# 题目信息

# 「KDOI-02」一个弹的投

## 题目背景

- 前置芝士：[平抛运动](https://baike.baidu.com/item/%E5%B9%B3%E6%8A%9B%E8%BF%90%E5%8A%A8/974021?fr=aladdin)
~~（看到这个如果不想做可以直接开下一题）~~

「这群该死的外星人，肯定是来抢夺新矿资源的！」  
「这导弹什么鬼啊，研究不明白。」  
无数的水滴型武器从苍穹之外落下，猛击着无知的生命。  

## 题目描述

经研究，该武器的运作方式是这样的。其中设重力方向为 $y$ 轴负半轴，$x$ 轴为地面，速度向右为正向左为负。  
- 每颗导弹在 $(x_i,y_i)$ 的地方投放并悬浮，初始速度设置为 $v_i$。
- 所有导弹投放完成后，于同一时刻开始照初始速度做平抛运动。其中 $g=9.8$。  
- 每颗导弹与另一颗导弹碰撞时，不会改变原来的路线，并且将爆破威力 $p_i$ 增加 $1$，所有导弹初始时 $p_i=0$，**在接触到 $x$ 轴时碰撞也增加威力**。
- 当武器落到 $x$ 轴时，会对落点造成 $p_i$ 点杀伤力。

地面指挥部提前预测了导弹的落点，并部署了反制武器。第 $i$ 台武器能将第 $i$ 枚导弹在降落至地面后的威力值减少 $a_i$（至多减少到 $0$）。但是，由于技术限制，只能启动其中 $m$ 台反制武器。地面指挥官想知道，导弹造成的爆炸威力值总和最小为多少。

## 说明/提示

**【样例解释】**

- **样例 1 解释：** 

	每颗导弹的爆炸威力值都是 $0$。
- **样例 2 解释：** 

	四枚导弹的爆炸威力值分别是 $0,1,1,0$，启动第 $2$ 或第 $3$ 台反制武器，最后爆炸威力值的和为 $1$。
    
- **样例 4 说明：**

   该样例满足测试点 $13\sim16$ 的限制。
***
**【数据范围】**

对于 $100\%$ 的数据，$1\le n\le5\times10^5$，$0\le a_i,m\le n$，$0\le |x_i|,y_i\le10^9$，$0\le |v_i|\le10^6$。  

**保证所有导弹起始坐标不相等。**

|测试点编号|$n\le$|特殊性质|
|:-:|:-:|:-:|
|$1\sim6$|$5000$|无|
|$7\sim10$|$12000$|无|
|$11\sim12$|$10^5$|有|
|$13\sim16$|$10^5$|无|
|$17\sim20$|$5\times10^5$|无|

特殊性质：保证所有 $y_i$ 均相同。  

**【提示】**

本题 I/O 量较大，推荐使用较快的 I/O 方式。

附平抛运动落点公式：  
$$x_t=x_i+v_i\sqrt{\dfrac{2y_i}g}$$

## 样例 #1

### 输入

```
3 0
1 1 -2
1 2 -1
1 3 1
1 1 1```

### 输出

```
0```

## 样例 #2

### 输入

```
4 1
-3 3 0
1 3 1
4 3 -4
-9 3 -7
1 3 2 3```

### 输出

```
1```

## 样例 #3

### 输入

```
见附件中的 missile3.in```

### 输出

```
见附件中的 missile3.ans```

## 样例 #4

### 输入

```
见附件中的 missile4.in```

### 输出

```
见附件中的 missile4.ans```

# AI分析结果



# 「KDOI-02」一个弹的投 题解分析

## 唯一算法分类
逆序对统计 + 贪心策略

---

## 核心思路与难点解析

### 关键算法流程
1. **按y轴分组**：所有导弹按初始y坐标分组，仅同组导弹可能碰撞  
2. **计算碰撞次数**：对每组导弹按初始x排序后，计算每个导弹的落点x的逆序对数量  
3. **贪心选择反制**：按每个导弹可减少的威力值（min(p_i,a_i)）降序选择前m个  

### 算法可视化设计
- **分组动画**：用不同颜色区块表示不同y组的导弹，动态展开各组计算过程  
- **逆序对统计**：  
  1. 初始x排序后显示导弹编号（如3→1→4→2）  
  2. 落点x离散化为柱状图，树状数组动态显示当前统计范围  
  3. 红蓝高亮当前导弹的落点位置与统计区域  
- **贪心选择**：用滑动窗口动画展示前m个最大减伤值的选取过程  

---

## 题解评分与亮点（≥4星）

### 1. Ray1（★★★★☆）
**亮点**：  
- 双树状数组正反统计逆序对  
- 清晰的分组处理逻辑  
- 时间复杂度O(n log n)最优  
**核心代码片段**：
```cpp
// 正序统计x_i < x_j且d_i >= d_j
for(int i=0;i<s;i++){
    t[x][i].d = upper_bound(d,d+s,t[x][i].d)-d;
    V[t[x][i].id] += get(t[x][i].d);
    add(t[x][i].d);
}

// 反序统计x_i > x_j且d_i <= d_j 
for(int i=s-1;i>=0;i--){
    V[t[x][i].id] += s-1-i - get(t[x][i].d-1);
    add(t[x][i].d);
}
```

### 2. 老官童鞋gogo（★★★★☆）
**亮点**：  
- 归并排序实现逆序对统计  
- 详细注释与调试经验分享  
**核心注释**：
```cpp
/* 归并时统计两种逆序：
   1. 左侧比当前大的（右侧贡献）
   2. 右侧比当前小的（左侧贡献）*/
while(p1<=mid&&p2<=r){
    if(bot[p1].to<bot[p2].to){
        f[bot[p1].num] += cnt; // 统计右侧已处理的小于值
        temp[p++] = bot[p1++];
    } else {
        cnt++; // 左侧剩余元素均会产生逆序
        f[bot[p2].num] += mid-p1+1;
        temp[p++] = bot[p2++];
    }
}
```

### 3. Hanx16Kira（★★★★☆）
**亮点**：  
- 离散化与树状数组的完整实现  
- 像素风格可视化建议  
**像素动画设计**：  
- 导弹初始位置用绿色像素块表示  
- 落点位置用红色箭头动态移动  
- 树状数组更新时显示蓝色光晕特效  

---

## 最优技巧提炼

### 逆序对快速统计
1. **双树状数组法**：  
   - 正序插入统计右侧较小值  
   - 逆序插入统计左侧较大值  
2. **离散化优化**：  
   ```cpp
   sort(d, d+s);
   double pos = upper_bound(d, d+s, curr_d) - d;
   ```

### 贪心策略优化
- 预处理可减伤值：`f[i] = min(p[i], a[i])`  
- 降序排序后取前m个：`sort(f+1, f+n+1, greater<int>())`

---

## 同类题目推荐
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)  
   **相似点**：逆序对基础模板  
2. [P3810 三维偏序](https://www.luogu.com.cn/problem/P3810)  
   **相似点**：分治与树状数组结合  
3. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)  
   **相似点**：贪心策略选择最优解  

---

## 个人心得摘录
> "考场上因为没开long long挂了20分，血的教训！所有累加操作必须检查范围" —— Laffey  
> "归并排序统计逆序时，要同时考虑左侧剩余元素和右侧已插入元素的贡献" —— 老官童鞋gogo

---

## 可视化算法演示（核心逻辑）

### 复古像素风格设计
1. **界面布局**：  
   - 左侧：导弹初始位置（8-bit飞机图标）  
   - 右侧：落点柱状图（红蓝像素条）  
   - 底部：树状数组状态显示（绿色格子表示已统计）  

2. **动画流程**：  
   ```js
   // 伪代码示例
   class Missile {
     constructor(x, y, v) {
       this.startX = x;
       this.endX = x + v * Math.sqrt(2*y/9.8); 
     }
   }

   function animateGroup(group) {
     group.sort((a,b) => a.startX - b.startX); // 初始x排序
     drawPixelGrid(group);
     
     // 正序统计
     let bit = new BinaryIndexedTree();
     group.forEach((m, idx) => {
       let pos = discreteEndX(m.endX);
       bit.add(pos);
       highlight(m, 'red');
       playSound('blip');
     });
     
     // 逆序统计
     bit.clear();
     [...group].reverse().forEach((m, idx) => {
       let pos = discreteEndX(m.endX);
       bit.add(pos);
       highlight(m, 'blue');
       playSound('blip');
     });
   }
   ```

3. **音效设计**：  
   - `blip.wav`：每次树状数组更新时播放（8-bit风格短音）  
   - `success.wav`：完成一组计算时播放（马里奥金币音效）

---

## 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 5e5+5;
const double g = 9.8;

struct Missile {
    int x,y,v,id;
    double ed;
    bool operator<(const Missile& o) const {
        return x < o.x; // 按初始x排序
    }
};

vector<Missile> group[N];
int p[N], a[N], reduce[N];

int main() {
    // 输入与分组
    int n,m; cin >> n >> m;
    map<int, int> yMap;
    for(int i=0; i<n; i++){
        Missile msl;
        cin >> msl.x >> msl.y >> msl.v;
        msl.ed = msl.x + msl.v * sqrt(2*msl.y/g);
        msl.id = i;
        if(!yMap.count(msl.y)) 
            yMap[msl.y] = yMap.size();
        group[yMap[msl.y]].push_back(msl);
    }

    // 计算每个导弹的p值
    for(auto& [y, vec] : group) {
        sort(vec.begin(), vec.end());
        vector<double> ends;
        for(auto& m : vec) ends.push_back(m.ed);
        sort(ends.begin(), ends.end());
        
        // 离散化
        auto getPos = [&](double ed) {
            return upper_bound(ends.begin(), ends.end(), ed) - ends.begin();
        };

        // 正反向统计逆序
        FenwickTree ft(ends.size());
        for(int i=0; i<vec.size(); i++){
            int pos = getPos(vec[i].ed);
            p[vec[i].id] += ft.query(pos);
            ft.update(pos, 1);
        }
        ft.clear();
        for(int i=vec.size()-1; i>=0; i--){
            int pos = getPos(vec[i].ed);
            p[vec[i].id] += ft.query(pos-1);
            ft.update(pos, 1);
        }
    }

    // 贪心选择
    ll total = accumulate(p, p+n, 0LL);
    for(int i=0; i<n; i++){
        cin >> a[i];
        reduce[i] = min(p[i], a[i]);
    }
    sort(reduce, reduce+n, greater<int>());
    total -= accumulate(reduce, reduce+m, 0LL);
    cout << max(total, 0LL);
}
```

---
处理用时：101.17秒
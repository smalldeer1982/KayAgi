# 题目信息

# 「KDOI-03」还原数据

## 题目描述

小 E 正在做一道经典题：

给定一个长度为 $n$ 的序列 $a$ 和 $q$ 个操作，操作共有 $2$ 种类型：

+ $\tt{1~l~r~x}$：对于所有 $l\le i\le r$，$a_i\leftarrow a_i+x$。
+ $\tt{2~l~r~x}$：对于所有 $l\le i\le r$，$a_i\leftarrow \max(a_i,x)$。

题目要求输出所有操作结束后的最终序列 $a'$。

小 E 迅速写了一份代码提交，但是发现，由于宇宙射线的影响，输入数据出现了一些小问题。具体地，对于所有 $2$ 操作，操作中给出的 $x$ 均被丢失了，也就是说，输入数据中的 $2$ 操作只剩下了 $\tt{2~l~r}$。输出数据则没有问题。小 E 现在想要通过剩余的数据恢复原来的输入数据，请你帮助他完成这个任务。

当然，可能会有多种合法的输入数据，你需要找到其中任意一种。数据保证有解。

## 说明/提示

**【样例 1 解释】**

所有合法输出需要满足：第 $1$ 个数 $\le3$，第 $2$ 个数恰好为 $20$。

**【样例 2】**

见选手文件中的 `restore/restore2.in` 与 `restore/restore2.ans`。

**【样例 3】**

见选手文件中的 `restore/restore3.in` 与 `restore/restore3.ans`。


***

**【数据范围】**

记 $q_2$ 为单组数据内 $2$ 操作的个数，$\sum n$ 为单个测试点内所有 $n$ 的和，$\sum q$ 为单个测试点内所有 $q$ 的和。

对于 $20\%$ 的数据，保证 $n,q\le50$，$\sum n,\sum q\le1~000$。

对于 $40\%$ 的数据，保证 $n,q\le1~000$，$\sum n,\sum q\le10^5$。

对于另外 $20\%$ 的数据，保证 $l=1,r=n$。

对于另外 $20\%$ 的数据，保证 $q_2\le100$。

对于 $100\%$ 的数据，保证 $1\le T\le 100$，$1\le n,q\le 10^5$，$1\le\sum n,\sum q\le 3\times10^5$，$-10^9\le a_i,x\le 10^9$，$-10^{15}\le a_i'\le10^{15}$， $q_2\ge1$。


***

**【校验器】**


本题样例文件较大，无法在附件中下载，请在选手文件中查看。

为了方便测试，在 $\texttt{restore}$ 目录下我们下发了 $\texttt{checker.cpp}$ 文件。你可以编译该文件，并使用它校验自己的输出文件。请注意它与最终评测时所用的校验器并不完全一致，你不需要也不应该关心其代码的具体内容。

编译命令为：

```plain
g++ checker.cpp -o checker -std=c++14
```

使用方式为：

```
./checker <inputfile> <outputfile> <answerfile>
```

校验器可能会返回以下状态中的其中一种：

+ $\tt{Accepted}$：表示你的输出完全正确。
+ $\tt{Wrong~answer~at~testcase~ x}$：表示你的输出在第 $x$ 个测试数据出错。

***

**【提示】**

本题输入输出量较大，推荐使用较快的输入输出方式。

KDOI 出题组温馨提示：**多测不清空，爆零两行泪。**


## 样例 #1

### 输入

```
1
5 3
1 2 3 4 5
2 3 5
1 3 4 2
2 1 1
20 2 5 6 5
```

### 输出

```
3 20```

# AI分析结果



## 算法分类
线段树、逆向思维

---

## 题解思路与算法要点

### 核心思路
**逆向处理操作序列**，通过线段树维护区间最小值与区间加减操作：
- **类型1操作**（原为区间加）在逆向处理时变为区间减。
- **类型2操作**（原为取max）的x值取当前区间的最小值，确保正向操作时所有数不会超过最终结果。

### 解决难点
1. **逆向处理**：正向操作中的取max会影响后续操作，逆向处理可避免复杂的前后依赖。
2. **区间最小值维护**：每次类型2操作的x必须满足 `x ≤ 当前区间最小值`，否则会导致正向操作后的值超过最终结果。
3. **数据结构选择**：线段树高效支持区间加减与区间最小值查询。

### 算法流程
1. **初始化线段树**：以最终序列为初始值。
2. **倒序遍历操作**：
   - 类型1操作：对线段树进行逆向加减（原加x变为减x）。
   - 类型2操作：查询区间最小值作为x，记录答案。
3. **输出结果**：按正向操作顺序输出记录的x值。

---

## 最优思路提炼
- **倒序处理操作**：将类型2操作的x推导转化为区间最小值查询。
- **线段树维护**：区间加减与最小值查询的完美结合。
- **关键结论**：类型2操作的x必须等于逆序处理时的区间最小值。

---

## 可视化算法设计

### 动画演示方案
1. **像素风格界面**：
   - **线段树节点**：用8位像素方块表示，颜色深浅反映节点值大小。
   - **当前操作**：高亮显示操作区间（红色框），类型2操作时显示最小值的闪烁效果。
2. **关键步骤动态展示**：
   - 类型1操作：区间方块颜色渐变表示值减少。
   - 类型2操作：显示红色箭头指向最小值，记录x值到右侧列表。
3. **音效与交互**：
   - **音效**：类型1操作播放“减号”音效，类型2操作播放“确认”音效。
   - **步进控制**：用户可暂停/继续，调整动画速度观察细节。

### 代码片段（线段树核心）
```cpp
struct SegTree {
    long long val[N << 2], tag[N << 2];
    void pushdown(int p) {
        val[p<<1] += tag[p]; val[p<<1|1] += tag[p];
        tag[p<<1] += tag[p]; tag[p<<1|1] += tag[p];
        tag[p] = 0;
    }
    void update(int p, int l, int r, int L, int R, int x) {
        if (L <= l && r <= R) { val[p] += x; tag[p] += x; return; }
        pushdown(p);
        int mid = (l + r) >> 1;
        if (L <= mid) update(p<<1, l, mid, L, R, x);
        if (R > mid) update(p<<1|1, mid+1, r, L, R, x);
        val[p] = min(val[p<<1], val[p<<1|1]);
    }
    long long query(int p, int l, int r, int L, int R) {
        if (L <= l && r <= R) return val[p];
        pushdown(p);
        int mid = (l + r) >> 1;
        long long res = LLONG_MAX;
        if (L <= mid) res = min(res, query(p<<1, l, mid, L, R));
        if (R > mid) res = min(res, query(p<<1|1, mid+1, r, L, R));
        return res;
    }
};
```

---

## 相似题目推荐
1. **P3372 线段树模板**（区间加、区间求和）
2. **P6242 线段树（动态开点）**（区间最值操作）
3. **P4198 楼房重建**（逆向思维与区间维护）

---

## 题解评分（≥4星）

### Error_Yuan（⭐⭐⭐⭐⭐）
- **亮点**：代码简洁高效，直接使用线段树核心功能，无冗余操作。
- **关键代码**：在类型2操作中反复查询最小值直至所有节点处理完毕。

### Sol1（⭐⭐⭐⭐）
- **亮点**：详细解释逆向推导过程，强调x的取值与后续操作的关系。
- **代码优化**：通过差分预处理类型1操作的总影响。

### Dregen_Yor（⭐⭐⭐⭐）
- **亮点**：完整注释与代码结构清晰，适合学习线段树基础。

---

## 个人心得摘录
> "逆向处理是关键——正向操作中的取max会被后续覆盖，逆向则每一步独立。"  
> "线段树的下传标记必须清零，否则多测会WA到怀疑人生。"

---

## 总结
本题通过逆向处理与线段树的结合，巧妙解决了操作间的依赖问题。关键点在于类型2操作的x值推导与区间维护，适合作为线段树与逆向思维的经典练习题。

---
处理用时：81.38秒
# 题目信息

# 『STA - R1』好吃的智慧果子

## 题目背景

在上古时代，$-(2077^{-1}\ \ (mod=2035))$ 年，$\mathfrak{Morlin}$ 种下了一棵非常珍贵的$\colorbox{black}{\textcolor{red}{\textbf{智♂慧♂树♂}}}$，被 $\mathfrak{char\_phi}$ 看见了。

过了 $114810$ 年，树上结出了 $\colorbox{black}{\textcolor{blue}{\textbf{智♂慧♂果♂子♂}}}$。  
又过了 $1919514$ 年，果子成熟了，$\mathfrak{char\_phi}$ 非常馋。

$\mathfrak{char\_phi}$ 十分想吃果子，但是~~神机妙算的~~ $\mathfrak{Morlin}$ 早就知道 $\mathfrak{char\_phi}$ 想要吃他的果子，所以把每个果子都装进了密码箱。

现在，$\mathfrak{char\_phi}$ 把偷果子这项重任托付给了你。  

## 题目描述

**形式化题面**

维护一个序列 $\{a_n\}$，每次操作给五个非负整数 $l, r, k, p, c$，对于所有 $i\in[l,r]$，将 $a_i\gets (f_{a_i}^k+c)\bmod p$。

其中 $f$ 是 Fibonacci 数列，定义为：
$$f_n=\begin{cases}n&n\leqslant 1\\f_{n-1}+f_{n-2}&n>1\end{cases}$$
***

**原题面**

~~神机妙算的~~ $\mathfrak{Morlin}$ 早就知道 $\mathfrak{char\_phi}$ 很聪明，所以他会不定时改密码。

每个密码箱上有一个数字，组成了数列 $\{a_n\}$。

关于密码有 $m$ 次操作，每次操作给定五个整数 $l, r, k, p, c$，表示将满足 $l \leqslant i \leqslant r$ 将 $a_i$ 变成 $(f_{a_i}^k+c) \bmod p$（$f_i$ 代表斐波那契数列的第 $i$ 项；保证 $l \leqslant r$）。

$\mathfrak{char\_phi}$ 搞了一个记录器记录下了 $\mathfrak{Morlin}$ 的操作。现在，他把记录器给了你，希望你能在 $\mathfrak{Morlin}$ 操作完后搞出所有密码箱的密码。

## 说明/提示

**【数据范围】**

**本题采用捆绑测试。**

| Subtask | $\bm{n,m\leqslant}$ | 分值 | 特殊性质 |
| :--: | :--: | :--: | :--: |
| $1$ | $10^3$ | $10$ | 无 |
| $2$ | $10^5$ | $10$ | $p \leqslant 2$ |
| $3$ | $10^5$ | $20$ | $p \leqslant 3$ |
| $4$ | $10^5$ | $60$ | 无 |

对于 $100\%$ 的数据，$1 \leqslant n, m \leqslant 10^5$，$1 \leqslant a_i, p, k \leqslant 100$，$0 \leqslant c \leqslant 10^9$。

## 样例 #1

### 输入

```
6 2
1 1 4 5 1 4
2 4 2 100 3
3 5 1 97 5```

### 输出

```
1 4 52 44 6 4```

# AI分析结果



**唯一算法分类**：线段树/映射维护

---

### **题解思路、算法要点与解决难点**
1. **核心思路**  
   - **值域映射**：观察到每次操作对每个数的影响仅取决于其当前值，且值域较小（≤100），可将每个操作转化为映射函数 `f: [0,100] → [0,p)`。  
   - **映射复合**：多个操作连续作用等价于映射的复合，满足结合律，可用线段树维护区间映射的复合结果。  
   - **预处理优化**：预先计算所有可能的斐波那契数模p后的幂次，避免重复计算。

2. **解决难点**  
   - **高效合并操作**：通过线段树的延迟标记（lazy propagation）合并映射，每次合并复杂度为O(100)。  
   - **正确预处理**：对每个可能的 `a_i`、`p`、`k` 预处理 `f(a_i)^k mod p`，确保快速查询。

3. **对比题解**  
   - **joke3579**：使用线段树直接维护映射数组，每个节点存储当前区间的复合映射。  
   - **Lgx_Q**：事件排序+线段树维护生效操作，可能实现复杂且预处理需验证。  
   - **Fzrcy**：结构体封装映射，代码简洁，预处理方式与首解类似。  
   - **鲤鱼江**：快速读写的优化，映射合并逻辑一致，适合大输入规模。

---

### **题解评分 (≥4星)**
1. **joke3579（5星）**  
   - **亮点**：思路清晰，预处理与线段树实现高效，代码结构规范。  
   - **核心代码**：  
     ```cpp
     struct permu {
         int p[R];
         permu() { iota(p, p + R, 0); }
         permu &operator *= (const permu &rhs) { /*复合映射*/ }
     };
     void assign(int p, int l, int r, int L, int R, const permu& pr) {
         if (L <= l && r <= R) { tr[p] *= pr; return; }
         // 下传标记并递归
     }
     ```

2. **Fzrcy（4星）**  
   - **亮点**：结构体封装映射，代码简洁，预处理部分高效。  
   - **核心代码**：  
     ```cpp
     struct dsu{ int vt[V]; };
     dsu operator + (dsu b) { /*合并映射*/ }
     void modify(int k, int l, int r, int x, int y, dsu v) {
         // 线段树区间更新
     }
     ```

3. **鲤鱼江（4星）**  
   - **亮点**：快速IO优化，映射合并逻辑清晰，适合大规模数据。  
   - **核心代码**：  
     ```cpp
     struct Per{ int v[101]; void operator*=(const Per &t){ /*复合*/ } };
     void update(int now, int l, int r, int x, int y) {
         // 应用映射到区间
     }
     ```

---

### **最优思路或技巧提炼**
1. **值域映射预处理**  
   - 对每个操作参数 `(k, p, c)`，预处理所有 `a_i ∈ [0,100]` 的映射结果 `(f(a_i)^k + c) % p`，时间复杂度 O(100³)。  
2. **线段树维护复合映射**  
   - 每个线段树节点存储一个映射数组，标记下传时合并映射，时间复杂度 O(100 log n)。  
3. **延迟标记优化**  
   - 通过延迟传播减少不必要的递归，确保每次操作均摊复杂度为 O(log n)。

---

### **同类型题或类似算法套路**
- **区间函数复合**：如 CF1743F（区间覆盖函数的复合）、[NOIP2022] 比赛（区间统计类问题）。  
- **值域有限的操作**：如区间取模、区间哈希变换等，可通过预处理映射优化。

---

### **推荐洛谷题目**
1. **P3372 【模板】线段树 1**（区间加、求和）  
2. **CF1743F Intersection of Permutations**（区间映射复合）  
3. **P6492 [COCI2010-2011#6] STEP**（区间操作与性质维护）

---

### **可视化与算法演示**
1. **动画方案**  
   - **网格绘制**：以像素网格表示线段树节点，每个节点显示其映射数组。  
   - **颜色标记**：  
     - 当前操作的区间用高亮边框标记。  
     - 映射数组中修改的值用红色闪烁显示。  
   - **步进控制**：允许单步执行操作，观察映射如何合并到下层的节点。  
2. **复古像素风格**  
   - **8位调色板**：线段树节点用绿色（未更新）、黄色（延迟标记）、红色（当前操作）。  
   - **音效触发**：  
     - 映射合并时播放“哔”声，操作完成时播放上升音阶。  
3. **AI自动演示**  
   - 自动按顺序应用所有操作，展示映射如何从根节点传播到叶子节点。

---

### **个人心得摘录**
- **预处理的重要性**：在值域有限时，牺牲空间预处理所有可能情况，大幅减少运行时计算量。  
- **延迟标记的威力**：通过延迟合并映射，避免每次操作都递归到底层，极大优化时间复杂度。  
- **调试技巧**：验证小规模数据（如p=2）的映射结果，确保预处理和复合逻辑正确。

---
处理用时：70.58秒
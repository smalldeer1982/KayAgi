# 题目信息

# [KMOI R1] 五五五五（Hard）

## 题目背景

“事类相推，各有攸归，故枝条虽分而同本干知，发其一端而已。又所析理以辞，解体用图，庶亦约而能周，通而不黩，览之者思过半矣。”——刘徽


## 题目描述

小宋有一个序列 $A=\{a_1,a_2\dots,a_n\}$，其中 $\forall i\in [1,n],a_i\in[0,9]$。

对于 $1\le l\le r\le n$，他记 $f(l,r)$ 等于 $\overline{a_la_{(l+1)}\dots a_r}$ 的末尾连续 $5$ 的个数。

例如：对于序列 $a=\{1,1,4,5,1,4\}$，$f(2,4)=1,f(1,3)=0$。

不过小宋会对这个序列不断地操作，具体地，他会做以下操作：

- $(1,x,y)$：将第 $x$ 个数改为 $y$（$x\in[1,n],y\in[0,9]$）。

- $2$: 将序列 $a$ 反转，例如 $\{1,1,4,5\}$ 反转之后就是 $\{5,4,1,1\}$。

- $3$：对序列进行询问。

- $(4,l,r)$：对序列进行询问。

对于每一种操作 $3$，请你输出:

$$\Big(\sum\limits_{l=1}^
{n}\sum\limits_{r=l}^{n} f(l,r)\Big) \bmod 10^9+7$$

对于每一个操作 $4$，请你输出：

$$\Big(\sum\limits_{i=l}^{r}a_i\Big) \bmod 10^9+7$$

## 说明/提示

## 样例 $1$ 解释：

| 操作 | 操作后的序列 | 答案 |
| :----------: | :----------: | :----------: |
| $(1,3,3)$ | $\{1,5,3\}$ | $/$ |
| $3$ | $/$ | $2$ |
| $(1,1,5)$ | $\{5,5,3\}$ | $/$ |
| $(4,1,3)$ | $/$ | $13$ |

## 样例 $2$ 解释：

| 操作 | 操作后的序列 | 答案 |
| :----------: | :----------: | :----------: |
| $3$ | $/$ | $4$ |
| $2$ | $\{4,1,5,4,1,1\}$ | $/$ |
| $3$ | $/$ | $3$ |
| $(1,1,5)$ | $\{5,1,5,4,1,1\}$ | $/$ |
|$(4,1,4)$|$/$|$15$|
## 数据范围
| 测试点编号 | $n\le$ |$q\le$| 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
|$1$|$100$|$100$|$/$|
|$2,3$|$10^3$|$10^3$|$\mathbf{A}$|
|$4$|$10^3$|$10^3$|$\mathbf{B}$|
|$5\sim10$|$2\times 10^5$|$2\times 10^5$|$/$|
|$11\sim13$|$2\times 10^5$|$2\times 10^5$|$\mathbf{A}$|
|$14,15$|$2\times 10^5$|$2\times 10^5$|$/$|
|$16\sim18$|$5\times 10^5$|$5\times 10^5$|$\mathbf{B}$|
|$19\sim25$|$5\times 10^5$|$5\times 10^5$|$/$|

特殊性质 $\mathbf{A}:$ 没有操作 $2$。

特殊性质 $\mathbf{B}:$ 没有操作 $3$。

对于 $100\%$ 的数据：$1\le n\le 5\times 10^5$，$1\le q\le 5\times 10^5$。

 $\forall i\in [1,n]$，满足 $a_i\in[0,9]$。

## 样例 #1

### 输入

```
3 4
1 5 5
1 3 3
3
1 1 5
4 1 3```

### 输出

```
2
13```

## 样例 #2

### 输入

```
6 5
1 1 4 5 1 4
3
2
3
1 1 5
4 1 4```

### 输出

```
4
3
15```

# AI分析结果



---

## 算法分类
线段树 + 数据结构维护连续段

---

## 题解思路与核心难点分析

### 核心思路
所有题解均围绕如何高效维护**连续5的贡献**和**反转操作**展开。核心思路分为两类：

1. **双线段树镜像维护**（Fire_flame、lovely_hyzhuo等）  
   - 维护正向/反向两棵线段树，反转操作通过标记切换  
   - 线段树节点存储：区间和、前缀连续5长度、后缀连续5长度、总贡献  
   - 修改操作同步更新两棵树，查询时根据标记选择对应树

2. **Set维护极长连续段**（Ginger_he、hanjinghao等）  
   - 用set存储所有极长连续5的区间  
   - 维护正反两个贡献总和，反转时交换总和变量  
   - 修改时分裂/合并相邻区间并重新计算贡献

### 解决难点对比
| 方法                | 核心难点解决方案                                                                 |
|---------------------|--------------------------------------------------------------------------------|
| 线段树镜像法        | 定义特殊线段树合并规则：`s5 = 左区间后缀5 + 右区间前缀5`，动态计算跨区间贡献        |
| Set维护极长连续段法 | 推导连续段贡献公式，修改时通过`upper_bound`快速定位相邻区间，数学计算贡献变化量      |

### 算法选择建议
- **线段树法**：适合高频查询场景（操作3），时间复杂度稳定为`O(n + q log n)`  
- **Set法**：适合低频查询场景，代码量较少但需处理复杂数学公式

---

## 题解评分（≥4星）

### Fire_flame（5星）
- **亮点**：完整定义线段树合并规则，镜像维护解决反转  
- **代码**：通过`pushup`函数实现跨区间贡献计算，处理`l5`和`r5`的合并逻辑清晰

### Ginger_he（5星）
- **亮点**：数学推导极长连续段贡献公式，set维护实现优雅  
- **核心代码**：
  ```cpp
  int calc3(int l, int r) { // 计算区间贡献
      int t = r - l + 1;
      return ((1ll*(r+1)*t*(t+1)/2 - t*(t+1)*(2*t+1)/6) % mod + mod) % mod;
  }
  ```

### hanjinghao（4星）
- **亮点**：双树状数组分别维护正反序列和，set维护极长段  
- **优化**：贡献计算使用预处理的`f`数组加速

---

## 最优思路提炼

### 关键技巧
1. **镜像数据结构**：用正反两套结构应对反转操作，通过标记切换查询源  
2. **贡献公式分解**：将连续段贡献分解为`Σi*(L - i + 1)`，化简为多项式计算  
3. **极长区间维护**：通过set的`upper_bound`快速定位修改点影响的相邻区间

### 实现示例（线段树法）
```cpp
struct node {
    int l5, r5, s5, sum; // 前缀5长、后缀5长、总贡献、区间和
    // 合并规则示例
    node operator+(const node& rhs) {
        node res;
        res.l5 = (l5 == sz ? sz + rhs.l5 : l5);
        res.r5 = (rhs.r5 == rhs.sz ? rhs.sz + r5 : rhs.r5);
        res.s5 = s5 + rhs.s5 - calc(r5) - calc(rhs.l5) + calc(r5 + rhs.l5);
        return res;
    }
};
```

---

## 类似题目推荐
1. **P5490 扫描线** - 线段树维护区间覆盖  
2. **P3373 线段树2** - 双标记线段树  
3. **P6136 普通平衡树** - set维护动态区间

---

## 可视化设计（复古像素风格）

### 动画演示逻辑
1. **网格布局**：将序列映射为像素网格，每个格子表示一个数字  
2. **颜色编码**：  
   - 红色：当前修改位置  
   - 绿色：连续5区间  
   - 黄色：线段树节点合并时的跨区间贡献  
3. **音效触发**：  
   - `1.5kHz`短音：修改操作  
   - `800Hz`长音：区间合并  
   - 8-bit音乐：反转时播放旋律反转音效

### 交互示例
```javascript
// 伪代码：修改操作动画
function animateModify(pos, val) {
    grid[pos].color = RED; 
    playSound('beep1'); // 修改音效
    setTimeout(() => {
        grid[pos].value = val;
        if (val == 5) grid[pos].color = GREEN;
        else grid[pos].color = WHITE;
        updateTreePath(pos); // 高亮线段树更新路径
    }, 200);
}
```

---

## 总结
本题核心在于**动态维护连续段贡献**，通过镜像数据结构或数学推导实现高效更新。线段树法适合追求稳定性的场景，而Set法在代码简洁性上更优。复古可视化通过颜色编码和音效强化关键操作，使算法流程更直观。

---
处理用时：70.44秒
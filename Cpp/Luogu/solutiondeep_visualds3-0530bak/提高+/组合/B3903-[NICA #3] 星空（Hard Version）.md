# 题目信息

# [NICA #3] 星空（Hard Version）

## 题目背景

**Easy Version 和 Hard Version 差别在于数据范围。**

## 题目描述

小 R 有一个长度为 $n$ 的序列 $a$，保证序列中的每个数都是 $2$ 的整数次幂。

小 M 有一个数 $x$，她希望重新排列序列 $a$，使得不存在一个 $i\in[1,n)$ 满足 $a_i+a_{i+1}>x$。重排的方式为：选择一个 $1\sim n$ 的排列 $p$，然后令新序列 $a'$ 满足 $a'_i=a_{p_i}$。$a'$ 即为重排后的序列。

现在你想要知道有多少种重排的方式能满足小 M 的要求。两种重排方式不同当且仅当选择的排列 $p$ 不同。

## 说明/提示

数据保证，$2 \leq n \leq 10^5$，$1 \leq a_i \leq 2^{60}$，$1 \leq x < 2^{63}$。

## 样例 #1

### 输入

```
6 46
4 8 8 16 32 32```

### 输出

```
144```

# AI分析结果



### 唯一算法分类
组合数学 + 贪心分类

---

### 综合分析与结论

#### 核心思路
所有题解均基于以下步骤：
1. **分类元素**：按数值与 x 的关系分为关键类（B/黑球）、冲突类（A/灰球）、安全类（C/白球）。
2. **合法性检查**：存在元素 ≥x 时无解，x 为 2 的幂次时任意排列均合法。
3. **排列构造**：
   - 先排列安全类元素，形成基础结构。
   - 将关键类元素插入安全类的间隙，确保不相邻。
   - 将冲突类元素插入剩余间隙，避免与关键类相邻。

#### 解决难点
- **分类正确性**：需确保冲突类仅与关键类冲突，安全类与所有元素兼容。
- **组合计算**：利用阶乘预处理与组合数公式快速计算排列方案。

#### 可视化设计
- **像素动画**：用不同颜色方块表示三类元素（如红=关键，蓝=冲突，绿=安全）。
- **动态插入**：显示安全类排列成行后，红块逐个插入间隙，蓝块随后插入剩余间隙。
- **音效反馈**：插入成功时播放轻快音效，非法插入（如红块相邻）触发警告音。
- **自动演示**：模拟排列过程，右侧显示当前组合数计算步骤。

---

### 题解清单（评分≥4星）

1. **GTAH2333（4星）**
   - **亮点**：严格分类与数学公式推导，预处理阶乘优化计算。
   - **代码缺陷**：变量命名模糊（如 `k1, k2, k3`），影响可读性。

2. **ccxswl（5星）**
   - **亮点**：清晰的三类划分与组合数公式，代码结构简洁高效。
   - **优化点**：直接处理阶乘逆元，逻辑流畅，可读性强。

---

### 最优思路与技巧提炼

1. **分类策略**：
   - **关键类（B）**：x 的最高位对应的 2 的幂次。
   - **冲突类（A）**：与 B 相加 >x 且自身 ≤x/2。
   - **安全类（C）**：与任意元素相加 ≤x。

2. **组合构造**：
   - 安全类排列后形成 `c+1` 个间隙，插入 B 类元素的方式为组合数 `C(c+1, b)`。
   - 剩余间隙数为 `t = c+1 - b`，插入 A 类的方式为 `C(a + t - 1, t - 1)`。

3. **阶乘优化**：
   - 预处理阶乘与逆元，O(1) 计算组合数，应对大模数下的高效计算。

---

### 核心代码实现（ccxswl 解法）

```cpp
int main() {
  int n, X; cin >> n >> X;
  // 预处理阶乘与逆元
  vec<int> fc(n*2+3), ifc(n*2+3);
  fc[0] = 1;
  for(int i=1; i<=n*2; i++) fc[i] = fc[i-1] * i % mod;
  ifc[n*2] = qpow(fc[n*2], mod-2);
  for(int i=n*2-1; i>=0; i--) ifc[i] = ifc[i+1] * (i+1) % mod;

  // 分类元素
  int A = 0, B = 0, C = 0;
  ll tmp = 最高位值; // 根据 x 计算得到
  for(int a_i : a) {
    if(a_i == tmp) B++;
    else if(a_i > (tmp/2)) A++;
    else C++;
  }

  // 计算组合数
  int t = C + 1 - B;
  int ans = C(C+1, B) * C(A+t-1, t-1) % mod;
  ans = ans * fc[A] % mod * fc[B] % mod * fc[C] % mod;
  cout << ans;
}
```

---

### 相似题目推荐
1. **P2181 对角线**（组合数计算间隙插入问题）
2. **P3223 [HNOI2012] 排队**（排列限制下的组合数学）
3. **P1375 小朋友的数字游戏**（元素分类与排列约束）

---

### 可视化算法演示
- **Canvas 绘制**：
  - 初始化三色方块队列，按类分组。
  - 安全类（绿）排列为直线，红块插入间隙后蓝块填充。
- **步进控制**：用户点击触发下一步，显示当前插入位置与组合数更新。
- **状态面板**：实时显示已插入元素数、剩余间隙数、当前贡献的乘数因子。

---

### 个人心得摘录
- **GTAH2333**：通过数学归纳法验证分类正确性，强调二进制幂次的唯一性。
- **ccxswl**：调试中发现 x 为 2 的幂次需单独处理，否则组合数计算错误。

---
处理用时：93.89秒
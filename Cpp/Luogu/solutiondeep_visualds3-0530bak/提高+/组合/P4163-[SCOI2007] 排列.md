# 题目信息

# [SCOI2007] 排列

## 题目描述

给一个数字串 $s$ 和正整数 $d$, 统计 $s$ 有多少种不同的排列能被 $d$ 整除（可以有前导 $0$）。例如 $123434$ 有 $90$ 种排列能被 $2$ 整除，其中末位为 $2$ 的有 $30$ 种，末位为 $4$ 的有  $60$ 种。

## 说明/提示

$100\%$ 的数据满足：$s$ 的长度不超过 $10$，$1\le d\le 1000$，$1\le T\le 15$。

在前三个例子中，排列分别有 $1,3,3628800$ 种，它们都是 $1$ 的倍数。

## 样例 #1

### 输入

```
7
000 1
001 1
1234567890 1
123434 2
1234 7
12345 17
12345678 29```

### 输出

```
1
3
3628800
90
3
6
1398
```

# AI分析结果



## 算法分类
动态规划（状压DP）

---

## 题解思路与核心难点

### 核心思路
通过状压DP记录状态集合和余数，动态转移时避免重复计算相同数字的排列。设 `dp[S][k]` 表示选中的数字集合为状态 `S`，当前数对 `d` 取余为 `k` 的方案数。转移时枚举未选位置，若当前数字未被处理过则更新状态，防止同一状态中重复处理相同数字的不同位置。

### 解决难点
1. **重复数字处理**：在状态转移时，用临时数组标记当前数字是否已处理，确保同一状态下相同数字的不同位置仅处理一次。
2. **状态转移优化**：通过预处理每个状态的可用位置，减少无效枚举。
3. **时间复杂度**：优化后复杂度为 `O(T * 2^len * len * d)`，适用于 `len ≤ 10`。

---

## 题解评分（≥4星）

1. **Monster_Qi（5星）**  
   - **亮点**：在转移时通过标记去重，无需后处理，代码简洁高效。
   - **调试心得**：通过临时数组 `b` 避免重复转移，确保正确性。

2. **传奇英雄（4星）**  
   - **亮点**：预处理状态转移路径，优化常数，代码运行速度快。
   - **优化点**：提前计算状态的可选位置，减少循环次数。

3. **jins3599（4星）**  
   - **亮点**：代码可读性强，最后通过阶乘除法去重，思路清晰。
   - **注意点**：需确保输入中重复数字的处理正确。

---

## 最优思路与技巧

### 关键技巧
1. **状压DP状态设计**：用二进制位表示选中集合，余数作为第二维。
2. **动态转移去重**：在每步转移时，通过标记数组跳过已处理的相同数字。
3. **预处理优化**：提前计算每个状态的可用位置，加速状态转移。

### 通用解法
- 对于排列问题中的重复数字，可在转移时标记或最后除以阶乘。
- 状压DP适用于小规模（`n ≤ 20`）的集合选择问题。

---

## 相似题目
1. **P1896 [SCOI2005] 互不侵犯**（状压DP）
2. **P1433 吃奶酪**（状压DP + 路径优化）
3. **P3052 [USACO12MAR] Cows in a Skyscraper G**（状压DP + 分组优化）

---

## 可视化设计

### 动画方案
1. **状态转移网格**：在Canvas中绘制二进制状态和余数网格，高亮当前状态 `S` 和余数 `k`。
2. **颜色标记**：选中位置用绿色高亮，当前处理数字用红色标记。
3. **步进控制**：支持暂停/继续，单步查看转移过程。

### 复古像素风格
- **颜色方案**：8位色（深蓝背景、亮绿状态块、红黄标记）。
- **音效**：转移时播放电子音效，完成时播放胜利音调。
- **自动演示**：按BFS顺序遍历状态，动态展示余数变化。

---

## 核心代码实现

```cpp
#include <cstring>
#include <iostream>
using namespace std;

const int MAXN = 11;
int T, d, a[MAXN], dp[1<<MAXN][1000];
char s[MAXN];

int main() {
    scanf("%d", &T);
    while (T--) {
        memset(dp, 0, sizeof(dp));
        scanf("%s%d", s, &d);
        int len = strlen(s);
        for (int i = 0; i < len; i++) 
            a[i] = s[i] - '0';
        
        dp[0][0] = 1;
        for (int S = 0; S < (1 << len); S++) {
            bool used[10] = {0}; // 标记当前数字是否已处理
            for (int j = 0; j < len; j++) {
                if (S & (1 << j) || used[a[j]]) continue;
                used[a[j]] = true;
                for (int k = 0; k < d; k++) {
                    int new_k = (k * 10 + a[j]) % d;
                    dp[S | (1 << j)][new_k] += dp[S][k];
                }
            }
        }
        printf("%d\n", dp[(1 << len) - 1][0]);
    }
    return 0;
}
```

---

## 个人心得摘录
- **Monster_Qi**：发现同一状态下重复数字会导致错误转移，通过临时数组标记避免重复。
- **ppp204**：调试中发现全排列会重复计算，最终通过阶乘除法去重。

---

## 总结
本题通过状压DP高效处理排列问题，关键是在状态转移时即时去重，避免重复计算。理解题意中“不同排列”的定义对选择去重方式至关重要。

---
处理用时：391.42秒
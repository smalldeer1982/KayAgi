# 题目信息

# 「KDOI-04」Pont des souvenirs

## 题目背景

虽然这是一个 C，但是

![](https://cdn.luogu.com.cn/upload/image_hosting/dzj8va56.png)

## 题目描述

给定正整数 $n,k$，求有多少个长度为 $n$ 的正整数序列 $a$ 满足：

* $0<a_1\le a_2\le a_3\le\cdots\le a_n\le k$；
* $\forall\ i\not=j$，$a_i+a_j\le k+1$。

答案对 $10^9+7$ 取模。

## 说明/提示

**【样例解释】**

对于第 $1$ 组测试数据，所有满足要求的序列为 $(1,1)$ 和 $(1,2)$。

对于第 $2$ 组测试数据，所有满足要求的序列为 $(1)$，$(2)$ 和 $(3)$。

**【数据范围】**

对于 $100\%$ 的数据，保证 $1\le T\le2\times10^5$，$1\le n,k\le10^7$。

**本题开启捆绑测试。**

|子任务编号|分值|$T\le$|$n\le$|$k$|
|:-:|:-:|:-:|:-:|:-:|
|$1$|$8$|$5$|$5$|$\le5$|
|$2$|$3$|$10^5$|$10^7$|$=1$|
|$3$|$3$|$10^5$|$10^7$|$=2$|
|$4$|$8$|$10^5$|$10^7$|$=3$|
|$5$|$16$|$10$|$200$|$\le200$|
|$6$|$16$|$10$|$3000$|$\le3000$|
|$7$|$8$|$10^4$|$10^7$|$\le5$|
|$8$|$8$|$100$|$10^7$|$\le10^5$|
|$9$|$30$|$2\times10^5$|$10^7$|$\le10^7$|


## 样例 #1

### 输入

```
5
2 2
1 3
4 5
4030 218
1145 1419
```

### 输出

```
2
3
20
571656908
172735629
```

# AI分析结果



## 唯一算法分类
组合数学

---

## 综合分析与结论

### 核心思路
本题的核心在于将序列约束条件转化为组合数学问题。关键发现：
1. 非降序列中任意两数之和≤k+1的条件等价于最大两个元素之和≤k+1
2. 将序列构造问题转化为两个组合数求和问题，利用组合数公式+预处理实现O(1)查询

### 解决难点
1. **条件转化**：通过序列单调性将二维约束降为一维约束
2. **组合数推导**：利用隔板法思想建立序列构造与组合数的映射关系
3. **预处理优化**：通过线性预处理阶乘和逆元实现组合数O(1)计算

### 可视化设计
1. **像素动画**：展示阶乘预处理过程，每个阶乘计算步骤对应一个像素块填充
2. **组合数推导**：用动态路径展示从序列构造到组合数公式的转化过程
3. **音效反馈**：预处理完成时播放合成音效，组合数计算时触发8bit音效
4. **自动演示**：按步骤展示约束转化、公式推导、预处理、查询四阶段

---

## 题解清单 (≥4星)

### 1. Polaris_Australis_ 的做法6（5星）
**亮点**：
- 完美运用组合数求和公式化简式子
- 最终形式为两个组合数之和，复杂度最优
- 包含详尽的数学推导过程

### 2. hcywoi 的题解（4星）
**亮点**：
- 通过隔板法直观解释序列构造
- 详细拆分k的奇偶性情况
- 提供完整预处理代码模板

### 3. 李34 的代码实现（4星）
**亮点**：
- 代码简洁高效，完美体现最终公式
- 处理k的奇偶性方式优雅
- 包含完整的预处理和查询逻辑

---

## 核心代码实现
```cpp
constexpr int V = 2e7;
int fact[V + 1], inv[V + 1], ifact[V + 1];

void init() {
    fact[0] = inv[0] = ifact[0] = 1;
    fact[1] = inv[1] = ifact[1] = 1;
    for(int i=2; i<=V; ++i) {
        fact[i] = 1LL * fact[i-1] * i % MOD;
        inv[i] = 1LL * (MOD - MOD/i) * inv[MOD%i] % MOD;
        ifact[i] = 1LL * ifact[i-1] * inv[i] % MOD;
    }
}

int solve(int n, int k) {
    int c1 = (k + 1) / 2; // ceil(k/2)
    int c2 = k / 2;       // floor(k/2)
    int ans = (C(n + c1 - 1, n) + C(n + c2 - 1, n)) % MOD;
    return (n == 1) ? k : ans; // 特判n=1
}

int C(int n, int k) {
    return 1LL * fact[n] * ifact[k] % MOD * ifact[n - k] % MOD;
}
```

---

## 同类型题目推荐
1. P4369 组合数问题（组合数性质应用）
2. P1495 曹冲养猪（模数处理与组合思维）
3. P3197 越狱（约束条件下的组合计数）

---

## 可视化设计要点
1. **阶乘预处理动画**：每个阶乘计算时，右侧像素条长度+1，伴随"嘟"音效
2. **组合数路径演示**：在网格中绘制从(0,0)到(n,k)的路径表示组合数
3. **约束转化演示**：用两个像素小人分别代表aₙ₋₁和aₙ，动态显示相加过程
4. **自动推导模式**：按空格键分步展示公式推导过程，关键步骤高亮显示

---

## 个人心得摘录
"在草稿纸反复推导组合数求和公式时，突然意识到可以用上指标求和定理，那一刻的顿悟如同打通任督二脉" —— 来自题解作者调试经历

---

## 复古游戏化实现
```html
<canvas id="pixelCanvas"></canvas>
<script>
// 8-bit风格颜色配置
const COLORS = ['#000000','#1D2B53','#7E2553','#008751',
               '#AB5236','#5F574F','#C2C3C7','#FFF1E8'];

class FactorialAnimation {
  constructor() {
    this.progress = 0;
    this.sound = new Audio('data:audio/wav;base64,UklGRl...'); // 8bit音效
  }
  
  drawPixel(ctx, x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*16, y*16, 16, 16);
  }

  async run() {
    const ctx = document.getElementById('pixelCanvas').getContext('2d');
    for(let i=1; i<=V; i++) {
      this.drawPixel(ctx, i%100, Math.floor(i/100), COLORS[i%7]);
      if(i%1000 === 0) this.sound.cloneNode().play();
      await new Promise(r => setTimeout(r, 5));
    }
  }
}
</script>
```

---
处理用时：71.83秒
# 题目信息

# 串串题

## 题目描述

给定长度分别为 $n,m$ 的整数序列 $A,B$ 和常数 $W,d$，序列从 $1$ 开始标号，保证 $A_i,B_i \in [1,W]$。

容易发现，我们有 $\binom{W}{d}$ 种方案选择 $[1,W]$ 中的 $d$ 个互不相同的整数。

对于每一种选择的方案，我们删去 $A$ 中出现的对应的 $d$ 种整数，令此时序列 $B$ 在序列 $A$ 中的出现次数为这次选择方案的权值。

你需要求所有的选择方案的权值和，对 ${10}^9+7$ 取模。

若对题意有疑问，请阅读样例及样例解释。

注：$\binom{a}{b}$ 表示组合数，含义为在 $a$ 个物品中**无序**地选择出 $b$ 个物品的方案数。

**请注意：我们并不会删除序列 $\bm{B}$ 中出现的对应整数。**

## 说明/提示

**【样例解释】**

在样例的第一组数据中：

1. 如果我们选择删去 $A$ 中的字符 $1$，$A$ 将变为 $\{2\}$，此时 $B$ 在 $A$ 中的出现次数为 $0$。
1. 如果我们选择删去 $A$ 中的字符 $2$，$A$ 将变为 $\{1,1,1\}$，此时 $B$ 在 $A$ 中的出现次数为 $2$。
1. 如果我们选择删去 $A$ 中的字符 $3$，$A$ 将变为 $\{1,1,2,1\}$，此时 $B$ 在 $A$ 中的出现次数为 $1$。

因此，第一组数据的答案为 $0+2+1=3$。

**再次提醒：我们并不会删除序列 $\bm{B}$ 中出现的对应整数。**

---

**【数据范围】**

对于 $100\%$ 的数据，$1 \le n,m,W \le {10}^6$，$1 \le d, A_i, B_j \le W$，$1 \le T \le 5$。

**本题采用捆绑测试且开启子任务依赖！**

| 子任务 | $n \le$ | $m \le$ | $W \le$ | 特殊性质 | 分数 | 依赖 |
| - | - | - | - | - | - | - |
| 1 | $10$ | $10$ | $5$ | | $10$ | \ |
| 2 | $1000$ | $1000$ | $5$ | | $20$ | 子任务 1 |
| 3 |  | | | A | $15$ | \ |
| 4 |  | | | B | $25$ | \ |
| 5 | | | | | $30$ | 子任务 1、2、3、4 |

特殊性质 A：保证 $d=1$。

特殊性质 B：令 $c$ 表示仅在序列 $A$ 中出现，而不在序列 $B$ 中出现的数字总数。保证 $c \le 5$。

## 样例 #1

### 输入

```
2
4 2 3 1
1 1 2 1
1 1
8 3 4 1
1 2 3 1 2 3 1 2
1 2 1
```

### 输出

```
3
2
```

# AI分析结果



## 唯一算法分类  
**组合数学 + 字符串匹配 (KMP) + 滑动窗口**

---

## 综合分析与结论  
### 核心思路  
1. **关键元素与非关键元素分离**：将序列 B 中的元素标记为关键元素（必须保留），其余为非关键元素（可选删除）。  
2. **字符串匹配**：提取 A 中的关键元素形成新序列 C，使用 KMP 算法在 C 中查找 B 的匹配位置。  
3. **滑动窗口统计**：对每个匹配的区间，统计该区间内非关键元素的种类数 t，贡献为组合数 C(c-t, d-t)，其中 c 是非关键元素总数。  
4. **组合数预处理**：预处理阶乘和逆元，实现 O(1) 查询组合数。

### 解决难点  
- **高效匹配**：通过 KMP 算法在 O(n+m) 时间内找到所有可能的匹配位置。  
- **区间统计优化**：滑动窗口结合桶计数，维护区间内非关键元素种类数，时间复杂度 O(n)。  
- **边界处理**：注意 KMP 的预处理和匹配过程中可能访问越界的细节（如清空 B[m+1]）。

### 可视化设计  
1. **KMP 匹配过程**：  
   - 展示前缀函数数组构建过程，用不同颜色标注匹配成功/失败的回跳操作。  
   - 动态显示主串和模式串的指针移动。  
2. **滑动窗口维护**：  
   - 用双色方块表示当前窗口内的元素（关键/非关键）。  
   - 高亮新增/移除的非关键元素，实时更新桶计数和种类数。  
3. **组合数计算**：  
   - 显示非关键元素总数 c、当前区间种类数 t，动态计算 C(c-t, d-t)。  

---

## 题解清单 (≥4星)  
1. **Demeanor_Roy (★★★★☆)**  
   - **亮点**：代码结构清晰，桶计数与双指针维护高效，组合数预处理完整。  
   - **关键代码**：使用 `cnt` 数组统计非关键元素种类，结合 KMP 匹配结果计算贡献。  

2. **离散小波变换° (★★★★☆)**  
   - **亮点**：详细推导组合数计算逻辑，强调关键性质（必须删除的数为区间内非关键元素）。  
   - **关键代码**：通过双指针维护区间左右端点，动态维护 `ans`（非关键元素种类数）。  

3. **sangshang (★★★★☆)**  
   - **亮点**：采用 Z 函数替代 KMP，提供另一种字符串匹配思路，代码实现简洁。  
   - **关键代码**：使用 Z 函数计算匹配区间，滑动窗口统计非关键元素。  

---

## 最优思路与代码实现  
### 核心代码片段  
```cpp  
// 组合数预处理  
int fct[N], inv[N], finv[N];  
void init() {  
    fct[0] = inv[0] = finv[0] = 1;  
    for (int i=1; i<N; ++i) {  
        fct[i] = 1ll * fct[i-1] * i % mod;  
        inv[i] = (i==1) ? 1 : 1ll * (mod - mod/i) * inv[mod%i] % mod;  
        finv[i] = 1ll * finv[i-1] * inv[i] % mod;  
    }  
}  
int C(int x, int y) {  
    return (x < y || y < 0) ? 0 : 1ll * fct[x] * finv[y] % mod * finv[x-y] % mod;  
}  

// KMP匹配与贡献计算  
vector<int> p; // 存储A中关键元素的下标  
for (int i=1; i<=n; ++i)  
    if (vis[a[i]]) p.push_back(i);  

// KMP预处理  
vector<int> nxt(m+1);  
for (int i=2, j=0; i<=m; ++i) {  
    while (j && b[i] != b[j+1]) j = nxt[j];  
    if (b[i] == b[j+1]) ++j;  
    nxt[i] = j;  
}  

// 双指针维护区间非关键元素  
int ans = 0, l = 1, r = 0, cnt = 0;  
for (int i=1, j=0; i<=p.size(); ++i) {  
    while (r < p[i-1]) {  
        ++r;  
        if (!vis[a[r]] && ++num_cnt[a[r]] == 1) ++cnt;  
    }  
    while (l < p[i-m]) {  
        if (!vis[a[l]] && --num_cnt[a[l]] == 0) --cnt;  
        ++l;  
    }  
    ans = (ans + C(c - cnt, d - cnt)) % mod;  
}  
```

---

## 相似题目推荐  
1. **P3375 【模板】KMP字符串匹配**  
   - 练习 KMP 算法的标准模板题。  
2. **P1495 组合数问题**  
   - 组合数预处理与快速查询的经典问题。  
3. **P1043 滑动窗口**  
   - 双指针维护区间统计的入门题目。  

---

## 可视化与复古游戏化设计  
### 动画方案  
1. **KMP 匹配过程**：  
   - **像素风格**：用 8-bit 色块表示字符串字符，绿色表示匹配成功，红色表示失败。  
   - **音效**：匹配成功时播放短促“叮”声，失败时播放低沉“咚”声。  
2. **滑动窗口维护**：  
   - **网格绘制**：将 A 序列映射为像素网格，关键元素为蓝色，非关键为灰色。  
   - **动态窗口**：用黄色方框标记当前窗口，新增元素闪烁提示。  
3. **组合数计算**：  
   - **数值显示**：在屏幕右侧实时显示 c、t、C(c-t, d-t) 的数值变化。  

### 控制面板  
- **自动播放**：AI 自动运行算法，按步骤展示匹配和窗口滑动。  
- **手动步进**：用户可点击按钮逐帧观察指针移动和计数更新。  
- **速度调节**：滑动条控制动画速度（0.5x~3x）。  

---

**示例代码 (JS Canvas)**  
```javascript  
// 绘制关键元素序列  
function drawSequence(ctx, seq, pos) {  
    for (let i=0; i<seq.length; i++) {  
        ctx.fillStyle = (i === pos) ? "#FF0000" : "#00FF00";  
        ctx.fillRect(20 + i*30, 50, 25, 25);  
        ctx.fillText(seq[i], 25 + i*30, 65);  
    }  
}  
// 触发音效  
function playSound(type) {  
    const audioCtx = new AudioContext();  
    const oscillator = audioCtx.createOscillator();  
    oscillator.type = 'square';  
    oscillator.frequency.setValueAtTime(type === 'match' ? 880 : 440, audioCtx.currentTime);  
    oscillator.connect(audioCtx.destination);  
    oscillator.start();  
    oscillator.stop(audioCtx.currentTime + 0.1);  
}  
```

---
处理用时：92.79秒
# 题目信息

# [HNOI2004] 树的计数

## 题目描述

一个有 $n$ 个节点的树，设它的节点分别为 $v_1,v_2,\ldots,v_n$，已知第 $i$ 个节点 $v_i$ 的度数为 $d_i$，问满足这样的条件的不同的树有多少棵。


## 说明/提示

$1\le n\le 150$，保证满足条件的树不超过 $10^{17}$ 个。

## 样例 #1

### 输入

```
4                     
2 1 2 1
```

### 输出

```
2```

# AI分析结果



## 算法分类
组合数学（Prüfer 序列）

---

## 题解思路与核心分析

### 核心思路
所有题解均基于 **Prüfer 序列**的关键性质：度数为 \(d_i\) 的节点在 Prüfer 序列中出现 \(d_i-1\) 次。问题转化为求多重排列数：
\[
\frac{(n-2)!}{\prod_{i=1}^n (d_i-1)!}
\]

### 解决难点
1. **大数处理**：直接计算阶乘会溢出，需采用以下方法：
   - **Python 高精度**：直接利用语言特性（如 TheLostWeak 的解法）。
   - **质因数分解**：分解阶乘与分母的质因数，通过指数加减计算（bloodstalk 的解法）。
   - **组合数递推**：预处理组合数，逐项相乘（行吟啸九州的解法）。
   - **大模数逆元**：选模数 \(>10^{17}\)，用逆元模拟除法（Timmy_ 的解法）。

2. **特判条件**：
   - 总度数必须为 \(2n-2\)。
   - 当 \(n=1\) 时，度数必须为 0。
   - 存在度数为 0 的节点时无解。

---

## 题解评分（≥4星）

1. **TheLostWeak（★★★★★）**  
   - **亮点**：详细推导 Prüfer 序列，Python 代码简洁高效，直接处理大数。  
   - **代码可读性**：清晰的分母计算与特判逻辑。

2. **bloodstalk（★★★★☆）**  
   - **亮点**：质因数分解避免高精度，C++ 实现高效，分解阶乘并统计质数指数。  
   - **优化点**：预处理质因数分解表减少重复计算。

3. **Pentiment（★★★★☆）**  
   - **亮点**：大模数逆元法，利用 `__int128` 防止溢出，代码简洁。  
   - **创新点**：选模数 \(10^{17}+3\) 保证结果正确性。

---

## 最优思路与技巧

### 关键思路
- **质因数分解法**（推荐用于 C++）：  
  1. 预处理 \(1 \sim n\) 的质因数分解。  
  2. 计算分子 \((n-2)!\) 的质因数指数。  
  3. 分母 \(\prod (d_i-1)!\) 的质因数指数相减。  
  4. 最终结果 = 所有质因数的指数乘积。

### 代码片段（bloodstalk 解法）
```cpp
for(int i=1; i<=n; i++) {
    Calc(i); // 分解i的质因数
    for(int j=1; j<=n; j++) 
        p[i][j] += p[i-1][j]; // 累加阶乘的质因数
}
for(int i=1; i<=n; i++) {
    for(int j=1; j<=n; j++)
        p[n-2][j] -= p[du[i]-1][j]; // 分母的质因数指数相减
}
ll ans = 1;
for(int i=1; i<=n; i++) {
    for(int j=1; j<=p[n-2][i]; j++)
        ans *= i; // 计算结果
}
```

---

## 同类型题与算法套路

### 类似题目
1. **P2624 [HNOI2008] 明明的烦恼**  
   - 扩展问题：部分节点度数未知，需计算组合数变体。

2. **P4981 父子**  
   - 应用 Cayley 公式 \(n^{n-2}\) 计算生成树数量。

3. **P4430 小猴打架**  
   - 生成树边序计数，结合 Cayley 公式与排列。

---

## 可视化与算法演示

### 动画设计
- **Prüfer 序列生成**：  
  - **步骤**：逐步删除最小叶子节点，高亮当前节点及其父节点。  
  - **颜色标记**：当前操作节点（红色）、序列更新（绿色）。

- **质因数分解过程**：  
  - **网格显示**：质因数按列排列，阶乘分解为质因数指数（动态累加）。  
  - **分母计算**：用不同颜色标记指数的增减（蓝色加，红色减）。

### 复古像素风格
- **8-bit 音效**：  
  - 删除节点时播放 "beep" 音效。  
  - 计算完成时播放胜利音效（8-bit 风格）。  
- **Canvas 绘制**：  
  - 质因数分解网格用像素块表示，指数变化通过方块高度动画展示。  

---

## 个人心得摘录

- **TheLostWeak**：  
  > “一切与度数有关的树上计数问题，都可以用 Prüfer 序列解决。”  
  - 强调 Prüfer 序列在树计数中的普适性。

- **spire001**：  
  > “Hack 说的对，但是我无脑压位高精。”  
  - 调试高精度实现的无奈与最终暴力解法的有效性。

---

## 核心算法流程（可视化步骤）

1. **输入处理**：验证度数总和与特判条件（红色警示错误输入）。  
2. **质因数分解**：  
   - 展示 \( (n-2)! \) 分解为质因数（动态累加指数）。  
3. **分母调整**：  
   - 逐步减去每个 \( (d_i-1)! \) 的质因数指数（高亮当前 \(d_i\)）。  
4. **结果计算**：  
   - 逐个质因数相乘，显示最终结果（绿色高亮完成）。

---
处理用时：74.56秒
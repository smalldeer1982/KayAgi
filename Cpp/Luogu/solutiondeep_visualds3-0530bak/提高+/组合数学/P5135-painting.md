# 题目信息

# painting

## 题目背景

Wolfycz很喜欢画画（雾

## 题目描述

Wolfycz喜欢网格图，他希望在网格图上画上一些黑格子，使得每一列都恰好有一个黑格子。但是黑格子太乱了不好看，所以Wolfycz希望黑格子按列号依次连线是下降的，具体来讲，每列黑格子所在行号不得小于前一列黑格子所在行号（我们令左上角为第一行第一列）

Wolfycz觉得这样画出来的图非常漂亮，但是Wolfycz有时候觉得连线要严格下降才好看（即每列黑格子所在行号必须大于前一列黑格子所在行号），有时候觉得连线只要不上升就好看（即每列黑格子所在行号不得小于前一列黑格子所在行号）。现在Wolfycz想知道，对于一个$N×M$的网格图，他能画出多少个好看的图？两个图不相同，当且仅当存在某一列的黑格子，它在两个图中对应的行号不同

UPD：$N$行$M$列

## 说明/提示

对于$20\%$的数据，$T\leqslant 5,N\leqslant 8,M\leqslant 8$

对于另外$20\%$的数据，$N=1$或$M=1$

对于另外$20\%$的数据，$N\leqslant 10^6,M\leqslant 10^6$

对于$100\%$的数据，$T\leqslant 50,N\leqslant 10^{18},M\leqslant 10^6$

## 样例 #1

### 输入

```
5
5 2 1
5 3 0
3 4 0
8 4 1
6 2 1```

### 输出

```
10
35
15
70
15```

# AI分析结果



**算法分类**  
组合数学

---

**题解思路、算法要点与解决难点**  
- **核心思路**：将问题转化为组合数计算。  
  - **opt=1**（严格下降）：从n行选m个不同行，方案数为组合数C(n, m)。  
  - **opt=0**（非严格下降）：允许重复选择行，转化为可重复组合，方案数为C(n+m-1, m)。  
- **解决难点**：处理大数组合数计算（n≤1e18，m≤1e6）。通过逐项计算分子并乘逆元避免溢出，模数1e9+7下使用费马小定理求逆元。  
- **关键优化**：预处理阶乘逆元减少重复计算，或直接暴力循环计算分子分母。

---

**题解评分 (≥4星)**  
1. **Wolfycz (5星)**  
   - 预处理逆元，代码简洁高效，直接循环计算组合数，时间复杂度O(Tm)。  
   - 核心代码片段：  
     ```cpp  
     int C(ll n, int m) {  
         int res = 1;  
         for (int i=1; i<=m; i++)  
             res = 1ll*res*((n-i+1)%mod)%mod*inv[i]%mod;  
         return res;  
     }  
     ```  
2. **daniEl_lElE (4星)**  
   - 直接暴力计算组合数，逻辑清晰，但未预处理逆元，每次重新计算分母逆元。  
3. **xiaomuyun (4星)**  
   - 使用Lucas定理处理大n，但m较大时效率较低，适用于极端数据。

---

**最优思路或技巧提炼**  
- **组合数转换**：严格下降对应非重组合，非严格下降对应可重组合。  
- **逆元预处理**：预处理1~m的逆元，加速组合数计算。  
- **大数处理**：逐项计算分子并取模，避免数值溢出。

---

**同类型题或类似算法套路**  
- **隔板法**：如将k个相同物品分n组（允许空组）对应C(k+n-1, n-1)。  
- **杨辉三角/组合数性质**：动态规划预处理组合数。  
- **质因数分解优化**：处理极大数的组合数模运算。

---

**推荐相似题目**  
1. P3807（卢卡斯定理模板）  
2. P3197（逆元与组合数）  
3. CF785D（组合数递推与隔板法）

---

**个人心得摘录**  
- Wolfycz在题解中强调**预处理逆元**的重要性，避免重复计算。  
- Ruiqun2009的快速阶乘算法虽高效但**复杂度与可读性难以平衡**，适合极端数据。  

---

**可视化与算法演示**  
- **动画设计**：  
  - **网格绘制**：8位像素风格网格，列高亮显示当前选择的行。  
  - **连线效果**：红色线段表示严格下降，蓝色为非严格下降，错误选择时闪烁提示。  
  - **音效反馈**：正确选择播放“叮”声，错误时播放“嘟”声。  
- **关键步骤高亮**：  
  - **分子计算**：逐步显示(n-i+1)的连乘过程，颜色渐变。  
  - **逆元计算**：用不同颜色标记分母阶乘的逆元求解步骤。  
- **自动演示模式**：AI自动选择合法行号，展示组合数增长过程。

---

**代码实现（Wolfycz精简版）**  
```cpp  
#include<cstdio>  
#define int long long  
const int mod=1e9+7;  
int inv[1000005];  

int C(int n, int m) {  
    int res=1;  
    for(int i=1; i<=m; i++)  
        res = 1ll * res * (n-i+1) % mod * inv[i] % mod;  
    return res;  
}  

signed main() {  
    inv[1]=1;  
    for(int i=2; i<=1e6; i++)  
        inv[i] = 1ll*(mod-mod/i)*inv[mod%i] % mod;  
    int T; scanf("%lld",&T);  
    while(T--){  
        int n,m,opt; scanf("%lld%lld%lld",&n,&m,&opt);  
        printf("%lld\n", opt ? C(n,m) : C(n+m-1,m));  
    }  
    return 0;  
}  
```  

**可视化代码片段（JS伪代码）**  
```javascript  
function drawGrid(n, m, opt) {  
    ctx.fillStyle = "#8B00FF"; // 紫色像素风格  
    for(let col=0; col<m; col++) {  
        let row = chooseRow(opt, prevRow);  
        ctx.fillRect(col*10, (n-row)*10, 8, 8);  
        if (col>0) drawLine(col-1, prevRow, col, row);  
        prevRow = row;  
    }  
}  
```  

--- 

**总结**  
本题通过组合数模型巧妙转化几何约束，预处理逆元暴力计算在合理数据范围内高效简洁。复古像素动画可生动展现选择过程，音效增强交互理解。

---
处理用时：100.40秒
# 题目信息

# [USACO23JAN] Moo Route G

## 题目描述

现在有一条数轴，$t$ 表示当前时刻。在 $t=0$ 时 Bessie 恰好处在 $x=0$ 的位置。

接下来，每秒钟 Bessie 会向左或者向右移动一个单位距离，我们保证 Bessie 是在 $0-N$ 的位置之间移动并最终停在 $x=0$ 的位置。同时，我们有一个 $A_0,A_1,A_2\ldots A_{N-1}$ 的数列，分别表示 Bessie 经过 $0.5,1.5,2.5\ldots (N-1).5$ 这些点的次数。我们可以用一个由 $\text{L}$ 和 $\text{R}$ 组成的序列来表示 Bessie 的路径，我们称 Bessie 改变了一次方向为在序列中的相邻两个字符不同。现在我们不知道具体的移动序列是什么，但我们知道 Bessie 采用了让她改变方向次数最少的走法。现在请问 Bessie 的路径有多少种不同的可能情况？（我们称两条路径不同当且仅当这条路径对应序列中的某一位不同）

## 说明/提示

$N\le10^5,\max(A_i)\le10^6$。

对于测试点 $2-4$，满足 $N\le2,\max(A_i)\le10^3$。

对于测试点 $5-7$，满足 $N\le2$。

对于测试点 $8-11$，满足 $\max(A_i)\le10^3$。

## 样例 #1

### 输入

```
2
4 6```

### 输出

```
2```

# AI分析结果



## 算法分类
组合数学

---

## 题解思路与算法要点

### 核心思路
将路径分解为相邻两层尖的排列组合问题。对于每对相邻层：
- 若上层尖数 ≤ 下层尖数，将上层尖看作不可分割的块，下层尖中选对应数量放置，方案数为组合数 $C_{A_{i}}^{A_{i+1}}$  
- 若上层尖数 > 下层尖数，将下层尖看作分割点，将上层尖分割成若干段，方案数为组合数 $C_{A_{i+1}-1}^{A_{i}-1}$  
最终结果为所有相邻层方案数之积。

### 解决难点
1. **方向次数最小化**：通过保证每层尖尽可能填满下层尖的空隙，避免不必要的转向。
2. **组合数推导**：利用插板法或选择法将尖的排列问题转化为组合数计算。
3. **预处理优化**：预处理阶乘与逆元，实现 $O(1)$ 计算组合数。

### 代码实现关键
1. **预处理阶乘与逆元**：使用费马小定理预处理逆元，快速计算组合数。
2. **逐层相乘**：遍历每对相邻层，根据大小关系选择组合数公式，累乘结果。

---

## 题解评分 (≥4星)

### [Bugupop] ★★★★☆  
- **亮点**：数形结合直观展示尖的排列，分情况讨论清晰，配图辅助理解。
- **代码**：完整预处理阶乘，边界条件处理明确。

### [MCRS_lizi] ★★★★☆  
- **亮点**：从 $N=2$ 特例推广到通解，类比苹果篮子问题，逻辑递进自然。
- **代码**：使用动态逆元预处理，内存效率更高。

### [Poncirus] ★★★★☆  
- **亮点**：路径替换的拼接思路简洁，代码模块化程度高。
- **心得**：强调终点必须为 0 的条件，避免读者忽略关键约束。

---

## 最优思路提炼
1. **尖的分解**：将路径分解为相邻层的尖排列，独立计算每层贡献。
2. **组合数转换**：
   - 上层尖多 → 下层尖分割上层（插板法）。
   - 下层尖多 → 选择下层尖放置上层（选择法）。
3. **乘法原理**：各层独立，总方案数为各层方案数之积。

---

## 同类型题与算法套路
1. **插板法应用**：如分球入盒问题（[CF1525E]）。
2. **路径组合问题**：如卡特兰数相关题目（[P1641]）。
3. **分步乘法原理**：如多阶段决策问题（[P2513]）。

---

## 推荐题目
1. [P1641] 生成字符串  
2. [P2513] 逆序对数列  
3. [CF1525E] Assimilation IV

---

## 代码实现（核心逻辑）
```cpp
const int mod = 1e9 + 7, N = 1e6 + 10;
ll fac[N], inv[N];

void init() {
    fac[0] = 1;
    for (int i = 1; i < N; ++i) fac[i] = fac[i-1] * i % mod;
    inv[N-1] = pow(fac[N-1], mod-2, mod);
    for (int i = N-2; i >= 0; --i) inv[i] = inv[i+1] * (i+1) % mod;
}

ll C(int n, int m) {
    if (n < m || m < 0) return 0;
    return fac[n] * inv[m] % mod * inv[n - m] % mod;
}

int main() {
    init();
    int n; cin >> n;
    vector<int> a(n);
    for (auto &x : a) cin >> x, x /= 2;
    
    ll ans = 1;
    for (int i = 1; i < n; ++i) {
        int x = a[i-1], y = a[i];
        if (x >= y) ans = ans * C(x, y) % mod;
        else ans = ans * C(y-1, x-1) % mod;
    }
    cout << ans;
}
```

---

## 可视化设计
### 动画方案
1. **网格绘制**：用 Canvas 绘制数轴，每层尖用不同颜色方块表示。
2. **尖插入演示**：
   - **上层尖多**：下层尖高亮，插入分割线动态绘制上层尖分割。
   - **下层尖多**：上层尖逐个飞入下层选中位置，伴随音效。
3. **颜色标记**：
   - 当前操作层：红色边框。
   - 已处理层：半透明灰色。
4. **音效**：
   - 分割线插入：短促 "beep"。
   - 尖放置成功：上扬音调。

### 复古像素风格
- **调色板**：8 位红/绿/蓝主色调，黑色网格线。
- **AI 模式**：自动播放各层处理，速度可调（快/中/慢）。
- **积分系统**：每正确计算一层得 10 分，错误操作扣分。

---

## 个人心得
- **预处理范围**：逆元数组需覆盖最大可能的组合数参数（如 $\max(A_i)$）。
- **边界条件**：$A_i = 1$ 时需特判，避免计算 $C(0, 0)$ 出错。
- **数形结合**：画图辅助理解尖的排列规则，避免纯公式推导的思维盲区。

---
处理用时：70.70秒
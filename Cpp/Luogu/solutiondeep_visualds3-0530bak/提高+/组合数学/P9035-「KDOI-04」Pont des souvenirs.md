# 题目信息

# 「KDOI-04」Pont des souvenirs

## 题目背景

虽然这是一个 C，但是

![](https://cdn.luogu.com.cn/upload/image_hosting/dzj8va56.png)

## 题目描述

给定正整数 $n,k$，求有多少个长度为 $n$ 的正整数序列 $a$ 满足：

* $0<a_1\le a_2\le a_3\le\cdots\le a_n\le k$；
* $\forall\ i\not=j$，$a_i+a_j\le k+1$。

答案对 $10^9+7$ 取模。

## 说明/提示

**【样例解释】**

对于第 $1$ 组测试数据，所有满足要求的序列为 $(1,1)$ 和 $(1,2)$。

对于第 $2$ 组测试数据，所有满足要求的序列为 $(1)$，$(2)$ 和 $(3)$。

**【数据范围】**

对于 $100\%$ 的数据，保证 $1\le T\le2\times10^5$，$1\le n,k\le10^7$。

**本题开启捆绑测试。**

|子任务编号|分值|$T\le$|$n\le$|$k$|
|:-:|:-:|:-:|:-:|:-:|
|$1$|$8$|$5$|$5$|$\le5$|
|$2$|$3$|$10^5$|$10^7$|$=1$|
|$3$|$3$|$10^5$|$10^7$|$=2$|
|$4$|$8$|$10^5$|$10^7$|$=3$|
|$5$|$16$|$10$|$200$|$\le200$|
|$6$|$16$|$10$|$3000$|$\le3000$|
|$7$|$8$|$10^4$|$10^7$|$\le5$|
|$8$|$8$|$100$|$10^7$|$\le10^5$|
|$9$|$30$|$2\times10^5$|$10^7$|$\le10^7$|


## 样例 #1

### 输入

```
5
2 2
1 3
4 5
4030 218
1145 1419
```

### 输出

```
2
3
20
571656908
172735629
```

# AI分析结果



---

## **算法分类**  
组合数学

---

## **题解思路与解决难点**  

### **核心思路**  
题目要求统计满足非递减且任意两数之和≤k+1的正整数序列数目。通过分析，第二个条件可简化为最大两个数之和的限制，从而转化为组合数学问题。关键步骤如下：  
1. **问题转化**：序列的最大两个元素之和必须≤k+1，枚举末位元素的值，将问题拆分为两个组合数求和问题。  
2. **组合数模型**：利用隔板法或路径计数模型，将前n-1个元素的合法序列数转化为组合数计算。  
3. **恒等式优化**：通过上指标求和公式（朱世杰恒等式）将O(k)的求和转化为O(1)的组合数计算。  

### **解决难点**  
- **条件转化**：发现第二个条件等价于控制最大两个元素的和。  
- **组合数简化**：利用组合恒等式避免逐项求和，将复杂度从O(k)降至O(1)。  

---

## **题解评分 (≥4星)**  

### 1. **Polaris_Australis_ (5星)**  
- **关键亮点**：从暴力到组合恒等式的完整推导，清晰展示优化路径。  
- **代码片段**：最终公式化为两组合数之和，预处理阶乘+逆元实现O(1)查询。  

### 2. **kbtyyds (5星)**  
- **关键亮点**：详细推导吸收恒等式与上指标求和的结合，最终公式简洁。  
- **个人心得**：提到调试中通过数学归纳法验证组合数模型。  

### 3. **hcywoi (4星)**  
- **关键亮点**：通过隔板法拆分问题，结合组合数公式快速求和。  
- **代码可读性**：预处理阶乘与逆元，代码结构清晰。  

---

## **最优思路与技巧**  

### **关键技巧**  
1. **差分序列转化**：将非递减序列转化为差分数组，避免直接处理单调性。  
2. **组合恒等式**：利用 $\sum_{i=0}^m \binom{n+i}{n} = \binom{n+m+1}{n+1}$ 快速求和。  
3. **预处理优化**：预处理阶乘与逆元，实现组合数O(1)计算。  

### **同类型题套路**  
- **序列计数问题**：常转化为组合数或动态规划模型。  
- **组合恒等式**：上指标求和、吸收恒等式等是核心优化手段。  

---

## **推荐题目**  
1. **P4369 [Code+#3] 组合数问题**（组合数应用）  
2. **P6688 序列计数**（非递减序列计数+组合优化）  
3. **P1350 车的放置**（棋盘组合问题）  

---

## **个人心得摘录**  
- **kbtyyds**：在推导过程中多次尝试配凑系数，最终发现吸收恒等式是关键。  
- **Demeanor_Roy**：原以为动态规划不可行，但通过组合数模型实现降维打击。  

---

## **可视化与算法演示**  

### **动态演示设计**  
1. **路径计数动画**：  
   - **Canvas网格**：显示从(1,1)到(n, m)的非递减路径，每步高亮当前组合数对应路径。  
   - **颜色标记**：红色标记当前枚举的末位值i，蓝色标记$\min(i, k+1-i)$的边界。  

2. **组合恒等式可视化**：  
   - **像素风格**：8位像素字体显示组合数公式，绿色闪烁展示上指标求和的关键步骤。  
   - **音效触发**：每次求和完成时播放“升级音效”，错误步骤播放“失败音效”。  

3. **复古游戏化设计**：  
   - **自动演示模式**：AI自动枚举i值，右侧显示当前求和结果，类似贪吃蛇自动寻路。  
   - **积分系统**：每正确合并一次求和项得10分，连击加成提升得分。  

### **关键代码片段（JS+Canvas）**  
```javascript
// 初始化8位画布
const canvas = document.getElementById("pixel-canvas");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false; // 保持像素风格

// 绘制组合数路径
function drawCombPath(n, m) {
    ctx.fillStyle = "#00FF00"; // 复古绿
    for (let i = 0; i <= n + m; i++) {
        setTimeout(() => {
            drawStep(i, n, m); // 逐步绘制路径
            if (i === n + m) playSuccessSound(); // 完成音效
        }, i * 100);
    }
}

// 音效触发
function playSuccessSound() {
    const audio = new Audio("data:audio/wav;base64,UklGRl9..."); // 8位音效
    audio.play();
}
```

---

## **核心实现代码**  
```cpp
const int MOD = 1e9+7, N = 2e7;
int fact[N], inv[N];

void init() {
    fact[0] = inv[0] = 1;
    for (int i=1; i<N; i++) fact[i] = 1LL * fact[i-1] * i % MOD;
    inv[N-1] = pow(fact[N-1], MOD-2); // 费马小定理求逆元
    for (int i=N-2; i>=1; i--) inv[i] = 1LL * inv[i+1] * (i+1) % MOD;
}

int C(int n, int m) {
    if (n < m) return 0;
    return 1LL * fact[n] * inv[m] % MOD * inv[n-m] % MOD;
}

int solve(int n, int k) {
    int m1 = (k + 1) / 2, m2 = k / 2;
    return (C(n + m1 -1, n) + C(n + m2 -1, n)) % MOD;
}
```

---
处理用时：75.85秒
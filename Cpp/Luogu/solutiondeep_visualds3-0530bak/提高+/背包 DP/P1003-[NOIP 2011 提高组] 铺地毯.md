# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果



# [NOIP 2011 提高组] 铺地毯 题解分析

## 唯一算法分类
**模拟、枚举**

---

## 题解思路、算法要点与解决难点
### 核心思路
1. **覆盖判断**：每个地毯的覆盖范围由左下角坐标（a,b）和延伸长度（g,k）确定，右上角坐标为（a+g, b+k）
2. **逆序检查**：后铺的地毯在上层，因此从最后一张地毯倒序检查，第一个覆盖目标点的即为答案
3. **空间优化**：存储地毯参数而非实际坐标区域，空间复杂度从 O(10^10) 降至 O(n)

### 解决难点
1. **数据范围陷阱**：直接开二维数组记录每个坐标的地毯会引发 MLE（400MB 内存需求）
2. **覆盖条件判断**：需要准确理解矩形边界条件（含四个顶点）
3. **查询优化**：通过逆序检查实现 O(n) 时间复杂度，且平均查询次数优于正序

---

## 题解评分 (≥4星)
1. **[Vct14 题解]** ⭐⭐⭐⭐⭐
   - 亮点：逆序检查提前返回，结构体存储参数清晰
2. **[kuaiCreator 题解]** ⭐⭐⭐⭐
   - 亮点：简洁的逆序实现，变量命名规范
3. **[Jayfeather2012 题解]** ⭐⭐⭐⭐
   - 亮点：明确的逆序思路，注释清晰

---

## 最优思路与技巧提炼
### 关键算法
```cpp
for(int i = n; i >= 1; i--) { // 逆序遍历所有地毯
    if(x >= a[i] && x <= a[i]+g[i] && 
       y >= b[i] && y <= b[i]+k[i]) {
        return i; // 立即返回第一个符合条件的
    }
}
```

### 核心技巧
1. **逆序短路**：通过倒序遍历实现「找到即停」的优化策略
2. **参数存储**：用结构体或独立数组存储每个地毯的坐标参数
3. **边界计算**：实时计算右上角坐标 `x <= a[i] + g[i]` 而非预存

---

## 同类型题与算法套路
### 通用解法
- **覆盖问题**：通过存储对象参数后判断点/区域归属
- **最近操作查询**：逆序检查最后生效的操作

### 相似题目
1. P1056 排座椅（区间覆盖统计）
2. P1496 火烧赤壁（区间合并与覆盖）
3. P2280 激光炸弹（二维前缀和与覆盖统计）

---

## 可视化与算法演示
### 动画方案设计
1. **像素网格**：用 Canvas 绘制 100x100 的简化坐标系
2. **地毯绘制**：按铺设顺序用不同颜色填充矩形区域（后铺的覆盖前层）
3. **检查高亮**：
   - 红色方块标记目标点
   - 逆序遍历时，当前检查的地毯用黄色边框闪烁
   - 发现覆盖时，该地毯区域变为绿色闪烁三次

### 复古交互功能
```javascript
// 伪代码示例
function drawStep(i) {
    ctx.clearRect(0, 0, 500, 500); // 清空画布
    drawAllCarpet();              // 绘制所有地毯
    highlightCurrentCarpet(i);    // 黄框高亮当前检查的地毯
    if(checkHit(i)) {             // 命中检测
        playSuccessSound();
        highlightHitCarpet(i);    // 绿闪效果
        stopAnimation();
    }
}
```

### 音效设计
- **检查音效**：8-bit "beep" 音（每次循环触发）
- **命中音效**：NES 风格胜利旋律
- **失败音效**：经典 FC 游戏结束音

---

## 核心代码实现
```cpp
#include <iostream>
using namespace std;

struct Carpet { int a, b, g, k; };

int main() {
    int n, x, y;
    Carpet carpets[10005];
    
    cin >> n;
    for(int i=1; i<=n; i++)
        cin >> carpets[i].a >> carpets[i].b >> carpets[i].g >> carpets[i].k;
    cin >> x >> y;

    for(int i=n; i>=1; i--) { // 逆序关键循环
        int right = carpets[i].a + carpets[i].g;
        int top = carpets[i].b + carpets[i].k;
        if(x >= carpets[i].a && x <= right && 
           y >= carpets[i].b && y <= top) {
            cout << i;
            return 0;
        }
    }
    cout << -1;
}
```

---

## 个人心得摘录
> "在初次尝试时想用二维数组记录每个坐标的地毯，结果发现内存爆炸。后来意识到只需要存储参数并在查询时实时计算，这正是空间换时间的经典取舍。" —— 智子题解中的调试经验

> "从后往前找地毯的思路就像翻书找最后一页的批注，比从头开始逐页检查要聪明得多。" —— Jayfeather2012 的算法感悟

---
处理用时：80.33秒
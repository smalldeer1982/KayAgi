# 题目信息

# [USACO1.1] 贪婪的送礼者 Greedy Gift Givers

## 题目描述

对于一群 $n$ 个要互送礼物的朋友，GY 要确定每个人送出的钱比收到的多多少。在这一个问题中，每个人都准备了一些钱来送礼物，而这些钱将会被平均分给那些将收到他的礼物的人。  

然而，在任何一群朋友中，有些人将送出较多的礼物(可能是因为有较多的朋友)，有些人有准备了较多的钱。  

给出一群朋友，没有人的名字会长于 $14$ 字符，给出每个人将花在送礼上的钱，和将收到他的礼物的人的列表，请确定每个人收到的比送出的钱多的数目。

## 说明/提示

【数据范围】  
$1\le n \le 10$。

题目翻译来自NOCOW。

USACO Training Section 1.1

## 样例 #1

### 输入

```
5
dave
laura
owen
vick
amr
dave
200 3
laura
owen
vick
owen
500 1
dave
amr
150 2
vick
owen
laura
0 2
amr
vick
vick
0 0
```

### 输出

```
dave 302
laura 66
owen -359
vick 141
amr -150
```

# AI分析结果



---

## 【唯一算法分类】  
模拟

---

## 【题解思路、算法要点与解决难点】  

### 核心逻辑分析  
1. **数据结构选择**：  
   - **结构体数组**：存储每个用户的姓名、送出金额、收到金额等字段，通过线性查找匹配姓名（时间复杂度 O(n^2)）。  
   - **STL map**：建立姓名到金额的映射，快速查找（时间复杂度 O(n log n)），显著优化查找效率。  

2. **关键操作步骤**：  
   - **金额分配**：送礼者送出金额为 `总金额 // 接收人数`，余数需返还给送礼者（`总金额 % 接收人数`）。  
   - **边界处理**：当接收人数为 0 时，直接跳过分配步骤，避免除以零的运行时错误。  

3. **解决难点**：  
   - **姓名匹配**：通过线性遍历或 `map<string, int>` 实现快速映射。  
   - **余数处理**：确保未分配的金额正确返还给送礼者，避免逻辑错误。  

---

## 【题解评分 (≥4星)】  

### 1. BlueArc（5星）  
- **思路清晰度**：使用 `map<string, int>` 简化姓名映射，代码简洁。  
- **代码可读性**：逻辑紧凑，无冗余操作。  
- **优化程度**：利用 STL 容器高效处理数据。  
- **关键代码**：  
  ```cpp
  cnt[s] -= num * p; // 计算送礼者净支出
  cnt[person] += num; // 收礼者增加金额
  ```

### 2. 蒟蒻炒扇贝（4星）  
- **实践可操作性**：详细注释解释 `map` 的使用和余数处理逻辑。  
- **个人心得**：强调余数返还的坑点（未处理时仅得 22 分）。  
- **关键代码**：  
  ```cpp
  money[x] -= have; // 先扣除总金额
  money[x] += (have - give * l); // 返还余数
  ```

### 3. w1049（4星）  
- **算法优化**：结合 `vector` 保持输入顺序，`map` 维护金额映射。  
- **代码亮点**：  
  ```cpp
  vector<string> id; // 保持原始输入顺序
  m[tmp] += give; // 通过 map 快速更新金额
  ```

---

## 【最优思路或技巧提炼】  

### 核心技巧  
1. **STL map 快速映射**：将姓名映射为键，金额为值，避免线性查找的低效。  
2. **余数返还机制**：确保送礼者最终金额计算为 `送出金额 - 已分配金额 + 余数`。  
3. **边界处理**：在分配前检查接收人数是否为 0，防止除以零错误。  

### 代码片段示例  
```cpp
map<string, int> cnt;
string name;
cin >> name >> total >> num;
if (num != 0) {
    int per = total / num;
    cnt[name] -= per * num; // 净支出
    cnt[receiver] += per; // 收礼者增加
}
```

---

## 【同类型题或类似算法套路】  
- **通用解法**：涉及字符串映射与金额分配的模拟问题，优先考虑 `map` 或 `unordered_map`。  
- **相似题目**：  
  1. **P1308 统计单词数**：字符串匹配与计数。  
  2. **P1598 垂直柱状图**：字符频率统计与输出格式化。  
  3. **P1056 排座椅**：输入处理与条件排序。  

---

## 【推荐相似知识点题目】  
1. [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)  
2. [P1598 垂直柱状图](https://www.luogu.com.cn/problem/P1598)  
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)  

---

## 【个人心得摘录】  
- **Aoki_灏**：强调必须精确比较全名而非首字母，避免偷懒导致的错误。  
- **蒟蒻炒扇贝**：“22 分惨案”源于未处理余数返还，调试时需关注边界条件。  

---

## 【可视化与算法演示】  

### 核心算法动画设计  
1. **像素风格界面**：  
   - **颜色方案**：16 色调色板，绿色表示收礼者，红色表示送礼者。  
   - **Canvas 绘制**：网格化显示每个用户，金额变化时弹出像素数字。  

2. **动画流程**：  
   - **Step 1**：高亮送礼者名字，显示总金额和接收人数。  
   - **Step 2**：逐个分配金额到接收者，伴随 8-bit 音效。  
   - **Step 3**：显示余数返还，送礼者金额更新。  

3. **交互功能**：  
   - **步进控制**：按钮控制单步执行或自动播放。  
   - **音效触发**：分配时播放 `coin.wav`，错误时播放 `error.wav`。  

### 复古游戏化设计  
- **AI 演示模式**：自动按输入顺序执行分配，模拟“贪吃蛇”式流程。  
- **积分系统**：正确完成一次分配得 10 分，错误操作扣 5 分。  

---

**示例代码（JS 动画核心逻辑）**  
```javascript
// Canvas 绘制送礼者与收礼者
ctx.fillStyle = '#8B8B83'; // 复古灰色背景
ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.fillStyle = '#FF6B6B'; // 红色表示送礼者
ctx.fillText(sender.name, x, y);
// 播放音效
audio.play('allocate');
```

---
处理用时：85.19秒
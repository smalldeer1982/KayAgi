# 题目信息

# [HNOI2001] 产品加工

## 题目描述

某加工厂有 A、B 两台机器，来加工的产品可以由其中任何一台机器完成，或者两台机器共同完成。由于受到机器性能和产品特性的限制，不同的机器加工同一产品所需的时间会不同，若同时由两台机器共同进行加工，所完成任务又会不同。

某一天，加工厂接到  $n$ 个产品加工的任务，每个任务的工作量不尽一样。

你的任务就是：已知每个任务在 A 机器上加工所需的时间  $t_1$，B 机器上加工所需的时间  $t_2$ 及由两台机器共同加工所需的时间  $t_3$，请你合理安排任务的调度顺序，使完成所有  $n$ 个任务的总时间最少。

## 说明/提示

对于所有数据，有  $1\le n\le 6\times 10^3$， $0\le t_1,t_2,t_3\le 5$。

## 样例 #1

### 输入

```
5                            

2 1 0

0 5 0

2 4 1

0 0 3

2 1 1

```

### 输出

```
9```

# AI分析结果



## 算法分类
动态规划（背包问题变种）

---

## 综合分析与结论

### 核心思路
- **状态设计**：定义 `dp[j]` 表示当 A 机器累计用时为 `j` 时，B 机器的最小用时。通过将两个维度的状态压缩为一个，解决了传统双机调度问题的空间复杂度问题。
- **状态转移**：每个任务有三种处理方式（A 单独处理、B 单独处理、AB 同时处理），对应三种状态转移方式：
  ```cpp
  dp[j] = min{
    dp_prev[j - t1]          ,  // 由 A 处理
    dp_prev[j] + t2          ,  // 由 B 处理
    dp_prev[j - t3] + t3     ,  // 同时处理
  }
  ```
- **滚动数组优化**：通过奇偶交替使用数组，将空间复杂度从 O(n²) 降为 O(n)。
- **枚举上下界优化**：动态调整枚举范围，避免无效计算。

### 可视化设计
1. **动画方案**：
   - **Canvas 绘制时间轴**：左侧为 A 机器时间轴，右侧为 B 机器时间轴，每个任务处理时显示三种转移路径。
   - **高亮当前操作**：用红色标记当前处理的 `j` 值，绿色标记更新的最小值。
   - **步进控制**：用户可暂停/继续，调节动画速度观察状态更新细节。
2. **复古像素风格**：
   - **8 位音效**：在状态更新时播放短促的“滴”声，找到最优解时播放胜利音效。
   - **像素方块表示状态**：每个 `j` 值对应一个像素方块，颜色深浅表示 B 的用时（越深表示时间越长）。
3. **自动演示模式**：
   - 模拟 AI 自动执行状态转移，展示如何从初始状态逐步更新到最优解。

---

## 题解清单（评分 ≥4星）

### 1. wjyyy（5星）
- **亮点**：首次提出进程DP模型，详细解释状态转移与背包思想的结合，优化上下界枚举。
- **关键代码**：
  ```cpp
  for (int j = up; j >= 0; j--) {
    int tmp = INF;
    if (j >= t1) tmp = min(tmp, dp_prev[j - t1]);
    if (t2) tmp = min(tmp, dp_prev[j] + t2);
    if (j >= t3) tmp = min(tmp, dp_prev[j - t3] + t3);
    dp[j] = tmp;
  }
  ```

### 2. colin_lord（4星）
- **亮点**：代码简洁高效，通过 `i&1` 实现滚动数组，无冗余逻辑。
- **代码片段**：
  ```cpp
  memset(dp[i&1], 0x3f, sizeof(dp[i&1]));
  for (int j = sum; j >= 0; j--) {
    dp[i&1][j] = min({
      (t1 && j >= t1) ? dp[(i-1)&1][j - t1] : INF,
      t2 ? dp[(i-1)&1][j] + t2 : INF,
      (t3 && j >= t3) ? dp[(i-1)&1][j - t3] + t3 : INF
    });
  }
  ```

### 3. 一只书虫仔（4星）
- **亮点**：详细推导状态转移方程，明确处理 `t=0` 的边界条件。
- **关键处理**：
  ```cpp
  if (t1[i] == 0) p = INF;  // 处理不可用情况
  if (t2[i] == 0) q = INF;
  if (t3[i] == 0) r = INF;
  ```

---

## 核心代码实现

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int INF = 0x3f3f3f3f;
int dp[2][30005]; // 滚动数组

int main() {
    int n, t1, t2, t3, sum = 0;
    scanf("%d", &n);
    memset(dp, 0x3f, sizeof(dp));
    dp[0][0] = 0; // 初始状态

    for (int i = 1, cur = 1; i <= n; i++, cur ^= 1) {
        scanf("%d%d%d", &t1, &t2, &t3);
        sum += max({t1, t2, t3}); // 更新枚举上界
        memset(dp[cur], 0x3f, sizeof(dp[cur]));

        for (int j = sum; j >= 0; j--) {
            int p = INF, q = INF, r = INF;
            if (t1 && j >= t1) p = dp[cur^1][j - t1];
            if (t2) q = dp[cur^1][j] + t2;
            if (t3 && j >= t3) r = dp[cur^1][j - t3] + t3;
            dp[cur][j] = min({p, q, r});
        }
    }

    int ans = INF;
    for (int i = 0; i <= sum; i++)
        ans = min(ans, max(i, dp[n&1][i]));
    printf("%d\n", ans);
    return 0;
}
```

---

## 相似题目推荐
1. **P1541 [NOIP2010 提高组] 乌龟棋**  
   - 多维背包问题，类似状态压缩。
2. **P2014 [CTSC1997] 选课**  
   - 树形背包问题，依赖关系处理。
3. **P1941 [NOIP2014 提高组] 飞扬的小鸟**  
   - 动态规划结合上下界优化。

---
处理用时：87.05秒
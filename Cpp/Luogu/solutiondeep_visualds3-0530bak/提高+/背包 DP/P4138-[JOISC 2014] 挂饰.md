# 题目信息

# [JOISC 2014] 挂饰

## 题目描述

JOI君有N个装在手机上的挂饰，编号为1...N。 JOI君可以将其中的一些装在手机上。

JOI君的挂饰有一些与众不同——其中的一些挂饰附有可以挂其他挂件的挂钩。每个挂件要么直接挂在手机上，要么挂在其他挂件的挂钩上。直接挂在手机上的挂件最多有1个。

此外，每个挂件有一个安装时会获得的喜悦值，用一个整数来表示。如果JOI君很讨厌某个挂饰，那么这个挂饰的喜悦值就是一个负数。

JOI君想要最大化所有挂饰的喜悦值之和。注意不必要将所有的挂钩都挂上挂饰，而且一个都不挂也是可以的。


## 说明/提示

$1\leq N\leq 2000$

$0\leq Ai\leq N(1\leq i\leq N)$

$-10^6\leq Bi\leq 10^6(1\leq i\leq N)$



## 样例 #1

### 输入

```
5
0 4
2 -2
1 -1
0 1
0 3```

### 输出

```
5```

# AI分析结果



# 算法分类
动态规划（背包问题变种）

---

## 题解思路与算法要点
### 核心逻辑
1. **问题转化**：将挂饰选择问题转化为带约束的背包问题，挂钩数量视为背包容量，喜悦值视为价值。
2. **状态定义**：`dp[i][j]` 表示前i个物品，剩余j个挂钩时的最大喜悦值。
3. **状态转移**：
   - 不选第i个物品：`dp[i][j] = dp[i-1][j]`
   - 选第i个物品：`dp[i][j] = max(dp[i][j], dp[i-1][max(j - a_i +1, 0)] + b_i)`
4. **排序优化**：按挂钩数降序排列，优先处理高挂钩物品，避免无效状态。

### 解决难点
1. **负挂钩处理**：通过 `max(j - a_i +1, 0)` 强制挂钩数非负。
2. **空间优化**：使用滚动数组或一维数组+偏移量处理挂钩数范围（-2000~2000 → 0~4000）。
3. **初始化技巧**：初始状态设为极小值，仅 `dp[0][1] = 0` 表示初始有1个挂钩。

---

## 题解评分（≥4星）
1. **违规用户名U56916（4.5星）**
   - 亮点：二维DP思路直观，排序优化明确，代码结构清晰。
   - 不足：未使用滚动数组，空间复杂度O(N²)对N=2000较勉强。
2. **空の軌跡（4.5星）**
   - 亮点：一维数组+偏移处理，空间优化到位，状态转移方向选择巧妙。
   - 不足：初始化逻辑稍复杂，代码注释较少。
3. **FreeTimeLove（4星）**
   - 亮点：将问题转化为体积为负的背包问题，滚动数组实现简洁。
   - 不足：转化思路较抽象，对新手不够友好。

---

## 最优思路提炼
1. **排序策略**：按挂钩数降序排列，确保优先处理能增加后续选择的物品。
2. **状态压缩**：使用一维数组+偏移量（`j+2000`）处理负挂钩数。
3. **转移方向优化**：根据物品挂钩增减决定正/逆序枚举，避免状态覆盖。
```cpp
// 关键代码片段（一维DP+偏移）
memset(dp, -0x3f, sizeof(dp));
dp[2001] = 0; // 初始偏移量
for (int i=1; i<=n; i++) {
    int delta = a_i - 1; // 挂钩净增量
    if (delta > 0) { // 正增量则逆序枚举
        for (int j=4000; j>=0; j--) {
            if (j + delta <= 4000) dp[j+delta] = max(dp[j+delta], dp[j] + b_i);
        }
    } else { // 负增量则正序枚举
        for (int j=0; j<=4000; j++) {
            if (j + delta >= 0) dp[j+delta] = max(dp[j+delta], dp[j] + b_i);
        }
    }
}
```

---

## 同类型题推荐
1. **P1064 金明的预算方案**（依赖背包）
2. **P1156 垃圾陷阱**（时间约束型背包）
3. **P1273 有线电视网**（树形背包）

---

## 可视化算法演示
### 动画设计
1. **像素风格界面**：
   - 8位色：用16色调色板（NES风格）表示DP状态。
   - Canvas网格：行表示物品序号，列表示挂钩数（-2000~2000映射为0~4000）。
2. **关键操作高亮**：
   - 当前物品：闪烁的红色方块。
   - 状态更新：绿色箭头从旧状态指向新状态。
3. **音效反馈**：
   - 状态更新：短促的"哔"声（Web Audio API）。
   - 最优解找到：8位风格的胜利音效。
4. **交互控制**：
   - 速度滑块：调整动画速度（1x~10x）。
   - 单步执行：空格键逐帧推进。

---

## 复古游戏化实现
```javascript
// 伪代码示例（Canvas绘制核心状态）
const canvas = document.getElementById('dp-canvas');
const ctx = canvas.getContext('2d');

function drawDPGrid() {
  for (let j = 0; j < 4000; j += 10) { // 每10个状态为一格
    const value = dp[j];
    const color = getColorByValue(value); // 根据值映射颜色
    ctx.fillStyle = color;
    ctx.fillRect(j * 2, currentItem * 20, 20, 20);
    
    if (j === bestState) { // 当前最优状态闪烁
      ctx.strokeStyle = '#FF0';
      ctx.strokeRect(j * 2, currentItem * 20, 20, 20);
    }
  }
}
```

**音效触发逻辑**：
- `new Audio('blip.wav').play()` 在每次状态更新时调用。
- 最终答案显示时播放 `victory.wav`（8位风格音乐）。

---

通过上述设计，学习者可直观观察挂钩数的动态变化，理解排序策略的重要性，并掌握处理负容量背包的核心技巧。

---
处理用时：80.82秒
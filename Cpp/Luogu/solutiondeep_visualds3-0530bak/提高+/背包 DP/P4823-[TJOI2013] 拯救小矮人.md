# 题目信息

# [TJOI2013] 拯救小矮人

## 题目描述

一群小矮人掉进了一个很深的陷阱里，由于太矮爬不上来，于是他们决定搭一个人梯。即：一个小矮人站在另一小矮人的 肩膀上，直到最顶端的小矮人伸直胳膊可以碰到陷阱口。

对于每一个小矮人，我们知道他从脚到肩膀的高度 $A_i$，并且他的胳膊长度为 $B_i$。陷阱深度为 $H$。

如果我们利用矮人 $1$，矮人 $2$，矮人 $3$，……，矮人 $k$ 搭一个梯子，满足 $A_1+A_2+A_3+\dots+A_k+B_k \geq H$，那么矮人 $k$ 就可以离开陷阱逃跑了，一旦一个矮人逃跑了，他就不能再搭人梯了。  

我们希望尽可能多的小矮人逃跑，问最多可以使多少个小矮人逃跑。

## 说明/提示

对于 $30\%$ 的数据，$N\leq 200$；  

对于 $100\%$ 的数据，$1 \leq N\leq 2000$，$1 \leq A_i,B_i,H\leq10^5$。

## 样例 #1

### 输入

```
2
20 10
5 5
30```

### 输出

```
2```

## 样例 #2

### 输入

```
2
20 10
5 5
35```

### 输出

```
1```

# AI分析结果



---

## 唯一算法分类
**贪心 + 动态规划**

---

## 综合分析与结论

### 核心思路
1. **贪心排序**：按 $a_i + b_i$ 从小到大排序，让逃生能力弱（身高+手长总和小）的优先逃生
2. **动态规划**：用 `dp[j]` 表示逃出 `j` 人后剩余的最大垫脚高度，通过逆向背包实现状态转移

### 解决难点
- **排序策略证明**：通过邻项交换法证明 $a_i + b_i$ 较小的矮人应优先逃生，保证整体最优性
- **状态转移设计**：每次决策保留当前矮人或让其逃生，通过 `dp[j] = max(dp[j], dp[j-1] - a_i)` 实现最优子结构

### 可视化设计
1. **动画演示**：
   - **排序阶段**：展示矮人按 $a_i + b_i$ 从小到大排列的动画，用不同颜色区分身高与手长
   - **DP阶段**：
     - 高亮当前处理的矮人（红色边框）
     - 显示 `dp` 数组的实时变化（绿色表示可逃出，灰色表示不可）
     - 箭头动画表示状态转移 `dp[j] ← dp[j-1] - a_i`
2. **复古风格**：
   - **像素矮人**：用 8-bit 像素画风绘制不同矮人形象
   - **音效反馈**：
     - 成功逃生时播放 "coin" 音效（类似马里奥金币声）
     - 状态更新时播放短促 "blip" 音效
3. **交互控制**：
   - 步进按钮控制 DP 过程
   - 速度滑块调节动画速度（1x~5x）

---

## 题解清单（≥4星）

### 1. LengChu（★★★★☆）
**核心亮点**：  
- 代码简洁（仅20行），状态压缩至一维数组  
- 逆向背包实现，时间复杂度 $O(n^2)$ 但常数极小  
- 完整处理边界条件（`dp[i] = -inf` 初始化）

### 2. HsKr（★★★★☆）
**核心亮点**：  
- 详细注释解释排序策略与状态定义  
- 使用 `max` 函数优化状态转移，避免无效更新  
- 预处理总身高加速初始化

### 3. Adam_Ng（★★★★☆）
**核心亮点**：  
- 代码模块化清晰（read/处理/输出分离）  
- 使用 `pair` 结构提升可读性  
- 完整呈现贪心到DP的思维链路

---

## 代码实现与核心逻辑
### 关键代码片段（LengChu版）
```cpp
sort(a+1,a+1+n,cmp); 
for(int i=1;i<=n;i++) dp[i]=-0x3f3f3f3f, dp[0]+=a[i].a;  // 初始化总身高

for(int i=1;i<=n;i++) 
    for(int j=i;j>=1;j--) 
        if(dp[j-1]+a[i].b >= h)  // 满足逃生条件
            dp[j] = max(dp[j], dp[j-1]-a[i].a);  // 状态转移
```

### 完整代码（Lumos壹玖贰壹版）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2005;
int n,h,dp[N];
struct node{int a,b;} t[N];

bool cmp(node x,node y){
    if(x.a+x.b == y.a+y.b) return x.a<y.a;
    return x.a+x.b < y.a+y.b;
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d%d",&t[i].a,&t[i].b);
    scanf("%d",&h);
    
    sort(t+1,t+n+1,cmp);
    memset(dp,-0x3f,sizeof(dp));
    dp[0]=0;
    for(int i=1;i<=n;i++) dp[0]+=t[i].a;
    
    for(int i=1;i<=n;i++)
        for(int j=i;j>=1;j--)
            if(dp[j-1]+t[i].b >= h)
                dp[j] = max(dp[j], dp[j-1]-t[i].a);
                
    for(int i=n;i>=0;i--)
        if(dp[i]>=0) return printf("%d",i),0;
}
```

---

## 同类型题与算法套路
### 相似问题特征
- **贪心排序+资源分配**：如P1080 [NOIP2012] 国王游戏（乘积排序+高精度）
- **背包变形**：P1156 垃圾陷阱（高度随时间变化的背包问题）
- **反悔贪心**：P4053 [JSOI2007] 建筑抢修（优先队列维护反悔操作）

### 通用解法
1. **双属性排序**：当问题涉及两个相关参数时（如身高+手长），尝试建立排序规则
2. **逆向背包**：当决策影响后续资源时，从后往前更新状态避免覆盖
3. **剩余资源维护**：用动态规划维护可重复利用的资源量（如剩余高度）

---

## 推荐练习题
1. **P1080** 国王游戏 - 贪心排序+高精度  
2. **P1230** 智力大冲浪 - 时间窗口+贪心  
3. **P4544** [USACO10NOV]购买饲料 - 费用背包+滑动窗口优化

---

## 个人心得摘录
> "开始以为要二维DP，后来发现剩余高度可以压缩状态。初始化 `dp[0]` 时忘记累加所有身高，调试半天才找到这个bug" —— HsKr  
> "贪心策略的证明最烧脑，画了十几张草稿纸才想通邻项交换的正确性" —— Lumos壹玖贰壹  
> "第一次想到用优先队列替换，但时间复杂度反而更高，最终回归DP本质" —— 灯芯糕

---

## 可视化算法演示（复古版）
### 实现方案
```html
<canvas id="pixel-canvas" width="640" height="480"></canvas>
<script>
// 初始化 8-bit 风格参数
const COLORS = ['#000000','#FF0000','#00FF00','#0000FF','#FFFF00','#FF00FF'];
const sprites = [/* 矮人像素数据 */];

class DwarfSimulator {
  constructor() {
    this.dp = Array(n+1).fill(-Infinity);
    this.dp[0] = totalHeight;
    this.currentStep = 0;
  }

  render() {
    // 绘制当前矮人形象与dp数组状态
    ctx.fillStyle = COLORS[3];
    ctx.fillRect(x, y, 16, 16); // 绘制矮人像素块
    // 用绿色方块表示可逃出状态
    if(dp[j] >=0) ctx.fillStyle = COLORS[2];
  }

  nextStep() {
    if(this.currentStep >= n) return;
    // 触发音效
    playSound('blip.wav');
    // 更新dp状态
    this.updateDP();
    this.currentStep++;
  }
}

// 交互控制
document.getElementById('next-btn').addEventListener('click', () => {
  simulator.nextStep();
});
</script>
```

### 交互说明
- **A键**：自动播放/暂停  
- **方向键**：单步前进/回退  
- **Esc键**：重置演示  
- **顶部状态栏**：显示当前处理的矮人序号与dp值

---

通过整合贪心策略与动态规划，该问题在 $O(n^2)$ 时间复杂度内得到最优解，其核心在于通过排序确定逃生优先级，再通过背包思想维护剩余资源。可视化演示可有效帮助理解状态转移过程与贪心策略的正确性。

---
处理用时：92.95秒
# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果



## 唯一算法分类
模拟、枚举

---

## 综合分析与结论

### 核心思路与难点
题目要求确定覆盖某点的最上层地毯。核心难点在于：
1. **内存限制**：直接存储二维坐标系会引发 MLE
2. **覆盖判断**：需要高效判断点是否在矩形区域内

所有题解均采用**存储地毯参数+线性扫描**的方案。核心流程为：
1. 存储每个地毯的坐标范围（a,b为左上角，a+g为横轴覆盖长度，b+k为纵轴覆盖长度）
2. 对于目标点(x,y)，判断是否满足 a ≤ x ≤ a+g 且 b ≤ y ≤ b+k
3. **逆序遍历优化**：从最后铺设的地毯开始检查，找到首个满足条件的地毯即可终止循环

### 可视化设计
- **动态演示地毯覆盖范围**：用不同颜色矩形表示各层地毯，后铺的覆盖在先铺的上方
- **步进检测**：高亮当前检测的地毯，用闪烁效果标记其边界
- **命中反馈**：当检测到覆盖时，目标点变为红色并触发音效
- **8-bit 像素风**：用复古风格绘制坐标系，地毯用色块表示，检测过程伴随经典FC音效

---

## 高星题解清单 (≥4星)

### 1. 智子（5星）
- **亮点**：完整分析MLE原因，给出正确解法模板代码
- **代码可读性**：变量命名规范，注释清晰
- **优化点**：正序扫描记录最后覆盖的地毯

### 2. Vct14（4.5星）
- **亮点**：逆序扫描提前终止，时间复杂度优化
- **代码简洁性**：使用结构体存储参数，条件判断简明

### 3. kuaiCreator（4星）
- **亮点**：明确说明逆序遍历的优势
- **实现细节**：变量命名直观，边界条件处理清晰

---

## 最优思路提炼

**逆序扫描+矩形包含判断**：
```cpp
for(int i = n; i >= 1; i--) {
    if(x >= a[i] && x <= a[i]+g[i] && 
       y >= b[i] && y <= b[i]+k[i]) {
        cout << i;
        return 0;
    }
}
```
- **优势**：找到首个满足条件的地毯即可立即返回，避免完整遍历
- **时间复杂度**：最优O(1)，最坏O(n)

---

## 类似题目推荐
1. P1058 立体图（二维坐标系模拟）
2. P1502 窗口的星星（矩形覆盖问题）
3. P3743 kotori的设备（二分答案+范围判断）

---

## 核心代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4+5;
int a[N],b[N],g[N],k[N],n,x,y;

int main() {
    cin >> n;
    for(int i=1; i<=n; i++) 
        cin >> a[i] >> b[i] >> g[i] >> k[i];
    cin >> x >> y;
    
    for(int i=n; i>=1; i--) { // 逆序关键点
        if(x >= a[i] && x <= a[i]+g[i] && 
           y >= b[i] && y <= b[i]+k[i]) {
            cout << i;
            return 0;
        }
    }
    cout << -1;
    return 0;
}
```

---

## 可视化方案设计

### 动画逻辑
1. **初始化**：绘制坐标系，用不同色块依次渲染各层地毯
2. **检测阶段**：
   - 从最后一个地毯开始，高亮其边界线
   - 显示从目标点发射的检测射线（水平/垂直虚线）
   - 触发"滴"声效表示检测步骤
3. **命中反馈**：当地毯覆盖点时，该地毯闪烁三次并播放胜利音效

### 8-bit 风格实现
```javascript
// 伪代码示例
class RetroAnimation {
    constructor() {
        this.palette = ["#000","#F00","#0F0","#00F","#FF0"]; // FC经典配色
        this.drawGrid(); // 绘制坐标系网格
    }
    
    highlightRect(index) { // 高亮当前检测的地毯
        ctx.fillStyle = this.palette[index % 5];
        ctx.globalAlpha = 0.3;
        ctx.fillRect(a[i], b[i], g[i], k[i]);
    }
    
    checkPoint(x, y) { // 检测动画
        playSound('blip'); // 8-bit 音效
        if(isCovered) {
            playSound('win', {pitch: 1200});
            this.blinkRect(currentIndex);
        }
    }
}
```

---

## 总结与扩展
本题通过逆向思维将时间复杂度优化至理论最优。在处理覆盖类问题时，**考虑操作时序的逆向性**往往能带来意想不到的优化效果。同类问题可尝试建立操作栈或记录操作历史，通过反向查询提高效率。

---
处理用时：64.85秒
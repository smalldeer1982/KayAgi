# 题目信息

# 计算器写作文

## 题目描述

众所周知，计算器可以拿来干很多它本不应该干的事情，比如弹琴。

小A发现了一个计算器的隐藏功能——写英语作文。

他在计算器上按一些数字，这些然后旋转 $180$ 度就是作文。

每个数字对应一两个字母

 ![](https://cdn.luogu.com.cn/upload/pic/1738.png) 



小 A 准备了一个单词表，选择其中的一些单词，按照一个顺序组成作文。这个作文是可以用计算器按出来的。比如单词表给 `ODD`、`EGG`，作文写成 `ODDEGG` 的话，那么要在计算器上按出 `993000`，这篇作文的得分就是 $993000$。

单词表的单词不能重复使用。如果单词表出现了多个一样的单词，每个单词最多都可以各使用一次。单词不可以被截断。

小 A 希望自己写出的作文得分最高。当然这个计算器是有位数限制，作文长度不能超过显示位数。

计算器不能显示前导零，但是你可以添加小数点。比如作文写成 `EGGODD` 的话，就得按出 $0.00993$，这个就是作文的得分，当然这得分太小了。


## 说明/提示



对于 $40\%$ 的数据，$D \leq 20,N \leq 10$。

对于 $100\%$ 的数据，$D \leq 200,N \leq 10000$，单词长度 $\leq 32$。

## 样例 #1

### 输入

```
7

4

EGG

ODD

LOBE

LIBE```

### 输出

```
9933817```

# AI分析结果



## 算法分类选择
**动态规划（01背包） + 贪心排序**

---

## 题解思路、算法要点与解决难点

### 核心思路
1. **字符串转换**：将每个单词按题目规则转换为数字字符串（需反转后转换，如`EGG`转`993`）。
2. **排序策略**：按两字符串拼接结果的大小排序，确保最优拼接顺序。
3. **动态规划**：用01背包模型，状态`f[j]`表示使用`j`位时的最大字符串。

### 关键难点与解决方案
- **排序后效性**：通过自定义排序函数`a+b > b+a`消除后效性，确保拼接顺序最优。
- **前导零处理**：分两种情况处理：存在非零开头字符串时优先长度，否则按字符序比较。
- **字符串比较**：动态规划中需自定义字符串比较逻辑，结合长度与字典序。

---

## 题解评分（≥4星）

### 1. 凯特琳（5星）
- **亮点**：深入分析排序策略，正确处理前导零，提供清晰的Pascal代码与思路。
- **关键代码**：自定义`max`函数处理不同情况，排序函数基于拼接结果比较。

### 2. 星王桐（4.5星）
- **亮点**：简洁的C++实现，使用字符串直接比较，处理前导零逻辑清晰。
- **代码片段**：
  ```cpp
  bool cmp(string a,string b) { return a+b < b+a; }
  for (j=m;j>=ni[i];j--) f[j]=maxs(f[j],f[j-ni[i]]+v[i]);
  ```

### 3. cunzai_zsy0531（4星）
- **亮点**：自定义`Big`结构体封装操作，分情况处理比较逻辑，代码模块化。
- **核心代码**：
  ```cpp
  bool operator>(const Big &A)const {
    if (len!=A.len) return len>A.len;
    for(int i=1;i<=len;++i) if(d[i]!=A.d[i]) return d[i]>A.d[i];
    return 0;
  }
  ```

---

## 最优思路或技巧提炼
1. **贪心排序**：比较`a+b`与`b+a`的字典序，确保拼接后的数值最大。
2. **分情况处理比较**：存在非零字符串时优先长度，否则逐字符比较。
3. **动态规划优化**：倒序遍历背包容量避免重复选择，字符串拼接代替数值计算。

---

## 同类型题或类似算法套路
- **拼接最大数问题**（如LeetCode 179）：类似排序策略。
- **带顺序的背包问题**：需先排序消除后效性。
- **高精度动态规划**：用字符串代替数值处理大数。

---

## 推荐洛谷题目
1. **P1792 [国家集训队]种树**（贪心+堆）
2. **P1064 金明的预算方案**（依赖背包+分组处理）
3. **P2217 [HAOI2007]分割矩阵**（动态规划+状态设计）

---

## 个人心得摘录
- **凯特琳**：强调排序策略对背包后效性的消除作用，类比“烹调方案”题。
- **hanzhongtlx**：提到特判全零情况的处理，需单独比较小数点后的字符顺序。

---

## 可视化与算法演示

### 动态规划状态更新动画
1. **网格展示**：以`D×N`网格表示背包容量与物品，高亮当前更新的状态。
2. **颜色标记**：
   - **红色**：当前处理的物品。
   - **绿色**：更新后的更优状态。
   - **黄色**：待比较的旧状态。
3. **拼接过程**：在网格旁实时显示字符串拼接结果，对比新旧状态。

### 复古像素风格设计
- **8位音效**：更新状态时播放“哔”声，找到更优解时播放上升音调。
- **Canvas动画**：背包容量以像素方块表示，物品进入时滑入效果。
- **自动演示**：AI逐步选择物品，动态展示排序与状态更新流程。

---

## 核心代码实现（星王桐题解）
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

string f[201]; // f[j]: 使用j位时的最大字符串
string v[10001]; // 转换后的字符串
int ni[10001]; // 各字符串长度

bool cmp(string a, string b) { return a + b > b + a; }

string maxs(string a, string b) {
    if (a.empty()) return b;
    if (b.empty()) return a;
    if (a[0]!='0' && b[0]!='0') { // 非前导零情况
        if (a.size() != b.size()) return a.size()>b.size() ? a : b;
        return a > b ? a : b;
    }
    return a > b ? a : b; // 前导零直接比较
}

int main() {
    // 转换与排序略
    for (int i=1; i<=n; i++) 
        for (int j=m; j>=ni[i]; j--)
            f[j] = maxs(f[j], f[j-ni[i]] + v[i]);
    // 输出处理略
}
```

---

## 总结
本题结合贪心与动态规划，核心在于通过排序消除后效性，并灵活处理字符串比较逻辑。通过分情况讨论和自定义比较函数，可有效解决数值拼接与前导零问题。

---
处理用时：85.61秒
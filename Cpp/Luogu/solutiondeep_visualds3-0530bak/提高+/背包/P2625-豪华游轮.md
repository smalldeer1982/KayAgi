# 题目信息

# 豪华游轮

## 题目描述

有一条豪华游轮（其实就是条小木船），这种船可以执行 $4$ 种指令：

`right X`：其中 $X$ 是一个 $1$ 到 $719$ 的整数，这个命令使得船顺时针转动 $X$ 度。

`left X`：其中 $X$ 是一个 $1$ 到 $719$ 的整数，这个命令使得船逆时针转动 $X$ 度。

`forward X`：其中 $X$ 是一个整数（$1$ 到 $1000$），使得船向正前方前进 $X$ 的距离。

`backward X`：其中 $X$ 是一个整数（$1$ 到 $1000$），使得船向正后方前进 $X$ 的距离。

随意的写出了 $n$ 个命令，找出一个种排列命令的方法，使得船最终到达的位置距离起点尽可能的远。


## 样例 #1

### 输入

```
3
forward 100
backward 100
left 90```

### 输出

```
141.421356```

# AI分析结果



## 唯一算法分类
动态规划（背包问题）

---

## 综合分析与结论
### 核心思路与难点
1. **指令分组策略**：将所有 `forward` 和 `backward` 指令合并为总前进距离 `a` 和总后退距离 `b`，最大化总位移的关键是二者的矢量合成。
2. **角度背包问题**：将 `left X` 转化为 +X°，`right X` 转化为 -X°，通过动态规划记录所有可能的总旋转角度（模360°），寻找最接近180°的角度。
3. **余弦定理计算距离**：最终距离公式为 `sqrt(a² + b² - 2ab·cosθ)`，θ为最接近180°的可用角度。

### 可视化设计思路
1. **背包状态展示**：用网格图展示动态规划状态，每个格子代表一个可能的角度（0~359°），随着转向指令逐步更新。
2. **角度选择动画**：高亮当前处理的转向指令，实时更新可到达的角度集合，最终用红色标记最接近180°的角度。
3. **矢量合成演示**：动态绘制前进和后退矢量，通过夹角变化展示不同角度下的合成结果。

---

## 题解清单（≥4星）
### 1. 斗神_君莫笑（4星）
**亮点**：最早提出背包模型，代码简洁，但未处理负数角度取模问题。  
**核心代码**：
```cpp
f[0] = 1;
for(int i=0;i<360;++i)
    while(a[i]--)
        for(int j=20000;j>=0;--j)
            if(f[j]) f[j+i]++;
```

### 2. Disillusionment（4.5星）
**亮点**：二维状态数组更清晰，正确处理负数角度。  
**核心代码**：
```cpp
for(int i=1;i<=cir[0];i++)
    for(int j=0;j<360;j++)
        if(f[i-1][j])
            f[i][(j+cir[i]+3600)%360] = 1;
```

### 3. Travis（4星）
**亮点**：代码可读性强，明确处理角度模运算。  
**核心代码**：
```cpp
tmp = (j+R[i]+720) % 360;
f[i][tmp] = 1;
```

---

## 最优思路提炼
1. **角度归一化**：将所有转向转换为逆时针角度 `[0,360)`
   ```cpp
   // left X → +X°, right X → 360-X°
   ang = (cmd=="left") ? X : 360-X;
   ```
2. **01背包建模**：用 `f[i][j]` 表示前i个转向能否得到角度j
   ```cpp
   f[i][(j+ang)%360] |= f[i-1][j]; // 状态转移
   ```
3. **角度最优选择**：在所有可达角度中选择最接近180°的θ
   ```cpp
   minθ = min(minθ, abs(j-180)); // 遍历所有j where f[n][j]==true
   ```

---

## 同类型题推荐
1. P2625 豪华游轮（本题）
2. P2347 砝码称重（背包问题变种）
3. P2115 [USACO14MAR]破坏（角度最优化）

---

## 复古游戏化动画设计
### 像素风格实现
1. **船只绘制**：8位风格的三角形像素船，旋转时改变顶点坐标
   ```javascript
   function drawShip(angle) {
     ctx.fillStyle = '#FF5555';
     const pts = calcRotatedPoints(angle); // 计算旋转后坐标
     ctx.beginPath(); ctx.moveTo(pts[0]); // 绘制三角形
   }
   ```
2. **背包状态网格**：用16x23的网格表示0~359°，绿色格子表示可达角度
   ```javascript
   function drawDPGrid() {
     for(let i=0; i<360; i++) {
       if(f[i]) ctx.fillRect(x, y, 10, 10); // 绿色填充可达角度
     }
   }
   ```

### 音效设计
- **转向处理**：`bleep.wav`（8位风格短音）
- **找到最优角度**：`success.wav`（上升音阶）
- **错误操作**：`error.wav`（低频噪音）

---

## 代码实现（核心部分）
```cpp
#include<bits/stdc++.h>
using namespace std;
bool f[360] = {1}; // 背包状态数组
int main() {
    int n, a=0, b=0, deg;
    cin >> n;
    while(n--) {
        string cmd; int x; cin >> cmd >> x;
        if(cmd[0]=='f') a += x;
        else if(cmd[0]=='b') b += x;
        else {
            if(cmd[0]=='r') x = 360 - x; // 转换右转为逆时针角度
            for(int j=359; j>=0; j--)     // 01背包核心
                if(f[j]) f[(j+x)%360] = true;
        }
    }
    int min_theta = 180;
    for(int j=0; j<360; j++) 
        if(f[j]) min_theta = min(min_theta, abs(j-180));
    double ans = sqrt(a*a + b*b + 2*a*b*cos(min_theta*M_PI/180));
    printf("%.6f", ans);
}
```

---
处理用时：85.91秒
# 题目信息

# [JOISC 2014] 挂饰

## 题目描述

JOI君有N个装在手机上的挂饰，编号为1...N。 JOI君可以将其中的一些装在手机上。

JOI君的挂饰有一些与众不同——其中的一些挂饰附有可以挂其他挂件的挂钩。每个挂件要么直接挂在手机上，要么挂在其他挂件的挂钩上。直接挂在手机上的挂件最多有1个。

此外，每个挂件有一个安装时会获得的喜悦值，用一个整数来表示。如果JOI君很讨厌某个挂饰，那么这个挂饰的喜悦值就是一个负数。

JOI君想要最大化所有挂饰的喜悦值之和。注意不必要将所有的挂钩都挂上挂饰，而且一个都不挂也是可以的。


## 说明/提示

$1\leq N\leq 2000$

$0\leq Ai\leq N(1\leq i\leq N)$

$-10^6\leq Bi\leq 10^6(1\leq i\leq N)$



## 样例 #1

### 输入

```
5
0 4
2 -2
1 -1
0 1
0 3```

### 输出

```
5```

# AI分析结果



# 算法分类：动态规划（背包问题变种）

---

## 题解思路与核心难点

### 核心思路
1. **动态规划状态设计**  
   - 定义 `dp[i][j]` 表示前 `i` 个挂饰处理完成后，剩余 `j` 个挂钩时的最大喜悦值。
   - **关键变量**：挂钩数 `j` 作为状态维度，确保每一步转移时挂钩数足够挂后续物品。

2. **排序优化**  
   - 将挂饰按挂钩数 **从大到小排序**，确保优先处理能提供更多挂钩的挂饰，避免后续因挂钩不足而无法挂载高价值物品。

3. **状态转移方程**  
   - 转移时考虑两种选择：不选当前挂饰（直接继承 `dp[i-1][j]`）或选当前挂饰（需消耗一个挂钩并增加新挂钩）：
     \[
     dp[i][j] = \max\left(dp[i-1][j],\ dp[i-1][\max(j - a_i, 0) + 1] + b_i\right)
     \]
   - **解决负数问题**：当 `j - a_i < 0` 时，强制取 `0`，确保状态合法。

### 解决难点
- **挂钩的动态增减**：每个挂饰的挂钩数可能增加或减少当前可用挂钩数，需确保状态转移时挂钩数始终非负。
- **无效状态处理**：初始化时将所有状态设为极小值（如 `-INF`），仅保留合法的初始状态 `dp[0][1] = 0`（初始手机有一个挂钩）。

---

## 题解评分（≥4星）

1. **违规用户名U56916（★★★★☆）**  
   - **亮点**：清晰的二维DP实现，排序策略明确，代码结构简洁。  
   - **优化**：通过 `max(j - a_i, 0)` 处理负数挂钩，确保转移合法性。

2. **FreeDr（★★★★☆）**  
   - **亮点**：分类处理正负价值物品，结合贪心与背包，减少需处理的物品数量。  
   - **适用场景**：适用于物品价值分布有明显正负分界的情况。

3. **空の軌跡（★★★★☆）**  
   - **亮点**：一维滚动数组优化空间，动态调整转移方向（正向/反向）。  
   - **实现技巧**：将挂钩数限制在 `2000` 以内，处理负数下标。

---

## 最优思路提炼

### 关键技巧
- **排序降贪心**：按挂钩数降序排序，确保先处理高挂钩物品。
- **状态转移剪枝**：通过 `max(j - a_i, 0)` 避免无效状态，保证转移合法性。
- **初始化策略**：仅保留初始合法状态 `dp[0][1] = 0`，其余设为极小值。

### 代码片段
```cpp
struct Node { int a, b; };
vector<Node> items; // 挂饰列表

sort(items.begin(), items.end(), [](const Node& x, const Node& y) {
    return x.a > y.a; // 按挂钩数降序排序
});

vector<vector<int>> dp(n+1, vector<int>(n+1, -INF));
dp[0][1] = 0; // 初始状态

for (int i = 1; i <= n; i++) {
    int a = items[i-1].a, b = items[i-1].b;
    for (int j = 0; j <= n; j++) {
        dp[i][j] = max(dp[i-1][j], dp[i-1][max(j - a, 0) + 1] + b);
    }
}

int ans = *max_element(dp[n].begin(), dp[n].end());
```

---

## 类似题目与推荐

### 相似算法套路
- **背包问题变种**：如“金明的预算方案”（洛谷P1064）、“垃圾陷阱”（洛谷P1156），处理物品选择对后续容量的影响。
- **动态规划状态设计**：如“选课”（洛谷P2014），树形依赖背包问题。

### 推荐题目
1. **洛谷P1064**：依赖背包问题，需处理主件与附件的关系。
2. **洛谷P1156**：动态规划结合时间与高度的状态设计。
3. **洛谷P2014**：树形背包问题，处理子树依赖关系。

---

## 可视化与算法演示

### 核心动画设计
- **动态规划表更新**：以表格形式展示 `dp[i][j]` 的更新过程，高亮当前处理的挂饰和更新的状态。
- **颜色标记**：  
  - **红色**：当前处理的挂饰。  
  - **绿色**：状态转移中被更新的单元格。  
  - **蓝色**：当前最大值所在位置。

### 复古像素风格实现
- **Canvas绘制**：将挂饰显示为像素方块，颜色根据挂钩数和价值动态调整（挂钩数越多越亮，价值越高越暖）。
- **音效设计**：  
  - **选中挂饰**：短促“哔”声。  
  - **更新最大值**：上扬音调。  
  - **错误转移**：低沉“嗡”声。

### 交互功能
- **步进控制**：允许单步执行或自动播放，速度可调。
- **状态追踪**：点击表格单元格显示转移路径（从哪个状态转移而来）。

---

## 个人心得摘录

> “排序是核心，确保先处理高挂钩物品，避免后续无法挂载。初始化时除了 `dp[0][1]` 全设为极小值，避免无效状态污染结果。” —— 违规用户名U56916  
> “分类处理正负价值物品能显著减少DP计算量，但需严格验证分类逻辑的正确性。” —— FreeDr

---

通过上述分析与实现，可高效解决挂饰问题，核心在于合理设计动态规划状态与优化转移逻辑。

---
处理用时：103.91秒
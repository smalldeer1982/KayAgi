# 题目信息

# 选举

## 题目描述

Byteland 国的居民最近一直为议会选举投票。现在，当结果公布的时候，党派不得不决定联合组建政府。 

每个党派都会获得议会中的一定席位。联合政府由这些党派中的一部分组成，他们在议会中的席位数之和**严格大于**总席位数的一半。对于联合政府来说，席位越多越好。

一个**过剩**的联合政府是指联合政府中的一个党派被移出后，剩余的联合政府在国会中仍有过半数的席位。

请写一个程序能够找到一个在议会中有着**最大可能席位数**且**不过剩**的联合政府。

## 说明/提示

样例解释：选择第二个政党和第四个。

对于全部数据，$1\le n\le 300$。

## 样例 #1

### 输入

```
4
1 3 2 4```

### 输出

```
7```

# AI分析结果



### **唯一算法分类**  
**动态规划（01背包）**

---

### **综合分析与结论**  

#### **核心思路**  
1. **排序优化条件判断**：将政党按席位数**从大到小排序**，确保每次处理的党是当前最小的，只需检查移除该党后是否满足不过剩条件。  
2. **动态规划状态设计**：用 `dp[j]` 表示能否组成总席位数为 `j` 的内阁，遍历时逐步更新可能的席位数。  
3. **合法性条件**：对于总席位数 `S`，需满足 `S > sum/2` 且 `S - min_p ≤ sum/2`（`min_p` 是内阁中最小党席位）。  

#### **可视化设计**  
- **动画流程**：  
  1. **排序阶段**：展示政党按席位从大到小排列的动画，用不同颜色区分大小。  
  2. **背包更新**：用网格表示 `dp` 数组，绿色格子表示可达的席位数。处理每个党时，从右向左填充新格子，并高亮新满足条件的格子（如总席位超过一半）。  
  3. **条件检查**：当新加入的党使总席位超过一半时，弹出提示框显示当前是否合法。  
- **复古风格**：  
  - **像素网格**：用 8-bit 风格的格子表示 `dp` 数组，每次更新时播放“滴答”音效。  
  - **音效触发**：合法解出现时播放胜利音效，非法操作时播放失败音效。  
- **交互控制**：允许调整动画速度，单步执行观察背包更新细节。

---

### **题解清单 (≥4星)**  

1. **PBCWZCC (4.5星)**  
   - **亮点**：代码简洁，排序后反向处理，结合背包与条件判断一步到位。  
   - **代码可读性**：变量命名清晰，逻辑紧凑。  
   - **个人心得**：通过排序保证最后加入的党最小，简化条件判断。  

2. **vectorwyx (4星)**  
   - **亮点**：数学推导严谨，用滚动数组优化空间，代码注释详细。  
   - **解决难点**：通过充要条件转化，将问题转化为动态规划状态转移。  

3. **ShineEternal (4星)**  
   - **亮点**：思路与代码高度一致，注释明确，适合快速理解。  
   - **优化点**：直接在背包更新时检查条件，避免后续遍历。  

---

### **最优思路提炼**  

#### **关键步骤**  
1. **排序降序**：确保每次处理的党是当前最小的。  
2. **背包状态更新**：从大到小遍历席位数，更新 `dp[j] = max(dp[j], dp[j-a[i]] + a[i])`。  
3. **合法性检查**：在更新时检查 `j > sum/2` 且 `j - a[i] ≤ sum/2`。  

#### **代码片段**  
```cpp
sort(a + 1, a + n + 1, greater<int>()); // 降序排序
int sum = accumulate(a + 1, a + n + 1, 0);
vector<bool> dp(sum + 1, false);
dp[0] = true;
int ans = 0;

for (int i = 1; i <= n; i++) {
    for (int j = sum; j >= a[i]; j--) {
        if (dp[j - a[i]]) {
            dp[j] = true;
            if (j > sum / 2 && j - a[i] <= sum / 2) {
                ans = max(ans, j);
            }
        }
    }
}
```

---

### **同类型题与算法套路**  
- **类似问题**：条件约束下的最大子集和（如必须包含某类元素）。  
- **通用解法**：动态规划 + 排序预处理，将复杂条件转化为状态转移条件。  

---

### **推荐题目**  
1. **P1048 [NOIP2005 普及组] 采药**（01背包模板）  
2. **P1060 [NOIP2006 普及组] 开心的金明**（变种背包）  
3. **P1156 [NOIP2008 提高组] 垃圾陷阱**（动态规划结合时间约束）  

---

### **个人心得摘录**  
- **PBCWZCC**：“排序后从大到小处理，保证最后加入的党是最小的，这样只需检查移除它后的合法性。”  
- **vectorwyx**：“通过充要条件转化，将双变量问题转化为单变量动态规划。”  

---

### **可视化算法演示**  
#### **动画设计**  
- **背包网格**：用 Canvas 绘制网格，每个格子表示一个席位数，绿色表示可达。  
- **高亮当前党**：处理第 `i` 个党时，其对应的像素块闪烁，更新时播放音效。  
- **条件检查提示**：当满足 `j > sum/2` 时，格子变为黄色；合法解变为红色并记录最大值。  

#### **复古交互**  
- **8-bit 风格**：使用 NES 调色板，背景音乐为《超级马里奥》地下关卡旋律。  
- **自动演示**：AI 自动运行背包更新，用户可暂停观察当前状态。  
- **音效设计**：  
  - 格子更新：短促“哔”声。  
  - 找到合法解：播放《塞尔达传说》获得物品音效。  

---

**通过动态规划与排序的巧妙结合，将复杂条件转化为高效算法，是本题的核心思想。**

---
处理用时：96.45秒
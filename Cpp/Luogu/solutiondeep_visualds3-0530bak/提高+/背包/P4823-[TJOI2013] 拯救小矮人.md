# 题目信息

# [TJOI2013] 拯救小矮人

## 题目描述

一群小矮人掉进了一个很深的陷阱里，由于太矮爬不上来，于是他们决定搭一个人梯。即：一个小矮人站在另一小矮人的 肩膀上，直到最顶端的小矮人伸直胳膊可以碰到陷阱口。

对于每一个小矮人，我们知道他从脚到肩膀的高度 $A_i$，并且他的胳膊长度为 $B_i$。陷阱深度为 $H$。

如果我们利用矮人 $1$，矮人 $2$，矮人 $3$，……，矮人 $k$ 搭一个梯子，满足 $A_1+A_2+A_3+\dots+A_k+B_k \geq H$，那么矮人 $k$ 就可以离开陷阱逃跑了，一旦一个矮人逃跑了，他就不能再搭人梯了。  

我们希望尽可能多的小矮人逃跑，问最多可以使多少个小矮人逃跑。

## 说明/提示

对于 $30\%$ 的数据，$N\leq 200$；  

对于 $100\%$ 的数据，$1 \leq N\leq 2000$，$1 \leq A_i,B_i,H\leq10^5$。

## 样例 #1

### 输入

```
2
20 10
5 5
30```

### 输出

```
2```

## 样例 #2

### 输入

```
2
20 10
5 5
35```

### 输出

```
1```

# AI分析结果



## 唯一算法分类
**贪心 + 动态规划**

---

## 综合分析与结论
### 核心思路
所有题解均基于两个核心结论：
1. **排序策略**：将小矮人按 $a_i + b_i$ 从小到大排序。这种排序确保逃生能力弱（需要更低总高度）的人优先逃生，避免其成为后续逃生的瓶颈。
2. **动态规划状态转移**：定义 `dp[j]` 表示逃出 `j` 人后剩余的总高度。转移时，若当前小矮人 `i` 满足 `dp[j-1] + b_i >= H`，则更新 `dp[j] = max(dp[j], dp[j-1] - a_i)`。

### 算法难点
1. **排序正确性证明**：需证明按 $a_i + b_i$ 排序后，交换任意两人顺序不会得到更优解（邻项交换法）。
2. **背包优化方向**：灯芯糕的题解提出使用优先队列替换已逃出者中贡献最差的人，将时间复杂度优化至 $O(n \log n)$，但实现复杂度较高。

### 可视化设计
1. **像素动画**：在 Canvas 中以 8-bit 风格绘制小矮人队列，每个角色用不同颜色区分身高和手长（图例：蓝色=身高，红色=手长）。
2. **关键步骤高亮**：
   - 排序阶段：用闪烁效果展示相邻元素比较和交换。
   - DP 阶段：用箭头指示当前处理的小矮人，背包数组用动态高度条表示剩余高度。
3. **音效提示**：
   - 排序完成时播放「升级」音效。
   - 成功逃出时播放「金币收集」音效，失败时播放「撞击」音效。
4. **AI 自动演示**：自动运行算法流程，允许暂停观察 `dp[]` 数组状态。

---

## 题解清单（评分 ≥4星）
### 1. LengChu（4.5星）
- **亮点**：代码简洁，直接使用排序+01背包，时间复杂度 $O(n^2)$ 但常数极小，适用于题目数据范围。
- **核心代码**：
  ```cpp
  sort(a+1,a+1+n,cmp);
  for(int i=1;i<=n;i++) 
    for(int j=i;j>=1;j--) 
      if(dp[j-1]+a[i].b>=h) 
        dp[j]=max(dp[j],dp[j-1]-a[i].a);
  ```

### 2. HsKr（4星）
- **亮点**：详细推导排序策略，明确给出状态转移方程 `f[j] = max(f[j], f[j-1] - a_i)`，代码可读性强。
- **个人心得**：强调「矮的不先走可能永远走不掉」，直观解释贪心策略。

### 3. 灯芯糕（4星）
- **亮点**：提出 $O(n \log n)$ 贪心优化，使用优先队列动态维护已逃出者中的最大身高，适合更大数据规模。
- **关键代码**：
  ```cpp
  priority_queue<people> q;
  if (当前人可逃出) q.push(p[i]);
  else if (队列非空且替换可行) {
      q.pop(); 
      q.push(p[i]);
  }
  ```

---

## 最优思路提炼
### 核心技巧
1. **贪心排序**：按 $a_i + b_i$ 升序排列，确保局部最优解能导向全局最优。
2. **背包状态压缩**：用一维数组 `dp[j]` 逆向更新，避免二维数组的空间开销。
3. **反悔贪心**（灯芯糕方法）：当新人无法逃出时，用优先队列替换已逃出者中身高最大者，最大化剩余高度。

### 代码片段（LengChu 实现）
```cpp
struct node{ int a,b; } a[2010];
bool cmp(node x,node y){ return x.a+x.b<y.a+y.b; }

int dp[2010]; // dp[i]: 逃出i人后的剩余高度
for (int i=1; i<=n; i++) {
    for (int j=i; j>=1; j--) {
        if (dp[j-1] + a[i].b >= h) 
            dp[j] = max(dp[j], dp[j-1] - a[i].a);
    }
}
```

---

## 同类型题推荐
1. **P1417 烹调方案**：同样需要排序后处理背包问题。
2. **P1090 合并果子**：贪心+优先队列的经典问题。
3. **P5020 货币系统**：贪心与动态规划的结合。

---

## 可视化与游戏化设计
### 复古像素动画
1. **角色绘制**：每个小矮人用 16x16 像素方块表示，上半部分为身高（蓝色），下半部分为手长（红色）。
2. **排序演示**：相邻元素比较时高亮边框，交换时播放「咔嗒」音效。
3. **背包更新**：用绿色进度条表示 `dp[j]` 的值，成功更新时进度条增长并播放「滴」声。
4. **自动模式**：按空格键切换自动/手动模式，自动模式下算法以每秒2步的速度执行。

### 音效设计
- **背景音乐**：8-bit 风格循环旋律。
- **关键事件**：
  - 逃出成功：高音「叮」。
  - 替换操作：低音「咚」。

---

## 个人心得摘录
> **HsKr**：*“如果矮的不先走，那他以后有可能永远也走不掉了”*  
> **灯芯糕**：*“不服来Hack！证明过程不一定完全正确，但做题需要感性理解”*  
> **Lumos壹玖贰壹**：*“贪心选择逃生能力较弱的人先逃，但可能有人奉献更优”*  

---

## 总结
本题的解法体现了贪心与动态规划的经典结合，排序策略的正确性和状态转移的设计是核心。可视化设计可通过复古像素风格增强理解，音效和动画反馈能有效提升学习体验。

---
处理用时：75.78秒
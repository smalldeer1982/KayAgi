# 题目信息

# [NOIP 2017 提高组] 逛公园

## 题目背景

NOIP2017 D1T3

## 题目描述

策策同学特别喜欢逛公园。公园可以看成一张 $N$ 个点 $M$ 条边构成的有向图，且没有 自环和重边。其中 $1$ 号点是公园的入口，$N$ 号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。

策策每天都会去逛公园，他总是从 $1$ 号点进去，从 $N$ 号点出来。

策策喜欢新鲜的事物，它不希望有两天逛公园的路线完全一样，同时策策还是一个 特别热爱学习的好孩子，它不希望每天在逛公园这件事上花费太多的时间。如果 $1$ 号点 到 $N$ 号点的最短路长为 $d$，那么策策只会喜欢长度不超过 $d + K$ 的路线。

策策同学想知道总共有多少条满足条件的路线，你能帮帮它吗？

为避免输出过大，答案对 $P$ 取模。

如果有无穷多条合法的路线，请输出 $-1$。


## 说明/提示

【样例解释1】


对于第一组数据，最短路为 $3$。 $1\to 5, 1\to 2\to 4\to 5, 1\to 2\to 3\to 5$ 为 $3$ 条合法路径。


【测试数据与约定】

对于不同的测试点，我们约定各种参数的规模不会超过如下


测试点编号　　|$T$　　　|$N$　　　|$M$　　　|$K$　　　|是否有 $0$ 边
-|-|-|-|-|-
$1$|$5$|$5$|$10$|$0$|否
$2$|$5$|$10^3$|$2\times 10^3$|$0$|否
$3$|$5$|$10^3$|$2\times 10^3$|$50$|否
$4$|$5$|$10^3$|$2\times 10^3$|$50$|否
$5$|$5$|$10^3$|$2\times 10^3$|$50$|否
$6$|$5$|$10^3$|$2\times 10^3$|$50$|是
$7$|$5$|$10^5$|$2\times 10^5$|$0$|否
$8$|$3$|$10^5$|$2\times 10^5$|$50$|否
$9$|$3$|$10^5$|$2\times 10^5$|$50$|是
$10$|$3$|$10^5$|$2\times 10^5$|$50$|是


对于 $100\%$ 的数据，$1 \le P \le 10^9$，$1 \le a_i,b_i \le N$，$0 \le c_i \le 1000$。

数据保证：至少存在一条合法的路线。

---

- 2019.8.30 增加了一组 hack 数据 by @skicean
- 2022.7.21 增加了一组 hack 数据 by @djwj233

## 样例 #1

### 输入

```
2
5 7 2 10
1 2 1
2 4 0
4 5 2
2 3 2
3 4 1
3 5 2
1 5 3
2 2 0 10
1 2 0
2 1 0```

### 输出

```
3
-1

```

# AI分析结果



## 唯一算法分类
**动态规划 + 最短路**

---

## 综合分析与结论
### 核心思路与算法流程
1. **最短路预处理**：用 Dijkstra 计算每个节点到终点的最短距离 `dis[u]`。
2. **动态规划状态**：定义 `dp[u][k]` 表示从起点到节点 `u`，路径长度恰好为 `dis[u]+k` 的方案数。
3. **状态转移**：反向建图遍历边 `(v, u, w)`，转移方程为 `dp[u][k] += dp[v][dis[u]+k-w-dis[v]]`。
4. **零环检测**：在记忆化搜索中标记访问状态，若同一状态重复访问则判定存在零环。

### 可视化设计思路
1. **动画流程**：
   - **阶段1**：用绿色高亮展示 Dijkstra 计算最短路径的过程，节点按松弛顺序变色。
   - **阶段2**：用蓝色方块表示 `dp[u][k]` 状态，动态显示状态转移时的数值累加过程。
   - **零环检测**：当触发环检测时，红色闪烁当前节点，播放短促警报音效。
2. **复古像素风格**：
   - 节点用 8x8 像素块表示，最短路径用黄色线条，状态转移用蓝色箭头。
   - 背景音乐为 8-bit 风格循环音轨，状态更新时触发“嘀”声效。

---

## 题解清单（≥4星）
### 1. CJZJC（5星）⭐️⭐️⭐️⭐️⭐️
- **亮点**：正确处理 hack 数据，通过 Tarjan 找零环，结合正反向最短路验证合法性。
- **代码**：反向图记忆化搜索，分层处理合法路径。
- **心得**：强调零环需结合正反向最短路验证，避免误判。

### 2. JayJessy（4星）⭐️⭐️⭐️⭐️
- **亮点**：清晰记忆化搜索实现，通过 `vis` 数组检测递归环。
- **代码**：反向边遍历 + 状态剪枝（`nk < 0 || nk > K`）。
- **心得**：调试中发现需单独处理 `dp[1][0]` 的初始化。

### 3. 2014吕泽龙（4星）⭐️⭐️⭐️⭐️
- **亮点**：拓扑排序处理零边 DAG，按 `dis` 排序避免后效性。
- **代码**：分层图 DP 转移，时间复杂度严格 O(KM)。
- **心得**：指出零环只需检查 `dis[i]+dis0[i]` 的合法性。

---

## 最优思路提炼
1. **状态压缩**：将路径长度差值 `k` 作为第二维，状态数从 O(N·D) 降至 O(NK)。
2. **反向图优化**：建反向边实现记忆化搜索，避免正向图的无效转移。
3. **零环快速判定**：在搜索栈中标记 `vis[u][k]`，递归重复访问同一状态时立即返回 -1。
4. **剪枝优化**：转移前判断 `dis[u] + k - w >= dis[v]`，过滤非法状态。

---

## 类似题目推荐
1. **P1144**：最短路计数（基础版，无零边）
2. **P1608**：路径统计（严格最短路，含重边处理）
3. **UOJ Hack 数据版**：需处理复杂零环和路径组合

---

## 个人心得摘录
> **CJZJC**：  
> “被 hack 数据教育后发现，零环必须结合正反向最短路验证，不能仅凭存在环就判无限解。”

> **JayJessy**：  
> “调试两小时发现，`dp[1][0]` 的初始化必须放在搜索之后，否则会漏判起点处的零环。”

---

## 可视化代码片段（JS + Canvas）
```javascript
// 绘制节点与状态（8-bit 风格）
function drawNode(ctx, x, y, state) {
  const colors = { default: '#2c3e50', active: '#e74c3c', visited: '#3498db' };
  ctx.fillStyle = colors[state];
  ctx.fillRect(x*40, y*40, 32, 32); // 像素块间隔 8px
}

// 动态更新 DP 状态
function updateDPAnimation(u, k, value) {
  ctx.fillStyle = '#ffffff';
  ctx.fillText(value, u*40 + 5, k*20 + 15); // 在网格右侧显示数值
  playSound('blip'); // 触发 8-bit 音效
}

// 零环检测提示
function highlightCycle(u, k) {
  ctx.strokeStyle = '#e74c3c';
  ctx.strokeRect(u*40, k*20, 32, 32);
  playSound('alert'); // 触发警报音
}
```

---

## 同类型算法套路
- **最短路 + 计数 DP**：将路径约束转换为差值维度，结合拓扑序确保无后效性。
- **分层图思想**：按路径长度差值分层，每层独立处理状态转移。
- **环检测**：在搜索中维护访问标记，适用于任何需要检测递归环的场景。

---
处理用时：71.06秒
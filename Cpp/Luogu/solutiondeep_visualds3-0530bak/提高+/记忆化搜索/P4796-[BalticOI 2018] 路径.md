# 题目信息

# [BalticOI 2018] 路径

## 题目描述

**题目译自 [BalticOI 2018](https://boi2018.progolymp.se/tasks/) Day2「[Paths](https://boi18-day2-open.kattis.com/problems/boi18.paths)」**

给定一张 $N$ 个点 $M$ 条边的无向图，每个点有一个颜色，所有点的颜色共有 $K$ 种，编号为 $1\ldots K$。求图上有多少条长度至少为 $2$ 的简单路径，满足路径上的每一个点的颜色互不相同。

路径上的点的连接顺序不同看作不同的两条路径。

## 说明/提示

#### 样例 1 解释
![](https://gitee.com/mingqihuang/pics/raw/master/pathsfig.pdf.svg)

样例 1 中表达的图如上图所示。每个点的底色分别为白色（颜色 $1$）、灰色（颜色 $2$）或黑色（颜色 $3$）。共有 $10$ 条路径满足路径上的所有点的颜色都不同。它们是：``1-2``, ``2-1``, ``2-3``, ``3-2``, ``2-4``, ``4-2``, ``1-2-4``, ``4-2-1``, ``3-2-4`` 和 ``4-2-3``。

注意 ``1`` 不能看作是一条路径，因为一条路径至少连接两个点。``1-2-3`` 也不满足条件，因为有两个点都是 $1$ 号颜色。

|子任务|分值|数据范围|
|:--:|:--:|:--:|
|$1$|$23$|$1 \leqslant N,M \leqslant 100, 1 \leqslant K \leqslant 4$|
|$2$|$20$|$1 \leqslant N,M \leqslant 300\,000, 1 \leqslant K \leqslant 3$|
|$3$|$27$|$1 \leqslant N,M \leqslant 300\,000, 1 \leqslant K \leqslant 4$|
|$4$|$30$|$1 \leqslant N,M \leqslant 100\,000, 1 \leqslant K \leqslant 5$|

感谢 Hatsune_Miku 提供的翻译

## 样例 #1

### 输入

```
4 3 3
1 2 1 3
1 2
2 3
4 2```

### 输出

```
10

```

## 样例 #2

### 输入

```
9 11 4
1 2 3 4 1 2 1 2 2
1 2
1 3
2 3
2 4
3 6
6 2
6 5
4 3
4 5
7 8
9 8```

### 输出

```
70```

# AI分析结果



## 算法分类
动态规划（状压DP）

## 综合分析与结论
本题要求统计无向图中颜色互不重复且长度≥2的简单路径数目。核心思路是利用状态压缩动态规划（状压DP）高效处理颜色集合，通过二进制位表示颜色使用状态，确保路径中颜色不重复。

**核心算法流程**：
1. **状态定义**：设 `dp[u][S]` 表示以节点 `u` 结尾，经过颜色集合为 `S` 的路径数。初始化每个节点自身颜色对应的状态为1。
2. **状态转移**：遍历所有状态 `S`，对每个节点 `u`，若 `S` 中包含 `u` 的颜色，则遍历其邻接点 `v`。若 `v` 的颜色不在 `S` 中，则将 `S` 更新为 `S | (1 << color[v])`，并累加 `dp[u][S]` 到 `dp[v][新状态]`。
3. **答案统计**：处理每个状态时，若颜色数量≥2，累加对应 `dp` 值到答案。

**处理顺序**：状态需按颜色数量递增或数值递增处理，确保转移时前置状态已计算。例如，颜色数量为 `k` 的状态处理前，所有颜色数量为 `k-1` 的状态已处理完毕。

**可视化设计**：
- **颜色集合高亮**：用不同颜色标记当前状态包含的颜色，节点以颜色块显示。
- **状态转移动画**：当前处理节点闪烁，邻接点动态扩展，颜色集合更新时显示位运算过程。
- **复古风格**：像素化节点和颜色块，音效提示状态转移完成或答案统计。

## 题解清单（≥4星）
1. **GLZP（4.5星）**  
   - **亮点**：按颜色数量排序状态，确保正确转移；代码结构清晰，注释明确。  
   - **关键代码**：状态预处理排序，动态规划转移逻辑简洁。

2. **Error_Eric（4.5星）**  
   - **亮点**：代码极简，直接按数值处理状态，无需排序；函数 `fun` 高效处理转移。  
   - **关键代码**：状态循环与邻接遍历合并，减少冗余判断。

3. **activeO（4星）**  
   - **亮点**：结构清晰，与GLZP类似但更简洁；状态排序预处理明确。  
   - **关键代码**：状态预处理与动态规划转移逻辑一致。

## 最优思路提炼
- **状压DP**：将颜色集合压缩为二进制位，状态数 `2^K` 可控。
- **转移顺序**：按状态数值递增或颜色数量递增处理，确保前置状态已计算。
- **邻接遍历**：对每个节点的邻接点动态扩展状态，避免重复颜色。

## 同类型题与算法套路
- **类似问题**：统计带限制的路径数（如边权、节点属性限制）。
- **通用解法**：状压处理集合限制，动态规划或记忆化搜索。

## 推荐题目
1. **P3959 宝藏**（状压DP，处理树形结构）
2. **P2831 愤怒的小鸟**（状压预处理与DP结合）
3. **P1171 售货员的难题**（TSP问题，状压经典）

## 个人心得摘录
- **GLZP**：强调状态排序的重要性，避免依赖未计算状态。
- **Error_Eric**：通过数值递增隐式保证处理顺序，减少预处理步骤。

## 关键代码实现（Error_Eric）
```cpp
void fun(int val, int pos) {
    int fr = val ^ (1 << c[pos]);
    if (fr == 0) f[pos][val] = 1;
    else {
        for (auto &to : e[pos])
            f[pos][val] += f[to][fr];
        ans += f[pos][val];
    }
}

// 主循环
for (int i = 0; i < (1 << k); i++)
    for (int j = 1; j <= n; j++)
        if (i & (1 << c[j]))
            fun(i, j);
```

## 可视化与复古效果
- **Canvas绘制**：节点以网格排列，状态颜色用像素块填充，转移时动态连接。
- **音效设计**：状态更新时播放8位“滴”声，答案累加时播放上扬音调。
- **自动演示**：按状态顺序自动播放，支持暂停/步进观察转移细节。

**复古动画示例**：  
![复古风格动画示意图](https://via.placeholder.com/400x200/000000/FFFFFF/?text=Pixel+DP+Visualization)  
（图示：节点颜色块与状态位动态更新，邻接边高亮显示转移路径。）

---
处理用时：190.23秒
# 题目信息

# 弹珠游戏（2021 CoE-I C）

## 题目描述

$\operatorname{Alice}$ 对弹珠游戏已经有些厌烦了，她经常在电脑上玩这个游戏。她之所以感到厌烦是因为在这个游戏上她已经是专家级别，她总是能够和电脑打成平手。$\operatorname{Bob}$ 为 $\operatorname{Alice}$ 创造了一款新的电脑游戏。以下是这款两人电脑游戏的规则：

（1）游戏在如下图所示的菱形棋盘上进行；

![](https://cdn.luogu.com.cn/upload/image_hosting/qw7lsky0.png)

（2）两名玩家轮流放置弹珠，可以在横向、纵向、$45$ 度斜线、$135$ 度斜线方向未放置弹珠的位置**连续放置 $1$ 至 $3$ 颗弹珠**，玩家在可以放置弹珠的情况下，必须至少放置 $1$ 颗弹珠。以下是合法的单次放置操作的示例（黑色圆点表示放置了弹珠，白色圆点表示未放置弹珠，进行该次操作前棋盘为空）：

![](https://cdn.luogu.com.cn/upload/image_hosting/v38tajmr.png)

以下是非法的单次放置操作的示例（黑色圆点表示放置了弹珠，白色圆点表示未放置弹珠，进行该次操作前棋盘为空）：

![](https://cdn.luogu.com.cn/upload/image_hosting/mldg0cs0.png)

非法原因的解释：（$a$）三颗弹珠不在同一条斜线（或者垂直线）上；（$b$）两颗弹珠之间相隔一个空位；（$c$）三颗弹珠不在同一条斜线上；（$d$）三颗弹珠不在同一条斜线（或者垂直线）上；（$e$）一次性放置了 $4$ 颗弹珠；（$f$）三颗弹珠不在同一条水平线（或者垂直线、或者斜线）上。

（3）如果某位玩家无法再继续放置弹珠，则该名玩家输掉游戏，另外一名玩家获胜。

$\operatorname{Alice}$ 总是第一个进行游戏，而且经常是和 $\operatorname{Bob}$ 玩这个游戏，$\operatorname{Bob}$ 在进行若干游戏操作后可能会离开，将游戏交由电脑代理，电脑总是按照最优策略放置弹珠。
给定 $\operatorname{Bob}$ 离开后的游戏状态，你的任务是确定 $\operatorname{Alice}$ 是否可能在对阵电脑时获得胜利。

## 说明/提示

#### 样例说明

第一组数据，$\operatorname{Alice}$ 可以选择在棋盘左下角的斜线方向所剩下的 $3$ 个空余位置一次性连续放置 $3$ 颗弹珠，使得后续电脑无法再放置弹珠，因此 $\operatorname{Alice}$ 能够获胜。

第二组数据，$\operatorname{Alice}$ 可以选择沿着第四行剩下的 $3$ 个空余位置一次性连续放置 $3$ 颗弹珠，使得后续电脑无法再放置弹珠，因此 $\operatorname{Alice}$ 能够获胜。

第三组数据，棋盘剩下倒数第二列两个连续的空余位置，$\operatorname{Alice}$ 可以一次放置 $2$ 颗弹珠，使得后续电脑无法放置弹珠，因此 $\operatorname{Alice}$ 会获胜。

第四组数据，类似于第二组测试数据，棋盘剩下第三行两个连续的空余位置，因此 $\operatorname{Alice}$ 会获胜。

第五组数据，棋盘只剩下两个不连续的空余位置，由于 $\operatorname{Alice}$ 一次只能选择一个空余位置放置 $1$ 颗弹珠，因此不管 $\operatorname{Alice}$ 如何操作，电脑总能一次性将剩下的棋盘使用弹珠填满，使得 $\operatorname{Alice}$ 无法再继续放置弹珠，因此 $\operatorname{Alice}$ 会输掉比赛。

第六组数据，$\operatorname{Alice}$ 可以选择在棋盘右上角斜线方向的中间两个空余位置放置 $2$ 颗弹珠，使得棋盘状态转化为样例输入的第五组数据，因此 $\operatorname{Alice}$ 会赢得比赛。


------------

#### 数据范围

对于 $10\%$ 的数据，$0 \lt T \leq 10$。

对于 $60\%$ 的数据，$0 \lt T \leq 10^3$。

对于 $80\%$ 的数据，$0 \lt T \leq 10^5$。

对于 $100\%$ 的数据，$0 \lt T \leq 10^6$。


------------

#### 提示

本题输入量较大，请使用合适的读入方式。

## 样例 #1

### 输入

```
6

   *
  * *
 * * *
* * * *
 . * *
  . *
   .

   *
  * *
 * * *
. . . *
 * * *
  * *
   *

   *
  * *
 * * .
* * * *
 * * .
  * *
   *

   *
  * *
 . . *
* * * *
 * * *
  * *
   *

   .
  * *
 * * *
* * * .
 * * *
  * *
   *

   .
  * .
 * * .
* * * .
 * * *
  * *
   *```

### 输出

```
Possible.
Possible.
Possible.
Possible.
Impossible.
Possible.```

# AI分析结果



---

### 算法分类  
**博弈论 + 状态压缩 DP**

---

### 题解思路与核心分析  
**核心难点**：棋盘状态的合法移动判断与高效状态转移。  
**解决思路**：  
1. **状态压缩**：将 4x4 菱形棋盘转换为 16 位二进制数，每位表示是否放置弹珠。  
2. **方向处理**：通过旋转棋盘或坐标映射简化方向枚举（横向、纵向、45°斜线、135°斜线）。  
3. **必胜态判断**：基于博弈论，若存在一个移动使得对手处于必败态，则当前状态为必胜态。  
4. **预处理打表**：预先计算所有 65536 种状态的胜负结果，查询时直接查表。

**关键对比**：  
- **cmll02**：直接生成状态转移表并压缩存储，代码空间优化极致。  
- **metaphysis**：递归记忆化搜索，方向枚举逻辑清晰。  
- **cirnovsky**：预定义所有合法移动模式（82种），避免实时方向计算。

---

### 题解评分（≥4星）  
1. **metaphysis（5星）**  
   - 清晰的递归记忆化实现，方向枚举逻辑严密。  
   - 高效快读处理输入，适合大数据量。  
   - **亮点**：状态转移时逐方向扩展，避免遗漏合法移动。  

2. **cmll02（4星）**  
   - 预计算所有状态的胜负结果，查询速度极快。  
   - 通过二进制压缩优化表存储，降低代码体积。  
   - **不足**：生成表的代码未完整展示，可读性略低。  

3. **cirnovsky（4星）**  
   - 手动预定义合法移动模式，减少运行时计算。  
   - 状态转移直接枚举预存模式，逻辑简洁。  
   - **亮点**：棋盘映射表设计巧妙，避免旋转操作。

---

### 最优思路提炼  
**关键技巧**：  
1. **棋盘旋转映射**：将菱形棋盘转为 4x4 网格，简化坐标计算。  
   ```cpp  
   int matrix[16] = {0,4,1,8,5,2,12,9,6,3,13,10,7,14,11,15};  
   ```  
2. **必败态初始化**：满盘状态（全1）为必败态，逆推其他状态。  
3. **合法移动检测**：沿四个方向扩展，检查连续 1~3 个空位。  
   ```cpp  
   int dir[4][2] = {{1,0}, {0,1}, {1,1}, {1,-1}};  
   ```  
4. **记忆化搜索剪枝**：已计算状态直接返回结果，避免重复计算。

---

### 同类型题推荐  
1. **P3182 [HAOI2016]放棋子**（状态压缩+博弈论）  
2. **P2148 [SDOI2009]E&D**（SG函数应用）  
3. **P2964 [USACO09NOV]A Coin Game**（状态DP+博弈分析）

---

### 个人心得摘录  
- **棋盘方向处理**：将菱形棋盘旋转 45° 转为矩形网格，极大简化方向计算。  
- **打表优化**：在本地生成所有状态的胜负表，是处理大数据量查询的关键。  
- **代码空间压缩**：将 65536 位表压缩为字符串，显著减少代码体积。

---

### 可视化与算法演示  
**动画设计**：  
1. **棋盘渲染**：用 Canvas 绘制旋转后的 4x4 网格，已放置弹珠为红色，空位为绿色。  
2. **状态高亮**：当前操作的方向和弹珠位置用黄色边框标记。  
3. **自动演示**：按必胜策略自动选择移动，步进间隔可调。  
4. **音效提示**：  
   - 放置弹珠：8-bit "哔"声。  
   - 胜利/失败：不同音调提示。  

**代码片段（JS）**：  
```javascript  
// 棋盘渲染  
function drawBoard(state) {  
  ctx.clearRect(0, 0, 400, 400);  
  for (let i = 0; i < 16; i++) {  
    const x = (i % 4) * 100 + 50, y = Math.floor(i / 4) * 100 + 50;  
    ctx.fillStyle = (state & (1 << i)) ? "#FF0000" : "#00FF00";  
    ctx.fillRect(x, y, 80, 80);  
  }  
}  
```  

**复古风格**：  
- 使用 8-bit 像素字体和 16 色调色板。  
- 背景音乐：FC 风格的循环旋律。  

---

### 核心代码实现（metaphysis）  
```cpp  
int dfs(int x) {  
    if (~cache[x]) return cache[x];  
    for (int i = 0; i < 16; i++) {  
        if (x & (1 << i)) continue;  
        int r = i / 4, c = i % 4;  
        for (int j = 0; j < 4; j++) {  
            int bit = 0;  
            for (int k = 0; k < 3; k++) {  
                int rr = r + dir[j][0] * k;  
                int cc = c + dir[j][1] * k;  
                if (rr < 0 || rr > 3 || cc < 0 || cc > 3) break;  
                if (x & (1 << (rr * 4 + cc))) break;  
                bit |= (1 << (rr * 4 + cc));  
                if (!dfs(x ^ bit)) return cache[x] = 1;  
            }  
        }  
    }  
    return cache[x] = 0;  
}  
```

---
处理用时：74.93秒
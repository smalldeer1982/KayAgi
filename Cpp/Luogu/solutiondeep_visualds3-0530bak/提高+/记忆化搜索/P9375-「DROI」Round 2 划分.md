# 题目信息

# 「DROI」Round 2 划分

## 题目背景

与其编写苍白无力的背景，不如出更有质量的题。

## 题目描述

给定长度为 $n$ 的序列 $A$。

定义序列 $A$ 的某个子段 $[L,R]$ 的权值为: 

$$ \sum_{i=L}^{R}[\vert A_i - A_L \vert是完全平方数] \times \sum_{i=L}^{R}[\vert A_R - A_i \vert是完全平方数]$$

现在你需要将序列 $A$ **不重不漏**地划分成若干个子段，使得对于 $\forall i \in [1,n]$，长度为 $i$ 的子段有 $c_i$ 个。

在此基础上，求一种划分方案使所有子段权值和最大，输出这个最大值即可。特殊地，若不存在任意一种划分方案，则输出 `-1`。

**对题意不清楚的，可见下方说明提示。**


## 说明/提示

#### 样例解释
对于样例一，一种最优划分是分别在第二、三个数后面将序列断开。

对于样例二，一种最优划分是分别在第三、四、五、八个数后面将序列断开。


------------

#### 数据范围

**「本题采用捆绑测试」**

- $\operatorname{Subtask} 1(10\%)$：$n \leq 20$。

- $\operatorname{Subtask} 2(20\%)$：$n \leq 50,\sum_{i=1}^{n}c_i \leq 20$。

- $\operatorname{Subtask} 3(20\%)$：$n \leq 50,\forall i>5,c_i=0$。

- $\operatorname{Subtask} 4(50\%)$：无特殊限制。

对于 $100\%$ 的数据：$0 \leq c_i\leq n \leq 120,1 \leq a_i \leq 10^4$。

------------

#### 说明提示

- 我们规定，$0$ 是完全平方数。

- $[P]=1$ 当且仅当 $P$ 是真命题，否则 $[P]=0$。


## 样例 #1

### 输入

```
6
2 1 4899 4 1 4
1 1 1 0 0 0```

### 输出

```
9```

## 样例 #2

### 输入

```
10
1 1 1 2 4 3 3 3 8 8
2 1 2 0 0 0 0 0 0 0```

### 输出

```
24```

# AI分析结果



## 唯一算法分类
动态规划（多维背包）

## 综合分析与结论

**核心难点**  
1. **状态设计**：需记录各长度子段的使用次数，状态维度与有效子段种类数相关  
2. **转移方程**：需快速计算当前划分点对应的区间权值  
3. **空间优化**：多维状态需通过压缩或哈希映射降低存储开销  

**算法流程**  
1. **预处理**：O(n³) 计算所有区间权值 v[l][r]  
2. **状态压缩**：将有效子段长度映射为维度，状态表示各长度已用次数  
3. **动态规划**：  
   - 计算当前总长度 t = ∑(cnt[i] * len[i])  
   - 枚举可能添加的子段长度 len[i]，从前一状态转移  
   - 权值累加：f[new_state] = max(f[new_state], f[old_state] + v[t-len+1][t])  

**可视化设计**  
- **动画展示**：  
  1. 网格绘制各状态节点，颜色深浅表示当前权值大小  
  2. 高亮当前转移路径（如从状态A→B时，用闪烁箭头连接）  
  3. 右侧面板实时显示总长度和已用子段分布  
- **像素风格**：  
  - 8-bit 音效：转移时播放"滴"声，找到最优解时播放胜利旋律  
  - Canvas 网格动画：每个状态节点显示为 16x16 像素方块  
  - 自动演示模式：模拟 AI 按最优路径逐步展开状态  

## 题解清单（≥4星）

1. **Demeanor_Roy（4.5星）**  
   - **亮点**：记忆化搜索 + 哈希状态压缩，代码简洁高效  
   - **关键代码**：通过结构体封装状态，递归求解避免多维数组  

2. **gcx12012（4星）**  
   - **亮点**：进制压维技巧，一维数组管理多维状态  
   - **核心代码**：`mc[i] = mc[i+1] * (c[i+1]+1)` 实现进制转换  

## 最优思路提炼

- **状态哈希化**：将多维状态编码为整数，用 map/数组存储  
- **预处理剪枝**：先排除 ∑i*c_i≠n 的无解情况  
- **权值预计算**：牺牲 O(n³) 时间换取 O(1) 区间查询  

```cpp
// 预处理区间权值（Demeanor_Roy 题解片段）
for(int l=1;l<=n;l++) 
    for(int r=l;r<=n;r++) {
        int s1=0, s2=0;
        for(int k=l;k<=r;k++) {
            s1 += check(abs(a[l]-a[k]));
            s2 += check(abs(a[r]-a[k]));
        }
        v[l][r] = s1 * s2;
    }
```

## 相似题目推荐

1. **P1541 乌龟棋**  
   - 多维状态记录各面值卡牌使用次数  
2. **P5020 货币系统**  
   - 动态规划处理子集划分与权值优化  
3. **P6779 [yLOI2020] 凉凉**  
   - 高维状态压缩与预处理技巧结合  

## 可视化代码片段（JS/Canvas）

```javascript
// 状态节点绘制（像素风格）
function drawState(ctx, state, x, y) {
    ctx.fillStyle = `hsl(${state.value % 360}, 70%, 60%)`;
    ctx.fillRect(x*20, y*20, 18, 18); // 16x16 + 2px间隔
    ctx.fillStyle = "#fff";
    ctx.font = "8px Arial";
    ctx.fillText(state.value, x*20+2, y*20+12);
}

// 音效触发
function playSound(type) {
    const sfx = {
        move: [140, 0.01, , , 0.3],  // 转移音效
        win: [600, 0.5, , , 0.7]     // 成功音效
    };
    synth.triggerAttackRelease(sfx[type][0], sfx[type][1]);
}
```

## 个人心得摘录

> "实际状态数远低于理论上限，哈希映射在本题表现优于数组预分配" —— Demeanor_Roy  
> "递归生成状态比多层循环更易维护，但需注意剪枝" —— baoziwu2  
> "压维时进制基数的选择直接影响状态空间大小" —— gcx12012  

## 复古游戏化设计

- **颜色方案**：16色 EGA 调色板，状态值映射到不同色阶  
- **自动演示**：DFS 搜索最优路径，用绿色方块标记当前探索方向  
- **积分系统**：  
  - 基础分：每转移一步 +10  
  - 连击分：连续正确转移时倍率递增  
- **关卡设计**：  
  - 教学关：仅 2 种长度子段  
  - 进阶关：动态增删有效子段类型

---
处理用时：100.13秒
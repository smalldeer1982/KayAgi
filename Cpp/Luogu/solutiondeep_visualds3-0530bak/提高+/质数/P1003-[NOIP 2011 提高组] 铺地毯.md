# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果



---

**唯一算法分类**  
枚举

---

**综合分析与结论**  
本题需找出覆盖某点的最上层地毯。所有题解均采用枚举法，通过存储各地毯参数并逐一判断覆盖关系。核心难点在于避免二维数组的空间浪费，正确做法是记录每个地毯的坐标范围，在线性时间内遍历检查。

**关键思路**：  
1. **存储参数**：保存每个地毯的左上角坐标(a,b)及延伸长度(g,k)，确定覆盖范围。  
2. **覆盖判断**：检查点(x,y)是否满足 a ≤ x ≤ a+g 且 b ≤ y ≤ b+k。  
3. **遍历顺序**：逆序遍历可提前终止，正向遍历需记录最大值，两种方法时间复杂度均为O(n)。  

**可视化设计**：  
- **动画方案**：以网格坐标系展示所有地毯，高亮当前检查的地毯范围，若覆盖目标点则标记颜色并终止。  
- **复古像素风格**：用8位色块表示地毯，红色闪烁标记目标点，覆盖时播放“成功”音效。  
- **交互控制**：步进执行，显示当前地毯索引，支持正/逆序切换对比效率差异。

---

**题解清单 (≥4星)**  
1. **智子（5星）**  
   - 亮点：清晰分析空间问题，提供错误与正确解法对比，代码规范。  
2. **谁懂谁伤心（4星）**  
   - 亮点：逆序遍历优化，提前终止循环，代码简洁高效。  
3. **Vct14（4星）**  
   - 亮点：预计算右下角坐标，判断逻辑直观，结构体存储增强可读性。  

---

**核心代码实现**  
```cpp
// 逆序遍历实现（作者：kuaiCreator）
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4+5;
int a[N], b[N], g[N], k[N], n, x, y, ans = -1;
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) 
        cin >> a[i] >> b[i] >> g[i] >> k[i];
    cin >> x >> y;
    for (int i = n; i >= 1; i--) {
        if (x >= a[i] && x <= a[i]+g[i] && y >= b[i] && y <= b[i]+k[i]) {
            ans = i; // 找到则立即退出
            break;
        }
    }
    cout << ans;
    return 0;
}
```

**代码要点**：  
- 逆序循环从n到1，使用`break`提前终止。  
- 条件判断直接比较坐标范围，无冗余计算。  

---

**同类型题推荐**  
1. P1047 校门外的树（区间覆盖问题）  
2. P1059 明明的随机数（数据去重与排序）  
3. P1090 合并果子（贪心与优先队列）  

---

**个人心得摘录**  
- **智子**：开二维数组的尝试导致MLE，强调空间复杂度的重要性。  
- **谁懂谁伤心**：逆序思维可减少不必要的遍历，尤其在存在多层覆盖时效果显著。  
- **kuaiCreator**：预处理右下角坐标简化判断条件，提高代码可维护性。  

---

**可视化实现片段（伪代码）**  
```javascript
// 伪代码：Canvas绘制与音效触发
function drawStep(index) {
    clearCanvas();
    drawAllCarpets(); // 灰色矩形块表示
    highlightCurrentCarpet(index); // 黄色边框
    drawTargetPoint(x, y); // 红色圆点
    if (isCovered(index)) {
        playSound('success.wav');
        stopAnimation();
    }
}

// 自动逆序演示
let current = n;
const timer = setInterval(() => {
    if (current < 1) clearInterval(timer);
    drawStep(current);
    current--;
}, 1000);
```

**复古风格设计**：  
- **调色板**：8位色（黑、白、灰、黄、红），模拟FC游戏风格。  
- **音效**：覆盖时播放8-bit“胜利”音效，背景循环芯片音乐。  
- **积分系统**：每正确识别一个地毯+10分，错误无扣分，总分展示效率排名。  

--- 

**总结**  
本题通过线性枚举与空间优化，展示了如何将看似高复杂度的问题转化为高效解决方案。逆序遍历与条件判断的巧妙结合，是同类覆盖问题的通用思路。

---
处理用时：71.72秒
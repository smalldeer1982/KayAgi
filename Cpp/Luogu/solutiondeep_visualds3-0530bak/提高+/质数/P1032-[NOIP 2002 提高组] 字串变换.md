# 题目信息

# [NOIP 2002 提高组] 字串变换

## 题目背景

本题不保证存在靠谱的多项式复杂度的做法。测试数据非常的水，各种做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)

## 题目描述

已知有两个字串 $A,B$ 及一组字串变换的规则（至多 $6$ 个规则），形如：

- $A_1\to B_1$。
- $A_2\to B_2$。

规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $ B_1$，$A_2$ 可以变换为 $B_2\cdots$。

例如：$A=\texttt{abcd}$，$B＝\texttt{xyz}$，

变换规则为：

- $\texttt{abc}\rightarrow\texttt{xu}$，$\texttt{ud}\rightarrow\texttt{y}$，$\texttt{y}\rightarrow\texttt{yz}$。

则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：

- $\texttt{abcd}\rightarrow\texttt{xud}\rightarrow\texttt{xy}\rightarrow\texttt{xyz}$。

共进行了 $3$ 次变换，使得 $A$ 变换为 $B$。


## 说明/提示

对于 $100\%$ 数据，保证所有字符串长度的上限为 $20$。

**【题目来源】**

NOIP 2002 提高组第二题

## 样例 #1

### 输入

```
abcd xyz
abc xu
ud y
y yz
```

### 输出

```
3
```

# AI分析结果



### 算法分类
广度优先搜索（BFS）与双向广度优先搜索（双向 BFS）

---

### 题解思路与核心难点分析

#### 核心算法流程
1. **BFS 基础框架**：  
   - 初始字符串入队，逐层扩展所有可能的变换规则应用位置  
   - 每次扩展时生成新字符串并判断是否达到目标状态  
   - 通过判重（`map`/`unordered_map`）避免重复处理同一状态  

2. **双向 BFS 优化**：  
   - 同时从起点和终点进行 BFS，每次选择较小的队列扩展  
   - 规则在反向搜索时需要反转（如 `A→B` 变为 `B→A`）  
   - 当两队列相遇时，总步数为两方向步数之和  

#### 解决难点对比
| 题解实现              | 判重方法               | 规则处理方式               | 优化点                     |
|-----------------------|------------------------|----------------------------|----------------------------|
| MakotoTSK（基础 BFS） | 无判重                 | 直接替换                   | 无                         |
| songyouyi（BFS+判重） | `map<string,bool>`     | 手动拼接字符串             | 判重避免重复状态           |
| lym2022（BFS+判重）   | `map<string,bool>`     | `replace` 函数+位置标记    | 替换后修改字符避免重复替换 |
| 租酥雨（双向 BFS）    | 遍历对方队列判重       | 手动拼接字符串（反向规则） | 双向扩展减少搜索空间       |
| Qianmo_su（双向 BFS） | `unordered_map` 记录步数 | `substr`+`replace`         | 优先扩展较小队列           |

---

### 题解评分（≥4星）

1. **songyouyi（4.5星）**  
   - **亮点**：完整判重逻辑、代码可读性强、正确处理多位置替换  
   - **代码片段**：  
     ```cpp
     if (mp[tt]) continue;  // 判重逻辑
     mp[tt] = 1;
     q.push({tt, ss.d + 1});
     ```

2. **租酥雨（4星）**  
   - **亮点**：双向 BFS 实现、手动拼接字符串优化性能  
   - **代码片段**：  
     ```cpp
     new_born(x, i, j);  // 双向扩展
     if (key) return;    // 相遇检测
     ```

3. **TuringTime（4星）**  
   - **亮点**：修正内存问题、`map` 判重、代码简洁  
   - **代码片段**：  
     ```cpp
     if (!mp[ps]) {       // 判重与入队
         q.push(make_pair(ps, s.second + 1));
         mp[ps] = 1;
     }
     ```

---

### 最优思路与技巧提炼

1. **关键数据结构**  
   - **判重容器**：使用 `unordered_map` 或 `map` 记录已访问状态，避免重复扩展  
   - **队列选择**：双向 BFS 中优先扩展较小队列以减少总搜索空间  

2. **规则应用优化**  
   - **多位置替换**：通过 `find` 循环定位所有匹配子串（如 `while (pos != -1)`）  
   - **字符串操作**：优先使用 `replace` 或手动拼接（`substr`+`erase`+`insert`）  

3. **剪枝策略**  
   - **步数限制**：在 BFS 中提前终止超过 10 步的状态  
   - **长度限制**：预测字符串长度增长上限（如 `maxl*10`）进行剪枝  

---

### 类似题目推荐

1. **P1120 小书童**（洛谷）  
   - 关键词：BFS、状态转换、最少步骤  
2. **P1035 数变换**（洛谷）  
   - 关键词：规则应用、双向 BFS  
3. **LeetCode 127. 单词接龙**  
   - 关键词：字符串变换、双向 BFS  

---

### 可视化与算法演示设计

#### 动画方案
- **BFS 层序扩展**：  
  - 用不同颜色区分队列层级，展示新生成的字符串  
  - 高亮当前处理的字符串和应用的规则  
- **双向 BFS 相遇检测**：  
  - 左右两侧分别显示正向/反向队列扩展过程  
  - 当两队列有交集时，用闪烁效果标记相遇点  

#### 复古像素风格实现
- **Canvas 绘制**：  
  - 字符串状态以 8x8 像素块显示，每个字符对应一个色块  
  - 队列用滚动列表形式展示，仿照 FC 游戏菜单样式  
- **音效设计**：  
  - 扩展新状态时播放「叮」声，相遇时播放「胜利」音效  
  - 超过步数限制时播放「失败」低音  

#### 交互功能
- **步进控制**：支持暂停/继续/单步执行  
- **速度调节**：滑动条控制动画速度（1x~10x）  
- **模式切换**：BFS/双向 BFS 对比演示  

---

### 个人心得摘录

1. **lyc1109 的调试经验**：  
   > 「DFS 必须配合严格剪枝和 `map` 判重才能通过，否则会 TLE。规则排序（短规则优先）显著减少无效搜索。」  

2. **租酥雨的双向 BFS 实现**：  
   > 「手动拼接字符串虽然繁琐，但避免了 STL 函数的性能损耗。反向规则处理需要特别小心边界条件。」  

---

### 核心代码实现（判重+BFS）

```cpp
#include <iostream>
#include <queue>
#include <unordered_map>
using namespace std;

string A, B, ruleA[6], ruleB[6];
int n;

int bfs() {
    queue<string> q;
    unordered_map<string, int> vis;
    q.push(A);
    vis[A] = 0;
    
    while (!q.empty()) {
        string u = q.front(); q.pop();
        if (u == B) return vis[u];
        if (vis[u] > 10) break;
        
        for (int i = 0; i < n; i++) {
            size_t pos = u.find(ruleA[i]);
            while (pos != string::npos) {
                string v = u;
                v.replace(pos, ruleA[i].size(), ruleB[i]);
                if (!vis.count(v)) {
                    vis[v] = vis[u] + 1;
                    q.push(v);
                }
                pos = u.find(ruleA[i], pos + 1);
            }
        }
    }
    return -1;
}

int main() {
    cin >> A >> B;
    while (cin >> ruleA[n] >> ruleB[n]) n++;
    int ans = bfs();
    if (ans != -1 && ans <= 10) cout << ans;
    else cout << "NO ANSWER!";
}
```

---
处理用时：104.13秒
# 题目信息

# [JLOI2014] 聪明的燕姿

## 题目背景

> 阴天傍晚车窗外
>
> 未来有一个人在等待
>
> 向左向右向前看
>
> 爱要拐几个弯才来
>
> 我遇见谁会有怎样的对白
>
> 我等的人他在多远的未来
>
> 我听见风来自地铁和人海
>
> 我排着队拿着爱的号码牌

## 题目描述

城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。

可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字 $S$，那么自己等的人手上的号码牌数字的所有正约数之和必定等于 $S$。

所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。

## 说明/提示

对于 $100\%$ 的数据，$k\leqslant100$，$S\leqslant2\times10^9$。

## 样例 #1

### 输入

```
42```

### 输出

```
3
20 26 41```

# AI分析结果



---

### **唯一算法分类**  
**数论+深度优先搜索（DFS）**

---

### **综合分析与结论**  

#### **核心思路与难点**
- **核心定理**：基于约数和定理，将问题转化为质数的幂次组合问题。
- **DFS 剪枝**：  
  - 预处理 $\sqrt{S}$ 范围内的质数，避免重复计算。  
  - 当剩余值 $now=1$ 时，当前乘积即为解。  
  - 若 $now-1$ 是质数，则直接生成解（因 $1+(now-1)=now$）。  
- **难点对比**：  
  - **质数判断优化**：部分题解（如 timmark）利用预筛质数表快速判断大质数。  
  - **重复解处理**：需排序后去重（如 mohei0 的 `unique` 操作）。  

#### **可视化设计思路**  
- **动画流程**：  
  1. **质数分解展示**：以网格显示质数表，高亮当前选中的质数（如 $p_i$）。  
  2. **DFS 路径动态绘制**：用树状图展示搜索路径，分支对应不同质数的选择。  
  3. **剩余值标记**：实时显示当前剩余值 $now$ 和乘积 $s$，颜色区分状态（如红色表示剩余值非质数）。  
- **复古风格**：  
  - **像素化质数网格**：质数以 8-bit 方块显示，选中时闪烁。  
  - **音效触发**：找到解时播放经典 FC 过关音效，质数判断失败则播放低音。  

---

### **题解评分 (≥4星)**  

1. **ycyaw 题解（4.5星）**  
   - **亮点**：代码简洁，核心逻辑清晰，预处理质数 + 剪枝条件明确。  
   - **优化点**：缺少去重逻辑，需手动排序后处理。  

2. **LaoPi 题解（4星）**  
   - **亮点**：详细注释，特判 $now-1$ 为质数的情况，输出格式处理严谨。  
   - **优化点**：质数判断函数未完全利用预筛表，导致重复计算。  

3. **timmark 题解（4.5星）**  
   - **亮点**：质数判断高效（结合预筛表与大数特判），代码简洁。  
   - **优化点**：未显式处理重复解，依赖输入顺序。  

---

### **最优思路与技巧提炼**  

#### **关键步骤**
1. **质数预处理**：线性筛法生成 $\sqrt{S}$ 内质数表。  
2. **DFS 核心逻辑**：  
   ```python
   def dfs(now, x, s):
       if now == 1:  # 终止条件
           ans.append(s)
           return
       if is_prime(now - 1) and (now - 1) > primes[x]:  # 剪枝条件
           ans.append(s * (now - 1))
       for i in range(x, len(primes)):
           p = primes[i]
           if p * p > now: break
           sum_p = 1 + p
           t = p
           while sum_p <= now:
               if now % sum_p == 0:
                   dfs(now // sum_p, i + 1, s * t)
               t *= p
               sum_p += t
   ```
3. **去重与排序**：最终结果需排序后输出，确保唯一性。  

---

### **同类型题与算法套路**  
- **通用解法**：质因数分解 + 搜索剪枝，适用于约数和、反质数等问题。  
- **类似题目**：  
  - **洛谷 P1593**（因子和）  
  - **洛谷 P2424**（约数和）  
  - **洛谷 P1072**（Hankson的趣味题）  

---

### **推荐相似题目**  
1. **P1593 因子和**  
   - 求 $A^B$ 的因子和，需结合快速幂与约数和定理。  
2. **P2424 约数和**  
   - 计算区间内每个数的约数和，可优化为筛法预处理。  
3. **P1072 Hankson的趣味题**  
   - 通过质因数分解求解满足条件的数，DFS 剪枝思路相似。  

---

### **个人心得摘录**  
- **mohei0**：调试时发现重复解问题，最终通过 `sort + unique` 解决。  
- **wsm52**：初期暴力法 TLE，意识到必须利用约数和定理反向搜索。  

---

### **可视化与算法演示**  

#### **核心算法动画设计**  
- **Canvas 动态绘制**：  
  - **质数网格**：以 32x32 像素块显示质数，选中时高亮黄色。  
  - **DFS 树**：用绿色线条连接搜索路径，当前质数分支标记为红色。  
- **音效与交互**：  
  - **正确解音效**：8-bit 风格“胜利”音效（频率 1000Hz, 500ms）。  
  - **步进控制**：用户可点击“Next”单步执行，观察质数选择与剩余值变化。  

#### **代码片段（JS 实现）**  
```javascript
// 初始化质数网格（伪代码）
function initPrimesCanvas() {
  ctx.fillStyle = "#8B0000"; // 复古红
  primes.forEach((p, i) => {
    let x = (i % 10) * 35, y = Math.floor(i / 10) * 35;
    ctx.fillRect(x, y, 30, 30); // 绘制质数方块
  });
}

// DFS 单步执行（伪代码）
function dfsStep(now, x, s) {
  highlightPrime(x); // 高亮当前质数
  if (now === 1) {
    playSound('win'); // 触发音效
    addResult(s);
  }
  // ...其他逻辑
}
```

---

**总结**：本题通过质因数分解与剪枝 DFS 高效求解，核心在于约数和定理的应用与质数预处理。可视化设计可结合复古元素增强理解，同类题目多涉及数论与搜索的交叉应用。

---
处理用时：80.08秒
# 题目信息

# [CQOI2018] 破解D-H协议

## 题目背景

Diffie-Hellman 密钥交换协议是一种简单有效的密钥交换方法。它可以让通讯双方在没有事先约定**密钥**的情况下，通过**不安全**（可能被窃听）**的信道**确定一个**安全的密钥** $K$，用于加密之后的通讯内容。

## 题目描述

假定通讯双方名为 Alice 和 Bob，协议的工作过程描述如下（其中 $\bmod$ 表示取模运算）：

1. 协议规定一个**固定的**质数 $P$，以及模 $P$ 的一个原根 $g$。**$\boldsymbol P$ 和 $\boldsymbol g$ 的数值都是公开的，无需保密。**

2. Alice 生成一个随机数 $a$，并计算 $A=g^a\bmod P$，将 $A$ 通过不安全信道发送给 Bob。

3. Bob 生成一个随机数 $b$，并计算 $B=g^b\bmod P$，将 $B$ 通过不安全信道发送给 Alice。

4. Bob 根据收到的 $A$ 计算出**密钥** $K=A^b \bmod P$，而 Alice 根据收到的 $B$ 计算出 $K=B^a\bmod P$。

5. 双方得到了相同的 $K$，即 $g^{ab} \bmod P$。$K$ 即之后通讯的加密密钥。

可见，这个过程中可能被窃听的只有 $A,B$，而 $a,b,K$ 是保密的。并且根据 $A,B,P,g$ 这 $4$ 个数，不能轻易计算出 $K$，因此 $K$ 可以作为一个安全的密钥。

当然安全是相对的，该协议的安全性取决于数值的大小，通常 $a,b,P$ 都选取数百位以上的大整数以避免被破解。然而如果 Alice 和 Bob 编程时偷懒，为了避免实现大数运算，选择的数值都小于 $2^{31}$，那么破解他们的密钥就比较容易了。

$T$ 次给定窃听得到的 $A,B$，你需要尝试破解出**密钥** $K$。


## 说明/提示

对于 $30\%$ 的数据，$2\le A,B,P\le 1000$；

对于 $100\%$ 的数据，$2\le A,B<P<2^{31}，2\le g<20，1\le n\le 20$。

$\text{Statement fixed by @Starrykiller.}$

## 样例 #1

### 输入

```
3 31
3
27 16
21 3
9 26```

### 输出

```
4
21
25```

# AI分析结果



## 唯一算法分类
**离散对数问题 (BSGS算法)**

## 题解思路与核心难点分析
**题目核心**：基于 Diffie-Hellman 协议，通过 BSGS 算法求解离散对数问题 $g^a \equiv A \ (\text{mod}\ P)$ 得到指数 $a$，再用快速幂计算 $K = B^a \ \text{mod}\ P$

**核心难点**：
1. **BSGS 分块策略**：需将指数分块为 $a = im - j$，预处理 $g^{im}$ 存入哈希表，再枚举 $j$ 查找匹配项
2. **哈希效率优化**：手写哈希或使用 `unordered_map` 加速查询（标准 `map` 的 $O(\log n)$ 查询会超时）
3. **边界条件处理**：分块大小 $m = \lceil \sqrt{P} \rceil$，循环范围需覆盖所有可能情况

---

## 题解评分（≥4星）
| 作者          | 评分 | 关键亮点                                                                 |
|---------------|------|--------------------------------------------------------------------------|
| LeavingZzz    | ⭐⭐⭐⭐⭐ | 手写哈希表优化查询速度，详细推导 BSGS 分块逻辑，代码可读性强               |
| Eason_AC      | ⭐⭐⭐⭐  | 使用 `unordered_map` 替代 `map`，代码简洁且高效，注释清晰                 |
| MY            | ⭐⭐⭐⭐  | 强调哈希表清空的重要性，提供学习笔记链接，代码注释完善                     |

---

## 最优思路与技巧提炼
### 核心算法流程
1. **预处理阶段**：
   ```cpp
   m = ceil(sqrt(P));
   for i in 1..m:
       val = g^(i*m) mod P
       存入哈希表：key=val, value=i*m
   ```
2. **查询阶段**：
   ```cpp
   for j in 0..m-1:
       target = A * g^j mod P
       在哈希表中查找 target，若存在则返回 a = i*m - j
   ```

### 关键优化技巧
- **哈希表选择**：手写哈希表或 `unordered_map`（查询复杂度 $O(1)$）
- **快速幂优化**：使用位运算加速幂计算
- **分块策略**：确保 $m = \lceil \sqrt{P} \rceil$ 覆盖所有可能解

---

## 可视化算法演示设计
### 动画方案（Canvas 实现）
1. **分块预处理**：
   - 绘制 $m \times m$ 网格表示分块
   - 动态填充预处理值 $g^{im}$，用绿色高亮当前计算的块
   - 播放音效：每计算一格播放短促「滴」声

2. **查询匹配过程**：
   - 左侧显示当前 $j$ 值，右侧显示哈希表
   - 红色闪烁标记当前计算的 $A \cdot g^j$，蓝色标记哈希匹配项
   - 匹配成功时播放「叮」声，背景变黄

3. **复古像素风格**：
   - 使用 16 色调色板（NES 风格）
   - 网格线用深灰色，数据块用蓝绿渐变
   - 音效采用 8-bit 芯片音乐

### 交互功能
- **速度调节**：滑块控制动画速度（0.5x~5x）
- **单步执行**：按钮逐帧观察分块和查询
- **自动演示**：AI 自动完成分块和查询，展示最优路径

---

## 关键代码实现（BSGS + 快速幂）
```cpp
#include <unordered_map>
using namespace std;

typedef long long ll;

ll qpow(ll a, ll b, ll p) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

ll BSGS(ll g, ll A, ll P) {
    unordered_map<ll, ll> hash;
    ll m = ceil(sqrt(P));
    ll gm = qpow(g, m, P), val = gm;
    
    // 预处理 g^(i*m)
    for (ll i = 1; i <= m; ++i) {
        hash[val] = i * m;
        val = val * gm % P;
    }
    
    // 枚举 j 查找匹配
    ll target = A;
    for (ll j = 0; j < m; ++j) {
        if (hash.count(target))
            return hash[target] - j;
        target = target * g % P;
    }
    return -1;
}
```

---

## 相似题目推荐
1. [P3846 - BSGS 模板题](https://www.luogu.com.cn/problem/P3846)
2. [P2485 - 多功能计算器（扩展离散对数）](https://www.luogu.com.cn/problem/P2485)
3. [P3306 - 随机数生成器（递推式与离散对数结合）](https://www.luogu.com.cn/problem/P3306)

---
处理用时：71.98秒
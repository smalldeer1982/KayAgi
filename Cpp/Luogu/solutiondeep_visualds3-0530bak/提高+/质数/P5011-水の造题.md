# 题目信息

# 水の造题

## 题目背景

第一分钟,$CYJian$说:"要有样子."于是便有了$k$种动作..

第二分钟,$CYJian$说:"要有活力."于是便有了$k$种动作组成的总动作数为$N$的搏击操.

第三分钟,$CYJian$说:"要有数学."于是便有了一套搏击操的威力.

第四分钟,$CYJian$说:"数字要小."于是便有了一个伟大的模数$19491001$.

第五分钟,$CYJian$说:"要有规律."于是便有了一套搏击操威力的计算方法.

第六分钟,$CYJian$说:"要有限制."于是便有了时空限制以及数据范围.

第七分钟,$CYJian$说:"要有答案."于是便有了这道题让你做掉.

...

第*分钟,巨佬$Imagine$说:"数据太水."于是蒟蒻出题人疯了..(详见数据范围)

## 题目描述

现在有一套由$k$种动作组成的动作总数为$N$的搏击操.

已知第$1$,$2$...$k$个动作的威力为$a[1...k]$

且如果第一个动作后紧接着第二个动作,则威力会额外加上$a[1]+a[2]$

如果第二个动作后紧接着第三个动作,则威力会额外加上$a[2]+a[3]$

...

如果第$k$个动作后紧接着第一个动作,则威力会额外加上$a[k]+a[1]$

请求出最后动作的期望威力..

当然,还是要用伟大的模数$19491001$来膜一膜的...

## 说明/提示

样例解释：

```
x-y 表示第一个动作为x，第二个动作为y

1-1 : 1+1=2
1-2 : 1+2+(1+2)=6
1-3 : 1+3=4
1-4 : 1+4=5
1-5 : 1+5=6
1-6 : 1+6=7
2-1 : 2+1=3
2-2 : 2+2=4
2-3 : 2+3+(2+3)=10
2-4 : 2+4=6
2-5 : 2+5=7
2-6 : 2+6=8
3-1 : 3+1=4
3-2 : 3+2=5
3-3 : 3+3=6
3-4 : 3+4+(3+4)=14
3-5 : 3+5=8
3-6 : 3+6=9
4-1 : 4+1=5
4-2 : 4+2=6
4-3 : 4+3=7
4-4 : 4+4=8
4-5 : 4+5+(4+5)=18
4-6 : 4+6=10
5-1 : 5+1=6
5-2 : 5+2=7
5-3 : 5+3=8
5-4 : 5+4=9
5-5 : 5+5=10
5-6 : 5+6+(5+6)=22
6-1 : 6+1+(6+1)=14
6-2 : 6+2=8
6-3 : 6+3=9
6-4 : 6+4=10
6-5 : 6+5=11
6-6 : 6+6=12

2+6+4+5+6+7+3+4+10+6+7+8+4+5+6+14+8+9+5+6+7+8+18+10+6+7+8+9+10+22+14+8+9+10+11+12=294

294/36=49/6

1/6 = 16242501 (mod 19491001)

ans = 49 * 16242501 mod 19491001 = 16242509
```

$Subtask 1$($20 pts$):$1 \leq N \leq 10 \qquad 1 \leq k \leq 7$ 

$Subtask 2$($20 pts$):$1 \leq N \leq 10^6 \qquad 1 \leq k \leq 7$ 

$Subtask 3$($20 pts$):$1 \leq N \leq 10^{40000} \qquad 1 \leq k \leq 7$ 

$Subtask 4$($20 pts$):$1 \leq N \leq 10^{10^6} \qquad 1 \leq k \leq 7$ 

$Subtask 5$($20 pts$):$1 \leq N \leq 10^{10^6} \qquad 1 \leq k \leq 10^6$ 

保证所有的数据: $1 \leq a[i] \leq 10^7$

## 注意:本题捆绑测试

小提示：

可以用下面的inv(x)求出x的逆元：

```
long long mod = 19491001;

long long quick_pow(long long x, int k) {
    long long res = 1;
    while(k) {
        if(k & 1) res = res * x % mod;
        x = x * x % mod;
        k >>= 1;
    }
    return res;
}

long long inv(long long x) {
    return quick_pow(x, mod - 2);
}
```

## 样例 #1

### 输入

```
2
6
1 2 3 4 5 6
```

### 输出

```
16242509
```

# AI分析结果



## 唯一算法分类
**数学/期望计算**

---

## 综合分析与结论

### 核心思路
1. **期望拆分**：将总期望拆分为单独动作贡献与连续动作组合的额外贡献。
2. **快速推导公式**：通过线性期望性质，直接得出最终公式 `ans = sum*(n*k + 2*(n-1))/k²`。
3. **大数处理**：直接对 `n` 取模，避免高精度运算。

### 解决难点
- **公式推导**：如何将组合技的贡献与单独动作的贡献统一到数学公式中。
- **模运算**：处理 `n` 的极高精度输入，需在读入时逐位取模。
- **逆元计算**：利用费马小定理快速求模意义下的除法。

### 可视化设计
- **动态公式推导**：展示公式如何从单独动作和连续动作的贡献叠加而来。
- **像素动画**：用 8-bit 风格显示输入 `n` 的逐位取模过程、sum 的计算步骤。
- **音效触发**：计算逆元时播放短促音效，公式正确时播放上扬音效。

---

## 题解清单（评分≥4星）

### 1. 作者：Imakf（5星）
- **亮点**：直接拆分期望的线性性，代码简洁高效。
- **关键代码**：
  ```cpp
  LL Ans = sum * t % MOD * 2 % MOD;
  Ans = (Ans + ivk * n % MOD * sum) % MOD;
  ```

### 2. 作者：VERACITY（4.5星）
- **亮点**：通过组合技概率推导，逻辑清晰。
- **关键代码**：
  ```cpp
  ans = (sum1*inv_k%Mod + sum2*inv_k2%Mod)%Mod;
  ```

### 3. 作者：TemplateClass（4星）
- **亮点**：公式推导一步到位，代码极简。
- **关键代码**：
  ```cpp
  printf("%lld", ((k + 2) * n - 2) % MOD * invk % MOD * invk % MOD * s % MOD);
  ```

---

## 最优思路与技巧
1. **期望线性性**：将总期望拆分为单独和连续的贡献，避免复杂递推。
2. **模运算优化**：直接逐位取模处理大数 `n`。
3. **逆元预处理**：用费马小定理快速计算 `1/k` 和 `1/k²`。

---

## 类似题目推荐
1. **P5082 测平均**：涉及期望与逆元计算。
2. **P2155 沙拉公主的困惑**：大数模运算与组合数优化。
3. **P3811 乘法逆元**：模运算与逆元应用。

---

## 个人心得摘录
- **Imakf**：*“无限 orz 出题人 CYJian！”*（表达对题目的敬意）
- **kkxacj**：*“题就跟标题一样水”*（强调数学推导简化问题）

---

## 可视化与算法演示（核心逻辑）
### 动画设计
1. **输入处理**：
   - 像素风格逐位输入 `n`，显示取模过程。
   - 颜色标记当前处理的数字位（黄色高亮）。
2. **公式推导**：
   - 分步显示 `单独贡献`（蓝色）和 `组合贡献`（红色）的叠加。
   - 最终公式以绿色闪烁效果呈现。
3. **逆元计算**：
   - 快速幂计算时，展示二进制分解过程（如 `k^mod-2` 的位运算）。
   - 成功计算时播放“叮”音效。

### 复古交互
- **控制面板**：8-bit 风格按钮，支持暂停/步进。
- **音效**：使用 Web Audio API 播放芯片音乐，背景循环 8-bit BGM。

---

## 核心代码实现（Imakf 题解）
```cpp
// 读入 n 并取模
n = read(MOD), k = read();
LL sum = 0;
for(int i = 1; i <= k; ++i) sum = (sum + read()) % MOD;

// 计算逆元和最终答案
LL t = (n - 1 + MOD) * quick_pow(k*k % MOD, MOD-2) % MOD;
LL ivk = quick_pow(k, MOD-2);
LL Ans = (sum * t * 2 + ivk * n % MOD * sum) % MOD;
printf("%lld", Ans);
```

---
处理用时：64.06秒
# 题目信息

# 【模板】原根

## 题目描述

给定整数 $n$，求它的所有原根。

为了减小你的输出量，给出输出参数 $d$，设 $n$ 的所有原根有 $c$ 个，从小到大分别为 $g_1,\ldots,g_c$，你只需要依次输出 $g_d,g_{2d},\ldots,g_{\lfloor\frac{c}{d}\rfloor\times d}$。

---

如果你不了解原根的定义，可以自行查找资料或阅读下列定义：

正整数 $g$ 是正整数 $n$ 的原根，当且仅当 $1\leq g\leq n-1$，且 $g$ 模 $n$ 的阶为 $\varphi(n)$。

## 说明/提示

【样例解释】

对于第 $1,2,4,6$ 组数据，给出的 $n$ 的所有原根都出现在输出中。

对于第 $3$ 组数据，$25$ 的原根集合为 $\{2,3,8,12,13,17,22,23\}$。

对于第 $5$ 组数据，$9$ 的原根集合为 $\{2,5\}$。

【数据范围】

对于 $100\%$ 的数据，$1\leq T\leq 10$，$2\leq n\leq 10^6$，$1\leq d\leq 200$，保证输出的数的总个数不超过 $10^5$。

## 样例 #1

### 输入

```
6
2 1
4 1
25 2
36 1
9 6
18 1
```

### 输出

```
1
1 
1
3 
8
3 12 17 23 
0

2

2
5 11 
```

# AI分析结果



# 【模板】原根 题解分析

## 唯一算法分类
**数论 - 原根判定与生成**

---

## 题解思路与算法要点

### 核心思路
1. **原根存在性判断**  
   - 当且仅当 \( n = 2, 4, p^k, 2p^k \)（\( p \) 为奇素数）时，\( n \) 存在原根。
   - 预处理这些形式，快速判断是否存在原根。

2. **最小原根搜索**  
   - 枚举 \( g \in [1, n) \)，利用阶的性质验证：\( g^{\varphi(n)/p_i} \not\equiv 1 \ (\text{mod} \ n) \)（\( p_i \) 为 \( \varphi(n) \) 的质因子）。
   - 通过快速幂优化验证过程。

3. **生成所有原根**  
   - 若 \( g \) 是原根，则所有 \( g^k \ (\text{mod} \ n) \)（\( \gcd(k, \varphi(n)) = 1 \)）均为原根。
   - 使用筛法或欧拉函数性质高效生成满足条件的 \( k \)。

### 解决难点
- **快速验证原根**：通过分解 \( \varphi(n) \) 的质因子，避免枚举所有可能的阶。
- **高效生成互质数**：使用筛法或线性筛预处理标记与 \( \varphi(n) \) 互质的数，加速生成步骤。

---

## 题解评分（≥4星）

1. **codecode（5星）**  
   - **亮点**：完整数学证明，详细推导原根存在性与性质，代码结构清晰。
   - **关键代码**：分解 \( \varphi(n) \) 质因子，快速幂验证。

2. **ix35（4星）**  
   - **亮点**：代码简洁，预处理素数加速，直接生成原根。
   - **关键代码**：欧拉筛预处理，最小原根搜索逻辑。

3. **panyf（4星）**  
   - **亮点**：优化互质数生成，使用筛法标记，复杂度 \( O(n \log \log \log n) \)。
   - **关键代码**：埃氏筛思想标记非互质数。

---

## 最优思路提炼

1. **预处理优化**  
   - 预处理所有可能原根存在的形式（2,4,p^k,2p^k）。
   - 线性筛计算欧拉函数 \( \varphi(n) \)。

2. **质因数分解加速验证**  
   - 分解 \( \varphi(n) \) 的质因子，仅需检查这些因子对应的指数次幂。

3. **互质数筛法生成**  
   - 标记 \( \varphi(n) \) 的质因子倍数，快速筛选与 \( \varphi(n) \) 互质的数。

---

## 同类型题与算法套路

- **通用解法**：  
  1. 分解 \( \varphi(n) \) 的质因子。  
  2. 枚举验证最小原根。  
  3. 生成满足互质条件的指数 \( k \)。

- **类似题目**：  
  - **P4549**（原根应用）  
  - **P5535**（判断原根存在性）  
  - **P4139**（扩展欧拉定理与原根性质）

---

## 可视化与算法演示

### 动画方案
1. **循环群生成**  
   - **像素风格**：用 8 位色块表示模 \( n \) 的剩余类，原根 \( g \) 的幂次动态填充。
   - **高亮**：与 \( \varphi(n) \) 互质的指数对应的色块闪烁显示。

2. **关键步骤演示**  
   - **阶验证**：显示 \( g^{\varphi(n)/p_i} \ (\text{mod} \ n) \) 的计算过程，失败时红色闪烁。
   - **互质筛选**：筛法标记非互质数，灰色块表示被筛除。

3. **交互控制**  
   - **速度调节**：滑块控制动画速度（100ms~2s/步）。  
   - **步进模式**：手动点击执行下一步，观察验证逻辑。

### 复古游戏化设计
- **音效**：  
  - 成功找到原根：8-bit 胜利音效（上升音阶）。  
  - 验证失败：短促“错误”音效。  
- **积分系统**：  
  - 每正确生成一个原根得 10 分，连续正确触发连击奖励。  
- **自动演示模式**：AI 自动执行算法步骤，展示最优路径。

---

## 代码实现（关键片段）

```cpp
// 预处理欧拉函数与质数
void init() {
    phi[1] = 1;
    for (int i = 2; i <= N; i++) {
        if (!vis[i]) {
            prime[++cnt] = i;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= cnt && i*prime[j] <= N; j++) {
            vis[i*prime[j]] = 1;
            if (i % prime[j]) phi[i*prime[j]] = phi[i] * (prime[j]-1);
            else { phi[i*prime[j]] = phi[i] * prime[j]; break; }
        }
    }
}

// 寻找最小原根
int find_root(int n) {
    vector<int> factors = factorize(phi[n]);
    for (int g = 1; g < n; g++) {
        if (gcd(g, n) != 1) continue;
        bool valid = true;
        for (int p : factors) {
            if (qpow(g, phi[n]/p, n) == 1) { valid = false; break; }
        }
        if (valid) return g;
    }
    return -1;
}
```

---

## 个人心得摘录

- **调试教训**：未预处理原根存在性导致 TLE，需先判断 \( n \) 是否符合形式。  
- **优化顿悟**：筛法标记互质数比逐个计算 \( \gcd \) 快 10 倍以上。  
- **思维突破**：原根生成实为群论中的生成元，理解抽象代数概念后更易编码。

---
处理用时：87.29秒
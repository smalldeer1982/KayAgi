# 题目信息

# 『MdOI R2』Odyssey

## 题目背景

超越音速的极限，不及瑰丽多变的极光；

微弱的脉冲，开拓原本一片混沌的天地；

沉郁的蓝缓缓闪动，史诗的红迎接巅峰；

血色的夕阳尽头，是将夜的星辰；

夜半的满天星空，也会被来自地狱的硝烟掩盖；

炽红炼狱消逝，只金色遗迹永存。

在这里等待着每一位的，都是一段艰苦而璀璨的旅程。

## 题目描述

若正整数 $a$ 与 $b$ 满足：

- $a$ 与 $b$ 的积是一个正整数的 $k$ 次方，即存在正整数 $c$ 使得 $ab=c^k$。

那么我们称 $(a,b)$ 为一组**完美数对**。

---

有一个包含 $n$ 个结点和 $m$ 条边的**有向无环图**，这张图中的每条边都有权值和长度两个属性。

如果一条路径 $P$ 满足**以下条件之一**，则称其为一条**完美路径**：

- $P$ 中仅包含一条边。

- $P$ 从其起点开始依次为 $e_1, e_2, e_3, \ldots e_p$ 这 $p\ (p\ge 2)$ 条边，对于任意的 $1\leq i\leq p-1$，$e_i$ 的权值和 $e_{i+1}$ 的权值组成完美数对。

你需要求出图中最长完美路径的长度，一条路径的长度定义为这条路径上所有边的长度之和。

## 说明/提示

【帮助与提示】  

为方便选手测试代码，本题额外提供两组附加样例供选手使用。  

[样例输入1](https://www.luogu.com.cn/paste/wx1lz6m2) [样例输出1](https://www.luogu.com.cn/paste/28xe7f0x)      

[样例输入2](https://www.luogu.com.cn/paste/efgwngs5) [样例输出2](https://www.luogu.com.cn/paste/5hcpoayt)   

----

【样例解释】

样例中给出的有向无环图如图所示，其中边上的红色数字为边的权值，黑色数字为边的长度：

![](https://cdn.luogu.com.cn/upload/image_hosting/w6x03ksd.png)

最长完美路径为 $2\to 5\to 3$，因为这两条边的权值 $2$ 和 $18$ 满足 $2\times 18=6^2$，是完美数对，此路径长度为 $5+9=14$。

此外，$2\to 1\to 4\to 3,\ \ 2\to 4\to 3,\ \ 1\to 5\to 3$ 等也是完美路径，但不是最长的。

图中，$2\to 1\to 5\to 3$ 长度为 $15$，是一条更长的路径，但它并不是完美路径，因为前两个边权 $24$ 和 $8$ 的乘积为 $192$，不是正整数的平方，即 $(24,8)$ 不是完美数对。

---

【数据范围】

**本题采用捆绑测试。**

对于 $100\%$ 的数据：$1\leq n\leq 10^5,\ \ 1\leq m\leq 2\times 10^5,\ \ 1\leq k\leq 10,\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^5,\ \ 1\leq l\leq 10^4$。

给出的图**不保证弱连通**，图中从一个点到另一个点**可能**存在多条边，但保证给出的图是有向无环图。

| 子任务编号 | $n\leq$ |     $m\leq$      | $w\leq$ | $k\leq$ |  特殊性质  | 分值 |
| :--------: | :-----: | :--------------: | :-----: | :-----: | :--------: | :--: |
| Subtask 1  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $1$   |     无     | $18$ |
| Subtask 2  |  $10$   |       $10$       |  $100$  |  $2$   |     无     | $12$ |
| Subtask 3  |  $600$  | $1.5\times 10^3$ | $10^3$  |   $2$   |     无     | $10$ |
| Subtask 4  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   | $w$ 为素数 | $15$ |
| Subtask 5  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   |     无     | $15$ |
| Subtask 6  |  $600$  | $1.5\times 10^3$ | $10^3$  |  $5$   |     无     | $10$ |
| Subtask 7  | $10^5$  |  $2\times 10^5$  | $10^5$  |  $10$   |     无     | $20$ |



## 样例 #1

### 输入

```
5 7 2
2 5 2 5
5 3 18 9
2 4 6 7
4 3 6 3
2 1 24 2
1 4 6 8
1 5 8 4```

### 输出

```
14```

# AI分析结果



## 算法分类
拓扑排序上的动态规划（DAG DP）

---

## 题解思路与解决难点

### 核心思路
1. **数论处理**：将边权分解质因数，指数对k取模，得到简化后的权值w及其互补数f(w)，满足w*f(w)是k次方。
2. **状态设计**：定义dp[u][w]表示以u节点为终点，最后一条边权为w的最长路径长度。
3. **拓扑排序转移**：按拓扑序更新状态，当处理边(u→v)时，若当前边权为w，则用dp[u][f(w)] + l更新dp[v][w]。
4. **数据结构优化**：使用哈希或map存储状态，避免预处理所有可能的权值。

### 解决难点
1. **互补数计算**：处理大质数时需防止溢出，例如当f(w)超过1e5时标记为无效。
2. **状态爆炸问题**：直接存储每个节点所有可能的权值会MLE，使用unordered_map或分层图动态管理。
3. **DAG性质利用**：拓扑排序保证无环，确保状态转移顺序正确。

---

## 题解评分（≥4星）

### 一扶苏一（5星）
- **亮点**：双哈希避免冲突，map状态转移清晰，代码模块化。
- **代码**：通过质因数分解预处理哈希值，map存储状态，拓扑排序中动态更新。

### BFqwq（4星）
- **亮点**：分层图设计巧妙，通过节点扩展处理互补边。
- **注意点**：代码中需处理分层图的连接关系，数组大小需仔细计算。

### zzqDeco（4星）
- **亮点**：代码简洁，直接使用unordered_map存储状态，适合快速实现。
- **优化**：拓扑排序中实时更新状态，避免预处理哈希。

---

## 最优思路提炼

1. **质因数分解取模**  
   ```python
   def preprocess(w):
       res = 1
       for p in primes:
           cnt = 0
           while w % p == 0:
               cnt += 1
               w //= p
           cnt %= k
           res *= p^cnt  # 实际代码需处理溢出
       return res, complementary_res
   ```
2. **拓扑排序动态规划**  
   ```cpp
   queue<int> q;
   while (!q.empty()) {
       int u = q.front();
       for (auto [v,w,l] : edges[u]) {
           dp[v][current_hash] = max(dp[v][current_hash], 
                                   dp[u][complement_hash] + l);
           if (--in[v] == 0) q.push(v);
       }
   }
   ```

3. **哈希状态压缩**  
   使用双哈希或质数幂次组合作为唯一标识：
   ```cpp
   hash_val = 0;
   for (auto [p, cnt] : factors)
       hash_val += cnt * PRIME_BASE^(p_id);
   ```

---

## 类似题目推荐

1. **P1137 旅行计划**  
   DAG最长路径模板，可套用拓扑排序DP。

2. **P3387 缩点+最长路径**  
   DAG上动态规划，需先处理强连通分量。

3. **P2149 障碍路线**  
   带状态限制的最短路径，类似状态转移思想。

---

## 可视化设计

### 复古像素动画方案
1. **画面布局**  
   - **左侧**：8-bit风格节点网格，用不同颜色标记活跃节点（当前处理的u）和相邻节点v。
   - **右侧**：显示当前边权分解公式，如`24=2^3*3^1 → 2^(3%2)=2^1`。

2. **动画流程**  
   ```mermaid
   graph TD
   A[当前节点u高亮黄色] --> B[显示u的出边]
   B --> C[分解边权w→显示质因数模k]
   C --> D[查找互补数f(w)→显示红色箭头]
   D --> E[更新v节点状态→绿色闪烁]
   ```

3. **音效设计**  
   - **分解成功**：8-bit上升音阶（do→mi→sol）。
   - **状态更新**：经典马里奥金币音效。
   - **路径延长**：塞尔达解谜成功音效。

4. **交互功能**  
   - **速度滑块**：控制拓扑排序执行速度。
   - **单步调试**：空格键逐步执行状态转移。
   - **哈希查看**：点击节点显示当前所有状态值。

---

## 核心代码实现（BFqwq分层图版）

```cpp
void topo(int w) {
    while (!q.empty()) q.pop();
    // 建图部分
    for (auto e : g[w]) { // w类型边
        add(e.from, e.to + n, e.l); // 分层处理
        in[e.to + n]++;
    }
    for (auto e : g[f[w]]) { // 互补类型边
        add(e.from + n, e.to, e.l);
        in[e.to]++;
    }
    // 拓扑排序DP
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = h[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            dp[v] = max(dp[v], dp[u] + e[i].l);
            if (--in[v] == 0) q.push(v);
        }
    }
}
```

---

## 个人心得摘录

> **BFqwq调试经历**：  
> 最初未考虑分层图节点数翻倍，导致RE。后来将数组开至2倍，并清空每轮状态，最终AC。  
> **教训**：DAG扩展时务必计算清楚节点规模。

> **zzqDeco优化技巧**：  
> 发现unordered_map比map快30%，但需要处理哈希冲突。实测1e5规模下冲突率可接受。

---

通过结合数论处理与动态规划，此题完美体现了DAG性质与状态压缩的巧妙结合。8-bit风格可视化可显著提升算法理解趣味性。

---
处理用时：97.81秒
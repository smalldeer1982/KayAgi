# 题目信息

# 「EZEC-9」GCD Tree

## 题目背景

规定 $\gcd(x,y)$ 表示 $x,y$ 的最大公约数，$\operatorname{lca}(x,y)$ 表示 $x$ 号节点和 $y$ 号节点的最近公共祖先。

## 题目描述

给你 $n$ 个点，编号分别为 $1,2,\ldots,n$，点权分别为 $a_1,a_2,\ldots,a_n$。

请你用这 $n$ 个点构造一棵树，使得 $\forall 1 \le i < j \le n$，$\gcd(a_i, a_j) = a_{\operatorname{lca}(i, j)}$。

若无解，报告之，否则输出树的形态。

## 说明/提示

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（5 points）：$n = 2$。
-  Subtask 2（5 points）：所有 $a_i$ 均相等。
-  Subtask 3（5 points）：$n \le 5$。
-  Subtask 4（10 points）：保证有解。
-  Subtask 5（15 points）：$n \le 100$。
-  Subtask 6（15 points）：$n \le 10^3$。
-  Subtask 7（15 points）：$n \le 3 \times 10^3$。
-  Subtask 8（30 points）：无特殊限制。

对于 $100 \%$ 的数据，$2 \le n \le 10^5$，$1 \le a_i \le 10^6$。

## 样例 #1

### 输入

```
5
1 2 3 4 5
```

### 输出

```
0 1 1 2 1
```

## 样例 #2

### 输入

```
5
1 2 3 4 6
```

### 输出

```
-1
```

# AI分析结果



## 算法分类
**数论构造、树结构、倍数处理**

---

## 题解思路与解决难点

### 核心思路
1. **重复点处理**：权值相同的点必须形成链式结构，只保留一个代表节点参与后续构造。
2. **父节点选择**：每个节点的父节点是权值最大的存在的因数（确保满足 `gcd` 条件）。
3. **树结构验证**：验证所有可能的 `gcd` 值对应的节点是否构成连续子树，避免非法点对。

### 关键步骤
1. **重复点缩链**：将相同权值的点连成链，父节点指向第一个出现的点。
2. **按权值排序**：从大到小枚举权值，将倍数未分配父节点的点连接当前节点。
3. **调和级数遍历**：枚举所有可能的 `gcd` 值，检查其倍数是否形成合法子树。

### 难点对比
- **littleKtian**：通过调和级数遍历倍数，快速连接父子，二次验证子树连续性。
- **LZDQ**：分解每个节点与父节点的商值质因数，验证质因数对应的节点形成链式结构。
- **Ecrade_**：预处理所有数的因数，按因数大小建树，并利用倍增 LCA 验证。

---

## 题解评分（≥4星）

1. **littleKtian（★★★★★）**  
   - **亮点**：代码简洁，调和级数遍历高效，验证逻辑清晰。  
   - **实现**：用数组 `xh` 记录权值映射，两次遍历快速建树。

2. **LZDQ（★★★★☆）**  
   - **亮点**：质因数分解验证，通过 `c_u = a_u / fa_u` 避免冗余计算。  
   - **实现**：动态数组存储质因数对应的节点，链式检查。

3. **chenxinyang2006（★★★★☆）**  
   - **亮点**：利用 `set` 维护子树，倍增 LCA 快速验证。  
   - **实现**：预处理因数集合，按大小递归构建子树。

---

## 最优思路提炼

### 关键技巧
1. **缩链处理重复点**：相同权值点形成链，仅保留代表节点。
2. **最大因数父节点**：按权值从大到小连接倍数节点，确保父节点为最大因数。
3. **调和级数验证**：枚举 `gcd` 值，检查其倍数是否连续子树。

### 数据结构
- **哈希数组**：记录权值到节点的映射（`xh[a] = i`）。
- **动态数组/调和遍历**：快速处理倍数关系。

### 代码片段（littleKtian）
```cpp
// 处理重复点
for (int i = 1; i <= n; i++) {
    if (xh[a[i]]) fa[xh[a[i]]] = i, tj(i, xh[a[i]]), ++tt;
    xh[a[i]] = i;
}

// 按权值从大到小建树
for (int i = N; i; i--) if (xh[i]) {
    rt = xh[i];
    for (int j = i * 2; j <= N; j += i)
        if (xh[j] && (!fa[xh[j]])) fa[xh[j]] = xh[i], tj(xh[i], xh[j]), ++tt;
}

// 验证子树连续性
for (int i = 1; i <= N; i++) {
    int tt = 0;
    for (int j = i; j <= N; j += i)
        if (xh[j] && (fa[xh[j]] == 0 || a[fa[xh[j]]] % i != 0)) ++tt;
    if (tt > 1) return printf("-1"), 0;
}
```

---

## 类似题目
1. **P3384 【模板】树链剖分**：树结构操作与路径处理。
2. **P2421 荒岛野人**：数论构造与因数分析。
3. **CF915G Coprime Arrays**：调和级数优化与因数处理。

---

## 可视化设计

### 动画方案
1. **像素风格**：用 16 色调色板绘制树节点，根节点为红色，普通节点为绿色。
2. **高亮操作**：
   - **连接父子**：当前处理的权值节点高亮黄色，连接的倍数节点闪烁蓝色。
   - **验证步骤**：非法 `gcd` 值出现时，相关节点变为红色并播放失败音效。
3. **控制面板**：
   - **速度调节**：滑动条控制建树和验证速度。
   - **步进执行**：手动触发每一步操作，观察权值遍历和父子连接。

### 复古音效
- **连接成功**：8-bit 短促“滴”声。
- **验证失败**：低音“嗡”声提示非法结构。
- **背景音乐**：循环播放 FC 风格轻快旋律。

---

## 结论
通过权值因数关系构造树，结合调和级数遍历和子树验证，可在 `O(n log n)` 复杂度内高效解决。核心在于合理处理重复点、正确选择父节点，并全面验证所有可能的 `gcd` 情况。

---
处理用时：81.87秒
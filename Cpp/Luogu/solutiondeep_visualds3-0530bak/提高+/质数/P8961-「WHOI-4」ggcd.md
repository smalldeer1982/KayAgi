# 题目信息

# 「WHOI-4」ggcd

## 题目背景

如何输入输出 `__int128`：

```cpp
__int128 read() {
  char c = getchar();
  __int128 x = 0;
  bool f = 0;
  for (; !isdigit(c); c = getchar()) f ^= !(c ^ 45);
  for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
  if (f) x = -x;
  return x;
}
void write(__int128 x, char c = '\0') {
  if (x < 0) putchar('-'), x = -x;
  if (x > 9) write(x / 10);
  putchar(x % 10 + '0');
  if (c != '\0') putchar(c);
}
```

## 题目描述

**本题已新增一组样例，请注意查看。**

小 Y 给了你长度为 $n$ 的数组 $y$ 以及一个正整数 $m$，保证 $0\le y_i<m$，请你构造一个同样长为 $n$ 的数组 $x$，使得：

1. $x_i$ 在 `__int128` 范围内；
2. $x_i\bmod m=y_i$；
3. $\gcd(|x_1|,\cdots,|x_n|)\bmod m$ 最大。

注意，$x_i$ **可以为负**，此时 $m\mid (x_i-y_i)$ 且 $0\le y_i<m$。 

## 说明/提示

**数据范围**

**本题采用捆绑测试。**

Subtask 1（$30$ pts）：$m$ 是素数。

Subtask 2（$70$ pts）：无特殊限制。

对于所有数据，保证 $2\le m \le10^9$，$1\le n\le10^6$。

**关于 Special Judge**

对于每个测试点：

如果你输出的格式不正确，你将会获得 $0$ 分。

如果你输出的数中有不在 `__int128` 范围的数，可能导致溢出所以你可能无法获得预期的分数。

如果你的数列 $x$ 不符合题目给定的 $y$，你将会获得 $0$ 分。

如果你的数列 $x$ 不符合你输出的 $g$，你将会获得 $0$ 分。

如果你的 $g$ 不为最大，你将会获得 $0$ 分。

否则你将获得该测试点的所有分数。

## 样例 #1

### 输入

```
1 10
4```

### 输出

```
6
-6```

## 样例 #2

### 输入

```
1 10
7```

### 输出

```
7
7```

## 样例 #3

### 输入

```
2 9
3 3```

### 输出

```
6
12 -6```

## 样例 #4

### 输入

```
10 7
1 2 3 4 5 6 0 1 2 3```

### 输出

```
6
36 30 24 18 12 6 42 -6 30 24```

# AI分析结果



**唯一算法分类**  
数论（最大公约数）

---

### **题解思路与解决难点**  
**核心思路**：  
1. 推导最大可能的 gcd 模 m 值：  
   - 设 `g = gcd(y₁, y₂, ..., yₙ, m)`，则答案 `ans = m - g`  
   - 原理：每个 `y_i` 可构造为 `y_i` 或 `m-y_i`，其与 `m` 的 gcd 相同。最终所有数的 gcd 与 `m` 取最大公约数的结果即为 `g`，模 `m` 的最大值为 `m - g`  

2. 构造数组的关键步骤：  
   - 对非关键点 `i ≠ p`，构造 `x_i = -ans * (y_i / g)`，保证 `ans` 整除 `x_i`  
   - 对关键点 `p`，寻找 `k'` 使得 `x_p = ans * (k'*m - y_p)/g` 的绝对值的 gcd 与其他数一致  

**解决难点**：  
- **数学推导**：需证明 `ans = m - g` 的正确性，涉及模运算和 gcd 的交互性质  
- **构造实现**：处理全零数组的特殊情况，以及寻找合适的 `k'` 使得整体 gcd 正确  

---

### **题解评分 (4星)**  
- **思路清晰度**：★★★★☆（核心推导完整，但构造细节需反复推敲）  
- **代码可读性**：★★★☆☆（变量命名简略，缺乏注释）  
- **算法优化**：★★★★☆（线性时间计算 gcd，随机试探 `k'` 保证效率）  
- **实践操作**：★★★★☆（需注意 `__int128` 范围限制）  

---

### **最优思路或技巧提炼**  
1. **数论转换**：将模条件转换为 `x_i = y_i + k_i*m`，利用 `gcd(a, b) = gcd(a - k*b, b)` 简化问题  
2. **构造策略**：对非关键点统一构造，对关键点枚举/随机试探以保证整体 gcd  
3. **边界处理**：特判全零数组和单元素数组，避免除零错误  

---

### **同类型题推荐**  
1. **洛谷 P2445**：最大化操作后的数组 gcd  
2. **洛谷 P5435**：快速计算多个数的 gcd  
3. **洛谷 P1072**：结合 gcd 和 lcm 的复合条件求解  

---

### **代码核心逻辑实现**  
```cpp
// 计算全局 gcd(g)
int g = m;
for (int i = 1; i <= n; ++i) {
    g = __gcd(g, a[i]); // a[i] 为输入的 y_i
}
ans = m - g;

// 构造非关键点 x_i
for (int i = 1; i <= n; ++i) {
    if (i == AN) continue; // AN 是预先选定的关键点下标
    k[i] = -a[i] / g;
    x[i] = k[i] * m + a[i]; // 保证 x_i ≡ y_i (mod m)
}

// 寻找关键点 k' 使得整体 gcd 为 ans
int _k = 1;
do {
    k[AN] = (_k * ans - a[AN]) / g;
    x[AN] = k[AN] * m + a[AN];
    _k++;
} while (__gcd(G, x[AN]) != ans);
```

---

### **可视化与算法演示设计**  
**动画方案**：  
1. **状态面板**：  
   - 左侧显示当前计算步骤（如“计算全局 gcd”、“构造非关键点”、“试探关键点 k'”）  
   - 右侧用网格展示数组 `x[]`，当前操作元素高亮为红色  

2. **关键步骤演示**：  
   - **GCD 计算**：用连线动态连接 `y_i` 和 `g`，显示 `g` 的更新过程  
   - **构造非关键点**：显示 `x_i = -ans*(y_i/g)` 的公式推导，绿色标记已构造元素  
   - **试探 k'**：用闪烁效果展示 `x_p` 的变化，成功时播放胜利音效  

3. **复古风格**：  
   - **8位像素 UI**：使用 16 色调色板，算法步骤用复古字体显示  
   - **音效设计**：  
     - 计算 gcd 时播放短促“滴”声  
     - 成功构造时播放 8-bit 胜利旋律  
     - 错误时播放低音“哔”声  

**交互设计**：  
- **步进控制**：空格键单步执行，方向键调整动画速度  
- **自动演示**：按 `A` 键启动 AI 自动完成构造流程  

---

### **总结**  
本题核心在于通过数论性质推导最大可能值，并巧妙构造数组满足条件。可视化设计通过复古风格和交互式演示，帮助理解数学推导与构造策略的关联，适合作为数论与构造题的典型教学案例。

---
处理用时：81.74秒
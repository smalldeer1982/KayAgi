# 题目信息

# [科大国创杯小学组 2025] 改写

## 题目背景

Subtask 0 为民间数据（最后两组测试点为民间 hack 数据），Subtask 1 为官方数据。

## 题目描述

小可可在学习字符串算法！

一个长度为 $m$ 的字符串 $r$ 是回文的，当且仅当 $r_i = r_{m+1-i}$ 对所有 $1 \leq i \leq m$ 均成立。例如 $\tt{aaabaaa}$，$\tt{abba}$ 都是回文串，但 $\tt{aaabaa}$ 不是回文串。

给定一个字符串 $s$，把 $s$ 分成若干个非空子段，使得每一个子段都不是回文的，同时最大化划分出的子段数目，请你输出最大划分数，无解则输出 $-1$。

子段的定义为：一个字符串保留任意连续字符后形成的字符串。

由于字符串 $s$ 可能很长，我们将会按照 $c, len$ 的形式给出整个字符串，具体含义见输入格式。

## 说明/提示

### 样例解释

- 对于第一组数据，序列为 $\tt{ba}$，且只存在 $\tt{ba}$ 这一种划分方案，因此答案为 $1$。
- 对于第二组数据，序列为 $\tt{bbbb}$，显然没有合法方案。
- 对于第三组数据，序列为 $\tt{aabbabbaba}$，存在一种划分出四段的方案: $\tt{aabb}$，$\tt{ab}$，$\tt{ba}$，$\tt{ba}$，可以证明没有答案更优的划分方式。
- 对于第四组数据，序列为 $\tt{aabaaccaa}$，存在一种划分出三段的方案: $\tt{aaba}$，$\tt{ac}$，$\tt{caa}$，可以证明没有答案更优的划分方式。
- 对于第五组数据，序列为 $\tt{aba}$，容易发现无论怎么划分，都至少有一个回文串，所以无解。

### 约定和数据范围

- 数据点 $1$，$T = 10$，$1 \leq n \leq 3$，$1 \leq len_i \leq 2$。
- 数据点 $2$，$T = 10$，$1 \leq n \leq 3$，$1 \leq len_i \leq 10^9$。
- 数据点 $3, 4$，$T = 10$，$1 \leq n \leq 150$，$1 \leq len_i \leq 2$。
- 数据点 $5, 6$，$T = 10$，$1 \leq n \leq 150$，$1 \leq len_i \leq 10^9$。
- 数据点 $7 \sim 9$，$T = 10$，$1 \leq n \leq 2.5 \times 10^3$，$1 \leq len_i \leq 2$。
- 数据点 $10 \sim 12$，$T = 10$，$1 \leq n \leq 2.5 \times 10^3$，$1 \leq len_i \leq 10^9$。
- 数据点 $13 \sim 16$，$T = 10, 1 \leq n \leq 10^5, 1 \leq len_i \leq 2$。
- 数据点 $17 \sim 20$，$T = 10, 1 \leq n \leq 10^5, 1 \leq len_i \leq 10^9$。

## 样例 #1

### 输入

```
5
2
b 1
a 1
1
b 4
7
a 2
b 2
a 1
b 2
a 1
b 1
a 1
5
a 2
b 1
a 2
c 2
a 2
3
a 1
b 1
a 1```

### 输出

```
1
-1
4
3
-1```

# AI分析结果



---

### **算法分类**
贪心算法

---

### **综合分析与结论**
#### **题目核心**
将字符串分割成最多的非回文子段，需快速处理输入的大规模压缩字符串。

#### **题解思路**
1. **关键性质**：相邻不同字符的段合并后必为非回文。
2. **压缩段处理**：将长度超过2的段压缩为长度为2的段，简化问题。
3. **贪心分割**：尽可能分割相邻的不同段，最大化划分数。
4. **动态规划解法**：检查每个位置前4个可能的子段是否为非回文，更新最优划分数。

#### **解决难点**
- **回文判断优化**：通过压缩后的字符串减少回文判断的复杂度。
- **大规模输入处理**：动态规划处理压缩后的字符串，复杂度为 O(n)。

#### **可视化设计**
- **动画流程**：展示压缩后的字符串，高亮当前检查的字符段，动态更新分割点。
- **颜色标记**：当前处理字符段用红色高亮，已确认的非回文子段用绿色标记。
- **步进控制**：允许单步执行，观察每一步的分割决策。
- **8位像素风格**：用复古方块表示字符，音效提示分割成功/失败。

---

### **题解清单**
1. **JHPOTATO 题解（★★★★☆）**
   - **关键亮点**：通过贪心策略处理压缩后的段，分析各类段的最优合并方式。
   - **代码可读性**：理论分析全面，但代码实现需处理较多边界条件。

2. **Officer_Xia_ZhuRen 题解（★★★★★）**
   - **关键亮点**：动态规划直接处理压缩字符串，暴力检查前4个位置，代码简洁高效。
   - **实践优势**：适用于大规模输入，时间复杂度可控。

---

### **最优思路提炼**
1. **段压缩**：将每段长度截断为最多2，转化为 O(n) 规模问题。
2. **贪心分割**：相邻不同字符的段合并为非回文子段，最大化划分数。
3. **动态规划优化**：对压缩后的字符串，每个位置仅检查前4个可能的子段。

---

### **代码实现**
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m;
int a[400005], dp[400005];

bool checkpl(int l, int r) {
    for (int i = l; i <= (l + r) / 2; ++i) {
        if (a[i] != a[r - (i - l)]) return false;
    }
    return true;
}

void solve() {
    cin >> m;
    n = 0;
    // 处理输入，将每段压缩为最多2长度
    for (int i = 1; i <= m; ++i) {
        char c; int len;
        cin >> c >> len;
        len = min(len, 2);
        for (int j = 0; j < len; ++j) {
            a[++n] = c - 'a' + 1;
        }
    }
    fill(dp, dp + n + 1, -1e9);
    dp[0] = 0;
    for (int i = 1; i <= n; ++i) {
        for (int j = max(1, i - 4); j <= i; ++j) {
            if (!checkpl(j, i)) {
                dp[i] = max(dp[i], dp[j-1] + 1);
            }
        }
    }
    if (!checkpl(1, n)) dp[n] = max(dp[n], 1);
    cout << (dp[n] < 0 ? -1 : dp[n]) << endl;
}

int main() {
    int T; cin >> T;
    while (T--) solve();
    return 0;
}
```

---

### **相似题目推荐**
1. **P1435 回文字串**  
2. **P1216 分割回文串**  
3. **P1659 压缩技术（续集版）**

---

### **可视化演示**
- **Canvas 动画**：将压缩后的字符串显示为像素块，不同颜色代表不同字符。
- **动态高亮**：红色标记当前检查的子段，绿色标记合法分割。
- **音效提示**：成功分割时播放上升音调，失败时短促低音。
- **自动演示**：展示贪心策略的逐步分割过程，对比动态规划决策路径。

---

### **总结**
通过压缩段和贪心/动态规划策略，高效解决大规模字符串分割问题，关键在优化回文判断和分割决策。

---
处理用时：191.49秒
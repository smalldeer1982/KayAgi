# 题目信息

# [NOIP 2003 提高组] 侦探推理

## 题目描述

明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：

$$
\def\arraystretch{1.5}
\begin{array}{|l|l|}\hline
\textbf{\textsf{证词内容}} & \textbf{\textsf{证词含义}}\\\hline
\text{I am guilty.} & \text{我是罪犯。} \\\hline
\text{I am not guilty.} & \text{我不是罪犯。} \\\hline
\text{{\tt XXX} is guilty.} & \text{{\tt XXX} 是罪犯。其中 {\tt XXX} 表示某个同学的名字。} \\\hline
\text{{\tt XXX} is not guilty.} & \text{{\tt XXX} 不是罪犯。} \\\hline
\text{Today is {\tt XXX}.} &
\begin{aligned}
&\text{今天是 {\tt XXX}。其中 {\tt XXX} 表示某个星期的单词。}\\
&\text{星期只有可能是以下之一：}\\
&\texttt{Monday}, \texttt{Tuesday}, \texttt{Wednesday}, \texttt{Thursday}, \\
&\texttt{Friday}, \texttt{Saturday}, \texttt{Sunday}。
\end{aligned}
\\\hline
\end{array}$$

证词中出现的其他话，都不列入逻辑推理的内容。


明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。


现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！

## 说明/提示

对于 $100\%$ 数据，满足 $1\le M\le 20$，$0\le N\le M$，$1\le P\le 100$。

**【题目来源】**

NOIP 2003 提高组第二题

## 样例 #1

### 输入

```
3 1 5
MIKE
CHARLES
KATE
MIKE: I am guilty.
MIKE: Today is Sunday.
CHARLES: MIKE is guilty.
KATE: I am guilty.
KATE: How are you??
```

### 输出

```
MIKE
```

# AI分析结果



### 综合分析与结论

**题目核心思路**：  
本题需通过枚举可能的罪犯和日期，结合证词的真假性进行逻辑验证。关键在于正确处理证词格式，动态判断每个人的真/假状态，并统计假话人数是否在允许范围内。虽题目不涉及典型贪心算法，但通过枚举优化的暴力法成为主流解法。

**解决难点**：  
1. **证词解析**：需处理多种语句格式（如"I am guilty"与"XXX is guilty"），并过滤无效证词。  
2. **状态一致性**：同一人的所有证词必须全真或全假，需快速检测矛盾。  
3. **人数浮动处理**：未说话者的真假状态需动态计算，满足假话人数范围约束。

**算法共性**：  
各题解均采用双重枚举（罪犯+日期）+ 逐人验证的框架，利用数据结构（`map`, `vector`）优化证词存储，通过状态标记与计数判断合法性。

---

### 题解清单（评分≥4星）

1. **wjyyy（4.5星）**  
   - **亮点**：使用STL高效处理人名映射与证词分类，逻辑分层清晰，变量命名规范。  
   - **关键代码**：通过`vector<sta>`存储结构化证词，简化后续验证逻辑。  
   - **个人心得**：强调数据预处理的重要性，避免无效证词干扰主逻辑。

2. **Sanust（4星）**  
   - **亮点**：结构体存储证词三要素（主语、日期、否定），代码注释详尽，处理"I"的特殊情况。  
   - **剪枝优化**：在验证中提前终止矛盾情况，减少无效枚举。

---

### 最优思路提炼

**核心策略**：  
1. **双重枚举**：遍历每个嫌疑人（罪犯候选）和星期组合，构建假设场景。  
2. **证词验证**：对每个假设场景，检查所有人的证词是否自洽（全真或全假）。  
3. **动态计数**：  
   - 确定说假话的人数`cnt`和未说话者的浮动范围`ran`。  
   - 若`N ∈ [cnt, cnt+ran]`，假设成立。

**实现技巧**：  
- **结构化存储**：将证词按类型（日期/罪犯）和属性（肯定/否定）分类。  
- **快速映射**：利用`map`实现人名到编号的快速转换，避免字符串重复比较。  
- **剪枝优化**：在验证中一旦发现矛盾立即终止当前假设，减少计算量。

---

### 同类型题目推荐

1. **P1003 铺地毯**：枚举判断目标点覆盖情况。  
2. **P1217 [USACO1.5]回文质数**：结合枚举与数学验证。  
3. **P1036 选数**：子集枚举与质数判断。

---

### 可视化设计思路

**动画演示方案**：  
1. **枚举高亮**：  
   - 用不同颜色标记当前假设的罪犯（红色）和日期（蓝色）。  
   - 网格显示所有嫌疑人，点击可切换枚举目标。  
2. **证词验证过程**：  
   - 逐人显示证词，真话标绿，假话标红，矛盾时闪烁提示。  
   - 侧边栏动态更新`cnt`与`ran`的数值，符合条件时边框高亮。  
3. **交互控制**：  
   - **步进模式**：手动切换假设场景，观察验证细节。  
   - **自动播放**：按顺序演示所有可能组合，最终停留合法结果。  

**复古像素风格**：  
- **8-bit元素**：嫌疑人用像素头像表示，证词以对话气泡呈现。  
- **音效设计**：  
  - 正确选择时播放经典FC过关音效（如《超级玛丽》金币声）。  
  - 矛盾触发时使用《魂斗罗》中弹音效。  
- **积分系统**：  
  - 每正确排除一个不可能场景得10分，连击正确则积分翻倍。  

---

### 关键代码片段（wjyyy版）

```cpp
// 枚举罪犯i和星期j，验证合法性
for(int i=1;i<=n;++i) { // 枚举罪犯
    for(int j=1;j<=7;++j) { // 枚举星期
        int flag=0, cnt=0, ran=0;
        for(int k=1; !flag && k<=n; ++k) { // 检查每个人
            vector<sta>::iterator it = v[k].begin();
            if(v[k].empty()) { ran++; continue; }
            // 计算当前人证词的真假状态
            bool rea = ...; // 根据i,j判断
            // 检查后续证词是否一致
            for(; it!=v[k].end(); ++it) {
                if(矛盾发生) { flag=1; break; }
            }
            cnt += !rea; // 统计假话数
        }
        if(!flag && cnt>=m && cnt-ran<=m) {
            // 合法情况处理
        }
    }
}
```

---

### 总结

本题解通过暴力枚举与结构化验证，高效处理逻辑推理的复杂性。核心优化在于合理的数据存储（分类证词）与动态计数策略，确保在有限数据范围内快速求解。可视化设计通过交互式枚举演示，帮助理解假设验证的动态过程，结合复古元素增强学习趣味性。

---
处理用时：95.27秒
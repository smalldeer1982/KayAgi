# 题目信息

# [NOIP 2012 提高组] 开车旅行

## 题目描述

小 $\text{A}$ 和小 $\text{B}$ 决定利用假期外出旅行，他们将想去的城市从 $1 $ 到 $n$ 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 $i$ 的海拔高度为$h_i$，城市 $i$ 和城市 $j$ 之间的距离 $d_{i,j}$ 恰好是这两个城市海拔高度之差的绝对值，即 $d_{i,j}=|h_i-h_j|$。
 
旅行过程中，小 $\text{A}$ 和小 $\text{B}$ 轮流开车，第一天小 $\text{A}$ 开车，之后每天轮换一次。他们计划选择一个城市 $s$ 作为起点，一直向东行驶，并且最多行驶 $x$ 公里就结束旅行。    

小 $\text{A}$ 和小 $\text{B}$ 的驾驶风格不同，小 $\text{B}$ 总是沿着前进方向选择一个最近的城市作为目的地，而小 $\text{A}$ 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 $x$ 公里，他们就会结束旅行。

在启程之前，小 $\text{A}$ 想知道两个问题：

1、 对于一个给定的 $x=x_0$，从哪一个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值最小（如果小 $\text{B}$ 的行驶路程为 $0$，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。

2、对任意给定的 $x=x_i$ 和出发城市 $s_i$，小 $\text{A}$ 开车行驶的路程总数以及小 $\text B$ 行驶的路程总数。


## 说明/提示

【样例1说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/zgms0k7y.png)

各个城市的海拔高度以及两个城市间的距离如上图所示。

如果从城市 $1$ 出发，可以到达的城市为 $2,3,4$，这几个城市与城市 $1$ 的距离分别为 $1,1,2$，但是由于城市 $3$ 的海拔高度低于城市 $2$，所以我们认为城市 $3$ 离城市 $1$ 最近，城市 $2$ 离城市 $1$ 第二近，所以小A会走到城市 $2$。到达城市 $2$ 后，前面可以到达的城市为 $3,4$，这两个城市与城市 $2$  的距离分别为 $2,1$，所以城市 $4$ 离城市 $2$ 最近，因此小B会走到城市$4$。到达城市 $4$ 后，前面已没有可到达的城市，所以旅行结束。

如果从城市 $2$ 出发，可以到达的城市为 $3,4$，这两个城市与城市 $2$ 的距离分别为 $2,1$，由于城市 $3$ 离城市 $2$ 第二近，所以小 $\text A$ 会走到城市 $3$。到达城市 $3$ 后，前面尚未旅行的城市为 $4$，所以城市 $4$ 离城市 $3$ 最近，但是如果要到达城市 $4$，则总路程为 $2+3=5>3$，所以小 $\text B$ 会直接在城市 $3$ 结束旅行。

如果从城市 $3$ 出发，可以到达的城市为 $4$，由于没有离城市 $3$ 第二近的城市，因此旅行还未开始就结束了。

如果从城市 $4$ 出发，没有可以到达的城市，因此旅行还未开始就结束了。


【样例2说明】

当 $x=7$ 时，如果从城市 $1$ 出发，则路线为 $1 \to 2 \to 3 \to 8 \to 9$，小 $\text A$ 走的距离为 $1+2=3$，小 $\text B$ 走的距离为 $1+1=2$。（在城市 $1$ 时，距离小 $\text A$ 最近的城市是 $2$ 和 $6$，但是城市 $2$ 的海拔更高，视为与城市 $1$ 第二近的城市，所以小 $\text A$ 最终选择城市 $2$；走到$9$ 后，小 $\text A$ 只有城市 $10$ 可以走，没有第二选择可以选，所以没法做出选择，结束旅行）

如果从城市 $2$ 出发，则路线为 $2 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $3$ 出发，则路线为 $3 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $4$ 出发，则路线为 $4 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $5$ 出发，则路线为 $5 \to 7 \to 8$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $5,1$。

如果从城市 $6$ 出发，则路线为 $6 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$5,1$。

如果从城市 $7$ 出发，则路线为 $7 \to 9 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $8$ 出发，则路线为 $8 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,0$。

如果从城市 $9$ 出发，则路线为 $9$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $0,0$（旅行一开始就结束了）。

如果从城市 $10$ 出发，则路线为 $10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$0,0$。

从城市 $2$ 或者城市 $4$ 出发小 $\text A$ 行驶的路程总数与小 $\text B$ 行驶的路程总数的比值都最小，但是城市 $2$ 的海拔更高，所以输出第一行为 $2$。

【数据范围与约定】  

对于 $30\%$ 的数据，有$1\le n \le 20,1\le m\le 20$；  
对于$40\%$ 的数据，有$1\le n \le 100,1\le m\le 100$；  
对于 $50\%$ 的数据，有$1\le n \le 100,1\le m\le 1000$；  
对于 $70\%$ 的数据，有$1\le n \le 1000,1\le m\le 10^4$；   
对于 $100\%$ 的数据：$1\le n,m \le 10^5$，$-10^9 \le h_i≤10^9$，$1 \le s_i \le n$，$0 \le x_i \le 10^9$   
数据保证 $h_i$ 互不相同。


## 样例 #1

### 输入

```
4 
2 3 1 4 
3 
4 
1 3 
2 3 
3 3 
4 3
```

### 输出

```
1 
1 1 
2 0 
0 0 
0 0 ```

## 样例 #2

### 输入

```
10 
4 5 6 1 2 3 7 8 9 10 
7 
10 
1 7 
2 7 
3 7 
4 7 
5 7 
6 7 
7 7 
8 7 
9 7 
10 7```

### 输出

```
2 
3 2 
2 4 
2 1 
2 4 
5 1 
5 1 
2 1 
2 0 
0 0 
0 0```

# AI分析结果



### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **问题转换**：将行驶过程抽象为跳跃问题，通过预处理每个城市的下两个目标（小A的次近、小B的最近）转化为倍增模型。
2. **高效预处理**：
   - **双向链表**：按海拔排序后，删除已处理节点保证方向正确，快速找到每个城市的最近和次近城市。
   - **Set/平衡树**：倒序插入城市，利用`upper_bound`和`lower_bound`动态维护后续城市集合。
3. **倍增优化**：定义`f[i][j]`表示从城市`i`出发跳跃`2^j`次后的终点，`da[i][j]`和`db[i][j]`记录对应路程。通过二进制分解快速计算总路程。

#### **贪心策略**
- **局部最优选择**：每次驾驶选择当前最近的（B）或次近的（A）城市，确保每一步的行驶距离最小。
- **全局最优验证**：通过预处理和倍增保证多次跳跃后的总路径最优。

---

### **题解评分（≥4星）**

1. **yangrunze（★★★★★）**
   - **亮点**：详细推导双向链表预处理逻辑，清晰展示倍增状态转移，代码注释丰富。
   - **代码可读性**：结构清晰，变量命名规范，适合教学。
   - **优化**：`O(n log n)`预处理，`O(log x)`查询。

2. **shadow__（★★★★☆）**
   - **亮点**：简洁的Set实现预处理，适合熟悉STL的读者。
   - **不足**：链表删除逻辑未详细展开，对新手不够友好。

3. **star_fish（★★★★☆）**
   - **亮点**：优先队列优化链表操作，代码完整。
   - **不足**：预处理部分稍显复杂，需仔细验证边界条件。

---

### **最优思路与技巧提炼**

1. **双向链表预处理**（关键代码）：
   ```cpp
   for (int i = 1; i <= n; i++) {
       int p = pos[i], p1 = h[p].pre, p2 = h[p].nxt;
       // 选择最近城市gb[i]和次近ga[i]
       if (p1存在且更近) gb[i] = h[p1].id;
       else gb[i] = h[p2].id;
       // 删除当前节点，保证后续处理只考虑东侧城市
       del(p);
   }
   ```

2. **倍增状态转移**：
   ```cpp
   for (int j = 1; j <= logn; j++) {
       for (int i = 1; i <= n; i++) {
           f[i][j] = f[f[i][j-1]][j-1]; // 跳跃2^j次终点
           da[i][j] = da[i][j-1] + da[f[i][j-1]][j-1]; // A的路程累加
           db[i][j] = db[i][j-1] + db[f[i][j-1]][j-1]; // B的路程累加
       }
   }
   ```

---

### **同类型题目与算法套路**
- **倍增应用**：P3379（LCA）、P3865（ST表）。
- **贪心+预处理**：P1090（合并果子）、P1080（国王游戏）。

---

### **推荐题目**
1. **P1081 [NOIP2012 提高组] 开车旅行**（本题）
2. **P3295 [SCOI2016] 萌萌哒**（倍增并查集）
3. **P2471 [SCOI2007] 降雨量**（区间查询预处理）

---

### **个人心得摘录**
- **yangrunze**：调试链表时注意前驱/后继的边界条件，避免指针越界。
- **star_fish**：优先队列实现邻域搜索时，需处理重复元素和距离相同的情况。

---

### **可视化与算法演示**
1. **动画设计**：
   - **Canvas绘制**：城市按海拔排序后水平排列，红色标记当前城市，绿色/蓝色箭头表示A/B的选择。
   - **步进控制**：点击按钮逐步展示跳跃过程，显示`da`和`db`的累加值。
   - **复古像素风**：8-bit风格城市图标，跳跃时播放“跳跃音效”，背景音乐循环。

2. **交互示例**：
   ```javascript
   // 伪代码：步进演示跳跃
   function simulate(start, x) {
       let pos = start, totalA = 0, totalB = 0;
       for (let j = 20; j >= 0; j--) {
           if (f[pos][j] && totalA + da[pos][j] + totalB + db[pos][j] <= x) {
               highlight(pos, f[pos][j]); // 高亮当前跳跃
               totalA += da[pos][j];
               totalB += db[pos][j];
               pos = f[pos][j];
               playSound('jump.wav');
           }
       }
   }
   ```

---

### **结论**
- **核心算法**：双向链表预处理 + 倍增优化，将查询复杂度从`O(n)`降至`O(log n)`。
- **实现关键**：正确处理链表删除和倍增状态转移，注意边界条件验证。
- **拓展价值**：此模型可应用于任何需要快速跳跃查询的场景（如LCA、路径压缩）。

---
处理用时：80.88秒
# 题目信息

# 迎接仪式

## 题目描述

LHX 教主要来 X 市指导 OI 学习工作了。为了迎接教主，在一条道路旁，一群“Orz 教主 er”穿着文化衫站在道路两旁迎接教主，每件文化衫上都印着大字。一旁的 Orzer 依次摆出“欢迎欢迎欢迎欢迎……”的大字，但是领队突然发现，另一旁穿着“教”和“主”字文化衫的 Orzer 却不太和谐。

为了简单描述这个不和谐的队列，我们用 `j` 替代“教”，`z` 替代“主”。而一个 `j` 与 `z` 组成的序列则可以描述当前的队列。为了让教主看得尽量舒服，你必须调整队列，使得 `jz` 子串尽量多。每次调整你可以交换任意位置上的两个人，也就是序列中任意位置上的两个字母。而因为教主马上就来了，时间仅够最多做 $K$ 次调整（当然可以调整不满 $K$ 次），所以这个问题交给了你。

## 说明/提示

**【样例说明】**

第 $1$ 次交换位置 $1$ 上的 `z` 和位置 $4$ 上的 `j`，变为 `jzzzj`；

第 $2$ 次交换位置 $4$ 上的 `z` 和位置 $5$ 上的 `j`，变为 `jzzjz`。

最后的串有 $2$ 个 `jz` 子串。

**【数据规模与约定】**

对于 $10 \%$ 的数据，有 $N \le 10$；  
对于 $30 \%$ 的数据，有 $K \le 10$；  
对于 $40 \%$ 的数据，有 $N \le 50$；  
对于 $100 \%$ 的数据，有 $1 \le N \le 500$，$1 \le K \le 100$。

## 样例 #1

### 输入

```
5 2 
zzzjj
```

### 输出

```
2
```

# AI分析结果



### 综合分析与结论

**题目核心**：通过最多 K 次交换，使字符串中 "jz" 子串数量最大化。关键在于动态规划（DP）的状态设计，需跟踪交换次数与当前字符状态。

**核心难点与解决方案**：
1. **状态设计**：必须记录交换的 j 和 z 次数，以及当前字符状态（j/z）。四维 DP `f[i][j][k][l]`（前 i 位，交换 j 次 j，k 次 z，当前字符为 l）是最优解。
2. **转移方程**：根据当前字符是否为 j/z 分情况讨论，判断是否需要交换并更新计数。
3. **初始化与边界处理**：初始状态需正确设置，交换次数必须平衡（j=k）。

**贪心策略的局限性**：本题无法通过贪心直接解决，因每次交换影响后续状态，需全局最优的 DP 方法。

---

### 题解清单（≥4星）

1. **gorokokoro（5星）**  
   **亮点**：
   - 四维状态设计，避免漏算后续可能的 jz 组合。
   - 初始化严谨，正确处理边界条件。
   - 代码清晰，逻辑严密，解决了常见题解的漏洞。

2. **hzoi_liuchang（4.5星）**  
   **亮点**：
   - 状态转移方程详细推导，分字符类型讨论。
   - 代码简洁，注释明确，适合理解基础思路。

3. **lichenfan（4星）**  
   **亮点**：
   - 状态定义直观，代码可读性强。
   - 核心转移逻辑集中，便于调试。

---

### 最优思路与技巧提炼

**关键思路**：
1. **四维状态设计**：`f[i][j][k][l]` 跟踪前 i 位、交换次数 j/k、当前字符状态。
2. **交换次数平衡**：最终答案需取 `j=k` 的情况，保证交换合法性。
3. **状态转移分情况**：
   - **当前字符为 j**：不交换则继承前状态；交换则消耗一次 j→z。
   - **当前字符为 z**：不交换可能新增 jz；交换则消耗 z→j。

**代码片段**（gorokokoro 核心逻辑）：
```cpp
for(i = 1; i <= n; i++)
    for(j = 0; j <= m; j++)
        for(k = 0; k <= m; k++) {
            // 当前字符为原始状态
            f[i][j][k][a[i]] = max(f[i-1][j][k][0] + a[i], f[i-1][j][k][1]);
            if(a[i]) { // 原字符为 z，尝试改为 j
                if(k) // 消耗一次 z→j
                    f[i][j][k][0] = max(f[i-1][j][k-1][0], f[i-1][j][k-1][1]);
            } else { // 原字符为 j，尝试改为 z
                if(j) // 消耗一次 j→z
                    f[i][j][k][1] = max(f[i-1][j-1][k][0] + 1, f[i-1][j-1][k][1]);
            }
        }
```

---

### 同类型题目推荐

1. **P1091 合唱队形**（动态规划，状态设计）
2. **P1156 垃圾陷阱**（多维状态 DP，条件转移）
3. **P1273 有线电视网**（树形 DP，资源分配）

---

### 可视化与算法演示

**动态规划状态转移动画**：
1. **网格绘制**：用 Canvas 绘制二维网格，横轴为字符位置，纵轴为交换次数，颜色区分当前字符（j/z）。
2. **状态更新高亮**：当前处理的字符位置高亮，箭头表示状态转移路径。
3. **计数显示**：实时显示当前最大 jz 数量，交换次数变化。

**复古游戏化设计**：
- **8-bit 像素风格**：字符显示为像素块，交换时播放经典音效。
- **自动演示模式**：逐步展示 DP 状态填充，速度可调。
- **关卡积分**：每正确填充一个状态得 10 分，错误操作扣分。

---

### 核心代码实现（gorokokoro）

```cpp
#include <iostream>
#include <algorithm>
#include <climits>
#define N 520
#define K 120
using namespace std;

char s[N];
int a[N], f[N][K][K][2];

int main() {
    int n, m; cin >> n >> m >> s;
    for(int i = 1; i <= n; i++) a[i] = s[i-1] == 'z';

    // 初始化
    fill(&f[0][0][0][0], &f[0][0][0][0] + sizeof(f)/sizeof(int), INT_MIN);
    f[0][0][0][1] = 0;

    for(int i = 1; i <= n; i++)
        for(int j = 0; j <= m; j++)
            for(int k = 0; k <= m; k++) {
                // 不交换的情况
                f[i][j][k][a[i]] = max(f[i-1][j][k][0] + a[i], f[i-1][j][k][1]);
                // 尝试交换
                if(a[i]) { // 原为 z，改为 j
                    if(k) f[i][j][k][0] = max(f[i-1][j][k-1][0], f[i-1][j][k-1][1]);
                } else { // 原为 j，改为 z
                    if(j) f[i][j][k][1] = max(f[i-1][j-1][k][0] + 1, f[i-1][j-1][k][1]);
                }
            }

    int ans = 0;
    for(int i = 0; i <= m; i++)
        ans = max(ans, max(f[n][i][i][0], f[n][i][i][1]));
    cout << ans << endl;
    return 0;
}
```

---

**总结**：四维动态规划是本题的最优解，需细致处理状态转移与边界条件。可视化设计可增强对 DP 状态转移的理解，适合教学与调试。

---
处理用时：94.05秒
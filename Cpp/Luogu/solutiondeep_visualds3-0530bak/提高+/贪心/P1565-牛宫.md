# 题目信息

# 牛宫

## 题目描述

AP 神牛准备给自己盖一座很华丽的矩形宫殿。于是，他看中了一块 $N \times M$ 的矩形空地。

空地中每个格子都有自己的海拔高度 $a_{i,j}$。AP 想让他的宫殿的平均海拔在海平面之上（假设海平面的高度是 0，平均数都会算吧？）。而且，AP 希望他的宫殿尽量大，能够容纳更多的人来膜拜他。请问 AP 的宫殿最后会有多大？


## 说明/提示

对于 $50\%$ 的数据，$N,M \le 100$；

对于 $100 \%$ 的数据，$1 \le N,M \le 200$，$-2\times10^9 \le a_{i,j} \le 16315$。


## 样例 #1

### 输入

```
3 2
4 0
-10 8
-2 -2
```

### 输出

```
4
```

# AI分析结果



### 综合分析与结论

**题目核心**：寻找最大面积的子矩阵，使得总和 > 0。本质是二维最大子矩阵问题的变种，需结合前缀和与贪心策略优化时间复杂度。

**核心难点**：  
1. 二维枚举的高效压缩（如枚举上下边界，转化为一维问题）  
2. 一维问题中快速找到最长有效区间（总和 > 0 且长度最大）

**贪心策略关键**：  
- **前缀和优化**：将二维矩阵压缩为列前缀和，快速计算子矩阵和。  
- **单调性维护**：在一维数组中维护单调递减序列，快速定位最小左端点，使得当前右端点的前缀和差值最大。  
- **动态决策**：枚举右端点时，利用历史最小值或单调栈结构，避免重复计算。

**可视化设计思路**：  
1. **二维枚举阶段**：用像素网格展示矩阵，高亮当前枚举的上下边界。  
2. **一维处理阶段**：横向展示前缀和数组，动态标记当前右端点及维护的最小值位置。  
3. **贪心选择动画**：当发现更小的左端点时触发闪光效果，找到新最大区间时用扩散动画标记。

---

### 题解评分与亮点（≥4星）

#### 1. 作者：zhyh (★★★★☆)  
**亮点**：  
- O(n³) 复杂度，利用单调栈维护前缀和的最优决策点。  
- 构造两个单调序列（递减左端点、递增右端点），双向扫描优化查找。  
**代码片段**：  
```cpp
for(int i=1;i<=r[0];i++){
    while(l[0]>1 && ( l[l[0]]>=r[i] || s[l[l[0]]]<s[r[i]] ))l[0]-=1;
    if(s[l[l[0]]]<s[r[i]])tmp=max(tmp,r[i]-l[l[0]]);
}
```

#### 2. 作者：喝水 (★★★★☆)  
**亮点**：  
- 动态维护最小值，边枚举右端点边更新最大可能长度。  
- 复杂度 O(n³) 且代码简洁，无需复杂数据结构。  
**核心逻辑**：  
```cpp
ll res = 0;
for(int i=x; i<=m; i++){
    res = min(res, t[i-x]); // 维护历史最小值
    if(t[i] > res) return true; // 发现可行区间
}
```

#### 3. 作者：Captain_Paul (★★★★☆)  
**亮点**：  
- 二分答案框架清晰，易于理解。  
- 预处理列前缀和，横向压缩为一维数组后二分最大宽度。  
**代码结构**：  
```cpp
for(int i=1; i<=n; i++)
  for(int j=i; j<=n; j++)
    ans = max(ans, (j-i+1)*getlen()); // 二分计算最大宽度
```

---

### 最优思路提炼

**关键步骤**：  
1. **列前缀和压缩**：预处理每列的前缀和，枚举上下边界 i 和 j，计算该区域每列的总和。  
2. **横向前缀和数组**：将每列的总和转化为横向前缀和数组 s[]。  
3. **贪心维护最小值**：遍历每个右端点 k，维护 s[0..k-len] 的最小值，若 s[k] - min_val > 0，则 len 可行。  
4. **单调栈加速**：用单调栈保存可能的最优左端点，快速跳过无效决策。

**代码实现核心**：  
```cpp
// 枚举上下边界 i,j，处理横向前缀和
vector<ll> t(m+1, 0);
for(int k=1; k<=m; k++) 
    t[k] = t[k-1] + (col_sum[j][k] - col_sum[i-1][k]);

// 维护单调递减栈
stack<int> stk;
stk.push(0);
for(int k=1; k<=m; k++){
    while(!stk.empty() && t[k] < t[stk.top()]) 
        stk.pop();
    max_len = max(max_len, k - stk.top());
    stk.push(k);
}
```

---

### 同类型题目与算法套路

**通用解法**：  
1. **前缀和压缩**：将高维问题压缩为低维。  
2. **单调性优化**：利用单调栈/队列维护决策点的候选集。  
3. **动态最值维护**：边遍历边更新历史极值，避免重复扫描。

**推荐题目**：  
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)  
2. [P1719 寻找最大加权矩形](https://www.luogu.com.cn/problem/P1719)  
3. [P3408 暴雨](https://www.luogu.com.cn/problem/P3408)（二维动态规划与贪心结合）

---

### 可视化与复古游戏化设计

**像素动画方案**：  
1. **网格绘制**：用 Canvas 绘制 N×M 的像素网格，不同海拔用颜色梯度表示（如蓝色负值，红色正值）。  
2. **枚举高亮**：上下边界枚举时，对应行闪烁黄色边框。  
3. **前缀和流动**：横向计算前缀和时，用流动光效从左到右填充。  

**音效设计**：  
- **有效区间发现**：8-bit 上升音效（如 FC 马里奥吃金币）。  
- **最小值更新**：短促“滴”声。  
- **最大面积刷新**：长音阶胜利旋律。  

**交互功能**：  
- **速度调节**：滑块控制枚举速度（1x~10x）。  
- **单步调试**：按空格键逐步执行，观察单调栈变化。  
- **自动演示**：AI 模式自动选择最优上下边界，并展示贪心决策过程。

---

### 个人心得摘录

> **zhyh 的调试经验**：  
> “构造单调序列时需注意相等值的处理，若 s[i] == s[j]，应优先保留更小的下标。”  
>   
> **喝水 的优化顿悟**：  
> “维护历史最小值时，发现只需关注 i-len 前的状态，无需全局扫描。”  
>   
> **Captain_Paul 的踩坑记录**：  
> “二分 check 函数中，初始将 res 设为 0 导致漏解，改为 -INF 后通过。”

---

### 代码实现（核心贪心逻辑）

**O(n³) 单调栈实现**：  
```cpp
long long max_area = 0;
for (int i=1; i<=n; i++) {
    vector<long long> col_sum(m+1, 0);
    for (int j=i; j<=n; j++) {
        for (int k=1; k<=m; k++) 
            col_sum[k] += a[j][k]; // 累加当前行的列和
        vector<long long> s(m+1, 0);
        for (int k=1; k<=m; k++) s[k] = s[k-1] + col_sum[k];
        stack<int> stk; stk.push(0);
        for (int k=1; k<=m; k++) {
            while (!stk.empty() && s[k] <= s[stk.top()]) 
                stk.pop();
            int width = stk.empty() ? k : k - stk.top();
            max_area = max(max_area, (j-i+1LL)*width);
            if (stk.empty()) stk.push(k);
        }
    }
}
cout << max_area;
```

---
处理用时：116.37秒
# 题目信息

# 豪华游轮

## 题目描述

有一条豪华游轮（其实就是条小木船），这种船可以执行 $4$ 种指令：

`right X`：其中 $X$ 是一个 $1$ 到 $719$ 的整数，这个命令使得船顺时针转动 $X$ 度。

`left X`：其中 $X$ 是一个 $1$ 到 $719$ 的整数，这个命令使得船逆时针转动 $X$ 度。

`forward X`：其中 $X$ 是一个整数（$1$ 到 $1000$），使得船向正前方前进 $X$ 的距离。

`backward X`：其中 $X$ 是一个整数（$1$ 到 $1000$），使得船向正后方前进 $X$ 的距离。

随意的写出了 $n$ 个命令，找出一个种排列命令的方法，使得船最终到达的位置距离起点尽可能的远。


## 样例 #1

### 输入

```
3
forward 100
backward 100
left 90```

### 输出

```
141.421356```

# AI分析结果



### 综合分析与结论

**题目核心思路**：  
船的最远距离取决于所有前进（`forward`）和后退（`backward`）的步数总和，以及通过转向指令调整后的方向夹角。最优策略是将所有 `forward` 和 `backward` 的移动集中执行，中间插入一个尽可能接近 180 度的转向角度，使得两者的位移方向相反（最大化总距离）。其余转向指令可在移动后执行，不影响位置。

**贪心策略与动态规划结合**：  
1. **合并移动指令**：将 `forward` 和 `backward` 的步数分别累加为总步数 $a$ 和 $b$。  
2. **处理转向指令**：将 `left X` 转为 $+X$ 度，`right X` 转为 $-X$ 度（等价于 $360-X$ 度的逆时针旋转），构建角度集合。  
3. **01 背包求所有可能角度**：通过动态规划记录所有可能的转向子集和模 360 后的角度值。  
4. **最优角度选择**：在所有可能的子集和中，选择最接近 180 度的角度，应用余弦定理计算最大距离。

**难点与解决**：  
- **排列顺序不影响总和**：转向指令的总和模 360 是固定的，但中间子集的选择影响移动方向。  
- **背包优化**：通过 01 背包处理转向角度，避免枚举所有排列组合，时间复杂度为 $O(n \cdot 360)$。  
- **浮点精度**：角度转弧度时需精确计算，避免因精度丢失导致结果误差。

---

### 题解评分（≥4星）

1. **凯特琳（5星）**  
   - **亮点**：明确四步操作思路，将转向角度预处理为模 360 的正方向，正确使用布尔数组 DP 记录所有可能角度。  
   - **代码可读性**：Pascal 代码清晰，注释较少但逻辑简洁。  
   - **优化**：动态规划仅维护布尔状态，高效且节省空间。

2. **Disillusionment（4.5星）**  
   - **亮点**：直接指出问题的 01 背包本质，代码中使用二维数组记录状态，便于调试。  
   - **实现细节**：处理负角度时通过 `+360*10` 避免负数取模问题。  
   - **改进点**：二维数组可优化为一维滚动数组。

3. **Travis（4星）**  
   - **亮点**：将左右转向统一为逆时针角度，动态规划逻辑清晰，代码附带详细注释。  
   - **实践性**：使用 `setprecision` 控制输出精度，避免浮点误差。  
   - **不足**：未处理角度重复时的合并优化。

---

### 最优思路与代码实现

**核心代码（C++ 动态规划）**  
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, front = 0, back = 0;
    vector<int> angles;
    cin >> n;
    for (int i = 0; i < n; ++i) {
        string s; int x;
        cin >> s >> x;
        if (s == "forward") front += x;
        else if (s == "backward") back += x;
        else if (s == "left") angles.push_back(x % 360);
        else angles.push_back((-x % 360 + 360) % 360);
    }

    vector<bool> dp(360, false);
    dp[0] = true;
    for (int angle : angles) {
        vector<bool> new_dp = dp;
        for (int j = 0; j < 360; ++j) {
            if (dp[j]) {
                int next = (j + angle) % 360;
                new_dp[next] = true;
            }
        }
        dp = new_dp;
    }

    int best_angle = 180;
    for (int j = 0; j < 360; ++j) {
        if (dp[j]) {
            best_angle = min(best_angle, abs(j - 180));
        }
    }

    double rad = best_angle * M_PI / 180;
    double ans = sqrt(front*front + back*back - 2*front*back*cos(rad));
    printf("%.6f\n", ans);
    return 0;
}
```

**关键步骤解释**：  
1. **预处理转向**：将 `right X` 转为逆时针等效角度。  
2. **动态规划记录可达角度**：`dp[j]` 表示是否可以通过部分转向指令得到总角度 $j$。  
3. **寻找最优角度**：在所有可达角度中，选择离 180 度最近的。  
4. **余弦定理计算距离**：公式为 $\sqrt{a^2 + b^2 - 2ab \cos(\theta)}$，其中 $\theta$ 为最优角度与 180 度的差。

---

### 相似题目与扩展

1. **洛谷 P2625 [蓝桥杯]多米诺骨牌**  
   - 双向背包问题，记录差值的最小绝对值。  
2. **LeetCode 494. 目标和**  
   - 通过动态规划寻找子集和，与目标值的最近距离。  
3. **Codeforces 837D. Round Subset**  
   - 多维背包问题，优化尾随零的数量。

---

### 可视化与游戏化设计

**复古像素动画设计**：  
1. **Canvas 绘制**：  
   - 使用网格表示角度范围（0-359），高亮当前动态规划处理的角度。  
   - 移动指令以像素块表示，前进/后退方向用箭头指示。  
2. **音效交互**：  
   - **选择角度**：播放 8-bit 点击音效。  
   - **找到最优解**：播放胜利音效，背景音乐循环。  
3. **自动演示模式**：  
   - 动态规划过程逐步展开，AI 自动选择角度，用户可暂停观察。  

**交互面板功能**：  
- **步进控制**：单步执行动态规划，观察角度可达性变化。  
- **参数调节**：调整转向角度或移动步数，实时更新结果。  

---

### 总结

本题通过贪心策略将移动指令集中处理，结合 01 背包动态规划求最优转向角度，有效简化了排列顺序的复杂性。关键点在于将指令顺序问题转化为角度子集和的最优化问题，动态规划记录所有可能状态。可视化设计可直观展示角度选择与距离计算的关系，增强理解。

---
处理用时：287.42秒
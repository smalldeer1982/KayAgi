# 题目信息

# [NOIP 2015 普及组] 推销员

## 题目背景

NOIP2015 普及组 T4

## 题目描述

阿明是一名推销员，他奉命到螺丝街推销他们公司的产品。螺丝街是一条死胡同，出口与入口是同一个，街道的一侧是围墙，另一侧是住户。螺丝街一共有 $N$ 家住户，第 $i$ 家住户到入口的距离为 $S_i$ 米。由于同一栋房子里可以有多家住户，所以可能有多家住户与入口的距离相等。阿明会从入口进入，依次向螺丝街的 $X$ 家住户推销产品，然后再原路走出去。

阿明每走 $1$ 米就会积累 $1$ 点疲劳值，向第 $i$ 家住户推销产品会积累 $A_i$ 点疲劳值。阿明是工作狂，他想知道，对于不同的 $X$，在不走多余的路的前提下，他最多可以积累多少点疲劳值。


## 说明/提示

**输入输出样例 1 说明**

$X=1$：向住户 $5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $5$，总疲劳值为 $15$。

$X=2$：向住户 $4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $4+5$，总疲劳值为 $5+5+4+5=19$。

$X=3$：向住户 $3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值 $3+4+5$，总疲劳值为 $5+5+3+4+5=22$。

$X=4$：向住户 $2,3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值 $2+3+4+5$，总疲劳值 $5+5+2+3+4+5=24$。

$X=5$：向住户 $1,2,3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值 $1+2+3+4+5$，总疲劳值 $5+5+1+2+3+4+5=25$。


**输入输出样例 2 说明**

$X=1$：向住户 $4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $4$，总疲劳值 $4+4+4=12$。

$X=2$：向住户 $1,4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $5+4$，总疲劳值 $4+4+5+4=17$。

$X=3$：向住户 $1,2,4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $5+4+4$，总疲劳值 $4+4+5+4+4=21$。

$X=4$：向住户 $1,2,3,4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $5+4+3+4$，总疲劳值 $4+4+5+4+3+4=24$。或者向住户 $1,2,4,5$推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $5+4+4+1$，总疲劳值 $5+5+5+4+4+1=24$。

$X=5$：向住户 $1,2,3,4,5$ 推销，往返走路的疲劳值为$5+5$，推销的疲劳值为 $5+4+3+4+1$，总疲劳值 $5+5+5+4+3+4+1=27$。

**数据范围**

对于 $20\%$ 的数据，$1 \le N \le20$；  
对于 $40\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1 \le N \le 1000$；  
对于 $100\%$ 的数据，$1 \le N \le 100000$。


## 样例 #1

### 输入

```
5
1 2 3 4 5
1 2 3 4 5```

### 输出

```
15
19
22
24
25```

## 样例 #2

### 输入

```
5
1 2 2 4 5
5 4 3 4 1```

### 输出

```
12
17
21
24
27```

# AI分析结果



### 【综合分析与结论】

**核心思路**：  
所有题解均围绕贪心策略展开，核心矛盾在于平衡疲劳值（A）与路程（S）的取舍。主流解法通过排序+前缀/后缀预处理实现高效计算，时间复杂度 O(n) 或 O(n log n)。

**关键贪心策略**：  
1. 按疲劳值降序排序，取前 X 大的 A 值之和 + 前 X 项最大 S×2（常规情况）
2. 舍弃第 X 小的 A 值，换入后方最大的 (A+2S) 值（优化情况）

**解决难点**：  
- 证明只需替换最小的 A 值即可覆盖最优情况（反证法：替换多个会导致 A 总和下降更快）
- 通过预处理前缀和、前最大值、后最大值实现 O(1) 查询

**可视化设计**：  
- **像素动画**：横向排列住户，已选元素高亮为黄色，当前候选区（后缀）用红色框标记
- **步进演示**：展示每次选择时两种情况的数值对比，动态更新前缀和与后缀最大值
- **音效提示**：正确选择时播放 "coin" 音效，切换策略时播放 "select" 音效

---

### 【题解清单 (≥4星)】

1. **Rainy7 / Walrus 题解 (⭐⭐⭐⭐⭐)**  
   - **亮点**：  
     - 排序后前缀和+后缀 max 预处理，O(n) 时间复杂度  
     - 代码极简（20行内），可读性强  
     - 包含关键公式推导 `max(sum[X]+2*maxS, sum[X-1]+max(A+2S))`  

2. **qhr2023 题解 (⭐⭐⭐⭐)**  
   - **亮点**：  
     - 动态维护最大 S 值，避免重复计算  
     - 利用结构体排序简化逻辑  

3. **XCDRF_ 题解 (⭐⭐⭐⭐)**  
   - **亮点**：  
     - 优先队列维护两种选择（增 S 或增 A）  
     - 适合教学贪心与堆的结合使用  

---

### 【最优代码实现】

**核心逻辑**：排序后预处理前后缀，每次取两种情况的 max

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5;
struct Node{int s,a;} v[N];
int n,sum[N],pre[N],suf[N];

int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>v[i].s;
    for(int i=1;i<=n;i++) cin>>v[i].a;
    sort(v+1,v+n+1,[](Node& a,Node& b){return a.a>b.a;});
    
    for(int i=1;i<=n;i++){
        sum[i]=sum[i-1]+v[i].a;
        pre[i]=max(pre[i-1],v[i].s*2);
    }
    for(int i=n;i>=1;i--) 
        suf[i]=max(suf[i+1],v[i].s*2+v[i].a);
    
    for(int i=1;i<=n;i++)
        cout<<max(sum[i]+pre[i], sum[i-1]+suf[i])<<endl;
}
```

---

### 【同类型题目推荐】

1. P1090 [NOIP2004 提高组] 合并果子（贪心+优先队列）  
2. P2240 【深基12.例1】部分背包问题（性价比贪心）  
3. P1233 木棍加工（二维偏序+贪心）

---

### 【可视化设计示例】

**HTML/JS 核心片段**：  
```html
<canvas id="canvas" width="800" height="200"></canvas>
<script>
const houses = sortedData; // 已排序数据
let selected = [], maxS = 0;

function draw(){
    ctx.clearRect(0,0,800,200);
    houses.forEach((h,i) => {
        // 绘制住户方块，已选则黄色，候选后缀红色边框
        if(selected.includes(i)) ctx.fillStyle='#ff0';
        else if(i > currentX) ctx.strokeStyle='#f00';
        // 显示当前两种情况的数值对比
    });
}
// 音效触发
function playSound(type){
    const sfx = {select: '8bit_beep.mp3', coin: '8bit_coin.mp3'};
    new Audio(sfx[type]).play();
}
</script>
```

**交互特性**：  
- 方向键控制选择步进  
- 按空格切换贪心策略展示  
- 底部实时显示 sum[X] 与 suf[i] 的数值变化

---

### 【关键学习点】

1. **贪心选择证明**：通过替换单个元素的最优性推导全局最优  
2. **预处理技巧**：前缀和与前/后缀最大值的高效维护  
3. **代码简化**：利用结构体排序与 STL 减少代码量

---
处理用时：81.48秒
# 题目信息

# [APIO2009] 会议中心

## 题目描述

Siruseri 政府建造了一座新的会议中心。许多公司对租借会议中心的会堂很 感兴趣，他们希望能够在里面举行会议。

对于一个客户而言，仅当在开会时能够独自占用整个会堂，他才会租借会堂。 会议中心的销售主管认为：最好的策略应该是将会堂租借给尽可能多的客户。

显 然，有可能存在不止一种满足要求的策略。 例如下面的例子。总共有 4 个公司。他们对租借会堂发出了请求，并提出了 他们所需占用会堂的起止日期（如下表所示）。

```cpp
       开始日期 结束日期 
 公司1    4        9 
 公司2    9        11 
 公司3    13       19 
 公司4    10       17 
```
上例中，最多将会堂租借给两家公司。租借策略分别是租给公司 1 和公司 3， 或是公司 2 和公司 3，也可以是公司 1 和公司 4。注意会议中心一天最多租借给 一个公司，所以公司 1 和公司 2 不能同时租借会议中心，因为他们在第九天重合 了。

销售主管为了公平起见，决定按照如下的程序来确定选择何种租借策略：首 先，将租借给客户数量最多的策略作为候选，将所有的公司按照他们发出请求的 顺序编号。对于候选策略，将策略中的每家公司的编号按升序排列。最后，选出 其中字典序最小1的候选策略作为最终的策略。

例中，会堂最终将被租借给公司 1 和公司 3：3 个候选策略是 {(1,3),(2,3),(1,4)}。而在字典序中(1,3)<(1,4)<(2,3)。 你的任务是帮助销售主管确定应该将会堂租借给哪些公司。


## 说明/提示

对于 50%的输入，N≤3000。

在所有输入中，N≤200000。


## 样例 #1

### 输入

```
4 
4 9
9 11 
13 19 
10 17```

### 输出

```
2
1 3```

# AI分析结果



### 综合分析与结论

**核心思路**：  
本题需解决两个问题：①最大不相交线段数（经典贪心问题）；②在最大解中选字典序最小的集合。难点在于第二问的贪心验证策略，需确保插入当前线段后不影响总数。

**贪心策略关键**：  
1. **预处理倍增数组**：计算每个线段后续的最优选择，快速查询区间内的最大线段数。
2. **字典序验证**：按编号从小到大尝试插入线段，检查插入后剩余区间的最大线段数是否满足 `原数量 = 左子区间 + 右子区间 + 1`。
3. **离散化与数据结构**：离散化端点，使用 `set` 维护已选线段的前驱后继，高效查询区间边界。

**难点与解决**：  
- **时间效率**：通过倍增预处理将查询复杂度降至 O(log n)。
- **正确性验证**：插入线段时需分割区间并验证子区间总和，保证全局最优。

**可视化设计**：  
- **动画方案**：  
  - **颜色标记**：当前处理线段（红色）、已选线段（绿色）、候选区间（蓝色）。  
  - **步进控制**：单步执行插入验证，展示分割后的左右子区间。  
  - **验证过程**：高亮前驱和后继线段，动态计算子区间容量。  
- **复古像素风格**：  
  - **Canvas 网格**：线段以不同颜色块表示，端点坐标映射到像素位置。  
  - **音效提示**：成功插入（清脆音效），冲突（低沉音效），背景 8-bit 音乐循环。  
  - **自动演示**：AI 按编号顺序尝试插入，展示决策流程。

---

### 题解清单（评分≥4星）

1. **jjsnam（★★★★★）**  
   - **亮点**：  
     - 详细讲解倍增预处理与贪心验证的结合，代码规范易读。  
     - 使用 `set` 维护区间边界，离散化处理高效。  
   - **关键代码**：  
     ```cpp
     int getMx(int st, int r) {
         int res = 0;
         for (int k = Log2; k >= 0; k--) {
             if (seg[ne[st][k]].r <= r) {
                 res += (1 << k), st = ne[st][k];
             }
         }
         return res;
     }
     ```

2. **kczno1（★★★★☆）**  
   - **亮点**：  
     - 简洁的线段树实现，动态维护字典序最优路径。  
     - 通过树状数组优化 DP 转移，兼顾效率与代码简洁性。  
   - **关键代码**：  
     ```cpp
     int cmpPath(int u, int v) {
         int x = n+1, y = n+1;
         for (int i=20; i>=0; --i) {
             if (fa[i][u] != fa[i][v]) {
                 x = min(x, g[i][u]);
                 y = min(y, g[i][v]);
                 u = fa[i][u], v = fa[i][v];
             }
         }
         return x < y;
     }
     ```

3. **喵仔牛奶（★★★★☆）**  
   - **亮点**：  
     - 使用珂朵莉树维护区间，动态分割验证。  
     - 代码结构清晰，注释详细，适合学习实现细节。  
   - **关键代码**：  
     ```cpp
     bool ok(int x) {
         int le = *prev(s.lower_bound(l[x])), ri = *s.lower_bound(r[x]);
         return (get(le+1, l[x]-1) + get(r[x]+1, ri-1) + 1 == get(le+1, ri-1));
     }
     ```

---

### 最优思路与技巧提炼

**核心贪心策略**：  
1. **预处理倍增数组**：  
   - 按右端点排序后，预处理每个线段跳 2^k 步后的位置，用于快速计算区间容量。  
2. **离散化端点**：  
   - 将线段端点映射到连续整数，减少查询范围。  
3. **set维护边界**：  
   - 插入线段时通过 `upper_bound` 查找前驱和后继，分割区间验证。  

**验证条件**：  
插入线段 [l, r] 后，需满足：  
`原区间容量 = 左子区间容量 + 右子区间容量 + 1`

---

### 同类型题目推荐

1. **P1803 线段覆盖**：基础的最大不相交区间问题。  
2. **P2107 小Z的AK计划**：贪心选择与时间管理。  
3. **P3620 数据备份**：区间选择进阶，需维护最优决策链。

---

### 可视化代码片段（Canvas 示例）

```javascript
// 初始化 Canvas
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const segments = [...]; // 离散化后的线段数据

function drawSegment(seg, color) {
    ctx.fillStyle = color;
    ctx.fillRect(seg.l * 10, 50, (seg.r - seg.l) * 10, 20);
}

function animateInsert(seg) {
    // 高亮当前线段
    drawSegment(seg, '#FF0000');
    // 查找前驱和后继
    const prev = findPrev(seg.l);
    const next = findNext(seg.r);
    // 绘制分割区间
    drawSegment(prev, '#00FF00');
    drawSegment(next, '#0000FF');
    // 验证并播放音效
    if (validate(prev, seg, next)) {
        playSound('success.mp3');
        addToSet(seg);
    } else {
        playSound('fail.mp3');
    }
}
```

---

### 个人心得摘录

- **jjsnam**：  
  > “调了一天终于弄懂，题解区太乱，高赞只讲结果。必须详细拆解每一步的验证逻辑。”  
  - **启示**：清晰的步骤拆解和边界处理是解题关键。

- **lokiii**：  
  > “手动二分暴露出 DP 维护字典序的复杂性，最终回归贪心更高效。”  
  - **启示**：复杂问题需优先考虑贪心可行性，避免过度设计。

---

### 总结

本题通过预处理和贪心验证的结合，高效解决字典序最小问题。核心在于快速计算区间容量与动态维护已选线段边界。可视化设计通过步进验证和复古风格交互，可深化对贪心策略的理解。

---
处理用时：96.80秒
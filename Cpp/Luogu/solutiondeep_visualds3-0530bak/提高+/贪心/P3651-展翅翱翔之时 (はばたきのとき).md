# 题目信息

# 展翅翱翔之时 (はばたきのとき)

## 题目背景

**船が往くよミライへ旅立とう**

**船只启航 朝未来展开旅途**

**青い空笑ってる（なにがしたい?）**

**湛蓝天空露出微笑（想做些什么?）**

**ヒカリになろうミライを照らしたい**

**化作光芒吧 想就此照亮未来**

**輝きは心からあふれ出してもっと先の景色望むんだ**

**光辉自内心满溢而出 愿能望见更加前方的景色**

**Ah!やっと手にしたミライチケットかざして…！**

**Ah!挥舞起终于得手的未来门票…！**



 ![](https://cdn.luogu.com.cn/upload/pic/4529.png) 

我们Aqours，终于闪闪发亮了！


2月25和26日，将是我们登上横滨ARENA演唱的日子！


而且，还要在全日本、甚至全世界的好多影院进行转播呢！


转播好像还是通过中继卫星传输的呢！


未来ずら！


## 题目描述

不过，好像中继卫星上，出了一些问题呢……

我们的中继卫星一共有 $N$ 颗，编号成 $1$ 到 $N$。不过，好像一个中继卫星可以且仅可以单向地从另一颗中继卫星那儿接收数据。

第 $i$ 颗卫星现在已经被设定到了从第 $A_i$ 颗卫星（称为接收源）那儿接受数据。

不过这些中继卫星的接收源是可以修改的，只不过每次修改要花一定的资金呢。

听说要达成中继的话，这些卫星之间必须**两两之间能够互相（直接或间接）通信**才行啊。

虽然鞠莉家里很有钱，可是这么大的花费，也得提前准备一下呢。

所以，你能帮我们算算这样子一共最少要花多少钱吗？

## 说明/提示

### 数据范围及约定

- 对于 $10\%$ 的数据，满足 $N \le 10$。
- 对于 $40\%$ 的数据，满足 $N \le 15$。
- 对于 $70\%$ 的数据，满足 $N \le 3000$。
- 对于 $100\%$ 的数据，满足 $2 \le N \le 100000,1 \le C_i \le 10^9$。

### 以下是彩蛋

事实上 LoveLive 的直播卫星中继只有一颗星，而且永远都是不加密的。

导致只要有一个卫星锅就可以在家偷偷看直播，也就是传说中的卫星源。

lin_toto：万代南梦宫都把浅水湾给买了，居然只有回放，只好跑到香港 the sky 去看 + 手动滑稽。

至于为什么看转播，eplus 表示 LoveLive 系列演唱会的票大家尽管抽选尽管抢，买得到算我输。

于是 lin_toto 在去年 μ's Final LoveLive 的时候拿肉鸡把 eplus 搞趴下了，然后就买到了。

于是今年 eplus 连抢票都不让抢了，全抽选，抽得到算我输。

然后 lin_toto 就去看转播了。


## 样例 #1

### 输入

```
4
2 2
1 6
1 3
3 1```

### 输出

```
5```

# AI分析结果



### 综合分析与结论

**题目核心**：将基环树森林通过最小代价修改为强连通图（单个环）。关键在于处理树部分的最优保留策略与环上的动态断边选择。

**核心难点**：
1. **基环树分解**：分离环与树结构，树需转为外向链，环需断开成链后重组。
2. **贪心策略**：树部分保留最大权值的子边（最小化删除代价），环上通过DP选择最优断点。
3. **复杂度控制**：需线性时间处理10^5级别数据。

**贪心策略可视化设计**：
- **树处理动画**：用绿色高亮每个节点保留的最大边，红色显示被删边，展示累计代价。
- **环处理动画**：用环形布局展示节点，动态显示DP过程（cut0/cut1状态转移），黄色标记当前决策点，紫色高亮最终断边位置。

---

### 题解评分与亮点

1. **whiteqwq（★★★★★）**
   - **亮点**：完整分解基环树结构，清晰分步处理树与环，代码可读性强。
   - **关键代码**：DFS保留最大边，环上双状态DP。

2. **kradcigam（★★★★☆）**
   - **亮点**：极简拓扑排序预处理，巧妙处理环上断边，代码效率极高。
   - **关键代码**：队列处理入度为0节点，排序后贪心断环。

3. **z7z_Eta（★★★★☆）**
   - **亮点**：显式维护重儿子链，环处理与whiteqwq类似，代码注释丰富。
   - **关键代码**：find_loop找环，贪心保留最大子边。

---

### 最优思路提炼

1. **树部分贪心**：对每个节点保留最大权值的出边（`out[x] = max_edge`），其余删除。
2. **环动态规划**：维护两种状态（是否已断环），转移方程：
   ```
   cut1 = min( min(cut0, cut1) + 断环边, cut1 + 断链边 )
   cut0 += 断链边
   ```
3. **特判全环**：若整图是单环则直接输出0。

---

### 同类型题目与套路

1. **基环树通用解法**：
   - 找环（两次标记法）
   - 树DP/贪心处理外向链
   - 环上DP或数学计算最优解

2. **类似题目**：
   - P2607 [ZJOI2008]骑士（基环树DP）
   - P1453 城市环路（基环树拆环处理）
   - P4381 [IOI2008]Island（基环森林直径）

---

### 推荐练习题
1. **P2607** - 基环树DP经典题
2. **P3533** - 基环树哈希判环
3. **P6258** - 基环树最短路变形

---

### 核心代码实现

**贪心保留最大边（whiteqwq版）**：
```cpp
void dfs(long long x, long long last) {
    for (auto y : edges[x]) {
        if (y == last || on_loop[y]) continue;
        dfs(y, x);
        if (cost[best_edge[x]] > cost[y]) 
            ans += cost[y];
        else 
            ans += cost[best_edge[x]], best_edge[x] = y;
    }
}
```

**环上DP处理（kradcigam版）**：
```cpp
for(int i=1; i<=m; i++){
    cut1 = min( min(cut0, cut1) + loop_edge_cost[i], 
               cut1 + chain_edge_cost[i] );
    cut0 += chain_edge_cost[i];
}
ans += cut1;
```

---

### 可视化设计（复古像素版）

**动画要素**：
1. **像素风格基环树**：
   - 节点：8x8像素方块，环节点用黄色，树节点用绿色
   - 边：箭头线段，保留边用蓝色，删除边用红色闪烁

2. **交互控制**：
   ```html
   <div id="ctrl">
     <button onclick="step()">▶ Next Step</button>
     <input type="range" id="speed" min="100" max="1000">
   </div>
   <canvas id="game" width="640" height="480"></canvas>
   ```

3. **音效设计**：
   - 保留边：NES风格"叮"声（三角波）
   - 删除边："爆炸"音效（方波+衰减）
   - 完成阶段：经典过关音效

**动画逻辑**：
```javascript
function drawTree() {
    // 绘制基环树结构
    ctx.fillStyle = '#00FF00'; // 树节点绿色
    nodes.forEach(n => {
        if (n.onLoop) ctx.fillStyle = '#FFFF00'; // 环节点黄色
        ctx.fillRect(n.x*32, n.y*32, 8, 8);
    });
}

function step() {
    // 贪心选择过程
    let node = getNextNode();
    highlight(node); // 黄色闪烁
    playSound('select.wav');
    updateEdges(node); // 红蓝边更新
}
```

---

### 个人心得摘录

> **whiteqwq调试经验**："环断开时必须强制至少断一次环边，否则会形成非法环结构。为此需要维护cut0/cut1两种状态，这是本题最易错点。"

> **z7z_Eta注释**："想象's'形结构，必须断中间连接点才能展开为链。这个几何直觉帮助理解环处理策略。"

> **kradcigam优化**："直接预处理入度为0节点，避免递归爆栈。这是处理大规模数据的关键优化。"

---

通过整合各题解精华，结合动态规划与贪心策略，配合直观的可视化设计，可高效解决此类基环树问题。核心在于分离树与环的处理，并在环上做出最优断边决策。

---
处理用时：85.38秒
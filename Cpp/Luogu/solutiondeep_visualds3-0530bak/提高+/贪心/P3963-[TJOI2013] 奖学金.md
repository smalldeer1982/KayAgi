# 题目信息

# [TJOI2013] 奖学金

## 题目背景

小张最近发表了一篇论文，有一个神秘人物要给小张学院发奖学金。

## 题目描述

小张学院有 $c$ 名学生，第 $i$ 名学生的成绩为 $a_i$，要获得的奖学金金额为 $b_i$。  
要从这 $c$ 名学生中挑出 $n$ 名学生发奖学金。这个神秘人物爱好奇特，他希望得到奖学金的同学的**成绩**的**中位数**尽可能大，但同时，他们的**奖学金总额**不能超过 $f$。


## 说明/提示

### 样例 1 解释

选择成绩为 $5$，$35$，$50$ 的三名同学，奖金总额为 $18 + 30 + 21 = 69$。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10^3$，$c \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $3 \leq n  \leq 10^5$，$n \leq c \leq 2 \times 10^5$，$0 \leq f \leq 2\times 10^9$，$0 \leq a_i \leq 2 \times 10^9$，$0 \leq b_i \leq 10^5$。

## 样例 #1

### 输入

```
3 5 70
30 25
50 21
20 20
5 18
35 30
```

### 输出

```
35```

## 样例 #2

### 输入

```
5 6 9
4 0
4 1
6 3
8 0
10 4
10 5
```

### 输出

```
6```

# AI分析结果



### 综合分析与结论

#### 核心思路与难点
题目要求选出n名学生，使成绩中位数最大且总奖学金≤f。核心思路为：
1. **排序策略**：将学生按成绩升序排列，枚举每个可能的中位数位置i
2. **贪心选择**：在i的左侧选k=(n-1)/2个奖学金最小的学生，右侧同理
3. **快速计算**：高效维护前k小的奖学金总和，常用优先队列或主席树

**解决难点**在于如何高效维护动态区间前k小和：
- **优先队列法**：O(c logk)时间复杂度，空间O(c)，通过维护大根堆动态替换较大元素
- **主席树法**：O(c logm)时间（m为离散化范围），适合多次区间查询但实现复杂

#### 贪心策略可视化设计
1. **动画流程**：
   - 排序后的学生列表水平排列，成绩从左到右递增
   - 滑动指针枚举中位数i，高亮当前候选（红色）
   - 左右两侧动态绘制堆结构，绿色为被选中的奖学金
   - 实时显示当前总奖学金和f的对比

2. **复古像素风格**：
   - 使用Canvas绘制8-bit风格学生条形图，高度表示成绩，颜色深浅表示奖学金
   - 堆结构用像素方块堆叠表示，替换元素时播放经典"blip"音效
   - 当总金额超过f时，屏幕抖动+警报音效，符合游戏化设计

---

### 题解评分（≥4星）

1. **胖头鱼学员（★★★★☆）**
   - 核心亮点：双优先队列预处理左右最小和，代码简洁高效
   - 代码可读性：结构清晰，变量命名规范
   - 优化程度：O(c logk)时间，无需离散化
   ```cpp
   // 预处理左侧最小和
   priority_queue<int> q;
   for(int i=1;i<=c;i++){
       if(i<=k) q.push(a[i]), sum += a[i];
       else if(a[i]<q.top()){
           sum += a[i]-q.top(); 
           q.pop(); q.push(a[i]);
       }
       f[i] = sum;
   }
   ```

2. **ycyaw（★★★★☆）**
   - 核心亮点：正反扫描+堆，直接输出最大可行解
   - 实践性：从后往前枚举，找到即终止
   - 个人心得：强调枚举顺序优化，减少无效计算

3. **ix35（★★★★☆）**
   - 亮点：权值线段树动态维护区间和
   - 创新点：离散化处理奖学金值域
   ```cpp
   void add(int p,int pos){ // 动态插入节点
       if(l==r) { sum[p]++; return; }
       if(pos<=mid) add(lson,pos);
       else add(rson,pos);
       sum[p] = sum[lson] + sum[rson];
   }
   ```

---

### 最优思路提炼

**贪心选择策略**：
1. **排序定中位**：成绩升序排列，仅需保证i左右有k个元素
2. **双堆维护**：
   - 左侧维护大根堆存最小的k个元素
   - 新元素比堆顶小则替换，保证堆内始终为当前最小k个
3. **前缀和预计算**：预处理左右最小和数组，枚举时O(1)查询

**关键代码片段**：
```cpp
sort(a+1, a+c+1, cmp); // 按成绩排序

// 预处理左侧
priority_queue<int> leftHeap;
for(int i=1; i<=c; i++){
    if(i <= k) {
        leftHeap.push(a[i].b);
        sum += a[i].b;
    } else if(a[i].b < leftHeap.top()){
        sum += a[i].b - leftHeap.top();
        leftHeap.pop();
        leftHeap.push(a[i].b);
    }
    leftSum[i] = (i > k) ? sum : INF;
}

// 枚举中位数
for(int i=c-k; i>k; i--){
    if(leftSum[i-1] + rightSum[i+1] + a[i].b <= f){
        cout << a[i].grade;
        return 0;
    }
}
```

---

### 相似题目推荐
1. **P1168 中位数** - 动态维护中位数
2. **P1801 黑匣子** - 动态查询第K小
3. **P1090 合并果子** - 贪心+优先队列

---

### 可视化代码示例（Canvas动画节选）
```javascript
// 绘制学生条形图
function drawStudents() {
  ctx.fillStyle = "#8B0000"; // 暗红色背景
  students.forEach((s, i) => {
    const h = s.grade / maxGrade * canvas.height;
    ctx.fillRect(i*barWidth, canvas.height-h, barWidth-1, h);
    
    // 高亮当前中位数
    if(i === currentIdx) {
      ctx.fillStyle = "#FFD700"; // 金色
      ctx.fillRect(i*barWidth, canvas.height-h, barWidth-1, 5);
    }
  });
}

// 堆元素替换动画
function heapAnimation(oldVal, newVal) {
  particles.push({
    x: currentHeapPos,
    y: 50,
    text: `-${oldVal} +${newVal}`,
    alpha: 1.0
  });
  playSound("swap"); // 播放交换音效
}
```

---

### 个人心得摘录
1. **渡墨残殇**：  
   *"叶子节点必须返回k*b[l]，否则重复元素会计算错误，调试两天才发现的细节"*  
   → 离散化后相同值需乘数量

2. **FutaRimeWoawaSete**：  
   *"query返回叶子时应乘rank，否则像rz直接返回val"*  
   → 线段树查询需考虑重复元素

---

### 算法比较
| 方法       | 时间复杂度 | 空间复杂度 | 实现难度 | 适用场景       |
|------------|------------|------------|----------|----------------|
| 优先队列   | O(c logk)  | O(c)       | 易       | 单次查询       |
| 主席树     | O(c logm)  | O(c logm)  | 难       | 多区间查询     |
| 权值线段树 | O(c logm)  | O(m)       | 中等     | 值域较小的情况 |

通过可视化可清晰对比堆的动态调整过程与线段树的静态查询差异。

---
处理用时：97.67秒
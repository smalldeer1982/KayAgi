# 题目信息

# [JOISC 2014] 挂饰

## 题目描述

JOI君有N个装在手机上的挂饰，编号为1...N。 JOI君可以将其中的一些装在手机上。

JOI君的挂饰有一些与众不同——其中的一些挂饰附有可以挂其他挂件的挂钩。每个挂件要么直接挂在手机上，要么挂在其他挂件的挂钩上。直接挂在手机上的挂件最多有1个。

此外，每个挂件有一个安装时会获得的喜悦值，用一个整数来表示。如果JOI君很讨厌某个挂饰，那么这个挂饰的喜悦值就是一个负数。

JOI君想要最大化所有挂饰的喜悦值之和。注意不必要将所有的挂钩都挂上挂饰，而且一个都不挂也是可以的。


## 说明/提示

$1\leq N\leq 2000$

$0\leq Ai\leq N(1\leq i\leq N)$

$-10^6\leq Bi\leq 10^6(1\leq i\leq N)$



## 样例 #1

### 输入

```
5
0 4
2 -2
1 -1
0 1
0 3```

### 输出

```
5```

# AI分析结果



---

## 综合分析与结论

### 核心思路与难点
本题本质是 **带容量扩展的 01 背包问题**，核心难点在于挂钩数量会动态变化，需结合 **贪心排序策略** 优化动态规划过程。各题解普遍采用以下思路：
1. **贪心排序**：优先处理挂钩多的挂饰，避免多次转移导致容量不足。
2. **状态设计**：`dp[i][j]` 表示前 i 个物品、剩余 j 个挂钩时的最大喜悦值。
3. **状态转移**：`dp[i][j] = max(不选当前, 选当前后剩余 max(j-a+1,0) 挂钩)`。
4. **边界处理**：初始状态为 `dp[0][1]=0`，其他设为极小值避免非法转移。

### 贪心策略解析
- **排序依据**：按挂钩数降序排列，确保先处理能提供更多挂钩的挂饰，为后续转移创造容量空间。
- **动态规划优化**：通过排序减少无效状态转移，例如避免低挂钩挂饰过早消耗初始容量。

### 可视化设计要点
- **复古像素风格**：挂饰用不同颜色方块表示（挂钩数多→亮色），选择时高亮显示。
- **状态网格**：Canvas 绘制二维网格，纵轴为挂饰序号，横轴为剩余挂钩数，颜色深浅表示喜悦值。
- **音效交互**：选择挂饰时播放上升音调，非法转移时播放警示音。
- **自动演示**：AI 按贪心策略逐步选择挂饰，动态更新网格状态与喜悦值总和。

---

## 题解评分（≥4星）

1. **违规用户名U56916（5星）**
   - **亮点**：清晰的状态转移方程，结构体排序优化，完整处理负数边界。
   - **代码可读性**：结构清晰，注释明确，适合教学演示。
   - **个人心得**：强调排序重要性，避免“多次挂在手机无效”。

2. **空の軌跡（4.5星）**
   - **亮点**：一维数组优化，正/逆序转移区分处理，压缩状态至 4000 范围。
   - **代码简洁性**：高效利用滚动数组，适合高阶学习者。

3. **FreeTimeLove（4星）**
   - **亮点**：将体积转化为负值处理，滚动数组优化，独特初始化思路。
   - **创新性**：负数体积处理方式具有启发性，适合拓展思考。

---

## 最优思路与技巧

### 关键算法步骤
```cpp
sort(w+1, w+n+1, [](auto& x, auto& y){ return x.a > y.a; }); // 挂钩降序排序

memset(dp, 0x80, sizeof(dp)); // 初始化为极小值
dp[0][1] = 0; // 初始状态：0个物品，1个挂钩

for(int i=1; i<=n; i++){
    for(int j=0; j<=n; j++){
        // 不选当前：dp[i][j] = dp[i-1][j]
        // 选当前：剩余挂钩为 max(j - w[i].a, 0) + 1
        int prev_hooks = max(j - w[i].a, 0) + 1;
        dp[i][j] = max(dp[i-1][j], dp[i-1][prev_hooks] + w[i].b);
    }
}
```

### 技巧总结
1. **排序优化**：优先处理高挂钩挂饰，确保每次转移最大化可用容量。
2. **负数处理**：通过 `max(j-a,0)` 避免非法状态，强制挂载到初始位置。
3. **滚动数组**：部分题解使用位运算 (`i&1`) 优化空间至 O(n)。

---

## 同类题目推荐
1. **P1064 金明的预算方案**（依赖背包+分组处理）
2. **P1156 垃圾陷阱**（时间维度动态规划）
3. **P1941 飞扬的小鸟**（多重背包+状态压缩）

---

## 个人心得摘录
- **违规用户名U56916**：  
  *“排序让钩子多的先计算，避免低挂钩多次无效占用初始容量。”*
- **空の軌跡**：  
  *“转移方向决定状态更新顺序，正序逆序需谨慎选择。”*
- **Sin_qwq**：  
  *“初始状态若不设为0，所有转移将基于无穷小，导致计算错误。”*

---

## 可视化算法演示（核心代码）
```javascript
// 示例：Canvas绘制状态网格（伪代码）
function drawGrid(dp) {
    for(let i=0; i<=n; i++) {
        for(let j=0; j<=n; j++) {
            let color = intensity(dp[i][j]); // 根据喜悦值映射颜色
            ctx.fillStyle = color;
            ctx.fillRect(j*cellSize, i*cellSize, cellSize, cellSize);
        }
    }
    // 高亮当前选择
    ctx.strokeStyle = '#FF0000';
    ctx.strokeRect(currentJ*cellSize, currentI*cellSize, cellSize, cellSize);
}

// 音效触发
function playSound(effect) {
    if(effect === 'choose') new Audio('pick.wav').play();
    else if(effect === 'error') new Audio('error.wav').play();
}
```

---

## 复古游戏化设计
- **像素艺术**：挂饰用 16x16 像素图标，挂钩数显现在顶部。
- **自动演示 AI**：每 500ms 执行一步最优转移，动态更新网格与分数。
- **积分系统**：正确转移+10分，连击正确+额外奖励，错误扣分。
- **8-bit 音效**：使用芯片音乐生成器制作符合复古风格的音效。

**交互示例**：  
![复古像素界面](https://via.placeholder.com/400x300?text=Retro+UI+with+Grid+and+Score)  
*说明：左侧为状态网格，右侧显示当前选择与总分，下方控制面板含速度调节与暂停功能。*

---
处理用时：107.60秒
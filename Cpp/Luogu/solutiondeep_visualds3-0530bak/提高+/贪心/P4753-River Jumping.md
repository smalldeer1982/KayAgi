# 题目信息

# River Jumping

## 题目描述

有一条宽度为 $N$ 的河上，小 D 位于坐标为 $0$ 的河岸上，他想到达坐标为 $N$ 的河岸上后再回到坐标为 $0$ 的位置。在到达坐标为 $N$ 的河岸之前小 D 只能向坐标更大的位置跳跃，在到达坐标为 $N$ 的河岸之后小 D 只能向坐标更小的位置跳跃。在河的中间有 $M$ 个岩石，小 D 希望能跳到每个岩石上恰好一次。由于小 D 的跳跃能力太强，小 D 的跳跃长度有个下限 $S$，但没有上限。现在请你判断他是否能够完成他的目标。

## 说明/提示

对于全部数据，保证 $1 \le N,S \le 100000$，$0 \le M < N$，$1 \le w_i < N$。

## 样例 #1

### 输入

```
6 1 3
3```

### 输出

```
YES
1 2 0```

## 样例 #2

### 输入

```
6 2 2
2 4```

### 输出

```
YES
2 3 1 0```

## 样例 #3

### 输入

```
5 2 3
2 3```

### 输出

```
NO```

# AI分析结果



### 综合分析与结论

**核心贪心策略**：  
1. **必要条件验证**：检查首尾岩石与起点/终点的距离 ≥ S，排除无法跳跃的边界情况。
2. **连续三石验证**：若任意三个连续岩石间距 < S，则无法覆盖，直接无解。
3. **双向贪心遍历**：  
   - **正向跳跃**：从起点出发，每次选择最近的满足距离条件的岩石，标记为已访问。  
   - **反向跳跃**：从终点返回，处理剩余岩石，确保每次跳跃距离 ≥ S。  
4. **覆盖验证**：检查所有岩石是否被两次遍历覆盖，否则输出无解。

**难点解决**：  
- **正确性保证**：通过两次遍历的贪心选择，确保所有岩石被严格覆盖，避免漏判。
- **特殊处理**：处理 `m=0`（无岩石）和 `n < S` 等边界情况，确保逻辑完整性。

**可视化设计思路**：  
- **像素风格动画**：岩石以 8-bit 像素块显示，起点/终点用不同颜色标记。
- **步进演示**：正向跳跃时高亮当前岩石（绿色），反向跳跃时高亮（蓝色），动态显示跳跃路径。
- **音效反馈**：跳跃成功时播放清脆音效，无解时播放错误提示音。

---

### 题解清单（评分≥4星）

1. **FlierKing（5星）**  
   - **亮点**：简洁的双向贪心实现，通过两次遍历覆盖所有岩石，代码逻辑清晰。
   - **关键代码**：
     ```cpp
     for (正向遍历) {
         if (a[i] - p >= S) 标记并记录；
     }
     for (反向遍历) {
         if (p - a[i] >= S) 标记并记录；
     }
     ```
   - **个人心得**：“贪心能跳就跳，两次遍历确保覆盖所有可能。”

2. **y2823774827y（4星）**  
   - **亮点**：通过 `f[]` 数组记录已访问状态，严格验证跳跃条件。
   - **关键代码**：
     ```cpp
     for (反向遍历) {
         if (!f[i] && 距离足够) 标记并记录；
     }
     ```
   - **踩坑提醒**：“反向遍历时需注意变量范围，否则会漏判条件。”

3. **Vermouth_1412（4星）**  
   - **亮点**：详细处理边界条件（如 `m=0`），增强代码鲁棒性。
   - **关键代码**：
     ```cpp
     if (m == 0) {
         if (n >= S) 输出特殊解；
     }
     ```

---

### 核心贪心代码实现

**FlierKing 的关键片段**：  
```cpp
// 正向贪心跳跃
int p = 0, cnt = 0;
for (int i = 1; i <= m + 1; i++) {
    if (a[i] - p >= S) {
        f[++cnt] = i;
        p = a[i];
        u[i] = true;
    }
}
// 反向贪心跳跃
p = a[m + 1];
for (int i = m; i >= 0; i--) {
    if (!u[i] && p - a[i] >= S) {
        f[++cnt] = i;
        p = a[i];
        u[i] = true;
    }
}
// 验证覆盖所有点
if (cnt == m + 2) 输出 YES;
```

---

### 类似题目推荐

1. **P1095 守望者的逃离**  
   - **相似点**：分段决策（跑步 vs 魔法），贪心选择最优移动方式。

2. **P5019 铺设道路**  
   - **相似点**：贪心处理区间覆盖，每次操作覆盖连续区域。

3. **P1056 排座椅**  
   - **相似点**：贪心选择最优分割线，最大化通道利用率。

---

### 可视化与游戏化设计

**动画方案**：  
1. **Canvas 绘制**：  
   - 岩石用像素块表示，起点（0）为绿色，终点（N）为红色，中间岩石为黄色。
   - 跳跃路径用线段连接，正向为绿色，反向为蓝色。

2. **交互控制**：  
   - **步进按钮**：手动控制跳跃步骤，观察贪心选择过程。
   - **自动播放**：AI 自动执行跳跃，速度可调节。

3. **音效设计**：  
   - **跳跃成功**：8-bit 上升音效。
   - **无解提示**：低沉错误音效。

**代码片段（JS）**：  
```javascript
// 绘制岩石
function drawRocks(ctx, rocks) {
    rocks.forEach((rock, idx) => {
        ctx.fillStyle = idx === 0 ? '#00FF00' : idx === rocks.length-1 ? '#FF0000' : '#FFFF00';
        ctx.fillRect(rock.x * 10, 100, 10, 10); // 像素风格
    });
}
// 跳跃音效
const jumpSound = new Audio('data:audio/wav;base64,UEsDBBQAAAA...');
```

---

**总结**：通过双向贪心策略严格覆盖所有岩石，结合边界条件验证，确保算法正确性。可视化设计以交互式步进和复古风格增强理解，适用于教学与自测。

---
处理用时：92.67秒
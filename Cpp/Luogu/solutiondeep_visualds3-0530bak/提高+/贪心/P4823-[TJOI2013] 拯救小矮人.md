# 题目信息

# [TJOI2013] 拯救小矮人

## 题目描述

一群小矮人掉进了一个很深的陷阱里，由于太矮爬不上来，于是他们决定搭一个人梯。即：一个小矮人站在另一小矮人的 肩膀上，直到最顶端的小矮人伸直胳膊可以碰到陷阱口。

对于每一个小矮人，我们知道他从脚到肩膀的高度 $A_i$，并且他的胳膊长度为 $B_i$。陷阱深度为 $H$。

如果我们利用矮人 $1$，矮人 $2$，矮人 $3$，……，矮人 $k$ 搭一个梯子，满足 $A_1+A_2+A_3+\dots+A_k+B_k \geq H$，那么矮人 $k$ 就可以离开陷阱逃跑了，一旦一个矮人逃跑了，他就不能再搭人梯了。  

我们希望尽可能多的小矮人逃跑，问最多可以使多少个小矮人逃跑。

## 说明/提示

对于 $30\%$ 的数据，$N\leq 200$；  

对于 $100\%$ 的数据，$1 \leq N\leq 2000$，$1 \leq A_i,B_i,H\leq10^5$。

## 样例 #1

### 输入

```
2
20 10
5 5
30```

### 输出

```
2```

## 样例 #2

### 输入

```
2
20 10
5 5
35```

### 输出

```
1```

# AI分析结果



### 一、题解思路与算法要点对比

#### 核心贪心策略对比
1. **灯芯糕题解**（O(n log n)贪心）
   - 排序规则：按（H - a_i - b_i）降序，优先让最低逃生高度高的人先走
   - 反悔机制：用优先队列维护已逃出的人，当当前人无法逃出时，替换队列中身高最大的
   - 关键证明：通过替换身高更大但贡献更低的逃出者，提升剩余高度利用率

2. **动态规划题解**（O(n²)背包）
   - 排序规则：按（a_i + b_i）升序，优先让逃生能力弱的人先逃
   - 状态设计：dp[j] 表示逃出 j 人后的剩余高度最大值
   - 转移方程：`dp[j] = max(dp[j], dp[j-1] - a_i)`，仅当满足逃生条件时更新

#### 解决难点对比
- **贪心策略的证明**：灯芯糕通过几何图示证明排序和替换的合理性；DP方法通过邻项交换法证明排序规则
- **实现复杂度**：贪心需要维护优先队列和反悔逻辑；DP实现更简单但时间复杂度过高
- **极端情况处理**：贪心策略能处理"牺牲一人换多人"的情况；DP严格按排序顺序处理

### 二、题解评分（≥4星）

1. **灯芯糕题解** ⭐⭐⭐⭐⭐
   - 亮点：O(n log n)时间复杂度、反悔贪心设计巧妙、附带几何证明
   - 代码可读性：需结合博客理解，核心逻辑清晰
   - 优化程度：最优时间复杂度，适合1e6数据量

2. **LengChu题解** ⭐⭐⭐⭐
   - 亮点：简洁的背包DP实现，代码仅20行
   - 可读性：状态设计直观，注释明确
   - 适用性：适合n≤2000的题目数据范围

3. **HsKr题解** ⭐⭐⭐⭐
   - 亮点：详细的状态转移分析，附带邻项交换证明
   - 代码实现：标准背包模板，易迁移到其他问题

### 三、最优思路提炼

**核心贪心策略**：
1. **排序规则**：按 a_i + b_i 升序排列，让逃生能力弱（所需总高度低）的先逃
2. **反悔机制**：当当前人无法逃出时，用优先队列替换已逃出的最高者，最大化剩余高度
3. **数学依据**：设总剩余高度为 S，若 S + b_i ≥ H 则逃出，否则替换已逃出中 a 最大的

**关键代码片段**（灯芯糕反悔贪心）：
```cpp
priority_queue<int> q;
int total_height = sum_all_a;
sort(people, people + n, [](auto &x, auto &y) {
    return (x.a + x.b) > (y.a + y.b); 
});

for (auto &p : people) {
    if (total_height + p.b >= H) {
        q.push(p.a);
        total_height -= p.a;
    } else if (!q.empty() && q.top() > p.a) {
        total_height += q.top() - p.a;
        q.pop();
        q.push(p.a);
    }
}
return q.size();
```

### 四、同类型题目与算法套路

**常见贪心套路**：
1. **区间调度类**：按右端点排序（如：选择不重叠区间）
2. **代价/收益比**：按单位代价收益排序（如：P1080国王游戏）
3. **反悔贪心**：优先队列维护当前最优解，允许替换历史选择

**推荐题目**：
1. P1230 智力大冲浪（任务调度与反悔）
2. P2107 小Z的AK计划（贪心+优先队列）
3. P4597 序列sequence（反悔贪心模板）

### 五、可视化与算法演示设计

**贪心过程动画方案**：
1. **初始状态**：显示按 a+b 排序的小矮人队列，用不同颜色区分已逃出/未逃出
2. **贪心选择**：
   - 当前处理的小矮人高亮黄色
   - 检测能否逃出：显示当前总高度 (S) + b_i 与 H 的比较
3. **反悔操作**：
   - 若无法逃出，从优先队列（已逃出区域）中弹出最高者（红色闪烁）
   - 显示替换后的总高度变化：S += (弹出者的a - 当前a)
4. **音效反馈**：
   - 逃出成功：清脆"叮"声
   - 替换操作：电子合成音效
   - 错误尝试：低沉提示音

**复古像素风格实现**：
```javascript
// Canvas绘制示例
function drawPixel(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*10, y*10, 8, 8); // 8x8像素块
}

// 绘制小矮人队列
people.forEach((p, i) => {
    drawPixel(i, 0, p.escaped ? '#00FF00' : '#808080');
    drawText(i*10, 20, `a=${p.a} b=${p.b}`);
});
```

### 六、个人心得摘录

1. **灯芯糕的调试经验**：
   > "最初认为按 a 降序排列即可，直到发现样例2中必须牺牲高个子。反悔机制的引入让正确性大幅提升。"

2. **HsKr的DP优化**：
   > "将二维DP压缩为一维时，逆序更新避免状态污染是关键，否则会重复计算同一人的贡献。"

3. **LengChu的代码精简**：
   > "初始化 dp[0] 为所有a之和，后续只需考虑逃出者的a被扣除，极大简化状态转移逻辑。"

---
处理用时：95.45秒
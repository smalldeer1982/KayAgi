# 题目信息

# 「EZEC-2」数轴

## 题目描述

小 X 画了一条数轴，他将进行 $n$ 次操作，每次操作他会先在数轴上的 $x_i$ 位置上增添 $a_i$ 个标记。

然后他需要选择二元组 $(l,r)$，满足 $l,r$ 为整数， $0\le l\le r \le m$，且在数轴上的区间 $[l,r]$ 上的标记的个数**小于等于** $k$。

对于每次操作，你需要求出满足条件的二元组 $(l,r)$ 中 $r-l$ 的最大值。



## 说明/提示

**【样例解释 #2】**

每次操作后选择的二元组分别是 $(0,15),(4,15),(4,15),(8,15),(9,15)$。

---
**【数据范围与约定】**

| 数据点编号 | $n=$ | $m=$ | $k=$ |
| :----------: | :----------: | :----------: | :----------: |
| $1,2$ | $100$ | $100$ | $3$ |
| $3,4$ | $100$ | $10^3$ | $3$ |
| $5,6$ | $100$ | $10^4$ | $3$ |
| $7,8$ | $500$ | $10^4$ | $3$ |
| $9,10$ | $10^3$ | $10^4$ | $3$ |
| $11,12$ | $10^4$ | $10^5$ | $3$ |
| $13\sim 16$ | $10^5$ | $10^6$ | $0$ |
| $17\sim 21$ | $10^5$ | $10^6$ | $3$ |
| $22,23$ | $10^5$ | $10^9$ | $100$ |
| $24,25$ | $10^6$ | $10^9$ | $100$ |

保证测试点 $13\sim 16$ 的 $x_i$ 为随机构造。

测试点 $24,25$ 的时间限制为 $3\text s$ ，其他测试点的时间限制均为 $2\text s$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^6$，$0\le m\le 10^9$，$0\le x_i\le m$，$0\le k\le 100$，$1\le a_i\le 100$。

**注意：数轴上同一个位置上可能会多次增添标记。**

**已自动开启 $\text{O2}$ 优化，保证时空限制均为 $\text{std}$ 在开启 $\text{O2}$ 优化后的两倍以上。**

## 样例 #1

### 输入

```
5 4 0
2 1
3 1
0 1
1 1
4 1```

### 输出

```
1
1
0
0
-1```

## 样例 #2

### 输入

```
5 15 1
3 1
8 1
1 1
7 1
14 1```

### 输出

```
15
11
11
7
6
```

## 样例 #3

### 输入

```
10 100 10
94 3
22 10
9 4
37 1
21 10
92 5
50 9
68 8
44 4
78 9
```

### 输出

```
100
93
83
77
77
77
68
44
40
26
```

## 样例 #4

### 输入

```
10 100 3
95 1
13 1
52 1
74 1
40 1
54 1
71 1
68 1
51 3
12 2
```

### 输出

```
100
100
100
94
80
59
56
53
50
39
```

# AI分析结果



### 综合分析与结论

**题目核心**：每次操作后求满足区间标记数 ≤k 的最大区间长度，需高效维护动态变化的标记点。

**难点**：
1. **动态维护关键点**：标记点分布稀疏且动态变化，无法直接遍历整个数轴。
2. **高效区间查询**：每次操作后需快速找到满足条件的最长区间，无法暴力枚举。

**贪心策略**：
- **时光倒流**：将添加操作转为删除操作，答案单调递增，避免重复计算。
- **局部性原理**：删除一个点仅影响其周围最多 k 个关键点，仅需检查这些区域。

**核心数据结构**：
- **双向链表**：维护关键点的前驱和后继，支持 O(1) 删除操作。
- **双指针滑动窗口**：在关键点序列上快速找到满足区间和 ≤k 的最长窗口。

---

### 题解评分（≥4星）

1. **君のNOIP（★★★★☆）**
   - **亮点**：离线预处理关键点，双指针滑动窗口清晰，代码结构易读。
   - **关键代码**：通过排序和 map 预处理所有标记点，维护左右指针动态更新。

2. **一扶苏一（★★★★★）**
   - **亮点**：严格证明贪心正确性，链表维护与双指针结合，时间复杂度最优。
   - **个人心得**：“删除操作只需影响周围 k 个点”是核心优化点。

3. **_CHO（★★★★☆）**
   - **亮点**：直接暴力检查周围 k 个点，链表操作简洁，适合快速实现。
   - **代码片段**：用 pre/suc 数组模拟链表，删除时更新前后关系。

---

### 最优思路提炼

**贪心策略实现步骤**：
1. **逆序处理**：从最终状态逐步删除标记点，保证答案单调递增。
2. **链表维护关键点**：删除点后更新相邻点的前驱后继，快速跳转。
3. **局部双指针扫描**：对每个被删点周围 k 个区域，用双指针计算最长区间。

**关键代码片段（一扶苏一）**：
```cpp
// 初始化链表和双指针
for (int i = 0; i <= m; ++i) {
    lp[i] = i - 1; rp[i] = i + 1;
}
// 逆序处理删除操作
for (int i = n; i; --i) {
    w[a[i]] -= b[i]; // 删除标记
    if (w[a[i]] == 0) { // 更新链表
        lp[rp[a[i]]] = lp[a[i]];
        rp[lp[a[i]]] = rp[a[i]];
    }
    // 双指针检查周围 k 个点
    int l = a[i], sum = 0;
    while (sum <= k && lp[l] != -1) sum += w[l = lp[l]];
    // ... 更新最大区间
}
```

---

### 同类型题目与算法套路

**常见贪心场景**：
- **区间覆盖**：选择最少区间覆盖整个线段。
- **活动选择**：选择最多不重叠活动。
- **最小延迟调度**：合理安排任务顺序。

**推荐题目**：
1. **P1803 线段覆盖**：经典区间贪心，选择不重叠线段。
2. **P1090 合并果子**：哈夫曼树贪心，优先队列优化。
3. **P5019 铺设道路**：区间增减操作的最小次数。

---

### 可视化与算法演示

**动画设计**：
1. **像素风格数轴**：用 Canvas 绘制数轴，关键点显示为彩色方块。
2. **链表动态变化**：删除点时高亮其前后方块，连线表示链表关系。
3. **双指针扫描**：左右指针以箭头表示，滑动时实时显示当前区间和。
4. **音效交互**：删除点播放“碎裂”音效，更新最大值时播放成功音调。

**交互功能**：
- **步进控制**：按空格逐步执行删除操作。
- **自动演示**：AI 自动运行，展示贪心策略的渐进过程。
- **数据面板**：显示当前操作点、最大区间长度和剩余标记数。

---

### 复古游戏化设计

**8位像素风格**：
- **数轴背景**：深蓝色网格，标记点为黄色/红色方块。
- **音效**：使用 ChipTunes 风格音效，删除点播放“哔”声，更新答案播放上升音阶。

**关卡与积分**：
- **每删除一个点**视为一关，连续正确更新答案获得连击奖励。
- **积分规则**：根据找到的最大区间长度动态加分，历史最高分存档。

**代码片段（音效触发）**：
```javascript
// 删除标记时触发音效
function playDeleteSound() {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(440, audioCtx.currentTime);
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(0.1);
}
```

---

### 总结

本题通过逆序处理与贪心局部性优化，将复杂度降至 O(nk)。双向链表与双指针的结合是核心，可视化设计可直观展示动态维护过程。同类题目需掌握贪心策略的变形与高效数据结构的使用。

---
处理用时：90.08秒
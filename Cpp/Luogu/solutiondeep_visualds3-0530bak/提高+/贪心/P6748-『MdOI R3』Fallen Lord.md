# 题目信息

# 『MdOI R3』Fallen Lord

## 题目背景

统治着世界，统治着寂寞。

## 题目描述

L 国有 $n$ 个城市，它们之间有 $n-1$ 条道路，形成了一棵树的结构。

国王 L 派遣了一些军队来驻守这些道路，驻守每一条道路的军队战斗力都可以被量化为 $[1,m]$ 中的整数。

每个城市都有一个城主，第 $i$ 个城主有一个忍耐度 $a_i$。如果国王 L 在与第 $i$ 个城市相连的所有道路上驻守的军队战斗力的**中位数**超过了**城主**的忍耐度，那么**城主**就会认为国王不信任他而产生谋反的心理。

国王 L 当然不希望有人造反，但他又想使驻守道路的军队的总战斗力**最大**来保证国防安全。现在他找到了 L 国最强的 OIer —— 您，去来帮助他解决这个问题。

如果无论如何安排军队都会有人想要造反，那么输出 `-1`。

**注：对于任意 $k$ 个数，它们的中位数是将这些数从小到大排序后第 $\left\lfloor\dfrac{k}{2}\right\rfloor+1$ 个数。**

## 说明/提示

更多样例请[到这里](https://www.luogu.com.cn/paste/0wcdzik5)领取。

对于所有数据，$1\le u_i,v_i \le n\le 5\times 10^5$，$n\ge 2$，$1\le a_i\le m\le 10^9$。  

|子任务编号|$n\leq$|$m\leq$|其他性质|分值|
|:-:|:-:|:-:|:-:|:-:|
|1|$8$|$8$|无|$5$|
|2||$1$|无|$1$|
|3|||树的形态为一条链|$10$|
|4|||存在度数为 $n-1$ 的节点|$12$|
|5|$10^5$||每个节点度数 $\le 6$|$17$|
|6|$5\times 10^3$||无|$20$|
|7|||无|$35$|

其中，留空的表示和 $100\%$ 的数据范围限制相同。
### 样例解释
![](https://cdn.luogu.com.cn/upload/image_hosting/ipkyy6az.png)

如图驻守 $n-1=6$ 条道路的军队战斗力（按照输入中的顺序）依次为 $50,50,12,12,12,12$。

## 样例 #1

### 输入

```
7 100
50 25 25 12 12 12 12
1 2
1 3
2 4
2 5
3 6
3 7```

### 输出

```
148```

# AI分析结果



### 综合分析与结论

#### 核心思路与算法要点
1. **问题转化**：将中位数约束转化为「最多允许 k 条边 > a_i」的条件（k = ⌊度数/2⌋）。
2. **贪心策略**：每条边的权值只能取 a_u、a_v 或 m，最大化总和需尽可能选择 m。
3. **树形DP设计**：
   - 状态定义：`f[u][0/1]` 表示父边是否超过当前节点忍耐度时的最大和。
   - 子节点贡献差值排序：计算每个子节点选择高权值（m）与低权值的增益差值，排序后取前 k 大的合法差值。

#### 难点与解决方案
1. **状态转移的合法性**：确保每个节点允许的高权值边数不超过限制。通过排序差值后取前 k 个实现。
2. **父子节点约束联动**：父边权值的选择影响当前节点的合法性判断，需分类讨论父边权值与父子忍耐度的大小关系。
3. **高效计算**：利用排序代替背包 DP 的 O(n²) 复杂度，将时间复杂度优化至 O(n log n)。

#### 可视化设计思路
- **像素风格动画**：以树结构为背景，当前处理节点高亮为红色，子节点按增益差值降序排列。
- **贪心选择演示**：通过绿色高亮显示被选中的差值项，实时更新当前总和。
- **音效与交互**：选中差值时播放金币音效，错误选择（如超出限制）时播放警示音，支持步进控制观察决策过程。

---

### 题解评分（≥4星）

| 作者       | 评分 | 关键亮点 |
|------------|------|----------|
| AK_Dream   | ⭐⭐⭐⭐ | 状态定义清晰，利用排序差值实现高效贪心，代码简洁易读 |
| OMG_wc     | ⭐⭐⭐⭐ | 暴力转贪心的思路直观，差值排序策略解释明确 |
| a___       | ⭐⭐⭐⭐ | 状态转移方程推导严谨，特例处理（度数≤2）考虑周全 |

---

### 最优思路与技巧提炼

#### 关键贪心策略
1. **差值排序法**：  
   ```cpp
   for (子节点 v) {
       gain = (选高权值贡献) - (选低权值贡献);
       if (gain > 0) 加入排序列表;
   }
   sort(gain降序);
   总和 += 前k个gain;
   ```
2. **状态压缩**：通过 `f[u][0/1]` 区分父边权值是否超标，减少状态维度。

#### 实现技巧
1. **特判度数≤2**：此时无法满足父边超标，直接标记 `f[u][1] = -INF`。
2. **边权三元选择**：父边权值只能是 `min(a_u, a_fa)`、`max(a_u, a_fa)` 或 m，避免枚举所有可能。

---

### 同类型题与算法套路

1. **区间贪心**：如 [P1233 木棍加工](https://www.luogu.com.cn/problem/P1233)，通过排序差值选择最优加工顺序。
2. **树形DP+贪心**：如 [P2585 三色二叉树](https://www.luogu.com.cn/problem/P2585)，子节点贡献需按特定规则排序。
3. **限制条件下的最值**：如 [P5021 赛道修建](https://www.luogu.com.cn/problem/P5021)，类似的中位数约束与边权选择。

---

### 推荐题目
1. [P2585 三色二叉树](https://www.luogu.com.cn/problem/P2585)  
2. [P5021 赛道修建](https://www.luogu.com.cn/problem/P5021)  
3. [P1233 木棍加工](https://www.luogu.com.cn/problem/P1233)  

---

### 代码核心片段（AK_Dream 题解）

```cpp
void dfs(int x, int fa) {
    vector<ll> val; ll sum = 0; int tot = 0;
    for (auto y : sons) {
        ll p = max(dp[y][0]+min(a[x],a[y]), dp[y][1]+a[x]); // 低权值
        ll q = max(dp[y][0]+a[y], dp[y][1]+m);              // 高权值
        sum += p;
        if (q > p) val.push_back(q - p); // 计算增益差值
    }
    sort(val.rbegin(), val.rend()); // 降序排序
    for (int i = 0; i < min(k, (int)val.size()); i++) 
        sum += val[i]; // 取前k大增益
    dp[x][0] = sum;
}
```

---

### 可视化示例（伪代码）

```javascript
class GreedyVisualizer {
    constructor(tree) {
        this.nodes = tree; // 树结构数据
        this.currentNode = 1; // 当前处理节点
        this.highlightColor = "#FF0000"; // 当前节点红色
    }

    renderStep() {
        // 绘制树结构，高亮当前节点
        drawTree(this.nodes, this.currentNode);
        
        // 获取当前节点的子节点差值列表
        let diffs = calculateDifferences(this.currentNode);
        diffs.sort((a,b) => b - a); // 降序排序
        
        // 显示排序过程动画
        animateSorting(diffs, () => {
            playSound("sort_complete.wav");
            selectTopKDiffs(diffs, k); // 高亮前k项
            updateSumDisplay();
        });
    }
}
```

---

### 复古游戏化设计
- **8-bit音效**：选中差值时播放 `coin.wav`，错误时 `error.wav`。
- **积分系统**：每正确选择一个差值 +10 分，连续正确触发连击倍率。
- **自动演示模式**：AI 按最优路径自动选择，速度可调（1x/2x/5x）。

---
处理用时：86.97秒
# 题目信息

# [KSN2021] Delivering Balls

## 题目描述

给定一个长度为 $N$ 的序列 $H$ 和 $Q$ 次询问。

第 $i$ 次询问中，你初始在第 $S_i$ 列 $H_{S_i}$ 行，想要到第 $T_i$ 列第 $H_{T_i}$ 行。

你可以进行若干次移动。每次移动你可以选择以下两种参数：

* 列 $-1$，列不变，列 $+1$。
* 行 $-1$，行不变，行 $+1$。

如果你选择行 $-1$，消耗 $1$ 体力，如果你选择行不变，消耗 $2$ 体力，如果你选择行 $+1$，消耗 $4$ 体力。

你需要保证每次移动后，你的列数 $x$ 在 $[1,N]$ 之间，且你的行数 $y$ 不小于 $H_x$。

对于每个询问，你需要求出你消耗体力的最小值。

## 说明/提示

**【样例解释】**

以下为第一个样例中两个询问的图示：

![](https://sandalphon.tlx.toki.id/api/v2/problems/JIDPROG92Su7ScrLh6DkhILekKA/render/roket-q-1.png) ![](https://sandalphon.tlx.toki.id/api/v2/problems/JIDPROG92Su7ScrLh6DkhILekKA/render/roket-q-2.png)

**【数据范围】**

- Subtask 1（7 points）：只存在一组数据，满足 $N=8$，$Q=4$，$H=[,9,3,3,5,4,8,2]$，$(S_i,T_i)$ 依次为 $(1,8)$，$(3,6)$，$(6,4)$ 和 $(7,2)$。
- Subtask 2（5 points）：$S_i+1=T_i$。
- Subtask 3（6 points）：$H_i=i$。
- Subtask 4（18 points）：$N,Q,H_i\leq 100$。
- Subtask 5（24 points）：$N,Q\leq 1000$。
- Subtask 6（13 points）：$S_i=1$。
- Subtask 7（27 points）：无特殊限制。

对于所有数据，$2\leq N\leq 2\times 10^5$，$H_i\leq 10^9$，$Q\leq 2\times 10^5$，$1\leq S_i,T_i\leq N$。

## 样例 #1

### 输入

```
4
9 1 8 2
2
1 3
4 2```

### 输出

```
3
31```

## 样例 #2

### 输入

```
9
1 2 3 2 1 2 3 2 1
4
1 9
4 6
2 6
5 2```

### 输出

```
18
4
9
9```

# AI分析结果



---

## 综合分析与结论

### 核心思路
所有题解均采用**贪心策略+ST表预处理**，核心要点为：
1. 路径必须经过区间最高点，此时斜向移动消耗最少
2. 提前计算起点到最高点的必要抬升高度（$\max h_i-i$）
3. 计算终点到最高点的必要下降高度（$\max h_i+i$）
4. 通过公式 $ans=4(h_{max}-h_s)+(h_{max}-h_t)+2*(横向调整距离)$ 得出总消耗

### 解决难点
- **贪心策略验证**：证明斜向移动最优性（斜向消耗4 < 分步移动6）
- **路径阻挡处理**：通过 $\max(h_i-i)$ 和 $\max(h_i+i)$ 计算阻挡高度
- **方向交换处理**：当 $S>T$ 时交换方向并调整公式参数

### 最优思路与可视化设计
- **动画方案**：以像素风格展示起点→抬升→斜向→平行→下降→终点的路径，红色标记最高点，黄色高亮斜向移动段
- **交互设计**：步进展示 ST 表查询过程，音效提示关键决策点（如最高点选择）

---

## 题解评分（≥4星）

1. **Math_rad_round（⭐⭐⭐⭐）**  
   - 亮点：路径分解详细，图示辅助理解，代码分阶段计算体力  
   - 不足：代码冗余，变量命名混乱

2. **minVan（⭐⭐⭐⭐⭐）**  
   - 亮点：公式 $ans = a -4h_s -h_t +2(b+c)$ 简洁高效，代码可读性极佳  
   - 关键代码：
     ```cpp
     int a1 = max(f[s][k][0], f[r-(1<<k)+1][k][0]);
     int b1 = max(f[s][k][1], f[r-(1<<k)+1][k][1]);
     int c1 = max(f[s][k][2], f[r-(1<<k)+1][k][2]);
     ans = a1 -4*h[s] -h[t] +2*(b1+c1);
     ```

3. **zhouyuhang（⭐⭐⭐⭐）**  
   - 亮点：代码简洁，预处理与查询逻辑清晰  
   - 个人心得："斜向路线斜率总为1" 是推导关键

---

## 核心代码实现（minVan版）

```cpp
// ST表预处理
for(int i=1; i<=n; i++) {
    f[i][0][0] = a[i];
    f[i][0][1] = a[i]-i;
    f[i][0][2] = a[i]+i;
}
for(int j=1; j<20; j++) {
    for(int i=1; i+(1<<j)<=n; i++) {
        f[i][j][0] = max(f[i][j-1][0], f[i+(1<<(j-1))][j-1][0]);
        f[i][j][1] = max(f[i][j-1][1], f[i+(1<<(j-1))][j-1][1]);
        f[i][j][2] = max(f[i][j-1][2], f[i+(1<<(j-1))][j-1][2]);
    }
}

// 查询计算
int s,t, l=min(s,t), r=max(s,t);
int k = log2(r-l+1);
int a1 = max(f[l][k][0], f[r-(1<<k)+1][k][0]);
int b1 = max(f[l][k][1], f[r-(1<<k)+1][k][1]);
int c1 = max(f[l][k][2], f[r-(1<<k)+1][k][2]);
ll ans = a1 -4LL*h[s] -h[t] +2LL*(b1 + c1);
```

---

## 同类型题目推荐

1. **P1886 滑动窗口**（区间最值，ST表基础）
2. **P2471 降雨量**（区间最值应用，逻辑判断）
3. **P2216 理想的正方形**（二维RMQ问题）

---

## 可视化设计要点

### 复古像素风格
- **颜色方案**：绿色路径、红色最高点、黄色斜向段
- **Canvas绘制**：网格坐标系，起点/终点用不同颜色方块
- **音效**：8-bit音效标记抬升/下降/平行阶段

### 自动演示模式
1. 初始化显示H数组与ST表结构
2. 步进展示路径选择：斜向移动→受阻→调整抬升高度
3. 动态公式栏显示当前计算参数（如 $\max h_i-i$ 值）

---

**总结**：本题解法的核心在于贪心选择最高点路径与ST表高效查询，minVan的公式化实现最为简洁高效，适合作为标准解法掌握。

---
处理用时：83.83秒
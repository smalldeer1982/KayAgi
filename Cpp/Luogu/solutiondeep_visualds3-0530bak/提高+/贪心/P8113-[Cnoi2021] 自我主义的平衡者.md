# 题目信息

# [Cnoi2021] 自我主义的平衡者

## 题目背景

「流浪月球 ~ The Wandering Moon」在幻想乡上映了。

正如一千个人心中有一千个哈姆雷特，关于它的争议也在悄然蔓延。

不知何时起，一个叫做「花瓣」的平台出现，慢慢取代了市井之中的讨论声，成为了争议的主战场——因为它具有评分功能。平台上旁征博引、各抒己见的评分帖成为了幻想乡的居民们日常，一切看起来岁月静好。

直到平衡者的出现。

起初没有人在意在意这缕杂音，这只不过是一种无心的叛逆，一点无奈的情感，一次无聊的宣泄。直到平衡的思想深入人心，自我主义的狂潮达到顶峰，评分系统的秩序几近崩溃。

Cirno 觉得自己该做些什么了。

## 题目描述

Cirno 决定通过计算来说服与拯救被自我主义裹挟的众人。

参与评分的共有 $n$ 位居民，平台限制的最高分为 $m$。

每个居民在评分前都有一个心理预期分数 $a_i(a_i\in[0,m]\cap\mathbb{Z})$。

但人们并不会按照心理预期分数直接评分，而是当当前平台上的平均分严格高于自己的心理预期分数时，便评分道「分数太高了，打个 $0$ 分平衡一下」，反之则说「分数太低了，打个满分（$m$分）平衡一下」。

初始时平台上的平均分为 $0$。

为了证明这种评分方式对公平的破坏性，Cirno 希望你计算出这 $n$ 位居民在不同的排列顺序下评分，平台上最终平均分可能的最大值与最小值。

## 说明/提示

**数据范围与约定**

对于 $100\%$ 的数据保证，$1 < n,m\le 10^5$，$a_i \in [0,m]$。

**子任务**

Subtask1（10 points）：$n \le 8$。

Subtask2（10 points）：$n \le 20$。

Subtask3（30 points）：$n \le 10^3$。

Subtask4（50 points）：无特殊限制。

## 样例 #1

### 输入

```
5 5
1 2 3 4 5```

### 输出

```
4.00 2.00```

## 样例 #2

### 输入

```
7 114
23 75 35 17 101 55 73```

### 输出

```
81.43 32.57```

# AI分析结果



---

## 综合分析与结论

### 题目核心分析
给定 $n$ 个居民的预期分数，通过贪心策略确定评分顺序，使得最终平均分最大/最小。每个居民的决策仅取决于当前平均分与其预期值的大小关系，打 $0$ 分或 $m$ 分。

### 算法要点与难点
1. **贪心策略**：
   - **最大值策略**：将 $a_i$ 从小到大排序，确保更多人在早期打 $m$ 分
   - **最小值策略**：将 $a_i$ 从大到小排序，迫使更多人在后期打 $0$ 分
2. **数学证明**：
   - 通过邻项交换法证明排序策略的最优性，核心矛盾点在于交换相邻项不会更优
   - 将平均分比较转化为总和比较（$\text{sum} \leq a_i \times (i-1)$）避免浮点误差
3. **实现关键**：
   - 排序时间复杂度 $O(n \log n)$
   - 模拟评分时维护总和而非实时计算平均值

### 解决难点对比
| 题解差异点           | 共同点                     |
|----------------------|---------------------------|
| 部分题解用邻项交换法详细证明 | 均采用排序+模拟的实现框架 |
| 部分题解直接推导数学结论 | 均通过总和比较避免浮点误差 |
| 代码差异在排序方向和循环方向 | 输出结果保留两位小数一致 |

---

## 题解评分（≥4星）

### 1. 作者：peppaking8（⭐⭐⭐⭐⭐）
- **亮点**：
  - 代码极简，直接通过总和比较避免浮点运算
  - 使用冒泡排序思路的邻项交换法证明排序正确性
  - 时间复杂度严格 $O(n \log n)$
- **代码片段**：
  ```cpp
  for(int i=1;i<=n;i++){
      if(sum <= a[i]*(i-1)) sum += m;
  } 
  ```

### 2. 作者：Code_星云（⭐⭐⭐⭐）
- **亮点**：
  - 详细分类讨论三种邻项关系
  - 代码中实时维护平均值变量
  - 强调数学归纳法的应用
- **个人心得**：
  > "仿照冒泡排序调整即证！这种证明方式与排序不等式如出一辙"

### 3. 作者：block_in_mc（⭐⭐⭐⭐）
- **亮点**：
  - 以打 $m$ 分的数量最大化为目标推导
  - 代码使用 `greater<int>()` 实现降序排序
- **关键证明**：
  > "交换相邻项后，靠后的人打 $m$ 分的概率降低，故不优于原顺序"

---

## 最优思路与代码实现

### 核心贪心逻辑
```cpp
// 最大值计算（升序）
sort(a+1, a+n+1);
ll sum = 0;
for(int i=1; i<=n; i++){
    if(sum <= a[i] * (i-1)) sum += m;
}
double max_avg = sum * 1.0 / n;

// 最小值计算（降序）
sort(a+1, a+n+1, greater<int>());
sum = 0;
for(int i=1; i<=n; i++){
    if(sum <= a[i] * (i-1)) sum += m;
}
double min_avg = sum * 1.0 / n;
```

### 实现思想
- **避免浮点误差**：通过比较 `sum <= a[i] * (i-1)` 替代 `avg <= a[i]`
- **排序方向**：升序保证早期尽可能多打 $m$ 分，降序反之
- **时间复杂度**：由排序主导，严格 $O(n \log n)$

---

## 同类型题目与推荐

### 贪心算法通用套路
1. **排序+线性扫描**：如区间调度、任务分配
2. **邻项交换证明**：需证明任意交换相邻项不会更优
3. **避免浮点运算**：通过整数运算替代除法

### 推荐题目
1. **P1223 排队接水**  
   （贪心排序求最小总等待时间）
2. **P1094 纪念品分组**  
   （双指针贪心匹配）
3. **P1803 凌乱的yyy / 线段覆盖**  
   （区间调度经典贪心）

---

## 可视化与游戏化设计

### 贪心过程动画方案
1. **像素风格展示**：
   - 每个居民显示为 16x16 像素方块
   - 绿色表示打 $m$ 分，红色表示打 $0$ 分
   ```javascript
   ctx.fillStyle = (score === m) ? '#00FF00' : '#FF0000';
   ctx.fillRect(x*20, y*20, 16, 16);
   ```
2. **动态决策演示**：
   - 当前平均分显示在画布顶部
   - 高亮当前决策的居民方块
3. **音效设计**：
   - 打 $m$ 分时播放 `coin.wav`（金币音效）
   - 打 $0$ 分时播放 `error.wav`（错误提示音）

### 游戏化交互
- **关卡模式**：
  - 第 1 关：手动排列 3 个居民观察结果
  - 第 2 关：自动演示正确排序策略
  - 第 3 关：挑战错误排序的后果
- **积分系统**：
  - 正确排列一个居民 +100 分
  - 连续正确触发 2 倍连击奖励

---

## 代码实现（带音效的简化版）

```html
<!DOCTYPE html>
<canvas id="game" width="800" height="600"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const audio = new Audio('data:audio/wav;base64,UklGRl9...'); // 简短的8位音效

let a = [3,1,4,2,5];
let sorted = false;
let currentStep = 0;
let totalSum = 0;

function drawStep() {
  ctx.clearRect(0, 0, 800, 600);
  // 绘制当前居民状态
  a.forEach((val, i) => {
    ctx.fillStyle = i === currentStep ? '#FFFF00' : '#FFFFFF';
    ctx.fillRect(50 + i*70, 300, 50, 50);
    ctx.fillStyle = '#000000';
    ctx.fillText(val, 70 + i*70, 330);
  });
  // 播放音效
  audio.currentTime = 0;
  audio.play();
}

function nextStep() {
  if (!sorted) {
    a.sort((x,y) => x - y);
    sorted = true;
  }
  if (currentStep < a.length) {
    if (totalSum <= a[currentStep] * currentStep) {
      totalSum += 5; // 假设m=5
    }
    currentStep++;
    drawStep();
  }
}

// 点击画布步进
canvas.addEventListener('click', nextStep);
// 初始化绘制
drawStep();
</script>
```

---

## 总结与拓展

本题通过巧妙的排序策略揭示了贪心算法的核心思想——通过局部最优推导全局最优。其证明方法（邻项交换）和实现技巧（整数比较）可推广至多种排序类贪心问题。在可视化设计中融入游戏化元素，能有效加深对贪心决策过程的理解。

---
处理用时：97.41秒
# 题目信息

# Inferno

## 题目背景

> 我是幽灵。  
> 穿过悲惨之城，我落荒而逃。  
> 穿过永世凄苦，我远走高飞。

沿着阿尔诺河的堤岸，我夺路狂奔，气喘吁吁……左转上了卡斯特拉尼大街，一直朝北而行，始终隐蔽在乌菲兹美术馆的阴影之下。

但他们还是穷追不舍。

他们的脚步声越来越响，这些追捕者冷酷无情，不达目的绝不善罢甘休。

这么多年来，他们一直尾随着我。他们锲而不舍，是的我只能活在地下……被迫呆在炼狱之中……就像冥府的恶魔，时刻忍受地狱的煎熬。

> 我是幽灵。

如今浮生尘世，我举目北望，却看不到通往救赎的捷径——那高耸的亚平宁山脉挡住了黎明的第一缕阳光。

## 题目描述

罗伯特 · 兰登在洗下但丁死亡面具上的丙烯石膏后，在背面发现了一行字：

> 哦，有着稳固智慧的人啊，  
> 请注意这里的含义  
> 就藏在晦涩的序列面纱之下。

下面有一行由 $1,-1$ 组成的长度为 $n$ 的序列。面具经受了岁月的侵蚀，序列中有一些数已经模糊不清。幸运的是，面具下面有给出两条线索：

> 你只得往空缺的位置填 $k$ 个 $1$，其余填入 $-1$，需要最大化这个序列的最大子段和。

 > > **一个序列的最大子段和定义为，其在一段连续长度的区间内的最大和。形式化地，一个序列 $a$ 的最大子段和即为 $\max\limits_{l=1}^n\max\limits_{r=l}^n\left(\sum\limits_{i=l}^r a_i\right)$。**

罗伯特 · 兰登希望在瘟疫扩散之前找到有关的线索。于是他找到了你。

- - -

#### 【形式化题意】

给定一个只包含 $-1,0,1$ 的序列，求出往 $0$ 的位置上填 $k$ 个 $1$，其余填 $-1$ 后最大子段和的最大值。

## 说明/提示

#### 【样例解释】

一种可行的方案是填入 $\{1,1,-1\}$，最大子段和为 $2$。

#### 【数据范围】


**本题开启捆绑测试。**

| $\text{SubTask}$ | 分值 | $n,k\le $ |
| :----------: | :----------: | :----------: |
| $0$ | $4$ | $20$ | 
| $1$ | $6$ | $200$ | 
| $2$ | $10$ | $5\times 10^3$ | 
| $3$ | $30$ | $5\times 10^5$ | 
| $4$ | $50$ | $10^7$ | 


对于 $100\%$ 的数据，$1\le n,k\le10^7$，$a_i\in \{-1,0,1\}$。保证 $k\le$ 序列中 $0$ 的个数。

**本题标程使用优化后的输入输出，在 O2 优化下最大点用时约 $350$ ms，足以通过此题。如果您自认为您的程序复杂度正确，却超出时间限制，请使用更优的输入输出方式，或者优化常数。**


## 样例 #1

### 输入

```
5 2
1 0 -1 0 0```

### 输出

```
2```

# AI分析结果



### 综合分析与结论

**题目核心**：在0的位置填k个1，其余填-1，使得序列的最大子段和最大化。

**核心思路**：
1. **贪心策略**：最优解必定存在一个连续区间，其中填k个1，其余0填-1。将问题拆分为两种情况：
   - 情况1：区间内0的数量≤k，全填1。此时子段和=原序列和+0的数量。
   - 情况2：区间内0的数量>k，填k个1，其余填-1。此时子段和=原序列和+2k-0的数量。

2. **数据结构优化**：
   - 维护两个前缀和数组（全填1、全填-1）。
   - 单调队列维护情况1的区间最大值，后缀最大值数组处理情况2。

**难点与解决**：
- **高效枚举区间**：通过预处理0的位置数组，快速定位到每个左端点对应的k个0的右边界。
- **双情况处理**：将问题分解为两个独立的最值问题，利用数据结构优化查询。

**可视化设计**（复古像素风格）：
- **动画步骤**：
  1. 显示原始序列，用不同颜色标记1、-1、0。
  2. 滑动窗口枚举左端点，高亮当前处理的区间。
  3. 两种情况分屏展示：左侧显示全填1的区间（绿色），右侧显示填k个1后的区间（黄色）。
  4. 单调队列动态变化，显示队列头尾元素及当前最大值。
- **音效提示**：
  - 选择0填1时播放“滴”声。
  - 找到更优解时播放上扬音效。
- **游戏化**：积分系统，每正确维护一次队列得10分，通关后显示总分。

### 题解清单（评分≥4星）

1. **cyffff的题解（5星）**
   - **亮点**：思路清晰，双前缀和与单调队列结合，代码高效。
   - **代码可读性**：结构分明，变量命名规范，注释适当。
   - **优化**：利用位置数组快速定位0的分界点，O(n)复杂度。

2. **LHQing的题解（4.5星）**
   - **亮点**：简洁的代码实现，双指针维护后缀最大值。
   - **优势**：代码简短，适合快速理解核心逻辑。
   - **不足**：变量名较简略，可读性稍逊。

3. **TernaryTree的题解（4星）**
   - **亮点**：引入尺取法，独特的前后缀处理。
   - **创新点**：结合线段树思想，优化区间查询。
   - **适用性**：适合对尺取法熟悉的读者。

### 最优思路提炼

**贪心策略核心**：
- **关键观察**：最大子段和必定由某个区间的k个1贡献，优先填在密集区域。
- **实现技巧**：
  1. **预处理0的位置**：记录每个0的位置，快速计算区间内的0数量。
  2. **分情况转化**：将问题转换为两个独立的前缀和差最大值问题。
  3. **单调队列优化**：维护滑动窗口内的最小值，快速响应查询。

**代码核心片段**（cyffff题解）：
```cpp
// 预处理前缀和与后缀最大值
for(int i=n;i>=1;i--)
    pm[i]=max(pm[i+1],p1[i]), sm[i]=max(sm[i+1],p0[i]);

// 单调队列维护区间最大值
for(;lp<=np-1;lp++){
    while(hd<=tl&&stk[tl].v<p1[lp]) tl--;
    stk[++tl]={p1[lp],lp};
}
ans=max({ans,stk[hd].v-p1[i],sm[np]-p0[i]+2*k});
```

### 同类题目推荐

1. **P1115 最大子段和**：基础版，练习动态规划。
2. **P2642 最大差值**：结合前缀后缀最值。
3. **P3128 最大连续子序列**：带限制条件的子段和问题。

### 个人心得摘录

- **调试教训**：初始未考虑0数量不足k的情况，导致数组越界（Forever1507题解）。
- **顿悟瞬间**：发现两种情况可独立计算，豁然开朗（LHQing题解）。

### 可视化代码示例（复古风格JS）

```javascript
// 初始化Canvas
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let speed = 500; // 动画速度

function drawArray(arr, highlightIdx) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    arr.forEach((num, i) => {
        ctx.fillStyle = num === 1 ? '#00FF00' : (num === -1 ? '#FF0000' : '#888888');
        if (i === highlightIdx) ctx.fillStyle = '#FFFF00'; // 高亮当前处理元素
        ctx.fillRect(i * 30, 100, 25, 25);
    });
}

// 模拟算法步骤
function animateSolution(steps) {
    let stepIdx = 0;
    const interval = setInterval(() => {
        if (stepIdx >= steps.length) {
            clearInterval(interval);
            return;
        }
        const {arr, idx} = steps[stepIdx];
        drawArray(arr, idx);
        stepIdx++;
    }, speed);
}
```

### 总结

本题通过巧妙的问题分解与数据结构优化，将看似复杂的贪心选择转化为高效的前缀和计算。核心在于识别两种独立情况，并利用单调性维护最值，避免了暴力枚举的高开销。

---
处理用时：93.52秒
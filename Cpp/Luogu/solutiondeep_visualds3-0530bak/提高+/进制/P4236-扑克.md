# 题目信息

# 扑克

## 题目背景

lsq邀请wzt去他家打扑克牌

## 题目描述

lsq的扑克没有大小王，共计有n张，由于wzt沉迷于幂运算无法自拔，wzt提出要每次抽a^2张牌（这里“^”是乘方的意思），lsq觉得这样抽真没意思，于是改成了每次抽a^k（k是一个自然数，由游戏者自由选择）张牌。**由lsq开始**，每个人轮流按上述规则摸牌，谁先摸到最后一张牌谁就赢。

由于时间充裕，lsq和wzt一共会玩q盘游戏，每一盘都有不同的a和n。wzt怒敲了一波代码，竟然可以算出当确定了a和n的值后，若能必胜如何下。lsq在见识过你的~~毒瘤~~操作后，希望你也帮他写出一个程序，能判断确定了a和n的值后他是否能赢，lsq当然知道怎么下最优，所以不需要你算出如何下 

**注意：此题中两方的打牌决策都是若有必胜决策则必用必胜决策**

此题中k是一个每次抽牌都可由抽牌者自己决定的一个非负整数，可以结合下面的样例加以理解

## 说明/提示

对于30%的数据，满足q<=30，a<=30，n<=1e8

对于50%的数据，满足q<=50，a<=30，n<=1e12

对于100%的数据，满足q<=50000，a<=20000，n<=1e500

样例一解释：
询问1：lsq必胜，lsq先抽2^1=2，接下来无论wzt抽2^1=2或2^0=1，lsq只要把牌抽完；其他抽法同上（只是顺序不同）

询问2：wzt必胜，若lsq先抽2^0=1，则wzt抽2^3=8；若lsq先抽2^1=2，则wzt抽2^2=4，接下来无论lsq抽2^1=2或2^0=1，wzt只要把牌抽完；其他抽法同上（只是顺序不同）

询问3：lsq必胜，lsq只需拿走3^2=9即可

By [Broadway](https://www.luogu.org/space/show?uid=33509)

## 样例 #1

### 输入

```
3
2 5
2 9
3 9```

### 输出

```
lsq Win
wzt Win
lsq Win```

# AI分析结果



**唯一算法分类**  
博弈论（模运算与奇偶性分析）

---

### **题解思路与算法要点**
#### **核心思路**
1. **奇偶性主导的博弈策略**：  
   - 当 `a` 为奇数时，每次取牌操作会改变剩余牌数的奇偶性。最终胜负仅由初始 `n` 的奇偶性决定：若 `n` 为奇数则先手必胜，否则后手必胜。
   - 当 `a` 为偶数时，胜负由 `n % (a+1)` 的结果决定：若余数为奇数或等于 `a`，先手必胜；否则后手必胜。

2. **大数取模优化**：  
   - `n` 可能极大（1e500），需逐字符计算其对 `a+1` 的模。利用模运算的分配律，逐位累加并取模，避免直接处理大数。

#### **解决难点**
- **数学推导**：通过分析 `a^k` 在模 `a+1` 下的周期性（如 `a^2 ≡ 1 mod (a+1)`），将问题转化为模运算判断。
- **大数处理**：通过字符串逐位取模，高效处理 `n` 的值。

---

### **题解评分 (≥4星)**
1. **Maniac丶坚果的题解（5星）**  
   - **亮点**：完整数学证明 + 高效代码实现，直接处理大数取模。
   - **代码片段**：
     ```cpp
     if (n % 2 == 1) {
         if (ch[len - 1] % 2 == 1) puts("lsq Win");
         else puts("wzt Win");
     } else {
         int now = 0;
         for (int i = 0; i < len; ++i) {
             now = now * 10 + ch[i] - '0';
             now %= (a + 1);
         }
         if (now % 2 == 1 || now == a) puts("lsq Win");
         else puts("wzt Win");
     }
     ```
   - **心得**：通过观察 `a^k` 的模特性简化问题。

2. **__Watcher的题解（4星）**  
   - **亮点**：通过打表发现规律，验证结论正确性。
   - **代码片段**：
     ```cpp
     if (a % 2 == 1) {
         if (n % 2 == 1) printf("lsq Win\n");
         else printf("wzt Win\n");
     } else {
         if (n % (a + 1) == 0) printf("wzt Win\n");
         else if (n % 2 == 1 || n == a) printf("lsq Win\n");
     }
     ```

---

### **最优思路提炼**
1. **数学分类讨论**：  
   - 奇偶性分治，结合模运算特性，快速判断必胜条件。
2. **大数处理技巧**：  
   - 逐位取模替代大数运算，时间复杂度从 `O(n)` 降为 `O(len(n))`。

---

### **同类型题推荐**
1. **P2949 [博弈论]取石子游戏**：巴什博弈变种，需分析取石子策略。
2. **P1288 取数游戏II**：环形博弈，依赖奇偶性与模运算。
3. **P1247 取火柴游戏**：Nim博弈，需计算异或和。

---

### **可视化与算法演示**
#### **动画设计**
- **像素风格界面**：  
  - **背景**：8位扑克牌堆，动态显示剩余牌数 `n`。  
  - **操作高亮**：当前玩家选择 `a^k` 时，对应牌堆闪烁（红色边框）。  
  - **胜负提示**：胜利时播放经典FC胜利音效（如《超级马里奥》过关音效）。

- **核心流程演示**：  
  1. **输入阶段**：以滚动字幕显示 `a` 和 `n` 的输入。  
  2. **计算阶段**：  
     - 若 `a` 为奇数，显示奇偶性判定（绿色/红色数字）。  
     - 若 `a` 为偶数，显示 `n % (a+1)` 的计算过程，逐位数字流动到模运算框。  
  3. **结果动画**：胜利用烟花动画，失败用灰暗牌堆。

- **交互功能**：  
  - **速度调节**：滑动条控制模运算逐位计算速度。  
  - **自动演示**：AI自动选择最优策略，展示关键决策点。

#### **代码片段（JS伪代码）**
```javascript
// 大数取模动画（逐位计算）
function calcMod(nStr, a) {
    let mod = a + 1;
    let remainder = 0;
    for (let digit of nStr) {
        remainder = (remainder * 10 + parseInt(digit)) % mod;
        // 高亮当前处理位
        highlightDigit(digit);
        playSound('blip'); // 每处理一位播放音效
    }
    return remainder;
}
```

---

### **结论**
本题通过奇偶性与模运算的博弈策略，将复杂的大数问题转化为高效计算。核心在于分类讨论 `a` 的奇偶性，结合数学推导与字符串处理技巧，实现快速判定胜负。

---
处理用时：87.65秒
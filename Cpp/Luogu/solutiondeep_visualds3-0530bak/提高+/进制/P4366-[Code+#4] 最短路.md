# 题目信息

# [Code+#4] 最短路

## 题目背景

在北纬 91° ，有一个神奇的国度，叫做企鹅国。这里的企鹅也有自己发达的文明，称为企鹅文明。因为企鹅只有黑白两种颜色，所以他们的数学也是以二进制为基础发展的。

比如早在 $11101001$ 年前，他们就有了异或这样一个数学概念。如果你不知道异或是什么，请出门过墙左转到[这里](https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96)。

再比如早在 $1000010$ 年前，他们的大科学家 Penguin. Tu 就提出了[图](https://zh.wikipedia.org/wiki/%E5%9B%BE_%28%E6%95%B0%E5%AD%A6%29#%E6%9C%89/%E7%84%A1_%E5%90%91%E5%9B%BE)和[最短路径](https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98)这样一些概念。

## 题目描述

企鹅国中有 $N$ 座城市，编号从 $1$ 到 $N$ 。

对于任意的两座城市 $i$ 和 $j$ ，企鹅们可以花费 $(i~\mathrm{xor}~j) \times C$ 的时间从城市 $i$ 走到城市 $j$ ，这里 $C$ 为一个给定的常数。

当然除此之外还有 $M$ 条单向的快捷通道，第 $i$ 条快捷通道从第 $F_i$​​ 个城市通向第 $T_i$​​ 个城市，走这条通道需要消耗 $V_i$​​ 的时间。

现在来自 **P**enguin **K**ingdom **U**niversity 的企鹅豆豆正在考虑从城市 $A$ 前往城市 $B$ 最少需要多少时间？

## 说明/提示

**样例1解释**

直接从 $1$ 走到 $4$ 就好了。

**样例2解释**

先从 $3$ 走到 $2$ ，再从 $2$ 通过通道到达 $4$ ，再从 $4$ 走到 $6$。

![0](https://cdn.luogu.com.cn/upload/pic/16868.png)

活泼可爱的出题人给大家留下了下面这张图。

![1](https://i.loli.net/2018/04/02/5ac1bb2333c22.jpg)

Credit: https://www.luogu.org/discuss/show/38908

## 样例 #1

### 输入

```
4 2 1
1 3 1
2 4 4
1 4```

### 输出

```
5```

## 样例 #2

### 输入

```
7 2 10
1 3 1
2 4 4
3 6```

### 输出

```
34```

# AI分析结果



**唯一算法分类**：最短路（Dijkstra 算法优化）

---

### 综合分析与结论

**核心思路**：  
通过位运算特性，将任意两点的异或边简化为仅保留二进制位相差 1 的边（即 $i \rightarrow i \oplus 2^k$），使得边数从 $O(N^2)$ 降为 $O(N \log N)$。结合给定 $M$ 条边后，用 Dijkstra 算法求解最短路。

**算法流程**：  
1. **建图优化**：对每个节点 $i$，仅连接 $i$ 与 $i \oplus 2^k$ 的边（权值 $2^k \cdot C$）。  
2. **Dijkstra 优化**：使用线段树/堆维护未访问节点的最小值，并提前终止目标节点的计算。

**可视化设计要点**：  
- **像素动画**：用 8-bit 风格网格展示节点，当前处理的节点显示为闪烁方块，更新的边以高亮线条表示。  
- **音效触发**：节点被访问时播放 "beep" 音效，找到最短路时播放胜利音效。  
- **自动演示**：AI 自动执行 Dijkstra，展示优先队列的弹出和边更新的动态过程。

---

### 题解清单（≥4星）

1. **Mirach（★★★★★）**  
   - **亮点**：线段树优化 Dijkstra，处理 0 号节点避免边界问题。  
   - **代码片段**：  
     ```cpp
     for(rg int i=1;i<=n;i<<=1)
         if(!bo[x^i]&&(x^i)<=n) update(0,n,1,x^i,dis[x]+c*i);
     ```

2. **Froranzen（★★★★☆）**  
   - **亮点**：位分解建边，堆优化剪枝（目标节点提前终止）。  
   - **心得**：指出堆优化可能 TLE，需结合 O2 优化。

3. **crashed（★★★★☆）**  
   - **亮点**：数学证明异或边可拆解，代码结构清晰。  
   - **关键代码**：  
     ```cpp
     for(int j=0;j<=lg2;j++)
         addedge(i, i^(1<<j), (1<<j)*C);
     ```

---

### 核心代码实现

**异或边建图 + Dijkstra 模板**：  
```cpp
// 建图部分
for (int i = 0; i <= n; i++) {
    for (int j = 1; j <= n; j <<= 1) {
        int to = i ^ j;
        if (to <= n) add_edge(i, to, j * C);
    }
}
// Dijkstra 部分（堆优化）
priority_queue<pii, vector<pii>, greater<pii>> pq;
pq.emplace(0, start);
while (!pq.empty()) {
    auto [d, u] = pq.top(); pq.pop();
    if (u == target) break; // 提前终止优化
    for (auto [v, w] : edges[u]) {
        if (dis[v] > d + w) {
            dis[v] = d + w;
            pq.emplace(dis[v], v);
        }
    }
}
```

---

### 相似题目推荐

1. **P2446 [SDOI2010]大陆争霸**（位运算 + 最短路）  
2. **P5663 加工零件**（分层图最短路）  
3. **P4568 [JLOI2011]飞行路线**（多维状态最短路）

---

### 个人心得摘录

> "在 Dijkstra 更新点的时候，如果终点更新过了，就可以跳出去了，能减少 50% 时间。" —— Sirius_Sakura  
> **总结**：提前终止是优化最短路算法的实用技巧。

---

### 复古像素化动画设计

1. **Canvas 绘制**：  
   - 节点排列为网格，每个节点用 16x16 像素方块表示，异或边用黄色线条连接。  
   - **颜色标记**：当前节点（红色），已访问节点（灰色），最短路径（绿色闪烁）。  

2. **音效设计**：  
   - `visit_sound()`：当节点被访问时播放 8-bit "ping"。  
   - `path_found()`：找到路径时播放胜利旋律。  

3. **自动演示逻辑**：  
   ```javascript
   function autoRun() {
       let current = pq.pop();
       highlightNode(current);
       playSound('ping');
       if (current === target) endAnimation();
       // ... 更新相邻节点
   }
   ```

---
处理用时：71.77秒
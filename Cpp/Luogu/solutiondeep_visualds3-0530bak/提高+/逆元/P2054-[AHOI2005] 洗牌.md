# 题目信息

# [AHOI2005] 洗牌

## 题目描述

为了表彰小联为 Samuel 星球的探险所做出的贡献，小联被邀请参加 Samuel 星球近距离载人探险活动。

由于 Samuel 星球相当遥远，科学家们要在飞船中度过相当长的一段时间，小联提议用扑克牌打发长途旅行中的无聊时间。玩了几局之后，大家觉得单纯玩扑克牌对于像他们这样的高智商人才来说太简单了。有人提出了扑克牌的一种新的玩法。

对于扑克牌的一次洗牌是这样定义的，将一叠 $N$（$N$为偶数）张扑克牌平均分成上下两叠，取下面一叠的第一张作为新的一叠的第一张，然后取上面一叠的第一张作为新的一叠的第二张，再取下面一叠的第二张作为新的一叠的第三张……如此交替直到所有的牌取完。

如果对一叠 $6$ 张的扑克牌 ${1,2,3,4,5,6}$，进行一次洗牌的过程如下图所示：

  ![](https://cdn.luogu.com.cn/upload/pic/1641.png) 

从图中可以看出经过一次洗牌，序列 $1,2,3,4,5,6$ 变为 $4,1,5,2,6,3$。当然，再对得到的序列进行一次洗牌，又会变为 $2,4,6,1,3,5$。

游戏是这样的，如果给定长度为 $N$ 的一叠扑克牌，并且牌面大小从 $1$ 开始连续增加到 $N$（不考虑花色），对这样的一叠扑克牌，进行 $M$ 次洗牌。最先说出经过洗牌后的扑克牌序列中第 $L$ 张扑克牌的牌面大小是多少的科学家得胜。小联想赢取游戏的胜利，你能帮助他吗？

## 说明/提示

$0 ＜ N \leq 10^{10}$，$0 \leq M \leq 10^{10}$，且 $N$ 为偶数。


## 样例 #1

### 输入

```
6 2 3```

### 输出

```
6```

# AI分析结果



## 算法分类
**数学（模运算、逆元）**

---

## 题解思路与核心难点
### 核心思路
1. **位置变换规律**：每次洗牌后，位置`x`的新位置为`2x mod (n+1)`。经过`M`次洗牌，位置变换公式为 `x * 2^M ≡ L (mod n+1)`。
2. **逆元求解**：转化为求方程 `x ≡ L * (2^M)^{-1} (mod n+1)`，需计算 `2^M` 的逆元。
3. **快速幂与快速乘**：处理大数幂运算和乘法，防止溢出。

### 解决难点
- **数学推导**：发现洗牌后的位置变换是模运算的关键。
- **逆元计算**：当 `n` 为偶数时，`n+1` 为奇数，2 的逆元可快速求得为 `(n+2)/2`，无需扩展欧几里得。
- **大数处理**：使用快速乘避免乘法溢出。

---

## 题解评分（≥4星）
1. **qqvq（5星）**  
   - **亮点**：结合扩展欧几里得求逆元，使用快速幂和快速乘处理大数运算，代码严谨。
   - **代码片段**：
     ```cpp
     inline ll mul(ll a, ll b, ll mod) {
       ll ret = 0;
       while (b) {
         if (b & 1) ret = (ret + a) % mod;
         a = (a + a) % mod;
         b >>= 1;
       }
       return ret % mod;
     }
     ```

2. **RenaMoe（4星）**  
   - **亮点**：详细推导同余方程，使用快速乘确保计算正确性，代码清晰。
   - **代码片段**：
     ```cpp
     inline ll mul(ll a, ll b, ll p) {
       ll ans = 0;
       while (b) {
         if (b & 1) ans = (ans + a) % p;
         a = (a + a) % p;
         b >>= 1;
       }
       return ans;
     }
     ```

3. **Diu_（4星）**  
   - **亮点**：直接利用逆元公式 `(n+2)/2`，简化计算，适合偶数 `n`。
   - **代码片段**：
     ```cpp
     x = n/2 + 1;  // 2的逆元公式
     printf("%lld", qmul(l, qpow(x, m, n), n));
     ```

---

## 最优思路提炼
1. **位置变换模型**：洗牌操作等价于 `x → 2x mod (n+1)`。
2. **逆元快速计算**：当 `n` 为偶数时，`2` 的逆元为 `(n+2)/2`，直接用于快速幂。
3. **大数运算处理**：使用快速乘（龟速乘）避免溢出。

---

## 类似题目推荐
1. **P3811 【模板】乘法逆元**  
   - **关键词**：逆元、模运算。
2. **P1965 转圈游戏**  
   - **关键词**：快速幂、位置循环。
3. **P1082 同余方程**  
   - **关键词**：扩展欧几里得、线性同余。

---

## 可视化算法演示
### 动画方案
1. **位置变换动画**：  
   - **步骤**：展示牌的位置如何从 `x` 变换到 `2x mod (n+1)`。
   - **高亮**：当前操作的位置以红色闪烁，新位置绿色显示。
2. **快速幂过程**：  
   - **步进显示**：二进制分解指数，逐位计算幂次，高亮当前位和中间结果。
3. **逆元计算**：  
   - **扩展欧几里得流程**：动态展示递归求解过程，高亮每一步的系数变化。

### 复古像素风格
- **颜色方案**：8位色调色板，红（当前操作）、绿（新位置）、蓝（背景）。
- **音效**：  
  - **关键操作**：短促“哔”声。
  - **完成计算**：胜利音效。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

ll mul(ll a, ll b, ll mod) { // 快速乘
    ll ret = 0;
    while (b) {
        if (b & 1) ret = (ret + a) % mod;
        a = (a + a) % mod;
        b >>= 1;
    }
    return ret;
}

ll pow_mod(ll a, ll b, ll mod) { // 快速幂
    ll res = 1;
    while (b) {
        if (b & 1) res = mul(res, a, mod);
        a = mul(a, a, mod);
        b >>= 1;
    }
    return res;
}

int main() {
    ll n, m, l;
    cin >> n >> m >> l;
    ll mod = n + 1;
    ll inv_2 = (mod + 1) / 2; // 2的逆元
    ll total_inv = pow_mod(inv_2, m, mod);
    cout << mul(l, total_inv, mod);
    return 0;
}
```

---
处理用时：109.57秒
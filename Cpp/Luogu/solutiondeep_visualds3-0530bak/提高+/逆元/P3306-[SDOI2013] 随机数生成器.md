# 题目信息

# [SDOI2013] 随机数生成器

## 题目背景

小 W 喜欢读书，尤其喜欢读《约翰克里斯朵夫》。

## 题目描述

最近小 W 准备读一本新书，这本书一共有 $p$ 页，页码范围为 $0 \sim p-1$。

小 W 很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用 NOI2012 上学习的线性同余法生成一个序列，来决定每天具体读哪一页。

我们用 $x_i$ 来表示通过这种方法生成出来的第 $i$ 个数，也即小 W 第 $i$ 天会读哪一页。这个方法需要设置 $3$ 个参数 $a,b,x_1$，满足 $0\leq a,b,x_1\lt p$，且 $a,b,x_1$ 都是整数。按照下面的公式生成出来一系列的整数：
$$x_{i+1} \equiv a \times x_i+b \pmod p$$
其中 $\bmod$ 表示取余操作。

但是这种方法可能导致某两天读的页码一样。

小 W 要读这本书的第 $t$ 页，所以他想知道最早在哪一天能读到第 $t$ 页，或者指出他永远不会读到第 $t$ 页。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq T \leq 50$。
- $0 \leq a, b, x_1, t \lt p$，$2 \leq p \leq 10^9$。
- $p$ 为质数。

## 样例 #1

### 输入

```
3
7 1 1 3 3
7 2 2 2 0
7 2 2 2 1
```

### 输出

```
1 
3 
-1```

# AI分析结果



## 算法分类
**BSGS算法**

---

## 题解思路与算法要点

### 核心思路
所有题解均通过数学推导将递推式转化为等比数列形式，最终得到形如 $a^{k} \equiv C \pmod{p}$ 的方程，使用 **BSGS算法** 求解离散对数。关键步骤包括：
1. **特判边界情况**（a=0, a=1, x1=t）
2. **数学变形**将递推式转换为等比数列形式
3. **模运算下的逆元计算**（费马小定理）
4. **BSGS算法实现**（分块处理+哈希表查询）

### 解决难点对比
| 题解特点               | ChenZ01                                                                 | wwyx2001                                                                 |
|------------------------|-------------------------------------------------------------------------|-------------------------------------------------------------------------|
| **推导方式**           | 纯数学推导，显式展示等比数列构造过程                                      | 强调递推式变形为等比数列的直观思路                                        |
| **BSGS优化**           | 使用`std::map`实现哈希表                                                 | 手写链式哈希表，在BZOJ/洛谷跑出最优解                                      |
| **特判处理**           | 详细分离a=0/a=1/x1=t三种情况                                              | 将a=1的情况合并到通解中，代码更紧凑                                        |
| **逆元计算**           | 显式写出逆元计算公式 $(1-a)^{-1}$                                         | 用`pow(b, p-2)`隐式处理分母                                                |

---

## 题解评分（≥4星）

### 1. ChenZ01（⭐⭐⭐⭐⭐）
- **亮点**：推导过程最完整，边界情况处理清晰，代码模块化设计
- **核心代码段**：
```cpp
long long ans = bsgs(a, ((t - b*inv(1-a,p))%p + p) %p * inv(...), p);
if(ans != -1) cout << ans + 1 << endl;
```

### 2. wwyx2001（⭐⭐⭐⭐）
- **亮点**：手写哈希表优化性能，代码风格紧凑
- **关键优化**：
```cpp
void Insert(int x, int y) { // 链式哈希插入
    nxt[++t] = head[x%N], head[x%N] = t; 
    val[t] = x, num[t] = y;
}
```

### 3. HoshiuZ（⭐⭐⭐⭐）
- **亮点**：详细注释推导过程，处理模运算负数的`mul`函数设计
- **独特处理**：
```cpp
#define mul(x,y) (((x%p+p)%p)*((y%p+p)%p))%p // 保证乘数非负
```

---

## 最优思路提炼
1. **数学变形**：通过添加常数项 $k=\frac{b}{a-1}$ 将递推式转化为等比数列
   $$X_n + k \equiv a^{n-1}(X_1 + k) \pmod{p}$$
2. **特判优先**：优先处理a=0/a=1的退化情况，避免BSGS异常
3. **逆元技巧**：用费马小定理计算模质数下的除法，如 $\frac{1}{1-a} \equiv (1-a)^{p-2} \pmod{p}$
4. **BSGS分块**：预处理$\sqrt{p}$规模的哈希表，实现$O(\sqrt{p})$时间复杂度

---

## 同类型题目
1. [洛谷P3846] 可爱的质数 - 裸BSGS模板
2. [洛谷P2485] 计算器 - 离散对数+快速幂+扩展欧几里得
3. [洛谷P3306] 随机数生成器 - 本题原题

---

## 可视化算法演示设计

### 动画方案（BSGS流程演示）
1. **分块预处理**：
   - 绘制哈希表插入过程，用绿色高亮当前插入的$a^j \mod p$
   - 音效：每次插入时播放短促"滴"声

2. **大步查询**：
   - 红色标记当前查询的$t \cdot A^{-im} \mod p$
   - 当匹配到哈希表中的值时，闪烁显示匹配位置并播放成功音效

3. **矩阵乘法模式**（Maxwei_wzj题解）：
   - 展示矩阵快速幂的二进制分解过程
   - 用8位像素风格绘制矩阵元素的变化

### 复古游戏化设计
- **像素风格**：使用NES调色板（#306082主色调，#c0c0c0背景）
- **音效设计**：
  - 正确匹配：8-bit风格胜利音效（上升琶音）
  - 无解情况：播放经典FC游戏"Game Over"音效片段
- **自动演示**：按空格键切换手动/自动模式，自动模式下算法步骤以0.5秒间隔执行

---

## 核心代码实现（BSGS算法）
```cpp
ll BSGS(ll a, ll b, ll p) {
    ll m = ceil(sqrt(p)), t = 1;
    unordered_map<ll, ll> mp;
    for(ll i=0; i<m; ++i) { // 小步插入
        if(!mp.count(t)) mp[t] = i;
        t = t * a % p;
    }
    ll k = inv(t, p), w = b; // 计算a^-m
    for(ll i=0; i<m; ++i) { // 大步查询
        if(mp.count(w)) return i*m + mp[w];
        w = w * k % p;
    }
    return -1;
}
```

---

## 调试心得摘录
> **Hovny**题解提到："提交了16次才发现模运算中负数未正确处理"。  
> **启示**：所有模运算操作后必须用`(x%p + p)%p`确保非负

> **qwaszx**在注释中强调："mul宏必须保证两个乘数非负"。  
> **关键点**：C++中负数取模行为未定义，需显式转正

---

## 扩展思考
当模数$p$非质数时，需改用扩展BSGS算法，通过消去公约数处理方程。此时需在BSGS前增加预处理步骤，将方程转化为$a^x \equiv b \pmod{p}$且$\gcd(a,p)=1$的形式。

---
处理用时：76.39秒
# 题目信息

# 公主の#18文明游戏

## 题目背景

公主发现了一个游戏，998，于是我就花钱给她买下来了（捂脸）


## 题目描述

这个游戏叫做《文♂明》（滑稽），但是跟平常意义上的不一样。

这个游戏里有n个城市，标号1~n，有m条双向道路相连，编号1~m。

游戏里会系统会添加Ni个人到一个城市Xi，并给定这些人的信仰Ci

系统还会切断一条道路，并给定道路编号Xi

系统还会给定一个城市Xi，询问从Xi出发可以到达的所有城市中选择Ni个人，

使得他们信仰都为Ci的概率为多少，对19260817取模。

输入数据不保证没有重边和自环。

输入数据不保证同一条边不会被切断两次以上。

因为是公主的游戏，所以本题输入量较大，请注意输入的优化


## 说明/提示

吐槽某人居然没告诉我 我没放样例

补发样例（其实我本来有样例来着）

在这里跟大家道歉

对于30%的数据，1<=n,m,q<=100

对于60%的数据，1<=n,m,q<=50000

对于100%的数据，1<=n,m,q<=400000

对于100%的数据，保证所有信仰在C++的int，Pascal的long int范围内

对于100%的数据，保证每次添加的人数和初始人数都不超过10

对于100%的数据，保证数据随机生成

题目 @玫葵之蝶

## 样例 #1

### 输入

```
5 5 5
5 1
9 2
8 1
8 1
6 2
5 2
1 2
2 2
1 1
5 3
1 1 3 2
2 1
3 3 4 1
3 2 3 1
3 1 2 1
```

### 输出

```
9293681
15578602
849742
```

# AI分析结果



# 唯一算法分类  
并查集、启发式合并、离线处理

---

## 综合分析与结论  
**核心思路**：  
1. **时间倒流**：将断边操作离线后逆序处理，转化为加边操作，利用并查集维护连通性  
2. **启发式合并**：用 map 存储各连通块信仰人数，小集合合并到大集合保证 O(nlogn) 时间复杂度  
3. **概率计算**：预处理阶乘与逆元，通过组合数公式 C(m,k)/C(n,k) 快速计算概率  

**可视化设计要点**：  
- **动画流程**：  
  1. 初始显示所有城市节点与未切断的边（蓝色）  
  2. 倒序处理操作时，加边操作触发两个连通块合并动画（大集合吞噬小集合）  
  3. 查询操作高亮当前连通块（黄色脉冲效果）  
- **高亮机制**：  
  - 红色闪烁：当前处理的断边操作逆转为加边  
  - 绿色数字跳动：合并时小集合的信仰数据流向大集合  
- **像素风格**：  
  - 城市节点用 16x16 像素方块表示，不同信仰用不同颜色（红/绿/蓝）  
  - 道路用 2 像素宽的线条连接，断边时显示断裂动画（像素碎片飞溅）  

---

## 题解清单 (≥4星)  

### 1. 官方题解（作者：玫葵之蝶）★★★★★  
**亮点**：  
- 首次提出时间倒流与启发式合并的核心思路  
- 明确组合数公式推导过程  
- 时间复杂度分析严谨  

### 2. ACINE 题解 ★★★★☆  
**亮点**：  
- 模块化代码结构（合并/查询/逆元分离）  
- 详细注释关键数据结构的操作  
- 附带调试心得："变量打错导致提交几十次"，极具警示意义  

### 3. yzxoi 题解 ★★★★☆  
**亮点**：  
- 使用 vector 存储信仰类型简化合并逻辑  
- 独立实现 find/erase 操作避免 map 迭代器失效  
- 代码中直接标注关键公式推导位置  

---

## 最优思路或技巧提炼  

### 关键技巧 1：离线时间倒流  
```cpp  
// 预处理所有断边标记  
for(int i=1;i<=q;i++) if(op==2) mark_edge(x);  
// 倒序处理时，断边操作转为加边  
for(int i=q;i>=1;i--){  
    if(op==2) merge(edge[x].u, edge[x].v);  
    else if(op==1) undo_add_people();  
}
```

### 关键技巧 2：启发式合并  
```cpp  
void merge(int a, int b) {
    a = find(a); b = find(b);
    if(a == b) return;
    if(mp[a].size() > mp[b].size()) swap(a,b); // 小集合并入大集合
    for(auto& [faith,cnt] : mp[a]) {
        mp[b][faith] += cnt; // 信仰数据迁移
    }
    fa[a] = b; // 并查集指向
}
```

### 关键技巧 3：逆元快速计算  
```cpp  
LL inv(LL x) { // 费马小定理求逆元
    return fast_pow(x, MOD-2); 
}
LL C(LL n, LL k) { // 组合数公式
    return fac[n] * inv(fac[k]) % MOD * inv(fac[n-k]) % MOD;
}
```

---

## 同类型题推荐  
1. **P1197 [JSOI2008]星球大战**（离线处理断边连通性）  
2. **P3301 [SDOI2013]方程**（组合数取模与逆元计算）  
3. **P4219 [BJOI2014]大融合**（动态树维护连通块信息）  

---

## 个人心得摘录  
> "出题人发题解不带代码，手动调了半天发现变量打反...这提醒我们合并时务必检查父子节点指向" —— ACINE 调试经历  

> "随机数据下 map 合并表现优异，但理论上 Splay 合并更优" —— 官方题解中的优化暗示  

---

## 复古游戏化动画演示方案  
**核心元素**：  
- **8-bit 音效**：  
  - `merge.wav`：合并时播放类似《吃豆人》的吞咽音效  
  - `query.wav`：查询成功时播放《超级马里奥》金币音效  
- **像素动画**：  
  ```javascript
  // Canvas 绘制合并动画
  function drawMerge(a, b) {
      let small = a.size < b.size ? a : b;
      let particles = createParticles(small); // 生成小集合像素碎片
      particles.forEach(p => {
          p.moveTo(b.pos); // 碎片飞向大集合位置
          if(p.reached) playSound('merge.wav'); 
      });
  }
  ```
- **自动演示模式**：  
  ```javascript
  autoPlay() {
      let ops = reversed(operations); // 倒序操作列表
      ops.forEach(op => {
          highlightCurrentOp(op);
          simulateStep(op); // 自动执行每一步
          delay(1000); // 可调节速度
      });
  }
  ```

---
处理用时：80.37秒
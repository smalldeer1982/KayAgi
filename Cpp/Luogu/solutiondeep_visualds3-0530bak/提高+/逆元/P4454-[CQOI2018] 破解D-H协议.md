# 题目信息

# [CQOI2018] 破解D-H协议

## 题目背景

Diffie-Hellman 密钥交换协议是一种简单有效的密钥交换方法。它可以让通讯双方在没有事先约定**密钥**的情况下，通过**不安全**（可能被窃听）**的信道**确定一个**安全的密钥** $K$，用于加密之后的通讯内容。

## 题目描述

假定通讯双方名为 Alice 和 Bob，协议的工作过程描述如下（其中 $\bmod$ 表示取模运算）：

1. 协议规定一个**固定的**质数 $P$，以及模 $P$ 的一个原根 $g$。**$\boldsymbol P$ 和 $\boldsymbol g$ 的数值都是公开的，无需保密。**

2. Alice 生成一个随机数 $a$，并计算 $A=g^a\bmod P$，将 $A$ 通过不安全信道发送给 Bob。

3. Bob 生成一个随机数 $b$，并计算 $B=g^b\bmod P$，将 $B$ 通过不安全信道发送给 Alice。

4. Bob 根据收到的 $A$ 计算出**密钥** $K=A^b \bmod P$，而 Alice 根据收到的 $B$ 计算出 $K=B^a\bmod P$。

5. 双方得到了相同的 $K$，即 $g^{ab} \bmod P$。$K$ 即之后通讯的加密密钥。

可见，这个过程中可能被窃听的只有 $A,B$，而 $a,b,K$ 是保密的。并且根据 $A,B,P,g$ 这 $4$ 个数，不能轻易计算出 $K$，因此 $K$ 可以作为一个安全的密钥。

当然安全是相对的，该协议的安全性取决于数值的大小，通常 $a,b,P$ 都选取数百位以上的大整数以避免被破解。然而如果 Alice 和 Bob 编程时偷懒，为了避免实现大数运算，选择的数值都小于 $2^{31}$，那么破解他们的密钥就比较容易了。

$T$ 次给定窃听得到的 $A,B$，你需要尝试破解出**密钥** $K$。


## 说明/提示

对于 $30\%$ 的数据，$2\le A,B,P\le 1000$；

对于 $100\%$ 的数据，$2\le A,B<P<2^{31}，2\le g<20，1\le n\le 20$。

$\text{Statement fixed by @Starrykiller.}$

## 样例 #1

### 输入

```
3 31
3
27 16
21 3
9 26```

### 输出

```
4
21
25```

# AI分析结果



---

**唯一算法分类**：BSGS（大步小步算法）

---

### **题解思路、算法要点与解决难点**

**核心逻辑**：  
题目要求根据 $A = g^a \mod P$ 和 $B = g^b \mod P$ 求出 $K = g^{ab} \mod P$。通过 **BSGS 算法**求解离散对数问题，得到 $a$ 或 $b$ 后，利用快速幂计算 $K = B^a \mod P$ 或 $K = A^b \mod P$。

**算法要点**：  
1. **BSGS 分块思想**：将指数 $x$ 表示为 $x = im - j$，预处理哈希表存储 $g^{im} \mod P$，枚举 $j$ 匹配 $Ag^j \mod P$。  
2. **快速幂优化**：高效计算大数幂取模。  
3. **哈希表优化**：使用 `unordered_map` 或手写哈希表加速查询。

**解决难点**：  
- **分块预处理**：将问题分解为 $\sqrt{P}$ 规模的子问题，降低时间复杂度至 $O(\sqrt{P})$。  
- **逆元处理**：通过改写指数形式避免逆元计算（如 $x = im - j$）。

---

### **题解评分与推荐（≥4星）**

1. **Leonid 的题解（4星）**  
   - **亮点**：代码简洁，直接调用 STL `map`，适合快速理解 BSGS 流程。  
   - **缺点**：`map` 效率略低，但可通过替换为 `unordered_map` 优化。  
   - **核心代码**：  
     ```cpp
     ll BSGS(ll a, ll b, ll p) {
         // 预处理哈希表，分块查询
     }
     ```

2. **LeavingZzz 的题解（4星）**  
   - **亮点**：手写哈希表提升效率，详细注释 BSGS 分块逻辑。  
   - **缺点**：代码稍长，但更贴近竞赛实践需求。  
   - **核心代码**：  
     ```cpp
     struct Hash_table { 
         // 手写哈希表实现
     };
     ```

3. **MY 的题解（4星）**  
   - **亮点**：代码规范，使用 `unordered_map`，附加 BSGS 学习笔记链接。  
   - **核心代码**：  
     ```cpp
     int BSGS(int a, int b, int p) {
         // 预处理与分块查询
     }
     ```

---

### **最优思路提炼**

1. **BSGS 分块优化**：  
   - 预处理 $g^{im} \mod P$ 存入哈希表，枚举 $j$ 计算 $Ag^j \mod P$，匹配哈希表项。  
   - **代码片段**：  
     ```cpp
     ll m = ceil(sqrt(p));
     for (ll i=1; i<=m; i++) // 预处理 g^{im}
     for (ll j=0; j<m; j++)  // 枚举 j 计算 Ag^j
     ```

2. **快速幂优化指数计算**：  
   - 使用快速幂计算 $B^a \mod P$，时间复杂度 $O(\log a)$。  
   - **代码片段**：  
     ```cpp
     ll qpow(ll a, ll b, ll p) {
         // 快速幂实现
     }
     ```

---

### **可视化与算法演示**

**动画方案设计**：  
1. **分块预处理阶段**：  
   - 显示 $g^{im} \mod P$ 的计算过程，用**蓝色方块**表示当前计算的块。  
   - 哈希表填充时，用**绿色高亮**新插入的键值对。  
2. **查询匹配阶段**：  
   - 枚举 $j$ 时，用**黄色高亮**当前计算的 $Ag^j \mod P$，并在哈希表中**红色闪烁**匹配项。  
3. **复古像素风格**：  
   - 使用 **16色像素网格** 展示哈希表状态，每一步计算触发 **8-bit 音效**。  
   - **音效设计**：  
     - 预处理完成时播放「升级」音效，匹配成功时播放「胜利」音效。

**交互设计**：  
- **控制面板**：支持暂停/继续、调整动画速度（1x/2x/0.5x）。  
- **自动演示模式**：按步骤自动执行 BSGS 的分块与查询，模拟 AI 解题流程。

---

### **同类型题推荐**

1. **P3846 [TJOI2007] 可爱的质数**  
   - 直接应用 BSGS 算法求解离散对数。  
2. **P2485 [SDOI2011] 计算器**  
   - 综合考察快速幂、逆元与 BSGS。  
3. **P3306 [SDOI2013] 随机数生成器**  
   - 结合递推公式与 BSGS 求解同余方程。

---

**代码片段（BSGS 核心逻辑）**：  
```cpp
ll BSGS(ll a, ll b, ll p) {
    unordered_map<ll, ll> hash;
    ll m = ceil(sqrt(p)), t = 1;
    for (ll i = 1; i <= m; i++) {
        t = t * a % p;
        hash[t] = i; // 预处理 g^{im}
    }
    ll inv_am = qpow(t, p-2, p); // 费马小定理求逆元
    t = b;
    for (ll i = 0; i < m; i++) {
        if (hash.count(t)) 
            return i * m + hash[t];
        t = t * inv_am % p; // 逆元优化
    }
    return -1;
}
```

---

**总结**：通过 BSGS 分块降低离散对数问题复杂度，结合快速幂高效求解。可视化设计通过分阶段高亮与复古交互增强理解，适用于教学与竞赛训练。

---
处理用时：84.48秒
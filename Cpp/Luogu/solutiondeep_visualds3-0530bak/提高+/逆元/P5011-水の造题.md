# 题目信息

# 水の造题

## 题目背景

第一分钟,$CYJian$说:"要有样子."于是便有了$k$种动作..

第二分钟,$CYJian$说:"要有活力."于是便有了$k$种动作组成的总动作数为$N$的搏击操.

第三分钟,$CYJian$说:"要有数学."于是便有了一套搏击操的威力.

第四分钟,$CYJian$说:"数字要小."于是便有了一个伟大的模数$19491001$.

第五分钟,$CYJian$说:"要有规律."于是便有了一套搏击操威力的计算方法.

第六分钟,$CYJian$说:"要有限制."于是便有了时空限制以及数据范围.

第七分钟,$CYJian$说:"要有答案."于是便有了这道题让你做掉.

...

第*分钟,巨佬$Imagine$说:"数据太水."于是蒟蒻出题人疯了..(详见数据范围)

## 题目描述

现在有一套由$k$种动作组成的动作总数为$N$的搏击操.

已知第$1$,$2$...$k$个动作的威力为$a[1...k]$

且如果第一个动作后紧接着第二个动作,则威力会额外加上$a[1]+a[2]$

如果第二个动作后紧接着第三个动作,则威力会额外加上$a[2]+a[3]$

...

如果第$k$个动作后紧接着第一个动作,则威力会额外加上$a[k]+a[1]$

请求出最后动作的期望威力..

当然,还是要用伟大的模数$19491001$来膜一膜的...

## 说明/提示

样例解释：

```
x-y 表示第一个动作为x，第二个动作为y

1-1 : 1+1=2
1-2 : 1+2+(1+2)=6
1-3 : 1+3=4
1-4 : 1+4=5
1-5 : 1+5=6
1-6 : 1+6=7
2-1 : 2+1=3
2-2 : 2+2=4
2-3 : 2+3+(2+3)=10
2-4 : 2+4=6
2-5 : 2+5=7
2-6 : 2+6=8
3-1 : 3+1=4
3-2 : 3+2=5
3-3 : 3+3=6
3-4 : 3+4+(3+4)=14
3-5 : 3+5=8
3-6 : 3+6=9
4-1 : 4+1=5
4-2 : 4+2=6
4-3 : 4+3=7
4-4 : 4+4=8
4-5 : 4+5+(4+5)=18
4-6 : 4+6=10
5-1 : 5+1=6
5-2 : 5+2=7
5-3 : 5+3=8
5-4 : 5+4=9
5-5 : 5+5=10
5-6 : 5+6+(5+6)=22
6-1 : 6+1+(6+1)=14
6-2 : 6+2=8
6-3 : 6+3=9
6-4 : 6+4=10
6-5 : 6+5=11
6-6 : 6+6=12

2+6+4+5+6+7+3+4+10+6+7+8+4+5+6+14+8+9+5+6+7+8+18+10+6+7+8+9+10+22+14+8+9+10+11+12=294

294/36=49/6

1/6 = 16242501 (mod 19491001)

ans = 49 * 16242501 mod 19491001 = 16242509
```

$Subtask 1$($20 pts$):$1 \leq N \leq 10 \qquad 1 \leq k \leq 7$ 

$Subtask 2$($20 pts$):$1 \leq N \leq 10^6 \qquad 1 \leq k \leq 7$ 

$Subtask 3$($20 pts$):$1 \leq N \leq 10^{40000} \qquad 1 \leq k \leq 7$ 

$Subtask 4$($20 pts$):$1 \leq N \leq 10^{10^6} \qquad 1 \leq k \leq 7$ 

$Subtask 5$($20 pts$):$1 \leq N \leq 10^{10^6} \qquad 1 \leq k \leq 10^6$ 

保证所有的数据: $1 \leq a[i] \leq 10^7$

## 注意:本题捆绑测试

小提示：

可以用下面的inv(x)求出x的逆元：

```
long long mod = 19491001;

long long quick_pow(long long x, int k) {
    long long res = 1;
    while(k) {
        if(k & 1) res = res * x % mod;
        x = x * x % mod;
        k >>= 1;
    }
    return res;
}

long long inv(long long x) {
    return quick_pow(x, mod - 2);
}
```

## 样例 #1

### 输入

```
2
6
1 2 3 4 5 6
```

### 输出

```
16242509
```

# AI分析结果



### 算法分类
**期望计算、数学推导与模运算**

---

### 题解思路与核心难点

#### **核心思路**
1. **期望拆分**：将总威力拆分为「单独动作贡献」和「相邻组合额外贡献」。
2. **数学推导**：
   - **单独贡献**：每个动作在 $N$ 个位置出现的期望次数为 $\frac{N}{k}$，总贡献为 $\frac{N}{k} \sum a_i$。
   - **相邻组合贡献**：每个相邻组合出现的期望次数为 $\frac{N-1}{k^2}$，总贡献为 $\frac{2(N-1)}{k^2} \sum a_i$。
3. **合并公式**：总期望为 $\frac{\sum a_i \cdot (Nk + 2N - 2)}{k^2}$，通过逆元计算模结果。

#### **解决难点**
- **大数处理**：$N$ 可达 $10^{10^6}$，需逐位取模。
- **公式简化**：通过线性期望性质避免动态规划，直接推导出闭式解。

---

### 题解评分（≥4星）

1. **Imakf（5星）**
   - **亮点**：从期望线性性出发，思路清晰，代码简洁。
   - **代码**：高效处理大数取模，逻辑明确。
2. **VERACITY（4.5星）**
   - **亮点**：分步计算贡献，公式推导详细。
   - **代码**：直接实现公式，可读性强。
3. **JPGOJCZX（4星）**
   - **亮点**：通过动态规划推导闭式解，思路完整。
   - **代码**：结合递推公式优化计算。

---

### 最优思路与技巧

1. **数学建模**：将问题拆解为独立事件与组合事件的期望叠加。
2. **逆元优化**：利用费马小定理快速计算模意义下的除法。
3. **大数取模**：逐位读取 $N$ 并取模，避免高精度计算。

---

### 类似题目推荐

1. **P3758 可乐**：期望与组合贡献的拆分。
2. **P1654 OSU!**：独立事件与连续事件的期望计算。
3. **P1365 WJMZBMR打osu! / Easy**：动态规划结合期望递推。

---

### 可视化与算法演示

#### **动画设计**
1. **贡献拆分**：
   - **单独动作**：每个位置高亮显示，动态累加贡献。
   - **相邻组合**：用箭头连接相邻动作，显示额外加成。
2. **公式推导**：
   - 逐步展开公式 $\frac{Nk + 2(N-1)}{k^2} \sum a_i$，颜色标记各变量。
3. **逆元计算**：
   - 展示快速幂计算逆元的过程，动态显示模运算步骤。

#### **复古像素风格**
- **Canvas 绘制**：动作序列以像素方块表示，组合加成时触发闪烁特效。
- **音效**：
  - 单步执行时播放 8-bit 点击音效。
  - 公式推导完成时播放通关音效。

---

### 核心代码片段

```cpp
// 读入大数 N 并取模
ll n = 0;
char ch;
while (isdigit(ch = getchar())) 
    n = (n * 10 + ch - '0') % MOD;

// 计算总公式
ll inv_k = qpow(k, MOD-2); // 逆元
ll inv_k2 = inv_k * inv_k % MOD;
ll ans = (sum * (n * k % MOD + 2 * (n - 1) % MOD)) % MOD;
ans = ans * inv_k2 % MOD;
```

---

### 总结

本题通过数学建模与期望拆分，将复杂问题转化为简洁的闭式解，结合快速幂与大数处理技巧高效实现。核心在于理解独立事件与组合事件的贡献叠加，并熟练运用模运算优化。

---
处理用时：79.22秒
# 题目信息

# 派遣

## 题目背景

Steve在洞穴里发现了一张地图，上面标识出了黑暗势力的据点，他决定派遣一些士兵前去

## 题目描述

然而，这些士兵不一定具有与黑暗势力作战的能力，因而最终被派遣的士兵是未知的

为了尽量了解派遣的士兵的情况，Steve需要你帮忙计算一些值

Steve一共有$t$支军队，每支军队的人数都不同

每支军队可以按一定标准排成$n \times k$的方阵，每个士兵的位置可以用坐标$(x,y)$表示，其中$0\le x < n,0 \le y <k$，这个士兵的编号就是$x\cdot k+y$

位于$(0,0)$位置的士兵是队长，无论任何情况都会被派遣

对于其余的士兵，可以派遣，也可以不派遣

一支$n \times k$的军队的能力值是这样定义的：

如果所有士兵都被派遣，那么能力值是$1$

如果位于$(x,y)$位置的士兵(编号为$i$)未被派遣，那么能力值变为原来的$\frac{x}{i-x}$

例如，对于一支$2\times 2$的军队，如果$(1,1)$位置的士兵(编号为$3$)未被派遣，其他士兵都被派遣，那么能力值为$\frac{1}{3-1}=\frac{1}{2}$

如果$(1,1)$位置的士兵(编号为$3$)和$(0,1)$位置的士兵(编号为$1$)都未被派遣，那么能力值为$\frac{1}{3-1} \times \frac{0}{1-0} = 0$

如果$(1,1)$位置的士兵(编号为$3$)和$(1,0)$位置的士兵(编号为$2$)都未被派遣，那么能力值为$\frac{1}{3-1} \times \frac{1}{2-1} = \frac{1}{2}$

现在，Steve需要你为每一支军队，计算出所有可能派遣方案的能力值之和

为了避免出现分数，输出结果是模$1145141$意义下的值

如果这个值不存在，那么输出$-1$

也就是，如果你的答案为既约分数$\frac{p}{q}$，你需要找到一个最小的非负整数$a$，满足$p\equiv q\cdot a(mod 1145141)$，并输出这个值，如果不存在这样的整数，就输出$-1$

提示：$1145141$是质数

## 说明/提示

第四组数据实际值为$\frac{7}{3}$

第五组数据实际值为$\frac{55}{9}$

第一组数据解释：

如果所有士兵都被派遣，那么能力值为$1$

如果$(1,1)$位置的士兵(编号为$3$)未被派遣，那么能力值为$\frac{1}{3-1}=0.5$

如果$(0,1)$位置的士兵(编号为$1$)未被派遣，那么能力值为$\frac{0}{1-0} = 0$

如果$(1,1)$位置的士兵(编号为$3$)和$(0,1)$位置的士兵(编号为$1$)未被派遣，那么能力值为$\frac{1}{3-1} \times \frac{0}{1-0} = 0$

如果$(1,0)$位置的士兵(编号为$2$)未被派遣，那么能力值为$\frac{1}{2-1} = 1$

如果$(1,0)$位置的士兵(编号为$2$)和$(1,1)$位置的士兵(编号为$3$)未被派遣，那么能力值为$\frac{1}{2-1} \times \frac{1}{3-1}=0.5$

如果$(1,0)$位置的士兵(编号为$2$)和$(0,1)$位置的士兵(编号为$1$)未被派遣，那么能力值为$\frac{1}{2-1} \times \frac{0}{1-0}=0$

如果只有队长被派遣，那么能力值为$\frac{1}{3-1} \times \frac{0}{1-0} \times \frac{1}{2-1}=0$

所以，答案为$1+0.5+0+0+1+0.5+0+0=3$

数据范围：

对于所有数据，$n\ge 1,k\ge 2$

Subtask1是比赛时的测试数据：

测试点| 分值| t | $n\le$| $k\le$
:-: | :-: | :-: | :-: | :-:
1| 10| 5| 5| 5| 
2| 11| 100| 100| 100|
3| 12| 100000| 5| 100000|
4| 13| 100000| 100000| 5|
5| 16| 5| 100000| 100000|
6| 18| 5| $10^9$| $10^9$|
7| 20| 100000| $10^9$|$10^9$|

Subtask2包括两个不计分的Hack数据，均满足$t=1$

#8满足#7的性质

#9满足#5的性质

## 样例 #1

### 输入

```
5
2 2
3 3
1 4
2 4
3 4
```

### 输出

```
3
7
1
381716
127244
```

# AI分析结果



## 算法分类  
**数学推导与模运算**

---

## 题解思路与核心难点

### 核心公式推导
所有题解的核心思路是推导出能力值总和的数学表达式：
$$
\text{答案} = \frac{(nk-1)!}{(nk-n)! \cdot (k-1)^{n-1} \cdot (n-1)!}
$$
通过分解分子分母的阶乘和质因子次数，结合模数性质进行高效计算。

### 解决难点
1. **大数阶乘模**  
   利用威尔逊定理 $(p-1)! \equiv -1 \ (\text{mod}\ p)$，递归处理大数阶乘模，时间复杂度降至 $\mathcal{O}(\log n)$。
2. **质因子次数判断**  
   统计分子和分母中模数 $p=1145141$ 的因子次数，若分母次数 > 分子次数则输出 -1。
3. **逆元计算**  
   预处理阶乘和逆元，通过费马小定理快速求逆元。

---

## 题解评分 (≥4星)

### 1. Alex_Wei 的题解（⭐️⭐️⭐️⭐️⭐️）
- **亮点**：数学推导清晰，递归计算阶乘模的代码简洁，处理超大 $n,k$ 高效。
- **代码片段**：
  ```cpp
  ll cal(ll v){return v<mod?fc[v]:fc[v%mod]*((v/mod)&1?-1:1)%mod*cal(v/mod)%mod;}
  ```

### 2. Thinking 的题解（⭐️⭐️⭐️⭐️）
- **亮点**：使用结构体同时记录值和质因子次数，逻辑清晰。
- **核心代码**：
  ```cpp
  data getf(ll x){
    return x<mod?data(f[x],0ll):data((ll)fp(f[mod-1],x/mod)*f[x%mod]%mod,x/mod)*getf(x/mod);
  }
  ```

### 3. Hope2075 的题解（⭐️⭐️⭐️⭐️）
- **亮点**：分块处理阶乘和逆元，适合理解模运算的分治思想。
- **代码片段**：
  ```cpp
  if(c>0) puts("0");
  else if(c==0) write(num2);
  else puts("-1");
  ```

---

## 最优思路与技巧

### 关键技巧
1. **递归阶乘模**  
   将 $v!$ 拆分为 $(v \% p)! \cdot (-1)^{v/p} \cdot (v/p)!$，递归处理。
2. **质因子次数比较**  
   统计分子分母中 $p$ 的因子次数差，快速判断无解情况。
3. **逆元预计算**  
   预处理 $1$ 至 $p-1$ 的阶乘和逆元，加速计算。

---

## 类似题目推荐
1. **P3807 【模板】卢卡斯定理**  
   （组合数模质数，需递归分解）
2. **P2613 【模板】有理数取余**  
   （分数模运算，逆元应用）
3. **P2480 [SDOI2010]古代猪文**  
   （大数阶乘模与质因子分解）

---

## 可视化设计

### 算法演示方案
1. **阶乘分解动画**  
   - **颜色标记**：红色高亮当前递归层数，绿色显示余数部分 $(v \% p)$，黄色显示商部分 $(v/p)$。
   - **步进控制**：单步展示如何将 $v!$ 分解为 $(v \% p)! \cdot (-1)^{v/p} \cdot (v/p)!$。

2. **质因子次数统计**  
   - **动态图表**：柱状图对比分子和分母的质因子次数，红色柱超出时触发失败音效。

### 复古像素风格
- **8位音效**：递归时播放“滴”声，质因子统计完成时播放“叮”声。
- **Canvas绘制**：用像素方块表示阶乘的分解过程，递归层数以不同颜色堆叠显示。

---

## 核心代码实现（Alex_Wei 版）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 1145141;
ll fc[mod];

ll cal(ll v) {
    return v < mod ? fc[v] : fc[v % mod] * ((v / mod) & 1 ? -1 : 1) % mod * cal(v / mod) % mod;
}

int main() {
    int t; cin >> t;
    fc[0] = 1;
    for(int i=1; i<mod; i++) fc[i] = fc[i-1] * i % mod;
    while(t--) {
        ll n, k; cin >> n >> k;
        if((k-1) % mod == 0) cout << "-1\n";
        else {
            ll l = n*k - n, r = n*k - 1;
            // 计算分子分母的质因子次数差
            // ...（省略具体比较代码）
            cout << (cal(r) * inv(cal(l)) % mod * inv(ksm(k-1, n-1)) % mod) << '\n';
        }
    }
}
```

---

## 个人心得摘录
- **Alex_Wei**：强调阶乘模的递归拆分是核心，需注意负号处理 `((v/mod) & 1 ? -1 : 1)`。
- **Thinking**：通过结构体封装值和次数，简化了分式模运算的逻辑。

---
处理用时：79.73秒
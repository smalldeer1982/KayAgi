# 题目信息

# [入门赛 #9] 最澄澈的空与海 (Hard Version)

## 题目背景

材料 1：

> 请小心地计算下面的算式：$138 - 108 \div 6 = ?$  
> 你大概难以置信，这个算式的计算结果竟然是 $5!$

材料 2：

> 对于一个正整数 $x$，$x! = 1 \times 2 \times \cdots \times (x - 1) \times x$。我们称 $x!$ 为 $x$ 的阶乘。  
> 特别的，$0! = 1$。

显然，「$138 - 108 \div 6 = 5$」是错误的，而「$(138 - 108) \div 6 = 5$」是正确的，所以对材料 1 中的内容，部分读者会认为「作者没有搞清加减乘除的运算优先级关系而犯错」。

然而，材料 1 最后一行的叹号并不是标点符号，而是材料 2 提到的「阶乘」。

考虑到这一点，「$138 - 108 \div 6 = 5! = 1 \times 2 \times \cdots \times 5 = 120$」显然就是正确的了。

## 题目描述

然而，此题可能与上面的题目背景关系不是很大。

我们会给你 $T$ 组数据，每组数据包括一个正整数 $n$。

对于每组数据，请你帮助求出满足以下条件的整数三元组 $(x, y, z)$ 的组数：

1. $x \geq 0$，$z \geq 1$。
2. $x - y \div z = n!$ 且 $(x - y) \div z = \dfrac{n!}{n}$。

由于答案可能过大，因此你需要输出答案对 $998244353$ 取模后的结果。

不难注意到答案有可能为 $\infty$，这时请按照「输出格式」要求进行处理。

**请注意此处应满足 $(x - y) \div z = \dfrac{n!}{n}$ 而不是 $= n$。**

请注意这里的 $\div$ 不是向下取整的整除，这显然意味着你需要保证 $y \div z$ 和 $(x - y) \div z$ 为整数。

## 说明/提示

### 样例 1 解释

样例中的具体三元组如下：

| $n$ | 所有可能的三元组 |
| :----------: | :----------: |
| $2$ | $(2, 0, 2)$ |
| $3$ | $\begin{matrix}(8, 4, 2) & (5, -5, 5) & (6, 0, 3)\end{matrix}$ |
| $4$ | $\begin{matrix}(19, -95, 19) & (21, -21, 7) & (24, 0, 4) \\ (27, 9, 3) & (20, -40, 10) & (36, 24, 2)\end{matrix}$ |

### 数据规模与约定

对于前 $20\%$ 的数据，保证 $T \leq 10$，$n \leq 10$。

对于前 $40\%$ 的数据，保证 $n \leq 10 ^ 3$。

对于另外 $20\%$ 的数据，保证 $T = 1$。

对于 $100\%$ 的数据，保证 $1 \leq T \leq 10 ^ 5$，$1 \leq n \leq 10 ^ 6$。

## 样例 #1

### 输入

```
3
2
3
4```

### 输出

```
1
3
6```

# AI分析结果



### 算法分类
数论（因数分解与预处理）

---

### 题解思路与解决难点

#### 核心思路推导
1. 联立方程组消元，得到关键式：`x = (n-1)(n-1)! * z/(z-1)`
2. 分析得出 `z-1` 必须是 `(n-1)(n-1)!` 的因数
3. 问题转化为计算 `(n-1)(n-1)!` 的因数个数

#### 关键难点与突破
1. **大规模质因数分解**：通过线性筛法预处理每个数的最小质因数，将分解复杂度优化至 `O(log n)`
2. **动态维护因数个数**：维护质因数指数数组，每次增量更新答案
3. **离线预处理优化**：一次性计算所有可能的 `n` 对应的答案，实现 `O(1)` 查询

#### 实现要点对比
| 题解作者       | 数据结构                  | 核心优化手段                          |
|----------------|---------------------------|---------------------------------------|
| Maxmilite      | 线性筛+动态维护质因数指数 | 逆元优化除法，预处理阶乘贡献          |
| __ryp__        | 离线排序预处理            | 按需分解质因数，减少重复计算          |
| Empty_Dream    | 最小质因数分解法          | 双倍贡献机制与撤回操作                |

---

### 题解评分（≥4星）

1. **Maxmilite（5星）**
   - 亮点：完整数学推导，动态维护答案的逆元优化
   - 代码：使用线性筛预处理最小质因数，支持 `1e6` 量级

2. **__ryp__（4.5星）**
   - 亮点：离线处理巧妙减少重复计算，代码简洁
   - 技巧：将查询按 `n` 排序后增量处理

3. **Empty_Dream（4星）**
   - 亮点：最小质因数分解实现清晰，双倍贡献机制
   - 优化：通过 `update` 函数统一处理质因数增减

---

### 最优思路提炼

#### 核心技巧
```python
# 伪代码：预处理阶乘因数个数
初始化线性筛记录最小质因数
预计算逆元表

ans = 1  # 当前因数个数乘积
for i in 1..1e6:
    分解 i 的质因数（利用最小质因数）
    对每个质因数 p^cnt:
        ans /= (当前p的指数+1)
        更新p的指数 += 2*cnt  # 因式分解i^2
        ans *= (新指数+1)
    记录 ans 到 f[i]
    撤销i的贡献（保留阶乘部分）
```

#### 关键优化
- **线性筛最小质因数**：将质因数分解复杂度从 `O(√n)` 降至 `O(log n)`
- **逆元预计算**：将模运算中的除法转为乘法
- **增量维护答案**：避免重复计算质因数指数

---

### 同类型题与算法套路

#### 通用解法
- **阶乘相关因数问题**：预处理每个质数在阶乘中的指数
- **多组查询优化**：离线排序+增量处理

#### 类似题目
1. [P2048 分解质因数](https://www.luogu.com.cn/problem/P2048)（质因数分解训练）
2. [P3938 阶乘问题](https://www.luogu.com.cn/problem/P3938)（阶乘性质应用）
3. [P2158 约数个数和](https://www.luogu.com.cn/problem/P2158)（因数个数公式应用）

---

### 可视化设计

#### 动画演示方案
```javascript
// 伪代码：核心流程可视化
class Visualization {
  constructor() {
    this.primeGrid = new PixelGrid(100, 100); // 质数分布网格
    this.factorBars = new BarChart();         // 质因数指数条形图
    this.currentNumber = 1;                   // 当前处理的数
  }

  step() {
    // 分解当前数的质因数（高亮对应网格）
    let factors = getPrimeFactors(this.currentNumber);
    this.primeGrid.highlightCells(factors);

    // 更新因数个数条形图
    factors.forEach(p => {
      this.factorBars.increase(p, 2); // 双倍贡献
      this.factorBars.animateUpdate();
    });

    // 记录答案后撤回单次贡献
    factors.forEach(p => {
      this.factorBars.decrease(p, 1);
      this.factorBars.animateUpdate();
    });

    this.currentNumber++;
  }
}
```

#### 复古游戏化要素
- **8位音效**：
  - `分解质因数` → 短促 "哔" 声
  - `更新答案` → 上升音阶
  - `完成预处理` → 经典通关音乐
- **像素风格**：
  - 质数用绿色像素块，合数用红色
  - 因数个数用横向条形图表示，类似复古RPG状态栏

---

### 核心代码实现
```cpp
// 线性筛预处理最小质因数
void sieve(int maxn) {
    vector<int> mn(maxn+1);
    for(int i=2; i<=maxn; i++){
        if(!mn[i]) primes[++cnt]=i, mn[i]=i;
        for(int j=1; j<=cnt && primes[j]*i<=maxn; j++){
            mn[primes[j]*i] = primes[j];
            if(i%primes[j]==0) break;
        }
    }
}

// 动态维护因数个数
int ans = 1;
unordered_map<int, int> exp_cnt; // 质因数 -> 当前指数

void process(int x, int coeff) { // coeff=2表示i^2，=1表示撤回
    while(x > 1){
        int p = mn[x], cnt = 0;
        while(x % p == 0) x/=p, cnt++;
        ans = ans * inv[exp_cnt[p]+1] % MOD; // 移除旧贡献
        exp_cnt[p] += cnt * coeff;
        ans = ans * (exp_cnt[p]+1) % MOD;    // 添加新贡献
    }
}

// 预处理答案
for(int i=1; i<=1e6; i++){
    process(i, 2);   // 处理i^2的贡献
    f[i] = ans;      // 记录答案
    process(i, -1);  // 撤回i的贡献
}
```

---

### 个人心得摘录
> "在调试时发现，忘记处理n=1的特殊情况导致WA。阶乘类问题永远要注意边界条件！" —— Empty_Dream

> "线性筛的最小质因数分解法比试除法快10倍以上，处理1e6数据从TLE变成AC" —— __ryp__

---

### 知识拓展
**算术基本定理的应用**：任何大于1的整数都可以唯一分解为质数的幂次积。本题通过维护这些幂次来计算因数个数，是数论问题的典型解决方法。

---
处理用时：79.43秒
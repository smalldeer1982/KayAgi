# 题目信息

# [ZJOI2007] 矩阵游戏

## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。


## 样例 #1

### 输入

```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0
```

### 输出

```
No
Yes
```

# AI分析结果



### 算法分类：二分图最大匹配

---

### 题解思路与算法要点

**核心思路**  
将矩阵的**行**与**列**视为二分图的两个集合，每个黑格子 (i,j) 对应一条行i到列j的边。问题转化为判断是否存在完美匹配（n对匹配），即每行都能通过交换找到对应的列使得对角线上为黑格。

**解决难点**  
1. **建模转换**：理解行列交换不改变二分图结构的性质，即匹配数恒定。
2. **高效实现**：使用匈牙利算法（O(n³)）或网络流（Dinic，O(n²√n)）处理n=200的数据规模。

**算法对比**  
- **匈牙利算法**：代码简洁，适合快速实现，邻接矩阵或前向星存储。
- **网络流**：通过虚拟源汇点建模，Dinic算法适合大规模数据，需处理反向边。

---

### 题解评分（≥4星）

1. **俾斯麦的题解（★★★★☆）**  
   - 亮点：详细对比两种解法，代码注释清晰，优化clear函数减少memset开销。  
   - 代码：匈牙利实现高效，Dinic部分完整。

2. **cmwqf的题解（★★★★☆）**  
   - 亮点：图示直观，模型建立过程清晰，代码简短易理解。  
   - 引用："交换行列本质是节点重编号，不影响匹配数"。

3. **hs_black的题解（★★★★☆）**  
   - 亮点：代码最简，邻接表实现匈牙利算法，直接判断完美匹配。  
   - 代码：仅需30行，适合快速掌握核心逻辑。

---

### 最优技巧提炼

**关键思路**  
- 将行列视为二分图节点，黑格子为边，完美匹配即存在解。
- 行列交换仅改变节点编号，不改变边的关系，因此初始匹配决定结果。

**实现优化**  
- **邻接表存储**：节省空间，遍历更高效（适用于稀疏图）。
- **时间戳优化**：替代memset访问标记，提升匈牙利效率。

---

### 类似题目推荐

1. **P3386 【模板】二分图最大匹配**  
   - 基础模板题，练习匈牙利或Dinic实现。

2. **P1963 [NOI2009] 变换序列**  
   - 二分图匹配的变形，需构造字典序最小的匹配。

3. **P2764 最小路径覆盖问题**  
   - 将DAG路径覆盖转化为二分图匹配问题。

---

### 核心代码实现（匈牙利算法）

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int N=205;
int n,T,vis[N],match[N],G[N][N];

bool dfs(int u){
    for(int v=1;v<=n;++v)
        if(G[u][v] && !vis[v]){
            vis[v]=1;
            if(!match[v]||dfs(match[v])){
                match[v]=u;
                return true;
            }
        }
    return false;
}

int main(){
    scanf("%d",&T);
    while(T--){
        memset(match,0,sizeof(match));
        scanf("%d",&n);
        for(int i=1;i<=n;++i)
            for(int j=1;j<=n;++j)
                scanf("%d",&G[i][j]);
        
        int ans=0;
        for(int i=1;i<=n;++i){
            memset(vis,0,sizeof(vis));
            ans += dfs(i);
        }
        puts(ans==n?"Yes":"No");
    }
    return 0;
}
```

---

### 可视化算法设计

**动画演示方案**  
1. **网格绘制**：Canvas绘制n×n网格，黑格高亮为黄色。
2. **匹配过程**：  
   - 行节点（左侧）与列节点（右侧）以不同颜色区分。
   - 当前遍历的节点用闪烁边框标记，匹配边显示为绿色实线。
3. **交互控制**：  
   - 步进按钮单步执行DFS，显示vis数组和match数组变化。
   - 速度滑块调节自动播放速度（100ms~2s）。

**复古像素风格**  
- **颜色方案**：8位色，行节点（#FF5555），列节点（#5555FF），匹配边（#55FF55）。
- **音效**：匹配成功时播放8bit上升音效，失败时短促低音。
- **自动演示**：AI按DFS顺序自动选择节点，路径回溯时红色闪烁提示。

---

### 总结

本题通过巧妙的二分图建模，将看似复杂的行列交换转化为匹配问题。匈牙利算法以其简洁性成为首选，而网络流解法则展示了图论问题的通用性。可视化时通过动态展示匹配过程与复古元素结合，可有效提升理解与记忆。

---
处理用时：69.31秒
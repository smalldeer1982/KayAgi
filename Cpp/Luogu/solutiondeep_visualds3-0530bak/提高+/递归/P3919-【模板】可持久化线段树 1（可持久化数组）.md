# 题目信息

# 【模板】可持久化线段树 1（可持久化数组）

## 题目背景

**UPDATE : 最后一个点时间空间已经放大**

2021.9.18 增添一组 hack 数据 by @panyf

标题即题意

有了可持久化数组，便可以实现很多衍生的可持久化功能（例如：可持久化并查集）


## 题目描述

如题，你需要维护这样的一个长度为 $ N $ 的数组，支持如下几种操作


1. 在某个历史版本上修改某一个位置上的值

2. 访问某个历史版本上的某一位置的值


此外，每进行一次操作（**对于操作2，即为生成一个完全一样的版本，不作任何改动**），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组）



## 说明/提示

数据规模：

对于30%的数据：$ 1 \leq N, M \leq {10}^3 $

对于50%的数据：$ 1 \leq N, M \leq {10}^4 $

对于70%的数据：$ 1 \leq N, M \leq {10}^5 $

对于100%的数据：$ 1 \leq N, M \leq {10}^6, 1 \leq {loc}_i \leq N, 0 \leq v_i < i, -{10}^9 \leq a_i, {value}_i  \leq {10}^9$

**经测试，正常常数的可持久化数组可以通过，请各位放心**

~~数据略微凶残，请注意常数不要过大~~

~~另，此题I/O量较大，如果实在TLE请注意I/O优化~~

询问生成的版本是指你访问的那个版本的复制

样例说明：

一共11个版本，编号从0-10，依次为：

\* **0** : 59 46 14 87 41

\* **1** : 59 46 14 87 41

\* **2** : 14 46 14 87 41

\* **3** : 57 46 14 87 41

\* **4** : 88 46 14 87 41

\* **5** : 88 46 14 87 41

\* **6** : 59 46 14 87 41

\* **7** : 59 46 14 87 41

\* **8** : 88 46 14 87 41

\* **9** : 14 46 14 87 41

\* **10** : 59 46 14 87 91


## 样例 #1

### 输入

```
5 10
59 46 14 87 41
0 2 1
0 1 1 14
0 1 1 57
0 1 1 88
4 2 4
0 2 5
0 2 4
4 2 1
2 2 2
1 1 5 91```

### 输出

```
59
87
41
87
88
46```

# AI分析结果



## 算法分类
可持久化线段树（主席树）

---

## 综合分析与结论
### 题解思路与核心难点
题目要求维护数组的历史版本，支持**版本回退**与**单点修改**。核心难点在于如何高效存储所有版本并避免空间爆炸。各题解通过以下方案解决：

1. **可持久化线段树**（主流解法）  
   - **核心思想**：每个版本只复制修改路径上的节点，其余节点复用旧版本。  
   - **实现关键**：  
     - 维护每个版本的根节点，修改时从旧根出发创建新路径。  
     - 查询时直接访问旧版本的根节点，无需修改。  
   - **复杂度**：单次操作 $O(\log n)$ 时间，总空间 $O((n + m) \log n)$。

2. **离线 DFS + 回溯**（Elegia 题解）  
   - 将版本依赖关系建模为树，通过 DFS 遍历处理操作。  
   - 修改操作后回溯时恢复原值，适用于可逆操作。  
   - **适用性**：仅限离线场景，无法处理不可逆操作（如并查集合并）。

3. **STL rope 混分法**（panda_2134 题解）  
   - 使用 C++ 扩展库中的 `rope` 实现可持久化数组。  
   - **局限性**：常数较大，无法通过严格数据规模测试。

### 最优思路与技巧
- **路径复制**：仅复制受影响节点，复用未修改子树。  
- **版本根管理**：用数组维护每个版本的根节点，查询时直接索引。  
- **离线回溯优化**：若操作可逆，可通过 DFS 遍历版本树节省空间。

---

## 题解清单（≥4星）
1. **hyfhaha（★★★★★）**  
   - **亮点**：原理讲解清晰，配图展示节点复用机制，代码结构简洁。  
   - **关键代码**：  
     ```cpp
     int update(int node, int begin, int end, int x, int val) {
         node = clone(node); // 复制旧节点
         if (begin == end) tree[node].val = val;
         else {
             int mid = (begin + end) >> 1;
             if (x <= mid) tree[node].l = update(..., x, val);
             else tree[node].r = update(..., x, val);
         }
         return node;
     }
     ```

2. **Elegia（★★★★☆）**  
   - **亮点**：离线处理版本树，空间优化至 $O(n)$。  
   - **个人心得**：“操作可逆时，回溯法比主席树更高效”。

3. **pigeonN（★★★★☆）**  
   - **亮点**：指针实现可持久化线段树，代码风格易读。  
   - **技巧**：使用内存池预分配节点，避免动态内存开销。

---

## 核心代码实现
```cpp
struct Node {
    int l, r, val;
} tree[MAXN * 20];
int root[MAXN], cnt;

void build(int &rt, int l, int r, int a[]) {
    rt = ++cnt;
    if (l == r) { tree[rt].val = a[l]; return; }
    int mid = (l + r) >> 1;
    build(tree[rt].l, l, mid, a);
    build(tree[rt].r, mid + 1, r, a);
}

int update(int old_rt, int l, int r, int pos, int val) {
    int new_rt = ++cnt;
    tree[new_rt] = tree[old_rt]; // 克隆旧节点
    if (l == r) tree[new_rt].val = val;
    else {
        int mid = (l + r) >> 1;
        if (pos <= mid) tree[new_rt].l = update(tree[old_rt].l, l, mid, pos, val);
        else tree[new_rt].r = update(tree[old_rt].r, mid + 1, r, pos, val);
    }
    return new_rt;
}

int query(int rt, int l, int r, int pos) {
    if (l == r) return tree[rt].val;
    int mid = (l + r) >> 1;
    if (pos <= mid) return query(tree[rt].l, l, mid, pos);
    else return query(tree[rt].r, mid + 1, r, pos);
}
```

---

## 可视化设计
### 动画方案
1. **线段树结构展示**：  
   - **初始版本**：完整线段树结构，叶子节点为初始数组值。  
   - **修改操作**：高亮修改路径，新节点用绿色标记，旧节点灰色。  
   - **查询操作**：沿路径显示访问节点，终点值闪烁提示。

2. **像素风格**：  
   - **8 位调色板**：根节点红色，内部节点蓝色，叶子黄色。  
   - **Canvas 绘制**：网格布局，每个节点显示区间范围。  
   - **音效**：创建节点时播放“哔”声，查询成功时播放“叮”。

3. **交互控制**：  
   - **步进执行**：点击按钮逐步展示修改/查询过程。  
   - **版本切换**：下拉菜单选择历史版本，动态渲染对应树结构。

---

## 相似题目推荐
1. **P3834 静态区间第 k 小**  
   - 同样使用可持久化线段树，维护权值前缀和。

2. **P3402 可持久化并查集**  
   - 基于可持久化数组实现并查集的历史版本回退。

3. **P5055 可持久化文艺平衡树**  
   - 结合可持久化与平衡树，支持区间反转操作。

---
处理用时：75.52秒
# 题目信息

# 小白逛公园

## 题目背景

小新经常陪小白去公园玩，也就是所谓的遛狗啦…

## 题目描述

在小新家附近有一条“公园路”，路的一边从南到北依次排着 $n$ 个公园，小白早就看花了眼，自己也不清楚该去哪些公园玩了。

一开始，小白就根据公园的风景给每个公园打了分。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第 $a$ 个和第 $b$ 个公园之间（包括 $a, b$ 两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。

那么，就请你来帮小白选择公园吧。

## 说明/提示

### 数据规模与约定

对于 $100\%$ 的数据，$1 \le n \le 5 \times 10^5$，$1 \le m \le 10^5$，所有打分都是绝对值不超过 $1000$ 的整数。

## 样例 #1

### 输入

```
5 3
1
2
-3
4
5
1 2 3
2 2 -1
1 2 3```

### 输出

```
2
-1```

# AI分析结果



# 小白逛公园题解分析

## 唯一算法分类
线段树

---

## 题解思路与核心难点
### 核心算法流程
所有题解均采用线段树维护以下4个关键值：
1. **sum**：区间总和
2. **lmax**：以左端点开始的连续最大子段和
3. **rmax**：以右端点结束的连续最大子段和
4. **max**：区间最大子段和

**合并策略**（以节点合并为例）：
```python
left = 左子节点
right = 右子节点
new_node.sum = left.sum + right.sum
new_node.lmax = max(left.lmax, left.sum + right.lmax)
new_node.rmax = max(right.rmax, right.sum + left.rmax)
new_node.max = max(left.max, right.max, left.rmax + right.lmax)
```

### 解决难点
1. **跨区间合并**：当查询区间跨越左右子树时，需计算左子树的右端最大值与右子树的左端最大值之和
2. **负值处理**：所有题解强调必须包含至少一个元素，需在合并时判断是否舍弃负值
3. **查询优化**：返回结构体而非简单数值，递归查询时动态合并中间结果

---

## 高星题解清单（≥4星）
### 1. Unknown_Error（⭐⭐⭐⭐⭐）
- **亮点**：代码最精简，pushup函数逻辑清晰，直接处理maxr+maxl的三种情况
- **核心片段**：
```cpp
void pushup(Node &rt, const Node &ls, const Node &rs) {
    rt.maxv = max(ls.maxr + rs.maxl, max(ls.maxv, rs.maxv));
    rt.maxl = max(ls.maxl, ls.sumv + rs.maxl);
    rt.maxr = max(rs.maxr, rs.sumv + ls.maxr);
}
```

### 2. ez_lcw（⭐⭐⭐⭐）
- **亮点**：手绘示意图辅助理解区间合并，详细分步解释更新规则
- **个人心得**："注意题目没有保证x<=y，需手动交换"的踩坑提醒

### 3. Uranus（⭐⭐⭐⭐）
- **亮点**：结构体查询返回完整信息，模块化设计便于理解
- **代码特点**：SegmentTree结构体封装查询结果，清晰展示合并过程

---

## 最优技巧提炼
1. **四元组维护法**：每个线段树节点存储(sum, lmax, rmax, max)四值
2. **结构体递归查询**：查询返回完整结构体而非单一数值，实现查询时动态合并
3. **负值防御机制**：在pushup阶段通过max(0, value)确保不出现空选情况

---

## 同类型题目推荐
1. **SP1716 GSS3**（区间最大子段和+单点修改）
2. **P2042 维护数列**（区间操作+最大子段和）
3. **P1115 最大子段和**（基础版静态问题）

---

## 可视化设计
### 算法演示方案
**动画要素**：
1. **节点高亮**：用不同颜色区分sum(灰色)、lmax(蓝色)、rmax(红色)、max(金色)
2. **合并过程**：以粒子动画展示左子树rmax与右子树lmax的相加过程
3. **数据流动**：用箭头表示查询时结构体信息的向上传递

**复古游戏化实现**：
```javascript
// 伪代码示例：像素风格线段树节点绘制
function drawNode(x, y, node) {
    // 8位色：#4B0082(靛蓝)背景，#FFD700(金色)最大值
    ctx.fillStyle = "#4B0082";
    ctx.fillRect(x, y, 64, 64); // 64x64像素方块
    ctx.fillStyle = "#FFD700";
    ctx.fillText(`MAX:${node.max}`, x+5, y+15);
}
```

**音效设计**：
- **节点合并**：8-bit "blip"短音（440Hz方波）
- **查询完成**：NES风格胜利音效（三连升调）
- **错误操作**：经典FC出错音效（低频噪音）

---

## 核心代码实现
以ez_lcw题解的合并逻辑为例：
```cpp
void putin(int k) {
    tree[k].sum = tree[k*2].sum + tree[k*2+1].sum;
    tree[k].maxleft = max(tree[k*2].maxleft, 
                        tree[k*2].sum + tree[k*2+1].maxleft);
    tree[k].maxright = max(tree[k*2+1].maxright,
                         tree[k*2+1].sum + tree[k*2].maxright);
    tree[k].ans = max(max(tree[k*2].ans, tree[k*2+1].ans),
                    tree[k*2].maxright + tree[k*2+1].maxleft);
}
```
此实现通过递归维护四元组，完美展现线段树合并策略的精髓。

---
处理用时：70.65秒
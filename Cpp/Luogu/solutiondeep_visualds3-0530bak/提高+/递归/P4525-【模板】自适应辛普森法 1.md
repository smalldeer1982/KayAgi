# 题目信息

# 【模板】自适应辛普森法 1

## 题目描述

试计算积分

$\displaystyle{\int_L^R\frac{cx+d}{ax+b}\mathrm{d}x}$

结果保留至小数点后 $6$ 位。

数据保证计算过程中分母不为 $0$ 且积分能够收敛。

## 说明/提示

$a,b,c,d\in[-10,10]$，$-100\le L<R\le 100$ 且 $R-L\ge1$。

## 样例 #1

### 输入

```
1 2 3 4 5 6```

### 输出

```
2.732937```

# AI分析结果



# 【分类】自适应辛普森法

---

## 【综合分析与结论】
本题核心为计算有理函数的定积分，存在两种主流解法：
1. **数学解析法**：通过分式分解和积分公式直接求得原函数（当分母线性时）
2. **数值积分法**：使用自适应辛普森法进行二次函数拟合近似积分

**数学解析法**通过将 $\frac{cx+d}{ax+b}$ 分解为 $\frac{c}{a} + \frac{ad-bc}{a(ax+b)}$，利用 $\int \frac{1}{ax+b}dx = \frac{1}{a}\ln|ax+b|$ 的积分公式快速求得精确解，时间复杂度 $O(1)$。需特判 $a=0$ 的一次函数情况。

**自适应辛普森法**则通过递归将区间二分，用二次函数拟合原函数，当左右子区间积分和与总区间积分误差满足精度时终止递归。其核心公式为：
$$\int_a^b f(x)dx \approx \frac{(b-a)}{6}[f(a)+4f(\frac{a+b}{2})+f(b)]$$

---

## 【题解评分 (≥4星)】
1. **qianfujia（5星）**  
   - 数学推导简洁清晰，代码仅需特判 a=0 的分母情况  
   - 关键代码仅10行，直接套用积分公式  
   - 时间复杂度 O(1)，完胜数值方法

2. **zythonc（5星）**  
   - 详细推导分式分解过程，给出完整换元步骤  
   - 代码中通过数学函数直接计算，无递归开销  
   - 附带积分步骤的LaTeX公式推导，教学价值高

3. **ikka（4星）**  
   - 详细讲解辛普森公式的抛物线拟合原理  
   - 给出自适应递归的误差控制逻辑（15*eps判断）  
   - 代码结构规范，适合作为模板

---

## 【最优思路提炼】
### 关键技巧
1. **分式分解法**（数学解析）  
   $$\frac{cx+d}{ax+b} = \frac{c}{a} + \frac{ad-bc}{a(ax+b)}$$  
   将原式拆分为常数项与 $\frac{1}{ax+b}$ 的组合，直接应用积分表

2. **辛普森递归终止条件**  
   ```cpp
   if(fabs(L+R-ans)<=15*eps) return L+R+(L+R-ans)/15; 
   ```
   通过当前区间积分与子区间积分和的差异动态调整精度

---

## 【同类型题推荐】
1. [P4526 自适应辛普森法2](https://www.luogu.com.cn/problem/P4526)  
   积分函数包含指数项，需数值积分
2. [P4207 月下柠檬树](https://www.luogu.com.cn/problem/P4207)  
   求复杂几何图形面积，需结合辛普森法
3. [P3717 能量采集](https://www.luogu.com.cn/problem/P3717)  
   二维积分问题，可扩展辛普森法

---

## 【可视化设计】
### 算法演示（自适应辛普森法）
```html
<div id="simpson-canvas"></div>
<script>
// 初始化 Canvas
const canvas = document.createElement('canvas');
canvas.width = 800; canvas.height = 400;
document.querySelector('#simpson-canvas').appendChild(canvas);
const ctx = canvas.getContext('2d');

// 绘制函数曲线（红色）
function drawFunction() {
  ctx.beginPath();
  for(let x=0; x<canvas.width; x++){
    const xx = L + (R-L)*x/canvas.width;
    const yy = f(xx);
    ctx.lineTo(x, canvas.height - (yy-yMin)/(yMax-yMin)*canvas.height); 
  }
  ctx.strokeStyle = '#ff0000'; ctx.stroke();
}

// 递归绘制辛普森区间（绿色矩形 + 蓝色抛物线）
function drawInterval(l, r, depth) {
  const mid = (l+r)/2;
  // 绘制当前区间背景
  ctx.fillStyle = `rgba(0,255,0,${0.1/(depth+1)})`;
  ctx.fillRect(l*canvas.width/(R-L), 0, 
    (r-l)*canvas.width/(R-L), canvas.height);
  
  // 绘制辛普森抛物线
  const y1 = f(l), y2 = f(mid), y3 = f(r);
  ctx.beginPath();
  ctx.moveTo(l, y1);
  ctx.bezierCurveTo(l, y1, mid, y2*2 - (y1+y3)/2, r, y3); // 近似二次曲线
  ctx.strokeStyle = '#0000ff'; ctx.stroke();
}
</script>
```
![自适应辛普森法可视化](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Simpsons_method_illustration.svg/800px-Simpsons_method_illustration.svg.png)  
（图示：红色为原函数曲线，蓝色为辛普森拟合抛物线，绿色深浅表示递归深度）

---

## 【核心代码实现】
### 数学解析法（qianfujia）
```cpp
double f(double x) {
    return c*x/a + (d/a - b*c/(a*a)) * log(fabs(a*x + b));
}
double f2(double x) {
    return (c*x*x)/(2*b) + (d*x)/b;
}
int main() {
    if(abs(a) == 0) printf("%.6lf", f2(r)-f2(l));
    else printf("%.6lf", f(r)-f(l));
}
```

### 自适应辛普森法（ikka）
```cpp
double asr(double l,double r,double eps,double ans) {
    double mid = (l+r)/2;
    double L=simpson(l,mid), R=simpson(mid,r);
    if(fabs(L+R-ans) <= 15*eps) 
        return L+R + (L+R-ans)/15;
    return asr(l,mid,eps/2,L) + asr(mid,r,eps/2,R);
}
```

---

## 【复古游戏化设计】
1. **像素风格**：使用 16 色索引调色板，用 8x8 像素块表示积分区间
2. **音效设计**：
   - 区间分割：播放类似《超级马里奥》金币音效（短促的 500Hz 方波）
   - 达到精度：播放《塞尔达传说》解谜成功音效（上升和弦）
3. **动画逻辑**：
   ```javascript
   // 8-bit 风格绘制
   function drawPixel(x, y, color) {
     ctx.fillStyle = COLORS[color];
     ctx.fillRect(x*8, y*8, 8, 8); 
   }
   // 自动演示循环
   function autoPlay() {
     splitInterval(currentL, currentR); // 分割区间
     if(++step % 2 == 0) playSound('split'); 
     requestAnimationFrame(autoPlay);
   }
   ```

---
处理用时：110.01秒
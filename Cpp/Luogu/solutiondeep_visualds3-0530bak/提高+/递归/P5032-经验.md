# 题目信息

# 经验

## 题目背景

[赛时答疑](https://www.luogu.org/discuss/show/80694)  

**简略版已经更新，时限改为500ms**

攒够经验附魔去~~

Steve在minecraft中总是会遇上难题：
他想要修理n本附魔书，每本附魔书的等级为ai，他总是不知道铁砧修理和经验值的机制。他便在mcwiki上搜索到了一些资料：
![](https://d1u5p3l4wpay3k.cloudfront.net/minecraft_zh_gamepedia/pChart4mw/e8160a1cad02998149d79c65237dc775.png)

----图为经验值与等级的关系，摘自mcwiki 

他看到这个图，就想：我等级升的越高，我所需要的经验值便越多，那么如果我等级刚好够铁砧修理的话，那我所耗费的经验不就越少了吗？他便继续搜索了下去，并将铁砧机制附在了下面,让你帮他解决问题：

## 题目描述

**累积惩罚：**

无论是重命名、修复、还是合并操作，其经验花费都会因其物品先前在铁砧上的操作而增加，这些额外增加的花费被称作“累积惩罚”。对于一件从未放上铁砧的物品，累积惩罚为0。

一个物品每次在铁砧上操作过后（不包括重命名），其累积惩罚都会先乘2再加1。如此一来，一个物品在操作过N次后累积惩罚是2^N-1。6次操作之后，累积惩罚是63级，此时生存模式下无法再作进一步的修复和附魔工作。31次操作后，惩罚等级是2147483647级，此时在任何模式下都不能再进行操作。

当合并两个物品时，玩家会同时受到两件物品的累积惩罚。合并后物品的累积惩罚根据先前两个物品中较高者计算。例如，合并两个累积惩罚分别是3级和15级的物品会额外花费18级的惩罚经验，而合并后的物品惩罚是31级（15*2+1）。

累积惩罚甚至会作用在不会磨损的物品上，譬如附魔书。因此，合并4本时运 I 的附魔书，会得到一本累积惩罚为3的时运 III 附魔书。

     累计操作数	      惩罚

         0	           0

         1	           1

         2	           3

         3	           7

         4	           15

         5	           31

使用合成方格进行的物品修复操作会移除所有累积惩罚，但也会丢失所有的魔咒。

**合并物品：**

铁砧界面中第一格/左边的物品称为目标物品；第二格/右边的物品称为牺牲物品——合并后会消失。如果牺牲物品附有魔咒，铁砧会同时试图将牺牲物品的附魔合并至目标物品上。无论目标物品上的魔咒是否产生实际变化，铁砧都将根据目标物品与牺牲物品上的魔咒收取玩家的等级耗费。

对于牺牲物品上的每个魔咒来说：如果目标物品也拥有相同的魔咒：

当牺牲物品的魔咒等级较高时，目标物品魔咒的等级将上升至牺牲物品上的等级。

当牺牲物品的魔咒等级相同时，目标物品上魔咒的等级将提升1级，除非其等级已为最高。    

当牺牲物品的魔咒等级较低时，目标物品上该魔咒的等级不变。
    
合并物品的总花费将是下列费用之和：

1.目标物品和牺牲物品的累积惩罚之和。

2.如果同时进行重命名，则额外产生重命名的费用。

3.如果目标物品耐久度未满，则耗费2级用于维修。

4.如果牺牲物品拥有魔咒，则产生附魔费用。

5.如果牺牲物品是一本附魔书，则不会产生维修费用，铁砧会尝试将书本上的魔咒合并至目标物品上。亦可同时对目标物品进行重命名。此时的附魔花费一般会少于合并两个类似物品的费用。

-----摘自mc wiki，稍作删改

**简略版：**  
给出附魔书，只有同等等级的才能合并。合并的代价为两本书的累计代价之和。合成后的书的累计代价为合成前最大代价的2倍加上1。求最高等级和最小花费（要求最高等级为第一关键字）,Steve因为开了挂，所以最高等级不限

现给出$n$本附魔书，每本附魔书有它的等级$ai$,问如何才能得到附魔书的最大等级$x$，在此基础上，请计算合成它消耗的最小等级$y$。（我们假设每本附魔书初始的累积惩罚为1）。

Steve很懒，他不想看上面的话，他只想要让你编写出一个程序计算出$x$与$y$。但Steve为了不外传，他只要求你输出$x$在模$y$意义下的乘法逆元$k$即可。如果没有，请输出$-1$.

## 说明/提示

**样例解释**
 
第一个样例：    
合并两个第一等级的，合并花费2经验，代价升为3  
再合并两个第二等级的，花费3+1=4经验，代价升为7  
再合并两个第三等级的，花费7+1=8经验，代价升为15  
最后合并两个第四等级的，花费15+1=16经验，代价升为31  

经验总花费：2+4+8+16=30，最大等级：5


对于第一个样例: $x=5$,$y=30$;

对于第二个样例: $x=3$,$y=10$;

**数据范围**

![]( https://cdn.luogu.com.cn/upload/pic/41547.png )

保证数据随机，$x$,$y$,$k$在long int范围内

**温馨提示**

本题读入量较大，请使用较快的读入方法，在此，提供一种快速读入的样式：(需包含头文件<cctype>)

```
#include<cctype>
inline void read(int &x){
     char ch=getchar();x=0;
     while(!isdigit(ch))   ch=getchar();
     while(isdigit(ch))   x=x*10+ch-'0',ch=getchar();
}
```

## 样例 #1

### 输入

```
5
1 1 2 3 4```

### 输出

```
-1```

## 样例 #2

### 输入

```
4
1 1 1 1```

### 输出

```
7```

# AI分析结果



## 唯一算法分类
贪心算法、递归与分治

## 综合分析与结论

### 核心思路
1. **最高等级计算**：通过桶排序统计各等级数量，逐层向上合并（类似二进制进位）
2. **最小代价计算**：递归合并策略，优先使用已有书籍，不足时递归生成低等级书籍，同时累加合并代价

### 解决难点
- **高效处理大数据量**：桶排序 + 递归分治实现 O(n) 时间复杂度
- **合并顺序优化**：通过递归保证每次合并的两本书都是当前等级的最小代价组合
- **动态维护累积惩罚**：合并后惩罚值根据较大值的 2n+1 规则自动计算

### 可视化设计
1. **动画流程**：
   - 初始显示各等级书的像素方块（不同颜色区分等级）
   - 递归合并时，高亮当前操作的两个方块，产生爆炸粒子特效
   - 新生成的书籍用更高亮度颜色显示，惩罚值以数字浮动显示
2. **音效设计**：
   - 合并成功时播放8位机风格的"哔"声
   - 递归展开时播放"滴"声提示层级变化
   - 最终结果出现时播放经典FC过关音效

## 题解评分（≥4星）

### 南城忆潇湘（5星）
- 亮点：桶排序预处理 + 递归代价计算，O(n)时间复杂度
- 关键代码：
```cpp
int dg(int x) {
    if(d[x]) { d[x]--; return 1; }
    int p = dg(x-1), q = dg(x-1);
    ans += p + q;
    return max(p, q)*2 + 1;
}
```

### Imakf（4星）
- 亮点：双队列维护合并顺序，模拟合并果子过程
- 关键思路：
```cpp
while(q.size()>1) {
    auto a = pop_min(q), b = pop_min(q);
    if(a.level == b.level) 
        q.push(merge(a,b));
    else 
        q.push_back(max(a,b));
}
```

### Alarm5854（4星）
- 亮点：基数排序优化输入处理，递归树可视化思路清晰
- 优化点：将递归过程比作满二叉树，时间复杂度严格证明

## 最优思路提炼

**黄金法则**：
1. **二进制进位式合并**：通过 `c[i+1] += c[i]/2` 快速计算最高等级
2. **递归代价累加**：从目标等级向下分解，`ans += p+q` 实现自动累加
3. **惩罚值动态更新**：`max(p,q)*2+1` 完美符合题目规则

## 同类题目推荐
1. P1090 合并果子（经典贪心）
2. P6033 合并果子加强版（双队列优化）
3. P2168 荷马史诗（k叉哈夫曼树）

## 可视化算法演示
```javascript
// 伪代码展示递归合并过程
function animateMerge(level) {
    if (hasBook(level)) {
        playSound('pickup');
        highlightBook(level);
        return;
    }
    splitAnimation(level);
    animateMerge(level-1);
    animateMerge(level-1);
    showMergeEffect(level);
    updateCostDisplay();
}
```

## 关键代码实现
```cpp
// 递归计算合并代价（南城忆潇湘题解核心）
int dg(int x) {
    if(d[x]) { // 存在本级书直接使用
        d[x]--;
        return 1; // 初始惩罚为1
    }
    int p = dg(x-1); // 递归分解左子树
    int q = dg(x-1); // 递归分解右子树
    ans += p + q;   // 累加当前合并代价
    return max(p, q)*2 + 1; // 计算新惩罚值
}
```

## 个人心得摘录
"递归就像倒着搭积木，要从目标形状开始拆解。每个高层级合并都需要保证底层结构的正确性，debug时要像考古学家一样层层剥离" —— 南城忆潇湘

## 复古动画要素
1. **像素风格**：16色调色板，每个等级对应不同颜色方块
2. **合并特效**：
   - 合并时方块爆炸成8x8粒子
   - 新方块生成时产生波纹扩散效果
3. **音效系统**：
   - 选择音效：250Hz方波，持续0.1s
   - 合并音效：500Hz→1000Hz滑音
   - 错误音效：200Hz锯齿波短脉冲

[点击查看完整实现方案](https://example.com/mc-anvil-simulator)（虚构链接）

---
处理用时：80.71秒
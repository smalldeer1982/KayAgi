# 题目信息

# 低价购买

## 题目描述

“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。

这里是某支股票的价格清单：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}\hline
\textsf{日期} & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \cr\hline
\textsf{价格} & 68 & 69 & 54 & 64 & 68 & 64 & 70 & 67 & 78 & 62& 98 & 87 \cr\hline
\end{array}$$

最优秀的投资者可以购买最多 $4$ 次股票，可行方案中的一种是：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textsf{日期} & 2 & 5 & 6 & 10 \cr\hline
\textsf{价格} & 69 & 68 & 64 & 62 \cr\hline
\end{array}
$$


## 样例 #1

### 输入

```
12
68 69 54 64 68 64 70 67 78 62 98 87
```

### 输出

```
4 2
```

# AI分析结果



# 低价购买题解分析

## 算法分类
动态规划（最长下降子序列及方案数统计）

---

## 题解思路与核心难点

### 核心算法流程
1. **最长下降子序列（LDS）**  
   使用动态规划，`f[i]` 表示以第 `i` 天结尾的最长下降子序列长度。状态转移方程为：  
   \[
   f[i] = \max_{j < i, a[j] > a[i]} (f[j] + 1)
   \]
2. **方案数统计**  
   引入 `t[i]` 记录以第 `i` 天结尾的方案数。关键点在于去重：  
   - 若存在 `a[i] == a[j]` 且 `f[i] == f[j]`，则 `t[j] = 0`（前者的方案被后者覆盖）。  
   - 状态转移方程为：  
   \[
   t[i] = \sum_{j < i, a[j] > a[i], f[j] = f[i] - 1} t[j]
   \]

### 解决难点
- **去重逻辑**：通过倒序遍历或置零操作，确保相同元素仅在最后出现的位置被统计。
- **方案数累积**：在动态规划过程中同步更新方案数，避免重复计算。

---

## 题解评分（≥4星）

### 1. wjyyy（★★★★★）
- **亮点**：  
  - 使用 `t[j] = 0` 直接去重，逻辑清晰。  
  - 代码结构简洁，双循环分离计算长度和方案数。  
- **代码片段**：  
  ```cpp
  for (int j = 1; j < i; j++) {
      if (f[i] == f[j] && a[i] == a[j]) t[j] = 0;
      else if (f[i] == f[j] + 1 && a[i] < a[j]) t[i] += t[j];
  }
  ```

### 2. HITZero（★★★★☆）
- **亮点**：  
  - 显式初始化 `f[i] = 1`，代码可读性强。  
  - 使用 `ans1` 和 `ans2` 分别存储结果，逻辑分明。  
- **代码片段**：  
  ```cpp
  for (int j = 1; j < i; j++) {
      if (dp[i] == dp[j] + 1 && a[i] < a[j]) f[i] += f[j];
      else if (a[i] == a[j] && dp[i] == dp[j]) f[j] = 0;
  }
  ```

### 3. feecle6418（★★★★☆）
- **亮点**：  
  - 在动态规划主循环内完成去重，减少额外遍历。  
  - 使用 `g[j] = 0` 直接标记无效方案。  
- **代码片段**：  
  ```cpp
  if (a[j] == a[i] && f[i] == f[j]) f[j] = 0;
  ```

---

## 最优思路提炼
1. **动态规划框架**：先计算最长下降子序列长度，再同步更新方案数。  
2. **去重技巧**：倒序遍历或置零相同元素的前驱方案数。  
3. **时间复杂度**：O(n²)，适用于题目数据范围（n ≤ 5000）。  

---

## 同类型题与推荐题目
1. **最长上升子序列（LIS）**  
   - 题号：P1020 导弹拦截  
2. **带权方案数统计**  
   - 题号：P2513 逆序对数列  
3. **优化版动态规划**  
   - 题号：P1439 最长公共子序列（转化为 LIS）

---

## 可视化设计
### 动画方案
1. **动态规划状态更新**：  
   - **颜色标记**：当前元素 `a[i]` 高亮为蓝色，比较元素 `a[j]` 为黄色。  
   - **步进控制**：展示 `f[i]` 和 `t[i]` 的更新过程，如：  
     - 当 `a[j] > a[i]` 时，`f[i]` 从 `f[j] + 1` 更新。  
     - 当 `a[i] == a[j]` 且 `f[i] == f[j]` 时，`t[j]` 变红并置零。  
2. **复古像素风格**：  
   - 使用 8-bit 像素字体，`f` 和 `t` 数组以网格形式展示。  
   - 音效触发：  
     - **成功更新**：短促“滴”声。  
     - **去重操作**：低沉“哔”声。  

### 交互演示
- **控制面板**：支持暂停、步进、重置。  
- **自动演示**：模拟算法自动运行，速度可调。  

---

## 代码实现（关键逻辑）
```cpp
#include <cstdio>
#include <cstring>
int max(int x, int y) { return x > y ? x : y; }
int a[5001], f[5001], t[5001];

int main() {
    int n, maxx = 0;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j < i; j++)
            if (a[i] < a[j]) f[i] = max(f[i], f[j] + 1);
        if (f[i] == 0) f[i] = 1;
        maxx = max(maxx, f[i]);
        
        for (int j = 1; j < i; j++) {
            if (f[i] == f[j] && a[i] == a[j]) t[j] = 0;
            else if (f[i] == f[j] + 1 && a[i] < a[j]) t[i] += t[j];
        }
        if (!t[i]) t[i] = 1;
    }
    
    int sum = 0;
    for (int i = 1; i <= n; i++)
        if (f[i] == maxx) sum += t[i];
    printf("%d %d", maxx, sum);
    return 0;
}
```

---

## 个人心得
- **调试教训**：去重时需注意循环顺序，倒序遍历可避免重复统计。  
- **优化技巧**：在计算方案数时同步去重，减少后续遍历开销。

---
处理用时：73.82秒
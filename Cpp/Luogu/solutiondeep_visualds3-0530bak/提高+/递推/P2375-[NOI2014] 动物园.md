# 题目信息

# [NOI2014] 动物园

## 题目描述

近日，园长发现动物园中好吃懒做的动物越来越多了。例如企鹅，只会卖萌向游客要吃的。为了整治动物园的不良风气，让动物们凭自己的真才实学向游客要吃的，园长决定开设算法班，让动物们学习算法。

某天，园长给动物们讲解 KMP 算法。

园长：“对于一个字符串 $S$，它的长度为 $L$。我们可以在 $O(L)$ 的时间内，求出一个名为 $\mathrm{next}$ 的数组。有谁预习了 $\mathrm{next}$ 数组的含义吗？”

熊猫：“对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀又是它的前缀的字符串中（它本身除外），最长的长度记作 $\mathrm{next}[i]$。”

园长：“非常好！那你能举个例子吗？”

熊猫：“例 $S$ 为 $\verb!abcababc!$，则 $\mathrm{next}[5]=2$。因为$S$的前$5$个字符为 $\verb!abcab!$，$\verb!ab!$ 既是它的后缀又是它的前缀，并且找不到一个更长的字符串满足这个性质。同理，还可得出 $\mathrm{next}[1] = \mathrm{next}[2] = \mathrm{next}[3] = 0$，$\mathrm{next}[4] = \mathrm{next}[6] = 1$，$\mathrm{next}[7] = 2$，$\mathrm{next}[8] = 3$。”

园长表扬了认真预习的熊猫同学。随后，他详细讲解了如何在 $O(L)$ 的时间内求出 $\mathrm{next}$ 数组。

下课前，园长提出了一个问题：“KMP 算法只能求出 $\mathrm{next}$ 数组。我现在希望求出一个更强大 $\mathrm{num}$ 数组一一对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作 $\mathrm{num}[i]$。例如 $S$ 为 $\verb!aaaaa!$，则 $\mathrm{num}[4] = 2$。这是因为$S$的前 $4$ 个字符为 $\verb!aaaa!$，其中 $\verb!a!$ 和 $\verb!aa!$ 都满足性质‘既是后缀又是前缀’，同时保证这个后缀与这个前缀不重叠。而 $\verb!aaa!$ 虽然满足性质‘既是后缀又是前缀’，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，$\mathrm{num}[1] = 0,\mathrm{num}[2] = \mathrm{num}[3] = 1,\mathrm{num}[5] = 2$。”

最后，园长给出了奖励条件，第一个做对的同学奖励巧克力一盒。听了这句话，睡了一节课的企鹅立刻就醒过来了！但企鹅并不会做这道题，于是向参观动物园的你寻求帮助。你能否帮助企鹅写一个程序求出$\mathrm{num}$数组呢？

特别地，为了避免大量的输出，你不需要输出 $\mathrm{num}[i]$ 分别是多少，你只需要输出所有 $(\mathrm{num}[i]+1)$ 的乘积，对 $10^9 + 7$ 取模的结果即可。


## 说明/提示

测试点编号| 约定
-|-  
1| $n \le 5, L \le 50$  
2| $n \le 5, L \le 200$  
3| $n \le 5, L \le 200$  
4| $n \le 5, L \le 10,000$  
5| $n \le 5, L \le 10,000$  
6| $n \le 5, L \le 100,000$  
7| $n \le 5, L \le 200,000$   
8| $n \le 5, L \le 500,000$  
9| $n \le 5, L \le 1,000,000$  
10| $n \le 5, L \le 1,000,000$  


## 样例 #1

### 输入

```
3
aaaaa
ab
abcababc```

### 输出

```
36
1
32 ```

# AI分析结果



**唯一算法分类**：KMP算法扩展应用

---

### **题解思路、算法要点与解决难点**
1. **核心思路**  
   通过两次KMP遍历高效求解`num`数组：
   - **第一次遍历**：构建`next`数组（记录最长前后缀长度），同时递推`num`数组（不考虑重叠的公共前后缀数量）。
   - **第二次遍历**：维护指针`j`，确保其不超过当前长度`i`的一半，累乘`num[j]+1`得到最终结果。

2. **算法要点**  
   - **next数组性质**：`next[i]`表示前缀`S[1..i]`的最长公共前后缀长度，形成一棵树形结构（fail树）。
   - **num数组递推**：`num[i] = num[next[i]] + 1`，统计所有可能的公共前后缀数量。
   - **指针跳跃优化**：在第二次遍历时，通过调整`j`的位置，保证其满足`j ≤ i/2`，避免暴力跳转带来的高时间复杂度。

3. **解决难点**  
   - **重叠条件处理**：通过动态调整指针`j`，确保其在满足不重叠的条件下快速定位。
   - **时间复杂度优化**：利用KMP算法中指针`j`的单调性，保证两次遍历总时间复杂度为`O(n)`。

---

### **题解评分（≥4星）**
1. **Orion545（★★★★★）**  
   - 思路清晰，引入fail树概念，两次KMP过程严格线性时间复杂度。
   - 代码简洁，核心逻辑通过两次循环实现，无冗余操作。
2. **nofind（★★★★☆）**  
   - 类似两次KMP思路，代码结构清晰，但未深入解释指针跳跃的单调性证明。
   - 个人心得提到“暴跳nxt直到`j ≤ i/2`”，直观易懂。
3. **WjNaG（★★★★☆）**  
   - 通过注释详细解释`num`数组递推逻辑，适合新手理解。
   - 代码中`while(k*2>j+1)`直观体现重叠条件处理。

---

### **最优思路或技巧提炼**
- **两次KMP遍历**：第一次预处理`next`和`num`，第二次动态调整指针满足条件。
- **指针跳跃单调性**：通过维护全局指针`j`，保证其总移动次数为`O(n)`。
- **乘积取模优化**：在遍历过程中直接累乘并取模，避免中间结果溢出。

---

### **同类型题与算法套路**
- **KMP扩展应用**：如求最小循环节（洛谷P4391）、最长双回文串（洛谷P4551）。
- **fail树性质**：常用于统计所有公共前后缀的集合，如AC自动机的fail树分析。

---

### **推荐相似题目**
1. **P3375**：KMP模板题，练习基础`next`数组构建。
2. **P3435**：基于`next`数组的后缀处理，需要统计最长不重叠循环节。
3. **P5829**：利用fail树性质统计所有公共前后缀的异或和。

---

### **可视化与算法演示**
1. **动画设计**  
   - **KMP构建next数组**：高亮当前字符`i`和指针`j`，展示匹配失败时的跳跃过程。
   - **动态调整j指针**：用红色标记`j`的位置，绿色标记`i/2`边界，当`j`超过边界时触发跳跃动画。
   - **乘积计算**：在每次调整`j`后，显示`num[j]+1`的值及当前累乘结果。

2. **复古像素风格**  
   - **Canvas网格**：每个字符显示为8x8像素块，`i`和`j`用不同颜色（黄色和蓝色）标记。
   - **音效触发**：匹配成功时播放高音“哔”，跳跃时播放低音“嘟”，计算乘积时触发短促“叮”。
   - **自动演示模式**：按空格键切换手动/自动，自动模式下算法逐步执行，速度可调。

---

### **代码片段（核心逻辑）**
```cpp
// 第一次遍历：构建next和num数组
j = 0; num[1] = 1;
for (int i = 1; i < n; i++) {
    while (j && s[i] != s[j]) j = next[j];
    if (s[i] == s[j]) j++;
    next[i+1] = j;
    num[i+1] = num[j] + 1;
}

// 第二次遍历：调整j并计算乘积
j = 0; ll ans = 1;
for (int i = 0; i < n; i++) {
    while (j && s[i] != s[j]) j = next[j];
    if (s[i] == s[j]) j++;
    while (j*2 > i+1) j = next[j];
    ans = ans * (num[j] + 1) % MOD;
}
```

---

### **总结**
本题核心在于**利用KMP算法的指针跳跃特性**，通过两次遍历高效处理不重叠条件。可视化设计应重点展示指针调整过程，帮助理解算法的单调性优化。同类题目多涉及`next`数组的扩展性质，需熟练掌握fail树与指针跳跃技巧。

---
处理用时：63.87秒
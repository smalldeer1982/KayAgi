# 题目信息

# 「Stoi2033」世界未末日

## 题目背景

注意：**利用提交反馈以套取数据的行为属于作弊**。

> 就算是世界要崩溃  
> 亲爱的我也绝不会落泪  
> 不放弃爱过的那种感觉  
> 珍惜着有你记忆的一切  
> 就算是世界要倾斜  
> 亲爱的我也绝不说离别  
> 尽管末日威胁再强烈  
> 有爱就不累  
> ——《世界未末日》

## 题目描述

Vinsta 和 Stella 有 $n$ 堆石子，第 $i$ 堆有 $s_i$ 个。

她们约定从 Vinsta 开始轮流操作，每次操作可以选择不少于 $1$ 堆且不超过 $k$ 堆的石子。对于第 $i$ 堆石子，可以选取两个实数 $a,b$ 满足：

- $a \times b=s_i$
- $a+b=c,c\in[1,s_i]\cap\Z$

并丢掉第 $i$ 堆的 $c$ 个石子，即 $s_i\leftarrow s_i-c$。不能操作者败，她们想要知道 Vinsta 是否有必胜策略。

## 说明/提示

### 数据范围

**本题采用捆绑测试。**

| Subtask | $1\le n \le$ | $1\le S \le$ | 分值 |
| :-: | :-: | :-: | :-: |
| $1$ | $300$ | $300$ | $7$ |
| $2$ | $300$ | $3 \times 10^7$ | $8$ |
| $3$ | $300$ | $3\times 10^{10}$ | $16$ |
| $4$ | $3\times 10^6$ | $3$ | $3$ |
| $5$ | $3\times 10^6$ | $3 \times 10^3$ | $3$ |
| $6$ | $3\times 10^6$ | $3 \times 10^7$ | $16$ |
| $7$ | $3\times 10^6$ | $3\times 10^{10}$ | $47$ |

对于 $100\%$ 的数据， $1 \le k \le n \le 3 \times 10^6$，$1 \le S \le 3 \times 10^{10}$。

## 样例 #1

### 输入

```
7 1 13
2 3 4 5 7 10 11
```

### 输出

```
YES
```

## 样例 #2

### 输入

```
8 1 13
2 3 4 5 7 10 11 13
```

### 输出

```
NO
```

## 样例 #3

### 输入

```
7 2 100
19 26 8 17 11 45 14
```

### 输出

```
YES
```

# AI分析结果



1. **唯一算法分类**  
博弈论/SG函数

---

2. **综合分析与结论**  
该题本质是k-SG博弈问题，核心在于快速计算每堆石子的SG值。关键推导发现：  
- SG(x)的转移范围是[0, x-2√x]，且SG函数单调递增  
- 通过递推式SG(x) = SG(x-2√x) +1，预计算每个SG值对应的最小x（l数组）  
- 利用二分法快速查询给定s_i的SG值  
- 最终按k-SG规则统计二进制各位出现次数是否全为k+1的倍数  

**可视化设计思路**：  
- **像素动画**：用8-bit风格网格展示l数组的生成过程，每次递推时用不同颜色块表示当前计算阶段  
- **高亮步骤**：预处理阶段用闪烁效果标记l[i]的修正过程；二分查找时用光标跟踪mid位置  
- **音效触发**：每次成功计算SG值时播放上升音效，异或结果非零时播放胜利音效  
- **游戏化积分**：将预处理步骤拆解为"关卡"，每完成一个l[i]计算得10分  

---

3. **题解清单 (≥4星)**  
**VinstaG173题解（5星）**：  
- 完整覆盖所有部分分，呈现算法优化路径  
- 预处理l数组的递推修正逻辑清晰  
- 二进制位统计实现高效  

**喵仔牛奶题解（4星）**：  
- 数学推导完整，给出二次方程判别式的关键观察  
- 代码结构简洁，但未覆盖分步优化  

---

4. **最优思路与代码实现**  
**核心代码（预处理+二分查询）**：  
```cpp
// 预处理l数组
vector<ll> l = {0};
while (l.back() < S) {
    ll next = pow(sqrt(l.back()+1)+1, 2);
    while (next - 2*sqrt(next) < l.back()) next++;
    l.push_back(next);
}

// 查询SG值
int get_sg(ll x) {
    return upper_bound(l.begin(), l.end(), x) - l.begin() - 1;
}
```

**k-SG判定逻辑**：  
```cpp
vector<int> cnt(64);
for (auto sg : sg_values) {
    for (int bit = 0; bit < 60; bit++)
        cnt[bit] += (sg >> bit) & 1;
}
bool win = any_of(cnt.begin(), cnt.end(), [k](int x) { 
    return x % (k+1) != 0; 
});
```

---

5. **同类型题与推荐题目**  
**类似套路**：  
- 利用数学性质化简SG函数计算  
- 分块预处理加速查询  

**推荐题目**：  
1. P2575 高手过招（SG函数状态压缩）  
2. P2148 [SDOI2009] E&D（分组SG异或）  
3. P2964 [USACO09NOV] Coin Game（k-Nim博弈）

---

6. **可视化与游戏化设计**  
**像素动画实现**：  
- **Canvas绘制**：16色调色板，用32x32像素块表示每个l[i]值  
- **递推演示**：每帧显示当前计算的l[i]，右侧显示公式推导过程  
- **音效配置**：  
  - `coin.wav`：每次二分查找成功  
  - `win.wav`：最终存在必胜策略时播放  

**AI演示模式**：  
- 自动播放预处理过程，速度可调  
- 用红色方框标记当前正在计算的l[i]值  

---

**总结**：通过数学推导将SG函数计算复杂度从O(S)降至O(logS)，结合k-SG的二进制统计技巧，形成高效解法。可视化设计应重点呈现递推与二分查询的关联性。

---
处理用时：79.92秒
# 题目信息

# [JRKSJ R5] Jalapeno and Garlic

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/peaku0fe.png)

## 题目描述

一个 $n$ 个点的环，点有点权 $a$，编号依次从 $1\sim n$。点 $1$ 与点 $n$ 相邻。

你希望只存在一个 $x\in[1,n]$ 满足 $a_x\ne 0$。为此，你需要按下面流程进行操作：

1. 选定一个 $x$，表示最终使得 $a_x\ne 0$。**此后不能更改 $x$ 的选择。**
2. 进行若干次修改操作，每次操作你可以选定一个 $y\in[1,n]$，将 $a_y\gets a_y-1$。同时在与点 $y$ 相邻的两个点中**等概率选择**一个，其点权将被 $+1$。

你希望期望的修改次数最少，所以求在最优策略下的期望操作次数（操作 1 不计入）。

## 说明/提示

### 样例 $1$ 解释

选定 $x=2$，进行 $114514$ 次操作，每次的 $y=1$。

### 数据规模

**本题采用捆绑测试。**

| $\text{Subtask}$ | $n\le$ |分值 |
| :----------: | :----------: |:----------: |
| $1$ | $2$ | $5$ |
| $2$ | $10^3$ | $20$ |
| $3$ | $10^4$ | $20$ |
| $4$ | $10^5$ | $20$ |
| $5$ | $10^6$ | $35$ |

对于 $100\%$ 的数据，$2\le n\le 10^6$，$0\le a_i<1004535809$。

## 样例 #1

### 输入

```
2
114514 1919810```

### 输出

```
114514```

## 样例 #2

### 输入

```
3
1 1 2```

### 输出

```
4```

# AI分析结果



---

### **唯一算法分类**  
数学期望与线性优化

---

### **综合分析与结论**  
**核心思路**  
题目要求在环上通过操作将所有权值集中到某个点，求最小期望操作次数。关键点在于推导每个点到达目标的期望步数，并通过数学优化实现线性复杂度计算。

**算法流程**  
1. **期望推导**：对于距离目标点顺时针距离为 $i$ 的点，其期望步数 $f_i = i(n-i)$。通过递推方程 $f_i = 1 + \frac{1}{2}(f_{i-1} + f_{i+1})$ 结合边界条件 $f_0=0$ 和环的对称性推导得出。
2. **总期望公式**：总操作次数为 $\sum_{i=1}^n a_i \cdot |i-d|(n-|i-d|)$，其中 $d$ 为目标点。拆分为前缀和与后缀和的组合形式，避免绝对值的计算。
3. **线性优化**：通过维护三个前缀和（$\sum a_i$, $\sum i a_i$, $\sum i^2 a_i$）和后缀和，将计算复杂度从 $O(n^2)$ 降至 $O(n)$。

**解决难点**  
- **递推方程求解**：通过主元法或矩阵分析推导期望公式。
- **数学拆解与优化**：将绝对值拆分为对称区间，利用前缀和快速计算。
- **大数处理**：使用 `__int128` 存储中间结果，防止溢出。

**可视化设计**  
1. **环形动画**：用 Canvas 绘制环形结构，高亮当前目标点 $d$，动态显示每个点的权值 $a_i$ 及其对总期望的贡献。
2. **滑动窗口效果**：当目标点移动时，用颜色渐变表示前缀和与后缀和的变化，箭头标记关键变量的更新路径（如 $d$ 右移时，左侧点的贡献减少，右侧贡献增加）。
3. **像素风格与音效**：采用 8-bit 音效，每次目标点切换时播放“移动”音效，计算完成时播放成功音效。背景音乐为循环的芯片音乐。

---

### **题解清单 (≥4星)**  
1. **NaCly_Fish（★★★★★）**  
   - **亮点**：完整推导期望公式，通过前缀和优化拆分绝对值，代码简洁高效。  
   - **代码片段**：维护三个前缀和与后缀和，直接计算展开后的多项式。

2. **normalpcer（★★★★☆）**  
   - **亮点**：滑动窗口优化，动态维护总和变化量，避免重复计算。  
   - **心得**：“每次移动目标点时，利用增量更新总和，复杂度优化到 $O(n)$”。

3. **enucai（★★★★☆）**  
   - **亮点**：直接拆解期望公式，代码简洁，预处理前缀和后缀和。  
   - **代码片段**：将总期望拆为 `pre` 和 `suf` 两部分，快速计算最小值。

---

### **最优思路或技巧提炼**  
1. **数学拆解**：将绝对值表达式 $|i-d|(n-|i-d|)$ 展开为多项式，利用前缀和快速求和。
2. **滑动窗口优化**：目标点移动时，通过增量更新总和，而非重新计算所有项。
3. **大数处理**：全程使用 `__int128` 避免溢出，最后取模输出。

---

### **同类型题或类似算法套路**  
1. **环上动态规划**：如环上的资源分配问题，常需拆环为链或利用对称性。
2. **期望递推优化**：需建立递推方程并求解，如 CF24D 的递推式优化。
3. **前缀和优化**：通过预处理加速区间和计算，如滑动窗口最值。

---

### **推荐类似题目**  
1. **P1365 期望收益**（环上期望计算）
2. **CF24D Broken robot**（递推期望与高斯消元优化）
3. **P5483 滑动窗口**（前缀和与动态维护）

---

### **个人心得摘录**  
- **normalpcer**：“移动目标点时，绝大多数点的贡献变化有规律，只需处理特殊点。”  
- **BobL**：“发现每个点的期望增量存在等差关系，直接维护总和变化量。”  
- **do_while_true**：“将贡献拆分为三阶差分，用纯数学方法避免复杂数据结构。”

---

### **核心代码实现**  
以 **NaCly_Fish** 的代码为例：  
```cpp
// 维护前缀和与计算总期望
i128 ans = 0;
for (i32 p = 0; p < N; p++) {
    chkMin(ans, cur);
    cur += 2 * sigma_i_times_ai;
    cur -= static_cast<i128>(N + 1) * sigma_ai;
    cur += static_cast<i64>(N * 2) * a[p];
    sigma_i_times_ai -= sigma_ai;
    sigma_i_times_ai += static_cast<i64>(a[p]) * N;
}
```

---

### **可视化算法演示**  
**动画步骤**：  
1. **初始化**：绘制环形节点，显示初始权值 $a_i$。  
2. **选择目标点**：高亮当前目标 $d$，计算并显示每个点的 $f_i$。  
3. **滑动更新**：右移目标点时，动态更新前缀和与后缀和，箭头标记变化量。  
4. **最小值标记**：当找到更小的总期望时，闪烁提示并记录位置。  

**交互设计**：  
- **速度控制**：滑动条调节动画速度。  
- **单步执行**：按空格逐帧移动目标点。  
- **音效触发**：每次更新时播放“点击”音效，找到最小值时播放“胜利”音效。  

**复古风格**：  
- **调色板**：16 色 FC 风格，节点用像素方块表示。  
- **背景音乐**：8-bit 芯片音乐循环播放。  
- **音效设计**：使用 Web Audio API 实现，模拟 FC 音效。

---
处理用时：89.09秒
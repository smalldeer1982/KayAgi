# 题目信息

# [THUPC 2023 初赛] 欺诈游戏

## 题目背景

在《LIAR GAME》中，小 E 看到了一个有趣的游戏。

## 题目描述

这个游戏名叫《走私游戏》。游戏规则大概是这样的：一名玩家扮演走私者，一名玩家扮演检察官。走私者可以将 $x$ 日元（$x$ 为 $[0,n]$ 内的整数，由走私者决定）秘密放入箱子中，而检查官需要猜测箱子中的金额。假设检察官猜了 $y$（$y$ 也必须是整数）。如果 $x=y$，则走私失败，走私者一分钱也拿不到。如果 $x>y$，则走私成功，走私者可以从检查官那里拿走 $x$ 日元。如果 $x<y$，则走私失败，但是由于冤枉检察官需要赔付给走私者 $y/2$ 日元。游戏分有限回合进行。双方轮流做走私者和检察官。

可以证明，最优情况下每个回合走私者会采用同一种策略，检察官也会采用同一种策略。小 E 想知道在一个回合中，双方的最优策略分别是什么。

## 说明/提示

#### 样例解释 1

这 $4$ 个数分别为 $2/3,1/3,1/3,2/3$。

#### 子任务

保证 $1\le n \le 400000$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
1
```

### 输出

```
665496236 332748118
332748118 665496236
```

# AI分析结果



---

**唯一算法分类**：博弈论（纳什均衡）

---

### **综合分析与结论**

#### **核心思路与算法流程**
本题的核心是求解混合策略纳什均衡，关键步骤如下：
1. **期望收益相等**：在最优策略下，无论对方选择何种策略，己方的期望收益必须相等。
2. **递推关系**：通过相邻项的期望相等条件，推导出概率的递推式。例如：
   - 走私者策略：$f_i = \frac{(i-1)f_{i-1} + \sum_{j=0}^{i-1}f_j}{2i}$
   - 检察官策略：$g_i = \frac{2((i-1)g_{i-1} + \sum_{j=0}^{i-1}g_j)}{i}$
3. **前缀和优化**：利用前缀和快速计算递推中的累加项，时间复杂度优化至 $O(n)$。
4. **归一化**：将所有概率值归一化为总和为1的分布。

#### **可视化设计**
- **动画流程**：  
  1. **递推步骤**：展示每个 $i$ 的递推计算过程，高亮当前项 $f[i]$ 和前缀和。  
  2. **归一化**：动态显示概率总和调整过程，颜色标记归一化后的概率分布。  
  3. **对比展示**：并列显示走私者与检察官的概率分布变化。  

- **复古像素风格**：  
  - **Canvas 网格**：用 8-bit 像素块表示概率值，颜色深浅反映概率大小。  
  - **音效触发**：每计算一个 $i$ 播放短音效，完成时播放胜利音效。  
  - **自动模式**：按固定速度自动执行递推步骤，支持暂停/继续。

---

### **题解清单 (4星及以上)**

1. **Leasier 题解（★★★★★）**  
   - **亮点**：清晰的递推式推导，利用前缀和优化，代码简洁高效。  
   - **关键代码**：
     ```cpp
     f[0] = 1;
     for (i=1 to n) {
         pre += f[i-1];
         f[i] = ((i-1)*f[i-1] + pre) * inv[2i] % mod;
     }
     ```

2. **WYXkk 题解（★★★★★）**  
   - **亮点**：通过相邻项相减直接推导递推关系，数学处理简洁。  
   - **个人心得**："直接列出方程组，用前缀和避免重复计算。"

3. **SmallBlack 题解（★★★★☆）**  
   - **亮点**：详细解释纳什均衡背景，代码使用结构体处理线性组合。  
   - **关键代码**：
     ```cpp
     struct Num { int k, b; }; // 表示 ax + b 形式
     Num t[N], sum;
     t[i+1] = (sum + t[i]*(i+1)) * inv[2i];
     ```

---

### **最优思路提炼**
- **递推式构造**：通过相邻项期望相等条件，化简得到递推关系。  
- **前缀和优化**：将累加项 $\sum_{j=0}^{i-1}f_j$ 转换为前缀和，避免重复计算。  
- **归一化技巧**：将概率表示为基（如 $f_0$）的倍数，最后统一调整总和为1。

---

### **同类型题目推荐**
1. **CF1778D**：递推求解期望，需处理前缀和与逆元。  
2. **P3211 [HNOI2011]XOR和路径**：概率递推与期望计算。  
3. **P3750 [六省联考2017]分手是祝愿**：博弈策略与递推优化。

---

### **代码片段（核心逻辑）**
```cpp
// Leasier 题解核心代码（简化）
const int mod = 998244353;
ll inv[800007], f[400007], g[400007];

void init(int n) {
    inv[0] = inv[1] = 1;
    for (int i=2; i<=n; i++) 
        inv[i] = mod - (mod/i) * inv[mod%i] % mod;
}

int main() {
    init(n*2);
    // 计算 f[i]
    f[0] = 1; ll pre = 0;
    for (int i=1; i<=n; i++) {
        pre = (pre + f[i-1]) % mod;
        f[i] = ((f[i-1]*(i-1) + pre) % mod) * inv[2*i] % mod;
    }
    // 归一化
    ll sumf = accumulate(f, f+n+1, 0LL) % mod;
    sumf = quick_pow(sumf, mod-2, mod);
    for (int i=0; i<=n; i++) 
        printf("%lld ", f[i] * sumf % mod);
}
```

---

### **可视化与游戏化设计**
- **像素动画**：  
  ![Pixel Demo](https://via.placeholder.com/400x200/000000/FFFFFF?text=递推动画：i=0→n)  
  - 每个步骤用像素块表示当前计算的 $i$，颜色深度表示概率值。  
  - 音效：每步计算播放 `beep` 音效，完成时播放 `8-bit 胜利音乐`。  

- **自动演示**：  
  ```javascript
  // 伪代码：自动执行递推
  let i = 0;
  function step() {
      if (i > n) return;
      highlight(i);
      updateSum();
      playSound('beep');
      i++;
      setTimeout(step, 1000);
  }
  step();
  ```

---

**总结**：本题通过博弈论中的纳什均衡条件，结合递推与前缀和优化，高效求解概率分布。关键是对期望相等的数学推导和代码中的模运算处理。

---
处理用时：86.21秒
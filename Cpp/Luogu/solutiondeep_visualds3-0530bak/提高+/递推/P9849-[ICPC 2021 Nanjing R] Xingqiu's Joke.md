# 题目信息

# [ICPC 2021 Nanjing R] Xingqiu's Joke

## 题目描述

有 $T$ 个盒子，每盒子上有一个锁，锁上有两个整数 $a$ 和 $b$。你可以对这个锁做若干次以下 3 种操作：

- $a$ 和 $b$ 分别减去 $1$
- $a$ 和 $b$ 分别增加 $1$
- $a$ 和 $b$ 分别除以它们共同的素数因子

如果 $a$ 或 $b$ 或两者都变为 $1$，盒子就会解锁。请你编写一个程序，计算每个盒子的锁打开的最少步骤数量。

## 样例 #1

### 输入

```
5
4 7
9 8
32 84
11 35
2 1
```

### 输出

```
2
7
5
4
0
```

# AI分析结果



# 算法分类：记忆化搜索与数论（质因数分解）

## 题解思路、算法要点与解决难点

### 核心思路
1. **问题转换**：将问题视为状态 $(a, \delta)$，其中 $\delta = |a - b|$。加减操作不改变 $\delta$，除法操作将 $\delta$ 除以质因子。
2. **质因子分解**：$\delta$ 的质因子是可能被用来进行除法操作的唯一候选，因为公共质因子必须能整除 $\delta$。
3. **递归与记忆化**：通过 DFS 递归处理每个质因子，计算调整到可整除的最小步数，并通过记忆化避免重复计算。

### 解决难点
1. **质因子分解的正确性**：必须正确分解 $\delta$ 的所有质因子，包括处理重复因子和剩余的大质数。
2. **状态转移的两种方向**：对于每个质因子 $g$，需计算向上调整（加步数）或向下调整（减步数）的最优解。
3. **记忆化的高效存储**：使用哈希或 `map<pair<int, int>, int>` 存储状态，保证快速查找。

---

## 最优思路或技巧提炼

### 关键技巧
1. **质因子预处理**：分解 $\delta$ 的质因子作为候选，后续操作仅需枚举这些因子。
2. **状态表示优化**：以较小的数 $a$ 和 $\delta$ 作为状态参数，避免冗余计算。
3. **两种调整策略**：对每个质因子 $g$，计算 $\text{mod} = a \% g$，分别尝试：
   - **向下调整**：花费 $\text{mod}$ 步减到 $a-\text{mod}$，递归到 $(a/g, \delta/g)$。
   - **向上调整**：花费 $g-\text{mod}$ 步加到 $a + (g-\text{mod})$，递归到 $(a/g+1, \delta/g)$。

---

## 题解评分 (≥4星)

### 题解1（作者：CashCollectFactory，4.5星）
- **亮点**：详细数学证明，状态转移清晰，代码注释丰富。
- **代码**：使用哈希函数处理状态，质因子分解高效。

### 题解2（作者：SDLTF_凌亭风，4星）
- **亮点**：代码简洁，状态转移逻辑明确，递归终止条件处理得当。
- **缺点**：缺少详细数学推导。

### 题解3（作者：Fimlty，4星）
- **亮点**：代码可读性强，函数封装清晰，适合初学者理解。
- **缺点**：未处理质因子分解的边界情况。

---

## 可视化与算法演示

### 动画方案
1. **核心逻辑展示**：
   - **网格布局**：将状态 $(a, \delta)$ 显示为像素网格，当前操作的高亮区域为红色。
   - **质因子分解**：以爆炸动画分解 $\delta$ 的质因子，每个因子用不同颜色标记。
   - **调整步骤**：用箭头动画显示加减操作，除法操作用“/”符号闪烁。

2. **颜色标记**：
   - **当前状态**：黄色背景。
   - **质因子**：绿色边框。
   - **调整路径**：蓝色箭头（向下）、红色箭头（向上）。

3. **步进控制**：
   - **速度调节**：滑动条控制动画速度（0.5x~2x）。
   - **单步执行**：按空格键逐步执行递归步骤。

### 复古游戏化设计
- **像素风格**：使用 16 色调色板，状态显示为 8x8 像素块。
- **音效设计**：
  - **分解质因子**：播放“叮”声（类似《超级玛丽》金币音效）。
  - **状态转移**：播放“哔”声（类似《俄罗斯方块》旋转音效）。
  - **找到最优解**：播放《塞尔达传说》通关音乐片段。
- **自动演示模式**：算法自动选择质因子并展示最优路径，类似贪吃蛇 AI 移动。

---

## 核心代码实现（以 SDLTF_凌亭风 为例）

```cpp
#include <bits/stdc++.h>
#define tra(x, y) (x * 1e9 + y)
using namespace std;

vector<int> fact;
unordered_map<long long, int> f;

int dfs(int a, int c) {
    if(a == 1) return 0;
    if(c == 1) return a - 1;
    if(f[tra(a, c)]) return f[tra(a, c)];
    int res = a - 1;
    for(auto p : fact) 
        if(c % p == 0) {
            int mod = a % p;
            res = min({res, 
                mod + 1 + dfs(a / p, c / p),
                (p - mod) + 1 + dfs(a / p + 1, c / p)
            });
        }
    return f[tra(a,c)] = res;
}

int main() {
    int T; cin >> T;
    for(int a, b, delta; T--;) {
        fact.clear(); f.clear();
        cin >> a >> b;
        if(a > b) swap(a, b);
        delta = b - a;
        for(int i = 2; i*i <= delta; ++i) {
            if(delta % i == 0) {
                fact.push_back(i);
                while(delta % i == 0) delta /= i;
            }
        }
        if(delta > 1) fact.push_back(delta);
        cout << dfs(a, b - a) << '\n';
    }
}
```

---

## 相似题目推荐
1. **P1075 质因数分解**：基础质因子分解练习。
2. **P2421 荒岛野人**：涉及差值分析与模运算。
3. **P1463 反素数**：质因子分解与最优化结合。

---
处理用时：86.70秒
# 题目信息

# [NOI2005] 瑰丽华尔兹

## 题目背景

你跳过华尔兹吗？当音乐响起，当你随着旋律滑动舞步，是不是有一种漫步仙境的惬意？

众所周知，跳华尔兹时，最重要的是有好的音乐。但是很少有几个人知道，世界上最伟大的钢琴家一生都漂泊在大海上，他的名字叫丹尼・布德曼・T.D.・柠檬・1900，朋友们都叫他 1900。

1900 在 20 世纪的第一年出生在往返于欧美的邮轮弗吉尼亚号上。很不幸，他刚出生就被抛弃，成了孤儿。1900 孤独的成长在弗吉尼亚号上，从未离开过这个摇晃的世界。也许是对他命运的补偿，上帝派可爱的小天使艾米丽照顾他。可能是天使的点化，1900 拥有不可思议的钢琴天赋：从未有人教，从没看过乐谱，但他却能凭着自己的感觉弹出最沁人心脾的旋律。当 1900 的音乐获得邮轮上所有人的欢迎时，他才 8 岁，而此时，他已经乘着海轮往返欧美大陆 50 余次了。

虽说是钢琴奇才，但 1900 还是个孩子，他有着和一般男孩一样的好奇和调皮，只不过更多一层浪漫的色彩罢了：这是一个风雨交加的夜晚，海风卷起层层巨浪拍打着弗吉尼亚号，邮轮随着巨浪剧烈的摇摆。船上的新萨克斯手迈克斯・托尼晕船了，1900 招呼托尼和他一起坐到舞厅里的钢琴上，然后松开了固定钢琴的闸，于是，钢琴随着海轮的倾斜滑动起来。准确的说，我们的主角 1900…


## 题目描述

不妨认为舞厅是一个 $N$ 行 $M$ 列的矩阵，矩阵中的某些方格上堆放了一些家具，其他的则是空地。钢琴可以在空地上滑动，但不能撞上家具或滑出舞厅，否则会损坏钢琴和家具，引来难缠的船长。每个时刻，钢琴都会随着船体倾斜的方向向相邻的方格滑动一格，相邻的方格可以是向东、向西、向南或向北的。而艾米丽可以选择施魔法或不施魔法：如果不施魔法，则钢琴会滑动；如果施魔法，则钢琴会原地不动。

艾米丽是个天使，她知道每段时间的船体的倾斜情况。她想使钢琴在舞厅里滑行的路程尽量长，这样 1900 会非常高兴，同时也有利于治疗托尼的晕船。但艾米丽还太小，不会算，所以希望你能帮助她。


## 说明/提示

钢琴的滑行路线：

 ![](https://cdn.luogu.com.cn/upload/pic/1307.png) 

钢琴在“×”位置上时天使使用一次魔法，因此滑动总长度为 $6$。

【数据范围】

$50\%$ 的数据中，$1\leq N, M\leq 200，T\leq 200$；

$100\%$ 的数据中，$1\leq N$, $M \leq 200$，$K \leq 200$，$T\leq 40000$。


## 样例 #1

### 输入

```
4 5 4 1 3
..xx.
.....
...x.
.....
1 3 4
4 5 1
6 7 3```

### 输出

```
6```

# AI分析结果



### 算法分类
单调队列优化动态规划

---

### 题解思路与核心难点
#### 核心思路
1. **状态定义**：设 `dp[k][i][j]` 表示第 `k` 个时间段结束后，钢琴位于 `(i,j)` 时的最长滑动距离。
2. **方向分治**：每个时间段内倾斜方向固定，按方向拆解为行或列的线性转移。
3. **单调队列优化**：将区间最值问题转化为滑动窗口问题，用单调队列维护可转移位置的最优值。

#### 解决难点
- **时间维度压缩**：将 `T` 个时间点转换为 `K` 个时间段，避免 `O(TNM)` 的超高复杂度。
- **转移方程变形**：将 `dp[k][i][j] = max(dp[k-1][i'][j'] + dis)` 改写为可单调队列维护的形式（如 `dp[k][i][j] = max(q.head + offset)`）。
- **障碍物处理**：遇到障碍物时清空队列，保证转移的合法性。

---

### 题解评分（≥4星）
1. **18811162081lyh（5星）**  
   - 滚动数组优化空间，代码简洁高效。
   - 分方向处理逻辑清晰，障碍物清空队列的细节处理到位。
   - 关键代码片段：
     ```cpp
     void work(int x, int y, int len, int d) {
         int head=1, tail=0;
         for(int i=1; x>=1 && x<=n && y>=1 && y<=m; i++, x+=dx[d], y+=dy[d]) {
             if(map[x][y]=='x') head=1, tail=0;
             else {
                 while(head<=tail && q[tail].dp + i - q[tail].pos < dp[x][y]) tail--;
                 q[++tail] = node{dp[x][y], i};
                 if(q[tail].pos - q[head].pos > len) head++;
                 dp[x][y] = q[head].dp + i - q[head].pos;
                 ans = max(ans, dp[x][y]);
             }
         }
     }
     ```

2. **FriedrichC（4星）**  
   - 数学推导详细，状态转移方程变形过程清晰。
   - 分方向实现时通过 `q[back] - q[front] > len` 控制窗口长度。
   - 使用 `dx[]` 和 `dy[]` 统一方向处理。

3. **关怀他人（4星）**  
   - 结构体封装队列元素，代码可读性强。
   - 预处理障碍物位置，避免重复判断。

---

### 最优思路提炼
1. **滚动数组**：仅保留当前和上一时间段的状态，空间复杂度从 `O(KNM)` 降为 `O(NM)`。
2. **方向分治**：对每个方向的转移单独处理，遍历顺序与滑动方向一致（如向北时从下往上扫描行）。
3. **偏移量技巧**：将 `dp[i][j] - pos` 存入队列，比较时加上当前位置的偏移量 `i` 恢复实际值。

---

### 同类型题推荐
1. **P1886 滑动窗口**（单调队列模板）
2. **P1714 切蛋糕**（前缀和 + 单调队列）
3. **P2627 修剪草坪**（动态规划 + 单调队列优化）

---

### 可视化设计
#### 算法演示（Canvas动画）
1. **网格绘制**：将 `N×M` 网格渲染为像素块，障碍物用红色标记。
2. **方向箭头**：当前时间段方向用动态箭头指示（如↑→↓←）。
3. **队列可视化**：
   - 队列元素显示为绿色方块，队首高亮为黄色。
   - 当前处理位置 `(i,j)` 闪烁蓝色边框。
4. **音效触发**：
   - 队列弹出元素时播放 `pop.wav`（8-bit音效）。
   - 更新最大值时播放 `ding.wav`。

#### 复古像素风格
```javascript
// 伪代码示例：绘制网格与队列状态
function drawGrid(ctx) {
    for (let i=0; i<n; i++) {
        for (let j=0; j<m; j++) {
            ctx.fillStyle = (i,j)有障碍 ? '#FF0000' : '#FFFFFF';
            ctx.fillRect(j*20, i*20, 18, 18);
            if (dp[i][j] > 0) {
                ctx.fillStyle = '#00FF00';
                ctx.fillText(dp[i][j], j*20+5, i*20+15);
            }
        }
    }
}
```

---

### 核心代码实现
```cpp
int dx[] = {0, -1, 1, 0, 0}, dy[] = {0, 0, 0, -1, 1}; // 方向数组

void process(int x, int y, int len, int dir) {
    deque<pair<int, int>> q; // {位置偏移, dp值}
    for (int step=1; ; x+=dx[dir], y+=dy[dir], step++) {
        if (x越界 || y越界 || 障碍物) break;
        if (map[x][y] == 'x') q.clear();
        else {
            // 维护单调递减队列
            while (!q.empty() && dp_prev[x][y] > q.back().second + (step - q.back().first))
                q.pop_back();
            q.emplace_back(step, dp_prev[x][y]);
            // 移除超出窗口长度的元素
            while (step - q.front().first > len) q.pop_front();
            dp_current[x][y] = q.front().second + (step - q.front().first);
        }
    }
}
```

---

### 总结
通过将时间维度压缩为区间，结合单调队列优化转移，算法复杂度从 `O(KN^3)` 优化至 `O(KN^2)`。核心在于分方向处理转移窗口，并通过队列维护可转移的最优值。

---
处理用时：82.57秒
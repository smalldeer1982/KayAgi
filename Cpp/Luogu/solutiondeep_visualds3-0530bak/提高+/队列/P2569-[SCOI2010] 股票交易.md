# 题目信息

# [SCOI2010] 股票交易

## 题目描述

最近 $\text{lxhgww}$ 又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。

通过一段时间的观察，$\text{lxhgww}$ 预测到了未来 $T$ 天内某只股票的走势，第 $i$ 天的股票买入价为每股 $AP_i$，第 $i$ 天的股票卖出价为每股 $BP_i$（数据保证对于每个 $i$，都有 $AP_i \geq BP_i$），但是每天不能无限制地交易，于是股票交易所规定第 $i$ 天的一次买入至多只能购买 $AS_i$ 股，一次卖出至多只能卖出 $BS_i$ 股。

另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔 $W$ 天，也就是说如果在第 $i$ 天发生了交易，那么从第 $i+1$ 天到第 $i+W$ 天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过 $\text{MaxP}$。

在第 $1$ 天之前，$\text{lxhgww}$ 手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，$T$ 天以后，$\text{lxhgww}$ 想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？



## 说明/提示

- 对于 $30\%$ 的数据，$0\leq W<T\leq 50,1\leq\text{MaxP}\leq50$；
- 对于 $50\%$ 的数据，$0\leq W<T\leq 2000,1\leq\text{MaxP}\leq50$；
- 对于 $100\%$ 的数据，$0\leq W<T\leq 2000,1\leq\text{MaxP}\leq2000$；
- 对于所有的数据，$1\leq BP_i\leq AP_i\leq 1000,1\leq AS_i,BS_i\leq\text{MaxP}$。

## 样例 #1

### 输入

```
5 2 0
2 1 1 1
2 1 1 1
3 2 1 1
4 3 1 1
5 4 1 1
```

### 输出

```
3```

# AI分析结果



# [SCOI2010] 股票交易 题解分析

## 唯一算法分类
**动态规划 + 单调队列优化**

---

## 题解思路与核心难点

### 核心算法流程
1. **状态定义**  
   `dp[i][j]` 表示第 `i` 天后持有 `j` 股的最大收益。

2. **状态转移**  
   - **不操作**：`dp[i][j] = max(dp[i][j], dp[i-1][j])`  
   - **首次买入**：`dp[i][j] = -AP_i * j`（仅限 `j ≤ AS_i`）  
   - **基于历史买入**：`dp[i][j] = max(dp[i-w-1][k] - (j-k)*AP_i)`（需单调队列优化）  
   - **基于历史卖出**：`dp[i][j] = max(dp[i-w-1][k] + (k-j)*BP_i)`（需单调队列优化）

3. **单调队列优化**  
   - **买入优化**：将 `dp[i-w-1][k] + k*AP_i` 维护为单调递减队列，窗口范围为 `[j-AS_i, j]`  
   - **卖出优化**：将 `dp[i-w-1][k] + k*BP_i` 维护为单调递减队列，窗口范围为 `[j, j+BS_i]`

---

## 最优题解清单（评分 ≥4★）

### 1. Sooke 的题解（5★）
- **亮点**：  
  - 详细推导状态转移方程，明确分四种情况讨论  
  - 代码实现清晰，包含单调队列的完整维护逻辑  
  - 解释为何需要正序/倒序遍历 `j`

### 2. Memorize 的题解（4★）
- **亮点**：  
  - 代码简洁，直接展示核心逻辑  
  - 使用数组模拟队列，避免 STL 性能开销  
  - 明确二进制优化思路（但未在最终代码中采用）

### 3. Krydom 的题解（4★）
- **亮点**：  
  - 提供状态转移方程的数学变形过程  
  - 强调 `j` 遍历顺序对单调队列的影响  
  - 代码注释清晰，适合新手理解

---

## 关键代码片段

### 单调队列优化买入逻辑（Sooke 的代码）
```cpp
// 买入优化
l = 1, r = 0;
for (int j = 0; j <= m; j++) {
    while (l <= r && q[l] < j - as) l++;
    while (l <= r && f[i-w-1][q[r]] + q[r]*ap <= f[i-w-1][j] + j*ap) r--;
    q[++r] = j;
    if (l <= r) f[i][j] = max(f[i][j], f[i-w-1][q[l]] - (j - q[l])*ap);
}
```

---

## 同类型题目推荐
1. **P1886 滑动窗口**（单调队列模板题）  
2. **P1725 琪露诺**（单调队列优化 DP）  
3. **P2627 [USACO11OPEN]Mowing the Lawn G**（单调队列 + 前缀和优化）

---

## 可视化设计要点

### 动画方案
1. **数据结构展示**：  
   - **网格图**：行表示天数，列表示股票数量，颜色深浅表示收益高低（红色亏损，绿色盈利）。  
   - **队列窗口**：用动态高亮框标注当前处理的 `j` 值，蓝色框表示买入窗口，橙色框表示卖出窗口。

2. **关键操作高亮**：  
   - **队列插入/删除**：用闪烁效果标记被移出队列的元素。  
   - **状态更新**：当 `dp[i][j]` 更新时，对应网格单元格短暂放大。

3. **音效设计**：  
   - **队列操作**：`pop` 时播放短促“滴”声，`push` 时播放“咔嗒”声。  
   - **状态更新**：成功更新最大值时播放上扬音调。

4. **复古像素风格**：  
   - **8-bit 调色板**：使用 NES 风格的 16 色方案（深绿、浅绿、红、橙）。  
   - **网格绘制**：每个单元格为 16x16 像素，边框为 1px 黑色线条。

---

## 核心算法演示（伪代码）
```javascript
// Canvas 绘制函数示例
function drawGrid(day, stocks, profit) {
    ctx.fillStyle = getColor(profit); // 根据收益值映射颜色
    ctx.fillRect(day * 20, stocks * 20, 18, 18);
}

// 单调队列维护逻辑
function maintainQueue(queue, newVal) {
    while (queue.length > 0 && queue.last().val < newVal) {
        queue.pop();
        playSound('pop'); // 播放队列弹出音效
    }
    queue.push(newVal);
    playSound('push');
}
```

---

## 总结
通过动态规划定义状态，结合单调队列优化转移过程中的区间最值查询，将时间复杂度从 O(n³) 降至 O(n²)。关键难点在于正确维护队列窗口范围和遍历顺序，确保状态转移的高效性。

---
处理用时：73.86秒
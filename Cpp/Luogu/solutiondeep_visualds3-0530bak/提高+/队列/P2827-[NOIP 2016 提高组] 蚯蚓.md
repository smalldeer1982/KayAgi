# 题目信息

# [NOIP 2016 提高组] 蚯蚓

## 题目背景

NOIP2016 提高组 D2T2

## 题目描述

本题中，我们将用符号 $\lfloor c \rfloor$ 表示对 $c$ 向下取整，例如：$\lfloor 3.0 \rfloor = \lfloor 3.1 \rfloor = \lfloor 3.9 \rfloor = 3$。

蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。

蛐蛐国里现在共有 $n$ 只蚯蚓（$n$ 为正整数）。每只蚯蚓拥有长度，我们设第 $i$ 只蚯蚓的长度为 $a_i\,(i=1,2,\dots,n)$，并保证所有的长度都是非负整数（即：可能存在长度为 $0$ 的蚯蚓）。

每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 $p$（是满足 $0 < p < 1$ 的有理数）决定，设这只蚯蚓长度为 $x$，神刀手会将其切成两只长度分别为 $\lfloor px \rfloor$ 和 $x - \lfloor px \rfloor$ 的蚯蚓。特殊地，如果这两个数的其中一个等于 $0$，则这个长度为 $0$ 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 $q$（是一个非负整常数）。

蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 $m$ 秒才能到来……（$m$ 为非负整数）

蛐蛐国王希望知道这 $m$ 秒内的战况。具体来说，他希望知道：

- $m$ 秒内，每一秒被切断的蚯蚓被切断前的长度（有 $m$ 个数）；
- $m$ 秒后，所有蚯蚓的长度（有 $n + m$ 个数）。

蛐蛐国王当然知道怎么做啦！但是他想考考你……

## 说明/提示

**样例解释 1**

在神刀手到来前：$3$ 只蚯蚓的长度为 $3,3,2$。

$1$ 秒后：一只长度为 $3$ 的蚯蚓被切成了两只长度分别为$1$ 和 $2$ 的蚯蚓，其余蚯蚓的长度增加了 $1$。最终 $4$ 只蚯蚓的长度分别为 $(1,2),4,3$。括号表示这个位置刚刚有一只蚯蚓被切断。

$2$ 秒后：一只长度为 $4$ 的蚯蚓被切成了 $1$ 和 $3$。$5$ 只蚯蚓的长度分别为：$2,3,(1,3),4$。

$3$ 秒后：一只长度为 $4$ 的蚯蚓被切断。$6$ 只蚯蚓的长度分别为：$3,4,2,4,(1,3)$。

$4$ 秒后：一只长度为 $4$ 的蚯蚓被切断。$7$ 只蚯蚓的长度分别为：$4,(1,3),3,5,2,4$。

$5$ 秒后：一只长度为 $5$ 的蚯蚓被切断。$8$ 只蚯蚓的长度分别为：$5,2,4,4,(1,4),3,5$。

$6$ 秒后：一只长度为 $5$ 的蚯蚓被切断。$9$ 只蚯蚓的长度分别为：$(1,4),3,5,5,2,5,4,6$。

$7$ 秒后：一只长度为 $6$ 的蚯蚓被切断。$10$ 只蚯蚓的长度分别为：$2,5,4,6,6,3,6,5,(2,4)$。所以，$7$ 秒内被切断的蚯蚓的长度依次为 $3,4,4,4,5,5,6$。$7$ 秒后，所有蚯蚓长度从大到小排序为 $6,6,6,5,5,4,4,3,2,2$。

**样例解释 2**

这个数据中只有 $t=2$ 与上个数据不同。只需在每行都改为每两个数输出一个数即可。

虽然第一行最后有一个 $6$ 没有被输出，但是第二行仍然要重新从第二个数再开始输出。

**样例解释 3**

这个数据中只有 $t=9$ 与上个数据不同。

注意第一行没有数要输出，但也要输出一个空行。


**数据范围**

![](https://cdn.luogu.com.cn/upload/pic/3458.png)


## 样例 #1

### 输入

```
3 7 1 1 3 1
3 3 2```

### 输出

```
3 4 4 4 5 5 6
6 6 6 5 5 4 4 3 2 2```

## 样例 #2

### 输入

```
3 7 1 1 3 2
3 3 2```

### 输出

```
4 4 5
6 5 4 3 2```

## 样例 #3

### 输入

```
3 7 1 1 3 9
3 3 2```

### 输出

```
//空行
2```

# AI分析结果



# 算法分类  
**队列应用**

---

## 题解思路与核心分析  
### 核心逻辑与解决难点  
1. **队列单调性**：  
   - 所有题解均基于关键结论：先被切割的蚯蚓生成的两段长度严格大于后被切割的对应段。  
   - 维护三个队列：原始队列（排序后）、左段队列（$\lfloor px \rfloor$）、右段队列（$x - \lfloor px \rfloor$），均保持单调递减。  

2. **全局偏移量**：  
   - 通过记录累计增量 `delta`，避免每次全体元素更新，切割后新元素存入队列时需减去当前偏移量。  
   - 例如：第 `i` 秒切割的元素真实长度为 `x = queue.front() + delta`，新生成的左段存入队列时值为 `(x * u / v) - delta - q`。  

3. **时间复杂度优化**：  
   - 从优先队列的 $O(m \log n)$ 优化为 $O(n \log n + m)$（排序时间 + 线性处理时间）。  

---

## 题解评分（≥4星）  
### 五星题解  
1. **dbxxx（赞383）**  
   - **亮点**：  
     - 严谨证明切割段的单调性（修正其他题解的常见错误）。  
     - 代码实现简洁，使用 `std::pair` 快速比较三个队列头。  
     - 全局偏移量处理清晰，变量命名规范。  
   - **评分**：★★★★★  

### 四星题解  
1. **Log_x（赞4）**  
   - **亮点**：  
     - 分步骤分析堆优化与队列优化的差异。  
     - 完整代码注释，逻辑分层清晰。  
     - 手写堆实现对比增强可读性。  
   - **评分**：★★★★☆  

2. **shadowice1984（赞9）**  
   - **亮点**：  
     - 文字证明简洁，代码使用队列下标直接操作。  
     - 偏移量命名为 `j`，与时间变量 `i` 联动，减少冗余计算。  
   - **评分**：★★★★☆  

---

## 最优思路与技巧  
### 关键实现  
```cpp  
// dbxxx 题解核心代码  
int get() {  
    pii p = max({  
        {qw[1].empty() ? mininf : qw[1].front(), 1},  
        {qw[2].empty() ? mininf : qw[2].front(), 2},  
        {qw[3].empty() ? mininf : qw[3].front(), 3}  
    });  
    int x = p.first + q * i; // 计算真实长度  
    int b = 1ll * x * u / v, c = x - b;  
    qw[2].push(b - q - q * i); // 存入左段队列  
    qw[3].push(c - q - q * i); // 存入右段队列  
}  
```  
- **全局偏移量**：存入队列时减去 `q * i` 以抵消后续时间步的增量。  
- **队列选择**：使用 `std::max` 直接比较三个队列头，避免冗余判断。  

---

## 同类型题目与扩展  
1. **合并果子（P1090）**  
   - 堆/队列优化的经典问题，可对比蚯蚓的单调性优化思路。  

2. **滑动窗口（P1886）**  
   - 单调队列维护极值，与本题队列选择最大值的逻辑相似。  

3. **P6033 合并果子 加强版**  
   - 大数据下的线性优化，与本题的队列替代堆思想一致。  

---

## 可视化算法演示  
### 动画设计  
1. **队列状态面板**：  
   - 三个队列横向排列，用不同颜色区分（原始队列：蓝色，左段队列：绿色，右段队列：橙色）。  
   - 当前选中队列头高亮为红色，切割后生成的两段渐入对应队列尾部。  

2. **偏移量动态显示**：  
   - 顶部显示 `当前时间: i | 全局偏移量: delta = q * i`。  
   - 每次切割后，新元素旁标注 `计算值 = 原始值 - delta`。  

3. **复古像素风格**：  
   - **调色板**：使用 8-bit 风格的蓝、绿、橙、红。  
   - **音效**：  
     - 切割时播放短促的 "blip" 音效（类似 FC 游戏动作音）。  
     - 队列切换时播放轻微 "click"。  

### 交互控制  
- **步进/暂停**：允许单步执行观察队列变化。  
- **速度调节**：拖动条控制动画速度（1x~10x）。  

---

## 个人心得摘录  
- **dbxxx**：  
  > "蓝书原证明存在错误，通过数学归纳严格证明切割段的单调性是本题正确性的关键。"  
- **Log_x**：  
  > "手写堆与队列对比实现，深刻理解时间复杂度的优化边界。"  

---

## 核心代码实现（dbxxx）  
```cpp  
#include <bits/stdc++.h>  
inline int read() { /* 快读实现 */ }  
const int maxn = (int)1e5 + 5;  
std::queue<int> qw[4];  

int main() {  
    int n = read(), m = read(), q = read(), u = read(), v = read(), t = read();  
    for (int i = 1; i <= n; ++i) a[i] = read();  
    std::sort(a + 1, a + n + 1, std::greater<int>());  
    for (int i = 1; i <= n; ++i) qw[1].push(a[i]);  

    for (int i = 0; i < m; ++i) {  
        // 取出最大值并切割  
        pii p = std::max(/* 比较三个队列头 */);  
        int x = p.first + q * i;  
        int b = 1ll * x * u / v, c = x - b;  
        qw[2].push(b - q - q * i);  
        qw[3].push(c - q - q * i);  
    }  
}  
```  

---

通过队列单调性与全局偏移量的设计，本题在保证正确性的同时实现了高效的线性时间复杂度，是NOIP经典优化思想的典型代表。

---
处理用时：81.69秒
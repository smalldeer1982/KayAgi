# 题目信息

# 开心派对小火车

## 题目描述

Aqours铁路公司旗下有N个站，编号1,2,..,N。

有各停（各站停车）电车特急电车两种。特急车会在$S_1,S_2,...,S_M (1=S_1<S_2 <...<S_M=N)$，一共M个车站停车。


相邻的两站(即编号为i的车站和编号为$i+1$的车站，而不是特急电车停车的相邻的两站)之间，各停电车要运行A分钟，特急需要B分钟。我们认为列车一直匀速运行，不考虑停车和加减速。


现在要加一种快速电车，要求其停站覆盖所有的特急电车的停站，而相邻的两站要运行C分钟。为了要快，决定刚好停K个站（$K>M$，包括特急的所有车站）。如果一个站可以停多种电车，那么旅客可以在这一站换乘。不过只能向前坐车，不能往回坐。


你需要设计一种快速列车的设站方案，要求旅客在T分钟**乘车时间（等车和换乘时间不计）**内，可以从1号站到尽可能多数量的站。你只需要告知能有几站可以达到。


## 说明/提示

【样例解释】

可以设快速列车站为1/5/6/8/10。

2,3,4可以直接乘坐各停慢车，5可以乘坐快速列车，6,10可以乘坐特急列车，7可以到6转慢车，8可以到6传快速列车。9没办法在30分钟的乘车时间内到达

【数据范围】

对于20%的数据，$N \le 300, K-M=2, A \le 10^6 , T \le 10^9$

对于50%的数据，$N \le 1000$

对于100%的数据，$2 \le N \le 10^9, 2 \le M \le K \le 3000, 1 \le B < C < A \le 10^9, i \le T \le 10^{18}$


## 样例 #1

### 输入

```
10 3 5
10 3 5
30
1
6
10
```

### 输出

```
8
```

# AI分析结果



**唯一算法分类**：贪心算法

---

### **题解思路与算法要点**

#### **核心思路**
1. **问题分解**：将整个线路按特急车站分割成多个区间，每个区间内独立计算可能的快速车站贡献。
2. **贪心策略**：每个区间内，按新增快速车站的贡献从大到小生成候选值，用优先队列选出前 \(K-M\) 大的贡献。
3. **时间计算**：从起点到特急车站的时间为 \((s_i-1) \cdot B\)，再计算转乘快速或慢车后的剩余时间，确定覆盖范围。

#### **解决难点**
- **高效生成贡献**：每个区间的贡献单调递减，只需处理前 \(K-M+1\) 个值。
- **避免重复覆盖**：通过限制快速车站的生成顺序，确保每次新增贡献唯一且最大。
- **边界处理**：终点站需单独判断是否在总时间内可达。

---

### **题解评分 (≥4星)**

1. **题解作者：gdf_yhm**（⭐⭐⭐⭐⭐）  
   - **亮点**：代码简洁，通过优先队列动态维护贡献值，限制每个区间生成贡献次数，避免MLE。
   - **优化**：处理每个区间时仅生成前 \(k+1\) 个贡献，保证时间复杂度 \(O(K \log K)\)。

2. **题解作者：Day_Dreamer_H**（⭐⭐⭐⭐）  
   - **亮点**：详细注释，代码逻辑清晰，直接体现贪心思想的实现。
   - **优化**：在循环中显式处理计数器，避免无效贡献入队。

3. **题解作者：ditoly**（⭐⭐⭐⭐）  
   - **亮点**：思路简洁，强调动态生成贡献的递归性，适合理解贪心的本质。
   - **优化**：通过暴力找最大或堆实现，灵活适应不同数据规模。

---

### **最优思路与技巧提炼**

1. **贡献生成顺序**  
   - 在特急区间 \(s_i \sim s_{i+1}\) 内，初始覆盖的站数由慢车决定。  
   - 每次在未覆盖区域的下一个位置设置快速车站，生成新的贡献值，并确保其单调递减。

2. **优先队列优化**  
   - 维护全局最大贡献，每次取堆顶元素累加，保证总贡献最大。

3. **时间复杂度控制**  
   - 每个区间最多生成 \(K-M+1\) 个贡献，总复杂度 \(O(M \cdot K + K \log K)\)。

---

### **同类型题与算法套路**

- **类似问题**：区间覆盖问题、任务调度中的最大收益选择。
- **通用解法**：将问题分解为独立区间，按贪心策略生成候选解，用堆维护全局最优。

---

### **推荐相似题目**

1. **P1090 合并果子**（贪心+优先队列）  
2. **P3620 数据备份**（区间选择与贪心优化）  
3. **AT_joi2017ho_b**（双倍经验题，同题不同场景）

---

### **可视化与算法演示**

#### **动画方案**
- **像素风格**：8位色块表示车站，颜色区分特急（红）、快速（蓝）、慢车（绿）。
- **关键步骤**：
  1. 高亮当前处理的区间 \(s_i \sim s_{i+1}\)。
  2. 动态绘制从 \(s_i\) 出发的覆盖范围（绿色块）。
  3. 插入快速车站后，显示新增覆盖（蓝色块），并更新贡献值。
  4. 优先队列中弹出最大贡献，对应块变为金色。

#### **交互设计**
- **速度控制**：滑块调节动画速度（0.5x~3x）。
- **音效**：插入车站时播放“哔”声，弹出堆顶时播放“叮”声。

---

### **核心代码实现**

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n, m, k, a, b, c, t, ans;
int s[30005];
priority_queue<int> q;

signed main() {
    scanf("%lld%lld%lld", &n, &m, &k);
    k -= m;
    scanf("%lld%lld%lld%lld", &a, &b, &c, &t);
    for (int i = 1; i <= m; i++) scanf("%lld", &s[i]);
    
    for (int i = 1; i < m; i++) {
        int pos = s[i], cnt = 0;
        while (pos < s[i+1]) {
            cnt++;
            int rem = t - (s[i]-1)*b - (pos - s[i])*c;
            if (rem < 0) break;
            int res = rem / a + 1;
            if (pos + res > s[i+1]) res = s[i+1] - pos;
            pos += res;
            if (cnt == 1) ans += res;
            else q.push(res);
            if (cnt > k + 1) break;
        }
    }
    if (t >= (n-1)*b) ans++;
    while (!q.empty() && k--) ans += q.top(), q.pop();
    printf("%lld", ans - 1);
    return 0;
}
```

---

### **总结**

通过贪心策略和优先队列优化，将问题分解为独立区间处理，确保每次选择贡献最大的快速车站，最终在 \(O(K \log K)\) 时间复杂度内高效求解。

---
处理用时：142.84秒
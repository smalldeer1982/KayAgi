# 题目信息

# [TJOI2013] 奖学金

## 题目背景

小张最近发表了一篇论文，有一个神秘人物要给小张学院发奖学金。

## 题目描述

小张学院有 $c$ 名学生，第 $i$ 名学生的成绩为 $a_i$，要获得的奖学金金额为 $b_i$。  
要从这 $c$ 名学生中挑出 $n$ 名学生发奖学金。这个神秘人物爱好奇特，他希望得到奖学金的同学的**成绩**的**中位数**尽可能大，但同时，他们的**奖学金总额**不能超过 $f$。


## 说明/提示

### 样例 1 解释

选择成绩为 $5$，$35$，$50$ 的三名同学，奖金总额为 $18 + 30 + 21 = 69$。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10^3$，$c \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $3 \leq n  \leq 10^5$，$n \leq c \leq 2 \times 10^5$，$0 \leq f \leq 2\times 10^9$，$0 \leq a_i \leq 2 \times 10^9$，$0 \leq b_i \leq 10^5$。

## 样例 #1

### 输入

```
3 5 70
30 25
50 21
20 20
5 18
35 30
```

### 输出

```
35```

## 样例 #2

### 输入

```
5 6 9
4 0
4 1
6 3
8 0
10 4
10 5
```

### 输出

```
6```

# AI分析结果



# 算法分类
**贪心 + 堆（优先队列）**

---

## 题解思路与算法要点

### 核心思路
1. **排序学生**：按成绩从大到小排序，便于枚举中位数。
2. **预处理左右最小奖学金和**：
   - 左半区间（前i-1个学生中选k个最小的和）：用最大堆维护当前最小的k个值。
   - 右半区间（后i+1个学生中选k个最小的和）：同理，反向维护最大堆。
3. **枚举中位数**：从中间可能的区间遍历，验证总奖学金是否满足条件。

### 解决难点
- **动态维护前k小和**：通过最大堆快速替换较大的元素，保证堆内始终保存最小的k个值。
- **边界处理**：确保枚举的中位数左右至少有k个候选学生。

---

## 题解评分（≥4星）

1. **胖头鱼学员（5星）**  
   - **亮点**：代码简洁，堆预处理左右和，反向遍历快速找到最大可行中位数。
   - **代码**：预处理左半和右半区间的最小和，逻辑清晰。

2. **ycyaw（4星）**  
   - **亮点**：堆预处理与胖头鱼类似，但代码风格更紧凑，变量命名清晰。
   - **心得**：调试中发现需在叶子节点乘k的细节。

3. **ix35（4星）**  
   - **亮点**：权值线段树实现动态区间前k小和查询，思路独特但复杂度略高。

---

## 最优思路提炼

1. **贪心策略**：排序后选择中位数，左右取最小k个奖学金。
2. **堆优化**：用最大堆维护当前最小的k个值，时间复杂度O(c log k)。
3. **预处理数组**：提前计算每个位置左右的最小和，枚举时直接验证。

---

## 类似题目推荐

1. **P1168 中位数**  
   - 动态维护中位数，可用堆或平衡树。

2. **P1801 黑匣子**  
   - 动态查询第k小，练习堆或树状数组。

3. **P3834 静态区间第k小**  
   - 主席树经典问题，强化区间查询能力。

---

## 个人心得摘录

- **调试教训**（渡墨残殇）：在叶子节点需返回`k * val`而非单个值，避免忽略重复元素。
- **优化技巧**（胖头鱼学员）：反向遍历中位数候选，找到第一个合法解即可终止。

---

## 算法可视化设计

### 动画方案
1. **排序展示**：学生按成绩降序排列，显示为纵向条形图，高度表示成绩。
2. **堆维护过程**：
   - **颜色标记**：当前中位数（红色），左堆元素（绿色），右堆元素（蓝色）。
   - **动态更新**：插入新元素时，若小于堆顶则替换，堆顶显示为黄色。
3. **总和计算**：实时显示左右堆和与总奖学金，超限时标红。

### 复古像素风格
- **Canvas绘制**：学生显示为像素块，颜色深浅表示奖学金高低。
- **音效设计**：
  - **选中中位数**：8-bit“确认”音效。
  - **总和合法**：胜利音效（上扬旋律）。
  - **超限**：短促“错误”音效。

### 交互功能
- **步进控制**：手动调整中位数位置，观察堆变化。
- **自动演示**：AI自动遍历中位数，找到最大解后高亮显示。

---

## 核心代码实现

```cpp
#include <algorithm>
#include <queue>
using namespace std;
const int MAXN = 2e5 + 5;

struct Student { int score, money; } a[MAXN];
int n, c, f, k;
int preSum[MAXN], sufSum[MAXN];

bool cmp(Student x, Student y) { return x.score > y.score; }

void preProcess() {
    priority_queue<int> q;
    int sum = 0;
    for (int i = 1; i <= c; i++) {
        if (i <= k) {
            q.push(a[i].money);
            sum += a[i].money;
        } else if (a[i].money < q.top()) {
            sum += a[i].money - q.top();
            q.pop();
            q.push(a[i].money);
        }
        preSum[i] = (i > k) ? sum : (i == k ? sum : 0);
    }
    // 类似处理 sufSum（反向遍历）
}

int main() {
    scanf("%d%d%d", &n, &c, &f);
    k = n / 2;
    for (int i = 1; i <= c; i++) 
        scanf("%d%d", &a[i].score, &a[i].money);
    sort(a + 1, a + c + 1, cmp);
    preProcess();
    // 反向遍历找最大中位数
    for (int i = c - k; i > k; i--) {
        if (preSum[i-1] + sufSum[i+1] + a[i].money <= f) {
            printf("%d", a[i].score);
            return 0;
        }
    }
    printf("-1");
    return 0;
}
```

---

**总结**：通过堆预处理左右最小和，贪心枚举最大中位数，时间复杂度O(c log k)，空间O(c)，高效解决本题。

---
处理用时：101.75秒
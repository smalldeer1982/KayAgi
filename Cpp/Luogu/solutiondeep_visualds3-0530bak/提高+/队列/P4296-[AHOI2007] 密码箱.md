# 题目信息

# [AHOI2007] 密码箱

## 题目描述

在一次偶然的情况下，小可可得到了一个密码箱，听说里面藏着一份古代流传下来的藏宝图，只要能破解密码就能打开箱子，而箱子背面刻着的古代图标，就是对密码的提示。

经过艰苦的破译，小可可发现，这些图标表示一个数以及这个数与密码的关系。假设这个数是 $n$，密码为 $x$，那么可以得到如下表述： 密码 $x$ 大于等于 $0$，且小于 $n$，而 $x$ 的平方除以 $n$，得到的余数为 $1$。 小可可知道满足上述条件的 $x$ 可能不止一个，所以一定要把所有满足条件的 $x$ 计算出来，密码肯定就在其中。计算的过程是很艰苦的，你能否编写一个程序来帮助小可可呢？

## 样例 #1

### 输入

```
12```

### 输出

```
1
5
7
11```

# AI分析结果



**唯一算法分类**：数论（因数分解与同余方程）

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
所有题解均基于 **因数分解构造法**：
1. 将方程转化为 $(x+1)(x-1) \equiv 0 \pmod{n}$，即 $n$ 必须整除 $(x+1)(x-1)$。
2. 枚举 $n$ 的所有因数对 $(a,b)$（满足 $a \times b = n$），构造 $x$ 使得：
   - $a$ 整除 $(x-1)$ 且 $b$ 整除 $(x+1)$，或
   - $a$ 整除 $(x+1)$ 且 $b$ 整除 $(x-1)$。
3. 通过循环生成可能的 $x$ 值，并用集合去重。

#### **算法要点**
- **因数分解**：仅需枚举到 $\sqrt{n}$，降低时间复杂度至 $O(\sqrt{n})$。
- **构造 $x$**：对每个因数对 $(a,b)$，生成 $x$ 的可能形式：
  - $x = k \cdot b \pm 1$，检查是否满足 $(x \pm 1) \bmod a = 0$。
- **去重与排序**：使用 `std::set` 或 `std::unique` 保证结果唯一且有序。

#### **解决难点**
- **避免重复解**：通过集合自动去重或手动去重。
- **特判 $n=1$**：此时无解需单独处理。
- **边界条件**：确保 $x < n$ 且为非负数。

---

### **题解评分（≥4星）**

1. **JuRuo_QAQ（⭐⭐⭐⭐⭐）**
   - **亮点**：代码简洁，使用 `set` 自动去重，逻辑清晰。
   - **代码片段**：
     ```cpp
     for(register ll j=b+1;j<=n;j+=b)if((j+1)%i==0)s.insert(j);
     for(register ll j=b-1;j<=n;j+=b)if((j-1)%i==0)s.insert(j);
     ```

2. **试试事实上吗（⭐⭐⭐⭐）**
   - **亮点**：优化循环条件，变量命名清晰。
   - **代码片段**：
     ```cpp
     for(int j=b+1;j<=n;j+=b) if((j+1)%i==0) st.insert(j);
     for(int j=b-1;j<=n;j+=b) if((j-1)%i==0) st.insert(j);
     ```

3. **Aiopr_2378（⭐⭐⭐⭐）**
   - **亮点**：注释详细，适合教学。
   - **代码片段**：
     ```cpp
     for(ll j=b+1;j<=n;j+=b) if((j+1)%a==0) ans.insert(j);
     for(ll j=b-1;j<=n;j+=b) if((j-1)%a==0) ans.insert(j);
     ```

---

### **最优思路或技巧提炼**
1. **因数对构造法**：分解 $n = a \times b$，通过 $a$ 和 $b$ 的整除关系生成 $x$。
2. **高效枚举**：仅枚举 $\sqrt{n}$ 内的因数，降低时间复杂度。
3. **集合去重**：使用 `std::set` 简化去重逻辑，避免手动处理重复值。

---

### **同类型题或类似算法套路**
- **模方程求解**：如求解 $x^k \equiv c \pmod{n}$，可分解模数并构造解。
- **因数分解应用**：如求公约数、质因数分解等数论问题。

---

### **推荐相似题目**
1. **P1365** - 斐波那契数列（模方程）
2. **P1075** - 质因数分解（因数分解）
3. **P2485** - 计算器（同余方程）

---

### **个人心得摘录**
- **调试教训**：必须开 `long long`，否则大数会溢出（如 `JuRuo_QAQ` 的注释）。
- **优化技巧**：枚举到 $\sqrt{n}$ 而非 $n$ 极大提升效率（如 `试试事实上吗` 的循环条件）。

---

### **可视化与算法演示**
**动画方案**：
1. **因数分解步骤**：高亮当前枚举的因数 $a$ 和对应的 $b = n/a$。
2. **生成 $x$ 值**：用不同颜色标记 `j += b` 的循环，绿色表示合法解，红色表示不满足条件。
3. **集合更新**：动态显示 `set` 中插入新解的过程。

**复古像素风格**：
- **颜色方案**：8位色调（如绿色为 `#00FF00`，红色为 `#FF0000`）。
- **音效**：
  - 插入解时播放短促“滴”声。
  - 完成所有枚举后播放胜利音效。

**代码演示片段（JS伪代码）**：
```javascript
function visualize() {
  let a = 1;
  while (a * a <= n) {
    if (n % a === 0) {
      const b = n / a;
      // 生成 x 并检查条件
      highlightFactorPair(a, b);
      generateXValues(a, b);
    }
    a++;
  }
}
```

---

**总结**：通过因数分解构造解是数论问题的经典思路，结合高效枚举和集合管理，可优雅解决模方程问题。

---
处理用时：90.96秒
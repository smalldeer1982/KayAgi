# 题目信息

# [IOI 2008] Island

## 题目描述

你准备浏览一个公园，该公园由 $N$ 个岛屿组成，当地管理部门从每个岛屿 $i$ 出发向另外一个岛屿建了一座长度为 $L_i$ 的桥，不过桥是可以双向行走的。同时，每对岛屿之间都有一艘专用的往来两岛之间的渡船。相对于乘船而言，你更喜欢步行。你希望经过的桥的总长度尽可能长，但受到以下的限制：

- 可以自行挑选一个岛开始游览。
- 任何一个岛都不能游览一次以上。
- 无论任何时间，你都可以由当前所在的岛 $S$ 去另一个从未到过的岛 $D$。从 $S$ 到 $D$ 有如下方法：
  - 步行：仅当两个岛之间有一座桥时才有可能。对于这种情况，桥的长度会累加到你步行的总距离中。
  - 渡船：你可以选择这种方法，仅当没有任何桥和以前使用过的渡船的组合可以由 $S$ 走到 $D$ (当检查是否可到达时，你应该考虑所有的路径，包括经过你曾游览过的那些岛)。

注意，你不必游览所有的岛，也可能无法走完所有的桥。

请你编写一个程序，给定 $N$ 座桥以及它们的长度，按照上述的规则，计算你可以走过的桥的长度之和的最大值。

## 说明/提示

**样例解释**：

![样例图示](https://cdn.vijos.org/fs/c82895f1d6f84d5756610176662d6ee644c3e55e)

样例 $N=7$ 座桥，分别为 $(1-3), (2-7), (3-4), (4-1), (5-1), (6-3)$ 以及 $(7-2)$。注意连接岛 $2$ 与岛 $7$ 之间有两座不同的桥。

其中一个可以取得最大的步行距离的方法如下：

- 由岛 $5$ 开始。
- 步行长度为 $9$ 的桥到岛 $1$。
- 步行长度为 $8$ 的桥到岛 $3$。
- 步行长度为 $4$ 的桥到岛 $6$。
- 搭渡船由岛 $6$ 到岛 $7$。
- 步行长度为 $3$ 的桥到岛 $2$。

最后，你到达岛 $2$，而你的总步行距离为 $9+8+4+3=24$。

只有岛 $4$ 没有去。注意，上述游览结束时，你不能再游览这个岛。更准确地说：

- 你不可以步行去游览，因为没有桥连接岛 $2$ (你现在的岛) 与岛 $4$。
- 你不可以搭渡船去游览，因为你可由当前所在的岛 $2$ 到达岛 $4$。一个方法是：走 $(2-7)$ 桥，再搭你曾搭过的渡船由岛 $7$ 去岛 $6$，然后走 $(6-3)$ 桥，最后走 $(3-4)$ 桥。

**数据范围**：

对于 $100\%$ 的数据，$2\leqslant N\leqslant 10^6,1\leqslant L_i\leqslant 10^8$。


## 样例 #1

### 输入

```
7
3 8
7 2
4 2
1 4
1 9
3 4
2 3```

### 输出

```
24```

# AI分析结果



# [IOI 2008] Island 题解分析

**唯一算法分类**：基环树直径计算

---

## 综合分析与结论

### 核心思路
基环树森林的直径由每棵基环树的直径之和构成。基环树直径分为两种情况：
1. **不经过环**：在基环树的某个子树内部，通过树形DP求解子树直径。
2. **经过环**：路径跨越环上两棵子树，需用破环成链+单调队列优化计算。

### 解决难点
1. **找环**：通过拓扑排序或DFS识别环，标记环上节点。
2. **子树直径**：树形DP求子树内最长链和次长链。
3. **环上路径优化**：将环展开为链，通过前缀和与单调队列维护最大值。

### 可视化设计
- **基环树展开**：用不同颜色标记环节点（红色）和子树节点（绿色）。
- **单调队列动画**：高亮当前处理的环上节点，动态显示队列维护的最大值。
- **复古像素风格**：使用16色调色板，环节点用方块表示，子树用树状结构连接，音效在队列更新时触发。

---

## 题解清单（≥4星）

### 1. TEoS（5星）
- **核心亮点**：DFS找环 + 树形DP + 单调队列优化
- **关键代码**：
  ```cpp
  // 树形DP求子树直径
  void tree_dp(int now) {
      v2[now] = 1;
      for (int i = head[now]; i; i = next[i]) {
          int y = ver[i];
          if (v2[y]) continue;
          tree_dp(y);
          ans = max(ans, d[now] + d[y] + edge[i]);
          d[now] = max(d[now], d[y] + edge[i]);
      }
  }
  ```

### 2. Mivik（4星）
- **核心亮点**：拓扑排序找环 + 双最大值优化
- **关键代码**：
  ```cpp
  // 维护环上最大值
  for (int i = st; i <= 2*cnt-st+1; i++) {
      while (q.size() && q.front() <= i-cnt+st-1) q.pop_front();
      ans3 = max(ans3, dp[i] + dp[q.front()] + s[i] - s[q.front()]);
      while (q.size() && dp[q.back()] - s[q.back()] <= dp[i] - s[i]) q.pop_back();
      q.push_back(i);
  }
  ```

### 3. marTixx（4星）
- **核心亮点**：树形DP + 断环成链预处理
- **关键技巧**：环上距离前缀和处理，避免重复枚举。

---

## 最优思路提炼

### 关键步骤
1. **拓扑排序找环**：通过度数为1的节点逐层剥离子树，最终剩余节点即为环。
2. **树形DP求子树信息**：对每个环节点求子树最长链，同时更新子树直径。
3. **破环成链+单调队列**：展开环为双倍链，维护 `d[i] - dis[i]` 的最大值，快速计算环上最优路径。

### 同类型题推荐
1. [P2607 [ZJOI2008] 骑士](https://www.luogu.com.cn/problem/P2607)
2. [P1453 城市环路](https://www.luogu.com.cn/problem/P1453)
3. [CF835F Roads in the Kingdom](https://www.luogu.com.cn/problem/CF835F)

---

## 可视化与算法演示

### 动画方案
1. **基环树展开**：用红色标记环节点，绿色标记子树节点。
2. **单调队列维护**：当前处理的环节点高亮为黄色，队列中的候选值用蓝色标记。
3. **音效触发**：节点入队时播放“滴”声，找到更优解时播放上扬音调。

### 复古游戏化设计
- **Canvas 绘制**：环节点用8x8像素方块，子树用线条连接。
- **自动演示模式**：按步长自动推进算法，展示环展开和队列更新过程。
- **积分系统**：正确找到环得10分，优化路径成功得20分。

---

**核心代码片段（树形DP + 单调队列）**
```cpp
// 树形DP求子树最长链
void dfs(int u, int fa) {
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (v == fa || on_cycle[v]) continue;
        dfs(v, u);
        max_len = max(max_len, f[u] + f[v] + e[i].w);
        f[u] = max(f[u], f[v] + e[i].w);
    }
}

// 单调队列优化环上路径
deque<int> q;
for (int i = 1; i <= 2 * m; ++i) {
    while (!q.empty() && i - q.front() > m) q.pop_front();
    if (!q.empty()) ans = max(ans, f[i] + f[q.front()] + sum[i] - sum[q.front()]);
    while (!q.empty() && f[i] - sum[i] >= f[q.back()] - sum[q.back()]) q.pop_back();
    q.push_back(i);
}
```

---

通过以上分析，可系统掌握基环树直径计算的核心思路与实现技巧。

---
处理用时：83.66秒
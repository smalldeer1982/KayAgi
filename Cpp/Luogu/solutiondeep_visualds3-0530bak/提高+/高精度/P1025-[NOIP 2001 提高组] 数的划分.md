# 题目信息

# [NOIP 2001 提高组] 数的划分

## 题目描述

将整数 $n$ 分成 $k$ 份，且每份不能为空，任意两个方案不相同（不考虑顺序）。

例如：$n=7$，$k=3$，下面三种分法被认为是相同的。

$1,1,5$;   
$1,5,1$;   
$5,1,1$.

问有多少种不同的分法。


## 说明/提示

四种分法为：  
$1,1,5$;  
$1,2,4$;  
$1,3,3$;  
$2,2,3$.

**【题目来源】**

NOIP 2001 提高组第二题

## 样例 #1

### 输入

```
7 3
```

### 输出

```
4
```

# AI分析结果



### 算法分类
动态规划（DP）与深度优先搜索剪枝（DFS with pruning）

### 核心思路与算法分析
1. **动态规划解法**：
   - **核心定义**：`f[i][x]`表示将整数i划分为x个非空部分的方案数。
   - **状态转移**：
     - 包含1的方案：`f[i][x] += f[i-1][x-1]`
     - 不包含1的方案：`f[i][x] += f[i-x][x]`（每个数至少为2，转化为i-x分x份）
   - **边界条件**：`f[i][1]=1`（单份方案唯一），`i<x`时`f[i][x]=0`
   - **空间优化**：使用滚动数组将空间复杂度降至O(k^2)

2. **DFS剪枝解法**：
   - **序列不降保证**：通过强制每个数不小于前一个数避免重复方案
   - **剪枝策略**：
     - 下界：当前数≥前一个数
     - 上界：剩余数的平均值`(n-sum)/(k-x+1)`
   - **递归终止**：当填满k份且总和为n时计数

### 题解评分（≥4星）
1. **s_r_f的DP解法（★★★★☆）**  
   核心亮点：清晰的状态转移推导与简洁的二维DP实现  
   代码特点：  
   ```cpp
   for (int i=2;i<=n;i++)
     for (int x=2;x<=k;x++)
       if (i>x) f[i][x]=f[i-1][x-1]+f[i-x][x];
   ```

2. **Clouder的空间优化DP（★★★★★）**  
   核心亮点：指针映射+滚动数组实现O(k^2)空间  
   优化技巧：  
   ```cpp
   int *f[maxn]; // 指针数组映射内存块
   for (i=1; i<=n; ++i)
     for (j=min(k,i); j; --j)
       f[i][j] = (f[i-j][j] + f[i-1][j-1]) % MOD;
   ```

3. **__CJY__的极简DFS（★★★★☆）**  
   核心亮点：仅9行代码实现完整剪枝逻辑  
   代码亮点：  
   ```cpp
   void dfs(int l,int p,int s){
     if(p==k+1){ ans+=(s==n); return; }
     for(int i=l; s+i<=n; i++) dfs(i,p+1,s+i);
   }
   ```

### 算法可视化设计
1. **动态规划状态表**  
   - **动画效果**：  
     - 创建n×k的像素网格，初始填充灰色  
     - 高亮当前填充的单元格（i,x）为绿色  
     - 用黄色箭头指向`f[i-1][x-1]`和`f[i-x][x]`的依赖项  
     - 每次更新时播放"哔"声效
   - **交互控制**：支持暂停/单步/调节速度

2. **DFS递归树**  
   - **像素风格**：  
     - 每个节点显示当前选择的数和剩余份数  
     - 有效路径用蓝色方块，剪枝路径用红色闪烁  
   - **音效反馈**：  
     - 有效递归："叮"声  
     - 触发剪枝："咔"声
   - **自动演示**：AI自动选择当前最小有效数，模拟最优搜索路径

### 同类型题目推荐
1. [P1024 数的划分（原题简单版）](https://www.luogu.com.cn/problem/P1024)
2. [P2409 Y的积木（分组背包变种）](https://www.luogu.com.cn/problem/P2409)
3. [P1249 最大乘积（划分乘积最值）](https://www.luogu.com.cn/problem/P1249)

### 核心代码实现（Clouder优化DP）
```cpp
#include <cstdio>
int dp[610][610], *f[200100], n, k;

int main() {
    scanf("%d%d", &n, &k);
    int p = 0;
    for(int i=0; i<=n; ++i) { // 指针初始化
        if(p >= 600) p -= 600;
        f[i] = dp[p+1]; ++p;
    }
    f[0][0] = 1;
    for(int i=1; i<=n; ++i) {
        memset(f[i], 0, sizeof(f[i]));
        for(int j=min(k,i); j; --j)
            f[i][j] = (f[i-j][j] + f[i-1][j-1]) % 10086;
    }
    printf("%d", f[n][k]);
}
```

该实现通过指针映射将空间复杂度优化至O(k²)，且通过逆序更新避免覆盖问题，适合处理大范围数据。

---
处理用时：82.11秒
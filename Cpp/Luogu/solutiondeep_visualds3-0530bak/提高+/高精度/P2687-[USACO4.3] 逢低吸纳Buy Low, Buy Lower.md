# 题目信息

# [USACO4.3] 逢低吸纳Buy Low, Buy Lower

## 题目描述

“逢低吸纳”是炒股的一条成功秘诀。如果你想成为一个成功的投资者，就要遵守这条秘诀：“逢低吸纳，越低越买”。

这句话的意思是：每次你购买股票时的股价一定要比你上次购买时的股价低。按照这个规则购买股票的次数越多越好，看看你最多能按这个规则买几次。

给定连续的 $N$ 天中每天的股价。你可以在任何一天购买一次股票，但是购买时的股价一定要比你上次购买时的股价低。写一个程序，求出最多能买几次股票。

以下面这个表为例，某几天的股价是：

|天数    |股价    |
|:-------|:-------|
|$1$|$68$|
|$2$|$69$|
|$3$|$54$|
|$4$|$64$|
|$5$|$68$|
|$6$|$64$|
|$7$|$70$|
|$8$|$67$|
|$9$|$78$|
|$10$|$62$|
|$11$|$98$|
|$12$|$87$|


这个例子中，如果每次买股票时的股价都比上一次买时低，那么最多能买 $4$ 次股票。一种买法如下（可能有其他的买法）：


|天数    |股价    |
|:-------|:-------|
|$2$|$69$|
|$5$|$68$|
|$6$|$64$|
|$10$|$62$|

## 说明/提示

$1 \le N \le 5000$。

## 样例 #1

### 输入

```
12
68 69 54 64 68 64 70 67
78 62 98 87```

### 输出

```
4 2```

# AI分析结果



## 算法分类
动态规划 (最长下降子序列及方案数统计)

## 题解思路与核心分析
### 核心算法流程
1. **状态定义**：  
   - `dp[i]` 表示以第i天股价结尾的最长下降子序列长度  
   - `cnt[i]` 表示对应方案数

2. **状态转移**：  
   ```cpp
   for i = 1..n:
     dp[i] = 1  // 初始化为自身
     for j = 1..i-1:
       if a[i] < a[j]:
         dp[i] = max(dp[i], dp[j]+1)
     // 统计方案数
     for j = 1..i-1:
       if a[i] == a[j] && dp[i] == dp[j]:
         cnt[j] = 0  // 去重关键
       if a[i] < a[j] && dp[i] == dp[j]+1:
         cnt[i] += cnt[j]
     if cnt[i] == 0: cnt[i] = 1  // 新序列初始化
   ```

3. **去重机制**：  
   当发现相同值且相同长度时，将前序位置的方案数清零，确保重复序列仅统计最后一次出现的位置

### 难点对比
| 题解 | 方案数处理 | 数值精度处理 | 去重方式 |
|-----|------------|--------------|----------|
| Zhou_yu | long double累加 | 依赖浮点数精度 | 转移时清零相同元素 |
| Register_int | 压位高精度 | 精确计算 | 哈希表记录最后出现位置 |
| chenhanzheapple | long double累加 | 同Zhou_yu | 转移后清零 |

## 五星题解推荐
### 1. Zhou_yu (4★)
**亮点**：  
- 利用long double巧妙规避高精度  
- 双重循环清晰分离长度计算与方案统计  
- 代码简洁易懂，适合快速实现

**核心代码**：
```cpp
for(int j=1;j<i;j++) {
  if(f[i]==f[j] && a[i]==a[j]) anses[j]=0;
  else if(f[i]==f[j]+1 && a[i]<a[j]) anses[i]+=anses[j];
}
```

### 2. Register_int (4★)
**亮点**：  
- 压位高精度保证绝对正确性  
- 使用结构体封装高精度运算  
- 讨论时间复杂度与优化方向

**高精实现**：
```cpp
struct Int {
  ll a[MAXM]; // 压18位存储
  Int operator+(const Int &rhs) {
    ll t=0;
    for(int i=MAXM-1;~i;i--){
      t += a[i] + rhs.a[i];
      a[i] = t%BASE; t /= BASE;
    }
    return *this;
  }
};
```

### 3. mayike (4★)
**亮点**：  
- 完整高精度实现教学  
- 详细注释辅助理解  
- 分步解释去重逻辑

**关键逻辑**：
```cpp
else if(a[i]==a[j]&&b[i]==b[j])c[j]=0; // 去重核心
```

## 最优技巧提炼
1. **去重时机**：在方案数转移过程中即时清零，而非最后统计时处理  
2. **精度选择**：根据数据规模选择long double（≤1e4932）或压位高精度  
3. **状态分离**：将长度计算与方案统计分离为两个独立循环  
4. **初始化策略**：`cnt[i] = max(cnt[i], 1)` 处理单元素序列

## 同类题目推荐
1. [P1108] 低价购买（本题双倍经验）
2. [P1020] 导弹拦截（最长下降子序列变形）
3. [P1439] 最长公共子序列（序列问题扩展）

## 可视化设计
### 动画方案
![DP状态更新动图](https://i.imgur.com/3JQZqj3.gif)  
**元素说明**：  
- **红色高亮**：当前正在处理的i元素  
- **绿色箭头**：从j到i的转移路径  
- **黄色闪烁**：发生去重清零的位置  
- **底部状态栏**：实时显示dp数组和cnt数组

### 复古像素风格
```javascript
// 像素绘制示例
function drawGrid() {
  ctx.fillStyle = '#2C3E50'; // 深蓝背景
  ctx.fillRect(0, 0, 800, 600);
  
  // 绘制数组元素
  for(let i=0; i<n; i++) {
    ctx.fillStyle = (i == currentIndex) ? '#E74C3C' : '#3498DB';
    drawPixelBlock(30 + i*40, 100, dp[i]); 
    drawPixelBlock(30 + i*40, 200, cnt[i]);
  }
}
```

### 音效设计
- **转移成功**：8-bit上升音效（[JSFXR生成](https://sfxr.me/)）  
- **去重操作**：短促"哔"声  
- **找到最长序列**：经典马里奥过关音效

## 核心代码实现
```cpp
// Zhou_yu题解核心逻辑
for(int i=1; i<=n; i++){
    f[i] = 1;
    // 计算最长长度
    for(int j=1; j<i; j++)
        if(a[i]<a[j]) f[i] = max(f[i], f[j]+1);
    
    // 统计方案数
    for(int j=1; j<i; j++){
        if(a[i]==a[j] && f[i]==f[j]) anses[j]=0;
        else if(f[i]==f[j]+1 && a[i]<a[j]) anses[i] += anses[j];
    }
    if(!anses[i]) anses[i] = 1;
}
```

## 调试经验摘录
> "前一秒坚持要写高精度，后一秒发现long double能过所有测试点... 实践出真知，有时候要敢于尝试非正统解法" —— Zhou_yu  
> "高精度的压位数量需要仔细计算，压18位时BASE=1e18，要防止加法溢出" —— Register_int  
> 在a[i]==a[j]时，清零操作必须在方案数累加前执行，否则会导致漏清 —— mayike

## 算法扩展思考
当N增大到1e5时，可通过离散化+树状数组优化到O(N logN)，方案数统计可结合哈希表记录同类元素最后出现位置的方案数，实现高效去重。

---
处理用时：84.73秒
# 题目信息

# 【模板】KMP

## 题目描述

给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。  
现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。

定义一个字符串 $s$ 的 border 为 $s$ 的一个**非 $s$ 本身**的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。  
对于 $s_2$，你还需要求出对于其每个前缀 $s'$ 的最长 border $t'$ 的长度。

## 说明/提示

### 样例 1 解释

 ![](https://cdn.luogu.com.cn/upload/pic/2257.png)。
 
对于 $s_2$ 长度为 $3$ 的前缀 `ABA`，字符串 `A` 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为 $1$。


### 数据规模与约定

**本题采用多测试点捆绑测试，共有 3 个子任务**。

- Subtask 1（30 points）：$|s_1| \leq 15$，$|s_2| \leq 5$。
- Subtask 2（40 points）：$|s_1| \leq 10^4$，$|s_2| \leq 10^2$。
- Subtask 3（30 points）：无特殊约定。

对于全部的测试点，保证 $1 \leq |s_1|,|s_2| \leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。

## 样例 #1

### 输入

```
ABABABC
ABA
```

### 输出

```
1
3
0 0 1 
```

# AI分析结果



## 【唯一算法分类】
字符串匹配算法（KMP）

---

## 【综合分析与结论】

### 核心思路与难点
KMP 算法的核心在于**避免暴力回溯**，通过预处理构造 next 数组实现智能跳转。核心流程分为两部分：
1. **next 数组构建**：计算模式串每个位置的最长公共前后缀长度（border）
2. **匹配阶段**：主串指针不回溯，模式串指针按 next 数组跳转

**解决难点**：
- 理解前缀函数的递归推导（`next[j]` 的跳转逻辑）
- 避免暴力算法中主串指针回退，保证 O(n+m) 时间复杂度
- 处理匹配成功后的二次跳转（如 "ABABA" 中可能连续匹配）

### 可视化设计要点
1. **算法过程动画**：
   - **Canvas 分屏显示**：左半屏展示 next 数组构建过程，右半屏展示匹配流程
   - **颜色标记**：当前比较字符（红色）、匹配成功区域（绿色）、next 跳转路径（黄色箭头）
   - **步进控制**：支持单步执行观察指针移动和跳转逻辑

2. **复古游戏化效果**：
   - **8-bit 音效**：
     - `j++` 时播放上升音阶（C4→E4）
     - 失配跳转时播放下降音阶（E4→C3）
     - 匹配成功时播放胜利音效（马里奥过关音效片段）
   - **像素动画**：
     - 字符以 16x16 像素块显示，失配时抖动特效
     - next 数组构建过程用发光边框标记公共前后缀
   - **自动演示模式**：
     - 可设置匹配速度（慢速/正常/极速）
     - 显示实时复杂度统计（比较次数/跳转次数）

---

## 【题解清单（≥4星）】

### 1. 皎月半洒花（★★★★★）
**核心亮点**：
- 图文结合解释 border 跳转逻辑
- 通过 "ABA→A" 案例详解 next 推导
- 完整代码注释 + 复杂度分析

### 2. frostime（★★★★☆）
**核心亮点**：
- 对比暴力算法与 KMP 的差异
- 用 "ABACABACABD" 案例分步推演
- 提供 next 数组手工计算技巧

### 3. 一扶苏一（★★★★）
**核心亮点**：
- 严格数学语言定义前缀函数
- 精简代码实现（37行核心逻辑）
- 捆绑测试点分析

---

## 【最优思路/技巧提炼】

### 核心代码实现
```cpp
// next 数组构建（frostime 实现）
void ConstructNext(const string &pat, int next[]) {
    next[0] = -1;
    int ptr = 0, lastNext = -1;
    while (ptr < pat.length() - 1) {
        if (lastNext == -1 || pat[ptr] == pat[lastNext]) {
            next[++ptr] = ++lastNext;
        } else {
            lastNext = next[lastNext];
        }
    }
}

// 匹配阶段（皎月半洒花实现）
j = 0;
for (int i = 1; i <= la; i++) {
    while (j && b[j+1] != a[i]) j = kmp[j];
    if (b[j+1] == a[i]) j++;
    if (j == lb) {
        cout << i - lb + 1 << endl;
        j = kmp[j];
    }
}
```

### 关键优化点
1. **双重 while 跳转**：匹配失败时连续跳转 next 直到可继续匹配
2. **虚拟哨兵技巧**：`next[0] = -1` 统一边界处理
3. **匹配成功后跳转**：`j = kmp[j]` 处理重叠匹配

---

## 【同类型题/算法拓展】

### 相似算法
- **Boyer-Moore**：坏字符规则 + 好后缀规则
- **扩展 KMP**：计算所有后缀与模式串的公共前缀
- **AC 自动机**：Trie 树上的 KMP 思想

### 推荐题目
1. **P1368 工艺**（最小循环节）
2. **P4391 [BOI2009]Radio Transmission**（无线传输）
3. **P5829 失配树**（next 数组树化）

---

## 【可视化方案示例（JS伪代码）】

```javascript
class KMPVisualizer {
  constructor(canvas) {
    this.ctx = canvas.getContext('2d');
    this.pattern = "ABABCABAB";
    this.text = "ABABABCABABABABCABAB";
    this.next = [];
    this.i = this.j = 0;
  }

  draw() {
    // 绘制文本串和模式串
    this.drawString(this.text, 50, 50, this.i, 'TEXT');
    this.drawString(this.pattern, 50, 100, this.j, 'PATTERN');
    
    // 高亮 next 跳转路径
    if (this.state === 'FAIL') {
      this.drawArrow(50 + this.j * 16, 100, 50 + this.next[this.j] * 16);
    }
  }

  step() {
    if (this.text[this.i] === this.pattern[this.j]) {
      this.playSound('match'); // 匹配音效
      this.i++; this.j++;
    } else {
      this.playSound('mismatch'); // 失配音效
      this.j = this.next[j];
      this.state = 'FAIL';
    }
  }
}
```

---

## 【调试心得摘录】

> _"调试时发现字符串索引从 1 开始会引发 RE，改用 0-based 后解决。next 数组最后一位必须手动归零，否则会误判重叠匹配。"_  
> —— frostime

> _"理解 j=kmp[j] 的跳转需要想象模式串被『折叠』，ABAB 跳转后等效于从第二个 A 开始比较"_  
> —— 一扶苏一

> _"next 数组的构建本质是模式串自我匹配，这个顿悟后代码立刻简洁了 50%"_  
> —— chu_yh

---
处理用时：72.99秒
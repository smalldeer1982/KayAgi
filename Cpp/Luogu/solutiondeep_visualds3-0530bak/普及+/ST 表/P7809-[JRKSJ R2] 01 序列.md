# 题目信息

# [JRKSJ R2] 01 序列

## 题目描述

给你一个长度为 $n$ 的 $01$ 序列 $a_{1\sim n}$，接下来有两种询问共 $m$ 次：

- `1 l r`，表示询问 $l$ 到 $r$ 区间的最长不下降子序列的长度。
- `2 l r`，表示询问 $l$ 到 $r$ 区间的最长上升子序列的长度。

## 说明/提示

本题采用捆绑测试。

| $\text{Subtask}$ | $n\le$ | $m\le$ | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $\text{1}$ | $10^6$ | $10^6$ | 所有 $a_i$ 均相等 | $5$ |
| $\text{2}$ | $10^3$ | $10^3$ | 无 | $10$ |
| $\text{3}$ | $10^4$ | $10^4$ | 无 | $15$ |
| $\text{4}$ | $10^5$ | $10^5$ | 无 | $30$ |
| $\text{5}$ | $10^6$ | $5\times10^6$ | 无 | $40$ |
| $\text{6}$ | $10^6$ | $5\times10^6$ | hack 数据 | $0$ |

对于 $100\%$ 的数据，$1\le n\le 10^6$，$1\le m\le 5\times10^6$，$0\le a_i\le 1$。

本题输入输出量极大，请使用较为快速的输入输出方法。

#### 样例解释:
对于第一个询问，满足的序列有：$\{0,1,1,1,1\},\{0,0,0,0,1\}$。\
对于第二个询问，满足的序列有：$\{0,1\}$。\
对于第三个询问，满足的序列有：$\{0,0\},\{0,1\},\{1,1\}$。\
对于第四个询问，满足的序列有：$\{0\},\{1\}$。

$\text{Upd 2021.8.16}$：增加两组 Hack 数据。

## 样例 #1

### 输入

```
8 4
0 1 1 0 1 0 0 1
1 1 8
2 1 8
1 3 6
2 5 6```

### 输出

```
5
2
2
1```

# AI分析结果



**唯一算法分类**: 前缀和与ST表（区间最值查询）

---

### **题解思路、算法要点与解决难点**

#### **操作2（最长上升子序列）**：
- **核心思路**：最长上升子序列长度只能是1或2。当且仅当区间中存在`0`后紧跟`1`时，答案为2。
- **实现要点**：
  - 预处理数组`pre[i]`表示前`i`位中`01`子串的出现次数。
  - 查询时若`pre[r] > pre[l]`则存在`01`，否则不存在。

#### **操作1（最长不下降子序列）**：
- **核心思路**：最优子序列形如`00...011...1`，需找到分割点`i`使`[l,i]`的0数量 + `[i+1,r]`的1数量最大。
- **实现要点**：
  - 前缀和数组`sum0`统计0的个数，后缀和数组`sum1`统计1的个数。
  - 构造表达式`sum0[i] - sum0[l-1] + sum1[r] - sum1[i]`，等价于`sum0[i] + sum1[i]`的区间最大值减去固定值。
  - 使用ST表预处理区间最大值，实现O(1)查询。

#### **难点解决**：
- **快速区间最值查询**：通过ST表将预处理复杂度降至O(n log n)，查询复杂度O(1)。
- **分割点推导**：通过数学变换将原问题转换为可前缀和优化的形式，避免暴力枚举分割点。

---

### **题解评分 (≥4星)**

1. **cyffff（5星）**：
   - **亮点**：代码简洁，ST表预处理高效，操作2使用前缀和差分判断，常数优化显著。
   - **核心代码**：
     ```cpp
     st[0][i] = z - o; // 预处理0的前缀和与1的后缀和之差
     write(1 + !(pre[l] == pre[r])); // 判断01存在性
     ```

2. **Mars_Dingdang（4.5星）**：
   - **亮点**：详细推导分割点公式，清晰注释前缀和逻辑，代码可读性高。
   - **关键步骤**：
     ```cpp
     ans = max(sum0[r] - sum0[l-1], sum1[r] - sum1[l-1]);
     ans = max(ans, Max(l, r) - sum0[l-1] - sum1[r+1]);
     ```

3. **Superiority（4星）**：
   - **亮点**：使用`lstOne`和`firZero`数组快速判断操作2，逻辑直观。
   - **代码片段**：
     ```cpp
     return (sum0[l] <= sum1[r] ? 2 : 1); // 直接比较0和1的位置
     ```

---

### **最优思路提炼**
1. **操作1的ST表优化**：
   - **核心变量**：`sum0[i] + sum1[i]`表示分割点`i`的贡献值。
   - **预处理**：ST表存储区间最大值，查询时减去固定偏移量`sum0[l-1] + sum1[r+1]`。

2. **操作2的前缀和差分**：
   - **关键数组**：`pre[i]`记录`01`出现次数，区间存在`01`等价于`pre[r] > pre[l]`。

---

### **同类型题推荐**
1. **P3865 ST表模板**：直接应用区间最值查询。
2. **P1198 最大数**：动态维护区间最值，结合线段树/ST表。
3. **P1440 求m区间内的最小值**：滑动窗口与单调队列优化。

---

### **可视化与算法演示**

#### **动画设计**：
1. **像素风格界面**：
   - **序列展示**：用绿色（0）和红色（1）像素块表示序列。
   - **分割点扫描**：高亮当前分割点`i`，显示`sum0[i]`和`sum1[i]`的数值变化。

2. **ST表查询过程**：
   - **高亮区间**：用蓝色边框标记当前ST表查询的区间块（如`[l, mid]`和`[mid+1, r]`）。
   - **动态合并**：逐步显示最大值合并过程，辅以8-bit音效。

3. **操作2的01检测**：
   - **闪烁标记**：若存在`01`，对应位置的`0`和`1`像素块闪烁黄色。

#### **复古游戏化元素**：
- **音效设计**：
  - **正确查询**：播放经典《超级马里奥》金币音效。
  - **错误/无解**：短促的《塞尔达传说》受伤音效。
- **积分系统**：每正确回答一个查询得10分，连续正确触发连击奖励。

#### **交互控制**：
- **步进按钮**：允许单步执行ST表查询，观察分割点选择。
- **速度调节**：滑动条控制动画速度（0.5x~3x）。

---

### **核心代码片段（cyffff）**
```cpp
// 预处理ST表
for (int i=1; i<=19; i++)
    for (int j=1; j+(1<<i)-1 <=n; j++)
        st[i][j] = max(st[i-1][j], st[i-1][j+(1<<(i-1))]);

// 查询操作1
int ans = max(pp[r] - pp[l-1], query(l,r) - (l-1 - pp[l-1]) + pp[r]);

// 查询操作2
putc(1 + (pre[l] != pre[r])); // 直接判断前缀和差分
```

---

### **总结**
本题通过前缀和与ST表的结合，将看似复杂的区间查询问题转化为高效预处理和快速查询。操作2的`01`检测和操作1的分割点优化体现了对问题特殊性质的深刻洞察，是典型的数据结构思维训练案例。

---
处理用时：82.52秒
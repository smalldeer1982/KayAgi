# 题目信息

# [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。


## 说明/提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
389 207 155 300 299 170 158 65```

### 输出

```
6
2
```

# AI分析结果



---

## 算法分类  
**二分**

---

## 综合分析与结论  
### 核心思路与难点  
1. **第一问（最长不上升子序列）**  
   - **维护单调栈**：用数组维护可能成为最长不上升子序列末尾的元素，保证其单调性  
   - **二分优化**：对每个新元素，二分找到第一个小于该元素的位置并替换，保证栈的单调性不变  
   - **难点**：正确选择二分条件（`>=` 或 `>`），证明替换不影响结果正确性  

2. **第二问（最少系统数）**  
   - **Dilworth 定理**：将问题转化为求最长上升子序列长度  
   - **贪心+二分**：维护一个单调递增数组，每次找到第一个大于等于当前值的位置并替换  
   - **难点**：理解定理的数学证明，正确实现上升子序列的二分查找  

### 可视化设计要点  
- **像素动画**：用 Canvas 绘制数组元素，以 8-bit 像素风格展示每次二分过程  
- **颜色标记**：  
  - 红色：当前搜索区间 `[left, right]`  
  - 绿色：mid 位置  
  - 黄色：已处理元素  
- **音效设计**：  
  - `mid` 更新：播放短促“滴”声  
  - 找到替换位置：播放上升音调  
  - 新系统创建：播放爆炸音效  
- **交互控制**：支持暂停/继续、单步执行、调整动画速度  

---

## 题解清单（评分≥4星）  
1. **离散小波变换°（5星）**  
   - **亮点**：完整证明单调性，清晰解释二分条件，代码与注释对应  
   - **核心代码**：  
     ```cpp
     int l=0, r=t+1;
     while(r-l>1){
         int m=l+(r-l)/2;
         if(F[m]>=H[i]) l=m; else r=m;
     }
     ```
  
2. **STA_Morlin（4星）**  
   - **亮点**：结合 Dilworth 定理的通俗解释，代码简洁  
   - **心得摘录**：“多年后看到这题感慨颇丰”——体现经典题目的长期价值  

3. **Otue（4星）**  
   - **亮点**：独立给出贪心证明，提供未优化与优化双版本代码  
   - **关键片段**：  
     ```cpp
     while(k<=cnt && g[k]<a[i]) k++;
     if(k>cnt) g[++cnt]=a[i];
     else g[k]=a[i];
     ```

---

## 最优思路/技巧提炼  
1. **二分条件统一模板**：  
   - 第一问用 `upper_bound` + `greater` 找**最后一个 ≥ 当前值**的位置  
   - 第二问用 `lower_bound` 找**第一个 ≥ 当前值**的位置  

2. **单调性维护技巧**：  
   ```cpp
   // 最长不上升子序列维护
   if(a[i] <= f[cnt]) f[++cnt] = a[i];
   else *upper_bound(f+1, f+cnt+1, a[i], greater<int>()) = a[i];
   ```

3. **Dilworth 定理应用**：  
   - 最少系统数 = 最长上升子序列长度  
   - 避免重新发明轮子，直接调用上升子序列代码  

---

## 类似题目推荐  
1. **P1091 [NOIP2004 提高组] 合唱队形**  
   - 求最长上升+下降子序列组合  

2. **P1439 【模板】最长公共子序列**  
   - 利用 LIS 优化 LCS 问题  

3. **P2216 [HAOI2007] 理想的正方形**  
   - 二维滑动窗口结合单调队列  

---

## 核心代码实现  
```cpp
// 第一问：最长不上升子序列
vector<int> f;
for (int x : a) {
    if (f.empty() || x <= f.back()) f.push_back(x);
    else *upper_bound(f.begin(), f.end(), x, greater<int>()) = x;
}
cout << f.size() << endl;

// 第二问：最长上升子序列
vector<int> g;
for (int x : a) {
    auto it = lower_bound(g.begin(), g.end(), x);
    if (it == g.end()) g.push_back(x);
    else *it = x;
}
cout << g.size() << endl;
```

---

## 复古游戏化动画伪代码  
```javascript
// Canvas 绘制示例（伪代码）
const canvas = document.getElementById("pixel-canvas");
const ctx = canvas.getContext("2d");

function drawArray(arr, left, right, mid) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let i = 0; i < arr.length; i++) {
        // 绘制像素方块
        ctx.fillStyle = i >= left && i <= right ? "#FF0000" : 
                        i === mid ? "#00FF00" : "#FFFF00";
        ctx.fillRect(i * 20, 0, 18, 18);
    }
}

// 音效触发
function playSound(effect) {
    const audio = new Audio(`sfx/${effect}.wav`);
    audio.play();
}

// 自动演示循环
let step = 0;
function autoPlay() {
    const { left, right, mid } = steps[step++];
    drawArray(currentArray, left, right, mid);
    playSound("mid");
    if (step < steps.length) setTimeout(autoPlay, speed);
}
```

---
处理用时：68.07秒
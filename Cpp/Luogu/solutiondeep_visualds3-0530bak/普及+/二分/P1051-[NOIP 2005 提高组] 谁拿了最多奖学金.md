# 题目信息

# [NOIP 2005 提高组] 谁拿了最多奖学金

## 题目描述

某校的惯例是在每学期的期末考试之后发放奖学金。发放的奖学金共有五种，获取的条件各自不同：

1. 院士奖学金，每人 $8000$ 元，期末平均成绩高于 $80$ 分（$>80$），并且在本学期内发表$1$篇或$1$篇以上论文的学生均可获得；
2. 五四奖学金，每人 $4000$ 元，期末平均成绩高于 $85$ 分（$>85$），并且班级评议成绩高于 $80$ 分（$>80$）的学生均可获得；
3. 成绩优秀奖，每人 $2000$ 元，期末平均成绩高于 $90$ 分（$>90$）的学生均可获得；
4. 西部奖学金，每人 $1000$ 元，期末平均成绩高于 $85$ 分（$>85$）的西部省份学生均可获得；
5. 班级贡献奖，每人 $850$ 元，班级评议成绩高于 $80$ 分（$>80$）的学生干部均可获得；

只要符合条件就可以得奖，每项奖学金的获奖人数没有限制，每名学生也可以同时获得多项奖学金。例如姚林的期末平均成绩是 $87$ 分，班级评议成绩 $82$ 分，同时他还是一位学生干部，那么他可以同时获得五四奖学金和班级贡献奖，奖金总数是 $4850$ 元。

现在给出若干学生的相关数据，请计算哪些同学获得的奖金总数最高（假设总有同学能满足获得奖学金的条件）。


## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，满足 $1 \le  N \le  100$。

**【题目来源】**

NOIP 2005 提高组第一题

## 样例 #1

### 输入

```
4
YaoLin 87 82 Y N 0
ChenRuiyi 88 78 N Y 1
LiXin 92 88 N N 0
ZhangQin 83 87 Y N 1
```

### 输出

```
ChenRuiyi
9000
28700
```

# AI分析结果



## 唯一算法分类  
**无算法分类**

---

## 综合分析与结论  
### 核心思路
题目属于**多条件模拟题**，核心在于按照 5 个独立奖学金规则计算每个学生的总奖金，并通过打擂台法快速获取最大值。所有题解均采用结构体存储学生数据，通过多个独立的条件判断累加奖金，最终通过遍历比较或排序找出最高奖金。

### 解决难点
1. **条件独立性**：各项奖金可叠加计算，必须用多个`if`而非`else if`  
2. **输入处理**：字符型字段（Y/N）与数值型字段混合输入，需注意空格过滤  
3. **同分优先级**：最高奖金相同时选择输入顺序靠前者，无需排序但需记录原始序号  

### 最优技巧提炼
1. **逻辑表达式乘法**：将条件表达式转换为布尔值（0/1），直接与奖金相乘简化代码  
   ```cpp
   sum = (a>80&&e)*8000 + (a>85&&b>80)*4000 + (a>90)*2000 + ...;
   ```
2. **打擂台法替代排序**：遍历时维护当前最大值和学生姓名，时间复杂度从 O(n logn) 降为 O(n)  
3. **输入顺序隐式记录**：通过遍历顺序自动处理同分情况，无需显式存储序号  

---

## 题解清单（≥4星）
### 1. qhr2023（4.5⭐）
**亮点**：  
- **极致简洁**：利用逻辑表达式乘法，仅用 5 行完成奖金计算  
- **空间高效**：无需结构体，输入时即时处理数据  
- **代码量最小**：仅 20 行完整实现  

### 2. hanyu0722（4⭐）
**亮点**：  
- **无排序优化**：直接维护最大值，时间复杂度最优  
- **变量命名清晰**：`maxx`记录最大值，`sum`累加总和  
- **输入处理规范**：分字段读取，避免格式错误  

### 3. Haohao123coding（4⭐）
**亮点**：  
- **结构体规范**：明确字段命名，增强可维护性  
- **注释详尽**：每个奖金条件对应注释，逻辑清晰  
- **边界处理**：严格使用`>`而非`>=`，完全匹配题意  

---

## 核心代码实现
### 最优实现（qhr2023 逻辑表达式版）
```cpp
int sum = (a>80 && e)*8000 + 
          (a>85 && b>80)*4000 + 
          (a>90)*2000 + 
          (a>85 && d=='Y')*1000 + 
          (b>80 && c=='Y')*850;
```

### 打擂台法核心逻辑
```cpp
int max_money = -1, total = 0;
string max_name;
for (每个学生) {
    if (当前学生.money > max_money) {
        max_money = 当前学生.money;
        max_name = 当前学生.name;
    }
    total += 当前学生.money;
}
```

---

## 可视化设计（奖金计算过程）
### 动画方案
1. **分步高亮**：  
   - 用不同颜色标记每个奖学金条件，逐项检查并显示是否满足  
   - 满足条件时，右侧累计奖金动态增加，伴随音效  

2. **学生对比面板**：  
   - 并列显示当前学生与最高记录保持者的各项数据  
   - 当新最高出现时，触发闪光特效与提示音  

3. **复古像素风格**：  
   - 使用 8-bit 字体，绿色表示条件满足，红色不满足  
   - 背景播放 chiptune 风格音乐，奖金增加时播放 "coin" 音效  

### 交互功能
- **步进控制**：按空格键逐学生分析，Enter 键自动播放  
- **数据面板**：显示当前处理的学生姓名、各条件状态、奖金累加过程  
- **历史轨迹**：侧边栏滚动显示已处理学生的奖金数，最高记录标红  

---

## 相似题目推荐
1. **P1093 [NOIP2007 普及组] 奖学金**  
   - 多条件排序（总分、语文、学号）  
2. **P1309 [NOIP2011 普及组] 瑞士轮**  
   - 动态排序与归并优化  
3. **P5143 攀爬者**  
   - 结构体排序与距离计算  

---

## 个人心得摘录
- **lucienshawls**：  
  > "cin在数据规模小时没问题，但大数据时需用快读。本题虽小，但养成良好的输入习惯很重要。"  
  **启示**：输入优化习惯需长期培养，即使小数据也能提升代码鲁棒性。

- **陈嘉逸2012**：  
  > "因为一名学生可以重复获奖，所以判断的时候要用 if 而不是 else if。"  
  **教训**：条件独立性是本题核心陷阱，需特别注意。

- **mcturtle**：  
  > "警示后人：奖金可以叠加，要用多个 if，不能用 if else。"  
  **总结**：多次踩坑后的经验强调，避免思维定式。

---
处理用时：67.19秒
# 题目信息

# [NOIP 2012 提高组] 借教室

## 题目描述

在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。

面对海量租借教室的信息，我们自然希望编程解决这个问题。

我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_i$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_j,s_j,t_j$，表示某租借者需要从第 $s_j$ 天到第 $t_j$ 天租借教室（包括第 $s_j$ 天和第 $t_j$ 天），每天需要租借 $d_j$ 个教室。

我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供 $d_j$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。

借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_j$ 天到第 $t_j$ 天中有至少一天剩余的教室数量不足 $d_j$ 个。

现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。


## 说明/提示

【输入输出样例说明】

第 $1 $份订单满足后，$4 $天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2 $天到第 $4$ 天每天提供 $3$ 个教室，而第 $3$ 天剩余的教室数为$ 2$，因此无法满足。分配停止，通知第 $2$ 个申请人修改订单。

【数据范围】

对于 $10\%$ 的数据，有 $1\le n,m\le 10$；

对于 $30\%$ 的数据，有 $1\le n,m\le 1000$；

对于 $70\%$ 的数据，有 $1 \le n,m \le 10^5$；

对于 $100\%$ 的数据，有 $1 \le n,m \le 10^6$，$0 \le r_i,d_j\le 10^9$，$1 \le s_j\le t_j\le n$。


NOIP 2012 提高组 第二天 第二题

2022.2.20 新增一组 hack 数据

## 样例 #1

### 输入

```
4 3 
2 5 4 3 
2 1 3 
3 2 4 
4 2 4```

### 输出

```
-1 
2```

# AI分析结果



# 算法分类：二分

## 综合分析与结论
本问题核心在于通过二分法确定最早无法满足的订单编号，结合差分数组高效处理区间修改。所有题解中，**二分+差分**是唯一通过全部数据的解法，时间复杂度为 O((n+m) log m)，适用于 1e6 级数据规模。线段树解法虽正确但常数过大，暴力优化仅适合部分数据。

### 核心难点与解决方案
1. **二分边界处理**  
   - 初始区间设为 [1, m]，通过 `mid = (left + right) >> 1` 计算中点
   - 检查前 mid 个订单是否合法，合法则 `left = mid + 1`，否则 `right = mid`
   - 退出条件为 `left > right`，最终 left 指向第一个非法订单

2. **差分数组优化**  
   - 对每个订单 [s, t] 的区间修改转化为差分数组的两端点操作：`diff[s] += d`，`diff[t+1] -= d`
   - 前缀和计算后即可得到每日实际需求量

### 可视化设计思路
1. **动画展示二分过程**  
   - 初始区间标记为绿色，每次 mid 计算后高亮显示黄色
   - 合法区间右移时左半变灰，非法区间左移时右半变灰
   - 最终结果以红色闪烁提示第一个非法订单

2. 复古像素风格（可选）  
   - 使用 8-bit 风格绘制搜索区间，每次收缩伴随经典音效
   - Canvas 网格动态更新 mid 位置，背景音乐循环播放

---

## 高分题解推荐 (≥4星)
1. **皎月半洒花（5星）**  
   - 思路清晰，详细讲解差分原理与二分单调性
   - 代码简洁，包含完整注释与边界处理
   - 核心亮点：前缀和与差分逆运算的对比分析

2. WsW_（4星）  
   - 代码结构紧凑，使用 STL 加速 IO
   - 亮点：函数式封装检查逻辑，提高可读性

3. 清远学会（4星）  
   - 提供线段树与二分两种解法对比
   - 亮点：调试技巧与常数优化经验分享

---

## 核心代码实现
### 二分+差分标准实现
```cpp
bool check(int x) { // 检查前x订单是否合法
    memset(diff, 0, sizeof(diff));
    for(int i=1; i<=x; ++i) {
        diff[l[i]] += d[i];
        diff[r[i]+1] -= d[i];
    }
    int sum = 0;
    for(int i=1; i<=n; ++i) {
        sum += diff[i];
        if(sum > a[i]) return false;
    }
    return true;
}

int main() {
    int left=1, right=m, ans=0;
    while(left <= right) {
        int mid = (left + right) >> 1;
        if(check(mid)) {
            left = mid + 1;
            ans = mid;
        } else {
            right = mid - 1;
        }
    }
    if(ans == m) cout << 0;
    else cout << -1 << endl << ans+1;
}
```

---

## 同类型题拓展
1. **P4343 自动刷题机**  
   二分答案求可行解极值

2. **P2678 跳石头**  
   二分最短跳跃距离的最大值

3. **P1182 数列分段**  
   二分最大段和的最小值

---

## 可视化示例（伪代码）
```javascript
// Canvas绘制二分区间
function drawRange(left, right, mid) {
    ctx.fillStyle = "#8B0000"; // 深红背景
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 绘制当前区间[left, right]
    ctx.fillStyle = "#32CD32"; // 亮绿
    ctx.fillRect(left*10, 50, (right-left)*10, 20);
    
    // 高亮mid
    ctx.fillStyle = "#FFD700"; // 金色
    ctx.fillRect(mid*10, 50, 10, 20);
}

// 音效触发
function playBeep(type) {
    if(type == "move") beep(440, 100); // 移动音
    if(type == "found") beep(880, 500); // 找到答案
}
```

---

通过二分框架与差分优化，本问题得以高效解决。实际编码时需注意差分数组的初始化与复用，避免每次全量重置。可视化交互可显著提升算法理解深度，推荐结合动画演示二分收缩过程。

---
处理用时：51.14秒
# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果



### 【算法分类】
二分

---

### 【题解思路与解决难点】
#### 核心思路对比
1. **哈希映射（O(n)）**  
   通过`map/unordered_map`存储数值出现次数，将A-B=C转换为B=A-C，遍历时累加对应次数。优势在于代码简洁，但哈希表存在常数开销。

2. **二分查找（O(n log n)）**  
   排序后对每个元素A[i]，用`lower_bound`和`upper_bound`查找A[i]-C的区间，通过两指针差值计算出现次数。核心难点在于正确使用STL函数处理重复元素。

3. **双指针（O(n)）**  
   维护两个右指针分别表示等于C和超过C的边界，利用有序性单调移动指针，适用于无需统计具体值的场景。

#### 二分算法关键要点
- **区间初始化**：排序后数组的起点和终点（通常为整个数组范围）
- **mid计算**：`mid = left + (right-left)/2`避免溢出
- **条件判断**：根据`a[mid]`与目标值比较调整区间
- **边界处理**：`lower_bound`返回≥目标的首位置，`upper_bound`返回>目标的首位置，差值即为出现次数

---

### 【题解评分（≥4星）】
1. **樱花飞舞（5星）**  
   - 亮点：清晰展示STL二分函数应用，代码简洁高效  
   - 代码片段：
     ```cpp
     ans += upper_bound(a+1,a+N+1,a[i]+C) - lower_bound(a+1,a+N+1,a[i]+C);
     ```

2. **OsvaldoAsensioLopez（4.5星）**  
   - 亮点：巧用map实现O(n)统计，代码极简  
   - 代码片段：
     ```cpp
     m[a[i]]++;  
     ans += m[a[i]-c];
     ```

3. **jins3599（4星）**  
   - 亮点：双指针维护区间，避免重复计算  
   - 关键逻辑：
     ```cpp
     while(r1 <= n && a[r1] - a[l] <= c) r1++;
     ans += r1 - r2; // 区间内均为合法解
     ```

---

### 【最优思路提炼】
- **哈希映射**：适用于无需排序场景，但需注意数据范围（大数值需用STL容器）
- **二分STL**：排序后直接调用`lower_bound/upper_bound`，差值法统计次数，避免手写二分错误
- **边界处理技巧**：若C=0需特殊处理（排除自身匹配），可通过判断条件过滤

---

### 【同类型题拓展】
1. **P1678 统计数字**：排序后二分查找数值区间
2. **P2440 木材加工**：二分答案判断可行性
3. **P2678 跳石头**：经典二分答案应用

---

### 【可视化设计（二分过程）】
#### 动画方案
1. **搜索区间动态标记**  
   - 绿色高亮当前`left`和`right`，红色标记`mid`
2. **比较结果反馈**  
   - 若`a[mid] < target`：左区间变红，右指针左移
   - 若`a[mid] ≥ target`：右区间变蓝，左指针右移
3. **音效与像素风格**  
   - 收缩时播放8-bit“滴”声，找到目标时播放胜利音效
   - Canvas绘制排序数组，搜索区间以不同颜色方块展示

#### 关键代码片段（JS伪代码）
```javascript
function binarySearchVisual(target) {
  let left = 0, right = arr.length-1;
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    highlight(mid, 'red'); // 高亮mid
    if (arr[mid] < target) {
      playSound('move');
      left = mid + 1;
    } else {
      right = mid - 1;
    }
    updateCanvas(left, right); // 更新区间显示
  }
}
```

---

### 【个人心得摘录】
> "二分最易错的是死循环和边界处理，牢记**循环条件与指针移动必须匹配**，比如`left=mid+1`和`right=mid`的组合可避免无限循环。" —— 樱花飞舞题解调试笔记

> "当C=0时，每个数会与自己匹配一次，必须减去这些无效数对。" —— 某题解踩坑记录

---

### 【推荐练习题】
1. **P1102 A-B数对**（本题）
2. **P1024 一元三次方程求解**（二分求根）
3. **P1182 数列分段**（二分答案经典）

---
处理用时：64.94秒
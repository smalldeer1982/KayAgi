# 题目信息

# 删数问题

## 题目描述

键盘输入一个高精度的正整数 $n$（不超过 $250$ 位），去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的非负整数。编程对给定的 $n$ 和 $k$，寻找一种方案使得剩下的数字组成的新数最小。

## 说明/提示

用 $\operatorname{len}(n)$ 表示 $n$ 的**位数**，保证 $1 \leq k < \operatorname{len}(n) \leq 250$。

## 样例 #1

### 输入

```
175438 
4
```

### 输出

```
13```

# AI分析结果



### 算法分类：贪心算法

---

### 题解思路与核心难点分析

**核心思路**：  
所有题解均基于贪心策略，核心思路为：**从左到右选择尽可能小的数字作为每一位**。具体分为两种实现方式：
1. **逐位构造法**：每次在允许删除的范围内选择最小的数字作为当前位，更新剩余可删除次数和搜索范围。
2. **删峰法**：遍历字符串，删除第一个递减序列中的较大值（如 `175438` 中 `7>5` 时删除7），循环直至删完k个数字。

**解决难点**：
- **前导零处理**：需删除结果前的所有零，但需保留至少一个零（如 `10` 删1位后应输出 `0`）。
- **全递增序列处理**：当序列严格递增时，需从末尾删除剩余需删的次数。
- **时间复杂度优化**：部分题解通过链表或双指针优化删除操作，避免频繁字符串拷贝。

---

### 评分≥4星的题解

1. **expin（赞260）⭐⭐⭐⭐⭐**  
   **亮点**：  
   - 分阶段选择最小数字，直接构造结果，避免重复遍历。  
   - 动态调整剩余可删次数，逻辑清晰。  
   **代码片段**：  
   ```cpp
   while (cnt < rest) { // 需要选rest个数字
       minp = t;
       for (int i = t; i <= k + t; ++i) // 在允许范围内找最小值
           if (a[minp] > a[i]) minp = i;
       if (a[minp]) flag = 1; // 处理前导零
       if (flag) cout << a[minp];
       k -= (minp - t); // 更新剩余可删次数
       t = minp + 1;    // 移动搜索起点
       cnt++;
   }
   ```

2. **修罗海神王（赞196）⭐⭐⭐⭐**  
   **亮点**：  
   - 通过删除“下坡数”（如 `7>5`）简化操作，代码直观。  
   - 手动处理前导零，兼容全零情况。  
   **代码片段**：  
   ```cpp
   for (int i = 1; i <= n; ++i) // 删n次
       for (int j = 0; j < l; ++j)
           if (a[j] > a[j + 1]) { // 找到下坡数
               for (int k = j; k < l; ++k) a[k] = a[k + 1];
               l--; break;
           }
   ```

3. **xh39（赞142）⭐⭐⭐⭐**  
   **亮点**：  
   - 使用 `string::erase` 简化删除操作，代码简洁。  
   - 直接处理高峰数，适合快速实现。  
   **代码片段**：  
   ```cpp
   while (s) { // 循环删s次
       for (i = 0; n[i] <= n[i + 1];) i++; // 找高峰
       n.erase(i, 1); // 删除高峰数
       s--;
   }
   ```

---

### 最优思路与技巧提炼

1. **贪心策略选择**：优先在高位选择更小的数字，确保全局最优。
2. **前导零处理**：在输出阶段统一处理，而非在删除过程中处理。
3. **链表优化**：使用双向链表（如Sol1的题解）实现O(n)时间复杂度。
4. **边界处理**：对全递增序列需删除末尾字符，避免遗漏。

---

### 同类型题目推荐

1. **LeetCode 402. 移掉K位数字**（同题）
2. **洛谷 P1328 [NOIP2014 提高组] 生活大爆炸版石头剪刀布**（贪心策略）
3. **LeetCode 316. 去除重复字母**（类似构造最小序列）

---

### 可视化算法设计（像素风格）

**动画设计**：  
1. **初始化**：将输入数字显示为像素方块（16色），如 `1 7 5 4 3 8`。  
2. **删峰过程**：  
   - 红色高亮当前峰（如`7`），播放“哔”音效。  
   - 删除后，后方数字左移，显示绿色箭头动画。  
3. **前导零处理**：删除前导零时，零方块渐隐，伴随“咔嚓”音效。  
4. **自动模式**：按空格键切换自动/手动，自动模式下每0.5秒执行一步。  

**交互示例**：  
- **步进控制**：方向键左右单步执行，`R`键重置。  
- **音效**：8-bit风格音效，使用Web Audio API触发。  

---

### 关键代码实现（删峰法）

```cpp
string deleteKDigits(string num, int k) {
    while (k--) {
        int i = 0;
        while (i < num.size() - 1 && num[i] <= num[i + 1]) i++;
        num.erase(i, 1); // 删除第一个峰
    }
    // 处理前导零
    size_t non_zero = num.find_first_not_of('0');
    return (non_zero == string::npos) ? "0" : num.substr(non_zero);
}
```

---
处理用时：68.01秒
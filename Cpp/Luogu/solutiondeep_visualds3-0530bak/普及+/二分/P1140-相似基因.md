# 题目信息

# 相似基因

## 题目背景

大家都知道，基因可以看作一个碱基对序列。它包含了 $4$ 种核苷酸，简记作 `A, C, G, T`。生物学家正致力于寻找人类基因的功能，以利用于诊断疾病和发明药物。

在一个人类基因工作组的任务中，生物学家研究的是：两个基因的相似程度。因为这个研究对疾病的治疗有着非同寻常的作用。

## 题目描述

两个基因的相似度的计算方法如下：

对于两个已知基因，例如 `AGTGATG` 和 `GTTAG`，将它们的碱基互相对应。当然，中间可以加入一些空碱基 `-`，例如：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\tt A & \tt G & \tt T & \tt G & \tt A & \tt T & \texttt - & \tt G \\ \hline
\texttt - & \tt G & \tt T & \texttt - & \texttt - & \tt T & \texttt A & \tt G \\ \hline
\end{array}
$$

这样，两个基因之间的相似度就可以用碱基之间相似度的总和来描述，碱基之间的相似度如下表所示：

$$
\def\arraystretch{1.5}
\begin{array}{ |c|c|c|c|c|c|} \hline
& \tt A & \tt C & \tt G & \tt T & \texttt - \\ \hline
\tt A & 5 & -1 & -2 & -1 & -3\\ \hline
\tt C & -1 & 5 & -3 & -2 & -4 \\\hline
\tt G & -2 & -3 & 5 & -2 & -2 \\\hline
\tt T & -1 & -2 & -2 & 5 & -1 \\\hline
\texttt - & -3 & -4 & -2 & -1 & * \\\hline
\end{array}
$$ 

那么相似度就是：$(-3)+5+5+(-2)+(-3)+5+(-3)+5=9$。因为两个基因的对应方法不唯一，例如又有：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|} \hline
\tt A & \tt G & \tt T & \tt G & \tt A & \tt T & \tt G \\ \hline
\texttt - & \tt G & \tt T & \texttt T & \texttt A & \texttt - & \tt G \\ \hline
\end{array}
$$

相似度为：$(-3)+5+5+(-2)+5+(-1)+5=14$。规定两个基因的相似度为所有对应方法中，相似度最大的那个。


## 样例 #1

### 输入

```
7 AGTGATG
5 GTTAG
```

### 输出

```
14
```

# AI分析结果



## 唯一算法分类
**动态规划**

---

## 综合分析与结论
### 核心思路与算法要点
1. **状态定义**：  
   `dp[i][j]` 表示第一个基因前 `i` 个碱基与第二个基因前 `j` 个碱基对齐的最大相似度。
   
2. **状态转移方程**：  
   每个状态有三种转移方式：
   ```cpp
   dp[i][j] = max(
       dp[i-1][j-1] + score(a[i], b[j]),  // 直接匹配
       dp[i-1][j] + score(a[i], '-'),     // a[i]与空碱基匹配
       dp[i][j-1] + score('-', b[j])      // b[j]与空碱基匹配
   )
   ```

3. **边界处理**：  
   - `dp[0][0] = 0`  
   - 当 `i=0` 时，只能通过插入空碱基初始化：`dp[0][j] = dp[0][j-1] + score('-', b[j])`  
   - 当 `j=0` 时同理。

4. **难点与解决**：  
   - **负值处理**：需将 `dp` 数组初始化为极小值（如 `-1e8`），避免未计算的中间状态干扰结果。  
   - **字符映射**：将 `A/C/G/T` 转换为下标（如 `A→1`），便于查表计算相似度。

---

## 题解评分（≥4星）
1. **zhy137036（5星）**  
   - 结构清晰，分步骤讲解动态规划的核心要素（状态定义、转移方程、边界处理）。  
   - 代码规范，注释明确，预处理字符转换和边界初始化完整。  
   - 通过图示辅助理解状态转移，适合新手学习。

2. **Segment_Tree（4星）**  
   - 代码简洁，使用 `string` 简化输入处理。  
   - 预处理 `dp` 数组为极小值，避免负值陷阱。  
   - 缺少详细文字解释，适合有经验的读者。

3. **Ykimna（4星）**  
   - 通过实例图解说明状态转移，直观易懂。  
   - 强调初始化 `dp` 为极小值的必要性，避免 WA。  
   - 代码风格稍显紧凑，注释较少。

---

## 最优思路提炼
1. **状态转移的三种情况**：  
   每次仅需考虑当前碱基的三种匹配方式（直接匹配、插入空碱基到任一序列），无需回溯全局。

2. **边界初始化技巧**：  
   当一方序列长度为 0 时，另一方必须全与空碱基匹配，需单独循环初始化。

3. **负值陷阱规避**：  
   初始时将 `dp` 数组设为极小值（如 `-1e8`），防止未计算的状态被误用。

---

## 同类型题推荐
1. **最长公共子序列（LCS）**  
   - 题号：P1439  
   - 二维动态规划，状态转移与本题类似。

2. **编辑距离**  
   - 题号：P2758  
   - 状态转移同样涉及字符替换、插入、删除操作。

3. **字串距离**  
   - 题号：P1279  
   - 计算字符串对齐的最小代价，与本题相似度计算逻辑一致。

---

## 个人心得摘录
- **Ykimna**：  
  > “初始化 `dp` 数组为极小值，否则可能因负值答案导致 WA。调试时发现未初始化的位置被误认为合法状态。”

- **gary2005**：  
  > “`cin` 输入字符串时，下标从 0 开始，需注意字符转换的边界，否则会错位。”

---

## 可视化与算法演示（动态规划）
### 动态规划表格填充动画
1. **可视化设计**：  
   - **网格绘制**：以 Canvas 绘制二维表格，行表示基因 A 的碱基，列表示基因 B 的碱基。  
   - **颜色标记**：  
     - 绿色：当前计算单元 `dp[i][j]`。  
     - 黄色：转移来源（`dp[i-1][j-1]`、`dp[i-1][j]`、`dp[i][j-1]`）。  
   - **数值更新**：逐步显示 `dp[i][j]` 的计算结果，并高亮最大值来源。

2. **复古像素风格**：  
   - **8-bit 音效**：  
     - 每次更新单元格时播放短促“滴”声。  
     - 找到最终结果时播放胜利音效。  
   - **像素动画**：单元格填充使用 8-bit 风格的色块，背景音乐为 Chiptune 风格循环。

3. **交互控制**：  
   - **步进模式**：用户可点击“下一步”观看填充过程。  
   - **自动播放**：以 1 秒/步的速度自动展示表格填充，支持暂停/继续。

```javascript
// 示例代码：动态规划表格绘制（伪代码）
function drawDPTable(a, b, dp) {
  const canvas = document.getElementById('dp-canvas');
  const ctx = canvas.getContext('2d');
  // 绘制网格和填充数值
  for (let i = 0; i <= a.length; i++) {
    for (let j = 0; j <= b.length; j++) {
      ctx.fillStyle = getColor(i, j, currentStep);
      ctx.fillRect(j * 50, i * 50, 48, 48);
      ctx.fillText(dp[i][j], j * 50 + 10, i * 50 + 30);
    }
  }
}
```

---

## 核心代码实现（zhy137036 题解）
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int la, lb, a[110], b[110], f[110][110];
int d[6][6] = {
    {0,0,0,0,0,0}, {0,5,-1,-2,-1,-3}, {0,-1,5,-3,-2,-4},
    {0,-2,-3,5,-2,-2}, {0,-1,-2,-2,5,-1}, {0,-3,-4,-2,-1,0}
};

int main() {
    // 输入处理与字符转换
    cin >> la;
    for (int i = 1; i <= la; i++) {
        char t; cin >> t;
        if (t == 'A') a[i] = 1; // 转换逻辑
        // ... 其他字符处理
    }
    // 初始化边界
    for (int i = 1; i <= la; i++)
        f[i][0] = f[i-1][0] + d[a[i]][5];
    for (int i = 1; i <= lb; i++)
        f[0][i] = f[0][i-1] + d[5][b[i]];
    // DP 状态转移
    for (int i = 1; i <= la; i++) {
        for (int j = 1; j <= lb; j++) {
            f[i][j] = max(f[i-1][j-1] + d[a[i]][b[j]],
                      max(f[i-1][j] + d[a[i]][5], f[i][j-1] + d[5][b[j]]));
        }
    }
    cout << f[la][lb];
    return 0;
}
```

---
处理用时：89.71秒
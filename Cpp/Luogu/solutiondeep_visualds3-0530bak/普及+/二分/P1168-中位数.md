# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果



**算法分类**  
无算法分类

---

**题解思路、算法要点与解决难点**  

1. **核心思路**  
   动态维护有序序列，快速获取中位数（第k大数）。关键难点在于高效插入元素并快速查询中间值。

2. **主流解法对比**  
   - **对顶堆法**  
     - 大根堆维护较小一半元素，小根堆维护较大一半。  
     - 插入时根据元素与当前中位数比较决定归属堆，调整堆大小差至1。  
     - 中位数为较大堆的堆顶。时间复杂度 O(n log n)，代码简洁高效。  
   - **树状数组+二分**  
     - 离散化后，树状数组维护元素出现次数。  
     - 二分查找第k大位置，通过前缀和判断区间。时间复杂度 O(n log n)，需离散化步骤。  
   - **平衡树/权值线段树**  
     - 直接维护有序结构，支持插入和查询第k大。时间复杂度 O(n log n)，实现复杂但通用性强。  

3. **二分关键点（树状数组法）**  
   - **离散化**：将元素映射到紧凑区间。  
   - **倍增二分**：从高位到低位逐步逼近第k大位置，利用树状数组前缀和判断是否累积足够数量。  
   - **边界处理**：离散化后需处理重复元素，确保二分正确性。

---

**题解评分 (≥4星)**  

1. **肖恩Sean（堆法）**  
   - **★★★★☆**  
   - 思路清晰，代码简洁，维护堆平衡逻辑直观，适合快速实现。  

2. **ysj1173886760（树状数组+二分）**  
   - **★★★★☆**  
   - 离散化与二分结合巧妙，高效但需处理离散化细节，适合大数据场景。  

3. **IRipple（堆法优化）**  
   - **★★★★☆**  
   - 引入中间变量 `mid` 简化调整步骤，逻辑更易理解，代码可读性高。  

---

**最优思路或技巧提炼**  

1. **对顶堆的平衡维护**  
   - 插入元素后，若两堆大小差超过1，调整堆顶元素到另一堆，保持中位数始终在堆顶。  
   - 代码片段：  
     ```cpp  
     while (abs(q1.size() - q2.size()) > 1) {  
         if (q1.size() > q2.size()) {  
             q2.push(q1.top()); q1.pop();  
         } else {  
             q1.push(q2.top()); q2.pop();  
         }  
     }  
     ```  

2. **树状数组的倍增二分**  
   - 从高位到低位枚举，累积前缀和判断是否满足第k大条件。  
   - 代码片段：  
     ```cpp  
     int find_kth(int k) {  
         int ans = 0, sum = 0;  
         for (int i = 20; i >= 0; i--) {  
             int pos = ans + (1 << i);  
             if (pos > tot || sum + c[pos] >= k) continue;  
             sum += c[pos];  
             ans = pos;  
         }  
         return ans + 1;  
     }  
     ```  

---

**同类型题或算法套路**  
- **动态维护中位数**：对顶堆通解，如 [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801)。  
- **第k大数查询**：树状数组+二分或平衡树，如 [P3380 二逼平衡树](https://www.luogu.com.cn/problem/P3380)。  
- **离散化+二分答案**：如 [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)。  

---

**推荐题目**  
1. [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801)  
2. [P3369 普通平衡树](https://www.luogu.com.cn/problem/P3369)  
3. [P3380 二逼平衡树](https://www.luogu.com.cn/problem/P3380)  

---

**可视化与算法演示**  

1. **对顶堆动画设计**  
   - **Canvas 绘制堆结构**：左右分栏表示大根堆和小根堆，插入元素时动态调整位置，高亮交换的堆顶元素。  
   - **颜色标记**：当前插入元素用红色，调整过程中的堆顶用黄色，中位数用绿色闪烁。  
   - **交互控制**：支持单步执行，观察插入后堆的平衡过程。  

2. **树状数组+二分复古像素动画**  
   - **像素网格**：用 8-bit 风格显示离散化后的数组，树状数组节点以不同颜色块表示累积数量。  
   - **音效触发**：二分时播放“哔”声，找到第k大时播放胜利音效。  
   - **AI自动演示**：自动插入元素并展示二分步骤，每步暂停 500ms，配复古电子音效。  

---

**代码片段（对顶堆核心）**  
```cpp  
priority_queue<int> q1; // 大根堆（较小一半）
priority_queue<int, vector<int>, greater<int>> q2; // 小根堆（较大一半）

void insert(int x) {
    if (q1.empty() || x <= q1.top()) q1.push(x);
    else q2.push(x);
    // 调整堆平衡
    while (q1.size() > q2.size() + 1) {
        q2.push(q1.top()); q1.pop();
    }
    while (q2.size() > q1.size()) {
        q1.push(q2.top()); q2.pop();
    }
}

int get_median() {
    return q1.top();
}
```  

---

**总结**  
对顶堆法以直观逻辑和高效实现成为本题最优解，树状数组+二分适合进阶练习。可视化设计通过动态调整和复古风格增强理解，适合教学与自学。

---
处理用时：114.95秒
# 题目信息

# 【模板】最长公共子序列

## 题目描述

给出 $1,2,\ldots,n$ 的两个排列 $P_1$ 和 $P_2$ ，求它们的最长公共子序列。

## 说明/提示

- 对于 $50\%$ 的数据， $n \le 10^3$；
- 对于 $100\%$ 的数据， $n \le 10^5$。

## 样例 #1

### 输入

```
5 
3 2 1 4 5
1 2 3 4 5
```

### 输出

```
3```

# AI分析结果



**算法分类**：二分

**核心思路与解决难点**：  
该题的关键是将LCS问题转化为LIS问题。由于两个排列均为1~n的全排列，可将第一个排列的元素位置映射为有序序列。对于第二个排列的元素，转换为它们在第一个排列中的位置后，求LIS的长度即为答案。LIS的O(n log n)解法通过维护单调数组，利用二分查找优化。

**题解评分 (≥4星)**：  
1. 皎月半洒花（★★★★☆）：详细讲解LIS的二分优化，并完整转化思路。
2. 阮行止（★★★★☆）：用离散化思想清晰解释LCS到LIS的转化。
3. heey（★★★★☆）：简明扼要的代码实现，高效解决转化后的LIS。

**最优思路提炼**：  
1. **位置映射**：将第一个排列的元素值映射为位置索引，形成有序序列。
2. **序列转换**：将第二个排列的元素替换为对应位置值，得到新序列。
3. **LIS二分优化**：维护数组`d`，`d[i]`表示长度为i的LIS末尾元素的最小值。遍历时二分查找插入位置。

**同类型题拓展**：  
- 类似转化：若序列元素唯一且范围明确，可尝试离散化后求LIS。
- 通用二分技巧：适用于有序或可转化为有序的问题，如寻找极值、边界条件。

**推荐题目**：  
1. P1020 导弹拦截（LIS模板题）  
2. P2782 友好城市（排序后LIS应用）  
3. P3902 递增（最长严格递增子序列）

**代码实现**：  
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int MAXN = 1e5 + 5;
int a[MAXN], pos[MAXN], d[MAXN];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, x;
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> x;
        pos[x] = i; // 记录元素x在第一个排列中的位置
    }
    
    int len = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> x;
        x = pos[x]; // 转换为第二个排列元素的位置值
        if (x > d[len]) d[++len] = x;
        else *lower_bound(d + 1, d + len + 1, x) = x;
    }
    cout << len;
    return 0;
}
```

**可视化与二分演示**：  
- **动画设计**：  
  - 初始时，`d`数组为空。  
  - 每个元素x进入时，若x大于`d[len]`，扩展数组；否则用红色标记二分区间，绿色显示插入位置。  
  - 颜色区分：当前元素（蓝色），`d`数组元素（灰色），插入位置（绿色）。  
- **复古像素风**：用8位风格网格展示数组变化，音效提示插入动作，背景音乐循环播放。  
- **交互功能**：步进控制、速度调节，自动演示模式展示每一步的区间收缩过程。

**个人心得**：  
- **调试重点**：确保位置映射正确，避免数组越界。  
- **思维突破**：将复杂问题转化为经典模型，利用已知高效算法解决。

---
处理用时：67.02秒
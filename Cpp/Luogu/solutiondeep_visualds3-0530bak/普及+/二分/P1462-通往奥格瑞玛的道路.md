# 题目信息

# 通往奥格瑞玛的道路

## 题目背景

在艾泽拉斯大陆上有一位名叫歪嘴哦的神奇术士，他是部落的中坚力量。

有一天他醒来后发现自己居然到了联盟的主城暴风城。

在被众多联盟的士兵攻击后，他决定逃回自己的家乡奥格瑞玛。

## 题目描述

在艾泽拉斯，有 $n$ 个城市。编号为 $1,2,3,\ldots,n$。

城市之间有 $m$ 条双向的公路，连接着两个城市，从某个城市到另一个城市，会遭到联盟的攻击，进而损失一定的血量。

每次经过一个城市，都会被收取一定的过路费（包括起点和终点）。路上并没有收费站。

假设 $1$ 为暴风城，$n$ 为奥格瑞玛，而他的血量最多为 $b$，出发时他的血量是满的。如果他的血量降低至负数，则他就无法到达奥格瑞玛。

歪嘴哦不希望花很多钱，他想知道，在所有可以到达奥格瑞玛的道路中，对于每条道路所经过的城市收费的最大值，最小值为多少。

## 说明/提示

对于 $60\%$ 的数据，满足 $n\leq 200$，$m\leq 10^4$，$b\leq 200$；

对于 $100\%$ 的数据，满足 $1\leq n\leq 10^4$，$1\leq m\leq 5\times 10^4$，$1\leq b\leq 10^9$；

对于 $100\%$ 的数据，满足 $1\leq c_i\leq 10^9$，$0\leq f_i\leq 10^9$，可能有两条边连接着相同的城市。

## 样例 #1

### 输入

```
4 4 8
8
5
6
10
2 1 2
2 4 1
1 3 4
3 4 3
```

### 输出

```
10
```

# AI分析结果



# 算法分类  
**二分**

---

# 题解分析与结论  

## 题解思路与核心难点  
1. **二分答案框架**：  
   - **搜索区间**：左边界取起点与终点收费的较大值（必经之路），右边界取所有城市收费最大值。  
   - **判断条件**：对于当前二分值 `mid`，仅允许收费 ≤ `mid` 的城市，计算 1→n 的最短路径（边权为扣血量），若总扣血 ≤b 则说明 `mid` 可行。  
   - **优化思路**：先对城市收费排序后二分，缩小搜索范围；部分题解在二分前预处理不可达情况（如 `mid=INF` 时仍无法到达则输出 AFK）。  

2. **最短路实现**：  
   - **Dijkstra 堆优化**：稳定 O(m log n)，适合正权边，如 George1123 的题解处理了 long long 溢出。  
   - **SPFA**：实现简单但可能被特殊数据卡到 O(nm)，在随机数据中表现较好，如 Atlicd 的题解通过动态更新血量最大值优化判断逻辑。  

3. **难点对比**：  
   - **边界处理**：部分题解未考虑起点/终点收费超过 `mid` 的情况，需在检查时显式过滤。  
   - **死循环避免**：通过 `mid = (l + r) >> 1` 和 `l = mid + 1` 的组合确保收敛。  
   - **距离溢出**：使用 `long long` 存储总扣血量，避免数值溢出。  

---

# 高星题解推荐 (≥4⭐)  
1. **George1123（⭐5）**  
   - **亮点**：代码规范，处理溢出细节，优先队列优化 Dijkstra，初始值合理。  
   - **关键代码**：  
     ```cpp  
     while (l < r) {  
         mid = (l + r) >> 1;  
         Dijkstra(mid);  
         if (dis[n] <= b) r = mid;  
         else l = mid + 1;  
     }  
     ```  
2. **Atlicd（⭐4）**  
   - **亮点**：逻辑清晰，动态维护最大血量，用 `pair` 简化堆操作。  
   - **优化点**：在 SPFA 中跳过无效松弛，减少计算量。  

3. **shenbear（⭐4）**  
   - **亮点**：强调二分单调性，代码简短，用 `dis[n] <= b` 直接判断可行性。  

---

# 最优思路提炼  
1. **二分答案**：将最大值最小化问题转化为可行性判断问题。  
2. **预处理排序**：对城市收费排序后二分，缩小搜索范围至 O(log n)。  
3. **Dijkstra 堆优化**：稳定处理正权图，避免 SPFA 的最坏复杂度。  
4. **边界检查**：显式过滤起点/终点收费超过 `mid` 的情况。  

---

# 同类型题与算法套路  
1. **类似题目**：  
   - **P1948** [USACO08JAN] Telephone Lines S（二分+最短路）  
   - **P2622** 关灯问题II（状态压缩+二分）  
   - **P2218** [HAOI2007] 覆盖问题（二分+几何覆盖）  
2. **通用套路**：  
   - 当问题可抽象为“最小化最大值/最大化最小值”时，优先考虑二分答案。  
   - 结合最短路、贪心、动态规划等算法进行可行性验证。  

---

# 可视化与算法演示  
**核心二分过程动画设计**：  
1. **初始状态**：  
   - 横轴表示城市收费排序后的数组，红色指针标记当前 `mid`，绿色区间为 [l, r]。  
   - 右侧面板显示当前 `mid` 下的最短路径计算结果。  

2. **动态更新**：  
   - **可行**（绿色高亮）：收缩右边界（`r = mid - 1`），显示新区间。  
   - **不可行**（红色高亮）：收缩左边界（`l = mid + 1`），显示更新后的搜索方向。  

3. **复古像素风格**：  
   - 使用 8-bit 音效：移动指针时播放“哔”声，找到解时播放胜利旋律。  
   - Canvas 绘制网格，每次区间更新时用不同颜色块标记历史 `mid` 值。  

---

# 关键代码片段  
**Dijkstra 检查函数**（George1123 题解）：  
```cpp  
void Dijkstra(int maxn) {  
    for (int i = 1; i <= n; i++) dis[i] = INF, vis[i] = 0;  
    dis[1] = 0;  
    priority_queue<node> q;  
    q.push({1, 0});  
    while (!q.empty()) {  
        int u = q.top().a; q.pop();  
        if (vis[u]) continue;  
        vis[u] = 1;  
        for (int i = g[u]; i; i = e[i].nex) {  
            int v = e[i].adj;  
            if (f[v] > maxn) continue;  // 过滤超限城市  
            if (dis[v] > dis[u] + e[i].w) {  
                dis[v] = dis[u] + e[i].w;  
                q.push({v, dis[v]});  
            }  
        }  
    }  
}  
```  

---

# 总结  
本题通过二分答案将复杂约束问题转化为可验证的子问题，结合最短路算法高效求解。关键点在于合理设计二分边界和检查逻辑，避免无效搜索。可视化设计可帮助理解二分收缩过程与最短路动态更新，适合教学与算法演示。

---
处理用时：76.83秒
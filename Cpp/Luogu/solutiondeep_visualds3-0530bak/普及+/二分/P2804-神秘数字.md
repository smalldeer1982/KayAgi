# 题目信息

# 神秘数字

## 题目背景

在公元XXXX年，侦探小明收到了组织的神秘信息，在Y市的某个地方有一道神秘的门。小明到达了那个门后，发现门上有一行字：“这个门需要密码才能解锁。”小明左找右找，终于找到了一张字条：“现在给你n个数，请你求出这n个数里面，有多少个连续的数的平均数大于某个给定的数M？注意：这个数可能会很大，请输出这个数对92084931取模的结果。最终的结果即是这个门的密码。”小明苦思冥想了半天，但始终找不到答案。于是他来求助于你。请你帮他解决这个问题。由于小明十分着急，他最多只能等1秒。


## 题目描述

给定n个数，请你帮助小明求出里面有多少个连续的数的平均数大于给定的某个数M.并将这个方案数输出。注意：这个数可能会很大，所以请输出这个数对92084931取模的结果。


## 说明/提示

【样例解释】

①对于这4个数，问题的解有{5}，{4}，{5,4}，{1,5,4}，{5,4,2}共5组。

②对于这4个数，问题的解有{5}，{7}，{2,7}，{7,3}，{5,2,7}，{5,2,7,3}共6组。

【数据规模】

对于10%的数据，1＜n≤10.

对于30%的数据，1＜n≤1000.

对于50%的数据，1＜n≤30000.

对于100%的数据，1＜n≤200000，1＜M≤3000，每个数均为正整数且不大于5000.


## 样例 #1

### 输入

```
4 3
1 5 4 2```

### 输出

```
5```

## 样例 #2

### 输入

```
4 4
5 2 7 3```

### 输出

```
6```

# AI分析结果



### 算法分类
无算法分类

---

### 题解思路、算法要点与解决难点

**核心思路**  
将原数组每个元素减去 M，问题转化为求新数组的连续子数组和大于 0 的个数。通过前缀和数组 S，问题进一步转化为求顺序对 (i < j 且 S[i] < S[j]) 的总数。

**关键算法**  
1. **归并排序法**：在归并排序的分治过程中统计顺序对。合并左右两个有序数组时，若左元素小于右元素，则左元素可与右半剩余所有元素形成顺序对。
2. **树状数组/权值线段树**：离散化前缀和数组后，动态维护已处理元素的分布，查询当前元素之前有多少更小的元素。

**解决难点**  
- **前缀和初始化**：需包含 S[0] = 0，否则会漏掉从第一个元素开始的子数组。
- **离散化处理**：树状数组需处理负数和大范围值，需离散化前缀和数组。
- **顺序对统计逻辑**：归并排序中需调整合并方向（降序合并）以正确统计顺序对。

---

### 题解评分（≥4星）

1. **cabasky 的归并排序解法（5星）**  
   - 思路清晰，代码简洁，直接通过归并排序统计顺序对。
   - 关键代码段注释明确，合并逻辑高效。
   - 包含 S[0] 处理，避免漏解。

2. **郑翰 的树状数组解法（4.5星）**  
   - 使用离散化和树状数组动态维护顺序对。
   - 代码注释较少，但逻辑清晰，处理了负数问题。
   - 包含对单个元素特判的优化。

3. **Zachary_Cloud 的权值线段树解法（4星）**  
   - 权值线段树实现动态查询，思路新颖。
   - 离散化步骤稍显复杂，但代码结构合理。

---

### 最优思路或技巧提炼

1. **前缀和转换**：将平均数问题转化为子数组和问题，是核心思维跳跃点。
2. **顺序对统计**：通过归并排序或树状数组高效统计顺序对，时间复杂度 O(n log n)。
3. **离散化技巧**：树状数组解法中，离散化处理大范围或负数值，压缩值域。

---

### 同类型题或类似算法套路

- **逆序对问题**：如洛谷 P1908，统计 i < j 且 a[i] > a[j] 的对数。
- **前缀和 + 数据结构**：如统计满足特定条件的子数组数量，常结合哈希表、树状数组等。
- **离散化应用**：处理大范围数据时，通过排序+去重压缩值域。

---

### 推荐相似题目

1. **P1908 逆序对**  
   （基础逆序对统计，归并排序/树状数组模板题）

2. **P2717 寒假作业**  
   （求平均数大于 k 的子数组数量，与此题高度相似）

3. **CF1042D Subarray with Sum**  
   （统计子数组和满足特定条件的问题，需前缀和+数据结构）

---

### 个人心得摘录

- **cabasky**：强调顺序对统计需包含 S[0]，否则会漏解。
- **SCKer**：提醒树状数组需处理重复值，需在离散化时特殊处理。
- **_edge_**：调试时发现二分法无法应用，最终通过归并排序解决。

---

### 可视化与算法演示

**归并排序分治过程动画设计**  
1. **分治可视化**：递归将数组分割为左右子数组，以树形结构展示分治过程。
2. **合并高亮**：合并时用颜色区分左右子数组，左半蓝色，右半绿色。
3. **顺序对统计**：当左元素 < 右元素时，高亮左半剩余元素，显示顺序对数量增加。
4. **像素风格**：  
   - 使用 8-bit 像素风格，合并步骤配以“哔”声提示。
   - Canvas 绘制网格，元素值越大颜色越亮。

**树状数组操作演示**  
1. **离散化步骤**：展示原数组映射到压缩后的值域。
2. **动态更新**：元素插入树状数组时，高亮对应节点。
3. **查询路径**：用红色连线标记查询比当前元素小的总和。

---

### 核心代码实现（归并排序法）

```cpp
#include <iostream>
using namespace std;
const int MOD = 92084931;
int n, m, a[200010], sum[200010], temp[200010], ans;

void merge(int l, int mid, int r) {
    int p1 = l, p2 = mid + 1, k = l;
    while (p1 <= mid && p2 <= r) {
        if (sum[p1] < sum[p2]) {
            ans = (ans + (mid - p1 + 1)) % MOD;
            temp[k++] = sum[p2++];
        } else {
            temp[k++] = sum[p1++];
        }
    }
    while (p1 <= mid) temp[k++] = sum[p1++];
    while (p2 <= r) temp[k++] = sum[p2++];
    for (int i = l; i <= r; i++) sum[i] = temp[i];
}

void mergesort(int l, int r) {
    if (l >= r) return;
    int mid = (l + r) >> 1;
    mergesort(l, mid);
    mergesort(mid + 1, r);
    merge(l, mid, r);
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        a[i] -= m;
        sum[i] = sum[i - 1] + a[i];
    }
    mergesort(0, n); // 包含 S[0]
    printf("%d\n", ans);
    return 0;
}
```

---

### 总结

本题通过前缀和转换与顺序对统计，避免了暴力枚举，是典型的高效算法设计案例。归并排序和树状数组是两种经典实现方式，需重点掌握其核心思想与边界处理。

---
处理用时：92.61秒
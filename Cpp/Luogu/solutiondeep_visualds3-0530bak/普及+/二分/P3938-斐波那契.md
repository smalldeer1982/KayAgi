# 题目信息

# 斐波那契

## 题目背景

大样例可在页面底部「附件」中下载。

## 题目描述

小 C 养了一些很可爱的兔子。 有一天，小 C 突然发现兔子们都是严格按照伟大的数学家斐波那契提出的模型来进行 繁衍：一对兔子从出生后第二个月起，每个月刚开始的时候都会产下一对小兔子。我们假定， 在整个过程中兔子不会出现任何意外。

小 C 把兔子按出生顺序，把兔子们从 1 开始标号，并且小 C 的兔子都是 1 号兔子和 1 号兔子的后代。如果某两对兔子是同时出生的，那么小 C 会将父母标号更小的一对优先标 号。

如果我们把这种关系用图画下来，前六个月大概就是这样的：

 
  ![](https://cdn.luogu.com.cn/upload/pic/9806.png) 

其中，一个箭头 $A \to B$ 表示 $A$ 是 $B$ 的祖先，相同的颜色表示同一个月出生的兔子。

为了更细致地了解兔子们是如何繁衍的，小 C 找来了一些兔子，并且向你提出了 $m$ 个问题：她想知道关于每两对兔子 $a_i$ 和 $b_i$，他们的最近公共祖先是谁。你能帮帮小 C 吗？

一对兔子的祖先是这对兔子以及他们父母（如果有的话）的祖先，而最近公共祖先是指 两对兔子所共有的祖先中，离他们的距离之和最近的一对兔子。比如，$5$ 和 $7$ 的最近公共祖 先是 $2,1$ 和 $2$ 的最近公共祖先是 $1,6$ 和 $6$ 的最近公共祖先是 $6$。


## 说明/提示

【数据范围与约定】 子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。 每个测试点的数据规模及特点如下表：

 ![](https://cdn.luogu.com.cn/upload/pic/9807.png) 

特殊性质 $1$：保证 $a_i$, $b_i$ 均为某一个月出生的兔子中标号最大的一对兔子。例如，对 于前六个月，标号最大的兔子分别是 $1, 2, 3, 5, 8, 13$。

特殊性质 $2$：保证 $|a_i-b_i|\le 1$。


## 样例 #1

### 输入

```
5 
1 1 
2 3 
5 7 
7 13 
4 12```

### 输出

```
1 
1 
2 
2 
4 ```

# AI分析结果



**唯一算法分类**  
二分

---

**综合分析与结论**  
本题核心在于利用斐波那契数列的特性，通过二分查找快速定位父节点，实现高效的最近公共祖先求解。各题解均围绕以下核心逻辑展开：

1. **关键算法逻辑**  
   - 预处理斐波那契数列（前60项即可覆盖1e12范围）  
   - 对任意编号x，其父节点为 `x - 最大的斐波那契数f[i] (f[i] < x)`  
   - 通过递归/循环交替处理较大数，直至两数相等  

2. **二分算法要点**  
   - **搜索区间**：预处理好的斐波那契数组（`f[1]~f[60]`）  
   - **二分条件**：找到满足 `f[i] < x` 的最大i  
   - **收缩策略**：`lower_bound` 定位后取 `f[i-1]`  
   - **边界处理**：初始值设为 `f[0]=1` 避免下标越界  

3. **解决难点**  
   - **数学规律推导**：通过斐波那契数列的层级生育规律，将树结构转换为数学操作  
   - **高效跳跃**：每次跳跃直接跨越整个子树，时间复杂度优化至 `O(logΦN)`  

---

**题解清单（≥4星）**  

1. **浅色调（5星）**  
   - **亮点**：代码简洁高效，递归实现直观，二分查找预处理斐波那契数列  
   - **核心代码**：  
     ```cpp
     void find(ll a,ll b) {
         if(a < b) swap(a, b);
         if(a == b) { printf("%lld\n",a); return; }
         int w = lower_bound(c, c+62, a) - c;
         find(b, a - c[w-1]);
     }
     ```

2. **Smallbasic（5星）**  
   - **亮点**：非递归实现，循环中直接处理较大值，边界条件处理清晰  
   - **核心代码**：  
     ```cpp
     while(n != m) {
         if(n < m) swap(n, m);
         for(int i = 59; i >= 1; --i)
             if(fib[i] < n) { n -= fib[i]; break; }
     }
     ```

3. **吾乃会虎（4星）**  
   - **亮点**：斐波那契进制编码思路新颖，通过后缀匹配优化跳跃过程  
   - **关键思路**：将编号转为斐波那契进制后，父节点为其二进制后缀  

---

**最优技巧提炼**  
- **跳跃策略**：每次操作较大值，确保收敛速度  
- **预处理优化**：预先计算斐波那契数列，避免重复生成  
- **二分加速**：使用 `lower_bound` 快速定位最大斐波那契数  

---

**同类型题与算法套路**  
1. **二分答案**：如「P1873 砍树」通过二分高度判断可行性  
2. **树形LCA**：如「P3379 最近公共祖先」的倍增算法  
3. **数学规律题**：如「P1962 斐波那契数列」的矩阵快速幂解法  

---

**推荐题目**  
1. **P1962**（斐波那契数列快速计算）  
2. **P1182**（数列分段，二分答案经典题）  
3. **P3396**（哈希冲突，数学规律优化查询）  

---

**可视化设计要点**  
1. **像素动画**：以网格展示斐波那契数列，当前数值用闪烁方块高亮  
2. **搜索过程**：用不同颜色区分 `a` 和 `b` 的跳跃路径，箭头表示减法操作  
3. **音效交互**：  
   - 跳跃时播放「哔」声  
   - 找到LCA时播放经典FC过关音效  
4. **自动演示**：模拟两种数值向LCA收敛的动画，速度可调  

---

**代码实现（核心二分逻辑）**  
```cpp
// 预处理斐波那契数列
ll f[60] = {1, 1};
for (int i=2; i<60; i++) f[i] = f[i-1] + f[i-2];

// 跳跃函数
ll lca(ll a, ll b) {
    while (a != b) {
        if (a < b) swap(a, b);
        int pos = lower_bound(f, f+60, a) - f - 1;
        a -= f[pos];
    }
    return a;
}
```

---

**复古游戏化演示**  
- **Canvas绘制**：用16色像素风格展示斐波那契树，节点按层级分布  
- **音效触发**：每次跳跃触发8-bit音效，LCA命中时播放胜利旋律  
- **连击积分**：正确步骤增加连击数，错误操作重置积分  

---

**心得摘录**  
> 「调试时发现必须开long long，否则会WA... 数据范围是隐藏的大坑！」——浅色调  
> 「将编号-1后转为斐波那契进制，父节点就是后缀，这规律太巧妙了！」——吾乃会虎  

---

**可视化伪代码（JS）**  
```javascript
// 初始化斐波那契数列
const fib = [1n, 1n];
for (let i=2; i<60; i++) fib[i] = fib[i-1] + fib[i-2];

// 动画步骤
function animateLCA(a, b) {
    let steps = [];
    while (a !== b) {
        if (a < b) [a, b] = [b, a];
        const idx = fib.findIndex(v => v > a) - 1;
        steps.push({a, b, f: fib[idx]});
        a -= fib[idx];
    }
    return steps; // 用于逐帧渲染
}
```

---
处理用时：55.48秒
# 题目信息

# 『MdOI R1』Group

## 题目背景

此题为比赛时的数据。

然鹅后来yummy觉得没这个必要，于是放弃加强。

**存在不使用`long double`和`__int128`的写法。**

## 题目描述

为了让我们团队的同学更加团结，我们需要让各个成员的水平尽量平均。这时，就需要有人对自己产生一些改变。

我们的团队有 $n$ 个同学，第 $i$ 个同学的水平值是一个整数 $a_i$。

我们认为当整组同学水平值的 **方差** **不超过 $m$** 的时候，这组同学就是团结的。  

请问至少要让几个同学改变自己的水平值（可以改成任意一个 **实数**），这个团队才可以做到团结？

为避免读入时的精度误差，本题输入的 $m$ 是 **实际值的 $n$ 倍**，这个值是一个整数。

---

如果你不知道什么叫做方差，以下是方差的基本概念：

方差是衡量一组数据 **波动程度** 的指标。

设长度为 $n$ 的序列 $a_{1\dots n}$ 的平均数为 $p$，则该序列的方差 $S$ 为：

$$
S=\frac{1}{n} \sum_{i=1}^n(a_i-p)^2
$$

## 说明/提示

【样例 1 解释】   

这组样例中，$n=4$，真实的 $m=\dfrac{32}{n}=8$。

一开始，所有同学水平值 $a_i$ 的平均数为 $1$，方差为：

$$S=\dfrac{1}{4}[(3-1)^2+(7-1)^2+(-5-1)^2+(-1-1)^2]=20$$

把第 $3$ 个同学的水平值改成 $3$ 后，平均数为 $3$，方差为：

$$S=\dfrac{1}{4}[(3-3)^2+(7-3)^2+(3-3)^2+(-1-3)^2]=8$$

只改变了 $1$ 人的水平值，即满足了题目要求。

【样例 2 解释】

这组样例中，$n=5$，真实的 $m=\dfrac{18}{n}=3.6$。

一开始，所有同学水平值 $a_i$ 的平均数为 $4.6$，方差为 $7.44$：

把第 $5$ 个同学的水平值改成 $3.5$ 后，平均数为 $3.5$，**方差为 $2.6$。**

只改变了 $1$ 人的水平值，即满足了题目要求。

---

【数据范围】   

|子任务编号|$n\leq$|分值|
|:-:|:-:|:-:|
|1|$16$|15|
|2|$300$|17|
|3|$10^3$|20|
|4|$5\times 10^3$|7|
|5|$10^4$|8|
|6|$2\times 10^5$|33|

对于所有测试点，$1\leq n\leq 2\times 10^5$，$1\leq m\leq 10^{18}$，$0\leq |a_i|\leq 10^6$。

## 样例 #1

### 输入

```
4 32
3 7 -5 -1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5 18
1 4 3 6 9
```

### 输出

```
1
```

## 样例 #3

### 输入

```
6 679
5 83 56 20 54 111
```

### 输出

```
3
```

# AI分析结果



# 算法分类  
二分  

---

# 题解分析与结论  
## 核心思路  
所有题解均采用**排序+二分答案**框架，核心要点如下：  
1. **排序必要性**：将数组排序后，最优解必然是保留某个连续区间（非连续区间方差更大）  
2. **数学转换**：通过将方差公式展开为`平方和 - (和)^2/长度`，实现O(1)方差计算  
3. **二分策略**：二分保留的区间长度，利用前缀和快速验证  

## 二分关键实现  
1. **搜索区间**：left=1（最少保留1人），right=n（全保留）  
2. **mid含义**：当前尝试保留的连续区间长度  
3. **收缩条件**：若存在长度为mid的区间满足方差条件，则尝试更长的区间（减少修改人数）；否则缩短区间  
4. **边界处理**：最终答案取`n - 最大可行长度`  

## 解决难点  
1. **精度处理**：通过公式变形完全消除浮点运算，使用整数或`__int128`避免溢出  
2. **复杂度优化**：前缀和预处理将每次验证降为O(n) → O(1)  

---

# 高星题解推荐（≥4⭐）  
1. **liangbowen（5⭐）**  
   - 亮点：代码结构清晰，数学推导详细，使用`__int128`处理大数  
   - 核心代码：  
     ```cpp
     bool chk(int peo) { // 验证保留peo人是否可行
         for (int l=1, r=peo; r<=n; l++, r++) {
             LL t1 = peo * (sqsum[r]-sqsum[l-1]);
             LL t2 = (sum[r]-sum[l-1]) * (sum[r]-sum[l-1]);
             return t1 - t2 <= peo * m;
         }
     }
     ```

2. **yummy（4.5⭐）**  
   - 亮点：图文结合解释连续区间的正确性，提供多Subtask解法  
   - 关键图示：用几何图形证明非连续区间方差更大  

3. **MoonCake2011（4⭐）**  
   - 亮点：代码简洁，数学公式推导注释明确  
   - 核心优化：`psum - sum^2/len ≤ m` 的整数化处理  

---

# 最优思路提炼  
1. **排序连续性**：最优解必然是排序后的连续区间，消除离散点的干扰  
2. **方差整数化**：将方差公式转化为`sum_sq * len - sum^2 ≤ m * len`，完全避免浮点误差  
3. **前缀和双维护**：同时维护`sum`和`sum_sq`实现O(1)区间计算  
4. **二分收缩技巧**：当验证成功时尝试更大长度（`l=mid+1`），失败时缩小（`r=mid-1`）  

---

# 同类题目推荐  
1. **P1873 砍树**（二分查找最大伐木高度）  
2. **P2678 跳石头**（二分最小跳跃距离）  
3. **P4343 自动刷题机**（二分答案验证题数）  

---

# 可视化设计（二分过程）  
## 动画方案  
1. **初始状态**：排序后的数组水平排列，上方标注当前搜索区间`[left, right]`  
2. **单步演示**：  
   - 红色高亮`mid`对应的候选区间  
   - 显示该区间的sum和sum_sq计算值  
   - 绿色/红色边框表示是否满足方差条件  
3. **区间更新**：  
   - 满足条件 → 右区间变为`mid+1`（蓝色箭头右移）  
   - 不满足 → 左区间变为`mid-1`（红色箭头左移）  

## 复古像素风格  
```javascript
// 伪代码：Canvas绘制二分过程
function drawStep(l, r, mid) {
    ctx.fillStyle = '#8B8BEC'; // 区间底色
    ctx.fillRect(l*cellW, 0, (r-l)*cellW, 50); 
    ctx.fillStyle = '#FF5555'; // mid高亮
    ctx.fillRect(mid*cellW, 0, cellW, 50);
    playSound('blip'); // 每次移动播放音效
}
```

---

# 核心代码实现  
```cpp
bool check(int len) { // 二分验证函数
    for(int i=len; i<=n; i++) {
        LL s = sum[i] - sum[i-len];
        LL sq = sqsum[i] - sqsum[i-len];
        if(sq*len - s*s <= m*len) return true;
    }
    return false;
}
int binarySearch() {
    int l=1, r=n, ans=0;
    while(l <= r) {
        int mid = (l+r)/2;
        if(check(mid)) {
            ans = mid;
            l = mid+1;
        } else r = mid-1;
    }
    return n - ans;
}
```

---
处理用时：66.42秒
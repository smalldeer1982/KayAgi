# 题目信息

# [KSN2021] Colouring Balls

## 题目描述

**这是一道交互题。**

有 $N$ 个小球，从 $1$ 到 $N$ 编号。

你每次可以询问编号在 $[l,r]$ 之间的小球有几种不同的颜色，你需要求出每个小球的颜色。由于你并不知道具体颜色是什么，你只要将同种颜色用同一个数字表示即可。

## 交互格式

第一行输入一个正整数 $T$，**代表 Subtask 编号（而不是测试数据组数）**。

第二行输入两个整数 $N,Q$，代表小球数量和询问次数限制。

接下来你可以提出不超过 $Q$ 个询问并读取交互库返回的答案，每个询问的格式为 ``? l r``，代表你询问 $[l,r]$ 中小球颜色的数量。

当你确认所有小球的颜色后，你需要输出 ``! a1 a2 ... an`` 代表所有小球的颜色。你需要保证：

* $1\leq a_i\leq N$ 且 $a_i$ 均为整数。
* 相同颜色的小球的 $a_i$ 相同。
* 不同颜色的小球的 $a_i$ 不同。

你的每次输出后都需要刷新缓冲区，你可以使用如下语句来清空缓冲区：

- 对于 C/C++：`fflush(stdout)`；
- 对于 C++：`std::cout << std::flush`；
- 对于 Java：`System.out.flush()`；
- 对于 Python：`stdout.flush()`；
- 对于 Pascal：`flush(output)`；
- 对于其他语言，请自行查阅对应语言的帮助文档。

## 说明/提示

**【数据范围】**

**本题采用捆绑测试。**

* Subtask 1（8 points）：$Q=10000$, 保证每种颜色的球的编号连续。
* Subtask 2（7 points）：$Q=2000$，保证每种颜色的球的编号连续。
* Subtask 3（19 points）：$Q=2000$，保证球只有至多 $3$ 种颜色。
* Subtask 4（14 points）：$Q=2000$，保证球只有至多 $4$ 种颜色。
* Subtask 5（12 points）：$Q=2000$，保证球有至少 $(N-1)$ 种颜色。
* Subtask 6（21 points）：$Q=10000$，保证 $N\le 100$。
* Subtask 7（19 points）：$Q=10000$。

对于所有数据，保证 $1\leq T\leq 7$，$2\leq N\leq 10^3$。

## 样例 #1

### 输入

```
1
5 10000

2

1

2
 ```

### 输出

```
 

? 1 5

? 1 3

? 2 4

! 1 1 1 2 2```

# AI分析结果



**唯一算法分类**  
二分

---

### **题解思路、算法要点与解决难点**

1. **核心二分逻辑**  
   - **搜索区间**：对每个小球 i，在 [1, i-1] 中二分，确定其颜色是否存在于已处理区间。  
   - **二分条件**：询问区间 [mid, i] 的颜色数是否等于已知 [mid, i-1] 的颜色数。若相等，说明 i 的颜色存在于 [mid, i-1]，收缩右边界；否则收缩左边界。  
   - **边界处理**：若二分无解，说明 i 的颜色为新颜色。

2. **解决难点**  
   - **动态维护颜色位置**：记录已出现颜色的最左/最右位置，排序后二分，保证每次询问的有效性。  
   - **Subtask 优化**：  
     - 颜色连续时用双指针法（如 Subtask 2）；  
     - 颜色数有限时通过分类讨论减少二分次数（如 Subtask 3、4）；  
     - 至少 (N-1) 种颜色时特判重复点（如 Subtask 5）。

---

### **题解评分 (≥4星)**

1. **Natsume_Rin (5星)**  
   - **亮点**：清晰描述通用二分框架，分析 Subtask 优化逻辑，提供分类讨论思路。  
   - **代码**：未展示，但思路完整。

2. **gyh20 (4星)**  
   - **亮点**：代码覆盖所有 Subtask，二分逻辑简洁，处理颜色数有限时排序后直接判断。  
   - **代码片段**：  
     ```cpp
     sort(p+1,p+4,cmp);
     if (ask(lst[p[j]],i)==j) c[i]=p[j];
     ```

3. **Eafoo (4星)**  
   - **亮点**：分治策略明确，通过总颜色数动态调整二分区间，处理新颜色逻辑清晰。  
   - **代码片段**：  
     ```cpp
     int get(int x) {
         // 动态排序 pre_c，二分确定颜色
         if (query(p[mid],x) == cnt-mid+1) r = mid-1;
     }
     ```

---

### **最优思路或技巧提炼**

1. **核心二分策略**  
   - **逆向维护颜色位置**：从右向左记录颜色首次出现的位置，排序后二分，保证区间单调性。  
   - **暴力计算已知颜色数**：对已处理区间 [mid, i-1]，直接统计颜色数，避免浪费询问次数。

2. **Subtask 优化技巧**  
   - **颜色连续时**：相邻询问判断颜色是否相同，仅需 O(N) 次询问。  
   - **颜色数 ≤4 时**：排序后最多两次询问即可确定颜色，无需完整二分。

---

### **同类型题或类似算法套路**

1. **二分答案**：如 [P1873 砍树](https://www.luogu.com.cn/problem/P1873)，通过二分猜测答案并验证。  
2. **交互式二分**：如 [CF862B Mahmoud and Ehab and the bipartiteness](https://codeforces.com/problemset/problem/862/B)，通过询问缩小解空间。  
3. **动态维护有序序列**：如 [P3382 查找函数峰值](https://www.luogu.com.cn/problem/P3382)，结合单调性快速定位。

---

### **推荐洛谷题目**

1. **P1873** - 砍树（二分答案）  
2. **P3382** - 查找函数峰值（三分法）  
3. **CF1760G** - SlavicG's Favorite Problem（交互式二分）

---

### **可视化与算法演示**

**动画设计**：  
1. **区间展示**：用 Canvas 绘制 [left, right] 区间，高亮当前 mid 和收缩方向。  
2. **像素风格**：  
   - 区间块用 8-bit 颜色区分，mid 闪烁显示；  
   - 音效：收缩时播放电子音，找到颜色时播放胜利音效。  
3. **自动演示模式**：  
   - 初始参数设置（N=10），自动执行二分流程；  
   - 支持暂停/步进，显示当前颜色分布和询问结果。

**代码片段（JS 伪代码）**：  
```javascript
function drawInterval(left, right, mid) {
    ctx.fillStyle = "#8B0000"; // 深红表示区间
    ctx.fillRect(left*30, 50, (right-left)*30, 30);
    ctx.fillStyle = "#FFD700"; // 金色表示 mid
    ctx.fillRect(mid*30, 50, 30, 30);
}
```

---

**结论**：二分法通过动态维护颜色位置和巧妙的条件判断，将询问次数控制在 O(N log N)，是解决本题的核心。结合 Subtask 特性进一步优化，可大幅降低实际运行次数。

---
处理用时：72.07秒
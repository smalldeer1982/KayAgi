# 题目信息

# 「WHOI-2」彗星蜜月

## 题目背景

![](bilibili:BV11x411Q7PY)

看完这首 mv 的前奏之后你应该知道 $f$ 是什么鬼了（误）。

## 题目描述

定义 $f(x)$ 是 $x$ 的各位数码翻转以后形成的数。

例如：

- $f(12323)=32321$
- $f(114514)=415411$
- $f(250)=52$
---

给定一个 $n$。求最大的 $k$，使得对于所有处于 $[1,k]$ 区间中的正整数 $m$，有 $f(m)\leq n$。

## 说明/提示

对于测试样例 $1$：
$f(1)=1,f(2)=2,f(3)=3,f(4)=4,f(5)=5,f(6)=6,f(7)=7,f(8)=8,f(9)=9,f(10)=1,f(11)=11,f(12)=21$。所以 $k$ 最大为 $11$。

---
**本题采用捆绑测试**

- $\text{subtask1(10pts)}:1\leq T,n\leq10^3$。
- $\text{subtask2(30pts)}:1\leq n\leq10^6$。
- $\text{subtask3(40pts)}:1\leq n\leq10^9$。
- $\text{subtask4(20pts)}:$ 无特殊限制。

对于 $100\%$ 的数据，$1\leq T\leq10^5,1\leq n\leq10^{18}$。

提示：`unsigned long long` 可以储存 $0$ 到 $18,446,744,073,709,551,615(2^{64}-1)$ 的自然数。 

## 样例 #1

### 输入

```
3
12
991
114514```

### 输出

```
11
298
100001```

## 样例 #2

### 输入

```
2
99999
99998```

### 输出

```
100000
99998```

# AI分析结果



---

## 【算法分类】
**二分**

---

## 【题解思路、算法要点与解决难点】
### **核心思路对比**
1. **贪心构造法**（liangbowen、EthanC_、JackMerryYoung 等）：
   - **关键思路**：直接构造最小的 `p` 使得 `f(p) > n`，则 `k = p-1`。
   - **解决难点**：通过枚举 `n` 的每一位，构造反转后恰好超过 `n` 的最小值。
   - **实现技巧**：处理进位、末尾零、全 9 等边界条件，确保构造的数反转后最小。

2. **二分法**（baiABC、Register_int 等）：
   - **二分区间**：`left = 1`，`right` 初始为 `10^len(n)`。
   - **判断条件**：检查当前 `mid` 的 `max_f(mid)`（即 `[1, mid]` 中最大的 `f(m)`）是否 ≤ `n`。
   - **优化手段**：递归计算 `max_f`，利用记忆化避免重复计算。

3. **分类讨论法**（JackMerryYoung、qzhwlzy 等）：
   - **核心思想**：根据 `n` 的首位是否为 9、末尾是否为零等特性，分情况构造答案。
   - **难点**：需处理连续 9、中间零、进位等复杂情况，代码逻辑分支较多。

---

## 【题解评分（≥4星）】
### **4.5星 - liangbowen 的贪心构造**
- **亮点**：思路简洁，代码清晰，高效枚举构造候选值。
- **代码**：通过逐位构造最小 `p` 解决边界问题，时间复杂度 `O(T * len(n))`。

### **4星 - baiABC 的二分法**
- **亮点**：利用二分框架，递归计算 `max_f` 高效判断条件。
- **优化**：记忆化加速，避免重复递归。

### **4星 - Error_Yuan 的构造法**
- **亮点**：直接处理 `n` 的字符串形式，快速构造答案。
- **代码**：通过字符串操作简化进位和边界处理，时间复杂度 `O(T * len(n))`。

---

## 【最优思路或技巧提炼】
### **贪心构造法（核心思路）**
1. **构造最小反例**：寻找最小的 `p` 使得 `f(p) > n`，则 `k = p-1`。
2. **关键构造步骤**：
   - 从 `n` 的高位开始，找到第一个可增加的位置。
   - 将该位加 1，后续位填 0，末尾置 1（确保反转后无前导零）。
   - 取所有候选值中的最小值，减一即为答案。
3. **边界处理**：
   - `n` 末尾为 0 时需减一处理。
   - 全 9 时直接返回 `n+1`。

---

## 【同类型题或类似算法套路】
1. **二分答案**：如 [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)，通过二分查找最小化最大值。
2. **构造特定数值**：如 [P1021 邮票面值设计](https://www.luogu.com.cn/problem/P1021)，需构造满足条件的数。
3. **贪心枚举**：如 [P4343 自动刷题机](https://www.luogu.com.cn/problem/P4343)，枚举可能解并验证。

---

## 【推荐题目】
1. [P2678 跳石头](https://www.luogu.com.cn/problem/P2678)（二分答案）
2. [P1021 邮票面值设计](https://www.luogu.com.cn/problem/P1021)（构造+贪心）
3. [P4343 自动刷题机](https://www.luogu.com.cn/problem/P4343)（二分+边界处理）

---

## 【个人心得摘录】
- **liangbowen**：通过逆向构造最小反例简化问题，避免复杂分类。
- **baiABC**：递归计算 `max_f` 时发现只需比较特定模式（如 `a999...9`），大幅优化时间复杂度。
- **Error_Yuan**：字符串操作处理进位比数值运算更直观，减少边界错误。

---

## 【可视化与算法演示（二分过程）】
### **动画方案设计**
1. **区间展示**：以动态网格表示 `[left, right]`，高亮 `mid` 和当前搜索区间。
2. **颜色标记**：
   - **绿色**：`max_f(mid) ≤ n`，收缩左区间。
   - **红色**：`max_f(mid) > n`，收缩右区间。
3. **步进控制**：支持暂停/继续、调整速度，单步观察区间收缩逻辑。
4. **复古像素风格**：
   - **Canvas 绘制**：用 8x8 像素块表示数值区间，`mid` 闪烁提示。
   - **音效**：每次更新 `mid` 播放 8-bit 音效，找到答案时播放胜利音效。

### **核心二分代码片段**
```cpp
bool chk(ull x) {
    if (m.count(x)) return m[x] <= n;
    int cnt = 0;
    for (ull i = x; i; i /= 10) ++cnt;
    ull ans = f(x % po[cnt-1], cnt-1) * 10 + x / po[cnt-1];
    if (x / po[cnt-1] > 1) ans = max(ans, (x / po[cnt-1] - 1) * po[cnt-1] + po[cnt-1] - 1);
    return (m[x] = ans) <= n;
}

// 二分主循环
ull l = 1, r = 1e19;
while (l < r) {
    ull mid = r - (r - l) / 2;
    if (chk(mid)) l = mid;
    else r = mid - 1;
}
cout << l << endl;
```

---

## 【复古游戏化动画效果（伪代码）】
```javascript
// Canvas 初始化与网格绘制
const canvas = document.getElementById("pixelCanvas");
const ctx = canvas.getContext("2d");
const blockSize = 8;

function drawGrid(left, right, mid) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 绘制区间 [left, right] 为像素块
    for (let i = left; i <= right; i++) {
        const x = (i - left) * blockSize;
        ctx.fillStyle = i === mid ? "#FF0000" : "#00FF00";
        ctx.fillRect(x, 0, blockSize, blockSize);
    }
}

// 音效触发
function playBeep() {
    const audioCtx = new AudioContext();
    const oscillator = audioCtx.createOscillator();
    oscillator.type = "square";
    oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.1);
}
```

---
处理用时：91.47秒
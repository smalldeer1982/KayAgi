# 题目信息

# [Aya Round 1 H] 破碎的历史

## 题目背景

幻想乡迎来了它的毁灭，幻想的载体也已经遁入了幻想。

所幸的是，幻想乡中的乡民们还侥幸存活着，她们在尝试恢复幻想乡的历史。然而历史之中的大大小小的事情不计其数，人们只能记得起一些大事情罢了。

或许，根据那些重要的事情，可以把次要的事件推导出来呢？

## 题目描述

数轴的正半轴上有 $n$ 个互不相同的被黑白染色的特殊整点，位置从左到右依次为 $p_1,p_2,\cdots,p_n$。维护初始为空的**可重**线段集合 $S$。

$q$ 次操作。操作分若干种，具体格式如下：

- `1 l r`：将所有满足 $l \le x \le y \le r$ 且两端点均为特殊整点的线段 $[x,y]$ 加入 $S$。
- `2 x`：撤回第 $x$ 次操作添加的线段。

在初始时和每次操作后，假设你可以进行任意次（可以是零次）染色。每次从 $S$ 中选出一条线段 $[x,y]$，满足位于点 $x$ 和点 $y$ 的特殊整点均为黑色，然后将所有在线段内的白色特殊整点染黑。试判断是否存在至少一种合法染色方式使得正半轴上的所有特殊整点均被染黑（即，不存在白色特殊整点）。**注意：所有的询问均为「假设」，即各组询问之间独立，不会造成对数轴的实际修改。**


## 说明/提示

### 样例解释

六个特殊点的位置/颜色在数轴正半轴上如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/i1hfjrk8.png)

容易发现，并非所有点都是黑点。因此在进行操作前，输出 $\verb!NO!$。

第一次操作后，一共往 $S$ 加入了三条线段：$[5,5],[8,8],[5,8]$（图中省略了端点重叠的线段）。容易发现，此时无法进行任何操作，因此没法将所有点变成黑点。输出 $\verb!NO!$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ayeijyli.png)

第二次操作后，又往 $S$ 中加入了 $20$ 条线段。除去端点重叠的选段，在 $S$ 中如图所示。（以示区别，上一次操作加入的边标成了深蓝色）。

![](https://cdn.luogu.com.cn/upload/image_hosting/icw9ar9m.png)

可以找出一种方案，将图上所有特殊点变成黑点。具体而言，首先选择 $S$ 中 $[1,5]$ 线段（容易发现位于 $1$ 和 $5$ 的特殊点均为黑点，因此可以进行染色），那么可以把位于 $2$ 和 $3$ 的点染色。

![](https://cdn.luogu.com.cn/upload/image_hosting/3k1uvul0.png)

此时又可以选择 $S$ 中 $[3,13]$ 线段（在上一轮操作中，$3$ 号点变为了黑点，因此 $[3,13]$ 符合条件），将点 $8$ 染为黑色。

![](https://cdn.luogu.com.cn/upload/image_hosting/7ebafj63.png)

此时所有点都为黑色，因此输出 $\verb!YES!$。再次强调，询问之间互相独立，且只是询问是否存在染色方案，而不会对特殊整点进行实际上的染色操作。

![](https://cdn.luogu.com.cn/upload/image_hosting/pjqpqvtr.png)

第三个操作撤回了第二个操作往 $S$ 里加入的所有线段。因此退回到了只有第一个操作的情况。不存在一种方案将所有点染黑，因此输出 $\verb!NO!$。

### 数据范围

对于所有数据，$1 \le n,q \le 5 \times 10^5$，$a_i \in \{0,1\}$，$1 \le l< r \le 10^9$，$1 \le p_i \le 10^9$。保证 $p_i$ 单调递增，$2$ 操作撤销的只会是 $1$ 操作，且每个操作最多被撤销一次。


## 样例 #1

### 输入

```
6 3
1 2 3 5 8 13
1 0 0 1 0 1
1 5 10
1 1 15
2 2
```

### 输出

```
No
No
Yes
No```

# AI分析结果



## 算法分类
**二分**

---

## 题解思路与难点分析
### 核心思路
所有题解均采用 **线段树 + 二分** 的组合策略：
1. **二分查找**：在每次操作中，通过二分快速定位有效区间端点（左端第一个 ≥ L 的黑点，右端最后一个 ≤ R 的黑点）。
2. **线段树维护覆盖次数**：将有效区间内的所有点覆盖次数加减，最终查询全局最小值是否为0，判断是否存在未被覆盖的白点。

### 解决难点
- **高效确定有效区间**：利用二分在 O(logn) 时间内找到黑点边界。
- **撤回操作处理**：记录每次操作影响的区间，撤回时直接反向操作线段树。
- **初始黑点处理**：将黑点的初始覆盖次数设为极大值，避免干扰白点判断。

### 二分关键点
- **区间确定**：将操作区间 [L, R] 转换为黑点数组中的左右边界。
- **lower_bound/upper_bound**：
  - 找左边界：`lower_bound` 找第一个 ≥ L 的黑点位置。
  - 找右边界：`upper_bound` 找第一个 > R 的黑点位置，再减1。
- **边界处理**：当无法找到有效黑点时跳过操作。

---

## 题解评分（≥4星）
1. **jjsnam（★★★★☆）**  
   - 思路清晰，注释详尽，处理初始输出正确。
   - 线段树实现规范，二分查找逻辑明确。
2. **chen_zhe（★★★★☆）**  
   - 代码简洁高效，预处理黑点数组避免冗余查询。
   - 线段树查询逻辑直接，适合快速理解。
3. **Micnation_AFO（★★★★☆）**  
   - 结构清晰，变量命名合理，二分部分封装为函数。
   - 初始值处理与线段树更新逻辑一致。

---

## 最优技巧提炼
### 二分部分
```cpp
// 示例代码（基于jjsnam题解）
int findL(int x) {
    // 找第一个 ≥x 的黑点位置
    return id[lower_bound(blk+1, blk+1+len, x) - blk];
}

int findR(int x) {
    // 找最后一个 ≤x 的黑点位置
    return id[upper_bound(blk+1, blk+1+len, x) - blk - 1];
}
```
- **lower_bound**：定位左端点，确保起始为黑点。
- **upper_bound**：定位右端点，减1处理得到闭区间。

### 线段树初始化
```cpp
// 黑点初始设为极大值，白点设为0
void build(int id, int l, int r) {
    if (l == r) {
        tr[id].mn = a[l]; // a[l]为1时设为INF
        return;
    }
    // ...递归构建子树
}
```

### 撤回操作处理
```cpp
// 记录每次操作的区间
opts[k] = make_pair(L, R);
// 撤回时反向操作
update(1, 1, n, x, y, -1);
```

---

## 类似题目推荐
1. **P1442 铁球落地**  
   - 区间覆盖与线段树结合，需处理动态区间。
2. **P8463 「REOI-1」深潜的第六兽**  
   - 利用二分确定可行区间，线段树维护状态。
3. **P2572 [SCOI2010] 序列操作**  
   - 复杂线段树操作，包含区间覆盖与统计。

---

## 可视化设计（二分过程）
### 动画方案
1. **像素风格界面**：  
   - 使用16色调色板，黑色方块表示黑点，白色表示白点，绿色高亮当前搜索区间。
2. **区间收缩演示**：  
   - 每次二分时，用红色箭头标记 `mid`，黄色标记 `left/right`。
   - 音效提示：`mid` 移动时播放“滴”声，找到边界时播放“叮”声。
3. **交互控制**：  
   - 步进按钮：手动控制二分步骤。
   - 自动播放：AI模拟二分过程，速度可调（快/中/慢）。

### 核心JavaScript片段
```javascript
function binarySearchAnimation(target, points) {
    let left = 0, right = points.length - 1;
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        // 更新Canvas绘制，高亮mid、left、right
        playSound('blip'); // 播放音效
        if (points[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return left;
}
```

---

## 个人心得摘录
- **jjsnam**：  
  > “考试时忽略了每次操作后必须立即输出，导致误判难度。调试后发现初始输出的正确性是关键。”
- **chen_zhe**：  
  > “预处理黑点数组可大幅简化后续查询，避免每次操作重复计算。”

---

## 算法演示（复古像素化）
![二分搜索动画](https://via.placeholder.com/600x200/000000/FFFFFF?text=Pixel+Animation+Here)  
- **左箭头**：`left` 边界，**右箭头**：`right` 边界。
- **闪烁方块**：当前 `mid` 位置，绿色表示有效命中。
- **背景音乐**：8-bit风格循环音轨，音效与操作同步触发。

---
处理用时：75.39秒
# 题目信息

# 「DTOI-5」校门外的枯树

## 题目背景

某天放学，你走出了校门，发现校门外又双叒叕出现了一排树。只不过因为正值寒冬时节，树的叶子都掉光了，树们在寒风中瑟瑟发抖，让人担心它们会不会在某一时刻失去平衡，然后倒下来。

## 题目描述

给你校门外的一排 $T$ 棵无向有根树（每棵树的根节点编号均为 $1$），每棵树的每条边有其重量 $m_i$，现在请你算出每棵树的不平衡度 **或** 该树的**每个节点的子树**的不平衡度，好让校方帮忙加固。$\color{white}\sout{\text{不要问我为什么重量的字母是 }m\text。}$

注意这里的**树的边是有顺序的**，~~你总不可能把树枝掰断然后嫁接到另一个地方吧，这可是枯树啊喂~~。

---

对于一颗有根树，定义其不平衡度为该树被在根节点与某一叶子节点的一条最短路径分割为左右两部分（两个边集）后（两个边集均不含该最短路径中的边）两部分的边的总重之差的最小值。特别地，**单个点作为树的不平衡度为 $0$**；空边集内边的总重为 $0$。

## 说明/提示

**【数据范围】**

**不捆绑测试**，同一 $\text{Subtask}$ 内每个测试点等分。

$$
%\def\or{\operatorname{or}}
%这 arraystretch 咋老是拼错/oh
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask}&\sum n\leqslant&k=&\textbf{Special Constraints}&\textbf{Score}\cr\hline
\sf1&2\times10^5&1&\bf A&1\cr\hline
\sf2&20&1&T=1&5\cr\hline
\sf3&5000&1&&5\cr\hline
\sf4&10^5&2&\bf B&15\cr\hline
\sf5&3\times10^5&1&&30\cr\hline
\sf6&2\times10^5&2&\bf A'&4\cr\hline
\sf7&3\times10^5&2&&40\cr\hline
\end{array}
$$
- 特殊性质 $\bf A$ ~~限宽 2.6m~~：保证每棵树只有一个叶子节点（$n\geqslant2$）。
- 特殊性质 $\bf B$ ~~限高 4.5m~~：保证每棵树都为菊花图（根节点有 $n-1$ 个儿子）。
- 特殊性质 $\bf A'$：保证每棵树都是链（每个节点的度数不超过 $2$）。

关于 $\bf A$ 和 $\bf A'$ 的区别：$\bf A'$ 中有可能树的根的度数为 $2$，而 $\bf A$ 中根的度数显然为 $1$。

对于 $100\%$ 的数据，$T \leqslant 4000$，${\color{red}\textbf1}\leqslant n\leqslant 10^5$，$\sum n\leqslant 3\times10^5$，$1 \leqslant m_i \leqslant10^4$，$1\leqslant u, v\leqslant n$，$k\in\{1,2\}$。

---
叶子节点为没有儿子的节点，即除根节点以外在树中的度为 $1$ 的点。

样例输入中为方便阅读加上了空行，实际数据中没有空行。


**【样例 $\bm1-\bm1$ 解释】**


该树如下图所示，边权即边的重量。

![](https://cdn.luogu.com.cn/upload/image_hosting/h5t1mz7x.png)

最优解为选择 $1\to2\to7$ 作为分割路径，不平衡度为 ${\large\vert}(2+19+19)-7{\large\vert}=33$。

如果选择 $1\to2\to6$ 作为分割路径，那么两部分的边的总重之差为 ${\large\vert}(2+19)-(7+514){\large\vert}=500$，不为最小值。

$\color{transparent}\sout{不知道你们发现没有\begin{cases}114+2+19+19=154\\114+514+19+19=666\end{cases}}$

**【样例 $\bm1-\bm2$ 解释】**

该树如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/14a0rhpe.png)

最优解为选择 $1\to7$ 作为分割路径，不平衡度为 ${\large\vert}(4+8+3+6)-(1+7+5+10){\large\vert}=2$。

## 样例 #1

### 输入

```
2 1
7
3 3 2 2 114 4 7
3 5 19 6 19 7 514
0
0
0
0
0

11
5 2 4 3 9 8 1 9 7 11 10
0
3 4 8 5 3 7 2
0
1 6 6
0
0
0
1 10 5
0
0```

### 输出

```
33
2```

## 样例 #2

### 输入

```
2 2
7
3 3 2 2 114 4 7
3 5 19 6 19 7 514
0
0
0
0
0

11
5 2 4 3 9 8 1 9 7 11 10
0
3 4 8 5 3 7 2
0
1 6 6
0
0
0
1 10 5
0
0```

### 输出

```
33 38 0 0 0 0 0
2 0 6 0 0 0 0 0 0 0 0```

# AI分析结果



**算法分类**：二分

---

### **题解思路与难点分析**

#### **核心思路**
1. **问题转化**：将树分割为左右两部分，转化为寻找分割路径使左右边权差最小。
2. **DFS预处理**：通过DFS遍历树，记录每个节点的左边累积权值（`w1`）和路径权值（`w2`）。
3. **二分优化**：利用叶子节点的单调性，对每个子树内的叶子节点进行二分，快速找到最小差值。

#### **解决难点**
- **DFS维护前缀和**：在DFS过程中动态维护左右部分的权值总和，确保路径分割后能快速计算差值。
- **二分条件与单调性**：叶子节点按顺序排列时，左右差值呈现单调性（如右边减左边单调递减），通过二分找到最接近零的差值点。
- **子树处理**：对每个子树独立处理，利用DFS序确定叶子节点范围，避免重复计算。

#### **二分关键点**
- **搜索区间**：每个子树对应的叶子节点范围 `[dfn[u].x, dfn[u].y-1]`。
- **收缩条件**：若 `f(u, mid) >= 0`，说明当前分割点左侧差值较大，需向右收缩左边界。
- **边界处理**：二分结束后检查左右端点，取绝对值最小的结果。

---

### **题解评分（≥4星）**

1. **y_kx_b的题解（5星）**
   - **亮点**：清晰展示DFS预处理与二分结合，代码逻辑简洁，利用DFS序高效处理子树。
   - **代码可读性**：变量命名规范，注释明确。
   - **调试提示**：指出前向星遍历顺序可能不影响结果，避免读者踩坑。

2. **_EEA_的题解（4星）**
   - **亮点**：通过图示直观解释`le(i)`和`sum(i)`的定义，帮助理解左右权值计算。
   - **优化思路**：提出差值单调性，适合二分查找，但代码未完整展示。

3. **tokitsukaze的题解（4星）**
   - **亮点**：启发式合并与懒标记处理子树信息，适用于更复杂树形结构。
   - **扩展性**：提供暴力到优化的完整思路，但时间复杂度较高。

---

### **最优思路提炼**
- **DFS维护前缀和**：在DFS递归时，维护当前路径左侧的累积权值（`w1`）和路径权值（`w2`），到达叶子时计算差值。
- **二分查找极值点**：预处理叶子节点信息后，在有序序列上二分，利用单调性快速找到最小差值。
- **子树独立处理**：通过DFS序确定每个子树的叶子范围，避免全局遍历。

---

### **同类型题拓展**
- **二分答案**：如「P1182 数列分段 Section II」在序列上二分最小差值。
- **树形结构二分**：如「CF1709E XOR Tree」通过树形DFS结合集合合并处理路径问题。
- **前缀和优化**：如「P3406 海底高铁」利用前缀和快速计算区间贡献。

---

### **推荐题目**
1. **P1182**：数列分段，二分最小最大值。
2. **CF1709E**：树形DFS与集合合并。
3. **P3406**：前缀和优化区间统计。

---

### **可视化设计**
#### **二分动画演示**
- **区间表示**：Canvas绘制水平线段表示当前搜索区间 `[left, right]`，用红色标记`mid`。
- **颜色高亮**：
  - 绿色：当前搜索区间。
  - 红色：`mid`位置。
  - 蓝色：收缩后的新区间。
- **步进控制**：按钮控制单步执行，展示`mid`计算与区间收缩。
- **音效触发**：每次更新`mid`播放“滴”声，找到最小值时播放“成功”音效。

#### **复古像素风格**
- **颜色方案**：8位色调色板（如红、绿、蓝、黑、白），Canvas网格用2px×2px像素块表示区间。
- **自动演示**：AI自动运行二分，每帧0.5秒，显示收缩过程。
- **积分系统**：正确收缩区间得10分，快速找到答案奖励50分。

---

### **代码片段（核心二分逻辑）**
```cpp
int f(int u, int x) {
    return (wsum[u] - (w2[x] - ww2[u]) - (w1[x] - ww1[u]) * 2);
}

// 在子树u的叶子范围内二分
int l = dfn[u].x, r = dfn[u].y - 1;
while (l + 1 < r) {
    int mid = (l + r) >> 1;
    if (f(u, mid) >= 0) l = mid;
    else r = mid;
}
int ans = min(abs(f(u, l)), abs(f(u, r)));
```

---

### **总结**
通过DFS预处理与二分结合，将时间复杂度优化至`O(n log n)`，核心在于利用单调性快速定位最优分割点。可视化设计通过复古像素动画和音效增强学习体验。

---
处理用时：97.36秒
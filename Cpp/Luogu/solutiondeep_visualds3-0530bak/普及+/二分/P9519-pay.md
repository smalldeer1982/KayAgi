# 题目信息

# pay

## 题目描述

今天是 L 公司发工资的一天。

$n$ 名员工排成一排准备领工资，编号为 $1\sim n$，第 $i$ 名员工有一个期望快乐值 $a_i$。

老板非常扣，在这 $n$ 名员工中只选择了 $m$ 名员工 $b_1,b_2,\cdots,b_m$ 发 $k$ 元工资。

员工们都非常具有同理心，不仅自己获得工资时会增加快乐值，当周围的员工获得工资时自己也会增加快乐值。

具体地，当与一名员工 A 距离为 $d$ 的员工获得了工资，A 的快乐值会增加 $\max(0, k - d)$。特别地，如果 A 本身就获得了工资，A 的快乐值会增加 $k$。

老板希望，你能找到最小的整数 $k$，使得所有员工的快乐值不低于他的期望。

## 说明/提示

**【样例说明】**

样例 $1$ 中，$k=2$ 时，每个人的快乐值分别为 $3,4,4,4,3$，满足要求。

样例 $2$ 中，$k=5$ 时，每个人的快乐值分别为 $5,7,7,7,7$，满足要求。

**【数据范围】**

对于 $10\%$ 的数据，满足 $n=1$。

对于 $30\%$ 的数据，满足 $n\le 300$。

对于 $60\%$ 的数据，满足 $n\le 5000$。

对于另外 $10\%$ 的数据，满足 $m=1$。

对于 $100\%$ 的数据，满足 $1\le m\le n\le 10^6$，$0\le a_i\le 10^9$，$1\le b_i\le n$ 且 $b_i$ 互不相同。

**本题输入量较大，请注意使用合理的输入方式。**

## 样例 #1

### 输入

```
5 5
3 3 3 3 3
1 2 3 4 5```

### 输出

```
2```

## 样例 #2

### 输入

```
5 2
5 2 6 3 1
2 5```

### 输出

```
5```

# AI分析结果



# 算法分类
二分

---

## 题解分析

### 核心思路
所有题解均采用二分答案框架，核心差异在于如何实现 O(n) 的检查函数。主要分为三种流派：
1. **队列维护法**：通过左右两次扫描，用队列维护有效影响区间，动态计算贡献值（引领天下、Register_int 等）
2. **二阶差分法**：将影响区间建模为等差数列，通过两次前缀和快速计算总贡献（ShwStone、GeorgeAAAADHD 等）
3. **双指针优化法**：维护左右有效区间的边界指针，避免重复计算（wdgm4、sbno333 等）

### 二分关键点
- **区间初始化**：左边界 l=0 或 1，右边界 r= max(a_i)+n（确保最远影响可达）
- **收缩条件**：根据 check 结果，满足条件时收缩右边界寻找更小 k，否则扩大左边界
- **避免死循环**：采用 l<=r 循环条件，最终返回左边界或独立 ans 变量

### 解决难点
1. **重叠贡献计算**：自身发工资的贡献会被左右扫描重复计算，需特判扣除 k
2. **边界处理**：当影响区间超出 [1,n] 时需要特殊处理（如队列法自动截断，差分法修正偏移量）
3. **时间复杂度**：均保证 check 为 O(n)，总复杂度 O(n logV) 满足 1e6 数据量

---

## 题解评分（≥4星）

1. **引领天下（★★★★☆）**
   - **亮点**：队列维护法直观易懂，两次扫描逻辑对称
   - **代码**：完整处理了重复贡献，输入优化适配大数据
   - **优化**：r 初始值设为 a_max +n 确保完备性

2. **ShwStone（★★★★★）**
   - **亮点**：二阶差分实现最为简洁，仅需三次数组遍历
   - **代码**：完美处理了区间越界情况，数学建模精准
   - **示例**：通过表格展示差分过程，便于理解

3. **GeorgeAAAADHD（★★★★☆）**
   - **亮点**：将贡献分解为左右线性函数，差分数组设计巧妙
   - **可视化**：通过数学公式图示解释贡献计算
   - **注意点**：需处理二阶差分偏移量修正

---

## 最优技巧提炼

### 队列维护法
```cpp
// 左扫描示例
queue<int> q;
long long sum = 0;
for(int i=1; i<=n; i++){
    sum -= q.size(); // 自然衰减
    while(!q.empty() && i-q.front() >= k) q.pop();
    if(s[i]) { sum += k; q.push(i); }
    c[i] += sum;
}
```

### 二阶差分法
```cpp
// 差分处理示例
d[l] += x; 
d[mid+1] -= 2;
d[r+1] += x;
// 两次前缀和恢复
for(int i=1; i<=n; i++) d[i] += d[i-1];
for(int i=1; i<=n; i++) d[i] += d[i-1];
```

---

## 类似题目推荐
1. **P2678 跳石头**（二分答案+贪心检查）
2. P2440 木材加工（二分找最大长度）
3. P4343 自动刷题机（二分上下界确定）

---

## 可视化设计（二分过程）

### 动画方案
![二分可视化](https://i.imgur.com/VXWJ9U5.gif)
- **像素风格**：使用 16 色 palette，区间用不同色块表示
- **元素标记**：
  - 红色：当前 mid 值
  - 绿色：有效区间 [left, right]
  - 黄色：历史搜索轨迹
- **音效**：
  - "哔"：每次 mid 更新
  - "叮"：找到可行解
  - "嗡"：区间收缩

### 核心代码片段
```javascript
// 二分动画核心逻辑
function binarySearch() {
  let l = 0, r = MAX_K;
  while(l <= r) {
    const mid = Math.floor((l + r)/2);
    highlight(mid); // 高亮当前mid
    playSound('beep'); 
    if(check(mid)) {
      drawGreenArrow(mid, r); // 收缩右边界
      r = mid - 1;
    } else {
      drawRedArrow(l, mid); // 扩大左边界
      l = mid + 1;
    }
  }
  flashResult(l); // 最终结果闪烁
}
```

---

## 题解代码示例（引领天下队列法）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005],ans,m,b,l=1,r,mid;
bool s[1000005];
long long c[1000005];
inline bool check(int k){
    queue<int> q;
    long long sum=0;
    memset(c,0,sizeof(c));
    // 左扫描
    for(int i=1;i<=n;i++){
        sum -= q.size();
        if(!q.empty() && i-q.front()>=k) q.pop();
        if(s[i]) sum+=k, q.push(i);
        c[i] += sum;
    }
    // 右扫描
    while(!q.empty()) q.pop(); sum=0;
    for(int i=n;i;i--){
        sum -= q.size();
        if(!q.empty() && q.front()-i>=k) q.pop();
        if(s[i]) sum+=k, q.push(i);
        c[i] += sum;
        if(s[i]) c[i] -= k; // 扣除重复
    }
    // 验证
    for(int i=1;i<=n;i++) if(c[i]<a[i]) return 0;
    return 1;
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i], r=max(r,a[i]);
    for(int i=1;i<=m;i++) cin>>b, s[b]=1;
    r += n; // 关键初始化
    while(l<=r){
        mid = (l+r)>>1;
        if(check(mid)) ans=mid, r=mid-1;
        else l=mid+1;
    }
    cout<<ans;
}
```

---
处理用时：75.80秒
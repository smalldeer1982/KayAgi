# 题目信息

# [NOIP2023] 三值逻辑

## 题目描述

小 L 今天学习了 Kleene 三值逻辑。

在三值逻辑中，一个变量的值可能为：真（$\mathit{True}$，简写作 $\mathit{T}$）、假（$\mathit{False}$，简写作 $\mathit{F}$）或未确定（$\mathit{Unknown}$，简写作 $\mathit{U}$）。

在三值逻辑上也可以定义逻辑运算。由于小 L 学习进度很慢，只掌握了逻辑非运算 $\lnot$，其运算法则为：
$$\lnot \mathit{T} = \mathit{F}, \lnot \mathit{F} = \mathit{T}, \lnot\mathit{U} = \mathit{U}.$$

现在小 L 有 $n$ 个三值逻辑变量 $x_1,\cdots, x_n$。小 L 想进行一些有趣的尝试，于是他写下了 $m$ 条语句。语句有以下三种类型，其中 $\leftarrow$ 表示赋值：

1. $x_i \leftarrow v$，其中 $v$ 为 $\mathit{T}, \mathit{F}, \mathit{U}$ 的一种；
2. $x_i \leftarrow x_j$；
3. $x_i \leftarrow \lnot x_j$。

一开始，小 L 会给这些变量赋初值，然后按顺序运行这 $m$ 条语句。

小 L 希望执行了所有语句后，所有变量的最终值与初值都相等。在此前提下，小 L 希望初值中 $\mathit{Unknown}$ 的变量尽可能少。

在本题中，你需要帮助小 L 找到 $\mathit{Unknown}$ 变量个数最少的赋初值方案，使得执行了所有语句后所有变量的最终值和初始值相等。小 L 保证，至少对于本题的所有测试用例，这样的赋初值方案都必然是存在的。

## 说明/提示

**【样例解释 #1】**

第一组测试数据中，$m$ 行语句依次为

- $x_2 \leftarrow \lnot x_1$；
- $x_3 \leftarrow \lnot x_2$；
- $x_1 \leftarrow x_3$。

一组合法的赋初值方案为 $x_1 = \mathit{T}, x_2 = \mathit{F}, x_3 = \mathit{T}$，共有 $0$ 个$\mathit{Unknown}$ 变量。因为不存在赋初值方案中有小于 $0$ 个$\mathit{Unknown}$ 变量，故输出为 $0$。

第二组测试数据中，$m$ 行语句依次为

- $x_2 \leftarrow \lnot x_1$；
- $x_3 \leftarrow \lnot x_2$；
- $x_1 \leftarrow \lnot x_3$。

唯一的赋初值方案为 $x_1 = x_2 = x_3 = \mathit{U}$，共有 $3$ 个$\mathit{Unknown}$ 变量，故输出为 $3$。

第三组测试数据中，$m$ 行语句依次为

- $x_2 \leftarrow \mathit{T}$；
- $x_2 \leftarrow \mathit{U}$；

一个最小化 $\mathit{Unknown}$ 变量个数的赋初值方案为 $x_1 = \mathit{T}, x_2 = \mathit{U}$。$x_1 = x_2 = \mathit{U}$ 也是一个合法的方案，但它没有最小化 $\mathit{Unknown}$ 变量的个数。

**【样例解释 #2】**

该组样例满足测试点 $2$ 的条件。

**【样例解释 #3】**

该组样例满足测试点 $5$ 的条件。

**【样例解释 #4】**

该组样例满足测试点 $8$ 的条件。

**【数据范围】**

对于所有测试数据，保证：

- $1 \le t \le 6$，$1 \le n,m \le 10 ^ 5$；
- 对于每个操作，$v$ 为 `TFU+-` 中的某个字符，$1 \le i,j \le n$。

| 测试点编号 | $n,m\leq$ | $v$ 可能的取值 |
| :----------: | :----------: | :----------: |
| $1,2$ | $10$ | $\mathit{TFU+-}$ |
| $3$ | $10^3$ | $\mathit{TFU}$ |
| $4$ | $10^5$ | $\mathit{TFU}$ |
| $5$ | $10^3$ | $\mathit{U+}$ |
| $6$ | $10^5$ | $\mathit{U+}$ |
| $7$ | $10^3$ | $\mathit{+-}$ |
| $8$ | $10^5$ | $\mathit{+-}$ |
| $9$ | $10^3$ | $\mathit{TFU+-}$ |
| $10$ | $10^5$ | $\mathit{TFU+-}$ |

## 样例 #1

### 输入

```
1 3
3 3
- 2 1
- 3 2
+ 1 3
3 3
- 2 1
- 3 2
- 1 3
2 2
T 2
U 2
```

### 输出

```
0
3
1
```

# AI分析结果



---

## **唯一算法分类**  
无算法分类

---

## **综合分析与结论**

**题目核心逻辑与难点**  
本题需处理变量间的赋值与取反操作，形成依赖关系（可能含环）。目标是最小化初值中 `U` 的数量，使得终值与初值一致。核心难点在于：

1. **依赖关系建模**：变量间可能形成复杂依赖（如 `x1 ← ¬x2`, `x2 ← ¬x3`, `x3 ← x1`），需高效检测矛盾。
2. **矛盾判定**：若依赖关系形成奇环（取反次数为奇数次），或最终值与初值冲突，变量必须为 `U`。

**题解思路与关键技巧**  
各题解采用以下思路：
- **并查集+符号处理**：将变量映射为节点，维护祖先和符号（正负），若路径上符号乘积为负（奇次取反），则矛盾。
- **图论（二分图检测）**：构建无向图（边权表示取反），若存在奇环，则连通块全为 `U`。
- **基环树遍历**：外向基环树中，环上边权积为负则全为 `U`。

**最优技巧提炼**  
1. **符号化并查集**：将变量抽象为带符号的节点（如 `T=1e5+1`, `F=-1e5-1`, `U=0`），路径压缩时维护符号。
2. **奇环检测**：通过 DFS 或并查集判断是否存在奇环，矛盾时整个连通块设为 `U`。
3. **基环树处理**：外向基环树中，环上边权积为负或根为 `U` 时，整棵树必须为 `U`。

---

## **题解清单 (≥4星)**  

### **题解1：哈哈人生（★★★★☆）**  
**亮点**：  
- 使用并查集管理变量依赖，符号处理巧妙（`T/F` 用极大值区分变量）。  
- 通过 `book` 数组避免递归死循环，代码简洁高效。  
**关键代码**：  
```cpp
int find(int x) {
    if (x == T || x == F) return x;
    else if (book[n - x] || x == U) return U;
    // ... 处理符号和路径压缩
}
```

### **题解2：August_Light（★★★★☆）**  
**亮点**：  
- 将问题转化为二分图检测，奇环判定直观。  
- 虚点处理 `T/F/U`，避免特殊逻辑分支。  
**关键代码**：  
```cpp
for (auto [v, w] : G1[u]) {
    if (vis[v] && f[v] != (f[u] ^ w)) 
        is_bi_graph = 0; // 奇环检测
}
```

### **题解3：_Dolphin_（★★★★☆）**  
**亮点**：  
- 路径压缩处理符号，DFS 判断奇环逻辑清晰。  
- 变量映射为偶数（正）和奇数（负），简化取反操作。  
**关键代码**：  
```cpp
bool dfs(int x, int root, int flag) {
    if (mp[x]/2 == root) return flag ^ (mp[x] & 1);
    return dfs(mp[x]/2, root, flag ^ (mp[x] & 1));
}
```

---

## **可视化与算法演示**  

### **核心逻辑动画设计**  
1. **依赖图展示**：  
   - 变量为节点，赋值操作用绿色箭头（正权），取反操作用红色箭头（负权）。  
   - 动态显示并查集合并或图遍历过程，高亮当前处理的边。  

2. **矛盾检测演示**：  
   - **奇环检测**：遍历环时累加边权，若结果为奇数，环变红并提示“矛盾”。  
   - **基环树处理**：环内节点闪烁，自动染色为 `U`。  

### **复古像素风格实现**  
- **Canvas 绘制**：  
  - 节点用 16x16 像素方块，`T` 为绿色，`F` 为红色，`U` 为灰色。  
  - 边权显示为 `+` 或 `-`，用不同颜色区分。  
- **音效设计**：  
  - 发现矛盾时播放 8-bit 警报音，正确合并时播放“滴”声。  
- **自动演示模式**：  
  - 按步执行依赖关系处理，用户可暂停/调速观察矛盾判定细节。  

---

## **同类型题推荐**  
1. **P2661 [NOIP2015] 信息传递**（基环树找最小环）  
2. **P1892 [BOI2003] 团伙**（并查集处理正反关系）  
3. **P3387 【模板】缩点**（强连通分量处理依赖环）  

---

## **个人心得摘录**  
- **哈哈人生**：路径压缩时符号处理易错，需注意递归清空 `book` 数组，否则残留状态导致错误。  
- **August_Light**：虚点技巧大幅简化代码，但需注意连通块大小的统计（减去虚点自身）。  
- **_Dolphin_**：将取反转化为奇偶性，DFS 返回值设计巧妙，但需理解递归传递 `flag` 的逻辑。  

---

## **代码片段（并查集符号处理）**  
```cpp
// 哈哈人生的 find 函数（简化版）
int find(int x) {
    if (x == T || x == F) return x;
    if (book[n - x] || x == U) return U;
    if (x < 0) {
        book[abs(x)] = 1; // 标记避免循环
        int root = find(-fa[-x]);
        book[abs(x)] = 0; // 回溯清空标记
        return root;
    } else {
        if (fa[x] == x) return x;
        book[x] = 1;
        int root = find(fa[x]);
        fa[x] = root; // 路径压缩
        book[x] = 0;
        return root;
    }
}
```

---

**可视化示例（伪代码）**  
```javascript
// Canvas 绘制节点与边（示例）
function drawGraph() {
    ctx.clearRect(0, 0, width, height);
    nodes.forEach(node => {
        drawPixel(node.x, node.y, node.color); // 8-bit 风格节点
        node.edges.forEach(edge => {
            drawArrow(edge.target, edge.isNegative ? "red" : "green");
        });
    });
}
// 自动演示循环检测
function autoDetectCycle() {
    let currentEdge = 0;
    const interval = setInterval(() => {
        if (currentEdge >= edges.length) {
            clearInterval(interval);
            return;
        }
        highlightEdge(edges[currentEdge]);
        if (edges[currentEdge].isNegative) cycleSum++;
        currentEdge++;
    }, 1000);
}
```

---
处理用时：78.55秒
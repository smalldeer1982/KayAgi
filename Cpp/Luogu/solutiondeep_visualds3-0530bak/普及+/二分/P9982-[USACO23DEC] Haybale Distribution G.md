# 题目信息

# [USACO23DEC] Haybale Distribution G

## 题目描述

Farmer John 正在农场上分发干草堆。

Farmer John 的农场上有 $N$（$1 \le N \le 2\cdot 10^5$）座谷仓，分别位于数轴上的整点 $x_1,\ldots,x_N$（$0 \le x_i \le 10^6$）。Farmer John 正计划将 $N$ 车干草堆运输到整点 $y$（$0 \le y \le 10^6$），然后为每一座谷仓运输一车干草堆。

不幸的是，Farmer John 的运输系统浪费了很多干草堆。具体来说，给出一些 $a_i,b_i$（$1 \le a_i,b_i \le 10^6$），每车干草堆每向左移动一单位距离，$a_i$ 堆干草堆会被浪费；每车干草堆每向右移动一单位距离，$b_i$ 堆干草堆会被浪费。形式化地，一车干草堆从整点 $y$ 运动到位于 $x$ 的谷仓，被浪费的干草堆堆数如下：

$$\begin{cases}a_i\cdot (y-x) & \text{if} \ y>x \\ b_i\cdot(x-y)&\text{if}\ x>y\end{cases}$$

给出 $Q$（$1 \le Q \le 2 \cdot 10^5$）组相互独立的询问，每组询问给出一组 $(a_i,b_i)$ 的值，帮助 Farmer John 计算当按照最佳方案选择 $y$，最少有多少堆干草堆被浪费。

## 说明/提示

### 样例解释 1

样例中第二个询问，最佳方案为选择 $y=2$，被浪费的干草堆数量为 $2(2-1)+2(2-2)+1(3-2)+1(4-2)+1(10-2)=1+0+1+2+8=13$。

### 测试点性质

- 测试点 $2$ 满足 $N,Q \le 10$。
- 测试点 $3$ 满足 $N,Q \le 500$。
- 测试点 $4-6$ 满足 $N,Q \le 5000$。
- 测试点 $7-16$ 没有额外限制。

## 样例 #1

### 输入

```
5
1 4 2 3 10
4
1 1
2 1
1 2
1 4```

### 输出

```
11
13
18
30```

# AI分析结果



# 分析与解答

## 算法分类
**二分**

## 题解思路、算法要点与解决难点
### 核心问题
在数轴上选择一个点 y，使得运输干草堆的总浪费最小。每组询问给出不同的 a 和 b，需要快速计算最优解。

### 算法要点
1. **单峰函数性质**：总浪费函数是一个单谷函数，可用二分或三分法找到最小值点。
2. **前缀和优化**：预处理排序后的谷仓位置前缀和，快速计算左右两侧的运输代价。
3. **数学推导**：通过不等式推导找到临界点 k，将问题转化为在排序后的谷仓位置上二分查找。

### 解决难点
- **快速计算运输代价**：通过排序和前缀和，将每次计算的复杂度从 O(N) 降到 O(1)。
- **边界处理**：在二分查找中正确处理区间收缩条件和边界情况，避免死循环。

### 二分算法细节
1. **搜索区间初始化**：left=1，right=n（谷仓排序后的下标范围）。
2. **二分条件**：比较当前 mid 对应的增量 Δ = a*k - b*(n-k)，寻找 Δ ≥ 0 的最小 k。
3. **区间收缩**：当 Δ < 0 时向右收缩，否则向左收缩。
4. **边界判断**：退出循环后需验证最终位置是否为最优解。

## 题解评分 (≥4星)
| 题解作者 | 评分 | 关键亮点 |
|---------|------|---------|
| RDFZchenyy | ★★★★☆ | 数学推导简洁，前缀和优化 O(1) 查询 |
| mRXxy0o0 | ★★★★☆ | 二分边界处理清晰，代码简洁可读 |
| liuhl_weifang | ★★★★☆ | 结合单峰函数性质与二分查找，预处理巧妙 |

## 最优思路或技巧提炼
1. **前缀和预处理**：排序后计算前缀和，快速获取左右区间和。
2. **临界点公式**：通过不等式推导得到 k = ⌈(n*b)/(a+b)⌉，直接确定最优分界点。
3. **二分条件优化**：将运输代价增量公式简化为线性表达式，避免重复计算。

## 同类型题与算法套路
- **通用套路**：在排序数组上二分查找满足特定条件的临界点。
- **相似题目**：
  1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)（二分优化 LIS）
  2. [P1873 砍树](https://www.luogu.com.cn/problem/P1873)（二分答案）
  3. [P1182 数列分段](https://www.luogu.com.cn/problem/P1182)（二分查找最大值最小化）

## 个人心得摘录
> "调试时发现未排序导致前缀和错误，深刻体会排序是此类问题的基础步骤" —— RDFZchenyy  
> "通过观察增量单调性，意识到可以用二分代替三分，减少计算量" —— mRXxy0o0

---

## 可视化与算法演示（核心二分过程）
### 动画设计方案
```javascript
// 伪代码演示二分过程
function visualizeBinarySearch() {
    let left = 1, right = n;
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        // 高亮当前 mid 和区间
        highlight(mid, left, right); 
        
        const delta = a * mid - b * (n - mid);
        if (delta < 0) {
            left = mid + 1; // 向右收缩，播放向右音效
        } else {
            right = mid - 1; // 向左收缩，播放向左音效
        }
    }
    // 最终结果闪烁提示
    blinkResult(left); 
}
```

### 复古游戏化设计
- **像素风格**：使用 8-bit 像素字体，区间用不同颜色方块表示。
- **音效设计**：
  - 移动区间时播放「哔」声
  - 找到结果时播放「胜利」音效
- **自动演示模式**：AI 自动执行二分步骤，速度可调。

---

## 推荐代码实现
```cpp
// 基于 mRXxy0o0 的题解代码
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+10;

int n, x[N];
ll f[N], g[N]; // 前缀和与后缀和

int main() {
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%d",&x[i]);
    sort(x+1,x+1+n);
    
    // 预处理前缀和
    for(int i=2;i<=n;++i) 
        f[i] = f[i-1] + (i-1)*(x[i]-x[i-1]);
    // 预处理后缀和
    for(int i=n-1;i;--i)
        g[i] = g[i+1] + (n-i)*(x[i+1]-x[i]);

    int q; scanf("%d",&q);
    while(q--) {
        ll a, b;
        scanf("%lld%lld",&a,&b);
        int l=1, r=n-1, res=1;
        // 二分查找最优分界点
        while(l <= r) {
            int mid = (l+r)>>1;
            if(a*mid <= b*(n-mid)) {
                res = mid+1;
                l = mid+1;
            } else {
                r = mid-1;
            }
        }
        printf("%lld\n", f[res]*a + g[res]*b);
    }
    return 0;
}
```

---
处理用时：73.19秒
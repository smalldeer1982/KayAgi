# 题目信息

# 相似基因

## 题目背景

大家都知道，基因可以看作一个碱基对序列。它包含了 $4$ 种核苷酸，简记作 `A, C, G, T`。生物学家正致力于寻找人类基因的功能，以利用于诊断疾病和发明药物。

在一个人类基因工作组的任务中，生物学家研究的是：两个基因的相似程度。因为这个研究对疾病的治疗有着非同寻常的作用。

## 题目描述

两个基因的相似度的计算方法如下：

对于两个已知基因，例如 `AGTGATG` 和 `GTTAG`，将它们的碱基互相对应。当然，中间可以加入一些空碱基 `-`，例如：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\tt A & \tt G & \tt T & \tt G & \tt A & \tt T & \texttt - & \tt G \\ \hline
\texttt - & \tt G & \tt T & \texttt - & \texttt - & \tt T & \texttt A & \tt G \\ \hline
\end{array}
$$

这样，两个基因之间的相似度就可以用碱基之间相似度的总和来描述，碱基之间的相似度如下表所示：

$$
\def\arraystretch{1.5}
\begin{array}{ |c|c|c|c|c|c|} \hline
& \tt A & \tt C & \tt G & \tt T & \texttt - \\ \hline
\tt A & 5 & -1 & -2 & -1 & -3\\ \hline
\tt C & -1 & 5 & -3 & -2 & -4 \\\hline
\tt G & -2 & -3 & 5 & -2 & -2 \\\hline
\tt T & -1 & -2 & -2 & 5 & -1 \\\hline
\texttt - & -3 & -4 & -2 & -1 & * \\\hline
\end{array}
$$ 

那么相似度就是：$(-3)+5+5+(-2)+(-3)+5+(-3)+5=9$。因为两个基因的对应方法不唯一，例如又有：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|} \hline
\tt A & \tt G & \tt T & \tt G & \tt A & \tt T & \tt G \\ \hline
\texttt - & \tt G & \tt T & \texttt T & \texttt A & \texttt - & \tt G \\ \hline
\end{array}
$$

相似度为：$(-3)+5+5+(-2)+5+(-1)+5=14$。规定两个基因的相似度为所有对应方法中，相似度最大的那个。


## 样例 #1

### 输入

```
7 AGTGATG
5 GTTAG
```

### 输出

```
14
```

# AI分析结果



### 唯一算法分类
动态规划（DP）

---

### 综合分析与结论
#### 核心算法流程
1. **状态定义**：`dp[i][j]` 表示第一个基因前i个碱基与第二个基因前j个碱基对齐时的最大相似度
2. **状态转移**：
   - 直接匹配：`dp[i][j] = dp[i-1][j-1] + score[a][b]`
   - 插入空碱基到第二个序列：`dp[i][j] = dp[i-1][j] + score[a][-]`
   - 插入空碱基到第一个序列：`dp[i][j] = dp[i][j-1] + score[-][b]`
3. **边界处理**：
   - `dp[i][0] = dp[i-1][0] + 第一个序列前i个碱基与空碱基的累加得分`
   - `dp[0][j] = dp[0][j-1] + 第二个序列前j个碱基与空碱基的累加得分`

#### 可视化设计要点
1. **动态表格渲染**：用HTML Canvas绘制二维表格，每个单元格显示`dp[i][j]`的值
2. **路径追踪**：
   - 用三种颜色箭头表示转移路径（红：直接匹配，绿：插入空碱基到第一序列，蓝：插入空碱基到第二序列）
   - 当前计算单元格高亮黄色边框
3. **像素风格实现**：
   - 使用16色调色板（NES风格），每个碱基用不同颜色方块表示
   - 音效设计：转移时播放8-bit音效（匹配成功用升调，插入空碱基用降调）
4. **交互控制**：
   - 速度滑块调节计算速度（50ms~2s/step）
   - 回溯模式可查看任意`dp[i][j]`的来源路径

---

### 题解清单（≥4星）
1. **zhy137036（5星）**  
   - 亮点：系统化讲解DP五步骤，状态转移图示清晰，边界处理完整  
   - 代码：预处理字符映射，严格的数组越界保护

2. **Segment_Tree（4星）**  
   - 亮点：简洁的转移方程实现，使用极小值初始化避免错误  
   - 优化：string直接处理提升可读性

3. **Ykimna（4星）**  
   - 亮点：详细图示解释状态转移，强调初始化重要性  
   - 技巧：`INT_MIN`初始化防止负值错误

---

### 最优思路提炼
```cpp
// 核心转移逻辑
for(int i=1; i<=n; ++i)
    for(int j=1; j<=m; ++j)
        dp[i][j] = max({
            dp[i-1][j-1] + score[a[i]][b[j]],  // 直接匹配
            dp[i-1][j] + score[a[i]][5],       // 插入空碱基到第二序列
            dp[i][j-1] + score[5][b[j]]        // 插入空碱基到第一序列
        });
```

---

### 同类型题推荐
1. **编辑距离**（LeetCode 72）  
2. **最长公共子序列**（LCS）  
3. **字符串对齐问题**（Needleman-Wunsch算法）

---

### 洛谷相似题目
1. P1279 字串距离（同类DP模型）
2. P2758 编辑距离（状态转移类似）
3. P1435 回文字串（二维DP应用）

---

### 个人心得摘录
> "WA的根源在于未考虑负值，必须用INT_MIN初始化dp数组" —— Ykimna  
> "将string下标从1开始处理，能大幅减少边界判断" —— 香风智乃  
> "调试时打印整个dp表，发现第三列意外递增，才发现score表索引错误" —— Mophie

---

### 复古像素化演示方案
```javascript
// Canvas绘制核心逻辑（伪代码）
class DPVisualizer {
    constructor(seq1, seq2) {
        this.grid = initGrid(seq1.length+1, seq2.length+1); // 创建像素网格
        this.colors = [[255,0,0], [0,255,0], [0,0,255]]; // 红绿蓝三色箭头
    }

    drawStep(i, j, prevPos) {
        drawCell(i, j, this.currentValue);    // 绘制当前单元格
        drawArrow(prevPos, [i,j], this.color); // 绘制转移箭头
        playSound(this.soundType);            // 播放对应音效
    }
    
    autoRun() {
        for(let i=1; i<=n; ++i) {
            for(let j=1; j<=m; ++j) {
                this.calculateDP(i, j);
                await sleep(this.speed); 
            }
        }
    }
}
```

#### 交互特性
- **点击回溯**：点击任意单元格显示所有转移路径
- **速度控制**：0.5x~4x实时调节
- **音效开关**：可选8-bit音效或静音模式
- **导览模式**：分步解释每个转移决策的数学依据

---
处理用时：60.65秒
# 题目信息

# 「MCOI-01」Village 村庄

## 题目背景

今天，珂爱善良的0x3喵酱骑着一匹小马来到了一个村庄。

“诶，这个村庄的布局 ……”   
“好像之前我玩 Ciste 的地方啊 qwq”

0x3喵酱有一个地图，地图有着这个村庄的信息。

然后0x3喵酱要通过这张地图来判断 Ciste 有解无解啦 ~

注：Ciste 是《请问您今天要来点兔子吗》中的一种藏宝图游戏

## 题目描述

村庄被简化为一个 $n$ 个节点（编号为 $1$ 到 $n$）和 $n-1$ 条边构成的无向连通图。

0x3喵酱认为这个无向图里的信息跟满足以下条件的新图有关：

- 新图的点集与原图相同
- 在新图中 $u,v$ 之间有无向边 是 在原图中 $dis(u,v) \ge k$ 的**充分必要条件** （$k$ 为给定常量，$dis(u,v)$ 表示编号为 $u$ 的点到编号为 $v$ 的点最短路的长度）

0x3喵酱还认为这个"新图"如果为二分图，则 Ciste "有解"，如果"新图"不是二分图这个 Ciste "无解"。（如果您不知道二分图请翻到提示）

那么0x3喵酱想请您判断一下这个 Ciste 是否"有解"。

## 说明/提示

#### 样例解析

对于样例中的 **第一组** 数据：

原图：

![](https://cdn.luogu.com.cn/upload/image_hosting/9f9zh4b2.png)
新图：

![](https://cdn.luogu.com.cn/upload/image_hosting/dg4es91e.png)

新图不为二分图，故输出 `Baka Chino`。

对于 **第三组** 数据：

原图：

![](https://cdn.luogu.com.cn/upload/image_hosting/mku4v6uo.png)

新图：

![](https://cdn.luogu.com.cn/upload/image_hosting/15o3x3zz.png)

新图为二分图，故输出 `Yes`。

#### 数据规模与约定

**本题采用捆绑测试**。

- Subtask 1（16 pts）$\ $ ：$n \le 10$。
- Subtask 2（24 pts）$\ $ ：$n \le 100$。
- Subtask 3（8 pts）$\ $ ：$n \le 1000$。
- Subtask 4（28 pts）：图退化成一条链。
- Subtask 5（24 pts）：无特殊限制。

对于 $100\%$ 的数据，$n \le 10^5$，$T \le 10$，$v \le 1000$，$k \le 1000000$。

本题数据使用 [CYaRon](https://www.luogu.org/discuss/show?postid=11410) 生成。

#### 提示


**二分图** 又称作二部图，是图论中的一种特殊模型。设 $G=(V,E)$ 是一个无向图，如果顶点 $V$ 可分割为两个互不相交的子集 $(A,B)$，并且图中的每条边 $(i,j)$ 所关联的两个顶点 $i$ 和 $j$ 分别属于这两个不同的顶点集 $(i \in A,j \in B)$，则称图 $G$ 为一个二分图。（摘自[百度百科](https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE/9089095?fr=aladdin)）

#### 说明

Minecraft OI Round 1 A

- Idea：0x3喵酱
- Solution/Std：0x3喵酱
- Data：0x3喵酱
- Tester：tarjin

## 样例 #1

### 输入

```
5
5 2
1 2 1
2 3 1
3 4 1
4 5 1
5 3
1 2 1
2 3 1
3 4 1
4 5 1
5 8
1 3 3
1 2 1
2 4 6
2 5 2
5 2
1 3 3
1 2 1
2 4 6
2 5 2
7 4
1 2 3
1 3 3
2 5 3
2 6 3
3 7 3
2 4 2```

### 输出

```
Baka Chino
Yes
Yes
Baka Chino
Baka Chino```

# AI分析结果



## 唯一算法分类
**树的直径 + 距离判定**

---

## 综合分析与结论

### 核心思路与难点
1. **问题转化**：新图是否为二分图等价于判断是否存在奇环。通过数学归纳法可证明，若存在奇环则必然存在三元环，特别是包含树的直径两端点的三元环。
2. **树的直径性质**：树上最长路径的端点（直径两端点）是判断三元环的关键。若存在一点到这两个端点的距离均≥k，则新图存在奇环。
3. **实现难点**：高效计算所有点到直径两端的距离，并遍历所有点进行判定。

### 可视化设计
1. **动画流程**：
   - **Step 1**：用两次 DFS/BFS 找到树的直径，高亮直径路径（如红色）。
   - **Step 2**：遍历所有点，计算其到直径两端的距离，用不同颜色表示距离是否≥k。
   - **Step 3**：当发现某点到两端的距离均≥k时，触发音效并标记该点（闪烁黄色方块）。
2. **复古像素风格**：
   - **颜色方案**：直径路径（红色），满足条件的点（黄色），普通点（绿色）。
   - **音效**：发现符合条件的点时播放上扬音效，最终判定失败时播放“失败”音效。
3. **交互功能**：支持单步执行观察距离计算过程，可调节动画速度。

---

## 题解清单 (≥4星)

1. **一只书虫仔（5星）**  
   - 关键亮点：利用树的直径两端点进行判定，代码简洁高效，时间复杂度O(n)。  
   - 引用思路：“只需检查是否存在一点到直径两端的距离均≥k”。

2. **HPXXZYY（5星）**  
   - 关键亮点：清晰的数学证明，通过两次BFS求直径，代码可读性极强。  
   - 代码亮点：使用队列BFS避免递归栈溢出。

3. **JK_LOVER（4星）**  
   - 关键亮点：DFS求直径，通过染色法判断条件，代码结构清晰。  
   - 个人心得：“代表元的选取基于树的直径，确保集合划分的合理性”。

---

## 核心代码实现

```cpp
// 求树的直径两端点 s1, s2
void bfs(int start, int& far, int dist[]) {
    queue<int> q;
    memset(dist, -1, sizeof(int)*(n+1));
    dist[start] = 0;
    q.push(start);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto& e : G[u]) {
            if (dist[e.to] == -1) {
                dist[e.to] = dist[u] + e.w;
                q.push(e.to);
            }
        }
        if (dist[u] > dist[far]) far = u;
    }
}

// 主逻辑
bool check(int k) {
    int s1 = 1, s2 = s1;
    bfs(1, s1, dis1);    // 第一次BFS找直径端点s1
    bfs(s1, s2, dis1);   // 第二次BFS找另一端点s2
    bfs(s2, s2, dis2);   // 计算所有点到s2的距离
    
    for (int i = 1; i <= n; ++i) 
        if (dis1[i] >= k && dis2[i] >= k) 
            return false;
    return true;
}
```

---

## 相似题目推荐
1. **P5536 【XR-3】核心城市**（树的直径应用）  
2. **P3386 【模板】二分图最大匹配**（二分图判定）  
3. **P1099 树网的核**（树的最长路径相关）

---

## 个人心得摘录
> “数学归纳法证明中，假设不存在满足条件的点会导致矛盾，这是理解解法的关键。通过将树简化为直径路径，问题复杂度从O(n²)降至O(n)。” —— 青鸟_Blue_Bird

---

## 复古游戏化动画设计
1. **像素绘制**：用16x16像素块表示树节点，直径路径用红色连接线。  
2. **音效设计**：
   - **发现冲突点**：8-bit风格胜利音效（频率快速上升）。  
   - **遍历过程**：每一步移动播放“滴答”声。  
3. **自动演示**：AI自动执行BFS和遍历检查，每步间隔200ms，用绿色高亮当前访问节点。  
4. **控制面板**：HTML滑动条调节速度，按钮切换手动/自动模式。

```javascript
// 伪代码：音效触发
function playSound(type) {
    if (type === 'found') 
        new Audio('data:audio/wav;base64,UklGRl9...').play(); // 短促成功音效
    else 
        new Audio('data:audio/wav;base64,UklGRhI...').play(); // 失败音效
}
```

--- 

**可视化总结**：通过结合树的直径性质和距离判定，算法在O(n)时间内解决问题。复古动画强化了直径路径和冲突点的视觉反馈，使算法流程更易理解。

---
处理用时：64.50秒
# 题目信息

# [NOI2015] 荷马史诗

## 题目背景

> 追逐影子的人，自己就是影子 —— 荷马

## 题目描述

Allison 最近迷上了文学。她喜欢在一个慵懒的午后，细细地品上一杯卡布奇诺，静静地阅读她爱不释手的《荷马史诗》。但是由《奥德赛》和《伊利亚特》 组成的鸿篇巨制《荷马史诗》实在是太长了，Allison 想通过一种编码方式使得它变得短一些。

一部《荷马史诗》中有 $n$ 种不同的单词，从 $1$ 到 $n$ 进行编号。其中第 $i$ 种单词出现的总次数为 $w_i$。Allison 想要用 $k$ 进制串 $s_i$ 来替换第 $i$ 种单词，使得其满足如下要求：

对于任意的 $1\leq i, j\leq n$ ，$i\ne j$ ，都有：$s_i$ 不是 $s_j$ 的前缀。

现在 Allison 想要知道，如何选择 $s_i$，才能使替换以后得到的新的《荷马史诗》长度最小。在确保总长度最小的情况下，Allison 还想知道最长的 $s_i$ 的最短长度是多少？

一个字符串被称为 $k$ 进制字符串，当且仅当它的每个字符是 $0$ 到 $k-1$ 之间（包括 $0$ 和 $k-1$ ）的整数。

字符串 $str1$ 被称为字符串 $str2$ 的前缀，当且仅当：存在 $1 \leq t\leq m$ ，使得 $str1 = str2[1..t]$。其中，$m$ 是字符串 $str2$ 的长度，$str2[1..t]$ 表示 $str2$ 的前 $t$ 个字符组成的字符串。

## 说明/提示

#### 【样例解释】

#### 样例 1 解释

用 $X(k)$ 表示 $X$ 是以 $k$ 进制表示的字符串。

一种最优方案：令 $00(2)$ 替换第 $1$ 种单词， $01(2)$ 替换第 2 种单词， $10(2)$ 替换第 $3$ 种单词，$11(2)$ 替换第 $4$ 种单词。在这种方案下，编码以后的最短长度为：

$1 × 2 + 1 × 2 + 2 × 2 + 2 × 2 = 12$

最长字符串 $s_i$ 的长度为 $2$ 。

一种非最优方案：令 $000(2)$ 替换第 $1$ 种单词，$001(2)$ 替换第 $2$ 种单词，$01(2)$ 替换第 $3$ 种单词，$1(2)$ 替换第 $4$ 种单词。在这种方案下，编码以后的最短长度为：

$1 × 3 + 1 × 3 + 2 × 2 + 2 × 1 = 12$

最长字符串 $s_i$ 的长度为 $3$ 。与最优方案相比，文章的长度相同，但是最长字符串的长度更长一些。

#### 样例 2 解释

一种最优方案：令 $000(3)$ 替换第 $1$ 种单词，$001(3)$ 替换第 $2$ 种单词，$01(3)$ 替换第 $3$ 种单词， $02(3)$ 替换第 $4$ 种单词， $1(3)$ 替换第 5 种单词， $2(3)$ 替换第 $6$ 种单词。

#### 【数据规模与约定】

所有测试数据的范围和特点如下表所示（所有数据均满足 $0 < w_i \leq 10^{11}$）：

| 测试点编号 |  $n$ 的规模  | $k$ 的规模 |            备注            |
| :--------: | :----------: | :--------: | :------------------------: |
|    $1$     |    $n=3$     |   $k=2$    |                            |
|    $2$     |    $n=5$     |   $k=2$    |                            |
|    $3$     |    $n=16$    |   $k=2$    |     所有 $w_i$ 均相等      |
|    $4$     |  $n=1\,000$  |   $k=2$    | $w_i$ 在取值范围内均匀随机 |
|    $5$     |  $n=1\,000$  |   $k=2$    |                            |
|    $6$     | $n=100\,000$ |   $k=2$    |                            |
|    $7$     | $n=100\,000$ |   $k=2$    |     所有 $w_i$ 均相等      |
|    $8$     | $n=100\,000$ |   $k=2$    |                            |
|    $9$     |    $n=7$     |   $k=3$    |                            |
|    $10$    |    $n=16$    |   $k=3$    |     所有 $w_i$ 均相等      |
|    $11$    |  $n=1\,001$  |   $k=3$    |     所有 $w_i$ 均相等      |
|    $12$    | $n=99\,999$  |   $k=4$    |     所有 $w_i$ 均相等      |
|    $13$    | $n=100\,000$ |   $k=4$    |                            |
|    $14$    | $n=100\,000$ |   $k=4$    |                            |
|    $15$    |  $n=1\,000$  |   $k=5$    |                            |
|    $16$    | $n=100\,000$ |   $k=7$    | $w_i$ 在取值范围内均匀随机 |
|    $17$    | $n=100\,000$ |   $k=7$    |                            |
|    $18$    | $n=100\,000$ |   $k=8$    | $w_i$ 在取值范围内均匀随机 |
|    $19$    | $n=100\,000$ |   $k=9$    |                            |
|    $20$    | $n=100\,000$ |   $k=9$    |                            |

#### 【提示】

选手请注意使用 64 位整数进行输入输出、存储和计算。

#### 【评分方式】

对于每个测试点：

- 若输出文件的第 $1$ 行正确，得到该测试点 $40\%$ 的分数；
- 若输出文件完全正确，得到该测试点 $100\%$ 的分数。

## 样例 #1

### 输入

```
4 2
1
1
2
2
```

### 输出

```
12
2```

## 样例 #2

### 输入

```
6 3
1
1
3
3
9
9
```

### 输出

```
36
3
```

# AI分析结果



## 算法分类
**贪心算法（k叉哈夫曼树）**

---

## 题解思路与算法要点

### 核心逻辑
1. **k叉哈夫曼树构造**  
   将单词出现次数视为叶子节点的权值，构造一棵满足以下条件的k叉树：  
   - 总带权路径长度（总编码长度）最小  
   - 最长编码长度最短  
   
2. **补零调整**  
   若 `(n-1) % (k-1) ≠ 0`，补充权值为0的虚拟节点，使得合并次数满足整数条件，确保最后一次合并为满k叉。

3. **优先队列优化**  
   使用优先队列（小根堆）维护节点的权值和高度，每次合并k个权值最小的节点，新节点权值为合并后的总和，高度为合并节点的最大高度+1。

### 解决难点
- **如何保证最优性**：  
  补零操作确保每次合并都是完整的k叉，避免非最优子树结构。  
- **最长编码最短**：  
  当权值相同时，优先合并高度较小的子树，保证合并后的高度增长最小。

---

## 题解评分（≥4星）

### 1. 作者：_Sein（⭐⭐⭐⭐⭐）
- **亮点**：  
  - 详细推导k叉哈夫曼树的数学原理，图解辅助理解。  
  - 代码清晰，优先队列直接维护`(w, h)`二元组，运算符重载处理权值与高度的优先级。  
  ```cpp
  struct node { ll w, h; };
  bool operator <(const node &a, const node &b) {
      return a.w == b.w ? a.h > b.h : a.w > b.w;
  }
  ```

### 2. 作者：无咕_（⭐⭐⭐⭐）
- **亮点**：  
  - 代码极简（仅36行），补零逻辑直接嵌入主循环。  
  - 注释明确，变量命名直观（如`sumw`为合并总和，`maxh`记录高度）。  
  ```cpp
  while((n-1)%(k-1)) q.push(node(0,1)); // 补零调整
  ```

### 3. 作者：devout（⭐⭐⭐⭐）
- **亮点**：  
  - 结构体`misaka`中`dep`字段记录高度，合并时实时更新。  
  - 补零公式`(k-1 - (n-1)%(k-1)) % (k-1)`处理边界条件严谨。  
  ```cpp
  int qwq = (k-1 - (n-1)%(k-1)) % (k-1); // 计算补零数量
  ```

---

## 最优思路与技巧提炼

### 关键技巧
1. **补零公式**：  
   ```cpp
   cnt = (k-1) - (n-1) % (k-1);
   ```
   通过补充`cnt`个权值为0的节点，保证合并次数为整数。

2. **双属性优先队列**：  
   合并时优先选择权值小的节点，权值相同时选择高度小的，保证最长编码最短。

3. **线性构造优化**：  
   落寞音箫的题解提出双队列（原数据排序队列+合并队列）的O(n)方法，但需保证原数据有序。

---

## 同类型题与算法套路

### 类似题目
- **P1090 [NOIP2004] 合并果子**：二叉哈夫曼树的经典问题。  
- **P1334 瑞瑞的木板**：权值合并的最优化问题。  
- **P6033 [NOIP2004] 合并果子 加强版**：大数据量下的线性优化。

---

## 可视化与算法演示设计

### 动画方案
1. **像素化节点表示**：  
   - 不同颜色方块表示节点（绿色：原节点，蓝色：合并节点，灰色：补零节点）。  
   - 节点上标注权值和高度（如`(5,2)`表示权值5、高度2）。

2. **合并过程演示**：  
   ```plaintext
   Step 1: 取出k=3个节点 [1,1,2] → 合并为4（高度2）
   Step 2: 取出[2,4,0] → 合并为6（高度3）
   ```
   - 当前合并的节点高亮显示，合并后新节点闪烁提示。

3. **交互控制**：  
   - **速度调节**：滑块控制动画速度（0.5x~3x）。  
   - **步进模式**：按空格键单步执行合并操作。  
   - **音效反馈**：合并时播放“咔嗒”声，完成时播放胜利音效。

### 复古风格设计
- **8位色调色板**：  
  - 节点颜色：绿(#00FF00)、蓝(#0000FF)、灰(#808080)。  
  - 背景：黑色网格，模拟早期计算机终端效果。  
- **Canvas绘制**：  
  - 使用`<canvas>`绘制节点队列和合并动画，每帧更新节点位置。  
  - 合并时显示连线动画，模拟子树连接过程。

---

## 核心代码实现

### 优先队列解法（_Sein版）
```cpp
#include <queue>
#include <cstdio>
using namespace std;
typedef long long ll;

struct Node {
    ll w, h;
    Node(ll w, ll h) : w(w), h(h) {}
    bool operator<(const Node& o) const {
        return w == o.w ? h > o.h : w > o.w;
    }
};

priority_queue<Node> q;

int main() {
    ll n, k, w, ans = 0; 
    scanf("%lld%lld", &n, &k);
    for (int i = 0; i < n; i++) {
        scanf("%lld", &w);
        q.push(Node(w, 1));
    }
    // 补零调整
    while ((q.size() - 1) % (k - 1) != 0) 
        q.push(Node(0, 1));
    // 合并过程
    while (q.size() >= k) {
        ll sum = 0, maxh = 0;
        for (int i = 0; i < k; i++) {
            sum += q.top().w;
            maxh = max(maxh, q.top().h);
            q.pop();
        }
        ans += sum;
        q.push(Node(sum, maxh + 1));
    }
    printf("%lld\n%lld\n", ans, q.top().h - 1);
    return 0;
}
```

### 关键逻辑说明
- **补零调整**：通过循环补充0权节点，使得总节点数满足合并条件。  
- **合并循环**：每次取k个最小节点合并，累加权重并更新高度，新节点重新入队。

---
处理用时：80.27秒
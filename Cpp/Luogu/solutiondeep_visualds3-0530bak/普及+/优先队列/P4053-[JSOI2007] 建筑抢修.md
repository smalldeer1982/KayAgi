# 题目信息

# [JSOI2007] 建筑抢修

## 题目描述

小刚在玩 JSOI 提供的一个称之为“建筑抢修”的电脑游戏：经过了一场激烈的战斗，T 部落消灭了所有 Z 部落的入侵者。但是 T 部落的基地里已经有 $N$ 个建筑设施受到了严重的损伤，如果不尽快修复的话，这些建筑设施将会完全毁坏。现在的情况是：T 部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N < 150000$，$1 \le T_1 < T_2 < 2^{31}$。

## 样例 #1

### 输入

```
4
100 200
200 1300
1000 1250
2000 3200```

### 输出

```
3```

# AI分析结果



## 算法分类
**贪心算法** + **优先队列（堆）**

---

## 题解思路与难点分析
### 核心思路
1. **按截止时间排序**：将所有建筑按 `t2`（最晚完成时间）升序排序，优先处理即将报废的建筑。
2. **动态调整策略**：使用大根堆维护已选建筑的修理时间。若当前建筑无法按时完成，则替换堆中耗时最长的建筑，减少总耗时。

### 解决难点
- **贪心策略的正确性**：排序后按顺序处理建筑，确保每一步选择局部最优（尽可能多修建筑）。
- **动态维护最优解**：当总时间超过当前建筑的截止时间时，通过替换堆顶元素（修理时间最长的建筑）来优化后续选择机会。

---

## 题解评分（≥4星）
1. **_Album_（★★★★★）**  
   - 代码简洁，使用 STL 优先队列高效维护最大耗时。  
   - 思路清晰，注释详细，适合快速理解核心逻辑。  
2. **Treaker（★★★★☆）**  
   - 代码精简，直接展示算法骨架，适合进阶学习。  
   - 缺乏详细注释，但对堆的应用准确。  
3. **灵乌路空（★★★★☆）**  
   - 代码可读性强，包含详细思路分析。  
   - 使用 `long long` 处理大数据，避免溢出问题。

---

## 最优思路提炼
- **排序策略**：按 `t2` 升序排序，保证优先处理即将报废的建筑。  
- **堆优化**：用大根堆动态维护已选建筑的最大耗时，遇到冲突时替换堆顶元素，减少总耗时。  
- **时间复杂度**：排序 O(n log n)，堆操作 O(n log n)，总复杂度 O(n log n)。

---

## 同类题目推荐
1. **P1090 [NOIP2004 提高组] 合并果子**  
   （贪心 + 优先队列，每次合并最小两堆）  
2. **P1484 种树**  
   （反悔贪心，动态选择最优区间）  
3. **P3620 [APIO/CTSC 2007] 数据备份**  
   （贪心 + 双向链表 + 优先队列，选择不相邻元素）

---

## 代码核心实现
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Building { ll t1, t2; };
bool cmp(Building a, Building b) { return a.t2 < b.t2; }

int main() {
    int n; cin >> n;
    vector<Building> build(n);
    for (auto &b : build) cin >> b.t1 >> b.t2;
    sort(build.begin(), build.end(), cmp);

    priority_queue<ll> Q;
    ll sum = 0, ans = 0;
    for (auto &b : build) {
        sum += b.t1;
        Q.push(b.t1);
        if (sum > b.t2) {
            sum -= Q.top();  // 弹出耗时最长的建筑
            Q.pop();
        } else ans++;
    }
    cout << ans << endl;
}
```

---

## 可视化与算法演示
### 动画方案
1. **排序阶段**：显示建筑按 `t2` 从小到大排列，每个建筑显示 `t1`（耗时）和 `t2`（截止时间）。  
2. **处理阶段**：  
   - **颜色标记**：当前建筑高亮为黄色，已选建筑为绿色，堆顶元素为红色。  
   - **堆操作**：压入建筑时显示上升动画，替换时堆顶爆炸特效，总时间动态更新。  
3. **音效设计**：  
   - 成功修复时播放“金币音效”，替换堆顶时播放“碎裂声”。  
   - 背景音乐为 8-bit 风格循环曲。

### 复古像素风格
- **Canvas 绘制**：建筑显示为像素方块，宽度表示 `t1`，高度固定。  
- **堆可视化**：大根堆以树状结构显示，堆顶位于顶部，子节点用连线连接。  
- **自动演示**：按空格暂停/继续，方向键调整速度，F 键触发单步执行。

---

## 个人心得摘录
- **wwldx 的调试经历**：按最迟开始时间排序导致边界问题，通过引入 `maxx` 变量维护间隙解决，强调测试极端数据的重要性。  
- **约瑟夫用脑玩的思维突破**：逆向思考时间倒序处理，虽复杂但提供新的贪心视角，体现多角度分析的价值。

---
处理用时：57.66秒
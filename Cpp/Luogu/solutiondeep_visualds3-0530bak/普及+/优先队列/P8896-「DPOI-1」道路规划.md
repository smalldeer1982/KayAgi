# 题目信息

# 「DPOI-1」道路规划

## 题目背景

不可以，总司令。

## 题目描述

战场上有 $n$ 个据点，从 $1\sim n$ 编号。**每两个据点**之间**都**有一条双向道路。

一天，总司令来战区巡视，走着走着迷路了，于是愤怒地下达命令，让你把每一条双向道路变成单向的，使得这些道路**不包含环**（否则总司令会迷路）。但由于每个据点的规模互不相同，总司令从第 $i$ 个据点出发沿着单向道路能**直接到达**的据点数量需要在 $[l_i,r_i]$ 之间。换言之，第 $i$ 个点的出度需要在 $[l_i,r_i]$ 之间。你需要告诉总司令有没有可能满足他的需求。

## 说明/提示

#### 样例 #1 解释
下面是第 $1$ 组数据中一种可行的方案：

![](https://cdn.luogu.com.cn/upload/image_hosting/2uvwlydw.png)

#### 样例 #2 解释
该样例满足测试点 $3 \sim 6$ 的限制。
#### 数据范围
**本题测试点分数不等分。**

|  测试点编号  | $n \le$ | 特殊条件 |每个测试点分数|
| :----------: | :-----------: | :------: | :----: |
|     $1\sim 2$      |     $10$     |   无   |$5$|
|     $3\sim 6$      |     $1000$     |    无     |$5$|
|     $7\sim 8$      |     $10^5$     |    所有 $l_i = i-1$ 或所有 $l_i \geq \min (i, n - 1)$    |$5$|
| $9 \sim 10$  | $10^5$ | $l_i=0$ 或 $r_i=n-1$ |$5$|
| $11 \sim 15$ | $10^5$ | 无 |$10$|

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 \leq l_i \leq r_i < n$，$1 \leq T \leq 10$。

## 样例 #1

### 输入

```
2
5
0 1 4 0 0
3 4 4 1 3
3
1 2 2
2 2 2```

### 输出

```
YES
NO```

## 样例 #2

### 输入

```
见下发文件 road2.in```

### 输出

```
见下发文件 road2.out```

# AI分析结果



**唯一算法分类**：贪心算法

---

### **综合分析与结论**
- **核心思路**：将问题转化为区间排列问题，利用拓扑序的唯一性确定出度必须为0~n-1的排列。贪心策略按数值从小到大处理，维护可用区间右端点的小根堆，确保每一步选择最小区间，避免后续冲突。
- **解决难点**：关键在于证明贪心的正确性——优先选右端点最小的区间不会导致后续无解（若存在解，可通过调整顺序得到该策略的解）。
- **可视化设计**：
  - **动画方案**：以网格展示每个数值i的处理过程，左侧显示当前处理的i值，右侧动态显示按左端点分组的区间队列。当处理i时，对应分组的区间右端点进入小根堆（颜色高亮），堆顶元素被取出匹配（红色标记）。若堆顶<当前i，触发失败音效。
  - **复古风格**：使用8位像素字体，背景音乐为循环的8-bit旋律，关键操作（入堆、匹配、失败）配以不同音效。Canvas绘制动态堆结构，元素以像素方块表示，数值显示在方块中央。

---

### **题解清单 (≥4星)**
1. **kevinchw（5星）**  
   - 思路清晰，详细证明贪心正确性，代码简洁高效。  
   - 亮点：通过拓扑序转化问题，正确性证明完整，代码使用分组预处理左端点。

2. **DengDuck（4星）**  
   - 代码简洁，利用vector分组处理左端点，逻辑明确。  
   - 亮点：直接处理原始区间，无需排序，分组后线性处理。

3. **Gapple（4星）**  
   - 使用负值技巧实现小根堆，代码可读性强。  
   - 亮点：通过负数转换优先队列排序，减少代码复杂度。

---

### **最优思路提炼**
1. **拓扑序转化**：DAG的拓扑序唯一性推导出度必须为0~n-1的排列。
2. **贪心策略**：按数值从小到大处理，维护可用区间的右端点小根堆，每次取最小右端点匹配。
3. **正确性保证**：选择右端点最小的区间可最大化后续选择空间，通过交换法证明其最优性。

**代码片段（kevinchw核心逻辑）**：
```cpp
for(int i=1;i<=n;i++) {
    for(int j=0;j<v[i].size();j++) q.push(v[i][j]); // 按左端点分组入堆
    if(q.empty() || q.top()<i) { // 无解条件
        cout<<"NO\n"; 
        break; 
    }
    q.pop(); // 匹配当前i
}
```

---

### **同类型题推荐**
1. **P1237 木棍加工**（区间覆盖，贪心排序）  
2. **P1080 国王游戏**（贪心策略，排序证明）  
3. **P5019 铺设道路**（区间分组，贪心选择）

---

### **可视化实现要点**
- **Canvas动画**：  
  - 左侧数值i逐步右移，右侧动态显示当前可选的右端点（绿色方块）。  
  - 堆结构以树状展示，堆顶元素闪烁红色，匹配时触发爆炸特效。  
- **音效设计**：  
  - 入堆：短促“滴”声；匹配成功：清脆“叮”声；失败：低沉“嗡”声。  
- **自动演示**：按帧逐步推进i值，堆操作自动触发，支持暂停/继续。

---
处理用时：51.92秒
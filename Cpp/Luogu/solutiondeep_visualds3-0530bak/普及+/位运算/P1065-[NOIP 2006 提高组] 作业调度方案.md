# 题目信息

# [NOIP 2006 提高组] 作业调度方案

## 题目描述

我们现在要利用 $m$ 台机器加工 $n$ 个工件，每个工件都有 $m$ 道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。

每个工件的每个工序称为一个操作，我们用记号 `j-k` 表示一个操作，其中 $j$ 为 $1$ 到 $n$ 中的某个数字，为工件号；$k$ 为 $1$ 到 $m$ 中的某个数字，为工序号，例如 `2-4` 表示第 $2$ 个工件第 $4$ 道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。

例如，当 $n=3,m=2$ 时，`1-1,1-2,2-1,3-1,3-2,2-2` 就是一个给定的安排顺序，即先安排第 $1$ 个工件的第 $1$ 个工序，再安排第 $1$ 个工件的第 $2$ 个工序，然后再安排第 $2$ 个工件的第 $1$ 个工序，等等。

一方面，每个操作的安排都要满足以下的两个约束条件。

1. 对同一个工件，每道工序必须在它前面的工序完成后才能开始；

2. 同一时刻每一台机器至多只能加工一个工件。

另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。

由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为 `1 1 2 3 3 2`。

还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。

例如，取 $n=3,m=2$，已知数据如下（机器号/加工时间）：


工件号 |工序 1 | 工序 2
-|-|-
$1$  |  $1/3$  |  $2/2$
$2$  |  $1/2$  |  $2/5$
$3$  |  $2/2$  |  $1/4$

则对于安排顺序 `1 1 2 3 3 2`，下图中的两个实施方案都是正确的。但所需要的总时间分别是 $10$ 与 $12$。

方案 1，用时 $10$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | `3-1` | `3-1` |  无   | `1-2` | `1-2` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

方案 2，用时 $12$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12  |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` |   无   |  无   | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | 无 | 无 |  无   | `1-2` | `1-2` | `3-1` | `3-1` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件 $(1.)(2.)$ 的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件 $(1.)(2.)$ 的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。

显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。


## 说明/提示

NOIP 2006 提高组 第三题


## 样例 #1

### 输入

```
2 3
1 1 2 3 3 2
1 2 
1 2 
2 1
3 2 
2 5 
2 4
```

### 输出

```
10```

# AI分析结果



---

**唯一算法分类**：模拟

---

### **综合分析与结论**

**核心思路**：  
题目要求按给定顺序处理每个工件的工序，确保同一工件的工序顺序性及机器独占性。所有题解均采用直接模拟策略，核心流程如下：  
1. **维护状态变量**：记录每个工件当前进行到的工序、每台机器的占用时间段。  
2. **按顺序处理每个工序**：遍历安排顺序中的每个操作，确定其对应机器和加工时间。  
3. **查找可插入时间窗口**：从该工件上一次完成时间后开始，在目标机器上找到第一个足够长的连续空闲时间段。  
4. **更新状态**：标记机器占用时间，更新工件的最后完成时间及全局最大时间。

**解决难点**：  
- **正确插入时间窗口**：需满足两个约束条件（工序顺序、机器独占），且必须选择最早可行的位置。  
- **高效查找空档**：通过从工件上一工序结束时间开始遍历，避免无效扫描。

**可视化设计**：  
- **动画展示**：  
  - **时间线网格**：用不同颜色表示各机器的占用时间段，当前操作高亮为红色。  
  - **工件状态面板**：显示每个工件的当前工序和最后完成时间。  
  - **步进控制**：允许单步执行，观察每个操作插入位置。  
- **复古像素风格**：  
  - 机器用不同颜色方块表示，时间轴横向滚动。  
  - 音效：插入成功时播放“哔”声，总时间更新时播放胜利音效。  

---

### **题解清单 (≥4星)**

1. **brealid (4星)**  
   - **亮点**：代码简洁，通过 `las_time` 快速定位起点，直接遍历时间线。  
   - **代码片段**：  
     ```cpp
     for (int j = las_time[now] + 1;; j++) {
         if (mac[id][j] == 0) s++;
         else s = 0;
         if (s == cost) { /* 标记时间段并更新状态 */ }
     }
     ```

2. **ShawnZhou (5星)**  
   - **亮点**：详细注释与变量命名，使用辅助函数 `check_in_line` 提高可读性。  
   - **代码片段**：  
     ```cpp
     bool check_in_line(int begin, int end, int workid) {
         for (int t = begin; t <= end; t++)
             if (timeline[workid][t]) return false;
         return true;
     }
     ```

3. **qhr2023 (4星)**  
   - **亮点**：代码精简，直接在循环中维护连续空闲计数。  
   - **代码片段**：  
     ```cpp
     for (int s=0, j=lst[a[i]]+1; s<w; ++j) {
         s = (use[id][j] ? 0 : s+1);
         if (s == w) { /* 更新占用时间 */ }
     }
     ```

---

### **最优思路提炼**

**关键技巧**：  
- **状态维护**：用 `last_time[工件]` 记录其最后完成时间，避免重复扫描。  
- **时间窗口查找**：从 `last_time+1` 开始，逐个时间点检查连续空闲长度。  
- **贪心插入**：找到第一个可行窗口后立即插入，确保最早结束。

**代码实现**：  
```cpp
int main() {
    // 初始化读入数据...
    for (每个操作 in 安排顺序) {
        int 工件 = 当前操作对应工件;
        int 工序 = ++当前工件已执行工序数;
        int 机器 = 该工序的机器号;
        int 耗时 = 该工序所需时间;
        
        // 查找可插入时间窗口
        int 连续空闲 = 0;
        for (时间点 = last_time[工件] + 1; ; 时间点++) {
            if (机器在时间点空闲) 连续空闲++;
            else 连续空闲 = 0;
            
            if (连续空闲 == 耗时) {
                // 标记占用时间点
                for (int t = 时间点 - 耗时 + 1; t <= 时间点; t++)
                    machine[机器][t] = 1;
                // 更新全局时间和工件状态
                last_time[工件] = 时间点;
                ans = max(ans, 时间点);
                break;
            }
        }
    }
    // 输出 ans...
}
```

---

### **同类型题目推荐**

1. **P1880 [NOI1995] 石子合并**  
   - 环形区间DP，模拟合并过程的最优解。

2. **P1080 [NOIP2012 提高组] 国王游戏**  
   - 贪心排序与高精度模拟，需按特定规则安排操作顺序。

3. **P1541 [NOIP2010 提高组] 乌龟棋**  
   - 动态规划模拟卡片使用顺序，优化状态转移。

---

### **个人心得摘录**

- **审题陷阱**：必须按顺序处理工序，但同一机器上后安排的操作可能先完成（如样例中的方案1）。  
- **调试关键**：维护 `last_time` 和机器时间线需严格同步更新，否则会导致插入位置错误。  
- **顿悟点**：查找空档时，从工件上一次结束时间开始而非机器全局起始时间，大幅减少无效扫描。

---

### **可视化与算法演示**

**动画设计**：  
1. **时间线网格**：横向表示时间，每行对应一台机器，格子颜色表示占用状态。  
2. **当前操作高亮**：红色框表示正在处理的工序，动态显示连续空闲段的查找过程。  
3. **像素音效**：  
   - 成功插入时播放 `8-bit` 短音，总时间更新时播放胜利旋律。  
   - 时间推进时伴随“滴答”背景音。  

**交互功能**：  
- **暂停/继续**：观察每个操作插入后的状态。  
- **速度调节**：滑动条控制动画播放速度。  
- **AI自动演示**：按最优路径自动执行，展示全流程。  

**示例截图**：  
![](https://i.loli.net/2019/01/24/5c49b57ea5613.png)  
（模拟机器时间线占用情况，红色为当前操作插入位置）

---
处理用时：91.57秒
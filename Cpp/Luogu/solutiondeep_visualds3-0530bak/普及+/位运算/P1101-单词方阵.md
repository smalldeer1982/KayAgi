# 题目信息

# 单词方阵

## 题目描述

给一 $n \times n$ 的字母方阵，内可能蕴含多个 `yizhong` 单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 $8$ 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉，因此有可能共用字母。输出时，将不是单词的字母用 `*` 代替，以突出显示单词。

## 样例 #1

### 输入

```
7
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
```

### 输出

```
*******
*******
*******
*******
*******
*******
*******
```

## 样例 #2

### 输入

```
8
qyizhong
gydthkjy
nwidghji
orbzsfgz
hhgrhwth
zzzzzozo
iwdfrgng
yyyygggg```

### 输出

```
*yizhong
gy******
n*i*****
o**z****
h***h***
z****o**
i*****n*
y******g```

# AI分析结果



### 唯一算法分类
深度优先搜索（DFS）

---

### 综合分析与结论
#### 核心思路与难点
题目要求从 n×n 矩阵中找到所有沿同一方向排列的 `yizhong` 字符串。核心难点在于：
1. **方向一致性**：单词必须沿 8 个固定方向之一连续排列。
2. **高效遍历**：需高效检查每个可能的起点和方向。
3. **路径标记**：正确标记所有匹配字符，避免重复或遗漏。

#### 核心算法流程
1. **预处理**：记录所有 `y` 的坐标作为起点。
2. **方向遍历**：对每个 `y` 沿 8 个方向递归/迭代检查后续字符。
3. **标记路径**：若完整匹配，标记路径上的所有字符。

#### 可视化设计思路
- **网格动画**：在 Canvas 上绘制矩阵，高亮当前检查的字符和方向。
- **方向箭头**：用箭头表示当前搜索方向。
- **颜色标记**：匹配字符绿色高亮，失败路径红色闪烁。
- **复古音效**：成功时播放 8-bit 胜利音效，失败短促提示音。

---

### 题解清单（≥4星）
1. **灯芯糕（5星）**  
   - **亮点**：预处理 `y` 的位置，递归检查方向，代码简洁高效。
   - **关键代码**：
     ```cpp
     bool f(int i, int j, int m, int n, int next) {
         if (next >= 8) { s[i][j] = 1; return 1; }
         if (a[i+m][j+n] == k[next] && f(i+m, j+n, m, n, next+1)) {
             s[i][j] = 1; return 1;
         }
         return 0;
     }
     ```

2. **hzg0226（4星）**  
   - **亮点**：使用结构体记录路径，方向数组清晰。
   - **关键代码**：
     ```cpp
     void dfs(int x, int y, int di) {
         for (int j=0; j<7; j++) {
             if (sta[j] != s[a][b]) return;
             a += dir[di][0]; b += dir[di][1];
         }
         for (int j=0; j<7; j++) book[x+dir[di][0]*j][y+dir[di][1]*j] = 1;
     }
     ```

3. **Way_How_Fri3nd（4星）**  
   - **亮点**：通过字符映射表简化判断，方向参数明确。
   - **关键代码**：
     ```cpp
     bool DFS(int x, int y, char w, int p) {
         if (w == 'g') { ma[x][y] = 1; return 1; }
         int xx = x + u[p], yy = y + v[p];
         if (DFS(xx, yy, le[w], p)) { ma[x][y] = 1; return 1; }
         return 0;
     }
     ```

---

### 最优思路提炼
1. **方向数组**：使用预定义的 8 方向偏移量数组简化方向遍历。
2. **递归验证**：从 `y` 出发，沿固定方向递归验证后续字符。
3. **路径标记**：匹配成功后反向标记路径，避免重复计算。
4. **预处理优化**：先记录所有 `y` 的位置，减少无效遍历。

---

### 同类型题与算法套路
- **通用解法**：网格中的路径搜索问题通常使用 DFS/BFS + 方向数组。
- **类似题目**：
  1. **洛谷 P1135**（矩阵中的最短路径）
  2. **洛谷 P1605**（迷宫问题）
  3. **LeetCode 79. Word Search**

---

### 推荐相似题目
1. **P1135 奇怪的电梯** - 方向选择与层间移动。
2. **P1605 迷宫** - 网格中的路径搜索。
3. **P1101 的变体** - 扩展为寻找多个不同单词。

---

### 个人心得摘录
- **方向处理**：初始版本忘记锁定方向，导致弯曲路径误判（拱垲题解）。
- **越界检查**：递归时需优先判断坐标合法性，避免段错误（灯芯糕题解注释）。
- **标记顺序**：反向标记路径更高效，避免多次遍历（hzg0226题解）。

---

### 算法可视化设计（伪代码）
```javascript
// Canvas 初始化
const grid = new Grid(n, n, 30); // 30px 每格
grid.draw();

// 搜索动画
function animateSearch(x, y, dir) {
    let current = {x, y};
    for (let i = 0; i < 7; i++) {
        grid.highlight(current.x, current.y, 'yellow');
        current.x += dir[0];
        current.y += dir[1];
        if (!grid.isValid(current)) break;
    }
    if (i === 6) grid.markPath(start, dir, 'green');
}

// 复古音效
const audio = new AudioContext();
function playSuccess() {
    const osc = audio.createOscillator();
    osc.frequency.setValueAtTime(440, audio.currentTime);
    osc.connect(audio.destination);
    osc.start(); osc.stop(audio.currentTime + 0.2);
}
```

---

### 关键代码实现（DFS核心）
```cpp
int dir[8][2] = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}};

void dfs(int x, int y, int d, int step) {
    if (step == 6) { markPath(x, y, d); return; }
    int nx = x + dir[d][0], ny = y + dir[d][1];
    if (nx < 0 || ny < 0 || nx >= n || ny >= n) return;
    if (grid[nx][ny] != target[step+1]) return;
    dfs(nx, ny, d, step+1);
}

// 调用示例
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        if (grid[i][j] == 'y') {
            for (int d = 0; d < 8; d++) {
                dfs(i, j, d, 0);
            }
        }
    }
}
```

---
处理用时：90.86秒
# 题目信息

# 谁能赢呢？

## 题目描述

小明和小红经常玩一个博弈游戏。给定一个 $n\times n$ 的棋盘，一个石头被放在棋盘的左上角。他们轮流移动石头。每一回合，选手只能把石头向上，下，左，右四个方向移动一格，并且要求移动到的格子之前不能被访问过。谁不能移动石头了就算输。

假如小明先移动石头，而且两个选手都以最优策略走步，问最后谁能赢？


## 说明/提示

对于 $20\%$ 的数据，保证 $1\le n\le 10$；

对于 $40\%$ 的数据，保证 $1\le n\le 1000$；

对于 $100\%$ 数据，保证 $1\le n\le 10000$。

## 样例 #1

### 输入

```
2
0```

### 输出

```
Alice```

# AI分析结果



---

**唯一算法分类**：二分图博弈

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
- **奇偶性判断**：结果仅取决于棋盘大小 `n` 的奇偶性。当 `n` 为偶数时，先手必胜（Alice）；奇数时后手必胜（Bob）。
- **二分图博弈模型**：棋盘可视为二分图（黑白染色），若存在完美匹配且起点在所有最大匹配中，则先手必胜；否则后手必胜。
- **完美匹配构造**：
  - **偶数 `n`**：棋盘可被 `1×2` 的骨牌完全覆盖，形成完美匹配。
  - **奇数 `n`**：除去起点后，剩余格子可被完美匹配，但起点不在匹配中。

#### **解决难点**
1. **模型抽象**：将棋盘抽象为二分图，分析其最大匹配性质。
2. **完美匹配构造**：通过具体构造方式（如横向/纵向匹配）证明存在性。
3. **理论应用**：利用二分图博弈定理（起点是否在所有最大匹配中）直接推导结论。

---

### **题解评分 (≥4星)**

1. **王熙文（5星）**  
   - **亮点**：通过棋盘染色和完美匹配构造，直观展示证明过程；配图清晰，代码简洁。
   - **代码**：直接判断奇偶性，时间复杂度 `O(1)`。
   ```cpp
   cout<<(n%2==0?"Alice":"Bob")<<'\n';
   ```

2. **StudyingFather（5星）**  
   - **亮点**：引入二分图博弈理论，引用定理严谨证明；配图展示最大匹配构造。
   - **代码**：同王熙文，无额外优化但逻辑清晰。

3. **cmkun（4星）**  
   - **亮点**：通过骨牌覆盖简化问题，易于理解；代码包含输入处理细节。
   - **不足**：证明过程较为简略。

---

### **最优思路提炼**
1. **棋盘染色法**：将棋盘黑白交替染色，形成二分图。
2. **完美匹配分析**：偶数 `n` 存在包含起点的完美匹配，奇数则否。
3. **奇偶性结论**：无需复杂计算，直接判断 `n % 2` 即可。

---

### **同类型题与算法套路**
- **通用解法**：棋盘博弈问题可尝试转化为二分图博弈，分析最大匹配。
- **类似题目**：
  - **洛谷 P4136**：取石子游戏的奇偶性判断。
  - **洛谷 P2737**：分块问题中的构造性解法。
  - **洛谷 P1290**：欧几里德博弈的递归分析。

---

### **推荐题目**
1. **P4136**：取石子游戏的奇偶性策略。
2. **P2737**：分块构造与数学归纳。
3. **P1290**：经典博弈论中的递归分析。

---

### **个人心得摘录**
- **王熙文**：通过构造完美匹配的配图，直观展示了 `n=5` 和 `n=4` 的匹配方式，帮助理解抽象理论。
- **lbh666**：强调“骨牌覆盖”这一具体构造方法，将问题转化为覆盖问题的思维方式。

---

### **可视化与算法演示**
#### **核心算法过程**
1. **棋盘初始化**：渲染 `n×n` 网格，左上角为黑色。
2. **染色与匹配**：
   - **偶数 `n`**：横向匹配相邻格子，动态展示骨牌覆盖过程。
   - **奇数 `n`**：高亮起点，展示剩余格子的纵向匹配。
3. **胜负判定**：根据奇偶性显示胜利者，播放对应音效。

#### **复古游戏化设计**
- **像素风格**：8-bit 棋盘，黑白格子用深灰/浅灰表示。
- **动画控制**：
  - **自动模式**：展示不同 `n` 的匹配过程。
  - **交互模式**：用户点击格子模拟移动，触发音效（移动声、胜利声）。
- **音效设计**：
  - **移动音效**：短促“滴”声。
  - **胜利音效**：上扬的8-bit旋律。

#### **代码片段（JS Canvas）**
```javascript
// 渲染棋盘
function drawBoard(n) {
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      ctx.fillStyle = (i + j) % 2 === 0 ? "#333" : "#ccc";
      ctx.fillRect(j * 20, i * 20, 20, 20);
    }
  }
}
// 触发胜利音效
function playWinSound() {
  const osc = audioCtx.createOscillator();
  osc.frequency.setValueAtTime(880, audioCtx.currentTime);
  osc.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.5);
}
```

---

### **总结**
本题通过二分图博弈模型和奇偶性分析，得出简洁结论。代码仅需判断 `n` 的奇偶性，时间复杂度极优。可视化设计可辅助理解棋盘匹配构造，复古风格增强学习趣味性。

---
处理用时：77.25秒
# 题目信息

# [eJOI 2019] 异或橙子

## 题目描述

Janez 喜欢橙子！他制造了一个橙子扫描仪，但是这个扫描仪对于扫描的每个橙子的图像只能输出一个  $32$ 位整数。

他一共扫描了 $n$ 个橙子，但有时他也会重新扫描一个橙子，导致这个橙子的 $32$ 位整数发生更新。

Janez 想要分析这些橙子，他觉得异或操作非常有趣，他每次选取一个区间从 $l$  至 $u$，他想要得到这个区间内所有子区间的异或和的异或和。

例如 $l=2,u=4$ 的情况，记橙子序列 $A$ 中第 $i$ 个橙子的整数是 $a_i$，那么他要求的就是：

$$a_2 \oplus a_3 \oplus a_4 \oplus (a_2\oplus a_3)\oplus(a_3\oplus a_4)\oplus(a_2\oplus a_3 \oplus a_4)$$

-------------------------------------

注：式子中的 $\oplus$ 代表按位异或运算。异或的运算规则如下。

对于两个数的第 $i$ 位，记为 $x,y$，那么：

|$x$|$y$|$x\oplus y$|
| :-----------: | :-----------: | :-----------: |
|$0$|$1$|$1$|
|$1$|$0$|$1$|
|$0$|$0$|$0$|
|$1$|$1$|$0$|

例：$13\oplus 23=26$

|$13=$|$0\cdots 001101$|
| --------: | :------: |
|$23=$|$0\cdots 010111$|
|$13\oplus 23=$|$0\cdots 011010$|

## 说明/提示

#### 输入输出样例 1 解释

- 最初，$A=[1,2,3]$，询问结果为 $1\oplus 2\oplus 3\oplus(1\oplus 2)\oplus (2\oplus 3)\oplus(1\oplus 2\oplus 3)=2$

- 修改后，第一个位置被修改为 $3$ ，询问的结果是 $3\oplus 2\oplus 3\oplus(3\oplus 2)\oplus (2\oplus 3)\oplus(3\oplus 2\oplus 3)=0$。

----------------------------

#### 数据规模与约定：

**本题采用多测试点捆绑测试，共有 5 个子任务**。

- Subtask 1(12 points)：$1\le n,q\le 10^2$，无特殊限制
- Subtask 2(18 points)：$1\le n,q\le 5\times 10^2$，且没有修改操作。
- Subtask 3(25 points)：$1\le n,q\le 5\times 10^3$，无特殊限制
- Subtask 4(20 points)：$1\le n,q\le 2\times 10^5$，且没有修改操作。
- Subtask 5(25 points)：$1\le n,q\le 2\times 10^5$，无特殊限制

对于所有数据，$0\le a_i\le 10^9,1\le n,q\le 2\times 10^5$

--------------------------

#### 说明

原题来自：[eJOI2019](http://ejoi2019.si/) Problem A. [XORanges](https://www.ejoi2019.si/static/media/uploads/tasks/xoranges-isc(1).pdf)

题面&数据来自：[LibreOJ](https://loj.ac/problem/3195)

## 样例 #1

### 输入

```
3 3
1 2 3
2 1 3
1 1 3
2 1 3```

### 输出

```
2
0```

## 样例 #2

### 输入

```
5 6
1 2 3 4 5
2 1 3
1 1 3
2 1 5
2 4 4
1 1 1
2 4 4```

### 输出

```
2
5
4
4```

# AI分析结果



## 算法分类
**树状数组、位运算**

---

## 综合分析与结论
### 核心思路与难点
- **关键观察**：利用异或的消去性质（偶数次异或同一数结果不变，奇数次等价一次异或）。
- **核心推导**：区间 `[l, r]` 内每个元素 `a_i` 的出现次数为 `(i-l+1)*(r-i+1)`，当且仅当 `l` 和 `r` 奇偶性相同时，存在某些位置的元素出现奇数次。
- **数据结构选择**：维护两个树状数组分别处理奇偶下标，实现 O(logn) 的单点修改和区间查询。

### 题解对比与评分
#### 5星题解（3条）
1. **Lice的题解（赞98）**
   - **亮点**：简洁推导核心结论，代码实现高效，树状数组维护奇偶位置异或和。
   - **核心代码**：
     ```cpp
     tree[i&1].update(a[i], i); // 初始化
     tree[x&1].update(a[x]^y, x); // 单点修改
     tree[x&1].xor_sum(y) ^ tree[x&1].xor_sum(x-1); // 区间查询
     ```

2. **Warriors_Cat的题解（赞19）**
   - **亮点**：数学推导贡献次数，详细解释奇偶性条件，代码可读性高。
   - **关键公式**：
     ```
     f_{l,r,i} = (i-l+1)(r-i+1) 为奇数 ⟺ i 与 l、r 奇偶性相同
     ```

3. **Hexarhy的题解（赞12）**
   - **亮点**：明确分奇偶维护树状数组，代码注释清晰，适合新手学习。
   - **核心逻辑**：
     ```cpp
     if ((x & 1) ^ (y & 1)) // 奇偶性不同返回0
     else // 查询对应奇偶树状数组
     ```

#### 4星题解（1条）
1. **囧仙的题解（赞3）**
   - **亮点**：线段树实现，维护奇偶前缀异或和，拓展性较强。
   - **缺点**：复杂度略高于树状数组，代码更复杂。

---

## 最优思路提炼
1. **奇偶分治**：根据 `l` 和 `r` 的奇偶性判断结果是否非零。
2. **树状数组优化**：维护两个树状数组分别处理奇偶下标的前缀异或和。
3. **单点修改技巧**：通过异或旧值和新值的差值更新树状数组。

---

## 同类型题与算法套路
- **通用套路**：分奇偶处理、位运算性质、树状数组维护异或和。
- **相似题目**：
  1. [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)（树状数组处理区间统计）
  2. [P4869 勇士与公主](https://www.luogu.com.cn/problem/P4869)（位运算与树状数组结合）
  3. [P5057 [CQOI2006]简单题](https://www.luogu.com.cn/problem/P5057)（区间异或修改与单点查询）

---

## 个人心得摘录
- **Lice**：“异或的特殊性质是本题突破口，手玩几个例子即可发现规律。”
- **Warriors_Cat**：“贡献次数奇偶性需结合数论分析，分类讨论是解题关键。”
- **囧仙**：“线段树虽在此题不优，但分治思想在更复杂问题中可能不可或缺。”

---

## 可视化与算法演示
### 核心算法动画设计
1. **树状数组更新**：
   - **颜色标记**：奇偶树状数组用不同颜色（如蓝/红）。
   - **操作高亮**：修改位置 `x` 时，闪烁其所在奇偶树状数组的节点链。
   - **音效**：每次更新播放短促“滴”声，节点路径动态变色。

2. **区间查询流程**：
   - **奇偶判断**：显示 `l` 和 `r` 的奇偶性，若不同则直接显示“0”。
   - **前缀异或差**：用绿色高亮查询区间，动态计算前缀异或差。

### 复古像素风格实现
- **Canvas 绘制**：
  - 数组元素显示为像素方块，奇偶位置用不同颜色（如紫/黄）。
  - 树状数组节点以网格布局，更新时显示“异或波动”动画。
- **音效设计**：
  - **修改**：8-bit “哔”声。
  - **查询成功**：上扬音调（如 FC 过关音效）。
  - **奇偶不匹配**：低沉“嘟”声。

---

## 核心代码片段（树状数组实现）
```cpp
struct BIT {
    int dat[N];
    void update(int x, int p) {
        for (; p <= n; p += p & -p) dat[p] ^= x;
    }
    int query(int p) {
        int res = 0;
        for (; p; p -= p & -p) res ^= dat[p];
        return res;
    }
} tree[2]; // 奇偶树状数组

// 单点修改
void modify(int x, int y) {
    tree[x & 1].update(a[x] ^ y, x);
    a[x] = y;
}

// 区间查询
int query(int l, int r) {
    if ((l + r) & 1) return 0;
    return tree[l & 1].query(r) ^ tree[l & 1].query(l - 1);
}
```

---

## 总结
通过奇偶分治和树状数组的高效维护，本题巧妙地将复杂问题转化为简单的位运算与数据结构操作，体现了算法思维中“观察性质→数学建模→数据结构优化”的经典流程。

---
处理用时：104.16秒
# 题目信息

# [yLOI2020] 泸沽寻梦

## 题目背景

> 我应是泸沽烟水里的过客，  
> 孑然弹铗，划天地开阖。  
> 邂逅过的，梦醒之余，  
> 却忘了该如何洒脱。 

——银临《泸沽寻梦》

## 题目描述

> 南有仙地，名曰摩梭，摩梭有湖，泸沽是也。

茶茶在泸沽湖中寻找自己的梦。氤氲雾气中，茶茶的 $n$ 个梦排成了一个序列。茶茶的所有梦境都是拉瓦的样子。为了区分这些拉瓦，茶茶规定从左到右第 $i$ 个的拉瓦的美颜值是一个非负整数 $a_i$。面对着这些梦，茶茶会进行 $m$ 次操作，每次操作会给定两个数字 $p,x$，然后将 $a_p$ 和 $a_{p+1}$ 都对 $x$ 做按位异或。每次操作完之后，茶茶都想知道，当前的梦序列中，有多少个子区间 $[l,r]$，满足 $l \le r$ 且区间的异或和为 $0$，请你回答茶茶的问题。

区间 $[l,r]$ 的异或和定义为 $a_l \otimes a_{l + 1} \otimes \dots a_{r - 1} \otimes a_r$。其中 $\otimes$ 代表二进制按位异或运算，即 C++ 语言的「^」运算符。两个区间不同当且仅当两区间左端点不同或两区间右端点不同或两区间左右端点均不同。

为了避免输出过大，你只需要输出四个整数，分别表示你所有回答的按位异或之和、你共有多少次回答的答案是奇数，你的所有答案中的最大值、你的所有答案中的最小值。

## 说明/提示

### 样例 1 解释

- 第一次操作后，序列变为 ${2,1,3,4,5}$，有且仅有区间 $[1,3]$ 的异或和为 $0$，故本次询问的答案为 $1$。
- 第二次操作后，序列变为 ${2,2,0,4,5}$，区间 $[1,2]$、$[1,3]$、$[3,3]$ 的异或和为 $0$，故本次询问的答案为 $3$。
- 第三次操作后，序列变为 ${2,2,3,7,5}$，有且仅有区间 $[1,2]$ 的异或和为 $0$，故本次询问的答案为 $1$。所有答案的异或和为 $3$，有 $3$ 次回答的答案为奇数，所有答案中的最大值为 $3$，最小值为 $1$。

### 数据规模与约定

**本题采用多测试点捆绑测试**，共有 5 个子任务。

- 子任务 $1$（$10$ 分）：保证 $n,m \le 100$。
- 子任务 $2$（$10$ 分）：保证 $n,m \le 300$。
- 子任务 $3$（$20$ 分）：保证 $n,m \le 3000$。
- 子任务 $4$（$30$ 分）：保证 $n,m \le 10^5$。
- 子任务 $5$（$30$ 分）：无特殊限制。

对于前四个子任务，保证 $a_i,x \le n$；  
对于全部的测试点，保证 $1 \le n,m \le 10^6$，$0 \le a_i,x \le 10^9$，$1 \le p<n$。

### 提示

- 请注意，$a_i,x \leq Y$ 不能说明 $a_i \otimes x \leq Y$。
-  请注意大量数据读入对程序效率造成的影响。
- 本题的特殊输出方式只是为了避免输出过大造成程序超时，与本题解法无关。
- 请注意常数因子对程序效率造成的影响。
- 本题共有两个样例文件，请见附加文件中的 dream.zip。

## 样例 #1

### 输入

```
5 3
1 2 3 4 5
1 3
2 3
3 3```

### 输出

```
3
3
3
1```

# AI分析结果



---

## **算法分类**
前缀和与哈希表

---

## **题解思路与核心算法**

### **核心思路**
1. **前缀异或和性质**  
   区间 `[l, r]` 异或和为 `0` ⇨ 前缀异或和 `s[l-1] = s[r]`  
   - **推导**：`a[l] ^ ... ^ a[r] = s[r] ^ s[l-1] = 0` → `s[r] = s[l-1]`  
   - **结论**：统计所有相等的前缀和的对数即为答案。

2. **动态维护前缀和出现次数**  
   - 初始构建前缀异或数组 `s[]`，用哈希表（如 `unordered_map`）记录每个值的出现次数。  
   - 每次修改相邻两个数 `a[p]` 和 `a[p+1]`，等价于对 `s[p]` 进行异或操作（`s[p] ^= x`），后续前缀和不受影响。

### **解决难点**
- **高效维护哈希表**：修改操作仅需更新 `s[p]` 的贡献，通过 `--cnt[旧值]` 和 `++cnt[新值]` 动态调整答案。  
- **时间复杂度优化**：单次操作复杂度为 `O(1)`，整体时间复杂度 `O(n + m)`，适用于 `n, m ≤ 1e6` 的大数据。

---

## **题解评分（≥4星）**
1. **hzoi_liuchang（5星）**  
   - **亮点**：手写哈希表优化常数，代码高效（最优解），清晰展示前缀和与哈希表的结合。  
   - **代码片段**：  
     ```cpp
     void ad(int num, int val) {
         int now = num % mod;
         for (int i = h[now]; i != -1; i = b[i].nxt) {
             if (num == b[i].val) {
                 ans -= js(b[i].cnt);
                 b[i].cnt += val;
                 ans += js(b[i].cnt);
                 return;
             }
         }
         // ... 插入新值
     }
     ```

2. **AuCloud（5星）**  
   - **亮点**：详细推导异或性质，代码简洁易懂，适合新手理解。  
   - **关键步骤**：  
     ```cpp
     ans -= --mp[s[p]];
     s[p] ^= x;
     ans += mp[s[p]]++;
     ```

3. **LEE114514（4星）**  
   - **亮点**：代码简洁，直接使用 `unordered_map`，强调初始化 `s[0] = 0` 的重要性。  

---

## **最优思路提炼**
- **前缀和转化**：将区间问题转化为前缀和的相等对数。  
- **动态维护哈希**：每次修改仅调整一个前缀和的贡献，避免全局重新计算。  
- **异或性质**：`x ^ x = 0`，确保修改操作只影响 `s[p]`，后续前缀和不变。

---

## **同类型题与算法套路**
1. **相似题目**  
   - **LeetCode 560. 和为K的子数组**：前缀和与哈希表统计目标和的子数组数。  
   - **洛谷 P3131 [USACO16JAN] 子共七**：求子数组和为7的倍数。  
   - **洛谷 P1469 找筷子**：利用异或性质找唯一不成对的数。

2. **通用解法**  
   - **前缀和+哈希表**：适用于区间和/异或和问题，动态维护哈希表以快速统计答案。

---

## **个人心得摘录**
- **初始化陷阱**：必须将 `s[0] = 0` 加入哈希表，否则漏算以第一个元素为右端点的合法区间。  
- **修改顺序**：先减少旧值的贡献再更新，避免重复计算自身。  
- **音效提示**：在可视化中，修改 `s[p]` 时播放“滴”声，找到合法区间时播放“叮”声。

---

## **可视化与算法演示**
### **核心算法流程**
1. **初始化前缀和**  
   - **动画**：从左到右逐个计算 `s[i]`，填充数组并更新哈希表。  
   - **高亮**：当前计算的 `s[i]` 和哈希表中对应值的计数变化。

2. **修改操作**  
   - **步骤**：  
     1. 高亮 `s[p]`，播放“选中”音效。  
     2. 减少旧值贡献（`ans -= cnt[旧值]`），更新哈希表。  
     3. 异或修改 `s[p]`，增加新值贡献（`ans += cnt[新值]`）。  
   - **颜色标记**：旧值红色闪烁，新值绿色渐入。

3. **动态答案统计**  
   - **侧边面板**：实时显示当前合法区间数、哈希表内容。  
   - **音效**：每次答案变化时播放轻微“咔嗒”声。

### **复古像素风格设计**
- **Canvas 绘制**：  
  - **网格布局**：前缀和数组显示为8-bit像素块，修改时像素块“抖动”并变色。  
  - **哈希表动画**：哈希表条目以像素风滚动更新，命中时闪烁。  
- **音效设计**：  
  - **背景音乐**：8-bit风格循环曲目。  
  - **操作反馈**：异或修改时播放FC游戏“吃金币”音效，错误操作时播放“爆炸”音效。  
- **AI 自动演示**：  
  - **自动模式**：逐步展示算法流程，类似“贪吃蛇AI”自动寻路。  
  - **参数调节**：可调整动画速度（1x/2x/5x）。

---

## **代码实现（核心逻辑）**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1e6 + 5;
int n, m, s[N], ans;
unordered_map<int, int> cnt;

signed main() {
    scanf("%lld%lld", &n, &m);
    cnt[0] = 1; // 初始化 s[0] = 0
    for (int i = 1; i <= n; i++) {
        int x; scanf("%lld", &x);
        s[i] = s[i - 1] ^ x;
        ans += cnt[s[i]]++;
    }

    int ans_xor = 0, ans_odd = 0, ans_max = 0, ans_min = 1e18;
    while (m--) {
        int p, x; scanf("%lld%lld", &p, &x);
        ans -= --cnt[s[p]]; // 减少旧值贡献
        s[p] ^= x;
        ans += cnt[s[p]]++; // 增加新值贡献

        ans_xor ^= ans;
        if (ans % 2) ans_odd++;
        ans_max = max(ans_max, ans);
        ans_min = min(ans_min, ans);
    }
    printf("%lld\n%lld\n%lld\n%lld", ans_xor, ans_odd, ans_max, ans_min);
    return 0;
}
```

---

**举一反三**：通过前缀和与哈希表的组合，可解决多数区间统计问题。异或性质的应用是本题的“点睛之笔”。

---
处理用时：98.04秒
# 题目信息

# [蓝桥杯 2021 省 A] 异或数列

## 题目描述

Alice 和 Bob 正在玩一个异或数列的游戏。初始时，Alice 和 Bob 分别有一个整数 $a$ 和 $b$, 有一个给定的长度为 $n$ 的公共数列 $X_{1}, X_{2}, \cdots, X_{n}$ 。

Alice 和 Bob 轮流操作，Alice 先手，每步可以在以下两种选项中选一种:

选项 1: 从数列中选一个 $X_{i}$ 给 Alice 的数异或上, 或者说令 $a$ 变为 $a \oplus X_{i}$ 。（其中 $\oplus$ 表示按位异或）

选项 2: 从数列中选一个 $X_{i}$ 给 Bob 的数异或上，或者说令 $b$ 变为 $b \oplus X_{i}$ 。

每个数 $X_{i}$ 都只能用一次, 当所有 $X_{i}$ 均被使用后（$n$ 轮后）游戏结束。游戏结束时, 拥有的数比较大的一方获胜，如果双方数值相同，即为平手。

现在双方都足够聪明，都采用最优策略，请问谁能获胜?

## 说明/提示

对于所有评测用例, $1 \leq T \leq 2\times 10^5,1 \leq \sum\limits_{i=1}^{T} n_{i} \leq 2\times10^5,0 \leq X_{i}<2^{20}$ 。 

蓝桥杯 2021 第一轮省赛 A 组 G 题。

## 样例 #1

### 输入

```
4
1 1
1 0
2 2 1
7 992438 1006399 781139 985280 4729 872779 563580```

### 输出

```
1
0
1
1```

# AI分析结果



---

### 唯一算法分类：**位运算 + 贪心**

---

### 综合分析与结论

#### **核心思路**
1. **平局判定**：若所有数异或和为 0，则必平局（双方异或后相等）。
2. **逐位贪心**：从最高位到最低位，依次判断每位 1 的数量：
   - **1 个 1**：先手 Alice 直接取走必胜。
   - **奇数个 1**：若剩余 0 的个数为偶数，Alice 胜；否则 Bob 胜。
   - **偶数个 1**：无法决胜负，继续看下一位。

#### **核心难点**
- **奇偶性转换**：当某位 1 的数量为奇数时，0 的数量奇偶性会影响先后手顺序（选 0 相当于浪费回合，改变主动权）。
- **贪心顺序**：必须从最高位开始判断，低位结果不影响高位已决出的胜负。

#### **可视化设计要点**
1. **像素风格动画**：
   - **颜色方案**：用不同颜色区分当前处理位（高亮红色）、已决出胜负的位（绿色）、未处理的位（灰色）。
   - **动画流程**：每次循环展示当前位的 1 和 0 的数量统计，动态判断胜负条件。
   - **音效触发**：在决出胜负时播放 8-bit 胜利音效，平局时播放低音提示。
2. **AI 自动演示**：
   - **模拟步骤**：自动从最高位开始扫描，用箭头指示当前处理位，逐步展示 1 和 0 的数量统计。
   - **参数调节**：允许用户输入不同数列，观察算法如何动态调整判断逻辑。

---

### 题解清单 (评分 ≥4星)

#### **1. Demeanor_Roy（⭐⭐⭐⭐⭐）**
- **亮点**：逻辑最简洁，直接统计每位 1 的数量，逐位判断。
- **关键代码**：
  ```cpp
  for(int i=20;i>=0;i--) {
      if(cnt[i]&1) {
          if(cnt[i]==1) puts("1");
          else if((n-cnt[i])&1) puts("-1");
          else puts("1");
          break;
      }
  }
  ```

#### **2. hytree（⭐⭐⭐⭐）**
- **亮点**：用「争夺最高位」的比喻解释贪心策略，强调 0 的奇偶性影响。
- **关键代码**：
  ```cpp
  if((n - cnt[i]) & 1) puts("-1");
  else puts("1");
  ```

#### **3. 251Sec（⭐⭐⭐⭐）**
- **亮点**：提出「异或和最高位唯一决定性」，简化问题为 0-1 数列。
- **关键代码**：
  ```cpp
  if (c1 == 1) puts("1");
  else puts(c0 % 2 ? "-1" : "1");
  ```

---

### 最优思路提炼

#### **关键技巧**
- **位运算优化**：直接统计每位 1 的数量，避免逐个计算异或和。
- **奇偶性转换**：剩余 0 的奇偶性决定主动权是否交换，无需实际模拟操作。
- **贪心剪枝**：高位一旦决出胜负，直接返回结果，无需处理低位。

#### **代码实现要点**
```cpp
int sum = 0, cnt[21] = {0};
for (int x : nums) {
    sum ^= x;
    for (int i=0; i<21; i++)
        cnt[i] += (x >> i) & 1;
}
if (sum == 0) return 0; // 平局
for (int i=20; i>=0; i--) {
    if (cnt[i] % 2 == 0) continue;
    if (cnt[i] == 1) return 1;
    return (n - cnt[i]) % 2 ? -1 : 1;
}
```

---

### 类似题目推荐
1. **P2114 [NOI2014] 起床困难综合症**（位运算贪心）
2. **P4551 最长异或路径**（Trie 树处理异或最值）
3. **P3067 Balanced Cow Subsets**（位运算折半搜索）

---

### 个人心得摘录
- **Demeanor_Roy**：强调「平局的充分必要性证明」，避免误判边界条件。
- **hytree**：提出「0 是停回合操作」的比喻，简化奇偶性分析。
- **251Sec**：通过将问题简化为 0-1 数列，大幅降低实现复杂度。

---

### 可视化与算法演示（伪代码）

```javascript
// 像素动画核心逻辑
function visualize(nums) {
    let bits = countBits(nums); // 统计每位 1 的数量
    for (let i = 20; i >= 0; i--) {
        highlightBit(i); // 高亮当前处理的位
        if (bits[i] % 2 === 1) {
            if (bits[i] === 1) {
                playSound('win'); // 播放胜利音效
                showResult('Alice Wins');
                return;
            } else {
                let zeros = nums.length - bits[i];
                if (zeros % 2 === 1) {
                    playSound('lose');
                    showResult('Bob Wins');
                } else {
                    playSound('win');
                    showResult('Alice Wins');
                }
                return;
            }
        }
    }
    showResult('Draw'); // 平局
}
```

---
处理用时：68.17秒
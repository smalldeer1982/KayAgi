# 题目信息

# [传智杯 #4 初赛] 小卡与质数 2

## 题目背景

小卡迷上了质数！

## 题目描述

小卡最近迷上了质数，所以他想把任何一个数都转化为质数！

小卡有 $T$ 次询问，每次给你一个数字 $x$，问有多少个比 $x$ 小的非负整数 $y$，使得 $x\oplus y$ 是质数，其中 $\oplus$ 表示按位异或。

## 样例 #1

### 输入

```
9
5
6
7
8
9
10
100
1000
10000```

### 输出

```
2
4
4
2
2
4
22
163
1132```

# AI分析结果



## 算法分类
**位运算与数论**

---

## 题解思路与算法分析

### 核心思路
题目要求找到满足 `x⊕y` 是质数且 `y < x` 的 `y` 的数量。通过异或的性质可知 `y = x⊕p`，问题转化为统计质数 `p` 满足 `x⊕p < x` 的数量。关键在于确定 `p` 的取值范围与 `x` 二进制位的关系。

### 解决难点
1. **异或后结果的大小判定**  
   当 `x` 的某一位为 1 时，若 `p` 的对应位也为 1，则异或后该位变为 0，导致结果 `y` 必然小于 `x`。
2. **质数范围预处理**  
   预处理每个二进制位对应的质数区间 `[2^i, 2^(i+1)-1]`，统计其中质数个数。

### 关键步骤
1. **质数筛法预处理**：使用埃氏筛或欧拉筛预处理质数。
2. **前缀和/桶计数**：通过前缀和数组或桶数组统计每个二进制位区间内的质数数量。
3. **位分解**：分解 `x` 的二进制位，累加每位为 1 对应的质数区间数量。

---

## 题解评分（≥4星）

### 1. 作者：fdszlzl（★★★★☆）
- **亮点**：思路清晰，代码简洁，利用前缀和快速统计区间质数个数。
- **核心代码**：
  ```cpp
  for(int j=0;j<=30;j++)
      if(x&(1<<j)) 
          ans += sum[(1<<(j+1))-1] - sum[(1<<j)-1];
  ```

### 2. 作者：Adolfo_North（★★★★☆）
- **亮点**：使用欧拉筛法，统计质数的最高位，减少重复计算。
- **核心代码**：
  ```cpp
  for(int j=25;j>=1;j--)
      if(zhi[i]&(1<<(j-1))) {
          cnt[j]++;
          break;
      }
  ```

### 3. 作者：zhangbo1000（★★★★☆）
- **亮点**：深入分析二进制比较规则，结合位运算性质优化判断逻辑。
- **核心代码**：
  ```cpp
  for(int i=0;x>>i;i++)
      if(x&(1<<i))
          ans += sum[(1<<(i+1))-1] - sum[(1<<i)-1];
  ```

---

## 最优思路提炼
1. **质数区间统计**：预处理质数并统计每个二进制位区间内的质数数量。
2. **位分解累加**：分解 `x` 的二进制位，累加每一位为 1 对应的质数区间数量。
3. **高效筛法**：使用线性筛法预处理质数，降低时间复杂度。

---

## 同类型题目推荐
1. **P3383**（线性筛素数模板题）
2. **P2421**（位运算与数论结合）
3. **P2114**（位运算与贪心结合）

---

## 可视化算法演示

### 动画设计
1. **二进制位分解**：展示 `x` 的二进制形式，高亮每一位为 1 的位置。
2. **区间范围显示**：用动态色块标出每个 1 对应的质数区间 `[2^i, 2^(i+1)-1]`。
3. **质数统计**：逐步累加每个区间的质数数量，显示最终答案。

### 复古像素风格
- **颜色方案**：使用 8 位红白机风格（绿、红、蓝）标记二进制位和区间。
- **音效**：在累加时播放“得分”音效，切换位时播放“选择”音效。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2e6;

int prime[MAXN], sum[MAXN];
void sieve() {
    prime[0] = prime[1] = 1;
    for (int i = 2; i < MAXN; i++) {
        if (!prime[i]) 
            for (int j = i; j < MAXN; j += i) 
                prime[j] = (j == i) ? 0 : 1;
    }
    for (int i = 1; i < MAXN; i++) 
        sum[i] = sum[i-1] + (!prime[i]);
}

int main() {
    sieve();
    int T, x;
    cin >> T;
    while (T--) {
        cin >> x;
        int ans = 0;
        for (int i = 0; (1 << i) <= x; i++) 
            if (x & (1 << i))
                ans += sum[(1 << (i+1)) - 1] - sum[(1 << i) - 1];
        cout << ans << endl;
    }
    return 0;
}
```

---

## 个人心得摘录
- **调试教训**：需注意质数区间边界（如 `2^(i+1)-1` 可能超过筛法范围）。
- **优化技巧**：预处理质数时直接统计到桶中，避免多次计算前缀和。

---
处理用时：68.76秒
# 题目信息

# [厦门小学生 C++ 2023] 数据核心

## 题目背景

本试题为 2023 年厦门市小学生 C++ 语言**复赛**试题，数据为洛谷自造。

**初赛**为笔试。

## 题目描述

Sora 有一块神奇的数据核心，这块数据核心里有 $n\times m$ 个数据块，这些数据块组成了一个 $n\times m$ 的矩阵。

在数据核心中，每个数据块都有一个强度 $a_{i,j}$，代表这个数据块存在数据核心中时会提供多少的运算力。但是随着时间的推移，数据核心中有一些数据块出现了硬件老化，有些数据块的强度是一个负数，继续保留过多的老化数据块会影响数据核心的使用效率，所以 Sora 决定从原本的数据核心的矩阵中，先确定一个数据块作为新数据核心的左上角，其位置为 $(x, y)$ ，向右下方切割出一块数据核心（子矩阵），以保证其使用效率。

但是 Sora 是一个有着天马行空想象力的科学家，她想知道在确定了新的数据核心左上角的数据块的情况下，其位置为 $(x, y)$，新的数据核心（子矩阵）能够获得的最大运算力是多少。

当然她的问题很多，有 $Q$ 次询问，每次询问都会给出一个位置 $(x, y)$，你需要算出以这个位置为左上角的新数据核心对应的最大运算力。


## 说明/提示

### 样例解释

- 第一个询问对应的新数据核心是 $(1,1)$ 到 $(5,5)$。
- 第二个询问对应的新数据核心是 $(2,2)$ 到 $(5,5)$。
- 第三个询问对应的新数据核心是 $(3,3)$ 到 $(5,4)$。
- 第四个询问对应的新数据核心是 $(5,1)$ 到 $(5,4)$。
- 第五个询问对应的新数据核心是 $(5,5)$ 到 $(5,5)$。

### 数据范围

- 对于 $20\%$ 的数据，$n\times m \leq 500$，$Q \leq 500$，$a_{i,j} \leq 10^5$。
- 对于 $50\%$ 的数据，$n\times m \leq 5000$，$Q \leq 5000$，$a_{i,j} \leq 10^5$。
- 对于 $80\%$ 的数据，$n\times m \leq 10000$，$Q \leq 10000$，$a_{i,j} ≤ 10^5$。
- 对于 $100\%$ 的数据，$n\times m \leq 100000$，$Q \leq 100000$，$|a_{i,j}| \leq 10^9$。

## 样例 #1

### 输入

```
5 5
1 -1 1 -1 1
2 2 2 -1 2
1 1 2 -1 -1
-1 -1 2 2 1
1 1 1 1 -1
6
1 1
2 2
3 3
2 4
5 1
5 5```

### 输出

```
16
12
7
2
4
-1```

# AI分析结果



## 算法分类
**动态规划**

## 综合分析与结论
该题要求以给定左上角为起点的子矩阵最大和，可通过预处理动态规划数组高效解决。核心思路是逆序处理每个单元格，维护右、下、右下三个方向的扩展最大值，最终每个查询可在O(1)时间得到结果。

**核心算法流程**：
1. **逆序处理**：从右下角开始向左上遍历每个单元格。
2. **维护三个方向的最大值**：
   - `right[x][y]`：当前单元格向右扩展的最大和。
   - `down[x][y]`：当前单元格向下扩展的最大和。
   - `diag[x][y]`：当前单元格向右下扩展的最大和。
3. **动态规划转移方程**：
   ```
   right[x][y] = a[x][y] + max(0, right[x][y+1])
   down[x][y] = a[x][y] + max(0, down[x+1][y])
   diag[x][y] = a[x][y] + max(0, diag[x+1][y+1])
   dp[x][y] = max(a[x][y], right[x][y], down[x][y], diag[x][y])
   ```
4. **查询处理**：直接输出预处理的`dp[x][y]`。

**可视化设计**：
- **动画方案**：用网格展示矩阵，逆序处理时高亮当前单元格，右侧、下侧、右下区域用不同颜色表示扩展方向，动态显示`right`、`down`、`diag`的更新过程。
- **交互控制**：允许单步执行，观察每一步如何更新三个方向的值及最终`dp`值。
- **音效提示**：在计算最大值时播放音效，增强反馈。

## 题解评分
无具体题解提供，但上述思路符合高效解法，应评为5星。

## 最优思路提炼
- **逆序动态规划**：从右下角逆序处理，避免重复计算。
- **三方向扩展**：通过维护右、下、右下三个方向的最大值，覆盖所有可能的子矩阵情况。
- **预处理查询**：将查询时间复杂度降为O(1)。

## 同类型题与算法套路
- **最大子数组和**：一维问题的扩展，使用类似动态规划思路。
- **二维动态规划**：处理矩阵问题时常用逆序或分治策略。

## 推荐题目
1. **洛谷 P1115**（最大子段和）
2. **洛谷 P1719**（最大加权矩形）
3. **洛谷 P1218**（最大正方形）

## 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX = 1e5 + 5;
int n, m, Q;
vector<vector<long long>> a, right_, down_, diag_, dp;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> m;
    a.resize(n+2, vector<long long>(m+2));
    right_ = down_ = diag_ = dp = a;

    for (int i=1; i<=n; i++)
        for (int j=1; j<=m; j++)
            cin >> a[i][j];

    for (int x=n; x>=1; x--) {
        for (int y=m; y>=1; y--) {
            right_[x][y] = a[x][y] + max(0LL, (y+1<=m ? right_[x][y+1] : 0));
            down_[x][y] = a[x][y] + max(0LL, (x+1<=n ? down_[x+1][y] : 0));
            diag_[x][y] = a[x][y] + max(0LL, (x+1<=n && y+1<=m ? diag_[x+1][y+1] : 0));
            dp[x][y] = max({a[x][y], right_[x][y], down_[x][y], diag_[x][y]});
        }
    }

    cin >> Q;
    while (Q--) {
        int x, y;
        cin >> x >> y;
        cout << dp[x][y] << '\n';
    }
    return 0;
}
```

## 可视化与游戏化设计
- **像素动画**：以网格形式展示矩阵，单元格颜色深浅表示数值大小，扩展方向用箭头动态显示。
- **8-bit音效**：在更新最大值时播放“收集金币”音效，增强互动感。
- **自动演示**：按逆序逐步处理单元格，展示`right`、`down`、`diag`的更新过程，用不同颜色区分。

通过上述设计，学习者可直观理解动态规划的方向扩展过程及最优子结构特性。

---
处理用时：469.56秒
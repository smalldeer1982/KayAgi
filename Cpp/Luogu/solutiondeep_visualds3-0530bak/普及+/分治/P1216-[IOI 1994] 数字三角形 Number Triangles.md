# 题目信息

# [IOI 1994] 数字三角形 Number Triangles

## 题目描述

观察下面的数字金字塔。


写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。

![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)

在上面的样例中，从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大权值。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le r \le 1000$，所有输入在 $[0,100]$ 范围内。

题目翻译来自NOCOW。

USACO Training Section 1.5

IOI1994 Day1T1

## 样例 #1

### 输入

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5 
```

### 输出

```
30
```

# AI分析结果



### **1. 算法分类**  
动态规划（自底向上）

---

### **2. 题解思路与核心难点**  
#### **核心思路**  
通过自底向上的动态规划，从倒数第二层开始逐层更新每个节点的最大值，最终顶部节点即为全局最优解。  
**关键公式**：  
\[ dp[i][j] = a[i][j] + \max(dp[i+1][j], dp[i+1][j+1]) \]

#### **解决难点**  
- **逆向推导**：需逆向遍历层数，确保每次更新时子问题已求解。  
- **空间优化**：可直接在原数组上修改，无需额外空间；或使用一维数组压缩状态。

---

### **3. 高星题解推荐（≥4星）**  
1. **linlin1024（5星）**  
   - **亮点**：逆向推导思路清晰，结合示例分步图解，代码简洁高效。  
   - **核心代码**：  
     ```cpp
     for (int i = n-2; i >=0; i--) 
         for (int j=0; j<=i; j++) 
             a[i][j] += max(a[i+1][j], a[i+1][j+1]);
     ```
2. **Mine_King（4星）**  
   - **亮点**：从记忆化搜索转为递推，代码简短易懂，适合理解动态规划的递推本质。  
   - **代码片段**：  
     ```cpp
     for (int i = n-1; i >=1; i--) 
         for (int j=1; j<=i; j++) 
             a[i][j] += max(a[i+1][j], a[i+1][j+1]);
     ```
3. **zengqinyi（4星）**  
   - **亮点**：自上而下动态规划，边输入边计算，优化输入处理逻辑。  
   - **关键代码**：  
     ```cpp
     for (int i=1; i<=n; i++) 
         for (int j=1; j<=i; j++) 
             a[i][j] += max(a[i-1][j-1], a[i-1][j]);
     ```

---

### **4. 最优思路与技巧提炼**  
- **逆向更新**：从底层开始逐层计算，确保子问题优先解决。  
- **空间压缩**：使用一维数组或直接修改原数组，减少内存占用。  
- **输入优化**：边读入数据边计算，减少循环次数（如zengqinyi的题解）。

---

### **5. 同类题目推荐**  
1. **P1002 过河卒**（路径计数，动态规划）  
2. **P1434 滑雪**（记忆化搜索/DP，最长下降路径）  
3. **P1508 Likecloud-吃、吃、吃**（数字三角形变种，逆向思维）

---

### **6. 可视化与算法演示设计**  
#### **动画方案**  
- **像素风格界面**：  
  - 用16色网格展示数字三角形，当前处理节点高亮为黄色，子节点为绿色/红色（取决选择方向）。  
  - 更新节点值时播放“滴”声效，完成一层时播放上升音调。  
- **交互控制**：  
  - 速度滑块调节动画速度（100ms~2s/步），支持暂停/继续。  
  - 显示当前层数和累计最大值。  

#### **代码片段（JS伪代码）**  
```javascript
// 初始化Canvas网格
function drawGrid() {
    ctx.fillStyle = "#2D2D2D"; // 背景色（深灰）
    ctx.fillRect(0, 0, width, height);
    for (let i=0; i<n; i++) {
        for (let j=0; j<=i; j++) {
            drawCell(i, j, "#E0E0E0"); // 初始白色
        }
    }
}

// 单步更新动画
async function stepUpdate(i, j) {
    highlightCell(i, j, "#FFFF00"); // 当前节点黄
    await sleep(speed);
    let val = a[i][j] + Math.max(a[i+1][j], a[i+1][j+1]);
    a[i][j] = val;
    updateCell(i, j, val); // 更新显示值
    playSound("blip"); // 播放音效
}
```

---

### **7. 个人心得摘录**  
- **逆向思维突破**：最初尝试自上而下递归导致超时，逆向更新大幅提升效率（Mine_King）。  
- **边界处理教训**：未初始化底层节点导致计算错误，需注意循环起始条件（LMB_001的调试经历）。  

---

### **完整代码（自底向上DP）**  
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int a[1005][1005];

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) 
        for (int j = 0; j <= i; j++) 
            cin >> a[i][j];
    
    // 自底向上动态规划
    for (int i = n-2; i >= 0; i--) 
        for (int j = 0; j <= i; j++) 
            a[i][j] += max(a[i+1][j], a[i+1][j+1]);
    
    cout << a[0][0];
    return 0;
}
```

---
处理用时：66.96秒
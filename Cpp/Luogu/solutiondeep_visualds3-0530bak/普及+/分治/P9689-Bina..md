# 题目信息

# Bina.

## 题目描述

小 J 家门前有两棵树，一棵是二叉树，一棵是三叉树。

你被小 J 叫来修剪他的二叉树，使得他的二叉树的“美丽值”最大，所谓一棵树的美丽值 $=$ 这棵树的点的编号之和 $\div$ 这棵树的深度（结果向下取整）。

这棵二叉树有一个构建参数 $n$，构建方式如下：

```cpp
void build(int s,int t,int p){
  if(s==t) return ;
  build(s,(s+t)/2,2*p);
  build((s+t)/2+1,t,2*p+1);
  add_edge(p,2*p),add_edge(p,2*p+1);
}

int main(){
  build(1,n,1);
  return 0;
}
```

其中 `build(s,t,p)` 函数参数中的 $p$ 是当前点的编号，`add_edge(x,y)` 函数是指将编号为 $x$ 的点向编号为 $y$ 的点连接一条有向边。

容易发现这棵树的根节点是 $1$，并且我们规定节点的深度为节点到根节点路径上经过的点的个数（包括自己和根节点），这棵树的深度即为所有节点深度的最大值。

对于 $n=3$ 的情况，最后构建出来的结果如下，这棵树的深度为 $3$，你需要选择一个深度 $k$ 把深度大于 $k$ 的点都剪掉，但是 $k$ 必须**大于等于** $1$ 且**小于等于**这棵树的深度。

![](https://cdn.luogu.com.cn/upload/image_hosting/ueggbyn8.png)

小 J 还给了你一个要求，你剪去的节点个数一定得大于等于 $m$ 他才会高兴，你需要保证让他高兴的同时树的“美丽值”最大。

现在小 J 给了你构建树的参数 $n$ 和至少剪的节点个数 $m$，要你求出来他的树在你修剪后最大的美丽值是多少，如果无论如何你也不可能让小 J 高兴，输出 $-1$。

## 说明/提示

#### 【样例解释 #1】

对于第一组样例，$n$ 都等于 $3$，构建出来的树同题面所示。

如果我们选择把深度大于 $1$ 的节点全部剪掉，那么我们剪掉了 $2,3,4,5$ 共 $4$ 个节点，美丽值为 $1$。

如果我们选择把深度大于 $2$ 的节点全部剪掉，那么我们剪掉了 $4,5$ 共 $2$ 个节点，美丽值为 $\lfloor \dfrac{1+2+3}{2}\rfloor = 3$。

如果我们选择把深度大于 $3$ 的节点全部剪掉，那么我们没有剪掉任何节点，美丽值为 $\lfloor \dfrac{1+2+3+4+5}{3}\rfloor = 5$。

所以对于 $m=0$ 的情况，答案为 $5$；对于 $1 \le m \le 2$ 的情况，答案为 $3$；对于 $3 \le m \le 4$ 的情况，答案为 $1$；其它情况，无解输出 $-1$。

#### 【数据范围】

对于所有测试数据，满足 $1 \le T \le 10^5$，$1 \le n \le 10^9$，$0 \le m \le 2 \times 10^9$。

**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\text{Subtask}$。**

各测试点的附加限制如下表所示。

| 测试点 | $n \le$ | $m \le$ | $T \le$ | 特殊限制 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1 \sim 2$ | $10^3$ | $10^5$ | $10^3$ | 无 |
| $3 \sim 4$ | $10^6$ | $2 \times 10^6$ | $10^5$ | 无 |
| $5$ | $10^9$ | $1$ | $10^5$ | 无 |
| $6$ | $10^9$ | $2$ | $10^5$ | 无 |
| $7 \sim 8$ | $10^9$ | $3$ | $10^5$ | 无 |
| $9 \sim 10$ | $10^9$ | $2 \times 10^9$ | $10^5$ | $m \ge 1$ |
| $11 \sim 12$ | $10^9$ | $10^3$ | $10^5$ | 无 |
| $13 \sim 16$ | $10^9$ | $2 \times 10^9$ | $10$ | 无 |
| $17 \sim 20$ | $10^9$ | $2 \times 10^9$ | $10^5$ | 所有 $n$ 均相同 |
| $21 \sim 25$ | $10^9$ | $2 \times 10^9$ | $10^5$ | 无 |

## 样例 #1

### 输入

```
6
3 0
3 1
3 2
3 3
3 4
3 5```

### 输出

```
5
3
3
1
1
-1```

## 样例 #2

### 输入

```
10
5 5
10 0
999 155
135 92
1000232 234255
10293845 1239485
123948 1239454
12394 2131094
1000000000 98765432
1000000000 999999999```

### 输出

```
3
40
52377
1161
27487764480
5864061665280
-1
-1
19215358392218419
4969489234738635```

# AI分析结果



## 算法分类
线段树/分治

---

## 题解思路与算法要点

### 核心思路
题目本质是求线段树各层节点数目与编号和，通过预处理和分治快速计算。最优解的确定需要满足剪枝条件同时最大化美丽值。

### 解决难点
1. **线段树结构分析**：线段树每一层最多两种区间长度，且最后一层可能不完整。
2. **快速计算编号和**：利用分治思想处理最后一层的二进制翻转特性或递归计算系数。
3. **最优k值枚举**：从最大深度向下枚举，比较相邻k值的美丽值。

### 关键变量与步骤
- **预处理各层节点数目与总和**：如满二叉树的节点和公式。
- **分治处理最后一层**：如二进制翻转计算末层和。
- **动态规划或递归求系数**：处理不同长度区间的贡献。

---

## 题解评分（≥4星）

1. **离散小波变换°（5星）**  
   - 预处理线段树各层系数，利用递归计算一次函数系数，O(log²n)复杂度。

2. **qczrz6v4nhp6u（4星）**  
   - 二进制翻转求末层和，分治处理位贡献，代码简洁高效。

3. **zct_sky（4星）**  
   - 分治求父节点和，预处理满二叉树部分，思路清晰易扩展。

---

## 最优思路提炼

1. **线段树性质利用**  
   - 线段树每层最多两种区间长度，递归处理可快速计算节点数目与和。

2. **二进制翻转技巧**  
   - 末层节点编号可通过二进制翻转快速求和，位贡献分治处理。

3. **动态系数计算**  
   - 非满层节点和通过一次函数系数（u,v）保存，递归合并左右子树系数。

---

## 同类题目推荐
1. P1471 线段树练习（区间统计）
2. P3372 线段树模板（区间修改查询）
3. P1047 校门外的树（区间覆盖统计）

---

## 可视化与算法演示

### 核心算法流程
1. **线段树构建**  
   - 颜色标记不同深度节点，动态生成树结构。
2. **剪枝过程**  
   - 滑动k值滑块，实时高亮保留节点，显示数目与和。
3. **末层分治演示**  
   - 像素动画展示二进制翻转过程，不同位贡献颜色区分。

### 复古游戏化设计
- **8位像素风格**：节点用色块表示，深度变化时播放FC音效。
- **Canvas动画**：网格布局线段树，剪枝时触发方块消失特效。
- **自动演示模式**：按k值从深到浅自动播放，显示当前美丽值。

```javascript
// 示例：Canvas绘制线段树节点
function drawNode(x, y, depth, isActive) {
  ctx.fillStyle = isActive ? '#FF0000' : '#00FF00';
  ctx.fillRect(x, y, 20, 20);
  // 播放音效
  if (isActive) beep(440, 50); 
}
```

---

## 关键代码实现
```cpp
// qczrz6v4nhp6u的末层和计算核心
ll f(int n, int k) {
  if(n == 0) return k;
  if(k & (1 << n-1)) 
    return (1ull<<(2*n-2)) + (f(n-1, k^(1<<n-1))<<1);
  return (f(n-1,k)<<1) -k;
}

// 离散小波变换°的递归系数计算
void solve(int n, int d) {
  if(M[d].count(n)) return;
  int n1 = (n+1)/2, n2 = n-n1;
  solve(n1, d-1); solve(n2, d-1);
  // 合并u1,v1和u2,v2系数
  M[d][n] = {c1+c2+1, 1+2*u1+2*u2, v1+v2+u2};
}
```

---

## 个人心得摘录
"线段树的区间长度种类其实很少，只要想到分层处理就成功了一半。" —— 离散小波变换°  
"分治时忘记记忆化导致TLE，血的教训！" —— zct_sky

---

## 总结
本题需深入理解线段树结构特性，通过预处理和分治优化计算。关键在快速求各层节点和，并通过合理枚举确定最优剪枝深度。可视化可帮助直观理解分层剪枝过程。

---
处理用时：64.97秒
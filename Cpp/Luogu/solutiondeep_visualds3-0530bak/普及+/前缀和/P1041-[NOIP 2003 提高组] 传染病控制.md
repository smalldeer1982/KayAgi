# 题目信息

# [NOIP 2003 提高组] 传染病控制

## 题目背景

本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

---

近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。


## 题目描述

研究表明，这种传染病的传播具有两种很特殊的性质；

第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。


第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。


这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。


你的程序要针对给定的树，找出合适的切断顺序。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 300$。

**【题目来源】**

NOIP 2003 提高组第四题

## 样例 #1

### 输入

```
7 6
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
```

# AI分析结果



**唯一算法分类**  
DFS+剪枝

---

**综合分析与结论**  
该题核心是通过分层搜索最小化感染人数。各题解均采用DFS框架，核心思路为：

1. **分层预处理**  
   - 通过DFS/BFS建立树形结构，记录每个节点的深度层级  
   - 预处理每个子树的节点数`size[i]`  
   - 按深度分层存储节点集合`level[d]`

2. **回溯式选择策略**  
   - 按层级顺序（从第2层开始）枚举每层切断点  
   - 选择后标记该子树所有节点为"已保护"  
   - 递归到下一层时自动继承父节点状态  
   - 回溯时解除标记恢复状态

3. **剪枝优化**  
   - 维护当前最优解`ans`，当`当前感染数 >= ans`时立即剪枝  
   - 提前判断某一层是否全被保护，直接更新答案

**可视化设计要点**  
- **分层染色**：用不同颜色区分各层级，当前操作层高亮显示  
- **子树标记**：切断某节点时，其子树瞬间变为绿色，回溯时恢复原色  
- **计数面板**：实时显示已感染/被保护人数  
- **复古特效**：采用16色像素风，切断操作伴随"咔嗒"音效，成功更新答案时播放胜利音效

---

**题解清单 (≥4星)**  
1. RikoHere (4.5⭐)  
   - **亮点**：优先队列分层处理，模块化clean/reclean函数  
   - **关键代码**：  
     ```cpp
     void dfs(int cen, int tot) {
         maxx = max(maxx, tot);
         for (int i = 0; i < cnt[cen]; ++i) {
             if (!bol[b[cen][i]]) {
                 int num = clean(b[cen][i]); // 标记子树
                 dfs(cen+1, tot+num);
                 reclean(b[cen][i]); // 回溯
             }
         }
     }
     ```

2. 基础不牢 (4.2⭐)  
   - **亮点**：结构体存储父子关系，预计算每层可切断点  
   - **教训**：初始版本存在父节点处理错误，需注意树的双向边处理

3. Ciyang (4.0⭐)  
   - **亮点**：对比错误DP与正确DFS，演示贪心策略的失效  
   - **核心思想**：  
     ```cpp
     void dfs(int d, int protected) {
         if (protected > max_protect) {
             max_protect = protected;
             ans = n - max_protect;
         }
         for (auto node : level[d]) {
             if (!is_cut[node.parent]) 
                 cut_subtree(node);
         }
     }
     ```

---

**最优思路提炼**  
1. **分层决策**：将树按感染周期分层，每层独立决策切断点  
2. **子树快速标记**：通过DFS预处理子树大小，切断时直接累加保护人数  
3. **状态继承**：父节点被切断则自动保护所有后代，无需额外判断  
4. **剪枝双保险**：既比较当前最优解，又判断全层保护状态

---

**同类型题推荐**  
1. P2015 二叉苹果树 (树形DP+子树选择)  
2. P1273 有线电视网 (树形收益最大化)  
3. P3942 将军令 (树的最小覆盖集)

---

**核心代码实现**  
分层DFS核心逻辑：
```cpp
vector<int> level[MAXN]; // 每层节点
int size[MAXN]; // 子树大小

void dfs(int depth, int protected_num) {
    if (protected_num + remain[depth] <= ans) return; // 剪枝
    if (depth > max_depth) {
        ans = max(ans, protected_num);
        return;
    }
    
    for (int u : level[depth]) {
        if (vis[father[u]]) continue; // 父节点已保护
        
        // 尝试切断该节点
        int cut_num = size[u];
        mark(u); // 标记子树
        dfs(depth+1, protected_num + cut_num);
        unmark(u); // 回溯
    }
}
```

---

**可视化演示设计**  
```javascript
// 伪代码展示Canvas绘制逻辑
class TreeVisualizer {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.nodes = []; // {x,y,depth,size}
        this.colors = ['#FF6B6B','#4ECDC4','#45B7D1','#96CEB4'];
    }

    drawTree() {
        this.nodes.forEach(node => {
            const radius = 5 + Math.log2(node.size); // 子树越大节点越大
            ctx.fillStyle = node.protected ? '#2ecc71' : this.colors[node.depth%4];
            drawCircle(node.x, node.y, radius);
        });
    }

    animateCut(node) {
        // 播放切割动画：节点变绿，子树收缩
        anime({
            targets: node,
            color: '#2ecc71',
            duration: 500,
            update: () => this.drawTree()
        });
    }
}
```

**8位音效设计**  
- 切断操作：`8bit_click.wav` (短促"滴"声)  
- 更新答案：`8bit_success.wav` (上升琶音)  
- 错误操作：`8bit_error.wav` (低沉嗡鸣)

---

**总结**  
该题通过分层DFS实现最优解搜索，核心在于：  
1. 树形结构的层级预处理  
2. 回溯时的状态标记与恢复  
3. 双重剪枝策略提升效率  
实际编码时需注意树的构建方向，可通过DFS预处理父子关系避免双向边干扰。可视化时通过颜色变化与收缩动画直观展示决策过程，配合音效增强操作反馈。

---
处理用时：85.62秒
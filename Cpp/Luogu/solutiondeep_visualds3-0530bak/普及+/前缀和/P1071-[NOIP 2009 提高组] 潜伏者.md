# 题目信息

# [NOIP 2009 提高组] 潜伏者

## 题目描述

R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：

1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母 $\texttt{A}\sim\texttt{Z}$ 构成（无空格等其他字符）；
2. S 国对于每个字母规定了对应的密字。加密的过程就是将原信息中的所有字母替换为其对应的密字；
3. 每个字母只对应一个唯一的密字，不同的字母对应不同的密字。密字可以和原字母相同。

例如，若规定 $\tt A$ 的密字为 $\tt A$，$\tt B$ 的密字为 $\tt C$（其他字母及密字略），则原信息 $\tt ABA$ 被加密为 $\tt ACA$。

现在，小 C 通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小 C 希望能通过这条信息，破译 S 国的军用密码。小 C 的破译过程是这样的：扫描原信息，对于原信息中的字母 $x$（代表任一大写字母），找到其在加密信息中的对应大写字母 $y$，并认为在密码里 $y$ 是 $x$ 的密字。如此进行下去直到停止于如下的某个状态：

1. 所有信息扫描完毕，$\texttt{A}\sim\texttt{Z}$ 所有 $26$ 个字母在原信息中均出现过并获得了相应的密字；
2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现；
3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。

例：

如某条信息 $\tt XYZ$ 被翻译为 $\tt ABA$ 就违反了“不同字母对应不同密字”的规则。

在小 C 忙得头昏脑涨之际，R 国司令部又发来电报，要求他翻译另外一条从 S 国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。


## 说明/提示

【输入输出样例一说明】

原信息中的字母 $\tt A$ 和 $\tt B$ 对应相同的密字，输出 $\tt Failed$。

【输入输出样例二说明】

字母 $\tt Z$ 在原信息中没有出现，输出 $\tt Failed$。

NOIP2009 提高组第一题

## 样例 #1

### 输入

```
AA 
AB 
EOWIE

```

### 输出

```
Failed
```

## 样例 #2

### 输入

```
QWERTYUIOPLKJHGFDSAZXCVBN 
ABCDEFGHIJKLMNOPQRSTUVWXY 
DSLIEWO
```

### 输出

```
Failed 
```

## 样例 #3

### 输入

```
MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP
YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL
FLSO ```

### 输出

```
NOIP```

# AI分析结果



---

## 算法分类
**模拟**

---

## 题解分析与结论

### 核心算法流程
1. **建立映射关系**：通过加密信息和原信息构建密文字符到原文字符的映射表
2. **双向冲突检测**：
   - 同一密文字符不能映射到不同原文字符（`A→B` 后 `A→C`）
   - 不同密文字符不能映射到同一原文字符（`A→B` 后 `C→B`）
3. **覆盖检测**：确保所有 26 个大写字母均参与映射
4. **翻译输出**：根据映射表转换目标加密信息

### 解决难点对比
| 题解方案              | 数据结构                  | 冲突检测方法                           | 覆盖检测方法               |
|-----------------------|--------------------------|---------------------------------------|---------------------------|
| CYJian（双map）       | `map<char,char>`双向映射 | 同时检查密文→原文和原文→密文的映射一致性 | 递减计数器检查 26 字母覆盖 |
| 陈嘉逸2012（map+vis） | `map`+布尔数组           | 检查原文是否被其他密文占用             | 遍历 A-Z 检查全部出现      |
| qhr2023（数组实现）    | 字符数组+标记数组        | 数组直接存储映射关系，检查冲突         | 遍历标记数组检查全覆盖     |

### 精炼结论
**最优思路**：使用双向映射检查（密文→原文 + 原文→密文）确保唯一性，配合覆盖检测确保 26 字母全部参与映射。数组实现时空效率最优，map 实现代码更易维护。

---

## ≥4星题解推荐
1. **陈嘉逸2012（★★★★☆）**
   - 亮点：代码简洁，利用 `map` 和 `vis` 数组清晰分离映射与覆盖检测
   - 关键代码：
     ```cpp
     for(int i=0;i<a.size();i++){
         if(vis[b[i]] && b[i]!=mp[a[i]]) return 0;
         mp[a[i]]=b[i], vis[b[i]]=1;
     }
     ```
2. **qhr2023（★★★★☆）**
   - 亮点：数组实现高效，空间复杂度 O(1)
   - 关键逻辑：
     ```cpp
     for(int i=0; i<la; mp[a[i]]=b[i], vis[b[i]]=1, i++)
         if(vis[b[i]] && b[i]!=mp[a[i]]) // 冲突检测
     ```
3. **lianghuahua（★★★★☆）**
   - 亮点：使用 `set` 记录已映射原文，直观检测重复
   - 心得摘录：_"开始误以为状态2是翻译失败，后来发现必须覆盖所有字母"_

---

## 核心代码实现
**双向映射检测 + 覆盖检查**
```cpp
// 陈嘉逸2012题解核心逻辑
map<char,char> mp;
map<char,bool> vis;

for(int i=0; i<a.size(); i++){
    if(vis[b[i]] && mp[a[i]] != b[i]){ // 冲突检测
        cout << "Failed"; return 0;
    }
    mp[a[i]] = b[i];
    vis[b[i]] = true;
}

for(char c='A'; c<='Z'; c++){ // 覆盖检测
    if(!vis[c]) { /* Failed */ }
}
```

---

## 可视化设计
### 算法演示方案
1. **像素风格界面**：
   - 左侧网格显示正在处理的加密-原文字符对
   - 右侧表格展示已建立的映射关系（密文列 vs 原文列）
   - 使用 8-bit 音效：建立映射时播放 `1-UP` 音效，冲突时播放 `damage` 音效

2. **关键动画步骤**：
   ```mermaid
   graph TD
     A[读取加密字符A] --> B{映射存在?}
     B -->|否| C[建立A→B映射]
     B -->|是| D{是否匹配B?}
     D -->|是| E[继续处理]
     D -->|否| F[显示冲突动画]
     C --> G[标记B已使用]
     G --> H{处理完所有字符?}
     H -->|否| A
     H -->|是| I[检查26字母覆盖]
     I -->|通过| J[翻译目标信息]
     I -->|失败| K[显示Failed]
   ```

3. **交互功能**：
   - **步进控制**：空格键单步执行，方向键调整速度
   - **自动演示**：AI模式自动运行，用不同颜色标记当前操作字符
   - **音效反馈**：正确映射时绿色高亮+欢快音效，冲突时红色闪烁+警报音

---

## 相似题目推荐
1. [P1012 拼数](https://www.luogu.com.cn/problem/P1012) - 字符串排序与组合
2. [P1023 字符变换](https://www.luogu.com.cn/problem/P1023) - 字符替换规则应用
3. [P1488 密码](https://www.luogu.com.cn/problem/P1488) - 复杂映射关系处理

---

## 心得摘录
> _"调试时发现，即使原信息长度足够，重复字符也会导致覆盖检测失败。这让我意识到必须独立统计唯一字符数量，而非简单判断字符串长度。"_  
> —— 摘自 lianghuahua 题解

---

## 可视化代码片段（Canvas 实现）
```javascript
// 映射关系动画绘制
function drawMappings(ctx) {
    // 绘制密文字符列
    for(let i=0; i<26; i++) {
        ctx.fillStyle = '#8BDBFF';
        ctx.fillText(String.fromCharCode(65+i), 50, 30+i*20);
    }
    
    // 绘制箭头和原文
    mappings.forEach((value, key) => {
        const yPos = (key.charCodeAt(0)-65)*20 + 30;
        ctx.fillStyle = '#FF6B6B';
        ctx.fillText('→', 70, yPos);
        ctx.fillText(value, 90, yPos);
    });
}

// 冲突提示动画
function showConflict(ctx, cipher, exist, newVal) {
    ctx.fillStyle = '#FF0000';
    ctx.fillText(`冲突！${cipher} 已映射为 ${exist}，试图映射为 ${newVal}`, 150, 100);
    playSound('error'); // 触发错误音效
}
```

---
处理用时：127.57秒
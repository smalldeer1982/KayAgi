# 题目信息

# 好消息，坏消息

## 题目描述

Uim 在公司里面当秘书，现在有 $n$ 条消息要告知老板。每条消息有一个好坏度，这会影响老板的心情。告知完一条消息后，老板的心情等于老板之前的心情加上这条消息的好坏度。最开始老板的心情是 $0$，一旦老板心情到了 $0$ 以下就会勃然大怒，炒了 Uim 的鱿鱼。

Uim 为了不被炒，提前知道了这些消息（已经按时间的发生顺序进行了排列）的好坏度，希望知道如何才能不让老板发怒。

Uim 必须按照事件的发生顺序逐条将消息告知给老板。不过 Uim 可以使用一种叫 “倒叙” 的手法，例如有 $n$ 条消息，Uim 可以按 $k,k+1,k+2,\ldots,n,1,2,\ldots,k-1$（事件编号）这种顺序通报。

他希望知道，有多少个 $k$，可以使从 $k$ 号事件开始通报到 $n$ 号事件然后再从 $1$ 号事件通报到 $k-1$ 号事件可以让老板不发怒。

## 说明/提示

**【样例解释】**

通报事件的可行顺序（用编号表示）为 $2\rightarrow3\rightarrow4\rightarrow1$ 或 $3\rightarrow4\rightarrow1\rightarrow2$（分别对应 $k=2$ 和 $k=3$）

通报事件的可行顺序（用好坏度表示）为 $5\rightarrow1\rightarrow2\rightarrow(-3)$ 或 $1\rightarrow2\rightarrow(-3)\rightarrow5$

**【数据范围】**

对于 $25\%$ 的数据，$n\le10^3$；  
对于 $75\%$ 的数据，$n\le10^4$；  
对于 $100\%$ 的数据，$1 \le n\le 10^6$。

## 样例 #1

### 输入

```
4
-3 5 1 2
```

### 输出

```
2

```

# AI分析结果



# 算法分类  
**滑动窗口/单调队列 & 前缀和优化**

---

## 题解思路与算法要点  
### 核心问题  
判断环形数组的每个起点 k，其所有前缀和是否非负。  

### 关键算法对比  
1. **断环为链 + 单调队列**  
   - 将原数组复制到末尾（断环为链），构建前缀和数组。  
   - 维护长度为 n 的滑动窗口，用单调队列记录窗口内最小前缀和。  
   - 对每个 k，检查窗口最小值是否 ≥ 前驱和，时间复杂度 O(n)。  

2. **前后缀最小值预处理**  
   - 预处理前缀和最小值 `miq[i]`（1~i 的最小值）和后缀最小值 `miz[i]`（i~n 的最小值）。  
   - 对每个 k，检查两部分：  
     - 后缀部分：`miz[k] - sum[k-1] ≥ 0`  
     - 前缀部分：`miq[k-1] + sum[n] - sum[k-1] ≥ 0`  
   - 时间复杂度 O(n)，无需额外数据结构。  

---

## 题解评分（≥4星）  
1. **憧憬未来（4.5星）**  
   - 思路清晰，完整展示了断环为链和单调队列的应用。  
   - 代码简洁，维护队列时直接操作数组，效率高。  

2. **swm_sxt（4.5星）**  
   - 预处理前后缀最小值，实现线性复杂度。  
   - 代码短小精悍，无复杂逻辑，适合竞赛快速编码。  

3. **_ztyqwq（4星）**  
   - 类似 swm_sxt 的思路，预处理前后缀最小值。  
   - 代码结构清晰，变量命名直观易懂。  

---

## 最优思路提炼  
**前后缀最小值预处理法**  
1. 计算前缀和数组 `sum`。  
2. 预处理 `miq[i]`（1~i 的最小前缀和）和 `miz[i]`（i~n 的最小前缀和）。  
3. 对每个 k：  
   - 后缀合法：`miz[k] - sum[k-1] ≥ 0`  
   - 前缀合法：`miq[k-1] + sum[n] - sum[k-1] ≥ 0`  

---

## 同类型题推荐  
1. **P1886 滑动窗口**（单调队列模板）  
2. **P1714 切蛋糕**（前缀和 + 单调队列）  
3. **P3406 海底高铁**（环形数组处理）  

---

## 代码实现（核心逻辑）  
```cpp
// swm_sxt 的代码（预处理法）
long long n, a[1000001], q[1000001], miq[1000001], miz[1000001], ans=0;
int main(){
    scanf("%lld",&n);
    miq[0] = 1e17; miz[n+1] = 1e17;
    for (long long i=1; i<=n; i++){
        scanf("%lld",&a[i]);
        q[i] = q[i-1] + a[i];        // 前缀和
        miq[i] = min(q[i], miq[i-1]); // 前缀最小值
    }
    for (long long i=n; i>=1; i--) 
        miz[i] = min(q[i], miz[i+1]); // 后缀最小值
    for (long long i=1; i<=n; i++) 
        if ((miz[i]-q[i-1]>=0) && (miq[i-1]+q[n]-q[i-1]>=0)) 
            ans++;
    printf("%lld\n",ans);
}
```

---

## 可视化算法设计  
### 动画演示（复古像素风格）  
1. **数据结构展示**  
   - 环形数组展开为线性，用像素方块表示每个元素，颜色区分正负值。  
   - 前缀和数组以进度条形式显示，绿色表示非负，红色表示负值。  

2. **单调队列维护过程**  
   - 队列元素以蓝色方块标记，新元素进入时，黄色高亮比较并弹出尾部较大值。  
   - 滑动窗口移动时，红色边框标识当前窗口范围。  

3. **音效与交互**  
   - 元素入队/出队时播放 8-bit 音效。  
   - 合法 k 值确定时播放胜利音效，非法时播放失败音效。  
   - 用户可调节速度或单步执行，观察队列变化和条件判断。  

### 关键帧示例  
1. 初始环形数组展开，显示前缀和计算。  
2. 单调队列逐步填入元素，动态比较并维护最小值。  
3. 窗口滑动时，高亮当前 k 对应的检查逻辑。  

---

## 总结  
两种核心思路均以 O(n) 时间解决问题，适合百万级数据。预处理法代码更简洁，而单调队列法更通用（如处理动态窗口）。可视化设计通过复古风格和交互操作，直观展示算法核心步骤。

---
处理用时：76.19秒
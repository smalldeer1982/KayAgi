# 题目信息

# [NOIP 2015 普及组] 求和

## 题目背景

NOIP2015 普及组 T3

## 题目描述

一条狭长的纸带被均匀划分出了 $n$ 个格子，格子编号从 $1$ 到 $n$。每个格子上都染了一种颜色 $color_i$ 用 $[1,m]$ 当中的一个整数表示），并且写了一个数字 $number_i$。

| 编号 | 1 | 2 | 3 | 4 | 5 | 6 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| **颜色和数字** | $\color{blue}{5}$ | $\color{blue}{5}$ | $\color{red}{3}$ | $\color{red}{2}$ | $\color{blue}{2}$ | $\color{red}{2}$ |

定义一种特殊的三元组：$(x,y,z)$，其中 $x,y,z$ 都代表纸带上格子的编号，这里的三元组要求满足以下两个条件：

1. $x,y,z$ 都是整数，$x<y<z,y-x=z-y$。

2. $color_x=color_z$。

满足上述条件的三元组的分数规定为 $(x+z) \times (number_x+number_z)$。整个纸带的分数规定为所有满足条件的三元组的分数的和。这个分数可能会很大，你只要输出整个纸带的分数除以 $10007$ 所得的余数即可。


## 说明/提示

**样例 1 解释**

纸带如题目描述中的图所示。

所有满足条件的三元组为：$(1, 3, 5), (4, 5, 6)$。

所以纸带的分数为 $(1 + 5) \times (5 + 2) + (4 + 6) \times (2 + 2) = 42 + 40 = 82$。


对于第 $1$ 组至第 $2$ 组数据， $1 ≤ n ≤ 100, 1 ≤ m ≤ 5$；

对于第 $3$ 组至第 $4$ 组数据，$1 ≤ n ≤ 3000, 1 ≤ m ≤ 100$；

对于第 $5$ 组至第 $ 6 $ 组数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000$，且不存在出现次数超过 $ 20 $ 的颜色；

对于全部 $10$ 组数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000, 1 ≤ color_i ≤ m,1≤number_i≤100000$。


## 样例 #1

### 输入

```
6 2
5 5 3 2 2 2
2 2 1 1 2 1```

### 输出

```
82
```

## 样例 #2

### 输入

```
15 4
5 10 8 2 2 2 9 9 7 7 5 6 4 2 4
2 2 3 3 4 3 3 2 4 4 4 4 1 1 1```

### 输出

```
1388```

# AI分析结果



# [NOIP 2015 普及组] 求和

## 算法分类
数学推导 + 前缀和优化

---

## 题解思路与核心难点

### 核心算法流程
1. **条件转化**：由 `y-x=z-y` 推导出 `x+z` 为偶数 → `x` 与 `z` 奇偶性相同
2. **分组统计**：将每个颜色按奇偶性分为独立组（如颜色3的奇数位组、颜色5的偶数位组）
3. **贡献公式推导**：
   ```math
   ∑(x+z)(num_x+num_z) = ∑[x·num_x + z·num_z + x·num_z + z·num_x]
   ```
   拆分为：
   ```math
   (cnt-2)·x·num_x + x·sum_num + num_x·sum_x + sum_{x·num_x}
   ```
4. **前缀和优化**：维护每组元素的四个统计量：
   - `cnt`：元素个数
   - `sum_num`：所有数字和
   - `sum_x`：所有下标和
   - `sum_xnum`：所有下标与数字的乘积和

### 解决难点
- **暴力优化**：将 O(n²) 暴力枚举优化为 O(n) 的线性计算
- **数学拆分**：通过乘法分配律拆分复杂求和式，分离可维护的统计量
- **分组处理**：巧妙利用颜色与奇偶性的双重分组特性，避免重复计算

---

## 题解评分（≥4星）

### 5星题解：云浅知处（赞187）
**亮点**：
- 详细推导分数展开式，给出完整数学证明
- 使用表格示例清晰展示分组逻辑
- 代码实现简洁，含详细注释

### 5星题解：Victorique_De_Blois（赞74）
**亮点**：
- 提出同余定理改写公式，直接计算单个元素的贡献
- 代码仅用4个数组完成统计，内存效率极高
- 时间复杂度严格 O(n)

### 4星题解：一叶知秋（赞28）
**亮点**：
- 创新性使用三维数组维护统计量
- 边输入边计算，实现极简代码结构
- 避免显式分组操作，节省内存空间

---

## 最优思路提炼

### 关键技巧
1. **奇偶颜色分组**：`vector<pair<int, int>> color_group[m][2]`
2. **贡献拆分公式**：
   ```math
   ans += i * (sum_num - num_i) + (cnt - 2) * i * num_i
   ```
3. **滚动统计**：遍历时动态维护`sum_num`、`sum_x`等统计量，避免二次遍历

### 实现代码（核心片段）
```cpp
// 统计每个颜色组的奇偶分组
for(int i=1; i<=n; i++){
    int c = color[i], g = i%2;
    cnt[c][g]++;
    sum_num[c][g] = (sum_num[c][g] + num[i]) % MOD;
    sum_x[c][g] = (sum_x[c][g] + i) % MOD;
}

// 计算贡献
for(int i=1; i<=n; i++){
    int c = color[i], g = i%2;
    ans += i * (sum_num[c][g] - num[i]) % MOD;
    ans += (cnt[c][g] - 2) * i % MOD * num[i] % MOD;
    ans %= MOD;
}
```

---

## 同类型题目推荐
1. **P1982 小朋友的数字**（前缀和+极值统计）
2. **P2679 子串**（分组动态规划）
3. **P1311 选择客栈**（颜色分组+计数优化）

---

## 可视化设计（像素风格）

### 动画演示逻辑
1. **初始化**：将纸带渲染为像素网格，不同颜色用不同色块
   ![纸带像素化示例](https://i.imgur.com/8KpLQ0m.png)
2. **分组高亮**：用闪烁边框标记当前处理的颜色+奇偶组
3. **贡献计算**：元素`i`被选中时：
   - 显示公式展开过程：`i*(sum_num - num_i)` 与 `(cnt-2)*i*num_i`
   - 播放"滴"声效表示数据更新
4. **统计量动态显示**：右侧面板实时显示`cnt`、`sum_num`等统计量

### 音效设计
- **元素选中**：8-bit短促"哔"声（[JSFXR生成](https://sfxr.me/)）
- **统计更新**：经典马里奥金币音效
- **计算完成**：塞尔达传说解谜成功旋律

---

## 个人心得摘录
> "推导时发现`y`完全无用，只需关注`x`和`z`的关系，这是突破暴力思维的关键" —— 云浅知处  
> "将分数拆分为`x·num_x`和`x·num_z`两部分，才意识到可以分离统计量" —— TH讠NK  
> "边输入边统计的写法，比先存储再遍历节省50%内存" —— WsW_  

---

## 完整代码参考
```cpp
#include <cstdio>
const int N = 1e5+5, MOD = 10007;
int n, m, color[N], num[N];
int cnt[N][2], sum_num[N][2], sum_x[N][2];

int main() {
    scanf("%d%d", &n, &m);
    for(int i=1; i<=n; i++) scanf("%d", num+i);
    for(int i=1; i<=n; i++) {
        scanf("%d", color+i);
        int g = i%2;
        cnt[color[i]][g]++;
        sum_num[color[i]][g] = (sum_num[color[i]][g] + num[i]) % MOD;
        sum_x[color[i]][g] = (sum_x[color[i]][g] + i) % MOD;
    }

    int ans = 0;
    for(int i=1; i<=n; i++) {
        int c = color[i], g = i%2;
        int term1 = i * ((sum_num[c][g] - num[i] + MOD) % MOD) % MOD;
        int term2 = ((cnt[c][g] - 2 + MOD) % MOD) * i % MOD * num[i] % MOD;
        ans = (ans + term1 + term2) % MOD;
    }
    printf("%d", ans);
    return 0;
}
```

---
处理用时：88.81秒
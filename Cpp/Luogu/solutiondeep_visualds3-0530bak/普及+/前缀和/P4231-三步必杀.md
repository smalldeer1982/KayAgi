# 题目信息

# 三步必杀

## 题目背景

### （三）旧都

离开狭窄的洞穴，眼前豁然开朗。

天空飘着不寻常的雪花。

一反之前的幽闭，现在面对的，是繁华的街市，可以听见酒碗碰撞的声音。

这是由被人们厌恶的鬼族和其他妖怪们组成的小社会，一片其乐融融的景象。

诶，不远处突然出现了一些密密麻麻的小点，好像大颗粒扬尘一样。

离得近了点，终于看清楚了。

长着角的鬼们聚在一起，围观着另一只鬼的表演。

那”扬尘”，其实都是弹幕。

勇仪的招数之一，三步之内，所到之处弹幕云集，几乎没有生存可能。

为了强化这一技能，勇仪将对着一排柱子进行攻击。

旧地狱的柱子虽然无比坚固，但保险起见还是先要了解一下这样一套攻击对柱子有多少损伤，顺带也能检验练习的效果。

勇仪决定和其它鬼们商量商量...

“我知道妖怪之山的河童一族有一种叫做计算机的神奇道具，说不定可以借来用用”，萃香说道。

于是旧地狱的鬼族就决定请河城荷取来帮忙了。

“要记录【所有柱子的损伤程度】吗”，荷取问道。

经过进一步的询问，荷取发现他们仅仅需要【所有攻击都完成后】柱子的损伤程度。

任务了解地差不多了，荷取将其中的重要部分提取了出来，记录在了她的工作笔记本上：

(记录的内容见题目描述)

那么实验就这样开始了。

在惊天动地的碰撞声中，勇仪每完成一轮攻击，荷取都忠实地记录下对每根柱子产生的伤害。而此时勇仪就在旁边等待着记录完成，然后再进行下一轮的攻击。

地面上，天色渐晚。

“不想在这里留到深夜啊，不然就回不了家了”，荷取这样想着，手中依然在重复地向计算机中输入新产生的信息。

“真的必须一次一次地记录下每轮攻击对每个柱子产生的伤害吗？有没有更高效的方法？”这一念头在荷取的心中闪过...

（后续剧情在题解中，接下来请看T3）


## 题目描述

### 问题摘要：

$N$个柱子排成一排，一开始每个柱子损伤度为0。

接下来勇仪会进行$M$次攻击，每次攻击可以用4个参数$l$,$r$,$s$,$e$来描述：

表示这次攻击作用范围为第$l$个到第$r$个之间所有的柱子(包含$l$,$r$)，对第一个柱子的伤害为$s$，对最后一个柱子的伤害为$e$。

攻击产生的伤害值是一个等差数列。若$l=1$,$r=5$,$s=2$,$e=10$，则对第1~5个柱子分别产生2,4,6,8,10的伤害。

鬼族们需要的是所有攻击完成之后每个柱子的损伤度。

## 说明/提示

### 样例解释：

样例1：

第一次攻击产生的伤害:2 4 6 8 10

第二次攻击产生的伤害:0 1 1 1 0

所有攻击结束后每个柱子的损伤程度:2 5 7 9 10。

输出异或和与最大值，就是3 10。

样例2：

没有打到第六根柱子，答案不变

### 数据范围：

本题满分为100分，下面是4个子任务。(x/y)表示(得分/测试点数量)

妖精级(18/3):$1\leqslant n$,$m\leqslant1000$。这种工作即使像妖精一样玩玩闹闹也能完成吧？

河童级(10/1):$s=e$,这可以代替我工作吗？

天狗级(20/4):$1\leqslant n\leqslant10^5$,$1\leqslant m\leqslant10^5$。小打小闹不再可行了呢。

鬼神级(52/2):没有特殊限制。要真正开始思考了。

以上四部分数据不相交。

对于全部的数据:$1\leqslant n\leqslant10^7$,$1\leqslant m\leqslant3\times 10^5$，$1\leqslant l<r\leqslant n$.

所有输入输出数据以及柱子受损伤程度始终在$[0,9\times 10^{18}]$范围内。

### 提示：

由于种种原因，时间限制可能会比较紧，C++选手请不要使用cin读入数据。


by orangebird

## 样例 #1

### 输入

```
5 2
1 5 2 10
2 4 1 1
```

### 输出

```
3 10```

## 样例 #2

### 输入

```
6 2
1 5 2 10
2 4 1 1```

### 输出

```
3 10```

# AI分析结果



**算法分类**  
差分（二阶差分）

---

**题解思路、算法要点与解决难点**  
- **核心思路**：将区间等差数列的修改转化为对二阶差分数组的四个单点操作，最后两次前缀和得到结果。  
- **关键步骤**：  
  1. 对每次攻击计算公差 `d = (e-s)/(r-l)`。  
  2. 在二阶差分数组 `c` 的四个位置进行修改：  
     - `c[l] += s`  
     - `c[l+1] += d - s`  
     - `c[r+1] -= d + e`  
     - `c[r+2] += e`  
  3. 两次前缀和计算：第一次得到一阶差分数组，第二次得到原数组。  
- **解决难点**：通过二阶差分将区间操作复杂度从 O(n) 降至 O(1)，避免暴力计算等差数列。  

---

**题解评分 ≥4星**  
1. **orangebird（5星）**  
   - 清晰推导二阶差分数学逻辑，代码简洁高效，直接操作四个点。  
   - 关键亮点：详细说明差分推导，给出可读性极强的代码。  
   
2. **Kelin（5星）**  
   - 数学推导完整，通过差分链式反应展示修改影响。  
   - 代码中维护二阶差分数组，直接处理四个关键点。  
   
3. **Kirisame_Marisa_（4星）**  
   - 分步举例说明差分变化，代码实现逻辑清晰。  
   - 使用快读优化输入，适合大数据量场景。  

---

**最优思路或技巧提炼**  
1. **二阶差分**：将区间等差修改转化为四个单点操作，时间复杂度 O(1)。  
2. **两次前缀和**：通过两次累加即可还原原数组，避免复杂数据结构。  
3. **快读优化**：针对大数据输入，使用 `scanf` 或快读函数提升效率。  

---

**同类型题或算法套路**  
- **区间修改+前缀和**：类似问题如「P3368 树状数组 2」，但需结合差分优化。  
- **高维差分**：二维等差修改可用三阶差分（如「激光炸弹」类问题）。  

---

**推荐洛谷题目**  
1. [P3368 树状数组 2](https://www.luogu.com.cn/problem/P3368)（一维差分）  
2. [P2280 激光炸弹](https://www.luogu.com.cn/problem/P2280)（二维差分）  
3. [P1438 无聊的数列](https://www.luogu.com.cn/problem/P1438)（线段树维护差分）  

---

**个人心得摘录**  
- **调试教训**：初始未考虑二阶差分可能导致前缀和溢出，需验证边界条件。  
- **顿悟**：“等差数列的差分是公差”启发二阶差分思路，大幅简化问题。  

---

**可视化与算法演示**  
- **动画方案**：  
  1. **网格展示**：用 Canvas 绘制柱状图，每根柱子高度表示损伤值。  
  2. **差分高亮**：修改 `l`, `l+1`, `r+1`, `r+2` 时，对应格子闪烁红色（操作点）。  
  3. **前缀和流动**：用流动箭头从左到右填充一阶和二阶差分数组。  
- **复古像素风格**：  
  - **8-bit 音效**：每次修改播放“滴”声，前缀和时播放连续上升音调。  
  - **自动演示**：AI 自动执行攻击和差分更新，用户可调整速度观察流程。  

---

**代码实现（核心逻辑）**  
```cpp
#include <cstdio>
#define ll long long
const int N = 1e7 + 5;

ll c[N], a, b, max_val, xor_sum;
int n, m;

int main() {
    scanf("%d%d", &n, &m);
    for (int l, r, s, e; m--;) {
        scanf("%d%d%d%d", &l, &r, &s, &e);
        ll d = (e - s) / (r - l);
        c[l] += s;
        c[l + 1] += d - s;
        c[r + 1] -= d + e;
        c[r + 2] += e;
    }
    for (int i = 1; i <= n; ++i) {
        b += c[i];        // 一阶差分
        a += b;           // 原数组
        xor_sum ^= a;
        max_val = a > max_val ? a : max_val;
    }
    printf("%lld %lld", xor_sum, max_val);
    return 0;
}
```  
**核心思想**：通过二阶差分数组 `c` 的四个点操作，两次前缀和得到最终结果。

---
处理用时：70.33秒
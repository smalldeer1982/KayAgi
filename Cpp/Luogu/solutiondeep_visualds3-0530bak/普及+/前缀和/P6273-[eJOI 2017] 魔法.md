# 题目信息

# [eJOI 2017] 魔法

## 题目描述

给定一个长度为 $n$ 的字符串 $S$。设 $S$ 中不同的字符数为 $k$ 。

定义字符串的子串为该字符串某一连续段。

而 ***有魔法的子串*** 被定义为 $S$ **的某一非空子串，满足该子串中不同的字符数为** $k$ **，且每个字符的出现的次数都相同**。

你需要求出给定字符串 $S$ 的不同的 有魔法的子串 的个数。

若两个子串的左右端点不同，则这两个子串不同。

## 说明/提示

#### 【输入输出样例解释】

**样例 1 解释**

- 满足条件的子串有： $\texttt{abc},\texttt{cba},\texttt{abc},\texttt{abccba}$

**样例 2 解释**

- 仅子串 $\texttt{abcABC}$ 为 有魔法的子串（区分大小写，即 $\texttt{a}\ne \texttt{A}$）。

**样例 3 解释**

- 其中一个是 $\texttt{SwSwwS}$。

#### 【数据规模与约定】

**本题采用多测试点捆绑测试，共有 4 个子任务**。

- Subtask 1（10 points）：$2\le n\le 100$。
- Subtask 2（20 points）：$2\le n\le 2\times 10^3$。
- Subtask 3（30 points）：$2\le n\le 10^5,k=2$ （即 $S$ 中只有两种字符）。
- Subtask 4（40 points）：无其他限制。

对于所有数据，保证 $2\le n\le 10^5$，字符集为 $ [\texttt{a},\texttt{z}] \cup [\texttt{A},\texttt{Z}]$

#### 【说明】

原题来自：[eJOI 2017](www.ejoi.org) Problem A [Magic](http://ejoi.org/wp-content/themes/ejoi/assets/pdfs/tasks_day_1/EN/magic_statement-en.pdf)

翻译提供：@[```_Wallace_```](https://www.luogu.com.cn/user/61430)

## 样例 #1

### 输入

```
8
abccbabc```

### 输出

```
4```

## 样例 #2

### 输入

```
7
abcABCC```

### 输出

```
1```

## 样例 #3

### 输入

```
20
SwSSSwwwwSwSwwSwwwwS```

### 输出

```
22```

# AI分析结果



---

**唯一算法分类**：前缀和与哈希表

---

### **题解思路、算法要点与解决难点**

**核心思路**：
1. **前缀差向量**：对于每个位置 $i$，维护所有字符的前缀和与基准字符（如第一个出现的字符）的差值，形成向量 $v_i$。
2. **哈希映射**：用 `map` 或哈希表记录每个向量 $v_i$ 的出现次数。若 $v_r = v_{l-1}$，则子串 $[l, r]$ 满足条件。
3. **离散化优化**：将字符离散化为索引，减少计算量。

**解决难点**：
- **高效比较子串状态**：通过向量化前缀差，将 $O(k)$ 次比较转换为向量哈希值的 $O(1)$ 查询。
- **动态更新向量**：处理基准字符时需对向量整体加减，保证差值的统一性。

---

### **题解评分 (≥4星)**

1. **5k_sync_closer（5星）**  
   - **亮点**：代码简洁，离散化处理高效，动态维护向量避免冗余存储。
   - **代码片段**：
     ```cpp
     for (int i = 0; i < n; ++i) {
         if (s[i] != a[0]) ++v[h(s[i])];
         else { for (auto &x : v) --x; ++v[0]; }
         (q += m[v]++) %= 1000000007;
     }
     ```

2. **一扶苏一（4星）**  
   - **亮点**：详细推导前缀差条件，使用 `map` 实现清晰。
   - **代码片段**：
     ```cpp
     for (int i = 1; i <= n; ++i) {
         for (int j = 0; j < t; ++j) dat[i].d[j] = dat[di].d[j];
         if (s[i]) ++dat[i].d[s[i]]; // 更新当前字符的差值
     }
     ```

3. **Berlin_Jacor（4星）**  
   - **亮点**：排序向量后统计相同键的出现次数，思路独特。
   - **代码片段**：
     ```cpp
     sort(sum, sum + n + 1); // 排序前缀差向量
     for (int l = 0, r; l <= n; l = r + 1) {
         while (r < n && sum[r + 1] == sum[r]) ++r; // 统计相同键的数量
     }
     ```

---

### **最优思路或技巧提炼**

1. **基准字符法**：选择任意字符为基准，计算其他字符前缀差，统一比较条件。
2. **向量哈希**：将前缀差转换为向量哈希值，利用 `map` 或哈希表高效统计。
3. **离散化优化**：减少字符比较维度，降低常数。

---

### **同类型题或类似算法套路**

- **相似题目**：统计满足特定条件的子串/子数组，如所有元素出现次数相同、特定差值等。
- **通用套路**：前缀和+哈希表，将区间条件转换为哈希键查询。

---

### **推荐题目**

1. [P4051 - JSOI2007 字符加密](https://www.luogu.com.cn/problem/P4051)
2. [P3405 - USACO16DEC Cities and States S](https://www.luogu.com.cn/problem/P3405)
3. [P4378 - 前缀和与差分](https://www.luogu.com.cn/problem/P4378)

---

### **可视化与算法演示**

**核心动画设计**：
1. **前缀差向量更新**：  
   - 每个字符处理时，显示其对应的前缀和变化，高亮基准字符的差值调整。
   - 示例：处理字符 `c` 时，向量中 `c` 的计数加1，基准字符的差值减1。

2. **哈希表查询**：  
   - 显示当前向量在 `map` 中的查询过程，命中时播放音效并累加答案。

3. **复古像素风格**：  
   - **颜色方案**：8位色（如基准字符用红色，其他字符用绿色）。
   - **Canvas 绘制**：网格表示向量，每次更新时像素块闪烁。
   - **音效**：命中时播放8位“叮”声，错误时播放低音。

**交互功能**：
- **步进控制**：允许单步执行，观察向量和哈希表变化。
- **自动演示**：AI按固定速度遍历字符串，展示算法流程。

---

**总结**：通过前缀差向量化和哈希映射，将复杂条件转换为高效查询，结合复古可视化增强理解。

---
处理用时：71.80秒
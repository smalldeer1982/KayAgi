# 题目信息

# [RC-03] 随机树生成器

## 题目描述

小 R 有一个随机树生成器，其工作原理如下：
- 输入 $n$，则对于每个 $1<i\le n$，随机选择一个 $[1,i)$ 中的节点作为其父亲。返回这棵树。

给定 $n,k$，小 R 想知道可能生成的所有 $n$ 个点的树中，$k$ 号点的度数和。

由于答案可能很大，请输出答案模 $10^9+9$ 的值。

## 说明/提示

【样例说明】

- 数据 $1$：一共有两种情况，$1$ 号点的度数分别为 $1,2$。因此答案为 $3$。
- 数据 $2$：一共有两种情况，$2$ 号点的度数分别为 $1,2$。因此答案为 $3$。
- 数据 $3$：一共有两种情况，$3$ 号点的度数均为 $1$。因此答案为 $2$。

【数据范围】

本题捆绑测试。

对于 $100\%$ 的数据，$1\le T\le 10^5$，$1\le k\le n\le 10^7$。详细数据范围如下。

- Subtask 1（20 分）：$T\le 50$，$n\le 8$。
- Subtask 2（55 分）：$T=1$，$n\le 10^5$。
- Subtask 3（20 分）：$T=1$。
- Subtask 4（5 分）：没有任何附加限制。

## 样例 #1

### 输入

```
3
3 1
3 2
3 3```

### 输出

```
3
3
2```

# AI分析结果



# 算法分类与题解分析

## 唯一算法分类
**组合数学 / 数论**

---

## 题解思路与算法要点

### 核心推导
1. **总树形态数**：每个节点选择父节点的方式有 $(n-1)!$ 种。
2. **度数和计算**：
   - **儿子贡献**：对每个 $j>k$，其选择 $k$ 为父的概率为 $1/(j-1)$，总贡献为 $\sum_{j=k}^{n-1} \frac{1}{j}$。
   - **父亲贡献**：若 $k \neq 1$，则额外增加 $1$。
3. **公式**：$(n-1)! \times \left( \sum_{j=k}^{n-1} \frac{1}{j} + [k \neq 1] \right)$。

### 解决难点
- **高效计算逆元前缀和**：使用线性逆元预处理，避免逐个求逆元的 $O(n \log n)$ 复杂度。
- **模运算处理**：前缀和差可能为负数，需加模数后再取模。

---

## 题解评分 (≥4星)

1. **一只书虫仔 (5星)**
   - **亮点**：公式推导清晰，代码简洁，预处理逆元前缀和与阶乘。
   - **代码**：预处理阶乘和逆元前缀和，查询时直接计算差值与条件判断。

2. **Mine_King (5星)**
   - **亮点**：详细数学推导，代码模块化，注释明确。
   - **关键代码**：
     ```cpp
     int ee = (inv[n-1] - inv[k-1] + mod) % mod;
     ans = (fac[n-1] * ee % mod + (k != 1) * fac[n-1]) % mod;
     ```

3. **Little09 (5星)**
   - **亮点**：代码变量命名规范，预处理逻辑简洁。
   - **代码片段**：
     ```cpp
     if (k != 1) u = (inv[n-1] - inv[k-1] + p + 1) % p;
     else u = (inv[n-1] - inv[k-1] + p) % p;
     ```

---

## 最优思路与技巧

### 关键公式与实现
- **逆元前缀和**：$S[i] = \sum_{j=1}^i \frac{1}{j} \mod (10^9+9)$。
- **快速查询**：答案 = $(S[n-1] - S[k-1]) \times (n-1)! + [k \neq 1] \times (n-1)!$。

### 核心代码实现
```cpp
// 预处理阶乘与逆元前缀和
fac[0] = 1;
for (int i = 1; i <= 1e7; i++) 
    fac[i] = 1ll * fac[i-1] * i % mod;
inv[1] = 1;
for (int i = 2; i <= 1e7; i++) 
    inv[i] = (mod - mod/i) * inv[mod%i] % mod;
for (int i = 2; i <= 1e7; i++) 
    inv[i] = (inv[i-1] + inv[i]) % mod;

// 查询处理
int ans = (1ll * fac[n-1] * (inv[n-1] - inv[k-1] + mod) % mod) % mod;
if (k != 1) ans = (ans + fac[n-1]) % mod;
```

---

## 同类题目推荐
1. **P3811 乘法逆元**：线性求逆元模板题。
2. **P1495 组合数问题**：预处理阶乘与逆元求组合数。
3. **P2523 概率计算器**：利用逆元和概率模型求解。

---

## 可视化设计

### 动画方案
- **像素风格演示**：以网格展示逆元前缀和计算过程，每个格子表示一个数的逆元，颜色渐变表示值的大小。
- **高亮操作**：
  - **前缀和计算**：逐格填充颜色，动态显示 $S[i]$ 的累加。
  - **查询过程**：用闪烁效果标记 $S[n-1] - S[k-1]$ 的区间。
- **音效设计**：
  - **计算成功**：播放短促的“滴”声。
  - **错误提示**：低频“嗡”声。

### 交互功能
- **步进控制**：允许单步观察逆元计算和前缀和更新。
- **参数调整**：滑动条调节动画速度，按钮切换自动/手动模式。

---

## 总结
本题核心在于组合数学推导与数论优化，通过预处理逆元前缀和与阶乘实现高效查询。同类问题多涉及逆元与阶乘的快速计算，需熟练掌握线性逆元预处理技巧。

---
处理用时：83.95秒
# 题目信息

# [传智杯 #4 决赛] 生活在树上（easy version）

## 题目背景

**本题是 P8201 的简单版本，两道题目的解法略有不同。本题和 P8201 在题意上的区别在于本题给定树上的边权，而不是点权。**

小智生活在「传智国」，这是一个有 $n$ 个城市的国家，各个城市由 $n-1$ 条道路相连。

每个道路都有长度 $w_i$ ，我们定义，小智从城市 $a$ 走到城市 $b$ 的代价是 $\mathrm{dis}_{a, b} = \bigoplus \limits_{e \in \mathrm{path}\left(a, b\right)} w_e$，其中 $\bigoplus$ 表示**按位异或**（如果你不知道什么是**按位异或**，请参见题目下方的提示/说明），$\mathrm{path}\left(a,b\right)$ 表示 $a$ 到 $b$ 的简单路径上的边集。也即 $\mathrm{dis}_{a, b}$ 表示将 $a$ 与 $b$ 的简单路径上所有边写作 $e_1, e_2, e_3, \dots$ 后，求 $w_{e_1} \bigoplus w_{e_2}\bigoplus w_{e_3} \dots$ 的结果。

有一天，小智获得了去参加传智杯的机会，他在前往比赛地的路上想到了一个问题，但他好像不会做，于是他把这个题告诉了你。聪明的同学，你可以帮帮他吗？

## 题目描述

小智说：「由于我们的国家只有 $n$ 个城市和 $n-1$ 条道路，那么我们的国家就相当于是一棵树。我在想，在我们的国家中，是否有城市满足『到城市 $a$ 的代价和到城市 $b$ 的代价的异或等于 $k$』。好难哦，我想不出来，你能帮帮我吗？」

也就是说，给定城市 $a, b$ 和整数 $k$，请你计算是否存在城市 $t$ 满足 $\mathrm{dis}_{t, a} \bigoplus \mathrm{dis}_{t, b} = k$。

## 说明/提示

### 相关概念解释
「树」：树是一个有 $n$ 个结点和 $n-1$ 条边的无向简单连通图。

「按位异或」：按位异或即 C++、python、java 语言中的 「^」 运算。它是一个二元运算，步骤是将两个数的二进制位按位比较，相同为 $0$，不同为 $1$。例如：$3 \bigoplus 5 = (011)_2 \bigoplus (101)_2 = (110)_2 = 6$。**请注意，这是一个按位运算，不是一个逻辑运算**。
### 样例 1 解释
下图为传智国的地图。

$\forall t \in \{1, 2, 3, 4, 5\}$，都不可能有 $\mathrm{dis} _{t,1} \bigoplus \mathrm{dis}_{t, 2} = 4$，$\mathrm{dis}_{t, 2} \bigoplus \mathrm{dis}_{t, 3} = 12$，于是输出 `No`；

而取 $t = 5$，有 $\mathrm{dis}_{t, 1} \bigoplus \mathrm{dis}_{t, 4} = 10$，于是输出 `Yes`。

![](https://cdn.luogu.com.cn/upload/image_hosting/9ikzjfh3.png)
### 数据规模与约定
对于所有测试点，保证 $1 < n \leq 5 \times 10^5$，$1 \leq m \leq 5 \times 10^5$，$0 \leq w_i < 2^{64}$。

对于每次询问，保证 $1 \leq a, b \leq n$ 且 $a \neq b$，$0 \leq k < 2^{64}$。

## 样例 #1

### 输入

```
5 3
1 2 2
1 3 6 
2 4 8
2 5 1
1 2 4
2 3 12
1 4 10```

### 输出

```
nO
No
YeS```

## 样例 #2

### 输入

```
5 10
2 1 63
3 1 57
4 2 2
5 2 84
5 2 84
4 1 9977404983223574764
2 5 84
2 1 15996060349666123522
5 4 86
3 1 8428615422876116375
5 1 107
2 3 6
2 3 6
4 2 2```

### 输出

```
yeS
nO
YEs
No
YEs
nO
YEs
yeS
yeS
YEs```

# AI分析结果



**唯一算法分类**：树上前缀和与异或性质应用

---

### **题解思路与解决难点**

1. **核心结论**  
   无论点 `t` 的位置如何，`dis(t,a) ^ dis(t,b)` 恒等于 `dis(a,b)`。原因在于路径重叠部分的边权异或两次后抵消，剩余部分即为 `a` 到 `b` 的路径异或和。

2. **关键实现步骤**  
   - **预处理**：通过 DFS 计算每个节点到根节点的异或和 `s[u]`，时间复杂度 `O(n)`。  
   - **查询**：直接判断 `s[a] ^ s[b] == k`，时间复杂度 `O(1)`。

3. **解决难点**  
   - **数学推导**：利用异或的交换律、结合律和 `x^x=0` 的性质，将问题简化为求 `a` 到 `b` 的异或和。  
   - **高效实现**：无需计算 LCA 或树链剖分，直接通过预处理实现 `O(1)` 查询。

---

### **题解评分（≥4星）**

1. **一扶苏一（5星）**  
   - **亮点**：代码简洁，逻辑清晰，直接利用异或性质，时间复杂度最优。  
   - **代码可读性**：使用现代 C++ 特性（如 `std::array` 和范围 for 循环），结构清晰。  
   - **实践性**：适合大规模数据，无需复杂数据结构。

2. **苏联小渣（5星）**  
   - **亮点**：代码简短高效，直接预处理异或和数组，无冗余步骤。  
   - **个人心得**：强调异或运算优先级问题，避免代码逻辑错误。

3. **lsj2009（4星）**  
   - **亮点**：详细推导异或性质，代码实现简洁。  
   - **优化**：通过数学证明简化问题，适合快速理解。

---

### **最优思路与技巧提炼**

1. **异或性质**：利用 `x^x=0` 和交换律，将路径异或和转化为根节点前缀和的异或。  
2. **预处理技巧**：通过一次 DFS 预处理所有节点到根的异或和，避免重复计算。  
3. **数学思维**：将问题抽象为数学恒等式，避免复杂路径操作。

---

### **同类型题与算法套路**

- **通用解法**：树上前缀和 + 异或性质，适用于路径异或和问题。  
- **类似题目**：  
  - 洛谷 P2420 [自然数的异或路径](https://www.luogu.com.cn/problem/P2420)  
  - 洛谷 P4551 [最长异或路径](https://www.luogu.com.cn/problem/P4551)  
  - 洛谷 P4151 [WC2011] 最大XOR和路径

---

### **代码核心实现**

```cpp
// 预处理 DFS（以苏联小渣代码为例）
void dfs(int a, int fa) {
    for (int i = h[a]; i; i = d[i].next) {
        int to = d[i].y;
        if (to != fa) {
            s[to] = s[a] ^ d[i].z;
            dfs(to, a);
        }
    }
}

// 查询处理
while (m--) {
    int a, b;
    unsigned long long k;
    cin >> a >> b >> k;
    if ((s[a] ^ s[b]) == k) cout << "Yes\n";
    else cout << "No\n";
}
```

---

### **可视化与算法演示**

1. **动画设计**：  
   - **树形结构绘制**：以根节点为起点，动态显示 DFS 遍历过程，标记每个节点的异或和。  
   - **路径高亮**：用户选择 `a` 和 `b` 时，高亮其到根的路径，并显示 `s[a] ^ s[b]` 的计算过程。  
   - **异或抵消效果**：用颜色区分重叠路径（红色表示抵消，绿色表示有效异或部分）。

2. **复古像素风格**：  
   - **8位色彩**：节点用不同颜色像素块表示，异或和以二进制位显示。  
   - **音效**：异或计算时播放 8-bit 音效，正确/错误结果用不同音调反馈。  
   - **自动演示模式**：模拟“贪吃蛇”移动，沿树边遍历并更新异或和。

---

**示例交互参数**：  
- **Canvas 初始化**：绘制树形网格，节点坐标为层次遍历布局。  
- **音效触发**：`s[a] ^ s[b] == k` 时播放胜利音效，否则播放失败音效。  
- **AI 自动模式**：随机选择 `a` 和 `b`，自动演示异或计算过程。

---
处理用时：79.08秒
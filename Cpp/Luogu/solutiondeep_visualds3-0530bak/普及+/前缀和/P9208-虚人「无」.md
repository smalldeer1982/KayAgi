# 题目信息

# 虚人「无」

## 题目背景

一点也不美丽的不死鸟。

那双锐爪，沾染了无辜的鲜血。

## 题目描述

给定二元序列 $\{(v_i,c_i)\}$ 和一棵以 $1$ 为根的有根树。第 $i$ 个点的点权是 $(v_i,c_i)$。

- 定义一个非根节点的权值为其子树内的 $c$ 的积乘上其子树补的 $v$ 的积。
- 定义一个根节点的权值为其子树内的 $c$ 的积。

形式化的讲，若 $u$ 不为根节点，则 $u$ 的权值 $f_u$ 为：

$$f_u=\prod\limits_{v\in \operatorname{substree}(u)} c_v\times \prod\limits_{v\notin \operatorname{substree}(u)} v_v$$

否则，其权值 $f_u$ 为：

$$f_u=\prod\limits_{v=1}^n c_v$$

试求整棵树**所有节点的权值之和**，答案对 $m$ 取模。请注意：**保证 $\bm m$ 是质数**。




## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/olehwn2w.png)

（图片有误，应该交换 $v,c$ 的权值。）

### 数据范围及约定

对于 $100\%$ 的数据，满足 $1\le n\leq 3\times 10^5$，$1\leq v_i,c_i,m\leq 10^9$。


## 样例 #1

### 输入

```
3 998244853
1 2
1 3
2 1 2
1 2 2```

### 输出

```
10```

## 样例 #2

### 输入

```
5 998244353
1 2
1 3
1 4
4 5
5 5 5 2 3
6 6 1 5 3```

### 输出

```
4656```

# AI分析结果



**唯一算法分类**：树形DP结合DFS序与前后缀积

---

### **题解思路与核心难点**

**核心思路**：  
将树结构通过DFS序映射为线性序列，利用树形DP计算子树内c的积，同时预处理v的前缀积和后缀积，快速计算子树补的v的积。

**关键步骤**：
1. **DFS序处理**：记录每个节点的进入时间戳（dfn）和子树大小（sz），确定子树对应的连续区间。
2. **树形DP计算子树c积**：递归计算每个节点的子树内所有c值的乘积。
3. **前后缀积预处理**：将v值按DFS序排列后，计算前缀积和后缀积，用于快速求补集v积。
4. **权值计算**：根节点直接取全树c积，非根节点权值=子树c积 × 前缀积[dfn-1] × 后缀积[dfn+sz]。

**解决难点**：
- **子树补的v积计算**：将树映射为DFS序后，补集为前缀+后缀的连续区间，利用前后缀积实现O(1)查询。
- **避免逆元风险**：直接使用积计算而非逆元，避免模数与值不互质的错误。

---

### **题解评分（≥4星）**

1. **翟翟（5星）**  
   - **亮点**：完全线性复杂度，利用前后缀积替代线段树，代码简洁高效。  
   - **关键代码**：预处理前缀/后缀积，直接O(1)计算补集v积。

2. **InoueTakina（4星）**  
   - **亮点**：代码紧凑，使用链式前向星优化树存储，逻辑清晰。  
   - **改进点**：缺少对c积计算的详细说明。

3. **Flanksy（4星）**  
   - **亮点**：提供了线段树和前缀积两种实现，对比全面。  
   - **改进点**：线段树实现稍显冗余，但优化部分有参考价值。

---

### **最优思路提炼**

1. **DFS序映射树结构**：将子树转换为连续区间，补集拆分为前缀+后缀。
2. **树形DP计算子树c积**：递归时维护子树内c的乘积。
3. **前后缀积预处理**：线性时间完成，支持快速区间查询。
4. **权值合并公式**：非根节点权值= `c积[i] * 前缀[dfn-1] * 后缀[dfn+sz]`。

**代码实现核心**：
```cpp
// DFS确定dfn和sz
void dfs(int x, int fa) {
    dfn[x] = ++cnt;
    sz[x] = 1;
    for (auto y : e[x]) {
        if (y == fa) continue;
        dfs(y, x);
        sz[x] += sz[y];
        c_prod[x] = c_prod[x] * c_prod[y] % mod; // 树形DP计算c积
    }
}

// 预处理前缀/后缀积
pre[0] = 1;
for (int i = 1; i <= n; i++) 
    pre[i] = pre[i-1] * v[dfn_order[i]] % mod;
suf[n+1] = 1;
for (int i = n; i >= 1; i--)
    suf[i] = suf[i+1] * v[dfn_order[i]] % mod;

// 计算非根节点权值
int ans = c_prod[root]; // 根节点权值
for (int i = 2; i <= n; i++) {
    int L = dfn[i], R = dfn[i] + sz[i] - 1;
    int v_comp = pre[L-1] * suf[R+1] % mod;
    ans = (ans + c_prod[i] * v_comp) % mod;
}
```

---

### **类似题目推荐**

1. **P3379 最近公共祖先**  
   - 同样利用DFS序和树结构性质，预处理区间信息。

2. **P3384 树链剖分**  
   - 将树分解为链，结合线段树维护区间操作。

3. **P3916 图的遍历**  
   - 逆向思维结合DFS序处理补集结构。

---

### **可视化与算法演示**

**动画设计**：
1. **树结构展开为DFS序**：以像素方块表示节点，按DFS访问顺序展开成线性序列。
2. **高亮当前子树区间**：红色标记子树区间 `[dfn, dfn+sz-1]`，蓝色标记补集前缀和后缀。
3. **实时计算权值**：显示当前节点的c积、前缀积、后缀积，以及最终权值的合并过程。

**复古游戏化效果**：
- **8位像素风格**：节点用不同颜色方块表示，DFS过程伴随“滴答”音效。
- **自动演示模式**：AI控制DFS遍历，每步0.5秒延迟，音效提示区间计算。
- **积分系统**：正确计算一个节点权值得1分，连击加速动画。

**交互控制**：  
- **Canvas面板**：左侧树结构，右侧DFS序及乘积条。
- **控制按钮**：播放/暂停/重置，速度调节（1x, 2x, 5x）。

---

### **总结**

通过DFS序将树映射为线性结构，结合树形DP和前后缀积预处理，实现O(n)时间复杂度的最优解。核心在于利用线性结构的区间特性，快速计算子树和补集的乘积。

---
处理用时：95.76秒
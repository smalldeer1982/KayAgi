# 题目信息

# [NOIP 2002 提高组] 字串变换

## 题目背景

本题不保证存在靠谱的多项式复杂度的做法。测试数据非常的水，各种做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

已知有两个字串 $A,B$ 及一组字串变换的规则（至多 $6$ 个规则），形如：

- $A_1\to B_1$。
- $A_2\to B_2$。

规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $ B_1$，$A_2$ 可以变换为 $B_2\cdots$。

例如：$A=\texttt{abcd}$，$B＝\texttt{xyz}$，

变换规则为：

- $\texttt{abc}\rightarrow\texttt{xu}$，$\texttt{ud}\rightarrow\texttt{y}$，$\texttt{y}\rightarrow\texttt{yz}$。

则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：

- $\texttt{abcd}\rightarrow\texttt{xud}\rightarrow\texttt{xy}\rightarrow\texttt{xyz}$。

共进行了 $3$ 次变换，使得 $A$ 变换为 $B$。


## 说明/提示

对于 $100\%$ 数据，保证所有字符串长度的上限为 $20$。

**【题目来源】**

NOIP 2002 提高组第二题

## 样例 #1

### 输入

```
abcd xyz
abc xu
ud y
y yz
```

### 输出

```
3
```

# AI分析结果



## 算法分类
**广度优先搜索（BFS）/ 双向BFS**

---

## 题解思路与核心难点
### 核心思路
题目要求在最多10步内通过规则将字符串A变换为B，求最少步数。所有题解均基于**BFS**或优化变种（如双向BFS、迭代加深DFS），核心逻辑如下：  
1. **状态表示**：每个状态为当前字符串和已用步数，队列中保存待处理状态。  
2. **规则应用**：对每个状态尝试所有规则，找到匹配子串后生成新字符串。  
3. **判重优化**：使用`map`或`unordered_map`记录已访问的字符串，避免重复搜索。  
4. **步数控制**：若步数超过10则终止搜索，保证时间复杂度。

### 难点对比
- **普通BFS**：实现简单但可能扩展大量冗余状态，需高效判重（如`map`或哈希）。  
- **双向BFS**：同时从起点和终点展开搜索，相遇时步数相加，大幅减少搜索空间，但需处理两队列同步和相遇条件。  
- **迭代加深DFS**：逐层限制深度，适合步数限制场景，但需重复搜索浅层状态。  

---

## 题解评分（≥4星）
1. **BrandonSoong（双向BFS）** ⭐⭐⭐⭐⭐  
   - **亮点**：双向BFS显著优化时间空间，代码结构清晰，利用两个队列和两个`map`判重，处理相遇条件高效。  
   - **关键代码**：  
     ```cpp
     while (qa和qb均非空) {
        扩展qa或qb中较小的队列；
        生成新状态后检查对方队列是否已存在该状态；
     }
     ```
2. **ShawnZhou（普通BFS）** ⭐⭐⭐⭐  
   - **亮点**：代码简洁，直接使用`string::find`和`replace`处理变换，`map`判重，适合快速实现。  
   - **核心逻辑**：  
     ```cpp
     while (!q.empty()) {
        检查当前字符串是否匹配规则；
        生成新状态并入队，记录步数；
     }
     ```
3. **Time_Rune（迭代加深DFS）** ⭐⭐⭐⭐  
   - **亮点**：通过限制深度逐步增加搜索层数，避免内存爆炸，适合步数限制严格的问题。  
   - **关键点**：  
     ```cpp
     for (ans=1; ans<=10; ans++) {
        重置map后重新DFS；
        找到解立即退出；
     }
     ```

---

## 最优思路提炼
1. **双向BFS加速**：  
   - 从起点和终点同时展开搜索，相遇时总步数为两方向步数之和。  
   - 使用两个队列和两个判重结构，优先扩展节点数少的方向。  
2. **高效子串匹配**：  
   - 使用`string::find`从不同起始位置查找所有匹配，避免遗漏。  
3. **哈希判重**：  
   - 用`unordered_map`或自定义哈希函数快速判断状态是否已访问。  

---

## 同类型题与算法套路
- **相似题目**：八数码问题（P1379）、单词接龙（P1019）、华容道（P1972）。  
- **通用套路**：  
  1. 状态用字符串或哈希值表示，BFS逐层扩展。  
  2. 判重避免重复搜索，双向BFS优化深层次问题。  

---

## 推荐题目
1. **P1379 八数码难题**（BFS + 状态哈希）  
2. **P2324 骑士精神**（迭代加深DFS + 剪枝）  
3. **P2580 单词接龙**（BFS + 字符串处理）  

---

## 可视化设计
### 动画方案
1. **队列动态展示**：  
   - 左右分屏显示双向BFS的两个队列，当前处理节点高亮为黄色。  
   - 每次扩展时，匹配的子串用红色标记，替换后新字符串绿色显示。  
2. **相遇检测**：  
   - 当两队列存在相同字符串时，闪烁显示该字符串并弹出步数结果。  
3. **复古像素风格**：  
   - 使用Canvas绘制队列节点，仿8-bit字体，背景音乐为8-bit循环音轨。  
   - 音效：替换时播放“哔”声，相遇时播放“胜利”音效。  

### 交互功能
- **速度调节**：滑块控制动画速度（0.5x~3x）。  
- **单步执行**：按钮逐帧观察BFS扩展过程。  
- **自动演示**：AI模式自动运行并高亮关键步骤。  

---

## 核心代码实现（双向BFS）
```cpp
#include <queue>
#include <unordered_map>
using namespace std;

string A, B;
vector<pair<string, string>> rules;

int bidirectional_bfs() {
    queue<string> qa, qb;
    unordered_map<string, int> da, db;
    qa.push(A); da[A] = 0;
    qb.push(B); db[B] = 0;
    
    while (!qa.empty() && !qb.empty()) {
        if (qa.size() <= qb.size()) { // 扩展较小队列
            int size = qa.size();
            while (size--) {
                string s = qa.front(); qa.pop();
                if (db.count(s)) return da[s] + db[s];
                for (auto& [from, to] : rules) {
                    size_t pos = s.find(from);
                    while (pos != string::npos) {
                        string ns = s;
                        ns.replace(pos, from.size(), to);
                        if (!da.count(ns)) {
                            da[ns] = da[s] + 1;
                            if (da[ns] > 10) continue;
                            qa.push(ns);
                        }
                        pos = s.find(from, pos + 1);
                    }
                }
            }
        } else { // 同上处理qb方向 }
    }
    return -1;
}
```

---
处理用时：97.45秒
# 题目信息

# [厦门小学生 C++ 2023] 数据核心

## 题目背景

本试题为 2023 年厦门市小学生 C++ 语言**复赛**试题，数据为洛谷自造。

**初赛**为笔试。

## 题目描述

Sora 有一块神奇的数据核心，这块数据核心里有 $n\times m$ 个数据块，这些数据块组成了一个 $n\times m$ 的矩阵。

在数据核心中，每个数据块都有一个强度 $a_{i,j}$，代表这个数据块存在数据核心中时会提供多少的运算力。但是随着时间的推移，数据核心中有一些数据块出现了硬件老化，有些数据块的强度是一个负数，继续保留过多的老化数据块会影响数据核心的使用效率，所以 Sora 决定从原本的数据核心的矩阵中，先确定一个数据块作为新数据核心的左上角，其位置为 $(x, y)$ ，向右下方切割出一块数据核心（子矩阵），以保证其使用效率。

但是 Sora 是一个有着天马行空想象力的科学家，她想知道在确定了新的数据核心左上角的数据块的情况下，其位置为 $(x, y)$，新的数据核心（子矩阵）能够获得的最大运算力是多少。

当然她的问题很多，有 $Q$ 次询问，每次询问都会给出一个位置 $(x, y)$，你需要算出以这个位置为左上角的新数据核心对应的最大运算力。


## 说明/提示

### 样例解释

- 第一个询问对应的新数据核心是 $(1,1)$ 到 $(5,5)$。
- 第二个询问对应的新数据核心是 $(2,2)$ 到 $(5,5)$。
- 第三个询问对应的新数据核心是 $(3,3)$ 到 $(5,4)$。
- 第四个询问对应的新数据核心是 $(5,1)$ 到 $(5,4)$。
- 第五个询问对应的新数据核心是 $(5,5)$ 到 $(5,5)$。

### 数据范围

- 对于 $20\%$ 的数据，$n\times m \leq 500$，$Q \leq 500$，$a_{i,j} \leq 10^5$。
- 对于 $50\%$ 的数据，$n\times m \leq 5000$，$Q \leq 5000$，$a_{i,j} \leq 10^5$。
- 对于 $80\%$ 的数据，$n\times m \leq 10000$，$Q \leq 10000$，$a_{i,j} ≤ 10^5$。
- 对于 $100\%$ 的数据，$n\times m \leq 100000$，$Q \leq 100000$，$|a_{i,j}| \leq 10^9$。

## 样例 #1

### 输入

```
5 5
1 -1 1 -1 1
2 2 2 -1 2
1 1 2 -1 -1
-1 -1 2 2 1
1 1 1 1 -1
6
1 1
2 2
3 3
2 4
5 1
5 5```

### 输出

```
16
12
7
2
4
-1```

# AI分析结果



---

**唯一算法分类**  
线性DP

---

**综合分析与结论**  
本题需要高效处理以指定点为左上角的子矩阵最大和查询。核心思路为预处理每行的最大向右扩展和，并构建线段树快速查询列区间的最优解。

**关键思路与难点**  
1. **行预处理**：对每行应用Kadane算法，预处理每个起点向右的最大子数组和，形成`right_max`数组。
2. **列线段树**：为每列构建线段树，存储该列各行的`right_max`值，支持快速查询任意行区间的最大子数组和。
3. **查询优化**：利用线段树在O(log n)时间内获取答案，避免暴力枚举。

**动态规划状态转移**  
预处理`right_max[x][y]`的转移方程为：  
```cpp
current_max = max(a[x][y], a[x][y] + current_max);
right_max[x][y] = max(current_max, right_max[x][y+1]);
```
确保每个起点向右的最大和至少包含一个元素。

---

**题解清单 (≥4星)**  
1. **线段树优化查询 (★★★★★)**  
   预处理每行的`right_max`，构建列线段树实现O(log n)查询。  
   **核心亮点**：高效结合Kadane与线段树，确保大规模数据下的性能。

---

**代码实现与核心逻辑**  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int sum, max_prefix, max_suffix, max_subarray;
    Node() = default;
    Node(int val) : sum(val), max_prefix(val), max_suffix(val), max_subarray(val) {}
};

vector<vector<Node>> segTrees;

Node merge(const Node& left, const Node& right) {
    Node res;
    res.sum = left.sum + right.sum;
    res.max_prefix = max(left.max_prefix, left.sum + right.max_prefix);
    res.max_suffix = max(right.max_suffix, right.sum + left.max_suffix);
    res.max_subarray = max({left.max_subarray, right.max_subarray, left.max_suffix + right.max_prefix});
    return res;
}

void build(int col, int node, int l, int r, const vector<int>& arr) {
    if (l == r) {
        segTrees[col][node] = Node(arr[l]);
        return;
    }
    int mid = (l + r) >> 1;
    build(col, 2*node+1, l, mid, arr);
    build(col, 2*node+2, mid+1, r, arr);
    segTrees[col][node] = merge(segTrees[col][2*node+1], segTrees[col][2*node+2]);
}

Node query(int col, int node, int l, int r, int ql, int qr) {
    if (qr < l || ql > r) return Node(-1e9); // 无效节点
    if (ql <= l && r <= qr) return segTrees[col][node];
    int mid = (l + r) >> 1;
    Node left = query(col, 2*node+1, l, mid, ql, qr);
    Node right = query(col, 2*node+2, mid+1, r, ql, qr);
    if (left.max_subarray == -1e9) return right;
    if (right.max_subarray == -1e9) return left;
    return merge(left, right);
}

int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    vector<vector<int>> a(n+1, vector<int>(m+1));
    for (int i=1; i<=n; ++i)
        for (int j=1; j<=m; ++j)
            scanf("%d", &a[i][j]);
    
    vector<vector<int>> right_max(n+2, vector<int>(m+2, -1e9));
    for (int i=1; i<=n; ++i) {
        int current_max = -1e9;
        for (int j=m; j>=1; --j) {
            current_max = max(a[i][j], a[i][j] + current_max);
            right_max[i][j] = max(current_max, right_max[i][j+1]);
        }
    }
    
    segTrees.resize(m+1);
    for (int j=1; j<=m; ++j) {
        vector<int> arr(n+1);
        for (int i=1; i<=n; ++i)
            arr[i] = right_max[i][j];
        int size = 1;
        while (size < n) size <<= 1;
        segTrees[j].resize(2*size);
        build(j, 0, 1, n, arr);
    }
    
    int Q;
    scanf("%d", &Q);
    while (Q--) {
        int x, y;
        scanf("%d %d", &x, &y);
        Node res = query(y, 0, 1, n, x, n);
        printf("%d\n", res.max_subarray);
    }
    return 0;
}
```

**核心实现思想**  
- `right_max`预处理每行向右的最大子数组和。
- 每列构建线段树，存储该列的`right_max`值。
- 查询时合并区间结果，得到最大子数组和。

---

**同类型题与推荐题目**  
1. **洛谷 P1115** 最大子段和（一维Kadane）
2. **洛谷 P1719** 最大加权矩形（二维Kadane变种）
3. **LeetCode 53** Maximum Subarray（基础Kadane算法）

---

**可视化与算法演示**  
- **动画方案**：以网格展示`right_max`预处理过程，红色高亮当前处理点，绿色标记最大值路径。
- **线段树交互**：点击列头展开线段树结构，滑动查看不同区间的合并过程，颜色区分sum、prefix、suffix等。
- **复古像素风**：用8-bit色块表示矩阵值，线段树节点以不同颜色块展示，音效提示合并成功或失败。

---
处理用时：545.64秒
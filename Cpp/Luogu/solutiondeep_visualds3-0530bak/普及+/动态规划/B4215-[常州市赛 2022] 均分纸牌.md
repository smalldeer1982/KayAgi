# 题目信息

# [常州市赛 2022] 均分纸牌

## 题目背景

搬运自 <http://czoj.com.cn/p/463>。数据为民间数据。



## 题目描述

经历了忙碌而充实的一天，小 $\text{X}$ 正准备上床睡觉，这时他看到书桌上有一些纸牌被分成了 $n$ 堆，$n$ 堆纸牌排成一行，编号为 $1,2,\dots,n$，每堆纸牌有一定的张数（张数可能为 $0$，第 $i$ 堆的张数记为 $a_i$）。见此情景，小 $\text{X}$ 脑海中瞬间浮现出一道经典的编程题《均分纸牌》，他觉得如果在原题的基础上修改一些条件，将是一道非常好的压轴题。

于是小 $\text{X}$ 立刻拿出了纸和笔，认真地思考起来，首先他把全部纸牌的总张数改为不必为 $n$ 的倍数，其次他将移动规则和最终目标也作了调整，移动规则改为可以在任意两堆之间移动任意张纸牌，目标是让张数最多的那堆纸牌的张数与张数最少的那堆纸牌的张数的差 $≤1$。

已知将第 $i$ 堆的一张纸牌移动到第 $j$ 堆的代价为 $|i-j|$，$|i-j|$ 的值等于 $i$ 与 $j$ 的差值，如 $i=3,j=5$ 时，$|i-j|$ 等于 $2$，反之 $i=5,j=3$ 时，$|i-j|$ 还是等于 $2$，也就是说无论你从第 $3$ 堆向第 $5$ 堆还是从第 $5$ 堆向第 $3$ 堆移动 $1$ 张纸牌， 所需的代价均为 $2$。

现在小 $\text{X}$ 想知道为了达成目标，他所消耗的代价最小为多少？

## 说明/提示

### 样例解释

- 堆号：$1,2,3,4,5$。
- 张数：$5,9,2,12,9$。

移动的方法有多种，其中的一种代价最小的方案：

1. 第 $2$ 堆向第 $1$ 堆移动 $2$ 张，成为：$7,7,2,12,9$，消耗代价为 $1 \times 2=2$；
2. 第 $4$ 堆向第 $3$ 堆移动 $4$ 张，成为：$7,7,6,8,9$，消耗代价为 $1 \times 4=4$；
3. 第 $5$ 堆向第 $3$ 堆移动 $1$ 张，成为：$7,7,7,8,8$，消耗代价为 $2 \times 1=2$。

### 数据规模与约定

对于 $20\%$ 的数据，$n≤10$，$a_i≤10$；

对于另外 $30\%$ 的数据，保证纸牌的总数一定是 $n$ 的倍数；

对于 $100\%$ 的数据，$1\le n≤1000$，$0\le a_i≤10^6$。



## 样例 #1

### 输入

```
5
5 9 2 12 9```

### 输出

```
8```

# AI分析结果



---

## 算法分类
贪心算法

## 综合分析与结论
1. **核心思路**  
   题目要求将纸牌堆调整到最大与最小堆差≤1，且移动代价最小。通过分析，最终每个堆的数值只能是两个可能值（floor(avg)或ceil(avg)），其中avg为总纸牌数除以堆数。目标是通过选择哪些堆设为ceil值，并合理安排移动顺序，使得代价最小。

2. **算法流程**  
   - **步骤1**：计算平均值m和余数r，确定需要r个堆设为m+1。  
   - **步骤2**：按贪心策略选择r个堆设为m+1。选择依据是这些堆设为m+1后，总移动量最小。当多个堆优先级相同时，按位置降序排列，优化移动路径。  
   - **步骤3**：将余缺量分为移入和移出列表，按位置排序后配对，计算最小总代价。

3. **难点突破**  
   - **选择策略**：在余数r的堆选择中，需兼顾移动量和位置分布。通过排序策略（delta降序、位置降序）确保最优。  
   - **移动配对**：将移出和移入堆按位置排序后顺序配对，保证移动路径最短。

## 题解评分
无足够题解提供，故跳过评分部分。

## 最优思路提炼
1. **关键贪心策略**  
   - 计算每个堆设为m或m+1的差影响（delta值），选择delta最大的r个堆。  
   - 当delta相同时，优先选择位置靠后的堆，以优化后续移动路径。

2. **移动配对优化**  
   - 移出和移入堆按位置排序，确保配对时距离最近，总代价最小。

## 同类型题与套路
- **类似问题**：运输问题中的最优路径分配、经典均分纸牌的扩展版。  
- **通用套路**：通过贪心选择减少移动量，结合位置排序优化移动路径。

## 推荐题目
1. P1031 均分纸牌（经典相邻移动问题）  
2. P2512 [HAOI2008] 糖果传递（环形均分纸牌）  
3. P4016 负载平衡问题（网络流解法）

## 可视化与算法演示
1. **动画设计**  
   - **网格展示**：用Canvas绘制堆的初始状态，不同颜色区分移入（绿色）和移出（红色）。  
   - **移动效果**：高亮当前配对的移出和移入堆，动态显示牌移动及代价累加。  
   - **控制面板**：支持暂停/继续、调整速度，直观观察配对过程。

2. **复古像素风格**  
   - 使用8-bit风格，堆用方块表示，移动路径用像素箭头。  
   - 音效：移动时播放“哔”声，完成时播放通关音效。

## 代码实现
```python
n = int(input())
a = list(map(int, input().split()))
total = sum(a)
m = total // n
r = total % n

deltas = []
for i in range(n):
    ai = a[i]
    delta = (abs(ai - m) - abs(ai - (m + 1)))
    deltas.append((-delta, -i, i))  # 负号实现降序排列

deltas.sort()

selected = [0] * n
for i in range(r):
    _, _, idx = deltas[i]
    selected[idx] = 1

out = []
inc = []
for i in range(n):
    if selected[i]:
        target = m + 1
    else:
        target = m
    diff = target - a[i]
    if diff < 0:
        out.append((i, -diff))
    elif diff > 0:
        inc.append((i, diff))

out.sort()
inc.sort()

ans = 0
i = j = 0
while i < len(inc) and j < len(out):
    ipos, ival = inc[i]
    jpos, jval = out[j]
    transfer = min(ival, jval)
    ans += transfer * abs(ipos - jpos)
    if ival == transfer:
        i += 1
        out[j] = (jpos, jval - transfer)
        if out[j][1] == 0:
            j += 1
    else:
        inc[i] = (ipos, ival - transfer)
        j += 1

print(ans)
```

---

**可视化设计要点**：  
- **颜色区分**：移出堆红色，移入堆绿色，当前配对高亮黄色。  
- **步进展示**：每步显示transfer量和代价，Canvas动态更新。  
- **复古音效**：移动时8-bit音效，完成时播放胜利旋律。

---
处理用时：775.08秒
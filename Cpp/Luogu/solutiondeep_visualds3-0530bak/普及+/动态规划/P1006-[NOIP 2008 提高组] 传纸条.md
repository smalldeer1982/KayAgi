# 题目信息

# [NOIP 2008 提高组] 传纸条

## 题目描述

小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排坐成一个 $m$ 行 $n$ 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 $(1,1)$，小轩坐在矩阵的右下角，坐标 $(m,n)$。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。

在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。

还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 $0$ 表示），可以用一个 $[0,100]$ 内的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。


## 说明/提示

**【数据范围】**

对于 $30\%$ 的数据，满足 $1 \le m,n \le 10$。  
对于 $100\%$ 的数据，满足 $1 \le m,n \le 50$。

**【题目来源】**

NOIP 2008 提高组第三题。

## 样例 #1

### 输入

```
3 3
0 3 9
2 8 5
5 7 0
```

### 输出

```
34```

# AI分析结果



## 【唯一算法分类】  
**线性DP**

---

## 【综合分析与结论】  
**核心思路**  
题目要求找两条从左上到右下的不相交路径，使得好感度之和最大。可转化为同时寻找两条路径，用动态规划同步处理两个点的移动，确保路径不重复。

**关键难点与解决**  
1. **状态设计**：需同步记录两个点的位置。三维DP（总步数+两点的纵坐标）或四维DP（两点的坐标）是常见思路，利用步数之和固定来降维。  
2. **路径去重**：通过约束第二个点始终在第一个点的右下方（i < j）或在同一步数下严格不重叠。  
3. **空间优化**：滚动数组压缩三维到二维，倒序枚举避免覆盖。  

**状态转移方程**  
- 三维DP：`F[k][i][j] = max(F[k-1][i-1][j], F[k-1][i][j-1], ...) + a[i][k-i] + a[j][k-j]`  
- 四维DP：`dp[i][j][k][l] = max(四种前驱状态) + a[i][j] + a[k][l]`  

---

## 【题解评分 (≥4星)】  
1. **聪明王必胜 (5星)**  
   - **亮点**：三维状态设计巧妙，利用步数之和固定降维，代码简洁。  
   - **关键代码**：  
     ```cpp  
     F[k][i][j] = max(F[k-1][i][j], F[k-1][i-1][j], ...) + a[k-i][i] + a[k-j][j];  
     ```  
2. **ouuan (5星)**  
   - **亮点**：滚动数组优化空间至二维，倒序枚举避免覆盖，适合大数据。  
   - **关键代码**：  
     ```cpp  
     f[j][k] = max(f[j][k], f[j-1][k-1]) + a[j][i-j] + a[k][i-k];  
     ```  
3. **Eric1030 (4星)**  
   - **亮点**：详细注释与分步解释，适合初学者理解三维DP逻辑。  

---

## 【最优思路提炼】  
**关键技巧**  
1. **同步移动双路径**：将两条路径视为同步移动，总步数固定，用步数和坐标差降维。  
2. **滚动数组优化**：仅保留当前步数层，节省空间复杂度至O(n²)。  
3. **严格路径约束**：通过限制`i < j`或`k > i`确保路径不重叠。  

**代码片段 (ouuan的滚动数组实现)**  
```cpp  
for (int i=4;i<n+m;++i)  
    for (int j=min(i-2,n);j>=1;--j) // 倒序枚举j和k  
        for (int k=min(i-1,n);k>j;--k)  
            f[j][k] = max(...) + a[j][i-j] + a[k][i-k];  
```

---

## 【同类型题与算法套路】  
- **双路径DP**：适用于需同时处理两条不相交路径的问题。  
- **推荐题目**  
  1. [P1004 方格取数](https://www.luogu.com.cn/problem/P1004)  
  2. [P2776 路径计数（加强版）](https://www.luogu.com.cn/problem/P2776)  
  3. [T35377 大教室中传纸条（数据加强）](https://www.luogu.com.cn/problem/T35377)  

---

## 【可视化设计要点】  
**动画方案**  
1. **像素风格DP矩阵**：  
   - **Canvas网格**：绘制步数轴与坐标网格，每个格子表示状态值。  
   - **颜色标记**：当前步数层用绿色，前驱状态用黄色，最大值更新时闪烁。  
2. **音效触发**：  
   - **状态更新**：短促“滴”声。  
   - **找到最优解**：8-bit胜利音效。  
3. **自动演示模式**：  
   - **AI步进**：按步数自动推进，高亮当前处理的两个点。  
   - **交互控制**：支持暂停/继续/步进，速度调节（1x, 2x, 5x）。  

**复古游戏化示例 (伪代码)**  
```javascript  
// 初始化Canvas与音效  
const grid = new PixelGrid(rows, cols);  
grid.highlightCell(i1, j1, '#00FF00'); // 绿色标记路径1  
grid.highlightCell(i2, j2, '#FF0000'); // 红色标记路径2  
playSound('step'); // 更新音效  
```

---

## 【个人心得摘录】  
- **Eric1030**：调试中发现未处理`i == j`导致重复计算，加入条件判断后AC。  
- **Tomwsc**：四维DP需注意坐标枚举顺序，避免无效状态浪费计算。  

---

## 【推荐代码实现】  
**ouuan的滚动数组优化 (核心部分)**  
```cpp  
#include <iostream>  
#include <algorithm>  
using namespace std;  
int n, m, f[210][210], a[210][210];  
int main() {  
    cin >> n >> m;  
    for (int i=1; i<=n; ++i)  
        for (int j=1; j<=m; ++j)  
            cin >> a[i][j];  
    memset(f, -1, sizeof(f));  
    f[1][2] = a[1][2] + a[2][1];  
    for (int i=4; i<n+m; ++i)  
        for (int j=min(i-2,n); j>=1; --j)  
            for (int k=min(i-1,n); k>j; --k) {  
                int s = max({f[j-1][k], f[j][k-1], ...});  
                f[j][k] = s + a[j][i-j] + a[k][i-k];  
            }  
    cout << f[n-1][n];  
    return 0;  
}  
```

---
处理用时：82.98秒
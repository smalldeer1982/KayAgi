# 题目信息

# [NOIP 2003 提高组] 神经网络

## 题目背景

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。



## 题目描述

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)

神经元（编号为 $i$）


图中，$X_1 \sim X_3$ 是信息输入渠道，$Y_1 \sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)

兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）

$$C_i=\left(\sum\limits_{(j,i) \in E} W_{ji}C_{j}\right)-U_{i}$$

公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。



## 说明/提示

**【题目来源】**

NOIP 2003 提高组第一题

## 样例 #1

### 输入

```
5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
```

### 输出

```
3 1
4 1
5 1
```

# AI分析结果



---

## 算法分类  
**无算法分类**（拓扑排序 + 层次遍历）

---

## 综合分析与结论  
### 核心思路与解决难点  
1. **拓扑排序保证计算顺序**：神经元按层次排列，必须确保前驱节点（上一层的神经元）先被处理完毕，再处理当前节点。  
2. **阈值处理**：中间层和输出层的神经元需在计算时减去阈值，但输入层初始状态直接使用，不参与阈值减法。  
3. **激活条件判断**：仅当神经元状态 `C[i] > 0` 时才会向下一层传递信号，需在拓扑排序过程中动态判断。  
4. **输出层识别**：输出层神经元定义为出度为0的节点，需遍历结束后统一筛选。

### 可视化设计要点  
1. **动态网格动画**：  
   - **颜色标记**：输入层（绿色）、中间层（黄色）、输出层（红色）；激活状态（高亮）、未激活（灰暗）。  
   - **高亮当前节点**：队列处理到某个神经元时，其对应网格方块闪烁，并显示当前状态值。  
   - **状态转移线条**：用流动线条表示信号传递，权重值随线条颜色深浅变化。  
2. **复古像素风格**：  
   - **8位音效**：节点激活时播放短促“哔”声，传递信号时播放“滴答”声，错误时播放低沉音效。  
   - **Canvas网格**：每个神经元用16x16像素方块表示，状态更新时数值以像素字体显示。  
3. **交互控制面板**：  
   - **步进执行**：用户可点击“Next Step”观察拓扑排序和状态更新的每一步。  
   - **速度调节**：滑动条控制动画速度，支持暂停/继续。  

---

## 题解清单（≥4星）  
1. **Lucaster_（5星）**  
   - **亮点**：队列拓扑排序预处理输入层，阈值减法逻辑清晰，出度数组标记输出层。  
   - **代码片段**：  
     ```cpp  
     while (!q.empty()) {  
         h = q.front(); q.pop();  
         for (遍历邻接边) {  
             if (当前节点状态 <= 0) continue;  
             更新下一节点状态，并判断是否入队。  
         }  
     }  
     ```  
   - **个人心得**：调试中发现输入层阈值处理错误，修正后AC。  

2. **zzlzk（4星）**  
   - **亮点**：反向建图递归计算输出层，避免显式拓扑排序。  
   - **技巧**：记忆化搜索直接计算每个输出层节点的状态。  

3. **dingcx（4星）**  
   - **亮点**：显式记录层数，分层次处理神经元状态更新。  
   - **关键代码**：  
     ```cpp  
     for (每层遍历) {  
         if (非输入层) 减阈值;  
         激活状态下传递信号。  
     }  
     ```  

---

## 核心实现代码  
**Lucaster_ 题解的关键逻辑（C++）**  
```cpp  
// 预处理输入层入队  
for (int i=1; i<=n; ++i) {  
    if (c[i] > 0) {  
        q.push(i);  
        vis[i] = true;  
    } else {  
        c[i] -= u[i]; // 非输入层提前减阈值  
    }  
}  

// 拓扑排序处理  
while (!q.empty()) {  
    int h = q.front(); q.pop();  
    for (邻接边遍历) {  
        if (c[h] <= 0) continue;  
        int t = e[i].to;  
        c[t] += e[i].val * c[h];  
        if (!vis[t]) {  
            q.push(t);  
            vis[t] = true;  
        }  
    }  
}  

// 输出结果筛选  
for (int i=1; i<=n; ++i) {  
    if (out[i] == 0 && c[i] > 0) {  
        记录输出层节点;  
    }  
}  
```  

---

## 同类型题推荐  
1. **P1119 灾后重建**（拓扑排序 + 动态规划）  
2. **P3387 缩点**（DAG处理与拓扑排序结合）  
3. **P4017 最大食物链计数**（拓扑排序 + 路径计数）  

---

## 可视化实现（伪代码）  
```javascript  
// Canvas初始化与网格绘制  
const grid = new PixelGrid(16, 16, 32); // 32x32像素每个节点  
grid.drawNeuron(neuronId, color);  

// 动画更新逻辑  
function updateStep() {  
    let current = queue.dequeue();  
    grid.highlight(current, 'yellow');  
    for (let edge of current.edges) {  
        grid.drawFlow(current, edge.target, edge.weight);  
        edge.target.state += current.state * edge.weight;  
        if (edge.target.state > 0 && !edge.target.visited) {  
            queue.enqueue(edge.target);  
            edge.target.visited = true;  
        }  
    }  
    grid.updateState(current);  
}  

// 音效触发  
Audio.play('activate', current.state > 0 ? 'high' : 'low');  
```  

---

**关键提示**：通过拓扑排序确保层次处理顺序，阈值减法需区分输入层，输出层判断结合出度数组。

---
处理用时：77.90秒
# 题目信息

# [NOIP 2009 提高组] Hankson 的趣味题

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。

今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：

1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；

2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。

Hankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。


## 说明/提示

**【样例解释】**

第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。

第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。

**【数据范围】**

- 对于 $50\%$ 的数据，保证有 $1\leq a_0,a_1,b_0,b_1 \leq 10000$ 且 $n \leq 100$。
- 对于 $100\%$ 的数据，保证有 $1 \leq a_0,a_1,b_0,b_1 \leq 2 \times 10^9$ 且 $n≤2000$。

NOIP 2009 提高组 第二题


## 样例 #1

### 输入

```
2 
41 1 96 288 
95 1 37 1776 ```

### 输出

```
6 
2```

# AI分析结果



## 算法分类
无算法分类（数论/质因数分解/因数枚举）

---

## 综合分析与结论

### 核心思路
1. **因数枚举法**  
   核心思想：x必须是b₁的因数。通过枚举b₁的所有因数（至sqrt(b₁)），检查每个因数是否满足以下条件：  
   - gcd(x, a₀) = a₁  
   - lcm(x, b₀) = b₁  
   时间复杂度：O(√b₁ * log b₁) 每组数据，通过剪枝可AC。  

2. **质因数分解法**  
   核心思想：对a₀/a₁、b₁/b₀进行质因数分解，通过指数约束确定x的质因数指数范围。  
   关键步骤：  
   - 分解每个数质因数  
   - 对每个质因数p，确定x的指数必须满足的区间  
   - 各质因数可能数相乘得总方案数  
   复杂度：O(√n) 预处理质数表 + 分解质因数。

### 解决难点
- **因数枚举法**：需处理成对因数，避免重复计算。  
- **质因数分解法**：需处理大质数（如b₁未被质数表覆盖时），需分类讨论指数约束条件。

### 可视化设计
1. **因数枚举动态演示**：  
   - 网格展示√b₁范围内的因数i，动态标记i和b₁/i。  
   - 高亮当前检查的因数，显示gcd/lcm计算结果，红色标记不符合条件，绿色标记通过。  
   - 示例：b₁=288时，枚举i=9→检查成功，显示gcd(9,41)=1，lcm(9,96)=288。  

2. **质因数分解过程**：  
   - 分解a₀、a₁、b₀、b₁的质因数，展示每个质因数的指数关系。  
   - 如p=3时，a₀=0次，a₁=0次 → x的指数≥0；b₀=5次，b₁=5次 → x指数≤5。  
   - 动态生成指数区间，相乘得结果。  

---

## 题解评分（≥4星）

1. **zzlzk（4星）**  
   - 亮点：简洁枚举，代码清晰，适合快速实现。  
   - 代码关键：成对枚举因数，避免重复计数。  

2. **KesdiaelKen（5星）**  
   - 亮点：深入数学推导，优化算法复杂度，核心思路可推广。  
   - 关键代码：质因数分解后处理指数约束。  

3. **皎月半洒花（4星）**  
   - 亮点：唯一分解定理应用清晰，适合数学思维训练。  
   - 代码细节：处理大质数时的特判逻辑。  

---

## 最优思路提炼

**关键技巧**：  
1. **因数成对枚举**：将O(b₁)优化至O(√b₁)。  
2. **质因数指数约束**：通过分解后的指数区间确定可能数。  
3. **剪枝优化**：提前排除无效情况（如b₁不被a₁整除）。  

**代码实现核心**：  
```cpp
for(int x=1;x*x<=b1;x++){
    if(b1%x!=0) continue;
    if(check(x)) ans++; // 检查i和b1/i
}
```

---

## 同类型题推荐
1. **P1029 最大公约数和最小公倍数问题**  
2. **P2444 最小公倍数计数**  
3. **P2651 添加括号III**  

---

## 可视化与算法演示

### 动态因数检查（Canvas实现）
```javascript
// 示例：枚举i=9，b1=288
drawGrid(b1); // 绘制1~sqrt(b1)的格子
highlightCell(9); // 高亮i=9
showCalculation(`gcd(9,41)=1, lcm(9,96)=288 → 有效`);
```

### 像素风格DP矩阵
- **8位色调色板**：绿色（有效因数）、红色（无效）、黄色（当前检查）。  
- **音效**：通过时播放“金币声”，失败时“低沉音效”。  

---

## 代码片段（因数枚举法）
```cpp
#include<cstdio>
using namespace std;
int gcd(int a,int b){return b?gcd(b,a%b):a;}

int main(){
    int T,a0,a1,b0,b1;
    scanf("%d",&T);
    while(T--){
        int ans=0;
        scanf("%d%d%d%d",&a0,&a1,&b0,&b1);
        for(int x=1;x*x<=b1;x++){ // 枚举因数对
            if(b1%x!=0) continue;
            // 检查x和b1/x
            if(x%a1==0 && gcd(x/a1, a0/a1)==1 && gcd(b1/b0, b1/x)==1) 
                ans++;
            int y=b1/x;
            if(x!=y && y%a1==0 && gcd(y/a1, a0/a1)==1 && gcd(b1/b0, b1/y)==1)
                ans++;
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

---
处理用时：80.77秒
# 题目信息

# [NOIP 2007 普及组] 守望者的逃离

## 题目背景

NOIP2007 普及组 T3

## 题目描述

恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。

守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。

为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。

守望者的跑步速度为 $17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1s$ 内移动 $60m$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。

现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间 $T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。

注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。


## 说明/提示

对于 $30\%$ 的数据，$1  \le  T   \le  10$，$ 1   \le   S   \le  100$；

对于 $50\%$ 的数据，$1   \le  T   \le   10^3$，$ 1   \le  S  \le   10^4$；

对于 $100\%$ 的数据，$1   \le   T   \le   3\times  10^5$，$0   \le   M   \le   10^3$，$ 1   \le  S   \le   10^8$。


## 样例 #1

### 输入

```
39 200 4
```

### 输出

```
No
197
```

## 样例 #2

### 输入

```
36 255 10```

### 输出

```
Yes
6```

# AI分析结果



**唯一算法分类**：线性DP

---

### 题解思路与算法要点
**核心难点**：在魔法值不足时，需在恢复魔法与跑步之间选择最优策略。动态规划的状态转移需综合考虑时间、魔法值、距离三者的动态关系。

**关键思路**：
1. **贪心与DP结合**：优先使用魔法闪现（60m/s > 17m/s），同时维护两种状态：
   - `s2`：仅通过魔法闪现移动的累计距离
   - `s1`：结合闪现和跑步的动态最优距离，每次取 `max(s1+17, s2)`
2. **状态转移方程**：
   ```cpp
   for(int i=1; i<=t; i++) {
       if (魔法≥10) s2 += 60, 魔法-10;
       else 魔法 +=4;
       s1 = max(s1+17, s2); // 核心状态转移
   }
   ```
3. **优化手段**：用两个变量代替数组，空间复杂度O(1)，适用于T≤3e5的大数据范围。

---

### 题解评分（≥4星）
1. **wzr1125（5星）**  
   - **亮点**：双变量贪心，代码简洁高效（仅20行），清晰展示状态维护逻辑。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=t;i++){ 
         if(m>=10) m-=10,fla+=60, run+=17;
         else m+=4, run+=17;
         run = max(run, fla);
     }
     ```

2. **qhr2023（4星）**  
   - **亮点**：极致简化代码（7行），用三目运算符优化判断逻辑。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=t;i++){
         m>=10?m-=10,s2+=60:m+=4; 
         s1=max(s1+17,s2);
     }
     ```

3. **GLr137（4星）**  
   - **亮点**：标准线性DP实现，分两步处理闪现和跑步，适合教学理解。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=t;i++){ // 先处理闪现
         dp[i] = dp[i-1] + (m>=10 ? 60 : 0);
         m = (m>=10) ? m-10 : m+4;
     }
     for(int i=1;i<=t;i++){ // 再处理跑步
         dp[i] = max(dp[i], dp[i-1]+17);
     }
     ```

---

### 最优技巧提炼
1. **双状态贪心**：维护闪现距离与跑步距离，通过`max`实时更新最优解。
2. **时间线性推进**：每秒独立处理，避免复杂的状态依赖。
3. **魔法值动态调整**：魔法不足时累计恢复量，达到10立即使用。

---

### 同类型题与算法套路
- **套路**：时间轴上的动态决策问题，常见于资源（如魔法、能量）受限的最优路径问题。
- **相似题目**：
  1. **P1002 过河卒**（状态转移与路径计数）
  2. **P1048 采药**（0-1背包问题）
  3. **P1090 合并果子**（贪心策略优化）

---

### 可视化设计（像素风格DP动画）
**实现方案**：
1. **Canvas网格**：横向为时间（0-T秒），纵向为距离（0-S米），每个格子表示1秒内的状态。
2. **动态更新**：
   - **红色方块**：代表闪现距离`s2`，每次闪现时方块右跳60格。
   - **蓝色方块**：代表跑步距离`s1`，每帧右移17格，当超过红色时变色。
3. **音效触发**：
   - `叮~`：成功使用闪现
   - `哒哒`：跑步声效
   - `胜利旋律`：当任一方块到达S时播放

**交互功能**：
- **速度调节**：滑动条控制每秒帧数（1x-10x）
- **单步调试**：按空格暂停/继续，右键单步执行

---

**代码片段（JS核心逻辑）**：
```javascript
function simulate() {
  let s1 = 0, s2 = 0, m = initialM;
  for (let t = 1; t <= T; t++) {
    if (m >= 10) {
      s2 += 60;
      m -= 10;
      playSound('magic'); // 触发闪现音效
    } else {
      m += 4;
    }
    s1 = Math.max(s1 + 17, s2);
    drawCanvas(t, s1, s2); // 更新Canvas绘制
  }
}
```

---

**个人心得**：
> "最初尝试分情况讨论魔法恢复策略，代码复杂易错。后来发现维护双状态取max的贪心策略，不仅代码简洁，还能覆盖所有情况，真是大道至简！" —— wzr1125

---
处理用时：63.66秒
# 题目信息

# [BJWC2008] 雷涛的小猫

## 题目背景

原最大整数参见 P1012

## 题目描述

雷涛同学非常的有爱心，在他的宿舍里，养着一只因为受伤被救助的小猫（当然，这样的行为是违反学生宿舍管理条例的）。在他的照顾下，小猫很快恢复了健康，并且愈发的活泼可爱了。

可是有一天，雷涛下课回到寝室，却发现小猫不见了！经过一番寻找，才发现她正趴在阳台上对窗外的柿子树发呆…

在北京大学的校园里，有许多柿子树，在雷涛所在的宿舍楼前，就有 $N$ 棵。并且这 $N$ 棵柿子树每棵的高度都是 $H$。冬天的寒冷渐渐笼罩了大地，树上的叶子渐渐掉光了，只剩下一个个黄澄澄的柿子，看着非常喜人。而雷涛的小猫恰好非常的爱吃柿子，看着窗外树上的柿子，她十分眼馋，于是决定利用自己敏捷的跳跃能力跳到树上去吃柿子。

小猫可以从宿舍的阳台上跳到窗外任意一棵柿子树的树顶。之后，她每次都可以在当前位置沿着当前所在的柿子树向下跳 $1$ 单位距离。当然，小猫的能力远不止如此，她还可以在树之间跳跃。每次她都可以从当前这棵树跳到另外的任意一棵，在这个过程中，她的高度会下降 `Delta` 单位距离。每个时刻，只要她所在的位置有柿子，她就可以吃掉。整个“吃柿子行动”一直到小猫落到地面上为止。

雷涛调查了所有柿子树上柿子的生长情况。他很想知道，小猫从阳台出发，最多能吃到多少柿子？他知道写一个程序可以很容易的解决这个问题，但是他现在懒于写任何代码。于是，现在你的任务就是帮助雷涛写一个这样的程序。

图为 $N=3, H=10, Delta=2$ 的一个例子。小猫按照图示路线进行跳跃，可以吃到最多的 $8$ 个柿子。

![](https://cdn.luogu.com.cn/upload/image_hosting/69gyw9xt.png)


## 说明/提示

### 数据范围及约定

对于全部数据，$1 \leq N, H ≤ 2000$，$0 \leq N_i ≤ 5000$，$1 ≤ Delta ≤ N,1 ≤ T_{i,j} ≤ H$。

输入文件大小不大于 40MB。注意输入输出效率。

来源 Excalibur, 2008。

## 样例 #1

### 输入

```
3 10 2
3 1 4 10
6 3 5 9 7 8 9
5 4 5 3 6 9```

### 输出

```
8```

# AI分析结果



# 【算法分类】
**线性DP**

---

# 【题解思路与难点分析】

### **核心思路**
- **状态定义**：`dp[i][j]` 表示在第 `i` 棵树、高度 `j` 时能吃到的最多柿子数。
- **转移方程**：
  - 从同一棵树下降：`dp[i][j] = dp[i][j+1] + a[i][j]`
  - 从其他树跳跃：`dp[i][j] = max_prev[j+Delta] + a[i][j]`
  - 最终取两者的最大值。
- **辅助数组**：维护 `max_prev[j]` 记录高度 `j` 时的全局最大值，避免枚举所有树。

### **解决难点**
1. **跳跃优化**：跳跃转移需要所有树在 `j+Delta` 高度的最大值，直接枚举导致 O(n²h) 复杂度。通过 `max_prev` 数组将跳跃转移优化至 O(1)。
2. **遍历顺序**：从高到低处理高度，确保状态转移依赖的值已计算。
3. **预处理**：将输入数据转换为每棵树各高度的柿子数量矩阵 `a[i][j]`。

---

# 【题解评分（≥4星）】

### **题解1：issue_is_fw（★★★★☆）**
- **亮点**：清晰解释暴力到优化的思路，代码简洁，维护 `pre` 数组实现 O(nh) 复杂度。
- **代码核心**：
  ```cpp
  for (int j = h; j >= 0; j--) {
    for (int i = 1; i <= n; i++) {
      dp[i][j] = a[i][j] + dp[i][j+1];
      dp[i][j] = max(dp[i][j], pre[j+de] + a[i][j]);
      pre[j] = max(pre[j], dp[i][j]);
    }
  }
  ```

### **题解2：良辰何需美景（★★★★★）**
- **亮点**：代码极简，直接维护 `ret` 数组，输出 `ret[h]` 一步到位。
- **代码核心**：
  ```cpp
  for (int j = 1; j <= h; j++) {
    for (int i = 1; i <= n; i++) {
      if (j > d) f[i][j] = max(f[i][j-1], ret[j-d]) + a[i][j];
      else f[i][j] = f[i][j-1] + a[i][j];
      ret[j] = max(ret[j], f[i][j]);
    }
  }
  ```

### **题解3：sxyugao（★★★★☆）**
- **亮点**：详细推导优化思路，强调 `g[i]` 表示高度 `i` 的最大值。
- **代码核心**：
  ```cpp
  for (int i = 1; i <= h; i++) {
    for (int j = 1; j <= n; j++) f[i][j] = f[i-1][j] + a[j][i];
    if (i > d) for (int j = 1; j <= n; j++) f[i][j] = max(f[i][j], g[i-d] + a[j][i]);
    for (int j = 1; j <= n; j++) g[i] = max(f[i][j], g[i]);
  }
  ```

---

# 【最优思路提炼】
- **关键优化**：维护全局最大值数组 `max_prev`，将跳跃转移复杂度从 O(n) 降为 O(1)。
- **实现技巧**：倒序处理高度，确保状态依赖已计算；预处理输入数据为二维数组 `a[i][j]`。
- **思维模式**：识别重复计算场景（所有树的最大值），用辅助数据结构优化。

---

# 【同类型题推荐】
1. **P1725 琪露诺**（滑动窗口优化跳跃 DP）
2. **P1091 合唱队形**（双向线性 DP）
3. **P1280 尼克的任务**（时间线逆向 DP）

---

# 【可视化设计：动态规划矩阵动画】

### **动画方案**
- **8位像素风格**：用复古绿色调绘制 DP 矩阵，每格表示 `dp[i][j]`。
- **步进控制**：按高度从高到低逐步渲染，当前处理的高度用闪烁边框标记。
- **转移高亮**：
  - 蓝色：从同一棵树转移（`dp[i][j+1]`）。
  - 红色：从 `max_prev[j+Delta]` 跳跃转移。
- **音效**：
  - 转移时播放 "beep" 音效。
  - 更新 `max_prev` 时播放 "ping" 音效。

### **代码片段（伪代码）**
```javascript
// Canvas 初始化
const grid = new PixelGrid(n, h, {palette: 'retro'});

// 动画循环
for (let j = h; j >= 0; j--) {
  grid.highlightHeight(j); // 闪烁当前高度
  for (let i = 0; i < n; i++) {
    const sameTree = dp[i][j+1] + a[i][j];
    const jump = max_prev[j+delta] + a[i][j];
    dp[i][j] = Math.max(sameTree, jump);
    grid.setCell(i, j, dp[i][j], {color: sameTree > jump ? 'blue' : 'red'});
    playSound('beep');
  }
  max_prev[j] = Math.max(...dp.map(row => row[j]));
  grid.updateLegend(max_prev); // 更新右侧最大值显示
  playSound('ping');
}
```

---

# **总结**
通过维护全局最大值数组优化跳跃转移，将复杂度降至 O(nh)，是典型的线性 DP 优化。代码实现简洁高效，适合作为动态规划优化的经典例题。

---
处理用时：91.58秒
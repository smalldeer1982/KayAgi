# 题目信息

# [USACO1.4] 铺放矩形块 Packing Rectangles

## 题目描述

给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)

$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  

这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。

可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，输入的所有数在 $[1,50]$ 内。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5
```

### 输出

```
40
4 10
5 8
```

# AI分析结果



**唯一算法分类**：枚举（暴力搜索）

---

### **题解思路与核心难点分析**

**核心思路**：  
1. **排列组合**：4个矩形可全排列（4!种顺序），每个矩形可旋转（长宽互换，2^4种情况）。  
2. **六种基本布局**：题目给定的6种摆放方式需分别计算封闭矩形的长宽。  
3. **面积更新**：对所有可能的排列和布局计算面积，维护最小值及对应长宽。

**解决难点**：  
1. **覆盖所有情况**：通过全排列+旋转生成所有可能的矩形排列组合。  
2. **布局计算**：对每种排列，需正确推导6种布局的长宽公式，尤其是复杂的第六种情况（需分5种子情况处理）。

---

### **题解评分 (≥4星)**

1. **七喜 (4.5星)**  
   - **亮点**：DFS生成排列，代码结构清晰，注释详细，覆盖6种布局。  
   - **优化点**：使用DFS代替多重循环，适合教学演示。

2. **HFUUZY (4星)**  
   - **亮点**：全排列+四重循环处理旋转，逻辑紧凑，代码高效。  
   - **不足**：多重嵌套影响可读性，但覆盖所有情况。

3. **Chiesl (4.2星)**  
   - **亮点**：结构体存储答案，分情况讨论详细，适合理解布局推导。  
   - **优化**：可视化注释帮助理解复杂布局。

---

### **最优技巧提炼**

1. **全排列+旋转覆盖所有可能**：  
   ```cpp
   do {
       for (int i=0; i<16; i++) { // 2^4种旋转
           // 处理每个矩形的旋转状态
       }
   } while (next_permutation(order, order+4));
   ```

2. **布局公式化**：  
   将6种布局的长宽计算封装为函数，如：  
   ```cpp
   // 布局1：四个矩形横向排列
   x = sum_width; y = max_height;
   // 布局6：复杂交错排列（分5种子情况）
   if (h3 >= h2+h4) x = ...;
   ```

3. **去重与存储**：  
   使用集合或数组标记已出现的长宽组合，避免重复输出。

---

### **同类型题与算法套路**

- **通用思路**：枚举所有可能状态 + 几何推导。  
- **相似题目**：  
  1. [P5917 [IOI1994] 矩形覆盖](https://www.luogu.com.cn/problem/P5917)（双倍经验）  
  2. [P1058 立体图](https://www.luogu.com.cn/problem/P1058)（空间布局枚举）  
  3. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)（全排列+剪枝）

---

### **个人心得摘录**

- **调试教训**：第六种布局的分支判断极易遗漏边界条件（如 `h3 == h4`）。  
- **顿悟点**：通过画图明确每个子情况的长宽推导，减少公式错误。

---

### **可视化与算法演示设计**

**核心流程动画**：  
1. **像素化矩形块**：每个矩形用不同颜色块表示，长宽以像素数显示。  
2. **动态排列**：展示全排列生成过程，高亮当前处理的矩形。  
3. **布局切换**：点击按钮切换6种布局，动态计算长宽并绘制封闭矩形框。

**复古游戏化设计**：  
- **像素音效**：  
  - 排列切换时播放“滴”声，布局计算成功时播放“叮”声。  
  - 背景音乐为8位芯片风格循环曲。  
- **Canvas动画**：  
  ```javascript
  // 绘制矩形块（示例）
  ctx.fillStyle = '#FF0000';
  ctx.fillRect(x, y, width, height);
  // 播放音效
  function playBeep() { /* Web Audio API实现 */ }
  ```
- **自动演示模式**：  
  - 按空格键暂停/继续，方向键控制演示速度。

---

### **代码片段（核心逻辑）**

**全排列与旋转处理**：  
```cpp
void dfs(int depth) {
    if (depth == 4) {
        check_layouts(); // 计算所有布局
        return;
    }
    for (int i=0; i<4; i++) {
        if (!used[i]) {
            used[i] = true;
            // 不旋转
            rects[depth] = original[i];
            dfs(depth+1);
            // 旋转长宽
            swap(rects[depth].w, rects[depth].h);
            dfs(depth+1);
            used[i] = false;
        }
    }
}
```

**布局计算（示例：第六种）**：  
```cpp
void layout6() {
    int h1 = rects[0].h, h2 = rects[1].h, h3 = rects[2].h, h4 = rects[3].h;
    int total_h = max(h1 + h3, h2 + h4);
    int total_w;
    if (h3 >= h2 + h4) {
        total_w = max(rects[1].w, max(rects[0].w, rects[2].w) + rects[3].w);
    } else if (h3 > h4 && h3 < h2 + h4) {
        total_w = max(rects[0].w + rects[1].w, max(rects[0].w, rects[2].w) + rects[3].w);
    }
    // ...其他子情况
    update_min_area(total_w, total_h);
}
```

---

**可视化与教学价值**：通过动态排列和布局切换，直观展示暴力搜索与几何分析的结合，适合算法初学者理解枚举思想。

---
处理用时：68.03秒
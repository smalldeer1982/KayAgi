# 题目信息

# [IOI 1994] 数字三角形 Number Triangles

## 题目描述

观察下面的数字金字塔。


写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。

![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)

在上面的样例中，从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大权值。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le r \le 1000$，所有输入在 $[0,100]$ 范围内。

题目翻译来自NOCOW。

USACO Training Section 1.5

IOI1994 Day1T1

## 样例 #1

### 输入

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5 
```

### 输出

```
30
```

# AI分析结果



### 唯一算法分类  
**动态规划**

---

### 综合分析与结论  
**核心思路**：  
所有题解均采用动态规划思想，分为自底向上递推和自顶向下记忆化搜索两种方向。自底向上通过从最后一行开始逐层向上计算每个节点的最大路径和，最终顶端值即为答案；自顶向下则需递归+记忆化避免重复计算。

**算法流程可视化设计**：  
1. **动画方案**：  
   - **网格绘制**：将数字三角形以网格形式展示，每个节点显示当前值。  
   - **颜色标记**：  
     - 当前处理节点高亮为黄色  
     - 下方两个子节点高亮为蓝色  
     - 更新后的值用绿色闪烁  
   - **步进逻辑**：从倒数第二层开始，按从左到右顺序处理每个节点，比较下方两个子节点的值，更新当前节点值。  

2. **复古像素风格**：  
   - **8位色板**：使用深蓝背景，白色网格线，节点值用黄色像素字体显示。  
   - **音效**：  
     - 节点更新时播放“哔”声  
     - 路径更新时播放“叮咚”声  
   - **Canvas动画**：用矩形块表示节点，箭头动态连接子节点，模拟数据流动。  

---

### 题解清单（≥4星）  
1. **linlin1024（5星）**  
   - **亮点**：自底向上递推，原地修改数组，代码简洁直观。  
   - **核心代码**：  
     ```cpp
     for(int i=n-2;i>=0;i--) 
         for(int j=0;j<=i;j++)
             a[i][j] += max(a[i+1][j], a[i+1][j+1]);
     ```

2. **iwprc（4星）**  
   - **亮点**：一维数组空间优化，边读边处理。  
   - **核心代码**：  
     ```cpp
     for(int i=n-1;i;i--)
         for(int j=i;j<=n;j++)
             a[j] = max(a[j],a[j+1]) + p;
     ```

3. **MuelsyseU（4星）**  
   - **亮点**：详细分析空间压缩技巧，实现滚动数组优化。  
   - **关键片段**：  
     ```cpp
     for(int i=n-1;i>=1;i--)
         for(int j=1;j<=i;j++)
             dp[j] = max(dp[j], dp[j+1]) + a[i][j];
     ```

---

### 最优思路与技巧提炼  
1. **状态压缩**：用一维数组代替二维数组，空间复杂度从 O(n²) 降至 O(n)。  
2. **逆序更新**：处理一维数组时从右向左更新，避免覆盖未使用的数据。  
3. **就地修改**：直接在输入数组上更新最大值，无需额外存储空间。  

---

### 类似题目推荐  
1. **P1115 最大子段和**（一维DP）  
2. **P1434 滑雪**（网格DP+记忆化搜索）  
3. **P1216 [USACO1.5]数字三角形**（本题，但可尝试其他变种）

---

### 个人心得摘录  
> “最初尝试记忆化搜索递归超时，改为逆序递推后效率大幅提升。动态规划的核心在于找到无后效性的状态表示。” —— Mine_King  
> “从下往上推时，每个节点的最优解仅依赖下层结果，这种无后效性让递推变得自然。” —— linlin1024  

---

### 核心算法实现（自底向上+一维优化）  
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int dp[1005]; // 一维数组优化

int main() {
    int n, x;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            cin >> x;
            dp[j] = max(dp[j], dp[j-1]) + x; // 逆序更新关键
        }
    }
    cout << *max_element(dp+1, dp+n+1);
    return 0;
}
```

---

### 可视化代码片段（JS Canvas）  
```javascript
// 绘制节点更新动画
function drawStep(layer, pos, newVal) {
    ctx.fillStyle = '#FFFF00'; // 当前节点黄色
    drawNode(layer, pos);
    setTimeout(() => {
        ctx.fillStyle = '#00FF00'; // 更新后绿色闪烁
        ctx.fillText(newVal, x, y);
    }, 500);
}
```

---
处理用时：63.75秒
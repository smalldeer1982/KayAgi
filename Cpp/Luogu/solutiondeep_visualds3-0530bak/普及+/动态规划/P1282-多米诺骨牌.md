# 题目信息

# 多米诺骨牌

## 题目描述

多米诺骨牌由上下 $2$ 个方块组成，每个方块中有 $1\sim6$ 个点。现有排成行的上方块中点数之和记为 $S_1$，下方块中点数之和记为 $S_2$，它们的差为 $\left|S_1-S_2\right|$。如图，$S1=6+1+1+1=9$，$S2=1+5+3+2=11$，$\left|S_1-S_2\right|=2$。每个多米诺骨牌可以旋转 $180°$，使得上下两个方块互换位置。请你计算最少旋转多少次才能使多米诺骨牌上下 $2$ 行点数之差达到最小。

![](https://cdn.luogu.com.cn/upload/pic/91.png)

对于图中的例子，只要将最后一个多米诺骨牌旋转 $180°$，即可使上下 $2$ 行点数之差为 $0$。

## 样例 #1

### 输入

```
4
6 1
1 5
1 3
1 2
```

### 输出

```
1
```

# AI分析结果



---

**唯一算法分类**: 0-1背包

---

### 综合分析与结论
**核心思路**：将每个骨牌视为物品，选择翻转/不翻转两种状态，转化为差值最小化的0-1背包问题。通过动态规划记录前i个骨牌形成特定差值时的最小翻转次数。

**关键难点**：
1. **差值处理**：需同时处理正负差值，通过设置偏移量（如+5000）将负数映射到合法数组下标
2. **状态转移**：每个骨牌有两种转移路径（翻转/不翻转），需同时考虑差值变化和翻转次数递增
3. **空间优化**：使用滚动数组或一维数组将空间复杂度从O(n²)优化到O(n)

**可视化设计要点**：
1. **DP矩阵动画**：展示二维网格，行表示骨牌序号，列表示差值（居中偏移），用绿色高亮当前更新的单元格
2. **状态转移追踪**：用箭头连接前序状态与当前状态，红色箭头表示翻转操作，蓝色表示不翻转
3. **像素风格**：采用16色复古调色板，每个状态单元格用8x8像素块表示，翻转时触发"哔"音效，找到最优解时播放胜利音效
4. **自动演示模式**：按帧推进DP填充过程，支持暂停查看任意步骤的状态值

---

### 题解清单（4星以上）
1. **fy0123（5星）**
   - 亮点：清晰定义`f[i][j]`为前i个骨牌上一行和为j的最小翻转次数
   - 核心代码：
     ```cpp
     for(int i=2; i<=n; i++)
         for(int j=0; j<=6*n; j++){
             if(j-a[i] >=0) f[i][j] = min(f[i][j], f[i-1][j-a[i]]);
             if(j-b[i] >=0) f[i][j] = min(f[i][j], f[i-1][j-b[i]]+1);
         }
     ```

2. **dj114133643（4.5星）**
   - 亮点：差值中心化处理，代码简洁易懂
   - 核心代码：
     ```cpp
     for(i=1; i<=n; i++)
         for(j=-5000; j<=5000; j++)
             f[i][j+N] = min(f[i-1][j-dis+N], f[i-1][j+dis+N]+1);
     ```

3. **pigstd（4星）**
   - 亮点：一维数组优化，空间效率最优
   - 核心代码：
     ```cpp
     for(int i=sum; i>=0; i--)
         if(f[i] != INF){
             f[i+x] = min(f[i+x], f[i]);
             f[i+y] = min(f[i+y], f[i]+1);
             f[i] = INF; // 状态重置
         }
     ```

---

### 最优思路提炼
1. **差值转换**：将问题转化为求上下行和的最小差值，总和不变量简化状态设计
2. **偏移量技巧**：通过`+N`（如5000）处理负数下标，避免数组越界
3. **滚动数组优化**：仅保留当前层状态，空间复杂度从O(n²)降为O(n)
4. **对称剪枝**：最终只需遍历差值绝对值最小的状态，无需全量搜索

---

### 相似题目推荐
1. **P1060 开心的金明**（0-1背包基础）
2. **P1048 采药**（经典0-1背包）
3. **P1164 小A点菜**（计数型背包变种）

---

### 可视化代码片段（JS Canvas）
```javascript
// 初始化画布
const canvas = document.getElementById('dp-grid');
const ctx = canvas.getContext('2d');
const colors = ['#000', '#0f0', '#f00', '#00f']; // 复古像素调色板

function drawDPCell(i, j, val) {
    ctx.fillStyle = val === Infinity ? colors[0] : colors[1];
    ctx.fillRect(j*8, i*8, 8, 8); // 8x8像素块
    if(val < Infinity) {
        ctx.fillStyle = colors[3];
        ctx.fillText(val, j*8+1, i*8+7); // 显示数值
    }
}

// 播放音效
function playSound(type) {
    const sfx = {
        flip: new Audio('data:audio/wav;base64,UklGRl9...'), // 翻转音效
        solved: new Audio('data:audio/wav;base64,UklGRkZ...') // 解题音效
    };
    sfx[type].play();
}
```

---

### 个人心得摘录
> "调试时发现必须重置上一轮状态，否则会重复计算。通过将f[i]设为INF再更新，避免了状态污染。" —— pigstd  
> "贪心看似可行，但遇到正负差值抵消的case就失败，深刻理解到DP的全局优化优势" —— Zerosking

---

### 算法演示设计
1. **初始化**：绘制偏移后的差值坐标系，骨牌序号为纵轴，差值为横轴
2. **步进演示**：
   - 高亮当前骨牌，显示其a/b值
   - 用流动光效展示状态转移路径（红/蓝箭头）
   - 更新单元格时播放对应音效
3. **胜利动画**：找到最小差值时，整行单元格闪烁金色，播放8-bit胜利音乐
4. **交互控制**：支持拖动进度条回溯任意步骤，右键查看状态详情

---
处理用时：88.44秒
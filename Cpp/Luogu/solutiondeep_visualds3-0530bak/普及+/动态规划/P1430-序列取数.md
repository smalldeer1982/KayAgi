# 题目信息

# 序列取数

## 题目描述

给定一个长为 $n$ 的整数序列 $(n \le 1000)$，由 A 和 B 轮流取数（A 先取）。每个人可从序列的左端或右端取若干个数（至少一个），但不能两端都取。所有数都被取走后，两人分别统计所取数的和作为各自的得分。假设 A 和 B 都足够聪明，都使自己得分尽量高，求 A 的最终得分。

## 样例 #1

### 输入

```
2

1 -1

2 1 2```

### 输出

```
-1

3```

# AI分析结果



## 算法分类
**线性DP**

---

## 题解思路与算法要点

### 核心逻辑
题目本质是博弈论中的极大极小问题，采用区间DP求解。核心状态定义为：
- `dp[i][j]`：区间`[i,j]`的先手最大得分
- `sum[i][j]`：区间`[i,j]`的总和

### 关键优化
1. **辅助数组优化**  
   通过维护前缀最小值数组`p[i][j]`和后缀最小值数组`q[i][j]`，将时间复杂度从O(n³)优化到O(n²)
2. **滚动数组优化**  
   iwprc的解法通过改变状态定义方式（`L[i][j]`必须取左端点，`R[i][j]`必须取右端点），利用区间长度递增特性，将空间复杂度优化到O(n)

### 状态转移方程
核心转移逻辑：当前得分 = 区间总和 - 对手在剩余区间的最优选择  
```python
dp[i][j] = sum[i][j] - min(0, p[i][j-1], q[i+1][j])
p[i][j] = min(p[i][j-1], dp[i][j])  # 维护前缀最小值
q[i][j] = min(q[i+1][j], dp[i][j])  # 维护后缀最小值
```

---

## 题解评分（≥4星）

### 1. Khassar（5星）
- **亮点**：通过`f[i][j]`和`g[i][j]`记录左右侧最小值，代码简洁高效
- **代码示例**：
```cpp
for(int L=1;L<=n;L++)
    for(int i=1;i+L<=n;i++){
        int j=i+L;
        m = min(0, min(f[i+1][j], g[i][j-1]));
        d[i][j] = s[j]-s[i-1] - m;
        f[i][j] = min(d[i][j], f[i+1][j]);
        g[i][j] = min(d[i][j], g[i][j-1]);
    }
```

### 2. zhlzt（5星）
- **亮点**：最简代码实现，直接维护`p[][]`和`q[][]`数组
- **核心代码**：
```cpp
for(int len=1;len<=n;len++)
    for(int i=1;i+len-1<=n;i++){
        j = i+len-1;
        dp[i][j] = sum[j] - sum[i-1] - min(0, p[i][j-1], q[i+1][j]);
        p[i][j] = min(p[i][j-1], dp[i][j]);
        q[i][j] = min(q[i+1][j], dp[i][j]);
    }
```

### 3. iwprc（4星）
- **亮点**：创新性的滚动数组优化，空间复杂度O(n)
- **核心优化**：
```cpp
for(j=1;j<n;j++)
    for(i=1;i+j<=n;i++){
        r[i] = a[i+j] + max(r[i], s[i+j-1]-s[i-1]-max(l[i],r[i]));
        l[i] = a[i] + max(l[i+1], s[i+j]-s[i]-max(l[i+1],r[i+1]));
    }
```

---

## 最优思路与技巧

### 核心思路
**极小化极大原理**：  
- 每个决策要考虑对手的最优响应，当前得分 = 区间总和 - 对手在剩余区间的最大可能得分
- 通过维护前缀/后缀最小值数组，避免重复计算子问题

### 关键技巧
1. **区间DP的滚动数组优化**  
   利用区间长度递增特性，复用数组空间
2. **博弈问题转换**  
   将两人得分问题转换为最大化差值问题，简化状态定义
3. **辅助数组设计**  
   `p[i][j]`记录区间`[i,j]`左侧取数的最小损失，`q[i][j]`记录右侧取数的最小损失

---

## 同类题目推荐
1. P1880 [NOI1995] 石子合并（区间DP经典）
2. P2590 [ZJOI2008] 树的统计（树形DP+区间操作）
3. P1005 [NOIP2007 提高组] 矩阵取数游戏（双端取数+高精度）

---

## 可视化设计

### 动画方案
1. **网格绘制**  
   在Canvas上绘制n×n的DP矩阵，每个格子代表`dp[i][j]`
2. **颜色标记**  
   - 红色：当前计算的`dp[i][j]`
   - 蓝色：依赖的子区间`dp[i+1][j]`和`dp[i][j-1]`
   - 黄色：辅助数组`p[i][j]`和`q[i][j]`
3. **步进演示**  
   按区间长度从小到大逐步填充矩阵，高亮转移路径

### 复古游戏化设计
1. **8位像素风格**  
   - 使用16色调色板（NES经典配色）
   - 每个DP格子用8×8像素方块表示
2. **音效设计**  
   - 转移计算：短促的"哔"声
   - 最优解更新：上升音阶
   - 错误操作：低沉警报声
3. **自动演示模式**  
   模拟"贪吃蛇AI"自动填充矩阵，按区间长度逐步推进

---

## 代码实现（zhlzt最优解）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int d[N],dp[N][N],p[N][N],q[N][N];

int main(){
    int t,n; scanf("%d",&t);
    while(t--){
        scanf("%d",&n);
        for(int i=1;i<=n;i++){
            scanf("%d",d+i);
            d[i] += d[i-1]; // 前缀和
            dp[i][i] = p[i][i] = q[i][i] = d[i]-d[i-1];
        }
        for(int len=2;len<=n;len++)
            for(int i=1,j=i+len-1; j<=n; i++,j++){
                dp[i][j] = d[j]-d[i-1] - min(0, min(p[i][j-1], q[i+1][j]));
                p[i][j] = min(p[i][j-1], dp[i][j]);
                q[i][j] = min(q[i+1][j], dp[i][j]);
            }
        printf("%d\n",dp[1][n]);
    }
    return 0;
}
```

---

## 个人心得摘录
> "维护前缀后缀最小值数组时，发现必须倒序枚举区间起点，否则会覆盖未使用的数据" —— qwerta  
> "将博弈问题转换为差值最大化问题，瞬间简化了状态转移的逻辑" —— Kelin  
> "滚动数组优化的关键在于发现状态转移只依赖相邻层的数据" —— iwprc

---

通过系统分析各题解的核心思路与优化技巧，本问题的最佳解法是通过维护前缀/后缀最小值数组实现O(n²)时间复杂度的区间DP。该解法兼具效率与可读性，是博弈类区间DP问题的经典解决方案。

---
处理用时：98.58秒
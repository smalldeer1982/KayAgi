# 题目信息

# 猫狗大战

## 题目描述

新一年度的猫狗大战通过 SC（星际争霸）这款经典的游戏来较量，野猫和飞狗这对冤家为此已经准备好久了，为了使战争更有难度和戏剧性，双方约定只能选择 Terran（人族）并且只能造机枪兵。

比赛开始了，很快，野猫已经攒足几队机枪兵，试探性的发动进攻；然而，飞狗的机枪兵个数也已经不少了。野猫和飞狗的兵在飞狗的家门口相遇了，于是，便有一场腥风血雨和阵阵惨叫声。由于是在飞狗的家门口，飞狗的兵补给会很快，野猫看敌不过，决定撤退。这时飞狗的兵力也不足够多，所以没追出来。

由于不允许造医生，机枪兵没办法补血。受伤的兵只好忍了。

现在，野猫又攒足了足够的兵力，决定发起第二次进攻。为了使这次进攻给狗狗造成更大的打击，野猫决定把现有的兵分成两部分，从两路进攻。由于有些兵在第一次战斗中受伤了，为了使两部分的兵实力平均些，分的规则是这样的：

1. 两部分兵的个数最多只能差一个；
2. 每部分兵的血值总和必须要尽可能接近。

现在请你编写一个程序，给定野猫现在有的兵的个数以及每个兵的血格值，求出野猫按上述规则分成两部分后每部分兵的血值总和。

## 说明/提示

TO 狗狗：这道题的数据范围我已经尽量按星际的游戏规则来了，如果你再固执于由于机枪兵的攻击力一定使不能达到某些血格值或者游戏中一定要造农民不能使机枪兵的人数达到 $200$ 的话，我只能决定将那场猫狗大战的录像公开于世人了！！！


## 样例 #1

### 输入

```
3
35
20
32
```

### 输出

```
35 52```

# AI分析结果



## 算法分类
**0-1背包**

## 题解思路与核心难点
### 核心思路
本题本质是一个带人数约束的二维 0-1 背包问题。需要同时满足两个条件：  
1. **人数平衡**：两部分人数差 ≤1  
2. **血量平衡**：两部分血量总和尽可能接近  

### 动态规划设计
**状态定义**：  
`dp[i][j]` 表示选 `i` 个兵，总血量为 `j` 是否可行  

**状态转移**：  
对每个士兵的血量 `a[k]`，逆向遍历更新：  
`dp[i][j] |= dp[i-1][j-a[k]]`  

**优化技巧**：  
- 使用 **滚动数组** 压缩空间  
- **bitset 加速**：利用位运算快速处理状态转移  

### 解决难点
1. **双约束处理**：需同时记录人数和血量，传统一维背包无法满足  
2. **奇偶人数处理**：当 n 为奇数时，需同时检查 `n/2` 和 `n/2+1` 的情况  
3. **最优解提取**：遍历所有可能血量，计算与总血量中值的绝对差  

---

## 题解评分 (≥4星)
### vegetabird (5星)
- **亮点**：经典二维背包实现，清晰展示状态转移  
- **代码**：初始化 `f[0][0]=1`，逆向更新避免重复计数  
```cpp
for(j=5000;j>=a[i];j--)
    for(k=100;k>=1;k--)
        f[j][k] = max(f[j][k], f[j-a[i]][k-1]);
```

### i207M (5星)
- **亮点**：bitset 优化空间，代码简洁高效  
- **关键代码**：  
```cpp
for(ri j = i; j >=1; --j)
    f[j] |= (f[j-1] << w[i]);
```

### danefishhh (4星)
- **亮点**：正确处理奇偶人数问题，避免常见错误  
- **关键逻辑**：  
```cpp
if(f[n >> 1][i] || f[(n >> 1)+1][i])
    printf("%d %d", i, sum - i);
```

---

## 最优思路提炼
1. **二维背包框架**：将人数作为第二维度，构建二维可行性背包  
2. **逆向遍历更新**：确保每个物品只被选取一次  
3. **最优解判定**：遍历所有可能的 `j`，找最接近 `sum/2` 的值  

---

## 类似题目推荐
1. **P1060 开心的金明**（0-1背包基础）  
2. **P1156 垃圾陷阱**（带约束的二维背包）  
3. **P2347 砝码称重**（多重背包变种）  

---

## 可视化设计（像素风格DP动画）
### 动画要素
1. **8位像素网格**：  
   - X轴表示血量（0~8000），Y轴表示人数（0~100）  
   - 每个格子用 16x16 像素方块，激活状态为亮绿色，未激活为深灰色  

2. **物品处理动画**：  
   - 当前处理的士兵显示为红色像素块，从顶部下落至背包区域  
   - 更新状态时，对应格子短暂闪烁黄色边框  

3. **音效设计**：  
   - **转移成功**：8-bit "beep" 短音  
   - **找到最优解**：经典 FC 过关音效  

4. **自动演示模式**：  
   - 按固定速度逐步处理每个士兵，显示状态矩阵更新过程  
   - 最终最优路径用连续闪烁的蓝色路径标记  

```javascript
// 伪代码：Canvas 绘制核心逻辑
function drawDPGrid() {
    for(let i=0; i<=maxPersons; i++) {
        for(let j=0; j<=maxHP; j+=50) { // 抽样绘制
            ctx.fillStyle = dp[i][j] ? '#00FF00' : '#333333';
            ctx.fillRect(j/10, i*20, 15, 15);
        }
    }
}
```

---

## 核心代码实现
### 二维背包标准实现
```cpp
#include<bits/stdc++.h>
using namespace std;
bool dp[105][8005]; // dp[i][j] = 选i人总血j是否可行

int main() {
    int n, sum = 0;
    cin >> n;
    dp[0][0] = true;
    
    for(int k=1; k<=n; k++) {
        int a; cin >> a;
        sum += a;
        for(int i=min(k, n/2+1); i>=1; i--) // 人数约束
            for(int j=sum; j>=a; j--)
                dp[i][j] |= dp[i-1][j-a];
    }

    int best = sum;
    for(int j=0; j<=sum; j++)
        if(dp[n/2][j] || (n%2 && dp[n/2+1][j]))
            best = min(best, abs(2*j - sum));
    
    cout << (sum - best)/2 << " " << (sum + best)/2;
}
```

---
处理用时：92.63秒
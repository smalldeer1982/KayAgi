# 题目信息

# 塔

## 题目描述

小明很喜欢摆积木，现在他正在玩的积木是由 $N$ 个木块组成的，他想用这些木块搭出两座高度相同的塔，一座塔的高度是搭建它的所有木块的高度和，并且一座塔至少要用一个木块。每个木块只能用一次，也可以不用。目前已知每块木块的高度，小明想知道在最终两个塔的高度相同的情况下，他所能搭的塔的最大高度是多少，你能帮助他吗？

## 说明/提示

对于 $100\%$ 的数据，$N \le 50$ ，每块木块的高度 $h$ 满足 $1 \le h \le 500000$，所有木块的高度总和 $\le 500000$。

## 样例 #1

### 输入

```
3

2 3 5```

### 输出

```
5```

# AI分析结果



### 算法分类
**线性DP**

---

### 题解思路与核心难点
#### **核心思路**
题目要求用N个木块搭建两座高度相同的塔，最大化塔的高度。本质是**分组决策问题**，每个木块有三种选择：不选、放左塔、放右塔。动态规划通过维护两塔高度差作为状态，避免直接记录两个塔高度的维度爆炸。

#### **关键状态设计**
- **FLYing解法**：定义 `f[i][j]` 为前i个积木中，第一堆与第二堆的差值为j时，左堆的最大高度。通过差值+偏移量处理负数，状态转移仅需处理三种情况。
- **我要上天解法**：定义 `dp[i][j]` 为前i个积木中，两塔高度差为j时较高塔的高度。需处理四种转移情况，包括放矮塔导致高低交换的情况。

#### **解决难点**
1. **差值处理**：通过偏移量（如+500000）将差值映射到正数范围。
2. **滚动数组优化**：仅保留前一状态的空间，大幅降低内存消耗。
3. **剪枝与可行性判断**：DFS解法通过前缀和剪枝减少搜索空间，但DP更高效。

---

### 题解评分（≥4星）
1. **FLYing（5星）**  
   - 状态设计简洁，滚动数组优化空间至O(1)。  
   - 代码清晰，转移方程仅需3种情况。  
   - 核心逻辑高度聚焦差值，无冗余判断。

2. **我要上天（4星）**  
   - 状态定义直观（较高塔高度），覆盖所有转移情况。  
   - 包含详细条件判断，适合教学理解。  
   - 未使用滚动数组，空间复杂度较高。

3. **K2sen（4星）**  
   - DFS+记忆化剪枝，展示非DP思路。  
   - 通过排序优化搜索顺序，实测可AC。  
   - 适合小数据量或教学对比。

---

### 最优思路提炼
1. **差值动态规划**：以两塔高度差为状态，避免维护双高度。
2. **滚动数组**：交替使用两个一维数组，空间复杂度从O(N·SUM)降至O(SUM)。
3. **偏移量技巧**：将差值范围[-SUM, SUM]映射到[0, 2·SUM]，解决负数索引问题。

**关键转移方程（FLYing解法）**：
```cpp
f[i%2][j] = max(
    f[(i-1)%2][j], // 不选当前积木
    f[(i-1)%2][j - a[i]] + a[i], // 放左塔
    f[(i-1)%2][j + a[i]] // 放右塔
);
```

---

### 同类型题与算法套路
- **类似题目**：分割等和子集、最小差值多米诺骨牌翻转。
- **通用套路**：  
  - 差值DP：当问题涉及两组差值时，以差值为状态。  
  - 滚动数组：处理线性DP时优化空间。

---

### 推荐练习题
1. **P2347 砝码称重**（差值DP基础）  
2. **P1282 多米诺骨牌**（最小化差值翻转）  
3. **P4161 [SCOI2005]最大子矩阵**（二维状态扩展）

---

### 个人心得摘录
- **FLYing**：  
  > “将差值加上500000映射到正数范围，避免负数下标，是本题核心技巧。”  
- **K2sen**：  
  > “DFS剪枝的关键在于前缀和的最优性判断，排序后优先选大积木可快速逼近最优解。”

---

### 可视化与算法演示
#### **动态规划矩阵更新动画**
- **Canvas网格**：行表示处理到第i个积木，列表示差值（偏移后），格子颜色深浅表示左堆高度。
- **高亮操作**：  
  - 红色：不选积木，继承上一状态。  
  - 绿色：放左塔，差值增加。  
  - 蓝色：放右塔，差值减少。
- **步进控制**：可调节速度观察状态转移细节。

#### **复古像素风格设计**
- **8位音效**：  
  - 转移时播放“哔”声，成功更新最大值时播放“叮”声。  
  - 背景音乐：循环8位芯片风格旋律。
- **像素方块**：每个状态用16x16像素块表示，颜色区分高度值。

```javascript
// 示例：Canvas绘制DP状态网格（伪代码）
const canvas = document.getElementById('dp-canvas');
const ctx = canvas.getContext('2d');
const colors = ['#000', '#0F0', '#F00', '#00F']; // 黑、绿、红、蓝

function drawGrid(dpState) {
  for (let j = 0; j < dpState.length; j++) {
    const colorIdx = Math.min(3, Math.floor(dpState[j] / 100000));
    ctx.fillStyle = colors[colorIdx];
    ctx.fillRect(j * 10, currentRow * 10, 10, 10);
  }
}
```

---

### 核心代码实现（FLYing解法）
```cpp
#include<cstdio>
#include<cstring>
#define maxn 1000039
using namespace std;
int f[2][maxn], N, a[51], ans;
int max(int a, int b, int c) { return max(a, max(b, c)); }

int main() {
    memset(f, -0x3f, sizeof(f));
    scanf("%d", &N);
    f[0][500000] = 0; // 初始状态：差值为0（偏移后）
    for(int i = 1; i <= N; i++) scanf("%d", &a[i]);
    
    for(int i = 1; i <= N; i++) {
        for(int j = 0; j <= 1000000; j++) {
            int curr = i % 2, prev = curr ^ 1;
            f[curr][j] = f[prev][j]; // 不选
            if(j >= a[i]) f[curr][j] = max(f[curr][j], f[prev][j - a[i]] + a[i]); // 放左
            if(j + a[i] <= 1000000) f[curr][j] = max(f[curr][j], f[prev][j + a[i]]); // 放右
            if(j == 500000) ans = max(ans, f[curr][j]); // 更新答案
        }
    }
    printf("%d", ans ? ans : -1);
    return 0;
}
```

---
处理用时：125.92秒
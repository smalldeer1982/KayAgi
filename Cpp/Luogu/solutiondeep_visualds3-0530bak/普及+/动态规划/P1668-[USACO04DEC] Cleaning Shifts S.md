# 题目信息

# [USACO04DEC] Cleaning Shifts S

## 题目描述

一天有 $T(1\le T\le 10^6)$ 个时段。约翰正打算安排他的 $N(1\le N\le 2.5\times 10^4)$ 只奶牛来值班，打扫打扫牛棚卫生。每只奶牛都有自己的空闲时间段 $ [S_i,E_i](1\le S_i\le E_i\le T)$，只能把空闲的奶牛安排出来值班。而且，每个时间段必需有奶牛在值班。

那么，最少需要动用多少奶牛参与值班呢？如果没有办法安排出合理的方案，就输出 $-1$。

## 说明/提示

$1\le T\le 10^6$，$N\le 2.5\times 10^4$，$1\le S_i\le E_i\le T$。

$\text{Update On 2023/08/08}$：添加了一组hack数据，详情见[这里](https://www.luogu.com.cn/discuss/613052)。叉掉了时间复杂度为 $\mathcal O(nt)$ 的错解。

## 样例 #1

### 输入

```
3 10
1 7
3 6
6 10```

### 输出

```
2```

# AI分析结果



# 算法分类
无算法分类  

---

# 题解思路与算法要点  

**核心思路**：  
题目本质是区间覆盖问题，需选择最小区间数覆盖[1,T]。各解法围绕贪心、动态规划、最短路展开：  

1. **贪心算法**（最优解）  
   - 按左端点排序区间，每次选择能覆盖当前最左未覆盖点且右端点最大的区间  
   - 时间复杂度：O(N log N)  
   - 解决难点：通过局部最优（最大右延展）保证全局最优  

2. **动态规划+线段树优化**  
   - 定义dp[i]为覆盖[1,i]的最小奶牛数  
   - 状态转移：dp[E_i] = min(dp[j] for j ∈ [S_i-1, E_i-1]) +1  
   - 线段树维护区间最小值，优化查询效率至O(log T)  
   - 时间复杂度：O(N log T)  

3. **最短路建模**  
   - 将区间[S_i,E_i]转化为边：S_i-1 → E_i，权值1  
   - 每个时间点i → i-1连权值0的边（允许向左回溯）  
   - 01BFS或Dijkstra求0到T的最短路径  
   - 离散化后时间复杂度：O(N log N)  

---

# 题解评分（≥4星）  

1. **Greenzhe（5星）**  
   - 思路清晰，贪心策略正确性证明充分  
   - 代码简洁高效（O(N log N)），双指针优化  
   - 关键亮点：严谨的数学证明与直观的双指针实现  

2. **Southern_Dynasty（4星）**  
   - 最短路建模新颖，01BFS与离散化处理巧妙  
   - 时间复杂度优秀，适合大规模数据  
   - 关键亮点：将覆盖问题转化为经典图论模型  

3. **船酱魔王（4星）**  
   - 线段树优化DP思路清晰，代码结构规范  
   - 状态转移方程设计合理，注释详细  
   - 关键亮点：线段树维护区间最小值的实践技巧  

---

# 最优思路提炼  

**贪心策略关键步骤**：  
1. 按左端点排序所有区间  
2. 初始化当前覆盖终点`st=1`，指针`i`遍历区间  
3. 每次在左端点≤`st`的区间中选右端点最大的，更新`st`至该右端点+1  
4. 若中途无法覆盖或最终`st<T`，返回-1  

**代码片段**：  
```cpp
sort(range+1, range+n+1);
int st=1, ans=0;
for(int i=1, j=1; i<=n; ){
    int max_r = 0;
    while(j <=n && range[j].l <= st) {
        max_r = max(max_r, range[j].r);
        j++;
    }
    if(max_r < st) break; // 无法覆盖
    ans++;
    st = max_r + 1;
    i = j;
}
if(st > ed) cout << ans;
else cout << -1;
```

---

# 同类型题与算法套路  

**相似问题**：  
- 最小点覆盖区间（HDU 1050）  
- 时间安排中的最大重叠（LeetCode 435）  
- 带权区间调度（洛谷P1280）  

**通用解法**：  
- 贪心按端点排序 + 双指针扫描  
- DP预处理 + 数据结构优化查询  
- 图论建模（最短路/差分约束）  

---

# 推荐练习题  
1. **P4644 [USACO05DEC] Cleaning Shifts**（带权区间覆盖）  
2. **P1280 尼克的任务**（时间轴DP）  
3. **CF1029C**（区间交叠与极值问题）  

---

# 可视化与算法演示  

**动态规划可视化设计**：  
1. **动画方案**：  
   - 时间轴横向展开，动态更新`dp`数组  
   - 线段树节点高亮显示当前查询区间`[S_i-1, E_i-1]`  
   - 更新`dp[E_i]`时显示线段树单点修改过程  

2. **复古像素风格**：  
   - 8-bit色彩：深蓝背景，亮绿网格线，红色高亮当前操作  
   - 时间轴以像素块表示，覆盖区间用不同颜色填充  
   - 音效：选择区间时播放“哔”声，更新`dp`时短促“咔嗒”  

3. **交互控制**：  
   - 步进按钮单步执行贪心选择或DP更新  
   - 速度滑块调节动画速度（0.5x~5x）  
   - 模式切换：贪心/DP/最短路对比演示  

**核心代码示例（Canvas动画）**：  
```javascript
// 绘制时间轴与区间覆盖
ctx.fillStyle = "#00FF00"; // 像素绿
for (const cow of cows) {
    ctx.fillRect(cow.S * scaleX, 0, (cow.E - cow.S) * scaleX, 20);
}

// 贪心选择高亮
ctx.strokeStyle = "#FF0000";
ctx.strokeRect(selectedCow.S * scaleX, 0, (selectedCow.E - selectedCow.S) * scaleX, 20);
```

---

# 个人心得摘录  

**调试经验**：  
- 贪心需注意排序后的区间可能完全覆盖，需及时终止循环（如样例中提前到达`T`）  
- DP初始化`dp[0]=0`而非`dp[1]`，避免漏掉起点覆盖  

**思维突破**：  
- 最短路建模将区间端点转化为节点，权值1表示选择一头牛，是“空间换时间”的典型技巧  

---

**可视化演示地址**：[在线尝试](https://algorithm-visualizer.org/greedy/interval-covering)（模拟贪心策略）

---
处理用时：113.90秒
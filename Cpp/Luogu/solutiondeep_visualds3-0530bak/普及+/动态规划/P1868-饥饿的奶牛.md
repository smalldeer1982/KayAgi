# 题目信息

# 饥饿的奶牛

## 题目描述

有一条奶牛冲出了围栏，来到了一处圣地（对于奶牛来说），上面用牛语写着一段文字。

现用汉语翻译为：

有 $N$ 个区间，每个区间 $x,y$ 表示提供的 $x\sim y$ 共 $y-x+1$ 堆优质牧草。你可以选择任意区间但不能有重复的部分。

对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。

## 说明/提示

$1 \leq n \leq 1.5 \times 10^5$，$0 \leq x \leq y \leq 3 \times 10^6$。

## 样例 #1

### 输入

```
3
1 3
7 8
3 4```

### 输出

```
5```

# AI分析结果



## 算法分类选择
**线性DP**

---

## 题解思路与算法要点

### 核心思路
题目要求选择不相交区间使得总长度最大。所有题解均采用动态规划思路，主要分为两类实现方式：

1. **右端点排序+二分查找**  
   按右端点排序区间，状态定义为前i个区间的最大长度。通过二分查找找到最后一个不与当前区间重叠的区间，实现O(n log n)的时间复杂度。

2. **按位置遍历+直接更新**  
   维护每个右端点位置的最大值数组。遍历每个位置i，若i是某区间的右端点，则更新状态：`f[i] = max(f[i-1], f[x-1] + length)`。时间复杂度O(max_y + n)，空间复杂度O(max_y)。

### 解决难点
- **状态定义**：大多数题解选择`f[i]`表示前i个区间的最大长度或位置i处的最大长度。
- **转移优化**：通过排序+二分或预处理区间端点，将O(n²)优化为线性或O(n log n)。
- **数据结构**：部分题解使用线段树/树状数组维护最大值，但实现复杂度较高。

---

## 题解评分（≥4星）

### 1. zhy137036（5星）
- **亮点**：直接按位置遍历，代码简洁高效。预处理每个右端点的区间列表，实现O(n + max_y)时间。
- **代码核心**：
  ```cpp
  vector<int> beg[3000010]; // 存储每个右端点对应的左端点
  for(int i=1; i<=mx; i++){
      f[i] = f[i-1];
      for(int x : beg[i]) // 遍历所有以i为右端点的区间
          f[i] = max(f[i], f[x-1] + (i - x + 1));
  }
  ```

### 2. 御坂10027号（4星）
- **亮点**：排序后二分查找前驱区间，逻辑清晰。
- **关键代码**：
  ```cpp
  sort(a+1, a+n+1, cmp); // 按右端点排序
  for(int i=1; i<=n; i++){
      int j = lower_bound(...); // 二分查找最后一个右端点 < a[i].x
      dp[i] = max(dp[i-1], dp[j] + a[i].len);
  }
  ```

### 3. vegetabird（4星）
- **亮点**：权值线段树维护最大值，适合动态维护区间查询。
- **核心片段**：
  ```cpp
  for(int i=1; i<=n; i++){
      int max_pre = query(1, a[i].x-1); // 线段树查询
      dp[i] = max_pre + a[i].len;
      update(a[i].y, dp[i]); // 更新线段树
  }
  ```

---

## 最优思路提炼
1. **按位置遍历**  
   预处理所有区间到其右端点的映射，直接遍历每个位置，利用`f[i] = max(f[i-1], f[x-1] + len)`更新状态。时间复杂度线性，空间换时间。
2. **关键技巧**  
   - 预处理区间到右端点的列表。
   - 通过`f[i]`同时记录历史最大值，避免重复计算。

---

## 同类型题与算法套路
- **相似题目**：  
  1. [P1803 凌乱的yyy](https://www.luogu.com.cn/problem/P1803)（贪心选择不相交区间）  
  2. [P1944 最长括号匹配](https://www.luogu.com.cn/problem/P1944)（线性DP处理区间匹配）  
  3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)（线性DP双向遍历）

---

## 推荐题目
1. P1803（贪心区间选择）  
2. P1944（线性DP处理特殊区间）  
3. P1091（双向线性DP）

---

## 个人心得摘录
- **zhy137036**：通过预处理右端点的区间列表，避免了排序和二分，代码更简洁。  
- **御坂10027号**：调试时发现排序后的最后一个右端点不一定是全局最大值，需单独处理。  
- **MichaelYoung**：倒推法灵感来自“尼克的任务”，但实现时发现逆序处理更复杂。

---

## 可视化与算法演示
### 动态规划状态转移动画
1. **像素风格展示**  
   - 用Canvas绘制一维数组`f[]`，每个格子表示位置i的`f[i]`值。  
   - 高亮当前处理的区间右端点，显示其对应的左端点和长度。  
   - 更新时播放8-bit音效，绿色表示继承`f[i-1]`，黄色表示新增区间。

2. **交互设计**  
   - **自动模式**：按右端点顺序自动播放转移过程。  
   - **手动模式**：点击任意位置查看`f[i]`的更新来源。  
   - **对比模式**：并排显示排序法和位置遍历法的DP数组更新差异。

### 代码片段（JS伪代码）
```javascript
// Canvas绘制DP数组
function drawDPGrid() {
    ctx.clearRect(0, 0, width, height);
    for (let i = 0; i <= maxY; i++) {
        ctx.fillStyle = (i === currentPos) ? "#FFD700" : "#00FF00";
        ctx.fillRect(i * cellSize, 0, cellSize, cellSize);
        ctx.fillText(f[i], i * cellSize + 5, 15);
    }
}

// 更新动画
function animateStep() {
    if (currentPos > maxY) return;
    updateF(currentPos); // 实际更新逻辑
    drawDPGrid();
    currentPos++;
    requestAnimationFrame(animateStep);
}
```

---

## 核心代码实现
### zhy137036的线性DP实现
```cpp
#include<cstdio>
#include<vector>
using namespace std;
vector<int> beg[3000010];
int n, mx, f[3000010];

int main() {
    scanf("%d", &n);
    for(int i=1; i<=n; i++) {
        int x, y;
        scanf("%d%d", &x, &y);
        beg[y].push_back(x-1); // 存储x-1方便计算f[x-1]
        mx = max(mx, y);
    }
    for(int i=1; i<=mx; i++) {
        f[i] = f[i-1]; // 继承前一个位置的值
        for(int x : beg[i]) // 处理所有以i为右端点的区间
            f[i] = max(f[i], f[x] + (i - (x+1) + 1));
    }
    printf("%d", f[mx]);
}
```

---

**总结**：本题核心为线性DP，通过预处理区间端点实现高效转移。推荐优先掌握位置遍历法，其代码简洁且时间复杂度最优。

---
处理用时：127.23秒
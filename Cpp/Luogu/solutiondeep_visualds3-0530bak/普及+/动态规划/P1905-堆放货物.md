# 题目信息

# 堆放货物

## 题目背景

Caesar 看了你建设的城市后非常满意，提拔你担任 Genoa 的地方总督，并加薪 $50$ 第纳尔。最近他又写信给你说：Genoa 不能只靠 Rome 的财政扶持，你必须开展城市贸易增加财政收入。

在花费 $500$ 第纳尔开通了至 Capua 的商路后，来自 Capua 的船只源源不断地驶来，Genoa 急需建立一个仓库来临时存放送往 Capua 的货物。

## 题目描述

Genoa 的货物有三种：陶器，家具，大理石，共有 $n$ 个。他们的重量分别为 $1$，$2$，$3$ 个单位。现在，有 $p$ 艘 Capua 的船只在等待着仓库的货物，你应该将仓库里的货物分成 $p$ 堆，堆放规则如下：

- 同一堆中，重量从下至上应该是递减的（显然不能把大理石堆放在陶器或家具上）。
- 任意两堆重量之差不能超过 $3$ 个单位，否则会因分配过于不均发生船只间的冲突。

请你完成这个任务，给出一种可行的方案。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2 \leq n \leq 10^3$，$1 \leq p \leq \lfloor\frac n 2 \rfloor$，$1 \leq a_i \leq 3$。

#### 说明

感谢 @cn：苏卿念 提供spj。

spj说明：

```
score:ouo：你的输出里面有不是'1','2','3',' ','\n','\r'的东西，具体以ASCII的第X号字符
score:pvp：你在第x组的时候装下了超过规定数量的'3'|'2'|'1'。
score:TAT：蛇皮judge没能读入到想要读入的东东(类似于你直接提交了一个puts(" / 特别特别多的空格/"))
score:qaq：你把重量为w1的货物放到了w2上面(w1>w2)在第i组的第j个货物
score:ovo：你没有装足够的x
score:qwq：你第i组和第j组的差的绝对值>3了，(要打架了)，第i组的重量和为x，第j组的重量和为y。
score:pwp：答案正确，恭喜你嘤嘤嘤
```

## 样例 #1

### 输入

```
6
3
3 2 2 1 1 1
```

### 输出

```
3 1
2 1
2 1
```

# AI分析结果



**唯一算法分类**  
无算法分类

---

### **题解思路、算法要点与解决难点**  
**核心思路**：将货物从大到小排序后，采用贪心策略分配，确保每堆重量差≤3。  
**关键要点**：  
1. **排序保证堆内递减**：货物按3→2→1排序，每堆内部自然满足递减条件。  
2. **分配策略**：  
   - **蛇形填充**（霜月骑士）：按1→p→1的顺序循环填充，平衡各堆数量。  
   - **分层填充**（mot1ve）：每层依次填充各堆，余数部分继续分层。  
3. **重量差控制**：同一层货物重量相同，余数分配后最大差异不超过3。  

**解决难点**：  
- 如何在保证堆内递减的同时，控制堆间重量差。  
- 通过贪心策略的均匀分配，确保数学上最大差值≤3。  

---

### **题解评分 (≥4星)**  
1. **霜月骑士（4星）**  
   - **亮点**：蛇形填充简洁高效，代码清晰。  
   - **代码**：使用`vector`实现双向填充，时间复杂度O(n)。  
2. **mot1ve（4星）**  
   - **亮点**：分层填充直观易懂，逻辑严谨。  
   - **代码**：二维数组记录每层分配，输出时直接遍历。  
3. **Konnyaku_ljc（4星）**  
   - **亮点**：按列分配货物，逆序输出保证堆内递减。  

---

### **最优思路或技巧提炼**  
1. **排序与贪心**：  
   - 排序后分配是核心，确保堆内递减。  
   - 蛇形或分层填充保证堆数量均衡，重量差≤3。  
2. **数学归纳**：  
   - 最大差值仅可能出现在余数分配时，通过极端情况验证（如3+1与1+1）。  

---

### **同类型题或类似算法套路**  
- **分配问题**：如LeetCode 659（分割数组为连续子序列），需分组满足特定条件。  
- **贪心策略**：如洛谷P1094（纪念品分组），要求每组重量和≤阈值。  

---

### **推荐相似题目**  
1. **P1094 纪念品分组**（贪心+双指针）  
2. **P4447 [AHOI2018初中组]分组**（贪心+优先队列）  
3. **LeetCode 767 重构字符串**（贪心+频率分配）  

---

### **个人心得摘录**  
- **霜月骑士**：“蛇形填充保证数量差≤1，重量差自然≤3。”  
- **mot1ve**：“同一层重量相同，余数层差异受排序限制，无需复杂计算。”  

---

### **可视化与算法演示**  
**动画设计**：  
1. **排序阶段**：货物按3→2→1排列，颜色区分重量（红=3，绿=2，蓝=1）。  
2. **分配阶段**：  
   - **蛇形填充**：箭头从左到右填充，折返时反向，动态显示堆高度。  
   - **分层填充**：每层横向填充，堆高逐步增加，颜色标记当前层。  
3. **差值提示**：堆顶显示总重量，若两堆差>3，高亮红色警示。  

**复古像素风格**：  
- **颜色方案**：8位色调色板（红/绿/蓝代表重量，灰底网格）。  
- **音效**：  
  - 分配时播放“哔”声，成功时播放“叮”声。  
  - 错误差>3时播放“警告”音效。  
- **Canvas交互**：点击步进，自动播放速度可调，显示当前操作堆。  

---

### **代码片段（核心逻辑）**  
**霜月骑士的蛇形填充**：  
```cpp
sort(a+1, a+n+1, greater<int>());
int num = 1;
while (num <= n) {
    for (int i=1; i<=p && num<=n; i++, num++) // 正向填充
        v[i].push_back(a[num]);
    for (int i=p; i>=1 && num<=n; i--, num++) // 反向填充
        v[i].push_back(a[num]);
}
```

**mot1ve的分层填充**：  
```cpp
sort(a+1, a+n+1, cmp); // 从大到小排序
for (int i=1; i<=n; i++) {
    cnt++; // 当前堆编号
    if (cnt > p) { cnt=1; tot++; } // 进入下一层
    b[cnt][tot] = a[i]; // 记录到对应层
}
```

---

**总结**：本题通过排序+贪心策略巧妙解决，核心在于均匀分配策略的设计。蛇形填充与分层填充均为高效解法，时间复杂度O(n log n)，适用于大规模数据。

---
处理用时：91.24秒
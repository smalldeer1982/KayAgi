# 题目信息

# [SCOI2008] 着色方案

## 题目描述

有 $n$ 个木块排成一行，从左到右依次编号为 $1$ 至 $n$。

你有 $k$ 种颜色的油漆，第 $i$ 种颜色的油漆足够涂 $c_i$ 个木块。

所有油漆刚好足够涂满所有木块，即 $\sum_{i=1}^kc_i=n$。

由于相邻两个木块涂相同色显得很难看，所以你希望统计任意两个相邻木块颜色不同的着色方案。

由于答案可能很大，请输出对 $10^9+7$ 取模的结果。

## 说明/提示

- 对于 $50\%$ 的数据，$1 \leq k \leq 5$，$1 \leq c_i \leq 3$；
- 对于 $100\%$ 的数据，$1 \leq k \leq 15$，$1 \leq c_i \leq 5$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
10```

## 样例 #2

### 输入

```
5
2 2 2 2 2```

### 输出

```
39480```

## 样例 #3

### 输入

```
10
1 1 2 2 3 3 4 4 5 5
```

### 输出

```
85937576```

# AI分析结果



# [SCOI2008] 着色方案 题解分析

## 算法分类  
**线性DP**

---

## 题解思路与核心难点

### 核心算法思想  
题目要求相邻木块颜色不同，且油漆使用次数严格匹配。通过多维动态规划状态设计，记录剩余可用次数的颜色分布及上一次使用的颜色类型，避免相邻重复。

#### 关键状态设计  
- **Bartholomew/Log_x/mulberror题解**：使用六维状态 `f[a][b][c][d][e][last]`，其中 `a~e` 表示剩余使用次数为1~5的颜色数量，`last` 表示上一次使用的颜色剩余次数（用于排除相邻重复）。
- **Cyhlnj题解**：组合数学+分组插入，状态 `f[i][j]` 表示前 `i` 种颜色涂完后有 `j` 对相邻同色块的方案数，通过计算新颜色分组的插入方式转移。

#### 难点与解决方案  
1. **状态爆炸问题**  
   - 传统状态设计需记录所有颜色剩余次数，但题目中 `c_i ≤ 5`，将颜色按剩余次数分组，压缩为五维状态。
   - 例如，剩余次数为2的颜色可能有多个，但它们对状态转移的影响相同，无需区分具体颜色。

2. **相邻颜色限制**  
   - 在状态中加入 `last` 标记上一次使用的颜色类型（剩余次数），转移时扣除可能重复的情况。
   - 例如，若上一次使用剩余次数为2的颜色，则当前不能选择剩余次数为1的颜色（因为其由剩余次数为2的颜色用完一次后转换而来）。

---

## 最优题解评分与关键点

### 评分≥4星的题解  
1. **Bartholomew（4.5星）**  
   - **亮点**：六维状态设计直观，记忆化搜索实现简洁。  
   - **关键代码**：  
     ```cpp
     ll DFS(int a, int b, int c, int d, int e, int last) {
         if (所有颜色用完) return 1;
         if (已记忆) return dp值;
         ll res = 0;
         if (a) res += (a - (last==2)) * DFS(a-1, b, c, d, e, 1);
         if (b) res += (b - (last==3)) * DFS(a+1, b-1, c, d, e, 2);
         // 类似处理c, d, e...
         return dp[a][b][c][d][e][last] = res % MOD;
     }
     ```

2. **Cyhlnj（4星）**  
   - **亮点**：组合数学优化，时间复杂度更低（O(n^4)）。  
   - **核心公式**：  
     $$
     f_{i,j} = \sum \binom{c_{i+1}-1}{a-1} \cdot \binom{j}{b} \cdot \binom{sum[i]+1-j}{a-b}
     $$

3. **逃离地球（5星）**  
   - **亮点**：提供多种解法（容斥、FFT优化），全面覆盖知识点。  
   - **容斥思路**：  
     $$g_0 = \sum_{i=0}^n (-1)^i f_i$$
     通过背包卷积快速计算容斥项。

---

## 关键代码实现（Bartholomew版）

```cpp
ll f[16][16][16][16][16][6]; // 状态数组

ll dfs(int a, int b, int c, int d, int e, int last) {
    if (a + b + c + d + e == 0) return 1;
    if (f[a][b][c][d][e][last]) return f[a][b][c][d][e][last];
    ll res = 0;
    if (a) res += (a - (last == 2)) * dfs(a-1, b, c, d, e, 1);
    if (b) res += (b - (last == 3)) * dfs(a+1, b-1, c, d, e, 2);
    if (c) res += (c - (last == 4)) * dfs(a, b+1, c-1, d, e, 3);
    if (d) res += (d - (last == 5)) * dfs(a, b, c+1, d-1, e, 4);
    if (e) res += e * dfs(a, b, c, d+1, e-1, 5);
    return f[a][b][c][d][e][last] = res % MOD;
}
```

---

## 可视化设计（复古像素风格）

### 动画方案  
1. **状态网格**  
   - 在Canvas中绘制5×5网格，每个格子表示一个剩余次数分组（如红色块表示剩余1次的颜色数量）。  
   - 当前操作的格子高亮显示，例如选择剩余次数为2的颜色时，对应区域闪烁。

2. **音效与交互**  
   - **状态转移音效**：8-bit风格“滴”声，每次转移播放。  
   - **自动演示模式**：按步进速度自动展示状态更新，用户可暂停/调整速度。  
   - **错误提示**：相邻颜色重复时播放低沉音效并显示警告动画。

3. **像素化效果**  
   ```javascript
   // Canvas绘制示例
   function drawGrid(ctx, a, b, c, d, e) {
       ctx.fillStyle = "#FF0000"; // 红色表示剩余1次
       ctx.fillRect(0, 0, a*10, 10); // 简化绘制逻辑
       // 类似绘制其他剩余次数...
   }
   ```

---

## 同类型题目推荐  
1. **P1057 传球游戏**（线性DP）  
2. **P1433 吃奶酪**（状态压缩DP）  
3. **P1273 有线电视网**（树形DP）

---

## 核心优化总结  
- **多维状态压缩**：将颜色按剩余次数分组，避免枚举具体颜色。  
- **记忆化搜索**：减少重复计算，优化时间复杂度。  
- **组合数学优化**：通过分组插入和容斥原理降低复杂度。

---
处理用时：89.24秒
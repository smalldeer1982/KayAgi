# 题目信息

# [ZJOI2004] 午餐

## 题目描述

上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。

THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。

现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。

假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。

现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。


## 说明/提示

所有输入数据均为不超过200的正整数。


## 样例 #1

### 输入

```
5

2 2

7 7

1 3

6 4

8 5

```

### 输出

```
17```

# AI分析结果



# [ZJOI2004] 午餐 题解分析

## 算法分类
**线性DP**

---

## 核心思路与难点突破

### 1. 贪心策略
**关键结论**：将吃饭时间长的优先安排在队伍前端。  
**证明思路**：  
对于两人i和j，若i的吃饭时间更长，将其排在前面能减少总等待时间的最大值。通过交换法可证，当i在前时总完成时间更优。

### 2. DP状态设计
**状态定义**：  
`f[i][j]` 表示前i个人中，1号窗口打饭总时间为j时的最小全体完成时间。  
**巧妙优化**：  
- 利用前缀和`sum[i]`维护前i人总打饭时间，通过`sum[i]-j`快速获取2号窗口时间  
- 状态转移方程：  
  ```python
  # 放入1号窗口
  if j >= a[i]:
      f[i][j] = min(f[i][j], max(f[i-1][j-a[i]], j + b[i]))
  # 放入2号窗口
  f[i][j] = min(f[i][j], max(f[i-1][j], sum[i]-j + b[i]))
  ```

### 3. 动态规划实现
**关键步骤**：  
1. 按吃饭时间降序排序  
2. 初始化`f[0][0] = 0`  
3. 倒序枚举j，避免状态覆盖  
4. 最终遍历所有可能的j取最小值

---

## 题解评分（≥4星）

### 1. M_sea (5★)
**亮点**：  
- 清晰的状态转移图示  
- 完整的前缀和推导  
- 代码简洁且注释明确  
**核心代码**：  
```cpp
for(int i=1; i<=n; i++) {
    for(int j=0; j<=sum[i]; j++) {
        if(j>=s[i].a) 
            f[i][j] = min(f[i][j], max(f[i-1][j-s[i].a], j+s[i].b));
        f[i][j] = min(f[i][j], max(f[i-1][j], sum[i]-j+s[i].b));
    }
}
```

### 2. 灵乌路空 (5★)
**亮点**：  
- 严格数学推导贪心正确性  
- 完整DP转移路径分析  
- 代码包含详细状态转移注释  
**核心逻辑**：  
```cpp
for(int i=1; i<=n; ++i) {
    for(int j=sum[i]; j>=0; --j) {
        if(j >= a[i]) 
            f[i][j] = min(f[i][j], max(f[i-1][j-a[i]], j + b[i]));
        f[i][j] = min(f[i][j], max(f[i-1][j], sum[i]-j + b[i]));
    }
}
```

### 3. TH讠NK (4★)
**亮点**：  
- 详细对比贪心前后差异  
- 提供三维到二维的压缩思路  
- 包含多组测试数据验证  
**关键段落**：  
> "当两个人的总时间固定时，吃饭时间长的优先安排能减少max值的膨胀，这是贪心的核心"

---

## 可视化设计

### 动态规划矩阵动画
**实现要点**：  
1. **Canvas网格绘制**：  
   - 每格表示`f[i][j]`的值  
   - 深绿色表示当前更新的格子，浅灰色表示未计算  
2. **颜色标记**：  
   - 红色边框：当前处理的i值  
   - 黄色箭头：状态转移来源（上一行的j或j-a[i]）  
3. **音效触发**：  
   - "滴"声：正常状态转移  
   - "叮"声：发现更优解  
4. **复古像素风格**：  
   - 8-bit字体显示数值  
   - 背景音乐采用《超级玛丽》地下关BGM循环  

### 交互功能
- **速度调节滑块**：控制动画速度（1x~10x）  
- **单步执行按钮**：观察每一步的转移细节  
- **对比模式**：并行显示两种DP实现（标准二维数组 vs 滚动数组优化）  

---

## 同类型题目推荐
1. **P1091 合唱队形**：线性DP+双向LIS  
2. **P1064 金明的预算方案**：依赖背包+状态压缩  
3. **P2014 选课**：树形DP+分组背包  

---

## 关键代码片段
```cpp
// 核心DP转移逻辑
for (int i = 1; i <= n; ++i) {
    for (int j = sum[i]; j >= 0; --j) {
        if (j >= a[i]) {
            dp[i][j] = min(dp[i][j], max(dp[i-1][j - a[i]], j + b[i]));
        }
        dp[i][j] = min(dp[i][j], max(dp[i-1][j], (sum[i] - j) + b[i]));
    }
}
```

---

## 个人调试心得
> "初期错误地将sum[i]计算为前缀和的最大值，导致状态转移越界。通过添加`j <= sum[i]`的条件判断后问题解决。调试过程中发现，贪心排序的稳定性对最终结果影响极大，未排序时样例输出从17变为19"

---
处理用时：75.61秒
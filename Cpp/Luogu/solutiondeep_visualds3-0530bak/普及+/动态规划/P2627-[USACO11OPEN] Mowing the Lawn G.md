# 题目信息

# [USACO11OPEN] Mowing the Lawn G

## 题目描述

在一年前赢得了小镇的最佳草坪比赛后，Farmer John 变得很懒，再也没有修剪过草坪。现在，新一轮的最佳草坪比赛又开始了，Farmer John 希望能够再次夺冠。

然而，Farmer John 的草坪非常脏乱，因此，Farmer John 只能够让他的奶牛来完成这项工作。Farmer John 有 $N$（$1\le N\le 10^5$）只排成一排的奶牛，编号为 $1\ldots N$。每只奶牛的效率是不同的，奶牛 $i$ 的效率为 $E_i$（$0\le E_i\le 10^9$）。

靠近的奶牛们很熟悉，因此，如果 Farmer John安排超过 $K$ 只连续的奶牛，那么，这些奶牛就会罢工去开派对 :)。因此，现在 Farmer John 需要你的帮助，计算 FJ 可以得到的最大效率，并且该方案中没有连续的超过 $K$ 只奶牛。

## 样例 #1

### 输入

```
5 2
1
2
3
4
5
```

### 输出

```
12
```

# AI分析结果



# 线性DP

## 算法分析与结论
### 核心思路
题目要求选择奶牛时不能有连续超过K头被选中。关键思路是**将问题转化为动态规划，并通过单调队列优化状态转移**。所有题解的核心都在于维护一个滑动窗口内的极值，将时间复杂度从O(nk)优化到O(n)。

### 状态转移方程
**顺推法**：定义`dp[i][1]`表示选第i头的最大效率，转移方程：
```
dp[i][1] = max(dp[j][0] + sum[i] - sum[j]) + sum[i]
          = max(dp[j][0] - sum[j]) + sum[i]  (i-K ≤ j < i)
```
**逆推法**：定义`dp[i]`为不选第i头时的最小损失，转移方程：
```
dp[i] = min(dp[j]) + E[i]  (i-K-1 ≤ j < i)
```

### 解决难点
1. **滑动窗口极值维护**：通过单调队列维护窗口内`dp[j]-sum[j]`的最大值或`dp[j]`的最小值。
2. **前缀和优化**：将区间和转化为前缀和差分，简化计算。
3. **边界处理**：如逆推法中需要虚拟点`n+1`处理最后一段全选的情况。

### 可视化设计
- **DP矩阵动画**：展示`dp[i]`的更新过程，用不同颜色标记当前处理的i和队列中的j。
- **单调队列操作**：高亮队列头尾的弹出/插入动作，显示维护的极值。
- **像素风格**：用8位色块表示DP数组和队列，每次状态更新时播放复古音效。
- **交互控制**：允许单步执行观察状态转移，调节动画速度。

---

## 高星题解推荐 (≥4⭐)
1. **Koakuma (5⭐)**  
   亮点：详细讲解三种解法，尤其是逆推法的转化思路，代码清晰带注释，状态转移推导完整。

2. **Refined_heart (4.5⭐)**  
   亮点：双状态定义明确，代码中维护队列的过程注释详细，适合初学者理解单调队列优化。

3. **EarthGiao (4⭐)**  
   亮点：逆推思路转化巧妙，代码简洁，通过虚拟点处理边界问题，适合快速实现。

---

## 核心代码实现
```cpp
// 顺推法代码（Koakuma题解）
long long n, k, e[100010], sum[100010], dp[100010][2];
deque<int> q;

for(int i=1; i<=n; i++) {
    dp[i][0] = max(dp[i-1][0], dp[i-1][1]);
    // 维护单调队列
    while(!q.empty() && q.front() < i-k) q.pop_front();
    dp[i][1] = dp[q.front()][0] - sum[q.front()] + sum[i];
    // 插入新元素并保持单调性
    while(!q.empty() && dp[i][0]-sum[i] > dp[q.back()][0]-sum[q.back()]) 
        q.pop_back();
    q.push_back(i);
}
```

---

## 同类型题目推荐
1. **P1725 琪露诺** - 滑动窗口+单调队列优化DP
2. P2569 [SCOI2010]股票交易 - 复杂单调队列优化
3. P3195 [HNOI2008]玩具装箱 - 斜率优化DP

---

## 个人心得摘录
- **thmyl**：在维护队列时，先处理队头越界再计算当前值，否则会引入无效状态。
- **wick**：通过multiset/priority_queue实现，虽效率略低但代码更易调试。
- **YLWang**：线段树维护区间最大值，适合不熟悉单调队列的学习者。

---

## 可视化示例（伪代码）
```javascript
// Canvas绘制DP数组和队列
function drawDP() {
    ctx.fillStyle = '#8B0000'; // 复古红
    for(let i=0; i<=n; i++) {
        drawRect(i*30, 0, dp[i]); // 绘制dp[i]的值
        if(i === current) highlightRect(i*30, 0); // 高亮当前处理位置
    }
    // 绘制单调队列元素
    q.forEach((val, idx) => drawQueueElement(idx*30, 100, val));
}
// 音效触发
audio.play('pop'); // 队列弹出时
audio.play('insert'); // 插入新元素时
```

---
处理用时：69.68秒
# 题目信息

# [USACO10JAN] Cheese Towers S

## 题目描述

FJ 要建一个奶酪塔，高度最大为 $T\ (1 \le T \le 10^3)$ 。他有 $N\ (1 \le N \le 10^2)$ 种奶酪。第 $i$ 种奶酪的高度为 $H_i\ (5\le H_i \le T\text{ 且 }5 \mid H_i)$ ，价值为 $V_i\ (1 \le V_i \le 10^6)$ 。一块高度 $H_i\ge K\ (1 \le K \le T)$ 的奶酪被称为大奶酪，如果一个奶酪上方有大奶酪（如果有多块就只算一次），这个奶酪的高度 $H_i$ 就会变成原来的 $\frac{4}{5}$。FJ 想让他的奶酪塔价值和最大。请你求出这个最大值。

例如，考虑一种奶酪塔，其最大高度可以是 $53$，可以用三种类型的奶酪块建造。大块是大于或等于 $25$ 的块。下面是他堆叠的各种奶酪块的值和高度的图表：

|类型|价值|高度|
| :----------: | :----------: | :----------: |
|1|100|25|
|2|20|5|
|3|40|10|

FJ建造了以下奶酪塔：

|类型|价值|高度|
| :----------: | :----------: | :----------: |
|1|100|25|
|2|20|4|
|3|40|8|
|3|40|8|
|3|40|8|

总高度是 $25 + 4 + 8 + 8 + 8 = 53$，除塔顶奶酪外，其余高度均被压低。总价值是 $100 + 20 + 40 + 40 + 40 = 240$。

## 样例 #1

### 输入

```
3 53 25 
100 25 
20 5 
40 10 
```

### 输出

```
240 
```

# AI分析结果



# 算法分类
**完全背包**

---

## 题解思路与算法分析

### **核心思路**
1. **分治策略**：将问题拆分为两种互斥情况：
   - **无大奶酪**：直接套用完全背包模板。
   - **有大奶酪**：将最上方的大奶酪单独枚举，剩余部分视为压缩后的完全背包问题。
   
2. **贪心优化**：大奶酪必须放在塔顶，否则将其上移可提升压缩效果，从而可能获得更优解。

3. **动态规划设计**：
   - **完全背包预处理**：用 `f[j]` 表示总高度为 `j` 时的最大价值，处理时需将容量扩大至 `T*5/4`。
   - **枚举大奶酪**：对每个大奶酪 `i`，计算 `v[i] + f[(T - H_i) * 5/4]`，更新全局最优解。

### **解决难点**
- **高度压缩的数学转换**：压缩后的总高度为原高度的 `4/5`，反向推导时需将剩余空间放大为 `5/4` 倍。
- **背包容量扩展**：预处理阶段需将背包容量扩展至 `T*5/4`，以覆盖压缩后的所有可能情况。

### **关键状态转移**
- **完全背包部分**：
  ```cpp
  for (int j = h[i]; j <= T*5/4; j++)
    f[j] = max(f[j], f[j - h[i]] + v[i]);
  ```
- **大奶酪枚举**：
  ```cpp
  ans = max(ans, v[i] + f[(T - h[i]) * 5/4]);
  ```

---

## 高星题解推荐（≥4星）

1. **作者：reek（5星）**
   - **亮点**：代码简洁，思路清晰，直接点明两种情况的处理方式。
   - **核心代码**：
     ```cpp
     for (int i=1;i<=n;i++)
       for (int j=h[i];j<=T*5/4;j++)
         f[j] = max(f[j], f[j - h[i]] + v[i]);
     ans = max(ans, f[(T - h[i])*5/4] + v[i]);
     ```

2. **作者：Cxs3（4星）**
   - **亮点**：详细解释容量扩展的数学原理，代码可读性强。
   - **关键注释**：
     > "完全背包的循环需处理到 `T*5/4`，否则大奶酪枚举时可能越界。"

3. **作者：linyinuo2008（4星）**
   - **亮点**：引入复古像素动画演示思路，增强学习趣味性。
   - **心得摘录**：
     > "调试中发现背包容量未扩展导致63分，修正后AC，教训深刻。"

---

## 最优思路提炼

1. **贪心剪枝**：大奶酪仅需考虑塔顶位置。
2. **数学转换**：压缩高度通过反向放大处理，避免复杂分层状态。
3. **完全背包扩展**：预处理阶段扩大容量覆盖压缩场景。

---

## 类似题目推荐

1. **P1776 宝物筛选**（多重背包 + 二进制优化）
2. **P1853 投资的最大效益**（完全背包 + 周期性更新）
3. **P1941 飞扬的小鸟**（混合背包 + 状态压缩）

---

## 可视化设计

### **DP 矩阵动画**
- **8位像素风格**：用绿色方块表示 `f[j]` 更新，红色闪烁表示当前枚举的大奶酪。
- **Canvas 网格**：横向为背包容量 `0~T*5/4`，纵向为奶酪类型，每步更新时高亮对应格子。
- **音效**：`f[j]` 更新时播放“滴”声，找到更优解时播放“叮”声。

### **交互控制**
- **步进按钮**：单步执行背包填充或大奶酪枚举。
- **速度滑块**：调节动画速度，观察不同速度下的状态转移。

```javascript
// 伪代码：背包更新动画
function animateDP() {
  for (let i = 0; i < n; i++) {
    for (let j = h[i]; j <= T * 1.25; j++) {
      highlightCell(j); // 高亮当前处理格子
      updateCellColor(j, newValue); // 更新颜色反映数值变化
      playSound('beep'); // 播放音效
    }
  }
}
```

---

## 核心代码实现

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n, T, k, v[105], h[105], f[2005];

int main() {
    cin >> n >> T >> k;
    for (int i = 1; i <= n; i++)
        cin >> v[i] >> h[i];
    
    // 完全背包预处理
    for (int i = 1; i <= n; i++)
        for (int j = h[i]; j <= T * 5 / 4; j++)
            f[j] = max(f[j], f[j - h[i]] + v[i]);
    
    int ans = f[T]; // 无大奶酪情况
    
    // 枚举大奶酪
    for (int i = 1; i <= n; i++)
        if (h[i] >= k)
            ans = max(ans, v[i] + f[(T - h[i]) * 5 / 4]);
    
    cout << ans;
    return 0;
}
```

---
处理用时：85.00秒
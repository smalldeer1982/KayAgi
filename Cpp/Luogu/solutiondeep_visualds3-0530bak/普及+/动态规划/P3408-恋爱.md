# 题目信息

# 恋爱

## 题目描述

小 A 爱上了小 B！！！可是小 A 相对小 B 太弱，所以她当然不会同意小 A 的请求。小 A 苦苦追求，最终小 B 就提这样的条件：

- 小 B 有 $n$ 个下属（不包括小 B）组成了树状结构，小 B 在顶端，其他人都有一个直属上司。  
- 小 B 编号 $0$，其他人编号 $1 \sim n$。  
- 对于第 $i$ 人，如果这个人没有下属，那么小 A 可以给他 $A_i$ 元钱，则他会向他的直属上司写一封信，表示小 A 向小 B 求爱；  
- 如果他的直属下属有占比不小于 $\dfrac{A_i}{T}$ 的人写信表示小 A 向小 B 求爱，那么他也会向他的直属上司写一封信，表示小 A 向小 B 求爱。    
- 如果小 B 的直属下属有占比不小于 $\dfrac{C}{T}$ 的人写信表示小 A 向小 B 求爱，那么她会同意小 A 的请求。

请问小 A 至少需要给多少钱才会让小 B 同意小 A 的求爱。

## 说明/提示

对于 $20 \%$ 的数据，没有直属下属的人数 $\le 15$。  
对于 $40 \%$ 的数据，$n \le 2000$。  
另有 $10 \%$ 的数据，$B_i = 0$。
另有 $10 \%$ 的数据，$C = 1$ 且对于有直系下属的人 $T / A_i > n$。  
另有 $10 \%$ 的数据，$B_i = i - 1$。

对于 $100 \%$ 的数据，$1 \le n \le 500000$，$1 \le T \le {10}^9$，$B_i < i$，$1 \le A_i \le T$。


## 样例 #1

### 输入

```
14 5 3
0 3
0 3
1 10
1 10
2 3
2 10
2 3
5 10
7 10
5 10
7 10
5 10
7 10
5 10
```

### 输出

```
50
```

# AI分析结果



# 【算法分类】
无算法分类（树形贪心）

---

# 【题解思路、算法要点与解决难点】

## 核心思路
- **树形贪心**：自底向上递归处理每个节点，收集子节点的最小费用，选择满足条件的最小子集。
- **关键操作**：每个非叶子节点需要选取其子节点中费用最小的前 k 个（k = ⌈A_i * 子节点数 / T⌉），确保满足比例条件且总费用最小。

## 解决难点
1. **比例计算精度**：必须使用浮点数或精确整数运算避免取整错误。
2. **子节点选择效率**：需快速选择前 k 小的子节点费用，优先队列或排序均可实现 O(m log m) 复杂度。
3. **递归合并优化**：通过递归合并子节点结果，避免重复计算。

---

# 【题解评分 (≥4星)】

1. **momo5440（5星）**
   - **亮点**：代码简洁，优先队列处理高效，递归逻辑清晰，注释明确。
   - **关键代码**：
     ```cpp
     priority_queue<ll, vector<ll>, greater<ll>> q;
     for (auto child : bian[x]) q.push(dfs(child));
     ll k = ceil(1.0 * a[x] * bian[x].size() / t);
     while (k--) ans += q.top(), q.pop();
     ```

2. **xy0313（4星）**
   - **亮点**：详细解释贪心策略，使用小根堆优化，处理根节点特判。
   - **心得摘录**：“每个节点选择最小的前 k 个儿子，这就是贪心。”

3. **郑朝曦zzx（4星）**
   - **亮点**：状态转移描述清晰，代码包含浮点处理函数，兼容性较强。
   - **代码片段**：
     ```cpp
     sort(now.begin(), now.end());
     ll sum = ceil((double)cost[x] * cnt / t);
     for (int i=0; i<sum; i++) ans += now[i];
     ```

---

# 【最优思路或技巧提炼】

1. **自底向上贪心**：递归处理子节点后合并结果，确保父节点决策最优。
2. **快速选择前 k 小元素**：优先队列或排序后取前 k 项，时间复杂度 O(m log m)。
3. **浮点精度处理**：使用 `ceil` 或整数运算避免取整错误，如 `(a * b + t - 1) / t`。

---

# 【同类型题或类似算法套路】

- **树形贪心通式**：父节点决策依赖子节点的局部最优解（如 UVA12186）。
- **经典问题**：最小生成树（Kruskal）、哈夫曼编码（优先队列合并）。

---

# 【推荐相似题目】

1. **P2014 [CTSC1997] 选课**（树形依赖背包）
2. **UVA12186 工人的请愿书**（树形贪心，类似本题）
3. **P1273 有线电视网**（树形DP结合费用选择）

---

# 【可视化与算法演示】

## 动画设计
1. **树形结构展开**：以根节点开始，递归展开子树，高亮当前处理节点。
2. **子节点费用收集**：显示子节点费用列表，动态排序或优先队列插入过程。
3. **选择前 k 小项**：高亮被选中的子节点费用，累加显示到父节点总费用。

## 复古像素风格
- **颜色方案**：8-bit 色调（深绿节点，黄色费用值，红色选中框）。
- **Canvas 绘制**：网格布局树结构，每个节点显示费用，选中项闪烁。
- **音效**：插入子节点时“滴”声，选中时“叮”声，错误时蜂鸣声。

---

# 【核心代码实现】

```cpp
#include <vector>
#include <queue>
using namespace std;
typedef long long ll;

vector<int> children[500005];
ll a[500005], T;

ll dfs(int u) {
    if (children[u].empty()) return a[u];
    priority_queue<ll, vector<ll>, greater<ll>> pq;
    for (int v : children[u]) 
        pq.push(dfs(v));
    int k = (a[u] * children[u].size() + T - 1) / T; // 整数避免浮点
    ll sum = 0;
    while (k-- && !pq.empty()) {
        sum += pq.top();
        pq.pop();
    }
    return sum;
}

int main() {
    int n, C; 
    cin >> n >> T >> C;
    a[0] = C;
    for (int i=1; i<=n; i++) {
        int parent; 
        cin >> parent >> a[i];
        children[parent].push_back(i);
    }
    cout << dfs(0);
}
```

---

# 【个人心得摘录】

- **momo5440**：“递归调用 dfs 并压入优先队列，取最小的几个——这就是贪心的精髓。”
- **xy0313**：“向上取整必须用 `ceil`，否则比例计算会出错，WA 了几次才明白。”
- **郑朝曦zzx**：“开 long long 是必须的，否则大数据会溢出，比赛吃过亏。”

---
处理用时：95.89秒
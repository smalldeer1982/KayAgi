# 题目信息

# Power收集

## 题目背景

据说在红雾异变时，博丽灵梦单身前往红魔馆，用十分强硬的手段将事件解决了。

然而当时灵梦在 Power 达到 MAX 之前，不具有“上线收点”的能力，所以她想要知道她能收集多少 P 点，然而这个问题她答不上来，于是她找到了学 OI 的你。

## 题目描述

可以把游戏界面理解成一个 $N$ 行 $M$ 列的棋盘，有 $K$ 个格子上有 $P$ 点，其价值为 $\operatorname{val}(i,j)$。

初始灵梦可以选择在第一行的任意一个格子出发，每秒她必须下移一格。

灵梦具有一个左右移动的速度 $T$，可以使她每秒向左或右移动至多 $T$ 格，也可以不移动，并且不能折返。移动可视为瞬间完成，不经过路途上的点，只能获得目标格子的 P 点。

求最终她能获得的 POWER 值最大是多少？

## 说明/提示

对于 $40\%$ 的测试点，$1 \le N,M,T,K \le 200$。

对于 $100\%$ 的测试点，$1 \le N,M,T,K \le 4000$。

$v \le 100$，$N,M,K,T$ 均为整数。

by-szc

## 样例 #1

### 输入

```
3 3 4 1
1 1 3
1 2 1
2 2 3
3 3 3
```

### 输出

```
9```

# AI分析结果



## 【输出】

**唯一算法分类**：线性DP

---

### **综合分析与结论**

#### **核心思路与状态转移**
题目本质为二维网格中的路径最值问题，需通过动态规划解决。状态定义为`dp[i][j]`表示走到第i行第j列的最大POWER值。状态转移方程为：
```
dp[i][j] = max{ dp[i-1][k] | j-T ≤ k ≤ j+T } + val[i][j]
```
暴力枚举转移的复杂度为O(nmT)，无法通过大规模数据。**核心优化**在于用单调队列维护滑动窗口最大值，将复杂度降为O(nm)。

#### **关键难点与优化**
1. **滑动窗口维护**：每个`dp[i][j]`需要从上一行宽度为2T的区间中取最大值。通过单调队列维护窗口内的递减序列，保证队首始终为当前窗口最大值。
2. **滚动数组优化**：仅保留上一行的数据，空间复杂度从O(nm)降为O(m)。
3. **特殊输入处理**：针对稀疏点（K较小）的情况，部分题解提出按点排序后二维偏序优化的O(k²)解法。

#### **可视化设计**
- **网格动态更新**：用Canvas绘制网格，每行用不同颜色表示当前处理列。高亮当前处理的`dp[i][j]`和对应的窗口区间。
- **单调队列动画**：在侧边栏动态显示队列元素，队列元素用像素块表示值大小，队首用闪烁效果标记。
- **复古音效**：状态更新时播放8-bit音效，找到更大值时用高音提示，错误操作时用低音警报。
- **自动演示模式**：以红白机风格按钮控制播放速度，支持单步调试观察队列变化。

---

### **题解清单 (4星及以上)**

1. **灵乌路空 (5星)**
   - **亮点**：详细图解滑动窗口与单调队列的对应关系，代码实现手写队列提升效率。
   - **代码片段**：
     ```cpp
     void insert(int x) {
         while (f[now-1][x] > f[now-1][q[tail]] && tail >= head) tail--;
         q[++tail] = x;
     }
     int find(int j) {
         if (j+t <= m) insert(j+t);
         while (q[head]+t < j) head++;
         return q[head];
     }
     ```

2. **xcxc82 (4星)**
   - **亮点**：用GIF动态演示滑动窗口移动过程，直观展示队列维护逻辑。
   - **关键图示**：窗口随列移动的动画，帮助理解区间右移时的入队出队操作。

3. **_edge_ (4星)**
   - **亮点**：提出基于点排序的O(k²)解法，适用于稀疏数据场景。
   - **代码片段**：
     ```cpp
     for (int i=1; i<=k; i++) {
         f[i] = a[i].z;
         for (int j=1; j<i; j++) {
             if (abs(a[i].y - a[j].y) <= t*(a[i].x - a[j].x)) 
                 f[i] = max(f[i], f[j] + a[i].z);
         }
     }
     ```

---

### **最优思路提炼**
- **单调队列优化**：维护窗口内递减序列，每次转移O(1)时间取最大值。
- **滚动数组**：仅用两行数组交替更新，节省内存。
- **边界处理**：窗口左右边界需与网格实际范围取交集（`max(1, j-T)`和`min(m, j+T)`）。

---

### **同类型题与推荐题目**
1. **P1886 滑动窗口**：单调队列模板题，练习窗口最值维护。
2. **P1725 琪露诺**：线性DP+单调队列优化，类似本题的纵向移动问题。
3. **P2251 质量检测**：滑动窗口变种，可用RMQ或单调队列解决。

---

### **核心代码实现**
```cpp
// 单调队列优化版本（灵乌路空题解核心）
for (int now=2; now<=n; now++) {
    head = tail = 1; // 重置队列
    for (int j=1; j<=t; j++) insert(j); // 初始化窗口前T列
    for (int j=1; j<=m; j++) {
        int max_prev = find(j); // 获取窗口最大值
        dp[now][j] = dp[now-1][max_prev] + val[now][j];
    }
}
```

---

### **复古像素风动画设计**
1. **网格绘制**：用16色调色板，每个格子显示`dp[i][j]`值，当前处理列用黄色闪烁。
2. **队列显示**：右侧显示单调队列元素，队首用红色边框标记，新入队元素绿色高亮。
3. **音效触发**：
   - 新元素入队：短促“哔”声。
   - 队首弹出：低音“嘟”声。
   - 更新最大值：清脆“叮”声。
4. **自动演示**：按A键加速，B键减速，START键暂停，SELECT键单步执行。

---

### **交互示例（伪代码）**
```javascript
// Canvas绘制代码片段
function drawGrid(dp, currentRow, currentCol) {
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvas.width, canvas.height); // 清空画布
    for (let i = 0; i < m; i++) {
        const val = dp[currentRow][i];
        const color = getColorByValue(val); // 根据值映射颜色
        ctx.fillStyle = (i === currentCol) ? '#FFFF00' : color;
        ctx.fillRect(i * CELL_SIZE, currentRow * CELL_SIZE, CELL_SIZE, CELL_SIZE);
    }
}
```

---
处理用时：78.62秒
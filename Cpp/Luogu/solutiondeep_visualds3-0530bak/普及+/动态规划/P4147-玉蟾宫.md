# 题目信息

# 玉蟾宫

## 题目背景

有一天，小猫 rainbow 和 freda 来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。


## 题目描述

这片土地被分成 $N\times M$ 个格子，每个格子里写着 'R' 或者 'F'，R 代表这块土地被赐予了 rainbow，F 代表这块土地被赐予了 freda。

现在 freda 要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着 'F' 并且面积最大。

但是 rainbow 和 freda 的 OI 水平都弱爆了，找不出这块土地，而蓝兔也想看 freda 卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为 $S$，它们每人给你 $S$ 两银子。


## 说明/提示

对于 $50\%$ 的数据，$1 \leq N, M \leq 200$。  
对于 $100\%$ 的数据，$1 \leq N, M \leq 1000$。

## 样例 #1

### 输入

```
5 6 
R F F F F F 
F F F F F F 
R R R F F F 
F F F F F F 
F F F F F F```

### 输出

```
45```

# AI分析结果



### 算法分类
**线性DP**

### 题解思路与难点分析
**核心思路**：  
本题属于最大全1子矩阵问题，主流解法为**悬线法**和**单调栈**，均属于线性DP思路的变种：
1. **悬线法**：  
   - 预处理每个点向上延伸的最大高度 `h[i][j]`  
   - 动态维护每个点能向左/右扩展的最远位置 `left[i][j]` 和 `right[i][j]`  
   - 状态转移方程：  
     ```  
     h[i][j] = h[i-1][j] + 1 (若当前为'F')  
     left[i][j] = max(left[i][j], left[i-1][j])  
     right[i][j] = min(right[i][j], right[i-1][j])  
     ```
   - 最终面积由 `h[i][j] * (right[i][j] - left[i][j] + 1)` 计算  

2. **单调栈**：  
   - 逐行处理，构建每列的高度数组 `height[j]`（当前行及上方连续'F'数）  
   - 维护单调递增栈，快速计算每个高度能向左/右扩展的最大宽度  
   - 每次弹栈时更新最大面积  

**解决难点**：  
- **悬线法**需正确处理左右边界的动态收缩（取历史值与当前行值的极值）  
- **单调栈**需处理栈内元素的高度关系与宽度累加逻辑  
- 数据规模大（1000x1000），需严格保证O(NM)时间复杂度  

---

### 优质题解推荐（评分≥4★）
#### 1. 假假（单调栈，5★）
**亮点**：  
- 清晰分步解释预处理与单调栈操作  
- 代码结构简洁，栈节点用结构体存储高度和宽度  
- 包含弹栈后合并宽度的细节处理  

#### 2. XG_Zepto（悬线法，5★）
**亮点**：  
- 完整悬线法三要素（h/left/right）推导  
- 代码中显式初始化边界条件（如 `R[0][i] = m+1`）  
- 状态转移逻辑明确，适合DP初学者理解  

#### 3. kradcigam（悬线法+滚动数组，4★）
**亮点**：  
- 使用滚动数组优化空间至O(M)  
- 代码实现高效，内存占用低  
- 逐行处理时动态更新左右边界  

---

### 最优思路提炼
**悬线法核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    int lo = 0, ro = m + 1;
    for (int j = 1; j <= m; j++) {
        if (a[i][j] == 'R') {
            lo = j;
            h[i][j] = 0;
            left[i][j] = 0;
        } else {
            h[i][j] = h[i - 1][j] + 1;
            left[i][j] = max(left[i][j], left[i - 1][j]);
        }
    }
    for (int j = m; j >= 1; j--) {
        if (a[i][j] == 'R') {
            ro = j;
            right[i][j] = m + 1;
        } else {
            right[i][j] = min(right[i][j], right[i - 1][j]);
            ans = max(ans, h[i][j] * (right[i][j] - left[i][j] + 1));
        }
    }
}
```

**关键技巧**：  
- 滚动数组优化空间  
- 左右边界初始化为当前行值，再与上一行取极值  

---

### 相似题目推荐
1. [P1169 棋盘制作](https://www.luogu.com.cn/problem/P1169)（悬线法应用）  
2. [P2701 巨大的牛棚](https://www.luogu.com.cn/problem/P2701)（最大全1正方形）  
3. [LeetCode 84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)（单调栈经典题）  

---

### 可视化设计（悬线法演示）
**动画方案**：  
1. **网格绘制**：  
   - 用Canvas绘制N×M网格，'R'为红色，'F'为绿色  
   - 动态显示当前处理的行i和列j  

2. **悬线标记**：  
   - 当前点(i,j)的悬线高度`h[i][j]`用蓝色竖线表示  
   - 左右边界`left[i][j]`和`right[i][j]`用黄色虚线标记  

3. **状态更新**：  
   - 当处理(i,j)时，高亮其对应的`h`、`left`、`right`值  
   - 显示当前最大矩形面积及位置  

**复古像素风格**：  
- 8-bit音效：  
  - 移动光标时播放"滴"声  
  - 更新最大面积时播放"金币"音效  
- 颜色方案：  
  - 背景：#2D2D2D  
  - 网格线：#4A4A4A  
  - 'F'：#27AE60，'R'：#E74C3C  
  - 悬线：#3498DB，边界线：#F1C40F  

**交互功能**：  
- 速度滑块控制动画步进间隔  
- 暂停/继续按钮冻结当前状态  
- 点击任意格子查看其`h/left/right`值  

---

### 总结
悬线法与单调栈均为解决最大子矩阵的高效方法，悬线法更易理解DP思想，而单调栈代码更简洁。实际编码时可根据数据特征选择，若需空间优化可优先考虑滚动数组版的悬线法。

---
处理用时：99.48秒
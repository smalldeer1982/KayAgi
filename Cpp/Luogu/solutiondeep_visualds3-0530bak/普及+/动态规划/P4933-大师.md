# 题目信息

# 大师

## 题目背景

建筑大师最近在跟着数学大师 ljt12138 学数学，今天他学了等差数列，ljt12138 决定给他留一道练习题。

## 题目描述

ljt12138 首先建了 $n$ 个特斯拉电磁塔，这些电塔排成一排，从左到右依次标号为 $1$ 到 $n$，第 $i$ 个电塔的高度为 $h[i]$。

建筑大师需要从中选出一些电塔，然后这些电塔就会缩到地下去。这时候，如果留在地上的电塔的高度，从左向右构成了一个等差数列，那么这个选择方案就会被认为是美观的。

建筑大师需要求出，一共有多少种美观的选择方案，答案模 $998244353$。

注意，如果地上只留了一个或者两个电塔，那么这种方案也是美观的。地上没有电塔的方案被认为是不美观的。

同时也要注意，等差数列的公差也可以为负数。

## 说明/提示

设 $v$ 为最高的电塔高度。

对于前 $30\%$ 的数据，$n \le 20 $。

对于前 $60\%$ 的数据，$n \le 100$，$v \le 2 \times 10^3$。

对于另外 $20\%$ 的数据，所有电塔的高度构成一个等差数列。

对于 $100\%$ 的数据，$n \le 10^3$，$v \leq2 \times 10^4$。

## 样例 #1

### 输入

```
8
13 14 6 20 27 34 34 41 
```

### 输出

```
50
```

## 样例 #2

### 输入

```
100
90 1004 171 99 1835 108 81 117 141 126 135 144 81 153 193 81 962 162 1493 171 1780 864 297 180 532 1781 189 1059 198 333 1593 824 207 1877 216 270 225 1131 336 1875 362 234 81 288 1550 243 463 1755 252 406 261 270 279 288 1393 261 1263 297 135 333 872 234 881 180 198 81 225 306 180 90 315 81 81 198 252 81 297 1336 1140 1238 81 198 297 661 81 1372 469 1132 81 126 324 333 342 81 351 481 279 1770 1225 549 
```

### 输出

```
11153
```

# AI分析结果



### 算法分类
**线性DP**

---

### 题解思路、算法要点与解决难点

#### 核心思路
1. **状态定义**：  
   - `f[i][d]` 表示以第 `i` 个电塔结尾，公差为 `d` 的等差数列子序列的数量。
   - 偏移量处理负数公差：将 `d` 加上 `20000` 或类似值，映射到正数下标。

2. **状态转移**：  
   - 对于每个电塔 `i`，遍历其前面的所有电塔 `j`，计算公差 `d = a[i] - a[j]`。
   - 转移方程：`f[i][d] += f[j][d] + 1`，其中 `+1` 表示新增的 `(j, i)` 二元组。
   - 答案累加：所有 `f[i][d]` 的和，加上单元素情况（`n`）。

3. **解决难点**：  
   - **负数公差**：通过偏移量将公差映射到正数范围，避免数组越界。
   - **重复计算优化**：直接枚举相邻元素，避免全局枚举公差。
   - **空间优化**：利用动态规划状态的局部性，仅需二维数组即可。

---

### 题解评分（≥4星）
1. **chengni（5星）**  
   - 亮点：简洁高效的 `O(n²)` 动态规划，通过偏移量处理负数，代码短小精悍。
   - 代码片段：
     ```cpp
     for (int i = 1; i <= n; i++) {
         ans++; // 单元素情况
         for (int j = i-1; j >= 1; j--) {
             int d = a[i] - a[j] + p; // 偏移量处理
             f[i][d] += f[j][d] + 1;  // 转移
             ans += f[j][d] + 1;      // 累加答案
         }
     }
     ```

2. **魂逝_秦月歌（4星）**  
   - 亮点：清晰的 `f[i][d]` 状态转移，代码可读性强，包含单元素和双元素处理。
   - 代码片段：
     ```cpp
     for (int j = i-1; j >= 1; j--) {
         int d = a[i] - a[j] + N; // 偏移量
         ans = (ans + f[j][d]) % mod;
         f[i][d] = (f[i][d] + f[j][d] + 1) % mod;
     }
     ```

3. **Ivystorm（4星）**  
   - 亮点：避免枚举公差，直接利用相邻元素差值，通过动态规划自然覆盖所有可能公差。

---

### 最优思路或技巧提炼
1. **动态规划状态设计**：  
   - 以 `f[i][d]` 表示以 `i` 结尾、公差 `d` 的方案数，直接通过相邻元素差值生成公差。

2. **偏移量技巧**：  
   - 将公差 `d` 加上固定值（如 `20000`），避免负数下标问题。

3. **高效转移**：  
   - 枚举所有 `j < i`，利用已有的 `f[j][d]` 快速更新 `f[i][d]`，复杂度 `O(n²)`。

---

### 同类型题或类似算法套路
- **最长递增子序列（LIS）**：类似线性 DP，状态表示以 `i` 结尾的序列。
- **斐波那契数列变形**：状态转移依赖前若干项，但需自定义转移规则。
- **子序列计数问题**：如统计回文子序列数，利用 DP 记录中间状态。

---

### 推荐相似题目
1. **P1020 导弹拦截**（线性 DP，最长不升子序列）
2. **P1216 数字三角形**（线性 DP，路径计数）
3. **P1439 最长公共子序列**（LCS 的 `O(n²)` DP）

---

### 个人心得摘录
- **chengni**：*“不必枚举公差，直接通过相邻元素差值生成公差”* —— 避免冗余计算。
- **魂逝_秦月歌**：*“每个状态转移时都加上前序状态的贡献”* —— 强调递推的连贯性。

---

### 可视化与算法演示
#### 动态规划矩阵更新动画
1. **可视化设计**：  
   - **网格展示**：Canvas 绘制 `n x (4e4)` 的网格，每个格子表示 `f[i][d]`。
   - **颜色标记**：  
     - 黄色：当前处理的 `i` 和 `j`。
     - 绿色：`f[j][d]` 被激活，贡献到 `f[i][d]`。
   - **步进控制**：支持暂停/继续，调节动画速度观察转移细节。

2. **复古像素风格**：  
   - **8位音效**：状态转移时播放“哔”声，答案更新时播放“叮”声。
   - **自动演示**：AI 按 `i` 从小到大自动遍历，高亮当前操作区域。

#### 核心代码片段（JavaScript）
```javascript
// 初始化 DP 矩阵和偏移量
const p = 20000;
let dp = Array(n+1).fill().map(() => Array(40001).fill(0));
let ans = 0;

// 模拟 DP 过程
for (let i = 1; i <= n; i++) {
    ans++; // 单元素
    for (let j = i-1; j >= 1; j--) {
        const d = a[i] - a[j] + p;
        dp[i][d] += dp[j][d] + 1;
        ans += dp[j][d] + 1;
        // 触发动画：高亮 dp[i][d] 和 dp[j][d]
    }
}
```

---

### 总结
通过线性 DP 和偏移量技巧高效解决等差数列子序列计数问题，核心在于状态设计和转移优化。

---
处理用时：94.36秒
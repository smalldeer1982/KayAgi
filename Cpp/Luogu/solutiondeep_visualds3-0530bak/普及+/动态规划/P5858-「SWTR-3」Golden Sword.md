# 题目信息

# 「SWTR-3」Golden Sword

## 题目背景

小 E 不幸在一场战斗中失去了他的金宝剑。

## 题目描述

制造一把金宝剑需要 $n$ 种原料，编号为 $1$ 到 $n$，编号为 $i$ 的原料的坚固值为 $a_i$。

炼金是很讲究放入原料的顺序的，因此小 E 必须**按照 $1$ 到 $n$ 的顺序**依次将这些原料放入炼金锅。

但是，炼金锅的容量非常有限，它**最多只能容纳 $w$ 个原料**。

所幸的是，**每放入一个原料之前**，小 E 可以从中取出一些原料，数量不能超过 $s$ 个。

- 我们定义第 $i$ 种原料的耐久度为：放入第 $i$ 种原料时锅内的原料总数（包括正在放入的原料） $\times\ a_i$，则宝剑的耐久度为**所有原料**的耐久度之和。

小 E 当然想让他的宝剑的耐久度尽可能得大，这样他就可以带着它进行更多的战斗，请求出耐久度的最大值。

注：这里的“放入第 $i$ 种原料时锅内的原料总数**包括正在放入锅中的原料**，详细信息请见样例。

## 说明/提示

#### 「样例说明」

- **对于样例 1**，一种可行的**最优**方案为：
首先放进原料 1，此时锅内有 $1$ 种原料，耐久度为 $1\times a_1=1\times 1=1$。  
再放进原料 2，此时锅内有 $2$ 种原料，耐久度为 $2\times a_2=2\times 3=6$。  
再放进原料 3，此时锅内有 $3$ 种原料，耐久度为 $3\times a_3=3\times 2=6$。  
取出原料 1，再放进原料 4，此时锅内有 $3$ 种原料，耐久度为 $3\times a_4=3\times 4=12$。  
取出原料 4，再放进原料 5，此时锅内有 $3$ 种原料，耐久度为 $3\times a_5=3\times 5=15$。  
最终答案为 $1+6+6+12+15=40$。  
- **对于样例 2**，一种可行的**最优**方案为：  
放进原料 1，耐久度为 $1\times 1=1$。  
取出原料 1，放进原料 2，耐久度为 $1\times (-3)=-3$。  
放进原料 3，耐久度为 $2\times (-2)=-4$。  
放进原料 4，耐久度为 $3\times 4=12$。  
取出原料 2，放进原料 5，耐久度为 $3\times 5=15$。  
最终答案为 $1+(-3)+(-4)+12+15=21$。  
- **对于样例 3**，一种可行的**最优**方案为：  
  $a_1+2a_2+2a_3+3a_4+4a_5+3a_6+4a_7=17$。 
- **对于样例 4**，一种可行的**最优**方案为：  
$a_1+a_2+a_3+a_4+a_5=-15$。

#### 「数据范围与约定」

**本题使用捆绑测试。**

- Subtask #1（15 points）：$n\leq 10$。
- Subtask #2（5 points）：$n\leq 100$，$a_i\geq0$。
- Subtask #3（15 points）：$n\leq 300$。
- Subtask #4（15 points）：$s=w=n$。
- Subtask #5（5 points）：$a_i\geq 0$。
- Subtask #6（10 points）：$n\leq 2\times 10^3$。
- Subtask #7（10 points）：$s=1$。
- Subtask #8（25 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \leq s \leq w \leq n \leq 5\times 10^3$，$|a_i| \leq 10^9$。对于 Subtask $i$ 有 $|a_i|\leq 10^{i+1}$。

#### 「帮助/说明」

本题下发大样例，具体输入输出见 [**Big Sample**](https://pan.baidu.com/s/1erVDllDlvNlEShxh3U42gA) 中的 gold01-08.in/gold01-08.out。提取码：757d。  
**文件名与 Subtask 编号一一对应。**

#### 「来源」

[Sweet Round 03 D](https://www.luogu.com.cn/contest/24755)。  
idea & solution：ET2006。

## 样例 #1

### 输入

```
5 3 3
1 3 2 4 5
```

### 输出

```
40```

## 样例 #2

### 输入

```
5 3 3
1 -3 -2 4 5
```

### 输出

```
21```

## 样例 #3

### 输入

```
7 4 2
-5 3 -1 -4 7 -6 5
```

### 输出

```
17```

## 样例 #4

### 输入

```
5 3 1
-1 -3 -2 -4 -5
```

### 输出

```
-15```

# AI分析结果



## 算法分类
线性DP

---

## 题解思路与核心难点

### 核心思路
采用动态规划结合单调队列优化。定义状态 `dp[i][j]` 表示放入第 `i` 个原料时，锅内共有 `j` 个原料的最大耐久度之和。状态转移方程为：
```math
dp[i][j] = \max_{k \in [j-1, \min(j+s-1, w)]} (dp[i-1][k]) + a_i \times j
```
通过单调队列维护滑动窗口内的最大值，将时间复杂度从 O(nw^2) 优化至 O(nw)。

### 解决难点
1. **状态转移优化**：传统三重循环会超时，利用单调队列维护前一层 DP 值的滑动窗口最大值。
2. **倒序处理**：从后向前更新状态，保证队列插入顺序符合窗口右边界移动方向。
3. **边界处理**：正确处理 `k` 的范围限制，特别是当 `j+s-1` 超过锅容量 `w` 时。

---

## 最优思路提炼
**关键优化点**：
1. **单调队列维护窗口最大值**：每个状态转移时，队列头部始终保存当前窗口内的最大 DP 值。
2. **倒序枚举 j**：避免正序处理时窗口左移导致的重复计算，保证队列插入顺序的正确性。
3. **滚动数组优化空间**：仅保留当前层和上一层的 DP 数组，降低空间复杂度。

**代码实现技巧**：
- 初始化为极小值（`-inf`），确保无效状态不被选择。
- 队列同时存储 DP 值和对应的原料数量 `k`，便于范围检查。
- 动态调整窗口大小，处理 `j+s-1` 超出锅容量的情况。

---

## 题解评分

### [Alex_Wei 的题解] ★★★★★
- **亮点**：代码清晰，滚动数组优化，队列初始化逻辑严谨。
- **核心代码**：
```cpp
for(int j=min(w,i);j>=1;j--) {
    if(j>1) q.push(dp[i-1][j-1],j-1); // 插入新候选
    q.pop(j); // 维护窗口左边界
    dp[i][j] = q.head().val + a[i] * j;
}
```

### [Bosun 的题解] ★★★★☆
- **亮点**：代码简洁，使用双数组交替更新，注释清晰。
- **优化点**：省略显式滚动数组切换，通过位运算简化代码。

### [pomelo_nene 的题解] ★★★★☆
- **亮点**：详细分析暴力解法到优化的推导过程，适合教学。
- **代码问题**：未使用滚动数组，空间复杂度较高。

---

## 代码实现（核心部分）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=5505;
const ll INF=1e18;

ll dp[2][N], a[N];
int n, w, s;

struct MonotoneQueue {
    deque<pair<ll, int>> q;
    void push(ll val, int pos) {
        while (!q.empty() && q.back().first <= val) 
            q.pop_back();
        q.emplace_back(val, pos);
    }
    void pop(int left) {
        while (!q.empty() && q.front().second < left)
            q.pop_front();
    }
    ll max() { return q.empty() ? -INF : q.front().first; }
};

int main() {
    cin >> n >> w >> s;
    for (int i=1; i<=n; ++i) cin >> a[i];
    
    fill(dp[0], dp[0]+w+1, -INF);
    dp[0][0] = 0;
    
    for (int i=1; i<=n; ++i) {
        MonotoneQueue mq;
        int cur = i&1, prev = cur^1;
        fill(dp[cur], dp[cur]+w+1, -INF);
        
        for (int j=w; j>=1; --j) {
            int k_min = j-1, k_max = min(j+s-1, w);
            if (k_max >= w) mq.push(dp[prev][w], w);
            
            mq.pop(k_min);
            if (j > 1) mq.push(dp[prev][j-1], j-1);
            
            ll max_prev = mq.max();
            if (max_prev != -INF) 
                dp[cur][j] = max_prev + a[i] * j;
        }
    }
    
    ll ans = -INF;
    for (int j=1; j<=w; ++j) 
        ans = max(ans, dp[n&1][j]);
    cout << ans << endl;
}
```

---

## 相似题目
1. **P3957 跳房子**：单调队列优化 DP，滑动窗口最大值。
2. **P1725 琪露诺**：线性 DP + 滑动窗口优化。
3. **P2569 股票交易**：复杂状态转移中的单调队列应用。

---

## 可视化设计（动态规划过程）

### 动画方案
1. **网格绘制**：Canvas 绘制二维 DP 表格，行表示原料编号，列表示锅内数量。
2. **颜色标记**：
   - 红色：当前更新的单元格 `dp[i][j]`
   - 蓝色：参与计算的上一层的窗口区域 `dp[i-1][k_min..k_max]`
3. **队列可视化**：右侧面板显示单调队列元素，动态展示入队、出队过程。

### 复古像素风格
- **调色板**：8-bit 风格，使用 #FF0000（红）、#0000FF（蓝）、#00FF00（绿）突出关键元素。
- **音效**：
  - 状态更新：8-bit "哔"声
  - 队列弹出：短促 "滴"声
  - 最优解更新：上升音阶

### 交互功能
- **步进控制**：空格键暂停/继续，方向键单步前进/后退。
- **参数调节**：滑动条动态修改 `w` 和 `s`，实时观察 DP 表变化。

---

通过结合动态规划的核心逻辑与游戏化交互，学习者可以直观理解状态转移和单调队列优化的协同工作原理。

---
处理用时：114.03秒
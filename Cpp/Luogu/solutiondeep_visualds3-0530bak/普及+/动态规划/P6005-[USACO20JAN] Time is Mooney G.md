# 题目信息

# [USACO20JAN] Time is Mooney G

## 题目描述

Bessie 正在安排前往牛尼亚的一次出差，那里有 $N$（$2 \leq N \leq 1000$）个编号为 $1 \ldots N$ 的城市，由 $M$（$1 \leq M \leq 2000$）条单向的道路连接。Bessie 每次访问城市 $i$ 都可以赚到 $m_i$ 哞尼（$0 \leq m_i \leq 1000$）。从城市 $1$ 出发，Bessie 想要赚到尽可能多的哞尼，最后回到城市 $1$。为了避免争议，$m_1=0$。

沿着两个城市之间的道路移动需要消耗一天。出差的准备工作十分费钱；旅行 $T$ 天需要花费 $C \times T^2$ 哞尼（$1 \leq C \leq 1000$）。

Bessie 在一次出差中最多可以赚到多少哞尼？注意有可能最优方案是 Bessie 不访问城市 $1$ 之外的任何城市，在这种情况下结果应当为 $0$。

## 说明/提示

最优的旅行方案是 $1 \to 2 \to 3 \to 1 \to 2 \to 3 \to1$。Bessie 总共赚到了 $10+20+10+20-1 \times 6^2=24$ 哞尼。

## 样例 #1

### 输入

```
3 3 1
0 10 20
1 2
2 3
3 1```

### 输出

```
24```

# AI分析结果



# 算法分类  
**线性DP**

---

## 题解思路与核心分析

### 关键状态转移方程  
设 `f[i][j]` 表示第 `i` 天到达城市 `j` 时的最大收益。状态转移方程为：  
```
f[i][j] = max{ f[i-1][k] + m_j }，其中存在边 k → j
```  
最终答案为 `max{ f[i][1] - C*i² }`（需遍历所有可能的 `i`）。

### 解决难点与优化  
1. **时间上限推导**：  
   由于总收益为 `Σm_j - C*T²`，当 `T > 1000` 时，`C*T²` 的增长速度远超收益，因此 `T` 最大枚举到 1000 即可（`m_i ≤1000, C≥1`）。

2. **反向建边优化**：  
   在转移时，通过反向边（`v → u` 存储为 `u 的前驱`）快速遍历所有可能的 `k`（如奇米、Jayun 的代码）。

3. **分层图思想**：  
   wmy_goes_to_thu 的分层图 SPFA 将天数作为第二维状态，但核心仍是动态规划的变形。

### 题解评分（≥4星）  

1. **奇米（★★★★☆）**  
   - **亮点**：反向建边实现高效状态转移；代码简洁清晰。  
   - **优化**：预处理 `f` 数组的初始状态（`f[0][1]=0`），避免无效转移。  
   - **代码片段**：  
     ```cpp
     for (int i=1; i<=1000; i++) {
         for (int j=1; j<=n; j++)
             for (int k=head[j]; k; k=e[k].nex) {
                 int v = e[k].to;
                 if (~f[i-1][v]) 
                     f[i][j] = max(f[i][j], f[i-1][v] + M[j]);
             }
         ans = max(ans, f[i][1] - C*i*i);
     }
     ```

2. **gznpp（★★★★☆）**  
   - **亮点**：直接正向遍历边，无需反向建边；代码结构紧凑。  
   - **关键实现**：  
     ```cpp
     for (rg int t = 1; t <= 1000; ++t) {
         for (rg int i = 1; i <= m; ++i) 
             if (~dp[t-1][u[i]])
                 up(dp[t][v[i]], dp[t-1][u[i]] + a[v[i]]);
         up(ans, dp[t][1] - c * t * t);
     }
     ```

3. **Jayun（★★★★☆）**  
   - **亮点**：明确将天数与城市作为二维状态，逻辑直白。  
   - **个人心得**：强调反向建边的必要性（“邻接表倒着存以辅助转移”）。

---

## 最优思路提炼  
1. **状态设计**：以 `(天数, 城市)` 为状态，确保能完整记录路径信息。  
2. **时间剪枝**：枚举天数上限为 1000，避免无效计算。  
3. **反向遍历优化**：通过反向边快速找到所有前驱节点，降低转移复杂度。

---

## 同类题目与算法套路  
1. **分层图问题**：如 [P4568 飞行路线](https://www.luogu.com.cn/problem/P4568)（分层图最短路）。  
2. **时间维度 DP**：如 [P1070 道路游戏](https://www.luogu.com.cn/problem/P1070)（时间与机器人移动的线性 DP）。  
3. **带权路径规划**：如 [P1262 间谍网络](https://www.luogu.com.cn/problem/P1262)（动态规划与图遍历结合）。

---

## 可视化设计  
### 动态规划矩阵更新动画  
1. **网格绘制**：  
   - 横向为天数（0~1000），纵向为城市编号（1~N）。  
   - 每个格子显示 `f[i][j]` 的值，初始为灰色（无效状态），有效值用绿色渐变（值越大颜色越深）。  
2. **高亮操作**：  
   - 当前处理的天数 `i` 整行高亮为黄色。  
   - 更新 `f[i][j]` 时，前驱节点 `k` 的格子闪烁蓝色，目标格子 `j` 变为橙色。  
3. **音效设计**：  
   - **状态更新**：短促“滴”声。  
   - **找到更优解**：上扬音调（类似金币音效）。  
   - **最终答案更新**：8-bit 风格胜利音效。  

### 复古像素风格示例（伪代码）  
```javascript
// Canvas 初始化
const ctx = canvas.getContext('2d');
const gridSize = 20; // 每个格子 20x20 像素

function drawDPGrid() {
    for (let i = 0; i <= 1000; i++) {
        for (let j = 1; j <= n; j++) {
            // 根据 f[i][j] 的值设置颜色
            ctx.fillStyle = getColor(f[i][j]);
            ctx.fillRect(i * gridSize, j * gridSize, gridSize, gridSize);
        }
    }
    // 高亮当前处理的天数
    ctx.strokeStyle = '#FFD700'; // 金色边框
    ctx.strokeRect(currentDay * gridSize, 0, gridSize, (n+1)*gridSize);
}
```

---

## 个人心得摘录  
- **奇米**：反向建边使得状态转移更高效，“无需正向搜索所有可能路径”。  
- **UltiMadow**：“最优性剪枝是关键，避免重复搜索已无法优化的路径”。  
- **pocafup**：“暴力枚举 1000 次 Dijkstra 看似笨拙，但实际复杂度可控”。  

---

## 推荐题目  
1. [P1613 跑路](https://www.luogu.com.cn/problem/P1613)（分层图+倍增）  
2. [P4011 孤岛营救问题](https://www.luogu.com.cn/problem/P4011)（状态压缩+分层图）  
3. [P4542 捉迷藏](https://www.luogu.com.cn/problem/P4542)（时间与路径规划的线性 DP）

---
处理用时：79.31秒
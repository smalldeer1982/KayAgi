# 题目信息

# 「EZEC-1」出题

## 题目背景

你是一个毒瘤出题人。

## 题目描述

已知你有 $n$ 道毒瘤题，已经出好了题面，但数据还没出好。你还剩下 $m$ 的时间，每道题的毒瘤程度为 $a_{i}$，出数据的时间是 $x_{i}$，你有 $k$ 个老师，每个老师可以把一道题的毒瘤程度翻倍（每道题目最多被翻倍一次）。你的父母由于坚决反对你出公开赛，抢走了你的一道题，现在老师和父母的行动你都可以控制，但每位老师和父母的行为必须执行，请问你要怎么做，才能使出的题毒瘤程度之和最大？

## 说明/提示

【样例解释】

样例 $1$ ：

你控制你的父母拿走 $T1$ ，然后配 $T2$ 和 $T3$ 的数据，同时将 $T2$ 的毒瘤值翻倍，所以毒瘤值最大是 $15$

------------

【数据范围】

对于 $30\%$ 的数据，$ 0 \le x_{i} \le m $，$0 \le m \le 100 $，$2 \le n \le 10$，$ k<n$。

对于另外 $20\%$ 的数据，保证 $k=0$。

对于 $100\%$ 的数据，$0 \le a_{i} \le 1000$，$ 0 \le x_{i} \le m $，$0 \le m \le 1000 $，$0 \le n \le 100$，$ k<n$。

upd in 2020.7.6：添加一组 hack 数据。

## 样例 #1

### 输入

```
3 10 1
6 9
7 2
1 8```

### 输出

```
15```

## 样例 #2

### 输入

```
5 20 2
5 3 
9 7
2 6
7 8
1 2```

### 输出

```
38```

## 样例 #3

### 输入

```
3 6 2
5 4
3 3
3 3```

### 输出

```
12```

# AI分析结果



# 算法分析与题解总结

## 算法分类
**0-1背包**

## 核心思路与难点分析
### 核心思路
题目需要处理两个关键操作：父母必须拿走一道题，k次翻倍机会。解法分为两种情况：
1. **总时间充足（Σx_i ≤ m）**：  
   所有题目都能出数据，父母必须拿走一个题目。此时最优策略是：
   - 将题目按毒瘤值从大到小排序
   - 前k大的毒瘤值翻倍，剩下的题目中排除最小值（被父母拿走）
2. **总时间不足（Σx_i > m）**：  
   采用二维0-1背包DP，状态定义 `dp[i][j]` 表示用i时间、j次翻倍后的最大毒瘤值。转移时需倒序枚举时间和翻倍次数，避免重复计算。

### 动态规划关键点
- **状态转移方程**：  
  `dp[i][j] = max(dp[i][j], dp[i-x][j] + a, dp[i-x][j-1] + 2*a)`  
  其中`x`为当前题目时间，`a`为毒瘤值。
- **倒序枚举**：时间`i`和翻倍次数`j`均需倒序枚举，保证每个物品只被处理一次。

## 题解评分（≥4星）
1. **pigstd（★★★★☆）**  
   正确分情况处理，二维背包设计合理，代码简洁。未显式处理初始化可能影响极端情况。
2. **xiaozeyu（★★★★★）**  
   明确hack数据问题，强调倒序枚举重要性，代码鲁棒性强，解释清晰。
3. **一只书虫仔（★★★★☆）**  
   代码结构清晰，正确处理贪心与背包分支，但注释较少影响可读性。

## 最优思路提炼
1. **贪心与背包结合**：根据总时间是否充足分情况处理，极大优化复杂度。
2. **倒序枚举避免错误**：二维背包中倒序枚举时间和翻倍次数，确保状态转移正确。
3. **特殊处理翻倍次数**：将翻倍次数作为状态维度，独立处理`j=0`的情况。

## 类似题目推荐
1. **P1064 金明的预算方案**（依赖背包+多维度状态）  
2. **P1156 垃圾陷阱**（时间限制下的状态转移）  
3. **P1941 飞扬的小鸟**（多重背包与状态压缩）

---

## 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, k, sum, ans, f[1005][105], a[105], b[105];

void greedy() {
    sort(a+1, a+n+1, greater<int>());
    for(int i=1; i<=k; i++) ans += a[i] * 2;
    for(int i=k+1; i < n; i++) ans += a[i]; // 排除最小值
}

void dp() {
    for(int e=1; e<=n; e++) 
        for(int i=m; i>=b[e]; i--) {
            for(int j=min(k,e); j>=1; j--) { // 倒序枚举翻倍次数
                f[i][j] = max(f[i][j], max(f[i-b[e]][j] + a[e], f[i-b[e]][j-1] + 2*a[e]));
                ans = max(ans, f[i][j]);
            }
            f[i][0] = max(f[i][0], f[i-b[e]][0] + a[e]);
            ans = max(ans, f[i][0]);
        }
}

int main() {
    cin >> n >> m >> k;
    for(int i=1; i<=n; i++) cin >> a[i] >> b[i], sum += b[i];
    if(sum <= m) greedy();
    else dp();
    cout << ans;
    return 0;
}
```

---

## 可视化设计（复古像素风格）
1. **Canvas网格绘制**：  
   - 以16x16像素块绘制DP矩阵，每个单元格显示`dp[i][j]`的值。
   - 当前处理物品高亮为红色，已更新单元格闪烁黄色。
2. **音效设计**：  
   - 状态更新时播放8-bit "beep"音效。
   - 找到更优解时播放上升音阶。
3. **自动演示模式**：  
   - 按物品顺序自动播放，展示背包填充过程。
   - 用户可调节速度（慢/中/快）或暂停观察细节。
4. **控制面板**：  
   - 复古风格按钮，用像素字体显示"Play/Pause"、"Speed"。
   - 实时显示当前处理物品编号和剩余时间。

---

## 个人心得
- **枚举顺序的教训**：初始正序枚举翻倍次数导致同一物品多次翻倍，通过hack数据发现错误。
- **贪心陷阱**：最初未正确处理父母必须拿走一题的条件，误将总毒瘤值直接减最小项，后修正为排除最小值。

---
处理用时：88.29秒
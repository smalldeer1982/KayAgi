# 题目信息

# 「SWTR-5」Grid

## 题目背景

**赛时提醒：格子可以重复经过，但分数只算一次。**

## 题目描述

小 A 有一个 $n\times m$ 的网格，每个格子上都写着一个数字。为方便描述，令左上角的网格为 $(1,1)$，右下角的网格为 $(n,m)$。

小 A 可以进入最下方第 $n$ 行的任意一个网格，并按照以下规则进行游戏：

- 设小 A **第一次进入第 $i$ 行**的位置为 $(i,r_i)$：  
如果小 A 在 $(i,r_i)$，则他只能向左或向上跳。否则他可以向左，向右或向上跳。
- 小 A 不能跳出网格，除非他在第 $1$ 行，这代表结束整场游戏。

定义一局游戏的得分为所有小 A 经过的格子上的数字之和。小 A 想请你帮他求出得分的最小值。

## 说明/提示

「样例说明」

样例 $1$ 的解释如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/1l4pl5s2.png)

「数据范围与约定」

**本题采用捆绑测试。**

- Subtask 1（3 points）：$a_{i,j}\leq 0$。
- Subtask 2（12 points）：$n,m\leq 5$。
- Subtask 3（15 points）：$n=2$。
- Subtask 4（18 points）：$n,m\leq 90$。
- Subtask 5（22 points）：$n,m\leq 400$。
- Subtask 6（30 points）：无特殊限制。

对于 $100\%$ 的数据：$1\leq n,m\leq 10^3$，$-10^6 \leq a_{i,j}\leq 10^6$。

---

「题目来源」

[Sweet Round 05](https://www.luogu.com.cn/contest/28195) A。  
idea & solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。

## 样例 #1

### 输入

```
3 3
-1 -3 2
5 -1 -6
-3 7 -6```

### 输出

```
-17```

## 样例 #2

### 输入

```
3 3
1 2 3
4 5 -6
-7 8 9```

### 输出

```
-2```

## 样例 #3

### 输入

```
4 4
-1 2 -3 3
-7 -8 -9 -10
-7 20 -3 15
-8 7 0 -1```

### 输出

```
-32```

## 样例 #4

### 输入

```
17 17
536854 594409 871941 -388369 465282 -638502 -121382 -481711 -648747 583148 -407200 -756103 225750 685372 -952316 -115958 688880
-248927 927601 -41187 -729045 -902796 -714842 537911 -972691 646275 -968170 811593 -288461 -492905 954416 455549 839671 927565
317945 317920 -182592 -477 239886 747388 -323625 132984 -147642 637483 948110 750134 450272 -689049 862925 -327794 5865
196810 600825 -547716 873435 -389664 882011 -708186 504812 955352 -657431 -963785 -899423 671938 -770932 -428505 204660 -235382
592361 -686010 805643 -168792 871936 -334335 402655 783215 -315411 480760 371553 -87790 -111152 142452 918172 968088 364749
200836 914812 962142 -276470 757612 -369974 955746 -740349 -218873 976129 94337 -853562 69100 -479860 865764 -865684 -782689
-977548 -226536 197351 516125 137800 -391378 -392070 -954935 -399763 284345 -752733 195962 268045 800832 916405 578799 782717
-111876 -384522 785558 -663839 -346670 317823 -902413 -138975 794147 -377010 -370134 925156 333264 -827840 859848 773995 -335011
495949 -158831 446359 962836 -861756 936842 533809 -58318 -462176 561405 -127056 -497496 -636673 -312588 -354065 -489258 926614
603167 -154853 601062 951736 758952 -290610 838384 -455373 -823858 293098 782955 -711867 739231 -835281 -940599 938774 389756
-762794 -788479 -122327 -608246 998569 -70814 -198006 -361373 658973 -811815 -26348 240052 251877 -660298 -390790 558411 -90995
213545 492431 847902 -681087 -721770 -482897 -577178 -400679 712628 -943805 -613025 927604 867612 -753902 -235086 -60571 445511
901422 -769346 -655924 638444 188703 964292 865767 -298677 -245870 643123 -87216 -18374 -115040 -954311 -220506 919822 -183816
-576494 -481376 139875 360147 411997 437956 755645 874372 130352 -770235 -708813 850918 -835413 -426540 62763 722776 767682
-237305 -121638 -273740 518922 -423961 690214 -253799 571892 915095 586784 670083 -764317 14014 -103481 -750401 325979 70672
323842 988625 859616 920791 -749116 -660548 302396 408853 -944605 732263 -38368 223609 -484449 712951 831842 -200066 -965163
-659884 172567 -482821 -666287 42438 -113937 -539200 -57775 -558423 116068 532754 -440321 456398 -216316 293270 771477 583186
```

### 输出

```
-28761600```

# AI分析结果



# 算法分类选择  
**线性DP**

---

## 题解思路与算法要点  
**核心思路**：将多次往返左移的路径转化为预处理后的单次计算。动态规划的状态转移结合预处理的最小前缀和，实现 O(nm) 的时间复杂度。  

**关键步骤**：  
1. **预处理行数据**：对每行从左到右计算最小前缀和，合并连续左移的可能收益。  
2. **逆向动态规划**：从最后一行开始，自底向上逐行计算。每个格子的值由右侧或下侧的最优解转移而来。  

**解决难点**：  
- **路径复杂性**：通过预处理将左移折返的复杂路径简化为单步计算。  
- **状态转移方程**：分情况讨论当前格子是否包含负收益的左移路径，动态选择转移方向。  

---

## 题解评分 (≥4星)  
### 1. zumgze（5星）  
- **亮点**：代码简洁，预处理与 DP 结合紧密，逻辑清晰。  
- **核心代码**：  
  ```cpp
  for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
          if(a[i][j-1]<0) a[i][j] += a[i][j-1];
  for(int i=n;i>=1;i--)
      for(int j=m;j>=1;j--)
          if(a[i][j]<=0) dp[i][j] = min(dp[i][j+1], dp[i+1][j]+a[i][j]);
          else dp[i][j] = min(dp[i][j+1], dp[i+1][j]) + a[i][j];
  ```

### 2. Miraik（4星）  
- **亮点**：将问题转化为连续子段选择，利用前缀和极值优化。  
- **核心代码**：  
  ```cpp
  for(int j=1; j<=m; j++)
      qz[j] = min(qz[j-1], 0ll) + a[i][j];
  for(int j=m; j>=1; j--)
      hz[j] = min(hz[j+1], dp[i+1][j]) + a[i][j];
  ```

### 3. Wf_yjqd（4星）  
- **亮点**：分左右预处理，双数组优化转移逻辑。  
- **核心代码**：  
  ```cpp
  for(ll j=1; j<=m; j++)
      qz[j] = min(qz[j-1], 0ll) + a[i][j];
  for(ll j=m; j>=1; j--)
      hz[j] = min(hz[j+1], dp[i+1][j]) + a[i][j];
  ```

---

## 最优思路提炼  
**预处理最小前缀和**：将每行的左移收益提前计算，保证 DP 转移时只需比较右侧和下侧的最优解。例如，若某格子左移的总收益为负，则直接合并到当前格子的值中，避免动态规划时重复计算。  

**逆向 DP 设计**：从网格右下角向左上角递推，保证每个状态仅依赖已计算的子问题，避免后效性。  

---

## 类似题目  
1. **P1216 数字三角形**：基础路径选择 DP。  
2. **P1002 过河卒**：网格路径计数与动态规划。  
3. **P1434 滑雪**：网格中的最长递减路径，记忆化搜索与 DP 结合。  

---

## 可视化设计  
**动态规划矩阵更新动画**：  
1. **Canvas 网格绘制**：以像素风格绘制 n×m 网格，每个格子显示当前 DP 值和预处理后的 a[i][j] 值。  
2. **颜色标记**：  
   - **红色**：当前正在计算的格子 (i,j)。  
   - **蓝色**：转移来源（右侧和下侧）。  
   - **绿色**：已计算完成的最优值。  
3. **步进控制**：支持暂停/继续，单步观察预处理和 DP 的更新顺序。  
4. **音效**：  
   - 转移时播放“滴”声，找到更优解时播放“叮”声。  
   - 背景音乐为 8-bit 风格循环曲目。  

**复古像素效果**：  
- 使用 16 色调色板，格子边框为深灰色，数值用白色像素字体显示。  
- 更新动画时，当前格子闪烁三次，模仿经典游戏反馈。  

---

## 核心代码实现  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e3 + 5;
long long a[N][N], dp[N][N];

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
            if (a[i][j-1] < 0) a[i][j] += a[i][j-1];
        }
        dp[i][m+1] = 1e18; // 边界初始化
    }
    for (int i = n; i >= 1; i--) {
        for (int j = m; j >= 1; j--) {
            if (a[i][j] <= 0) 
                dp[i][j] = min(dp[i][j+1], dp[i+1][j] + a[i][j]);
            else 
                dp[i][j] = min(dp[i][j+1], dp[i+1][j]) + a[i][j];
        }
    }
    long long ans = 1e18;
    for (int j = 1; j <= m; j++) 
        ans = min(ans, dp[1][j]);
    cout << ans << endl;
    return 0;
}
```

---
处理用时：95.99秒
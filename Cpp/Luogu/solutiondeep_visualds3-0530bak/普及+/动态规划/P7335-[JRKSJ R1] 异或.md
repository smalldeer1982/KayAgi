# 题目信息

# [JRKSJ R1] 异或

## 题目描述

给你 $n,k$ 和序列 $a_{1,2\dots n}$，选出 $k$ 个**不交**区间 $[l_i,r_i]\subseteq[1,n]$，求出
$$\max_{l_i,r_i}\sum_{i=1}^k\bigoplus_{j=l_i}^{r_i}a_j$$

式中 $\oplus$ 表示二进制异或运算。

**保证数据随机。**

## 说明/提示

对于 $100\%$ 的数据，$1\le k\le n\le 3000$，$0\le a_i\le 10^{9}$。**保证数据随机。**

本题采用捆绑测试。

| $\text{Subtask}$ | $n\le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $30$ | $k\le3$ | $5$ |
| $2$ | $500$ | $a_i\le10^7$|  $10$ |
| $3$ | $1000$ | 无 |  $10$ |
| $4$ | $1500$ | 无 |  $15$ |
| $5$ | $2000$ | 无 |  $15$ |
| $6$ | $2500$ | 无 | $20$ |
| $7$ | $3000$ |  无|  $25$ |
#### 样例 1 解释
序列的三个区间分别为:
$$2,1,[3,4],[4],[4]$$
所得的三个区间的异或和之和为 $7+4+4=15$.

## 样例 #1

### 输入

```
6 3
2 1 3 4 4 4```

### 输出

```
15```

## 样例 #2

### 输入

```
7 2
3 4 5 6 7 8 9```

### 输出

```
24```

# AI分析结果



---

**唯一算法分类**  
线性DP

---

**综合分析与结论**  
本题核心为动态规划，结合预处理与分段优化处理随机数据特性。  

1. **核心思路**  
   - **状态设计**：`dp[i][j]`表示前i个元素选j个区间的最大异或和。  
   - **状态转移**：`dp[i][j] = max(dp[k][j-1] + mx[k+1][i])`，其中`mx`为区间最大异或值。  
   - **预处理优化**：利用前缀异或和+Trie树预处理`mx`数组，将区间异或转化为两数异或最大值。  

2. **关键难点与解决**  
   - **高效计算mx**：通过倒序插入Trie树，快速查询最大异或值，时间复杂度O(n² logV)。  
   - **分段压缩**：利用数据随机性，将连续的相同`mx`值合并为块，每个块只需计算一次贡献，降低DP转移复杂度至O(nk logn)。  

3. **可视化设计**  
   - **DP矩阵更新**：以网格展示`dp[i][j]`，高亮当前处理的`i`和`j`，颜色渐变表示值大小。  
   - **分段块标记**：用不同颜色块标记`mx`的分段区间，动态显示块内最大值如何影响状态转移。  
   - **复古像素风格**：采用8位色块，每次状态转移触发像素闪烁，音效随最大值更新播放。  

---

**题解清单 (≥4星)**  

1. **cyffff (5星)**  
   - **亮点**：详细解释预处理与分段优化，代码实现利用滚动数组和Trie树，复杂度分析严谨。  
   - **代码片段**：  
     ```cpp  
     for(int d=k-1;d;d--){  
         int s=d&1;  
         for(int l=n;l>=0;l--){  
             ll mx=0;  
             int r=1;  
             mx=ans[l][r]+dp[l][!s];  
             for(r++;r<=ans[l].len;r++){  
                 if(dp[ans[l].s[r].l][!s]+ans[l].top()<mx) break;  
                 mx=max(mx,dp[ans[l].s[r].l][!s]+ans[l][r]);  
             }  
             dp[l][s]=mx;  
         }  
     }  
     ```  

2. **hegm (4星)**  
   - **亮点**：预处理mx数组，分段处理简洁，代码易读。  
   - **代码片段**：  
     ```cpp  
     for(int j=1;j<=k;j++){  
         for(int i=1;i<=n;i++){  
             f[i][j%2]=0;  
             for(int x=1;x<=num[i];x++){  
                 f[i][j%2]=max(f[i][j%2],f[s[i][x].r][(j%2)^1]+s[i][x].w);  
             }  
         }  
     }  
     ```  

---

**最优思路/技巧提炼**  
1. **前缀异或转换**：将区间异或和转换为两数异或，利用Trie树高效查询。  
2. **分段压缩**：随机数据下`mx`值分段连续，仅处理各段最右端点以优化DP。  
3. **滚动数组**：空间优化至O(n)，避免高维数组内存问题。  

---

**同类型题推荐**  
1. **P4735** 最大异或和 - 动态维护前缀异或最大值。  
2. **P3292** [SCOI2016]幸运数字 - 线性基结合树链剖分。  
3. **P4514** 上帝造题的七分钟 - 二维区间操作与异或性质。  

---

**可视化与算法演示**  
- **动画方案**：  
  1. **网格绘制**：Canvas绘制n×k的DP网格，初始全灰。  
  2. **状态更新**：处理`dp[i][j]`时，对应格子渐变填充（绿→黄→红），数值越大颜色越深。  
  3. **分段高亮**：当转移涉及`mx`分段块时，左侧区间块闪烁蓝色边框。  
  4. **音效触发**：每次更新最大值时播放“升级”音效，滚动数组切换时播放“翻页”声。  

- **复古像素风格**：  
  - **调色板**：16色，主色调为深蓝（背景）、亮绿（当前状态）、橙黄（分段块）。  
  - **自动演示**：按帧逐步推进，用户可调节速度（1x/2x/5x），暂停后点击格子查看详细转移路径。  

---

**代码实现（核心逻辑）**  
```cpp  
// 预处理mx数组（hegm风格）  
for(int i=1;i<=n;i++){  
    for(int j=i-1,p=0;j>=0;j--){  
        p = max(p, a[i]^a[j]);  
        mx[j][i] = max(mx[j][i-1], p);  
    }  
    // 压缩分段  
    s[i][1] = {0,0,mx[0][i]};  
    int cnt=1;  
    for(int j=1;j<i;j++){  
        if(mx[j][i] != mx[j-1][i])  
            s[i][++cnt] = {j,j,mx[j][i]};  
        else  
            s[i][cnt].r = j;  
    }  
    num[i] = cnt;  
}  
```  

---

**个人心得摘录**  
- **cyffff**：调试中发现`ans`数组的压缩需严格单调，漏判条件导致WA，后通过断言检查修复。  
- **hegm**：最初未考虑滚动数组导致MLE，改为二维滚动后AC，强调空间优化的必要性。  

--- 

**推荐题目**  
1. P4735 最大异或和  
2. P3292 [SCOI2016]幸运数字  
3. P4514 上帝造题的七分钟

---
处理用时：100.80秒
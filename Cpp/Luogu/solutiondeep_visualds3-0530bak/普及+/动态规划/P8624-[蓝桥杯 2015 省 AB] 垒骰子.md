# 题目信息

# [蓝桥杯 2015 省 AB] 垒骰子

## 题目描述

赌圣 atm 晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。

经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！

我们先来规范一下骰子：$1$ 的对面是 $4$，$2$ 的对面是 $5$，$3$ 的对面是 $6$。

假设有 $m$ 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。

atm 想计算一下有多少种不同的可能的垒骰子方式。

两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。

由于方案数可能过多，请输出模 $10^9+7$ 的结果。

不要小看了 atm 的骰子数量哦～。

## 说明/提示

对于 $30\%$ 的数据：$n \le 5$。

对于 $60\%$ 的数据：$n \le 100$。

对于 $100\%$ 的数据：$0<n \le 10^9,m \le 36$。

时限 2 秒, 256M

蓝桥杯 2015 年省赛 AB 组 I 题。

## 样例 #1

### 输入

```
2 1
1 2
```

### 输出

```
544```

# AI分析结果



# 算法分类：线性DP（矩阵快速幂优化）

## 题解思路与难点对比

### 核心思路
1. **动态规划建模**：  
   定义状态 `f[i][j]` 表示第 `i` 个骰子朝上面为 `j` 的方案数。状态转移方程为：  
   $$ f[i][j] = \sum_{k=1}^6 f[i-1][k] \times 4 \times \text{valid}(k, \text{oppo}(j)) $$  
   其中 `valid(k, x)` 表示骰子 `k` 的底面是否允许与当前骰子的底面 `x` 接触（不排斥）。

2. **矩阵快速幂优化**：  
   将状态转移转化为矩阵乘法形式，构造转移矩阵 `A`，其中 `A[i][j]` 表示从状态 `i` 转移到 `j` 的系数（考虑排斥关系和旋转方案数 4）。最终结果为初始向量与 `A^{n-1}` 的乘积。

3. **对立面处理**：  
   使用 `oppo` 数组（如 `oppo[1] = 4`）快速查询骰子对立面。

### 解决难点
- **排斥关系的矩阵表示**：需将排斥关系映射到转移矩阵中，若 `k` 与 `oppo(j)` 排斥，则 `A[k][j] = 0`，否则 `A[k][j] = 4`。
- **时间复杂度优化**：直接递推复杂度为 `O(n)`，无法处理 `n ≤ 1e9`，矩阵快速幂将复杂度优化至 `O(6^3 \log n)`。

---

## 题解评分（≥4星）

### 1. 作者：Meickol（★★★★★）
- **亮点**：  
  - 分步骤讲解思路，图文结合解释转移方程。  
  - 代码清晰，矩阵乘法和快速幂实现规范。  
  - 初始状态和转移矩阵构建逻辑明确。

### 2. 作者：行吟啸九州（★★★★☆）
- **亮点**：  
  - 使用函数计算对立面，代码简洁。  
  - 快速幂部分采用模板化实现，易于复用。  
  - 初始矩阵直接设为行向量，优化计算。

### 3. 作者：naroto2022（★★★★☆）
- **亮点**：  
  - 显式将排斥关系处理为矩阵元素置零。  
  - 代码中独立处理 `4^n` 的快速幂，逻辑分离清晰。

---

## 最优思路与技巧提炼

### 关键技巧
1. **矩阵维度压缩**：  
   将 `f[i][j]` 的 6 种状态压缩为向量，矩阵乘法直接表示状态转移。

2. **对立面预处理**：  
   ```cpp
   int oppo[7] = {0, 4, 5, 6, 1, 2, 3}; // j的对面为oppo[j]
   ```

3. **转移矩阵构造**：  
   ```cpp
   for (int i=1; i<=6; i++) {
       for (int j=1; j<=6; j++) {
           if (st[i][oppo[j]]) A[i][j] = 0; // 排斥则不可转移
           else A[i][j] = 4;                 // 否则有4种旋转方案
       }
   }
   ```

---

## 同类题目推荐
1. **P1939 【模板】矩阵加速（数列）**  
   - 矩阵快速幂求线性递推数列。

2. **P1397 [NOI2013] 矩阵游戏**  
   - 大规模递推问题，矩阵快速幂优化。

3. **P4910 帕秋莉的手环**  
   - 环形排列问题，结合矩阵快速幂和动态规划。

---

## 代码片段（核心逻辑）

### 矩阵乘法与快速幂
```cpp
struct Matrix {
    ll c[7][7];
    Matrix() { memset(c, 0, sizeof c); }
};

Matrix operator*(const Matrix &a, const Matrix &b) {
    Matrix res;
    for (int i=1; i<=6; i++)
        for (int j=1; j<=6; j++)
            for (int k=1; k<=6; k++)
                res.c[i][j] = (res.c[i][j] + a.c[i][k] * b.c[k][j]) % mod;
    return res;
}

Matrix fast_pow(Matrix A, int k) {
    Matrix res;
    for (int i=1; i<=6; i++) res.c[i][i] = 1; // 单位矩阵
    while (k) {
        if (k & 1) res = res * A;
        A = A * A;
        k >>= 1;
    }
    return res;
}
```

---

## 可视化设计（核心DP过程）

### 动画演示方案
1. **矩阵更新高亮**：  
   - 在 Canvas 网格中，当前计算的矩阵元素 `(i, j)` 高亮为黄色，乘积累加过程显示为绿色流动效果。

2. **音效提示**：  
   - 状态转移时播放 `8-bit` 短音效，矩阵幂次完成时播放升级音效。

3. **复古像素风格**：  
   - 使用 `16色` 调色板，矩阵元素用 `16x16` 像素块表示，转移箭头用红色像素绘制。

### 交互设计
- **步进控制**：支持暂停/继续、单步执行、调整动画速度。  
- **自动演示**：AI 模式自动播放矩阵快速幂的二分幂过程。

---

## 个人心得摘录
> **调试经验**：  
> - 初始忘记处理双向排斥（如 `a` 排斥 `b` 需同时标记 `b` 排斥 `a`）。  
> - 矩阵乘法循环顺序错误（i-k-j 而非 i-j-k）导致计算错误。  
>  
> **优化感悟**：  
> - 将 `4^n` 分离为独立快速幂，避免在矩阵中重复计算。

---
处理用时：92.19秒
# 题目信息

# [蓝桥杯 2022 国 B] 费用报销

## 题目描述

小明在出差结束后返回了公司所在的城市，在填写差旅报销申请时，粗心的小明发现自己弄丢了出差过程中的票据。

为了弥补小明的损失，公司同意小明用别的票据进行报销，但是公司财务要求小明提交的票据中任意两张的日期差不小于 $K$ 天，且总金额不得超过实际差旅费用 $M$。

比如财务要求 $K=7$ 时，若小明提交了一张 1 月 8 日的票据，小明就不能提交 1 月 2 日至 1 月 14 日之间的其他票据，1 月 1 日及之前和 1 月 15 日及之后的票据则可以提交。

公司的同事们一起给小明凑了 $N$ 张票据，小明现在想要请你帮他整理一下，从中选取出符合财务要求的票据, 并使总金额尽可能接近 $M$ 。

需要注意，由于这些票据都是同一年的，因此 12 月底的票据不会影响到 1 月初票据的提交。这一年不是闰年。

## 说明/提示

**【样例说明】**

选择 1 月 3 日和 1 月 6 日的票据

**【评测用例规模与约定】**

对于 $100 \%$ 的评测用例, $1 \leq N \leq 1000,1 \leq M \leq 5000,1 \leq K \leq 50,1 \leq m_{i} \leq$ $12,1 \leq d_{i} \leq 31,1 \leq v_{i} \leq 400$

日期保证合法。 


蓝桥杯 2022 国赛 B 组 F 题。

## 样例 #1

### 输入

```
4 16 3
1 1 1
1 3 2
1 4 4
1 6 8```

### 输出

```
10```

# AI分析结果



1. **唯一算法分类**  
   **0-1背包**

---

### 综合分析与结论  
**核心思路**：将票据按时间排序后预处理每个票据的「前驱票据」位置（满足日期差 ≥ K），构建 0-1 背包模型，通过动态规划求解最大价值。  
**解决难点**：通过预处理 `lst[i]`（第 i 个票据前最近可选的合法票据）将时间约束融入背包模型，转移方程：  
$$f_{i,j} = \max(f_{i-1,j}, \ f_{lst[i],j-v_i} + v_i)$$  
**数据结构**：使用二维数组 `f[i][j]` 表示前 i 个票据总金额为 j 时的最大价值，`lst[i]` 数组辅助快速定位合法前驱。

---

### 题解清单 (≥4星)  
| 题解作者 | 星级 | 核心亮点 |  
|---------|------|---------|  
| Nwayy    | ⭐⭐⭐⭐ | 双解法对比，DP 状态转移清晰，代码可读性高 |  
| KawaragiMomoka | ⭐⭐⭐⭐ | 详细解释日期转换和 `last` 数组预处理，代码结构规范 |  
| 0x282e202e2029 | ⭐⭐⭐⭐ | 完整状态设计解释，强调初始化细节（f[0][0]=-INF）|  

---

### 最优思路提炼  
**关键技巧**：  
1. **时间转天数**：用前缀和数组将月份日期转换为统一天数  
2. **前驱预处理**：对排序后的票据，向前遍历找到第一个满足日期差条件的 `lst[i]`  
3. **背包融合条件**：通过 `lst[i]` 将时间约束转化为背包转移限制，保持 O(nm) 复杂度  
4. **逆向滚动优化**：倒序枚举金额维度，实现空间压缩  

**思维模型**：  
```
排序票据 → 预处理前驱 → 背包式状态转移 → 逆向找最大合法值
```

---

### 同类型题推荐  
1. **P1064 金明的预算方案**（带依赖关系的背包）  
2. **P1156 垃圾陷阱**（时间+高度双约束 DP）  
3. **P1941 飞扬的小鸟**（动态跳跃与障碍物约束）  

---

### 个人心得摘录  
> "WA 的教训：DP 注意初始化！将 `f[0][0]` 设为负无穷，避免首次选票据时错误判定日期差" —— Wing_  
> "看似是背包，实则是带时间约束的序列选择问题，排序和预处理是破题关键" —— Delete_error  

---

### 可视化与算法演示  
**DP 动画设计**：  
- **网格展示**：Canvas 绘制 n×m 的网格，横轴为金额（0~M），纵轴为票据编号  
- **颜色标记**：  
  - 红色高亮：当前处理的票据 i 对应的行  
  - 绿色闪烁：`lst[i]` 对应的前驱行  
  - 黄色填充：状态转移路径（从 `lst[i]` 到 i 的转移）  
- **音效反馈**：  
  - "滴"声：每次更新 `f[i][j]`  
  - "叮咚"声：发现更优解时触发  

**复古像素风格实现**：  
```javascript
// Canvas 初始化（伪代码）
const canvas = document.getElementById('dp-grid');
ctx.fillStyle = '#8B8B83'; // 灰色背景
ctx.fillRect(0, 0, width, height);

// 绘制 DP 网格
for (let i=0; i<=n; i++) {
  for (let j=0; j<=m; j++) {
    if (f[i][j] > 0) {
      ctx.fillStyle = '#FFD700'; // 金色填充有效状态
      ctx.fillRect(j*cellW, i*cellH, cellW-1, cellH-1);
    }
  }
}
```

---

### 核心代码实现  
```cpp
// 日期预处理（KawaragiMomoka 题解核心片段）
const int month[13] = {0,31,59,90,120,151,181,212,243,273,304,334,365};
for (int i=1; i<=n; i++) {
    int mon, d, v;
    scanf("%d%d%d", &mon, &d, &v);
    bills[i].date = month[mon-1] + d;
}

// DP 转移（Nwayy 题解核心片段）
sort(d+1, d+1+n, cmp); // 按时间排序
for (int i=1; i<=n; i++) {
    for (int j=m; j>=d[i].v; j--) {
        f[i][j] = max(f[i-1][j], f[lst[i]][j-d[i].v] + d[i].v);
    }
}
```

---

### 算法扩展思考  
若数据范围扩大至 N=1e4，M=1e5，可通过二分优化 `lst[i]` 的查找，将预处理复杂度从 O(n²) 降至 O(n logn)，保持整体 O(nm) 的可行性。

---
处理用时：84.57秒
# 题目信息

# [蓝桥杯 2022 国 B] 搬砖

## 题目描述

这天，小明在搬砖。

他一共有 $n$ 块砖，他发现第 $i$ 砖的重量为 $w_{i}$，价值为 $v_{i}$。他突然想从这些砖中选一些出来从下到上堆成一座塔，并且对于塔中的每一块砖来说，它上面所有砖的重量和不能超过它自身的价值。

他想知道这样堆成的塔的总价值（即塔中所有砖块的价值和）最大是多少。


## 说明/提示

**【样例说明】**

选择第 $1$、$2$、$4$ 块砖，从上到下按照 $2$、$1$、$4$ 的顺序堆成一座塔，总价值为 $4+1+5=10$。

**【评测用例规模与约定】**

对于 $20 \%$ 的数据，保证 $n \leq 10$;

对于 $100 \%$ 的数据，保证 $n \leq 1000 ; w_{i} \leq 20 ; v_{i} \leq 20000$ 。

蓝桥杯 2022 国赛 B 组 J 题。

## 样例 #1

### 输入

```
5
4 4
1 1
5 2
5 5
4 3```

### 输出

```
10```

# AI分析结果



---

### 算法分类  
**0-1 背包**

---

### 题解思路与核心难点解析  

#### 核心思路  
本题结合贪心策略与 0-1 背包动态规划，核心为：  
1. **排序策略**：将砖块按 `w_i + v_i` 升序排列，确保后续动态规划转移时的约束条件能被满足。  
2. **受限 0-1 背包**：对每个砖块，仅在 `j ∈ [w_i, w_i + v_i]` 范围内逆序更新背包状态，保证所选砖块的 `v_i ≥ 上方总重量`。  

#### 解决难点  
- **正确排序的数学证明**：需证明排序后任意两砖块 `i, j` 满足 `i 在前时更优`，确保最优解可通过排序后的序列构造。  
- **动态规划状态设计**：`dp[j]` 表示总重量为 `j` 时的最大价值，转移时需满足 `j - w_i ≤ v_i`（即上方总重量不超过当前砖的承重）。  

#### 算法实现要点  
- **排序函数**：`sort(a+1, a+n+1, cmp)`，其中 `cmp` 比较 `w_i + v_i`。  
- **状态转移方程**：  
  ```cpp  
  for (int j = a[i].w + a[i].v; j >= a[i].w; j--)  
      dp[j] = max(dp[j], dp[j - a[i].w] + a[i].v);  
  ```  
- **滚动数组优化**：逆序遍历避免状态覆盖。

---

### 题解评分（≥4星）  

1. **lottle1212（4.5⭐）**  
   - 亮点：代码简洁，注释清晰，直接体现排序与背包核心逻辑。  
   - 代码片段：  
     ```cpp  
     for (int i = 1; i <= n; ++i)  
         for (int j = a[i].w + a[i].v; j >= a[i].w; --j)  
             dp[j] = max(dp[j], dp[j - a[i].w] + a[i].v);  
     ```  

2. **王熙文（4⭐）**  
   - 亮点：数学证明严谨，初始化 `dp` 为负无穷避免边界问题。  
   - 代码片段：  
     ```cpp  
     memset(dp, -0x3f, sizeof(dp));  
     dp[0] = 0;  // 初始化合法状态  
     ```  

3. **small_lemon_qwq（4⭐）**  
   - 亮点：直观对比两砖块优劣，代码附带详细注释。  

---

### 最优技巧提炼  
1. **贪心排序**：通过 `w_i + v_i` 升序，确保后续背包转移的约束条件自洽。  
2. **受限背包范围**：转移时限制 `j ∈ [w_i, w_i + v_i]`，将砖块承重约束隐式融入状态更新。  
3. **滚动数组优化**：逆序更新避免状态覆盖，空间复杂度降至 `O(V)`。  

---

### 同类型题推荐  
1. **P1064 金明的预算方案**（依赖分组背包）  
2. **P1156 垃圾陷阱**（时间约束下的背包问题）  
3. **P1417 烹调方案**（需排序的 0-1 背包）  

---

### 个人心得摘录  
- **调试教训**：直接套用标准 0-1 背包会忽略承重约束，需结合排序策略。  
- **顿悟瞬间**：样例分析中发现 `w_i + v_i` 的排序规律是解题突破口。  

---

### 动态规划可视化设计  

#### 动画方案  
1. **像素风格界面**：  
   - 使用 8-bit 像素画风，`dp` 数组以网格形式展示，每个单元格表示总重量 `j` 对应的最大价值。  
   - 颜色编码：已更新单元格高亮为绿色，当前操作单元格为红色，未更新区域为灰色。  

2. **状态更新演示**：  
   - **步骤 1**：展示排序后的砖块列表（右侧面板）。  
   - **步骤 2**：逐个处理砖块，在 `j ∈ [w_i, w_i + v_i]` 范围内逆序更新 `dp[j]`。  
   - **步骤 3**：当 `dp[j]` 被更新时，触发像素闪烁效果，并播放短促音效（类似 FC 游戏中的得分音）。  

3. **交互功能**：  
   - **速度调节**：滑动条控制动画速度（0.5x~5x）。  
   - **单步执行**：允许用户逐砖块、逐重量值观察更新过程。  
   - **对比模式**：左右分屏展示未排序与排序后的背包更新差异。  

#### 核心代码片段（伪代码）  
```javascript  
// 初始化 Canvas 网格  
drawGrid(dp) {  
    for (let j = 0; j <= maxV; j++) {  
        ctx.fillStyle = getColor(dp[j]);  
        ctx.fillRect(j * cellSize, 0, cellSize, cellSize);  
    }  
}  

// 更新动画帧  
function animateStep(i, j) {  
    highlightBrick(i);  // 高亮当前砖块  
    flashCell(j);       // 闪烁当前更新单元格  
    playSound('update');  
    updateDP(j, dp[j]); // 更新网格显示  
}  
```  

#### 音效设计  
- **状态更新**：短促“滴”声（8-bit 合成音）。  
- **最优解更新**：上扬音调（类似金币收集音效）。  
- **背景音乐**：FC 风格循环旋律（低音量避免干扰）。  

---

通过此可视化设计，学习者可直观理解排序对动态规划的影响，并观察约束条件如何限制背包转移范围。

---
处理用时：119.37秒
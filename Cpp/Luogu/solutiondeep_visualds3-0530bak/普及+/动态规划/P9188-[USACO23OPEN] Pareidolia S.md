# 题目信息

# [USACO23OPEN] Pareidolia S

## 题目描述

### 题目背景

**注意：本题的时间限制为 4 秒，是默认时间限制的 2 倍。**

Pareidolia 是一种现象，指的是人们倾向于在并不真正存在的地方看到熟悉的图案——例如在云中看到一张脸。可以想象，由于农夫 John 经常与奶牛接触，他常常在日常物品中看到与奶牛相关的图案。例如，如果他看到字符串 "bqessiyexbesszieb"，农夫 John 的眼睛会忽略其中的一些字母，而他看到的只是 "bessiebessie"。


给定一个字符串 $s$，令 $B(s)$ 表示通过删除 $s$ 中的零个或多个字符后，能够形成的 "bessie" 的最大重复次数。在上面的例子中，$B(\text{``bqessiyexbesszieb"}) = 2$。

计算 $B(s)$ 是一个有趣的挑战，但农夫 John 对解决一个更有趣的挑战感兴趣：给定一个长度不超过 $3 \cdot 10^5$ 的字符串 $t$，且仅由字符 a-z 组成，计算所有连续子串 $s$ 的 $B(s)$ 之和。

## 说明/提示

对于第一个样例，有 12 个子串恰好包含 $1$ 个 "bessie"，有 $1$ 个子串恰好包含 $2$ 个 "bessie"，因此总数为 $12 \cdot 1 + 1 \cdot 2 = 14$。

- 输入 3-5：字符串长度不超过 $5000$。
- 输入 6-12：没有额外限制。

## 样例 #1

### 输入

```
bessiebessie
```

### 输出

```
14
```

## 样例 #2

### 输入

```
abcdefghssijebessie
```

### 输出

```
28
```

# AI分析结果



## 算法分类  
**线性DP**  

---

## 题解思路与解决难点  

### 核心思路  
所有题解均采用线性动态规划方法，核心逻辑为：  
1. **状态定义**：`dp[i]` 表示以第 `i` 个字符结尾的所有子串的 `B(s)` 之和。  
2. **状态转移**：找到离 `i` 最近的完整 `bessie` 的起始位置 `j`，转移方程为 `dp[i] = dp[j-1] + j`。其中 `j` 表示最后一个 `bessie` 的 `b` 的位置。  
3. **辅助数组**：维护 `f[7]` 或类似结构，记录 `bessie` 各字符的最新位置，用于快速确定 `j`。  

### 解决难点  
1. **高效定位 `j`**：通过维护 `f[1]~f[6]`，逐步更新 `bessie` 各字符的最近位置。例如：  
   - 遇到 `b` 时更新 `f[1] = i`。  
   - 遇到 `e` 时更新 `f[2] = f[1]`（匹配 `be`）和 `f[6] = f[5]`（匹配完整的 `bessie`）。  
2. **贡献累加**：每个 `bessie` 对答案的贡献为 `j`，即所有以 `[1, j]` 为起点、`i` 为终点的子串均包含此 `bessie`。  

---

## 题解评分（≥4星）  

1. **Nuyoah_awa（4.5星）**  
   - **亮点**：代码简洁，状态转移清晰，直接通过 `f[6]` 快速获取 `j`。  
   - **代码片段**：  
     ```cpp  
     if(s[i] == 'e') f[6] = f[5], f[2] = f[1];  
     dp[i] = dp[f[6] - 1] + f[6];  
     ```  

2. **ylch（4星）**  
   - **亮点**：详细解释求和顺序转换，强调通过单次遍历计算贡献。  
   - **关键说明**：“改变求和符号的顺序”将复杂度降至线性。  

3. **DengDuck（4星）**  
   - **亮点**：对 `lst` 数组的维护过程进行分步拆解，适合初学者理解。  
   - **代码片段**：  
     ```cpp  
     if(c[i] == 's') lst[4] = lst[3], lst[3] = lst[2];  
     ```  

---

## 最优思路提炼  
1. **状态数组维护**：通过 `f[1]~f[6]` 跟踪 `bessie` 各字符的最新位置，保证 `O(1)` 时间定位完整子序列。  
2. **贡献拆分**：每个 `bessie` 的贡献分为两部分：之前已统计的贡献 `dp[j-1]` 和新增的 `j` 个起点。  

---

## 类似题目推荐  
1. [LeetCode 115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)  
2. [LeetCode 467. 环绕字符串中唯一的子字符串](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/)  
3. [洛谷 P2679 子串](https://www.luogu.com.cn/problem/P2679)  

---

## 可视化与算法演示  

### 动画方案  
1. **动态网格展示**：  
   - 绘制字符串字符序列，高亮当前处理的字符。  
   - 右侧显示 `f[1]~f[6]` 的实时值，颜色标记变化元素。  
   - 下方展示 `dp` 数组的更新过程，用箭头表示 `dp[i] = dp[j-1] + j`。  

2. **复古像素风格**：  
   - **颜色方案**：8-bit 色调，`b` 用蓝色，`e` 用绿色，`s` 用黄色，`i` 用红色。  
   - **音效触发**：  
     - `b`：低音“哔”；`e`：高音“嘀”；完整 `bessie`：胜利音效。  
   - **自动演示**：按字符顺序自动播放，展示 `f` 和 `dp` 更新。  

### 交互设计  
- **步进控制**：允许暂停/继续，调整动画速度。  
- **状态对比**：并行展示不同题解的 `f` 数组更新逻辑。  

---

## 代码实现  
```cpp  
#include <bits/stdc++.h>  
#define int long long  
using namespace std;  
const int N = 3e5 + 5;  

int f[7], dp[N], ans;  
string s;  

signed main() {  
    cin >> s;  
    s = "#" + s;  
    for (int i = 1; i < s.size(); i++) {  
        if (s[i] == 'b') f[1] = i;  
        else if (s[i] == 'e') f[6] = f[5], f[2] = f[1];  
        else if (s[i] == 's') f[4] = f[3], f[3] = f[2];  
        else if (s[i] == 'i') f[5] = f[4];  
        dp[i] = f[6] ? (dp[f[6] - 1] + f[6]) : 0;  
        ans += dp[i];  
    }  
    cout << ans;  
    return 0;  
}  
```  

--- 

## 个人心得摘录  
- **调试关键**：确保 `f[6]` 仅在完整 `bessie` 出现时更新，避免无效累加。  
- **优化启示**：将问题转化为单次遍历，避免枚举所有子串，是线性时间的关键。

---
处理用时：90.44秒
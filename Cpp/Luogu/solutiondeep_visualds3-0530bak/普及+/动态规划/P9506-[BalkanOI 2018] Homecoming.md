# 题目信息

# [BalkanOI 2018] Homecoming

## 题目背景

翻译自 BalkanOI 2018 Day1 T2「Homecoming」；由于洛谷远慢于 loj，因此将时间限制从 300ms 调整至 500ms。

## 题目描述

有 $N$ 门课程，分别编号为 $0$ 到 $N-1$。如果你 pass 了课程 $i$，你可以拿到 $A _ i$ 美刀。  
有 $N$ 本教材，分别编号为 $0$ 到 $N-1$。$i$ 号教材的价格为 $B _ i$ 美刀。  
如果你要 pass 课程 $i$，你需要购买编号为 $i, (i+1) \bmod N, (i+2) \bmod N, \cdots, (i+K-1) \bmod N$ 的课本。$K$ 为给定的常数。  
你的目的是赚钱而非 pass 所有课程。请求出你最多能赚多少美刀。

## 交互过程

本题只支持 C++ 语言使用函数交互测评。**选手代码不需要也不能包含 `homecoming.h`，也不需要实现 `main` 函数。**

选手程序需要实现如下函数：

```
long long int solve(int N, int K, int *A, int *B);
```

在一次运行中这个函数可能会被调用多次。


## 样例

调用

```
solve(3, 2,
[40, 80, 100],
[140, 0, 20])
```

的返回值为 $60$。



## 说明/提示

### 数据范围及限制

令所有对 `solve` 函数的调用中 $N$ 的总和为 $S_N$，$NK$ 的总和为 $S_{NK}$。那么：

- $1\le K\le N\le 2\times 10^6$
- $1\le S_N\le 2\times 10^6$
- $0\le A_i,B_i\le 10^9$

详细子任务及附加限制如下表所示。

| 子任务编号 | 附加限制 | 分值 |
| :-----------: | :-----------: | :-----------: |
| $1$ | $1\le S_N\le 500$ | $13$ |
| $2$ | $1\le S_N\le 5000$ | $18$ |
| $3$ | $1\le S_{NK}\le 2\times 10^6$ | $31$ |
| $4$ | 无附加限制 | $38$ |

# AI分析结果



---

### 唯一算法分类  
**线性DP**

---

### 综合分析与结论  
本题核心在于利用动态规划处理环形结构的最优决策问题，核心难点在于避免环形结构导致的重复购买教材。各题解均采用**断环成链 + 两次线性DP**的思路，分别处理是否选择第一个课程的情况，确保覆盖所有可能性。关键点如下：  

1. **状态定义**  
   - `dp[i]` 表示处理到第 `i` 个课程时的最大利润。  
   - `maxx[i]` 维护前 `i-1` 个 `dp` 值的最大值，用于快速转移。  

2. **转移方程**  
   - 从 `dp[i-1]` 转移：已购买 `i+K-1` 的前置教材，只需扣除当前教材费用。  
   - 从 `maxx[i-1]` 转移：未购买前置区间，需扣除整个 `i` 对应区间的教材费用。  
   - 方程形式：  
     ```cpp  
     dp[i] = max(dp[i-1] - b[i+K-1], maxx[i-1] - sum(i, i+K-1)) + a[i]  
     ```  

3. **环形处理**  
   - 将数组复制为双倍长度模拟环形结构。  
   - 两次独立 DP：第一次强制选择第一个课程，第二次不选择。  

4. **优化手段**  
   - 前缀和数组 `sum` 快速计算区间教材总费用。  
   - 维护 `maxx` 数组避免每次遍历历史状态，保证时间复杂度为 O(N)。  

**可视化设计思路**  
- **动态更新网格**：以双倍链为横轴，`dp` 值为纵轴，用颜色渐变表示利润高低。  
- **高亮转移路径**：红色标记从 `dp[i-1]` 转移的路径，蓝色标记从 `maxx[i-1]` 的路径。  
- **环形边界动画**：在双倍链末端添加闪烁箭头，提示可能回到链首的环形逻辑。  
- **复古像素风格**：用 8-bit 风格网格，每个格子显示 `dp[i]` 值，转移时播放经典音效。  

---

### 题解清单（≥4星）  
1. **Zhao_daodao（4.5星）**  
   - **亮点**：明确分离两种转移逻辑，理论推导清晰。  
   - **心路引用**：“正确性：如果买一部分课程，那么最优解一定可以全部不买。”  

2. **cyngugugu（4.0星）**  
   - **亮点**：代码注释详细，处理环形边界时逻辑明确。  
   - **代码技巧**：两次独立 DP 覆盖所有情况，避免复杂环形处理。  

3. **liangbowen（4.0星）**  
   - **亮点**：强调断环成链的必要性，提供完整代码实现。  

---

### 核心代码实现  
```cpp  
long long int solve(int N, int K, int *A, int *B) {  
    ll ans = 0;  
    // 断环成链，复制数组  
    for (int i = 1; i <= 2*N; i++) {  
        a[i] = A[(i-1) % N];  
        b[i] = B[(i-1) % N];  
        sum[i] = sum[i-1] + b[i];  
    }  

    // 第一次 DP：强制选第一个课程  
    f[1] = a[1] - sum[K];  
    for (int i = 2; i <= N; i++) {  
        if (i+K-1 <= N) {  
            f[i] = max(f[i-1] - b[i+K-1], maxx[i-1] - (sum[i+K-1] - sum[i-1])) + a[i];  
        } else {  
            // 处理环形边界  
            f[i] = max(f[i-1], maxx[i-1] - (sum[N] - sum[i-1])) + a[i];  
        }  
        maxx[i] = max(maxx[i-1], f[i-1]);  
    }  

    // 第二次 DP：不选第一个课程  
    // ... 类似逻辑省略 ...  

    return ans;  
}  
```  

---

### 同类型题与相似套路  
- **环形DP通用解法**：断环成链 + 多次独立DP覆盖所有可能起点。  
- **区间费用优化**：前缀和加速区间计算，维护历史最大值避免重复遍历。  

**推荐题目**  
1. [P6064] SP283 Naptime（环形DP）  
2. [P3959] 宝藏（状压DP + 环形处理）  
3. [P2513] 逆序对数列（线性DP + 前缀和优化）  

---

### 个人心得摘录  
- **调试教训**：直接断环成链会忽略跨越链末端的循环购买，必须分类讨论起点。  
- **顿悟时刻**：“两次DP分别处理选与不选第一个课程，即可覆盖所有环形可能性。”  

---

### 复古游戏化动画设计  
1. **像素网格**：Canvas 绘制 16x16 像素的格子，绿色表示利润，红色表示教材费用。  
2. **音效设计**：  
   - `dp` 更新时播放“金币声”（8-bit 短促音）。  
   - 切换 DP 阶段时播放“关卡通过”音效。  
3. **AI自动模式**：自动高亮当前转移来源，步进速度可调，支持暂停观察 `maxx` 数组变化。  
4. **积分系统**：每正确转移一次得10分，最优解达成时播放胜利音乐。  

**代码片段（伪代码）**  
```javascript  
// 初始化像素网格  
const grid = new PixelGrid(2*N, 1, {palette: '8-bit'});  

// 更新 dp[i] 时触发动画  
function animateDP(i, source) {  
    grid.highlightCell(i, 0, 'yellow');  
    playSound('beep');  
    if (source === 'prev') {  
        grid.drawArrow(i-1, 0, i, 0, 'red');  
    } else {  
        grid.drawArrow(maxxPos, 0, i, 0, 'blue');  
    }  
}  
```

---
处理用时：83.38秒
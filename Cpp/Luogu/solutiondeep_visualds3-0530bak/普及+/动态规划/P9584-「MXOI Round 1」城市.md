# 题目信息

# 「MXOI Round 1」城市

## 题目描述

小 C 是 F 国的总统，尽管这个国家仅存在于网络游戏中，但他确实是这个国家的总统。

F 国由 $n$ 个城市构成，这 $n$ 个城市之间由 $n-1$ 条双向道路互相连接。保证从任意一个城市出发，都能通过这 $n-1$ 条双向道路，到达任意一个城市。

当然，通过这些双向道路是要收费的。通过第 $i$ 条双向道路，需要花费 $c_i$ 元。我们称 $c_i$ 为第 $i$ 条双向道路的费用。

我们定义 $cost(x,y)$ 表示从城市 $x$ 到城市 $y$ 的简单路径上，所有经过的双向道路的费用之和。特殊地，当 $x=y$ 时，$cost(x,y)=0$。

为了促进 F 国发展，小 C 新建了一个城市 $n+1$。现在他需要再新建一条双向道路，使得城市 $n+1$ 也可以通过这 $n$ 条双向道路到达任意一个城市。

他共有 $q$ 个新建道路的方案，每个方案会给定两个参数 $k_i,w_i$；对于每一个方案，你需要求出在新建一条连接城市 $k_i$ 和城市 $n+1$ 且费用为 $w_i$ 的双向道路后，所有 $cost(i,j)$ 之和，即 $\sum\limits_{i=1}^{n+1} \sum\limits_{j=1}^{n+1} cost(i,j)$。

由于答案可能很大，所以你只需要输出答案对 $998244353$ 取模的结果。

**方案之间相互独立**，也就是说所有方案不会影响现有的道路，这些方案不会真正被施行。

## 说明/提示

#### 【样例解释 #1】

在新建一条连接城市 $1$ 和城市 $5$ 且费用为 $2$ 的双向道路后，F 国的道路如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/j871257i.png)

例如，此时 $cost(4,5)=9$，$cost(1,3)=5$。

容易求得此时 $\sum\limits_{i=1}^{n+1} \sum\limits_{j=1}^{n+1} cost(i,j)=100$。

#### 【样例 #3】

见附加文件中的 `city/city3.in` 与 `city/city3.ans`。

该样例满足测试点 $4$ 的限制。

#### 【样例 #4】

见附加文件中的 `city/city4.in` 与 `city/city4.ans`。

该样例满足测试点 $11$ 的限制。

#### 【样例 #5】

见附加文件中的 `city/city5.in` 与 `city/city5.ans`。

该样例满足测试点 $14$ 的限制。

#### 【样例 #6】

见附加文件中的 `city/city6.in` 与 `city/city6.ans`。

该样例满足测试点 $20$ 的限制。

#### 【数据范围】

对于 $100\%$ 的数据，$2 \le n \le 2\times10^5$，$1 \le q \le 2\times10^5$，$1 \le u_i,v_i,k_i \le n$，$1 \le c_i,w_i \le 10^6$，保证从任意一个城市出发，都能通过原本存在的 $n-1$ 条双向道路，到达任意一个城市。

|测试点编号|$n \le$|$q \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1\sim3$|$80$|$80$|无|
|$4\sim7$|$5000$|$5000$|无|
|$8\sim10$|$5000$|$2\times10^5$|无|
|$11\sim13$|$2\times10^5$|$2\times10^5$|A|
|$14\sim16$|$2\times10^5$|$2\times10^5$|B|
|$17\sim20$|$2\times10^5$|$2\times10^5$|无|

特殊性质 A：保证对于所有的 $1 \le i \lt n$，都有 $u_i=i,v_i=i+1$。

特殊性质 B：保证对于所有的 $1 \le i \le q$，都有 $k_i=1$。

## 样例 #1

### 输入

```
4 2
2 1 3
3 2 2
4 2 4
1 2
2 2```

### 输出

```
100
88```

## 样例 #2

### 输入

```
9 5
2 3 6
6 1 4
5 2 10
2 4 1
9 1 9
2 8 3
1 2 3
7 4 8
4 9
7 3
6 1
9 7
2 1
```

### 输出

```
1050
1054
970
1148
896```

# AI分析结果



**唯一算法分类**  
无算法分类（核心为换根DP）

---

### **综合分析与结论**

#### **题解思路与算法要点**
- **核心思路**：通过两次 DFS 预处理每个节点到所有其他节点的距离和（换根DP），利用动态规划思想将单次查询复杂度降至 O(1)
- **状态转移方程**：  
  ```cpp
  dp[v] = dp[u] + w * (n - 2 * sz[v])
  ```
  - `sz[v]` 为以 v 为根的子树大小
  - `w` 为边权，表示从父节点 u 到子节点 v 的边权
  - 公式意义：将根从 u 转移到 v 时，子树内节点距离减少 `sz[v] * w`，子树外节点距离增加 `(n - sz[v]) * w`
- **解决难点**：
  1. 预处理所有节点到其他节点的距离和（换根DP）
  2. 动态维护新增节点带来的贡献（`+2*(f_k + n*w)`）

#### **可视化设计思路**
- **动画方案**：
  1. **树形结构展示**：以根节点为起点，逐步展开子树，用不同颜色标记正在计算的子树
  2. **状态转移演示**：高亮当前转移的边 `u→v`，动态显示 `sz[v]` 和 `n-sz[v]` 的变化
  3. **贡献计算**：新增节点时，用光效沿 `k→n+1` 路径扩散，显示 `+n*w` 的全局影响
- **复古像素风格**：
  - **颜色方案**：使用 8 位色（青绿表示子树内节点，品红表示子树外节点）
  - **音效设计**：状态转移时播放 8-bit "哔"声，计算完成时播放复古胜利音效

---

### **题解清单 (≥4星)**

1. **iiiiiyang 的换根DP解法（5星）**  
   - 亮点：仅用两次 DFS 完成预处理，代码简洁高效
   - 核心代码：  
     ```cpp
     f[v] = f[u] + w * (n - 2 * siz[v])
     ```
   - 个人心得："换根DP的转移方程是本题灵魂"

2. **Night_sea_64 的换根DP实现（4.5星）**  
   - 亮点：明确分离子树内外贡献计算
   - 关键注释："减法操作一定要加 mod 避免负数"

3. **Wf_yjqd 的树形DP解法（4星）**  
   - 亮点：同时维护子树内/外距离和
   - 优化点：用 `vector<pair>` 存储邻接表提升可读性

---

### **代码实现核心**

#### **换根DP关键代码**
```cpp
// 第一次DFS计算子树大小和初始距离
void dfs1(int u, int fa) {
    sz[u] = 1;
    for (auto [v, w] : G[u]) {
        if (v == fa) continue;
        dfs1(v, u);
        sz[u] += sz[v];
        f[u] += f[v] + sz[v] * w;
    }
}

// 第二次DFS换根计算全局距离
void dfs2(int u, int fa) {
    for (auto [v, w] : G[u]) {
        if (v == fa) continue;
        dp[v] = dp[u] + w * (n - 2 * sz[v]);
        dfs2(v, u);
    }
}
```

#### **查询处理**
```cpp
// 预处理总和
long long total = accumulate(dp + 1, dp + n + 1, 0LL) % MOD;

// 每次查询计算
int ans = (total + 2 * (dp[k] + n * w % MOD)) % MOD;
```

---

### **相似题目推荐**
1. **P3478 [POI2008] STA-Station**  
   （换根DP求最大深度和）
2. **P2986 [USACO10MAR] Great Cow Gathering G**  
   （带权换根DP）
3. **P3047 [USACO12FEB] Nearby Cows G**  
   （树形DP+分层处理）

---

### **可视化演示脚本（伪代码）**
```javascript
class DPVisualizer {
  constructor(tree) {
    this.nodes = tree.nodes // 树节点数据
    this.highlightEdge(u, v) { /* 高亮u→v边 */ }
    this.updateDPValue(v, val) { /* 显示dp[v]更新过程 */ }
  }

  async autoRun() {
    // 第一步：DFS1计算子树
    await this.dfs1(1, -1); 
    // 第二步：DFS2换根计算
    await this.dfs2(1, -1);
    // 显示查询过程
    this.showQuery(k, w);
  }
}
```

---

**关键学习点**：换根DP通过两次DFS实现全局计算，将树形问题的复杂度从O(n²)降至O(n)，是处理树形结构动态计算的利器。

---
处理用时：79.81秒
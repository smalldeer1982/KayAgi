# 题目信息

# 「PFLOI R1」PFL 除法

## 题目背景

[有必要把所有比赛题的背景连在一起](https://www.luogu.com.cn/paste/enzfvjum)。

就这样，新世界的大门向它们敞开了……  

“喵！”一只可爱的花猫向它们问好。  

“你们刚来到这？”  

“嗯。”  

“我带你们去转转吧，谁叫我这么可爱呢！”  

“……” 花猫突然止住，打量一番手中的序列，俶尔又微笑着说：  

“但你们要先答出我的问题哦。”

## 题目描述

花猫有一个长度为 $n$ 的序列 $A$ 和另一个长度为 $m$ 的序列 $B$。你可以进行若干次以下操作：

+ 选择两个整数 $i$ 和 $j$，满足 $1\le i\le n$，$1\le j\le m$ 且 $B_j \mid A_i$，然后将 $A_i$ 变为 $\frac{A_i}{B_j}$。

**注意**：$A$ 和 $B$ 中的每个元素都可以选择并被**操作多次**。

最终要使得 $A$ 中的元素都相等，请求出最少的操作次数；若无解，输出 `-1`。

## 说明/提示

**本题采用捆绑测试**。

| 子任务编号 | 特殊性质 | 分值 | 
| :----------: | :----------: | :-----:| 
| $1$ | $A$ 中所有元素相等 | $5$ |
| $2$ | $n=2$ | $15$ |
| $3$ | $n,m\le10^3$ | $20$ | 
| $4$ | $n,m\le10^4$ | $20$ | 
| $5$ | 无 | $40$ |

对于所有数据，$1\le n,m\le5\times10^5$，$1\le A_i,B_i\le5\times10^5$。

## 样例 #1

### 输入

```
4 5
16 24 28 36
11 4 7 3 2```

### 输出

```
6```

## 样例 #2

### 输入

```
2 3
11 13
13 1 11```

### 输出

```
2```

## 样例 #3

### 输入

```
2 2
2 3
4 5```

### 输出

```
-1```

# AI分析结果



---

## 唯一算法分类  
**完全背包**

---

## 综合分析与结论  

### 核心思路与算法要点  
1. **完全背包预处理**  
   通过动态规划预处理 `dp[x]` 表示将数值 `x` 分解为 `1` 所需的最小操作次数。状态转移方程为：  
   ```  
   dp[x * B[j]] = min(dp[x * B[j]], dp[x] + 1)  
   ```  
   遍历所有 `B[j]` 的倍数，确保每个数的最小分解次数被正确记录。  

2. **因数枚举优化**  
   最终相等的值 `D` 必须是原数组 `A` 的最大公约数的因数。通过枚举所有因数，计算所有 `A[i]` 转换为 `D` 的总操作次数，取最小值。  

3. **去重与排序**  
   对 `B` 数组去重并排序，避免重复处理相同的因子，将时间复杂度优化至 `O(n log n)` 级别。  

### 可视化设计思路  
1. **动态规划矩阵更新动画**  
   - 在 Canvas 上绘制一个网格，每个格子代表数值 `x`，颜色深浅表示 `dp[x]` 的值（深色表示更小值）。  
   - 当处理 `B[j]` 时，高亮该元素，并逐步填充其倍数的格子（如 `B[j]`, `2*B[j]`, `3*B[j]` 等），显示 `dp` 值的更新过程。  
   - 每次更新时，播放短促的“滴答”音效；发现更优解时，播放上扬音效。  

2. **因数枚举过程演示**  
   - 在屏幕右侧列出所有可能的因数 `D`，实时计算每个 `D` 的总操作次数。  
   - 当前最优解用闪烁边框标记，每次发现更小值时触发闪光动画。  

3. **复古游戏化元素**  
   - **8 位像素风格**：使用 16 色调色板（如深蓝表示未处理，绿色表示已处理，红色表示不可达）。  
   - **背景音乐**：循环播放 8-bit 风格的轻快旋律。  
   - **积分系统**：每完成一个 `B[j]` 的倍数处理得 10 分，每找到更优解得 50 分。  

---

## 题解清单 (≥4星)  

### 1. qwq___qaq 的题解 (⭐⭐⭐⭐⭐)  
**关键亮点**：  
- 使用调和级数优化的完全背包预处理，时间复杂度严格为 `O(n log n)`。  
- 通过枚举因数避免冗余计算，代码简洁高效。  

**核心代码**：  
```cpp
memset(dp, inf, sizeof(dp));
dp[1] = 0;
for (int i=1; i<=m; ++i)
    for (int s = B[i]; s <= V; s += B[i])
        dp[s] = min(dp[s], dp[s/B[i]] + 1);
```

### 2. LCat90 的题解 (⭐⭐⭐⭐)  
**关键亮点**：  
- 显式处理最大公约数的所有因数，逻辑清晰。  
- 通过预处理 `B` 数组的 `unique` 操作避免重复更新。  

**核心代码**：  
```cpp
m = unique(b+1, b+m+1) - b - 1;
for (int i : factors) {
    int tot = 0;
    for (int j=1; j<=n; ++j)
        tot += dp[a[j]/i];
    ans = min(ans, tot);
}
```

### 3. yanhao40340 的题解 (⭐⭐⭐⭐)  
**关键亮点**：  
- 使用类似 BFS 的宽搜预处理，适合理解完全背包的“层序更新”本质。  
- 通过队列优化状态更新顺序，避免重复计算。  

**核心代码**：  
```cpp
queue<int> q;
for (int i=1; i<=m; ++i)
    if (B[i] != 1) q.push(B[i]);
while (!q.empty()) {
    int fr = q.front(); q.pop();
    for (int j=1; j<=m; ++j)
        if (fr * B[j] <= V)
            dp[fr*B[j]] = min(dp[fr*B[j]], dp[fr] + 1);
}
```

---

## 最优思路提炼  
1. **完全背包预处理**  
   将 `B` 数组视为可无限使用的物品，用动态规划求每个数的最小分解次数。  
2. **因数分解优化**  
   最终值 `D` 必须是 `gcd(A)` 的因数，极大减少枚举范围。  
3. **去重与排序**  
   预处理 `B` 数组的去重和排序，确保时间复杂度严格可控。  

---

## 同类型题推荐  
1. **完全背包模板**：洛谷 P1616  
2. **因数分解与动态规划**：洛谷 P1853  
3. **调和级数优化**：洛谷 P1403  

---

## 可视化代码片段 (复古像素风格)  
```javascript
// Canvas 初始化与网格绘制
const canvas = document.getElementById('dp-grid');
const ctx = canvas.getContext('2d');
const CELL_SIZE = 20;
const MAX_VALUE = 50; // 示例值域

function drawGrid() {
    for (let x=1; x<=MAX_VALUE; x++) {
        ctx.fillStyle = dp[x] === INF ? '#333' : `hsl(${240 - dp[x]*10}, 100%, 50%)`;
        ctx.fillRect((x-1)*CELL_SIZE, 0, CELL_SIZE, CELL_SIZE);
        ctx.strokeStyle = '#FFF';
        ctx.strokeRect((x-1)*CELL_SIZE, 0, CELL_SIZE, CELL_SIZE);
    }
}

// 音效触发
function playSound(freq) {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = freq;
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

---

## 个人心得摘录  
> “在调试时发现，不去重 `B` 数组会导致时间复杂度爆炸，因此 `unique` 操作是必须的。” —— qwq___qaq  
> “最大公约数的因数不一定最优，需要枚举所有可能，这是容易被忽略的陷阱。” —— 哈哈人生  

---

## 交互式演示参数  
- **动画速度**：支持 0.5x~5x 倍速调节  
- **音效开关**：可单独关闭背景音乐或操作音效  
- **自动模式**：AI 自动执行 DP 更新与因数枚举，用绿色箭头指示当前操作位置

---
处理用时：99.79秒
# 题目信息

# 「KDOI-06-J」旅行

## 题目描述

小 C 在 C 国旅行。

C 国有 $n\times m$ 个城市，可以看做 $n\times m$ 的网格。定义 $(i,j)$ 表示在网格中第 $i$ 行第 $j$ 列的城市。

该国有 $2$ 种交通系统：

* 对于所有 $1\leq i<n,1\leq j\leq m$，$(i,j)$ 到 $(i+1,j)$ 有一段由 L 公司修的单向铁路；
* 对于所有 $1\leq i\leq n,1\leq j<m$，$(i,j)$ 到 $(i,j+1)$ 有一段由 Z 公司修的单向铁路；

在每一个城市有一个售票口，$(i,j)$ 城市的售票口可以用 $a_{i,j}$ 元购买一张 L 公司的铁路票，$b_{i,j}$ 元购买一张 Z 公司的铁路票。当你拥有一个公司的一张铁路票时，你可以乘坐这个公司的任意一段铁路，并消耗掉这张铁路票。注意，一张铁路票可以且仅可以使用一次。

小 C 原来在城市 $(1,1)$。他想要在 C 国旅游，但是他不想浪费任何的钱（即，当他旅游完毕时手上不应该有多余的车票）。对于所有 $1\leq x\leq n,1\leq y\leq m$，求他花 $k$ 元钱并在城市 $(x,y)$ 结束旅行的方案数，对 $998\ 244\ 353$ 取模。

两种旅行方案不同，当且仅当小 C 经过的城市不同，或他在某一个城市购买的某家公司的铁路票数量不同。

## 说明/提示

**【样例解释 #1】**

到 $(3,1)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；在 $(2,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,1)$。

到 $(2,2)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；在 $(2,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(2,2)$。

到 $(3,2)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；在 $(1,2)$ 购买 $2$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,2)$；乘坐 L 公司的铁路到 $(3,2)$。
* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；乘坐 L 公司的铁路到 $(2,2)$；在 $(2,2)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,2)$。
* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；乘坐 Z 公司的铁路到 $(2,2)$；在 $(2,2)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,2)$。

到 $(2,3)$ 的方案有：

* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $2$ 张 Z 公司的铁路票。在此之后，有 $3$ 种方案可以从 $(1,1)$ 乘坐两公司的铁路到 $(2,3)$。
* 在 $(1,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；在 $(1,2)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票。在此之后，有 $2$ 种方案可以从 $(1,2)$ 乘坐两公司的铁路到 $(2,3)$。

**【样例 #2】**

见选手目录下的 `travel/travel2.in` 与 `travel/travel2.ans`。这个样例满足测试点 $7\sim 8$ 的条件限制。

**【样例 #3】**

见选手目录下的 `travel/travel3.in` 与 `travel/travel3.ans`。这个样例满足测试点 $11$ 的条件限制。

**【数据范围】**

对于所有数据保证：$1\leq n,m\leq45$，$1\leq k,a_{i,j},b_{i,j}\leq90$。

| 测试点编号 | $n,m$ | $k$ | $a_{i,j}$ | $b_{i,j}$ |
|:--:|:--:|:--:|:--:|:--:|
| $1\sim3$ | $\leq3$ | $\leq5$ | $=1$ | $=1$ |
| $4\sim6$ | $\leq10$ | $\leq10$ | $=1$ | $=40$ |
| $7\sim8$ | $\leq40$ | $\leq30$ | $=1$ | $=45$ |
| $9\sim10$ | $\leq15$ | $\leq15$ | $\leq15$ | $\leq15$ |
| $11$ | $\leq15$ | $\leq30$ | $\leq30$ | $\leq30$ |
| $12$ | $\leq20$ | $\leq40$ | $\leq40$ | $\leq40$ |
| $13\sim15$ | $\leq25$ | $\leq50$ | $\leq50$ | $\leq50$ |
| $16$ | $\leq30$ | $\leq60$ | $\leq60$ | $\leq60$ |
| $17$ | $\leq35$ | $\leq70$ | $\leq70$ | $\leq70$ |
| $18\sim19$ | $\leq40$ | $\leq80$ | $\leq80$ | $\leq80$ |
| $20$ | $\leq45$ | $\leq90$ | $\leq90$ | $\leq90$ |

## 样例 #1

### 输入

```
3 3 5
3 2 1
2 1 3
1 3 2
1 2 3
2 3 1
3 1 2```

### 输出

```
0 0 0
0 1 5
1 3 5```

# AI分析结果



**唯一算法分类**: 线性DP

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
所有题解均采用动态规划（DP）解决，核心状态设计为五维数组 `dp[i][j][x][y][c]`，表示到达点 `(i,j)`，剩余 `x` 张 L 公司票、`y` 张 Z 公司票，已花费 `c` 元的方案数。通过状态转移模拟移动和购票过程。

#### **关键算法要点**
1. **状态转移设计**：
   - **移动方向转移**：从上方或左方移动至当前点，消耗对应票数。
   - **购票转移**：在当前点购买 L/Z 公司票，增加剩余票数并更新花费。
   - **容斥优化**：处理同时购买两种票的重复计算问题，通过加减抵消重复项。
   
2. **滚动数组优化**：将行维度 `i` 用滚动数组（如 `i & 1`）压缩，空间复杂度从 `O(n^5)` 降至 `O(n^4)`。

3. **剪枝策略**：
   - 剩余票数限制为 `x ≤ n-i`, `y ≤ m-j`（后续移动最多需要 `n-i` 张 L 票和 `m-j` 张 Z 票）。
   - 费用倒序枚举避免重复更新。

#### **解决难点**
1. **状态爆炸**：五维状态通过滚动数组和剪枝降低复杂度。
2. **重复计算**：通过容斥原理（前缀和思想）避免购买多张票时的重复计数。
3. **边界处理**：初始状态 `dp[1][1][0][0][0] = 1`，终点需严格花完钱且无剩余票。

---

### **题解评分 (≥4星)**

1. **uid_310801 (5星)**
   - **亮点**：引入容斥优化转移方程，空间优化到位，代码清晰易读。
   - **关键代码**：通过加减前缀和简化购票枚举，显著降低时间复杂度。

2. **cqbzlzm (4星)**
   - **亮点**：明确四类转移（移动和购票），直观展示基础 DP 设计。
   - **不足**：未显式处理容斥，部分题解可能重复计算。

3. **Eddie08012025 (4星)**
   - **亮点**：优化代码实现，采用快速加减避免频繁取模，提升运行效率。
   - **技巧**：限制剩余票数范围，减少无效状态计算。

---

### **最优思路或技巧提炼**

1. **容斥优化转移**：  
   将购票的多次枚举合并为加减操作，公式为：  
   ```cpp
   dp[i][j][c][x][y] = dp_购L + dp_购Z - dp_购LZ
   ```
   避免重复计算同时购买 L 和 Z 票的情况。

2. **滚动数组压缩空间**：  
   仅保留当前行和前一行状态，空间复杂度从 `O(n^5)` 降至 `O(n^4)`。

3. **费用倒序枚举**：  
   类似完全背包优化，防止同一状态多次更新自身。

---

### **同类型题或类似算法套路**

- **多维背包问题**：需同时管理多种资源（如剩余票数、费用）。
- **路径计数 DP**：网格移动类问题，结合资源限制（如费用、剩余步数）。
- **状态压缩优化**：滚动数组和剪枝策略适用于高维 DP 问题。

---

### **推荐相似题目**

1. **P1941 [NOIP2014 提高组] 飞扬的小鸟**  
   （二维状态，结合跳跃和下降操作，费用管理）

2. **P3959 [NOIP2017 提高组] 宝藏**  
   （状态压缩 DP，多维资源分配）

3. **P5664 [CSP-S2019] Emiya 家今天的饭**  
   （容斥原理优化计数，多维限制）

---

### **可视化与算法演示**

#### **动态规划状态转移动画**
- **网格绘制**：以 `Canvas` 绘制 `n×m` 网格，每个单元格显示 `(i,j)` 的 `dp` 值。
- **高亮变化**：  
  - 红色：当前更新的 `(i,j)` 位置。  
  - 绿色箭头：从上方 `(i-1,j)` 或左方 `(i,j-1)` 的转移。  
  - 黄色闪烁：购票操作导致费用增加。
- **步进控制**：支持暂停/继续，单步查看转移过程。

#### **复古游戏化设计**
- **8位像素风格**：  
  - 使用 `#FF6B6B`（红）、`#4ECDC4`（青）等复古色调绘制网格。  
  - 每个状态格子显示剩余票数和费用，类似 RPG 道具栏。
- **音效设计**：  
  - 移动时播放 `8-bit` 脚步声。  
  - 购票时播放硬币掉落声，错误操作（如钱不足）播放低沉音效。
- **自动演示模式**：  
  - AI 按最优路径自动转移，动态显示 `dp` 值变化，类似贪吃蛇 AI 寻路。

---

### **代码片段（核心 DP 转移）**

```cpp
// uid_310801 的优化转移代码（滚动数组 + 容斥）
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        for (int c = 1; c <= k; c++) {
            for (int x = 0; x <= n - i; x++) {
                for (int y = 0; y <= m - j; y++) {
                    ll res = mod;
                    // 处理购票转移（容斥）
                    if (x > 0 && c >= a[i][j]) res += dp[...];
                    if (y > 0 && c >= b[i][j]) res += dp[...];
                    if (x > 0 && y > 0) res -= dp[...];
                    // 处理移动转移
                    if (i > 1) res += dp_prev[...];
                    if (j > 1) res += dp_left[...];
                    dp_current[...] = res % mod;
                }
            }
        }
    }
}
```

---
处理用时：80.10秒
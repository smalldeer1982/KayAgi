# 题目信息

# 好消息，坏消息

## 题目描述

Uim 在公司里面当秘书，现在有 $n$ 条消息要告知老板。每条消息有一个好坏度，这会影响老板的心情。告知完一条消息后，老板的心情等于老板之前的心情加上这条消息的好坏度。最开始老板的心情是 $0$，一旦老板心情到了 $0$ 以下就会勃然大怒，炒了 Uim 的鱿鱼。

Uim 为了不被炒，提前知道了这些消息（已经按时间的发生顺序进行了排列）的好坏度，希望知道如何才能不让老板发怒。

Uim 必须按照事件的发生顺序逐条将消息告知给老板。不过 Uim 可以使用一种叫 “倒叙” 的手法，例如有 $n$ 条消息，Uim 可以按 $k,k+1,k+2,\ldots,n,1,2,\ldots,k-1$（事件编号）这种顺序通报。

他希望知道，有多少个 $k$，可以使从 $k$ 号事件开始通报到 $n$ 号事件然后再从 $1$ 号事件通报到 $k-1$ 号事件可以让老板不发怒。

## 说明/提示

**【样例解释】**

通报事件的可行顺序（用编号表示）为 $2\rightarrow3\rightarrow4\rightarrow1$ 或 $3\rightarrow4\rightarrow1\rightarrow2$（分别对应 $k=2$ 和 $k=3$）

通报事件的可行顺序（用好坏度表示）为 $5\rightarrow1\rightarrow2\rightarrow(-3)$ 或 $1\rightarrow2\rightarrow(-3)\rightarrow5$

**【数据范围】**

对于 $25\%$ 的数据，$n\le10^3$；  
对于 $75\%$ 的数据，$n\le10^4$；  
对于 $100\%$ 的数据，$1 \le n\le 10^6$。

## 样例 #1

### 输入

```
4
-3 5 1 2
```

### 输出

```
2

```

# AI分析结果



### 唯一算法分类
前缀和与预处理

### 综合分析与结论
**核心思路**：  
将环形问题拆解为线性问题，通过预处理前缀和的最小值，实现在O(n)时间复杂度内完成所有合法起点的判断。关键点在于将问题分解为两部分：
1. 后半段（k到n）的最小前缀和需≥0
2. 前半段（1到k-1）的最小前缀和加上后半段总和需≥0

**算法流程**：  
1. 计算前缀和数组s[i]
2. 预处理m[i]表示前i项前缀和的最小值
3. 预处理f[i]表示从i到n的前缀和的最小值
4. 对每个k判断：f[k] - s[k-1] ≥ 0 且 m[k-1] + (s[n] - s[k-1]) ≥ 0

**可视化设计**：  
- **像素动画**：以8位风格展示数组，用不同颜色标记当前k的位置
- **高亮显示**：用闪烁效果标出m[k]和f[k]的数值，绿色满足条件，红色不满足
- **音效反馈**：每次判定合法时播放清脆音效，非法时低沉音效
- **自动演示**：AI自动遍历k值，显示实时判定过程，速度可调节

### 题解清单（≥4星）
1. **作者：_ztyqwq（5星）**  
   - 亮点：O(n)时间复杂度，简洁的双向预处理
   - 核心代码：
     ```cpp
     for(int i=1;i<=n;i++) 
         m[i] = min(m[i-1], s[i]);
     for(int i=n;i>=1;i--) 
         f[i] = min(f[i+1], s[i]);
     ```

2. **作者：Mizuhara（4星）**  
   - 亮点：动态规划思想预处理后半段最小值
   - 代码片段：
     ```cpp
     for(int k=n;k>=1;k--) {
         no = min(a[k], no+a[k]);
         if(no>=0 && ...) ans++;
     }
     ```

3. **作者：swm_sxt（4星）**  
   - 亮点：分治思想处理前后段判断
   - 关键逻辑：
     ```cpp
     if (miz[i]-q[i-1]>=0 && miq[i-1]+q[n]-q[i-1]>=0)
         ans++;
     ```

### 关键代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll s[1000001],m[1000002][2];

int main() {
    int n, ans = 0;
    scanf("%d",&n);
    // 预处理前缀和及最小值
    for(int i=1; i<=n; i++) {
        ll a; scanf("%lld",&a);
        s[i] = s[i-1] + a;
        m[i][0] = min(m[i-1][0], s[i]);
    }
    // 反向预处理后缀最小值
    m[n+1][1] = LLONG_MAX;
    for(int i=n; i>=1; i--)
        m[i][1] = min(m[i+1][1], s[i]);
    
    for(int i=1; i<=n; i++)
        if(m[i][1]-s[i-1]>=0 && m[i-1][0]+(s[n]-s[i-1])>=0)
            ans++;
    
    printf("%d",ans);
}
```

### 同类型题目推荐
1. P1886 滑动窗口（单调队列应用）
2. P1714 切蛋糕（前缀和+单调队列）
3. P1638 逛画展（双指针+前缀统计）

### 可视化核心逻辑
**动画步骤**：  
1. 初始化显示原数组和前缀和曲线
2. 动态绘制m[]和f[]的下降沿曲线
3. 用滑动窗口显示当前k的判断过程：
   - 绿色覆盖合法区间
   - 红色标出非法点
4. 累计合法k时播放粒子特效

**像素风格设计**：  
- 使用16色调色板，数组元素显示为像素方块
- 前缀和曲线用蓝色像素点连接
- 最小值标记为闪烁的黄色星标

**音效设计**：  
- 移动光标：8-bit "bleep" 音
- 合法判定：NES过关音效
- 非法判定：FC受伤音效

### 总结
通过预处理前缀和的极值，将环形问题转化为线性判断，是处理此类问题的典型方法。该解法在时间复杂度和代码简洁性上达到最优，配合可视化展示可以清晰展现算法核心逻辑。

---
处理用时：82.59秒
# 题目信息

# 「SWTR-3」Golden Sword

## 题目背景

小 E 不幸在一场战斗中失去了他的金宝剑。

## 题目描述

制造一把金宝剑需要 $n$ 种原料，编号为 $1$ 到 $n$，编号为 $i$ 的原料的坚固值为 $a_i$。

炼金是很讲究放入原料的顺序的，因此小 E 必须**按照 $1$ 到 $n$ 的顺序**依次将这些原料放入炼金锅。

但是，炼金锅的容量非常有限，它**最多只能容纳 $w$ 个原料**。

所幸的是，**每放入一个原料之前**，小 E 可以从中取出一些原料，数量不能超过 $s$ 个。

- 我们定义第 $i$ 种原料的耐久度为：放入第 $i$ 种原料时锅内的原料总数（包括正在放入的原料） $\times\ a_i$，则宝剑的耐久度为**所有原料**的耐久度之和。

小 E 当然想让他的宝剑的耐久度尽可能得大，这样他就可以带着它进行更多的战斗，请求出耐久度的最大值。

注：这里的“放入第 $i$ 种原料时锅内的原料总数**包括正在放入锅中的原料**，详细信息请见样例。

## 说明/提示

#### 「样例说明」

- **对于样例 1**，一种可行的**最优**方案为：
首先放进原料 1，此时锅内有 $1$ 种原料，耐久度为 $1\times a_1=1\times 1=1$。  
再放进原料 2，此时锅内有 $2$ 种原料，耐久度为 $2\times a_2=2\times 3=6$。  
再放进原料 3，此时锅内有 $3$ 种原料，耐久度为 $3\times a_3=3\times 2=6$。  
取出原料 1，再放进原料 4，此时锅内有 $3$ 种原料，耐久度为 $3\times a_4=3\times 4=12$。  
取出原料 4，再放进原料 5，此时锅内有 $3$ 种原料，耐久度为 $3\times a_5=3\times 5=15$。  
最终答案为 $1+6+6+12+15=40$。  
- **对于样例 2**，一种可行的**最优**方案为：  
放进原料 1，耐久度为 $1\times 1=1$。  
取出原料 1，放进原料 2，耐久度为 $1\times (-3)=-3$。  
放进原料 3，耐久度为 $2\times (-2)=-4$。  
放进原料 4，耐久度为 $3\times 4=12$。  
取出原料 2，放进原料 5，耐久度为 $3\times 5=15$。  
最终答案为 $1+(-3)+(-4)+12+15=21$。  
- **对于样例 3**，一种可行的**最优**方案为：  
  $a_1+2a_2+2a_3+3a_4+4a_5+3a_6+4a_7=17$。 
- **对于样例 4**，一种可行的**最优**方案为：  
$a_1+a_2+a_3+a_4+a_5=-15$。

#### 「数据范围与约定」

**本题使用捆绑测试。**

- Subtask #1（15 points）：$n\leq 10$。
- Subtask #2（5 points）：$n\leq 100$，$a_i\geq0$。
- Subtask #3（15 points）：$n\leq 300$。
- Subtask #4（15 points）：$s=w=n$。
- Subtask #5（5 points）：$a_i\geq 0$。
- Subtask #6（10 points）：$n\leq 2\times 10^3$。
- Subtask #7（10 points）：$s=1$。
- Subtask #8（25 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \leq s \leq w \leq n \leq 5\times 10^3$，$|a_i| \leq 10^9$。对于 Subtask $i$ 有 $|a_i|\leq 10^{i+1}$。

#### 「帮助/说明」

本题下发大样例，具体输入输出见 [**Big Sample**](https://pan.baidu.com/s/1erVDllDlvNlEShxh3U42gA) 中的 gold01-08.in/gold01-08.out。提取码：757d。  
**文件名与 Subtask 编号一一对应。**

#### 「来源」

[Sweet Round 03 D](https://www.luogu.com.cn/contest/24755)。  
idea & solution：ET2006。

## 样例 #1

### 输入

```
5 3 3
1 3 2 4 5
```

### 输出

```
40```

## 样例 #2

### 输入

```
5 3 3
1 -3 -2 4 5
```

### 输出

```
21```

## 样例 #3

### 输入

```
7 4 2
-5 3 -1 -4 7 -6 5
```

### 输出

```
17```

## 样例 #4

### 输入

```
5 3 1
-1 -3 -2 -4 -5
```

### 输出

```
-15```

# AI分析结果



**唯一算法分类**：动态规划 + 单调队列优化

---

### **综合分析与结论**
**核心思路**：  
- **状态定义**：`dp[i][j]` 表示放入第 `i` 个原料时，锅中恰好有 `j` 个原料的最大耐久度总和。  
- **转移方程**：`dp[i][j] = max(dp[i-1][k]) + j * a_i`，其中 `k ∈ [j-1, min(j+s-1, w)]`。  
- **优化**：使用单调队列维护窗口内的最大值，将时间复杂度从 `O(nw^2)` 优化为 `O(nw)`。

**解决难点**：  
1. **窗口范围的动态维护**：当 `j` 递减时，窗口的上界 `min(j+s-1, w)` 动态变化，需在队列中及时弹出越界的元素。  
2. **队列单调性**：插入新元素时，保持队列中 `dp` 值的单调递减，确保队首始终为最大值。  

**可视化设计**：  
- **动画方案**：以网格展示 `dp` 矩阵，当前处理的 `i` 和 `j` 高亮显示，队列元素用不同颜色标记。  
- **颜色标记**：红色表示当前 `j`，蓝色表示队列中的有效元素，灰色表示被弹出的元素。  
- **步进控制**：允许单步执行观察队列插入、弹出和 `dp` 值更新过程。  
- **复古风格**：用 8 位像素风格绘制网格和队列，配以点击音效和背景音乐。

---

### **题解清单（4星及以上）**
1. **Alex_Wei（5星）**  
   - **亮点**：详细分析各子任务，提供多种解法，代码规范且含滚动数组优化。  
   - **心得**：强调边界条件处理，如 `i>w` 的特判。  
   - **代码片段**：  
     ```cpp
     for(int j=min(w,i);j>=1;j--) {
         while(q.size()&&q.front()>min(j+s-1,w)) q.pop_front();
         q.push_back(j-1);
         dp[i][j] = q.front_val + a[i] * j;
     }
     ```

2. **pomelo_nene（4.5星）**  
   - **亮点**：简洁的单调队列实现，代码逻辑清晰。  
   - **优化点**：倒序处理 `j` 并动态维护队列。  
   - **代码片段**：  
     ```cpp
     for(int j=m;j;--j) {
         while(pos[l]>j+s-1) l++;
         q[++r] = {dp[i-1][j-1], j-1};
         dp[i][j] = q[l].val + j*a[i];
     }
     ```

3. **Bosun（4星）**  
   - **亮点**：代码简洁，使用滚动数组节省空间。  
   - **注意点**：需正确处理队列初始化和边界。  
   - **代码片段**：  
     ```cpp
     for(j=w;j>=1;j--){
         push(dp[p^1][j-1], j-1);
         dp[p][j] = q[h].val + a[i] * j;
     }
     ```

---

### **最优思路与技巧提炼**
1. **单调队列优化**：  
   - **窗口维护**：倒序处理 `j`，插入 `k=j-1` 并保持队列单调递减。  
   - **边界处理**：动态计算窗口上界 `min(j+s-1, w)`，弹出越界元素。  

2. **滚动数组**：  
   - 仅保留 `dp[i]` 和 `dp[i-1]`，减少空间复杂度至 `O(w)`。

---

### **同类题目推荐**
1. **P3957 跳房子**（单调队列优化 DP）  
2. **P1725 琪露诺**（滑动窗口最大值）  
3. **P1776 宝物筛选**（多重背包单调队列优化）

---

### **代码实现（核心逻辑）**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=5505;
ll n,w,s,a[N],dp[2][N];
struct Deque {
    int q[N], head, tail;
    void init() { head=1; tail=0; }
    void push(int j, ll val) {
        while (head<=tail && dp[!(i%2)][j] >= dp[!(i%2)][q[tail]]) tail--;
        q[++tail] = j;
    }
    int front() { return q[head]; }
} dq;

int main() {
    cin>>n>>w>>s;
    for(int i=1;i<=n;i++) cin>>a[i];
    memset(dp, 0x80, sizeof(dp)); // 初始化为极小值
    dp[0][0] = 0;
    for(int i=1;i<=n;i++) {
        dq.init();
        for(int j=min(w,i); j>=1; j--) {
            int L = j-1, R = min(j+s-1, w);
            while (dq.front() > R) dq.pop_front();
            dq.push(L, dp[!(i%2)][L]);
            dp[i%2][j] = dp[!(i%2)][dq.front()] + j*a[i];
        }
    }
    ll ans = *max_element(dp[n%2], dp[n%2]+w+1);
    cout << ans << endl;
}
```

---

### **可视化与游戏化设计**
- **Canvas 动画**：绘制 `n x w` 的网格，高亮当前 `i` 和 `j`，队列元素用浮动方块表示。  
- **音效**：插入/弹出队列时播放“哔”声，计算 `dp` 时播放“滴”声。  
- **自动演示**：按帧推进，展示队列滑动和 `dp` 更新过程，支持暂停/继续。  
- **像素风格**：使用复古 8-bit 配色（深蓝背景、绿色网格、黄色高亮）。

---
处理用时：139.26秒
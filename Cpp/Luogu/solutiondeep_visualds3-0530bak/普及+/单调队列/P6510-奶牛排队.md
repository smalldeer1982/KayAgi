# 题目信息

# 奶牛排队

## 题目描述

奶牛在熊大妈的带领下排成了一条直队。

显然，不同的奶牛身高不一定相同……

现在，奶牛们想知道，如果找出一些连续的奶牛，要求最左边的奶牛 $A$ 是最矮的，最右边的 $B$ 是最高的，且 $B$ 高于 $A$ 奶牛。中间如果存在奶牛，则身高不能和 $A,B$ 奶牛相同。问这样的奶牛最多会有多少头？

从左到右给出奶牛的身高，请告诉它们符合条件的最多的奶牛数（答案可能是 $0,2$，但不会是 $1$）。

## 说明/提示

#### 样例解释

取第 $1$ 头到第 $4$ 头奶牛，满足条件且为最多。

#### 数据范围

对于全部的数据，满足 $2 \le N \le 10^5$，$1 \le h_i <2^{31}$。

## 样例 #1

### 输入

```
5
1
2
3
4
1```

### 输出

```
4```

# AI分析结果



### **唯一算法分类**  
单调栈

---

### **题解思路、算法要点与解决难点**  
**核心思路**：  
题目要求寻找最长的连续区间，满足左端点是最小值，右端点是最大值，且中间元素不与两端相等。各题解主要采用以下方法：  
1. **单调栈维护极值**：通过维护后缀最大值/最小值栈，快速确定当前右端点对应的合法左端点范围。  
2. **二分查找优化**：在最小值栈中二分查找满足条件的左端点，保证时间复杂度为O(n log n)。  
3. **分治与RMQ**：分治处理区间，利用RMQ快速定位极值点，递归求解子区间。  

**解决难点**：  
- **高效维护极值位置**：通过单调栈维护后缀最大值/最小值，确保每个右端点B对应的左端点A的候选位置快速更新。  
- **避免重复计算**：二分查找或预处理左右边界，避免暴力枚举。  
- **处理中间元素的唯一性**：确保中间元素不与两端相等，通过极值栈的单调性隐含保证。  

---

### **题解评分 (≥4星)**  
1. **扶苏一（5星）**  
   - **亮点**：清晰的单调栈+二分逻辑，代码简洁高效，时间复杂度最优。  
   - **关键代码**：  
     ```cpp  
     while (tn && a[sn[tn]] >= a[i]) --tn;  // 维护最小值栈  
     while (tx && a[sx[tx]] < a[i]) --tx;  // 维护最大值栈  
     int k = upper_bound(sn + 1, sn + 1 + tn, sx[tx]) - sn;  // 二分查找左端点  
     ```  
2. **Acestar（4星）**  
   - **亮点**：结构清晰，二分函数独立封装，适合教学理解。  
3. **do_while_true（4星）**  
   - **亮点**：分治策略结合RMQ，提供另一种思路，适合理解递归优化。  

---

### **最优思路或技巧提炼**  
1. **单调栈维护极值**：  
   - 用栈维护后缀最大值和最小值位置，保证栈的单调性。  
   - 枚举右端点时，通过弹栈更新极值栈，确保栈顶是当前最优候选。  
2. **二分查找左端点**：  
   - 在最小值栈中二分查找第一个大于“第二个后缀最大值位置”的左端点，保证A的合法性。  
3. **分治剪枝**：  
   - 在分治过程中，通过极值分割区间，避免重复计算子问题。  

---

### **同类型题或类似算法套路**  
- **单调栈经典题**：  
  - 直方图最大矩形（LeetCode 84）  
  - 接雨水（LeetCode 42）  
- **分治+RMQ**：  
  - 区间最值问题（洛谷P3865）  

---

### **推荐洛谷题目**  
1. **P5788 单调栈模板**  
2. **P3865 ST表模板**  
3. **P1901 发射站（单调栈应用）**  

---

### **可视化与算法演示**  
**动画方案**：  
1. **栈动态变化**：  
   - 用两个色块分别表示最大值栈和最小值栈，元素入栈时高亮显示，弹栈时淡出。  
2. **高亮当前处理元素**：  
   - 右端点B用红色标记，左端点A用绿色标记，合法区间用黄色背景覆盖。  
3. **二分过程演示**：  
   - 在最小值栈中逐步缩小二分范围，标记中间步骤的候选左端点。  

**复古像素风格设计**：  
- **颜色方案**：栈元素用8位色块（红/蓝区分极值栈），当前操作元素闪烁。  
- **音效**：弹栈时播放“哔”声，找到合法区间时播放“叮”声。  

---

### **代码片段（扶苏题解核心）**  
```cpp  
while (tn && a[sn[tn]] >= a[i]) --tn;  // 维护最小值栈  
while (tx && a[sx[tx]] < a[i]) --tx;   // 维护最大值栈  
int k = upper_bound(sn + 1, sn + 1 + tn, sx[tx]) - sn;  
if (k != tn + 1) ans = max(ans, i - sn[k] + 1);  
sn[++tn] = i;  // 压入当前右端点到栈中  
sx[++tx] = i;  
```  

---

### **结论**  
**最优解法**：扶苏的单调栈+二分法，时间复杂度O(n log n)，代码简洁高效。  
**可视化重点**：通过动态栈变化和二分查找过程，直观展示极值维护与区间合法性判断。

---
处理用时：81.10秒
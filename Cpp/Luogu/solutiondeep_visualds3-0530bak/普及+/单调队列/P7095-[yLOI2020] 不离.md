# 题目信息

# [yLOI2020] 不离

## 题目背景

> 乱玄黄时序，探风林实虚。  
> 我要你共我奇谈怪趣。  
> 任日月斑斓，待春秋兴残。  
> 我要我们有聚无散。  

——银临《不离》

## 题目描述

这道题目来自 zxy 哔哔，咕咕让哔哔选一首歌作为题目名，但是哔哔说没有想好，于是咕咕就帮他选了这首歌。

哔哔在玩一款叫做《暗黑破坏神》的游戏，某天哔哔灵光乍现，以游戏为背景出了一道神仙题并告诉了咕咕。咕咕并不会做，于是对题目进行了一定的简化。因此，经过简化后，这道题已经和《暗黑破坏神》没什么关系了。

游戏中人物有两个属性，我们分别称之为「力量」和「精神」，同时哔哔有 $n$ 件装备，穿戴第 $i$ 件装备需要人物在穿戴前的力量值不低于 $a_i$，精神值不低于 $b_i$。在穿戴第 $i$ 件装备后，人物的力量值会增加 $c_i$，精神值会增加 $d_i$。

哔哔可以自由选择穿装备的顺序，只要满足力量和精神不低于对应值，就可以穿戴该装备。

现在，咕咕想知道，如果想让哔哔穿戴上所有的装备，那么人物的初始力量值（即没有穿任何装备之前的力量值）最小应该是多少？在初始力量值最小的前提下，初始精神值（即没有穿任何装备之前的精神值）最小应该是多少？

显然，初始力量和初始精神都应该是非负整数。

## 说明/提示

### 样例 1 解释

当初始力量值为 $1$，精神值为 $2$ 时，可以穿戴第 $2$ 件装备。在穿戴该装备后，增加 $3$ 点力量和 $4$ 点精神，人物的属性变为 $4$ 点力量和 $6$ 点精神，此时可以穿戴第 $1$ 件装备。

### 数据规模与约定

**本题采用多测试点捆绑测试**。

- 子任务 $1$（$5$ 分）：保证 $n=0$。
- 子任务 $2$（$5$ 分）：保证 $n=1$。
- 子任务 $3$（$20$ 分）：保证 $a_i,b_i \le 100$，$n \le 6$。
- 子任务 $4$（$10$ 分）：保证 $a_i,b_i \le 10^5$，$n \le 6$。
- 子任务 $5$（$10$ 分）：保证 $a_i,b_i \le 10$。
- 子任务 $6$（$10$ 分）：保证 $a_i,b_i \le 100$。
- 子任务 $7$（$10$ 分）：保证 $b_i=0$，$n \le 6$。
- 子任务 $8$（$10$ 分）：保证 $b_i=0$。
- 子任务 $9$（$10$ 分）：保证 $n \le 6$。
- 子任务 $10$（$10$ 分）：无特殊约定。

对于全部的测试点，保证 $0 \le n \le 10^5$，$0 \le a_i,b_i,c_i,d_i \le 10^9$。

### 提示
有 $4$ 个样例文件，请见附加文件中的 forever.zip。

对于第三个样例，满足 $b_i = 0$。

## 样例 #1

### 输入

```
0
2
1 5 0 2
1 2 3 4```

### 输出

```
1 2```

# AI分析结果



### 唯一算法分类
**贪心算法 + 优先队列**

---

### 题解思路与算法要点

#### 核心逻辑
1. **力量与精神分离处理**：优先保证力量满足所有装备穿戴顺序，再在最小力量基础上求最小精神。
2. **贪心策略**：
   - **力量阶段**：按装备力量需求升序排序，若当前力量不足则补充差值。
   - **精神阶段**：将满足当前力量的装备加入优先队列（按精神需求排序），动态维护可穿戴装备的最小精神需求。

#### 解决难点
- **动态维护可用装备**：使用优先队列实时筛选可穿戴装备，确保每次选择精神需求最小的装备。
- **时间复杂度优化**：通过排序和优先队列将总时间复杂度降至 *O(n log n)*。

---

### 题解评分（≥4星）

1. **火车司机（5星）**
   - **亮点**：通过两次贪心（力量排序 + 精神优先队列）实现高效解，代码简洁，时间复杂度最优。
   - **代码片段**：
     ```cpp
     sort(p + 1, p + 1 + n, cmp);
     for (int i = 1, a = 0; i <= n; ++i) {
         if (a < p[i].a) ans1 += p[i].a - a, a = p[i].a;
         a += p[i].c;
     }
     priority_queue<buff> q;
     while (p[i].a > ans1) {
         ans1 += q.top().c, ans2 += q.top().b - b, b = q.top().b + q.top().d;
         q.pop();
     }
     ```

2. **LAB_Maple（4星）**
   - **亮点**：明确分离力量与精神处理阶段，用优先队列动态更新可选装备，代码可读性强。
   - **个人心得**：“处理完力量后，再次遍历装备”避免了全排列的暴力解法。

3. **doctorZ_（4星）**
   - **亮点**：直接模拟穿戴过程，通过优先队列维护精神需求，代码结构清晰。
   - **关键代码**：
     ```cpp
     while (p[j+1].a <= resa && j < n) q.push(p[++j]);
     if (resb < q.top().b) ansb += q.top().b - resb, resb = q.top().b;
     ```

---

### 最优思路与技巧
1. **贪心策略分离**：先解决力量问题，再在力量解的基础上处理精神问题。
2. **优先队列动态筛选**：在精神阶段，用优先队列维护当前可穿戴装备的最小精神需求。
3. **排序优化**：按力量升序排序确保贪心正确性，避免暴力枚举顺序。

---

### 类似题目推荐
1. **P1080 国王游戏**（贪心排序 + 高精度）
2. **P1230 智力大冲浪**（时间窗口 + 优先队列）
3. **P5019 铺设道路**（贪心模拟）

---

### 可视化与算法演示

#### 动画设计
1. **力量阶段**：
   - **网格视图**：装备按力量升序排列，用绿色高亮已穿戴装备，红色表示当前力量不足。
   - **动态增长**：力量条随穿戴装备逐步增长，补充差值时显示黄色闪烁提示。

2. **精神阶段**：
   - **优先队列可视化**：队列中装备按精神需求升序排列，用蓝色标记队首元素。
   - **穿戴过程**：每次从队列取出最小精神需求的装备，精神条增长并显示紫色动画。

#### 复古游戏化设计
- **8位像素风格**：力量/精神条用像素块表示，穿戴装备时播放“升级”音效。
- **AI自动演示**：自动按最优策略穿戴装备，右下角显示当前解的变化过程。

---

### 核心代码片段（火车司机）
```cpp
sort(p + 1, p + n + 1, [](buff x, buff y) {
    return x.a < y.a || (x.a == y.a && x.c > y.c);
});
for (int i = 1, a = 0; i <= n; ++i) {
    if (a < p[i].a) ans1 += p[i].a - a, a = p[i].a;
    a += p[i].c;
}
priority_queue<buff> q;
for (int i = 1; i <= n; ++i) {
    while (p[i].a > ans1) {
        ans1 += q.top().c, ans2 += q.top().b - b, b = q.top().b + q.top().d;
        q.pop();
    }
    q.push(p[i]);
}
```

---
处理用时：77.03秒
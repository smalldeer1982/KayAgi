# 题目信息

# [NOIP 2003 提高组] 神经网络

## 题目背景

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。



## 题目描述

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)

神经元（编号为 $i$）


图中，$X_1 \sim X_3$ 是信息输入渠道，$Y_1 \sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)

兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）

$$C_i=\left(\sum\limits_{(j,i) \in E} W_{ji}C_{j}\right)-U_{i}$$

公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。



## 说明/提示

**【题目来源】**

NOIP 2003 提高组第一题

## 样例 #1

### 输入

```
5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
```

### 输出

```
3 1
4 1
5 1
```

# AI分析结果



### 【唯一算法分类】拓扑排序

---

### 综合分析与结论

**核心思路**  
题目本质是带权有向无环图（DAG）上的分层计算问题。通过拓扑排序确保神经元按层次处理，每一层节点仅由上一层激活。核心算法流程如下：  
1. **预处理阈值**：非输入层节点初始状态直接减去阈值，输入层保持原值  
2. **拓扑排序**：用队列维护处理顺序，仅当节点状态 >0 时才向后传递信号  
3. **输出层筛选**：遍历所有出度为0的节点，输出状态 >0 的结果  

**关键难点与解决**  
- **输入层阈值处理**：通过判断初始状态是否为0，区分输入层与其他层  
- **信号传递条件**：仅在 `c[i] > 0` 时触发后续节点计算  
- **输出层判定**：通过统计出度是否为0快速筛选结果  

**可视化设计思路**  
1. **动态拓扑排序**：  
   - 用不同颜色区分未处理/已处理节点（灰色→绿色）  
   - 队列可视化：右侧显示当前队列元素，高亮队首  
2. **信号传递动画**：  
   - 当节点状态变为正时，触发脉冲动画（黄色闪光）  
   - 边权值以半透明线条显示，激活时变为红色  
3. **状态更新面板**：  
   - 每个节点下方实时显示当前状态值  
   - 阈值以 `(-U)` 形式显示在节点内部  

---

### 题解清单（≥4星）

1. **Lucaster_（5星）**  
   - 预处理阈值，队列拓扑排序逻辑清晰  
   - 使用结构体存储边信息，代码可读性高  
   - 关键调试心得：`from` 字段冗余，优化后更简洁  

2. **zzlzk（4.5星）**  
   - 反向建图+记忆化搜索实现拓扑逻辑  
   - 精简代码（仅30行），阈值处理巧妙  
   - 独特思路：递归计算节点状态  

3. **MakotoTSK（4星）**  
   - 明确分层处理思想，暴力枚举父节点  
   - 预处理层号加速计算，适合教学演示  
   - 调试教训：未处理输入层直接作为输出的情况  

---

### 最优思路提炼

1. **阈值预处理技巧**  
   ```cpp
   for(int i=1;i<=n;i++){
       scanf("%d%d",&c[i],&u);
       if(c[i]==0) c[i] -= u; //非输入层直接减阈值
       else q.push(i);        //输入层入队
   }
   ```

2. **拓扑排序核心逻辑**  
   ```cpp
   while(!q.empty()){
       int u = q.front(); q.pop();
       if(c[u] <=0) continue;
       for(Edge e : adj[u]){
           c[e.to] += e.w * c[u];
           if(--in[e.to] == 0){
               q.push(e.to);
               c[e.to] -= u[e.to]; //延迟减阈值
           }
       }
   }
   ```

3. **输出层快速筛选**  
   ```cpp
   vector<int> res;
   for(int i=1;i<=n;i++)
       if(out[i]==0 && c[i]>0) 
           res.push_back({i,c[i]});
   sort(res.begin(), res.end());
   ```

---

### 类似题目推荐

1. **P1113 杂务** - 拓扑排序求最长路径  
2. **P4017 最大食物链计数** - DAG拓扑排序计数  
3. **P1983 车站分级** - 拓扑排序层级划分  

---

### 可视化方案（复古像素风）

**动画要素**：  
1. **8位像素风格**：  
   - 神经元用16x16像素方块表示，输入层绿色，中间层蓝色，输出层红色  
   - 状态值以8x8像素数字显示在方块中心  

2. **信号传递特效**：  
   ```javascript
   function playPulseAnim(from, to) {
       const line = drawLine(from, to, '#FF5555'); 
       line.animate({opacity:0}, 500);
       from.addClass('pulsate');
   }
   ```

3. **音效设计**：  
   - 节点激活：8-bit "哔"声（Web Audio合成方波）  
   - 信号传递：短促"滴"声伴随脉冲动画  
   - 结果输出：经典FC过关音效  

**交互控制**：  
```html
<div id="control-panel">
    <button onclick="step()">单步执行</button>
    <input type="range" id="speed" min="100" max="2000">
    <label>AI自动演示 <input type="checkbox" id="auto"></label>
</div>
```

---

### 核心代码实现

```cpp
#include <queue>
#include <vector>
using namespace std;

struct Edge { int to, w; };
vector<Edge> adj[105];
int c[105], u[105], in[105], out[105];

void solve() {
    queue<int> q;
    for(int i=1; i<=n; i++){
        if(c[i] > 0) q.push(i);
        else c[i] -= u[i];
    }
    
    while(!q.empty()){
        int u = q.front(); q.pop();
        for(Edge e : adj[u]){
            c[e.to] += e.w * c[u];
            if(--in[e.to] == 0 && c[e.to] > 0){
                q.push(e.to);
            }
        }
    }
    
    bool hasOutput = false;
    for(int i=1; i<=n; i++){
        if(out[i]==0 && c[i]>0){
            printf("%d %d\n",i,c[i]);
            hasOutput = true;
        }
    }
    if(!hasOutput) puts("NULL");
}
```

---

通过拓扑排序逐层激活神经元，结合像素风可视化与音效反馈，可直观展现信号在网络中的传播过程。核心在于正确处理阈值与激活条件，确保计算顺序符合层次结构。

---
处理用时：67.45秒
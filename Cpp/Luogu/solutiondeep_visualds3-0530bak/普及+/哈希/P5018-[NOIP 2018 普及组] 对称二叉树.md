# 题目信息

# [NOIP 2018 普及组] 对称二叉树

## 题目背景

NOIP2018 普及组 T4

## 题目描述

一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树： 

1.  二叉树； 
2.  将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。   

下图中节点内的数字为权值，节点外的 $id$ 表示节点编号。  

![](https://cdn.luogu.com.cn/upload/image_hosting/nkln7z1l.png)

现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数最多。请输出这棵子树的节点数。   

注意：只有树根的树也是对称二叉树。本题中约定，以节点 $T$ 为子树根的一棵“子 树”指的是：节点$T$ 和它的全部后代节点构成的二叉树。 

## 说明/提示

**样例 1 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/4lfen5aa.png)    
最大的对称二叉子树为以节点 $2$ 为树根的子树，节点数为 $1$。   

**样例 2 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/vhzzc587.png)

最大的对称二叉子树为以节点 $7$ 为树根的子树，节点数为 $3$。 

**数据规模与约定**

共 $25$ 个测试点。    

$v_i ≤ 1000$。 

- 测试点 $1 \sim 3, n ≤ 10$，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。 
- 测试点 $4 \sim 8, n ≤ 10$。
- 测试点 $9 \sim 12, n ≤ 10^5$，保证输入是一棵“满二叉树” 。 
- 测试点 $13 \sim 16, n ≤ 10^5$，保证输入是一棵“完全二叉树”。
- 测试点 $17 \sim 20, n ≤ 10^5$，保证输入的树的点权均为 $1$。
- 测试点 $21 \sim 25, n ≤ 10^6$。

本题约定： 

层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 $1$。 
 
 树的深度：树中节点的最大层次称为树的深度。 
 
 满二叉树：设二叉树的深度为 $h$，且二叉树有 $2^h-1$ 个节点，这就是满二叉树。  

![](https://cdn.luogu.com.cn/upload/image_hosting/8tof1fxx.png)

完全二叉树：设二叉树的深度为 $h$，除第 $h$ 层外，其它各层的结点数都达到最大 个数，第 $h$ 层所有的结点都连续集中在最左边，这就是完全二叉树。  

![](https://cdn.luogu.com.cn/upload/image_hosting/ibo7js1f.png)

## 样例 #1

### 输入

```
2 
1 3 
2 -1 
-1 -1 
```

### 输出

```
1```

## 样例 #2

### 输入

```
10 
2 2 5 5 5 5 4 4 2 3 
9 10 
-1 -1 
-1 -1 
-1 -1 
-1 -1 
-1 2 
3 4 
5 6 
-1 -1 
7 8```

### 输出

```
3```

# AI分析结果



# [NOIP 2018 普及组] 对称二叉树

## 算法分类
无算法分类（树形结构递归判断）

---

## 综合分析与结论

### 核心思路
各题解围绕「递归判断子树对称性」展开，核心在于：
1. **对称性判断**：通过递归比较左子树的左节点与右子树的右节点，左子树的右节点与右子树的左节点
2. **剪枝优化**：预处理子树大小，仅对左右子树大小相等的节点进行递归判断，将时间复杂度优化至O(n log n)

### 关键难点与突破
1. **结构对称性验证**：通过交叉递归判断左右子树的结构和权值
2. **子树大小剪枝**：避免对明显不对称的子树进行无效递归
3. **哈希加速判断**：部分题解采用欧拉序+双哈希快速比较子树结构

### 可视化设计要点
1. **递归过程可视化**：
   - 使用不同颜色标记当前比较的左右子树节点
   - 动态绘制递归调用栈的深度变化
2. **像素化呈现**：
   ```javascript
   // 绘制节点示例
   function drawNode(x, y, val, isActive) {
     ctx.fillStyle = isActive ? '#FF5555' : '#55AAFF';
     ctx.fillRect(x*40, y*40, 30, 30); // 像素块风格
     ctx.fillText(val, x*40+5, y*40+20);
   }
   ```
3. **音效反馈**：
   - 正确匹配时播放8-bit上升音效
   - 匹配失败时播放短促低音
4. **自动演示模式**：
   - 按层序遍历顺序自动触发节点检查
   - 可调节单步执行速度观察递归细节

---

## 题解清单（≥4星）

### 1. 何俞均（哈希法） ★★★★☆
**核心亮点**：  
- 双欧拉序+双哈希快速比较子树结构  
- 实现O(n)预处理，O(1)判断  
**代码片段**：
```cpp
bool check(int x) {
    int ls = t[x].ch[0], rs = t[x].ch[1];
    return getHash(hs1[0], L[ls], R[ls]) == getHash(hs1[1], rL[rs], rR[rs]);
}
```

### 2. wsm52（递归法） ★★★★★
**核心亮点**：  
- 代码极简（仅20行核心逻辑）  
- 剪枝优化思路清晰  
**代码片段**：
```cpp
bool check(int l, int r) {
    if(l==-1 && r==-1) return true;
    if(l==-1 || r==-1 || v[l]!=v[r]) return false;
    return check(l_son[l], r_son[r]) && check(r_son[l], l_son[r]);
}
```

### 3. qhr2023（剪枝优化） ★★★★☆
**核心亮点**：  
- 数学证明时间复杂度  
- 启发式合并思想的巧妙应用  
**关键证明**：
```
∑(i=1~logn)∑(j=1~2^(i-1)) (2^(logn-i+1)-1) = O(n logn)
```

---

## 最优思路提炼

### 关键技巧
1. **对称性递归模板**：
```python
def is_sym(a, b):
    if not a and not b: return True
    if not a or not b: return False
    return a.val == b.val and is_sym(a.left, b.right) and is_sym(a.right, b.left)
```
2. **子树大小剪枝**：
```cpp
if(size[left] != size[right]) continue; // 快速跳过不匹配子树
```

### 思维突破点
将二叉树对称性问题转化为镜像节点的递归验证问题，通过交叉验证（左-右、右-左）实现结构对称性判断。

---

## 相似题目推荐
1. [P101 对称二叉树](https://www.luogu.com.cn/problem/P101)（基础对称判断）
2. [P104 二叉树的最大深度](https://www.luogu.com.cn/problem/P104)（树形结构递归应用）
3. [P105 从前序与中序遍历序列构造二叉树](https://www.luogu.com.cn/problem/P105)（树形结构重建）

---

## 个人心得摘录
> "考试时意识到暴力递归可能超时，但加上子树大小剪枝后意外AC。调试时发现忘记处理单子节点情况，后增加`if(size[left]!=size[right])`条件后通过" —— 摘自某未署名题解

> "哈希法理论高效但实现复杂，现场编码建议优先考虑递归+剪枝方案" —— 何俞均题解备注

---

## 可视化算法演示

### 动画流程设计
1. **初始化阶段**：
   - 按层序绘制二叉树，每个节点显示权值和子树大小
   - 用绿色边框标记当前检查的子树根节点

2. **递归验证阶段**：
   ```javascript
   // 伪代码示例
   async function check(a, b) {
     highlight(a, 'red'); // 高亮左节点
     highlight(b, 'blue'); // 高亮右节点
     await sleep(500);
     
     if(!a && !b) return true;
     if(!a || !b || a.val!=b.val) return false;
     
     return await check(a.left, b.right) 
         && await check(a.right, b.left);
   }
   ```

3. **结果反馈**：
   - 成功时整棵子树闪烁金色
   - 失败时节点变为灰色并播放震动效果

### 复古风格实现
1. **8-bit调色板**：
   - 节点色：#55AAFF（蓝）、#FF5555（红）  
   - 背景色：#2A2A2A（深灰）

2. **音效设计**：
   - 正确音效：方波短音（500Hz, 0.2s）
   - 错误音效：噪音脉冲（0.1s）

---

## 核心代码实现
**递归判断+剪枝（wsm52题解精简版）**
```cpp
int ans = 1;
void dfs(int x) {
    size[x] = 1;
    if(l[x]!=-1) dfs(l[x]), size[x] += size[l[x]];
    if(r[x]!=-1) dfs(r[x]), size[x] += size[r[x]];
}

bool check(int a, int b) {
    if(a==-1 && b==-1) return true;
    if(a==-1 || b==-1 || v[a]!=v[b]) return false;
    return check(l[a], r[b]) && check(r[a], l[b]);
}

int main() {
    dfs(1);
    for(int i=1; i<=n; ++i)
        if(check(l[i], r[i]))
            ans = max(ans, size[i]);
    cout << ans;
}
```

---
处理用时：74.27秒
# 题目信息

# 「Wdsr-1」小铃的书

## 题目背景

本居小铃在人间之里经营着一家名为“铃奈庵”的书店。店里井井有条地堆放着很多很多书。  

一天，魔理沙来铃奈庵借书，搞得店里十分混乱，魔理沙随身携带的魔导书与铃奈庵的书籍全都混在了一起。

## 题目描述

小铃一共有 $n-1$ 本书，每本书有一个编号 $a_i$，两本书属于同一种类当且仅当两本书的编号相同。  

由于小铃平时将这些书整理得井井有条，因此在小铃的 $n-1$ 本书中，每个种类的书的数量都恰好是 $k$ 的倍数，其中 $k$ 是一给出的常数。
 
现在，魔理沙的一本编号未知的魔导书与小铃的 $n-1$ 本书混在了一起，而魔理沙只有知道魔导书的编号才能将其找回。  

由于书的数量实在太多，魔理沙找到了你来帮忙，希望聪明的你能帮她求出混入的魔导书的编号。

**注意：魔理沙的魔导书可能与小铃的某本书有着相同的编号。**

## 说明/提示

#### 样例说明

样例 $1$ 中，小铃的书的编号为 $1,2,3$，分别有 $3$ 本。因此魔导书的编号为 $5$。

样例 $2$ 中，小铃的书的编号为 $1,4,5$，分别有 $4$ 本。因此魔导书的编号为 $1$。

------------------------

#### 数据范围及约定

**本题采取捆绑测试。**

$$
\def\arraystretch{1.5}
\def\cuteran{https://www.luogu.com.cn/paste/iyzwht7l}
\begin{array}{|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{分值} \cr\hline
1 & 10^5 & 50 \cr\hline
2 & 10^6 & 25 \cr\hline
3 & 10^7 & 25 \cr\hline
\end{array}
$$

对于全部数据，保证 $1 \le n \le 10^7$  ，$2 \le k \le 10^3$  ，$1 \le a_i \le 10^{18}$。保证数据合法，即有且只有一本混入的魔导书。   

-----------------

#### 提示

**请注意时空限制。**

**使用 $\texttt{cin}$ / $\texttt{cout}$ 可能超时，这里给出一个快速读入模板：**

```cpp
long long qread(){
    long long w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
```

**或者使用这份模板：**

```cpp
typedef long long LL;
#define gc pa==pb&&(pb=(pa=buf)+fread(buf,1,100000,stdin),pa==pb)?EOF:*pa++
static char buf[100000],*pa(buf),*pb(buf);
inline LL readint() {
	LL x=0;char c=gc;
	while(c<'0'||c>'9')c=gc;
	for(;c>='0'&&c<='9';c=gc)x=x*10+(c&15);
	return x;
}
```

**其中，在开启 O2 开关的前提下，前者在极限数据下的读入要 $500\texttt{ms}$，而后者需要 $300\texttt{ms}$。也就是说，你的程序至少有 $500\sim 700\texttt{ms}$ 的时间执行主要算法。**

## 样例 #1

### 输入

```
10 3
1 1 2 2 3 5 3 2 1 3```

### 输出

```
5```

## 样例 #2

### 输入

```
13 4
1 1 4 5 1 4 1 4 4 5 5 5 1```

### 输出

```
1```

# AI分析结果



## 唯一算法分类
位运算与分块统计

---

## 综合分析与结论

### 核心思路与难点
**题目核心**：找到导致总数量不是k的倍数的唯一编号  
**关键观察**：所有合法编号的各进制位总和必须是k的倍数  
**核心难点**：  
1. 大规模数据下（n=1e7）需要O(n)算法  
2. 数值范围极大（1e18）无法直接存储出现次数  
**突破方案**：  
将每个数拆分为固定位数的多个块（如16位块），统计每个块的出现次数模k的结果，最后组合各块的余数得到答案

### 算法流程可视化设计
**动画方案**：  
1. 创建4个可视化区域对应4个分块统计器  
2. 每个数输入时以像素块形式拆分成4段（每段16位）  
3. 每段对应的统计器数值+1时闪烁黄色，模k归零时变绿  
4. 最终答案区域从右到左拼接待高亮的红色块  
**复古风格**：  
- 使用8位红白机风格的16色调色板  
- 每个统计器用像素网格表示（256x256网格）  
- 关键操作伴随8-bit音效（分解音、模运算音、答案确认音）

---

## 题解清单（≥4星）

### [★★★★★] wyd_forever 的分块位运算解法
- **亮点**：将数值拆分为4个8位块，用位运算快速提取  
- **优化**：O(4n)时间复杂度，完美匹配1e7数据规模  
- **代码**：使用65536进制拆分，直接位与和移位操作

### [★★★★☆] 朱屹帆 的百进制拆分法  
- **亮点**：直观的十进制思维拆分（100进制）  
- **优势**：代码可读性强，9次循环处理每个数  
- **注意点**：实际运行效率略低于位运算版本

### [★★★★☆] yurzhang 的Barrett Reduction优化  
- **创新**：通过数学方法消除除法/取模运算  
- **价值**：提供对底层运算优化的深入思考  
- **局限**：当前数据已被加强卡掉，但思维值得学习

---

## 核心代码实现

### 位运算分块版（wyd_forever）
```cpp
typedef unsigned long long LL;
const int Base = 1<<8, p=4;
int cnt[p][Base]; // 分块计数器

int main() {
    LL n=read(), k=read();
    for(LL i=1; i<=n; ++i) {
        LL x=read();
        for(int j=0; j<p; ++j) { // 拆分为4个8位块
            ++cnt[j][x & 255];   // 取低8位
            x >>= 8;            // 右移处理下一个块
        }
    }
    LL ans=0;
    for(int j=0; j<p; ++j)
        for(int i=0; i<Base; ++i)
            if(cnt[j][i]%k)
                ans |= (LL)i << (j*8); // 拼接结果
    cout << ans;
}
```

### 可视化关键JS片段
```javascript
// 8位风格动画核心逻辑
function processNumber(x) {
  for(let j=0; j<4; j++) {
    const part = x & 0xFF;
    counters[j][part] = (counters[j][part] + 1) % k;
    playSound('blip'); // 分解音效
    x >>= 8;
  }
  updateDisplay(); // 刷新像素画风显示
}
```

---

## 相似题目推荐
1. **P1461 海明码** - 位运算与编码校验  
2. **P2119 魔法阵** - 分块统计与组合数学  
3. **P1360 均分纸牌** - 模运算与平衡思想

---

## 可视化设计要点
1. **像素画布**：400x300 Canvas，16色复古调色板  
2. **音效设计**：  
   - `blip.wav`（分解操作）  
   - `mod.wav`（模运算归零）  
   - `success.wav`（答案确定）  
3. **自动演示**：  
   - 按F1开启AI模式，自动生成测试数据并演示  
   - 空格键暂停/继续，方向键控制演示速度  
4. **积分系统**：  
   - 正确识别一个块+100分  
   - 连续正确获得连击加成  
   - 错误操作触发8-bit爆炸动画

---

## 总结提炼
**关键思维**：  
- **分治思想**：将大问题分解为独立处理的子问题  
- **位运算优化**：利用计算机底层特性提升效率  
**实现技巧**：  
1. 选择2^8等进制便于位操作  
2. 多维数组存储分块统计结果  
3. 最终结果通过位移运算快速拼接  
**扩展应用**：  
类似思想可用于大规模数据的特征统计、哈希分桶等场景

---
处理用时：66.59秒
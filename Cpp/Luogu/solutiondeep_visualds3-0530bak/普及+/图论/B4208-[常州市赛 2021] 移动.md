# 题目信息

# [常州市赛 2021] 移动

## 题目背景

搬运自 <http://czoj.com.cn/p/444>。数据为民间数据。

## 题目描述

小 $\text X$ 学校的教学楼是一栋 $H$ 层的建筑。学生在同一楼层间可以自由移动，但是只有通过爬楼梯才可以上下楼层。  
让我们把教学楼抽象成一个有 $H\times M$ 个格子的矩形，学生可以从一个单元格上花费 $1$ 秒移动到上下左右的相邻单元格上。学生在水平方向上的移动是没有限制的（除了不能摔出楼外），但只有在有楼梯相连的时候才能进行竖直移动。一个楼梯会连接同一列中的一段连续楼层，**且一列中只会有一个楼梯**。**对于这一部分叙述可以通过样例理解**。  
现在有 $T$ 个学生，每个人都希望从一个位置走到另一个位置上。他们想问问小 $\text X$ 最短需要花费多长时间。

## 说明/提示

### 样例解释
![](https://cdn.luogu.com.cn/upload/image_hosting/tdx69my8.png)
### 数据范围  
对于所有数据，$1\le x\le M$ 且所有 $x$ 各不相同，$1\le h_1<h_2\le H,1\le s_x,t_x\le M,1\le s_y,t_y\le H,1\le H,M\le 10^5,1\le K\le 300,1\le T\le 5 \times 10^4$。

## 样例 #1

### 输入

```
9 8
2
3 5 8
6 2 5
3
6 8 5 7
4 6 7 2
1 9 8 1```

### 输出

```
6
9
-1```

# AI分析结果



---

### **唯一算法分类**  
无算法分类  

---

### **综合分析与结论**  
#### **核心思路**  
1. **同一层处理**：若起点与终点楼层相同，直接返回横向距离。  
2. **跨层枚举楼梯**：枚举每个楼梯，判断其是否覆盖起点和终点的楼层。若满足，计算路径时间：  
   - 横向移动到楼梯列的时间  
   - 竖直移动的楼层差时间  
   - 横向移动到终点的列时间  
3. **取最小值**：在所有符合条件的楼梯中取最短时间，若无则返回 `-1`。  

#### **解决难点**  
- **高效性**：通过预处理楼梯信息，每个查询仅需 `O(K)` 时间（`K` 为楼梯数），适用于大规模数据。  
- **正确性**：严格判断楼梯覆盖区间，确保竖直移动合法。  

#### **可视化设计**  
- **动画流程**：  
  1. 显示起点和终点位置。  
  2. 高亮每个楼梯列，动态绘制起点→楼梯列→终点的路径。  
  3. 颜色区分有效/无效路径（绿色有效，红色无效）。  
- **像素风格**：  
  - 楼层用网格表示，楼梯列用黄色像素块标记。  
  - 路径用蓝色像素块逐步填充，音效提示路径有效性。  

---

### **题解清单 (≥4星)**  
#### **题解 1 ⭐⭐⭐⭐⭐**  
**关键亮点**：  
- 简洁处理同一层情况。  
- 枚举楼梯时直接判断覆盖区间，时间复杂度优化。  
- 代码可读性强，无冗余逻辑。  

**代码片段**：  
```cpp  
#include <bits/stdc++.h>
using namespace std;

struct Stair { int x, h1, h2; };

int main() {
    int H, M, K, T;
    cin >> H >> M >> K;
    vector<Stair> stairs(K);
    for (int i = 0; i < K; i++) {
        int x, h1, h2;
        cin >> x >> h1 >> h2;
        stairs[i] = {x, h1, h2};
    }
    cin >> T;
    while (T--) {
        int sx, sy, tx, ty;
        cin >> sx >> sy >> tx >> ty;
        if (sy == ty) {
            cout << abs(sx - tx) << "\n";
            continue;
        }
        int ans = INT_MAX;
        for (auto &s : stairs) {
            if (s.h1 <= sy && sy <= s.h2 && s.h1 <= ty && ty <= s.h2) {
                int cost = abs(sx - s.x) + abs(tx - s.x) + abs(sy - ty);
                ans = min(ans, cost);
            }
        }
        cout << (ans == INT_MAX ? -1 : ans) << "\n";
    }
    return 0;
}
```  

---

### **最优思路提炼**  
**关键技巧**：  
- **枚举中间点**：利用楼梯数量较少的特点，将问题转换为“枚举中转列”的最短路径问题。  
- **区间覆盖判断**：直接判断起点和终点是否在楼梯的覆盖区间内，避免复杂图遍历。  

---

### **同类型题与套路**  
- **中间点枚举**：如中转站、多段跳转问题，均需枚举有限的关键节点。  
- **分层处理**：将路径拆分为水平与竖直部分，独立计算后合并。  

---

### **推荐题目**  
1. **P1354 房间最短路问题**（网格中的最短路径）  
2. **P1037 产生数**（有限中间状态枚举）  
3. **P1144 最短路计数**（多维度最短路变种）  

---

### **可视化与算法演示**  
#### **动画方案**  
1. **初始化**：绘制 `H×M` 网格，标记楼梯列为黄色。  
2. **单步执行**：  
   - 红色方块标记起点，绿色方块标记终点。  
   - 枚举每个楼梯时，高亮其列，计算路径并显示。  
3. **音效反馈**：  
   - 有效路径播放“滴”声，无效路径播放“哔”声。  
4. **自动模式**：按楼梯顺序自动播放所有可能路径，最终显示最短路径。  

#### **复古像素风格**  
- **颜色方案**：8色调色板（黑背景、蓝路径、黄楼梯、红/绿起点终点）。  
- **音效**：使用 Web Audio API 播放 8-bit 音效，增强交互感。  

---

### **总结**  
本题通过预处理楼梯信息，巧妙利用枚举法在有限时间内解决大规模数据的最短路径问题。核心在于将复杂移动拆分为水平与竖直部分，并通过区间覆盖判断快速筛选有效路径。

---
处理用时：286.97秒
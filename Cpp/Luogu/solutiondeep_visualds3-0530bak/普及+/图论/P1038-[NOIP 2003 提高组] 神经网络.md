# 题目信息

# [NOIP 2003 提高组] 神经网络

## 题目背景

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。



## 题目描述

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)

神经元（编号为 $i$）


图中，$X_1 \sim X_3$ 是信息输入渠道，$Y_1 \sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)

兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）

$$C_i=\left(\sum\limits_{(j,i) \in E} W_{ji}C_{j}\right)-U_{i}$$

公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。



## 说明/提示

**【题目来源】**

NOIP 2003 提高组第一题

## 样例 #1

### 输入

```
5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
```

### 输出

```
3 1
4 1
5 1
```

# AI分析结果



### **算法分类**  
拓扑排序

---

### **综合分析与结论**  
#### **核心思路**  
1. **拓扑排序处理层次依赖**：神经元分层传递，确保前驱节点先处理完毕。  
2. **输入层与阈值预处理**：输入层神经元初始状态非零，无需减阈值；非输入层在初始化时直接减去阈值。  
3. **状态传递条件**：仅当神经元状态 `C[i] > 0` 时向下传递信号。  
4. **输出层判定**：出度为0的节点为输出层，需检查状态是否正。  

#### **可视化设计**  
- **动画方案**：  
  - **节点状态变化**：用颜色区分未处理（灰）、激活（绿）、非激活（红）。  
  - **队列动态**：显示队列中的节点，高亮当前处理的节点。  
  - **信号传递**：用箭头动画表示权值累加过程。  
- **复古像素风格**：  
  - **Canvas绘制**：网格布局节点，8位音效（如入队“滴”声、传递“哔”声）。  
  - **自动演示**：按拓扑序逐步激活节点，支持暂停/步进。  

---

### **题解清单 (≥4星)**  
1. **Lucaster_ (5星)**  
   - **亮点**：代码简洁，预处理阈值，队列拓扑排序逻辑清晰。  
   - **关键代码**：  
     ```cpp  
     while (!q.empty()) {  
         h = q.front(); q.pop();  
         for (遍历邻接边) {  
             if (c[h] <= 0) continue;  
             c[t] += w * c[h];  // 状态传递  
             if (!vis[t]) q.push(t);  
         }  
     }  
     ```  

2. **zzlzk (4.5星)**  
   - **亮点**：反向建图，记忆化搜索递归实现拓扑序，避免显式队列。  
   - **关键代码**：  
     ```cpp  
     int DFS(int p) {  
         if (vis[p]) return c[p];  
         for (遍历前驱节点)  
             c[p] += DFS(前驱) * 边权;  
         return max(0, c[p]);  
     }  
     ```  

3. **ghj1222 (4星)**  
   - **亮点**：标准拓扑排序流程，显式维护入度数组。  
   - **个人心得**：  
     > “输入层的阈值是陷阱！必须特判，否则第五个点WA到怀疑人生。”  

---

### **最优技巧提炼**  
1. **阈值预处理**：非输入层初始化时直接减阈值，简化后续计算。  
2. **队列拓扑排序**：确保节点按层次处理，避免重复更新。  
3. **输出层快速判定**：维护出度数组，最终遍历出度为0的节点。  

---

### **同类型题与算法套路**  
- **通用解法**：DAG上的依赖处理（拓扑排序+动态规划/状态传递）。  
- **类似题目**：  
  - **P1113 杂务**：拓扑排序求最长路径。  
  - **P4017 最大食物链计数**：拓扑排序+路径计数。  
  - **P1983 车站分级**：隐式建图+拓扑层次划分。  

---

### **推荐题目**  
1. **P1113**（拓扑排序+DP）  
2. **P4017**（拓扑排序+计数）  
3. **P1983**（拓扑排序+层次分析）  

---

### **可视化代码片段 (JS/Canvas)**  
```javascript  
// 初始化像素画布  
const canvas = document.getElementById("pixel-canvas");  
const ctx = canvas.getContext("2d");  
const nodes = [ /* 节点坐标及状态 */ ];  

// 绘制节点（8位风格）  
function drawNode(node) {  
    ctx.fillStyle = node.active ? "#00FF00" : "#FF0000";  
    ctx.fillRect(node.x, node.y, 16, 16); // 16x16像素方块  
}  

// 动画更新（队列处理）  
function animateStep() {  
    const current = queue.shift();  
    highlight(current);  // 高亮当前节点  
    nodes[current].neighbors.forEach(updateNeighbor);  
    requestAnimationFrame(animateStep);  
}  
```  

---

### **总结**  
本题通过拓扑排序确保神经元按层次处理，预处理阈值和输入层是解题关键。可视化设计可通过复古像素动画直观展示信号传递过程，辅以音效增强交互体验。

---
处理用时：67.32秒
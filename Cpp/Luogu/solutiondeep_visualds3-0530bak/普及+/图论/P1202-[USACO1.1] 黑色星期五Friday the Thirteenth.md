# 题目信息

# [USACO1.1] 黑色星期五Friday the Thirteenth

## 题目描述

$13$ 号又是一个星期五，那么 $13$ 号在星期五比在其他日子少吗？  

为了回答这个问题，写一个程序，要求计算每个月的十三号落在周一到周日的次数。给出 $n$ 年的一个周期，要求计算 $1900$ 年 $1$ 月 $1$ 日至 $1900+n-1$ 年 $12$ 月 $31$ 日中十三号落在周一到周日的次数。

这里有一些你要知道的:

1. $1900$ 年 $1$ 月 $1$ 日是星期一。
2. $4,6,11$ 和 $9$ 月有 $30$ 天，其他月份除了 $2$ 月都有 $31$ 天，闰年 $2$ 月有 $29$ 天，平年 $2$ 月有 $28$ 天。
3. 年份可以被 $4$ 整除的为闰年（$1992=4\times 498$ 所以 $1992$ 年是闰年，但是 $1990$ 年不是闰年）。
4. 以上规则不适合于世纪年。可以被 $400$ 整除的世纪年为闰年，否则为平年。所以，$1700,1800,1900,2100$ 年是平年，而 $2000$ 年是闰年。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 400$。

题目翻译来自NOCOW。

USACO Training Section 1.1

## 样例 #1

### 输入

```
20
```

### 输出

```
36 33 34 33 35 35 34
```

# AI分析结果



## 算法分类
日期处理（数学公式/递推）

---

## 题解思路与解决难点

### 核心算法流程
1. **日期计算核心**：快速确定每月13号的星期数
2. **闰年处理**：区分世纪年（%400）与普通闰年（%4且!%100）
3. **星期递推**：利用相邻月份13号的星期数差值 = 前一月天数%7

### 关键实现差异对比
| 题解类型         | 时间复杂度 | 空间复杂度 | 代码复杂度 | 核心思路                     |
|------------------|------------|------------|------------|------------------------------|
| 暴力逐天模拟     | O(365n)    | O(1)       | 极高       | 遍历所有日期判断13号         |
| 基姆拉尔森公式   | O(12n)     | O(1)       | 低         | 数学公式直接计算星期数       |
| 月份递推法       | O(12n)     | O(1)       | 中         | 利用每月天数%7递推星期数变化 |

### 最优思路提炼
1. **递推式优化**：
```cpp
// 每月递推公式
next_month_13_week = (current_week + month_days) % 7
```
2. **基姆拉尔森公式**：
```cpp
int week_day(int y, int m, int d) {
    if(m < 3) m += 12, y--;
    return (d + 2*m + 3*(m+1)/5 + y + y/4 - y/100 + y/400 + 1) % 7;
}
```

---

## 高分题解推荐 (≥4★)

### 1. HEIGE（基姆拉尔森公式） ★★★★★
```cpp
int week_day(int y, int m, int d) {
    if(m < 3) m += 12, y--;
    return (d + 2*m + 3*(m+1)/5 + y + y/4 - y/100 + y/400 + 1) % 7;
}
```
**亮点**：公式直接计算每月13号的星期数，时间复杂度最优

### 2. buickboy（月份递推法） ★★★★☆
```cpp
for(int i=1900;i<=1900+n-1;i++){
    if(闰年) m[2]=29;
    for(int j=1;j<=12;j++){
        x = (上月天数 + x) % 7;
        cnt[x]++;
    }
}
```
**亮点**：空间换时间，预处理每月天数模7值

### 3. 早右昕（跨月差值法） ★★★★☆
```cpp
void operator++(date &a) {
    bool leap = 闰年判断;
    a.ww += month_days[leap][a.mm++]; 
    a.ww %= 7;
}
```
**亮点**：运算符重载实现日期递增，代码结构优雅

---

## 可视化设计

### 动画演示方案
```javascript
// 核心逻辑伪代码
function animate() {
    highlight(current_month); // 红色高亮当前月份
    playSound('click');       // 操作音效
    let days = getMonthDays(year, month);
    week = (week + days) % 7; // 递推公式
    updateCounter(week);      // 更新统计计数器
    if(month == 12) year++;   // 年递增逻辑
}
```

### 复古像素风格实现
```css
/* 8位风格CSS */
.pixel-font { font-family: 'Press Start 2P', cursive; }
.date-box {
    width: 32px; height: 32px;
    background: #6B8C42; /* 复古绿 */
    border: 2px solid #4A752D;
}
```

### 交互功能
- **步进控制**：Space键逐月执行
- **音效反馈**：每次月份切换播放8bit音效
- **自动模式**：按A键启动自动播放（速度可调）

---

## 相似题目推荐
1. P1978 [NOIP2013 普及组] 日期计算
2. P1007 [NOIP2007 提高组] 统计天数
3. P1271 日历问题

---

## 关键代码片段
基姆拉尔森公式实现：
```cpp
#include<iostream>
using namespace std;
int week_day(int y, int m, int d) {
    if(m < 3) m += 12, y--;
    return (d + 2*m + 3*(m+1)/5 + y + y/4 - y/100 + y/400 + 1) % 7;
}
int main() {
    int n, cnt[7] = {0};
    cin >> n;
    for(int y=1900; y<1900+n; y++)
        for(int m=1; m<=12; m++)
            cnt[week_day(y,m,13)]++;
    cout << cnt[6] << " "<<cnt[0]<<" "<<cnt[1]<<" "<<cnt[2]<<" "<<cnt[3]<<" "<<cnt[4]<<" "<<cnt[5];
}
```

递推法核心逻辑：
```cpp
int m[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int week = 3; // 1899-12-13是周三
for(int y=1900; y<1900+n; y++){
    if(闰年) m[2]=29;
    for(int mon=1; mon<=12; mon++){
        cnt[week]++;
        week = (week + m[mon]) % 7;
    }
}
```

---
处理用时：72.43秒
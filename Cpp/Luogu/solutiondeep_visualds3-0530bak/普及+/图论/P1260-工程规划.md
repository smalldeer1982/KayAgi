# 题目信息

# 工程规划

## 题目描述

造一幢大楼是一项艰巨的工程，它是由 $n$ 个子任务构成的，给它们分别编号 $1,2,\cdots,n\ (5≤n≤1000)$。由于对一些任务的起始条件有着严格的限制，所以每个任务的起始时间 $T_1,T_2,\cdots,T_n$ 并不是很容易确定的(但这些起始时间都是非负整数，因为它们必须在整个工程开始后启动)。例如：挖掘完成后，紧接着就要打地基；但是混凝土浇筑完成后，却要等待一段时间再去掉模板。

这种要求就可以用 $m\ (5≤m≤5000)$ 个不等式表示，不等式形如 $T_i-T_j≤b$ 代表 $i$ 和 $j$ 的起始时间必须满足的条件。每个不等式的右边都是一个常数 $b$，这些常数可能不相同，但是它们都在区间 $(-100,100)$ 内。

你的任务就是写一个程序，给定像上面那样的不等式，找出一种可能的起始时间序列 $T_1,T_2,\cdots,T_n$，或者判断问题无解。对于有解的情况，要使最早进行的那个任务和整个工程的起始时间相同，也就是说，$T_1,T_2,\cdots,T_n$ 中至少有一个为 $0$。


## 说明/提示

由@zhouyonglong提供SPJ


## 样例 #1

### 输入

```
5 8
1 2 0
1 5 -1
2 5 1
3 1 5
4 1 4
4 3 -1
5 3 -1
5 4 -3```

### 输出

```
0
2
5
4
1
```

## 样例 #2

### 输入

```
5 5
1 2 -3
1 5 -1
2 5 -1
5 1 -5
4 1 4```

### 输出

```
NO SOLUTION
```

# AI分析结果



---

**算法分类**：差分约束系统

---

### **题解思路与核心难点**

1. **核心思路**  
   - 将每个不等式 \(T_i - T_j \leq b\) 转化为有向边 \(j \rightarrow i\)（权值 \(b\)），构建差分约束图。  
   - 添加超级源点 \(S\)（如编号 \(n+1\)），连接所有节点确保图的连通性。  
   - 用 **SPFA** 求解从 \(S\) 出发的单源最短路，若存在负环则无解，否则调整所有节点值使其非负且至少一个为0。

2. **解决难点**  
   - **负环判定**：通过统计节点入队次数，若超过 \(n\) 次则存在负环。  
   - **解的非负性**：找到所有节点距离的最小值，整体减去该值以确保至少一个节点为0。

---

### **高分题解推荐（≥4星）**

1. **作者：L_M_（5星）**  
   - **亮点**：清晰的SPFA实现，超级源点处理图的连通性，负环判断逻辑简洁。  
   - **代码片段**：  
     ```cpp
     void spfa(int s) {
         queue<int> q;
         memset(dis, 0x3f, sizeof(dis));
         dis[s] = 0; q.push(s);
         while (!q.empty()) {
             int u = q.front(); q.pop();
             if (popst[u]++ > n) { /* 无解处理 */ }
             for (int i = fir[u]; i; i = e[i].next) {
                 int v = e[i].to, w = e[i].cost;
                 if (dis[v] > dis[u] + w) {
                     dis[v] = dis[u] + w;
                     q.push(v);
                 }
             }
         }
     }
     ```

2. **作者：SDqwq（4星）**  
   - **亮点**：代码可读性高，通过 `minm` 统一调整解的非负性，注释详细。  
   - **关键技巧**：通过 `minm = min(dis[i])` 快速计算偏移量。

3. **作者：一只书虫仔（4星）**  
   - **亮点**：简洁的SPFA实现，注释中强调“最大路”和“负环”的关系，适合深入理解差分约束。

---

### **最优思路提炼**

1. **图建模**  
   - 不等式 \(T_i - T_j \leq b \Rightarrow\) 建边 \(j \rightarrow i\)（权 \(b\)）。  
   - 超级源点 \(S \rightarrow\) 所有节点（权0），确保图的连通性。

2. **SPFA优化**  
   - 队列优化松弛过程，实时检测负环。  
   - 时间复杂度 \(O(m)\)，适合稀疏图。

3. **解的非负调整**  
   - 计算所有节点距离的最小值 \(min\_val\)，输出时每个节点减去 \(min\_val\)。

---

### **同类型题目推荐**

1. **P5960 【模板】差分约束算法**  
   - 差分约束的模板题，直接应用相同思路。

2. **P1993 小K的农场**  
   - 类似差分约束，含等式和不等式的混合约束。

3. **P3275 [SCOI2011] 糖果**  
   - 差分约束的扩展，需处理严格不等式和长链优化。

---

### **可视化设计思路**

1. **动画流程**  
   - **步骤1**：展示不等式转换为边的过程（如 \(T_1 - T_2 \leq 3\) 显示为节点2→1，权3）。  
   - **步骤2**：超级源点 \(S\) 连接所有节点（灰色虚线箭头）。  
   - **步骤3**：动态演示SPFA队列变化，高亮当前松弛的边（如红色边表示正在松弛）。  
   - **步骤4**：若检测到负环，播放“失败音效”并标红环路径。  
   - **步骤5**：调整解时，用渐变色区分原始值和偏移后的结果。

2. **复古像素风格**  
   - **颜色方案**：8位色（绿：正常节点，红：负环，黄：当前处理边）。  
   - **音效**：  
     - 松弛成功：短促“滴”声。  
     - 负环检测：低频“嗡”声。  
   - **Canvas交互**：  
     - 点击“单步”按钮逐步执行SPFA。  
     - 拖动滑块调整动画速度。

---

### **代码片段（核心逻辑）**

```cpp
// SPFA核心逻辑（作者：L_M_）
void spfa(int s) {
    queue<int> q;
    memset(dis, 0x3f, sizeof(dis));
    dis[s] = 0; q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        if (popst[u]++ > n) { 
            printf("NO SOLUTION"); 
            return; 
        }
        for (int i = fir[u]; i; i = e[i].next) {
            int v = e[i].to, w = e[i].cost;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!instack[v]) {
                    q.push(v);
                    instack[v] = 1;
                }
            }
        }
    }
    // 调整解为非负
    int minm = *min_element(dis + 1, dis + n + 1);
    for (int i = 1; i <= n; i++) 
        printf("%d\n", dis[i] - minm);
}
```

---

**总结**：差分约束的核心是将不等式转化为图边，通过最短路算法求解。超级源点解决连通性问题，负环检测确保解的存在性，解的偏移保证非负性。可视化设计通过动态展示SPFA和复古交互增强理解。

---
处理用时：87.68秒
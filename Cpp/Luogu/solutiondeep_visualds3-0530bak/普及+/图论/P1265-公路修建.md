# 题目信息

# 公路修建

## 题目描述

某国有 $n$ 个城市，它们互相之间没有公路相通，因此交通十分不便。为解决这一“行路难”的问题，政府决定修建公路。修建公路的任务由各城市共同完成。

修建工程分若干轮完成。在每一轮中，每个城市选择一个与它最近的城市，申请修建通往该城市的公路。政府负责审批这些申请以决定是否同意修建。

政府审批的规则如下：

1. 如果两个或以上城市申请修建同一条公路，则让它们共同修建；
2. 如果三个或以上的城市申请修建的公路成环。如下图，A 申请修建公路 AB，B 申请修建公路 BC，C 申请修建公路 CA。则政府将否决其中最短的一条公路的修建申请； 
3. 其他情况的申请一律同意。

![](https://cdn.luogu.com.cn/upload/image_hosting/apng39qc.png)

一轮修建结束后，可能会有若干城市可以通过公路直接或间接相连。这些可以互相连通的城市即组成“城市联盟”。在下一轮修建中，每个“城市联盟”将被看作一个城市，发挥一个城市的作用。

当所有城市被组合成一个“城市联盟”时，修建工程也就完成了。

你的任务是根据城市的分布和前面讲到的规则，计算出将要修建的公路总长度。

## 说明/提示

修建的公路如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/p0dtxt2l.png)

## 样例 #1

### 输入

```
4

0 0

1 2

-1 2

0 4```

### 输出

```
6.47```

# AI分析结果



## 唯一算法分类
最小生成树（Prim算法）

---

## 题解思路与算法要点

### 核心思路
题目要求通过多轮修路最终连通所有城市。通过分析规则发现，规则二（成环否决最短边）在实际情况中无法成立，因此问题等价于求完全图的最小生成树。由于边数过多（约2500万条），需采用Prim算法以避免存储所有边，并在计算过程中动态生成边权。

### 算法实现要点
1. **动态计算距离**：不预存所有边，每次需要时用欧几里得距离公式计算。
2. **Prim算法流程**：
   - 初始化距离数组`dis[]`，起点设为0，其余为极大值。
   - 每次选择未访问的最近点加入生成树。
   - 用新加入的点更新其他点的最短距离。
3. **数据类型处理**：坐标差平方可能溢出`int`，需用`long long`存储中间结果，最终用`sqrt`转为`double`。

### 解决难点
- **内存优化**：完全图边数爆炸，动态计算避免存储。
- **正确性证明**：规则二无法成立，确保直接求MST的正确性。

---

## 题解评分（≥4星）

1. **MY（赞375）⭐⭐⭐⭐⭐**  
   - 思路清晰，完整推导规则二无效性。
   - 代码简洁，注释详细，完全体现Prim核心逻辑。
   - 动态计算距离，避免MLE。

2. **EricWay1024（赞111）⭐⭐⭐⭐**  
   - 深入解释Prim贪心思想（树智能生长）。
   - 强调稠密图现算边权的优势。
   - 代码优化距离计算，使用整数运算延迟开根。

3. **无意识躺枪人（赞27）⭐⭐⭐⭐**  
   - 数学证明规则二不可行，明确问题本质。
   - 代码精简，仅保留核心逻辑。
   - 显式处理坐标差平方，避免溢出。

---

## 最优思路与技巧提炼

### 关键思路
- **规则二无效性**：通过反证法证明三个城市成环时边权相等，否决任意一条不影响MST总权值。
- **动态边权计算**：在Prim的更新循环中实时计算两点距离，公式为：  
  `distance = sqrt((x_i - x_j)^2 + (y_i - y_j)^2)`  
  其中平方运算用`long long`存储，避免溢出。

### 代码片段（核心逻辑）
```cpp
void Prim() {
    dis[1] = 0.0;
    for (int i = 1; i <= n; i++) {
        int curr = -1;
        double min_dist = INF;
        // 选择最近点
        for (int j = 1; j <= n; j++) {
            if (!vis[j] && dis[j] < min_dist) {
                min_dist = dis[j];
                curr = j;
            }
        }
        vis[curr] = true;
        ans += dis[curr];
        // 动态更新距离
        for (int j = 1; j <= n; j++) {
            double dist = sqrt(pow(x[curr] - x[j], 2) + pow(y[curr] - y[j], 2));
            if (!vis[j] && dist < dis[j]) {
                dis[j] = dist;
            }
        }
    }
}
```

---

## 同类型题与算法套路

### 类似算法套路
- **稠密图MST**：优先选择Prim算法，避免Kruskal的排序开销。
- **动态边权计算**：适用于边权可快速计算的场景（如几何问题）。

### 推荐题目
1. **P1547 Out of Hay**  
   - 求MST中的最大边，适合练习Kruskal。
2. **P2330 [SCOI2005] 繁忙的都市**  
   - MST性质应用，求最小生成树边数。
3. **P1991 无线通讯网**  
   - 几何MST问题，需动态计算边权。

---

## 个人心得摘录

- **调试教训**：坐标差平方可能溢出`int`，需用`long long`存储后再转`double`（如`Sci_M3`题解）。
- **优化技巧**：堆优化Prim在5000节点下常数过大，不如朴素实现（`Suzt_ilymtics`题解）。

---

## 可视化与算法演示

### 动画设计
1. **像素风格呈现**：
   - 城市显示为8-bit像素点，已加入生成树的点标记为绿色，候选点为红色。
   - 当前选中点闪烁，更新边显示为黄色线段。

2. **关键步骤演示**：
   - **步骤1**：初始化所有点为白色，起点标记为绿色。
   - **步骤2**：红色候选点中显示距离值，选中最小值后变绿。
   - **步骤3**：黄色线条表示新加入边，更新相邻点的距离值。

3. **交互控制**：
   - **速度调节**：滑块控制动画速度（0.5x~5x）。
   - **步进模式**：按空格单步执行，显示当前操作说明。

### 音效设计
- **选中点**：8-bit“哔”声。
- **更新距离**：短促“滴”声。
- **完成MST**：播放胜利音效。

---

## 核心代码实现

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

const int MAXN = 5005;
double x[MAXN], y[MAXN], dis[MAXN];
bool vis[MAXN];

double distance(int a, int b) {
    return sqrt((x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]));
}

void prim(int n) {
    fill(dis, dis + MAXN, 1e18);
    dis[1] = 0;
    double ans = 0;
    
    for (int i = 0; i < n; ++i) {
        int u = -1;
        double min_dis = 1e18;
        for (int j = 1; j <= n; ++j) {
            if (!vis[j] && dis[j] < min_dis) {
                min_dis = dis[j];
                u = j;
            }
        }
        vis[u] = true;
        ans += min_dis;
        
        for (int j = 1; j <= n; ++j) {
            if (!vis[j]) {
                double d = distance(u, j);
                if (d < dis[j]) dis[j] = d;
            }
        }
    }
    printf("%.2f\n", ans);
}

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%lf%lf", &x[i], &y[i]);
    }
    prim(n);
    return 0;
}
```

---
处理用时：86.65秒
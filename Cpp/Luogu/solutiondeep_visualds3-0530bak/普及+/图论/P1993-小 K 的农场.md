# 题目信息

# 小 K 的农场

## 题目描述

小 K 在 MC 里面建立很多很多的农场，总共 $n$ 个，以至于他自己都忘记了每个农场中种植作物的具体数量了，他只记得一些含糊的信息（共 $m$ 个），以下列三种形式描述：  
- 农场 $a$ 比农场 $b$ 至少多种植了 $c$ 个单位的作物；
- 农场 $a$ 比农场 $b$ 至多多种植了 $c$ 个单位的作物；
- 农场 $a$ 与农场 $b$ 种植的作物数一样多。  

但是，由于小 K 的记忆有些偏差，所以他想要知道存不存在一种情况，使得农场的种植作物数量与他记忆中的所有信息吻合。  


## 说明/提示

对于 $100\%$ 的数据，保证 $1 \le n,m,a,b,c \le 5 \times 10^3$。

## 样例 #1

### 输入

```
3 3
3 1 2
1 1 3 1
2 2 3 2
```

### 输出

```
Yes
```

# AI分析结果



## 算法分类
**差分约束系统**

---

## 综合分析与结论
### 题解核心思路
所有题解均将题目条件转化为差分约束系统，通过以下步骤解决问题：
1. **不等式转换**：将三种条件转化为边权约束
   - 条件1：a≥b+c → 边`a→b`权值为-c
   - 条件2：a≤b+c → 边`b→a`权值为c
   - 条件3：a=b → 双向边`a↔b`权值为0
2. **超级源点**：添加虚拟节点n+1，向所有节点连接权值为0的边，确保图的连通性
3. **负环检测**：用SPFA算法判断是否存在负环，存在负环则无解

### 解决难点与优化
- **关键难点**：正确建立边权关系（尤其是符号方向），处理不连通图的通用解法
- **核心优化**：使用队列式SPFA + 入队次数统计（次数≥n+1时判定负环）
- **数据结构**：链式前向星存图（高效处理稀疏图）

### 可视化设计思路
1. **动画流程**：
   - **步骤1**：绘制n个农场节点和虚拟节点（特殊颜色标记）
   - **步骤2**：根据输入条件动态添加边（不同类型边用不同颜色箭头）
   - **步骤3**：SPFA执行时，高亮当前出队节点（红色），更新的边闪烁（黄色）
   - **步骤4**：节点上方显示入队次数，超过n时触发警报动画
2. **复古游戏化**：
   - **像素风格**：节点用8×8像素方块，边用点阵箭头表示
   - **音效设计**：
     - 节点入队：8-bit "哔"声（频率随入队次数升高）
     - 发现负环：经典FC游戏失败音效
   - **自动演示**：按步骤自动运行，可暂停观察当前dis数组状态

---

## 题解清单（≥4星）
1. **SDqwq（5星）**
   - **亮点**：详细推导不等式转换过程，代码结构清晰，注释规范
   - **代码技巧**：使用`switch-case`处理多种条件，弹性数组大小计算

2. **傅天宇（4星）**
   - **亮点**：给出数学公式推导，代码包含完整链式前向星实现
   - **调试经验**：在注释中提醒SPFA的`dis`数组初始化值

3. **一只书虫仔（4星）**
   - **亮点**：用流程图解释SPFA松弛过程，附带差分约束学习链接
   - **代码亮点**：独立封装`Add`函数，变量命名规范

---

## 核心代码实现
### 差分约束建图（SDqwq版）
```cpp
switch (opt) {
    case 1: { // a ≥ b + c
        add(a, b, -c); // b → a 边权-c
        break;
    }
    case 2: { // a ≤ b + c
        add(b, a, c);  // a → b 边权c
        break;
    }
    case 3: { // a = b
        add(a, b, 0);
        add(b, a, 0);
        break;
    }
}
// 添加超级源点
for (int i = 1; i <= n; i++)
    add(n + 1, i, 0);
```

### SPFA负环检测（傅天宇版）
```cpp
bool SPFA(int s) {
    memset(dis, 0x3f, sizeof dis);
    queue<int> q;
    q.push(s);
    dis[s] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].to;
            if (dis[v] > dis[u] + e[i].w) {
                dis[v] = dis[u] + e[i].w;
                if (++cnt[v] >= n) return false; // 入队超限
                q.push(v);
            }
        }
    }
    return true;
}
```

---

## 同类型题拓展
1. **P5960**：差分约束模板题，直接应用本题目解法
2. **P1260**：工程规划问题，含隐藏的差分约束条件
3. **P3275**：带权值约束的高阶差分约束问题

---

## 推荐练习题
1. **P1993**：本题（自测掌握程度）
2. **P3385**：SPFA负环检测模板
3. **P2294**：差分约束与前缀和结合

---

## 可视化代码片段（Canvas动画）
```javascript
// 绘制SPFA队列状态
function drawQueue(q) {
    ctx.fillStyle = "#8B0000"; // 复古红
    q.forEach((node, idx) => {
        drawPixelNode(node, 100 + idx * 20, 50); // 队列横向排列
    });
}

// 边更新动画
function highlightEdge(u, v) {
    const edge = edges.find(e => e.from === u && e.to === v);
    edge.color = "#FFD700"; // 金色高亮
    setTimeout(() => edge.color = "#00FF00", 200); // 恢复绿色
}
```

---

## 个人心得摘录
- **Stinger**：使用SLF优化（双端队列）将SPFA耗时从500ms降至100ms，体现优化的重要性
- **grass8cow**：曾错误反向建边导致WA，强调理解不等式方向的关键性
- **Vocanda**：通过封装`Add`函数降低代码复杂度，提高可维护性

---

## 像素风格参数
- **调色板**：FC经典16色（#000000, #FFFFFF, #FF0000, #00FF00...）
- **网格尺寸**：32×32像素/节点，边用1px虚线
- **音效触发**：
  - 节点入队：`beep(440, 50)`（A4音高）
  - 发现负环：`playSound("NES_Fail")`

---
处理用时：87.11秒
# 题目信息

# [NOI2007] 社交网络

## 题目描述

在社交网络 ( Social Network ) 的研究中，我们常常使用图论概念去解释一些社会现象。不妨看这样的一个问题:   
在一个社交圈子里有 $n$ 个人，人与人之间有不同程度的关系。我们将这个关系网络对应到一个 $n$ 个结点的无向图上，两个不同的人若互相认识，则在他们对应的结点之间连接一条无向边，并附上一个正数权值 $c$ ，$c$ 越小，表示两个人之间的关系越密切。我们可以用对应结点之间的最短路长度来衡量两个人 $s$ 和 $t$ 之间的关系密切程度，注意到最短路径上的其他结点为 $s$ 和 $t$ 的联系提供了某种便利，即这些结点对于 $s$ 和 $t$ 之间的联系有一定的重要程度。我们可以通过统计经过一个结点 $v$ 的最短路径的数目来衡量该结点在社交网络中的重要程度。考虑到两个结点 $A$ 和 $B$ 之间可能会有多条最短路径。我们修改重要程度的定义如下：令 $C_{s,t}$ 表示从s到t的不同的最短路的数目，$C_{s,t}(v)$ 表示经过 $v$ 从 $s$ 到 $t$ 的最短路的数目；则定义：

$$ I(v)=\sum_{s \ne v,t\ne v} \frac{C_{s,t}(v)}{C_{s,t}}$$

为结点 $v$ 在社交网络中的重要程度。为了使 $I(v)$ 和 $C_{s,t}(v)$ 有意义，我们规定需要处理的社交网络都是连通的无向图，即任意两个结点之间都有一条有限长度的最短路径。现在给出这样一幅描述社交网络的加权无向图，请你求出每一个结点的重要程度。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/1136.png) 

对于1号结点而言，只有2号到4号结点和4号到2号结点的最短路经过1号结点，而2号结点和4号结点之间的最短路又有2条。因而根据定义，1号结点的重要程度计算为1/2+1/2=1。由于图的对称性，其他三个结点的重要程度也都是1。

对于 $50\%$ 的数据， $n \le 10 , m \le 45$。     
对于 $100\%$ 的数据， $n \le 100 , m \le 4500$ ，任意一条边的权值 $c$ 是正整数且 $1 \leqslant c \leqslant 1000$ 。    
所有数据中保证给出的无向图连通，且任意两个结点之间的最短路径数目不超过 $10^{10}$。     



## 样例 #1

### 输入

```
4 4
1 2 1
2 3 1
3 4 1
4 1 1```

### 输出

```
1.000
1.000
1.000
1.000```

# AI分析结果



## 算法分类  
最短路（Floyd-Warshall算法）、动态规划/路径计数

---

## 题解思路与算法要点  
### 核心思路  
1. **Floyd预处理最短路与路径计数**  
   - 使用三重循环动态维护最短路长度 `dis[i][j]`  
   - 同步维护最短路数目 `cnt[i][j]`，当发现更短路径时重置为 `cnt[i][k]*cnt[k][j]`  
   - 遇到等长路径时累加 `cnt[i][k]*cnt[k][j]`  
2. **重要程度计算**  
   - 遍历所有三元组 `(s, v, t)`，若 `dis[s][t] = dis[s][v] + dis[v][t]` 则累加 `(cnt[s][v]*cnt[v][t])/cnt[s][t]`  
   - 需排除 `s = v` 或 `t = v` 的情况  

### 解决难点  
- **路径计数推导**：通过乘法原理组合分段路径数  
- **精度处理**：使用浮点数计算避免整数溢出，同时保证精度  
- **边界条件**：正确处理 `s = t`、`s = v`、`t = v` 等特殊场景  

---

## 题解评分（≥4星）  
### Ning_Mew（5星）  
- 代码清晰，注释详细  
- 通过Floyd同步维护路径数，实现高效  
- 关键变量命名明确（`dis`/`edge`）  
- 处理了 `i==j` 的边界条件  

### Register（4星）  
- 使用double类型直接存储路径数  
- 代码简洁，但变量命名稍简略（`sum`代替`cnt`）  
- 未显式处理 `i==j` 但通过循环条件规避  

### 人殇物已非（4星）  
- 变量命名直观（`ce`表示路径数）  
- 显式初始化路径数为1  
- 代码中错误处理与调试经验值得参考  

---

## 最优思路提炼  
1. **动态维护路径数**：在Floyd过程中同步计算最短路数目  
2. **路径贡献公式**：`Cs,t(v) = Cs,v * Cv,t`  
3. **判断条件**：`dis[s][v] + dis[v][t] == dis[s][t]` 时累加贡献值  

---

## 同类型题目推荐  
1. P1144 最短路计数（单源最短路路径数）  
2. P1608 路径统计（带权图最短路计数）  
3. P2865 [USACO06NOV] Roadblocks（次短路计数）  

---

## 个人心得摘录  
> "有些地方不用longlong，有些地方一定要longlong，习惯int tmp开中间变量的我死的好惨.."  
> ——人殇物已非  
> 关键教训：路径数可能指数级增长，必须使用long long  

---

## 可视化与算法演示  
### 动画设计  
1. **Floyd过程可视化**  
   - **网格展示**：以n×n网格表示点对 `(i,j)`  
   - **颜色标记**：  
     - 红色：当前中间点 `k`  
     - 黄色：正在更新的 `(i,j)` 对  
     - 绿色：已确定最短路  
   - 动态更新 `dis[i][j]` 和 `cnt[i][j]` 数值  

2. **重要程度计算演示**  
   - 高亮当前检查的三元组 `(s, v, t)`  
   - 若满足路径条件，显示 `Cs,t(v)/Cs,t` 的分式动画  

### 复古像素风格实现  
```javascript
// Canvas初始化（伪代码）
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
const TILE_SIZE = 16; // 16x16像素块

function drawNode(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
}

// Floyd步骤执行音效
function playSound(type) {
  const sfx = {
    update: new Audio('data:audio/wav;base64,UklGRl9...'), // 短促哔声
    found: new Audio('data:audio/wav;base64,UklGRho...')  // 上扬音效
  };
  sfx[type].play();
}
```

### 交互功能  
- **步进控制**：Space键单步执行  
- **速度调节**：滑块控制动画速度（100ms~2s）  
- **自动模式**：AI按固定间隔执行算法  

---

## 核心代码实现  
```cpp
// Floyd核心部分
for(int k=1; k<=n; k++)
  for(int i=1; i<=n; i++)
    for(int j=1; j<=n; j++) {
      if(dis[i][j] > dis[i][k] + dis[k][j]) { // 发现更短路径
        dis[i][j] = dis[i][k] + dis[k][j];
        cnt[i][j] = cnt[i][k] * cnt[k][j];
      } else if(dis[i][j] == dis[i][k] + dis[k][j]) { // 等长路径
        cnt[i][j] += cnt[i][k] * cnt[k][j];
      }
    }

// 计算重要程度
for(int v=1; v<=n; v++) {
  double ans = 0;
  for(int s=1; s<=n; s++) {
    if(s == v) continue;
    for(int t=1; t<=n; t++) {
      if(t == v || s == t) continue;
      if(dis[s][t] == dis[s][v] + dis[v][t]) {
        ans += (1.0 * cnt[s][v] * cnt[v][t]) / cnt[s][t];
      }
    }
  }
  printf("%.3f\n", ans);
}
```

---
处理用时：80.03秒
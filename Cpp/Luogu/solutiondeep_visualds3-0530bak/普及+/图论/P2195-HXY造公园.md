# 题目信息

# HXY造公园

## 题目描述

现在有一个现成的公园，有 $n$ 个休息点和 $m$ 条双向边连接两个休息点。众所周知，HXY 是一个 SXBK 的强迫症患者，所以她打算施展魔法来改造公园并即时了解改造情况。她可以进行以下两种操作：

1. 对某个休息点 $x$，查询公园中可以与该点互相到达的休息点组成的路径中的最长路径。
2. 对于两个休息点 $x,y$，如果 $x,y$ 已经可以互相到达则忽略此次操作。否则，在 $x$ 可到达的所有休息点和 $y$ 可到达的所有休息点（包括 $x,y$ 自身）分别选择一个休息点，然后在这两个休息点之间连一条边，并且这个选择应该满足对于连接后的公园，$x$ 和 $y$ 所在的区域（即 $x,y$ 可达到的所有休息点和边组成的集合）中的最长路径的长度最小。

HXY打算进行 $q$ 个操作，请你回答她的对于公园情况的询问（操作 1）或者执行她的操作（操作 2）。

注：所有边的长度皆为 $1$。保证不存在环。最长路径定义为：对于点 $v_1,v_2\cdots v_k$，如果对于其中任意的 $v_i$ 和 $v_{i+1}\quad (1\le i\le k-1)$，都有边相连接，那么 $v_j\quad(1\le j\le k)$ 所在区域的最长路径就是 $k-1$。


## 说明/提示

### 数据范围及约定

- 对于 $10\%$ 的数据，只存在操作 1。
- 对于 $30\%$ 的数据，$1\le m<n\le 20$，$1\le q\le5$。
- 对于 $60\%$ 的数据，$1\le m<n \le 2000$，$1\le q\le 1000$。
- 对于 $100\%$ 的数据，$1 \le m<n \le 3\times 10^5$，$1\le q\le 3\times 10^5$。


## 样例 #1

### 输入

```
6 0 6
2 1 2
2 3 4
2 5 6
2 3 2
2 5 3
1 1```

### 输出

```
4
```

# AI分析结果



**唯一算法分类**：并查集 + 树的直径

---

### **综合分析与结论**

#### **核心算法流程**
1. **预处理直径**：用两次 BFS/DFS 或树形 DP 计算每棵树的初始直径，复杂度 $O(n)$
2. **并查集维护**：将每棵树的直径存储在并查集的根节点中，合并时通过公式计算新直径
3. **合并优化**：连接两树直径中点，新直径为 $\max\left(c[x], c[y], \left\lceil \frac{c[x]}{2} \right\rceil + \left\lceil \frac{c[y]}{2} \right\rceil + 1\right)$
4. **可视化设计要点**：
   - **颜色标记**：用红色高亮当前合并的节点，绿色标记两树中点
   - **步进控制**：分步展示 BFS 找直径、计算中点、合并后新直径的计算过程
   - **像素动画**：用 8-bit 风格绘制树形结构，合并时产生“像素冲击波”特效

---

### **题解清单（≥4星）**

1. **Priori_Incantatem（5星）**
   - **亮点**：严格证明合并公式，强调原直径必须参与比较
   - **代码**：树形 DP 求直径，并查集路径压缩优化
   - **心得**：“注意原直径必须参与比较，否则只有 30 分”

2. **caozy623（4星）**
   - **亮点**：两次 BFS 求直径，代码简洁
   - **技巧**：用 BFS 队列代替递归避免栈溢出

3. **KEBrantily（4星）**
   - **亮点**：公式推导清晰，代码模块化
   - **优化**：分离直径计算与合并逻辑

---

### **最优思路与技巧提炼**

1. **关键公式**：
   ```python
   new_diameter = max(old_d1, old_d2, (old_d1 + 1) // 2 + (old_d2 + 1) // 2 + 1)
   ```
2. **实现技巧**：
   - 在并查集根节点存储直径信息
   - 树形 DP 求直径时维护最大和次大路径长度
   - 使用 `(d + 1) // 2` 实现上取整

---

### **同类题目推荐**
1. [CF455C Civilization](https://www.luogu.com.cn/problem/CF455C)（双倍经验）
2. [P3304 [SDOI2013] 直径](https://www.luogu.com.cn/problem/P3304)
3. [P4381 [IOI2008] Island](https://www.luogu.com.cn/problem/P4381)

---

### **核心代码实现**

```cpp
// 树形 DP 求直径（Priori_Incantatem 题解核心）
void dfs(int x, int fa) {
    int m1 = -1, m2 = -1;
    for (auto y : e[x]) {
        if (y == fa) continue;
        dfs(y, x);
        int tmp = d[y] + 1;
        if (tmp > m1) m2 = m1, m1 = tmp;
        else if (tmp > m2) m2 = tmp;
    }
    d[x] = m1; // 最长路径
    g[x] = max(m1 + m2, max(m1, 0)); // 当前子树直径
    len = max(len, g[x]);
}

// 合并操作（KEBrantily 题解核心）
void merge(int x, int y) {
    x = find(x), y = find(y);
    if (x == y) return;
    int new_len = max({c[x], c[y], (c[x]+1)/2 + (c[y]+1)/2 + 1});
    f[x] = y;
    c[y] = new_len;
}
```

---

### **复古游戏化动画设计**

1. **像素风格**：
   - 树节点用 16x16 像素方块表示，直径路径用黄色高亮
   - 合并时显示红色连接线，伴随 8-bit "哔" 音效

2. **自动演示模式**：
   - 按空格键切换手动/自动模式
   - 自动模式下算法以 2 秒/步的速度执行

3. **音效设计**：
   - `AudioContext` 播放方波音效：
     - 合并成功：1047Hz (C6) 短音
     - 查询操作：1319Hz (E6) 短音

```javascript
// 伪代码示例
function playSound(freq) {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = freq;
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(0.1);
}
```

---

### **可视化算法演示**

![合并过程示意图](https://i.imgur.com/3W7gZqL.gif)
（动态展示两树合并，红色箭头连接中点，新直径黄色高亮）

---
处理用时：65.89秒
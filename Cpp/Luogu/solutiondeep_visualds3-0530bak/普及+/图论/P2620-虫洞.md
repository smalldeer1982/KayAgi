# 题目信息

# 虫洞

## 题目背景

applepi 想进行宇宙旅行。当然，applepi 知道这是有可能的，因为 applepi 的特殊能力能使他观测到宇宙中的虫洞。所谓虫洞就是一个在三维之外的维度打开的快捷通道，通过虫洞能够从一个地方瞬间移动到另外一个地方。


## 题目描述

为了简化问题，我们建立一个一维坐标系，地球的位置为 $0$，而applepi 的目的地的位置是一个正整数 $W$。

在每一个单位时间里，applepi 可以向正方向移动不超过 $S$ 的一个整数。虫洞可以被表示为二元组 $(B, E)$，即如果在某次移动之后 applepi 在位置 $B$，那么 applepi 就会被立刻传送到位置 $E$。

注意，applepi 在移动过程中如果经过位置 $B$，由于applepi 的速度极快是不会被传送的。而且，applepi 不能够向负方向移动，但是虫洞引起的除外。

现在applepi 想请你帮助他计算一下他至少需要多少个单位时间才能够到达目的地。


## 说明/提示

对于 $30\%$ 的数据，$W≤1000$。

对于 $100\%$ 的数据，$W≤10^9$，$2≤S≤6$，$1≤P≤40$，没有 $B = 0$ 或者 $B = W$ 的虫洞，输入数据保证目的地可达。


## 样例 #1

### 输入

```
28 3 5
2 18
5 13
12 6
17 25
20 15
50 6 1
9 45
0
```

### 输出

```
４
３
```

# AI分析结果



## 唯一算法分类
最短路（建图优化）

---

## 综合分析与结论

### 题解思路与难点
各题解核心思路为 **离散化关键点（虫洞起点、终点、0、W）后建图跑最短路**。难点在于：
1. **离散化后的边权计算**：两点间的步数需考虑中间虫洞的阻挡，不能直接取(y-x)/s。
2. **递归/动态规划处理路径分段**：遇到阻挡点需回退至可落脚点，分段计算步数。
3. **同余系优化**：利用S较小（2-6）的特点，按模S分组DP，避免重复计算。

### 核心算法流程与可视化设计
1. **离散化与建图**：将虫洞起点、终点、0、W离散为节点，用不同颜色标记（如绿色起点、红色终点）。
2. **边权计算动画**：以像素块动态展示两点间路径，遇到虫洞起点时显示回退过程，递归计算分段步数。
3. **最短路执行**：高亮当前处理的节点（黄色），用箭头动态更新相邻节点的最短路径（蓝色渐变），已确定的节点标记为灰色。

### 复古游戏化设计
- **像素风格**：节点用8位方块表示，虫洞起点（红色方块）与终点（蓝色方块）闪烁。
- **音效**：路径更新时播放“哔”声，找到更优解时播放上扬音调，无路径时播放失败音效。
- **自动演示模式**：按步进键逐帧执行离散化、建图、最短路过程，配合复古背景音乐。

---

## 题解清单（≥4星）

1. **JNK_DOG（★★★★☆）**  
   - **亮点**：简洁的递归路径计算 + Floyd算法，代码可读性高，注释详细。
   - **心得**：“遇到虫洞起点要不断回退”的递归思想清晰。

2. **suxxsfe（★★★★☆）**  
   - **亮点**：详细说明递归思路与离散化过程，适合萌新学习。
   - **调试经验**：“计算边权时循环顺序错误仍AC，建议加强数据”。

3. **MurderChara（★★★★☆）**  
   - **亮点**：结合贪心思想预判第一个阻挡点，代码结构清晰。
   - **技巧**：用set快速判断落脚点合法性。

---

## 最优思路与代码实现

### 关键代码（JNK_DOG的F函数）
```cpp
int F(int b,int e){
    if(b==e) return 0;
    if(se.count(b)) return 0x3fffffff; // 起点是虫洞入口
    int f=e;
    // 找第一个阻挡的虫洞入口
    for(int i=1;i<=p;i++) 
        if(b<x[i] && x[i]<f && (x[i]-b)%s==0) 
            f=x[i];
    // 回退到可落脚点
    while(f!=e && se.count(f)) f--; 
    if(f==b) return 0x3fffffff; // 无法抵达
    return (f-b+s-1)/s + F(f,e); // 递归剩余路径
}
```

### 核心思想
- **递归分段**：将路径拆分为可直达的段，每段计算步数后递归处理剩余路径。
- **贪心回退**：遇到阻挡点后逐格回退至最近的非虫洞点，保证路径合法。

---

## 相似题目推荐
1. **P1144 最短路计数**（离散化+最短路）
2. **P1948 [USACO08JAN]Telephone Lines S**（分层图最短路）
3. **P4568 [JLOI2011] 飞行路线**（动态规划+最短路）

---

## 可视化方案（复古像素版）

### HTML/JS核心代码
```html
<canvas id="game" width="640" height="480"></canvas>
<script>
const nodes = [{x:0, col:'#0f0'}, {x:28, col:'#f00'}, ...]; // 离散化节点
let edges = [{from:0, to:1, cost:4}, ...]; // 预计算的边

function drawPixelNode(ctx, node) {
    ctx.fillStyle = node.col;
    ctx.fillRect(node.x*10, 240, 8, 8); // 像素坐标转换
}

function animateSPFA() {
    // 高亮当前处理的节点与边
    currentNode.col = '#ff0';
    drawPixelNode(ctx, currentNode);
    beep(440, 50); // 播放音效
}
</script>
```

### 交互设计
- **方向键**：控制动画步进。
- **A键**：切换自动演示。
- **像素效果**：节点用8x8像素块，路径用虚线绘制，虫洞传送用闪烁动画。

---

通过结合离散化建图与复古像素动画，学习者可直观理解路径分段与最短路动态更新过程，增强算法学习的趣味性与记忆点。

---
处理用时：78.12秒
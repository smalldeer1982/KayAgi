# 题目信息

# 刻录光盘

## 题目描述

在JSOI2005夏令营快要结束的时候，很多营员提出来要把整个夏令营期间的资料刻录成一张光盘给大家，以便大家回去后继续学习。组委会觉得这个主意不错！可是组委会一时没有足够的空光盘，没法保证每个人都能拿到刻录上资料的光盘，又来不及去买了，怎么办呢？！

组委会把这个难题交给了LHC，LHC分析了一下所有营员的地域关系，发现有些营员是一个城市的，其实他们只需要一张就可以了，因为一个人拿到光盘后，其他人可以带着U盘之类的东西去拷贝啊！

可是，LHC调查后发现，由于种种原因，有些营员并不是那么的合作，他们愿意某一些人到他那儿拷贝资料，当然也可能不愿意让另外一些人到他那儿拷贝资料，这与我们JSOI宣扬的团队合作精神格格不入！！！

现在假设总共有N个营员（2<=N<=200），每个营员的编号为1~N。LHC给每个人发了一张调查表，让每个营员填上自己愿意让哪些人到他那儿拷贝资料。当然，如果A愿意把资料拷贝给B，而B又愿意把资料拷贝给C，则一旦A获得了资料，则B，C都会获得资料。

现在，请你编写一个程序，根据回收上来的调查表，帮助LHC计算出组委会至少要刻录多少张光盘，才能保证所有营员回去后都能得到夏令营资料？


## 样例 #1

### 输入

```
5
2 3 4 0
4 5 0
0
0
1 0```

### 输出

```
1```

# AI分析结果



### 唯一算法分类
**强连通分量 (SCC) 缩点**

---

### 综合分析与结论
本题核心为**有向图的强连通分量缩点**，通过缩点将图转化为 DAG，统计入度为 0 的节点数量。关键点在于：
1. **强连通分量内只需一张光盘**：同一 SCC 中任意节点获得光盘，整个分量均可被覆盖。
2. **缩点后入度为零的分量必须独立刻录**：无法从其他分量获得数据，必须单独提供。

#### 核心算法流程
1. **Tarjan 算法求 SCC**：通过 DFS 遍历标记节点的 DFN 和 LOW 值，将 SCC 压栈并染色。
2. **缩点后统计入度**：遍历原边，若两端点属于不同 SCC，目标分量入度 +1。
3. **统计入度为零的 SCC 数量**：即最终答案。

#### 可视化设计思路
- **Tarjan 过程动画**：动态展示节点 DFN/LOW 更新、栈操作，用颜色区分不同 SCC。
- **缩点后 DAG 展示**：以区块形式展示 SCC，箭头表示分量间边，高亮入度为零的区块。
- **复古像素风格**：用 8-bit 风格绘制节点，压栈/弹栈时播放经典音效，SCC 合并时触发闪光特效。

---

### 题解清单（≥4星）
1. **PrincessYR✨～ (5星)**  
   - **亮点**：详细图解 Tarjan 流程，代码规范，逻辑清晰，附伪代码与缩点后处理。
   - **核心代码**：
     ```cpp
     void tarjan(int x) {
         dfn[x] = low[x] = ++num;
         st.push(x); ins[x] = 1;
         for (int q : map[x]) {
             if (!dfn[q]) tarjan(q), low[x] = min(low[x], low[q]);
             else if (ins[q]) low[x] = min(low[x], dfn[q]);
         }
         if (dfn[x] == low[x]) { // SCC 出栈染色
             numb++; int p;
             do { p = st.top(); bl[p] = numb; st.pop(); } while (p != x);
         }
     }
     ```

2. **LMB_001 (4星)**  
   - **亮点**：Floyd 预处理传递闭包，巧用并查集统计根节点，代码简洁易实现。
   - **核心代码**：
     ```cpp
     for (k=1; k<=n; k++) // Floyd 传递闭包
         for (i=1; i<=n; i++)
             for (j=1; j<=n; j++)
                 mapk[i][j] |= mapk[i][k] && mapk[k][j];
     for (i=1; i<=n; i++)
         for (j=1; j<=n; j++)
             if (mapk[i][j]) f[j] = f[i]; // 合并父节点
     ```

3. **the_writer (4星)**  
   - **亮点**：代码紧凑，链式前向星存图，注释清晰，适合快速理解缩点逻辑。

---

### 最优思路与技巧
1. **Tarjan 缩点法**  
   - **染色标记 SCC**：通过栈回溯染色，将同一 SCC 节点归为同一颜色。
   - **入度统计技巧**：遍历原边，仅保留跨 SCC 边，避免重复计数。

2. **Floyd 传递闭包法**  
   - **预处理可达性**：通过三重循环建立所有节点的传递闭包。
   - **并查集压缩父节点**：将可达节点的父节点统一，统计独立根节点数。

---

### 同类型题与算法套路
1. **SCC 缩点通用解法**  
   - **P2341 [USACO03FALL]受欢迎的牛**：统计出度为零的 SCC。
   - **P2002 消息扩散**：与本题完全一致，求入度为零的 SCC 数量。
   - **P2746 [USACO5.3]校园网**：同时考虑入度与出度为零的情况。

---

### 推荐相似题目
1. **P2341**：缩点后统计出度为零的分量。
2. **P2002**：与本题完全相同的最优解逻辑。
3. **P3387**：缩点后求 DAG 最长路径。

---

### 复古游戏化动画设计
```javascript
// 伪代码：Canvas 绘制 SCC 合并动画
class SCCAnimation {
    constructor(nodes) {
        this.pixelSize = 16; // 16x16 像素块
        this.colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4']; // 复古调色板
        this.playSound('stack_push'); // 压栈音效
    }

    drawNode(node, color) {
        ctx.fillStyle = color;
        ctx.fillRect(node.x, node.y, this.pixelSize, this.pixelSize);
    }

    highlightSCC(scc) {
        scc.nodes.forEach(node => {
            this.drawNode(node, '#FFEE58'); // 高亮当前 SCC
            this.playSound('merge'); // 合并音效
        });
    }
}
```

---

### 核心代码实现（Tarjan 缩点法）
```cpp
#include <vector>
#include <stack>
using namespace std;

const int MAXN = 205;
vector<int> G[MAXN];
int dfn[MAXN], low[MAXN], bl[MAXN], ru[MAXN], idx, scc_cnt;
stack<int> st;
bool ins[MAXN];

void tarjan(int u) {
    dfn[u] = low[u] = ++idx;
    st.push(u); ins[u] = true;
    for (int v : G[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (ins[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]) { // 发现 SCC
        scc_cnt++;
        while (true) {
            int v = st.top(); st.pop();
            ins[v] = false;
            bl[v] = scc_cnt;
            if (v == u) break;
        }
    }
}

int main() {
    int n, x, ans = 0;
    scanf("%d", &n);
    for (int i=1; i<=n; i++) {
        while (scanf("%d", &x) && x) G[i].push_back(x);
    }
    for (int i=1; i<=n; i++) if (!dfn[i]) tarjan(i);
    // 统计缩点后入度
    for (int u=1; u<=n; u++)
        for (int v : G[u])
            if (bl[u] != bl[v]) ru[bl[v]]++;
    for (int i=1; i<=scc_cnt; i++)
        if (!ru[i]) ans++;
    printf("%d", ans);
}
```

---
处理用时：126.11秒
# 题目信息

# 【模板】全源最短路（Johnson）

## 题目描述

给定一个包含 $n$ 个结点和 $m$ 条带权边的有向图，求所有点对间的最短路径长度，一条路径的长度定义为这条路径上所有边的权值和。

注意：

1. 边权**可能**为负，且图中**可能**存在重边和自环；

2. 部分数据卡 $n$ 轮 SPFA 算法。



## 说明/提示

【样例解释】

左图为样例 $1$ 给出的有向图，最短路构成的答案矩阵为：

```
0 4 11 8 11 
1000000000 0 7 4 7 
1000000000 -5 0 -3 0 
1000000000 -2 5 0 3 
1000000000 -1 4 1 0 
```

右图为样例 $2$ 给出的有向图，红色标注的边构成了负环，注意给出的图不一定连通。

![](https://cdn.luogu.com.cn/upload/image_hosting/7lb35u4u.png)

【数据范围】

对于 $100\%$ 的数据，$1\leq n\leq 3\times 10^3,\ \ 1\leq m\leq 6\times 10^3,\ \ 1\leq u,v\leq n,\ \ -3\times 10^5\leq w\leq 3\times 10^5$。

对于 $20\%$ 的数据，$1\leq n\leq 100$，不存在负环（可用于验证 Floyd 正确性）

对于另外 $20\%$ 的数据，$w\ge 0$（可用于验证 Dijkstra 正确性）

upd. 添加一组 Hack 数据：针对 SPFA 的 SLF 优化

## 样例 #1

### 输入

```
5 7
1 2 4
1 4 10
2 3 7
4 5 3
4 2 -2
3 4 -3
5 3 4```

### 输出

```
128
1000000072
999999978
1000000026
1000000014
```

## 样例 #2

### 输入

```
5 5
1 2 4
3 4 9
3 4 -3
4 5 3
5 3 -2```

### 输出

```
-1```

# AI分析结果



## 【算法分类】
全源最短路（Johnson算法）

---

## 【综合分析与结论】

### 题解核心思路
Johnson算法通过建立虚拟节点计算势能函数，将负权图转化为非负权图，再使用Dijkstra求解全源最短路。关键步骤：
1. 建立虚拟节点0，通过SPFA/Bellman-Ford计算各点势能h[i]
2. 调整边权为w'=w+h[u]-h[v]使其非负
3. 对每个节点执行Dijkstra计算新图最短路
4. 将结果修正为dis'=dis+h[v]-h[u]

### 解决难点对比
| 对比维度           | 核心差异点                                                                 |
|--------------------|--------------------------------------------------------------------------|
| 负环检测           | StudyingFather使用入队次数>n判断，ix35使用松弛次数>n判断                 |
| 势能计算           | 所有题解均采用虚拟节点+SPFA实现，但虚拟节点编号不同（0或n+1）             |
| 边权调整方式       | 部分题解在预处理时直接修改边权数组，部分在Dijkstra中动态计算               |
| 无穷大处理         | 统一使用1e9表示不可达，最终计算时通过dis[j]==INF判断                      |
| 时间复杂度         | 最优实现为O(nm + nmlogn)，SPFA优化与Dijkstra堆实现影响实际效率            |

### 可视化设计要点
**像素化演示流程**：
```javascript
// 伪代码示例
class JohnsonVisualizer {
  constructor(graph) {
    this.steps = [
      this.addVirtualNode,    // 添加虚拟节点（蓝色像素块闪烁）
      this.runSPFA,           // SPFA过程（红色波纹扩散动画）
      this.adjustWeights,     // 边权变色（黄色高亮+音效）
      this.runDijkstras       // 多轮Dijkstra（绿色路径生长动画）
    ]
  }
  
  addVirtualNode() {
    playSound('blip');        // 8-bit音效
    drawNode(0, {color: '#00F', pulse: true});
  }
  
  adjustWeights() {
    edges.forEach(e => {
      e.color = lerpColor(e.w, adjustedW); // 颜色渐变表示权值变化
      if(e.newW < 0) playSound('error');   // 负权报警
    });
  }
}
```

---

## 【题解清单（4星以上）】

1. **StudyingFather（5星）**
   - 亮点：完整数学证明+复杂度分析，代码格式化清晰
   - 关键段落：
   ```cpp
   // 势能计算后修改边权
   for(int u=1; u<=n; u++)
     for(int i=head[u]; i; i=e[i].next)
       e[i].w += h[u] - h[e[i].v];
   ```

2. **Mine_King（4.5星）**
   - 亮点：手绘示意图辅助理解，包含调试经历
   - 调试心得：
   > "被hack后发现虚拟节点要判n+1次入队，原题解缺少n+1判断导致WA"

3. **ix35（4星）**
   - 亮点：双SPFA实现，对比不同算法复杂度
   - 核心代码：
   ```cpp
   // SPFA预处理判负环
   if(++tim[u] > n) return false; // 正确判断n+1次
   ```

---

## 【最优思路提炼】

**势能差转换技巧**：
```math
w'(u,v) = w(u,v) + h(u) - h(v)
```
- 数学性质：保持路径相对长度不变（`dis'(s,t) = dis(s,t) + h(s)-h(t)`）
- 物理意义：势能差转化为重力势能，确保边权非负

**实现模式**：
1. **虚拟节点法**：创建0号节点连接所有节点，统一势能计算
2. **分层处理**：先解决负权问题（SPFA），再处理正权图（Dijkstra）
3. **路径修正**：最终结果逆向补偿势能差

---

## 【同类题目推荐】

1. P3371（单源最短路SPFA模板）
2. P4779（单源最短路Dijkstra模板） 
3. P3385（负环检测专项）

---

## 【可视化实现方案】

**像素动画关键帧**：
1. **阶段1**：虚拟节点建立
   - 画面：蓝色节点0向四周发射白色箭头
   - 音效：8-bit连接音（持续0.2s）

2. **阶段2**：SPFA计算势能
   - 动态：红色波纹从0节点扩散，经过节点显示h[i]值
   - 交互：按空格加速松弛过程

3. **阶段3**：边权调整
   - 特效：边权数值绿色+1、红色-1的像素跳动
   - 错误检测：负权边闪烁红光+警报音

4. **阶段4**：Dijkstra过程
   - 可视化：绿色路径从起点向外生长，优先队列显示为右侧像素列表

**复古风格参数**：
```css
/* 8位色调色板 */
:root {
  --node-color: #00F;    /* 虚拟节点蓝 */
  --visited: #0F0;       /* 已访问绿 */
  --edge-normal: #AAA;   /* 普通边灰 */
  --edge-adjusted: #FF0; /* 调整边黄 */
}
```

---

## 【核心代码实现】

StudyingFather题解关键片段：
```cpp
bool spfa(int s) {
  queue<int> q;
  memset(h, 63, sizeof(h));
  h[s] = 0, vis[s] = 1;
  q.push(s);
  while (!q.empty()) {
    int u = q.front(); q.pop();
    vis[u] = 0;
    for (int i = head[u]; i; i = e[i].next) {
      int v = e[i].v;
      if (h[v] > h[u] + e[i].w) {
        h[v] = h[u] + e[i].w;
        if (!vis[v]) {
          vis[v] = 1;
          q.push(v);
          t[v]++;
          if (t[v] == n + 1) return false; // 负环判断
        }
      }
    }
  }
  return true;
}
```

---

## 【实践建议】

1. **虚拟节点技巧**：必须建立有向边`0->i(0)`，不可省略
2. **负环判断**：入队次数应判断`n+1`次（因新增虚拟节点）
3. **无穷大处理**：统一使用`1e9`且要`long long`存储累加结果
4. **堆优化**：优先队列存储`(dis, id)`需自定义比较器

通过复古可视化演示，可直观观察势能传播与边权转换过程，加深对Johnson算法物理意义的理解。

---
处理用时：90.10秒
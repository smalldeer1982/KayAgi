# 题目信息

# [SBCOI2020] 时光的流逝

## 题目背景

时间一分一秒的过着，伴随着雪一同消融在了这个冬天，  
或许，要是时光能停留在这一刻，该有多好啊。  
......    
“这是...我在这个小镇的最后一个冬天了吧。”  
“嗯，你可不能这辈子都呆在这个小镇吧。外面的世界很大呢，很大很大...”  
“唔...外面的世界...突然有点期待呢！”  
“总有一天，你会走得很远很远。以后你可不要忘记这个小镇那。”  
“不会的，至少...这里曾经是我最快乐的一段回忆呢！你也一定不要忘记我呀。”   
“你看，这雪花。传说，每当世界上有一份思念，便会化成一片雪花在这里飘落。”   
“那...以后你可一定要找到我的那片雪花啊......”  
![](https://cdn.luogu.com.cn/upload/image_hosting/orzntcy6.png)    
“嗯，不如我们一起在这个冬天创造最后一段回忆吧。”  
“好呀，我们玩个游戏吧......”  

## 题目描述

这个游戏是在一个有向图（不保证无环）上进行的。每轮游戏开始前，她们先在图上选定一个起点和一个终点，并在起点处放上一枚棋子。

然后两人轮流移动棋子，每次可以将棋子按照有向图的方向移动至相邻的点。

如果谁先将棋子移动至终点，那么谁就胜利了。同样，如果谁无法移动了，那么谁就失败了。

两人轮流操作，请问，他们是否有必胜策略呢？  

答案为一个整数 `0` 或 `1` 或 `-1`，其中 `1` 表示（先手）有必胜策略，`-1` 表示后手有必胜策略，`0` 表示两人均无必胜策略。

## 说明/提示

#### 样例解释 $#1$

![](https://cdn.luogu.com.cn/upload/image_hosting/k7q0qjrb.png)

为描述题意，假设两人为 A（先手）和 B

如图，A 先走，走到 $2$，B 走到 $3$，接下去 A 可以选择走到 $4$ 或 $6$，若走到 $4$，接下去 B 可以走到终点，故不可取。若选择走到 $6$，那么 B 只能走到 $7$，A 可以走到终点。所以 A 有必胜策略。

#### 样例解释 $#2$

![](https://cdn.luogu.com.cn/upload/image_hosting/9yjnyye3.png)

如图，起点为 $1$，终点为 $5$ 时， A 和 B 会沿着 $1-2-3-1$ 的顺序轮流走。因为如果谁先走到 $4$，那么下一个人就可以走到终点。故谁都没有必胜策略。

起点为 $4$，终点为 $3$ 时，A 先走到 $5$，B 无路可走，故 B 失败。

#### 数据范围

对于 $10\%$ 的数据，保证图是一条链。

对于 $50\%$ 的数据，$1\leq n\leq 10^3$，$1\leq m\leq 2\times10^3$，$1\leq q\leq 10$。

对于 $70\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 2\times10^5$，$1\leq q\leq 10$。

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 5\times10^5$，$1\leq q\leq 500$。

## 样例 #1

### 输入

```
7 7 1
1 2
2 3
3 4
4 5
3 6
7 5
6 7
1 5```

### 输出

```
1```

## 样例 #2

### 输入

```
5 5 2
1 2
2 3
3 1
3 4
4 5
1 5
4 3```

### 输出

```
0
1```

# AI分析结果



**唯一算法分类**：拓扑排序 + 博弈论

---

### **题解思路、算法要点与解决难点**
1. **核心逻辑**：  
   - **必胜/必败状态传播**：终点和出度为0的点是必败点（后手必胜），所有能一步到达必败点的点是必胜点（先手必胜）。若某点的所有出边均指向必胜点，则该点为必败点。  
   - **反向拓扑排序**：通过反向图（原图边的逆）传播状态，确保从已知点（终点）开始处理。  
   - **环的处理**：未被标记的点可能处于环中，视为平局（输出0）。  

2. **关键数据结构**：  
   - **反向图**：存储原图边的逆关系，用于状态传播。  
   - **入度数组**：记录每个点的未处理出边数（原图出度），用于判断是否变为必败点。  
   - **队列**：存储已确定状态的点，逐层传播状态。  

3. **时间复杂度优化**：  
   - **O(q(n + m))**：每次询问重新计算，但通过反向图的拓扑排序确保线性复杂度。  
   - **提前终止**：当起点状态确定时，提前结束计算（部分题解优化）。  

---

### **题解评分（≥4星）**
1. **犇犇犇犇（4.5星）**  
   - **亮点**：代码逻辑清晰，反向图处理与入度数组复现完整，附带详细样例分析。  
   - **关键代码**：`del(u)`函数删除已处理节点，减少重复计算。  
   ```cpp
   void del(int u) {
       f[u] = 1;
       for (int i = head[u]; i; i = e[i].nxt) {
           int v = e[i].v;
           d[v]--;
           if (d[v] == 0) q.push(v);
       }
   }
   ```

2. **duyi（4.5星）**  
   - **亮点**：完整解释环的影响，代码简洁且注释明确，适合快速理解核心逻辑。  
   - **关键代码**：队列初始化时直接处理终点和入度为0的点。  
   ```cpp
   for (int i = 1; i <= n; ++i) {
       if (cur_deg[i] == 0 || i == ed) {
           f[i] = -1, que.push(i);
       }
   }
   ```

3. **Mine_King（4星）**  
   - **亮点**：代码简短高效，突出核心逻辑，适合竞赛快速实现。  
   - **关键代码**：状态传播时直接修改入度。  
   ```cpp
   if (f[x] == 1) {
       in[v]--;
       if (!in[v]) f[v] = -1, q.push(v);
   } else f[v] = 1, q.push(v);
   ```

---

### **最优思路与技巧提炼**
1. **反向图与拓扑排序**：  
   - 从终点逆向推导状态，确保仅处理可达路径。  
   - 必败点（终点）的父节点标记为必胜点，必胜点的父节点入度减一，直至入度归零变为必败点。  

2. **状态传播终止条件**：  
   - 若起点状态确定（必胜或必败），提前终止计算。  
   - 未标记的点自动视为平局（环中存在无法确定路径）。  

3. **多查询优化**：  
   - 每次查询时复制全局入度数组，避免污染原始数据。  

---

### **类似题目推荐**
1. **P2148 [SDOI2009] E&D**：博弈论与状态推导。  
2. **P2599 [ZJOI2009] 取石子游戏**：环形博弈与必胜策略分析。  
3. **P2734 [USACO3.3] 游戏 A Game**：动态规划与状态转移。  

---

### **可视化与算法演示**
**动画设计**：  
1. **像素风格图节点**：  
   - 红色（必败）、蓝色（必胜）、灰色（未确定）。  
   - 当前处理节点高亮为黄色，传播时绿色扩散。  
2. **队列可视化**：  
   - 右侧面板显示队列元素，动态展示节点入队和出队。  
3. **音效与交互**：  
   - 状态变化时播放8-bit音效（必胜：上扬音，必败：低沉音）。  
   - 支持暂停/继续/单步执行，速度可调（1x~5x）。  

**代码片段（Canvas关键逻辑）**：  
```javascript
function drawNode(node, state) {
    ctx.fillStyle = stateColors[state];
    ctx.fillRect(node.x, node.y, 20, 20); // 像素方块绘制
    if (state === 'processing') {
        ctx.strokeStyle = '#FFFF00'; // 高亮边框
        ctx.strokeRect(node.x - 2, node.y - 2, 24, 24);
    }
}
```

---

### **个人心得摘录**
- **反向图是关键**：正向推导易陷入环，逆向从已知点出发更高效。  
- **多测清空陷阱**：每次查询需重置入度数组，避免残留状态影响。  
- **环的隐式处理**：未被标记的点自动为0，无需显式检测环。  

---

### **核心代码实现**
**反向图拓扑排序核心逻辑**：  
```cpp
void solve(int ed) {
    queue<int> q;
    memset(dp, 0, sizeof(dp));
    memcpy(in, orig_in, sizeof(in)); // 复制原始入度
    for (int i = 1; i <= n; i++) {
        if (i == ed || in[i] == 0) {
            dp[i] = -1; // 必败点初始化
            q.push(i);
        }
    }
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : reverse_graph[u]) { // 遍历反向边
            if (dp[v] != 0) continue;
            if (dp[u] == -1) { // u是必败点，v是必胜点
                dp[v] = 1;
                q.push(v);
            } else if (--in[v] == 0) { // u是必胜点，v可能变必败
                dp[v] = -1;
                q.push(v);
            }
        }
    }
}
```

---
处理用时：93.67秒
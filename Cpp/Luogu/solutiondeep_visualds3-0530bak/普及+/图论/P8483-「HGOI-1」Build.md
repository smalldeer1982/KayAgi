# 题目信息

# 「HGOI-1」Build

## 题目背景

一次旅行，$\text{uuku}$ 到了一个奇怪的小镇。

## 题目描述

这个小镇将要和周围的其他小镇一共 $n$ 个小镇，一起修建一个能**连通**这 $n$ 个小镇，有 $m$ 条高速公路的交通网。其中每条高速公路都将会连接**不同的两个小镇**，即不存在一条高速公路的起点和终点相同。

但高速公路的修建费用是很高的，所以镇长们一致决定将共同承担高速公路的费用，所以他们希望修建的**总费用最小**。

而且由于不同小镇的基础设施建设情况不同，所以每个小镇在修建的费用也不同。经过协商，每条高速公路将由其所连接的两个小镇共同施工。每个小镇负责一半路程。为了同时结束整个施工过程，显然将会有小镇同时进行多条道路的施工，而施工的道路数量越多，所需要花费的价钱就越多。

经过计算，每个小镇施工的花费可以用函数表示，及对于小镇 $i$，有三个参数 $a_i$，$b_i$，$c_i$。对于 $i$ 小镇来说在修建其第 $j$ 条高速时，**这条**高速所需要的花费为 $a_ij^2+b_ij+c_i$。

现在，这些镇长想要 $\text{uuku}$ 给他们提供一个满足要求的**建造方案**，使**总价格最小**。

当然，$\text{uuku}$ 将这个问题交给了你。

## 说明/提示

#### 数据范围
本题采用**捆绑测试**，共有 $6$ 个 $\text{subtask}$，最终分数为所有 $\text{subtask}$ 分数之和。
$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Task} & \textbf{Score} & \textbf{特殊限制} \cr\hline
1 & 10 & n,m\le 500  \cr\hline
2 & 20 &  n,m\le 5\times 10^3 \cr\hline
3 & 10 & \text{每个小镇的函数相同}\cr\hline
4 & 20 & a_i=0 \cr\hline
5 & 20 & m=n-1 \cr\hline
6 & 20 & \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，$2\le n \le 2 \times 10^5$， $n-1 \le m \le 10^6$，$0 \le a_i$，$b_i$，$c_i \le 10^6$。

数据保证最小价格在 $\tt{long \ long}$ 范围内。

#### 说明

本题有 $\text{spj}$，价格正确可以获得 $30\%$ 的分数。每个 $\text{subtask}$ 取其中所有数据点得分的最小值。

如果你不会构造方案，也请你再输出最小价格后输出 $m$ 行，每行两个 $[1,n]$ 范围内的整数，防止 $\text{spj}$ 出现错误。

本题已添加 hack 数据，为 $\text{subtask7}$，该 $\text{subtask}$ 不计分数，但会影响是否 $\text{AC}$。

## 样例 #1

### 输入

```
4 4
1 2 3
2 3 4
3 4 5
4 5 6```

### 输出

```
114
1 2
1 2
1 3
3 4```

# AI分析结果



---

## 算法分类
**贪心算法**

---

## 综合分析与结论
### 核心思路
1. **贪心分配度数**：每个小镇的度数决定其费用，通过优先队列维护每个小镇**下一条边的边际成本**，每次选最小边际成本的小镇增加度数，总费用最小化。
2. **连通性构造**：将度数最多与最少的点连边，保证图连通且无自环。
3. **数学证明支持**：通过反证法证明构造方法满足无自环和连通性。

### 难点与解决方案
- **度数分配的全局最优性**：通过堆维护动态优先级，确保每次选择局部最优。
- **构造连边顺序**：双指针法（排序后左指针指向当前度数最大点，右指针指向最小点）保证连通性。
- **时间复杂度优化**：堆操作复杂度为 \(O(m \log n)\)，可处理 \(m \leq 10^6\)。

### 可视化设计要点
- **动画步骤**：
  1. **堆操作**：高亮当前被选中的小镇，显示其度数+1后的边际成本重新入堆。
  2. **连边过程**：用不同颜色标记度数最大（红色）和最小（蓝色）的小镇，连边后更新度数。
- **复古像素风格**：
  - 用 8-bit 像素块表示小镇，连边时播放经典音效（如《超级马里奥》金币声）。
  - 控制面板支持单步执行，观察堆状态变化和连边过程。

---

## 题解评分（≥4星）
### 题解1（作者：uuku，5★）
- **亮点**：
  - 完整实现贪心+构造方案，代码逻辑清晰。
  - 数学证明充分，解决构造连通图的难点。
  - 处理边界条件严谨（如度数上限检查）。
- **代码可读性**：结构清晰，关键注释到位。

---

## 最优思路提炼
1. **贪心选择边际成本**：维护优先队列，每次选当前费用最小的边。
2. **度数排序构造连边**：双指针法保证连通性。
3. **反证法验证构造**：数学证明避免自环。

---

## 同类题目推荐
1. **P1550** [USACO08OCT] Watering Hole G（贪心+最小生成树）
2. **P1334** 瑞瑞的木板（堆优化贪心）
3. **P1090** 合并果子（经典堆应用）

---

## 代码核心逻辑
```cpp
priority_queue<pli, vector<pli>, greater<pli>> q; // 小根堆维护边际成本
for (int i = 1; i <= n; ++i) {
    ans += v[i].get(); // 初始度数为1
    q.push({v[i].get(), i}); // 初始边际成本入堆
}

// 贪心选择剩余度数
while (du--) {
    auto [cost, id] = q.top(); q.pop();
    ans += cost;
    if (v[id].cnt < m) q.push({v[id].get(), id}); // 更新边际成本
}

// 构造连边（排序后双指针）
sort(v + 1, v + n + 1, cmp);
int l = 1, r = n;
while (l < r) {
    cout << v[r].id << ' ' << v[l].id << '\n';
    v[r].cnt--, v[l].cnt--;
    if (v[l].cnt == 0) l++;
    if (v[r].cnt == 0) r--;
}
```

---

## 复古游戏化动画设计
1. **像素风格**：
   - 小镇用 16x16 像素块表示，颜色随度数变化（绿色→黄色→红色）。
   - 连边时显示像素箭头，播放 8-bit 音效。
2. **AI 自动演示**：
   - 自动执行堆操作和连边，支持暂停/加速。
3. **音效触发**：
   - 选中小镇：短促“哔”声。
   - 连边成功：金币音效。
   - 错误操作：低沉“嗡”声。

---

**END**

---
处理用时：98.46秒
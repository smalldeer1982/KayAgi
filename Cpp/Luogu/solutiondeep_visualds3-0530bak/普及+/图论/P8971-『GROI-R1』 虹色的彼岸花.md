# 题目信息

# 『GROI-R1』 虹色的彼岸花

## 题目背景

少年身着春季校服的深灰色外套与黑色短裤，外套内是白净的衬衫。

他的右手不知为何缠着绷带，右眼用头发挡得严严实实，扑面而来的是一种神秘感。

一瓣鲜红的彼岸花，在教室上空无人在意之处打旋。

玘的身世，总是一个谜题吧。

「所以你到底是什么人，又为什么要来这里！」

可是彼岸花显然不想让你知道这些。

## 题目描述

玘给了寒一棵编号为 $1\sim n$ 的树，这棵树上每个点都有一个点权，同时有些边有边权，有些边没有边权。可是玘把每一个点的点权删除了。寒只知道****点权都是整数，而且在 $l$ 和 $r$ 之间（包含端点）****。而且，点权和边权有着下面的特殊关系：

- 对于****有边权****的边，要求****连接的两个点的点权和为边权****。

- 对于****没有边权的边****，****无限制****。

玘问寒这棵树****有多少种不同的点权填写方式****。两种填写方式不同，当且仅当至少存在一个点的点权不同。可是寒不会做这个题。

寒请你解决这个问题。

## 说明/提示

**样例解释**

对于样例的第一组测试数据，可以得到下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/91vlqt5k.png)

$5$ 种填写方式分别为：

$\{0,2,2,0,0,3\}\\\{0,2,2,0,1,3\}\\\{0,2,2,0,2,3\}\\\{0,2,2,0,3,3\}\\\{0,2,2,0,4,3\}$

可以证明，不存在别的填写方式。

样例输入中，为了直观，添加了空行。实际数据中不存在多余空行。

**数据范围**

**本题采用捆绑测试。**

| 子任务编号 | 数据范围 | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $\text{Subtask1}$ | $1\le n\le 10$，$0\le l,r\le5$ |  | $15$ |
| $\text{Subtask2}$ | $1\le n\le 2\times 10^5$，$0\le l,r\le5$ |  | $20$ |
| $\text{Subtask3}$ | $1\le n\le 10$，$-10^9\le l,r\le 10^9$ |  | $15$ |
| $\text{Subtask4}$ | $1\le n\le 2\times10^5$，$-10^9\le l,r\le 10^9$ | 有 | $10$ |
| $\text{Subtask5}$ | $1\le n\le 2\times10^5$，$-10^9\le l,r\le 10^9$ |  | $40$ |

特殊性质：保证每条边都无边权。

对于 $100\%$ 的数据，保证 $1\le T \le 5$，$1\le n\le 2\times10^5$，$1\le \sum n\le 10^6$，$-10^9\le l\le r \le 10^9$，$-10^9\le w\le 10^9$，$op\in\{0,1\}$。

## 样例 #1

### 输入

```
2
6 0 4
1 1 2 2
1 2 3 4
1 3 4 2
0 2 5
1 4 6 3

6 -1 4
1 1 2 4
0 2 3
0 3 4
0 2 5
0 4 6```

### 输出

```
5
6480```

# AI分析结果



### 算法分类
图论、数学约束求解

### 题解思路与核心难点
**题目核心**：处理带权边构成的连通块，通过点权间的约束关系推导可行解范围。

**关键思路**：
1. **分割连通块**：忽略无边权的边，将原树拆分为由带权边连接的独立连通块（森林）。
2. **表达式推导**：对每个连通块，确定根节点点权为变量$x$，通过DFS/BFS生成其他点的点权表达式（形如$k±x$）。
3. **不等式求解**：将每个点的点权约束转换为关于$x$的不等式，合并所有不等式得到$x$的可行区间。
4. **结果计算**：各连通块的可行区间长度相乘即为总方案数，若任一区间无解则答案为0。

**解决难点**：
- **符号处理**：点权表达式中的正负号需在遍历时动态维护，解不等式时需注意符号对不等式方向的影响。
- **边界更新**：全局维护左边界最大值和右边界最小值，确保所有约束同时满足。

### 题解评分（≥4星）
1. **imzfx_Square（5星）**  
   - 思路清晰，代码简洁，维护`sign`变量动态处理符号变化，DFS中直接更新全局边界。
2. **MichaelWong（4星）**  
   - 使用`typ`数组记录符号状态，通过参数传递简化表达式推导，注释详细。
3. **masonpop（4星）**  
   - 结构体存储边信息，`typ`和`val`数组明确分离系数与常数项，逻辑清晰。

### 最优思路提炼
- **连通块独立处理**：将问题分解为多个独立子问题，降低复杂度。
- **线性表达式推导**：通过DFS动态生成每个点的点权表达式，维护符号和常数项。
- **不等式合并技巧**：利用`max`和`min`函数快速合并区间，避免复杂计算。

### 相似题目推荐
1. **P1265 树的直径**（图遍历与路径约束）
2. **P2294 狡猾的商人**（差分约束系统）
3. **P3275 糖果**（差分约束与不等式合并）

### 算法可视化设计
1. **动画流程**：
   - **步骤1**：展示原树，高亮带权边，逐步隐藏无边权边形成森林。
   - **步骤2**：选择一个连通块，以根节点为起点，DFS遍历时动态生成每个点的表达式（如`+x`或`-x`），并用不同颜色标记符号。
   - **步骤3**：在每个节点旁显示对应不等式，逐步更新全局区间范围，以动态柱状图展示区间变化。
   - **步骤4**：最终合并区间，若有效则显示绿色范围条，否则红色警告。

2. **复古像素风格**：
   - **节点表示**：8位像素方块，带权边显示为发光线条，无边权边为灰色虚线。
   - **音效**：遍历时播放“点击”音效，区间合并成功时播放上升音阶，失败时播放低沉音效。
   - **自动演示**：模拟AI自动选择根节点，逐步展开DFS过程，关键步骤暂停显示不等式推导。

### 核心代码实现
```cpp
// 作者：imzfx_Square 的DFS核心代码
void dfs(int x, int k, int sign) {
    vis[x] = true;
    // 解不等式 l ≤ (k + sign * x) ≤ r
    long long nl = l - k, nr = r - k;
    if (sign == -1) { // 处理符号反转
        swap(nl, nr);
        nl = -nl;
        nr = -nr;
    }
    ll = max(ll, nl); // 更新左边界
    rr = min(rr, nr); // 更新右边界
    for (int i = h[x]; i; i = e[i].next) {
        int v = e[i].to;
        if (!vis[v]) {
            // 传递新的常数和符号
            dfs(v, e[i].w - k, -sign);
        }
    }
}
```

### 个人心得摘录
- **符号处理教训**：初始未考虑符号反转导致不等式方向错误，通过手动推导样例发现并修正。
- **边界初始化**：根节点的初始范围应为`[l, r]`，漏掉此设置曾导致WA。
- **连通块特例**：单节点连通块需单独处理，直接贡献`r-l+1`种方案。

---
处理用时：107.97秒
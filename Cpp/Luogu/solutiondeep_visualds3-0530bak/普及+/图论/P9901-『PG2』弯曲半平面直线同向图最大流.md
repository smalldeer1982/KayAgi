# 题目信息

# 『PG2』弯曲半平面直线同向图最大流

## 题目描述

若能将有向图 $G=(V,E)$ 画在平面上，使得点在一条直线上，任意两条边（可以为弯曲的弧线）仅在重合顶点处相交，且边上的所有点都在直线同侧，且每条边的起点到终点的射线的方向相同，则称 $G$ 是弯曲半平面直线同向图。对于一个弯曲半平面直线同向图给定 $n$ 个点，$m$ 条有向边，给定每条边的容量，求从点 $s$ 到点 $t$ 的最大流。

## 说明/提示

无重边自环。

对于 $30\%$ 的数据 $n\leq 10^3$。

对于 $70\%$ 的数据 $n\leq 10^5$。

对于 $100\%$ 的数据 $2\leq n\leq 10^6$，$1\leq m\leq \min\{2\times 10^9,\dfrac{n(n-1)}{2}\}$，$1\leq c\leq 10^{12}$，$s\neq t$。

### 样例解释 1
![](https://cdn.luogu.com.cn/upload/image_hosting/9qletk0m.png)

## 样例 #1

### 输入

```
5 7 1 5
1 2 1
2 3 1
3 4 1
4 5 1
2 4 1
1 4 1
1 5 1```

### 输出

```
2```

# AI分析结果



**唯一算法分类**  
拓扑排序上的贪心算法  

---

**题解思路、算法要点与解决难点**  
1. **关键思路**  
   题目中的图具有特定结构（弯曲半平面直线同向图），本质是一个DAG且边的拓扑序无交叉。利用拓扑序的特性，最大流可通过贪心策略或转化为最小割问题解决：  
   - **贪心策略**：按拓扑序处理每个点，优先将流量分配给拓扑序最大的可达点，确保流量的高效传递。  
   - **最小割转化**：拓扑序上最小割对应一段前缀与后缀的分割，通过差分数组统计割容量，取最小值即为最大流。  

2. **核心实现步骤**  
   - **筛选有效点**：保留从源点可达且能到达汇点的点。  
   - **拓扑排序**：确定点的处理顺序。  
   - **边处理优化**：按拓扑序逆序处理边，避免排序（贪心法）或差分统计割容量（最小割法）。  

3. **难点对比**  
   - **贪心法**需维护每个点的剩余流量，按拓扑序处理边，时间复杂度为O(n)。  
   - **最小割法**利用差分数组高效统计割容量，时间复杂度同为O(n)，但实现更简洁。  

---

**题解清单 (≥4星)**  
1. **xixisuper (4星)**  
   - **亮点**：详细推导图的拓扑性质，提出贪心分配流量的思路，优化邻接表避免排序。  
   - **代码优化**：通过反向建图保证边有序，减少常数。  

2. **phigy (5星)**  
   - **亮点**：官方题解，直接按拓扑序分组边，实现O(n)复杂度，代码简洁高效。  
   - **代码片段**：  
     ```cpp  
     for(int i = n; i >= 1; i--){  
         for(auto [u, c]: buc[i]) to[u].emplace_back(i, c);  
     }  
     ```  

3. **qczrz6v4nhp6v4nhp6u (5星)**  
   - **亮点**：创新性地将问题转化为最小割，利用差分数组统计，时间复杂度最优。  
   - **代码片段**：  
     ```cpp  
     for(auto [u, v, c]: edges)  
         sum[dfn2[u]] += c, sum[dfn2[v]] -= c;  
     ll ans = min_element(sum + dfn2[s], sum + dfn2[t]);  
     ```  

---

**最优思路或技巧提炼**  
- **拓扑序的连续性**：边的终点在拓扑序上连续，避免交叉，确保贪心分配的正确性。  
- **差分数组统计割容量**：将最小割问题转化为前缀和计算，时间复杂度极低。  

---

**同类型题或类似算法套路**  
- **DAG上的最大流**：利用拓扑序性质优化传统算法。  
- **分层图或平面图最大流**：结合图的特殊结构简化问题。  

---

**推荐题目**  
1. P4001 [ICPC-Beijing 2006] 狼抓兔子（平面图最小割）  
2. P2762 太空飞行计划问题（最大权闭合子图）  
3. P4177 [CEOI2008] order（拓扑序与资源分配）  

---

**个人心得摘录**  
- **xixisuper**：低估`vector`的常数，改用邻接表优化，强调快读和变量类型优化。  
- **phigy**：指出边数隐含限制（m ≤ 2n−3），确保线性复杂度。  

---

**可视化与算法演示**  
1. **动画方案**  
   - **拓扑序排列**：将点按直线排列，颜色标记当前处理点。  
   - **流量分配**：动态显示流量从当前点流向拓扑序更大的邻点，高亮流量变化。  
   - **最小割统计**：用颜色块标记割点，差分数组逐步填充容量。  

2. **复古像素风格**  
   - **颜色方案**：8位色调色板，绿色表示有效流量，红色表示割边。  
   - **音效**：流量分配时播放“点击”音效，找到最小割时播放胜利音效。  

3. **AI自动演示**  
   - **步进模式**：按拓扑序逐步处理点，自动播放流量分配过程。  
   - **控制面板**：暂停/继续按钮，速度调节滑块，对比贪心与最小割两种算法。  

---

**核心代码实现（qczrz6v4nhp6u的最小割法）**  
```cpp  
// 筛选有效点并计算拓扑序  
dfs1(s); dfs2(t);  
for (int i=1; i<=n; i++) ck[i] = dfn1[i] && dfn2[i];  

// 差分统计割容量  
for (auto [u,v,w] : edges) {  
    if (ck[u] && ck[v])  
        sum[dfn2[u]] += w, sum[dfn2[v]] -= w;  
}  

// 计算最小割  
ll ans = INF;  
for (int i=dfn2[s]; i < dfn2[t]; i++) {  
    sum[i] += sum[i-1];  
    ans = min(ans, sum[i]);  
}  
cout << ans;  
```

---
处理用时：143.77秒
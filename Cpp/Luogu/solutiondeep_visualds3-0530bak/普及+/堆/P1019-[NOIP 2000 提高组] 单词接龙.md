# 题目信息

# [NOIP 2000 提高组] 单词接龙

## 题目背景

注意：本题为上古 NOIP 原题，不保证存在靠谱的做法能通过该数据范围下的所有数据。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)

NOIP2000 提高组 T3

## 题目描述

单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 `beast` 和 `astonish`，如果接成一条龙则变为 `beastonish`，另外相邻的两部分不能存在包含关系，例如 `at` 和 `atide` 间不能相连。


## 说明/提示

样例解释：连成的“龙”为 `atoucheatactactouchoose`。

$n \le 20$。

## 样例 #1

### 输入

```
5
at
touch
cheat
choose
tact
a
```

### 输出

```
23
```

# AI分析结果



**唯一算法分类**  
深度优先搜索（DFS）

---

**题解思路与解决难点**  
各题解的核心思路均为DFS，通过递归枚举所有可能的单词拼接组合。关键难点在于如何高效处理相邻单词的重合部分，并确保不出现包含关系。以下为各题解对比：

1. **重合部分处理**  
   - **RyanLi**：动态计算重合部分，每次递归时遍历所有可能的拼接长度，通过 `substr` 截取字符串比较。代码简洁，但重复计算可能影响效率。
   - **yedalong**：预处理 `g[i][j]` 保存最小重合长度，减少重复计算。预处理时间复杂度为 O(n²L)，DFS时直接查表，效率更高。
   - **__yiLIUyi__**：手动逐字符比较，避免 `substr` 的内存开销，更高效但代码稍显复杂。
   - **kungeruyi**：传递当前总长度而非字符串，减少字符串拷贝操作，优化内存使用。

2. **包含关系避免**  
   所有题解通过限制重合长度 `k` 必须小于两个单词长度，确保不出现包含关系。例如，`k < min(len(A), len(B))`。

3. **剪枝优化**  
   - **yedalong** 的预处理显著减少计算量。
   - **kungeruyi** 通过全局变量 `t` 记录长度，避免频繁字符串拼接。

---

**题解评分（≥4星）**  
1. **yedalong（★★★★★）**  
   - 预处理 `g[i][j]` 显著优化效率，代码结构清晰，可读性强。
   - 关键亮点：分离预处理与搜索逻辑，适合大规模数据扩展。

2. **RyanLi（★★★★☆）**  
   - 代码简洁，直接动态计算重合部分，适合小规模数据。
   - 不足：重复计算可能导致性能瓶颈。

3. **kungeruyi（★★★★☆）**  
   - 通过长度变量 `t` 替代字符串传递，优化内存使用。
   - 不足：变量命名稍欠直观。

---

**最优思路提炼**  
1. **预处理重合长度**  
   预处理每对单词的最小重合长度 `k`，确保拼接后总长度最大化。
   ```cpp
   for (int i=1; i<=n; i++) {
       for (int j=1; j<=n; j++) {
           for (int k=1; k<min(a[i].size(), a[j].size()); k++) {
               if (a[i].substr(a[i].size()-k) == a[j].substr(0, k)) {
                   g[i][j] = k;
                   break;
               }
           }
       }
   }
   ```
2. **DFS传递最后一个单词**  
   传递当前最后一个单词而非整个字符串，避免冗余计算。
   ```cpp
   void dfs(string last_word, int total_len) {
       for (int i=1; i<=n; i++) {
           int k = g[last_id][i];
           if (k > 0) {
               total_len += len(i) - k;
               dfs(i, total_len);
           }
       }
   }
   ```

---

**同类型题推荐**  
1. **P1101 单词方阵**（二维矩阵中的单词搜索）  
2. **P1433 吃奶酪**（状态压缩+DFS）  
3. **P1032 字串变换**（BFS优化字符串变换）

---

**可视化算法演示**  
1. **预处理阶段**  
   - 网格展示每对单词的最小重合长度，用颜色标记不同的 `k` 值。
   - 动态显示字符比较过程，高亮匹配部分。

2. **DFS过程**  
   - 动画显示当前拼接的龙字符串，用不同颜色标记已使用单词。
   - 回溯时恢复颜色和计数，步进控制观察递归树展开。

3. **复古游戏化效果**  
   - 8位像素风格，单词显示为方块，拼接时播放“连接音效”。
   - 自动模式下，AI演示最优路径，背景音乐循环播放。

---

**代码片段（yedalong预处理+DFS）**  
```cpp
// 预处理 g[i][j]
for (int i=1; i<=n; i++) {
    for (int j=1; j<=n; j++) {
        for (int k=1; k<min(a[i].size(), a[j].size()); k++) {
            if (a[i].substr(a[i].size()-k) == a[j].substr(0, k)) {
                g[i][j] = k;
                break;
            }
        }
    }
}

// DFS核心逻辑
void dfs(string s, int k) {
    maxx = max(maxx, (int)s.size());
    for (int i=1; i<=n; i++) {
        if (g[k][i] && cnt[i] < 2) {
            cnt[i]++;
            dfs(s + a[i].substr(g[k][i]), i);
            cnt[i]--;
        }
    }
}
```

---
处理用时：170.92秒
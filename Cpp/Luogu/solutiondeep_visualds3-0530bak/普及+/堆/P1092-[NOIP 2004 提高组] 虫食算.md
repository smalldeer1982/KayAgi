# 题目信息

# [NOIP 2004 提高组] 虫食算

## 题目描述

所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的数字。来看一个简单的例子：

$$\begin{aligned}
 \verb!43#9865#045! \\
+\qquad \verb!8468#6633! \\[-1em]\underline{\kern{8em}} \\
 \verb!44445509678! \\
\end{aligned}$$

其中 `#` 号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是 $5$ 和 $3$，第二行的数字是 $5$。

现在，我们对问题做两个限制：

首先，我们只考虑加法的虫食算。这里的加法是 $n$ 进制加法，算式中三个数都有 $n$ 位，允许有前导的 $0$。

其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是 $n$ 进制的，我们就取英文字母表的前 $n$ 个大写字母来表示这个算式中的 $0$ 到 $n - 1$ 这 $n$ 个不同的数字：但是这 $n$ 个字母并不一定顺序地代表 $0$ 到 $n-1$。输入数据保证 $n$ 个字母分别至少出现一次。

$$\begin{aligned}
 \verb!BADC! \\
+\quad \verb!CBDA! \\[-1em]\underline{\kern{4em}} \\
 \verb!DCCC! \\
\end{aligned}$$

上面的算式是一个4进制的算式。很显然，我们只要让 $\verb!ABCD!$ 分别代表 $0123$，便可以让这个式子成立了。你的任务是，对于给定的 $n$ 进制加法算式，求出 $n$ 个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 10$；
- 对于 $50\%$ 的数据，保证 $n \le 15$；
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 26$。

## 样例 #1

### 输入

```
5
ABCED
BDACE
EBBAA
```

### 输出

```
1 0 3 4 2
```

# AI分析结果



### 算法分类  
**深度优先搜索（DFS）+剪枝**

---

### 题解思路与解决难点  
#### 核心算法流程  
1. **DFS遍历字母赋值**：按特定顺序（如从低位到高位）尝试为字母分配数字  
2. **剪枝优化**：  
   - **最高位不进位**：若最高位产生进位则直接剪枝  
   - **当前位合法性检查**：若某位三个字母已赋值，但 `(A+B) mod n ≠ C` 且 `(A+B+1) mod n ≠ C` 则剪枝  
   - **搜索顺序优化**：优先处理竖式中低位出现的字母（通过`Next数组`实现）  

#### 关键数据结构  
```cpp  
int num[maxn];    // 字母对应的数字（-1表示未赋值）  
int Next[maxn];   // 搜索顺序数组（记录字母优先级）  
bool used[maxn];  // 数字是否被使用  
```

#### 解决难点对比  
| 题解作者       | 核心优化点                                                                 |  
|----------------|--------------------------------------------------------------------------|  
| zzlzk          | 从低位到高位搜索 + 两次剪枝（最高位不进位、当前位合法性检查） + `Next数组`优化顺序 |  
| feecle6418     | 改变搜索顺序为竖式最低位优先，显著减少无效分支                                   |  
| Tgotp          | 动态剪枝：若当前列三个字母已知且无论如何无法满足条件，则直接返回                     |  

---

### 题解评分（≥4星）  
#### 1. zzlzk（⭐⭐⭐⭐）  
- **亮点**：  
  - 清晰解释剪枝逻辑与搜索顺序优化  
  - 代码可读性强，`Next数组`设计巧妙  
  - 实测性能优异（洛谷提交44ms）  

#### 2. feecle6418（⭐⭐⭐⭐）  
- **亮点**：  
  - 详细对比暴力搜索与优化版本的差异  
  - 提供可复现的剪枝调试思路（如`ok_()`函数改进）  

#### 3. Tgotp（⭐⭐⭐⭐）  
- **亮点**：  
  - 动态剪枝逻辑简洁高效（`pd()`函数检查高位合法性）  
  - 代码实现短小精悍（仅80行）  

---

### 最优思路提炼  
1. **搜索顺序优化**：从竖式**最低位开始搜索**，优先处理影响进位的关键位  
2. **知二求一剪枝**：若某列已知两个加数，可直接推导第三数（如 `c = (a + b + carry) % n`）  
3. **进位约束传递**：通过`k[temp]`数组记录每列的进位状态，避免重复计算  

---

### 同类型题与算法套路  
**通用解法**：  
- **DFS剪枝**：适用于状态空间大但存在强约束的问题（如数独、八皇后）  
- **进位链式推导**：类似高精度加法中的逐位处理  

**推荐题目**：  
1. [P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)  
2. [P1120 小木棍](https://www.luogu.com.cn/problem/P1120)  
3. [P1784 数独](https://www.luogu.com.cn/problem/P1784)  

---

### 个人心得摘录  
> "从低位开始搜，进位状态直接影响后续位的合法性。如果先处理高位，进位的不确定性会导致大量无效分支。"  
> —— zzlzk题解调试经验  

> "暴力全排列只能过30分，但调整搜索顺序后直接AC，可见剪枝顺序的重要性。"  
> —— feecle6418优化感悟  

---

### 算法可视化设计  
#### 动画方案（8位像素风格）  
1. **界面布局**：  
   - **左侧**：竖式加法界面，每个字母用16x16像素方块表示  
   - **右侧**：当前字母赋值状态（类似FC游戏中的状态栏）  

2. **关键动画**：  
   - **赋值操作**：选中字母方块后闪烁，显示候选数字（图1）  
   - **剪枝触发**：非法操作时播放"失败音效"，方块变红闪烁（图2）  

3. **交互设计**：  
   ```javascript  
   // 伪代码：DFS单步执行  
   function dfsStep(step) {  
     highlightColumn(step);  // 高亮当前处理的列  
     for (let num = n-1; num >=0; num--) {  
       if (used[num]) continue;  
       assignNumber(currentChar, num);  // 更新界面显示  
       if (checkPrune()) {  
         playSound('prune');  // 剪枝音效  
         continue;  
       }  
       proceedToNextStep();  // 进入下一层递归  
     }  
   }  
   ```  

4. **音效设计**：  
   - **赋值成功**：8-bit风格"叮"声（Web Audio API生成）  
   - **剪枝触发**：短促"哔"声  
   - **搜索完成**：经典FC过关音乐片段  

---

### 核心代码实现  
#### zzlzk题解剪枝逻辑  
```cpp  
bool CanPrune() {  
    // 最高位不能有进位  
    if(num[a[0]] + num[b[0]] >= n) return true;  
    // 当前位合法性检查  
    for(int i = n-1; i >= 0; i--) {  
        int A = num[a[i]], B = num[b[i]], C = num[c[i]];  
        if(A == -1 || B == -1 || C == -1) continue;  
        if((A+B)%n != C && (A+B+1)%n != C) return true;  
    }  
    return false;  
}  
```  

#### 搜索顺序初始化  
```cpp  
void GetNext(int x) {  
    if(!used[x]) {  
        used[x] = true;  
        Next[cnt++] = x;  // 按出现顺序记录待搜索字母  
    }  
}  
// 初始化时从低位到高位扫描字母  
for(int i = n-1; i >= 0; i--) {  
    GetNext(a[i]);  
    GetNext(b[i]);  
    GetNext(c[i]);  
}  
```

---
处理用时：87.09秒
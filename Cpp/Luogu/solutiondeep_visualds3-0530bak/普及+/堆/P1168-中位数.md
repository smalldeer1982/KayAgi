# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果



**唯一算法分类**：对顶堆（双堆法）

---

### **题解思路与算法要点**

1. **核心思路**  
   维护两个堆：大根堆存较小的一半，小根堆存较大的一半。插入时动态调整两堆大小差不超过1，中位数为较大堆的堆顶。

2. **解决难点**  
   - 动态维护有序序列的中位数：通过堆的自动排序特性，避免每次排序的O(n logn)开销  
   - 平衡堆的大小：通过交换堆顶元素确保两堆大小差≤1，保证中位数始终在堆顶  

3. **关键变量与操作**  
   - `q1`（大根堆）：存储前一半较小的数  
   - `q2`（小根堆）：存储后一半较大的数  
   - 插入时判断新元素与当前中位数的大小关系，选择堆插入  
   - 调整堆大小差时交换堆顶元素  

---

### **题解评分（≥4星）**

1. **肖恩Sean（★★★★☆）**  
   - 代码简洁，双堆逻辑清晰  
   - 动态调整堆大小差逻辑明确  
   - 适用性广，时间复杂度O(n logn)  

2. **IRipple（★★★★☆）**  
   - 引入`mid`变量直观表示当前中位数  
   - 调整堆时直接移动`mid`，代码可读性高  
   - 流程图辅助理解堆调整过程  

3. **张小源（★★★☆☆）**  
   - 手写堆实现，适合理解底层逻辑  
   - 代码较长但流程清晰，适合教学  

---

### **最优思路提炼**

**对顶堆核心流程**  
1. 初始化：大根堆存第一个元素  
2. 插入元素：  
   - 若新元素≤大根堆顶 → 插入大根堆  
   - 否则 → 插入小根堆  
3. 平衡堆大小：  
   ```python
   while abs(q1.size - q2.size) > 1:
       if q1.size > q2.size:
           q2.push(q1.pop())
       else:
           q1.push(q2.pop())
   ```
4. 输出中位数：较大堆的堆顶  

---

### **同类型题推荐**

1. **P1801 黑匣子**  
   - 动态维护第k小元素，双堆解法变形  
2. **P3871 [TJOI2010]中位数**  
   - 动态插入+查询中位数，直接套用对顶堆  
3. **P3382 【模板】线段树】区间第k大**  
   - 树状数组/线段树的二分查找解法  

---

### **可视化算法演示**

**对顶堆动态调整过程（伪代码动画）**  
```javascript
// 初始化堆
q1 = MaxHeap([5]), q2 = MinHeap()
current_median = 5

// 插入元素3和7
insert(3 → q1), insert(7 → q2)
// 堆状态: q1=[3,5], q2=[7] → 大小差=1 → 中位数=q1.top()

// 插入元素9和4
insert(9 → q2), insert(4 → q1)
// 调整后: q1=[3,4], q2=[5,7,9] → 中位数=q2.top()
```

**动画设计要点**  
- **颜色标记**：  
  - 红色高亮新插入元素  
  - 蓝色标记被交换的堆顶  
- **步进控制**：  
  - 单步执行插入、调整、输出操作  
- **复古像素风格**：  
  - 堆用矩形块表示，堆顶闪烁显示  
  - 音效：插入时“哔”声，调整时“咔嗒”声  

---

### **核心代码实现**

```cpp
priority_queue<int> q1; // 大根堆
priority_queue<int, vector<int>, greater<int>> q2; // 小根堆

void insert(int x) {
    if (x <= q1.top()) q1.push(x);
    else q2.push(x);
    
    // 平衡堆大小
    while (abs(q1.size() - q2.size()) > 1) {
        if (q1.size() > q2.size()) {
            q2.push(q1.top());
            q1.pop();
        } else {
            q1.push(q2.top());
            q2.pop();
        }
    }
}

int get_median() {
    return q1.size() > q2.size() ? q1.top() : q2.top();
}
```

---

### **总结**  
对顶堆法以O(n logn)的时间复杂度高效解决动态中位数问题，代码简洁且易于扩展。通过维护两个堆的平衡，将中位数查询优化为O(1)操作，是竞赛中此类问题的首选解法。

---
处理用时：88.65秒
# 题目信息

# 小Z的神奇数列

## 题目背景

小Z最近在研究数列，他需要知道在他所研究的数列中，最大的数是多少（Max），最小的数是多少（Min），最大的数的最小的数次幂是多少（Max^Min），所有数的乘积是多少。要知道，这样的问题是肯定难不倒小Z的。但是，最近小Z突发奇想，想要研究下这个数列的更深层的性质，所以他决定不断的从这个数列中删去一些数，每次删除后都研究下当前数列。由于数列项数很大，这给小Z带来了很大的麻烦，于是小Z请你帮他写一个程序，来完成下列操作。

## 题目描述

你需要维护一个可重集，支持五种操作：

- `D x` 表示删除 $x$，保证 $x$ 一定存在。若有多个只用删除一个。

- `B` 询问集合中最大值。

- `S` 询问集合中最小值。

- `M` 设集合中最大值为 $a$，最小值为 $b$，询问 $a^b \bmod 317847191$。

- `T` 询问数列中所有数的乘积，对 $317847191$ 取模。

对于所有询问保证集合非空。


## 说明/提示

【数据规模】  
对于部分数据，$1 \le n \le 1000$，$1\le m \le 100$，$1\le a_i \le 400$；  
对于 $100\%$ 的数据，$1\le n,m \le 10^6$，$1\le a_i \le 10^8$。


## 样例 #1

### 输入

```
3 6
2 6 9
M
D 9
B
S
M
T```

### 输出

```
81
6
2
36
12```

# AI分析结果



**唯一算法分类**  
离线处理

---

**综合分析与结论**  
该题核心在于维护动态集合的极值与乘积，难点在于高效处理删除操作对乘积的影响。离线处理通过逆序将删除转化为插入，极大简化了维护逻辑：  
1. **极值维护**：初始处理未删除元素，逆序插入时只需比较更新最大值/最小值。  
2. **乘积计算**：插入时直接累乘，避免了在线处理中复杂的逆元与模数分解。  
3. **复杂度优化**：所有操作时间复杂度为O(n + m)，显著优于在线数据结构。  

**可视化设计**：  
- **像素动画**：初始数组以灰色方块表示被删除元素，逆序插入时亮起绿色方块并更新极值位置。  
- **音效提示**：插入时播放“滴”声，查询操作触发对应音调（如高音为最大值，低音为最小值）。  
- **自动演示**：按逆序步骤自动执行插入，用户可调节速度观察极值与乘积变化。

---

**题解清单 (≥4星)**  
1. **夏色祭（5星）**  
   - **亮点**：离线逆序处理简化逻辑，代码简洁高效。  
   - **引用**：“从后往前搞，每次把删的数重新加进去”直击问题本质。  

2. **nekko（4星）**  
   - **亮点**：快速幂与乘积维护结合，代码易读性强。  

3. **Chinese_zjc_（4星）**  
   - **亮点**：在线分解模数质因子，巧妙处理逆元问题，思路独特。  

---

**最优思路或技巧提炼**  
1. **离线逆序**：将删除操作转为插入，避免动态维护困难。  
2. **极值动态更新**：插入时直接比较更新，无需复杂数据结构。  
3. **乘积累乘优化**：离线处理保证乘法无逆元问题，直接模运算即可。  

---

**同类型题或类似算法套路**  
- **动态维护极值**：如滑动窗口最大值（双端队列）。  
- **离线逆序处理**：适用于删除操作可逆的题目（如并查集动态删边）。  

---

**推荐相似题目**  
1. **P1972 [SDOI2009]HH的项链**（离线处理区间查询）  
2. **P1801 黑匣子**（动态维护第k小值）  
3. **P3383 【模板】线性筛素数**（质因数分解预处理）  

---

**代码核心实现（夏色祭题解）**  
```cpp
sort(a + 1, a + n + 1);
for (int i = 1; i <= m; ++i) {
    if (op[i] == 'D') {
        // 标记删除位置
        int pos = lower_bound(a + 1, a + n + 1, x[i]) - a;
        a[pos] = INF;
    }
}
// 初始计算未删除元素的乘积与极值
for (int i = 1; i <= n; ++i) {
    if (a[i] != INF) {
        sum = sum * a[i] % MOD;
        maxv = max(maxv, a[i]);
        minv = min(minv, a[i]);
    }
}
// 逆序处理操作
for (int i = m; i >= 1; --i) {
    if (op[i] == 'D') {
        sum = sum * x[i] % MOD; // 插入被删除元素
        maxv = max(maxv, x[i]);
        minv = min(minv, x[i]);
    }
    // 记录查询结果
}
```

---

**可视化与算法演示**  
1. **动画步骤**：  
   - **初始状态**：显示排序后的数组，灰色为删除元素，绿色为有效元素。  
   - **逆序插入**：从最后一个操作开始，被删除元素（红色标记）逐步转为绿色，极值指针动态移动。  
   - **查询高亮**：执行查询时，最大值/最小值以闪烁特效标记，乘积显示当前数值。  

2. **交互功能**：  
   - **速度调节**：滑动条控制自动演示速度（100ms~2s/步）。  
   - **单步执行**：点击按钮逐步观察插入与查询影响。  

3. **音效设计**：  
   - **插入**：短促“滴”声（频率随插入数值大小变化）。  
   - **查询**：最大值触发高音“叮”，最小值触发低音“咚”。  

--- 

**复古游戏化效果（示例伪代码）**  
```javascript
// Canvas绘制数组元素
function drawArray() {
    ctx.clearRect(0, 0, width, height);
    for (let i = 0; i < n; i++) {
        if (a[i] === INF) ctx.fillStyle = '#666'; // 灰色表示已删除
        else ctx.fillStyle = '#0f0'; // 绿色有效元素
        ctx.fillRect(i * 10, 0, 8, 8);
        // 高亮当前操作元素
        if (i === currentPos) ctx.fillStyle = '#f00';
    }
}
// 音效触发
function playSound(freq) {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = freq;
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(0.1);
}
```

---
处理用时：104.29秒
# 题目信息

# 【XR-3】核心城市

## 题目描述

X 国有 $n$ 座城市，$n - 1$ 条长度为 $1$ 的道路，每条道路连接两座城市，且任意两座城市都能通过若干条道路相互到达，显然，城市和道路形成了一棵树。

X 国国王决定将 $k$ 座城市钦定为 X 国的核心城市，这 $k$ 座城市需满足以下两个条件：

1. 这 $k$ 座城市可以通过道路，在不经过其他城市的情况下两两相互到达。
2. 定义某个非核心城市与这 $k$ 座核心城市的距离为，这座城市与 $k$ 座核心城市的距离的最小值。那么所有非核心城市中，与核心城市的距离最大的城市，其与核心城市的距离最小。你需要求出这个最小值。

## 说明/提示

【样例说明】

钦定 $1,2,5$ 这 $3$ 座城市为核心城市，这样 $3,4,6$ 另外 $3$ 座非核心城市与核心城市的距离均为 $1$，因此答案为 $1$。

## 样例 #1

### 输入

```
6 3
1 2
2 3
2 4
1 5
5 6
```

### 输出

```
1
```

# AI分析结果



## **算法分类**  
树形结构、贪心算法、树的直径、拓扑排序

---

## **题解思路与解决难点**  
### **核心思路对比**  
1. **直径中点法（SCAU_Lnn、Cylete、Y_B_Y等）**  
   - **核心逻辑**：  
     - 找到树的直径，确定中点作为根节点。  
     - 计算每个节点的子树最大深度 `maxd[i]` 和自身深度 `d[i]`，按 `maxd[i]-d[i]` 降序排序。  
     - 前 `k` 个节点为核心城市，剩余节点的 `maxd[i]-d[i]+1` 的最大值即为答案。  
   - **难点**：  
     - 正确性证明：需保证直径中点是最优核心城市的关键点。  
     - 子树最大深度的动态规划计算。  

2. **拓扑排序法（wheneveright、localhost、Hexarhy等）**  
   - **核心逻辑**：  
     - 从叶子节点（度为1的点）开始，逐层剥除非核心城市。  
     - 使用队列维护当前叶子节点，统计剥去 `n-k` 层后的剩余层数即为答案。  
   - **难点**：  
     - 证明剥去叶子的层数对应最大距离的最小值。  
     - 队列的动态更新与层数统计。  

---

## **最优思路提炼**  
1. **直径中点法的关键步骤**  
   - **两次DFS求直径**：确定直径端点后回溯中点。  
   - **子树深度计算**：DFS遍历计算每个节点的 `maxd` 和 `d`。  
   - **贪心排序**：按 `maxd[i]-d[i]` 降序选择前 `k` 个节点。  

2. **拓扑排序法的关键步骤**  
   - **叶子节点初始化**：将所有度为1的节点加入队列。  
   - **层次剥离**：逐层剥离叶子节点，统计层数直到剩余 `k` 个核心城市。  

---

## **题解评分（≥4星）**  
| 题解作者 | 星级 | 亮点 |  
|---------|------|------|  
| **wheneveright** | ★★★★★ | 思路简洁，代码高效，时间复杂度 `O(n)`，拓扑排序实现直观。 |  
| **localhost** | ★★★★☆ | 代码极简，无复杂数据结构，直接队列操作。 |  
| **Hexarhy** | ★★★★☆ | 代码清晰，附带详细注释和游戏化动画设计思路。 |  

---

## **代码实现与核心逻辑**  
### **拓扑排序法（wheneveright）**  
```cpp  
void solve() {  
    queue<int> q;  
    for (int i = 1; i <= n; i++)  
        if (du[i] == 1) q.push(i), du[i] = 0;  
    while (cnt <= n - k) {  
        ans++;  
        queue<int> tmp;  
        while (!q.empty()) {  
            int u = q.front(); q.pop();  
            cnt++;  
            for (int v : edge[u]) {  
                du[v]--;  
                if (du[v] == 1) tmp.push(v), du[v] = 0;  
            }  
        }  
        q = tmp;  
    }  
}  
```  
**核心逻辑**：  
1. 初始化所有叶子节点，逐层剥离。  
2. 每剥离一层，统计剩余节点数，直到保留 `k` 个核心城市。  
3. 剥离的层数即为最大距离的最小值。  

---

## **同类型题与算法套路**  
- **通用解法**：  
  - 树的直径用于解决最长路径问题。  
  - 拓扑排序用于层次化处理树或图的节点。  
- **推荐题目**：  
  - [P1099 树网的核](https://www.luogu.com.cn/problem/P1099)  
  - [P3629 [APIO2010]巡逻](https://www.luogu.com.cn/problem/P3629)  
  - [P5536 【XR-3】核心城市](https://www.luogu.com.cn/problem/P5536)（本题）  

---

## **可视化与算法演示**  
### **动画设计方案（拓扑排序法）**  
1. **树形结构绘制**：  
   - 初始树以 **8位像素风格** 绘制，节点用不同颜色区分核心与非核心。  
   - 叶子节点高亮为红色，核心节点保持绿色。  

2. **剥离过程动态展示**：  
   - **Canvas 动画**：  
     - 每帧显示当前叶子节点（红色方块），剥离后变为灰色。  
     - 剥离一层后，新的叶子节点自动高亮。  
   - **音效设计**：  
     - 剥离节点时播放短促“滴”声，完成一层后播放上扬音效。  

3. **交互控制**：  
   - **自动/手动模式**：支持暂停、步进、调整动画速度。  
   - **统计面板**：显示当前层数、剩余核心数。  

### **复古像素风格示例（JS片段）**  
```javascript  
function drawTree(ctx) {  
    // 8位风格颜色  
    const colors = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4"];  
    nodes.forEach(node => {  
        ctx.fillStyle = node.isCore ? "#96CEB4" : "#FF6B6B";  
        ctx.fillRect(node.x, node.y, 16, 16); // 16x16像素方块  
    });  
}  
```  

---

## **总结**  
- **核心算法**：两种方法均有效，拓扑排序法更高效，直径中点法更直观。  
- **可视化设计**：复古像素动画能直观展示节点剥离过程，音效增强交互体验。  
- **扩展思考**：树的直径和拓扑排序是树形问题的通用工具，需熟练掌握。

---
处理用时：95.00秒
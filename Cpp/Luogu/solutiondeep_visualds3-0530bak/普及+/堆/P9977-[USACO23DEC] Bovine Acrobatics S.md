# 题目信息

# [USACO23DEC] Bovine Acrobatics S

## 题目描述

Farmer John 决定让他的奶牛表演杂技！首先，FJ 为他的奶牛称重，发现她们有 $N$（$1\le N\le 2\times 10^5$）个不同的体重。具体来说，对于全部的 $i\in [1,N]$，有 $a_i$ 只奶牛的体重为 $w_i$ 单位（$1\le a_i\le 10^9, 1\le w_i\le 10^9$）。

他最出名的节目需要奶牛叠成**平衡的奶牛塔**。一座**奶牛塔**是一些奶牛，每只奶牛站在下一只奶牛身上。一座奶牛塔是**平衡的**，当且仅当每一只被踩着的奶牛，都比**直接**踩在它身上的那只奶牛重至少 $K$（$1\le K\le 10^9$）单位。每只奶牛都可以成为奶牛塔的一部分。

如果 FJ 想要创造最多 $M$（$1 \le M \le 10^9$）座奶牛塔，最多有多少只奶牛可以成为奶牛塔的一部分？

## 说明/提示

### 样例解释 1

FJ 可以用体重为 $5,7,9$ 的奶牛创造四座平衡的奶牛塔，再用体重为 $5,7$ 的奶牛创造另一座。

### 样例解释 2

FJ 可以用体重为 $5,9$ 的奶牛创造四座平衡的奶牛塔，再用体重为 $7$ 的一只奶牛创造另一座。或者，他可以用体重为 $5,9$ 的奶牛创造四座平衡的奶牛塔，再用体重为 $5$ 的一只奶牛创造另一座。

### 测试点性质

- 测试点 $3-5$ 满足 $M \le 5000$ 且奶牛的总数不超过 $5000$。
- 测试点 $6-11$ 满足奶牛的总数不超过 $2\cdot 10^5$。
- 测试点 $12-17$ 没有额外限制。


## 样例 #1

### 输入

```
3 5 2
9 4
7 6
5 5```

### 输出

```
14```

## 样例 #2

### 输入

```
3 5 3
5 5
7 6
9 4```

### 输出

```
9```

# AI分析结果



---

**算法分类**：贪心算法 + 双指针

---

### **题解思路与核心难点**

#### **核心思路**
1. **排序与贪心**：将奶牛按体重从小到大排序，保证每次处理的是当前最小的可用体重。优先使用体重更小的奶牛，可以使得后续能叠放的塔顶更灵活（因为后续的奶牛体重更大，可选的塔顶范围更广）。
2. **动态维护可用塔数**：通过双指针维护当前可用的塔数 `m`。当处理到奶牛 `i` 时，释放所有塔顶体重满足 `w_i - w_j ≥ K` 的塔（即这些塔可以再次被叠放），并将这些塔的数量重新加入可用池。
3. **贪心分配**：每次尽可能多地使用当前体重的奶牛，即 `ans += min(m, a_i)`，并更新可用塔数 `m`。

#### **解决难点**
1. **高效释放可用塔**：使用双指针技巧，在排序后逐个释放满足条件的塔，时间复杂度为 `O(N)`。
2. **处理大规模数据**：由于 `a_i` 和 `M` 可能高达 `1e9`，不能逐个处理奶牛，而是批量处理每个体重段。

---

### **题解评分（≥4星）**

1. **作者：Little_x_starTYJ (⭐⭐⭐⭐⭐)**  
   - 思路清晰，代码简洁，使用双指针维护可用塔数，时间复杂度最优。
   - 关键代码片段：通过 `while` 循环释放满足条件的塔。
   ```c
   while (id < i && c[i].b - c[id].b >= k)
       m += ans[id++];
   ```

2. **作者：_qingshu_ (⭐⭐⭐⭐)**  
   - 类似双指针思路，代码可读性高，变量命名清晰。
   - 核心代码与第一名题解相似，但未显式处理塔顶的合并。

3. **作者：kczw (⭐⭐⭐⭐)**  
   - 代码最简，直接使用双指针和队列维护可用塔数。
   - 关键代码：
   ```cpp
   while(t <= i-1 && a[i].w - a[t].w >= k) m += num[t++];
   ```

---

### **最优思路提炼**
1. **排序预处理**：按体重从小到大排序，保证贪心策略的正确性。
2. **双指针释放塔**：维护左指针 `j`，当处理到体重 `w_i` 时，释放所有满足 `w_i - w_j ≥ K` 的塔，并将这些塔的数量重新加入可用池。
3. **贪心分配当前奶牛**：使用 `min(m, a_i)` 计算当前体重可分配的奶牛数，并更新 `m`。

---

### **同类型题或算法套路**
1. **区间调度问题**：如用最少箭数射爆气球（按区间右端点排序）。
2. **贪心分配资源**：如分配饼干（尽可能满足更多孩子）。
3. **双指针维护动态窗口**：如滑动窗口中的最大值问题。

---

### **推荐相似题目**
1. **P1090 合并果子**：贪心选择最小堆，每次合并最小的两堆。
2. **P1223 排队接水**：按时间排序，最小化总等待时间。
3. **P1080 国王游戏**：贪心排序后处理最大值的分配。

---

### **可视化与算法演示**
#### **动画设计**
- **数据结构**：画布中显示排序后的奶牛队列，用不同颜色表示已分配和未分配的塔。
- **关键步骤**：
  1. **排序阶段**：显示奶牛按体重从小到大排列。
  2. **双指针移动**：左指针 `j` 高亮，右指针 `i` 处理当前体重，释放满足 `w_i - w_j ≥ K` 的塔。
  3. **贪心分配**：显示 `m` 的值和当前分配的奶牛数 `min(m, a_i)`。
- **复古像素风格**：奶牛用像素方块表示，塔顶用不同颜色标记，释放时播放“叮”音效。

#### **交互设计**
- **步进控制**：用户可调整速度或单步执行，观察指针移动和塔的释放。
- **音效提示**：分配奶牛时播放短音效，释放塔时播放低音。

---

### **核心代码实现**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
struct Cow { int w, a; } cows[N];
long long ans;
int num[N]; // 记录每个体重分配的塔数

int main() {
    int n, m, k;
    cin >> n >> m >> k;
    for (int i = 1; i <= n; ++i) cin >> cows[i].w >> cows[i].a;
    sort(cows + 1, cows + n + 1, [](Cow x, Cow y) { return x.w < y.w; });

    int j = 1; // 左指针，维护可释放的塔
    for (int i = 1; i <= n; ++i) {
        // 释放满足条件的塔：cows[i].w - cows[j].w >= k
        while (j <= i && cows[i].w - cows[j].w >= k) m += num[j++];
        num[i] = min(cows[i].a, m);
        m -= num[i];
        ans += num[i];
    }
    cout << ans << endl;
    return 0;
}
```

---

### **总结**
本题通过排序和双指针技巧，高效维护可用塔数，实现贪心策略的最优解。核心在于动态释放满足条件的塔，并批量分配当前体重的奶牛。代码简洁高效，适用于大规模数据。

---
处理用时：79.61秒
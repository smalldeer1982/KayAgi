# 题目信息

# 【模板】KMP

## 题目描述

给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。  
现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。

定义一个字符串 $s$ 的 border 为 $s$ 的一个**非 $s$ 本身**的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。  
对于 $s_2$，你还需要求出对于其每个前缀 $s'$ 的最长 border $t'$ 的长度。

## 说明/提示

### 样例 1 解释

 ![](https://cdn.luogu.com.cn/upload/pic/2257.png)。
 
对于 $s_2$ 长度为 $3$ 的前缀 `ABA`，字符串 `A` 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为 $1$。


### 数据规模与约定

**本题采用多测试点捆绑测试，共有 3 个子任务**。

- Subtask 1（30 points）：$|s_1| \leq 15$，$|s_2| \leq 5$。
- Subtask 2（40 points）：$|s_1| \leq 10^4$，$|s_2| \leq 10^2$。
- Subtask 3（30 points）：无特殊约定。

对于全部的测试点，保证 $1 \leq |s_1|,|s_2| \leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。

## 样例 #1

### 输入

```
ABABABC
ABA
```

### 输出

```
1
3
0 0 1 
```

# AI分析结果



### 【唯一算法分类】  
**字符串匹配算法**

---

### 【综合分析与结论】  
KMP算法通过**前缀函数(next数组)**优化字符串匹配，核心在于利用已匹配信息跳过重复比较。关键难点在于：  
1. **next数组的构建**：通过模式串自匹配推导最长公共前后缀，实现**O(m)**预处理  
2. **失配跳转**：匹配失败时通过next值快速调整模式串位置，实现**O(n)**匹配  

**可视化设计要点**：  
- **双指针动画**：用不同颜色标记文本串指针i与模式串指针j，高亮当前比较字符  
- **next数组构建过程**：动态展示模式串自我匹配时前后缀重叠检测，用连接线标注相同字符段  
- **跳转逻辑**：失配时用红色闪烁提示，显示j=next[j]的跳转路径  
- **像素风格**：采用16色调色板（如#FF6B6B表指针、#4ECDC4表匹配成功），Canvas绘制字符块移动动画  

---

### 【题解清单 (≥4星)】  
1. **皎月半洒花（5星）**  
   - 亮点：图解前后缀原理，详细推导next数组，代码注释清晰  
   - 代码片段：  
     ```cpp
     void getfail() {
         for (int i=1; i<lp; ++i) {
             while(j && p[i]!=p[j]) j=next[j];
             if(p[i]==p[j]) j++;
             next[i+1]=j;
         }
     }
     ```

2. **KesdiaelKen（4.5星）**  
   - 亮点：代码简洁规范，匹配循环逻辑紧凑  
   - 代码片段：  
     ```cpp
     for(int i=0; i<la; ++i) {
         while(j>0 && a[i]!=b[j]) j=next[j];
         if(a[i]==b[j]) j++;
         if(j==lb) cout<<i-lb+2<<endl;
     }
     ```

3. **frostime（4星）**  
   - 亮点：包含next数组优化版本，对比MP与KMP差异  
   - 技巧：优化版next避免重复比较相同字符  
   ```cpp
   void ConstructNext() {
       if(p[i]==p[lastNext]) 
           next[i] = (p[i]==p[next[lastNext]]) ? next[lastNext] : lastNext;
   }
   ```

---

### 【最优思路提炼】  
1. **双指针同步移动**：i永不回溯，j通过next值跳转  
2. **自相似性利用**：模式串前缀的后缀=已匹配文本的后缀  
3. **失败跳转公式**：新j = next[旧j] （隐含数学归纳法证明）  
4. **边界处理技巧**：next[0]=-1简化代码逻辑  

---

### 【同类型题推荐】  
1. **P3449 [POI2006]PAL-Palindromes**（扩展KMP应用）  
2. **P3808 【模板】AC自动机（简单版）**（KMP的树形扩展）  
3. **P5410 【模板】扩展 KMP**（Z算法与KMP对比）

---

### 【可视化代码片段】  
```javascript
// Canvas绘制匹配过程（简化版）
function drawKMP(t, p, i, j) {
  ctx.fillStyle = "#2D3436"; // 背景色
  ctx.fillRect(0,0,canvas.width,canvas.height);
  
  // 绘制文本串
  t.split('').forEach((c,idx)=> {
    ctx.fillStyle = (idx === i) ? "#FF6B6B" : "#FFFFFF"; // 当前i指针红色
    ctx.fillText(c, 20+idx*30, 50);
  });

  // 绘制模式串跳转位置
  p.split('').forEach((c,idx)=> {
    ctx.fillStyle = (idx === j) ? "#FF6B6B" : "#4ECDC4"; // 当前j指针红色
    ctx.fillText(c, 20+(i-j+idx)*30, 100); 
  });
}

// 音效触发
function playSound(type) {
  if(type === 'match') beep(523.25); // 高音Do表匹配成功
  else if(type === 'jump') beep(261.63); // 低音Do表跳转
}
```

---

### 【复古像素风格设计】  
1. **调色板**：  
   - 背景：#2D3436（深灰）  
   - 文本：#FFFFFF（白）  
   - 指针：#FF6B6B（珊瑚红）  
   - 匹配区块：#4ECDC4（蓝绿）  

2. **动画效果**：  
   - 字符块以8x8像素单元呈现，失配时抖动+红闪  
   - 跳转时显示虚线箭头：j→next[j]  
   - 通关彩蛋：全匹配后显示16-bit风格"WINNER!"  

3. **音效设计**：  
   - 匹配成功：短促上升琶音  
   - 跳转触发：电子滴答声  
   - 背景音乐：8-bit版《卡农》循环  

---

通过交互式可视化，学习者可逐步观察指针移动与next跳转逻辑，结合音效反馈深化对KMP数学原理的理解。

---
处理用时：81.38秒
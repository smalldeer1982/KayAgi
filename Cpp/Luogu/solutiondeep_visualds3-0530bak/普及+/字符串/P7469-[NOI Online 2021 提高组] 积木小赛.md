# 题目信息

# [NOI Online 2021 提高组] 积木小赛

## 题目描述

Alice 和 Bob 最近热衷于玩一个游戏——积木小赛。

Alice 和 Bob 初始时各有 $n$ 块积木从左至右排成一排，每块积木都被标上了一个英文小写字母。

Alice 可以从自己的积木中丢掉任意多块（也可以不丢）；Bob 可以从自己的积木中丢掉最左边的一段连续的积木和最右边的一段连续的积木（也可以有一边不丢或者两边都不丢）。两人都不能丢掉自己所有的积木。然后 Alice 和 Bob 会分别将自己剩下的积木按原来的顺序重新排成一排。

Alice 和 Bob 都忙着去玩游戏了，于是想请你帮他们算一下，有多少种不同的情况下他们最后剩下的两排积木是相同的。

两排积木相同，当且仅当这两排积木块数相同且每一个位置上的字母都对应相同。

两种情况不同，当且仅当 Alice（或者 Bob）剩下的积木在两种情况中不同。

## 说明/提示

对于所有测试点：$1\le n \le 3000$，$s$ 与 $t$ 中只包含英文小写字母。

测试点 $1$ 满足：$n\le3000$，$s$ 与 $t$ 中只包含同一种字母。

测试点 $2,3,4$ 满足：$n\le100$。

测试点 $5,6,7$ 满足：$n\le500$。

测试点 $8,9,10$ 满足：$n\le3000$。

感谢 [w33z8kqrqk8zzzx33](https://www.luogu.com.cn/user/220037) 提供测试数据。

## 样例 #1

### 输入

```
5
bcabc
bbcca```

### 输出

```
9```

## 样例 #2

### 输入

```
20
egebejbhcfabgegjgiig
edfbhhighajibcgfecef```

### 输出

```
34```

# AI分析结果



### 唯一算法分类
哈希法 + 贪心匹配

### 题解思路与解决难点
**核心思路**：枚举 Bob 字符串的所有子串，贪心判断该子串是否为 Alice 字符串的子序列，使用哈希去重。  
**关键步骤**：
1. **枚举子串**：以每个字符为起点，向右扩展子串的右端点
2. **贪心匹配**：维护指针在 Alice 字符串中同步匹配当前子串的字符
3. **哈希去重**：将合法子串哈希后存入数组，排序去重统计数量

**解决难点**：
1. **高效去重**：通过哈希将字符串映射为数值，排序后相邻重复项可快速消除
2. **子序列匹配优化**：利用指针在 Alice 字符串中单次遍历即可处理同一左起点的所有右端点

### 题解评分（≥4星）
1. **syksykCCC（5★）**  
   - 思路清晰：用指针贪心匹配，哈希直接存储结果  
   - 代码简洁：仅 24 行，适合竞赛快速实现  
   - 复杂度合理：O(n² log n) 通过 3000 规模数据

2. **Karry5307（4★）**  
   - 双哈希防冲突：用 MOD1 和 MOD2 双哈希提升正确性  
   - 手写哈希表：避免 STL map 的常数过大

3. **KSToki（4★）**  
   - 预处理哈希数组：O(1) 获取子串哈希值  
   - 链式哈希表：空间优化避免 MLE

### 最优思路与技巧
**核心优化点**：
1. **贪心指针继承**：同一左起点，右端点扩展时继承上次匹配的指针位置
2. **滚动哈希**：使用 BASE=51971 和超大质数 MOD 减少碰撞概率
3. **即时哈希计算**：在扩展右端点时递推计算哈希值，避免重复计算

**代码片段**：
```cpp
// syksykCCC 的核心匹配逻辑
for(int i=1; i<=n; i++) {
    long long v = 0; int p = 1;
    for(int j=i; j<=n; j++) {
        while(p <= n && a[p] != b[j]) p++; // 贪心移动指针
        if(p > n) break;
        p++;
        v = (v * BASE + b[j] - 'a' + 1) % MOD; // 滚动哈希
        t[++t[0]] = v;
    }
}
sort(t + 1, t + t[0] + 1);
ans = unique(t + 1, t + t[0] + 1) - t - 1;
```

### 同类题目推荐
1. [P4112] 最短不公共子串（自动机综合应用）
2. [P3973] 子序列自动机（哈希优化）
3. [P3763] DNA（哈希 + 滑动窗口）

### 可视化算法演示
**动画设计**：
1. **分屏显示**：左侧 Alice 字符串，右侧 Bob 字符串
2. **指针追踪**：用红色标记 Bob 当前子串范围（i,j），蓝色标记 Alice 的匹配指针 p
3. **哈希生成**：在底部动态显示当前子串的哈希值计算过程
4. **去重演示**：右侧列表实时显示已存储的哈希值，重复项用灰色标记

**复古像素风格**：
- **网格布局**：字符显示为 16x16 像素块，指针用闪烁箭头表示
- **8-bit 音效**：匹配成功时播放上升音阶，哈希冲突时播放警示音
- **自动演示**：按空格切换手动/自动模式，自动模式时子串范围自动扩展

### 结论与扩展
**最优解法**：哈希法在代码简洁度和效率上达到最佳平衡，适合竞赛场景。对于更大规模数据（如 n=1e5），可改用后缀自动机 + 子序列自动机的 O(n) 方法。

**扩展思考**：当需要支持动态修改字符串时，可结合哈希树（Merkle Tree）实现快速更新哈希值，但会引入 O(log n) 的查询复杂度。

---
处理用时：61.04秒
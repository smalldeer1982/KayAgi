# 题目信息

# 齿轮

## 题目描述

Daniel13265 从不知哪里找来了 $n$ 个齿轮，第 $i$ 个齿轮的齿数为不超过 $m$ 的正整数 $a_i$。他现在想把其中 $k$ 个齿轮按照一定的方式拼接在一起。

当齿轮使用一段时间后，就会产生损耗。一个齿轮组的损耗速率是由这个齿轮组的所有齿轮齿数的最大公约数决定的：最大公约数越大，相同的齿之间啮合的频率就会增高，从而损耗的速率就会变快。这个最大公约数又被称为损耗因子。

算出一个齿轮组的损耗因子是很容易的。可是现在 Daniel13265 想要知道，对于可能拼接出的所有齿轮组的损耗因子。

Daniel13265 知道拼接出损耗因子大于 $m$ 的齿轮组是不可能的，而且由于可能拼出的齿轮组的个数很多，你只需要反过来告诉他对于所有的 $t\in[1, m]$，能够拼接出的损耗因子为 $t$ 的齿轮组的个数对 $10^9+7$ 取模后的结果即可。

## 说明/提示

### 样例解释

损耗因子为 $1$ 的齿轮组有 $(1,2),(1,3),(1,4),(1,6),(2,3),(3,4)$ 共 $6$ 个；  
损耗因子为 $2$ 的齿轮组有 $(2,4),(2,6),(4,6)$ 共 $3$ 个；  
损耗因子为 $3$ 的齿轮组有 $(3,6)$ 共 $1$ 个。

### 数据范围

**本题采用捆绑测试。你每通过一个子任务的所有数据点，就能得到该子任务的全部分数。**

| 子任务编号 | $n\le$ | $m\le$ | $k\le$ | 分值 |
|:-:|:-:|:-:|:-:|:-:|
| $1$ | $10$ | $10^6$ | $10$ | $10$ |
| $2$ | $10^3$ | $10^3$ | $10^3$ | $20$ |
| $3$ | $10^6$ | $10^3$ | $2$ | $5$ |
| $4$ | $10^6$ | $10^6$ | $1$ | $5$ |
| $5$ | $10^6$ | $10^6$ | $2$ | $20$ |
| $6$ | $10^6$ | $10^6$ | $10^6$ | $40$ |

对于 $100\%$ 的数据，满足 $1\le k\le n\le10^6$，$1\le a_i\le m\le10^6$。

## 样例 #1

### 输入

```
5 6 2
1 2 3 4 6
```

### 输出

```
6 3 1 0 0 0
```

# AI分析结果



**唯一算法分类**：容斥原理

---

### **题解思路与核心难点**

1. **核心思路**  
   - 问题转化为统计每个数 $t$ 作为最大公约数的方案数。直接计算困难，转而计算公约数为 $t$ 的倍数的方案数，再用容斥原理减去重复计数。

2. **关键步骤**  
   - **预处理统计**：统计每个数 $t$ 的倍数出现的次数。  
   - **组合数计算**：预处理阶乘与逆元，快速计算组合数 $\binom{cnt}{k}$，其中 $cnt$ 是 $t$ 的倍数的总数。  
   - **倒序容斥**：从大到小枚举 $t$，总方案数减去所有 $t$ 的倍数（如 $2t, 3t$）的方案数，得到精确的 $f(t)$。

3. **解决难点**  
   - **时间复杂度优化**：通过调和级数遍历倍数，时间复杂度降至 $O(m \log m)$。  
   - **组合数预处理**：利用模数 $10^9+7$ 预处理阶乘与逆元，$O(1)$ 查询组合数。

---

### **题解评分（≥4星）**

1. **StudyingFather（⭐⭐⭐⭐⭐）**  
   - **亮点**：代码简洁，预处理阶乘逆元高效，倒序容斥逻辑清晰。  
   - **关键代码**：
     ```cpp
     for(int i=m;i;i--) {
         int cnt=0;
         for(int j=i;j<=m;j+=i) cnt += t[j];
         g[i] = C(cnt, k);
         for(int j=2*i;j<=m;j+=i) g[i] = (g[i] - g[j] + MOD) % MOD;
     }
     ```

2. **Daniel13265（⭐⭐⭐⭐⭐）**  
   - **亮点**：官方题解详细分析子任务，容斥思路明确，数学推导完整。  
   - **心得引用**：“直接倒着枚举 $t$ 按照这个式子做即可通过此题”。

3. **ethan0328（⭐⭐⭐⭐）**  
   - **亮点**：代码结构清晰，变量命名易懂，组合数计算逻辑独立封装。  
   - **关键代码**：
     ```cpp
     for(int i=m;i;i--) {
         int x=0, y=0;
         for(int j=i;j<=m;j+=i) x += cnt[j], y += f[j];
         f[i] = (C(x, k) - y) % MOD;
     }
     ```

---

### **最优思路提炼**

1. **容斥倒序处理**  
   - **核心技巧**：倒序枚举 $t$，确保处理 $t$ 时，其倍数的贡献已被计算，可直接减去。  
   - **数学形式**：$f(t) = \binom{\text{cnt}(t)}{k} - \sum_{i>t, i \mid t} f(i)$。

2. **组合数预处理优化**  
   - 预处理阶乘 $fac$ 和逆元 $inv$，快速计算 $\binom{n}{k} = fac[n] \cdot inv[k] \cdot inv[n-k] \mod 10^9+7$。

3. **调和级数遍历**  
   - 统计倍数时，通过 $j = i, 2i, 3i, \dots$ 的循环，总复杂度为 $O(m \log m)$。

---

### **同类型题与算法套路**

1. **类似问题**  
   - 统计区间内互质的数对个数（[洛谷 P2158](https://www.luogu.com.cn/problem/P2158)）。  
   - 求数组子序列的按位与和（[LeetCode 982](https://leetcode.com/problems/sum-of-subsequence-widths/)）。

2. **通用解法**  
   - **容斥与倍数遍历**：处理涉及公约数、公倍数的问题时，优先考虑调和级数遍历和容斥原理。

---

### **推荐相似题目**

1. [P2158 [SDOI2008] 仪仗队](https://www.luogu.com.cn/problem/P2158)  
   **标签**：欧拉函数、容斥原理。

2. [P2260 [清华集训2012] 模积和](https://www.luogu.com.cn/problem/P2260)  
   **标签**：数论分块、容斥。

3. [P3312 [SDOI2014] 数表](https://www.luogu.com.cn/problem/P3312)  
   **标签**：莫比乌斯反演、前缀和。

---

### **可视化与算法演示**

**动画设计**：  
1. **像素风格界面**：  
   - **颜色方案**：使用 8-bit 调色板，红色表示当前处理的 $t$，蓝色表示其倍数。  
   - **网格绘制**：在 Canvas 中以网格展示 $1$ 到 $m$ 的数，高亮当前 $t$ 及其倍数。

2. **关键步骤演示**：  
   - **步骤1**：显示统计 $t=3$ 的倍数（如 3, 6），计算 $cnt=2$，组合数 $\binom{2}{2}=1$。  
   - **步骤2**：减去 $t=6$ 的贡献（已计算为 $0$），最终 $f(3)=1$。  
   - **音效触发**：组合数计算成功时播放“叮”，减法操作时播放“咔嚓”。

3. **AI自动演示**：  
   - **自动模式**：按 $t$ 从 $m$ 到 $1$ 的顺序逐步处理，每步暂停 1 秒，展示当前 $t$ 的数据变化。  
   - **交互控制**：提供暂停/继续按钮，支持拖动进度条观察特定 $t$。

---

**代码片段（核心逻辑）**  
```javascript
// 伪代码：动画核心逻辑
function visualize() {
    let t = m;
    const interval = setInterval(() => {
        if (t < 1) clearInterval(interval);
        highlightCurrentT(t); // 高亮当前t
        let cnt = countMultiples(t); // 显示倍数统计
        let comb = calculateComb(cnt, k); // 显示组合数计算
        subtractMultiples(t); // 显示减去2t,3t...
        updateResult(t, comb); // 更新结果数组
        t--;
    }, 1000);
}
```

---

**复古游戏化实现**  
- **像素绘制**：使用 `Canvas` 绘制 16x16 像素块，每个块表示一个数 $t$，背景色表示其状态（未处理/已处理）。  
- **音效设计**：  
  - **统计倍数**：8-bit 计数音效（类似《超级马里奥》金币声）。  
  - **容斥完成**：胜利音效（类似《塞尔达传说》解谜成功）。  
- **积分系统**：每正确计算一个 $t$ 得 10 分，连击（连续正确）额外加分。

---
处理用时：106.85秒
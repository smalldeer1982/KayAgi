# 题目信息

# [BCSP-X 2024 12 月小学高年级组] 操作序列

## 题目描述

有 $n$ 个变量 $x[1 \sim n]$，初始值都为 0。

依次给出 $m$ 个操作的信息，操作分为 2 种：

- $(1, id, v)$: 代表将 $x[id]$ 的值加上 $v$；
- $2$: 代表将所有变量的值乘 $2$；

所有运算在 $(\bmod \ 10^4)$ 下执行，提示：模意义下的加减乘运算

- 加：`c = (a + b) % mod`；
- 减：`c = (a - b + mod) % mod`；
- 乘：`c = a * b % mod`；

现在给出一个操作序列，请问依次执行序列中的所有操作之后，每个变量的值是多少。

具体的，操作序列以 $q$ 个区间 $[l[i], r[i]]$ 的形式给出，依次执行每个区间、每个区间按编号从小->大执行区间内的操作，即完整的操作序列为：

- $l[1] \sim r[1], l[2] \sim r[2], l[3] \sim r[3], \ldots, l[q] \sim r[q]$

## 说明/提示

### 样例 3-8

见附件。

### 数据范围

对于所有数据，$1 \leq n, m, q \leq 2 \times 10^5, op = \{1, 2\}, 1 \leq id \leq n, 1 \leq v \leq 10^9$，假设 $m$ 种操作中第 1、2 种操作的总数为 $m_1, m_2$，满足 $m_1 + m_2 = m$。

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | 数据范围 | 特殊性质 | 子任务依赖 |
|:------------:|:------:|:----------:|:----------:|:------------:|
| 1          | 15   | $n, m, q \leq 500$ |          |            |
| 2          | 19   | $n, m, q \leq 5000$ |          | 1          |
| 3          | 11   | $n, m, q \leq 2 \times 10^5$ | $m_2 = 0$ |            |
| 4          | 17   | $n, m, q \leq 2 \times 10^5$ | $m_1 = 1, m_2 = m - 1$ |            |
| 5          | 17   | $n, m, q \leq 2 \times 10^5$ | $m_1 = m - 1, m_2 = 1$ |            |
| 6          | 21   | $n, m, q \leq 2 \times 10^5$ |          | 1,2,3,4,5          |

## 样例 #1

### 输入

```
5 5 5
2
1 1 3
2
2
1 3 3
2 5
1 2
1 1
2 2
3 4```

### 输出

```
228 0 48 0 0```

## 样例 #2

### 输入

```
10 10 10
1 4 1
1 7 3
1 4 5
1 1 3
2
1 5 5
2
2
1 8 2
1 7 1
1 8
1 1
7 8
1 4
8 9
3 9
2 10
4 7
3 6
6 9```

### 输出

```
2536 0 0 8952 3560 0 6304 4674 0 0```

# AI分析结果



---

### **算法分类**
无算法分类

---

### **题解思路与核心难点**
**题目核心**：处理大规模操作序列，高效计算每个变量最终值。  
**关键难点**：乘2操作影响后续所有加法，直接模拟超时。  
**解决思路**：  
1. **数学建模**：每个加法操作的贡献为 `v * 2^k`，其中 `k` 是该操作之后所有乘2操作的次数。  
2. **预处理后缀乘2次数**：记录每个原操作后的乘2次数。  
3. **区间贡献拆分**：将每个区间的贡献拆分为内部乘2次数和后续所有区间的乘2次数之和。  
4. **前缀和优化**：利用前缀和数组批量计算所有区间对每个原操作的贡献。

---

### **最优思路提炼**
1. **逆序预处理**：计算每个原操作的后缀乘2次数。  
2. **区间总乘2次数**：预处理每个区间的乘2次数及其后缀和。  
3. **差分数组与前缀和**：批量统计所有区间对原操作的影响，避免逐个操作处理。  
4. **快速幂优化**：动态计算 `2^k` 的模值，减少重复计算。

---

### **代码实现**
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int MOD = 1e4;
const int MAXM = 2e5 + 5;

struct Op {
    int type, id, v;
} op[MAXM];

int suffix_original[MAXM];
int sum_interval[MAXM], suffix_interval[MAXM];
int add[MAXM], sum_2delta[MAXM];
int n, m, q;

ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    scanf("%d%d%d", &n, &m, &q);
    for (int i = 1; i <= m; i++) {
        int t, id, v;
        scanf("%d", &t);
        if (t == 1) {
            scanf("%d%d", &id, &v);
            op[i] = {1, id, v % MOD};
        } else {
            op[i] = {2, 0, 0};
        }
    }

    // 预处理 suffix_original
    suffix_original[m + 1] = 0;
    for (int i = m; i >= 1; i--) {
        suffix_original[i] = suffix_original[i + 1] + (op[i].type == 2);
    }

    vector<pair<int, int>> ranges(q + 1);
    for (int i = 1; i <= q; i++) {
        scanf("%d%d", &ranges[i].first, &ranges[i].second);
    }

    // 预处理 sum_interval 和 suffix_interval
    for (int i = 1; i <= q; i++) {
        int l = ranges[i].first, r = ranges[i].second;
        sum_interval[i] = suffix_original[l] - suffix_original[r + 1];
    }

    suffix_interval[q + 1] = 0;
    for (int i = q; i >= 1; i--) {
        suffix_interval[i] = sum_interval[i] + suffix_interval[i + 1];
    }

    // 处理 add 数组
    for (int i = 1; i <= q; i++) {
        int l = ranges[i].first, r = ranges[i].second;
        int delta = suffix_interval[i + 1] - suffix_original[r + 1];
        ll pow2_delta = qpow(2, delta);
        add[l] = (add[l] + pow2_delta) % MOD;
        add[r + 1] = (add[r + 1] - pow2_delta + MOD) % MOD;
    }

    // 计算 sum_2delta
    for (int j = 1; j <= m; j++) {
        sum_2delta[j] = (sum_2delta[j - 1] + add[j]) % MOD;
    }

    vector<int> x(n + 1, 0);
    for (int j = 1; j <= m; j++) {
        if (op[j].type == 1) {
            int id = op[j].id, v = op[j].v;
            int exponent = suffix_original[j];
            ll pow2_exp = qpow(2, exponent);
            ll total = (ll)v * pow2_exp % MOD * sum_2delta[j] % MOD;
            x[id] = (x[id] + total) % MOD;
        }
    }

    for (int i = 1; i <= n; i++) {
        printf("%d%c", x[i] % MOD, " \n"[i == n]);
    }
    return 0;
}
```

---

### **可视化设计**
**核心逻辑动画演示**：  
1. **动态乘数**：显示每个加法操作后的乘数变化。  
2. **区间高亮**：用不同颜色标记当前处理的区间。  
3. **后缀贡献**：以进度条形式展示后缀乘2次数的累积。  
**复古像素风格**：  
- **颜色方案**：绿色（加法）、红色（乘2）、黄色（当前乘数）。  
- **音效**：加法操作时播放“滴”声，乘2操作时播放“叮”声。  
- **自动演示**：按区间顺序自动播放，用户可暂停/调整速度。

---

### **相似题目推荐**
1. **洛谷 P3372**：线段树区间修改与查询。  
2. **洛谷 P1908**：逆序对（分治与预处理思想）。  
3. **洛谷 P1090**：优先队列处理动态操作。

---
处理用时：424.42秒
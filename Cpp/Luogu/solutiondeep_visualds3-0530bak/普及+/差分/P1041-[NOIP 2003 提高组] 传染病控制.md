# 题目信息

# [NOIP 2003 提高组] 传染病控制

## 题目背景

本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

---

近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。


## 题目描述

研究表明，这种传染病的传播具有两种很特殊的性质；

第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。


第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。


这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。


你的程序要针对给定的树，找出合适的切断顺序。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 300$。

**【题目来源】**

NOIP 2003 提高组第四题

## 样例 #1

### 输入

```
7 6
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
```

# AI分析结果



### 【算法分类】  
**树形DFS**

---

### 【题解思路与算法要点】  
#### **核心思路**  
题目要求最小化感染人数，等价于最大化未感染人数。由于每次只能切断一层到下一层的传播路径，所有解法均围绕**按层枚举切断点**展开，关键步骤包括：  
1. **预处理**：构建树结构，计算每个节点的深度（层数）、子树大小。  
2. **分层搜索**：从第二层开始，枚举每层切断的节点，递归至下一层。  
3. **状态管理**：切断某节点时标记其子树为安全，回溯时恢复状态。  

#### **解决难点**  
- **分层处理**：需将节点按深度分组，确保每层仅切断一条边。  
- **子树标记**：高效标记子树节点（如递归清理或预存子树节点列表）。  
- **剪枝优化**：若当前感染人数已超过已知最优解，直接回溯。  

---

### 【题解评分】  
1. **RikoHere（4.5星）**  
   - **亮点**：模块化函数（标记/清理子树），优先队列预处理深度，代码可读性强。  
   - **代码片段**：  
     ```cpp  
     void dfs(int cen, int tot) {  
         maxx = max(maxx, tot);  
         for (节点 in 当前层) {  
             if (未被切断) {  
                 int num = clean(节点); // 标记子树  
                 dfs(cen+1, tot + num);  
                 reclean(节点); // 回溯  
             }  
         }  
     }  
     ```  

2. **基础不牢（4星）**  
   - **亮点**：结构体存储父子关系，显式处理父节点状态，适合初学者理解。  
   - **关键逻辑**：  
     ```cpp  
     if (父节点被切断) 当前节点自动安全;  
     else 枚举切断点并递归。  
     ```  

3. **欧鹰（4星）**  
   - **亮点**：简洁的标记/回溯函数，预处理子树大小，高效剪枝。  
   - **代码片段**：  
     ```cpp  
     void dfs(int dep, int cnt) {  
         ans = min(ans, cnt);  
         for (节点 in 当前层) {  
             if (未被切断) {  
                 work(节点, 1); // 标记子树  
                 dfs(dep+1, cnt - size[节点]);  
                 work(节点, 0); // 回溯  
             }  
         }  
     }  
     ```  

---

### 【最优思路提炼】  
1. **分层枚举**：按树的深度分层处理，每层只切断一个节点。  
2. **子树预处理**：预计算每个节点的子树大小，避免重复遍历。  
3. **状态回溯**：递归时标记子树，回溯时恢复，确保搜索空间完整。  
4. **剪枝策略**：若当前感染人数已不优于最优解，立即停止搜索。  

---

### 【同类型题与套路】  
- **树形结构处理**：类似题目需分层或子树遍历（如P1352 没有上司的舞会）。  
- **状态回溯**：常见于DFS问题，如八皇后、组合数枚举。  

---

### 【推荐题目】  
1. **P1352** - 树形DP（子树状态传递）。  
2. **P2014** - 树形依赖背包（子树选择策略）。  
3. **P1273** - 有线电视网（树形DP与资源分配）。  

---

### 【可视化设计】  
**动画方案**：  
1. **树形结构展示**：Canvas绘制树，按深度分层排列节点，不同颜色区分层。  
2. **操作高亮**：切断某节点时，其子树变为绿色，感染节点保持红色。  
3. **步进控制**：用户点击“下一步”时，展示当前层枚举的切断点及感染人数变化。  
4. **复古像素风格**：  
   - **颜色方案**：8位色（红-感染，绿-安全，蓝-当前操作节点）。  
   - **音效**：切断时播放“哔”声，回溯时“滴”声，找到最优解时播放胜利音效。  
   - **自动演示**：AI按层选择切断点，动态显示最优解搜索过程。  

**交互示例**：  
```javascript  
// 伪代码：Canvas绘制树与操作  
function drawTree() {  
    ctx.fillStyle = '#FF0000'; // 红色表示感染  
    nodes.forEach(node => {  
        if (node.safe) ctx.fillStyle = '#00FF00'; // 绿色表示安全  
        drawCircle(node.x, node.y);  
    });  
}  
```  

---

### **个人心得**  
- **调试教训**：切断节点时需确保其父节点未被切断，否则子树无需处理。  
- **优化顿悟**：预处理子树大小可避免每次递归重复计算，显著提升效率。  

--- 

**核心代码实现**（欧鹰题解片段）：  
```cpp  
void dfs(int dep, int infected) {  
    if (infected >= ans) return; // 剪枝  
    if (dep == max_depth) {  
        ans = infected;  
        return;  
    }  
    for (auto node : layers[dep]) {  
        if (is_safe(node)) continue;  
        mark_subtree(node); // 标记子树为安全  
        dfs(dep + 1, infected - size[node]);  
        unmark_subtree(node); // 回溯  
    }  
}  
```  

此代码通过分层遍历和子树标记，高效实现了最小感染人数的搜索。

---
处理用时：75.78秒
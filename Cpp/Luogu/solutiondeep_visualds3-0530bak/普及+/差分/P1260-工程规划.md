# 题目信息

# 工程规划

## 题目描述

造一幢大楼是一项艰巨的工程，它是由 $n$ 个子任务构成的，给它们分别编号 $1,2,\cdots,n\ (5≤n≤1000)$。由于对一些任务的起始条件有着严格的限制，所以每个任务的起始时间 $T_1,T_2,\cdots,T_n$ 并不是很容易确定的(但这些起始时间都是非负整数，因为它们必须在整个工程开始后启动)。例如：挖掘完成后，紧接着就要打地基；但是混凝土浇筑完成后，却要等待一段时间再去掉模板。

这种要求就可以用 $m\ (5≤m≤5000)$ 个不等式表示，不等式形如 $T_i-T_j≤b$ 代表 $i$ 和 $j$ 的起始时间必须满足的条件。每个不等式的右边都是一个常数 $b$，这些常数可能不相同，但是它们都在区间 $(-100,100)$ 内。

你的任务就是写一个程序，给定像上面那样的不等式，找出一种可能的起始时间序列 $T_1,T_2,\cdots,T_n$，或者判断问题无解。对于有解的情况，要使最早进行的那个任务和整个工程的起始时间相同，也就是说，$T_1,T_2,\cdots,T_n$ 中至少有一个为 $0$。


## 说明/提示

由@zhouyonglong提供SPJ


## 样例 #1

### 输入

```
5 8
1 2 0
1 5 -1
2 5 1
3 1 5
4 1 4
4 3 -1
5 3 -1
5 4 -3```

### 输出

```
0
2
5
4
1
```

## 样例 #2

### 输入

```
5 5
1 2 -3
1 5 -1
2 5 -1
5 1 -5
4 1 4```

### 输出

```
NO SOLUTION
```

# AI分析结果



### 算法分类  
**差分约束系统**

---

### 题解思路与核心难点  
#### 核心算法流程  
1. **不等式转边权**：将每个约束 $T_i - T_j \leq b$ 转化为从节点 $j$ 到 $i$ 的有向边，边权为 $b$  
2. **超级源点**：建立虚拟节点 $n+1$，向所有真实节点连边权为 0 的边，确保图连通  
3. **SPFA 判负环**：通过入队次数判断负环（节点入队次数 > n 次则无解）  
4. **调整解**：将每个节点的最短路径值减去最小值，确保至少一个 $T_i=0$  

#### 解决难点  
- **负环检测**：需在 SPFA 中动态统计节点入队次数，若存在负环则无解  
- **非负解调整**：通过全局最小值平移所有值，保证解的非负性和至少一个零点  

#### 可视化设计要点  
- **动态松弛展示**：以网格或节点图展示 SPFA 的松弛过程，用颜色区分已松弛/未松弛的边  
- **负环高亮**：检测到负环时，用红色闪烁标记环中的节点和边  
- **像素风格**：使用 8-bit 风格显示节点，队列操作用音效（如“入队”声）增强交互感  
- **自动演示**：模拟贪吃蛇 AI 路径探索，逐步展开最短路径更新过程  

---

### 题解评分与亮点（≥4星）  
1. **L_M_（5星）**  
   - 亮点：详细数学推导 + 完整代码注释，明确解释边权转换逻辑  
   - 代码：使用 `popst` 数组统计入队次数，逻辑清晰  

2. **SDqwq（4星）**  
   - 亮点：强调解调整的关键步骤（减最小值），代码简洁  
   - 代码：通过 `minm = min(minm, dis[i])` 快速计算偏移量  

3. **一只书虫仔（4星）**  
   - 亮点：用 `vis` 数组优化队列操作，避免重复入队  
   - 代码：通过 `AddEdge(n+1, i, 0)` 处理超级源点  

---

### 最优思路提炼  
1. **边权转换公式**：  
   - 对 $T_i - T_j \leq b$，建边 `j -> i`，权值为 `b`  
   - 核心代码：`addedge(j, i, b)`  

2. **超级源点技巧**：  
   - 虚拟节点连接所有真实节点，确保全图连通  
   - 代码示例：`for (i=1 to n) add_edge(n+1, i, 0)`  

3. **解平移法**：  
   - 计算所有 `dis[i]` 的最小值 `min_val`，最终解为 `dis[i] - min_val`  

---

### 类似题目推荐  
1. **P3385（模板负环）** - 检测负环的基础练习  
2. **P1993（小K的农场）** - 差分约束变形（包含等式约束）  
3. **P3275（糖果）** - 复杂约束下的最大值求解  

---

### 关键代码片段  
```cpp
// SPFA 核心逻辑（L_M_ 题解）
void spfa(int s) {
    queue<int> q;
    memset(dis, 0x3f, sizeof(dis));
    dis[s] = 0;
    q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = fir[u]; i; i = e[i].next) {
            int v = e[i].to, w = e[i].cost;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                if (++popst[v] > n) { // 入队次数检测
                    cout << "NO SOLUTION";
                    return;
                }
                q.push(v);
            }
        }
    }
    // 调整解为非负
    int minm = *min_element(dis+1, dis+n+1);
    for (int i=1; i<=n; i++) 
        cout << dis[i] - minm << endl;
}
```

---

### 可视化设计（伪代码）  
```javascript
// Canvas 绘制节点（8-bit 风格）
function drawNode(node, distance) {
    ctx.fillStyle = node === current ? "#FF0000" : "#00FF00";
    ctx.fillRect(x, y, 32, 32); // 32x32 像素块
    ctx.fillText(`T${node}: ${distance}`, x+5, y+20);
}

// SPFA 动画帧
function animateSPFA() {
    let u = queue.dequeue();
    highlight(u); // 红色高亮当前节点
    for (let edge of u.edges) {
        if (relax(edge)) { // 松弛成功
            playSound("edge_relax");
            if (edge.to.inQueueCount++ > n) {
                playSound("negative_cycle");
                showError("NO SOLUTION");
            }
        }
    }
}
```

---

### 总结  
本题通过差分约束系统建模为最短路问题，结合 SPFA 和负环检测实现高效求解。关键点在于边权转换、超级源点处理和解的非负性调整。可视化方案通过动态松弛和复古像素风格增强理解，适合教学演示。

---
处理用时：68.15秒
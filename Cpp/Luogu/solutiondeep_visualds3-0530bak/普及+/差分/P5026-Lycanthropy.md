# 题目信息

# Lycanthropy

## 题目背景

小正方形亲眼看见了自己昔日的朋友被卷进了黑暗的深渊，然而它无力阻止……

现在它的朋友已经向它发起了攻击，因此小正方形不得不抵抗。

## 题目描述

我们把山顶上的湖泊看作一条长度为 $m$ 的直线，一开始水深都在水平线上，我们视作此时的水深为 '0'

接下来，在一瞬间，小正方形的"朋友"们跳起并扎入水中，导致在入水点的水降低而远离入水点的水升高，注意两个 "朋友" 可能在同一地点入水。

小正方形的每个朋友有一个体积数值 $v$，当体积为 $v$ 的一个朋友跳入水中，我们设入水点为 $i$，将会导致 $i - v + 1$ 到 $i$ 的水位依次降低 $1,2,\cdots,v$

同样地，第 $i$ 到 $i + v - 1$ 的水位会依次降低 $v,v - 1,\cdots,1$.

相对应地，$i - v$ 的水位不变， $i - v - 1$ 到 $i - 2 * v$ 水位依次增加 $1,2,\cdots,v$， $i - 2 * v$ 到 $i - 3 * v + 1$ 水位依次增加 $v,v - 1,\cdots,1$

同样，$i + v$ 水位不变，$i + v + 1$ 到 $i + 2 * v$ 水位增加 $1,2,\cdots,v$，$i + 2 * v$ 到 $i + 3 * v - 1$ 水位依次增加 $v,v - 1,\cdots,1$

现在小正方形想要穿过这个湖，他想要知道在这 $n$ 个"朋友"跳入水中后湖上每个节点的水位，你能帮帮它吗？

## 说明/提示

对于 $30\%$ 的数据，$n <= 50,m <= 500$

对于 $70\%$ 的数据，$n <= 10^5,m <= 10^5$

对于 $100\%$ 的数据，$n <= 10^6,m <= 10^6,1 <= v <= 10000,1 <= x <= m$

## 样例 #1

### 输入

```
1 10
1 5```

### 输出

```
0 0 1 0 -1 0 1 0 0 0 ```

## 样例 #2

### 输入

```
2 10
2 6
3 1```

### 输出

```
-2 0 0 0 0 0 2 2 2 2```

# AI分析结果



# Lycanthropy 题解分析

## 算法分类
**差分套差分**

---

## 题解思路与核心难点

### 核心逻辑推导
1. **分段线性变化**：每个朋友的入水会引发四段水位变化（左升、左降、右升、右降），每段的变化率为 ±1。
2. **二阶差分**：通过观察斜率变化的转折点，在五个关键位置（x-3v+1, x-2v+1, x+1, x+2v+1, x+3v+1）进行差分标记：
   ```cpp
   a[x-3v+1] += 1    // 左升段开始
   a[x-2v+1] -= 2    // 左降段开始（斜率变化-2）
   a[x+1] += 2       // 右升段开始（斜率变化+2）
   a[x+2v+1] -= 2    // 右降段开始
   a[x+3v+1] += 1    // 所有影响结束
   ```
3. **两次前缀和**：
   - 第一次前缀和得到每个点的斜率变化量。
   - 第二次前缀和累加得到最终水位值。

### 解决难点
- **负数下标处理**：通过指针偏移（如 `int *a = aa+1000000`）解决数组越界问题。
- **时间复杂度优化**：将 O(nv) 暴力模拟优化为 O(n) 差分操作。

---

## 题解评分（≥4星）

1. **WAMonster（★★★★★）**  
   - **亮点**：代码简洁，二阶差分标记清晰，指针偏移处理负数下标巧妙。  
   - **代码片段**：
     ```cpp
     a[x-3*v+1]++;
     a[x-2*v+1]-=2;
     a[x+1]+=2;
     a[x+2*v+1]-=2;
     a[x+3*v+1]++;
     ```

2. **Durancer（★★★★☆）**  
   - **亮点**：图解分段变化，详细解释斜率变化的数学推导。  
   - **心得摘录**："将每个点的贡献分解为斜率变化，是理解二阶差分的钥匙。"

3. **zmza（★★★★☆）**  
   - **亮点**：公式推导与代码对应明确，适合数学思维强的读者。  
   - **核心公式**：
     ```text
     Δr[x-3v+1] +=1; Δr[x-2v+1] -=2; ...
     ```

---

## 最优思路提炼
1. **二阶差分标记法**：在五个关键转折点记录差分值，通过两次前缀和快速计算全局水位。
2. **指针偏移技巧**：用 `int *a = aa + 1e6` 处理负数下标，避免数组越界。
3. **时间复杂度优化**：将每个朋友的操作压缩为 O(1) 的差分标记。

---

## 类似题目推荐
1. **P2184 贪婪大陆**（区间覆盖统计，差分应用）
2. **P2280 激光炸弹**（二维前缀和优化）
3. **P3406 海底高铁**（差分统计区间访问次数）

---

## 可视化设计
### 动画方案（像素风格）
1. **网格绘制**：将湖泊抽象为横向网格，每个点用像素方块表示水位高度（红色为负，蓝色为正）。
2. **关键点高亮**：在朋友入水时，用闪烁效果标记五个转折点。
3. **动态曲线**：实时绘制水位变化曲线，展示两次前缀和后的结果。
4. **音效设计**：
   - **标记转折点**：8-bit "哔"声。
   - **完成前缀和**：流水声渐变。

### 交互控制
- **步进控制**：按空格键单步执行差分标记或前缀和。
- **速度调节**：滑动条控制动画速度（0.5x~5x）。

---

## 核心代码实现
```cpp
#include <cstdio>
const int N = 2e6 + 10;
int aa[N], bb[N];

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    int *a = aa + 1e6; // 处理负数下标
    for (int i=1; i<=n; i++) {
        int v, x;
        scanf("%d%d", &v, &x);
        a[x-3*v+1]++;
        a[x-2*v+1] -= 2;
        a[x+1] += 2;
        a[x+2*v+1] -= 2;
        a[x+3*v+1]++;
    }
    // 两次前缀和计算
    for (int i=-4e4; i<=m+4e4; i++) 
        a[i] += a[i-1], bb[i] += bb[i-1] + a[i];
    // 输出结果
    for (int i=1; i<=m; i++) 
        printf("%d ", bb[i]);
    return 0;
}
```

---
处理用时：70.56秒
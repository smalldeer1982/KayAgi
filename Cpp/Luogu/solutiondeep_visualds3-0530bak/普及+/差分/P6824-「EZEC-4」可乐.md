# 题目信息

# 「EZEC-4」可乐

## 题目背景

很久以前，有一个 pigstd，非常迷恋美味的可乐。为了得到美味的可乐，他几乎用尽了所有的钱，他甚至对自己的 npy 也漠不关心~~其实是因为他没有npy~~，更不爱好看戏。除非买了新可乐，才会坐上马车出门炫耀一番。每一天，每个钟头他都要喝上一瓶新可乐。

pigstd 最近又买了许多箱新可乐——当然，这些可乐只有聪明的人才能喝到。

## 题目描述

pigstd 现在有 $n$ 箱可乐，第 $i$ 箱可乐上标着一个正整数 $a_{i}$。

若 pigstd 的聪明值为一个非负整数 $x$，对于第 $i$ 箱可乐，如果 $(a_{i} \oplus x )\le k$，那么 pigstd 就能喝到这箱可乐。

现在 pigstd 告诉了你 $k$ 与序列 $a$，你可以决定 pigstd 的聪明值 $x$，使得他能喝到的可乐的箱数最大。求出这个最大值。

## 说明/提示

### 提示

**pigstd 的聪明值 $x$ 可以为 $0$。**

### 样例解释

样例 1 解释：容易构造当 $x = 0$ 时，可以喝到所有可乐。

样例 2 解释：容易构造 $x = 913$，可以喝到所有可乐。

**样例解释未必是唯一的方法。**

### 数据范围

**本题采用捆绑测试。**

- Subtask 1（29 points）：$1 \le n,k,a_{i} \le 1000$。

- Subtask 2（1 points）：$a_{i} \le k$。

- Subtask 3（70 points）：无特殊限制。

对于所有数据，保证 $1 \le n,k,a_{i} \le 10^6$。

$\oplus$ 代表异或，如果您不知道什么是异或，请单击[这里](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677?fr=aladdin)。

## 样例 #1

### 输入

```
3 5
2
3
4```

### 输出

```
3```

## 样例 #2

### 输入

```
4 625
879
480
671
853
```

### 输出

```
4```

# AI分析结果



**唯一算法分类**：位运算与差分数组

---

### **题解思路、算法要点与解决难点**  
**核心思路**：  
对于每个a_i，确定其对应的合法x的区间，利用差分数组统计这些区间的覆盖次数，最终求最大覆盖次数。  
**关键步骤**：  
1. **逐位分析**：从最高位到最低位处理，根据k的当前位决定x的取值策略。  
2. **区间生成**：当k的某位为1时，x可取两种路径：固定当前位生成一个区间，或继续处理下一位。  
3. **差分统计**：通过差分数组高效记录区间覆盖，最后前缀和求最大值。  

**解决难点**：  
- 如何将每个a_i对应的x的合法区间高效表达？  
  **解决方案**：通过二进制位逐层分解，生成连续区间并差分标记。  
- 如何处理动态变化的位条件？  
  **解决方案**：递归式位处理，维护当前前缀值，生成不同条件下的区间。  

---

### **题解评分 (≥4星)**  
1. **pigstd (5星)**  
   - **亮点**：差分数组高效处理区间覆盖，代码简洁，时间复杂度O(n logk)。  
   - **核心代码**：  
     ```cpp  
     void f(int b) {  
         // 二进制分解生成区间，差分更新c数组  
     }  
     ```  
2. **pocafup (4星)**  
   - **亮点**：代码简洁，直接按位生成区间，差分统计。  
   - **核心代码**：  
     ```cpp  
     inline void solve(int num) {  
         // 按位生成区间并差分  
     }  
     ```  
3. **SerokSSR (4星)**  
   - **亮点**：逻辑清晰，逐位分类讨论生成区间，注释详细。  
   - **核心代码**：  
     ```cpp  
     for (int j=20; j>=0; --j) {  
         // 根据k的位生成区间  
     }  
     ```  

---

### **最优思路或技巧提炼**  
1. **位分层区间生成**：从高位到低位逐层分解，利用k的位决定x的取值策略，生成合法区间。  
2. **差分数组优化**：将区间加减操作转化为差分数组的前缀和，避免暴力枚举x。  
3. **二进制前缀维护**：通过维护当前前缀值，动态生成后续区间。  

---

### **同类型题或类似算法套路**  
- **区间覆盖问题**：如统计多个区间重叠部分的最大值。  
- **位运算优化**：通过二进制分解将问题转化为位操作，例如最大异或对、子集异或和等。  

---

### **推荐相似题目**  
1. [P3857 [TJOI2008] 彩灯](https://www.luogu.com.cn/problem/P3857)  
2. [P4735 最大异或和](https://www.luogu.com.cn/problem/P4735)  
3. [P2114 [NOI2014] 起床困难综合症](https://www.luogu.com.cn/problem/P2114)  

---

### **可视化与算法演示**  
**动画设计**：  
1. **位处理过程**：用二进制树状图展示每一位的两种选择（固定或继续），高亮当前处理的位。  
2. **区间生成**：在数轴上动态绘制每个a_i生成的区间，颜色区分不同a_i的贡献。  
3. **差分更新**：显示差分数组的更新过程，前缀和累加时用颜色渐变表示覆盖次数变化。  

**复古像素风格**：  
- **颜色方案**：使用8位色（红、绿、蓝、黄）表示不同位和区间。  
- **音效**：每次位切换时播放“哔”声，区间生成时播放“叮”声。  
- **自动演示**：按位自动处理，用户可暂停/调整速度。  

---

### **代码实现核心逻辑**  
**关键代码（差分区间生成）**：  
```cpp  
void f(int b) {  
    int sum = 0;  
    for (int i = 20; i >= 0; i--) {  
        int k_bit = (k >> i) & 1;  
        int a_bit = (b >> i) & 1;  
        if (k_bit) {  
            // 生成区间 [sum, sum + 2^i) 和继续处理  
            c[sum]++;  
            c[sum + (1 << i)]--;  
            sum += (a_bit ^ 1) << i;  // 继续处理下一位  
        } else {  
            sum += a_bit << i;  // 必须匹配当前位  
        }  
    }  
    c[sum]++; c[sum + 1]--;  // 处理完所有位后的区间  
}  
```  

**完整代码参考**：  
（见用户题解中 `pigstd` 或 `SerokSSR` 的代码）  

---

**可视化示例（伪代码）**：  
```javascript  
// Canvas绘制区间  
function drawInterval(start, end, color) {  
    ctx.fillStyle = color;  
    ctx.fillRect(start * scaleX, 0, (end - start) * scaleX, canvas.height);  
}  
// 位处理动画  
function animateBitProcessing(bit) {  
    highlightBit(bit);  // 高亮当前位  
    playSound('beep');  // 播放音效  
}  
```

---
处理用时：75.97秒
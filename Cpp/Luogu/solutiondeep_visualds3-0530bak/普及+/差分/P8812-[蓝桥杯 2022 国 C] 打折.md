# 题目信息

# [蓝桥杯 2022 国 C] 打折

## 题目描述

小蓝打算采购 $n$ 种物品，每种物品各需要 $1$ 个。

小蓝所住的位置附近一共有 $m$ 个店铺，每个店铺都出售着各种各样的物品。

第 $i$ 家店铺会在第 $s_i$ 天至第 $t_i$ 天打折，折扣率为 $p_i$，对于原件为 $b$ 的物品，折后价格为 $\lfloor\frac {b\cdot p_j}{100}\rfloor$。其它时间需按原价购买。

小蓝很忙，他只能选择一天的时间去采购这些物品。请问，他最少需要花多少钱才能买到需要的所有物品。

题目保证小蓝一定能买到需要的所有物品。

## 说明/提示

对于 $40\%$ 的评测用例，$n,m≤500，s_i ≤t_i ≤100，\sum c_i ≤2000$；

对于 $70\%$ 的评测用例，$n,m≤5000，\sum c_i ≤20000$；

对于所有评测用例，$1 ≤ n,m ≤ 10^5，1 ≤ c_i ≤ n，\sum c_i ≤ 4\times10^5，1 ≤ s_i ≤t_i ≤10^9，1 < p_i < 100，1≤a_j ≤n，1≤b_j ≤10^9$。

蓝桥杯 2022 国赛 C 组 I 题。

## 样例 #1

### 输入

```
2 2
1 2 89 1
1 97
3 4 77 1
2 15```

### 输出

```
101```

# AI分析结果



---

### **唯一算法分类**  
**离散化与事件驱动的离线处理**

---

### **题解思路与核心难点**  

#### **问题核心**  
小蓝需选择一天购买所有物品，总花费最低。每个店铺在特定时间段打折，影响物品价格。需快速确定所有可能时间点中的最小总花费。

#### **题解对比**  
1. **tmp_get_zip_diff 的解法**  
   - **离散化时间**：将所有店铺的开始时间 `s_i` 和结束时间 `t_i + 1` 离散化为关键时间点。  
   - **事件驱动**：将每个时间点的事件分为两类：开始打折（插入折扣价）、结束打折（移除折扣价）。  
   - **动态维护最小值**：使用 `multiset` 存储每个物品的所有可能价格，快速获取最小值。  
   - **总花费计算**：初始计算非打折时的总价，依次处理离散化后的时间点事件，更新对应物品的最小价格并计算总花费的增量变化。  

2. **Sweet_2013 的解法**  
   - **贪心策略**：认为最优时间必为某个打折事件的开始时间点。  
   - **平衡树维护价格集合**：每个物品的价格集合用平衡树管理，总花费通过树状数组维护。  
   - **动态更新**：时间点右移时，调整价格集合并更新总花费。  

#### **核心难点与解决**  
- **时间范围过大**（1e9 天）：离散化时间点，仅处理关键事件（开始/结束打折）。  
- **动态维护最小值**：`multiset` 或平衡树支持 O(1) 取最小值，插入/删除操作 O(log n)。  
- **高效计算总花费**：通过增量更新避免每次重新计算所有物品的最小价格。  

---

### **题解评分**  
1. **tmp_get_zip_diff（⭐️⭐️⭐️⭐️⭐️）**  
   - 思路清晰，离散化与事件驱动处理高效。  
   - 代码可读性强，利用 `multiset` 简洁实现动态维护最小值。  
   - 时间复杂度 O(m log m + ∑c_i log n)，适用于 1e5 规模数据。  

2. **Sweet_2013（⭐️⭐️⭐️）**  
   - 思路正确但未提供完整代码，实现细节模糊。  
   - 贪心策略需严格证明正确性（最优时间必为事件点）。  

---

### **最优思路提炼**  
- **离散化事件点**：仅处理关键时间点（打折开始/结束），避免无效枚举。  
- **增量更新总花费**：通过记录每个事件对总花费的贡献（差值）快速计算。  
- **高效数据结构**：`multiset` 或平衡树维护价格集合的最小值，支持动态插入/删除。  

---

### **同类型题与算法套路**  
- **区间事件处理**：如会议室调度、时间轴上的任务安排。  
- **动态维护极值**：如滑动窗口最小值、实时更新集合的极值。  
- **典型题目**：  
  1. [洛谷 P2216](https://www.luogu.com.cn/problem/P2216)：二维滑动窗口极值。  
  2. [洛谷 P2880](https://www.luogu.com.cn/problem/P2880)：区间查询极值。  
  3. [Codeforces 1029D](https://codeforces.com/problemset/problem/1029/D)：离散化与离线事件处理。  

---

### **可视化与算法演示**  

#### **动画设计**  
1. **时间轴滚动**：  
   - 横向时间轴标记离散化后的关键事件点（如 `s_i`, `t_i + 1`）。  
   - 当前处理的时间点高亮为红色，历史时间点灰化。  

2. **物品价格变化**：  
   - 每个物品的 `multiset` 用垂直列表展示，最小值用绿色高亮。  
   - 处理事件时，插入/删除价格时显示动画（如弹入/淡出）。  

3. **总花费更新**：  
   - 右侧面板实时显示当前总花费，数值变化时用箭头提示增减。  

#### **复古像素风格**  
- **8 位色调色板**：时间轴用蓝色像素块，事件点用黄色闪烁标记。  
- **音效设计**：  
  - 事件触发时播放短促“滴”声。  
  - 总花费更新时根据增减播放不同音调。  
- **自动演示模式**：按时间顺序自动处理事件，支持暂停/步进。  

---

### **代码核心实现**  
```cpp
// 离散化时间并处理事件
sort(time.begin(), time.end());
time.resize(unique(time.begin(), time.end()) - time.begin());

// 初始化每个物品的原价集合
for (int i = 1; i <= n; i++) {
    st[i].insert(original_price[i]);
}

// 处理开始和结束事件
for (auto [x, y] : startD[i]) {
    temp -= *st[x].begin();
    st[x].insert(y);
    temp += *st[x].begin();
}

// 维护总花费的最小值
ans = min(ans, temp);
```

---

### **个人心得**  
- **离散化必要性**：直接枚举 1e9 天不可行，离散化将问题规模压缩至 O(m) 级别。  
- **multiset 的坑点**：删除元素时需确保只删除一个副本（避免误删所有相同值）。  
- **贪心验证**：通过数学归纳法证明最优时间必为事件点，避免遗漏边界情况。  

--- 

通过上述分析与实现，可高效解决大规模时间轴上的动态最优化问题。

---
处理用时：93.82秒
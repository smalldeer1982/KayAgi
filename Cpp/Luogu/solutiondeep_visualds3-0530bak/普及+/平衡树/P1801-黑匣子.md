# 题目信息

# 黑匣子

## 题目描述

Black Box 是一种原始的数据库。它可以储存一个整数数组，还有一个特别的变量 $i$。最开始的时候 Black Box 是空的．而 $i=0$。这个 Black Box 要处理一串命令。

命令只有两种：

- `ADD(x)`：把 $x$ 元素放进 Black Box;

- `GET`：$i$ 加 $1$，然后输出 Black Box 中第 $i$ 小的数。

记住：第 $i$ 小的数，就是 Black Box 里的数的按从小到大的顺序排序后的第 $i$ 个元素。

我们来演示一下一个有11个命令的命令串。（如下表所示）

| 序号 | 操作 | $i$ | 数据库 | 输出 |
| :--: | :--- | :------: | ------ | :----: |
|   1  | `ADD(3)`     |   $0$    |  $3$  | / |
|   2  | `GET` |   $1$    |  $3$  | $3$ |
|   3  |`ADD(1)`|$1$|$1,3$|/|
|   4  |`GET`|$2$|$1,3$|$3$|
|   5  |`ADD(-4)`|$2$|$-4,1,3$|/|
|   6  |`ADD(2)`|$2$|$-4,1,2,3$|/|
|   7  |`ADD(8)`|$2$|$-4,1,2,3,8$|/|
|   8  |`ADD(-1000)`|$2$|$-1000,-4,1,2,3,8$|/|
|   9  |`GET`|$3$|$-1000,-4,1,2,3,8$|$1$|
|  10  |`GET`|$4$|$-1000,-4,1,2,3,8$|$2$|
|  11  |`ADD(2)`|$4$|$-1000,-4,1,2,2,3,8$|/|

现在要求找出对于给定的命令串的最好的处理方法。`ADD` 命令共有 $m$ 个，`GET` 命令共有 $n$ 个。现在用两个整数数组来表示命令串：

1. $a_1,a_2,\cdots,a_m$：一串将要被放进 Black Box 的元素。例如上面的例子中 $a=[3,1,-4,2,8,-1000,2]$。

2. $u_1,u_2,\cdots,u_n$：表示第 $u_i$ 个元素被放进了 Black Box 里后就出现一个 `GET` 命令。例如上面的例子中 $u=[1,2,6,6]$ 。输入数据不用判错。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，$1 \leq n,m \leq 10^{4}$。
- 对于 $50\%$ 的数据，$1 \leq n,m \leq 10^{5}$。
- 对于 $100\%$ 的数据，$1 \leq n,m \leq 2 \times 10^{5},|a_i| \leq 2 \times 10^{9}$，保证 $u$ 序列单调不降。

## 样例 #1

### 输入

```
7 4
3 1 -4 2 8 -1000 2
1 2 6 6
```

### 输出

```
3
3
1
2
```

# AI分析结果



**唯一算法分类**：堆（对顶堆技术）

---

**综合分析与结论**  
本题要求动态维护元素集合，实时查询第k小值。**对顶堆**是核心解法，利用大根堆维护前i-1小的元素，小根堆保存剩余元素，每次GET操作通过调整堆顶获取答案。难点在于插入时正确分配元素到堆中，并保持堆大小关系。  

**可视化设计**：  
- **动画演示**：用两个堆的图形表示，大根堆用红色边框，小根堆蓝色。插入元素时，元素根据堆顶比较动态移动，高亮当前操作元素。  
- **步进控制**：用户可点击按钮逐步执行ADD/GET，观察堆的调整过程。  
- **音效**：插入时播放“滴”声，GET时播放“叮”声，调整堆顶时播放滑动音效。  
- **复古风格**：采用8-bit像素字体，堆用方块堆叠表示，背景循环轻快芯片音乐。

---

**题解清单 (≥4星)**  
1. **Sooke（5星）**：代码简洁，利用优先队列实现，逻辑清晰，适合快速理解对顶堆机制。  
2. **sxb_201（4.5星）**：代码结构明确，注释详细，直接体现双堆协作的核心思路。  
3. **7KByte（4星）**：图文并茂，详细解释堆的调整过程，适合视觉学习者。

---

**核心代码实现（对顶堆）**  
```cpp
priority_queue<int> max_heap; // 大根堆存前i-1小
priority_queue<int, vector<int>, greater<int>> min_heap; // 小根堆存剩余

void add(int x) {
    if (max_heap.empty() || x <= max_heap.top()) {
        max_heap.push(x);
        if (max_heap.size() > i - 1) { // 超过i-1个，调整
            min_heap.push(max_heap.top());
            max_heap.pop();
        }
    } else {
        min_heap.push(x);
    }
}

int get() {
    int res = min_heap.top();
    max_heap.push(res);
    min_heap.pop();
    i++;
    return res;
}
```

---

**同类型题与算法套路**  
- **动态维护中位数**：类似对顶堆，保持两堆大小差≤1。  
- **实时查询第k大**：调整堆逻辑或使用快速选择算法。  
- **离线处理**：若操作可排序，可结合排序与高效数据结构。

---

**推荐题目**  
1. **P1168 中位数**：动态维护中位数，直接应用对顶堆。  
2. **P3871 [TJOI2010]中位数**：类似动态中位数问题。  
3. **P3834 可持久化线段树**：静态区间第k小，需主席树。

---

**个人心得摘录**  
- **调试经验**：确保大根堆大小始终为i-1，插入时需先判断是否溢出。  
- **优化点**：将u数组排序后离线处理，避免重复调整堆，减少操作次数。

---

**可视化算法演示（关键步骤）**  
1. **初始状态**：两个堆为空，i=0。  
2. **ADD(3)**：3放入大根堆，i仍为0，无需调整。  
3. **GET**：i=1，大根堆超过i-1（0），将3移到小根堆，输出3后移回大根堆。  
4. **ADD(1)**：1≤3，放入大根堆，此时大根堆大小2>i-1（1），将3移到小根堆。  

通过动画颜色区分操作步骤，每次GET后i递增，堆的调整过程直观展示。

---
处理用时：68.04秒
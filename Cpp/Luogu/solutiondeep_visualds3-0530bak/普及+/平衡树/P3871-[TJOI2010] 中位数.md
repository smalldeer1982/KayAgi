# 题目信息

# [TJOI2010] 中位数

## 题目描述

给定一个由 $N$ 个元素组成的整数序列，现在有两种操作：

- $\texttt{1 add }\textit{a}$：在该序列的最后添加一个整数 $a$，组成长度为 $N + 1$ 的整数序列。
- $\texttt{2 mid}$：输出当前序列的中位数。

中位数是指将一个序列按照从小到大排序后处在中间位置的数。（若序列长度为偶数，则指处在中间位置的两个数中较小的那个）

例 $1$：$[1, 2, 13, 14, 15, 16]$ 中位数为 $13$。  
例 $2$：$[1, 3, 5, 7, 10, 11, 17]$ 中位数为 $7$。  
例 $3$：$[1, 1, 1, 2, 3]$ 中位数为 $1$。


## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据，$1 ≤ N ≤ 10,000$，$0 ≤ M ≤ 1,000$。
- 对于 $100\%$ 的数据，$1 ≤ N ≤ 100,000$，$0 ≤ M ≤ 10,000$。

序列中整数的绝对值不超过 $10^9$，序列中的数可能有重复。

## 样例 #1

### 输入

```
6
1 2 13 14 15 16
5
add 5
add 3
mid
add 20
mid
```

### 输出

```
5
13
```

# AI分析结果



### 唯一算法分类
**对顶堆（双堆维护中位数）**

---

### 综合分析与结论
**核心思路**：  
维护两个堆：
- **大根堆**存储较小的一半元素，堆顶即为当前中位数  
- **小根堆**存储较大的一半元素  
每次插入后调整堆大小，保持大根堆元素数 ≥ 小根堆元素数，查询时直接取大根堆顶

**核心难点与解决**：  
1. **插入元素位置判断**：新元素与大根堆顶比较决定插入位置  
2. **堆大小平衡调整**：通过元素转移保证两堆大小差 ≤1  
3. **堆顶动态维护**：每次插入后可能调整堆顶元素位置  

**可视化设计思路**：  
- **颜色标记**：  
  - 红色高亮当前插入元素  
  - 蓝色标记大根堆顶，黄色标记小根堆顶  
- **动画步骤**：  
  1. 元素插入对应堆时的箭头动画  
  2. 堆调整时元素的转移动画（如大根堆顶移动到小根堆）  
  3. 查询时闪烁高亮大根堆顶  
- **复古像素风格**：  
  - 8-bit 堆结构显示（矩形块表示堆元素）  
  - 堆顶用闪烁像素箭头标识  
  - 音效：插入时短促“滴”声，调整时“哔”声，查询成功播放经典 FC 过关音效  

---

### 题解清单（≥4星）

1. **作者：Garrison（5星）**  
   - **亮点**：代码简洁，逻辑清晰，完整展示对顶堆调整逻辑  
   - **核心代码**：  
     ```cpp
     void insert(int x){
         if(q1.empty() || x <= q1.top()) q1.push(x);
         else q2.push(x);
         // 调整堆大小差
         if(q1.size() > q2.size()+1) q2.push(q1.top()), q1.pop();
         if(q2.size() > q1.size()) q1.push(q2.top()), q2.pop();
     }
     ```

2. **作者：这有一只匿（4星）**  
   - **亮点**：详细注释调整逻辑，适合新手理解  
   - **个人心得**：强调"不要轻易相信队友的话"，体现调试经验  

3. **作者：Paperback_Writer（4星）**  
   - **亮点**：引入STL优先队列实现，代码可读性极强  
   - **技巧**：通过取反实现大根堆：`priority_queue<int>`存储负数  

---

### 核心实现代码（对顶堆）
```cpp
priority_queue<int> q1; // 大根堆（实际存负数）
priority_queue<int, vector<int>, greater<int>> q2; // 小根堆

void insert(int x) {
    if(q1.empty() || x <= -q1.top()) q1.push(-x);
    else q2.push(x);
    
    // 调整堆平衡
    if(q1.size() > q2.size()+1) {
        q2.push(-q1.top());
        q1.pop();
    }
    else if(q2.size() > q1.size()) {
        q1.push(-q2.top());
        q2.pop();
    }
}

int getMid() {
    return -q1.top();
}
```

---

### 同类型题推荐
1. **P1168 中位数**（双堆模板题）  
2. **P1801 黑匣子**（动态查询第K大元素）  
3. **P3380 二逼平衡树**（进阶平衡树练习）

---

### 可视化演示设计
**Canvas动画示例**：  
```javascript
// 伪代码：绘制堆结构
function drawHeap(heap, x, y) {
    let elements = heap.slice().sort((a,b)=>b-a); // 堆数据
    elements.forEach((val, i) => {
        ctx.fillStyle = '#8B00FF'; // 紫色方块
        ctx.fillRect(x, y + i*30, 50, 25); // 绘制堆元素
        ctx.fillText(val, x+5, y + i*30 + 15);
    });
}

// 插入动画示例
async function animateInsert(val) {
    highlight(val); // 高亮当前元素
    await sleep(500);
    if(val <= q1.peek()) {
        moveTo(val, q1Pos); // 元素移动到大根堆
        q1.add(val);
    } else {
        moveTo(val, q2Pos); // 移动到小根堆
        q2.add(val);
    }
    balanceHeaps(); // 调整堆的动画
}
```

**复古音效设计**：  
- `insert_sound.wav`：8-bit 短促音（插入操作）  
- `balance_sound.wav`：调谐音（堆调整）  
- `success_sound.wav`：经典 FC 过关音效（查询成功）

---

### 总结
**最优技巧**：利用双堆性质动态维护中间值，时间复杂度 O(logN) 的插入与 O(1) 的查询，在效率与实现难度间取得完美平衡。**学习启示**：当问题涉及动态中位数/分位数时，优先考虑对顶堆或分块策略。

---
处理用时：70.57秒
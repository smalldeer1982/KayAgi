# 题目信息

# [中山市赛 2024] 参数拟合

## 题目描述

在《机械设计与制作》课程中，Jimmy 制作了一款机械臂作为期末作业。在测试与改进阶段，immy 通过实验测得了他设计的机械臂的尺寸、硬度、灵活度、最大抓力等 $n$ 个参数 $A_1, A_2\dots A_n$。根据理论计算，机械臂的最佳性能参数为 $B_1, B_2\dots B_n$。为了提高机械臂的性能，拿到更高的分数，Jimmy 决定调整机械参数。

由于机械臂各个部件间具有关联性，修改某个参数的同时也会影响到另一个参数。具体来说，只有 m 种调整可以进行：给定 $(x_i, y_i)$，让 $A_{x_i} \gets A_{x_i} + p, A_{y_i} \gets A_{y_i} + p$，其中 $p$ 为任意整数，且调整次数不限。Jimmy 希望通过调整使得 $S =\sum \limits_{i=1}^n(A_i - B_i)^2$ 最小，请你帮他算出调整后 $S$ 的最小值。

## 说明/提示

### 数据范围

- 对于 $20\%$ 的数据，$1 \leq n, m \leq 5$，$0 \leq A_i, B_i \leq 5$。
- 另有 $40\%$ 的数据，所有 $B_i = 0$ 且所有 $x_i = 1$ 。
- 对于 $100\%$ 的数据，$1 \leq n \leq 2 \times 10^5$，$1 \leq m \leq 5 \times 10^5$，$0 \leq A_i, B_i \leq 10^5$。

注意：$(x_i, y_i)$ 可能出现重复。


## 样例 #1

### 输入

```
6 3
14 9 1 0 4 7
11 11 5 8 7 3
1 2
3 4
5 6```

### 输出

```
46```

# AI分析结果



**唯一算法分类**  
图论、连通块分析、数学优化

---

**综合分析与结论**  

**核心思路**  
将每个参数调整操作视为图中的边，分析各连通块。对于每个连通块，目标是分配差值使平方和最小。关键点在于：  
1. **连通块总和奇偶性**：若存在奇数环（非二分图），总和奇偶性可调整，余数只需 `sum % 2`；若为二分图，余数需按 `sum % sz` 分配。  
2. **DFS差值转移**：通过DFS将子节点的差值累加到父节点，保持总和不变。  
3. **数学优化**：均分差值（方差最小化），余数按最优分配（如 `t*(s+1)^2 + (sz-t)*s^2`）。

**难点与解决**  
- **奇偶性调整**：利用图是否为二分图判断奇环存在，决定余数处理方式。  
- **差值转移正确性**：DFS过程中需确保差值总和不变（原题解代码错误地使用减法，应修正为加法）。  

**可视化设计**  
- **连通块高亮**：不同颜色标记连通块，动态展示DFS遍历过程。  
- **差值转移动画**：父节点与子节点差值变化，强调总和不变。  
- **奇偶性提示**：奇数环用闪烁边框标记，余数计算时弹出公式提示。  

---

**题解清单 (4星)**  
1. **dengchengyu的题解（4星）**  
   - **亮点**：结合图论与数学优化，提出奇环对奇偶性的影响。  
   - **优化点**：DFS差值转移需修正为加法（原代码错误）。  
   - **心得知**：通过三节点环示例发现奇偶性调整的可能性。  

---

**核心代码修正与实现**  

**修正后的DFS片段**  
```cpp
void dfs(int x) {
    vis[x] = 1;
    sz++;
    for (int i = st[x]; i; i = nx[i]) {
        int v = to[i];
        if (!vis[v]) {
            bz[v] = bz[x] ^ 1;
            dfs(v);
            if (a[v] != 0) {
                a[x] += a[v]; // 修正为加法，保持总和不变
                a[v] = 0;
            }
        } else if (bz[v] == bz[x]) {
            flag[rt] = 1; // 发现奇环
        }
    }
}
```

**完整修正代码**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5, M = 5e5 + 5;
typedef long long ll;
ll a[N], b[N];
int to[M << 1], nx[M << 1], st[N], tot;
int vis[N], bz[N], flag[N], rt;
ll ans = 0, sz;

void add(int x, int y) {
    to[++tot] = y, nx[tot] = st[x], st[x] = tot;
}

void dfs(int x) {
    vis[x] = 1;
    sz++;
    for (int i = st[x]; i; i = nx[i]) {
        int v = to[i];
        if (!vis[v]) {
            bz[v] = bz[x] ^ 1;
            dfs(v);
            if (a[v] != 0) {
                a[x] += a[v];
                a[v] = 0;
            }
        } else if (bz[v] == bz[x]) {
            flag[rt] = 1;
        }
    }
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &b[i]);
        a[i] -= b[i];
    }
    for (int i = 1; i <= m; i++) {
        int x, y;
        scanf("%d%d", &x, &y);
        add(x, y), add(y, x);
    }
    for (int i = 1; i <= n; i++) {
        if (!vis[i]) {
            sz = 0;
            rt = i;
            bz[i] = 0;
            dfs(i);
            ll sum = abs(a[i]);
            if (flag[i]) {
                ans += sum % 2;
            } else {
                ll t = sum / sz;
                ll t2 = sum % sz;
                ans += t * t * (sz - t2) + (t + 1) * (t + 1) * t2;
            }
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

**同类型题与推荐题目**  
1. **CF920E Connected Components**（连通块分析）  
2. **Luogu P1330 封锁阳光大学**（二分图判定）  
3. **Luogu P1969 积木大赛**（差值分配优化）  

---

**复古游戏化动画设计**  
- **像素风格**：8位色块表示节点，边用亮色线条。奇环节点闪烁红光。  
- **音效**：转移差值时播放“滴”声，发现奇环时播放警报音。  
- **自动演示**：模拟DFS遍历，逐步展示差值转移与余数计算。  

**关键动画步骤**  
1. 初始节点显示差值，连通块用不同背景色。  
2. DFS遍历时，当前节点高亮，差值转移时子节点变暗。  
3. 余数计算时弹出公式，奇环标记持续闪烁。  

---

**个人心得**  
- **调试教训**：DFS中的差值转移方向易错，需严格验证总和不变性。  
- **思维突破**：利用图论性质（二分图、奇环）优化数学分配，减少计算量。

---
处理用时：279.14秒
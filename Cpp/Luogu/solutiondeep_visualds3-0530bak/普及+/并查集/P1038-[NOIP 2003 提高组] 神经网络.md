# 题目信息

# [NOIP 2003 提高组] 神经网络

## 题目背景

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。



## 题目描述

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)

神经元（编号为 $i$）


图中，$X_1 \sim X_3$ 是信息输入渠道，$Y_1 \sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)

兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）

$$C_i=\left(\sum\limits_{(j,i) \in E} W_{ji}C_{j}\right)-U_{i}$$

公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。



## 说明/提示

**【题目来源】**

NOIP 2003 提高组第一题

## 样例 #1

### 输入

```
5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
```

### 输出

```
3 1
4 1
5 1
```

# AI分析结果



## **算法分类**
拓扑排序

---

## **综合分析与结论**
**核心思路**：所有题解均采用拓扑排序处理层间依赖，关键点包括：
1. **预处理U_i**：非输入层初始减去阈值，输入层保留原值。
2. **队列管理**：仅处理激活节点（C_i>0），按拓扑序更新下游。
3. **输出层判定**：通过出度数组标记，最终收集出度为0且激活的节点。

**难点与解决**：
- **阈值处理**：输入层不参与阈值计算（U_i无效），其余节点初始减U_i。
- **信号传递条件**：仅在C_i>0时传递，避免无效计算。
- **输出排序**：按编号升序输出，需排序或优先队列。

**可视化设计**：
1. **队列动画**：展示节点入队/出队过程，高亮当前处理节点。
2. **状态变化**：节点颜色区分激活（绿色）与未激活（灰色）。
3. **边传递效果**：动态显示信号传递时的权值计算过程。
4. **复古像素风格**：用8-bit网格表示神经元，音效触发于节点激活和信号传递。

---

## **题解评分 (≥4星)**
1. **Lucaster_ (⭐⭐⭐⭐⭐)**
   - **亮点**：代码结构清晰，详细注释预处理逻辑，通过`out`数组高效判断输出层。
   - **心得**：强调输入层阈值无效，通过`vis`数组避免重复入队。

2. **zzlzk (⭐⭐⭐⭐)**
   - **亮点**：反向建图+记忆化搜索，递归处理依赖关系，代码简洁。
   - **技巧**：递归拓扑排序，避免显式队列管理。

3. **ghj1222 (⭐⭐⭐⭐)**
   - **亮点**：显式拓扑排序流程，通过入度数组控制处理顺序。
   - **优化**：预处理时直接处理非输入层的U_i减法。

---

## **最优思路与技巧**
1. **拓扑排序队列化**：用队列维护激活节点，确保层序正确。
   ```cpp
   queue<int> q;
   for (输入层节点) q.push(i);
   while (!q.empty()) {
     int u = q.front(); q.pop();
     if (c[u] <= 0) continue;
     for (所有下游节点v) {
       c[v] += w_uv * c[u];
       if (!vis[v]) q.push(v), vis[v] = 1;
     }
   }
   ```
2. **输出层判定优化**：通过出度数组快速筛选。
   ```cpp
   for (int i=1; i<=n; i++)
     if (out[i] == 0 && c[i] > 0) 收集结果;
   ```

3. **预处理U_i**：输入层保持原值，其他节点初始减U_i。
   ```cpp
   if (c[i]初始为0) c[i] -= u[i]; // 非输入层
   ```

---

## **同类题目推荐**
1. **P1137 旅行计划** - 拓扑排序求最长路径。
2. **P1983 车站分级** - 层级依赖的拓扑排序应用。
3. **P2712 拓扑排序** - 基础拓扑排序模板题。

---

## **个人心得摘录**
- **Lucaster_**：调试时发现输入层阈值无效，通过分离处理逻辑解决。
- **faker121**：因输出层判定遗漏负状态，WA多次后添加`c[i]>0`条件。
- **AuCloud**：递归拓扑排序时未处理环，导致死循环，后增加访问标记。

---

## **可视化与算法演示**
**核心流程动画**：
1. **初始化**：输入层节点高亮黄色，其他灰色；队列显示待处理节点。
2. **处理节点**：当前节点变为绿色，计算下游节点值，传递路径高亮。
3. **激活判定**：下游节点值更新后若>0，变为黄色并入队。
4. **输出阶段**：红色边框标记输出层节点，按编号升序排列。

**复古像素实现**：
```javascript
// Canvas绘制示例
function drawNode(x, y, state) {
  ctx.fillStyle = state === 'active' ? '#00FF00' : '#808080';
  ctx.fillRect(x*32, y*32, 28, 28); // 8-bit风格节点
  if (state === 'output') ctx.strokeStyle = '#FF0000';
}
// 音效触发
function playSound(effect) {
  const sfx = { activate: 'blip.mp3', error: 'error.wav' };
  new Audio(sfx[effect]).play();
}
```

**自动演示模式**：
- **速度控制**：滑块调节处理间隔（100ms~1s）。
- **AI步进**：自动执行队列操作，动态更新节点状态。

---

通过以上分析与设计，学习者可深入理解拓扑排序在层级依赖问题中的应用，并通过交互式可视化直观掌握算法流程。

---
处理用时：76.78秒
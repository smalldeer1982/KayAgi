# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果



---

**【算法分类】**  
分层图 + SPFA 求最长路  

---

**【题解思路、算法要点与解决难点】**  
**核心思路**：将原图扩展为三层，分别表示不同状态（未买、已买未卖、已卖），通过边权转移状态，最终求最长路径。  
**关键要点**：  
1. **分层建图**：  
   - 第一层（原始状态）：允许移动但不买卖  
   - 第二层（买入状态）：从第一层对应节点通过负边权转移（模拟买入）  
   - 第三层（卖出状态）：从第二层对应节点通过正边权转移（模拟卖出）  
2. **SPFA求最长路**：由于存在正权边且可能成环，SPFA 适合处理此类最长路径问题  

**解决难点**：  
- 如何将买卖操作建模为图结构中的状态转移  
- 确保买卖操作仅发生一次（通过分层限制转移方向）  
- 处理双向边时需保证分层结构完整性  

---

**【题解评分】**  
| 题解作者         | 评分 | 亮点                                                                 |
|------------------|------|----------------------------------------------------------------------|
| fy1234567ok      | ⭐⭐⭐⭐ | 分层图思路清晰，代码仅40行，注释详细                                  |
| ctzm (Tarjan缩点) | ⭐⭐⭐⭐ | 处理强连通分量稳定，反图DFS判断可达性，通过Hack数据验证                |
| HPXXZYY          | ⭐⭐⭐  | 双端SPFA预处理最小买入价和最大卖出价，实现简洁                         |

---

**【最优思路与技巧】**  
**核心技巧**：  
1. **分层图状态转移**：  
   - 通过三层图模拟交易状态（未买→已买→已卖）  
   - 层间转移边权为交易价格，层内移动边权为0  
2. **SPFA负权处理**：将最长路问题转化为最短路问题（边权取反）  
3. **节点编号映射**：使用 `t(x,i) = x + i*n` 快速定位分层节点  

**代码实现精髓**：  
```cpp
// 分层图边权设置
for(int i=1; i<=n; ++i) {
    G[t(i,0)].push_back({t(i,1), -v}); // 买入转移
    G[t(i,1)].push_back({t(i,2), v});  // 卖出转移
}
// 原图双向边处理
add(x, y);  // 三层同时复制边
if(z == 2) add(y, x);
```

---

**【同类型题套路】**  
1. **分层图经典题**：  
   - P4568 [JLOI2011] 飞行路线（k次免费机会建模为k+1层图）  
   - P2939 [USACO09FEB]Revamping Trails G（同飞行路线）  
2. **状态转移图**：  
   - P4011 孤岛营救问题（钥匙状态作为分层维度）  

---

**【推荐练习题】**  
1. P4568 [JLOI2011] 飞行路线  
2. P1266 速度限制（状态包含速度限制信息）  
3. P3831 [SHOI2012] 回家的路（分层处理换乘）  

---

**【可视化算法演示】**  
**动画设计**：  
1. **三层图结构**：  
   - 第一层：蓝色节点，显示原图结构  
   - 第二层：绿色节点，边标注买入价格（红色负值）  
   - 第三层：黄色节点，边标注卖出价格（绿色正值）  
2. **SPFA过程**：  
   - 当前队列节点高亮为橙色  
   - 松弛操作时边闪烁黄色，更新节点显示最新距离值  
   - 最终路径以金色线条连接三层节点  

**复古像素效果**：  
- 使用16色调色板（NES风格）  
- 节点显示为8x8像素方块，层间通过阶梯状排列  
- 音效设计：  
  - 节点入队：短促“哔”声（Square Wave）  
  - 发现更优路径：上升音阶（C4→E4→G4）  
  - 算法完成：经典FC过关音效  

```javascript
// 伪代码：SPFA单步可视化
function spfaStep() {
    let u = queue.dequeue();
    highlightNode(u, COLOR_ORANGE); // 高亮当前节点
    for (let edge of G[u]) {
        playSound("beep.wav"); // 边处理音效
        if (relax(edge)) {
            highlightEdge(edge, COLOR_YELLOW); // 松弛成功边闪烁
            updateNodeDisplay(edge.v); // 更新目标节点数值
            if (!inQueue[edge.v]) {
                queue.enqueue(edge.v);
                highlightNode(edge.v, COLOR_CYAN); // 新入队节点高亮
            }
        }
    }
}
```

---

**【关键题解代码】**  
fy1234567ok 分层图完整实现：  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;

int n, m, d[maxn*3], inq[maxn*3];
vector<pair<int, int>> G[maxn*3];

#define t(x,i) (x+i*n)
#define add(x, y) G[t(x,0)].push_back({t(y,0), 0}), G[t(x,1)].push_back({t(y,1),0}), G[t(x,2)].push_back({t(y,2),0})

void spfa(int s) {
    memset(d, 0x80, sizeof(d)); // 初始化为-INF
    d[s] = 0; 
    queue<int> Q; Q.push(s);
    while(!Q.empty()) {
        int x = Q.front(); Q.pop();
        for(auto [v, len] : G[x]) 
            if(d[v] < d[x] + len) {
                d[v] = d[x] + len;
                if(!inq[v]) Q.push(v);
            } 
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin >> n >> m;
    for(int i=1, v; i<=n; ++i) {
        cin >> v;
        G[t(i,0)].push_back({t(i,1), -v});
        G[t(i,1)].push_back({t(i,2), v});
    }
    for(int i=1,x,y,z; i<=m; ++i) {
        cin >> x >> y >> z;
        add(x, y);
        if(z == 2) add(y, x);
    }
    spfa(t(1,0));
    cout << d[t(n,2)];
}
```

---
处理用时：86.07秒
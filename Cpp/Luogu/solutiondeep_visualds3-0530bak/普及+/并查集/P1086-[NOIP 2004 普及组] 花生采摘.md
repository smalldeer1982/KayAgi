# 题目信息

# [NOIP 2004 普及组] 花生采摘

## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。

**注意**：在采摘过程中不能回到路边。

## 说明/提示

noip2004普及组第2题


## 样例 #1

### 输入

```
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0```

### 输出

```
37```

## 样例 #2

### 输入

```
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```

### 输出

```
28```

# AI分析结果



**唯一算法分类**: 模拟 + 贪心

---

### 题解思路、算法要点与解决难点

#### 核心思路
1. **贪心策略**：按花生数量从大到小排序，依次采摘。
2. **时间计算**：使用曼哈顿距离计算移动时间，每一步需判断剩余时间是否足够返回路边。
3. **关键变量**：
   - 当前坐标 `(x, y)`
   - 剩余时间 `k`
   - 总花生数 `ans`

#### 解决难点
1. **首次采摘特殊处理**：从路边到第一个点只需计算行距离，无需列距离。
2. **时间判断逻辑**：每次移动后需验证 `剩余时间 ≥ 当前点行号`（返回路边所需时间）。
3. **数据结构优化**：用结构体存储坐标和花生数，排序后遍历。

---

### 题解评分 (≥4星)
1. **qhr2023（5星）**  
   - **亮点**：代码极简（仅18行），逻辑清晰，用结构体排序和累加时间。
   - **代码片段**：
     ```cpp
     for (int i=1; i<=cnt; ++i) {
         sum += abs(a[i-1].x-a[i].x) + abs(a[i-1].y-a[i].y) + 1;
         if (sum + a[i].x <= k) ans += a[i].v;
         else break;
     }
     ```
2. **jiangXxin（4星）**  
   - **亮点**：详细注释和曼哈顿距离实现，首次采摘特判。
   - **心得**：提到“采摘过程中不能回到路边”的边界条件。
3. **_Arahc_（4星）**  
   - **亮点**：使用优先队列和 `map` 动态管理花生点，避免全排序。

---

### 最优思路与技巧
1. **降维排序**：将二维坐标存储为结构体数组，按花生数降序排序。
2. **曼哈顿距离**：计算两点间移动时间（`|x1-x2| + |y1-y2|`）。
3. **时间验证公式**：`剩余时间 ≥ 移动时间 + 采摘时间（1单位） + 返回时间（当前行号）`。

---

### 类似题目推荐
1. **P1090 [NOIP2004 提高组] 合并果子**（贪心+优先队列）
2. **P1223 [NOIP1999 普及组] 排队接水**（排序+时间计算）
3. **P1012 [NOIP1998 提高组] 拼数**（字符串排序贪心）

---

### 可视化与算法演示
#### 动画设计
1. **网格绘制**：在 Canvas 中绘制花生田网格，不同颜色表示花生数量。
2. **高亮路径**：红色标记当前采摘点，蓝色显示移动路径。
3. **时间条**：顶部显示剩余时间，实时更新。
4. **复古风格**：8位像素音效（移动时“哔”，采摘成功“叮”）。

#### 关键步骤演示
```javascript
// 伪代码：模拟采摘过程
let time = k, ans = 0, current = {x:0, y:0};
for (const pea of sortedPeas) {
    const moveTime = Math.abs(current.x - pea.x) + Math.abs(current.y - pea.y);
    const totalCost = moveTime + 1 + pea.x; // 移动+采摘+返回时间
    if (time >= totalCost) {
        time -= (moveTime + 1); // 扣除移动和采摘时间
        ans += pea.v;
        current = {x: pea.x, y: pea.y};
    } else break;
}
```

---

### 个人心得摘录
> “第一次采摘必须特判能否返回，否则直接输出0。” —— jiangXxin  
> “用优先队列动态管理花生点，避免全排序的空间浪费。” —— _Arahc_

---

### 代码实现（核心逻辑）
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node { int v, x, y; } a[425];
bool cmp(node a, node b) { return a.v > b.v; }

int main() {
    int n, m, k, cnt = 0, sum = 0, ans = 0;
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            int x; cin >> x;
            if (x > 0) a[++cnt] = {x, i, j};
        }
    sort(a + 1, a + cnt + 1, cmp);
    a[0] = {0, 0, a[1].y}; // 初始位置在路边
    
    for (int i = 1; i <= cnt; i++) {
        sum += abs(a[i-1].x - a[i].x) + abs(a[i-1].y - a[i].y) + 1;
        if (sum + a[i].x <= k) ans += a[i].v;
        else break;
    }
    cout << ans;
    return 0;
}
```

---
处理用时：72.54秒
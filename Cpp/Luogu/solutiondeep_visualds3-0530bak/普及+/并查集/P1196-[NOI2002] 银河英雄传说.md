# 题目信息

# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 说明/提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)

题目中没有强制 $i \neq j$，但是实测数据中不存在 $i = j$ 的情况。

## 样例 #1

### 输入

```
4
M 2 3
C 1 2
M 2 4
C 4 2```

### 输出

```
-1
1```

# AI分析结果



---

**唯一算法分类**：带权并查集

---

### **题解核心思路与难点分析**
#### ▍算法核心要点
1. **数据结构设计**  
   - `fa[]`：记录节点父节点  
   - `front[]`：记录节点到父节点的距离（动态维护到根节点的距离）  
   - `size[]`：记录以当前节点为根的集合大小（用于合并时计算新距离）

2. **路径压缩优化**  
   在 `find()` 函数中递归更新父节点和距离：  
   ```cpp
   int find(int x) {
       if (fa[x] == x) return x;
       int root = find(fa[x]);     // 先递归找到根节点
       front[x] += front[fa[x]];   // 动态更新当前节点到根的距离
       return fa[x] = root;        // 路径压缩
   }
   ```

3. **合并操作**  
   合并时将 `i` 的根节点连接到 `j` 的根节点尾部，并更新 `front` 和 `size`：  
   ```cpp
   void merge(int i, int j) {
       int fi = find(i), fj = find(j);
       fa[fi] = fj;
       front[fi] = size[fj];    // i的根到j的根的距离 = j集合大小
       size[fj] += size[fi];    // 更新j集合大小
   }
   ```

4. **查询操作**  
   若两节点同根，计算距离差：  
   ```cpp
   if (find(x) == find(y)) 
       return abs(front[x] - front[y]) - 1;
   ```

#### ▍解决难点
- **动态维护距离**：路径压缩时需先递归更新父节点，再计算当前节点的距离（顺序不可逆）。  
- **合并时的距离计算**：`i` 的根节点距离 `j` 的根节点的距离等于 `j` 集合大小（`size[j]`）。

---

### **题解评分（≥4星）**
1. **假装思考（★★★★★）**  
   - **亮点**：详细解释路径压缩时如何动态更新 `front[]`，代码清晰注释完整  
   - **核心代码**：  
     ```cpp
     front[fx] += num[fy];  // 合并时更新距离
     num[fy] += num[fx];    // 更新集合大小
     ```

2. **破壁人（★★★★☆）**  
   - **亮点**：简洁实现带权并查集，直接维护 `s[]`（距离）和 `b[]`（集合大小）  
   - **核心代码**：  
     ```cpp
     s[r1] = s[r2] + b[r2];  // 合并时更新根节点距离
     ```

3. **Mr_Wolfram（★★★★☆）**  
   - **亮点**：代码可读性强，变量命名清晰（`dis[]` 和 `num[]`）  
   - **核心代码**：  
     ```cpp
     dis[r1] = dis[r2] + num[r2];  // 合并逻辑
     ```

---

### **最优思路与技巧提炼**
1. **动态路径压缩**  
   在 `find()` 中递归更新父节点和距离，确保所有节点直接指向根节点并维护最新距离。

2. **集合大小辅助合并**  
   用 `size[]` 记录集合大小，合并时快速计算新距离（`front[fx] = size[fy]`）。

3. **离线预处理**  
   部分题解通过预先处理所有合并操作（如重构二叉树），再统一计算最终状态的距离。

---

### **同类型题与算法套路**
- **通用解法**：带权并查集适用于需要维护节点间关系的场景（如距离、层级、模数关系）。  
- **相似题目**：  
  - [P2342 叠积木](https://www.luogu.com.cn/problem/P2342)（合并与查询下方块数）  
  - [P2024 食物链](https://www.luogu.com.cn/problem/P2024)（维护环形关系）  
  - [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)（并查集扩展应用）

---

### **可视化与算法演示**
#### ▍动画设计
1. **数据结构可视化**  
   - **树形结构**：以像素风格绘制并查集树，根节点用红色高亮，路径压缩时动态收缩分支。  
   - **距离标记**：每个节点旁显示 `front[]` 值，合并时用箭头标注新连接关系。

2. **关键操作高亮**  
   - **路径压缩**：当前节点向上跳跃时，路径变为黄色，递归完成后变为绿色。  
   - **合并操作**：被合并的子树整体平移至目标队列尾部，`size[]` 数值动态更新。

3. **交互功能**  
   - **步进控制**：支持单步执行 `find()` 和 `merge()`，观察每一步 `front[]` 和 `size[]` 的变化。  
   - **音效反馈**：路径压缩成功时播放“咔嗒”音效，查询结果为 -1 时播放低沉音效。

#### ▍复古像素风格实现
```javascript
// Canvas 绘制节点示例（简化版）
function drawNode(x, y, value, isRoot) {
    ctx.fillStyle = isRoot ? "#FF0000" : "#00FF00"; // 根节点红色，普通绿色
    ctx.fillRect(x * 30, y * 50, 25, 25);          // 节点方块
    ctx.fillStyle = "#FFFFFF";
    ctx.fillText(value, x * 30 + 5, y * 50 + 15);  // 显示 front 值
}
```

---

### **个人心得摘录**
> “路径压缩时先递归更新父节点，再更新当前节点距离，否则会导致距离计算错误。” —— 假装思考  
> “合并时只需更新根节点的 `front`，子节点在后续 `find()` 中自动更新。” —— Mr_Wolfram

---

### **推荐练习题**
1. [P1197 星球大战](https://www.luogu.com.cn/problem/P1197)（逆向并查集）  
2. [P5937  Parity Game](https://www.luogu.com.cn/problem/P5937)（带权并查集 + 离散化）  
3. [CF455D  Serega and Fun](https://www.luogu.com.cn/problem/CF455D)（块状链表与并查集结合）

---
处理用时：81.09秒
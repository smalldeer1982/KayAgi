# 题目信息

# [JSOI2008] 星球大战

## 题目描述

很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治着整个星系。

某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。

但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。

现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le m \le 2\times 10^5$，$1\le n \le 2m$，$x \neq y$。

[JSOI2008]


## 样例 #1

### 输入

```
8 13
0 1
1 6
6 5
5 0
0 6
1 2
2 3
3 4
4 5
7 1
7 2
7 6
3 6
5
1
6
3
5
7
```

### 输出

```
1
1
1
2
3
3```

# AI分析结果



### **唯一算法分类**  
**并查集**

---

### **题解思路、算法要点与解决难点**  
#### **核心思路**  
1. **逆向思维**：将摧毁操作转换为重建操作，从最终状态逆序处理。  
2. **并查集维护连通性**：通过合并操作动态维护连通块数量。  
3. **邻接表存储图**：快速遍历每个节点的相邻节点。  

#### **解决难点**  
- **动态删除的不可逆性**：并查集无法直接支持删除操作，通过逆序重建将问题转化为合并操作。  
- **高效合并与统计**：每次恢复节点时仅需遍历其邻接节点，避免全图遍历。  

#### **关键步骤**  
1. **初始化**：标记所有被摧毁的节点，构建初始连通块（仅保留未摧毁的节点和边）。  
2. **逆序处理**：从最后一个被摧毁的节点开始恢复，每次合并该节点与其邻接的可用节点。  
3. **连通块计数**：每次恢复后通过 `总节点数 - 合并次数` 计算当前连通块数。  

---

### **题解评分 (≥4星)**  
1. **碳六灵（赞235）**  
   - **评分**：★★★★★  
   - **亮点**：代码结构清晰，使用链式前向星存储边，逆序处理逻辑简洁，时间复杂度最优。  
   - **核心代码**：  
     ```cpp  
     void hb(int u, int v) {  
         u = find(u), v = find(v);  
         if (u != v) father[v] = u;  
     }  
     ```  
     - **个人心得**：通过逆向思维将问题转换为修建操作，显著降低复杂度。  

2. **花开依然爱Qu（赞91）**  
   - **评分**：★★★★☆  
   - **亮点**：使用邻接表遍历邻接节点，代码可读性高。  
   - **核心代码**：  
     ```cpp  
     for (i = head[u]; i != -1; i = a[i].next)  
         if (!e[a[i].to] && find(a[i].to) != find(u))  
             tot--, f[find(a[i].to)] = find(u);  
     ```  

3. **Golden_Winter（赞72）**  
   - **评分**：★★★★☆  
   - **亮点**：按时间轴排序边，合并时动态维护连通块数。  
   - **核心代码**：  
     ```cpp  
     sort(a + 1, a + 1 + m);  
     for (int i = 0; i <= K; i++) {  
         for (; a[j].c == i; j++) merge(a[j].x, a[j].y);  
         ans[i] = num - (K - i);  
     }  
     ```  

---

### **最优思路或技巧提炼**  
1. **逆向处理**：将删除操作转为添加操作，利用并查集的合并特性。  
2. **邻接表遍历**：仅处理当前恢复节点的邻接节点，避免冗余计算。  
3. **路径压缩优化**：通过 `find` 函数的路径压缩，确保并查集操作接近 O(1)。  

---

### **同类型题或类似算法套路**  
- **动态连通性问题**：需处理动态变化的图结构（如边/节点的增删）。  
- **离线处理**：通过逆序操作将不可逆问题转化为可合并问题。  

#### **推荐题目**  
1. **P3144 [USACO16OPEN]关闭的农场**：类似动态连通性问题。  
2. **P1196 [NOI2002]银河英雄传说**：并查集维护距离信息。  
3. **P3367 【模板】并查集**：基础并查集实现。  

---

### **可视化与算法演示**  
#### **动画设计**  
1. **初始状态**：用红色标记被摧毁的节点，绿色为可用节点，灰色边为不可用边。  
2. **恢复过程**：逆序恢复节点时，将其变为绿色，并高亮与其相邻的绿色节点。  
3. **合并动画**：用连线颜色变化表示合并操作（如黄色闪烁后变为统一颜色）。  
4. **统计面板**：实时显示当前连通块数。  

#### **复古像素风格**  
- **颜色方案**：使用 8-bit 调色板（绿-可用，红-摧毁，黄-合并）。  
- **音效**：恢复节点时播放「哔」声，合并时播放「叮」声。  

---

### **代码实现片段**  
#### **核心合并与计数逻辑**  
```cpp  
int ans[k + 1];  
ans[k] = initial_block_count;  
for (int i = k - 1; i >= 0; i--) {  
    int node = destroyed_nodes[i];  
    vis[node] = false; // 标记为可用  
    block_count++;      // 初始假设为独立块  
    for (int j = head[node]; j; j = edges[j].next) {  
        int neighbor = edges[j].to;  
        if (!vis[neighbor] && find(node) != find(neighbor)) {  
            merge(node, neighbor);  
            block_count--;  
        }  
    }  
    ans[i] = block_count;  
}  
```  

---

### **个人心得摘录**  
- **碳六灵**：  
  > “逆向思维是本题的关键，通过将摧毁转为修建，问题迎刃而解。”  
- **wjyyy**：  
  > “注意每次合并时祖先的判断，必须使用 `find` 函数而非直接访问父节点。”  

---

### **总结**  
通过逆向处理与并查集的高效合并，本题在 O(m α(n)) 时间复杂度内解决动态连通性问题。可视化设计中，像素风格和音效可增强学习体验，而邻接表与路径压缩则是代码高效的关键。

---
处理用时：81.02秒
# 题目信息

# [NOIP 2010 提高组] 关押罪犯

## 题目背景

NOIP2010 提高组 T3

## 题目描述

S 城现有两座监狱，一共关押着 $N$ 名罪犯，编号分别为 $1\sim N$。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 $c$ 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 $c$ 的冲突事件。

每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。

在详细考察了 $N$ 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。

那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？


## 说明/提示

**输入输出样例说明**

罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是 $3512$（由 $2$ 号和 $3$ 号罪犯引发）。其他任何分法都不会比这个分法更优。

![](https://cdn.luogu.com.cn/upload/image_hosting/uia11zcq.png)

**数据范围**  

对于 $30\%$ 的数据有 $N\leq 15$。

对于 $70\%$ 的数据有 $N\leq 2000,M\leq 50000$。  

对于 $100\%$ 的数据有 $N\leq 20000,M\leq 100000$。


## 样例 #1

### 输入

```
4 6
1 4 2534
2 3 3512
1 2 28351
1 3 6618
2 4 1805
3 4 12884```

### 输出

```
3512```

# AI分析结果



## 算法分类
**并查集（种类并查集 / 拓展域并查集）**

---

## 题解思路与核心难点

### 算法要点对比
| 方法               | 核心思路                                                                 | 实现难点                                                                 | 时间复杂度       |
|--------------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------|------------------|
| **拓展域并查集**   | 每个节点拆分为两个域（自身/敌人域），通过合并操作维护敌人关系            | 正确维护两个域的合并关系，避免同一节点的两个域合并                       | O(Mα(N))         |
| **二分图+二分答案**| 二分最大冲突值，将大于该值的边构建图，判断是否是二分图                   | 二分范围控制，多次进行 DFS 染色判断                                      | O(M logC)        |
| **贪心+普通并查集**| 按冲突值降序处理，用辅助数组记录敌人，将敌人的敌人合并到同一集合         | 维护多组敌人关系时需处理多个合并分支                                     | O(Mα(N))         |

### 解决难点关键
1. **拓展域并查集**：通过 `u` 和 `u+n` 表示两个对立状态，合并时始终保证 `u` 与 `v` 的反状态相连。
   ```cpp
   merge(u, v+n);  // u与v的敌人域合并
   merge(v, u+n);  // v与u的敌人域合并
   ```
2. **二分图判定**：染色时若相邻节点颜色相同则非二分图，需正确处理回溯逻辑。
3. **贪心策略**：按冲突值降序处理，优先解决高冲突对，遇到无法分离的冲突时即为答案。

---

## 题解评分（≥4星）

### ⭐⭐⭐⭐ 梦回还（拓展域并查集）
- **亮点**：代码简洁，直接利用双倍空间处理对立关系，完美体现种类并查集的核心思想。
- **代码片段**：
  ```cpp
  if (find(u) == find(v)) { // 冲突检测
      printf("%d", val); break;
  }
  merge(u, v+n); merge(v, u+n);
  ```

### ⭐⭐⭐⭐ _Weslie_（拓展域详解）
- **亮点**：通过示例详细解释拓展域原理，附带同类题扩展（如食物链问题），极具教学价值。
- **核心思想**：
  > "将每个节点的正反状态分离，通过合并操作维护敌人的敌人关系"

### ⭐⭐⭐⭐ fy0123（二分图+二分答案）
- **亮点**：将问题转化为二分图判定问题，思路清晰易懂，适合理解图论本质。
- **优化点**：预处理排序后只需线性扫描，二分范围控制精准。

---

## 最优技巧提炼
1. **对立域拆分**：将每个实体拆分为正反两个逻辑域（如 `u` 和 `u+n`），通过并查集维护对立关系。
2. **贪心降序处理**：优先处理高权值冲突，首次无法解决的冲突即为全局最优解。
3. **二分答案转化**：将极值问题转化为判定问题，结合二分图特性快速验证。

---

## 类似算法套路
- **对立关系维护**：POJ 1182（食物链）、洛谷 P1892（团伙）
- **二分答案+图论**：洛谷 P3385（负环判定）、POJ 3041（最小顶点覆盖）

---

## 推荐相似题目
1. **P1892 [BOI2003]团伙**（拓展域基础应用）
2. **P2024 [NOI2001]食物链**（三域对立关系）
3. **P3385 负环**（二分答案+图论判定）

---

## 可视化与算法演示设计
### 动画方案（拓展域并查集）
1. **像素风格呈现**：
   - 每个节点显示为两个色块（红/蓝表示两个域）
   - 合并操作时，用闪烁箭头连接对应域
2. **关键步骤高亮**：
   - **冲突检测**：红色边框高亮冲突的 `u` 和 `v`
   - **域合并**：动态绘制 `u→v+n` 和 `v→u+n` 的连线
3. **交互控制**：
   - 步进按钮单步执行合并
   - 速度滑块调节动画速度
   - 音效：合并成功（清脆音效）、冲突发生（警报音）

### 代码片段（JS 动画核心）
```javascript
class UnionFind {
    constructor(n) {
        this.parent = Array.from({length: 2*n}, (_,i) => i);
    }
    find(u) {
        if (this.parent[u] !== u) {
            this.parent[u] = this.find(this.parent[u]);
        }
        return this.parent[u];
    }
    merge(u, v) {
        this.parent[this.find(u)] = this.find(v);
    }
}
```

---

## 个人心得摘录
> "处理敌人关系时，敌人的敌人就是朋友——这看似简单的逻辑，通过并查集的双域设计变得异常优雅。" —— _Weslie_

> "二分答案的难点不在于写代码，而在于如何将问题转化为可判定的性质，这需要深刻的问题理解。" —— fy0123

---

## 总结
通过拓展域并查集或二分图判定，可高效解决本问题。前者以简洁的代码实现复杂关系维护，后者以清晰的逻辑展现问题本质。可视化设计应聚焦对立域的合并过程，通过像素动画强化理解。

---
处理用时：72.66秒
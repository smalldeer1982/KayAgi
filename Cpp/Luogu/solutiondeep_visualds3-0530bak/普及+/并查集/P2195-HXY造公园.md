# 题目信息

# HXY造公园

## 题目描述

现在有一个现成的公园，有 $n$ 个休息点和 $m$ 条双向边连接两个休息点。众所周知，HXY 是一个 SXBK 的强迫症患者，所以她打算施展魔法来改造公园并即时了解改造情况。她可以进行以下两种操作：

1. 对某个休息点 $x$，查询公园中可以与该点互相到达的休息点组成的路径中的最长路径。
2. 对于两个休息点 $x,y$，如果 $x,y$ 已经可以互相到达则忽略此次操作。否则，在 $x$ 可到达的所有休息点和 $y$ 可到达的所有休息点（包括 $x,y$ 自身）分别选择一个休息点，然后在这两个休息点之间连一条边，并且这个选择应该满足对于连接后的公园，$x$ 和 $y$ 所在的区域（即 $x,y$ 可达到的所有休息点和边组成的集合）中的最长路径的长度最小。

HXY打算进行 $q$ 个操作，请你回答她的对于公园情况的询问（操作 1）或者执行她的操作（操作 2）。

注：所有边的长度皆为 $1$。保证不存在环。最长路径定义为：对于点 $v_1,v_2\cdots v_k$，如果对于其中任意的 $v_i$ 和 $v_{i+1}\quad (1\le i\le k-1)$，都有边相连接，那么 $v_j\quad(1\le j\le k)$ 所在区域的最长路径就是 $k-1$。


## 说明/提示

### 数据范围及约定

- 对于 $10\%$ 的数据，只存在操作 1。
- 对于 $30\%$ 的数据，$1\le m<n\le 20$，$1\le q\le5$。
- 对于 $60\%$ 的数据，$1\le m<n \le 2000$，$1\le q\le 1000$。
- 对于 $100\%$ 的数据，$1 \le m<n \le 3\times 10^5$，$1\le q\le 3\times 10^5$。


## 样例 #1

### 输入

```
6 0 6
2 1 2
2 3 4
2 5 6
2 3 2
2 5 3
1 1```

### 输出

```
4
```

# AI分析结果



---

**算法分类**  
并查集 + 树的直径

---

### **题解核心思路与难点对比**

#### **核心逻辑**
1. **初始预处理**  
   - 使用并查集维护森林连通性  
   - 对每棵树预处理其直径（最长路径）  
   - **关键变量**：`c[x]` 表示以 `x` 为根的树的直径长度  

2. **操作1（查询）**  
   - 直接返回并查集根节点对应的 `c[x]` 值  

3. **操作2（合并）**  
   - 若两树已连通则忽略  
   - 计算新直径：  
     \[
     \text{新直径} = \max\left( \left\lceil \frac{c[x]}{2} \right\rceil + \left\lceil \frac{c[y]}{2} \right\rceil +1, \ c[x], \ c[y] \right)
     \]
   - 更新并查集与 `c[x]`  

#### **难点对比**
| 题解作者       | 直径求法     | 合并公式推导               | 时间复杂度优化           |
|----------------|--------------|----------------------------|--------------------------|
| Priori_Incantatem | 树形DP       | 详细证明中点选择必要性     | 路径压缩并查集           |
| caozy623       | 两次BFS      | 图解说明中点连接策略       | 非递归遍历避免栈溢出     |
| walk_alone     | 树形DP       | 数学公式推导新直径计算     | 按秩合并优化并查集       |

---

### **题解评分（≥4星）**

1. **Priori_Incantatem（5星）**  
   - **亮点**：详细证明合并策略的正确性，代码可读性强，处理边界条件（如原直径可能更大）  
   - **代码片段**：  
     ```cpp
     int tmp = ((c[x]+1)>>1) + ((c[y]+1)>>1) + 1;
     tmp = max(tmp, max(c[x], c[y]));
     ```

2. **caozy623（4.5星）**  
   - **亮点**：图解说明中点连接策略，使用两次BFS直观求直径  
   - **个人心得**：  
     > "合并时要取直径的中点，否则会错样例！调了半天才发现公式没加原直径的比较。"

3. **Rusalka（4星）**  
   - **亮点**：简洁的树形DP实现，并查集路径压缩优化  
   - **代码片段**：  
     ```cpp
     void dfs(int u, int fa) {
         int m1 = -1, m2 = -1;
         for (auto v : G[u]) {
             if (v == fa) continue;
             dfs(v, u);
             int tmp = d[v] + 1;
             if (tmp > m1) m2 = m1, m1 = tmp;
             else if (tmp > m2) m2 = tmp;
         }
         c[u] = max(m1 + m2, max(m1, m2));
     }
     ```

---

### **最优思路与技巧提炼**

1. **树的直径高效求法**  
   - **树形DP法**：每个节点维护子树最长和次长路径，时间复杂度 \(O(n)\)  
   - **两次BFS法**：任选节点找到最远点，再从此点找最远点，两段距离即直径  

2. **合并策略的数学推导**  
   - 新直径由以下三者取最大值：  
     - 原两树直径的较大值  
     - 两树半径（中点分割后的半长）之和加1  
   - **公式核心**：  
     \[
     \text{新直径} = \max\left( \text{原最大值}, \left\lceil \frac{d_1}{2} \right\rceil + \left\lceil \frac{d_2}{2} \right\rceil +1 \right)
     \]

3. **并查集优化技巧**  
   - 路径压缩 + 按秩合并，确保操作均摊 \(O(\alpha(n))\) 时间复杂度  

---

### **同类题目推荐**
1. **CF455C Civilization**  
   - 双倍经验题，题意与解法完全相同  

2. **P3304 [SDOI2013] 直径**  
   - 求树的直径并统计所有直径必经边的数量  

3. **P4408 [NOI2003] 逃学的小孩**  
   - 结合直径性质求最优路径  

---

### **可视化与算法演示**

#### **动画设计（8位像素风格）**
1. **数据结构展示**  
   - **并查集树**：用不同颜色方块表示不同连通块，根节点高亮  
   - **直径路径**：红色线段标记当前树的直径  

2. **合并操作动画**  
   - **步骤1**：高亮待合并的两棵树，显示其直径和中点  
   - **步骤2**：在中点间绘制黄色连线，播放“连接音效”  
   - **步骤3**：计算新直径，更新并查集根节点颜色  

3. **交互功能**  
   - **速度控制**：滑块调节动画速度（100ms~2s/步）  
   - **单步执行**：按空格键逐步执行合并/查询操作  

#### **音效设计**
- **连接成功**：8-bit风格“叮”声  
- **查询操作**：短促“滴”声  
- **错误操作**：低沉“嗡”声（如重复合并同一连通块）  

---

### **代码实现（关键逻辑）**

```cpp
// 树形DP求直径（Priori_Incantatem题解核心）
void dfs(int x, int fa) {
    int m1 = -1, m2 = -1;
    for (auto y : e[x]) {
        if (y == fa) continue;
        dfs(y, x);
        int tmp = d[y] + 1;
        if (tmp > m1) m2 = m1, m1 = tmp;
        else if (tmp > m2) m2 = tmp;
    }
    d[x] = max(d[x], m1);
    g[x] = max(m1 + m2, max(m1, m2));
    len = max(len, g[x]);
}

// 合并操作（walk_alone题解核心）
void merge(int x, int y) {
    x = find(x), y = find(y);
    if (x == y) return;
    int new_len = max((c[x]+1)/2 + (c[y]+1)/2 + 1, max(c[x], c[y]));
    f[x] = y;
    c[y] = new_len;
}
```

---

**总结**  
本题需结合并查集的动态连通性维护与树的直径性质，核心难点在于合并时最小化新直径的策略推导。通过预处理每棵树的直径，并在合并时巧妙选择中点连接，可高效处理大规模数据。

---
处理用时：86.49秒
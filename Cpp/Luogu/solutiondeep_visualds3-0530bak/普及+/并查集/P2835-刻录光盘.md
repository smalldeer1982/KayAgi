# 题目信息

# 刻录光盘

## 题目描述

在JSOI2005夏令营快要结束的时候，很多营员提出来要把整个夏令营期间的资料刻录成一张光盘给大家，以便大家回去后继续学习。组委会觉得这个主意不错！可是组委会一时没有足够的空光盘，没法保证每个人都能拿到刻录上资料的光盘，又来不及去买了，怎么办呢？！

组委会把这个难题交给了LHC，LHC分析了一下所有营员的地域关系，发现有些营员是一个城市的，其实他们只需要一张就可以了，因为一个人拿到光盘后，其他人可以带着U盘之类的东西去拷贝啊！

可是，LHC调查后发现，由于种种原因，有些营员并不是那么的合作，他们愿意某一些人到他那儿拷贝资料，当然也可能不愿意让另外一些人到他那儿拷贝资料，这与我们JSOI宣扬的团队合作精神格格不入！！！

现在假设总共有N个营员（2<=N<=200），每个营员的编号为1~N。LHC给每个人发了一张调查表，让每个营员填上自己愿意让哪些人到他那儿拷贝资料。当然，如果A愿意把资料拷贝给B，而B又愿意把资料拷贝给C，则一旦A获得了资料，则B，C都会获得资料。

现在，请你编写一个程序，根据回收上来的调查表，帮助LHC计算出组委会至少要刻录多少张光盘，才能保证所有营员回去后都能得到夏令营资料？


## 样例 #1

### 输入

```
5
2 3 4 0
4 5 0
0
0
1 0```

### 输出

```
1```

# AI分析结果



### 算法分类
强连通分量（SCC）与缩点

---

### 题解思路与核心难点
**核心逻辑**：通过强连通分量将图转化为 DAG，统计入度为 0 的强连通分量数量。  
**解决难点**：  
1. **强连通分量识别**：Tarjan/Kosaraju 算法精准定位环状结构  
2. **单向关系处理**：传统并查集无法处理单向传播关系，需结合 Floyd 传递闭包或缩点技术  
3. **入度统计优化**：缩点后只需检查跨分量的边即可计算入度  

**可视化设计要点**：  
- **动态染色**：用渐变色区分不同 SCC，红色表示当前遍历节点，黄色表示栈内节点  
- **DFN/LOW 值追踪**：在节点旁实时显示这两个值的更新过程  
- **缩点动画**：将 SCC 收缩为超级节点，用连线动画展示跨分量边  
- **入度统计面板**：右侧独立区域显示各缩点的入度值，入度归零时闪烁提示  

---

### 题解评分（≥4星）

#### 1. PrincessYR✨～（5★）
**核心亮点**：  
- 完整 Tarjan 算法教学配图解  
- 关键代码段注释清晰（DFN/LOW 更新逻辑）  
- 缩点后入度统计代码简洁高效  
**代码片段**：
```cpp
if(bl[i] != bl[next]) ru[bl[next]]++;
```

#### 2. hongzy（4★）
**创新点**：  
- 改造并查集的合并规则为单向传播  
- 结合 Floyd 预处理传播关系  
**关键逻辑**：
```cpp
void Unite(int x, int y) {
    while(x != f[x]) x = f[x]; 
    f[y] = x; // 单向合并
}
```

#### 3. Randolph、（4★）
**独特价值**：  
- 提供 Kosaraju 算法实现  
- 反向图两次 DFS 思路清晰  
**核心代码**：
```cpp
void dfs2(int u){
    if(SCCNo[u]) return;
    SCCNo[u] = SCCCnt;
    for(int i = 0;i < G2[u].size();i++) 
        dfs2(G2[u][i]);
}
```

---

### 最优思路提炼
1. **SCC 快速定位**：  
   - Tarjan 算法通过 DFS 栈维护当前路径  
   - `DFN[u] == LOW[u]` 时弹出栈元素形成 SCC  
2. **缩点技巧**：  
   - 对跨分量的边只保留首尾分量间的连接  
   - 使用 `belong[]` 数组记录节点所属分量  
3. **入度零统计**：  
   - 仅需遍历原始边集判断是否跨分量  
   - 最终统计各分量入度为零的数量  

---

### 同类型题目
1. [P2341] 受欢迎的牛（SCC 缩点+出度统计）  
2. [P2746] 校园网（SCC 入度/出度双重统计）  
3. [P3387] 缩点（SCC 缩点后 DP）

---

### 复古像素化演示方案
**实现要素**：  
1. **16色 Palette**：  
   - 节点：深蓝（未访问）、粉红（栈中）、翠绿（已处理）  
   - 边：灰色（普通）、金色（跨分量边）  
2. **音效设计**：  
   - DFS 递归：8-bit "哔" 声（频率随递归深度变化）  
   - 弹出栈：短促 "咔嚓" 声  
   - 发现 SCC：胜利小号音效  
3. **自动演示模式**：  
   - 按空格键切换手动/自动模式  
   - 自动模式下算法以 2x 速度执行关键步骤  

**Canvas 关键逻辑**：  
```javascript
function drawSCC(stack) {
  ctx.fillStyle = '#2C3E50'; // 深蓝背景
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  stack.forEach((node, idx) => {
    const x = 50 + idx * 40;
    const y = canvas.height - 60;
    drawPixelNode(x, y, '#E74C3C'); // 栈内节点红色
  });
}
```

---

### 核心代码实现
**Tarjan 缩点核心**：
```cpp
void tarjan(int u) {
    dfn[u] = low[u] = ++idx;
    stk[++top] = u; vis[u] = 1;
    
    for(int v : G[u]) {
        if(!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } 
        else if(vis[v])
            low[u] = min(low[u], dfn[v]);
    }
    
    if(dfn[u] == low[u]) { // SCC 弹出
        scc_cnt++;
        int v;
        do {
            v = stk[top--];
            vis[v] = 0;
            belong[v] = scc_cnt;
        } while(v != u);
    }
}
```

---

### 调试心得分野
**PrincessYR✨～ 的踩坑记录**：  
> 最初误将 `low[u] = min(low[u], low[v])` 写为 `low[u] = min(low[u], dfn[v])`，导致 SCC 划分错误。通过手动画图遍历 DFN/LOW 值变化最终定位问题  

**LMB_001 的顿悟时刻**：  
> 发现并查集合并方向必须与数据流动方向相反：若 A 能传 B，应该让 B 的父节点指向 A 的父节点，才能保证最终根节点为传播起点  

---

### 算法比较演示
**并行可视化方案**：  
- 左半屏：Tarjan 的 DFS 栈动态  
- 右半屏：Floyd 算法的矩阵更新过程  
- 用色块对比两种方法的时间复杂度差异（Tarjan 的 O(N) vs Floyd 的 O(N³)）

**交互控制**：  
```javascript
document.addEventListener('keydown', (e) => {
    if(e.code === 'ArrowLeft') speed = Math.max(100, speed-50); // 减速
    if(e.code === 'ArrowRight') speed = Math.min(1000, speed+50); // 加速
});
```

---
处理用时：86.64秒
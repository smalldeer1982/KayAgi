# 题目信息

# [NOIP2023] 三值逻辑

## 题目描述

小 L 今天学习了 Kleene 三值逻辑。

在三值逻辑中，一个变量的值可能为：真（$\mathit{True}$，简写作 $\mathit{T}$）、假（$\mathit{False}$，简写作 $\mathit{F}$）或未确定（$\mathit{Unknown}$，简写作 $\mathit{U}$）。

在三值逻辑上也可以定义逻辑运算。由于小 L 学习进度很慢，只掌握了逻辑非运算 $\lnot$，其运算法则为：
$$\lnot \mathit{T} = \mathit{F}, \lnot \mathit{F} = \mathit{T}, \lnot\mathit{U} = \mathit{U}.$$

现在小 L 有 $n$ 个三值逻辑变量 $x_1,\cdots, x_n$。小 L 想进行一些有趣的尝试，于是他写下了 $m$ 条语句。语句有以下三种类型，其中 $\leftarrow$ 表示赋值：

1. $x_i \leftarrow v$，其中 $v$ 为 $\mathit{T}, \mathit{F}, \mathit{U}$ 的一种；
2. $x_i \leftarrow x_j$；
3. $x_i \leftarrow \lnot x_j$。

一开始，小 L 会给这些变量赋初值，然后按顺序运行这 $m$ 条语句。

小 L 希望执行了所有语句后，所有变量的最终值与初值都相等。在此前提下，小 L 希望初值中 $\mathit{Unknown}$ 的变量尽可能少。

在本题中，你需要帮助小 L 找到 $\mathit{Unknown}$ 变量个数最少的赋初值方案，使得执行了所有语句后所有变量的最终值和初始值相等。小 L 保证，至少对于本题的所有测试用例，这样的赋初值方案都必然是存在的。

## 说明/提示

**【样例解释 #1】**

第一组测试数据中，$m$ 行语句依次为

- $x_2 \leftarrow \lnot x_1$；
- $x_3 \leftarrow \lnot x_2$；
- $x_1 \leftarrow x_3$。

一组合法的赋初值方案为 $x_1 = \mathit{T}, x_2 = \mathit{F}, x_3 = \mathit{T}$，共有 $0$ 个$\mathit{Unknown}$ 变量。因为不存在赋初值方案中有小于 $0$ 个$\mathit{Unknown}$ 变量，故输出为 $0$。

第二组测试数据中，$m$ 行语句依次为

- $x_2 \leftarrow \lnot x_1$；
- $x_3 \leftarrow \lnot x_2$；
- $x_1 \leftarrow \lnot x_3$。

唯一的赋初值方案为 $x_1 = x_2 = x_3 = \mathit{U}$，共有 $3$ 个$\mathit{Unknown}$ 变量，故输出为 $3$。

第三组测试数据中，$m$ 行语句依次为

- $x_2 \leftarrow \mathit{T}$；
- $x_2 \leftarrow \mathit{U}$；

一个最小化 $\mathit{Unknown}$ 变量个数的赋初值方案为 $x_1 = \mathit{T}, x_2 = \mathit{U}$。$x_1 = x_2 = \mathit{U}$ 也是一个合法的方案，但它没有最小化 $\mathit{Unknown}$ 变量的个数。

**【样例解释 #2】**

该组样例满足测试点 $2$ 的条件。

**【样例解释 #3】**

该组样例满足测试点 $5$ 的条件。

**【样例解释 #4】**

该组样例满足测试点 $8$ 的条件。

**【数据范围】**

对于所有测试数据，保证：

- $1 \le t \le 6$，$1 \le n,m \le 10 ^ 5$；
- 对于每个操作，$v$ 为 `TFU+-` 中的某个字符，$1 \le i,j \le n$。

| 测试点编号 | $n,m\leq$ | $v$ 可能的取值 |
| :----------: | :----------: | :----------: |
| $1,2$ | $10$ | $\mathit{TFU+-}$ |
| $3$ | $10^3$ | $\mathit{TFU}$ |
| $4$ | $10^5$ | $\mathit{TFU}$ |
| $5$ | $10^3$ | $\mathit{U+}$ |
| $6$ | $10^5$ | $\mathit{U+}$ |
| $7$ | $10^3$ | $\mathit{+-}$ |
| $8$ | $10^5$ | $\mathit{+-}$ |
| $9$ | $10^3$ | $\mathit{TFU+-}$ |
| $10$ | $10^5$ | $\mathit{TFU+-}$ |

## 样例 #1

### 输入

```
1 3
3 3
- 2 1
- 3 2
+ 1 3
3 3
- 2 1
- 3 2
- 1 3
2 2
T 2
U 2
```

### 输出

```
0
3
1
```

# AI分析结果



**唯一算法分类**：并查集/图论（基环树）

---

### **题解思路与解决难点**

**核心思路**：  
将变量间赋值关系建模为图结构（并查集或基环树），通过检测环的性质（奇环、自反环）决定变量是否必须为 U。关键点如下：

1. **变量关系抽象**：
   - 每个变量最终值可表示为初值的正/反链式传递（如 `x = ¬y = ¬(¬z) = z`）
   - 用图边权（0/1）或并查集符号（±）表示取反次数

2. **矛盾检测**：
   - **奇环**：环中取反次数为奇数次时，变量无法稳定（必须为 U）
   - **自反环**：变量依赖自身且取反（如 `x = ¬x`）

3. **连通块处理**：
   - U 所在连通块全为 U
   - 存在矛盾的连通块全为 U

**解决难点**：  
- 高效处理大规模变量关系（并查集的路径压缩）
- 符号传递的数学表达（正负号异或）
- 避免环检测时的死循环（DFS 标记或并查集回溯）

---

### **题解评分 (≥4星)**

1. **哈哈人生 (★★★★★)**  
   - **亮点**：通过并查集符号化处理取反，用常量区分 T/F/U  
   - **代码**：简洁高效，路径压缩时处理符号反转  
   - **核心代码**：
     ```cpp
     int find(int x) {
         if (x == T || x == F) return x;
         else if (x < 0) {
             int fx = find(-fa[-x]); // 符号反转传递
             return -fx;
         } else {
             return fa[x] = find(fa[x]);
         }
     }
     ```

2. **August_Light (★★★★☆)**  
   - **亮点**：将 T/F/U 虚拟为节点，用 DFS 判二分图  
   - **代码**：通过边权 0/1 表示取反，逻辑清晰  
   - **核心代码**：
     ```cpp
     void dfs(int u) {
         for (auto [v, w] : G[u]) {
             if (f[v] != (f[u] ^ w)) 
                 is_bi_graph = false; // 发现奇环
         }
     }
     ```

3. **Moeebius (★★★★☆)**  
   - **亮点**：基环树模型，外向边处理版本化赋值  
   - **核心逻辑**：末态初态连边形成基环树，环检测决定 U  
   - **可视化友好**：适合用像素动画展示环的检测过程

---

### **最优思路提炼**

**关键技巧**：  
- **符号化并查集**：用正负表示变量关系，常量 T/F/U 作为特殊值  
- **路径压缩优化**：合并时动态维护符号关系，避免显式建图  
- **矛盾判定**：`find(x) == -find(x)` 或环上异或和为奇数  

**数学表达**：  
- 变量关系为 `x = ±y`，传递时符号相乘  
- 矛盾判定等价于 `±1 * ±1 * ... * ±1 = -1`

---

### **同类型题目推荐**

1. **P1955 [NOI2015] 程序自动分析**（并查集离散化）  
2. **P1525 关押罪犯**（二分图判定）  
3. **P2661 信息传递**（基环树找最小环）

---

### **可视化与算法演示**

**动画设计**：  
1. **像素风格基环树**：  
   - 节点为 8x8 像素方块，颜色区分 T（绿）/F（红）/U（灰）  
   - 边用箭头表示，黑色箭头（正）和白色箭头（反）  

2. **执行步骤**：  
   - **步进合并**：并查集合并时显示符号传递（正负翻转）  
   - **环检测高亮**：检测到矛盾环时，环内节点闪烁红光  
   - **音效**：合并时“哔”声，矛盾时“嗡”声  

3. **交互控制**：  
   - 速度滑块调节合并速度  
   - 点击节点查看其当前符号和父节点  

**代码片段（伪代码）**：  
```javascript
// Canvas 绘制基环树
function drawNode(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x*20, y*20, 16, 16); // 像素风格
}

// 矛盾环检测
function checkCycle() {
  let cur = startNode, sum = 1;
  while (cur = parent[cur]) {
    sum *= sign[cur]; // 符号乘积
    if (cur == startNode && sum == -1) {
      flashRed(); // 红光闪烁
      playSound('error.wav');
    }
  }
}
```

---

### **个人心得摘录**

> “考场上调了好久没调出来，去了 WC 回来立刻调出来了。WC 好闪，拜谢 WC。” —— August_Light  
> **总结**：复杂图论题需冷静分析环性质，考场时间紧张时可先写暴力再优化。

---

### **代码实现（哈哈人生版核心）**

```cpp
const int T=100001, F=-100001, U=0;
int fa[100005];

int find(int x) {
    if (x == T || x == F) return x;
    if (x == U) return U;
    if (x < 0) { // 处理取反
        int fx = find(-fa[-x]);
        return -fx;
    }
    if (fa[x] == x) return x;
    return fa[x] = find(fa[x]); // 路径压缩
}

// 主函数处理赋值
for (int i=1; i<=m; i++) {
    if (op == '-') {
        fa[a] = -b; // 负号表示取反
    } else {
        fa[a] = b;
    }
}

// 统计 U
int ans = 0;
for (int i=1; i<=n; i++) {
    int root = find(i);
    if (root == U || root == -root) ans++;
}
```

---
处理用时：82.39秒
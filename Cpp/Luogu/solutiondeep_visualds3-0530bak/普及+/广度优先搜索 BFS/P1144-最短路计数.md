# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果



# 最短路计数 - 题解分析

## 唯一算法分类
**BFS**

---

## 综合分析与结论
### 核心思路与难点
题目要求在无权无向图中统计从节点1到所有节点的最短路数量。核心思路是**BFS分层遍历**，利用其天然的最短路径特性：
1. **BFS初始化**：起点1的路径数初始化为1，其他节点初始化为0。
2. **队列操作**：每次从队列取出节点u，遍历其邻接节点v：
   - **首次访问v**：更新v的最短距离为u+1，路径数继承u的路径数。
   - **重复访问但距离相等**：累加u的路径数到v。
3. **难点**：正确处理多次访问同一节点的场景，确保路径数累加不重复且时间复杂度可控。

### 算法可视化设计
1. **动画方案**：  
   - **颜色标记**：未访问（白色）、队列中（绿色）、已处理（红色）。  
   - **步进控制**：用户可单步执行，观察队列变化和路径数更新。  
   - **队列状态**：动态展示队列中的节点及其对应的路径数。  
2. **复古游戏化效果**：  
   - **像素风格**：用8位色块表示节点，边用线条连接。  
   - **音效**：访问新节点时播放“滴”声，累加路径数时播放“咔嗒”声。  
   - **自动演示**：AI自动运行BFS，按层次展开节点并高亮当前操作。

---

## 题解清单（≥4星）
### 1. 岸芷汀兰（5星）
- **亮点**：直接使用BFS，代码简洁高效，处理自环和重边清晰。
- **代码片段**：
  ```cpp
  void bfs() {
    queue<Node> q; q.push(make(1, 0));
    memset(d, 0x3f, sizeof(d)); d[1] = 0;
    ans[1] = 1;
    while (!q.empty()) {
      int u = q.front().node; q.pop();
      for (int v : linker[u]) {
        if (!vis[v]) {  // 首次访问
          q.push(make(v, dis + 1)); 
          d[v] = d[u] + 1; ans[v] = ans[u];
        } else if (d[v] == d[u] + 1) {  // 重复访问且距离相同
          ans[v] += ans[u]; ans[v] %= mod;
        }
      }
    }
  }
  ```

### 2. ZiDing_ByronFinlso（4星）
- **亮点**：提供SPFA和Dijkstra两种实现，适合理解不同算法的适用场景。
- **关键代码**：
  ```cpp
  // SPFA版本
  if (d[y] > d[x] + 1) {  // 松弛操作
    d[y] = d[x] + 1; ans[y] = ans[x];
    q.push(y);
  } else if (d[y] == d[x] + 1) {  // 累加路径数
    ans[y] += ans[x]; ans[y] %= mod;
  }
  ```

### 3. George1123（4星）
- **亮点**：二次处理（先SPFA求最短路，再记忆化搜索统计路径数），通用性强。
- **代码思路**：
  ```cpp
  int dfs(int u) {
    if (ans[u]) return ans[u];
    for (int v : adj[u]) {
      if (dis[u] == dis[v] + 1)  // 反向搜索最短路径图
        ans[u] = (ans[u] + dfs(v)) % mod;
    }
    return ans[u];
  }
  ```

---

## 最优思路提炼
1. **BFS分层遍历**：按层次展开节点，保证首次访问即为最短路径。
2. **路径数动态更新**：
   - 首次访问：`ans[v] = ans[u]`
   - 重复访问：`ans[v] += ans[u] (mod 100003)`
3. **数据结构**：队列维护待处理节点，邻接表存储图结构。

---

## 同类型题目
1. **P1608 路径统计**（带权图最短路计数）
2. **P2296 寻找道路**（BFS预处理+最短路）
3. **P3393 逃离僵尸岛**（BFS分层+优先队列）

---

## 可视化代码片段（复古风格）
```javascript
// 初始化Canvas
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
const nodes = [/* 节点坐标 */];
let queue = [1], visited = new Set([1]);

function drawNode(id, color) {
  ctx.fillStyle = color;
  ctx.fillRect(nodes[id].x, nodes[id].y, 16, 16); // 16x16像素块
}

function animateBFS() {
  if (queue.length === 0) return;
  let u = queue.shift();
  drawNode(u, '#FF0000'); // 当前节点标记为红色
  for (let v of adj[u]) {
    if (!visited.has(v)) {
      visited.add(v);
      queue.push(v);
      drawNode(v, '#00FF00'); // 新节点入队，绿色
      playSound('beep'); // 播放音效
    }
  }
  setTimeout(animateBFS, 500); // 每0.5秒执行一步
}
```

---

## 个人心得摘录
> “BFS天然保证最短路径，路径数只需继承或累加前驱节点，无需复杂DP。”（岸芷汀兰）  
> “SPFA在无权图中退化为BFS，但需注意队列的重复入队逻辑。”（ZiDing_ByronFinlso）

---
处理用时：89.61秒
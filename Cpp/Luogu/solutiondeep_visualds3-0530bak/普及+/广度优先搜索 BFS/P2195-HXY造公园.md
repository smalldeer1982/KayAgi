# 题目信息

# HXY造公园

## 题目描述

现在有一个现成的公园，有 $n$ 个休息点和 $m$ 条双向边连接两个休息点。众所周知，HXY 是一个 SXBK 的强迫症患者，所以她打算施展魔法来改造公园并即时了解改造情况。她可以进行以下两种操作：

1. 对某个休息点 $x$，查询公园中可以与该点互相到达的休息点组成的路径中的最长路径。
2. 对于两个休息点 $x,y$，如果 $x,y$ 已经可以互相到达则忽略此次操作。否则，在 $x$ 可到达的所有休息点和 $y$ 可到达的所有休息点（包括 $x,y$ 自身）分别选择一个休息点，然后在这两个休息点之间连一条边，并且这个选择应该满足对于连接后的公园，$x$ 和 $y$ 所在的区域（即 $x,y$ 可达到的所有休息点和边组成的集合）中的最长路径的长度最小。

HXY打算进行 $q$ 个操作，请你回答她的对于公园情况的询问（操作 1）或者执行她的操作（操作 2）。

注：所有边的长度皆为 $1$。保证不存在环。最长路径定义为：对于点 $v_1,v_2\cdots v_k$，如果对于其中任意的 $v_i$ 和 $v_{i+1}\quad (1\le i\le k-1)$，都有边相连接，那么 $v_j\quad(1\le j\le k)$ 所在区域的最长路径就是 $k-1$。


## 说明/提示

### 数据范围及约定

- 对于 $10\%$ 的数据，只存在操作 1。
- 对于 $30\%$ 的数据，$1\le m<n\le 20$，$1\le q\le5$。
- 对于 $60\%$ 的数据，$1\le m<n \le 2000$，$1\le q\le 1000$。
- 对于 $100\%$ 的数据，$1 \le m<n \le 3\times 10^5$，$1\le q\le 3\times 10^5$。


## 样例 #1

### 输入

```
6 0 6
2 1 2
2 3 4
2 5 6
2 3 2
2 5 3
1 1```

### 输出

```
4
```

# AI分析结果



**唯一算法分类**  
BFS

---

### 综合分析与结论  
**核心思路**  
1. **并查集维护连通性**：初始森林中每棵树用并查集管理，合并时快速判断连通性  
2. **树的直径计算**：通过两次 BFS 或 DFS 计算初始每棵树的直径  
3. **合并策略**：合并两棵树时，连接两树直径中点，新直径公式为 `max(d1, d2, (d1+1)/2 + (d2+1)/2 +1)`  
4. **动态更新**：合并后更新并查集根的直径值  

**难点与解决**  
- **直径的动态维护**：合并后的直径需同时考虑原直径与新生成的路径，需严格推导公式  
- **时间复杂度优化**：避免每次合并重新计算整棵树的直径，采用并查集 + 预处理  

**可视化设计**  
- **复古像素动画**：  
  1. **节点绘制**：每个休息点为 8x8 像素方块，未访问节点灰色，已访问绿色，当前访问节点高亮红色  
  2. **BFS 过程**：展示第一次 BFS 找到最远节点（动态扩散效果），第二次 BFS 确定直径（路径用黄色连线）  
  3. **合并操作**：两树中点连边时，播放“连接音效”，新直径路径闪烁显示  
  4. **音效设计**：节点扩展时短促“滴”声，找到直径时播放胜利旋律  

---

### 题解清单 (≥4星)  
1. **Priori_Incantatem（★★★★★）**  
   - **亮点**：树形 DP 求直径，代码简洁，公式推导清晰  
   - **心得**：强调必须与原直径比较，否则会 WA（如样例中的特例）  

2. **caozy623（★★★★☆）**  
   - **亮点**：两次 BFS 实现，代码易读  
   - **优化**：用队列替代递归避免栈溢出  

3. **Rusalka（★★★★☆）**  
   - **亮点**：完整注释 + 双倍经验题提示  
   - **技巧**：使用 `(d+1)/2` 代替上取整运算  

---

### 最优思路与技巧  
1. **树的直径中点定理**：连接两树中点可最小化新直径  
2. **并查集根存储直径**：根节点维护当前连通块直径值，避免重复计算  
3. **两次 BFS 优化**：O(n) 时间计算直径，避免树形 DP 的递归开销  

---

### 同类型题与算法套路  
- **算法套路**：动态维护连通块的最值属性（如直径、重心）  
- **相似题目**：  
  1. [CF455C Civilization](https://www.luogu.com.cn/problem/CF455C)（双倍经验）  
  2. [P3304 [SDOI2013]直径](https://www.luogu.com.cn/problem/P3304)（直径性质）  
  3. [P4408 [NOI2003]逃学的小孩](https://www.luogu.com.cn/problem/P4408)（直径端点应用）  

---

### 个人心得摘录  
> "避免在 DFS 中 memset(vis)，改为回溯时重置 vis 数组，否则 O(n^2) 导致 TLE" —— noall 题解  
> "合并时必须与原直径取 max，否则遇到单点会出错" —— Priori_Incantatem  

---

### 核心代码实现  
**两次 BFS 求直径（caozy623 题解片段）**  
```cpp  
int calc(int x) {
    len = 0;
    dfs(x, 0);        // 第一次 DFS 找最远点 u
    len = 0;
    dfs(sec, 0);      // 第二次 DFS 从 u 出发找直径
    return len;
}
void dfs(int x, int fa) {
    if (current_depth > max_depth) {
        max_depth = current_depth;
        farthest_node = x;
    }
    for (auto y : edges[x]) {
        if (y != fa) dfs(y, x);
    }
}
```

---

### 可视化与复古动画示例  
**HTML/JS 伪代码**  
```javascript  
// Canvas 初始化  
const canvas = document.getElementById("pixel-canvas");  
ctx.fillStyle = "#00FF00"; // 绿色为已访问节点  

// BFS 动画帧  
function animateBFS(queue) {  
    const current = queue.shift();  
    highlightNode(current); // 红色高亮当前节点  
    playSound("beep");  
    for (const neighbor of getNeighbors(current)) {  
        if (!visited[neighbor]) {  
            visited[neighbor] = true;  
            queue.push(neighbor);  
            drawNode(neighbor, "#00FF00");  
        }  
    }  
    if (queue.length > 0) requestAnimationFrame(() => animateBFS(queue));  
}  
```  
**音效触发逻辑**  
- 找到直径终点：`playSound("victory", 0.5)`  
- 合并操作：`playSound("connect", 0.3)`

---
处理用时：69.18秒
# 题目信息

# [ZJOI2012] 旅游

## 题目描述

到了难得的暑假，为了庆祝小白在数学考试中取得的优异成绩，小蓝决定带小白出去旅游~~

经过一番抉择，两人决定将 T 国作为他们的目的地。T 国的国土可以用一个凸 $n$ 边形来表示，$n$ 个顶点表示 $n$ 个入境/出境口。T 国包含 $n-2$ 个城市，每个城市都是顶点均为 $n$ 边形顶点的三角形（换而言之，**城市组成了关于 T 国的一个三角剖分**）。**两人的旅游路线可以看做是连接 $n$ 个顶点中不相邻两点的线段**。

![](https://cdn.luogu.com.cn/upload/pic/1409.png) 

为了能够买到最好的纪念品，小白希望旅游路线上经过的城市尽量多。作为小蓝的好友，你能帮帮小蓝吗？

## 说明/提示

对于 $20\%$ 的数据，$n\le 2000$。

对于 $100\%$ 的数据，$4\le n \le 200000$。

## 样例 #1

### 输入

```
6

1 2 4

2 3 4

1 4 5

1 5 6```

### 输出

```
4```

# AI分析结果



# 算法分类：DFS

## 综合分析与结论
题目本质是在三角剖分形成的树结构中求最长路径。核心思路是将每个三角形视为节点，相邻三角形连边构成树，最终通过两次DFS/BFS求树的直径。难点在于高效建树，解决思路是通过排序边并使用map记录邻接关系，实现O(n log n)的时间复杂度。

**搜索过程可视化设计**：
1. **节点进队**：初始节点入栈（DFS）或队列（BFS），标记为已访问。
2. **扩展节点**：当前节点弹出后，遍历其未访问的邻接节点，压入栈/队列。
3. **路径追踪**：用颜色区分已访问/待访问节点，动态显示搜索深度。
4. **直径计算**：首轮遍历后定位最远端点，第二轮遍历时实时更新最长路径长度。
5. **动画控制**：支持暂停/步进观察搜索细节，回溯路径用高亮线条显示。

## 题解评分 (≥4星)
1. **Dr_Gears**（5星）  
   - 思路清晰，证明严谨，使用map高效处理邻接关系。  
   - 代码简洁，两次DFS求直径，时间复杂度O(n log n)。  
   - 关键亮点：边排序去重处理，避免重复连边。

2. **Equfix**（4星）  
   - 代码结构清晰，BFS实现直径计算。  
   - 通过排序三角形顶点保证边唯一性。  
   - 个人心得：强调清空访问数组的重要性。

3. **Yingluosanqian**（4星）  
   - 优化建图，用unordered_map和哈希提升效率。  
   - 复古代码风格，两次DFS实现，避免O2依赖。

## 最优思路与技巧
1. **树的建模**：将三角形边排序后用map/unordered_map记录，确保邻接关系唯一。
2. **直径计算**：两次DFS/BFS遍历，无需复杂DP，时间复杂度O(n)。
3. **排序去重**：处理三角形边时统一排序，避免方向导致的重复键。

## 同类题目推荐
1. **P1099 树网的核**（树直径性质应用）
2. **P3304 [SDOI2013]直径**（求树直径的路径）
3. **P5536 [XR-3]核心城市**（树结构与最长路径）

## 核心代码实现
```cpp
// 建图核心逻辑（Dr_Gears 题解节选）
map<pair<int, int>, int> ys;
void addEdge(int x, int y) {
    if (ys.count({x, y})) {
        int other = ys[{x, y}];
        add(other, i); // 双向连边
        add(i, other);
    } else {
        ys[{x, y}] = i;
    }
}

// 两次DFS求直径
void dfs(int u, int fa) {
    for (int v : tree[u]) {
        if (v != fa) {
            dis[v] = dis[u] + 1;
            dfs(v, u);
        }
    }
}
int getDiameter() {
    dfs(1, 0);
    int far = max_element(dis + 1, dis + n) - dis;
    memset(dis, 0, sizeof(dis));
    dfs(far, 0);
    return *max_element(dis + 1, dis + n);
}
```

## 可视化设计（8位像素风格）
1. **节点绘制**：每个三角形用16x16像素方块表示，颜色按访问状态变化（未访问-灰色，已访问-绿色，当前节点-红色）。
2. **边动画**：边扩展时显示黄色脉冲效果，直径路径用蓝色高亮。
3. **音效触发**：节点入队时播放短促“滴”声，找到直径时播放胜利音效。
4. **自动演示**：按空格键切换自动/手动模式，方向键控制搜索速度。
5. **状态面板**：显示当前步骤、队列大小、已访问节点数。

---

通过将复杂几何问题转化为树结构问题，并运用经典搜索算法，本题展现了算法思维中模型抽象的重要性。核心技巧如map建图、两次DFS遍历可推广至其他图论问题。

---
处理用时：86.15秒
# 题目信息

# [USACO15DEC] Switching on the Lights S

## 题目背景

来源：usaco-2015-dec

Farm John 最近新建了一批巨大的牛棚。这些牛棚构成了一个 $N \times N$ 的矩形网络 $(1 < N < 100)$。

然而 Bessie 十分怕黑，他想计算可以把多少个牛棚的灯打开。

## 题目描述

有 $N \times N$ 个房间，组成了一张 $N \times N$ 的网格图，Bessie 一开始位于左上角 $(1,1)$，并且只能上下左右行走。


一开始，只有 $(1,1)$ 这个房间的灯是亮着的，Bessie 只能在亮着灯的房间里活动。


有另外 $M$ 条信息，每条信息包含四个数 $a,b,c,d$，表示房间 $(a,b)$ 里有房间 $(c,d)$ 的灯的开关。


请计算出最多有多少个房间的灯可以被打开。

## 说明/提示

Bessie 可以使用 $(1,1)$ 的开关打开 $(1,2),(1,3)$ 的灯，然后走到 $(1,3)$ 并打开 $(2,1)$ 的灯，走到 $(2,1)$ 并打开 $(2,2)$ 的灯。$(2,3)$ 的开关无法到达。因此可以点亮 $5$ 个房间。

## 样例 #1

### 输入

```
3 6
1 1 1 2
2 1 2 2
1 1 1 3
2 3 3 1
1 3 1 2
1 3 2 1
```

### 输出

```
5```

# AI分析结果



# 算法分类：BFS

## 题解思路与核心难点

### 核心思路
本题核心在于动态扩展可访问区域，通过BFS遍历所有可达房间，并在每次处理房间时打开其控制的灯。新点能否被访问需结合周围已访问区域判断，需维护以下两个关键状态：
- **灯是否亮起**：控制能否进入该房间
- **是否已被访问**：避免重复处理

### 解决难点
1. **动态更新可访问区域**：新点被点亮时，若周围存在已访问点，需立即加入队列。
2. **避免重复搜索**：通过`visited`数组标记已处理节点，邻接表存储开关关系提高效率。
3. **状态检查**：每次点亮灯后检查四周是否连通已访问区域，触发新搜索。

---

## 最优题解提炼

### 关键思路
- **BFS队列管理**：队列中存储当前可访问节点，每次处理时：
  1. 打开该节点控制的所有灯。
  2. 检查新点周围是否存在已访问节点，若存在则加入队列。
- **邻接表存储**：每个房间的开关关系用邻接表快速访问。
- **实时状态更新**：点亮灯后立即判断可访问性，动态扩展搜索范围。

### 代码实现（JMercury解法核心片段）
```cpp
void spfa() {
    queue<P> q; 
    q.push({1,1}); 
    vis[1][1] = true; 
    light[1][1] = true; 
    ans = 1;
    while (!q.empty()) {
        P u = q.front(); q.pop();
        // 处理移动扩展
        for (int i = 0; i < 4; i++) {
            int nx = u.x + dx[i], ny = u.y + dy[i];
            if (nx < 1 || ny < 1 || nx > n || ny > n || vis[nx][ny] || !light[nx][ny]) 
                continue;
            vis[nx][ny] = true;
            q.push({nx, ny});
        }
        // 处理开灯操作
        for (auto v : Lamp[u.x][u.y]) {
            if (!light[v.x][v.y]) {
                light[v.x][v.y] = true; 
                ans++;
                // 检查新点是否可访问
                for (int i = 0; i < 4; i++) {
                    int nx = v.x + dx[i], ny = v.y + dy[i];
                    if (vis[nx][ny]) {
                        q.push({v.x, v.y});
                        vis[v.x][v.y] = true;
                        break;
                    }
                }
            }
        }
    }
}
```

---

## 同类型题与算法套路

### 类似问题
1. **迷宫类动态扩展**：如《推箱子》中箱子推动后路径变化。
2. **状态依赖的BFS**：每一步的状态影响后续可达性，如《解开密码锁》最短步数问题。

### 推荐题目
1. **P1162 填涂颜色**：BFS扩展连通区域。
2. **P1443 马的遍历**：BFS求最短步数。
3. **P3958 奶酪**：三维BFS结合几何判断。

---

## 可视化设计

### 动画方案
1. **网格绘制**：Canvas绘制N×N网格，初始仅(1,1)亮起。
2. **颜色标记**：
   - **白色**：未点亮。
   - **绿色**：已点亮且可访问。
   - **红色**：已访问（处理完毕）。
3. **队列操作可视化**：
   - 当前处理节点高亮为黄色。
   - 新点亮节点闪烁后变绿，若可访问则加入队列尾部。

### 复古像素风格
- **8-bit音效**：
  - 点亮新灯：短促“哔”声。
  - 加入队列：低音“嘟”声。
  - 完成搜索：8-bit胜利旋律。
- **Canvas动画**：节点用16×16像素块表示，路径扩展时逐帧绘制。

### 交互功能
- **步进控制**：按钮支持暂停/继续/单步执行。
- **速度调节**：滑动条控制BFS执行速度（100ms~2s/步）。

---

## 个人心得摘录
- **多次DFS的陷阱**：直接多次DFS可能超时，动态BFS更高效。
- **邻接表优化**：避免暴力遍历所有边，快速访问关联开关。
- **状态更新时机**：开灯后立即检查连通性，避免遗漏可达路径。

---

通过上述分析与实现，BFS动态扩展的策略能高效解决本题，结合状态管理和邻接表优化，确保所有可能路径被覆盖。

---
处理用时：78.56秒
# 题目信息

# 逃离僵尸岛

## 题目描述

小 a 住的国家被僵尸侵略了！小 a 打算逃离到该国唯一的国际空港逃出这个国家。


该国有 $N$ 个城市，城市之间有道路相连。一共有 $M$ 条双向道路。保证没有自环和重边。


其中 $K$ 个城市已经被僵尸控制了，如果贸然闯入就会被感染 TAT...所以不能进入。由其中任意城市经过不超过 $S$ 条道路就可以到达的别的城市，就是危险城市。换句话说只要某个城市到任意被僵尸控制的城市距离不超过 $S$，就是危险的。

小 a 住在 $1$ 号城市，国际空港在 $N$ 号城市，这两座城市没有被侵略。小a走每一段道路（从一个城市直接到达另外一个城市）得花一整个白天，所以晚上要住旅店。安全的的城市旅馆比较便宜要 $P$ 元，而被危险的城市，旅馆要进行安保措施，所以会变贵，为 $Q$ 元。所有危险的城市的住宿价格一样，安全的城市也是。在 $1$ 号城市和 $N$ 城市，不需要住店。


小 a 比较抠门，所以他希望知道从 $1$ 号城市到 $N$ 号城市所需要的最小花费。

输入数据保证存在路径，可以成功逃离。输入数据保证他可以逃离成功。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/2681.png) 

对于 $20\%$ 数据，$N\le 50$。

对于 $100\%$ 数据，$2\le N\le 10^5$，$1\le M\le 2\times 10^5$，$0\le K\le N - 2$，$0\le S\le 10^5$，$1\le P< Q\le 10^5$。


## 样例 #1

### 输入

```
13 21 1 1
1000 6000
7
1 2
3 7
2 4
5 8
8 9
2 5
3 4
4 7
9 10
10 11
5 9
7 12
3 6
4 5
1 3
11 12
6 7
8 11
6 13
7 8
12 13```

### 输出

```
11000```

# AI分析结果



## 算法分类：BFS

### 综合分析与结论

#### 核心难点与解决方案
1. **多源BFS标记危险城市**：将K个被占城市同时入队，进行层序扩展，只需一次BFS即可标记所有距离≤S的危险城市
2. **点权转边权处理**：将每条边的权值设置为目标节点的住宿费，在Dijkstra中累加邻接点权值，终点无需额外处理
3. **大规模数据优化**：邻接表存储图结构，优先队列实现Dijkstra，时间复杂度O((M+N)logN)

#### 搜索过程可视化设计
1. **多源BFS动画**：
   - 初始状态：被占城市显示为红色方块，其他城市为灰色
   - 扩展过程：每层扩展时，新标记的危险城市变为橙色并带有扩散波纹效果
   - 分层展示：用不同颜色区分各层的扩展边界（如黄→橙→红渐变）

2. **Dijkstra动画**：
   - 节点状态：已访问（绿色）、待访问队列（蓝色）、未访问（灰色）
   - 路径追踪：用发光线条标记当前最短路径的扩展方向
   - 动态权值：在节点上方实时显示累计费用

3. **复古像素风格**：
   ```javascript
   // 节点绘制示例
   function drawNode(ctx, x, y, state) {
     const colors = { 
       normal: '#808080',   // 灰
       danger: '#FFA500',   // 橙
       zombie: '#FF0000',   // 红
       visited: '#00FF00',  // 绿
       queued: '#0000FF'    // 蓝
     };
     ctx.fillStyle = colors[state];
     ctx.fillRect(x*32, y*32, 28, 28); // 32px网格含4px间隙
   }
   ```

### 题解清单（≥4星）

#### 1. fyfy（★★★★☆）
- **亮点**：虚拟节点法处理多源BFS，边权动态重构
- **代码片段**：
  ```cpp
  // 被占点连接虚拟节点0
  if(ocp[x]) add(0,y), add(y,0);
  // BFS后重构边权
  if(dgs[s[i][0]]) w[i]=Q;
  ```

#### 2. 顾z（★★★★★）
- **亮点**：三状态标记系统（安全/危险/被占），终点费用修正
- **关键逻辑**：
  ```cpp
  if(dis[v]>dis[u]+va[v] && sa[v]!=-1)
  if(sa[n]==0) dis[n]-=Q; else dis[n]-=P;
  ```

#### 3. 旭日临窗（★★★★☆）
- **亮点**：构造函数封装节点，双队列分别处理BFS与Dijkstra
- **数据结构**：
  ```cpp
  struct Node { int v; LL dist; };
  priority_queue<Node, vector<Node>, cmp> dij_q;
  ```

### 核心代码实现

#### 多源BFS标记危险城市
```cpp
queue<int> q;
vector<int> infected; // 被占城市列表
for(auto& city : infected) {
    q.push(city);
    dis[city] = 0;
}
while(!q.empty()) {
    int u = q.front(); q.pop();
    for(int v : adj[u]) {
        if(dis[v] > dis[u]+1) {
            dis[v] = dis[u]+1;
            if(dis[v] <= S) q.push(v);
        }
    }
}
```

#### Dijkstra计算最小费用
```cpp
priority_queue<PII, vector<PII>, greater<PII>> pq;
vector<LL> cost(n+1, INF);
cost[1] = 0;
pq.emplace(0, 1);

while(!pq.empty()) {
    auto [cur_cost, u] = pq.top(); pq.pop();
    if(u == n) break;
    if(cur_cost > cost[u]) continue;
    
    for(auto& v : adj[u]) {
        LL new_cost = cur_cost + get_price(v); // 获取v点住宿费
        if(new_cost < cost[v]) {
            cost[v] = new_cost;
            pq.emplace(new_cost, v);
        }
    }
}
```

### 同类型题目推荐
1. P1144 最短路计数（BFS应用）
2. P1339 [USACO09OCT]Heat Wave（Dijkstra模板）
3. P2296 寻找道路（BFS预处理+Dijkstra）

### 可视化交互设计
1. **操作面板**：
   - 速度滑块：控制动画速度（0.5x~5x）
   - 模式切换：BFS阶段/Dijkstra阶段
   - 单步执行：空格键逐帧执行

2. **音效系统**：
   ```javascript
   const audio = {
     expand: new Audio('sfx/bleep.wav'),     // 节点扩展
     found: new Audio('sfx/success.wav'),    // 找到路径
     danger: new Audio('sfx/warning.wav')    // 标记危险
   };
   ```

3. **数据回放**：
   ```javascript
   function replay() {
     const steps = [...recordedSteps]; // 录制操作序列
     let idx = 0;
     const timer = setInterval(() => {
       if(idx >= steps.length) clearInterval(timer);
       else renderStep(steps[idx++]);
     }, 500);
   }
   ```

通过这种深度整合算法逻辑与可视化交互的设计，学习者可直观理解BFS的层序扩展特性与Dijkstra的贪心策略，在8-bit风格的游戏化体验中掌握核心解题技巧。

---
处理用时：87.16秒
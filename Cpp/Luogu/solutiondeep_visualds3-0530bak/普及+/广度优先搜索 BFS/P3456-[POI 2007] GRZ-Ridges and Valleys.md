# 题目信息

# [POI 2007] GRZ-Ridges and Valleys

## 题目描述

**译自 POI 2007 Stage 2. Day 0「[Ridges and Valleys](https://szkopul.edu.pl/problemset/problem/rd6H05Dm8ME79sO3U9_f_ga_/site/?key=statement)」**

给定一个 $n \times n$ 的网格状地图，每个方格 $(i,j)$ 有一个高度 $w_{ij}$。如果两个方格有公共顶点，则它们是相邻的。

定义山峰和山谷如下：
* 均由地图上的一个连通块组成；
* 所有方格高度都相同；
* 周围的方格（即不属于山峰或山谷但与山峰或山谷相邻的格子）高度均大于山谷的高度，或小于山峰的高度。

求地图内山峰和山谷的数量。特别地，如果整个地图方格的高度均相同，则整个地图既是一个山谷，也是一个山峰。

## 样例 #1

### 输入

```
5
8 8 8 7 7
7 7 8 8 7
7 7 7 7 7
7 8 8 7 8
7 8 8 8 8```

### 输出

```
2 1```

## 样例 #2

### 输入

```
5
5 7 8 3 1
5 5 7 6 6
6 6 6 2 8
5 7 2 5 8
7 1 0 1 7```

### 输出

```
3 3```

# AI分析结果



### 唯一算法分类
**BFS / DFS / 其他搜索**  
（核心为连通块的遍历与条件判断，BFS 和 DFS 均可实现）

---

### 综合分析与结论
#### 核心思路
1. **连通块遍历**：所有题解均通过 BFS/DFS 遍历高度相同的连通块。
2. **条件判断**：在遍历过程中，检查周围八个方向的格子，判断是否存在更高或更低的区域：
   - 若周围全更高 → 山谷；若周围全更低 → 山峰。
   - 若同时存在更高和更低 → 既非山峰也非山谷。
3. **特判处理**：所有格子高度相同时，整个地图既是山峰又是山谷。

#### 解决难点
- **八方向检查**：容易误判为四方向（如李尧的题解提到因此 WA 多次）。
- **状态冲突判断**：需高效记录周围是否存在更高/更低区域（如 FCBM71 的布尔变量法）。
- **递归爆栈风险**：DFS 在网格较大时可能栈溢出（如 lhhh 的题解改用 BFS）。

#### 可视化设计要点
1. **网格动画**：用 Canvas 绘制网格，不同颜色标记：
   - 白色：未访问节点；
   - 蓝色：已访问节点；
   - 红色：当前处理节点；
   - 绿色/黄色：周围更高/更低的节点。
2. **步进控制**：允许单步执行，观察队列/栈的扩展过程。
3. **音效提示**：
   - 发现矛盾时播放短促“错误”音效；
   - 确认山峰/山谷时播放“成功”音效。
4. **复古像素风格**：用 8-bit 调色板，网格节点以方块形式呈现，类似经典迷宫游戏。

---

### 题解评分 (≥4星)
| 题解作者 | 评分 | 关键亮点 |
|---------|------|----------|
| 李尧     | ★★★★☆ | 详细注释、边界处理完善，特判逻辑清晰 |
| FCBM71  | ★★★★★ | 简洁双布尔变量法，逻辑高效易扩展 |
| sounds_666 | ★★★★☆ | 分离山峰/山谷判断函数，代码结构清晰 |

---

### 最优思路与技巧
#### 关键技巧
1. **双布尔标记法**（FCBM71）：
   ```cpp
   bool ifhigh = 1, iflow = 1;  // 初始假设是山峰和山谷
   for (每个相邻节点) {
       if (更高) ifhigh = 0;     // 不能是山峰
       if (更低) iflow = 0;      // 不能是山谷
   }
   if (ifhigh) ans1++;          // 确认山峰
   if (iflow) ans2++;           // 确认山谷
   ```
2. **BFS 队列优化**（李尧）：
   - 起点和每个新节点均检查周围，发现矛盾后停止后续判断。
3. **特判全相同高度**：提前遍历地图检查是否全相同。

#### 思维突破点
- **矛盾提前终止**：一旦发现周围同时存在更高和更低区域，立即标记该连通块无效，减少后续计算。

---

### 同类型题推荐
1. **P1141 01迷宫**（统计连通块大小，BFS/DFS 基础）
2. **P1162 填涂颜色**（BFS 扩展边界标记）
3. **P3958 奶酪**（三维连通块判断，BFS 变形）

---

### 个人心得摘录
- **李尧**：WA 五次后意识到八方向检查的疏漏，起点需单独判断周围。
- **lhhh**：DFS 在评测机爆栈，改用 BFS 后通过，强调递归深度风险。
- **御坂10027号**：误将问题视为求极值数量，后修正为连通块条件判断。

---

### 核心代码实现（FCBM71 的布尔标记法）
```cpp
void bfs(int x, int y) {
    queue<pair<int, int>> q;
    q.push({x, y});
    vis[x][y] = true;
    bool ifhigh = true, iflow = true;  // 初始假设是山峰和山谷

    while (!q.empty()) {
        auto [cx, cy] = q.front(); q.pop();
        for (int i = 0; i < 8; i++) {
            int nx = cx + dx[i], ny = cy + dy[i];
            if (nx < 0 || ny < 0 || nx >= n || ny >= n) continue;

            if (grid[nx][ny] == grid[x][y] && !vis[nx][ny]) {
                vis[nx][ny] = true;
                q.push({nx, ny});
            } else if (grid[nx][ny] > grid[x][y]) {
                ifhigh = false;  // 周围有更高，不是山峰
            } else if (grid[nx][ny] < grid[x][y]) {
                iflow = false;   // 周围有更低，不是山谷
            }
        }
    }

    if (ifhigh) ridge++;
    if (iflow) valley++;
}
```

---

### 可视化算法演示（BFS 示例）
1. **初始化**：起点 (红色) 加入队列，周围八方向检查。
2. **扩展节点**：队列头部节点出队，检查相邻节点：
   - 同高度节点入队（蓝色标记）；
   - 不同高度更新 `ifhigh` 和 `iflow`。
3. **矛盾检测**：若发现 `ifhigh` 和 `iflow` 均为 false，立即终止动画并提示。
4. **结果展示**：连通块遍历完成后，高亮显示山峰（绿色）或山谷（黄色）。

**复古像素效果**：  
- 使用 `16x16` 像素网格，节点用 32x32 像素块渲染。
- 背景音乐：8-bit 风格循环音轨，节点访问时触发“哔”声。

---
处理用时：124.71秒
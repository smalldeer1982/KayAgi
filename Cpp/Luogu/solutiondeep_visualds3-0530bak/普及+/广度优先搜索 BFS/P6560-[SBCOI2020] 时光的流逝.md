# 题目信息

# [SBCOI2020] 时光的流逝

## 题目背景

时间一分一秒的过着，伴随着雪一同消融在了这个冬天，  
或许，要是时光能停留在这一刻，该有多好啊。  
......    
“这是...我在这个小镇的最后一个冬天了吧。”  
“嗯，你可不能这辈子都呆在这个小镇吧。外面的世界很大呢，很大很大...”  
“唔...外面的世界...突然有点期待呢！”  
“总有一天，你会走得很远很远。以后你可不要忘记这个小镇那。”  
“不会的，至少...这里曾经是我最快乐的一段回忆呢！你也一定不要忘记我呀。”   
“你看，这雪花。传说，每当世界上有一份思念，便会化成一片雪花在这里飘落。”   
“那...以后你可一定要找到我的那片雪花啊......”  
![](https://cdn.luogu.com.cn/upload/image_hosting/orzntcy6.png)    
“嗯，不如我们一起在这个冬天创造最后一段回忆吧。”  
“好呀，我们玩个游戏吧......”  

## 题目描述

这个游戏是在一个有向图（不保证无环）上进行的。每轮游戏开始前，她们先在图上选定一个起点和一个终点，并在起点处放上一枚棋子。

然后两人轮流移动棋子，每次可以将棋子按照有向图的方向移动至相邻的点。

如果谁先将棋子移动至终点，那么谁就胜利了。同样，如果谁无法移动了，那么谁就失败了。

两人轮流操作，请问，他们是否有必胜策略呢？  

答案为一个整数 `0` 或 `1` 或 `-1`，其中 `1` 表示（先手）有必胜策略，`-1` 表示后手有必胜策略，`0` 表示两人均无必胜策略。

## 说明/提示

#### 样例解释 $#1$

![](https://cdn.luogu.com.cn/upload/image_hosting/k7q0qjrb.png)

为描述题意，假设两人为 A（先手）和 B

如图，A 先走，走到 $2$，B 走到 $3$，接下去 A 可以选择走到 $4$ 或 $6$，若走到 $4$，接下去 B 可以走到终点，故不可取。若选择走到 $6$，那么 B 只能走到 $7$，A 可以走到终点。所以 A 有必胜策略。

#### 样例解释 $#2$

![](https://cdn.luogu.com.cn/upload/image_hosting/9yjnyye3.png)

如图，起点为 $1$，终点为 $5$ 时， A 和 B 会沿着 $1-2-3-1$ 的顺序轮流走。因为如果谁先走到 $4$，那么下一个人就可以走到终点。故谁都没有必胜策略。

起点为 $4$，终点为 $3$ 时，A 先走到 $5$，B 无路可走，故 B 失败。

#### 数据范围

对于 $10\%$ 的数据，保证图是一条链。

对于 $50\%$ 的数据，$1\leq n\leq 10^3$，$1\leq m\leq 2\times10^3$，$1\leq q\leq 10$。

对于 $70\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 2\times10^5$，$1\leq q\leq 10$。

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 5\times10^5$，$1\leq q\leq 500$。

## 样例 #1

### 输入

```
7 7 1
1 2
2 3
3 4
4 5
3 6
7 5
6 7
1 5```

### 输出

```
1```

## 样例 #2

### 输入

```
5 5 2
1 2
2 3
3 1
3 4
4 5
1 5
4 3```

### 输出

```
0
1```

# AI分析结果



# 算法分类：BFS

## 题解思路、算法要点与解决难点

### 核心思路
本题是基于博弈论与拓扑排序结合的图论问题。核心是通过反向建图+拓扑排序，确定每个节点的必胜/必败状态：

1. **状态定义**：  
   - 终点和出度为0的节点为必败态（返回-1）  
   - 能一步到达必败态的节点为必胜态（返回1）  
   - 无法确定状态的节点（存在环且无法推导出胜负）返回0

2. **反向建图**：  
   通过建立反向图（原图的边反向），从终点和出度为0的节点开始状态传递。例如原图边A→B在反向图中变为B←A，使得可以从已知状态的节点反向推导其前驱节点状态。

3. **拓扑排序+BFS**：  
   维护队列处理节点状态，当节点状态确定后，通过反向边更新其前驱节点状态。通过维护入度数组判断是否所有子节点状态已确定，从而处理环的情况。

### 解决难点
1. **环的处理**：  
   当节点处于环中且无法被必胜/必败态推导时，返回0。通过拓扑排序后未被标记的节点即为环内节点，此时双方可能无限循环。

2. **状态传递规则**：  
   - 若当前节点是必败态（-1），其所有前驱节点标记为必胜态（1）  
   - 若当前节点是必胜态（1），则前驱节点的入度减1，当入度为0时标记为必败态

3. **多查询优化**：  
   每次查询独立处理，需重置状态数组和入度数组。通过提前终止（当起点状态确定时停止搜索）优化时间复杂度。

---

## 题解评分（≥4星）

### 1. 犇犇犇犇（5星）
**亮点**：  
- 官方题解，代码注释详细  
- 反向建图+入度维护逻辑清晰  
- 包含手动模拟样例解释，帮助理解状态传递  
- 代码加入优化：起点状态确定后提前终止搜索

**关键代码**：
```cpp
void del(int u) {
    f[u] = 1;
    for (遍历u的反向边v) {
        d[v]--;
        if (d[v] == 0) q.push(v);
    }
}
while (q不空) {
    int u = q.front();
    if (vic[x]已确定) break; // 优化提前终止
    if (u是必败点) 标记所有v为必胜点
    else if (u出度为0) 标记为必败点
}
```

### 2. duyi（5星）
**亮点**：  
- 理论分析深入，区分DAG与有环情况  
- 代码简洁，使用前向星存图  
- 明确队列初始化方式（终点+入度0节点）

**核心逻辑**：
```cpp
for (初始化队列) {
    if (节点i入度0 || i是终点) 加入队列，标记为必败
}
while (队列不空) {
    if (当前节点必败) 标记前驱为必胜
    else if (当前节点必胜) 前驱入度减1，入度0则标记必败
}
```

### 3. Mine_King（4星）
**亮点**：  
- 代码最简洁，适合快速理解  
- 状态标记逻辑清晰（-1/1/0）  
- 使用STL队列实现标准BFS

**代码片段**：
```cpp
if (f[x]==1) {
    in[to]--;
    if (!in[to]) 标记为必败
} else {
    标记为必胜
}
```

---

## 最优思路/技巧提炼

1. **反向图拓扑排序**：  
   通过反向建图，从已知状态（终点/出度0节点）开始推导，确保每个节点状态只被计算一次。

2. **入度剪枝**：  
   维护每个节点的未处理子节点数，仅当所有子节点状态确定时，才确定当前节点状态，有效处理环。

3. **状态传递规则**：  
   - 必败态节点 → 所有前驱标记为必胜  
   - 必胜态节点 → 前驱入度减1，入度0则标记必败

4. **多查询处理**：  
   每次查询独立处理，复制入度数组避免互相影响。

---

## 类似题目推荐

1. **P3243 [HNOI2015]菜肴制作**  
   - 反向拓扑排序确定最优解

2. **P2597 [ZJOI2012]灾难**  
   - DAG上的支配树问题，需反向推导

3. **P2146 [NOI2015]软件包管理器**  
   - 树链剖分+状态标记，类似节点状态传递

---

## 可视化算法演示

### 动画设计
1. **节点状态颜色标记**：  
   - 红色：必败态（-1）  
   - 蓝色：必胜态（1）  
   - 灰色：未确定（0）

2. **队列处理流程**：  
   - 初始队列含终点和出度0节点（红色）  
   - 每次取出队首节点，遍历反向边更新前驱节点  
   - 新增节点按BFS顺序加入队列

3. **动态入度显示**：  
   每个节点显示当前剩余未处理的子节点数（入度值），减为0时变红。

### 复古游戏化效果
- **8-bit像素风格**：  
  节点显示为16x16像素方块，边用单色线条连接。  
- **音效**：  
  - 节点入队：8-bit "哔"声  
  - 状态变更：不同音调（高音表必胜，低音表必败）  
- **自动演示模式**：  
  按空格暂停/继续，方向键调节速度。

### 交互示例
```javascript
// Canvas绘制节点示例
function drawNode(ctx, x, y, state) {
    ctx.fillStyle = state === 1 ? '#00F' : state === -1 ? '#F00' : '#888';
    ctx.fillRect(x-8, y-8, 16, 16);
    ctx.strokeStyle = '#000';
    ctx.strokeRect(x-8, y-8, 16, 16);
}
```

---

## 代码实现（犇犇犇犇题解核心部分）

```cpp
void solve(int x, int y) {
    queue<int> q;
    memset(f, 0, sizeof(f));
    memcpy(in, origin_in, sizeof(in)); // 复制初始入度

    // 初始队列：终点和入度0节点
    for (int i=1; i<=n; i++) {
        if (i == y || in[i] == 0) {
            f[i] = -1;
            q.push(i);
        }
    }

    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : reverse_graph[u]) { // 遍历反向边
            if (f[v] != 0) continue;
            if (f[u] == -1) { // u必败，v必胜
                f[v] = 1;
                q.push(v);
            } else {
                in[v]--;
                if (in[v] == 0) { // v所有子节点已处理
                    f[v] = -1;
                    q.push(v);
                }
            }
        }
    }
    cout << f[x] << endl;
}
```

---
处理用时：99.14秒
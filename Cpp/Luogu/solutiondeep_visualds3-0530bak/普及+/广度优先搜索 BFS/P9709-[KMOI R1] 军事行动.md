# 题目信息

# [KMOI R1] 军事行动

## 题目背景

$$\blue{他们来了。}$$

$$\purple{集结军队，干掉他们，一个不留。}$$

$$\blue{是！}$$

## 题目描述

喵星边境局势愈发紧张，导致发生边境冲突。喵星军队总司令小袁立即对 $Y$ 星采取军事行动。

整个宇宙可以看作一个平面直角坐标系，城市 $1,2,\dots,n$ 的坐标分别为 $(x_1,y_1),(x_2,y_2),\dots(x_n,y_n)$。

现在小袁率领的**若干支**舰队（可以理解为小袁的军事力量是无限的）驻扎在边境要塞，城市 $1$ 处。他的舰队会进行以下移动：

- 如果舰队的坐标为 $(x,y)$，那么一天之后它可以移动到 $(x-1,y+2)$ 或 $(x+1,y+2)$ 或 $(x+2,y+1)$ 或 $(x-2,y+1)$ 或 $(x-1,y-2)$ 或 $(x+1,y-2)$ 或 $(x+2,y-1)$ 或 $(x-2,y-1)$ 处。

其中环绕在外的还有一条小行星带，当舰队的坐标  $(x,y)$ 且 $x\le 0$ 或 $y\le 0$ 或 $m < x$ 或 $m < y$ 时，舰队就会撞到小行星带。这是小袁所不想看到的。

现在小袁要攻打城市 $2,3,\dots,n$，每一次他都会从一个**已经占领**的城市（城市 $1$ 也算），派出舰队前往城市 $i$ 并攻打它，舰队**到达之后的第二天**城市 $i$ 就被攻占了。

特别的，小袁在一个舰队**前往攻打或攻打一个城市**的时候不会派出另外一支舰队，在**攻占一座城市后当天**可以立即派出另外一支舰队。

小袁想问，最少要花多少时间才能攻占所有的城市。

**攻打顺序可以不按照 $2,3\dots n$ 的顺序。**

## 说明/提示

## 样例一解释：

舰队在第一天来到了 $(3,2)$ 的位置，第二天到达了城市 $2$ 的位置，第三天占领了城市 $2$。总共花了 $3$ 天。

## 样例二解释：

舰队在第一天到达了城市 $2$ 的位置，第二天占领了城市 $2$。第三天到达了城市 $3$ 的位置，第四天占领了城市 $3$。总共花了 $4$ 天。

## 数据范围

**本题采用 Subtask 捆绑测试。**

|子任务编号|  测试点编号| $n$ | $m$ |特殊性质|分值|
|:-----:| :----------: | :----------: | :----------: | :----------: |:---:|
|$1$| $1\sim2$ | $1\le n\le 7$ |$4\le m\le 7$|无|$10$|
|$2$| $3\sim7$ | $1\le n\le 200$ |$4\le m\le 70$|无|$25$|
|$3$| $8\sim9$ | $1\le n\le 150$ |$4\le m\le 150$|有|$15$|
|$4$| $10\sim20$ | $1\le n\le 2000$ |$4\le m\le 150$|无|$50$|

特殊性质：对于每一个 $1\le i\le n-1$，都有 $x_i = x_{i+1}$。

**数据严格保证不会有不同的城市拥有相同的坐标。**

## 样例 #1

### 输入

```
2 20
1 1
1 3```

### 输出

```
3```

## 样例 #2

### 输入

```
3 150
1 2
2 4
4 3```

### 输出

```
4```

## 样例 #3

### 输入

```
10 10
1 4
2 3
2 6
3 6
10 3
1 5
4 2
5 3
2 8
9 2```

### 输出

```
23```

## 样例 #4

### 输入

```
查看附件的 example4.in```

### 输出

```
查看附件的 example4.out```

# AI分析结果



## 算法分类
**BFS**

---

## 题解思路与解决难点

### 核心思路
题目本质是求**最小生成树**，边权为两城市间马步移动的最短时间。所有解法均采用以下步骤：
1. **BFS预处理**：对每个城市进行广度优先搜索，计算其到其他城市的马步移动时间（即边权）。
2. **构建完全图**：所有城市两两连边，权值为 BFS 计算出的最短时间。
3. **最小生成树**：使用 Kruskal 或 Prim 算法求最小生成树的总权值和。
4. **最终答案**：总权值加上 `n-1`（每个城市攻占需要额外 1 天）。

### 搜索算法关键点
- **BFS 初始化**：每个城市的起点入队，标记已访问。
- **访问顺序**：按层扩展，确保首次到达其他城市时记录最短时间。
- **剪枝策略**：遇到已访问的网格坐标直接跳过，避免重复计算。
- **数据结构**：队列管理待扩展节点，二维数组记录最短距离。

### 难点对比
- **数学公式计算边权**（_Flame_ 题解）：尝试用数学推导替代 BFS，但存在边界情况处理不全的风险。
- **完全图优化**（Fire_flame 题解）：BFS 遍历整个网格，可能产生冗余计算；而部分题解在 BFS 中遇到其他城市即记录边权，提前剪枝。
- **数据规模**：当 `m=150` 且 `n=2000` 时，需优化 BFS 的存储和访问标记，避免 MLE 或 TLE。

---

## 题解评分 (≥4星)
1. **Fire_flame（4.5星）**  
   - 思路清晰，完整实现 BFS + Kruskal，代码结构简洁。
   - 预处理完全图，适用于小规模数据，注释详细。
   - 缺点：大规模数据时 BFS 效率较低。

2. **Night_sea_64（4星）**  
   - 采用 Prim 算法，更适合稠密图，时间复杂度更优。
   - BFS 预处理时直接更新距离矩阵，减少存储开销。
   - 代码可读性稍逊，缺乏详细注释。

3. **CQ_Bob（4星）**  
   - 结合 BFS 和并查集，实现 Kruskal 算法。
   - 边权计算后排序处理，代码模块化清晰。
   - 未优化 BFS 的提前终止，可能产生冗余计算。

---

## 最优思路与技巧
- **BFS 剪枝**：在扩展节点时，若遇到其他城市，立即记录边权，无需继续扩展后续层（如 DerrickLo 的代码）。
- **Prim 优化**：对稠密图（完全图）使用 Prim 算法，时间复杂度 `O(n²)`，优于 Kruskal 的 `O(m log m)`。
- **坐标哈希**：将二维坐标 `(x,y)` 映射为一维索引，便于快速查找城市编号（如 qzmoot 的代码）。

---

## 类似算法与题目
- **棋盘最短路径**：如 P2324 [SCOI2005] 骑士精神（BFS + 状态压缩）。
- **网格生成树**：如 P1548 棋盘问题（二维网格的最小生成树）。
- **动态边权计算**：如 P1588 丢失的牛（BFS 动态计算移动代价）。

---

## 个人心得摘录
- **sbno333**：因忘记最终加 `n-1` 调试半小时，强调审题细节的重要性。
- **ryf_loser**：提到“最小生成树是突然顿悟”，反映建模能力的关键性。
- **qzmoot**：通过哈希优化坐标查询，避免暴力遍历城市列表。

---

## 可视化与算法演示
### 核心搜索过程动画设计
1. **BFS 扩展可视化**：
   - **节点颜色**：起点（绿色）、已访问（灰色）、当前扩展（红色）、其他城市（蓝色）。
   - **网格绘制**：在 Canvas 中以网格展示，马步移动时高亮下一步可达位置。
   - **音效触发**：访问新节点时播放“滴”声，发现城市时播放“叮”声。

2. **最小生成树构建**：
   - **边高亮**：按权值从小到大逐步连接城市，显示当前生成树的边。
   - **统计面板**：实时显示总权值、已选边数、剩余边数。

3. **复古像素风格**：
   - **8-bit 调色板**：使用 NES 风格的 16 色方案，节点用 8x8 像素块表示。
   - **自动演示模式**：AI 自动执行 BFS 和生成树构建，支持暂停/继续/步进。

### 代码片段（BFS 核心）
```cpp
void bfs(int sx, int sy) {
    queue<Step> q;
    memset(vis, 0, sizeof(vis));
    q.push({sx, sy, 0});
    vis[sx][sy] = 1;
    
    while (!q.empty()) {
        auto [x, y, steps] = q.front(); q.pop();
        for (int i = 0; i < 8; i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx < 1 || ny < 1 || nx > m || ny > m || vis[nx][ny]) 
                continue;
            vis[nx][ny] = 1;
            if (city_map[nx][ny] != -1) // 发现其他城市
                edges.push_back({current_city, city_map[nx][ny], steps + 1});
            q.push({nx, ny, steps + 1});
        }
    }
}
```

---

## 推荐题目
1. **P2324**：骑士精神的 BFS 状态搜索。
2. **P1514**：棋盘覆盖问题，DFS 或 BFS 应用。
3. **P1548**：二维网格的生成树计数。

---
处理用时：99.42秒
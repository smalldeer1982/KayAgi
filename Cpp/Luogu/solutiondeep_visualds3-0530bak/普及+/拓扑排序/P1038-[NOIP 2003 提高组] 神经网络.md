# 题目信息

# [NOIP 2003 提高组] 神经网络

## 题目背景

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。



## 题目描述

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)

神经元（编号为 $i$）


图中，$X_1 \sim X_3$ 是信息输入渠道，$Y_1 \sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)

兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）

$$C_i=\left(\sum\limits_{(j,i) \in E} W_{ji}C_{j}\right)-U_{i}$$

公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。



## 说明/提示

**【题目来源】**

NOIP 2003 提高组第一题

## 样例 #1

### 输入

```
5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
```

### 输出

```
3 1
4 1
5 1
```

# AI分析结果



### 唯一算法分类  
拓扑排序

---

### 综合分析与结论  
#### 核心思路
通过拓扑排序处理神经元的层级传递关系，确保前驱节点计算完成后才进行后继节点的状态计算。关键步骤：
1. **输入预处理**：输入层节点直接入队，非输入层节点预先减去阈值
2. **拓扑传播**：队列处理过程中，仅当节点处于兴奋状态（C_i>0）时才向后传递信号
3. **输出筛选**：收集所有出度为0且C_i>0的节点作为输出层

#### 核心难点
1. **阈值处理时机**：输入层不参与阈值计算，中间层需要先减阈值再判断兴奋状态
2. **状态传递条件**：必须严格判断C_i>0时才进行信号传递
3. **输出层判定**：需同时满足出度为0和C_i>0两个条件

#### 可视化设计
1. **动画流程**：
   - 绿色节点：队列中待处理的兴奋节点
   - 红色箭头：正在传递信号的边
   - 灰色节点：已处理完毕的非兴奋节点
2. **状态面板**：
   - 实时显示各节点的C_i值和出度状态
   - 高亮当前处理的节点及其出边
3. **复古像素风格**：
   - 使用8-bit风格网格布局神经元
   - 信号传递时播放"哔"声效，完成时播放"叮"声效

---

### 题解清单 (4星及以上)
1. **Lucaster_** (⭐⭐⭐⭐⭐)  
   - 亮点：双重队列机制，预处理输入层状态，使用邻接表高效处理边关系
   - 关键代码：`if(c[e[i].from]>0) c[t] += e[i].val*c[h]`
   - 调试心得：发现from字段冗余后优化代码结构

2. **zzlzk** (⭐⭐⭐⭐)  
   - 亮点：反向建图记忆化搜索，递归式拓扑处理
   - 关键思路：输出层节点作为递归起点，避免显式队列管理

3. **teafrogsf** (⭐⭐⭐⭐)  
   - 亮点：入度出度双数组管理，暴力层序遍历实现拓扑效果
   - 优化点：`if(c[h]<=0) continue` 提前剪枝非兴奋节点

---

### 核心代码实现
```cpp
// Lucaster_ 题解核心片段
void build(int u,int v,int w) { // 邻接表建边
    e[++cnt] = {v, w, hd[u]};
    hd[u] = cnt;
    out[u] = true; // 标记有出边
}

while(!q.empty()) {
    int h = q.front(); q.pop();
    if(c[h] <= 0) continue; // 兴奋状态检查
    for(int i=hd[h]; i; i=e[i].next) {
        int t = e[i].to;
        c[t] += e[i].val * c[h]; // 信号传递
        if(!vis[t]) q.push(t), vis[t] = true;
    }
}
```

---

### 相似题目推荐
1. **P1983 车站分级** (拓扑排序应用)
2. **P4017 最大食物链计数** (DAG入度出度处理)
3. **P2741 无序字母对** (欧拉路径+拓扑思想)

---

### 可视化算法演示方案
1. **Canvas网格布局**：
   - 每个神经元显示为16x16像素方块
   - 输入层显示为蓝色，中间层黄色，输出层紫色
2. **动画步骤**：
   1. 输入层节点闪烁3次后开始传播
   2. 信号沿激活的边流动（红色光点移动）
   3. 被激活的节点变为绿色并抖动
3. **交互功能**：
   - 空格键暂停/继续
   - 方向键控制动画速度
   - F1显示各节点当前状态数值

---

### 调试心得摘录
> "发现测试点5卡了多次，最终发现是输入层节点同时作为输出层时需要特殊处理。通过增加`if(cd[i]==0 && c[i]>0)`双重条件解决" —— Lucaster_  
> "反向建图的递归方式意外节省了队列管理代码量，但需要注意递归深度限制" —— zzlzk

---

通过拓扑排序框架配合状态传播机制，该题展现了DAG处理的典型模式。可视化设计中融入游戏化元素能有效提升算法理解度，特别是信号传递过程的动态演示可帮助初学者建立清晰的层级传播概念。

---
处理用时：72.61秒
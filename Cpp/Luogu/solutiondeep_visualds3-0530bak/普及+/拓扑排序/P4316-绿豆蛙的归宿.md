# 题目信息

# 绿豆蛙的归宿

## 题目背景

随着新版百度空间的上线，Blog 宠物绿豆蛙完成了它的使命，去寻找它新的归宿。

## 题目描述

给出张 $n$ 个点 $m$ 条边的有向无环图，起点为 $1$，终点为 $n$，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。

绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果该节点有 $k$ 条出边，绿豆蛙可以选择任意一条边离开该点，并且走向每条边的概率为 $\frac{1}{k}$ 。现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 10^2$。
- 对于 $40\%$ 的数据，保证 $n \leq 10^3$。
- 对于 $60\%$ 的数据，保证 $n \leq 10^4$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times n$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^9$，给出的图无重边和自环。

## 样例 #1

### 输入

```
4 4 
1 2 1 
1 3 2 
2 3 3 
3 4 4```

### 输出

```
7.00```

# AI分析结果



## 算法分类：期望DP

---

### 综合分析与结论

**核心思路**  
所有题解均基于期望DP，通过逆向拓扑排序实现。核心公式为：  
$$ f[x] = \sum_{y \in son(x)} \frac{f[y] + w(x,y)}{k} $$  
其中 $k$ 是节点出度，$w$ 是边权。关键难点在于理解 **逆推思想** 和 **反向建图** 的必要性。

**可视化设计要点**  
1. **动态拓扑排序**：以像素风格展示反向建图后的拓扑队列，当前处理节点用闪烁高亮  
2. **期望值更新动画**：每次从队列取出节点时，用箭头指向其前驱节点，逐步累加期望值  
3. **音效触发**：节点入队时播放 "beep" 音效，期望值更新时播放 "click" 音效  
4. **像素风格控件**：控制面板包含播放/暂停按钮和速度滑块，使用 16 色复古调色板

---

### 题解清单（≥4星）

1. **___new2zy___（5星）**  
   - 亮点：完整推导期望DP模型，代码清晰，反向拓扑实现高效  
   - 核心代码：  
     ```cpp
     void toposort() {
         queue<int> q;
         q.push(n);
         while(!q.empty()) {
             int x = q.front(); q.pop();
             for(int i=head[x];i;i=p[i].from) {
                 int y = p[i].to;
                 f[y] += (f[x] + p[i].w)/dg[y]; // 核心状态转移
                 if(!(--in[y])) q.push(y);
             }
         }
     }
     ```

2. **wangjyqh（4星）**  
   - 亮点：对比顺推/逆推公式，给出两种实现方式  
   - 关键公式：  
     - 逆推：$dp[x] = \sum (dp[y] + w)/k$  
     - 顺推：需维护概率数组 $g[y] = \sum g[x]/k$  

3. **ghj1222（4星）**  
   - 亮点：提出 **边贡献思想**，$Ans = \sum f_e \times w_e$  
   - 关键步骤：  
     ```cpp
     p[y] += p[x]/out[x]; // 概率传递
     f[y] += p[x]/out[x] * w; // 边贡献累加
     ```

---

### 最优思路提炼

**核心技巧**  
1. **逆推拓扑排序**：从终点反向计算，避免概率累乘  
2. **反向建图**：将原图边反向存储，直接使用原图出度  
3. **零初始化终点**：$f[n] = 0$ 作为递归边界条件  

**代码实现关键**  
```cpp
// 反向建边时记录原图出度
add_edge(y, x, w); // 边反向存储
dg[x]++; // 原图出度保持不变

// 拓扑排序中动态转移
for (int y : reverse_edges[x]) {
    f[x] += (f[y] + w) / original_out_degree[x];
}
```

---

### 同类型题拓展

1. **P1850 换教室**：期望DP结合最短路  
2. **P3232 [HNOI2013]游走**：边期望+高斯消元  
3. **P6835 [CSP-S2020] 函数调用**：拓扑排序处理函数调用链  

---

### 个人心得摘录

> "逆推时所有点的到达概率最终为1，省去概率计算。这是逆推代码比顺推简洁的根本原因。" —— Guitar_Jasmine  
> "边贡献思想将问题分解为独立计算每条边的期望通过次数，适合处理复杂路径问题" —— ghj1222

---

### 可视化算法演示

**动画设计**  
1. **初始化阶段**：  
   - 显示反向建图后的DAG，终点n标记为绿色  
   - 节点1显示为红色，其他节点为蓝色  

2. **拓扑过程**：  
   - 当前处理节点x高亮为黄色，出队时变为灰色  
   - 对每个前驱节点y，显示边权w和转移公式  

3. **期望更新**：  
   - 在节点y上方实时显示累加过程：  
     `f[y] += (f[x]=当前值) + w`  
   - 更新后数值以放大动画强调变化  

**音效方案**  
- `q.pop()`：8-bit "pop" 音效 (频率: 800Hz, 时长: 50ms)  
- `f[y]更新`：三连音效模拟累加过程  

**代码片段（Canvas绘制）**  
```javascript
function drawNode(ctx, x, y, value, color) {
    ctx.fillStyle = color; // 根据状态选择颜色
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "#000";
    ctx.font = "14px retro";
    ctx.textAlign = "center";
    ctx.fillText(value.toFixed(2), x, y+5);
}

function drawEdge(ctx, x1, y1, x2, y2, w) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = "#777";
    ctx.stroke();
    ctx.fillText(w, (x1+x2)/2 + 10, (y1+y2)/2 - 10);
}
```

---

### 代码实现（核心逻辑）

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5+10;
vector<pair<int,int>> G[N]; // 反图：to, weight
int n, m, in[N], orig_out[N];
double f[N];

void topo() {
    queue<int> q;
    q.push(n);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto [v, w] : G[u]) {
            f[v] += (f[u] + w) / orig_out[v];
            if (--in[v] == 0) q.push(v);
        }
    }
}

int main() {
    cin >> n >> m;
    while (m--) {
        int u, v, w; cin >> u >> v >> w;
        G[v].emplace_back(u, w); // 反向建图
        in[u]++; // 原图的入度变为反图的出度
        orig_out[u]++; // 记录原图出度
    }
    topo();
    printf("%.2lf\n", f[1]);
}
```

---
处理用时：91.65秒
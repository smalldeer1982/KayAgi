# 题目信息

# 小 C 与桌游

## 题目背景

小 C 是一个热爱桌游的高中生，现在他被一个桌游难住了，快来帮帮他！

## 题目描述

这个桌游的地图可以被抽象成一个 $n$ 个点，$m$ 条边的**有向无环图**（**不保证连通**），小 C 在这个地图上行走，小 C 能走到某个点当且仅当能够到达这个点的所有点都已经被小 C 走到。小 C 会走到每个点恰好 $1$ 次，并且他能走到哪些点与他当前所在的点没有关系（即可以走到与当前所在的点没有连边的点，只要满足之前的条件）。

小 C 每走到一个标号比之前走到的点都大的点，他就会有 $\frac{1}{2}$ 的概率从对手那里拿到 $1$ 块筹码，有 $\frac{1}{2}$ 的概率给对手 $1$ 块筹码，双方初始各有 $1919810$ 个筹码。

小 C 的运气时好时坏，所以他希望你帮他计算出：

- 在最优情况下，即他每次都能从对手那里拿到筹码时，他采取最优的行走方式能得到的筹码数。
- 在最劣情况下，即对手每次都能从他那里拿到筹码时，他采取最优的行走方式会失去的筹码数。



## 说明/提示

**样例解释**

最优情况下的行走方式是 $1-2-3$，最劣情况下的行走方式是 $1-3-2$。

**计分方式**

对于每一个测试点：

- 如果你输出格式错误或者两行都不正确，将会得到 $0$ 分。
- 如果你的输出第一行正确，第二行错误或第二行正确，第一行错误，将会得到这个测试点 $40 \%$ 的分数。
- 否则，你将会得到这个测试点 $100 \%$ 的分数。

**数据范围**

对于 $20\%$ 的数据，$1 \le n, m \le 10$。

对于 $40\%$ 的数据，$1 \le n, m \le 2000$。

对于 $100\%$ 的数据，$1 \le n, m \le 5 \times 10^5$，$1 \le u, v \le n$。


## 样例 #1

### 输入

```
3 2
1 2
1 3```

### 输出

```
3
2```

# AI分析结果



### 唯一算法分类
拓扑排序、贪心算法

### 题解思路与核心难点

#### 最优情况处理
- **核心思路**：采用小根堆维护拓扑排序，每次选择编号最小的可用节点。这保证了后续更大节点的访问机会最大化。
- **关键变量**：`maxn` 记录当前已访问的最大编号，每次遇到更大编号时得分增加。
- **数据结构**：优先队列（小根堆）实现拓扑排序。

#### 最劣情况处理
- **核心难点**：直接使用大根堆选择最大节点可能错过更优路径。
- **突破思路**：
  1. **分层处理**：将可用节点分为两类：
     - 不影响得分的节点（编号 ≤ 当前最大值）：用普通队列处理。
     - 可能增加得分的节点（编号 > 当前最大值）：用大根堆维护。
  2. **贪心策略**：优先处理队列中的小节点，再处理大根堆中的大节点。
- **关键实现**：
  - 使用两个容器：大根堆存储候选节点，队列存储不影响得分的节点。
  - 每次处理完大节点后，立即处理所有不影响得分的节点。

### 题解评分（≥4星）

1. **Mubuky（★★★★☆）**
   - **亮点**：通过大根堆与队列结合，清晰分层处理节点。
   - **代码示例**：
     ```cpp
     while (!qless.empty()) {
         int x = qless.top();
         if (x > maxn) ans++;
         while (!qless.empty()) { // 转移所有节点到临时队列
             kz.push(qless.top());
             qless.pop();
         }
         while (!kz.empty()) { // 处理所有不影响得分的节点
             int nx = kz.front();
             kz.pop();
             maxn = max(maxn, nx);
             // 更新后续节点入度
         }
     }
     ```

2. **Sweetlemon（★★★★★）**
   - **亮点**：提出动态规划与贪心结合的思路，使用树状数组优化状态转移。
   - **关键思路**：维护关键点集合，通过`pre[i]`表示前置最大编号，动态计算最小得分。

3. **huangzirui（★★★★☆）**
   - **亮点**：提出优先处理不影响得分的节点，再处理大节点，逻辑简洁高效。
   - **代码片段**：
     ```cpp
     while (!q2.empty()) {
         int now = q2.top();
         if (now > maxx) { ... }
         while (q2.size()) { // 处理不影响得分的节点
             dfs(q2.top()); // 递归处理小节点
             q2.pop();
         }
     }
     ```

### 最优思路提炼
- **分层贪心**：最劣情况中，将节点分为两类处理，优先消耗不影响得分的节点。
- **双容器协作**：大根堆维护候选得分点，队列处理无影响节点，确保得分最小化。

### 类似题目
1. **P3243 [HNOI2015]菜肴制作**（拓扑排序+贪心）
2. **P1137 旅行计划**（DAG 拓扑排序）
3. **P4017 最大食物链计数**（拓扑排序+DP）

### 可视化设计
#### 核心算法演示
- **动画效果**：
  - **节点分类**：红色表示候选得分点（大根堆），绿色表示无影响节点（队列）。
  - **高亮操作**：处理大节点时闪烁红色，处理小节点时闪烁绿色。
  - **得分标记**：每次得分增加时显示金色特效。

#### 复古像素风格
- **实现方案**：
  1. **Canvas 绘制**：用 16x16 像素方块表示节点，堆和队列分列左右。
  2. **音效设计**：
     - 处理节点：8-bit "beep" 音效。
     - 得分增加：上扬音调。
  3. **自动演示**：按步长自动执行，速度可调。

### 核心代码片段
```cpp
// 最劣情况处理（Mubuky 题解核心逻辑）
priority_queue<int> qless; // 大根堆
queue<int> kz; // 临时队列

while (!qless.empty()) {
    int x = qless.top();
    if (x > maxn) ans++; // 得分增加
    // 转移所有节点到临时队列
    while (!qless.empty()) { 
        kz.push(qless.top());
        qless.pop();
    }
    // 处理所有不影响得分的节点
    while (!kz.empty()) {
        int nx = kz.front(); 
        kz.pop();
        maxn = max(maxn, nx); // 更新最大值
        for (int j : g[nx]) { // 更新后续节点
            in2[j]--;
            if (in2[j] == 0) {
                if (j > maxn) qless.push(j); // 重新入堆
                else kz.push(j); // 继续处理
            }
        }
    }
}
```

### 个人心得摘录
- **Mubuky**：反例证明直接贪心无效，必须结合队列处理小节点。
- **Sweetlemon**：动态规划状态转移需要维护后缀最小值，树状数组优化是关键。

---
处理用时：84.10秒
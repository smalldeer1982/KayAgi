# 题目信息

# [NOIP2020] 排水系统

## 题目描述

对于一个城市来说，排水系统是极其重要的一个部分。

有一天，小 C 拿到了某座城市排水系统的设计图。排水系统由 $n$ 个排水结点（它们从 $1 \sim n$ 编号）和若干个单向排水管道构成。每一个排水结点有若干个管道用于汇集其他排水结点的污水（简称为该结点的汇集管道），也有若干个管道向其他的排水结点排出污水（简称为该结点的排出管道）。

排水系统的结点中有 $m$ 个污水接收口，它们的编号分别为 $1, 2, \ldots , m$，污水只能从这些接收口流入排水系统，并且这些结点没有汇集管道。排水系统中还有若干个最终排水口，它们将污水运送到污水处理厂，没有排出管道的结点便可视为一个最终排水口。

现在各个污水接收口分别都接收了 $1$ 吨污水，污水进入每个结点后，会均等地从当前结点的每一个排出管道流向其他排水结点，而最终排水口将把污水排出系统。

现在小 C 想知道，在该城市的排水系统中，每个最终排水口会排出多少污水。该城市的排水系统设计科学，管道不会形成回路，即不会发生污水形成环流的情况。

## 说明/提示

**【样例 #1 解释】**

$1$ 号结点是接收口，$4, 5$ 号结点没有排出管道，因此是最终排水口。  
$1$ 吨污水流入 $1$ 号结点后，均等地流向 $2, 3, 5$ 号结点，三个结点各流入 $\frac{1}{3}$ 吨污水。  
$2$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
$3$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
最终，$4$ 号结点排出 $\frac{1}{6} + \frac{1}{6} = \frac{1}{3}$ 吨污水，$5$ 号结点排出 $\frac{1}{3} + \frac{1}{6} + \frac{1}{6} = \frac{2}{3}$ 吨污水。

**【数据范围】**

| 测试点编号 | $n \le$ | $m \le$ |
|:-:|:-:|:-:|
| $1 \sim 3$ | $10$ | $1$ |
| $4 \sim 6$ | ${10}^3$ | $1$ |
| $7 \sim 8$ | ${10}^5$ | $1$ |
| $9 \sim 10$ | ${10}^5$ | $10$ |

对于全部的测试点，保证 $1 \le n \le {10}^5$，$1 \le m \le 10$，$0 \le d_i \le 5$。

数据保证，污水在从一个接收口流向一个最终排水口的过程中，不会经过超过 $10$ 个中间排水结点（即接收口和最终排水口不算在内）。

## 样例 #1

### 输入

```
5 1
3 2 3 5
2 4 5
2 5 4
0
0
```

### 输出

```
1 3
2 3
```

## 样例 #2

### 输入

```
见附件中的 water/water2.in```

### 输出

```
见附件中的 water/water2.ans```

## 样例 #3

### 输入

```
见附件中的 water/water3.in```

### 输出

```
见附件中的 water/water3.ans```

# AI分析结果



# [NOIP2020] 排水系统 题解分析

## 唯一算法分类
拓扑排序

---

## 综合分析与结论
### 核心算法流程
1. **拓扑排序框架**
   - 使用队列维护入度为0的节点（污水接收口）
   - 每次取出队列头部节点u，将其污水均分到所有出边连接的节点v
   - 更新v节点的入度，若入度归零则入队

2. **分数处理技巧**
   - 分子分母用`__int128`存储避免溢出
   - 关键公式：$f_v = f_v + \frac{f_u}{outdegree(u)}$
   - 每次加法后立即通分：$gcd = \text{gcd}(新分子, 新分母)$

3. **可视化设计思路**
   - **动画流程**：节点按拓扑序渐变为绿色，水流以黄色线条流向子节点
   - **高亮规则**：当前处理节点用橙色闪烁，最终排水口用红色边框
   - **分数展示**：每个节点旁显示分子/分母，约分过程用渐隐动画
   - **复古效果**：8-bit音效（队列弹出音：NES金币声，入队音：马里奥跳跃声）

---

## 题解清单（≥4星）

### 1. 作者：Legitimity（★★★★☆）
- **亮点**：代码结构清晰，分数类封装完整，使用`__int128`处理大数
- **关键代码**：
  ```cpp
  struct Frac{
      __int128 x, y;
      void yuefen() {
          __int128 g = gcd(x, y);
          x /= g; y /= g;
      }
      Frac operator/(int k) {
          Frac t = *this;
          t.y *= k;
          t.yuefen();
          return t;
      }
  };
  ```

### 2. 作者：normalpcer（★★★★☆）
- **亮点**：拓扑排序与分数处理解耦，队列初始化时直接标记初始节点
- **调试心得**：强调必须初始分母为1，否则会在空节点计算时出现除零错误

### 3. 作者：gavinliu266（★★★★☆）
- **优化点**：用`vector`预存所有最终排水口，输出时直接遍历无需二次判断
- **实现技巧**：约分时同时处理分子分母，避免中间变量溢出

---

## 最优思路提炼
1. **拓扑驱动分配**  
   利用DAG特性，确保每个节点只在其所有上游处理完毕后进行计算

2. **即时约分策略**  
   每次分数运算后立即求GCD约分，防止数值爆炸：
   ```cpp
   void add(int v, Frac f) {
       f_v = f_v + f;
       __int128 g = gcd(f_v.x, f_v.y);
       f_v.x /= g; f_v.y /= g;
   }
   ```

3. **结构体封装**  
   将分数运算封装为独立类，提升代码可维护性：
   ```cpp
   struct Frac {
       __int128 a, b;
       Frac operator+(Frac o) {
           __int128 lcm = b / gcd(b, o.b) * o.b;
           return {a*(lcm/b) + o.a*(lcm/o.b), lcm};
       }
   };
   ```

---

## 同类型题推荐
1. **P1038 神经网络** - 拓扑排序传递信号
2. **P1983 车站分级** - DAG层级划分
3. **P1137 旅行计划** - 拓扑序DP

---

## 个人心得摘录
> "考场上看到分数计算直接放弃高精度，改用__int128水过。事后证明分母最大是$3^{11} \times 5^{10}$，刚好不会溢出128位，算是险中求胜。" —— 作者：Legitimity

> "调试时发现约分后分母可能为0，最后强制所有分母初始化为1才解决。血的教训：永远不要相信未初始化的数据！" —— 作者：wjr_jok

---

## 可视化算法演示（核心逻辑）
```javascript
// 伪代码示例：拓扑排序动画核心逻辑
class WaterFlowAnim {
    constructor(nodes) {
        this.queue = new PixelQueue(8-bit风格, 0xFF9900);
        this.nodes = nodes.map(n => new NodeSprite(n.id, 16x16像素));
    }

    step() {
        let u = this.queue.dequeue();  // 播放"pop.wav"
        u.setColor(0xFF0000);         // 当前节点变红
        
        u.edges.forEach(edge => {
            let v = edge.to;
            this.animateWaterFlow(u, v);  // 黄色粒子流向v
            v.frac.add(u.frac / u.outDegree);
            v.frac.reduce();              // 显示约分动画
            
            if (--v.inDegree === 0) {
                this.queue.enqueue(v);    // 播放"blip.wav"
                v.setColor(0x00FF00);     // 新入队变绿
            }
        });
    }
}
```

---

## 复古游戏化设计
1. **视觉样式**  
   - 节点：16x16像素方块，绿色=待处理，红色=正在计算，蓝色=完成
   - 水流：黄色像素点从父节点向子节点逐帧移动

2. **音效设计**  
   - `queue.pop()`：FC风格短促"滴"声（频率800Hz，时长0.1s）
   - `frac.reduce()`：成功约分时播放上升琶音

3. **自动演示模式**  
   - 按空格键暂停/继续
   - 方向键控制动画速度（←减速，→加速）

---

通过以上分析，该题的核心在于拓扑排序与分数处理的结合，配合合理的数据结构选择（如`__int128`），即可高效解题。可视化设计则通过复古游戏元素增强算法理解过程的趣味性。

---
处理用时：86.86秒
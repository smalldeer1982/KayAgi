# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果



# 算法分类
**枚举**

---

# 题解思路与难点分析

## 核心思路
所有题解均采用**逆向思维**避免存储全图：  
1. **不保存覆盖状态**：直接存储每个地毯的几何参数（左上角坐标+长宽）
2. **O(n) 遍历判断**：从最后一个地毯开始逆序检查，第一个覆盖目标点的即为答案
3. **边界判断公式**：`x ∈ [a,a+g] && y ∈ [b,b+k]`

## 解决难点
1. **空间优化**：二维数组方案会导致 400MB 内存占用（MLE），改用线性存储将空间降为 O(n)
2. **时间优化**：逆序遍历可在找到第一个覆盖点时立即返回，平均时间复杂度优于正序遍历

---

# 高星题解推荐 (≥4★)

1. **Vct14 题解（5★）**  
   - 亮点：逆序判断+提前返回，代码简洁高效  
   - 核心代码片段：  
     ```cpp
     for(int i=n; i>=1; i--){
         if(x<=l[i].c && x>=l[i].a && y<=l[i].d && y>=l[i].b){
             cout<<i; return 0; // 立即终止程序
         }
     }
     ```

2. **谁懂谁伤心 题解（4.5★）**  
   - 亮点：预计算右下角坐标，判断条件直观  
   - 核心优化：  
     ```cpp
     b[j][0]=a[j][0]+n; // 预处理右下角x坐标
     ```

3. **kuaiCreator 题解（4★）**  
   - 亮点：完全使用基本数据类型，内存极致优化  
   - 关键设计：  
     ```cpp
     const int N = 1e4+5; // 精确控制数组大小
     ```

---

# 最优代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4+5;
int a[N], b[N], g[N], k[N], n, x, y;

int main() {
    cin >> n;
    for(int i=1; i<=n; i++) 
        cin >> a[i] >> b[i] >> g[i] >> k[i];
    cin >> x >> y;
    
    for(int i=n; i>=1; i--) {
        if(x >= a[i] && x <= a[i]+g[i] && 
           y >= b[i] && y <= b[i]+k[i]) {
            cout << i;
            return 0;
        }
    }
    cout << -1;
    return 0;
}
```

**核心思想**：  
- 逆序遍历地毯数组，第一个满足覆盖条件的地毯即为最上层
- 使用四个一维数组分别存储地毯参数，空间复杂度 O(n)

---

# 可视化算法演示设计

## 动画方案
1. **像素网格渲染**：  
   - 使用 Canvas 绘制坐标系，每个地毯显示为半透明色块
   - 目标点以闪烁红点标记，当地毯覆盖时变绿

2. **执行流程**：  
   ```mermaid
   graph TD
    开始 --> 加载地毯数据
    加载地毯数据 --> 标记目标点
    标记目标点 --> 逆序遍历地毯
    逆序遍历地毯 -->|是| 高亮当前地毯
    高亮当前地毯 --> 检查覆盖
    检查覆盖 -->|覆盖| 显示结果并终止
    检查覆盖 -->|不覆盖| 继续遍历
   ```

3. **复古风格特效**：  
   - **音效**：遍历时播放"滴"声，命中时播放8-bit胜利音效
   - **像素动画**：地毯用16色马赛克效果渲染，目标点使用红绿交替闪烁

---

# 相似题目推荐
1. **P1056 排座椅** - 线段覆盖问题
2. **P1496 火烧赤壁** - 区间合并问题
3. **P3740 贴海报** - 覆盖顺序判断

---

# 总结与心得
- **逆向思维**是本题关键：后铺的地毯优先级更高，逆序遍历可快速定位
- **空间优化**必须舍弃全图存储，转为参数化判断
- **边界处理**需注意题目中"边界和顶点也算覆盖"的特殊条件

通过本题可掌握**线性空间处理覆盖问题**的核心技巧，为后续复杂几何问题打下基础。

---
处理用时：74.89秒
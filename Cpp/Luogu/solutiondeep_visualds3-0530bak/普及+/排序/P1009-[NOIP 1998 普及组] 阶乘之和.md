# 题目信息

# [NOIP 1998 普及组] 阶乘之和

## 题目描述

用高精度计算出 $S = 1! + 2! + 3! + \cdots + n!$（$n \le 50$）。

其中 `!` 表示阶乘，定义为 $n!=n\times (n-1)\times (n-2)\times \cdots \times 1$。例如，$5! = 5 \times 4 \times 3 \times 2 \times 1=120$。

## 说明/提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le 50$。

**【其他说明】**

注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \le 20$，使用书中的代码无法通过本题。

如果希望通过本题，请继续学习第八章高精度的知识。

NOIP1998 普及组 第二题

## 样例 #1

### 输入

```
3
```

### 输出

```
9```

# AI分析结果



## 算法分类
**高精度算法**

---

## 题解思路与难点对比

### 核心算法流程
1. **阶乘计算**：用高精度乘法递推计算每个阶乘（`i! = (i-1)! * i`）
2. **累加求和**：用高精度加法将每个阶乘结果累加至总和
3. **进位处理**：乘法和加法过程中需动态处理进位与数组长度

### 解决难点
- **动态数组管理**：阶乘结果位数随i增大指数级增长，需动态扩展数组长度
- **双重进位处理**：乘法进位（每位可能达到 `9*50=450`）与加法进位需分开处理
- **零值处理**：输出时需跳过前导零（如最后数组高位可能存在的无效零）

---

## 题解评分（≥4星）

### 1. C_Z_C [★★★★☆]
- **亮点**：同时维护阶乘数组与总和数组，实现O(n)空间复杂度
- **关键代码**：
```cpp
for(int j=0;j<len_a;j++) // 高精乘核心
    for(int k=0;k<=len_b;k++)
        c[j+k] += a[j]*b[k];
```

### 2. 二元长天笑 [★★★★★]
- **亮点**：通过重载运算符实现高精类，主程序简洁如普通运算
- **核心实现**：
```cpp
struct fantastic { // 重载+和*
    int len,s[9999];
    fantastic operator+(const fantastic &a){...}
    fantastic operator*(const fantastic &x){...}
};
```

### 3. zhangboju [★★★★☆]
- **思维突破**：公式变形 `S = 1*(1+2*(1+3*(...)))`，将问题转化为单次高精乘+加1
- **核心逻辑**：
```cpp
for(int i=n;i>=1;i--){
    mul(i,ans);    // ans *= i
    inc(ans[1]);   // ans += 1
}
```

---

## 最优技巧提炼

### 递推式高精度乘法
- **递推公式**：`fact[i] = fact[i-1] * i`
- **实现关键**：每次乘法后立即处理进位（代码示例）：
```cpp
for(int j=1;j<=fact_len;j++) fact[j] *= i;
for(int j=1;j<=fact_len;j++){
    fact[j+1] += fact[j]/10;
    fact[j] %= 10;
    if(j==fact_len && fact[j+1]>0) fact_len++;
}
```

### 累加优化
- **并行进位**：在累加时同步处理进位，避免二次遍历
```cpp
for(int j=1;j<=max_len;j++){
    sum[j] += fact[j];
    sum[j+1] += sum[j]/10;
    sum[j] %= 10;
}
```

---

## 同类型题目推荐
1. **P1001 A+B Problem（高精）**  
   （基础高精度加法练习）

2. **P1303 A*B Problem**  
   （高精度乘法专项训练）

3. **P1255 数楼梯**  
   （高精度+递推，类似阶乘增长模式）

---

## 可视化设计

### 动画演示方案
```html
<div id="canvas-container">
    <canvas id="fact-canvas" width="600" height="200"></canvas>
    <div class="control-panel">
        <button onclick="stepBack()">←</button>
        <button onclick="togglePlay()">▶/❚❚</button>
        <button onclick="stepNext()">→</button>
        <input type="range" id="speed" min="1" max="5" value="3">
    </div>
</div>

<script>
// 示例数据结构
let state = {
    currentStep: 0,
    steps: [
        { type: 'mult', i: 3, fact: [1], sum: [1] },
        { type: 'add',  fact: [6], sum: [7] },
        // ...其他步骤
    ]
};

function drawStep(step) {
    // 绘制当前阶乘计算
    ctx.fillStyle = '#8BC34A'; // 绿色标记当前操作位
    drawArray(step.fact, {x:50, y:50}, 'Factorial');
    
    // 绘制累加过程
    ctx.fillStyle = '#2196F3';
    drawArray(step.sum, {x:50, y:120}, 'Sum');
    
    // 高亮进位操作
    if(step.carryPos) {
        ctx.strokeStyle = '#FF5722';
        ctx.strokeRect(50+step.carryPos*30, 80, 24, 24);
    }
}
</script>
```

### 复古风格实现
- **像素字体**：使用 `Press Start 2P` 等8位风格字体
- **音效设计**：
  - 乘法操作：短促的「哔」声（Web Audio生成方波）
  - 进位发生：音调升高半音
  - 完成累加：马里奥过关音效片段
- **动画效果**：使用CSS像素化滤镜：
```css
#fact-canvas {
    image-rendering: pixelated;
    filter: sepia(100%) contrast(150%); 
}
```

---

## 核心代码实现
```cpp
// 高精度乘+加完整实现
#include <iostream>
#include <cstring>
using namespace std;

int sum[1000] = {0}, fact[1000] = {1,1}; // 从索引1开始存储

void calcFactorialSum(int n) {
    int fact_len = 1, sum_len = 1;
    
    for(int i=1; i<=n; i++){
        // 计算i! = fact * i
        for(int j=1; j<=fact_len; j++) 
            fact[j] *= i;
            
        // 处理乘法进位
        for(int j=1; j<=fact_len; j++){
            fact[j+1] += fact[j]/10;
            fact[j] %= 10;
            if(j == fact_len && fact[j+1]>0) 
                fact_len++;
        }
        
        // 累加到总和
        sum_len = max(sum_len, fact_len);
        for(int j=1; j<=fact_len; j++){
            sum[j] += fact[j];
            sum[j+1] += sum[j]/10;
            sum[j] %= 10;
        }
        if(sum[sum_len+1] > 0) sum_len++;
    }
    
    // 输出结果
    for(int i=sum_len; i>=1; i--)
        cout << sum[i];
}

int main() {
    int n;
    cin >> n;
    calcFactorialSum(n);
    return 0;
}
```

---

## 调试心得摘录
> **C_Z_C**题解评论：  
> "因为进位处理写成了f[j+1]++导致WA一个点，高精度进位必须用除法取模！"  
> **启示**：进位值可能是多位数（如45/10=4余5），必须用除法而非简单+1

> **吃葡萄吐糖**调试经验：  
> "发现50!计算时中间结果超过int范围，改用long long存储每位"  
> **优化**：使用`int`数组存储十进制位时，每个元素可存0-9，避免溢出

---

通过分步可视化与复古风格演示，学习者可直观观察：
1. 阶乘计算的位数扩展过程
2. 进位操作如何像波纹一样从低位向高位传播
3. 累加时两数组的对应位相加与进位产生
配合8位音效与像素动画，将抽象的高精度运算转化为具象的动态过程。

---
处理用时：106.45秒
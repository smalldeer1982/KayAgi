# 题目信息

# [NOIP 2012 提高组] 国王游戏

## 题目描述

恰逢 H 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。

国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。


## 说明/提示

【输入输出样例说明】

按 $1$、$2$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $1$、$3$、$2$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $2$、$1$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按$ 2$、$3$、$1 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$；

按 $3$、$1$、$2 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；  

按$ 3$、$2$、$1$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$。

因此，奖赏最多的大臣最少获得 $2$ 个金币，答案输出 $2$。


 
【数据范围】

对于 $20\%$ 的数据，有 $1≤ n≤ 10,0 < a,b < 8$；

对于 $40\%$ 的数据，有$ 1≤ n≤20,0 < a,b < 8$；

对于 $60\%$ 的数据，有 $1≤ n≤100$；

对于 $60\%$ 的数据，保证答案不超过 $10^9$；

对于 $100\%$ 的数据，有 $1 ≤ n ≤1,000,0 < a,b < 10000$。



NOIP 2012 提高组 第一天 第二题


## 样例 #1

### 输入

```
3 
1 1 
2 3 
7 4 
4 6 ```

### 输出

```
2```

# AI分析结果



# 【算法分类】  
**贪心算法**

---

# **题解思路、算法要点与解决难点**  
## **核心思路**  
所有题解均基于**贪心策略**：按大臣左右手数字乘积升序排列，使获得最多金币的大臣金币数最小。关键证明通过**邻项交换法**：若相邻两位大臣乘积不满足升序，交换后最大值不会更大。

## **算法实现要点**  
1. **排序条件推导**：通过比较交换前后的最大值，证明当 `a_i*b_i < a_j*b_j` 时，i 应排在 j 前。
2. **高精度处理**：  
   - **乘法**：累乘左手数值，使用高精度乘低精度（如压4位优化）。  
   - **除法**：计算当前乘积除以右手值的商，记录最大商。  
3. **数据结构**：  
   - 使用数组或自定义高精度类存储大数（如 `bign` 结构体）。  
   - 部分题解采用压位技巧（如每4位存储一个数）优化空间和时间。

## **解决难点**  
- **数学证明**：严格推导排序条件的正确性（需排除直觉干扰）。  
- **高精度实现**：处理超过 `1e4000` 的大数乘除，避免溢出和超时。  
- **代码调试**：高精度运算的进位、去零等细节易出错（如 `Jerry_zpl` 提到调试1小时）。

---

# **题解评分 (≥4星)**  
1. **洛必达法则 (4.5星)**  
   - **亮点**：数学证明详尽，逻辑严密；代码包含高精度实现。  
   - **不足**：代码可读性一般，高精度部分未封装。  
   - **心得**：“证明部分反复推导，确保无漏洞”。  

2. **frankchenfu (4.5星)**  
   - **亮点**：高精度类封装清晰，代码模块化；证明简洁易懂。  
   - **关键代码**：  
     ```cpp  
     struct bign { // 高精度类封装  
         int a[MAXN], len;  
         bool operator>(const bign &rhs) { /*...*/ }  
         void operator*=(int rhs) { /*...*/ }  
     };  
     ```  

3. **VitrelosTia (4星)**  
   - **亮点**：Python代码简洁，避免手动高精度；邻项交换思路清晰。  
   - **关键片段**：  
     ```python  
     o[1:] = sorted(o[1:], key=lambda x: x[0] * x[1])  # 按乘积排序  
     ```  

---

# **最优思路或技巧提炼**  
1. **邻项交换法**：通过比较相邻元素交换后的结果，确定排序条件。  
2. **压位高精度**：每4位存储一个数，减少乘除运算次数（如 `QQ红包` 的压4位实现）。  
3. **贪心策略扩展**：类似问题（如任务调度）中，若需最小化最大值，可尝试乘积或和排序。  

---

# **同类型题与算法套路**  
- **通用套路**：贪心排序 + 高精度处理。  
- **类似题目**：  
  1. **P1248 加工生产调度**（按加工时间差值排序）  
  2. **P2123 皇后游戏**（邻项交换法推导排序条件）  
  3. **P1009 阶乘之和**（高精度累加与乘法）  

---

# **推荐相似知识点题目**  
1. **P1083 [NOIP 2012 提高组] 借教室**（二分 + 差分）  
2. **P1090 [NOIP 2004 提高组] 合并果子**（贪心 + 优先队列）  
3. **P1012 [NOIP 1998 提高组] 拼数**（字符串排序贪心）  

---

# **个人心得摘录**  
- **Jerry_zpl**：“高精度乘除的进位处理极易出错，需逐位验证。”  
- **aiyougege**：“Python的浮点误差需用 `divmod` 规避，整数运算更可靠。”  
- **No_commander**：“邻项交换法需严格分情况讨论，避免直觉误导。”  

---

# **可视化与算法演示**  
## **动画设计**  
- **像素风格队列**：  
  - 用色块表示大臣，左/右手数值显示在两侧。  
  - **高亮比较**：相邻块比较时，显示 `a_i*b_i` 与 `a_j*b_j`，绿色箭头指示正确顺序。  
- **高精度过程**：  
  - 展示累乘过程，数字以4位一组滚动更新。  
  - 除法时，动态分割大数并计算商。  

## **交互功能**  
- **步进控制**：单步执行排序与高精度运算。  
- **音效**：  
  - 正确交换时播放“叮”声，错误时“哔”声。  
  - 背景音乐为8-bit风格循环曲目。  

## **代码片段（Canvas绘制）**  
```javascript  
// 绘制大臣队列（伪代码）  
function drawQueue(ctx, ministers) {  
  ministers.forEach((m, i) => {  
    ctx.fillStyle = i === currentCompare ? "#FF0000" : "#00FF00";  
    ctx.fillRect(i * 60, 100, 50, 30); // 绘制大臣方块  
    ctx.fillText(`L:${m.a}`, i * 60 + 5, 110);  
    ctx.fillText(`R:${m.b}`, i * 60 + 5, 130);  
  });  
}  
```  

---

# **完整题解代码示例（frankchenfu）**  
```cpp  
#include <cstdio>  
#include <algorithm>  
using namespace std;  
const int MAXN = 1010;  

struct bign {  
    int a[4000], len;  
    bign(int x=0) { /* 初始化 */ }  
    void operator*=(int x) { /* 高精度乘低精度 */ }  
    bign operator/(int x) { /* 高精度除低精度 */ }  
    bool operator>(const bign &x) { /* 比较大小 */ }  
};  

struct Node { int a, b; } p[MAXN];  

int main() {  
    int n; scanf("%d", &n);  
    for (int i=0; i<=n; i++) scanf("%d%d", &p[i].a, &p[i].b);  
    sort(p+1, p+n+1, [](Node x, Node y) { return x.a*x.b < y.a*y.b; });  

    bign mul = p[0].a, ans = 0;  
    for (int i=1; i<=n; i++) {  
        bign tmp = mul / p[i].b;  
        if (tmp > ans) ans = tmp;  
        mul *= p[i].a;  
    }  
    ans.print();  
    return 0;  
}  
```  

---

**总结**：本题需掌握贪心排序的数学证明与高精度实现，核心是对乘积排序和高效处理大数运算。

---
处理用时：94.48秒
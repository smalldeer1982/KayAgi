# 题目信息

# [USACO1.1] 坏掉的项链 Broken Necklace

## 题目描述

你有一条由 $n$ 个红色的，白色的，或蓝色的珠子组成的项链，珠子是随意安排的。 这里是 $n=29$ 的两个例子:

![](https://cdn.luogu.com.cn/upload/image_hosting/i7imvc0g.png) 

第一和第二个珠子在图片中已经被作记号。

图片 A 中的项链可以用下面的字符串表示：

`brbrrrbbbrrrrrbrrbbrbbbbrrrrb`

假如你要在一些点打破项链，展开成一条直线，然后从一端开始收集同颜色的珠子直到你遇到一个不同的颜色珠子，在另一端做同样的事(颜色可能与在这之前收集的不同)。 确定应该在哪里打破项链来收集到最大数目的珠子。

例如，在图片 A 中的项链中，在珠子 $9$ 和珠子 $10$ 或珠子 $24$ 和珠子 $25$ 之间打断项链可以收集到 $8$ 个珠子。

白色珠子什么意思?

在一些项链中还包括白色的珠子(如图片B) 所示。

当收集珠子的时候，一个被遇到的白色珠子可以被当做红色也可以被当做蓝色。

表现含有白珠项链的字符串将会包括三个符号 `r`，`b`，`w` 。

写一个程序来确定从一条被给出的项链可以收集到的珠子最大数目。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$3\le n \le 350$

题目翻译来自NOCOW。

USACO Training Section 1.1

## 样例 #1

### 输入

```
29 
wwwbbrwrbrbrrbrbrwrwwrbwrwrrb
```

### 输出

```
11```

# AI分析结果



## 算法分类
**环形字符串处理 + 贪心/模拟**

---

## 综合分析与结论
### 核心问题
在环形项链中寻找断点，使得收集的左右两侧同色珠子（允许白色作为任意颜色）总和最大。核心难点在于：
1. **环形处理**：需避免数组越界并处理首尾相连的情况
2. **白色灵活性**：白色珠子可动态视为红/蓝，需在遍历时动态决策
3. **最大连续收集**：需高效计算左右两侧最大可收集长度

### 算法核心流程
1. **环形展开**：将字符串复制为双倍/三倍长度，消除环形边界
2. **动态颜色维护**：
   - 向左收集时，若遇到白色则继承后续颜色
   - 向右收集时，动态更新当前基准颜色
3. **贪心策略**：在颜色切换点计算左右总和，维护最大值

---

## 题解清单 (≥4星)

### 1. 青衫白叙（★★★★★）
**亮点**：
- 线性时间复杂度 O(n)，单次遍历完成计算
- 巧用 `a, b, w` 变量跟踪左右段长度与白色计数
- 代码极简（仅 20 行），无冗余数据结构

**核心逻辑**：
```cpp
for(int i = 0; i < n<<1; i++) {
    if(s[i] == 'w') { b++,w++; } 
    else if(s[i] == c){ b++,w=0; }
    else {
        ans = max(ans, a + b); // 更新最大值
        a = b - w; // 左段继承右段非白色部分
        b = w + 1; // 右段继承白色部分
        w = 0;
        c = s[i];
    }
}
```

### 2. w_y_c（★★★★☆）
**亮点**：
- 三倍字符串处理环形，逻辑直观
- 单独处理白色断点的两种可能性
- 边界条件处理完善

**关键步骤**：
```cpp
a = a + a + a; // 三倍展开
for(int i = n; i < 2*n; i++) {
    if(a[i] == 'w') { // 处理白色断点
        a[i] = 'r'; ans = max(ans, f(i));
        a[i] = 'b'; ans = max(ans, f(i));
        a[i] = 'w';
    }
    ans = max(ans, f(i)); // 普通断点
}
```

### 3. 田阙西（★★★★☆）
**亮点**：
- 动态规划预处理左右累计值
- 四组数组分别维护红/蓝的左右最大长度
- 避免重复计算，效率稳定

**预处理逻辑**：
```cpp
// 向左预处理
for(int i=1; i<=n*2; i++) {
    if(c[i] == 'w') { lR[i] = lR[i-1]+1; lB[i] = lB[i-1]+1; }
    else if(c[i] == 'r') lR[i] = lR[i-1]+1;
    else lB[i] = lB[i-1]+1;
}
// 向右预处理同理
```

---

## 最优思路提炼
1. **环形展开**：将字符串复制为 2-3 倍长度，线性化处理环形问题
2. **动态颜色切换**：维护当前基准颜色，遇到新颜色时更新左右段
3. **白色继承机制**：将连续的白色段计入当前段，颜色切换时继承到对侧
4. **贪心更新策略**：在颜色变化点计算最大值，避免全遍历

---

## 同类问题推荐
1. **环形最大子数组和**（LeetCode 918）
2. **颜色交替的最长路径**（洛谷 P1144）
3. **环形链表检测**（LeetCode 141）
4. **连续字符处理**（洛谷 P1563）

---

## 可视化设计
### 动画方案
1. **颜色标记**：
   - 红色块、蓝色块、白色半透明块
   - 当前处理位置用闪烁边框高亮
2. **指针运动**：
   - 左右指针向两侧扩展，实时显示收集长度
   - 遇到颜色变化时显示断点标记
3. **数据面板**：
   - 实时显示 `a（左段长度）`, `b（右段长度）`, `w（白色计数）`
   - 历史最大值用不同颜色标注

### 复古像素风格
- **8位调色板**：红(#FF0000)、蓝(#0000FF)、白(#FFFFFF)、背景(#000000)
- **音效设计**：
  - 收集珠子：8-bit 短促 "哔" 声
  - 颜色切换：下滑音效
  - 最大更新：上扬旋律
- **Canvas 网格**：珠子显示为 16x16 像素方块，带扫描线特效

---

## 核心代码实现（青衫白叙方案）
```cpp
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
char s[700],c;
int a, b, w, ans;
int main(){
    int n;
    scanf("%d%s",&n,s);
    memcpy(s+n,s,n); // 双倍展开
    for(int i= 0; i < n<<1; i++) {
        if(s[i] == 'w') b++, w++;
        else if(s[i] == c) b++, w=0;
        else {
            ans = max(ans, a + b);
            a = b - w; // 左段继承非白色部分
            b = w + 1; // 右段继承白色
            w = 0;
            c = s[i];
        }
    }
    ans = max(ans, a + b);
    printf("%d\n",min(ans,n));
}
```

---

## 总结
**最优选择**：青衫白叙的线性扫描法，在效率与简洁性上达到最佳平衡。其通过动态维护左右段长度与白色计数，在 O(n) 时间内解决问题，适合大规模数据且无需复杂预处理。

---
处理用时：77.16秒
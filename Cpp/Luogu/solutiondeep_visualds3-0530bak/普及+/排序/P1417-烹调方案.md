# 题目信息

# 烹调方案

## 题目背景

由于你的帮助，火星只遭受了最小的损失。但 gw 懒得重建家园了，就造了一艘飞船飞向遥远的 earth 星。不过飞船飞到一半，gw 发现了一个很严重的问题：肚子饿了 ~。

gw 还是会做饭的，于是拿出了储藏的食物准备填饱肚子。gw 希望能在 $T$ 时间内做出最美味的食物，但是这些食物美味程度的计算方式比较奇葩，于是绝望的 gw 只好求助于你了。

## 题目描述

一共有 $n$ 件食材，每件食材有三个属性，$a_i$，$b_i$ 和 $c_i$，如果在 $t$ 时刻完成第 $i$ 样食材则得到 $a_i-t\times b_i$ 的美味指数，用第 $i$ 件食材做饭要花去 $c_i$ 的时间。

众所周知，gw 的厨艺不怎么样，所以他需要你设计烹调方案使得美味指数最大。

## 说明/提示

### 数据范围及约定

- 对于 $40\%$ 的数据 $1 \le n \le 10$；
- 对于 $100\%$ 的数据 $1 \le n \le 50$。

所有数字均小于 $10^5$。

### 题目来源

tinylic 改编


## 样例 #1

### 输入

```
74 1
502
2
47
```

### 输出

```
408```

# AI分析结果



## 算法分类
**动态规划（排序+01背包）**

---

## 题解思路与核心难点

### 核心思路
1. **排序推导**：通过数学推导相邻两个物品的最优顺序，得出排序条件 `c[i] * b[j] < c[j] * b[i]`，确保先处理相邻物品时总价值更大。
2. **动态规划**：排序后转化为01背包问题，状态 `dp[j]` 表示时间 `j` 能获得的最大美味值，转移时计算 `a_i - j*b_i` 的时变价值。

### 难点对比
- **传统01背包缺陷**：传统背包物品价值固定，但本题价值随时间衰减，需通过排序确定处理顺序。
- **溢出风险**：多个题解强调必须用 `long long` 存储中间值，否则大数相乘会溢出（如 `c[i]*b[j]` 在排序比较时可能超过 `int` 范围）。

---

## 题解评分（≥4星）

### 1. kkksc03（★★★★★）
- **亮点**：最早给出数学推导，代码清晰且用 `memset` 初始化状态为-1（表示不可达），最终遍历所有时间取最大值。
- **代码片段**：
  ```cpp
  sort(a, a + n, cmp); // 按 c[x]*b[y] < c[y]*b[x] 排序
  for (i = 0; i < n; i++)
    for (j = T; j >= a[i].c; --j)
      f[j + a[i].c] = max(f[j + a[i].c], f[j] + a[i].a - (j + a[i].c) * a[i].b);
  ```

### 2. zjy111（★★★★☆）
- **亮点**：用通俗语言解释排序原理，强调 `long long` 必要性，给出错误代码对比。
- **关键注释**：
  ```cpp
  // 三年OI一场空, 不开long long见祖宗！！！
  bool cmp(thing a,thing b){ return a.b*b.c>b.b*a.c; } // 排序条件化简
  ```

### 3. henry_y（★★★★☆）
- **亮点**：手写完整推导过程，给出排序条件的数学证明，代码用 `-b[j]*c[i] > -b[i]*c[j]` 等效条件。
- **推导片段**：
  ```
  -b[j]*c[i] > -b[i]*c[j] → b[i]*c[j] > b[j]*c[i] → 排序条件成立
  ```

---

## 最优思路提炼
1. **排序条件**：通过交换相邻物品推导出 `c[i]*b[j] < c[j]*b[i]`，确保全局最优。
2. **状态设计**：用一维数组 `dp` 倒序更新，避免重复选择。
3. **时间计算**：转移时直接用 `j + c[i]` 作为完成时间，避免多次累加。

---

## 类似题目推荐
1. **P1064 金明的预算方案**（依赖物品的背包问题）
2. **P2217 切蛋糕**（时变价值+贪心）
3. **P5020 货币系统**（动态规划与数学性质结合）

---

## 可视化设计

### 动画方案
1. **排序演示**：用网格展示食材，动态比较相邻元素并交换，高亮当前比较的 `c[i]*b[j]` 和 `c[j]*b[i]`。
2. **背包更新**：在时间轴上滑动指针，显示 `dp[j]` 更新过程，用颜色区分新旧值。
   - **高亮**：当前处理的食材图标、被更新的 `dp` 格子。
3. **音效触发**：在每次 `dp` 更新或找到更大值时播放 8-bit 音效。

### 复古像素风格
- **颜色方案**：16色，用绿色表示选中食材，红色表示时间耗尽。
- **Canvas 绘制**：食材显示为像素方块，背包状态用网格表示，右侧显示实时最大美味值。
- **自动演示**：按空格键暂停/继续，方向键调整速度。

---

## 核心代码实现
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
typedef long long LL;
const int MAXN = 1e5+5;

struct Node { LL a, b, c; };
LL dp[MAXN], ans;
Node arr[55];

bool cmp(Node x, Node y) {
    return x.c * y.b < y.c * x.b;
}

int main() {
    int T, n; cin >> T >> n;
    for (int i=0; i<n; i++) cin >> arr[i].a;
    for (int i=0; i<n; i++) cin >> arr[i].b;
    for (int i=0; i<n; i++) cin >> arr[i].c;
    
    sort(arr, arr+n, cmp);
    memset(dp, 0x8f, sizeof(dp)); // 初始化为极小值
    dp[0] = 0;
    
    for (int i=0; i<n; i++) {
        for (int j=T; j>=arr[i].c; j--) {
            LL val = arr[i].a - j * arr[i].b;
            dp[j] = max(dp[j], dp[j - arr[i].c] + val);
        }
    }
    for (int i=0; i<=T; i++) ans = max(ans, dp[i]);
    cout << ans << endl;
    return 0;
}
```

---

## 个人心得摘录
> “当发现部分数据WA时，先检查是否所有中间变量都用了 `long long`，尤其是排序条件和 `a_i - t*b_i` 计算。” —— zjy111

> “记忆化搜索虽然直观，但面对T=1e5时会有栈溢出风险，必须用滚动数组优化。” —— zyxzrzxm

---
处理用时：90.02秒
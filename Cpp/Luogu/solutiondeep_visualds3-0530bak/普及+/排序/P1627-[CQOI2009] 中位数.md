# 题目信息

# [CQOI2009] 中位数

## 题目描述

给出 $1,2,...,n$ 的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是 $b$。中位数是指把所有元素从小到大排列后，位于中间的数。

## 说明/提示

#### 数据规模与约定

对于 $30\%$ 的数据中，满足 $n \le 100$；

对于 $60\%$ 的数据中，满足 $n \le 1000$；

对于 $100\%$ 的数据中，满足 $n \le 100000,1 \le b \le n$。

## 样例 #1

### 输入

```
7 4
5 7 2 4 3 1 6 ```

### 输出

```
4```

# AI分析结果



---

## 算法分类
**前缀和与差值统计**

---

## 综合分析与结论

### 核心算法逻辑
所有题解的核心思路均围绕「相对差值统计」展开：
1. **问题转化**：将原数组转换为以中位数b为基准的-1/0/1数组，比b大记为1，小记为-1，等于记为0。此时问题转化为：寻找包含0且和为0的奇数长度区间。
2. **前缀和统计**：以b的位置为中心，向左统计前缀和差值（比b大的数量 - 比b小的数量），向右统计后缀和差值，用哈希表或数组记录差值出现次数。
3. **互补匹配**：对于左半部分的差值k，在右半部分寻找差值-k，通过乘法原理计算匹配数。

### 实现难点与解决
- **负数下标处理**：差值可能为负，通过数组偏移（如加1e5）或使用`std::map`解决。
- **奇数长度限制**：部分题解利用奇偶性分桶统计，但最优解法通过强制包含中心点自动满足奇数长度条件。
- **高效查询**：数组查询复杂度O(1)优于哈希表的O(logn)，成为主流选择。

### 可视化设计思路
1. **动画流程**：
   - **步骤1**：高亮中心点b，左右展开扫描，实时显示当前差值。
   - **步骤2**：用动态颜色标记左侧差值的存储（如蓝色格子表示数组偏移后的位置）。
   - **步骤3**：右侧扫描时，高亮当前差值并显示在右侧数组中查找互补值的过程（如红色闪烁匹配项）。
2. **交互功能**：支持暂停、步进、速度调节，可拖拽查看任意时刻的前缀和状态。

---

## 题解评分（≥4星）

### 1. Heartlessly（5星）
- **亮点**：数组偏移处理负数，O(n)时间复杂度，代码简洁高效。
- **关键代码**：
  ```cpp
  l[maxN] = 1, r[maxN] = 1;  // 初始化偏移后的0位置
  for (LL i = tmp - 1; i >= 1; i--) { sum += a[i]; l[sum + maxN]++; }
  ```

### 2. qwerta（5星）
- **亮点**：极简实现，利用前缀和的奇偶性分桶统计，代码量最小。
- **关键代码**：
  ```cpp
  for (int i=0;i<=200000;i++) sum += mark1[i]*mark2[i];
  ```

### 3. 诗乃（4星）
- **亮点**：清晰的双指针遍历逻辑，注释详细，适合教学。
- **个人心得**：强调数组下标偏移处理负数，避免哈希表开销。

---

## 最优思路与技巧

### 关键技巧
1. **差值偏移映射**：将差值k映射到数组的`k + MAXN`位置，消除负数影响。
2. **中心点分割法**：强制子序列包含中心点，自动满足奇数长度条件。
3. **互补值匹配**：利用乘法原理快速统计左右两部分的匹配对数。

### 同类型题套路
- **前缀和+哈希表**：如「和为K的子数组」（LeetCode 560）。
- **奇偶性分桶**：如「连续子数组和为k的倍数」（LeetCode 523）。

---

## 推荐练习题
1. **P3406** 海底高铁 - 前缀和统计区间覆盖次数。
2. **P4305** 不重复数字 - 哈希表维护唯一性。
3. **P3131** 子序列查询 - 前缀和与差值匹配。

---

## 个人心得摘录
- **调试教训**：初始使用`map`的题解在1e5数据下TLE，改用数组后效率提升10倍（作者：B_1168）。
- **思维突破**：将绝对数值比较转化为相对差值统计，极大简化问题（作者：Heartlessly）。

---

## 算法可视化（复古像素风格）

### 实现要点
1. **像素风格**：8-bit色板（16色），网格布局，数组元素显示为彩色方块。
2. **动画效果**：
   - **中心扫描**：中心点闪烁，左右扫描时显示绿色光标移动。
   - **差值显示**：当前差值以浮动数字跟随光标，匹配成功时播放「叮」音效。
   - **数组更新**：左侧数组格子渐变为蓝色，右侧查找时目标格子闪烁红色。
3. **交互设计**：
   - **速度滑块**：控制扫描速度（1x~10x）。
   - **自动演示**：AI自动运行，模拟「贪吃蛇」式路径覆盖。

### 代码片段（JS Canvas）
```javascript
// 绘制前缀和数组
function drawPrefixSum(ctx, sums, offsetX, offsetY) {
  sums.forEach((val, idx) => {
    ctx.fillStyle = getColor(val); // 根据值选择颜色
    ctx.fillRect(offsetX + idx*16, offsetY, 15, 15);
    ctx.fillText(val, offsetX + idx*16 +2, offsetY +12);
  });
}

// 播放匹配音效
function playMatchSound() {
  const audio = new Audio('data:audio/wav;base64,UklGRl...');
  audio.play();
}
```

---

**可视化演示链接**：[模拟器地址](https://algorithm-visualizer.org/)（示例实现需结合具体代码）

---
处理用时：93.79秒
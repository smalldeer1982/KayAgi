# 题目信息

# [ZJOI2004] 午餐

## 题目描述

上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。

THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。

现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。

假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。

现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。


## 说明/提示

所有输入数据均为不超过200的正整数。


## 样例 #1

### 输入

```
5

2 2

7 7

1 3

6 4

8 5

```

### 输出

```
17```

# AI分析结果



### **唯一算法分类**  
贪心 + 动态规划（背包问题变种）

---

### **综合分析与结论**

#### **核心思路与难点**
1. **贪心排序**：  
   将所有人按**吃饭时间从大到小排序**。正确性证明：若两人交换顺序后总结束时间不会更优，故必须保证吃饭慢的先打饭。
   
2. **动态规划状态设计**：  
   定义 `dp[i][j]` 表示前 `i` 个人，1号窗口打饭总时间为 `j` 时的最早结束时间。利用**前缀和**压缩状态，另一窗口时间由 `sum[i] - j` 计算。

3. **状态转移**：  
   - **放入1号窗口**：`dp[i][j] = min(dp[i][j], max(dp[i-1][j - a], j + b))`  
   - **放入2号窗口**：`dp[i][j] = min(dp[i][j], max(dp[i-1][j], sum[i] - j + b))`  
   每次转移需比较两种情况的结束时间，取最小值。

4. **压缩空间技巧**：  
   使用滚动数组或逆序更新优化空间复杂度至 `O(n * sum_a)`。

---

### **题解评分（≥4星）**

1. **M_seа (★★★★★)**  
   - **亮点**：代码简洁，状态转移清晰，利用前缀和优化空间。  
   - **关键代码**：
     ```cpp
     f[i][j] = min(f[i][j], max(f[i-1][j-s[i].a], j + s[i].b));
     f[i][j] = min(f[i][j], max(f[i-1][j], sum[i] - j + s[i].b));
     ```

2. **TH讠NK (★★★★☆)**  
   - **亮点**：详细贪心证明，结合物理模型解释时间分配，适合数学推导。  
   - **关键代码**：
     ```cpp
     f[i][j] = min(f[i][j], max(f[i-1][j - a_i], j + b_i));
     ```

3. **lover_ (★★★★☆)**  
   - **亮点**：通过对比两人交换顺序的结束时间，直观证明贪心正确性。  
   - **关键代码**：
     ```cpp
     max(a1 + a2 + b2, a1 + b1) < max(a1 + a2 + b1, a2 + b2)
     ```

---

### **最优思路与技巧提炼**

1. **贪心预处理**：  
   排序策略是解题关键，需严格证明其正确性（类似国王游戏中的交换法）。

2. **状态压缩**：  
   通过前缀和将二维状态压缩为一维，减少空间复杂度。

3. **逆向更新**：  
   动态规划时逆序更新 `j`，避免覆盖未处理的状态，类似背包问题优化。

---

### **同类型题推荐**

1. **[P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541)**  
   - 类似思路：限制条件下的动态规划，需预处理步数分配。

2. **[P1280 尼克的任务](https://www.luogu.com.cn/problem/P1280)**  
   - 逆向动态规划，处理时间区间分配问题。

3. **[P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)**  
   - 背包问题变种，需结合条件选择策略。

---

### **可视化与算法演示**

#### **动态规划表填充动画**
- **Canvas 网格绘制**：  
  - 横向表示1号窗口时间 `j`，纵向表示处理到第 `i` 个人。  
  - **颜色标记**：当前处理的 `i` 用绿色高亮，转移路径用红色箭头标识。  
  - **步进控制**：单步展示每一步 `j` 的更新过程，显示 `max` 比较结果。

#### **复古像素风格设计**
- **8位音效**：  
  - **转移成功**：播放短促“滴”声。  
  - **更新最小值**：播放上升音调。  
- **像素动画**：  
  - 人物以像素方块表示，从队列进入窗口时显示打饭时间进度条。  
  - 结束时间用红色数字在窗口上方弹出。

#### **交互控制面板**
- **速度调节**：滑块控制动画速度（100ms~2s/步）。  
- **自动演示**：AI 模式自动填充表格，高亮最优路径。  

---

### **关键代码实现（动态规划部分）**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 210;
struct Person { int cook, eat; };
Person s[N];
int sum[N], dp[N][N*N];

int main() {
    int n; cin >> n;
    for (int i = 1; i <= n; i++) 
        cin >> s[i].cook >> s[i].eat;
    sort(s+1, s+n+1, [](auto& a, auto& b) { 
        return a.eat > b.eat; 
    });
    
    for (int i = 1; i <= n; i++)
        sum[i] = sum[i-1] + s[i].cook;
    
    memset(dp, 0x3f, sizeof(dp));
    dp[0][0] = 0;
    
    for (int i = 1; i <= n; i++) {
        for (int j = sum[i]; j >= 0; j--) {
            int a = s[i].cook, b = s[i].eat;
            if (j >= a) // 放入1号窗口
                dp[i][j] = min(dp[i][j], max(dp[i-1][j-a], j + b));
            // 放入2号窗口
            dp[i][j] = min(dp[i][j], max(dp[i-1][j], sum[i] - j + b));
        }
    }
    
    int ans = INT_MAX;
    for (int j = 0; j <= sum[n]; j++)
        ans = min(ans, dp[n][j]);
    cout << ans << endl;
    return 0;
}
```

---

### **总结**
本题通过贪心预处理优化动态规划状态，结合背包思想压缩维度，是典型的多阶段决策问题。可视化设计可帮助理解状态转移的取舍过程，而复古风格增强学习趣味性。

---
处理用时：87.27秒
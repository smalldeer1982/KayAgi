# 题目信息

# [NOIP 2015 普及组] 求和

## 题目背景

NOIP2015 普及组 T3

## 题目描述

一条狭长的纸带被均匀划分出了 $n$ 个格子，格子编号从 $1$ 到 $n$。每个格子上都染了一种颜色 $color_i$ 用 $[1,m]$ 当中的一个整数表示），并且写了一个数字 $number_i$。

| 编号 | 1 | 2 | 3 | 4 | 5 | 6 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| **颜色和数字** | $\color{blue}{5}$ | $\color{blue}{5}$ | $\color{red}{3}$ | $\color{red}{2}$ | $\color{blue}{2}$ | $\color{red}{2}$ |

定义一种特殊的三元组：$(x,y,z)$，其中 $x,y,z$ 都代表纸带上格子的编号，这里的三元组要求满足以下两个条件：

1. $x,y,z$ 都是整数，$x<y<z,y-x=z-y$。

2. $color_x=color_z$。

满足上述条件的三元组的分数规定为 $(x+z) \times (number_x+number_z)$。整个纸带的分数规定为所有满足条件的三元组的分数的和。这个分数可能会很大，你只要输出整个纸带的分数除以 $10007$ 所得的余数即可。


## 说明/提示

**样例 1 解释**

纸带如题目描述中的图所示。

所有满足条件的三元组为：$(1, 3, 5), (4, 5, 6)$。

所以纸带的分数为 $(1 + 5) \times (5 + 2) + (4 + 6) \times (2 + 2) = 42 + 40 = 82$。


对于第 $1$ 组至第 $2$ 组数据， $1 ≤ n ≤ 100, 1 ≤ m ≤ 5$；

对于第 $3$ 组至第 $4$ 组数据，$1 ≤ n ≤ 3000, 1 ≤ m ≤ 100$；

对于第 $5$ 组至第 $ 6 $ 组数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000$，且不存在出现次数超过 $ 20 $ 的颜色；

对于全部 $10$ 组数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000, 1 ≤ color_i ≤ m,1≤number_i≤100000$。


## 样例 #1

### 输入

```
6 2
5 5 3 2 2 2
2 2 1 1 2 1```

### 输出

```
82
```

## 样例 #2

### 输入

```
15 4
5 10 8 2 2 2 9 9 7 7 5 6 4 2 4
2 2 3 3 4 3 3 2 4 4 4 4 1 1 1```

### 输出

```
1388```

# AI分析结果



### 唯一算法分类  
无算法分类（核心为数学推导+分组统计）  

---

### 综合分析与结论  
**核心思路**：  
1. **数学推导**：将三元组分数公式拆解为可分组统计的形式，避免暴力枚举。  
2. **分组统计**：按颜色和奇偶性分组，每组维护数值和、元素数量等统计值。  
3. **线性遍历**：遍历每个元素时，利用组内统计值快速计算贡献。  

**解决难点**：  
- **公式拆解**：将 $(x+z)(num_x+num_z)$ 拆分为 $x \cdot num_x + z \cdot num_z + x \cdot num_z + z \cdot num_x$，并发现与组内统计值的关联性。  
- **动态维护统计值**：每组维护 `sum`（数值和）、`cnt`（元素数）、`id_sum`（编号和）、`prod_sum`（编号与数值乘积和），通过一次遍历完成统计。  

**可视化设计**：  
- **颜色分组**：用不同颜色区分红蓝两组（奇偶性），每组按颜色标签动态扩展。  
- **关键变量高亮**：当处理元素时，高亮其所在组的 `sum` 和 `cnt`，并显示当前贡献计算公式。  
- **步进控制**：支持单步执行，展示每个元素如何更新统计值并计算贡献。  
- **复古像素风格**：用 8-bit 像素块表示元素，奇数组用绿色，偶数组用蓝色，统计值以浮动文字显示。  

---

### 题解清单（≥4星）  
1. **Victorique_De_Blois（5星）**  
   - **亮点**：代码最简洁，直接维护 `sum[c][g]` 和 `cnt[c][g]`，公式推导清晰。  
   - **核心代码**：  
     ```cpp  
     for(int i=1; i<=n; i++) {  
         int c = color[i], g = i%2;  
         ans += i * (sum[c][g] + (cnt[c][g]-2)*number[i]);  
     }  
     ```  

2. **Sol1（4.5星）**  
   - **亮点**：通过公式 $\sum (cnt-2) \cdot x \cdot num_x + x \cdot sum$ 直接计算贡献。  
   - **心得摘录**：“每个元素的贡献仅与组内统计值相关，无需存储所有元素。”  

3. **WsW_（4星）**  
   - **亮点**：用 `s_c[c][g][0~3]` 多维数组维护统计值，代码结构清晰易扩展。  

---

### 最优思路提炼  
1. **分组统计**：按颜色和奇偶性分组，每组维护 `sum`（数值和）、`cnt`（元素数）。  
2. **贡献公式**：每个元素的贡献为 $i \cdot (sum + (cnt-2) \cdot num_i)$，其中 `sum` 是组内数值和。  
3. **一次遍历**：遍历时动态更新统计值，避免存储所有元素。  

---

### 相似题目推荐  
1. **P1982 小朋友的数字**（分组统计+前缀最值）  
2. **P3131 [USACO16JAN] Subsequences Summing to Sevens S**（同余分组）  
3. **P3406 海底高铁**（区间统计+差分优化）  

---

### 核心代码实现  
```cpp  
const int MOD = 10007;  
int n, m, color[N], num[N];  
int sum[N][2], cnt[N][2];  // sum[c][g]: 颜色c且奇偶性g的数值和  

int main() {  
    cin >> n >> m;  
    for (int i=1; i<=n; i++) cin >> num[i];  
    for (int i=1; i<=n; i++) {  
        int c, g;  
        cin >> c;  
        g = i % 2;  
        // 动态统计  
        sum[c][g] = (sum[c][g] + num[i]) % MOD;  
        cnt[c][g]++;  
    }  

    int ans = 0;  
    for (int i=1; i<=n; i++) {  
        int c = color[i], g = i%2;  
        int s = sum[c][g], k = cnt[c][g];  
        ans = (ans + i * (s + (k-2)*num[i] % MOD)) % MOD;  
    }  
    cout << ans;  
}  
```  

---

### 可视化设计（伪代码）  
```javascript  
// Canvas 绘制逻辑  
function drawGrid() {  
    // 奇数组用绿色块，偶数组用蓝色块  
    groups.forEach(group => {  
        group.elements.forEach(elem => {  
            ctx.fillStyle = group.isOdd ? "#00FF00" : "#0000FF";  
            ctx.fillRect(elem.x, elem.y, 16, 16);  
        });  
        // 显示统计值  
        ctx.fillText(`sum=${group.sum}`, group.x, group.y);  
        ctx.fillText(`cnt=${group.cnt}`, group.x, group.y + 20);  
    });  
}  

// 步进动画  
function step() {  
    let elem = elements[currentIndex];  
    // 高亮当前元素  
    highlight(elem);  
    // 更新统计值  
    groups[elem.c][elem.g].sum += elem.num;  
    groups[elem.c][elem.g].cnt++;  
    // 计算贡献  
    let contribution = elem.i * (sum + (cnt-2)*elem.num);  
    showContribution(contribution);  
    currentIndex++;  
}  
```  

**复古音效设计**：  
- **点击元素**：8-bit “哔”声（Web Audio API 生成 200Hz 方波）  
- **更新统计值**：短促“咔嗒”声（白噪声脉冲）  
- **计算完成**：上升音阶（C大调三和弦）  

---

通过分组统计和数学优化，将 O(n²) 复杂度降至 O(n)，是此类问题的经典解决范式。

---
处理用时：86.27秒
# 题目信息

# [USACO10OCT] Dinner Time S

## 题目描述

农场主约翰的 $N$（$1 \le N \le 10 ^ 3$）头奶牛被编号为 $1 \sim N$，它们正在保加利亚参加 IOI。奶牛们喜欢保加利亚的太阳并享受着它们的假日，一切看起来都没问题。

变化发生在晚餐时间前后。这家餐馆很小，只有 $M$（$1 \le M \le N$）个座位，编号为 $1 \sim M$。每头牛从一个位置 $CX_i$，$CY_i$ 进入餐馆（$-10 ^ 6 \le CX_i \le 10 ^ 6,-10 ^ 6 \le CY_i \le 10 ^ 6$）；座位可以在 $SX_j$，$SY_j$ 找到（$-10 ^ 6 \le SX_j \le10 ^ 6,-10 ^ 6\le SY_j\le 10 ^ 6$）。



奶牛有一种非常有效的（尽管很原始）方法把自己分配到座位上。一旦某只奶牛确定她会先到某个座位上，她就会尽快赶到那里（所有的奶牛都跑得一样快）。



农场主约翰的奶牛和所有获奖的奶牛一样，跳过座位、桌子或其他奶牛都没有问题，因此它们可以直线奔跑。当多头牛可以同时到达一个座位时，最老的牛（在输入数据中出现得更早的牛）获得座位。当一头牛可以第一个到达多个座位时，她也会选择在输入中最早出现的座位。



一些奶牛将不能吃晚饭，这些吃不到饭的饥饿的奶牛正集体计划偷农场主约翰自己的食物。农场主约翰想要一份他应该提防的奶牛名单。（如果没有饥饿的奶牛，则输出 $0$）。你能帮他吗？



注：在计算中可能会有超过 $32$ 位整数范围但在 $64$ 位整数范围内的数。

------------

## 样例 #1

### 输入

```
2 1 
0 1 
1 0 
1 10 
```

### 输出

```
2 
```

# AI分析结果



---

### 唯一算法分类  
**模拟**

---

### 题解思路、算法要点与解决难点  
**核心逻辑**：  
1. **按顺序处理座位**：每个座位按输入顺序处理，保证优先选择更早出现的座位。  
2. **最近牛选择**：对每个座位，遍历所有未被分配的牛，计算其与座位的平方距离（无需开根），记录最小距离的牛。  
3. **输入顺序优先级**：若多牛距离相同，选择输入顺序更早（编号更小）的牛。  
4. **特判全分配情况**：若所有牛都有座位，输出 `0`。  

**解决难点**：  
- **正确处理输入顺序**：座位和牛的匹配均需按输入顺序处理，而非随机排序。  
- **优化距离计算**：用平方距离代替实际距离比较，避免浮点运算。  

---

### 题解评分（≥4星）  
1. **yinhy09（★★★★★）**  
   - **亮点**：外层循环座位、内层循环牛的暴力模拟，正确处理输入顺序和距离比较。  
   - **代码优化**：使用 `flag` 数组标记已分配的牛，避免重复计算。  
   - **特判处理**：明确处理 `n == m` 的情况。  

2. **hyc1026（★★★★☆）**  
   - **结构清晰**：使用 `mindis` 和 `pos` 记录当前最优解，代码逻辑清晰。  
   - **数据类型**：显式标注 `1ll` 防止溢出。  

3. **封禁用户（★★★★☆）**  
   - **特判强调**：明确处理 `n == m` 的输出，避免 WA。  
   - **调试提示**：注释中强调不开 `long long` 的风险。  

---

### 最优思路或技巧提炼  
1. **暴力模拟法**：  
   - **外层循环座位**：保证按输入顺序处理每个座位。  
   - **内层循环牛**：对每个座位，遍历所有未被分配的牛，计算平方距离。  
   - **优先级处理**：当距离相同时，选择输入顺序更早的牛（即编号更小的牛）。  
2. **代码优化**：  
   - 使用 `flag` 数组标记已分配牛的索引，避免重复计算。  
   - 用平方距离比较代替实际距离计算，节省计算时间。  

---

### 同类型题或类似算法套路  
- **贪心分配问题**：如 LeetCode 455. Assign Cookies，按规则分配资源。  
- **模拟优先级队列**：如处理按时间顺序和优先级调度的任务。  

---

### 推荐洛谷题目  
1. **P1056 排座椅**（模拟座位分配）  
2. **P1540 机器翻译**（队列模拟资源分配）  
3. **P1199 三国游戏**（贪心策略与模拟）  

---

### 个人心得摘录  
- **不开 `long long` 见祖宗**：多个题解强调平方距离可能超过 `int` 范围。  
- **特判全分配**：若未处理 `n == m`，会 WA 测试点。  
- **输入顺序即优先级**：模拟时必须严格按照输入顺序处理。  

---

### 可视化与算法演示  
**动画方案设计**：  
1. **像素风格展示**：  
   - **奶牛与座位**：用不同颜色方块表示（如绿色奶牛、红色座位）。  
   - **当前操作**：高亮正在处理的座位和候选牛，其他元素半透明化。  
2. **关键步骤动画**：  
   - **距离计算**：在奶牛和座位间绘制线段，显示平方距离数值。  
   - **牛被选中**：被分配的牛变为灰色，座位标记为已占用。  
3. **交互控制**：  
   - **步进控制**：允许单步执行或自动播放，调节动画速度。  
   - **音效提示**：选中时播放短促音效，完成分配后播放成功音效。  

**复古像素实现**：  
```javascript
// 伪代码：Canvas 绘制关键帧  
function drawFrame(seatIndex, cowIndex) {  
  ctx.clearRect(0, 0, canvas.width, canvas.height);  
  // 绘制所有奶牛  
  cows.forEach((cow, i) => {  
    ctx.fillStyle = cow.assigned ? "#808080" : "#00FF00";  
    ctx.fillRect(cow.x, cow.y, 16, 16);  
  });  
  // 高亮当前处理的座位和候选牛  
  ctx.fillStyle = "#FF0000";  
  ctx.fillRect(seats[seatIndex].x, seats[seatIndex].y, 16, 16);  
  ctx.fillStyle = "#FFFF00";  
  ctx.fillRect(cows[cowIndex].x, cows[cowIndex].y, 16, 16);  
}  
```

---

### 核心代码实现  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1005;
long long cx[MAXN], cy[MAXN]; // 奶牛坐标
bool used[MAXN];              // 标记是否已分配

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> cx[i] >> cy[i];
    
    for (int j = 1; j <= m; j++) {
        long long sx, sy;
        cin >> sx >> sy;
        long long min_dis = LLONG_MAX;
        int chosen = -1;
        
        // 遍历所有未被分配的牛，找距离最小的
        for (int i = 1; i <= n; i++) {
            if (used[i]) continue;
            long long dx = cx[i] - sx;
            long long dy = cy[i] - sy;
            long long dis = dx * dx + dy * dy;
            if (dis < min_dis) {
                min_dis = dis;
                chosen = i;
            }
        }
        used[chosen] = true; // 标记为已分配
    }

    if (n == m) cout << 0;
    else {
        for (int i = 1; i <= n; i++) 
            if (!used[i]) cout << i << endl;
    }
    return 0;
}
```

---
处理用时：101.38秒
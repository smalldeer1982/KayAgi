# 题目信息

# 魔法

## 题目描述

cjwssb 知道是误会之后，跟你道了歉。你为了逗笑他，准备和他一起开始魔法。不过你的时间不多了，但是更惨的是你还需要完成 $n$ 个魔法任务。假设你当前的时间为 $T$，每个任务需要有一定的限制 $t_i$ 表示只有当你的 $T$ 严格大于 $t_i$ 时你才能完成这个任务，完成任务并不需要消耗时间。当你完成第 $i$ 个任务时，你的时间 $T$ 会加上 $b_i$，此时要保证 $T$ 在任何时刻都大于 $0$，那么请问你是否能完成这 $n$ 个魔法任务，如果可以，输出 $\texttt{+1}\texttt{s}$，如果不行，输出 $\texttt{-1}\texttt{s}$。


## 说明/提示

对于 $20\%$ 的数据，$n\leq10$；

对于 $100\%$ 的数据，$n\leq10^5,Z\leq10,t_i\leq10^5,T\leq10^5,-10^5\leq b_i\leq 10^5$。

By lantian

$\LaTeX$ By ⚡炭治郎⚡

## 因为历史遗留问题，博客讨论可能无法发出样例输出的字符串，可以考虑使用其他方式规避。


## 样例 #1

### 输入

```
1
2 13
1 -9
5 -3
```

### 输出

```
+1s
```

# AI分析结果



# 算法分析与题解总结

## 算法分类
**贪心算法**

---

## 题解思路与核心难点分析

### 核心思路
1. **任务分组**：将任务分为 `b≥0` 和 `b<0` 两组。
2. **正收益任务排序**：`b≥0` 的任务按 `t_i` 升序排列，优先完成门槛最低的任务以快速提升时间。
3. **负收益任务排序**：`b<0` 的任务按 `t_i + b_i` 降序排列，确保完成顺序的最优性。
4. **动态检查**：处理每个任务时检查 `T > t_i`，并维护 `T > 0`。

### 解决难点
- **负收益任务的顺序推导**：通过数学推导证明 `t_i + b_i` 的排序策略，避免因顺序错误导致无法完成所有任务。
- **时间维护的实时性**：每一步操作后必须保证时间始终严格大于0。

---

## 题解评分（≥4星）

| 题解作者       | 评分 | 关键亮点                                                                 |
|----------------|------|--------------------------------------------------------------------------|
| lwz2002        | ★★★★☆ | 完整推导排序策略，代码简洁易懂，处理分组逻辑清晰。                     |
| 风中の菜鸡     | ★★★★☆ | 数学推导详细，代码未展示但思路明确，重点突出贪心策略。                 |
| 长安何处在     | ★★★★☆ | 引入逆向思维转化问题，代码实现独特，通过倒序处理简化逻辑。             |

---

## 最优思路与技巧提炼

### 关键算法步骤
1. **分组排序策略**：
   ```cpp
   // 正收益任务排序
   sort(a + 1, a + cnt1 + 1, [](auto &x, auto &y) { return x.tim < y.tim; });
   
   // 负收益任务排序
   sort(f + 1, f + cnt2 + 1, [](auto &x, auto &y) { return x.tim + x.b > y.tim + y.b; });
   ```
2. **动态时间维护**：
   ```cpp
   for (任务 : 正收益组) {
       if (T <= 任务.tim) 失败;
       T += 任务.b;
   }
   for (任务 : 负收益组) {
       if (T <= 任务.tim) 失败;
       T += 任务.b;
       if (T <= 0) 失败;
   }
   ```

### 思维技巧
- **临项交换法**：通过假设两个任务的完成顺序推导最优条件，得到排序依据。
- **逆向转化**：将负收益任务的总和计算后倒序处理，转化为类似正收益的问题。

---

## 类似题目推荐
1. **P1080 国王游戏**：贪心排序策略，根据乘积确定大臣排列顺序。
2. **P1248 加工生产调度**：Johnson算法，分组排序处理任务调度。
3. **P2123 皇后游戏**：多条件排序策略，推导最优顺序。

---

## 可视化算法设计

### 动画方案
1. **任务分组展示**：
   - **正收益任务**显示为绿色方块，按 `t_i` 从小到大排列。
   - **负收益任务**显示为红色方块，按 `t_i + b_i` 从大到小排列。
2. **时间轴动态更新**：
   - 初始时间 `T` 显示为蓝色进度条。
   - 每处理一个任务时高亮当前任务方块，显示 `T > t_i?` 的判断过程。
   - 时间变化时播放上升（正收益）或下降（负收益）的动画效果，并更新数值。

### 复古像素风格
- **颜色方案**：16色调色板，正收益绿（#00FF00），负收益红（#FF0000），时间条蓝（#0000FF）。
- **音效设计**：
  - **成功处理**：8-bit上升音效（类似《超级玛丽》吃金币）。
  - **失败**：短促爆炸音效（类似《魂斗罗》中弹）。
  - **背景音乐**：循环8-bit冒险风格BGM。

### 交互功能
- **步进控制**：支持暂停/继续、单步执行。
- **自动演示**：AI按最优策略自动完成任务，展示时间变化与任务处理顺序。
- **关卡模式**：将不同测试用例设为关卡，通过后解锁更复杂数据。

---

## 核心代码实现

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

struct Task { int t, b; };

bool cmp_pos(Task &a, Task &b) { return a.t < b.t; }
bool cmp_neg(Task &a, Task &b) { return a.t + a.b > b.t + b.b; }

int main() {
    int Z; scanf("%d", &Z);
    while (Z--) {
        int n, T; scanf("%d%d", &n, &T);
        Task pos[100010], neg[100010];
        int cnt_p = 0, cnt_n = 0;
        
        for (int i = 0; i < n; i++) {
            int t, b; scanf("%d%d", &t, &b);
            if (b >= 0) pos[cnt_p++] = {t, b};
            else neg[cnt_n++] = {t, b};
        }
        
        sort(pos, pos + cnt_p, cmp_pos);
        sort(neg, neg + cnt_n, cmp_neg);
        
        bool ok = true;
        for (int i = 0; i < cnt_p; i++) {
            if (T <= pos[i].t) { ok = false; break; }
            T += pos[i].b;
        }
        for (int i = 0; i < cnt_n; i++) {
            if (T <= neg[i].t) { ok = false; break; }
            T += neg[i].b;
            if (T <= 0) { ok = false; break; }
        }
        
        puts(ok ? "+1s" : "-1s");
    }
    return 0;
}
```

---

## 总结
通过分组排序与动态检查，该问题在O(n log n)复杂度内解决。关键点在于负收益任务的排序策略推导，以及严格的时间维护条件。类似调度问题可借鉴此题的贪心策略与数学推导方法。

---
处理用时：98.29秒
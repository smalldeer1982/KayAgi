# 题目信息

# [USACO17FEB] Why Did the Cow Cross the Road I S

## 题目描述

Farmer John 的奶牛们正在学习如何有效地过马路。回想起古老的“鸡为什么要过马路？”笑话，他们认为鸡一定是过马路的专家，于是去寻找鸡来帮助它们。

事实上，鸡是非常忙碌的生物，它们只有有限的时间来帮助奶牛。农场上有 $C$ 只鸡（$1 \leq C \leq 20,000$），方便地用编号 $1 \ldots C$ 标识，每只鸡 $i$ 只愿意在确切的时间 $T_i$ 帮助一头奶牛。奶牛们从不着急，它们的日程安排更加灵活。农场上有 $N$ 头奶牛（$1 \leq N \leq 20,000$），方便地用编号 $1 \ldots N$ 标识，其中奶牛 $j$ 能够在时间 $A_j$ 到时间 $B_j$ 之间过马路。考虑到“伙伴系统”是最好的方式，每头奶牛 $j$ 理想情况下希望找到一只鸡 $i$ 来帮助她过马路；为了使它们的日程安排兼容，$i$ 和 $j$ 必须满足 $A_j \leq T_i \leq B_j$。

如果每头奶牛最多只能与一只鸡配对，每只鸡也最多只能与一头奶牛配对，请计算可以构建的最大奶牛-鸡配对数。

## 样例 #1

### 输入

```
5 4
7
8
6
2
9
2 5
4 9
0 3
8 13```

### 输出

```
3```

# AI分析结果



# 算法分类
**贪心算法**

---

## 题解思路与核心难点分析

### **核心思路**
本题要求最大化奶牛与鸡的配对数量，需满足奶牛时间区间包含鸡的时间点。核心策略为：
1. **双排序**：将奶牛按右端点升序排序，鸡按时间升序排序
2. **贪心匹配**：对每个奶牛区间，寻找最小可用鸡（满足条件的最左鸡），保证后续有更多匹配机会

### **解决难点**
- **时间复杂度优化**：暴力双重循环 O(nm) 会超时
- **高效查询可用鸡**：需快速找到满足 `A_j ≤ T_i ≤ B_j` 的最小 T_i
- **动态删除已匹配鸡**：避免重复使用同一鸡

---

## 优质题解推荐（≥4星）

### 1. **StudyingFather（★★★★★）**
- **亮点**：优先队列优化，时间复杂度 O(n log n)
- **代码简析**：
  ```cpp
  priority_queue<seg> q; // 小根堆按右端点排序
  for (每个鸡时间点 a[i]) {
    while (当前区间左端点 ≤ a[i]) q.push(区间);
    弹出右端点 < a[i] 的无效区间;
    if 堆不空: 匹配堆顶区间;
  }
  ```

### 2. **zzl_05（★★★★☆）**
- **亮点**：multiset 二分优化
- **核心代码**：
  ```cpp
  multiset<int> chickens;
  for (区间排序后) {
    auto it = chickens.lower_bound(区间左端点);
    if (*it ≤ 右端点) 匹配并删除;
  }
  ```

### 3. **MyukiyoMekya（★★★★☆）**
- **创新点**：并查集优化删除操作，避免二分后线性扫描
- **关键步骤**：
  ```cpp
  并查集维护可用鸡节点，删除时指向下一位置
  二分找到首个 ≥A_j 的鸡后直接查询并查集根节点
  ```

---

## 最优思路提炼

### **关键技巧**
1. **右端点优先排序**：确保优先处理更紧急（右端点小）的奶牛
2. **有序数据结构**：multiset/优先队列快速查找可用鸡
3. **动态维护可用资源**：匹配后立即删除鸡，避免重复

---

## 类似题目推荐
1. **P1803 线段覆盖**：区间选点最大不相交问题
2. **P2870 最佳牛围栏**：贪心+二分答案优化
3. **P2285 打鼹鼠**：时间序列动态匹配

---

## 个人心得摘录
> "第一次按左端点排序只过50分，改为右端点排序后AC。数据水也能过，但真正比赛必须优化！" —— MC_Launcher  
> "用并查集跳指针代替二分+扫描，将删除复杂度从O(n)降到O(1)" —— MyukiyoMekya

---

## 算法可视化设计

### **动画方案**
1. **元素展示**：
   - 奶牛区间：横向色块，左端绿色→右端红色渐变
   - 鸡时间点：垂直黄线标注数值
   - 当前操作：高亮闪烁当前处理的奶牛区间和候选鸡

2. **流程演示**：
   - **步骤1**：排序动画，奶牛区间按右端点从左到右排列
   - **步骤2**：遍历每个奶牛区间，从鸡序列中划出满足条件的区域
   - **步骤3**：显示二分查找过程（折半查找箭头），命中后删除鸡节点

3. **交互设计**：
   - **速度控制**：滑块调节动画速度（0.5x~3x）
   - **单步执行**：按钮逐帧查看匹配过程
   - **音效**：匹配成功时播放“叮”声，失败时“噗”声

### **复古像素风格**
- **调色板**：8位色（#FF6B6B奶牛红, #4ECDC4鸡黄, #45B7D1水域蓝）
- **Canvas绘制**：
  ```javascript
  // 绘制奶牛区间
  ctx.fillStyle = '#FF6B6B';
  ctx.fillRect(startX, yPos, width, 20);
  // 绘制鸡时间点
  ctx.fillStyle = '#4ECDC4';
  ctx.fillRect(timeX, yPos, 4, 30);
  ```

---

## 核心代码实现（multiset版）
```cpp
#include <algorithm>
#include <set>
using namespace std;

int main() {
    int C, N, t, ans = 0;
    vector<pair<int, int>> cows;
    multiset<int> chickens;
    
    // 输入并排序
    sort(chickens.begin(), chickens.end());
    sort(cows.begin(), cows.end(), [](auto &a, auto &b) {
        return a.second < b.second; // 按右端点排序
    });
    
    // 贪心匹配
    for (auto &cow : cows) {
        auto it = chickens.lower_bound(cow.first);
        if (it != chickens.end() && *it <= cow.second) {
            ans++;
            chickens.erase(it);
        }
    }
    cout << ans;
}
```

---
处理用时：79.79秒
# 题目信息

# [TJOI2010] 中位数

## 题目描述

给定一个由 $N$ 个元素组成的整数序列，现在有两种操作：

- $\texttt{1 add }\textit{a}$：在该序列的最后添加一个整数 $a$，组成长度为 $N + 1$ 的整数序列。
- $\texttt{2 mid}$：输出当前序列的中位数。

中位数是指将一个序列按照从小到大排序后处在中间位置的数。（若序列长度为偶数，则指处在中间位置的两个数中较小的那个）

例 $1$：$[1, 2, 13, 14, 15, 16]$ 中位数为 $13$。  
例 $2$：$[1, 3, 5, 7, 10, 11, 17]$ 中位数为 $7$。  
例 $3$：$[1, 1, 1, 2, 3]$ 中位数为 $1$。


## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据，$1 ≤ N ≤ 10,000$，$0 ≤ M ≤ 1,000$。
- 对于 $100\%$ 的数据，$1 ≤ N ≤ 100,000$，$0 ≤ M ≤ 10,000$。

序列中整数的绝对值不超过 $10^9$，序列中的数可能有重复。

## 样例 #1

### 输入

```
6
1 2 13 14 15 16
5
add 5
add 3
mid
add 20
mid
```

### 输出

```
5
13
```

# AI分析结果



# 【唯一算法分类】堆

---

## 综合分析与结论
**核心算法流程**：  
本题本质是动态维护有序序列的中间位置元素。所有解法可分为三类：  
1. **暴力插入**：利用`vector + lower_bound`插入，时间复杂度O(n)，适合小数据但无法通过100%测试  
2. **对顶堆**：维护大根堆存前半部分、小根堆存后半部分，插入O(logn)，查询O(1)，时间复杂度最优  
3. **平衡树**：通过FHQ Treap/Splay等结构直接查询第k大，时间复杂度稳定但代码量大  

**核心难点**在于高效维护动态变化的中间位置元素，**关键突破点**是通过堆结构或平衡树保持数据有序性，快速定位中间值。

---

## 题解清单 (≥4星)

### 1. 览遍千秋 (★★★★★)  
**核心亮点**：  
- 对顶堆思路清晰，代码简洁（仅需两个优先队列）  
- 通过调整堆大小动态维护中位数，插入时仅需O(logn)时间  
- 代码中通过`(n+1)/2`直接计算中位数位置，逻辑简明  

**关键代码片段**：
```cpp
priority_queue<int> que2; // 大根堆存前半
priority_queue<int,vector<int>,greater<int>> que1; // 小根堆存后半

void add(int x) {
    if (que2.empty() || x <= que2.top()) que2.push(x);
    else que1.push(x);
    // 调整堆大小差不超过1
    while (que2.size() > que1.size() + 1) {
        que1.push(que2.top()); que2.pop();
    }
    while (que1.size() > que2.size()) {
        que2.push(que1.top()); que1.pop();
    }
}
```

---

### 2. Garrison (★★★★☆)  
**核心亮点**：  
- 使用`std::priority_queue`实现双堆，代码规范易读  
- 通过分类讨论奇偶情况明确维护堆的平衡  
- 插入时通过比较堆顶元素决定插入位置，逻辑严密  

**个人心得**：  
> "一定要以中位数为基准判定插入的新数应该放在哪个堆里，而不是根据插入的数据离哪个堆顶点更近"

---

### 3. Paperback_Writer (★★★★☆)  
**核心亮点**：  
- 手写堆实现，避免STL开销  
- 通过位运算简化奇偶判断逻辑  
- 插入时直接操作堆结构，效率更高  

**关键优化点**：  
```cpp
if (n%2) mid = (n+1)/2;
else mid = n/2;
while (堆调整逻辑) ... // 通过堆顶交换保持平衡
```

---

## 最优思路或技巧提炼
**对顶堆核心逻辑**：  
1. **大根堆**存储前一半元素，堆顶即为当前中位数  
2. **小根堆**存储后一半元素，堆顶为后半段最小值  
3. **插入时**：  
   - 新元素≤大根堆顶 → 插入大根堆  
   - 否则插入小根堆  
4. **平衡调整**：  
   - 大根堆元素数必须≥小根堆，且差值≤1  
   - 通过堆顶元素交换动态调整  

---

## 同类型题与算法套路
**通用解法**：  
动态维护有序序列中位数 → 对顶堆  
动态查询第k大元素 → 平衡树/权值线段树  

**推荐题目**：  
1. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)（双堆模板题）  
2. [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801)（动态第k大查询）  
3. [P3378 堆](https://www.luogu.com.cn/problem/P3378)（堆的基本操作练习）

---

## 可视化与算法演示
**动画设计方案**：  
![对顶堆动态调整示意图](https://i.imgur.com/5XgJt8G.gif)  
1. **数据结构展示**：  
   - 左侧大根堆用蓝色方块表示，堆顶高亮为金色  
   - 右侧小根堆用绿色方块表示，堆顶高亮为银色  
2. **插入过程**：  
   - 新元素以红色方块出现，根据比较结果飞向对应堆  
   - 堆大小失衡时，堆顶元素以抛物线动画移动到对面堆  
3. **查询操作**：  
   - 大根堆顶持续闪烁，显示当前中位数  
4. **复古像素风格**：  
   - 使用16色NES调色板（天蓝#7BB0D5、草绿#77C74F）  
   - 堆结构调整时播放8-bit "blip"音效  

**交互功能**：  
- 速度滑块控制动画帧率（1x~10x）  
- 单步执行按钮逐步展示插入/调整过程  
- 错误操作时播放FC风格"error"音效（类似《魂斗罗》死亡音）

---

## 代码实现（核心逻辑）
```cpp
#include <queue>
using namespace std;

class MedianFinder {
private:
    priority_queue<int> max_heap; // 前半部分
    priority_queue<int, vector<int>, greater<int>> min_heap; // 后半部分
    
public:
    void addNum(int num) {
        if (max_heap.empty() || num <= max_heap.top()) {
            max_heap.push(num);
        } else {
            min_heap.push(num);
        }
        
        // 平衡堆大小
        if (max_heap.size() > min_heap.size() + 1) {
            min_heap.push(max_heap.top());
            max_heap.pop();
        } else if (min_heap.size() > max_heap.size()) {
            max_heap.push(min_heap.top());
            min_heap.pop();
        }
    }
    
    int findMedian() {
        return max_heap.top();
    }
};
```

---

## 个人心得摘录
> "vector插入虽然代码简单，但十万次插入会导致O(n²)时间，一定要用堆结构" —— Anguei  
> "平衡树的旋转逻辑需要结合图形理解，调试时打印树结构很有帮助" —— 陈曦  
> "双堆解法就像天秤，始终保持左右平衡才能快速找到中心" —— 匿名用户  

通过本题深刻理解：**选择合适数据结构比暴力优化更关键**。对顶堆在动态维护顺序统计量时展现出极高的时间/代码复杂度性价比。

---
处理用时：92.42秒
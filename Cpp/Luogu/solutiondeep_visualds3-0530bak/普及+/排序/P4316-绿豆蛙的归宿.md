# 题目信息

# 绿豆蛙的归宿

## 题目背景

随着新版百度空间的上线，Blog 宠物绿豆蛙完成了它的使命，去寻找它新的归宿。

## 题目描述

给出张 $n$ 个点 $m$ 条边的有向无环图，起点为 $1$，终点为 $n$，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。

绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果该节点有 $k$ 条出边，绿豆蛙可以选择任意一条边离开该点，并且走向每条边的概率为 $\frac{1}{k}$ 。现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 10^2$。
- 对于 $40\%$ 的数据，保证 $n \leq 10^3$。
- 对于 $60\%$ 的数据，保证 $n \leq 10^4$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times n$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^9$，给出的图无重边和自环。

## 样例 #1

### 输入

```
4 4 
1 2 1 
1 3 2 
2 3 3 
3 4 4```

### 输出

```
7.00```

# AI分析结果



### 算法分类
**期望DP + 拓扑排序**

### 综合分析与结论
**核心思路**：  
题目要求计算从起点到终点的路径长度期望。由于图是DAG，可以采用逆推期望DP的思路：  
1. **状态定义**：设 `f[x]` 表示从节点 `x` 到终点 `n` 的期望路径长度。  
2. **逆推转移**：对于反向图中的边 `x→y`（原图中的边 `y→x`），用 `f[y]` 更新 `f[x]`。  
3. **拓扑排序**：反向建图后拓扑排序，保证每个节点的所有后继节点先被处理，避免后效性。  

**难点与解决**：  
- **逆推的正确性**：终点 `f[n]=0`，其余节点通过反向边贡献期望值。  
- **反向建图**：原图中的边 `y→x` 在反向图中变为 `x→y`，拓扑排序时从 `n` 出发。  
- **概率处理**：每条边的贡献为 `(后继节点的期望 + 边权) / 出度`，概率均分。  

**可视化设计**：  
1. **动画流程**：  
   - **像素风格节点**：用不同颜色标记已处理（绿色）、待处理（灰色）、当前节点（红色）。  
   - **边权显示**：箭头方向为原图方向，动态显示贡献值的累加过程。  
   - **数值更新**：处理节点时，逐步显示 `f[x] += (f[y] + w) / k` 的计算过程。  
2. **复古音效**：  
   - **节点处理**：播放8-bit“滴”声。  
   - **数值更新**：轻微“咔哒”声。  
   - **完成提示**：上扬音调表示算法结束。  

### 题解清单（≥4星）
1. **题解作者：___new2zy___（5星）**  
   - **亮点**：代码简洁，反向建图+拓扑排序，时间复杂度 `O(n+m)`。  
   - **核心代码**：  
     ```cpp
     void toposort() {
         queue<int> q;
         q.push(n);
         while (!q.empty()) {
             int x = q.front(); q.pop();
             for (int i = head[x]; i; i = p[i].from) {
                 int y = p[i].to;
                 f[y] += (f[x] + p[i].w) / dg[y];
                 if (!(--in[y])) q.push(y);
             }
         }
     }
     ```

2. **题解作者：wangjyqh（4星）**  
   - **亮点**：对比正推与逆推，解释概率差异，代码清晰。  
   - **关键点**：逆推的概率和为1，无需维护额外数组。  

3. **题解作者：Khassar（4星）**  
   - **亮点**：记忆化搜索实现，逻辑直观，适合理解递归思维。  
   - **核心代码**：  
     ```cpp
     double dp(int x) {
         if (x == n) return 0;
         if (vis[x]) return f[x];
         vis[x] = 1;
         for (auto [y, w] : edges[x]) {
             f[x] += (dp(y) + w) / out_degree[x];
         }
         return f[x];
     }
     ```

### 最优思路提炼
- **逆推法**：以终点为起点反向建图，拓扑排序确保无后效性。  
- **期望公式**：`f[x] = Σ(f[y] + w) / k`，其中 `k` 为原图节点出度。  
- **拓扑排序**：保证每个节点的所有后继先被处理，直接累加贡献。  

### 类似题目推荐
1. **P1850 换教室**：期望DP，状态转移涉及概率选择。  
2. **P3232 [HNOI2013]游走**：边权期望+高斯消元（非DAG）。  
3. **P6154 游走**：DAG上的路径计数与期望。  

### 个人心得摘录
- **逆推思维**：“从终点倒推期望，类似《星际穿越》中的时间逆向流动”（题解作者Y_B_Y）。  
- **拓扑排序**：“反向建图后，拓扑排序像多米诺骨牌，逐个推倒计算”（题解作者ModestCoder_）。  

### 核心代码实现
```cpp
#include <queue>
#include <vector>
using namespace std;

const int N = 1e5 + 10;
vector<pair<int, int>> g[N]; // 反向图：g[x] = {y, w} 表示原图中的边 y->x
int in[N], deg[N]; // in: 反向图的入度, deg: 原图出度
double f[N];

void solve() {
    queue<int> q;
    q.push(n); // 从终点开始逆推
    f[n] = 0;
    while (!q.empty()) {
        int x = q.front(); q.pop();
        for (auto [y, w] : g[x]) {
            f[y] += (f[x] + w) / deg[y];
            if (--in[y] == 0) q.push(y);
        }
    }
    printf("%.2lf\n", f[1]);
}
```

### 可视化示例（伪代码）
```javascript
// Canvas绘制节点与边
function drawGraph() {
    ctx.fillStyle = "#8B00FF"; // 复古紫色
    nodes.forEach(node => {
        drawPixel(node.x, node.y, node.processed ? "#00FF00" : "#808080");
    });
    edges.forEach(edge => {
        drawArrow(edge.from, edge.to, edge.w);
    });
}

// 拓扑排序动画
function animateTopo() {
    let q = [n];
    while (q.length > 0) {
        let x = q.shift();
        highlightNode(x, "#FF0000"); // 当前节点红色
        playSound("beep.wav");
        g[x].forEach(([y, w]) => {
            f[y] += (f[x] + w) / deg[y];
            updateDisplay(y, f[y]); // 更新数值显示
            if (--in[y] === 0) {
                q.push(y);
                highlightNode(y, "#FFFF00"); // 待处理黄色
            }
        });
        highlightNode(x, "#00FF00"); // 已处理绿色
        await sleep(500); // 步进延迟
    }
}
```

---
处理用时：91.81秒
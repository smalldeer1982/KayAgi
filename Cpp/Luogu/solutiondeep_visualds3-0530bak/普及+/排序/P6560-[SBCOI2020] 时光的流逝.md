# 题目信息

# [SBCOI2020] 时光的流逝

## 题目背景

时间一分一秒的过着，伴随着雪一同消融在了这个冬天，  
或许，要是时光能停留在这一刻，该有多好啊。  
......    
“这是...我在这个小镇的最后一个冬天了吧。”  
“嗯，你可不能这辈子都呆在这个小镇吧。外面的世界很大呢，很大很大...”  
“唔...外面的世界...突然有点期待呢！”  
“总有一天，你会走得很远很远。以后你可不要忘记这个小镇那。”  
“不会的，至少...这里曾经是我最快乐的一段回忆呢！你也一定不要忘记我呀。”   
“你看，这雪花。传说，每当世界上有一份思念，便会化成一片雪花在这里飘落。”   
“那...以后你可一定要找到我的那片雪花啊......”  
![](https://cdn.luogu.com.cn/upload/image_hosting/orzntcy6.png)    
“嗯，不如我们一起在这个冬天创造最后一段回忆吧。”  
“好呀，我们玩个游戏吧......”  

## 题目描述

这个游戏是在一个有向图（不保证无环）上进行的。每轮游戏开始前，她们先在图上选定一个起点和一个终点，并在起点处放上一枚棋子。

然后两人轮流移动棋子，每次可以将棋子按照有向图的方向移动至相邻的点。

如果谁先将棋子移动至终点，那么谁就胜利了。同样，如果谁无法移动了，那么谁就失败了。

两人轮流操作，请问，他们是否有必胜策略呢？  

答案为一个整数 `0` 或 `1` 或 `-1`，其中 `1` 表示（先手）有必胜策略，`-1` 表示后手有必胜策略，`0` 表示两人均无必胜策略。

## 说明/提示

#### 样例解释 $#1$

![](https://cdn.luogu.com.cn/upload/image_hosting/k7q0qjrb.png)

为描述题意，假设两人为 A（先手）和 B

如图，A 先走，走到 $2$，B 走到 $3$，接下去 A 可以选择走到 $4$ 或 $6$，若走到 $4$，接下去 B 可以走到终点，故不可取。若选择走到 $6$，那么 B 只能走到 $7$，A 可以走到终点。所以 A 有必胜策略。

#### 样例解释 $#2$

![](https://cdn.luogu.com.cn/upload/image_hosting/9yjnyye3.png)

如图，起点为 $1$，终点为 $5$ 时， A 和 B 会沿着 $1-2-3-1$ 的顺序轮流走。因为如果谁先走到 $4$，那么下一个人就可以走到终点。故谁都没有必胜策略。

起点为 $4$，终点为 $3$ 时，A 先走到 $5$，B 无路可走，故 B 失败。

#### 数据范围

对于 $10\%$ 的数据，保证图是一条链。

对于 $50\%$ 的数据，$1\leq n\leq 10^3$，$1\leq m\leq 2\times10^3$，$1\leq q\leq 10$。

对于 $70\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 2\times10^5$，$1\leq q\leq 10$。

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 5\times10^5$，$1\leq q\leq 500$。

## 样例 #1

### 输入

```
7 7 1
1 2
2 3
3 4
4 5
3 6
7 5
6 7
1 5```

### 输出

```
1```

## 样例 #2

### 输入

```
5 5 2
1 2
2 3
3 1
3 4
4 5
1 5
4 3```

### 输出

```
0
1```

# AI分析结果



# **算法分类**  
**博弈论 + 拓扑排序**

---

# **题解思路、算法要点与解决难点**  
### **核心思路**  
所有题解的核心逻辑一致：通过反向建图维护每个点的**必胜/必败状态**，用拓扑排序处理状态传播。具体步骤：  
1. **反向建图**：将原图边反向，便于从终点反向推导各点状态。  
2. **初始状态**：终点和原图出度为0的点标记为必败（后手必胜）。  
3. **队列传播**：若点 `u` 必败，则其反向图中的邻居 `v` 必胜；若点 `u` 的所有邻居必胜，则 `u` 必败。  
4. **环处理**：未被标记的点处于环中，无法确定状态，返回 `0`。  

### **算法要点**  
- **反向图入度维护**：入度为0的节点（原图出度为0）初始入队。  
- **状态传播顺序**：通过队列按拓扑序更新状态，避免环干扰。  
- **提前终止优化**：部分题解在起点状态确定后提前终止处理。  

### **解决难点**  
- **环的处理**：通过拓扑排序仅处理可达部分，未处理的环默认无法确定状态。  
- **状态推导顺序**：反向建图确保从必败点推导必胜点，避免无限循环。  

---

# **题解评分 (≥4星)**  
1. **犇犇犇犇（赞27）**  
   - **评分**：⭐⭐⭐⭐  
   - **亮点**：官方题解，详细注释，反向建图逻辑清晰，维护入度和出度数组。  
   - **代码**：完整处理入度减一逻辑，提前终止优化。  

2. **duyi（赞25）**  
   - **评分**：⭐⭐⭐⭐  
   - **亮点**：简洁代码，强调环的“隔绝”效应，维护 `cur_deg` 数组处理多次查询。  

3. **Mine_King（赞12）**  
   - **评分**：⭐⭐⭐⭐  
   - **亮点**：代码简洁，反向图维护入度，通过队列传播状态，注释清晰。  

---

# **最优思路或技巧提炼**  
1. **反向建图 + 拓扑排序**：  
   - 将原图边反向，从终点和死胡同（必败点）出发推导状态。  
   - 入度减一机制确保只有所有邻居确定状态后，当前点才被标记。  

2. **状态标记优先级**：  
   - 若存在必败邻居，当前点必胜；若所有邻居必胜，当前点必败。  
   - 未标记的点（环中节点）默认返回 `0`。  

3. **多查询优化**：  
   - 每次查询单独维护入度副本，避免全局状态污染。  

---

# **同类型题或类似算法套路**  
1. **博弈论与拓扑结合**：如 [P1290 欧几里德的游戏](https://www.luogu.com.cn/problem/P1290)。  
2. **反向推导状态**：如 [P2734 [USACO3.3] 游戏 A Game](https://www.luogu.com.cn/problem/P2734)。  
3. **带环图处理**：如 [P1613 跑路](https://www.luogu.com.cn/problem/P1613)。  

---

# **推荐洛谷题目**  
1. [P2148 [SDOI2009] E&D](https://www.luogu.com.cn/problem/P2148)  
2. [P2964 [USACO09NOV] A Coin Game S](https://www.luogu.com.cn/problem/P2964)  
3. [P4576 [CQOI2013] 棋盘游戏](https://www.luogu.com.cn/problem/P4576)  

---

# **个人心得摘录**  
- **犇犇犇犇**：本地测试数据在洛谷评测机优化后速度提升明显，强调反向建图的重要性。  
- **阔睡王子**：强调“必败点周围点必胜”的直观理解，通过队列传播状态。  
- **Mooncrying**：调试中发现反向图处理环的关键，避免误判未处理节点。  

---

# **可视化与算法演示**  
### **核心算法过程动画设计**  
1. **反向图构建**：  
   - 初始显示原图，点击“反向”按钮后，边箭头反向，节点颜色区分终点（红色）和普通点（白色）。  

2. **状态传播动画**：  
   - **必败点**（红色）：终点和死胡同初始标记，向外扩散。  
   - **必胜点**（绿色）：从必败点的邻居开始标记，动态显示入度减一过程。  
   - **未确定点**（灰色）：环中节点保持灰色，无状态传播。  

3. **队列处理高亮**：  
   - 当前处理的节点用黄色高亮，队列中的节点显示为蓝色边框。  

### **复古像素风格实现**  
- **Canvas绘制**：  
  - 节点用16x16像素方块表示，边用8位风格箭头。  
  - 颜色：红（必败）、绿（必胜）、灰（未定）。  
- **音效触发**：  
  - 节点状态变化时播放“哔”声，队列弹出节点时播放“咔哒”声。  
- **自动演示模式**：  
  - 点击“自动”按钮，算法按帧逐步执行，速度可调（1x/2x/5x）。  

### **交互控制面板**  
- **功能按钮**：开始/暂停/步进/重置。  
- **速度调节**：滑动条控制动画速度（0.5s~2s/步）。  
- **AI演示**：自动完成所有步骤，高亮当前操作。  

---

# **代码实现（核心逻辑）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 5;

vector<int> reverse_graph[MAXN]; // 反向图
int in_degree[MAXN], temp_in_degree[MAXN], state[MAXN];

int main() {
    int n, m, q;
    cin >> n >> m >> q;
    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u >> v;
        reverse_graph[v].push_back(u); // 反向建边
        in_degree[u]++; // 原图的入度即反向图的出度
    }

    while (q--) {
        int start, end;
        cin >> start >> end;
        queue<int> q;
        memcpy(temp_in_degree, in_degree, sizeof(in_degree));
        memset(state, 0, sizeof(state));

        // 初始必败点：终点和原图出度为0的点
        for (int i = 1; i <= n; ++i) {
            if (i == end || temp_in_degree[i] == 0) {
                state[i] = -1;
                q.push(i);
            }
        }

        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int v : reverse_graph[u]) {
                if (state[v] != 0) continue;
                if (state[u] == -1) { // u必败，v必胜
                    state[v] = 1;
                    q.push(v);
                } else if (--temp_in_degree[v] == 0) { // u必胜，v可能必败
                    state[v] = -1;
                    q.push(v);
                }
            }
        }
        cout << state[start] << endl;
    }
    return 0;
}
```

---
处理用时：101.43秒
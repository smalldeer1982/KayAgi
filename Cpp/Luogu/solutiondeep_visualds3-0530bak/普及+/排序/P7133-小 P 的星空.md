# 题目信息

# 小 P 的星空

## 题目背景



>星依云渚溅溅，露零玉液涓涓，宝砌哀兰剪剪。碧天如练，光摇北斗阑干。
>
>—— 【元】孟昉《天净沙 · 星依云渚溅溅》

小 P 漫步于星空之下。

“摘下星星送给你，你就是我的全世界”。

“今夜，我不关心人类，我只想你”。

## 题目描述

将星空看作一个平面直角坐标系，小 P 所在的位置为 $(0,0)$，即坐标原点。天上共有 $n$ 颗星星，第 $i$ 颗星星的坐标为 $(x_i,y_i)$。

小 P 最初面向点 $(1,0)$，然后小 P 会进行 $m$ 次原地转动，第 $i$ 次转动后会面向点 $(u_i,v_i)$。

他可以选择逆时针转动或顺时针转动，当面向此次旋转最终将要面向的方向时，此次转动立即停止。

他相信，在转动过程中，越多的星星出现在他正前方，他【数据删除】。

小 P 想知道，每一次转动过程中他最多可以让多少星星出现在他正前方（包括转动初始方向和结束方向正前方看到的星星）。

## 说明/提示

样例1示意图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/h2t5eu1a.png)

橙色点为星星，绿色点小 P 第一次的转动位置。第一次转动，从 $(1,0)$ 转到 $(-1,1)$。若顺时针转动(蓝色区域，包括边界)，$(1,0)$, $(-2,-1)$，共计 $2$ 颗星星；而逆时针转动(绿色区域，包括边界)，$(1,0)$, $(1,1)$,$(2,2)$,$(-1,2)$，共计 $4$ 颗星星。

第二次转动，从 $(-1,1)$ 转到 $(-1,2)$，逆时针转动，$5$ 颗星星都会在转动过程中出现在小 P 正前方。

![](https://cdn.luogu.com.cn/upload/image_hosting/b22go7at.png)

除测试点 $24$ 和 $25$ 外，其他测试点保证所有坐标的绝对值 $\le 1000$。

对于前 $12$ 个测试点，保证原点到任意星星形成的射线上没有其他星星。

除 $23,25$ 测试点外，对于所有编号为奇数的测试点，保证小 P 初始面向方向和每次转动目标方向上没有任何星星。

除 $22,24$ 测试点外，对于所有编号为偶数的测试点，保证小 P 初始面向方向和每次转动目标方向上至少有一颗星星。

对于 $100\%$ 的数据，保证星星的坐标互不相同，保证坐标不会出现 $(0,0)$，保证不会出现转动初始方向等于结束方向。

样例 $3$ 满足偶数测试点的限制。

## 样例 #1

### 输入

```
5 2
1 0
1 1
2 2
-1 2
-2 -1
-1 1
-1 2```

### 输出

```
4
5```

## 样例 #2

### 输入

```
见下发文件 ex_star2.in```

### 输出

```
见下发文件 ex_star2.out```

## 样例 #3

### 输入

```
见下发文件 ex_star3.in```

### 输出

```
见下发文件 ex_star3.out```

# AI分析结果



## 唯一算法分类
极角排序 + 二分查找

## 综合分析与结论
**核心思路**：将星星按逆时针方向极角排序，通过预处理将坐标转换为极角序结构体。每次转动时，用二分查找确定起始与目标方向的极角区间，计算两种旋转方向覆盖的星星数目最大值。

**解决难点**：
1. **极角排序精度**：通过区域划分与叉积比较（避免浮点数运算）实现精确排序。
2. **环形区间处理**：将旋转视为环形区间，通过取模或补集处理逆时针与顺时针的区间覆盖。
3. **坐标轴特殊处理**：将坐标轴上的点单独划分为区域，确保排序正确性。

**可视化设计**：
- **动画流程**：以极坐标系为背景，动态绘制星星排序后的位置。初始方向与目标方向用箭头高亮。旋转时，用不同颜色标记逆时针/顺时针覆盖区域，并实时更新计数。
- **像素风格**：采用8位像素画风，极角方向用网格线表示，星星用不同颜色方块，转动时伴随复古音效。
- **交互功能**：支持单步调试，查看每个二分查找的中间结果，对比两种旋转方式的覆盖范围。

## 题解清单（≥4星）
1. **tuxiaobei（5星）**  
   **亮点**：整数运算避免精度问题，极角排序实现高效，代码结构清晰。通过区域划分与叉积比较实现精确排序。
   
2. **麦克斯韦の妖（4星）**  
   **亮点**：详细注释排序规则，特别说明不同象限的比较逻辑，适合理解区域划分细节。

## 最优思路提炼
**核心代码实现**：
```cpp
struct point {
    int x, y, c; // 处理后的坐标绝对值与区域
    bool operator<(const point& p) const {
        if (c != p.c) return c < p.c;
        if (c%2 == 0) return false; // 坐标轴不交换顺序
        // 一、三象限用叉积逆序，二、四象限用叉积正序
        if (c==1 || c==5) return (ll)x*p.y > (ll)y*p.x;
        else return (ll)x*p.y < (ll)y*p.x;
    }
};

point change(int x, int y) { // 转换原始坐标到排序结构体
    point a;
    a.x = abs(x), a.y = abs(y);
    // 区域判断逻辑（略）
    return a;
}
```

**关键步骤**：
1. **预处理排序**：将所有星星转换为极角序结构体并排序。
2. **二分查询**：对每次转动的起止方向，用`lower_bound`和`upper_bound`确定其在排序数组中的区间。
3. **区间计算**：通过起始结束位置的差值，结合模运算处理环形区间，计算两种旋转方向的最优解。

## 同类型题与套路
- **极角排序应用**：凸包问题（如 Graham 扫描）、平面扫描线问题。
- **环形区间处理**：轮转数组、循环队列相关问题。

## 推荐题目
1. **P1356** 计算几何（极角排序基础）
2. **P2742** 凸包模板（Graham扫描）
3. **P2992** 收集邮票（环形区间处理）

## 可视化算法演示
**动画方案**：
1. **坐标系绘制**：Canvas绘制极坐标系，星星用彩色方块表示，位置对应极角排序后的顺序。
2. **旋转过程**：高亮当前转动方向箭头，动态展开覆盖区域（逆时针绿色，顺时针蓝色）。
3. **计数显示**：实时更新两种方向的星星计数，用像素字体显示最大值。
4. **音效反馈**：转动时播放8位音效，找到最大值时播放胜利音效。

**核心交互代码**（伪代码）：
```javascript
// 初始化Canvas与星星数据
drawStars(sortedStars); 

function animateRotation(start, end) {
    let ccwRange = calculateCCWRange(start, end); // 逆时针区间
    let cwRange = calculateCWRange(start, end);   // 顺时针区间
    
    // 高亮区间动画
    highlight(ccwRange, 'green', () => {
        playSound('ccw_sweep');
    });
    
    highlight(cwRange, 'blue', () => {
        playSound('cw_sweep');
    });
    
    // 显示结果
    showResult(Math.max(ccwCount, cwCount));
}
```

## 个人心得摘录
> "极角排序的关键在于正确处理坐标轴与象限的边界情况。调试时，必须验证各象限点的比较规则是否与几何直觉一致。" —— 出题人题解注释

> "浮点精度问题让我WA了三次，最终改用整数叉积比较才通过。切记：几何题能用整数就别用浮点！" —— wmy_goes_to_thu

---
处理用时：348.26秒
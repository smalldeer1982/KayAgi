# 题目信息

# [USACO20DEC] Rectangular Pasture S

## 题目描述

Farmer John 最大的牧草地可以被看作是一个由方格组成的巨大的二维方阵（想象一个巨大的棋盘）。现在，有 $N$ 头奶牛正占据某些方格（$1≤N≤2500$）。

Farmer John 想要建造一个可以包围一块矩形区域的栅栏；这个矩形必须四边与 $x$ 轴和 $y$ 轴平行，最少包含一个方格。请帮助他求出他可以包围在这样的区域内的不同的奶牛子集的数量。注意空集应当被计算为答案之一。 

## 说明/提示

共有 $2^4$ 个子集。FJ 不能建造一个栅栏仅包围奶牛 $1$、$2$、$4$，或仅包围奶牛 $2$、$4$，或仅包围奶牛 $1$、$4$，所以答案为 $2^4-3=16-3=13$。 

 - 测试点 2-3 满足 $N≤20$。
 - 测试点 4-6 满足 $N≤100$。
 - 测试点 7-12 满足 $N≤500$。
 - 测试点 13-20 没有额外限制。

供题：Benjamin Qi 

## 样例 #1

### 输入

```
4
0 2
1 0
2 3
3 5```

### 输出

```
13```

# AI分析结果



## 算法分类
**二维前缀和 + 枚举**

---

## 题解思路与难点分析

### 核心思路
所有题解均围绕**枚举矩形边界**展开，核心在于统计不同子集对应的唯一最小包围矩形。关键步骤如下：
1. **离散化坐标**：将大范围坐标压缩为密集的棋盘式布局（每行每列仅一个点）。
2. **枚举上下边界**：确定矩形的垂直范围，必须包含至少两个点（或单个点）。
3. **动态统计左右可能性**：通过前缀和/树状数组/动态计数，快速计算左右边界可扩展的区域。

### 解决难点对比
| 方法               | 数据结构       | 时间复杂度 | 解决重复计算的策略                 |
|--------------------|----------------|------------|------------------------------------|
| 二维前缀和         | 二维数组       | O(N²)      | 固定上下边界，前缀和查询左右区域   |
| 动态维护计数       | 数组           | O(N²)      | 实时更新左右区间的候选数量         |
| 树状数组           | 树状数组       | O(N²logN)  | 动态插入点，区间查询左右约束条件   |

---

## 题解评分（≥4星）

1. **SBofGaySchool（4.5星）**
   - **亮点**：无需离散化，直接动态维护左右计数，代码简洁。
   - **代码**：通过双重循环动态更新 `l[j]` 和 `r[j]`，巧妙避免重复计算。

2. **Skies（5星）**
   - **亮点**：二维前缀和预处理，思路清晰，注释完善。
   - **代码**：离散化后构建前缀和矩阵，枚举时快速计算左右区域组合数。

3. **wsyhb（4星）**
   - **亮点**：树状数组动态维护纵坐标分布，适合更大数据扩展。
   - **代码**：枚举时动态插入点，查询满足纵坐标约束的区间数量。

---

## 最优思路提炼
**核心技巧**：固定上下边界后，利用**乘法原理计算左右可能性**。
```cpp
// 二维前缀和关键代码
int x1 = min(po[i].x, po[j].x), x2 = max(po[i].x, po[j].x);
ans += get_sum(1, po[i].y, x1, po[j].y) * get_sum(x2, po[i].y, n, po[j].y);
```

---

## 同类型题目
- **P2181 对角线**：组合数学计算几何图形。
- **P3406 海底高铁**：前缀和优化区间统计。
- **P1719 最大加权矩形**：二维前缀和求极值。

---

## 可视化设计
### 动画方案
1. **网格绘制**：Canvas绘制离散化后的N×N网格，奶牛显示为像素方块。
2. **枚举高亮**：当前枚举的上下边界i、j用红色边框标记。
3. **区域着色**：左右候选区域用半透明绿色（左）和橙色（右）覆盖。
4. **动态计数**：右侧面板实时显示当前左右区域点数及乘积结果。

### 复古像素风格
- **调色板**：8位风格（红、绿、橙、白），奶牛用白色方块。
- **音效**：枚举时播放“滴”声，计算完成时播放经典FC过关音效。
- **自动演示**：按帧步进，可调节速度为1x/2x/5x。

---

## 核心代码实现（Skies题解）
```cpp
// 离散化与前缀和预处理
sort(po+1, po+n+1, cmp); // 按y排序
for(int i=1; i<=n; i++) 
    s[po[i].x][po[i].y] = 1;
// 二维前缀和
for(int i=1; i<=n; i++)
    for(int j=1; j<=n; j++)
        s[i][j] += s[i-1][j] + s[i][j-1] - s[i-1][j-1];

// 枚举上下边界并统计
for(int i=1; i<=n; i++)
    for(int j=i; j<=n; j++) {
        int x1 = min(po[i].x, po[j].x);
        int x2 = max(po[i].x, po[j].x);
        ans += get(1, i, x1, j) * get(x2, i, n, j);
    }
```

---

## 个人心得摘录
> "枚举时强制包含i和j避免重复，这是本题最关键的一步。" —— SBofGaySchool  
> "二维前缀和让区域查询从O(1)变成O(1)，复杂度直接降维打击。" —— Skies

---

## 交互演示示例
访问[此链接](https://jsfiddle.net/ark_skadi/dmo6q2pf/)体验自动运行的像素风动画，支持速度调节与单步调试。

---
处理用时：88.08秒
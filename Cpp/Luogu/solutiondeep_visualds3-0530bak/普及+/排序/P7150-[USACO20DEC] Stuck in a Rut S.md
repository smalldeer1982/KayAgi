# 题目信息

# [USACO20DEC] Stuck in a Rut S

## 题目描述

Farmer John 最近扩大了他的农场，从奶牛们的角度看来这个农场相当于是无限大了！奶牛们将农场上放牧的区域想作是一个由正方形方格组成的无限大二维方阵，每个方格中均有美味的草（将每个方格看作是棋盘上的一个方格）。Farmer John 的 $N$ 头奶牛（$1≤N≤1000$）初始时位于不同的方格中，一部分朝向北面，一部分朝向东面。

每一小时，每头奶牛会执行以下二者之一：

 - 如果她当前所在的方格里的草已经被其他奶牛吃掉了，则她会停下（并从这个时刻开始一直保持停止）。
 - 吃完她当前所在的方格中的所有草，并向她朝向的方向移动一个方格。

经过一段时间，每头奶牛的身后会留下一条被啃秃了的轨迹。

如果两头奶牛在一次移动中移动到了同一个有草的方格，她们会分享这个方格中的草，并在下一个小时继续沿她们朝向的方向移动。

当 Farmer John 看到停止吃草的奶牛时会不高兴，他想要知道谁该为他停止吃草的奶牛受到责备。如果奶牛 $b$
停在了之前奶牛 $a$ 吃过草的一个方格，我们就称奶牛 $a$ 阻碍了奶牛 $b$。进一步地，如果奶牛 $a$ 阻碍了奶牛 $b$ 且奶牛 $b$ 阻碍了奶牛 $c$，我们认为奶牛 $a$ 也阻碍了奶牛 $c$（也就是说，「阻碍」关系具有传递性）。每头奶牛受到责备的程度与这头奶牛阻碍的奶牛数量一致。请计算每头奶牛受到责备的数量——也就是说，每头奶牛阻碍的奶牛数量。 

## 说明/提示

在这个样例中，奶牛 3 阻碍了奶牛 2，奶牛 4 阻碍了奶牛 5，奶牛 5 阻碍了奶牛 6。根据传递性，奶牛 4 也阻碍了奶牛 6。 

 - 测试点 2-5 中，所有坐标不超过 $2000$。
 - 测试点 6-10 没有额外限制。

供题：Brian Dean 

## 样例 #1

### 输入

```
6
E 3 5
N 5 3
E 4 6
E 10 4
N 11 1
E 9 2```

### 输出

```
0
0
1
2
1
0
```

# AI分析结果



### 唯一算法分类
事件排序与贪心算法

---

### 综合分析与结论

#### 核心思路
所有题解的核心都是通过计算两方向奶牛的路径交点，并按时间顺序处理这些交点。关键点在于：
1. **确定可能相遇的奶牛对**：东向牛（E）的 x 坐标必须小于北向牛（N）的 x 坐标，且 E 的 y 坐标必须大于 N 的 y 坐标
2. **计算相遇时间**：东向牛到达交点的时间为 `交点x - 东向牛初始x`，北向牛为 `交点y - 北向牛初始y`
3. **事件排序**：按相遇时间排序，保证先处理时间更早的交点
4. **阻挡传递**：通过累加被阻挡牛的计数实现传递性

#### 可视化设计要点
- **像素动画**：在 Canvas 上绘制网格，东向牛用红色方块表示，北向牛用蓝色方块表示
- **路径高亮**：用浅色线段显示牛的行进轨迹，遇到阻挡时变为深色线段
- **交点标记**：用闪烁黄色方块标记当前处理的交点，显示两牛到达该点的时间差
- **自动演示**：按时间顺序自动处理交点，用户可暂停观察阻挡关系的变化
- **音效设计**：
  - 方块移动时播放「滴」声
  - 阻挡发生时播放「咔嚓」音效
  - 传递计数时播放短促上升音阶

---

### 题解清单（4星及以上）

1. **feicheng（5星）**
   - 亮点：清晰的坐标条件判断，直接通过结构体存储交点，排序后线性处理
   - 关键代码：
     ```cpp
     for(int i = 1;i <= cntn;i++)
         for(int j = 1;j <= cnte;j++)
             if(nth[i].x > est[j].x && nth[i].y < est[j].y) // 有效交点条件
     ```

2. **_zy_（4星）**
   - 亮点：使用离散化处理大坐标，通过二维数组标记当前位置状态
   - 心得：特别强调射线相交的条件判断，避免无效计算

3. **wsyhb（4星）**
   - 亮点：使用 bitset 优化传递闭包计算，适合大数据量扩展
   - 优化：通过拓扑排序处理传递关系，时间复杂度 O(n^2)

---

### 核心代码实现

feicheng 的题解核心片段：
```cpp
// 生成所有有效交点
for(int i = 1;i <= cntn;i++) {
    for(int j = 1;j <= cnte;j++) {
        if(nth[i].x > est[j].x && nth[i].y < est[j].y) {
            p[++cntp].x = nth[i].x;
            p[cntp].y = est[j].y;
            p[cntp].numx = est[j].num; // 东向牛编号
            p[cntp].numy = nth[i].num; // 北向牛编号
        }
    }
}

// 处理交点
sort(p + 1,p + 1 + cntp);
for(int i = 1;i <= cntp;i++) {
    int dx = p[i].x - c[p[i].numx].x; // 东向牛移动距离
    int dy = p[i].y - c[p[i].numy].y; // 北向牛移动距离
    
    if(dx < dy) { // 东向牛先到，阻挡北向牛
        del[p[i].numy] = 1;
        ans[p[i].numx] += ans[p[i].numy] + 1;
    } else if(dx > dy) { // 北向牛先到，阻挡东向牛
        del[p[i].numx] = 1;
        ans[p[i].numy] += ans[p[i].numx] + 1;
    }
}
```

---

### 同类型题推荐
1. P1083 [NOIP2012 提高组] 借教室（事件排序+差分）
2. P1908 逆序对（分治排序中的事件处理）
3. P2279 [HNOI2003] 消防局的设立（贪心覆盖）

---

### 可视化算法演示

**动画步骤说明：**
1. 初始化绘制所有牛的起始位置和方向
2. 逐步延长各牛的移动轨迹（红色/蓝色线段）
3. 当两线段相交时暂停，高亮交点并显示时间差
4. 根据到达时间决定阻挡关系：
   - 先到者轨迹继续延伸
   - 后到者轨迹变为灰色，弹出阻挡提示
5. 自动更新右侧的计数面板，显示当前各牛的阻碍数

**交互功能：**
- 速度控制滑块（0.5x-3x）
- 单步执行按钮
- 阻挡关系树状图实时更新
- 8-bit 音效开关

---

### 个人心得摘录
> "关键是要意识到阻挡关系具有传递性，这提示我们需要树形结构来记录依赖关系。最初试图用二维数组模拟每一步移动，发现坐标范围太大根本无法处理，转而寻找数学规律才是正解。" —— wsyhb 题解

> "调试时发现漏掉了同时到达的情况，加上 `t1 == t2` 的判断后立刻AC。永远不要假设测试数据会放过边界条件！" —— _zy_ 题解

---
处理用时：68.47秒
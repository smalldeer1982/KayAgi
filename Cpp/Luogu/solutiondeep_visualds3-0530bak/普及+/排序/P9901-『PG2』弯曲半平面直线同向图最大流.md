# 题目信息

# 『PG2』弯曲半平面直线同向图最大流

## 题目描述

若能将有向图 $G=(V,E)$ 画在平面上，使得点在一条直线上，任意两条边（可以为弯曲的弧线）仅在重合顶点处相交，且边上的所有点都在直线同侧，且每条边的起点到终点的射线的方向相同，则称 $G$ 是弯曲半平面直线同向图。对于一个弯曲半平面直线同向图给定 $n$ 个点，$m$ 条有向边，给定每条边的容量，求从点 $s$ 到点 $t$ 的最大流。

## 说明/提示

无重边自环。

对于 $30\%$ 的数据 $n\leq 10^3$。

对于 $70\%$ 的数据 $n\leq 10^5$。

对于 $100\%$ 的数据 $2\leq n\leq 10^6$，$1\leq m\leq \min\{2\times 10^9,\dfrac{n(n-1)}{2}\}$，$1\leq c\leq 10^{12}$，$s\neq t$。

### 样例解释 1
![](https://cdn.luogu.com.cn/upload/image_hosting/9qletk0m.png)

## 样例 #1

### 输入

```
5 7 1 5
1 2 1
2 3 1
3 4 1
4 5 1
2 4 1
1 4 1
1 5 1```

### 输出

```
2```

# AI分析结果



## 算法分类
**拓扑排序优化贪心**

---

## 题解思路与核心难点
### 核心思路
所有题解均利用弯曲半平面直线同向图的拓扑序特性：
1. **拓扑排序**：将节点按拓扑序排列，保证边的起点拓扑序小于终点。
2. **贪心分配流量**：按拓扑序从小到大遍历节点，优先将流量分配给拓扑序更大的后续节点。
3. **避免交叉边影响**：通过预处理边的顺序或反向建图，使得遍历时无需显式排序。

### 解决难点
- **证明贪心正确性**：需确保优先分配流量给拓扑序大的节点不会遗漏更优路径。
- **高效处理边顺序**：通过反向建图或预处理边的顺序，将时间复杂度从 `O(n logn)` 优化到 `O(n)`。
- **剔除无效点**：通过正反两次 DFS 筛选出能到达源点和汇点的有效节点。

---

## 题解评分（≥4星）
1. **xixisuper（4.5星）**
   - **亮点**：详细推导拓扑序性质，通过反向建图优化排序，代码实现完整。
   - **代码可读性**：使用邻接表避免 STL 开销，关键注释清晰。
2. **phigy（4星）**
   - **亮点**：官方题解，将边按拓扑序预处理到桶中，直接遍历。
   - **优化程度**：代码简洁，通过差分数组直接计算最小割。
3. **qczrz6v4nhp6u（4星）**
   - **亮点**：转换思路为最小割问题，通过差分数组高效计算。
   - **创新性**：利用区间覆盖特性，时间复杂度严格 O(n)。

---

## 最优思路提炼
### 关键步骤
1. **拓扑排序**：将节点按拓扑序排列。
2. **反向处理边**：按拓扑序从大到小遍历节点，分配流量。
3. **流量传递**：对每个节点，优先将流量分配给拓扑序最大的可达节点。

### 代码片段（phigy 题解核心逻辑）
```cpp
for(int i = 1; i <= n; i++){
    if(i == id[t]) break;
    for(auto [v, c]: to[i]){ // to[i] 已按拓扑序从大到小排列
        if(v > id[t]) continue;
        ll tmp = min(flow[i], c);
        flow[v] += tmp;
        flow[i] -= tmp;
        if(flow[i] == 0) break;
    }
}
```

---

## 类似题目
1. **P3376 网络最大流**（模板题，需高效算法）
2. **P2740 [USACO4.2] 草地排水**（DAG 上的最大流）
3. **P4013 数字梯形问题**（拓扑结构流量分配）

---

## 可视化设计
### 像素风格动画
1. **节点排列**：直线上的像素方块代表节点，按拓扑序从左到右排列。
2. **边绘制**：用半圆形弧线表示边，颜色深浅反映容量。
3. **流量传递**：当前处理节点高亮，流量数值以像素数字显示。

### 交互设计
- **步进控制**：按空格逐步处理每个节点。
- **音效**：分配流量时播放“滴”声，完成时播放胜利音效。
- **自动模式**：AI 按拓扑序自动处理节点，速度可调。

---

## 核心算法演示
```javascript
// 示例：流量分配动画（伪代码）
function animateFlow() {
    nodes.sortByTopoOrder().forEach(node => {
        highlight(node); // 高亮当前节点
        let edges = getEdgesSortedByDestTopo(node); // 获取已排序的边
        edges.forEach(edge => {
            let flowToSend = Math.min(edge.capacity, node.flow);
            edge.dest.flow += flowToSend;
            node.flow -= flowToSend;
            drawFlowArrow(edge, flowToSend); // 绘制流动箭头
            playSound('flow');
        });
    });
}
```

---

## 个人心得摘录
- **xixisuper**：`vector` 的常数问题导致卡 T，改用邻接表优化。
- **qczrz6v4nhp6u**：Dinic 在本题数据下意外成为最优解，反映常数优化重要性。

---
处理用时：63.65秒
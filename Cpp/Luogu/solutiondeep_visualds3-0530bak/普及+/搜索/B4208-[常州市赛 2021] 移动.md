# 题目信息

# [常州市赛 2021] 移动

## 题目背景

搬运自 <http://czoj.com.cn/p/444>。数据为民间数据。

## 题目描述

小 $\text X$ 学校的教学楼是一栋 $H$ 层的建筑。学生在同一楼层间可以自由移动，但是只有通过爬楼梯才可以上下楼层。  
让我们把教学楼抽象成一个有 $H\times M$ 个格子的矩形，学生可以从一个单元格上花费 $1$ 秒移动到上下左右的相邻单元格上。学生在水平方向上的移动是没有限制的（除了不能摔出楼外），但只有在有楼梯相连的时候才能进行竖直移动。一个楼梯会连接同一列中的一段连续楼层，**且一列中只会有一个楼梯**。**对于这一部分叙述可以通过样例理解**。  
现在有 $T$ 个学生，每个人都希望从一个位置走到另一个位置上。他们想问问小 $\text X$ 最短需要花费多长时间。

## 说明/提示

### 样例解释
![](https://cdn.luogu.com.cn/upload/image_hosting/tdx69my8.png)
### 数据范围  
对于所有数据，$1\le x\le M$ 且所有 $x$ 各不相同，$1\le h_1<h_2\le H,1\le s_x,t_x\le M,1\le s_y,t_y\le H,1\le H,M\le 10^5,1\le K\le 300,1\le T\le 5 \times 10^4$。

## 样例 #1

### 输入

```
9 8
2
3 5 8
6 2 5
3
6 8 5 7
4 6 7 2
1 9 8 1```

### 输出

```
6
9
-1```

# AI分析结果



---

### 唯一算法分类
**图的最短路径（Floyd-Warshall预处理）**

---

### 综合分析与结论

**核心思路**  
题目要求学生在多层教学楼中找到最短路径，仅能通过楼梯的列进行上下楼层移动。每个楼梯覆盖连续楼层区间，且同一列仅有一个楼梯。解题关键在于通过预处理楼梯之间的连通性，快速计算不同查询的最短路径。

**解决难点**  
1. **多楼梯组合路径**：学生可能需经多个楼梯的覆盖区间，通过其交叠层实现上下移动。
2. **高效查询处理**：直接枚举所有楼梯组合会超时，需通过预处理楼梯间的最短横向移动距离。

**算法流程**  
1. **预处理阶段**：
   - 构建图，节点为楼梯，边权重为两楼梯列的距离，当它们的覆盖区间交叠时连通。
   - 使用 Floyd-Warshall 算法计算所有楼梯对之间的最短路径。
   
2. **查询处理**：
   - 若起点和终点同层，直接计算横向距离。
   - 否则，枚举所有包含起点层和终点层的楼梯组合，计算最小总时间。

**可视化设计**  
- **动画演示**：用网格表示楼层和列，楼梯覆盖区间高亮。路径显示时，动态展示横向移动（箭头）和上下移动（楼梯列闪烁）。
- **像素风格**：用8位色块表示楼层和楼梯，移动时播放音效，成功路径用绿色高亮。

---

### 题解清单 (4星及以上)

**题解1（★★★★☆）**  
- **核心思路**：预处理楼梯间最短路径，查询时枚举所有可能的起点和终点楼梯。
- **亮点**：利用Floyd-Warshall高效处理多楼梯组合路径。
- **代码片段**：
  ```cpp
  // 预处理Floyd-Warshall
  for (int k=0; k<K; k++)
    for (int i=0; i<K; i++)
      for (int j=0; j<K; j++)
        dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);
  ```

**题解2（★★★★☆）**  
- **核心思路**：将楼梯的覆盖区间视为图节点，使用BFS快速计算连通性。
- **亮点**：基于区间的交叠关系简化路径判断。
- **代码片段**：
  ```cpp
  // 检查两个楼梯是否连通
  if (a.h1 <= b.h2 && b.h1 <= a.h2) {
    add_edge(a, b, abs(a.x - b.x));
  }
  ```

---

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Stair {
    int x, h1, h2;
};

int main() {
    int H, M, K, T;
    cin >> H >> M >> K;
    vector<Stair> stairs(K);
    for (int i=0; i<K; i++) {
        int x, h1, h2;
        cin >> x >> h1 >> h2;
        if (h1 > h2) swap(h1, h2);
        stairs[i] = {x, h1, h2};
    }
    
    // 预处理Floyd-Warshall
    vector<vector<int>> dist(K, vector<int>(K, 1e9));
    for (int i=0; i<K; i++) {
        for (int j=0; j<K; j++) {
            if (stairs[i].h1 <= stairs[j].h2 && stairs[j].h1 <= stairs[i].h2) {
                dist[i][j] = abs(stairs[i].x - stairs[j].x);
            }
        }
        dist[i][i] = 0;
    }
    for (int k=0; k<K; k++)
        for (int i=0; i<K; i++)
            for (int j=0; j<K; j++)
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
    
    cin >> T;
    while (T--) {
        int sx, sy, tx, ty;
        cin >> sx >> sy >> tx >> ty;
        if (sy == ty) {
            cout << abs(sx - tx) << '\n';
            continue;
        }
        int min_time = INT_MAX;
        vector<int> start, end;
        for (int i=0; i<K; i++) {
            if (stairs[i].h1 <= sy && sy <= stairs[i].h2) start.push_back(i);
            if (stairs[i].h1 <= ty && ty <= stairs[i].h2) end.push_back(i);
        }
        for (int s : start) {
            for (int e : end) {
                int d = abs(sx - stairs[s].x) + abs(tx - stairs[e].x) + dist[s][e];
                min_time = min(min_time, d + abs(sy - ty));
            }
        }
        cout << (min_time < 1e9 ? min_time : -1) << '\n';
    }
    return 0;
}
```

---

### 同类型题推荐
1. **P1144 最短路计数**：最短路径的变形，涉及多路径计数。
2. **P3371 单源最短路径（弱化版）**：Dijkstra算法的应用。
3. **P2962 [USACO09NOV]Lights G**：结合图遍历与状态压缩。

---

### 可视化与算法演示
**核心流程**：  
1. **预处理阶段**：展示每个楼梯的覆盖区间和列位置，用线段表示交叠关系。
2. **查询处理**：动画显示枚举楼梯组合，路径逐步展开，计算横向移动距离。

**复古像素效果**：  
- **颜色方案**：楼梯用蓝色，路径用黄色，成功路径渐变为绿色。
- **音效**：移动时播放“哔”声，成功路径播放8-bit胜利音乐。

---

**个人心得**：  
- **预处理的重要性**：针对多查询，预处理显著降低时间复杂度。
- **区间的交叠判断**：需仔细处理边界条件，避免错误连通性判断。

---
处理用时：589.93秒
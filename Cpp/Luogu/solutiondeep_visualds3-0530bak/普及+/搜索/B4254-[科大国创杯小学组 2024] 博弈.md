# 题目信息

# [科大国创杯小学组 2024] 博弈

## 题目描述

小可可和小聪聪最近在玩黑白棋！

在介绍本问题之前，我们先介绍黑白棋规则：

1. 游戏使用标准的 $8 \times 8$ 棋盘，上面初始时有四枚棋子：两枚黑色棋子和两枚白色棋子，按照对角线交叉排列。

2. 游戏开始时，黑方先行。

3. 玩家的目标是通过翻转对手的棋子，将棋盘上的大多数格子占为己有。

4. 每一步，玩家必须将自己的棋子放在一个合法的位置上。合法的位置必须满足以下条件：
   - 新放置的棋子必须与棋盘上已有的同色棋子在一条直线（水平、垂直或对角线）上夹住对方的一串棋子（夹住的意思是，在夹住的一端是己方的棋子，另一端是对方的棋子）。
   - 在夹住对方棋子的同时，所有被夹住的对方棋子都会被翻转成己方颜色。

5. 如果某一方无法合法落子，则该回合轮到对方继续行动。

6. 游戏继续进行，直到棋盘被填满或双方都无法合法落子。

7. 游戏结束时，棋盘上棋子数较多的一方获胜。如果双方棋子数相同，则为平局。

给定一个 $n \times n$ 棋盘上的黑白棋残局，对于接下来所有的可能局面——也就是说，黑方白方轮流行棋，白方先行，走到双方都无法行棋，在所有的可能状态中，最终黑方获胜的有多少种，白方获胜的有多少种，平局有多少种。

在本题中，我们定义残局为最多有不超过 $10$ 个未被放入棋子的格子。

需要注意的是：我们给出的棋盘不一定能够从一个合法的开局得到。你无需关心当前棋盘局面是如何形成的——即便它并不连通。

## 说明/提示

### 数据范围

- 数据点 $1 \sim 6$，$1 \leq n \leq 3$，空格子数不超过 $4$。
- 数据点 $7 \sim 12$，$1 \leq n \leq 4$，空格子数不超过 $5$。
- 数据点 $13 \sim 18$，$1 \leq n \leq 4$，空格子数不超过 $10$。
- 数据点 $19 \sim 23$，$1 \leq n \leq 5$，空格子数不超过 $5$。
- 数据点 $24 \sim 25$，$1 \leq n \leq 5$，空格子数不超过 $10$。

## 样例 #1

### 输入

```
3
-1 0 1
0 1 0
1 0 -1```

### 输出

```
2 0 0```

## 样例 #2

### 输入

```
4
-1 -1 -1 -1
-1 0 1 0
-1 1 0 1
-1 -1 -1 -1```

### 输出

```
1813 2494 519```

# AI分析结果



**唯一算法分类**：深度优先搜索（DFS）与回溯算法

---

### **题解思路与核心难点**

1. **核心思路**  
   - **状态枚举**：预处理所有空格，DFS 遍历所有可能的落子顺序，模拟每一步合法落子后的棋盘变化。
   - **合法落子判定**：沿 8 个方向检查是否存在被对方棋子夹住的情况，若存在则翻转该方向的所有对方棋子。
   - **递归终止条件**：空格填满或双方连续无法落子，统计最终棋子数决定胜负。

2. **解决难点**  
   - **翻转逻辑实现**：需正确遍历每个方向，并在确认夹住后执行翻转。
   - **状态管理**：递归中通过深拷贝保存棋盘状态，避免分支间的干扰。
   - **剪枝优化**：预处理空格减少无效遍历，直接跳过已填充的位置。

---

### **题解评分与亮点**

#### **题解：hujiaqi364（★★★★★）**
- **亮点**  
  - **预处理空格**：预先记录所有空格位置，减少每次遍历棋盘的开销。  
  - **高效回溯**：使用 `memcpy` 快速保存/恢复棋盘状态，避免频繁动态内存操作。  
  - **参数设计**：`cant` 参数记录连续无法落子次数，简化终止条件判断。  
- **代码示例**：
  ```cpp
  void dfs(int c, int k, int cant) {
      if (c == m || cant >= 2) { // 终止条件：空格填满或双方无法落子
          count(); // 统计结果
          return;
      }
      // 遍历所有空格尝试落子
      for (int i = 1; i <= m; ++i) {
          if (f[i]) continue;
          f[i] = 1; // 标记已用
          memcpy(p, a, sizeof p); // 保存当前棋盘
          a[x[i]][y[i]] = k; // 落子
          if (check(x[i], y[i], k)) { // 合法则递归
              dfs(c + 1, !k, 0);
          }
          memcpy(a, p, sizeof p); // 恢复棋盘
          f[i] = 0;
      }
      // 无法落子时换手
      if (!can) dfs(c, !k, cant + 1);
  }
  ```

#### **题解：wangxiaochai（★★★★☆）**
- **亮点**  
  - **模块化设计**：分离 `isValidMove`、`flipPieces` 函数，逻辑清晰。  
  - **递归切换玩家**：通过 `1 - player` 切换当前玩家，简化状态传递。  
- **潜在问题**：未预处理空格，每次遍历整个棋盘可能效率较低。

---

### **最优思路提炼**

1. **核心技巧**  
   - **空格预处理**：提前收集所有空格位置，减少无效遍历。
   - **快速状态管理**：使用内存拷贝（如 `memcpy`）代替逐元素复制，提升回溯效率。
   - **方向枚举法**：沿 8 个方向扩展，统一处理翻转逻辑。

2. **优化思维**  
   - **剪枝**：若当前玩家无合法落子，直接进入对方回合，避免无效分支。
   - **状态压缩**：棋盘较小（5x5），适合直接深拷贝而非哈希压缩。

---

### **类似题目推荐**

1. **[P1312 Mayan 游戏](https://www.luogu.com.cn/problem/P1312)**  
   - **相似点**：棋盘状态枚举与回溯，需处理复杂游戏规则。
2. **[P1074 靶形数独](https://www.luogu.com.cn/problem/P1074)**  
   - **相似点**：DFS 剪枝优化，状态回溯。
3. **[P1514 引水入城](https://www.luogu.com.cn/problem/P1514)**  
   - **相似点**：棋盘模拟与多路径决策。

---

### **可视化与算法演示**

1. **动画设计**  
   - **棋盘绘制**：5x5 像素网格，黑色（#000000）表示黑棋，白色（#FFFFFF）表示白棋，灰色（#808080）为空格。
   - **落子高亮**：当前落子位置用红色边框标记，翻转的棋子显示为渐变动画。
   - **音效触发**：落子时播放“滴”声，游戏结束时播放胜利/平局音效。

2. **交互控制**  
   - **步进执行**：允许用户逐帧观察落子与翻转过程。
   - **自动演示**：AI 模式自动选择合法落子，展示最优路径。

**代码片段（Canvas 绘制）**：
```javascript
function drawBoard(board) {
    ctx.clearRect(0, 0, 500, 500);
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            ctx.fillStyle = board[i][j] === 0 ? '#000' : board[i][j] === 1 ? '#fff' : '#808080';
            ctx.fillRect(j * 100, i * 100, 95, 95);
        }
    }
}
```

---

### **个人心得摘录**

- **调试教训**：翻转逻辑需严格检查方向终止条件，避免越界或错误翻转。
- **优化启发**：预处理空格显著减少递归深度，提升代码效率。

---

**结论**：通过暴力 DFS 枚举所有合法落子路径，结合高效状态管理与剪枝，可在有限数据规模下正确求解黑白棋残局问题。

---
处理用时：84.22秒
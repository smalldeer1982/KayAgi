# 题目信息

# [NOIP 1999 提高组] 邮票面值设计

## 题目背景

除直接打表外，本题不保证存在**正确且时间复杂度可以通过全部数据**做法。由于测试数据过水，部分错误做法可以通过此题，通过不代表做法正确。本题不接受 hack 数据。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

## 题目描述

给定一个信封，最多只允许粘贴 $N$ 张邮票，计算在给定 $K$（$N+K \le 15$）种邮票的情况下（假定所有的邮票数量都足够），如何设计邮票的面值，能得到最大值 $\mathsf{MAX}$，使在 $1$ 至 $\mathsf{MAX}$ 之间的每一个邮资值都能得到。

例如，$N=3$，$K=2$，如果面值分别为 $1$ 分、$4$ 分，则在 $1\sim 6$ 分之间的每一个邮资值都能得到（当然还有 $8$ 分、$9$ 分和 $12$ 分）；如果面值分别为 $1$ 分、$3$ 分，则在 $1\sim 7$ 分之间的每一个邮资值都能得到。可以验证当 $N=3$，$K=2$ 时，$7$ 分就是可以得到的连续的邮资最大值，所以 $\mathsf{MAX}=7$，面值分别为 $1$ 分、$3$ 分。


## 样例 #1

### 输入

```
3 2
```

### 输出

```
1 3
MAX=7
```

# AI分析结果



# 【NOIP 1999 提高组】邮票面值设计题解分析

## 算法分类
**DFS + 动态规划**

---

## 题解思路与难点

### 核心思路
1. **DFS枚举面值组合**：通过深度优先搜索生成递增的邮票面值组合。
2. **动态规划验证**：对每个生成的面值组合，用动态规划计算其能覆盖的最大连续邮资。
3. **剪枝优化**：在DFS中限制面值选择范围（上一面值+1 ~ 当前最大连续值+1），避免无效搜索。

### 解决难点
1. **面值选择上下界**：正确确定每个面值的取值范围，保证覆盖连续性。  
   若当前面值组合能覆盖到最大值`max_val`，则下一面值必须≤`max_val+1`，否则无法覆盖`max_val+1`。
2. **动态规划状态设计**：  
   - `dp[i]`表示组成邮资`i`所需最少邮票数。  
   - 状态转移方程：`dp[i] = min(dp[i], dp[i - a[j]] + 1)`，其中`a[j]`是当前面值组合中的邮票。

---

## 题解评分（≥4星）

### 1. 包子入侵（5星）
- **亮点**：  
  - 代码注释详细，DFS剪枝逻辑清晰。  
  - 动态规划部分通过`a[t]*n`快速确定最大可能邮资范围。  
  - 回溯逻辑简洁，使用全局变量保存最优解。
- **关键代码**：
  ```cpp
  void dfs(int t, int mx) {
    if (t == k+1) { /* 更新最优解 */ }
    for (int i = a[t-1]+1; i <= mx+1; i++) {
      a[t] = i;
      int x = dp(t, mx); // 计算当前组合的最大连续值
      dfs(t+1, x);
    }
  }
  ```

### 2. Celebrate（5星）
- **亮点**：  
  - 详细解释剪枝策略，明确面值上界为`t+1`。  
  - 动态规划部分优化循环范围至`a[k]*n`，减少计算量。  
  - 使用`memcpy`快速保存最优解。
- **关键代码**：
  ```cpp
  void dfs(int k) {
    if (k > m) { /* 更新答案 */ }
    for (int i = a[k-1]+1; i <= t+1; i++) {
      a[k] = i;
      int x = solve(k); // 计算当前最大连续值
      dfs(k+1);
    }
  }
  ```

### 3. Lynx（4星）
- **亮点**：  
  - DFS参数设计明确，传递`当前最大连续值`优化剪枝。  
  - 动态规划中通过`while(dp[i] <= n)`快速确定中断点。
- **关键代码**：
  ```cpp
  void dfs(int dep, int lst1, int lst2) {
    if (dep > k) { /* 更新最优解 */ }
    for (int i = lst1+1; i <= lst2+1; i++) {
      tmp[dep] = i;
      int x = calc(dep, sum + i); // 计算最大连续值
      dfs(dep+1, i, x);
    }
  }
  ```

---

## 最优思路与技巧提炼
1. **递增生成面值**：确保面值组合严格递增，避免重复搜索。
2. **动态规划剪枝**：通过`dp[i] > n`快速确定无法覆盖的邮资点。
3. **范围限制**：下一面值的上界为当前最大连续值+1，保证覆盖连续性。

---

## 类似算法题目
1. **洛谷P1092 虫食算**（DFS剪枝 + 状态验证）  
2. **洛谷P1379 八数码难题**（BFS + 状态哈希）  
3. **洛谷P1120 小木棍**（DFS剪枝 + 动态规划优化）

---

## 可视化设计（DFS搜索过程）
### 动画方案
1. **节点表示**：每个面值组合为树的一个节点，颜色标记当前搜索路径。  
2. **步进展示**：  
   - **当前面值选择**：高亮显示当前尝试的面值（如红色）。  
   - **剪枝过程**：灰色标记被跳过的无效范围（如超过`max_val+1`的值）。  
   - **动态规划结果**：显示当前组合的`dp`数组计算过程，突出中断点。  
3. **复古像素风格**：  
   - 使用8位色块表示不同面值，绿色为已选面值，黄色为当前尝试值。  
   - 音效：选中有效面值时播放“哔”声，剪枝时播放“咔”声。

---

## 核心代码示例
### DFS + 动态规划核心逻辑
```cpp
int dp(int t, int mx) {
    int f[50000];
    memset(f, 0x3f, sizeof(f));
    f[0] = 0;
    for (int i = 1; i <= t; i++) {
        for (int j = a[i]; j <= a[t] * n; j++) {
            f[j] = min(f[j], f[j - a[i]] + 1);
        }
    }
    for (int i = 1; i <= a[t] * n; i++) {
        if (f[i] > n) return i - 1;
    }
    return a[t] * n;
}

void dfs(int t, int mx) {
    if (t == k + 1) {
        if (mx > maxn) {
            maxn = mx;
            memcpy(ans, a, sizeof(a));
        }
        return;
    }
    for (int i = a[t-1] + 1; i <= mx + 1; i++) {
        a[t] = i;
        int x = dp(t, mx);
        dfs(t + 1, x);
    }
}
```

---
处理用时：79.15秒
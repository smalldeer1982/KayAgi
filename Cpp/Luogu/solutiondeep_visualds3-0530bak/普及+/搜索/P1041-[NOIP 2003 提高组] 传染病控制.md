# 题目信息

# [NOIP 2003 提高组] 传染病控制

## 题目背景

本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

---

近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。


## 题目描述

研究表明，这种传染病的传播具有两种很特殊的性质；

第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。


第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。


这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。


你的程序要针对给定的树，找出合适的切断顺序。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 300$。

**【题目来源】**

NOIP 2003 提高组第四题

## 样例 #1

### 输入

```
7 6
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
```

# AI分析结果



### 唯一算法分类
**DFS**

---

### 综合分析与结论
#### 核心思路与难点
1. **树形结构分层**：将节点按到根节点的距离分层，切断操作只能在相邻层之间进行，形成逐层决策的框架。
2. **子树大小预处理**：通过一次 DFS 预处理每个节点的子树大小，快速计算切断某子树后的未被感染人数。
3. **DFS 剪枝**：按层进行 DFS，每层枚举切断的子树，通过回溯统计最优解，结合子树大小剪枝避免无效搜索。
4. **状态标记与回溯**：用布尔数组标记已切断的子树，递归时动态更新状态，回溯时恢复现场。

#### 可视化设计思路
1. **分层树形结构**：用 Canvas 绘制树状图，不同层节点用不同颜色区分（如根节点红色，第二层蓝色等）。
2. **动态切断演示**：点击某层节点时，其子树变为灰色并播放 "切断音效"，动态显示剩余感染人数。
3. **回溯过程展示**：用虚线箭头表示递归返回路径，恢复子树颜色并播放轻微音效。
4. **像素风格优化**：
   - 节点用 16x16 像素方块表示，边缘锯齿化处理
   - 背景使用深蓝网格，模拟 CRT 显示器效果
   - 音效采用 8-bit 芯片音乐，切断时播放短促 "哔" 声，找到最优解时播放马里奥过关音效

---

### 题解清单（4星及以上）

#### 1. RikoHere（⭐️⭐️⭐️⭐️⭐️）
**亮点**：
- 模块化设计（clean/reclean 函数分离）
- 使用优先队列预处理层级关系
- 清晰的分层 DFS 框架
```cpp
void dfs(int cen, int tot) {
    maxx = max(maxx, tot); // 更新最大保护人数
    for (每个当前层节点) {
        if (!被切断) {
            int num = clean(节点); // 标记子树
            dfs(下一层, tot + num); 
            reclean(节点); // 回溯
        }
    }
}
```

#### 2. 基础不牢（⭐️⭐️⭐️⭐️）
**亮点**：
- 显式维护父节点状态
- 提前处理链式特例
```cpp
void dfs(int now, int cnt) {
    if (当前层全被切断) 直接更新答案;
    for (每个节点) {
        if (父节点未被切断) {
            切断该子树并递归;
        }
    }
}
```

#### 3. majt（⭐️⭐️⭐️⭐️）
**亮点**：
- 使用 vector 存储每层节点
- 最优剪枝提前终止搜索
```cpp
if (sum >= ans) return; // 关键剪枝
for (auto node : 当前层节点) {
    切断并递归;
}
```

---

### 关键代码实现
**预处理子树大小与层级**
```cpp
void dfs_pre(int u, int depth) {
    level[depth].push_back(u);
    max_depth = max(max_depth, depth);
    for (int v : children[u]) {
        dfs_pre(v, depth + 1);
        size[u] += size[v]; // 累加子树大小
    }
}
```

**核心 DFS 逻辑**
```cpp
int ans = n;
void dfs(int current_layer, int protected_cnt) {
    if (current_layer > max_depth) {
        ans = min(ans, n - protected_cnt);
        return;
    }
    
    for (int node : level[current_layer]) {
        if (父节点未被切断) {
            int save = cut_subtree(node); // 切断并返回保护人数
            dfs(current_layer + 1, protected_cnt + save);
            restore_subtree(node); // 回溯
        }
    }
}
```

---

### 相似题目推荐
1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)  
   （树形 DP，状态选择与回溯）
2. [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)  
   （树形 DP + 剪枝）
3. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)  
   （树形结构的最优划分）

---

### 可视化代码片段（Canvas 动画）
```javascript
// 绘制树节点（像素风格）
function drawNode(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*40, y*60, 32, 32); // 32x32 像素方块
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.strokeRect(x*40, y*60, 32, 32);
}

// DFS 动画核心
function animateDFS(layer) {
    if (layer > maxDepth) return;
    
    currentNodes = levels[layer];
    currentNodes.forEach((node, idx) => {
        setTimeout(() => {
            drawNode(node.x, node.y, '#f00'); // 高亮当前节点
            playSound('select'); // 播放选择音效
            
            setTimeout(() => {
                cutSubtree(node); // 切断子树
                animateDFS(layer + 1); // 递归下一层
            }, 500);
        }, idx * 1000); // 间隔 1 秒展示每个选择
    });
}
```

---

### 总结
本题通过分层 DFS 与子树预处理，将指数级复杂度优化为可行解。关键是通过树形结构的层级特性，将问题分解为逐层决策问题。可视化时强调层级递进与回溯过程，配合 8-bit 风格增强学习者的空间感知。同类问题可借鉴这种"分层处理+预处理剪枝"的框架。

---
处理用时：72.49秒
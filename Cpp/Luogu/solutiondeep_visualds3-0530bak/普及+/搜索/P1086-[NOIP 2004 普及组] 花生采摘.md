# 题目信息

# [NOIP 2004 普及组] 花生采摘

## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。

**注意**：在采摘过程中不能回到路边。

## 说明/提示

noip2004普及组第2题


## 样例 #1

### 输入

```
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0```

### 输出

```
37```

## 样例 #2

### 输入

```
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```

### 输出

```
28```

# AI分析结果



**算法分类**  
其他搜索（贪心策略）

---

### **题解思路与核心难点**

1. **核心思路**  
   所有题解均采用**贪心策略**，按花生数量降序处理每个植株。核心步骤：
   - 预处理：收集所有有花生的点，按数量排序。
   - 模拟采摘：从最大值开始，计算移动到该点的时间+采摘时间，并判断剩余时间能否返回路边。

2. **解决难点**  
   - **时间计算**：需区分首次进入（从路边到第一株）和后续移动（曼哈顿距离），并确保总时间包含返回路边的行数。
   - **终止条件**：若剩余时间不足以返回，立即终止采摘。

---

### **题解评分（≥4星）**

1. **jiangXxin（4星）**  
   - 亮点：结构体排序清晰，初始位置处理简洁，边界条件（`k >= ex`）正确。
   - 代码：[见原回答]

2. **MC_long_live（4星）**  
   - 亮点：稀松矩阵存储优化空间，时间判断逻辑严谨（`if (abs(...)+1+... > k)`）。
   - 代码：[见原回答]

3. **_Arahc_（4星）**  
   - 亮点：使用优先队列和 `map` 维护最大值，代码简洁高效。
   - 代码：[见原回答]

---

### **最优技巧提炼**

1. **贪心排序**  
   - 预处理所有花生点并按数量降序排列，确保优先处理最大值。

2. **曼哈顿距离计算**  
   - 移动时间 = |x₁ - x₂| + |y₁ - y₂|，避免复杂路径规划。

3. **时间判断优化**  
   - 每一步计算总时间（移动+采摘+返回），若超限则立即终止。

---

### **同类题目推荐**

1. **P1090 [NOIP2004 提高组] 合并果子**  
   - 贪心+优先队列，每次合并最小两堆。

2. **P1223 [贪心] 排队接水**  
   - 按接水时间升序排列，最小化总等待时间。

3. **P5019 [NOIP2018 提高组] 铺设道路**  
   - 贪心策略处理区间覆盖。

---

### **个人心得摘录**

- **边界处理**：首次采摘需单独判断能否返回（如 `k >= 2*x+1`）。
- **时间细节**：采摘时间固定为1单位，容易遗漏（如 `k--`）。
- **数据结构**：优先队列和结构体排序是优化代码的关键。

---

### **可视化设计思路**

1. **动画方案**  
   - **网格绘制**：以复古像素风格绘制花生田，高亮当前处理点。
   - **路径显示**：用曼哈顿路径（直角折线）展示移动过程。
   - **时间面板**：实时显示剩余时间和已采花生数。

2. **交互设计**  
   - **步进控制**：允许单步执行观察每个决策。
   - **音效触发**：成功采摘播放8位音效，超限时播放失败音效。

3. **复古风格**  
   - **颜色方案**：16色调色板，植株用绿色（有花生）和灰色（无花生）。
   - **背景音乐**：循环播放8位风格BGM，增强沉浸感。

---

### **代码片段（核心逻辑）**

```cpp
// jiangXxin 题解核心逻辑
sort(stu+1, stu+pn+1, comp); // 按花生数降序排序
int fx = 1, fy = stu[1].y;   // 初始位置（路边）
k--;                         // 进入第一株的时间
for (int i=1; i<=pn; i++) {
    int ex = stu[i].x, ey = stu[i].y;
    int tm = abs(fx-ex) + abs(fy-ey); // 曼哈顿距离
    k -= tm + 1;             // 移动时间 + 采摘时间
    if (k >= ex) {           // 剩余时间能否返回？
        ans += stu[i].sum;
        fx = ex; fy = ey;    // 更新当前位置
    } else break;
}
```

---

**END**

---
处理用时：77.61秒
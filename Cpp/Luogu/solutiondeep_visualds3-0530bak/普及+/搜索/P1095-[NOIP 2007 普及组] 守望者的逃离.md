# 题目信息

# [NOIP 2007 普及组] 守望者的逃离

## 题目背景

NOIP2007 普及组 T3

## 题目描述

恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。

守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。

为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。

守望者的跑步速度为 $17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1s$ 内移动 $60m$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。

现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间 $T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。

注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。


## 说明/提示

对于 $30\%$ 的数据，$1  \le  T   \le  10$，$ 1   \le   S   \le  100$；

对于 $50\%$ 的数据，$1   \le  T   \le   10^3$，$ 1   \le  S  \le   10^4$；

对于 $100\%$ 的数据，$1   \le   T   \le   3\times  10^5$，$0   \le   M   \le   10^3$，$ 1   \le  S   \le   10^8$。


## 样例 #1

### 输入

```
39 200 4
```

### 输出

```
No
197
```

## 样例 #2

### 输入

```
36 255 10```

### 输出

```
Yes
6```

# AI分析结果



---

**算法分类：其他搜索（贪心与动态规划）**

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
本题的关键在于在有限时间内选择 **闪现** 或 **跑步** 的最优策略。闪现速度更快（60m/s），但需魔法值；跑步稳定但速度慢（17m/s）。解决思路分为两类：
1. **贪心策略**：优先用魔法闪现，魔法不足时根据剩余时间、距离选择恢复魔法或跑步。
2. **动态规划**：维护每秒的最远距离，结合闪现和跑步的最优值。

#### **解决难点**
1. **魔法恢复与闪现的权衡**：魔法不足时需等待恢复，但等待时间可能比跑步更优。
2. **时间与距离的动态规划**：需在每一步选择中综合考虑魔法值、剩余时间、剩余距离的最优解。

---

### **题解评分（≥4星）**

1. **作者：wzr1125（5星）**  
   - **亮点**：双变量动态维护闪现与跑步距离，代码简洁高效。  
   - **代码片段**：
     ```cpp
     for(int i=1;i<=t;i++){ 
         if(m>=10) m-=10,fla+=60; 
         else m+=4;
         run = max(run +17, fla); 
         if(run>=s) { /* 成功逃离 */ }
     }
     ```

2. **作者：jingwenhan（4星）**  
   - **亮点**：动态规划数组记录每秒最优值，分两阶段处理闪现与跑步。  
   - **代码片段**：
     ```cpp
     for(int i=1;i<=t;i++){ 
         dp[i] = (m>=10) ? dp[i-1]+60 : dp[i-1]; 
         m = (m>=10) ? m-10 : m+4; 
     }
     ```

3. **作者：qhr2023（4星）**  
   - **亮点**：极简代码实现贪心策略，直接维护两个状态变量。  
   - **代码片段**：
     ```cpp
     for(int i=1; i<=t; i++){ 
         m>=10 ? (m-=10,s2+=60) : (m+=4); 
         s1 = max(s1+17, s2); 
     }
     ```

---

### **最优思路或技巧提炼**

1. **双状态维护法**：分别跟踪纯闪现距离和综合距离，每一步取最大值（如 `run = max(run+17, fla)`）。
2. **魔法值分段处理**：根据剩余魔法值（0~1、2~5、6~9）选择最优恢复策略，减少无效等待。
3. **动态规划优化**：分两步更新状态，先处理闪现再处理跑步，避免复杂条件判断。

---

### **同类型题与算法套路**

1. **贪心与动态规划结合**：类似「跳跃游戏」（LeetCode 55），需在每一步选择最优跳跃步数。
2. **资源约束优化**：如「加油站问题」（LeetCode 134），需在资源限制下找到最优路径。
3. **时间-状态权衡**：如「背包问题」的变形，需在时间与收益之间平衡。

---

### **推荐题目**
1. **P1048 采药**（动态规划，时间与收益的权衡）
2. **P1099 导弹拦截**（贪心策略与动态规划结合）
3. **P2014 选课**（树形动态规划，资源分配问题）

---

### **个人心得摘录**

- **wpy233**：通过魔法值分段构建决策表，减少无效循环，但代码复杂度较高。
- **Asurudo**：指出某些情况下闪现并非最优，需结合剩余时间与距离灵活选择。

---

### **可视化与算法演示**

#### **动画设计**
- **像素风格界面**：用网格表示时间轴，每格代表1秒，不同颜色标记闪现（蓝色）、恢复（黄色）、跑步（绿色）。
- **状态更新**：每秒更新魔法值、距离，动态显示 `fla` 与 `run` 的变化。
- **音效提示**：闪现时播放“嗖”音效，跑步时播放脚步声，成功/失败时播放不同音效。

#### **交互演示**
```javascript
// 伪代码：Canvas动画核心逻辑
function simulate() {
  let m = initialM, s = initialS, t = initialT;
  let run = 0, fla = 0;
  for (let i = 1; i <= t; i++) {
    if (m >= 10) { m -= 10; fla += 60; }
    else m += 4;
    run = Math.max(run + 17, fla);
    drawStep(i, m, run, fla); // 绘制当前状态
    if (run >= s) break;
  }
}
```

---

### **总结**
本题通过贪心与动态规划的巧妙结合，高效解决了时间与资源约束下的最优路径问题。核心在于状态维护与分段决策，适合作为动态规划入门与贪心策略的综合训练。

---
处理用时：65.69秒
# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果



# 最短路计数 - 题解分析

## 算法分类
**BFS**

---

## 题解思路与难点

### 核心逻辑
1. **BFS层序扩展**：由于是无权图，BFS天然满足层序访问特性，首次访问某节点的路径即为最短路。
2. **计数叠加规则**：
   - 若发现更短路径：重置计数为前驱节点的计数。
   - 若路径长度相同：累加前驱节点的计数到当前节点。
3. **高效存储与访问**：邻接表存储图结构，队列维护待处理节点，避免重复入队。

### 解决难点
- **动态更新计数**：通过维护距离数组 `dis` 和计数数组 `ans`，在 BFS 中正确处理相同距离的路径叠加。
- **大范围数据处理**：邻接表压缩存储，避免使用复杂数据结构导致内存超限。

---

## 题解评分（≥4星）

### 1. 作者：ZiDing_ByronFinlso（SPFA实现）
**★★★★☆**  
- **亮点**：SPFA实现简洁，利用队列优化，代码可读性强；初始化 `ans[1]=1` 清晰明确。  
- **代码示例**：
  ```cpp
  if (d[y] > d[x] + 1) { // 更短路径，重置计数
      d[y] = d[x] + 1;
      ans[y] = ans[x];
  } else if (d[y] == d[x] + 1) { // 相同路径，累加计数
      ans[y] = (ans[y] + ans[x]) % mod;
  }
  ```

### 2. 作者：岸芷汀兰（BFS实现）
**★★★★★**  
- **亮点**：纯BFS实现，逻辑直击核心；通过 `vis` 数组避免重复入队，高效处理计数叠加。  
- **个人心得**："每个节点只扩展比自己距离远1的结点" 点明了BFS的层序特性。

### 3. 作者：King丨帝御威（Dijkstra堆优化）
**★★★★☆**  
- **亮点**：Dijkstra的堆优化实现，展示不同算法殊途同归；优先队列管理距离更新。  
- **代码片段**：
  ```cpp
  priority_queue< pair<int,int> > q;
  q.push(make_pair(-d[y], y)); // 负权值实现小根堆
  ```

---

## 最优思路提炼

### 关键技巧
1. **BFS层序遍历**：保证首次访问即最短路径。
2. **动态计数叠加**：通过 `dis` 和 `ans` 数组配合，实现路径数的累加。
3. **邻接表压缩存储**：使用链式前向星或 `vector` 存储边，适应大规模数据。

### 代码片段（BFS核心）
```cpp
void bfs() {
    queue<int> q;
    q.push(1);
    ans[1] = 1; dis[1] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : adj[u]) {
            if (dis[v] == INF) { // 首次访问
                dis[v] = dis[u] + 1;
                ans[v] = ans[u];
                q.push(v);
            } else if (dis[v] == dis[u] + 1) { // 相同距离
                ans[v] = (ans[v] + ans[u]) % MOD;
            }
        }
    }
}
```

---

## 同类型题推荐
1. **P1608 路径统计**：带权图的最短路计数，需正确处理权值叠加。
2. **P2296 寻找道路**：BFS预处理+最短路计数，双重搜索逻辑。
3. **P3393 逃离僵尸岛**：分层BFS结合计数，多状态扩展。

---

## 可视化设计

### 动画方案
1. **节点状态标记**：
   - **红色**：当前处理节点。
   - **绿色**：队列中待处理节点。
   - **蓝色**：已访问完成节点。
2. **队列动态显示**：右侧面板实时展示队列内容，高亮当前出队节点。
3. **计数更新效果**：每次路径计数变化时，节点显示闪烁动画。

### 复古像素风格
- **8-bit 音效**：
  - 节点入队：短促“滴”声。
  - 计数更新：连续“嘟”声。
  - 搜索完成：经典通关音乐。
- **Canvas 绘制**：网格化节点布局，边用虚线连接，节点为16x16像素方块。

### 交互功能
- **步进控制**：支持空格键逐帧执行。
- **速度调节**：滑动条控制动画速度（0.5x~5x）。
- **模式切换**：BFS与DFS对比模式，观察遍历顺序差异。

---

## 总结
通过BFS的层序特性，结合动态计数规则，可高效解决无权图最短路计数问题。SPFA和Dijkstra的实现展示了不同算法的适用场景，而邻接表与队列的优化使用是处理大规模数据的关键。复古可视化设计增强了学习过程的趣味性，帮助理解节点扩展与计数逻辑。

---
处理用时：66.43秒
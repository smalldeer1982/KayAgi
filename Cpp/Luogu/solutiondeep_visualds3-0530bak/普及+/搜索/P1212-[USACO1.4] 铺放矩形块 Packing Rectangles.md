# 题目信息

# [USACO1.4] 铺放矩形块 Packing Rectangles

## 题目描述

给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)

$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  

这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。

可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，输入的所有数在 $[1,50]$ 内。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5
```

### 输出

```
40
4 10
5 8
```

# AI分析结果



## 算法分类
**DFS**

---

## 题解思路与解决难点
### 核心思路
1. **排列与旋转枚举**：通过 DFS 生成所有 4 个矩形的排列组合，并考虑每个矩形是否旋转（长宽交换）。
2. **六种布局计算**：对每种排列组合，应用题目给出的 6 种基本布局方式，计算对应的封闭矩形长宽。
3. **剪枝优化**：记录最小面积，动态更新结果，避免重复计算。

### 解决难点
- **排列组合的完备性**：DFS 递归确保所有排列和旋转情况被覆盖（共 `4! × 2^4 = 384` 种可能）。
- **复杂布局计算**：第六种布局需分多条件讨论矩形堆叠关系，易出错。
- **去重与结果记录**：用集合或数组记录所有满足最小面积的长宽组合，排序后输出。

---

## 题解评分（≥4星）
1. **七喜（4.5星）**
   - **亮点**：DFS 生成排列，代码结构清晰，注释详细，合并部分情况简化逻辑。
   - **代码可读性**：良好的变量命名，递归边界处理明确。
2. **Chiesl（4.2星）**
   - **亮点**：结构体存储结果，分情况讨论清晰，合并镜像情况。
   - **优化**：使用 `vector` 和 `sort` 去重，避免重复存储。
3. **legend_cn（4.0星）**
   - **亮点**：代码简洁，DFS 与 check 函数分离，注释关键分支。
   - **实践性**：直接输出结果，无冗余步骤。

---

## 最优思路与技巧
1. **DFS 生成排列与旋转**  
   递归枚举每个矩形的位置及旋转状态，确保覆盖所有可能性。
   ```cpp
   void dfs(int depth) {
       if (depth == 4) { check(); return; }
       for (int i=0; i<4; i++) {
           if (!used[i]) {
               used[i] = true;
               // 不旋转
               current[depth] = rects[i];
               dfs(depth+1);
               // 旋转后再次递归
               swap(current[depth].w, current[depth].h);
               dfs(depth+1);
               used[i] = false;
           }
       }
   }
   ```
2. **六种布局快速计算**  
   对排列后的矩形，按固定公式计算每种布局的封闭尺寸：
   ```cpp
   // 布局1：四矩形并排
   int case1_w = w1 + w2 + w3 + w4;
   int case1_h = max(h1, max(h2, max(h3, h4)));
   ```
3. **结果动态更新**  
   维护最小面积和候选边长集合，遇到更优解时重置集合。

---

## 类似题目推荐
1. **P1099 [NOIP2007 提高组] 树网的核**  
   （几何最值问题，需计算覆盖路径的最小矩形）
2. **P1514 [NOIP2010 提高组] 引水入城**  
   （区域覆盖问题，涉及排列组合与最优化）
3. **P1966 [NOIP2013 提高组] 火柴排队**  
   （排列最优化问题，需调整元素顺序）

---

## 可视化算法演示
### 搜索过程动画设计
- **节点表示**：每个矩形用不同颜色方块表示，当前排列用高亮边框。
- **访问顺序**：DFS 递归时，左侧面板显示当前选择的矩形序号及旋转状态。
- **布局绘制**：右侧画布动态绘制六种布局的封闭矩形，实时显示最小面积。

### 复古像素风格实现
- **颜色方案**：16 色调色板，矩形用红/绿/蓝/黄像素块表示。
- **音效设计**：
  - `访问新节点`：8-bit 短音效（类似《超级马里奥》金币声）。
  - `找到更优解`：上升音阶提示。
- **自动演示**：按 DFS 顺序自动切换排列，0.5 秒/步，可暂停观察。

---

## 关键代码片段（七喜题解核心）
```cpp
void check() {
    int x, y;
    // Case 1: 四矩形并排
    x = tmpx[1] + tmpx[2] + tmpx[3] + tmpx[4];
    y = max(max(tmpy[1], tmpy[2]), max(tmpy[3], tmpy[4]));
    alter(x, y);
    
    // Case 6: 复杂堆叠（分条件判断）
    y = max(tmpy[1]+tmpy[3], tmpy[2]+tmpy[4]);
    if (tmpy[1]+tmpy[3] <= tmpy[4])
        x = max(tmpx[2], max(tmpx[1], tmpx[3]) + tmpx[4]);
    else if (...) // 其他条件分支
    alter(x, y);
}

void dfs(int dep) {
    if (dep == 4) { check(); return; }
    for (int i=1; i<=4; i++) {
        if (!vis[i]) {
            tmpx[dep+1] = x[i]; // 不旋转
            tmpy[dep+1] = y[i];
            vis[i] = 1;
            dfs(dep+1);
            
            tmpx[dep+1] = y[i]; // 旋转后
            tmpy[dep+1] = x[i];
            dfs(dep+1);
            vis[i] = 0;
        }
    }
}
```

---
处理用时：71.26秒
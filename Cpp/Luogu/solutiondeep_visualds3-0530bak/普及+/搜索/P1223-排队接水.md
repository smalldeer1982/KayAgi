# 题目信息

# 排队接水

## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。


## 说明/提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。


## 样例 #1

### 输入

```
10 
56 12 1 99 1000 234 33 55 99 812```

### 输出

```
3 2 7 8 1 4 9 6 10 5
291.90
```

# AI分析结果



**算法分类**  
贪心算法

---

### **题解思路与核心难点**

**核心思路**  
通过贪心策略将接水时间短的人排在前面，减少后续等待时间的累加。数学证明相邻交换法（若存在逆序则总时间增加），故最优解为按时间升序排列。

**解决难点**  
1. **序号保存**：需在排序后输出原编号。题解通过结构体、pair、数组乘法（时间*1001+编号）等方式解决。
2. **等待时间计算**：总时间 = Σ(时间[i] * 剩余人数)，公式推导为关键。
3. **数据类型**：总时间需用`double`避免精度丢失。

---

### **题解评分 (≥4星)**  

1. **作者：f112358 (4.5星)**  
   - **亮点**：巧用`时间*1001 + 序号`存储数据，排序后取模分离序号，避免结构体。
   - **代码简洁性**：单数组处理，无额外数据结构。
   - **优化**：时间复杂度 O(n log n)。

2. **作者：BlueArc (4.5星)**  
   - **亮点**：结构体+sort排序，公式`time += a[i].b * (n-i)`直接计算总时间。
   - **可读性**：逻辑清晰，注释详细。

3. **作者：Anguei (4星)**  
   - **亮点**：使用`std::pair`简化代码，利用默认排序规则。
   - **优化**：动态内存分配避免浪费空间。

---

### **最优技巧提炼**

1. **贪心策略**：时间升序排列是核心，所有题解均基于此。
2. **数据结构**：
   - **结构体/pair**：同时保存时间和序号（推荐新手使用）。
   - **数值编码**：`时间*K + 序号`（K>最大序号）排序后取余解码（适合竞赛优化）。
3. **公式优化**：总时间 = Σ(时间[i] * (n-i))，避免双重循环累加。

---

### **同类型题目推荐**

1. **P1090 [NOIP2004 提高组] 合并果子**（贪心+优先队列）
2. **P1803 线段覆盖**（按右端点排序）
3. **P2240 部分背包问题**（性价比贪心）

---

### **可视化算法设计**

**核心动画流程**  
1. **初始队列**：显示乱序的接水时间（像素方块表示数值，附带原编号）。
2. **排序过程**：高亮当前比较的元素，若交换则播放“哔”音效。
3. **等待计算**：接水时，后续方块显示红色边框（表示等待），总时间累加并更新。

**复古像素风格**  
- **调色板**：8位色（时间值越大，颜色越深）。
- **音效**：排序交换（8-bit“滴答”声），计算完成（上扬音调）。
- **Canvas 演示**：网格显示每个人接水时间，排序后依次变绿表示已处理。

---

### **关键代码片段**

**结构体排序（BlueArc 题解）**
```cpp
struct Water { int time, num; };
bool cmp(Water a, Water b) { return a.time < b.time; }

sort(a+1, a+n+1, cmp);
for(int i=1; i<=n; i++) 
    total += a[i].time * (n - i);
```

**数值编码（f112358 题解）**
```cpp
t[i] = time * 1001 + i; // 存储
sort(t+1, t+n+1);
int id = t[i] % 1001;  // 解码
```

---

### **总结与扩展**

**核心结论**  
贪心策略下，按时间升序排列为最优解。结构体与数值编码是处理关联数据的两种高效方式。

**调试心得**  
- 总时间需用`double`，`float`可能导致精度不足（如作者zzozz的踩坑经历）。
- 冒泡排序在n较小时可用，但应优先选择O(n log n)算法。

---
处理用时：53.14秒
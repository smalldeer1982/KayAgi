# 题目信息

# 幻象迷宫

## 题目背景

（喵星人 LHX 和 WD 同心协力击退了汪星人的入侵，不幸的是，汪星人撤退之前给它们制造了一片幻象迷宫。）

WD：呜呜，肿么办啊……

LHX：momo...我们一定能走出去的！

WD：嗯，+U+U！

## 题目描述

幻象迷宫可以认为是无限大的，不过它由若干个 $N\times M$ 的矩阵重复组成。矩阵中有的地方是道路，用 $\verb!.!$ 表示；有的地方是墙，用 $\verb!#!$ 表示。LHX 和 WD 所在的位置用 $\verb!S!$ 表示。也就是对于迷宫中的一个点$(x,y)$，如果 $(x \bmod n,y \bmod m)$ 是 $\verb!.!$ 或者 $\verb!S!$，那么这个地方是道路；如果 $(x \bmod n,y \bmod m)$ 是$\verb!#!$，那么这个地方是墙。LHX 和 WD 可以向上下左右四个方向移动，当然不能移动到墙上。

请你告诉 LHX 和 WD，它们能否走出幻象迷宫（如果它们能走到距离起点无限远处，就认为能走出去）。如果不能的话，LHX 就只好启动城堡的毁灭程序了……当然不到万不得已，他不想这么做。

## 说明/提示

- 对于 $30\%$ 的数据，$1\le N,M\le 20$；
- 对于 $50\%$ 的数据，$1\le N,M\le 100$；
- 对于 $100\%$ 的数据，$1\le N,M\le 1500$，每个测试点不超过 $10$ 组数据。

## 样例 #1

### 输入

```
5 4
##.#
##S#
#..#
#.##
#..#
5 4
##.#
##S#
#..#
..#.
#.##
```

### 输出

```
Yes
No

```

# AI分析结果



### 【唯一算法分类】  
**DFS**

---

### **题解思路、算法要点与解决难点**  
- **核心思路**：  
  通过DFS遍历迷宫，记录每个位置的模坐标（取模后的坐标）和对应的绝对坐标。若同一模坐标被多次访问且绝对坐标不同，说明存在无限路径。  

- **解决难点**：  
  1. **无限迷宫的表示**：通过取模运算将绝对坐标映射到原始迷宫范围，无需实际扩展迷宫。  
  2. **循环路径检测**：若某模坐标的绝对坐标与之前不同，则说明路径跨越多个迷宫块，可无限延伸。  

- **关键实现**：  
  - `vis[x][y][lx, ly]`：记录模坐标`(x, y)`对应的绝对坐标`(lx, ly)`。  
  - DFS中每次移动时更新绝对坐标，并通过模运算计算新的模坐标。  

---

### **题解评分 (≥4星)**  
1. **DEVILK (5星)**  
   - **亮点**：代码简洁，通过模坐标和绝对坐标的对比直接判断无限路径。  
   - **代码片段**：  
     ```cpp  
     void dfs(int x, int y, int lx, int ly) {  
         if (vis[x][y][0] && (vis[x][y][1] != lx || vis[x][y][2] != ly)) {  
             fl = 1; // 触发无限路径条件  
             return;  
         }  
         vis[x][y][0] = 1;  
         vis[x][y][1] = lx, vis[x][y][2] = ly;  
         // 更新四个方向  
     }  
     ```  

2. **ygsldr (4星)**  
   - **亮点**：将迷宫扩展为2倍，通过边界传送简化逻辑。  
   - **代码片段**：  
     ```cpp  
     bool dfs(int x, int y) {  
         if (map1[x][y] || map2[x % n][y % m]) return true;  
         map1[x][y] = map2[x % n][y % m] = true;  
         // 处理边界传送  
     }  
     ```  

3. **LengChu (4星)**  
   - **亮点**：使用哈希函数记录绝对坐标，避免负数取模问题。  
   - **代码片段**：  
     ```cpp  
     int f(int x, int y) { return (x + n * 4) / n * 131 + ...; }  
     if (book[tx][ty] != f(v.x, v.y)) return true;  
     ```  

---

### **最优思路或技巧提炼**  
1. **模坐标与绝对坐标分离**：通过取模运算将无限迷宫映射到有限范围，记录绝对坐标以检测循环路径。  
2. **哈希优化**：对绝对坐标进行哈希处理，快速判断是否重复访问。  
3. **边界传送逻辑**：处理越界时直接传送到对应位置，模拟无限扩展。  

---

### **同类型题或类似算法套路**  
- **通用解法**：  
  - 迷宫类问题中，若需处理无限扩展，可通过模运算和坐标映射避免内存爆炸。  
  - 循环路径检测可结合哈希或绝对坐标记录。  

- **类似题目**：  
  1. **P1825 [USACO11OPEN]Corn Maze S**（传送门机制）  
  2. **P1519 Crossing Threshold**（无限扩展判断）  
  3. **P1141 01迷宫**（连通块与路径搜索）  

---

### **个人心得摘录**  
- **DEVILK**：初始误判边界条件，通过反例修正逻辑（如样例`3x5`迷宫）。  
- **LengChu**：负数取模需特殊处理，否则导致索引错误。  
- **xiejinhao**：扩展为2倍迷宫即可满足条件，3倍会超内存。  

---

### **可视化与算法演示**  
1. **动画设计**：  
   - **节点绘制**：原始迷宫网格，当前节点高亮为红色，已访问节点为灰色。  
   - **路径扩展**：DFS栈动态显示，跨迷宫块时显示绝对坐标偏移。  
   - **终止条件**：当检测到重复模坐标时，红色闪烁提示成功。  

2. **复古像素风格**：  
   - **颜色方案**：16色调色板，迷宫墙为深蓝，路径为浅绿，起点为黄色。  
   - **音效**：访问新节点时播放8bit“滴”声，成功时播放胜利音效。  

3. **交互功能**：  
   - **步进控制**：支持暂停/继续，调整DFS速度。  
   - **自动演示**：AI自动执行DFS，显示当前绝对坐标和模坐标。  

```javascript  
// 示例：Canvas绘制节点  
function drawNode(x, y, isVisited) {  
    ctx.fillStyle = isVisited ? "#888" : "#2E86C1";  
    ctx.fillRect(x * 20, y * 20, 18, 18);  
}  
// 触发音效  
function playSound(effect) {  
    const audio = new Audio(`sfx-${effect}.wav`);  
    audio.play();  
}  
```  

--- 

**核心搜索逻辑实现**  
```cpp  
// DEVILK的DFS核心逻辑  
void dfs(int x, int y, int lx, int ly) {  
    if (vis[x][y][0] && (vis[x][y][1] != lx || vis[x][y][2] != ly)) {  
        fl = 1;  
        return;  
    }  
    vis[x][y][0] = 1;  
    vis[x][y][1] = lx, vis[x][y][2] = ly;  
    for (int i = 0; i < 4; ++i) {  
        int xx = (x + dx[i] + n) % n;  
        int yy = (y + dy[i] + m) % m;  
        int lxx = lx + dx[i], lyy = ly + dy[i];  
        if (!a[xx][yy]) dfs(xx, yy, lxx, lyyy);  
    }  
}  
```

---
处理用时：85.42秒
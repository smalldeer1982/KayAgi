# 题目信息

# 进攻幽暗城

## 题目背景

由于震惊海内外的 “愤怒门投毒事件” 的发生，部落为了对抗皇家药剂师协会的叛乱，所有的外交工作完成后，部落大酋长萨尔带领着小 A 穿过传送门到达幽暗城平叛。


## 题目描述

幽暗城的地图是一个 $n \times m$ 的 $01$ 串。$a_{i, j} = 1$ 时表示 $(i, j)$ 的位置是障碍，无法通过；$a_{i, j} = 0$ 时表示 $(i, j)$ 的位置可以进入。

小 A 与萨尔的初始位置是 $(x_1, y_1)$，而恐惧魔王的初始位置是 $(x_2, y_2)$。小 A 的目标就是到达恐惧魔王的位置。

萨尔会按照一个特定的路线行走，该路线是一个数字串，由 $0 \sim 4$ 组成。

第 $i$ 秒，若数字串第（$i \bmod {}$数字串的长度）位等于 $0$，则表示这一秒萨尔将会原地不动；   
等于 $1$，则表示这一秒萨尔会向上走一格；   
等于 $2$，则表示这一秒萨尔会向下走一格；   
等于 $3$，则表示这一秒萨尔会向左走一格；   
等于 $4$，则表示这一秒萨尔会向右走一格。

若萨尔将要移动的位置是墙或者超出迷宫的范围，则萨尔会原地不动。恐惧魔王也是这样。（换句话说，你可以认为如果将数字串是重复无限次，第 $i$ 秒就是字符串第 $i$ 位）

小A每秒可以选择从上下左右四个方向中选择一个方向，朝那个方向走一格，前提是那个位置不是墙并且没有超出迷宫的范围；或者原地不动。不过，由于幽暗城的诡异环境，小 A 只能持续脱离萨尔的光环 $s$ 秒，若超过 $s$ 秒小 A 则会死亡。光环的有效半径为 $d$ ，表示当小 A 与萨尔之间的距离 $\sqrt{(x-xx)^2+(y-yy)^2}$ 小于等于 $d$ 时小 A 才能受到萨尔光环的效果。若小 A 脱离萨尔的光环又重新进入光环有效区域，则再次离开光环时持续时间归零重记。

小 A 想知道最少需要几秒他才能到达恐惧魔王所在的位置。

## 说明/提示

**【题目来源】**

kiro 原创

**【数据范围】**

对于 $100\%$ 的数据，$1 \le n,m \le 50$，$0 \le s \le 1000$，$0 \le d \le 100$，$1 \le $ 数字串长度 $ \le 100$，$0 \le $ 答案 $ \le 100$。

## 样例 #1

### 输入

```
3 4 7 3
1010
0000
0101
1 2 3 3
0132401
12131
```

### 输出

```
3
```

# AI分析结果



## 算法分类
**BFS**

---

## 综合分析与结论
### 核心思路
1. **预处理NPC路径**：萨尔和恐惧魔王的移动路径固定，可预先计算每时刻的位置，避免BFS中重复计算。
2. **状态设计**：状态为小A的坐标、当前时间、连续脱离光环时间。萨尔和魔王的位置通过时间直接查表获取。
3. **剪枝优化**：若当前脱离时间超过s秒则剪枝；利用预处理数据快速计算欧氏距离判断是否在光环内。
4. **终止条件**：小A与魔王位置相同即输出当前时间。

### 可视化设计
- **网格动态绘制**：用不同颜色标记小A（蓝色）、萨尔（绿色）、魔王（红色）、障碍（黑色）。
- **光环范围**：以萨尔为中心绘制半透明圆形区域，脱离时红色闪烁提示。
- **队列状态展示**：右侧面板显示BFS队列内容，高亮当前处理节点。
- **8位像素风格**：采用NES复古配色，角色用16x16像素块表示，移动时辅以“滴”声效。
- **步进控制**：支持暂停/继续，拖拽进度条观察特定时刻状态。

---

## 题解清单（≥4星）

### 1. wzmzmhk（5星）
- **亮点**：清晰的状态结构体设计，双重位置校验（移动前/后），完整预处理逻辑
- **代码片段**：
```cpp
struct coord {
    int Ax, Ay, sx, sy, demx, demy, t, t1;
};
// 预处理魔王位置
for(int i=1; i<=100; i++){
    int tx = Lorx[i-1] + dx[order[i%len]];
    if(valid(tx)) Lorx[i] = tx; //边界检查略
}
```

### 2. world_execute（4.5星）
- **亮点**：迭代加深搜索应用，合理利用答案上限约束
- **技巧**：分层限制搜索深度，避免无效分支

### 3. May_Cry_（4星）
- **亮点**：精简状态表示，音效触发逻辑
- **心得**："必须特判移动后相遇，否则70分" — 强调边界检查重要性

---

## 核心代码实现
### BFS主逻辑（wzmzmhk题解核心）
```cpp
queue<coord> q;
q.push(初始状态);
while(!q.empty()){
    coord cur = q.front(); q.pop();
    // 预处理NPC位置
    int s_step = cur.t % sal_len;
    Point sal_pos = pre_sal[s_step];
    // 移动判断
    for(int dir=0; dir<5; dir++){
        int nx = cur.x + dx[dir];
        int ny = cur.y + dy[dir];
        if(越界或障碍) continue;
        // 计算脱离时间
        double dis = sqrt(pow(nx-sal_pos.x,2)+pow(ny-sal_pos.y,2));
        int new_out = (dis > d) ? cur.out_time+1 : 0;
        if(new_out > s) continue; //剪枝
        // 终止条件
        if(nx == pre_devil[cur.t+1].x && ny == pre_devil[cur.t+1].y)
            return cur.t+1;
        q.push({nx, ny, cur.t+1, new_out});
    }
}
```

---

## 相似题目推荐
1. **P1443 马的遍历** - BFS基础应用
2. **P1126 机器人搬重物** - 带状态的方向处理
3. **P1514 引水入城** - 多目标BFS+剪枝

---

## 可视化代码片段（Canvas绘制）
```javascript
function drawGrid() {
  ctx.fillStyle = "#2D2D2D"; // 深灰背景
  ctx.fillRect(0,0,canvas.width,canvas.height);
  // 绘制网格线
  for(let x=0; x<=cols; x++){
    ctx.beginPath();
    ctx.moveTo(x*TILE_SIZE, 0);
    ctx.lineTo(x*TILE_SIZE, rows*TILE_SIZE);
    ctx.strokeStyle = "#404040";
    ctx.stroke();
  }
  // 绘制萨尔光环
  ctx.beginPath();
  ctx.arc(sal.x*TILE_SIZE, sal.y*TILE_SIZE, d*TILE_SIZE, 0, 2*Math.PI);
  ctx.fillStyle = "rgba(0,255,0,0.2)";
  ctx.fill();
}
```

---

## 复古音效方案
```javascript
const sfx = {
  move: new Howl({src: 'data:audio/wav;base64,UklGRl9...'}), // 8-bit bleep
  win: new Howl({src: 'data:audio/wav;base64,UklGRk9...'}),
  danger: new Howl({src: 'data:audio/wav;base64,UklGRiA...'})
};
// 移动时触发
sfx.move.play(); 
```

---

## 关键优化总结
1. **时空分离**：将NPC运动与玩家运动解耦，预处理NPC路径节省计算
2. **状态压缩**：通过时间隐式携带NPC位置，避免五维状态爆炸
3. **欧氏距离缓存**：预处理平方值避免重复开方
```cpp
// 距离判断优化（避免sqrt）
bool inRange(int x1, int y1, int x2, int y2) {
    return (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) <= d*d;
}
```

---
处理用时：79.06秒
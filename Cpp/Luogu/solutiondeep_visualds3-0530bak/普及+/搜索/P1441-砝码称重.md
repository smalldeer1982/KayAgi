# 题目信息

# 砝码称重

## 题目描述

现有 $n$ 个砝码，重量分别为 $a_i$，在去掉 $m$ 个砝码后，问最多能称量出多少不同的重量（不包括 $0$）。

请注意，砝码只能放在其中一边。

## 说明/提示

【样例说明】

在去掉一个重量为 $2$ 的砝码后，能称量出 $1, 2, 3$ 共 $3$ 种重量。


【数据规模】

对于 $20\%$ 的数据，$m=0$。

对于 $50\%$ 的数据，$m\leq 1$。

对于 $50\%$ 的数据，$n\leq 10$。

对于 $100\%$ 的数据，$n\leq 20$， $m\leq 4$，$m < n$，$a_i\leq 100$。


## 样例 #1

### 输入

```
3 1
1 2 2```

### 输出

```
3```

# AI分析结果



### 算法分类
**DFS + 动态规划**

---

### 题解思路与核心难点
#### 核心思路
1. **DFS枚举删除组合**：通过DFS遍历所有可能的删除m个砝码的组合，保留n-m个砝码。
2. **动态规划计算子集和**：对保留的砝码进行01背包计算，统计能组成的重量种类数。

#### 解决难点
- **剪枝优化**：DFS时若已删除砝码数超过m则剪枝，减少无效搜索。
- **高效DP**：用滚动数组优化空间，倒序更新避免重复计算。
- **去重技巧**：通过排序砝码或记录已处理状态，避免重复计算相同组合。

---

### 题解评分（≥4星）
1. **hsfzLZH1（4.5星）**
   - 亮点：DFS剪枝高效，动态规划用tot变量优化计算范围。
   - 代码可读性强，剪枝逻辑清晰。

2. **pantw（5星）**
   - 亮点：状态压缩枚举+bitset位运算，代码简洁高效。
   - 利用bitset的位并行特性，O(n)时间完成子集和计算。

3. **wzhhhhh（4星）**
   - 亮点：状态压缩+int代替bitset，空间更紧凑。
   - 直接枚举所有子集，适合n=20的极限情况。

---

### 最优思路提炼
```cpp
// 状态压缩+bitset（pantw题解核心代码）
for(int i=0; i<= (1<<n)-1; i++) {
    if(popcount(i) == n-m) {
        bitset<2010> S;
        S[0] = 1;
        for(int j=0; j<n; j++) 
            if(i & (1<<j)) S |= S << a[j];
        ans = max(ans, (int)S.count()-1);
    }
}
```
**技巧总结**：
- **状态压缩**：用二进制位表示砝码是否保留，直接遍历所有组合。
- **bitset优化**：位运算快速合并子集和，复杂度O(n·sum/32)。

---

### 同类题目推荐
1. **P2347 砝码称重**（基础子集和问题）
2. **P1036 选数**（DFS枚举子集+质数判断）
3. **P2392 背包问题**（多重背包变形）

---

### 可视化算法演示（DFS+bitset）
**动画设计**：
1. **节点表示**：每个砝码为像素块，红色表示已删除，绿色保留。
2. **搜索过程**：DFS递归树动态展开，当前路径高亮显示。
3. **bitset更新**：右侧显示bitset二进制位，实时展示新重量生成。

**复古像素风格**：
- **8-bit音效**：节点选中时播放“哔”声，新重量生成时播放上升音阶。
- **Canvas绘制**：砝码用16x16像素块，颜色区分状态，背景循环芯片音乐。

---

### 核心代码（DFS剪枝+DP）
```cpp
void dfs(int cur, int now) {
    if(now > m) return; // 剪枝：已删超过m
    if(cur == n) {
        if(now == m) dp(); // 执行动态规划
        return;
    }
    dfs(cur+1, now); // 保留当前砝码
    tf[cur] = true;  // 标记删除
    dfs(cur+1, now+1);
    tf[cur] = false; // 回溯
}

void dp() {
    memset(f, 0, sizeof f);
    f[0] = true; ans = 0; tot = 0;
    for(int i=0; i<n; i++) {
        if(tf[i]) continue; // 跳过删除的砝码
        for(int j=tot; j>=0; j--)
            if(f[j] && !f[j+a[i]]) 
                f[j+a[i]] = true, ans++;
        tot += a[i]; // 动态更新最大可能重量
    }
    ret = max(ret, ans);
}
```

---
处理用时：56.01秒
# 题目信息

# [USACO2.2] 派对灯 Party Lamps

## 题目描述

在 IOI98 的节日宴会上，我们有 $n$ 盏彩色灯，他们分别从 $1 \sim n$ 被标上号码。这些灯都连接到四个按钮：

按钮 $1$：当按下此按钮，将改变所有的灯：本来亮着的灯就熄灭，本来是关着的灯被点亮。

按钮 $2$：当按下此按钮，将改变所有奇数号的灯。

按钮 $3$：当按下此按钮，将改变所有偶数号的灯。

按钮 $4$：当按下此按钮，将改变所有序号是 $3k+1 \ (k \in [0,+\infty) \cap \mathbb Z)$ 的灯。例如：$1,4,7,10 \dots$

一个计数器 $c$ 记录按钮被按下的次数。当宴会开始，所有的灯都亮着，此时计数器 $c$ 为 $0$。

你将得到计数器 $c$ 上的数值和经过若干操作后某些灯的状态。写一个程序去找出所有灯最后可能的与所给出信息相符的状态，并且没有重复。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$10 \le n \le 100$，$0 \le c \le 10^4$。

【样例解释】  
在这个样例中，有三种可能的状态：

- 所有灯都关着

- $1,4,7,10$ 号灯关着，$2,3,5,6,8,9$ 亮着。

- $1,3,5,7,9$ 号灯关着，$2,4,6,8,10$ 亮着。


翻译来自NOCOW

USACO 2.2


## 样例 #1

### 输入

```
10
1
-1
7 -1
```

### 输出

```
0000000000
0101010101
0110110110
```

# AI分析结果



# 【算法分类】  
其他搜索

---

# **题解思路与算法要点**  
本题目通过分析按钮操作的性质，发现每个按钮按偶数次等于无效，最终状态仅与按钮按奇数次的情况有关。结合灯的周期性变化（每6个灯状态重复），将问题简化为枚举所有可能的按钮组合（共16种），并检查生成的6位状态是否满足输入条件。通过预处理输入条件并利用位运算高效生成和验证状态，最终收集所有合法状态并按字典序输出。

**核心难点**：  
1. **按钮组合的等效性**：多个按钮组合可能生成相同状态，需去重。  
2. **状态生成与验证**：通过位掩码快速生成状态，并高效检查是否符合输入条件。  
3. **次数限制处理**：根据c的奇偶性和次数上限筛选合法按钮组合。

---

# **题解评分（≥4星）**  
1. **Orzalpha（⭐⭐⭐⭐⭐）**  
   - **亮点**：通过数学公理推导状态等效性，利用预生成常量表快速验证，代码简洁高效。  
   - **核心**：将状态分为8种，直接查表验证，极大减少计算量。  

2. **key_rA9（⭐⭐⭐⭐）**  
   - **亮点**：位运算与循环节结合，直接枚举所有可能状态，代码逻辑清晰。  
   - **核心**：预处理状态表，直接生成并排序输出，逻辑紧凑。  

3. **resftlmuttmotw（⭐⭐⭐⭐）**  
   - **亮点**：枚举按钮奇偶性并利用集合去重，代码可读性强，实践友好。  
   - **核心**：通过奇偶性过滤组合，生成状态并验证，逻辑直接。  

---

# **最优思路与技巧提炼**  
1. **周期性与位掩码**：将灯的状态压缩为6位循环，利用位掩码快速生成按钮操作后的状态。  
2. **等效性剪枝**：通过数学推导减少需枚举的状态数，如按钮组合的等效性分析。  
3. **集合去重与排序**：用集合存储合法状态，自动去重并排序，简化代码逻辑。  

---

# **类似题目推荐**  
1. **P1219 八皇后**（DFS经典问题，状态压缩与剪枝）  
2. **P1120 小木棍**（DFS+剪枝，枚举与状态验证）  
3. **P1032 字串变换**（BFS最短路径，状态生成与去重）  

---

# **核心代码实现**  
```python
n = int(input())
c = int(input())

on_bits = set()
off_bits = set()

# 处理必须亮的灯
x = list(map(int, input().split()))
for num in x:
    if num == -1:
        break
    idx = (num - 1) % 6
    on_bits.add(idx)

# 处理必须灭的灯
x = list(map(int, input().split()))
for num in x:
    if num == -1:
        break
    idx = (num - 1) % 6
    off_bits.add(idx)

valid_states = set()

# 按钮掩码：按钮1~4对应的6位掩码
masks = [63, 42, 21, 36]

for i in range(2):
    for j in range(2):
        for k in range(2):
            for l in range(2):
                cnt = i + j + k + l
                if cnt > c or (cnt % 2) != (c % 2):
                    continue
                # 生成状态
                state = 63
                state ^= i * masks[0]
                state ^= j * masks[1]
                state ^= k * masks[2]
                state ^= l * masks[3]
                
                # 检查状态合法性
                valid = True
                for idx in on_bits:
                    if (state & (1 << idx)) == 0:
                        valid = False
                        break
                if not valid:
                    continue
                for idx in off_bits:
                    if (state & (1 << idx)) != 0:
                        valid = False
                        break
                if valid:
                    # 生成n位字符串
                    s = []
                    for pos in range(n):
                        bit = (state >> (pos % 6)) & 1
                        s.append('1' if bit else '0')
                    valid_states.add(''.join(s))

if not valid_states:
    print("IMPOSSIBLE")
else:
    for s in sorted(valid_states):
        print(s)
```

---

# **可视化与算法演示**  
**搜索过程动画设计**：  
1. **像素化网格**：用6×6网格表示灯的状态，每个格子显示当前位的亮（黄色）或灭（蓝色）。  
2. **按钮操作演示**：点击按钮时，触发对应掩码的异或操作，高亮显示被翻转的灯。  
3. **自动模式**：按顺序枚举按钮组合，显示生成的状态并检查合法性，合法状态以绿色边框标记。  
4. **音效反馈**：  
   - 翻转音效：8-bit风格“哔”声。  
   - 合法状态：短促上扬音效。  
   - 非法状态：低沉提示音。  

**复古风格控制面板**：  
- 按钮：8-bit风格像素按钮，点击触发操作。  
- 状态显示：LED灯样式展示当前6位状态。  
- 速度调节：滑动条控制动画速度，支持暂停/继续。  

**演示示例**：  
![像素化按钮与灯网格](demo.gif)  
（注：实际实现需结合Canvas与Web Audio API）

---
处理用时：308.14秒
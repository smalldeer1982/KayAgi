# 题目信息

# [POI 2004] SZP

## 题目背景

一班班花 [$\color{red}{\texttt{y}}\color{black}{\texttt{hb}}$](/user/835809) 十分可爱。

## 题目描述

班花 [$\color{red}{\texttt{y}}\color{black}{\texttt{hb}}$](/user/835809) 作为某日的值日班长，在自习课上管理着 $n$ 名同学。除了她以外每一名同学都监视着另一名同学。现在班花 [$\color{red}{\texttt{y}}\color{black}{\texttt{hb}}$](/user/835809) 需要选择尽量多的同学去搬卷子和答题卡，且使得对于这些同学中的每一名同学，至少有一位监视她的同学没有被选中。问班花 [$\color{red}{\texttt{y}}\color{black}{\texttt{hb}}$](/user/835809) 最多可以选择多少同学。

由于班花 [$\color{red}{\texttt{y}}\color{black}{\texttt{hb}}$](/user/835809) 太可爱了，所以没有人监视她，也可以认为她的学号是 $0$。

如果一个人没有被监视，那么她就不能被选择。


## 说明/提示

对于 $100\%$ 的数据，$1\le k,a_k\le n\le 10^6$。

## 样例 #1

### 输入

```
6
2
3
1
3
6
5
```

### 输出

```
3```

# AI分析结果



### 唯一算法分类：BFS

---

### 综合分析与结论

#### 核心思路与难点
题目转化为在基环树森林中选择最大点集，满足每个被选点至少有一个未被选的前驱监视者。核心难点在于处理链式结构和环结构：
1. **链式结构**：用拓扑排序处理入度为0的节点。入度为0的节点必须不选，其监视者必须被选，以此类推。
2. **环结构**：每个环可选的节点数为环长的一半（向下取整），通过贪心策略选择交替节点。

#### 搜索算法要点
- **BFS实现拓扑排序**：用队列维护入度为0的节点，逐步处理链式结构。
- **环处理**：遍历未访问节点统计环长，直接取半。

#### 可视化设计思路
1. **节点状态标记**：已选（绿色）、未选（红色）、待处理（黄色）。
2. **队列动画**：展示节点入队出队过程，处理链式结构。
3. **环遍历动画**：以不同颜色高亮环的遍历路径，动态显示环长计算。
4. **像素化风格**：采用8位像素网格，节点用方块表示，边用箭头连接，音效配合节点状态变化。

---

### 题解清单（≥4星）

1. **wyd_is_JOKER（5星）**
   - **亮点**：简洁高效的拓扑排序+环长取半策略，时间复杂度O(n)，代码可读性强。
   - **代码核心**：
     ```cpp
     while (!Q.empty()) {
         int u = Q.front(); Q.pop();
         vis[u] = 1;
         if (choose[u]) {
             in[ak[u]]--;
             if (!in[ak[u]]) Q.push(ak[u]);
         } else {
             if (!choose[ak[u]]) {
                 choose[ak[u]] = 1;
                 ans++;
                 Q.push(ak[u]);
             }
         }
     }
     // 处理环
     for (int i=1; i<=n; i++) if (!vis[i]) {
         int cnt = 0;
         for (int j=i; !vis[j]; j=ak[j]) cnt++, vis[j]=1;
         ans += cnt / 2;
     }
     ```

2. **zac2010（4星）**
   - **亮点**：基环树DP，适用于更复杂的约束条件，思路严谨但实现稍复杂。
   - **核心思想**：断环成树，DP计算两种情况的最大值。

3. **OI_AKed_me（4星）**
   - **亮点**：贪心策略清晰，处理环时直接统计未选节点，代码简洁。
   - **核心代码**：
     ```cpp
     while (!Q.empty()) {
         int u = Q.front(); Q.pop();
         ans += use[u];
         if (!use[u] && !use[to[u]]) {
             use[to[u]] = 1;
             Q.push(to[u]);
         }
     }
     ```

---

### 最优思路提炼
1. **拓扑排序处理链**：入度为0的节点不选，强制选其监视者。
2. **环长取半贪心**：每个环最多选⌊环长/2⌋个节点。
3. **BFS队列优化**：线性时间复杂度，适用于大规模数据。

---

### 相似题目推荐
1. **P2607 [ZJOI2008] 骑士**（基环树DP）
2. **P1352 没有上司的舞会**（树形DP）
3. **P2661 信息传递**（基环树找环）

---

### 个人心得摘录
- **fishing_cat**：处理环时误将总环点数除二，导致奇数环错误，提醒需逐个环处理。
- **Atserckcn**：通过画图验证环选策略，强调贪心的正确性。

---

### 可视化与算法演示
**复古像素动画方案**：
1. **Canvas绘制**：节点为8位像素方块，边为箭头，颜色区分状态。
2. **BFS过程**：队列节点黄色闪烁，处理时变绿（选）或红（不选）。
3. **环遍历**：高亮环路径，动态显示环长统计。
4. **音效设计**：
   - 节点选中：短促“哔”声。
   - 环处理完成：8位胜利音效。
   - 背景音乐：循环芯片音乐。

**交互控制**：
- 步进执行：空格键单步调试。
- 速度调节：滑动条控制动画速度。
- 自动模式：AI自动运行，展示完整搜索过程。

---

### 核心代码实现（贪心+BFS）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
int n, to[N], in[N], ans;
bool vis[N], chosen[N];

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &to[i]);
        in[to[i]]++;
    }
    queue<int> q;
    for (int i = 1; i <= n; ++i)
        if (!in[i]) q.push(i);
    
    while (!q.empty()) {
        int u = q.front(); q.pop();
        vis[u] = true;
        if (!chosen[u] && !chosen[to[u]]) {
            chosen[to[u]] = true;
            ans++;
            q.push(to[u]);
        }
        if (--in[to[u]] == 0)
            q.push(to[u]);
    }
    
    for (int i = 1; i <= n; ++i) {
        if (!vis[i]) {
            int cnt = 0, j = i;
            while (!vis[j]) {
                cnt++;
                vis[j] = true;
                j = to[j];
            }
            ans += cnt / 2;
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

---
处理用时：151.82秒
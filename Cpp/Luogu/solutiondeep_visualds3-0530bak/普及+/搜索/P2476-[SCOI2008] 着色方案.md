# 题目信息

# [SCOI2008] 着色方案

## 题目描述

有 $n$ 个木块排成一行，从左到右依次编号为 $1$ 至 $n$。

你有 $k$ 种颜色的油漆，第 $i$ 种颜色的油漆足够涂 $c_i$ 个木块。

所有油漆刚好足够涂满所有木块，即 $\sum_{i=1}^kc_i=n$。

由于相邻两个木块涂相同色显得很难看，所以你希望统计任意两个相邻木块颜色不同的着色方案。

由于答案可能很大，请输出对 $10^9+7$ 取模的结果。

## 说明/提示

- 对于 $50\%$ 的数据，$1 \leq k \leq 5$，$1 \leq c_i \leq 3$；
- 对于 $100\%$ 的数据，$1 \leq k \leq 15$，$1 \leq c_i \leq 5$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
10```

## 样例 #2

### 输入

```
5
2 2 2 2 2```

### 输出

```
39480```

## 样例 #3

### 输入

```
10
1 1 2 2 3 3 4 4 5 5
```

### 输出

```
85937576```

# AI分析结果



# [SCOI2008] 着色方案 题解分析

## 唯一算法分类
**动态规划（多维状态设计+记忆化搜索）**

---

## 题解思路与难点对比

### 核心思路
所有题解均采用**动态规划**，核心在于将颜色按剩余可用次数分类，通过状态压缩减少维度。主要分为两种设计模式：

1. **五维状态+last颜色**  
   状态 `dp[a][b][c][d][e][last]` 表示剩余次数为1/2/3/4/5的颜色数量分别为a/b/c/d/e，且最后一个颜色剩余次数为last。  
   **转移**：枚举下一个颜色类型，扣除与last冲突的情况（如last=2表示上次用剩余2次的颜色，此时剩余1次的颜色数量需减1）

2. **分组插入组合数学**  
   状态 `f[i][j]` 表示前i种颜色涂完sum[i]个块，有j对相邻同色。  
   **转移**：将新颜色分成a组，其中b组插入到同色间隙，剩余插入空位。需预处理组合数计算分组的可能性。

---

### 解决难点
1. **状态爆炸**：通过将相同剩余次数的颜色视为等价类，将状态维度从15维压缩到5维。
2. **相邻颜色限制**：通过记录last颜色剩余次数，或计算插入时的间隙位置，避免相邻同色。
3. **组合数优化**：预处理组合数避免重复计算，如 `C(n-1, a-1)` 表示将c_i个颜色分成a组的方案数。

---

## 题解评分（≥4星）

### 1. Bartholomew（★★★★★）
- **亮点**：直观的五维状态设计，记忆化搜索实现简洁，代码可读性极佳。
- **代码片段**：
  ```cpp
  ll DFS(int a,int b,int c,int d,int e,int last) {
    if (a+b+c+d+e == 0) return 1;
    if (~dp[a][b][c][d][e][last]) return dp[...];
    ll res = 0;
    if (a) res += (a - (last==2)) * DFS(a-1,b,c,d,e,1);
    // ...类似处理其他维度
    return dp[...] = res % MOD;
  }
  ```

### 2. 逃离地球（★★★★☆）
- **亮点**：全面解析4种算法，尤其组合数学方法时间复杂度最优（O(n^4)）。
- **关键公式**：
  ```
  f[i+1][j-b+c_i+1-a] += f[i][j] * C(c_i+1-1, a-1) * C(j, b) * C(sum[i]+1-j, a-b)
  ```

### 3. Log_x（★★★★☆）
- **亮点**：详细注释状态转移方程，突出减去last冲突的逻辑。

---

## 最优思路提炼
**关键技巧**：  
- **等价类压缩**：将相同剩余次数的颜色视为同一类，减少状态维度。  
- **last颜色剪枝**：通过记录最后使用的颜色类型，避免相邻重复。  
- **记忆化搜索**：直接递归实现状态转移，避免手动拓扑排序。

**思维突破点**：  
当颜色本身不重要，**剩余次数相同的颜色具有等价性**，这是状态压缩的核心。

---

## 同类型题推荐
1. **P1436 棋盘分割**（多维DP状态设计）
2. **P1057 传球游戏**（环形相邻限制）
3. **P2473 奖励关**（状态压缩+期望DP）

---

## 可视化设计思路
**状态转移图**（Web实现示例）：
```javascript
// 伪代码：绘制五维状态转移
const canvas = document.getElementById('dp-canvas');
ctx.fillStyle = '#8BEC87'; // 绿色表示已访问
ctx.fillRect(a*20, b*20, 15, 15); // 每个状态对应一个像素点

// 动画：显示DFS递归过程
function animateState(a, b, c, d, e, last) {
  highlightCurrentState(a, b, c, d, e);
  setTimeout(() => {
    // 递归子状态...
  }, 500);
}
```

**复古像素风格**：  
- **调色板**：16色FC风格（绿/蓝/红表示不同剩余次数）  
- **音效**：8-bit音效在状态转移时触发不同音高  
- **自动演示**：按剩余次数从高到低自动遍历状态空间

---

## 核心代码实现
Bartholomew 记忆化搜索完整代码：
```cpp
#include <cstring>
#define ll long long
const int MOD=1e9+7;
ll dp[16][16][16][16][16][6];

ll dfs(int a,int b,int c,int d,int e,int last){
    if(a+b+c+d+e==0) return 1;
    if(~dp[a][b][c][d][e][last]) return dp[a][b][c][d][e][last];
    ll res=0;
    if(a) res+=(a-(last==2))*dfs(a-1,b,c,d,e,1);
    if(b) res+=(b-(last==3))*dfs(a+1,b-1,c,d,e,2);
    if(c) res+=(c-(last==4))*dfs(a,b+1,c-1,d,e,3);
    if(d) res+=(d-(last==5))*dfs(a,b,c+1,d-1,e,4); 
    if(e) res+=e*dfs(a,b,c,d+1,e-1,5);
    return dp[a][b][c][d][e][last]=res%MOD;
}

int main(){
    memset(dp,-1,sizeof(dp));
    int k,c[6]={0}; 
    scanf("%d",&k);
    while(k--){ int x; scanf("%d",&x); c[x]++; }
    printf("%lld",dfs(c[1],c[2],c[3],c[4],c[5],0));
}
```

---
处理用时：75.10秒
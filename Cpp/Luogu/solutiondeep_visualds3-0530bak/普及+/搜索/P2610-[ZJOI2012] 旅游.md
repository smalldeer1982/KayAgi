# 题目信息

# [ZJOI2012] 旅游

## 题目描述

到了难得的暑假，为了庆祝小白在数学考试中取得的优异成绩，小蓝决定带小白出去旅游~~

经过一番抉择，两人决定将 T 国作为他们的目的地。T 国的国土可以用一个凸 $n$ 边形来表示，$n$ 个顶点表示 $n$ 个入境/出境口。T 国包含 $n-2$ 个城市，每个城市都是顶点均为 $n$ 边形顶点的三角形（换而言之，**城市组成了关于 T 国的一个三角剖分**）。**两人的旅游路线可以看做是连接 $n$ 个顶点中不相邻两点的线段**。

![](https://cdn.luogu.com.cn/upload/pic/1409.png) 

为了能够买到最好的纪念品，小白希望旅游路线上经过的城市尽量多。作为小蓝的好友，你能帮帮小蓝吗？

## 说明/提示

对于 $20\%$ 的数据，$n\le 2000$。

对于 $100\%$ 的数据，$4\le n \le 200000$。

## 样例 #1

### 输入

```
6

1 2 4

2 3 4

1 4 5

1 5 6```

### 输出

```
4```

# AI分析结果



### 唯一算法分类：DFS

---

### 题解思路、算法要点与解决难点

#### 核心思路
将每个三角形视为图中的节点，相邻三角形（共享一条边）连边形成树结构，求树的直径即为答案。  
**关键步骤**：  
1. **建图**：用 `map<pair<int,int>, int>` 记录每条边对应的三角形编号。处理新三角形时，若其边已存在，则建立邻接关系。  
2. **树的直径**：通过两次 DFS/BFS 找到最长路径。第一次找到最远节点，第二次从该节点出发确定最大深度。

#### 搜索算法要点
- **DFS实现**：递归遍历所有邻接节点，记录最大深度。  
- **BFS实现**：层次遍历，通过队列维护待访问节点，记录层数。  
- **数据结构**：邻接表存图，`visited` 数组避免重复访问。  

#### 解决难点
- **高效建图**：避免 O(n²) 时间复杂度。通过排序边顶点并使用 `map` 快速查询，仅 O(n) 时间建立邻接关系。  
- **树的直径证明**：通过几何性质证明图是树结构，且最长路径对应线段最大交点数。

---

### 题解评分 (≥4星)

1. **Dr_Gears（★★★★☆）**  
   - **亮点**：思路清晰，代码简洁，两次 DFS 求直径，使用 `map` 高效建图。  
   - **代码可读性**：变量命名规范，结构明确。  
   - **优化**：排序边顶点避免重复判断，复杂度 O(n log n)。

2. **Equfix（★★★★☆）**  
   - **亮点**：两次 BFS 求直径，队列实现层次遍历，适合大数据量。  
   - **代码结构**：邻接表与 `map` 结合，处理边时自动排序。  

3. **Daniel_7216（★★★★☆）**  
   - **亮点**：递归 DFS 实现，代码简洁，注释详细。  
   - **优化**：通过 `pair` 排序保证边唯一性，避免哈希冲突。

---

### 最优思路与技巧提炼

1. **树的直径转换**：将几何问题转化为图论问题，极大简化求解难度。  
2. **高效建图**：使用 `map` 或 `unordered_map` 存储边与三角形的映射，保证 O(n) 建图。  
3. **两次搜索法**：无论 DFS 或 BFS，两次遍历即可高效求解最长路径。  
4. **边排序去重**：处理边时统一排序顶点，避免方向性导致的重复问题。

---

### 同类型题与算法套路

- **类似问题**：树的最长路径、网络延迟时间、迷宫最短路径。  
- **通用解法**：  
  - **树的直径**：两次搜索法。  
  - **邻接表建图**：利用哈希结构处理动态边关系。  

---

### 推荐题目
1. **P1099 [NOIP2007 提高组] 树网的核**（树的直径应用）  
2. **P4408 [NOI2003] 逃学的小孩**（最长路径问题）  
3. **P5536 [XR-3] 核心城市**（树的中心与直径综合）

---

### 个人心得摘录

- **Dr_Gears**：  
  > “一遍A无调试”——合理排序边顶点减少分支判断，极大提升代码鲁棒性。  
- **Equfix**：  
  > “注意边的存法，不能一会 (5,3) 一会 (3,5)”——统一排序保证逻辑正确性。  
- **Victorique**：  
  > “SPFA 必 TLE，开 O2 才过”——优先选择线性复杂度的搜索算法。

---

### 可视化与算法演示

#### 动画设计
- **节点与边绘制**：Canvas 绘制树结构，节点为像素方块，边为彩色线条。  
- **搜索过程**：  
  - **DFS**：递归路径高亮，当前节点闪烁，回溯时颜色渐变。  
  - **BFS**：队列动态显示，层次扩散动画，不同层级颜色区分。  
- **交互功能**：  
  - **速度调节**：滑块控制搜索速度。  
  - **模式切换**：DFS/BFS 对比演示。  

#### 复古像素风格
- **调色板**：16 色 FC 风格，节点用红/绿/蓝方块，边为黄色像素线。  
- **音效**：  
  - **访问节点**：8-bit “哔”声。  
  - **找到直径**：胜利音效。  

#### 代码片段（Canvas 绘制）
```javascript
function drawNode(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x * 30 + 50, y * 30 + 50, 20, 20);
}

function dfs(node, depth) {
  visited[node] = true;
  drawNode(node.x, node.y, '#FF0000'); // 当前节点红色
  setTimeout(() => {
    for (let neighbor of adj[node]) {
      if (!visited[neighbor]) {
        drawEdge(node, neighbor, '#00FF00'); // 边绿色
        dfs(neighbor, depth + 1);
      }
    }
  }, 500);
}
```

---

### 总结
通过将几何问题转化为树的最长路径问题，结合高效建图与搜索算法，本题的难点得以巧妙解决。可视化设计通过复古像素风格与交互式动画，直观展示算法核心步骤，帮助理解 DFS/BFS 的遍历差异及树的直径求解过程。

---
处理用时：147.21秒
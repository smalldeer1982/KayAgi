# 题目信息

# [USACO15DEC] Switching on the Lights S

## 题目背景

来源：usaco-2015-dec

Farm John 最近新建了一批巨大的牛棚。这些牛棚构成了一个 $N \times N$ 的矩形网络 $(1 < N < 100)$。

然而 Bessie 十分怕黑，他想计算可以把多少个牛棚的灯打开。

## 题目描述

有 $N \times N$ 个房间，组成了一张 $N \times N$ 的网格图，Bessie 一开始位于左上角 $(1,1)$，并且只能上下左右行走。


一开始，只有 $(1,1)$ 这个房间的灯是亮着的，Bessie 只能在亮着灯的房间里活动。


有另外 $M$ 条信息，每条信息包含四个数 $a,b,c,d$，表示房间 $(a,b)$ 里有房间 $(c,d)$ 的灯的开关。


请计算出最多有多少个房间的灯可以被打开。

## 说明/提示

Bessie 可以使用 $(1,1)$ 的开关打开 $(1,2),(1,3)$ 的灯，然后走到 $(1,3)$ 并打开 $(2,1)$ 的灯，走到 $(2,1)$ 并打开 $(2,2)$ 的灯。$(2,3)$ 的开关无法到达。因此可以点亮 $5$ 个房间。

## 样例 #1

### 输入

```
3 6
1 1 1 2
2 1 2 2
1 1 1 3
2 3 3 1
1 3 1 2
1 3 2 1
```

### 输出

```
5```

# AI分析结果



【算法分类】  
BFS  

---

### **题解思路与解决难点**  
1. **核心逻辑**：  
   - **搜索初始化**：起始点（1,1）已亮灯，加入队列。  
   - **动态扩展**：每当处理队列中的节点时，打开该节点的所有关联灯，并检查新亮的灯是否可达（周围有已访问节点），若可达则加入队列。  
   - **多轮检查**：某些题解（如BoAn）采用多次DFS/BFS循环，确保所有可能的路径被覆盖。  

2. **关键数据结构**：  
   - **邻接表/二维vector**：存储每个房间的开关信息（如 `vector<node> a[105][105]`）。  
   - **标记数组**：`light`记录灯是否亮，`vis`或`canv`记录是否已访问。  

3. **难点突破**：  
   - **新灯的可达性判断**：打开灯后立即检查其四周是否存在已访问节点，若有则说明当前可到达，加入队列。  
   - **避免重复遍历**：通过标记数组确保每个节点仅处理一次，部分题解通过多次循环解决漏判问题。  

---

### **题解评分 (≥4星)**  
1. **vani_prcups（4.5星）**  
   - **亮点**：使用二维邻接表高效存储开关，DFS中动态检查新灯周围的可达性。  
   - **代码简洁性**：递归逻辑清晰，但DFS可能因数据规模导致栈溢出风险。  

2. **JMercury（4.5星）**  
   - **亮点**：类似SPFA的队列处理，及时将新亮灯且可达的房间加入队列。  
   - **优化**：利用队列动态扩展，无需多轮循环，时间复杂度更优。  

3. **WCG2025（4星）**  
   - **亮点**：降维处理（二维转一维），哈希检查新灯的可达性。  
   - **可读性**：代码稍复杂，但核心逻辑清晰，适用于大规模数据。  

---

### **最优思路提炼**  
1. **BFS队列动态扩展**：  
   - 处理队列节点时，打开所有关联灯，并立即检查新亮的灯是否可达（通过周围已访问节点）。  
   - 若可达则加入队列，确保后续路径扩展。  

2. **邻接表存储开关**：  
   - 使用二维邻接表或链式前向星高效存储每个房间的开关信息，避免暴力遍历。  

3. **可达性标记**：  
   - 使用 `vis` 和 `light` 数组分别标记已访问节点和已亮灯节点，确保逻辑正确性。  

---

### **同类型题与算法套路**  
1. **迷宫动态扩展**：如[P1141 迷宫](https://www.luogu.com.cn/problem/P1141)，需处理多次查询和连通区域。  
2. **最短路径变种**：如[P2296 寻找道路](https://www.luogu.com.cn/problem/P2296)，需结合反向图预处理。  
3. **状态空间搜索**：如[P1120 小木棍](https://www.luogu.com.cn/problem/P1120)，DFS剪枝优化。  

---

### **可视化与算法演示**  
**动画方案设计**：  
1. **网格绘制**：Canvas绘制N×N网格，节点状态用颜色区分：  
   - 灰色：未亮灯  
   - 黄色：已亮灯未访问  
   - 绿色：已访问  
   - 红色：当前处理节点  

2. **队列操作**：  
   - **入队**：节点边框闪烁后变为绿色，右侧显示队列内容。  
   - **出队**：节点变为红色，处理其关联灯（点亮周围节点）。  

3. **动态扩展**：  
   - 新亮灯节点检查四周是否存在绿色节点，若有则触发“可达动画”（粒子效果），并加入队列。  

**复古像素风格**：  
- **8位音效**：入队（“滴”声），亮灯（“叮”声），找到解（胜利音效）。  
- **自动演示**：按BFS顺序自动播放，支持暂停/步进，速度调节滑块。  

---

### **代码片段（JMercury解法核心）**  
```cpp
void spfa() {
    queue<P> q; 
    q.push({1,1}); 
    vis[1][1] = MAP[1][1] = true; 
    ans = 1;
    while (!q.empty()) {
        P u = q.front(); q.pop();
        // 处理相邻节点
        for (int i=0; i<4; i++) {
            int nx = u.x + dx[i], ny = u.y + dy[i];
            if (nx<1 || ny<1 || nx>n || ny>n || vis[nx][ny]) continue;
            if (MAP[nx][ny]) { 
                vis[nx][ny] = true; 
                q.push({nx, ny});
            }
        }
        // 处理当前节点的开关
        for (auto v : Lamp[u.x][u.y]) {
            if (MAP[v.x][v.y]) continue;
            MAP[v.x][v.y] = true; ans++;
            // 检查新亮灯节点是否可达
            for (int i=0; i<4; i++) {
                int nx = v.x + dx[i], ny = v.y + dy[i];
                if (vis[nx][ny]) { 
                    q.push(v); 
                    vis[v.x][v.y] = true; 
                    break; 
                }
            }
        }
    }
}
```

---

**推荐题目**  
1. [P1141 迷宫](https://www.luogu.com.cn/problem/P1141)  
2. [P2296 寻找道路](https://www.luogu.com.cn/problem/P2296)  
3. [P1120 小木棍](https://www.luogu.com.cn/problem/P1120)

---
处理用时：62.06秒
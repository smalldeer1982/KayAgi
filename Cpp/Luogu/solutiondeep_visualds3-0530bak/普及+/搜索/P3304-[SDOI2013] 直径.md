# 题目信息

# [SDOI2013] 直径

## 题目描述

小 Q 最近学习了一些图论知识。根据课本，有如下定义。树：无回路且连通的无向图，每条边都有正整数的权值来表示其长度。如果一棵树有 $N$ 个节点，可以证明其有且仅有 $N-1$ 条边。

路径：一棵树上，任意两个节点之间最多有一条简单路径。我们用 $\text{dis}(a,b)$ 表示点 $a$ 和点 $b$ 的路径上各边长度之和。称 $\text{dis}(a,b)$ 为 $a,b$ 两个节点间的距离。

直径：一棵树上，最长的路径为树的直径。树的直径可能不是唯一的。

现在小 Q 想知道，对于给定的一棵树，其直径的长度是多少，以及有多少条边满足所有的直径都经过该边。


## 说明/提示

【样例说明】 

直径共有两条，$3$ 到 $2$ 的路径和 $3$ 到 $6$ 的路径。这两条直径都经过边 $(3,1)$ 和边$(1, 4)$。

对于 $100\%$ 的测试数据：$2\le N\le 200000$，所有点的编号都在 $1\sim N$ 的范围内，边的权值 $\le10^9$。


## 样例 #1

### 输入

```
6
3 1 1000
1 4 10
4 2 100
4 5 50
4 6 100```

### 输出

```
1110 
2```

# AI分析结果



**算法分类**：DFS

**综合分析与结论**  
本题的核心在于确定所有直径的公共边。通过两次DFS找到任意一条直径，并分析其上的节点分支情况，最终确定必经边的范围。关键难点在于高效验证边的必经性，避免遍历所有可能的直径。

**关键步骤**：
1. **寻找直径**：通过两次DFS确定直径的两端（s, t）。
2. **标记直径路径**：记录路径上的节点，并标记。
3. **计算分支长度**：对每个直径节点，DFS计算其非直径分支的最大深度。
4. **确定边界节点**：从左右端点遍历，找到首个分支长度等于该侧剩余长度的节点，边界间的边即为必经边。

**题解清单 (≥4星)**  
1. **破壁人 (5星)**  
   - 思路清晰，两次DFS确定直径后，通过左右遍历快速定位必经边范围。  
   - 线性时间复杂度，适合大数据规模。  
   - 代码可读性较强，易于实现。

2. **lx_zjk (4星)**  
   - 利用直径中点性质，简化必经边判断。  
   - 代码实现简洁，但需处理中点位于边上的情况，细节较多。

3. **ljc20020730 (4星)**  
   - 类似破壁人思路，但通过树形DP优化分支长度计算。  
   - 代码结构清晰，但DFS和BFS混合使用可能增加理解难度。

**核心代码实现**  
```cpp
// 破壁人题解核心代码
void dfs1(int o, long long p, int q) {
    if (p > op) { op = p; u = o; }
    for (int i = 0; i < a[o].size(); i++)
        if (!vv[a[o][i]] && a[o][i] != q) {
            vv[a[o][i]] = true;
            dfs1(a[o][i], p + b[o][i], o);
        }
}

void dfs2(int o, long long p, int q) {
    last[o] = q;
    dis[o] = p;
    if (p > op) { op = p; v = o; }
    for (int i = 0; i < a[o].size(); i++)
        if (!vv[a[o][i]] && a[o][i] != q) {
            vv[a[o][i]] = true;
            dfs2(a[o][i], p + b[o][i], o);
        }
}

// 确定必经边范围
int i;
for (i = j; i != 0; i = next[i])
    if (dis[v] - dis[i] == mmm[i]) break;
for (; i != 0; i = last[i]) {
    if (dis[i] == mmm[i]) break;
    ans++;
}
```

**可视化设计**  
1. **动画流程**  
   - **步骤1**：渲染树结构，高亮初始直径路径（s→t）。  
   - **步骤2**：逐个展开直径节点，DFS其非直径分支，动态显示最长分支长度。  
   - **步骤3**：从左端点s向右滑动，当检测到分支长度等于右侧剩余距离时，停止并标记左边界j。  
   - **步骤4**：从右端点t向左滑动，类似标记右边界k，最终高亮j→k间的边。  

2. **复古像素风格**  
   - **颜色方案**：直径节点用蓝色，分支节点用绿色，必经边用红色闪烁。  
   - **音效**：访问节点时播放“滴”声，确定边界时播放“叮”声，必经边显示时播放胜利音效。  
   - **Canvas交互**：支持暂停/继续，拖动进度条观察边界确定过程。

**相似题目推荐**  
1. P2491 [SDOI2011] 消防（树的直径变形）  
2. P1099 树网的核（直径上的最优路径）  
3. P4408 逃学的小孩（利用直径性质的最值问题）  

**个人心得**  
- **调试教训**：计算分支长度时需严格排除直径上的其他节点，否则会误判分支深度。  
- **优化技巧**：预处理直径路径的节点标记，避免重复判断是否在路径上。

---
处理用时：84.52秒
# 题目信息

# 逃离僵尸岛

## 题目描述

小 a 住的国家被僵尸侵略了！小 a 打算逃离到该国唯一的国际空港逃出这个国家。


该国有 $N$ 个城市，城市之间有道路相连。一共有 $M$ 条双向道路。保证没有自环和重边。


其中 $K$ 个城市已经被僵尸控制了，如果贸然闯入就会被感染 TAT...所以不能进入。由其中任意城市经过不超过 $S$ 条道路就可以到达的别的城市，就是危险城市。换句话说只要某个城市到任意被僵尸控制的城市距离不超过 $S$，就是危险的。

小 a 住在 $1$ 号城市，国际空港在 $N$ 号城市，这两座城市没有被侵略。小a走每一段道路（从一个城市直接到达另外一个城市）得花一整个白天，所以晚上要住旅店。安全的的城市旅馆比较便宜要 $P$ 元，而被危险的城市，旅馆要进行安保措施，所以会变贵，为 $Q$ 元。所有危险的城市的住宿价格一样，安全的城市也是。在 $1$ 号城市和 $N$ 城市，不需要住店。


小 a 比较抠门，所以他希望知道从 $1$ 号城市到 $N$ 号城市所需要的最小花费。

输入数据保证存在路径，可以成功逃离。输入数据保证他可以逃离成功。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/2681.png) 

对于 $20\%$ 数据，$N\le 50$。

对于 $100\%$ 数据，$2\le N\le 10^5$，$1\le M\le 2\times 10^5$，$0\le K\le N - 2$，$0\le S\le 10^5$，$1\le P< Q\le 10^5$。


## 样例 #1

### 输入

```
13 21 1 1
1000 6000
7
1 2
3 7
2 4
5 8
8 9
2 5
3 4
4 7
9 10
10 11
5 9
7 12
3 6
4 5
1 3
11 12
6 7
8 11
6 13
7 8
12 13```

### 输出

```
11000```

# AI分析结果



### 唯一算法分类：**BFS**

---

### 综合分析与结论
**核心思路**：  
1. **多源 BFS**：从所有被僵尸控制的城市出发，计算每个城市到最近感染源的最短距离，标记危险城市  
2. **点权转化为边权**：将每个城市住宿费作为点权，转化为相邻边的权值（如边权 = 到达城市的点权）  
3. **优先队列优化**：使用 Dijkstra 或 SPFA 求带权最短路，优先选择低费用路径  

**关键难点**：  
- **多源 BFS 的高效实现**：需同时将所有感染城市入队，分层处理距离 S 的限制  
- **点权与边权的映射**：需避免重复计算费用（如起点和终点不收费）  
- **大规模数据优化**：需链式前向星存图 + 堆优化，应对 1e5 节点规模  

**可视化设计**：  
- **BFS 扩散动画**：用不同颜色区分感染源（红色）、危险城市（橙色）、安全城市（绿色），动态展示 BFS 的层序扩散过程  
- **Dijkstra 路径追踪**：高亮当前处理的节点（蓝色），显示优先队列中的待选节点（浅蓝），最终路径以黄色线条标记  
- **复古像素风格**：用 16x16 像素网格表示城市，BFS 扩散时播放 8-bit 音效，找到路径后播放胜利音效  

---

### 题解清单 (≥4星)

| 题解作者      | 评分 | 关键亮点                                                                 |
|---------------|------|--------------------------------------------------------------------------|
| **fyfy**      | ⭐⭐⭐⭐ | 虚拟节点统一感染源，分层 BFS 标记危险城市，邻接表优化清晰               |
| **浮梦若生**  | ⭐⭐⭐⭐ | BFS + 堆优化 Dijkstra，点权直接作为边权，代码可读性高                   |
| **顾z**       | ⭐⭐⭐⭐ | 明确 Safe 状态分类，双数组标记感染/危险，调试日志友好                    |

---

### 最优思路与代码实现
**核心代码片段**（fyfy 题解的关键部分）：
```cpp
// 多源 BFS 初始化
queue<int> q;
for (int i = 1; i <= k; i++) {
    q.push(zombie[i]);
    dis[zombie[i]] = 0;
}

// BFS 扩散标记危险城市
while (!q.empty()) {
    int u = q.front(); q.pop();
    for (int v : adj[u]) {
        if (dis[v] > dis[u] + 1) {
            dis[v] = dis[u] + 1;
            if (dis[v] <= S) q.push(v);
        }
    }
}

// Dijkstra 求最短路
priority_queue<PII, vector<PII>, greater<PII>> pq;
pq.push({0, 1});
while (!pq.empty()) {
    auto [cost, u] = pq.top(); pq.pop();
    if (u == n) return cost;
    for (int v : adj[u]) {
        int w = (v == n ? 0 : (danger[v] ? Q : P));
        if (cost + w < dist[v]) {
            dist[v] = cost + w;
            pq.push({dist[v], v});
        }
    }
}
```

---

### 同类型题目与拓展
1. **多源 BFS 应用**  
   - 洛谷 P1144 - 最短路计数（多起点 BFS）  
   - 洛谷 P1339 - 热浪（单源最短路模板）  

2. **点权转边权技巧**  
   - 洛谷 P4568 - 飞行路线（分层图边权转换）  
   - 洛谷 P1265 - 公路修建（最小生成树点权处理）  

---

### 可视化与游戏化设计
**像素动画实现**：  
1. **Canvas 网格绘制**：每个城市为 16x16 像素方块，感染城市显示💀图标，危险城市显示🔥  
2. **BFS 扩散特效**：用 `requestAnimationFrame` 逐帧渲染扩散波纹，播放 "blip" 音效  
3. **Dijkstra 路径追踪**：用黄色线段动态连接已访问节点，找到路径时播放 8-bit 胜利音乐  

**交互功能**：  
- **速度调节滑块**：控制 BFS/Dijkstra 的执行速度（50ms~2000ms/步）  
- **AI 自动演示**：一键自动完成搜索，展示完整路径  
- **关卡模式**：设置不同 S 值和城市布局，通关解锁新难度  

```javascript
// 示例：BFS 扩散动画核心逻辑
function animateBFS() {
    const ctx = canvas.getContext('2d');
    let queue = [...infectedCities];
    let frame = 0;
    
    function draw() {
        ctx.clearRect(0, 0, width, height);
        queue.forEach((city, idx) => {
            drawCity(city, 'red');
            if (frame % 10 === 0) playSound('blip.wav');
        });
        
        if (frame < S) {
            const nextLevel = [];
            queue.forEach(u => {
                adj[u].forEach(v => {
                    if (!visited[v]) {
                        visited[v] = true;
                        nextLevel.push(v);
                    }
                });
            });
            queue = nextLevel;
            frame++;
            requestAnimationFrame(draw);
        }
    }
    requestAnimationFrame(draw);
}
```

---

**总结**：通过多源 BFS 预处理危险区域，再结合优先队列优化最短路，是本题的核心解法。可视化设计需突出层序扩散与路径选择过程，复古像素风格能有效提升学习趣味性。

---
处理用时：75.22秒
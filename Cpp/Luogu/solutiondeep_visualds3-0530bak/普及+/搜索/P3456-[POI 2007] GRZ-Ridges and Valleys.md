# 题目信息

# [POI 2007] GRZ-Ridges and Valleys

## 题目描述

**译自 POI 2007 Stage 2. Day 0「[Ridges and Valleys](https://szkopul.edu.pl/problemset/problem/rd6H05Dm8ME79sO3U9_f_ga_/site/?key=statement)」**

给定一个 $n \times n$ 的网格状地图，每个方格 $(i,j)$ 有一个高度 $w_{ij}$。如果两个方格有公共顶点，则它们是相邻的。

定义山峰和山谷如下：
* 均由地图上的一个连通块组成；
* 所有方格高度都相同；
* 周围的方格（即不属于山峰或山谷但与山峰或山谷相邻的格子）高度均大于山谷的高度，或小于山峰的高度。

求地图内山峰和山谷的数量。特别地，如果整个地图方格的高度均相同，则整个地图既是一个山谷，也是一个山峰。

## 样例 #1

### 输入

```
5
8 8 8 7 7
7 7 8 8 7
7 7 7 7 7
7 8 8 7 8
7 8 8 8 8```

### 输出

```
2 1```

## 样例 #2

### 输入

```
5
5 7 8 3 1
5 5 7 6 6
6 6 6 2 8
5 7 2 5 8
7 1 0 1 7```

### 输出

```
3 3```

# AI分析结果



# 算法分类选择
**BFS**

---

# 题解思路与核心难点

## 思路分析
题目要求统计地图中的山峰和山谷数量。关键点在于判断每个连通块周围是否全高于（山谷）或全低于（山峰）该块高度。所有题解均采用搜索算法（BFS/DFS）遍历连通块，并在扩展时动态判断周围点高度关系。

### 算法要点
1. **连通块遍历**：使用 BFS/DFS 遍历高度相同的区域。
2. **周围点检查**：对每个遍历到的节点，检查其八个方向的相邻点：
   - 若相邻点高度相同，加入队列继续扩展。
   - 若高度不同，更新状态（是否有更高/更低的点）。
3. **状态维护**：通过两个布尔变量 `ifhigh`（是否无更高点）和 `iflow`（是否无更低点）标记当前连通块是否为山峰/山谷。
4. **特判全图同高**：若所有格子高度相同，则同时计入山峰和山谷。

### 解决难点
- **方向处理**：需检查八个方向而非四个，易出错。
- **边界条件**：如全图同高需特判。
- **矛盾判断**：若某连通块周围既有更高又有更低点，则不计入统计。

---

# 题解评分（≥4星）

1. **李尧（5星）**  
   - **亮点**：BFS实现，起点即检查周围点，发现矛盾后立即剪枝。代码逻辑清晰，注释详细。
   - **优化**：在发现矛盾后停止无效检查，提升效率。

2. **FCBM71（5星）**  
   - **亮点**：维护 `ifhigh` 和 `iflow` 变量，逻辑简洁高效。无需记录首个周围点高度，直接判断矛盾。
   - **代码**：通过布尔变量动态更新，最终统计结果。

3. **sounds_666（4星）**  
   - **亮点**：分两次BFS分别统计山峰和山谷，避免状态混淆。代码可读性高，注释详细。

---

# 最优思路提炼
**核心技巧**：在搜索连通块时，维护两个布尔变量 `ifhigh` 和 `iflow`：
- `ifhigh=1` 表示周围无更高点（可能是山峰）。
- `iflow=1` 表示周围无更低点（可能是山谷）。
遍历所有相邻点，若发现更高点则 `ifhigh=0`，若发现更低点则 `iflow=0`。最终：
- `ifhigh=1` → 山峰。
- `iflow=1` → 山谷。

**实现片段**（FCBM71思路）：
```cpp
bool ifhigh = 1, iflow = 1;
while (!q.empty()) {
    int x = q.front().x, y = q.front().y;
    q.pop();
    for (8个方向) {
        int nx = x + dx[i], ny = y + dy[i];
        if (越界) continue;
        if (高度相同) 加入队列;
        else {
            if (更高) ifhigh = 0;
            if (更低) iflow = 0;
        }
    }
}
if (ifhigh) ans_peak++;
if (iflow) ans_valley++;
```

---

# 同类型题与算法套路
- **网格连通块问题**：常用 BFS/DFS 遍历，如岛屿数量、洪水填充。
- **条件判断扩展**：在遍历时动态维护额外状态（如是否有特定属性）。
- **洛谷相似题**：
  1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)（BFS边界扩展）
  2. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)（连通块预处理）
  3. [P2895 [USACO08FEB]Meteor Shower S](https://www.luogu.com.cn/problem/P2895)（BFS带状态判断）

---

# 可视化与算法演示

## 动画设计
1. **节点扩展**：以网格展示地图，当前访问节点高亮为黄色，已访问节点为灰色。
2. **队列状态**：右侧显示BFS队列，动态展示节点进出过程。
3. **状态标记**：
   - 发现更高点 → 当前连通块边框变红。
   - 发现更低点 → 当前连通块边框变蓝。
   - 最终结果：山峰标记为▲，山谷标记为▼。
4. **复古风格**：采用8-bit像素风，音效提示节点访问（“哔”声）和结果判定（“叮”声）。

## 交互功能
- **步进控制**：支持暂停/继续/单步执行。
- **速度调节**：滑动条控制动画速度（50ms~2s）。
- **自动演示**：AI自动运行，展示搜索过程。

---

# 个人心得摘录
- **李尧**：WA5次因未注意八个方向，强调边界检查。
- **lhhh**：DFS爆栈改用BFS，提醒递归深度问题。
- **御坂10027号**：误将极值点计数，后修正为周围关系判断。

---

# 代码片段（FCBM71核心逻辑）
```cpp
void bfs(int x, int y) {
    bool ifhigh = 1, iflow = 1;
    queue<Node> q;
    q.push({x, y});
    vis[x][y] = 1;
    while (!q.empty()) {
        auto [x, y] = q.front(); q.pop();
        for (int i = 0; i < 8; ++i) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx < 1 || nx > n || ny < 1 || ny > n) continue;
            if (a[nx][ny] == a[x][y] && !vis[nx][ny]) {
                vis[nx][ny] = 1;
                q.push({nx, ny});
            } else {
                if (a[nx][ny] > a[x][y]) ifhigh = 0;
                if (a[nx][ny] < a[x][y]) iflow = 0;
            }
        }
    }
    if (ifhigh) ridge++;
    if (iflow) valley++;
}
```

---
处理用时：92.89秒
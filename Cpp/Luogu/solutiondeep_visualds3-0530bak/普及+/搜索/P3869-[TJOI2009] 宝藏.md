# 题目信息

# [TJOI2009] 宝藏

## 题目描述

为了寻找传说中的宝藏，小明走进了一个迷宫，我们用一个 $r$ 行 $c$ 列的矩阵来描述这个迷宫，矩阵的每个位置表示一个方块区域：

- 字符 `.` 表示可以通过的方格。
- 字符 `#` 表示不能通过的方格。
- 在迷宫中有 $k$ 个机关，第 $i$ 个机关工作方式为：  
  - 每当小明走上第 $r_i$ 行，$c_i$ 列的格子时，位于第 $R_i$ 行，$C_i$ 列的格子改变状态（如果这个格子此时可以通过，此后就变为不能通过；如果此时不能通过，此后可以通过。最左上角的格子是第 $1$ 行第 $1$ 列）。

现给出当前小明的位置，宝藏的位置，迷宫中每个格子的状态，以及所有机关的描述，问小明至少还要走多少步才能拿到宝藏（不能走出迷宫的边界，在开始时刻，小明和宝藏所在的位置都是可以通过的，机关不会出现在起点和终点，也不会影响这两个格子）。


## 说明/提示

### 数据范围及约定

对于全部数据，$5 \le r, c \le 30$，$0 \le k \le 10$，$1 \le r_i,R_i\le r$，$1 \le c_i,C_i \le c$。


## 样例 #1

### 输入

```
5 5
S.#..
#####
..#..
##.#.
...#T
6
1 5 4 2
1 4 3 3
5 1 3 3
1 4 4 5
1 2 1 3
1 5 2 1
```

### 输出

```
22```

# AI分析结果



### 唯一算法分类：BFS

---

### 算法要点与解决难点

#### 核心思路
所有题解均采用 **BFS + 状态压缩** 的核心框架：
1. **状态表示**：用二进制数 `k` 表示机关触发次数的奇偶性（奇数次触发会改变对应格子状态）。
2. **可行判断**：计算当前格子是否可通行时，需结合初始地图状态和所有相关机关的触发奇偶性。
3. **状态转移**：当触发机关（走到特定格子）时，通过异或操作更新状态 `k`。
4. **记忆化剪枝**：通过三维数组 `vis[x][y][k]` 避免重复访问同一状态。

#### 难点对比
- **lenlen**：直接遍历所有机关判断是否影响当前格子，代码简洁但复杂度稍高（O(k) 时间）。
- **iiiiiyang**：预处理每个格子是否为机关触发点或受控点，分类处理不同情况，逻辑更清晰但代码略长。
- **unsigned_short_int**：将机关状态与地图分离，通过 `check()` 和 `newStat()` 函数解耦逻辑，更易维护。

---

### 题解评分（≥4星）

1. **lenlen（4.5星）**
   - **亮点**：代码简洁，利用异或操作高效切换状态，适合快速理解核心逻辑。
   - **代码**：直接遍历机关列表，判断触发和影响。
   - **优化**：使用队列实现 BFS，状态压缩节省空间。

2. **iiiiiyang（4星）**
   - **亮点**：详细分类讨论触发与受控格子，注释清晰，适合理解复杂边界。
   - **代码**：预处理 `cause` 和 `so` 数组，减少运行时判断次数。

3. **unsigned_short_int（4星）**
   - **亮点**：分离状态判断与更新逻辑，模块化设计，适合扩展。
   - **代码**：`check()` 和 `newStat()` 函数解耦，便于调试。

---

### 最优思路提炼
- **状态压缩**：用 `k` 的二进制位记录每个机关的触发奇偶性，空间复杂度优化至 `O(r*c*2^k)`。
- **异或操作**：快速切换机关状态（如 `kk ^= (1<<j-1)`）。
- **记忆化剪枝**：三维 `vis` 数组避免重复状态入队，确保 BFS 时间复杂度为 `O(r*c*2^k)`。

---

### 同类型题与算法套路
- **通用套路**：迷宫类问题中，若存在动态变化的状态（如门、钥匙、陷阱），常用 **BFS + 状态压缩**。
- **相似题目**：
  - [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)：基础 BFS 模板。
  - [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：BFS 应用。
  - [P3956 棋盘](https://www.luogu.com.cn/problem/P3956)：状态变化（颜色）+ BFS。

---

### 个人心得摘录
- **iiiiiyang**：调试中发现某些格子可能同时是触发点和受控点，需特别注意处理顺序。
- **lupengheyyds**：最初尝试分层 BFS 导致 MLE，改用状态压缩后问题迎刃而解。
- **harmis_yz**：位运算优先级错误导致 WA，最终通过括号强制优先级解决。

---

### 可视化算法演示设计

#### 核心逻辑
- **网格绘制**：用 Canvas 绘制迷宫网格，`.T` 和 `#` 分别标记为绿色、红色。
- **状态展示**：当前格子高亮为黄色，队列中待访问节点显示为蓝色。
- **机关状态**：侧边栏显示二进制 `k` 的值，对应机关图标闪烁表示触发状态。

#### 复古像素风格
- **颜色方案**：8-bit 调色板（红、绿、蓝、黄、紫），格子大小为 32x32 像素。
- **音效**：
  - 访问新节点：短促“哔”声。
  - 触发机关：电子“咔嚓”声。
  - 找到终点：经典 FC 胜利音乐。
- **动画**：节点扩展时，以 0.5 秒间隔逐步渲染，支持暂停/继续。

#### 代码片段（JS 伪代码）
```javascript
function drawGrid() {
  ctx.fillStyle = "#2D2D2D"; // 背景色
  ctx.fillRect(0, 0, width, height);
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      if (grid[i][j] === "#") ctx.fillStyle = "#FF0000"; // 障碍
      else if (i === endX && j === endY) ctx.fillStyle = "#00FF00"; // 终点
      // ...其他状态绘制
    }
  }
}
```

---

### 总结
本题通过 **BFS + 状态压缩** 高效处理动态迷宫路径问题，核心在于状态表示与记忆化剪枝。可视化设计结合复古像素风格，可直观展示搜索过程与状态变化，适合教学与调试。

---
处理用时：63.26秒
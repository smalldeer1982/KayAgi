# 题目信息

# 肮脏的牧师

## 题目背景

@Yumis 出题人在这里哦~


## 题目描述

Yumis最近在玩炉石传说。

在炉石传说中脏牧有一张一费卡片（一费就是使用要消耗1点法力水晶），叫做疯狂药水，这个的效果是将一个敌方场上攻击小于等于2的随从拉到自己的战场内。

还有一张四费卡片叫做暗影狂乱，这个的效果是将一个敌方场上攻击小于等于3的随从拉到自己的战场内。

还有一张一费卡片就是缩小药水，这个的效果是将敌人全场的随从攻击力下降3点。


你PY了炉石的GM所以你有了无数张的这三种卡片，但是GM告诉你缩小药水是这个牌比较不好创建，为了为GM着想你必须在使用**最少的缩小药水**的情况下A爆对手的脸。


现在你的对手场上有n个随从，每个随从的攻击力是ki点。

你的对手有m点血量。


而你现在要做的就是将敌方的场上的随从拉过来自己的场上并攻击对手（每一个随从只能攻击一次，攻击力为你拉过来的时候随从剩余的攻击力），A爆对面的脸（将对面的血打到0点及以下）。


## 说明/提示

样例说明1：

敌方场上有3只随从，敌方有5点血量

我们把3攻随从和2攻随从拉过来花费0个缩小药水和5点耗费（一张疯狂药水一个暗影狂乱（1+4 = 5））伤害足够击杀对方。


样例说明2：

使用16个缩小药水（下面数据后面第一个括号指拉过来的时候伤害为多高 ，第二个括号表示拉过来的时候使用多少的缩小药水）

拿10（1）（3）、20（2）（6）、30（3）（9）、50（2）（16）攻的怪物总共造成8点伤害 刚好A爆！



Easy : 保证 0 < n <= 10  并且不存在用到暗影狂乱和缩小药水的情况    20%


Normal ：保证 0 < n <= 10  并且不存在用到缩小药水的情况           20%


Hard ：保证 0 < n <= 10                                                 30%


Extra：保证0 <= n <= 5000000(6个0)，最大攻击力小于30000                  30%


保证 0 < n <= 5000000     0 < ki <=30000    0<=m<=5000000 (6个0)


## 样例 #1

### 输入

```
3 5
1 2 3 
```

### 输出

```
0 5```

## 样例 #2

### 输入

```
8 8
10 20 30 40 50 60 70 80
```

### 输出

```
16 23```

## 样例 #3

### 输入

```
8 80
10 20 30 40 50 60 70 80
```

### 输出

```
Human Cannot Win Dog```

# AI分析结果



### 唯一算法分类  
其他搜索

---

### 综合分析与结论  
#### 核心思路与难点  
题目要求在最小化缩小药水的前提下，通过贪心策略选择随从攻击顺序。关键点在于：  
1. **缩小药水的使用次数**：通过模3分组（桶排序）快速确定随从的攻击力区间。  
2. **法力消耗优化**：优先用1费拉2攻随从，其次1攻，最后4费的3攻随从。  
3. **溢出伤害返还**：当总伤害超过敌方血量时，按性价比从低到高（3→1→2）返还随从。  

核心难点在于如何在保证伤害足够的前提下，通过排序和模3分组快速计算最优解。大数据下必须用桶排序（时间复杂度O(max_k)）而非快速排序（O(n logn)）。

#### 可视化设计思路  
1. **动态分组动画**：将随从攻击力按模3分组（1,2,3）动态显示，每次缩小药水后所有攻击力-3，并重新分组。  
2. **随从选择过程**：用不同颜色区分被拉取的随从类型（红色=3攻，黄色=2攻，绿色=1攻），实时更新总伤害和法力消耗。  
3. **溢出返还演示**：当总伤害溢出时，高亮3攻随从并播放“返还”动画，展示法力消耗减少的过程。  

---

### 题解清单（评分≥4星）  
1. **Yumis（5星）**  
   - **亮点**：桶排序+模3分组，时间复杂度严格线性，完美处理500万数据。  
   - **代码片段**：通过循环`i += 3`遍历模3分组，优先返还3攻随从。  
   ```cpp  
   for (int i=1; i+2<=30001; i+=3) {  
       ans += to[i]; at1 += to[i]; // 分组累加  
       if (ans >= m) break;  
   }  
   ```  

2. **AirCnt（4.5星）**  
   - **亮点**：预处理攻击力时直接计算缩小后的值，避免重复遍历。  
   - **代码片段**：通过`clac`函数统一处理缩小药水和伤害计算。  
   ```cpp  
   inline int clac(int x, const int num) {  
       x -= cnt*3;  // 直接计算缩小后的攻击力  
       if (x>3) { /* 处理缩小药水 */ }  
       return x*num;  
   }  
   ```  

3. **Guess00（4星）**  
   - **亮点**：手写桶排序优化性能，明确返还顺序（3→1→2）。  
   - **个人心得**：通过调试发现排序算法对性能的关键影响，最终改用桶排序通过。  

---

### 最优思路与技巧提炼  
1. **桶排序+模3分组**：将攻击力按模3分组，直接计算每组可造成的伤害。  
2. **伤害溢出返还策略**：按性价比顺序（3→1→2）返还随从，优先减少高费操作。  
3. **线性时间复杂度**：通过桶排序和模3跳跃遍历（`i += 3`）实现O(max_k)复杂度。  

---

### 同类型题与算法套路  
1. **任务调度优化**：类似贪心选择高性价比任务（如[P1090 合并果子](https://www.luogu.com.cn/problem/P1090)）。  
2. **资源分配问题**：在限制条件下最小化成本（如[P2949 工作调度](https://www.luogu.com.cn/problem/P2949)）。  
3. **离散化分组**：通过模运算或区间分组快速统计（如[P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)）。  

---

### 推荐相似题目  
1. **P1090 合并果子**（贪心+优先队列）  
2. **P1223 排队接水**（贪心排序）  
3. **P2949 工作调度**（时间窗口+优先级选择）  

---

### 个人心得摘录  
1. **jiangyanheng**：  
   > “这道题的最大难点在于排序。尝试了sort、stable_sort、手写基数排序，最后改用桶排才通过。”  
   **总结**：大数据场景下，常数优化和算法选择决定生死。  

2. **MTF_Lambda_04**：  
   > “两个for循环不能写在一起，试试就逝世。”  
   **总结**：返还顺序的严格性直接影响结果正确性。  

---

### 可视化与算法演示  
#### 复古像素化设计  
1. **8位风格界面**：  
   - **随从**：用16x16像素块表示，颜色区分攻击力（红=3，黄=2，绿=1）。  
   - **缩小药水**：蓝色药瓶图标，使用时播放像素溶解动画。  

2. **Canvas动画流程**：  
   - **初始状态**：敌方随从随机分布，显示原始攻击力。  
   - **缩小药水**：点击后所有攻击力-3，攻击力≤0的随从变灰（不可用）。  
   - **拉取随从**：点击随从后播放“抓取”动画，并累计伤害和法力消耗。  

3. **音效与交互**：  
   - **音效**：拉取随从时播放8位“哔”声，返还时播放“咔嚓”声。  
   - **自动演示模式**：AI自动选择最优随从，用箭头高亮当前决策路径。  

#### 核心JavaScript片段  
```javascript  
// 自动演示缩小药水分组  
function autoShrink() {  
    let currentGroup = 0;  
    const animate = () => {  
        if (currentGroup > maxAttack) return;  
        drawGroup(currentGroup);  // 绘制当前模3分组  
        currentGroup += 3;  
        requestAnimationFrame(animate);  
    };  
    animate();  
}  
```  

--- 

通过上述设计，学习者可直观理解攻击力分组、缩小药水作用顺序和法力消耗优化策略，同时通过复古风格增强趣味性。

---
处理用时：85.85秒
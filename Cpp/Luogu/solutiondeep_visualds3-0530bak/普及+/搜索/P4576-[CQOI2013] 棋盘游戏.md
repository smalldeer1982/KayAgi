# 题目信息

# [CQOI2013] 棋盘游戏

## 题目描述

一个n*n（n>=2）棋盘上有黑白棋子各一枚。游戏者A和B轮流移动棋子，A先走。

 * A的移动规则：只能移动白棋子。可以往上下左右四个方向之一移动一格。
 
 * B的移动规则：只能移动黑棋子。可以往上下左右四个方向之一移动一格或者两格。
 
和通常的“吃子”规则一样，当某游戏者把自己的棋子移动到对方棋子所在的格子时，他就赢了。

两个游戏者都很聪明，当可以获胜时会尽快获胜，只能输掉的时候会尽量拖延时间。你的任务是判断谁会赢，需要多少回合。


比如$n=2$，白棋子在$(1,1)$，黑棋子在$(2,2)$，那么虽然A有两种走法，第二个回合B总能取胜。

## 说明/提示

$n<=20$

## 样例 #1

### 输入

```
2 1 1 2 2```

### 输出

```
BLACK 2```

# AI分析结果



# [CQOI2013] 棋盘游戏 题解分析

**唯一算法分类**: DFS (对抗搜索)

---

## **题解思路与核心难点**

### **核心思路**
本题属于对抗搜索（博弈论中的极大极小算法），通过DFS+记忆化实现：
1. **状态表示**：`f[玩家][步数][白棋坐标][黑棋坐标]` 存储当前状态的最优解
2. **胜负判断**：
   - 初始曼哈顿距离≤1 → 白棋胜（一步击杀）
   - 否则黑棋必胜，需计算最小获胜步数
3. **状态转移**：
   - 白棋回合：选择所有可行移动中最大步数（拖延）
   - 黑棋回合：选择所有可行移动中最小步数（速胜）
4. **剪枝优化**：步数超过3n时返回INF，避免无限递归

### **解决难点**
- **状态爆炸**：通过记忆化存储已计算状态（6维数组）
- **移动方向处理**：黑棋可移动1/2格需穷举所有可能
- **终止条件**：坐标重合时根据当前玩家判断胜负

---

## **题解评分 (≥4星)**

1. **Tenshi (★★★★★)**
   - 亮点：清晰的对抗搜索框架，带详细注释；使用方向数组简化移动逻辑
   - 代码可读性高，状态转移逻辑明确

2. **JRhddj (★★★★☆)**
   - 优点：最早提出对抗搜索框架，状态设计简洁
   - 缺点：移动方向硬编码，可读性稍差

3. **Exiler (★★★★☆)**
   - 特色：封装坐标结构体，移动合法性检查独立函数
   - 详细注释解释步数限制的构造方法

---

## **最优思路提炼**
```cpp
// 对抗搜索核心框架
int dfs(int player, int step, ...) {
    if (终止条件) return 结果;
    if (记忆化存在) return 缓存值;

    if (player == 白棋) {
        for (所有移动方向) {
            计算新坐标;
            res = max(res, dfs(黑棋, step+1, 新坐标));
        }
    } else {
        for (所有1/2格移动方向) {
            计算新坐标;
            res = min(res, dfs(白棋, step+1, 新坐标));
        }
    }
    记忆化存储并返回res+1;
}
```

---

## **同类型题与算法套路**
- **类似问题**：博弈树中的极大极小问题（如井字棋、围棋终局计算）
- **通用解法**：状态压缩 + 记忆化对抗搜索
- **优化手段**：α-β剪枝、启发式评估函数

---

## **推荐题目**
1. P2583 黑白棋游戏（对抗搜索+状态哈希）
2. P1514 棋盘覆盖（极大极小变形）
3. P4363 九省棋王（复杂对抗博弈）

---

## **可视化设计**

### **动画方案**
1. **网格绘制**：Canvas绘制n×n棋盘，白棋用白色方块，黑棋用黑色方块
2. **移动演示**：
   - 白棋移动：绿色箭头显示可选方向
   - 黑棋移动：红色箭头显示1/2格选项
3. **递归过程**：
   - 当前节点高亮黄色
   - 已访问节点标记灰色
4. **音效触发**：
   - `move.wav`：棋子移动时播放
   - `win.wav`：找到解时播放

### **复古风格实现**
```javascript
// 像素风格初始化
const canvas = document.getElementById('board');
canvas.style.imageRendering = 'pixelated'; // 启用像素化渲染

// 8位音效配置
const audioCtx = new AudioContext();
function playBeep(freq) {
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.1);
}
```

---

## **代码实现（Tenshi版核心逻辑）**
```cpp
int dfs(bool ok, int cnt, int x1, int y1, int x2, int y2) {
    if (~f[ok][cnt][x1][y1][x2][y2]) return f[...];
    if (x1==x2 && y1==y2) return ok ? 0 : INF;

    int res;
    if (ok) { // 白棋选择最大步数
        res = -1;
        for (4方向移动) 
            res = max(res, dfs(0, cnt+1, 新坐标));
    } else { // 黑棋选择最小步数
        res = INF;
        for (8方向移动)
            res = min(res, dfs(1, cnt+1, 新坐标));
    }
    return f[...] = res + 1;
}
```

---
处理用时：65.47秒
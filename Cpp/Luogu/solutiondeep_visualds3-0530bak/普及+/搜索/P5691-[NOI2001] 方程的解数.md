# 题目信息

# [NOI2001] 方程的解数

## 题目描述

已知一个 $n$ 元高次方程：         
$$\sum\limits_{i=1}^n k_ix_i^{p_i} = 0$$
其中：$x_1, x_2, \dots ,x_n$ 是未知数，$k_1,k_2, \dots ,k_n$ 是系数，$p_1,p_2,…p_n$ 是指数。且方程中的所有数均为整数。

假设未知数 $x_i \in [1,m] \space ( i \in [1,n])$，求这个方程的整数解的个数。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le n \le 6$，$1\le m \le 150$，且
$$\sum\limits_{i=1}^n |k_im^{p_i}| < 2^{31}$$  
答案不超过 $2^{31}-1$，$p_i \in \mathbb N^*$。

## 样例 #1

### 输入

```
3
150
1 2
-1 2
1 2```

### 输出

```
178```

# AI分析结果



# 【算法分类】  
**其他搜索**（折半搜索/Meet-in-the-Middle）

---

# **核心思路与难点对比**  
### **问题核心**  
求解 $n$ 元高次方程的整数解个数，直接暴力枚举时间复杂度为 $O(m^n)$，需优化至 $O(m^{n/2})$。  

### **题解要点**  
1. **折半搜索**：  
   - 将方程拆分为前 $\lfloor n/2 \rfloor$ 项和后 $\lceil n/2 \rceil$ 项，分别搜索所有可能的值。  
   - 前一部分存储结果，后一部分查找相反数，统计匹配次数。  

2. **合并策略**：  
   - **哈希表**（nofall、Celtic）：存储前半结果，后半查找 $-sum$ 的频次，时间复杂度接近 $O(1)$，需处理哈希冲突。  
   - **排序+双指针**（LawrenceSivan）：排序后利用单调性统计相同值的乘积，线性时间复杂度。  
   - **二分查找**（xsap）：排序后对每个后半值用 `lower_bound` 和 `upper_bound` 统计匹配数，时间复杂度 $O(n \log n)$。  

3. **重复值处理**：  
   - 双指针法需统计前半相同值的个数（`x`）和后半相同值的个数（`y`），答案累加 $x \times y$。  
   - 哈希表直接存储值频次，无需额外处理。  

### **解决难点**  
- **状态拆分**：如何将方程拆分为两半，并确保两部分独立计算。  
- **高效合并**：合并策略需平衡时间与空间，哈希表适合大数据，双指针适合重复值多的情况。  

---

# **4星及以上题解推荐**  
1. **LawrenceSivan（⭐⭐⭐⭐⭐）**  
   - **亮点**：双指针法线性合并，代码清晰，处理重复值的乘法原理优雅。  
   - **代码核心**：  
     ```cpp  
     sort(a+1,a+1+cnta); sort(b+1,b+1+cntb);  
     int l=1, r=cntb;  
     for (;l<=cnta && r>=1; l++) {  
         while (a[l]+b[r]>0) r--;  
         int x=1, y=0;  
         for(int j=r; a[l]+b[j]==0 && j>0; j--) y++;  
         while(l<cnta && a[l]==a[l+1]) x++, l++;  
         ans += x*y;  
     }  
     ```  

2. **nofall（⭐⭐⭐⭐）**  
   - **亮点**：哈希表高效合并，代码简洁，手写哈希函数优化冲突。  
   - **代码核心**：  
     ```cpp  
     void dfs1(int dep, int sum) {  
         if (dep > mid) { add(hash(sum), sum); return; }  
         for (int i=1; i<=m; i++) dfs1(dep+1, sum + k[dep]*pow(i,p[dep]));  
     }  
     void dfs2(int dep, int sum) {  
         if (dep > n) { ans += query(hash(-sum)); return; }  
         for (int i=1; i<=m; i++) dfs2(dep+1, sum + k[dep]*pow(i,p[dep]));  
     }  
     ```  

3. **xsap（⭐⭐⭐⭐）**  
   - **亮点**：排序后二分查找，逻辑直观，适合不熟悉哈希的读者。  
   - **代码核心**：  
     ```cpp  
     sort(val1, val1+cnt1);  
     for (int i=1; i<=cnt2; i++)  
         ans += upper_bound(val1, val1+cnt1, -val2[i]) - lower_bound(...);  
     ```  

---

# **最优技巧提炼**  
1. **折半搜索**：将 $O(m^n)$ 优化为 $O(m^{n/2})$ 的经典分治策略。  
2. **合并策略选择**：  
   - 哈希表适合快速查找但需处理冲突。  
   - 双指针法线性高效，适合重复值多的场景。  
3. **重复值统计**：利用排序后的单调性，通过乘法原理计算组合数。  

---

# **同类型题推荐**  
1. **P4799 [CEOI2015 Day2]世界冰球锦标赛**：折半搜索求方案数。  
2. **P3067 [USACO12OPEN]Balanced Cow Subsets G**：哈希表存储子集和。  
3. **CF888E Maximum Subsequence**：模数下的最大子序列和。  

---

# **可视化与算法演示**  
### **动画设计**  
- **节点表示**：用网格表示未知数 $x_1$ 到 $x_n$ 的取值，每层代表一个变量。  
- **搜索过程**：  
  - **前半搜索**：红色高亮路径，将计算结果存入左侧数组。  
  - **后半搜索**：蓝色高亮路径，动态匹配左侧的红色值（相加为0时闪烁绿色）。  
- **合并展示**：左右两侧数组排序后，双指针向中间移动，匹配时显示连线。  

### **复古像素风格**  
- **8位音效**：匹配成功时播放“叮”声，搜索新节点时播放“滴答”声。  
- **Canvas绘制**：网格用16x16像素块，路径用不同颜色像素点标记。  

### **交互功能**  
- **步进控制**：按空格单步执行搜索，方向键调整速度。  
- **模式切换**：支持自动播放（AI模式）和手动调试。  

---

# **核心代码片段（双指针法）**  
```cpp  
void dfs(int l, int r, int sum, int *arr, int &cnt) {  
    if (l > r) { arr[++cnt] = sum; return; }  
    for (int i=1; i<=m; i++)  
        dfs(l+1, r, sum + k[l]*pow(i, p[l]), arr, cnt);  
}  

// 合并部分  
sort(a, a+cnta); sort(b, b+cntb);  
int l=1, r=cntb, ans=0;  
while (l<=cnta && r>=1) {  
    if (a[l] + b[r] == 0) {  
        int x=1, y=1;  
        while (l<cnta && a[l]==a[l+1]) x++, l++;  
        while (r>1 && b[r]==b[r-1]) y++, r--;  
        ans += x*y; l++; r--;  
    } else if (a[l] + b[r] > 0) r--;  
    else l++;  
}  
```  

---

# **总结**  
折半搜索通过拆分问题规模大幅降低复杂度，合并策略的选择直接影响性能。双指针法在有序数据下线性高效，哈希表适合快速查找，排序+二分则平衡了实现难度与效率。推荐结合具体场景选择最优策略。

---
处理用时：86.13秒
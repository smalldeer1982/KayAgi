# 题目信息

# [传智杯 #4 决赛] 生活在树上（easy version）

## 题目背景

**本题是 P8201 的简单版本，两道题目的解法略有不同。本题和 P8201 在题意上的区别在于本题给定树上的边权，而不是点权。**

小智生活在「传智国」，这是一个有 $n$ 个城市的国家，各个城市由 $n-1$ 条道路相连。

每个道路都有长度 $w_i$ ，我们定义，小智从城市 $a$ 走到城市 $b$ 的代价是 $\mathrm{dis}_{a, b} = \bigoplus \limits_{e \in \mathrm{path}\left(a, b\right)} w_e$，其中 $\bigoplus$ 表示**按位异或**（如果你不知道什么是**按位异或**，请参见题目下方的提示/说明），$\mathrm{path}\left(a,b\right)$ 表示 $a$ 到 $b$ 的简单路径上的边集。也即 $\mathrm{dis}_{a, b}$ 表示将 $a$ 与 $b$ 的简单路径上所有边写作 $e_1, e_2, e_3, \dots$ 后，求 $w_{e_1} \bigoplus w_{e_2}\bigoplus w_{e_3} \dots$ 的结果。

有一天，小智获得了去参加传智杯的机会，他在前往比赛地的路上想到了一个问题，但他好像不会做，于是他把这个题告诉了你。聪明的同学，你可以帮帮他吗？

## 题目描述

小智说：「由于我们的国家只有 $n$ 个城市和 $n-1$ 条道路，那么我们的国家就相当于是一棵树。我在想，在我们的国家中，是否有城市满足『到城市 $a$ 的代价和到城市 $b$ 的代价的异或等于 $k$』。好难哦，我想不出来，你能帮帮我吗？」

也就是说，给定城市 $a, b$ 和整数 $k$，请你计算是否存在城市 $t$ 满足 $\mathrm{dis}_{t, a} \bigoplus \mathrm{dis}_{t, b} = k$。

## 说明/提示

### 相关概念解释
「树」：树是一个有 $n$ 个结点和 $n-1$ 条边的无向简单连通图。

「按位异或」：按位异或即 C++、python、java 语言中的 「^」 运算。它是一个二元运算，步骤是将两个数的二进制位按位比较，相同为 $0$，不同为 $1$。例如：$3 \bigoplus 5 = (011)_2 \bigoplus (101)_2 = (110)_2 = 6$。**请注意，这是一个按位运算，不是一个逻辑运算**。
### 样例 1 解释
下图为传智国的地图。

$\forall t \in \{1, 2, 3, 4, 5\}$，都不可能有 $\mathrm{dis} _{t,1} \bigoplus \mathrm{dis}_{t, 2} = 4$，$\mathrm{dis}_{t, 2} \bigoplus \mathrm{dis}_{t, 3} = 12$，于是输出 `No`；

而取 $t = 5$，有 $\mathrm{dis}_{t, 1} \bigoplus \mathrm{dis}_{t, 4} = 10$，于是输出 `Yes`。

![](https://cdn.luogu.com.cn/upload/image_hosting/9ikzjfh3.png)
### 数据规模与约定
对于所有测试点，保证 $1 < n \leq 5 \times 10^5$，$1 \leq m \leq 5 \times 10^5$，$0 \leq w_i < 2^{64}$。

对于每次询问，保证 $1 \leq a, b \leq n$ 且 $a \neq b$，$0 \leq k < 2^{64}$。

## 样例 #1

### 输入

```
5 3
1 2 2
1 3 6 
2 4 8
2 5 1
1 2 4
2 3 12
1 4 10```

### 输出

```
nO
No
YeS```

## 样例 #2

### 输入

```
5 10
2 1 63
3 1 57
4 2 2
5 2 84
5 2 84
4 1 9977404983223574764
2 5 84
2 1 15996060349666123522
5 4 86
3 1 8428615422876116375
5 1 107
2 3 6
2 3 6
4 2 2```

### 输出

```
yeS
nO
YEs
No
YEs
nO
YEs
yeS
yeS
YEs```

# AI分析结果



# 算法分类
**DFS**

# 综合分析与结论

## 核心思路
题目要求判断是否存在点 t 使得 `dis(t,a) ^ dis(t,b) = k`。通过异或运算的数学性质推导发现，无论 t 的位置如何，`dis(t,a) ^ dis(t,b)` 始终等于 `dis(a,b)`（即 a 到 b 路径的异或和）。因此只需预处理每个节点到根的异或和，通过 `dis(a,b) = xor[a] ^ xor[b]` 直接判断是否等于 k。

## 解决难点
- **数学推导**：发现路径重叠部分的异或抵消特性，将问题转化为固定值判断。
- **高效查询**：通过一次 DFS 预处理所有节点到根的异或和，实现 O(1) 查询。

## 可视化设计
1. **DFS 预处理动画**：展示从根节点出发，递归遍历树的过程，实时更新每个节点的异或值。
2. **路径异或抵消演示**：用颜色区分两条路径（t→a 和 t→b），动态显示重叠部分的异或抵消过程。
3. **复古像素风格**：节点以 8-bit 方块表示，访问时触发像素音效，成功/失败时播放对应音效。
4. **交互控制**：支持暂停/步进，调整动画速度观察 DFS 遍历顺序。

# 题解评分（≥4星）

1. **一扶苏一（5星）**  
   - **亮点**：代码最简洁，直接利用异或性质，无需 LCA 计算。
   - **代码**：仅需 30 行，DFS 预处理 + O(1) 查询。

2. **苏联小渣（4.5星）**  
   - **亮点**：详细数学推导，强调异或运算优先级问题。
   - **调试提示**：注释提醒开 `unsigned long long`。

3. **stntn（4星）**  
   - **亮点**：分情况讨论 t 的位置，图示辅助理解。
   - **代码优化**：使用邻接表存图，内存高效。

# 最优思路与代码

## 关键代码（DFS预处理）
```cpp
void dfs(int u, int fa) {
    for (auto [v, w] : edges[u]) {
        if (v != fa) {
            xor_sum[v] = xor_sum[u] ^ w;
            dfs(v, u);
        }
    }
}
```

## 查询逻辑
```cpp
if ((xor_sum[a] ^ xor_sum[b]) == k) return "Yes";
else return "No";
```

# 类似题目

1. **洛谷 P2420【树的路径异或】**  
   求树中所有路径异或和为零的数量。

2. **洛谷 P4556【雨天的尾巴】**  
   树上差分与路径统计（需结合权值桶）。

3. **Codeforces 842D【树上异或路径查询】**  
   动态维护路径异或最大值。

# 个人心得摘录

- **苏联小渣**：  
  > "因为异或运算的优先级较低，必须加括号，否则会导致逻辑错误。考试时因此卡了很久样例。"

- **stntn**：  
  > "开 `unsigned long long` 是关键，否则大数异或会溢出导致 WA。"

# 可视化与动画设计

## 核心流程
1. **树构建阶段**：以像素方块绘制树结构，边权显示为浮动数字。
2. **DFS 遍历**：根节点开始，递归访问子节点，已访问节点变绿色，当前路径边高亮。
3. **异或值更新**：每个节点旁实时显示 `xor_sum` 的二进制变化。
4. **查询演示**：输入 a、b、k 后，计算 `xor_sum[a]^xor_sum[b]`，动态显示结果与 k 的比对。

## 游戏化要素
- **音效设计**：  
  - 节点访问：8-bit "哔"声。  
  - 成功/失败：经典 FC 过关/失败音效。  
- **积分系统**：每正确回答 10 次解锁新树结构皮肤。

## 代码片段（JS Canvas 绘制）
```javascript
function drawNode(x, y, value, visited) {
    ctx.fillStyle = visited ? '#00FF00' : '#FF0000';
    ctx.fillRect(x, y, 30, 30); // 像素方块
    ctx.fillText(value.toString(16), x + 5, y + 20); // 显示异或值
}
```

---
处理用时：69.80秒
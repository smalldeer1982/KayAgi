# 题目信息

# 「DAOI R1」Flame

## 题目背景

>尝尝天堂里的苹果有什么了不起，我要尝尝地狱里的苹果。

## 题目描述

黑暗里有黑色的火焰，只有目光敏锐的人才可以捕捉到,

借着这点卑微之光,走进地狱深处......

欢迎来到地狱的审判之地。

$ \texttt{hhpq.} $ 将 D 押入了地狱的审判之地，D 必须在业火之城成功生成一座业火监狱之前逃离，所以他想知道还有多少秒时间。

在这座业火之城中，共有 $n$ 个祭坛，共有 $m$ 条可以蔓延火苗的业火之路，且业火之路是双向连通。

已知在这一座业火之城共有 $k$ 个火种已被点燃的业火祭坛，且从第一秒开始，火种将开始从被点燃的业火祭坛向可以蔓延且未被点燃的业火祭坛蔓延。

当祭坛被点燃后，则会瞬间激活，和与之有路的祭坛连接业火圣壁。

当存在一片由业火圣壁构成的封闭图形时，则业火监狱生成成功。

### 简化题意
给出一个 $n$ 个点，$m$ 条边的无向图，每一个点有一个标记，初始有 $k$ 个点的标记为 `1`（将给出这 $k$ 个点的编号），其余的点标记为 `0`。

每一秒，对于每个标记为 `1` 的点，与它**有边相连**的点的标记都会变成 `1`。

求最少需要多少秒，图中标记为 `1` 的点与其相邻的边可以构成一个简单环。

**换言之，求最少多少秒后存在一个由 `1` 构成的集合形成简单环。**

## 说明/提示

### 样例解释

#### 样例1解释

当时间到第一秒时，祭坛 $1$ 的火焰将蔓延到祭坛 $2$ 和 $3$，此时已经构成一个封闭图形了，故答案为 $1$。

#### 样例2解释

可以证明到此时是无法产生简单环的。

### 数据规模

| Subtask | $n\leq$ | $m\leq$ | $k\leq$ | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $10^6$ | $n-1$ | $10^4$ | $5$ |
| $1$ | $10^6$ | $2\times10^6$ | $1$ | $10$|
| $2$ | $10$ | $45$ | $1$ | $5$ |
| $3$ | $200$ | $500$ | $10$ | $10$ |
| $4$| $2\times 10^3$ | $5\times 10^3$ | $50$ | $10$ |
| $5$ | $5\times10^5$ | $6\times10^5$ | $500$ | $30$ |
| $6$ | $10^6$ | $2\times10^6$ | $10^4$ | $30$ |

### 保证与约定

保证数据无重边和自环；

保证数据给定的图是一张无向连通图。

### 帮助

输入量较大，建议使用较为快速的读入方式。

## 样例 #1

### 输入

```
3 3 1
1 2
2 3
3 1
1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5 4 2
1 2
2 3
3 4
2 5
1 5
```

### 输出

```
Poor D!
```

## 样例 #3

### 输入

```
15 15 2
2 1
2 3
2 9
5 9
4 5
5 7
6 7
7 8
7 11
11 10
10 9
10 14
14 15
11 12
12 13
4 15
```

### 输出

```
3
```

# AI分析结果



# 【算法分类】
**BFS**

---

# 【题解思路与解决难点】

## **核心思路**
1. **多源BFS预处理**：计算每个节点被感染的最早时间。
2. **环检测**：通过并查集合并节点，若合并时发现同属一个集合则成环；或二分答案后构建子图用并查集/Tarjan判环。

## **解决难点**
- **感染时间计算**：需处理多个起点同时扩散，通过BFS保证每个节点的最短感染时间。
- **高效环检测**：传统DFS判环复杂度高，通过并查集在合并时动态检测环，时间复杂度接近线性。
- **大规模数据优化**：使用路径压缩+按秩合并的并查集，避免暴力判环的超时风险。

---

# 【题解评分（≥4星）】

### 1. [Binary_Lee] ★★★★★
- **亮点**：对比并查集与Tarjan的优劣，提供两种代码实现，逻辑清晰，注释详细。
- **代码示例**：
  ```cpp
  // 二分答案+并查集判环
  bool check(int mid) {
      dsu.init(n);
      for (int i = 1; i <= m; i++) 
          if (dis[u[i]] <= mid && dis[v[i]] <= mid)
              if (dsu.query(u[i], v[i])) return true;
              else dsu.merge(u[i], v[i]);
      return false;
  }
  ```

### 2. [Augen_stern] ★★★★☆
- **亮点**：提出「边扩散边合并」的BFS优化，减少预处理时间，代码简洁。
- **关键代码**：
  ```cpp
  while (!q.empty()) {
      int x = q.front(); q.pop();
      for (邻接节点 y) {
          if (dis[y]未更新) 更新并合并集合;
          else if (同集合) 更新答案;
      }
  }
  ```

### 3. [Icyfires18] ★★★★☆
- **亮点**：代码结构模块化，包含详细的初始化与剪枝逻辑，适合教学。
- **核心代码**：
  ```cpp
  void bfs() { // 多源BFS
      while (!q.empty()) {
          int u = q.front(); q.pop();
          for (邻接节点 v) 
              if (dis[v] > dis[u]+1) 更新并入队;
      }
  }
  ```

---

# 【最优思路提炼】

### **关键技巧**
1. **多源BFS队列初始化**：将所有初始感染点同时入队，保证扩散顺序的正确性。
2. **边权为1的最短路**：BFS天然保证最短感染时间，无需Dijkstra。
3. **并查集动态判环**：在合并节点时立即检查是否成环，时间复杂度为 $O(m \alpha(n))$。
4. **二分答案优化**：对时间二分，每次仅需检查部分边，减少冗余计算。

---

# 【同类题目推荐】
1. **P2661 信息传递**：有向图最小环，并查集直接应用。
2. **P2921 Trick or Treat on the Farm**：DFS找环+记忆化。
3. **P3388 割点**：Tarjan算法求关键节点。

---

# 【可视化与算法演示】

### **BFS感染过程**
- **动画设计**：像素网格表示节点，颜色梯度表示感染时间，队列用动态列表展示。
- **交互操作**：步进控制感染扩散，高亮当前处理的节点和边。

### **并查集合并**
- **可视化效果**：节点以树结构显示，合并时动态绘制连接线，成环时触发红色闪烁。
- **音效设计**：
  - `感染新节点`：8-bit "滴"声。
  - `发现环`：经典FC胜利音效。

### **复古游戏化示例（伪代码）**
```javascript
// Canvas绘制感染节点
function drawNode(x, y, time) {
    ctx.fillStyle = `hsl(${time * 30}, 70%, 50%)`;
    ctx.fillRect(x * 20, y * 20, 18, 18);
}

// 音效触发
function playSound(effect) {
    const sfx = { infect: 'beep.mp3', cycle: 'fanfare.mp3' };
    new Audio(sfx[effect]).play();
}
```

---

# 【核心代码实现】

### **多源BFS预处理**
```cpp
queue<int> q;
memset(dis, 0x3f, sizeof dis);
for (int i = 1; i <= k; i++) {
    int x; cin >> x;
    dis[x] = 0;
    q.push(x);
}
while (!q.empty()) {
    int u = q.front(); q.pop();
    for (int v : adj[u]) {
        if (dis[v] > dis[u] + 1) {
            dis[v] = dis[u] + 1;
            q.push(v);
        }
    }
}
```

### **并查集判环**
```cpp
int find(int x) {
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}

bool check(int t) {
    for (int i = 1; i <= n; i++) fa[i] = i;
    for (auto [u, v] : edges) {
        if (dis[u] > t || dis[v] > t) continue;
        int fu = find(u), fv = find(v);
        if (fu == fv) return true;
        fa[fu] = fv;
    }
    return false;
}
```

---
处理用时：69.59秒
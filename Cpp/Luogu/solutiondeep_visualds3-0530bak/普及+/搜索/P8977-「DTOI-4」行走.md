# 题目信息

# 「DTOI-4」行走

## 题目背景

小 L 感到无聊，于是希望在树上行走。

## 题目描述

小 L 有一棵 $n$ 个点的树，树上点有点权，其中第 $i$ 个点权值为 $a_i$。

他不喜欢奇奇怪怪的权值，于是他保证 $a_i$ 一定是 $-1, 0, 1$ 之一。

他认为在树上行走是有趣的，于是他想要在这棵树上走出一条路径 $P$，其需要满足以下条件：

- $P$ 是一条**可以为空**的**简单有向路径**。
- 设 $P$ 中依次经过的点为 $P_1, P_2, \cdots, P_{|P|}$，则你求出的 $P$ 需要满足 $P_1 = 1$。
- 设 $f(P) = \displaystyle\sum_{i = 1}^{|P|} \frac{a_{P_i}}{2^{i - 1}}$，则你求出的 $P$ 需要满足 $f(P)$ 最大。
- 在 $f(P)$ 最大的前提下，你求出的 $P$ 还需要满足 $P$ 的字典序最小。

请你求出符合上述条件的路径 $P$。 

------------

关于本题中字典序的定义：

设有两条待比较的路径 $P \neq Q$。

- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i < Q_i$，则我们称 $P$ 的字典序小于 $Q$。
- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i > Q_i$，则我们称 $P$ 的字典序大于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| < |Q|$，则我们称 $P$ 的字典序小于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| > |Q|$，则我们称 $P$ 的字典序大于 $Q$。

## 说明/提示

#### 样例 #1 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/c7n2n6i0.png)

$P = [1, 2, 4]$ 时 $f(P) = 1 + 0 + \frac{1}{4} = \frac{5}{4}$。可以证明不存在更优的 $P$。
#### 数据范围
| $\textbf{Subtask}$ | $n$ | $a_i$ | 依赖 | 分值 |
| :------: | :------: | :------: | :------: | :------: |
| $1$ | $1 \leq n \leq 50$ | 无特殊限制 | 无 | $10 \operatorname{pts}$ |
| $2$ | $1 \leq n \leq 500$ | 同上 | $1$ | $10 \operatorname{pts}$ |
| $3$ | $1 \leq n \leq 5 \times 10^3$ | 同上 | $1, 2$ | $10 \operatorname{pts}$ |
| $4$ | $1 \leq n \leq 10^5$ | 同上 | $1 \sim 3$ | $20 \operatorname{pts}$ |
| $5$ | 无特殊限制 | $a_i \in \{-1, 1\}$ | 无 | $20 \operatorname{pts}$ |
| $6$ | 同上 | 无特殊限制 | $1 \sim 5$ | $30 \operatorname{pts}$ |

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$a_i \in \{-1, 0, 1\}$，$1 \leq u, v \leq n$，保证给出的边可以构成一棵**无根树**。

## 样例 #1

### 输入

```
5
1 0 -1 1 -1
1 2
2 3
2 4
1 5```

### 输出

```
1 2 4```

# AI分析结果



## 算法分类
**DFS**

## 综合分析与结论
### 核心思路
题目要求在树结构中找到从根节点1出发的最优路径，满足权值和最大且字典序最小。所有题解均基于以下关键策略：
1. **排除负权节点**：路径不能包含权值为-1的节点（后序权值无法弥补当前损失）。
2. **贪心选择权值1**：每一步优先选择权值1的路径，确保当前位的最大贡献。
3. **字典序处理**：邻接表排序确保遍历时优先访问编号更小的节点。

### 解决难点
- **权值比较**：采用二进制权重思想，高位权值（路径前段）对结果影响更大，需优先处理。
- **路径剪枝**：DFS/BFS过程中动态维护当前最优路径，及时淘汰次优分支。
- **后缀0处理**：路径末尾的0不会增加权值但影响字典序，需在输出前截断。

### 可视化设计
1. **节点状态标记**：
   - 红色：当前访问节点
   - 绿色：待访问队列中的节点
   - 灰色：已淘汰节点
2. **搜索过程动画**：
   - 逐步展开树结构，高亮当前处理的父节点
   - 显示DFS递归栈的入栈/出栈操作
   - 实时显示路径权值计算过程（浮点累加器）
3. **8位像素风格**：
   - 节点使用16x16像素方块，权值1用黄色，0用蓝色，-1用红色
   - 路径绘制采用经典RPG游戏的"踩格子"效果
   - 音效系统：节点访问时播放NES风格的"哔"声，找到最优路径时播放《超级玛丽》过关音效

## 题解清单（4星及以上）
### 1. xiaoqian02（4.5星）
- **亮点**：使用DFS+路径剪枝，维护`qz`数组记录当前最优权值序列
- **代码可读性**：结构清晰，注释详细
- **关键代码**：
```cpp
bool dfs(int p,int fr,int dep) {
    int mx = -1;
    bool bg = 0;
    for(int k : ed[p]) {
        if(k == fr) continue;
        mx = max(mx, a[k]);
        // 剪枝逻辑...
    }
    // 处理0权值分支...
}
```

### 2. Hovery（4星）
- **亮点**：BFS分层处理，维护`mx`数组记录每层最大权值
- **优化点**：优先队列保证字典序
- **关键代码**：
```cpp
while(!q.empty()) {
    auto [x, dep, val] = q.front();
    if(val < mx[dep]) continue; // 剪枝
    // 扩展子节点...
}
```

### 3. Leasier（4.2星）
- **亮点**：双队列系统处理权值1和0的分界
- **创新点**：使用`dot1/dot2/dot3`数组管理不同权值层节点
```cpp
while(true) {
    if(存在权值1节点) {
        // 处理1权值层...
    } else {
        // 处理0权值层...
    }
}
```

## 最优思路提炼
1. **路径构建策略**：
   - 优先选择权值1的分支
   - 当某层无1时降级选择0
   - 动态维护当前最优路径前缀

2. **字典序保证**：
   - 预处理邻接表排序（`sort(ed.begin(), ed.end())`）
   - 在权值相同的情况下选择编号最小的子节点

3. **空间优化**：
   - 使用`nxt[]`数组记录每个节点的最优后继，避免存储完整路径
   - 及时清空不再使用的路径缓存（`vector().swap()`）

## 类似题目推荐
1. **P1354 树的直径**（树形DP+路径追踪）
2. **P3398 仓鼠找sugar**（LCA应用+路径交叉判断）
3. **P2680 运输计划**（树链操作+二分答案）

## 可视化核心代码示例
```javascript
// 像素风格路径绘制
function drawPath(ctx, path) {
    path.forEach((node, idx) => {
        const x = node.x * 16 + 4;
        const y = node.y * 16 + 4;
        ctx.fillStyle = node.a === 1 ? '#FFE202' : '#00A2E8';
        ctx.fillRect(x, y, 8, 8);
        if(idx > 0) {
            const prev = path[idx-1];
            ctx.strokeStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.moveTo(prev.x*16+8, prev.y*16+8);
            ctx.lineTo(x+8, y+8);
            ctx.stroke();
        }
    });
}
```

## 个人心得摘录
> "赛时漏掉后缀0截断导致WA了3次，后来在纸上画出权值分布才恍然大悟。调试时输出每层`qz`数组的状态帮助极大。" —— Nuyoah_awa

> "意识到邻接表排序的重要性后，把链式前向星改为vector+sort，直接通过了最后一个hack用例。" —— xiaoqian02

## 复古游戏化演示
1. **初始化**：
   - 16色调色板加载（Javascript `ImageData`处理）
   - 加载8-bit音效（`beep1.wav`用于节点访问，`success.wav`用于找到路径）

2. **动画循环**：
```javascript
function gameLoop() {
    // 每帧更新当前搜索节点
    const current = stack.pop();
    drawNode(current, 0xFF0000); // 红色高亮当前节点
    
    // 处理子节点
    current.children.sort().forEach(child => {
        if(!visited.has(child)) {
            visited.add(child);
            drawNode(child, 0x00FF00); // 绿色标记待访问
            stack.push(child);
            playSound(beep1); // 播放音效
        }
    });
    
    // 递归调用
    if(stack.length > 0) {
        setTimeout(gameLoop, 300); // 300ms帧间隔
    } else {
        playSound(success); // 找到路径
    }
}
```

3. **交互控制**：
   - 空格键暂停/继续
   - 方向键控制单步执行
   - F1键切换自动/手动模式

通过这种可视化设计，学习者可以直观观察DFS的递归过程，理解路径选择的优先级策略，并在游戏化交互中加深对树遍历算法的理解。

---
处理用时：73.39秒
# 题目信息

# [KMOI R1] 军事行动

## 题目背景

$$\blue{他们来了。}$$

$$\purple{集结军队，干掉他们，一个不留。}$$

$$\blue{是！}$$

## 题目描述

喵星边境局势愈发紧张，导致发生边境冲突。喵星军队总司令小袁立即对 $Y$ 星采取军事行动。

整个宇宙可以看作一个平面直角坐标系，城市 $1,2,\dots,n$ 的坐标分别为 $(x_1,y_1),(x_2,y_2),\dots(x_n,y_n)$。

现在小袁率领的**若干支**舰队（可以理解为小袁的军事力量是无限的）驻扎在边境要塞，城市 $1$ 处。他的舰队会进行以下移动：

- 如果舰队的坐标为 $(x,y)$，那么一天之后它可以移动到 $(x-1,y+2)$ 或 $(x+1,y+2)$ 或 $(x+2,y+1)$ 或 $(x-2,y+1)$ 或 $(x-1,y-2)$ 或 $(x+1,y-2)$ 或 $(x+2,y-1)$ 或 $(x-2,y-1)$ 处。

其中环绕在外的还有一条小行星带，当舰队的坐标  $(x,y)$ 且 $x\le 0$ 或 $y\le 0$ 或 $m < x$ 或 $m < y$ 时，舰队就会撞到小行星带。这是小袁所不想看到的。

现在小袁要攻打城市 $2,3,\dots,n$，每一次他都会从一个**已经占领**的城市（城市 $1$ 也算），派出舰队前往城市 $i$ 并攻打它，舰队**到达之后的第二天**城市 $i$ 就被攻占了。

特别的，小袁在一个舰队**前往攻打或攻打一个城市**的时候不会派出另外一支舰队，在**攻占一座城市后当天**可以立即派出另外一支舰队。

小袁想问，最少要花多少时间才能攻占所有的城市。

**攻打顺序可以不按照 $2,3\dots n$ 的顺序。**

## 说明/提示

## 样例一解释：

舰队在第一天来到了 $(3,2)$ 的位置，第二天到达了城市 $2$ 的位置，第三天占领了城市 $2$。总共花了 $3$ 天。

## 样例二解释：

舰队在第一天到达了城市 $2$ 的位置，第二天占领了城市 $2$。第三天到达了城市 $3$ 的位置，第四天占领了城市 $3$。总共花了 $4$ 天。

## 数据范围

**本题采用 Subtask 捆绑测试。**

|子任务编号|  测试点编号| $n$ | $m$ |特殊性质|分值|
|:-----:| :----------: | :----------: | :----------: | :----------: |:---:|
|$1$| $1\sim2$ | $1\le n\le 7$ |$4\le m\le 7$|无|$10$|
|$2$| $3\sim7$ | $1\le n\le 200$ |$4\le m\le 70$|无|$25$|
|$3$| $8\sim9$ | $1\le n\le 150$ |$4\le m\le 150$|有|$15$|
|$4$| $10\sim20$ | $1\le n\le 2000$ |$4\le m\le 150$|无|$50$|

特殊性质：对于每一个 $1\le i\le n-1$，都有 $x_i = x_{i+1}$。

**数据严格保证不会有不同的城市拥有相同的坐标。**

## 样例 #1

### 输入

```
2 20
1 1
1 3```

### 输出

```
3```

## 样例 #2

### 输入

```
3 150
1 2
2 4
4 3```

### 输出

```
4```

## 样例 #3

### 输入

```
10 10
1 4
2 3
2 6
3 6
10 3
1 5
4 2
5 3
2 8
9 2```

### 输出

```
23```

## 样例 #4

### 输入

```
查看附件的 example4.in```

### 输出

```
查看附件的 example4.out```

# AI分析结果



**唯一算法分类**  
BFS

---

### **题解思路、算法要点与解决难点**  
**核心思路**：  
所有题解均基于「BFS预处理城市间移动时间 → 构建完全图 → 最小生成树求总时间」的核心流程。  
1. **BFS预处理**：为每个城市发起 BFS，计算其到其他城市的最短移动天数（即边权）。  
2. **最小生成树（MST）**：将城市视为图的节点，边权为移动天数，求 MST 的总边权，加上攻占所需的 $n-1$ 天。  

**解决难点**：  
- **高效计算边权**：直接暴力 BFS 每个城市的坐标，确保正确性。  
- **大规模边的处理**：完全图边数为 $O(n^2)$，需用 Kruskal 或 Prim 高效处理。  

**搜索算法要点**：  
- **队列初始化**：以当前城市的坐标作为起点，步数初始化为 0。  
- **访问顺序**：BFS 按层扩展，保证首次到达其他城市时的步数最小。  
- **剪枝策略**：使用 `vis` 数组避免重复访问同一坐标。  

---

### **题解评分 (≥4星)**  
1. **Fire_flame (5星)**  
   - 思路清晰，代码结构简洁。  
   - BFS 预处理后直接 Kruskal 求 MST，逻辑连贯。  
   - 预处理时动态生成边，减少内存占用。  

2. **Night_sea_64 (4星)**  
   - 明确说明 BFS + Prim 的适用性。  
   - 代码注释详细，适合初学者理解。  

3. **DerrickLo (4星)**  
   - 使用 BFS 动态记录边权，Kruskal 实现高效。  
   - 代码中处理队列时直接存储步数，避免冗余计算。  

---

### **最优思路或技巧提炼**  
1. **BFS预处理边权**：对每个城市发起 BFS，记录其到所有其他城市的最短移动天数。  
2. **完全图 MST 优化**：Prim 算法在完全图上复杂度为 $O(n^2)$，优于 Kruskal 的 $O(m \log m)$（$m \approx n^2$）。  
3. **攻占时间修正**：最终答案需加上 $n-1$ 天（每个城市攻占耗时 1 天）。  

---

### **同类型题或类似算法套路**  
- **图的最短路径总和**：如 [P1396 营救](https://www.luogu.com.cn/problem/P1396)，需找到路径使最大边权最小。  
- **网格中的 BFS 扩展**：如 [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)，利用 BFS 层序特性。  

---

### **推荐相似题目**  
1. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)  
2. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)  
3. [P1396 营救](https://www.luogu.com.cn/problem/P1396)  

---

### **个人心得摘录**  
- **sbno333**：纯 BFS 搜索比 MST 快 10 倍，但需注意剪枝优化。  
- **ryf_loser**：调试时因未加 $n-1$ 的天数导致错误，强调审题重要性。  

---

### **可视化与算法演示**  
**动画方案**：  
1. **BFS 扩散过程**：  
   - **像素风格网格**：城市用绿色方块表示，BFS 扩散用橙色波浪填充。  
   - **队列状态**：右侧面板显示当前队列中的坐标及步数。  
   - **音效触发**：每访问新坐标播放短促“滴”声，发现城市时播放“金币”音效。  

2. **最小生成树构建**：  
   - **边的高亮**：MST 的边以蓝色动态连接，添加时伴随“连接”音效。  
   - **实时总时间**：顶部面板显示当前总时间（边权和 + 攻占天数）。  

**交互设计**：  
- **步进控制**：支持暂停/继续，手动单步观察 BFS 扩展。  
- **复古 UI**：使用 8-bit 字体，背景音乐为循环芯片音乐。  

---

### **关键代码片段**  
**BFS 预处理边权（Fire_flame 题解）**  
```cpp
void bfs(int sx, int sy) {
    queue<step> q;
    q.push({sx, sy, 0});
    memset(f, 0, sizeof(f));
    f[sx][sy] = 1;
    while (!q.empty()) {
        int tx = q.front().x, ty = q.front().y, tl = q.front().len;
        q.pop();
        for (int i = 0; i < 8; i++) {
            int px = tx + dx[i], py = ty + dy[i];
            if (f[px][py] || px <= 0 || py <= 0 || px > m || py > m) continue;
            if (mp[px][py]) // 发现其他城市，记录边权
                e[++cnt] = {mp[sx][sy], mp[px][py], tl + 1};
            f[px][py] = 1;
            q.push({px, py, tl + 1});
        }
    }
}
```

---

**总结**：本题通过 BFS 预处理与最小生成树的结合，巧妙地将路径搜索转化为图论问题，适合作为 BFS 扩展与 MST 应用的经典案例。

---
处理用时：75.90秒
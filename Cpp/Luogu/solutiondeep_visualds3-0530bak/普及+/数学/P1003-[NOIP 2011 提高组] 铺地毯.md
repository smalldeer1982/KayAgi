# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果



# 解题分析

## 唯一算法分类
**几何**

---

## 题解思路与算法要点

### 核心思路
**覆盖性检查**：判断给定点是否在某个地毯的矩形范围内。  
**逆序优化**：后铺的地毯覆盖先铺的，逆序遍历可提前找到答案。  
**空间优化**：仅存储地毯参数，避免二维数组爆内存。

### 解决难点
1. **内存限制**：直接开二维数组记录坐标会超内存（400MB），需改用参数存储。  
2. **高效判断**：  
   - 检查点是否在矩形内的公式：`a ≤ x ≤ a+g` 且 `b ≤ y ≤ b+k`  
   - 逆序遍历只需找到第一个满足条件的地毯即可终止。

### 数学方法
- **矩形覆盖判定**：通过左上角坐标 `(a,b)` 和延伸范围 `(g,k)` 计算右下角坐标 `(a+g, b+k)`。  
- **边界处理**：边界和顶点视为被覆盖。

---

## 题解评分 (≥4星)

### 智子 (5星)
- **亮点**：首提空间优化思路，明确MLE问题，提供AC代码。  
- **代码**：使用四个数组存储参数，正序遍历更新答案。

### kuaiCreator (5星)
- **亮点**：逆序遍历提前终止，时间复杂度最优。  
- **代码**：循环从 `n` 到 `1`，找到即退出。

### Jayfeather2012 (4星)
- **亮点**：明确逆序思路，代码简洁。  
- **不足**：变量命名可优化。

---

## 最优思路提炼
1. **逆序检查**：从最后铺的地毯开始检查，第一个覆盖点即为答案。  
2. **公式判定**：`x ∈ [a, a+g]` 且 `y ∈ [b, b+k]`。  
3. **提前终止**：找到后立即返回结果，减少遍历次数。

---

## 同类型题拓展
- **通用思路**：多矩形覆盖问题中，常通过存储参数逐个检查。  
- **常见优化**：逆序剪枝、空间压缩、批量处理。

---

## 推荐题目
1. **P1503 兔子猎杀**（判断点是否在陷阱范围内）  
2. **P2283 激光炸弹**（二维前缀和覆盖统计）  
3. **P3744 李彬的几何课**（几何图形覆盖判定）

---

## 代码实现（逆序优化版）
```cpp
#include <iostream>
using namespace std;

const int MAXN = 1e4 + 5;
int a[MAXN], b[MAXN], g[MAXN], k[MAXN];

int main() {
    int n, x, y;
    cin >> n;
    for (int i = 1; i <= n; ++i)
        cin >> a[i] >> b[i] >> g[i] >> k[i];
    cin >> x >> y;

    for (int i = n; i >= 1; --i) {
        if (x >= a[i] && x <= a[i] + g[i] && y >= b[i] && y <= b[i] + k[i]) {
            cout << i;
            return 0;
        }
    }
    cout << -1;
    return 0;
}
```

---

## 可视化设计

### 动画方案
1. **像素风格渲染**：  
   - 用 `Canvas` 绘制坐标系，地毯以不同颜色矩形表示。  
   - 目标点用闪烁像素点标记。  
2. **逆序检查演示**：  
   - 高亮当前检查的地毯边界（红色边框）。  
   - 若覆盖，播放成功音效并停止；否则渐隐该地毯。  
3. **音效交互**：  
   - **覆盖时**：8-bit 上扬音效。  
   - **未覆盖**：短促“滴”声。  
   - **结束**：找到答案时播放经典FC通关音乐。

### 代码片段（JS）
```javascript
// 伪代码：绘制逆序检查过程
function drawStep(i) {
    ctx.clearRect(0, 0, W, H);
    drawGrid(); // 绘制背景网格
    drawPoint(x, y); // 绘制目标点
    // 绘制当前检查的地毯
    ctx.strokeStyle = 'red';
    ctx.strokeRect(a[i], b[i], g[i], k[i]);
    // 覆盖判定
    if (checkCover(i)) {
        playSuccessSound();
        stopAnimation();
    }
}
```

---

## 个人心得摘录
- **kuaiCreator**：逆序遍历是本题的最优解，比正序减少平均时间复杂度。  
- **智子**：调试时发现二维数组不可行，转向参数存储法。  
- **Eason_cyx**：从错误中学习，避免无脑开大数组。

---
处理用时：63.44秒
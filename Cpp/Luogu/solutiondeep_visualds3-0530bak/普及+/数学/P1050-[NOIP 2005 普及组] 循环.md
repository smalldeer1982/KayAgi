# 题目信息

# [NOIP 2005 普及组] 循环

## 题目描述

乐乐是一个聪明而又勤奋好学的孩子。他总喜欢探求事物的规律。一天，他突然对数的正整数次幂产生了兴趣。


众所周知，$2$ 的正整数次幂最后一位数总是不断的在重复 $2,4,8,6,2,4,8,6…$ 我们说 $2$ 的正整数次幂最后一位的循环长度是 $4$（实际上 $4$ 的倍数都可以说是循环长度，但我们只考虑最小的循环长度）。类似的，其余的数字的正整数次幂最后一位数也有类似的循环现象：

$$
\def\arraystretch{1.5}
\begin{array}{c|c|c}\hline
\textbf{数字}& \textbf{循环} & \textbf{循环长度} \cr\hline\hline
2 & 2,4,8,6 & 4\cr\hline
3 & 3,9,7,1 & 4\cr\hline
4 & 4,6 & 2\cr\hline
5 & 5 &  1\cr\hline
6 & 6 & 1\cr\hline
7 & 7,9,3,1 & 4\cr\hline
8 & 8,4,2,6 & 4\cr\hline
9 & 9,1 & 2\cr\hline
\end{array}
$$

这时乐乐的问题就出来了：是不是只有最后一位才有这样的循环呢？对于一个整数 $n$ 的正整数次幂来说，它的后 $k$ 位是否会发生循环？如果循环的话，循环长度是多少呢？

注意：

1. 如果 $n$ 的某个正整数次幂的位数不足 $k$，那么不足的高位看做是 $0$。
2. 如果循环长度是 $L$，那么说明对于任意的正整数 $a$，$n$ 的 $a$ 次幂和 $a+L$ 次幂的最后 $k$ 位都相同。


## 说明/提示

**【数据范围】**

对于 $30 \%$ 的数据，满足 $k \le 4$；  
对于$100 \%$ 的数据，满足 $1 \le n < {10}^{100}$，$1 \le k \le 100$。

**【题目来源】**

NOIP 2005 普及组第四题

## 样例 #1

### 输入

```
32 2```

### 输出

```
4```

# AI分析结果



**唯一算法分类**：数论

---

### **题解思路与核心难点**

#### **核心思路**
题目要求计算大数 `n` 的正整数次幂后 `k` 位的循环长度。核心思路是逐位递推：
1. **逐位处理**：从最后一位开始，逐步扩展到 `k` 位。
2. **循环倍数关系**：后 `i` 位的循环长度必为后 `i-1` 位循环长度的倍数。
3. **高精度优化**：仅保留后 `k` 位参与计算，避免指数爆炸。

#### **关键公式与推导**
- **递推公式**：若后 `i-1` 位的循环长度为 `L`，则后 `i` 位的循环长度必为 `L × t`（`t ∈ [1,10]`）。
- **模运算性质**：每次计算时，通过模 `10^i` 保留后 `i` 位，确保运算规模可控。
- **无解条件**：若某一位在 10 次尝试内无法找到循环，则整体无解。

#### **解决难点**
1. **高精度乘法**：实现仅保留后 `k` 位的高效乘法。
2. **循环长度递推**：维护当前乘数基数，快速找到各次幂的后 `k` 位。
3. **时间复杂度控制**：逐位处理将复杂度优化至 `O(k² × 10)`。

---

### **题解评分（≥4星）**

1. **作者：_Life_（4.5星）**
   - **亮点**：逐位递推思路清晰，附详细计算示例，代码高效。
   - **代码**：高精度乘法仅保留后 `k` 位，逐次更新乘数基数。

2. **作者：vectorwyx（4星）**
   - **亮点**：理论证明循环倍数关系，代码结合数论与高精度。
   - **关键段**：通过 `10` 次枚举确定每层循环倍数。

3. **作者：Shadow_Soldier（4星）**
   - **亮点**：详细数学推导，代码注释清晰，高精度实现规范。

---

### **最优思路提炼**

1. **递推法**：
   - 从后 `1` 位开始，逐层计算后 `i` 位的循环长度。
   - 每层最多尝试 `10` 次乘法，时间复杂度稳定。

2. **高精度优化**：
   ```cpp
   // 高精度乘法（仅保留后k位）
   bignum operator*(bignum a, bignum b) {
       bignum ans;
       for (int i=0; i<k; i++)
           for (int j=0; j<k; j++)
               ans.x[i+j] += a.x[i] * b.x[j];
       // 进位处理与截断
       return ans;
   }
   ```

3. **乘数基数更新**：
   - 每层处理完成后，更新乘数为当前循环次方，保持前 `i` 位不变。

---

### **同类型题与算法套路**

1. **通用套路**：
   - **循环节问题**：利用逐层递推和模运算性质。
   - **高精度优化**：仅保留必要位数参与运算。
   - **数论应用**：欧拉定理、循环长度分解。

2. **相似题目**：
   - **P1965 转圈游戏**（快速幂模运算）
   - **P1068 指数循环节**（欧拉定理应用）
   - **P1313 计算系数**（高精度与组合数）

---

### **可视化与算法演示**

#### **动画方案**
- **逐层递推演示**：
  - **第1步**：显示后 `1` 位的循环计算（如 `3 → 9 → 7 → 1`）。
  - **第i步**：高亮当前处理位，展示乘数基数的更新。
  - **颜色标记**：红色标记当前计算位，绿色显示已确定的循环长度。

#### **复古像素风格**
- **Canvas 绘制**：
  - 用 8 位像素块表示每一位数字，每次乘法后更新对应块的颜色。
  - **音效**：成功找到循环时播放 `8-bit` 上扬音效，失败则短促提示。

#### **交互设计**
- **步进控制**：允许单步执行，观察每层循环的乘法和取模过程。
- **自动模式**：AI 自动推导，模拟“贪吃蛇”式路径展示递推步骤。

---

### **核心代码实现**

```cpp
// 高精度结构体与乘法（保留后k位）
struct bignum {
    int x[205];
    bignum() { memset(x, 0, sizeof(x)); }
    bignum operator*(const bignum &b) const {
        bignum res;
        for (int i=0; i<k; i++)
            for (int j=0; j<k; j++)
                res.x[i+j] += x[i] * b.x[j];
        // 进位处理
        for (int i=0; i<k; i++) {
            res.x[i+1] += res.x[i] / 10;
            res.x[i] %= 10;
        }
        return res;
    }
};

// 逐层递推主逻辑
bignum n, mul, ans;
for (int i=0; i<k; i++) {
    bignum tmp = n;
    int cnt = 1;
    for (; cnt<=10; cnt++) {
        tmp = tmp * mul; // 乘数基数
        if (tmp.x[i] == n.x[i]) break;
    }
    if (cnt > 10) return puts("-1"), 0;
    ans = ans * cnt; // 更新总循环长度
    // 更新乘数为 mul^cnt
}
```

---

**总结**：本题通过逐位递推与高精度优化，将复杂循环问题分解为可处理的子问题，结合数论性质与代码实现技巧，高效解决大规模指数循环计算。

---
处理用时：80.12秒
# 题目信息

# [NOIP 2005 提高组] 谁拿了最多奖学金

## 题目描述

某校的惯例是在每学期的期末考试之后发放奖学金。发放的奖学金共有五种，获取的条件各自不同：

1. 院士奖学金，每人 $8000$ 元，期末平均成绩高于 $80$ 分（$>80$），并且在本学期内发表$1$篇或$1$篇以上论文的学生均可获得；
2. 五四奖学金，每人 $4000$ 元，期末平均成绩高于 $85$ 分（$>85$），并且班级评议成绩高于 $80$ 分（$>80$）的学生均可获得；
3. 成绩优秀奖，每人 $2000$ 元，期末平均成绩高于 $90$ 分（$>90$）的学生均可获得；
4. 西部奖学金，每人 $1000$ 元，期末平均成绩高于 $85$ 分（$>85$）的西部省份学生均可获得；
5. 班级贡献奖，每人 $850$ 元，班级评议成绩高于 $80$ 分（$>80$）的学生干部均可获得；

只要符合条件就可以得奖，每项奖学金的获奖人数没有限制，每名学生也可以同时获得多项奖学金。例如姚林的期末平均成绩是 $87$ 分，班级评议成绩 $82$ 分，同时他还是一位学生干部，那么他可以同时获得五四奖学金和班级贡献奖，奖金总数是 $4850$ 元。

现在给出若干学生的相关数据，请计算哪些同学获得的奖金总数最高（假设总有同学能满足获得奖学金的条件）。


## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，满足 $1 \le  N \le  100$。

**【题目来源】**

NOIP 2005 提高组第一题

## 样例 #1

### 输入

```
4
YaoLin 87 82 Y N 0
ChenRuiyi 88 78 N Y 1
LiXin 92 88 N N 0
ZhangQin 83 87 Y N 1
```

### 输出

```
ChenRuiyi
9000
28700
```

# AI分析结果



**唯一算法分类**  
无算法分类

---

### **题解思路、算法要点与解决难点**  
1. **核心思路**  
   - **模拟计算**：遍历每个学生，按条件累加其奖学金。  
   - **即时更新最大值**：在输入时直接计算并记录当前最高奖学金学生，避免存储全部数据。  
   - **条件独立判断**：每个奖学金条件独立检查，允许叠加。  

2. **数学方法**  
   - **逻辑表达式优化**：通过逻辑表达式（如 `(a>80 && e)*8000`）将条件判断与金额计算合并，简化代码。  
   - **打擂台法**：仅需一次遍历即可找到最大值，时间复杂度为 `O(n)`。  

3. **解决难点**  
   - **输入处理**：需正确处理字符串和字符的输入顺序（如 `scanf(" %c")` 跳过空格）。  
   - **条件边界**：注意严格大于（如 `>85` 而非 `>=85`）。  

---

### **题解评分 (≥4星)**  
1. **qhr2023**（★★★★★）  
   - **亮点**：代码极度简洁，利用逻辑表达式直接计算每项奖金，时间复杂度最低。  
   - **代码可读性**：对熟练开发者友好，但对新手稍显抽象。  

2. **hanyu0722**（★★★★☆）  
   - **亮点**：完全无需结构体或排序，直接在输入时处理数据，内存效率最优。  
   - **实践性**：适合竞赛场景，代码简短高效。  

3. **Haohao123coding**（★★★★☆）  
   - **结构清晰**：使用结构体存储数据，代码逻辑明确，适合教学场景。  
   - **打擂台法**：正确维护最大值和总奖金。  

---

### **最优思路/技巧提炼**  
1. **逻辑表达式计算**  
   - 将条件判断与金额计算合并：`sum += (condition) * reward`。  
   - 示例：`(a>85 && b>80)*4000` 直接计算是否满足五四奖学金。  

2. **即时更新最大值**  
   ```cpp
   if (current_money > max_money) {
       max_money = current_money;
       max_student = current_name;
   }
   ```  

3. **输入优化**  
   - 使用 `scanf(" %c")` 跳过空格，避免字符读取错误。  

---

### **同类型题与算法套路**  
1. **条件叠加型模拟题**  
   - 特点：多个独立条件需同时检查，结果累加。  
   - 套路：逐项判断条件，避免使用 `else if`。  

2. **经典例题**  
   - [P1085 不高兴的津津](https://www.luogu.com.cn/problem/P1085)：多条件判断每日状态。  
   - [P1422 小玉家的电费](https://www.luogu.com.cn/problem/P1422)：分段计费问题。  

---

### **推荐相似题目**  
1. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)  
2. [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)  
3. [P1598 垂直柱状图](https://www.luogu.com.cn/problem/P1598)  

---

### **可视化与算法演示**  
**动画设计**  
1. **像素风格界面**  
   - **颜色方案**：16色复古调色板，绿色表示满足条件，红色表示未满足。  
   - **Canvas 绘制**：每个学生显示为像素方块，右侧动态展示条件检查结果。  

2. **核心计算步骤**  
   - **步骤1**：高亮当前学生姓名，显示其期末成绩、班级成绩等数据。  
   - **步骤2**：逐个检查奖学金条件，满足则显示对应奖金并播放音效。  
   - **步骤3**：更新总奖金和当前最高记录，用箭头指向最大值学生。  

3. **交互功能**  
   - **步进控制**：允许单步执行观察每个条件判断。  
   - **自动模式**：以 1秒/步的速度自动演示，背景音乐为 8-bit 风格。  

**代码片段（JS 伪代码）**  
```javascript
// 初始化 Canvas 和音效
const canvas = document.getElementById("pixel-canvas");
const ctx = canvas.getContext("2d");
const beepSound = new Audio("8bit-beep.wav");

function drawStudent(student, step) {
    // 绘制学生像素方块，高亮当前步骤
    if (step === 0) ctx.fillStyle = "#FF0000"; // 红色高亮
    else ctx.fillStyle = "#00FF00";             // 绿色条件满足
    ctx.fillRect(x, y, 32, 32);
}
```

---

### **个人心得摘录**  
- **qhr2023**：利用逻辑表达式简化代码是竞赛编程的常用技巧，但需注意可读性。  
- **lucienshawls**：输入优化虽在本题不必要，但养成良好习惯对处理大数据有益。  
- **Haohao123coding**：结构体虽增加代码量，但在复杂问题中更易维护。  

---

### **核心代码实现（qhr2023 风格）**  
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, total_sum = 0, max_sum = 0;
    string max_name;
    cin >> n;
    
    for (int i = 0; i < n; i++) {
        string name;
        int a, b, e;
        char c, d;
        cin >> name >> a >> b >> c >> d >> e;
        
        int current = (a > 80 && e >= 1) * 8000 +
                     (a > 85 && b > 80) * 4000 +
                     (a > 90) * 2000 +
                     (a > 85 && d == 'Y') * 1000 +
                     (b > 80 && c == 'Y') * 850;
        
        total_sum += current;
        if (current > max_sum) {
            max_sum = current;
            max_name = name;
        }
    }
    
    cout << max_name << "\n" << max_sum << "\n" << total_sum;
    return 0;
}
```

---
处理用时：106.93秒
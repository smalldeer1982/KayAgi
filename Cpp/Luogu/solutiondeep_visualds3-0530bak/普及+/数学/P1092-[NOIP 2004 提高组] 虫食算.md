# 题目信息

# [NOIP 2004 提高组] 虫食算

## 题目描述

所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的数字。来看一个简单的例子：

$$\begin{aligned}
 \verb!43#9865#045! \\
+\qquad \verb!8468#6633! \\[-1em]\underline{\kern{8em}} \\
 \verb!44445509678! \\
\end{aligned}$$

其中 `#` 号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是 $5$ 和 $3$，第二行的数字是 $5$。

现在，我们对问题做两个限制：

首先，我们只考虑加法的虫食算。这里的加法是 $n$ 进制加法，算式中三个数都有 $n$ 位，允许有前导的 $0$。

其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是 $n$ 进制的，我们就取英文字母表的前 $n$ 个大写字母来表示这个算式中的 $0$ 到 $n - 1$ 这 $n$ 个不同的数字：但是这 $n$ 个字母并不一定顺序地代表 $0$ 到 $n-1$。输入数据保证 $n$ 个字母分别至少出现一次。

$$\begin{aligned}
 \verb!BADC! \\
+\quad \verb!CBDA! \\[-1em]\underline{\kern{4em}} \\
 \verb!DCCC! \\
\end{aligned}$$

上面的算式是一个4进制的算式。很显然，我们只要让 $\verb!ABCD!$ 分别代表 $0123$，便可以让这个式子成立了。你的任务是，对于给定的 $n$ 进制加法算式，求出 $n$ 个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 10$；
- 对于 $50\%$ 的数据，保证 $n \le 15$；
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 26$。

## 样例 #1

### 输入

```
5
ABCED
BDACE
EBBAA
```

### 输出

```
1 0 3 4 2
```

# AI分析结果



**唯一算法分类**：无算法分类

### 综合分析与结论

该问题的核心是n进制加法竖式的字母替换求解。通过DFS结合剪枝策略高效缩小搜索空间：

1. **关键公式推导**：  
   竖式每列需满足 (a + b + carry) mod n = c，其中carry为进位（0或1）。最高位不能有进位，否则结果位数超过n。

2. **剪枝策略**：  
   - **逐列检查**：从右到左处理每一列，若当前列三个字母已确定但无法满足加法规则，立即剪枝。  
   - **进位预判**：处理当前列时，若后续列无论如何调整都无法满足条件（如进位矛盾），提前终止搜索。  
   - **数值唯一性**：已使用的数值不能被重复分配，通过标记数组快速判断。

3. **实现优化**：  
   - **逆序处理**：优先处理低位字母，尽早确定关键数值，减少后续分支。  
   - **可行性检验**：在分配数值前预判该列是否可能合法，避免无效搜索。

**可视化设计思路**：  
- 使用Canvas绘制竖式，每列高亮当前处理位置。  
- 动态显示字母分配过程，不同颜色标记已确定/待定字母。  
- 步进演示进位传递，用箭头表示进位影响方向。  
- 复古像素风格：8位字体，方格背景，音效提示合法分配或剪枝操作。

---

### 最优思路或技巧提炼

1. **逆向搜索+剪枝**  
   - 从右到左逐列处理，优先处理低位，利用进位传递特性。  
   - 每列合法性检查：若三个字母中有两个已知，第三个必须满足 (a+b+carry) mod n = c。

2. **数值分配优化**  
   - 优先分配高位字母（如最高位不能有进位），大幅减少无效分支。  
   - 预处理字母出现顺序，按出现频率排序，优先处理高频字母。

3. **进位动态管理**  
   - 在递归参数中传递进位值，确保每列计算时包含正确进位。  
   - 最高位单独校验，确保无进位。

---

### 推荐相似题目

1. **P1082 同余方程**  
   - 涉及模运算与方程求解，强化数论思维。

2. **P1217 回文质数**  
   - 综合考察数论与搜索优化，需高效剪枝。

3. **P1379 八数码难题**  
   - 状态空间搜索，剪枝与启发式搜索的经典应用。

---

### 核心代码实现

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int n, num[30], next[30], cnt;
char s1[30], s2[30], s3[30];
bool used[30];

bool Check() {
    int carry = 0;
    for (int i = n - 1; i >= 0; i--) {
        int a = num[s1[i] - 'A'], b = num[s2[i] - 'A'], c = num[s3[i] - 'A'];
        if (a == -1 || b == -1 || c == -1) continue;
        if ((a + b + carry) % n != c) return false;
        carry = (a + b + carry) / n;
    }
    return carry == 0;
}

bool Prune() {
    for (int i = n - 1; i >= 0; i--) {
        int a = num[s1[i] - 'A'], b = num[s2[i] - 'A'], c = num[s3[i] - 'A'];
        if (a == -1 || b == -1 || c == -1) continue;
        if ((a + b) % n != c && (a + b + 1) % n != c) return true;
    }
    return false;
}

void DFS(int depth) {
    if (depth == n) {
        if (Check()) {
            for (int i = 0; i < n; i++) printf("%d ", num[i]);
            exit(0);
        }
        return;
    }
    if (Prune()) return;
    int cur = next[depth];
    for (int i = n - 1; i >= 0; i--) {
        if (!used[i]) {
            used[i] = true;
            num[cur] = i;
            DFS(depth + 1);
            num[cur] = -1;
            used[i] = false;
        }
    }
}

int main() {
    scanf("%d%s%s%s", &n, s1, s2, s3);
    memset(num, -1, sizeof(num));
    // 预处理字母顺序
    for (int i = n - 1; i >= 0; i--) {
        char ch[] = {s1[i], s2[i], s3[i]};
        for (int j = 0; j < 3; j++) {
            int c = ch[j] - 'A';
            if (!used[c]) {
                used[c] = true;
                next[cnt++] = c;
            }
        }
    }
    memset(used, 0, sizeof(used));
    DFS(0);
    return 0;
}
```

**代码说明**：  
- `Check()` 验证当前分配是否满足整个竖式。  
- `Prune()` 剪枝函数，检查当前列是否可能合法。  
- `DFS` 深度优先搜索，按预处理顺序分配数值。  
- 预处理 `next` 数组确定字母处理顺序，优化搜索效率。

---
处理用时：79.50秒
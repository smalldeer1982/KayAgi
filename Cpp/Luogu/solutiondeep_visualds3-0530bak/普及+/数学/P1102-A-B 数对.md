# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果



### 算法分类
**组合数学**

---

### 题解思路与算法要点

#### 核心数学逻辑
题目本质是统计满足 `A-B=C` 的数对数量。通过数学变形 `A = B + C`，将问题转化为**统计每个元素作为B时，数组中存在多少个A = B + C**。核心公式推导：
- 对于每个元素 `B`，满足条件的 `A` 的数量等于数组中 `B + C` 的出现次数
- 总答案等于所有元素的 `B + C` 出现次数之和

#### 解决难点与关键点
1. **高效统计出现次数**：直接暴力枚举会超时（O(n²)）
2. **重复元素处理**：不同位置的相同数值算不同数对
3. **大数据范围**：数值上限达2³⁰，无法用传统数组计数

#### 主要解法对比
| 方法         | 时间复杂度   | 空间复杂度 | 实现难度 | 核心技巧               |
|--------------|--------------|------------|----------|------------------------|
| 哈希表(map)  | O(n)         | O(n)       | ⭐        | 直接统计出现次数       |
| 排序+二分法  | O(n log n)   | O(1)       | ⭐⭐       | upper_bound/lower_bound |
| 双指针       | O(n)         | O(1)       | ⭐⭐⭐      | 单调性维护区间长度     |

---

### 高星题解推荐 (≥4★)

1. **OsvaldoAsensioLopez（赞789）**
   - **评分**: ⭐⭐⭐⭐
   - **亮点**: 
     - 将问题转换为 `A-C=B`，利用STL map统计次数
     - 代码简洁（仅10行核心逻辑）
     - 时间复杂度最优（O(n)）
   - **代码片段**：
     ```cpp
     map<LL,LL> m;
     for(int i=1;i<=n;i++) m[a[i]]++, a[i]-=c; 
     for(int i=1;i<=n;i++) ans += m[a[i]];
     ```

2. **樱花飞舞（赞536）**
   - **评分**: ⭐⭐⭐⭐
   - **亮点**:
     - 使用STL二分函数精确计算重复元素数量
     - 清晰演示 `upper_bound - lower_bound` 技巧
   - **核心公式**：
     ```cpp
     ans += upper_bound(...) - lower_bound(...);
     ```

3. **jins3599（赞460）**
   - **评分**: ⭐⭐⭐⭐
   - **亮点**:
     - 双指针维护单调区间
     - 时间复杂度O(n)且无需额外空间
   - **关键操作**：
     ```cpp
     while(r1 <=n && a[r1]-a[l]<=c) r1++;
     while(r2 <=n && a[r2]-a[l]<c)  r2++;
     ans += r1 - r2;
     ```

---

### 最优思路提炼
1. **哈希映射法**
   - **核心公式**：`ans = Σ count[B] * count[B+C]`
   - **实现步骤**：
     1. 遍历数组统计每个数的出现次数（map/unordered_map）
     2. 再次遍历数组，累加 `当前数+C` 的出现次数
   - **优势**：线性时间复杂度，代码极简

2. **双指针法优化**
   - **关键推导**：排序后满足 `a[r] - a[l] = C` 的区间必然连续
   - **操作流程**：
     ```
     排序数组 → 维护左右指针 → 计算区间长度 → 乘积累加
     ```

---

### 同类型题目推荐
1. [P1102 A-B数对](https://www.luogu.com.cn/problem/P1102)（本题）
2. [P1638 逛画展](https://www.luogu.com.cn/problem/P1638)（双指针经典）
3. [P1496 火烧赤壁](https://www.luogu.com.cn/problem/P1496)（区间统计）

---

### 可视化算法演示（像素风格）

#### 核心运算流程
```javascript
// 伪代码演示哈希表法
const canvas = initCanvas(); // 初始化8位像素画布
const pixels = [];
let ans = 0;

// 步骤1：构建哈希表
arr.forEach(num => {
  drawPixel(num, 0xFF0000); // 红色标记当前处理元素
  hashMap[num] = (hashMap[num] || 0) + 1;
  playSound('beep1'); // 8-bit音效
});

// 步骤2：计算结果
arr.forEach(num => {
  const target = num + C;
  drawPixel(num, 0x00FF00); // 绿色标记当前元素
  drawLine(num, target);    // 画线连接B与A
  ans += hashMap[target] || 0;
  playSound('beep2');
});

// 最终效果
drawText(`Answer: ${ans}`, 8, 8, 0xFFFFFF);
```

#### 交互功能
- **步进控制**：空格键单步执行
- **速度调节**：方向键调整动画速度
- **音效开关**：BGM可选《超级玛丽》风格背景音乐

---

### 关键代码实现（哈希表法）
```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

typedef long long LL;
LL a[200001];

int main() {
    int n; LL c, ans = 0;
    unordered_map<LL, LL> cnt;
    
    cin >> n >> c;
    for(int i=0; i<n; ++i) {
        cin >> a[i];
        cnt[a[i]]++;
    }
    
    for(int i=0; i<n; ++i) 
        ans += cnt[a[i] + c];
    
    cout << ans;
    return 0;
}
```

---
处理用时：76.15秒
# 题目信息

# [ZJOI2007] 矩阵游戏

## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。


## 样例 #1

### 输入

```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0
```

### 输出

```
No
Yes
```

# AI分析结果



**算法分类**：组合数学（二分图匹配）

---

### **题解思路与解决难点**
1. **核心模型转换**  
   将矩阵中的每个黑格子视为行与列之间的边，构建二分图：左部节点为行号，右部节点为列号。若矩阵中 (i,j) 为黑色，则添加边 i→j。

2. **关键性质**  
   - 行交换与列交换不影响二分图的匹配结构，因为交换行/列仅改变节点编号，不改变边的关系。  
   - 目标转换为求二分图的**最大匹配是否等于n**。若存在完美匹配，则可通过调整行列使得每行匹配到对应的列，主对角线全黑。

3. **算法选择**  
   - **匈牙利算法**：时间复杂度 O(n³)，适用于 n≤200。  
   - **Dinic网络流**：将行和列分别连接源点和汇点，边容量为1，求最大流是否为n，效率更高但实现稍复杂。

---

### **题解评分（≥4星）**
1. **俾斯麦的题解（5星）**  
   - 详细分析二分图模型转换，配图辅助理解，提供匈牙利和Dinic两种解法代码，注释清晰。  
   - 代码优化：避免全数组清零，提升效率。

2. **hs_black的题解（4星）**  
   - 简洁代码实现匈牙利算法，核心逻辑明确，适合快速理解模型转换。  
   - 附关键注释：“交换行列不影响最大匹配数”，直击核心难点。

3. **Night_Aurora的题解（4星）**  
   - 从匹配角度解释交换操作的本质，强调“匹配数不变”的关键性质，逻辑清晰。  
   - 网络流解法思路完整，但代码实现较简略。

---

### **最优思路提炼**
1. **二分图建模**  
   将每行视为左部节点，每列视为右部节点，黑格子为边，问题转化为求完美匹配。

2. **交换操作的等价性**  
   交换行或列仅改变节点编号，不改变匹配结构，因此只需判断初始图是否存在n的匹配。

3. **匈牙利算法实现要点**  
   - 对每行执行DFS寻找增广路，统计总匹配数。  
   - 使用时间戳替代memset优化访问标记，提升效率。

---

### **同类型题目推荐**
1. [P1963 变换序列](https://www.luogu.com.cn/problem/P1963)  
   二分图匹配求字典序最小解，需反向匹配。

2. [P2764 最小路径覆盖问题](https://www.luogu.com.cn/problem/P2764)  
   二分图模型求DAG的最小路径覆盖。

3. [P3386 二分图最大匹配](https://www.luogu.com.cn/problem/P3386)  
   模板题，练习匈牙利或Dinic实现。

---

### **代码实现（匈牙利算法）**
```cpp
#include <cstdio>
#include <cstring>
#include <vector>
using namespace std;
const int N = 205;

int n, match[N];
bool vis[N];
vector<int> g[N];

bool dfs(int u) {
    for (int v : g[u]) 
        if (!vis[v]) {
            vis[v] = true;
            if (!match[v] || dfs(match[v])) {
                match[v] = u;
                return true;
            }
        }
    return false;
}

bool check() {
    memset(match, 0, sizeof match);
    for (int i = 1; i <= n; ++i) {
        memset(vis, 0, sizeof vis);
        if (!dfs(i)) return false;
    }
    return true;
}

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i) {
            g[i].clear();
            for (int j = 1; j <= n; ++j) {
                int x; scanf("%d", &x);
                if (x) g[i].push_back(j);
            }
        }
        puts(check() ? "Yes" : "No");
    }
    return 0;
}
```

---

### **可视化设计（像素风格演示）**
1. **动画流程**  
   - **步骤1**：绘制n×n网格，黑色格子高亮显示。  
   - **步骤2**：左侧列出行节点，右侧列出列节点，黑格子对应连边。  
   - **步骤3**：动态显示匈牙利算法的DFS过程，当前搜索行用红色标记，尝试边闪烁蓝色，匹配成功边变绿色。

2. **交互功能**  
   - **速度调节**：滑动条控制DFS步骤间隔（100ms~1s）。  
   - **音效**：匹配成功时播放8-bit音效，失败时低沉音。

3. **复古风格**  
   - **颜色方案**：使用FC游戏机的16色调色板，节点用黄色，边用青色，匹配边绿色。  
   - **Canvas绘制**：每个步骤更新后，用像素块刷新界面，模拟经典游戏效果。

---

**总结**：通过组合数学中的二分图模型，将行列交换问题转化为匹配问题，结合匈牙利算法高效解决。可视化设计通过像素动画直观展示匹配过程，增强理解。

---
处理用时：64.60秒
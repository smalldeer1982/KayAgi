# 题目信息

# 排队接水

## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。


## 说明/提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。


## 样例 #1

### 输入

```
10 
56 12 1 99 1000 234 33 55 99 812```

### 输出

```
3 2 7 8 1 4 9 6 10 5
291.90
```

# AI分析结果



## 算法分类
贪心算法

## 题解分析与结论
### 核心算法流程
1. **贪心策略**：将接水时间短的人优先排列，通过数学证明相邻两人交换位置可减少总等待时间
2. **数据结构**：
   - 结构体（时间+编号）
   - pair（时间作为first元素）
   - 数值编码法（时间×1001 + 编号）
3. **关键公式**：总等待时间 = Σ(t_i × (n-i))，其中i为排序后的顺序位

### 可视化设计要点
1. **像素动画**：
   - 使用16色像素块表示不同接水时间（红色=最久，绿色=最短）
   - 排序过程展示数值交换动画，带8-bit音效
   - 等待时间累加显示为金币收集动画，每步显示当前贡献值

2. **交互控制**：
   ```javascript
   class Animation {
     constructor(times) {
       this.queue = times.map((t,i) => ({t, id: i+1}));
       this.steps = [];
     }
     
     // 生成冒泡排序动画帧
     generateFrames() {
       for(let i=0; i<this.queue.length-1; i++) {
         for(let j=0; j<queue.length-i-1; j++) {
           this.steps.push({type: 'compare', a:j, b:j+1});
           if(this.queue[j].t > this.queue[j+1].t) {
             this.steps.push({type: 'swap', a:j, b:j+1});
             [this.queue[j], this.queue[j+1]] = [this.queue[j+1], this.queue[j]];
           }
         }
       }
     }
   }
   ```

### 最优题解推荐（≥4星）
1. **f112358（5星）**
   - 亮点：独创数值编码法，时间×1001+编号实现快速排序
   - 代码片段：
     ```cpp
     t[i] = x * 1001 + i; // 编码
     cout << t[j]%1001;   // 解码
     ```

2. **Anguei（4.5星）**
   - 亮点：STL pair的巧妙应用，代码简洁高效
   - 关键代码：
     ```cpp
     std::pair<int, int> a[n];
     sort(a, a+n); // 利用pair默认排序
     ```

3. **BlueArc（4星）**
   - 亮点：经典结构体解法，公式推导清晰
   - 核心逻辑：
     ```cpp
     time += a[i].b * j; // j为剩余等待人数
     ```

## 同类型题目推荐
1. P1090 合并果子（贪心+优先队列）
2. P1803 凌乱的yyy（活动选择问题）
3. P2240 部分背包问题（分数背包贪心）

## 关键技巧总结
1. **序号处理技巧**：通过数学运算将编号嵌入排序键值（时间×M + id，M>max_id）
2. **等待时间计算**：总时间 = t₁×(n-1) + t₂×(n-2) + ... + tₙ₋₁×1
3. **稳定性处理**：当时间相同时按原始顺序排列（结构体保留原编号）

## 复古游戏化设计
1. **音效设计**：
   - 正确排序："NES音效库"中选取8-bit上升音阶
   - 错误操作：经典FC错误音效（0xEB长鸣）
2. **积分系统**：
   ```javascript
   class GameScore {
     constructor() {
       this.combo = 0;  // 连击数
       this.bestTime = Infinity; // 最短用时
     }
     
     addCombo() {
       this.combo = Math.min(this.combo+1, 5);
       playSound(`combo_${this.combo}`);
     }
   }
   ```

---
处理用时：54.09秒
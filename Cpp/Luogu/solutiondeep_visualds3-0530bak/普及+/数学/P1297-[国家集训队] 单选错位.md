# 题目信息

# [国家集训队] 单选错位

## 题目描述

gx 和 lc 去参加 noip 初赛，其中有一种题型叫单项选择题，顾名思义，只有一个选项是正确答案。

试卷上共有 $n$ 道单选题，第 $i$ 道单选题有 $a_i$ 个选项，这 $a_i$ 个选项编号是 $1,2,3,\ldots,a_i$，每个选项成为正确答案的概率都是相等的。

lc 采取的策略是每道题目随机写上 $1 \sim a_i$ 的某个数作为答案选项，他用不了多少时间就能期望做对 $\sum_{i=1}^n \frac{1}{a_i}$ 道题目。gx 则是认认真真地做完了这 $n$ 道题目，可是等他做完的时候时间也所剩无几了，于是他匆忙地把答案抄到答题纸上，没想到抄错位了：第 $i$ 道题目的答案抄到了答题纸上的第 $i+1$ 道题目的位置上，特别地，第 $n$ 道题目的答案抄到了第 $1$ 道题目的位置上。

现在 gx 已经走出考场没法改了，不过他还是想知道自己期望能做对几道题目，这样他就知道会不会被 lc 鄙视了。

我们假设 gx 没有做错任何题目，只是答案抄错位置了。


## 说明/提示

【样例说明】

| 正确答案   |   gx的答案    | 做对题目 | 出现概率 |
| :----------: | :----------: |:----------: | :----------: |
| $\{1,1,1\}$  |    $\{1,1,1\}$    |    $3$    |    $\frac16$ |
| $\{1,2,1\}$    |   $ \{1,1,2\}$   |    $1$    |    $\frac16$ |
|$\{1,3,1\}$    |   $ \{1,1,3\} $   |    $1$    |    $\frac16$ |
|$\{2,1,1\}$    |   $ \{1,2,1\} $   |    $1$    |    $\frac16$|
|$\{2,2,1\}$    |   $ \{1,2,2\}$    |    $1$    |    $\frac16$ |
|$\{2,3,1\}$    |    $\{1,2,3\} $   |    $0$    |    $\frac16$ |




$a = \{2,3,1\}$。

共有 $6$ 种情况，每种情况出现的概率是 $\frac{1}{6}$，gx 期望做对 $\frac{3+1+1+1+1+0}6 = \frac76$ 题。（相比之下，lc 随机就能期望做对 $\frac{11}6$ 题）



对于 $30\%$ 的数据，$n\leq 10, C\leq 10$。

对于 $80\%$ 的数据，$n\leq 10^4, C\leq 10$。

对于 $90\%$ 的数据，$n\leq 5\times 10^5, C\leq 10^8$。

对于 $100\%$ 的数据，$2\leq n\leq 10^7, 0\leq A,B,C \leq 10^8$，$1 \leq a_i \leq 10^8$。


## 样例 #1

### 输入

```
3 2 0 4 1```

### 输出

```
1.167
```

# AI分析结果



---

### 唯一算法分类  
**组合数学**

---

### 综合分析与结论  

#### 核心思路与难点  
题目本质是**概率期望的线性叠加**问题，关键难点在于：  
1. 发现相邻两题的错位关系是独立事件，可以拆解为每一题的期望贡献  
2. 推导出统一公式：$\text{正确概率} = \frac{1}{\max(a_i, a_{i+1})}$  
3. 处理环形错位（第n题答案抄到第1题）

#### 关键公式推导  
**三种情况统一为1/max(a,b)的证明**：  
- **a = b**：共有a种匹配情况，总可能性a²，概率1/a  
- **a > b**：有效匹配范围缩小至b，概率 $\frac{b}{a} \cdot \frac{1}{b} = \frac{1}{a}$  
- **a < b**：正确答案必须落在前a项，概率 $\frac{a}{b} \cdot \frac{1}{a} = \frac{1}{b}$  

#### 可视化设计思路  
1. **环形链表动画**：将题目排列成环形，用箭头表示错位方向  
2. **分步高亮**：  
   - 红框标记当前处理的题目对(i, i+1)  
   - 显示当前max(a_i, a_j)值与累加结果  
   - 每一步展示 $\frac{1}{\max(a,b)}$ 的计算过程  
3. **像素风格控制面板**：  
   - 复古8-bit字体显示累加结果  
   - 按钮控制单步执行/自动播放  
   - 音效：正确匹配时播放"叮"声，累加时播放金币音效  

---

### 题解清单（≥4星）

#### 1. stoorz（★★★★★）  
**亮点**：  
- 分类讨论三种情况，逻辑清晰  
- 代码简洁高效，直接生成数据后循环累加  
```cpp
for (int i=1;i<=n;i++)
    ans+=1/(double)max(a[i],a[i+1]);
```

#### 2. stdlifg（★★★★☆）  
**亮点**：  
- 公式化简过程详细，数学推导更深入  
- 提供两种等价思路的对比  
```cpp
ans+=1.0/(db)max(a[1],a[n]);
for(int i=2; i<=n; ++i) 
    ans+=1.0/(db)max(a[i],a[i-1]);
```

#### 3. codecode（★★★★☆）  
**亮点**：  
- 严格按数学定义推导古典概率  
- 使用模运算处理环形结构  
```cpp
a[0] = a[n]; // 环形处理
for(int i=1;i<=n;i++)
    ans += 1.0/max(a[i-1],a[i]);
```

---

### 最优思路提炼  
**核心技巧**：  
1. **期望线性性**：总期望=各独立事件期望之和  
2. **极值统一**：通过max(a,b)合并三种分类讨论  
3. **环形处理**：a[n+1]=a[1] 实现无缝衔接  

**代码优化点**：  
- 生成数据时直接取模运算，避免中间变量  
- 使用double累加而非每次转换类型  

---

### 同类型题目推荐  
1. P1654（期望线性性）  
2. P1365（几何分布期望）  
3. P6155（错位排列加强版）

---

### 可视化代码片段（复古风格）  
```javascript
// Canvas绘制核心逻辑
function drawStep(i) {
  ctx.fillStyle = "#8B0000"; // 深红底色
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // 绘制环形题目
  questions.forEach((q, idx) => {
    if(idx === currentPair) { // 高亮当前对
      ctx.fillStyle = "#FFD700"; // 金色
      drawArrow(q.x, q.y, nextQ.x, nextQ.y); 
    }
    drawPixelBox(q.x, q.y, q.value); 
  });

  // 显示公式
  ctx.fillStyle = "#00FF00";
  ctx.fillText(`1/${maxVal}`, formulaX, formulaY);
  playSound('step'); // 播放8-bit音效
}
```

---

### 知识迁移建议  
当遇到以下特征时，可考虑类似解法：  
1. **独立事件期望叠加**：总结果可分解为多个独立贡献  
2. **极值简化分类**：不同情况可通过max/min统一处理  
3. **环形结构**：通过模运算或首尾相接处理循环关系  

---

### 个人心得摘录  
> "最开始以为要处理复杂的排列组合，后来发现期望的线性性质直接拆解为独立概率求和，顿时豁然开朗。调试时发现忘记处理环形结构导致WA，加上a[n+1]=a[1]后AC，细节决定成败！" —— stoorz

---

### 动画演示截图示意  
![图示](https://via.placeholder.com/600x400/000000/FFFFFF?text=8-bit+动画示例：红框标记当前题对，金色箭头指示错位方向，下方显示累加公式)  
（实际实现时需用Canvas绘制像素化题目和动态箭头）

---
处理用时：66.33秒
# 题目信息

# 数列

## 题目描述

有这样一种数列 $a_1, a_2, \cdots a_n$，其中 $a_{1}=0$，且对任意一项 $a_{i}$ 满足 $|a_{i}-a_{i+1}|=1$（$1\le i<n$）。设 $s=\sum_{i = 1}^n a_i = a_{1}+a_{2}+ \cdots +a_{n}$，表示前 $n$ 项之和。

现在给出数列长度 $n$ 与数列前 $n$ 项之和 $s$，要求：

输出满足条件的数列的总数对 $2^{64}$ 取模后的结果。

输出满足条件的 $100$ 个数列（如果不满 $100$ 个就全部输出）。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 100$，$-2^{63} \leq s \lt 2^{63}$。

#### 说明

spj provider：@[xiaolilsq](user/230249)。

## 样例 #1

### 输入

```
4 0
```

### 输出

```
2
0 -1 0 1
0 1 0 -1
```

# AI分析结果



---

**唯一算法分类**  
组合数学

---

### 综合分析与结论  
#### 核心思路  
将每个位置的步长变化视为±1的选择，总和变化可转化为组合数学问题：  
1. 最大理论值 `S_max = n(n-1)/2`  
2. 每个-1选择会使总和减少 `2*(n-i)`（i为当前操作位）  
3. 问题等价于用若干 `(n-i)` 的权重凑出目标值 `k = (S_max - s)/2`  
4. 转化为整数划分问题，使用背包DP计算方案数  

#### 关键公式推导  
$$ s = \frac{n(n-1)}{2} - 2\sum_{i=1}^{n-1} (n-i) \cdot x_i $$  
其中 `x_i ∈ {0,1}` 表示是否在第i位选择-1。化简得：  
$$ \sum_{i=1}^{n-1} (n-i) \cdot x_i = \frac{n(n-1)-2s}{4} = k $$  

#### 解决难点  
- 奇偶性判断：`n(n-1)-2s` 必须为偶数  
- 动态规划状态设计：`dp[i][j]` 表示前i个权重凑出j的方案数  
- 方案生成剪枝：DFS回溯时提前终止无效分支  

---

### 题解评分 (≥4星)  
#### 1. SunnyYuan（5星）  
- **亮点**：完整数学推导 + 状态压缩DP + DFS剪枝输出  
- **代码优化**：使用 `unsigned long long` 自动取模  
- **关键代码**：  
```cpp  
for(int i = 2; i <= n; i++){  
    int x = (n - i + 1);  
    memcpy(f[i], f[i-1], sizeof(f[i]));  
    for(int j = x; j < M; j++)  
        f[i][j] += f[i-1][j - x];  
}  
```

#### 2. Remilia1023（4.5星）  
- **亮点**：正反双向DP + 滚动数组优化  
- **创新点**：使用 `bitset` 记录可达状态，避免无效转移  
- **关键代码**：  
```cpp  
for(int j = st - boun; j <= st + boun; j++)  
    if(exi[i][j]){  
        exi[i+1][j+n-i] = exi[i+1][j-n+i] = 1;  
        dp[o^1][j+n-i] += dp[o][j];  
        dp[o^1][j-n+i] += dp[o][j];  
    }  
```

#### 3. Walter_Fang（4星）  
- **亮点**：极简背包实现 + 快速剪枝  
- **代码简洁性**：仅30行核心逻辑，DFS与DP分离  
- **关键公式**：  
```cpp  
k = (n*(n-1)/2 - s)/2;  
for(int i=1; i<n; i++)  
    for(int j=k; j>=i; j--)  
        dp[j] += dp[j-i];  
```

---

### 最优思路与技巧提炼  
1. **权重转换**：将位置i的影响量化为 `n-i`  
2. **奇偶剪枝**：提前排除 `k` 非整数的无解情况  
3. **滚动背包**：用一维数组倒序遍历实现空间优化  
4. **回溯剪枝**：生成方案时优先探索-1分支（权重更大）  

---

### 同类型题推荐  
1. **P1164 小A点菜**（01背包方案数）  
2. **P1048 采药**（经典01背包）  
3. **P1832 A+B Problem（再升级）**（质数组合背包）  

---

### 可视化与算法演示设计  
#### 像素化动画方案  
```javascript  
// 核心演示逻辑（伪代码）  
class PixelSolver {  
  constructor(n, s) {  
    this.weights = Array.from({length: n-1}, (_,i) => n-i-1);  
    this.target = (n*(n-1)/2 - s)/2;  
    this.dp = new Array(this.target+1).fill(0);  
    this.dp[0] = 1;  
    this.currentStep = 0;  
  }

  nextFrame() {  
    if (this.currentStep >= this.weights.length) return;  
    const w = this.weights[this.currentStep];  
    for (let j = this.target; j >= w; j--) {  
      if (this.dp[j - w] > 0) {  
        this.dp[j] += this.dp[j - w];  
        highlightCell(j);  // 高亮更新位置  
        playSound('click');  
      }  
    }  
    this.currentStep++;  
  }  
}  
```  
- **颜色标记**：  
  - 红色：当前处理的权重  
  - 绿色：DP数组中被更新的位置  
- **音效**：  
  - 点击声：每次权重处理  
  - 完成声：到达目标值  

---

### 个人心得摘录  
> "调试时发现DFS必须先探索-1分支，否则会漏掉大权重组合。回溯时若先处理+1分支，剪枝效率大幅下降。" —— SunyYuan题解评论  

---

### 代码实现（核心DP部分）  
```cpp  
// 计算方案数（SunnyYuan版）  
ull dp[M] = {0};  
dp[0] = 1;  
for (int i = 1; i < n; i++) {  
    int w = n - i;  
    for (int j = k; j >= w; j--) {  
        dp[j] += dp[j - w];  
    }  
}  
cout << dp[k] << endl;  
```

---
处理用时：68.97秒
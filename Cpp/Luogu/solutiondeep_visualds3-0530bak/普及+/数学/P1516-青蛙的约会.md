# 题目信息

# 青蛙的约会

## 题目描述

两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。

我们把这两只青蛙分别叫做青蛙 A 和青蛙 B，并且规定纬度线上东经 $0$ 度处为原点，由东往西为正方向，单位长度 $1$ 米，这样我们就得到了一条首尾相接的数轴。设青蛙 A 的出发点坐标是 $x$，青蛙 B 的出发点坐标是 $y$。青蛙 A 一次能跳 $m$ 米，青蛙 B 一次能跳 $n$ 米，两只青蛙跳一次所花费的时间相同。纬度线总长 $L$ 米。现在要你求出它们跳了几次以后才会碰面。


## 说明/提示

对于 $100\%$ 的数据，$1 \le x \ne y \le 2 \times 10^{9}$，$1 \le m, n \le 2 \times 10^{9}$，$1 \le L \le 2.1 \times 10^{9}$。


## 样例 #1

### 输入

```
1 2 3 4 5
```

### 输出

```
4
```

# AI分析结果



# 数论

### 题解思路与算法要点
1. **核心数学模型**  
   所有题解均将问题转化为解线性同余方程 `(m-n)k ≡ y-x (mod L)`，最终转换为扩展欧几里得算法求解 `(n-m)k + Lz = x-y`。  
   **关键推导步骤**：  
   - 方程变形：`x + km ≡ y + kn (mod L)` → `k(m-n) ≡ y-x (mod L)`  
   - 负号处理：若 `m < n`，需交换青蛙参数并取反，确保系数非负  
   - 最小解调整：用 `(x*(a/gcd) % (L/gcd) + (L/gcd)) % (L/gcd)` 保证解为正整数  

2. **解决难点对比**  
   | 题解作者         | 核心优化/差异点                                                                 |  
   |------------------|---------------------------------------------------------------------------------|  
   | 皎月半洒花       | 详细推导方程转化过程，引入变量 `S=x-y, W=n-m` 简化表达式，强调模运算中负数处理 |  
   | FlashHu          | 明确处理系数为负数的情况，提出 `ax+by=c` 的最小非负解公式 `(x%(b/g)+b/g)%(b/g)` |  
   | QSWei            | 将方程改写为 `kB - lz = -A`，通过调整参数符号避免混淆，代码简洁易读           |  

3. **关键数学证明**  
   - **同余方程有解条件**：`gcd(n-m, L) | (x-y)`，否则无解  
   - **通解形式**：若特解为 `k0`，所有解为 `k = k0 + t*(L/gcd)`（`t` 为整数）  
   - **最小正整数解**：通过模运算将解调整到 `[0, L/gcd)` 区间  

---

### 题解评分（≥4星）
1. **皎月半洒花（5星）**  
   - **亮点**：详细公式推导与模运算证明，代码注释清晰  
   - **代码片段**：  
     ```cpp  
     exgcd(b, l, x1, y1);  
     if (a % ans != 0) cout << "Impossible";  
     else cout << ((x1*(a/ans)) % (l/ans) + (l/ans)) % (l/ans);  
     ```  
   - **可视化设计**：高亮 `exgcd` 递归过程，用红色标记参数交换步骤  

2. **FlashHu（4.5星）**  
   - **亮点**：处理系数负数时 `a=-a, c=-c`，代码简洁高效  
   - **个人心得**：“虽然是裸的 exgcd 题，但容易被细节坑到”  
   - **代码片段**：  
     ```cpp  
     if (a < 0) { a = -a; c = -c; }  
     exgcd(a, b, x, y);  
     printf("%lld\n", (c/g*x % (b/g) + b/g) % (b/g));  
     ```  

3. **aiyougege（4星）**  
   - **亮点**：引入 `d = gcd(m-n, L)` 分解方程，强调解的周期性  
   - **可视化设计**：用绿色标记 `d` 的计算过程，展示通解调整  

---

### 最优思路与技巧提炼
1. **核心公式推导**  
   - 将环形相遇问题转化为线性同余方程是关键，需注意模运算中的符号处理  
   - 扩展欧几里得求特解后，通过 `k = (k0 % mod + mod) % mod` 调整最小解  

2. **代码实现技巧**  
   - **负数处理**：若 `n < m`，交换青蛙参数并取反，统一系数为正数  
   - **无解判定**：直接检查 `(x-y) % gcd(n-m, L) != 0`  

3. **同类型题拓展**  
   - **常见题型**：线性同余方程、模运算应用、环形相遇问题  
   - **通用套路**：  
     ```text  
     1. 将问题转化为 ax ≡ b (mod m)  
     2. 用扩展欧几里得算法求 gcd(a,m)  
     3. 若无解则终止，否则调整解至最小正整数  
     ```  

---

### 推荐类似题目
1. **P1082 [NOIP2012 提高组] 同余方程**  
   - 求解 `ax ≡ 1 (mod b)` 的最小正整数解  

2. **P5656 【模板】二元一次不定方程 (exgcd)**  
   - 扩展欧几里得算法的全面练习  

3. **P2054 [AHOI2005] 洗牌**  
   - 环形排列与模运算结合，需推导置换公式  

---

### 复古像素风可视化设计
1. **动画演示流程**  
   - **Step 1**（黄色高亮）：展示方程 `x + km ≡ y + kn (mod L)`  
   - **Step 2**（红色标记）：变形为 `(n-m)k + Lz = x-y`，计算 `gcd(n-m, L)`  
   - **Step 3**（绿色闪烁）：递归展开 `exgcd`，动态绘制辗转相除过程  
   - **Step 4**（蓝色框选）：调整解至 `[0, L/gcd)` 区间，播放“通关”音效  

2. **交互功能**  
   - **速度调节**：拖动滑块控制动画速度（0.5x~2x）  
   - **音效触发**：  
     - 错误时播放 8-bit 短促“失败”音效（无解场景）  
     - 正确解播放上升音调，配合像素烟花特效  

3. **代码片段（Canvas 绘制）**  
   ```javascript  
   function drawStep(ctx, step, x, y) {  
     ctx.fillStyle = "#FF0000"; // 红色标记当前操作  
     ctx.fillRect(x*30, y*30, 30, 30);  
     // 播放音效  
     if (step === "gcd") playSound("beep1");  
   }  
   ```  

---

### 核心代码实现
**扩展欧几里得算法与解调整**  
```cpp  
#include <iostream>  
using namespace std;  
typedef long long ll;  

ll exgcd(ll a, ll b, ll &x, ll &y) {  
    if (!b) { x = 1; y = 0; return a; }  
    ll d = exgcd(b, a % b, y, x);  
    y -= a / b * x;  
    return d;  
}  

int main() {  
    ll x, y, m, n, L;  
    cin >> x >> y >> m >> n >> L;  
    ll a = n - m, b = L, c = x - y;  
    if (a < 0) { a = -a; c = -c; } // 处理负数  
    ll x0, y0, d = exgcd(a, b, x0, y0);  
    if (c % d) cout << "Impossible";  
    else {  
        ll mod = b / d;  
        cout << (x0 * (c/d) % mod + mod) % mod;  
    }  
    return 0;  
}  
```

---
处理用时：76.62秒
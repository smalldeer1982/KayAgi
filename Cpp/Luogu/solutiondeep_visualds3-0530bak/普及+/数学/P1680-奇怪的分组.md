# 题目信息

# 奇怪的分组

## 题目背景

终于解出了 dm 同学的难题，dm 同学同意帮 v 神联络。可 dm 同学有个习惯，就是联络同学的时候喜欢分组联络，而且分组的方式也很特别，要求第 $i$ 组的的人数必须大于他指定的个数 $C_i$。在 dm 同学联络的时候，v 神在想，按照 dm 同学的规则一共可以有多少种方案呢？他想啊想，终于……没想出来。于是他又想到了聪明的你，你能帮 v 神算出按照 dm 同学的规则有多少种分组方案吗？


## 题目描述

v 神的班级共有 $N$ 个人，dm 同学想把同学分成 $M$ 组联络，要求第 $i$ 组的人数必须大于给定的正整数 $C_i$，求有多少不同的方案（两个是相同的方案当且仅当对于任意的一队 $i$，两个方案的第 $i$组同学数量相等）。由于结果很大，所以你只需要输出模 $10^9+7$ 的值。


## 说明/提示

### 样例解释

方案有三种，每组的个数分别是 $(3,3,4)$，$(2,4,4)$，$(2,3,5)$。

### 数据范围约定

对于 $30\%$ 的数据，$N,M\le 10$。

对于 $60\%$ 的数据，$N,M\le 1000$。

对于 $100\%$ 的数据，$1\le N ,M\le 10^6$，$1\le C_i\le 1000$。

数据保证至少有一个方案。


## 样例 #1

### 输入

```
10 3

1

2

3

```

### 输出

```
3```

# AI分析结果



**唯一算法分类**：组合数学

### 题解思路、算法要点与解决难点

#### 核心数学推导
题目要求将 $N$ 人分成 $M$ 组，每组人数必须严格大于 $C_i$。通过以下步骤转化为组合数学问题：
1. **预处理约束**：每组至少分配 $C_i+1$ 人，总需 $S = \sum (C_i+1) = \sum C_i + M$ 人。
2. **剩余人数计算**：总人数 $N$ 减去 $S$，得到剩余可自由分配的人数 $K = N - \sum C_i - M$。
3. **隔板法应用**：将 $K$ 人分配到 $M$ 组（允许空组），转化为组合数问题，答案为 $C(K+M-1, M-1)$。

#### 组合数计算优化
1. **阶乘预处理**：预处理 $1$ 到 $10^6$ 的阶乘及其逆元，实现 $O(1)$ 查询组合数。
2. **逆元计算**：利用费马小定理，通过快速幂求逆元，将除法转化为乘法。

#### 解决难点
- **模型转换**：正确理解“严格大于”转化为“至少分配 $C_i+1$”，并处理剩余人数的分配。
- **大数运算**：处理大数组合数时，需高效计算模 $10^9+7$ 下的值，避免溢出。

### 题解评分（≥4星）

1. **hongzy的题解（5星）**
   - **亮点**：预处理阶乘和逆元，代码高效清晰，快速读入优化。
   - **代码片段**：
     ```cpp
     LL Qpow(LL a, LL b) { // 快速幂求逆元
         LL ans = 1;
         for(; b; b>>=1, a=a*a%MOD)
             if(b & 1) ans = ans*a % MOD;
         return ans;
     }
     int C(int n, int k) { // 组合数计算
         LL fm = (1LL * fc[n-k] * fc[k]) % MOD;
         return 1LL * fc[n] * Qpow(fm, MOD-2) % MOD;
     }
     ```

2. **KAMIYA_KINA的题解（4星）**
   - **亮点**：详细解释球盒模型与组合数推导，代码可读性强。
   - **心得摘录**：通过网格图类比组合数，直观展示隔板法的几何意义。

3. **rickyxrc的题解（4星）**
   - **亮点**：代码简洁，边界条件处理明确，强调数据保证有解。
   - **代码片段**：
     ```cpp
     i64 C(i64 n,i64 m){
         return jcs[n] * inv[m] % mod * inv[n-m] % mod;
     }
     ```

### 最优思路提炼
1. **模型转换**：将原问题转化为剩余人数的自由分配问题。
2. **组合数优化**：预处理阶乘和逆元，快速计算大数组合模值。
3. **快速幂应用**：利用费马小定理求逆元，避免直接除法。

### 同类型题与算法套路
- **常见套路**：涉及“至少分配”的计数问题，通常转化为隔板法或容斥原理。
- **类似题目**：  
  - [P2480 [SDOI2010] 古代猪文](https://www.luogu.com.cn/problem/P2480)（组合数+Lucas定理）
  - [P3197 [HNOI2008] 越狱](https://www.luogu.com.cn/problem/P3197)（快速幂+容斥）
  - [P1313 计算系数](https://www.luogu.com.cn/problem/P1313)（二项式定理+快速幂）

### 可视化与算法演示
**动画方案**：
1. **初始状态**：显示总人数 $N$ 和每组约束 $C_i$。
2. **预处理步骤**：高亮减去 $C_i+1$ 的过程，显示剩余人数 $K$。
3. **隔板法演示**：动态展示将 $K$ 个球放入 $M$ 个盒子的过程，用隔板分割。
4. **组合数计算**：逐步显示阶乘、逆元计算步骤，最终结果高亮。

**复古像素风格**：
- **颜色方案**：使用8位色调色板，隔板为绿色，球为黄色。
- **音效**：计算完成时播放“滴”声，错误时“哔”声。

### 代码实现（核心逻辑）
```cpp
#include <iostream>
using namespace std;
typedef long long LL;
const int MOD = 1e9+7;
const int MAXN = 1e6+10;

LL fc[MAXN]; // 阶乘数组

LL qpow(LL a, LL b) { // 快速幂
    LL res = 1;
    for (; b; b >>= 1, a = a*a % MOD)
        if (b & 1) res = res*a % MOD;
    return res;
}

void init() { // 预处理阶乘
    fc[0] = 1;
    for (int i=1; i<MAXN; i++)
        fc[i] = fc[i-1] * i % MOD;
}

LL comb(int n, int k) { // 计算C(n,k)
    if (n < k) return 0;
    LL inv = qpow(fc[k] * fc[n-k] % MOD, MOD-2);
    return fc[n] * inv % MOD;
}

int main() {
    init();
    int n, m;
    cin >> n >> m;
    for (int i=0; i<m; i++) {
        int c; cin >> c;
        n -= c; // 减去C_i
    }
    n -= m; // 转化为剩余K = n - sum(C_i) - m
    cout << comb(n-1, m-1);
    return 0;
}
```

---
处理用时：157.21秒
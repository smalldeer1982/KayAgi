# 题目信息

# 角色属性树

## 题目描述

绪萌同人社是一个有趣的组织，该组织结构是一个树形结构。有一个社长，直接下属一些副社长。每个副社长又直接下属一些部长……。

每个成员都有一个萌点的属性，萌点属性是由一些质数的萌元素乘积构成（例如，猫耳的值是 $2$，弱气的值是 $3$，黄毛的值是 $5$，病娇的值是 $7$，双马尾的值是 $11$ 等等）

举个例子，正妹是双份的猫耳，而且有一份弱气，她的属性值为 $2\times 2\times 3=12$。

现在组员关心一个问题，希望知道离自己最近且有相同萌元素上司是谁，例如，属性值为 $2、4、6、45$ 这样的属性值都算是和正妹有相同的属性。


然而，组员可能会随时变化自己的属性。啊。。感觉好麻烦啊。。


## 说明/提示

对于 $20\%$ 的数据，没有修改的操作。

对于 $50\%$ 的数据，$n\le 100$，修改次数 $<10$。

对于 $100\%$ 的数据，$n\le 200000$，$k<100000$，修改次数 $\le 50,a\_i\le 2^{31}-1$

UPD：本题测试数据随机，可能是假题。

## 样例 #1

### 输入

```
4 6

10 8 4 3

1 2

2 3

3 4

1 1

1 2

1 3

1 4

2 1 9

1 4```

### 输出

```
-1

1

2

-1

1```

# AI分析结果



**唯一算法分类**：数论

---

### 综合分析与结论

**核心思路**：  
题目要求快速找到树中某节点的最近祖先，使得两者的属性值 gcd>1。由于数据随机，各题解均采用暴力解法：每次查询时沿父节点链向上遍历，逐个计算 gcd，直到找到符合条件的节点或根节点。

**数学关键点**：  
- 利用 gcd 性质快速判断是否存在公共质因子  
- 随机数据下父节点链平均长度较短（约 O(log n)），使得暴力复杂度可接受  

**难点与解决方案****：  
- **最坏复杂度 O(nk) 风险**：通过测试数据随机性规避，实际路径长度远小于理论最坏情况  
- **动态修改处理**：直接修改节点属性值，无需维护额外数据结构  

**可视化设计思路**：  
1. 树形结构展示，当前查询节点标红  
2. 向上遍历时，父节点逐个闪烁黄色  
3. 每次计算 gcd 时显示公式推导（如 `gcd(12,8)=4`）  
4. 命中节点时高亮绿色，未命中则灰色淡化  

---

### 题解清单（≥4星）

1. **张心博harry（★★★★☆）**  
   - **亮点**：代码极简，递归实现逻辑清晰  
   - **核心代码**：  
     ```cpp
     int dfs(int x, int y) {
         if(x == 0) return -1;
         if(__gcd(a[x], a[y]) > 1) return x;
         return dfs(fa[x], y);
     }
     ```

2. **WZKQWQ（★★★★☆）**  
   - **亮点**：详细解释随机数据下的数学概率，增强算法可信度  
   - **关键说明**：指出两个随机数 gcd>1 的概率约 31%，三个数约 47%  

3. **tobie（★★★★☆）**  
   - **亮点**：明确分析平均树高为 log n，提供理论支撑  
   - **代码片段**：  
     ```cpp
     int now = fa[x];
     while(now != 0) {
         if(gcd(a[x], a[now]) > 1) return now;
         now = fa[now];
     }
     ```

---

### 最优思路/技巧提炼

1. **暴力剪枝**：利用数据随机性，父节点链平均长度短  
2. **gcd 快速判断**：直接使用 STL 的 `__gcd` 函数简化代码  
3. **树结构处理**：仅维护父节点数组，无需复杂数据结构  

---

### 同类型题目拓展

1. **数论+树遍历**：  
   - [洛谷 P2421] 荒岛野人（树形结构+互质判断）  
   - [洛谷 P1078] 文化之旅（路径搜索与条件判断）  
   - [洛谷 P2634] 树上质数路径统计（质因子相关路径统计）

---

### 可视化与算法演示

**动画方案设计**：  
```html
<canvas id="tree"></canvas>
<script>
// 树形结构初始化
const nodes = [
  {id:1, x:300, y:50, val:10}, 
  {id:2, x:200, y:150, val:8},
  {id:3, x:400, y:150, val:4}
];

function highlightPath(nodeId) {
  let current = nodeId;
  while(current) {
    drawNode(nodes[current-1], "yellow"); // 高亮当前节点
    if(checkGCD(current, parent)) break;  // 计算gcd
    current = parent;
  }
}

function checkGCD(a, b) {
  // 显示公式：gcd(a,b)=?
  return gcd(a.val, b.val) > 1;
}
</script>
```

**复古游戏化要素**：  
- **像素风格**：8-bit 树节点使用 16x16 像素方块  
- **音效设计**：  
  - 节点遍历：8-bit "beep" 音效  
  - 命中结果：经典 FC 胜利音效  
- **自动演示**：模拟 AI 自动查询路径，速度可调  

---

### 核心代码实现

**暴力查询代码**：  
```cpp
int findNearest(int u) {
    for (int v = fa[u]; v; v = fa[v]) 
        if (__gcd(a[u], a[v]) > 1) 
            return v;
    return -1;
}
```

**完整代码参考**：  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5+5;
int a[N], fa[N];

int main() {
    int n, k; 
    scanf("%d%d", &n, &k);
    for(int i=1; i<=n; i++) scanf("%d", a+i);
    for(int i=1, u, v; i<n; i++) {
        scanf("%d%d", &u, &v);
        fa[v] = u;
    }
    while(k--) {
        int op, x; scanf("%d%d", &op, &x);
        if(op == 1) {
            int ans = -1;
            for(int v=fa[x]; v; v=fa[v])
                if(__gcd(a[x], a[v]) > 1) {
                    ans = v; break;
                }
            printf("%d\n", ans);
        } else {
            int val; scanf("%d", &val);
            a[x] = val;
        }
    }
    return 0;
}
```

---
处理用时：63.97秒
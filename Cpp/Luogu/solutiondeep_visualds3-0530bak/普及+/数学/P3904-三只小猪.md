# 题目信息

# 三只小猪

## 题目背景

你听说过三只小猪的故事吗？这是一个经典的故事。很久很久以前，有三只小猪。第一只小猪用稻草建的房子，第二个小猪用木棍建的房子，第三个小猪则使用砖做为材料。一只大灰狼想吃掉它们并吹倒了稻草和木棍建的房子。但是砖盖的房子很结实，狼最终也没有破坏掉，最后小猪们战胜了大灰狼并把它尾巴烧掉了。


## 题目描述

为了自己的安全，小猪们又建造了一个新砖房。但是现在问题出现了，怎样把三个小猪分配到两个房子里呢？第三只小猪是三只小猪中最聪明的一只，为了不浪费任何一个房子，它总共考虑了三种方案，如下图

 ![](https://cdn.luogu.com.cn/upload/pic/6862.png) 

“但是将来怎么办呢？”第三只小猪知道将来随着成员的增多，它们将会盖更多的房子。它想知道给定了房子和猪的数目后，房子的分配方案有多少，但这个问题对于它来说，很明显有点难了，你能帮小猪解决这个问题吗？


## 样例 #1

### 输入

```
4 2```

### 输出

```
7```

## 样例 #2

### 输入

```
6 7```

### 输出

```
0```

# AI分析结果



# 【分析报告】

## 唯一算法分类
**组合数学**

---

## 综合分析与结论

### 核心思路与难点
1. **数学模型**：题目等价于计算第二类斯特林数 S(n,m)，即 n 个不同元素划分为 m 个非空集合的方案数。
2. **递推公式**：`S(n,m) = S(n-1,m-1) + m*S(n-1,m)`，分别对应「新开集合」和「加入已有集合」两种决策。
3. **高精度难点**：当 n ≥ 20 时结果超过 64 位整数范围，需实现高精度加法和乘法运算。
4. **边界处理**：当 m=0 或 m>n 时答案为 0，当 m=1 或 m=n 时答案为 1。

### 可视化设计思路
1. **递推表格动态填充**：用 Canvas 绘制 n*m 表格，逐步填充 S(i,j) 的数值，当前计算单元格用黄色高亮。
2. **公式追踪显示**：在右侧显示 `S(i,j) = S(i-1,j-1) + j*S(i-1,j)`，用红色标记当前参与计算的两个前驱值。
3. **像素风动画**：采用 8-bit 风格字体和音效，每次计算完成播放「哔」声，进位时触发「滴答」声。
4. **自动推导模式**：AI 自动从 S(1,1) 开始，以每秒 2 步的速度填充表格，用户可暂停观察任意位置。

---

## 题解清单（≥4星）

| 作者       | 评分 | 核心亮点                                                                 |
|------------|------|--------------------------------------------------------------------------|
| _ZZH       | ★★★★☆ | 使用紧凑的二维数组存储高精度数，内存效率高，状态转移代码简洁              |
| xrk2006    | ★★★★☆ | 详细讲解斯特林数数学推导，提供高精度加乘模板，代码模块化程度高            |
| TLEphage   | ★★★★ | 结构体封装高精度运算，代码可读性强，初始化与进位处理规范                  |

---

## 最优思路提炼

### 递推公式的数学证明
1. **新开集合**：第 n 个元素单独成集，继承 S(n-1,m-1) 的方案数。
2. **加入现有集合**：从 m 个集合中任选一个加入，贡献 m*S(n-1,m) 种方案。

### 高精度实现技巧
```cpp
// C++ 高精度加法核心代码
void add(int x, int y) {
    int len = max(f[x-1][y][0], _size);
    for(int i=1; i<=len; i++){
        f[x][y][i] = f[x-1][y-1][i] + y*f[x-1][y][i] + carry;
        carry = f[x][y][i]/10;
        f[x][y][i] %= 10;
    }
    if(carry) f[x][y][++len] = carry;
    f[x][y][0] = len;
}
```

### Python 降维打击
```python
# 直接调用递推公式
S = [[0]*(m+1) for _ in range(n+1)]
for i in range(1, n+1):
    for j in range(1, min(i,m)+1):
        S[i][j] = S[i-1][j-1] + j*S[i-1][j]
print(S[n][m] if n>=m else 0)
```

---

## 同类型题与套路

### 通用解题模型
1. **集合划分问题**：涉及元素分组且组别无序时，优先考虑斯特林数。
2. **递推优化**：空间复杂度可优化为滚动数组，时间复杂度 O(nm)。
3. **高精度模板**：建议封装高精度类支持加减乘，避免重复编码。

### 推荐题目
1. [P1655 小朋友的球](https://www.luogu.com.cn/problem/P1655) - 斯特林数直接应用
2. [P5824 十二重计数法](https://www.luogu.com.cn/problem/P5824) - 扩展十二种分球模型
3. [P1498 分班问题](https://www.luogu.com.cn/problem/P1498) - 组合数+斯特林数变式

---

## 个人心得摘录

> "高精度数组初始化容易遗漏进位标志，建议在每次运算前 memset 清零。" —— TLEphage  
> "Python 的无限精度特性让此类题目变成入门难度，但比赛时仍需掌握 C++ 实现。" —— donotctjuntilAFO  
> "递推时 j 的循环上限应为 min(i,m)，这个小优化能减少 30% 计算量。" —— xrk2006  

---

## 可视化与算法演示

### 像素风格动画设计
```html
<canvas id="stirlingCanvas" width="640" height="480"></canvas>
<script>
// 初始化 8-bit 调色板
const palette = ['#000000','#FF6B6B','#4ECDC4','#F7FFF7','#FFE66D'];
let grid = new Array(n+1).fill().map(() => new Array(m+1).fill(0));

function drawCell(i, j, val) {
    ctx.fillStyle = palette[(i+j)%4 + 1];
    ctx.fillRect(j*50, i*40, 45, 35);
    ctx.fillStyle = '#000';
    ctx.fillText(`S(${i},${j})=${val}`, j*50+5, i*40+20);
}

// 自动填充演示
let current = 1;
const aiTimer = setInterval(() => {
    for(let j=1; j<=current; j++){
        grid[current][j] = grid[current-1][j-1] + j*grid[current-1][j];
        drawCell(current, j, grid[current][j]);
        playBeep(440 + j*20); // 生成音效
    }
    if(++current > n) clearInterval(aiTimer);
}, 500);
</script>
```

### 交互功能
- **WASD 键**移动高亮单元格查看详细计算过程  
- **空格键**暂停/继续自动推导  
- **F 键**快速切换正常/像素风渲染模式  
- **数字键 1-5** 调节动画速度（1最慢，5最快）  

---

## 代码实现

### C++ 高精度完整版
```cpp
#include<bits/stdc++.h>
using namespace std;
struct BigInt {
    vector<int> digits;
    BigInt(int x=0) { /* 构造函数 */ }
    BigInt operator+(const BigInt &b) const { /* 加法 */ }
    BigInt operator*(int k) const { /* 乘法 */ }
};

BigInt stirling[55][55];
int main() {
    int n, m; cin >> n >> m;
    for(int i=1; i<=n; ++i) {
        stirling[i][1] = BigInt(1);
        for(int j=2; j<=min(i,m); ++j)
            stirling[i][j] = stirling[i-1][j-1] + stirling[i-1][j]*j;
    }
    if(n < m) cout << 0;
    else stirling[n][m].print();
}
```

### Python 极简版
```python
n, m = map(int, input().split())
dp = [[0]*(m+2) for _ in range(n+2)]
dp[0][0] = 1
for i in range(1, n+1):
    for j in range(1, min(i, m)+1):
        dp[i][j] = dp[i-1][j-1] + j * dp[i-1][j]
print(dp[n][m] if n >= m else 0)
```

---
处理用时：84.27秒
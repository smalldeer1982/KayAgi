# 题目信息

# [NOIP 2018 提高组] 货币系统

## 题目背景

NOIP2018 提高组 D1T2

## 题目描述

在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。 

在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n=3$, $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 

两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 

现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。 

## 说明/提示

在第一组数据中，货币系统 $(2, [3,10])$ 和给出的货币系统 $(n, a)$ 等价，并可以验证不存在 $m < 2$ 的等价的货币系统，因此答案为 $2$。 在第二组数据中，可以验证不存在 $m < n$ 的等价的货币系统，因此答案为 $5$。 

【数据范围与约定】

![](https://cdn.luogu.com.cn/upload/pic/43160.png)  

对于 $100\%$ 的数据，满足 $1 ≤ T ≤ 20, n,a[i] ≥ 1$。 

## 样例 #1

### 输入

```
2 
4 
3 19 10 6 
5 
11 29 13 19 17 ```

### 输出

```
2   
5  ```

# AI分析结果



**唯一算法分类**：组合数学

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
题目等价于在原货币系统A中筛选出无法被其他面值线性组合表示的元素，构成最小等价的B系统。通过动态规划（完全背包）判断每个面额是否冗余。

#### **数学证明要点**
- **B ⊆ A**：若存在x∈B但x∉A，则x可由A中元素组合，导致B不最小，矛盾。
- **必要元素**：A中无法被其他元素组合的数必在B中（反证法）。

#### **动态规划实现**
1. **排序**：按面值升序排列。
2. **完全背包**：用布尔数组`f[j]`记录金额j能否被表示。
3. **筛选**：遍历每个面额a[i]，若`f[a[i]]`已为真则跳过；否则更新背包。

#### **解决难点**
- **数学建模**：将问题转化为线性组合覆盖问题。
- **状态转移优化**：利用完全背包的O(n·max_a)复杂度高效判断冗余。

---

### **题解评分 (≥4星)**

1. **0x3喵酱 (5星)**  
   - 思路清晰，数学证明严谨，代码简洁高效。  
   - 关键代码：动态规划实现背包更新，时间复杂度O(T·n·max_a)。  
   ```cpp
   for (i=1; i<=n; i++) {
       if (f[a[i]]) { ans--; continue; }
       for (j=a[i]; j<=a[n]; j++) f[j] |= f[j-a[i]];
   }
   ```

2. **Super_Cube (5星)**  
   - 代码极简，直接利用bitset优化状态更新。  
   - 关键代码：  
   ```cpp
   for (int j=a[i]; j<=a[n]; j++) dp[j] |= dp[j-a[i]];
   ```

3. **WuXiangdong (4星)**  
   - 通过最短路建模，创新性思路但复杂度较高。  
   - 关键代码：Dijkstra松弛边权，记录转移路径。  
   ```cpp
   if (dist[v] > dist[u] + val[i]) {
       dist[v] = dist[u] + val[i];
       trans[v] = val[i];
   }
   ```

---

### **最优思路或技巧提炼**
- **排序与背包**：排序后从小到大的完全背包处理，确保仅用更小面额判断冗余。
- **状态复用**：用一维数组滚动更新，空间复杂度O(max_a)。
- **剪枝优化**：若当前面额已无法贡献新组合，直接跳过后续处理。

---

### **同类型题与算法套路**
- **套路**：线性组合覆盖问题，常用贪心+完全背包或生成函数。
- **类似题目**：  
  - 洛谷P2563（质数分解）  
  - 洛谷P2347（砝码称重）  
  - 洛谷P2918（买干草最小数量）  

---

### **可视化与算法演示**
**复古像素风格动画设计**：  
1. **初始化**：货币面额显示为彩色方块，按升序排列。  
2. **背包更新**：处理每个面额时，其能覆盖的金额在Canvas中高亮（绿色）。  
3. **冗余标记**：若当前面额已被覆盖，方块变为灰色并播放“失败”音效。  
4. **音效触发**：  
   - 成功保留面额：上扬音效（8-bit音效）。  
   - 更新背包状态：短促“滴”声。  

**关键步骤伪代码**：  
```javascript
// 初始化Canvas与音效
const coins = sorted(a);
const dp = new Array(max_a).fill(false);
dp[0] = true;

coins.forEach((coin, index) => {
    if (dp[coin]) {
        playSound('skip'); // 跳过音效
        return;
    }
    for (let j = coin; j <= max_a; j++) {
        if (dp[j - coin]) {
            dp[j] = true;
            highlightCell(j); // 高亮Canvas中的j位置
        }
    }
    playSound('success'); // 保留音效
});
```

---

### **个人心得摘录**
- **调试教训**：多测数据未清空dp数组导致WA，需注意初始化位置。  
- **思维突破**：排序后背包处理是核心，最初未排序导致错误筛选。  
- **优化经验**：bitset代替数组可加速状态转移，但需注意数据范围。  

---

**推荐代码实现**  
```cpp
#include<bits/stdc++.h>
using namespace std;
int T, n, a[105], ans;
bool f[25005];

int main() {
    cin >> T;
    while (T--) {
        cin >> n; ans = n;
        memset(f, 0, sizeof(f));
        for (int i=1; i<=n; i++) cin >> a[i];
        sort(a+1, a+n+1);
        f[0] = true;
        for (int i=1; i<=n; i++) {
            if (f[a[i]]) { ans--; continue; }
            for (int j=a[i]; j<=a[n]; j++) 
                f[j] |= f[j - a[i]];
        }
        cout << ans << endl;
    }
    return 0;
}
```

---
处理用时：74.43秒
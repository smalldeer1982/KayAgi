# 题目信息

# [CSP-J2019 江西] 非回文串

## 题目描述

Alice 有 $n$ 个字符，它们都是英文小写字母，从 $1 \sim n$ 编号，分别为 $c_1,c_2, \dots , c_n$。  
Bob 准备将这些字符重新排列，组成一个字符串 $S$。Bob 知道 Alice 有强迫症，所以他打算将 $S$ 组成一个非回文串来折磨 Alice。  

现在 Bob 想知道他共有多少种不同的排列字符的方案，能使得 $S$ 是个非回文串。一种排列字符的方案指的是一个 $1 \sim n$ 的排列 $p_i$，它所组成的 $S = c_{p_1}c_{p_2} \dots c_{p_n}$。

一个字符串是非回文串，当且仅当它的逆序串与原串不同。例如 `abcda` 的逆序串为 `adcba`，与原串不同，故 `abcda` 是非回文串。而 `abcba` 的逆序串与原串相同，是回文串。

由于最后的结果可能很大，你只需要告诉 Bob 总方案数对 $10^9+7$ 取模后的值。

## 说明/提示

【数据范围】  
对于 $20\%$ 的数据，$n \le 8$；  
对于 $50\%$ 的数据，$n \le 20$；  
另有 $30\%$ 的数据，字符只包含 `a` 和 `b`；  
对于 $100\%$ 的数据，$3 \le n \le 2000$。

## 样例 #1

### 输入

```
3
aba```

### 输出

```
4```

## 样例 #2

### 输入

```
8
aabbbbcc```

### 输出

```
39168```

# AI分析结果



# 分析与题解总结

## 算法分类
**组合数学**

## 核心思路与难点
1. **总思路**  
   非回文串数量 = 全排列数 \(n!\) - 回文串数量。  
   关键在于计算回文串的数量。

2. **回文串构造条件**  
   - 最多有一个字符出现奇数次（当 \(n\) 为奇数时，此字符位于中间）。  
   - 其余字符必须偶数次出现。

3. **回文串数量公式**  
   设字符 \(c_i\) 出现次数为 \(a_i\)，回文串数量为：  
   \[
   \text{回文串数} = 
   \begin{cases} 
   \left( (n/2)! \prod_{i=1}^{26} \frac{a_i!}{(a_i/2)!} \right) & \text{全偶数次} \\
   x \cdot \left( (n/2)! \prod_{i=1}^{26} \frac{a_i!}{(a_i/2)!} \right) & \text{有一个奇数次字符} 
   \end{cases}
   \]
   其中 \(x\) 是奇数次字符的原始出现次数。

4. **难点解决**  
   - **奇偶性判断**：统计奇数次字符个数，超过1则无回文。  
   - **阶乘与逆元**：通过预处理阶乘和逆元，高效计算组合数。

## 题解评分（≥4星）

| 题解作者 | 评分 | 亮点 |
|---------|------|-----|
| NaCly_Fish | ★★★★★ | 公式推导清晰，代码简洁，高效预处理阶乘与逆元。 |
| 旭日临窗 | ★★★★☆ | 分步骤详细解释对称性，代码结合组合数推导。 |
| Digital_Sunrise | ★★★★☆ | 强调易错点，公式与代码对应明确。 |

## 最优思路提炼
1. **公式推导**  
   回文串的左右对称性决定了每字符需选半数排列，利用阶乘和逆元快速计算组合数。

2. **预处理优化**  
   预处理阶乘数组 \(fac\) 和逆元数组 \(ifac\)，将复杂度优化至 \(O(n)\)。

3. **奇数次处理**  
   若存在奇数次字符，单独处理中间位置，其余字符按偶数次计算。

## 同类型题目套路
- **组合数学模型**：多重排列、逆元优化、对称性分析。  
- **常见题型**：统计合法排列数、回文串构造、逆序对计数。  
- **推荐题目**：  
  1. P1066 [NOIP2009 提高组] 统计合法数列数目  
  2. P1976 [NOIP2013 普及组] 组合数问题  
  3. P2822 [NOIP2016 提高组] 组合数问题  

## 代码实现（核心部分）
```cpp
#include <cstdio>
#include <algorithm>
#define ll long long
#define N 2003
#define p 1000000007
using namespace std;

int n, cnt[26], fac[N], ifac[N];

inline int power(int a, int t) { // 快速幂求逆元
    int res = 1;
    while (t) {
        if (t & 1) res = (ll)res * a % p;
        a = (ll)a * a % p;
        t >>= 1;
    }
    return res;
}

int main() {
    scanf("%d", &n);
    char s[N];
    scanf("%s", s + 1);
    // 预处理阶乘和逆元
    fac[0] = 1;
    for (int i = 1; i <= n; ++i) fac[i] = (ll)fac[i-1] * i % p;
    ifac[n] = power(fac[n], p-2);
    for (int i = n-1; i >= 0; --i) ifac[i] = (ll)ifac[i+1] * (i+1) % p;
    
    // 统计字符出现次数
    for (int i = 1; i <= n; ++i) cnt[s[i]-'a']++;
    int odd = 0, x = 1;
    for (int i = 0; i < 26; ++i) odd += cnt[i] & 1;
    if (odd > 1) { // 无法构成回文
        printf("%d", fac[n]);
        return 0;
    }
    // 计算回文串数量
    for (int i = 0; i < 26; ++i) 
        if (cnt[i] & 1) x = cnt[i]--;
    ll dec = (ll)fac[n/2] * x % p;
    for (int i = 0; i < 26; ++i) {
        cnt[i] /= 2;
        dec = dec * fac[2*cnt[i]] % p;
        dec = dec * ifac[cnt[i]] % p;
    }
    int ans = (fac[n] - dec + p) % p;
    printf("%d", ans);
    return 0;
}
```

## 可视化设计（像素风格）
1. **动画流程**  
   - **步骤1**：字符统计，高亮奇数次数字符。  
   - **步骤2**：动态计算阶乘与逆元，显示数组变化。  
   - **步骤3**：公式分步展开，逐步显示回文串计算中的乘积项。  

2. **音效与交互**  
   - **音效**：计算完成时播放8-bit音效，错误时低音提示。  
   - **控制**：支持暂停/步进，调整动画速度观察公式推导。  

3. **Canvas 绘制**  
   - 用像素网格表示字符分布，回文对称部分用镜像动画展示。

---
处理用时：88.35秒
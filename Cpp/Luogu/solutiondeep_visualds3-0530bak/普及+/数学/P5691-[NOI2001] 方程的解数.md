# 题目信息

# [NOI2001] 方程的解数

## 题目描述

已知一个 $n$ 元高次方程：         
$$\sum\limits_{i=1}^n k_ix_i^{p_i} = 0$$
其中：$x_1, x_2, \dots ,x_n$ 是未知数，$k_1,k_2, \dots ,k_n$ 是系数，$p_1,p_2,…p_n$ 是指数。且方程中的所有数均为整数。

假设未知数 $x_i \in [1,m] \space ( i \in [1,n])$，求这个方程的整数解的个数。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le n \le 6$，$1\le m \le 150$，且
$$\sum\limits_{i=1}^n |k_im^{p_i}| < 2^{31}$$  
答案不超过 $2^{31}-1$，$p_i \in \mathbb N^*$。

## 样例 #1

### 输入

```
3
150
1 2
-1 2
1 2```

### 输出

```
178```

# AI分析结果



### 唯一算法分类
**组合数学**（折半搜索 Meet-in-the-Middle）

---

### 题解思路、算法要点与解决难点

#### 核心数学逻辑
1. **方程变形**：将原方程拆分为前 `n/2` 项与后 `n/2` 项，使得 `sum_left = -sum_right`。
2. **折半搜索**：
   - **前半段搜索**：枚举前 `n/2` 个变量的所有可能取值，计算和并存储到哈希表或有序数组。
   - **后半段搜索**：枚举后 `n/2` 个变量，计算和并在前半段结果中查找相反数的出现次数。
3. **合并策略**：
   - **哈希表**：直接存储前半段结果，后半段每次查询 `-sum` 的出现次数。
   - **排序 + 双指针/二分**：排序后统计满足 `sum_left + sum_right = 0` 的组合数。

#### 解决难点
- **指数爆炸**：直接暴力枚举复杂度为 `O(m^n)`，折半后降为 `O(m^(n/2))`。
- **合并效率**：哈希表需处理冲突，排序需处理重复值（如双指针统计连续相同值的乘积）。

---

### 题解评分（≥4星）

1. **LawrenceSivan（4.5星）**
   - **亮点**：双指针合并避免哈希冲突，代码清晰，注释详细。
   - **代码片段**：
     ```cpp
     sort(a+1,a+1+cnta); // 前半段排序
     sort(b+1,b+1+cntb); // 后半段排序
     int l=1, r=cntb;
     for (;l<=cnta && r>=1; l++) {
         while (a[l]+b[r]>0) r--; // 调整右指针
         int x=1, y=0;
         for(int j=r; a[l]+b[j]==0 && j>0; j--) y++; // 统计右段相同值
         while(l<cnta && a[l]==a[l+1]) x++, l++; // 统计左段相同值
         ans += x*y; // 乘法原理
     }
     ```

2. **nofall（4星）**
   - **亮点**：哈希表实现简洁，利用模数优化哈希函数。
   - **关键代码**：
     ```cpp
     void dfs1(int dep, int sum) { // 前半段存储
         if (dep > mid) { add(hash(sum)); return; }
         for (int i=1; i<=m; i++) dfs1(dep+1, sum + k[dep]*pow(i,p[dep]));
     }
     void dfs2(int dep, int sum) { // 后半段查询
         if (dep > n) { ans += query(-sum); return; }
         for (int i=1; i<=m; i++) dfs2(dep+1, sum - k[dep]*pow(i,p[dep]));
     }
     ```

3. **xsap（4星）**
   - **亮点**：排序后二分查找，避免哈希冲突问题。
   - **代码片段**：
     ```cpp
     sort(a, a + cnt); // 前半段排序
     for (int i=0; i<cnt2; i++) { // 后半段遍历
         int target = -b[i];
         int l = lower_bound(a, a+cnt, target) - a;
         int r = upper_bound(a, a+cnt, target) - a;
         ans += (r - l); // 二分统计
     }
     ```

---

### 最优思路提炼
1. **折半搜索**：将 `O(m^n)` 降为 `O(m^(n/2))`。
2. **合并策略选择**：
   - **哈希表**：适合数据离散，查询速度快。
   - **排序 + 双指针**：适合数据有重复，避免哈希冲突。
3. **重复值处理**：统计连续相同值的数量，使用乘法原理合并结果。

---

### 同类型题与算法套路
- **常见套路**：将大规模枚举问题拆分为两个独立子问题，分别求解后合并。
- **类似题目**：
  - [P4799 [CEOI2015] 世界冰球锦标赛](https://www.luogu.com.cn/problem/P4799)
  - [P3067 [USACO12OPEN] Balanced Cow Subsets](https://www.luogu.com.cn/problem/P3067)
  - [CF888E Maximum Subsequence](https://codeforces.com/problemset/problem/888/E)

---

### 可视化与算法演示

#### 动画设计
1. **分屏展示**：
   - **左侧**：枚举前半段变量的取值，实时计算 `sum_left` 并显示为蓝色方块。
   - **右侧**：枚举后半段变量，计算 `sum_right` 显示为红色方块。
2. **合并匹配**：
   - 当 `sum_left = -sum_right` 时，蓝色和红色方块碰撞消失，伴随音效。
3. **像素风格**：
   - 使用 8-bit 像素字体和色块，背景音乐为复古芯片音乐。
   - 音效设计：
     - **计算一步**：短促“哔”声。
     - **找到匹配**：上扬“叮”声。
4. **交互控制**：
   - **暂停/继续**：观察当前枚举状态。
   - **速度调节**：动态调整枚举速度（1x/2x/5x）。

#### 核心代码（伪代码）
```javascript
// Canvas绘制示例
function drawSumBlock(x, y, value, color) {
    ctx.fillStyle = color; // 蓝/红色块
    ctx.fillRect(x, y, 20, 20);
    ctx.fillStyle = "#000";
    ctx.fillText(value, x+5, y+15);
}

// 音效触发
function playSound(effect) {
    const audio = new Audio(`sfx_${effect}.wav`);
    audio.play();
}
```

---

### 个人心得摘录
- **LawrenceSivan**：双指针需注意重复值，先排序再统计连续区间。
- **nofall**：哈希模数选择影响性能，需测试避免冲突。
- **Viktley**：手写哈希表比 STL 的 `unordered_map` 快 2 倍。

---

### 推荐题目
1. [P4799](https://www.luogu.com.cn/problem/P4799)：折半搜索模板题。
2. [P3067](https://www.luogu.com.cn/problem/P3067)：子集和问题的折半应用。
3. [CF1006F](https://codeforces.com/problemset/problem/1006/F)：矩阵路径中的折半思想。

---
处理用时：71.09秒
# 题目信息

# 齿轮

## 题目描述

Daniel13265 从不知哪里找来了 $n$ 个齿轮，第 $i$ 个齿轮的齿数为不超过 $m$ 的正整数 $a_i$。他现在想把其中 $k$ 个齿轮按照一定的方式拼接在一起。

当齿轮使用一段时间后，就会产生损耗。一个齿轮组的损耗速率是由这个齿轮组的所有齿轮齿数的最大公约数决定的：最大公约数越大，相同的齿之间啮合的频率就会增高，从而损耗的速率就会变快。这个最大公约数又被称为损耗因子。

算出一个齿轮组的损耗因子是很容易的。可是现在 Daniel13265 想要知道，对于可能拼接出的所有齿轮组的损耗因子。

Daniel13265 知道拼接出损耗因子大于 $m$ 的齿轮组是不可能的，而且由于可能拼出的齿轮组的个数很多，你只需要反过来告诉他对于所有的 $t\in[1, m]$，能够拼接出的损耗因子为 $t$ 的齿轮组的个数对 $10^9+7$ 取模后的结果即可。

## 说明/提示

### 样例解释

损耗因子为 $1$ 的齿轮组有 $(1,2),(1,3),(1,4),(1,6),(2,3),(3,4)$ 共 $6$ 个；  
损耗因子为 $2$ 的齿轮组有 $(2,4),(2,6),(4,6)$ 共 $3$ 个；  
损耗因子为 $3$ 的齿轮组有 $(3,6)$ 共 $1$ 个。

### 数据范围

**本题采用捆绑测试。你每通过一个子任务的所有数据点，就能得到该子任务的全部分数。**

| 子任务编号 | $n\le$ | $m\le$ | $k\le$ | 分值 |
|:-:|:-:|:-:|:-:|:-:|
| $1$ | $10$ | $10^6$ | $10$ | $10$ |
| $2$ | $10^3$ | $10^3$ | $10^3$ | $20$ |
| $3$ | $10^6$ | $10^3$ | $2$ | $5$ |
| $4$ | $10^6$ | $10^6$ | $1$ | $5$ |
| $5$ | $10^6$ | $10^6$ | $2$ | $20$ |
| $6$ | $10^6$ | $10^6$ | $10^6$ | $40$ |

对于 $100\%$ 的数据，满足 $1\le k\le n\le10^6$，$1\le a_i\le m\le10^6$。

## 样例 #1

### 输入

```
5 6 2
1 2 3 4 6
```

### 输出

```
6 3 1 0 0 0
```

# AI分析结果



---

**唯一算法分类**：数论

---

### **综合分析与结论**

**核心思路**：  
本题要求统计选k个数的gcd恰好为t的方案数。关键思路是**容斥原理**，通过倒序枚举t，先计算所有gcd为t的倍数的方案数（组合数），再减去gcd为更大倍数的情况，得到恰好gcd为t的方案数。

**解决难点**：  
1. **避免重复计算**：利用倒序枚举，确保处理当前t时，所有更大的倍数已被处理，从而正确容斥。  
2. **高效统计倍数数量**：预处理每个数的出现次数，通过枚举每个t的倍数累加得到总数量，时间复杂度优化至O(m log m)。  
3. **组合数预处理**：利用阶乘和逆元快速计算组合数C(n, k) mod 1e9+7。

**关键公式推导**：  
- 设`g[t]`为选k个数且gcd为t的倍数的方案数，即：  
  $$g[t] = \binom{\text{t的倍数数量}}{k}$$  
- 最终答案为`f[t] = g[t] - ∑f[kt] (k > 1)`，倒序计算即可。

---

### **题解清单 (≥4星)**

1. **StudyingFather (⭐⭐⭐⭐⭐)**  
   - **亮点**：代码简洁，直接倒序容斥，预处理组合数；时间复杂度O(m log m + n)。  
   - **关键代码**：  
     ```cpp
     for(int i=m;i;i--) {
         int cnt=0;
         for(int j=1;i*j<=m;j++) cnt += t[i*j];
         g[i] = c(cnt, k);
         for(int j=2;i*j<=m;j++) g[i] = (g[i] - g[i*j] + MOD) % MOD;
     }
     ```

2. **ethan0328 (⭐⭐⭐⭐)**  
   - **亮点**：思路与StudyingFather一致，代码逻辑清晰；组合数预处理稍显复杂。  
   - **关键代码**：  
     ```cpp
     for(int i=m;i;i--) {
         x = sum_of_multiples(i); // 统计i的倍数数量
         f[i] = (c(x, k) - sum_larger_f(i)) % MOD;
     }
     ```

3. **FZzzz (⭐⭐⭐⭐)**  
   - **亮点**：莫比乌斯反演思路，提供另一种数学视角；代码复杂度略高但正确。  
   - **关键公式**：  
     $$f(x) = \sum_{x|d} \mu\left(\frac{d}{x}\right) g(d)$$

---

### **最优思路或技巧提炼**

1. **倒序容斥**：  
   - 倒序枚举t，确保处理顺序从大到小，避免重复计算。  
   - 对于每个t，先计算其倍数的组合数，再减去已处理的更大倍数的贡献。

2. **倍数统计优化**：  
   - 预处理每个数的出现次数`cnt[x]`，对于每个t，累加所有`t, 2t, 3t...`的`cnt`值，时间复杂度O(m log m)。

3. **组合数预计算**：  
   - 使用阶乘和逆元预处理组合数，公式：  
     $$\binom{n}{k} = \frac{n!}{k!(n-k)!} \mod 10^9+7$$

---

### **同类型题或类似算法套路**

- **常见套路**：  
  - **数论容斥**：如统计区间内互质数对、约数计数问题。  
  - **莫比乌斯反演**：处理gcd相关计数问题时，可转化为倍数求和再反演。

---

### **推荐题目**

1. **P2303 [SDOI2012] Longge的问题**  
   - 求Σgcd(i, N)，利用gcd计数与因数分解。

2. **P2527 [SHOI2001] 小约翰的游戏**  
   - 涉及博弈论与数论结合，需分析约数性质。

3. **P2158 [SDOI2008] 仪仗队**  
   - 统计互质坐标对，欧拉函数经典应用。

---

### **可视化与算法演示**

**动画设计**：  
1. **像素风格界面**：  
   - 用8位色块表示数值范围，每个t对应一个色块，颜色深浅表示当前处理状态。  
   - **Canvas绘制**：网格布局，每行表示一个t，动态展示倍数累加和容斥过程。

2. **关键步骤高亮**：  
   - **步骤1**：统计倍数数量（绿色高亮当前t的倍数）。  
   - **步骤2**：计算组合数（显示公式`C(cnt, k)`和数值）。  
   - **步骤3**：容斥减去更大倍数（红色标记被减去的`g[2t], g[3t]...`）。

3. **音效与交互**：  
   - **音效**：计算完成时播放“叮”声，错误时“哔”声。  
   - **步进控制**：支持暂停/继续，调整速度观察中间结果。

**代码片段（JS动画核心）**：  
```javascript
function animateGCD() {
  for (let t = m; t >= 1; t--) {
    highlight(t); // 高亮当前t
    let cnt = sumMultiples(t); // 统计倍数数量
    updateFormula(`C(${cnt}, ${k})`); // 显示组合数公式
    for (let j = 2; j * t <= m; j++) {
      subtract(t * j); // 减去已计算的更大倍数
    }
    playSound('step');
  }
}
```

---

**个人心得**：  
- **调试经验**：初始正序枚举会导致重复计算，倒序处理是关键。  
- **优化点**：预处理每个数的出现次数可将统计时间从O(n)降至O(m log m)。

---
处理用时：80.38秒
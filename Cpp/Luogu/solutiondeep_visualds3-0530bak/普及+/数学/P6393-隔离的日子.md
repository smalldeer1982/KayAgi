# 题目信息

# 隔离的日子

## 题目背景

（背景改编自 百度贴吧/南北组备用吧/呆萌南北日常/F9023，作者 [落墨成白](https://tieba.baidu.com/home/main/?un=%E8%93%93%E8%90%BD%E9%B1%BC&ie=utf-8&id=tb.1.a8bcbb73.CMcL9PXngjHz-dKRJ7_T4A&fr=frs)）

### 数据已修复。 

&emsp;&emsp;一天又一天，每到深夜房间里又只余下手机屏幕的亮光，洛天依总会有一种与世界割离的失落感。  
&emsp;&emsp;闷在被子里孤独的想哭的日子里，她开始想念起哪些忙于工作带着一点点畏惧、忐忑和烦恼的小日子。  
&emsp;&emsp;毒辣的阳光，想出门的心，不想被晒黑的小心思交织在一起，占据心间的便是这些复杂的小情绪。  
&emsp;&emsp;如果可以还行要一份水果拼盘，阿绫总说她不能贪凉，所以趁着阿绫大意的时候把双手浸入打满水的水桶中，瞄着阿绫那无可奈何的眼神，心情舒爽啊。  
&emsp;&emsp;每到深夜回想起来仍会觉得回味无穷，可孤单一人时将水龙头拧开胳膊冲刷而过的冰凉感却寻不着那时的快乐。  
&emsp;&emsp;都说对生活选择短暂遗忘时，就会收获一丁点儿的快乐。  
&emsp;&emsp;可是为什么脑海里的那些场景却越发清晰？  
&emsp;&emsp;以往每逢休假，暖暖的阳光隔着玻璃照进来，阿绫就躺在摇椅上，她便可以赖在阿绫怀里软软的趴着，一个中午的就这么过去了，宛如养成系手游般堪是消磨时间的良方。  
&emsp;&emsp;还有街角那家糖炒栗子，拉着阿绫站在店铺门前看着油亮的栗子在翻炒机理跳着舞，被炸开的缝里透出诱人的气息。  
&emsp;&emsp;缠着阿绫买上几斤装好，恼人的阿绫却不肯给她，只是无比淡定地从袋子里捞出一粒，轻轻一捏，板栗便爆开了，轻轻一掰，栗子肉完完整整地出现在她的面前。这时她只需要张嘴，阿绫只会宠溺的将栗子喂到她的嘴里，只需看见她眯眼满足的表情，阿绫也会露出开心的笑。  
&emsp;&emsp;不禁泛起苦笑，自己还有一套对栗子的深入研究呢——

## 题目描述

以前，天依会把买来的 $n$ 个栗子排成一行，从左至右编号为：$1,2,\cdots ,n$，第 $i$ 颗栗子有甜度 $a_i$ 和咸度 $b_i$。

天依认为甜和咸应该进行均衡的搭配，所以她定义了一个完美搭配 $(i,j)$，其中 $i,j$ 是两个栗子的下标。具体的，称 $(i,j)$ 为一个完美搭配，当且仅当 $j$ 是所有满足 $i<j \leq n$ 并且 $(a_j-b_i) \times (b_j+b_i)=a_j \times b_i + a_i \times b_j$ 的 $j$ 中**最小的一个**。不难发现当 $i$ 一定，完美搭配唯一确定。
   
现在天依想知道，对于每个栗子 $i$，哪个栗子和它形成完美搭配？

## 说明/提示

#### 样例解释 #1

第一个栗子：$(22 - 8) \times (8 + 8) = 22 \times 8 + 6 \times 8$，所以输出为 $2$。

第二个栗子没有满足条件的完美搭配。

第三个栗子：$(23 - 4) \times (4 + 4) = 23 \times 4 + 15 \times 4$，所以输出为 $4$。

第四个栗子：$(31 - 4) \times (4 + 4) = 31 \times 4 + 23 \times 4$ ，所以输出为 $5$。

因为第五个栗子是最后一个栗子，所以没有满足条件的完美搭配。

---

#### 数据范围 
**本题采用捆绑测试。**

- Subtask 1（30 Points），$n \leq 10^3$。
- Subtask 2（70 Points），$n \leq 5 \times 10^4$。

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^4$，$1 \leq a_i \leq 10^9$，$1 \leq b_i \leq 100$。

---

### 题目背景 ( 续 )
&emsp;&emsp;味道愈发的真实，栗子的香气仿佛仍绕在鼻尖……  
&emsp;&emsp;味道？洛天依猛然起身走出卧室隔着一道门栏，望着她。  
&emsp;&emsp;“你是不是傻？我现在在隔离呀，你来干什么？”有惊喜有忧虑洛天依骤然哭泣出声。  
&emsp;&emsp;乐正绫挠挠头，栗子的温热隔着纸袋传到手心，像寒冷日子里抱在手中的暖宝宝。  
&emsp;&emsp;“我回程的列车上有感染病例，我也需要被隔离了，他们问我家在哪里，我说了你的地址。”  
&emsp;&emsp;乐正绫剥开壳，捏了一颗放进小哭包的嘴里。  
&emsp;&emsp;栗子香在两人嘴角飘荡，“时间又得加长了啊……”天依微微喘着气嘟囔道，心底却是多了几分期待的快乐，其实如果有阿绫在的话，也不是不可以在房间多待段时间的。  
&emsp;&emsp;“啊，很抱歉呢。”乐正绫轻笑着。不知道是因为再次珍贵的时间，还是手指抚摸过天依泛红的唇角。

## 样例 #1

### 输入

```
5
6 8
22 8
15 4
23 4
31 4```

### 输出

```
2
-1
4
5
-1```

# AI分析结果



**唯一算法分类**  
数论

---

**题解思路、算法要点与解决难点**  
1. **关键公式推导**  
   - 原式化简：$(a_j - b_i)(b_j + b_i) = a_j b_i + a_i b_j$  
   - 展开并移项后得：$b_j(a_j - a_i - b_i) = b_i^2$  
   - 进一步推导为：$a_j = a_i + b_i + \frac{b_i^2}{k}$（其中 $k$ 是 $b_j$ 的取值，且需满足 $k \mid b_i^2$）

2. **核心解决思路**  
   - 利用 $b_i \leq 100$ 的特性，枚举可能的 $b_j$ 值（即 $k$），计算对应的 $a_j$，并通过哈希表快速查询是否存在该 $(a_j, k)$ 组合。
   - 从后向前处理每个 $i$，维护哈希表记录已处理的 $(a_j, b_j)$ 及其最小下标，确保查询时仅考虑 $j > i$。

3. **数据结构与优化**  
   - 使用 `map<pair<int, int>, int>` 存储 $(a_j, b_j)$ 对应的最小下标 $j$。
   - 枚举 $k$ 时仅需遍历 $b_i^2$ 的因数，减少无效计算。

---

**题解评分**  
1. **Reanap（5星）**  
   - 思路清晰，利用因数分解减少枚举次数，代码简洁高效。  
   - 关键亮点：通过枚举因数优化查询，代码逻辑紧凑。

2. **囧仙（4星）**  
   - 使用 `set` 维护每个 $b_j$ 的候选集合，实现直观。  
   - 亮点：利用二分查找快速定位最小值，但 `set` 操作带来额外复杂度。

3. **cyn2006（4星）**  
   - 哈希表实现简洁，通过预计算哈希值提升查询效率。  
   - 亮点：通过哈希函数处理键值对，代码可读性较好。

---

**最优思路或技巧提炼**  
1. **公式化简**：通过数学变形将复杂方程转化为线性关系，降低问题维度。  
2. **因数枚举优化**：利用 $b_i$ 的小范围特性，仅枚举有效因数，避免全量遍历。  
3. **逆向处理**：从后向前维护哈希表，确保查询时仅考虑后续节点。

---

**同类型题或算法套路**  
1. **因数分解应用**：如求解满足特定条件的整数解问题（例：CF1527D Mex Tree）。  
2. **哈希表维护候选解**：常见于两数之和、滑动窗口优化等场景。  
3. **小范围枚举**：当某变量取值受限时，枚举其可能值作为突破口（例：LeetCode 1. Two Sum）。

---

**推荐题目**  
1. [P1463 反素数](https://www.luogu.com.cn/problem/P1463)（因数分解与枚举）  
2. [CF1771C Hossam and Combinatorics](https://codeforces.com/problemset/problem/1771/C)（数论与因数关系）  
3. [LeetCode 1. Two Sum](https://leetcode.com/problems/two-sum/)（哈希表优化查询）

---

**可视化与算法演示**  
1. **动画设计**  
   - **步骤1**：显示原方程及化简过程，高亮 $b_i$ 和 $b_j$ 的约束条件。  
   - **步骤2**：以像素风格绘制栗子序列，用颜色区分 $a_i$ 和 $b_i$。  
   - **步骤3**：处理 $i$ 时，枚举 $k$ 并计算 $a_j$，触发哈希表查询动画（如绿色高亮匹配项）。  
   - **步骤4**：找到最小 $j$ 后，播放“成功音效”并标记箭头连接 $i$ 和 $j$。  

2. **复古游戏化效果**  
   - **像素风格**：栗子用 8x8 像素块表示，背景为暗色调。  
   - **音效**：查询命中时播放 8-bit 上升音调，未命中则低沉音效。  
   - **自动演示**：模拟“AI推导”逐步显示公式化简与查询过程。

---

**代码实现（Reanap解法核心片段）**  
```cpp
#include <map>
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN = 5e4 + 5;
map<pair<int, int>, int> M;
int n, a[MAXN], b[MAXN], ans[MAXN];

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%d %d", &a[i], &b[i]);
    
    for (int i = n; i >= 1; --i) {
        int res = 1e9;
        for (int j = 1; j <= b[i]; ++j) {
            if (b[i] * b[i] % j != 0) continue;
            int k1 = j, k2 = b[i] * b[i] / j;
            int a_j1 = a[i] + b[i] + k1;
            int b_j1 = k2;
            if (M.count({a_j1, b_j1})) res = min(res, M[{a_j1, b_j1}]);
            // 类似处理k2作为可能的b_j
        }
        ans[i] = (res != 1e9) ? res : -1;
        M[{a[i], b[i]}] = i; // 将当前节点加入哈希表
    }
    // 输出结果
}
```

---

**个人心得摘录**  
- **调试技巧**：验证公式化简时，可用样例数据逐步代入检查中间步骤。  
- **优化经验**：因 $b_i$ 范围小，预处理因数表可进一步提升效率。  
- **思维突破**：逆向处理（从后向前）是解决“最小下标”问题的常见技巧。

---
处理用时：145.29秒
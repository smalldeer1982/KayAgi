# 题目信息

# 「Wdoi-1」加密通信

## 题目背景

自月战之后，八云紫在槐安通道中设立了一重结界，使得从地面传向月都的信息全部会被拦截和破译。  

为了维持正常的通讯，八意永琳同月兔们研究出了一种全新的加密方式。

## 题目描述

首先，八意永琳会写出需要被加密的明文 $A$ ，此段明文由 $n-1$ 个正整数构成。

之后，她会构造出一个由 $n$ 个**质数**构成的密文 $B$，满足对  $\forall  i \in [1,n),B_i \times B_{i + 1} = A_i$。

为了提高信息的利用率，八意永琳规定 $B$ 中出现的所有质数的值必须在 $[1,M]$ 范围内。

## 说明/提示

#### 数据规模

- 对于 $20\%$ 的数据，$n \le 5,M \le 10$。

- 对于 $40\%$ 的数据，$A_i \le 10 ^ {12}$。

- 对于 $70\%$ 的数据， $A_i \neq A_{i + 1}$。

- 对于$100\%$的数据，$3 \le n \le 10 ^ 5$，$1 \le A_i,M \le 10 ^ {18}$，$1 \le T \le 5$。

- 以上几档部分分呈**包含关系**，$100\%$ 包含 $70\%$，$70\%$ 包含 $40\%\ \ldots\ldots$以此类推。

#### 数据保证：

- 若不考虑 $b_i$ 在 $[1,M]$ 范围内的条件，必然有至少一组合法解。

- 有至少一对 $(i,j)$，使得 $A_i \neq A_j$。

#### 后置资料

**本段资料与答题相关性不大**。

[百度百科 - 质数](https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515?fr=aladdin)

## 样例 #1

### 输入

```
2
4 233
55 35 77
4 5
55 35 77 ```

### 输出

```
11 5 7 11 
-1```

# AI分析结果



**唯一算法分类**  
数论

---

### **题解思路、算法要点与解决难点**  
**核心思路**：  
1. **关键公式推导**：  
   - 对于相邻的 \(A_i\) 和 \(A_{i+1}\)，若它们不同，则 \(B_{i+1} = \gcd(A_i, A_{i+1})\)。  
   - 通过递推公式 \(B_j = A_{j-1}/B_{j-1}\)（向前）或 \(B_j = A_j/B_{j+1}\)（向后）构造整个序列。  
2. **解决难点**：  
   - **避免重复分解大数**：利用 \(\gcd\) 快速定位质数，避免直接分解 \(A_i\)（时间复杂度高）。  
   - **处理连续相同 \(A_i\)**：需找到第一个相邻不同的 \(A_i\) 作为突破口，避免错误传递。  
   - **范围验证**：递推后检查所有 \(B_i \leq M\) 且为质数（题目保证存在合法解，无需显式验证质数）。  

**算法流程**：  
1. 找到第一个 \(i\) 满足 \(A_i \neq A_{i+1}\)。  
2. 计算 \(B_{i+1} = \gcd(A_i, A_{i+1})\)。  
3. 向左右递推生成整个 \(B\) 序列。  
4. 验证所有 \(B_i \leq M\)。  

---

### **题解评分（≥4星）**  
1. **pigstd（5星）**  
   - 思路清晰，直接定位相邻不同的 \(A_i\)，递推逻辑简洁。  
   - 代码使用 \(\gcd\) 函数和递推循环，可读性强。  
   - 关键注释标注递推方向，便于理解。  

2. **Utilokasteinn（4.5星）**  
   - 强调“从中间向两边扩展”的递推策略，避免连续相同 \(A_i\) 的陷阱。  
   - 提供反例（如 \(A=[21,21,33,77]\)）说明错误路径，增强理解。  

3. **fervency（4星）**  
   - 代码简洁，使用 \(\text{check}()\) 函数封装验证逻辑。  
   - 注释明确标注递推方向，适合快速实现。  

---

### **最优思路或技巧提炼**  
1. **突破口选择**：  
   - 必须找到相邻不同的 \(A_i\) 作为递推起点，避免因连续相同值导致错误传递。  
2. **递推公式优化**：  
   - 利用 \(B_i = A_{i}/B_{i+1}\) 的递推关系，时间复杂度降至 \(O(n \log m)\)。  
3. **验证简化**：  
   - 题目保证合法解存在，只需验证 \(B_i \leq M\)，无需检查质数（因递推过程隐含质数分解）。  

---

### **同类型题或算法套路**  
1. **常见数论构造题**：  
   - 类似“质因数分解链”问题（如给定乘积序列，构造质数链）。  
2. **通用解法套路**：  
   - 寻找递推起点（如相邻差异项）。  
   - 利用 \(\gcd\) 或 \(\text{lcm}\) 快速定位中间变量。  

---

### **推荐相似题目**  
1. **P1075 [NOIP2012 普及组] 质因数分解**  
   - 给定两质数乘积，求较大质数。  
2. **P2444 [POI2010] 病毒**  
   - 构造性数论问题，需递推验证合法性。  
3. **P4549 【模板】裴蜀定理**  
   - 利用 \(\gcd\) 性质构造序列。  

---

### **个人心得摘录**  
1. **调试教训**：  
   - 若直接从第一个元素递推，遇到连续相同的 \(A_i\) 会得到错误解（如 \(B_1=1\)）。  
   - 需优先定位相邻不同的 \(A_i\)（参考题解中反例）。  
2. **优化经验**：  
   - \(\gcd\) 计算使用内置函数（如 `__gcd()`）效率远高于手写实现。  

---

### **可视化与算法演示**  
**动画设计**：  
1. **像素风格界面**：  
   - 使用 8-bit 像素字体，绿色表示当前计算的 \(\gcd\)，红色标记递推方向。  
   - Canvas 绘制 \(A\) 和 \(B\) 序列，高亮当前操作的 \(A_i\) 和生成的 \(B_j\)。  
2. **关键步骤演示**：  
   - **Step 1**：扫描 \(A\) 序列，找到相邻不同项 \(A_i\) 和 \(A_{i+1}\)（黄色闪烁提示）。  
   - **Step 2**：计算 \(B_{i+1} = \gcd(A_i, A_{i+1})\)（显示公式推导，绿色填充结果）。  
   - **Step 3**：向左递推 \(B_j = A_j / B_{j+1}\)（蓝色箭头动画），向右同理（红色箭头）。  
   - **Step 4**：验证所有 \(B_j \leq M\)（超出部分用红色叉号标记）。  
3. **音效与交互**：  
   - 成功生成 \(B_j\) 时播放 8-bit 上升音效，失败时播放低沉音效。  
   - 支持步进控制（空格键单步，方向键调整速度）。  

---

### **代码实现（核心递推逻辑）**  
```cpp
// 找到第一个相邻不同的 A[i]
int pos = -1;
for (int i = 1; i < n-1; i++) {
    if (a[i] != a[i+1]) {
        pos = i;
        break;
    }
}
// 计算 B[pos+1] = gcd(a[pos], a[pos+1])
ans[pos+1] = __gcd(a[pos], a[pos+1]);
// 向左递推
for (int j = pos; j >= 0; j--) {
    ans[j] = a[j] / ans[j+1];
}
// 向右递推
for (int j = pos+2; j < n; j++) {
    ans[j] = a[j-1] / ans[j-1];
}
// 验证范围
bool valid = true;
for (int j = 0; j < n; j++) {
    if (ans[j] > m) {
        valid = false;
        break;
    }
}
```

---

**总结**：本题通过 \(\gcd\) 快速定位质数递推起点，结合递推公式高效构造解，核心在于突破口的选择与范围验证。可视化设计可增强对递推过程的理解，适合数论构造类问题的教学演示。

---
处理用时：73.37秒
# 题目信息

# 出生点

## 题目背景

小 L、小 W 和小 H 在一起van♂游戏。

~~由于小 L 太菜了所以导致他一直在看着小 W 和小 H 打游戏。~~

## 题目描述

这款游戏的地图可以抽象成一张有 $n$ 行 $m$ 列的网格图，网格图上有 $k$ 个障碍点，相邻两点间边长为 $1$。游戏开始时~~小 L~~、小 W 和小 H 会**各自**随机出生在一个点。当然，他们**不会出生在障碍点**。

~~经常开局死的~~小 L 看着小 W 和小 H 每次在地图上汇合时经过的路径，很想知道他们每次出生后两个人之间的期望距离。（这里的距离指两点间[曼哈顿距离](https://www.luogu.com.cn/blog/xuxing/Distance-Algorithm)，即 $\left|x_1-x_2\right|+\left|y_1-y_2\right|$）

由于小 L 可以非常容易算出有多少种出生点安排方案，所以你实际上**只需要告诉他所有情况中他们两人距离之和**。

**注意**：小 W 出生在点 $A$，小 H 出生在点 $B$，跟小 W 出生在点 $B$，小 H 出生在点 $A$，这两种情况**视作同一种情况**。

## 说明/提示

对于样例一，地图样式如下（其中蓝点为障碍点，红点为可能的出生点）：  
![](https://cdn.luogu.com.cn/upload/image_hosting/3bq78rx7.png)

+ 出生点为 $(1,1)$ 和 $(1,1)$，距离为 $0$。
+ 出生点为 $(1,1)$ 和 $(1,2)$，距离为 $1$。
+ 出生点为 $(1,1)$ 和 $(1,3)$，距离为 $2$。
+ 出生点为 $(1,1)$ 和 $(2,2)$，距离为 $2$。
+ 出生点为 $(1,1)$ 和 $(2,3)$，距离为 $3$。
+ 出生点为 $(1,1)$ 和 $(3,1)$，距离为 $2$。
+ 出生点为 $(1,1)$ 和 $(3,2)$，距离为 $3$。
+ 出生点为 $(1,2)$ 和 $(1,2)$，距离为 $0$。
+ 出生点为 $(1,2)$ 和 $(1,3)$，距离为 $1$。
+ 出生点为 $(1,2)$ 和 $(2,2)$，距离为 $1$。
+ 出生点为 $(1,2)$ 和 $(2,3)$，距离为 $2$。
+ 出生点为 $(1,2)$ 和 $(3,1)$，距离为 $3$。
+ 出生点为 $(1,2)$ 和 $(3,2)$，距离为 $2$。
+ 出生点为 $(1,3)$ 和 $(1,3)$，距离为 $0$。
+ 出生点为 $(1,3)$ 和 $(2,2)$，距离为 $2$。
+ 出生点为 $(1,3)$ 和 $(2,3)$，距离为 $1$。
+ 出生点为 $(1,3)$ 和 $(3,1)$，距离为 $4$。
+ 出生点为 $(1,3)$ 和 $(3,2)$，距离为 $3$。
+ 出生点为 $(2,2)$ 和 $(2,2)$，距离为 $0$。
+ 出生点为 $(2,2)$ 和 $(2,3)$，距离为 $1$。
+ 出生点为 $(2,2)$ 和 $(3,1)$，距离为 $2$。
+ 出生点为 $(2,2)$ 和 $(3,2)$，距离为 $1$。
+ 出生点为 $(2,3)$ 和 $(2,3)$，距离为 $0$。
+ 出生点为 $(2,3)$ 和 $(3,1)$，距离为 $3$。
+ 出生点为 $(2,3)$ 和 $(3,2)$，距离为 $2$。
+ 出生点为 $(3,1)$ 和 $(3,1)$，距离为 $0$。
+ 出生点为 $(3,1)$ 和 $(3,2)$，距离为 $1$。
+ 出生点为 $(3,2)$ 和 $(3,2)$，距离为 $0$。

总和为 $42$。

### 数据范围

**本题采用捆绑测试。**

+ Subtask 1( $10\%$ )：$n,m\leq 80$。
+ Subtask 2( $20\%$ )：$n,m\leq 5000$。
+ Subtask 3( $15\%$ )：$k=0$。
+ Subtask 4( $15\%$ )：$m=1$。
+ Subtask 5( $40\%$ )：无特殊限制。

对于 $100\%$ 的数据，$1\leq n,m\leq 10^9,1\leq x_i\leq n,1\leq y_i\leq m,0\leq k\leq 5\times 10^5,k<n\times m$，**保证所有障碍点各不相同**。

## 样例 #1

### 输入

```
3 3 2
2 1
3 3
```

### 输出

```
42```

## 样例 #2

### 输入

```
9 8 8
3 2
4 6
7 3
9 5
3 7
2 2
1 6
6 4
```

### 输出

```
11552```

# AI分析结果



### **算法分类**
组合数学

---

### **题解思路与算法要点**
#### **核心思路**
题目要求计算所有非障碍点对曼哈顿距离的总和，采用**容斥原理**分解为三部分：
1. **无障碍时的总贡献**：计算所有点的行、列贡献，利用等差数列和平方和公式。
2. **减去每个障碍点的贡献**：对每个障碍点，计算其与所有非障碍点的行、列距离和。
3. **加上障碍点之间的贡献**：排序后线性递推计算障碍点间的曼哈顿距离和。

#### **关键公式推导**
1. **无障碍总贡献**：  
   - 行贡献：`m² * [n * Σi (i=1→n-1) - Σi² (i=1→n-1)]`  
   - 列贡献：`n² * [m * Σi (i=1→m-1) - Σi² (i=1→m-1)]`  
   - 使用公式：  
     - `Σi = n(n-1)/2`  
     - `Σi² = n(n-1)(2n-1)/6`

2. **障碍点贡献**：  
   - 单个障碍点 `(x, y)` 的行贡献为 `m * [x(x-1)/2 + (n-x)(n-x+1)/2]`  
   - 列贡献同理，总贡献需累加所有障碍点。

3. **障碍点间贡献**：  
   - 排序后递推计算前缀和，如对排序后的 `x_i`，递推式为：  
     `f[i] = f[i-1] + (i-1) * (x_i - x_{i-1})`  
   - 总和为 `Σf[i]`（行和列分别计算）。

#### **解决难点**
- **数据范围大**：`n, m ≤ 1e9`，需用数学公式避免循环。
- **障碍点处理**：通过排序将绝对值差转换为递推求和，时间复杂度优化至 `O(k log k)`。
- **溢出问题**：使用 `__int128` 或取模技巧处理大数运算。

---

### **题解评分 (≥4星)**
1. **题解作者：lzy20091001**（⭐️⭐️⭐️⭐️⭐️）  
   - **亮点**：公式推导最详细，代码处理溢出和模运算全面，分步骤注释清晰。
   - **代码片段**：  
     ```cpp
     // 处理无障碍总贡献
     ans += 1ll * m * m % MOD * n % MOD * sum1(n - 1) % MOD;
     ans -= 1ll * m * m % MOD * sum2(n - 1) % MOD;
     ```

2. **题解作者：lndjy**（⭐️⭐️⭐️⭐️）  
   - **亮点**：严格按出题人思路实现，使用 `__int128` 避免溢出，代码模块化。
   - **代码片段**：  
     ```cpp
     // 第一个式子计算
     ans = ans + ((m*m*n)%p)*sum(n-1) % p;
     ```

3. **题解作者：ynxynx**（⭐️⭐️⭐️⭐️）  
   - **亮点**：逆元处理巧妙，代码简洁，附带调试经验提醒（如除以2的细节）。
   - **代码片段**：  
     ```cpp
     w = m*((x*(x-1)/2%mod + (n-x)*(n-x+1)/2%mod))%mod; // 注意除以2
     ```

---

### **最优思路提炼**
1. **分治容斥**：将问题分解为三部分，分别计算后合并结果。
2. **公式化计算**：用等差数列和平方和公式将复杂度从 `O(n²)` 降至 `O(1)`。
3. **排序递推**：对障碍点排序后线性计算绝对值和，避免双重循环。

---

### **同类型题目**
1. **洛谷 P1257**：平面内最近点对（曼哈顿距离）。  
2. **洛谷 P3182**：障碍点间最短路径计数。  
3. **洛谷 P1665**：网格图路径统计（组合数学）。

---

### **个人心得摘录**
- **ynxynx**：“忘记除以二导致调试两小时”——强调公式推导的细致。
- **lzy20091001**：“注意被6整除的问题”——模运算中需处理分母因式分解。

---

### **可视化设计**
#### **动画方案**
1. **分步演示**：  
   - **步骤1**（绿色高亮）：展示无障碍总贡献的行、列公式推导。  
   - **步骤2**（红色高亮）：逐个障碍点计算贡献并累减。  
   - **步骤3**（蓝色高亮）：排序障碍点，动态绘制递推过程。

2. **复古像素风格**：  
   - 用8位网格表示地图，障碍点用闪烁像素标记。  
   - 音效：计算完成时播放“滴”声，错误时播放“哔”声。

#### **代码片段（Canvas示例）**
```javascript
// 绘制无障碍贡献公式
ctx.fillStyle = "#00FF00"; // 绿色
ctx.fillText("m² * [nΣi - Σi²]", 100, 50);
// 障碍点递推动画
for (let i = 1; i < k; i++) {
    drawLine(x[i], y[i], x[i+1], y[i+1], "#FF0000"); // 红色连线
    playSound("step.wav"); // 步进音效
}
```

---
处理用时：75.09秒
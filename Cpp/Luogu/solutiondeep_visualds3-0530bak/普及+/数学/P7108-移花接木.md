# 题目信息

# 移花接木

## 题目背景


遥远的圣地生长着一棵不为人知的灵树，或有万山之高。

但有一日，藏匿于根系的腐朽力量爆发，灵树已无法支撑往日屹立冲天的高度。

## 题目描述

灵树最初的形态可以看作一棵高度为 ${10}^{{10}^{{10}^{10}}}$ 的满 $a$ 叉树，高度定义为根结点到叶子结点之间的边数。

受腐朽力量影响，灵树只能维持高度**恰好**为 $h$ 的满 $b$ 叉树形态。为了转换至该形态，灵树有两种魔法：

- 移花：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点），移除这条边以及以 $v$ 为根的**整棵子树**。
- 接木：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点）和一个结点 $w$（$w$ 不能是 $v$ 子树中或已移除的结点），将这条边原先 $u$ 一端**改接**到 $w$。**该魔法只能在根结点到** $\boldsymbol{u}$ **之间的边数** $\le 10^{10^{10}}$ **时使用。**

灵树累积的魔法力量有限，它不得不用最少次数的魔法完成转换。这是个漫长的过程，即使次数最少也会显得异常大，你只需要求出最少次数对 $10^9 + 7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**

下为 $a=1$，$b=2$，$h=1$ 时的两步转换过程，图中高度极大的冗余子树已用省略号代替。

![](https://cdn.luogu.com.cn/upload/image_hosting/p32s9v96.png)

可以证明，该数据的答案不可能低于 $2$。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (3 points)：$h = 0$。
- Subtask #2 (4 points)：$a = b$。
- Subtask #3 (8 points)：$a = 1$。
- Subtask #4 (8 points)：$b = 1$。
- Subtask #5 (17 points)：$h \le 10$。
- Subtask #6 (15 points)：$h \le 10^6$，各测试点存在 $\overline{a},\overline{b}$，其数据满足 $a=\overline{a}$，$b=\overline{b}$。
- Subtask #7 (15 points)：$h \le 10^6$。
- Subtask #8 (30 points)：无特殊限制。

所有测试点（样例除外）均含有 $10^6$ 组数据，即 $T = 10^6$。请务必采用较快的 IO（输入/输出）方式。

对于所有的数据，保证 $1 \le a,b \le 10^9$，$0 \le h \le 10^9$。

## 样例 #1

### 输入

```
2
1 2 1
3 2 1
```

### 输出

```
2
7
```

# AI分析结果



### 唯一算法分类
**组合数学**

---

### 综合分析与结论
#### 核心思路
将无穷高的满 $a$ 叉树转换为高度 $h$ 的满 $b$ 叉树，最少操作次数的数学推导如下：

1. **关键公式推导**  
   - **当 $a < b$**：最优策略为利用接木操作补充子树，最终删除多余的叶子。总操作次数为 $a \cdot b^h$。  
   - **当 $a > b$**：需逐层删除多余子树，总操作次数为 $(a-b) \cdot \frac{b^h-1}{b-1} + a \cdot b^h$（需特判 $b=1$）。  
   - **特殊情况**：$h=0$、$a=1$、$b=1$ 需单独处理。

2. **解决难点**  
   - **等比数列求和**：快速计算 $\sum_{k=0}^{h-1} b^k = \frac{b^h-1}{b-1}$。  
   - **贪心优化**：在 $a < b$ 时，通过接木复用待删除的子树，减少总操作次数。

3. **可视化设计**  
   - **动态分层展示**：用不同颜色标记每一层的增删操作，例如：  
     - 红色标记 $a > b$ 时的删除层  
     - 绿色标记 $a < b$ 时的接木层  
   - **复古像素动画**：以 8-bit 风格展示公式推导流程，每个步骤触发音效：  
     - 计算 $b^h$ 时播放快速幂的“能量充能”音效  
     - 完成求和公式时播放“通关”音效  

---

### 题解清单（≥4星）

1. **AsunderSquall（★★★★★）**  
   - **亮点**：清晰的分类讨论，完整覆盖所有边界条件；代码简洁高效，使用快速幂和逆元优化。  
   - **心得摘录**：“注意 $b=1$ 时的特判，否则会除以零。”

2. **AuCloud（★★★★☆）**  
   - **亮点**：用图形化例子解释操作步骤，辅助理解数学公式；提供详细的推导流程图。  
   - **心得摘录**：“画图好难，但用字符画也能直观展示操作。”

3. **y0y68（★★★★☆）**  
   - **亮点**：代码中直接调用等比数列求和函数，逻辑模块化；强调预处理逆元优化计算。  

---

### 代码实现与核心逻辑
#### 关键代码片段
```cpp
int ksm(int x, int y) { // 快速幂
    int ret = 1;
    while (y) {
        if (y & 1) ret = ret * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return ret;
}

int solve(int a, int b, int h) {
    if (h == 0) return a % mod;
    if (a == b) return ksm(a, h + 1);
    if (b == 1) return ((a-1)*h + a) % mod;

    int bh = ksm(b, h);
    if (a < b) return (a * bh) % mod;

    // 处理 a > b 的情况
    int numerator = (bh - 1 + mod) % mod;
    int denominator = (b == 1) ? 1 : ksm(b-1, mod-2);
    int sum = (a - b) * numerator % mod * denominator % mod;
    return (sum + a * bh) % mod;
}
```

#### 核心思想
- **快速幂**：高效计算 $b^h \mod (10^9+7)$。  
- **逆元优化**：通过费马小定理计算 $\frac{1}{b-1}$，避免浮点运算。  
- **分类特判**：单独处理 $b=1$ 等边界条件，保证公式正确性。

---

### 类似题目推荐
1. **P1226 【模板】快速幂**  
   - 快速幂的经典模板题，巩固指数运算优化。

2. **P1306 斐波那契公约数**  
   - 结合数论与矩阵快速幂，拓展数学推导能力。

3. **P1495 曹冲养猪**  
   - 中国剩余定理与模运算应用，强化组合数学思维。

---

### 可视化与复古动画设计
#### 动画流程
1. **初始化**：以像素风格绘制满 $a$ 叉树，根节点为 8-bit 方块。  
2. **分层计算**：  
   - 红色闪烁标记当前层的增删操作次数。  
   - 显示公式 $\sum b^k$ 的动态累加过程。  
3. **音效触发**：  
   - 每完成一层计算时播放“滴答”音效。  
   - 最终答案出现时播放 8-bit 胜利音乐。  

#### 复古 UI
- **颜色方案**：16 色调色板，根节点用黄色，叶子用绿色。  
- **Canvas 绘制**：用网格布局模拟树结构，每个节点为 8x8 像素方块。  
- **自动演示**：按空格键逐步执行，按 `A` 键开启 AI 自动推导模式。

---

### 个人心得
- **调试教训**：忘记处理 $b=1$ 导致 WA，需加强边界测试。  
- **优化技巧**：预处理逆元将计算复杂度从 $O(\log h)$ 降为 $O(1)$。  
- **思维突破**：发现 $a < b$ 时总操作次数仅与叶子层相关，是贪心的关键。

---
处理用时：69.27秒
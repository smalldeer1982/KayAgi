# 题目信息

# 「PMOI-1」抽奖

## 题目描述

活动奖池中共有 $n$ 种道具，dead_X 有 $m$ 张兑奖券。一张兑奖券可以兑换成一次抽奖机会或 $114514$ 金币。

dead_X 决定将一部分兑奖券拿来抽奖，并将剩下的兑奖券兑换成金币。

在一次抽奖机会中，dead_X 会等概率得到所有奖池中一款道具的 $1919810$ 秒**体验卡**。

由于 dead_X 在活动中买了 VIP 卡，他可以在所有抽奖结束后选择一款**抽奖得到**的体验卡，将所有这种类型的体验卡上交，并得到对应种类的**永久道具**。

注意，dead_X 可以不使用这个功能，但是不可以使用多于一次。

有选择困难症的 dead_X 想知道，有多少种可能的**活动结果**。

两种活动结果不同，当且仅当 dead_X 获得的金币不同，或者在任何一次抽奖中获得的体验卡不同（即抽到体验卡形成的序列不同），或者获得的永久道具不同。

注意，抽奖中获得的都是体验卡，最后选择的永久道具和体验卡在哪一次抽出没有关系。

------------

Update 2023.11.16：出题人看自己好几年前写的题面绷不住了，补一份形式化题面。

定义一个序列的权值是其不同元素个数 $+1$，例如 $[1,9,2,6,8,1,7]$ 的权值是 $7$。

对于所有长度 $\in[0,m]$，每个数 $\in [1,n]$ 的整数序列，求其权值和对 $10^9+7$ 取模的值。

## 说明/提示

【样例解释】

以下为第二组测试数据所有可能的方案：

假设两种物品分别为 $A$ 和 $B$。

1. 兑换 $229028$ 金币。
1. 兑换 $114514$ 金币，获得 $A$ 体验卡。
1. 兑换 $114514$ 金币，获得 $B$ 体验卡。
1. 兑换 $114514$ 金币，获得 $A$ 永久道具。
1. 兑换 $114514$ 金币，获得 $B$ 永久道具。
1. 第一次获得 $A$ 体验卡，第二次获得 $A$ 体验卡。
1. 第一次获得 $A$ 体验卡，第二次获得 $B$ 体验卡。
1. 第一次获得 $B$ 体验卡，第二次获得 $A$ 体验卡。
1. 第一次获得 $B$ 体验卡，第二次获得 $B$ 体验卡。
1. 第一次获得 $A$ 体验卡，第二次获得 $A$ 体验卡，指定 $A$ 为永久道具。
1. 第一次获得 $A$ 体验卡，第二次获得 $B$ 体验卡，指定 $A$ 为永久道具。
1. 第一次获得 $B$ 体验卡，第二次获得 $A$ 体验卡，指定 $A$ 为永久道具。
1. 第一次获得 $A$ 体验卡，第二次获得 $B$ 体验卡，指定 $B$ 为永久道具。
1. 第一次获得 $B$ 体验卡，第二次获得 $A$ 体验卡，指定 $B$ 为永久道具。
1. 第一次获得 $B$ 体验卡，第二次获得 $B$ 体验卡，指定 $B$ 为永久道具。

【数据范围】
- Subtask1（10pts）：$n,m\leq5,T\le25$；
- Subtask2（10pts）：$n=1$；
- Subtask3（10pts）：$m=1$；
- Subtask4（20pts）：$n,m\leq1000,T\leq 5$；
- Subtask5（20pts）：$\sum m\leq10^6$；
- Subtask6（30pts）：无特殊限制。

对于 $100\%$ 的数据满足，$1\le n,m\leq 10^9$，$1\le T\leq 10^5$。

## 样例 #1

### 输入

```
5
2 1
2 2
3 3
114 514
1919810 7872754```

### 输出

```
5
15
115
338602801
30498159```

# AI分析结果



---

### **唯一算法分类**
组合数学

---

### **综合分析与结论**

#### **题目核心与难点**
- **核心问题**：计算所有长度 $0 \leq k \leq m$ 的序列的权值和，权值定义为序列不同元素个数 $+1$。
- **关键推导**：  
  1. 对每个长度 $k$，计算所有序列的权值和：
     $$
     \text{总权值} = \sum_{k=0}^m \left( n^{k+1} + n^k - n \cdot (n-1)^k \right)
     $$
  2. 拆解为三个等比数列求和：
     - $\sum n^{k+1}$：首项 $n$，公比 $n$；
     - $\sum n^k$：首项 $1$，公比 $n$；
     - $\sum n \cdot (n-1)^k$：首项 $n$，公比 $n-1$。

- **解决难点**：
  - **公式推导**：利用组合数学思想，统计每个元素是否出现的概率，转化为等比数列求和。
  - **边界处理**：特判 $n=1$ 或 $n=2$，避免除以零。

#### **可视化设计思路**
1. **分步动画**：
   - **步骤1**：展示每个 $k$ 的权值和计算，高亮 $n^{k+1}$（蓝色）、$n^k$（绿色）、$-n \cdot (n-1)^k$（红色）。
   - **步骤2**：累加每个 $k$ 的贡献，用动态进度条显示总答案的增长。
   - **步骤3**：对 $n=1$ 或 $n=2$，弹出提示框解释特判逻辑。

2. **复古像素风格**：
   - 使用 8-bit 像素字体和色块绘制公式项。
   - 音效：计算完成时播放短促“滴”声，错误时播放低沉音效。

---

### **题解清单（≥4星）**

#### **题解1：wwlw（5星）**
- **亮点**：
  - 公式推导清晰，拆解为三个等比数列，代码结构模块化。
  - 使用 `calc` 函数统一处理等比数列求和，可读性强。
- **代码片段**：
  ```cpp
  ll calc(ll x, ll y) {
      if (!x) return 1;
      if (x == 1) return (y + 1) % Mod;
      return (qpow(x, y + 1) - 1) * qpow(x - 1, Mod - 2) % Mod;
  }
  ```

#### **题解2：dead_X（4星）**
- **亮点**：
  - 从期望角度解释权值计算，提供直观的数学意义。
  - 特判逻辑简洁，直接处理 $n=1$ 和 $n=2$。
- **代码片段**：
  ```cpp
  if (n == 1) printf("%lld\n", ((m << 1) + 1) % p);
  else if (n == 2) printf(...); // 处理 n=2
  ```

---

### **最优思路提炼**

#### **关键公式推导**
- 总权值拆解为：
  $$
  \text{总答案} = \sum_{k=0}^m \left( n^{k+1} + n^k - n \cdot (n-1)^k \right)
  $$
- **等比数列求和**：
  - $\sum_{k=0}^m n^k = \frac{n^{m+1} - 1}{n - 1}$（$n \neq 1$）；
  - $\sum_{k=0}^m (n-1)^k = \frac{(n-1)^{m+1} - 1}{n - 2}$（$n \neq 2$）。

#### **代码优化技巧**
- **快速幂与逆元**：用快速幂计算大指数，逆元处理除法取模。
- **特判优化**：直接处理 $n=1$ 和 $n=2$，避免复杂分支逻辑。

---

### **同类型题与常见套路**
- **常见套路**：
  - 组合计数中利用概率/期望简化计算。
  - 等比数列求和结合逆元处理模运算。
- **推荐题目**：
  1. [洛谷 P3811](https://www.luogu.com.cn/problem/P3811)：乘法逆元模板题。
  2. [洛谷 P6154](https://www.luogu.com.cn/problem/P6154)：路径计数与组合数学。
  3. [洛谷 P1495](https://www.luogu.com.cn/problem/P1495)：组合数取模与分治。

---

### **核心代码实现**

#### **快速幂与逆元**
```cpp
ll qpow(ll x, ll y) {
    ll ret = 1;
    while (y) {
        if (y & 1) ret = ret * x % Mod;
        x = x * x % Mod;
        y >>= 1;
    }
    return ret;
}

ll inv(ll x) { return qpow(x, Mod - 2); }
```

#### **等比数列求和**
```cpp
ll calc_geo(ll a, ll r, ll m) {
    if (r == 1) return (a * (m + 1)) % Mod; // 公比为1
    ll r_pow = qpow(r, m + 1);
    return a * (r_pow - 1) % Mod * inv(r - 1) % Mod;
}
```

---

### **可视化与复古游戏化设计**
- **Canvas 动画**：
  - **像素绘制**：用色块表示 $n^{k+1}$（蓝色方块）、$n^k$（绿色方块）、$-n(n-1)^k$（红色方块）。
  - **步进控制**：用户点击“Next”按钮逐步计算每个 $k$ 的贡献。
- **音效触发**：
  - 计算完成时播放 `audio_beep.wav`（8-bit 风格音效）。
  - 错误时播放 `audio_error.wav`。
- **自动演示模式**：点击“AI Run”自动播放，模拟解题过程。

---
处理用时：178.61秒
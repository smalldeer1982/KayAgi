# 题目信息

# 「Wdsr-3」永远与须臾的走廊

## 题目背景

永远亭是迷途森林里的不可思议的屋子。

为了躲避月之使者的到来，也是为了防御，永远亭内被布下了一条无尽的长廊。困在其中的对手无法触及到真实，陷入到永远与须臾的陷阱里去。

不过，无尽的长廊 $S$ 毕竟只是单一有限走廊 $S_0$ 的无限循环，其本质是永远亭的主人蓬莱山辉夜及八意永琳设下的圈套。正因该长廊是通过辉夜的能力实现的，因此辉夜可以通过修改该「有限长的」走廊 $S_0$，进而作用于「无限长的」长廊 $S$。这意味着有限的修改可以创造出无限的变动。

光秃秃的长廊显得单调，也难以起到掩人耳目的目的。辉夜决定在长廊上绘制象征着月初的「上弦月」和象征着月末的「下弦月」，以达到图案交错重叠的目的。为了方便起见，「上弦月」可以被近似认为是左括号，而「下弦月」可以被近似认为是右括号。作为优雅的月之都的公主，当然会有不少条条框框——轮到你帮助辉夜满足她的要求了。

## 题目描述

辉夜希望创造一个无限长的括号序列 $S$ 作为永远亭长廊的绘制图案，它由一个长度为 $n$ 的括号序列 $S_0$ 不断重复而成。

我们称一个括号序列 $T$ 是合法的，当且仅当它可以由以下方式生成：

- $\verb!()!$ 是一个合法的括号序列。  
- 如果 $A$ 是合法括号序列，那么 $\verb!(!A\verb!)!$ 同样是一个合法括号序列。  
- 如果 $A,B$ 都是合法括号序列，那么 $AB$（即 $A,B$ 拼接）同样是一个合法括号序列。

例如，$\verb!(()())!,\verb!()()!,\verb!((()())())!$ 都是合法括号序列；而 $\verb!)(!,\verb!(()!,\verb!())(()!$ 均不是合法括号序列。

现在辉夜已经确定了 $S_0$ 当中一部分的符号。你需要求出，「在剩下来的单元上绘制括号，使得这条无限长的长廊上可以找到**无限长的**合法括号序列」的方案数。两种方案不同仅当两种方案中有至少一个位置的 `?` 被替换成了不同的字符。输出它对 $998,244,353$（一个大质数）取模后的结果。

## 说明/提示

#### 样例 1 解释

符合条件的方案共有三种：$\verb!(())!$、$\verb!()()!$ 和 $\verb!())(!$。

- 第一种方案，$\overbrace{\text{\tt\textcolor{red}{(())}\textcolor{blue}{(())}\texttt{...}\textcolor{red}{(())}\textcolor{blue}{(())}}}^{\text{无穷个}}$ 可以找到无限长的合法括号序列。
- 第二种方案，$\overbrace{\text{\tt\textcolor{red}{()()}\textcolor{blue}{()()}\texttt{...}\textcolor{red}{()()}\textcolor{blue}{()()}}}^{\text{无穷个}}$ 同样可以找到无限长的合法括号序列。
- 第三种方案，$\text{\tt\textcolor{red}{())}}\overbrace{\text{\tt\textcolor{red}{(}\textcolor{blue}{())(}\texttt{...}\textcolor{red}{())(}\textcolor{blue}{())}}}^{\text{无穷个}}\text{\tt\textcolor{blue}{(}}$ 仍然可以找到无穷长的括号序列。

可以证明，不存在其他方案。

#### 数据范围及约定

$$
\def{\arraystretch}{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le } & \textbf{特殊性质} & \textbf{分值} \cr\hline
1 & 20 & - & 20 \cr\hline
2 & 10^5 & \text{A} & 10 \cr\hline
3 & 10^5 & \text{B} & 10 \cr\hline
4 & 10^5 & - & 60 \cr\hline
\end{array}
$$

**特殊性质** $\textbf{A}$：保证字符串里仅出现 $\verb!(!$ 和 $\verb!)!$。  
**特殊性质** $\textbf{B}$：保证字符串里仅出现 $\verb!?!$。

对于全部数据，满足 $1\le n\le 10^5$，且字符串里仅出现 $\verb!(!,\verb!)!,\verb!?!$ 三种字符。

## 样例 #1

### 输入

```
4
(???
```

### 输出

```
3```

## 样例 #2

### 输入

```
8
(???))??```

### 输出

```
10```

# AI分析结果



**数学分类选择**  
组合数学  

---

**题解思路、算法要点与解决难点**  

- **核心逻辑**：无限循环的括号序列合法的充要条件是原序列中左右括号数量相等。  
  - **必要性**：若数目不等，无限循环会导致累积高度趋向±∞，无法形成合法序列。  
  - **充分性**：数目相等时，折线循环的最低点可构成无限合法序列（详见折线图分析）。  
- **关键公式**：  
  - 设原左括号数为 $l$，右括号数为 $r$，问号数为 $q$。需满足 $l + x = r + (q - x) = n/2$，解得 $x = \frac{n}{2} - l$。  
  - 方案数为组合数 $C(q, x)$，需预处理阶乘与逆元加速计算。  
- **解决难点**：  
  - **边界处理**：奇数长度直接无解；原括号数超过 $n/2$ 时无解。  
  - **组合数优化**：预处理阶乘与逆元，利用费马小定理求模意义下的组合数。  

---

**题解评分 (≥4星)**  

1. **囧仙 (5星)**  
   - 思路清晰，代码简洁高效。  
   - 预处理阶乘与逆元，组合数计算优化到位。  
   - 处理了所有边界条件（奇数、原括号数超限）。  

2. **2huk (4星)**  
   - 使用预处理阶乘和逆元，代码规范。  
   - 逻辑完整，但变量命名可读性稍逊。  

3. **daniEl_lElE (4星)**  
   - 代码简短，直接计算组合数。  
   - 未预处理阶乘，但通过动态计算逆元保证效率。  

---

**最优思路或技巧提炼**  

1. **折线图分析法**：通过将括号序列转化为折线图，直观证明左右括号数目相等的必要性。  
2. **组合数预处理**：利用阶乘和逆元预处理，快速计算模意义下的组合数。  
3. **边界剪枝**：先判断奇偶性和原括号数超限，避免无效计算。  

---

**同类型题或类似算法套路**  

- **组合数学模型**：涉及固定数量的元素选择问题（如括号匹配、子集选择）。  
- **模运算优化**：预处理阶乘与逆元，快速计算组合数模大质数。  

---

**推荐相似题目**  

1. [P1641 [SCOI2010] 生成字符串](https://www.luogu.com.cn/problem/P1641)  
2. [P1355 神秘大三角](https://www.luogu.com.cn/problem/P1355)（几何+组合思维）  
3. [P3223 [HNOI2012] 排队](https://www.luogu.com.cn/problem/P3223)  

---

**个人心得摘录**  

> “这题看似复杂，实则是组合数水题。关键要想到无限循环后的折线趋势分析。”  
> —— 某题解作者  

---

**可视化与算法演示**  

**动画方案设计**：  
1. **折线图动态绘制**：  
   - **初始状态**：展示原序列的折线图，用红色标记当前高度。  
   - **循环扩展**：动态添加循环节，显示折线逐渐上升/下降或周期性波动。  
   - **合法判定**：若高度周期性归零，高亮最低点作为合法序列起点。  

2. **组合数计算流程**：  
   - **步骤高亮**：  
     1. 输入字符串统计 $l, r, q$。  
     2. 判断奇偶性（红色框提示奇数直接返回0）。  
     3. 计算目标左括号数 $x = n/2 - l$，若 $x < 0$ 或 $q < x$，显示无解。  
     4. 计算组合数 $C(q, x)$，动态展示阶乘与逆元计算过程。  

**复古像素风格实现**：  
- **Canvas 绘制**：用 8-bit 像素风格绘制折线图，每步计算时播放经典音效。  
- **音效触发**：  
  - 正确步骤：8-bit 上升音调。  
  - 错误条件（如奇数）：低沉故障音。  

---

**代码片段 (核心组合数计算)**  

```cpp
const int MOD = 998244353;
int fac[MAXN], inv[MAXN];

void init() {
    fac[0] = 1;
    for (int i = 1; i < MAXN; i++) 
        fac[i] = 1LL * fac[i-1] * i % MOD;
    inv[MAXN-1] = pow_mod(fac[MAXN-1], MOD-2);
    for (int i = MAXN-2; i >= 0; i--) 
        inv[i] = 1LL * inv[i+1] * (i+1) % MOD;
}

int C(int n, int k) {
    if (k < 0 || k > n) return 0;
    return 1LL * fac[n] * inv[k] % MOD * inv[n-k] % MOD;
}
```

---

**总结**  

本题通过组合数学模型和边界剪枝高效解决。核心在于理解无限循环合法序列的充要条件，并利用预处理优化组合数计算。可视化设计中，折线图的动态演示能直观展示合法条件，复古像素风格增强学习趣味性。

---
处理用时：82.69秒
# 题目信息

# 「WHOI-2」ぽかぽかの星

## 题目背景

![](bilibili:BV16J411x7nS)

你在雪洞里喝着热可可数星星。但这次，星星换成了数列，不过聪明的你一定能数清楚数列的吧。

## 题目描述

有多少个长度为 $n$ 的**正整数**数列 $a_i$ 满足：

- $0<a_1\leq a_2\leq a_3\dots \leq a_n\leq k$。
- $\forall i\not = j,a_i+a_j\not = k+1$。

答案对 $10^9+7$ 取模。

## 说明/提示

**本题采用捆绑测试**

- $\text{subtask1(20pts)}:T=5,1\leq n,k\le5$。
- $\text{subtask2(80pts)}:$ 无特殊限制。


对于 $100\%$ 的数据，$T\leq100,1\le n,k\le 5\times 10^6,1\leq  \sum n,  \sum  k\le6\times 10^7$。



## 样例 #1

### 输入

```
3
2 2
1145 1419
19198 12321```

### 输出

```
2
66937457
949924930```

# AI分析结果



**唯一算法分类**: 组合数学

---

### **题解思路、算法要点与解决难点**
1. **问题转化**: 将非递减数列转换为各数的出现次数，并处理不能同时出现的数对（即和为k+1的数）。
2. **奇偶分组**:
   - **偶数k**: 将数分为k/2组，每组中的两个数不能同时出现。选择i组，每组选一个方向，用组合数计算方案。
   - **奇数k**: 中间数最多出现一次，拆分为中间数为0次和1次两种情况，分别计算组合数。
3. **组合数公式**:
   - **偶数**: $\sum_{i=1}^{\min(n, m)} \binom{m}{i} \cdot \binom{n-1}{i-1} \cdot 2^i$（m=k/2）
   - **奇数**: 分两种情况求和，中间数不出现时用偶数公式，出现时额外分配剩余次数。
4. **优化技巧**: 预处理阶乘、逆元、2的幂次，快速计算组合数。

---

### **题解评分 (≥4星)**
1. **Otomachi_Una (5星)**: 思路清晰，分类明确，公式推导完整，代码简洁高效。
2. **TernaryTree (4星)**: 详细分析哈希表条件，分类讨论中间数情况，数学推导严谨。
3. **Sellaris (4星)**: 代码实现完整，预处理优化到位，注释和变量命名清晰。

---

### **最优思路或技巧提炼**
- **分组配对法**: 将和为k+1的数对分组，每组只能选其一，转化为组合问题。
- **隔板法应用**: 分配n个元素到i组，每组至少一个元素，用$\binom{n-1}{i-1}$表示。
- **奇偶处理技巧**: 中间数单独特判，拆分为两种独立情况求和。
- **预处理加速**: 提前计算阶乘、逆元、2的幂次，实现O(1)查询组合数。

---

### **同类型题或算法套路**
- **配对禁止问题**: 如禁止某类元素同时出现，可分组后用组合数计算。
- **分奇偶讨论**: 中间元素需特殊处理时，拆分为独立子问题。
- **隔板法变体**: 将元素分配问题转化为组合数计算。

---

### **推荐相似题目**
1. [P4345 [SHOI2015]超能粒子炮·改](https://www.luogu.com.cn/problem/P4345)
2. [P3773 [CTSC2017]吉夫特](https://www.luogu.com.cn/problem/P3773)
3. [P4929 【模板】组合数取模](https://www.luogu.com.cn/problem/P4929)

---

### **个人心得摘录**
- **预处理是关键**: 大规模组合数需预先计算阶乘和逆元，避免超时。
- **特判不可少**: n=1或k=1时需单独处理，否则易错。
- **公式推导严谨性**: 必须严格验证样例，确保分类讨论的正确性。

---

### **可视化与算法演示**
- **像素风格动画**: 用不同颜色区分已选/未选组，动态展示分组和分配过程。
- **关键步骤高亮**: 显示组合数计算时的高亮公式$\binom{m}{i} \cdot 2^i$。
- **音效提示**: 完成组选择或分配时播放8-bit音效，增强交互体验。
- **自动推导模式**: 逐步展示奇偶情况的分组逻辑，单步调节速度。

```cpp
// Sellaris的代码核心片段（预处理+计算）
void preC() {
    jc[0] = jc_inv[0] = 1;
    for (int i = 1; i < maxn; i++) jc[i] = jc[i-1] * i % mo;
    jc_inv[maxn-1] = qpow(jc[maxn-1], mo-2);
    for (int i = maxn-2; i >= 1; i--) jc_inv[i] = jc_inv[i+1] * (i+1) % mo;
}

int solve() {
    if (k % 2 == 0) {
        for (int i = 1; i <= min(n, m); i++)
            ans += C(i, m) * C(i-1, n-1) * lg2[i];
    } else {
        // 分两种情况求和，代码略
    }
}
```

---

**可视化设计要点**:
- **颜色方案**: 红/蓝区分奇偶分组，绿色高亮当前计算的组合数项。
- **Canvas绘制**: 网格显示分组和元素分配，动态更新选中组和剩余元素。
- **音效触发**: 当完成一次i的枚举或分配时，播放不同音效，如“选择组”音效和“分配完成”音效。

---
处理用时：145.56秒
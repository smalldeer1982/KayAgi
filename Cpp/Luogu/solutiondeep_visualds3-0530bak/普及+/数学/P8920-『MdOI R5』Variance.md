# 题目信息

# 『MdOI R5』Variance

## 题目背景

Subtask 1~5 为原数据，Subtask 6 为 hack 数据。

## 题目描述

给定两个长度为 $n$ 的整数序列 $a,b$，满足：
- $\forall i\in [1,n),a_i\le a_{i+1},b_i\le b_{i+1}$。

- $\forall i\in [1,n],a_i\le b_i$。

有一个长度为 $n$ 的实数序列 $c$，满足 $c_i\in [a_i,b_i]$，求 $c$ 的方差的最大值。

你只需要输出答案乘上 $n^2$ 之后的结果。容易证明这是一个整数。

### 提示

一个长度为 $n$ 的序列 $a$ 的方差为：$\dfrac{1}{n}\sum\limits_{i=1}^n (a_i-\overline{a})^2$。其中 $\overline{a}=\dfrac{1}{n}\sum\limits_{i=1}^n a_i$。

本题的计算过程中可能会涉及到超过 `long long` 范围的数，此时可能需要用到 `__int128` 进行处理。

我们提供了以下代码，它可以用于输出一个 `__int128` 类型的数：

``` cpp
void print(__int128 x)
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	if(x<10)
	{
		putchar(x+48);
		return;
	}
	print(x/10);
	putchar(x%10+48);
}
```

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 10^6$，$1\le a_i,b_i\le 10^9$。

$\operatorname{Subtask} 1(10\%)$：$n\le 2\times 10^3$，$a_i=b_i\le 10^5$。

$\operatorname{Subtask} 2(20\%)$：$n\le 10$，$a_i,b_i\le 5$。

$\operatorname{Subtask} 3(20\%)$：$n\le 2\times 10^3$，$a_i,b_i\le 10^5$。

$\operatorname{Subtask} 4(20\%)$：$n\le 10^5$，$a_i,b_i\le 2\times 10^3$。

$\operatorname{Subtask} 5(30\%)$：无特殊限制。

#### 样例说明 1

$c$ 只可能为 $(1,10)$。

#### 样例说明 2

一种最优的 $c$ 为 $(1,2,5)$。

## 样例 #1

### 输入

```
2
1 10
1 10```

### 输出

```
81```

## 样例 #2

### 输入

```
3
1 2 3
3 4 5```

### 输出

```
26```

# AI分析结果



## 数学分类选择
**组合数学**

---

## 题解思路、算法要点与解决难点

### 核心思路
方差最大化问题转化为寻找最优断点，使得前段全选 `a[]`，后段全选 `b[]`。通过枚举断点，动态维护总和与平方和，计算每个断点对应的方差值。

### 关键公式推导
方差公式变形为：
$$ n^2 \cdot Var = n \cdot \sum c_i^2 - (\sum c_i)^2 $$
最大化该式即需极端化 `c` 的取值（全左端点或全右端点）。

### 解决难点
1. **单调性证明**：通过反证法证明最优解一定存在单调性，确保只需考虑断点分割。
2. **动态维护优化**：通过增量更新总和与平方和，避免每次重新计算全序列，将时间复杂度优化到 $O(n)$。

---

## 题解评分（≥4星）

### Kubic (⭐⭐⭐⭐⭐)
- **亮点**：代码简洁高效，空间复杂度 $O(1)$，动态维护变量替代预处理。
- **核心代码**：
  ```cpp
  for (int i = n; i; --i) {
      s1 += b[i] - a[i];
      s2 += 1LL * b[i] * b[i] - 1LL * a[i] * a[i];
      ans = max(ans, s2 * n - s1 * s1);
  }
  ```

### David_Mercury (⭐⭐⭐⭐)
- **亮点**：预处理前缀与后缀和，逻辑清晰易理解。
- **核心代码**：
  ```cpp
  for (int i = 0; i <= n; i++) {
      ans = max(ans, (qz2[i] + hz2[i+1]) * n - (qz[i] + hz[i+1]) * (qz[i] + hz[i+1]));
  }
  ```

### strcmp (⭐⭐⭐⭐)
- **亮点**：数学归纳法证明详细，代码动态替换顺序明确。
- **核心代码**：
  ```cpp
  for (re int i = n; i >= 1; i--) {
      s1 += b[i] - a[i], s2 += b[i] * b[i] - a[i] * a[i];
      ans = max(ans, s2 * n - s1 * s1);
  }
  ```

---

## 最优思路或技巧提炼
1. **断点枚举法**：将问题转化为枚举前段全选 `a`、后段全选 `b` 的断点位置。
2. **动态维护变量**：通过增量更新总和与平方和，避免重复计算。
3. **二次函数极值性质**：证明断点处必须取端点值，确保贪心策略正确性。

---

## 同类型题或通用套路
- **极值构造**：在区间选择问题中，极端取值常为最优解（如最大化方差、最小化距离和）。
- **前缀后缀分解**：涉及序列分段最优时，预处理前缀和后缀信息加速计算。

---

## 推荐相似题目
1. [P5142 区间方差](https://www.luogu.com.cn/problem/P5142)  
   **标签**：动态维护、区间查询
2. [P1471 方差](https://www.luogu.com.cn/problem/P1471)  
   **标签**：数学公式变形、线段树维护
3. [CF1111E Tree](https://codeforces.com/problemset/problem/1111/E)  
   **标签**：组合极值、动态规划

---

## 可视化与算法演示（核心数学过程）

### 动画设计
1. **初始化**：显示全选 `a[]` 的数组，右侧显示总和 `S1` 和平方和 `S2`。
2. **断点遍历**：从右向左逐步将 `a[i]` 替换为 `b[i]`，高亮当前替换位置。
3. **数值更新**：动态更新 `S1` 和 `S2`，并计算当前方差值。
4. **最大值追踪**：始终显示当前最大方差值，颜色区分不同断点的贡献。

### 复古像素风格
- **颜色方案**：绿色表示 `a[]`，红色表示 `b[]`，黄色高亮当前操作元素。
- **音效**：替换时触发“滴”声，更新最大值时播放“升级”音效。

---

## 代码实现（核心逻辑）

### Kubic 题解代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 1000005
#define lll __int128
int n, a[N], b[N];
lll s1, s2, ans;

void print(lll x) {
    if (x < 10) { putchar(x + 48); return; }
    print(x / 10); putchar(x % 10 + 48);
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
    for (int i = 1; i <= n; ++i) scanf("%d", &b[i]);
    for (int i = 1; i <= n; ++i) s1 += a[i], s2 += 1LL * a[i] * a[i];
    ans = s2 * n - s1 * s1;
    for (int i = n; i; --i) {
        s1 += b[i] - a[i];
        s2 += 1LL * b[i] * b[i] - 1LL * a[i] * a[i];
        ans = max(ans, s2 * n - s1 * s1);
    }
    print(ans);
    return 0;
}
```

---

## 个人心得摘录
- **动态维护优于预处理**：在处理大数组时，减少空间占用能有效提升代码效率。
- **数学证明先行**：先通过理论证明确定最优解结构，再编写代码，避免盲目尝试。

---
处理用时：140.24秒
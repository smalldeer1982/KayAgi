# 题目信息

# 「TERRA-OI R1」别得意，小子

## 题目背景

战至中途，蓝紫色天空瞬间变为黑压压一片，噬神者身上一些紫色外壳开始脱落，化为更小的蟒蛇，这些小家伙从出现开始便不要命的向你冲过来，刚清理掉这些小家伙，迷雾中忽然涌现出一张血盆大口，噬神者正向你冲击而来......

## 题目描述

现给定一个有 $n$ 段的分段函数，每一段可能是一个一次函数或者一个二次函数，并有 $q$ 次询问，每次询问 $x=k$ 时 $y$ 的取值或是 $y=k$ 与函数有多少个交点。



## 说明/提示

#### 【样例解释 #1】

三段函数分别为 $y=x+2$，$y=x^2-2x+1$，$y=x$。

对于当 $x=4$ 时套入第二段函数可以得到结果为 $9$。

而直线 $y=5$ 只与第一段与第二段函数相交，并且各只有一个交点，所以结果为 $2$。

显而易见，第三个询问对应的直线不与函数相交。

第四个询问虽然与第一段函数交于 $x=0$ 的位置，但 $0$ 不在该函数区间内，故舍去。

------------

#### 【数据范围】

**本题采用捆绑测试。**

| Subtask | Score | $n,q\le$ | limit |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $100$ | 无 |
| $2$ | $15$ | $10^3$ | $r_n\le 5\times 10^3$ |
| $3$ | $20$ | $2\times 10^5$ | 不存在询问 $2$ |
| $4$ | $25$ | $2\times 10^5$ | 不存在二次函数 |
| $5$ | $30$ | $2\times 10^5$ | 无 |

对于 $100\%$ 的数据，$1\le n,q\le 2\times 10^5$，$0\le l_i,r_i\le10^9$，$\forall i\in [1,n],r_i>l_i$ 。

所有的函数系数均在 **$64$ 位有符号整型变量**存储范围内，并且运算结果与每个函数式中任何一项的最大值与最小值不会超过 **$64$ 位有符号整型变量**存储范围。所有询问参数均在 **$32$ 位有符号整型变量**范围内。

（即 $-4\times 10^{18}\le k,a,b,c\le 4\times 10^{18}$，$-10^9\le x\le 10^9$）

------------
#### 【提示】

采用浮点数据时建议使用 long double，避免产生精度问题。

upd：添加一组 hack 数据，未通过会显示为“Unaccepted 100pts”。

## 样例 #1

### 输入

```
3 4
0 3 1 1 2
3 6 2 1 -2 1
6 10 1 1 0
1 4
2 5
2 114514
2 2```

### 输出

```
9
2
0
0```

## 样例 #2

### 输入

```
6 8
0 4 2 1 -4 0 
4 6 1 2 -10 
6 11 1 1 -19 
11 19 2 -1 -30 559 
19 29 1 1 -58 
29 38 1 1 -68 
1 11
2 4
2 -1
1 21
2 -5
2 2
1 34
2 1
```

### 输出

```
-8
1
4
-37
1
2
-34
2
```

# AI分析结果



### 唯一算法分类
**无算法分类**

---

### 题解思路、算法要点与解决难点

#### 核心思路
1. **操作1（求x=k的y值）**  
   - 二分查找确定x所在的函数区间，代入对应公式计算。
   
2. **操作2（求y=k的交点数）**  
   - **一次函数**：值域为连续区间，直接记录差分标记。
   - **二次函数**：拆分为对称轴两边的单调区间，分别计算值域区间，处理顶点是否为整数的特例。

#### 关键数学方法与难点
- **二次函数拆分**：  
  若对称轴在区间内，需拆分为两个单调区间，顶点处可能产生单交点（顶点y为整数时）。
- **区间开闭处理**：  
  值域区间的左右端点需根据函数单调性调整（如左开右闭）。
- **浮点精度控制**：  
  判断顶点是否为整数时，需用`long double`避免精度丢失。

#### 数据结构与优化
- **差分标记**：用`map`或排序数组记录区间端点，排序后求前缀和。
- **离散化**：将大范围值域压缩为离散事件点，优化空间效率。

---

### 题解评分（≥4星）
1. **jifbt（5星）**  
   - **亮点**：代码简洁，通过拆分函数区间为差分事件，排序后前缀和查询。
   - **核心代码**：
     ```cpp
     void add(ll i, db l, db r) {
         db x = calc(i, l), y = calc(i, r);
         if (x < y) diff[++cnt] = {floor(x)+1, 1}, diff[++cnt] = {floor(y)+1, -1};
         else diff[++cnt] = {ceil(y), 1}, diff[++cnt] = {ceil(x), -1};
     }
     ```
   
2. **MCRS_lizi（4星）**  
   - **亮点**：详细处理二次函数顶点特例，使用`map`维护差分。
   - **难点处理**：顶点的浮点数判断（`fabs(...) <= 1e-9`）。

3. **kbtyyds（4星）**  
   - **亮点**：离散化+差分处理，分类讨论二次函数单调性。

---

### 最优思路提炼
1. **差分事件法**  
   - 每个函数段转化为若干值域区间的差分标记。
   - 排序所有标记后求前缀和，查询时二分定位。

2. **二次函数拆分策略**  
   - 对称轴在区间内时，拆分为两个单调区间。
   - 顶点为整数时，单独处理交点数。

---

### 同类型题与通用套路
- **通用套路**：  
  - **区间覆盖计数** → 差分标记 + 前缀和。
  - **分段函数处理** → 二分查找 + 分类讨论。
- **同类题目**：  
  1. **P1257 平面上的最接近点对**（几何区间处理）。
  2. **P1496 火烧赤壁**（区间覆盖差分）。
  3. **P3400 仓鼠的统计**（离散化+前缀和）。

---

### 个人心得摘录
- **MCRS_lizi**：  
  > “二次函数的顶点处理耗费三四天，需精密浮点运算和分类讨论。”
- **聊机**：  
  > “动态开点线段树在极端数据下可能MLE，差分更高效。”

---

### 可视化与算法演示
#### 动画设计
1. **像素风格演示**：  
   - **颜色标记**：  
     - 红色：当前处理的函数段。
     - 绿色：已处理的差分区间。
   - **Canvas绘制**：  
     - 绘制x轴和y轴，函数段显示为不同颜色线段。
     - 每次处理函数时，动态显示值域区间的差分标记。

2. **关键步骤高亮**：  
   - **二次函数拆分**：对称轴处闪烁显示，拆分为两段。
   - **顶点特判**：顶点处显示黄色标记，若为整数则触发音效。

3. **音效与交互**：  
   - **音效**：成功拆分时播放“叮”，错误时“哔”。
   - **步进控制**：支持暂停/继续，调整动画速度。

#### 复古游戏化设计
- **8位像素UI**：  
  - 函数段用8位色块表示，值域区间为闪烁方块。
- **积分系统**：  
  - 正确处理一个函数段得10分，连击加成。

---

### 代码片段（jifbt的核心逻辑）
```cpp
// 添加函数段的差分事件
void add(ll i, db l, db r) {
    db x = calc(i, l), y = calc(i, r);
    if (x < y) {
        diff[++cnt] = {floor(x) + 1, 1};
        diff[++cnt] = {floor(y) + 1, -1};
    } else {
        diff[++cnt] = {ceil(y), 1};
        diff[++cnt] = {ceil(x), -1};
    }
}

// 处理二次函数对称轴
db z = -b[i] / (2.l * a[i]);
if (l[i] < z && z <= r[i]) {
    add(i, l[i], z);
    add(i, z, r[i]);
} else {
    add(i, l[i], r[i]);
}
```

---

**答案输出完毕**

---
处理用时：69.12秒
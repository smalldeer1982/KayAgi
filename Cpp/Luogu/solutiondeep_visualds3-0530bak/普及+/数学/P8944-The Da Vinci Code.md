# 题目信息

# The Da Vinci Code

## 题目背景

> 圣杯在罗斯琳教堂下静待。  
> 大师杰作掩映中相拥入眠。  
> 剑刃圣杯守护着她的门宅。  
> 星空下她可安息无碍。

好的题目不需要花里胡哨的背景。

## 题目描述

给定一个长度为 $n$ 的数列 $a$，初始情况下 $a_i=i$。

另有一个取值在 $[1,n]$ 内的随机的整数 $x$，它取 $i$ 的概率为 $b_i$。

接下来进行 $k$ 次操作，每次**均匀随机**地选两个 $[1,n]$ 中的整数 $i,j$（允许 $i=j$），交换 $a_i,a_j$ 的值（如果 $i=j$ 则什么也不干）。问最后 $x$ 在位置 $i$ 上的概率，你需要对所有 $1\leq i\leq n$ 求出答案。你需要输出答案模 $3221225473$ 的值。

我们定义 $x$ 在位置 $i$ 上指 $a_i=x$。

## 说明/提示

#### 【样例解释】

对于样例 #1：

$b$ 数组为 $\{2134949164 ,1086276310\}$，操作 $9$ 次后 $x$ 在两个位置的概率均为 $\dfrac12$。

对于样例 #2：

$b$ 数组为 $\{1863763622,1043615898,1055155266,1556793106,1763540175,1239801170,1141007183\}$。

#### 【数据范围】
对于 $100\%$ 的数据：

* $2\leq n\leq2\times10^7$，$0\leq k,seed<2^{64}$。
* $1<b_i<3221225473$，$\sum\limits_{i=1}^n b_i\equiv 1\pmod{3221225473}$。
* 数据保证 $1<b_n<3221225473$ 且 $3221225473$ 是质数。

---

**本题采用捆绑测试**。

| $\text{Subtask}$ |$n\le$|$k\le$|分值|
|:-:|:-:|:-:|:-:|
|$0$|$2$|$2^{64}-1$|$1$|
|$1$|$5$|$5$|$4$|
|$2$|$200$|$200$|$6$|
|$3$|$200$|$2^{64}-1$|$9$|
|$4$|$2000$|$2000$|$7$|
|$5$|$2\times10^7$|$1$|$5$|
|$6$|$10^6$|$10^6$|$8$|
|$7$|$2\times10^7$|$10^7$|$10$|
|$8$|$10^6$|$2^{64}-1$|$15$|
|$9$|$2\times10^7$|$2^{64}-1$|$35$|

## 样例 #1

### 输入

```
2 9 998244353
```

### 输出

```
2684354563
```

## 样例 #2

### 输入

```
7 3 123456789
```

### 输出

```
24313281849
```

## 样例 #3

### 输入

```
10 9000000000000000000 1000000000000000000
```

### 输出

```
20026214895
```

## 样例 #4

### 输入

```
4 0 123456789
```

### 输出

```
12357556560
```

# AI分析结果



**唯一算法分类**  
组合数学

---

**综合分析与结论**  
本题核心在于发现交换操作的线性概率转移性质。通过分析每次交换对概率分布的影响，得出每个位置的概率变化遵循线性递推关系。最终通过快速幂或通项公式高效计算k次操作后的结果。

**关键公式推导**  
1. 每次交换后概率递推式：  
   $$b_i' = \frac{n-2}{n}b_i + \frac{2}{n^2}$$  
2. 通项公式（不动点法）：  
   $$b_i^{(k)} = (b_i^{(0)} - \frac{1}{n}) \cdot \left(\frac{n-2}{n}\right)^k + \frac{1}{n}$$  

**可视化设计思路**  
- **颜色高亮**：在动画中用不同颜色区分初始概率、线性变换参数（p、q）、快速幂步骤  
- **分步演示**：展示每步的 (n-2)/n 系数计算、2/n² 常数项叠加、快速幂分解过程  
- **概率变化曲线**：用折线图动态展示某位置概率随操作次数k的变化趋势  

---

**题解清单（≥4星）**  
1. **Missa（★★★★★）**  
   - 核心亮点：直接找到通项公式，代码简洁高效  
   - 关键代码：  
     ```cpp
     LL s = qpow(invn * (n-2) % mod, k);
     LL t = (b[i] - invn) * s % mod + invn;
     ```

2. **cyffff（★★★★）**  
   - 核心亮点：线性变换快速幂实现  
   - 关键代码：  
     ```cpp
     uint k1 = (n-2)*inv(n)%mod;
     uint k2 = qpow(k1, k);
     uint b2 = (k2-1)*inv(k1-1) % mod * b1 % mod;
     ```

---

**最优思路提炼**  
通过概率转移矩阵的特征分解，发现其存在不动点 $\frac{1}{n}$，将问题转化为等比数列求和。利用快速幂直接计算变换系数，将时间复杂度优化至 $O(n + \log k)$。

---

**同类型题套路**  
- **线性概率转移**：当概率变化可表示为线性组合时，寻找通项公式  
- **模数快速幂**：大指数快速幂配合费马小定理求逆元  
- **概率收敛性**：分析多次操作后的概率稳定状态  

---

**推荐练习题**  
1. P1654 概率计算器（概率矩阵快速幂）  
2. P3214 卡牌游戏（概率期望递推）  
3. P1365 WJMZBMR打比赛（概率动态规划）  

---

**可视化实现方案**  
```javascript
// 核心代码：8位像素风格概率变化动画
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');

function drawProbability(before, after, k) {
  // 8位风格绘制：红色表示初始概率，绿色表示变换后概率
  ctx.fillStyle = '#FF0000'; 
  drawBar(before, 50);
  
  ctx.fillStyle = '#00FF00';
  drawBar(after, 150);
  
  // 显示公式推导过程
  ctx.fillStyle = '#FFFFFF';
  ctx.fillText(`Step ${k}: b_i = ${(n-2)/n}*prev + ${2/(n*n)}`, 10, 200);
}

function animate() {
  // 自动步进，每步500ms
  let currentK = 0;
  const interval = setInterval(() => {
    if(currentK > k) clearInterval(interval);
    const newProb = calculateStep(currentK);
    drawProbability(initialProb, newProb, currentK);
    currentK++;
  }, 500);
}
```

---

**复古游戏化设计**  
- **像素音效**：  
  - 快速幂分解时播放8位"blip"声  
  - 完成计算时播放胜利音效  
- **积分系统**：  
  - 每正确推导一个公式步骤+100分  
  - 连续正确获得2倍连击奖励  
- **关卡设计**：  
  - 关卡1：推导基础递推式  
  - 关卡2：实现快速幂优化  
  - BOSS关：处理n=2e7的极端情况  

---

**个人心得**  
- **调试教训**：注意模数3221225473的unsigned特性，避免负值  
- **优化技巧**：将O(k)递推转化为O(log k)的快速幂是突破关键  
- **数学直觉**：发现概率收敛到1/n的不动点简化了计算

---
处理用时：170.05秒
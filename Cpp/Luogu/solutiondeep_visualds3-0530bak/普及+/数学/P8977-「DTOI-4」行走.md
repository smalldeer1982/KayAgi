# 题目信息

# 「DTOI-4」行走

## 题目背景

小 L 感到无聊，于是希望在树上行走。

## 题目描述

小 L 有一棵 $n$ 个点的树，树上点有点权，其中第 $i$ 个点权值为 $a_i$。

他不喜欢奇奇怪怪的权值，于是他保证 $a_i$ 一定是 $-1, 0, 1$ 之一。

他认为在树上行走是有趣的，于是他想要在这棵树上走出一条路径 $P$，其需要满足以下条件：

- $P$ 是一条**可以为空**的**简单有向路径**。
- 设 $P$ 中依次经过的点为 $P_1, P_2, \cdots, P_{|P|}$，则你求出的 $P$ 需要满足 $P_1 = 1$。
- 设 $f(P) = \displaystyle\sum_{i = 1}^{|P|} \frac{a_{P_i}}{2^{i - 1}}$，则你求出的 $P$ 需要满足 $f(P)$ 最大。
- 在 $f(P)$ 最大的前提下，你求出的 $P$ 还需要满足 $P$ 的字典序最小。

请你求出符合上述条件的路径 $P$。 

------------

关于本题中字典序的定义：

设有两条待比较的路径 $P \neq Q$。

- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i < Q_i$，则我们称 $P$ 的字典序小于 $Q$。
- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i > Q_i$，则我们称 $P$ 的字典序大于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| < |Q|$，则我们称 $P$ 的字典序小于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| > |Q|$，则我们称 $P$ 的字典序大于 $Q$。

## 说明/提示

#### 样例 #1 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/c7n2n6i0.png)

$P = [1, 2, 4]$ 时 $f(P) = 1 + 0 + \frac{1}{4} = \frac{5}{4}$。可以证明不存在更优的 $P$。
#### 数据范围
| $\textbf{Subtask}$ | $n$ | $a_i$ | 依赖 | 分值 |
| :------: | :------: | :------: | :------: | :------: |
| $1$ | $1 \leq n \leq 50$ | 无特殊限制 | 无 | $10 \operatorname{pts}$ |
| $2$ | $1 \leq n \leq 500$ | 同上 | $1$ | $10 \operatorname{pts}$ |
| $3$ | $1 \leq n \leq 5 \times 10^3$ | 同上 | $1, 2$ | $10 \operatorname{pts}$ |
| $4$ | $1 \leq n \leq 10^5$ | 同上 | $1 \sim 3$ | $20 \operatorname{pts}$ |
| $5$ | 无特殊限制 | $a_i \in \{-1, 1\}$ | 无 | $20 \operatorname{pts}$ |
| $6$ | 同上 | 无特殊限制 | $1 \sim 5$ | $30 \operatorname{pts}$ |

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$a_i \in \{-1, 0, 1\}$，$1 \leq u, v \leq n$，保证给出的边可以构成一棵**无根树**。

## 样例 #1

### 输入

```
5
1 0 -1 1 -1
1 2
2 3
2 4
1 5```

### 输出

```
1 2 4```

# AI分析结果



### 算法分类
**无算法分类**

---

### 题解思路与解决难点

#### 核心数学逻辑
1. **权值贡献模型**：路径贡献公式 $f(P) = \sum \frac{a_i}{2^{i-1}}$ 具有指数衰减特性，使得高位权值（靠近根节点的选择）对结果影响更大。
2. **贪心策略**：
   - **优先选1**：若当前层存在权值1的节点，其贡献必然优于后续所有0的累加（利用 $\frac{1}{2^k} > \sum_{j=k+1}^\infty \frac{1}{2^j}$）。
   - **禁止选-1**：即使后续全1也无法抵消当前-1的负贡献。
3. **字典序处理**：在权值相同的候选路径中，按子节点编号排序后选择最小字典序路径。

#### 解决难点
- **路径长度与权值平衡**：长路径可能因末尾0降低总贡献，需在遍历时动态截断无效后缀。
- **高效遍历**：需在 $O(n)$ 时间内处理大规模树结构，通过预处理子节点排序避免冗余比较。

---

### 题解评分（≥4星）

1. **xiaoqian02（★★★★☆）**
   - **思路**：DFS + 贪心选择1/0，预处理子节点排序保证字典序。
   - **亮点**：显式处理权值贡献的截断逻辑（`qz`数组清零），代码结构清晰。
   - **代码片段**：
     ```cpp
     bool dfs(int p, int fr, int dep) {
         int mx = -1;
         bool bg = 0;
         for (int k : ed[p]) {
             if (k == fr || a[k] == -1) continue;
             mx = max(mx, a[k]);
             if (a[k] == 1) {
                 if (qz[dep] == 0) { // 首次发现更优路径
                     qz[dep] = 1;
                     nxt[p] = k;
                     for (int j = dep+1; j <= mxd; j++) qz[j] = 0; // 截断后续
                 }
                 if (dfs(k, p, dep+1)) nxt[p] = k; // 子路径优化
             }
         }
         // 处理0节点...
         return bg;
     }
     ```

2. **Hovery（★★★★☆）**
   - **思路**：BFS分层维护候选节点，优先扩展权值1的节点。
   - **亮点**：利用队列分层处理，动态更新每层最大权值。
   - **代码片段**：
     ```cpp
     while (!q.empty()) {
         auto [x, dep, val] = q.front(); q.pop();
         if (val < mx[dep]) continue; // 非最优路径淘汰
         for (int y : G[x]) {
             if (a[y] != -1 && !vis[y]) {
                 q.push({y, dep+1, val + (a[y]==1)});
                 mx[dep+1] = max(mx[dep+1], val + (a[y]==1));
             }
         }
     }
     ```

3. **Leasier（★★★★☆）**
   - **思路**：动态维护候选路径终点集合，分层淘汰非最优路径。
   - **亮点**：显式处理末尾0的截断（`while (len>0 && a[ans[len]]==0) len--`）。
   - **代码片段**：
     ```cpp
     while (true) {
         bool has_1 = any_of(dot1, dot1+cnt1, [](int u){ return has_child_1(u); });
         if (has_1) {
             // 优先扩展1节点
             for (int u : dot1) for (int v : sorted_children(u)) {
                 if (a[v] == 1) add_to_next_layer(v);
             }
         } else {
             // 处理0节点...
         }
     }
     ```

---

### 最优技巧提炼
1. **贪心剪枝**：每一步优先选择权值1的节点，直接淘汰同层0节点。
2. **字典序预处理**：对所有节点的子节点按编号排序，确保DFS/BFS时自然选择最小字典序路径。
3. **动态截断**：在发现更优路径时，立即清空后续位的贡献（如`qz[dep+1..mxd] = 0`）。

---

### 类似题目推荐
1. **P1099 树网的核** - 树直径上的最优路径选择。
2. **P2495 消耗战** - 树形DP中的资源分配与路径截断。
3. **P1273 有线电视网** - 树形DP结合收益最大化。

---

### 可视化设计（像素风格演示）
1. **树形结构绘制**：Canvas绘制节点，根节点1居中，子节点按层展开。
2. **路径高亮**：当前选中路径以绿色像素块标记，权值1节点显示为黄色，0为灰色，-1为红色（禁用）。
3. **贡献值动态显示**：右侧面板实时计算并显示当前路径的$f(P)$值。
4. **音效反馈**：选中1时播放高音“哔”，0时中音“嘟”，路径更新时播放短促“咔嚓”声。
5. **自动推导模式**：AI模拟贪心选择过程，每步延迟500ms，路径自动延伸并高亮。

```javascript
// 示例：Canvas节点绘制与路径更新
function drawTree() {
    ctx.clearRect(0, 0, width, height);
    nodes.forEach(node => {
        ctx.fillStyle = node.active ? '#FF0' : (node.a === 0 ? '#888' : '#F00');
        ctx.fillRect(node.x, node.y, 16, 16); // 16x16像素块
    });
    // 绘制当前路径连线...
}

// 音效触发
function playSound(type) {
    const sfx = { '1': 'beep_high', '0': 'beep_mid', 'update': 'click' };
    new Audio(`sfx/${sfx[type]}.wav`).play();
}
```

---

### 总结
本题通过贪心策略与树遍历结合，在保证权值最大的前提下利用预处理排序解决字典序问题。关键点在于理解指数衰减权值的特性，并设计高效剪枝逻辑。可视化方案通过像素风格和音效增强理解，适合教学演示。

---
处理用时：76.25秒
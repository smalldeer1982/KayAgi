# 题目信息

# [USACO1.1] 黑色星期五Friday the Thirteenth

## 题目描述

$13$ 号又是一个星期五，那么 $13$ 号在星期五比在其他日子少吗？  

为了回答这个问题，写一个程序，要求计算每个月的十三号落在周一到周日的次数。给出 $n$ 年的一个周期，要求计算 $1900$ 年 $1$ 月 $1$ 日至 $1900+n-1$ 年 $12$ 月 $31$ 日中十三号落在周一到周日的次数。

这里有一些你要知道的:

1. $1900$ 年 $1$ 月 $1$ 日是星期一。
2. $4,6,11$ 和 $9$ 月有 $30$ 天，其他月份除了 $2$ 月都有 $31$ 天，闰年 $2$ 月有 $29$ 天，平年 $2$ 月有 $28$ 天。
3. 年份可以被 $4$ 整除的为闰年（$1992=4\times 498$ 所以 $1992$ 年是闰年，但是 $1990$ 年不是闰年）。
4. 以上规则不适合于世纪年。可以被 $400$ 整除的世纪年为闰年，否则为平年。所以，$1700,1800,1900,2100$ 年是平年，而 $2000$ 年是闰年。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 400$。

题目翻译来自NOCOW。

USACO Training Section 1.1

## 样例 #1

### 输入

```
20
```

### 输出

```
36 33 34 33 35 35 34
```

# AI分析结果



# 算法分类
**日期处理与数学公式应用**

---

## 题解思路与核心难点

### 算法要点
1. **直接模拟法**  
   - 逐天累加，统计13号出现的星期数  
   - 难点：闰年判断、月份天数切换、代码冗长易错  
   - 复杂度：O(总天数)，当 n=400 时总天数为 400×365≈146,000  
   - 示例代码：封禁用户题解（600+行循环）

2. **基姆拉尔森公式法**  
   - 公式：`week = (day + 2*month + 3*(month+1)/5 + year + year/4 - year/100 + year/400 + 1) % 7`  
   - 处理1月/2月为上年13/14月  
   - 复杂度：O(n×12)，直接计算每月13号的星期数  
   - 示例代码：HEIGE题解（20行核心逻辑）

3. **蔡勒公式法**  
   - 公式：`w = (y + y/4 + c/4 - 2c + 26(m+1)/10 + d - 1) % 7`  
   - 处理世纪年与闰年逻辑  
   - 示例代码：yyy2015c01题解（数学推导）

4. **日期步进优化**  
   - 利用相邻月份13号的星期数差等于上月天数模7  
   - 复杂度：O(n×12)，但减少逐日计算  
   - 示例代码：早右昕题解（结构体+月份步进）

---

## 题解评分（≥4星）

1. **HEIGE（基姆拉尔森公式）**  
   - 评分：★★★★★  
   - 亮点：公式直接计算，代码简洁高效，复杂度最优  
   - 关键代码：  
     ```cpp
     int week_day(int year, int month, int day) {
         if (month == 1 || month == 2) month += 12, year--;
         return (day + 2*month + 3*(month+1)/5 + year + year/4 - year/100 + year/400 + 1) % 7;
     }
     ```

2. **早右昕（日期步进）**  
   - 评分：★★★★☆  
   - 亮点：通过月份天数差快速计算，结构体封装清晰  
   - 关键代码：  
     ```cpp
     void operator++(date &a) {
         bool spl = (a.yy%400==0) || ((a.yy%100) && (a.yy%4==0));
         a.ww += d[spl][a.mm++], a.ww %= 7;
         if (a.mm == 12) a.yy++, a.mm = 0;
     }
     ```

3. **KingOfWA（数学步进）**  
   - 评分：★★★★  
   - 亮点：利用每月天数模7特性，避免逐日计算  
   - 关键代码：  
     ```pascal
     for i:=1900 to 1900+n-1 do
         for j:=1 to 12 do begin
             if j=1 then d:=(d+getDay(i-1,12)) mod 7
             else d:=(d+getDay(i,j-1)) mod 7;
             inc(a[d]);
         end;
     ```

---

## 最优思路提炼

1. **核心公式法**  
   - 使用基姆拉尔森或蔡勒公式直接计算每月13号的星期数，时间复杂度最优（O(n×12)）  
   - 关键优化：避免逐日循环，通过数学推导一步到位  

2. **步进法优化**  
   - 相邻月份13号的星期差等于上月天数模7，如：  
     - 1月13日星期数 = (上年12月天数 + 上年12月13日星期数) %7  
   - 优势：无需完整日期模拟，仅需存储当前月份13号的星期数  

---

## 同类型题与算法套路

1. **日期计算类问题通用解法**  
   - 公式法（基姆拉尔森/蔡勒）适用于快速计算星期数  
   - 步进法适用于需要连续日期推算的场景  

2. **类似题目推荐**  
   - P1217 [USACO1.5]回文质数（日期相关质数计算）  
   - P1308 [NOIP2011]统计单词数（字符串模式匹配）  
   - P1059 [NOIP2006]明明的随机数（数据去重与排序）

---

## 可视化算法演示

### 复古像素风格动画设计
1. **核心动画逻辑**  
   - **Canvas网格**：每个格子表示一个月份，颜色表示该月13号的星期数  
   - **步进控制**：按年份逐步填充格子，高亮当前计算的年份和月份  
   - **音效触发**：每次计算13号时播放“滴”声，完成一年后播放8-bit音阶  

2. **颜色与交互**  
   - 颜色方案：7种颜色对应周一到周日（如红色=周六，蓝色=周一）  
   - 控制面板：  
     ```html
     <button onclick="step()">单步执行</button>
     <input type="range" id="speed" min="1" max="10">速度调节</input>
     ```  
   - 示例动画片段（JavaScript）：  
     ```javascript
     function drawMonth(year, month) {
         let week = zeller(year, month, 13); // 公式计算
         ctx.fillStyle = COLORS[week];
         ctx.fillRect((year-1900)*12 + month, 0, 1, 1);
         playSound('beep'); // 触发音效
     }
     ```

---

## 关键代码实现

### 基姆拉尔森公式核心逻辑
```cpp
#include <iostream>
using namespace std;

int week_day(int year, int month, int day) {
    if (month == 1 || month == 2) month += 12, year--;
    return (day + 2*month + 3*(month+1)/5 + year + year/4 - year/100 + year/400 + 1) % 7;
}

int main() {
    int n, cnt[7] = {0};
    cin >> n;
    for (int y = 1900; y < 1900 + n; y++)
        for (int m = 1; m <= 12; m++)
            cnt[week_day(y, m, 13)]++;
    cout << cnt[5] << " " << cnt[6] << " ";
    for (int i=0; i<5; i++) cout << cnt[i] << " ";
}
```

---

## 个人心得摘录

1. **调试教训**  
   - 封禁用户题解中提到“输出顺序是周六到周五”，需特别注意题目要求的输出顺序与星期映射  

2. **优化顿悟**  
   - HEIGE题解提到“蔡勒公式虽然高效，但竞赛中难以记忆”，推荐掌握至少一种公式的推导方法  

---

通过公式法与步进法的结合，可高效解决日期推算类问题，其核心在于将日期数学化处理而非暴力模拟。

---
处理用时：85.18秒
# 题目信息

# [蓝桥杯 2022 国 A] 选素数

## 题目描述

小蓝有一个数 $x$，每次操作小蓝会选择一个小于 $x$ 的素数 $p$，然后在 $x$ 成为 $p$ 的倍数前不断将 $x$ 加 $1$，（如果 $x$ 一开始就是 $p$ 的倍数则 $x$ 不变）。

小乔看到了小蓝进行了 $2$ 次上述操作后得到的结果 $n$，他想知道 $x$ 在一开始是多少。如果有多种可能，他想知道 $x$  一开始最小可以是多少，而如果不存在任何解，说明小乔看错了，此时请输出 $-1$。

## 说明/提示

**【评测用例规模与约定】**

- 对于 $60\%$ 的评测用例，$1 \leq n \leq 5000$；
- 对于所有评测用例，$1 \leq n \leq 10^6$。

蓝桥杯 2022 国赛 A 组 G 题。

## 样例 #1

### 输入

```
22```

### 输出

```
8```

# AI分析结果



**算法分类**  
数论（质因数分解与线性筛）

---

**题解思路、算法要点与解决难点**  
- **核心思路**：反向推导两次操作的可能范围，利用线性筛预处理最大质因数。  
  1. **第一次操作后的数范围**：由结果n的最大质因数p_max确定区间[n-p_max+1, n]。  
  2. **第二次操作后的数范围**：对每个可能的中间值m，其最小初始值x为m - m的最大质因数 +1。  
- **关键优化**：线性筛预处理每个数的最大质因数，时间复杂度O(n)。  
- **解决难点**：避免暴力枚举的高时间复杂度，通过预处理快速获取质因数信息。

---

**题解评分 (≥4星)**  
1. **ChrysanthBlossom (4.5星)**  
   - 思路清晰，详细推导两次操作范围。  
   - 代码简洁，线性筛实现高效。  
   - 特殊处理质数情况，逻辑严谨。  

2. **lemon2021 (4星)**  
   - 分步骤解析操作过程，代码结构清晰。  
   - 使用线性筛预处理最大质因数，但代码变量命名稍显随意。  

3. **HHH6666666666 (4星)**  
   - 代码简洁，直接利用线性筛结果快速求解。  
   - 逻辑明确，无冗余步骤，适合快速理解核心逻辑。

---

**最优思路或技巧提炼**  
1. **线性筛记录最大质因数**：  
   - 在筛法过程中维护每个数的最大质因数，利用`np[i*j] = max(j, np[i])`。  
   - 时间复杂度O(n)，避免多次质因数分解。  
2. **反向推导范围**：  
   - 两次操作后的数范围由最大质因数确定，通过区间遍历避免穷举。  
3. **特判质数情况**：若n为质数或1，直接输出-1。

---

**同类型题与算法套路**  
- **相似题目**：  
  1. 求数的所有质因数。  
  2. 预处理区间内数的最大/最小质因数。  
  3. 反向推导操作后的可能初始值。  
- **通用解法**：  
  预处理质数/因数信息 → 反向推导操作链的可能范围 → 枚举验证最优解。

---

**推荐题目**  
1. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)  
2. [P2043 质因数分解](https://www.luogu.com.cn/problem/P2043)  
3. [P1072 [NOIP2009 提高组] Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072)

---

**个人心得摘录**  
- **调试教训**：遍历区间时需排除质数，否则导致错误候选解。  
- **思维突破**：线性筛不仅能筛质数，还可维护每个数的其他因数信息。  
- **优化关键**：预处理最大质因数将复杂度从O(n√n)降至O(n)。

---

**可视化与算法演示**  
**动画设计**：  
1. **线性筛过程**：  
   - 像素网格展示筛法步骤，高亮当前数i及其筛的合数i*j。  
   - 标记每个合数的最大质因数，颜色区分质数/合数。  
2. **区间遍历**：  
   - 展示n的质因数分解，动态绘制区间[n-p_max+1, n]。  
   - 对每个m∈区间，计算其对应x=m-m_max+1，实时更新最小值。  
3. **复古像素风格**：  
   - 使用8位色调色板（深蓝、浅绿、红色）表示质数、合数、当前操作数。  
   - 音效：质数标记时播放“叮”，找到解时播放胜利音效。  

**代码片段（关键筛法逻辑）**  
```cpp
void init() {
    for (int i = 2; i <= n; i++) {
        if (!np[i]) {
            pri.push_back(i);
            np[i] = i; // 质数的最大质因数为自身
        }
        for (auto j : pri) {
            if (i * j > n) break;
            np[i * j] = max(np[i], j); // 更新合数的最大质因数
            if (i % j == 0) break;
        }
    }
}
```

---

**结论**  
通过线性筛预处理最大质因数，结合反向推导操作范围，可在O(n)时间复杂度内高效求解。核心在于预处理与区间枚举的结合，避免暴力分解质因数的高开销。

---
处理用时：68.83秒
# 题目信息

# [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。


## 说明/提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
389 207 155 300 299 170 158 65```

### 输出

```
6
2
```

# AI分析结果



## 算法分类
动态规划，贪心，二分查找

---

## 题解思路与核心难点

### 核心思路
1. **第一问（最长不上升子序列）**  
   维护一个单调递减数组 `f`，表示各长度子序列的末尾最大值。对于每个新元素，若小于等于末尾则直接添加，否则二分查找替换第一个小于它的位置，保持数组的单调性。

2. **第二问（最少系统数）**  
   根据 Dilworth 定理，最少系统数等于最长上升子序列长度。维护一个单调递增数组 `g`，用类似方法处理，但替换条件改为寻找第一个大于等于当前值的位置。

### 解决难点
- **贪心策略的正确性**：通过维护单调数组，确保每次替换后不影响后续元素的处理，同时保证最优解的结构。
- **Dilworth 定理的理解**：将最少链覆盖问题转化为最长反链问题，需通过贪心或定理证明其等价性。
- **二分查找的边界处理**：正确选择 `upper_bound` 或 `lower_bound`，配合 `greater<int>()` 调整比较逻辑。

---

## 题解评分（≥4星）

1. **离散小波变换°（5星）**  
   - 详细推导贪心与二分优化，结合数学证明，代码简洁高效。  
   - **亮点**：从 DP 到优化的完整逻辑链，Dilworth 定理的代码等价性解释。

2. **STA_Morlin（4.5星）**  
   - 清晰的贪心策略与代码对称性，适合快速理解。  
   - **亮点**：对比两问的代码差异，强调 `lower_bound` 和 `upper_bound` 的使用。

3. **Otue（4星）**  
   - 贪心策略的严格证明，代码实现直观。  
   - **亮点**：通过逐步替换展示贪心正确性，适合新手理解。

---

## 最优思路提炼

### 关键技巧
1. **单调数组维护**  
   - **第一问**：`f[i]` 表示长度为 `i` 的不上升子序列的最小末尾值，保持 `f` 单调递减。
   - **第二问**：`g[i]` 表示长度为 `i` 的上升子序列的最大末尾值，保持 `g` 单调递增。

2. **二分查找优化**  
   ```cpp
   // 第一问：查找第一个小于当前值的下标
   int pos = upper_bound(f, f + len, a[i], greater<int>()) - f;
   // 第二问：查找第一个大于等于当前值的下标
   int pos = lower_bound(g, g + len, a[i]) - g;
   ```

3. **Dilworth 定理应用**  
   将最少链覆盖转换为最长反链（最长上升子序列），避免复杂证明直接编码。

---

## 同类型题推荐
1. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)  
   （双向 LIS 问题）
2. [P1439 最长公共子序列](https://www.luogu.com.cn/problem/P1439)  
   （LIS 映射转换）
3. [P2782 友好城市](https://www.luogu.com.cn/problem/P2782)  
   （排序后转化为 LIS）

---

## 核心代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 + 5;
int a[MAXN], f[MAXN], g[MAXN];

int main() {
    int n = 0, x;
    while (cin >> x) a[++n] = x;

    // 第一问：最长不上升子序列
    int len1 = 0;
    f[0] = INT_MAX;
    for (int i = 1; i <= n; ++i) {
        if (a[i] <= f[len1]) f[++len1] = a[i];
        else {
            int pos = upper_bound(f + 1, f + len1 + 1, a[i], greater<int>()) - f;
            f[pos] = a[i];
        }
    }
    cout << len1 << endl;

    // 第二问：最长上升子序列
    int len2 = 0;
    for (int i = 1; i <= n; ++i) {
        if (a[i] > g[len2]) g[++len2] = a[i];
        else {
            int pos = lower_bound(g + 1, g + len2 + 1, a[i]) - g;
            g[pos] = a[i];
        }
    }
    cout << len2 << endl;
    return 0;
}
```

---

## 可视化设计（复古像素版）

### 动画方案
1. **8-bit 风格界面**  
   - 绿色像素块表示已处理的导弹，红色块表示当前导弹  
   - 蓝色进度条显示二分查找区间，黄色箭头指示替换位置

2. **音效设计**  
   - `哔~`：元素插入数组末尾  
   - `叮~`：元素替换数组中间  
   - 8-bit 背景音乐循环播放

3. **交互功能**  
   - 空格键暂停/继续  
   - 方向键控制动画速度  
   - F 键切换自动演示/手动模式

### 算法演示步骤
1. **初始化**  
   显示空数组 `f[]` 和 `g[]`，背景加载导弹数据。

2. **处理每个导弹**  
   - 当前导弹高亮闪烁，显示高度数值  
   - 二分查找过程用左右指针动画表示  
   - 命中插入点时播放对应音效，数组更新动画

3. **最终结果**  
   两个结果数值以像素字体弹出，播放胜利音效。

```javascript
// 伪代码示例：Canvas 绘制关键帧
function drawFrame() {
    ctx.fillStyle = "#2C3E50"; // 背景色
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 绘制 f 数组
    for (let i = 0; i < f.length; i++) {
        drawPixelBlock(30 + i*20, 100, f[i], "#1ABC9C");
    }
    
    // 绘制当前导弹
    drawPixelBlock(mouseX, mouseY, currentMissile, "#E74C3C");
}
```

---
处理用时：97.54秒
# 题目信息

# [NOIP 2009 提高组] Hankson 的趣味题

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。

今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：

1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；

2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。

Hankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。


## 说明/提示

**【样例解释】**

第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。

第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。

**【数据范围】**

- 对于 $50\%$ 的数据，保证有 $1\leq a_0,a_1,b_0,b_1 \leq 10000$ 且 $n \leq 100$。
- 对于 $100\%$ 的数据，保证有 $1 \leq a_0,a_1,b_0,b_1 \leq 2 \times 10^9$ 且 $n≤2000$。

NOIP 2009 提高组 第二题


## 样例 #1

### 输入

```
2 
41 1 96 288 
95 1 37 1776 ```

### 输出

```
6 
2```

# AI分析结果



## 算法分类
数学推导与因数枚举

---

## 综合分析与结论

### 题解思路与核心难点
题目需找到满足两个条件的x：  
1. **gcd(x, a0) = a1**  
2. **lcm(x, b0) = b1**  

所有题解围绕以下核心思路展开：  
**x必须是b1的因数**（由条件2的最小公倍数性质）。通过枚举b1的因数，结合条件1的gcd约束快速筛选有效解。

#### 核心算法流程
1. **枚举所有可能的x**：遍历1到√b1，检查每个i是否为b1的因数（成对获取i和b1/i）
2. **条件验证**：对每个候选x，验证：
   - gcd(x, a0) == a1
   - lcm(x, b0) == b1（等价于x*b0/gcd(x,b0) == b1）
3. **时间复杂度优化**：通过√b1的枚举范围将复杂度降至O(√b1 * logN)，其中logN为gcd计算时间

#### 难点与对比
- **质因数分解法**：需处理每个质因数的指数范围，实现复杂但理论最优（O(√b1)预处理后O(1)计算），但对代码能力要求高
- **直接枚举法**：实现简单，但需处理重复因数（如i^2 = b1时），代码更易调试

---

## 题解清单（≥4星）

### 1. zzlzk（⭐⭐⭐⭐⭐）
- **亮点**：直接枚举b1的因数，利用sqrt优化，代码简洁高效
- **关键代码**：
```cpp
for(int x=1;x*x<=b1;x++) 
    if(b1%x==0){
        if(x%a1==0 && gcd(x/a1,p)==1 && gcd(q,b1/x)==1) ans++;
        int y = b1/x;
        if(y%a1==0 && gcd(y/a1,p)==1 && gcd(q,b1/y)==1) ans++;
    }
```

### 2. KesdiaelKen（⭐⭐⭐⭐）
- **亮点**：数学推导消除冗余计算，将问题转化为质因数分解后的条件组合
- **核心优化**：通过分解s = b1/a1和n = b1/b0，将x的约束转换为质因数间的互质关系

### 3. Ebola（⭐⭐⭐⭐）
- **亮点**：唯一分解定理应用，逐质因数分析约束条件
- **关键步骤**：对每个质因数p，分析其在a0/a1、b1/b0中的指数关系，计算合法区间

---

## 最优思路与技巧

### 关键技巧
1. **因数成对枚举**：仅需枚举到√b1即可覆盖所有因数
2. **条件转化**：  
   - gcd(x, a0)=a1 → x是a1倍数且x/a1与a0/a1互质
   - lcm(x, b0)=b1 → x是b1因数且b1/x与b0互质
3. **预处理互质关系**：通过提前计算a0/a1和b1/b0的gcd，减少重复计算

### 代码实现
```cpp
int ans = 0;
for(int x=1; x*x<=b1; x++){
    if(b1%x != 0) continue;
    // 检查x和b1/x是否满足条件
    if(check(x)) ans++;
    if(x != b1/x && check(b1/x)) ans++;
}
```

---

## 可视化与算法演示

### 像素动画设计
1. **网格布局**：  
   - 左侧显示b1的因数枚举过程（像素方块表示数值，绿色为当前检查的因数）
   - 右侧分屏展示gcd和lcm的计算过程（红色箭头指向当前操作数）

2. **动态效果**：
   - **因数扫描**：像素方块从1到√b1逐个高亮，发现因数时播放“哔”音效
   - **条件验证**：成功时方块变绿并加分，失败时变灰闪烁（伴随低音效）

3. **复古音效**：
   - 发现因数：8-bit风格“滴”声
   - 验证通过：上升音阶（C→E→G）
   - 验证失败：低音“嘟”声

4. **自动演示模式**：
   - AI自动遍历因数，关键步骤暂停0.5秒
   - 可切换手动模式，用方向键选择因数

### 示例动画流程
1. 初始化显示b1=288的网格
2. 扫描x=9 → 高亮9和32（288/9=32）
3. 验证gcd(9,96)=3，通过 → 方块变绿
4. 验证lcm(9,37)=333≠1776 → 方块变灰

---

## 相似题目推荐
1. **P1069 细胞分裂**（质因数分解与指数匹配）
2. **P1075 质因数分解**（因数枚举与数学性质）
3. **P1414 又是毕业季II**（gcd性质与因数分析）

---

## 个人心得摘录
> “暴力枚举看似简单，但通过因数成对枚举和条件转化，竟能轻松通过1e9数据”——zzlzk  
> “质因数分解法调试了3小时，最终发现漏了处理最后一个未分解完的大质数”——Ebola

---

## 核心代码（枚举法）
```cpp
#include<cstdio>
using namespace std;

int gcd(int a, int b) { return b ? gcd(b, a%b) : a; }

int main() {
    int T, a0, a1, b0, b1;
    scanf("%d", &T);
    while(T--) {
        scanf("%d%d%d%d", &a0,&a1,&b0,&b1);
        int ans = 0;
        for(int x=1; x*x<=b1; x++) {
            if(b1 % x != 0) continue;
            // 检查x和b1/x
            if(gcd(x, a0)==a1 && x*b0/gcd(x,b0)==b1) ans++;
            int y = b1/x;
            if(x != y && gcd(y,a0)==a1 && y*b0/gcd(y,b0)==b1) ans++;
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

---
处理用时：91.32秒
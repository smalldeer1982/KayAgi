# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果



### 唯一算法分类
**广度优先搜索（BFS）**

---

### 综合分析与结论
#### 核心思路与难点
1. **核心算法流程**  
   - 利用 BFS 分层遍历特性（边权为 1 的无权图）  
   - 维护两个关键数组：  
     - `dis[i]`：1 到 i 的最短距离  
     - `ans[i]`：1 到 i 的最短路径数量  
   - 首次访问节点时初始化 `ans` 为前驱节点的路径数  
   - 后续遇到相同层数的访问时累加路径数（取模）

2. **关键难点与解决方案**  
   - **重边处理**：邻接表存储时自动支持重边  
   - **分层计数**：通过 `dis` 数组确保只累加同一层的前驱节点  
   - **高效性**：BFS 时间复杂度 O(N+M)，优于 Dijkstra 和 SPFA

---

### 题解清单（≥4星）
1. **岸芷汀兰（★★★★★）**  
   - **亮点**：纯 BFS 实现，利用队列分层特性直接统计路径数  
   - **代码亮点**：  
     ```cpp
     if (!vis[cur]) {
         q.push(cur); 
         ans[cur] = ans[x];
     } else if (dis[cur] == dis[x] + 1) {
         ans[cur] += ans[x];
     }
     ```

2. TsReaper（★★★★☆）  
   - **亮点**：明确指出 BFS 的正确性（无权图特性）  
   - **核心思想**：每个节点只入队一次，保证计数无重复

3. King丨帝御威（★★★★☆）  
   - **亮点**：堆优化 Dijkstra 实现，兼容带权图场景  
   - **代码片段**：  
     ```cpp
     if (d[y] > d[x] + 1) ans[y] = ans[x];
     else if (d[y] == d[x] + 1) ans[y] += ans[x];
     ```

---

### 最优思路与代码实现
#### 关键代码（BFS 核心逻辑）
```cpp
void bfs() {
    queue<int> q;
    q.push(1);
    ans[1] = 1; dis[1] = 0; vis[1] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : adj[u]) {
            if (!vis[v]) {
                dis[v] = dis[u] + 1;
                ans[v] = ans[u];
                vis[v] = 1;
                q.push(v);
            } else if (dis[v] == dis[u] + 1) {
                ans[v] = (ans[v] + ans[u]) % MOD;
            }
        }
    }
}
```

#### 实现思想
- **分层遍历**：队列保证节点按距离递增顺序处理  
- **路径数累加**：仅当节点处于下一层时更新 `ans[v]`

---

### 同类型题目推荐
1. **P1608 路径统计**（带权图最短路计数）  
2. **P2296 寻找道路**（BFS + 条件过滤）  
3. **P3393 逃离僵尸岛**（分层 BFS + 优先级处理）

---

### 可视化设计
#### 像素风格动画方案
1. **颜色标记**  
   - **当前节点**：红色像素块  
   - **已访问节点**：绿色像素块  
   - **路径数更新**：黄色闪烁特效  

2. **动画流程**  
   ```plaintext
   1. 初始化 1 号节点为红色
   2. 弹出队列头部节点 u，标记为绿色
   3. 遍历 u 的邻居 v：
     - 若 v 未访问：染红并入队，显示 ans[v] = ans[u]
     - 若 v 已访问且同层：显示 ans[v] += ans[u]
   4. 循环直到队列为空
   ```

3. **音效设计**  
   - **节点入队**：8-bit "beep" 短音  
   - **路径数更新**：芯片音效（类似 FC 金币声）  
   - **完成遍历**：经典过关音效

---

### 个人心得摘录
> "BFS 的队列特性天然适合无权图最短路径统计，每个节点第一次被访问时一定是最短路径，后续的同层访问只需累加计数，无需复杂状态管理。" —— 岸芷汀兰

---

### 扩展思考
对于带权图的最短路计数，可改用 Dijkstra 算法，在松弛操作中同步更新路径数（见 King丨帝御威 的题解）。其核心逻辑与 BFS 的分层思想一脉相承，只是优先级队列替代了普通队列。

---
处理用时：66.41秒
# 题目信息

# [USACO04DEC] Cleaning Shifts S

## 题目描述

一天有 $T(1\le T\le 10^6)$ 个时段。约翰正打算安排他的 $N(1\le N\le 2.5\times 10^4)$ 只奶牛来值班，打扫打扫牛棚卫生。每只奶牛都有自己的空闲时间段 $ [S_i,E_i](1\le S_i\le E_i\le T)$，只能把空闲的奶牛安排出来值班。而且，每个时间段必需有奶牛在值班。

那么，最少需要动用多少奶牛参与值班呢？如果没有办法安排出合理的方案，就输出 $-1$。

## 说明/提示

$1\le T\le 10^6$，$N\le 2.5\times 10^4$，$1\le S_i\le E_i\le T$。

$\text{Update On 2023/08/08}$：添加了一组hack数据，详情见[这里](https://www.luogu.com.cn/discuss/613052)。叉掉了时间复杂度为 $\mathcal O(nt)$ 的错解。

## 样例 #1

### 输入

```
3 10
1 7
3 6
6 10```

### 输出

```
2```

# AI分析结果



# 算法分类
**贪心算法**

# 题解思路与解决难点
## 核心思路
题目要求在保证时间段完全覆盖的前提下选择最少的奶牛。各题解主要采用以下三种思路：
1. **贪心策略**：按左端点排序，每次选择能覆盖当前起点的最大右端点区间。
2. **线段树优化DP**：动态规划维护覆盖区间的最小代价，用线段树加速区间查询。
3. **最短路建模**：将时间点转化为图节点，区间转化为带权边，通过最短路求解。

## 关键对比
| 方法         | 时间复杂度       | 核心数据结构       | 解决难点                     |
|--------------|------------------|--------------------|-----------------------------|
| 贪心算法     | O(n log n)       | 排序数组           | 正确性证明与双指针实现       |
| 线段树DP     | O(n log T)       | 线段树             | 离散化与区间查询优化         |
| 最短路       | O(n + T)         | 邻接表/双端队列    | 图的构建与01-BFS优化         |

**贪心算法的核心步骤**：
1. 按左端点排序所有区间。
2. 维护当前覆盖终点`st`，每次选择左端点≤`st`且右端点最大的区间。
3. 更新`st`为选中区间的右端点+1，直到覆盖整个时间段。

# 题解评分（≥4星）
1. **Greenzhe的贪心解法（5星）**
   - 思路清晰，代码简洁，时间复杂度最优。
   - 正确性证明完整，双指针实现高效。
   - 关键代码：
     ```cpp
     while(j<=n && range[j].l<=st) { 
         r = max(r, range[j].r); 
         j++; 
     }
     ```

2. **Southern_Dynasty的最短路解法（4星）**
   - 创新性建模，01-BFS优化提升效率。
   - 离散化处理支持大范围时间。
   - 关键代码：
     ```cpp
     for(int i=1; i<=n; ++i) 
         add_edge(u[i]-1, v[i], 1);  // 区间转化为边
     ```

3. **bloodstalk的线段树DP（4星）**
   - 线段树加速查询，通用性强。
   - 适用于带权区间覆盖的扩展问题。
   - 关键代码：
     ```cpp
     int Min = Query(a[i].l-1, a[i].r-1, 0, R, 1);
     f[a[i].r] = min(f[a[i].r], Min + 1);
     ```

# 最优思路与技巧
1. **贪心选择策略**：每次选择覆盖当前起点且右端点最大的区间，确保局部最优。
2. **双指针优化**：线性扫描已排序区间，减少重复遍历。
3. **离散化技巧**（最短路）：将大范围时间点映射到紧凑空间，降低复杂度。

# 类似题目推荐
1. **P4644 [USACO05DEC] Cleaning Shifts S**：带权区间覆盖，需最小化总费用。
2. **P1280 尼克的任务**：时间轴覆盖问题，逆向动态规划。
3. **P1803 线段覆盖**：经典区间选择问题，贪心策略相似。

# 可视化与算法演示
## 贪心算法动画设计
1. **像素风格界面**：
   - 时间轴以横向像素条表示，绿色表示已覆盖，红色表示未覆盖。
   - 奶牛区间用不同颜色块标注，选中时闪烁黄色。
2. **关键操作高亮**：
   - 当前`st`位置用蓝色光标标记。
   - 候选区间遍历时，右端点最大值实时显示。
3. **音效与交互**：
   - 选中区间时播放8-bit音效。
   - 无解时播放低沉警报音，成功时播放胜利旋律。
4. **自动演示模式**：
   - 按帧逐步展示区间选择过程，支持暂停/继续。

示例动画流程：
```
初始状态：[1,7][3,6][6,10]（灰色未选中）
Step 1: 选中[1,7]，覆盖1-7（变绿），st=8
Step 2: 选中[6,10]，覆盖6-10（变绿），st=11≥10，结束
```

# 代码片段（贪心核心）
```cpp
sort(range+1, range+n+1);
int st=1, ans=0;
for(int i=1, j=1; i<=n;) {
    int max_r = 0;
    while (j<=n && range[j].l <= st) {
        max_r = max(max_r, range[j].r);
        j++;
    }
    if (max_r < st) break; // 无法覆盖
    ans++;
    if (max_r >= ed) { cout << ans; return 0; }
    st = max_r + 1;
    i = j;
}
cout << -1;
```

# 个人心得摘录
- **调试教训**：贪心需严格保证排序顺序，否则候选区间可能漏掉最优解。
- **思维突破**：最短路建模中将时间点转化为图节点，通过边权模拟区间覆盖。
- **优化技巧**：双指针跳过已处理区间，避免重复扫描（如Greenzhe的`i=j`操作）。

---
处理用时：92.70秒
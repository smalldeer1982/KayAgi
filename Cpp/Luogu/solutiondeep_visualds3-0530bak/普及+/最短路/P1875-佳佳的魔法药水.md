# 题目信息

# 佳佳的魔法药水

## 题目背景

发完了 $k$ 张照片，佳佳却得到了一个坏消息：他的 MM 得病了！佳佳和大家一样焦急万分！治好 MM 的病只有一种办法，那就是传说中的 $0$ 号药水…… 怎么样才能得到 $0$ 号药水呢？你要知道佳佳的家境也不是很好，成本得足够低才行……

## 题目描述

**存在 ab 相同 c 不同的情况，与题意相悖**。题还是可以做，但数据待修正。

得到一种药水有两种方法：可以按照魔法书上的指导自己配置，也可以到魔法商店里去买——那里对于每种药水都有供应，虽然有可能价格很贵。在魔法书上有很多这样的记载：

$1$ 份 A 药水混合 $1$ 份 B 药水就可以得到 $1$ 份 C 药水。（至于为什么 $1 + 1 = 1$，因为……这是魔法世界）好了，现在你知道了需要得到某种药水，还知道所有可能涉及到的药水的价格以及魔法书上所有的配置方法，现在要问的就是：

1. 最少花多少钱可以配制成功这种珍贵的药水；

2. 共有多少种不同的花费最少的方案（两种可行的配置方案如果有任何一个步骤不同则视为不同的）。假定初始时你手中并没有任何可以用的药水。


## 说明/提示

数据范围：

每一种药水的价格均 $\ge 1$ 且 $\le 2.8\times 10^4$。

样例说明：

最优方案有 $3$ 种，分别是：

- 直接买 $0$ 号药水；
- 买 $4$ 号药水、$5$ 号药水配制成 $1$ 号药水，直接买 $2$ 号药水，然后配制成 $0$ 号药水；
- 买 $4$ 号药水、$5$ 号药水配制成 $1$ 号药水，买 $3$ 号药水、$6$ 号药水配制成 $2$ 号药水，然后配制成 $0$ 号药水。

## 样例 #1

### 输入

```
7 
10 5 6 3 2 2 3 
1 2 0 
4 5 1 
3 6 2
```

### 输出

```
10 3```

# AI分析结果



**唯一算法分类**  
Dijkstra 算法

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
将药水视为图中的节点，合成关系视为边。使用类似 Dijkstra 的贪心策略，每次确定当前最小花费的节点，并用其与其他已确定最小花费的节点共同更新合成药水的状态。动态维护两个核心变量：
- `cost[i]`：药水 `i` 的最小花费。
- `ans[i]`：在最小花费下的方案数。

#### **算法要点**
1. **贪心选择**：每次从未处理的节点中选择 `cost` 最小的节点，确保其 `cost` 已是最优解。
2. **合成更新**：对于每个已确定的节点 `u`，遍历所有能与 `u` 合成其他药水的节点 `v`（需 `v` 也已确定最小花费），更新合成目标药水的 `cost` 和 `ans`。
3. **方案数累积**：
   - 若合成路径的花费等于当前 `cost`，则累加方案数：`ans[c] += ans[a] * ans[b]`。
   - 若合成路径更优，则重置方案数：`ans[c] = ans[a] * ans[b]`。

#### **解决难点**
- **环形依赖**：由于可能存在环，无法使用拓扑排序。Dijkstra 的贪心策略通过优先处理最小花费节点，确保已处理的节点不再被更新，从而避免循环。
- **方案数计算**：需在动态更新过程中正确维护组合数，避免重复或遗漏。

---

### **题解评分 (≥4星)**

| 题解作者       | 评分 | 关键亮点                                                                 |
|----------------|------|--------------------------------------------------------------------------|
| 半仙胡小桃     | ⭐⭐⭐⭐ | 邻接矩阵实现简洁，直接体现核心逻辑；方案数更新逻辑清晰。                   |
| Seg_Tree       | ⭐⭐⭐⭐ | 堆优化提升效率，链式前向星节省空间；处理相同药水合成逻辑严谨。             |
| Joyce_Jiang    | ⭐⭐⭐⭐ | 代码简洁，邻接矩阵实现易读；明确强调必须用已确定节点更新合成路径。         |

---

### **最优思路或技巧提炼**
1. **贪心确定最小节点**：每次选 `cost` 最小的未处理节点，确保后续更新不会影响其最优性。
2. **链式前向星优化**：高效存储合成关系，避免邻接矩阵的空间浪费。
3. **动态维护方案数**：根据花费相等或更优的情况，分别进行累加或重置。
4. **相同药水处理**：允许 `A+A→C` 类合成，需在存边时避免重复（如仅存一次双向边）。

---

### **同类型题或类似算法套路**
- **Dijkstra 变种**：适用于需按某种优先级逐步确定节点状态的问题（如最短路径、最小生成树）。
- **动态规划 + 图论**：若状态转移存在环形依赖，可结合贪心或 SPFA 迭代。

---

### **推荐相似题目**
1. [P4779 单源最短路径（标准 Dijkstra）](https://www.luogu.com.cn/problem/P4779)
2. [P4017 最大食物链计数（拓扑排序 + DP）](https://www.luogu.com.cn/problem/P4017)
3. [P3385 负环检测（SPFA 应用）](https://www.luogu.com.cn/problem/P3385)

---

### **可视化与算法演示**
**动画设计**：
1. **节点状态**：
   - 未处理：灰色方块。
   - 已处理：绿色方块。
   - 当前处理：闪烁黄色方块。
2. **合成边**：用箭头连接两个原料药水至目标药水，触发更新时高亮。
3. **更新效果**：
   - 若 `cost` 降低：目标药水变为红色，显示新值。
   - 若 `cost` 相同：目标药水变为橙色，显示 `ans` 增加。
4. **复古风格**：
   - 8-bit 音效：选中节点时播放“滴”声，更新成功时播放“叮”声。
   - 像素网格布局：药水按编号排列在网格中，合成边用 8-bit 风格箭头表示。

**控制面板**：
- 速度滑块：调整动画帧间隔。
- 单步执行：手动触发每一步更新。
- 自动播放：AI 按算法逻辑自动运行。

---

### **代码片段（核心逻辑）**
```cpp
// 链式前向星存边 + 堆优化 Dijkstra（Seg_Tree 题解核心）
void dijkstra() {
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> q;
    for (int i = 0; i < n; i++) {
        q.push({cost[i], i});
    }
    while (!q.empty()) {
        auto [c, u] = q.top(); q.pop();
        if (c != cost[u]) continue; // 已过时的状态
        vis[u] = true;
        for (int i = head[u]; i; i = edg[i].nxt) {
            int v = edg[i].v, a = edg[i].u2;
            if (!vis[a]) continue; // 必须双方均已确定
            if (cost[v] > cost[u] + cost[a]) {
                cost[v] = cost[u] + cost[a];
                ans[v] = ans[u] * ans[a];
                q.push({cost[v], v});
            } else if (cost[v] == cost[u] + cost[a]) {
                ans[v] += ans[u] * ans[a];
            }
        }
    }
}
```

---

### **个人心得摘录**
- **Seg_Tree**：强调必须等两个原料药水均被处理后再更新目标节点，否则方案数会错误累积。
- **Joyce_Jiang**：邻接矩阵虽空间占用高，但代码简洁，适合小数据范围；明确需先标记节点为已处理再更新。

---
处理用时：90.23秒
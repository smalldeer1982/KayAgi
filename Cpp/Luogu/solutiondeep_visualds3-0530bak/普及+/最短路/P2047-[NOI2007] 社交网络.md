# 题目信息

# [NOI2007] 社交网络

## 题目描述

在社交网络 ( Social Network ) 的研究中，我们常常使用图论概念去解释一些社会现象。不妨看这样的一个问题:   
在一个社交圈子里有 $n$ 个人，人与人之间有不同程度的关系。我们将这个关系网络对应到一个 $n$ 个结点的无向图上，两个不同的人若互相认识，则在他们对应的结点之间连接一条无向边，并附上一个正数权值 $c$ ，$c$ 越小，表示两个人之间的关系越密切。我们可以用对应结点之间的最短路长度来衡量两个人 $s$ 和 $t$ 之间的关系密切程度，注意到最短路径上的其他结点为 $s$ 和 $t$ 的联系提供了某种便利，即这些结点对于 $s$ 和 $t$ 之间的联系有一定的重要程度。我们可以通过统计经过一个结点 $v$ 的最短路径的数目来衡量该结点在社交网络中的重要程度。考虑到两个结点 $A$ 和 $B$ 之间可能会有多条最短路径。我们修改重要程度的定义如下：令 $C_{s,t}$ 表示从s到t的不同的最短路的数目，$C_{s,t}(v)$ 表示经过 $v$ 从 $s$ 到 $t$ 的最短路的数目；则定义：

$$ I(v)=\sum_{s \ne v,t\ne v} \frac{C_{s,t}(v)}{C_{s,t}}$$

为结点 $v$ 在社交网络中的重要程度。为了使 $I(v)$ 和 $C_{s,t}(v)$ 有意义，我们规定需要处理的社交网络都是连通的无向图，即任意两个结点之间都有一条有限长度的最短路径。现在给出这样一幅描述社交网络的加权无向图，请你求出每一个结点的重要程度。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/1136.png) 

对于1号结点而言，只有2号到4号结点和4号到2号结点的最短路经过1号结点，而2号结点和4号结点之间的最短路又有2条。因而根据定义，1号结点的重要程度计算为1/2+1/2=1。由于图的对称性，其他三个结点的重要程度也都是1。

对于 $50\%$ 的数据， $n \le 10 , m \le 45$。     
对于 $100\%$ 的数据， $n \le 100 , m \le 4500$ ，任意一条边的权值 $c$ 是正整数且 $1 \leqslant c \leqslant 1000$ 。    
所有数据中保证给出的无向图连通，且任意两个结点之间的最短路径数目不超过 $10^{10}$。     



## 样例 #1

### 输入

```
4 4
1 2 1
2 3 1
3 4 1
4 1 1```

### 输出

```
1.000
1.000
1.000
1.000```

# AI分析结果



# 分析报告

## 算法分类
**Floyd-Warshall算法**

---

## 题解思路与核心难点
### 核心算法流程
1. **Floyd预处理最短路径与路径计数**  
   通过三重循环动态维护两个矩阵：
   - `dis[i][j]`：i到j的最短路径长度
   - `cnt[i][j]`：i到j的最短路径条数（**关键难点**）
   
   转移逻辑：
   ```cpp
   for (int k=1; k<=n; k++)
       for (int i=1; i<=n; i++)
           for (int j=1; j<=n; j++) {
               if (dis[i][j] > dis[i][k] + dis[k][j]) { // 发现更短路径
                   dis[i][j] = dis[i][k] + dis[k][j];
                   cnt[i][j] = cnt[i][k] * cnt[k][j];   // 重置计数
               } else if (dis[i][j] == dis[i][k] + dis[k][j]) { // 等长路径
                   cnt[i][j] += cnt[i][k] * cnt[k][j];  // 累加计数
               }
           }
   ```

2. **贡献度计算**  
   对每个节点v，遍历所有s≠v且t≠v的节点对：
   ```cpp
   if (dis[s][t] == dis[s][v] + dis[v][t]) // v在s→t的最短路上
       ans[v] += (cnt[s][v] * cnt[v][t]) / (double)cnt[s][t];
   ```

### 解决难点
- **路径计数动态维护**：通过乘法原理（路径组合）和加法原理（等长路径合并）确保计数准确性
- **浮点精度处理**：最终结果需保留3位小数，用`double`类型存储中间结果

---

## 题解评分（≥4星）
1. **Ning_Mew（★★★★★）**  
   - 亮点：代码结构清晰，Floyd与贡献计算分离；注释详细解释路径计数逻辑
   - 关键代码：
     ```cpp
     // Floyd部分
     if(dis[i][j]>dis[i][k]+dis[k][j]) {
         dis[i][j] = dis[i][k]+dis[k][j];
         edge[i][j] = edge[i][k]*edge[k][j];
     } else if(dis[i][j]==dis[i][k]+dis[k][j]) {
         edge[i][j] += edge[i][k]*edge[k][j];
     }
     ```

2. **Register（★★★★☆）**  
   - 亮点：变量命名规范（sum代替cnt），贡献计算部分用简洁的三重循环
   - 优化点：代码中去除了i==j的判断，提升效率

3. **人殇物已非（★★★★☆）**  
   - 亮点：强调long long防溢出；调试经历（重边处理）具有参考价值
   - 关键注释：
     ```cpp
     // 注意：dis最初要赋足够大的值，sum最初是0
     memset(dis,0x3f,sizeof(dis));
     memset(sum,0,sizeof(sum));
     ```

---

## 最优思路提炼
**Floyd动态维护路径计数**  
- 初始化时，直接相连的边路径数设为1
- 在Floyd的松弛过程中：
  - 发现更短路径时，路径数重置为两段路径数的乘积
  - 发现等长路径时，路径数累加乘积结果

---

## 同类题目推荐
1. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)  
   （单源最短路径计数，Dijkstra/BFS应用）
2. [P1608 路径统计](https://www.luogu.com.cn/problem/P1608)  
   （带权最短路径计数，SPFA优化）
3. [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)  
   （动态Floyd应用，时间维度处理）

---

## 可视化设计
### 动画方案（Floyd核心过程）
1. **网格展示**  
   - 用`<canvas>`绘制n×n网格，每个格子显示`dis[i][j]`和`cnt[i][j]`
   - **当前操作高亮**：用红色边框标记正在处理的k、i、j节点

2. 动态更新演示  
   ```javascript
   // 伪代码示例
   function animateStep(k, i, j) {
       highlightCell(i, j, 'yellow'); // 当前更新的i,j
       if (newDis < oldDis) {
           drawArrow(i, k, 'blue');    // 路径i→k→j
           drawArrow(k, j, 'blue');
           updateCell(i, j, newDis, newCnt);
       } else if (newDis == oldDis) {
           flashCell(i, j, 'green');  // 路径数增加
           updateCnt(i, j, addedCnt);
       }
   }
   ```

3. **复古像素风格**  
   - 使用16色调色板（如#FF6B6B红、#4ECDC4青）
   - 节点显示为8×8像素方块，路径用1px虚线
   - 音效设计：
     - 路径更新：8-bit "beep"声（[JSFiddle示例](https://jsfiddle.net/6spjuh9L/)）
     - 错误操作：短促低音

---

## 核心代码实现
```cpp
// Floyd最短路径计数
for (int k=1; k<=n; ++k)
    for (int i=1; i<=n; ++i)
        for (int j=1; j<=n; ++j) {
            if (i == j || j == k || i == k) continue;
            if (dis[i][j] > dis[i][k] + dis[k][j]) {
                dis[i][j] = dis[i][k] + dis[k][j];
                cnt[i][j] = cnt[i][k] * cnt[k][j];
            } else if (dis[i][j] == dis[i][k] + dis[k][j]) {
                cnt[i][j] += cnt[i][k] * cnt[k][j];
            }
        }

// 计算节点v的重要程度
for (int v=1; v<=n; ++v) {
    double res = 0;
    for (int s=1; s<=n; ++s) {
        if (s == v) continue;
        for (int t=1; t<=n; ++t) {
            if (t == v || s == t) continue;
            if (dis[s][t] == dis[s][v] + dis[v][t]) {
                res += (1.0 * cnt[s][v] * cnt[v][t]) / cnt[s][t];
            }
        }
    }
    printf("%.3f\n", res);
}
```

---
处理用时：89.02秒
# 题目信息

# 正则表达式

## 题目背景

小Z童鞋一日意外的看到小X写了一个正则表达式的高级程序，这个正则表达式程序仅仅由字符“0”,“1”，“.”和“\*”构成，但是他能够匹配出所有在OJ上都AC的程序的核心代码！小Z大为颇感好奇，于是他决定入侵小X的电脑上去获得这个正则表达式的高级程序。


## 题目描述

在 Internet 网络中的每台电脑并不是直接一对一连通的，而是某些电脑之间存在单向的网络连接，也就是说存在 $A$ 到 $B$ 的连接不一定存在 $B$ 到 $A$ 的连接，并且有些连接传输速度很快，有些则很慢，所以不同连接传输所花的时间是有大有小的。另外，如果存在 $A$ 到 $B$ 的连接的同时也存在 $B$ 到 $A$ 的连接的话，那么 $A$ 和 $B$ 实际上处于同一局域网内，可以通过本地传输，这样花费的传输时间为 $0$。

现在小 Z 告诉你整个网络的构成情况，他希望知道从他的电脑（编号为 $1$），到小 X 的电脑（编号为 $n$）所需要的最短传输时间。

## 说明/提示

- 对于  $40\%$ 的数据，$1\leq n\leq 10^3$, $1\leq m\leq 10^4$；
- 对于  $70\%$ 的数据，$1\leq n\leq 5 \times 10^3$， $1\leq m\leq 10^5$；
- 对于  $100\%$ 的数据，$1\leq n\leq 2 \times 10^5$， $1\leq m\leq 10^6$。

保证答案在 `int` 范围内。

## 样例 #1

### 输入

```
3 2
1 2 1
2 3 1
```

### 输出

```
2```

## 样例 #2

### 输入

```
5 5
1 2 1
2 3 6
3 4 1
4 2 1
3 5 2
```

### 输出

```
3```

# AI分析结果



### **唯一算法分类**  
Tarjan缩点 + 最短路

---

### **综合分析与结论**

#### **核心思路**  
题目本质是**带权强连通分量最短路问题**：  
1. **缩点**：用Tarjan算法将强连通分量（SCC）缩为单个节点，SCC内节点间传输时间为0  
2. **重构DAG**：不同SCC间的边保留原权值  
3. **最短路**：在缩点后的DAG上，从起点所在SCC到终点所在SCC跑最短路

#### **解决难点**  
- **缩点正确性**：确保同一SCC内所有节点被合并  
- **边权处理**：缩点时过滤掉SCC内边，保留跨SCC边  
- **效率优化**：针对大规模数据（n=2e5, m=1e6）需使用堆优化Dijkstra

#### **可视化设计**  
1. **Tarjan过程**：  
   - **颜色标记**：已访问节点（绿色）、栈中节点（黄色）、当前递归路径（红色）  
   - **动态栈**：展示递归栈的push/pop操作  
2. **Dijkstra过程**：  
   - **优先队列可视化**：实时显示队列中节点及其距离  
   - **路径追踪**：高亮最短路径的更新过程  
3. **复古像素风格**：  
   - 使用8-bit网格表示节点，SCC合并时显示像素爆炸特效  
   - 音效设计：发现SCC时播放「叮」声，路径更新时播放「滴」声

---

### **题解清单 (≥4星)**

#### **1. Diamiko (5星)**  
**亮点**：  
- 完整注释 + 链式前向星实现  
- 强调缩点后节点用color标记的细节  
- 明确Dijkstra处理缩点后图的逻辑  

#### **2. subarude (4星)**  
**亮点**：  
- 对比拓扑排序与最短路的选择  
- 提供缩点板子题链接辅助理解  
- 强调`belong[]`数组的边界处理  

#### **3. PrincessQi (4星)**  
**亮点**：  
- 极简代码风格（仅70行）  
- 直接复用原图结构，减少内存拷贝  
- 注释中强调SPFA在本题的可行性  

---

### **最优思路提炼**  
1. **Tarjan缩点核心逻辑**：  
   ```python
   def tarjan(u):
       low[u] = dfn[u] = ++idx
       stack.push(u)
       for v in G[u].neighbors:
           if not dfn[v]: 
               tarjan(v)
               low[u] = min(low[u], low[v])
           elif in_stack[v]:
               low[u] = min(low[u], dfn[v])
       if dfn[u] == low[u]:
           while True:
               v = stack.pop()
               scc_id[v] = cnt
               if u == v: break
   ```  
   **关键点**：递归时维护`low[]`，回溯时判断SCC  

2. **缩点后最短路**：  
   ```cpp
   // 重构边时过滤同SCC边
   for each edge u->v:
       if scc[u] != scc[v]:
           add_edge(scc[u], scc[v], w)

   // Dijkstra核心
   priority_queue<pair<int,int>> pq;
   pq.push({0, scc[1]});
   while !pq.empty():
       dist, u = pq.top()
       for v in new_G[u]:
           if dist + w < dis[v]:
               dis[v] = dist + w
               pq.push(v)
   ```  

---

### **同类型题推荐**  
1. **P3387** 缩点+最长路  
2. **P2002** 消息扩散（缩点后统计入度）  
3. **P2341** 受欢迎的牛（SCC基础应用）

---

### **可视化代码片段**  
```javascript
// 像素风格Tarjan动画（伪代码）
class TarjanViz {
  constructor() {
    this.canvas = document.getElementById('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.nodes = [/* 像素坐标数据 */];
    this.playSound('background'); // 8-bit BGM
  }

  drawNode(node, color) {
    // 绘制16x16像素方块
    this.ctx.fillStyle = color;
    this.ctx.fillRect(node.x*20, node.y*20, 16, 16);
  }

  onSCCFound(nodes) {
    nodes.forEach(node => {
      this.drawExplosion(node); // 像素爆炸特效
      this.playSound('ding');   // 发现SCC音效
    });
  }
}
```

---

### **个人心得摘录**  
- **调试陷阱**：`belong[1]`可能不等于1，需显式查询起点SCC  
- **优化经验**：SPFA在随机数据下表现良好，但Dijkstra更稳定  
- **思维突破**：将SCC视为超级节点是图论问题通用技巧  

---

### **扩展思考**  
若允许负权边，需改用SPFA并处理负环，但本题因SCC内边权为0，不会出现负环。

---
处理用时：73.64秒
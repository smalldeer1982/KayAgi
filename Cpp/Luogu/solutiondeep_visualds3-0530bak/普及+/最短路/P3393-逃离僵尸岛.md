# 题目信息

# 逃离僵尸岛

## 题目描述

小 a 住的国家被僵尸侵略了！小 a 打算逃离到该国唯一的国际空港逃出这个国家。


该国有 $N$ 个城市，城市之间有道路相连。一共有 $M$ 条双向道路。保证没有自环和重边。


其中 $K$ 个城市已经被僵尸控制了，如果贸然闯入就会被感染 TAT...所以不能进入。由其中任意城市经过不超过 $S$ 条道路就可以到达的别的城市，就是危险城市。换句话说只要某个城市到任意被僵尸控制的城市距离不超过 $S$，就是危险的。

小 a 住在 $1$ 号城市，国际空港在 $N$ 号城市，这两座城市没有被侵略。小a走每一段道路（从一个城市直接到达另外一个城市）得花一整个白天，所以晚上要住旅店。安全的的城市旅馆比较便宜要 $P$ 元，而被危险的城市，旅馆要进行安保措施，所以会变贵，为 $Q$ 元。所有危险的城市的住宿价格一样，安全的城市也是。在 $1$ 号城市和 $N$ 城市，不需要住店。


小 a 比较抠门，所以他希望知道从 $1$ 号城市到 $N$ 号城市所需要的最小花费。

输入数据保证存在路径，可以成功逃离。输入数据保证他可以逃离成功。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/2681.png) 

对于 $20\%$ 数据，$N\le 50$。

对于 $100\%$ 数据，$2\le N\le 10^5$，$1\le M\le 2\times 10^5$，$0\le K\le N - 2$，$0\le S\le 10^5$，$1\le P< Q\le 10^5$。


## 样例 #1

### 输入

```
13 21 1 1
1000 6000
7
1 2
3 7
2 4
5 8
8 9
2 5
3 4
4 7
9 10
10 11
5 9
7 12
3 6
4 5
1 3
11 12
6 7
8 11
6 13
7 8
12 13```

### 输出

```
11000```

# AI分析结果



### 算法分类  
BFS预处理 + 最短路径算法（Dijkstra/SPFA）

---

### 综合分析与结论  
**核心思路**：  
1. **多源BFS**标记危险城市（与僵尸城距离 ≤ S 的点）  
2. **点权转边权**：将城市住宿费用作为边权（每条边的权重 = 目标节点费用）  
3. **最短路算法**计算从起点到终点的最小费用  

**难点与解决方案**：  
- **多源BFS优化**：将所有僵尸城统一加入队列，按层扩展，避免重复计算  
- **边权转换**：通过拆点或直接修改邻接表，将点权转化为邻接边的权重  
- **终点特判**：起点和终点的住宿费用需强制设为0  

**可视化设计**：  
- **BFS扩展动画**：用红色扩散波纹表示危险区域的扩展过程，僵尸城为黑色，危险层数用不同透明度表示  
- **Dijkstra路径追踪**：用绿色高亮当前最短路径候选节点，黄色表示已确定的最优路径节点  
- **复古像素风格**：城市节点用8-bit方块表示，危险城市闪烁红光，安全城市为蓝色，路径费用以像素数字动态更新  

---

### 题解清单（≥4星）  
1. **作者：fyfy（⭐⭐⭐⭐⭐）**  
   - **亮点**：虚拟节点统一僵尸城，SPFA双次求解，代码结构清晰  
   - **核心代码**：  
     ```cpp  
     add(0, y); // 虚拟节点连接所有僵尸城  
     spfa(0);   // BFS标记危险城市  
     for (边权赋值) w[i] = (危险 ? Q : P);  
     spfa(1);   // 最终最短路  
     ```  

2. **作者：顾z（⭐⭐⭐⭐）**  
   - **亮点**：双BFS分离标记与最短路，详细注释与错误处理  
   - **心得摘录**：  
     > "WA点4和6是因为INF不够大，必须用`INF=30000000000`"  

3. **作者：kkksc03（⭐⭐⭐⭐）**  
   - **亮点**：点权转边权的数学公式（边权=两点权值和/2）  
   - **核心思想**：  
     ```cpp  
     for 每条边(u,v):  
         edge_weight = (cost[u] + cost[v])  
     最终结果除以2避免重复计算  
     ```  

---

### 最优思路提炼  
1. **多源BFS标记法**：  
   - 初始化队列时加入所有僵尸城，层数从0开始计数  
   - 当扩展层数达到S时停止，避免无效计算  

2. **边权动态赋值**：  
   ```python  
   for v in 邻接表:  
       if v是终点: 边权 = 0  
       elif v是危险点: 边权 = Q  
       else: 边权 = P  
   ```  

3. **优先队列优化Dijkstra**：  
   - 使用`priority_queue`维护当前最小费用候选节点  
   - 跳过已被占领的节点（标记为不可访问）  

---

### 同类型题目推荐  
1. **P1144 最短路计数**（BFS+最短路扩展）  
2. **P4568 飞行路线**（分层图+最短路）  
3. **P1948 电话线**（二分答案+最短路判定）  

---

### 个人心得摘录  
1. **作者：FutaRimeWoawaSete**：  
   > "被占领城市之间不连边，否则会错误标记危险城市层级"  
2. **作者：momo5440**：  
   > "SPFA中若v是被占领点直接continue，否则第4个点WA到怀疑人生"  
3. **作者：Celebrate**：  
   > "必须用long long，100000²会爆int！用错类型样例都过不了"  

---

### 可视化算法演示（核心逻辑）  
**BFS危险标记过程**：  
```javascript  
// 伪代码示例  
const bfs = () => {  
  let queue = zombieCities.map(c => ({pos:c, layer:0}));  
  while (queue.length) {  
    const {pos, layer} = queue.shift();  
    if (layer > S) break;  
    for (邻接节点v of pos) {  
      if (!visited[v]) {  
        markAsDanger(v);  // 标记为红色  
        queue.push({pos:v, layer: layer+1});  
      }  
    }  
  }  
};  
```  

**Dijkstra路径搜索**：  
```javascript  
// 伪代码示例  
const dijkstra = () => {  
  const pq = new PriorityQueue((a,b) => a.cost < b.cost);  
  pq.push({node:1, cost:0});  
  while (!pq.empty()) {  
    const {node, cost} = pq.pop();  
    if (node == N) return cost;  
    for (邻接节点v of node) {  
      const newCost = cost + getEdgeCost(node, v);  
      if (newCost < dist[v]) {  
        dist[v] = newCost;  
        pq.push({node:v, cost:newCost});  
        drawEdgeHighlight(node, v); // 高亮当前边  
      }  
    }  
  }  
};  
```  

**复古像素风格实现**：  
- **Canvas绘制**：  
  ```javascript  
  // 绘制城市节点  
  function drawCity(ctx, x, y, type) {  
    const colors = {safe: '#00F', danger: '#F00', zombie: '#000'};  
    ctx.fillStyle = colors[type];  
    ctx.fillRect(x*32, y*32, 28, 28); // 32x32网格，留4像素边框  
  }  
  ```  
- **音效设计**：  
  - 危险城市标记：8-bit "警报"音效（500Hz方波，持续0.1秒）  
  - 路径更新：短促"滴"声（200Hz，50ms）  

---

### 核心代码实现（Dijkstra部分）  
```cpp  
typedef long long ll;  
priority_queue<pair<ll, int>> pq;  
ll dist[MAXN];  

void dijkstra(int start) {  
  memset(dist, 0x3f, sizeof(dist));  
  dist[start] = 0;  
  pq.push({0, start});  
  while (!pq.empty()) {  
    auto [d, u] = pq.top(); pq.pop();  
    if (-d > dist[u]) continue;  
    for (auto [v, cost] : adj[u]) {  
      if (cost == INF) continue; // 跳过被占领城市  
      if (dist[v] > dist[u] + cost) {  
        dist[v] = dist[u] + cost;  
        pq.push({-dist[v], v});  
      }  
    }  
  }  
}  
```  

该代码通过优先队列实现堆优化Dijkstra，时间复杂度O(M log N)，完美处理1e5级数据规模。

---
处理用时：88.42秒
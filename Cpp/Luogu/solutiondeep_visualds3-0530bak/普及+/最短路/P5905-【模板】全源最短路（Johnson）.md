# 题目信息

# 【模板】全源最短路（Johnson）

## 题目描述

给定一个包含 $n$ 个结点和 $m$ 条带权边的有向图，求所有点对间的最短路径长度，一条路径的长度定义为这条路径上所有边的权值和。

注意：

1. 边权**可能**为负，且图中**可能**存在重边和自环；

2. 部分数据卡 $n$ 轮 SPFA 算法。



## 说明/提示

【样例解释】

左图为样例 $1$ 给出的有向图，最短路构成的答案矩阵为：

```
0 4 11 8 11 
1000000000 0 7 4 7 
1000000000 -5 0 -3 0 
1000000000 -2 5 0 3 
1000000000 -1 4 1 0 
```

右图为样例 $2$ 给出的有向图，红色标注的边构成了负环，注意给出的图不一定连通。

![](https://cdn.luogu.com.cn/upload/image_hosting/7lb35u4u.png)

【数据范围】

对于 $100\%$ 的数据，$1\leq n\leq 3\times 10^3,\ \ 1\leq m\leq 6\times 10^3,\ \ 1\leq u,v\leq n,\ \ -3\times 10^5\leq w\leq 3\times 10^5$。

对于 $20\%$ 的数据，$1\leq n\leq 100$，不存在负环（可用于验证 Floyd 正确性）

对于另外 $20\%$ 的数据，$w\ge 0$（可用于验证 Dijkstra 正确性）

upd. 添加一组 Hack 数据：针对 SPFA 的 SLF 优化

## 样例 #1

### 输入

```
5 7
1 2 4
1 4 10
2 3 7
4 5 3
4 2 -2
3 4 -3
5 3 4```

### 输出

```
128
1000000072
999999978
1000000026
1000000014
```

## 样例 #2

### 输入

```
5 5
1 2 4
3 4 9
3 4 -3
4 5 3
5 3 -2```

### 输出

```
-1```

# AI分析结果



### 唯一算法分类
Johnson 算法（全源最短路）

---

### 综合分析与结论
**核心思路**：通过势能函数将负权图转化为非负权图，使 Dijkstra 能正确运行。关键步骤：
1. **虚拟节点预处理**：添加虚拟节点 0 并连接所有节点（边权为 0）
2. **势能计算**：用 Bellman-Ford/SPFA 计算虚拟节点到各点的最短路径（即势能 h[i]）
3. **边权修正**：将边权 w(u,v) 调整为 w(u,v)+h[u]-h[v]
4. **Dijkstra 多源计算**：对每个节点运行 Dijkstra 求最短路
5. **结果还原**：修正后的最短路需减去势能差 h[s]-h[t]

**可视化设计要点**：
- **像素动画**：用网格表示节点，不同颜色区分步骤：
  - 红色：虚拟节点和初始连接边
  - 黄色：SPFA 计算势能时的队列扩散过程
  - 绿色：边权修正后的新权值
  - 蓝色：Dijkstra 的优先队列操作
- **音效触发**：
  - 短促 "滴" 声：每次节点入队/出队
  - 上扬音效：成功修正边权时
  - 警报音：检测到负环时
- **步进控制**：可单步观察势能计算和边权修正过程

---

### 题解清单（评分≥4星）
1. **StudyingFather（5星）**
   - 亮点：完整数学证明，代码结构清晰，通过格式化工具提升可读性
   - 核心代码：SPFA 判负环 + 势能计算 → 边权修正 → 多源 Dijkstra
   - 调试心得：特别强调格式化代码的重要性，避免手写格式错误

2. **ix35（4星）**
   - 亮点：对比 Floyd/Dijkstra/Bellman-Ford 适用场景，代码实现包含两种存图方式
   - 优化点：使用前向星存图 + 队列优化 Bellman-Ford

3. **SDqwq（4星）**
   - 亮点：完整注释模板代码，特别说明入队次数判负环的细节（n+1 次）
   - 关键代码片段：
     ```cpp
     if(++tim[v] > n) return false; // 虚拟节点导致总节点数为 n+1
     ```

---

### 最优思路与技巧
**关键突破点**：
1. **势能差分抵消**：通过势能差 h[u]-h[v] 的线性叠加，保证路径总偏移量恒定
2. **三角形不等式应用**：h[v] ≤ h[u] + w(u,v) → 修正后边权非负
3. **虚拟节点技巧**：统一处理不连通图，避免单独判负环

**代码优化技巧**：
```cpp
// 边权修正的简洁实现
for(int u=1; u<=n; u++)
    for(int i=head[u]; i; i=e[i].next)
        e[i].w += h[u] - h[e[i].v];
```

---

### 相似题目推荐
1. [P3385] 负环检测（SPFA 基础）
2. [P4779] Dijkstra 模板（非负权图训练）
3. [P4015] 运输问题（费用流中的 Johnson 思想应用）

---

### 算法可视化方案
**核心动画流程**：
1. **初始化阶段**：
   - 绘制虚拟节点 0（红色方块），向其他节点发射白色箭头（权值 0）
2. **SPFA 阶段**：
   - 队列扩散效果：节点按入队顺序渐变为黄色
   - 实时显示势能值 h[i] 在节点上方
3. **边权修正阶段**：
   - 原边权显示为灰色，修正后显示为绿色浮动数字
4. **Dijkstra 阶段**：
   - 优先队列可视化：右侧显示当前队列节点及其距离
   - 已确定最短路的节点变为蓝色

**交互设计**：
- **速度滑块**：控制动画速度（0.5x~5x）
- **模式切换**：对比原始图/修正后图的 Dijkstra 运行差异
- **负环演示**：手动注入负环数据，触发警报音效和红色闪烁提示

---

### 扩展思考
**与费用流的关系**：Johnson 的势能思想衍生出原始对偶算法（Primal-Dual），用于处理带费用的网络流问题。两者的核心都是通过势能差维持非负边权，使得贪心算法可用。

**Hack 数据防御**：针对 SLF 优化的 SPFA，可通过构造层状稠密图进行攻击。Johnson 的优势在于只需 1 次 SPFA，相比 n 轮 SPFA 更抗攻击。

---
处理用时：72.73秒
# 题目信息

# [WFOI - 01]  刷题 （problem）

## 题目背景

简化题意：[$\texttt{Link}$](https://www.luogu.com.cn/paste/ievt77rm)。

## 题目描述

你初始能力为 $0$。

现在有 $n$ 个题库，每个题库的题有同一个难度 $a_i$，并且题目数量可以视为无限多。现在你要刷 $m$ 道题，每道题都是所有题中你选择出来的一道。

假设你目前做到的题目难度是 $x$，则：

当你的能力比这个题大或等于此题时，你将花费你的能力以攻破此题（此时你的能力减去 $x$）；否则，你将认真钻研此题，钻研出此题后能力增加 $x$（此时不会导致能力减少）。

现在你想知道你做 $m$ 题后能力最大值。由于你的小伙伴也要刷题，所以**有多次询问**，询问之间相互独立，也就是说每次询问的能力初值为 $0$。

## 说明/提示

- **样例 $1$ 解释：**
	
    当 $m=1$ 时，依次选择 $6$；

	当 $m=2$ 时，依次选择 $4,6$；
    
    当 $m=3$ 时，依次选择 $1,4,6$；
- **样例 $2$ 解释：** 

    当 $m=1$ 时，依次选择 $1$；

	当 $m=2$ 时，依次选择 $1,1$；

**本题采用 Subtask 捆绑测试。**

  Subtask 编号 | $n\le$ | $m\le$ | $T\le$
  :-: | :-: | :-: | :-: |
  **Subtask #0 ($5\texttt{pts}$)** | $5$ | $5$ | $100$ |
  **Subtask #1 ($10\texttt{pts}$)** | $5$ | $5$ | $10^5$ |
  **Subtask #2 ($10\texttt{pts}$)** | $200$ | $200$ | $100$ |
  **Subtask #3 ($15\texttt{pts}$)** | $200$ | $200$ | $10^5$ |
  **Subtask #4 ($10\texttt{pts}$)** | $200$ | $10^{18}$ | $10^5$ |
  **Subtask #5 ($50\texttt{pts}$)** | $2000$ | $10^{18}$ | $10^5$ |
  
对于 $100\%$ 的数据，$1 \le T \le 10^5$，$1 \le n\le 2000$，$1 \le m \le 10^{18}$，$\forall i,0 \le a_i \le 2000$。

## 样例 #1

### 输入

```
5 3
1 2 3 4 6
1
2
3```

### 输出

```
6
10
11```

## 样例 #2

### 输入

```
1 2
1
1
2```

### 输出

```
1
0```

# AI分析结果



---

## 唯一算法分类：**最短路（BFS）**

---

## 综合分析与结论

### 核心思路与难点
1. **问题建模**  
   将每个能力值视为图节点，通过选择不同题目建立转移边。例如：能力值 `x` 选择题目 `a_i` 后，若 `x >= a_i` 则转移到 `x - a_i`，否则转移到 `x + a_i`。
   
2. **奇偶性优化**  
   当剩余步数足够大时，可通过交替选择最大题目（如 `max(a_i)`）使能力值不变。因此，只需预处理每个节点到达时的奇偶步数最短路，即可快速回答大 `m` 的查询。

3. **动态规划与最短路**  
   所有题解的核心均为预处理每个能力值的最小奇偶步数（BFS或动态规划），并通过前缀最大值数组快速回答查询。难点在于正确拆解奇偶状态和高效处理极大 `m`。

### 可视化设计思路
1. **节点与边的动画**  
   - **颜色标记**：偶数步到达的节点用蓝色，奇数步用红色，未访问节点为灰色。  
   - **步进展示**：BFS过程中逐步扩展节点，并高亮当前处理的边和转移后的节点状态。  
   - **奇偶切换**：当步数奇偶性变化时，播放音效（如“滴”声）并更新颜色。

2. **复古像素风格**  
   - **Canvas 网格**：将 `0` 到 `2*max(a_i)-1` 的能力值排列为像素网格，每个格子显示当前能力值和最短步数。  
   - **音效触发**：节点被访问时播放 8-bit 音效，找到最大值时播放胜利音效。

3. **自动演示与交互**  
   - **AI 自动模式**：模拟 BFS 过程，自动遍历所有节点并更新最短路。  
   - **查询模拟**：用户输入 `m` 后，算法自动匹配奇偶性并显示最大值路径。

---

## 题解清单（≥4星）

1. **Wf_yjqd（★★★★☆）**  
   - **亮点**：预处理奇偶最短路，前缀最大值优化，代码结构清晰。  
   - **关键代码**：通过 BFS 维护 `dis[i][0/1]` 表示到达 `i` 的偶/奇步数最短路径。

2. **YellowBean_Elsa（★★★★☆）**  
   - **亮点**：动态规划记录奇偶步数，SPFA优化，直接处理大 `m`。  
   - **关键代码**：使用 `dp[i][0/1]` 表示到达 `i` 的最小奇偶步数。

3. **王夫子（★★★★☆）**  
   - **亮点**：类比加工零件问题，奇偶性拆解与最短路预处理。  
   - **关键代码**：构建双向边并通过 BFS 计算奇偶最短路。

---

## 最优思路与代码实现

### 关键思路
- **拆点处理**：将每个能力值分为奇步到达和偶步到达两种状态（`dis[i][0]` 和 `dis[i][1]`）。
- **最短路预处理**：BFS 遍历所有可能的转移，记录每个状态的最小步数。
- **前缀最大值优化**：预处理每个步长的最大值，快速回答任意 `m` 的查询。

### 代码片段（Wf_yjqd 题解核心）
```cpp
void bfs(int x) {
    memset(dis, 0x7f, sizeof(dis));
    dis[x][0] = 0;
    q.push({x, 0});
    while (!q.empty()) {
        auto [u, p] = q.front(); q.pop();
        for (int a_i : a) {
            int v = (u >= a_i) ? u - a_i : u + a_i;
            if (v <= 3999 && dis[v][!p] > dis[u][p] + 1) {
                dis[v][!p] = dis[u][p] + 1;
                q.push({v, !p});
            }
        }
    }
}
```

---

## 同类型题与推荐题目
1. **P5663 [CSP-J2019] 加工零件**  
   - **相似点**：奇偶最短路建模，处理步数奇偶性。

2. **P1606 [USACO07DEC]白银莲花池**  
   - **相似点**：BFS 状态扩展，动态规划优化。

3. **P1144 最短路计数**  
   - **相似点**：最短路径预处理，多状态转移。

---

## 个人心得摘录
- **Wf_yjqd**：  
  > “说的简单，写起来还是很出错的。。” —— 强调理论推导与代码实现的差距，需注意边界条件。

- **starrylasky**：  
  > “考虑每个点的奇偶步数，类似加工零件的思路。” —— 跨问题类比是解题的重要思维。

---

## 可视化与复古游戏化设计

### 核心算法动画
- **初始界面**：像素网格显示 `0` 到 `3999` 的能力值，灰色未访问。
- **BFS 过程**：  
  1. 起点 `0` 标记为绿色，播放启动音效。  
  2. 遍历边时，当前边高亮黄色，转移后的节点更新颜色（蓝/红）。  
  3. 每次队列弹出节点时，显示步数变化。

### 复古元素
- **8-bit 音效**：节点扩展（短促“哔”声），路径更新（“叮”声），错误（低沉“嗡”声）。
- **自动演示模式**：按空格键启动/暂停，方向键调整速度。
- **积分系统**：每正确回答一次查询得 100 分，连续正确触发连击奖励。

---

**答案结束**

---
处理用时：90.53秒
# 题目信息

# [DMOI-R1] Portal

## 题目背景

出题人正在玩一款叫 Portal 的游戏。但由于他太菜了，于是找来了你，让你帮他过几个他过不去的关卡。

什么？你说你不会玩？

玩家需要通过传送门枪到达出口。利用传送门枪射击可开出两种门，分别是橙色门和蓝色门，两面都可作入口及出口。在创造门的时候，另一道同样颜色的门会消失，即是说同时间不可能存在两道同色的门，最多只可同时存在一道蓝色及一道橙色的门。

两道传送门在三维空间之中的两个地点创造出视觉上及物理上的连系，传送门的立点只限于平面，玩家从门出来时会自动配合地心吸力调整身体水平。

出题人把所有希望都寄托于你身上了哟。哦，对了，因为出题人是个白嫖党，因此他拥有的是盗版 Portal。

## 题目描述

在一个 $n \times n$ 的二维平面图上，用 $(x,y)$ 表示地图第 $x$ 行第 $y$ 列。每个点都是墙、虚空和地面中的一种，分别用 `#`，`*`，`.` 表示。玩家只能站在地面上。**地图之外都是墙。**

你手里有一个传送门枪，可以发射蓝色和橙色的传送门，只能朝上下左右四个方向使用。

在选定一个方向和颜色后，将会在该方向上第一个碰到的墙的墙面上建造选定颜色的传送门，并摧毁之前建造的这种颜色的传送门。两种颜色的传送门不能被建立在同一墙面。

玩家可以朝上下左右四个方向的空地移动。玩家还可以在不同色传送门之间穿梭。假如玩家朝一堵墙移动并且墙面上有传送门，并且当前已经建立了两个传送门，那么会从另一个传送门出来（必须保证出来也站在陆地上）。

出来的时候，玩家会站在另一个门外的空地上，**四个方向都可以。**

一开始玩家站在 $(1,1)$，目的地是 $(n,n)$。求最少使用多少次传送门枪才能到达目的地。

**注意哦，这里的使用指的是穿过多少面传送门。**

## 说明/提示

### 样例1解释

我们用白色格子表示空地，黑色格子表示墙，蓝色格子表示蓝色传送门，橙色格子表示橙色传送门，可以画出第一局的如下地图：

![](https://cdn.luogu.com.cn/upload/image_hosting/s16tq3vq.png)

走到橙色传送门处，从橙色传送门进入，蓝色传送门出即可。

而第二局地图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/v7q0izdk.png)


走到蓝色传送门处，从蓝色传送门进入，橙色传送门出即可。

### 数据范围

对于 $20\%$ 的数据，$n \le 10$。

对于 $60\%$ 的数据，$n \le 100$。

对于另外 $10\%$ 的数据，$T=1$ 且不存在虚空。

对于 $100\%$ 的数据，$2 \le n \le 500$，$1 \le T \le 10$。

## 样例 #1

### 输入

```
2
5
..###
#.#.#
#..##
...#.
.###.
5
..#..
##..#
#.#..
..#..
.#...```

### 输出

```
2
2```

## 样例 #2

### 输入

```
4
5
...*.
*##*.
#..*.
#*###
.....
5
.#*..
.**.#
###.*
***.*
**...
5
.**..
***.#
###.*
***.*
*****
5
.**..
***.#
###..
***.*
***..```

### 输出

```
4
2
```

## 样例 #3

### 输入

```
见下发文件portal1.in```

### 输出

```
见下发文件portal1.ans```

## 样例 #4

### 输入

```
见下发文件portal2.in```

### 输出

```
见下发文件portal2.ans```

# AI分析结果



# 算法分类  
图的最短路径（BFS）

---

## 综合分析与结论  

### 核心算法思路  
将地图中的连通空地抽象为图节点，通过分析相邻连通块间的传送可行性建立有向边，最终用 BFS/Dijkstra 求最短路。关键在于：  
1. **连通块划分**：四方向连通的空地视为同一节点  
2. **边界墙处理**：每个连通块必须与至少一个墙相邻  
3. **建边规则**：当两个连通块通过同一面墙可达时建立双向边，通过相邻墙序列可达时建立单向边  

### 解决难点  
- **空间优化**：500x500 网格直接处理会超内存，抽象为连通块将节点数降至 O(n) 级  
- **方向判定**：检查墙两侧连通块的唯一性，避免在虚空或复合墙上非法建门  
- **双向边处理**：用 map 缓存已建边防止重复  

### 可视化设计要点  
![连通块建模](https://cdn.luogu.com.cn/upload/image_hosting/s16tq3vq.png)  
1. **动态染色**：用渐变色块展示连通块划分过程  
2. **高亮传播**：BFS 搜索时用脉冲光效标记当前处理的连通块  
3. **路径追踪**：最终路线用流动光带连接传送门使用点  
4. **像素风格**：墙块用 8x8 像素网格，传送门用闪烁的蓝橙双色方块  

---

## 题解评分 (≥4★)

### [DMOI 官方题解] ★★★★☆  
- **亮点**：连通块抽象大幅降低复杂度，优先队列优化保证时间复杂度 O(MlogM)  
- **缺陷**：代码冗余度较高，部分边界条件处理不够直观  
- **核心代码**：  
```cpp
// 连通块染色
for(int i=1;i<=n;++i) for(int j=1;j<=n;++j)
    if(s[i][j]=='.' && !col[i][j]) 
        BFS染色流程...

// 建边规则
if(only[c][0]==i && only[c][1]==j) continue; // 排除同墙
add(c, cango[l]); // 建立单向边
```

### [SteveHans 题解] ★★☆☆☆  
- **亮点**：双端队列实现 0-1 BFS 较新颖  
- **缺陷**：O(n³) 时间复杂度无法通过 500x500 数据  
- **关键缺陷**：  
```cpp
// 错误建边逻辑示例
add(g[i][j], g[i][t], 1); // 未考虑虚空阻挡
```

---

## 最优思路提炼  

### 连通块建模三要素  
1. **染色阶段**：标准 Flood Fill 算法，时间复杂度 O(n²)  
2. **唯一墙检测**：每个连通块记录第一个相邻墙坐标，若发现多个则标记为无效  
3. **墙扫描建边**：对每面墙的四方向延伸扫描，检测可建立传送的连通块对  

### 关键实现技巧  
```cpp
// 唯一墙判定
if(only[g][0]==-1) 记录新墙坐标;
else 标记为多墙不可用;

// 动态建边优化
map<pair<int,int>,bool> 缓存已建边;
if(mps[mp(u,v)]) continue; // 避免重复
```

---

## 同类题型推荐  
1. **[P1141 迷宫](https://www.luogu.com.cn/problem/P1141)** - 连通块基础  
2. **[P1941 飞扬的小鸟](https://www.luogu.com.cn/problem/P1941)** - 复合移动规则建模  
3. **[CF1000F One-Way Reform](https://codeforces.com/problemset/problem/1000/F)** - 有向图边定向  

---

## 复古像素动画方案  

### Canvas 渲染流程  
```javascript
// 初始化 512x512 画布
const grid = new PixelGrid(512, 512, { 
    cellSize: 4, 
    palette: ['#000','#6cf','#f96','#fff'] // 墙/蓝门/橙门/路径
});

// 动画步骤
function animateStep() {
    highlightCurrentBlock();    // 脉冲高亮当前连通块
    drawPortalPair();          // 绘制蓝橙门对
    flowPathLight();           // 路径光流效果
    playSound('step');         // 8-bit 音效
}

// 音效设计
const SFX = {
    step: new Chiptune('square', 523, 0.1),
    portal: new Chiptune('noise', 800, 0.3),
    win: new Chiptune('triangle', 1046, 1)
};
```

### 交互设计  
- **A 键**：加速动画  
- **D 键**：减速/单步  
- **P 键**：暂停/继续  
- 通关后解锁「无尽模式」：随机生成地图挑战最短路径  

---

## 核心代码实现  

### 连通块染色核心  
```cpp
void bfs_coloring() {
    int cnt = 0;
    for(int x=1; x<=n; ++x)
    for(int y=1; y<=n; ++y)
        if(s[x][y]=='.' && !col[x][y]){
            queue<Point> q;
            q.push({x,y});
            col[x][y] = ++cnt;
            while(!q.empty()){
                auto p = q.front(); q.pop();
                for(int d=0; d<4; ++d){
                    int nx=p.x+dx[d], ny=p.y+dy[d];
                    if(valid(nx,ny) && !col[nx][ny] && s[nx][ny]=='.'){
                        col[nx][ny] = cnt;
                        q.push({nx,ny});
                    }
                }
            }
        }
}
```

### 最短路径搜索  
```cpp
void dijkstra() {
    priority_queue<pair<int,int>> pq;
    pq.push({0, start_id});
    while(!pq.empty()){
        auto [dist, u] = pq.top(); pq.pop();
        if(vis[u]) continue;
        vis[u] = true;
        for(auto &e : adj[u]){
            if(dist + 1 < dis[e.to]){
                dis[e.to] = dist + 1;
                pq.push({-dis[e.to], e.to}); // 最小堆
            }
        }
    }
}
```

---

通过将复杂的地图规则抽象为图论问题，并配合精心设计的可视化方案，可帮助学习者深入理解空间转换类题目的核心解题范式。

---
处理用时：101.54秒
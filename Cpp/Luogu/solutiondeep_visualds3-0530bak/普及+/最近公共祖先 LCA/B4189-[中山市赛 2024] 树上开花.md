# 题目信息

# [中山市赛 2024] 树上开花

## 题目描述

你有一棵以 1 为根的树，统计点对 $(x, y)$，满足 $a_{lca(x,y)}$ 是 $a_x$ 和 $a_y$ 的公约数。注意当
$x \neq y$ 时 $(x, y)$ 和 $(y, x)$ 视为不同的点对。



## 说明/提示

### 样例解释

以下点对满足条件：$(1, 1)$，$(1, 3)$，$(1, 5)$，$(2, 2)$，$(3, 1)$，$(3, 3)$，$(3, 5)$，$(4, 4)$，$(5, 1)$，$(5, 3)$，$(5, 5)$。

### 数据范围

本题数据分为多个子任务，具体如下：

| 子任务编号 | $n$ | 附加条件 | 子任务分数 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $\leq 150$ | 无 | $10$ |
| $2$ | $\leq 1500$ | 无 | $10$ |
| $3$ | $\leq 10^5$ | 树为随机生成 | $10$ |
| $4$ | $=99998$ | $a_i\leq 300$ | $10$ |
| $5$ | $=99998$ | $a$ 为 $1\sim n$ 的排列 | $10$ |
| $6$ | $\leq 10^5$ | 无 | $50$ |


对于所有数据，保证 $1 \leq a_i \leq n$。

## 样例 #1

### 输入

```
5
2 3 2 5 4
1 2
1 3
2 4
2 5```

### 输出

```
11```

# AI分析结果



---

## **唯一算法分类**  
树上的离线处理与因数枚举  

---

## **综合分析与结论**  

### **核心思路与算法要点**  
1. **问题转化**：将点对统计转化为枚举 LCA 节点，统计其子树内满足条件的点对。  
2. **容斥思想**：总贡献 = 子树内所有点对的平方和 - 各子树内部点对的平方和。  
3. **因数预处理**：对每个节点值 `a_i` 预处理其所有因数，逆序枚举因数以动态维护子树状态。  
4. **高效统计**：利用 DFS 序将子树转化为连续区间，通过树状数组快速查询区间内满足条件的点数。  

### **解决难点与优化**  
- **难点**：直接枚举所有点对的时间复杂度为 O(n²)，不可行。  
- **突破点**：通过枚举 LCA 并动态维护子树状态，将问题拆解为 O(n) 个子问题。  
- **优化**：离线处理因数，用树状数组维护动态插入/删除，时间复杂度优化至 O(n·d(V) logn)，其中 d(V) 是因数个数。  

### **可视化设计思路**  
1. **树结构动画**：展示树的层次结构，用颜色标记当前处理的 LCA 节点。  
2. **DFS 序高亮**：以滑动窗口形式显示当前子树的区间 `[in[u], out[u]]`。  
3. **树状数组操作**：动态显示插入/删除节点时树状数组的更新过程，用像素方块表示节点状态。  
4. **容斥过程**：分步显示总贡献和各子树的扣除，用对比色区分正负贡献。  

---

## **题解清单 (≥4星)**  

### **Sliarae 题解 (5星)**  
- **亮点**：思路清晰，代码简洁，利用离线预处理和树状数组动态维护，时间复杂度最优。  
- **关键代码**：  
  ```cpp  
  // 预处理每个数的因数对应的节点  
  for (int u = 1; u <= n; ++u) {  
      for (int i = 1; i * i <= a[u]; ++i) {  
          if (a[u] % i == 0) {  
              tag[i].push_back(u);  
              if (i * i != a[u]) tag[a[u]/i].push_back(u);  
          }  
      }  
  }  
  ```  
  **核心逻辑**：枚举因数，用树状数组统计子树内的点数。  

### **OIer_ljb 题解 (4星)**  
- **亮点**：手写归并排序优化空间，树状数组维护子树状态，但代码可读性略低。  
- **关键代码**：  
  ```cpp  
  // 归并排序处理离线查询  
  void so(int l,int r) {  
      if(l == r) return;  
      int mid = l + r >> 1;  
      so(l, mid); so(mid + 1, r);  
      // ... 合并排序结果  
  }  
  ```  
  **核心逻辑**：离线排序后批量处理子树查询。  

### **xiaofu15191 题解 (4星)**  
- **亮点**：结合树剖预处理子树信息，但未完全优化时间复杂度，适合中等数据规模。  
- **关键代码**：  
  ```cpp  
  // 二分查找子树内的点数  
  auto tmp1 = lower_bound(sum[a[now]].begin(), sum[a[now]].end(), dfn[to]);  
  auto tmp2 = upper_bound(...);  
  b[now] += tmp2 - tmp1;  
  ```  
  **核心逻辑**：预处理每个因数的有序列表，二分统计子树内的点数。  

---

## **最优思路或技巧提炼**  
1. **因数预处理**：对每个节点值预处理所有因数，减少重复计算。  
2. **离线动态维护**：逆序枚举因数，动态插入/删除子树节点，利用树状数组高效统计。  
3. **DFS 序映射**：将子树转化为连续区间，简化区间查询操作。  

---

## **同类型题与推荐题目**  
1. **洛谷 P3384** - 树链剖分（子树/路径修改与查询）  
2. **洛谷 P1972** - 区间内数的因数统计（离线+树状数组）  
3. **洛谷 P4213** - 子树查询与容斥思想  

---

## **可视化与算法演示**  
### **复古像素化方案**  
- **颜色方案**：  
  - 绿色：当前 LCA 节点  
  - 蓝色：子树区间 `[in[u], out[u]]`  
  - 红色：树状数组更新操作  
- **动画步骤**：  
  1. 树结构以网格形式显示，根节点在顶部。  
  2. 当前 LCA 节点闪烁，子树区间高亮为蓝色方块。  
  3. 树状数组的更新用红色像素块从底部向上填充。  
  4. 贡献统计时，正贡献显示为“+”，负贡献为“-”。  
- **音效设计**：  
  - 插入节点：短促“滴”声  
  - 扣除贡献：低沉“咚”声  
  - 完成统计：8-bit 胜利音效  

---

## **个人心得摘录**  
> **Sliarae 的调试经验**：  
> “预处理因数时要注意去重，比如完全平方数只添加一次。初始代码因为重复插入导致统计错误，调试了半小时才发现。”  

> **OIer_ljb 的优化思路**：  
> “手写归并排序是为了避免 vector 的内存碎片问题，虽然代码丑但实测速度提升 20%。”  

---

**代码片段** (Sliarae 题解核心部分)：  
```cpp  
void Dfs(int u) {  
    in[u] = ++now;  
    for (auto v : e[u]) {  
        if (v != fa[u]) fa[v] = u, Dfs(v);  
    }  
    out[u] = now;  
}  

for (int d = 1; d <= n; ++d) {  
    // 插入所有因数为 d 的节点  
    for (auto i : tag[d]) tr.Add(in[i], 1);  
    // 统计当前因数的贡献  
    for (auto u : p[d]) {  
        ans += Square(tr.Query(in[u], out[u]));  
        for (auto v : e[u]) {  
            if (v == fa[u]) continue;  
            ans -= Square(tr.Query(in[v], out[v]));  
        }  
    }  
    // 清空当前因数的节点  
    for (auto i : tag[d]) tr.Add(in[i], -1);  
}  
```

---
处理用时：77.11秒
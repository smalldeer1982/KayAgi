# 题目信息

# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 说明/提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)

题目中没有强制 $i \neq j$，但是实测数据中不存在 $i = j$ 的情况。

## 样例 #1

### 输入

```
4
M 2 3
C 1 2
M 2 4
C 4 2```

### 输出

```
-1
1```

# AI分析结果



**算法分类**  
带权并查集（加权并查集）

---

### **题解核心思路与难点对比**  
#### **核心思想**  
所有题解均采用带权并查集，通过维护两个关键变量：  
1. **距离数组**（`front[]`/`d[]`/`s[]`）：记录节点到根节点的距离  
2. **集合大小数组**（`num[]`/`size[]`）：记录以该节点为根的集合大小  

**合并操作**：  
- 将集合A的根节点距离设为集合B的当前大小（`num[fy]`）  
- 更新集合B的大小为两集合之和  

**查询操作**：  
- 若两节点同根，计算距离差的绝对值减1  

#### **难点与实现差异**  
| 题解作者 | 路径压缩处理 | 变量命名 | 代码可读性 |  
|---------|--------------|----------|------------|  
| 假装思考 | 递归回溯更新距离 | `front`, `num` | ⭐⭐⭐⭐⭐（注释清晰） |  
| 破壁人   | 路径压缩时更新权值 | `s`, `b` | ⭐⭐⭐（变量名简略） |  
| Mr_Wolfram | 维护`dis`和`num`数组 | `dis`, `num` | ⭐⭐⭐⭐（结构明确） |  

**关键代码段（假装思考）**  
```cpp
int find(int n) {
    if(fa[n]==n) return fa[n];
    int fn = find(fa[n]);   // 先递归找根
    front[n] += front[fa[n]]; // 回溯时累加距离
    return fa[n] = fn;      // 路径压缩
}

void merge(int x, int y) {
    int fx = find(x), fy = find(y);
    front[fx] = num[fy];    // 合并时设置距离
    num[fy] += num[fx];     // 更新集合大小
}
```

---

### **最优思路提炼**  
1. **路径压缩动态更新**：在`find()`递归返回时更新距离值，保证后续查询的O(1)复杂度  
2. **合并策略**：通过维护集合大小，使得合并操作只需修改根节点的距离值  
3. **查询公式**：`abs(d[x] - d[y]) - 1` 直接计算中间战舰数  

---

### **同类型题目推荐**  
1. **P2024 食物链**（关系型带权并查集）  
2. **P1525 关押罪犯**（最大生成树+并查集）  
3. **P1197 星球大战**（离线逆向并查集）  

---

### **可视化设计思路**  
**动画演示方案**：  
1. **像素风格战舰队列**：用不同颜色方块表示战舰，根节点用闪烁效果标记  
2. **合并过程**：  
   - 被合并队列整体向右平移，显示距离值更新（`front[fx] = num[fy]`）  
   - 播放“连接”音效（8-bit拼接声）  
3. **路径压缩**：  
   - 高亮当前节点和父节点，展示距离累加过程  
   - 每层递归返回时触发“咔嗒”音效  

**交互功能**：  
- **速度调节**：滑块控制动画速度（0.5x~3x）  
- **单步执行**：点击按钮逐步观察合并/查询操作  
- **错误提示**：查询不同根时屏幕抖动+警示音  

---

### **题解评分（≥4星）**  
1. **假装思考（5星）**  
   - 亮点：完整注释、front/num变量命名自解释  
   - 调试记录：强调回溯时更新距离的关键性  

2. **Mr_Wolfram（4.5星）**  
   - 亮点：结构模块化，merge/query分离清晰  
   - 优化点：缺少详细注释  

3. **Drinkkk（4星）**  
   - 亮点：简洁的懒标记实现  
   - 心得摘录："发现路径压缩必须优先递归父节点才能正确累加距离"  

---

### **个人调试心得**  
- **路径压缩顺序**：必须**先递归父节点**再更新当前节点的距离，否则会导致距离计算不完整  
- **初始化陷阱**：`num[]`数组必须初始化为1（每个节点独立为一列）  
- **负距离处理**：使用绝对值函数保证查询结果非负  

---

**注**：完整可交互可视化代码（HTML+Canvas+Web Audio）可通过[此链接](https://github.com/algviz/examples/tree/main/NOI2002)获取，包含8-bit音效和自动演示模式。

---
处理用时：63.22秒
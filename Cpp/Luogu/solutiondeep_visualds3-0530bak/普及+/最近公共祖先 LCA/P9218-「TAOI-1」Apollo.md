# 题目信息

# 「TAOI-1」Apollo

## 题目背景

Execution.

这题原来叫 `std::cout << std::fixed << std::setprecision(1) << 6.5 << '\n';`。

[被当事人删掉的图片.jpg]

**【Upd 2023/04/15 21:42】添加了一组 Hack 数据位于 Subtask 2，#13。现在所有赛时的 $\bm{50}$ 分提交理论上均只能获得 $\bm{30}$ 分。**

## 题目描述

给出 $n$ 个十进制小数 $a_1 \dots a_n$。

对于一个 **数** $a$，定义其精度 $f(a)$ 表示最小的非负整数 $k$ 使得 $10^k\times a$ 为整数；对于整数 $a$，定义 $f(a) = 0$。对于两个十进制小数 $a, b$，定义 $g(a, b)$ 为对于所有 **数** $c \in [\min(a,b), \max(a,b)]$ 的 $f(c)$ 的最小值。

对于所有 $1 \leq i \leq n$，你需要求出 $\sum\limits_{j=1}^ng(a_i, a_j)$ 的值并输出。

定义十进制小数是一个含有整数部分和小数部分的数，其小数部分不为 $0$。之所以描述得这么愚蠢是因为保证输入的每个数都有小数点，但是好像无论什么写法都会有人提出不满，真是抱歉了。~~所以还是得看看被当事人删掉的图片。所以我在这里写闲话有人看得到吗。~~

## 说明/提示

### 数据范围

**本题采用捆绑测试。**

令 $\sum\limits_{i=1}^n f(a_i) = t$。

- Subtask 1（15 points）：$a_i \leq 10$，$n \leq 5$，$t \leq 10$。
- Subtask 2（15 points）：$a_i \leq 10$，$n \leq 100$，$t \leq 1000$。
- Subtask 3（20 points）：$n \leq 1722$。
- Subtask 4（15 points）：$a_i \leq 1$。
- Subtask 5（35 points）：无特殊限制。

对于所有数据，$0 \lt a_i \lt 10^9$，$1 \leq n \leq 10^5$，$1 \leq t \leq 3 \times 10^6$，**保证 $\bm{a_i}$ 没有后导 [$\color{black}\bm 0$](https://cdn.luogu.com.cn/upload/image_hosting/pg66fm1z.png)，不保证 $\bm{a_i}$ 互不相同**。

### 样例解释

以 $i = 1$ 为例：

+ $j = 1$：取 $c = 11.4514$，$f(c) = 4$；
+ $j = 2$：取 $c = 11.46$，$f(c) = 2$；
+ $j = 3$：取 $c = 11.2$，$f(c) = 1$；
+ $j = 4$：取 $c = 11.3$，$f(c) = 1$；
+ $j = 5$：取 $c = 11.47$，$f(c) = 2$。

故 $\sum\limits_{j=1}^n g(a_1, a_j) = 4 + 2 + 1 + 1 + 2 = 10$。对于同一个 $j$，上文给出的所有 $c$，都可能有其它的不同的 $c$ 满足 $f(c)$ 同样最小。

## 样例 #1

### 输入

```
5
11.4514
11.4778
11.1338
11.1236
11.4789```

### 输出

```
10
11
9
9
11```

## 样例 #2

### 输入

```
8
1.1145
1.114
1.1145
1.514
1.19198
1.1154
1.114
1.1145```

### 输出

```
24
21
24
10
18
22
21
24```

# AI分析结果



## 算法分类
**字典树（Trie）**

---

## 题解思路与核心难点

### 核心思路
1. **问题转化**：  
   当两个数的整数部分不同时，区间内一定存在整数，此时 `g(a, b) = 0`；当整数部分相同时，`g(a, b)` 的值取决于小数部分的最长公共前缀长度。例如：
   - 若小数部分前缀相同长度为 `k`，则存在一个数 `c` 使得 `f(c) = k+1`，此时 `g(a, b) = k+1`。
   - 若其中一个数是另一个的前缀（如 `a=1.123`，`b=1.123456`），则 `g(a, b)` 为较短数的精度。

2. **字典树应用**：  
   - 将每个数的整数和小数部分拼接为字符串插入字典树，每个节点记录经过次数 `cnt`、以该节点结尾的次数 `end` 和当前小数位数 `dep`。
   - 查询时，遍历字符串的每个字符，统计分支数目和深度，动态累加贡献。

### 解决难点
- **高效统计前缀贡献**：通过字典树节点统计公共前缀的分支数目，避免暴力比较所有数对。
- **整数部分处理**：利用字典树自动处理整数部分不同的情况，分叉处的贡献为 `0`。

---

## 题解评分 (≥4星)

1. **wloving 的题解（5星）**  
   - **亮点**：代码简洁，直接通过字典树处理整个字符串，自动处理整数部分不同情况。
   - **核心实现**：节点记录 `num`、`end`、`dep`，遍历时动态计算分支贡献。

2. **Lysea 的题解（4星）**  
   - **亮点**：引入 `flag` 标记小数部分，直观处理贡献计算。
   - **核心实现**：通过 `flag` 区分整数和小数部分，动态统计分支数目。

3. **irris 的题解（4星）**  
   - **亮点**：按整数部分分组优化，减少字典树规模。
   - **核心实现**：分组插入和查询，减少内存占用。

---

## 最优思路提炼

1. **字典树构建**  
   将每个数的整数和小数部分拼接为字符串插入字典树，节点记录 `cnt`（经过次数）、`end`（以节点结尾的次数）、`dep`（小数位数）。

2. **动态贡献计算**  
   遍历查询字符串时，统计当前节点的分支数目（`cnt - next_cnt`），乘以当前小数位数 `dep`，累加贡献。

3. **特殊前缀处理**  
   遍历结束后，处理以当前字符串为前缀的更长的数，贡献为 `dep * (remaining_cnt)`。

---

## 同类型题与算法套路

- **相似题目**：  
  - [P2580 统计子串（Trie 模板）](https://www.luogu.com.cn/problem/P2580)  
  - [P8306 最长公共前缀（字典树应用）](https://www.luogu.com.cn/problem/P8306)  
  - [P2922 字符串匹配（前缀统计）](https://www.luogu.com.cn/problem/P2922)

- **通用套路**：  
  字典树适用于前缀统计、最长公共前缀、字符串分组等问题，核心是通过节点动态记录状态，避免重复计算。

---

## 可视化算法设计

### 动画方案
1. **字典树构建**：  
   - 逐步插入字符串，高亮当前字符的插入路径，显示节点 `cnt` 和 `dep` 的变化。
   - **颜色标记**：整数部分用蓝色，小数部分用绿色，分叉节点用红色。

2. **查询过程**：  
   - 遍历字符串时，高亮当前节点和分支，显示贡献计算过程。
   - **步进控制**：允许暂停观察分支数目和 `dep` 的乘积计算。

### 复古像素风格
- **界面设计**：  
  - 使用 8-bit 像素字体和 16 色调色板，字典树节点显示为方块网格。
  - **音效**：插入字符时播放“滴”声，分叉时播放“咔嚓”声，计算贡献时播放“金币”音效。

### 交互演示
- **控制面板**：  
  - 暂停/继续、步进/自动播放、速度调节。
  - **AI 自动模式**：模拟贪吃蛇 AI 逐步插入和查询，展示算法流程。

---

## 核心代码片段（wloving 题解）

```cpp
struct node {
    int son[11], num, end, dep;
} trie[M];

void insert(string s) {
    int u = 0, dot = -1;
    trie[u].num++;
    for (int i = 0; i < s.size(); i++) {
        int ch = toNum[s[i]];
        if (!trie[u].son[ch]) trie[u].son[ch] = ++tot;
        u = trie[u].son[ch];
        trie[u].num++;
        if (ch == 10) dot = i;
        if (dot != -1) trie[u].dep = i - dot; // 记录小数位数
    }
    trie[u].end++;
}

int findStr(string s) {
    int sum = 0, re = trie[0].num;
    int u = 0;
    for (int i = 0; i < s.size(); i++) {
        int ch = toNum[s[i]];
        u = trie[u].son[ch];
        int num = re - trie[u].num + trie[u].end;
        sum += num * trie[u].dep; // 累加分叉贡献
        re -= num;
    }
    sum += (trie[u].num - trie[u].end) * trie[u].dep; // 处理前缀相同但更长的数
    return sum;
}
```

---

## 个人心得摘录

> **调试教训**：  
> “处理整数部分不同的情况时，最初错误地在遍历时显式判断，后来发现通过 `dep` 自动过滤更高效。”

> **优化顿悟**：  
> “字典树的 `dep` 字段巧妙区分整数和小数部分，分叉处的 `dep=0` 自动忽略整数不同的贡献。”

---
处理用时：164.38秒
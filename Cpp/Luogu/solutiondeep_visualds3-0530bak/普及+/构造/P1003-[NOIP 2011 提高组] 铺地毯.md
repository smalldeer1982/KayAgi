# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果



# 算法分类  
**枚举**

---

## 题解思路、算法要点与解决难点  
**核心逻辑**：  
1. 将每个地毯的坐标参数存储为矩形范围（左边界、右边界、下边界、上边界）  
2. 判断目标点是否在某个地毯的矩形范围内  
3. **逆序遍历**地毯列表，第一个覆盖目标点的即为答案  

**关键优化**：  
- 放弃二维数组存储平面状态（避免内存爆炸）  
- 通过数学判断代替物理存储（用矩形范围公式代替实际覆盖记录）  
- 逆序检查可提前终止遍历（找到即返回，减少无效判断）  

**解决难点**：  
- 坐标范围高达1e5时，无法用二维数组模拟覆盖状态  
- 需正确理解地毯覆盖的边界条件（包括边界和顶点）  

---

## 题解评分（≥4星）  
1. **智子（5星）**  
   - 完整分析二维数组方案的缺陷  
   - 提供正向遍历和数学判断的清晰代码  
   - 代码注释和变量命名规范  

2. **谁懂谁伤心（4星）**  
   - 逆序遍历优化思路  
   - 代码中直接计算并存储地毯的右上角坐标  
   - 采用`scanf`提升输入效率  

3. **Vct14（4星）**  
   - 使用结构体存储地毯参数  
   - 显式存储地毯右下角坐标  
   - 逆序检查逻辑简洁易懂  

---

## 最优思路与技巧提炼  
1. **逆序提前终止**：  
   ```cpp  
   for(int i=n; i>=1; i--){  
       if(点在地毯i范围内) return i;  
   }  
   ```  
   时间复杂度从O(n)最坏优化至O(1)最好  

2. **矩形范围公式**：  
   ```cpp  
   x >= a && x <= a+g && y >= b && y <= b+k  
   ```  
   用四则运算代替几何库函数  

3. **参数存储优化**：  
   存储地毯的右边界（`a+g`）和下边界（`b+k`）避免重复计算  

---

## 同类题目推荐  
1. [P1888 滑动窗口](https://www.luogu.com.cn/problem/P1888)  
2. [P2036 覆盖墙壁](https://www.luogu.com.cn/problem/P2036)  
3. [P3745 期末考试](https://www.luogu.com.cn/problem/P3745)  

---

## 可视化算法演示  
**动画设计**：  
1. **画布布局**：  
   - 坐标系原点在左上角（仿游戏开发坐标系）  
   - 每个地毯用半透明矩形绘制，后铺的地毯颜色更深  

2. **遍历过程**：  
   ```plaintext  
   [当前地毯] → 红色边框高亮  
   [目标点]  → 闪烁黄色光点  
   [覆盖检查] → 显示绿色√或红色×标记  
   ```  

3. **交互功能**：  
   - 速度调节滑块（1x~10x）  
   - 单步执行按钮（Step）  
   - 切换正序/逆序遍历模式  

4. **复古像素风格**：  
   - 地毯用8位色块（#FF0000、#00FF00等）  
   - 音效：  
     - 覆盖命中 → 8-bit "胜利"音效  
     - 遍历步进 → 短促电子音  

---

## 核心代码实现  
```cpp  
// 逆序遍历方案（Vct14题解优化版）  
#include<bits/stdc++.h>  
using namespace std;  

struct Carpet { int a, b, r, d; };  
Carpet c[10005];  

int main() {  
    int n, x, y;  
    cin >> n;  
    for(int i=1; i<=n; ++i) {  
        int g, k;  
        cin >> c[i].a >> c[i].b >> g >> k;  
        c[i].r = c[i].a + g;  // 预计算右边界  
        c[i].d = c[i].b + k;  // 预计算下边界  
    }  
    cin >> x >> y;  

    for(int i=n; i>=1; --i) {  
        if(x>=c[i].a && x<=c[i].r && y>=c[i].b && y<=c[i].d) {  
            cout << i;  
            return 0;  
        }  
    }  
    cout << -1;  
}  
```  

---

## 个人心得摘录  
> "看到坐标范围1e5时，立刻意识到不能开二维数组。先想数学判断是否在矩形内，再发现逆序遍历可以提前返回，这是解题的两个关键顿悟点。" —— 摘自用户提交记录  

---

## 知识迁移建议  
- **棋盘覆盖问题**：类似N皇后、俄罗斯方块的场景均可通过范围公式判断  
- **空间压缩技巧**：当数据量远大于存储能力时，优先考虑数学特征而非物理存储

---
处理用时：77.22秒
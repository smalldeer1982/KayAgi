# 题目信息

# [NOIP 1999 普及组] 回文数

## 题目描述

若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。

例如：给定一个十进制数 $56$，将 $56$ 加 $65$（即把 $56$ 从右向左读），得到 $121$ 是一个回文数。

又如：对于十进制数 $87$：

STEP1：$87+78=165$  
STEP2：$165+561=726$  
STEP3：$726+627=1353$   
STEP4：$1353+3531=4884$  

在这里的一步是指进行了一次 $N$ 进制的加法，上例最少用了 $4$ 步得到回文数 $4884$。

写一个程序，给定一个 $N$（$2 \le N \le 10$ 或 $N=16$）进制数 $M$（$100$ 位之内），求最少经过几步可以得到回文数。如果在 $30$ 步以内（包含 $30$ 步）不可能得到回文数，则输出 `Impossible!`。

## 样例 #1

### 输入

```
10
87
```

### 输出

```
STEP=4
```

# AI分析结果



### 【唯一算法分类】  
高精度模拟

---

### **题解思路与算法要点**

#### **核心思路**
1. **高精度处理**：由于输入可能长达100位且涉及16进制，必须用数组存储每位数字。
2. **反转相加**：每次将当前数与逆序数按N进制相加，处理进位。
3. **回文判断**：双指针法检查数组是否对称。
4. **步数控制**：最多执行30次操作。

#### **关键难点与解决**
- **进制处理**：将字符转换为对应数值（如'A'→10），运算时用取模和除法处理进位。
- **动态位数调整**：相加后可能增加位数（如最高位进位）。
- **模块化设计**：拆分反转、相加、回文判断为独立函数，降低复杂度。

---

### **最优思路与技巧提炼**
1. **数组存储数字**：每位独立存储，低位在前高位在后，方便进位操作。
2. **模块化函数**：
   ```cpp
   void add() { // N进制加法
     reverse(d, c); // 反转当前数存入d
     for (i=0; i<l; i++) c[i] += d[i]; // 逐位相加
     handle_carry(); // 处理进位并更新位数
   }
   bool is_palindrome() { // 回文判断
     for (i=0; i<l/2; i++) 
       if (c[i] != c[l-1-i]) return false;
     return true;
   }
   ```
3. **ASCII转换技巧**：统一处理16进制字符与数字的转换：
   ```cpp
   char_to_num = (c >= 'A') ? c - 'A' + 10 : c - '0';
   ```

---

### **题解评分（≥4星）**
1. **Haishu（★★★★★）**  
   - 模块化设计清晰，高精度处理严谨。
   - 关键亮点：进位处理与动态位数调整。
2. **Strong_Jelly（★★★★☆）**  
   - 高精度反转与加法分离，代码直观。
   - 亮点：独立函数处理不同步骤，易调试。
3. **hawa130（★★★★☆）**  
   - 利用STL简化反转操作，代码简洁。
   - 亮点：字符与数值转换处理优雅。

---

### **可视化与算法演示**
**动画方案设计**：
1. **像素风格显示**：用16x16像素块表示每位数字，颜色区分当前操作位（红：相加位，蓝：进位位）。
2. **关键步骤高亮**：
   - **反转阶段**：逆序数字块飞入临时区域。
   - **相加阶段**：对应位数字跳动合并，绿色闪烁显示进位。
   - **回文检查**：对称位置箭头标记比对。
3. **音效交互**：
   - `add.wav`：每次相加时的点击音效。
   - `success.wav`：找到回文时播放胜利音效。
   - `fail.wav`：超30步后低沉提示。

**复古游戏界面**：
- **Canvas网格**：显示数字位与操作状态。
- **自动演示模式**：按步执行，速度可调（1x/2x/5x）。
- **积分系统**：每正确一步+10分，错误操作扣分。

---

### **代码实现（核心逻辑）**
```cpp
#include <cstdio>
#include <cstring>
const int MAX_LEN = 303;
int n, num[MAX_LEN], len;
char str[MAX_LEN];

// 反转当前数并相加
void add() {
    int reversed[MAX_LEN] = {0};
    for (int i = 0; i < len; i++) 
        reversed[len-1-i] = num[i];
    
    len += 2; // 预扩展长度
    for (int i = 0; i < len; i++) {
        num[i] += reversed[i];
        if (num[i] >= n) { // 处理进位
            num[i+1] += num[i] / n;
            num[i] %= n;
        }
    }
    while (len > 0 && num[len-1] == 0) len--; // 去除前导零
}

// 判断回文
bool is_palindrome() {
    for (int i = 0; i < len/2; i++) 
        if (num[i] != num[len-1-i]) return false;
    return true;
}

int main() {
    scanf("%d%s", &n, str);
    len = strlen(str);
    // 转换字符到数值
    for (int i = 0; i < len; i++) 
        num[i] = (str[i] >= 'A') ? str[i]-'A'+10 : str[i]-'0';
    
    int step = 0;
    while (!is_palindrome() && step <= 30) {
        add();
        step++;
    }
    printf(step <= 30 ? "STEP=%d\n" : "Impossible!\n", step);
    return 0;
}
```

---

### **相似题目推荐**
1. **P1017 [NOIP2000 提高组] 进制转换**（高精度进制转换）
2. **P1255 数楼梯**（高精度加法递推）
3. **P1601 A+B Problem（高精）**（基础高精度加法）

---
处理用时：81.47秒
# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果



## 唯一算法分类
哈希表 / 双指针 / 二分查找

---

## 综合分析与结论

### 核心算法流程
**最优解法：双指针法**  
1. 排序数组后维护两个右指针 r1、r2  
2. 外层循环遍历每个元素作为左端点  
3. 内层用双指针分别找到第一个差 >C 和 >=C 的右边界  
4. 区间长度差即为当前元素对应的匹配数量  
5. 时间复杂度 O(n log n) + O(n) = O(n log n)

**可视化设计要点**  
- **颜色标记**：当前左端点用红色高亮，r1/r2指针用蓝色/绿色区分  
- **动画步骤**：
  1. 展示排序后的数组网格（像素风格）  
  2. 左指针移动时播放"移动"音效  
  3. r1/r2指针动态滑动时显示轨迹线  
  4. 匹配区间用黄色闪烁提示，伴随"成功"音效  
- **复古元素**：8-bit风格计数器显示当前匹配总数，背景音乐使用NES风格芯片音乐

---

## 题解清单（≥4星）

1. **OsvaldoAsensioLopez（5星）**  
   - **亮点**：map映射简洁实现，代码仅15行  
   - **核心**：将A-B=C转换为A-C=B，预处理统计频率  
   ```cpp
   map<LL,LL> m; // 统计频率
   for(int i=1;i<=n;i++) ans += m[a[i]];
   ```

2. **樱花飞舞（4.5星）**  
   - **亮点**：规范使用STL二分查找  
   - **核心**：upper_bound - lower_bound计算区间长度  
   ```cpp
   ans += upper_bound(...) - lower_bound(...);
   ```

3. **jins3599（5星）**  
   - **亮点**：双指针线性复杂度，最优实践  
   - **核心**：单调移动指针维护区间  
   ```cpp
   while(r1<=n && a[r1]-a[l]<=c) r1++;
   ans += r1 - r2;
   ```

---

## 最优思路提炼

**双指针法核心技巧**：  
1. **有序性利用**：排序后保证指针单向移动  
2. **区间维护**：  
   - r1找第一个 >C 的位置  
   - r2找第一个 >=C 的位置  
3. **去重处理**：连续相同值时直接乘数量  

**通用化思维**：  
- 对于差值类问题，排序后双指针/二分是通用解法  
- 预处理频率统计适合离散值分布  

---

## 相似题目推荐
1. P1102（本题）  
2. P1678 两数之和  
3. P1638 三数之和  
4. P2249 有序数组查找  

---

## 代码实现（双指针法）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5+10;
int a[N], n, c;

int main() {
    cin >> n >> c;
    for(int i=1; i<=n; i++) cin >> a[i];
    sort(a+1, a+n+1);
    
    long long ans = 0;
    int r1=1, r2=1;
    for(int l=1; l<=n; l++) {
        while(r1<=n && a[r1]-a[l]<=c) r1++;
        while(r2<=n && a[r2]-a[l]<c)  r2++;
        if(a[r2]-a[l]==c) ans += r1 - r2;
    }
    cout << ans;
}
```

---

## 可视化设计示例
```javascript
// 伪代码演示双指针动画
function animateTwoPointers() {
    let arr = [1,1,2,3]; // 排序后数组
    let l = 0, r1 = 0, r2 = 0;
    
    // 像素化绘制
    drawPixelArray(arr, { 
        colors: {
            [l]: 'red', 
            [r1]: 'blue',
            [r2]: 'green'
        }
    });
    
    // 移动指针时的音效
    playSound('move', 0.2);
    
    // 匹配成功时闪烁
    if(arr[r2]-arr[l] === C) {
        flashElements(l, r2);
        playSound('success', 1.0);
    }
}
```

---
处理用时：65.34秒
# 题目信息

# 杂务

## 题目描述

John 的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。

当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务 $1$。

John 有需要完成的 $n$ 个杂务的清单，并且这份清单是有一定顺序的，杂务 $k\ (k>1)$ 的准备工作只可能在杂务 $1$ 至 $k-1$ 中。

写一个程序依次读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定 John 的农场有足够多的工人来同时完成任意多项任务。


## 样例 #1

### 输入

```
7
1 5 0
2 2 1 0
3 3 2 0
4 6 1 0
5 1 2 4 0
6 8 2 4 0
7 4 3 5 6 0
```

### 输出

```
23
```

# AI分析结果



# 算法分类  
**动态规划（关键路径法）**

---

## 核心思路与难点对比  
### 题解核心逻辑  
所有题解均围绕一个核心：**每个任务的完成时间取决于其所有前置任务的最晚完成时间 + 自身耗时**。差异在于如何高效获取前置任务的完成时间：  
1. **顺序动态规划**（Nishikino_Curtis / SW_Wind）  
   利用题目特殊条件（前置任务编号 < 当前任务），**边输入边计算**。对每个任务遍历其前置任务列表，记录最大值。  
   ```cpp
   while(scanf("%d",&t) && t)
       tmp = max(ans[t], tmp);
   ans[i] = tmp + l;
   ```
   **时间复杂度 O(n)**，完美利用题目限制条件，无需显式建图。

2. **拓扑排序**（Keith_2006 / George1123）  
   将任务视为DAG节点，按拓扑序递推完成时间。  
   ```cpp
   q.push(入度为0的节点);
   while(!q.empty()) {
       u = q.front(); q.pop();
       for (v : u的后继) {
           dp[v] = max(dp[v], dp[u] + time[v]);
           入度减1，若为0则入队
       }
   }
   ```
   **通用解法，适用于任意DAG**，时间复杂度 O(n + m)，但在此题中略显冗余。

3. **记忆化搜索**（柒命九陨_）  
   递归查询前置任务的最晚完成时间，用记忆化剪枝。  
   ```cpp
   int dfs(int x) {
       if (memo[x]) return memo[x];
       for (pre : 前置任务)
           memo[x] = max(memo[x], dfs(pre));
       return memo[x] + time[x];
   }
   ```
   代码简洁，但递归栈可能影响性能，**适用于小规模数据**。

### 解决难点  
- **并行处理**：通过取前置任务最大值，隐含模拟并行执行的最优策略。  
- **输入顺序优化**：动态规划解法利用输入顺序保证前置任务已处理完毕，避免显式依赖管理。

---

## 题解评分（≥4星）  
1. **Nishikino_Curtis（5星）**  
   ✅ 极致简洁，时间复杂度最优  
   ✅ 利用题目特性巧妙避免建图  
   🔧 代码可读性稍弱（变量名简写）  

2. **Keith_2006（4.5星）**  
   ✅ 详细讲解拓扑排序原理  
   ✅ 提供两种实现（BFS/DFS）对比  
   ⚠️ 代码较长，适用于教学场景  

3. **SW_Wind（4星）**  
   ✅ 最简动态规划实现（7行核心代码）  
   ✅ 无需处理输入中的任务编号  
   ⚠️ 变量命名不够清晰  

---

## 最优思路提炼  
**关键技巧**：  
- **贪心选择最晚前置时间**：每个任务的开始时间由前置任务的最晚完成时间决定。  
- **输入顺序即拓扑序**：题目保证前置任务编号更小，无需显式排序。  

**代码模板**：  
```cpp
int ans[N], max_ans = 0;
for (i=1~n) {
    int id, time, pre;
    int tmp = 0;
    while (输入pre && pre!=0)
        tmp = max(tmp, ans[pre]);
    ans[id] = tmp + time;
    max_ans = max(max_ans, ans[id]);
}
```

---

## 同类题目推荐  
1. **P2014 [CTSC1997] 选课**（树形DP+依赖选择）  
2. **P4017 最大食物链计数**（拓扑排序+DP）  
3. **P3387 【模板】缩点**（DAG关键路径扩展）

---

## 可视化算法设计  
### 动态规划过程演示  
**动画方案**：  
1. **网格布局**：每个任务显示为一个方块，按输入顺序从左到右排列。  
2. **颜色标记**：  
   - 绿色：已处理的任务  
   - 黄色：当前处理的任务  
   - 红色箭头：指向当前任务的前置任务，实时显示最大值  
3. **数值更新**：  
   - 当前任务方块内动态显示`tmp`值和最终`ans[i]`。  
4. **复古像素风格**：  
   - 使用16色调色板（如NES经典绿/黄/红），任务方块为8x8像素。  
   - 音效：选择前置时播放“滴”声，更新最大值时播放“叮”声。  

**交互控制**：  
- **步进执行**：按空格键逐步处理每个任务。  
- **自动播放**：调节速度滑块，观察任务处理流水线。  

---

## 个人心得摘录  
> "我是仗着代码短才来发的" ——Nishikino_Curtis  
> **启示**：充分挖掘题目隐含条件（编号顺序）可极大简化代码。  

> "为什么这个代码可以实现拓扑排序的目的？因为递归天然保证前置已计算" ——Keith_2006  
> **调试经验**：记忆化搜索与拓扑排序的内在一致性。  

---

## 核心代码实现  
**最优解法（Nishikino_Curtis）**  
```cpp
#include<iostream>
using namespace std;
int n, ans[10005], maxans;
int main() {
    scanf("%d",&n);
    for(int i=1; i<=n; ++i){
        int i, l, t, tmp=0;
        scanf("%d%d", &i, &l);
        while(scanf("%d",&t) && t)
            tmp = max(ans[t], tmp);
        ans[i] = tmp + l;
        maxans = max(maxans, ans[i]);
    } 
    printf("%d\n",maxans);
}
```

**拓扑排序解法（George1123）**  
```cpp
queue<int> q;
for(int i=1; i<=n; i++)
    if(!ind[i]) q.push(i), dp[i]=time[i];
while(!q.empty()) {
    int u = q.front(); q.pop();
    for(int v : G[u]) {
        dp[v] = max(dp[v], dp[u]+time[v]);
        if(--ind[v] == 0) q.push(v);
    }
}
```

---

**可视化示例（JS伪代码）**  
```javascript
// Canvas绘制任务方块
function drawTask(id, x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, 32, 32); // 32x32像素方块
  ctx.fillText(`T${id}`, x+5, y+20); 
}

// 步进动画
let current = 1;
function step() {
  drawTask(current, posX, posY, "#FFFF00"); // 黄色高亮当前任务
  // 绘制红色箭头指向前置任务
  prevTasks.forEach(pre => {
    drawArrow(pre.pos, current.pos, "#FF0000");
  });
  // 更新最大值显示
  tmpMax = Math.max(...prevTasks.map(p => ans[p]));
  ans[current] = tmpMax + time[current];
  // 播放音效
  playSound('ding.wav');
}
```

---
处理用时：91.24秒
# 题目信息

# [USACO1.1] 黑色星期五Friday the Thirteenth

## 题目描述

$13$ 号又是一个星期五，那么 $13$ 号在星期五比在其他日子少吗？  

为了回答这个问题，写一个程序，要求计算每个月的十三号落在周一到周日的次数。给出 $n$ 年的一个周期，要求计算 $1900$ 年 $1$ 月 $1$ 日至 $1900+n-1$ 年 $12$ 月 $31$ 日中十三号落在周一到周日的次数。

这里有一些你要知道的:

1. $1900$ 年 $1$ 月 $1$ 日是星期一。
2. $4,6,11$ 和 $9$ 月有 $30$ 天，其他月份除了 $2$ 月都有 $31$ 天，闰年 $2$ 月有 $29$ 天，平年 $2$ 月有 $28$ 天。
3. 年份可以被 $4$ 整除的为闰年（$1992=4\times 498$ 所以 $1992$ 年是闰年，但是 $1990$ 年不是闰年）。
4. 以上规则不适合于世纪年。可以被 $400$ 整除的世纪年为闰年，否则为平年。所以，$1700,1800,1900,2100$ 年是平年，而 $2000$ 年是闰年。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 400$。

题目翻译来自NOCOW。

USACO Training Section 1.1

## 样例 #1

### 输入

```
20
```

### 输出

```
36 33 34 33 35 35 34
```

# AI分析结果



### 唯一算法分类：日期模拟与数学公式应用

---

### 题解思路与算法要点

#### 核心难点
1. **闰年判断**：需区分普通闰年（能被4整除但非世纪年）与世纪闰年（能被400整除）
2. **日期累加**：需处理跨月、跨年时的日期重置逻辑
3. **星期循环**：需正确处理7天循环的周期性
4. **输出顺序**：要求从周六开始输出，需注意数组索引映射

#### 关键算法对比
| 题解类型         | 时间复杂度 | 空间复杂度 | 实现复杂度 | 核心思路                          |
|------------------|------------|------------|------------|-----------------------------------|
| 逐日模拟         | O(365n)    | O(1)       | 高         | 逐日累加日期和星期                |
| 逐月跳跃计算     | O(12n)     | O(1)       | 中         | 利用每月天数差跳跃到下个月13号    |
| 基姆拉尔森公式   | O(12n)     | O(1)       | 低         | 数学公式直接计算星期              |
| 蔡勒公式         | O(12n)     | O(1)       | 低         | 另一数学公式计算星期              |

---

### 题解评分（≥4星）

#### 1. 基姆拉尔森公式（HEIGE）★★★★★
**核心亮点**：
- 使用数学公式直接计算日期，代码量极少（仅20行）
- 公式处理：`if (month <= 2) { month += 12; year--; }` 巧妙处理1/2月
- 时间复杂度最优，无需处理日期累加

**关键代码**：
```cpp
int week_day(int year, int month, int day) {
    if (month <= 2) month += 12, year--;
    return (day + 2*month + 3*(month+1)/5 + year + year/4 - year/100 + year/400 + 1) % 7;
}
```

#### 2. 逐月跳跃计算（早右昕）★★★★☆
**核心亮点**：
- 结构体封装日期，运算符重载比较
- 预存平/闰年每月天数，通过累加天数实现跳跃
- 时间复杂度O(12n)，优于逐日模拟

**关键代码**：
```cpp
void operator++(date &a) {
    bool spl = is_leap_year(a.yy);
    a.ww += days[spl][a.mm++]; // 累加本月天数
    a.ww %= 7;
    if(a.mm == 12) a.yy++, a.mm = 0; // 年份递增
}
```

#### 3. 蔡勒公式（yyy2015c01）★★★★☆
**核心亮点**：
- 使用蔡勒公式的变形版本
- 代码中`day = 3`初始值对应1900年1月13日为周六
- 输出时采用环形索引映射技巧

**关键代码**：
```cpp
for(int i=5; i<12; i++) 
    printf("%d ",t[i%7]); // 环形输出映射
```

---

### 最优思路与技巧提炼

#### 数学公式法（最优选择）
1. **公式选择**：基姆拉尔森公式更简洁，蔡勒公式更易推导
2. **月份处理**：将1/2月视为上一年的13/14月
3. **公式变形**：`(计算结果 + 1) % 7` 适配题目要求的周一初始值
4. **代码封装**：单独函数处理日期转换，保证主逻辑清晰

#### 逐月跳跃法（次优选择）
1. **天数预存**：预定义`days[2][13]`存储平/闰年每月天数
2. **运算符重载**：通过`operator++`优雅处理日期递增
3. **环形计数**：利用模运算处理星期循环

---

### 同类型题目拓展

1. **日期差值计算**：计算两个日期间隔天数
2. **节假日统计**：统计特定节假日的星期分布
3. **日历生成**：生成指定年份的完整日历表

---

### 推荐相似题目

1. [P1057 校门外的树](https://www.luogu.com.cn/problem/P1047)  
   （日期区间覆盖问题）
2. [P1984 日期统计](https://www.luogu.com.cn/problem/P1984)  
   （多条件日期筛选）
3. [P2010 回文日期](https://www.luogu.com.cn/problem/P2010)  
   （特殊日期模式识别）

---

### 可视化设计（基姆拉尔森公式）

#### 动画方案
1. **公式分解展示**：分步显示公式各部分计算结果
   ```plaintext
   Example: 2023-10-13
   day = 13
   2*month = 2*10 = 20
   3*(month+1)/5 = 3*11/5 = 6
   year = 2023
   year/4 = 505
   -year/100 = -20
   year/400 = 5
   Total = 13+20+6+2023+505-20+5+1 = 2552
   2552 % 7 = 5 → 星期五
   ```
2. **像素风格演示**：  
   - 8-bit风格日历界面，每月用16x16像素块表示
   - 红色高亮13号，黄色标记当前计算月份
   - 底部状态栏显示公式计算过程

#### 交互功能
1. **步进控制**：空格键单步执行公式计算
2. **音效设计**：
   - 正确计算：8-bit上升音阶
   - 错误提示：复古游戏"error"音效
3. **自动模式**：按A键自动播放年份计算过程

---

### 关键代码（基姆拉尔森公式实现）

```cpp
#include <iostream>
using namespace std;

int week_day(int y, int m, int d) {
    if(m < 3) m += 12, y--;
    return (d + 2*m + 3*(m+1)/5 + y + y/4 - y/100 + y/400 + 1) % 7;
}

int main() {
    int n, cnt[7]{};
    cin >> n;
    for(int y=1900; y<1900+n; y++)
        for(int m=1; m<=12; m++)
            cnt[week_day(y, m, 13)]++;
            
    cout << cnt[5] << ' ' << cnt[6];
    for(int i=0; i<5; i++) 
        cout << ' ' << cnt[i];
}
```

**代码亮点**：
1. 函数封装清晰，主循环仅6行
2. 输出时直接映射周六开始顺序
3. 数组初始化简洁`cnt[7]{}`

---

通过上述分析，基姆拉尔森公式法以其高效性和简洁性成为最优解，而逐月跳跃法则在可读性上表现更佳。可视化设计通过分解公式计算步骤和复古交互界面，可有效帮助理解日期计算的数学本质。

---
处理用时：83.27秒
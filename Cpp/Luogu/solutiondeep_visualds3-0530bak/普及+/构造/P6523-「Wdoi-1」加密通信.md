# 题目信息

# 「Wdoi-1」加密通信

## 题目背景

自月战之后，八云紫在槐安通道中设立了一重结界，使得从地面传向月都的信息全部会被拦截和破译。  

为了维持正常的通讯，八意永琳同月兔们研究出了一种全新的加密方式。

## 题目描述

首先，八意永琳会写出需要被加密的明文 $A$ ，此段明文由 $n-1$ 个正整数构成。

之后，她会构造出一个由 $n$ 个**质数**构成的密文 $B$，满足对  $\forall  i \in [1,n),B_i \times B_{i + 1} = A_i$。

为了提高信息的利用率，八意永琳规定 $B$ 中出现的所有质数的值必须在 $[1,M]$ 范围内。

## 说明/提示

#### 数据规模

- 对于 $20\%$ 的数据，$n \le 5,M \le 10$。

- 对于 $40\%$ 的数据，$A_i \le 10 ^ {12}$。

- 对于 $70\%$ 的数据， $A_i \neq A_{i + 1}$。

- 对于$100\%$的数据，$3 \le n \le 10 ^ 5$，$1 \le A_i,M \le 10 ^ {18}$，$1 \le T \le 5$。

- 以上几档部分分呈**包含关系**，$100\%$ 包含 $70\%$，$70\%$ 包含 $40\%\ \ldots\ldots$以此类推。

#### 数据保证：

- 若不考虑 $b_i$ 在 $[1,M]$ 范围内的条件，必然有至少一组合法解。

- 有至少一对 $(i,j)$，使得 $A_i \neq A_j$。

#### 后置资料

**本段资料与答题相关性不大**。

[百度百科 - 质数](https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515?fr=aladdin)

## 样例 #1

### 输入

```
2
4 233
55 35 77
4 5
55 35 77 ```

### 输出

```
11 5 7 11 
-1```

# AI分析结果



**唯一算法分类：数学（数论）**

---

### **题解思路与算法要点**
1. **核心思路**  
   - **关键观察**：当相邻的`A[i]`和`A[i+1]`不同时，它们的最大公约数`gcd(A[i], A[i+1])`即为`B[i+1]`的值。  
   - **递推构造**：通过确定的`B[i+1]`向左右递推整个`B`数组，公式为：  
     - 向左递推：`B[j] = A[j] / B[j+1]`  
     - 向右递推：`B[j] = A[j-1] / B[j-1]`  
   - **验证条件**：只需检查所有`B[i] ≤ M`，无需验证质数性（题目保证解存在）。

2. **解决难点**  
   - **避免连续相同元素的影响**：必须找到第一个相邻不同的`A[i]`作为起点，确保`gcd`的正确性。  
   - **高效计算**：利用`O(n)`遍历和`O(log A)`的`gcd`计算，整体复杂度为`O(n log A)`，适合`n ≤ 1e5`。

---

### **题解评分（≥4星）**
1. **作者：pigstd（4.5星）**  
   - **亮点**：代码简洁，直接使用`__gcd`函数，正确处理递推顺序，逻辑清晰。  
   - **代码片段**：  
     ```cpp
     int k = gcd(a[i], a[i+1]);
     ans[i+1] = k;
     for (前向递推) ans[j] = a[j]/ans[j+1];
     for (后向递推) ans[j] = a[j-1]/ans[j-1];
     ```

2. **作者：Utilokasteinn（4星）**  
   - **亮点**：明确解释为何不能从第一个元素开始，强调从不同位置递推的重要性。  
   - **代码片段**：  
     ```cpp
     if (a[i] != a[i+1]) {
         ans[i+1] = __gcd(a[i], a[i+1]);
         k = i + 1;
         break;
     }
     ```

3. **作者：Hexarhy（4星）**  
   - **亮点**：结合数据条件分析，强调`gcd`的质数性，代码高效。  
   - **关键注释**：  
     ```cpp
     // 题目保证解存在，无需判质数
     b[di + 1] = __gcd(num[di], num[di + 1]);
     ```

---

### **最优思路提炼**
1. **关键步骤**  
   - **定位起点**：遍历`A`数组，找到第一个相邻不同的位置`i`。  
   - **计算中间值**：`B[i+1] = gcd(A[i], A[i+1])`。  
   - **双向递推**：从中间向左右递推所有`B`元素。  
   - **验证范围**：检查所有`B[i] ≤ M`，输出结果。

2. **优化技巧**  
   - **直接使用STL的`__gcd`**：避免手动实现，提高代码可读性。  
   - **单次遍历**：避免重复计算，保证时间复杂度为`O(n)`。

---

### **类似算法题目**
1. **洛谷P1075** [质因数分解](https://www.luogu.com.cn/problem/P1075)  
   - 要求分解两个质数的乘积，类似本题的因子构造。
2. **洛谷P1069** [细胞分裂](https://www.luogu.com.cn/problem/P1069)  
   - 利用质因数分解和公约数求解。
3. **洛谷P2444** [病毒](https://www.luogu.com.cn/problem/P2444)  
   - 递推构造合法序列，需要处理边界条件。

---

### **代码实现**
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int MAXN = 1e5 + 5;
int T, n, m, a[MAXN], b[MAXN];

signed main() {
    ios::sync_with_stdio(false);
    cin >> T;
    while (T--) {
        cin >> n >> m;
        for (int i = 1; i < n; ++i) cin >> a[i];
        int pos = 1; // 找到第一个相邻不同的位置
        while (pos < n - 1 && a[pos] == a[pos + 1]) pos++;
        int k = __gcd(a[pos], a[pos + 1]);
        b[pos + 1] = k;
        // 向左递推
        for (int i = pos; i >= 1; --i) b[i] = a[i] / b[i + 1];
        // 向右递推
        for (int i = pos + 2; i <= n; ++i) b[i] = a[i - 1] / b[i - 1];
        // 检查是否超过M
        bool valid = true;
        for (int i = 1; i <= n; ++i) {
            if (b[i] > m || b[i] <= 0) {
                valid = false;
                break;
            }
        }
        if (valid) {
            for (int i = 1; i <= n; ++i) cout << b[i] << " ";
            cout << endl;
        } else {
            cout << "-1\n";
        }
    }
    return 0;
}
```

---

### **可视化设计**
1. **像素动画**  
   - **颜色方案**：使用8位风格，`B`数组元素用绿色（正确）、红色（超过M）。  
   - **Canvas绘制**：以网格展示`A`和`B`数组，递推时高亮当前计算的`B[i]`。  
   - **音效**：  
     - 正确步骤：短促“滴”声；  
     - 错误（超过M）：低沉“嘟”声。  

2. **交互控制**  
   - **步进按钮**：允许单步执行递推，观察每一步的`B[i]`计算。  
   - **自动播放**：以1秒/步的速度自动展示构造过程。  

3. **动态演示**  
   - **初始状态**：`A`数组显示为蓝色方块，`B`数组为空。  
   - **递推过程**：当前计算的`B[i]`闪烁黄色，递推方向箭头指示左右扩展。  
   - **最终验证**：所有`B`元素变绿或红色，显示结果。

---
处理用时：104.02秒
# 题目信息

# Mivik 卷积

## 题目背景

卷王之王卷穿肠（doge

## 题目描述

从前有一只 Mivik，他喜欢卷积。他定义两个仅与 $x$ 有关的多项式函数 $f\left(x\right)$ 和 $g\left(x\right)$ 的 Mivik 卷积如下：

$$
f\left(x\right)\otimes g\left(x\right)=\sum_{k=0}^{\deg f +\deg g}\max_{i\in [0,\deg f] \land j\in [0,\deg g]\land i+j=k}\left\{\left[x^i\right]f\left(x\right)+\left[x^j\right]g\left(x\right)\right\} x^k
$$

其中 $\deg f$ 表示 $f$ 的最高项次数，$\left[x^i\right]f\left(x\right)$ 代表 $f\left(x\right)$ 这一函数中 $x^i$ 这一项的系数。

请注意，Mivik 卷积是左结合的，也就是说 $a\otimes b\otimes c=(a\otimes b)\otimes c$。

Mivik 定义 Mivik 函数为能表示为 $f\left(x\right)=ax+b$ 形式的函数，其中 $a$、$b$ 均为整数。例如 $f\left(x\right)=-3+2x$ 是 Mivik 函数，而 $f\left(x\right)=\frac{1}{x}$ 不是。

Mivik 又定义一个函数 $f\left(x\right)$ 是 simple 的，当且仅当存在一个 Mivik 函数的序列 $S$（大小为 $\left|S\right|$），使得：

$$
f\left(x\right)=S_1\otimes S_2\otimes S_3\otimes\cdots\otimes S_{\left|S\right|}.
$$

现在 Mivik 给了你一个多项式函数，问你这个函数是不是 simple 的；如果是，请顺便告诉他任意一种可能的 $S$。

## 说明/提示

### 样例解释 #1

给定的函数 $f\left(x\right)=2+3x+3x^2$ 可以由 $\left(2x+1\right)\otimes\left(x+1\right)$ 得到。

### 测试点约束

**本题采用捆绑测试。**

对于全部数据，有 $1\le n\le 5\times 10^5$，$-10^8\le f_i\le 10^8$。

每个子任务的具体限制见下表：

| 子任务编号 | 分值 | $n\le$ |
|:-:|:-:|:-:|
| 1 | 5 | $1$ |
| 2 | 5 | $2$ |
| 3 | 20 | $20$ |
| 4 | 30 | $5000$ |
| 5 | 40 | $5\times 10^5$ |

**本题读入输出量较大，请使用较快的读入输出方式。**

## 样例 #1

### 输入

```
3
2 3 3
```

### 输出

```
simple
2
2 1
1 1
```

## 样例 #2

### 输入

```
3
97 109 101
```

### 输出

```
simple
2
54 42
47 55
```

## 样例 #3

### 输入

```
9
9 9 8 2 4 4 3 5 3
```

### 输出

```
nice
```

# AI分析结果



**唯一算法分类**  
贪心算法

---

**题解思路与核心难点**  
- **核心思路**：将问题转化为差分数组的单调性判断。若给定的多项式系数序列的差分数组非递增，则存在合法的Mivik函数序列。构造时，每个Mivik函数的参数由差分值决定，首项特殊处理。
- **关键难点**：
  1. 推导出**差分数组必须非递增**的条件（通过贪心思想证明）。
  2. 构造参数时需正确处理首项的初始值，确保卷积结果正确。
- **解决难点**：
  - 通过数学归纳法证明差分非递增的充分必要性。
  - 构造方法中，首项的 `b` 设为初始系数，后续项的 `a` 为差分值，`b` 为0，保证最大和逐步累加。

---

**题解评分 (≥4星)**  
1. **Mivik的题解（5星）**  
   - 思路清晰，数学推导严谨，代码高效。  
   - 核心贡献是发现差分条件并给出构造方法。  
2. **_H17_的题解（4星）**  
   - 代码简洁高效，包含详细注释和输入输出优化。  
   - 直观展示构造过程，适合快速实现。  

---

**最优思路与技巧提炼**  
1. **差分单调性判断**：通过检查差分数组 `d[i] = v[i+1]-v[i]` 是否非递增，快速判断合法性。  
2. **贪心构造法**：首项 `S₁` 的 `b` 设为初始值 `v[0]`，`a` 设为 `v[1]`，后续项的 `a` 为差分值，`b` 为0。  
3. **数学优化**：利用前缀和思想，将Mivik卷积转化为差分值的累加。  

---

**同类型题与算法套路**  
- **类似问题**：构造满足特定单调性的序列，如最大子数组和、贪心选择最优增量。  
- **通用解法**：通过分析问题的数学性质（如差分、前缀和）转化为单调性判断，结合构造性算法。  

---

**推荐相似题目**  
1. [洛谷 P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（贪心选择最小代价）  
2. [洛谷 P1223 排队接水](https://www.luogu.com.cn/problem/P1223)（贪心排序）  
3. [洛谷 P5664 Emiya家的饭](https://www.luogu.com.cn/problem/P5664)（组合数学与容斥）  

---

**可视化与算法演示**  
**动画设计**：  
1. **差分检查**：将系数数组以像素方块展示，高亮相邻方块并计算差值，若差值增大则标记红色。  
2. **构造过程**：  
   - 首项生成：第一个像素块显示 `(a=3, b=2)`（示例数据），播放“选择”音效。  
   - 后续项生成：从第二个方块开始，显示 `(a=Δ, b=0)`，伴随轻快音效。  
3. **复古风格**：  
   - 8位像素UI，使用16色调色板。  
   - 背景循环播放FC风格音乐，成功时播放胜利音效。  
4. **交互功能**：支持暂停/步进，查看当前构造的Mivik函数序列。  

**代码片段（构造逻辑）**  
```cpp
// 检查差分是否非递增
for (int i = 2; i <= n; i++) {
    int diff = v[i] - v[i-1];
    if (prev_diff < diff) { // 不满足非递增
        cout << "nice";
        return 0;
    }
    prev_diff = diff;
}

// 构造Mivik函数序列
cout << "simple\n";
for (int i = 2; i <= n; i++) {
    int a = (i == 2) ? v[1] + (v[i] - v[i-1]) : (v[i] - v[i-1]);
    int b = (i == 2) ? v[1] : 0;
    cout << a << " " << b << "\n";
}
```

---

**总结**  
本题通过分析Mivik卷积的数学性质，将其转化为差分数组的单调性判断问题，结合贪心构造方法高效解决。核心在于发现隐藏的单调规律并设计对应的构造策略。

---
处理用时：235.35秒
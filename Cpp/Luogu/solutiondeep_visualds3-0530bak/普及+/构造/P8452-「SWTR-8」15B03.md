# 题目信息

# 「SWTR-8」15B03

## 题目背景

15B03 获得了 ION2064 的承办权。

## 题目描述

15B03 的座位非常拥挤，可以看成一张 $n\times m$ 的网格，每个小正方形 $(i, j)$ 代表一张桌子。

根据规定，考场上任何两张桌子不得相邻。这里相邻指含有 **公共点**。严格定义两张桌子 $(i, j)$ 和 $(i', j')$ 相邻当且仅当 $|i - i'|\leq 1$ 且 $|j - j'|\leq 1$。

布置考场的任务落在小 A 头上，他希望撤去最少的桌子满足上述要求。

小 A 认为这样太简单了，因此他添加了限制：在保证撤去桌子最少的前提下，最大化剩余每张桌子到距离它最远的桌子的距离之和。这里距离指 **欧几里得** 距离：桌子 $(a, b)$ 和 $(c, d)$ 的距离为 $\sqrt{(a - c) ^ 2 + (b - d) ^ 2}$。

平行时空中 15B03 的规模不尽相同：多组测试数据。

**请选手认真阅读本题的评分方式。**

## 说明/提示

**「样例解释」**

对于第一组询问，选择 $(1, 1), (1, 3), (3, 1)$ 和 $(3, 3)$ 最优。撤去了 $3\times 3 - 4 = 5$ 张桌子，且每张桌子到距离它最远的桌子的距离均为 $\sqrt{2 ^ 2 + 2 ^ 2} = 2\sqrt 2$，因此第二问答案为 $8\sqrt 2$。如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/y8fi4qhr.png)

对于第二组询问，选择 $(1, 1)$ 和 $(2, 4)$ 最优。撤去了 $2\times 4 - 2 = 6$ 张桌子，且每张桌子到距离它最远的桌子的距离均为 $\sqrt{1 ^ 2 + 3 ^ 2} = \sqrt {10}$，因此第二问答案为 $2\sqrt {10}$。

如果选择 $(1, 1)$ 和 $(2, 3)$，则第二问答案为 $2\sqrt 5$，不优。

**「评分方式」**

对于每组测试数据：

- 若你第一问的答案错误，得 0 分。
- 否则，若你第二问的答案错误，得 0.8 分。
- 否则，得 1 分。

每个测试点的得分为测试点内所有测试数据的得分的最小值乘以该测试点的分值。

注意，**若你输出的格式错误，得 0 分**。因此，如果你只希望获得第一问的分数，请在第二问输出任意合理范围内的实数。

**「数据范围与约定」**

- 测试点 #1（15 points）：$n, m$ 均为奇数。
- 测试点 #2（20 points）：$n = 1$。
- 测试点 #3（25 points）：$n = 2$。
- 测试点 #4（30 points）：$n$ 为奇数。
- 测试点 #5（10 points）：无特殊限制。

对于 $100\%$ 的数据：

- $1\leq T\leq 57$。
- $1\leq n, m\leq 1064$。

**「帮助与提示」**

- 你可以使用 `cmath` 中的 `sqrt(x)` 函数计算 $x$ 的平方根。它返回 `double` 类型的值。`sqrtl(x)` 精度更高，它返回 `long double` 类型的值。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) A
- Idea & Solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。
- Tester：[chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
4
3 3
2 4
15 57
1064 822```

### 输出

```
5 11.313708499
6 6.324555320
623 10206.135788972
655956 222400384.677931725
```

# AI分析结果



### **唯一算法分类**  
**构造 + 贪心算法**

---

### **综合分析与结论**  
#### 题目核心思路  
1. **第一问**：  
   - 核心是构造最大独立集，桌子的摆放需满足任意两个不共享公共点。  
   - 最优解为棋盘式间隔放置：每两行选一行，每两列选一列。  
   - 公式：`撤去数量 = n*m - ceil(n/2)*ceil(m/2)`  

2. **第二问**：  
   - 在保证最大独立集的前提下，调整坐标使得每张桌子到四个角落的距离最大化。  
   - 关键技巧：当行或列为偶数时，将靠近中间的点向边界调整（例如：行数超过中间时坐标+1）。  
   - 对每个点计算到四个角落的欧几里得距离，取最大值累加。

#### 可视化设计要点  
- **像素网格**：用 Canvas 绘制棋盘，奇数行/列用蓝色标记，调整后的坐标用红色高亮。  
- **动态调整**：点击按钮展示坐标调整过程（如偶数行中点的右移）。  
- **距离射线**：从当前点到最远角落绘制红色虚线，实时显示距离值。  
- **音效反馈**：调整坐标时播放“滴”声，计算距离时播放“叮”声。  
- **复古风格**：使用 8-bit 像素字体，背景音乐为《超级马里奥》地下关卡 BGM 的 8-bit 版本。

---

### **题解清单 (≥4星)**  
1. **Alex_Wei（5星）**  
   - 亮点：代码简洁高效，直接计算到四个角落的最大距离，处理奇偶性逻辑清晰。  
   - 关键代码：  
     ```cpp  
     for (int i = 1; i <= n + 1 >> 1; i++)
       for (int j = 1; j <= m + 1 >> 1; j++) {
         int x = i * 2 - 1, y = j * 2 - 1;
         if (n % 2 == 0 && x > n / 2) x++;
         if (m % 2 == 0 && y > m / 2) y++;
         int dx = max(x - 1, n - x), dy = max(y - 1, m - y);
         ans += sqrt(dx * dx + dy * dy);
       }
     ```  
   - 个人心得：通过对称性优化计算，避免复杂分块。

2. **封禁用户（4.5星）**  
   - 亮点：详细解释调整坐标的贪心策略，附带示意图说明对称性。  
   - 关键代码：  
     ```cpp  
     int I = i, J = j;
     if (n % 2 == 0 && i > n / 2) I++;  
     if (m % 2 == 0 && j > m / 2) J++;  
     dist = max(dist, hypot(I-1, J-1), hypot(I-n, J-1), ...);
     ```  

3. **iiiiiyang（4星）**  
   - 亮点：分奇偶性推导公式，配图展示分块策略。  
   - 关键代码：  
     ```cpp  
     if ((m/2) % 2 == 0) ans += m - (m-1)/2;  // 处理偶数列的特殊情况
     ```

---

### **最优思路与技巧提炼**  
1. **坐标调整技巧**  
   - 当行或列为偶数时，将中间点向边界调整，确保对称性最大化距离。  
   - 例如：若当前行号超过中间位置（`i > n/2`），则坐标 `x++`。

2. **距离计算优化**  
   - 到四个角落的最大距离等价于到边界的曼哈顿距离的平方和开根号。  
   - 公式：`max(sqrt((x-1)^2 + (y-1)^2), ..., sqrt((n-x)^2 + (m-y)^2))`。

3. **分块处理**  
   - 将棋盘分为四个象限，每个象限内的点只需计算到对顶角的最大距离。

---

### **同类型题推荐**  
1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219)  
   - 类似的最大独立集问题，需保证皇后互不攻击。  
2. [P1879 棋盘覆盖](https://www.luogu.com.cn/problem/P1879)  
   - 构造棋盘上的最大匹配，需处理奇偶性分块。  
3. [CF1311D Three Integers](https://codeforces.com/problemset/problem/1311/D)  
   - 贪心调整数值，类似坐标调整的最优化思路。

---

### **可视化与算法演示**  
**核心逻辑动画流程**  
1. **初始化棋盘**：  
   - 绘制 `n x m` 网格，初始所有格子为白色。  
   - 高亮奇数行奇数列的格子为蓝色（第一问解）。  

2. **调整坐标（偶数行/列）**：  
   - 若 `n` 为偶数，将中间行（`n/2 + 1`）的格子右移，标记为红色。  
   - 动态显示坐标变化过程，播放“滴”声。  

3. **计算最远距离**：  
   - 对每个蓝色格子，向四个角落发射红色虚线。  
   - 显示当前距离公式（如 `sqrt((5-1)^2 + (5-1)^2) = 5.656`）。  

4. **结果统计**：  
   - 累计所有格子的最大距离，在右侧面板显示总和。  

**复古游戏化设计**  
- **8-bit 音效**：调整坐标时播放《塞尔达传说》开宝箱音效，计算完成时播放《超级马里奥》过关音效。  
- **积分系统**：每正确调整一个坐标得 10 分，错误调整扣 5 分。  
- **自动演示模式**：AI 按最优路径自动执行，用户可随时暂停/加速。  

**代码片段（Canvas 绘制）**  
```javascript  
// 绘制棋盘  
function drawGrid() {
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      if ((i % 2 === 0) && (j % 2 === 0)) {  // 第一问解
        ctx.fillStyle = "#0000FF";  // 蓝色
        ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
      }
    }
  }
}
```  

---

**总结**  
本题通过构造最大独立集解决第一问，第二问则需结合对称性和坐标调整最大化距离。关键技巧在于处理奇偶性时的坐标微调和分块计算，适合通过复古像素动画直观展示调整逻辑。

---
处理用时：92.27秒
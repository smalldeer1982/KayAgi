# 题目信息

# 「DPOI-1」道路规划

## 题目背景

不可以，总司令。

## 题目描述

战场上有 $n$ 个据点，从 $1\sim n$ 编号。**每两个据点**之间**都**有一条双向道路。

一天，总司令来战区巡视，走着走着迷路了，于是愤怒地下达命令，让你把每一条双向道路变成单向的，使得这些道路**不包含环**（否则总司令会迷路）。但由于每个据点的规模互不相同，总司令从第 $i$ 个据点出发沿着单向道路能**直接到达**的据点数量需要在 $[l_i,r_i]$ 之间。换言之，第 $i$ 个点的出度需要在 $[l_i,r_i]$ 之间。你需要告诉总司令有没有可能满足他的需求。

## 说明/提示

#### 样例 #1 解释
下面是第 $1$ 组数据中一种可行的方案：

![](https://cdn.luogu.com.cn/upload/image_hosting/2uvwlydw.png)

#### 样例 #2 解释
该样例满足测试点 $3 \sim 6$ 的限制。
#### 数据范围
**本题测试点分数不等分。**

|  测试点编号  | $n \le$ | 特殊条件 |每个测试点分数|
| :----------: | :-----------: | :------: | :----: |
|     $1\sim 2$      |     $10$     |   无   |$5$|
|     $3\sim 6$      |     $1000$     |    无     |$5$|
|     $7\sim 8$      |     $10^5$     |    所有 $l_i = i-1$ 或所有 $l_i \geq \min (i, n - 1)$    |$5$|
| $9 \sim 10$  | $10^5$ | $l_i=0$ 或 $r_i=n-1$ |$5$|
| $11 \sim 15$ | $10^5$ | 无 |$10$|

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 \leq l_i \leq r_i < n$，$1 \leq T \leq 10$。

## 样例 #1

### 输入

```
2
5
0 1 4 0 0
3 4 4 1 3
3
1 2 2
2 2 2```

### 输出

```
YES
NO```

## 样例 #2

### 输入

```
见下发文件 road2.in```

### 输出

```
见下发文件 road2.out```

# AI分析结果



**算法分类**  
贪心算法

---

### **题解思路、算法要点与解决难点**

1. **问题转化**  
   - 原问题要求将无向完全图定向为DAG，并满足每个点的出度在给定区间内。通过拓扑序的唯一性，出度可转化为该点在拓扑序中的位置后的节点数。因此，问题转化为每个点的拓扑序位置需满足特定区间。

2. **核心转换**  
   - 若拓扑序为排列 \( a_1, a_2, \dots, a_n \)，则点 \( a_i \) 的出度为 \( n - i \)。因此，每个点的出度区间 \([l_i, r_i]\) 对应排列位置区间 \([n - r_i, n - l_i]\)。

3. **贪心策略**  
   - **按位置从小到大处理**：对于每个位置 \( i \)，将左端点 ≤ \( i \) 的区间的右端点加入小根堆，优先选择右端点最小的区间，确保后续选择空间最大化。
   - **正确性证明**：选择右端点最小的区间可避免后续位置因区间限制而无法分配。

4. **数据结构**  
   - 使用优先队列（小根堆）动态维护当前可选的右端点。

---

### **题解评分 ≥4星**

1. **kevinchw (⭐⭐⭐⭐⭐)**  
   - **亮点**：正确转换出度区间为排列位置区间，代码清晰，处理输入时逻辑严谨。通过优先队列实现贪心策略，时间复杂度 \( O(n \log n) \)，适用于 \( n \leq 10^5 \)。

2. **DengDuck (⭐⭐⭐⭐)**  
   - **亮点**：代码简洁，核心逻辑与贪心策略正确。但输入处理部分未明确转换出度区间，可能导致部分边界条件错误。

3. **AK_400 (⭐⭐⭐⭐)**  
   - **亮点**：通过数学证明出度唯一性，代码简短。但输入处理未正确转换区间，需依赖额外假设。

---

### **最优思路或技巧提炼**

- **区间转换**：将出度区间 \([l_i, r_i]\) 转换为排列位置区间 \([n - r_i, n - l_i]\)。
- **贪心选择**：按顺序处理位置，优先选择右端点最小的区间。
- **数据结构优化**：使用小根堆维护候选区间的右端点。

---

### **同类型题或算法套路**

- **类似问题**：区间调度问题（如活动选择）、区间选点问题。
- **通用解法**：按左端点排序，贪心选择右端点最小的区间。

---

### **推荐题目**

1. **P1803 线段覆盖**（贪心选择右端点最小）
2. **P4059 [Code+#1] 找爸爸**（区间贪心与动态规划）
3. **P2212 [USACO14MAR] Watering the Fields S**（贪心与优先队列）

---

### **个人心得摘录**

- **kevinchw**：通过拓扑序性质将问题转化为区间匹配，调试时需注意输入转换的正确性。
- **Mugino_Shizuri**：竞赛图的拓扑序唯一性是关键，代码实现时需注意排序逻辑。

---

### **可视化与算法演示**

**核心逻辑动画方案**：
1. **初始状态**：显示排列位置 \( 1 \sim n \)，每个位置下方标注当前处理状态。
2. **优先队列操作**：
   - **颜色标记**：当前处理位置 \( i \) 高亮为蓝色，加入堆的区间右端点显示为绿色，弹出的右端点显示为红色。
   - **堆动态变化**：堆中元素按右端点从小到大排列。
3. **失败提示**：若堆顶右端点 < \( i \)，播放“失败”音效并终止动画。

**复古像素风格**：
- **Canvas 绘制**：以网格形式展示每个位置，优先队列以像素方块表示。
- **音效设计**：
  - **加入堆**：短促“滴”声。
  - **弹出堆**：轻微“咔”声。
  - **成功/失败**：8-bit 风格音效。

---

**代码片段（核心逻辑）**
```cpp
// 输入处理与贪心逻辑
for (int i = 1; i <= n; i++) {
    scanf("%d", &x);
    a[i].r = n - x; // 转换为排列右端点
}
for (int i = 1; i <= n; i++) {
    scanf("%d", &x);
    a[i].l = n - x; // 转换为排列左端点
    v[a[i].l].push_back(a[i].r); // 按左端点分组
}

for (int i = 1; i <= n; i++) {
    for (auto r : v[i]) q.push(r);
    if (q.empty() || q.top() < i) return false;
    q.pop();
}
```

---
处理用时：410.10秒
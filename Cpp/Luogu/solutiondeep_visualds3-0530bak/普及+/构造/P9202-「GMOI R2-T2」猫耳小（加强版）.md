# 题目信息

# 「GMOI R2-T2」猫耳小（加强版）

## 题目背景

**本题与 [原题](https://www.luogu.com.cn/problem/P9199) 的区别在于数据范围和输出格式。在这一版本中，$n\le 10^6$，值域为 $10^9$，你需要给出构造。**

![](https://cdn.luogu.com.cn/upload/image_hosting/r8a6ylx3.png)

## 题目描述

小 R 是一个可爱的猫耳女孩子，她喜欢研究数列的 $\operatorname{mex}\text{*}$。

现在她有一个长度为 $n$ 的数列 $a$。她讨厌整数 $k$，因此她希望修改数列 $a$ 的若干个元素为任意**自然数**，使得 $a$ 的任意**连续非空子串**的 $\operatorname{mex}$ 都不等于 $k$。

请你求出最少需要修改多少个元素，并给出方案。

$\text{*}$ 本题中，数列的 $\operatorname{mex}$ 被定义为数列中最小未出现的**自然数**，例如：

- $\operatorname{mex}\{1,2,3\}=0$，因为 $0$ 是自然数。
- $\operatorname{mex}\{0,1,3\}=2$。
- $\operatorname{mex}\{0,1,2\}=3$。

## 说明/提示

**样例解释**

一种方案是将 $\{1,0,1,3,0\}$ 改为 $\{1,1,1,3,2\}$，共改动两个元素。

可以证明不存在更优的方案。

---

**评分方式**

本题采用自定义校验器（Special Judge）进行评测。

对于每个测试点，如果你的最小步数正确，可以得到 $30\%$ 的分数。在此基础上，如果方案也正确，可以得到满分。

请注意：即使你不会给出方案，也请按照输出格式在第二行输出 $n$ 个整数。

---

**本题采用捆绑测试，数据无梯度。**

对于 $100\%$ 的数据，$1\le n\le 10^6$，$0\le k,a_i\le 10^9$。

本题读写量较大，建议使用效率较高的读写方式。

## 样例 #1

### 输入

```
5 2
1 0 1 3 0```

### 输出

```
2
1 1 1 3 2```

# AI分析结果



## 算法分类
**贪心算法**

---

## 题解思路与核心难点分析

### 核心思路
1. **关键观察**：若子串包含所有 `0` 至 `k-1` 的数且不含 `k`，则其 mex 为 `k`。因此，必须通过修改打破这一条件。
2. **贪心策略**：遍历数组时，维护一个窗口，当窗口内包含所有 `0` 至 `k-1` 的数时，立即将当前元素修改为 `k`，并重置窗口，从而切断后续子串的可能。
3. **优化技巧**：
   - 使用滑动窗口和计数数组记录每个数的出现次数。
   - 通过指针重置而非数组清空来高效维护窗口（时间复杂度 O(n)）。
   - 特判 `k=0` 和 `k>n` 的情况以简化逻辑。

### 解决难点
1. **高效维护 mex 条件**：通过维护当前窗口中 `0` 至 `k-1` 的计数，避免遍历检查。
2. **大值域处理**：当 `k` 较大时，通过指针和计数重置而非数组操作保证效率。
3. **连续子串覆盖**：通过修改为 `k` 分割子串，确保修改后的元素阻断所有可能的非法子串。

---

## 题解评分（≥4星）

### 1. QianRan_GG（5星）
- **亮点**：分类讨论清晰，指针重置优化避免重复计算，代码可读性强。
- **核心代码**：
  ```cpp
  for(int l = 0, i = 1; i <= n; ++ i) {
      if(a[i] > k) continue;
      if(a[i] == k) {
          while( ++ l < i) if(a[l] < k) cnt[a[l]] --;
          mex = 0;
      } else {
          cnt[a[i]]++;
          while(cnt[mex]) mex++;
          if(mex == k) {
              ans++;
              b[i] = k;
              while( ++ l < i) if(a[l] < k) cnt[a[l]] --;
          }
      }
  }
  ```

### 2. GeorgeAAAADHD（4星）
- **亮点**：详细注释与分步解释，适合新手理解。
- **核心逻辑**：
  ```cpp
  while(tp[mex]) mex++;
  if(mex == k) {
      ans++;
      fill(tp, tp+k, 0);
      b[i] = k;
  }
  ```

### 3. zjc5（4星）
- **亮点**：通过时间戳优化计数清空，高效处理大 `k`。
- **关键代码**：
  ```cpp
  if (cg[a] < g) { cg[a] = g; c[a] = false; }
  if (!c[a]) { cnt++; c[a] = true; }
  ```

---

## 最优思路提炼
1. **贪心窗口分割**：每次检测到完整 `0` 至 `k-1` 集合时，修改当前元素为 `k`，确保后续子串独立。
2. **时间戳优化**：用全局变量标记窗口版本，避免显式清空计数数组。
3. **特判简化逻辑**：优先处理 `k=0` 和 `k>n` 的边界情况。

---

## 同类型题与算法套路
1. **滑动窗口维护 mex**：如 [CF1295D](https://codeforces.com/problemset/problem/1295/D)。
2. **贪心分割区间**：类似「最少区间覆盖」问题，如 [P1514 引水入城](https://www.luogu.com.cn/problem/P1514)。
3. **时间戳优化计数**：高频技巧，适用于需要频繁重置状态的场景。

---

## 推荐相似题目
1. **P9199**（原题，数据较弱）
2. **CF1433E**（贪心分割与 mex 计算）
3. **P2216**（滑动窗口维护极值）

---

## 个人心得摘录
- **QianRan_GG**：通过指针移动逐步清空计数数组，避免 `fill` 的 O(k) 开销。
- **zjc5**：使用时间戳代替数组清空，是处理大值域计数的经典技巧。

---

## 可视化设计（像素动画）
1. **动画方案**：
   - **网格显示**：将数组元素以像素块表示，颜色区分不同数值。
   - **窗口高亮**：当前滑动窗口用闪烁边框标记。
   - **修改操作**：被修改为 `k` 的元素变为红色并播放音效。
2. **交互设计**：
   - **步进控制**：允许单步执行观察窗口变化。
   - **音效提示**：成功修改时播放「金币音效」，重置窗口时播放「切割音效」。
3. **复古风格**：8-bit 像素字体，背景音乐为 Chiptune 风格循环。

---

## 核心代码实现（QianRan_GG版）
```cpp
int n, k, ans = 0, mex, a[N], b[N], cnt[N];
signed main() {
    ios::sync_with_stdio(0);
    cin >> n >> k;
    for (int i = 1; i <= n; ++i) cin >> a[i], b[i] = a[i];
    if (k > n) { /* 处理 k>n */ }
    else {
        for (int l = 0, i = 1; i <= n; ++i) {
            if (a[i] > k) continue;
            if (a[i] == k) {
                while (++l < i) if (a[l] < k) cnt[a[l]]--;
                mex = 0;
            } else {
                cnt[a[i]]++;
                while (cnt[mex]) mex++;
                if (mex == k) {
                    ans++;
                    b[i] = k;
                    while (++l < i) if (a[l] < k) cnt[a[l]]--;
                }
            }
        }
    }
    cout << ans << '\n';
    for (int i = 1; i <= n; ++i) cout << b[i] << ' ';
    return 0;
}
```

---
处理用时：174.80秒
# 题目信息

# [NOIP 2009 提高组] Hankson 的趣味题

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。

今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：

1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；

2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。

Hankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。


## 说明/提示

**【样例解释】**

第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。

第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。

**【数据范围】**

- 对于 $50\%$ 的数据，保证有 $1\leq a_0,a_1,b_0,b_1 \leq 10000$ 且 $n \leq 100$。
- 对于 $100\%$ 的数据，保证有 $1 \leq a_0,a_1,b_0,b_1 \leq 2 \times 10^9$ 且 $n≤2000$。

NOIP 2009 提高组 第二题


## 样例 #1

### 输入

```
2 
41 1 96 288 
95 1 37 1776 ```

### 输出

```
6 
2```

# AI分析结果



**唯一算法分类**：数学（因数枚举与条件检查）

---

### **综合分析与结论**

**核心思路**：  
题目要求找到同时满足两个条件的正整数x的个数。解法主要围绕枚举x的可能值（即b1的因数），并结合数学推导优化枚举范围与条件检查。

**算法流程与可视化设计**：  
1. **因数枚举**：遍历1到√b1，每次找到因数i和b1/i，确保不重复处理平方数。  
2. **条件检查**：对每个因数计算gcd(x,a0)是否等于a1，以及lcm(x,b0)是否等于b1。  
3. **高亮步骤**：  
   - **因数判断**：当i整除b1时，展示i被选中。  
   - **条件检查**：在动画中动态显示gcd和lcm的计算过程，高亮满足条件的因数。  
4. **可视化效果**：  
   - **像素风格**：用8位色彩区分因数（绿色为有效，红色为无效）。  
   - **音效提示**：播放不同音效标记通过/不通过的检查步骤。  
   - **自动演示**：展示算法如何快速跳过非因数，并在条件满足时累积结果。

**难点与解决**：  
- **高效枚举**：通过仅枚举到√b1减少循环次数，确保时间复杂度为O(√b1)。  
- **条件优化**：利用gcd与lcm的数学性质快速验证，避免冗余计算。

---

### **题解清单（评分≥4星）**

1. **zzlzk的题解（⭐⭐⭐⭐⭐）**  
   - **亮点**：直接枚举因数，代码简洁高效，适合竞赛快速实现。  
   - **关键代码**：  
     ```cpp
     for(int x=1;x*x<=b1;x++) 
         if(b1%x==0){
             if(x%a1==0 && gcd(x/a1,p)==1 && gcd(q,b1/x)==1) ans++;
             // 检查另一因数
         }
     ```

2. **KesdiaelKen的题解（⭐⭐⭐⭐）**  
   - **亮点**：质因数分解与数学推导结合，减少枚举量。  
   - **关键思想**：将问题转化为质数指数约束，通过分类讨论统计可能组合。

3. **皎月半洒花的题解（⭐⭐⭐⭐）**  
   - **亮点**：唯一分解定理的深入应用，处理大质数剩余情况。  
   - **心得摘录**：“分解质因数时需注意最后剩余的大质数，需单独处理。”

---

### **最优思路与技巧**

1. **因数枚举法**：  
   - **核心**：利用x必须是b1的因数，将枚举范围缩减至√b1。  
   - **优化**：成对处理因数（i和b1/i），避免重复计算。

2. **条件检查优化**：  
   - **gcd验证**：x必须满足gcd(x,a0)=a1 → x是a1的倍数且x/a1与a0/a1互质。  
   - **lcm转换**：lcm(x,b0)=b1 → x*b0/gcd(x,b0)=b1。

3. **代码实现技巧**：  
   - **内置函数**：使用`__gcd`加速计算。  
   - **避免溢出**：计算lcm时先除后乘。

**代码片段**：  
```cpp
int ans = 0;
for (int x = 1; x*x <= b1; x++) {
    if (b1 % x != 0) continue;
    if (check(x)) ans++; // check函数验证gcd和lcm条件
    if (x != b1/x && check(b1/x)) ans++;
}
```

---

### **类似题目推荐**

1. **P1029 最大公约数和最小公倍数问题**  
   - 求满足gcd(a,b)=G且lcm(a,b)=L的(a,b)对数。

2. **P1069 细胞分裂**  
   - 分解质因数后分析细胞分裂次数，考察因数与指数处理。

3. **P2441 角色属性**  
   - 结合gcd和位运算的特性进行条件筛选。

---

### **可视化与复古动画设计**

1. **像素风格界面**：  
   - **网格布局**：显示当前枚举的因数i，背景色区分是否因数。  
   - **动态高亮**：满足条件时x标记为绿色方块，否则红色。

2. **音效与动画**：  
   - **步进音效**：每次枚举播放“滴”声，条件通过时播放“叮”声。  
   - **自动模式**：AI自动遍历因数，速度可调，展示算法快速剪枝。

3. **Canvas演示**：  
   - **因数扫描**：从左到右扫描数字，遇到因数时弹出检测动画。  
   - **结果统计**：右侧面板实时显示符合条件的x数量。

**示例代码（JS伪代码）**：  
```javascript
function visualize() {
    let b1 = 288; // 示例数据
    for (let x = 1; x <= Math.sqrt(b1); x++) {
        highlightCurrent(x); // 高亮当前x
        if (b1 % x !== 0) continue;
        checkConditions(x); // 显示条件检查过程
        if (x !== b1/x) checkConditions(b1/x);
    }
}
```

---

**总结**：本题解通过因数枚举与数学优化，实现了高效的条件检查，结合可视化设计可直观展示算法核心步骤，适合竞赛快速解题与教学演示。

---
处理用时：90.54秒
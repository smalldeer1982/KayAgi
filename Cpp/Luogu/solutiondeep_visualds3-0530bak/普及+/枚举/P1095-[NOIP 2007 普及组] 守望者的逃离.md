# 题目信息

# [NOIP 2007 普及组] 守望者的逃离

## 题目背景

NOIP2007 普及组 T3

## 题目描述

恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。

守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。

为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。

守望者的跑步速度为 $17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1s$ 内移动 $60m$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。

现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间 $T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。

注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。


## 说明/提示

对于 $30\%$ 的数据，$1  \le  T   \le  10$，$ 1   \le   S   \le  100$；

对于 $50\%$ 的数据，$1   \le  T   \le   10^3$，$ 1   \le  S  \le   10^4$；

对于 $100\%$ 的数据，$1   \le   T   \le   3\times  10^5$，$0   \le   M   \le   10^3$，$ 1   \le  S   \le   10^8$。


## 样例 #1

### 输入

```
39 200 4
```

### 输出

```
No
197
```

## 样例 #2

### 输入

```
36 255 10```

### 输出

```
Yes
6```

# AI分析结果



# 算法分类  
**贪心算法与动态规划结合**

# 综合分析与结论  
题目核心在于在魔法恢复与移动方式之间寻找最优策略。主要解决思路可分为两类：  
1. **贪心策略**：优先使用闪烁法术，剩余魔法不足时按特定条件选择恢复魔法或跑步  
2. **动态规划**：维护两个状态（纯闪现距离/综合最优距离），通过状态转移实现最优解  

**核心难点**：  
- 魔法恢复时间与跑步效率的平衡（如恢复5秒魔法可闪现120m，但直接跑步7秒可跑119m）  
- 剩余时间与剩余距离的临界条件判断  

**可视化设计要点**：  
1. **双状态并行显示**：左侧显示闪现距离（蓝色光效），右侧显示跑步距离（绿色脚印）  
2. **魔法值动态条**：顶部像素风格能量槽显示魔法值，恢复时播放"charge"音效  
3. **时间轴进度**：底部8位风格计时器，每秒触发"tick"音效  
4. **决策高亮**：当闪现距离超过跑步距离时，用金色闪光特效标记关键转折点  

# 题解评分（≥4星）  
1. **wzr1125（5星）**  
   - 亮点：双变量状态转移，代码仅15行，时间复杂度O(T)  
   - 代码片段：  
     ```cpp  
     for(int i=1;i<=t;i++){
         if(m>=10) m-=10,fla+=60;
         else m+=4;
         run = max(run+17, fla);
         if(run>=s)...
     }  
     ```  

2. **qhr2023（4星）**  
   - 亮点：极致简化版动态规划，仅用两个变量  
   - 代码片段：  
     ```cpp  
     m>=10?m-=10,s2+=60:m+=4;  
     s1=max(s1+17, s2);  
     ```  

3. **NewbieZZZ（4星）**  
   - 亮点：清晰的双状态注释，包含魔法恢复的数学分析  
   - 代码片段：  
     ```cpp  
     for(int i=1; i<=t; ++i){
         if(m >=10) dis[i] = dis[i-1]+60, m-=10;
         else m +=4;
         dis[i] = max(dis[i], dis[i-1]+17);
     }  
     ```  

# 最优思路提炼  
**贪心+状态融合策略**：  
1. **优先闪现**：魔法≥10时必用闪现（60m/s > 17m/s）  
2. **状态继承**：当闪现累计距离超过纯跑步时，跑步者"继承"闪现者的进度  
3. **临界处理**：时间或距离不足以完成完整恢复-闪现周期时切换纯跑步  

# 同类型题目推荐  
1. **P1090 合并果子**（贪心+优先队列）  
2. **P1048 采药**（时间约束下的动态规划）  
3. **P5019 铺设道路**（贪心策略与状态继承）  

# 可视化算法演示  
**Canvas动画设计**：  
```javascript  
// 伪代码示例  
class Animation {
  constructor() {
    this.flaDist = 0;    // 闪现距离（蓝色光柱）
    this.runDist = 0;    // 跑步距离（绿色方块）
    this.manaBar = new ManaBar(0,0,200,20); // 魔法值显示
  }

  step(m, s, t) {
    if(m >=10) {
      this.flaDist += 60;
      playSound('flash.wav');
      this.manaBar.decrease(10);
    } else {
      this.manaBar.increase(4);
      playSound('recharge.wav');
    }
    
    this.runDist = Math.max(this.runDist+17, this.flaDist);
    
    if(this.runDist > this.flaDist) {
      this.highlightRunner(); // 绿色高亮
    } else {
      this.highlightFlasher(); // 蓝色脉冲
    }
  }
}  
```  

**8位风格要素**：  
- 魔法槽：像素化蓝色渐变条，恢复时产生波纹特效  
- 距离显示：左侧闪现距离为闪烁的蓝色数字，右侧跑步为滚动的绿色数字  
- 音效设计：  
  - 闪现：8-bit "zap"音效  
  - 跑步：节奏性"step"音效  
  - 魔法满：触发"ready"提示音  

# 核心代码实现  
**最优解代码（wzr1125改进版）**：  
```cpp  
#include<bits/stdc++.h>
using namespace std;

int main() {
    int m, s, t, fla = 0, run = 0;
    cin >> m >> s >> t;
    for(int i=1; i<=t; ++i) {
        if(m >= 10) m -= 10, fla += 60;
        else m += 4;
        run = max(run + 17, fla);
        if(run >= s) {
            cout << "Yes\n" << i;
            return 0;
        }
    }
    cout << "No\n" << run;
    return 0;
}
```  

**关键逻辑说明**：  
- `fla`变量记录纯闪现累计距离  
- `run`变量记录综合最优距离，每次取`run+17`与`fla`的最大值  
- 时间复杂度O(T)完美处理1e5级数据量  

通过这种双状态动态规划，既保证了闪现的优先性，又能在闪现者领先时让跑步者继承最优进度，最终达到全局最优解。

---
处理用时：79.07秒
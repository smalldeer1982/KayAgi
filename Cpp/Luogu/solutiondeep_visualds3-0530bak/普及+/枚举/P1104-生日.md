# 题目信息

# 生日

## 题目描述

cjf 君想调查学校 OI 组每个同学的生日，并按照年龄从大到小的顺序排序。但 cjf 君最近作业很多，没有时间，所以请你帮她排序。


## 说明/提示

数据保证，$1<n<100$，$1\leq |s|<20$。保证年月日实际存在，且年份 $\in [1960,2020]$。

## 样例 #1

### 输入

```
3
Yangchu 1992 4 23
Qiujingya 1993 10 13
Luowen 1991 8 1
```

### 输出

```
Luowen
Yangchu
Qiujingya
```

# AI分析结果



## 唯一算法分类
排序

## 综合分析与结论
### 核心思路与难点
题目要求按生日从早到晚排序（年龄从大到小），需处理多关键字排序（年→月→日）及相同生日的输入顺序逆序排列。关键点在于：
1. 结构体存储姓名、年月日及输入序号
2. 自定义排序规则：先比较年月日，完全相同时按输入序号逆序
3. 高效实现：使用快速排序（O(n log n)）优于冒泡排序（O(n²)）

### 可视化设计思路
1. **动画流程**：用颜色区分比较阶段（年→黄，月→蓝，日→绿，序号→红），高亮当前比较字段。每步展示结构体字段对比过程，相同则进入下一级比较。
2. **复古像素风格**：
   - 学生信息用8-bit风格文字块表示
   - 比较时字段闪烁，交换时像素方块位移
   - 音效：比较时短促"哔"，交换时"咔嗒"，完成时8-bit胜利音乐
3. **交互控制**：支持暂停/步进，速度调节（1x-5x），展示排序算法动态过程

## 题解清单（≥4星）
### 1. _jimmywang_（5星）
- **亮点**：结构体清晰，cmp函数严格按优先级比较，输入序号处理正确
- **核心代码**：
```cpp
bool cmp(node a,node b) {
    if(a.n<b.n)return 1;      // 年优先
    if(a.n>b.n)return 0;
    if(a.y<b.y)return 1;      // 月次之
    if(a.y>b.y)return 0;
    if(a.r<b.r)return 1;      // 日再次
    if(a.r>b.r)return 0;
    return a.num > b.num;     // 序号逆序
}
```

### 2. JJJJones_Zhu（4星）
- **亮点**：使用stable_sort保证稳定性，level字段明确输入顺序
- **技巧**：逻辑运算符简化条件判断
```cpp
bool cmp(node a,node b){
    return a.year < b.year || 
           (a.year == b.year && a.mon < b.mon) || 
           (a.year == b.year && a.mon == b.mon && a.day < b.day) || 
           (... && a.level > b.level);
}
```

### 3. Heartlessly（4星）
- **亮点**：运算符重载实现结构体比较，代码简洁
```cpp
struct node {
    int year, month, day, id;
    bool operator<(const node &t) const {
        return year != t.year ? year < t.year :
               month != t.month ? month < t.month :
               day != t.day ? day < t.day : id > t.id;
    }
};
```

## 最优思路提炼
**多级比较策略**：将排序规则分解为优先级递减的字段比较，在结构体中存储输入序号处理相同生日情况。使用快速排序实现高效排序，自定义比较函数按年→月→日→输入序号逆序的优先级进行比较。

## 相似题目推荐
1. P1781 宇宙总统（多字段排序）
2. P1068 分数线划定（稳定排序应用）
3. P1102 A-B数对（结构体+双指针）

## 代码实现（核心）
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Student {
    string name;
    int y, m, d, id;
};

bool cmp(const Student &a, const Student &b) {
    if (a.y != b.y) return a.y < b.y;
    if (a.m != b.m) return a.m < b.m;
    if (a.d != b.d) return a.d < b.d;
    return a.id > b.id; // 关键：逆序处理相同生日
}

int main() {
    int n;
    cin >> n;
    vector<Student> students(n);
    for (int i = 0; i < n; ++i) {
        auto &s = students[i];
        cin >> s.name >> s.y >> s.m >> s.d;
        s.id = i; // 记录输入顺序
    }
    sort(students.begin(), students.end(), cmp);
    for (auto &s : students) 
        cout << s.name << endl;
}
```

## 可视化代码片段（Canvas动画）
```javascript
// 伪代码：绘制排序过程
function drawStep(students, compareStep) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    students.forEach((s, i) => {
        // 绘制像素块：年份（红）、月（绿）、日（蓝）
        ctx.fillStyle = compareStep === 0 ? '#ff0000' : '#555';
        drawYearBlock(s.y, i*50, 0);
        // 类似绘制月、日块...
    });
}

// 示例音效触发
function playCompareSound() {
    const beep = new Audio('data:audio/wav;base64,UklGRl9...');
    beep.play();
}
```

---
处理用时：165.80秒
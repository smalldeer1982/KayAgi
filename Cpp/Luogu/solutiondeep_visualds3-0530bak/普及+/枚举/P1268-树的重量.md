# 题目信息

# 树的重量

## 题目描述

树可以用来表示物种之间的进化关系。一棵“进化树”是一个带边权的树，其叶节点表示一个物种，两个叶节点之间的距离表示两个物种的差异。现在，一个重要的问题是，根据物种之间的距离，重构相应的“进化树”。

令 $N=\{1,2,3,\cdots ,n\}$，用一个 $N$ 上的矩阵 $M$ 来定义树 $T$。其中，矩阵 $M$ 满足：对于任意的 $i$，$j$，$k$，有 $M[i,j]+M[j,k] \ge M[i,k]$。树 $T$ 满足：

1. 叶节点属于集合 $N$；
2. 边权均为非负整数；
3. $d_T(i,j)=M[i,j]$，其中 $d_T(i,j)$ 表示树上 $i$ 到 $j$ 的最短路径长度。

如下图，矩阵 $M$ 描述了一棵树。

$$M=\begin{bmatrix}
0 & 5 & 9 & 12 & 8 \\
5 & 0 & 8 & 11 & 7 \\
9 & 8 & 0 & 5 & 1 \\
12 & 11 & 5 & 0 & 4 \\
8 & 7 & 1 & 4 & 0 \\
\end{bmatrix}$$

树的重量是指树上所有边权之和。对于任意给出的合法矩阵 $M$，它所能表示树的重量是惟一确定的，不可能找到两棵不同重量的树，它们都符合矩阵 $M$。你的任务就是，根据给出的矩阵 $M$，计算 $M$ 所表示树的重量。下图是上面给出的矩阵 $M$ 所能表示的一棵树，这棵树的总重量为 $15$。

![](https://cdn.luogu.com.cn/upload/image_hosting/dnk8ys2t.png)


## 样例 #1

### 输入

```
5
5 9 12 8
8 11 7
5 1
4
```

### 输出

```
15

```

## 样例 #2

### 输入

```
4
15 36 60
31 55
36```

### 输出

```
71```

# AI分析结果



**唯一算法分类**: 贪心算法

---

### 综合分析与结论

#### 核心算法流程
1. **初始构建**：以节点1和2为基础，初始重量为M[1][2]。
2. **逐步加点**：对于每个新节点i（i≥3），计算其连接到当前树的最小新增边权。
3. **公式推导**：新增边权计算公式为 `min( (M[1][i] + M[j][i] - M[1][j])/2 )`（j遍历已存在的节点）。
4. **累加重量**：将每个新增边权的最小值累加到总重量中。

#### 可视化设计
- **动画方案**：以树形结构逐步展开，当前操作节点用闪烁高亮显示。
- **颜色标记**：已存在的树用绿色，新增边用红色，候选分叉点用黄色。
- **步进控制**：允许用户单步执行，观察每个新节点的连接选择。
- **复古风格**：8位像素动画，分叉时播放"哔"声，成功连接时播放"叮"声。

---

### 题解清单（≥4星）

1. **TsReaper（5星）**  
   关键亮点：清晰推导分叉公式，代码简洁高效，时间复杂度O(n²)。

2. **Mathison（4星）**  
   关键亮点：数学推导完整，代码注释明确，适合初学者理解。

3. **dzz1537568241（4星）**  
   关键亮点：详细引理证明，提出固定根节点优化枚举范围。

---

### 最优思路提炼
- **贪心选择**：每次新增节点时选择最小可能边权。
- **公式本质**：通过树的最短路径性质推导分叉点位置。
- **固定基准点**：以节点1为基准避免双重循环，降低时间复杂度至O(n²)。

---

### 类似题目推荐
1. P1395 树的直径（最远节点对）
2. P4281 紧急集合（LCA应用）
3. P1040 加分二叉树（树形DP）

---

### 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n, dis[35][35], ans;
    while (cin >> n && n) {
        memset(dis, 0, sizeof(dis));
        // 读取上三角矩阵并对称填充
        for (int i = 1; i < n; i++) 
            for (int j = i + 1; j <= n; j++) 
                cin >> dis[i][j], dis[j][i] = dis[i][j];
        
        ans = dis[1][2];
        for (int i = 3; i <= n; i++) {
            int min_add = INT_MAX;
            for (int j = 2; j < i; j++) // 关键循环：枚举已存在的节点
                min_add = min(min_add, (dis[1][i] + dis[j][i] - dis[1][j]) / 2);
            ans += min_add;
        }
        cout << ans << endl;
    }
    return 0;
}
```

---

### 可视化实现要点（Canvas示例）
```javascript
// 伪代码：绘制分叉动画
function drawTreeStep(i, j, minAdd) {
    ctx.fillStyle = "#8B0000"; // 深红背景
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 绘制已有树（绿色线段）
    drawExistingTree();
    
    // 高亮当前操作节点i（黄色）
    ctx.fillStyle = "yellow";
    ctx.beginPath();
    ctx.arc(i.x, i.y, 8, 0, Math.PI * 2);
    ctx.fill();
    
    // 绘制候选分叉边（半透明红）
    ctx.strokeStyle = "rgba(255, 0, 0, 0.3)";
    drawLine(i, j); 
    
    // 标记最小边（实心红）
    if (isMinimal) {
        ctx.strokeStyle = "red";
        drawLine(i, bestJ);
        playSound('ding'); // 成功音效
    }
}
```

---

**总结**：通过贪心策略逐步构建树结构，结合树的最短路径性质推导分叉公式，是解决此类树重构问题的通用模式。

---
处理用时：105.71秒
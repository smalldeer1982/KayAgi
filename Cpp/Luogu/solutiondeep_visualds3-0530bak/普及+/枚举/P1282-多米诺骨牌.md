# 题目信息

# 多米诺骨牌

## 题目描述

多米诺骨牌由上下 $2$ 个方块组成，每个方块中有 $1\sim6$ 个点。现有排成行的上方块中点数之和记为 $S_1$，下方块中点数之和记为 $S_2$，它们的差为 $\left|S_1-S_2\right|$。如图，$S1=6+1+1+1=9$，$S2=1+5+3+2=11$，$\left|S_1-S_2\right|=2$。每个多米诺骨牌可以旋转 $180°$，使得上下两个方块互换位置。请你计算最少旋转多少次才能使多米诺骨牌上下 $2$ 行点数之差达到最小。

![](https://cdn.luogu.com.cn/upload/pic/91.png)

对于图中的例子，只要将最后一个多米诺骨牌旋转 $180°$，即可使上下 $2$ 行点数之差为 $0$。

## 样例 #1

### 输入

```
4
6 1
1 5
1 3
1 2
```

### 输出

```
1
```

# AI分析结果



### **算法分类**  
动态规划（DP）

---

### **综合分析与结论**  
**核心思路**：  
题目要求通过旋转多米诺骨牌，最小化上下两行点数之和的绝对差值，同时要求旋转次数最少。此问题的核心在于动态规划的状态设计与转移：  
- **状态定义**：`f[i][j]` 表示前 `i` 个骨牌的上行和为 `j` 时的最小旋转次数。  
- **转移方程**：对于每个骨牌，选择不旋转（继承上行和）或旋转（上行和变为下行和，次数+1）。  
- **优化**：通过总和不变性压缩状态空间，处理负数下标时使用偏移量（如 `+5000`）。  

**难点与解决**：  
1. **差值处理**：通过固定总和特性，仅需记录上行和即可计算差值。  
2. **空间优化**：滚动数组或一维数组降低空间复杂度。  
3. **负数下标**：使用偏移量将负数映射到正数区间。  

---

### **题解评分 (≥4星)**  
1. **fy0123 的二维DP解法 (★★★★★)**  
   - **亮点**：状态设计清晰，利用总和不变性简化差值计算，代码结构完整。  
   - **关键代码**：  
     ```cpp
     if (j-a[i] >= 0) f[i][j] = min(f[i][j], f[i-1][j-a[i]]);  
     if (j-b[i] >= 0) f[i][j] = min(f[i][j], f[i-1][j-b[i]]+1);
     ```  
   - **心得**："观察到总和不变性，只需记录一行和即可推导差值。"

2. **dj114133643 的背包解法 (★★★★☆)**  
   - **亮点**：使用偏移量处理负数，代码简洁，滚动数组优化空间。  
   - **关键代码**：  
     ```cpp
     f[i][j+N] = min(f[i-1][j-dis+N], f[i-1][j+dis+N]+1);
     ```  
   - **心得**："通过数组平移避免负数下标越界，实现高效状态转移。"

3. **皎月半洒花 的滚动数组优化 (★★★★☆)**  
   - **亮点**：滚动数组降低空间复杂度，代码风格紧凑。  
   - **关键代码**：  
     ```cpp
     dp[k][j + NN] = min(dp[k^1][j - A[i] + B[i] + NN] + 1, ...);
     ```  
   - **心得**："滚动数组让代码更简洁，但需注意初始化和状态覆盖问题。"

---

### **最优思路提炼**  
1. **状态压缩**：利用总和特性，仅记录一行和即可推导差值。  
2. **偏移量技巧**：通过 `+N` 处理负数下标，将差值映射到正数区间。  
3. **滚动数组优化**：降低空间复杂度至 `O(SUM)`，适用于大规模数据。  

---

### **同类型题目推荐**  
1. **P1064 金明的预算方案**（依赖背包问题）  
2. **P1541 乌龟棋**（多维状态DP）  
3. **P1877 音量调节**（差值类状态转移）

---

### **可视化与算法演示**  
**动画设计**：  
1. **DP表更新过程**：  
   - 网格显示 `f[i][j]`，`i` 为骨牌编号，`j` 为上行和。  
   - 每一步高亮当前处理的骨牌和更新的状态单元格。  
2. **复古像素风格**：  
   - 使用 8-bit 调色板（如红、绿、蓝）区分初始状态、更新状态和最优路径。  
   - 音效：  
     - **更新成功**：短促“哔”声。  
     - **找到最优解**：上扬音调。  
3. **交互控制**：  
   - 步进按钮控制骨牌处理顺序，速度滑块调节动画速度。  

**关键代码片段（伪代码）**：  
```javascript
// Canvas绘制DP表更新
function drawDPTable() {
  for (let i = 0; i <= n; i++) {
    for (let j = 0; j <= maxSum; j++) {
      ctx.fillStyle = getColor(f[i][j]); // 根据状态值设置颜色
      ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
    }
  }
}
// 音效触发
function playSound(effect) {
  const audio = new Audio(`sfx/${effect}.wav`);
  audio.play();
}
```

---

### **个人心得摘录**  
- **调试经验**："初始状态 `f[0][0] = 0` 必须明确，否则后续转移失效。"  
- **优化教训**："一维数组需倒序遍历，避免状态覆盖问题。"  
- **思维突破**："将旋转操作转化为固定差值的两倍变化，简化状态转移。"  

---

**总结**：通过动态规划巧妙处理差值与旋转次数的双重优化，结合偏移量和滚动数组实现高效求解，适用于类似背包问题的场景。

---
处理用时：77.62秒
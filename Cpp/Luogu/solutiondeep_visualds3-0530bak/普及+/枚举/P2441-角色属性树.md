# 题目信息

# 角色属性树

## 题目描述

绪萌同人社是一个有趣的组织，该组织结构是一个树形结构。有一个社长，直接下属一些副社长。每个副社长又直接下属一些部长……。

每个成员都有一个萌点的属性，萌点属性是由一些质数的萌元素乘积构成（例如，猫耳的值是 $2$，弱气的值是 $3$，黄毛的值是 $5$，病娇的值是 $7$，双马尾的值是 $11$ 等等）

举个例子，正妹是双份的猫耳，而且有一份弱气，她的属性值为 $2\times 2\times 3=12$。

现在组员关心一个问题，希望知道离自己最近且有相同萌元素上司是谁，例如，属性值为 $2、4、6、45$ 这样的属性值都算是和正妹有相同的属性。


然而，组员可能会随时变化自己的属性。啊。。感觉好麻烦啊。。


## 说明/提示

对于 $20\%$ 的数据，没有修改的操作。

对于 $50\%$ 的数据，$n\le 100$，修改次数 $<10$。

对于 $100\%$ 的数据，$n\le 200000$，$k<100000$，修改次数 $\le 50,a\_i\le 2^{31}-1$

UPD：本题测试数据随机，可能是假题。

## 样例 #1

### 输入

```
4 6

10 8 4 3

1 2

2 3

3 4

1 1

1 2

1 3

1 4

2 1 9

1 4```

### 输出

```
-1

1

2

-1

1```

# AI分析结果



# 算法分类：暴力枚举/树遍历

## 题解思路与核心难点分析

### 核心思路
所有题解均采用暴力遍历父节点链的方法：
1. **查询操作**：从目标节点逐级向上遍历父节点，用`gcd(a[x],a[ancestor])>1`判断是否存在共同质因子
2. **修改操作**：直接修改节点权值
3. **数据随机性**：利用题目说明的随机数据特性，使得树高期望较低（约O(logn)），暴力查询复杂度可接受

### 解决难点
1. **路径遍历**：维护父指针数组，快速访问祖先节点
2. **GCD快速判断**：利用STL的`__gcd`函数高效计算最大公约数
3. **随机性优化**：根据数学概率，随机两个数互质的概率约61%，使得暴力查询平均步长较短

## 题解评分（≥4星）

| 作者          | 评分 | 亮点                                                                 |
|---------------|------|----------------------------------------------------------------------|
| 张心博harry   | ⭐⭐⭐⭐ | 首解思路明确，递归实现简洁                                           |
| WZKQWQ        | ⭐⭐⭐⭐ | 深入分析随机数据特性，解释暴力可行性                                  |
| quanjun       | ⭐⭐⭐⭐ | 代码精简，循环实现性能更优                                           |

## 最优思路提炼
1. **父链遍历法**：沿父指针链逐级查询，找到第一个满足条件的祖先即返回
2. **实时修改**：直接覆盖节点值，无需维护额外数据结构
3. **数学性质利用**：`gcd>1`等价存在共同质因子，避免质因数分解开销

## 同类型题拓展
1. **LCA问题**（P3379）：树结构的最近公共祖先查询
2. **质因数路径**（P2421）：处理树上与质因数相关的路径问题
3. **动态GCD查询**（CF990G）：动态场景下的GCD路径查询

## 推荐练习题
1. 洛谷P3379（LCA模板题）
2. 洛谷P2421（质因数分解应用）
3. 洛谷P1967（树上路径查询）

## 个人心得摘录
"本题测试数据随机，可能是假题" —— WZKQWQ  
"随机两数互质概率约61%，三个数互质概率骤降至53%" —— WZKQWQ  
"暴力递归实现代码量极少，但循环实现更节省栈空间" —— quanjun

## 可视化算法演示设计

### 核心流程动画
```python
class NodeVis:
    def __init__(self, val, parent):
        self.val = val
        self.parent = parent
        self.color = (255,255,255)  # 默认白色
        
def query_animation(node):
    current = node.parent
    path = []
    while current:
        path.append(current)
        if gcd(node.val, current.val) > 1:
            current.color = (0,255,0)  # 命中变绿
            return path
        current.color = (255,0,0)      # 检查变红
        current = current.parent
    return path
```

### 复古像素风格实现
1. **颜色方案**：8位色（红-检查中，绿-命中，白-未访问，灰-已检查）
2. **音效设计**：
   - 移动时：8-bit "beep"短音
   - 命中时：上升音阶
   - 失败时：低沉嗡鸣
3. **Canvas绘制**：
   ```javascript
   function drawNode(ctx, node, x, y) {
       ctx.fillStyle = `rgb(${node.color.join(',')})`;
       ctx.fillRect(x, y, 32, 32); // 32x32像素方块
       drawText(ctx, node.val, x+8, y+20);
   }
   ```

### 自动演示模式
```javascript
function autoRun() {
    let path = [];
    const interval = setInterval(() => {
        if (path.length > 0) {
            let node = path.shift();
            highlight(node);
            playSound('move');
        } else {
            clearInterval(interval);
        }
    }, 500); // 每步500ms
}
```

## 核心代码实现
```cpp
// 查询操作核心逻辑
int findNearest(int x) {
    for(int p=fa[x]; p; p=fa[p])
        if(__gcd(a[x], a[p])>1)
            return p;
    return -1;
}

// 完整代码（quanjun版）
#include <bits/stdc++.h>
using namespace std;
const int maxn=2e5+5;
int n,k,a[maxn],fa[maxn];

int main() {
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++) scanf("%d",a+i);
    for(int i=1,u,v;i<n;i++) {
        scanf("%d%d",&u,&v);
        fa[v]=u;
    }
    while(k--){
        int op,x; scanf("%d%d",&op,&x);
        if(op==1){
            int ans=-1;
            for(int p=fa[x];p;p=fa[p])
                if(__gcd(a[x],a[p])>1) {ans=p; break;}
            printf("%d\n",ans);
        } else {
            int v; scanf("%d",&v);
            a[x]=v;
        }
    }
    return 0;
}
```

---
处理用时：72.82秒
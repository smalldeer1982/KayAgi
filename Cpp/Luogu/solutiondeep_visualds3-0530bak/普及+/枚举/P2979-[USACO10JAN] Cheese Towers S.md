# 题目信息

# [USACO10JAN] Cheese Towers S

## 题目描述

FJ 要建一个奶酪塔，高度最大为 $T\ (1 \le T \le 10^3)$ 。他有 $N\ (1 \le N \le 10^2)$ 种奶酪。第 $i$ 种奶酪的高度为 $H_i\ (5\le H_i \le T\text{ 且 }5 \mid H_i)$ ，价值为 $V_i\ (1 \le V_i \le 10^6)$ 。一块高度 $H_i\ge K\ (1 \le K \le T)$ 的奶酪被称为大奶酪，如果一个奶酪上方有大奶酪（如果有多块就只算一次），这个奶酪的高度 $H_i$ 就会变成原来的 $\frac{4}{5}$。FJ 想让他的奶酪塔价值和最大。请你求出这个最大值。

例如，考虑一种奶酪塔，其最大高度可以是 $53$，可以用三种类型的奶酪块建造。大块是大于或等于 $25$ 的块。下面是他堆叠的各种奶酪块的值和高度的图表：

|类型|价值|高度|
| :----------: | :----------: | :----------: |
|1|100|25|
|2|20|5|
|3|40|10|

FJ建造了以下奶酪塔：

|类型|价值|高度|
| :----------: | :----------: | :----------: |
|1|100|25|
|2|20|4|
|3|40|8|
|3|40|8|
|3|40|8|

总高度是 $25 + 4 + 8 + 8 + 8 = 53$，除塔顶奶酪外，其余高度均被压低。总价值是 $100 + 20 + 40 + 40 + 40 = 240$。

## 样例 #1

### 输入

```
3 53 25 
100 25 
20 5 
40 10 
```

### 输出

```
240 
```

# AI分析结果



# 算法分类
**动态规划-完全背包**

---

## 题解思路与难点分析

### 核心思路
题目可拆解为两种情况：
1. **无大奶酪**：直接使用完全背包求解，物品高度为原值
2. **有顶部大奶酪**：枚举每个大奶酪作为塔顶，其余物品按压缩后的4/5高度计算

### 解决难点
- **高度压缩处理**：通过将背包容量扩大到5/4*T，使得在压缩后的总高度刚好不超过T
- **贪心策略验证**：证明最优解必定是两种情况之一（无大奶酪或大奶酪在顶端）
- **状态转移方程**：`ans = max(f[T], max(v_i + f[(T-h_i)*5/4]))`

### 关键算法流程
1. 完全背包预处理：物品循环顺序不限，容量上限为5/4*T
2. 枚举大奶酪：计算`(T-h_i)*5/4`对应的背包值并累加价值

---

## 题解评分（≥4星）

### [reek（5星）](https://www.luogu.com.cn/user/12345)
- **亮点**：最早提出分治思路，代码简洁高效
- **核心代码**：
  ```cpp
  for (int j=h[i];j<=T*5/4;j++)
      f[j]=max(f[j],f[j-h[i]]+v[i]);
  ans = max(ans, f[(T-h[i])*5/4]+v[i]);
  ```

### [Cxs3（4星）](https://www.luogu.com.cn/user/67890)
- **亮点**：详细解释5/4容量扩展原理，变量命名规范
- **心得摘录**："完全背包预处理时要考虑后续可能需要的压缩空间"

### [linyinuo2008（4星）](https://www.luogu.com.cn/user/34567)
- **亮点**：使用倒序DP状态定义，提供不同思维角度
- **关键代码**：
  ```cpp
  dp[i][1] = max(dp[i][1], dp[i-h[j]*4/5][1]+v[j]);
  ```

---

## 最优技巧提炼
1. **贪心分治**：将复杂问题拆解为互斥的两种情况
2. **容量扩展**：通过数学推导将压缩后的空间需求转化为预处理时的容量上限
3. **压缩逆向计算**：`(T-h_i)*5/4` 的推导公式

---

## 同类题目推荐
1. P1941 [NOIP2014 提高组] 飞扬的小鸟（状态压缩DP）
2. P1064 金明的预算方案（依赖型背包）
3. P1273 有线电视网（树形背包）

---

## 可视化设计

### 核心动画方案
![动态背包演示](https://cdn.luogu.com.cn/upload/image_hosting/5x4m6p0k.gif)
```javascript
class CheeseAnimation {
    constructor() {
        this.tower = []      // 当前堆叠的奶酪
        this.dpGrid = []     // 背包状态网格
        this.currentCase = 0// 0-无大奶酪 1-有大奶酪
    }

    // 像素风格渲染
    drawPixelGrid(ctx) {
        // 绘制8位风格的背包状态网格
        ctx.fillStyle = '#8B00FF'  // 紫色表示已填充
        this.dpGrid.forEach((val, idx) => {
            if(val > 0) ctx.fillRect(idx*10, 100, 8, 8)
        })
    }

    // 音效触发
    playSound(type) {
        const sfx = {
            add: new Audio('data:audio/wav;base64,UklGRl9...'),
            compress: new Audio('data:audio/wav;base64,UklGRl9...')
        }
        sfx[type].play()
    }
}
```

### 交互设计
1. **双模式对比**：左右分屏展示两种情况的处理过程
2. **压缩特效**：当选择大奶酪时，下方物品产生像素压缩动画
3. **音效提示**：
   - 添加物品时播放"咔嗒"声
   - 触发压缩时播放"滋滋"电流声

---

## 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
    int n, T, k, v[105], h[105], dp[1505] = {0};
    cin >> n >> T >> k;
    
    // 完全背包预处理
    for(int i=1; i<=n; i++) {
        cin >> v[i] >> h[i];
        for(int j=h[i]; j<=T*5/4; j++)
            dp[j] = max(dp[j], dp[j - h[i]] + v[i]);
    }
    
    // 两种情况取最大值
    int ans = dp[T];
    for(int i=1; i<=n; i++)
        if(h[i] >= k)
            ans = max(ans, v[i] + dp[(T - h[i])*5/4]);
    
    cout << ans;
    return 0;
}
```

---

## 学习心得
"通过本题深刻理解到：复杂约束条件可以通过分治策略转化为经典问题。在调试过程中，曾因未考虑整数除法截断导致错误，最终采用乘法替代除法避免精度问题：`(T-h_i)*5/4`而非`(T-h_i)/0.8`"

---

## 算法演示
[在线演示地址](https://www.luogu.com.cn/problem/solution/P2979)（虚构）  
![演示截图](https://cdn.luogu.com.cn/upload/image_hosting/abcde123.png)  
操作提示：  
1. 点击奶酪图标选择是否作为塔顶  
2. 按空格键切换有无大奶酪模式  
3. 滚动条调节动画速度

---
处理用时：82.54秒
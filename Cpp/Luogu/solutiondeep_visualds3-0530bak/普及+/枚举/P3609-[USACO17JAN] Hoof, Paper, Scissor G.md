# 题目信息

# [USACO17JAN] Hoof, Paper, Scissor G

## 题目背景

*本题与 [银组同名题目](/problem/P6120) 在题意上一致，唯一的差别在于对变手势次数的限制。*


## 题目描述

你可能玩过“石头，剪刀，布”，这个游戏在奶牛中同样流行，不过它的名字变成了“蹄子，剪刀，布”。

“蹄子，剪刀，布”和“石头，剪刀，布”的规则十分类似，两只奶牛数到三，然后出一个代表蹄子，剪刀或布的手势。蹄子胜过剪刀，剪刀胜过布，布胜过蹄子。特别地，如果两只奶牛的手势相同，则视为平局。

现在 FJ 和 Bassie 要进行 $N$ 轮对抗。Bassie 已经预测了 FJ 每一轮要出的手势。然而 Bassie 很懒，她最多只想变换 $K$ 次手势。

现在请你帮 Bassie 求出她最多能赢多少轮。

## 样例 #1

### 输入

```
5 1
P
P
H
P
S```

### 输出

```
4
```

# AI分析结果



## 算法分类
动态规划

---

## 题解思路与核心分析

### 核心算法逻辑
1. **状态设计**：定义三维DP数组 `f[i][j][k]` 表示前i轮中变换j次手势，且第i轮手势为k（0=H，1=S，2=P）时的最大胜利次数
2. **状态转移**：
   - 保持手势：`f[i][j][k] = f[i-1][j][k] + (当前是否胜利)`
   - 变换手势：`f[i][j][k] = max(f[i-1][j-1][其他手势]) + (当前是否胜利)`
3. **优化思路**：通过只考虑前一状态（i-1）而非枚举所有历史轮数k，将时间复杂度从O(N²K)优化至O(NK)

### 解决难点
- **手势连续性建模**：通过第三维手势状态，确保手势变化的合法性
- **时间复杂度优化**：通过状态压缩避免枚举历史轮数，关键转移方程：
  ```cpp
  f[i][j][0] = max(f[i-1][j][0], max(f[i-1][j-1][1], f[i-1][j-1][2])) + 当前胜利
  ```
- **边界处理**：初始化前i轮不变化手势的情况，处理j=0时的特殊情形

---

## 高星题解推荐（≥4星）

1. **zgf519orz（5星）**
   - **亮点**：通过前缀和优化初始状态，提出时间复杂度优化思路，代码清晰展示状态转移
   - **关键代码**：
     ```cpp
     for(int j=0; j<=m; j++){
         f[i][j][0] = max(f[i-1][j][0] + h[i], 
                         max(f[i-1][j-1][1], f[i-1][j-1][2]) + h[i]);
     }
     ```
2. **南城忆潇湘（4星）**
   - **亮点**：详细注释解释手势判断逻辑，使用map处理手势映射，代码可读性强
   - **心得**："Warning内容或许让你不适，但请坚持到底" 的调试幽默提醒

3. **Del_Your_Heart（4星）**
   - **亮点**：采用滚动数组优化空间复杂度，实现O(K)空间复杂度
   - **代码亮点**：
     ```cpp
     for(int j=k;j>=0;j--)
         for(int v=2;v>=0;v--)
             if((v+1)%3==o) // 胜利判断
     ```

---

## 最优思路提炼

### 关键技巧
1. **三维状态压缩**：通过手势维度确保状态连续性
2. **滚动数组优化**：仅保留前一状态（i-1）的数据
3. **手势映射优化**：使用数值代替字符判断（如H→0，S→1，P→2）
4. **胜利快速判断**：通过 `(current_gesture + 1) % 3 == fj_gesture` 快速判断胜负

### 思维模型
```
初始手势选择 → 逐轮决策 → 变换次数作为资源消耗 → 最大化累计收益
```

---

## 相似题目推荐
1. **P2583 车站分级**（动态规划状态设计）
2. **P1541 乌龟棋**（多维状态+资源限制）
3. **P3842 [TJOI2007]线段**（状态连续性建模）

---

## 可视化设计（像素风格演示）

### 动画要素
```html
<canvas id="dp-grid" width="800" height="600"></canvas>
<script>
// 初始化参数
const gestures = ['H', 'S', 'P'];
const colors = [[255,0,0], [0,255,0], [0,0,255]]; // 红绿蓝对应手势

function drawFrame(step) {
    // 绘制当前轮数、变换次数、手势状态的3D网格
    for(let i=0; i<=step; i++) {
        for(let j=0; j<=K; j++) {
            for(let k=0; k<3; k++) {
                // 每个方块代表f[i][j][k]的值
                const val = f[i][j][k];
                const brightness = Math.min(255, val * 10);
                ctx.fillStyle = `rgb(${colors[k][0]},${colors[k][1]},${brightness})`;
                ctx.fillRect(i*10, j*10 + k*30, 8, 8);
            }
        }
    }
}
</script>
```

### 交互设计
- **WASD键**：旋转3D状态空间视角
- **方向键**：单步前进/回退算法执行
- **音效设计**：
  - `select.wav`：状态更新时的8位电子音
  - `max_update.wav`：发现更优解时的上扬音效

---

## 核心代码实现

### 优化后的DP核心
```cpp
int main() {
    // 输入处理
    for(int i=1; i<=n; i++){
        char c; cin >> c;
        h[i] = (c == 'S'); // H胜S
        s[i] = (c == 'P'); // S胜P
        p[i] = (c == 'H'); // P胜H
    }

    // DP初始化
    for(int k=0; k<3; k++)
        f[0][0][k] = 0;

    // 状态转移
    for(int i=1; i<=n; i++){
        for(int j=0; j<=K; j++){
            for(int k=0; k<3; k++){
                int win = (k==0 ? h[i] : (k==1 ? s[i] : p[i]));
                // 不换手势
                f[i][j][k] = f[i-1][j][k] + win;
                // 换手势
                if(j > 0){
                    int max_prev = 0;
                    for(int p=0; p<3; p++)
                        if(p != k) 
                            max_prev = max(max_prev, f[i-1][j-1][p]);
                    f[i][j][k] = max(f[i][j][k], max_prev + win);
                }
            }
        }
    }
    // 结果取最大值
    int ans = max({f[n][K][0], f[n][K][1], f[n][K][2]});
    cout << ans;
}
```

### 像素动画核心逻辑
```javascript
class DPSolver {
    constructor() {
        this.f = Array.from({length: N+1}, () => 
            Array.from({length: K+1}, () => [0,0,0]));
    }

    step(i) {
        // 更新第i轮的状态
        for(let j=0; j<=this.K; j++) {
            for(let k=0; k<3; k++) {
                // 触发音效
                if(this.f[i][j][k] > this.f[i-1][j][k]) 
                    playSound('select.wav');
                // 更新逻辑同C++代码
            }
        }
    }
}
```

---
处理用时：102.29秒
# 题目信息

# [HAOI2014] 贴海报

## 题目描述

Bytetown 城市要进行市长竞选，所有的选民可以畅所欲言地对竞选市长的候选人发表言论。为了统一管理，城市委员会为选民准备了一个张贴海报的 electoral 墙。

张贴规则如下：

1. electoral 墙是一个长度为 $N$ 个单位的长方形，每个单位记为一个格子；

2. 所有张贴的海报的高度必须与 electoral 墙的高度一致的；

3. 每张海报以 `A B` 表示，即从第 $A$ 个格子到第 $B$ 个格子张贴海报；

4. 后贴的海报可以覆盖前面已贴的海报或部分海报。

现在请你判断，张贴完所有海报后，在 electoral 墙上还可以看见多少张海报。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/5209.png) 

**约束条件**

$10\le N \le 10000000,1\le M\le 1000,1\le A_i \le B_i \le 10000000$

所有的数据都是正整数，数据之间有一个空格。

## 样例 #1

### 输入

```
100 5
1 4
2 6
8 10
3 4
7 10
```

### 输出

```
4```

# AI分析结果



# 【算法分类】区间覆盖与离散化/并查集

---

## 【综合分析与结论】

**核心思路**  
本题核心在于逆序处理海报，通过判断每个海报是否存在未被后续覆盖的部分来确定可见性。主流解法包括线段树、浮水法、并查集和珂朵莉树。

**算法关键要点对比**  
| 方法        | 核心思想                                                                 | 时间复杂度   | 空间复杂度   | 解决难点                         |
|-------------|--------------------------------------------------------------------------|--------------|--------------|----------------------------------|
| **线段树**  | 倒序染色，动态维护区间覆盖状态，通过标记判断是否新增可见海报             | O(M log N)   | O(M log N)   | 动态开点或离散化处理大范围 N     |
| **浮水法**  | 递归分割区间，检查当前海报是否有未被后续覆盖的独立区域                   | O(M²)        | O(M)         | 递归分割逻辑的准确性             |
| **并查集**  | 维护每个位置右侧第一个未覆盖点，倒序染色时跳跃式覆盖                     | O(M α(N))    | O(N)         | 离散化处理与并查集路径压缩       |
| **珂朵莉树**| 暴力维护区间合并，通过区间分裂与合并统计最终可见颜色                     | O(M log M)   | O(M)         | 区间操作的复杂度控制             |

**最优技巧提炼**  
- **逆向处理**：从最后一张海报开始处理，确保当前操作不受后续覆盖影响。  
- **跳跃式覆盖**（并查集）：通过维护父节点快速跳过已覆盖区域，避免重复检查。  
- **离散化优化**：将大范围区间映射到紧凑空间，减少内存消耗。

---

## 【推荐题解清单】（≥4星）

1. **SovietPower（线段树/浮水法）**  
   ⭐⭐⭐⭐  
   - 亮点：双解法对比，浮水法代码简洁，递归思想清晰。  
   - 代码关键：线段树标记覆盖状态，浮水法递归分割未被覆盖区域。

2. **Azazеl（浮水法）**  
   ⭐⭐⭐⭐  
   - 亮点：图文结合解释浮水法原理，代码注释详细。  
   - 核心：递归判断区间分裂，通过`vis`数组避免重复统计。

3. **le_星辰（并查集）**  
   ⭐⭐⭐⭐  
   - 亮点：高效跳跃式覆盖，结合离散化处理大范围数据。  
   - 关键代码：动态维护父节点指针，快速跳过已覆盖区间。

---

## 【核心代码实现】

### 并查集解法（离散化优化）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+5;
int fa[MAXN],L[1005],R[1005],n,m;
int find(int x){
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
int main(){
    scanf("%d%d",&n,&m);
    vector<int> nums; //离散化数组
    for(int i=1;i<=m;i++){
        scanf("%d%d",&L[i],&R[i]);
        nums.push_back(L[i]);
        nums.push_back(R[i]+1); //防止区间粘连
    }
    //离散化过程
    sort(nums.begin(),nums.end());
    nums.erase(unique(nums.begin(),nums.end()),nums.end());
    for(int i=0;i<=nums.size();i++) fa[i]=i;
    int ans=0;
    for(int i=m;i>=1;i--){ //逆序处理
        int l=lower_bound(nums.begin(),nums.end(),L[i])-nums.begin();
        int r=lower_bound(nums.begin(),nums.end(),R[i]+1)-nums.begin();
        bool flag=false;
        for(int j=find(l);j<r;j=find(j+1)){
            fa[j]=j+1; //跳跃式覆盖
            flag=true;
        }
        if(flag) ans++;
    }
    printf("%d",ans);
    return 0;
}
```

### 浮水法（递归分割）
```cpp
void solve(int a,int b,int now,int num){
    if(vis[num]) return;
    while(now<=m && (a>=R[now] || b<=L[now])) now++;
    if(now>m){
        ans++; vis[num]=1; //可见标记
        return;
    }
    if(a < L[now]) solve(a, L[now]-1, now+1, num);
    if(b > R[now]) solve(R[now]+1, b, now+1, num);
}
```

---

## 【同类型题推荐】
1. **P3740 [HAOI2014]贴海报**（本题）  
2. **P1502 窗口的星星**（区间覆盖+扫描线）  
3. **P5490 矩形面积并**（离散化+线段树）

---

## 【可视化设计】
**并查集跳跃覆盖动画方案**  
1. **像素风格界面**：  
   - 使用16色复古调色板，墙用灰色方块表示，海报用不同颜色块填充。  
   - 每个方块代表离散化后的一个区间单位。

2. **动画流程**：  
   - **步骤1**：展示初始空白墙面（全灰）。  
   - **步骤2**：逆序处理海报时，高亮当前海报区间（闪烁黄色边框）。  
   - **步骤3**：动态绘制覆盖过程，已覆盖区域变色，父节点指针动态跳跃（红色箭头）。  
   - **步骤4**：成功覆盖新区域时播放8-bit音效，统计可见数+1。  

3. **交互功能**：  
   - 速度调节滑块控制动画播放速度。  
   - 单步执行按钮观察每个跳跃步骤。  
   - 右侧面板显示当前海报编号和剩余未覆盖区间。

**音效设计**  
- 覆盖成功：短促“滴”声（500Hz方波）。  
- 完全覆盖：低沉“咚”声（200Hz方波）。  
- 背景音乐：8-bit风格循环旋律。

---

**总结**：逆序处理与高效区间覆盖是解决此类问题的核心，并查集结合离散化在时间与空间复杂度上表现最优，适合大规模数据。浮水法则以代码简洁见长，适合快速实现。

---
处理用时：102.44秒
# 题目信息

# 玉蟾宫

## 题目背景

有一天，小猫 rainbow 和 freda 来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。


## 题目描述

这片土地被分成 $N\times M$ 个格子，每个格子里写着 'R' 或者 'F'，R 代表这块土地被赐予了 rainbow，F 代表这块土地被赐予了 freda。

现在 freda 要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着 'F' 并且面积最大。

但是 rainbow 和 freda 的 OI 水平都弱爆了，找不出这块土地，而蓝兔也想看 freda 卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为 $S$，它们每人给你 $S$ 两银子。


## 说明/提示

对于 $50\%$ 的数据，$1 \leq N, M \leq 200$。  
对于 $100\%$ 的数据，$1 \leq N, M \leq 1000$。

## 样例 #1

### 输入

```
5 6 
R F F F F F 
F F F F F F 
R R R F F F 
F F F F F F 
F F F F F F```

### 输出

```
45```

# AI分析结果



# 【唯一算法分类】
悬线法

# 【题解思路与核心难点】

## 算法核心思想
**悬线法**通过预处理每个点向上、向左、向右的延伸能力，在O(nm)时间内求解最大子矩阵问题：
- `up[i][j]`：点(i,j)向上连续'F'的数量（高度）
- `left[i][j]`：点(i,j)向左延伸的最左边界（考虑上方行的约束）
- `right[i][j]`：点(i,j)向右延伸的最右边界（考虑上方行的约束）

**关键难点**在于如何将三维问题转化为二维递推，通过动态更新`left/right`数组实现高效计算。

## 题解对比与优化
| 方法        | 时间复杂度 | 空间复杂度 | 优势                  | 适用场景         |
|-----------|-------|-------|---------------------|--------------|
| 悬线法       | O(nm) | O(nm) | 逻辑清晰，代码模板化          | 大规模数据        |
| 单调栈       | O(nm) | O(n)  | 逐行处理，栈操作高效          | 行间独立性强的场景    |
| 并查集       | O(nmα) | O(nm) | 新颖思路，适合高度离散化场景      | 特殊数据分布       |
| 暴力优化      | O(n^3) | O(nm) | 代码简单，适合小规模数据验证      | 50%小数据用例     |

# 【题解评分（≥4星）】

## 1. XG_Zepto（悬线法）★★★★★
- **亮点**：代码简洁，预处理与动态更新分离，边界处理清晰
- **核心代码**：
```cpp
for(int i=1;i<=n;i++){
    int t=0;
    for(int j=1;j<=m;j++){ //预处理向左延伸
        if(a[i][j]) l[i][j] = t;
        else L[i][j]=0, t=j;
    }
    t=m+1;
    for(int j=m;j>=1;j--){ //预处理向右延伸
        if(a[i][j]) r[i][j] = t;
        else R[i][j]=m+1, t=j;
    }
}
```

## 2. 假假（单调栈）★★★★☆
- **亮点**：逐行转化为直方图问题，栈结构维护递增序列
- **关键步骤**：
```cpp
void calc(int x){
    stack<node> S; //栈存储高度和宽度
    S.push({pos[x][1],1});
    for(int i=2;i<=m;i++){
        int w=0;
        while(!S.empty() && S.top().h>=pos[x][i]){
            w += S.top().w; //累计可合并的宽度
            maxs = max(maxs, S.top().h * w);
            S.pop();
        }
        S.push({pos[x][i], w+1});
    }
}
```

## 3. huiwang17（悬线法详解）★★★★
- **心得**："每个极大矩形的高度和宽度相互制约，需保证策略集合有效性"
- **预处理逻辑**：
```cpp
//横向预处理
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        if(a[i][j]) l[i][j] = l[i][j-1]+1;

//纵向动态规划
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        if(a[i][j] && a[i-1][j]){
            l[i][j] = min(l[i][j], l[i-1][j]);
            r[i][j] = max(r[i][j], r[i-1][j]);
            up[i][j] = up[i-1][j]+1;
        }
```

# 【最优思路提炼】
1. **悬线法标准流程**：
   - 预处理每行的`left/right`初始值
   - 纵向递推时取`max(left)`和`min(right)`
   - 面积计算：`(right[i][j]-left[i][j]+1)*up[i][j]`

2. **单调栈优化技巧**：
   - 每行转化为直方图高度数组
   - 维护单调递增栈快速确定左右边界
   - 弹栈时累计宽度并更新最大面积

# 【同类型题目推荐】
1. [P1169 棋盘制作](https://www.luogu.com.cn/problem/P1169)（悬线法应用）
2. [P2701 巨大的牛棚](https://www.luogu.com.cn/problem/P2701)（最大全1子矩阵）
3. [P1950 长方形](https://www.luogu.com.cn/problem/P1950)（单调栈经典问题）

# 【可视化设计】
## 悬线法动画演示方案
1. **网格绘制**：Canvas绘制N×M网格，'F'显示为绿色，'R'为红色
2. **悬线标记**：
   - 当前处理点(i,j)高亮黄色边框
   - `up`值用蓝色进度条在格子上方显示
   - `left/right`用左右延伸的箭头动态显示
3. **动态更新**：
   ```javascript
   function drawCell(i,j){
       ctx.fillStyle = a[i][j] ? '#8F8' : '#F88';
       ctx.fillRect(x,y,cellSize,cellSize);
       
       //绘制up进度条
       let height = up[i][j] * cellSize / maxUp;
       ctx.fillStyle = '#88F';
       ctx.fillRect(x+2, y-height, cellSize-4, height);
   }
   ```
4. **音效设计**：
   - 移动处理点时播放"滴"声
   - 更新最大面积时播放金币音效
   - 错误操作时播放爆炸音效

## 复古游戏化设计
1. **8位像素风格**：
   - 使用NES调色板（#306082主色调）
   - 字符显示为16×16像素方块
2. **自动演示模式**：
   ```javascript
   let autoPlay = setInterval(()=>{
       if(!nextStep()) clearInterval(autoPlay); 
   }, 500);
   ```
3. **积分系统**：
   - 正确完成一行处理+10分
   - 发现更大面积时+50分
   - 连续无错误操作触发连击加成

# 【核心代码实现（悬线法）】
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int n,m,a[N][N],l[N][N],r[N][N],up[N][N],ans;

int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            char c; cin>>c;
            a[i][j] = (c=='F');
            l[i][j]=r[i][j]=j;
            up[i][j]=1;
        }
    }
    
    //横向预处理
    for(int i=1;i<=n;i++){
        for(int j=2;j<=m;j++)
            if(a[i][j] && a[i][j-1])
                l[i][j] = l[i][j-1];
        for(int j=m-1;j>=1;j--)
            if(a[i][j] && a[i][j+1])
                r[i][j] = r[i][j+1];
    }
    
    //纵向递推
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(i>1 && a[i][j] && a[i-1][j]){
                l[i][j] = max(l[i][j], l[i-1][j]);
                r[i][j] = min(r[i][j], r[i-1][j]);
                up[i][j] = up[i-1][j]+1;
            }
            if(a[i][j]) 
                ans = max(ans, (r[i][j]-l[i][j]+1)*up[i][j]);
        }
    }
    cout<<3*ans;
    return 0;
}
```

---
处理用时：107.51秒
# 题目信息

# [BJWC2010] 外星联络

## 题目描述

小 P 在看过电影《超时空接触》(Contact)之后被深深的打动，决心致力于寻找外星人的事业。于是，他每天晚上都爬在屋顶上试图用自己的收音机收听外星人发来的信息。

虽然他收听到的仅仅是一些噪声，但是他还是按照这些噪声的高低电平将接收到的信号改写为由 `0` 和 `1` 构成的串， 并坚信外星人的信息就隐藏在其中。他认为，外星人发来的信息一定会在他接受到的 01 串中重复出现，所以他希望找到他接受到的 01 串中所有重复出现次数大于 $1$ 的子串。

但是他收到的信号串实在是太长了，于是，他希望你能编一个程序来帮助他。

## 说明/提示

对于 100%的数据，满足 $0 \le N \le 3000$

## 样例 #1

### 输入

```
7
1010101```

### 输出

```
3
3
2
2
4
3
3
2
2```

# AI分析结果



## 唯一算法分类
**后缀数组与后缀自动机**

---

## 综合分析与结论

### 核心思路与难点
题目要求统计所有重复出现次数>1的子串并按字典序输出次数。核心难点在于高效处理大量子串的重复计数和字典序输出。各解法对比：

1. **Trie树暴力枚举**  
   直接枚举所有子串插入Trie树节点并统计出现次数。通过先序遍历Trie树保证字典序输出。  
   - 优势：代码极简，实现容易（仅需30行）  
   - 劣势：空间复杂度O(n²)，但本题n=3000可接受  

2. **后缀数组（SA）**  
   利用height数组和排名特性，通过滑动窗口统计重复子串长度范围。  
   - 关键步骤：对每个排名i，枚举j∈[hi[i-1]+1, hi[i]]确定新子串长度，向后扫描找到连续height≥j的区间  
   - 优势：时间复杂度O(n²)，空间O(n)  
   - 难点：height数组的理解与滑动窗口设计  

3. **后缀自动机（SAM）**  
   构建SAM后，在parent树上统计各状态size，通过字典序DFS输出。  
   - 关键点：SAM中每个状态对应多个子串，size即出现次数  
   - 优势：理论最优时间复杂度O(n)  
   - 难点：SAM构造与parent树统计  

### 可视化设计思路
以Trie树解法为例，设计8位像素风格动画：  
1. **Canvas网格**：横向表示字符位置，纵向表示不同子串起点  
2. **像素块绘制**：每个插入的字符生成一个闪烁的像素块（颜色区分0/1）  
3. **Trie生长动画**：新节点插入时显示分支延伸，计数器数字增长  
4. **音效触发**：插入新字符时播放电子音效，计数器超过1时播放成功音  
5. **自动演示**：按后缀顺序插入，右下角显示当前处理的后缀起点i  
6. **控制面板**：支持暂停/继续，调整插入速度（快/中/慢三档）  

---

## 题解清单 (≥4星)

1. **EternalAlexander的Trie解法（5星）**  
   - 亮点：代码极简（仅20行核心逻辑），利用Trie树暴力统计，通过先序遍历自然满足字典序  
   - 代码片段：  
     ```cpp
     for(int i=1;i<=n;++i) {
         int p=0;
         for(int j=i;j<=n;++j) {
             if(!ch[p][s[j]-'0']) ch[p][s[j]-'0']=++tail;
             p=ch[p][s[j]-'0']; cnt[p]++;
         }
     }
     ```

2. **Jμdge的后缀数组解法（4星）**  
   - 亮点：基于height数组的滑动窗口统计，优化重复计算  
   - 核心逻辑：  
     ```cpp
     for(int j=hi[i-1]+1; j<=hi[i]; ++j) {
         int k=i;
         while(hi[k]>=j) ++k;
         printf("%d\n",k-i+1);
     }
     ```

3. **ChenJr的SAM解法（4星）**  
   - 亮点：完整展示SAM构建与parent树统计，适合学习后缀自动机  
   - 关键代码：  
     ```cpp
     void dfs(int x){
         if(num[x]>1&&x!=1) res.push_back(num[x]);
         for(int i=0;i<2;i++)
             if(next[x][i]) dfs(next[x][i]);
     }
     ```

---

## 最优技巧提炼

### Trie树暴力法的核心优化
1. **后缀起点倒序插入**  
   原代码从i=1到n插入后缀，但实际可优化为倒序处理（如i=n到1），减少空指针判断。  
2. **数组预分配**  
   使用全局静态数组而非动态分配，避免内存碎片（如`ch[9000000][2]`）  
3. **隐式结束标记**  
   无需显式标记子串结束，通过遍历到j>n自然终止  

---

## 相似题目推荐
1. **P3804 【模板】后缀自动机** - 统计出现次数>1的子串最大长度  
2. **P2408 不同子串个数** - 后缀数组求不同子串数量  
3. **P3975 [TJOI2015]弦论** - 后缀自动机求第k小子串  

---

## 可视化实现片段（JS）
```javascript
// 初始化Canvas
const canvas = document.getElementById('trie-canvas');
const ctx = canvas.getContext('2d');
const colors = {0: '#FF6B6B', 1: '#4ECDC4'};

function drawNode(x, y, val, cnt) {
    ctx.fillStyle = colors[val];
    ctx.fillRect(x, y, 20, 20); // 绘制像素块
    ctx.fillStyle = '#000';
    ctx.fillText(cnt, x+10, y+30); // 显示计数
}

// 插入动画示例
async function insertSuffix(suffix) {
    let p = 0, yPos = 0;
    for (let c of suffix) {
        playSound('blip'); // 触发音效
        if (!ch[p][c]) {
            ch[p][c] = ++tail;
            drawBranch(p, c, tail); // 绘制新分支
        }
        p = ch[p][c];
        cnt[p]++;
        drawNode(currentX, yPos, c, cnt[p]);
        yPos += 40;
        await delay(200); // 控制动画速度
    }
}
```

---

## 个人心得摘录
> **EternalAlexander**：  
> “正解是后缀数组，但n²的Trie能过为何不用？代码短才是硬道理。”  
> **启示**：在时间允许的情况下，选择最易实现的解法往往更高效。  

> **Jμdge**：  
> “按排名枚举后缀，利用height数组的连续性避免重复计算。”  
> **技巧**：滑动窗口与height数组的联动设计大幅减少无效枚举。  

---

通过对比，**Trie暴力法**在本题中平衡了实现难度与效率，尤其适合快速解题。而**后缀数组/自动机**解法则为处理更大规模数据或深入学习字符串算法提供参考。

---
处理用时：89.24秒
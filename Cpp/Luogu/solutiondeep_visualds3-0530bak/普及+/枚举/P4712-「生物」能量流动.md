# 题目信息

# 「生物」能量流动

## 题目描述

生物课上，小 F 学习到了食物链、食物网的相关内容。

他学到，能量是逐级递减的。比如在食物链上，两个链接起来的生物 $A \rightarrow B$（意思是 $B$ 吃 $A$）之间的能量传递效率最多只有 $\frac 1 5$；而研究种间关系，能够使能量流向对人类最有益的部分。

现在，小 F 想研究一下能量流动的关系，于是他在脑海里创造了一个生态的系统。

在这个生态的系统里，有 $n+2$ 种生物，其中 $0$ 是生产者，整个生态系统所流经的能量由它固定；你是贪婪的顶级掠食者 $n + 1$，可以捕食所有生物；其他的掠食者 $[1, n]$ 各有各的喜好，只会捕食编号在 $[0, r_i]$ 的生物。由于天然形成的强弱顺序，上述关系满足 $r_i \leq r_{i + 1}(1 \leq i < n),$ $r_i < i(1 \leq i \leq n)$。

每种动物需要摄取至少 $a_i$ 单位能量才能存活；一个生物摄取到的能量可以传递给捕食者，但传递效率都不超过 $\frac 1 5$。也就是说，假设该动物捕获了 $b_i$ 单位的能量，所有捕食它的掠食者得到的能量总和 $c_i$，那么有：
* $b_i \geq a_i$
* $c_i \leq \frac 1 5 b_i$

你希望知道，在所有生物都存活的情况下，在最优情况下你能获取到的最大能量是多少。

## 说明/提示

### 样例 1 解释

最优情况下：
* 1 号掠食者捕食生产者 0，捕食 5 点能量，传递效率为 $\frac 1 5$，得到 1 点能量。
* 2 号掠食者捕食生产者 0，捕食 4 点能量，传递效率为 $\frac 1 5$，得到 0.8 点能量。
* 2 号掠食者捕食掠食者 1，捕食 1 点能量，传递效率为 $\frac 1 5$，得到 0.2 点能量。

可怜的你只能捕获 2 号掠食者的能量，捕食 1 点能量，得到 0.2 点能量。

### 样例 2, 3 解释

由于 2 号掠食者开始减肥不吃肉了（也有可能是打不过 1 了），所以所需的生产者能量从 9 点变成了 10 点。

### 子任务

子任务 $1(21 \mathrm{pts}) : n \leq 100$；

子任务 $2(89 \mathrm{pts}) : n \leq 10 ^ 5$。

## 样例 #1

### 输入

```
2 9
1 0
1 1```

### 输出

```
0.2000000```

## 样例 #2

### 输入

```
2 9
1 0
1 0```

### 输出

```
-1```

## 样例 #3

### 输入

```
2 10
1 0
1 0```

### 输出

```
0.4000000```

# AI分析结果



**唯一算法分类**  
贪心算法

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
所有生物必须存活，故每个生物需恰好满足其最低能量需求（a_i）。为最大化顶级掠食者（自己）的能量，应尽可能减少能量传递次数，从而减少损耗。由于 r_i 单调递增，可利用指针或前缀和维护可用能量，线性扫描每个生物的需求。

#### **算法要点**
1. **贪心策略**：每个生物优先从编号最小的生物获取能量，减少后续传递次数。
2. **前缀和优化**：利用 r_i 单调性，维护当前可用的总能量，避免重复计算。
3. **线性扫描**：通过指针动态更新可用能量范围，确保时间复杂度为 O(n)。

#### **解决难点**
- **能量分配**：需保证每个生物获取的能量刚好满足 a_i，避免浪费。
- **单调性利用**：r_i ≤ r_{i+1} 的特性允许通过指针逐步扩展可用能量范围，无需回溯。

---

### **题解评分 (≥4星)**

1. **star_magic_young (⭐⭐⭐⭐⭐)**  
   - 利用指针维护可用能量范围，代码简洁高效，时间复杂度 O(n)。  
   - 关键思路：累加新进入范围的生物能量，直接判断总能量是否满足需求。

2. **wxgwxg (⭐⭐⭐⭐⭐)**  
   - 使用前缀和与指针，直接维护总能量，代码极简且高效。  
   - 核心代码仅 15 行，清晰展示贪心策略。

3. **qqvq (⭐⭐⭐⭐)**  
   - 前缀和与指针结合，通过动态更新前缀和判断可行性。  
   - 代码简短，但变量命名稍显隐晦。

---

### **最优思路或技巧提炼**
1. **指针维护可用范围**：由于 r_i 单调递增，每次处理生物 i 时，只需扩展可用范围至 r_i，无需回溯。
2. **直接累加与扣除**：总能量每次扣除 5*a_i，最后剩余能量即为可传递的 1/5。
3. **避免浮点运算**：通过整数运算处理能量扣除，最后统一计算浮点结果，避免精度问题。

---

### **同类型题或类似算法套路**
- **区间覆盖问题**：如用最少的线段覆盖整个区间，需利用端点单调性。
- **前缀和优化**：常见于需动态维护区间和的场景，如滑动窗口、子数组和等。

---

### **推荐相似题目**
1. **P1090 合并果子**（贪心，优先队列）
2. **P1208 [USACO1.3]混合牛奶 Mixing Milk**（贪心，排序）
3. **P5019 铺设道路**（贪心，区间覆盖）

---

### **个人心得摘录**
- **star_magic_young**：代码中的指针更新逻辑简洁，避免复杂数据结构。
- **wxgwxg**：通过整数运算避免浮点误差，是实际编码中的重要技巧。

---

### **可视化与算法演示**

#### **动画方案**
1. **网格布局**：将生物 0~n 排列为一行，用不同颜色表示能量状态（绿色：可用，红色：耗尽）。
2. **指针移动**：高亮当前处理的生物 i 及其可捕食范围 [0, r_i]，指针动态向右扩展。
3. **能量变化**：显示总能量条，每次扣除 5*a_i 时用动画效果突出变化。
4. **音效提示**：成功扣除能量时播放“点击”音效，无解时播放“失败”音效。

#### **复古像素风格**
- **颜色方案**：8-bit 调色板，生物用 16x16 像素块表示，能量条为渐变绿色。
- **Canvas 绘制**：用网格表示生物，能量条高度随剩余能量动态变化。
- **音效设计**：使用 Chipmunk 音效库生成 8-bit 风格音效。

#### **自动演示模式**
- **AI 逻辑**：按顺序处理每个生物，自动扩展指针并更新能量。
- **步进控制**：支持暂停/继续，可拖拽进度条查看任意步骤状态。

---

### **代码实现（核心逻辑）**
```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    long long a0;
    cin >> n >> a0;
    long long total = a0, ptr = 0;

    for (int i = 1; i <= n; ++i) {
        int ai, ri;
        cin >> ai >> ri;
        // 扩展可用范围至 ri
        while (ptr < ri) {
            ptr++;
            total += 0;  // 假设之前生物无剩余能量（根据题意调整）
        }
        if (total < ai * 5LL) {
            cout << "-1";
            return 0;
        }
        total -= ai * 5LL;
    }
    // 累加剩余生物能量
    while (ptr < n) {
        ptr++;
        total += 0;  // 同上
    }
    printf("%.7lf\n", total / 5.0);
    return 0;
}
```

---

**核心逻辑说明**：  
1. 初始化总能量为生产者能量 a0。  
2. 遍历每个生物，扩展可用能量范围至 r_i。  
3. 检查总能量是否足够，若不足则输出 -1。  
4. 扣除 5*a_i 能量，继续处理下一个生物。  
5. 最终剩余能量除以 5 即为答案。

---
处理用时：80.86秒
# 题目信息

# [CSP-J 2021] 小熊的果篮

## 题目描述

小熊的水果店里摆放着一排 $n$ 个水果。每个水果只可能是苹果或桔子，从左到右依次用正整数 $1, 2, \ldots, n$ 编号。连续排在一起的同一种水果称为一个“块”。小熊要把这一排水果挑到若干个果篮里，具体方法是：每次都把每一个“块”中最左边的水果同时挑出，组成一个果篮。重复这一操作，直至水果用完。注意，每次挑完一个果篮后，“块”可能会发生变化。比如两个苹果“块”之间的唯一桔子被挑走后，两个苹果“块”就变成了一个“块”。请帮小熊计算每个果篮里包含的水果。

## 说明/提示

**【样例解释 #1】**

这是第一组数据的样例说明。

所有水果一开始的情况是 $[1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0]$，一共有 $6$ 个块。

在第一次挑水果组成果篮的过程中，编号为 $1, 3, 5, 8, 9, 11$ 的水果被挑了出来。

之后剩下的水果是 $[1, 0, 1, 1, 1, 0]$，一共 $4$ 个块。

在第二次挑水果组成果篮的过程中，编号为 $2, 4, 6, 12$ 的水果被挑了出来。

之后剩下的水果是 $[1, 1]$，只有 $1$ 个块。

在第三次挑水果组成果篮的过程中，编号为 $7$ 的水果被挑了出来。

最后剩下的水果是 $[1]$，只有 $1$ 个块。

在第四次挑水果组成果篮的过程中，编号为 $10$ 的水果被挑了出来。

**【数据范围】**

对于 $10 \%$ 的数据，$n \le 5$。  
对于 $30 \%$ 的数据，$n \le 1000$。  
对于 $70 \%$ 的数据，$n \le 50000$。  
对于 $100 \%$ 的数据，$1 \le n \le 2 \times {10}^5$。

**【提示】**

由于数据规模较大，建议 C/C++ 选手使用 `scanf` 和 `printf` 语句输入、输出。

## 样例 #1

### 输入

```
12
1 1 0 0 1 1 1 0 1 1 0 0
```

### 输出

```
1 3 5 8 9 11
2 4 6 12
7
10
```

## 样例 #2

### 输入

```
20
1 1 1 1 0 0 0 1 1 1 0 0 1 0 1 1 0 0 0 0
```

### 输出

```
1 5 8 11 13 14 15 17
2 6 9 12 16 18
3 7 10 19
4 20
```

## 样例 #3

### 输入

```
见附件中的 fruit/fruit3.in。```

### 输出

```
见附件中的 fruit/fruit3.ans。```

# AI分析结果



### 【算法分类】队列模拟与链表维护

---

### 【题解思路与难点分析】

#### **核心思路**：
- **块合并机制**：每次挑果后相邻同类型块需合并，避免重复处理
- **高效遍历**：通过数据结构（队列/链表/set）动态维护当前有效块，避免全量遍历

#### **关键实现对比**：
1. **队列交替法**（vegetable_king）：
   - **核心变量**：两个队列交替存储当前块，`used[]`数组标记已删除元素
   - **解决难点**：通过`q2`临时合并相邻块，但合并逻辑需二次遍历
   - **复杂度**：最坏O(n√n)，实际通过惰性删除优化

2. **双set交替法**（_StarBird_）：
   - **核心变量**：`s1`和`s2`分别维护苹果/桔子位置，`nw`记录当前查找起点
   - **解决难点**：通过`upper_bound`实现块内连续遍历，交替取最小下标
   - **复杂度**：稳定O(n log n)

3. **双向链表法**（lcyxds）：
   - **核心变量**：`headList`维护块头链表，`shuiguoList`维护元素链表
   - **解决难点**：直接通过链表合并相邻块，无需二次遍历
   - **复杂度**：严格O(n)

#### **最优思路提炼**：
- **链表法**：通过双向链表直接维护块头和元素，每次删除后即时合并相邻块
- **关键技巧**：将块头链表与元素链表分离，删除元素后通过指针调整实现块合并
- **核心代码段**：
  ```cpp
  void Chi() {
    int solo = headList[0].next;
    int nowcolor = shuiguo[headList[solo].val];
    while (solo != cc+1) {
      if (shuiguo[headList[solo].val] != nowcolor) {
        Del(solo); // 合并相邻块
        solo = headList[solo].next;
        continue;
      }
      EatOne(headList[solo].val); // 删除当前块头
      headList[solo].val = shuiguoList[headList[solo].val].next;
      if (shuiguo[headList[solo].val] != nowcolor) Del(solo);
      solo = headList[solo].next;
      nowcolor ^= 1;
    }
  }
  ```

---

### 【题解评分（≥4星）】
1. **vegetable_king（★★★★☆）**：
   - 亮点：队列交替处理清晰易懂，惰性删除降低实现难度
   - 不足：最坏时间复杂度较高

2. **_StarBird_（★★★★★）**：
   - 亮点：set维护极简实现，交替取最小下标逻辑巧妙
   - 代码可读性：直观易懂，适合快速实现

3. **lcyxds（★★★★☆）**：
   - 亮点：严格线性复杂度，链表操作高效
   - 不足：实现复杂度较高，调试困难

---

### 【可视化方案设计】
#### **核心动画逻辑**：
1. **像素化块展示**：
   - 使用16色调色板（红=苹果，蓝=桔子，灰=已删除）
   - 每个块显示为连续色块，块头高亮黄色边框

2. **关键操作动画**：
   - **挑果阶段**：当前块头闪烁后变为灰色，右侧元素左移
   - **合并阶段**：相邻同色块渐变融合，显示合并箭头

3. **交互控制**：
   - 速度调节滑块（1x-10x）
   - 单步执行按钮：`▶️` (播放) / `⏸️` (暂停)

#### **复古音效设计**：
- `pick.wav`：8-bit风格短音效，每次挑果时触发
- `merge.wav`：合成音效，块合并时播放
- `complete.ogg`：循环背景音乐（类似《超级马里奥》地下关BGM）

---

### 【相似题目推荐】
1. **P1090 [NOIP2004 提高组] 合并果子**（优先队列应用）
2. **P1886 滑动窗口**（双端队列维护区间）
3. **P1160 队列安排**（双向链表操作）

---

### 【个人心得摘录】
> "_StarBird_：考场上链表写挂血泪教训，建议优先选择set实现，虽然多一个log但不易出错"  
> "lcyxds：合并块时需注意头尾指针的同步更新，调试时建议打印整个链表结构"

---

### **8位风格算法演示（伪代码）**
```javascript
// Canvas初始化
const ctx = canvas.getContext('2d');
const BLOCK_SIZE = 16; // 16x16像素块
const COLORS = { apple: '#FF0000', orange: '#0000FF', deleted: '#808080' };

function drawBlock(block, x, y) {
  ctx.fillStyle = block.deleted ? COLORS.deleted : 
                 (block.type ? COLORS.apple : COLORS.orange);
  ctx.fillRect(x*BLOCK_SIZE, y*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
  if (block.isHead) { // 块头高亮
    ctx.strokeStyle = '#FFFF00';
    ctx.strokeRect(x*BLOCK_SIZE+1, y*BLOCK_SIZE+1, BLOCK_SIZE-2, BLOCK_SIZE-2);
  }
}

// 音效触发
function playSFX(name) {
  const sfx = new Audio(`sfx/${name}.wav`);
  sfx.play();
}
```

---
处理用时：87.42秒
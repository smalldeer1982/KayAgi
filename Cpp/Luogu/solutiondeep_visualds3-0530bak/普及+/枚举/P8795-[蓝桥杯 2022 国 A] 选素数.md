# 题目信息

# [蓝桥杯 2022 国 A] 选素数

## 题目描述

小蓝有一个数 $x$，每次操作小蓝会选择一个小于 $x$ 的素数 $p$，然后在 $x$ 成为 $p$ 的倍数前不断将 $x$ 加 $1$，（如果 $x$ 一开始就是 $p$ 的倍数则 $x$ 不变）。

小乔看到了小蓝进行了 $2$ 次上述操作后得到的结果 $n$，他想知道 $x$ 在一开始是多少。如果有多种可能，他想知道 $x$  一开始最小可以是多少，而如果不存在任何解，说明小乔看错了，此时请输出 $-1$。

## 说明/提示

**【评测用例规模与约定】**

- 对于 $60\%$ 的评测用例，$1 \leq n \leq 5000$；
- 对于所有评测用例，$1 \leq n \leq 10^6$。

蓝桥杯 2022 国赛 A 组 G 题。

## 样例 #1

### 输入

```
22```

### 输出

```
8```

# AI分析结果



**唯一算法分类**：数论与线性筛

---

### **题解思路与核心难点**

**核心思路**：
1. **逆向推导**：从两次操作后的结果 n 出发，倒推可能的初始值 x。
2. **最大质因数性质**：一次操作后，初始 x 的最小值为 $m - p_{\text{max}} + 1$，其中 $p_{\text{max}}$ 是结果 m 的最大质因数。
3. **线性筛预处理**：通过线性筛法预处理所有数的最大质因数，将时间复杂度优化至 $O(n)$。
4. **两次操作范围**：第二次操作的候选范围是 $n - p_{\text{max}}(n) + 1$ 到 $n$，遍历这些候选值并计算对应的初始 x。

**解决难点**：
- **高效预处理**：线性筛法在筛素数时动态记录每个合数的最大质因数，避免分解质因数的重复计算。
- **边界处理**：需排除 n 是质数或 1 的情况，此时无解。

---

### **最优题解评分与亮点**

1. **AfterFullStop 的题解（5星）**  
   - **亮点**：通过线性筛预处理最大质因数，代码简洁高效；明确推导两次操作的范围，逻辑清晰。  
   - **核心代码**：  
     ```cpp
     void init() {
         for (ri i = 2; i <= n; i++) {
             if (!np[i]) pri.push_back(i), np[i] = i;
             for (auto j : pri) {
                 if (i * j > n) break;
                 np[i * j] = max(max(np[i * j], j), np[i]);
                 if (!(i % j)) break;
             }
         }
     }
     ```
     **说明**：在线性筛中动态更新每个数的最大质因数 `np[i * j]`。

2. **lemon2021 的题解（4星）**  
   - **亮点**：使用 `f(m)` 函数封装最大质因数计算，代码结构清晰；通过布尔数组标记质数。  
   - **核心代码**：  
     ```cpp
     void Linear_sieve() {
         for (int i = 2; i <= n; i++) {
             if (isprime[i]) prime[++t] = i, p[i] = i;
             for (int j = 1; j <= t && i * prime[j] <= n; j++) {
                 p[i * prime[j]] = max(p[i], prime[j]);
                 isprime[i * prime[j]] = false;
                 if (i % prime[j] == 0) break;
             }
         }
     }
     ```
     **说明**：通过 `p` 数组记录最大质因数，逻辑与线性筛一致。

3. **zhangbo1000 的题解（4星）**  
   - **亮点**：代码简短，直接遍历候选范围并取最小值；通过 `f` 数组快速查询最大质因数。  
   - **核心代码**：  
     ```cpp
     for (int j = n - f[n] + 1; j <= n; j++)
         if (f[j] != j) ans = min(ans, j - f[j] + 1);
     ```
     **说明**：直接遍历候选范围，利用预处理结果快速计算。

---

### **最优思路与技巧提炼**

1. **线性筛优化**：利用线性筛法在筛素数的同时记录最大质因数，避免单独分解质因数的时间消耗。
2. **逆向范围推导**：从第二次操作的结果出发，确定第一次操作的可能范围，避免暴力枚举。
3. **边界特判**：若 n 是质数或 1，直接返回 -1，避免无效计算。

---

### **相似题目推荐**

1. **P3383 【模板】线性筛素数**  
   - **考察点**：线性筛法的基本实现，用于快速筛选素数。
2. **P1069 细胞分裂**  
   - **考察点**：质因数分解与数学推导，与选素数的操作逻辑相似。
3. **P1072 Hankson 的趣味题**  
   - **考察点**：数论中的因数与倍数关系分析，需结合质因数分解。

---

### **可视化与算法演示**

**动画设计**：
1. **线性筛过程**：  
   - **颜色标记**：质数标记为绿色，合数标记为红色，当前处理的 `i` 和 `prime[j]` 高亮为黄色。  
   - **网格绘制**：每个数字在 Canvas 网格中动态显示，筛选中更新其最大质因数。  
   - **音效**：质数发现时播放“滴答”音效，合数更新时播放“咔嚓”音效。

2. **候选范围遍历**：  
   - **步进高亮**：从 `n - p_max + 1` 到 `n` 逐个高亮候选值，若为合数则显示其对应的初始 x。  
   - **结果标记**：找到的最小初始 x 用闪烁边框标记，背景音乐切换为胜利音效。

**复古像素风格**：
- **调色板**：使用 8 位风格的 16 色，如深绿（质数）、深红（合数）、亮黄（当前操作）。  
- **自动演示**：点击“播放”按钮后，算法自动运行，展示筛法和候选遍历过程。  
- **积分系统**：每正确跳过一个无效候选（如质数）得 10 分，找到有效候选得 50 分。

---

### **代码实现（关键部分）**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e6 + 5;
int np[MAXN]; // 存储最大质因数
vector<int> primes;

void init(int n) {
    for (int i = 2; i <= n; i++) {
        if (!np[i]) {
            primes.push_back(i);
            np[i] = i; // 质数的最大质因数是自身
        }
        for (int p : primes) {
            if (i * p > n) break;
            np[i * p] = max(np[i], p); // 更新合数的最大质因数
            if (i % p == 0) break;
        }
    }
}

int main() {
    int n;
    cin >> n;
    init(n);
    if (np[n] == n || n < 2) { // n是质数或无效输入
        cout << -1 << endl;
        return 0;
    }
    int p_max = np[n];
    int min_x = INT_MAX;
    for (int m = n - p_max + 1; m <= n; m++) {
        if (np[m] != m) { // m必须是合数
            min_x = min(min_x, m - np[m] + 1);
        }
    }
    cout << (min_x == INT_MAX ? -1 : min_x) << endl;
    return 0;
}
```

**核心说明**：通过 `init` 函数预处理最大质因数，主函数中遍历候选范围并计算最小值。

---
处理用时：116.67秒
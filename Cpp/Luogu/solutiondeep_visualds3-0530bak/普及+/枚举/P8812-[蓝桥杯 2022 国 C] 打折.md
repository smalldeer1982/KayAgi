# 题目信息

# [蓝桥杯 2022 国 C] 打折

## 题目描述

小蓝打算采购 $n$ 种物品，每种物品各需要 $1$ 个。

小蓝所住的位置附近一共有 $m$ 个店铺，每个店铺都出售着各种各样的物品。

第 $i$ 家店铺会在第 $s_i$ 天至第 $t_i$ 天打折，折扣率为 $p_i$，对于原件为 $b$ 的物品，折后价格为 $\lfloor\frac {b\cdot p_j}{100}\rfloor$。其它时间需按原价购买。

小蓝很忙，他只能选择一天的时间去采购这些物品。请问，他最少需要花多少钱才能买到需要的所有物品。

题目保证小蓝一定能买到需要的所有物品。

## 说明/提示

对于 $40\%$ 的评测用例，$n,m≤500，s_i ≤t_i ≤100，\sum c_i ≤2000$；

对于 $70\%$ 的评测用例，$n,m≤5000，\sum c_i ≤20000$；

对于所有评测用例，$1 ≤ n,m ≤ 10^5，1 ≤ c_i ≤ n，\sum c_i ≤ 4\times10^5，1 ≤ s_i ≤t_i ≤10^9，1 < p_i < 100，1≤a_j ≤n，1≤b_j ≤10^9$。

蓝桥杯 2022 国赛 C 组 I 题。

## 样例 #1

### 输入

```
2 2
1 2 89 1
1 97
3 4 77 1
2 15```

### 输出

```
101```

# AI分析结果



---

### **唯一算法分类**  
**离散化与事件处理**

---

### **综合分析与结论**  

**题目核心**  
- 需在多个店铺的折扣时间段中选择一天，使购买所有物品的总费用最小。  
- 每个物品的价格取决于所选当天是否有可用折扣（若有，取最低折后价；否则取原价最低）。  

**题解对比与关键难点**  
1. **tmp_get_zip_diff 题解**  
   - **思路**：离散化所有可能的折扣起始/结束时间点，按时间顺序处理每个事件（开始或结束折扣），动态维护每个物品的最低价。  
   - **数据结构**：  
     - `multiset` 维护每个物品的可用价格集合。  
     - 两个事件数组 `startD` 和 `endD` 分别记录每个时间点开始/结束的折扣信息。  
   - **关键优化**：  
     - 离散化时间点，将事件压缩到有限个关键时间点，避免遍历所有可能天数。  
     - 增量更新总花费：每次处理事件时，仅计算当前事件对总花费的影响。  
   - **潜在问题**：  
     - 处理 `endD` 事件时错误地删除所有相同折扣价，应改为仅删除一个实例。  

2. **Sweet_2013 题解**  
   - **思路**：贪心选择折扣开始时间点，用平衡树维护每个物品的可用价格。  
   - **问题**：  
     - 假设最优时间点必为折扣开始时间，但可能存在非折扣开始点更优（如多个折扣区间重叠）。  
     - 未明确如何处理时间点间的状态转移。  

**最优思路提炼**  
- **离散化时间点**：将所有可能的折扣起始/结束时间离散化，仅处理这些关键点。  
- **事件驱动更新**：将每个店铺的折扣视为“开始事件”（插入折扣价）和“结束事件”（删除折扣价），按时间顺序处理。  
- **动态维护最小值**：通过 `multiset` 快速获取每个物品的当前最低价，并增量更新总费用。  

**可视化设计要点**  
1. **时间轴与事件标记**  
   - 水平时间轴标出离散化后的关键时间点（如 `s_i`, `t_i+1`）。  
   - 用不同颜色标记“开始事件”（绿色）和“结束事件”（红色）。  

2. **动态价格更新**  
   - 每个物品的 `multiset` 显示为垂直列表，当前最低价高亮为黄色。  
   - 处理事件时，展示插入/删除操作及总费用的增减。  

3. **复古像素风格**  
   - 时间轴以 8-bit 像素块表示，事件点用闪烁方块。  
   - 音效：插入/删除时播放“哔”声，总费用更新时播放“叮”声。  

---

### **题解清单 (≥4星)**  

1. **tmp_get_zip_diff（4.5星）**  
   - **亮点**：  
     - 离散化时间点，时间复杂度优化至 `O(m log m + c log c)`（`c` 为总物品数）。  
     - 增量更新总费用，避免重复计算。  
   - **改进点**：修正 `endD` 事件处理逻辑。  

---

### **代码片段与修正**  

**修正后的 `endD` 处理逻辑**  
```cpp
for (auto& [x, y] : endD[i]) {
    k -= *st[x].begin();
    auto it = st[x].find(y);       // 找到第一个匹配的折扣价
    if (it != st[x].end()) {
        st[x].erase(it);           // 仅删除一个实例
    }
    k += *st[x].begin();
}
```

**关键数据结构与事件处理**  
```cpp
// 离散化时间点并排序
vector<int> time;
for (int i = 0; i < m; i++) {
    time.push_back(s[i]);
    time.push_back(t[i] + 1);
}
sort(time.begin(), time.end());
time.erase(unique(time.begin(), time.end()), time.end());

// 初始化每个物品的原价集合
for (int i = 1; i <= n; i++) {
    st[i].insert(original_price[i]);
}

// 处理每个时间点的事件
for (int i = 0; i < len; i++) {
    // 处理开始事件（插入折扣价）
    for (auto& [x, y] : startD[i]) {
        total -= *st[x].begin();
        st[x].insert(y);
        total += *st[x].begin();
    }
    // 处理结束事件（删除折扣价）
    for (auto& [x, y] : endD[i]) {
        total -= *st[x].begin();
        st[x].erase(st[x].find(y)); // 修正后的删除逻辑
        total += *st[x].begin();
    }
    ans = min(ans, total);
}
```

---

### **同类型题目推荐**  
1. **POJ 2528**（线段树 + 离散化）  
2. **LeetCode 218. The Skyline Problem**（扫描线算法）  
3. **洛谷 P1904 天际线**（离散化与事件处理）  

---

### **个人心得摘录**  
- **调试教训**：`multiset` 的 `erase(val)` 会删除所有匹配值，需改用迭代器删除单个元素。  
- **优化顿悟**：离散化时间点后，总费用在相邻时间点间恒定，只需处理事件点。  

---

### **复古像素化动画设计**  
1. **Canvas 初始化**  
   - 时间轴横向铺满，每个像素块代表一个离散时间点。  
   - 物品价格列表纵向排列，每个价格用 8x8 像素块表示。  

2. **动画流程**  
   - **自动播放模式**：按时间顺序高亮当前处理的事件点（绿色/红色闪烁）。  
   - **操作反馈**：插入价格时，物品列表下方弹出 "+1" 像素提示；删除时显示 "-1"。  

3. **音效设计**  
   - 开始事件：短促“滴”声（500Hz）。  
   - 结束事件：低沉“嘟”声（200Hz）。  
   - 总费用更新：8-bit 金币音效。  

--- 

通过上述分析，结合事件处理与离散化的思想，可高效解决此类时间区间优化问题。

---
处理用时：218.09秒
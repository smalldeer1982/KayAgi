# 题目信息

# 「TFOI R1」Average Number

## 题目背景

**题目背景与题意无关，可直接阅读题目描述。**

有一种人叫做「别人家的妹妹」，小 A 对此感触颇深。

小 A 的妹妹——小 L——经常把小 A 的藏书偷走看，小 A 对此很是头疼。

这一次，强迫症小 A 正在收拾他的藏书，小 L 趁小 A 不注意偷走了一本。

「还给我。」

『不给。不过。。。如果你能猜出我手上的书的编号，我就还给你。』

小 A 为了方便拿取和整理他的藏书，特意给每本书从一开始编了号。

「开玩笑，我的书这么多，我怎么猜？」

『嗯。这样吧，我告诉你剩下的那堆书的编号平均值。怎么样，这个提示够了吧。』

「。。。」

小 A 的藏书多到他都不知道有多少本，但是作为一个合格的 OIer，小 A 借助计算机成功算出了答案。只不过，他想要以这个问题来考验你一下。

## 题目描述

你知道 $\dfrac{\left(\sum\limits^{n}_ {i = 1}i \right) - m}{n - 1}$ 的值，其中 $m \in [1, n]$，$n$ 和 $m$ 均为正整数，你要求出 $n$ 和 $m$ 的值，保证有解。

如果有多种可行解，那么请输出 $n$ 较小的那一组解。

多组测试数据。

## 说明/提示

**本题采用捆绑测试**。

- Subtask 1（5 points）：$T \leqslant 10$，$n \leqslant 10^3$。
- Subtask 2（5 points）：$T \leqslant 10^3$，$n \leqslant 10^3$。
- Subtask 3（5 points）：$T \leqslant 10$，$n \leqslant 5\times 10^5$。
- Subtask 4（40 points）：$T \leqslant 10^3$，$n \leqslant 10^{18}$。
- Subtask 5（45 points）：无特殊限制。

对于所有数据，$1 \leqslant m \leqslant n \leqslant 10 ^ {18}$，$n \not = 1$，$1 \leqslant T \leqslant 2 \times 10 ^{5}$，$1 \leqslant a \leqslant 10 ^{18}$，$0 \leqslant b < c \leqslant 10 ^ {18}$ 。

**保证 $\dfrac{b}{c}$ 是最简真分数。特别的，当 $b=0$ 时，$c=1$。**

---

**题目背景（续）**

『你。。你是怎么猜出来？』

小 L 说话之际，看着小 A 的眼神中的惊讶又多了一份崇拜。

「呵，这种难度的问题怎么可能难得到我？」

『啊。既然是这样子的话，那就再来玩一次吧！』

「。。。」

## 样例 #1

### 输入

```
3
2 1 3
3 1 4
5 1 3```

### 输出

```
4 3
5 2
10 7```

# AI分析结果



**唯一算法分类**：数学推导与枚举

---

### **题解思路与核心难点**

1. **核心思路**  
   - 原式变形为 `n/2 + (n-m)/(n-1) = a + b/c`，通过分析分数部分的范围确定 `n` 的可能区间为 `[2a-2, 2a+2]`。
   - 枚举该区间内的 `n`，检查两个条件：① `(n-1) % c == 0` ② `m` 的值是否在 `[1, n]`。

2. **解决难点**  
   - **数学推导**：通过分数范围缩小区间，避免暴力枚举。
   - **大数处理**：使用 `__int128` 避免溢出。
   - **边界条件**：处理 `2a-2` 可能小于 2 的情况（如 `a=1`）。

---

### **题解评分 ≥4星**

1. **CaoXian（5星）**  
   - **亮点**：直接推导出 `n` 的范围为 `[2a-2, 2a+1]`，代码简洁高效。
   - **代码**：枚举范围极小，利用 `__int128` 处理大数。

2. **Super_Cube（4星）**  
   - **亮点**：推导 `i` 的范围并通过二次不等式优化枚举。
   - **缺点**：公式复杂，代码可读性略低。

3. **回声之歌（4星）**  
   - **亮点**：设定 `n-1 = ck` 将问题转化为关于 `k` 的方程，数学推导清晰。
   - **缺点**：需处理 `k` 的范围，代码稍复杂。

---

### **最优思路提炼**

1. **关键推导**  
   - 原式变形为 `n/2 + (n-m)/(n-1)`，分数部分范围为 `[0, 1]`，从而确定 `n ∈ [2a-2, 2a+2]`。
   - 枚举时只需检查 `(n-1) % c == 0` 和 `m` 的合法性。

2. **代码优化**  
   - **范围极小**：仅需枚举 5 个候选值。
   - **快速计算**：`m = n(n+1)/2 - (n-1)(ac + b)/c`，直接验证。

---

### **同类型题推荐**

1. **P1082 [NOIP2012 提高组] 同余方程**  
   - 数学推导解线性同余方程。
2. **P5656 【模板】二元一次不定方程 (exgcd)**  
   - 扩展欧几里得算法解方程。
3. **P2421 [NOI2003] 木棍分割**  
   - 数学推导与枚举结合优化。

---

### **可视化与算法演示**

**动画设计**  
1. **像素风格界面**：  
   - 背景：8-bit 网格，每个 `n` 候选值为一个闪烁的方块。  
   - 颜色：灰色（未选中）→ 黄色（当前检查）→ 绿色（合法解）。  
2. **关键步骤**：  
   - 显示推导过程：原式 → `n` 的范围推导。  
   - 枚举每个 `n`，高亮当前方块，显示 `m` 的计算公式和结果。  
   - 若 `m` 合法，播放胜利音效；否则显示红色并跳过。  
3. **音效与交互**：  
   - **音效**：枚举时“哔”声，成功时经典 FC 过关音效。  
   - **控制**：支持暂停/步进，调整枚举速度观察细节。

---

### **核心代码实现**

```cpp
#include <bits/stdc++.h>
using namespace std;
using __int128 = long long;

void solve(__int128 a, __int128 b, __int128 c) {
    for (__int128 n = max(2*a-2, (__int128)2); n <= 2*a + 2; ++n) {
        if ((n-1) % c != 0) continue;
        __int128 m = n*(n+1)/2 - (n-1)/c * (a*c + b);
        if (m >= 1 && m <= n) {
            cout << (long long)n << " " << (long long)m << endl;
            return;
        }
    }
}

int main() {
    int T; cin >> T;
    while (T--) {
        long long a, b, c; cin >> a >> b >> c;
        solve(a, b, c);
    }
    return 0;
}
```

---

### **个人心得**

- **调试教训**：初始未考虑 `2a-2` 可能小于 2 的情况，导致 WA。  
- **优化经验**：枚举范围极小是本题关键，避免复杂数学推导。

---
处理用时：76.20秒
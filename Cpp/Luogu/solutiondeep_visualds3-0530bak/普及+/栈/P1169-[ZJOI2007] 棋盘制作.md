# 题目信息

# [ZJOI2007] 棋盘制作

## 题目描述

国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个 $8 \times 8$ 大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。

而我们的主人公 `小Q`，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友 `小W` 决定将棋盘扩大以适应他们的新规则。

`小Q` 找到了一张由 $N \times M$ 个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。`小Q` 想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。

不过 `小Q` 还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。

于是 `小Q` 找到了即将参加全国信息学竞赛的你，你能帮助他么？


## 说明/提示

对于 $20\%$ 的数据，$N, M ≤ 80$

对于 $40\%$ 的数据，$N, M ≤ 400$

对于 $100\%$ 的数据，$N, M ≤ 2000$


## 样例 #1

### 输入

```
3 3
1 0 1
0 1 0
1 0 0
```

### 输出

```
4
6
```

# AI分析结果



## **算法分类**  
悬线法

---

## **题解思路与核心难点**  
### **核心思路**  
题目要求找到棋盘上最大的正方形和矩形区域，满足相邻格子颜色不同。悬线法通过维护每个点的左、右、向上延伸的边界，逐步递推计算最大子矩阵。

### **关键步骤与难点**  
1. **预处理左右边界**：  
   - `left[i][j]`：点 (i,j) 向左能到达的最远位置（满足颜色交替）。  
   - `right[i][j]`：向右的最远位置。  
   - 初始化为当前列，通过相邻颜色判断递推。  

2. **向上延伸高度**：  
   - `up[i][j]`：点 (i,j) 向上能连续延伸的行数（颜色交替）。  
   - 若当前行与上一行颜色不同，`up[i][j] = up[i-1][j] + 1`，并合并左右边界。  

3. **实时更新答案**：  
   - 正方形面积：`min(横向宽度, up[i][j])` 的平方。  
   - 矩形面积：`横向宽度 * up[i][j]`。  

**难点**：正确合并上下行的左右边界，确保不越界且颜色交替条件成立。

---

## **题解评分 (≥4星)**  
1. **顾z（5星）**  
   - 思路清晰，详细解释悬线法原理和递推公式。  
   - 代码简洁，预处理和状态转移逻辑明确。  
   - 附示意图验证算法正确性，解决读者疑问。  

2. **Felis（4星）**  
   - 从悬线定义出发，分步讲解预处理和状态更新。  
   - 代码注释完整，适合新手理解。  

3. **George1123（4星）**  
   - 提出独特的坐标奇偶取反技巧，简化问题为纯色矩阵搜索。  
   - 结合动态规划和单调栈，提供多角度解法。  

---

## **最优思路与技巧提炼**  
1. **悬线法核心变量**：  
   ```cpp  
   left[i][j] = max(left[i][j], left[i-1][j]);  // 合并上下行左边界  
   right[i][j] = min(right[i][j], right[i-1][j]);  
   up[i][j] = up[i-1][j] + 1;  
   ```  
2. **奇偶取反优化**：  
   ```cpp  
   a[i][j] ^= (i + j) % 2;  // 将棋盘转换为纯色问题  
   ```  
3. **单调栈求矩形**：  
   - 预处理每列高度，对每行用单调栈维护递增序列，快速计算最大矩形。  

---

## **同类题目推荐**  
1. **P4147 玉蟾宫**（悬线法模板题）  
2. **P2701 巨大的牛棚**（最大正方形）  
3. **P1387 最大正方形**（动态规划解法）  

---

## **可视化与算法演示**  
### **动画方案设计**  
1. **网格绘制**：  
   - 棋盘渲染为像素风格，每个格子颜色表示原始值（0/1）。  
   - 悬线高亮：当前处理点 (i,j) 标记为黄色，`left`/`right`边界用红/蓝线标注，`up`高度用绿色柱状图显示。  

2. **关键操作演示**：  
   - **步进模式**：逐行处理，展示每个点的 `left`、`right`、`up` 更新过程。  
   - **颜色变化**：合并上下行边界时，用闪烁效果突出变化区域。  

3. **复古音效**：  
   - 悬线扩展时播放“滴”声，找到更大面积时播放“升级”音效。  
   - 背景音乐采用 8-bit 风格循环曲目。  

### **代码片段（Canvas绘制悬线）**  
```javascript  
function drawGrid() {
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      ctx.fillStyle = a[i][j] ? "#000" : "#FFF";
      ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
      // 绘制悬线边界
      ctx.strokeStyle = "red";
      ctx.beginPath();
      ctx.moveTo(left[i][j] * cellSize, i * cellSize);
      ctx.lineTo(left[i][j] * cellSize, (i + 1) * cellSize);
      ctx.stroke();
    }
  }
}
```  

---

## **个人心得摘录**  
1. **顾z的UPD部分**：  
   > “红色部分会被考虑到……悬线法通过逐层合并边界，确保不遗漏任何可能的极大子矩阵。”  
   - **启示**：悬线法的正确性依赖于逐行递推和边界合并，需理解状态转移的覆盖性。  

2. **George1123的坐标取反**：  
   > “将横纵坐标和为偶数的点取反，问题简化为纯色矩阵搜索。”  
   - **技巧**：通过数学变换将复杂条件转换为统一标准，大幅简化问题。  

---

## **完整代码（悬线法实现）**  
```cpp  
#include <bits/stdc++.h>
using namespace std;
const int N = 2005;
int n, m, a[N][N], l[N][N], r[N][N], up[N][N];
int ans1, ans2;

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            scanf("%d", &a[i][j]);
            l[i][j] = r[i][j] = j;
            up[i][j] = 1;
            if ((i + j) % 2 == 0) a[i][j] ^= 1;
        }

    // 预处理左右边界
    for (int i = 1; i <= n; i++) {
        for (int j = 2; j <= m; j++)
            if (a[i][j] != a[i][j-1]) 
                l[i][j] = l[i][j-1];
        for (int j = m-1; j >= 1; j--)
            if (a[i][j] != a[i][j+1])
                r[i][j] = r[i][j+1];
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (i > 1 && a[i][j] != a[i-1][j]) {
                up[i][j] = up[i-1][j] + 1;
                l[i][j] = max(l[i][j], l[i-1][j]);
                r[i][j] = min(r[i][j], r[i-1][j]);
            }
            int width = r[i][j] - l[i][j] + 1;
            ans1 = max(ans1, min(width, up[i][j]));
            ans2 = max(ans2, width * up[i][j]);
        }
    }
    printf("%d\n%d\n", ans1 * ans1, ans2);
    return 0;
}
```

---
处理用时：81.04秒
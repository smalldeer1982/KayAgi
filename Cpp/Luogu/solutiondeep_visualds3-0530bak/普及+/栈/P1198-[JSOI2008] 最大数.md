# 题目信息

# [JSOI2008] 最大数

## 题目描述

现在请求你维护一个数列，要求提供以下两种操作：

1.  查询操作。

语法：`Q L`

功能：查询当前数列中末尾 $L$ 个数中的最大的数，并输出这个数的值。

限制：$L$ 不超过当前数列的长度。$(L > 0)$

2. 插入操作。

语法：`A n`

功能：将 $n$ 加上 $t$，其中 $t$ 是最近一次查询操作的答案（如果还未执行过查询操作，则 $t=0$），并将所得结果对一个固定的常数 $D$ 取模，将所得答案插入到数列的末尾。

限制：$n$ 是整数（可能为负数）并且在长整范围内。

注意：初始时数列是空的，没有一个数。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq M \leq 2 \times 10^5$，$1 \leq D \leq 2 \times 10^9$。

## 样例 #1

### 输入

```
5 100
A 96
Q 1
A 97
Q 1
Q 2
```

### 输出

```
96
93
96
```

# AI分析结果



# 算法分类：数据结构（线段树/单调栈）

---

## 综合分析与结论

**核心难点**  
动态维护末尾插入的数列，高效查询末尾L个数中的最大值。关键挑战在于插入与查询的高效性（O(1)~O(log n)）。

**解决方案对比**  
1. **线段树**  
   - 直接维护区间最大值，支持动态插入和查询  
   - 时间复杂度：插入O(log n)，查询O(log n)  
   - 优点：通用性强，支持任意区间查询  
   - 缺点：代码量较大，空间占用较高  

2. **单调栈+二分**  
   - 维护递减单调栈，栈中元素为极大值及其位置  
   - 时间复杂度：插入均摊O(1)，查询O(log n)  
   - 优点：代码简洁高效，空间最优  
   - 缺点：仅适用于末尾查询场景  

3. **ST表**  
   - 反向维护区间，插入时更新前缀  
   - 时间复杂度：插入O(log n)，查询O(1)  
   - 优点：查询极快  
   - 缺点：插入复杂度较高，难以处理动态扩展  

**最优结论**  
推荐**单调栈+二分**，代码仅20行，时空效率最优。适合本题末尾插入与查询的特殊场景。

---

## 题解清单（≥4星）

1. **Spasmodic（5星）**  
   - 单调栈+二分，代码极简  
   - 核心代码片段：  
     ```cpp
     while(r && a[q[r-1]] < a[sz]) r--; // 维护递减栈
     q[r++] = sz;  // 记录极大值位置
     *lower_bound(q, q+r, sz-x+1);  // 二分查询
     ```

2. **moongazer（4星）**  
   - 分块算法，平衡插入与查询  
   - 亮点：将操作分块处理，均摊复杂度O(√n)  

3. **单曦增（4星）**  
   - 并查集优化单调栈，查询O(1)  
   - 巧妙点：用并查集跳过无效节点，提升查询效率  

---

## 可视化算法分析（单调栈+二分）

**动画设计**  
1. **像素风格演示**  
   - **栈元素**：用绿色方块表示，高度对应数值  
   - **当前元素**：红色高亮，插入时与栈顶比较  
   - **弹出动画**：被淘汰元素淡出，配"哔"音效  

2. **关键步骤**  
   - **插入96**：栈空直接入栈 → 栈：[96]  
   - **插入93**：93 < 96，入栈 → 栈：[96, 93]  
   - **查询L=2**：二分找到栈首 → 结果96  

**交互功能**  
- **速度调节**：滑块控制动画速度（0.5x~3x）  
- **单步执行**：按空格逐步观察栈变化  
- **音效**：成功查询播放"叮"，插入播放"咔嗒"  

---

## 核心代码实现（单调栈+二分）

```cpp
int main() {
    int m, d, sz = 0, r = 0;
    scanf("%d%d", &m, &d);
    vector<int> a(m+1), q(m+1);
    for (int i = 1; i <= m; ++i) {
        char op; int x;
        scanf(" %c%d", &op, &x);
        if (op == 'A') {
            a[++sz] = (x + t) % d;
            while (r && a[q[r-1]] < a[sz]) r--; // 维护单调性
            q[r++] = sz; // 记录位置
        } else {
            int pos = lower_bound(q.begin(), q.begin()+r, sz - x + 1) - q.begin();
            t = a[q[pos]];
            printf("%d\n", t);
        }
    }
}
```

---

## 相似题目推荐
1. **P1440 求m区间内的最小值**（单调队列模板）  
2. **P1886 滑动窗口**（滑动窗口最值）  
3. **P5788 单调栈**（右侧第一个更大元素）  

---

## 个人心得摘录
> "被数据范围坑了两次，原题L可能为0需特判。单调栈的边界处理是魔鬼细节！" —— xzyxzy  
> "并查集的跳跃式查询一开始难以理解，画图后才顿悟父节点指向下一个有效极大值" —— 单曦增  

---

## 拓展思考
**树状数组解法**：反向维护前缀最大值，插入时从后往前更新。查询时取最右L长度的块最大值。代码略复杂于单调栈但效率相当，适合喜欢BIT的学习者。

---
处理用时：65.93秒
# 题目信息

# 幻象迷宫

## 题目背景

（喵星人 LHX 和 WD 同心协力击退了汪星人的入侵，不幸的是，汪星人撤退之前给它们制造了一片幻象迷宫。）

WD：呜呜，肿么办啊……

LHX：momo...我们一定能走出去的！

WD：嗯，+U+U！

## 题目描述

幻象迷宫可以认为是无限大的，不过它由若干个 $N\times M$ 的矩阵重复组成。矩阵中有的地方是道路，用 $\verb!.!$ 表示；有的地方是墙，用 $\verb!#!$ 表示。LHX 和 WD 所在的位置用 $\verb!S!$ 表示。也就是对于迷宫中的一个点$(x,y)$，如果 $(x \bmod n,y \bmod m)$ 是 $\verb!.!$ 或者 $\verb!S!$，那么这个地方是道路；如果 $(x \bmod n,y \bmod m)$ 是$\verb!#!$，那么这个地方是墙。LHX 和 WD 可以向上下左右四个方向移动，当然不能移动到墙上。

请你告诉 LHX 和 WD，它们能否走出幻象迷宫（如果它们能走到距离起点无限远处，就认为能走出去）。如果不能的话，LHX 就只好启动城堡的毁灭程序了……当然不到万不得已，他不想这么做。

## 说明/提示

- 对于 $30\%$ 的数据，$1\le N,M\le 20$；
- 对于 $50\%$ 的数据，$1\le N,M\le 100$；
- 对于 $100\%$ 的数据，$1\le N,M\le 1500$，每个测试点不超过 $10$ 组数据。

## 样例 #1

### 输入

```
5 4
##.#
##S#
#..#
#.##
#..#
5 4
##.#
##S#
#..#
..#.
#.##
```

### 输出

```
Yes
No

```

# AI分析结果



# 幻象迷宫题解分析与可视化方案

## 算法分类
**深度优先搜索（DFS） / 广度优先搜索（BFS）**

---

## 题解核心思路与难点对比

### 核心算法流程
所有题解均基于**模坐标与绝对坐标联合判定**的核心思想：
1. **坐标映射**：将无限迷宫坐标 (x,y) 映射到原始矩阵 (x%n, y%m)
2. **状态记录**：额外记录该点对应的绝对坐标（或偏移量）
3. **循环检测**：当同一模坐标被不同绝对坐标访问时，判定存在无限路径

### 解决难点对比
| 题解特点                  | 数据结构                     | 时间复杂度 | 空间复杂度  |
|---------------------------|----------------------------|------------|-------------|
| DEVILK（三维数组记录）     | vis[x][y][lx, ly]           | O(N*M)     | O(N*M*K)    |
| GNAQ（三维数组记录）       | vis[posx][posy][x, y]       | O(N*M)     | O(N*M*K)    |
| ygsldr（二维迷宫扩展）     | map1[2n][2m]                | O(4N*M)    | O(4N*M)     |
| crpboy（虚拟坐标步数记录） | s[x][y][stepx, stepy]       | O(N*M)     | O(N*M*K)    |

---

## ★★★★★ 题解推荐
### 1. DEVILK（赞193）
**核心代码片段**：
```cpp
void dfs(int x, int y, int lx, int ly) {
    if(vis[x][y][0] && (vis[x][y][1]!=lx || vis[x][y][2]!=ly)) {
        fl = 1; // 发现不同绝对坐标的重复访问
        return;
    }
    vis[x][y][1] = lx, vis[x][y][2] = ly;
    // 四方向扩展时计算新绝对坐标
    int xx = (x + dx[i] + n) % n; 
    int lxx = lx + dx[i];
}
```
**亮点**：通过三维数组精确记录模坐标与绝对坐标的对应关系，时空效率均衡

### 2. GNAQ（赞74）
```cpp
void dfs(int x,int y,int posx,int posy) {
    if(vis[posx][posy][2] && (vis[posx][posy][0]!=x || ...))
        ans=1; // 状态比对触发条件
    vis[posx][posy][0]=x; // 记录绝对坐标
}
```
**优化点**：使用结构化的三维数组存储状态，逻辑清晰易维护

### 3. ygsldr（赞44）
```cpp
void dfs(int x,int y) {
    if(x==-1) return dfs(dn-1,y); // 边界传送
    if(map2[x%n][y%m]) return true; 
}
```
**创新性**：采用迷宫扩展与边界传送机制，直观展示无限迷宫特性

---

## 关键算法可视化设计
### 动画方案（Canvas实现）
1. **网格绘制**：绘制基础N×M网格，使用不同颜色标识：
   - 灰色：墙体
   - 绿色：可行路径
   - 红色：起点S

2. **探索动画**：
```javascript
function drawStep(x, y, lx, ly) {
    // 当前探索点高亮（金色）
    ctx.fillStyle = "#FFD700";
    ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
    
    // 绘制绝对坐标偏移量
    ctx.fillText(`(${lx},${ly})`, x*cellSize+2, y*cellSize+12);
}
```

3. **循环检测特效**：
```javascript
// 当检测到循环时触发
function showInfinite() {
    // 全屏闪烁黄色背景
    ctx.fillStyle = "rgba(255,255,0,0.3)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 播放成功音效
    new Audio('success.wav').play();
}
```

### 复古像素风格
- **调色板**：使用NES风格的8色调色板
  ```javascript
  const palette = ["#000000", "#FFFFFF", "#FF0000", "#00FF00", 
                  "#0000FF", "#FFFF00", "#FF00FF", "#00FFFF"];
  ```
- **音效设计**：
  - 移动：8-bit "bleep" 音效（Web Audio API生成）
  - 发现循环：FC游戏通关音效

---

## 同类型题目推荐
1. **P1443** 马的遍历（BFS基础）
2. **P1141** 01迷宫（连通块与无限扩展）
3. **P1825** [USACO11OPEN]Corn Maze S（复杂迷宫路径）

---

## 核心代码实现
DEVILK题解的精简版：
```cpp
#include<cstring>
const int MAXN = 1501;
int vis[MAXN][MAXN][3]; // [0]:是否访问 [1]:lx [2]:ly

void dfs(int x, int y, int lx, int ly) {
    if(vis[x][y][0] && (vis[x][y][1]!=lx || vis[x][y][2]!=ly)) {
        printf("Yes"); exit(0);
    }
    vis[x][y][0] = 1;
    vis[x][y][1] = lx, vis[x][y][2] = ly;
    
    for(int i=0; i<4; ++i){
        int nx = (x + dx[i] + n) % n;
        int ny = (y + dy[i] + m) % m;
        if(!a[nx][ny]) // 非墙体
            dfs(nx, ny, lx+dx[i], ly+dy[i]);
    }
}
```

---

## 思维拓展
当遇到**无限扩展类迷宫**问题时，可套用以下模板：
1. **坐标映射**：对原始矩阵尺寸取模
2. **状态扩展**：记录原始坐标外的附加信息（步数、偏移量等）
3. **循环判定**：在状态更新时比对历史记录
4. **剪枝优化**：及时终止无效路径的探索

通过这种模式化思维，可以快速解决类似P1443、P1141等迷宫变种问题。

---
处理用时：75.71秒
# 题目信息

# 角色属性树

## 题目描述

绪萌同人社是一个有趣的组织，该组织结构是一个树形结构。有一个社长，直接下属一些副社长。每个副社长又直接下属一些部长……。

每个成员都有一个萌点的属性，萌点属性是由一些质数的萌元素乘积构成（例如，猫耳的值是 $2$，弱气的值是 $3$，黄毛的值是 $5$，病娇的值是 $7$，双马尾的值是 $11$ 等等）

举个例子，正妹是双份的猫耳，而且有一份弱气，她的属性值为 $2\times 2\times 3=12$。

现在组员关心一个问题，希望知道离自己最近且有相同萌元素上司是谁，例如，属性值为 $2、4、6、45$ 这样的属性值都算是和正妹有相同的属性。


然而，组员可能会随时变化自己的属性。啊。。感觉好麻烦啊。。


## 说明/提示

对于 $20\%$ 的数据，没有修改的操作。

对于 $50\%$ 的数据，$n\le 100$，修改次数 $<10$。

对于 $100\%$ 的数据，$n\le 200000$，$k<100000$，修改次数 $\le 50,a\_i\le 2^{31}-1$

UPD：本题测试数据随机，可能是假题。

## 样例 #1

### 输入

```
4 6

10 8 4 3

1 2

2 3

3 4

1 1

1 2

1 3

1 4

2 1 9

1 4```

### 输出

```
-1

1

2

-1

1```

# AI分析结果



## 唯一算法分类
暴力枚举

## 综合分析与结论
本题核心在于快速找到满足条件的最近祖先节点。各题解均采用暴力向上遍历父节点链的方式，利用数据随机性获得实际可行性。关键要点在于：
1. 利用gcd>1判断两个数是否存在公共质因子
2. 通过树结构的父指针链式遍历
3. 数据随机性使期望遍历次数大大减少

可视化设计要点：
- **节点高亮**：用不同颜色表示当前查询节点、已检查节点和满足条件的节点
- **路径追踪**：动态绘制从查询节点到当前检查节点的路径
- **gcd计算展示**：实时显示当前节点与查询节点的gcd值
- **复古像素风格**：用8-bit色块表示树节点，路径追踪时产生类似贪吃蛇移动的视觉效果

## 题解清单（≥4星）
1. **Zilljy258（4.5星）**
   - 代码简洁，递归实现清晰
   - 核心函数仅5行，逻辑高度浓缩
2. **WZKQWQ（4.2星）**
   - 深入分析随机数据特性
   - 提供概率计算支撑暴力可行性
3. **quanjun（4星）**
   - 函数式实现，代码规范易读
   - 独立封装solve函数便于理解

## 最优思路与技巧
**关键技巧**：
1. **gcd快速判断**：利用STL的__gcd函数快速判断公共质因子
2. **链式遍历**：通过父指针数组实现O(1)空间的上溯遍历
3. **数据随机性利用**：依赖测试数据树高较小的特性保证效率

**思维突破点**：
- 逆向思维：不预处理质因数，而是动态计算gcd
- 复杂度换正确性：牺牲理论最坏复杂度换取代码简洁性

## 相似题目推荐
1. P3379（LCA问题）
2. P2421（树形结构属性查询）
3. P2633（树上路径查询）

## 可视化算法演示
```javascript
// 伪代码展示核心动画逻辑
class TreeVisualizer {
  constructor(nodes) {
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.nodes = nodes.map(n => ({...n, x:0, y:0}));
    this.path = [];
  }

  // 8-bit风格渲染
  render() {
    this.ctx.fillStyle = '#2D2D2D';
    this.ctx.fillRect(0, 0, 800, 600);
    
    this.nodes.forEach(node => {
      this.ctx.fillStyle = node.highlight ? '#FF5555' : '#88CCFF';
      this.ctx.fillRect(node.x, node.y, 30, 30);
    });

    // 绘制当前路径
    this.ctx.strokeStyle = '#FFFF00';
    this.path.forEach((p,i) => {
      if(i > 0) this.ctx.lineTo(p.x+15, p.y+15);
    });
    this.ctx.stroke();
  }

  // 执行查询动画
  async queryAnimation(nodeId) {
    let current = this.nodes.find(n => n.id === nodeId);
    while(current.parent) {
      this.path.push(current);
      this.render();
      await sleep(500); // 步进延迟
      if(gcd(current.val, targetVal) > 1) {
        current.highlight = true;
        break;
      }
      current = current.parent;
    }
  }
}
```

## 核心代码实现
```cpp
// 查询函数核心实现
int findNearest(int u) {
    for(int v = fa[u]; v; v = fa[v]) 
        if(__gcd(a[u], a[v]) > 1)
            return v;
    return -1;
}

// 完整代码结构
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5+5;
int a[N], fa[N];

int main() {
    int n, k; 
    scanf("%d%d", &n, &k);
    for(int i=1; i<=n; ++i) scanf("%d", a+i);
    
    // 建树
    for(int i=1; i<n; ++i) {
        int u, v; scanf("%d%d", &u, &v);
        fa[v] = u;
    }
    
    while(k--) {
        int op, x; scanf("%d%d", &op, &x);
        if(op == 1) {
            int ans = -1;
            for(int v=fa[x]; v; v=fa[v]) 
                if(__gcd(a[x], a[v]) > 1) {
                    ans = v; break;
                }
            printf("%d\n", ans);
        } else {
            int val; scanf("%d", &val);
            a[x] = val;
        }
    }
    return 0;
}
```

## 个人心得摘录
"测试数据的随机性让暴力变得可行——在工业级代码中可能被视为hack的做法，在算法竞赛特定场景下却成为最优解。这提醒我们要充分理解题目条件的所有可能性。" —— WZKQWQ

"递归实现的简洁性有时能超越循环的性能优势，特别是在代码可读性方面。当时间复杂度不是瓶颈时，应该优先选择更易维护的写法。" —— Zilljy258

## 同类算法拓展
该暴力解法可视为**链式遍历法**的典型应用，类似场景包括：
1. 链表环检测（龟兔赛跑算法）
2. 树形结构最近公共祖先查询
3. 跳跃指针法的简化版本

在允许一定概率失败或依赖数据特性的场景下，此类算法往往能取得出人意料的效果。

---
处理用时：64.90秒
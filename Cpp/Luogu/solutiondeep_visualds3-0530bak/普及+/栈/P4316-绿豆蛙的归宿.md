# 题目信息

# 绿豆蛙的归宿

## 题目背景

随着新版百度空间的上线，Blog 宠物绿豆蛙完成了它的使命，去寻找它新的归宿。

## 题目描述

给出张 $n$ 个点 $m$ 条边的有向无环图，起点为 $1$，终点为 $n$，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。

绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果该节点有 $k$ 条出边，绿豆蛙可以选择任意一条边离开该点，并且走向每条边的概率为 $\frac{1}{k}$ 。现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 10^2$。
- 对于 $40\%$ 的数据，保证 $n \leq 10^3$。
- 对于 $60\%$ 的数据，保证 $n \leq 10^4$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times n$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^9$，给出的图无重边和自环。

## 样例 #1

### 输入

```
4 4 
1 2 1 
1 3 2 
2 3 3 
3 4 4```

### 输出

```
7.00```

# AI分析结果



**唯一算法分类**：期望动态规划（期望DP）与拓扑排序

---

### **综合分析与结论**
**核心思路**：  
- **逆推期望DP**：设`f[x]`为节点`x`到终点`n`的期望路径长度，状态转移方程为：  
  \[
  f[x] = \sum_{y \in \text{后继节点}} \frac{f[y] + w(x,y)}{k} \quad (k=\text{出度})
  \]  
  反向建图后，利用拓扑排序按逆序计算每个节点的期望值，确保每个节点的所有后继节点已被处理。

**解决难点**：  
1. **逆推的正确性**：终点`f[n]=0`确定，逆序保证每个节点的依赖项已计算完毕。  
2. **拓扑排序优化**：通过反向图的拓扑排序实现高效递推，时间复杂度为 \(O(n + m)\)。  

**可视化设计**：  
1. **动画演示**：  
   - **DAG结构**：用节点和带权边的形式展示图结构，终点`n`标记为绿色，当前处理节点高亮为红色。  
   - **拓扑排序过程**：按逆序逐个处理节点，显示当前节点的`f[x]`值更新过程。  
   - **期望计算**：动态显示每个节点的`f[x]`值如何由后继节点加权平均得到，边权以悬浮标签显示。  
2. **复古像素风格**：  
   - 节点以8位像素方块表示，边以像素线条连接，处理时播放“滴答”音效。  
   - **自动播放模式**：算法自动运行，用户可调节速度或单步执行。  

---

### **题解评分（≥4星）**
1. **___new2zy___（5星）**  
   - **亮点**：详细推导逆推期望DP，代码清晰反向拓扑排序实现。  
   - **核心代码**：  
     ```cpp
     void toposort() {
         queue<int> q;
         q.push(n);
         while (!q.empty()) {
             int x = q.front(); q.pop();
             for (int i = head[x]; i; i = p[i].from) {
                 int y = p[i].to;
                 f[y] += (f[x] + p[i].w) / dg[y];
                 if (!(--in[y])) q.push(y);
             }
         }
     }
     ```

2. **wangjyqh（4星）**  
   - **亮点**：对比正推与逆推，给出两种代码实现。  
   - **关键公式**：  
     - 逆推：\( f[x] = \sum \frac{f[y] + w}{k} \)  
     - 正推：需维护概率和期望，复杂度较高。

3. **ghj1222（4星）**  
   - **亮点**：转化为边期望次数求和，提供新视角。  
   - **核心代码**：  
     ```cpp
     for (int i = 0; i < e[x].size(); i++) {
         p[y] += p[x] / out[x];
         ans += p[x] / out[x] * e[x][i].w;
     }
     ```

---

### **最优思路提炼**
1. **逆推法**：  
   - **状态设计**：`f[x]`表示`x`到终点的期望长度，避免正推的概率维护。  
   - **拓扑排序**：反向建图后按拓扑序递推，保证无后效性。  
   - **时间复杂度**：\(O(n + m)\)，适用于大规模数据。  

2. **关键代码段**：  
   ```cpp
   // 反向建图，拓扑排序逆推
   for (int i = 1; i <= m; i++) {
       add_edge(y, x, w); // 反向边
       in[x]++, dg[x]++;  // in为拓扑排序入度，dg为原图出度
   }
   while (!q.empty()) {
       int x = q.front(); q.pop();
       for (each x的后继节点 y) {
           f[y] += (f[x] + w) / dg[y];
           if (--in[y] == 0) q.push(y);
       }
   }
   ```

---

### **同类型题与算法套路**
- **通用解法**：DAG上的期望DP通常逆推，结合拓扑排序处理依赖关系。  
- **类似题目**：  
  1. [P1850 换教室](https://www.luogu.com.cn/problem/P1850)（期望DP）  
  2. [P3232 游走](https://www.luogu.com.cn/problem/P3232)（边期望次数+高斯消元）  
  3. [P6154 走路](https://www.luogu.com.cn/problem/P6154)（DAG上的概率DP）  

---

### **推荐题目**
1. **P1850**：多状态期望DP，需处理概率转移。  
2. **P6154**：DAG上的路径计数与概率计算。  
3. **P6835**：图论与期望结合，需灵活设计状态。  

---

### **个人心得摘录**
- **逆推简化问题**：终点状态确定时，逆推避免复杂的概率累乘（如：`f[n] = 0`直接初始化）。  
- **反向建图技巧**：通过反向边和拓扑排序实现高效递推，避免递归爆栈。  

---

### **可视化与算法演示**
**核心算法动画**：  
1. **初始化**：  
   - 终点`n`标记为绿色，`f[n] = 0`，其他节点为灰色。  
2. **拓扑排序步骤**：  
   - 当前处理节点变为红色，计算其所有前驱节点的`f`值。  
   - 边权显示为黄色标签，更新时显示公式：`f[y] += (f[x] + w) / k`。  
3. **完成状态**：  
   - 所有节点变为蓝色，起点`f[1]`显示最终结果。  

**复古风格实现**：  
- **8位音效**：节点处理时播放“滴答”声，边权更新时播放短音效。  
- **Canvas绘制**：用像素网格模拟DAG，节点编号显示在方块中央。  

```javascript
// 伪代码：动画关键帧
function updateNode(x) {
    highlight(x, 'red'); // 当前节点高亮
    for (let edge of reversedEdges[x]) {
        let y = edge.from;
        f[y] += (f[x] + edge.w) / outDegree[y];
        drawEdgeAnimation(edge, 'yellow'); // 边权更新动画
    }
    requestAnimationFrame(() => processNextNode());
}
```

---
处理用时：78.40秒
# 题目信息

# [ROI 2018]  Decryption

## 题目背景

译自 [ROI 2018 Day2](https://neerc.ifmo.ru/school/archive/2017-2018.html) T1. [Расшифровка](https://neerc.ifmo.ru/school/archive/2017-2018/ru-olymp-roi-2018-day2.pdf) ([Decryption](https://codeforces.com/gym/102154/problem/B))。 

## 题目描述

研究表明，汉字的顺序并不一定能影响阅读。科学家们对数列进行了类似的研究。

给一个正整数数列，若数列首项为数列中所有数的最小值，末项为数列中的最大值，则我们称这是个正确的数列。例如，序列 $[1, 3, 2, 4]$ 和 $[1, 2, 1, 2]$ 是正确的，但序列 
$[1, 3, 2]$ 不是。

给出长度为 n 的序列 $[a_1, a_2, \ldots, a_n]$。对于该序列的某个片段 $[a_l, a_{l+1}, \ldots, a_r]$, 若该片段的首项为该片段中的最小值，末项为该片段中的最大值，则我们称这是个正确的片段。

对于给定的序列，请求出该序列至少需要被分成多少段，才能使得每个片段均为正确的片段。序列 $[2, 3, 1, 1, 5, 1]$ 可以分为三个正确的段：$[2, 3]$ 和 $[1, 1, 5]$ 和 $[1]$。

需要编写一个程序，该程序按给定的顺序确定可以划分的最小正确段数。

## 说明/提示

对于 $30\%$ 的数据，$1 \leq n \leq 500$。

对于 $60\%$ 的数据，$1 \leq n \leq 5000$。

对于所有数据，$1 \leq n \leq3 \times 10^5$，$1\leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
5
5 4 3 2 1```

### 输出

```
5```

## 样例 #2

### 输入

```
4
1 3 2 4```

### 输出

```
1```

## 样例 #3

### 输入

```
6
2 3 1 1 5 1```

### 输出

```
3```

# AI分析结果



**唯一算法分类**  
单调栈与贪心

---

### **题解思路与算法要点**  
题目要求将序列分割成最少的正确片段（首项为片段最小值，末项为最大值）。核心思路是通过预处理确定每个元素右侧第一个更大/更小的位置，再通过贪心或动态规划快速确定分段边界。

#### **核心难点与解决方案**  
1. **如何快速找到每个元素的合法右端点？**  
   - 预处理每个元素右侧第一个更大（`mx[i]`）和更小（`mn[i]`）的位置，使用单调栈在 O(n) 时间内完成。
2. **如何贪心选择最长片段？**  
   - 从后向前遍历，每次尽可能扩展右端点。若当前右端点 `r` 满足 `mx[r] < mn[l]`，则继续跳到 `mx[r]`，直到无法扩展为止。
3. **如何通过单调栈优化动态规划？**  
   - 维护两个单调栈（递减栈和递增栈），利用二分查找确定转移点，DP 记录到当前位置的最小分段数。

---

### **题解评分 (≥4星)**  
1. **flangeborg (5星)**  
   - **亮点**：结合单调栈与 DP，思路清晰，代码简洁高效。  
   - **关键代码**：  
     ```cpp
     while (top1 && a[stk1[top1]] <= a[i]) top1--;
     stk1[++top1] = i;
     dp[i] = dp[*lower_bound(stk2 + 1, stk2 + top2 + 1, stk1[top1 - 1]) - 1] + 1;
     ```
2. **Loser_Syx (5星)**  
   - **亮点**：预处理 + 贪心，时间复杂度 O(n)，实现直观。  
   - **关键代码**：  
     ```cpp
     for (int i = n; i; ++res) {
         int j = i;
         for (; mx[i] < mn[j]; j = mn[j]);
         i = j - 1;
     }
     ```
3. **JJerry (4星)**  
   - **亮点**：分治思想结合 ST 表，递归处理子问题。  
   - **关键代码**：  
     ```cpp
     if (minn <= maxx) ans++;  // 找到合法区间
     else q.push(node{l, maxx});  // 分割处理
     ```

---

### **最优思路与技巧提炼**  
1. **预处理右侧边界**：通过单调栈预处理 `mx` 和 `mn` 数组，快速定位每个元素可能的扩展边界。
2. **贪心扩展片段**：从后向前遍历，利用预处理数组跳跃式扩展右端点，保证每次选择最长的合法片段。
3. **单调栈优化 DP**：维护递减栈确定左侧更大元素，递增栈辅助二分查找转移点，实现 O(n log n) 动态规划。

---

### **类似题目推荐**  
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)  
2. [P3143 钻石收藏家](https://www.luogu.com.cn/problem/P3143)  
3. [P1901 发射站](https://www.luogu.com.cn/problem/P1901)

---

### **可视化算法演示**  
**动画设计**：  
1. **预处理阶段**：  
   - 用颜色标记当前元素 `i`，动态显示单调栈的入栈和出栈过程。  
   - 高亮 `mx[i]` 和 `mn[i]` 的位置，展示右侧第一个更大/更小元素。  
2. **贪心扩展阶段**：  
   - 从末尾开始，用红色框标记当前段起点 `i`，绿色箭头逐步跳到 `mx[r]`，直到无法扩展。  
   - 每次分段时播放音效，并显示分段计数增加。  
3. **复古像素风格**：  
   - 使用 8-bit 像素风格绘制数组元素，背景音乐为循环芯片音乐。  
   - 关键操作（入栈、分段）时播放短促音效（如“哔”声）。  

**交互控制**：  
- **步进/暂停**：手动控制动画进度，观察每一步栈和分段变化。  
- **自动模式**：AI 自动执行算法，速度可调（慢/正常/快）。  

---

### **代码实现（核心逻辑）**  
```cpp
// Loser_Syx 的贪心实现
#include <vector>
using namespace std;

int main() {
    int n; cin >> n;
    vector<int> a(n+1), mn(n+1), mx(n+1), mns, mxs;
    mns.push_back(0); mxs.push_back(0);
    for (int i=1; i<=n; ++i) {
        cin >> a[i];
        // 预处理 mn[i]：右侧第一个更小的位置
        while (mns.size()>1 && a[i]<a[mns.back()]) mns.pop_back();
        mn[i] = mns.back();
        mns.push_back(i);
        // 预处理 mx[i]：右侧第一个更大的位置
        while (mxs.size()>1 && a[i]>=a[mxs.back()]) mxs.pop_back();
        mx[i] = mxs.back();
        mxs.push_back(i);
    }
    int res = 0;
    for (int i=n; i; ++res) {  // 从后向前贪心
        int j = i;
        while (mx[i] < mn[j]) j = mn[j];  // 跳跃扩展
        i = j - 1;  // 更新下一段起点
    }
    cout << res;
}
```

---
处理用时：112.66秒
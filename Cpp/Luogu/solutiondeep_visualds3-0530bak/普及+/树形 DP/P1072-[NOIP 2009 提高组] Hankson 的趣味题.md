# 题目信息

# [NOIP 2009 提高组] Hankson 的趣味题

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。

今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：

1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；

2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。

Hankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。


## 说明/提示

**【样例解释】**

第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。

第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。

**【数据范围】**

- 对于 $50\%$ 的数据，保证有 $1\leq a_0,a_1,b_0,b_1 \leq 10000$ 且 $n \leq 100$。
- 对于 $100\%$ 的数据，保证有 $1 \leq a_0,a_1,b_0,b_1 \leq 2 \times 10^9$ 且 $n≤2000$。

NOIP 2009 提高组 第二题


## 样例 #1

### 输入

```
2 
41 1 96 288 
95 1 37 1776 ```

### 输出

```
6 
2```

# AI分析结果



## 唯一算法分类
**数论**

---

## 综合分析与结论

### 核心算法思路
题目要求满足两个条件的整数个数：  
1. $\gcd(x, a_0) = a_1$  
2. $\text{lcm}(x, b_0) = b_1$  

**关键性质**：  
- $x$ 必须是 $b_1$ 的因数（由最小公倍数定义）  
- $x$ 需满足质因数分解的约束条件（由最大公约数和最小公倍数的质因数性质决定）  

### 解决难点
1. **高效枚举**：直接枚举 $x$ 的复杂度为 $O(\sqrt{b_1})$，需优化检查条件的方法  
2. **数学推导**：通过质因数分解将问题转化为指数范围的组合问题，避免暴力枚举  

### 核心算法流程
1. **因数枚举法**（4星）：  
   - 枚举 $b_1$ 的所有因数 $d$  
   - 检查 $d$ 是否满足 $\gcd(d, a_0) = a_1$ 和 $\text{lcm}(d, b_0) = b_1$  
   - 复杂度：$O(n \sqrt{b_1} \log b_1)$  

2. **质因数分解法**（5星）：  
   - 对 $a_0, a_1, b_0, b_1$ 进行质因数分解  
   - 对每个质因数 $p$，分析其指数约束条件：  
     - $\gcd$ 条件：$x$ 的指数下限由 $a_1$ 的指数决定  
     - $\text{lcm}$ 条件：$x$ 的指数上限由 $b_1$ 的指数决定  
   - 统计所有质因数的可能指数范围组合  

---

## 题解清单（≥4星）

### 1. KesdiaelKen（5星）
- **亮点**：通过数学推导将问题转化为质因数分解后的指数约束组合  
- **代码片段**：  
  ```cpp
  int cf(int a, int b) { // 去除 a 中与 b 共有的质因数
      ssqrt = sqrt(b);
      for(int i=2; i<=ssqrt; i++) {
          if(b%i == 0) while(a%i == 0) a /= i;
          while(b%i == 0) b /= i;
      }
      if(b != 1) while(a%b == 0) a /= b;
      return a;
  }
  ```
- **关键思路**：通过预处理质数分解，计算每个质因数的允许指数范围  

### 2. zzlzk（4星）
- **亮点**：简洁的因数枚举与条件检查  
- **代码片段**：  
  ```cpp
  for(int x=1; x*x <= b1; x++) {
      if(b1 % x == 0) {
          if(x % a1 == 0 && gcd(x/a1, p) == 1 && gcd(q, b1/x) == 1) ans++;
          int y = b1/x;
          if(y % a1 == 0 && gcd(y/a1, p) == 1 && gcd(q, b1/y) == 1) ans++;
      }
  }
  ```
- **关键思路**：直接枚举因数，利用 $\gcd$ 快速验证  

### 3. 皎月半洒花（4星）
- **亮点**：唯一分解定理的精细分析  
- **代码片段**：  
  ```cpp
  if(N1 > N2 && N3 < N4) {
      if(N2 == N4) A[i] = B[i] = 1;
      else { mark = 0; break; }
  }
  ```
- **关键思路**：逐质因数分析约束条件，组合可能性  

---

## 最优技巧提炼
1. **质因数分解约束**：将问题拆解为每个质因数的指数范围组合  
2. **因数成对枚举**：仅需枚举到 $\sqrt{b_1}$，处理因数对 $(d, b_1/d)$  
3. **数学优化检查**：通过 $\gcd$ 和 $\text{lcm}$ 的数学性质减少计算量  

---

## 同类型题目
1. **P1029** 最大公约数和最小公倍数问题  
2. **P2445** 能量采集（数论与 gcd 性质）  
3. **P1445** 樱花（质因数分解与组合）  

---

## 可视化与算法演示

### 动画设计（Canvas 像素风格）
1. **质因数分解动画**：  
   - **网格布局**：展示 $a_0, a_1, b_0, b_1$ 的质因数分解结果  
   - **颜色标记**：红色高亮当前处理的质因数，绿色标记合法指数范围  
   - **音效**：分解成功时播放 8-bit 音效  

2. **因数枚举动画**：  
   - **像素方块**：用方块表示 $b_1$ 的因数，绿色方块表示合法解  
   - **音效**：合法解出现时播放上扬音调  

3. **自动演示模式**：  
   - **AI 控制**：模拟算法流程，自动执行质因数分解与检查  
   - **速度调节**：支持暂停/步进，观察关键步骤  

### 复古游戏化实现
- **颜色方案**：16 色调色板，经典 FC 风格  
- **音效设计**：  
  - 分解成功：短促“滴”声  
  - 合法解：跳跃音阶  
  - 错误解：低沉“哔”声  
- **积分系统**：每正确解决一个质因数得 100 分，连击加倍  

---

## 代码实现（核心逻辑）
### 因数枚举法（zzlzk）
```cpp
#include <cstdio>
using namespace std;

int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        int a0, a1, b0, b1, ans = 0;
        scanf("%d%d%d%d", &a0, &a1, &b0, &b1);
        for (int x = 1; x * x <= b1; x++) {
            if (b1 % x != 0) continue;
            if (x % a1 == 0 && gcd(x / a1, a0 / a1) == 1 && gcd(b1 / b0, b1 / x) == 1) ans++;
            int y = b1 / x;
            if (x != y && y % a1 == 0 && gcd(y / a1, a0 / a1) == 1 && gcd(b1 / b0, b1 / y) == 1) ans++;
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

---

## 个人心得摘录
- **调试教训**：质因数分解需处理剩余的大质数（如代码中 `if(b1>1)` 的判断）  
- **优化顿悟**：发现 $\gcd$ 和 $\text{lcm}$ 的指数约束后，复杂度从 $O(\sqrt{b_1})$ 降至 $O(\log b_1)$

---
处理用时：118.42秒
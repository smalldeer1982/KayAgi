# 题目信息

# [USACO10MAR] Great Cow Gathering G

## 题目描述

Bessie 正在计划一年一度的奶牛大集会，来自全国各地的奶牛将来参加这一次集会。当然，她会选择最方便的地点来举办这次集会。

每个奶牛居住在 $N$ 个农场中的一个，这些农场由 $N-1$ 条道路连接，并且从任意一个农场都能够到达另外一个农场。道路 $i$ 连接农场 $A_i$ 和 $B_i$，长度为 $L_i$。集会可以在 $N$ 个农场中的任意一个举行。另外，每个牛棚中居住着 $C_i$ 只奶牛。

在选择集会的地点的时候，Bessie 希望最大化方便的程度（也就是最小化不方便程度）。比如选择第 $X$ 个农场作为集会地点，它的不方便程度是其它牛棚中每只奶牛去参加集会所走的路程之和（比如，农场 $i$ 到达农场 $X$ 的距离是 $20$，那么总路程就是 $C_i\times 20$）。帮助 Bessie 找出最方便的地点来举行大集会。

## 说明/提示

$1\leq N\leq 10^5$，$1\leq A_i\leq B_i\leq N$，$0 \leq C_i,L_i \leq 10^3$。

## 样例 #1

### 输入

```
5 
1 
1 
0 
0 
2 
1 3 1 
2 3 2 
3 4 3 
4 5 3 
```

### 输出

```
15 
```

# AI分析结果



# 【算法分类】
树形DP（换根法）

# 【题解分析与结论】
## 核心思路
通过两次DFS实现树形动态规划：
1. **预处理DFS**：计算以任意根节点（通常选1号节点）为聚集点的总成本，并统计各子树奶牛总数。
2. **换根DFS**：利用状态转移方程 `f[v] = f[u] + (总奶牛数 - 子树v奶牛数) * 边权 - 子树v奶牛数 * 边权` 推导所有节点的总成本。

## 解决难点
1. **状态转移方程推导**：通过观察父节点与子节点间奶牛移动带来的成本变化，将O(n²)复杂度优化为O(n)。
2. **子树统计技巧**：在预处理DFS中同时计算子树奶牛总数，为换根计算提供关键参数。
3. **带权树处理**：将奶牛数量作为点权，结合边权进行动态规划计算。

# 【题解评分（≥4星）】
1. **yybyyb（5星）**  
   - 清晰的两遍DFS框架，代码结构简洁  
   - 核心状态转移方程推导准确，注释详细  
   - 时间复杂度严格O(n)，适用于1e5数据规模

2. **Magi_karp（4.5星）**  
   - 创新性引入带权树重心概念  
   - 通过重构问题为经典重心问题提供新视角  
   - 实际运行效率与两次DFS方法相当

3. **James_Brady（4星）**  
   - 采用父节点-子节点双维度DP  
   - 分治思想清晰，代码模块化程度高  
   - 包含调试心得（初始值设置问题）

# 【最优思路提炼】
**换根法核心步骤**：
1. **预处理子树信息**：
```cpp
void dfs1(int u, int fa) {
    size[u] = c[u];
    for(auto v : tree[u]) {
        if(v == fa) continue;
        dfs1(v, u);
        size[u] += size[v];
        dp[u] += dp[v] + size[v] * edge_len;
    }
}
```

2. **状态转移方程**：
```math
dp[子节点] = dp[父节点] + (总奶牛数 - 子树奶牛数) * 边权 - 子树奶牛数 * 边权
```

3. **换根遍历**：
```cpp
void dfs2(int u, int fa) {
    ans = min(ans, dp[u]);
    for(auto v : tree[u]) {
        if(v == fa) continue;
        dp[v] = dp[u] + (total - size[v]) * edge_len - size[v] * edge_len;
        dfs2(v, u);
    }
}
```

# 【同类型题拓展】
1. **类似算法套路**：
   - 医院设置（动态规划求最小距离和）
   - 树的重心变形问题（带权重心计算）
   - 最短路径树优化问题

2. **推荐题目**：
   - P1364 医院设置（基础版）
   - P3041 [USACO12JAN]视频游戏的连击
   - P3478 [POI2008]STA-Station（换根法模板）

# 【个人心得摘录】
> "调试时发现初始值设置不足导致WA，将ans初始值改为1e18后通过。树形DP问题中，long long类型和足够大的初始值至关重要。"

> "重构问题为带权重心问题时，发现边权不影响重心位置的计算，只需将点权视为虚拟节点数，这一发现极大简化了问题。"

# 【可视化设计】
**动画演示方案**：
1. **树结构展示**：
   - 使用Canvas绘制树形结构，边权用不同颜色标注
   - 节点大小与奶牛数量成正比（点权可视化）

2. **预处理阶段**：
   - 红色高亮当前处理的子树
   - 动态显示size[u]和dp[u]的累加过程
   - 播放"数据更新"音效（8-bit风格）

3. **换根阶段**：
   - 绿色脉冲效果展示状态转移路径
   - 对比显示父节点与子节点dp值变化公式
   - 使用半透明区域区分子树与非子树区域

**交互功能**：
1. 速度控制条（0.5x~5x）
2. 单步执行按钮观察关键步骤
3. 模式切换：经典换根法 vs 树重心方法对比

**音效设计**：
- 正确转移：NES风格上升音阶
- 错误操作：经典FC失败音效
- 找到最优解：马里奥吃到金币音效

**像素风格**：
- 16色限定调色板（FC经典黄绿配色）
- 节点用8x8像素块表示，边权用LED风格数字显示
- 背景播放《超级马里奥》地下关BGM（循环MIDI）

# 【核心代码实现】
```cpp
// 换根法核心代码
#include <vector>
using namespace std;
typedef long long LL;
const int N = 1e5+5;

vector<pair<int,int>> G[N];
LL c[N], size[N], dp[N], total, ans = 1e18;

void dfs1(int u, int fa) {
    size[u] = c[u];
    for(auto [v, w] : G[u]) {
        if(v == fa) continue;
        dfs1(v, u);
        size[u] += size[v];
        dp[u] += dp[v] + size[v] * w;
    }
}

void dfs2(int u, int fa) {
    ans = min(ans, dp[u]);
    for(auto [v, w] : G[u]) {
        if(v == fa) continue;
        dp[v] = dp[u] + (total - size[v]) * w - size[v] * w;
        dfs2(v, u);
    }
}

int main() {
    int n; cin >> n;
    for(int i=1; i<=n; ++i) {
        cin >> c[i];
        total += c[i];
    }
    for(int i=1; i<n; ++i) {
        int u, v, w;
        cin >> u >> v >> w;
        G[u].emplace_back(v, w);
        G[v].emplace_back(u, w);
    }
    dfs1(1, -1);
    dfs2(1, -1);
    cout << ans;
}
```

---
处理用时：102.23秒
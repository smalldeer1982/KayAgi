# 题目信息

# 「C.E.L.U-01」族谱树

## 题目背景

小 Soup 正在翻看他们家的族谱，他们家的族谱构成了一棵树。小 Soup 发现，由于年代久远，他们家族中的一些分支已经绝迹，他对此十分好奇。

## 题目描述

小 Soup 给你他们家的族谱树，想要问你在这棵树中**所有**第 $k$ 层的孩子（树中深度为 $k$ 的点，根节点的深度为 $1$ ,根节点编号为 $1$ ）的 $\text{最近公共祖先}$ 是谁。

## 说明/提示


样例解释1：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zgcgu0da.png)

样例解释2：  
![](https://cdn.luogu.com.cn/upload/image_hosting/l02zvtkv.png)

#### 数据保证存在深度为 $k$ 的点

$\begin{array}{|c|c|c|}数据编号&n,m&特殊性质\\1&\le10&\diagdown\\2&\le100&\diagdown\\3\sim4&\le10^3&\diagdown\\5&\le3\times10^5&树为一条链\\6&\le3\times10^5&\diagdown\\7\sim10&\le3\times10^6&\diagdown\\11\sim12&\le5\times10^6&\diagdown\end{array}$


对于 $100\%$ 的数据，$n\le5\times10^6,m\le n$。

温馨提示：此题较卡常，请注意大常数带来的影响以及时空复杂度。如果你被卡常了，可以试试使用快速读入。

## 样例 #1

### 输入

```
8 3
0 1 1 2 2 3 4 5
2
1
4
```

### 输出

```
1
1
2```

## 样例 #2

### 输入

```
11 4
0 1 1 3 3 3 4 5 8 8 10
3
4
5
6```

### 输出

```
3
3
8
11```

# AI分析结果



## 算法分类
**树遍历与LCA性质应用**

---

## 题解思路与核心难点对比
### 核心思路
所有题解均围绕以下两个关键性质展开：
1. **答案分布在最长链上**：所有深度k的LCA必定在根到最深节点的路径上
2. **深度单调性**：若u是深度k的LCA，则u也必须是所有k'<k深度的LCA的祖先

### 解法对比
| 题解作者         | 核心方法                                                                 | 时间复杂度 | 空间复杂度 | 关键优化点                     |
|------------------|------------------------------------------------------------------------|------------|------------|--------------------------------|
| abruce           | 两次DFS预处理最大/次大子树深度，动态确定LCA链                          | O(n)       | O(n)       | 子树深度信息剪枝               |
| 无尽星空         | 类Tarjan离线处理，维护各深度节点的LCA                                  | O(n)       | O(n)       | 并查集+DFS序合并              |
| itisover         | 通过DFS序判断子树覆盖范围，从最深节点向上跳转                          | O(n)       | O(n)       | 最长链指针跳跃优化             |
| Farkas_W         | 长链剖分，仅维护最长链信息                                             | O(n)       | O(n)       | 长链性质剪枝                   |
| 老壁灯           | 欧拉序范围判断，逆向处理深度                                           | O(n)       | O(n)       | 欧拉序范围极值维护             |

---

## 最优思路与技巧提炼
### 关键技巧
1. **最长链跳跃法**（itisover解法）
   - 预处理每个深度层的DFS序最小/最大值
   - 从最深节点开始逆序处理，通过判断当前节点是否能覆盖该层的所有节点范围，动态调整LCA指针

2. **子树深度剪枝**（abruce解法）
   ```cpp
   // 关键代码片段
   int dfs2(int x, int now) {
       if (md[mx2[x]] >= now) return x; // 次大子树无法覆盖目标深度
       if (!md[mx1[x]] || d[x] == now) return x;
       return dfs2(mx1[x], now); // 向最大子树方向移动
   }
   ```

3. **欧拉序极值法**（老壁灯解法）
   ```cpp
   // 预处理每个深度的最小/最大DFS序
   void dfs(int u) {
       l[u] = ++tot;
       maxl[dep] = min(l[u], maxl[dep]);
       maxr[dep] = max(l[u], maxr[dep]);
       // ...遍历子树
   }
   
   // 判断覆盖
   while(l[pos] > maxl[i] || r[pos] < maxr[i]) 
       pos = fa[pos];
   ```

---

## 可视化算法设计
### 动画演示方案
1. **树结构展示**
   - 使用Canvas绘制树形结构，根节点在顶端，不同深度层水平排列
   - 当前处理的节点用闪烁的红色边框标记

2. **关键步骤演示**
   ```javascript
   // 伪代码示例
   class Visualizer {
       constructor(tree) {
           this.highlightNode(node, color); // 高亮当前节点
           this.drawSubtreeRange(node);     // 绘制子树覆盖范围
           this.showDepthLayer(k);          // 标记目标深度层
       }
       
       animateLCA(k) {
           // 从最深节点开始向上跳转
           let ptr = deepestNode;
           while(!coversLayer(ptr, k)) {
               this.highlightPath(ptr, 'gray'); // 标记无效路径
               ptr = ptr.parent;
           }
           this.highlightNode(ptr, 'gold'); // 标记最终LCA
       }
   }
   ```

3. **复古像素风格**
   - 使用16色调色板（NES风格）
   - 节点显示为8x8像素方块，不同深度层使用不同颜色
   - 音效设计：
     - `jump.wav`：节点跳跃音效
     - `confirm.wav`：找到LCA时的确认音
     - `error.wav`：超出覆盖范围提示音

---

## 相似题目推荐
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P3884 [JLOI2009]二叉树问题](https://www.luogu.com.cn/problem/P3884)
3. [P2633 Count on a tree](https://www.luogu.com.cn/problem/P2633)

---

## 题解评分（≥4星）
1. **abruce（★★★★★）**
   - 双DFS预处理清晰，利用子树深度信息高效剪枝
   - 完整数学证明支撑算法正确性

2. **itisover（★★★★☆）**
   - DFS序判断覆盖范围的思路新颖
   - 最长链跳跃法实现简洁高效

3. **老壁灯（★★★★☆）**
   - 欧拉序极值法实现巧妙
   - 逆向处理深度的思路极具启发性

---

## 核心代码实现（itisover解法）
```cpp
const int N = 5e6+5;
int dfn[N], ed[N], dep[N], fa[N], ans[N];
int min_dfn[N], max_dfn[N];

void dfs(int u) {
    dfn[u] = ++cnt;
    min_dfn[dep[u]] = min(min_dfn[dep[u]], dfn[u]);
    max_dfn[dep[u]] = max(max_dfn[dep[u]], dfn[u]);
    for(int v : children[u]) {
        dep[v] = dep[u] + 1;
        dfs(v);
    }
    ed[u] = cnt;
}

void solve() {
    int ptr = deepest_node;
    for(int d = max_depth; d >= 1; d--) {
        while(dfn[ptr] > min_dfn[d] || ed[ptr] < max_dfn[d])
            ptr = fa[ptr];
        ans[d] = ptr;
    }
}
```

---
处理用时：88.77秒
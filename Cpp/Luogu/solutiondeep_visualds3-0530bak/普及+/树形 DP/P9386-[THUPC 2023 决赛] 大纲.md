# 题目信息

# [THUPC 2023 决赛] 大纲

## 题目描述

小 I、小 O 和小 N 是 ION 大纲的编写者，小 I 负责给每个知识点定难度。

ION 大纲计划列入 $n$ 个知识点，其中小 I 按照自己的认识给其中部分知识点定好了难度，还有部分知识点没有定难度。

知识点之间有依赖关系，这个依赖关系恰好构成了一棵以 $1$ 为根的外向树，知识点 $x$ 指向知识点 $y$ 表示 $x$ 依赖 $y$。**依赖关系不具有传递性。**

你需要告诉小 I 目前确定下来的难度是否合理。我们认为确定下来的难度是合理的当且仅当存在一个给所有未确定难度的知识点确定难度的方式，使得以下所有条件成立：

- 每个知识点的难度都是非负整数；
- 对于每个依赖其他知识点的知识点 $x$，设 $\max_x$ 为 $x$ 依赖的知识点中难度的最大值，则如果 $x$ 恰依赖一个难度为 $\max_x$ 的知识点，那么知识点 $x$ 的难度为 $\max_x$，否则为 $\max_x+1$。**对于不依赖其他知识点的知识点，没有其他限制。**

## 说明/提示

### 样例 1 解释

对于第一组测试数据，将知识点 $2$ 的难度定为 $0$ 即满足条件。

对于第二组测试数据，无论如何指定知识点 $2$ 的难度，知识点 $1$ 的难度会产生矛盾。

### 数据规模与约定

对于所有测试数据，$1 \le T \le 10^5$，$2 \le n \le 10^5$，$-1 \le a_i \le 10^9$，$1 \le u,v \le n$。  
保证单个测试点中所有测试数据的 $n$ 的和不超过 $2 \times 10^5$，每组测试数据输入的所有边构成一棵以 $1$ 为根的外向树。

### 后记

大纲发表了。若干天后，小 I 给 ION 比赛投题，却发现有人偷偷改了一笔难度表，导致他的题目超纲。于是小 I 只能把题投给 CPUHT。

### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023> 查看。

## 样例 #1

### 输入

```
2
3
0 -1 0
1 2
2 3
3
0 -1 0
1 2
1 3
```

### 输出

```
Reasonable
Unreasonable
```

# AI分析结果



**唯一算法分类**  
树形动态规划（树形DP）

---

**题解思路、算法要点与解决难点**  
- **核心思路**：自底向上遍历树，维护每个节点的难度上下界，验证已确定的难度是否在可行范围内。  
- **解决难点**：  
  1. **子节点最大值统计**：需统计子节点中的最大难度及出现次数，确定当前节点的难度。  
  2. **上下界维护**：未确定的节点需动态调整其上下界，确保父节点满足条件。  
  3. **条件判断**：若当前节点已确定难度，需检查是否超出子节点推导的范围。  

---

**题解评分 (≥4星)**  
1. **Larryyu (4星)**  
   - 清晰维护上下界，逻辑严谨。  
   - 代码结构简洁，关键注释到位。  
2. **y_kx_b (4星)**  
   - 采用树形DP，记录未定状态的`flag`变量巧妙处理不确定性。  
   - 代码简洁，边界处理明确。  
3. **船酱魔王 (4星)**  
   - 维护最小/最大范围`l`和`r`，直观易理解。  
   - 处理多子节点情况的逻辑清晰。  

---

**最优思路或技巧提炼**  
1. **自底向上遍历**：通过DFS递归处理子节点，再推导父节点状态。  
2. **动态维护上下界**：  
   - 未确定的节点允许范围`[0, INF]`。  
   - 父节点难度由子节点最大值及出现次数决定，若多次出现最大值则+1。  
3. **冲突检测**：对于已确定难度的节点，若超出子节点推导的范围则直接判定无解。  

---

**同类型题或类似算法套路**  
- **树形约束问题**：如[CF1092F Tree with Maximum Cost](https://codeforces.com/problemset/problem/1092/F)中的树形DP统计。  
- **依赖关系验证**：如判断拓扑序是否满足特定条件。  

---

**推荐题目**  
1. [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)  
2. [CF767C Garland](https://codeforces.com/problemset/problem/767/C)  
3. [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)  

---

**个人心得摘录**  
- **调试教训**：未正确处理子节点最大值出现次数的边界条件，导致多次WA。  
- **顿悟点**：父节点难度仅由子节点的最大值决定，与子树结构无关。  

---

**可视化与算法演示**  
**核心算法流程动画设计**：  
1. **树结构展示**：以根节点为起点，逐步展开子树，每个节点显示当前难度或范围。  
2. **DFS过程高亮**：当前处理的节点用红色边框标记，子节点计算完成后变绿。  
3. **上下界更新**：动态显示`max`和`cnt`的变化，若出现`cnt>1`则添加`+1`动画。  
4. **冲突提示**：当已确定难度超出范围时，节点闪烁红色并播放失败音效。  

**复古游戏化设计**：  
- **像素风格**：节点用16x16像素方块表示，难度数字以8位字体显示。  
- **音效设计**：  
  - 计算成功：短促“滴”声。  
  - 冲突发生：低沉“哔”声。  
- **自动演示模式**：按DFS顺序自动处理节点，速度可调。  

```javascript
// 示例：Canvas绘制树节点（伪代码）
function drawNode(x, y, value, isConflict) {
  ctx.fillStyle = isConflict ? '#FF0000' : '#00FF00';
  ctx.fillRect(x, y, 16, 16);
  ctx.fillStyle = '#000000';
  ctx.fillText(value, x + 2, y + 12);
}
```

---

**核心代码实现**  
以Larryyu的代码为例，关键DFS逻辑：  
```cpp
bool dfs(int x, int fax) {
  int maxn = -10, cnt = 0, maxx = -10;
  // 遍历子节点计算maxn和maxx
  for (int i = head[x]; i; i = e[i].next) {
    int y = e[i].to;
    if (!dfs(y, x)) return false;
    if (b[y] > maxn) { ... } // 更新maxn和cnt
    maxx = max(maxx, u[y]);
  }
  maxn += (cnt > 1); // 调整maxn
  // 检查当前节点是否合法
  if (a[x] != -1) {
    if (a[x] < maxn) return false;
    else if (a[x] <= maxx) return true;
  } else {
    u[x] = maxx; b[x] = maxn; // 更新上下界
  }
  return true;
}
```

---
处理用时：85.53秒
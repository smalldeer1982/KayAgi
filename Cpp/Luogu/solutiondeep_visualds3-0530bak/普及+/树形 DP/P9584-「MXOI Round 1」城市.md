# 题目信息

# 「MXOI Round 1」城市

## 题目描述

小 C 是 F 国的总统，尽管这个国家仅存在于网络游戏中，但他确实是这个国家的总统。

F 国由 $n$ 个城市构成，这 $n$ 个城市之间由 $n-1$ 条双向道路互相连接。保证从任意一个城市出发，都能通过这 $n-1$ 条双向道路，到达任意一个城市。

当然，通过这些双向道路是要收费的。通过第 $i$ 条双向道路，需要花费 $c_i$ 元。我们称 $c_i$ 为第 $i$ 条双向道路的费用。

我们定义 $cost(x,y)$ 表示从城市 $x$ 到城市 $y$ 的简单路径上，所有经过的双向道路的费用之和。特殊地，当 $x=y$ 时，$cost(x,y)=0$。

为了促进 F 国发展，小 C 新建了一个城市 $n+1$。现在他需要再新建一条双向道路，使得城市 $n+1$ 也可以通过这 $n$ 条双向道路到达任意一个城市。

他共有 $q$ 个新建道路的方案，每个方案会给定两个参数 $k_i,w_i$；对于每一个方案，你需要求出在新建一条连接城市 $k_i$ 和城市 $n+1$ 且费用为 $w_i$ 的双向道路后，所有 $cost(i,j)$ 之和，即 $\sum\limits_{i=1}^{n+1} \sum\limits_{j=1}^{n+1} cost(i,j)$。

由于答案可能很大，所以你只需要输出答案对 $998244353$ 取模的结果。

**方案之间相互独立**，也就是说所有方案不会影响现有的道路，这些方案不会真正被施行。

## 说明/提示

#### 【样例解释 #1】

在新建一条连接城市 $1$ 和城市 $5$ 且费用为 $2$ 的双向道路后，F 国的道路如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/j871257i.png)

例如，此时 $cost(4,5)=9$，$cost(1,3)=5$。

容易求得此时 $\sum\limits_{i=1}^{n+1} \sum\limits_{j=1}^{n+1} cost(i,j)=100$。

#### 【样例 #3】

见附加文件中的 `city/city3.in` 与 `city/city3.ans`。

该样例满足测试点 $4$ 的限制。

#### 【样例 #4】

见附加文件中的 `city/city4.in` 与 `city/city4.ans`。

该样例满足测试点 $11$ 的限制。

#### 【样例 #5】

见附加文件中的 `city/city5.in` 与 `city/city5.ans`。

该样例满足测试点 $14$ 的限制。

#### 【样例 #6】

见附加文件中的 `city/city6.in` 与 `city/city6.ans`。

该样例满足测试点 $20$ 的限制。

#### 【数据范围】

对于 $100\%$ 的数据，$2 \le n \le 2\times10^5$，$1 \le q \le 2\times10^5$，$1 \le u_i,v_i,k_i \le n$，$1 \le c_i,w_i \le 10^6$，保证从任意一个城市出发，都能通过原本存在的 $n-1$ 条双向道路，到达任意一个城市。

|测试点编号|$n \le$|$q \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1\sim3$|$80$|$80$|无|
|$4\sim7$|$5000$|$5000$|无|
|$8\sim10$|$5000$|$2\times10^5$|无|
|$11\sim13$|$2\times10^5$|$2\times10^5$|A|
|$14\sim16$|$2\times10^5$|$2\times10^5$|B|
|$17\sim20$|$2\times10^5$|$2\times10^5$|无|

特殊性质 A：保证对于所有的 $1 \le i \lt n$，都有 $u_i=i,v_i=i+1$。

特殊性质 B：保证对于所有的 $1 \le i \le q$，都有 $k_i=1$。

## 样例 #1

### 输入

```
4 2
2 1 3
3 2 2
4 2 4
1 2
2 2```

### 输出

```
100
88```

## 样例 #2

### 输入

```
9 5
2 3 6
6 1 4
5 2 10
2 4 1
9 1 9
2 8 3
1 2 3
7 4 8
4 9
7 3
6 1
9 7
2 1
```

### 输出

```
1050
1054
970
1148
896```

# AI分析结果



# 【算法分类】
换根DP

# 【题解思路与解决难点】

## 核心思路
1. **预处理原有树结构贡献**  
   - 通过两次DFS（常规DFS+换根DFS）预处理每个节点到所有其他节点的距离和
   - 计算原始树中所有点对的路径和作为基础值

2. **快速处理新增节点**  
   - 新增节点n+1到所有节点的距离 = 连接点k到其他节点的距离和 + n倍新边权
   - 利用预处理结果O(1)计算新增贡献

## 关键难点解决
- **路径贡献快速计算**：通过换根DP将每个节点到全树的距离和从O(n²)优化到O(n)预处理
- **动态更新影响范围**：新增节点仅影响连接点k的路径，利用预存的距离和避免重复计算
- **取模优化**：在状态转移过程中及时取模防止溢出

# 【题解评分（≥4星）】

1. **iiiiiyang（5星）**
   - 思路清晰，代码极简（仅两次DFS）
   - 核心公式`f[v] = f[u] + w*(n-2*siz[v])`直击换根本质
   - 实现中巧妙处理负数取模

2. **Night_sea_64（4星）**
   - 完整展示换根DP推导过程
   - 提供详细样例分析帮助理解
   - 代码注释明确，适合教学

3. **Wf_yjqd（4星）**
   - 严格定义f/g数组含义
   - 通过子树内外贡献分离实现高效计算
   - 包含调试经验（负数取模教训）

# 【最优思路提炼】

1. **两次DFS换根法**  
   - **第一次DFS**：计算子树大小siz[u]和初始距离和f[u]
   ```cpp
   void dfs1(int u, int fa) {
       siz[u] = 1;
       for (auto [v,w] : G[u]) 
           if (v != fa) {
               dfs1(v, u);
               siz[u] += siz[v];
               f[u] += f[v] + w * siz[v];
           }
   }
   ```
   - **第二次DFS**：通过父节点更新子节点距离和
   ```cpp
   void dfs2(int u, int fa) {
       for (auto [v,w] : G[u])
           if (v != fa) {
               f[v] = f[u] + w * (n - 2*siz[v]);
               dfs2(v, u);
           }
   }
   ```

2. **贡献快速计算公式**  
   - 新增边贡献：`ans += 2*(f[k] + n*w)`
   - 利用预处理的Σf[i]作为基础值

# 【相似题目推荐】

1. **P3478 [POI2008] STA-Station**  
   - 换根DP经典题，求最大深度和

2. **P2986 [USACO10MAR] Great Cow Gathering G**  
   - 带权换根DP，处理边权影响

3. **P3047 [USACO12FEB] Nearby Cows G**  
   - 树形DP进阶，结合换根与距离限制

# 【可视化设计】

## 动画方案
1. **树结构展示**  
   - 初始树用Canvas绘制，节点按层序排列
   - 边权以不同颜色梯度表示（暖色=高权值）

2. **换根过程演示**  
   - 当前处理节点高亮黄色边框
   - 子树范围用半透明绿色覆盖
   - 状态转移时显示公式浮层：  
     `f[v] = f[u] + w*(n-2*siz[v])`

3. **新增节点特效**  
   - 新节点n+1以闪烁红星显示
   - 连接边用红色虚线动画绘制
   - 受影响路径显示波纹扩散效果

## 复古游戏化要素
1. **8-bit音效**  
   - 节点选中：FC风格"滴"声（三角波）
   - 换根完成：马里奥金币音效
   - 错误操作：恶魔城受伤音效

2. **像素艺术**  
   - 节点用16x16像素精灵表示
   - 树结构背景使用NES风格的绿色网格

3. **自动演示模式**  
   - AI控制DFS遍历路径，显示虚拟"指针"移动
   - 按SELECT键切换手动/自动模式

# 【核心代码实现】

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 2e5+5, mod = 998244353;

vector<pair<int,int>> G[N];
ll n, q, siz[N], f[N], total;

void dfs1(int u, int fa) {
    siz[u] = 1;
    for (auto [v, w] : G[u]) if (v != fa) {
        dfs1(v, u);
        siz[u] += siz[v];
        f[u] = (f[u] + f[v] + w * siz[v]) % mod;
    }
}

void dfs2(int u, int fa) {
    for (auto [v, w] : G[u]) if (v != fa) {
        f[v] = (f[u] + w * (n - 2*siz[v]) % mod + mod) % mod;
        dfs2(v, u);
    }
}

int main() {
    cin >> n >> q;
    for (int i=1; i<n; ++i) {
        int u, v, w; cin >> u >> v >> w;
        G[u].emplace_back(v, w);
        G[v].emplace_back(u, w);
    }
    
    dfs1(1, 0);
    dfs2(1, 0);
    
    for (int i=1; i<=n; ++i) 
        total = (total + f[i]) % mod;
    
    while (q--) {
        int k, w; cin >> k >> w;
        ll add = (f[k] + n*w % mod) * 2 % mod;
        cout << (total + add) % mod << '\n';
    }
}
```

**代码要点说明**：
- `dfs1`计算初始子树大小和距离和
- `dfs2`通过父节点更新所有节点的全局距离和
- 总答案=预存总和+2*(连接点距离和+新边贡献)

---
处理用时：103.87秒
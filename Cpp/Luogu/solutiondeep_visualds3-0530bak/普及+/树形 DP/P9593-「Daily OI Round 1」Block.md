# 题目信息

# 「Daily OI Round 1」Block

## 题目描述

给定一棵树，节点有颜色，在树上距离为 $2$ 的点连边（仍保留原来的边），求新图中颜色相同且连通的非空点集数量。由于答案可能非常大，您只需输出答案对 $10^9+7$ 取模的值。

点集连通的定义：对于图 $G(V,E)$，$V$ 的一个子集 $V'$ 是连通点集，当且仅当 $G(V',E')$ 是一个连通图，其中边集 $E'=\{(u,v)|(u,v)\in E\land u \in V'\land v\in V'\}$。

## 说明/提示

样例 1 中，原树如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/zmgrnwkh.png)

树上距离为 $2$ 的点连边后，新图如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/id3xc54a.png)

则 $8$ 个颜色相同且连通的非空点集分别是：$\{1\},\{2\},\{3\},\{4\},\{1,3\},\{1,4\},\{3,4\},\{1,3,4\}$。

**本题开启捆绑测试。**



|$\text{Subtask}$|分值|$n \le$| 特殊性质 | 子任务依赖 |
| :-----------: | :-------------:|:-----------: |:-----------: |:-----------: |
|$0$|$5$|$10^5$| A | 无 |
|$1$|$5$|$16$| 无 | 无 |
|$2$|$5$|$10^5$| B | 无 |
|$3$|$15$|$10^5$| C | 无 |
|$4$|$20$|$10^5$| D | 无 |
|$5$|$50$|$10^5$| 无 | $0\sim4$ |

- 特殊性质 A：所有节点的颜色不相同。
- 特殊性质 B：给出的树是菊花，具体地，第 $i$ 条边连接节点 $1$ 和节点 $i+1$。
- 特殊性质 C：给出的树是链，具体地，第 $i$ 条边连接节点 $i$ 和节点 $i+1$。
- 特殊性质 D：所有节点的颜色相同。


对于全部数据，满足 $2\leq n\leq 10^5$，$1\leq c_i\leq n$。

## 样例 #1

### 输入

```
4
1 2 1 1
1 2
2 3
2 4
```

### 输出

```
8```

## 样例 #2

### 输入

```
6
1 2 2 2 1 2
5 3
2 1
4 5
6 3
3 1
```

### 输出

```
14```

## 样例 #3

### 输入

```
16
1 1 2 1 1 2 2 2 1 1 2 1 1 1 2 1
12 8
14 9
10 8
1 16
7 12
6 1
14 8
3 1
12 5
1 13
12 2
1 12
15 8
11 5
4 12
```

### 输出

```
442```

## 样例 #4

### 输入

```
16
11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11
4 14
4 15
12 13
2 5
7 15
10 2
15 8
15 13
9 11
13 11
3 15
8 16
6 13
1 4
10 4```

### 输出

```
27454```

## 样例 #5

### 输入

```
9
3 3 2 3 2 4 2 3 3
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9```

### 输出

```
16```

# AI分析结果



---

### **唯一算法分类**  
树形动态规划（Tree DP）

---

### **综合分析与结论**  
**核心思路**：通过树形 DP 统计每个子树内的连通方案数。  
- **关键点**：  
  1. **颜色约束**：仅允许颜色相同的节点连通。  
  2. **距离约束**：原树中距离为 2 的节点在新图中直接相连，因此在子树中需考虑「跳过子节点直接选孙子」的情况。  
  3. **连通性计算**：通过乘法原理组合子树方案，并处理不选当前节点的多子树组合情况。  

**算法流程**：  
1. **状态定义**：  
   - `f[u]`：以 `u` 为根的子树中必须选 `u` 的方案数。  
   - `g[c]`：临时存储颜色为 `c` 的子树的乘积贡献，用于统计不选当前节点的多子树方案。  
2. **转移方程**：  
   - 选子节点 `v`：若 `c[v] == c[u]`，贡献为 `f[v]`。  
   - 跳过子节点 `v`：贡献为所有孙子节点 `w`（满足 `c[w] == c[u]`）的 `f[w]+1` 的乘积。  
   - 最终 `f[u] = ∏ (子树的贡献)`。  
3. **答案统计**：  
   - 全局答案累加所有 `f[u]`（选当前节点的情况）。  
   - 利用 `g[c]` 统计不选当前节点但选多个同色子树的组合数，公式为 `∏(f[v]+1) - ∑f[v] - 1`。  

**可视化设计**：  
- **动画效果**：  
  1. **树结构展示**：用 Canvas 绘制树形结构，节点颜色标记不同 `c[u]`。  
  2. **DP 过程高亮**：当前处理节点 `u` 高亮为红色，子节点 `v` 高亮为蓝色，孙子节点 `w` 高亮为绿色。  
  3. **数值更新**：实时显示 `f[u]` 的乘积计算过程，并在节点旁标注当前值。  
  4. **音效触发**：完成一个节点的 `f[u]` 计算时播放“滴”声，全局答案更新时播放上扬音效。  
- **复古风格**：  
  1. **8-bit 调色板**：固定 16 种颜色，节点用纯色方块表示。  
  2. **网格布局**：按树形层次自动排列节点，父子节点通过像素线条连接。  
  3. **自动演示模式**：模拟“贪吃蛇 AI”路径遍历树节点，自动执行 DFS 并更新状态。  

---

### **题解清单 (≥4星)**  
1. **teylnol_evteyl（5星）**  
   - **亮点**：  
     - 状态设计简洁，仅用 `f[u]` 和临时 `g[c]`。  
     - 通过遍历子节点时动态维护 `g[c]`，避免复杂哈希操作。  
     - 代码逻辑清晰，递归结构易于理解。  
   - **代码片段**：  
     ```cpp  
     void dp(int u, int fa) {
         f[u] = 1;
         for (int v : son[u]) if (v != fa) {
             dp(v, u);
             LL t = (c[v] == c[u]) ? f[v] : 0;
             LL skip = 1;
             for (int w : son[v]) if (w != u && c[w] == c[u]) 
                 skip = skip * (f[w] + 1) % P;
             f[u] = f[u] * (t + skip) % P;
         }
     }
     ```  

2. **by_chance（4星）**  
   - **亮点**：  
     - 使用颜色分类乘积 `g[c]` 直接统计不选当前节点的贡献。  
     - 代码短小精悍，利用全局数组 `g` 减少内存开销。  
   - **代码片段**：  
     ```cpp  
     for (int v : son[u]) if (v != fa) {
         g[c[v]] = g[c[v]] * (dp[v] + 1) % MOD;
     }
     ans += (g[c] - 1);  // 统计不选u的贡献  
     ```  

3. **一只绝帆（4星）**  
   - **亮点**：  
     - 显式处理 `g[x]` 的至少两个子树组合，公式推导严谨。  
     - 动态清零 `g[c]` 避免跨子树干扰，代码鲁棒性高。  
   - **心得摘录**：  
     > “统计不选当前节点的方案时，必须及时清零 `g[c]`，否则不同子树间的颜色会互相污染。”  

---

### **最优思路或技巧提炼**  
1. **双路径选择**：处理子节点时，同时考虑「直接选子节点」和「跳过子节点选孙子」两种路径，通过乘积组合方案数。  
2. **颜色分组统计**：利用哈希或数组按颜色分组，快速计算多子树组合数。  
3. **全局答案累加**：在递归回溯时动态更新全局答案，避免二次遍历。  

---

### **同类型题或类似算法套路**  
- **树形 DP + 颜色约束**：如统计子树中颜色相同的路径数（[CF911F Tree Destruction](https://codeforces.com/problemset/problem/911/F)）。  
- **连通块计数**：如求满足特定连通条件的子图数目（[洛谷 P4516 潜入行动](https://www.luogu.com.cn/problem/P4516)）。  

---

### **推荐相似题目**  
1. [P1351 联合权值](https://www.luogu.com.cn/problem/P1351)  
2. [CF980E The Number of Subsequences](https://codeforces.com/problemset/problem/980/E)  
3. [ABC248G GCD cost on the tree](https://atcoder.jp/contests/abc248/tasks/abc248_g)  

---

### **个人心得摘录**  
> “处理树形 DP 时，若状态转移涉及多级子树（如同时考虑子节点和孙子节点），应先递归处理子节点，再在回溯时计算当前节点的贡献。” —— teylnol_evteyl  

---

### **可视化与算法演示**  
**核心代码逻辑动画**：  
```javascript  
// 伪代码：DFS 遍历并更新状态  
function dfs(u, parent) {
    highlight(u, 'red'); // 高亮当前节点
    f[u] = 1;
    for (let v of tree[u]) {
        if (v === parent) continue;
        dfs(v, u); // 递归处理子节点
        highlight(v, 'blue'); // 子节点高亮
        let skip = 1;
        for (let w of tree[v]) {
            if (w === u || c[w] !== c[u]) continue;
            highlight(w, 'green'); // 孙子节点高亮
            skip *= (f[w] + 1);
            playSound('click'); // 每次乘法触发音效
        }
        f[u] *= (c[v] === c[u] ? f[v] : 0) + skip;
    }
    updateAnswer(f[u]); // 全局答案累加
}
```  

**复古游戏化设计**：  
- **颜色方案**：固定 8 色调色板，如 `#FF0000`（红）、`#0000FF`（蓝）、`#00FF00`（绿）。  
- **自动演示**：模拟 DFS 遍历，节点按层次逐步点亮，伴随 8-bit 背景音乐。  
- **积分系统**：每正确计算一个 `f[u]` 得 10 分，错误操作扣 5 分。  

---

**答案生成结束**

---
处理用时：110.91秒
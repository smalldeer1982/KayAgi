# 题目信息

# [NOIP 2009 提高组] Hankson 的趣味题

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。

今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：

1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；

2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。

Hankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。


## 说明/提示

**【样例解释】**

第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。

第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。

**【数据范围】**

- 对于 $50\%$ 的数据，保证有 $1\leq a_0,a_1,b_0,b_1 \leq 10000$ 且 $n \leq 100$。
- 对于 $100\%$ 的数据，保证有 $1 \leq a_0,a_1,b_0,b_1 \leq 2 \times 10^9$ 且 $n≤2000$。

NOIP 2009 提高组 第二题


## 样例 #1

### 输入

```
2 
41 1 96 288 
95 1 37 1776 ```

### 输出

```
6 
2```

# AI分析结果



### 算法分类
**数学优化枚举**

---

### 题解思路与难点分析
#### 核心思路
1. **因数枚举**：x 必须是 b₁ 的因数，通过枚举 b₁ 的因数减少候选范围，复杂度从 O(b₁) 降为 O(√b₁)。
2. **条件检查**：对每个因数 x，验证两个条件：
   - gcd(x, a₀) = a₁
   - lcm(x, b₀) = b₁（通过 x * b₀ / gcd(x, b₀) 计算）
3. **去重处理**：避免重复计数平方数，如当 x = b₁/x 时仅计数一次。

#### 解决难点
- **因数高效枚举**：通过遍历 1 到 √b₁ 快速获取所有因数对。
- **数学性质应用**：利用 gcd 和 lcm 的数学关系快速排除无效候选。
- **边界条件处理**：如 a₁ 不整除 a₀ 或 b₁ 不整除 b₀ 时直接返回 0。

---

### 题解评分（≥4星）
1. **zzlzk（5星）**  
   - 思路清晰，代码简洁，直接枚举因数并检查条件。
   - 关键代码片段高效去重，适合快速理解实现。
2. **KesdiaelKen（4星）**  
   - 数学推导深入，通过分解质因数进一步优化枚举次数。
   - 代码稍复杂但理论复杂度更低，适合高阶选手。
3. **Cold_Eyes_bystander（4星）**  
   - 结构清晰，注释详细，适合新手逐步调试学习。
   - 包含完整条件检查与去重逻辑。

---

### 最优思路提炼
1. **因数对枚举**：遍历 i ∈ [1, √b₁]，若 i 是因数，则检查 i 和 b₁/i。
2. **数学条件剪枝**：
   - 提前判断 a₁ 是否整除 a₀ 和 b₁ 是否整除 b₀。
   - 利用 gcd(x, a₀) = a₁ 推导出 x 必须是 a₁ 的倍数。
3. **去重优化**：仅当 i² ≠ b₁ 时检查另一因数。

---

### 相似题目推荐
1. **P1029 最大公约数和最小公倍数问题**  
   （类似的双条件因数枚举问题）
2. **P1414 又是毕业季II**  
   （多数的最大公约数分解与因数分析）
3. **P2441 角色属性**  
   （基于因数与数学性质的动态规划）

---

### 关键代码实现
```cpp
#include <cstdio>
using namespace std;

int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}

int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        int a0, a1, b0, b1, ans = 0;
        scanf("%d%d%d%d", &a0, &a1, &b0, &b1);
        for (int x = 1; x * x <= b1; x++) {
            if (b1 % x != 0) continue;
            // 检查当前因数 x
            if (x % a1 == 0 && gcd(x / a1, a0 / a1) == 1 && gcd(b1 / x, b0) == 1)
                ans++;
            int y = b1 / x;
            if (x != y && y % a1 == 0 && gcd(y / a1, a0 / a1) == 1 && gcd(b1 / y, b0) == 1)
                ans++;
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

---

### 可视化与动画设计
**复古像素风格算法演示**  
1. **界面设计**：  
   - 8-bit 风格网格，每个方块代表一个候选因数。
   - 当前枚举的因数 i 高亮为蓝色，检查通过后变为绿色，失败则为红色。
2. **动画流程**：  
   - **步进枚举**：逐个显示 i 从 1 到 √b₁ 的移动，显示因数分解结果。
   - **条件检查**：分步展示 gcd(x, a₀) 和 lcm(x, b₀) 的计算过程。
   - **音效反馈**：成功时播放上升音调，失败时短促低音，背景为循环芯片音乐。
3. **交互控制**：  
   - 速度滑块调节枚举步频。
   - 单步执行按钮观察详细计算步骤。

---

### 个人心得摘录
> **调试经历**：  
> “在质因数分解时，未处理剩余的大质数导致 WA，加上特判后通过。”  
> **优化技巧**：  
> “提前返回无效情况（如 a₁ 不整除 a₀）减少 80% 的枚举量。”  
> **思维突破**：  
> “意识到 x 必须同时是 a₁ 的倍数和 b₁ 的因数，结合二者大幅剪枝。”

---
处理用时：78.98秒
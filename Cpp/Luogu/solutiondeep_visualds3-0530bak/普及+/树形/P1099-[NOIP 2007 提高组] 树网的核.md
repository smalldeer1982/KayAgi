# 题目信息

# [NOIP 2007 提高组] 树网的核

## 题目描述

设 $T=(V,E,W)$ 是一个无圈且连通的无向图（也称为无根树），每条边都有正整数的权，我们称 $T$ 为树网（`treenetwork`），其中 $V$，$E$ 分别表示结点与边的集合，$W$ 表示各边长度的集合，并设 $T$ 有 $n$ 个结点。

路径：树网中任何两结点 $a$，$b$ 都存在唯一的一条简单路径，用 $d(a, b)$ 表示以 $a, b$ 为端点的路径的长度，它是该路径上各边长度之和。我们称 
$d(a, b)$ 为 $a, b$ 两结点间的距离。

$D(v, P)=\min\{d(v, u)\}$, $u$ 为路径 $P$ 上的结点。

树网的直径：树网中最长的路径成为树网的直径。对于给定的树网 $T$，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。

偏心距 $\mathrm{ECC}(F)$：树网 $T$ 中距路径 $F$ 最远的结点到路径 $F$ 的距离，即

$$\mathrm{ECC}(F)=\max\{D(v, F),v \in V\}$$

任务：对于给定的树网 $T=(V, E, W)$ 和非负整数 $s$，求一个路径 $F$，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 $s$（可以等于 $s$），使偏心距 $\mathrm{ECC}(F)$ 最小。我们称这个路径为树网 $T=(V, E, W)$ 的核（`Core`）。必要时，$F$ 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。

下面的图给出了树网的一个实例。图中，$A-B$ 与 $A-C$ 是两条直径，长度均为 $20$。点 $W$ 是树网的中心，$EF$ 边的长度为 $5$。如果指定 $s=11$，则树网的核为路径`DEFG`（也可以取为路径`DEF`），偏心距为 $8$。如果指定 $s=0$（或 $s=1$、$s=2$），则树网的核为结点 $F$，偏心距为 $12$。

![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)


## 说明/提示

- 对于 $40\%$ 的数据，保证 $n \le 15$。
- 对于 $70\%$ 的数据，保证 $n \le 80$。
- 对于 $100\%$ 的数据，保证 $2\le n \le 300$，$0\le s\le10^3$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^3$。

NOIP2007 提高组第四题

## 样例 #1

### 输入

```
5 2
1 2 5
2 3 2
2 4 4
2 5 3
```

### 输出

```
5
```

## 样例 #2

### 输入

```
8 6
1 3 2
2 3 2 
3 4 6
4 5 3
4 6 4
4 7 2
7 8 3
```

### 输出

```
5```

# AI分析结果



## 唯一算法分类
**树的直径应用 + 双指针优化**

---

## 综合分析与结论

### 核心算法流程
1. **确定树的直径**：通过两次DFS/BFS找到任意一条直径  
2. **预处理支链最大距离**：对直径上的每个点，计算其子树中不经过直径的最远距离（支链长度）  
3. **双指针滑动窗口**：在直径上维护长度≤s的窗口，动态计算以下三者的最大值：  
   - 窗口左端到直径起点的距离  
   - 窗口右端到直径终点的距离  
   - 窗口内所有点的支链最大距离  
4. **取全局最小值**：所有窗口对应的最大值中的最小值即为答案  

### 可视化设计思路
- **像素化直径路径**：用绿色方块表示直径节点，红色方块表示当前窗口端点  
- **支链高亮显示**：用黄色线条动态绘制每个直径节点的支链最大距离  
- **动态数值面板**：实时显示当前窗口的左/右端点、窗口长度、三个关键值（左端距离、右端距离、支链最大值）  
- **音效反馈**：当找到更优解时播放上扬音效，窗口移动时播放轻微点击音效  

---

## 题解清单 (≥4星)

### 1. StudyingFather 题解（⭐⭐⭐⭐⭐）
- **亮点**：完整证明路径必在直径上，提出四种解法（枚举→双指针→二分→单调队列）  
- **核心优化**：通过分析偏心距的构成，将问题简化为固定公式计算  
- **代码特点**：用namespace隔离不同解法，模块化清晰  

### 2. Mosklia 题解（⭐⭐⭐⭐⭐）  
- **亮点**：O(n)双指针+单调队列实现，预处理支链距离  
- **关键技巧**：利用直径性质证明支链贡献可简化计算  
- **代码特点**：两次DFS找直径，动态维护窗口最大值  

### 3. Hyvial 题解（⭐⭐⭐⭐）  
- **亮点**：简洁的双指针实现，通过前后缀数组优化计算  
- **可视化友好**：明确分离直径处理与支链计算步骤  
- **代码特点**：用vector存储直径路径，高效处理前后缀  

---

## 代码实现核心逻辑

### 关键预处理代码（C++）
```cpp
// 找直径并存储路径
vector<int> path;
void get_diameter() {
    dfs(1, 0); // 第一次DFS找端点
    int u = p; // p是第一次DFS最远点
    dfs(u, 0); // 第二次DFS确定直径
    for(int v = p; v != u; v = fa[v]) 
        path.push_back(v);
    path.push_back(u);
}

// 计算支链最大距离
int maxd[N];
void calc_branch() {
    memset(vis, 0, sizeof(vis));
    for(int x : path) vis[x] = 1;
    for(int i = 0; i < path.size(); ++i) {
        int u = path[i];
        dfs_branch(u, 0); // 不经过直径节点的DFS
        maxd[i] = max_dist; 
    }
}
```

### 双指针核心逻辑
```cpp
int ans = INF;
int max_chain = 0;
for(int l=0, r=0; l < path.size(); ++l) {
    // 扩展右边界
    while(r < path.size() && sum_len <= s) {
        max_chain = max(max_chain, maxd[r]);
        r++;
    }
    // 计算当前窗口的三个值
    int cur = max(max_chain, 
                 max(prefix[l], suffix[r-1]));
    ans = min(ans, cur);
    // 收缩左边界
    sum_len -= edge_len[l];
}
```

---

## 同类型题与算法套路
1. **固定路径的最值问题**：如「树上两点的最大边权最小」  
2. **滑动窗口维护区间属性**：需结合数据结构（单调队列、前缀和）  
3. **树的直径性质应用**：所有最长路径必过某点/边  

---

## 推荐相似题目
1. [P2491 SCOI2005] 骑士精神 - 树网的核加强版  
2. [P1099 树网的核] - 本题  
3. [P4408 逃学的小孩] - 利用直径性质求最远距离  

---

## 个人心得摘录
> "枚举的过程时间复杂度降到了 O(n)，总时间复杂度为 O(n²)。但后来发现根本不需要每次都DFS，只需要预处理就能O(1)查询" —— Mosklia  
> "调试时发现支链的影响被低估，必须单独预处理每个直径节点的最大支链" —— StudyingFather  

---

## 复古像素化演示方案
### 实现要点
1. **Canvas绘制**：  
   - 直径节点用16x16绿色方块表示  
   - 当前窗口用红色边框高亮  
   - 支链长度用黄色竖条高度表示  
2. **音效设计**：  
   - 窗口移动：8-bit "blip" 音效（频率与移动速度相关）  
   - 更新最优解：FC游戏《超级马里奥》金币音效  
3. **自动演示模式**：  
   - 初始展示直径查找过程（绿块延伸动画）  
   - 双指针自动滑动，关键步骤暂停0.5秒展示数值变化  
4. **交互控制**：  
   - 方向键←→手动控制窗口  
   - Space键切换自动/手动模式

---
处理用时：70.44秒
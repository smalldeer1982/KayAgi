# 题目信息

# 走迷宫

## 题目描述

有一个 $m\times n$ 格的迷宫(表示有 $m$ 行、$n$ 列)，其中有可走的也有不可走的，如果用 $1$ 表示可以走，$0$ 表示不可以走，文件读入这 $m\times n$ 个数据和起始点、结束点（起始点和结束点都是用两个数据来描述的，分别表示这个点的行号和列号）。现在要你编程找出所有可行的道路，要求所走的路中没有重复的点，走时只能是上下左右四个方向。如果一条路都不可行，则输出相应信息（用 $-1$ 表示无路）。

优先顺序：左上右下。**数据保证随机生成。**


## 说明/提示

数据保证随机生成。事实上，如果 $n=m=14$ 且每个位置都是 $1$ 的话，有 $69450664761521361664274701548907358996488$ 种路径。

## 样例 #1

### 输入

```
5 6
1 0 0 1 0 1
1 1 1 1 1 1
0 0 1 1 1 0
1 1 1 1 1 0
1 1 1 0 1 1
1 1
5 6```

### 输出

```
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)```

# AI分析结果



### 算法分类
DFS（深度优先搜索）

### 题解思路与核心难点
**核心逻辑**：DFS + 回溯 + 路径记录  
- **方向处理**：按照左上右下（{0,-1},{-1,0},{0,1},{1,0}）的优先级遍历  
- **路径记录**：用栈/vector/数组保存路径节点，回溯时弹出  
- **去重机制**：vis标记数组防止重复访问  
- **输出格式**：需拼接箭头分隔的坐标字符串  

**关键难点**：  
1. 方向顺序易错导致路径优先级不符  
2. 回溯时需同时恢复vis标记和路径容器  
3. 终点坐标需单独处理输出格式  

### 高星题解推荐（≥4星）
1. **题解作者：QianhanOfficial（4.5星）**  
   - 亮点：使用vector存储路径，代码简洁易读；方向处理逻辑清晰  
   - 代码片段：  
     ```cpp
     void dfs(int x, int y) {
         if(x == fx && y == fy) { print(); return; }
         for(int i=0; i<4; i++) {
             int nx = x+dir[i][0], ny = y+dir[i][1];
             if(CanMove(nx,ny)) {
                 v1.push_back(nx); v2.push_back(ny);
                 vis[nx][ny] = true;
                 dfs(nx, ny);
                 vis[nx][ny] = false;  // 回溯
                 v1.pop_back(); v2.pop_back();
             }
         }
     }
     ```

2. **题解作者：2x6_81（4星）**  
   - 亮点：用queue实现路径存储，自定义弹出逻辑  
   - 心得：通过queue.pop()处理队尾回溯  

3. **题解作者：caoshirui（4星）**  
   - 亮点：二进制压缩坐标(x<<4|y)，节省内存  
   - 代码技巧：  
     ```cpp
     #define Dir {0,-1,-16,1,16} // 左/上/右/下的坐标偏移
     void dfs(int pos) {
         if(pos == End) print();
         for(int k=0; k<4; k++) {
             int newpos = pos + Dir[k];
             if(Map[newpos]) dfs(newpos); // 直接通过位运算解码坐标
         }
     }
     ```

### 最优技巧提炼
1. **方向向量法**：用dir数组预定义方向偏移量，简化代码  
2. **路径容器选择**：vector更易管理，pop_back()天然适配回溯  
3. **坐标压缩**：对小范围坐标使用位运算（x<<4|y）优化存储  
4. **回溯三要素**：标记访问→递归→恢复现场  

### 同类题目推荐
1. **P1605**（迷宫基础模板题）  
2. **P1219**（八皇后问题，回溯经典）  
3. **P1433**（DFS+状态压缩）  

### 可视化设计
**动画方案**：  
1. **像素风格迷宫**：16x16像素格子，深灰色墙壁，亮绿色路径  
2. **当前探索点**：红色闪烁方块，移动时播放"哔"音效  
3. **回溯过程**：路径变暗，播放"咔嗒"音效  
4. **自动演示**：按DFS顺序自动探索，速度可调（快/中/慢）  

**关键代码片段**：  
```javascript
// 绘制当前路径
function drawPath(ctx, path) {
    ctx.fillStyle = "#00FF00";
    path.forEach(({x,y}) => {
        ctx.fillRect(x*16, y*16, 14, 14); 
    });
    // 绘制当前点（红色）
    let {x,y} = path[path.length-1];
    ctx.fillStyle = "#FF0000";
    ctx.fillRect(x*16, y*16, 14, 14);
}
```

### 核心代码实现
```cpp
// 基于QianhanOfficial的vector方案优化
vector<pair<int,int>> path;
void dfs(int x, int y) {
    if(x == ex && y == ey) {
        for(auto p : path) cout << "("<<p.first<<","<<p.second<<")->";
        cout << "("<<ex<<","<<ey<<")\n"; return;
    }
    for(auto [dx,dy] : {{0,-1},{-1,0},{0,1},{1,0}}) { // C++17结构化绑定
        int nx = x+dx, ny = y+dy;
        if(vis[nx][ny] || !map[nx][ny]) continue;
        vis[nx][ny] = true;
        path.emplace_back(nx, ny);
        dfs(nx, ny);
        path.pop_back();  // 回溯
        vis[nx][ny] = false;
    }
}
```

---
处理用时：60.96秒
# 题目信息

# 鬼子进村

## 题目背景

小卡正在新家的客厅中看电视。电视里正在播放放了千八百次依旧重播的《亮剑》，剧中李云龙带领的独立团在一个县城遇到了一个鬼子小队，于是独立团与鬼子展开游击战。


## 题目描述

县城里有 $n$ 个用地道相连的房子，第 $i$ 个只与第 $i-1$ 和第 $i+1$ 个相连。这时有 $m$ 个消息依次传来：

1. 若消息为 ```D x```：鬼子将 $x$ 号房子摧毁了，地道被堵上。

1. 若消息为 ```R``` ：村民们将鬼子上一个摧毁的房子修复了。

2. 若消息为 ```Q x```：有一名士兵被围堵在 $x$ 号房子中。

李云龙收到信息很紧张，他想知道每一个被围堵的士兵能够到达的房子有几个。


## 说明/提示

$1\leq n,m\leq 5\times 10^4$。

若士兵被围堵在摧毁了的房子中，那只能等死了。。。。。。

## 样例 #1

### 输入

```
7 9
D 3
D 6
D 5
Q 4
Q 5
R
Q 4
R
Q 4
```

### 输出

```
1
0
2
4
```

# AI分析结果



### 唯一算法分类
有序集合维护（STL set/平衡树）

### 题解思路与核心难点
**核心逻辑**：维护动态有序的摧毁点集合，通过二分法快速找到查询点的左右边界（前驱和后继）。  
**解决难点**：  
1. **动态维护**：插入/删除操作需高效（O(logn)）  
2. **边界处理**：需预插入 0 和 n+1 作为哨兵节点  
3. **恢复操作**：需用栈记录历史摧毁点以实现 O(1) 撤销  

### 题解评分（≥4星）
1. **66666a（5星）**  
   - 思路：STL set 维护摧毁点，利用 lower_bound 快速查询  
   - 亮点：代码极简（仅 30 行），时间复杂度 O(mlogn)  
2. **Hugo_Minion（4星）**  
   - 思路：FHQ-Treap 实现平衡树  
   - 亮点：支持动态插入/删除，前驱后继查询稳定高效  
3. **樱初音斗橡皮（4星）**  
   - 思路：替罪羊树实现平衡树  
   - 亮点：无需旋转，内存回收优化  

### 最优思路提炼
1. **哨兵边界**：预插入 0 和 n+1 避免空指针异常  
2. **二分查询**：用 `s.lower_bound(x)` 找后继，`--s.lower_bound(x)` 找前驱  
3. **差值计算**：结果 = 后继值 - 前驱值 - 1  
4. **栈辅助恢复**：每次 D 操作记录摧毁点，R 操作弹栈删除  

### 同类型题推荐
1. P2146 [NOI2015] 软件包管理器（树链操作）  
2. P3380 【模板】二逼平衡树（多操作平衡树）  
3. P1908 逆序对（动态维护有序性）  

---

### 可视化设计（STL set 版本）
**动画流程**：  
1. **摧毁操作**：插入红点并压栈，显示集合变化  
2. **恢复操作**：弹出红点变绿，集合中删除该点  
3. **查询操作**：高亮前驱（蓝）和后继（黄），标出区间长度  

**复古像素效果**：  
- 房屋用 8x8 像素块表示，绿色为完好，红色为摧毁  
- 音效：摧毁时播放爆炸音效，恢复时播放修复音效  
- Canvas 网格动态渲染，每步操作后刷新  

**关键代码片段（JS伪代码）**：
```javascript
class VillageVisualizer {
  constructor(n) {
    this.set = new Set([0, n+1]); // 初始化哨兵
    this.stack = [];
    this.pixelSize = 8; // 像素块大小
  }

  // 插入摧毁点（红色）
  insert(x) {
    this.set.add(x);
    this.stack.push(x);
    drawPixel(x, 'red'); // Canvas 绘制红色像素块
    playSound('explosion.wav');
  }

  // 查询区间（蓝色前驱，黄色后继）
  query(x) {
    let arr = Array.from(this.set).sort((a,b) => a-b);
    let suc = arr.find(v => v > x);
    let pre = arr.reverse().find(v => v < x);
    highlight(pre, 'blue');
    highlight(suc, 'yellow');
    return suc - pre - 1;
  }
}
```

---

### 核心代码实现（C++）
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m, x; 
    stack<int> stk;
    set<int> s = {0, n+1}; // 哨兵节点

    while (m--) {
        char op; cin >> op;
        if (op == 'D') {
            cin >> x;
            s.insert(x);
            stk.push(x);
        } else if (op == 'R') {
            s.erase(stk.top());
            stk.pop();
        } else {
            cin >> x;
            if (s.count(x)) cout << 0 << endl;
            else {
                auto suc = s.upper_bound(x);
                auto pre = prev(suc);
                cout << *suc - *pre - 1 << endl;
            }
        }
    }
    return 0;
}
```

---

通过有序集合维护摧毁点，结合哨兵和栈实现高效操作，是本题的最优解。其核心在于利用 STL 的内置二分功能快速定位边界，代码简洁且性能优异。

---
处理用时：65.67秒
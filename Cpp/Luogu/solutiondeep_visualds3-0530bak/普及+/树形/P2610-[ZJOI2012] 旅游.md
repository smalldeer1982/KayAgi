# 题目信息

# [ZJOI2012] 旅游

## 题目描述

到了难得的暑假，为了庆祝小白在数学考试中取得的优异成绩，小蓝决定带小白出去旅游~~

经过一番抉择，两人决定将 T 国作为他们的目的地。T 国的国土可以用一个凸 $n$ 边形来表示，$n$ 个顶点表示 $n$ 个入境/出境口。T 国包含 $n-2$ 个城市，每个城市都是顶点均为 $n$ 边形顶点的三角形（换而言之，**城市组成了关于 T 国的一个三角剖分**）。**两人的旅游路线可以看做是连接 $n$ 个顶点中不相邻两点的线段**。

![](https://cdn.luogu.com.cn/upload/pic/1409.png) 

为了能够买到最好的纪念品，小白希望旅游路线上经过的城市尽量多。作为小蓝的好友，你能帮帮小蓝吗？

## 说明/提示

对于 $20\%$ 的数据，$n\le 2000$。

对于 $100\%$ 的数据，$4\le n \le 200000$。

## 样例 #1

### 输入

```
6

1 2 4

2 3 4

1 4 5

1 5 6```

### 输出

```
4```

# AI分析结果



## 算法分类
**树的直径**

---

## 综合分析与结论
### 核心思路
1. **问题转化**：将每个三角形视为图中的一个节点，相邻三角形（共享一条边）之间连边，形成树结构。
2. **树的性质证明**：凸多边形的三角剖分无环且边数为 `n-3`，节点数为 `n-2`，故形成树。
3. **最长路径问题**：线段经过最多城市的问题等价于求树的直径（最长简单路径）。

### 关键难点与解决
- **难点1：如何高效构建树结构？**  
  使用 `map<pair<int,int>,int>` 记录每条边对应的三角形编号。若某边已存在，则将当前三角形与记录的三角形连边。
- **难点2：如何快速求树的直径？**  
  采用两次 DFS/BFS：第一次从任意起点找最远节点，第二次从该节点出发找最长路径。

### 可视化设计思路
1. **树构建动画**：用像素风格展示多边形三角剖分，每次插入三角形时高亮当前处理的边，若发现共享边则显示连边过程。
2. **直径搜索动画**：  
   - 第一次 DFS：用绿色标记遍历路径，红色标记当前最远节点。  
   - 第二次 DFS：用蓝色标记最终直径路径，路径长度动态显示。  
3. **交互设计**：支持步进查看边插入和遍历过程，音效提示连边和路径更新。

---

## 题解清单（≥4星）
### 1. Dr_Gears（⭐⭐⭐⭐⭐）
- **亮点**：理论推导清晰，代码简洁高效，利用 map 实现快速邻边查询。
- **核心代码**：
  ```cpp
  map<pair<int, int>, int> ys;
  void add(int x, int y) { /* 邻接表建边 */ }
  ```
  
### 2. Equfix（⭐⭐⭐⭐）
- **亮点**：代码可读性强，详细注释，强调排序处理边的唯一性。
- **关键优化**：对三角形顶点排序避免重复边。

### 3. PanH（⭐⭐⭐⭐）
- **亮点**：代码简洁，强调两次 DFS 求直径的经典性。
- **代码片段**：
  ```cpp
  int bfs(int st) { /* 返回最远节点 */ }
  ```

---

## 最优思路与技巧提炼
### 核心技巧
1. **边统一化处理**：将边的顶点排序（如 `u < v`），确保 `(u, v)` 和 `(v, u)` 视为同一条边。
2. **树的直径算法**：两次遍历法时间复杂度 `O(n)`，适用于大规模数据。
3. **哈希优化**：使用 `unordered_map` 或自定义哈希替代 `map` 提升查询速度（见 Yingluosanqian 题解）。

### 代码实现片段
```cpp
// 边处理与建树
sort(a, a + 3); // 顶点排序
for (int i = 0; i < 3; i++) {
    int u = a[i], v = a[(i + 1) % 3];
    if (u > v) swap(u, v);
    if (mp.find({u, v}) != mp.end()) {
        add_edge(current_id, mp[{u, v}]);
        mp.erase({u, v});
    } else {
        mp[{u, v}] = current_id;
    }
}

// 求直径
int get_diameter() {
    int u = bfs(1); // 第一次 BFS
    int v = bfs(u); // 第二次 BFS
    return depth[v];
}
```

---

## 相似题目推荐
1. **P1099 [NOIP2007 提高组] 树网的核**  
   - 考察树的直径性质及其应用。
2. **P3304 [SDOI2013] 直径**  
   - 求树的直径并统计所有直径必经边。
3. **P5536 【XR-3】核心城市**  
   - 树的中心与直径相关的最优化问题。

---

## 可视化与游戏化设计
### 像素风格动画
- **Canvas 绘制**：  
  1. 多边形初始化为红色边框，三角剖分边为黄色，对角线为蓝色。  
  2. 插入三角形时，高亮当前边为绿色，若发现共享边则闪烁三次并绘制白色连边。  
- **音效设计**：  
  - 连边成功：短促“哔”声。  
  - 直径更新：上扬音阶。  

### 自动演示模式
- **AI 控制流程**：自动完成三角剖分、建树、两次遍历，关键步骤暂停 1 秒展示。

---

## 个人心得摘录
> **Dr_Gears**：  
> “一遍A无调试”——强调排序处理边的关键性，避免重复和遗漏。  
> **Equfix**：  
> “mem数组要清空！！”——提醒在两次 BFS 之间重置状态，避免逻辑错误。

---
处理用时：66.76秒
# 题目信息

# 「C.E.L.U-01」族谱树

## 题目背景

小 Soup 正在翻看他们家的族谱，他们家的族谱构成了一棵树。小 Soup 发现，由于年代久远，他们家族中的一些分支已经绝迹，他对此十分好奇。

## 题目描述

小 Soup 给你他们家的族谱树，想要问你在这棵树中**所有**第 $k$ 层的孩子（树中深度为 $k$ 的点，根节点的深度为 $1$ ,根节点编号为 $1$ ）的 $\text{最近公共祖先}$ 是谁。

## 说明/提示


样例解释1：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zgcgu0da.png)

样例解释2：  
![](https://cdn.luogu.com.cn/upload/image_hosting/l02zvtkv.png)

#### 数据保证存在深度为 $k$ 的点

$\begin{array}{|c|c|c|}数据编号&n,m&特殊性质\\1&\le10&\diagdown\\2&\le100&\diagdown\\3\sim4&\le10^3&\diagdown\\5&\le3\times10^5&树为一条链\\6&\le3\times10^5&\diagdown\\7\sim10&\le3\times10^6&\diagdown\\11\sim12&\le5\times10^6&\diagdown\end{array}$


对于 $100\%$ 的数据，$n\le5\times10^6,m\le n$。

温馨提示：此题较卡常，请注意大常数带来的影响以及时空复杂度。如果你被卡常了，可以试试使用快速读入。

## 样例 #1

### 输入

```
8 3
0 1 1 2 2 3 4 5
2
1
4
```

### 输出

```
1
1
2```

## 样例 #2

### 输入

```
11 4
0 1 1 3 3 3 4 5 8 8 10
3
4
5
6```

### 输出

```
3
3
8
11```

# AI分析结果



## 算法分类
树形结构 / 深度预处理 / 最近公共祖先（LCA）

---

## 题解核心思路与难点对比

### 关键算法流程
所有最优解法的核心逻辑均可概括为：
1. **预处理子树最大深度**：通过DFS计算每个节点的子树最大深度（md[u]）
2. **维护最长链**：从最深节点向上回溯，判断当前节点能否覆盖该层所有节点
3. **动态更新答案**：利用dfn序或子树覆盖特性判断LCA有效性

### 解决难点
1. **线性时间复杂度**：必须避免暴力遍历所有节点的LCA组合
2. **空间优化**：需在5e6数据规模下保持低内存消耗
3. **逻辑正确性**：确保最深链上的节点能正确覆盖所有层

---

## 最优思路与技巧提炼

### 核心思想
1. **最长链性质**：所有深度的LCA必在根节点到最深节点的路径上
2. **dfn序判断**：利用`dfn[x] ∈ [dfn[u], dfn[u]+size[u]-1]`快速验证子树包含性
3. **逆向更新**：从最深深度向浅层递推，确保每个答案只需一次验证

### 代码实现优化
```cpp
// 关键片段：最深链回溯判断
int cur = deepest_node;
for(int d=max_depth; d>=1; d--){
    while(!check_contain(d, cur)) 
        cur = fa[cur];
    ans[d] = cur;
}

// dfn序验证函数
bool check_contain(int depth, int u){
    return dfn[min_node[depth]] >= dfn[u] && 
           dfn[max_node[depth]] <= dfn[u]+size[u]-1;
}
```

---

## 可视化算法设计

### 动画方案设计
1. **树结构展示**：Canvas绘制树形结构，节点按层次布局
2. **深度染色**：用渐变色表示节点深度（深红→浅黄）
3. **最长链追踪**：
   - 红色高亮显示当前验证的链节点
   - 绿色闪烁标记已验证通过的LCA节点
4. **dfn覆盖区**：半透明矩形框表示当前节点的子树dfn范围

### 交互功能
1. **速度控制**：滑动条调节动画速度（0.5x~5x）
2. **单步调试**：空格键逐帧执行回溯过程
3. **数据提示**：悬停节点显示深度/dfn/子树大小信息

### 复古像素风实现
```javascript
// 像素风格绘制示例
function drawNode(x, y, state){
    ctx.fillStyle = stateColors[state];
    ctx.fillRect(x*16, y*16, 14, 14); // 16x16像素块
    if(state === 'active'){
        // 添加扫描线特效
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(x*16, (y*16 + frame%16), 14, 2);
    }
}
```

---

## 高星题解推荐（≥4★）

### 1. abruce (5★)
- **亮点**：双DFS预处理最大深度，严格O(n)时间复杂度
- **核心代码**：
  ```cpp
  void dfs1(int u){ // 计算md, mx1, mx2
      for(auto v : children[u]){
          dfs1(v);
          if(md[v] > md[mx1[u]]){
              mx2[u] = mx1[u];
              mx1[u] = v;
          }
          // ... 更新次大值
      }
  }
  ```

### 2. 无尽星空 (4★)
- **亮点**：离线Tarjan算法实现，利用并查集动态维护LCA
- **关键优化**：
  ```cpp
  void tarjan(int u){
      for(v : children) tarjan(v);
      ans[dep] = find(current_lca);
  }
  ```

### 3. itisover (4★)
- **亮点**：最长链+dfn序验证，实践性能最优
- **核心逻辑**：
  ```cpp
  while(!check(dfn_min, dfn_max, cur))
      cur = fa[cur];
  ```

---

## 相似题目推荐
1. [P3379 LCA模板](https://www.luogu.com.cn/problem/P3379)
2. [P3304 直径](https://www.luogu.com.cn/problem/P3304)
3. [P4211 LCA的深度](https://www.luogu.com.cn/problem/P4211)

---

## 调试心得摘录
> "被卡常后发现fa[]数组用int比用vector快3倍" —— 素质玩家孙1超  
> "长链剖分的剪枝必须精确到子树大小判断" —— 荣耀南冥  
> "dfn序验证时注意叶子节点的size=1" —— Farkas_W

---

## 结论
最优解法采用**最长链回溯+dfn验证**，时间复杂度O(n)，空间复杂度O(n)。可视化时应重点展示深度预处理过程和链回溯的验证逻辑，通过像素风格动画强化算法关键步骤的可观测性。

---
处理用时：64.13秒
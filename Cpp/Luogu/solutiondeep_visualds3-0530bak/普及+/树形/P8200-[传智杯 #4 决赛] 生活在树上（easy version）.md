# 题目信息

# [传智杯 #4 决赛] 生活在树上（easy version）

## 题目背景

**本题是 P8201 的简单版本，两道题目的解法略有不同。本题和 P8201 在题意上的区别在于本题给定树上的边权，而不是点权。**

小智生活在「传智国」，这是一个有 $n$ 个城市的国家，各个城市由 $n-1$ 条道路相连。

每个道路都有长度 $w_i$ ，我们定义，小智从城市 $a$ 走到城市 $b$ 的代价是 $\mathrm{dis}_{a, b} = \bigoplus \limits_{e \in \mathrm{path}\left(a, b\right)} w_e$，其中 $\bigoplus$ 表示**按位异或**（如果你不知道什么是**按位异或**，请参见题目下方的提示/说明），$\mathrm{path}\left(a,b\right)$ 表示 $a$ 到 $b$ 的简单路径上的边集。也即 $\mathrm{dis}_{a, b}$ 表示将 $a$ 与 $b$ 的简单路径上所有边写作 $e_1, e_2, e_3, \dots$ 后，求 $w_{e_1} \bigoplus w_{e_2}\bigoplus w_{e_3} \dots$ 的结果。

有一天，小智获得了去参加传智杯的机会，他在前往比赛地的路上想到了一个问题，但他好像不会做，于是他把这个题告诉了你。聪明的同学，你可以帮帮他吗？

## 题目描述

小智说：「由于我们的国家只有 $n$ 个城市和 $n-1$ 条道路，那么我们的国家就相当于是一棵树。我在想，在我们的国家中，是否有城市满足『到城市 $a$ 的代价和到城市 $b$ 的代价的异或等于 $k$』。好难哦，我想不出来，你能帮帮我吗？」

也就是说，给定城市 $a, b$ 和整数 $k$，请你计算是否存在城市 $t$ 满足 $\mathrm{dis}_{t, a} \bigoplus \mathrm{dis}_{t, b} = k$。

## 说明/提示

### 相关概念解释
「树」：树是一个有 $n$ 个结点和 $n-1$ 条边的无向简单连通图。

「按位异或」：按位异或即 C++、python、java 语言中的 「^」 运算。它是一个二元运算，步骤是将两个数的二进制位按位比较，相同为 $0$，不同为 $1$。例如：$3 \bigoplus 5 = (011)_2 \bigoplus (101)_2 = (110)_2 = 6$。**请注意，这是一个按位运算，不是一个逻辑运算**。
### 样例 1 解释
下图为传智国的地图。

$\forall t \in \{1, 2, 3, 4, 5\}$，都不可能有 $\mathrm{dis} _{t,1} \bigoplus \mathrm{dis}_{t, 2} = 4$，$\mathrm{dis}_{t, 2} \bigoplus \mathrm{dis}_{t, 3} = 12$，于是输出 `No`；

而取 $t = 5$，有 $\mathrm{dis}_{t, 1} \bigoplus \mathrm{dis}_{t, 4} = 10$，于是输出 `Yes`。

![](https://cdn.luogu.com.cn/upload/image_hosting/9ikzjfh3.png)
### 数据规模与约定
对于所有测试点，保证 $1 < n \leq 5 \times 10^5$，$1 \leq m \leq 5 \times 10^5$，$0 \leq w_i < 2^{64}$。

对于每次询问，保证 $1 \leq a, b \leq n$ 且 $a \neq b$，$0 \leq k < 2^{64}$。

## 样例 #1

### 输入

```
5 3
1 2 2
1 3 6 
2 4 8
2 5 1
1 2 4
2 3 12
1 4 10```

### 输出

```
nO
No
YeS```

## 样例 #2

### 输入

```
5 10
2 1 63
3 1 57
4 2 2
5 2 84
5 2 84
4 1 9977404983223574764
2 5 84
2 1 15996060349666123522
5 4 86
3 1 8428615422876116375
5 1 107
2 3 6
2 3 6
4 2 2```

### 输出

```
yeS
nO
YEs
No
YEs
nO
YEs
yeS
yeS
YEs```

# AI分析结果



## 唯一算法分类
无特定算法分类（基于异或性质与树的前缀和）

---

## 综合分析与结论

**核心思路**  
所有题解均基于异或运算的以下性质：  
1. **自反性**：x ^ x = 0  
2. **路径独立性**：a 到 b 的异或和等于根到 a 的异或和 ^ 根到 b 的异或和  

通过预处理每个节点到根的异或和（记为 `dis[i]`），查询时直接计算 `dis[a] ^ dis[b]` 是否等于 k，时间复杂度为 O(1)。

**解决难点对比**  
- **错误思路**：试图用 LCA 或树剖求路径异或和（如 3a51_ 的题解）  
- **正确优化**：发现异或路径性质后，无需求 LCA，直接前缀异或和即可  

**可视化设计要点**  
1. **树形结构展示**：用 Canvas 绘制树形图，节点标注 `dis[i]` 值  
2. **路径高亮**：当输入 a,b 时，动态显示从根到 a 和根到 b 的路径  
3. **异或抵消动画**：用颜色标记两条路径的公共部分（异或后消失）和非公共部分（保留异或结果）  
4. **像素化风格**：采用 8-bit 像素字体，路径高亮使用红蓝闪烁特效  
5. **音效设计**：  
   - 正确时播放 "Mario coin" 音效  
   - 错误时播放 "Zelda secret" 音效  

---

## 题解清单（≥4星）

1. **一扶苏一（5星）**  
   - **亮点**：严谨的数学推导，代码极简（仅 30 行）  
   - **关键代码**：  
     ```cpp
     void dfs(...) { b[v] = b[u] ^ w; } // 前缀异或递推
     ```

2. **lsj2009（5星）**  
   - **亮点**：清晰的分步公式推导，给出完整的数学证明  
   - **心得摘录**：  
     > "发现了什么？其实我们不需要枚举i！这个瞬间让我顿悟了异或的魔力"

3. **苏联小渣（4.5星）**  
   - **亮点**：代码可读性极强，包含详细的注释说明  
   - **优化点**：省去 LCA 计算步骤，直接利用异或性质  

---

## 核心代码实现

**最优解法（一扶苏一）**  
```cpp
std::array<unsigned long long, maxn> dis;

void dfs(int u, int fa) {
  for(auto [v, w] : edges[u]) 
    if(v != fa) dis[v] = dis[u] ^ w, dfs(v, u);
}

// 查询处理
if((dis[a] ^ dis[b]) == k) return "Yes";
```

**可视化关键片段（JS）**  
```javascript
// 像素化路径绘制
function drawPath(node, color) {
  let x = node;
  while(x != root) {
    ctx.fillStyle = color;
    ctx.fillRect(pos[x].x, pos[x].y, 8, 8); // 8x8像素块
    x = parent[x];
    playSound('blip'); // 移动音效
  }
}
```

---

## 相似题目推荐

1. **P2420【自然数的异或路径】**  
   - 求树上路径异或和，与本题目完全一致的基础版

2. **P4551【最长异或路径】**  
   - 进阶应用，需结合 Trie 树求最大异或路径

3. **P4151【XOR】**  
   - 带环图的异或路径处理，需结合线性基

---

## 复古游戏化设计

**实现方案**  
1. **画面布局**：  
   - 左侧：FC风格的树形地图（16色模式）  
   - 右侧：LED像素屏显示 dis[a] ^ dis[b] 的二进制计算过程  

2. **AI演示模式**：  
   - 自动随机选择 a,b，展示异或结果与路径变化  
   - 每步演示延迟可调（200ms~1s）

3. **积分系统**：  
   - 连续答对 5 题解锁 "异或大师" 成就  
   - 错误时扣除 1 心形生命值（共 3 心）

---

## 总结

本题核心在于发现异或运算的路径独立性，最优解法通过 O(n) 预处理实现 O(1) 查询。树剖等复杂数据结构实属过度设计，而基于数学性质的前缀异和解法才是正解。可视化设计应重点突出异或抵消的动态过程和树形结构特征。

---
处理用时：61.12秒
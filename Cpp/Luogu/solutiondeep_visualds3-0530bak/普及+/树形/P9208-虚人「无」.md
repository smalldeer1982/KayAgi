# 题目信息

# 虚人「无」

## 题目背景

一点也不美丽的不死鸟。

那双锐爪，沾染了无辜的鲜血。

## 题目描述

给定二元序列 $\{(v_i,c_i)\}$ 和一棵以 $1$ 为根的有根树。第 $i$ 个点的点权是 $(v_i,c_i)$。

- 定义一个非根节点的权值为其子树内的 $c$ 的积乘上其子树补的 $v$ 的积。
- 定义一个根节点的权值为其子树内的 $c$ 的积。

形式化的讲，若 $u$ 不为根节点，则 $u$ 的权值 $f_u$ 为：

$$f_u=\prod\limits_{v\in \operatorname{substree}(u)} c_v\times \prod\limits_{v\notin \operatorname{substree}(u)} v_v$$

否则，其权值 $f_u$ 为：

$$f_u=\prod\limits_{v=1}^n c_v$$

试求整棵树**所有节点的权值之和**，答案对 $m$ 取模。请注意：**保证 $\bm m$ 是质数**。




## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/olehwn2w.png)

（图片有误，应该交换 $v,c$ 的权值。）

### 数据范围及约定

对于 $100\%$ 的数据，满足 $1\le n\leq 3\times 10^5$，$1\leq v_i,c_i,m\leq 10^9$。


## 样例 #1

### 输入

```
3 998244853
1 2
1 3
2 1 2
1 2 2```

### 输出

```
10```

## 样例 #2

### 输入

```
5 998244353
1 2
1 3
1 4
4 5
5 5 5 2 3
6 6 1 5 3```

### 输出

```
4656```

# AI分析结果



# 算法分类  
**树的前序遍历（DFS序）与前后缀积优化**

---

## 题解思路、算法要点与解决难点

### 核心思路
- **DFS序映射子树**：通过DFS遍历，将子树映射为一段连续区间，便于用前缀/后缀积快速计算外部乘积。
- **乘积拆分**：非根节点权值 = 子树内c的积 × 子树外v的积。子树外v的积可拆分为前缀积（左边界前） × 后缀积（右边界后）。
- **高效计算**：预处理v的前缀积和后缀积，避免线段树查询的log n复杂度。

### 难点解决
1. **子树外乘积的高效计算**  
   - 利用DFS序的连续区间特性，将子树外的v乘积拆分为前缀和后缀部分，O(1)计算。
2. **避免逆元限制**  
   - 通过前后缀积直接相乘，无需逆元操作，规避了模数m与v_i/c_i不互质的问题。

---

## 题解评分 (≥4星)

### 1. Emily666（5星）
- **亮点**：代码简洁，直接使用DFS序和前后缀积，O(n)时间复杂度；思路清晰，无需复杂数据结构。
- **代码可读性**：结构清晰，注释合理。
  
### 2. 翟翟（4星）
- **亮点**：思路与Emily666一致，但变量命名和代码结构稍显晦涩。
- **优化程度**：同样采用前后缀积，但未详细解释区间拆分逻辑。

### 3. Flanksy（线段树优化版，4星）
- **亮点**：通过线段树维护区间乘积，通用性更强。
- **实践性**：代码较长，但提供了逆元和线段树两种方案对比。

---

## 最优思路/技巧提炼

### 关键技巧
1. **DFS序区间映射**  
   - 预处理每个节点的子树在DFS序中的左右边界，将子树操作转化为区间操作。
2. **前后缀积预处理**  
   - 计算v的前缀积数组`lv`和后缀积数组`rv`，使得子树外v的积 = `lv[left-1] * rv[right+1]`。
3. **乘积拆分公式**  
   - 非根节点权值：`f_u = (子树c的积) × (前缀v积) × (后缀v积)`。

---

## 同类型题与算法套路

### 类似问题特征
- 需要统计子树/路径的乘积或和。
- 要求高效处理区间外的组合值（如补集、前缀后缀组合）。

### 推荐题目
1. **P3374 树状数组模板**  
   - 区间查询与单点修改，类似线段树应用。
2. **P3384 树链剖分**  
   - 将树映射为区间后处理路径问题。
3. **P3919 可持久化线段树**  
   - 处理历史版本的区间查询。

---

## 可视化与算法演示

### 动画设计
1. **DFS遍历过程**  
   - 用颜色标记当前遍历的节点，子树区间逐步扩展。
   - 显示每个节点的`L[u]`和`R[u]`区间范围。
2. **前缀/后缀积计算**  
   - 高亮前缀积区间（绿色）和后缀积区间（红色），动态展示乘积计算。
3. **权值计算步骤**  
   - 当前节点高亮，子树区间内c值连乘，外部v值通过前后缀积区域显示。

### 复古像素风格
- **颜色方案**：  
  - 子树区间：蓝色像素块  
  - 前缀积区域：绿色像素块  
  - 后缀积区域：红色像素块  
- **音效**：  
  - 遍历节点时播放“滴”声，计算乘积时播放“咔”声。
- **Canvas实现**：  
  - 树结构用网格表示，节点为8x8像素方块，DFS序动态绘制。

---

## 核心代码实现（Emily666）

```cpp
void dfs(int x, int f) {
    sc[x] = c[x]; // 子树c的积
    L[x] = ++tot; // DFS序左边界
    id[tot] = x;  // 反向映射
    for (auto y : e[x]) {
        if (y == f) continue;
        dfs(y, x);
        sc[x] = (sc[x] * sc[y]) % m; // 累加子树c的积
    }
    R[x] = tot; // DFS序右边界
}

// 预处理前后缀积
lv[0] = rv[n + 1] = 1;
for (int i = 1; i <= n; i++) 
    lv[i] = (lv[i - 1] * v[id[i]]) % m;
for (int i = n; i > 0; i--) 
    rv[i] = (rv[i + 1] * v[id[i]]) % m;

// 计算总答案
ans = sc[1] % m; // 根节点权值
for (int i = 2; i <= n; i++) {
    ll external_v = (lv[L[i] - 1] * rv[R[i] + 1]) % m;
    ans = (ans + sc[i] * external_v) % m;
}
```

---

## 个人心得摘录

> **Flanksy**：  
> “线段树维护区间乘积的代码容易被卡常，改用前缀积和后缀积后常数大幅降低。”  
> **调试教训**：初始未处理越界查询（如`dfn[i]+siz[i] >n`），导致WA。

> **Emily666**：  
> “将子树外v的积拆分为前后缀两部分是本题最关键的思维跳跃点。”

---
处理用时：69.55秒
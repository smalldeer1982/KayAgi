# 题目信息

# [THUPC 2023 决赛] 大纲

## 题目描述

小 I、小 O 和小 N 是 ION 大纲的编写者，小 I 负责给每个知识点定难度。

ION 大纲计划列入 $n$ 个知识点，其中小 I 按照自己的认识给其中部分知识点定好了难度，还有部分知识点没有定难度。

知识点之间有依赖关系，这个依赖关系恰好构成了一棵以 $1$ 为根的外向树，知识点 $x$ 指向知识点 $y$ 表示 $x$ 依赖 $y$。**依赖关系不具有传递性。**

你需要告诉小 I 目前确定下来的难度是否合理。我们认为确定下来的难度是合理的当且仅当存在一个给所有未确定难度的知识点确定难度的方式，使得以下所有条件成立：

- 每个知识点的难度都是非负整数；
- 对于每个依赖其他知识点的知识点 $x$，设 $\max_x$ 为 $x$ 依赖的知识点中难度的最大值，则如果 $x$ 恰依赖一个难度为 $\max_x$ 的知识点，那么知识点 $x$ 的难度为 $\max_x$，否则为 $\max_x+1$。**对于不依赖其他知识点的知识点，没有其他限制。**

## 说明/提示

### 样例 1 解释

对于第一组测试数据，将知识点 $2$ 的难度定为 $0$ 即满足条件。

对于第二组测试数据，无论如何指定知识点 $2$ 的难度，知识点 $1$ 的难度会产生矛盾。

### 数据规模与约定

对于所有测试数据，$1 \le T \le 10^5$，$2 \le n \le 10^5$，$-1 \le a_i \le 10^9$，$1 \le u,v \le n$。  
保证单个测试点中所有测试数据的 $n$ 的和不超过 $2 \times 10^5$，每组测试数据输入的所有边构成一棵以 $1$ 为根的外向树。

### 后记

大纲发表了。若干天后，小 I 给 ION 比赛投题，却发现有人偷偷改了一笔难度表，导致他的题目超纲。于是小 I 只能把题投给 CPUHT。

### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023> 查看。

## 样例 #1

### 输入

```
2
3
0 -1 0
1 2
2 3
3
0 -1 0
1 2
1 3
```

### 输出

```
Reasonable
Unreasonable
```

# AI分析结果



---

## 算法分类
**树形动态规划**

---

## 综合分析与结论

### 核心思路与难点
**核心思路**：通过树形 DP 维护每个节点的难度取值范围（下界和上界），自底向上递归验证合法性。  
**关键步骤**：
1. **叶子节点初始化**：未确定的叶子节点下界为 0，上界为无穷；已确定的叶子上下界均为其值。
2. **非叶节点计算**：对每个节点，统计所有子节点的下界最大值及出现次数，推导当前节点的下界；类似方法计算上界。
3. **合法性检查**：若节点已确定，其值必须在 [下界, 上界] 内；未确定节点允许调整。

**难点**：
- **下界推导**：当子节点下界最大值出现多次时，父节点下界需加 1。
- **上界处理**：若子节点存在未确定（上界无穷），父节点上界可能不固定。
- **矛盾判断**：已确定节点值超出范围时立即返回不合法。

---

## 题解评分（≥4星）

### 1. Larryyu（4星）
- **亮点**：明确上下界维护逻辑，代码结构清晰，注释详细。
- **关键代码**：
  ```cpp
  void dfs(int x) {
    int maxn = -10, cnt = 0, maxx = -10;
    // 统计子节点下界最大值及出现次数
    if (cnt > 1) maxn++; // 推导当前下界
    if (a[x] != -1 && a[x] < maxn) return 0; // 合法性检查
  ```

### 2. y_kx_b（4星）
- **亮点**：引入 `ub` 数组标记未确定状态，优化上界处理。
- **关键代码**：
  ```cpp
  bool flag = 0;
  flag |= ub[v]; // 判断子节点是否有未确定
  if (!flag && a[u] != x) return 0; // 子节点全确定时的检查
  ```

### 3. SIXIANG32（4星）
- **亮点**：结合 `Right` 数组处理节点确定性，逻辑严密。
- **关键代码**：
  ```cpp
  if (!cc) { // 子节点全确定
    if (a[x] != maxn) ans = 0;
  } else if (a[x] != -1) {
    if (a[x] < maxn) ans = 0;
  }
  ```

---

## 最优思路与技巧

### 核心技巧
1. **上下界推导**：
   - 下界：子节点下界最大值 + 是否重复（重复则加 1）。
   - 上界：子节点上界最大值 + 是否重复（类似下界）。
2. **合法性剪枝**：若当前节点已确定且值不在范围，立即终止递归。
3. **未确定标记**：通过标记（如 `ub` 或 `Right`）快速判断是否可调整。

### 同类型题
- **验证二叉搜索树**：维护子树值范围。
- **树上最大独立集**：树形 DP 状态转移。
- **资源分配问题**：依赖子节点状态的最优解。

---

## 推荐题目
1. **P1040 加分二叉树**（树形 DP + 区间划分）
2. **P1273 有线电视网**（树形背包问题）
3. **P1352 没有上司的舞会**（树形 DP 基础）

---

## 个人心得摘录
- **调试教训**（SIXIANG32）：  
  > *“一开始没考虑 `Right` 数组，导致条件遗漏，对拍时第一个测试点就错。必须明确每个节点的确定性。”*  
- **顿悟点**（y_kx_b）：  
  > *“发现点权随子节点单调不降，才想到用上下界维护，豁然开朗。”*

---

## 可视化与算法演示

### 核心算法动画设计
1. **树结构展示**：  
   - 以根节点为起点，逐层展开子树，每个节点显示当前上下界。
   - **颜色标记**：绿色（合法）、红色（冲突）、黄色（未确定）。
2. **动态更新**：  
   - 点击节点时，高亮其子节点，展示如何计算 `maxn` 和 `cnt`。
   - 例如：子节点下界为 [5,5,3]，显示 `maxn=5, cnt=2`，父节点下界变为 6。
3. **冲突提示**：  
   - 当已确定节点值超出范围时，播放错误音效并闪烁红色。

### 复古像素风格实现
- **Canvas 绘制**：  
  - 使用 8-bit 风格色块表示节点（16x16 像素）。
  - 每个色块显示简化的上下界数值（如 `L:5 U:∞`）。
- **音效设计**：  
  - 正确步骤：8-bit “滴”声。
  - 错误：短促“哔”声，类似经典游戏错误提示。
- **自动演示模式**：  
  - 模拟 AI 深度优先遍历，自动高亮当前处理节点，延迟 1 秒/步。

---

## 关键代码片段（Larryyu 解法核心）
```cpp
bool dfs(int x, int fax) {
  int maxn = -10, cnt = 0, maxx = -10;
  // 遍历子节点，统计下界最大值及出现次数
  for (auto y : children) {
    if (b[y] > maxn) { maxn = b[y]; cnt = 1; }
    else if (b[y] == maxn) cnt++;
    maxx = max(maxx, u[y]);
  }
  if (cnt > 1) maxn++; // 处理重复最大值
  // 检查已确定节点合法性
  if (a[x] != -1) {
    if (a[x] < maxn) return false;
    if (a[x] > maxx) return false;
  }
  // 更新当前节点上下界
  b[x] = maxn;
  u[x] = maxx;
  return true;
}
```

---
处理用时：82.27秒
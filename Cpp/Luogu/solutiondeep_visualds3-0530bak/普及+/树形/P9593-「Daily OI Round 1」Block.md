# 题目信息

# 「Daily OI Round 1」Block

## 题目描述

给定一棵树，节点有颜色，在树上距离为 $2$ 的点连边（仍保留原来的边），求新图中颜色相同且连通的非空点集数量。由于答案可能非常大，您只需输出答案对 $10^9+7$ 取模的值。

点集连通的定义：对于图 $G(V,E)$，$V$ 的一个子集 $V'$ 是连通点集，当且仅当 $G(V',E')$ 是一个连通图，其中边集 $E'=\{(u,v)|(u,v)\in E\land u \in V'\land v\in V'\}$。

## 说明/提示

样例 1 中，原树如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/zmgrnwkh.png)

树上距离为 $2$ 的点连边后，新图如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/id3xc54a.png)

则 $8$ 个颜色相同且连通的非空点集分别是：$\{1\},\{2\},\{3\},\{4\},\{1,3\},\{1,4\},\{3,4\},\{1,3,4\}$。

**本题开启捆绑测试。**



|$\text{Subtask}$|分值|$n \le$| 特殊性质 | 子任务依赖 |
| :-----------: | :-------------:|:-----------: |:-----------: |:-----------: |
|$0$|$5$|$10^5$| A | 无 |
|$1$|$5$|$16$| 无 | 无 |
|$2$|$5$|$10^5$| B | 无 |
|$3$|$15$|$10^5$| C | 无 |
|$4$|$20$|$10^5$| D | 无 |
|$5$|$50$|$10^5$| 无 | $0\sim4$ |

- 特殊性质 A：所有节点的颜色不相同。
- 特殊性质 B：给出的树是菊花，具体地，第 $i$ 条边连接节点 $1$ 和节点 $i+1$。
- 特殊性质 C：给出的树是链，具体地，第 $i$ 条边连接节点 $i$ 和节点 $i+1$。
- 特殊性质 D：所有节点的颜色相同。


对于全部数据，满足 $2\leq n\leq 10^5$，$1\leq c_i\leq n$。

## 样例 #1

### 输入

```
4
1 2 1 1
1 2
2 3
2 4
```

### 输出

```
8```

## 样例 #2

### 输入

```
6
1 2 2 2 1 2
5 3
2 1
4 5
6 3
3 1
```

### 输出

```
14```

## 样例 #3

### 输入

```
16
1 1 2 1 1 2 2 2 1 1 2 1 1 1 2 1
12 8
14 9
10 8
1 16
7 12
6 1
14 8
3 1
12 5
1 13
12 2
1 12
15 8
11 5
4 12
```

### 输出

```
442```

## 样例 #4

### 输入

```
16
11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11
4 14
4 15
12 13
2 5
7 15
10 2
15 8
15 13
9 11
13 11
3 15
8 16
6 13
1 4
10 4```

### 输出

```
27454```

## 样例 #5

### 输入

```
9
3 3 2 3 2 4 2 3 3
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9```

### 输出

```
16```

# AI分析结果



**唯一算法分类**: 树形动态规划 (Tree DP)

---

### **题解思路、算法要点与解决难点**

**核心思路**:
1. **树形DP状态定义**:
   - `f[u]`：以节点 `u` 为根的子树中，必须包含 `u` 的颜色相同且连通的非空点集数目。
   - `g` 数组：临时统计不选 `u` 时，其子树中多个同色子节点的组合贡献。

2. **状态转移**:
   - **选子节点 `v`**：若 `v` 与 `u` 同色，则直接合并 `v` 的贡献 `f[v]`。
   - **不选子节点 `v`**：但选 `v` 的同色孙子节点，此时贡献为所有孙子节点 `w` 的 `f[w] + 1` 的乘积。
   - **合并子节点贡献**：对每个子节点 `v`，总贡献为上述两种情况的乘积，最终 `f[u]` 是所有子节点贡献的连乘积。

3. **不选 `u` 的统计**:
   - 对每个颜色 `c`，统计 `u` 的所有同色子节点 `v` 的 `(f[v] + 1)` 的乘积，减去只选一个或零个的情况，得到至少选两个的贡献，累加到答案中。

**解决难点**:
- **高效处理孙子节点**：通过递归遍历，将子节点的孙子节点贡献直接合并到父节点的状态中，避免重复遍历。
- **颜色分组统计**：使用哈希表或数组临时记录每个颜色的乘积和总和，确保 `O(n)` 时间复杂度。
- **模运算优化**：在每一步乘法、加法操作中及时取模，避免溢出。

---

### **题解评分 (≥4星)**

1. **作者：teylnol_evteyl** (⭐⭐⭐⭐⭐)
   - **亮点**: 清晰的状态转移方程，高效处理颜色分组，代码简洁且模块化。
   - **代码片段**:
     ```cpp
     void dp(int u, int fa) {
         f[u] = 1;
         for (int v : children) {
             LL t = 1;
             // 处理孙子节点
             for (int w : grandchildren) t = t * (f[w] + 1) % P;
             f[u] = f[u] * t % P;
         }
         // 统计不选 u 的情况
         for (int v : children) {
             g[c[v]] = g[c[v]] * (f[v] + 1) % P;
         }
     }
     ```

2. **作者：by_chance** (⭐⭐⭐⭐)
   - **亮点**: 简化状态转移，合并选与不选的情况，代码可读性高。
   - **核心逻辑**:
     ```cpp
     for (int v : sons) {
         dp[u] *= (c[u] == c[v] ? dp[v] : 0) + product_of_grandchildren;
     }
     ```

3. **作者：一只绝帆** (⭐⭐⭐⭐)
   - **亮点**: 显式定义 `g` 数组，强调至少选两个子节点的组合数学推导。
   - **公式推导**:
     $$ g_{u,c} = \prod (f_v + 1) - \sum f_v - 1 $$

---

### **最优思路或技巧提炼**

1. **树形DP的合并策略**:
   - 父节点状态由子节点状态的乘积构成，确保子树独立性。
   - 通过颜色分组，利用乘法原理和容斥原理统计不选父节点的贡献。

2. **容斥原理应用**:
   - 计算多个同色子节点的组合时，用总乘积减去单点和空集的情况，简化计算。

3. **递归遍历优化**:
   - 递归处理子树时，同时维护临时颜色统计数组 `g`，避免重复遍历。

---

### **同类型题或类似算法套路**

- **相似题目**:
  1. **洛谷 P1352 没有上司的舞会**：树形DP处理选与不选的贡献。
  2. **洛谷 P4516 [JSOI2018] 潜入行动**：树形DP结合组合计数。
  3. **洛谷 P2607 [ZJOI2008] 骑士**：基环树上的DP与组合统计。

---

### **推荐相似题目**

1. **P1352**：树形DP基础题，理解选与不选的转移。
2. **P4516**：复杂树形DP，结合状态压缩。
3. **P2607**：处理基环树结构，扩展树形DP应用。

---

### **可视化与算法演示**

**动画设计**:
- **树结构可视化**：以树形图展示节点关系，高亮当前处理的节点 `u` 及其子节点。
- **颜色标记**：用不同颜色区分节点颜色，动态显示连通块的形成。
- **关键步骤**:
  1. **选 `u` 的情况**：递归展开子树，逐步显示 `f[u]` 的乘积过程。
  2. **不选 `u` 的情况**：显示颜色分组统计，突出容斥计算（总乘积 - 单点 - 空集）。
- **复古像素风格**：用8-bit色块表示节点，音效提示状态更新（如“选中”音效、乘积完成音效）。

**交互控制**:
- **步进执行**：手动控制递归深度，观察 `f[u]` 和 `g` 数组的变化。
- **自动演示**：模拟AI决策路径，自动播放最优解的生成过程。

---

### **代码实现核心逻辑**

**teylnol_evteyl 的代码核心**:
```cpp
void dp(int u, int fa) {
    f[u] = 1;
    for (int i = la[u]; i; i = ne[i]) {
        int v = en[i];
        if (v == fa) continue;
        dp(v, u);
        LL t = 1;
        // 处理孙子节点贡献
        for (int j = la[v]; j; j = ne[j]) {
            int w = en[j];
            if (w == u) continue;
            if (c[w] == c[u]) t = t * (f[w] + 1) % P;
        }
        if (c[v] == c[u]) t = (t + f[v]) % P;
        f[u] = f[u] * t % P;
    }
    // 统计不选 u 的同色组合
    for (int i = la[u]; i; i = ne[i]) {
        int v = en[i];
        if (v == fa) continue;
        g[c[v]] = g[c[v]] * (f[v] + 1) % P;
    }
    // 累加答案并重置 g
    for (int i = la[u]; i; i = ne[i]) {
        int v = en[i];
        if (v == fa) continue;
        res = (res + g[c[v]] - 1) % P;
        g[c[v]] = 1;
    }
}
```

**关键解释**:
- **孙子节点处理**：遍历子节点 `v` 的所有孙子节点 `w`，统计与 `u` 同色的贡献。
- **颜色分组统计**：用 `g` 数组临时记录每个颜色的乘积，最终通过容斥计算答案。

---
处理用时：104.97秒
# 题目信息

# [NOIP 2007 提高组] 树网的核

## 题目描述

设 $T=(V,E,W)$ 是一个无圈且连通的无向图（也称为无根树），每条边都有正整数的权，我们称 $T$ 为树网（`treenetwork`），其中 $V$，$E$ 分别表示结点与边的集合，$W$ 表示各边长度的集合，并设 $T$ 有 $n$ 个结点。

路径：树网中任何两结点 $a$，$b$ 都存在唯一的一条简单路径，用 $d(a, b)$ 表示以 $a, b$ 为端点的路径的长度，它是该路径上各边长度之和。我们称 
$d(a, b)$ 为 $a, b$ 两结点间的距离。

$D(v, P)=\min\{d(v, u)\}$, $u$ 为路径 $P$ 上的结点。

树网的直径：树网中最长的路径成为树网的直径。对于给定的树网 $T$，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。

偏心距 $\mathrm{ECC}(F)$：树网 $T$ 中距路径 $F$ 最远的结点到路径 $F$ 的距离，即

$$\mathrm{ECC}(F)=\max\{D(v, F),v \in V\}$$

任务：对于给定的树网 $T=(V, E, W)$ 和非负整数 $s$，求一个路径 $F$，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 $s$（可以等于 $s$），使偏心距 $\mathrm{ECC}(F)$ 最小。我们称这个路径为树网 $T=(V, E, W)$ 的核（`Core`）。必要时，$F$ 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。

下面的图给出了树网的一个实例。图中，$A-B$ 与 $A-C$ 是两条直径，长度均为 $20$。点 $W$ 是树网的中心，$EF$ 边的长度为 $5$。如果指定 $s=11$，则树网的核为路径`DEFG`（也可以取为路径`DEF`），偏心距为 $8$。如果指定 $s=0$（或 $s=1$、$s=2$），则树网的核为结点 $F$，偏心距为 $12$。

![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)


## 说明/提示

- 对于 $40\%$ 的数据，保证 $n \le 15$。
- 对于 $70\%$ 的数据，保证 $n \le 80$。
- 对于 $100\%$ 的数据，保证 $2\le n \le 300$，$0\le s\le10^3$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^3$。

NOIP2007 提高组第四题

## 样例 #1

### 输入

```
5 2
1 2 5
2 3 2
2 4 4
2 5 3
```

### 输出

```
5
```

## 样例 #2

### 输入

```
8 6
1 3 2
2 3 2 
3 4 6
4 5 3
4 6 4
4 7 2
7 8 3
```

### 输出

```
5```

# AI分析结果



# 算法分类  
**树的遍历与双指针优化**

---

## 综合分析与结论  
### 核心思路与难点  
1. **树的直径性质**：所有题解均利用树的直径特性（最长路径性质、中点唯一性）简化问题，最优路径必然存在于某条直径上  
2. **偏心距计算**：偏心距由三部分组成：  
   - 路径左端到直径左端距离  
   - 路径右端到直径右端距离  
   - 直径节点支链的最长距离  
3. **优化关键**：双指针滑动窗口快速定位合法路径，预处理支链距离避免重复计算  

### 核心算法流程  
1. **求直径**：两次DFS/BFS确定直径端点及路径  
2. **预处理**：  
   - 计算直径上每个节点的支链最长距离  
   - 预处理直径的前缀和后缀距离数组  
3. **双指针扫描**：固定左端点，右端点尽量右移至路径长度≤s，计算当前窗口的偏心距极值  

### 可视化设计思路  
**动画演示方案**（8位像素风格）：  
1. **直径绘制**：用红色像素块连成直径路径  
2. **双指针窗口**：蓝色高亮当前路径端点（i,j），窗口内显示绿色背景  
3. **支链动态延伸**：黄色像素点表示支链最远点，伴随音效触发  
4. **偏心距计算**：  
   - 左侧红色箭头显示`pres[l]`  
   - 右侧红色箭头显示`posts[r]`  
   - 支链黄色数字显示`maxd`  
5. **控制面板**：  
   - 步进按钮控制指针移动  
   - 音效开关（支链延伸音 / 窗口移动音）  
   - 速度调节滑块（0.5x~3x）  

---

## 题解清单（≥4星）  
### 1. StudyingFather（★★★★★）  
**亮点**：  
- 严格数学证明路径必在直径上  
- O(n)双指针+前缀和实现  
- 完整代码分离不同解法，便于对比  
**核心代码**：  
```cpp
namespace sub4 {
void solve() {
  // 预处理支链最大距离
  for(int i=1; i<=cnt; i++) dfs(dia[i],0);
  // 双指针扫描
  for(int l=1, r=1; l<=cnt; l++) {
    while(r<=cnt && pres[r+1]-pres[l]<=s) r++;
    minecc = min(max(maxd, max(pres[l], posts[r])), minecc);
  }
}
}
```

### 2. Mosklia（★★★★☆）  
**亮点**：  
- 单调队列维护支链最大值  
- 详细注释解释直径处理流程  
**关键实现**：  
```cpp
std::deque<int> q;
for(int i=1,j=1; i<=m; dist2 -= pt[del[i]].fa_dist,++i){
    while(j<i && tot-dist1-dist2>s) dist1 += pt[del[j++]].fa_dist;
    while(!q.empty() && pt[q.front()].cur_dist-s > pt[del[i]].cur_dist) q.pop_front();
    //...单调队列维护maxd
}
```

### 3. Hyvial（★★★★☆）  
**亮点**：  
- 双指针与预处理分离实现  
- 清晰的变量命名与模块划分  
**核心逻辑**：  
```cpp
int work(){
    dfs(1); dfs(p); // 找直径端点
    query_mx();     // 预处理支链距离
    for(int i=0,j=0; i<path.size(); i++){ // 双指针扫描
        while(j+1<path.size() && lst[path[j+1]]-lst[path[i]]<=s) j++;
        ans = min(ans, max({mx, lst[path[i]], nxt[path[j]]}));
    }
}
```

---

## 最优思路提炼  
1. **直径必选定理**：最优路径必在某一直径上，避免处理非直径分支  
2. **三要素极值法**：偏心距= max(左端距离, 右端距离, 支链maxd)  
3. **滑动窗口优化**：双指针维护当前最长合法路径，O(n)时间完成扫描  

---

## 同类题目推荐  
1. **P2491 [SDOI2011]消防** - 同模型，数据规模加强版  
2. **P4408 [NOI2003]逃学的小孩** - 利用直径端点性质  
3. **P3761 [TJOI2017]城市** - 路径选择与直径重构  

---

## 个人心得摘录  
> "写这道题时，最大的顿悟是意识到支链距离的计算不需要每次DFS，只需预处理一次即可" —— StudyingFather  
> "调试时发现支链处理边界极易出错，最终通过统一maxd计算解决" —— Mosklia  

---

## 可视化代码片段（Canvas动画）  
```javascript
// 绘制直径路径（红色像素块）
function drawDiameter() {
  ctx.fillStyle = "#FF0000";
  diameterNodes.forEach((node, idx) => {
    ctx.fillRect(node.x*20, node.y*20, 18, 18);
  });
}

// 双指针窗口动画
function animateWindow(l, r) {
  ctx.fillStyle = "rgba(0,255,0,0.3)";
  ctx.fillRect(diaNodes[l].x*20, diaNodes[l].y*20, 
              (diaNodes[r].x - diaNodes[l].x)*20, 18);
  
  // 播放滑动音效
  if(Date.now() - lastSound > 200) {
    beep(440, 50);
    lastSound = Date.now();
  }
}
```

---
处理用时：86.58秒
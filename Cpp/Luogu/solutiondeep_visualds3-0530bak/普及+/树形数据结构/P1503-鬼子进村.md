# 题目信息

# 鬼子进村

## 题目背景

小卡正在新家的客厅中看电视。电视里正在播放放了千八百次依旧重播的《亮剑》，剧中李云龙带领的独立团在一个县城遇到了一个鬼子小队，于是独立团与鬼子展开游击战。


## 题目描述

县城里有 $n$ 个用地道相连的房子，第 $i$ 个只与第 $i-1$ 和第 $i+1$ 个相连。这时有 $m$ 个消息依次传来：

1. 若消息为 ```D x```：鬼子将 $x$ 号房子摧毁了，地道被堵上。

1. 若消息为 ```R``` ：村民们将鬼子上一个摧毁的房子修复了。

2. 若消息为 ```Q x```：有一名士兵被围堵在 $x$ 号房子中。

李云龙收到信息很紧张，他想知道每一个被围堵的士兵能够到达的房子有几个。


## 说明/提示

$1\leq n,m\leq 5\times 10^4$。

若士兵被围堵在摧毁了的房子中，那只能等死了。。。。。。

## 样例 #1

### 输入

```
7 9
D 3
D 6
D 5
Q 4
Q 5
R
Q 4
R
Q 4
```

### 输出

```
1
0
2
4
```

# AI分析结果



# 【算法分类】
有序集合（平衡树/STL set）

# 【题解要点与难点对比】

**核心思路**：通过维护有序的摧毁房屋集合，快速查询指定位置的前驱（左边界）和后继（右边界）

**核心算法流程**：
1. 初始化时插入边界点0和n+1
2. D操作：将x插入有序集合，并压入撤销栈
3. R操作：弹出栈顶元素并从集合删除
4. Q操作：
   - 若x已被摧毁 → 输出0
   - 否则 → 查询集合中第一个>=x的位置作为右边界，前一个元素作为左边界 → 输出右边界-左边界-1

**关键数据结构**：
- set：维护被摧毁房屋的有序集合
- stack：记录操作顺序以实现撤销

**难点突破**：
1. 边界处理：插入0和n+1避免查询越界
2. 前驱后继查找：利用set的lower_bound特性
3. 时间复杂度优化：将暴力O(n)查询优化为O(logn)

# 【题解评分】
1. 66666a（STL set）：★★★★★  
   亮点：代码简洁高效（仅40行），利用STL特性巧妙实现，时间复杂度O(mlogn)
2. LordLeft（Treap）：★★★★☆  
   亮点：完整实现平衡树，演示核心前驱/后继查找逻辑
3. Hugo_Minion（FHQ-Treap）：★★★★☆  
   亮点：非旋转Treap实现，操作时间复杂度严格O(logn)

# 【最优思路提炼】
**核心技巧**：  
```cpp
set<int> s;
auto right = s.lower_bound(x); // 首个>=x的元素
auto left = prev(right);        // 前一个元素
ans = *right - *left - 1;
```

**实现要点**：
1. 插入初始边界值：s.insert(0), s.insert(n+1)
2. 查询时特判元素是否在集合中
3. 用栈实现撤销操作的O(1)时间维护

# 【同类题目推荐】
1. P3369 【模板】普通平衡树 → 练习基本平衡树操作
2. P3391 【模板】文艺平衡树 → 区间翻转操作
3. P6136 【模板】普通平衡树（数据加强版）→ 高性能平衡树实现

# 【可视化设计】
**动画方案**：
1. 像素风格显示n个房屋，初始为绿色（完好）
2. D操作：目标房屋变红（摧毁），插入set时显示二分查找过程
3. Q操作：高亮查询位置，显示前驱（左蓝框）和后继（右蓝框）
4. R操作：栈顶元素变回绿色，set中对应元素消失

**交互功能**：
```javascript
// 伪代码示例
class Visualizer {
  constructor(n) {
    this.canvas = document.getElementById("grid"); // 800x600像素画布
    this.houses = Array(n+2).fill(0); // 0和n+1为边界
    this.s = new Set([0, n+1]);
  }

  // 摧毁操作动画
  async destroy(x) {
    highlight(x, 'red');
    await insertToSet(x); // 显示二分查找插入过程
    stack.push(x);
  }

  // 查询操作动画
  async query(x) {
    if (s.has(x)) return 0;
    let right = s.lower_bound(x); // 高亮二分查找过程
    let left = right.prev();
    drawRect(left, 'blue'); 
    drawRect(right, 'blue');
    return right - left - 1;
  }
}
```

**复古特效**：
- 8-bit音效：
  - 摧毁：NES风格爆炸声（短促"嘭"）
  - 修复：恢复音效（水滴声）
  - 查询：电子"滴"声
- 像素字体显示操作日志
- 过关效果：连续正确查询3次触发烟花动画

# 【核心代码实现】
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m, x;
    char op;
    stack<int> undo_stack;
    set<int> s = {0, n+1}; // 初始化边界
    
    while(m--) {
        cin >> op;
        if(op == 'D') {
            cin >> x;
            s.insert(x);
            undo_stack.push(x);
        } 
        else if(op == 'R') {
            s.erase(undo_stack.top());
            undo_stack.pop();
        }
        else if(op == 'Q') {
            cin >> x;
            if(s.count(x)) cout << 0 << endl;
            else {
                auto right = s.upper_bound(x);
                auto left = prev(right);
                cout << *right - *left -1 << endl;
            }
        }
    }
}
```

# 【关键调试心得】
1. 边界陷阱：未插入n+1时，查询最右侧房屋会越界
2. lower_bound误用：应使用upper_bound保证右边界严格大于x
3. 撤销顺序：栈必须严格后进先出，否则会破坏操作时序性

# 【学习启示】
通过本题可掌握**有序集合维护动态区间**的核心方法，该模式在以下场景通用：
1. 动态维护区间合并（如P2894酒店）
2. 最近邻查询（如P3373区间最值）
3. 离散事件处理（如P2286宠物收养场）

掌握set的lower_bound/upper_bound用法，能大幅简化区间边界的处理逻辑。

---
处理用时：89.41秒
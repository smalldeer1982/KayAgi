# 题目信息

# [NOIP 2018 普及组] 对称二叉树

## 题目背景

NOIP2018 普及组 T4

## 题目描述

一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树： 

1.  二叉树； 
2.  将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。   

下图中节点内的数字为权值，节点外的 $id$ 表示节点编号。  

![](https://cdn.luogu.com.cn/upload/image_hosting/nkln7z1l.png)

现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数最多。请输出这棵子树的节点数。   

注意：只有树根的树也是对称二叉树。本题中约定，以节点 $T$ 为子树根的一棵“子 树”指的是：节点$T$ 和它的全部后代节点构成的二叉树。 

## 说明/提示

**样例 1 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/4lfen5aa.png)    
最大的对称二叉子树为以节点 $2$ 为树根的子树，节点数为 $1$。   

**样例 2 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/vhzzc587.png)

最大的对称二叉子树为以节点 $7$ 为树根的子树，节点数为 $3$。 

**数据规模与约定**

共 $25$ 个测试点。    

$v_i ≤ 1000$。 

- 测试点 $1 \sim 3, n ≤ 10$，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。 
- 测试点 $4 \sim 8, n ≤ 10$。
- 测试点 $9 \sim 12, n ≤ 10^5$，保证输入是一棵“满二叉树” 。 
- 测试点 $13 \sim 16, n ≤ 10^5$，保证输入是一棵“完全二叉树”。
- 测试点 $17 \sim 20, n ≤ 10^5$，保证输入的树的点权均为 $1$。
- 测试点 $21 \sim 25, n ≤ 10^6$。

本题约定： 

层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 $1$。 
 
 树的深度：树中节点的最大层次称为树的深度。 
 
 满二叉树：设二叉树的深度为 $h$，且二叉树有 $2^h-1$ 个节点，这就是满二叉树。  

![](https://cdn.luogu.com.cn/upload/image_hosting/8tof1fxx.png)

完全二叉树：设二叉树的深度为 $h$，除第 $h$ 层外，其它各层的结点数都达到最大 个数，第 $h$ 层所有的结点都连续集中在最左边，这就是完全二叉树。  

![](https://cdn.luogu.com.cn/upload/image_hosting/ibo7js1f.png)

## 样例 #1

### 输入

```
2 
1 3 
2 -1 
-1 -1 
```

### 输出

```
1```

## 样例 #2

### 输入

```
10 
2 2 5 5 5 5 4 4 2 3 
9 10 
-1 -1 
-1 -1 
-1 -1 
-1 -1 
-1 2 
3 4 
5 6 
-1 -1 
7 8```

### 输出

```
3```

# AI分析结果



# [NOIP 2018 普及组] 对称二叉树 - 题解分析

## 唯一算法分类
树形递归遍历 + 剪枝优化

---

## 综合分析与结论
### 核心思路
所有题解的核心都是通过递归判断左右子树对称性。最优解法通过预处理子树大小，结合以下核心步骤：
1. **预处理子树大小**：通过DFS预处理每个节点的子树节点数
2. **对称性判断**：递归比较左子树的左节点与右子树的右节点，左子树的右节点与右子树的左节点
3. **剪枝优化**：当左右子树大小不等时直接返回不对称

### 解决难点
- **结构对称判断**：通过交叉递归（左左 vs 右右，左右 vs 右左）解决镜像对称问题
- **复杂度控制**：通过子树大小剪枝，将时间复杂度优化至O(n log n)
- **权值匹配**：在递归过程中同步验证节点权值是否相等

---

## 题解评分（≥4星）

### 1. wsm52（5星）
**亮点**：
- 最简洁的递归实现（仅20行核心代码）
- 完美融合子树大小剪枝与权值判断
- 附带时间复杂度证明（启发式合并思想）

### 2. qhr2023（5星）
**亮点**：
- 清晰的递归逻辑分层展示
- 包含详细的复杂度数学推导
- 代码附带中文注释说明关键步骤

### 3. WsW_（4星）
**亮点**：
- 提出显式剪枝条件（size相等才递归）
- 包含复杂度证明的直观解释
- 代码结构模块化便于调试

---

## 最优思路与技巧提炼
### 关键代码实现
```cpp
bool check(int x, int y) {
    if(x==-1 && y==-1) return true;    // 双空对称
    if(x==-1 || y==-1) return false;   // 结构不对称
    if(val[x] != val[y]) return false; // 权值不匹配
    // 交叉递归判断
    return check(l[x], r[y]) && check(r[x], l[y]);
}
```

### 核心优化点
1. **子树大小剪枝**：预处理size后，比较时先判断`size[l] == size[r]`
2. **尾递归优化**：优先处理较小子树（类似启发式合并）
3. **短路逻辑**：使用`&&`运算提前终止无效判断

---

## 同类型题推荐
1. [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)（基础镜像判断）
2. [572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)（子树匹配问题）
3. [P1305 新二叉树](https://www.luogu.com.cn/problem/P1305)（树结构重建与遍历）

---

## 可视化算法设计
### 动画方案
1. **树形结构展示**：Canvas绘制二叉树，当前比较节点用红色边框标记
2. **递归路径高亮**：
   - 左子树路径：蓝色箭头（`l[x] -> r[y]`）
   - 右子树路径：绿色箭头（`r[x] -> l[y]`）
3. **状态提示板**：显示当前比较节点对和递归深度

### 复古像素风格
```javascript
// 像素节点绘制示例
function drawNode(x, y, val, isActive) {
    ctx.fillStyle = isActive ? '#FF5555' : '#5555FF';
    ctx.fillRect(x*40, y*40, 30, 30); // 30px方块
    ctx.fillStyle = '#FFF';
    ctx.fillText(val, x*40+8, y*40+20);
}
```

### 音效设计
- **节点匹配成功**：8-bit短促"哔"声（440Hz方波）
- **结构不匹配**：低沉"嘟"声（220Hz方波）
- **递归返回**：逐层音调升高（模拟调用栈弹出）

---

## 调试心得摘录
> "在完全对称的满二叉树测试时，发现递归深度达到20层仍能快速响应，验证了O(n log n)的复杂度预期。关键是通过size剪枝避免了对大规模不对称子树的无意义判断。" —— wsm52题解评论区

> "最初未考虑权值匹配顺序，将val判断放在递归调用之后，导致部分case误判。调整判断顺序后AC率大幅提升。" —— qhr2023代码注释

---

## 拓展思考
对于N=1e6的极端数据，可结合以下优化：
1. **迭代式DFS**：避免递归栈溢出
2. **哈希加速**：预处理子树特征哈希值
3. **并行判断**：对左右子树判断启用多线程

但实际在OJ环境中，简洁的递归实现已足够应对题目数据规模。

---
处理用时：78.85秒
# 题目信息

# [CSP-S2019] 括号树

## 题目背景

本题中**合法括号串**的定义如下：
1.	`()` 是合法括号串。
2.	如果 `A` 是合法括号串，则 `(A)` 是合法括号串。
3.	如果 `A`，`B` 是合法括号串，则 `AB` 是合法括号串。

本题中**子串**与**不同的子串**的定义如下：
1.	字符串 `S` 的子串是 `S` 中**连续**的任意个字符组成的字符串。`S` 的子串可用起始位置 $l$ 与终止位置 $r$ 来表示，记为 $S (l, r)$（$1 \leq l \leq r \leq |S |$，$|S |$ 表示 S 的长度）。
2.	`S` 的两个子串视作不同**当且仅当**它们在 `S` 中的位置不同，即 $l$ 不同或 $r$ 不同。

## 题目描述

一个大小为 $n$ 的树包含 $n$ 个结点和 $n - 1$ 条边，每条边连接两个结点，且任意两个结点间**有且仅有**一条简单路径互相可达。

小 Q 是一个充满好奇心的小朋友，有一天他在上学的路上碰见了一个大小为 $n$ 的树，树上结点从 $1 \sim n$ 编号，$1$ 号结点为树的根。除 $1$ 号结点外，每个结点有一个父亲结点，$u$（$2 \leq u \leq n$）号结点的父亲为 $f_u$（$1 ≤ f_u < u$）号结点。

小 Q 发现这个树的每个结点上**恰有**一个括号，可能是`(` 或`)`。小 Q 定义 $s_i$ 为：将根结点到 $i$ 号结点的简单路径上的括号，按结点经过顺序依次排列组成的字符串。
 
显然 $s_i$ 是个括号串，但不一定是合法括号串，因此现在小 Q 想对所有的 $i$（$1\leq i\leq n$）求出，$s_i$ 中有多少个**互不相同的子串**是**合法括号串**。
 
这个问题难倒了小 Q，他只好向你求助。设 $s_i$ 共有 $k_i$ 个不同子串是合法括号串， 你只需要告诉小 Q 所有 $i \times k_i$ 的异或和，即：
$$ (1 \times k_1)\ \text{xor}\ (2 \times k_2)\ \text{xor}\ (3 \times k_3)\ \text{xor}\ \cdots\ \text{xor}\ (n \times k_n) $$
其中 $xor$ 是位异或运算。

## 说明/提示

【样例解释1】

树的形态如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/10z2scex.png)

将根到 1 号结点的简单路径上的括号，按经过顺序排列所组成的字符串为 `(`，子串是合法括号串的个数为 $0$。

将根到 2 号结点的字符串为 `((`，子串是合法括号串的个数为 $0$。

将根到 3 号结点的字符串为 `()`，子串是合法括号串的个数为 $1$。

将根到 4 号结点的字符串为 `(((`，子串是合法括号串的个数为 $0$。

将根到 5 号结点的字符串为 `(()`，子串是合法括号串的个数为 $1$。

【数据范围】

![](https://cdn.luogu.com.cn/upload/image_hosting/1k6fabxr.png)


## 样例 #1

### 输入

```
5
(()()
1 1 2 2```

### 输出

```
6```

# AI分析结果



# [CSP-S2019] 括号树题解分析

## 算法分类
**栈 + 树形动态规划**

---

## 题解思路与核心难点

### 核心思路
所有题解的核心思想均围绕**栈的括号匹配特性**与**动态规划递推**展开：
1. **栈维护未匹配的左括号**：遍历路径时，遇到左括号入栈，右括号尝试匹配栈顶左括号。
2. **动态规划递推合法子串数**：定义 `lst[i]` 表示以节点 `i` 结尾的合法子串数，`sum[i]` 表示根到 `i` 的总合法子串数。递推公式为：
   - 若 `i` 是右括号且匹配成功，则 `lst[i] = lst[匹配左括号的父节点] + 1`
   - `sum[i] = sum[父节点] + lst[i]`
3. **树的回溯处理**：DFS遍历树时，需在递归返回时恢复栈状态，避免不同分支的干扰。

### 解决难点对比
| 题解作者 | 核心数据结构 | 回溯处理方式 | 时间复杂度 | 空间复杂度 |
|----------|--------------|--------------|------------|------------|
| Inkyo    | 栈、lst、sum | 手动保存栈顶 | O(n)       | O(n)       |
| xht      | 前缀和数组   | 离线桶统计   | O(n)       | O(n)       |
| Aleph1022| 动态规划数组 | 状态压缩     | O(n)       | O(n)       |

**最优思路提炼**：Inkyo的栈+动态规划方法思路清晰，代码简洁，适合快速理解与实现。

---

## 题解评分（≥4星）

1. **Inkyo（5星）**  
   - **亮点**：从暴力到链再到树的推导清晰，代码可读性强，回溯处理巧妙。
   - **代码片段**：
     ```cpp
     void dfs(int x) {
         int tmp = 0;
         if (c[x] == ')') {
             if (top) {
                 tmp = s[top];
                 lst[x] = lst[fa[tmp]] + 1;
                 top--;
             }
         } else if (c[x] == '(') s[++top] = x;
         sum[x] = sum[fa[x]] + lst[x];
         for (int v : children[x]) dfs(v);
         if (tmp) s[++top] = tmp; // 回溯恢复栈
         else if (top) top--;
     }
     ```

2. **万弘（4星）**  
   - **亮点**：简洁的栈操作与贡献值计算，明确区分新增子串的逻辑。
   - **代码片段**：
     ```cpp
     while (匹配左括号) {
         res += 父节点贡献;
         pop栈顶;
     }
     ```

3. **JayJessy（4星）**  
   - **亮点**：8位像素风格动画演示，交互式回溯展示，音效增强理解。

---

## 可视化算法演示设计

### 动画方案
1. **栈状态可视化**：  
   - **颜色标记**：左括号为绿色方块，右括号为红色方块，匹配时高亮黄色边框。
   - **动态变化**：入栈时方块从节点飞入栈区，匹配时弹出并显示连线到当前右括号。

2. **树遍历过程**：  
   - **路径高亮**：DFS路径用蓝色线条连接，当前节点闪烁显示。
   - **数据更新**：实时显示 `lst[i]` 和 `sum[i]` 的数值变化。

3. **复古像素风格**：  
   - **Canvas绘制**：树节点用8位像素方块表示，括号类型用不同颜色区分。
   - **音效设计**：匹配成功播放“叮”声，回溯时“咔嚓”声，错误匹配低沉音效。

### 交互控制
- **步进控制**：支持暂停/继续、单步执行、速度调节（1x, 2x, 5x）。
- **AI自动演示**：自动按DFS顺序遍历节点，可随时切换手动模式。

---

## 同类型题推荐
1. **P1944 最长括号匹配**（栈匹配 + 动态规划）
2. **P4205 括号生成器**（合法括号生成与计数）
3. **P2141 广义括号序列**（树形结构扩展）

---

## 个人心得摘录
> "考场上一定要先想部分分，正解往往由此演化而来。回溯时忘记恢复栈顶导致WA，调试两小时才找到问题。" —— Inkyo  
> "将树问题拆解为链处理，再考虑父子关系传递，是化繁为简的关键。" —— xht

---

## 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
vector<int> G[N];
int fa[N], stk[N], top;
long long lst[N], sum[N];
char s[N];

void dfs(int u) {
    int tmp = 0;
    if (s[u] == ')') {
        if (top) {
            tmp = stk[top];
            lst[u] = lst[fa[tmp]] + 1;
            top--;
        }
    } else if (s[u] == '(') stk[++top] = u;
    sum[u] = sum[fa[u]] + lst[u];
    for (int v : G[u]) dfs(v);
    if (tmp) stk[++top] = tmp; // 回溯恢复
    else if (top) top--;
}

int main() {
    int n; scanf("%d%s", &n, s+1);
    for (int i=2; i<=n; ++i) {
        scanf("%d", &fa[i]);
        G[fa[i]].push_back(i);
    }
    dfs(1);
    long long ans=0;
    for(int i=1; i<=n; ++i) ans ^= i*sum[i];
    printf("%lld", ans);
}
```

---
处理用时：82.82秒
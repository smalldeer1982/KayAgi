# 题目信息

# [蓝桥杯 2013 国 C] 横向打印二叉树

## 题目背景

二叉树可以用于排序。

## 题目描述

其原理很简单：对于一个排序二叉树添加新节点时，先与根节点比较，若小则交给左子树继续处理，否则交给右子树。

当遇到空子树时，则把该节点放入那个位置。

比如，`10 8 5 7 12 4` 的输入顺序，应该建成二叉树如图 $1$ 所示。

本题目要求：根据已知的数字，建立排序二叉树，并在标准输出中横向打印该二叉树。


## 说明/提示

样例解释 1：

![](https://cdn.luogu.com.cn/upload/image_hosting/4z42ybq4.png)

时限 1 秒, 64M。蓝桥杯 2013 年第四届国赛

## 样例 #1

### 输入

```
10 8 5 7 12 4```

### 输出

```
...|-12
10-|
...|-8-|
.......|...|-7
.......|-5-|
...........|-4```

## 样例 #2

### 输入

```
10 5 20```

### 输出

```
...|-20
10-|
...|-5```

## 样例 #3

### 输入

```
5 10 20 8 4 7```

### 输出

```
.......|-20
..|-10-|
..|....|-8-|
..|........|-7
5-|
..|-4```

# AI分析结果



**唯一算法分类**  
树的应用（模拟与遍历）

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
所有题解均围绕 **构建排序二叉树** 和 **横向打印布局** 展开，核心难点在于如何确定节点在字符矩阵中的位置及父子节点间的连接线。关键步骤如下：
1. **构建二叉树**：递归或循环插入节点，根据大小关系分配左右子树。
2. **横向输出逻辑**：采用 **右-根-左** 的中序变种遍历，确保右子树在上、左子树在下。
3. **字符填充**：递归计算每个节点前的空格数（`space` 或 `sum`），处理 `|-`、数字、`-|`。
4. **连接线处理**：记录节点的行号，通过父子节点的行范围在特定列填充 `|`。

#### **解决难点对比**
| 题解作者       | 关键技巧                                                                                     | 数据结构与辅助方法                                                                 |
|----------------|--------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| **冷却心**     | 全局字符数组 `mp[][]` 存储结果，递归后反向调整连接线（行覆盖 `|`）。                           | `nowL` 记录当前行，`line[]` 存储节点行号，三元运算符处理根节点和叶子节点的符号。           |
| **Wing_**      | 结构体存储节点的行号、列号，递归后通过 `work()` 函数统一填充连接线。                            | `c[][]` 字符数组，`sum` 参数动态计算空格数，`tr[u].z` 记录节点起始列。                    |
| **ChampionCyan**| 循环插入节点，`work()` 函数统一处理字符填充，递归后根据 `line[]` 调整连接线。                   | `ans[][]` 字符数组，`front` 计算增量空格，`eof` 标记行结束，`line[]` 记录行号。             |
| **jsisonx**    | 预处理子树节点数（`suml` 和 `sumr`），动态规划确定行号，递归构建字符数组。                      | 结构体存储子树大小，`id_set()` 函数计算行号，`map_set()` 处理字符填充和连接线。             |

---

### **题解评分 (≥4星)**

1. **冷却心（4.5星）**  
   - **亮点**：全局字符数组 + 行号反向覆盖，逻辑清晰，代码简洁。  
   - **代码可读性**：结构明确，递归逻辑易于理解。  
   - **优化点**：连接线处理高效，覆盖冲突解决巧妙。

2. **Wing_（4星）**  
   - **亮点**：结构体存储行列号，`work()` 函数统一处理连接线，层次分明。  
   - **代码可读性**：注释详细，变量命名规范。  
   - **优化点**：预处理父子行号范围，避免重复计算。

3. **ChampionCyan（4星）**  
   - **亮点**：循环插入节点，`eof` 标记行结束，代码简洁高效。  
   - **代码可读性**：函数分工明确，递归逻辑清晰。  
   - **优化点**：`line[]` 数组记录行号，减少全局变量依赖。

---

### **最优思路或技巧提炼**
1. **右-根-左遍历**：确保右子树先处理，形成“上右-中-下左”的横向布局。
2. **字符增量计算**：递归传递 `space` 参数，动态计算节点前的空格数（如 `Add = num.size() + 3`）。
3. **连接线覆盖法**：父子节点确定后，在特定列的行范围内填充 `|`（如 `for (i = L; i >= now)`）。
4. **全局字符数组**：使用二维数组预存输出结果，避免实时输出格式错乱。

---

### **同类型题或类似算法套路**
- **通用解法**：树的中序遍历 + 层次化字符填充（如表达式树打印、目录树结构）。
- **类似题目**：  
  - [P1020 二叉树的层序遍历](https://www.luogu.com.cn/problem/P1020)  
  - [P1305 新二叉树](https://www.luogu.com.cn/problem/P1305)  
  - [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)

---

### **可视化与算法演示**
**动画设计**：  
1. **构建二叉树**：动态展示节点插入过程，高亮当前比较的节点和路径。
2. **字符填充**：递归步骤可视化，逐行显示 `space` 计算和字符填充，红色高亮当前处理节点。
3. **连接线调整**：父子节点确定后，绿色高亮连接线覆盖的列和行范围。

**复古游戏化效果**：  
- **像素风格**：节点用 8-bit 方块表示，连接线用像素点阵绘制。  
- **音效设计**：  
  - 插入节点：短促“滴”声。  
  - 填充字符：连续“咔嗒”声。  
  - 完成连接线：上扬音效。  
- **自动演示**：按空格键逐步执行，支持调速和回退。

**代码片段（连接线覆盖逻辑）**：
```cpp
// 冷却心题解中的连接线处理
if (tree[ls(p)] != -1) {
    LL L = line[ls(p)], now = line[p];
    for (LL i = L; i >= now; i--)
        mp[i][ind - 1] = '|'; // 在特定列填充竖线
}
```

---

### **个人心得摘录**
- **冷却心**：  
  > “覆盖冲突通过 `if (mp[nowL][++ind] != '|')` 解决，避免后续空格覆盖已绘制的 `|`。”  
- **Wing_**：  
  > “右根左遍历是关键，否则行顺序会错乱。预处理行列号让连接线处理更系统。”  

---

### **推荐相似题目**
1. **P1053 表达式树打印**（横向输出表达式树）  
2. **P1271 目录树**（树形结构字符输出）  
3. **P1364 二叉树输出**（层次化打印变种）

---
处理用时：101.72秒
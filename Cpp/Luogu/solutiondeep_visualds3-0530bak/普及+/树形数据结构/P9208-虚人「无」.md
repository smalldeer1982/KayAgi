# 题目信息

# 虚人「无」

## 题目背景

一点也不美丽的不死鸟。

那双锐爪，沾染了无辜的鲜血。

## 题目描述

给定二元序列 $\{(v_i,c_i)\}$ 和一棵以 $1$ 为根的有根树。第 $i$ 个点的点权是 $(v_i,c_i)$。

- 定义一个非根节点的权值为其子树内的 $c$ 的积乘上其子树补的 $v$ 的积。
- 定义一个根节点的权值为其子树内的 $c$ 的积。

形式化的讲，若 $u$ 不为根节点，则 $u$ 的权值 $f_u$ 为：

$$f_u=\prod\limits_{v\in \operatorname{substree}(u)} c_v\times \prod\limits_{v\notin \operatorname{substree}(u)} v_v$$

否则，其权值 $f_u$ 为：

$$f_u=\prod\limits_{v=1}^n c_v$$

试求整棵树**所有节点的权值之和**，答案对 $m$ 取模。请注意：**保证 $\bm m$ 是质数**。




## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/olehwn2w.png)

（图片有误，应该交换 $v,c$ 的权值。）

### 数据范围及约定

对于 $100\%$ 的数据，满足 $1\le n\leq 3\times 10^5$，$1\leq v_i,c_i,m\leq 10^9$。


## 样例 #1

### 输入

```
3 998244853
1 2
1 3
2 1 2
1 2 2```

### 输出

```
10```

## 样例 #2

### 输入

```
5 998244353
1 2
1 3
1 4
4 5
5 5 5 2 3
6 6 1 5 3```

### 输出

```
4656```

# AI分析结果



## 算法分类
**树形DP + 前缀积与后缀积**

---

## 题解思路与解决难点

### 核心思路
1. **DFS序与子树区间**  
   通过DFS遍历树，记录每个节点的进入时间戳（`dfn`）和子树大小（`sz`），使得每个子树对应DFS序中的连续区间 `[dfn[i], dfn[i]+sz[i]-1]`。

2. **子树内的乘积计算**  
   在DFS过程中，通过树形DP计算每个节点的子树内所有`c`的乘积（记为`sc[i]`）。

3. **子树外的乘积优化**  
   - **前缀积**：预处理DFS序中每个位置之前所有`v`的乘积。
   - **后缀积**：预处理DFS序中每个位置之后所有`v`的乘积。  
   子树外的`v`乘积 = 前缀积到`dfn[i]-1` × 后缀积从`dfn[i]+sz[i]`开始。

### 解决难点
- **避免逆元**：通过前缀积和后缀积直接计算子树外的乘积，无需涉及模运算中的逆元，解决了`v`或`c`为模数倍数时的不可逆问题。
- **高效查询**：利用DFS序的连续性，将子树内外分解为区间乘积，时间复杂度优化至线性。

---

## 题解评分（≥4星）

1. **Emily666（5星）**  
   - **亮点**：代码简洁，利用前缀积和后缀积实现O(n)复杂度，无需复杂数据结构，边界处理清晰。
   - **心得**：明确提到避免逆元的关键思想，直接DFS序处理子树区间。

2. **翟翟（4星）**  
   - **亮点**：使用链式前向星优化树遍历，结构清晰。
   - **改进点**：未明确处理模数为质数时的特殊情况，但代码简洁性较强。

3. **InoueTakina（4星）**  
   - **亮点**：通过`L`和`R`数组快速定位子树区间，代码结构紧凑。
   - **改进点**：变量命名较为简略，可读性稍弱。

---

## 最优思路与技巧提炼

### 关键步骤
1. **DFS预处理**  
   ```cpp
   void dfs(int x, int fa) {
       dfn[x] = ++cnt;         // 记录进入时间戳
       sz[x] = 1;              // 子树大小初始化
       for (auto y : e[x]) {
           if (y == fa) continue;
           dfs(y, x);
           sz[x] += sz[y];     // 累加子树大小
           sc[x] = sc[x] * sc[y] % mod; // 子树c乘积
       }
   }
   ```
2. **前缀与后缀积计算**  
   ```cpp
   pre[0] = 1;
   for (int i = 1; i <= n; i++) 
       pre[i] = pre[i-1] * v[dfn[i]] % mod;
   suf[n+1] = 1;
   for (int i = n; i >= 1; i--)
       suf[i] = suf[i+1] * v[dfn[i]] % mod;
   ```

3. **权值求和**  
   ```cpp
   ans = sc[1]; // 根节点权值
   for (int i = 2; i <= n; i++) {
       int L = dfn[i], R = dfn[i] + sz[i] - 1;
       ll outside = pre[L-1] * suf[R+1] % mod;
       ans = (ans + sc[i] * outside) % mod;
   }
   ```

### 技巧总结
- **连续区间优化**：利用DFS序的连续性，将子树操作转化为区间操作。
- **分治乘积**：将全局乘积分解为前缀和后缀，避免逆元问题。

---

## 相似题目推荐
1. **P3379 【模板】最近公共祖先（LCA）**  
   - 使用DFS序处理树结构区间。

2. **P3384 【模板】轻重链剖分**  
   - 树链剖分中的子树区间处理。

3. **P3919 【模板】可持久化线段树**  
   - 区间乘积维护的变种应用。

---

## 可视化设计要点

### 动画演示
1. **DFS遍历高亮**  
   - **颜色标记**：当前DFS访问的节点以绿色高亮，回溯时变为蓝色。
   - **子树区间**：每次回溯时，用红色框标记当前节点的子树区间`[dfn, dfn+sz-1]`。

2. **乘积计算展示**  
   - **前缀/后缀积**：用滑动条动态显示前缀和后缀的覆盖范围，如子树外部分为黄色（前缀）和紫色（后缀）。
   - **实时更新**：点击节点时，显示其子树内`c`乘积和子树外`v`乘积的数值变化。

### 复古像素风格
- **8位色调色板**：绿色表示活跃节点，红色表示子树区间，黄色/紫色表示前缀/后缀。
- **音效设计**：  
  - **DFS步骤**：播放短促“滴”声。
  - **区间标记**：播放轻微“咔嚓”声。
  - **计算完成**：播放胜利音效。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 3e5 + 5;

vector<int> e[N];
ll c[N], v[N], sc[N], pre[N], suf[N];
int dfn[N], sz[N], n, mod, cnt;

void dfs(int u, int fa) {
    dfn[u] = ++cnt;
    sz[u] = 1;
    sc[u] = c[u];
    for (int v : e[u]) {
        if (v == fa) continue;
        dfs(v, u);
        sz[u] += sz[v];
        sc[u] = sc[u] * sc[v] % mod;
    }
}

int main() {
    cin >> n >> mod;
    for (int i = 1; i < n; i++) {
        int u, v; cin >> u >> v;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    for (int i = 1; i <= n; i++) cin >> c[i];
    for (int i = 1; i <= n; i++) cin >> v[i];
    
    dfs(1, 0);
    // 按DFS序重新排列v
    vector<ll> v_dfn(n + 1);
    for (int i = 1; i <= n; i++) v_dfn[dfn[i]] = v[i];
    
    // 计算前缀积和后缀积
    pre[0] = 1;
    for (int i = 1; i <= n; i++) 
        pre[i] = pre[i - 1] * v_dfn[i] % mod;
    suf[n + 1] = 1;
    for (int i = n; i >= 1; i--)
        suf[i] = suf[i + 1] * v_dfn[i] % mod;
    
    ll ans = sc[1] % mod;
    for (int i = 2; i <= n; i++) {
        int L = dfn[i], R = L + sz[i] - 1;
        ll outside = (L > 1 ? pre[L - 1] : 1) * (R < n ? suf[R + 1] : 1) % mod;
        ans = (ans + sc[i] * outside) % mod;
    }
    cout << ans << endl;
    return 0;
}
```

---
处理用时：132.96秒
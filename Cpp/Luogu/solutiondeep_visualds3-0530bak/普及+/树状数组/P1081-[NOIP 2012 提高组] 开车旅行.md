# 题目信息

# [NOIP 2012 提高组] 开车旅行

## 题目描述

小 $\text{A}$ 和小 $\text{B}$ 决定利用假期外出旅行，他们将想去的城市从 $1 $ 到 $n$ 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 $i$ 的海拔高度为$h_i$，城市 $i$ 和城市 $j$ 之间的距离 $d_{i,j}$ 恰好是这两个城市海拔高度之差的绝对值，即 $d_{i,j}=|h_i-h_j|$。
 
旅行过程中，小 $\text{A}$ 和小 $\text{B}$ 轮流开车，第一天小 $\text{A}$ 开车，之后每天轮换一次。他们计划选择一个城市 $s$ 作为起点，一直向东行驶，并且最多行驶 $x$ 公里就结束旅行。    

小 $\text{A}$ 和小 $\text{B}$ 的驾驶风格不同，小 $\text{B}$ 总是沿着前进方向选择一个最近的城市作为目的地，而小 $\text{A}$ 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 $x$ 公里，他们就会结束旅行。

在启程之前，小 $\text{A}$ 想知道两个问题：

1、 对于一个给定的 $x=x_0$，从哪一个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值最小（如果小 $\text{B}$ 的行驶路程为 $0$，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。

2、对任意给定的 $x=x_i$ 和出发城市 $s_i$，小 $\text{A}$ 开车行驶的路程总数以及小 $\text B$ 行驶的路程总数。


## 说明/提示

【样例1说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/zgms0k7y.png)

各个城市的海拔高度以及两个城市间的距离如上图所示。

如果从城市 $1$ 出发，可以到达的城市为 $2,3,4$，这几个城市与城市 $1$ 的距离分别为 $1,1,2$，但是由于城市 $3$ 的海拔高度低于城市 $2$，所以我们认为城市 $3$ 离城市 $1$ 最近，城市 $2$ 离城市 $1$ 第二近，所以小A会走到城市 $2$。到达城市 $2$ 后，前面可以到达的城市为 $3,4$，这两个城市与城市 $2$  的距离分别为 $2,1$，所以城市 $4$ 离城市 $2$ 最近，因此小B会走到城市$4$。到达城市 $4$ 后，前面已没有可到达的城市，所以旅行结束。

如果从城市 $2$ 出发，可以到达的城市为 $3,4$，这两个城市与城市 $2$ 的距离分别为 $2,1$，由于城市 $3$ 离城市 $2$ 第二近，所以小 $\text A$ 会走到城市 $3$。到达城市 $3$ 后，前面尚未旅行的城市为 $4$，所以城市 $4$ 离城市 $3$ 最近，但是如果要到达城市 $4$，则总路程为 $2+3=5>3$，所以小 $\text B$ 会直接在城市 $3$ 结束旅行。

如果从城市 $3$ 出发，可以到达的城市为 $4$，由于没有离城市 $3$ 第二近的城市，因此旅行还未开始就结束了。

如果从城市 $4$ 出发，没有可以到达的城市，因此旅行还未开始就结束了。


【样例2说明】

当 $x=7$ 时，如果从城市 $1$ 出发，则路线为 $1 \to 2 \to 3 \to 8 \to 9$，小 $\text A$ 走的距离为 $1+2=3$，小 $\text B$ 走的距离为 $1+1=2$。（在城市 $1$ 时，距离小 $\text A$ 最近的城市是 $2$ 和 $6$，但是城市 $2$ 的海拔更高，视为与城市 $1$ 第二近的城市，所以小 $\text A$ 最终选择城市 $2$；走到$9$ 后，小 $\text A$ 只有城市 $10$ 可以走，没有第二选择可以选，所以没法做出选择，结束旅行）

如果从城市 $2$ 出发，则路线为 $2 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $3$ 出发，则路线为 $3 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $4$ 出发，则路线为 $4 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $5$ 出发，则路线为 $5 \to 7 \to 8$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $5,1$。

如果从城市 $6$ 出发，则路线为 $6 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$5,1$。

如果从城市 $7$ 出发，则路线为 $7 \to 9 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $8$ 出发，则路线为 $8 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,0$。

如果从城市 $9$ 出发，则路线为 $9$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $0,0$（旅行一开始就结束了）。

如果从城市 $10$ 出发，则路线为 $10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$0,0$。

从城市 $2$ 或者城市 $4$ 出发小 $\text A$ 行驶的路程总数与小 $\text B$ 行驶的路程总数的比值都最小，但是城市 $2$ 的海拔更高，所以输出第一行为 $2$。

【数据范围与约定】  

对于 $30\%$ 的数据，有$1\le n \le 20,1\le m\le 20$；  
对于$40\%$ 的数据，有$1\le n \le 100,1\le m\le 100$；  
对于 $50\%$ 的数据，有$1\le n \le 100,1\le m\le 1000$；  
对于 $70\%$ 的数据，有$1\le n \le 1000,1\le m\le 10^4$；   
对于 $100\%$ 的数据：$1\le n,m \le 10^5$，$-10^9 \le h_i≤10^9$，$1 \le s_i \le n$，$0 \le x_i \le 10^9$   
数据保证 $h_i$ 互不相同。


## 样例 #1

### 输入

```
4 
2 3 1 4 
3 
4 
1 3 
2 3 
3 3 
4 3
```

### 输出

```
1 
1 1 
2 0 
0 0 
0 0 ```

## 样例 #2

### 输入

```
10 
4 5 6 1 2 3 7 8 9 10 
7 
10 
1 7 
2 7 
3 7 
4 7 
5 7 
6 7 
7 7 
8 7 
9 7 
10 7```

### 输出

```
2 
3 2 
2 4 
2 1 
2 4 
5 1 
5 1 
2 1 
2 0 
0 0 
0 0```

# AI分析结果



## 算法分类
倍增、双向链表预处理

## 题解思路与解决难点
### 核心思路
1. **双向链表预处理**：按海拔排序后，通过链表动态维护当前城市东侧的候选城市，快速找到每个城市的最近（B的选择）和次近（A的选择）城市。
2. **倍增优化查询**：构建跳跃表记录走2^k步后的位置及行驶距离，将单次查询复杂度从O(n)降至O(log n)。

### 算法要点
1. **预处理ga/gb数组**：
   - 排序后，对每个城市i，从链表相邻节点中选择距离最近的作为gb[i]，次近的作为ga[i]。
   - 每处理完一个城市i，将其从链表中删除，保证后续处理只考虑东侧城市。
2. **倍增表构建**：
   - `f[i][j][k]`：从城市i出发，k表示当前驾驶员，走2^j天到达的城市。
   - `da/db[i][j][k]`：记录对应行驶距离。
   - 状态转移需分情况处理j=1时的驾驶员交替。

### 解决难点
1. **链表维护的精确性**：需处理边界条件（如首尾节点），确保距离比较时正确包含所有候选。
2. **倍增状态转移**：交替驾驶时需翻转驾驶员标记，确保跳跃逻辑正确。

## 题解评分（≥4星）
1. **yangrunze（5星）**  
   - 思路清晰，详细讲解双向链表预处理过程，代码注释丰富，逻辑严谨。
   - 核心代码片段完整，易复现。
2. **shadow__（4星）**  
   - 提供set替代方案，思路新颖，但未完整展示实现。
   - 链表部分代码稍显复杂，但预处理思路明确。
3. **Tgotp（4星）**  
   - 代码简洁，完整展示链表与倍增实现，适合快速参考。
   - 缺少详细注释，但逻辑清晰。

## 最优思路提炼
**双向链表 + 倍增跳跃**  
1. 排序后动态维护候选城市，保证每次决策仅考虑东侧城市。
2. 通过倍增将路径跳跃优化为对数复杂度，适用于大规模查询。

## 同类题目
1. **P1081 开车旅行**（本题）
2. **P2680 运输计划**（倍增+LCA）
3. **P3953 逛公园**（最短路+动态规划）

## 代码核心实现
### 预处理链表与ga/gb
```cpp
struct City { int h, id, pre, nxt; } city[N];
bool cmp(City a, City b) { return a.h < b.h; }

void preprocess() {
    sort(city+1, city+n+1, cmp);
    for (int i=1; i<=n; ++i) {
        pos[city[i].id] = i;
        city[i].pre = i-1, city[i].nxt = i+1;
    }
    city[1].pre = city[n].nxt = 0;

    for (int i=1; i<=n; ++i) {
        int p = pos[i], p1 = city[p].pre, p2 = city[p].nxt;
        // 选择gb[i]和ga[i]
        if (p1且距离更近) gb[i] = city[p1].id;
        else gb[i] = city[p2].id;
        // 类似逻辑选择ga[i]
        // 删除当前节点
        city[city[p].pre].nxt = city[p].nxt;
        city[city[p].nxt].pre = city[p].pre;
    }
}
```

### 倍增查询
```cpp
pair<int, int> query(int s, int x) {
    int a_dist = 0, b_dist = 0, cur = s, driver = 0;
    for (int j=20; j>=0; --j) {
        if (f[j][cur][driver] && a_dist + b_dist + da[j][cur][driver] + db[j][cur][driver] <= x) {
            a_dist += da[j][cur][driver];
            b_dist += db[j][cur][driver];
            cur = f[j][cur][driver];
            if (j == 0) driver ^= 1; // 交替驾驶员
        }
    }
    return {a_dist, b_dist};
}
```

## 可视化设计
**8位像素风格演示**  
1. **链表维护动画**：
   - 显示排序后的城市海拔，用不同颜色方块表示当前处理节点。
   - 动态展示节点删除过程，高亮前驱/后继指针变化。
2. **倍增跳跃演示**：
   - 用箭头表示跳跃路径，不同颜色区分A/B驾驶。
   - 步进控制：按空格暂停/继续，方向键调整速度。
3. **音效设计**：
   - 节点删除时播放“哔”声，跳跃成功时播放上升音阶。
   - 背景音乐采用8位芯片风格循环旋律。

## 关键调试心得
1. **链表边界处理**：初始未处理首尾节点的pre/nxt，导致越界访问。通过添加边界检查修复。
2. **距离比较逻辑**：当海拔差相同时，需优先选海拔低的城市。比较时需将海拔纳入排序条件。

---
处理用时：75.76秒
# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果



# 中位数题解分析

## 算法分类
**对顶堆**

---

## 题解思路与核心难点
### 核心算法流程
1. **数据结构设计**  
   维护两个堆：
   - 大根堆（存储较小一半的数）
   - 小根堆（存储较大一半的数）
   
2. **插入策略**  
   - 新元素≤大根堆堆顶 → 插入大根堆  
   - 新元素＞大根堆堆顶 → 插入小根堆  

3. **平衡调整**  
   每次插入后检查堆大小差：  
   ```python
   while abs(len(max_heap) - len(min_heap)) > 1:
       if max_heap.size > min_heap.size:
           move max_heap.top to min_heap
       else:
           move min_heap.top to max_heap
   ```

4. **中位数获取**  
   奇数项时，较大的堆顶即为中位数。

---

## 题解评分（≥4星）

### 1. 肖恩Sean的对顶堆法 ★★★★★
- **关键亮点**  
  双堆维护大小差≤1，直接取较大堆顶  
- **代码实现**  
  ```cpp
  priority_queue<int> q1; // 大根堆
  priority_queue<int, vector<int>, greater<int>> q2; // 小根堆
  while (abs(q1.size() - q2.size()) > 1) {
      // 平衡操作...
  }
  ```

### 2. IRipple的动态调整法 ★★★★☆
- **关键亮点**  
  用`mid`变量记录当前中位数，堆间转移更直观  
- **个人心得**  
  "中位数的左边都小于等于它，右边都大于等于它"（堆结构天然符合）

### 3. ysj1173886760的树状数组法 ★★★★☆
- **关键亮点**  
  离散化+权值树状数组，适合大数据范围  
- **实现难点**  
  需处理离散化映射与二分查找逻辑

---

## 最优思路提炼
**对顶堆的核心优化逻辑**  
- **动态平衡**：插入时自动调整堆大小差，保证中位数直接取堆顶  
- **时间复杂度**：每个元素插入/调整为O(log n)，总复杂度O(n log n)  

---

## 可视化设计（像素风格演示）
### 动画方案
1. **元素插入**  
   - 新元素以蓝色像素块从右侧滑入  
   - 根据值大小分流向大根堆（左）或小根堆（右）  

2. **平衡调整**  
   - 堆顶元素标红闪烁，迁移时带拖尾特效  
   - 调整过程用黄色箭头标注移动路径  

3. **中位数标记**  
   - 当前中位数用绿色边框高亮  
   - 每次输出时播放8bit音效（类似《超级马里奥》金币声）

### 交互功能
- **速度调节**：滑块控制动画速度（0.5x~5x）  
- **单步调试**：按空格键逐帧观察堆调整过程  
- **自动演示**：AI模式自动完成插入与平衡（类似贪吃蛇AI）

---

## 同类型题目推荐
1. **P1801 黑匣子**  
   动态维护第k大元素（对顶堆直接应用）
2. **P3871 中位数**  
   带删除操作的动态中位数维护（堆+延迟删除）
3. **P3380 二逼平衡树**  
   树套树综合应用（拓展树状数组/线段树思路）

---

## 代码实现（对顶堆核心片段）
```cpp
priority_queue<int> q1; // 大根堆（存较小一半）
priority_queue<int, vector<int>, greater<int>> q2; // 小根堆（存较大一半）

void insert(int x) {
    if (x <= q1.top()) q1.push(x);
    else q2.push(x);
    
    // 平衡堆大小差
    while (abs((int)q1.size() - (int)q2.size()) > 1) {
        if (q1.size() > q2.size()) {
            q2.push(q1.top());
            q1.pop();
        } else {
            q1.push(q2.top());
            q2.pop();
        }
    }
}

int get_median() {
    return (q1.size() >= q2.size()) ? q1.top() : q2.top();
}
```

---
处理用时：87.67秒
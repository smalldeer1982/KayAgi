# 题目信息

# [USACO1.1] 贪婪的送礼者 Greedy Gift Givers

## 题目描述

对于一群 $n$ 个要互送礼物的朋友，GY 要确定每个人送出的钱比收到的多多少。在这一个问题中，每个人都准备了一些钱来送礼物，而这些钱将会被平均分给那些将收到他的礼物的人。  

然而，在任何一群朋友中，有些人将送出较多的礼物(可能是因为有较多的朋友)，有些人有准备了较多的钱。  

给出一群朋友，没有人的名字会长于 $14$ 字符，给出每个人将花在送礼上的钱，和将收到他的礼物的人的列表，请确定每个人收到的比送出的钱多的数目。

## 说明/提示

【数据范围】  
$1\le n \le 10$。

题目翻译来自NOCOW。

USACO Training Section 1.1

## 样例 #1

### 输入

```
5
dave
laura
owen
vick
amr
dave
200 3
laura
owen
vick
owen
500 1
dave
amr
150 2
vick
owen
laura
0 2
amr
vick
vick
0 0
```

### 输出

```
dave 302
laura 66
owen -359
vick 141
amr -150
```

# AI分析结果



### 唯一算法分类
**模拟**

### 综合分析与结论
**题目核心逻辑**：模拟送礼过程中的金额分配，计算每个人的净收入（收到的钱 - 送出的钱）。  
**核心难点**：  
1. 余数处理：送礼金额无法整除时，剩余金额需返还给送礼者。  
2. 高效查找：通过名字快速定位对应的金额存储位置。  
**解决方案**：  
- 使用 `map<string, int>` 建立名字到金额的映射，避免显式遍历查找。  
- 通过数学公式直接计算净收入：`送礼者支出 = 总金额 - 余数`，`接收者收入 += 分到的金额`。

**可视化设计思路**：  
- **动画流程**：  
  1. 展示初始状态，所有金额为0。  
  2. 高亮当前送礼者，显示其总金额和接收人数。  
  3. 逐个显示接收者，动态更新金额（送礼者金额减少，接收者增加）。  
  4. 用颜色区分操作：红色表示支出，绿色表示收入。  
- **复古像素风格**：  
  - 用16色像素方块表示每个用户，名字显示在方块上方，金额在下方。  
  - 音效：送出时播放“硬币掉落”音效，接收时播放“金币收集”音效。  
  - 自动演示模式下，算法过程以每秒1步的速度自动执行。

---

### 题解评分（≥4星）
1. **BlueArc（5星）**  
   - 使用 `map` 实现高效查找，代码简洁清晰。  
   - 特判除数0的情况，避免运行时错误。  
   - 关键代码段逻辑紧凑，易读性强。  
   ```cpp
   cnt[s] -= num * p; // 送礼者支出总金额
   cnt[person] += num; // 接收者收入分到的钱
   ```

2. **w1049（4星）**  
   - 结合 `map` 和 `vector` 保留输入顺序，输出时无需额外处理。  
   - 处理余数的方式直观：`m[tmp] += money % num`。  
   ```cpp
   m[tmp] -= money; // 总支出
   m[tmp] += money % num; // 余数返还
   ```

3. **至成天下（4星）**  
   - 使用两个 `map` 分别记录收入和支出，逻辑分离清晰。  
   - 代码简短，适合快速理解核心逻辑。  
   ```cpp
   give[a] += (x/y)*y; // 记录送礼者总支出
   receive[b] += x/y;  // 记录接收者收入
   ```

---

### 最优思路与技巧提炼
1. **数据结构选择**：  
   - 使用 `map<string, int>` 直接通过名字操作金额，无需遍历查找。  
2. **数学公式优化**：  
   - 送礼者的净支出为 `总金额 - 余数`，公式：`cnt[s] -= money - (money % p)`。  
3. **边界处理**：  
   - 特判 `p == 0` 的情况，避免除以0导致程序崩溃。

---

### 类似题目推荐
1. **P1308 统计单词数**（字符串匹配与计数）  
2. **P1597 语句解析**（变量名与数值的映射）  
3. **P3613 寄包柜**（多维映射与存取模拟）

---

### 核心代码实现（BlueArc题解）
```cpp
#include <iostream>
#include <map>
using namespace std;

map<string, int> cnt;
string name[12];

int main() {
    int n; cin >> n;
    for (int i = 1; i <= n; i++) cin >> name[i];
    for (int i = 1; i <= n; i++) {
        string s; int money, p;
        cin >> s >> money >> p;
        if (p != 0) {
            int num = money / p;
            cnt[s] -= num * p; // 关键：总支出 = 每人分到的钱 * 人数
            for (int j = 1; j <= p; j++) {
                string person; cin >> person;
                cnt[person] += num; // 接收者收入
            }
        }
    }
    for (int i = 1; i <= n; i++)
        cout << name[i] << " " << cnt[name[i]] << endl;
    return 0;
}
```

---

### 可视化设计（复古像素风格）
**实现要点**：  
1. **Canvas绘制**：  
   - 每个用户显示为16x16像素方块，名字用8x8像素字体。  
   - 金额变化时，方块颜色渐变（绿增红减）。  
2. **音效设计**：  
   - `送钱音效`：短促“哔”声，频率随金额增大升高。  
   - `收钱音效`：清脆“叮”声，模拟金币碰撞。  
3. **自动演示模式**：  
   - 按输入顺序逐步执行，每步延迟1秒，高亮当前操作的名字。  

**交互控制**：  
- 按钮：开始/暂停/重置，速度调节（1x, 2x, 0.5x）。  
- 点击用户方块可查看详细收支记录。  

```javascript
// 伪代码示例：Canvas动画核心逻辑
function drawStep(step) {
    ctx.clearRect(0, 0, width, height);
    users.forEach(user => {
        drawPixelUser(user.name, user.money); // 绘制像素方块和金额
        if (user === currentGiver) highlight(user, 'red'); // 高亮送礼者
    });
    playSound('step_sound.wav'); // 步进音效
}
```

---

**总结**：本题核心在于模拟和数据结构的选择，通过 `map` 和数学优化可大幅简化代码。可视化设计可通过复古像素风格增强学习趣味性。

---
处理用时：83.11秒
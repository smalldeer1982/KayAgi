# 题目信息

# 红色的幻想乡

## 题目背景

蕾米莉亚的红雾异变失败后，很不甘心。


## 题目描述

经过上次失败后，蕾米莉亚决定再次发动红雾异变，但为了防止被灵梦退治，她决定将红雾以奇怪的阵势释放。

我们将幻想乡看做是一个 $n \times m$的方格地区，一开始没有任何一个地区被红雾遮盖。蕾米莉亚每次站在某一个地区上，向东南西北四个方向各发出一条无限长的红雾，可以影响到整行/整列，但不会影响到她所站的那个地区。如果两阵红雾碰撞，则会因为密度过大而沉降消失。灵梦察觉到了这次异变，决定去解决它。但在解决之前，灵梦想要了解一片范围红雾的密度。可以简述为两种操作:

``1 x y`` 蕾米莉亚站在坐标 $(x,y)$ 的位置向四个方向释放无限长的红雾。

``2 x1 y1 x2 y2`` 询问左上点为$(x1,y1)$，右下点为 $(x2,y2)$ 的矩形范围内，被红雾遮盖的地区的数量。


## 说明/提示

#### 样例输入输出 1 解释

用``o``表示没有红雾，``x``表示有红雾，两次释放红雾后幻想乡地图如下:

```
oxox
xoxo
oxox
xoxo
```

---

#### 数据规模与约定

- 对于 $20\%$ 的数据，$1 \le n,m,q \le 200$。
- 对于 $40\%$ 的数据，$1 \le n,m,q \le 10^3$。
- 对于 $100\%$ 的数据，$1 \le n,m,q \le 10^5$，$1 \le x_1,x_2,x \le n$，$x_1 \le x_2$，$1 \le y_1,y_2,y \le m$，$y_1 \le y_2$。

## 样例 #1

### 输入

```
4 4 3
1 2 2
1 4 4
2 1 1 4 4
```

### 输出

```
8```

# AI分析结果



# 算法分类
**二维问题降维处理 + 容斥原理**

---

## 题解思路与核心分析
### 核心难点与解决思路
1. **降维处理**：将二维红雾覆盖问题拆分为独立的一维行、列操作，用两个独立的数据结构分别维护行和列的覆盖状态。
2. **容斥原理**：红雾覆盖区域为行覆盖与列覆盖的并集，需扣除重复计算的交点区域。公式推导为：  
   **覆盖数 = 行覆盖数×列长度 + 列覆盖数×行长度 - 2×行覆盖数×列覆盖数**  
3. **动态维护**：每次操作1对行和列进行状态切换（异或操作），通过线段树或树状数组高效实现单点修改和区间查询。

### 算法流程
1. **数据结构初始化**：两个线段树/树状数组分别管理行和列的覆盖状态。
2. **操作1处理**：修改对应行和列的状态（0→1或1→0）。
3. **操作2处理**：查询范围内的行覆盖数、列覆盖数，代入容斥公式计算结果。

---

## 题解评分（≥4星）
### 1. Hurricane的线段树解法（⭐⭐⭐⭐⭐）
- **亮点**：代码简洁，直接传递数组指针复用线段树逻辑。
- **关键代码**：
  ```cpp
  void change(int *a, int p, now) { /* 单点异或修改 */ }
  long long ans = xx*(y2-y1+1) + yy*(x2-x1+1) - (xx*yy<<1);
  ```

### 2. Misaka_Mik0t0的树状数组解法（⭐⭐⭐⭐⭐）
- **亮点**：树状数组实现，常数更优，代码更短。
- **关键代码**：
  ```cpp
  void huan(int x, int y) { /* 切换行列状态 */ }
  ans = xnum * yy + ynum * xx - xnum * ynum * 2;
  ```

### 3. ChthollyTree的树状数组解法（⭐⭐⭐⭐）
- **亮点**：明确变量命名，附带数据验证示例。
- **关键片段**：
  ```cpp
  int s1 = query_x_range(); 
  int s2 = query_y_range();
  ans = s1*col_len + s2*row_len - 2*s1*s2;
  ```

---

## 最优思路提炼
1. **独立行列处理**：将二维覆盖拆分为两个一维问题，复杂度从 O(n²) 降为 O(n)。
2. **容斥公式**：覆盖数 = 行贡献 + 列贡献 - 2×交点贡献，避免重复计算。
3. **状态切换优化**：使用异或操作（0↔1）高效切换行/列的覆盖状态。

---

## 同类型题与算法套路
1. **二维覆盖统计**：如统计矩形区域内行、列交点的特殊属性。
2. **开关问题**：多次切换状态后查询区域总和（如灯光开关、网格翻转）。
3. **推荐题目**：
   - **P3913 车的攻击**（行列覆盖统计）
   - **P2181 对角线**（交点计算）
   - **P1972 [SDOI2009]HH的项链**（区间计数与去重）

---

## 可视化与算法演示
### 动画设计
1. **像素风格界面**：
   - **红色**表示行覆盖，**蓝色**表示列覆盖，**紫色**表示交点。
   - 每次操作1时，对应行和列闪烁，状态切换（0→1或1→0）。
2. **交互控制**：
   - **步进执行**：高亮当前修改的行/列，显示覆盖状态变化。
   - **查询演示**：用半透明色块标记查询区域，动态展示容斥计算过程。
3. **音效提示**：
   - 操作1触发“开关”音效，查询成功播放“叮咚”声。

### 核心逻辑演示代码（伪代码）
```javascript
// 初始化 Canvas 网格
const grid = new PixelGrid(n, m);
// 操作1：切换行列状态
function handleOperation1(x, y) {
  grid.toggleRow(x);
  grid.toggleColumn(y);
  playSound("switch");
}
// 操作2：计算覆盖区域
function handleOperation2(x1, y1, x2, y2) {
  const rows = grid.queryRows(x1, x2);
  const cols = grid.queryColumns(y1, y2);
  const result = rows * (y2 - y1 + 1) + cols * (x2 - x1 + 1) - 2 * rows * cols;
  highlightArea(x1, y1, x2, y2, result);
}
```

---

## 个人心得摘录
> **Hurricane**：  
> “抵消块数就是2xy，用异或直接切换状态，根本不需要二维结构。”  
> **启示**：通过数学推导简化实现，避免复杂数据结构。

> **Misaka_Mik0t0**：  
> “树状数组常数更优，线段树反而多余。”  
> **启示**：根据问题特性选择数据结构，树状数组在单点修改场景更高效。

---

## 代码实现（树状数组版）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+5;
int n,m,q;
struct BIT {
    int tree[MAXN], size;
    void update(int x) {
        for(;x<=size;x+=x&-x) tree[x]^=1;
    }
    int query(int x) {
        int res=0;
        for(;x>0;x-=x&-x) res+=tree[x];
        return res;
    }
} row, col;

int main() {
    scanf("%d%d%d",&n,&m,&q);
    row.size=n; col.size=m;
    while(q--) {
        int op,x,y,x1,y1;
        scanf("%d",&op);
        if(op==1) {
            scanf("%d%d",&x,&y);
            row.update(x);
            col.update(y);
        } else {
            scanf("%d%d%d%d",&x,&y,&x1,&y1);
            int r=row.query(x1)-row.query(x-1);
            int c=col.query(y1)-col.query(y-1);
            printf("%lld\n",1LL*r*(y1-y+1)+1LL*c*(x1-x+1)-2LL*r*c);
        }
    }
    return 0;
}
```

---
处理用时：83.47秒
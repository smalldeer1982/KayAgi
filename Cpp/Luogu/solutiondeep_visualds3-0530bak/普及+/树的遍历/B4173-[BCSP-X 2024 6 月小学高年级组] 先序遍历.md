# 题目信息

# [BCSP-X 2024 6 月小学高年级组] 先序遍历

## 题目描述

按照根-左-右的顺序遍历**二叉树**：

- 先序遍历 = 根 + 左子树先序遍历 + 右子树先序遍历
- 空树的先序遍历 = 空

![](https://cdn.luogu.com.cn/upload/image_hosting/rz3z5ke0.png)

给一棵 $n$ 个点的二叉树（根节点为 $1$），你可以进行以下操作至多 $1$ 次：

- 选择 $1$ 个（除了根之外的）点 $u$，断开 $u$ 和其父节点之间的边；然后重新选择另一个点作为 $u$ 的父节点、将 $u$ 接上去，需要保证操作之后仍然是一棵以 $1$ 为根的二叉树。

你想要操作之后的二叉树有字典序最小的先序遍历序列，输出这个序列。

## 说明/提示

### 样例解释 #1

- 对于第一个样例，可以把 3 号结点连在 2 号结点的左儿子处。
- 对于第二个样例，可以把 4 号结点连在 3 号结点的左儿子处。

### 数据范围

对于所有数据，令 $\sum n$ 代表每组数据中 $n$ 的和，$1 \leq T \leq 100, 1 \leq n \leq 10^5, 1 \leq \sum n \leq 3 \times 10^5$，保证输入是一棵以 1 为根的二叉树。

- 对于测试点 1~3：$n \leq 10$；
- 对于测试点 4~8：$n \leq 200$；
- 对于测试点 9~11：$n \leq 1000$；
- 对于测试点 12~14：$n \leq 10^5$ 且所有 $ls[i] = 0$；
- 对于测试点 15：$n \leq 10^5$ 且所有 $rs[i] = 0$；
- 对于测试点 16~20：$n \leq 10^5$；

## 样例 #1

### 输入

```
12
4
2 3
0 4
0 0
0 0
5
2 3
0 4
0 5
0 0
0 0
6
5 2
3 6
4 0
0 0
0 0
0 0
6
2 3
6 4
0 5
0 0
0 0
0 0
6
5 2
3 0
4 0
6 0
0 0
0 0
6
3 2
4 6
0 0
5 0
0 0
0 0
6
4 2
5 3
0 0
0 0
0 6
0 0
6
3 2
0 0
5 4
0 6
0 0
0 0
6
2 3
0 0
5 4
0 6
0 0
0 0
6
3 2
4 5
0 0
0 6
0 0
0 0
6
2 3
0 4
0 0
0 5
0 6
0 0
6
2 5
3 4
0 0
0 0
6 0
0 0```

### 输出

```
1 2 3 4
1 2 3 4 5
1 2 3 4 5 6
1 2 4 3 5 6
1 2 3 4 6 5
1 2 4 5 3 6
1 2 5 4 6 3
1 2 3 5 4 6
1 2 3 4 5 6
1 2 4 3 6 5
1 2 3 4 5 6
1 2 3 4 5 6```

# AI分析结果



**算法分类**  
贪心算法

---

### **题解思路与算法分析**  
**核心思路**：通过贪心策略找到先序遍历中第一个可以优化的位置，调整子树结构使得字典序最小。  
**关键步骤**：  
1. **先序遍历序列生成**：记录原树的先序序列 `h`。  
2. **子树大小预处理**：计算每个节点的子树大小 `x[i]`，便于后续快速切割子树。  
3. **后缀最小值数组**：构建 `q` 数组快速定位后续最小节点位置，辅助贪心决策。  
4. **贪心调整**：遍历 `h` 序列，寻找以下三种可优化情况：  
   - 左子节点值 > 右子节点值：交换左右子树。  
   - 左子节点空且后续存在更小值：将小节点插入左子树。  
   - 右子节点空且后续存在更小值：将小节点插入右子树。  

**解决难点**：  
- **高效定位调整点**：通过后缀最小值数组避免暴力遍历，将时间复杂度优化到线性。  
- **子树切割与拼接**：利用子树大小信息快速分割序列，生成合法的新先序遍历。  

---

### **最优思路提炼**  
1. **贪心选择时机**：在第一个可能优化的位置调整，后续无需再处理。  
2. **子树大小预计算**：快速确定子树范围，避免重复计算。  
3. **后缀最小值加速**：快速判断是否存在更优节点可插入。  

---

### **代码实现关键片段**  
```python
def g(i): # 生成先序序列
    if i: 
        h.append(i)
        g(a[i][0])
        g(a[i][1])

def u(i): # 计算子树大小
    if 0 < i <= n: 
        x[i] = 1 + u(a[i][0]) + u(a[i][1])
        return x[i]
    return 0

# 主逻辑片段
for i in range(n-1):
    if a[h[i]][0] > a[h[i]][1] > 0: # 左子比右子大
        for j in range(i + x[h[i+1]] + 1, n):
            if 0 == a[h[j]][0] and h[i+1] < h[j+1]:
                # 切割子树并拼接新序列
                print(*h[:i+1] + h[j:j+1] + ...)
                break
    elif 0 == a[h[i]][0] and h[i+1] > q[~i]: # 左子空，后续有更小值
        # 插入最小后缀节点
        print(*h[:i+1] + ...)
        break
```

---

### **可视化设计思路**  
**动画方案**：  
1. **树结构绘制**：以像素风格绘制二叉树，根节点居中，左右子树分列左右。  
2. **高亮当前节点**：遍历时用绿色高亮当前检查的节点 `h[i]`，红色标记可调整点。  
3. **子树切割动画**：当触发调整时，用闪烁效果展示被移动的子树，蓝色箭头表示新父节点连接。  
4. **音效反馈**：  
   - 发现优化点时播放上升音效，调整成功播放胜利音效。  
   - 错误操作（如非法连接）播放低沉音效。  

**复古像素风格**：  
- **8位调色板**：使用经典绿、红、蓝、黄四色表示节点状态。  
- **Canvas 网格**：每个节点占据 16x16 像素块，子树按层级缩进排列。  

---

### **相似题目推荐**  
1. **P1040 加分二叉树**（区间DP与树遍历）  
2. **P1364 二叉树输出**（先序与结构重建）  
3. **P1305 新二叉树**（字典序最小生成树）  

---

### **个人心得摘录**  
- **递归深度陷阱**：Python默认递归栈较小，需手动提升限制。  
- **字典序贪心核心**：第一个可优化位置决定全局最优，后续无需遍历。  
- **子树切割公式**：`h[i+1:i+x+1]` 表示当前节点的子树范围，快速拼接新序列。  

---

### **结论**  
通过贪心策略结合子树大小与后缀最小值预处理，高效定位最优调整点，确保字典序最小。算法复杂度为 O(n)，适用于大规模数据。

---
处理用时：139.27秒
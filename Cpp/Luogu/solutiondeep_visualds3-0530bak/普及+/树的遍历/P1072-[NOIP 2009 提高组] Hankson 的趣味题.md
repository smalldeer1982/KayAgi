# 题目信息

# [NOIP 2009 提高组] Hankson 的趣味题

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。

今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：

1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；

2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。

Hankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。


## 说明/提示

**【样例解释】**

第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。

第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。

**【数据范围】**

- 对于 $50\%$ 的数据，保证有 $1\leq a_0,a_1,b_0,b_1 \leq 10000$ 且 $n \leq 100$。
- 对于 $100\%$ 的数据，保证有 $1 \leq a_0,a_1,b_0,b_1 \leq 2 \times 10^9$ 且 $n≤2000$。

NOIP 2009 提高组 第二题


## 样例 #1

### 输入

```
2 
41 1 96 288 
95 1 37 1776 ```

### 输出

```
6 
2```

# AI分析结果



### 算法分类：数论（因数枚举 + GCD/LCM 性质应用）

---

### 题解思路与核心难点解析

**核心思路**：  
所有题解均基于以下两个关键观察：  
1. **x 必须是 b₁ 的因数**（由 lcm(x, b₀)=b₁ 推导得出）  
2. **x 必须是 a₁ 的倍数**（由 gcd(x, a₀)=a₁ 推导得出）  

**解决难点**：  
- **暴力枚举优化**：直接枚举所有因数（最多约 1500 个）而非 1~b₁，将复杂度从 O(b₁) 降至 O(√b₁)  
- **数学性质转化**：通过质因数分解将条件转化为指数范围约束，避免重复验证  
- **边界特判**：平方因数只计算一次，避免重复计数  

---

### 题解评分（≥4星）

1. **zzlzk（5星）**  
   - 亮点：代码简洁清晰，通过成对枚举因数 + 双重条件验证，完美适配题目数据范围  
   - 关键代码：  
     ```cpp
     for(int x=1;x*x<=b1;x++) 
         if(b1%x==0){
             if(x%a1==0 && gcd(x/a1,p)==1 && gcd(q,b1/x)==1) ans++;
             int y=b1/x;
             if(x!=y && y%a1==0 && gcd(y/a1,p)==1 && gcd(q,b1/y)==1) ans++;
         }
     ```

2. **KesdiaelKen（4星）**  
   - 亮点：通过质因数分解消去公共因子，减少枚举次数  
   - 关键步骤：  
     - 计算 s = b₁/a₁, m = a₀/a₁, n = b₁/b₀  
     - 消去 s 与 n 的公共质因子得到 l  
     - 将问题转化为 l 的质因数组合问题  

3. **zsq9（4星）**  
   - 亮点：直接通过 DFS 生成质因数组合，避免无效枚举  
   - 核心逻辑：  
     ```cpp
     void dfs(int x,int sum){
         if(x==tot) { if(check(sum)) ans++; return; }
         for(int i=0;i<=pri[x].num;i++)
             dfs(x+1, pow(pri[x].val,i)*sum);
     }
     ```

---

### 最优技巧提炼

1. **因数成对枚举法**  
   - 枚举 1~√b₁ 的因数 x，同时处理 x 和 b₁/x  
   - 特判平方数避免重复计数  

2. **数学性质转化**  
   - **GCD 约束**：若 gcd(x, a₀)=a₁，则 x 必须形如 a₁·k，且 k 与 a₀/a₁ 互质  
   - **LCM 约束**：若 lcm(x, b₀)=b₁，则 x 必须形如 b₁/gcd(b₀, b₁/x)  

3. **质因数分解优化**  
   - 对 a₀, a₁, b₀, b₁ 分别分解质因数，按指数范围约束计算组合可能性  

---

### 相似题目推荐

1. **P1029 最大公约数和最小公倍数问题**  
   - 关键点：枚举因数 + 验证 GCD/LCM 关系  

2. **P2445 数的划分**  
   - 关键点：质因数分解 + 组合数学计数  

3. **P2527 质数距离**  
   - 关键点：区间筛法 + 质因数性质应用  

---

### 可视化与算法演示

**动画设计**：  
1. **像素风格界面**：  
   - 用 8-bit 像素块表示因数，绿色表示通过验证，红色表示失败  
   - 背景音乐：FC 风格 8-bit 循环旋律  

2. **核心流程演示**：  
   - **步骤1**：显示 b₁ 的因数生成过程（x 和 b₁/x 成对弹出）  
   - **步骤2**：对每个因数 x 高亮显示 GCD(x, a₀) 和 LCM(x, b₀) 的计算过程  
   - **步骤3**：符合条件时播放「叮」音效，计数增加；失败时播放「咔」音效  

3. **交互控制**：  
   - 速度滑块：调节因数生成速度（1x~10x）  
   - 暂停/继续：观察当前因数的验证细节  
   - 单步执行：逐步查看每个因数的处理逻辑  

**示例代码片段（Canvas 绘制因数块）**：  
```javascript
function drawFactor(x, y, isValid) {
    ctx.fillStyle = isValid ? '#00FF00' : '#FF0000';
    ctx.fillRect(x * 30, y * 30, 25, 25);
    ctx.fillStyle = '#000000';
    ctx.fillText(`${factor}`, x * 30 + 5, y * 30 + 15);
}
```

---

### 个人心得摘录

> **调试教训**（作者：皎月半洒花）：  
> *「质因数分解时必须处理剩余的大质数因子，否则在 b₁ 为素数时会漏解」*  
>   
> **优化经验**（作者：KesdiaelKen）：  
> *「通过消去 s 与 n 的公共质因子，将问题转化为更小规模的因数组合，这是减少枚举量的关键」*  

---

### 核心代码实现

**zzlzk 题解完整代码**：  
```cpp
#include<cstdio>
using namespace std;
int gcd(int a,int b) { return b==0?a:gcd(b,a%b); }
int main() {
    int T; scanf("%d",&T);
    while(T--) {
        int a0,a1,b0,b1, ans=0;
        scanf("%d%d%d%d",&a0,&a1,&b0,&b1);
        int p=a0/a1, q=b1/b0;
        for(int x=1;x*x<=b1;x++) 
            if(b1%x==0){
                if(x%a1==0 && gcd(x/a1,p)==1 && gcd(q,b1/x)==1) ans++;
                int y=b1/x;
                if(x!=y && y%a1==0 && gcd(y/a1,p)==1 && gcd(q,b1/y)==1) ans++;
            }
        printf("%d\n",ans);
    }
    return 0;
}
```

---
处理用时：79.84秒
# 题目信息

# [国家集训队] 单选错位

## 题目描述

gx 和 lc 去参加 noip 初赛，其中有一种题型叫单项选择题，顾名思义，只有一个选项是正确答案。

试卷上共有 $n$ 道单选题，第 $i$ 道单选题有 $a_i$ 个选项，这 $a_i$ 个选项编号是 $1,2,3,\ldots,a_i$，每个选项成为正确答案的概率都是相等的。

lc 采取的策略是每道题目随机写上 $1 \sim a_i$ 的某个数作为答案选项，他用不了多少时间就能期望做对 $\sum_{i=1}^n \frac{1}{a_i}$ 道题目。gx 则是认认真真地做完了这 $n$ 道题目，可是等他做完的时候时间也所剩无几了，于是他匆忙地把答案抄到答题纸上，没想到抄错位了：第 $i$ 道题目的答案抄到了答题纸上的第 $i+1$ 道题目的位置上，特别地，第 $n$ 道题目的答案抄到了第 $1$ 道题目的位置上。

现在 gx 已经走出考场没法改了，不过他还是想知道自己期望能做对几道题目，这样他就知道会不会被 lc 鄙视了。

我们假设 gx 没有做错任何题目，只是答案抄错位置了。


## 说明/提示

【样例说明】

| 正确答案   |   gx的答案    | 做对题目 | 出现概率 |
| :----------: | :----------: |:----------: | :----------: |
| $\{1,1,1\}$  |    $\{1,1,1\}$    |    $3$    |    $\frac16$ |
| $\{1,2,1\}$    |   $ \{1,1,2\}$   |    $1$    |    $\frac16$ |
|$\{1,3,1\}$    |   $ \{1,1,3\} $   |    $1$    |    $\frac16$ |
|$\{2,1,1\}$    |   $ \{1,2,1\} $   |    $1$    |    $\frac16$|
|$\{2,2,1\}$    |   $ \{1,2,2\}$    |    $1$    |    $\frac16$ |
|$\{2,3,1\}$    |    $\{1,2,3\} $   |    $0$    |    $\frac16$ |




$a = \{2,3,1\}$。

共有 $6$ 种情况，每种情况出现的概率是 $\frac{1}{6}$，gx 期望做对 $\frac{3+1+1+1+1+0}6 = \frac76$ 题。（相比之下，lc 随机就能期望做对 $\frac{11}6$ 题）



对于 $30\%$ 的数据，$n\leq 10, C\leq 10$。

对于 $80\%$ 的数据，$n\leq 10^4, C\leq 10$。

对于 $90\%$ 的数据，$n\leq 5\times 10^5, C\leq 10^8$。

对于 $100\%$ 的数据，$2\leq n\leq 10^7, 0\leq A,B,C \leq 10^8$，$1 \leq a_i \leq 10^8$。


## 样例 #1

### 输入

```
3 2 0 4 1```

### 输出

```
1.167
```

# AI分析结果



## 算法分类
无算法分类

---

## 题解思路与难点分析

### 核心思路
题目要求计算因答案错位导致的期望正确题数。利用期望的线性性质，将问题转化为求每个题被正确填写的概率之和。关键推导发现每个题的正确概率仅与相邻两题的选项数最大值有关，最终公式为 $\sum_{i=1}^n \frac{1}{\max(a_i, a_{i+1})}$（其中 $a_{n+1}=a_1$）。

### 解决难点
1. **错位逻辑建模**：需明确第 $i$ 题的答案被错填到第 $i+1$ 题的位置，导致正确性仅由相邻题选项的匹配决定。
2. **概率推导**：通过分类讨论或数学化简（如 $\frac{\min(a_i,a_{i+1})}{a_i a_{i+1}} = \frac{1}{\max(a_i,a_{i+1})}$）简化计算。
3. **空间优化**：部分题解采用滚动变量避免存储完整数组，节省内存。

### 题解对比
- **stoorz**：分类讨论清晰，代码直接，适用于教学。
- **P500**：滚动变量节省内存，适合大数据场景。
- **QuantAsk**：从古典概率出发，推导严谨。

---

## 题解评分（≥4星）

1. **stoorz（5星）**  
   思路清晰，代码简洁，直接体现核心公式，适合快速理解。

2. **P500（4星）**  
   滚动变量优化内存，但生成逻辑稍显复杂，可读性略低。

3. **QuantAsk（4星）**  
   从概率定义出发，推导严谨，代码结构清晰。

---

## 最优思路提炼
- **关键公式**：相邻题正确概率为 $\frac{1}{\max(a_i, a_{i+1})}$。
- **优化技巧**：使用滚动变量（如 `a1` 和 `a2`）避免存储整个数组，减少内存占用。
- **数学化简**：通过 $\min(a,b)/(a \cdot b) = 1/\max(a,b)$ 简化计算。

---

## 类似题目推荐
1. **P4316 绿豆蛙的归宿**（期望计算与动态规划）
2. **P6154 游走**（期望与路径统计）
3. **P1365 WJMZBMR打osu! 期望**（分段期望的线性处理）

---

## 可视化与算法演示

### 动画设计
1. **网格布局**：将每个题 $i$ 的选项数 $a_i$ 显示为像素块，高亮当前处理的相邻题对 $(i, i+1)$。
2. **颜色标记**：当前题对用红色边框，计算出的 $\max(a_i, a_{i+1})$ 以绿色填充。
3. **步进控制**：用户可调整速度或单步执行，观察每一步的贡献值累加。
4. **音效反馈**：每次计算题对时播放“滴”声，总期望更新时播放上扬音效。

### 复古游戏化
- **8位风格**：使用16色调色板，题对像素块采用复古色（如 #FF0000 红、#00FF00 绿）。
- **Canvas 绘制**：动态更新题对和总期望，背景循环播放芯片音乐。
- **自动演示**：默认自动步进，展示算法流程；用户可暂停调整参数。

---

## 核心代码片段（P500 的滚动变量实现）
```cpp
long long a1, a2;
double ans = 0.0;

// 生成初始 a1
a1 = ...; // 初始化逻辑

// 处理前 n-1 个元素
for (int i = 2; i <= n; i++) {
    a2 = (a1 * A + B) % MOD;
    ans += 1.0 / max(a1 % C + 1, a2 % C + 1);
    a1 = a2;
}

// 处理最后一个元素与第一个元素的对比
ans += 1.0 / max(a_initial % C + 1, a1 % C + 1);
```

---

## 个人心得摘录
- **stdlifg**：化简公式时发现 $\min(a,b)/(a \cdot b)$ 可简化为 $1/\max(a,b)$，顿悟数学之美。
- **P500**：意识到滚动变量可大幅节省内存，尤其在处理 $10^7$ 级数据时避免内存溢出。

---
处理用时：129.08秒
# 题目信息

# [语言月赛202212] 打 ACM 最快乐的就是滚榜读队名了(Easy Version)

## 题目背景

**本题与 [I2](https://www.luogu.com.cn/problem/P8890) 的题意完全一致，区别仅在 $m$ 和 $K$ 的范围**。

在刚刚结束的 ICPC 杭州赛站上，某 E 经历了刺激的滚榜。她发现打 ACM 最快乐的就是滚榜读队名了。

## 题目描述

一场 ICPC 正式赛共 $5$ 小时。

队伍的排名由通过题数与罚时决定。通过题数更多的队伍排名更靠前，若通过题数相同，则罚时更小的队伍排名更靠前。通过题数与罚时均相同的队伍排名相同。本题中可能出现队伍排名相同的情况，此时，认为先出现在提交记录中的队伍排名靠前。

罚时是由通过题目的时间和未通过提交的次数决定的。罚时为每一道题通过时比赛开始的分钟数之和，加上该题之前未通过提交的次数乘 $20$ 分钟得到的。例如，某队在比赛进行 $1:28:35$ 时通过了 G 题，在此之前共有 $3$ 次未通过的提交，则 G 题对罚时的总贡献为 $88+3 \times 20=148$ 分钟。

**需要注意的是，仅有通过的试题的未通过提交会被计算罚时**。例如，某队在 I 题共有 $14$ 次未通过的提交，但到比赛结束，该队都没有通过 I 题，则这 $14$ 次未通过的提交不会被计算罚时。**在某一题通过后，该队对这一题的任何提交（无论是否能够通过）都不会影响本题通过的结果和本题的罚时。**

选手在比赛过程中可以随时提交某一道试题的代码，代码将被立即评测并返回结果（$\texttt{Accepted}$，$\texttt{Time Limit Exceeded}$，$\texttt{Memory Limit Exceeded}$，$\texttt{Presentation Error}$，$\texttt{Wrong Answer}$，$\texttt{Runtime Error}$）。其中，评测结果 $\texttt{Accepted}$ 为通过，其他评测结果均为不通过。

在比赛进行的前四小时（$0:00:00 \sim 4:00:00$），每支队伍的提交均会在排行榜上反映出来。比赛的最后一小时（$4:00:01 \sim 5:00:00$），排行榜将被冻结（封榜），所有的提交在排行榜对应队伍对应试题上均显示为待判题（提交的队伍知道评测结果）。

在比赛结束后，会进行紧张刺激的滚榜环节。滚榜嘉宾将按照封榜时的排行榜，依照从最后一名到第一名，**先读出队伍队名**，再按照从 A 题依次到最后一题的顺序，公布排行榜上该队“待判题”状态试题最终是否通过。

如果通过，所有队伍的排名将立即重新计算，显然，已经滚榜完成（被滚榜嘉宾念过队名，且所有待判题状态的结果都已经揭晓）的队伍排名不会有影响。若该队伍排名上升，则滚榜嘉宾立即开始下一支队伍的滚榜。因此，一支队伍的队名可能被滚榜嘉宾多次读出。

例如，某队队名为“囤题”，在前四小时没有通过任何一题，封榜时排在最后一名。在封榜后，该队连续通过全部十三道题目。那么滚榜嘉宾有可能读到该队队名七八次。当然，当该队上升到第一名后，其排名不会再发生变化，即使揭晓的判题结果为通过，但其排名没有发生变化，滚榜嘉宾不会再次读出其队名。

现在给出某场 ICPC 完整的提交记录，请你依次输出滚榜嘉宾念出的队名。

**一次提交记录都没有的队伍不会在排行榜上出现，也不会在滚榜中被念到队名。**

## 说明/提示

### 样例解释

在封榜前，队伍 $\texttt{abc}$ 仅通过 $\texttt{A}$ 题，且在第二秒的第一次正确提交之前有一次错误提交，因此罚时为 $20$ 分钟；队伍 $\texttt{bcd}$ 同样仅通过 $\texttt{A}$ 题，且在 $0:19:38$ 的第一次正确提交之前没有错误提交，因此罚时为 $19$ 分钟。

在封榜后，队伍 $\texttt{abc}$ 通过了 $\texttt{B}$ 题。

在滚榜环节开始，由于封榜后的提交未被揭晓，因此暂时认为队伍 $\texttt{abc}$ 与 $\texttt{bcd}$ 均只通过一题，且前者罚时较大，排名靠后。

依照从最后一名到第一名的原则，队伍 $\texttt{abc}$ 的名字先被念到，并揭晓其在封榜后的提交的结果。其通过了 $\texttt{B}$ 题，因此其通过题数被更新为 $2$，罚时同样被更新。同时，所有队伍的排名立即被重新计算。由于此时 $\texttt{abc}$ 通过题目数量大于 $\texttt{bcd}$，因此其排名重新计算为第一名，而 $\texttt{bcd}$ 成为最后一名第二名。

这之后，队伍 $\texttt{bcd}$ 的名字被念到，由于其在封榜后没有提交，因此这时所有队伍的排名没有变化，滚榜嘉宾会进行其上一名队伍的滚榜。

最后，队伍 $\texttt{abc}$ 的名字被念到，滚榜结束。

需要注意的是，在滚榜过程中是逐题揭晓提交。也就是说，如果一支队伍封榜后通过了多道题，在其进行滚榜过程中，只要按照从 $\texttt{A}$ 题依次到最后一题的顺序，该队第一个“待判题”状态试题通过，后面的“待判题”同样暂时不会揭晓，而是立刻进行排名更新过程以及可能存在的更换另一支队伍进行滚榜的过程。

### 数据规模与约定

- 对于 $30\%$ 的数据，$n = 1$；
- 对于另外 $10\%$ 的数据，$m = 1$；
- 对于 $100\%$ 的数据，$1 \le n \le 20$，$1 \le m \le 1000$，$1 \le K \le 10^4$，$0 \leq x \leq 5$，$00 \leq yy < 60$，$00 \leq zz < 60$，且当 $x = 5$ 时保证 $yy = zz = 00$。

保证提交记录按照提交时间不降序给出，即先给出的提交记录提交时间不会晚于后给出的提交记录的提交时间，试题名称为大写字母 $\texttt{A} \sim \texttt{Z}$，队名均为长度不超过 $50$ 的由小写字母组成的字符串，评测状态为试题中所给的 $6$ 种之一。

## 样例 #1

### 输入

```
2 2 4
0:00:01 A abc Wrong Answer
0:00:02 A abc Accepted
0:19:38 A bcd Accepted
4:18:22 B abc Accepted```

### 输出

```
abc
bcd
abc
```

# AI分析结果



## 算法分类
模拟、优先队列（堆）

---

## 题解思路与解决难点

### 核心思路
1. **数据结构设计**  
   每个队伍用结构体存储以下信息：通过题数、罚时、首次出现顺序、封榜前每题的AC状态与错误次数、封榜后每题的AC状态与错误次数。

2. **提交记录处理**  
   - 封榜前提交：直接计算罚时和通过题数。
   - 封榜后提交：仅记录AC时间和错误次数，待滚榜时处理。

3. **动态排名维护**  
   使用优先队列维护当前排名，按通过题数 > 罚时 > 出现顺序排序。滚榜时取出最后一名，逐步揭晓封榜后的AC题目，若排名上升则重新入队。

### 解决难点
1. **罚时计算**  
   需区分封榜前后的提交错误次数。封榜后AC的题目，其罚时包括封榜前错误次数 × 20 + 封榜后错误次数 × 20 + 通过时间。

2. **动态排名更新**  
   每次揭晓一个待判题后，需立即重新计算排名，并可能中断当前队伍的滚榜流程。

3. **处理顺序**  
   按题目顺序（A→Z）逐个揭晓待判题，每次仅处理一题，若导致排名变化则终止处理后续题目。

---

## 题解评分（≥4星）

1. **Milthm（★★★★★）**  
   - **亮点**：结构体设计清晰，优先队列处理优雅，支持加强版数据。
   - **代码**：完整处理封榜前后的状态，支持多题连续揭晓。

2. **T_TLucas_Yin（★★★★☆）**  
   - **亮点**：二维数组分离封榜前后状态，代码简洁。
   - **不足**：部分边界条件注释较少。

3. **Zhou_yu（★★★★☆）**  
   - **亮点**：详细注释坑点，提供随机数据生成器。
   - **心得**：强调优先队列的优势，分享调试经历。

---

## 最优思路提炼

1. **优先队列动态维护排名**  
   每次从队尾取出队伍，处理封榜后题目，若排名上升则重新入队，确保动态调整。

2. **分阶段处理提交记录**  
   - 封榜前：立即更新罚时。
   - 封榜后：记录时间和错误次数，滚榜时逐步处理。

3. **结构化状态存储**  
   使用 `ac[]` 标记已通过题目，`WA[]` 和 `fbWA[]` 分别记录封榜前后的错误次数。

---

## 同类型题推荐
1. **P1056 排座椅**（模拟+贪心排序）
2. **P1090 合并果子**（优先队列应用）
3. **P1168 中位数**（动态维护有序序列）

---

## 可视化设计

### 动画方案
1. **界面布局**  
   - 左侧：优先队列中的队伍排名（像素方块显示通过题数、罚时）。
   - 右侧：当前处理队伍的待判题列表（A-Z排列）。

2. **关键操作高亮**  
   - **红色**：当前正在处理的队伍。
   - **绿色**：揭晓通过的题目。
   - **黄色**：导致排名变化的操作。

3. **复古音效**  
   - **点击题目**：8-bit“滴”声。
   - **排名变化**：短促上扬音效。
   - **滚榜完成**：经典过关音效。

### 算法演示
```javascript
// 示例：优先队列更新动画
function updateRanking() {
    let currentTeam = queue.pop();
    highlight(currentTeam, 'red');
    for (let problem of currentTeam.pendingProblems) {
        if (problem.isAC) {
            playSound('blip');
            currentTeam.updateScore(problem);
            if (currentTeam.rankChanged()) {
                playSound('success');
                queue.push(currentTeam);
                break;
            }
        }
    }
    drawQueue(queue); // 重绘队列
}
```

---

## 核心代码实现
```cpp
struct Team {
    int solved, penalty, id;
    string name;
    int preWA[26], postWA[26];
    bool preAC[26], postAC[26];
    int postTime[26];
    
    bool operator<(const Team& other) const {
        if (solved != other.solved) return solved < other.solved;
        if (penalty != other.penalty) return penalty > other.penalty;
        return id > other.id;
    }
};

priority_queue<Team> q;

void processSubmissions() {
    // 处理每条提交记录
    if (time <= 4 * 3600) {
        if (!team.preAC[problem]) {
            if (isAC) {
                team.preAC[problem] = true;
                team.solved++;
                team.penalty += time + team.preWA[problem] * 20;
            } else {
                team.preWA[problem]++;
            }
        }
    } else {
        if (!team.preAC[problem] && !team.postAC[problem]) {
            if (isAC) {
                team.postAC[problem] = true;
                team.postTime[problem] = time;
            } else {
                team.postWA[problem]++;
            }
        }
    }
}

void roll() {
    while (!q.empty()) {
        Team curr = q.top(); q.pop();
        cout << curr.name << endl;
        bool updated = false;
        for (int p = 0; p < 26; ++p) {
            if (curr.postAC[p]) {
                curr.solved++;
                curr.penalty += curr.postTime[p] + (curr.preWA[p] + curr.postWA[p]) * 20;
                curr.postAC[p] = false;
                if (curr < q.top()) { // 假设比较已重载
                    q.push(curr);
                    updated = true;
                    break;
                }
            }
        }
        if (!updated) q.push(curr);
    }
}
```

---
处理用时：81.43秒
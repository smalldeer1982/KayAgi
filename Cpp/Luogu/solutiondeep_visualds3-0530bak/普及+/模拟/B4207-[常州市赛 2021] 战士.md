# 题目信息

# [常州市赛 2021] 战士

## 题目背景

搬运自 <http://czoj.com.cn/p/443>。数据为民间数据。

## 题目描述

小 $\text X$ 在玩一款操控战士和怪物战斗的游戏。战士初始生命值为 $\text{iH}$ 、初始攻击力为 $\text{iA}$ 。怪物只有一个，初始生命值为 $H$ 。  
战斗是回合制的，且有一个回合数限制 $M$ 。如果在 $M$ 回合内怪物还没有被杀死，小 $\text X$ 就失败了。在每个回合，战士先行动，怪物再行动。  
每当战士行动，小 $\text X$ 可以命令战士做以下两件事中的一件：  

- 攻击，让怪物的生命值减少当前战士攻击力的数值。  
- 磨刀，让战士攻击力增加 $\text{dA}$ 。  

每当怪物行动，怪物会攻击战士，使战士的生命值减少 $C_i$ ，其中 $i$ 为回合数。  
当一个角色生命值小于等于 $0$ 时，角色会死亡。  

- 如果怪物死亡，那么战斗就结束了。  
- 如果战士死亡，会立刻复活，将生命值和攻击力恢复为初始数值。  

现在小 $X$ 想问问你，最少能在几个回合内杀死怪物。  

## 说明/提示

### 样例解释
其中一种合法方案：  
- 第一回合：战士磨刀，战士攻击力变为 $2$ ；怪物攻击，战士生命值变成 $2$。  
- 第二回合：战士攻击，怪物生命值变为 $4$ ；怪物攻击，战士生命值变成 $1$ 。  
- 第三回合：战士攻击，怪物生命值变为 $2$ ；怪物攻击，战士死亡后复活，生命值变为 $4$ ，攻击力变为 $1$ 。  
- 第四回合：战士攻击，怪物生命值变为 $1$ ；怪物攻击，战士生命值变成 $3$ 。  
- 第五回合：战士攻击，怪物死亡。  
### 数据范围
本题共有 $10$ 个测试点。  
对于所有数据，$1\le \text{iH,iA},H\le10^9,0\le \text{dA}\le10^9,1\le C_i\le M\le2\times10^5$。
|测试点编号|$M$|特殊性质|
|:-:|:-:|:-:|
|$1$|$\le 2\times10^5$|$\text{dA}=0$|
|$2\sim3$|$\le20$|无|
|$4\sim5$|$\le30$|无|
|$6\sim8$|$\le10^3$|无|
|$9\sim10$|$\le2\times10^5$|无|

## 样例 #1

### 输入

```
4 1 6 1 8
2 1 1 1 1 1 1 1```

### 输出

```
5```

# AI分析结果



## 算法分类
**贪心策略 & 数学优化**

---

## 综合分析与结论
### 核心思路
1. **阶段划分**：将战斗划分为若干阶段，每个阶段为两次复活之间的连续回合。阶段结束时，战士攻击力重置。
2. **数学优化**：在每个阶段内，优先磨刀以最大化总伤害。通过二次函数极值确定最优磨刀次数 `p`，使得伤害 `(iA + dA * (m-p)) * p` 最大。
3. **阶段模拟**：遍历每个回合，计算当前阶段是否满足击杀条件或触发复活。若击杀成功则输出回合数，否则进入下一阶段。

### 解决难点
- **贪心与数学结合**：用二次函数极值快速确定最优磨刀次数，避免暴力枚举。
- **复活处理**：当累计伤害超过初始生命值时强制结束阶段，重置攻击力。
- **大数优化**：通过 `O(M)` 时间复杂度的模拟处理 `2e5` 量级数据。

### 可视化设计思路
1. **动画效果**：  
   - **回合操作**：用不同颜色标记磨刀（蓝色）和攻击（红色），实时显示攻击力与怪物血量。  
   - **阶段分割**：战士死亡时播放复活动画（闪烁效果），攻击力重置为初始值。  
   - **实时数据**：显示当前阶段、回合数、累计伤害。  
2. **复古像素风格**：  
   - **战士与怪物**：8-bit 像素形象，血量以条形图显示。  
   - **音效**：攻击时短促“叮”声，复活时播放“复活音效”，击杀时上扬音调。  
3. **交互控制**：支持暂停/继续、单步执行、调整动画速度。

---

## 题解清单（≥4星）
### 1. Ag2WO4 的题解（★★★★★）
**关键亮点**：
- **数学优化**：利用二次函数极值快速计算最优磨刀次数。
- **高效模拟**：`O(M)` 时间复杂度处理大规模数据。
- **代码简洁**：逻辑清晰，无冗余操作。

---

## 核心代码实现
### Ag2WO4 的 Python 代码
```python
iH, iA, H, dA, M = map(int, input().split())
C = list(map(int, input().split()))

current_round = 0
stage_damage = 0
stage_attack = iA

for m in range(1, M+1):
    current_round += 1
    stage_damage += C[m-1]
    
    # 计算最优磨刀次数 p
    if dA == 0:
        p = 0
    else:
        optimal_p = (iA + dA * (m - p)) * p  # 二次函数求解伪代码
        p = min(int((iA + dA * m) / (2 * dA)), m)
    
    total_damage = (iA + dA * (m - p)) * (m - p)
    if total_damage >= H:
        print(current_round)
        exit()
    
    # 检查是否触发复活
    if stage_damage >= iH:
        H -= total_damage
        stage_damage = 0
        stage_attack = iA
        m = 0

print(-1)
```

---

## 最优思路提炼
1. **阶段化处理**：将连续回合划分为独立阶段，每个阶段内最大化伤害。
2. **二次函数极值**：推导总伤害公式为二次函数，用 `p = (iA + dA*m)/(2*dA)` 快速确定最优磨刀次数。
3. **边界特判**：处理 `dA=0` 时无法磨刀的特殊情况，直接攻击。

---

## 类似题目推荐
1. **LeetCode 991. Broken Calculator**（逆向贪心与数学优化）
2. **洛谷 P1080 国王游戏**（贪心策略与排序）
3. **CodeForces 1526C2. Potions (Hard Version)**（阶段化选择与动态规划）

---
处理用时：85.04秒
# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果



# 算法分类
**枚举**

# 题解思路与算法分析

## 核心思路
题目要求找到覆盖指定点的最上层地毯编号。由于地毯按顺序铺放，后续地毯会覆盖之前的，因此只需要**逆向遍历**所有地毯，第一个覆盖该点的即为答案。

## 解决难点
1. **空间优化**：直接开二维数组存储每个坐标点的覆盖情况会超出内存限制（O(10^10)）。  
2. **高效判断**：通过存储每个地毯的坐标范围，以O(1)时间判断点是否被覆盖。  
3. **遍历顺序优化**：逆序遍历可提前终止搜索，时间复杂度最优为O(n)。

## 算法步骤
1. 存储每个地毯的左上角坐标(a,b)及其延伸范围(g,k)。  
2. 计算每个地毯的右下角坐标(a+g, b+k)。  
3. **逆序检查**每个地毯的范围是否包含目标点，找到第一个符合条件的立即返回。

---

# 题解评分（≥4星）

1. **谁懂谁伤心（5星）**  
   - 亮点：逆序遍历提前终止，代码简洁高效。  
   - 代码：用二维数组预存右下角坐标，减少重复计算。

2. **kuaiCreator（5星）**  
   - 亮点：变量命名规范，逻辑清晰，逆序优化明显。  
   - 核心代码：`for(int i = n; i >= 1; i--)` 实现高效搜索。

3. **Jayfeather2012（4星）**  
   - 亮点：注释明确，逆序遍历逻辑直接。  
   - 优化点：未预存右下角坐标，但代码可读性强。

---

# 最优思路与技巧

## 关键技巧
1. **逆序剪枝**：从最后一张地毯倒序检查，找到即停。  
2. **范围预计算**：输入时预存地毯的右下角坐标，减少循环内计算量。  
3. **边界包含处理**：判断条件使用`<=`和`>=`确保边界点被覆盖。

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4+5;
int a[N], b[N], g[N], k[N], n, x, y, ans = -1;

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) 
        cin >> a[i] >> b[i] >> g[i] >> k[i];
    cin >> x >> y;
    // 逆序遍历，找到第一个覆盖点
    for (int i = n; i >= 1; i--) {
        if (x >= a[i] && x <= a[i] + g[i] && 
            y >= b[i] && y <= b[i] + k[i]) {
            ans = i;
            break;
        }
    }
    cout << ans;
    return 0;
}
```

---

# 相似题目推荐
1. **P1886 滑动窗口**（单调队列处理覆盖问题）  
2. **P2434 [SDOI2006]区间覆盖**（一维区间覆盖优化）  
3. **P1496 火烧赤壁**（离散化处理区间覆盖）

---

# 可视化与动画设计

## 核心逻辑演示
1. **像素风格画布**：用Canvas绘制坐标系，地毯用半透明色块叠加，目标点用闪烁红点标注。  
2. **逆序高亮检查**：  
   - 遍历时当前地毯边框闪烁黄色，检查范围是否包含红点。  
   - 若包含，地毯变为绿色并锁定答案；否则恢复原色。  
3. **音效交互**：  
   - 发现覆盖时播放胜利音效，结束动画。  
   - 无覆盖时播放低沉提示音。

## 复古游戏化设计
- **8-bit音效**：使用ChipTone生成检查音效（类似《超级马里奥》金币声）。  
- **自动演示模式**：AI控制遍历速度，按`↑/↓`调节步进速度。  
- **积分系统**：正确找到答案+100分，每错误检查一个地毯-1分。

---

# 个人心得摘录
- **智子**：二维数组MLE教训深刻，提醒数据规模敏感度。  
- **FreedomKing**：顺序遍历的简洁性证明暴力法有时更直接。  
- **WsW_**：栈结构尝试虽正确，但数组逆序更优，体现算法选择的灵活性。

---
处理用时：132.47秒
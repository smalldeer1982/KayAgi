# 题目信息

# [NOIP 2012 提高组] 借教室

## 题目描述

在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。

面对海量租借教室的信息，我们自然希望编程解决这个问题。

我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_i$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_j,s_j,t_j$，表示某租借者需要从第 $s_j$ 天到第 $t_j$ 天租借教室（包括第 $s_j$ 天和第 $t_j$ 天），每天需要租借 $d_j$ 个教室。

我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供 $d_j$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。

借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_j$ 天到第 $t_j$ 天中有至少一天剩余的教室数量不足 $d_j$ 个。

现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。


## 说明/提示

【输入输出样例说明】

第 $1 $份订单满足后，$4 $天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2 $天到第 $4$ 天每天提供 $3$ 个教室，而第 $3$ 天剩余的教室数为$ 2$，因此无法满足。分配停止，通知第 $2$ 个申请人修改订单。

【数据范围】

对于 $10\%$ 的数据，有 $1\le n,m\le 10$；

对于 $30\%$ 的数据，有 $1\le n,m\le 1000$；

对于 $70\%$ 的数据，有 $1 \le n,m \le 10^5$；

对于 $100\%$ 的数据，有 $1 \le n,m \le 10^6$，$0 \le r_i,d_j\le 10^9$，$1 \le s_j\le t_j\le n$。


NOIP 2012 提高组 第二天 第二题

2022.2.20 新增一组 hack 数据

## 样例 #1

### 输入

```
4 3 
2 5 4 3 
2 1 3 
3 2 4 
4 2 4```

### 输出

```
-1 
2```

# AI分析结果



## 算法分类
**二分答案 + 差分数组**

---

## 综合分析与结论

### 核心思路
题目要求找到第一个无法满足的订单编号。由于订单处理的单调性（若第k个订单失败，后续订单必然失败），可采用**二分答案**确定临界点。每次二分时用**差分数组**高效处理区间减法操作，通过前缀和计算每日教室需求，验证是否存在供不应求的情况。

### 难点与解决方案
1. **单调性验证**：  
   若前k个订单可满足，则前k-1个必然满足；若前k个不满足，则后续必然不满足。这一性质保证了二分的正确性。
2. **区间操作优化**：  
   差分数组将区间减法操作（[s_j, t_j] 减去d_j）转化为两次单点修改（diff[s_j]-=d_j, diff[t_j+1]+=d_j），时间复杂度从O(mn)优化至O(m+n)。
3. **空间与常数优化**：  
   差分数组复用内存空间，避免每次二分时创建新数组。最终时间复杂度为O((n+m)logm)，轻松应对1e6规模数据。

---

## 题解评分（≥4星）

### 1. 皎月半洒花（★★★★★）
- **亮点**：  
  详细讲解差分与二分的结合原理，代码清晰易读，通过`isok`函数分离验证逻辑，复用差分数组减少内存消耗。
- **核心代码**：
  ```cpp
  bool isok(int x) {
      memset(diff, 0, sizeof(diff));
      for (int i = 1; i <= x; i++) {
          diff[l[i]] += d[i];
          diff[r[i]+1] -= d[i];
      }
      for (int i = 1; i <= n; i++) {
          need[i] = need[i-1] + diff[i];
          if (need[i] > rest[i]) return 0;
      }
      return 1;
  }
  ```

### 2. WsW_（★★★★☆）
- **亮点**：  
  代码简洁高效，通过`check`函数直接复用差分数组，采用快速IO优化读入速度，适合竞赛场景。
- **核心代码**：
  ```cpp
  bool check(int x) {
      memset(c, 0, sizeof(c));
      for (int i = 1; i <= x; i++) {
          c[a[i].first] += d[i];
          c[a[i].second+1] -= d[i];
      }
      // 前缀和计算与验证
  }
  ```

### 3. _Bluehole（★★★★☆）
- **亮点**：  
  通过逆向思维快速定位失败天数，结合差分数组直接回溯订单，减少无效计算。
- **核心代码**：
  ```cpp
  work_(); // 差分处理
  for (int i = 1; i <= m; i++) {
      if (e[i].x <= temp && e[i].y >= temp) {
          k += e[i].v;
          if (k > a[temp]) { /* 输出结果 */ }
      }
  }
  ```

---

## 最优思路与技巧提炼
1. **二分答案框架**：  
   ```cpp
   int l = 1, r = m;
   while (l < r) {
       int mid = (l + r) >> 1;
       if (check(mid)) l = mid + 1;
       else r = mid;
   }
   ```
2. **差分数组操作**：  
   - 订单影响：`diff[s] += d; diff[t+1] -= d`
   - 前缀和计算：`sum += diff[i]`
3. **空间复用**：  
   每次二分时复用同一差分数组，通过`memset`快速重置。

---

## 相似题目推荐
1. **P3368【模板】树状数组 2**  
   （区间加 + 单点查询，差分思想）
2. **P4552 [Poetize6] IncDec Sequence**  
   （差分数组性质应用）
3. **P2574 XOR的艺术**  
   （区间修改 + 位运算，线段树/差分变种）

---

## 可视化设计（差分数组演示）
### 动画方案
1. **差分操作高亮**：  
   - 用红色标记当前订单影响的区间端点`s_j`和`t_j+1`。
   - 绿色箭头展示`diff[s_j]`和`diff[t_j+1]`的变化。
2. **前缀和计算过程**：  
   - 灰色进度条表示每日剩余教室数，蓝色条表示当前需求。
   - 当某天需求超过剩余量时，触发红色闪烁警告。
3. **复古像素风格**：  
   - 使用16色调色板，教室数量用8x8像素块表示。
   - 音效：区间操作时播放「哔」声，失败时播放「error」音效。

### 交互功能
- **步进控制**：  
  拖动滑块调整二分范围，观察差分数组和前缀和的实时变化。
- **自动演示**：  
  点击「AI Run」自动完成二分过程，速度可调。

---

## 核心代码（二分+差分）
```cpp
#include <cstdio>
#include <cstring>
const int MAXN = 1e6 + 5;
int n, m, r[MAXN], d[MAXN], s[MAXN], t[MAXN], diff[MAXN];

bool check(int x) {
    memset(diff, 0, sizeof(diff));
    for (int i = 1; i <= x; ++i) {
        diff[s[i]] += d[i];
        diff[t[i] + 1] -= d[i];
    }
    int sum = 0;
    for (int i = 1; i <= n; ++i) {
        sum += diff[i];
        if (sum > r[i]) return false;
    }
    return true;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%d", &r[i]);
    for (int i = 1; i <= m; ++i) scanf("%d%d%d", &d[i], &s[i], &t[i]);
    
    int l = 1, r = m, ans = 0;
    if (check(m)) { puts("0"); return 0; }
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (check(mid)) l = mid + 1;
        else r = mid - 1, ans = mid;
    }
    printf("-1\n%d", ans);
    return 0;
}
```

---
处理用时：91.03秒
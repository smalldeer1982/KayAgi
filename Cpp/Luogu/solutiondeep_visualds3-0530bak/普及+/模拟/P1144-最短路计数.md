# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果



# 最短路计数题解分析

## 算法分类
**广度优先搜索（BFS）**

---

## 综合分析与结论
### 核心思路
- **核心逻辑**：在无权图中，BFS天然具有分层特性，每层对应距离+1。首次到达某节点时确定其最短距离，后续相同距离的访问只累加路径数。
- **关键变量**：
  - `dis[]`：存储节点到起点的最短距离
  - `cnt[]`：存储到节点的最短路数量
- **解决难点**：处理重边和自环不影响计数，通过分层遍历保证每个节点被处理的顺序正确。

### 可视化设计思路
1. **像素动画**：用8-bit网格表示节点，不同颜色区分已访问/未访问节点。
2. **高亮机制**：当前处理的节点用闪烁黄色标记，其邻居节点用绿色边框提示。
3. **计数特效**：当节点计数增加时，弹出蓝色数字动画显示`+cnt`。
4. **音效设计**：
   - 节点入队：短促的"哔"声（Web Audio API）
   - 发现新层：复古电子音效
   - 计数更新：金币收集音效
5. **自动演示**：点击"Auto Run"按钮后，算法以0.5秒/步自动执行，可随时暂停。

---

## 题解清单（4星及以上）

### 1. 岸芷汀兰（BFS）⭐️⭐️⭐️⭐️⭐️
- **亮点**：基于BFS的分层特性，代码简洁高效（时间复杂度O(N+M)）
- **核心代码**：
```cpp
void bfs(){
    queue<Node> q; 
    q.push(make(1, 0));
    memset(d, 0x3f, sizeof(d)); 
    d[1] = 0; ans[1] = 1;
    while(q.size()){
        int u = q.front().node;
        for(auto v : linker[u]){
            if(!vis[v]){ // 首次访问
                d[v] = d[u]+1;
                ans[v] = ans[u];
                q.push(v);
            }
            else if(d[v] == d[u]+1) // 同层累加
                ans[v] = (ans[v]+ans[u])%mod;
        }
    }
}
```

### 2. ZiDing_ByronFinlso（SPFA）⭐️⭐️⭐️⭐️
- **亮点**：通过SPFA框架实现，适用带权图扩展
- **优化点**：使用链式前向星存图，内存效率高

### 3. King丨帝御威（Dijkstra）⭐️⭐️⭐️⭐️
- **亮点**：堆优化Dijkstra实现，处理带权图的通用性
- **代码特色**：使用pair存储节点和距离，优先队列优化

---

## 最优思路提炼
**分层计数法**：
1. 初始化起点的`cnt[1] = 1`
2. BFS分层遍历，首次访问节点时：
   ```math
   cnt[v] = cnt[u]
   ```
3. 遇到同层节点时：
   ```math
   cnt[v] = (cnt[v] + cnt[u]) \mod MOD
   ```

---

## 同类题目推荐
1. [P1608 路径统计](https://www.luogu.com.cn/problem/P1608)（带权最短路计数）
2. [P2384 最短路](https://www.luogu.com.cn/problem/P2384)（乘积最短路）
3. [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)（拓扑排序计数）

---

## 个人心得摘录
> "SPFA在带权图计数时可能重复统计，需要拓扑排序处理。而BFS在无权图中天然保证每个节点只被处理一次" —— XZYQvQ  
> "Dijkstra的优先队列优化要注意弹出节点时可能已经不是最短路径" —— 岸芷汀兰

---

## 复古像素动画实现（伪代码）
```javascript
class BFSCounterViz {
  constructor(nodes) {
    this.grid = new PixelGrid(800, 600); // 16色复古调色板
    this.sound = new RetroSound();
    this.queue = new Queue();
    this.initNodes(nodes);
  }

  step() {
    let u = this.queue.dequeue();
    this.grid.highlight(u, COLORS.YELLOW);
    this.sound.play("pop");
    
    u.neighbors.forEach(v => {
      if(v.dist > u.dist + 1) {
        v.dist = u.dist + 1;
        v.cnt = u.cnt;
        this.queue.enqueue(v);
        this.grid.flash(v, COLORS.GREEN);
      } else if(v.dist === u.dist + 1) {
        v.cnt = (v.cnt + u.cnt) % MOD;
        this.grid.showText(v, `+${u.cnt}`, COLORS.BLUE);
      }
    });
  }
}
```

通过方向键控制动画步进，空格键切换自动模式。每个节点的状态通过下方状态栏实时显示距离和计数。

---
处理用时：77.79秒
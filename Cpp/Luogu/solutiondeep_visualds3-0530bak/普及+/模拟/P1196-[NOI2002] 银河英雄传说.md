# 题目信息

# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 说明/提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)

题目中没有强制 $i \neq j$，但是实测数据中不存在 $i = j$ 的情况。

## 样例 #1

### 输入

```
4
M 2 3
C 1 2
M 2 4
C 4 2```

### 输出

```
-1
1```

# AI分析结果



**唯一算法分类**：带权并查集

---

### **综合分析与结论**
#### **核心思路**
1. **带权并查集**：维护每个战舰到所在队列队首的距离（`front[]`数组）及队列长度（`num[]`数组）。
2. **路径压缩**：在查找根节点时递归更新每个节点的`front`值，确保距离实时准确。
3. **合并操作**：将队列A的队首连接到队列B的末尾，更新A队首的`front`值为B队列长度，并累加队列长度。
4. **查询操作**：若两战舰同根，通过`front`差值减1计算中间战舰数。

#### **解决难点**
- **动态维护距离**：通过路径压缩时回溯更新`front`值，避免暴力遍历队列。
- **合并顺序处理**：明确合并方向（将A队列接到B队列尾部），通过`num`数组记录队列长度实现距离调整。

#### **可视化设计思路**
- **动画流程**：
  1. **合并操作**：用箭头表示队列连接，高亮前队列根节点，动态更新其`front`值为后队列长度。
  2. **路径压缩**：递归回溯时用颜色渐变表示节点父指针指向根，动态累加`front`值。
  3. **查询结果**：高亮两节点并显示其`front`值，用线段长度差表示中间战舰数。
- **复古像素风格**：
  - **颜色方案**：根节点用绿色，普通节点用蓝色，路径压缩节点用红色闪烁。
  - **音效**：合并时播放“连接”音效，路径压缩时播放“点击”音效，查询成功用上扬音调。

---

### **题解清单（≥4星）**
1. **假装思考（★★★★★）**  
   - **亮点**：清晰定义`front`和`num`数组，路径压缩时递归更新距离的逻辑简洁。
   - **代码片段**：
     ```cpp
     int find(int n) {
         if (fa[n] == n) return n;
         int fn = find(fa[n]);
         front[n] += front[fa[n]]; // 递归更新距离
         return fa[n] = fn;
     }
     ```
2. **破壁人（★★★★☆）**  
   - **亮点**：简化变量名（`d`代替`front`），合并时直接更新根节点距离。
   - **代码片段**：
     ```cpp
     void merge(int x, int y) {
         int dx = find(x), dy = find(y);
         fa[dx] = dy;
         d[dx] = s[dy]; // s为队列长度
         s[dy] += s[dx];
     }
     ```
3. **Mr_Wolfram（★★★★☆）**  
   - **亮点**：在路径压缩中同时维护队列长度，避免额外数组。
   - **个人心得**：“路径压缩后，`num`数组只需在合并时更新一次。”

---

### **代码实现（核心逻辑）**
```cpp
#include <iostream>
using namespace std;

const int MAXN = 30010;
int fa[MAXN], front[MAXN], num[MAXN];

int find(int x) {
    if (fa[x] != x) {
        int root = find(fa[x]);
        front[x] += front[fa[x]]; // 路径压缩时更新距离
        fa[x] = root;
    }
    return fa[x];
}

void merge(int x, int y) {
    int fx = find(x), fy = find(y);
    fa[fx] = fy;
    front[fx] = num[fy]; // 前队列根节点距离=后队列长度
    num[fy] += num[fx];  // 更新后队列总长度
}

int query(int x, int y) {
    if (find(x) != find(y)) return -1;
    return abs(front[x] - front[y]) - 1;
}

int main() {
    for (int i = 1; i < MAXN; ++i) fa[i] = i, num[i] = 1;
    int T; cin >> T;
    while (T--) {
        char op; int i, j;
        cin >> op >> i >> j;
        if (op == 'M') merge(i, j);
        else cout << query(i, j) << endl;
    }
    return 0;
}
```

---

### **相似题目推荐**
1. **P2342 [NOI2002] 银河英雄传说（原题）**  
2. **P1525 关押罪犯（并查集扩展应用）**  
3. **P2024 食物链（带权并查集经典）**

---

### **个人心得**
- **调试关键**：路径压缩时必须先递归更新父节点距离，再更新当前节点。
- **优化顿悟**：`num`数组只需在合并时更新根节点，路径压缩自动处理子节点。

---
处理用时：61.99秒
# 题目信息

# [NOI2013] 树的计数

## 题目描述

我们知道一棵有根树可以进行深度优先遍历（DFS）以及广度优先遍历（BFS）来生成这棵树的 DFS 序以及 BFS 序。两棵不同的树的 DFS 序有可能相同，并且它们的 BFS 序也有可能相同，例如下面两棵树的 DFS 序都是 `1 2 4 5 3`，BFS 序都是 `1 2 3 4 5`。

![](https://cdn.luogu.com.cn/upload/image_hosting/kagmha60.png)

现给定一个 DFS 序和 BFS 序，我们想要知道，符合条件的有根树中，树的高度的平均值。即，假如共有 $K$ 棵不同的有根树具有这组 DFS 序和 BFS 序，且他们的高度分别是 $h_1, h_2, \ldots, h_K$，那么请你输出：

$$
\frac{h_1+h_2+\ldots+h_K}K
$$

## 说明/提示

如果输出文件的答案与标准输出的差不超过 $0.001$，则将获得该测试点上的分数，否则不得分。

### 数据范围

- 对于 $20\%$ 的测试数据，满足：$n \le 10$；
- 对于 $40\%$ 的测试数据，满足：$n \le 100$；
- 对于 $85\%$ 的测试数据，满足：$n \le 2 \times 10^3$；
- 对于 $100\%$ 的测试数据，满足：$2 \le n \le 2 \times 10^5$。

## 样例 #1

### 输入

```
5 
1 2 4 5 3 
1 2 3 4 5
```

### 输出

```
3.500
```

# AI分析结果



**唯一算法分类**：树的性质与遍历序列分析

---

### **题解思路与解决难点**

**核心思路**：  
将树的高度转化为BFS序的分层数。通过分析DFS与BFS序的约束关系，确定每个位置是否必须分层（贡献1）、不能分层（贡献0）或可分可不分（贡献0.5），最终求期望值。

**关键步骤**：
1. **标号转换**：将BFS序重新标号为1~n，DFS序同步调整。
2. **必须分层点**：根节点单独分层；若BFS序相邻的节点在DFS序中逆序（如`d[x] > d[x+1]`），则必须分层。
3. **禁止分层区间**：若DFS序连续的两个节点i和i+1满足`d[i] < d[i+1] - 1`，则BFS序的`[d[i], d[i+1]-1]`区间内禁止分层（用差分标记）。
4. **期望计算**：未被标记的位置贡献0.5，已标记的位置贡献0，必须分层的位置贡献1。

**解决难点**：  
- **约束关系推导**：DFS和BFS序的交叉约束需细致分析，如DFS序连续节点的父子关系对BFS分层的限制。
- **高效区间标记**：使用差分数组快速处理禁止分层的区间，避免暴力遍历。

---

### **题解评分 (≥4星)**

1. **javalyc (★★★★★)**  
   - 思路清晰，代码简洁，通过差分数组高效处理区间约束。
   - 关键代码段：用`mark`函数差分标记区间，最终遍历统计贡献。
   ```cpp
   void mark(int x, int y) { sum[x]++, sum[y + 1]--; }
   ```

2. **香风智乃 (★★★★☆)**  
   - 详细图解约束条件，代码逻辑与javalyc类似，但变量命名更直观。
   - 核心代码段：通过`d[i]`和`b[i]`的转换处理标号，差分标记逻辑清晰。
   ```cpp
   for (int i=1;i<n;++i) 
       if (d[i]+1 < d[i+1]) mark(d[i], d[i+1]-1);
   ```

3. **CXY07 (★★★★☆)**  
   - 引入生成函数和期望分析，数学推导严谨，但代码实现稍显复杂。
   - 关键点：通过动态规划状态转移和差分数组结合，适合高阶理解。

---

### **最优思路提炼**

1. **差分标记区间**  
   使用差分数组快速标记禁止分层的区间，避免逐个遍历，时间复杂度O(n)。
   ```cpp
   // 标记区间 [l, r] 禁止分层
   void mark(int l, int r) {
       diff[l]++;
       diff[r + 1]--;
   }
   ```

2. **贡献分类计算**  
   - **必须分**：BFS序相邻且DFS序逆序，贡献1。
   - **禁止分**：被差分标记覆盖的位置，贡献0。
   - **不确定分**：未被标记的位置，贡献0.5。

---

### **类似题目推荐**

1. **P1030 求先序排列**：根据中序和后序求先序，遍历序列转换。
2. **P1229 遍历问题**：利用前序和后序确定可能的二叉树结构。
3. **P1827 美国血统**：通过中序和前序求后序，树的遍历序列分析。

---

### **可视化与算法演示**

**动画设计**：
1. **分层展示**：  
   - 将BFS序以颜色块横向排列，绿色表示当前层，红色表示必须分层的位置。
   - 高亮当前处理的BFS节点对（如x和x+1），若需分层则分裂颜色块。
   
2. **差分标记过程**：  
   - 用蓝色覆盖禁止分层的区间，动态显示差分数组的更新。
   - 示例：DFS序连续的两个节点i和i+1触发区间标记，蓝色覆盖对应BFS区间。

3. **贡献统计**：  
   - 显示每个位置的颜色（红/蓝/灰），右侧实时更新贡献总和。

**复古像素风格**：
- **颜色方案**：红（必须分）、蓝（禁止分）、灰（不确定）。
- **音效**：分层时播放“滴”声，标记区间时播放“嘟”声，计算完成播放8-bit胜利音效。

---

### **核心代码实现**

```cpp
#include <cstdio>
const int N = 2e5 + 10;
int n, d[N], pos[N], sum[N];
double ans = 1;

void mark(int x, int y) { sum[x]++, sum[y + 1]--; }

int main() {
    scanf("%d", &n);
    for (int i = 1, x; i <= n; i++) scanf("%d", &x), d[x] = i;
    for (int i = 1, x; i <= n; i++) scanf("%d", &x), pos[d[x]] = i;
    for (int i = 1; i <= n; i++) d[pos[i]] = i;
    
    mark(1, 1); // 根节点必须分层
    for (int i = 1; i < n; i++) {
        if (d[i] > d[i + 1]) {
            ans += 1;
            mark(i, i); // 必须分层
        }
        if (pos[i] < pos[i + 1] - 1)
            mark(pos[i], pos[i + 1] - 1); // 禁止分层区间
    }
    
    int now = 0;
    for (int i = 1; i < n; i++) {
        now += sum[i];
        ans += (now ? 0 : 0.5); // 未被标记则贡献0.5
    }
    printf("%.3f\n", ans);
    return 0;
}
```

**代码说明**：
- `d[i]`：节点i在DFS序中的位置。
- `pos[i]`：BFS序为i的节点在DFS序中的位置。
- `sum`数组：差分标记禁止分层的区间。
- 最终遍历时，未被标记的位置贡献0.5。

---
处理用时：70.30秒
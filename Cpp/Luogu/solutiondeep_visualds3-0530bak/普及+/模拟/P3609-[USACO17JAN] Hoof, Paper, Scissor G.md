# 题目信息

# [USACO17JAN] Hoof, Paper, Scissor G

## 题目背景

*本题与 [银组同名题目](/problem/P6120) 在题意上一致，唯一的差别在于对变手势次数的限制。*


## 题目描述

你可能玩过“石头，剪刀，布”，这个游戏在奶牛中同样流行，不过它的名字变成了“蹄子，剪刀，布”。

“蹄子，剪刀，布”和“石头，剪刀，布”的规则十分类似，两只奶牛数到三，然后出一个代表蹄子，剪刀或布的手势。蹄子胜过剪刀，剪刀胜过布，布胜过蹄子。特别地，如果两只奶牛的手势相同，则视为平局。

现在 FJ 和 Bassie 要进行 $N$ 轮对抗。Bassie 已经预测了 FJ 每一轮要出的手势。然而 Bassie 很懒，她最多只想变换 $K$ 次手势。

现在请你帮 Bassie 求出她最多能赢多少轮。

## 样例 #1

### 输入

```
5 1
P
P
H
P
S```

### 输出

```
4
```

# AI分析结果



**算法分类**  
动态规划

---

**题解思路与核心难点**  
**核心思路**：使用三维动态规划 `f[i][j][k]` 表示前 `i` 轮，变换 `j` 次手势，当前手势为 `k` 时的最大胜利次数。通过状态转移方程，仅依赖前一状态，将时间复杂度优化至 `O(N*K)`。  
**关键难点**：  
1. **状态转移优化**：从枚举历史所有可能变换点优化为仅依赖前一轮状态，避免 `O(N^2)` 复杂度。  
2. **手势胜负判断**：预处理每轮不同手势的胜负结果，通过前缀和或直接判断实现快速计算。  
**解决难点**：  
- 转移时比较保持当前手势或从其他两种手势变换而来，取最大值。  
- 使用滚动数组或压缩维度减少内存消耗。

---

**题解评分（≥4星）**  
1. **zgf519orz（5星）**  
   - 思路清晰，优化后的DP实现高效。  
   - 代码可读性强，注释详细。  
   - 通过前缀和预处理简化计算。  

2. **Meditations（4星）**  
   - 状态定义简洁，转移逻辑明确。  
   - 使用 `pk` 数组快速判断胜负。  
   - 代码结构清晰，适合快速理解核心逻辑。  

3. **薛裕龙（4星）**  
   - 采用模运算简化胜负判断。  
   - 滚动数组优化内存使用。  
   - 代码简洁，适合竞赛场景。

---

**最优思路提炼**  
1. **三维状态设计**：记录轮数、变换次数、当前手势。  
2. **前缀和预处理**：快速计算连续相同手势的胜利次数。  
3. **状态转移优化**：仅依赖前一轮状态，时间复杂度 `O(N*K)`。  
4. **滚动数组技巧**：减少内存占用，适用于大规模数据。

---

**同类型题与算法套路**  
- **通用DP模型**：适用于状态受多因素影响的最优化问题（如背包问题、路径规划）。  
- **手势类博弈问题**：类似「石头剪刀布」变种，需结合状态机思想。

**类似题目推荐**  
1. P2583 三带一（动态规划 + 状态转移）  
2. P1352 没有上司的舞会（树形DP，状态依赖）  
3. P1064 金明的预算方案（多维约束优化）

---

**个人心得摘录**  
- **zgf519orz**：优化时意识到 `i` 状态仅依赖 `i-1`，避免无效枚举。  
- **南城忆潇湘**：通过胜负关系转换简化判断逻辑。  
- **WayneStewart**：记忆化搜索更直观，但需注意递归边界条件。

---

**可视化与算法演示**  
**动画设计**：  
1. **网格视图**：以轮数为行，变换次数为列，手势用不同颜色块表示。  
2. **状态更新高亮**：当前轮手势变化时，箭头从上一状态指向当前块，颜色渐变。  
3. **胜负标记**：每轮显示FJ手势与Bassie手势对比，胜利轮次闪烁。  

**复古像素风格**：  
- **8-bit音效**：变换手势时播放「哔」声，胜利时播放「叮」声。  
- **Canvas绘制**：手势用像素图标（蹄子=方块，剪刀=三角，布=圆）。  
- **自动演示模式**：按轮次逐步推进，显示状态转移路径。

---

**核心代码片段（以zgf519orz优化版为例）**  
```cpp
int main() {
    // 预处理每轮出H/S/P能否赢
    for (int i=1; i<=n; i++) {
        char tmp; cin >> tmp;
        h[i] = (tmp == 'S');  // H赢S
        s[i] = (tmp == 'P');  // S赢P
        p[i] = (tmp == 'H');  // P赢H
    }

    // DP转移（仅保留核心循环）
    for (int i=1; i<=n; i++) {
        for (int j=0; j<=m; j++) {
            // 当前出H，可从上一轮H继承或从S/P变换
            f[i][j][0] = max(f[i-1][j][0] + h[i], 
                max(f[i-1][j-1][1], f[i-1][j-1][2]) + h[i]);
            // 类似处理S和P
        }
    }
    // 取所有可能状态的最大值
    cout << max(f[n][m][0], max(f[n][m][1], f[n][m][2]));
}
```

---
处理用时：73.90秒
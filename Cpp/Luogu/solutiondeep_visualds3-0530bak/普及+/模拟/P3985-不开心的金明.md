# 题目信息

# 不开心的金明

## 题目描述

金明今天很不开心，家里购置的二手房就要领钥匙了，房里并没有一间他自己专用的很宽敞的房间。更让他不高兴的是，妈妈昨天对他说：“你需要购买哪些物品，怎么布置，你说了不算（有很大的限制），而且不超过 $W$ 元钱。”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 $W$ 元。于是，他把每件物品规定了一个重要度整数 $p_i$ 表示。他还从因特网上查到了每件物品的价格 $v_i$（都是整数元）。

妈妈看到购物单后进行了审查，要求购物单上所有的物品价格的极差（最贵的减去最便宜的）不超过 $3$（当然金明至今不知道为什么会这样）。他希望在不超过 $W$ 元（可以等于 $W$ 元）的前提下，使购买的重要度总和 $\sum p_i$ 的最大。


请你帮助金明设计一个满足要求的购物单，你只需要告诉我们重要度的最大的和。


## 说明/提示

$1 \le N \le 100$。

$1 \le W \le 10^9$。

$1 \le v_i \le 10^9$。

对所有的 $i=1,2,3,…,N$，$\min(v_i) \le v_i \le \min(v_i)+3$。

$1 \le p_i \le 10^7$。


## 样例 #1

### 输入

```
5 10
2 800
5 400
5 300
3 400
2 200
```

### 输出

```
1600```

# AI分析结果



## 算法分类
动态规划（背包问题变种）

---

## 综合分析与结论

### 核心思路与难点
题目要求满足极差≤3且总价≤W的情况下最大化重要度。关键点在于利用极差条件将价格离散化为4种可能值（minv到minv+3），从而大幅压缩状态空间。核心解法分为两种思路：
1. **动态规划状态压缩**：将物品价格转换为相对于最小值的偏移量（0~3），用dp[i][j]表示选j个物品时偏移总量为i的最大重要度。总价=偏移总量+j*minv。
2. **分组枚举**：将物品按价格分为4组，分别预处理前缀和，四重循环枚举各组数量，计算合法组合的最大重要度。

难点在于处理极大W值（1e9）与传统背包的矛盾，通过极差特性将状态维度从价格转换为偏移量/物品数量是关键突破。

---

## 题解清单（≥4星）

1. **蓝莲花__（5星）**
   - 亮点：普适性强，将价格转换为相对值压缩状态空间，二维DP巧妙记录物品数量与偏移量。
   - 核心代码片段：
     ```cpp
     for (int i=1;i<=n;i++)
     for (int j=sv;j>=v[i];j--)
     for (int k=n;k>=1;k--)
         if (j+k*minv <= sumv) 
             dp[j][k] = max(dp[j][k], dp[j-v[i]][k-1]+w[i]);
     ```

2. **林聪（4星）**
   - 亮点：直观分组，四重循环枚举各价格组数量，配合前缀和快速计算。
   - 核心代码：
     ```cpp
     for(int i=0;i<=tot0;i++)
     for(int j=0;j<=tot1;j++)
     for(int k=0;k<=tot2;k++) {
         int sum = i*minn + j*(minn+1) + k*(minn+2);
         if(sum <= m) {
             int l = (m-sum)/(minn+3);
             ans = max(ans, s0[i]+s1[j]+s2[k]+s3[l]);
         }
     }
     ```

3. **sy_zmq_001（4星）**
   - 亮点：分治策略，对minv≤300与>300分别处理，结合背包与贪心。
   - 核心判断：
     ```cpp
     if(minn <= 300) { /* 背包 */ }
     else { /* 贪心选重要度最高 */ }
     ```

---

## 最优思路提炼

**关键技巧**：
1. **价格离散化**：所有价格转换为相对于minv的偏移量（0~3），压缩状态至可处理范围。
2. **双维度DP**：用偏移量总和+物品数量计算总价，避免直接存储极大W值。
3. **分组前缀和**：对同一价格物品按重要度排序预处理前缀和，快速计算任意数量组合的价值。

**思维突破**：利用极差限制将无限价格范围转化为有限偏移量，通过数学转换将总价计算分解为可管理的部分。

---

## 同类型题推荐

1. **P1064 金明的预算方案**（依赖背包）
2. **P1776 宝物筛选**（多重背包单调队列优化） 
3. **P1417 烹调方案**（时间影响价值的背包）

---

## 可视化设计（复古像素风）

### 动画方案
1. **状态矩阵展示**：  
   用16x16像素块组成DP矩阵，x轴为偏移量（0~300），y轴为物品数量。每次更新时高亮当前处理的`dp[j][k]`，旧值闪烁红色，新值绿色填充。

2. **物品处理动效**：  
   物品图标从右侧飞入，显示价格偏移量（0-3）。处理时在对应偏移列产生"+"特效，重要度数值以8位字体弹出。

3. **音效设计**：
   - 更新最优解：FC风格的"升级"音效（3个上升音符）
   - 背包容量溢出：短促"哔"声
   - 背景音乐：循环的8位芯片音乐

### 交互功能
- **步进控制**：方向键←→控制处理物品的进度
- **自动演示**：按A键启动AI自动播放，速度可调
- **数据面板**：右侧显示当前处理物品的price/p，DP矩阵最大值闪烁黄框

---

## 核心代码实现（蓝莲花解法）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mx=110;
int dp[mx*5][mx], n, w[mx], v[mx], sumv, minv=1e10, sv;

int main() {
    cin >> n >> sumv;
    for (int i=1; i<=n; i++) {
        cin >> v[i] >> w[i];
        minv = min(minv, v[i]);
        sv += v[i];
    }
    minv--;
    for (int i=1; i<=n; i++) v[i] -= minv;
    sv -= n*minv;

    for (int i=1; i<=n; i++)
        for (int j=sv; j>=v[i]; j--)
            for (int k=n; k>=1; k--)
                if (j + k*minv <= sumv)
                    dp[j][k] = max(dp[j][k], dp[j-v[i]][k-1] + w[i]);

    int ans = 0;
    for (int j=1; j<=sv; j++)
        for (int i=1; i<=n; i++)
            ans = max(ans, dp[j][i]);
    cout << ans;
    return 0;
}
```

**实现要点**：
- 预处理将价格转换为相对值`v[i] -= minv`
- 三维循环逆序更新避免重复选择
- 最终遍历所有可能的偏移量和物品数量组合求最大值

---

通过结合动态规划的状态压缩与极差特性，该解法高效处理了大规模价格范围的限制，是背包问题中状态设计的经典优化案例。

---
处理用时：111.02秒
# 题目信息

# 「SWTR-2」Crystal Balls

## 题目背景

$\mathrm{Ethan}$ 有一些可以释放强大能量的水晶球，他将要用这些水晶球合成可以消灭敌人的魔法。

- $a\equiv b\mathrm{\ (mod\ m)}$ 表示 $a$ 和 $b$ 对模 $m$ 同余，即 $(a-b)/m$ 为整数。

## 题目描述

$\mathrm{Ethan}$ 有 $n$ 个水晶球，现在他将这些水晶球排成一行，每一个水晶球上面有一个能量值，且**要么是绿色，要么是紫色**。

- 下文中，$P$ 代表紫色，$G$ 代表绿色。

$\mathrm{Ethan}$ 现在要按以下方式取走这些水晶球：

1. 取走**最左端**的水晶球。

2. 假设取走的水晶球的颜色为 $c_1$，能值为 $x_1$，**剩余最左端**的水晶球的颜色为 $c_2$，能量为 $x_2$，取出水晶的次数为 $cnt$（包括这一次）。

- 如果 $c_1=c_2$，那么 $\mathrm{Ethan}$ 会将这两个水晶球合成为一个大水晶球（本次取出的水晶球仍计入答案总数内，详情见样例），颜色为 $c_1$，能量值为 $x_1 \times x_2$，放在水晶球序列的**最左端**。

- 如果，$c_1=P,c_2=G,cnt\equiv 1\mathrm{\ (mod\ 2)}$，那么 $\mathrm{Ethan}$ 会将剩下的水晶球的**颜色反转**（即绿色变紫色，紫色变绿色）。

- 如果仍不能满足上面的条件，那么 $\mathrm{Ethan}$ 会将剩下的水晶球**序列翻转**。

就这样，直到最后只剩下一个球，此时 $\mathrm{Ethan}$ 会直接取走最后一个球，求取走的水晶球的**能量值之和**。

由于答案很大，请对 $p$ 取模。

## 说明/提示

---

### 样例说明

**样例 $1$：**

$\mathrm{Ethan}$ 首先会取出最左端的水晶球，颜色为 ```G```，答案加上它上面所写上的数字，即 $1$，剩下的水晶球翻转，序列变为 $4\ 3\ 2$ ```GGP```。（因为 $c_1=G,c_2=P$，取出水晶球的次数为奇数，不满足条件 $1,2$，所以序列翻转）。

再取出最左端的水晶球，颜色为 ```G```，答案加上 $4$，接着把剩下来最左端的水晶球与取走的水晶球合并成一个大的水晶球，写上的数字为 $12$，序列变为 $12\ 2$ ```GP```。

取出最左边的水晶球，颜色为 ```G```，答案加上 $12$，剩下的水晶球序列翻转，序列变为 $2$ ```P```。

取出最后一个的水晶球，答案加上 $2$，最终答案为 $1+4+12+2=19$。

**样例 $2$：**

先取出 $3$，$c_1=P,c_2=G,cnt=1$，颜色翻转

取出 $7$，$c_2=c_3=P$，将 $x_3$ 乘上 $x_2$，得到 $x_3=35$

取出 $35$，最终答案为 $3+7+35=45$

---

### 数据范围与约定

本题采用 $\mathrm{Subtask}$ 制。

$\mathrm{Subtask}\ 1:n\leq 2000,a_i\leq 10^9,p\leq 10^9,15\%$。

$\mathrm{Subtask}\ 2:n\leq 5\times 10^4,a_i\leq 10^9,p\leq 10^9,15\%$。

$\mathrm{Subtask}\ 3:n\leq 5\times 10^4,a_i\leq 10^{18},p\leq 10^{18},20\%$。

$\mathrm{Subtask}\ 4:n\leq 10^6,a_i\leq 10^9,p\leq 10^9,20\%$。

$\mathrm{Subtask}\ 5:n\leq 10^6,a_i\leq 10^{18},p\leq 10^{18},30\%$。

---

对于所有测试点，时间限制 $1s$，空间限制 $16MB$。

## 样例 #1

### 输入

```
4 998244353
1 2 3 4
GPGG```

### 输出

```
19```

## 样例 #2

### 输入

```
3 998244353
3 7 5
PGG```

### 输出

```
45```

## 样例 #3

### 输入

```
10 998244353
12345 23456 34567 45678 56789 67890 78901 89012 90123 101234
GPPGPGGGPG```

### 输出

```
104157290```

# AI分析结果



**唯一算法分类**  
模拟

---

**题解思路、算法要点与解决难点**  

- **核心思路**  
  所有题解均通过**双指针+状态标记**高效模拟操作，避免直接处理序列翻转。关键变量包括：
  - `head`/`tail`：当前序列端点。
  - `dir`：方向（+1向右，-1向左）。
  - `mask`：颜色反转标记（异或运算快速切换颜色）。
  
- **算法要点**  
  1. **合并操作**：颜色相同时，直接合并到相邻位置并用快速乘处理大数。
  2. **颜色反转**：通过`mask`异或标记，避免实际修改颜色数组。
  3. **序列翻转**：交换`head`/`tail`并反转`dir`，避免物理翻转数组。

- **解决难点**  
  - **快速乘**：处理大数相乘时，使用`long double`技巧或拆分为二进制加法避免溢出。
  - **状态同步**：操作后需同步指针、方向、颜色标记的联动变化。

---

**题解评分 (≥4星)**  

1. **Alex_Wei (5星)**  
   - 亮点：变量设计简洁，快速乘优化到位，代码高效易读。
   - 关键代码：通过`dir`控制方向，`mask`异或处理颜色反转。

2. **mlvx (4星)**  
   - 亮点：用`rev`标记序列方向，逻辑清晰。
   - 关键代码：`rev`切换时调整指针移动方向，避免数组翻转。

3. **3ksc03_is_sb (4星)**  
   - 亮点：快速乘实现巧妙，代码注释详细。
   - 关键代码：利用`unsigned`溢出特性实现快速取模。

---

**最优思路或技巧提炼**  

1. **双指针与方向控制**  
   - 用`head`和`tail`表示当前序列端点，`dir`表示移动方向（+1或-1）。
   - 序列翻转时只需交换`head`/`tail`并反转`dir`，时间复杂度O(1)。

2. **颜色反转标记**  
   - 用`mask`变量异或计算当前颜色（0未反转，1已反转），判断颜色时取原色异或`mask`。

3. **快速乘优化**  
   - 使用`long double`计算中间值，避免直接乘法溢出（如`a * b - floor(a*b/mod)*mod`）。

---

**同类型题或类似算法套路**  

- **双指针模拟**：如[NOIP2016 玩具谜题](https://www.luogu.com.cn/problem/P1563)，通过方向标记处理环形移动。
- **状态压缩**：如[LeetCode 73. Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/)，用标记替代实际修改。
- **快速乘/幂**：涉及大数运算的题目（如[Luogu P3811](https://www.luogu.com.cn/problem/P3811) 乘法逆元）。

---

**推荐相似题目**  

1. [P1563 玩具谜题](https://www.luogu.com.cn/problem/P1563)  
2. [P1965 转圈游戏](https://www.luogu.com.cn/problem/P1965)  
3. [P5657 格雷码](https://www.luogu.com.cn/problem/P5657)

---

**个人心得摘录**  

- **Alex_Wei**：强调快速乘的必要性，避免因毒瘤数据卡常。
- **pomelo_nene**：调试快速乘时多次WA，最终改用`__int128`通过。
- **Lcm_simida**：通过`f1`和`f2`简化条件判断，减少冗余代码。

---

**可视化与算法演示**  

- **动画设计**：  
  - **Canvas 网格**：显示水晶球序列，当前`head`/`tail`用箭头高亮。
  - **颜色标记**：用绿色/紫色方块表示颜色，反转时整体色调切换。
  - **操作高亮**：合并时闪烁相邻方块，反转时旋转整个序列区域。

- **复古像素风格**：  
  - **8位音效**：合并时播放“哔”声，反转时播放“咔嚓”声。
  - **自动演示**：按步骤自动执行，可暂停/调速观察变量变化。

- **交互控制**：  
  - **速度滑块**：调节动画速度（1x~10x）。
  - **单步执行**：点击按钮逐步观察`head`、`tail`、`mask`变化。

---

**核心代码片段**  

```cpp
// Alex_Wei 的核心逻辑
int head=1, tail=n, dir=1, mask=0;
ll ans=0;
for (int cnt=1; cnt <n; cnt++) {
    ans = (ans + a[head]) % mod;
    bool c1 = (s[head]=='G') ^ mask;
    bool c2 = (s[head+dir]=='G') ^ mask;
    if (c1 == c2) { // 合并
        a[head+dir] = quick_mul(a[head], a[head+dir], mod);
        head += dir;
    } else if (c1 && !c2 && (cnt%2)) { // 颜色反转
        mask ^= 1;
        head += dir;
    } else { // 序列翻转
        swap(head, tail);
        dir = -dir;
        head += dir;
    }
}
ans = (ans + a[head]) % mod;
```

---

**总结**  
通过状态标记与双指针高效模拟操作，避免直接处理复杂序列变化，结合快速乘解决大数问题。核心在于变量设计与状态同步，时间复杂度O(n)，适用于1e6级数据。

---
处理用时：79.41秒
# 题目信息

# [CSP-S2020] 儒略日

## 题目描述

为了简便计算，天文学家们使用儒略日（Julian day）来表达时间。所谓儒略日，其定义为从**公元前 4713 年 1 月 1 日正午 12 点到此后某一时刻间所经过的天数**，不满一天者用小数表达。若利用这一天文学历法，则每一个时刻都将被均匀的映射到数轴上，从而得以很方便的计算它们的差值。

现在，给定一个不含小数部分的儒略日，请你帮忙计算出该儒略日（一定是某一天的中午 12 点）所对应的公历日期。

我们现行的公历为格里高利历（Gregorian calendar），它是在公元 1582 年由教皇格里高利十三世在原有的儒略历（Julian calendar）的基础上修改得到的（注：儒略历与儒略日并无直接关系）。具体而言，现行的公历日期按照以下规则计算：

1. 公元 1582 年 10 月 15 日（含）以后：适用格里高利历，每年一月 $31$ 天、 二月 $28$ 天或 $29$ 天、三月 $31$ 天、四月 $30$ 天、五月 $31$ 天、六月 $30$ 天、七月 $31$ 天、八月 $31$ 天、九月 $30$ 天、十月 $31$ 天、十一月 $30$ 天、十二月 $31$ 天。其中，闰年的二月为 $29$ 天，平年为 $28$ 天。当年份是 $400$ 的倍数，或日期年份是 $4$ 的倍数但不是 $100$ 的倍数时，该年为闰年。
2. 公元 1582 年 10 月 5 日（含）至 10 月 14 日（含）：不存在，这些日期被删除，该年 10 月 4 日之后为 10 月 15 日。
3. 公元 1582 年 10 月 4 日（含）以前：适用儒略历，每月天数与格里高利历相同，但只要年份是 $4$ 的倍数就是闰年。
4. 尽管儒略历于公元前 45 年才开始实行，且初期经过若干次调整，但今天人类习惯于按照儒略历最终的规则反推一切 1582 年 10 月 4 日之前的时间。注意，**公元零年并不存在**，即公元前 1 年的下一年是公元 1 年。因此公元前 1 年、前 5 年、前 9 年、前 13 年……以此类推的年份应视为闰年。

## 说明/提示

**【数据范围】**

| 测试点编号 | $Q =$ | $r_i \le$ |
|:-:|:-:|:-:|
| $1$ | $1000$ | $365$ |
| $2$ | $1000$ | $10^4$ |
| $3$ | $1000$ | $10^5$ |
| $4$ | $10000$ | $3\times 10^5$ |
| $5$ | $10000$ | $2.5\times 10^6$ |
| $6$ | $10^5$ | $2.5\times 10^6$ |
| $7$ | $10^5$ | $5\times 10^6$ |
| $8$ | $10^5$ | $10^7$ |
| $9$ | $10^5$ | $10^9$ |
| $10$ | $10^5$ | 年份答案不超过 $10^9$ |

## 样例 #1

### 输入

```
3
10
100
1000```

### 输出

```
11 1 4713 BC
10 4 4713 BC
27 9 4711 BC```

## 样例 #2

### 输入

```
3
2000000
3000000
4000000```

### 输出

```
14 9 763
15 8 3501
12 7 6239```

## 样例 #3

### 输入

```
见附件中的 julian/julian3.in```

### 输出

```
见附件中的 julian/julian3.ans```

# AI分析结果



### 算法分类
**模拟 & 日期处理**

---

### 题解思路与核心难点

#### 核心思路
1. **分段处理历法**：分为儒略历（1582年10月4日前）与格里高利历（1582年10月15日后），中间10天直接跳过。
2. **周期优化**：儒略历每4年一周期（1461天），格里高利历每400年一周期（146097天），通过模运算快速定位年份。
3. **闰年判断**：儒略历下年份为4的倍数为闰年；格里高利历需额外排除能被100整除但不能被400整除的情况。

#### 解决难点
- **边界处理**：公元前1年与公元1年的衔接，1582年10月缺失的10天。
- **高效计算**：对超大年份（如1e9年）需避免逐天计算，通过周期跳跃优化时间复杂度至O(1)。
- **代码实现**：统一处理日期增减逻辑，避免重复代码。

---

### 题解评分（≥4星）

1. **「已注销」题解（⭐️⭐️⭐️⭐️⭐️）**  
   - **亮点**：预处理400年周期，利用模运算快速定位年份，代码简洁高效，时间复杂度O(1)。  
   - **核心代码**：  
     ```cpp
     if (n > 2299160) { // 格里高利历
         n -= 2159351;
         t = n / N * 400 + 1200;
         n %= N;
     } else { // 儒略历
         t = n / 1461 * 4 - 4712;
         n %= 1461;
     }
     ```

2. **OMG_wc题解（⭐️⭐️⭐️⭐️）**  
   - **亮点**：二分法确定年份，逻辑清晰，处理1582年特殊日期时直接修正天数。  
   - **核心代码**：  
     ```cpp
     while (l < r) { // 二分年份
         int mid = (l + r) >> 1;
         if (cal(mid) >= n) r = mid;
         else l = mid + 1;
     }
     ```

3. **PrincessQi题解（⭐️⭐️⭐️⭐️）**  
   - **亮点**：分阶段处理不同历法时期，对1582年特殊逻辑单独处理，代码可读性强。  
   - **核心代码**：  
     ```cpp
     if (n <= 2299160) { // 儒略历
         // ... 
     } else { // 格里高利历
         n += 10; // 跳过删除的10天
     }
     ```

---

### 最优思路与技巧
- **周期跳跃**：通过预处理400年周期天数，直接计算大范围年份，避免逐日累加。
- **二分优化**：对年份进行二分查找，快速定位目标日期所在年份。
- **模块化处理**：将闰年判断、月份天数计算封装为独立函数，增强代码复用性。

---

### 类似题目推荐
1. **P1202 [USACO1.1] 黑色星期五**：计算每月13日为星期几的频率。
2. **P1516 青蛙的约会**：日期循环与模运算结合。
3. **P1057 校门外的树**：区间覆盖问题，需处理大量日期或位置。

---

### 可视化与算法演示

#### 动画设计
1. **分阶段着色**：儒略历阶段用蓝色背景，格里高利历用绿色，被删除的10天标记为红色。
2. **步进控制**：允许单步执行年份跳跃或逐日推进，展示周期跳跃时的年份变化。
3. **像素风格**：用8位风格显示日期面板，每次按键触发“滴答”音效，闰年时播放上扬音效。

#### 关键动画逻辑
```javascript
// 伪代码：周期跳跃动画
function jumpYears(targetDays) {
    let cycles = Math.floor(targetDays / 146097);
    targetDays %= 146097;
    ctx.fillText(`跳跃 ${cycles} 个400年周期`, x, y);
    playSound('jump'); // 跳跃音效
}
```

---

### 代码片段（已注销题解核心逻辑）
```cpp
const int N = 146097; // 格里高利历400年天数
int y[N], m[N], d[N];

// 预处理400年内的日期
m[0] = d[0] = 1;
for (int i = 1; i < N; i++) {
    d[i] = d[i-1] + 1;
    if (d[i] > month_days(y[i-1], m[i-1])) {
        m[i] = m[i-1] + 1;
        d[i] = 1;
        if (m[i] > 12) y[i] = y[i-1] + 1;
    }
}

// 计算答案
if (r > 2299160) {
    r -= 2159351;
    int cycles = r / N;
    year = cycles * 400 + 1200;
    r %= N;
} else {
    // 处理儒略历
}
```

---

### 个人心得摘录
- **「已注销」调试笔记**：最初未考虑公元前1年的闰年规则，导致公元前1年误判为平年，通过单独验证公元前4713年数据修复。
- **OMG_wc踩坑**：二分时未处理1582年10月特殊区间，导致答案偏移10天，增加特判后通过。

---
处理用时：83.78秒
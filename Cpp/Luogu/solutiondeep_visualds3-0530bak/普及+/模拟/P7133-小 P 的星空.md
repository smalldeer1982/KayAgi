# 题目信息

# 小 P 的星空

## 题目背景



>星依云渚溅溅，露零玉液涓涓，宝砌哀兰剪剪。碧天如练，光摇北斗阑干。
>
>—— 【元】孟昉《天净沙 · 星依云渚溅溅》

小 P 漫步于星空之下。

“摘下星星送给你，你就是我的全世界”。

“今夜，我不关心人类，我只想你”。

## 题目描述

将星空看作一个平面直角坐标系，小 P 所在的位置为 $(0,0)$，即坐标原点。天上共有 $n$ 颗星星，第 $i$ 颗星星的坐标为 $(x_i,y_i)$。

小 P 最初面向点 $(1,0)$，然后小 P 会进行 $m$ 次原地转动，第 $i$ 次转动后会面向点 $(u_i,v_i)$。

他可以选择逆时针转动或顺时针转动，当面向此次旋转最终将要面向的方向时，此次转动立即停止。

他相信，在转动过程中，越多的星星出现在他正前方，他【数据删除】。

小 P 想知道，每一次转动过程中他最多可以让多少星星出现在他正前方（包括转动初始方向和结束方向正前方看到的星星）。

## 说明/提示

样例1示意图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/h2t5eu1a.png)

橙色点为星星，绿色点小 P 第一次的转动位置。第一次转动，从 $(1,0)$ 转到 $(-1,1)$。若顺时针转动(蓝色区域，包括边界)，$(1,0)$, $(-2,-1)$，共计 $2$ 颗星星；而逆时针转动(绿色区域，包括边界)，$(1,0)$, $(1,1)$,$(2,2)$,$(-1,2)$，共计 $4$ 颗星星。

第二次转动，从 $(-1,1)$ 转到 $(-1,2)$，逆时针转动，$5$ 颗星星都会在转动过程中出现在小 P 正前方。

![](https://cdn.luogu.com.cn/upload/image_hosting/b22go7at.png)

除测试点 $24$ 和 $25$ 外，其他测试点保证所有坐标的绝对值 $\le 1000$。

对于前 $12$ 个测试点，保证原点到任意星星形成的射线上没有其他星星。

除 $23,25$ 测试点外，对于所有编号为奇数的测试点，保证小 P 初始面向方向和每次转动目标方向上没有任何星星。

除 $22,24$ 测试点外，对于所有编号为偶数的测试点，保证小 P 初始面向方向和每次转动目标方向上至少有一颗星星。

对于 $100\%$ 的数据，保证星星的坐标互不相同，保证坐标不会出现 $(0,0)$，保证不会出现转动初始方向等于结束方向。

样例 $3$ 满足偶数测试点的限制。

## 样例 #1

### 输入

```
5 2
1 0
1 1
2 2
-1 2
-2 -1
-1 1
-1 2```

### 输出

```
4
5```

## 样例 #2

### 输入

```
见下发文件 ex_star2.in```

### 输出

```
见下发文件 ex_star2.out```

## 样例 #3

### 输入

```
见下发文件 ex_star3.in```

### 输出

```
见下发文件 ex_star3.out```

# AI分析结果



---

## 唯一算法分类  
极角排序（逆时针）+ 二分查找  

---

## 综合分析与结论  
### 核心思路  
将星星按逆时针方向排序，每次转动时通过二分查找确定起始方向与目标方向之间的区间，计算该区间包含的星星数量。由于顺时针和逆时针转动的可见星星数量之和为总星数，取两者最大值即可。

### 解决难点  
1. **精度问题**：  
   出题人题解通过 **象限划分+叉积比较** 避免浮点运算，其他题解通过约分或放大精度处理。  
2. **极角排序稳定性**：  
   同一方向上的星星需合并处理（如约分后的坐标），避免重复计算。  
3. **边界处理**：  
   起始方向与目标方向可能跨越多象限，需正确计算环形区间。

### 可视化设计  
1. **极坐标系动态扫描**：  
   - 初始方向（绿色箭头）、目标方向（红色箭头）在极坐标系中高亮显示。  
   - 顺时针（蓝色扇形）和逆时针（黄色扇形）扫描区域动态展开，覆盖的星星闪烁。  
2. **复古像素风格**：  
   - 用 8 位色块表示不同象限（红/黄/蓝/绿四色）。  
   - 关键星星用 16x16 像素图标表示，扫描时播放 8-bit 音效。  
3. **AI 自动演示**：  
   自动遍历所有转动步骤，展示最优路径的选择逻辑。  

---

## 题解清单（评分 ≥4星）  
1. **作者：tuxiaobei（★★★★★）**  
   - **亮点**：避免浮点运算，用象限与叉积实现稳定排序，代码简洁高效。  
   - **关键代码**：  
     ```cpp  
     // 象限划分与叉积比较  
     bool operator<(const point& p) const {  
         if (c != p.c) return c < p.c;  
         if (c == 1 || c == 5) return (ll)x*p.y > (ll)y*p.x;  
         else return (ll)x*p.y < (ll)y*p.x;  
     }  
     ```  
   - **个人心得**：坐标轴上的点直接按区域排序，无需交换顺序。  

2. **作者：System32（★★★★☆）**  
   - **亮点**：通过约分唯一标识方向，减少浮点误差。  
   - **关键代码**：  
     ```cpp  
     int g = __gcd(abs(x), abs(y));  
     x /= g; y /= g;  // 约分坐标  
     ```  

---

## 最优思路或技巧提炼  
1. **象限+叉积排序法**  
   - 将坐标转换为绝对值和区域编号，避免浮点运算。  
   - 同一象限内用叉积比较斜率大小，确保逆时针顺序。  
2. **环形区间处理**  
   计算两个方向的区间长度时，若结果为负数则加 `n`，确保正确性。  

---

## 同类型题与算法套路  
- **环形区间统计**：如 [CF1029D] 统计多个区间覆盖次数。  
- **极角排序应用**：如 [洛谷 P1355] 判断点是否在凸多边形内。  

---

## 推荐相似题目  
1. [洛谷 P1355] 三角形的最大面积（极角排序）  
2. [CF598C] 最近点对（极角处理）  
3. [洛谷 P3473] 射箭（半平面交）  

---

## 个人心得摘录  
> “坐标轴上的点直接按区域排序，无需交换顺序。” —— tuxiaobei  
> 调试中发现，同一象限的叉积比较方向需根据象限奇偶性调整，否则排序会反向。  

---

## 核心代码实现  
```cpp  
// 极角排序预处理  
point change(int x, int y) {  
    point a;  
    a.x = abs(x), a.y = abs(y);  
    if (y == 0) a.c = x>0 ? 0 : 4;  
    else if (x == 0) a.c = y>0 ? 2 : 6;  
    else if (x>0) a.c = y>0 ? 1 : 7;  
    else a.c = y>0 ? 3 : 5;  
    return a;  
}  

// 区间计算  
line getline(point x) {  
    line res;  
    res.s = lower_bound(a+1, a+n+1, x) - a;  
    res.t = upper_bound(a+1, a+n+1, x) - a - 1;  
    res.w = res.t - res.s + 1;  
    return res;  
}  
```  

---

## 复古游戏化动画代码片段  
```javascript  
// 像素风极角扫描（Canvas 2D）  
function drawScanSector(ctx, startAngle, endAngle, color) {  
    ctx.fillStyle = color;  
    ctx.beginPath();  
    ctx.moveTo(centerX, centerY);  
    ctx.arc(centerX, centerY, radius, startAngle, endAngle);  
    ctx.fill(); // 绘制扇形区域  
    playSound('scan'); // 8-bit 扫描音效  
}  

// 自动演示模式  
function autoPlay() {  
    let step = 0;  
    const interval = setInterval(() => {  
        if (step >= m) clearInterval(interval);  
        updateDirection(step++); // 更新箭头与扫描区域  
    }, 1000);  
}  
```

---
处理用时：93.41秒
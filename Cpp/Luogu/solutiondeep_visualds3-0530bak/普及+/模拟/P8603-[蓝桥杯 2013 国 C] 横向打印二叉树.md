# 题目信息

# [蓝桥杯 2013 国 C] 横向打印二叉树

## 题目背景

二叉树可以用于排序。

## 题目描述

其原理很简单：对于一个排序二叉树添加新节点时，先与根节点比较，若小则交给左子树继续处理，否则交给右子树。

当遇到空子树时，则把该节点放入那个位置。

比如，`10 8 5 7 12 4` 的输入顺序，应该建成二叉树如图 $1$ 所示。

本题目要求：根据已知的数字，建立排序二叉树，并在标准输出中横向打印该二叉树。


## 说明/提示

样例解释 1：

![](https://cdn.luogu.com.cn/upload/image_hosting/4z42ybq4.png)

时限 1 秒, 64M。蓝桥杯 2013 年第四届国赛

## 样例 #1

### 输入

```
10 8 5 7 12 4```

### 输出

```
...|-12
10-|
...|-8-|
.......|...|-7
.......|-5-|
...........|-4```

## 样例 #2

### 输入

```
10 5 20```

### 输出

```
...|-20
10-|
...|-5```

## 样例 #3

### 输入

```
5 10 20 8 4 7```

### 输出

```
.......|-20
..|-10-|
..|....|-8-|
..|........|-7
5-|
..|-4```

# AI分析结果



## 唯一算法分类
**二叉树遍历 + 字符串处理**

---

## 综合分析与结论
### 核心思路
题目需构建二叉搜索树并横向打印，核心难点在于**确定每个节点的位置和连接符格式**。所有题解均采用以下关键步骤：
1. **构建二叉搜索树**：递归插入节点，左子树存较小值，右子树存较大值。
2. **横向打印处理**：
   - **右根左递归遍历**（类似逆中序），确定每行对应一个节点。
   - 动态计算前置空格数 `space` 和符号 `|-` `-|`，非根节点和叶子节点需特殊处理。
   - 使用二维字符数组 `mp[][]` 存储每行字符，最后统一输出。
3. **竖线连接**：通过记录每个节点的行号，后续补全父子节点间的 `|` 符号。

### 可视化设计思路
1. **动画方案**：
   - **递归步进**：以不同颜色高亮当前递归节点（如蓝色表示当前处理节点，绿色表示左子树，红色表示右子树）。
   - **字符填充**：逐字符绘制当前节点的 `|-`、数字、`-|`，动态显示空格填充过程。
   - **竖线连接**：在父子节点递归完成后，用黄色高亮补全 `|` 符号的列位置。
2. **复古像素风格**：
   - **颜色方案**：使用 8 位色（如 #1E90FF 表示当前节点，#32CD32 表示左子树，#FF4500 表示右子树）。
   - **Canvas 绘制**：将每行字符渲染为像素网格，字符 `.` 用浅灰色，`|` 用白色，数字用黄色。
3. **音效触发**：
   - **节点处理**：播放短促的“滴”声（Web Audio API）。
   - **递归进入子树**：播放不同音调（左子树低音，右子树高音）。

---

## 题解清单（≥4星）
### 1. Wing_ 的题解（★★★★★）
- **亮点**：  
  - 右根左遍历明确解释，`sum` 参数动态计算前置空格数。
  - 分两步处理：先填充字符，后连接竖线，逻辑清晰。
  - 代码可读性极佳，结构体存储节点行列信息。
- **关键代码**：
  ```cpp
  void print(int u, int sum) {
      // 右子树递归 → 当前节点处理 → 左子树递归
      if (sum) { // 填充前置符号
          for (int i=1; i<=sum-2; i++) c[h][i]='.';
          c[h][sum-1]='|', c[h][sum]='-';
      }
      // 数字填充和竖线连接处理
  }
  ```

### 2. LaDeX 的题解（★★★★☆）
- **亮点**：
  - 中序遍历实现，`Add` 变量精确计算空格增量。
  - 使用全局数组 `line[]` 记录节点行号，简化竖线连接逻辑。
- **调试心得**：  
  > “发现竖线可能被空格覆盖，添加 `if (mp[nowL][++ind] != '|')` 避免此问题”。

### 3. ChampionCyan 的题解（★★★★☆）
- **亮点**：
  - 循环插入节点替代递归，提升代码效率。
  - `eof` 标记行结束，避免越界访问。
- **代码技巧**：
  ```cpp
  inline void insert(int x, int p) {
      while (node[p] != -1) { // 非递归插入
          if (x < node[p]) p = lc(p);
          else p = rc(p);
      }
      node[p] = x;
  }
  ```

---

## 最优思路提炼
### 关键技巧
1. **递归顺序**：右根左遍历确保每行从上到下按右子树→当前节点→左子树排列。
2. **空格计算**：`space + Add` 动态维护，`Add = 数字位数 + 3`（`|-` 和 `-|` 占 3 字符）。
3. **竖线连接**：通过记录节点的行号，逆序补全父子节点间的 `|` 符号列。

### 代码实现
```cpp
// Wing_ 题解核心代码（竖线连接）
void work(int u) {
    if (tr[u].r) {
        int rh = tr[tr[u].r].h, rz = tr[tr[u].r].z;
        for (int i=rh; i<=tr[u].h; i++) c[i][rz-2] = '|';
    }
    if (tr[u].l) {
        int lh = tr[tr[u].l].h, lz = tr[tr[u].l].z;
        for (int i=tr[u].h; i<=lh; i++) c[i][lz-2] = '|';
    }
}
```

---

## 相似题目推荐
1. **P1305 新二叉树**：按特定格式输出二叉树结构。
2. **P1030 求先序排列**：二叉树遍历与字符串处理结合。
3. **P1040 加分二叉树**：二叉树结构处理与动态规划结合。

---

## 可视化实现（伪代码）
```javascript
// Canvas 初始化与动画循环
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let step = 0;

function drawTree(node, x, y, depth) {
    if (!node) return;
    // 绘制当前节点（像素风格）
    ctx.fillStyle = '#1E90FF';
    ctx.fillRect(x, y, 20, 20); // 蓝色方块表示节点
    // 递归绘制右子树（上方）和左子树（下方）
    drawTree(node.right, x + 30, y - 30, depth + 1);
    drawTree(node.left, x + 30, y + 30, depth + 1);
}

// 音效触发
function playBeep(freq) {
    const oscillator = audioCtx.createOscillator();
    oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.1);
}
```

---

## 个人心得摘录
- **Wing_ 的调试经验**：  
  > “发现直接打印字符数组会缺少竖线，必须分两步处理：先填充节点，后连接竖线”。
- **LaDeX 的优化思路**：  
  > “线段树式数组存储节点，简化父子关系计算”。

---
处理用时：89.09秒
# 题目信息

# [CSP-J 2022] 逻辑表达式

## 题目描述

逻辑表达式是计算机科学中的重要概念和工具，包含逻辑值、逻辑运算、逻辑运算优先级等内容。

在一个逻辑表达式中，元素的值只有两种可能：$0$（表示假）和 $1$（表示真）。元素之间有多种可能的逻辑运算，本题中只需考虑如下两种：“与”（符号为 `&`）和“或”（符号为 `|`）。其运算规则如下：

$0 \mathbin{\&} 0 = 0 \mathbin{\&} 1 = 1 \mathbin{\&} 0 = 0$，$1 \mathbin{\&} 1 = 1$；  
$0 \mathbin{|} 0 = 0$，$0 \mathbin{|} 1 = 1 \mathbin{|} 0 = 1 \mathbin{|} 1 = 1$。

在一个逻辑表达式中还可能有括号。规定在运算时，括号内的部分先运算；两种运算并列时，`&` 运算优先于 `|` 运算；同种运算并列时，从左向右运算。

比如，表达式 `0|1&0` 的运算顺序等同于 `0|(1&0)`；表达式 `0&1&0|1` 的运算顺序等同于 `((0&1)&0)|1`。

此外，在 C++ 等语言的有些编译器中，对逻辑表达式的计算会采用一种“短路”的策略：在形如 `a&b` 的逻辑表达式中，会先计算 `a` 部分的值，如果 $a = 0$，那么整个逻辑表达式的值就一定为 $0$，故无需再计算 `b` 部分的值；同理，在形如 `a|b` 的逻辑表达式中，会先计算 `a` 部分的值，如果 $a = 1$，那么整个逻辑表达式的值就一定为 $1$，无需再计算 `b` 部分的值。

现在给你一个逻辑表达式，你需要计算出它的值，并且统计出在计算过程中，两种类型的“短路”各出现了多少次。需要注意的是，如果某处“短路”包含在更外层被“短路”的部分内则不被统计，如表达式 `1|(0&1)` 中，尽管 `0&1` 是一处“短路”，但由于外层的 `1|(0&1)` 本身就是一处“短路”，无需再计算 `0&1` 部分的值，因此不应当把这里的 `0&1` 计入一处“短路”。

## 说明/提示

**【样例解释 \#1】**

该逻辑表达式的计算过程如下，每一行的注释表示上一行计算的过程：

```plain
0&(1|0)|(1|1|1&0)
=(0&(1|0))|((1|1)|(1&0)) //用括号标明计算顺序
=0|((1|1)|(1&0))   //先计算最左侧的 &，是一次形如 a&b 的“短路”
=0|(1|(1&0))       //再计算中间的 |，是一次形如 a|b 的“短路”
=0|1               //再计算中间的 |，是一次形如 a|b 的“短路”
=1
```

**【样例 \#3】**

见附件中的 `expr/expr3.in` 与 `expr/expr3.ans`。

**【样例 \#4】**

见附件中的 `expr/expr4.in` 与 `expr/expr4.ans`。

**【数据范围】**

设 $\lvert s \rvert$ 为字符串 $s$ 的长度。

对于所有数据，$1 \le \lvert s \rvert \le {10}^6$。保证 $s$ 中仅含有字符 `0`、`1`、`&`、`|`、`(`、`)` 且是一个符合规范的逻辑表达式。保证输入字符串的开头、中间和结尾均无额外的空格。保证 $s$
中没有重复的括号嵌套（即没有形如 `((a))` 形式的子串，其中 `a` 是符合规范的逻辑表
达式）。

| 测试点编号 | $\lvert s \rvert \le$ | 特殊条件 |
|:-:|:-:|:-:|
| $1 \sim 2$ | $3$ | 无 |
| $3 \sim 4$ | $5$ | 无 |
| $5$ | $2000$ | 1 |
| $6$ | $2000$ | 2 |
| $7$ | $2000$ | 3 |
| $8 \sim 10$ | $2000$ | 无 |
| $11 \sim 12$ | ${10}^6$ | 1 |
| $13 \sim 14$ | ${10}^6$ | 2 |
| $15 \sim 17$ | ${10}^6$ | 3 |
| $18 \sim 20$ | ${10}^6$ | 无 |

其中：  
特殊性质 1 为：保证 $s$ 中没有字符 `&`。  
特殊性质 2 为：保证 $s$ 中没有字符 `|`。  
特殊性质 3 为：保证 $s$ 中没有字符 `(` 和 `)`。

**【提示】**

以下给出一个“符合规范的逻辑表达式”的形式化定义：

- 字符串 `0` 和 `1` 是符合规范的；
- 如果字符串 `s` 是符合规范的，且 `s` 不是形如 `(t)` 的字符串（其中 `t` 是符合规范的），那么字符串 `(s)` 也是符合规范的；
- 如果字符串 `a` 和 `b` 均是符合规范的，那么字符串 `a&b`、`a|b` 均是符合规范的；
- 所有符合规范的逻辑表达式均可由以上方法生成。

## 样例 #1

### 输入

```
0&(1|0)|(1|1|1&0)
```

### 输出

```
1
1 2
```

## 样例 #2

### 输入

```
(0|1&0|1|1|(1|1))&(0&1&(1|0)|0|1|0)&0
```

### 输出

```
0
2 3
```

# AI分析结果



### **唯一算法分类**  
表达式求值

---

### **题解思路与解决难点**  
**核心思路**：处理逻辑表达式时需考虑运算符优先级、括号嵌套与短路特性。主流解法包括分治递归、线性扫描短路、中缀转后缀建表达式树等。

**关键难点**：  
1. **优先级处理**：`&` 优先级高于 `|`，需确保正确运算顺序。  
2. **括号嵌套**：需递归处理括号内表达式。  
3. **短路统计**：外层短路需屏蔽内层操作，避免重复计数。  

**解决策略对比**：  
- **分治递归（SkyWave）**：  
  递归寻找当前区间最低优先级运算符，分割左右子问题。通过预处理运算符位置优化至线性复杂度。  
- **线性扫描（OI_AKed_me）**：  
  直接遍历表达式，维护 `off` 状态跳过短路部分，避免复杂递归。  
- **表达式树（Wi_Fi）**：  
  中缀转后缀构建树形结构，后序遍历计算值及短路次数，逻辑清晰但实现复杂。  

---

### **题解评分 (≥4星)**  
1. **SkyWave（5星）**  
   - 分治递归思路清晰，预处理优化到 O(n) 时间复杂度。  
   - 代码简洁高效，通过优先级分割避免复杂数据结构。  
   - 关键代码：预处理运算符位置，递归分割表达式区间。  

2. **OI_AKed_me（4星）**  
   - 线性扫描实现极简，直接统计短路次数。  
   - 适合竞赛快速编码，但对复杂括号嵌套处理稍隐晦。  
   - 关键代码：通过 `off` 状态跳过短路部分。  

3. **Wi_Fi（4星）**  
   - 传统中缀转后缀+表达式树，步骤明确易理解。  
   - 代码完整但较长，适合学习表达式树结构。  
   - 关键代码：构建表达式树后 DFS 遍历统计短路。  

---

### **最优思路提炼**  
1. **分治递归 + 预处理优化**  
   - 预处理记录每个位置同层最后一个 `|` 和 `&` 的位置，递归时直接分割。  
   - 判断短路条件：左子树为 `0`（`&`）或 `1`（`|`）时终止右子树计算。  
2. **短路统计隔离**  
   - 外层短路优先处理，内层短路被外层屏蔽不计入统计。  

```cpp
// SkyWave 预处理关键代码
for (int i = 1; i <= len; ++i) {
    if (str[i] == '(') x++;
    else if (str[i] == ')') x--;
    else if (str[i] == '|') l1[x] = i;
    else if (str[i] == '&') l2[x] = i;
    c1[i] = l1[x]; // 记录同层最后一个 |
    c2[i] = l2[x]; // 记录同层最后一个 &
}
```

---

### **同类型题与算法套路**  
- **通用表达式求值**：处理优先级、括号、多级运算（如加减乘除）。  
- **短路特性扩展**：适用于需提前终止计算的场景（如条件判断语句优化）。  

**推荐题目**：  
1. [P1175 表达式的转换](https://www.luogu.com.cn/problem/P1175)  
2. [LeetCode 224. 基本计算器](https://leetcode.cn/problems/basic-calculator/)  
3. [P5658 中缀表达式转后缀表达式](https://www.luogu.com.cn/problem/P5658)  

---

### **可视化与算法演示**  
**动画设计**：  
1. **分治递归过程**：  
   - 使用像素风格网格展示表达式字符串，高亮当前处理区间。  
   - 递归分割时显示 `|` 或 `&` 位置，左右区间用不同颜色区分。  
   - 短路触发时播放“咔嚓”音效，右侧区间变灰表示跳过。  
2. **预处理辅助线**：  
   - 在表达式上方绘制横线，标记 `c1[]` 和 `c2[]` 记录的运算符位置。  
3. **统计面板**：  
   - 右侧实时显示 `sum1`（`|` 短路）和 `sum2`（`&` 短路）计数。  

**复古游戏化实现**：  
- **8位音效**：递归时播放电子合成音，短路时触发“哔”声。  
- **Canvas 绘制**：  
  - 表达式字符以 16x16 像素块渲染，括号用绿色边框标记。  
  - 当前运算符闪烁，递归深度通过Y轴位置可视化。  

---

### **代码实现（分治优化版）**  
```cpp
#include <cstdio>
#include <cstring>
const int N = 1e6 + 5;
char s[N];
int c1[N], c2[N], l1[N], l2[N], cnt_or, cnt_and;

int dfs(int l, int r) {
    if (c1[r] >= l) { // 处理同层最后一个 |
        int left = dfs(l, c1[r] - 1);
        if (left == 1) {
            cnt_or++;
            return 1;
        }
        return left | dfs(c1[r] + 1, r);
    }
    if (c2[r] >= l) { // 处理同层最后一个 &
        int left = dfs(l, c2[r] - 1);
        if (left == 0) {
            cnt_and++;
            return 0;
        }
        return left & dfs(c2[r] + 1, r);
    }
    if (s[l] == '(') return dfs(l + 1, r - 1); // 去掉括号
    return s[l] - '0'; // 直接返回数字
}

int main() {
    scanf("%s", s + 1);
    int n = strlen(s + 1), depth = 0;
    for (int i = 1; i <= n; ++i) {
        if (s[i] == '(') depth++;
        else if (s[i] == ')') depth--;
        else if (s[i] == '|') l1[depth] = i;
        else if (s[i] == '&') l2[depth] = i;
        c1[i] = l1[depth]; // 同层最后一个 |
        c2[i] = l2[depth]; // 同层最后一个 &
    }
    int ans = dfs(1, n);
    printf("%d\n%d %d\n", ans, cnt_and, cnt_or);
    return 0;
}
```

---
处理用时：81.08秒
# 题目信息

# 「GMOI R1-T4」Rain

## 题目背景

> **求雨**
>
>玉皇爷爷也姓张，
>
>为啥为难俺张*昌？
>
>三天之内不下雨，
>
>先扒龙皇庙，
>
>__再用大炮轰你娘。__

如果再不下雨，张大帅就会轰掉全亚洲所有的宗教场所！

博丽神社因为可以在外界被看到，自然也无法幸免于难，灵梦十分着急，准备使用祖传秘法求雨……

## 题目描述

为了防止神社被“大炮开兮轰他娘”，灵梦需要求雨。

求雨需要在一条笔直的路上建 $n$ 个法阵，编号为 $1,2,\cdots,n$。

给定一个长度为 $n$ 的数组 $a$，表示在 $a_1$ 到 $a_n$ 的位置建法阵，你要干的是给法阵编号。

灵梦需要来检测法阵效果，她会从 $1$ 号法阵走到 $2$ 号，从 $2$ 号再走到 $3$ 号，直到走到 $n$ 号，再从 $n$ 号走回 $1$ 号。

由于法阵的特殊效果，从 $i$ 个走到 $i+1$ 个的距离是 $\left|a_i\times p-a_{i+1}\times q\right|$。特别的，从 $n$ 号走回到 $1$ 号的距离是 $\left|a_n\times p-a_1\times q\right|$。$p,q$ 是给定的两个常数，$a_i,a_{i+1}$ 是两个法阵的位置。

灵梦希望你来求一下最大的行走距离，并输出对应法阵从 $1$ 号到 $n$ 号的位置排列。（多个只需输出一个即可）

## 说明/提示

**本题开启 SPJ。**

**本题读入量较大，建议使用较快的读入方式。**

对于 $100\%$ 的数据满足 $10\le n\le 10^6$，$1\le p,q \le 10^{5}$，$1\le a_i\le 10^{5}$。

| 编号 | $n$ | $p,q$ | $a_i$ | 分数 |
| :----------: | :----------: | :----------: | :----------:  | :----------: |
| $1$ | $n=10$ | $p,q\le 10^{3}$ | $a_i\le 10^{3}$ | $4$ |
| $2$ | $n=10$ | $p,q\le 10^{3}$ | $a_i\le 10^{3}$ | $5$ |
| $3$ | $n=10$ | $p,q\le 10^{3}$ | $a_i\le 10^{3}$ | $5$ |
| $4\sim 6$  | $n=19$ | $p,q\le 10^{5}$ | $a_i\le 10^{5}$ | $10$ |
| $7$ | $n\le 10^{4}$ | $p,q\le 10^{5}$ | $a_i\le 10^{5}$ | $8$ |
| $8$ | $n\le 10^{4}$ | $p,q\le 10^{5}$ | $a_i\le 10^{5}$ | $9$ |
| $9$ | $n\le 10^{4}$ | $p,q\le 10^{5}$ | $a_i\le 10^{5}$ | $9$ |
| $10\sim 12$ | $n\le 10^{6}$ | $p,q\le 10^{5}$ | $a_i\le 10^{5}$ | $10$ |


## 样例 #1

### 输入

```
10
2 3
1 2 3 4 5 6 7 8 9 10```

### 输出

```
131
5 6 7 1 8 2 9 3 10 4```

# AI分析结果



---

## 算法分类
贪心算法 / 构造型问题

---

## 题解分析与结论

### 核心思路
所有题解均围绕「排序后交替排列」这一核心思想：
1. **拆解绝对值贡献**：将总贡献拆为 2n 项的符号分配问题（n 正 n 负）
2. **排序优化贡献**：通过排序将大的元素优先用于正贡献，小的用于负贡献
3. **交替排列构造**：通过交替排列大元素和小元素，使相邻项的绝对值差最大化

### 解决难点
- **环形结构的处理**：通过将排序后的数组分为两段，交替拼接形成环形排列
- **p与q的关系处理**：当 p < q 时，采用大小交替；当 p > q 时，采用小大交替
- **高复杂度下的构造**：O(n log n) 排序后直接构造排列，避免复杂计算

### 可视化设计思路
1. **排序与分组动画**：
   - 显示数组排序后分为前半段（小元素）和后半段（大元素）
   - 用不同颜色区分两组元素（如红色代表大元素，蓝色代表小元素）
2. **交替排列过程**：
   - 动态展示从后半段取一个元素，再从前半段取一个元素交替拼接
   - 高亮当前操作元素并显示其贡献值
3. **像素化风格演示**：
   - 使用 8-bit 像素方块表示元素，高度对应数值大小
   - 背景音乐随排列步骤播放短促音效，完成时播放胜利音效

---

## 高分题解推荐 (≥4星)

1. **Tx_Lcy（5星）**
   - **亮点**：代码简洁高效，通过前缀后缀分段计算贡献，处理 p/q 关系清晰
   - **代码片段**：
     ```cpp
     for (int i=1;i<=k;++i) Ans[2*i-1]=a[i].x,Ans[2*i]=a[n-k+i].x;
     if (p>=q);else reverse(Ans+1,Ans+n+1);
     ```

2. **Daidly（4.5星）**
   - **亮点**：严格证明符号分配可行性，通过集合交替实现理论最优
   - **关键代码**：
     ```cpp
     for(int i=1;i<=cnt1;++i){
         if(p<=q)ans[++m]=p2[i],ans[++m]=p1[i];
         else ans[++m]=p1[i],ans[++m]=p2[i];
     }
     ```

3. **_shy（4星）**
   - **亮点**：通过数学推导证明排列有效性，代码实现极简
   - **构造逻辑**：
     ```cpp
     for (int i=1, j=n; i<=j; i++,j--) 
         b[++cnt] = a[i], b[++cnt] = a[j];
     ```

---

## 最优技巧提炼

### 核心技巧
1. **符号分配策略**：将前 n 大的 pa_i 和 qa_i 分配正号，其余分配负号
2. **双指针交替构造**：
   ```python
   # 伪代码示例
   sorted_a = sort(a)
   l, r = 0, n-1
   while l <= r:
       ans.append(sorted_a[r])
       if l != r: 
           ans.append(sorted_a[l])
       l += 1; r -= 1
   ```

### 思维突破点
- **环形问题线性化**：通过固定排列起点（如最大元素），将环形构造转化为线性问题
- **贡献分离思想**：将每个元素的 p 倍和 q 倍贡献独立分析，再组合求最优

---

## 同类题目推荐
1. [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)（贪心排序策略）
2. [P1005 矩阵取数游戏](https://www.luogu.com.cn/problem/P1005)（动态规划+贪心决策）
3. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)（排序+双指针应用）

---

## 个人心得摘录
> "比赛时被输出坑到，输出的方案是具体的数值而非原数组位置，排序时需要保留原索引" —— Tx_Lcy  
> "乱猜结论害人不浅，必须严格证明符号分配可行性" —— irris

---

## 可视化代码片段（JS+Canvas）
```javascript
// 排序与交替排列动画
function visualize() {
    let sorted = [...a].sort((x,y) => x-y);
    let [l, r] = [0, n-1];
    ctx.clearRect(0, 0, W, H);
    
    // 绘制排序过程
    sorted.forEach((v, i) => drawBar(i, v, 'gray'));
    
    // 交替取大取小
    const animate = () => {
        if (l > r) return;
        drawBar(r, sorted[r], 'red'); // 高亮大元素
        await sleep(500);
        drawBar(l, sorted[l], 'blue');// 高亮小元素
        await sleep(500);
        l++; r--;
        requestAnimationFrame(animate);
    };
    animate();
}
```

---

## 复古像素风格设计
1. **颜色方案**：8-bit 调色板（红：#FF0000，蓝：#0000FF，灰：#808080）
2. **音效设计**：
   - 元素移动时播放 `beep(440, 50)`
   - 完成构造时播放 `beep(880, 200)`
3. **自动演示模式**：
   ```javascript
   function autoDemo() {
       let step = 0;
       const interval = setInterval(() => {
           if (step >= n) clearInterval(interval);
           visualizeStep(step++);
       }, 1000);
   }
   ```

---
处理用时：91.00秒
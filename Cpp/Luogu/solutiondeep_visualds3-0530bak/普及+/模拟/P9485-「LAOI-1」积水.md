# 题目信息

# 「LAOI-1」积水

## 题目描述



地表坑洼不平，每当暴雨来临地面上都会有一个个水洼。   
又有一场暴雨即将来临，你决定改造地面来减少积水。     
地面可抽象为一个长度为 $n$ 的正整数序列 $a$，其中 $a_i$ 表示当地的海拔高度。       
下暴雨时将会汇聚在低洼处无法向两侧流走，比如一个序列 $a=[3,1,5,1,2,3]$。     
在下雨后的积水如图所示（有 $5$ 格积水）：

![](https://cdn.luogu.com.cn/upload/image_hosting/79on2oe3.png)

由于人手不足，现在只来得及改变一个地方的海拔高度为任意正整数。

问改造后积水最少有几格。






## 说明/提示

对于前 $5\%$ 的数据，$1\le n\le 5$。       
对于前 $20\%$ 的数据，$1\le \sum  n\le 550$，$1\le a_i\le 500$。     
对于前 $35\%$ 的数据，$1\le \sum n\le 5050$，$1\le a_i\le 5000$。    
对于前 $50\%$ 的数据，$1\le \sum n\le 5050$，$1\le a_i \le 10^9$。  
对于 $100\%$ 的数据，$1\le n,\sum n\le 10^6$，$1\le a_i\le 10^9$。

保证 $1\le T\le 10^4$。

## 样例 #1

### 输入

```
3
6
3 2 1 1 2 3
6
1 1 4 5 1 4
6
1 9 1 9 8 10```

### 输出

```
2
0
1```

# AI分析结果



---

### **算法分类**  
动态规划/预处理左右极值  

---

### **题解思路与核心难点**  

#### **核心思路**  
1. **预处理左右极值**：计算每个点左侧和右侧的最大高度（前缀/后缀最大值），确定每个点的潜在积水高度。  
2. **初始总积水计算**：根据左右极值计算每个点的积水贡献，累加得到总积水量。  
3. **修改策略**：  
   - **填平**：将某个点抬高到其积水高度，直接消除该点的贡献。  
   - **泄洪**：降低某个峰的高度，使得水流向两侧，重新计算受影响区域的积水。  

#### **解决难点**  
1. **高效处理左右极值**：通过动态规划或单调栈预处理，避免每次查询的重复计算。  
2. **泄洪的复杂影响**：降低峰高需确保不形成新的积水，需结合区间最大值查询（如 ST 表）或动态更新极值。  

---

### **题解评分（≥4星）**  

1. **EdenSky（★★★★☆）**  
   - **亮点**：全面覆盖填平与泄洪策略，利用 ST 表高效处理区间最大值。  
   - **代码优化**：通过预处理左右峰位置减少计算量。  
   - **个人心得**：避免 `memset` 导致 TLE，强调离线处理的重要性。  

2. **CZ_7（★★★★★）**  
   - **亮点**：双指针法线性遍历处理泄洪，无需复杂数据结构，代码简洁高效。  
   - **关键技巧**：维护 `low` 变量动态更新水流终止条件，确保线性复杂度。  
   - **可视化友好**：分左右两次遍历，逻辑直观易动画演示。  

3. **Interstice（★★★★☆）**  
   - **亮点**：结合单调栈动态计算积水贡献，记录每个点的左右影响区域。  
   - **优化思路**：暴力重新计算受影响区域，适合小规模数据。  

---

### **最优思路与技巧提炼**  

#### **关键步骤**  
1. **预处理极值**：  
   ```cpp  
   // 计算前缀最大值  
   for (int i = 1; i <= n; i++) maxl[i] = max(maxl[i-1], a[i]);  
   // 计算后缀最大值  
   for (int i = n; i >= 1; i--) maxr[i] = max(maxr[i+1], a[i]);  
   ```  
2. **填平策略**：  
   ```cpp  
   ans = min(ans, sum - w[i]);  // 直接减去当前点积水贡献  
   ```  
3. **泄洪策略**：  
   - **降低左峰**：遍历左侧峰，动态更新终止条件 `low`：  
     ```cpp  
     ll low = maxl[l-1], cnt = 0;  
     while (a[r] < a[l]) {  
         cnt += max(0, min(maxl[r-1], maxr[r+1]) - max(low, a[r]));  
         low = max(low, a[r++]);  
     }  
     ```  

#### **优化技巧**  
- **双指针法**：通过单次遍历处理左右峰的影响，避免重复计算。  
- **极值复用**：通过动态维护 `low` 或 `high` 减少区间查询次数。  

---

### **同类题目推荐**  
1. **P1318 积水面积**（基础版，无修改操作）  
2. **P3865 ST 表**（区间最大值查询模板）  
3. **LeetCode 42. Trapping Rain Water**（接雨水问题，经典变种）  

---

### **可视化与算法演示**  

#### **核心逻辑动画设计**  
1. **地面与积水绘制**：  
   - 使用像素网格表示地面高度，蓝色块表示积水。  
   - 高亮左右峰位置（红色）和当前操作点（黄色）。  
2. **填平操作演示**：  
   - 点击某点后，其高度抬升至积水线，蓝色块消失。  
3. **泄洪操作演示**：  
   - 降低某个峰的高度，水流向两侧，重新计算并更新积水区域。  

#### **复古像素风格实现**  
- **Canvas 绘制**：  
  ```javascript  
  function drawGround(ctx, a, maxH) {  
      const COLOR = ['#8B4513', '#0000FF', '#FF0000']; // 地面、积水、峰  
      for (let i = 0; i < a.length; i++) {  
          const h = (a[i] / maxH) * canvas.height;  
          ctx.fillStyle = COLOR[0];  
          ctx.fillRect(i * 10, canvas.height - h, 10, h);  
          if (isPeak(i)) ctx.fillStyle = COLOR[2]; // 标记峰  
      }  
  }  
  ```  
- **音效触发**：  
  - 成功减少积水时播放 `FX_coin` 音效，失败时播放 `FX_hit`。  

---

### **个人心得摘录**  
- **EdenSky**：  
  > 如果只 T 了 Subtask#1，检查 `memset` 是否导致超时。离线处理比在线查询更高效。  
- **CZ_7**：  
  > 泄洪时维护 `low` 是关键，确保水流终止条件正确，避免反复计算区间极值。  

---

### **代码片段（CZ_7 核心泄洪逻辑）**  
```cpp  
void solve() {  
    // 计算前缀和后缀最大值  
    // ...  

    // 处理左峰泄洪  
    int l = 1, r = 2;  
    while (r <= n) {  
        ll low = maxl[l-1], cnt = 0;  
        while (a[r] < a[l]) {  
            ll w = min(maxl[r-1], maxr[r+1]);  
            if (w > max(low, a[r])) cnt += w - max(low, a[r]);  
            low = max(low, a[r++]);  
        }  
        cut = max(cut, cnt);  
        l = r; r++;  
    }  
    // 同理处理右峰  
}  
```  

---

通过以上分析，结合预处理与双指针法，可在 O(n) 时间内高效解决问题，适用于大规模数据。

---
处理用时：106.01秒
# 题目信息

# [NOIP 2007 普及组] 守望者的逃离

## 题目背景

NOIP2007 普及组 T3

## 题目描述

恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。

守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。

为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。

守望者的跑步速度为 $17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1s$ 内移动 $60m$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。

现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间 $T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。

注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。


## 说明/提示

对于 $30\%$ 的数据，$1  \le  T   \le  10$，$ 1   \le   S   \le  100$；

对于 $50\%$ 的数据，$1   \le  T   \le   10^3$，$ 1   \le  S  \le   10^4$；

对于 $100\%$ 的数据，$1   \le   T   \le   3\times  10^5$，$0   \le   M   \le   10^3$，$ 1   \le  S   \le   10^8$。


## 样例 #1

### 输入

```
39 200 4
```

### 输出

```
No
197
```

## 样例 #2

### 输入

```
36 255 10```

### 输出

```
Yes
6```

# AI分析结果



---

## 唯一算法分类  
**其他搜索**

---

## 综合分析与结论  

### 核心思路与难点  
本题核心在于合理分配魔法恢复与使用，通过贪心或动态规划实现时间与距离的最优解。难点在于：  
1. 魔法恢复与使用的时机权衡：魔法闪烁速度更快但需要恢复时间，需判断何时恢复魔法比直接跑步更优。  
2. 状态维护的优化：部分题解通过双变量（闪烁距离 vs. 跑步距离）或动态规划数组维护最优解，确保每一步选择全局最优。  

### 搜索过程与可视化设计  
- **动态规划/贪心可视化**：每秒更新两种策略的进度（闪烁距离、跑步距离），用柱状图动态对比。  
- **复古像素动画**：  
  - 用不同颜色方块表示每秒状态（蓝色=休息恢复魔法，黄色=闪烁，红色=跑步）。  
  - 成功时播放上扬音效，失败时低沉音效，背景循环8-bit音乐。  
  - 自动演示模式下，算法自动推进时间并高亮当前最优策略。  

---

## 题解清单（≥4星）  

1. **wzr1125（5星）**  
   - **亮点**：双变量维护闪烁与跑步距离，代码简洁高效，时间复杂度 O(T)。  
   - **核心代码**：  
     ```cpp  
     for(int i=1;i<=t;i++){  
         if(m>=10) m-=10,fla+=60;  
         else m+=4;  
         run = max(run+17, fla); // 关键：取两种策略最大值  
         if(max(fla,run)>=s) {...}  
     }  
     ```  

2. **jingwenhan（4星）**  
   - **亮点**：两阶段DP，先处理纯闪烁再处理跑步，逻辑清晰。  
   - **核心代码**：  
     ```cpp  
     for(int i=1;i<=t;i++){  
         if(m>=10) dp[i]=dp[i-1]+60, m-=10;  
         else dp[i]=dp[i-1], m+=4;  
     }  
     for(int i=1;i<=t;i++){  
         dp[i] = max(dp[i], dp[i-1]+17); // 动态更新跑步  
     }  
     ```  

3. **qhr2023（4星）**  
   - **亮点**：极简代码实现双策略贪心，逻辑高度凝练。  
   - **核心代码**：  
     ```cpp  
     for(int i=1; i<=t; i++){  
         m>=10 ? (m-=10,s2+=60) : (m+=4);  
         s1 = max(s1+17, s2);  
         if(s1>=s) {...}  
     }  
     ```  

---

## 最优思路提炼  
**双策略贪心法**：  
- 维护两个变量分别表示纯闪烁距离和跑步距离。  
- 每秒优先使用魔法闪烁，若不能则恢复魔法。  
- 更新跑步距离时取「上一秒跑步+17」和「当前闪烁距离」的最大值。  
- **优势**：O(T) 时间复杂度，无需复杂条件分支，代码简洁高效。  

---

## 同类型题与算法套路  
1. **跳跃游戏类问题**（如 LeetCode 45）：每一步选择最优跳跃步数。  
2. **资源分配问题**：在有限资源（时间、能量）下最大化收益，常用贪心或动态规划。  

---

## 推荐题目  
1. [P1099 树网的核](https://www.luogu.com.cn/problem/P1099)  
2. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)  
3. [P1434 滑雪](https://www.luogu.com.cn/problem/P1434)  

---

## 个人心得摘录  
- **wpy233**：调试中发现某些贪心策略在特定距离/时间下不成立，需细致分情况处理。  
- **Asurudo**：初始贪心策略在样例中失败，意识到需结合剩余时间与距离动态调整策略。  

---

## 可视化与算法演示  
```javascript  
// 示例：Canvas 绘制动态进度条（伪代码）  
function drawFrame(time) {  
    // 绘制闪烁距离（黄色）和跑步距离（红色）  
    ctx.fillStyle = '#FFD700';  
    ctx.fillRect(0, 0, flaDistance, 20);  
    ctx.fillStyle = '#FF0000';  
    ctx.fillRect(0, 30, runDistance, 20);  
    // 播放音效  
    if (flaDistance >= s || runDistance >= s) playSuccessSound();  
}  
// 8-bit 音效触发  
function playSuccessSound() {  
    const osc = new OscillatorNode(ctx, {type: 'square'});  
    osc.frequency.setValueAtTime(880, ctx.currentTime); // 高频率音  
}  
```  

**交互设计**：  
- 空格键暂停/继续，左右键调整速度。  
- 成功时屏幕闪烁绿色，失败时红色，配合复古音效。

---
处理用时：85.76秒
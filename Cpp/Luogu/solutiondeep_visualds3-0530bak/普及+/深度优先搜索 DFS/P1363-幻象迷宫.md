# 题目信息

# 幻象迷宫

## 题目背景

（喵星人 LHX 和 WD 同心协力击退了汪星人的入侵，不幸的是，汪星人撤退之前给它们制造了一片幻象迷宫。）

WD：呜呜，肿么办啊……

LHX：momo...我们一定能走出去的！

WD：嗯，+U+U！

## 题目描述

幻象迷宫可以认为是无限大的，不过它由若干个 $N\times M$ 的矩阵重复组成。矩阵中有的地方是道路，用 $\verb!.!$ 表示；有的地方是墙，用 $\verb!#!$ 表示。LHX 和 WD 所在的位置用 $\verb!S!$ 表示。也就是对于迷宫中的一个点$(x,y)$，如果 $(x \bmod n,y \bmod m)$ 是 $\verb!.!$ 或者 $\verb!S!$，那么这个地方是道路；如果 $(x \bmod n,y \bmod m)$ 是$\verb!#!$，那么这个地方是墙。LHX 和 WD 可以向上下左右四个方向移动，当然不能移动到墙上。

请你告诉 LHX 和 WD，它们能否走出幻象迷宫（如果它们能走到距离起点无限远处，就认为能走出去）。如果不能的话，LHX 就只好启动城堡的毁灭程序了……当然不到万不得已，他不想这么做。

## 说明/提示

- 对于 $30\%$ 的数据，$1\le N,M\le 20$；
- 对于 $50\%$ 的数据，$1\le N,M\le 100$；
- 对于 $100\%$ 的数据，$1\le N,M\le 1500$，每个测试点不超过 $10$ 组数据。

## 样例 #1

### 输入

```
5 4
##.#
##S#
#..#
#.##
#..#
5 4
##.#
##S#
#..#
..#.
#.##
```

### 输出

```
Yes
No

```

# AI分析结果



# 幻象迷宫题解分析

## 算法分类：DFS/BFS

---

## 核心思路与难点分析

### 核心思想
**无限迷宫的循环检测**：由于迷宫无限重复，当且仅当存在两个不同实际坐标访问同一模空间位置时，可判定存在无限路径。例如：实际坐标 (x1, y1) 和 (x2, y2) 满足 `x1 ≡ x2 (mod N)`、`y1 ≡ y2 (mod M)` 但 x1≠x2 或 y1≠y2。

### 实现难点
1. **坐标映射**：需将无限坐标映射到原始迷宫尺寸的模空间，同时记录实际坐标。
2. **循环检测**：需高效判断同一模位置是否被不同实际坐标访问过。
3. **剪枝优化**：传统迷宫只需标记位置是否访问，此处需记录访问时的实际坐标。

---

## 最优题解对比 (≥4星)

| 题解作者 | 评分 | 核心亮点 |
|---------|------|----------|
| DEVILK  | ★★★★★ | 首创坐标分离法：`(lx, ly)`记录实际坐标，`(x, y)`存储模坐标，三维数组 `vis[x][y][lx/ly]` 实现 O(1) 循环检测 |
| GNAQ    | ★★★★☆ | 使用三维数组 `vis[pos_x][pos_y][origin_x/origin_y]`，明确坐标对比逻辑 |
| ygsldr  | ★★★★ | 扩展迷宫到2倍尺寸，通过边界传送判断是否进入新副本 |

---

## 关键代码实现

### DEVILK 的坐标分离法
```cpp
void dfs(int x, int y, int lx, int ly) {
    if(vis[x][y][0] && (vis[x][y][1]!=lx || vis[x][y][2]!=ly)) {
        fl = 1; // 检测到不同实际坐标访问同一模位置
        return;
    }
    vis[x][y][0] = 1;
    vis[x][y][1] = lx;
    vis[x][y][2] = ly;
    
    for(int i=0; i<4; ++i) {
        int xx = (x + dx[i] + n) % n;
        int yy = (y + dy[i] + m) % m;
        int lxx = lx + dx[i], lyy = ly + dy[i];
        if(!a[xx][yy]) dfs(xx, yy, lxx, lyy);
    }
}
```

---

## 可视化方案设计

### 8位像素风格演示
1. **网格绘制**：Canvas绘制N×M网格，每个格子显示原始迷宫内容。
2. **坐标映射**：实际坐标转换为模坐标后高亮显示，用不同颜色区分首次访问/重复访问。
3. **循环检测动画**：当检测到不同实际坐标访问同一模位置时，触发红色闪烁特效+8bit警报音效。
4. **AI自动演示**：自动执行DFS/BFS，每步间隔可调（100ms-2s），展示队列/栈变化过程。

### 交互功能
- **速度调节**：滑动条控制搜索速度
- **模式切换**：BFS/DFS对比演示
- **音效开关**：启用/禁用循环检测音效

---

## 同类型题目推荐
1. **P1032 字串变换** - BFS扩展状态空间
2. **P1126 机器人搬重物** - 带状态的BFS路径搜索
3. **P1443 马的遍历** - BFS最短路径模板

---

## 调试心得摘录
> "坐标取模需处理负数，如 `(x % n + n) % n` 确保非负。首次实现时未考虑负数导致数组越界，调试2小时才发现。" —— DEVILK

---

## 知识扩展
**状态空间压缩**：当问题存在周期性或重复结构时，可通过模运算将无限状态映射到有限空间，这是处理无限扩展问题的通用技巧。

---
处理用时：58.52秒
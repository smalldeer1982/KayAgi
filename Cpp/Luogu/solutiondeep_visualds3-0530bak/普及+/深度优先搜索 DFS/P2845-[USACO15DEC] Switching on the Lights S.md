# 题目信息

# [USACO15DEC] Switching on the Lights S

## 题目背景

来源：usaco-2015-dec

Farm John 最近新建了一批巨大的牛棚。这些牛棚构成了一个 $N \times N$ 的矩形网络 $(1 < N < 100)$。

然而 Bessie 十分怕黑，他想计算可以把多少个牛棚的灯打开。

## 题目描述

有 $N \times N$ 个房间，组成了一张 $N \times N$ 的网格图，Bessie 一开始位于左上角 $(1,1)$，并且只能上下左右行走。


一开始，只有 $(1,1)$ 这个房间的灯是亮着的，Bessie 只能在亮着灯的房间里活动。


有另外 $M$ 条信息，每条信息包含四个数 $a,b,c,d$，表示房间 $(a,b)$ 里有房间 $(c,d)$ 的灯的开关。


请计算出最多有多少个房间的灯可以被打开。

## 说明/提示

Bessie 可以使用 $(1,1)$ 的开关打开 $(1,2),(1,3)$ 的灯，然后走到 $(1,3)$ 并打开 $(2,1)$ 的灯，走到 $(2,1)$ 并打开 $(2,2)$ 的灯。$(2,3)$ 的开关无法到达。因此可以点亮 $5$ 个房间。

## 样例 #1

### 输入

```
3 6
1 1 1 2
2 1 2 2
1 1 1 3
2 3 3 1
1 3 1 2
1 3 2 1
```

### 输出

```
5```

# AI分析结果



# 算法分类：BFS

## 题解思路与核心难点分析

### 核心逻辑
题目要求动态处理两种操作：移动（仅限亮灯区域）和开灯。关键难点在于新开灯的房间可能因后续操作变得可达，需要回溯机制。各题解通过以下方式突破难点：
1. **BFS队列动态扩展**：每次处理队列节点时，先打开所有关联灯，再检查新开灯房间四周是否存在已访问区域，若有则立即加入队列
2. **双状态标记**：使用`light[][]`记录灯是否开启，`visited[][]`记录是否已访问，确保不会重复处理节点
3. **邻接表存储开关关系**：快速获取每个房间能控制的全部灯列表

### 解决难点对比
| 题解特点          | vani_prcups (DFS) | JMercury (BFS+邻接表) | BoAn (DFS循环) |
|-------------------|-------------------|-----------------------|----------------|
| 搜索方式          | 深度优先          | 广度优先              | 多次深度优先   |
| 回溯机制          | 递归检查四周      | 队列自动扩展          | 循环至无变化   |
| 数据结构          | 二维邻接表        | vector邻接表          | 二维数组       |
| 时间复杂度        | O(N²+M)           | O(N²+M)               | O(kN²)         |
| 空间效率          | 中                | 高                    | 低             |

## 高星题解推荐（≥4星）

### 1. JMercury（5星）
**核心亮点**：
- 使用标准BFS框架与邻接表存储
- 引入双重检查机制：处理节点时先扩展移动，再处理开灯操作
- 代码结构清晰，维护两个独立循环处理移动与开灯
```cpp
void spfa() {
    queue<P> q; 
    q.push({1,1}); 
    vis[1][1] = true; 
    MAP[1][1] = true;
    while(!q.empty()) {
        P u = q.front(); q.pop();
        // 处理移动可达节点
        for(移动方向){
            if(相邻节点未访问且已开灯) 加入队列
        }
        // 处理开灯操作
        for(所有可控灯){
            if(灯未开启){
                开启并计数
                if(新灯四周有已访问节点) 加入队列
            }
        }
    }
}
```

### 2. vani_prcups（4星）
**核心亮点**：
- 创新性使用DFS+回溯检查
- 动态判断新开灯房间是否与已访问区域接壤
- 二维邻接表节省空间
```cpp
void dfs(int x,int y) {
    v[x][y] = 1;
    // 处理当前节点开关
    for(开关列表){
        if(灯未开){
            开启并计数
            if(新灯四周有已访问节点) 立即DFS新灯房间
        }
    }
    // 深度优先扩展
    if(上方可走) dfs(x-1,y);
    if(下方可走) dfs(x+1,y);
    ...
}
```

### 3. WCG2025（4星）
**核心亮点**：
- 哈希降维技巧（坐标→一维数）
- 独立check函数验证跨行移动合法性
- 队列分层处理减少无效遍历
```cpp
void bfs(){
    while(队列不空){
        处理当前节点开关
        for(四个方向){
            if(移动合法且未访问) 加入队列
        }
        // 特殊处理跨行校验
        if(check(v)) 加入特殊队列
    }
}
```

## 最优思路提炼
1. **BFS队列分层扩展**：优先处理可达节点的移动，再处理其开灯操作
2. **开关触发式入队**：新开灯的房间若四周有已访问区域，立即加入队列
3. **状态分离存储**：独立维护开灯状态与访问状态避免逻辑混淆
4. **邻接表加速访问**：O(1)时间复杂度获取每个房间的全部可控灯

## 同类题目推荐
1. P1162 填涂颜色（BFS扩展封闭区域）
2. P1443 马的遍历（BFS最短路变形）
3. P3956 棋盘（BFS+状态分层）

## 可视化设计（复古像素风格）

### 动画要素
- **8位色盘**：已访问（绿色）、未访问但开灯（黄色）、未开灯（黑色）
- **音效设计**：
  - 开灯：短促"哔"声
  - 移动：脚步声采样
  - 完成：8-bit胜利旋律
- **Canvas绘制**：
```javascript
function drawGrid() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,width,height); // 背景黑色
    for(let i=0; i<N; i++){
        for(let j=0; j<N; j++){
            if(light[i][j]) {
                ctx.fillStyle = visited[i][j] ? '#0F0' : '#FF0';
                ctx.fillRect(j*16, i*16, 15, 15);
            }
        }
    }
}
```

### 交互功能
- **步进控制**：空格暂停/继续，方向键单步执行
- **状态面板**：显示当前队列长度、已开灯数
- **AI自动模式**：以2倍速自动演示BFS扩展过程

## 关键代码实现（BFS核心）
```cpp
int bfs() {
    queue<Node> q;
    q.push({1,1});
    light[1][1] = vis[1][1] = 1;
    int cnt = 1;
    while(!q.empty()) {
        auto u = q.front(); q.pop();
        // 处理所有可控灯
        for(auto& sw : switch[u.x][u.y]) {
            if(!light[sw.x][sw.y]) {
                light[sw.x][sw.y] = 1;
                cnt++;
                // 检查新灯四周是否可达
                for(int d=0; d<4; d++){
                    int nx = sw.x + dir[d][0];
                    int ny = sw.y + dir[d][1];
                    if(vis[nx][ny]) {
                        q.push(sw);
                        vis[sw.x][sw.y] = 1;
                        break;
                    }
                }
            }
        }
        // 标准BFS扩展
        for(int d=0; d<4; d++){
            int nx = u.x + dir[d][0];
            int ny = u.y + dir[d][1];
            if(valid(nx,ny) && light[nx][ny] && !vis[nx][ny]) {
                vis[nx][ny] = 1;
                q.push({nx, ny});
            }
        }
    }
    return cnt;
}
```

---
处理用时：89.82秒
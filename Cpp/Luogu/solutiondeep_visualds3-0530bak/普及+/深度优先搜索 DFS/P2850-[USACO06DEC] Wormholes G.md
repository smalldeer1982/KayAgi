# 题目信息

# [USACO06DEC] Wormholes G

## 题目背景

[英文题面见此链接](https://www.luogu.com.cn/paste/mxuf6zpl)

## 题目描述

John 在他的农场中闲逛时发现了许多虫洞。虫洞可以看作一条十分奇特的有向边，并可以使你返回到过去的一个时刻（相对你进入虫洞之前）。

John 的每个农场有 $m$ 条小路（无向边）连接着 $n$ 块地（从 $1 \sim n$ 标号），并有 $w$ 个虫洞。

现在 John 希望能够从某块地出发，走过一条路径回到出发点，且同时也回到了出发时刻以前的某一时刻。请你告诉他能否做到。

## 说明/提示

#### 样例 2 解释

John 只需要沿着 $1 \rightarrow 2 \rightarrow 3 \rightarrow 1$ 的路径一直转圈即可，每转完一圈，时间就会减少一秒。

#### 数据范围与约定

对于 $100\%$ 的数据，$1 \le T \le 5$，$1 \le n \le 500$，$1 \le m \le 2500$，$1 \le w \le 200$，$1 \le p \le 10^4$。

## 样例 #1

### 输入

```
2
3 3 1
1 2 2
1 3 4
2 3 1
3 1 3
3 2 1
1 2 3
2 3 4
3 1 8```

### 输出

```
NO
YES```

# AI分析结果



# 算法分类：其他搜索（负环检测）

## 题解思路与核心难点

### 核心逻辑
判断图中是否存在负权环，存在负环意味着可以无限减少时间回到起点前。通过将虫洞建模为负权边，小路建模为无向正权边，转化为图论中的负环检测问题。

### 算法要点
1. **DFS版SPFA**：通过递归深度优先遍历检测负环，当某节点在递归路径中被二次访问时立即判定存在负环，时间复杂度 O(k·m)
2. **超级源点**：添加虚拟源点连接所有节点，避免多次遍历不同起点
3. **松弛优化**：初始化所有节点距离为0，仅关注负权边的松弛

### 解决难点
- 避免BFS版SPFA的O(n·m)最坏时间复杂度
- 正确处理双向小路与单向虫洞的混合存储
- 快速终止条件设计，DFS版可在发现环时立即返回

---

## 题解评分（≥4星）

1. **wjy666的DFS版SPFA（5星）**
   - 亮点：递归检测重复访问节点，使用vector邻接表
   - 关键代码：`if (fl[k]==1) { flag=1; return; }`
   - 优化点：立即剪枝终止搜索

2. **Sakura_Peng的超级源点（4星）**
   - 亮点：通过虚拟源点合并多次搜索
   - 代码特色：`cun(0,i,0)` 构建超级源点
   - 实践性：减少遍历次数，提升效率

3. **kczno1的DFS优化（4星）**
   - 亮点：注释解释DFS与BFS的时间复杂度差异
   - 技巧：`dis[]`初始化为0，仅关注负权路径
   - 测试案例覆盖：给出特殊测试数据验证逻辑

---

## 最优思路提炼

### 关键技巧
1. **DFS快速检测**：递归时维护访问标记，二次访问同一路径节点立即判定负环
2. **虚拟源点合并**：通过连接所有节点的超级源点，统一搜索入口
3. **零距离初始化**：将各节点初始距离设为0，仅负权边能触发松弛

### 实现示例（DFS版SPFA核心代码）
```cpp
void spfa(int x) {
    if (fl[x]) { flag=1; return; }
    fl[x] = 1;
    for(auto &e : adj[x]) {
        if (dis[e.to] > dis[x] + e.w) {
            dis[e.to] = dis[x] + e.w;
            spfa(e.to);
            if (flag) return;
        }
    }
    fl[x] = 0;
}
```

---

## 同类问题与题目推荐

### 类似算法套路
- **负环检测模板题**：如洛谷P3385
- **差分约束系统**：通过不等式建图判断可行性
- **最长路径问题**：转化为负权最短路径问题

### 推荐题目
1. **P3385 【模板】负环**  
   （直接练习负环检测模板）
2. **P1938 [USACO09NOV] Job Hunt S**  
   （带权路径与环路限制）
3. **P1266 速度限制**  
   （混合正负权边的最短路变形）

---

## 可视化与算法演示

### 动画设计
- **节点状态**：  
  - 绿色：未访问  
  - 黄色：当前路径中  
  - 红色：发现重复访问（负环）  
- **操作演示**：  
  1. 虫洞边显示为红色箭头，小路为蓝色双向箭头  
  2. 递归过程用堆栈可视化，展示路径回溯  
  3. 发现环时触发闪烁提示与音效

### 复古像素风格
- **8位风格**：  
  - 节点用16x16像素方块，边用单色线条  
  - 音效：8-bit音效库（访问声、发现环的胜利音效）  
- **自动演示**：  
  - 按帧推进递归深度，ESC暂停查看路径  
  - 右侧面板显示当前路径节点序列

---

## 个人心得摘录

> "DFS的SPFA在判负环时，一旦某个点两次出现在递归路径中就立即返回，这比BFS统计入队次数快得多。实测对于链式负环，DFS能比BFS快10倍以上。" —— wjy666题解注释

> "初始化所有节点距离为0，使得只有负权边能触发松弛，这相当于让算法专注检测负权路径，跳过正权边的无效计算。" —— EightSixSun题解心得

---

## 核心代码实现（DFS SPFA）

```cpp
vector<pair<int,int>> adj[505]; // 邻接表
int vis[505], dis[505];

bool dfs_spfa(int u) {
    vis[u] = 1;
    for (auto [v, w] : adj[u]) {
        if (dis[v] > dis[u] + w) {
            dis[v] = dis[u] + w;
            if (vis[v] || dfs_spfa(v)) 
                return true;
        }
    }
    vis[u] = 0;
    return false;
}

bool has_negative_cycle() {
    memset(dis, 0, sizeof dis);
    memset(vis, 0, sizeof vis);
    for (int i = 1; i <= n; ++i) {
        if (dfs_spfa(i)) 
            return true;
    }
    return false;
}
```

---
处理用时：90.74秒
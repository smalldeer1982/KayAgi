# 题目信息

# [SDOI2013] 直径

## 题目描述

小 Q 最近学习了一些图论知识。根据课本，有如下定义。树：无回路且连通的无向图，每条边都有正整数的权值来表示其长度。如果一棵树有 $N$ 个节点，可以证明其有且仅有 $N-1$ 条边。

路径：一棵树上，任意两个节点之间最多有一条简单路径。我们用 $\text{dis}(a,b)$ 表示点 $a$ 和点 $b$ 的路径上各边长度之和。称 $\text{dis}(a,b)$ 为 $a,b$ 两个节点间的距离。

直径：一棵树上，最长的路径为树的直径。树的直径可能不是唯一的。

现在小 Q 想知道，对于给定的一棵树，其直径的长度是多少，以及有多少条边满足所有的直径都经过该边。


## 说明/提示

【样例说明】 

直径共有两条，$3$ 到 $2$ 的路径和 $3$ 到 $6$ 的路径。这两条直径都经过边 $(3,1)$ 和边$(1, 4)$。

对于 $100\%$ 的测试数据：$2\le N\le 200000$，所有点的编号都在 $1\sim N$ 的范围内，边的权值 $\le10^9$。


## 样例 #1

### 输入

```
6
3 1 1000
1 4 10
4 2 100
4 5 50
4 6 100```

### 输出

```
1110 
2```

# AI分析结果



### **算法分类**  
DFS + BFS（混合搜索）

---

### **题解思路、算法要点与解决难点**  
#### **核心思路**  
所有直径必经边满足以下性质：  
1. **必在任意一条直径上**  
2. **删除该边后，分裂的两子树直径均小于原树直径**  

#### **关键步骤**  
1. **求任意一条直径**  
   - 两次 DFS/BFS 确定直径端点 `s` 和 `t`  
2. **标记直径路径**  
   - 通过父指针回溯记录直径上的所有点  
3. **确定必经边范围**  
   - **左断点**：从 `s` 向右遍历，找到第一个点 `j`，其非直径最长路径等于到 `t` 的距离  
   - **右断点**：从 `t` 向左遍历，找到第一个点 `k`，其非直径最长路径等于到 `s` 的距离  
   - 必经边为 `j` 到 `k` 之间的所有边  

#### **解决难点**  
- **高效计算非直径点的最长路径**  
  - 对直径上的每个点进行 DFS，避开其他直径点，得到 `dis[i]`  
- **正确判定断点边界**  
  - 结合 `ls[i]`（到左端点的距离）和 `rs[i]`（到右端点的距离）比较 `dis[i]`  

---

### **题解评分与推荐**  
#### **高星题解（≥4星）**  
1. **破壁人（⭐⭐⭐⭐⭐）**  
   - **亮点**：直观的分段遍历策略，清晰的断点判断逻辑  
   - **代码片段**：  
     ```cpp  
     for (i = j; i != 0; i = next[i])  
         if (dis[v] - dis[i] == mmm[i]) break;  
     ```  
2. **i207M（⭐⭐⭐⭐）**  
   - **亮点**：树形 DP 统计路径方案数，避免复杂路径遍历  
   - **代码片段**：  
     ```cpp  
     void dfs(int x, int _fa) {  
         f[x].w = 0, f[x].cnt = 1;  
         for (ri i = head[x]; i; i = nx[i]) {  
             // ... 动态维护最长路径和方案数  
         }  
     }  
     ```  
3. **wu3412790（⭐⭐⭐⭐）**  
   - **亮点**：基于中点定理简化问题，递归处理子树  

---

### **最优思路提炼**  
1. **必经边必在一条直径上**：通过两次 BFS 确定直径端点及路径  
2. **非直径分支的最长路径判定**：DFS 计算每个直径点的最大非直径路径 `dis[i]`  
3. **双指针缩范围**：左断点 `j` 和右断点 `k` 确定必经边区间  

---

### **同类型题与算法套路**  
- **类似问题**：树的最长路径、必经节点/边计数  
- **通用解法**：  
  - **双 BFS 求直径**：快速定位树的最长路径  
  - **DFS 子树分析**：处理子树最长路径或方案数统计  

---

### **推荐题目**  
1. [P1099 树网的核](https://www.luogu.com.cn/problem/P1099)  
2. [P2491 消防](https://www.luogu.com.cn/problem/P2491)  
3. [P4381 岛屿](https://www.luogu.com.cn/problem/P4381)  

---

### **可视化与算法演示**  
#### **动画设计**  
1. **像素风格遍历**：  
   - **节点表示**：8-bit 方块，直径点高亮为红色，必经边闪烁绿色  
   - **遍历过程**：队列（BFS）用蓝色波纹扩散，栈（DFS）用橙色涟漪  
2. **关键步骤演示**：  
   - **断点移动**：动态展示 `j` 和 `k` 的移动过程，结合数值比较逻辑  
   - **非直径路径计算**：灰色线条表示非直径分支，长度实时显示  
3. **交互控制**：  
   - **速度调节**：滑动条控制动画速度（1x~5x）  
   - **单步调试**：按钮逐帧观察 BFS/DFS 的节点访问顺序  

#### **核心代码片段（Canvas 动画）**  
```javascript  
function drawTree() {  
    ctx.clearRect(0, 0, canvas.width, canvas.height);  
    // 绘制所有边  
    edges.forEach(edge => {  
        if (isDiameterEdge(edge)) ctx.strokeStyle = "#FF0000"; // 红色标记直径边  
        else ctx.strokeStyle = "#888888";  
        drawEdge(edge);  
    });  
    // 高亮当前访问节点  
    ctx.fillStyle = "#00FF00";  
    currentNode.forEach(node => drawNode(node));  
}  
```

---

### **个人心得摘录**  
- **调试教训**：未开 `long long` 导致 WA，需注意数据范围  
- **思维突破**：利用中点定理大幅简化问题，避免复杂路径遍历  

---

### **结论**  
**破壁人题解**为最优实践，通过双指针缩范围的思路清晰高效，适合竞赛实现。结合可视化演示，可直观理解必经边的判定过程。

---
处理用时：114.18秒
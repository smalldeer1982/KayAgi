# 题目信息

# [CQOI2007] 三角形

## 题目描述

画一个等边三角形，把三边的中点连接起来，得到四个三角形，把它们称为 $T_1,T_2,T_3,T_4$，如图1。

把前三个三角形也这样划分，得到 $12$ 个更小的三角形，$T_{11},T_{12},T_{13},T_{14},T_{21},T_{22},T_{23},T_{24},T_{31},T_{32},T_{33},T_{34}$，如图2。

把编号以 $1,2,3$ 结尾的三角形又继续划分……最后得到的分形称为 Sierpinski 三角形。

![](https://cdn.luogu.com.cn/upload/pic/18501.png)

如果三角形 $B$ 不包含三角形 $A$，且 $A$ 的某一条完整的边是 $B$ 的某条边的一部分，则我们说 $A$ 靠在 $B$ 的边上。例如 $T_{12}$ 靠在 $T_{14}$ 和 $T_4$ 上，但不靠在 $T_{32}$ 上。

给出 Spierpinski 三角形中的一个三角形，找出它靠着的所有三角形。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 50$。

## 样例 #1

### 输入

```
T312```

### 输出

```
T314
T34
T4```

# AI分析结果



### 算法分类
**其他搜索**（基于字符串分析的规律推导与层次遍历）

---

### 题解思路与核心难点

#### 核心思路
1. **末尾为4的特判**：若输入编号末尾是`4`，直接输出前三位替换为`1,2,3`的三角形。
2. **非末尾4的层次分析**：对于非`4`结尾的三角形，其靠着的三角形必定是某一层父级结构的中间三角形（编号以`4`结尾）。通过遍历字符串的每一位，将首次出现的`1,2,3`替换为`4`生成结果。

#### 解决难点
- **层次跳跃**：需识别三角形在不同父级层次中的位置，例如`T312`的父级层次依次是`T31`、`T3`、`T`。
- **去重与顺序**：避免重复生成相同父级结构，如倒序遍历并记录首次出现的数字，确保每个父级仅处理一次。

#### 搜索算法要点
- **字符串遍历方向**：正序（如RedreamMer）或倒序（如xiaozeyu）处理每一位字符。
- **剪枝优化**：使用标志数组记录已处理的数字，确保每个数字仅生成一个结果。
- **数据结构**：字符串替换与排序输出。

---

### 高星题解推荐（≥4星）

1. **xiaozeyu（5星）**  
   - **亮点**：倒序遍历+首次出现标记，时间复杂度最优（O(n)），代码简洁。
   - **代码片段**：
     ```cpp
     for(int j=len-1;j>0;j--) {
         if(!flag[a[j]-'0']) {
             cout<<前缀+"4"<<endl;
             flag[a[j]-'0']=1;
         }
     }
     ```

2. **RedreamMer（4星）**  
   - **亮点**：正向遍历覆盖数组，逻辑直观，适合快速理解层次关系。
   - **代码片段**：
     ```cpp
     for(int i=1; i<=len; i++) {
         if(s[i]=='1') ss[0] = 前缀+"4";
         else if(s[i]=='2') ss[1] = 前缀+"4";
         // ...
     }
     ```

3. **Fire_flame（4星）**  
   - **亮点**：基于不同数字数量分类讨论，逻辑清晰，适合教学演示。
   - **代码片段**：
     ```cpp
     for(int i=0; i<s.size(); i++) {
         if(s[i]=='1') ans[1]=前缀+"4";
         // ...
     }
     ```

---

### 最优技巧提炼
1. **倒序首次标记法**：倒序遍历字符串，记录每个数字的首次出现位置，生成对应的父级中间三角形。
2. **层次覆盖法**：正序处理每位字符，直接覆盖对应位置的父级结果，最后统一排序去重。

---

### 类似题目推荐
1. **P1498 分形之城**：利用坐标变换递归生成分形结构。
2. **P1220 分形**：递归生成分形图形，分析坐标规律。
3. **P1010 幂次方**：递归分解数字为幂次表达式，类似字符串层次处理。

---

### 可视化设计
#### 搜索过程动画方案
- **节点扩展**：以树状结构展示分形层次，当前处理的字符高亮为红色，替换后生成的父级节点以绿色闪烁。
- **交互控制**：支持步进/暂停，显示当前遍历的字符位置及生成的父级编号。
- **复古像素风格**：用8-bit风格绘制三角形节点，点击节点触发音效（如“哔”声），成功生成结果时播放胜利音效。

#### 核心代码片段（Canvas动画）
```javascript
function drawNode(x, y, label, isCurrent) {
    ctx.fillStyle = isCurrent ? '#FF0000' : '#00FF00';
    ctx.fillRect(x, y, 30, 30);
    ctx.fillStyle = '#000';
    ctx.fillText(label, x + 5, y + 20);
}
// 遍历时调用：drawNode(x, y, s[i], i === currentPos);
```

---

### 个人心得摘录
> “通过倒序遍历字符串并标记首次出现的数字，可以高效生成所有父级中间三角形，避免重复计算。” —— xiaozeyu  
> “递归DFS虽直观，但字符串处理更简洁，适合竞赛时间优化。” —— AE酱

---

### 最终代码（xiaozeyu优化版）
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[55];
bool flag[5];
int main() {
    memset(flag, 0, sizeof(flag));
    cin >> a;
    int len = strlen(a);
    if (a[len-1] == '4') {
        for (int i=0; i<len-1; i++) cout << a[i];
        cout << "1\n";
        for (int i=0; i<len-1; i++) cout << a[i];
        cout << "2\n";
        for (int i=0; i<len-1; i++) cout << a[i];
        cout << "3\n";
        return 0;
    }
    for (int j=len-1; j>0; j--) {
        if (!flag[a[j]-'0']) {
            for (int i=0; i<j; i++) cout << a[i];
            cout << "4\n";
            flag[a[j]-'0'] = true;
        }
        if (flag[1] && flag[2] && flag[3]) break;
    }
    return 0;
}
```

---
处理用时：108.23秒
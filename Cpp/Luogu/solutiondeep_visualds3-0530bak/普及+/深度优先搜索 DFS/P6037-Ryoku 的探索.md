# 题目信息

# Ryoku 的探索

## 题目背景

Ryoku 对自己所处的世界充满了好奇，她希望能够在她「死」之前尽可能能多地探索世界。

这一天，Ryoku 得到了一张这个世界的地图，她十分高兴。然而，Ryoku 并不知道自己所处的位置到底在哪里，她也不知道她会什么时候死去。她想要知道如何才能尽可能多的探索这个世界。

## 题目描述

Ryoku 所处的世界可以抽象成一个有 $n$ 个点， $n$ 条边的带权无向连通图 $G$。每条边有美观度和长度。

Ryoku 会使用这样一个策略探索世界：在每个点寻找一个**端点她未走过**的边中**美观度最高**的走，如果没有边走，就沿着她前往这个点的边返回，类似于图的**深度优先遍历**。

探索的一个方案的长度是这个方案所经过的所有边长度的和（返回时经过的长度不用计算）。

她想知道，对于每一个起点 $s=1,2,\cdots,n$，她需要走过的长度是多少？



## 说明/提示

**【样例 1 说明】**

以下为输入输出样例 1 中的图： （边上红色数组为 $p$，黑色为 $w$）

![](https://cdn.luogu.com.cn/upload/image_hosting/rmk07281.png)

若起点为 $1$，顺序为 $1\to3\to5\to2\to4$，长度之和为 $7$。  
若起点为 $2$，顺序为 $2\to3\to5\to1\to4$，长度之和为 $7$。  
若起点为 $3$，顺序为 $3\to5\to1\to2\to4$，长度之和为 $8$。  
若起点为 $4$，顺序为 $4\to1\to3\to5\to2$，长度之和为 $7$。  
若起点为 $5$，顺序为 $5\to3\to1\to2\to4$，长度之和为 $8$。  

---

**【数据规模与约定】**

对于 $40\%$ 的数据，$n\le 10^3$。    
对于 $100\%$ 的数据，$3 \le n \le 10^6$，$1 \le u,v,p \le n$，$0\le w\le 10^9$，保证 $p$ 互不相同。

## 样例 #1

### 输入

```
5
4 1 2 1
1 2 3 2
3 1 1 4
3 5 2 5
2 3 2 3
```

### 输出

```
7
7
8
7
8```

# AI分析结果



# 【算法分类】  
**DFS**  

---

## **题解思路与核心难点**  
**核心思路**：  
1. **基环树结构**：题目给定的图是基环树（一个环 + 多棵子树），遍历时会走完所有边 **除环上的一条边**。  
2. **环处理**：  
   - **忽略边确定**：环上每个节点根据美观度选择忽略一条边（美观度较低的边）。  
   - **总长度计算**：总边权和减去被忽略边的权值。  
3. **子树处理**：非环节点的答案等于其所在子树的根节点（环上节点）的答案。  

**难点与解决**：  
1. **找环**：  
   - **DFS回溯法**（xiejinhao）：通过DFS回溯记录环上的节点，利用`vis`标记判断重复访问。  
   - **拓扑排序**（Zvelig1205、wangjinbo）：通过度数筛除非环节点，剩余度数≥2的节点构成环。  
2. **子树答案传递**：通过DFS遍历子树，将环上节点的答案传递给子树节点。  

---

## **题解评分（≥4星）**  
1. **xiejinhao（★★★★★）**  
   - **亮点**：DFS回溯找环，动态计算忽略边权；代码逻辑清晰，注释详细。  
   - **代码片段**：  
     ```cpp  
     bool dfs(int x, int fa, int fp, int fe) {  
         if(vis[x]) {  
             End = x, Ep = fp, Ee = fe;  
             return true;  
         }  
         vis[x] = 1;  
         for(int i = head[x]; i; i = Next[i]) {  
             int y = ver[i];  
             if(y == fa) continue;  
             if(dfs(y, x, p[i], e[i])) {  
                 ans[x] -= (美观度比较后的边权);  
                 ring.push_back(x);  
                 return x != End;  
             }  
         }  
         return false;  
     }  
     ```  
2. **Zvelig1205（★★★★☆）**  
   - **亮点**：拓扑排序找环，结构清晰；通过子树DFS传递答案。  
3. **wangjinbo（★★★★☆）**  
   - **亮点**：简洁的拓扑排序实现，快速判断环与非环节点。  

---

## **最优思路提炼**  
1. **找环关键**：  
   - **DFS回溯**：在DFS中记录路径，遇到已访问节点时回溯提取环。  
   - **拓扑排序**：通过度数筛除非环节点，剩余节点构成环。  
2. **忽略边选择**：环上节点比较相邻两条边的美观度，忽略较小的边。  
3. **子树答案继承**：以环为根遍历子树，子树节点答案等于根节点。  

---

## **类似题目推荐**  
1. **P2607 [ZJOI2008] 骑士**（基环树DP）  
2. **P4381 [IOI2008] Island**（基环树直径）  
3. **P3533 [POI2012] RAN-Rendezvous**（基环树最近公共祖先）  

---

## **可视化与算法演示**  
**动画设计**：  
1. **基环树绘制**：  
   - **环**：红色节点与边，动态高亮环的发现过程（DFS回溯或拓扑排序）。  
   - **子树**：绿色节点，显示从环上节点延伸的子树。  
2. **遍历过程**：  
   - **选择边**：当前节点扩展时，美观度最高的边闪烁显示。  
   - **忽略边**：被忽略的环边标灰，显示权值扣除。  
3. **复古像素风格**：  
   - **节点**：8位像素方块，环节点红色，子树节点绿色。  
   - **音效**：访问新节点时播放“滴”声，忽略边时播放“咔嚓”声。  

---

## **代码实现（核心部分）**  
**xiejinhao的DFS找环与答案计算**：  
```cpp  
// DFS找环并计算答案  
bool dfs(int x, int fa, int fp, int fe) {  
    if(vis[x]) {  
        End = x;  
        Ep = fp; Ee = fe;  
        return true;  
    }  
    vis[x] = 1;  
    for(int i = head[x]; i; i = Next[i]) {  
        int y = ver[i];  
        if(y == fa) continue;  
        if(dfs(y, x, p[i], e[i])) {  
            // 比较美观度，确定忽略边  
            if(x != End) ans[x] -= (fp > p[i] ? e[i] : fe);  
            else ans[x] -= (p[i] > Ep ? Ee : e[i]);  
            ring.push_back(x);  
            return x != End;  
        }  
    }  
    return false;  
}  
```  

---

## **个人心得摘录**  
> "一年OI一场空，不开long long见祖宗。" —— Zvelig1205  
> **总结**：数据范围大时需注意变量类型，避免溢出。  

---

## **复古游戏化动画实现（伪代码）**  
```javascript  
// Canvas绘制基环树（伪代码）  
function drawGraph() {  
    // 环节点：红色像素块  
    ringNodes.forEach(node => {  
        drawPixel(node.x, node.y, '#FF0000');  
    });  
    // 子树节点：绿色像素块  
    treeNodes.forEach(node => {  
        drawPixel(node.x, node.y, '#00FF00');  
    });  
    // 当前访问节点：闪烁黄色  
    if (currentNode) {  
        drawBlinking(currentNode.x, currentNode.y, '#FFFF00');  
    }  
}  
// 音效触发  
function playSound(effect) {  
    if (effect === 'visit') audio.play('beep.wav');  
    if (effect === 'ignore') audio.play('click.wav');  
}  
```

---
处理用时：69.28秒
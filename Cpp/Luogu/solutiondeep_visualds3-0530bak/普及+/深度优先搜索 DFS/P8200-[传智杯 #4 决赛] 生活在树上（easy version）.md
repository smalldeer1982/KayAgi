# 题目信息

# [传智杯 #4 决赛] 生活在树上（easy version）

## 题目背景

**本题是 P8201 的简单版本，两道题目的解法略有不同。本题和 P8201 在题意上的区别在于本题给定树上的边权，而不是点权。**

小智生活在「传智国」，这是一个有 $n$ 个城市的国家，各个城市由 $n-1$ 条道路相连。

每个道路都有长度 $w_i$ ，我们定义，小智从城市 $a$ 走到城市 $b$ 的代价是 $\mathrm{dis}_{a, b} = \bigoplus \limits_{e \in \mathrm{path}\left(a, b\right)} w_e$，其中 $\bigoplus$ 表示**按位异或**（如果你不知道什么是**按位异或**，请参见题目下方的提示/说明），$\mathrm{path}\left(a,b\right)$ 表示 $a$ 到 $b$ 的简单路径上的边集。也即 $\mathrm{dis}_{a, b}$ 表示将 $a$ 与 $b$ 的简单路径上所有边写作 $e_1, e_2, e_3, \dots$ 后，求 $w_{e_1} \bigoplus w_{e_2}\bigoplus w_{e_3} \dots$ 的结果。

有一天，小智获得了去参加传智杯的机会，他在前往比赛地的路上想到了一个问题，但他好像不会做，于是他把这个题告诉了你。聪明的同学，你可以帮帮他吗？

## 题目描述

小智说：「由于我们的国家只有 $n$ 个城市和 $n-1$ 条道路，那么我们的国家就相当于是一棵树。我在想，在我们的国家中，是否有城市满足『到城市 $a$ 的代价和到城市 $b$ 的代价的异或等于 $k$』。好难哦，我想不出来，你能帮帮我吗？」

也就是说，给定城市 $a, b$ 和整数 $k$，请你计算是否存在城市 $t$ 满足 $\mathrm{dis}_{t, a} \bigoplus \mathrm{dis}_{t, b} = k$。

## 说明/提示

### 相关概念解释
「树」：树是一个有 $n$ 个结点和 $n-1$ 条边的无向简单连通图。

「按位异或」：按位异或即 C++、python、java 语言中的 「^」 运算。它是一个二元运算，步骤是将两个数的二进制位按位比较，相同为 $0$，不同为 $1$。例如：$3 \bigoplus 5 = (011)_2 \bigoplus (101)_2 = (110)_2 = 6$。**请注意，这是一个按位运算，不是一个逻辑运算**。
### 样例 1 解释
下图为传智国的地图。

$\forall t \in \{1, 2, 3, 4, 5\}$，都不可能有 $\mathrm{dis} _{t,1} \bigoplus \mathrm{dis}_{t, 2} = 4$，$\mathrm{dis}_{t, 2} \bigoplus \mathrm{dis}_{t, 3} = 12$，于是输出 `No`；

而取 $t = 5$，有 $\mathrm{dis}_{t, 1} \bigoplus \mathrm{dis}_{t, 4} = 10$，于是输出 `Yes`。

![](https://cdn.luogu.com.cn/upload/image_hosting/9ikzjfh3.png)
### 数据规模与约定
对于所有测试点，保证 $1 < n \leq 5 \times 10^5$，$1 \leq m \leq 5 \times 10^5$，$0 \leq w_i < 2^{64}$。

对于每次询问，保证 $1 \leq a, b \leq n$ 且 $a \neq b$，$0 \leq k < 2^{64}$。

## 样例 #1

### 输入

```
5 3
1 2 2
1 3 6 
2 4 8
2 5 1
1 2 4
2 3 12
1 4 10```

### 输出

```
nO
No
YeS```

## 样例 #2

### 输入

```
5 10
2 1 63
3 1 57
4 2 2
5 2 84
5 2 84
4 1 9977404983223574764
2 5 84
2 1 15996060349666123522
5 4 86
3 1 8428615422876116375
5 1 107
2 3 6
2 3 6
4 2 2```

### 输出

```
yeS
nO
YEs
No
YEs
nO
YEs
yeS
yeS
YEs```

# AI分析结果



## 【唯一算法分类】
DFS

---

## 【综合分析与结论】
题目要求判断是否存在点t，使得t到a和t到b的路径异或和等于k。核心思路是发现无论t的位置如何，其到a和b的异或和等于a到b的路径异或和。通过DFS预处理每个节点到根的异或值，查询时直接比较a和b的异或值是否等于k。

**解决难点**：  
1. **路径异或的抵消性**：利用异或运算的自反性，公共路径部分会被抵消，仅保留a到b的异或和。  
2. **高效预处理**：DFS遍历树，计算每个节点到根节点的异或值，时间复杂度O(n)。  
3. **查询优化**：将问题转化为O(1)的异或比较，无需LCA或复杂路径计算。  

**可视化设计思路**：  
1. **DFS遍历动画**：以根节点为起点，逐层遍历子树，实时显示当前节点的异或值。  
2. **路径对比**：在查询时，高亮a和b的路径，展示异或抵消过程。  
3. **复古像素风格**：用8位色块表示节点，不同颜色区分已访问和未访问节点，访问时播放经典音效。  

---

## 【题解清单 (≥4星)】
1. **一扶苏一（5星）**  
   - **亮点**：利用群论思想推导异或性质，代码简洁高效。  
   - **核心代码**：预处理DFS，查询直接比较异或值。  

2. **lsj2009（5星）**  
   - **亮点**：详细推导异或性质，代码极简，时间复杂度最优。  
   - **关键句**：“不需要枚举i，直接判断异或和是否等于k。”  

3. **苏联小渣（4星）**  
   - **亮点**：通过LCA推导异或抵消，代码清晰，附带注意事项提醒。  
   - **心得**：“注意异或运算优先级，调试时因此卡壳。”  

---

## 【最优思路/技巧提炼】
1. **异或抵消定理**：对于任意路径查询，利用异或的自反性将问题简化为两点间异或和比较。  
2. **前缀异或预处理**：DFS一次计算所有节点到根的异或值，避免重复计算路径。  
3. **O(1)查询优化**：通过数学推导将问题转化为常数时间操作，极大提升效率。  

---

## 【同类型题与算法套路】
- **通用解法**：树上路径统计问题，常利用前缀和（加法、异或等）预处理，将路径查询转化为端点的运算。  
- **类似题目**：  
  1. **P2420 让我们异或吧**：计算树上路径异或和。  
  2. **P4556 雨天的尾巴**：树上路径标记与统计。  
  3. **P2633 Count on a tree**：树上路径第k大查询。  

---

## 【推荐洛谷题目】
1. **P2420**（异或路径查询）  
2. **P3379**（LCA模板，结合路径处理）  
3. **P4592**（异或性质与树分治）  

---

## 【个人心得摘录】
- **lsj2009**：“调试时发现必须用unsigned long long，否则溢出导致WA。”  
- **stntn**：“本题SPJ允许输出大小写混合，但实际比赛中需注意格式。”  
- **Dusker**：“随机输出Yes/No的大小写形式，增加趣味性。”  

---

## 【代码片段（DFS预处理）】
```cpp
void dfs(int u, int fa) {
    for (auto [v, w] : edges[u]) {
        if (v != fa) {
            xor_sum[v] = xor_sum[u] ^ w;
            dfs(v, u);
        }
    }
}

// 查询时直接比较
if (xor_sum[a] ^ xor_sum[b] == k) return Yes;
```

---

## 【可视化与复古动画设计】
1. **像素风格树**：节点用16x16像素方块表示，边用直线连接，异或值以8位字体显示。  
2. **DFS动画**：  
   - **当前节点**：红色闪烁方块。  
   - **已访问节点**：绿色静态方块。  
   - **音效**：访问节点时播放“哔”声，完成DFS时播放胜利音效。  
3. **交互控制**：  
   - **速度滑块**：调整DFS遍历速度（慢/中/快）。  
   - **单步执行**：按空格键逐步执行DFS。  
4. **查询演示**：输入a、b、k后，高亮路径并显示异或计算过程，结果以弹窗提示。  

**代码片段（Canvas绘制节点）**：  
```javascript
function drawNode(x, y, value, isCurrent) {
    ctx.fillStyle = isCurrent ? '#FF0000' : '#00FF00';
    ctx.fillRect(x * 50, y * 30, 40, 40);
    ctx.fillStyle = '#000';
    ctx.font = '8px Arial';
    ctx.fillText(value.toString(16), x * 50 + 5, y * 30 + 20);
}
```

---
处理用时：69.19秒
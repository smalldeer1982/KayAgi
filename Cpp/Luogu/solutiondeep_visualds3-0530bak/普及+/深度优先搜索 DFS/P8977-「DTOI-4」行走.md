# 题目信息

# 「DTOI-4」行走

## 题目背景

小 L 感到无聊，于是希望在树上行走。

## 题目描述

小 L 有一棵 $n$ 个点的树，树上点有点权，其中第 $i$ 个点权值为 $a_i$。

他不喜欢奇奇怪怪的权值，于是他保证 $a_i$ 一定是 $-1, 0, 1$ 之一。

他认为在树上行走是有趣的，于是他想要在这棵树上走出一条路径 $P$，其需要满足以下条件：

- $P$ 是一条**可以为空**的**简单有向路径**。
- 设 $P$ 中依次经过的点为 $P_1, P_2, \cdots, P_{|P|}$，则你求出的 $P$ 需要满足 $P_1 = 1$。
- 设 $f(P) = \displaystyle\sum_{i = 1}^{|P|} \frac{a_{P_i}}{2^{i - 1}}$，则你求出的 $P$ 需要满足 $f(P)$ 最大。
- 在 $f(P)$ 最大的前提下，你求出的 $P$ 还需要满足 $P$ 的字典序最小。

请你求出符合上述条件的路径 $P$。 

------------

关于本题中字典序的定义：

设有两条待比较的路径 $P \neq Q$。

- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i < Q_i$，则我们称 $P$ 的字典序小于 $Q$。
- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i > Q_i$，则我们称 $P$ 的字典序大于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| < |Q|$，则我们称 $P$ 的字典序小于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| > |Q|$，则我们称 $P$ 的字典序大于 $Q$。

## 说明/提示

#### 样例 #1 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/c7n2n6i0.png)

$P = [1, 2, 4]$ 时 $f(P) = 1 + 0 + \frac{1}{4} = \frac{5}{4}$。可以证明不存在更优的 $P$。
#### 数据范围
| $\textbf{Subtask}$ | $n$ | $a_i$ | 依赖 | 分值 |
| :------: | :------: | :------: | :------: | :------: |
| $1$ | $1 \leq n \leq 50$ | 无特殊限制 | 无 | $10 \operatorname{pts}$ |
| $2$ | $1 \leq n \leq 500$ | 同上 | $1$ | $10 \operatorname{pts}$ |
| $3$ | $1 \leq n \leq 5 \times 10^3$ | 同上 | $1, 2$ | $10 \operatorname{pts}$ |
| $4$ | $1 \leq n \leq 10^5$ | 同上 | $1 \sim 3$ | $20 \operatorname{pts}$ |
| $5$ | 无特殊限制 | $a_i \in \{-1, 1\}$ | 无 | $20 \operatorname{pts}$ |
| $6$ | 同上 | 无特殊限制 | $1 \sim 5$ | $30 \operatorname{pts}$ |

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$a_i \in \{-1, 0, 1\}$，$1 \leq u, v \leq n$，保证给出的边可以构成一棵**无根树**。

## 样例 #1

### 输入

```
5
1 0 -1 1 -1
1 2
2 3
2 4
1 5```

### 输出

```
1 2 4```

# AI分析结果



# 【算法分类】  
**DFS**

# 【题解思路与解决难点】  

## **核心思路**  
1. **排除-1节点**：由于-1的贡献无法被后续节点弥补，所有路径中不能包含权值为-1的节点。  
2. **贪心选择1**：在每一步优先选择权值为1的子节点，确保当前路径的分数最大。  
3. **字典序处理**：邻接表按子节点编号排序，遍历时按顺序访问，保证相同条件下选择编号最小的节点。  
4. **末尾0处理**：路径末尾的0不会增加分数，但会增加字典序，需去除。  

## **难点与解决方案**  
- **分数比较**：通过贪心策略避免显式计算分数。高位权值（如前面的1）直接影响整体大小，无需逐位计算。  
- **字典序维护**：预先排序邻接表，DFS/BFS遍历时按编号顺序访问子节点。  
- **高效剪枝**：在DFS中用数组记录当前最优路径，遇到更优路径时更新并剪枝后续分支。  

# 【题解评分（≥4星）】  

1. **xiaoqian02（4星）**  
   - **亮点**：清晰的DFS实现，维护路径权值数组（`qz`）和下一节点指针（`nxt`），动态更新最大路径。  
   - **代码可读性**：结构简洁，注释详细，适合快速理解贪心逻辑。  

2. **Hovery（4星）**  
   - **亮点**：BFS按层扩展，记录每层最大贡献，通过父指针重建路径。  
   - **优化点**：预处理父节点减少路径重建复杂度，适合大规模数据。  

3. **Leasier（4星）**  
   - **亮点**：逐层贪心筛选候选节点，处理末尾0剪枝，代码复杂度低。  
   - **技巧**：用双队列交替处理当前层和下一层，避免重复计算。  

# 【最优思路或技巧提炼】  
- **贪心路径选择**：每一步优先选1，无1再选0，确保分数最大化。  
- **邻接表预处理**：排序子节点列表，保证字典序最小的路径优先被访问。  
- **动态剪枝**：在DFS中维护当前路径权值数组，遇到更优分支时立即更新并终止无关搜索。  

# 【同类型题与算法套路】  
- **类似问题**：树/图中的最长路径、字典序最小路径、贪心选择最优子节点问题。  
- **通用解法**：  
  - **贪心+搜索**：结合贪心策略的DFS/BFS，优先访问特定条件下的节点。  
  - **邻接表排序**：预处理子节点顺序，确保遍历时符合题目要求的优先级。  

# 【推荐题目】  
1. **P1137 旅行计划**（拓扑排序+字典序路径）  
2. **P1606 [USACO07DEC]白银莲花池**（BFS处理带权路径）  
3. **P3958 奶酪**（三维空间BFS/DFS）  

# 【个人心得摘录】  
- **xiaoqian02**：赛时误以为起点任意，浪费15分钟，强调仔细审题的重要性。  
- **LiYomi**：BFS分层处理时需注意同一层节点的相互影响，避免局部最优导致全局错误。  

# 【可视化与算法演示】  
## **动画设计**  
- **节点状态**：  
  - 红色：当前访问节点（如根节点1）。  
  - 绿色：权值为1的子节点。  
  - 蓝色：权值为0的子节点。  
  - 灰色：权值为-1（不可访问）。  
- **搜索过程**：  
  1. 从根节点开始，按排序后的子节点顺序依次访问。  
  2. 优先选择绿色节点（权值1），若无则选蓝色节点（权值0）。  
  3. 动态显示路径构建，末尾0节点自动淡化表示剪枝。  
- **交互功能**：  
  - **速度调节**：滑块控制动画步进速度。  
  - **单步执行**：手动点击观察每一步选择逻辑。  
  - **路径对比**：并列显示DFS与BFS的搜索轨迹，突出贪心策略差异。  

## **复古像素风格实现**  
- **Canvas绘制**：用16色像素块表示节点，边用直线连接，节点编号显示在右侧。  
- **音效设计**：  
  - **节点访问**：8-bit“哔”声。  
  - **路径更新**：上扬音调提示更优路径。  
  - **剪枝**：低沉音效表示放弃当前分支。  
- **自动演示**：AI模式模拟DFS/BFS的完整搜索过程，用户可暂停观察细节。  

```javascript
// 示例代码（Canvas绘制节点）  
function drawNode(ctx, x, y, color) {  
    ctx.fillStyle = color;  
    ctx.fillRect(x - 10, y - 10, 20, 20);  
    ctx.strokeStyle = '#000';  
    ctx.strokeRect(x - 10, y - 10, 20, 20);  
}  
```

---
处理用时：155.40秒
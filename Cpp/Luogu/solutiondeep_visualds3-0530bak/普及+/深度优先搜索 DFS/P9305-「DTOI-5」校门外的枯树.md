# 题目信息

# 「DTOI-5」校门外的枯树

## 题目背景

某天放学，你走出了校门，发现校门外又双叒叕出现了一排树。只不过因为正值寒冬时节，树的叶子都掉光了，树们在寒风中瑟瑟发抖，让人担心它们会不会在某一时刻失去平衡，然后倒下来。

## 题目描述

给你校门外的一排 $T$ 棵无向有根树（每棵树的根节点编号均为 $1$），每棵树的每条边有其重量 $m_i$，现在请你算出每棵树的不平衡度 **或** 该树的**每个节点的子树**的不平衡度，好让校方帮忙加固。$\color{white}\sout{\text{不要问我为什么重量的字母是 }m\text。}$

注意这里的**树的边是有顺序的**，~~你总不可能把树枝掰断然后嫁接到另一个地方吧，这可是枯树啊喂~~。

---

对于一颗有根树，定义其不平衡度为该树被在根节点与某一叶子节点的一条最短路径分割为左右两部分（两个边集）后（两个边集均不含该最短路径中的边）两部分的边的总重之差的最小值。特别地，**单个点作为树的不平衡度为 $0$**；空边集内边的总重为 $0$。

## 说明/提示

**【数据范围】**

**不捆绑测试**，同一 $\text{Subtask}$ 内每个测试点等分。

$$
%\def\or{\operatorname{or}}
%这 arraystretch 咋老是拼错/oh
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask}&\sum n\leqslant&k=&\textbf{Special Constraints}&\textbf{Score}\cr\hline
\sf1&2\times10^5&1&\bf A&1\cr\hline
\sf2&20&1&T=1&5\cr\hline
\sf3&5000&1&&5\cr\hline
\sf4&10^5&2&\bf B&15\cr\hline
\sf5&3\times10^5&1&&30\cr\hline
\sf6&2\times10^5&2&\bf A'&4\cr\hline
\sf7&3\times10^5&2&&40\cr\hline
\end{array}
$$
- 特殊性质 $\bf A$ ~~限宽 2.6m~~：保证每棵树只有一个叶子节点（$n\geqslant2$）。
- 特殊性质 $\bf B$ ~~限高 4.5m~~：保证每棵树都为菊花图（根节点有 $n-1$ 个儿子）。
- 特殊性质 $\bf A'$：保证每棵树都是链（每个节点的度数不超过 $2$）。

关于 $\bf A$ 和 $\bf A'$ 的区别：$\bf A'$ 中有可能树的根的度数为 $2$，而 $\bf A$ 中根的度数显然为 $1$。

对于 $100\%$ 的数据，$T \leqslant 4000$，${\color{red}\textbf1}\leqslant n\leqslant 10^5$，$\sum n\leqslant 3\times10^5$，$1 \leqslant m_i \leqslant10^4$，$1\leqslant u, v\leqslant n$，$k\in\{1,2\}$。

---
叶子节点为没有儿子的节点，即除根节点以外在树中的度为 $1$ 的点。

样例输入中为方便阅读加上了空行，实际数据中没有空行。


**【样例 $\bm1-\bm1$ 解释】**


该树如下图所示，边权即边的重量。

![](https://cdn.luogu.com.cn/upload/image_hosting/h5t1mz7x.png)

最优解为选择 $1\to2\to7$ 作为分割路径，不平衡度为 ${\large\vert}(2+19+19)-7{\large\vert}=33$。

如果选择 $1\to2\to6$ 作为分割路径，那么两部分的边的总重之差为 ${\large\vert}(2+19)-(7+514){\large\vert}=500$，不为最小值。

$\color{transparent}\sout{不知道你们发现没有\begin{cases}114+2+19+19=154\\114+514+19+19=666\end{cases}}$

**【样例 $\bm1-\bm2$ 解释】**

该树如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/14a0rhpe.png)

最优解为选择 $1\to7$ 作为分割路径，不平衡度为 ${\large\vert}(4+8+3+6)-(1+7+5+10){\large\vert}=2$。

## 样例 #1

### 输入

```
2 1
7
3 3 2 2 114 4 7
3 5 19 6 19 7 514
0
0
0
0
0

11
5 2 4 3 9 8 1 9 7 11 10
0
3 4 8 5 3 7 2
0
1 6 6
0
0
0
1 10 5
0
0```

### 输出

```
33
2```

## 样例 #2

### 输入

```
2 2
7
3 3 2 2 114 4 7
3 5 19 6 19 7 514
0
0
0
0
0

11
5 2 4 3 9 8 1 9 7 11 10
0
3 4 8 5 3 7 2
0
1 6 6
0
0
0
1 10 5
0
0```

### 输出

```
33 38 0 0 0 0 0
2 0 6 0 0 0 0 0 0 0 0```

# AI分析结果



### 唯一算法分类
**DFS**

---

### 综合分析与结论
**核心思路**：通过 DFS 遍历树结构，在递归过程中维护分割路径的左右边权总和。对于每个叶子节点计算权重差的最小绝对值。  
**关键难点**：如何高效处理不同子树的分割情况，避免重复计算。  
**解决方案**：  
1. **k=1 情况**：单次 DFS 预处理所有叶子节点的左右边权前缀和，利用二分查找差值零点。  
2. **k=2 情况**：扩展 DFS 到每个子树，维护子树内叶子节点的前缀和范围，结合二分或启发式合并优化计算。  
**可视化设计**：  
- **动画展示**：DFS 遍历路径（红色高亮），递归回退时动态累加左右边权（蓝色/绿色数值更新）。  
- **像素风格**：根节点为 8-bit 像素方块，子树分支以不同颜色区分，访问顺序用闪光效果标记。  
- **音效触发**：叶子节点命中时播放“叮”声，二分查找切换路径时播放“咔哒”音效。  

---

### 题解清单（≥4星）
1. **y_kx_b（4星）**  
   - **亮点**：简洁的 DFS 实现，利用前向星存储树结构，代码可读性强。  
   - **代码片段**：递归累加 `w1`（左部分）和 `w2`（路径），叶子节点计算差值。  
   ```cpp
   void dfs(int u, int w2) {
       if (叶子节点) {
           ans = min(|总权重 - w2 - 2*w1|);
           return;
       }
       for (子节点 v) {
           dfs(v, w2 + 边权);
           w1 += 边权; // 回溯时累加左部分
       }
   }
   ```

2. **_EEA_（4星）**  
   - **亮点**：前缀和与二分结合，数学推导清晰。  
   - **关键点**：维护 `le[i]`（左累计）和 `sum[i]`（路径累计），差值单调性允许二分。  

3. **tokitsukaze（5星）**  
   - **亮点**：启发式合并 + 懒标记优化，处理通用树结构高效。  
   - **心得引用**：“合并时涉及整体加减，用懒标记避免重复更新。”  

---

### 最优思路提炼
1. **链式前向星遍历**：按输入顺序处理子树，无需显式排序。  
2. **前缀和差分**：全局权重减去路径和左右部分，直接计算差值。  
3. **懒标记优化**：启发式合并时，子树权值整体加减通过标记传递，避免逐个更新。  

---

### 同类型题与算法套路
- **通用树遍历**：适用于子树合并问题（如 CF1709E）。  
- **前缀和 + 二分**：用于单调性明显的差值最小化问题。  
- **启发式合并**：处理多子树信息合并的高效技巧。  

---

### 推荐题目
1. **P3379（最近公共祖先）** - 树遍历基础。  
2. **P3384（树链剖分）** - 子树与路径操作。  
3. **CF1092F（树形DP与后缀和）** - 类似前缀和思想。  

---

### 可视化与复古游戏化设计
**实现要点**：  
1. **Canvas 绘制**：根节点为绿色方块，叶子节点为红色，访问路径黄色高亮。  
2. **自动演示模式**：DFS 递归过程自动播放，按空格暂停/继续。  
3. **音效设计**：  
   - `访问节点`：8-bit 短音。  
   - **找到最优解**：胜利音效（类似 FC 通关）。  
4. **积分系统**：每正确计算一个子树答案得 10 分，显示在右上角。  

**代码片段（JS 伪代码）**：  
```javascript
function drawNode(node, color) {
    ctx.fillStyle = color;
    ctx.fillRect(node.x, node.y, 20, 20); // 像素方块
}
function playSound(effect) {
    const sfx = new Audio(`sfx/${effect}.wav`);
    sfx.play(); // 触发音效
}
```

---

### 个人心得摘录
- **y_kx_b**：“前向星加边顺序不影响结果，但需注意遍历方向。”  
- **tokitsukaze**：“80分暴力向上爬链会超时，必须换用启发式合并。”  
- **_edge**：“合并 set 时处理懒标记，避免逐个元素修改，复杂度骤降。”  

---

**总结**：本题核心为 DFS 遍历与子树信息高效维护，结合数学优化或数据结构技巧解决。不同子任务对应不同策略，通用解法需灵活运用树形 DP 或合并技术。

---
处理用时：68.37秒
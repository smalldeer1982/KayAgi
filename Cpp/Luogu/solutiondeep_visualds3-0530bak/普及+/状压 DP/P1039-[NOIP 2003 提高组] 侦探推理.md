# 题目信息

# [NOIP 2003 提高组] 侦探推理

## 题目描述

明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：

$$
\def\arraystretch{1.5}
\begin{array}{|l|l|}\hline
\textbf{\textsf{证词内容}} & \textbf{\textsf{证词含义}}\\\hline
\text{I am guilty.} & \text{我是罪犯。} \\\hline
\text{I am not guilty.} & \text{我不是罪犯。} \\\hline
\text{{\tt XXX} is guilty.} & \text{{\tt XXX} 是罪犯。其中 {\tt XXX} 表示某个同学的名字。} \\\hline
\text{{\tt XXX} is not guilty.} & \text{{\tt XXX} 不是罪犯。} \\\hline
\text{Today is {\tt XXX}.} &
\begin{aligned}
&\text{今天是 {\tt XXX}。其中 {\tt XXX} 表示某个星期的单词。}\\
&\text{星期只有可能是以下之一：}\\
&\texttt{Monday}, \texttt{Tuesday}, \texttt{Wednesday}, \texttt{Thursday}, \\
&\texttt{Friday}, \texttt{Saturday}, \texttt{Sunday}。
\end{aligned}
\\\hline
\end{array}$$

证词中出现的其他话，都不列入逻辑推理的内容。


明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。


现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！

## 说明/提示

对于 $100\%$ 数据，满足 $1\le M\le 20$，$0\le N\le M$，$1\le P\le 100$。

**【题目来源】**

NOIP 2003 提高组第二题

## 样例 #1

### 输入

```
3 1 5
MIKE
CHARLES
KATE
MIKE: I am guilty.
MIKE: Today is Sunday.
CHARLES: MIKE is guilty.
KATE: I am guilty.
KATE: How are you??
```

### 输出

```
MIKE
```

# AI分析结果



## 算法分类
**枚举模拟**

---

## 题解思路与解决难点

### 核心思路
通过双重枚举可能的**凶手**和**日期**，验证每个人的证词是否自洽（全真或全假），统计说谎人数是否满足条件。若存在多个合法凶手则输出 `Cannot Determine`，无合法解则输出 `Impossible`。

### 关键步骤
1. **输入处理**：分离人名与证词，过滤无效证词。
2. **双重枚举**：外层枚举凶手，内层枚举日期。
3. **证词验证**：
   - 遍历每个人的所有证词，判断是否符合当前枚举的凶手与日期。
   - 若同一人的证词存在矛盾（既说真话又说假话），则当前枚举组合无效。
4. **说谎人数统计**：统计确定说谎人数，结合未说话者的不确定性判断是否满足条件。

### 解决难点
- **证词多样性处理**：需处理“自述罪状”、“指控他人”、“日期声明”三类证词。
- **状态一致性**：确保每个人在所有证词中的真/假状态一致。
- **未说话者处理**：允许他们在说谎人数统计中灵活调整，扩大合法范围。

---

## 题解评分（≥4星）

1. **wjyyy (⭐⭐⭐⭐⭐)**
   - **亮点**：使用 `vector` 结构化存储证词，`map` 处理人名映射，逻辑清晰。
   - **代码可读性**：模块化处理证词类型，注释详细。

2. **Lovelace_qwq (⭐⭐⭐⭐)**
   - **亮点**：详细注释与模块化验证函数，适合理解。
   - **调试提示**：强调输入处理中的换行符问题。

3. **Sanust (⭐⭐⭐⭐)**
   - **亮点**：鲁棒的输入处理与状态标记，兼容数据格式问题。
   - **优化**：快速剪枝矛盾情况，减少无效枚举。

---

## 最优思路提炼

### 关键技巧
1. **双重枚举**：凶手与日期的组合覆盖所有可能解。
2. **状态标记法**：用 `fake` 数组标记每个人的说谎状态，快速判断矛盾。
3. **范围统计**：结合确定说谎人数与未说话者的可能贡献，验证合法性。

### 代码片段
```cpp
// 示例：验证当前凶手与日期组合的合法性
bool check(int who, int now) {
    memset(fake, -1, sizeof fake); // -1 表示未确定
    for (int i = 1; i <= m; i++) {
        for (auto it : proof[i]) {
            // 根据证词类型更新说谎状态
            if (it.type == SELF_GUILTY) {
                bool truth = (who == i);
                if (fake[i] != -1 && fake[i] != !truth) return false;
                fake[i] = !truth;
            }
            // 其他证词类型类似处理...
        }
    }
    int cnt = 0, maybe = 0;
    for (int i = 1; i <= m; i++) {
        if (fake[i] == 1) cnt++;
        else if (fake[i] == -1) maybe++;
    }
    return (cnt <= n && cnt + maybe >= n);
}
```

---

## 类似题目推荐
1. **P1038 神经网络**：逻辑判断与状态传递。
2. **P1005 矩阵取数游戏**：枚举决策与状态模拟。
3. **P1027 Car的旅行路线**：多条件枚举与最优解验证。

---

## 可视化设计

### 动画方案
- **像素风格界面**：用 8-bit 网格展示枚举的凶手与日期组合。
- **高亮与音效**：
  - **当前枚举项**：黄色边框闪烁。
  - **证词验证**：绿色（真）或红色（假）闪烁，伴随 8-bit 音效。
  - **矛盾提示**：错误时播放低沉音效，正确时上扬音效。

### 交互功能
- **步进控制**：手动切换枚举项，观察证词验证过程。
- **自动演示**：AI 按顺序遍历组合，显示合法解。
- **统计面板**：实时显示说谎人数与未确定人数。

### 实现示例（伪代码）
```javascript
// Canvas 绘制当前枚举状态
function drawGrid(凶手, 日期) {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, width, height);
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < 7; j++) {
            if (i === 当前凶手 && j === 当前日期) {
                ctx.fillStyle = 'yellow'; // 高亮当前项
            } else {
                ctx.fillStyle = 'gray';
            }
            ctx.fillRect(i * 30, j * 30, 25, 25);
        }
    }
}
```

---

## 个人心得摘录
- **输入处理教训**：`getline` 需注意换行符，否则导致证词截断错误。
- **调试技巧**：输出中间变量（如证词解析结果）快速定位逻辑漏洞。
- **优化顿悟**：未说话者不影响真/假状态，仅影响统计范围，减少无效计算。

---

**可视化与算法演示**  
通过交互式像素动画，直观展示枚举过程与证词验证逻辑，结合音效增强学习体验，帮助理解复杂条件判断与统计逻辑。

---
处理用时：108.93秒
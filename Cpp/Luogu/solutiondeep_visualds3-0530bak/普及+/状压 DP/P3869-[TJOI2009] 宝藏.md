# 题目信息

# [TJOI2009] 宝藏

## 题目描述

为了寻找传说中的宝藏，小明走进了一个迷宫，我们用一个 $r$ 行 $c$ 列的矩阵来描述这个迷宫，矩阵的每个位置表示一个方块区域：

- 字符 `.` 表示可以通过的方格。
- 字符 `#` 表示不能通过的方格。
- 在迷宫中有 $k$ 个机关，第 $i$ 个机关工作方式为：  
  - 每当小明走上第 $r_i$ 行，$c_i$ 列的格子时，位于第 $R_i$ 行，$C_i$ 列的格子改变状态（如果这个格子此时可以通过，此后就变为不能通过；如果此时不能通过，此后可以通过。最左上角的格子是第 $1$ 行第 $1$ 列）。

现给出当前小明的位置，宝藏的位置，迷宫中每个格子的状态，以及所有机关的描述，问小明至少还要走多少步才能拿到宝藏（不能走出迷宫的边界，在开始时刻，小明和宝藏所在的位置都是可以通过的，机关不会出现在起点和终点，也不会影响这两个格子）。


## 说明/提示

### 数据范围及约定

对于全部数据，$5 \le r, c \le 30$，$0 \le k \le 10$，$1 \le r_i,R_i\le r$，$1 \le c_i,C_i \le c$。


## 样例 #1

### 输入

```
5 5
S.#..
#####
..#..
##.#.
...#T
6
1 5 4 2
1 4 3 3
5 1 3 3
1 4 4 5
1 2 1 3
1 5 2 1
```

### 输出

```
22```

# AI分析结果



---

## 算法分类  
**广度优先搜索（BFS） + 状态压缩**

---

## 题解思路与核心难点  

### 核心思路  
1. **状态压缩**：将机关的触发次数奇偶性压缩为二进制整数（如 `k=10` 时用 10 位二进制数表示状态）。  
2. **BFS扩展**：每个状态包含坐标 `(x,y)`、步数 `step` 和机关状态 `state`，用三维数组 `vis[x][y][state]` 避免重复访问。  
3. **动态地图判断**：每次移动时，根据当前 `state` 计算目标格子是否可通过（需考虑初始地图和所有相关机关的奇数次触发）。  

### 解决难点  
1. **机关与地图的联动**：  
   - 触发机关时更新 `state`（异或操作），影响后续路径。  
   - 动态计算格子可通行性：遍历所有机关，若目标格子被某机关影响且其对应的二进制位为 `1`，则翻转通行状态。  
2. **状态爆炸控制**：通过 `30x30x1024` 的 `vis` 数组限制状态数，确保时间复杂度可接受。  

---

## 题解评分（≥4星）  

### 1. lenlen（⭐⭐⭐⭐⭐）  
- **亮点**：代码简洁高效，直接遍历所有机关处理触发和通行性判断，异或运算优化状态更新。  
- **关键代码**：  
  ```cpp
  for(int j=1;j<=N;j++) {
      if(xx==t[j].x&&yy==t[j].y&&((tmp.k>>j-1)&1)) flag^=1;
      if(xx==t[j].a&&yy==t[j].b) kk^=(1<<j-1);
  }
  ```

### 2. unsigned_short_int（⭐⭐⭐⭐）  
- **亮点**：模块化设计，分离 `check` 和 `newStat` 函数，逻辑清晰。  
- **关键代码**：  
  ```cpp
  bool check(int x, int st) {
      bool ret = a[x][y];
      for(int i=1; i<=k; i++) 
          ret ^= (st & (1<<(i-1)));
      return ret;
  }
  ```

### 3. wfc284（⭐⭐⭐⭐）  
- **亮点**：显式处理机关触发与影响的分离，代码注释详细。  
- **关键代码**：  
  ```cpp
  for(int j=0; j<k; j++) {
      if(tx==r[j] && ty==c[j]) s ^= 1<<j;
      if(tx==R[j] && ty==C[j] && (s>>j&1)) ok ^= 1;
  }
  ```

---

## 最优思路提炼  
1. **状态压缩**：用 `state` 的二进制位表示每个机关是否被触发奇数次。  
2. **异或优化**：通过 `state ^= (1<<i)` 快速切换机关状态。  
3. **动态通行判断**：遍历所有机关，根据 `state` 计算目标格子的最终通行状态。  

---

## 类似题目推荐  
1. **P4011 孤岛营救问题**：钥匙与门的动态状态处理。  
2. **P2622 关灯问题II**：状态压缩 + BFS。  
3. **P4569 [BJWC2011]禁忌**：多状态转移的 BFS 应用。  

---

## 可视化与算法演示  

### 动画设计  
1. **网格绘制**：  
   - **颜色标记**：绿色为起点，红色为终点，灰色为障碍，蓝色为触发机关。  
   - **动态更新**：被机关影响的格子颜色闪烁（如黄→灰交替）。  
2. **状态显示**：  
   - 右侧显示当前 `state` 的二进制位，高亮变化的位。  
   - 队列可视化：展示 BFS 队列的实时扩展过程。  
3. **复古风格**：  
   - **像素音效**：移动时播放 8-bit 脚步声，触发机关时播放电子音效。  
   - **自动演示**：模拟 BFS 的“AI探索”，用箭头表示移动方向，机关触发时显示爆炸特效。  

### 代码片段（Canvas绘制）  
```javascript
// 绘制迷宫网格
function drawGrid(ctx, grid) {
    for (let i = 0; i < ROWS; i++) {
        for (let j = 0; j < COLS; j++) {
            ctx.fillStyle = getColor(grid[i][j], state);
            ctx.fillRect(j*CELL_SIZE, i*CELL_SIZE, CELL_SIZE-1, CELL_SIZE-1);
        }
    }
}
```

---

## 个人心得摘录  
> “**lenlen**的题解提醒我注意起点和终点可能不在固定位置，避免低级错误。”  
> “**iiiiiyang**的调试经历：一个格子可能同时是触发点和被影响点，需要特别处理。”  

---

## 核心代码实现（lenlen版）  
```cpp
struct len { int x, y, dep, k; };
queue<len> q;
bool vis[32][32][1<<12];

while (!q.empty()) {
    tmp = q.front(); q.pop();
    if (到达终点) return tmp.dep;
    for (4方向) {
        int xx = tmp.x + dx[i], yy = tmp.y + dy[i];
        if (越界) continue;
        int flag = 初始通行状态;
        int kk = tmp.k;
        // 更新机关影响的通行性
        for (每个机关j) {
            if (目标格子被j影响) flag ^= (tmp.k的第j位);
            if (当前位置是触发点j) kk ^= (1<<j-1);
        }
        if (flag && !vis[xx][yy][kk]) {
            vis[xx][yy][kk] = true;
            q.push({xx, yy, tmp.dep+1, kk});
        }
    }
}
```

---
处理用时：97.72秒
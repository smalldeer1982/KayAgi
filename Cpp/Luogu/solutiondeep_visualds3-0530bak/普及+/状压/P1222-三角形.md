# 题目信息

# 三角形

## 题目描述

给出平面上的 $n$ 个等腰直角三角形。每个三角形用三个整数 $x,y,m$ 描述。一个三角形的三个顶点分别是 $(x,y),(x+m,y),(x,y+m)$。

你的任务是计算这些三角形覆盖的总面积。

## 说明/提示

样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/5ti25vl7.png)

数据范围：$1\le n \le 2000$，$1 \le i \le n$，$-10^7 \le x_i,y_i \le 10^7$，$1\leq m_i \le 1000$。

## 样例 #1

### 输入

```
5
-5 -3 6
-1 -2 3
0 0 2
-2 2 1
-4 -1 2
```

### 输出

```
24.5```

# AI分析结果



### 唯一算法分类
**扫描线算法**

---

### 题解思路与核心难点
#### 核心思路
所有题解的核心目标均为解决**等腰直角三角形覆盖面积**问题，主要分为两类思路：
1. **扫描线算法**：纵向离散化关键事件点（三角形底边、顶点、斜边交叉点），横向维护覆盖区间，通过梯形面积累加。
2. **自适应辛普森积分**：将问题转换为分段积分，用数值方法近似计算覆盖区间。

#### 解决难点
- **扫描线**：处理斜边与其他边的交点（需额外离散化事件点），维护动态区间合并。
- **辛普森积分**：避免精度误差导致漏算（需手动分割关键区间，如三角形边界）。
- **暴力枚举**：判断重叠区域的复杂度高，需优化几何包含关系。

---

### 题解评分（≥4星）
1. **ZhYic（5星）**
   - **亮点**：完整实现扫描线+事件点离散化，解决斜边交叉问题。
   - **代码**：通过差分数组和区间合并动态计算覆盖长度。
2. **辰星凌（5星）**
   - **亮点**：结合辛普森积分与关键区间分割，处理包含关系。
   - **代码**：预处理三角形包含关系，避免重复积分。
3. **Edgration（4星）**
   - **亮点**：简洁的自适应辛普森实现，适合快速解题。
   - **代码**：通过分段积分避免漏算，优化精度控制。

---

### 最优思路提炼
1. **离散化关键事件点**（扫描线）：
   - 纵向离散化所有三角形的底边、顶点及斜边交叉点。
   - 横向维护覆盖区间的差分数组，合并重叠区间。
2. **动态区间维护**：
   - 使用`vector`或线段树维护当前覆盖的区间，按左端点排序后合并。
3. **辛普森积分优化**：
   - 预处理三角形包含关系，仅保留最外层三角形。
   - 积分时分割区间到三角形边界，避免漏算。

---

### 同类型题推荐
1. **P5490【模板】扫描线**（矩形面积并）
2. **P1884 覆盖的面积**（线段树+扫描线）
3. **P3219【HNOI2012】三角形覆盖问题**（同类问题扩展）

---

### 个人心得摘录
- **ZhYic**：调试时发现斜边交叉导致扫描线间面积计算错误，需额外离散化交点。
- **辰星凌**：辛普森积分在几何覆盖中需手动分割关键区间，否则误差极大。
- **FlierKing**：暴力枚举需判断三角形包含关系，否则复杂度爆炸。

---

### 可视化设计
#### 动画方案（扫描线）
1. **像素风格渲染**：
   - **背景网格**：8位灰色网格，坐标轴标尺。
   - **三角形**：不同颜色填充（如红、蓝、绿），半透明叠加显示覆盖区域。
2. **扫描线动态移动**：
   - **当前线**：黄色横线，标出离散化后的纵坐标`y`。
   - **覆盖区间**：高亮蓝色线段，实时显示合并后的区间长度。
3. **事件点标记**：
   - **底边/顶点**：红色圆点，触发区间增删。
   - **斜边交点**：紫色闪烁方块，动态添加新事件点。
4. **音效交互**：
   - **区间合并**：短促“滴”声。
   - **事件触发**：复古8位音效（如《超级玛丽》金币声）。

#### 代码片段（扫描线核心逻辑）
```cpp
// 离散化纵坐标并排序
vector<int> ys;
for (auto &tri : triangles) {
    ys.push_back(tri.y);
    ys.push_back(tri.y + tri.m);
}
sort(ys.begin(), ys.end());
ys.erase(unique(ys.begin(), ys.end()), ys.end());

// 处理每个扫描线区间
double ans = 0, last_len = 0;
for (int i = 1; i < ys.size(); ++i) {
    int y = ys[i];
    // 计算当前覆盖区间
    vector<pair<int, int>> segs;
    for (auto &tri : active_tris) {
        if (tri.y <= y && y <= tri.y + tri.m) {
            int l = tri.x;
            int r = tri.x + (tri.m - (y - tri.y));
            segs.emplace_back(l, r);
        }
    }
    // 合并区间并累加面积
    merge(segs);
    double curr_len = total_length(segs);
    ans += (last_len + curr_len) * (y - ys[i-1]) / 2;
    last_len = curr_len;
}
```

---

### 结论
- **扫描线**是本题的最优解，需注意斜边交点的离散化。
- **辛普森积分**适合快速实现，但需精细控制精度。
- **暴力方法**仅在小数据下可行，需结合包含关系剪枝。

---
处理用时：61.19秒
# 题目信息

# [TJOI2009] 宝藏

## 题目描述

为了寻找传说中的宝藏，小明走进了一个迷宫，我们用一个 $r$ 行 $c$ 列的矩阵来描述这个迷宫，矩阵的每个位置表示一个方块区域：

- 字符 `.` 表示可以通过的方格。
- 字符 `#` 表示不能通过的方格。
- 在迷宫中有 $k$ 个机关，第 $i$ 个机关工作方式为：  
  - 每当小明走上第 $r_i$ 行，$c_i$ 列的格子时，位于第 $R_i$ 行，$C_i$ 列的格子改变状态（如果这个格子此时可以通过，此后就变为不能通过；如果此时不能通过，此后可以通过。最左上角的格子是第 $1$ 行第 $1$ 列）。

现给出当前小明的位置，宝藏的位置，迷宫中每个格子的状态，以及所有机关的描述，问小明至少还要走多少步才能拿到宝藏（不能走出迷宫的边界，在开始时刻，小明和宝藏所在的位置都是可以通过的，机关不会出现在起点和终点，也不会影响这两个格子）。


## 说明/提示

### 数据范围及约定

对于全部数据，$5 \le r, c \le 30$，$0 \le k \le 10$，$1 \le r_i,R_i\le r$，$1 \le c_i,C_i \le c$。


## 样例 #1

### 输入

```
5 5
S.#..
#####
..#..
##.#.
...#T
6
1 5 4 2
1 4 3 3
5 1 3 3
1 4 4 5
1 2 1 3
1 5 2 1
```

### 输出

```
22```

# AI分析结果



### 唯一算法分类
**状态压缩 BFS**

---

### 综合分析与结论
#### 核心思路
所有题解均采用 **BFS + 状态压缩** 的框架，核心要点包括：
1. **状态表示**：用二进制数（最多 $2^{10}=1024$ 种状态）记录每个机关被触发奇数次（1）或偶数次（0）
2. **状态转移**：每次移动后，检查当前格子是否为机关触发点，若是则更新状态
3. **通行判定**：根据当前机关状态动态计算目标格子是否可通行

#### 难点对比
| 难点描述 | lenlen 解法 | lupengheyyds 解法 | 其他解法差异 |
|---------|------------|-------------------|-------------|
| 机关触发逻辑 | 移动后遍历所有机关计算状态 | 预处理机关关系表 | 部分题解拆分触发机关和受控机关的遍历 |
| 通行状态计算 | 异或原始状态与机关影响 | 分三种情况（普通/触发/受控）处理 | 部分题解将原始地图与机关影响分开存储 |
| 记忆化方式 | 三维数组 `vis[x][y][k]` | 动态维护 bitset 集合 | 个别题解尝试二进制压缩地图导致 MLE |

#### 可视化设计
1. **动画演示**：网格地图中，当前坐标用红色闪烁，已访问状态用半透明覆盖，机关触发状态用二进制浮窗显示
2. **关键高亮**：
   - 移动时：蓝色箭头指示方向，绿色路径显示步数
   - 机关触发：黄色闪烁触发点，紫色闪烁被修改的格子
3. **复古风格**：使用 16 色像素风格，机关状态用 8-bit 音效（触发时播放 "哔" 声，到达终点播放胜利旋律）

---

### 题解评分 (≥4星)
1. **lenlen（★★★★☆）**
   - 亮点：最简洁的位运算实现，`flag ^= 1` 处理通行状态
   - 代码片段：
     ```cpp
     int flag = (mp[xx][yy] == '#') ? 0 : 1;
     for(int j=1; j<=N; j++) {
         if(xx==t[j].x && yy==t[j].y && ((tmp.k>>j-1)&1)) 
             flag ^= 1;
     }
     ```
   
2. **wfc284（★★★★☆）**
   - 亮点：分离机关触发与状态计算的逻辑
   - 心得摘录："注意第一次遇到终点就得停下，不然继续走会增加额外的步数"

3. **unsigned_short_int（★★★★☆）**
   - 亮点：使用结构体封装状态，独立函数处理状态转换
   - 优化点：`newStat()` 和 `check()` 函数解耦核心逻辑

---

### 最优思路提炼
**核心技巧**：
1. **双异或法则**：
   - 触发机关时用 `kk ^= (1<<j-1)` 翻转状态
   - 判断通行时用 `flag ^= ((tmp.k>>j-1)&1)` 累计影响
2. **三维记忆化**：`vis[x][y][k]` 确保同一位置不同机关状态不被重复访问
3. **即时计算模式**：在移动时动态计算目标格子的可通行性，而非预处理所有可能状态

---

### 同类题目推荐
1. [P4011 孤岛营救问题](https://www.luogu.com.cn/problem/P4011)  
   （钥匙状态压缩 + 分层 BFS）
2. [P2622 关灯问题II](https://www.luogu.com.cn/problem/P2622)  
   （状态压缩 + BFS 求最小步数）
3. [P1941 飞扬的小鸟](https://www.luogu.com.cn/problem/P1941)  
   （动态状态维护 + 记忆化搜索）

---

### 核心代码实现
以 lenlen 的解法为例，关键循环逻辑：
```cpp
while (!q.empty()) {
    tmp = q.front(); q.pop();
    if(mp[tmp.x][tmp.y] == 'T') return cout<<tmp.dep,0;
    
    for(int i=0; i<4; i++) {
        int xx=tmp.x+dx[i], yy=tmp.y+dy[i];
        if(xx<1 || xx>n || yy<1 || yy>m) continue;
        
        // 计算当前格子是否可通行
        int flag = (mp[xx][yy] == '#') ? 0 : 1;
        int kk = tmp.k;
        for(int j=1; j<=N; j++) {
            // 受机关影响的格子状态翻转
            if(xx==t[j].x && yy==t[j].y && ((tmp.k>>j-1)&1)) 
                flag ^= 1;
            // 触发新的机关
            if(xx==t[j].a && yy==t[j].b) 
                kk ^= (1<<(j-1));
        }
        
        if(flag && !vis[xx][yy][kk]) {
            vis[xx][yy][kk] = true;
            q.push({xx, yy, tmp.dep+1, kk});
        }
    }
}
```

---

### 可视化算法演示
**8-bit 风格演示方案**：
```html
<canvas id="grid"></canvas>
<script>
// 初始化 30x30 像素网格
const CELL_SIZE = 16;
const ctx = document.getElementById('grid').getContext('2d');

// 机关状态显示
function drawSwitchState(k) {
    ctx.fillStyle = '#000';
    ctx.fillRect(320, 0, 128, 128);
    for(let i=0; i<10; i++) {
        ctx.fillStyle = (k & (1<<i)) ? '#FF0' : '#0F0';
        ctx.fillRect(320 + (i%5)*24, 20 + Math.floor(i/5)*24, 16, 16);
    }
}

// 移动动画
function animateMove(x, y, k) {
    // 清空上一帧
    ctx.clearRect(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
    // 绘制当前状态...
}
</script>
```
- **音效设计**：使用 [jsfxr](https://sfxr.me/) 生成 8-bit 音效，触发机关时播放 `0,,0.1,,0.2,0.3,,0.1` 的短促音效

---

### 个人心得摘录
来自 ii​​iiyang 的调试经验：
> "一个格子可能既操控机关，又被机关影响，测试时发现样例中 60 分都是因为没处理这种嵌套情况，最后将触发和受控分开遍历才通过"

来自 lupengheyyds 的优化教训：
> "最初尝试用 bitset 压缩整个地图导致 MLE，后来意识到只需压缩机关状态即可，节省了 90% 的内存空间"

---
处理用时：74.60秒
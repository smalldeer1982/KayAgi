# 题目信息

# [NOIP 2001 普及组] 最大公约数和最小公倍数问题

## 题目描述

输入两个正整数 $x_0, y_0$，求出满足下列条件的 $P, Q$ 的个数：

1. $P,Q$ 是正整数。

2. 要求 $P, Q$ 以 $x_0$ 为最大公约数，以 $y_0$ 为最小公倍数。

试求：满足条件的所有可能的 $P, Q$ 的个数。

## 说明/提示

$P,Q$ 有 $4$ 种：

1. $3, 60$。
2. $15, 12$。
3. $12, 15$。
4. $60, 3$。

对于 $100\%$ 的数据，$2 \le x_0, y_0 \le {10}^5$。

**【题目来源】**

NOIP 2001 普及组第二题

## 样例 #1

### 输入

```
3 60
```

### 输出

```
4
```

# AI分析结果



---

**算法分类**：数学（最大公约数/因数分解）

---

### 题解思路、算法要点与解决难点

**核心思路**：  
通过数学性质 $P \times Q = x_0 \times y_0$ 和 $\gcd(P,Q) = x_0$，将问题转化为枚举因数对，利用 $\sqrt{x_0 \times y_0}$ 优化枚举次数。  
**关键步骤**：  
1. 计算 $n = x_0 \times y_0$，枚举 $i$ 到 $\sqrt{n}$，检查 $i$ 是否为 $n$ 的因数。
2. 若 $i$ 是因数且 $\gcd(i, n/i) = x_0$，则累加答案（成对计数）。
3. 特判 $x_0 = y_0$ 的情况，避免重复计数。

**解决难点**：  
- **因数对的高效枚举**：通过 $\sqrt{n}$ 减少枚举次数至 $O(\sqrt{n})$。
- **数学性质的结合**：$\gcd$ 和 $\operatorname{lcm}$ 的乘积关系直接关联枚举条件。

---

### 题解评分 (≥4星)

1. **樱雪喵（5星）**  
   - 代码简洁高效，利用 `__gcd` 函数直接判断条件。
   - 数学推导清晰，正确处理了平方数和成对计数的边界问题。
2. **sochiji（4星）**  
   - 数学分析深入，通过质因数分解推导答案公式 $2^k$。
   - 需要处理质因数分解效率问题，但对本题数据范围有效。
3. **getchar_unlocked（4星）**  
   - 代码简洁，通过标志位处理平方数，逻辑清晰。
   - 使用 `__builtin_sqrt` 优化枚举速度。

---

### 最优思路或技巧提炼

**核心技巧**：  
- **乘积性质**：直接利用 $P \times Q = x_0 \times y_0$ 减少变量维度。
- **因数对枚举优化**：仅枚举到 $\sqrt{n}$，复杂度从 $O(n)$ 降至 $O(\sqrt{n})$。
- **边界处理**：通过初始值调整和特判解决 $x_0 = y_0$ 的重复计数问题。

---

### 同类型题或类似算法套路

**通用解法**：  
- **最大公约数与因数分解结合**：通过分解质因数或枚举因数对，结合 $\gcd$ 性质求解。
- **逆向思维**：将复杂条件转化为数学等式，降低问题维度。

**类似题目**：  
1. P1072 [NOIP2009 提高组] Hankson 的趣味题  
2. P1414 又是毕业季II  
3. P2651 添加括号III  

---

### 可视化与算法演示

**动画方案**：  
1. **网格绘制**：将 $x_0 \times y_0$ 的因数对以网格形式展示，高亮当前枚举的 $i$ 和 $n/i$。
2. **颜色标记**：  
   - 红色：当前枚举的 $i$。  
   - 绿色：符合条件的因数对。  
   - 灰色：不满足 $\gcd$ 条件的因数对。  
3. **步进控制**：单步展示每个因数对的检查过程，实时更新答案计数。  
4. **音效提示**：  
   - 清脆音效：找到符合条件的因数对。  
   - 错误音效：不满足条件的因数对。

---

### 代码实现（核心逻辑）

```cpp
#include<bits/stdc++.h>
using namespace std;
long long m, n, ans;

int main() {
    cin >> m >> n;
    if (m == n) ans--;
    n *= m; // 计算 x0*y0
    for (long long i = 1; i <= sqrt(n); i++) {
        if (n % i == 0 && __gcd(i, n / i) == m) ans += 2;
    }
    cout << ans;
    return 0;
}
```

**核心思想**：  
- 通过 `n *= m` 避免重复计算乘积，直接枚举因数对。
- 利用 `__gcd` 快速判断条件，时间复杂度 $O(\sqrt{n})$。

---

### 复古游戏化动画效果（伪代码）

```javascript
// Canvas 绘制网格与因数对
function drawGrid() {
    for (let i = 1; i <= sqrt(n); i++) {
        if (n % i === 0) {
            // 绘制 i 和 n/i 的位置
            if (gcd(i, n/i) === x0) {
                playSuccessSound();
                highlightPair(i, n/i);
            } else {
                playErrorSound();
            }
        }
    }
}

// 音效触发
function playSuccessSound() {
    // 8-bit 风格音效
}

// 自动演示模式
function autoPlay() {
    let i = 1;
    const timer = setInterval(() => {
        if (i > sqrt(n)) clearInterval(timer);
        checkCurrentFactor(i++);
    }, 500); // 控制速度
}
```

---

**总结**：通过数学性质优化枚举过程是本题最优解法的核心，结合因数对的高效枚举和边界处理，代码简洁高效。可视化设计中，网格与步进控制的结合能直观展示算法流程，复古音效增强交互趣味性。

---
处理用时：150.06秒
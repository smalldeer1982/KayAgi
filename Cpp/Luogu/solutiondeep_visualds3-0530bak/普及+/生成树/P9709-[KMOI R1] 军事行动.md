# 题目信息

# [KMOI R1] 军事行动

## 题目背景

$$\blue{他们来了。}$$

$$\purple{集结军队，干掉他们，一个不留。}$$

$$\blue{是！}$$

## 题目描述

喵星边境局势愈发紧张，导致发生边境冲突。喵星军队总司令小袁立即对 $Y$ 星采取军事行动。

整个宇宙可以看作一个平面直角坐标系，城市 $1,2,\dots,n$ 的坐标分别为 $(x_1,y_1),(x_2,y_2),\dots(x_n,y_n)$。

现在小袁率领的**若干支**舰队（可以理解为小袁的军事力量是无限的）驻扎在边境要塞，城市 $1$ 处。他的舰队会进行以下移动：

- 如果舰队的坐标为 $(x,y)$，那么一天之后它可以移动到 $(x-1,y+2)$ 或 $(x+1,y+2)$ 或 $(x+2,y+1)$ 或 $(x-2,y+1)$ 或 $(x-1,y-2)$ 或 $(x+1,y-2)$ 或 $(x+2,y-1)$ 或 $(x-2,y-1)$ 处。

其中环绕在外的还有一条小行星带，当舰队的坐标  $(x,y)$ 且 $x\le 0$ 或 $y\le 0$ 或 $m < x$ 或 $m < y$ 时，舰队就会撞到小行星带。这是小袁所不想看到的。

现在小袁要攻打城市 $2,3,\dots,n$，每一次他都会从一个**已经占领**的城市（城市 $1$ 也算），派出舰队前往城市 $i$ 并攻打它，舰队**到达之后的第二天**城市 $i$ 就被攻占了。

特别的，小袁在一个舰队**前往攻打或攻打一个城市**的时候不会派出另外一支舰队，在**攻占一座城市后当天**可以立即派出另外一支舰队。

小袁想问，最少要花多少时间才能攻占所有的城市。

**攻打顺序可以不按照 $2,3\dots n$ 的顺序。**

## 说明/提示

## 样例一解释：

舰队在第一天来到了 $(3,2)$ 的位置，第二天到达了城市 $2$ 的位置，第三天占领了城市 $2$。总共花了 $3$ 天。

## 样例二解释：

舰队在第一天到达了城市 $2$ 的位置，第二天占领了城市 $2$。第三天到达了城市 $3$ 的位置，第四天占领了城市 $3$。总共花了 $4$ 天。

## 数据范围

**本题采用 Subtask 捆绑测试。**

|子任务编号|  测试点编号| $n$ | $m$ |特殊性质|分值|
|:-----:| :----------: | :----------: | :----------: | :----------: |:---:|
|$1$| $1\sim2$ | $1\le n\le 7$ |$4\le m\le 7$|无|$10$|
|$2$| $3\sim7$ | $1\le n\le 200$ |$4\le m\le 70$|无|$25$|
|$3$| $8\sim9$ | $1\le n\le 150$ |$4\le m\le 150$|有|$15$|
|$4$| $10\sim20$ | $1\le n\le 2000$ |$4\le m\le 150$|无|$50$|

特殊性质：对于每一个 $1\le i\le n-1$，都有 $x_i = x_{i+1}$。

**数据严格保证不会有不同的城市拥有相同的坐标。**

## 样例 #1

### 输入

```
2 20
1 1
1 3```

### 输出

```
3```

## 样例 #2

### 输入

```
3 150
1 2
2 4
4 3```

### 输出

```
4```

## 样例 #3

### 输入

```
10 10
1 4
2 3
2 6
3 6
10 3
1 5
4 2
5 3
2 8
9 2```

### 输出

```
23```

## 样例 #4

### 输入

```
查看附件的 example4.in```

### 输出

```
查看附件的 example4.out```

# AI分析结果



### **唯一算法分类**
最小生成树

---

### **综合分析与结论**
题目核心在于将城市间的移动时间视为边权，通过最小生成树求总时间。  
**关键步骤**：  
1. **BFS预处理**：对每个城市进行广度优先搜索，计算到其他城市的最短移动天数。  
2. **构建完全图**：将所有城市间的移动时间作为边权，形成完全图。  
3. **最小生成树**：使用Kruskal或Prim算法求最小生成树，总和即为移动时间，加上n-1次攻占天数。  

**可视化设计**：  
- **网格动画**：展示BFS逐步扩散的过程，不同颜色标记已探索区域和当前探索层。  
- **生成树构建**：高亮当前加入生成树的边，动态显示合并过程。  
- **复古像素风格**：城市显示为8-bit像素块，移动路径用闪烁线条表示，音效提示边合并。  

---

### **题解清单 (≥4星)**
1. **Fire_flame (4星)**  
   - **亮点**：清晰的Kruskal实现，BFS预处理与并查集结合，代码结构清晰。  
   - **关键代码**：通过队列记录BFS步数，遇到其他城市时添加边。  

2. **Night_sea_64 (4星)**  
   - **亮点**：Prim算法优化完全图处理，BFS预处理直接记录最短路径。  
   - **关键代码**：动态更新每个城市到生成树的最小距离，避免排序所有边。  

3. **qzmoot (4星)**  
   - **亮点**：简洁的BFS实现，优先队列优化搜索过程，模拟实时松弛操作。  

---

### **最优思路与技巧提炼**
1. **BFS预处理优化**：  
   - 对每个城市独立运行BFS，记录到所有网格点的最短距离。  
   - 遇到其他城市时立即记录边权，避免重复计算。  

2. **完全图的最小生成树**：  
   - **Kruskal**：适用于边数较多但稀疏的场景，需排序所有边。  
   - **Prim**：适用于完全图，直接维护每个点到生成树的最小距离。  

3. **时间复杂度平衡**：  
   - BFS预处理为O(nm²)，Prim为O(n²)，整体O(nm² + n²)。  

---

### **同类型题与相似算法**
- **类似题目**：网络布线问题（如所有节点连通的最小线缆长度）。  
- **通用思路**：将物理位置关系转化为图论问题，用最短路径和生成树求解。  

---

### **推荐相似题目**
1. **P3366** 【模板】最小生成树  
2. **P2330** [SCOI2005] 繁忙的都市  
3. **P1991** 无线通讯网  

---

### **个人心得摘录**
- **Fire_flame**：注意BFS中遇到其他城市需立即记录边，否则可能遗漏最短路径。  
- **Night_sea_64**：完全图用Prim更高效，避免排序大量边。  
- **qzmoot**：优先队列实时松弛的BFS优化，类似Dijkstra思想。  

---

### **代码片段（核心逻辑）**
```cpp
// BFS预处理最短路径（Fire_flame）
void bfs(int sx, int sy) {
    queue<step> q;
    q.push({sx, sy, 0});
    memset(f, 0, sizeof(f));
    f[sx][sy] = 1;
    while (!q.empty()) {
        auto [tx, ty, tl] = q.front(); q.pop();
        for (int i = 0; i < 8; i++) {
            int px = tx + dx[i], py = ty + dy[i];
            if (px <= 0 || py <= 0 || px > m || py > m || f[px][py]) continue;
            if (mp[px][py]) // 遇到其他城市，记录边
                e[++cnt] = {mp[sx][sy], mp[px][py], tl + 1};
            f[px][py] = 1;
            q.push({px, py, tl + 1});
        }
    }
}
```

---

### **可视化设计要点**
1. **Canvas网格绘制**：  
   - 网格大小为m×m，城市用不同颜色方块标记。  
   - BFS扩散时，当前层用半透明色填充，扩散过程动画显示。  

2. **生成树动态构建**：  
   - 边合并时播放“连接”音效，高亮边和节点。  
   - 最终生成树用红色线条连接所有城市。  

3. **复古音效**：  
   - **移动音效**：每次BFS扩散时播放短促“滴”声。  
   - **攻占音效**：城市被加入生成树时播放8-bit胜利音效。  

4. **自动演示模式**：  
   - 按步骤自动执行BFS和生成树合并，速度可调。  
   - 显示当前累计时间和已攻占城市数。  

---

**可视化示例（伪代码）**  
```javascript
// 绘制BFS扩散（伪代码）
function drawBFS(start) {
    let queue = [start];
    while (queue.length) {
        let [x, y, step] = queue.shift();
        drawPixel(x, y, colorLayer[step % 4]); // 不同层不同颜色
        for (let dir of directions) {
            let nx = x + dir.dx, ny = y + dir.dy;
            if (valid(nx, ny) && !visited[nx][ny]) {
                visited[nx][ny] = true;
                queue.push([nx, ny, step + 1]);
            }
        }
    }
}
```

---
处理用时：105.18秒
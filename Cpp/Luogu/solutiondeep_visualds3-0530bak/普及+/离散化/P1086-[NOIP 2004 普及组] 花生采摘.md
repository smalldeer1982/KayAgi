# 题目信息

# [NOIP 2004 普及组] 花生采摘

## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。

**注意**：在采摘过程中不能回到路边。

## 说明/提示

noip2004普及组第2题


## 样例 #1

### 输入

```
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0```

### 输出

```
37```

## 样例 #2

### 输入

```
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```

### 输出

```
28```

# AI分析结果



# 算法分类：模拟+贪心

---

## 题解思路与难点分析

### 核心算法流程
1. **数据预处理**：将有花生的植株坐标和花生数存入结构体数组，按花生数从大到小排序。
2. **时间计算**：每次采摘时计算移动时间（曼哈顿距离）、采摘时间（1单位）和返回时间（当前行数）。
3. **决策逻辑**：若剩余时间足够完成移动+采摘+返回，则累加花生数；否则终止采摘。

### 解决难点
- **正确计算时间**：需注意第一次采摘的特殊性（从路边出发），以及每次移动后的剩余时间必须满足返回条件。
- **高效排序**：使用优先队列或结构体排序快速获取最大值，避免反复遍历数组。
- **边界条件**：处理无花生、时间不足采摘第一株等极端情况。

---

## 题解评分（≥4星）

### 1. jiangXxin（5星）
- **亮点**：结构体排序逻辑清晰，曼哈顿距离计算准确，注释详细。
- **代码可读性**：变量命名合理，循环逻辑简洁。
- **优化点**：无冗余操作，直接模拟题意。

### 2. qhr2023（4.5星）
- **亮点**：代码极简（仅15行），结构体排序与时间累加一气呵成。
- **代码可读性**：使用`abs(a[i-1].x-a[i].x)`直接计算移动时间，无额外变量。
- **优化点**：未显式处理首次采摘逻辑，但通过初始化`a[0]`巧妙规避。

### 3. _Arahc_（4星）
- **亮点**：使用优先队列和`map`避免显式排序，STL应用熟练。
- **优化点**：自动维护降序序列，减少代码量。
- **缺点**：需处理队列空指针异常，逻辑稍复杂。

---

## 最优思路提炼

### 关键技巧
1. **降序排序**：优先处理高价值花生点，贪心策略保证局部最优。
2. **曼哈顿距离**：两点间移动时间=行差绝对值+列差绝对值。
3. **时间验证公式**：总耗时=移动时间+1（采摘）+当前行数（返回），需≤剩余时间。

### 代码片段（qhr2023）
```cpp
sort(a+1, a+cnt+1, comp); // 按花生数降序排序
a[0] = {0, 0, a[1].y};   // 初始化起点
for (int i=1; i<=cnt; ++i) {
    sum += abs(a[i-1].x-a[i].x) + abs(a[i-1].y-a[i].y) + 1;
    if (sum + a[i].x <= k) ans += a[i].v;
    else break;
}
```

---

## 类似题目推荐
1. **P1090 合并果子**：贪心+优先队列，每次合并最小两堆。
2. **P1223 排队接水**：排序使平均等待时间最小。
3. **P1803 线段覆盖**：按右端点排序，选择不重叠的最大线段数。

---

## 算法可视化设计

### 动画方案
1. **像素风格田网格**：棕色网格表示花生田，绿色方块为植株，颜色深浅表示花生数。
2. **路径高亮**：红色路径显示当前移动路线，黄色闪烁表示采摘。
3. **时间条**：顶部进度条动态显示剩余时间，红色预警区提示临界状态。

### 交互功能
- **步进控制**：空格键单步执行，方向键调整速度。
- **音效提示**：采摘时播放“金币声”，超时播放“警报声”。
- **复古元素**：8-bit背景音乐，像素字体显示计数。

---

## 个人心得摘录
> "第一次以为要用BFS，发现无障碍后改用曼哈顿距离，节省了大量代码。" —— jiangXxin  
> "必须注意采摘时间+返回时间的双重验证，否则WA到怀疑人生。" —— _Arahc_

---

## 核心代码实现（qhr2023）
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node { int v, x, y; } a[425];
bool cmp(node a, node b) { return a.v > b.v; }
int main() {
    int n, m, k, cnt = 0, sum = 0, ans = 0;
    cin >> n >> m >> k;
    for (int i=1; i<=n; ++i) for (int j=1; j<=m; ++j) {
        int x; cin >> x;
        if (x > 0) a[++cnt] = {x, i, j};
    }
    sort(a+1, a+cnt+1, cmp);
    a[0] = {0, 0, a[1].y};
    for (int i=1; i<=cnt; ++i) {
        sum += abs(a[i-1].x - a[i].x) + abs(a[i-1].y - a[i].y) + 1;
        if (sum + a[i].x <= k) ans += a[i].v;
        else break;
    }
    cout << ans;
    return 0;
}
```

---
处理用时：68.45秒
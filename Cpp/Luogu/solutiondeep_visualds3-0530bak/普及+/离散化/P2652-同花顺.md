# 题目信息

# 同花顺

## 题目背景

所谓同花顺，就是指一些扑克牌，它们花色相同，并且数字连续。


## 题目描述

现在我手里有 $n$ 张扑克牌，但它们可能并不能凑成同花顺。我现在想知道，最少更换其中的多少张牌，我能让这 $n$ 张牌都凑成同花顺？

## 说明/提示

- 对于 $30\%$ 的数据，$n \le 10$；
- 对于 $60\%$ 的数据，$n \le 10^{5}$，$ 1 \le a_{i} \le 10^{5}$，$1 \le b_{i} \le n$；
- 对于 $100\%$ 的数据，$n \le 10^{5}$，$1 \le a_{i}, b_{i} \le 10^{9}$；

## 样例 #1

### 输入

```
5
1 1
1 2
1 3
1 4
1 5```

### 输出

```
0```

## 样例 #2

### 输入

```
5
1 9
1 10
2 11
2 12
2 13```

### 输出

```
2```

# AI分析结果



### 唯一算法分类  
**排序+贪心+滑动窗口**

---

### 综合分析与结论  
**核心思路**：  
1. **排序去重**：按花色和数字排序，去重同一花色下重复数字的牌。  
2. **滑动窗口**：对每个花色维护一个窗口，满足窗口内最大数字差 ≤n，此时窗口长度即为保留的牌数。  
3. **时间复杂度**：排序 O(n log n) + 滑动窗口 O(n)，总复杂度 O(n log n)。  

**解决难点**：  
- 重复牌处理：通过排序后相邻元素对比去重。  
- 高效找最长区间：滑动窗口避免双重循环的 O(n²) 复杂度。  

**可视化设计**：  
1. **动画流程**：  
   - 初始展示杂乱扑克牌 → 排序后按花色分组 → 去重重复牌 → 滑动窗口动态扩展/收缩。  
   - 高亮当前窗口的左右边界，标记窗口内最大数字差。  
2. **复古风格**：  
   - **像素画风**：用 8-bit 风格扑克牌，花色用不同颜色方块（如♠️黑色、♥️红色）。  
   - **音效设计**：窗口右移时播放“滴”声，找到新最长区间时播放“升级”音效。  
   - **自动演示**：AI 逐步移动窗口，显示当前窗口长度与最大值的对比。  

---

### 题解清单 (≥4星)  
1. **Tethys (5星)**  
   - **亮点**：使用队列维护滑动窗口，代码简洁高效。  
   - **关键代码**：  
     ```cpp  
     while(q.size() && b[i].y - q.front() >= n) q.pop();  
     q.push(b[i].y);  
     ans = max(ans, (int)q.size());  
     ```  
   - **心得**：“遇到不同花色清空队列”避免冗余判断。  

2. **Merak (4星)**  
   - **亮点**：双重循环暴力枚举，适合小数据理解算法本质。  
   - **关键代码**：  
     ```cpp  
     for(int j=i; j>=1 && 同花色 && 数字差≤n; j--)  
         temp++;  
     ```  
   - **心得**：“反向思考：最少更换 = 总数 - 最长保留”为解题关键。  

3. **joseph_cheung (4星)**  
   - **亮点**：利用 STL `unique` 去重，代码极简。  
   - **关键代码**：  
     ```cpp  
     int totCard = unique(p+1,p+n+1)-p-1;  
     while(当前数字 - 队首 ≥n) pop队首;  
     ```  

---

### 最优技巧提炼  
1. **去重优化**：排序后相邻对比，跳过相同花色和数字的牌。  
2. **窗口维护**：队列或双指针动态调整窗口，确保数字差 ≤n。  
3. **逆向思维**：求最长保留牌数代替直接求最小更换数。  

---

### 同类型题推荐  
1. **P3143 [USACO16OPEN] Diamond Collector**（滑动窗口求最大区间）  
2. **P1102 A-B 数对**（排序后双指针找差值）  
3. **P1638 逛画展**（滑动窗口求最短满足区间）  

---

### 核心代码实现  
**Tethys 队列滑动窗口法**：  
```cpp  
sort(a + 1, a + n + 1, cmp);  
for(int i=1; i<=cnt; i++){  
    if(b[i].x != b[i-1].x) cl(); // 清空队列  
    while(q.size() && b[i].y - q.front() >= n) q.pop();  
    q.push(b[i].y);  
    ans = max(ans, (int)q.size());  
}  
cout << n - ans;  
```  

---

### 复古像素动画代码片段  
```javascript  
// Canvas 绘制扑克牌  
function drawCard(x, y, color, num) {  
    ctx.fillStyle = COLORS[color];  
    ctx.fillRect(x, y, CARD_W, CARD_H);  
    ctx.fillStyle = "white";  
    ctx.fillText(num, x + 5, y + 15);  
}  

// 滑动窗口移动音效  
function playSwipeSound() {  
    const osc = audioCtx.createOscillator();  
    osc.frequency.setValueAtTime(500, audioCtx.currentTime);  
    osc.connect(audioCtx.destination);  
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);  
}  
```  

---

### 个人心得摘录  
> **Merak**：“同色牌中数值相同的牌必须筛除，否则会错误计算最长区间。”  
> **Tethys**：“队列清空时机是关键，切换花色时必须重新开始计数。”  
> **rui_er**：“二分法虽好，但滑动窗口更直观且无需处理复杂边界。”  

---

### 可视化演示截图  
![同花顺滑动窗口动画](https://via.placeholder.com/600x400/000000/FFFFFF?text=Pixel+滑动窗口+演示)  
- **左侧**：排序后扑克牌按花色分组，红色高亮当前窗口。  
- **右侧**：实时显示最大保留牌数 `ans` 和当前窗口长度。

---
处理用时：77.63秒
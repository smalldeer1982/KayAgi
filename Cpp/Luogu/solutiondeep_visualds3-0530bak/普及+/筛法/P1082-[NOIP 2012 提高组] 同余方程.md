# 题目信息

# [NOIP 2012 提高组] 同余方程

## 题目描述

求关于 $ x$ 的同余方程 $ a x \equiv 1 \pmod {b}$ 的最小正整数解。


## 说明/提示

### 数据规模与约定

- 对于 $40\%$ 的数据，$2 ≤b≤ 1,000$；
- 对于 $60\%$ 的数据，$2 ≤b≤ 50,000,000$；
- 对于 $100\%$ 的数据，$2 ≤a, b≤ 2,000,000,000$。



## 样例 #1

### 输入

```
3 10```

### 输出

```
7```

# AI分析结果



# 唯一算法分类  
**扩展欧几里得算法**

---

## 综合分析与结论  
### 核心算法流程
1. **问题转化**：将同余方程 $ax \equiv 1 \pmod{b}$ 转化为线性方程 $ax + by = 1$  
2. **递归求解**：通过扩展欧几里得算法递归求 $ax + by = \gcd(a,b)$ 的解  
3. **特解调整**：通过 $(x \bmod b + b) \bmod b$ 确保最小正整数解  

### 可视化设计思路
- **动画流程**：  
  ① 以像素方块动态展示递归层级变化  
  ② 高亮当前操作的系数 $(a,b)$ 和中间变量 $(x,y)$  
  ③ 回溯阶段用颜色区分变量更新过程（红→黄→绿）  
- **复古风格**：  
  使用 8-bit 音效标记递归进入（低音）和回溯（高音）阶段  
  用 16x16 网格展示欧几里得算法系数变化轨迹  

---

## 题解清单（≥4星）

### 1. 学委（5星）  
**亮点**：  
- 详细推导扩展欧几里得递归关系式  
- 清晰解释解的正负调整逻辑  
- 完整注释的代码实现  

**核心代码**：
```cpp
void exgcd(long long a, long long b) {
    if(b == 0) { x = 1; y = 7; return; }
    exgcd(b, a % b);
    long long tx = x;
    x = y;
    y = tx - a / b * y;
}
```

### 2. _Nova（4.5星）  
**亮点**：  
- 引入裴蜀定理数学证明  
- 提供通解公式推导  
- 代码包含边界条件处理  

**核心代码**：
```cpp
int exgcd(int a,int b,int &x,int &y){
    if(b == 0) { x=1; y=0; return a; }
    int d = exgcd(b, a%b, y, x);
    y -= a/b*x;
    return d;
}
```

### 3. 陈曦（4星）  
**亮点**：  
- 对比暴力/快速幂/扩展欧几里得三种方法  
- 提供逆元概念的实际应用示例  
- 代码简洁易移植  

---

## 最优思路与技巧提炼

### 关键技巧
1. **递归方向反转**：  
   在回溯时交换 $x$ 和 $y$ 变量，避免显式存储中间状态  
   ```cpp
   exgcd(b, a%b, y, x); // 参数顺序反转
   y -= a/b * x;        // 直接利用交换后的变量
   ```

2. **最小解公式**：  
   通过 $(x \% b + b) \% b$ 确保结果在 $[1,b)$ 范围内  

3. **终止条件优化**：  
   当 $b=0$ 时直接返回 $x=1$，无需额外计算  

---

## 同类型题与算法套路

### 通用解法
1. **线性同余方程**：$ax \equiv c \pmod{m}$ → 扩展欧几里得  
2. **逆元问题**：当模数为质数时可用费马小定理，否则用扩展欧几里得  

### 推荐题目
1. [P3811] 乘法逆元（模板题）  
2. [P1516] 青蛙的约会（线性同余方程应用）  
3. [P5656] 二元一次不定方程（扩展欧几里得进阶）  

---

## 可视化实现示例（JS伪代码）

```javascript
// 8-bit风格Canvas绘制
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

// 递归过程可视化
function drawStep(a, b, depth) {
    ctx.fillStyle = '#FF4444'; // 红色标记当前层
    ctx.fillRect(depth*32, 0, 32, 32);
    ctx.fillText(`${a},${b}`, depth*32 + 5, 20);
}

// 音效触发器
function playSound(freq) {
    const oscillator = audioCtx.createOscillator();
    oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
}

// 扩展欧几里得动画
function animatedExgcd(a, b, depth=0) {
    if(b === 0) {
        playSound(880); // 高音标记终止
        return {x:1, y:0};
    }
    playSound(440);     // 中音标记递归进入
    const prev = animatedExgcd(b, a%b, depth+1);
    [x, y] = [prev.y, prev.x - Math.floor(a/b)*prev.y];
    drawArrow(depth*32, 32*(depth+1)); // 绘制回溯箭头
    return {x, y};
}
```

---

## 调试心得摘录
- **学委**：发现当 $y$ 初始值设为7仍能AC，说明终止条件的 $y$ 值不影响最终结果  
- **沙普绿12138**：在分解质因数时未处理剩余因子导致WA，后添加 `if(n>1) ans *=n-1` 修正  
- **xxxalq**：调试时发现快速幂未取模导致数值溢出，添加 `%b` 后通过  

---

## 复古游戏化设计
### 视觉要素
- **调色板**：NES红（#E71E25）、NES蓝（#2196F3）、NES黄（#FFEB3B）  
- **角色设计**：像素小人在系数网格上跳跃执行算法步骤  

### 交互机制
- **连击系统**：每正确完成一个递归层级+10分，错误操作扣分  
- **BOSS战模式**：最终BOSS为"大质数恶魔"，需快速计算逆元击败  

### 音效方案
| 事件           | 音高 | 波形       |
|----------------|------|------------|
| 进入递归       | C4   | 方波       |
| 回溯更新变量   | E4   | 三角波     |
| 获得最小解     | G5   | 正弦波     |
| 游戏结束       | C2   | 噪声       |

---
处理用时：68.69秒
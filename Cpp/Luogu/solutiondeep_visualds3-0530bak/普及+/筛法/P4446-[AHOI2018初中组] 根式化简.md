# 题目信息

# [AHOI2018初中组] 根式化简

## 题目描述

小可可在学习“立方根”的知识时碰到这样的问题：

将下面根式化简为最简根式：

(1) $\sqrt[3]{125}$ (2) $\sqrt[3]{81}$ (3) $\sqrt[3]{52}$

这个问题对于小可可来说太简单了，他很快就算出了答案：

(1) $5$ (2) $3\sqrt[3]{3}$ (3) $\sqrt[3]{52}$

小可可知道任意形如 $\sqrt[3]{x}$ 的根式，化简后一定可以被写成形如 $a\sqrt[3]{b}$ 的最简根式。他觉得这很有趣，就仿照出了不少题，但没一会儿就被密密麻麻的根式绕晕了，于是他向你求助：

给定 $n$ 个形如 $\sqrt[3]{x}$ 的根式，请你将它们化简为形如 $a\sqrt[3]{b}$ 的最简形式，为了方便，你只需要输出其中的 $a$ 即可。

如果你没有学过这部分数学知识，你可以认为题意是：给你 $n$ 个正整数 $x$，对于每一个 $x$，你需要求出整数 $a,b$ 使得 $a^3 \times b = x$，输出最大的整数 $a$ 即可。

## 说明/提示

对于 $100\%$ 的数据满足：$1 \le n \le 10000$，$1 \le x \le 10^{18}$。

本题共 10 个测试点，编号为1 \~ 10，每个测试点额外保证如下：
 
1 \~ 2： $n \le 10, x \le 10^6$   
3 \~ 4： $n \le 10, x \le 10^9$  
5 \~ 6： $n \le 100, x \le 10^{18}$ 且 $x$ 为完全立方数  
7 \~ 8： $n \le 500, x \le 10^{18}$  
9 \~ 10： $n \le 10000, x \le 10^{18}$

## 样例 #1

### 输入

```
3
125 81 52```

### 输出

```
5
3
1```

# AI分析结果



## 唯一算法分类  
**数论（质因数分解与二分查找）**

---

## 综合分析与结论  
### 核心思路与难点  
1. **分解质因数**：预处理所有小于 $\sqrt[4]{10^{18}} \approx 31623$ 的质数，对每个 $x$ 分解这些质因数，统计每个质数的次数。每积累三次则乘入 $a$，剩余次数保留。  
2. **处理剩余部分**：分解后的剩余值 $x'$ 要么是 1、单个质数、或某质数的立方。通过二分法检查 $x'$ 是否为立方数，若成立则取其立方根乘入 $a$。  
3. **关键难点**：  
   - **高效分解大数**：仅分解到 $\sqrt[4]{x}$ 的质数，避免超时。  
   - **立方数验证**：通过预计算立方表或二分法快速判断剩余值是否为立方数。  

### 可视化设计  
1. **像素风格动画**：  
   - **质因数分解**：以像素方块表示质数，每次分解时方块闪烁并累加计数，三次后触发音效并入 $a$。  
   - **二分查找**：显示立方表数组，指针左右移动，命中时方块高亮并播放成功音效。  
2. **音效与交互**：  
   - **分解音效**：短促“滴”声，每分解一个质因数触发。  
   - **立方匹配音效**：上扬音调，匹配成功时播放。  
   - **控制面板**：可调节分解速度，单步执行观察质数处理流程。  

---

## 题解清单（≥4星）  
1. **hongzy（5星）**  
   - **亮点**：预处理质数与立方表，代码简洁高效，利用 `lower_bound` 快速判断剩余值是否为立方数。  
   - **关键代码**：  
     ```cpp  
     for (int i=1; i<=cnt && plist[i] <= x; i++) {  
         c = 0;  
         while (x % plist[i] == 0) {  
             c++; x /= plist[i];  
             if (c == 3) ans *= plist[i], c = 0;  
         }  
     }  
     LL k = lower_bound(pow3+1, pow3+m+1, x) - pow3;  
     ```  
2. **KesdiaelKen（4星）**  
   - **亮点**：分阶段优化思路清晰，详细讨论不同数据规模的处理策略，适合教学。  
3. **ziiidan（4星）**  
   - **亮点**：结合线性筛与二分法，强调预处理质数范围的重要性，代码可读性强。  

---

## 最优思路提炼  
1. **质数预处理**：筛出 $\sqrt[4]{x_{\text{max}}}$ 内的质数，减少分解次数。  
2. **三次因子提取**：分解时每积累三次质因数则乘入 $a$，剩余部分单独处理。  
3. **剩余值验证**：二分法快速判断剩余值是否为立方数，时间复杂度 $O(1)$。  

---

## 类似题目与算法  
- **质因数分解**：[P1075 质因数分解](https://www.luogu.com.cn/problem/P1075)  
- **立方数判断**：[P1874 快速求和](https://www.luogu.com.cn/problem/P1874)（需处理大数）  
- **数论优化**：[P2424 约数和](https://www.luogu.com.cn/problem/P2424)  

---

## 代码实现  
```cpp  
#include <iostream>  
#include <algorithm>  
using namespace std;  
typedef long long LL;  
const int MAX_P = 31650, MAX_CUBE = 1e6;  
int primes[4000], cnt;  
LL cube[MAX_CUBE + 10];  

void sieve() {  
    bool is_prime[MAX_P] = {};  
    for (int i=2; i<=MAX_P; i++) {  
        if (!is_prime[i]) primes[cnt++] = i;  
        for (int j=0; j<cnt && i*primes[j]<=MAX_P; j++) {  
            is_prime[i*primes[j]] = true;  
            if (i % primes[j] == 0) break;  
        }  
    }  
}  

int main() {  
    sieve();  
    for (LL i=1; i<=MAX_CUBE; i++) cube[i] = i*i*i;  
    int T; scanf("%d", &T);  
    while (T--) {  
        LL x, a=1; scanf("%lld", &x);  
        for (int i=0; i<cnt && primes[i] <= x; i++) {  
            int cnt_p = 0;  
            while (x % primes[i] == 0) {  
                cnt_p++, x /= primes[i];  
                if (cnt_p == 3) a *= primes[i], cnt_p = 0;  
            }  
        }  
        LL k = lower_bound(cube+1, cube+MAX_CUBE+1, x) - cube;  
        a *= (cube[k] == x) ? k : 1;  
        printf("%lld\n", a);  
    }  
    return 0;  
}  
```  

---

## 可视化代码（关键片段）  
```javascript  
// 伪代码：像素动画与音效  
function animateFactorization(prime) {  
    const block = document.createElement('div');  
    block.style.backgroundColor = getPrimeColor(prime);  
    block.classList.add('pixel-block');  
    document.body.appendChild(block);  
    // 触发分解动画与音效  
    playSound('分解音效');  
}  

function checkCube(x) {  
    let low = 1, high = 1e6;  
    while (low <= high) {  
        const mid = Math.floor((low + high) / 2);  
        highlightCubeBlock(mid); // 高亮当前二分位置  
        if (mid*mid*mid === x) {  
            playSound('成功音效');  
            return mid;  
        }  
        // 更新指针动画  
    }  
}  
```  

---

## 个人心得  
- **预处理范围**：筛质数到 $\sqrt[4]{x}$ 而非 $\sqrt[3]{x}$ 大幅减少计算量。  
- **二分优化**：预计算立方表后使用 `lower_bound` 避免重复计算，提升效率。  
- **边界条件**：需处理 $x=1$ 或质数立方未被完全分解的情况。

---
处理用时：76.59秒
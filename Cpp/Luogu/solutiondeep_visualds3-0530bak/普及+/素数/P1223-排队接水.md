# 题目信息

# 排队接水

## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。


## 说明/提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。


## 样例 #1

### 输入

```
10 
56 12 1 99 1000 234 33 55 99 812```

### 输出

```
3 2 7 8 1 4 9 6 10 5
291.90
```

# AI分析结果



# 排队接水问题分析与题解总结

## 算法分类
贪心算法（排序策略）

---

## 核心思路与解决难点
**核心思路**：  
所有题解均采用**排序策略**，按接水时间升序排列。通过数学证明（交换相邻元素的总时间对比）得出最优策略：让接水时间短的人先接水，减少后续等待人数的时间累积。

**关键难点**：  
1. **等待时间计算**：第i个接水的人会产生 (n-i) 次后续等待，总时间公式为 Σt[i]*(n-i)  
2. **序号保留**：排序后需要保留原序号用于输出  
3. **精度控制**：平均时间需保留2位小数，必须使用double类型  

**算法实现对比**：
| 方法               | 数据结构                     | 时间复杂度 | 亮点                         |
|--------------------|------------------------------|-----------|------------------------------|
| 结构体+sort        | 结构体数组                    | O(nlogn)  | 直观易读，便于扩展           |
| pair+动态内存      | pair数组                      | O(nlogn)  | 省内存，利用pair默认排序规则 |
| 数值编码法         | long long数组（t*1001+编号） | O(nlogn)  | 无需结构体，巧妙利用数值特性 |
| 冒泡排序+双重数组  | 两个平行数组                  | O(n²)     | 无库依赖，适合教学          |

---

## 高星题解推荐（≥4★）

### 1. 无乐鸦（5★）
**亮点**：  
- 严谨的数学推导证明排序策略  
- 省略代码直接阐述核心思想  
- 启发式教学引导读者自主思考  

**核心公式**：  
当相邻元素t_i < t_j时，交换位置后的总时间差为 (t_i + t_i + t_j) vs (t_j + t_j + t_i)，显然前者更小。

---

### 2. f112358（4.5★）
**亮点**：  
- 创新数值处理：t*1001 + 编号  
- 单次排序同时处理时间和编号  
- 代码简洁（17行核心逻辑）  

**关键代码**：
```cpp
t[i] = x*1001 + i;  // 编码
sum += t[j]/1001*(n-j);  // 解码计算
```

---

### 3. BlueArc（4★）
**亮点**：  
- 结构体清晰分离时间和编号  
- 反向遍历优化计算：总时间 = Σt[i]*(n-i)  
- 完整数学公式注释  

**计算优化**：
```cpp
for(j=n-1;j>=1;j--) {
    i = n-j;  // 自动生成权重系数
    time += a[i].b*j; 
}
```

---

## 最优思路提炼
1. **贪心排序**：按接水时间升序排列  
2. **权重计算**：每个元素的贡献值为 t[i]*(n-i)  
3. **编码技巧**：对需要保留的附加信息（如原编号）进行数值处理  
4. **空间优化**：使用pair代替结构体减少内存占用  

---

## 可视化设计（复古像素版）

### 算法演示流程
1. **初始化**：  
   - 16色像素风格，每个用户显示为不同颜色方块  
   - 顶部状态栏显示当前总等待时间和平均时间  

2. **排序阶段**：  
   ```plaintext
   [56] [12] [1] [99] ... → 选择最小1→交换到首位
   ```

3. **接水过程**：  
   - 高亮当前接水者，显示等待人数气泡  
   - 右侧公式实时更新：sum += t[i]*(剩余人数)  

4. **音效设计**：  
   - "滴答"声：每次时间累加  
   - "叮咚"声：完成一个人接水  
   - 8-bit背景音乐循环  

### 交互功能
- **速度调节**：0.5x~4x 动画速度  
- **单步调试**：空格键逐步执行  
- **数据视角**：F1切换数值/图形视图  

---

## 相似题目推荐
1. **P1090 合并果子** - 贪心+优先队列  
2. **P1106 删数问题** - 字典序贪心  
3. **P1233 木棍加工** - 双关键字排序  

---

## 核心代码实现
**结构体版本（最优可读性）**：
```cpp
struct Person {
    int time, id;
} p[1005];

bool cmp(Person a, Person b) {
    return a.time < b.time; 
}

// 计算总时间
double sum = 0;
sort(p, p+n, cmp);
for(int i=0; i<n; i++) {
    sum += p[i].time * (n-i-1);
    cout << p[i].id << " ";
}
printf("\n%.2f", sum/n);
```

---

## 总结与拓展
本题展现了**排序贪心**的经典应用场景。关键是要发现**局部最优能推导全局最优**的特性。在类似问题中（如任务调度、资源分配），可以优先尝试排序策略，并通过数学证明验证有效性。

---
处理用时：58.46秒
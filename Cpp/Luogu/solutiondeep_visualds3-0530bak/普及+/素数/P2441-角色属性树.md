# 题目信息

# 角色属性树

## 题目描述

绪萌同人社是一个有趣的组织，该组织结构是一个树形结构。有一个社长，直接下属一些副社长。每个副社长又直接下属一些部长……。

每个成员都有一个萌点的属性，萌点属性是由一些质数的萌元素乘积构成（例如，猫耳的值是 $2$，弱气的值是 $3$，黄毛的值是 $5$，病娇的值是 $7$，双马尾的值是 $11$ 等等）

举个例子，正妹是双份的猫耳，而且有一份弱气，她的属性值为 $2\times 2\times 3=12$。

现在组员关心一个问题，希望知道离自己最近且有相同萌元素上司是谁，例如，属性值为 $2、4、6、45$ 这样的属性值都算是和正妹有相同的属性。


然而，组员可能会随时变化自己的属性。啊。。感觉好麻烦啊。。


## 说明/提示

对于 $20\%$ 的数据，没有修改的操作。

对于 $50\%$ 的数据，$n\le 100$，修改次数 $<10$。

对于 $100\%$ 的数据，$n\le 200000$，$k<100000$，修改次数 $\le 50,a\_i\le 2^{31}-1$

UPD：本题测试数据随机，可能是假题。

## 样例 #1

### 输入

```
4 6

10 8 4 3

1 2

2 3

3 4

1 1

1 2

1 3

1 4

2 1 9

1 4```

### 输出

```
-1

1

2

-1

1```

# AI分析结果



## 唯一算法分类
树形结构的暴力遍历

---

## 综合分析与结论
### 核心思路与难点
**题目核心**：在树形结构中快速查询离当前节点最近的满足 gcd>1 的祖先节点。  
**核心解法**：  
1. **暴力遍历父链**：每次查询时从父节点开始逐层向上遍历，用 gcd 快速判断是否存在公共质因子。  
2. **利用数据随机性**：随机生成的树高期望较低（约 logn），暴力查询的平均时间复杂度可接受。  

**关键难点**：  
- 传统暴力法在极端数据（如链状树）下会退化为 O(n)，但题目测试数据随机使得暴力可行  
- 无需预处理质因数分解，直接利用 gcd 的数学性质快速判断  

### 可视化设计思路
**动画方案**：  
1. **像素化树结构**：用 8-bit 像素方块表示树节点，父节点在上方，子节点通过像素线条连接。  
2. **遍历高亮**：查询时当前遍历的节点闪烁黄色，已检查的节点渐变为灰色，找到匹配节点时触发绿色闪光。  
3. **音效系统**：  
   - 移动时播放 "哔" 声（类似 FC 马里奥跳跃音）  
   - 匹配成功时播放 "叮咚" 音效  
   - 无结果时播放低沉 "嗡" 声  

**交互设计**：  
- 侧边面板可拖拽调节遍历速度（1x~10x）  
- 支持单步执行：按空格键逐步跳转父节点  
- 自动演示模式：AI 随机选择节点进行查询，展示算法过程  

---

## 题解清单（≥4星）
1. **Zilljy258（⭐⭐⭐⭐⭐）**  
   - 代码最简：仅 25 行实现核心逻辑  
   - 使用内置 `__gcd` 函数提升可读性  
   - 注释清晰标注建树与查询流程  

2. **WZKQWQ（⭐⭐⭐⭐）**  
   - 关键亮点：详细分析数据随机性对暴力可行性的影响  
   - 邻接表建树更易扩展（虽本题未利用）  
   - 函数封装规范（`build`、`dfs` 分离）  

3. **tobie（⭐⭐⭐⭐）**  
   - 独立实现 `gcd` 函数，避免依赖 STL  
   - 循环替代递归，减少栈溢出风险  
   - 代码风格简洁（主函数仅 30 行）  

---

## 最优思路与代码实现
### 关键技巧
- **暴力 + 数学优化**：  
  ```cpp
  int query(int u) {
    for(int v=fa[u]; v; v=fa[v])  // 逐层上跳
      if(__gcd(a[u], a[v]) > 1)   // 内置gcd计算
        return v;
    return -1;
  }
  ```
- **时间复杂度**：单次查询期望 O(logn)，最坏 O(n)（但数据随机规避）  

### 完整代码（Zilljy258 题解）
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200001], fa[200001]; 

int dfs(int x, int y) {
    if(x == 0) return -1;
    if(__gcd(a[x], a[y]) > 1) return x;  
    return dfs(fa[x], y);
}

int main() {
    int n, k; cin >> n >> k;
    for(int i=1; i<=n; i++) cin >> a[i];
    for(int i=1; i<n; i++) {
        int x, y; cin >> x >> y;
        fa[y] = x;  // 父节点建树
    }
    while(k--) {
        int op, x; cin >> op >> x;
        if(op == 1) cout << dfs(fa[x], x) << endl;
        else { int y; cin >> y; a[x] = y; }
    }
    return 0;
}
```

---

## 类似题目推荐
1. **P3379 【模板】最近公共祖先（LCA）**  
   - 同类型树遍历问题，但需倍增预处理  

2. **P2421 质数分解**  
   - 质因数分解与 gcd 的结合应用  

3. **P3258 松鼠的新家**  
   - 树形结构上的路径标记与查询  

---

## 可视化代码片段（Canvas 动画）
```javascript
// 绘制树节点（8-bit 风格）
function drawNode(ctx, x, y, val, state) {
  const colors = { default: '#6B8E23', active: '#FFD700', found: '#00FF00' };
  ctx.fillStyle = colors[state] || colors.default;
  ctx.fillRect(x-10, y-10, 20, 20); // 像素方块
  ctx.fillStyle = '#000';
  ctx.font = '8px "Press Start 2P"';
  ctx.fillText(val, x-5, y+3);
}

// 查询动画帧
function animateQuery(node) {
  let current = node.parent;
  while(current) {
    highlight(current); // 黄色高亮
    if(gcd(node.val, current.val) > 1) {
      flashGreen(current); // 成功闪光
      break;
    }
    current = current.parent;
  }
}
```

---

## 个人心得摘录
> **WZKQWQ 的调试经验**：  
> “原本担心 2e5 数据会 TLE，但加入随机数据特性分析后，提交竟一次 AC。数据水的题要敢于尝试暴力。”  

> **Zilljy258 的代码哲学**：  
> “递归比循环更直观体现树的上溯逻辑，STL 的 gcd 让代码保持简洁。”  

> **quanjun 的优化教训**：  
> “曾尝试倍增预处理 gcd，但代码复杂度反超暴力且速度未提升，回归暴力才是正解。”  

---

## 复古游戏化设计
**音效配置**：  
```javascript
const audio = {
  move: new Audio('data:audio/wav;base64,UklGRl...'), // 8-bit 哔声
  found: new Audio('data:audio/wav;base64,UklGRk...'), // 成功音
  fail: new Audio('data:audio/wav;base64,UklGRi...')  // 失败嗡声
};

// 触发音效示例
function playSound(type) {
  if(audio[type]) audio[type].cloneNode(true).play(); // 允许重叠播放
}
``` 

**积分系统**：  
- 每次成功查询 +10 分，连续无回溯查询达成 3 次触发连击 x2  
- 修改操作扣 5 分（鼓励高效查询）  
- 积分面板用 8-bit 字体显示在右上角

---
处理用时：68.71秒
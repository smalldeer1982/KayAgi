# 题目信息

# [AHOI2018初中组] 根式化简

## 题目描述

小可可在学习“立方根”的知识时碰到这样的问题：

将下面根式化简为最简根式：

(1) $\sqrt[3]{125}$ (2) $\sqrt[3]{81}$ (3) $\sqrt[3]{52}$

这个问题对于小可可来说太简单了，他很快就算出了答案：

(1) $5$ (2) $3\sqrt[3]{3}$ (3) $\sqrt[3]{52}$

小可可知道任意形如 $\sqrt[3]{x}$ 的根式，化简后一定可以被写成形如 $a\sqrt[3]{b}$ 的最简根式。他觉得这很有趣，就仿照出了不少题，但没一会儿就被密密麻麻的根式绕晕了，于是他向你求助：

给定 $n$ 个形如 $\sqrt[3]{x}$ 的根式，请你将它们化简为形如 $a\sqrt[3]{b}$ 的最简形式，为了方便，你只需要输出其中的 $a$ 即可。

如果你没有学过这部分数学知识，你可以认为题意是：给你 $n$ 个正整数 $x$，对于每一个 $x$，你需要求出整数 $a,b$ 使得 $a^3 \times b = x$，输出最大的整数 $a$ 即可。

## 说明/提示

对于 $100\%$ 的数据满足：$1 \le n \le 10000$，$1 \le x \le 10^{18}$。

本题共 10 个测试点，编号为1 \~ 10，每个测试点额外保证如下：
 
1 \~ 2： $n \le 10, x \le 10^6$   
3 \~ 4： $n \le 10, x \le 10^9$  
5 \~ 6： $n \le 100, x \le 10^{18}$ 且 $x$ 为完全立方数  
7 \~ 8： $n \le 500, x \le 10^{18}$  
9 \~ 10： $n \le 10000, x \le 10^{18}$

## 样例 #1

### 输入

```
3
125 81 52```

### 输出

```
5
3
1```

# AI分析结果



# 算法分类
**数论 + 质因数分解 + 三次方根判定**

---

## 题解思路与解决难点

### **核心算法流程**
1. **预处理质数**：计算10^18的四次方根（约31623），筛出该范围内的所有质数（共约3400个）
2. **质因数分解**：对每个x，用预处理的质数进行分解，记录每个质数的次数，每3次累计到答案a中
3. **立方根判定**：分解后的剩余部分x，用二分法判断是否为完全立方数，若是则取立方根乘入a

### **关键难点与突破**
1. **大数质因数分解**：通过限制质数范围为四次方根，将时间复杂度从O(1e6)优化到O(3e3)
2. **立方数快速判定**：预处理1e6的立方表+二分查找，或数学计算立方根后验证三次方
3. **剪枝优化**：分解过程中提前检查剩余数是否为立方数，减少后续计算（critnos的优化）

---

## 题解评分（≥4星）

### 1. hongzy（4.5星）⭐⭐⭐⭐✨
- **亮点**：首创四次方根质数筛法，结合预处理立方表与二分判定
- **代码**：预处理31650以内质数，代码结构清晰，时间复杂度O(3400*N)
- **优化**：将质数范围压缩到极小值，完美处理1e18规模数据

### 2. critnos（5星）⭐⭐⭐⭐⭐
- **亮点**：分解过程中动态检查剩余数是否为立方数，极致剪枝
- **代码**：在质因数分解循环内插入立方根判定，平均减少50%二分操作
- **性能**：实测166ms最优解，完美结合数学推导与工程优化

### 3. KesdiaelKen（4星）⭐⭐⭐⭐
- **亮点**：详细推导四次方根理论的正确性，代码附带数学证明
- **代码**：线性筛法生成质数表，逻辑严谨易理解
- **缺点**：未实现分解过程中的动态剪枝

---

## 最优思路提炼

### **核心技巧**
```python
# 伪代码流程
for x in input_numbers:
    a = 1
    # 阶段1：分解小质数
    for prime in primes_under_31650:
        cnt = 0
        while x % prime == 0:
            cnt += 1
            x /= prime
        a *= prime^(cnt//3)
    # 阶段2：判定大质数立方
    cubic_root = binary_search_cubic(x)
    if cubic_root^3 == x:
        a *= cubic_root
    print(a)
```

### **关键优化点**
- **质数范围压缩**：仅需处理四次方根内的质数（数学证明剩余数至多含3个质因数）
- **立方根快速计算**：用`pow(x,1/3)`取整后验证，避免大数溢出
- **动态剪枝**：在分解质因数循环中插入立方判定，提前终止无用计算

---

## 类似题目推荐
1. **P1075 质因数分解**（基础质因数分解）
2. **P1029 最大公约数和最小公倍数问题**（数论因子分析）
3. **P2429 制杖题**（质数筛法+大数分解）

---

## 可视化设计

### **动画方案**
1. **质因数分解过程**：
   - 网格显示当前x值，质数p高亮为红色
   - 每次分解p时，x缩小并弹出`p³`粒子特效，答案a增长
   - 示例：分解81→3⁴，弹出3³后a变为3，剩余3闪烁

2. **立方根判定**：
   - 剩余x悬浮空中，下方生成1e6个立方数光点
   - 二分查找时光点范围收缩，命中时立方根升空融入a

### **像素风格**
- **调色板**：16色复古风（深蓝背景，绿色数字，红色质数）
- **音效**：
  - 分解成功：8-bit "叮"声（类似马里奥吃金币）
  - 立方命中：胜利小号音效
  - 错误：经典FC死亡音

### 交互演示
```javascript
// 伪代码示例：Canvas绘制分解过程
function drawFactorization(x, primes) {
    let y = x;
    primes.forEach(p => {
        let cnt = 0;
        while(y % p === 0) {
            cnt++;
            y /= p;
            // 绘制分解动画
            ctx.fillStyle = '#FF0000'; // 红色高亮当前质数
            drawCube(p, cnt); // 绘制立方体表示p³
        }
        if(cnt >= 3) {
            playSound('coin'); // 分解成功音效
        }
    });
    // 立方判定动画
    let root = Math.cbrt(y);
    if(root**3 === y) {
        ctx.fillStyle = '#00FF00'; // 绿色立方根
        drawJumpingCube(root);
        playSound('victory');
    }
}
```

---

## 代码实现（critnos优化版）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXP = 31650;
vector<int> primes;

void sieve() { // 埃氏筛法
    vector<bool> isPrime(MAXP+1, true);
    for(int i=2; i*i<=MAXP; ++i) 
        if(isPrime[i])
            for(int j=i*i; j<=MAXP; j+=i) 
                isPrime[j] = false;
    for(int i=2; i<=MAXP; ++i) 
        if(isPrime[i]) 
            primes.push_back(i);
}

int main() {
    sieve();
    int n; scanf("%d", &n);
    while(n--) {
        ll x, ans=1; scanf("%lld", &x);
        // 阶段1：分解小质数
        for(int p : primes) {
            if(p*p*p*p > x) break; // 四次方根剪枝
            int cnt=0;
            while(x % p == 0) x/=p, cnt++;
            ans *= pow(p, cnt/3);
            // 动态立方检查
            ll rt = pow(x, 1.0/3);
            while(rt*rt*rt < x) rt++;
            if(rt*rt*rt == x) {
                ans *= rt;
                x = 1;
                break;
            }
        }
        // 阶段2：最终立方判定
        ll rt = pow(x, 1.0/3);
        while(rt*rt*rt < x) rt++;
        if(rt*rt*rt == x) ans *= rt;
        printf("%lld\n", ans);
    }
}
```

---
处理用时：71.44秒
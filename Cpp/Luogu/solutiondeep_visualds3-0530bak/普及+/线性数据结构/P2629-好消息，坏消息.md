# 题目信息

# 好消息，坏消息

## 题目描述

Uim 在公司里面当秘书，现在有 $n$ 条消息要告知老板。每条消息有一个好坏度，这会影响老板的心情。告知完一条消息后，老板的心情等于老板之前的心情加上这条消息的好坏度。最开始老板的心情是 $0$，一旦老板心情到了 $0$ 以下就会勃然大怒，炒了 Uim 的鱿鱼。

Uim 为了不被炒，提前知道了这些消息（已经按时间的发生顺序进行了排列）的好坏度，希望知道如何才能不让老板发怒。

Uim 必须按照事件的发生顺序逐条将消息告知给老板。不过 Uim 可以使用一种叫 “倒叙” 的手法，例如有 $n$ 条消息，Uim 可以按 $k,k+1,k+2,\ldots,n,1,2,\ldots,k-1$（事件编号）这种顺序通报。

他希望知道，有多少个 $k$，可以使从 $k$ 号事件开始通报到 $n$ 号事件然后再从 $1$ 号事件通报到 $k-1$ 号事件可以让老板不发怒。

## 说明/提示

**【样例解释】**

通报事件的可行顺序（用编号表示）为 $2\rightarrow3\rightarrow4\rightarrow1$ 或 $3\rightarrow4\rightarrow1\rightarrow2$（分别对应 $k=2$ 和 $k=3$）

通报事件的可行顺序（用好坏度表示）为 $5\rightarrow1\rightarrow2\rightarrow(-3)$ 或 $1\rightarrow2\rightarrow(-3)\rightarrow5$

**【数据范围】**

对于 $25\%$ 的数据，$n\le10^3$；  
对于 $75\%$ 的数据，$n\le10^4$；  
对于 $100\%$ 的数据，$1 \le n\le 10^6$。

## 样例 #1

### 输入

```
4
-3 5 1 2
```

### 输出

```
2

```

# AI分析结果



**算法分类**：前缀和与单调队列/环形数组处理

---

### **题解思路与解决难点**

**核心问题**：找到所有k，使得环形数组从k开始的前缀和始终≥0。

**关键思路**：
- **断环为链**：将数组复制到末尾，形成2n-1的链，便于处理环形结构。
- **前缀和预处理**：计算扩展数组的前缀和数组s[]。
- **滑动窗口最小值**：使用单调队列维护每个长度为n的窗口最小值，判断min(s[k..k+n-1]) - s[k-1] ≥0。

**主要难点**对比：
1. **暴力法**：直接检查每个k的所有位置，O(n²)超时。
2. **单调队列优化**：O(n)维护窗口最小值，复杂度最优。
3. **前后缀最小值**：O(n)预处理前后缀min数组，直接判断每个k的合法性。

---

### **题解评分（≥4星）**

1. **憧憬未来（★★★★★）**  
   - **亮点**：清晰的单调队列实现，断环为链处理优雅，代码高效。  
   - **代码**：通过维护单调递减队列快速获取窗口最小值。

2. **_ztyqwq（★★★★★）**  
   - **亮点**：O(n)预处理前后缀最小值，逻辑简洁，无复杂数据结构。  
   - **代码**：`m[i]`和`f[i]`分别记录前后缀min，判断条件直接。

3. **Mizuhara（★★★★☆）**  
   - **亮点**：动态规划递推后缀最小值，结合前缀min快速判断。  
   - **心得**：“吞噬算法”合并负数区间的思路独特，启发式解决。

---

### **最优思路提炼**

**核心技巧**：
1. **前缀和转换**：将环形问题转化为线性前缀和问题。
2. **区间最小值查询**：通过单调队列或预处理快速获取任意区间的min值。
3. **分治判断**：将环形拆分为前后两段，分别判断最小值是否合法。

**关键公式**：
- 后半段合法：`min(s[k..n]) - s[k-1] ≥ 0`
- 前半段合法：`min(s[1..k-1]) + (总s[n] - s[k-1]) ≥ 0`

---

### **同类型题目推荐**
- **滑动窗口极值**：P1886（单调队列模板）
- **环形子数组和**：P918（环形数组的最大子数组和）
- **二维RMQ**：P2216（理想的正方形，二维区间极值）

---

### **可视化设计**

**动画演示步骤**：
1. **环形展开**：原数组复制并展开，高亮当前窗口k~k+n-1。
2. **前缀和计算**：动态绘制s[]数组，颜色渐变表示值大小。
3. **单调队列维护**：队列元素动态进出，红色标记当前最小值。
4. **合法性判断**：绿色标记有效k，显示min值是否≥0。

**复古像素风格**：
- **Canvas绘制**：数组元素显示为8-bit像素块，滚动时伴有“哔”音效。
- **自动演示**：AI自动切换k，成功时播放胜利音效，失败则短促提示。

**交互功能**：
- **步进控制**：←→键调整k，空格暂停，Enter重放。
- **速度滑块**：调整动画速度，适应不同学习节奏。

---

### **核心代码片段**

**单调队列实现（憧憬未来）**：
```cpp
for(int i=1; i<=2*n-1; i++) {
    while(head<=tail && s[i]<=s[q[tail]]) tail--; // 维护递减队列
    q[++tail] = i;
    // 移除超出窗口的队头
    if(i >= n) {
        if(s[q[head]] - s[i-n] >=0) ans++;
    }
}
```

**前后缀最小值法（_ztyqwq）**：
```cpp
// 预处理前后缀min
for(int i=1; i<=n; i++) m[i] = min(m[i-1], s[i]);
for(int i=n; i>=1; i--) f[i] = min(f[i+1], s[i]);
// 判断每个k
if(m[i-1] + (s[n]-s[i-1])>=0 && f[i]-s[i-1]>=0) ans++;
```

---

**总结**：最优解通过前缀和与极值预处理，将问题复杂度降至O(n)。可视化设计聚焦于极值查询的动态过程，帮助理解算法核心。

---
处理用时：67.12秒
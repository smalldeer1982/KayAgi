# 题目信息

# [NOIP 2015 普及组] 求和

## 题目背景

NOIP2015 普及组 T3

## 题目描述

一条狭长的纸带被均匀划分出了 $n$ 个格子，格子编号从 $1$ 到 $n$。每个格子上都染了一种颜色 $color_i$ 用 $[1,m]$ 当中的一个整数表示），并且写了一个数字 $number_i$。

| 编号 | 1 | 2 | 3 | 4 | 5 | 6 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| **颜色和数字** | $\color{blue}{5}$ | $\color{blue}{5}$ | $\color{red}{3}$ | $\color{red}{2}$ | $\color{blue}{2}$ | $\color{red}{2}$ |

定义一种特殊的三元组：$(x,y,z)$，其中 $x,y,z$ 都代表纸带上格子的编号，这里的三元组要求满足以下两个条件：

1. $x,y,z$ 都是整数，$x<y<z,y-x=z-y$。

2. $color_x=color_z$。

满足上述条件的三元组的分数规定为 $(x+z) \times (number_x+number_z)$。整个纸带的分数规定为所有满足条件的三元组的分数的和。这个分数可能会很大，你只要输出整个纸带的分数除以 $10007$ 所得的余数即可。


## 说明/提示

**样例 1 解释**

纸带如题目描述中的图所示。

所有满足条件的三元组为：$(1, 3, 5), (4, 5, 6)$。

所以纸带的分数为 $(1 + 5) \times (5 + 2) + (4 + 6) \times (2 + 2) = 42 + 40 = 82$。


对于第 $1$ 组至第 $2$ 组数据， $1 ≤ n ≤ 100, 1 ≤ m ≤ 5$；

对于第 $3$ 组至第 $4$ 组数据，$1 ≤ n ≤ 3000, 1 ≤ m ≤ 100$；

对于第 $5$ 组至第 $ 6 $ 组数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000$，且不存在出现次数超过 $ 20 $ 的颜色；

对于全部 $10$ 组数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000, 1 ≤ color_i ≤ m,1≤number_i≤100000$。


## 样例 #1

### 输入

```
6 2
5 5 3 2 2 2
2 2 1 1 2 1```

### 输出

```
82
```

## 样例 #2

### 输入

```
15 4
5 10 8 2 2 2 9 9 7 7 5 6 4 2 4
2 2 3 3 4 3 3 2 4 4 4 4 1 1 1```

### 输出

```
1388```

# AI分析结果



---

## 唯一算法分类  
**数学优化与分组统计**

---

## 综合分析与结论  
### 核心思路  
题目要求找出所有满足以下条件的三元组 $(x, y, z)$：  
1. $x < y < z$ 且 $y - x = z - y$（等价于 $x$ 和 $z$ 奇偶性相同）  
2. $x$ 和 $z$ 颜色相同  

分数计算式为 $(x + z) \times (num_x + num_z)$。通过数学推导，将暴力枚举优化为线性复杂度：  
- **分组统计**：按颜色和奇偶性分组，每组内元素贡献可快速计算。  
- **公式拆解**：将分数拆解为组内元素数量、下标和、数值和等统计量的线性组合。  

### 算法流程  
1. **分组预处理**：遍历所有元素，统计每组（颜色 + 奇偶性）的元素数量 `cnt` 和数值总和 `sum_num`。  
2. **贡献计算**：再次遍历每个元素，根据所在组的统计量计算其对总分的贡献：  
   \[
   \text{贡献} = x \times \left( (\text{cnt}-2) \times num_x + \text{sum_num} \right)
   \]  
3. **取模输出**：累加所有贡献后输出结果对 $10007$ 取模的值。  

### 可视化设计  
- **动画方案**：  
  - **颜色分组**：用不同颜色区分不同组，每组内用像素块表示元素，奇偶性用不同边框标记。  
  - **动态统计**：遍历时高亮当前元素，实时更新右侧面板的 `cnt` 和 `sum_num` 值。  
  - **贡献计算**：当前元素的贡献公式逐步展开显示，关键变量（如 `cnt-2`）用闪烁特效突出。  
- **复古像素风格**：  
  - 使用 8-bit 像素字体和 16 色调色板，元素用方块表示，颜色编号显示在方块左上角。  
  - 背景音乐为 8-bit 风格循环音轨，计算贡献时播放短促“滴”声。  

---

## 题解清单 (≥4星)  
### 1. Victorique_De_Blois（5星）  
- **亮点**：代码简洁，利用前缀和与数学公式直接计算贡献，时间复杂度 $O(n)$。  
- **代码片段**：  
  ```cpp  
  for(int i = 1; i <= n; i++) {
      ans += i % mod * ((sum[c][g] + (nt[c][g] - 2) % mod * number[i] + mod) % mod);
      ans %= mod;
  }
  ```

### 2. Sol1（4星）  
- **亮点**：公式推导清晰，通过展开式子展示贡献拆分逻辑，代码实现高效。  
- **关键推导**：  
  \[
  \text{总贡献} = \sum \left( i \times (\text{sum\_num} + (k-2) \times num_i) \right)
  \]

### 3. WsW_（4星）  
- **亮点**：动态维护统计量，一次遍历完成计算，节省空间。  
- **代码片段**：  
  ```cpp  
  ans += i * (sum[c][g] - num_i) % mod;  
  ans += i * num_i % mod * (cnt[c][g] - 1) % mod;  
  ```

---

## 最优思路与代码实现  
### 核心代码  
```cpp  
#include <cstdio>  
const int N = 100000, MOD = 10007;  
int n, m, color[N], num[N], cnt[N][2], sum[N][2], ans;  

int main() {  
    scanf("%d%d", &n, &m);  
    for (int i = 1; i <= n; i++) scanf("%d", &num[i]);  
    for (int i = 1; i <= n; i++) {  
        scanf("%d", &color[i]);  
        int c = color[i], g = i % 2;  
        cnt[c][g]++;  
        sum[c][g] = (sum[c][g] + num[i]) % MOD;  
    }  
    for (int i = 1; i <= n; i++) {  
        int c = color[i], g = i % 2;  
        int k = cnt[c][g], s = sum[c][g];  
        ans = (ans + i * ((s + (k - 2) * num[i]) % MOD)) % MOD;  
    }  
    printf("%d", ans);  
    return 0;  
}  
```  

### 实现思想  
1. **分组统计**：首次遍历记录每组（颜色 + 奇偶性）的元素数量 `cnt` 和数值和 `sum`。  
2. **公式计算**：每个元素的贡献为 $i \times (\text{sum} + (\text{cnt}-2) \times num_i)$，直接累加。  

---

## 相似题目推荐  
1. **P1987 摆花**（分组统计与动态规划）  
2. **P3406 海底高铁**（前缀和优化与区间统计）  
3. **P2672 推销员**（贪心与数学优化）  

---

## 个人心得摘录  
- **调试教训**：初始未考虑取模导致负数，需用 `(x % MOD + MOD) % MOD` 修正。  
- **思维突破**：将三元组问题转化为二元组贡献，利用奇偶性分组避免暴力枚举。  

---

## 可视化与复古动画设计  
### 动画流程  
1. **分组展示**：元素按颜色分组，奇偶性用不同边框颜色区分（如红色为奇，蓝色为偶）。  
2. **统计面板**：右侧显示当前组的 `cnt` 和 `sum`，数值随遍历动态更新。  
3. **贡献计算**：当前元素高亮，贡献公式逐步显示：  
   \[
   \text{贡献} = i \times (\text{sum} + (\text{cnt}-2) \times num_i)
   \]  
4. **音效设计**：元素加入组时播放“哔”声，贡献计算时播放“叮”声。  

### 复古风格实现  
- **Canvas 绘制**：每个元素用 16x16 像素方块表示，颜色编号显示在左上角。  
- **自动演示**：点击“播放”按钮后，算法自动运行，元素依次高亮并更新统计面板。  

```javascript  
// 示例：Canvas绘制元素方块（伪代码）  
function drawElement(x, y, color, isOdd) {  
    ctx.fillStyle = COLORS[color];  
    ctx.fillRect(x * 20, y * 20, 16, 16);  
    ctx.strokeStyle = isOdd ? "#FF0000" : "#0000FF";  
    ctx.strokeRect(x * 20, y * 20, 16, 16);  
}  
```  

--- 

通过以上设计，学习者可直观理解分组统计与数学优化的核心思想，同时享受复古游戏的交互乐趣。

---
处理用时：118.37秒
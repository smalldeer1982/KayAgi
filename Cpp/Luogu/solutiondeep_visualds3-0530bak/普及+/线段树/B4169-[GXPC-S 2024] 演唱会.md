# 题目信息

# [GXPC-S 2024] 演唱会

## 题目背景

小林最近迷上了参加演唱会。

## 题目描述

有 $n$ 名粉丝在演唱会现场坐成一排，第 $i$ 名粉丝的应援力度为 $a_i$。

聚光灯每次会照射到一个区间 $[l,r]$，传达出的**应援力度**为区间中所有粉丝的应援力度之和乘以区间中最大的应援力度。

为了更好的应援，某个粉丝可能会更改他的应援力度。

请你帮小林算出，每次聚光灯照射过来的时候，传达出的应援力度的值。

## 说明/提示


**本题采用捆绑测试。**

- Subtask 1（30pts）：保证 $n,m\le 10^3$；
- Subtask 2（20pts）：保证无修改操作；
- Subtask 3（50pts）：无额外约束。

对于 $100\%$ 的数据，保证：

- $1\le n,m,a_i\le 10^5$；
- $\rm{opt}\in \{1,2\}$；
- 当 $\rm{opt}=1$ 时，$1\le x\le y\le n$；
- 当 $\rm{opt}=2$ 时，$1\le x\le n$，$1\le y\le 10^5$。




## 样例 #1

### 输入

```
5 5
1 2 3 4 5
1 1 3
1 3 5
2 1 4
1 1 3
1 1 5```

### 输出

```
18
60
36
90```

# AI分析结果



---

**唯一算法分类**：线段树

---

## 综合分析与结论

### 核心思路与难点
本题要求动态维护区间和与最大值，并在每次查询时计算两者的乘积。核心难点在于如何高效处理区间查询与单点更新。线段树通过在每个节点存储区间的和与最大值，实现了 O(log n) 的时间复杂度，完美满足题目要求。

### 算法流程与可视化设计
1. **线段树结构**：每个节点维护区间 `[l, r]` 的和 `sum` 和最大值 `max_val`。
2. **构建**：递归初始化，叶子节点直接赋值，非叶子节点合并子节点信息。
3. **更新**：单点修改后逐层更新父节点的 `sum` 和 `max_val`。
4. **查询**：遍历覆盖目标区间的线段树节点，累加 `sum`，取最大 `max_val`。

**可视化设计**：
- **颜色高亮**：修改时，叶子节点变红并向上传递更新；查询时，覆盖的节点变绿。
- **动画步进**：展示线段树递归拆分区间的过程，每次合并子节点的 `sum` 和 `max_val`。
- **控制面板**：支持调整动画速度，手动触发查询/修改操作。

---

## 最优题解（5星）

### 题解亮点
- **双属性维护**：线段树节点同时存储区间和与最大值，高效合并。
- **简洁实现**：递归逻辑清晰，代码可读性强。
- **时间复杂度优**：O(m log n) 完美处理 1e5 级数据。

```cpp
#include <iostream>
using namespace std;

const int MAXN = 1e5 + 10;

struct Node {
    int l, r, sum, max_val;
} tree[4 * MAXN];
int a[MAXN];

void build(int node, int l, int r) {
    tree[node].l = l, tree[node].r = r;
    if (l == r) {
        tree[node].sum = tree[node].max_val = a[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(node << 1, l, mid);
    build(node << 1 | 1, mid + 1, r);
    tree[node].sum = tree[node << 1].sum + tree[node << 1 | 1].sum;
    tree[node].max_val = max(tree[node << 1].max_val, tree[node << 1 | 1].max_val);
}

void update(int node, int pos, int val) {
    if (tree[node].l == tree[node].r) {
        tree[node].sum = tree[node].max_val = val;
        return;
    }
    int mid = (tree[node].l + tree[node].r) >> 1;
    if (pos <= mid) update(node << 1, pos, val);
    else update(node << 1 | 1, pos, val);
    tree[node].sum = tree[node << 1].sum + tree[node << 1 | 1].sum;
    tree[node].max_val = max(tree[node << 1].max_val, tree[node << 1 | 1].max_val);
}

void query(int node, int l, int r, int &sum, int &max_val) {
    if (tree[node].r < l || tree[node].l > r) return;
    if (l <= tree[node].l && tree[node].r <= r) {
        sum += tree[node].sum;
        max_val = max(max_val, tree[node].max_val);
        return;
    }
    query(node << 1, l, r, sum, max_val);
    query(node << 1 | 1, l, r, sum, max_val);
}

int main() {
    int n, m; cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    build(1, 1, n);
    while (m--) {
        int opt, x, y; cin >> opt >> x >> y;
        if (opt == 1) {
            int sum = 0, max_val = -1;
            query(1, x, y, sum, max_val);
            cout << sum * max_val << endl;
        } else update(1, x, y);
    }
    return 0;
}
```

---

## 同类型题推荐
1. **P3372 线段树 1**：区间加与区间和查询。
2. **P3865 ST 表**：静态区间最大值查询。
3. **P4513 小白逛公园**：动态维护区间最大子段和。

---

## 可视化与游戏化设计
- **像素风格**：线段树节点显示为绿色方块，修改时闪烁红色。
- **音效**：更新时播放“滴”声，查询成功时播放上升音阶。
- **自动演示**：模拟随机操作，动态展示线段树变化过程。

---
处理用时：157.25秒
# 题目信息

# [NOIP 2003 提高组] 神经网络

## 题目背景

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。



## 题目描述

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)

神经元（编号为 $i$）


图中，$X_1 \sim X_3$ 是信息输入渠道，$Y_1 \sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)

兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）

$$C_i=\left(\sum\limits_{(j,i) \in E} W_{ji}C_{j}\right)-U_{i}$$

公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。



## 说明/提示

**【题目来源】**

NOIP 2003 提高组第一题

## 样例 #1

### 输入

```
5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
```

### 输出

```
3 1
4 1
5 1
```

# AI分析结果



# 神经网络题解分析

## 算法分类
**拓扑排序**

---

## 核心思路与难点对比

### 核心逻辑
1. **拓扑排序处理顺序**  
   - 神经元分层次传递信号，必须按拓扑序处理才能保证前驱节点已计算完毕  
   - 使用队列维护待处理节点，仅当节点状态>0时才进行信号传递

2. **阈值处理**  
   - 输入层神经元状态直接使用初始值（不减去阈值）  
   - 中间层神经元在初始化时直接减去阈值（`c[i] -= u[i]`）

3. **输出层判断**  
   - 通过维护出度数组`out[]`，出度为0的节点即为输出层

### 关键难点对比
| 题解作者       | 阈值处理方式                          | 输出层判断方法                     | 特殊处理技巧                     |
|----------------|---------------------------------------|-------------------------------------|----------------------------------|
| Lucaster_      | 初始化时非输入层减u[i]               | 遍历所有节点检查出度是否为0         | 使用`vis[]`标记已入队防止重复处理 |
| zzlzk          | 拓扑排序时减u[i]                      | 邻接表判空判断输出层               | 反向建图+递归记忆化搜索          |
| hibiki         | 初始化时输入层单独处理                | 邻接表判空+出度数组双重校验         | 分层BFS标记层数                  |
| faker121       | 维护独立入度数组避免重复减阈值        | 优先队列自动排序输出               | 用独立数组保存原始入度           |

---

## 题解评分（≥4星）

### 1. Lucaster_（⭐⭐⭐⭐⭐）
**亮点**  
- 预处理阈值简化计算逻辑  
- 使用`out[]`数组清晰标识输出层  
- 队列仅存储活跃节点提升效率

### 2. zzlzk（⭐⭐⭐⭐） 
**亮点**  
- 反向建图实现自然递归  
- 公式推导清晰展示数学本质  
- 代码仅19行极简实现

### 3. teafrogsf（⭐⭐⭐⭐）
**亮点**  
- 独立入度数组避免修改原始数据  
- 显式分层处理提升可读性  
- 直接输出结果无需排序

---

## 最优思路提炼

### 核心代码片段（Lucaster_版）
```cpp
// 初始化处理阈值
for(int i=1;i<=n;++i){
    scanf("%d%d",&c[i],&x);
    if(c[i]) q.push(i); // 输入层直接入队
    else c[i] -= x;    // 非输入层立即减阈值
}

// 拓扑排序核心逻辑
while(!q.empty()){
    int h=q.front(); q.pop();
    if(c[h]<=0) continue; // 仅传递活跃信号
    for(int i=hd[h];i;i=e[i].next){
        int t=e[i].to;
        c[t] += e[i].val * c[h];
        if(!vis[t]) q.push(t), vis[t]=1;
    }
}

// 输出结果
for(int i=1;i<=n;++i)
    if(!out[i] && c[i]>0) 
        printf("%d %d\n",i,c[i]);
```

### 关键技巧
1. **阈值预减法**：在初始化阶段直接处理非输入层的阈值  
2. **活性传播**：队列中仅保留可能产生信号传递的节点  
3. **出度标记法**：通过维护`out[]`数组快速定位输出层

---

## 同类型题目推荐
1. **P4017 最大食物链计数** - 拓扑排序求路径数  
2. **P1983 车站分级** - 拓扑排序处理层级关系  
3. **P2742 [USACO5.3] 量取牛奶** - 带权值的拓扑处理

---

## 可视化设计

### 动画方案
1. **节点状态标记**  
   - 红色：未激活（C≤0）  
   - 绿色：活跃状态（C>0）  
   - 黄色：正在处理中

2. **队列可视化**  
   - 底部动态显示当前队列元素  
   - 元素出队时高亮边框闪烁

3. **信号传递过程**  
   ```mermaid
   graph LR
   A[当前节点] -->|w=3| B[节点2]
   A -->|w=2| C[节点3]
   style A fill:#9f9,stroke:#333
   style B fill:#f99,stroke:#333
   style C fill:#f99,stroke:#333
   ```

### 复古像素风格实现
```javascript
// Canvas绘制节点（8-bit风格）
function drawNode(ctx, x, y, state) {
    const colors = { active: '#33FF33', inactive: '#FF3333' };
    ctx.fillStyle = colors[state];
    ctx.fillRect(x*32, y*32, 28, 28); // 32x32网格
}

// 音效触发
function playSFX(type) {
    const sfx = {
        activate: new Audio('data:audio/wav;base64,UklGRl9v...'),
        propagate: new Audio('data:audio/wav;base64,UklGRk9...')
    };
    sfx[type].play();
}
```

---

## 实现要点总结
1. **拓扑序保证**：必须严格按层级处理节点  
2. **阈值分离处理**：输入层与其他层区别对待  
3. **效率优化**：通过活性标记避免无效计算  
4. **输出层快速定位**：出度数组维护法时间复杂度O(1)

通过结合拓扑排序与活性传播机制，既保证了计算正确性，又大幅提升了算法效率。可视化设计通过颜色标记和动态队列展示，可直观呈现信号传递过程，8-bit音效的加入则增强了学习趣味性。

---
处理用时：73.88秒
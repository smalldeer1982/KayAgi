# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果



# 算法分类：堆（优先队列）

## 综合分析与结论

### 核心算法流程
1. **对顶堆维护中位数**：使用大根堆维护较小元素，小根堆维护较大元素。保证两者大小差≤1，中位数为较大堆的堆顶。
2. **插入调整逻辑**：新元素根据大小放入对应堆，若堆大小差>1则调整堆顶元素。
3. **难点解决**：动态维护堆平衡（O(1)调整）、正确处理插入位置。

### 最优题解思路
**肖恩Sean（★★★★★）**
- 使用两个堆分别维护前/后半部分元素
- 每次插入后调整堆大小差至≤1
- 时间复杂度O(n logn)，空间O(n)

```cpp
priority_queue<int> q1; // 大根堆（较小元素）
priority_queue<int, vector<int>, greater<int>> q2; // 小根堆（较大元素）

void insert(int x) {
    if(x <= q1.top()) q1.push(x);
    else q2.push(x);
    
    // 调整堆大小差
    while(abs(q1.size() - q2.size()) > 1) {
        if(q1.size() > q2.size()) {
            q2.push(q1.top());
            q1.pop();
        } else {
            q1.push(q2.top());
            q2.pop();
        }
    }
}
```

## 题解清单（≥4星）

1. **肖恩Sean（★★★★★）**  
   经典对顶堆实现，代码简洁高效，维护堆平衡逻辑清晰

2. **IRipple（★★★★☆）**  
   引入mid变量动态调整，更直观展示中位数转移过程

3. **ysj1173886760（★★★★☆）**  
   树状数组+离散化方案，适合大数据范围场景

## 可视化设计

### 动画方案
```javascript
// 伪代码示例
class HeapVisualizer {
    constructor(canvas) {
        this.maxHeap = new PixelBarGroup(x=100, color="#FF6B6B"); // 大根堆
        this.minHeap = new PixelBarGroup(x=300, color="#4ECDC4"); // 小根堆
        this.currentNum = new HighlightBlock(x=500, color="#FFE66D");
    }

    insert(num) {
        // 显示数字进入对应堆
        if(num <= this.maxHeap.top()) {
            this.maxHeap.addWithEffect(num, "scaleUp");
        } else {
            this.minHeap.addWithEffect(num, "scaleUp");
        }
        
        // 调整堆平衡
        while(Math.abs(this.maxHeap.size - this.minHeap.size) > 1) {
            // 播放元素移动动画
            if(this.maxHeap.size > this.minHeap.size) {
                this.minHeap.addWithEffect(this.maxHeap.pop(), "slideRight");
            } else {
                this.maxHeap.addWithEffect(this.minHeap.pop(), "slideLeft");
            }
        }
        
        // 高亮当前中位数
        this.medianBlock = (this.maxHeap.size >= this.minHeap.size) 
            ? this.maxHeap.topBlock 
            : this.minHeap.topBlock;
        this.medianBlock.flash("gold", 3);
    }
}
```

### 复古游戏化要素
1. **8-bit音效**：
   - `insert_sound`: 插入元素时播放短促"哔"声
   - `balance_sound`: 调整堆时播放"滴嘟"声
   - `median_sound`: 找到中位数时播放上升音阶

2. **像素动画**：
   - 堆结构以矩形块堆叠展示
   - 元素移动时显示像素拖尾效果
   - 中位数显示为闪烁的金色方块

3. **自动演示模式**：
   ```javascript
   autoRun() {
       const nums = [3,1,5,9,8,7,6];
       let step = 0;
       const timer = setInterval(() => {
           if(step >= nums.length) clearInterval(timer);
           else {
               visualizer.insert(nums[step++]);
               playSound('step_sound');
           }
       }, 1000);
   }
   ```

## 同类型题目推荐
1. **P1801 黑匣子** - 动态维护第K大数
2. **P3871 [TJOI2010]中位数** - 实时查询中位数
3. **P3380 [模板]二逼平衡树** - 多操作维护有序序列

## 核心代码实现
```cpp
#include <queue>
using namespace std;

int main() {
    priority_queue<int> q1; // 大根堆（存储较小的一半）
    priority_queue<int, vector<int>, greater<int>> q2; // 小根堆
    
    int n, x; cin >> n;
    cin >> x;
    q1.push(x);
    cout << x << endl;
    
    for(int i=2; i<=n; i++) {
        cin >> x;
        if(x > q1.top()) q2.push(x);
        else q1.push(x);
        
        // 平衡堆大小
        while(abs(q1.size()-q2.size()) > 1) {
            if(q1.size() > q2.size()) {
                q2.push(q1.top());
                q1.pop();
            } else {
                q1.push(q2.top());
                q2.pop();
            }
        }
        
        if(i%2) cout << (q1.size()>q2.size() ? q1.top() : q2.top()) << endl;
    }
}
```

---
处理用时：71.95秒
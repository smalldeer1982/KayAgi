# 题目信息

# 三元上升子序列

## 题目描述

Erwin 最近对一种叫 `thair` 的东西巨感兴趣。。。

在含有 $n$ 个整数的序列 $a_1,a_2,\ldots,a_n$ 中，三个数被称作`thair`当且仅当 $i<j<k$ 且 $a_i<a_j<a_k$。

求一个序列中 `thair` 的个数。

## 说明/提示

#### 样例2 解释

$7$ 个 `thair` 分别是：

- 1 2 3
- 1 2 4
- 1 2 3
- 1 2 4
- 1 3 4
- 2 3 4
- 2 3 4

#### 数据规模与约定

- 对于 $30\%$ 的数据 保证 $n\le100$；
- 对于 $60\%$ 的数据 保证 $n\le2000$；
- 对于 $100\%$ 的数据 保证 $1 \leq n\le3\times10^4$，$1\le a_i\leq 10^5$。

## 样例 #1

### 输入

```
4
2 1 3 4```

### 输出

```
2```

## 样例 #2

### 输入

```
5
1 2 2 3 4```

### 输出

```
7```

# AI分析结果



### 唯一算法分类
树状数组优化

---

### 题解思路与核心难点分析

#### 核心思路
**乘法原理 + 离散化 + 树状数组**  
所有题解均基于以下观察：每个中间元素 `a[j]` 的贡献值为左边比它小的数的个数 `left[j]` 乘以右边比它大的数的个数 `right[j]`。通过两次遍历（正序统计 `left`，逆序统计 `right`），结合树状数组高效维护动态统计。

#### 算法实现要点
1. **离散化处理**：将原始数值映射到紧凑的整数范围，解决值域过大问题。
2. **树状数组维护**：
   - **正序遍历**：维护已处理的元素值，查询前缀和统计 `left[j]`。
   - **逆序遍历**：维护后续元素值，查询后缀和统计 `right[j]`。
3. **时间复杂度**：两次遍历 + 树状数组操作，总复杂度 `O(n log n)`。

#### 解决难点
- **离散化正确性**：需保证相同数值映射到同一位置，避免统计错误。
- **逆序统计技巧**：通过逆序遍历动态维护树状数组，计算 `right[j]` 时需调整查询逻辑。

---

### 高星题解推荐（≥4星）

1. **紫题（赞202）**  
   **评分：★★★★★**  
   - **亮点**：代码简洁，通用性强（可扩展至 M 元上升子序列）。  
   - **核心代码**：使用二维数组 `f[3][n]` 递推，树状数组优化状态转移。
   ```cpp
   for(int i = 2; i <= 3; i++) {
       memset(c, 0, sizeof(c));
       for(int j = 1; j <= n; j++) {
           f[i][j] = ask(a[j]-1);  // 查询前缀和
           add(a[j], f[i-1][j]);   // 更新树状数组
       }
   }
   ```

2. **Dog_Two（赞90）**  
   **评分：★★★★☆**  
   - **亮点**：分离 `left` 和 `right` 计算，解释详尽。  
   - **核心代码**：独立两个树状数组，正逆序分别处理。
   ```cpp
   for(int i=1; i<=n; ++i) {
       add(c1, _Q(A[i]), 1);
       Lef[i] = sum(c1, _Q(A[i])-1);  // 正序统计left
   }
   for(int i=n; i>=1; --i) {
       add(c2, _Q(A[i]), 1);
       Rit[i] = n-i - (sum(c2, _Q(A[i]))-1);  // 逆序统计right
   }
   ```

3. **SofanHe（赞14）**  
   **评分：★★★★**  
   - **亮点**：避免离散化，直接利用排序后的位置。  
   - **核心技巧**：通过排序后的 `pos` 属性维护元素顺序，简化离散化步骤。
   ```cpp
   sort(sf + 1, sf + n + 1, comp);  // 按值排序，记录原始位置
   for(int vc=1, i=1; i<=n; ++i) {
       if(sf[i].num != sf[i-1].num) while(vc < i) add1(sf[vc++].pos);
       cnts[i] = qy1(sf[i].pos-1);  // 直接通过位置统计
   }
   ```

---

### 最优思路提炼
1. **核心公式**：`ans = sum(left[j] * right[j])`。
2. **数据结构选择**：树状数组在动态维护和查询前缀/后缀和时效率最高。
3. **离散化必要性**：通过排序和去重将数值映射到 `[1, m]`，确保树状数组空间有效。
4. **两次遍历技巧**：正序统计 `left`，逆序统计 `right`，保证时间复杂度的最优性。

---

### 相似题目推荐
1. **P1908 逆序对**（树状数组统计逆序对）
2. **P3368 楼兰图腾**（三元组统计，类似思路）
3. **P1972 HH的项链**（区间统计与树状数组结合）

---

### 可视化算法演示设计
**动画方案**：  
1. **元素高亮**：当前处理的元素 `a[j]` 显示为红色，树状数组节点更新路径用黄色标记。
2. **动态更新**：
   - **正序遍历**：显示 `left[j]` 计算过程，树状数组节点值实时变化。
   - **逆序遍历**：用不同颜色区分 `right[j]` 的统计，树状数组反向更新。
3. **复古像素风格**：树状数组节点以 8-bit 方块表示，数值变化时播放经典音效（如《超级玛丽》金币声）。

**交互功能**：  
- **步进控制**：允许暂停/继续，单步观察树状数组更新。
- **数值映射展示**：侧边栏显示离散化后的数值与原值对应关系。

---

### 关键代码实现（紫题题解）
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MAXN = 3e4 + 5;

ll n, a[MAXN], s[MAXN], f[4][MAXN], c[MAXN], ans;

ll val(int x) { return lower_bound(s + 1, s + n + 1, a[x]) - s; }

ll ask(int x) {
    ll sum = 0;
    for (; x; x -= x & -x) sum += c[x];
    return sum;
}

void add(int x, ll v) {
    for (; x <= n; x += x & -x) c[x] += v;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i], s[i] = a[i];
    sort(s + 1, s + n + 1);
    ll m = unique(s + 1, s + n + 1) - s - 1;
    for (int i = 1; i <= n; i++) a[i] = val(i), f[1][i] = 1;

    for (int i = 2; i <= 3; i++) {
        fill(c, c + MAXN, 0);
        for (int j = 1; j <= n; j++) {
            f[i][j] = ask(a[j] - 1);
            add(a[j], f[i - 1][j]);
        }
    }

    for (int i = 1; i <= n; i++) ans += f[3][i];
    cout << ans << endl;
    return 0;
}
```

---
处理用时：91.48秒
# 题目信息

# [IOI 1998 ] [USACO5.5] 矩形周长Picture

## 题目背景

墙上贴着许多形状相同的海报、照片。它们的边都是水平和垂直的。每个矩形图片可能部分或全部的覆盖了其他图片。所有矩形合并后的边长称为周长。


## 题目描述

编写一个程序计算周长。

![](https://cdn.luogu.com.cn/upload/image_hosting/2eo4hzl6.png)

如图 $1$ 所示 $7$ 个矩形。

![](https://cdn.luogu.com.cn/upload/image_hosting/buk96amj.png)

如图 $2$ 所示，所有矩形的边界。所有矩形顶点的坐标都是整数。


## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N<5000$，所有坐标的数值范围都在 $-10^4$ 到 $10^4$ 之间。

## 样例 #1

### 输入

```
7
-15 0 5 10
-5 8 20 25
15 -4 24 14
0 -6 16 4
2 15 10 22
30 10 36 20
34 0 40 16```

### 输出

```
228```

# AI分析结果



**算法分类**：扫描线算法（线段树实现）

---

### **题解思路与核心难点**

1. **核心算法流程**：
   - **线段树扫描线**：将矩形拆分为上下边，按高度排序后逐层处理。线段树维护区间覆盖次数、有效覆盖长度、相邻线段端点状态。
   - **横向周长**：通过相邻两次扫描线间的覆盖长度差累加。
   - **纵向周长**：用线段树维护的连续线段数量乘以高度差。

2. **解决难点**：
   - **合并线段端点**：处理区间合并时端点是否连续，避免重复计数（如 `num` 字段的维护）。
   - **边处理顺序**：同一高度的边需先处理下边后上边，防止重叠误差。
   - **离散化优化**：针对坐标范围大的情况，离散化后压缩线段树规模。

---

### **题解评分（≥4星）**

1. **wucstdio（5星）**  
   - **亮点**：完整线段树实现，详细图解pushup逻辑，处理横向/纵向周长统一高效。
   - **代码**：结构清晰，注释明确，直接体现核心变量`len`和`num`的维护。

2. **xiejinhao（4星）**  
   - **亮点**：横纵分离扫描复用代码，离散化处理降低空间复杂度。
   - **优化**：通过函数参数传递树结构减少冗余，适合大规模数据。

3. **彼岸归航（4星）**  
   - **关键点**：强调同层边处理顺序的重要性，避免错误累加周长。
   - **实践性**：通过样例说明错误场景，调试经验实用。

---

### **最优思路与技巧**

1. **线段树节点设计**：
   ```cpp
   struct Tree {
       int sum;    // 覆盖次数（类似lazytag）
       int num;    // 连续线段数
       int len;    // 有效覆盖长度
       bool lflag, rflag; // 端点覆盖状态
   };
   ```
   - **pushup逻辑**：根据覆盖次数判断是否合并子区间，更新`num`和端点状态。

2. **边排序策略**：
   ```cpp
   bool cmp(Edge a, Edge b) {
       return a.h < b.h || (a.h == b.h && a.flag > b.flag);
   }
   ```
   - 确保同高度下边先于上边处理。

---

### **同类型题与推荐题目**

1. **P5490 [模板]扫描线**（矩形面积并）
2. **P1502 窗口的星星**（区间覆盖最大值）
3. **SPOJ-HORRIBLE**（区间加与区间和查询）

---

### **个人心得摘录**

- **wucstdio**：调试时发现同一高度的边顺序错误导致答案偏差，修正排序逻辑后AC。
- **Tweetuzki**：暴力解法在数据水时意外通过，验证了问题本质的覆盖统计特性。

---

### **可视化算法演示**

**动画设计**：
1. **扫描线移动**：红色竖线自下而上移动，触发当前处理的矩形边。
2. **线段树更新**：高亮被修改的区间节点，显示`sum`、`len`、`num`的变化。
3. **周长绘制**：
   - **横向**：绿色线段表示新增覆盖，长度差实时累加。
   - **纵向**：蓝色竖线数量由`num`决定，高度差动态计算。

**复古像素风格**：
- **Canvas绘制**：矩形边用8位色块表示，扫描线移动伴随芯片音效。
- **音效触发**：
  - `sum`增加时播放“哔”声，减少时“噗”声。
  - 周长更新时播放经典马里奥金币音效。

**核心代码片段（线段树更新）**：
```cpp
void pushup(int o, int l, int r) {
    if (tree[o].sum) {
        tree[o].len = r - l + 1;
        tree[o].num = 1;
        tree[o].lflag = tree[o].rflag = true;
    } else if (l == r) {
        tree[o].len = 0;
        tree[o].num = 0;
        tree[o].lflag = tree[o].rflag = false;
    } else {
        tree[o].len = tree[lson].len + tree[rson].len;
        tree[o].num = tree[lson].num + tree[rson].num;
        if (tree[lson].rflag && tree[rson].lflag) tree[o].num--;
        // ... 更新端点状态
    }
}
```

---

**总结**：线段树扫描线是此问题的标准解法，通过维护覆盖状态和线段数量，高效统计横纵周长。实现时需注意边处理顺序与离散化优化，可视化设计可增强对算法流程的理解。

---
处理用时：69.75秒
# 题目信息

# [TJOI2009] 开关

## 题目描述

现有 $n$ 盏灯排成一排，从左到右依次编号为：$1$，$2$，……，$n$。然后依次执行 $m$ 项操作。

操作分为两种：

1. 指定一个区间 $[a,b]$，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开）；
2. 指定一个区间 $[a,b]$，要求你输出这个区间内有多少盏灯是打开的。

**灯在初始时都是关着的。**

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2\le n\le 10^5$，$1\le m\le 10^5$，$1\le a,b\le n$，$c\in\{0,1\}$。

## 样例 #1

### 输入

```
4 5
0 1 2
0 2 4
1 2 3
0 2 4
1 1 4
```

### 输出

```
1
2```

# AI分析结果



# 算法分类
**线段树**

---

# 综合分析与结论

## 核心算法流程与难点解析
**核心思路**：区间反转操作等效于将开灯数量变为 `区间长度 - 当前开灯数`，用懒标记记录反转状态。查询时通过维护的 `sum` 值直接返回结果。

**难点与解决方案**：
1. **懒标记下传**：每次操作需要判断是否需要下传标记，并正确更新子节点状态。
2. **状态反转计算**：通过 `sum = r-l+1 - sum` 实现高效状态翻转。
3. **高效查询**：通过维护区间和避免暴力遍历。

**可视化设计要点**：
- **Canvas 动画**：用颜色块表示线段树节点，绿色表示开灯状态，红色表示关灯状态。反转操作时颜色块瞬间反转，伴随 "哔" 音效。
- **高亮标记**：被操作的区间用黄色边框高亮，懒标记下传时显示虚线流动效果。
- **步进控制**：支持暂停观察节点状态，单步执行观察标记下传过程。
- **复古音效**：使用 8-bit 音效库，反转操作时播放短促电子音，查询时播放上扬音调。

---

# 题解清单（≥4星）

## 1. 作者：shenbear（5星）
**亮点**：
- 最简洁的线段树实现
- 使用 `sum` 和 `tag` 双变量清晰维护状态
- 完整包含建树、下传、更新、查询全流程
**核心代码**：
```cpp
void pushdown(int root,int len) {
    if(ad[root]) {
        ad[root<<1] ^= 1;
        ad[root<<1|1] ^= 1;
        sum[root<<1] = (len-(len>>1)) - sum[root<<1];
        sum[root<<1|1] = (len>>1) - sum[root<<1|1];
        ad[root] = 0;
    }
}
```

## 2. 作者：Right（4.5星）
**亮点**：
- 创新性维护 `l0/l1` 双状态
- 使用 `swap` 代替算术运算提升可读性
**思维角度**：
```cpp
swap(t[p<<1].l0, t[p<<1].l1);  // 通过交换开关状态实现反转
```

## 3. 作者：Juan_feng（4星）
**亮点**：
- 分块实现的典范案例
- 维护 `ans[]` 数组优化整块查询效率
**关键公式**：
```cpp
ans[i] = block_size - ans[i]  // 整块反转计算
```

---

# 核心算法实现（线段树版）

## 关键函数实现
```cpp
void update(int node, int l, int r, int ul, int ur) {
    if(ul <= l && r <= ur) {
        tree[node].sum = (r-l+1) - tree[node].sum;
        tree[node].tag ^= 1;
        return;
    }
    push_down(node, l, r);
    int mid = (l+r)>>1;
    if(ul <= mid) update(node<<1, l, mid, ul, ur);
    if(ur > mid) update(node<<1|1, mid+1, r, ul, ur);
    tree[node].sum = tree[node<<1].sum + tree[node<<1|1].sum;
}
```

## 完整代码结构
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5+5;
int n,m;
struct Node {
    int sum, tag;
} tree[N<<2];

void pushup(int node) {
    tree[node].sum = tree[node<<1].sum + tree[node<<1|1].sum;
}

void pushdown(int node, int l, int r) {
    if(tree[node].tag) {
        int mid = (l+r)>>1;
        tree[node<<1].sum = mid-l+1 - tree[node<<1].sum;
        tree[node<<1|1].sum = r-mid - tree[node<<1|1].sum;
        tree[node<<1].tag ^= 1;
        tree[node<<1|1].tag ^= 1;
        tree[node].tag = 0;
    }
}

void build(int node, int l, int r) {
    if(l == r) {
        tree[node].sum = 0;
        return;
    }
    int mid = (l+r)>>1;
    build(node<<1, l, mid);
    build(node<<1|1, mid+1, r);
    pushup(node);
}

void update(int node, int l, int r, int ul, int ur) {
    if(ul <= l && r <= ur) {
        tree[node].sum = (r-l+1)-tree[node].sum;
        tree[node].tag ^= 1;
        return;
    }
    pushdown(node, l, r);
    int mid = (l+r)>>1;
    if(ul <= mid) update(node<<1, l, mid, ul, ur);
    if(ur > mid) update(node<<1|1, mid+1, r, ul, ur);
    pushup(node);
}

int query(int node, int l, int r, int ql, int qr) {
    if(ql <= l && r <= qr) return tree[node].sum;
    pushdown(node, l, r);
    int mid = (l+r)>>1, res = 0;
    if(ql <= mid) res += query(node<<1, l, mid, ql, qr);
    if(qr > mid) res += query(node<<1|1, mid+1, r, ql, qr);
    return res;
}

int main() {
    scanf("%d%d", &n, &m);
    build(1, 1, n);
    while(m--) {
        int op,l,r;
        scanf("%d%d%d", &op, &l, &r);
        if(op == 0) update(1, 1, n, l, r);
        else printf("%d\n", query(1, 1, n, l, r));
    }
    return 0;
}
```

---

# 拓展与应用

## 同类题目推荐
1. **P2574 XOR的艺术** - 几乎相同的操作模式
2. **P2846 光开关** - 二维版本区间反转
3. **P3372 线段树1** - 区间修改基础训练

## 算法变式
当需要支持 **多种混合操作**（如区间加、区间乘、区间反转）时，可通过：
1. 设计复合懒标记结构体
2. 定义操作优先级（如先乘后加）
3. 使用状态机管理标记传播

## 可视化演示代码片段
```javascript
// Canvas绘制线段树节点
function drawNode(x, y, size, state) {
    ctx.fillStyle = state ? "#8BC34A" : "#F44336";
    ctx.fillRect(x, y, size, size);
    if(selectedNode === node) {
        ctx.strokeStyle = "#FFEB3B";
        ctx.lineWidth = 3;
        ctx.strokeRect(x-2, y-2, size+4, size+4);
    }
}

// 播放8-bit音效
function playSFX(type) {
    const sfx = {
        flip: [0,,0.04,,0.2,0.3,,1.5,,,,,,,4],
        query: [1,,200,,0.3,0.6,,1,,,,7,,,,0.7]
    };
    new Audio().play(sfx[type]);
}
```

---

# 学习建议
1. 从 **单点修改** 练起，逐步过渡到区间操作
2. 用纸笔模拟小规模数据（n=4）的执行过程
3. 在可视化工具中单步跟踪标记传播路径
4. 尝试改造代码支持 **混合操作**（如同时支持加值和反转）

通过结合可视化演示与代码实践，可深入理解线段树在区间操作中的精妙设计，为解决更复杂的区间操作问题奠定基础。

---
处理用时：89.12秒
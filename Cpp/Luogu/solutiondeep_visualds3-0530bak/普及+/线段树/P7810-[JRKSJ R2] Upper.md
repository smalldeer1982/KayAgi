# 题目信息

# [JRKSJ R2] Upper

## 题目描述

有 $n$ 张扑克，第 $i$ 张扑克上写有一个正整数 $a_i$。

现在要把扑克划分成若干个合法的连续子段，其中，一个连续子段 $[l,r]$ “合法”当且仅当这个子段同时满足两个条件： 

* $a_l< a_r$
* $\gcd(a_l,a_r)>1$ 

请问最多能划分多少段。如果没有合法的划分方案，输出 $-1$ 即可。

如果您不知道 $\gcd$ 是什么意思，请看“提示”部分。

## 说明/提示

### 数据范围
本题采用捆绑测试。

对于 $100\%$ 的数据，$2\le n\le 10^5$，$1\le a_i\le 10^9$。

| $\text{Subtask}$ | $n\le$ | $a_i\le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $5$ | $10^9$ | 无 | $5$ |
| $2$ | $3\times10^3$ | $10^9$ | 无 | $15$ |
| $3$ | $2\times10^4$ | $10^6$ | 无 | $20$ |
| $4$ | $2\times 10^4$ | $10^9$ | 无 | $10$ |
| $5$ | $10^5$ | $10^9$ | 数据随机 | $10$ |
| $6$ | $10^5$ | $10^9$ | 无 | $40$ |

### 样例解释
对于样例 $1$，有且仅有一种划分方案 $\{2,1,8\},\{3,9\}$。\
对于样例 $2$，无合法的划分方案。

### 提示
对于两个正整数 $a,b$，$\gcd(a,b)$ 为它们的最大公因数，即满足既是 $a$ 的因数又是 $b$ 的因数的数中最大的数。

## 样例 #1

### 输入

```
5
2 1 8 3 9```

### 输出

```
2```

## 样例 #2

### 输入

```
5
5 4 3 2 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
20
20 9 36 36 40 8 3 10 9 20 18 12 30 20 30 15 8 9 27 45```

### 输出

```
7```

# AI分析结果



## 唯一算法分类
动态规划+数论+数据结构优化

---

## 综合分析与结论

### 核心思路
题目要求将序列划分为满足 a_l < a_r 且 gcd(a_l,a_r)>1 的连续子段。通过动态规划 f[i] 表示前 i 个元素的最大分段数，结合质因数分解将 gcd 条件转化为公共质因子存在性，使用权值线段树优化状态转移。

### 解决难点
1. **质因数分解**：预处理 sqrt(1e9) 内的质数，快速分解每个数的质因子
2. **离散化处理**：将大范围 a_i 映射到紧凑区间，降低线段树空间
3. **动态开点线段树**：为每个质因子维护独立线段树，查询比当前值小的最大 f 值
4. **状态转移优化**：O(1) 时间获取每个质因子对应的最优前驱状态

### 可视化设计
- **动画流程**：
  1. 展示质因数分解过程（不同质因子高亮显示）
  2. 动态规划步骤时，用线段树结构展示查询/更新操作
  3. 用颜色区分不同质因子对应的线段树
  4. 步进演示转移路径，显示当前 f[i] 的更新来源
- **复古像素风格**：
  - 用 8-bit 风格显示线段树节点（绿色表示更新节点，红色表示查询范围）
  - 背景播放经典 FC 游戏音效（分解成功时"叮"，转移时"咔"声）
  - Canvas 绘制质因子飘动特效，突出公共因子匹配

---

## 题解清单 (4星及以上)

1. **KazamaRuri（5★）**
   - 亮点：最优解实现，动态开点线段树极致优化
   - 核心代码片段：
     ```cpp
     void upd(int &x,int l,int r,int p,int k){
         if(!x)x=++tot; t[x]=max(t[x],k);
         if(l==r) return;
         int mid=l+r>>1;
         (p<=mid)?upd(lc[x],l,mid,p,k):upd(rc[x],mid+1,r,p,k);
     }
     ```

2. **ZillionX（5★）**
   - 亮点：Exact Division优化质因数分解，时空双重优化
   - 关键优化：
     ```cpp
     if(x*pv[j]<=pm[j]) { // Exact Division判断
         k++,dv[i][k]=j,x*=pv[j];
         while(x*pv[j]<=pm[j]) x*=pv[j];
     }
     ```

3. **Spasmodic（4★）**
   - 亮点：清晰的质因子维护结构，gp_hash_table 优化查询
   - 数据结构设计：
     ```cpp
     unordered_map<int,int> rt; // 质因子到线段树根的映射
     struct node{ int lc,rc,ma; }st[N<<5]; // 动态节点池
     ```

---

## 最优思路提炼

**质因子导向的动态规划**
1. 将 gcd>1 转换为存在公共质因子
2. 对每个质因子维护权值线段树，记录该因子对应的元素值域分布
3. 离散化后，线段树维护比当前值小的最大 f 值
4. 分解当前数的质因子，合并各因子对应线段树的查询结果

**关键优化点**：
- 预处理小质数加速分解
- 动态开点线段树的空间优化
- 离散化压缩值域到 O(n) 级别
- 分解时跳过已处理因子（Exact Division）

---

## 相似题目推荐
1. P1025 数的划分（质因数+动态规划）
2. P2424 约数和（因数维护技巧）
3. P2151 [SDOI2009]HH去散步（动态规划+矩阵优化）

---

## 核心代码实现
```cpp
// 质因数分解（预处理筛法略）
vector<int> get_primes(int x) {
    vector<int> res;
    for(int p : pre_primes) { // 预处理的质数表
        if(p*p > x) break;
        if(x%p == 0) {
            res.push_back(p);
            while(x%p == 0) x /= p;
        }
    }
    if(x > 1) res.push_back(x);
    return res;
}

// 动态规划主循环
for(int i=1; i<=n; i++) {
    auto primes = get_primes(a[i]);
    int max_prev = -INF;
    for(int p : primes) {
        // 查询p对应线段树中 <a[i] 的最大f值
        max_prev = max(max_prev, query_tree(rt[p], a[i]-1)); 
    }
    f[i] = max_prev + 1;
    
    // 将当前状态加入各质因子的线段树
    for(int p : primes) {
        update_tree(rt[p], a[i], f[i-1]);
    }
}
```

---

## 可视化实现要点
```javascript
// Canvas绘制线段树节点（伪代码）
function drawNode(x, y, val, isActive) {
    ctx.fillStyle = isActive ? '#FF5555' : '#55FF55';
    ctx.fillRect(x*50, y*50, 40, 40);
    ctx.fillText(val, x*50+10, y*50+20);
}

// 音效触发
function playSound(type) {
    if(type === 'query') beep(440, 50);
    if(type === 'update') beep(880, 30);
}
```

---
处理用时：74.47秒
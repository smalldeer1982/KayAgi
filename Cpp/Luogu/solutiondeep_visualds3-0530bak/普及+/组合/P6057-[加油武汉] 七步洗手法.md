# 题目信息

# [加油武汉] 七步洗手法

## 题目背景

现在正处于疫情防控的关键时期，大家要经常洗手，防止接触感染。

[正确的洗手方法](https://dxy.com/column/4473)

## 题目描述

给定一张含有 $n$ 个点的无向完全图，其中 $m$ 条边是白边，其余是黑边。

现在需要你求出同色的三元环（或者说，三角形）的个数。

## 说明/提示

 - 对于 $20\%$ 的数据，满足 $n \leq 200$；
 - 对于 $50\%$ 的数据，满足 $n \leq 2000$；
 - 对于 $100\%$ 的数据，满足 $1 \leq n \leq 10^5,1 \leq m \leq 3\times 10^5$。

## 样例 #1

### 输入

```
5 3
1 5
2 5
3 5```

### 输出

```
4```

# AI分析结果



---

## 算法分类
**组合数学/补集思想**

---

## 题解思路与解决难点

### 核心思路
**补集转化**：总三元环数（$\binom{n}{3}$）减去异色三元环数。  
异色三元环数的计算：每个点统计其连接的**白边数**与**黑边数**的乘积（异色角数），所有点异色角数之和除以2即为异色三元环数。

### 解决难点
1. **暴力不可行**：直接枚举三元组时间复杂度 $O(n^3)$，无法处理 $n \leq 1e5$ 的规模。  
2. **异色三元环的巧妙计算**：通过每个点的异色角数之和除以2，将复杂度降为 $O(n+m)$。  
3. **避免重复统计**：异色三角形被两个顶点各统计一次，故需除以2。

---

## 题解评分（≥4星）

1. **未见堇开（⭐⭐⭐⭐⭐）**  
   - **亮点**：思路清晰，补集转化直接，代码简洁高效。  
   - **关键代码**：遍历每个点计算 `deg[i]*(n-1-deg[i])`，总和除以2。  
   ```cpp
   for(reg int i=1;i<=n;i++)
       ans += (1ll*deg[i]*(n-1-deg[i]));
   printf("%lld",1ll*n*(n-1)*(n-2)/6 - (ans>>1));
   ```

2. **Star_Wind（⭐⭐⭐⭐）**  
   - **亮点**：代码简洁，数学推导明确，强调 `long long` 的重要性。  
   - **关键代码**：同思路，使用 `vector` 存储白边信息。  
   ```cpp
   sum += (v[i].size() * (n - v[i].size() - 1));
   cout << (ll)n*(n-1)*(n-2)/6 - sum/2;
   ```

3. **Skyjoy（⭐⭐⭐⭐）**  
   - **亮点**：代码极简，强调 `long long` 的必要性。  
   - **关键代码**：直接统计每个点的贡献。  
   ```cpp
   for(int i=1;i<=n;i++)
       cnt += e[i]*(n - e[i] - 1);
   printf("%lld", ans - cnt/2);
   ```

---

## 最优思路提炼

1. **补集思想**：将问题转化为总三元环数减去异色三元环数。  
2. **异色角统计**：每个点的异色角数为其白边数与黑边数的乘积。  
3. **除法消重**：异色三元环被两个顶点各统计一次，总和需除以2。

---

## 类似题目推荐

1. **P1989 三元环计数**：求无向图中三元环数量。  
2. **P3761 [TJOI2017]城市**：图论中补集思想的扩展应用。  
3. **P3452 [POI2007]BIU-Offices**：利用补图性质优化问题。

---

## 可视化设计

### 动画方案
1. **像素风格展示**：  
   - **节点与边**：用8位像素方块表示节点，白边用浅色线条，黑边用深色线条。  
   - **异色角高亮**：当统计某点时，其白边和黑边闪烁，计算乘积时显示数值。  
   - **累加效果**：总和在屏幕底部以像素数字动态增长，除以2时显示分步动画。  

2. **交互控制**：  
   - **步进执行**：允许单步观察每个点的贡献计算。  
   - **速度调节**：滑动条控制动画速度（1x, 2x, 5x）。  
   - **音效反馈**：计算异色角时播放“滴”声，完成时播放胜利音效。  

3. **伪代码演示**：  
   ```plaintext
   1. 初始化所有节点为灰色
   2. 遍历每个节点i:
      a. 高亮节点i
      b. 显示其白边数(deg[i])和黑边数(n-1-deg[i])
      c. 计算乘积并累加到总和
      d. 恢复节点i颜色
   3. 显示最终总和除以2的动画
   4. 总三元环数减去异色数，结果爆炸式呈现
   ```

---

## 核心代码实现

```cpp
#include <cstdio>
#define MAXN 100001
using namespace std;
typedef long long ll;

int deg[MAXN], n, m;

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        deg[u]++, deg[v]++; // 统计每个点的白边数
    }
    ll illegal = 0;
    for (int i = 1; i <= n; i++)
        illegal += 1LL * deg[i] * (n - 1 - deg[i]);
    ll total = 1LL * n * (n-1) * (n-2) / 6;
    printf("%lld\n", total - illegal / 2);
    return 0;
}
```

---

**武汉加油！算法之美，在于化繁为简。**

---
处理用时：90.59秒
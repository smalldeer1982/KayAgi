# 题目信息

# 路径计数2

## 题目描述

一个 $N \times N$ 的网格，你一开始在 $(1,1)$，即左上角。每次只能移动到下方相邻的格子或者右方相邻的格子，问到达 $(N,N)$，即右下角有多少种方法。

但是这个问题太简单了，所以现在有 $M$ 个格子上有障碍，即不能走到这 $M$ 个格子上。


## 说明/提示

对于 $20\%$ 的数据，有$N≤3$；

对于 $40\%$ 的数据，有$N≤100$；

对于 $40\%$ 的数据，有$M=0$；

对于 $100\%$ 的数据，有$N≤1000,M≤100000$。


## 样例 #1

### 输入

```
3 1
3 1```

### 输出

```
5```

# AI分析结果



# 算法分类
动态规划

# 题解思路与难点分析
## 核心算法
动态规划递推式：`dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD`，障碍点直接置零。难点在于处理边界条件和障碍标记顺序。

## 关键实现对比
1. **初始化方式**：
   - 佳铭题解通过`dp[0][1]=1`巧妙统一边界处理
   - Jimmy000在循环中处理初始化，需要特殊判断首行首列
2. **障碍处理时机**：
   - 正确做法应先判断障碍，若为障碍则直接置零不计算
   - 部分题解先计算路径数再置零，虽结果正确但冗余计算
3. **取模方式**：
   所有题解均在每一步累加后取模，防止数值溢出

# 高星题解推荐
1. **Jimmy000（4.5星）**  
   代码结构清晰，统一处理障碍和取模，但初始化稍显繁琐  
   ```cpp
   for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++) {
        a[i][j] += a[i-1][j]+a[i][j-1];
        if(b[i][j]==1) a[i][j]=0;
        a[i][j] %= 100003;
    }
   ```
2. **佳铭（4.5星）**  
   创新性边界初始化，代码简洁  
   ```cpp
   f[0][1] = 1; // 统一初始化
   for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j) {
        if(vis[i][j]) continue;
        f[i][j] = (f[i-1][j] + f[i][j-1]) % MOD;
    }
   ```
3. **wcl95716（4星）**  
   完整处理边界障碍，可读性强  
   ```cpp
   for(int i=1;i<=n;i++) {
    if(!f[1][i]) sum[1][i]=1;
    else break; // 遇到障碍即终止边界初始化
   }
   ```

# 最优思路提炼
1. **动态规划模板**  
   使用二维数组存储路径数，递推式`dp[i][j] = 左路径 + 上路径`
2. **障碍标记技巧**  
   预处理障碍点，在递推时直接跳过或置零
3. **高效边界处理**  
   通过`dp[0][1] = 1`或`break`处理边界障碍，避免冗余循环

# 同类题目推荐
1. P1002 [NOIP2002 普及组] 过河卒
2. P1176 路径计数（无障碍基础版）
3. P1121 环状最大两段子段和（类似状态转移思维）

# 可视化算法演示
## 动画设计
1. **网格绘制**  
   1000x1000网格，障碍点用红色标记，路径数实时更新显示
2. **递推过程**  
   从左到右、从上到下遍历，当前处理单元格高亮黄色，左/上单元格高亮蓝色
3. **数值变化**  
   数值变化时播放清脆音效，遇到障碍播放低沉音效
4. **复古风格**  
   采用8-bit像素风格，路径数以绿色数字动态跳变显示

## 控制面板功能
- 步进/连续模式切换
- 障碍分布随机生成
- 执行速度滑块（1x-10x）
- 网格缩放控件

# 核心代码实现
```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int MOD = 100003;
int dp[1005][1005], obs[1005][1005];

int main() {
    int n, m;
    cin >> n >> m;
    
    // 标记障碍
    while(m--) {
        int x, y;
        cin >> x >> y;
        obs[x][y] = 1;
    }

    // 动态规划初始化
    dp[0][1] = 1; // 巧妙边界处理
    
    for(int i=1; i<=n; ++i) {
        for(int j=1; j<=n; ++j) {
            if(obs[i][j]) {
                dp[i][j] = 0;
                continue;
            }
            dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD;
        }
    }
    cout << dp[n][n];
    return 0;
}
```

---
处理用时：131.47秒
# 题目信息

# 排队接水

## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。


## 说明/提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。


## 样例 #1

### 输入

```
10 
56 12 1 99 1000 234 33 55 99 812```

### 输出

```
3 2 7 8 1 4 9 6 10 5
291.90
```

# AI分析结果



### 唯一算法分类
贪心算法

---

### 题解思路与算法要点

#### 核心算法逻辑
1. **贪心策略**：将接水时间短的人排在前面，使得后续所有人的等待时间总和最小化。
2. **数学推导**：若相邻两人接水时间满足 $a < b$，则 $a$ 在前时的总等待时间更优（$a$ 贡献的等待时间更少）。
3. **数据结构**：使用结构体或 pair 保存编号和接水时间，按时间排序后输出编号。
4. **总时间计算**：第 $i$ 个人的接水时间会被后续 $(n-i)$ 人等待，总时间为 $\sum_{i=1}^{n} t_i \cdot (n-i)$。

#### 解决难点
- **保持原始序号**：排序后需保留原始编号，常见方法包括结构体、pair 或数值编码（如乘大数后取模）。
- **避免精度丢失**：总时间需用 `double` 或 `long long` 存储，避免整数溢出或浮点误差。

---

### 题解评分（≥4星）

| 作者          | 星级 | 关键亮点                                                                 |
|---------------|------|--------------------------------------------------------------------------|
| 无乐鸦        | ★★★★☆ | 数学证明清晰，深入推导贪心策略的正确性。                                 |
| BlueArc        | ★★★★☆ | 结构体排序实现简洁，公式推导直观。                                       |
| Anguei         | ★★★★☆ | 使用 pair 和 STL 默认排序，代码简洁高效。                                |

---

### 最优思路与技巧
1. **贪心策略证明**：通过相邻元素交换法证明局部最优可推导全局最优。
2. **数值编码技巧**（f112358）：  
   ```cpp
   t[i] = x * 1001 + i;  // 排序后取模得原始序号
   ```
3. **高效时间计算**：总时间公式 $\text{sum} += t[i] \cdot (n-i)$，避免双重循环。

---

### 相似题目推荐
1. **P1090 合并果子**（贪心 + 优先队列）  
2. **P1208 混合牛奶**（贪心选择单价最低）  
3. **P2240 部分背包问题**（按性价比贪心）

---

### 代码核心片段
```cpp
// BlueArc 的结构体实现
struct a { int b, num; };
bool cmp(a x, a y) { return x.b < y.b; }

sort(a+1, a+n+1, cmp);
for (int j=1; j<=n; j++) sum += a[j].b * (n-j);
```

```cpp
// Anguei 的 pair 实现
std::pair<int, int> a[n];
sort(a, a+n);
for (int i=0; i<n; i++) sum += a[i].first * (n-i-1);
```

---

### 可视化算法演示设计
1. **动画流程**：
   - **排序阶段**：用色块表示每个人的接水时间，动态展示冒泡或快排过程，每次交换后更新编号位置。
   - **时间计算阶段**：高亮当前处理的人，显示其时间对总时间的贡献值 $(n-i) \cdot t_i$。

2. **复古像素风格**：
   - **颜色方案**：绿色表示已排序部分，红色表示当前操作元素，黄色表示未排序部分。
   - **音效设计**：交换时播放“哔”声，计算总时间时播放“滴答”声，完成时播放胜利音效。

3. **交互功能**：
   - **步进控制**：允许暂停/继续，拖动进度条回溯步骤。
   - **自动演示**：AI 自动运行算法，速度可调（1x/2x/5x）。

---

### 个人心得摘录
> **冷、雨夜**：  
> “公式推导时一开始没注意乘的是 $(n-i)$，调试半天才发现是反向计数。”  
> **Sinwind**：  
> “用 pair 代替结构体让代码更简洁，但需注意默认排序规则。”

---

### 总结
本题通过贪心策略将问题转化为排序问题，关键点在于正确保留序号和高效计算总时间。不同实现方式在代码简洁性和效率上各有优劣，核心思想一致。可视化设计通过动态排序和分步计算，可直观展示算法核心逻辑。

---
处理用时：59.73秒
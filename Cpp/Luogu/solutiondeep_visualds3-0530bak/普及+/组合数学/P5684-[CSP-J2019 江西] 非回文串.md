# 题目信息

# [CSP-J2019 江西] 非回文串

## 题目描述

Alice 有 $n$ 个字符，它们都是英文小写字母，从 $1 \sim n$ 编号，分别为 $c_1,c_2, \dots , c_n$。  
Bob 准备将这些字符重新排列，组成一个字符串 $S$。Bob 知道 Alice 有强迫症，所以他打算将 $S$ 组成一个非回文串来折磨 Alice。  

现在 Bob 想知道他共有多少种不同的排列字符的方案，能使得 $S$ 是个非回文串。一种排列字符的方案指的是一个 $1 \sim n$ 的排列 $p_i$，它所组成的 $S = c_{p_1}c_{p_2} \dots c_{p_n}$。

一个字符串是非回文串，当且仅当它的逆序串与原串不同。例如 `abcda` 的逆序串为 `adcba`，与原串不同，故 `abcda` 是非回文串。而 `abcba` 的逆序串与原串相同，是回文串。

由于最后的结果可能很大，你只需要告诉 Bob 总方案数对 $10^9+7$ 取模后的值。

## 说明/提示

【数据范围】  
对于 $20\%$ 的数据，$n \le 8$；  
对于 $50\%$ 的数据，$n \le 20$；  
另有 $30\%$ 的数据，字符只包含 `a` 和 `b`；  
对于 $100\%$ 的数据，$3 \le n \le 2000$。

## 样例 #1

### 输入

```
3
aba```

### 输出

```
4```

## 样例 #2

### 输入

```
8
aabbbbcc```

### 输出

```
39168```

# AI分析结果



## 算法分类  
组合数学

---

## 题解思路与算法要点  
**核心思路**：总排列数 $n!$ 减去回文串排列数。回文串需满足字符出现次数奇偶性条件，计算时需处理对称结构。

**关键步骤**：
1. **总排列数**：直接计算 $n!$，取模。
2. **回文串条件**：  
   - 统计字符出现次数，奇数次数字符最多1个。  
   - 奇数字符超过1时，回文串数为0，答案直接为$n!$。  
3. **回文串计算**：  
   - 偶数次字符：将次数减半，计算对称排列。  
   - 奇数次字符：选一个作为中间字符，剩余次数处理为偶数。  
   - 公式：$(n/2)! \times \prod \frac{a_i!}{(a_i/2)!}$，若有奇数字符则乘其出现次数。  

**解决难点**：  
- 组合数的模运算处理，需预处理阶乘和逆元。  
- 奇偶情况的统一处理，避免重复计算。  

---

## 题解评分 (≥4星)  
1. **NaCly_Fish** ⭐⭐⭐⭐⭐  
   - 思路清晰，代码简洁高效。  
   - 预处理阶乘与逆元，直接推导公式实现。  
   - 处理奇偶情况逻辑明确，时间复杂度O(n)。  

2. **旭日临窗** ⭐⭐⭐⭐  
   - 详细推导回文串排列公式，分步解释组合数原理。  
   - 代码中使用费马小定理求逆元，结构清晰。  

3. **FJ_EYoungOneC** ⭐⭐⭐⭐  
   - 模块化处理阶乘函数，代码可读性强。  
   - 特判奇数次数字符超过1的情况，逻辑完整。  

---

## 最优思路提炼  
1. **预处理优化**：  
   预处理阶乘数组 `fac` 和逆元数组 `ifac`，快速计算组合数。  
2. **奇偶统一处理**：  
   通过奇数次数字符统计，统一处理中间字符选择，简化代码。  
3. **公式化简**：  
   利用排列数公式 $\frac{a_i!}{(a_i/2)!}$ 避免重复计算对称结构。  

---

## 相似题目推荐  
1. **P3807 【模板】卢卡斯定理**（组合数模运算）  
2. **P1495 曹冲养猪**（模运算与逆元应用）  
3. **P1066 [NOIP2006 提高组] 2^k进制数**（组合数计算与排列限制）  

---

## 个人心得摘录  
- **逆元计算**：多题解使用费马小定理求逆元，注意模数为质数。  
- **负数取模**：计算结果可能为负，需 `(ans + mod) % mod` 处理。  
- **中间字符选择**：奇数次数字符的剩余次数处理需先减1，避免遗漏。  

---

## 算法可视化设计  
**核心逻辑动画**：  
1. **回文结构展示**：  
   - 左右对称网格，中间位置高亮（若n为奇数）。  
   - 字符块动态分配到左右两侧，颜色区分不同字符。  
2. **阶乘与逆元计算**：  
   - 显示阶乘数组生成过程，逆元计算时的快速幂动画。  
3. **奇偶检查交互**：  
   - 统计字符次数时，奇数次数字符闪烁提示，超过1个时播放错误音效。  

**复古像素风格**：  
- **8位调色板**：字符块用16色像素风格，背景循环播放芯片音乐。  
- **音效设计**：  
  - 正确计算时播放8位“胜利”音效。  
  - 错误时播放短促“失败”音调。  

**Canvas交互**：  
- 用户可拖动字符调整排列，实时显示回文校验结果。  
- 自动演示模式逐步展示阶乘、组合数计算步骤。  

---

## 关键代码实现  
```cpp
#include<cstdio>
#include<algorithm>
#define ll long long
#define N 2003
#define p 1000000007
using namespace std;

int n, fac[N], ifac[N], cnt[26];
char a[N];

int power(int a, int t) {
    int res = 1;
    while (t) {
        if (t & 1) res = (ll)res * a % p;
        a = (ll)a * a % p;
        t >>= 1;
    }
    return res;
}

int main() {
    scanf("%d%s", &n, a + 1);
    // 预处理阶乘和逆元
    fac[0] = 1;
    for (int i = 1; i <= n; ++i) fac[i] = (ll)fac[i-1] * i % p;
    ifac[n] = power(fac[n], p-2);
    for (int i = n-1; i >= 0; --i) ifac[i] = (ll)ifac[i+1] * (i+1) % p;
    
    // 统计字符次数
    for (int i = 1; i <= n; ++i) cnt[a[i]-'a']++;
    
    // 检查奇数次数字符
    int odd = 0;
    for (int i = 0; i < 26; ++i) odd += cnt[i] & 1;
    if (odd > 1) {
        printf("%d", fac[n]);
        return 0;
    }
    
    // 计算回文串数目
    int dec = (n % 2) ? 1 : 0;
    for (int i = 0; i < 26; ++i) {
        if (cnt[i] & 1) dec = cnt[i];
        cnt[i] >>= 1;
    }
    dec = (ll)dec * fac[n/2] % p;
    for (int i = 0; i < 26; ++i)
        dec = (ll)dec * fac[cnt[i]*2] % p * ifac[cnt[i]] % p;
    
    printf("%d", (fac[n] - dec + p) % p);
    return 0;
}
```  
**代码要点**：  
- 预处理阶乘和逆元，快速计算组合数。  
- 奇数次数字符处理与回文数计算一体化完成，代码简洁高效。

---
处理用时：98.49秒
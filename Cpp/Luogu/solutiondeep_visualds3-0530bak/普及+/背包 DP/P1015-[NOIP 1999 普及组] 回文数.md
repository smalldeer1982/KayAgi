# 题目信息

# [NOIP 1999 普及组] 回文数

## 题目描述

若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。

例如：给定一个十进制数 $56$，将 $56$ 加 $65$（即把 $56$ 从右向左读），得到 $121$ 是一个回文数。

又如：对于十进制数 $87$：

STEP1：$87+78=165$  
STEP2：$165+561=726$  
STEP3：$726+627=1353$   
STEP4：$1353+3531=4884$  

在这里的一步是指进行了一次 $N$ 进制的加法，上例最少用了 $4$ 步得到回文数 $4884$。

写一个程序，给定一个 $N$（$2 \le N \le 10$ 或 $N=16$）进制数 $M$（$100$ 位之内），求最少经过几步可以得到回文数。如果在 $30$ 步以内（包含 $30$ 步）不可能得到回文数，则输出 `Impossible!`。

## 样例 #1

### 输入

```
10
87
```

### 输出

```
STEP=4
```

# AI分析结果



### **算法分类**  
模拟 + 高精度运算

---

### **题解思路与核心难点**  
**核心逻辑**：  
1. **模拟 N 进制加法**：将输入视为字符串，处理每一位的加法（注意进位规则从 `%10` 改为 `%N`）。  
2. **回文判断**：直接比较字符串与其反转后的结果是否相同。  
3. **步数控制**：最多执行 30 次加法，超过则输出 `Impossible!`。  

**解决难点**：  
1. **进制处理**：需支持 2~10 进制和 16 进制（字母 `A-F` 对应数字 10~15）。  
2. **高精度实现**：字符串操作避免数值溢出，正确处理进位与反转。  
3. **模块化设计**：拆分回文判断、加法操作为独立函数，提升代码复用性。  

---

### **题解评分 (≥4星)**  
1. **Haishu (★★★★★)**  
   - **亮点**：模块化设计清晰，代码结构简洁，处理进位和回文判断高效。  
   - **关键代码**：  
     ```cpp  
     bool pd() {  
         for (int i=0; i<l; ++i)  
             if (c[i] != c[l-1-i]) return false;  
         return true;  
     }  
     ```  

2. **hawa130 (★★★★☆)**  
   - **亮点**：利用 `reverse` 函数简化回文判断，支持动态进位扩展。  
   - **关键代码**：  
     ```cpp  
     string add(int k, string b) {  
         reverse(a.begin(), a.end());  
         for (int i=0; i<len; i++) {  
             numa[i] = (a[i] >= 'A') ? a[i]-'A'+10 : a[i]-'0';  
             // ... 高精度加法  
         }  
     }  
     ```  

3. **pantw (★★★★☆)**  
   - **亮点**：通过 `vector` 存储数字，直接操作数组实现快速反转和加法。  
   - **关键代码**：  
     ```cpp  
     void add(int a[], int b[]) {  
         for (int i=1; i<=l; i++) {  
             a[i] += b[i];  
             a[i+1] += a[i]/n;  
             a[i] %= n;  
         }  
     }  
     ```  

---

### **最优思路与技巧**  
1. **进制统一处理**：将字母 `A-F` 转换为数字 10~15，避免复杂判断。  
2. **原位反转相加**：直接操作数组，无需额外空间存储反转结果。  
3. **动态进位处理**：通过 `l += (进位存在)` 动态调整位数，避免固定长度限制。  

---

### **同类型题与推荐题目**  
1. **P1010 [NOIP1998 普及组] 幂次方**（高精度与递归结合）  
2. **P1601 A+B Problem（高精）**（高精度加法模板题）  
3. **P1005 [NOIP2007 提高组] 矩阵取数游戏**（高精度与动态规划结合）  

---

### **个人心得摘录**  
- **Haishu**：  
  > “利用函数拆分加法与回文判断，大大简化主程序逻辑，调试时更容易定位错误。”  
- **Strong_Jelly**：  
  > “将反转后的数直接存入新数组，避免指针混乱，是处理高精度加法的关键。”  

---

### **可视化与算法演示**  
**核心逻辑动画设计**：  
1. **像素风格可视化**：  
   - **颜色标记**：当前处理位（红色）、进位（黄色）、回文匹配位（绿色）。  
   - **网格布局**：将数字每位显示为像素块，动态展示加法过程。  

2. **音效与交互**：  
   - **关键操作音**：加法步骤（短促“滴”声），回文匹配（上扬音调）。  
   - **步进控制**：允许暂停/继续，调整动画速度观察进位细节。  

**动画伪代码**：  
```javascript  
function visualizeAdd(a, b, base) {  
    let carry = 0;  
    for (let i = 0; i < a.length; i++) {  
        highlight(a[i], 'red'); // 当前位高亮  
        let sum = a[i] + b[i] + carry;  
        carry = Math.floor(sum / base);  
        drawStep(sum % base, i);  
    }  
    if (carry > 0) {  
        addNewPixel(carry, 'yellow'); // 新增进位位  
    }  
}  
```  

---

### **完整代码示例 (Haishu 题解)**  
```cpp  
#include <cstdio>  
#include <cstring>  
const int S=303;  
int n, a[S], l;  
char c[S], d[S];  

inline void add() {  
    for (int i=0; i<l; ++i) d[l-i-1] = c[i];  
    l += 2;  
    for (int i=0; i<l; ++i) {  
        c[i] += d[i];  
        if (c[i] >= n) c[i+1]++, c[i]-=n;  
    }  
    while (!c[l-1]) --l;  
}  

inline bool pd() {  
    for (int i=0; i<l; ++i)  
        if (c[i] != c[l-1-i]) return false;  
    return true;  
}  

int main() {  
    scanf("%d%s", &n, c);  
    l = strlen(c);  
    for (int i=0; i<l; ++i) {  
        if (c[i] >= '0' && c[i] <= '9') c[i] -= '0';  
        else c[i] = c[i]-'A'+10;  
    }  
    int step=0;  
    while (!pd()) {  
        if (++step > 30) break;  
        add();  
    }  
    if (step <= 30) printf("STEP=%d\n", step);  
    else puts("Impossible!");  
    return 0;  
}  
```  

--- 

**可视化效果示例**：  
![回文数生成动画](https://via.placeholder.com/600x400/000000/FFFFFF?text=Pixel+Animation+Here)  
（设想：动态显示每一位的相加与进位过程，红色高亮当前操作位，绿色标记回文匹配位。）

---
处理用时：80.68秒
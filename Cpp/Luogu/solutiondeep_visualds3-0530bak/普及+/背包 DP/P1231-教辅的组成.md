# 题目信息

# 教辅的组成

## 题目背景

滚粗了的 HansBug 在收拾旧语文书，然而他发现了什么奇妙的东西。


## 题目描述

蒟蒻 HansBug 在一本语文书里面发现了一本答案，然而他却明明记得这书应该还包含一份练习题。然而出现在他眼前的书多得数不胜数，其中有书，有答案，有练习册。已知一个完整的书册均应该包含且仅包含一本书、一本练习册和一份答案，然而现在全都乱做了一团。许多书上面的字迹都已经模糊了，然而 HansBug 还是可以大致判断这是一本书还是练习册或答案，并且能够大致知道一本书和答案以及一本书和练习册的对应关系（即仅仅知道某书和某答案、某书和某练习册有可能相对应，除此以外的均不可能对应）。既然如此，HansBug 想知道在这样的情况下，最多可能同时组合成多少个完整的书册。



## 说明/提示

样例说明：

如题，$N_1=5$，$N_2=3$，$N_3=4$，表示书有 $5$ 本、练习册有 $3$ 本、答案有 $4$ 本。

$M_1=5$，表示书和练习册共有 $5$ 个可能的对应关系，分别为：书 $4$ 和练习册 $3$ 、书 $2$ 和练习册 $2$ 、书 $5$ 和练习册 $2$ 、书 $5$ 和练习册 $1$ 以及书 $5$ 和练习册 $3$。

$M_2=5$，表示数和答案共有 $5$ 个可能的对应关系，分别为：书 $1$ 和答案 $3$、书 $3$ 和答案 $1$、书 $2$ 和答案 $2$、书 $3$ 和答案 $3$ 以及书 $4$ 和答案 $3$。

所以，以上情况的话最多可以同时配成两个书册，分别为：书 $2$ 练习册 $2$ 答案 $2$、书 $4$ 练习册 $3$ 答案 $3$。


数据规模：

![](https://cdn.luogu.com.cn/upload/image_hosting/srj2v9um.png)

对于数据点 $1,2,3$，$1\le M_1,M_2\leq 20$。

对于数据点 $4\sim 10$，$1\le M_1,M_2 \leq 20000$。


## 样例 #1

### 输入

```
5 3 4
5
4 3
2 2
5 2
5 1
5 3
5
1 3
3 1
2 2
3 3
4 3
```

### 输出

```
2```

# AI分析结果



# 算法分类
网络流（最大流）中的拆点技巧

# 题解思路与难点分析

### 核心算法流程
1. **拆点建模**：将每本书拆分为入点和出点，中间连一条容量为1的边
2. **三层网络结构**：源点→练习册→书入点→书出点→答案→汇点
3. **边容量设置**：
   - 源点到练习册的边容量为1（每本练习册只能用一次）
   - 答案到汇点的边容量为1（每本答案只能用一次）
   - 书入点到书出点的边容量为1（每本书只能用一次）
4. 关键变量示例：
   ```cpp
   // 书x的入点编号：x+n2
   // 书x的出点编号：x+n2+n1
   add_edge(书入点, 书出点, 1); // 拆点边
   ```

### 解决难点
1. **书节点复用问题**：通过拆点将流量限制为1，确保每本书只能被选中一次
2. **大规模数据优化**：使用Dinic算法+当前弧优化处理2e4级别的边数
3. **三层关系映射**：
   - 练习册与书的入点相连
   - 书的出点与答案相连
   - 拆点边控制核心限制

# 题解评分（≥4星）
1. **Siyuan（★★★★★）**
   - 亮点：完整图解拆点原理，代码规范可读，时间复杂度分析明确
   - 关键代码段：
     ```cpp
     for(int i=1;i<=n1;++i) addedge(id(2,i),id(3,i),1); // 拆点边
     ```
2. **localhost（★★★★☆）**
   - 亮点：手绘流程图辅助理解，详细注释节点编号逻辑
   - 代码亮点：
     ```cpp
     // 练习册编号：2~n2+1
     // 书入点：n2+2~n2+n1+1 
     ```
3. **ViXpop（★★★★☆）**
   - 亮点：完整变量命名注释，包含详细调试经历描述
   - 关键注释：
     ```cpp
     // orz = 2 * n + m + k 总节点数
     // 练习册边：add(n2+2*n1+i, T, 1)
     ```

# 算法可视化设计
### 8位像素风格演示
1. **颜色方案**：
   - 红色：源点/汇点
   - 绿色：练习册节点
   - 蓝色：书入点
   - 黄色：书出点
   - 紫色：答案节点
2. **动画逻辑**：
   - 网格布局：
     ```
     [源点] → [练习册1] [练习册2]... → 
     [书1入]→[书1出] [书2入]→[书2出]... → 
     [答案1] [答案2]... → [汇点]
     ```
   - 流动特效：像素方块沿有效边移动，拆点边变灰后禁止反向流动
3. **音效设计**：
   - "滴"声：正常流过边
   - "咔嚓"声：拆点边被占用
   - 胜利音效：汇点累计流量刷新

# 核心代码实现
```cpp
// Dinic算法核心（带当前弧优化）
int bfs(int s, int t) {
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head)); // 当前弧优化
    queue<int> q;
    q.push(s);
    dep[s] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].to;
            if (!dep[v] && e[i].w > 0) {
                dep[v] = dep[u] + 1;
                q.push(v);
            }
        }
    }
    return dep[t];
}

int dfs(int u, int t, int flow) {
    if (u == t) return flow;
    int res = 0;
    for (int &i = cur[u]; i; i = e[i].next) { // 引用当前弧
        int v = e[i].to;
        if (dep[v] == dep[u] + 1 && e[i].w > 0) {
            int k = dfs(v, t, min(flow, e[i].w));
            if (k > 0) {
                e[i].w -= k;
                e[i^1].w += k;
                res += k;
                flow -= k;
                if (!flow) break;
            }
        }
    }
    return res;
}
```

# 相似题目推荐
1. P1402 酒店之王（三分图匹配+拆点）
2. P2764 最小路径覆盖问题（DAG拆点）
3. P3254 圆桌问题（多重匹配+流量分配）

# 调试经验总结
- **拆点边忘记添加**：导致书节点重复使用，WA第一个测试点
- **节点编号错误**：练习册/答案的偏移量计算错误，建议封装编号函数
- **反向边漏加**：网络流必须成对加边，建议封装add_edge函数

通过拆点技巧将节点选择转化为边容量限制，是网络流建模中的经典手法，值得深入理解其思想。

---
处理用时：83.28秒
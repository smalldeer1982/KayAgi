# 题目信息

# 多米诺骨牌

## 题目描述

多米诺骨牌由上下 $2$ 个方块组成，每个方块中有 $1\sim6$ 个点。现有排成行的上方块中点数之和记为 $S_1$，下方块中点数之和记为 $S_2$，它们的差为 $\left|S_1-S_2\right|$。如图，$S1=6+1+1+1=9$，$S2=1+5+3+2=11$，$\left|S_1-S_2\right|=2$。每个多米诺骨牌可以旋转 $180°$，使得上下两个方块互换位置。请你计算最少旋转多少次才能使多米诺骨牌上下 $2$ 行点数之差达到最小。

![](https://cdn.luogu.com.cn/upload/pic/91.png)

对于图中的例子，只要将最后一个多米诺骨牌旋转 $180°$，即可使上下 $2$ 行点数之差为 $0$。

## 样例 #1

### 输入

```
4
6 1
1 5
1 3
1 2
```

### 输出

```
1
```

# AI分析结果



# 多米诺骨牌题解分析

## 算法分类
**动态规划（背包问题变种）**

---

## 题解核心思路与难点分析

### 动态规划解法要点
1. **状态设计**：  
   `f[i][j]` 表示前i个骨牌，第一行点数总和为j时的最小翻转次数。  
   **关键点**：总和范围由骨牌点数决定（最多6*N），需处理负数通过偏移量转为正下标。

2. **转移方程**：
   ```cpp
   // 不翻转当前骨牌
   if (j - a[i] >= 0) f[i][j] = min(f[i][j], f[i-1][j-a[i]]);
   // 翻转当前骨牌（代价+1）
   if (j - b[i] >= 0) f[i][j] = min(f[i][j], f[i-1][j-b[i]] + 1);
   ```

3. **空间优化**：  
   使用滚动数组（两行交替）将空间复杂度从O(N^2)降至O(N)。

4. **负数处理**：  
   差值可能为负数，通过增加固定偏移量（如+5000）转为正下标。

---

## 高星题解推荐（≥4★）

### 1. fy0123（★★★★★）
**亮点**：  
- 清晰定义状态 `f[i][j]` 为前i个骨牌上总和j的最小翻转次数  
- 完整代码展示初始化、转移、答案求解全流程  
- 处理负数通过总和范围自然解决

### 2. dj114133643（★★★★☆）
**亮点**：  
- 使用差值作为状态维度，直观体现问题本质  
- 核心代码简洁，仅10行实现关键转移逻辑  
- 通过偏移量处理负数下标

### 3. 皎月半洒花（★★★★☆）
**亮点**：  
- 明确使用滚动数组优化空间  
- 代码模板化，适合快速移植  
- 状态转移方程采用对称式写法，易于理解

---

## 最优思路提炼

### 关键技巧
1. **状态压缩**：  
   通过滚动数组将二维DP压缩为一维，极大节省内存。
   
2. **差值转移**：  
   每个骨牌的贡献是固定差值，翻转操作等价于改变差值符号。

3. **对称搜索**：  
   最终答案在差值绝对值最小时，需同时检查正负对称点。

---

## 类似题目推荐
1. **P1064 金明的预算方案**（背包变种）  
2. **P1156 垃圾陷阱**（状态转移与时间维度结合）  
3. **P1877 音量调节**（差值型动态规划）

---

## 可视化设计

### 核心算法演示（Canvas动画）
1. **网格绘制**：  
   - X轴表示骨牌序号，Y轴表示差值（偏移后）  
   - 每个格子颜色深浅表示翻转次数（深色=次数少）

2. **关键帧**：  
   ```javascript
   // 示例伪代码
   function drawStep(i, j) {
     ctx.fillStyle = `hsl(240, ${100 - dp[i][j]*10}%, 50%)`;
     ctx.fillRect(j * cellWidth, i * cellHeight, cellWidth, cellHeight);
   }
   ```
3. **音效触发**：  
   - 发现更优解时播放 "ding" 音效  
   - 完成最终答案时播放 8-bit 胜利音效

---

## 核心代码片段（DP实现）
```cpp
const int N = 1000, OFFSET = 5000;
int dp[2][OFFSET*2]; // 滚动数组

memset(dp, 0x3f, sizeof(dp));
dp[0][OFFSET] = 0; // 初始状态

for (int i = 1; i <= n; ++i) {
  int cur = i % 2, prev = 1 - cur;
  memset(dp[cur], 0x3f, sizeof(dp[cur]));
  
  for (int j = 0; j <= OFFSET*2; ++j) {
    if (j >= a[i]) 
      dp[cur][j] = min(dp[cur][j], dp[prev][j - a[i]]);
    if (j >= b[i])
      dp[cur][j] = min(dp[cur][j], dp[prev][j - b[i]] + 1);
  }
}

// 寻找最小差值
int min_diff = INF, ans = INF;
for (int j = 0; j <= OFFSET*2; ++j) {
  int diff = abs(j - (sum - j));
  if (diff < min_diff || (diff == min_diff && dp[n%2][j] < ans)) {
    min_diff = diff;
    ans = dp[n%2][j];
  }
}
```

---

## 复古像素风设计
1. **色调方案**：  
   使用FC红白机经典8色：  
   - 背景：#000000  
   - 网格线：#FFFFFF  
   - 当前状态：#FF0000（红）  
   - 最优路径：#00FF00（绿）

2. **自动演示模式**：  
   - 按空格键暂停/继续  
   - 方向键控制动画速度  
   - 成功时显示 "STAGE CLEAR!" 像素字体

---

通过上述分析与可视化设计，学习者可直观理解动态规划在多阶段决策问题中的应用，同时通过互动元素加深对状态转移过程的理解。

---
处理用时：89.95秒
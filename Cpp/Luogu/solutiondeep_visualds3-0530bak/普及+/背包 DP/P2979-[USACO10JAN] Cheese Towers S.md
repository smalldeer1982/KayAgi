# 题目信息

# [USACO10JAN] Cheese Towers S

## 题目描述

FJ 要建一个奶酪塔，高度最大为 $T\ (1 \le T \le 10^3)$ 。他有 $N\ (1 \le N \le 10^2)$ 种奶酪。第 $i$ 种奶酪的高度为 $H_i\ (5\le H_i \le T\text{ 且 }5 \mid H_i)$ ，价值为 $V_i\ (1 \le V_i \le 10^6)$ 。一块高度 $H_i\ge K\ (1 \le K \le T)$ 的奶酪被称为大奶酪，如果一个奶酪上方有大奶酪（如果有多块就只算一次），这个奶酪的高度 $H_i$ 就会变成原来的 $\frac{4}{5}$。FJ 想让他的奶酪塔价值和最大。请你求出这个最大值。

例如，考虑一种奶酪塔，其最大高度可以是 $53$，可以用三种类型的奶酪块建造。大块是大于或等于 $25$ 的块。下面是他堆叠的各种奶酪块的值和高度的图表：

|类型|价值|高度|
| :----------: | :----------: | :----------: |
|1|100|25|
|2|20|5|
|3|40|10|

FJ建造了以下奶酪塔：

|类型|价值|高度|
| :----------: | :----------: | :----------: |
|1|100|25|
|2|20|4|
|3|40|8|
|3|40|8|
|3|40|8|

总高度是 $25 + 4 + 8 + 8 + 8 = 53$，除塔顶奶酪外，其余高度均被压低。总价值是 $100 + 20 + 40 + 40 + 40 = 240$。

## 样例 #1

### 输入

```
3 53 25 
100 25 
20 5 
40 10 
```

### 输出

```
240 
```

# AI分析结果



**唯一算法分类**  
动态规划（完全背包）

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   所有题解均围绕两种可能的最优情况展开：  
   - **无大奶酪**：直接完全背包求解。  
   - **顶端有大奶酪**：枚举每个大奶酪作为最上层，下方奶酪总高度需压缩至原高度的4/5，通过扩大背包容量至 `T*5/4` 预处理所有可能组合。  

2. **算法实现关键**  
   - **完全背包预处理**：在计算时，背包容量扩展至 `T*5/4`，确保后续能正确计算压缩后的剩余空间。  
   - **贪心策略**：仅需枚举顶端大奶酪，避免中间大奶酪的复杂状态处理。  
   - **状态转移公式**：  
     - 完全背包阶段：`f[j] = max(f[j], f[j - h[i]] + v[i])`。  
     - 大奶酪枚举阶段：`ans = max(ans, v[i] + f[(T - h[i]) * 5/4])`。  

3. **解决难点**  
   - **压缩高度的逆向计算**：通过预处理更大的背包容量，直接反向推导出压缩前的最大价值。  
   - **避免状态冲突**：二维 DP 解法（如 `f[j][0/1]`）通过状态分离解决，但一维解法更简洁高效。  

---

### **题解评分 (≥4星)**

| 题解作者        | 评分 | 亮点与简评                                                                 |
|----------------|------|----------------------------------------------------------------------------|
| reek (赞：75)  | ★★★★★ | 思路清晰，代码简洁，通过预处理和枚举大奶酪直接覆盖所有情况。               |
| Cxs3 (赞：14)  | ★★★★☆ | 详细解释背包容量扩展原因，代码可读性强。                                   |
| linyinuo2008 (赞：3) | ★★★★☆ | 分步骤讲解，结合示例说明压缩逻辑，适合新手理解。                           |

---

### **最优思路或技巧提炼**

1. **核心优化**  
   - **扩大背包容量**：将完全背包的容量扩展至 `T*5/4`，直接解决压缩高度后的剩余空间计算问题。  
   - **分治贪心策略**：将问题拆分为无大奶酪和顶端大奶酪两种互斥情况，避免复杂状态转移。  

2. **代码实现技巧**  
   - **一维数组优化**：通过一维数组逆序更新，节省空间并保持时间复杂度为 `O(NT)`。  
   - **边界处理**：在枚举大奶酪时，跳过高度超过 `T` 的无效情况。  

---

### **同类型题或类似算法套路**

- **完全背包变形**：如 [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)，需处理无限次选择。  
- **状态分离 DP**：如 [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)，通过主件/附件分离状态。  

---

### **推荐相似题目**

1. [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776)（多重背包+二进制优化）  
2. [P1853 投资的最大效益](https://www.luogu.com.cn/problem/P1853)（完全背包+容量扩展）  
3. [P2014 选课](https://www.luogu.com.cn/problem/P2014)（树形背包+状态压缩）  

---

### **代码实现片段**

```cpp
#include <iostream>
using namespace std;

int n, T, k, ans, f[2000], v[1000], h[1000];

int main() {
    cin >> n >> T >> k;
    for (int i = 1; i <= n; i++) {
        cin >> v[i] >> h[i];
        // 完全背包预处理，容量扩展至 T*5/4
        for (int j = h[i]; j <= T * 5 / 4; j++) {
            f[j] = max(f[j], f[j - h[i]] + v[i]);
        }
    }
    ans = f[T]; // 无大奶酪情况
    for (int i = 1; i <= n; i++) {
        if (h[i] >= k) { // 枚举大奶酪
            ans = max(ans, v[i] + f[(T - h[i]) * 5 / 4]);
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

### **可视化与算法演示**

1. **动画设计**  
   - **步骤1**：绘制背包容量条，初始为0，颜色渐变表示价值高低。  
   - **步骤2**：动态填充完全背包过程，高亮当前处理的奶酪和更新位置。  
   - **步骤3**：枚举大奶酪时，显示剩余空间计算 `(T - h[i]) * 5/4`，并用不同颜色区分压缩前后的空间。  

2. **复古像素风格**  
   - **颜色方案**：8-bit 风格，绿色表示小奶酪，红色表示大奶酪，金色表示最优解。  
   - **音效**：背包更新时播放“哔”声，找到最优解时播放“胜利”音效。  

3. **交互功能**  
   - **步进控制**：允许暂停/继续，查看每一步的背包状态。  
   - **自动演示**：模拟 AI 自动选择最优路径，辅以箭头指示当前操作。  

---

**总结**：通过完全背包预处理和贪心策略，将复杂的大奶酪问题简化为两种情况的组合，代码高效且易于理解。

---
处理用时：86.56秒
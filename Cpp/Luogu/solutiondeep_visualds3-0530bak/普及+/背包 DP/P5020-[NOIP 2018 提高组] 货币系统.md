# 题目信息

# [NOIP 2018 提高组] 货币系统

## 题目背景

NOIP2018 提高组 D1T2

## 题目描述

在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。 

在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n=3$, $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 

两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 

现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。 

## 说明/提示

在第一组数据中，货币系统 $(2, [3,10])$ 和给出的货币系统 $(n, a)$ 等价，并可以验证不存在 $m < 2$ 的等价的货币系统，因此答案为 $2$。 在第二组数据中，可以验证不存在 $m < n$ 的等价的货币系统，因此答案为 $5$。 

【数据范围与约定】

![](https://cdn.luogu.com.cn/upload/pic/43160.png)  

对于 $100\%$ 的数据，满足 $1 ≤ T ≤ 20, n,a[i] ≥ 1$。 

## 样例 #1

### 输入

```
2 
4 
3 19 10 6 
5 
11 29 13 19 17 ```

### 输出

```
2   
5  ```

# AI分析结果



# 货币系统（NOIP2018提高组）题解分析

## 唯一算法分类
**动态规划（完全背包）**

---

## 综合分析与结论

### 核心思路
通过完全背包判断每个面值能否被更小的面值组合出来，保留无法被组合的面值。核心步骤：
1. **排序**：将面值从小到大排序
2. **完全背包**：用布尔数组记录每个金额能否被表示
3. **筛选**：若当前面值已被前面面值组合，则剔除

### 解决难点
- **等价系统的数学证明**：需证明最优解的货币必为原系统的子集
- **背包优化**：利用已排序特性，只需用更小面值更新更大金额
- **时间复杂度优化**：O(n*max_a) 复杂度可处理最大面值25000的情况

### 可视化设计
**Canvas动画方案：**
1. **网格绘制**：将面值排序后显示为像素方块，颜色区分已处理/未处理
2. **背包更新**：动态展示金额标记过程，当前处理面值高亮闪烁
3. **音效触发**：
   - 成功剔除面值时播放8bit下滑音效
   - 保留面值时播放上升音效
4. **自动演示**：按排序顺序逐步处理面值，速度可调节

---

## 题解清单（≥4星）

### 1. 0x3喵酱（5星）
- **亮点**：数学证明严谨，代码简洁高效
- **关键代码**：
```cpp
sort(a+1,a+n+1);
f[0]=1;
for(int i=1;i<=n;i++){
    if(f[a[i]]) ans--;
    else for(int j=a[i];j<=a[n];j++) f[j]|=f[j-a[i]];
}
```
- **个人心得**：强调数学证明是核心，动态规划只是实现工具

### 2. Super_Cube（4.5星）
- **亮点**：代码极致简洁（仅15行），使用bitset优化空间
```cpp
std::sort(a+1,a+n+1);
for(int i=1;i<=n;++i)
    if(!dp[a[i]]) for(int j=a[i];j<=a[n];++j) dp[j]|=dp[j-a[i]];
```
- **优化**：通过排序后提前终止循环减少计算量

### 3. WuXiangdong（4星）
- **亮点**：引入三类面值标记，直观展示筛选过程
```cpp
for(int i=1;i<=25000;i++)
    for(int j=1;j<=n;j++)
        if(res[i]!=0) res[i+a[j]]=1;
```

---

## 核心代码实现
```cpp
// 0x3喵酱的优化版本
#include<bits/stdc++.h>
using namespace std;

int T,n,a[105];
bool dp[25005];

int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        memset(dp,0,sizeof(dp));
        dp[0] = true;
        for(int i=1;i<=n;i++) scanf("%d",&a[i]);
        sort(a+1,a+n+1);
        
        int ans = n;
        for(int i=1;i<=n;i++){
            if(dp[a[i]]) ans--;
            else for(int j=a[i];j<=a[n];j++) 
                dp[j] = dp[j] || dp[j - a[i]];
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 相似题目推荐
1. **P2347 砝码称重**（完全背包应用）
2. **P1064 金明的预算方案**（背包问题变种）
3. **P5021 赛道修建**（NOIP2018同套题，贪心+二分）

---

## 可视化实现要点
**复古像素风格设计：**
1. **颜色方案**：
   - 未处理面值：灰色（#808080）
   - 已保留面值：绿色（#00FF00）
   - 已剔除面值：红色（#FF0000）
2. **动画流程**：
   ```javascript
   function animateStep() {
       highlightCurrentCoin(); // 当前处理面值闪烁
       updateBackpackVisual(); // 背包数组颜色更新
       playSoundEffect();      // 根据操作播放音效
   }
   ```
3. **音效设计**：使用Web Audio生成8bit音效
   - 剔除成功：短促"嘟"声（200Hz方波）
   - 保留面值：上升音调（400Hz→600Hz滑音）

---

通过这种可视化设计，学习者可以直观理解完全背包在货币筛选中的应用，同时复古风格增加了学习的趣味性。核心在于展示动态规划中状态转移的过程，以及数学证明与算法实现的完美结合。

---
处理用时：72.95秒
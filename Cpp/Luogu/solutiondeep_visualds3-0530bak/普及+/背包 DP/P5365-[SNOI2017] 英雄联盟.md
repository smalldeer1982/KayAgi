# 题目信息

# [SNOI2017] 英雄联盟

## 题目描述

正在上大学的小皮球热爱英雄联盟这款游戏，而且打的很菜，被网友们戏称为「小学生」。

现在，小皮球终于受不了网友们的嘲讽，决定变强了，他变强的方法就是：买皮肤！

小皮球只会玩  $\text{N}$ 个英雄，因此，他也只准备给这 $\text{N}$ 个英雄买皮肤，并且决定，以后只玩有皮肤的英雄。

这 $\text{N}$ 个英雄中，第 $\text{i}$ 个英雄有 $K_i$ 款皮肤，价格是每款 $C_i$ Q 币（同一个英雄的皮肤价格相同）。

为了让自己看起来高大上一些，小皮球决定给同学们展示一下自己的皮肤，展示的思路是这样的：对于有皮肤的每一个英雄，随便选一个皮肤给同学看。

比如，小皮球共有 5 个英雄，这 5 个英雄分别有 $\text{0,0,3,2,4}$ 款皮肤，那么，小皮球就有 $3 \times 2 \times 4 = 24$ 种展示的策略。

现在，小皮球希望自己的展示策略能够至少达到  $\text{M}$ 种，请问，小皮球至少要花多少钱呢？

## 说明/提示

**样例解释**

每一个英雄都只有4款皮肤，每款皮肤2 Q币，那么每个英雄买3款皮肤，$3 \times 3 \times 3 \ge 24$，共花费 $6 \times 3$ Q币。

**数据范围**

共 10 组数据，第 $\text{i}$ 组数据满足：$\text{N} \le \max(5, \log_2^4i)$

$\text{100}\%$ 的数据：$\text{M} \le 10^{17}, 1 \le K_i \le 10, 1 \le C_i \le 199$。保证有解。

## 样例 #1

### 输入

```
3 24
4 4 4
2 2 2```

### 输出

```
18```

# AI分析结果



## 算法分类  
**动态规划/多重背包**

---

## 题解思路与解决难点  
### 核心算法分析  
题目要求用最少 Q 币使得展示策略数（各英雄购买皮肤数量的乘积）≥ M。核心思路为：  
1. **状态设计**：`dp[j]` 表示花费 `j` Q 币时的最大展示策略数。  
2. **转移方程**：对每个英雄 `i`，枚举购买 `p` 个皮肤（`0 ≤ p ≤ K_i`），更新 `dp[j] = max(dp[j], dp[j - p*C_i] * p)`。  
3. **逆序枚举**：类似 01 背包优化，倒序更新避免覆盖。  
4. **剪枝优化**：当 `dp[j] ≥ M` 时停止更新，避免溢出。  

### 解决难点  
1. **乘积处理**：传统背包用加法，本题需处理乘法，状态转移需特殊设计。  
2. **大数溢出**：`M` 可达 `1e17`，需用 `long long` 且及时剪枝。  
3. **初始状态**：`dp[0] = 1`（零花费对应一种策略）。  

---

## 题解评分（≥4星）  
1. **翼德天尊（5星）**  
   - **亮点**：代码简洁，优化一维数组，强调逆序枚举。  
   - **代码**：清晰注释与输入优化，适合快速理解核心逻辑。  
2. **AzzyZhe（4星）**  
   - **亮点**：提出剪枝优化，处理 `dp[j] ≥ M` 的边界条件。  
   - **代码**：详细注释与数据范围分析，适合进阶学习。  
3. **SIXIANG32（4星）**  
   - **亮点**：动态规划状态设计推导清晰，强调滚动数组优化。  
   - **代码**：使用 `signed main()` 避免类型错误，适合竞赛习惯。  

---

## 最优思路与技巧  
1. **一维状态压缩**：逆序枚举费用，节省空间复杂度。  
2. **剪枝优化**：在更新 `dp[j]` 时若已满足 `≥ M` 则停止更新，避免无效计算。  
3. **初始化技巧**：`dp[0] = 1` 保证乘法起点正确。  

---

## 同类型题与算法套路  
- **通用解法**：处理乘积类背包问题时，状态转移需用乘法，初始值设为 1。  
- **相似题目**：  
  1. **P1776 宝物筛选**（多重背包模板）  
  2. **P2347 砝码称重**（状态转移与组合计数）  
  3. **P6567 买表**（多重背包 + 二进制优化）  

---

## 个人心得摘录  
1. **不开 long long 见祖宗**：多题解强调 `long long` 的必要性。  
2. **初始化重要性**：`dp[0] = 1` 是正确转移的起点。  
3. **逆序枚举的必然性**：正序会导致同一物品多次计算，破坏背包限制。  

---

## 可视化与算法演示  
### 核心算法动画设计  
1. **动态更新展示**：  
   - **网格布局**：横轴为 Q 币花费，纵轴为英雄编号，每个格子显示当前 `dp[j]`。  
   - **颜色标记**：更新时高亮 `j` 和 `j - p*C_i`，红色表示变化，绿色表示已满足条件。  
2. **复古像素风格**：  
   - **8 位音效**：在更新 `dp[j]` 时播放短促音效，达成条件时播放胜利音效。  
   - **Canvas 绘制**：用像素块表示 `dp[j]` 值，颜色深浅反映数值大小。  
3. **交互控制**：  
   - **步进执行**：用户可逐英雄查看更新过程。  
   - **自动模式**：模拟 AI 自动完成背包填充，展示最优路径。  

---

## 核心代码实现  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN = 1e6 + 5;

LL dp[MAXN], k[MAXN], c[MAXN];
LL n, m, total_cost;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> k[i];
    for (int i = 1; i <= n; i++) {
        cin >> c[i];
        total_cost += k[i] * c[i];
    }
    memset(dp, 0, sizeof(dp));
    dp[0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = total_cost; j >= 0; j--) {
            for (int p = 1; p <= k[i] && p * c[i] <= j; p++) {
                if (dp[j - p * c[i]] * p >= m || dp[j] >= m)
                    dp[j] = m;  // 剪枝：超过 M 则不再计算
                else
                    dp[j] = max(dp[j], dp[j - p * c[i]] * p);
            }
        }
    }
    for (int ans = 0; ans <= total_cost; ans++) {
        if (dp[ans] >= m) {
            cout << ans << endl;
            return 0;
        }
    }
    return 0;
}
```

---

## 关键代码说明  
1. **剪枝优化**：在更新 `dp[j]` 时，若当前值已超过 `M`，直接设为 `M`。  
2. **逆序枚举**：`for (int j = total_cost; j >= 0; j--)` 确保每个物品只计算一次。  
3. **结果查询**：线性扫描 `dp` 数组，找到首个 `≥ M` 的最小花费。

---
处理用时：97.46秒
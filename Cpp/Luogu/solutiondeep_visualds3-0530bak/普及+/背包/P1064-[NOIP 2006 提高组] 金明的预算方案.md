# 题目信息

# [NOIP 2006 提高组] 金明的预算方案

## 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $n$ 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：

| 主件 | 附件 |
| :----------: | :----------: |
| 电脑 | 打印机，扫描仪 |
| 书柜 | 图书 |
| 书桌 | 台灯，文具 |
| 工作椅 | 无 |

如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1 \sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过 $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第 $j$ 件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\dots,j_k$，则所求的总和为：

$$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2}+ \dots +v_{j_k} \times w_{j_k}$$

请你帮助金明设计一个满足要求的购物单。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 3.2 \times 10^4$，$1 \leq m \leq 60$，$0 \leq v_i \leq 10^4$，$1 \leq p_i \leq 5$，$0 \leq q_i \leq m$，答案不超过 $2 \times 10^5$。

NOIP 2006 提高组 第二题

## 样例 #1

### 输入

```
1000 5
800 2 0
400 5 1
300 5 1
400 3 0
500 2 0
```

### 输出

```
2200```

# AI分析结果



## 【唯一算法分类】  
有依赖的分组背包

---

## 【题解思路、算法要点与解决难点】  
### 核心思路  
将每个主件及其附件视为一个分组，通过枚举主件的五种购买组合（不买、主件、主+附件1、主+附件2、主+两附件），转化为分组背包问题。各组之间独立决策，组内只能选一种购买方案。  

### 解决难点  
1. **依赖关系处理**：通过将主附件绑定为同一分组，保证仅当主件存在时才可能购买附件  
2. **组合复杂度控制**：利用主件最多有两个附件的特性，暴力枚举所有可能的购买组合（最多5种情况）  
3. **状态转移优化**：采用滚动数组倒序更新，避免二维数组带来的空间开销  

### 关键实现  
- 使用二维数组 `v[i][0-2]` 存储主件及两个附件的价格  
- 动态转移时，对每个主件的五种情况分别进行价值计算：  
  ```cpp
  for (主件i)
    for (j = n → 0)
      if (可购买主件) 更新价值
      if (可购买主件+附件1) 更新价值
      if (可购买主件+附件2) 更新价值
      if (可购买全部组合) 更新价值
  ```

---

## 【题解评分 (≥4星)】  
### 1. Anguei（★★★★★）  
- **亮点**：使用λ表达式简化转移方程，倒序循环优化空间  
- **核心代码**：  
  ```cpp
  auto cost2 = [v, p, i](int x, int y) { return v[i][x] + v[i][y]; };
  if (j >= cost2(0, 1)) // 附件1组合
    f[j] = max(f[j], f[j - cost2(0,1)] + rpp(0)+rpp(1));
  ```

### 2. tuntunQwQ（★★★★）  
- **亮点**：二维DP数组清晰展示状态转移，显式处理附件存在性  
- **核心代码**：  
  ```cpp
  if (v[i][0]+v[i][1] <= j) // 附件1判断
    f[i][j] = max(f[i][j], f[i-1][j-v[i][0]-v[i][1]] + ...);
  ```

### 3. ClV_Csy（★★★★）  
- **亮点**：结构体存储组合信息，预处理所有可能购买方案  
- **核心代码**：  
  ```cpp
  struct node { int v1,v2,v3,s1,s2,s3; };
  if (j >= a[i].v1 + a[i].v2) // 组合判断
    dp[j] = max(dp[j], ...);
  ```

---

## 【最优思路或技巧提炼】  
1. **分组枚举法**：将主附件组合预处理为分组物品，每组最多5种方案  
2. **滚动数组优化**：使用一维数组倒序更新，空间复杂度从O(nm)降为O(n)  
3. **组合权值预计算**：提前计算各组合的总价格和总价值，避免重复运算  

---

## 【同类型题或算法套路】  
1. **P2014 [CTSC1997] 选课**（树形依赖背包）  
2. **P1063 [NOIP2006 提高组] 能量项链**（环形区间DP）  
3. **P1156 垃圾陷阱**（时间轴背包）  

---

## 【推荐相似知识点题目】  
1. P1060 开心的金明（基础01背包）  
2. P2014 选课（树形依赖背包）  
3. P1273 有线电视网（分组背包变形）  

---

## 【个人心得摘录】  
> "附件可能先于主件输入，需要用`defaultdict`存储附件信息" —— jackgdn  
> "每个主件最多五种情况，暴力枚举反而比复杂算法更高效" —— Anguei  

---

## 【可视化与算法演示】  
### 动画方案设计  
1. **网格视图**：  
   - 左侧显示物品分组（主件+附件），右侧显示DP数组  
   - 主件分组展开时高亮五种购买组合的价格/价值  
2. **状态更新演示**：  
   ![动态规划状态转移](https://tmp.imagack.com/24-05-09/9d0a2d4c2c5b1b2a4d4b3e5e0c4f8eeb.gif)  
   - 红色箭头：当前处理的主件分组  
   - 绿色高亮：正在尝试的购买组合  
   - 黄色标记：被更新的DP数组位置  
3. **像素化风格**：  
   - 8-bit音效：每次状态更新时播放"哔"声，完成时播放胜利音效  
   - 背包容量用像素进度条表示，物品用不同颜色方块表示  

### 核心动画代码（伪代码）  
```javascript
// 伪代码示例：处理主件i的四种购买组合
function updateDP(i) {
  playSound('select'); // 选择物品音效
  for (let j = n; j >= 0; j--) {
    highlight(j, 'yellow'); // 当前处理的背包容量
    const cases = calculateCases(i, j); // 计算可行组合
    cases.forEach(c => {
      drawArrow(i, c);  // 显示状态转移路径
      if (c.value > dp[j]) {
        dp[j] = c.value;
        flashCell(j);   // 数值更新闪烁效果
      }
    });
  }
}
```

---

## 【完整代码参考】  
Anguei题解的核心实现（带注释）：  
```cpp
for (int i = 1; i <= m; ++i) {
  for (int j = n; j >= 0; --j) {
    auto cost2 = [v, p, i](int x, int y) { 
      return v[i][x] + v[i][y]; 
    };
    // 主件单独购买
    if (j >= v[i][0]) 
      f[j] = max(f[j], f[j - v[i][0]] + v[i][0]*p[i][0]);
    // 主件+附件1组合
    if (j >= cost2(0, 1))
      f[j] = max(f[j], f[j - cost2(0,1)] + ...);
    // ...其他组合类似
  }
}
```

---
处理用时：68.66秒
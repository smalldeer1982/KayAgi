# 题目信息

# 多米诺骨牌

## 题目描述

多米诺骨牌由上下 $2$ 个方块组成，每个方块中有 $1\sim6$ 个点。现有排成行的上方块中点数之和记为 $S_1$，下方块中点数之和记为 $S_2$，它们的差为 $\left|S_1-S_2\right|$。如图，$S1=6+1+1+1=9$，$S2=1+5+3+2=11$，$\left|S_1-S_2\right|=2$。每个多米诺骨牌可以旋转 $180°$，使得上下两个方块互换位置。请你计算最少旋转多少次才能使多米诺骨牌上下 $2$ 行点数之差达到最小。

![](https://cdn.luogu.com.cn/upload/pic/91.png)

对于图中的例子，只要将最后一个多米诺骨牌旋转 $180°$，即可使上下 $2$ 行点数之差为 $0$。

## 样例 #1

### 输入

```
4
6 1
1 5
1 3
1 2
```

### 输出

```
1
```

# AI分析结果



# 多米诺骨牌题解分析

## 唯一算法分类  
**动态规划**

---

## 综合分析与结论

### 核心难点与解决方案
1. **状态设计**：需要同时跟踪「当前差值」和「最小翻转次数」，通过二维 DP 数组 `f[i][j]` 表示前 `i` 个骨牌使上下差为 `j` 的最小翻转次数。
2. **负数处理**：差值可能为负，使用偏移量（如+5000）将负数映射到正数下标。
3. **空间优化**：通过滚动数组（如 `f[2][...]`）将空间复杂度从 O(n²) 降为 O(n)。

### 算法流程
1. **初始化**：设置第一个骨牌两种状态（翻转/不翻转）。
2. **状态转移**：
   - 若不翻转：`f[i][j] = min(f[i-1][j - a[i]], ...)`
   - 若翻转：`f[i][j] = min(f[i-1][j - b[i]] + 1, ...)`
3. **结果遍历**：在所有可能的差值中寻找最小绝对差及对应翻转次数。

### 可视化设计
- **动画方案**：  
  - **网格视图**：展示每个骨牌选择翻转时的差值变化，用红色标记当前操作的骨牌。  
  - **动态更新**：用柱状图表示不同差值 `j` 的最小翻转次数，绿色表示当前最优解。  
  - **步进控制**：允许逐骨牌观察状态转移过程，显示状态数组的更新路径。  
- **复古风格**：  
  - **像素方块**：每个骨牌用 8-bit 像素方块表示，翻转时播放 "click" 音效。  
  - **自动演示**：AI 模式模拟动态规划过程，自动高亮关键步骤并解释逻辑。

---

## 高星题解推荐（≥4星）

### 1. fy0123（★★★★★）
- **亮点**：  
  - 明确状态定义与转移方程，代码简洁易读。  
  - 通过总和 `s` 快速计算最终差值，逻辑清晰。  
- **核心代码**：  
  ```cpp
  for (int i = 2; i <= n; i++) 
    for (int j = 0; j <= 6*n; j++) {
      if (j-a[i] >= 0) f[i][j] = min(f[i][j], f[i-1][j-a[i]]);
      if (j-b[i] >= 0) f[i][j] = min(f[i][j], f[i-1][j-b[i]]+1);
    }
  ```

### 2. 皎月半洒花（★★★★☆）
- **亮点**：  
  - 使用滚动数组优化空间，降低内存消耗。  
  - 巧用位运算切换数组维度，代码高效。  
- **核心代码**：  
  ```cpp
  for (k = i = 1; i <= N; i++, k ^= 1) {
    memset(dp[k], 0x7f, sizeof(dp[k]));
    for (j = -5000; j <= 5000; j++)
      dp[k][j + NN] = min(dp[k^1][j + A[i] - B[i] + NN], 
                          dp[k^1][j - A[i] + B[i] + NN] + 1);
  }
  ```

### 3. dj114133643（★★★★☆）
- **亮点**：  
  - 差值中心化处理，避免负数下标问题。  
  - 双重循环覆盖正负区间，逻辑严密。  
- **核心代码**：  
  ```cpp
  for (i=1; i<=n; i++)
    for (j=-5000; j<=5000; j++) {
      dis = a[i] - b[i];
      f[i][j+N] = min(f[i-1][j-dis+N], f[i-1][j+dis+N] + 1);
    }
  ```

---

## 最优技巧提炼
1. **差值偏移法**：通过固定偏移量（如+5000）处理负数下标，适用于需要跟踪正负值的场景。
2. **滚动数组优化**：仅保留当前和前一轮状态，将空间复杂度从 O(n²) 降至 O(n)。
3. **对称遍历策略**：在结果阶段同时检查 `j` 和 `-j` 的差值，确保捕捉最小绝对差。

---

## 相似题目推荐
1. **P1064 金明的预算方案**（依赖型背包，多状态选择）  
2. **P1156 垃圾陷阱**（动态规划结合时间与高度约束）  
3. **P1941 飞扬的小鸟**（多维状态与跳跃决策优化）

---

## 个人心得摘录
> "本题的贪心策略只能保证局部最优，无法处理需要同时翻转多个骨牌的情况，最终通过暴力修正部分案例才 AC。" —— Zerosking  
> "初始化时若直接设置 `f[0][0] = 0` 会漏掉第一个骨牌的两种状态，必须显式处理边界。" —— Memorize  

---

## 可视化代码片段（Canvas 动画）
```javascript
// 绘制骨牌状态
function drawDomino(ctx, x, y, isFlipped) {
  ctx.fillStyle = isFlipped ? '#FF5555' : '#55FF55';
  ctx.fillRect(x, y, 30, 60); // 骨牌主体
  ctx.fillStyle = '#000';
  ctx.fillText(isFlipped ? 'FLIP' : 'ORIG', x+5, y+30); // 状态标记
}

// 更新差值柱状图
function updateDiffBars(diffValues) {
  diffValues.forEach((val, idx) => {
    let height = Math.abs(val) * 2;
    ctx.fillStyle = val === minDiff ? '#00FF00' : '#8888FF';
    ctx.fillRect(100 + idx*10, 300 - height, 8, height);
  });
}
```

---

## 复古音效设计
- **翻转音效**：8-bit "blip" 短音（Web Audio API 生成 200Hz 方波）。  
- **成功音效**：上升琶音（500Hz → 1000Hz）。  
- **背景音乐**：FC 风格循环旋律，使用 `setInterval` 调度。

---
处理用时：77.63秒
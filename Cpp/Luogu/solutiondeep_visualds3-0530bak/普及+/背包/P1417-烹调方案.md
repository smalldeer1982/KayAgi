# 题目信息

# 烹调方案

## 题目背景

由于你的帮助，火星只遭受了最小的损失。但 gw 懒得重建家园了，就造了一艘飞船飞向遥远的 earth 星。不过飞船飞到一半，gw 发现了一个很严重的问题：肚子饿了 ~。

gw 还是会做饭的，于是拿出了储藏的食物准备填饱肚子。gw 希望能在 $T$ 时间内做出最美味的食物，但是这些食物美味程度的计算方式比较奇葩，于是绝望的 gw 只好求助于你了。

## 题目描述

一共有 $n$ 件食材，每件食材有三个属性，$a_i$，$b_i$ 和 $c_i$，如果在 $t$ 时刻完成第 $i$ 样食材则得到 $a_i-t\times b_i$ 的美味指数，用第 $i$ 件食材做饭要花去 $c_i$ 的时间。

众所周知，gw 的厨艺不怎么样，所以他需要你设计烹调方案使得美味指数最大。

## 说明/提示

### 数据范围及约定

- 对于 $40\%$ 的数据 $1 \le n \le 10$；
- 对于 $100\%$ 的数据 $1 \le n \le 50$。

所有数字均小于 $10^5$。

### 题目来源

tinylic 改编


## 样例 #1

### 输入

```
74 1
502
2
47
```

### 输出

```
408```

# AI分析结果



---

## 算法分类
动态规划（01背包） + 贪心排序

---

## 核心思路与难点分析
**核心逻辑**：  
1. **排序推导**：通过比较相邻物品x和y的收益差值，得出排序条件 `c[x] * b[y] < c[y] * b[x]`，确保先处理对时间更敏感的食材  
2. **动态规划**：按排序顺序进行01背包，状态转移方程为 `dp[j] = max(dp[j], dp[j-c_i] + a_i - j*b_i)`  

**解决难点**：  
- **时间敏感性**：不同食材的价值随时间衰减速度不同，需通过排序确定最优处理顺序  
- **背包状态设计**：每个时间点的价值计算需包含当前时刻的衰减量 `j*b_i`  

---

## 题解评分（≥4星）
1. **kkksc03（5星）**  
   - 清晰推导排序条件  
   - 正确处理初始状态（-1表示不可达）  
   - 代码简洁高效  

2. **henry_y（4.5星）**  
   - 详细数学推导过程  
   - 强调long long的重要性  
   - 博客链接提供拓展学习  

3. **Doubeecat（4星）**  
   - 完整数学证明推导  
   - 清晰的变量命名和注释  

---

## 最优思路提炼
**核心技巧**：  
1. **贪心排序**：通过比较相邻物品的 `c_i*b_j` 确定顺序  
2. **逆序背包**：从最大时间倒序更新，保证物品只选一次  
3. **溢出防御**：全程使用long long防止乘法溢出  

**关键代码片段**：  
```cpp
// 排序条件（保证x在y前更优）
bool cmp(node x, node y) {
    return (LL)x.c * y.b < (LL)y.c * x.b;
}

// 动态规划核心逻辑
for (int i = 0; i < n; i++) {
    for (int j = T; j >= a[i].c; j--) {
        if (dp[j - a[i].c] != -1) {
            dp[j] = max(dp[j], dp[j - a[i].c] + a[i].a - j * a[i].b);
        }
    }
}
```

---

## 同类问题与题目推荐
**类似算法套路**：  
- 时间敏感的背包问题（如《国王游戏》中的排序策略）  
- 泛化物品背包问题  

**推荐题目**：  
1. [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)  
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)  
3. [P2214 能量项链](https://www.luogu.com.cn/problem/P2214)  

---

## 可视化设计
**动画方案**：  
1. **排序演示**：  
   - 以像素方块表示食材，显示c_i和b_i值  
   - 动态交换相邻方块，展示排序条件比较过程  

2. **背包更新**：  
   - 时间轴（0→T）以绿色进度条表示  
   - 当前处理的食材高亮显示  
   - 状态更新时，对应时间点闪烁黄色  

3. **复古效果**：  
   - 8-bit音效：排序时播放"blip"声，背包更新时播放"click"声  
   - 像素字体显示时间价值和当前最优解  

**交互功能**：  
- 速度调节滑块（1x→5x）  
- 暂停/单步执行按钮  
- 自动演示模式（AI自动排序+背包）  

---

## 个人心得摘录
> "三年OI一场空，不开long long见祖宗" —— zjy111  
> 调试时发现负数结果，最终发现是乘法溢出导致排序错误，深刻教训提醒基础数据类型的重要性

---

## 完整代码（kkksc03版）
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#define LL long long
using namespace std;

struct node { int a, b, c; };
LL f[100001], ans;
int T, n;

bool cmp(node x, node y) {
    return (LL)x.c * y.b < (LL)y.c * x.b;
}

int main() {
    scanf("%d%d", &T, &n);
    node a[51];
    // 输入略
    sort(a, a+n, cmp);
    memset(f, -1, sizeof f);
    f[0] = 0;
    
    for (int i = 0; i < n; i++)
        for (int j = T; j >= a[i].c; j--)
            if (f[j - a[i].c] != -1)
                f[j] = max(f[j], f[j - a[i].c] + a[i].a - (LL)j * a[i].b);
    
    for (int i = 0; i <= T; i++)
        ans = max(ans, f[i]);
    cout << ans;
}
```

---
处理用时：81.20秒
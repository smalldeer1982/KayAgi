# 题目信息

# [USACO10JAN] Cheese Towers S

## 题目描述

FJ 要建一个奶酪塔，高度最大为 $T\ (1 \le T \le 10^3)$ 。他有 $N\ (1 \le N \le 10^2)$ 种奶酪。第 $i$ 种奶酪的高度为 $H_i\ (5\le H_i \le T\text{ 且 }5 \mid H_i)$ ，价值为 $V_i\ (1 \le V_i \le 10^6)$ 。一块高度 $H_i\ge K\ (1 \le K \le T)$ 的奶酪被称为大奶酪，如果一个奶酪上方有大奶酪（如果有多块就只算一次），这个奶酪的高度 $H_i$ 就会变成原来的 $\frac{4}{5}$。FJ 想让他的奶酪塔价值和最大。请你求出这个最大值。

例如，考虑一种奶酪塔，其最大高度可以是 $53$，可以用三种类型的奶酪块建造。大块是大于或等于 $25$ 的块。下面是他堆叠的各种奶酪块的值和高度的图表：

|类型|价值|高度|
| :----------: | :----------: | :----------: |
|1|100|25|
|2|20|5|
|3|40|10|

FJ建造了以下奶酪塔：

|类型|价值|高度|
| :----------: | :----------: | :----------: |
|1|100|25|
|2|20|4|
|3|40|8|
|3|40|8|
|3|40|8|

总高度是 $25 + 4 + 8 + 8 + 8 = 53$，除塔顶奶酪外，其余高度均被压低。总价值是 $100 + 20 + 40 + 40 + 40 = 240$。

## 样例 #1

### 输入

```
3 53 25 
100 25 
20 5 
40 10 
```

### 输出

```
240 
```

# AI分析结果



---

## 算法分类
动态规划（完全背包） + 贪心策略

---

## 题解思路与核心分析

### 核心思路
1. **贪心策略**：最优解仅两种情况：
   - 无大奶酪 → 直接完全背包
   - 最顶部为大奶酪 → 下方所有奶酪高度压缩为原4/5
2. **完全背包预处理**：将背包容量扩大至 `T*5/4`，以处理下方奶酪被压缩后的总高度。
3. **分治处理**：
   - 情况一：完全背包计算无大奶酪时的最大值 `f[T]`
   - 情况二：枚举每个大奶酪作为顶部，计算 `v[i] + f[(T-h[i])*5/4]`

### 解决难点
- **大奶酪的位置处理**：通过贪心将大奶酪固定在顶部，避免复杂的状态转移。
- **高度压缩转换**：通过背包容量扩增（`T*5/4`）将压缩后的总高度转换为原始高度。

---

## 题解评分（≥4星）

1. **作者：reek（5星）**  
   - 思路清晰：明确分治两种最优情况
   - 代码简洁：仅需两个循环处理完全背包和枚举顶部大奶酪
   - 核心代码：
     ```cpp
     for (int j=h[i];j<=T*5/4;j++)
         f[j] = max(f[j], f[j-h[i]] + v[i]);
     ans = max(ans, f[(T-h[i])*5/4] + v[i]);
     ```

2. **作者：Cxs3（4星）**  
   - 详细分析：解释容量扩增的数学逻辑
   - 代码注释：强调 `j` 循环范围的重要性

3. **作者：linyinuo2008（4星）**  
   - 分步讲解：从无大奶酪到有大奶酪的过渡
   - 代码可读性：变量命名清晰，结构明确

---

## 最优思路提炼

1. **贪心确定大奶酪位置**：仅需考虑顶部有无大奶酪两种情况。
2. **背包容量扩增**：预处理时将 `j` 循环至 `T*5/4`，为后续压缩计算提供空间。
3. **分治处理状态**：完全背包与枚举大奶酪分离，降低复杂度。

---

## 类似题目推荐

1. **[P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)**  
   - 完全背包基础模板，无附加条件。
2. **[P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)**  
   - 带依赖关系的背包问题，需分情况处理。
3. **[P2854 [USACO06DEC]Cow Roller Coaster S](https://www.luogu.com.cn/problem/P2854)**  
   - 动态规划结合多维状态，需优化状态转移。

---

## 可视化与算法演示

### 动画设计
- **背包容量网格**：以像素网格表示背包容量 `0 → T*5/4`，每个格子显示当前最大价值 `f[j]`。
- **奶酪块动态填充**：每次循环时，用不同颜色块表示当前处理的奶酪类型（普通/大奶酪）。
- **高亮变化区域**：当 `f[j]` 更新时，高亮对应网格块，显示 `f[j] = max(...)` 的逻辑。
- **顶部大奶酪标记**：枚举大奶酪时，在塔顶显示该奶酪，下方显示压缩后的高度转换公式。

### 复古像素风格
- **8位音效**：
  - `f[j]` 更新时播放短促的 "beep" 音效。
  - 找到最优解时播放经典 FC 过关音乐。
- **Canvas 绘制**：
  - 背包网格用 16x16 像素块表示，颜色区分普通/大奶酪。
  - 塔结构用垂直堆叠的方块表示，顶部大奶酪闪烁提示。

### 核心代码片段（C++）
```cpp
int n, T, k, ans, f[2000], v[100], h[100];
int main() {
    scanf("%d%d%d", &n, &T, &k);
    for (int i=1; i<=n; i++) {
        scanf("%d%d", &v[i], &h[i]);
        // 完全背包预处理
        for (int j=h[i]; j<=T*5/4; j++)
            f[j] = max(f[j], f[j-h[i]] + v[i]);
    }
    ans = f[T];
    // 枚举顶部大奶酪
    for (int i=1; i<=n; i++)
        if (h[i] >= k)
            ans = max(ans, v[i] + f[(T - h[i])*5/4]);
    printf("%d\n", ans);
    return 0;
}
```

---

## 个人心得摘录

- **调试关键**：需注意 `(T-h[i])*5/4` 的整数截断问题，可能导致计算错误。
- **思维突破**：将大奶酪位置固定在顶部是简化问题的关键，避免多维状态转移。
- **优化技巧**：预处理时扩大背包容量，将压缩后的高度转换为原始高度，避免逆向计算。

---

**可视化交互示例（伪代码）**
```javascript
// Canvas 绘制背包网格
function drawGrid() {
    for (let j=0; j<=maxJ; j++) {
        ctx.fillStyle = getColor(f[j]);
        ctx.fillRect(j*16, 0, 15, 15); // 每个格子宽高16px
    }
}
// 更新动画帧
function updateFrame(i, j) {
    highlightCell(j); // 高亮当前处理的背包格子
    playSound('beep'); // 播放音效
}
```

---
处理用时：66.32秒
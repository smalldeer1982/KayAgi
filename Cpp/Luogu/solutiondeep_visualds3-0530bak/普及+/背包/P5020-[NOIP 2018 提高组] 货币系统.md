# 题目信息

# [NOIP 2018 提高组] 货币系统

## 题目背景

NOIP2018 提高组 D1T2

## 题目描述

在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。 

在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n=3$, $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 

两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 

现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。 

## 说明/提示

在第一组数据中，货币系统 $(2, [3,10])$ 和给出的货币系统 $(n, a)$ 等价，并可以验证不存在 $m < 2$ 的等价的货币系统，因此答案为 $2$。 在第二组数据中，可以验证不存在 $m < n$ 的等价的货币系统，因此答案为 $5$。 

【数据范围与约定】

![](https://cdn.luogu.com.cn/upload/pic/43160.png)  

对于 $100\%$ 的数据，满足 $1 ≤ T ≤ 20, n,a[i] ≥ 1$。 

## 样例 #1

### 输入

```
2 
4 
3 19 10 6 
5 
11 29 13 19 17 ```

### 输出

```
2   
5  ```

# AI分析结果



## 算法分类
动态规划（完全背包）

---

## 综合分析与结论
### 核心思路与难点解析
**核心思路**：通过完全背包思想，判断每个面值是否能被更小的面值组合表示。若能，则剔除该面值；若不能，则保留。最终保留的面值构成最小等价货币系统。

**解决难点**：
1. **数学证明**：需证明最小系统的元素必须属于原系统（通过反证法推导）。
2. **高效判定**：使用完全背包动态规划，用布尔数组记录每个金额是否可达。
3. **优化方向**：排序后从小到大处理，确保小面值先填充，大面值只需判断是否已被覆盖。

### 算法流程
1. **排序原数组**：确保小面值优先处理。
2. **初始化 dp 数组**：`dp[0] = true`（金额 0 可达）。
3. **遍历面值**：对每个面值 `a[i]`，若 `dp[a[i]]` 已为 `true`，则跳过；否则用该面值更新可达金额。
4. **统计答案**：未被跳过的面值数量即为最小系统大小。

**可视化设计**：
- **动画方案**：用网格表示金额，绿色块表示可达，红色块表示当前处理面值。每处理一个面值时，用波浪动画扩展其覆盖金额。
- **复古风格**：8-bit 像素字体，每次更新播放「金币音效」，成功剔除时播放「碎裂音效」。
- **交互功能**：步进控制可观察每个面值的处理过程，右侧面板展示当前保留的面值列表。

---

## 题解清单（≥4星）
### 1. 0x3喵酱（★★★★★）
**亮点**：严谨的数学证明 + 简洁的完全背包实现，代码清晰易读。
**关键代码**：
```cpp
sort(a+1, a+n+1);
f[0] = 1;
for(int i=1; i<=n; i++) {
    if(f[a[i]]) { ans--; continue; }
    for(int j=a[i]; j<=a[n]; j++) f[j] |= f[j-a[i]];
}
```

### 2. Super_Cube（★★★★☆）
**亮点**：极致简洁的代码风格，用 `bitset` 优化空间。
```cpp
sort(a+1,a+n+1);
for(int i=1; i<=n; ++i) {
    if(dp[a[i]]) --ans;
    else for(int j=a[i]; j<=a[n]; ++j) dp[j] = dp[j] | dp[j-a[i]];
}
```

### 3. WuXiangdong（★★★★）
**亮点**：从数学归纳法角度推导，提出「基」的概念，强化理论支撑。
```cpp
if(flag[a[j]]) continue; // 已被表示则跳过
cnt++;
for(int k=0; k<=aMax-a[j]; k++) 
    if(flag[k]) flag[k+a[j]] = true;
```

---

## 最优思路提炼
### 关键技巧
1. **排序预处理**：确保小面值优先处理，避免大面值干扰。
2. **布尔标记法**：用 `dp[j]` 记录金额 `j` 是否可达，空间复杂度低。
3. **动态剪枝**：若当前面值已被覆盖，直接跳过后续处理。

### 思维模型
**等效筛法**：类似素数筛法，每个面值作为「筛子」去标记更大金额的可达性。最终未被筛掉的面值即为系统基元素。

---

## 同类题目推荐
1. **P1616 疯狂的采药**（完全背包模板题）
2. P1064 金明的预算方案（依赖背包问题）
3. P2214 音乐播放器（集合覆盖问题）

---

## 可视化算法演示
### 核心逻辑动画
**实现方案**：
1. **Canvas 绘制**：用 16x16 像素网格表示金额范围，绿色填充表示可达。
2. **高亮当前面值**：红色边框标记正在处理的 `a[i]`。
3. **扩散效果**：处理 `a[i]` 时，从 `a[i]` 开始向右滑动覆盖，每帧更新可达金额。

**音效设计**：
- **点击面值**：8-bit「选择」音效（频率 440Hz，短促）。
- **标记成功**：清脆「金币」声（频率 880Hz）。
- **错误剔除**：低沉「爆炸」声（频率 220Hz）。

**代码片段**：
```javascript
// 伪代码：更新可达金额动画
function animateUpdate(a_i) {
    let current = a_i;
    while (current <= max_a) {
        grid[current].color = YELLOW; // 高亮当前更新
        playSound(660); // 更新音效
        current += a_i;
        setTimeout(() => {}, 100); // 控制动画速度
    }
}
```

---

## 个人心得摘录
> **0x3喵酱**：考场推导时先猜结论再证明，避免陷入复杂数学陷阱。  
> **SuperJvRuo**：因未清空转移数组导致 WA，调试教训深刻。  
> **WuXiangdong**：将问题抽象为「基」的概念，理论指导实践更高效。

---
处理用时：62.95秒
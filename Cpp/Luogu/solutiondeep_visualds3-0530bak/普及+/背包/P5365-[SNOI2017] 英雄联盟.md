# 题目信息

# [SNOI2017] 英雄联盟

## 题目描述

正在上大学的小皮球热爱英雄联盟这款游戏，而且打的很菜，被网友们戏称为「小学生」。

现在，小皮球终于受不了网友们的嘲讽，决定变强了，他变强的方法就是：买皮肤！

小皮球只会玩  $\text{N}$ 个英雄，因此，他也只准备给这 $\text{N}$ 个英雄买皮肤，并且决定，以后只玩有皮肤的英雄。

这 $\text{N}$ 个英雄中，第 $\text{i}$ 个英雄有 $K_i$ 款皮肤，价格是每款 $C_i$ Q 币（同一个英雄的皮肤价格相同）。

为了让自己看起来高大上一些，小皮球决定给同学们展示一下自己的皮肤，展示的思路是这样的：对于有皮肤的每一个英雄，随便选一个皮肤给同学看。

比如，小皮球共有 5 个英雄，这 5 个英雄分别有 $\text{0,0,3,2,4}$ 款皮肤，那么，小皮球就有 $3 \times 2 \times 4 = 24$ 种展示的策略。

现在，小皮球希望自己的展示策略能够至少达到  $\text{M}$ 种，请问，小皮球至少要花多少钱呢？

## 说明/提示

**样例解释**

每一个英雄都只有4款皮肤，每款皮肤2 Q币，那么每个英雄买3款皮肤，$3 \times 3 \times 3 \ge 24$，共花费 $6 \times 3$ Q币。

**数据范围**

共 10 组数据，第 $\text{i}$ 组数据满足：$\text{N} \le \max(5, \log_2^4i)$

$\text{100}\%$ 的数据：$\text{M} \le 10^{17}, 1 \le K_i \le 10, 1 \le C_i \le 199$。保证有解。

## 样例 #1

### 输入

```
3 24
4 4 4
2 2 2```

### 输出

```
18```

# AI分析结果



**唯一算法分类**：动态规划（多重背包）

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   将每个英雄视为多重背包中的物品，皮肤数量为物品数量，花费为物品体积。状态 `dp[j]` 表示花费 j Q币时的最大展示策略数。通过三重循环（英雄枚举、逆序花费枚举、皮肤数量枚举）进行状态转移。

2. **算法关键点**  
   - **状态定义**：`dp[j]` 表示花费 j Q币时的最大方案数  
   - **状态转移**：`dp[j] = max(dp[j], dp[j-p*c[i]] * p)`（p为当前英雄购买的皮肤数）  
   - **初始化**：`dp[0] = 1`（零花费时方案数为1）  
   - **优化策略**：当方案数超过 M 时停止更新（防止数值溢出）

3. **解决难点**  
   - **乘法状态转移**：传统背包为加法，此处为乘法，需重新设计转移方程  
   - **大数值处理**：M 最大为 1e17，需使用 `long long` 并控制计算过程  
   - **空间优化**：一维滚动数组替代二维数组，节省内存

---

### **题解评分 (≥4星)**

1. **翼德天尊（5星）**  
   - 代码清晰，注释完整  
   - 采用一维滚动数组优化  
   - 明确初始化逻辑和状态转移方程  

2. **AzzyZhe（4.5星）**  
   - 提供优化版本代码（144ms）  
   - 讨论二进制拆分不适用原因  
   - 提出对 M=0 的特殊处理  

3. **SIXIANG32（4星）**  
   - 详细推导二维到一维优化过程  
   - 强调滚动数组实现细节  
   - 代码包含防越界判断

---

### **最优思路与技巧提炼**

1. **状态压缩技巧**  
   使用一维数组逆序更新，避免二维数组空间浪费：
   ```cpp
   for (int j = qb; j >= 0; j--) 
       for (int p = 1; p <= k[i]; p++) 
           dp[j] = max(dp[j], dp[j-p*c[i]] * p);
   ```

2. **数值溢出控制**  
   当 `dp[j] >= M` 时停止更新，避免无效计算：
   ```cpp
   if (dp[j] >= M) break; // 提前终止
   ```

3. **边界条件处理**  
   初始化 `dp[0] = 1` 表示零花费时的合法状态，正确处理空集情况。

---

### **同类型题与算法套路**

1. **类似题目特征**  
   - 物品数量有限制  
   - 目标值为乘积形式  
   - 求最小成本/最大收益

2. **通用解法**  
   - **多重背包变形**：将数量限制转化为状态转移条件  
   - **乘积优化**：用对数转换乘为加（但本题范围允许直接计算）

---

### **推荐相似题目**

1. **P1776 宝物筛选**（多重背包模板题）  
2. **P1064 金明的预算方案**（依赖型背包）  
3. **P2854 [USACO06DEC]Cow Roller Coaster**（二维费用背包）

---

### **个人心得摘录**

1. **调试教训**  
   > "不开 long long 见祖宗" —— 多篇题解强调数值范围  
   > 关键点：`M` 和中间计算结果需使用 `long long`

2. **优化顿悟**  
   > "发现方案数超过 M 后无需继续更新" —— AzzyZhe  
   > 意义：减少无效计算，提升性能

---

### **可视化与算法演示**

**动态规划状态更新动画**：  
1. **网格绘制**：  
   - 横向为 Q币（0~总花费），纵向为英雄序号  
   - 每个单元格显示 `dp[j]` 值，初始全灰  

2. **更新过程**：  
   ```javascript
   // 伪代码示例
   for (let i = 1; i <= n; i++) {
       for (let j = qb; j >= 0; j--) {
           highlightColumn(j, 'yellow'); // 当前处理列
           for (let p = 1; p <= k[i]; p++) {
               if (j - p*c[i] >= 0) {
                   let newVal = dp[j - p*c[i]] * p;
                   if (newVal > dp[j]) {
                       dp[j] = newVal;
                       flashCell(i, j, 'green'); // 更新成功
                   }
               }
           }
       }
   }
   ```

3. **复古像素风格**：  
   - **颜色方案**：8位色（红：英雄切换，蓝：皮肤数量更新）  
   - **音效设计**：  
     - `beep(440, 50)` 皮肤数量增加时  
     - `beep(880, 100)` 找到可行解时  

---

### **核心代码实现**

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN = 125;
ll dp[250000] = {1}; // 初始化dp[0]=1
ll k[MAXN], c[MAXN], n, m, qb;

int main() {
    cin >> n >> m;
    for (int i=1; i<=n; i++) cin >> k[i];
    for (int i=1; i<=n; i++) {
        cin >> c[i];
        qb += k[i] * c[i]; // 总花费上限
    }
    for (int i=1; i<=n; i++) {
        for (int j=qb; j>=0; j--) {
            for (int p=1; p<=k[i] && p*c[i]<=j; p++) {
                if (dp[j - p*c[i]] * p > dp[j] && dp[j] < m) {
                    dp[j] = dp[j - p*c[i]] * p; // 状态转移
                }
            }
        }
    }
    int ans = 0;
    while (ans <= qb && dp[ans] < m) ans++;
    cout << ans;
    return 0;
}
```

---
处理用时：73.74秒
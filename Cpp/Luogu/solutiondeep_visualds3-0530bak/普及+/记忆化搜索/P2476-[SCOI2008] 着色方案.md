# 题目信息

# [SCOI2008] 着色方案

## 题目描述

有 $n$ 个木块排成一行，从左到右依次编号为 $1$ 至 $n$。

你有 $k$ 种颜色的油漆，第 $i$ 种颜色的油漆足够涂 $c_i$ 个木块。

所有油漆刚好足够涂满所有木块，即 $\sum_{i=1}^kc_i=n$。

由于相邻两个木块涂相同色显得很难看，所以你希望统计任意两个相邻木块颜色不同的着色方案。

由于答案可能很大，请输出对 $10^9+7$ 取模的结果。

## 说明/提示

- 对于 $50\%$ 的数据，$1 \leq k \leq 5$，$1 \leq c_i \leq 3$；
- 对于 $100\%$ 的数据，$1 \leq k \leq 15$，$1 \leq c_i \leq 5$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
10```

## 样例 #2

### 输入

```
5
2 2 2 2 2```

### 输出

```
39480```

## 样例 #3

### 输入

```
10
1 1 2 2 3 3 4 4 5 5
```

### 输出

```
85937576```

# AI分析结果



# 算法分类  
**动态规划（多维状态设计 + 记忆化搜索）**

---

## 题解思路与解决难点  
### 核心思路  
题目要求相邻木块颜色不同的方案数，所有颜色恰好用完。  
**核心难点**：  
1. 如何设计状态避免相邻颜色重复  
2. 如何高效处理颜色类型的等价性（剩余相同数量的颜色视为等价）  

**主流解法**：  
1. **多维状态 DP + 记忆化搜索**  
   - 状态设计：`f[c1][c2][c3][c4][c5][last]`  
     - `c1~c5`：剩余可涂 1~5 次的颜色种数  
     - `last`：上一次使用的颜色的剩余次数（防止相邻重复）  
   - 转移规则：枚举当前选择的颜色剩余次数 `x`，扣除已用次数后更新状态，并避免与 `last` 冲突  
   - 关键优化：将颜色按剩余次数分组，减少状态维度  

2. **组合数学 + 容斥**  
   - 通过多项式卷积计算相邻重复的容斥方案，需结合 FFT 优化  
   - 代码复杂度较高，实际应用较少  

**对比分析**：  
- **多维状态 DP** 更直观且代码简洁，通过记忆化搜索避免无效状态枚举  
- **组合数学方法** 理论复杂度更低，但实现复杂且常数大  

---

## 题解评分 (≥4星)  
1. **Bartholomew 题解（5星）**  
   - 亮点：清晰的状态定义与转移方程，代码可读性强  
   - 关键代码：  
     ```cpp  
     ll DFS(int a, int b, int c, int d, int e, int last) {  
         if (dp[a][b][c][d][e][last] != -1) return dp[...];  
         // 根据剩余次数分组转移  
     }  
     ```  

2. **逃离地球 题解（4.5星）**  
   - 亮点：全面分析多种解法，涵盖组合数学与容斥思路  
   - 关键代码（组合 DP）：  
     ```cpp  
     // 状态转移公式涵盖分块插入与组合数计算  
     ```  

3. **Log_x 题解（4星）**  
   - 亮点：详细解释状态转移逻辑，适合新手理解  
   - 关键代码：  
     ```cpp  
     if (a) res += (a - (last == 2)) * DFS(a-1, b, c, d, e, 1);  
     ```  

---

## 最优思路提炼  
**关键技巧**：  
1. **状态压缩**：将颜色按剩余次数分组，极大减少状态数  
2. **记忆化搜索**：避免重复计算相同状态，提高效率  
3. **转移剪枝**：通过 `last` 参数自动排除相邻重复的情况  

**通用套路**：  
- 对于颜色/物品分组问题，优先按特征（如剩余次数）设计多维状态  
- 相邻限制问题通常通过记录「最后选择」来避免冲突  

---

## 类似题目推荐  
1. **P2513 [HAOI2009] 逆序对数列**（多维 DP 计数）  
2. **P4163 [SCOI2007] 排列**（状态压缩 + 容斥）  
3. **P3226 [HNOI2012] 集合选数**（多维状态设计）  

---

## 可视化设计  
### 算法演示  
1. **像素化状态面板**  
   - 使用 8 位风格网格显示当前 `c1~c5` 和 `last` 的值  
   - 每次状态转移时，高亮变化的 `c_i` 和 `last`  

2. **动态转移步骤**  
   - 动画演示选择颜色 `x`，扣除次数后更新剩余次数组  
   - 若触发相邻重复（`x == last`），播放失败音效并回退  

3. **音效与反馈**  
   - 成功转移：8-bit 上升音效  
   - 无效选择：短促“错误”音效  

**Canvas 示例**：  
```javascript  
function drawState(ctx, c1, c2, c3, c4, c5, last) {  
    // 绘制 5 个颜色组块，last 用不同颜色标记  
}  
```  

---

## 核心代码实现  
```cpp  
ll dp(int a, int b, int c, int d, int e, int last) {  
    if (f[a][b][c][d][e][last]) return f[...];  
    ll res = 0;  
    if (a) res += (a - (last == 2)) * dp(a-1, b, c, d, e, 1);  
    if (b) res += (b - (last == 3)) * dp(a+1, b-1, c, d, e, 2);  
    if (c) res += (c - (last == 4)) * dp(a, b+1, c-1, d, e, 3);  
    if (d) res += (d - (last == 5)) * dp(a, b, c+1, d-1, e, 4);  
    if (e) res += e * dp(a, b, c, d+1, e-1, 5);  
    return f[...] = res % MOD;  
}  
```  

---

## 总结  
本题通过多维状态 DP 将颜色等价性转化为剩余次数分组，极大优化了状态数，结合记忆化搜索实现高效计算。其设计模式可推广至各类分组计数问题，尤其是带有相邻限制的场景。

---
处理用时：65.29秒
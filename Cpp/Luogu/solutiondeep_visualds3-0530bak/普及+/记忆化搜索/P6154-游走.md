# 题目信息

# 游走

## 题目背景

zbw 在 B 城游走。

## 题目描述

B 城可以看作一个有 $n$ 个点 $m$ 条边的**有向无环图**。**可能存在重边**。

zbw 在 B 城随机游走，他会在所有路径中随机选择一条路径，选择所有路径的概率相等。路径的起点和终点可以相同。

定义一条路径的长度为经过的边数，你需要求出 zbw 走的路径长度的期望，答案对 $998244353$ 取模。

## 说明/提示

样例说明：样例的答案分别为 $\dfrac{2}{5}$，$\dfrac{25}{19}$ 和 $\dfrac{11}{9}$。

| 测试点编号 | $n$ | $m$ | 特殊性质 | 每测试点分数 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1,2$ | $\le 10$ | $\le 10$ | 无 | $2$ |
| $3,4,5$ | $\le 15$ | $\le 100$ | 无 | $2$ |
| $6,7,8$ | $\le 100$ | $\le 10^3$ | 无 | $2$ |
| $9,10$ | $\le 10^3$ | $\le 10^4$ | 无 | $2$ |
| $11,12$ | $\le 10^4$ | $\le 10^5$ | 无 | $5$ |
| $13,14$ | $\le 10^5$ | $\le 2\times10^5$ | 无 | $5$ |
| $15,16$ | $\le 10^5$ | $\le 7\times10^5$ | 无 | $10$ |
| $17$ | $\le 10$ | $=n-1$ | 有向树 | $10$ |
| $18$ | $\le 10^3$ | $=n-1$ | 有向树 | $10$ |
| $19$ | $\le 10^4$ | $=n-1$ | 有向树 | $10$ |
| $20$ | $\le 10^5$ | $=n-1$ | 有向树 | $10$ |

其中，“有向树”的定义是：若把图视为无向图，则为一棵树（如样例 $1,2$）。

保证所有数据均按照某种方式随机，这意味着你可以认为算法执行过程中，你可以放心执行模意义下除法操作而不用担心除以零。

## 样例 #1

### 输入

```
3 2
1 2
3 2```

### 输出

```
199648871```

## 样例 #2

### 输入

```
6 5
1 3
2 3
3 4
4 5
4 6```

### 输出

```
630470119```

## 样例 #3

### 输入

```
5 6
1 2
1 3
4 5
3 4
3 5
2 4```

### 输出

```
887328315```

# AI分析结果



---

**唯一算法分类**：动态规划 + 拓扑排序

---

### **题解思路、算法要点与解决难点**

#### **核心算法流程**
1. **目标**：计算所有路径长度总和（`sum`）与路径总数（`cnt`），求 `sum / cnt`。
2. **状态定义**：
   - `f[i]`：以节点 `i` 为起点的路径长度总和。
   - `g[i]`：以节点 `i` 为起点的路径数量。
3. **状态转移**：
   - `g[i] = 1 + Σg[j]`（每个节点自身算一条路径，加上所有出边后驱节点的路径数）。
   - `f[i] = Σ(f[j] + g[j])`（每条路径长度加 1，总贡献为 `f[j] + 路径数 g[j]`）。
4. **实现方式**：
   - **记忆化搜索**：递归处理每个节点的后驱，确保先处理后驱再更新当前节点。
   - **拓扑排序**：按拓扑序处理节点，保证更新顺序正确。

#### **解决难点**
- **依赖关系处理**：DAG 中的节点必须按无环顺序处理（拓扑序或记忆化搜索）。
- **路径统计的边界条件**：每个节点自身也算一条路径（长度 0，但需计入路径数）。
- **逆元计算**：分数取模需用费马小定理（`a / b ≡ a * b^{mod-2} % mod`）。

---

### **题解评分（≥4星）**

1. **gyh20（4.5星）**  
   - **亮点**：代码简洁，记忆化搜索逻辑清晰，注释明确，适合快速理解核心状态转移。
   - **代码可读性**：变量命名规范，结构紧凑。
   - **优化点**：无需显式拓扑排序，依赖递归隐式处理顺序。

2. **zsaskk（4星）**  
   - **亮点**：使用拓扑排序显式处理节点顺序，适合理解 DAG 的依赖关系。
   - **实践性**：队列实现拓扑排序，代码易于移植到其他题目。

3. **Hexarhy（4星）**  
   - **亮点**：详细注释解释状态转移方程，适合新手理解数学推导。
   - **可视化友好**：队列操作和 DP 更新步骤明确，便于动画演示。

---

### **最优思路或技巧提炼**

1. **逆向思维统计路径贡献**  
   - 每条边 `u→v` 的贡献为 `(以 u 为终点的路径数) * (以 v 为起点的路径数)`，但需额外处理路径长度增量。

2. **动态规划状态压缩**  
   - 将路径长度和路径数合并为两个数组 `f` 和 `g`，避免复杂的数据结构。

3. **快速幂求逆元**  
   - 核心代码：`ans = sum * pow(cnt, mod-2, mod) % mod`，直接调用快速幂函数。

---

### **同类型题或类似算法套路**

1. **DAG 上的路径计数**  
   - 如 [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)，统计所有起点到终点的路径数。

2. **DAG 最长/最短路径**  
   - 如 [P1137 旅游规划](https://www.luogu.com.cn/problem/P1137)，拓扑排序后动态规划求最长路径。

---

### **推荐相似题目**

1. **P1137 旅游规划**（DAG 最长路径）
2. **P4017 最大食物链计数**（路径计数）
3. **P3387 缩点**（DAG 上的强连通分量处理后动态规划）

---

### **核心代码实现**

#### **记忆化搜索（gyh20 题解）**
```cpp
void DP(int now) {
    if (g[now]) return;
    g[now] = 1;
    for (int i = h[now]; i; i = e[i].next) {
        int y = e[i].to;
        DP(y);
        (g[now] += g[y]) %= mod;
        (f[now] += f[y] + g[y]) %= mod;
    }
}
```

#### **拓扑排序（Hexarhy 题解）**
```cpp
void topo_sort() {
    queue<int> q;
    for (int i = 1; i <= n; i++)
        if (!indeg[i]) q.push(i);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto v : edge[u]) {
            indeg[v]--;
            f[v] = (f[v] + f[u] + g[u]) % MOD;
            g[v] = (g[v] + g[u]) % MOD;
            if (!indeg[v]) q.push(v);
        }
    }
}
```

---

### **可视化与算法演示**

#### **动画方案**
1. **数据结构**：网格表示节点，颜色标记处理状态：
   - **白色**：未处理。
   - **黄色**：正在处理（递归或队列中）。
   - **绿色**：已处理完成。
2. **关键步骤高亮**：
   - **拓扑排序**：队列弹出节点时，高亮其出边和邻居。
   - **状态更新**：显示 `f[i]` 和 `g[i]` 的数值变化。
3. **复古像素风格**：
   - **Canvas 绘制**：节点用 16x16 像素方块，边用直线连接。
   - **音效**：节点处理完成时播放 8-bit 音效，背景音乐为循环芯片音乐。

#### **交互设计**
- **控制面板**：暂停/继续、单步执行、重置。
- **速度调节**：滑动条控制动画速度（100ms~2000ms/步）。

---

### **总结**

本题的核心在于将路径统计问题转化为动态规划模型，结合拓扑排序或记忆化搜索处理依赖关系。可视化设计通过颜色标记和复古风格增强理解，适合教学和算法演示。

---
处理用时：72.67秒
# 题目信息

# [NOIP 2009 普及组] 细胞分裂

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术）领域的知名专家。现在，他正在为一个细胞实验做准备工作：培养细胞样本。

Hanks 博士手里现在有 $N$ 种细胞，编号从 $1 \sim N$，一个第 $i$ 种细胞经过 $1$ 秒钟可以分裂为 $S_i$ 个同种细胞（$S_i$ 为正整数）。现在他需要选取某种细胞的一个放进培养皿，让其自由分裂，进行培养。一段时间以后，再把培养皿中的所有细胞平均分入 $M$ 个试管，形成 $M$ 份样本，用于实验。Hanks 博士的试管数 $M$ 很大，普通的计算机的基本数据类型无法存储这样大的 $M$ 值，但万幸的是，$M$ 总可以表示为 $m_1$ 的 $m_2$ 次方，即 $M = m_1^{m_2}$，其中 $m_1,m_2$ 均为基本数据类型可以存储的正整数。

注意，整个实验过程中不允许分割单个细胞，比如某个时刻若培养皿中有 $4$ 个细胞，Hanks 博士可以把它们分入 $2$ 个试管，每试管内 $2$ 个，然后开始实验。但如果培养皿中有 $5$ 个细胞，博士就无法将它们均分入 $2$ 个试管。此时，博士就只能等待一段时间，让细胞们继续分裂，使得其个数可以均分，或是干脆改换另一种细胞培养。

为了能让实验尽早开始，Hanks 博士在选定一种细胞开始培养后，总是在得到的细胞“刚好可以平均分入 $M$ 个试管”时停止细胞培养并开始实验。现在博士希望知道，选择哪种细胞培养，可以使得实验的开始时间最早。


## 说明/提示

【输入输出样例 \#1 说明】

经过 $1$ 秒钟，细胞分裂成 $3$ 个，经过 $2$ 秒钟，细胞分裂成 $9$个，……，可以看出无论怎么分裂，细胞的个数都是奇数，因此永远不能分入 $2$ 个试管。

【输入输出样例 \#2 说明】

第 $1$ 种细胞最早在 $3$ 秒后才能均分入 $24$ 个试管，而第 $2$ 种最早在 $2$ 秒后就可以均分（每试管 $144 / {24}^1 = 6$ 个）。故实验最早可以在 $2$ 秒后开始。

【数据范围】

对于 $50 \%$ 的数据，有 $m_1^{m_2} \le 30000$。

对于所有的数据，有 $1 \le N \le 10000$，$1 \le m_1 \le 30000$，$1 \le m_2 \le 10000$，$1 \le S_i \le 2 \times {10}^9$。


NOIP 2009 普及组 第三题


## 样例 #1

### 输入

```
1 
2 1 
3
```

### 输出

```
-1
```

## 样例 #2

### 输入

```
2
24 1
30 12
```

### 输出

```
2
```

# AI分析结果



### 唯一算法分类  
质因数分解  

---

### 题解思路与核心算法要点  

#### 核心思路  
所有题解均基于质因数分解思想：  
1. 将 $m_1^{m_2}$ 分解为质因数形式 $p_1^{c_1} \cdot p_2^{c_2} \cdots p_k^{c_k}$  
2. 对每个细胞 $S_i$ 分解质因数，验证是否包含所有 $p_1 \sim p_k$  
3. 对于每个共有质因数 $p_j$，计算满足 $S_i^t \geq p_j^{c_j}$ 的最小 $t$，取所有质因数的最大 $t$  
4. 最终取所有可行细胞的最小 $t$  

#### 解决难点  
1. **大数处理**：$m_1^{m_2}$ 直接计算会溢出，需通过质因数分解后指数相乘处理  
2. **效率优化**：仅分解 $m_1$ 而非 $m_1^{m_2}$，将指数统一乘以 $m_2$  
3. **特判处理**：当 $m_1=1$ 时无需等待，直接输出 $0$  

---

### 题解评分（≥4星）  

#### 1. 刘心远（★★★★★）  
- **亮点**：代码简洁，预处理质数表优化分解效率  
- **代码结构**：  
  ```cpp
  void getit(int n) { // 分解m1
      for(int i=2; i<=n; i++){
          if(n%i==0) {
              pri[++cnt] = i;
              while(n%i==0) a[cnt]++, n/=i;
          }
      }
      if(n>1) pri[++cnt]=n, a[cnt]=1; 
  }
  int calc(int s) {
      int max_t = 0;
      for每个质因数p_j:
          if(s不含p_j) return INF;
          计算p_j需要的最小t_j;
          max_t = max(max_t, t_j);
      return max_t;
  }
  ```  

#### 2. 暗ざ之殇（★★★★☆）  
- **亮点**：递归分解GCD优化计算过程，数学推导严谨  
- **关键步骤**：  
  ```cpp
  while(m != 1) {
      gcdd = gcd(m, s);
      m /= gcdd;
      s = gcdd;
      t++; // 记录迭代次数
  }
  // 计算最终时间公式
  ans = (t*m2 + tot*(t-1)*m2) / (tot+1);
  ```  

#### 3. Eason_lyx（★★★★）  
- **亮点**：使用vector动态存储质因数，代码易扩展  
- **核心逻辑**：  
  ```cpp
  vector<long long> a, b; // 存储m1的质因数和指数
  for每个细胞s:
      vector<long long> c; // 存储s的质因数指数
      if无法分解所有质因数 → 跳过
      计算每个质因数的最小t → 取max_t
  ```  

---

### 最优技巧提炼  

#### 质因数处理四步法  
1. **分解基准数**：对 $m_1$ 分解质因数，指数乘以 $m_2$  
2. **细胞验证**：检查每个细胞是否包含所有基准质因数  
3. **时间计算**：对每个共有质因数 $p_j$，计算 $\lceil \frac{c_j}{e_j} \rceil$  
4. **全局最优**：取所有细胞的最大时间中的最小值  

#### 代码优化技巧  
- **预处理质数表**：在分解 $m_1$ 和细胞时复用质数表提升效率  
- **向上取整技巧**：用 `(a + b - 1) / b` 代替浮点运算  

---

### 同类题目推荐  
1. **P1072** [Hankson的趣味题] - 质因数分解与条件验证  
2. **P1061** [NOIP2006 明明的随机数] - 质因数统计应用  
3. **P1029** [最大公约数和最小公倍数问题] - 质因数分解求组合  

---

### 个人心得摘录  
- **暗ざ之殇**：通过分解GCD将问题转化为递归形式，"每次将最大公约数除到右边"  
- **刘心远**："预处理30000以内质数表大幅提升分解效率"  
- **Eason_lyx**："发现s无需完全分解，只需处理m1的质因数即可优化计算"  

---

### 算法可视化设计  

#### 动画方案（像素风格演示）  
1. **质因数分解阶段**：  
   - 显示 $m_1$ 被分解为多个像素方块（不同颜色代表不同质因数）  
   - 每个方块显示指数，点击后指数乘以 $m_2$（伴随8-bit音效）  

2. **细胞验证阶段**：  
   - 细胞 $S_i$ 分解时，高亮匹配的质因数方块  
   - 若缺少某个质因数，该方块爆炸并播放失败音效  

3. **时间计算阶段**：  
   - 对每个质因数显示 $\lceil \frac{c_j}{e_j} \rceil$ 公式的逐步计算  
   - 最终时间用进度条表示，最短时间细胞用闪光特效标记  

#### 交互功能  
- **步进控制**：空格键单步执行分解过程  
- **速度调节**：方向键控制动画速度（1x~5x）  
- **自动模式**：AI自动选择最优细胞路径演示  

---

### 关键代码实现  

#### 质因数分解核心逻辑  
```cpp
vector<int> primes; // 存储m1的质因数
vector<int> exps;   // 存储对应指数（已乘m2）

void decompose(int m1, int m2) {
    for (int i=2; i*i<=m1; ++i) {
        if (m1%i == 0) {
            int cnt = 0;
            while (m1%i == 0) {
                cnt++;
                m1 /= i;
            }
            primes.push_back(i);
            exps.push_back(cnt * m2);
        }
    }
    if (m1 > 1) {
        primes.push_back(m1);
        exps.push_back(1 * m2);
    }
}
```

#### 细胞验证与时间计算  
```cpp
int calculate(int s) {
    int max_t = 0;
    for (int i=0; i<primes.size(); ++i) {
        int p = primes[i], req = exps[i];
        int cnt = 0;
        
        // 分解细胞s中的质因数p
        while (s % p == 0) {
            cnt++;
            s /= p;
        }
        if (cnt == 0) return INF; // 缺失必要质因数
        
        // 计算所需时间
        int t = (req + cnt - 1) / cnt; // 向上取整
        max_t = max(max_t, t);
    }
    return max_t;
}
```

---

通过将复杂的质因数操作转化为直观的像素动画，配合音效与交互控制，学习者可深入理解细胞分裂问题的数学本质与算法实现要点。

---
处理用时：84.72秒
# 题目信息

# [NOIP 2012 提高组] 同余方程

## 题目描述

求关于 $ x$ 的同余方程 $ a x \equiv 1 \pmod {b}$ 的最小正整数解。


## 说明/提示

### 数据规模与约定

- 对于 $40\%$ 的数据，$2 ≤b≤ 1,000$；
- 对于 $60\%$ 的数据，$2 ≤b≤ 50,000,000$；
- 对于 $100\%$ 的数据，$2 ≤a, b≤ 2,000,000,000$。



## 样例 #1

### 输入

```
3 10```

### 输出

```
7```

# AI分析结果



# 题解分析与结论

## 唯一算法分类  
扩展欧几里得算法（exgcd）

---

## 综合分析与结论  
### 核心思路与难点  
题目要求解同余方程 $ax \equiv 1 \pmod{b}$，其本质是求 $a$ 在模 $b$ 下的乘法逆元。核心难点在于：  
1. **方程有解的充要条件**：$\gcd(a,b)=1$（由裴蜀定理推导）  
2. **高效求解方法**：扩展欧几里得算法将问题转化为 $ax + by = 1$ 的整数解  
3. **解的调整**：通过取模运算将解调整为最小正整数  

### 算法流程与可视化设计  
**扩展欧几里得算法流程**：  
1. **递归分解**：将 $\text{exgcd}(a,b)$ 转化为 $\text{exgcd}(b, a \bmod b)$  
2. **边界处理**：当 $b=0$ 时返回 $x=1, y=0$  
3. **回溯计算**：用公式 $x = y',\ y = x' - \lfloor a/b \rfloor y'$ 更新解  

**可视化设计要点**：  
- **递归层级高亮**：用不同颜色区分递归层级，展示参数 $(a,b)$ 的变化  
- **变量更新动画**：用箭头动态展示 $x,y$ 在回溯时的更新过程  
- **模运算可视化**：通过网格图展示 $(x \bmod b + b) \bmod b$ 的调整过程  

---

## 题解清单（评分≥4星）  
### 1. 学委（⭐️⭐️⭐️⭐️⭐️）  
**核心亮点**：  
- 从问题转化到数学证明完整闭环  
- 代码中 `x = (x % b + b) % b` 完美处理负数情况  
- 附逆元应用场景说明，拓展性强  

### 2. _Nova（⭐️⭐️⭐️⭐️）  
**核心亮点**：  
- 结合裴蜀定理推导扩展欧几里得  
- 给出通解公式 $x = x_0 + k \cdot \frac{b}{\gcd(a,b)}$  
- 代码中直接返回 $(x \% b + b) \% b$ 保证最小正解  

### 3. 沙普绿12138（⭐️⭐️⭐️⭐️）  
**核心亮点**：  
- 另辟蹊径用欧拉定理 $x = a^{\varphi(b)-1} \bmod b$  
- 给出欧拉函数计算的优化实现  
- 时间复杂度 $O(\sqrt{b})$，适合小规模数据  

---

## 最优思路与技巧提炼  
### 扩展欧几里得标准解法  
```cpp
void exgcd(int a, int b, int &x, int &y) {
    if (!b) { x = 1; y = 0; return; }
    exgcd(b, a % b, y, x); // 递归时交换y,x位置
    y -= a / b * x;        // 巧妙避免中间变量
}
```
**实现技巧**：  
- 递归时直接交换 `y, x` 参数，省去临时变量  
- 负数处理公式 `(x % b + b) % b` 保证最小正解  

### 欧拉定理替代解法  
```cpp
int phi(int n) {
    int ans = n;
    for (int i=2; i*i<=n; ++i)
        if (n%i == 0) {
            ans = ans / i * (i-1);
            while (n%i == 0) n /= i;
        }
    if (n > 1) ans = ans / n * (n-1);
    return ans;
}
```
**适用场景**：当需要复用欧拉函数值时（如多次查询）  

---

## 同类题目推荐  
1. **P3811** 乘法逆元（线性递推）  
2. **P4549** 裴蜀定理（扩展应用）  
3. **P1516** 青蛙的约会（同余方程变形）  

---

## 可视化代码片段  
```javascript
// Canvas绘制递归树（伪代码）
function drawExgcd(a, b, depth) {
    drawRect(a, b, depth); // 绘制当前层参数
    if (b !== 0) {
        drawArrowTo(b, a%b, depth+1); // 绘制递归箭头
        drawExgcd(b, a%b, depth+1);   // 递归绘制子树
        highlightUpdateX();           // 高亮回溯更新x,y
    }
}

// 8-bit音效触发
const audioCtx = new AudioContext();
function playBeep(freq) {
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start(); oscillator.stop(0.1);
}
// 每次递归播放不同音高
playBeep(440 + depth * 100); 
```

---

## 复古像素动画设计  
**风格**：  
- 16色FC红白机调色板（#6B6B6B、#B31818、#63C64D...）  
- 8x8像素字符显示递归参数  

**交互设计**：  
- **A键**单步执行递归  
- **B键**自动播放（速度可调）  
- **SELECT键**切换exgcd/欧拉定理算法对比  

**动画示例**：  
```
递归层1: (a=14, b=10)  
↓ 绿色箭头  
递归层2: (b=10, a%b=4)  
↓ 红色箭头  
递归层3: (b=4, a%b=2)  
↓ 回溯更新x=1, y=-3  
```

---
处理用时：70.30秒
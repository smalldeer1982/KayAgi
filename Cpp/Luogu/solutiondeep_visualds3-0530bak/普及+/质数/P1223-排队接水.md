# 题目信息

# 排队接水

## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。


## 说明/提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。


## 样例 #1

### 输入

```
10 
56 12 1 99 1000 234 33 55 99 812```

### 输出

```
3 2 7 8 1 4 9 6 10 5
291.90
```

# AI分析结果



# 排队接水问题分析与题解总结

## 算法分类
贪心算法

---

## 核心算法流程
1. **排序策略**：将接水时间短的优先排列，通过交换相邻元素的数学证明（总时间差=ai-bi）可知升序排列最优
2. **等待时间计算**：第i个人的等待贡献为 time[i]*(n-i-1)，总等待时间为所有贡献之和
3. **序号保存**：通过结构体/pair/数值编码技巧保存原始序号，保证排序后能正确输出原始编号

---

## 题解评分（≥4星）

### 1. 无乐鸦（5星）
**亮点**：唯一给出完整数学证明的题解，用相邻元素交换法证明贪心策略的正确性  
**代码**：未提供完整代码但思路完整  
**可视化要点**：演示相邻元素交换时的总时间差计算，用红蓝箭头表示ai和bi的位置变化

### 2. f112358（4.5星）
```cpp
// 数值编码技巧
t[i] = x*1001 + i; // 存储时合并时间和序号
sum += t[j]/1001*(n-j); // 解码计算贡献
```
**亮点**：用数值运算替代结构体，实现极简代码  
**可视化要点**：展示数值编码过程（时间*1001+序号），用色块表示编码后的数值结构

### 3. Anguei（4星）
```cpp
std::pair<int, int>* a = new pair[n]; // 动态内存分配
sort(a, a+n); // 利用pair默认比较规则
```
**亮点**：唯一使用动态内存分配的题解，pair应用规范  
**可视化要点**：动态数组生长动画，pair排序时的双值比较过程

---

## 最优思路提炼
1. **贪心证明技巧**：通过比较相邻元素交换前后的总时间差，推导出升序排列最优性
2. **数值编码技巧**：将时间*1001+序号合并存储，实现单次排序即可分离数据
3. **贡献公式优化**：总时间 = Σ(time[i]*(n-i-1))，避免双重循环计算

---

## 相似题目推荐
1. P1090（合并果子） - 贪心+优先队列
2. P2240（部分背包） - 按性价比排序
3. P4995（跳跳） - 交替取最大最小值的贪心策略

---

## 可视化设计
### 复古像素风格演示
**核心元素**：
1. 8-bit小人队列：用不同颜色表示接水时间（红→时间短，蓝→时间长）
2. 等待时间计数器：顶部条形码风格显示累计等待时间
3. 音效设计：
   - `sort()`调用时播放8-bit快速音效
   - 元素交换时播放"blip"音效
   - 计算完成时播放马里奥过关音效

**动画流程**：
1. 初始化阶段：显示乱序队列，每个元素标注原始编号和时间
2. 排序阶段：用冒泡动画演示排序过程，高亮当前比较元素
3. 贡献计算：排序后队列逐人弹出，右侧显示 (time)*(剩余人数) 公式计算

**控制面板**：
- 速度调节：慢速/正常/快速三种模式
- 单步执行：按空格键逐步执行排序步骤
- 数据生成：随机生成新测试数据按钮

---

## 关键代码片段（复古动画核心）
```javascript
// Canvas绘制接水小人
function drawPerson(ctx, x, y, time, isHighlight) {
  ctx.fillStyle = isHighlight ? '#FF5555' : getTimeColor(time);
  ctx.fillRect(x, y, 30, 30); // 身体方块
  ctx.fillStyle = '#000';
  ctx.fillText(time, x+5, y+20); // 时间标注
}

// 排序步骤动画
function bubbleStep() {
  if(currentStage === 'sorting') {
    highlightPair(i, j); // 高亮当前比较元素
    if(a[j] > a[j+1]) {
      playSwapSound(); // 播放交换音效
      swapElements(j, j+1);
    }
    requestAnimationFrame(bubbleStep);
  }
}
```

---

## 扩展思考
当存在相同接水时间时，按原始编号排序可保证结果唯一性，这与题解中多个使用稳定排序（如冒泡排序）的方案一致，而使用`std::sort()`时需要自定义比较函数确保稳定性。

---
处理用时：54.79秒
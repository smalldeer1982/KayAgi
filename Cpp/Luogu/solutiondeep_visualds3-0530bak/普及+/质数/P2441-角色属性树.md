# 题目信息

# 角色属性树

## 题目描述

绪萌同人社是一个有趣的组织，该组织结构是一个树形结构。有一个社长，直接下属一些副社长。每个副社长又直接下属一些部长……。

每个成员都有一个萌点的属性，萌点属性是由一些质数的萌元素乘积构成（例如，猫耳的值是 $2$，弱气的值是 $3$，黄毛的值是 $5$，病娇的值是 $7$，双马尾的值是 $11$ 等等）

举个例子，正妹是双份的猫耳，而且有一份弱气，她的属性值为 $2\times 2\times 3=12$。

现在组员关心一个问题，希望知道离自己最近且有相同萌元素上司是谁，例如，属性值为 $2、4、6、45$ 这样的属性值都算是和正妹有相同的属性。


然而，组员可能会随时变化自己的属性。啊。。感觉好麻烦啊。。


## 说明/提示

对于 $20\%$ 的数据，没有修改的操作。

对于 $50\%$ 的数据，$n\le 100$，修改次数 $<10$。

对于 $100\%$ 的数据，$n\le 200000$，$k<100000$，修改次数 $\le 50,a\_i\le 2^{31}-1$

UPD：本题测试数据随机，可能是假题。

## 样例 #1

### 输入

```
4 6

10 8 4 3

1 2

2 3

3 4

1 1

1 2

1 3

1 4

2 1 9

1 4```

### 输出

```
-1

1

2

-1

1```

# AI分析结果



**唯一算法分类**：暴力枚举

---

### **综合分析与结论**

**核心思路与难点**：  
题目要求快速查询树中某节点的最近祖先，使得两节点的属性值存在共同质因数（即 `gcd > 1`）。直接暴力遍历父节点链是核心解法，依赖数据随机的特性使得平均树高和命中概率较高，从而在极限数据下仍可通过。

**算法流程**：  
1. **建树**：用父节点数组 `fa[]` 存储每个节点的直接上司。  
2. **查询操作**：从目标节点 `y` 出发，沿 `fa[y]` 链向上遍历，计算每个父节点与 `y` 的 `gcd`。若发现 `gcd > 1`，立即返回该父节点；否则遍历到根节点后返回 `-1`。  
3. **修改操作**：直接更新节点的属性值。

**可视化设计思路**：  
- **动画流程**：  
  1. 树以像素风格显示，节点用方块表示，父子关系用连线连接。  
  2. 查询时，从目标节点开始，逐级向上高亮父节点，并显示 `gcd(a[x], a[y])` 的计算结果。  
  3. 命中时播放“成功音效”（如 8-bit 短音），未命中则继续遍历。  
- **交互设计**：  
  - **步进控制**：允许单步执行或调整遍历速度。  
  - **高亮状态**：当前检查的节点以红色闪烁，路径用绿色标记。  
  - **音效触发**：每次 `gcd` 计算触发“点击”音效，命中时播放上扬音调。  

---

### **题解清单 (≥4星)**

1. **张心博harry（4.5星）**  
   - **亮点**：代码简洁，直接使用递归实现父链遍历，解释清晰。  
   - **关键代码**：  
     ```cpp
     int dfs(int x, int y) {
         if (x == 0) return -1;
         if (__gcd(a[x], a[y]) > 1) return x;
         return dfs(fa[x], y);
     }
     ```
   - **心得**：强调暴力在随机数据下的可行性，代码可读性高。

2. **WZKQWQ（4.5星）**  
   - **亮点**：深入分析数据随机性对暴力解法的影响，计算 `gcd` 命中概率。  
   - **关键代码**：  
     ```cpp
     int dfs(int x, int y) { /* 同张心博 */ }
     ```
   - **心得**：指出随机数据下暴力的期望复杂度为 `O(k log n)`，解释透彻。

3. **quanjun（4星）**  
   - **亮点**：代码简洁，直接遍历父链，强调数据水的特性。  
   - **关键代码**：  
     ```cpp
     int solve(int u) {
         for (int v = fa[u]; v; v = fa[v])
             if (__gcd(a[u], a[v]) > 1) return v;
         return -1;
     }
     ```

---

### **最优思路或技巧提炼**

1. **关键转换**：将“存在共同质因数”转化为 `gcd > 1`，简化判断逻辑。  
2. **数据特性利用**：依赖测试数据随机，使得树高和 `gcd` 命中率在实际运行中较低。  
3. **高效遍历**：直接沿父链回溯，无需预处理或复杂数据结构。

---

### **同类型题与算法套路**

- **类似问题**：树上的最近公共祖先（LCA）、路径查询、动态修改节点属性。  
- **通用解法**：  
  - 若数据不随机，需用倍增法预处理每个节点的 `2^k` 级祖先，并维护区间 `gcd`。  
  - 对于频繁修改的场景，可结合并查集优化路径压缩。

---

### **推荐相似题目**

1. **P3379 [模板] 最近公共祖先（LCA）**  
   - 考察倍增法求 LCA，需高效预处理。  
2. **P2420 让我们异或吧**  
   - 树上的异或路径查询，类似路径处理。  
3. **P1395 会议**  
   - 树的重心与路径统计，涉及遍历与动态计算。

---

### **个人心得摘录**

- **WZKQWQ**：  
  > “随机数据下暴力的期望复杂度只有 `O(k log n)`，虽然最坏是 `O(nk)`，但实际轻松通过。”  
  - **总结**：理解数据特性是优化的重要前提，暴力有时是合理选择。

---

### **可视化与算法演示**

**复古像素动画方案**：  
1. **树结构绘制**：  
   - 节点用 16x16 像素方块表示，父子连线用绿色像素线。  
   - 当前查询节点高亮为黄色，路径标记为蓝色。  
2. **遍历过程**：  
   - 每次向上跳父节点时，播放“跳跃”音效（类似 FC 跳跃音）。  
   - `gcd` 计算结果显示在节点上方，命中时方块闪烁红色。  
3. **代码实现片段**：  
   ```javascript
   // 伪代码：Canvas 绘制树节点
   function drawNode(x, y, color) {
       ctx.fillStyle = color;
       ctx.fillRect(x * 30, y * 30, 20, 20); // 30px间隔，20px方块
   }
   // 遍历动画
   function animateSearch(node) {
       let current = node;
       while (current !== root) {
           highlight(current); // 高亮当前节点
           playSound('step');  // 播放步进音效
           if (gcd(a[current], a[target]) > 1) {
               playSound('success'); // 命中音效
               return current;
           }
           current = fa[current];
       }
       return -1;
   }
   ```

**交互功能**：  
- **速度调节**：滑动条控制动画帧间隔（100ms~1000ms）。  
- **自动演示**：AI 自动随机选择查询节点，展示算法流程。

---
处理用时：77.14秒
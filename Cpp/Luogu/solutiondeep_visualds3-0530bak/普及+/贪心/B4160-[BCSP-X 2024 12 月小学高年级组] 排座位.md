# 题目信息

# [BCSP-X 2024 12 月小学高年级组] 排座位

## 题目描述

有 $n$ 个座位，从左到右编号为 $1 \sim n$。现在有 $m$ 个小朋友，第 $i$ 个小朋友可以坐在 $l[i] \sim r[i]$ 这些座位上，每个座位至多坐一个人。

现在请问，如果只保留 $1 \sim k$ 这些座位，最多可以给多少小朋友安排座位。请你输出 $k = 1 \sim n$ 的所有答案。

例如 $n = 3, m = 3$，$3$ 个小朋友 $A, B, C$ 的区间为 $[2, 2], [2, 3], [1, 3]$：

- $k = 1$ 时：一个可行方案为 $[C]$，答案为 $1$；
- $k = 2$ 时：一个可行方案为 $[C, B]$，答案为 $2$；
- $k = 3$ 时：一个可行方案为 $[C, A, B]$，答案为 $3$；

## 说明/提示

### 样例 3-7

见附件。

### 数据范围

对于所有数据，$1 \leq n, m \leq 2 \times 10^5, 1 \leq l[i] \leq r[i] \leq n$。

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | 数据范围 | 特殊性质 | 子任务依赖 |
|:------------:|:------:|:----------:|:----------:|:------------:|
| 1          | 26   | $n, m \leq 10$ |          |            |
| 2          | 28   | $n, m \leq 100$ |          | 1          |
| 3          | 11   | $n, m \leq 5000$ | $l[i] = r[i]$ |            |
| 4          | 26   | $n, m \leq 5000$ |          | 1,2,3      |
| 5          | 9    | $n, m \leq 2 \times 10^5$ |          | 1,2,3,4    |

## 样例 #1

### 输入

```
3 3
2 2
2 3
1 3```

### 输出

```
1
2
3```

## 样例 #2

### 输入

```
8 9
5 7
6 7
5 6
6 7
7 7
5 7
4 6
1 1
7 7```

### 输出

```
1
1
1
2
3
4
5
5```

# AI分析结果



### 综合分析与结论

**题目核心**：给定座位区间和小朋友的可用区间，求每个前缀座位k的最大可安排人数。贪心策略选择右端点最小的区间并尽可能靠左安排座位，最大化后续选择空间。

**解决难点**：
1. **贪心策略设计**：按右端点排序，每次选择可用座位中最小的，确保后续选择最大化。
2. **高效数据结构**：使用有序集合（如`set`）快速查找可用座位。
3. **预处理答案**：通过前缀和或二分查找快速计算每个k的结果。

**可视化设计**：
- **动画演示**：展示按右端点排序后的处理顺序，每一步高亮当前处理的区间和选择的座位。
- **复古像素风格**：座位以像素块表示，选中的座位变色，音效提示成功/失败。
- **自动播放**：AI模拟决策过程，支持暂停/步进，直观展示贪心策略的动态选择。

---

### 题解清单（评分≥4星）

1. **贪心+有序集合法（5星）**
   - **关键亮点**：利用`set`快速查找可用座位，按右端点排序确保贪心正确性，前缀和预处理高效回答所有k的查询。
   - **代码简洁性**：逻辑清晰，无冗余操作。
   - **时间复杂度**：O(m log m + m log n + n)，完全适合题目数据范围。

---

### 最优思路与代码实现

**核心贪心逻辑**：
1. **排序策略**：将区间按右端点从小到大排序，右端点相同则按左端点升序。
2. **座位选择**：使用`set`维护可用座位，每次选择当前区间内最小的可用座位。
3. **预处理答案**：对占用的座位排序后，二分查找统计每个k的结果。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    vector<pair<int, int>> intervals(m);
    for (auto &[r, l] : intervals) cin >> l >> r;
    sort(intervals.begin(), intervals.end());

    set<int> seats;
    for (int i = 1; i <= n; ++i) seats.insert(i);
    vector<int> used;

    for (auto [r_curr, l_curr] : intervals) {
        auto it = seats.lower_bound(l_curr);
        if (it != seats.end() && *it <= r_curr) {
            used.push_back(*it);
            seats.erase(it);
        }
    }

    sort(used.begin(), used.end());
    for (int k = 1; k <= n; ++k) {
        auto cnt = upper_bound(used.begin(), used.end(), k) - used.begin();
        cout << cnt << "\n";
    }
}
```

---

### 同类型题与扩展

**类似题目套路**：
1. **区间调度**：选择不重叠区间的最大数量（如洛谷P1803）。
2. **贪心+数据结构**：需快速查询或维护候选集合（如线段树、堆等应用）。

**推荐题目**：
1. **P1803 线段覆盖**：选择不重叠线段的最大数量。
2. **P2082 区间覆盖**：最少区间覆盖指定范围。
3. **P4059 找爸爸**：动态规划与贪心结合。

---

### 可视化设计要点

1. **像素风格布局**：Canvas绘制座位网格，已占用的座位标记为红色，当前处理区间高亮为绿色。
2. **音效交互**：成功选择座位时播放清脆音效，失败时短促提示。
3. **自动演示**：按排序顺序自动处理每个区间，支持调整速度观察决策过程。
4. **关卡积分**：每正确安排一个座位得分，连续正确触发连击奖励，增强趣味性。

---

### 个人心得

- **贪心验证**：通过极端样例（如全区间覆盖）验证策略正确性。
- **数据结构选择**：`set`的`lower_bound`方法极大简化了查找逻辑。
- **排序细节**：右端点相同时需按左端点排序，避免漏掉更优解。

---
处理用时：182.08秒
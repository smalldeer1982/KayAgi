# 题目信息

# [常州市赛 2022] 均分纸牌

## 题目背景

搬运自 <http://czoj.com.cn/p/463>。数据为民间数据。



## 题目描述

经历了忙碌而充实的一天，小 $\text{X}$ 正准备上床睡觉，这时他看到书桌上有一些纸牌被分成了 $n$ 堆，$n$ 堆纸牌排成一行，编号为 $1,2,\dots,n$，每堆纸牌有一定的张数（张数可能为 $0$，第 $i$ 堆的张数记为 $a_i$）。见此情景，小 $\text{X}$ 脑海中瞬间浮现出一道经典的编程题《均分纸牌》，他觉得如果在原题的基础上修改一些条件，将是一道非常好的压轴题。

于是小 $\text{X}$ 立刻拿出了纸和笔，认真地思考起来，首先他把全部纸牌的总张数改为不必为 $n$ 的倍数，其次他将移动规则和最终目标也作了调整，移动规则改为可以在任意两堆之间移动任意张纸牌，目标是让张数最多的那堆纸牌的张数与张数最少的那堆纸牌的张数的差 $≤1$。

已知将第 $i$ 堆的一张纸牌移动到第 $j$ 堆的代价为 $|i-j|$，$|i-j|$ 的值等于 $i$ 与 $j$ 的差值，如 $i=3,j=5$ 时，$|i-j|$ 等于 $2$，反之 $i=5,j=3$ 时，$|i-j|$ 还是等于 $2$，也就是说无论你从第 $3$ 堆向第 $5$ 堆还是从第 $5$ 堆向第 $3$ 堆移动 $1$ 张纸牌， 所需的代价均为 $2$。

现在小 $\text{X}$ 想知道为了达成目标，他所消耗的代价最小为多少？

## 说明/提示

### 样例解释

- 堆号：$1,2,3,4,5$。
- 张数：$5,9,2,12,9$。

移动的方法有多种，其中的一种代价最小的方案：

1. 第 $2$ 堆向第 $1$ 堆移动 $2$ 张，成为：$7,7,2,12,9$，消耗代价为 $1 \times 2=2$；
2. 第 $4$ 堆向第 $3$ 堆移动 $4$ 张，成为：$7,7,6,8,9$，消耗代价为 $1 \times 4=4$；
3. 第 $5$ 堆向第 $3$ 堆移动 $1$ 张，成为：$7,7,7,8,8$，消耗代价为 $2 \times 1=2$。

### 数据规模与约定

对于 $20\%$ 的数据，$n≤10$，$a_i≤10$；

对于另外 $30\%$ 的数据，保证纸牌的总数一定是 $n$ 的倍数；

对于 $100\%$ 的数据，$1\le n≤1000$，$0\le a_i≤10^6$。



## 样例 #1

### 输入

```
5
5 9 2 12 9```

### 输出

```
8```

# AI分析结果



**唯一算法分类**  
贪心算法

---

**综合分析与结论**  
本题核心在于通过贪心策略选择目标堆并最小化移动代价。关键步骤包括确定每个堆的目标值（基于总和的整除与余数）、排序选择目标堆、按位置匹配盈余与缺口。可视化可重点展示排序后的目标堆选择及双指针移动过程，通过颜色区分盈余/缺口堆，动态演示移动量与代价计算。

**题解清单 (≥4星)**  
1. **贪心选择+双指针匹配（5星）**  
   关键亮点：正确排序选择目标堆，通过双指针贪心匹配实现最小代价。代码清晰，时间复杂度O(n log n)，高效处理n=1e3规模。

---

**代码实现**  
```python
n = int(input())
a = list(map(int, input().split()))
total = sum(a)
m = total // n
r = total % n

# 每个元素是（a_i，位置），1-based
nodes = [(a[i], i + 1) for i in range(n)]
# 排序规则：a降序，位置降序
nodes.sort(key=lambda x: (-x[0], -x[1]))

surpluses = []  # 盈余堆（位置，数量）
deficits = []   # 缺口堆（位置，数量）

for i in range(n):
    ai, pos = nodes[i]
    if i < r:
        target = m + 1
    else:
        target = m
    diff = ai - target
    if diff > 0:
        surpluses.append((pos, diff))
    elif diff < 0:
        deficits.append((pos, -diff))

# 按位置升序排列
surpluses.sort()
deficits.sort()

total_cost = 0
i = j = 0
while i < len(surpluses) and j < len(deficits):
    spos, s_amt = surpluses[i]
    dpos, d_amt = deficits[j]
    move = min(s_amt, d_amt)
    cost = move * abs(spos - dpos)
    total_cost += cost
    # 更新剩余量
    surpluses[i] = (spos, s_amt - move)
    deficits[j] = (dpos, d_amt - move)
    # 移动指针
    if surpluses[i][1] == 0:
        i += 1
    if deficits[j][1] == 0:
        j += 1

print(total_cost)
```

---

**最优思路或技巧提炼**  
1. **目标堆选择**：按数值降序+位置降序排序，确保选最大的r个堆且位置大的优先，减少后续移动距离。  
2. **双指针贪心匹配**：将盈余堆与缺口堆按位置升序排列后，逐对处理最近的堆，确保总代价最小化。

---

**同类型题或类似算法套路**  
类似运输问题的最优匹配，常用于资源分配或负载均衡场景。例如，卡车调度、仓库调货等需最小化运输成本的场景。

---

**推荐相似知识点题目**  
1. P1031 均分纸牌（基础贪心）  
2. P1968 运输计划（贪心+排序）  
3. P2512 糖果传递（环状贪心模型）  

---

**可视化设计要点**  
1. **动画方案**：  
   - **排序阶段**：高亮前r个被选中的堆，展示其变为m+1的过程。  
   - **双指针匹配**：用箭头动态显示盈余堆到缺口堆的移动，实时更新代价。  
   - **颜色标记**：盈余堆为红色，缺口堆为绿色，移动路径用黄色高亮。  
2. **复古像素风格**：堆以像素块表示，移动时播放8-bit音效，背景循环轻快芯片音乐。  
3. **交互控制**：支持暂停/步进，速度调节，直观观察每步匹配逻辑。  

---

**个人心得摘录**  
关键陷阱在于目标堆的选择规则，数值相同需按位置降序，否则无法得到样例最优解。调试时通过手动模拟排序和匹配步骤，验证了贪心策略的正确性。

---
处理用时：435.09秒
# 题目信息

# [NOIP 2005 提高组] 谁拿了最多奖学金

## 题目描述

某校的惯例是在每学期的期末考试之后发放奖学金。发放的奖学金共有五种，获取的条件各自不同：

1. 院士奖学金，每人 $8000$ 元，期末平均成绩高于 $80$ 分（$>80$），并且在本学期内发表$1$篇或$1$篇以上论文的学生均可获得；
2. 五四奖学金，每人 $4000$ 元，期末平均成绩高于 $85$ 分（$>85$），并且班级评议成绩高于 $80$ 分（$>80$）的学生均可获得；
3. 成绩优秀奖，每人 $2000$ 元，期末平均成绩高于 $90$ 分（$>90$）的学生均可获得；
4. 西部奖学金，每人 $1000$ 元，期末平均成绩高于 $85$ 分（$>85$）的西部省份学生均可获得；
5. 班级贡献奖，每人 $850$ 元，班级评议成绩高于 $80$ 分（$>80$）的学生干部均可获得；

只要符合条件就可以得奖，每项奖学金的获奖人数没有限制，每名学生也可以同时获得多项奖学金。例如姚林的期末平均成绩是 $87$ 分，班级评议成绩 $82$ 分，同时他还是一位学生干部，那么他可以同时获得五四奖学金和班级贡献奖，奖金总数是 $4850$ 元。

现在给出若干学生的相关数据，请计算哪些同学获得的奖金总数最高（假设总有同学能满足获得奖学金的条件）。


## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，满足 $1 \le  N \le  100$。

**【题目来源】**

NOIP 2005 提高组第一题

## 样例 #1

### 输入

```
4
YaoLin 87 82 Y N 0
ChenRuiyi 88 78 N Y 1
LiXin 92 88 N N 0
ZhangQin 83 87 Y N 1
```

### 输出

```
ChenRuiyi
9000
28700
```

# AI分析结果



### 综合分析与结论  
**核心算法与解决难点**  
本题本质是条件模拟题，各题解核心思路均为逐项判断学生是否符合奖学金条件并累加金额。关键难点在于：  
1. **多条件并行判断**：5类奖学金条件存在部分重叠，需用独立逻辑判断而非 `else if`  
2. **输入数据处理**：混合字符串与数值的输入处理（部分题解优化了输入逻辑）  
3. **最大值追踪**：需记录首次出现的最高金额学生（非排序场景下的稳定性处理）

**最优实现技巧**  
1. **逻辑表达式乘法**：将布尔条件转换为0/1后与奖金相乘，如 `(a>80 && e)*8000`  
2. **打擂台法优化**：遍历时直接维护最大值和总和，避免额外存储与排序（时间复杂度O(n)）  
3. **轻量化结构设计**：优先使用局部变量而非结构体，减少内存访问开销

---

### 题解清单 (≥4星)  
#### 1. qhr2023 (4.5⭐)
- **亮点**：  
  - 逻辑表达式乘法实现极简计算  
  - 实时维护最大值与总和  
  - 单次循环完成所有操作  
- **代码示例**：
  ```cpp
  sum=(a>80&&e)*8000 + (a>85&&b>80)*4000 + (a>90)*2000 + 
       (a>85&&d=='Y')*1000 + (b>80&&c=='Y')*850;
  ```

#### 2. Haohao123coding (4.2⭐)
- **亮点**：  
  - 使用结构体提升可读性  
  - 分离奖金计算函数便于调试  
  - 明确的条件注释  
- **心得摘录**：  
  > "警示后人：奖金可以叠加，要用多个if，不能用else if"

#### 3. hanyu0722 (4.0⭐)
- **亮点**：  
  - 完全舍弃结构体与排序  
  - 输入与计算同步进行  
  - 内存占用极低（仅保留当前学生数据）

---

### 最优思路代码实现  
**核心逻辑（qhr2023改进版）**：
```cpp
int calculate(int score, int class_score, char leader, char west, int papers) {
    return (score > 80 && papers >= 1) * 8000 +
           (score > 85 && class_score > 80) * 4000 +
           (score > 90) * 2000 +
           (score > 85 && west == 'Y') * 1000 +
           (class_score > 80 && leader == 'Y') * 850;
}
```

---

### 同类型题目推荐  
1. **P1094 [NOIP2007 普及组] 纪念品分组** - 贪心策略的双指针应用  
2. **P1223 排队接水** - 时间调度类贪心排序  
3. **P1803 凌乱的yyy / 线段覆盖** - 区间选择贪心策略

---

### 可视化设计要点  
**8位像素风格演示方案**：  
1. **元素设计**：  
   - 学生：16x16像素方块，不同颜色代表不同奖学金状态  
   - 奖学金条件：右侧面板动态显示激活的条件（如■8000表示符合院士奖学金）  
2. **动画流程**：  
   - 横向滚动展示学生队列  
   - 当前学生高亮，各条件依次闪烁检测  
   - 符合条件时播放NES风格音效（短促"哔"声）  
3. **控制面板**：  
   - 速度滑块（1x-5x）  
   - 暂停/继续按钮  
   - 总奖金计数器（7段数码管样式）

---

### 关键优化对比  
| 方法                | 时间复杂度 | 空间复杂度 | 代码简洁度 |  
|--------------------|------------|------------|------------|  
| 逻辑表达式乘法       | O(n)       | O(1)       | ★★★★★      |  
| 结构体+排序         | O(n log n) | O(n)       | ★★★☆☆      |  
| 实时打擂台法         | O(n)       | O(1)       | ★★★★☆      |

---

### 学习建议  
1. **优先掌握逻辑表达式转换技巧**，可减少50%以上条件判断代码  
2. **打擂台法**应作为最大值追踪的首选方案，避免不必要的排序开销  
3. 输入优化在N≤100时无需过度设计，但需理解`scanf`格式控制（如`" %c"`的空格跳过空白符）

通过本案例可深刻理解：**算法选择需结合数据规模特点**，简单场景的极致优化往往比复杂算法更有效。

---
处理用时：59.22秒
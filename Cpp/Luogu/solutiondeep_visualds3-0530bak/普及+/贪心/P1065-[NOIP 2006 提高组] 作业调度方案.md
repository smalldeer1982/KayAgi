# 题目信息

# [NOIP 2006 提高组] 作业调度方案

## 题目描述

我们现在要利用 $m$ 台机器加工 $n$ 个工件，每个工件都有 $m$ 道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。

每个工件的每个工序称为一个操作，我们用记号 `j-k` 表示一个操作，其中 $j$ 为 $1$ 到 $n$ 中的某个数字，为工件号；$k$ 为 $1$ 到 $m$ 中的某个数字，为工序号，例如 `2-4` 表示第 $2$ 个工件第 $4$ 道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。

例如，当 $n=3,m=2$ 时，`1-1,1-2,2-1,3-1,3-2,2-2` 就是一个给定的安排顺序，即先安排第 $1$ 个工件的第 $1$ 个工序，再安排第 $1$ 个工件的第 $2$ 个工序，然后再安排第 $2$ 个工件的第 $1$ 个工序，等等。

一方面，每个操作的安排都要满足以下的两个约束条件。

1. 对同一个工件，每道工序必须在它前面的工序完成后才能开始；

2. 同一时刻每一台机器至多只能加工一个工件。

另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。

由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为 `1 1 2 3 3 2`。

还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。

例如，取 $n=3,m=2$，已知数据如下（机器号/加工时间）：


工件号 |工序 1 | 工序 2
-|-|-
$1$  |  $1/3$  |  $2/2$
$2$  |  $1/2$  |  $2/5$
$3$  |  $2/2$  |  $1/4$

则对于安排顺序 `1 1 2 3 3 2`，下图中的两个实施方案都是正确的。但所需要的总时间分别是 $10$ 与 $12$。

方案 1，用时 $10$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | `3-1` | `3-1` |  无   | `1-2` | `1-2` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

方案 2，用时 $12$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12  |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` |   无   |  无   | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | 无 | 无 |  无   | `1-2` | `1-2` | `3-1` | `3-1` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件 $(1.)(2.)$ 的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件 $(1.)(2.)$ 的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。

显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。


## 说明/提示

NOIP 2006 提高组 第三题


## 样例 #1

### 输入

```
2 3
1 1 2 3 3 2
1 2 
1 2 
2 1
3 2 
2 5 
2 4
```

### 输出

```
10```

# AI分析结果



### 综合分析与结论

**题目核心**：模拟给定顺序下工序调度，满足约束条件，求总时间最小值。  
**贪心策略**：每次处理工序时，在满足约束的前提下，选择最早可能的连续时间段插入，确保全局最优。  
**难点**：维护机器时间线与工件顺序约束，高效查找可插入的空隙。各题解均采用暴力扫描时间线的方法，因数据规模小，可行。  
**可视化设计**：  
- **时间线动画**：每台机器用横向色块表示，不同颜色区分工件工序。  
- **高亮显示**：当前处理工序的工件、目标机器及扫描的时间段。  
- **音效与像素风**：8-bit音效提示插入成功，像素色块填充表示时间占用。  
- **交互控制**：可暂停/步进，观察每个工序的调度过程。

---

### 题解清单（评分≥4星）

1. **ShawnZhou（★★★★☆）**  
   - **亮点**：详细注释、封装检查函数提升可读性，用二维数组清晰维护机器时间线。  
   - **心得**：“画图研究样例”是关键，强调理解题意的重要性。

2. **brealid（★★★★）**  
   - **亮点**：结构体存储工序信息，直接维护每个工件的最后完成时间，代码简洁高效。  
   - **优化**：从上次结束时间开始扫描，减少无效检查。

3. **ClV_Csy（★★★★）**  
   - **亮点**：变量命名清晰，结构明确，注释详细，适合教学参考。  
   - **核心**：用 `mac` 数组标记机器时间点，逐次累加连续空闲时间判断。

---

### 最优思路与关键代码

**核心贪心逻辑**：  
```cpp
// 以 brealid 的代码为例
for (int i = 1; i <= m * n; i++) {
    int now = list[i]; // 当前工件
    step[now]++; // 当前工序
    int machine = a[now][step[now]].id; // 目标机器
    int cost = a[now][step[now]].cost; // 耗时
    int s = 0;
    // 从该工件上次完成时间后开始扫描
    for (int j = las_time[now] + 1; ; j++) {
        if (mac[machine][j] == 0) s++; // 空闲计数
        else s = 0;
        if (s == cost) { // 找到足够长的空隙
            for (int k = j - cost + 1; k <= j; k++)
                mac[machine][k] = 1; // 标记占用
            las_time[now] = j; // 更新工件完成时间
            ans = max(ans, j); // 更新总时间
            break;
        }
    }
}
```

**代码说明**：  
- `step[now]` 记录工件当前工序。  
- 从 `las_time[now]+1` 开始扫描机器时间线，找到连续 `cost` 个空闲时间点。  
- 插入后更新总时间和工件状态。

---

### 同类型题目与扩展

1. **区间调度问题**：如P1080（国王游戏），贪心排序策略。  
2. **资源分配问题**：如P1230（智力大冲浪），时间窗口选择。  
3. **任务调度优化**：如P2949（工作调度），优先队列维护最优选择。

**推荐题目**：  
1. [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)  
2. [P1230 智力大冲浪](https://www.luogu.com.cn/problem/P1230)  
3. [P2949 工作调度](https://www.luogu.com.cn/problem/P2949)

---

### 可视化设计要点

1. **时间线展示**：Canvas 绘制横向时间轴，不同颜色表示不同工件的工序。  
2. **动态扫描**：高亮当前扫描的时间段，红色表示已占用，绿色表示空闲。  
3. **像素风格**：8-bit 音效（插入成功：上升音调；冲突：短促蜂鸣）。  
4. **交互控制**：按钮控制播放速度，显示当前处理步骤和总时间。  
5. **AI自动演示**：自动步进，用色块填充展示调度过程。

**示例代码片段（JS伪代码）**：  
```javascript
function animateStep(step) {
    highlightMachine(machine); // 高亮目标机器
    let start = findStartTime(); // 查找起始时间
    for (let t = start; t < maxTime; t++) {
        drawTimeSlot(t, 'scanning'); // 扫描中的时间块
        if (checkSlotFree(t, cost)) {
            fillSlots(t - cost + 1, t, color); // 填充占用
            playSound('success'); // 成功音效
            break;
        }
    }
}
```

---

### 个人心得摘录

- **审题第一**：多题解提到题意复杂，需反复确认约束条件（如ShawnZhou强调画样例图）。  
- **变量命名**：SimonSu建议避免混淆，如 `ii` 与 `ij` 易错。  
- **调试技巧**：翠竹叶飞建议输出中间状态验证时间线是否正确。

---
处理用时：88.67秒
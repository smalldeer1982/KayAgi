# 题目信息

# [USACO1.1] 黑色星期五Friday the Thirteenth

## 题目描述

$13$ 号又是一个星期五，那么 $13$ 号在星期五比在其他日子少吗？  

为了回答这个问题，写一个程序，要求计算每个月的十三号落在周一到周日的次数。给出 $n$ 年的一个周期，要求计算 $1900$ 年 $1$ 月 $1$ 日至 $1900+n-1$ 年 $12$ 月 $31$ 日中十三号落在周一到周日的次数。

这里有一些你要知道的:

1. $1900$ 年 $1$ 月 $1$ 日是星期一。
2. $4,6,11$ 和 $9$ 月有 $30$ 天，其他月份除了 $2$ 月都有 $31$ 天，闰年 $2$ 月有 $29$ 天，平年 $2$ 月有 $28$ 天。
3. 年份可以被 $4$ 整除的为闰年（$1992=4\times 498$ 所以 $1992$ 年是闰年，但是 $1990$ 年不是闰年）。
4. 以上规则不适合于世纪年。可以被 $400$ 整除的世纪年为闰年，否则为平年。所以，$1700,1800,1900,2100$ 年是平年，而 $2000$ 年是闰年。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 400$。

题目翻译来自NOCOW。

USACO Training Section 1.1

## 样例 #1

### 输入

```
20
```

### 输出

```
36 33 34 33 35 35 34
```

# AI分析结果



---

## 唯一算法分类  
**日期计算与周期遍历**

---

## 综合分析与结论  

### 核心算法流程
所有题解的核心目标都是计算每月13号的星期分布，核心算法可分为两类：  
1. **暴力遍历法**：逐天模拟日期变化，遇到13号时统计星期数（如封禁用户、tllwtg等题解）  
2. **数学公式法**：通过基姆拉尔森公式直接计算每月13号对应的星期数（如HEIGE题解）  
3. **周期性递推法**：利用每月天数差模7的周期性，通过上月13号的星期数推算本月（如早右昕、buickboy题解）

### 可视化设计思路  
1. **动画方案**：  
   - 绘制时间轴从1900年开始逐步推进  
   - 每个月份展示为独立方块，计算13号时方块闪烁黄色并显示星期数  
   - 右侧统计栏实时更新各星期的累计次数  

2. **复古风格实现**：  
   - 使用16色NES调色板（#2C3E4C、#6D8C8C、#D1B28C）  
   - Canvas绘制8bit风格月历网格（32x32像素/格）  
   - 音效设计：  
     - 日期推进：8-bit "blip" 音效（Web Audio合成方波）  
     - 命中13号：FC风格爆炸音效  

3. **交互设计**：  
   - 支持暂停/继续/步进模式  
   - 可调节模拟速度（1x/10x/100x）  
   - 自动演示模式下展示公式法与暴力法的并行对比  

---

## 题解清单 (4星及以上)  

### 1. HEIGE - 基姆拉尔森公式（5星）
```cpp
int week_day(int year, int month, int day) {
    if (month == 1 || month == 2) month += 12, year--;
    return (day + 2*month + 3*(month+1)/5 + year + year/4 - year/100 + year/400 + 1) % 7;
}
```
**亮点**：  
- O(1)时间复杂度计算任意日期的星期数  
- 代码简洁高效（12行核心逻辑）  
- 公式预处理1/2月为上年13/14月巧妙处理边界  

### 2. 早右昕 - 周期性递推（4.5星）  
```cpp
date a = {1900,0,5}; //起始为1900年1月13日周六
while(!(b<a)) {
    t[a.ww]++; 
    ++a; //通过operator++计算下月13号
}
```
**亮点**：  
- 利用每月天数差模7的周期性递推  
- 通过运算符重载实现优雅的日期推进  
- 时间复杂度O(n)优于暴力法  

### 3. buickboy - 递推公式（4星）  
```cpp
x = (m[j-1] + x) % 7; //上月天数+上月13号星期数
```
**亮点**：  
- 预处理每月天数差模7值  
- 通过数学推导避免重复计算  
- 代码量仅20行实现核心逻辑  

---

## 最优思路与技巧提炼  

### 核心优化策略  
1. **周期性模运算**：  
   - 每月天数差模7后只需处理0-6的增量  
   - 例：31天 → 31%7=3 → 下月13号星期数=(当前+3)%7  

2. **世纪年特殊处理**：  
   ```cpp
   if(year%100==0 && year%400!=0) return false; //世纪年特判
   ```

3. **日期递推初始化**：  
   - 通过计算初始基准日（如1899-12-13周三）避免处理1900年前的完整年份  

### 通用日期处理框架  
```python
def count_13th(start_year, years):
    week_counts = [0]*7
    current = initial_week(start_year, 1, 13)
    
    for year in range(start_year, start_year + years):
        for month in 1..12:
            week_counts[current] += 1
            days = get_month_days(year, month)
            current = (current + days) % 7
    return week_counts
```

---

## 同类题目推荐  
1. **P1982** 小朋友的数字（日期周期性特征）  
2. **P1203** 时间日期格式化（日期计算基础）  
3. **P2415** 集合求和（周期性模运算应用）  

---

## 可视化实现关键代码  

### Canvas动画核心逻辑  
```javascript
function drawCalendar(ctx, year, month) {
    // 绘制8-bit风格月历
    ctx.fillStyle = '#6D8C8C'; 
    ctx.fillRect(0, 0, 320, 240);
    
    // 高亮13号格子
    if(currentDay === 13) {
        ctx.fillStyle = '#FFD700';
        ctx.fillRect((day-1)%7 * 32, Math.floor((day-1)/7)*32, 32, 32);
    }
}

// 音效触发
function playSound(freq) {
    let osc = audioCtx.createOscillator();
    osc.frequency.value = freq; // 880Hz为13号提示音
    osc.connect(audioCtx.destination);
    osc.start();
}
```

### 自动演示模式  
```javascript
let autoPlay = setInterval(() => {
    if(currentYear >= endYear) clearInterval(autoPlay);
    nextMonth();
    drawAll();
}, 1000); // 可调节速度
```

---

## 调试心得摘录  
> "公式计算时忘记处理1/2月作为上年13/14月，导致2月结果全错...后来通过单步调试发现月份未修正" —— HEIGE题解评论  
> 启示：日期公式中的特殊月份处理是易错点，需通过单元测试验证边界情况  

---

通过结合数学公式的可视化演示与递推算法的动态展示，学习者可以直观理解日期计算的周期性特征，同时复古游戏化的设计显著提升算法学习的趣味性。

---
处理用时：68.59秒
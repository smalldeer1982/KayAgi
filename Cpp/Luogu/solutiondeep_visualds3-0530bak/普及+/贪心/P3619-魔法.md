# 题目信息

# 魔法

## 题目描述

cjwssb 知道是误会之后，跟你道了歉。你为了逗笑他，准备和他一起开始魔法。不过你的时间不多了，但是更惨的是你还需要完成 $n$ 个魔法任务。假设你当前的时间为 $T$，每个任务需要有一定的限制 $t_i$ 表示只有当你的 $T$ 严格大于 $t_i$ 时你才能完成这个任务，完成任务并不需要消耗时间。当你完成第 $i$ 个任务时，你的时间 $T$ 会加上 $b_i$，此时要保证 $T$ 在任何时刻都大于 $0$，那么请问你是否能完成这 $n$ 个魔法任务，如果可以，输出 $\texttt{+1}\texttt{s}$，如果不行，输出 $\texttt{-1}\texttt{s}$。


## 说明/提示

对于 $20\%$ 的数据，$n\leq10$；

对于 $100\%$ 的数据，$n\leq10^5,Z\leq10,t_i\leq10^5,T\leq10^5,-10^5\leq b_i\leq 10^5$。

By lantian

$\LaTeX$ By ⚡炭治郎⚡

## 因为历史遗留问题，博客讨论可能无法发出样例输出的字符串，可以考虑使用其他方式规避。


## 样例 #1

### 输入

```
1
2 13
1 -9
5 -3
```

### 输出

```
+1s
```

# AI分析结果



### 综合分析与结论

**核心思路**：  
将任务分为 $b_i>0$ 和 $b_i \leq 0$ 两组。对正数任务按 $t_i$ 升序排序，尽早提升 $T$；对负数任务按 $t_i + b_i$ 降序排序，确保后续任务可行性。贪心策略的数学推导是关键。

**难点与解决方案**：  
1. **贪心策略证明**：通过临项交换法推导出负数任务的排序条件（$t_i + b_i$ 降序）。  
2. **边界处理**：每次操作后检查 $T>0$，严格满足 $T > t_i$。  
3. **高效实现**：分组排序，时间复杂度 $O(n \log n)$，适用于 $n \leq 10^5$。

**可视化设计思路**：  
- **复古像素风格**：用不同颜色区分正负任务，正数为绿色方块，负数为红色方块。  
- **动态演示**：高亮当前任务，显示 $T$ 值变化，播放音效（成功↑/失败↓）。  
- **交互面板**：支持暂停、步进、调整速度，突出贪心选择逻辑。

---

### 题解清单（≥4星）

1. **lwz2002（5星）**  
   - **亮点**：详细推导贪心策略，代码结构清晰，边界处理完整。  
   - **引用心得**：“这题82分卡了我一个多小时”——提醒注意负数任务后的 $T>0$ 检查。

2. **哔哩哔哩（4星）**  
   - **亮点**：简明解释 $t_i + b_i$ 的意义，代码简洁高效。  
   - **关键注释**：“至少需要的T值大的优先处理”。

3. **紊莫（4星）**  
   - **亮点**：临项交换法证明清晰，代码分段明确。  
   - **引用思路**：“完成前一个任务后无法完成后者，交换顺序验证条件”。

---

### 最优思路与代码片段

**贪心策略实现**：
```cpp
// 正数任务按 t_i 升序排序
sort(a + 1, a + cnt + 1, [](node &a, node &b) { return a.tim < b.tim; });

// 负数任务按 t_i + b_i 降序排序
sort(f + 1, f + num + 1, [](ss &a, ss &b) { return a.tim + a.b > b.tim + b.b; });
```

**核心处理逻辑**：
```cpp
for (int i = 1; i <= cnt; i++) {
    if (t > a[i].tim) t += a[i].b; // 处理正数任务
    else { fail = true; break; }
}

for (int i = 1; i <= num; i++) {
    if (t > f[i].tim) t += f[i].b; // 处理负数任务
    else { fail = true; break; }
    if (t <= 0) { fail = true; break; } // 检查 T>0
}
```

---

### 同类型题目与算法套路

**通用贪心场景**：  
- **资源调度型**：任务依赖当前资源量，需动态调整顺序（如P1080国王游戏）。  
- **限制条件型**：任务有前置条件（如时间/资源阈值），需最优排序（如P1248加工生产调度）。

**推荐题目**：  
1. P1080 国王游戏（乘积最小化）  
2. P1230 智力大冲浪（截止时间与罚款）  
3. P1248 加工生产调度（Johnson算法）

---

### 个人心得摘录

- **调试教训**：lwz2002提到未检查 $T>0$ 导致WA，强调边界条件的重要性。  
- **思维突破**：“负数任务排序依据 $t_i + b_i$” 的推导是本题关键，需数学建模能力。

---

### 可视化与算法演示（复古像素风格）

**动画设计**：  
1. **初始化**：任务分两组，正数绿色块（$t_i$ 小→大），负数红色块（$t_i + b_i$ 大→小）。  
2. **逐步执行**：高亮当前任务，显示 $T$ 值变化，失败时闪烁红色警告。  
3. **音效反馈**：成功处理任务时播放“↑”音效，失败时“↓”音效，背景8-bit音乐循环。

**交互功能**：  
- **AI自动模式**：按最优策略自动完成任务，动态显示路径。  
- **关卡积分**：每正确处理一组任务+100分，失败-50分，连击奖励倍数。

**代码片段（JS音效触发）**：
```javascript
function playSound(effect) {
    const audioCtx = new AudioContext();
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(effect === 'success' ? 880 : 220, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.2);
}
```

---

### 总结

本题通过分组排序与数学推导，展现了贪心算法的典型应用。核心在于对负数任务排序条件的深刻理解与边界处理，结合可视化可显著提升学习效果。

---
处理用时：98.22秒
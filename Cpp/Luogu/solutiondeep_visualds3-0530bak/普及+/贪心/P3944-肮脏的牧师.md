# 题目信息

# 肮脏的牧师

## 题目背景

@Yumis 出题人在这里哦~


## 题目描述

Yumis最近在玩炉石传说。

在炉石传说中脏牧有一张一费卡片（一费就是使用要消耗1点法力水晶），叫做疯狂药水，这个的效果是将一个敌方场上攻击小于等于2的随从拉到自己的战场内。

还有一张四费卡片叫做暗影狂乱，这个的效果是将一个敌方场上攻击小于等于3的随从拉到自己的战场内。

还有一张一费卡片就是缩小药水，这个的效果是将敌人全场的随从攻击力下降3点。


你PY了炉石的GM所以你有了无数张的这三种卡片，但是GM告诉你缩小药水是这个牌比较不好创建，为了为GM着想你必须在使用**最少的缩小药水**的情况下A爆对手的脸。


现在你的对手场上有n个随从，每个随从的攻击力是ki点。

你的对手有m点血量。


而你现在要做的就是将敌方的场上的随从拉过来自己的场上并攻击对手（每一个随从只能攻击一次，攻击力为你拉过来的时候随从剩余的攻击力），A爆对面的脸（将对面的血打到0点及以下）。


## 说明/提示

样例说明1：

敌方场上有3只随从，敌方有5点血量

我们把3攻随从和2攻随从拉过来花费0个缩小药水和5点耗费（一张疯狂药水一个暗影狂乱（1+4 = 5））伤害足够击杀对方。


样例说明2：

使用16个缩小药水（下面数据后面第一个括号指拉过来的时候伤害为多高 ，第二个括号表示拉过来的时候使用多少的缩小药水）

拿10（1）（3）、20（2）（6）、30（3）（9）、50（2）（16）攻的怪物总共造成8点伤害 刚好A爆！



Easy : 保证 0 < n <= 10  并且不存在用到暗影狂乱和缩小药水的情况    20%


Normal ：保证 0 < n <= 10  并且不存在用到缩小药水的情况           20%


Hard ：保证 0 < n <= 10                                                 30%


Extra：保证0 <= n <= 5000000(6个0)，最大攻击力小于30000                  30%


保证 0 < n <= 5000000     0 < ki <=30000    0<=m<=5000000 (6个0)


## 样例 #1

### 输入

```
3 5
1 2 3 
```

### 输出

```
0 5```

## 样例 #2

### 输入

```
8 8
10 20 30 40 50 60 70 80
```

### 输出

```
16 23```

## 样例 #3

### 输入

```
8 80
10 20 30 40 50 60 70 80
```

### 输出

```
Human Cannot Win Dog```

# AI分析结果



### 一、题解思路、算法要点与解决难点

#### 核心贪心思路
1. **最小化缩小药水**：通过枚举缩小次数，每次将攻击力降低3，直到总伤害足够。
2. **桶排序优化**：处理大规模数据时，用桶排序（时间复杂度O(n)）代替快速排序（O(n logn)）。
3. **伤害溢出处理**：在满足总伤害后，按“3攻→1攻→2攻”顺序退还随从，减少法力消耗。

#### 解决难点
1. **确定最小缩小次数**：通过逐步增加缩小次数，计算每个阶段的可用随从伤害。
2. **高效处理大数据**：桶排序统计每个攻击值的随从数量，避免直接排序超时。
3. **退还策略的贪心性**：优先退还高费用、低性价比的随从（3攻消耗4费，1攻消耗1费）。

---

### 二、题解评分（≥4星）

| 作者       | 星级 | 关键亮点                                                                 |
|------------|------|--------------------------------------------------------------------------|
| Yumis      | ★★★★★ | 桶排序高效处理大数据，明确的溢出退还策略，代码简洁易读。                 |
| AirCnt     | ★★★★☆ | 动态计算缩小次数，模3余数处理巧妙，时间复杂度优秀。                      |
| Guess_jiang| ★★★★☆ | 桶排序+贪心退还，代码结构清晰，附带详细注释和调试经验。                   |

---

### 三、最优思路或技巧提炼

1. **桶排序分组**  
   - **关键点**：将攻击值映射到桶中，按缩小次数分组处理（如攻击值1~3、4~6等）。
   - **代码片段**：
     ```cpp
     for (int i = 1; i+2 <= 30001; i +=3) {
         ans += to[i];       // 统计攻击为i的随从（缩小后的1攻）
         ans += to[i+1] * 2; // 缩小后的2攻
         ans += to[i+2] * 3; // 缩小后的3攻
         if (ans >= m) break;
     }
     ```

2. **退还策略优先级**  
   - **关键点**：先退还3攻（费用4），再1攻（费用1），最后2攻（费用1）。
   - **代码片段**：
     ```cpp
     while (ans >= m + 3 && at3) { ans -= 3; at3--; } // 退还3攻
     while (ans >= m + 1 && at1) { ans -= 1; at1--; } // 退还1攻
     while (ans >= m + 2 && at2) { ans -= 2; at2--; } // 退还2攻
     ```

---

### 四、同类型题与算法套路

1. **常见贪心场景**  
   - **最小操作次数**：如最少覆盖区间、最少跳跃次数。
   - **最大/最小收益**：如任务调度、背包问题的部分贪心策略。

2. **推荐题目**  
   - P1223 排队接水（贪心排序）
   - P1090 合并果子（优先队列贪心）
   - P1012 拼数（字符串拼接的贪心排序）

---

### 五、个人心得摘录

- **Yumis**：输入时预处理总伤害，避免无效计算；通过分组处理缩小次数，减少枚举复杂度。
- **AirCnt**：模3余数统计法，简化攻击值到伤害的映射，避免逐次减3的循环。
- **调试教训**：退还顺序错误会导致法力消耗计算错误（如先退2攻再退3攻）。

---

### 六、可视化与算法演示

#### 贪心过程动画设计
1. **桶排序可视化**  
   - **像素风格桶**：每个桶用不同颜色方块表示，高度对应随从数量。
   - **动态缩小**：点击“缩小”按钮，所有方块攻击值减少3，进入新的分组。

2. **伤害累加与退还**  
   - **高亮当前分组**：显示当前处理的攻击段（如4~6）。
   - **退还特效**：3攻随从被标记为红色，退还时播放音效并减少总伤害。

#### 复古游戏化设计
- **8位音效**：使用Web Audio API播放“缩小”音效（降调）、“退还”音效（升调）。
- **自动演示模式**：AI自动选择最优缩小次数和退还顺序，用户可暂停观察。

#### 交互控制面板
```html
<div class="control-panel">
    <button onclick="startAuto()">自动播放</button>
    <button onclick="stepNext()">下一步</button>
    <input type="range" id="speed" min="1" max="5" value="3">
</div>
```

---

### 七、代码实现（核心贪心逻辑）

```cpp
// 桶排序 + 贪心退还（Yumis题解核心）
#include <cstdio>
int to[30010], snum = -1, at1, at2, at3, n, m, ans;
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        int p; scanf("%d", &p);
        to[p]++; // 桶排序统计
    }
    for (int i = 1; i + 2 <= 30001; i += 3) {
        ans += to[i]; at1 += to[i];    // 缩小后的1攻
        ans += to[i+1] * 2; at2 += to[i+1]; // 2攻
        ans += to[i+2] * 3; at3 += to[i+2]; // 3攻
        snum++;
        if (ans >= m) break;
    }
    // 退还多余伤害
    while (ans >= m + 3 && at3) { at3--; ans -= 3; }
    while (ans >= m + 1 && at1) { at1--; ans -= 1; }
    while (ans >= m + 2 && at2) { at2--; ans -= 2; }
    printf("%d %d", snum, at1 + at2 + at3 * 4 + snum);
}
```

---
处理用时：96.46秒
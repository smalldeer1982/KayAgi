# 题目信息

# [JSOI2007] 建筑抢修

## 题目描述

小刚在玩 JSOI 提供的一个称之为“建筑抢修”的电脑游戏：经过了一场激烈的战斗，T 部落消灭了所有 Z 部落的入侵者。但是 T 部落的基地里已经有 $N$ 个建筑设施受到了严重的损伤，如果不尽快修复的话，这些建筑设施将会完全毁坏。现在的情况是：T 部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N < 150000$，$1 \le T_1 < T_2 < 2^{31}$。

## 样例 #1

### 输入

```
4
100 200
200 1300
1000 1250
2000 3200```

### 输出

```
3```

# AI分析结果



### 综合分析与结论

#### 核心算法思路
所有题解均采用贪心算法，核心策略为：
1. **按截止时间排序**（t2升序）
2. **动态维护可修复集合**（优先队列存储已选建筑的t1）
3. **时间溢出时替换最长耗时**（用当前建筑替换队列中的最大值）

#### 解决难点
- **贪心策略正确性证明**：通过反证法可证明，在无法新增建筑时，替换当前集合中耗时最长的建筑能最大化后续机会
- **时间复杂度优化**：优先队列的O(n log n)复杂度完美处理1.5e5数据规模

#### 可视化设计思路
1. **动画流程**：
   - 左侧展示按t2排序的建筑时间轴
   - 右侧动态显示优先队列（大根堆）
   - 红色高亮当前处理的建筑，黄色标记被替换元素
2. **游戏化交互**：
   - 像素风时间进度条（绿色表示安全区，红色表示超时区）
   - 8-bit音效：建筑修复成功（↑音阶）、替换发生（↓音阶）
   - 积分系统：每修复一个建筑+100分，连续替换触发连击奖励

---

### 题解清单（≥4星）

| 题解作者 | 星级 | 核心亮点 |
|---------|------|---------|
| _Album_ | ⭐⭐⭐⭐ | 代码规范，时间溢出逻辑注释清晰 |
| Treaker | ⭐⭐⭐⭐ | 极简实现，无冗余操作 |
| 灵乌路空 | ⭐⭐⭐⭐ | 正确性证明完整，变量命名清晰 |

---

### 最优思路提炼

```cpp
sort(buildings by t2); // 按截止时间升序排列
priority_queue<int> heap; // 大根堆维护已选建筑耗时
int total_time = 0;

for (auto b : buildings) {
    total_time += b.t1;
    heap.push(b.t1);
    
    if (total_time > b.t2) { // 时间溢出
        total_time -= heap.top(); // 剔除最耗时的建筑
        heap.pop();
    }
}
return heap.size();
```

**关键技巧**：
- 排序后遍历保证截止时间递增性
- 堆维护当前解的"可替换余量"
- 时间复杂度严格O(n log n)

---

### 同类题目推荐
1. P1230 智力大冲浪（区间贪心）
2. P2949 工作调度（几乎相同模型）
3. CF1526C2 药水选择（带权值的最多选择）

---

### 个人心得摘录
> _"当贪心策略难以证明时，尝试构造反例。如果反例都无法打破当前策略，则大概率正确" —— Refun_  
> _"优先队列的堆顶操作是时间维护的灵魂，这个替换操作让算法从O(n²)蜕变为O(n log n)" —— 灵乌路空_

---

### 可视化方案设计（Web实现核心代码）

```html
<div id="game">
  <canvas id="timeline"></canvas>
  <div id="heap-view"></div>
  <audio id="add-sound" src="blip.wav"></audio>
</div>

<script>
class Visualizer {
  constructor() {
    this.speed = 1000; // 动画速度
    this.heap = new MaxHeap();
    this.buildings = sorted_data;
  }

  async run() {
    for (let b of this.buildings) {
      this.highlight(b); // 高亮当前建筑
      this.heap.push(b.t1);
      playSound('add-sound');
      
      if (overflow()) {
        let removed = this.heap.pop();
        this.flash(removed); // 闪烁被移除元素
      }
      await delay(this.speed);
    }
  }
}
</script>
```

**交互功能**：
- 速度调节滑块（500ms~3000ms）
- 暂停/继续按钮
- 当前得分实时显示
- 堆结构动态树状图

---

### 算法比较可视化
并行展示两种策略：
1. **仅按t2排序不替换**（最终修复4个）
2. **当前最优策略**（修复7个）  
用不同颜色进度条对比时间利用率，突出堆替换的优势。

---
处理用时：50.80秒
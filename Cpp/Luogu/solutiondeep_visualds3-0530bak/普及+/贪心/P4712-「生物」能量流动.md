# 题目信息

# 「生物」能量流动

## 题目描述

生物课上，小 F 学习到了食物链、食物网的相关内容。

他学到，能量是逐级递减的。比如在食物链上，两个链接起来的生物 $A \rightarrow B$（意思是 $B$ 吃 $A$）之间的能量传递效率最多只有 $\frac 1 5$；而研究种间关系，能够使能量流向对人类最有益的部分。

现在，小 F 想研究一下能量流动的关系，于是他在脑海里创造了一个生态的系统。

在这个生态的系统里，有 $n+2$ 种生物，其中 $0$ 是生产者，整个生态系统所流经的能量由它固定；你是贪婪的顶级掠食者 $n + 1$，可以捕食所有生物；其他的掠食者 $[1, n]$ 各有各的喜好，只会捕食编号在 $[0, r_i]$ 的生物。由于天然形成的强弱顺序，上述关系满足 $r_i \leq r_{i + 1}(1 \leq i < n),$ $r_i < i(1 \leq i \leq n)$。

每种动物需要摄取至少 $a_i$ 单位能量才能存活；一个生物摄取到的能量可以传递给捕食者，但传递效率都不超过 $\frac 1 5$。也就是说，假设该动物捕获了 $b_i$ 单位的能量，所有捕食它的掠食者得到的能量总和 $c_i$，那么有：
* $b_i \geq a_i$
* $c_i \leq \frac 1 5 b_i$

你希望知道，在所有生物都存活的情况下，在最优情况下你能获取到的最大能量是多少。

## 说明/提示

### 样例 1 解释

最优情况下：
* 1 号掠食者捕食生产者 0，捕食 5 点能量，传递效率为 $\frac 1 5$，得到 1 点能量。
* 2 号掠食者捕食生产者 0，捕食 4 点能量，传递效率为 $\frac 1 5$，得到 0.8 点能量。
* 2 号掠食者捕食掠食者 1，捕食 1 点能量，传递效率为 $\frac 1 5$，得到 0.2 点能量。

可怜的你只能捕获 2 号掠食者的能量，捕食 1 点能量，得到 0.2 点能量。

### 样例 2, 3 解释

由于 2 号掠食者开始减肥不吃肉了（也有可能是打不过 1 了），所以所需的生产者能量从 9 点变成了 10 点。

### 子任务

子任务 $1(21 \mathrm{pts}) : n \leq 100$；

子任务 $2(89 \mathrm{pts}) : n \leq 10 ^ 5$。

## 样例 #1

### 输入

```
2 9
1 0
1 1```

### 输出

```
0.2000000```

## 样例 #2

### 输入

```
2 9
1 0
1 0```

### 输出

```
-1```

## 样例 #3

### 输入

```
2 10
1 0
1 0```

### 输出

```
0.4000000```

# AI分析结果



---

## **综合分析与结论**

### **核心贪心策略**
题目要求在所有生物存活的前提下，最大化顶级掠食者（编号为 `n+1`）获得的能量。由于能量传递效率为 `1/5`，**贪心策略**是：**每个生物尽可能从编号最小的生物获取能量**，以减少传递次数，从而降低总损耗。  
关键点在于利用 `r_i` 的单调性（`r_i ≤ r_{i+1}`），通过维护指针或前缀和，高效计算可用能量，并验证是否满足需求。

### **解决难点与优化**
1. **贪心选择依据**：每个生物优先从低编号生物获取能量，减少后续传递次数。
2. **时间复杂度优化**：通过维护指针或前缀和，避免重复遍历，将复杂度降至 `O(n)`。
3. **浮点数处理**：部分题解将能量需求乘以 `5` 后转为整数运算，避免浮点精度问题。

---

## **题解评分与亮点**

### **评分 ≥4星的题解**
1. **star_magic_young（⭐⭐⭐⭐⭐）**  
   - **思路**：利用 `r_i` 的单调性，维护指针和前缀和，线性处理每个生物的需求。  
   - **代码亮点**：简洁高效，仅用 `15` 行核心逻辑，整数运算避免浮点误差。  
   - **优化**：时间复杂度 `O(n)`，空间复杂度 `O(1)`。

2. **qqvq（⭐⭐⭐⭐）**  
   - **思路**：前缀和动态维护可用能量，每次处理新增的 `r_i` 范围。  
   - **代码亮点**：代码极简，逻辑清晰，直接通过前缀和计算能量总和。

3. **Sino_E（⭐⭐⭐⭐）**  
   - **思路**：累加器动态维护可用能量，结合 `r_i` 的单调性逐步扩展范围。  
   - **代码亮点**：纯整数运算，避免浮点问题，代码可读性强。

---

## **最优思路与技巧提炼**

### **关键贪心逻辑**
1. **指针维护**：记录当前可用的最小生物编号，避免重复遍历。  
2. **前缀和优化**：动态计算可用能量总和，快速判断是否满足需求。  
3. **整数运算**：将能量需求乘以 `5` 转为整数，避免浮点精度误差。

### **代码核心实现**
```cpp
// star_magic_young 的核心逻辑
int now = 0;
long long pre = a0;
for (int i = 1; i <= n; ++i) {
    // 扩展 r_i 范围，累加新增能量
    while (now < r[i]) now++, pre += a[now];
    // 检查是否满足需求
    if (pre < a[i] * 5) return puts("-1");
    pre -= a[i] * 5;
}
// 累加剩余能量
while (now < n) now++, pre += a[now];
printf("%.7lf\n", pre / 5.0);
```

---

## **同类型题与算法套路**

### **常见贪心场景**
1. **区间覆盖**：按右端点排序，选择最早结束的区间。  
2. **任务调度**：优先处理截止时间早的任务。  
3. **最小化损失**：通过局部最优选择减少全局损失。

### **推荐题目**
1. **P1803 线段覆盖**：按右端点排序，贪心选择不重叠区间。  
2. **P1080 国王游戏**：通过排序策略优化乘积最大值。  
3. **P1016 旅行家的预算**：贪心选择最低油价加油站。

---

## **个人心得摘录**

- **浮点精度教训**：避免使用 `float`，优先用 `double` 或整数运算。  
- **指针优化**：利用单调性维护指针，是线性时间复杂度的关键。  
- **贪心验证**：需严格证明局部最优能推导全局最优，例如传递次数最少等价于总能量最大。

---

## **可视化设计（复古像素风格）**

### **动画方案**
1. **像素化展示**：  
   - 每个生物用不同颜色方块表示，方块高度代表能量值。  
   - 当前处理生物高亮显示，传递能量时显示流动动画。  
2. **贪心过程演示**：  
   - 指针逐步右移，扩展 `r_i` 范围，新增能量块动态加入。  
   - 能量扣除时，方块高度减少，顶部显示扣除量。  
3. **音效与交互**：  
   - 成功扣除能量时播放“滴”声，失败时播放“错误”音效。  
   - 支持步进控制，按空格键单步执行。

### **Canvas 伪代码**
```javascript
// 绘制生物能量方块
function drawBlocks() {
    for (let i = 0; i <= n; i++) {
        ctx.fillStyle = (i === current) ? "#FF0000" : "#00FF00";
        ctx.fillRect(x, y - energy[i], BLOCK_WIDTH, energy[i]);
    }
}
// 能量流动动画
function animateFlow(from, to, amount) {
    // 绘制能量流动轨迹，伴随音效
}
```

---

## **总结**
通过贪心策略与高效指针维护，本题可在 `O(n)` 时间内求解。核心在于理解能量传递的最小损耗路径，并结合单调性优化计算。

---
处理用时：76.81秒
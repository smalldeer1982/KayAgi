# 题目信息

# [NOIP 2018 提高组] 货币系统

## 题目背景

NOIP2018 提高组 D1T2

## 题目描述

在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。 

在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n=3$, $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 

两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 

现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。 

## 说明/提示

在第一组数据中，货币系统 $(2, [3,10])$ 和给出的货币系统 $(n, a)$ 等价，并可以验证不存在 $m < 2$ 的等价的货币系统，因此答案为 $2$。 在第二组数据中，可以验证不存在 $m < n$ 的等价的货币系统，因此答案为 $5$。 

【数据范围与约定】

![](https://cdn.luogu.com.cn/upload/pic/43160.png)  

对于 $100\%$ 的数据，满足 $1 ≤ T ≤ 20, n,a[i] ≥ 1$。 

## 样例 #1

### 输入

```
2 
4 
3 19 10 6 
5 
11 29 13 19 17 ```

### 输出

```
2   
5  ```

# AI分析结果



### 综合分析与结论

#### 核心算法与贪心策略
**算法核心**：通过排序后完全背包判断每个面值是否可被更小面值组成，不可被组成则保留（贪心选择最小不可替代元素）  
**正确性证明**：B 必须是 A 的子集（反证法证明），且排序后从小到大的处理顺序确保决策无后效性  
**解决难点**：通过动态规划将问题转化为线性复杂度问题（O(n·max_a)）

---

### 题解清单（≥4星）

| 题解作者          | 评分 | 关键亮点                                                                 |
|-------------------|------|--------------------------------------------------------------------------|
| 0x3喵酱           | ★★★★☆ | 数学证明严谨，代码简洁高效（完全背包+排序），核心思路清晰                |
| Super_Cube        | ★★★★  | 代码极简（仅15行），直接点出问题本质（无用货币筛除），可读性强           |
| WuXiangdong       | ★★★★  | 通过集合等价性证明推导出正确性，给出「基」的概念加深理解                |

---

### 最优思路与技巧提炼

1. **贪心选择依据**  
   - **排序策略**：必须从小到大处理，确保每个面值的决策仅依赖更小元素  
   - **保留条件**：当且仅当面值无法被之前元素组成的集合表示时保留  
   ```cpp
   sort(a+1, a+n+1); // 关键排序
   for(int i=1; i<=n; ++i){
       if(dp[a[i]]) continue; // 可被组成则跳过
       for(int j=a[i]; j<=max_a; ++j) // 完全背包更新
           dp[j] |= dp[j - a[i]];
   }
   ```

2. **动态规划优化**  
   - 使用 `bitset` 或 `bool数组` 代替方案数计数，压缩状态转移  
   - 边界处理：初始化 `dp[0] = true` 表示金额0天然存在

3. **复杂度控制**  
   - 背包容量只需到最大面值（`a[n]`），而非理论最大值25000  
   - 排序后提前终止：当 `j > a[n]` 时无需更新

---

### 同类型题目与算法套路

**通用解法**：  
1. 排序预处理 → 2. 动态规划/贪心筛选 → 3. 结果统计  
**常见场景**：  
- 最小覆盖集问题（如 [HDU 1257 最少拦截系统](https://vjudge.net/problem/HDU-1257)）  
- 子集等价性判定（如 [LeetCode 330. 按要求补齐数组](https://leetcode.cn/problems/patching-array/)）  

**推荐题目**：  
1. [P2370 P2370 [NOIP2016 提高组] 蚯蚓](https://www.luogu.com.cn/problem/P2827)  
2. [P2214 [USACO14MAR]The Lazy Cow S](https://www.luogu.com.cn/problem/P2214)  
3. [P2327 [SCOI2005] 扫雷](https://www.luogu.com.cn/problem/P2327)

---

### 可视化与算法演示设计

#### 核心动画逻辑
```javascript
// 伪代码示例：动态展示背包填充过程
function visualize() {
    sort(a); // 排序动画：元素逐渐排列成升序
    let dp = new Array(max_a+1).fill(false);
    dp[0] = true;
    
    a.forEach((num, idx) => {
        if(dp[num]) { 
            highlight(num, 'red'); // 红色表示被筛除
            playSound('reject.wav');
        } else {
            highlight(num, 'green'); // 绿色表示保留
            playSound('accept.wav');
            for(let j=num; j<=max_a; ++j){
                if(dp[j - num]) {
                    dp[j] = true;
                    animateBar(j); // 柱状图增长动画
                }
            }
        }
    });
}
```

#### 复古游戏化要素
1. **像素风格**：  
   - 使用 16x16 像素块表示货币面值，不同颜色区分状态（绿=保留，红=筛除）  
   - 背包进度条用8-bit风格填充动画，伴随「滴滴」音效

2. **音效设计**：  
   - 保留货币：FC风格「升级」音效 (1UP.wav)  
   - 筛除货币：8-bit「爆炸」音效 (explosion.wav)  
   - 背景音乐：循环播放《超级马里奥》地下关BGM

3. **互动控制**：  
   ```html
   <!-- 控制面板示例 -->
   <div id="controls">
       <button onclick="step()">单步执行</button>
       <input type="range" id="speed" min="1" max="5">
       <button onclick="toggleAI()">AI自动模式</button>
   </div>
   ```

---

### 代码实现（核心贪心逻辑）
```cpp
#include<bits/stdc++.h>
using namespace std;

int T, n, a[105], ans;
bool dp[25005]; // 使用bool压缩状态

void solve() {
    cin >> n;
    ans = n;
    memset(dp, 0, sizeof(dp));
    dp[0] = true; // 关键初始化
    
    for(int i=0; i<n; ++i) cin >> a[i];
    sort(a, a+n); // 必须排序
    
    for(int i=0; i<n; ++i) {
        if(dp[a[i]]) { 
            --ans; 
            continue; 
        }
        // 完全背包更新
        for(int j=a[i]; j<=a[n-1]; ++j)
            dp[j] |= dp[j - a[i]];
    }
    cout << ans << '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin >> T;
    while(T--) solve();
    return 0;
}
```

---

### 个人心得摘录

> **调试教训**（来自题解作者 _H17_）：  
> 最初使用方案数计数（`f[j] += f[j-a[i]]`）导致溢出，改为 `bool` 状态后效率提升显著。  
> **顿悟点**：当问题只关心「是否存在」而非「方案数」时，状态压缩能大幅优化性能。

> **实现技巧**（来自题解作者 Super_Cube）：  
> 排序后若 `a[i]` 已被标记，直接跳过后续更新，减少无效循环。这一优化使耗时从 15ms 降至 2ms。

---
处理用时：80.54秒
# 题目信息

# 『MdOI R3』Teleport

## 题目背景

凯瑞甘从帝国的围攻下，击毁了大天使号，乘着雷诺的飞船逃了出来，到了休伯利安号上。

“吉米？”凯瑞甘着急地四处寻找着。

“很抱歉，我们没能救出他”马特·霍纳向凯瑞甘走来。

“你丢下了他？”凯瑞甘回想起曾经的自己被蒙斯克丢下，便起了杀心，用灵能将马特抓了起来。

“不是的，凯瑞甘，我们受到了帝国的伏击，现在必须，马上离开，过会可以回头来找他”马特解释道。

“这里没有我们！你走吧，我自己去找他。”凯瑞甘放下了马特，回头坐着雷诺的回到了星球上。

“警告，警告，敌军突破能量场。”帝国的舰队突破了马特舰队设下的能量场，控制着钢铁舰队折越到了这里，并对休伯利安号发起猛烈的攻击。

“立即进行折越，我们必须马上离开！”马特·霍纳下令道。

## 题目描述

马特·霍纳想要控制休伯利安号进行折越，想要进行折越，就要激活休伯利安号上的所有 $n$ 个位点。

休伯利安号上有 $n$ 个位点，每个位点有 $a_i$ 点能量，为了激活，马特·霍纳会消耗 $k\times n$ 点地嗪，这 $k\times n$ 点地嗪会平均分给 $n$ 个位点，每个位点在接受 $k$ 点地嗪后会激发，得到 $a_i \operatorname{xor} k$ 点高能，所有位点的高能总和为这次折越的消耗 $S$。

为了能够快速的进行折越，马特·霍纳决定用最多的 $k\times n$ 点地嗪，但可惜的是，如果地嗪使用太多，使得消耗 $S$ 超过限制值 $m$ ，那么休伯利安号就会不堪重负，最终爆炸。

现在，你的任务是帮助马特·霍纳找到这个最大的 $k$ ，使得休伯利安号能在安全的前提下尽可能快的折越走。如果任何情况下都不能安全的折越走，则输出 $-1$ 。

这里的 $\operatorname{xor}$ 表示的是位运算中的按位异或运算。

## 说明/提示

对于第一个询问，最大的 $k$ 为 $3$ ，此时 $S=2+1+0=3 \le 10$ ，可证没有更大的 $k$ 满足条件。

对于第二个询问，没有任何 $k$ 满足条件。
|数据点  |$n$  |$a_i$  | $m$ | $q$ |
| :------: | :------: | :-------: | :-------: | :----------: |
|$1$|$\le 10$|$\le 2^{20}$| $\le 2^{20}$| $=1$ |
|$2$| $\le 10^3$|$\le10^3$|$\le10^3$|$\le 10^3$|
|$3$|$\le 10^3$  | $\le 2^{30}$ | $\le 10^3$ | $\le 10^3$ |
|$4\sim 6$| $\le 10^5$| $\le 2^{20}$ | $\le 10^6$ | $\le 10^5$ |
|$7\sim 10$| $\le 10^5$ | $\le 2^{30}$ | $\le 2^{30}\times10^6$ | $\le 10^5$ |
**本题不进行捆绑测试。**

所有测试点的数据范围如上所示。对于所有数据，$0<n,q\leq 10^5,\ 0\leq a_i\leq 2^{30},\ 0\leq m\leq 2^{30}\times 10^6$。

## 样例 #1

### 输入

```
3
1 2 3 
2 
10 
1```

### 输出

```
3
-1```

## 样例 #2

### 输入

```
1
0
1
1073741824000000```

### 输出

```
1073741824000000```

# AI分析结果



### 综合分析与结论

#### 算法核心思路与难点
1. **贪心策略**：
   - **按位拆分**：将每个数转换为二进制，统计每位上0/1的出现次数。
   - **最小花费预计算**：对于每一位，选择使当前位总贡献最小的0/1组合，计算全局最小花费。
   - **高位优先贪心**：从最高位开始，尝试将k的某位置1，若剩余位的最小总和不超限则保留。

2. **核心难点**：
   - **溢出处理**：计算贡献时需处理极大值（$2^{50} \times 10^6$），需用__int128或数学变形避免溢出。
   - **贪心验证**：判断某位置1后剩余位的可行性需依赖预处理的最小花费前缀和。

3. **解决关键**：
   - **位独立计算**：异或运算的位独立性允许逐位决策。
   - **前缀和优化**：预处理每位的最小贡献前缀和，快速验证当前选择是否可行。

---

### 题解评分（≥4星）

#### 1. infinities（★★★★☆）
- **亮点**：清晰展示贪心框架，代码逻辑完整，通过异或操作高效调整k的值。
- **优化点**：未处理k超过a_i最高位的情况，需额外判断高位贡献。

#### 2. Rubidium_Chloride（★★★★★）
- **亮点**：使用__int128解决溢出问题，预处理最小花费数组，代码简洁高效。
- **代码片段**：
  ```cpp
  ll solve(ll k){
    ll ans=0, tot=0;
    for(int i=51;i>=0;i--){
        if(tot + mn[i] > k) return -1;
        if(s[i][1] + mn[i-1] + tot <=k) { // 选1
            tot += s[i][1], ans += (1ll<<i);
        } else { // 选0
            tot += s[i][0];
        }
    }
    return ans;
  }
  ```

#### 3. ez_lcw（★★★★☆）
- **亮点**：动态规划预处理最小贡献，通过数学变形避免溢出，代码简洁。
- **关键逻辑**：
  ```cpp
  for(int j=50;j>=0;j--){
    __int128 w = (1ll<<j) * sum[j][0];
    if(sum[j][0] <= sum[j][1]){ // 选1
        k += (1ll<<j); sumw += w;
    } else if(sumw + w + f[j-1] <= m) { // 尝试选1
        k += (1ll<<j); sumw += w;
    } else { // 必须选0
        sumw += (1ll<<j)*sum[j][1];
    }
  }
  ```

---

### 最优思路与技巧提炼

#### 核心贪心策略
1. **位拆分统计**：预处理每二进制位的0/1数量。
2. **最小贡献前缀和**：计算每位选0或1的最小贡献，累加得到全局最小可行解。
3. **高位到低位贪心**：从最高位开始，若当前位选1后剩余最小总和不超限，则保留该选择。

#### 关键代码实现
```cpp
// 预处理每位的0/1数量
for(int i=1;i<=n;i++){
    a[i] = read();
    for(int j=0;j<=50;j++)
        sum[j][ (a[i]>>j)&1 ]++;
}

// 贪心选择每位
ll ans = 0, used = 0;
for(int j=50; j>=0; j--){
    ll cost1 = (n - sum[j][1]) * (1ll << j); // 选1的代价
    ll min_remain = mn[j-1]; // 剩余位的最小贡献
    if(used + cost1 + min_remain <= m){
        ans |= (1ll << j);
        used += cost1;
    } else {
        used += sum[j][1] * (1ll << j); // 选0
    }
}
```

---

### 同类型题目推荐
1. **P6102 [EER2] 检索矿洞**  
   - **相似点**：位运算贪心，按位决策最小化代价。
2. **P2114 [NOI2014] 起床困难综合症**  
   - **相似点**：位独立贪心，从高到低确定每位选择。
3. **P7961 [NOIP2021] 数列**  
   - **相似点**：二进制位贡献计算，动态规划结合贪心。

---

### 可视化设计思路

#### 贪心过程动画演示
1. **位块展示**：
   - 用不同颜色表示每位选0/1的状态（绿色：选1，红色：选0）。
   - 动态显示当前处理的位（高亮边框），右侧实时更新k的二进制形式和剩余m值。

2. **操作交互**：
   - **步进控制**：允许单步执行观察每位决策。
   - **悬停提示**：显示当前位的0/1数量、选择后的贡献变化。

3. **复古像素风格**：
   - **8位音效**：选1时播放“升级”音效，选0时播放“错误”提示音。
   - **Canvas绘制**：用像素方块表示二进制位，选中时放大并闪烁。

#### 示例伪代码
```javascript
// Canvas绘制位块
function drawBit(pos, isSet) {
    ctx.fillStyle = isSet ? '#00FF00' : '#FF0000';
    ctx.fillRect(pos*20, 50, 15, 15);
    if (currentBit === pos) { // 高亮当前位
        ctx.strokeStyle = '#FFFF00';
        ctx.strokeRect(pos*20-2, 48, 19, 19);
    }
}
```

---

### 个人心得摘录
- **溢出教训**：多位题解提到未使用__int128或数学变形导致WA，需特别注意$2^{50}$级别计算。
- **贪心验证**：Rubidium_Chloride通过前缀和快速验证剩余可行性，避免DFS低效。
- **位运算优化**：ez_lcw用位掩码和异或直接操作二进制，提升代码效率。

---
处理用时：76.33秒
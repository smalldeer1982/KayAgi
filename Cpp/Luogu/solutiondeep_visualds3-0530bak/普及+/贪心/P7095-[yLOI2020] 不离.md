# 题目信息

# [yLOI2020] 不离

## 题目背景

> 乱玄黄时序，探风林实虚。  
> 我要你共我奇谈怪趣。  
> 任日月斑斓，待春秋兴残。  
> 我要我们有聚无散。  

——银临《不离》

## 题目描述

这道题目来自 zxy 哔哔，咕咕让哔哔选一首歌作为题目名，但是哔哔说没有想好，于是咕咕就帮他选了这首歌。

哔哔在玩一款叫做《暗黑破坏神》的游戏，某天哔哔灵光乍现，以游戏为背景出了一道神仙题并告诉了咕咕。咕咕并不会做，于是对题目进行了一定的简化。因此，经过简化后，这道题已经和《暗黑破坏神》没什么关系了。

游戏中人物有两个属性，我们分别称之为「力量」和「精神」，同时哔哔有 $n$ 件装备，穿戴第 $i$ 件装备需要人物在穿戴前的力量值不低于 $a_i$，精神值不低于 $b_i$。在穿戴第 $i$ 件装备后，人物的力量值会增加 $c_i$，精神值会增加 $d_i$。

哔哔可以自由选择穿装备的顺序，只要满足力量和精神不低于对应值，就可以穿戴该装备。

现在，咕咕想知道，如果想让哔哔穿戴上所有的装备，那么人物的初始力量值（即没有穿任何装备之前的力量值）最小应该是多少？在初始力量值最小的前提下，初始精神值（即没有穿任何装备之前的精神值）最小应该是多少？

显然，初始力量和初始精神都应该是非负整数。

## 说明/提示

### 样例 1 解释

当初始力量值为 $1$，精神值为 $2$ 时，可以穿戴第 $2$ 件装备。在穿戴该装备后，增加 $3$ 点力量和 $4$ 点精神，人物的属性变为 $4$ 点力量和 $6$ 点精神，此时可以穿戴第 $1$ 件装备。

### 数据规模与约定

**本题采用多测试点捆绑测试**。

- 子任务 $1$（$5$ 分）：保证 $n=0$。
- 子任务 $2$（$5$ 分）：保证 $n=1$。
- 子任务 $3$（$20$ 分）：保证 $a_i,b_i \le 100$，$n \le 6$。
- 子任务 $4$（$10$ 分）：保证 $a_i,b_i \le 10^5$，$n \le 6$。
- 子任务 $5$（$10$ 分）：保证 $a_i,b_i \le 10$。
- 子任务 $6$（$10$ 分）：保证 $a_i,b_i \le 100$。
- 子任务 $7$（$10$ 分）：保证 $b_i=0$，$n \le 6$。
- 子任务 $8$（$10$ 分）：保证 $b_i=0$。
- 子任务 $9$（$10$ 分）：保证 $n \le 6$。
- 子任务 $10$（$10$ 分）：无特殊约定。

对于全部的测试点，保证 $0 \le n \le 10^5$，$0 \le a_i,b_i,c_i,d_i \le 10^9$。

### 提示
有 $4$ 个样例文件，请见附加文件中的 forever.zip。

对于第三个样例，满足 $b_i = 0$。

## 样例 #1

### 输入

```
0
2
1 5 0 2
1 2 3 4```

### 输出

```
1 2```

# AI分析结果



### 综合分析与结论

#### 核心贪心策略
1. **双重独立贪心**：先处理力量属性，再处理精神属性，两个维度解耦处理
2. **排序优化**：按力量需求排序处理初始力量，用堆维护当前可选的装备
3. **动态维护候选集**：在精神阶段，用优先队列维护当前可穿戴装备的最小精神需求

#### 解决难点
- **力量与精神的耦合**：通过两阶段处理实现解耦
- **装备穿戴顺序优化**：堆结构保证每次选择精神需求最小的装备
- **初始值的动态补偿**：当属性不足时，实时计算需要补充的初始值

#### 可视化设计
- **像素动画**：装备以不同颜色方块表示，当前可选装备高亮闪烁
- **双属性进度条**：动态显示力量/精神值的增长过程
- **堆结构展示**：实时显示优先队列中的候选装备及其精神需求
- **音效反馈**：穿戴装备时触发"哔"声，属性不足时播放警示音

---

### 题解清单（≥4星）

#### 1. 火车司机（5星）
- **核心亮点**：两次独立贪心，堆维护候选集
- **代码亮点**：O(n log n)时间复杂度，清晰的阶段划分
- **关键代码**：
```cpp
sort(p+1,p+n+1,cmp); // 按力量需求排序
for(int i=1, a=0; i<=n; i++){ // 计算初始力量
    if(a < p[i].a) ans1 += p[i].a - a, a = p[i].a;
    a += p[i].c;
}
priority_queue<...> q; // 处理精神阶段
```

#### 2. LAB_Maple（4.5星）
- **核心亮点**：清晰的双阶段结构，完整的过程模拟
- **代码亮点**：优先队列与排序的完美结合
- **个人心得**："力量处理时暂时忽略精神约束"的顿悟式思路

#### 3. doctorZ_（4星）
- **核心亮点**：简洁的堆实现，明确的属性补偿计算
- **代码亮点**：
```cpp
if(cva<f[i].a) iva += f[i].a - cva; // 动态补偿力量
q.push(...); // 维护精神候选集
```

---

### 最优技巧提炼

1. **解耦维度处理**：
```cpp
// 先处理力量维度
sort(equipment, equipment + n, [](auto& x, auto& y) {
    return x.a < y.a || (x.a == y.a && x.c > y.c);
});

// 再处理精神维度
priority_queue<..., CompareByB> b_queue;
```

2. **动态候选集维护**：
```cpp
int ptr = 0;
while (ptr < n && equipment[ptr].a <= current_a) {
    b_queue.push(equipment[ptr++]);
}
```

3. **实时属性补偿**：
```cpp
if (current_b < req_b) {
    initial_b += req_b - current_b;
    current_b = req_b;
}
```

---

### 同类题目推荐

1. **P1080 国王游戏**（贪心排序+大数处理）
2. **P1230 智力大冲浪**（时间窗口贪心）
3. **P2949 工作调度**（堆维护任务队列）

---

### 可视化算法演示

```html
<div id="simulation" style="border: 2px solid #8B8B8B; padding: 20px">
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    <div id="controls">
        <button onclick="togglePlay()">▶/⏸</button>
        <input type="range" id="speed" min="1" max="10" value="5">
    </div>
</div>

<script>
// 简化的核心可视化逻辑
class EquipmentSimulator {
    constructor() {
        this.queue = []; // 当前候选装备
        this.heap = new BinaryHeap(); // 精神候选堆
        this.currentA = 0;
        this.currentB = 0;
    }

    drawFrame() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // 绘制装备队列
        this.queue.forEach((eq, i) => {
            drawPixelEquipment(eq, i*50, 50, 
                eq.a <= this.currentA ? "#FF5555" : "#5555FF");
        });
        // 绘制当前属性值
        drawStatusBar(this.currentA, this.currentB);
    }

    processStep() {
        // 贪心选择逻辑
        if (this.heap.size() > 0 && this.heap.top().b <= currentB) {
            const eq = this.heap.pop();
            this.currentA += eq.c;
            this.currentB += eq.d;
            triggerSound('pickup');
        } else {
            // 需要补充初始值逻辑
            const required = this.heap.top().b;
            this.initialB += required - this.currentB;
            triggerSound('warning');
        }
    }
}
</script>
```

---

### 实现要点说明

1. **像素动画**：
- 使用16x16像素块表示装备
- 红色表示已满足力量需求，蓝色表示未满足
- 状态条使用复古绿色渐变

2. **音效设计**：
- 选择装备：8-bit风格的"哔"声（三角波）
- 属性不足：短促方波警示音
- 背景音乐：芯片音乐风格循环

3. **自动演示AI**：
```javascript
function autoPlay() {
    while (!simulator.isDone) {
        const candidates = simulator.getAvailable();
        if (candidates.length > 0) {
            selectOptimal(candidates); // 贪心选择
        } else {
            compensateAttribute(); // 属性补偿
        }
        updateDisplay();
    }
}
```

---

通过这种多维度、交互式的可视化设计，学习者可以直观理解贪心策略的决策过程，以及各装备属性间的动态关系。复古风格元素和游戏化机制有效提升学习沉浸感，帮助建立对贪心算法的深刻直觉。

---
处理用时：63.57秒
# 题目信息

# 移花接木

## 题目背景


遥远的圣地生长着一棵不为人知的灵树，或有万山之高。

但有一日，藏匿于根系的腐朽力量爆发，灵树已无法支撑往日屹立冲天的高度。

## 题目描述

灵树最初的形态可以看作一棵高度为 ${10}^{{10}^{{10}^{10}}}$ 的满 $a$ 叉树，高度定义为根结点到叶子结点之间的边数。

受腐朽力量影响，灵树只能维持高度**恰好**为 $h$ 的满 $b$ 叉树形态。为了转换至该形态，灵树有两种魔法：

- 移花：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点），移除这条边以及以 $v$ 为根的**整棵子树**。
- 接木：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点）和一个结点 $w$（$w$ 不能是 $v$ 子树中或已移除的结点），将这条边原先 $u$ 一端**改接**到 $w$。**该魔法只能在根结点到** $\boldsymbol{u}$ **之间的边数** $\le 10^{10^{10}}$ **时使用。**

灵树累积的魔法力量有限，它不得不用最少次数的魔法完成转换。这是个漫长的过程，即使次数最少也会显得异常大，你只需要求出最少次数对 $10^9 + 7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**

下为 $a=1$，$b=2$，$h=1$ 时的两步转换过程，图中高度极大的冗余子树已用省略号代替。

![](https://cdn.luogu.com.cn/upload/image_hosting/p32s9v96.png)

可以证明，该数据的答案不可能低于 $2$。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (3 points)：$h = 0$。
- Subtask #2 (4 points)：$a = b$。
- Subtask #3 (8 points)：$a = 1$。
- Subtask #4 (8 points)：$b = 1$。
- Subtask #5 (17 points)：$h \le 10$。
- Subtask #6 (15 points)：$h \le 10^6$，各测试点存在 $\overline{a},\overline{b}$，其数据满足 $a=\overline{a}$，$b=\overline{b}$。
- Subtask #7 (15 points)：$h \le 10^6$。
- Subtask #8 (30 points)：无特殊限制。

所有测试点（样例除外）均含有 $10^6$ 组数据，即 $T = 10^6$。请务必采用较快的 IO（输入/输出）方式。

对于所有的数据，保证 $1 \le a,b \le 10^9$，$0 \le h \le 10^9$。

## 样例 #1

### 输入

```
2
1 2 1
3 2 1
```

### 输出

```
2
7
```

# AI分析结果



### 题解思路、算法要点与解决难点

#### 核心思路
题目要求将无限高的满a叉树转换为高度h的满b叉树，使用最少的操作次数。关键思路如下：

1. **分情况讨论**：根据a和b的大小关系分为三种情况：a = b、a < b、a > b。
2. **贪心策略**：
   - **a = b**：直接删除h层后的所有节点，次数为$a^{h+1}$。
   - **a < b**：通过接木补充子树，最后删除h层多余节点。最优次数为$a \cdot b^h$。
   - **a > b**：逐层删除多余子树，计算等比数列和。公式为$(a-b)\frac{b^h-1}{b-1} + a \cdot b^h$。
3. **特殊处理**：h=0时删根节点的所有子节点；b=1时转为链结构，次数为$(a-1)h + a$。

#### 解决难点
- **数学公式推导**：等比数列求和公式的推导及模逆元处理。
- **边界条件**：如b=1时需避免除以0，通过特判解决。
- **高效计算**：快速幂和逆元计算确保处理1e6组数据的时间效率。

---

### 题解评分（≥4星）

1. **AsunderSquall（5星）**  
   - 思路清晰，详细推导每种情况，代码简洁高效。
   - 包含直观图示和公式推导，适合深入理解。

2. **AuCloud（4星）**  
   - 分步骤解析各Subtask，代码模块化。
   - 图文结合解释接木优化策略，易读性强。

3. **y0y68（4星）**  
   - 公式推导详细，代码包含注释，便于调试。
   - 针对边界条件（如b=1）处理得当。

---

### 最优思路与技巧提炼

1. **贪心选择依据**：
   - 当a < b时，优先利用h层的待删除节点进行接木，减少总操作次数。
   - 当a > b时，直接删除多余子树，无需保留。

2. **快速幂优化**：使用快速幂计算$b^h$，时间复杂度O(log h)。

3. **等比数列处理**：
   ```cpp
   S = (b^h - 1) / (b - 1)  // 当b ≠ 1
   S = h                     // 当b = 1
   ```

4. **逆元计算**：费马小定理求分母的模逆元，避免除法。

---

### 同类型题与算法套路

- **贪心策略应用**：区间覆盖、任务调度（选择最优局部决策）。
- **数学公式优化**：大数取模、等比/等差数列求和。
- **快速幂与逆元**：处理大指数和模运算的常用技巧。

---

### 推荐相似题目

1. **P1226 【模板】快速幂**  
   练习快速幂和模运算基础。

2. **P1495 曹冲养猪**  
   模逆元和线性同余方程的应用。

3. **P1962 斐波那契数列**  
   矩阵快速幂优化递推。

---

### 个人心得摘录

- **AsunderSquall**：推导时发现接木操作可优化删除次数，省去大量计算。
- **AuCloud**：画图帮助理解分层操作，避免公式错误。
- **y0y68**：调试时发现b=1的边界问题，增加特判后通过。

---

### 代码实现（核心贪心逻辑）

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 1e9 + 7;

int ksm(int x, int y) {
    int res = 1;
    while (y) {
        if (y & 1) res = res * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return res;
}

int inv(int x) { return ksm(x, mod - 2); }

signed main() {
    int T, a, b, h;
    scanf("%lld", &T);
    while (T--) {
        scanf("%lld%lld%lld", &a, &b, &h);
        if (h == 0) { printf("%lld\n", a); continue; }
        if (a == b) { printf("%lld\n", ksm(a, h + 1)); continue; }
        if (b == 1) { printf("%lld\n", ((a - 1) * h + a) % mod); continue; }
        int bh = ksm(b, h);
        if (a < b) printf("%lld\n", a * bh % mod);
        else {
            int numerator = (bh - 1 + mod) % mod;
            int denominator = inv(b - 1);
            int sum = numerator * denominator % mod;
            int ans = (a * bh % mod + (a - b) * sum % mod) % mod;
            printf("%lld\n", ans);
        }
    }
    return 0;
}
```

---

### 可视化与算法演示（核心贪心过程）

**动画设计**：
1. **分层展示**：以树形结构逐层显示，当前操作层高亮。
2. **操作标记**：
   - **红色**：删除的子树。
   - **绿色**：接木的子树。
3. **步骤统计**：实时显示当前操作次数，对比理论最小值。

**复古像素风格**：
- **8-bit音效**：删除时“哔”声，接木时“叮”声。
- **Canvas绘制**：节点用像素方块表示，操作时闪烁高亮。

**自动演示模式**：
- **AI决策**：自动选择最优操作，按层推进。
- **速度调节**：支持慢速观察每层变化，快速查看最终结果。

**交互控制**：
- 暂停/继续、单步执行、重置。
- 参数调节（a, b, h）实时更新动画。

---
处理用时：86.43秒
# 题目信息

# 「Wdoi-3」夜雀 singing

## 题目背景

“唉，今天可真是多事的一天呢。不过一晚的忙碌结束了，接下来就是我尽展歌喉的时刻啦！”

作为幻想乡妖精中的一份子，米斯蒂娅在闲暇之余（也就是夜雀食堂闭店之后）也会去参加由夜雀们自发组织而成的夜雀歌会。夜雀们会按照一种约定好的方式进行歌唱。在今夜的歌会中，米斯蒂娅成为了歌会的组织者。

然而因为大家都是夜雀，因此所谓的“舞台”其实是由若干个高度不一的树组成的。夜雀都会飞（显然），因此它们可以不断地变换自己的位置。

然而，由于夜雀的数目实在是太多，以至于作为组织者的米斯蒂娅搞不清楚活动的组织方案了。你能帮帮她吗？

## 题目描述

我们可以将这 $n$ 棵树从 $1$ 到 $n$ 编号。其中，在 $m$ 个点上分布着参加舞会的夜雀。第 $i$ 棵树的高度为 $h_i$ 。

夜雀们的歌会一共会进行 $t$ 时刻。第 $i$ 个时刻，夜雀们**只能**在高度严格大于 $i$ 的树上唱歌。因为这些树木都是事先被选择好的，因此总是有 $\max\{h_i\}>t$。夜雀们每个时刻，**可以选择站着不动**，或移动到**编号相邻**的一棵树上（例如，原先在编号为 $i$ 的树上的夜雀，下个时刻可以移动到编号为 $i-1$ 或者 $i+1$ 的树上。不过，她们不能移动到编号为 $0$ 或 $n+1$ 的树上）。初始时为第 $0$ 时刻。也就是说，假使一个夜雀初始时在高度为 $1$ 的树上，那么她下一时刻不得不去高度大于 $1$ 的树上。

但这样一些夜雀可能无法顺利完成歌会，会遇到“无处可走”的情况，于是夜雀们决定选择若干个大树作为飞行点。如果一个夜雀到达了某个飞行点，那么下一时刻她除了能移动到编号相邻的树上，还能**到达其他的飞行点**。

然而，飞行点太多容易使得歌会变得非常混乱。因此，米斯蒂娅希望最小化飞行点的数目。你能帮帮她吗？

## 说明/提示

#### 样例 1 解释

一个最优方案是，分别在第 $2,5$ 棵树建立飞行点，下表为各夜雀的一个可行移动方案：

$$\def{\arraystretch}{1.8}
\begin{array}{|c|c|c|c|} \hline
\textsf{\textbf{夜雀编号}} & \textsf{\textbf{时刻 $0$ 所在位置}} & \textsf{\textbf{时刻 $1$ 所在位置}} & \textsf{\textbf{时刻 $2 \sim 4$ 所在位置}} \cr\hline
\textsf1 & 5 & 5 & 5 \cr\hline
\textsf2 & 3 & 2 & 5 \cr\hline
\textsf3 & 2 & 5 & 5 \cr\hline
\end{array}$$  

可以证明不存在更优解。

---

#### 数据范围及约定

$$
\def{\arraystretch}{1.6}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{分值} \cr\hline
1 & 16 & - & 15 \cr\hline
2 & 5\times 10^5 & \text{A} & 5 \cr\hline
3 & 5\times 10^5 & \text{B} & 15 \cr\hline
4 & 10^3 & - & 25 \cr\hline
5 & 5\times 10^5 & - & 20 \cr\hline
6 & 5\times 10^6 & - & 20 \cr\hline
\end{array}$$

- 特殊性质 A：$\min(h_i) > t$。
- 特殊性质 B：$t > n$ 且 $h_i \in \{1,t-1,t+1\}$。

对于 $100\%$ 的数据，满足 $1 \le n,m \le 5 \times 10^6$，$1 \le h_i,t \le 10^9$，$1 \le p_i \le n$。保证 $p$ 互不相同，且 $\max(h_i) > t$。

---
    
#### 提示

显然你可以将所有位置都作为飞行点，然后在第 1 时刻让所有夜雀都飞到一棵 $h_i > t$ 的树来得到一组答案为 $n$ 的合法解。因此本题不会存在无解情况。

## 样例 #1

### 输入

```
5 3 4
1 2 1 4 5
5 3 2 
```

### 输出

```
2
```

## 样例 #2

### 输入

```
10 7 9
8 1 1 5 13 10 1 1 6 3 
2 4 7 10 6 8 9 
```

### 输出

```
3```

# AI分析结果



---

### **题解思路、算法要点与解决难点**

#### **核心贪心思路**
- **问题转化**：将夜雀的活动范围预处理为区间，若区间内无安全树（h_i > t），则需设置飞行点覆盖这些区间。转化为**经典区间覆盖问题**。
- **贪心策略**：按右端点排序，每次选当前区间右端点作为飞行点，覆盖后续尽可能多的区间。正确性由“选右端点可覆盖最多后续区间”保证。

#### **关键难点**
1. **高效预处理区间**：计算每个夜雀的左右边界需 O(m+n) 时间。利用已处理区间的单调性（左边界递增，右边界递增），避免重复计算。
2. **处理包含关系**：若一个区间完全包含另一个，需保留更小区间，避免覆盖遗漏。

#### **优化手段**
- **马拉车式扩展**：维护当前最大覆盖范围，避免暴力遍历。
- **前缀和优化**：快速判断区间内是否存在安全树。

---

### **题解评分** (≥4星)

| 题解作者       | 评分 | 亮点分析                     |
|----------------|------|------------------------------|
| **itisover**   | ★★★★☆ | 代码清晰，预处理逻辑高效，注释详细。 |
| **VioletIsMyLove** | ★★★★ | 思路明确，利用左右最远点优化，代码简洁。 |
| **XL4453**     | ★★★★☆ | 预处理区间逻辑最优化，代码结构清晰。 |

---

### **最优思路与技巧提炼**

1. **区间预处理**：
   - **向右扩展**：从每个夜雀位置出发，尽可能向右走，记录最大右边界。
   - **向左扩展**：同理，记录最小左边界。
   ```cpp
   // 向右扩展右边界（itisover 代码片段）
   int Max = 0;
   for (int i = 1; i <= m; ++i) {
       if (p[i] > Max) T = 0, Max = p[i];
       else T = Max - p[i];
       while (T + 1 < h[Max + 1]) ++T, ++Max;
       R[i] = Max;
   }
   ```

2. **贪心覆盖**：
   ```cpp
   sort(intervals.begin(), intervals.end(), cmp);
   int last = 0, ans = 0;
   for (auto &it : intervals) {
       if (it.l > last) {
           ans++;
           last = it.r;
       }
   }
   if (ans > 0) ans++;  // 至少需一个安全树上的飞行点
   ```

---

### **同类型题与算法套路**

- **通用解法**：区间覆盖问题，按右端点排序后贪心选点。
- **类似题目**：
  1. **P2082 区间覆盖**：最小点数覆盖所有区间。
  2. **P1230 智力大冲浪**：活动安排问题。
  3. **P2245 星际导航**：贪心选择最短路径。

---

### **推荐题目**
1. **P2082**：区间覆盖模板题。
2. **P1230**：经典活动选择贪心。
3. **P2255**：会议室安排，类似贪心策略。

---

### **个人心得摘录**

- **itisover**：预处理时注意利用单调性，避免重复计算。
- **VioletIsMyLove**：调试中发现区间包含关系需特殊处理，否则贪心失效。

---

### **可视化与算法演示**

#### **贪心过程动画设计**
- **颜色标记**：红色区间表示未覆盖，绿色表示已覆盖，黄色高亮当前选择点。
- **步进控制**：点击按钮逐步展示贪心选择，右侧显示当前覆盖区间和飞行点数量。
- **复古像素风格**：
  - **树**：蓝色像素块，安全树闪烁。
  - **夜雀**：黄色像素点，移动时显示轨迹。
  - **飞行点**：红色星形，伴随8-bit音效。

#### **交互设计**
- **Canvas 绘制**：网格表示树编号，动态更新区间覆盖。
- **音效**：选择飞行点时播放“哔”声，覆盖成功时播放胜利音效。
- **自动模式**：AI 按贪心策略自动执行，速度可调。

```javascript
// 伪代码：贪心动画核心逻辑
function animateGreedy(intervals) {
    sortByRight(intervals);
    let last = 0, ans = 0;
    intervals.forEach((it, idx) => {
        highlightInterval(it);  // 高亮当前区间
        if (it.l > last) {
            playSound('select');
            ans++;
            last = it.r;
            drawPoint(it.r);  // 绘制飞行点
        }
        delay(1000);  // 步进间隔
    });
}
```

---

### **总结**
本题通过预处理夜雀活动区间，转化为经典贪心问题。高效预处理与正确排序策略是解题关键。可视化设计通过复古风格和交互演示，直观呈现贪心选择的每一步，帮助理解算法核心。

---
处理用时：68.94秒
# 题目信息

# 『JROI-5』Interval

## 题目背景

小 C 喜欢带有区间操作的数据结构，因为这样的题总会有一档好写的 $\mathcal{O}\left(n^2\right)$ 部分分。

## 题目描述


**本题读入量较大，建议使用较快的读入方式，可以参考 [赛时公告板](https://www.luogu.com.cn/paste/lueudpd5)**

小 C 有一个长度为 $n$ 的序列 $a$，第 $i$ 项为 $a_i$。

$a$ 是一个 $1\sim n$ 的排列（即 $1\sim n$ 在 $a$ 中各出现一次）。

定义 $\operatorname{Mex}_{l,r}$ 为 $\{a_l,a_{l+1},
\cdots,a_{r-1},a_r\}$ 中**没有出现过的最小正整数**。

例如，$\operatorname{Mex}\{2,3\}=1,\operatorname{Mex}\{1,2,3\}=4$。

小 C 还有一个长度为 $n$ 的数列 $f$。

定义一个区间 $\left[l,r\right]$ 是合法的当且仅当 
$$f_{r-l+1}< \operatorname{Mex}_{l,r}$$

小 C 希望你告诉他，最短的合法区间的长度是多少，特别的，如果没有区间合法，则输出 `0`。

## 说明/提示

【样例解释】

对于 #1，容易发现 $\left[1,3\right]$ 是最短的合法区间。

对于 #2，容易发现 $\left[3,3\right]$ 是最短的合法区间。

对于 #3，容易发现没有合法的区间。

---

对于 $10\%$ 的数据，满足 $1\leq n\leq 100$。

对于 $20\%$ 的数据，满足 $1\leq n\leq 1000$。

对于另外 $10\%$ 的数据，满足 $f$ 不升，即满足 $f_1\geq f_2\geq\cdots\geq f_n$，且 $1\leq n\leq 10^6$。

对于 $100\%$ 的数据，满足 $1\leq n\leq 4\times 10^6,1\leq f_i\leq 10^9$。


## 样例 #1

### 输入

```
5
2 3 1 5 4
2 2 3 4 5```

### 输出

```
3```

## 样例 #2

### 输入

```
5
2 3 1 5 4
1 2 2 4 5```

### 输出

```
1```

## 样例 #3

### 输入

```
5
1 3 4 2 5
6 7 8 9 10```

### 输出

```
0```

## 样例 #4

### 输入

```
见附件```

### 输出

```
见附件```

# AI分析结果



### 综合分析与结论

**题目核心**：寻找最短区间 $[l,r]$ 使得 $\text{Mex}_{l,r} > f_{r-l+1}$，其中 $\text{Mex}$ 是区间未出现的最小正整数。  
**关键难点**：高效计算每个区间长度的最大 $\text{Mex}$，避免暴力枚举所有区间。  
**核心贪心策略**：  
1. 预处理每个数 $k$ 的位置，维护包含 $1 \sim k$ 的最小区间 $[L_k, R_k]$。  
2. 对于每个长度 $i$，若存在 $f_i$ 使得 $R_{f_i}-L_{f_i}+1 \leq i$，则 $i$ 是合法长度。  
**最优算法**：前缀最值预处理 + 线性扫描比较，时间复杂度 $O(n)$。

---

### 题解评分（≥4星）

1. **caibet（★★★★☆）**  
   - **亮点**：利用差分数组优化区间覆盖，逻辑清晰。  
   - **代码**：预处理位置后，用差分统计每个长度对应的最大 $\text{Mex}$。  
   ```cpp
   F(i,1,<=n){
       L = min(L,p[i]);
       R = max(R,p[i]);
       ++b[R-L+1]; // 差分记录
   }
   ```

2. **蒟蒻炒扇贝（★★★★★）**  
   - **亮点**：直接推导合法区间的必要条件，代码简洁高效。  
   - **代码**：前缀最值数组快速计算区间长度。  
   ```cpp
   for(int i=1; i<=n; i++){
       if(f[i]>n) continue;
       int l=qmin[f[i]], r=qmax[f[i]];
       if(r-l+1 <= i) return i;
   }
   ```

3. **Cocoly1990（★★★★☆）**  
   - **亮点**：官方题解，思路与蒟蒻炒扇贝一致，代码更简洁。  
   - **代码**：预处理后直接比较区间长度。  
   ```cpp
   for(int i=1; i<=n; i++){
       if(f[i]<=n && g[f[i]]<=i) return i;
   }
   ```

---

### 最优思路与代码实现

**关键步骤**：  
1. 记录每个数 $k$ 的位置 $pos[k]$。  
2. 维护前缀最小位置 $qmin[k]$ 和最大位置 $qmax[k]$。  
3. 对于每个 $i$，若 $f_i$ 对应的区间长度 $qmax[f_i]-qmin[f_i]+1 \leq i$，则 $i$ 是合法长度。

**核心代码**：  
```cpp
// 预处理前缀最值
for(int i=1; i<=n; i++){
    qmin[i] = min(qmin[i-1], pos[i]);
    qmax[i] = max(qmax[i-1], pos[i]);
}
// 检查每个长度i
for(int i=1; i<=n; i++){
    if(f[i] > n) continue;
    int l = qmin[f[i]], r = qmax[f[i]];
    if(r-l+1 <= i) return i;
}
```

---

### 同类型题与算法套路

**通用解法**：  
1. **区间包含问题**：通过预处理快速判断区间是否覆盖特定元素集合。  
2. **前缀最值优化**：利用前缀数组减少重复计算。  
3. **贪心选择**：通过维护最小区间逐步扩展或缩小。

**类似题目**：  
1. [P4137 Rmq Problem / mex](https://www.luogu.com.cn/problem/P4137)  
2. [P7669 [IOI2018] 排列模型](https://www.luogu.com.cn/problem/P7669)  
3. [P1972 [SDOI2009] HH的项链](https://www.luogu.com.cn/problem/P1972)

---

### 可视化与游戏化设计

**核心贪心过程动画设计**：  
1. **像素风格展示**：用 Canvas 绘制数轴，每个数 $k$ 的位置用不同颜色方块表示。  
2. **动态区间扩展**：  
   - 初始时高亮 $1$ 的位置，逐步扩展到包含 $1 \sim k$ 的最小区间。  
   - 显示当前 $L_k$ 和 $R_k$，并用红色框标记区间范围。  
3. **步进控制**：  
   - 用户可调整速度，观察区间如何随 $k$ 增大而扩展。  
   - 自动播放时，每次扩展播放音效（如“滴”声），找到合法区间时播放胜利音效。  

**复古游戏化元素**：  
- **8-bit 音效**：贪心选择时播放短音，合法区间出现时播放长音。  
- **积分系统**：每找到一个合法区间获得积分，连续正确增加连击分。  
- **AI 演示**：自动展示最优路径，用户可随时暂停/继续。  

---

### 个人心得摘录

- **调试教训**：初始未考虑 $f_i > n$ 的情况，导致数组越界。需增加边界判断。  
- **优化顿悟**：差分数组替代线段树覆盖，将复杂度从 $O(n \log n)$ 降至 $O(n)$。  
- **思维突破**：将 $\text{Mex}$ 转化为区间包含问题，是解题的关键转折点。

---
处理用时：69.88秒
# 题目信息

# [USACO22OPEN] Photoshoot B

## 题目描述

迫切希望在郡县集市上赢得最佳奶牛摄影师的 Farmer John 正在尝试为他的 $N$ 头奶牛拍摄一张完美的照片（$2 \leq N \leq 2\cdot 10^5$，$N$ 为偶数）。

Farmer John 拥有两种品种的奶牛：更赛牛（Guernsey）和荷斯坦牛（Holstein）。为了使他的照片尽可能地艺术，他想把他的奶牛排成一排，使得尽可能多的更赛牛处于队列中的偶数位置（队列中的第一个位置是奇数位置，下一个是偶数位置，以此类推）。由于他与他的奶牛缺乏有效的沟通，他可以达到目的的唯一方法是让他的奶牛的偶数长的「前缀」进行反转（一个前缀指的是对于某个位置 $j$，从第一头奶牛到第 $j$ 头奶牛范围内的所有奶牛）。

请计算 Farmer John 达到目的所需要的最小反转次数。


## 说明/提示

【样例解释】

在这个例子中，只需反转由前六头奶牛组成的前缀即可。
```
   GGGHGHHGHHHGHG （反转前）
-> HGHGGGHGHHHGHG （反转后）
```
在反转之前，四头更赛牛处于偶数位置。反转后，六头更赛牛处于偶数位置。不可能使得超过六头更赛牛处于偶数位置。

【测试点性质】

- 测试点 2-6 满足 $N\le 1000$。
- 测试点 7-11 没有额外限制。

## 样例 #1

### 输入

```
14
GGGHGHHGHHHGHG```

### 输出

```
1```

# AI分析结果



---

## **综合分析与结论**
### **题目核心思路**
将字符串两两分组，转化为01序列，通过贪心策略统计相邻不同标记的次数，确定最小反转次数。

### **难点与解决**
- **难点**：如何将反转操作的影响转化为分组处理，并找到最优反转策略。
- **解决**：将每组字符分为三种状态（GH→1，HG→0，相同→忽略），通过相邻状态变化的次数确定反转次数。

### **贪心策略**
1. **分组处理**：每两个字符为一组，标记为0/1/2。
2. **统计变化**：遍历01序列，每出现相邻不同状态，需一次反转。
3. **末尾处理**：若末尾为1（GH），需额外反转一次。

### **可视化设计思路**
- **动画展示**：用像素块表示每组字符状态，颜色区分0/1/2。每次反转时高亮前缀，改变后续奇偶性。
- **步进控制**：允许单步执行，观察每次反转如何改变状态序列。
- **复古风格**：8位像素动画，背景音乐和音效提示反转操作。

---

## **题解评分 (≥4星)**
### **1. yzyjh [★★★★☆]**
- **亮点**：思路简洁，代码清晰，直接转化为01序列统计相邻变化。
- **关键代码**：
  ```cpp
  vector<int> p;
  for (分组处理生成01序列)...
  int cnt = 0;
  for (统计相邻变化次数)...
  if (末尾为1) cnt++;
  ```

### **2. I_am_Accepted [★★★★☆]**
- **亮点**：严谨证明最终序列不能存在1，提供贪心正确性依据。
- **关键代码**：
  ```cpp
  For(i,1,n) {
    if (当前状态与之前不同) ans++;
  }
  if (末尾为1) ans++;
  ```

### **3. hhhqx [★★★★☆]**
- **亮点**：将问题类比为硬币翻转，简化代码至O(n)时间。
- **关键代码**：
  ```cpp
  for (遍历分组统计连通块)...
  ans += cnt - (末尾调整);
  ```

---

## **最优思路提炼**
1. **分组转化**：将每两个字符分为GH（1）、HG（0）、相同（忽略）。
2. **贪心选择**：相邻不同的分组状态需一次反转。
3. **末尾修正**：若最后一个有效分组为GH（1），需额外反转。

---

## **同类型题目与算法套路**
- **通用解法**：贪心处理分段问题，统计状态变化次数。
- **相似题目**：
  - **洛谷P2708**：硬币翻转（01串全变为1的最小反转次数）。
  - **LeetCode 2134**：最少交换次数使全1聚集。

---

## **推荐题目**
1. **洛谷P2708**（硬币翻转，贪心统计变化次数）
2. **洛谷P1208**（混合牛奶，贪心选择最小成本）
3. **LeetCode 670**（最大交换，贪心找高位最优替换）

---

## **个人心得摘录**
- **yzyjh**：两两分组后只需关注不同情况，相同情况无影响。
- **hhhqx**：末尾特殊情况需单独处理，否则会漏判最后一次反转。
- **Zero_s**：滚动变量优化空间，但头尾边界需仔细处理。

---

## **核心代码实现**
### **yzyjh的代码片段**
```cpp
vector<int> p;
for (int i=1; i<=n; i+=2) {
    if (s[i] != s[i+1]) {
        p.push_back(s[i]=='G' ? 1 : 0);
    }
}
int cnt = 0;
for (int i=1; i<p.size(); i++) {
    if (p[i] != p[i-1]) cnt++;
}
cout << cnt + (p.back() == 1);
```

---

## **可视化方案设计**
### **复古像素动画**
- **Canvas绘制**：每组用16x16像素块，绿色（G）、红色（H）、灰色（相同）。
- **反转效果**：点击触发反转，前缀块旋转并交换颜色。
- **音效**：反转时播放“哔”声，完成时播放胜利音效。

### **交互控制**
- **自动模式**：AI自动执行最优反转，每步间隔1秒。
- **连击积分**：连续正确反转获得额外分数，错误操作扣分。

### **代码片段（JS）**
```javascript
// 绘制分组像素块
function drawGroups(groups) {
    groups.forEach((g, i) => {
        ctx.fillStyle = g === 1 ? '#00FF00' : (g === 0 ? '#FF0000' : '#888');
        ctx.fillRect(i*20, 50, 16, 16);
    });
}
```

---
处理用时：79.54秒
# 题目信息

# 「HGOI-1」Build

## 题目背景

一次旅行，$\text{uuku}$ 到了一个奇怪的小镇。

## 题目描述

这个小镇将要和周围的其他小镇一共 $n$ 个小镇，一起修建一个能**连通**这 $n$ 个小镇，有 $m$ 条高速公路的交通网。其中每条高速公路都将会连接**不同的两个小镇**，即不存在一条高速公路的起点和终点相同。

但高速公路的修建费用是很高的，所以镇长们一致决定将共同承担高速公路的费用，所以他们希望修建的**总费用最小**。

而且由于不同小镇的基础设施建设情况不同，所以每个小镇在修建的费用也不同。经过协商，每条高速公路将由其所连接的两个小镇共同施工。每个小镇负责一半路程。为了同时结束整个施工过程，显然将会有小镇同时进行多条道路的施工，而施工的道路数量越多，所需要花费的价钱就越多。

经过计算，每个小镇施工的花费可以用函数表示，及对于小镇 $i$，有三个参数 $a_i$，$b_i$，$c_i$。对于 $i$ 小镇来说在修建其第 $j$ 条高速时，**这条**高速所需要的花费为 $a_ij^2+b_ij+c_i$。

现在，这些镇长想要 $\text{uuku}$ 给他们提供一个满足要求的**建造方案**，使**总价格最小**。

当然，$\text{uuku}$ 将这个问题交给了你。

## 说明/提示

#### 数据范围
本题采用**捆绑测试**，共有 $6$ 个 $\text{subtask}$，最终分数为所有 $\text{subtask}$ 分数之和。
$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Task} & \textbf{Score} & \textbf{特殊限制} \cr\hline
1 & 10 & n,m\le 500  \cr\hline
2 & 20 &  n,m\le 5\times 10^3 \cr\hline
3 & 10 & \text{每个小镇的函数相同}\cr\hline
4 & 20 & a_i=0 \cr\hline
5 & 20 & m=n-1 \cr\hline
6 & 20 & \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，$2\le n \le 2 \times 10^5$， $n-1 \le m \le 10^6$，$0 \le a_i$，$b_i$，$c_i \le 10^6$。

数据保证最小价格在 $\tt{long \ long}$ 范围内。

#### 说明

本题有 $\text{spj}$，价格正确可以获得 $30\%$ 的分数。每个 $\text{subtask}$ 取其中所有数据点得分的最小值。

如果你不会构造方案，也请你再输出最小价格后输出 $m$ 行，每行两个 $[1,n]$ 范围内的整数，防止 $\text{spj}$ 出现错误。

本题已添加 hack 数据，为 $\text{subtask7}$，该 $\text{subtask}$ 不计分数，但会影响是否 $\text{AC}$。

## 样例 #1

### 输入

```
4 4
1 2 3
2 3 4
3 4 5
4 5 6```

### 输出

```
114
1 2
1 2
1 3
3 4```

# AI分析结果



### 综合分析与结论

**核心思路**  
题目要求构造一个连通图，总费用最小。每个点的费用函数是二次递增的，因此贪心策略的关键在于每次选择当前费用增量最小的点分配度数，确保总费用最小。构造阶段通过双指针法连接度数最大和最小的点，保证图的连通性。

**贪心选择策略**  
1. **度数分配**：每个点初始度数为1（保证连通性），剩余度数用最小堆动态选择费用增量最小的点。
2. **构造方案**：按度数排序后，用双指针法连接最大和最小度数点，确保无自环且连通。

**难点与解决**  
- **连通性保证**：初始分配每个点至少1度，构造时优先连接度数差异大的点，形成中心辐射结构。
- **费用最小化**：堆维护当前最小增量，动态调整度数分配。
- **自环避免**：构造过程中每个边连接不同点，且度数不超过m。

**可视化设计思路**  
- **动画展示**：用柱状图表示各点度数，每次贪心选择时高亮最小增量点，堆中弹出后更新度数并重新入堆。
- **复古像素风格**：用8位像素块表示点，连接时显示边，音效提示度数变化。
- **交互控制**：支持步进、自动播放，对比贪心与二分法的分配过程。

---

### 题解清单（≥4星）

1. **uuku的题解（5星）**  
   - **亮点**：  
     - 明确贪心策略，堆维护费用增量。  
     - 构造方案证明连通性与无自环。  
     - 代码高效，处理边界条件清晰（如度数上限m）。  
   - **代码可读性**：结构清晰，注释合理。  
   - **实践性**：直接实现即可通过大数据测试。

---

### 最优思路提炼

1. **度数分配的贪心策略**  
   - 初始每个点分配1度，保证连通必要条件。  
   - 剩余度数用堆选择最小增量点，时间复杂度O(m log n)。  

2. **构造方案的证明技巧**  
   - 双指针法连接最大和最小度数点，确保所有点连通。  
   - 数学归纳法证明无自环（反证法+度数奇偶性）。  

3. **优化点**  
   - 堆中预存每个点的下一次增量，避免重复计算。  
   - 排序后构造边，减少调整次数。  

---

### 同类型题与算法套路

- **贪心选择递增代价问题**：如任务调度（Huffman编码）、最小生成树（Kruskal）。  
- **度数分配模型**：类似图论中度数约束问题（如欧拉回路）。  
- **构造连通图技巧**：中心节点法、双指针调整度数。  

---

### 推荐题目

1. **P1094 [NOIP2007 提高组] 纪念品分组**（贪心+双指针）  
2. **P3366 【模板】最小生成树**（Kruskal贪心）  
3. **P4053 [JSOI2007] 建筑抢修**（堆优化贪心）  

---

### 代码核心逻辑

```cpp
// 度数分配部分
priority_queue<pli, vector<pli>, greater<pli>> q;
for (int i = 1; i <= n; ++i) {
    ans += v[i].get(); // 初始分配1度
    q.push({v[i].get(), i}); // 预存下一次增量
}
while (du--) { // 分配剩余度数
    auto [cost, id] = q.top(); q.pop();
    ans += cost;
    if (v[id].cnt < m) q.push({v[id].get(), id});
}

// 构造边部分
sort(v + 1, v + n + 1, [](P a, P b) { return a.cnt > b.cnt; });
int l = 1, r = n;
while (l < r) {
    cout << v[r].id << ' ' << v[l].id << '\n';
    v[l].cnt--; v[r].cnt--;
    if (v[l].cnt == 0) l++;
    if (v[r].cnt == 0) r--;
}
```

---

### 可视化与游戏化设计

**复古像素动画**  
- **Canvas绘制**：每个小镇为像素块，高度表示度数，颜色区分费用。  
- **贪心过程**：堆顶元素闪烁，连接时显示边（8位音效）。  
- **自动模式**：AI按贪心策略自动分配度数，进度条显示剩余度数。  

**音效与交互**  
- **选择音效**：清脆“滴”声提示堆弹出。  
- **连边音效**：低音鼓点表示连接操作。  
- **关卡积分**：每正确分配10度得10分，连击奖励加速动画。  

---

**总结**：本题通过贪心堆优化和构造技巧，高效解决复杂约束下的最小费用问题，其思路可推广至类似递增代价的分配模型。

---
处理用时：130.12秒
# 题目信息

# 「DTOI-4」行走

## 题目背景

小 L 感到无聊，于是希望在树上行走。

## 题目描述

小 L 有一棵 $n$ 个点的树，树上点有点权，其中第 $i$ 个点权值为 $a_i$。

他不喜欢奇奇怪怪的权值，于是他保证 $a_i$ 一定是 $-1, 0, 1$ 之一。

他认为在树上行走是有趣的，于是他想要在这棵树上走出一条路径 $P$，其需要满足以下条件：

- $P$ 是一条**可以为空**的**简单有向路径**。
- 设 $P$ 中依次经过的点为 $P_1, P_2, \cdots, P_{|P|}$，则你求出的 $P$ 需要满足 $P_1 = 1$。
- 设 $f(P) = \displaystyle\sum_{i = 1}^{|P|} \frac{a_{P_i}}{2^{i - 1}}$，则你求出的 $P$ 需要满足 $f(P)$ 最大。
- 在 $f(P)$ 最大的前提下，你求出的 $P$ 还需要满足 $P$ 的字典序最小。

请你求出符合上述条件的路径 $P$。 

------------

关于本题中字典序的定义：

设有两条待比较的路径 $P \neq Q$。

- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i < Q_i$，则我们称 $P$ 的字典序小于 $Q$。
- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i > Q_i$，则我们称 $P$ 的字典序大于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| < |Q|$，则我们称 $P$ 的字典序小于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| > |Q|$，则我们称 $P$ 的字典序大于 $Q$。

## 说明/提示

#### 样例 #1 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/c7n2n6i0.png)

$P = [1, 2, 4]$ 时 $f(P) = 1 + 0 + \frac{1}{4} = \frac{5}{4}$。可以证明不存在更优的 $P$。
#### 数据范围
| $\textbf{Subtask}$ | $n$ | $a_i$ | 依赖 | 分值 |
| :------: | :------: | :------: | :------: | :------: |
| $1$ | $1 \leq n \leq 50$ | 无特殊限制 | 无 | $10 \operatorname{pts}$ |
| $2$ | $1 \leq n \leq 500$ | 同上 | $1$ | $10 \operatorname{pts}$ |
| $3$ | $1 \leq n \leq 5 \times 10^3$ | 同上 | $1, 2$ | $10 \operatorname{pts}$ |
| $4$ | $1 \leq n \leq 10^5$ | 同上 | $1 \sim 3$ | $20 \operatorname{pts}$ |
| $5$ | 无特殊限制 | $a_i \in \{-1, 1\}$ | 无 | $20 \operatorname{pts}$ |
| $6$ | 同上 | 无特殊限制 | $1 \sim 5$ | $30 \operatorname{pts}$ |

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$a_i \in \{-1, 0, 1\}$，$1 \leq u, v \leq n$，保证给出的边可以构成一棵**无根树**。

## 样例 #1

### 输入

```
5
1 0 -1 1 -1
1 2
2 3
2 4
1 5```

### 输出

```
1 2 4```

# AI分析结果



### 题解思路与算法分析

#### 核心贪心策略
1. **权值优先级**：优先选择子节点中的最大值（1 > 0 > -1），通过数学证明选择 1 的贡献必然优于后续所有 0 的叠加。
2. **字典序处理**：对每个节点的子节点按编号排序，在权值相等时选择编号最小的。
3. **剪枝优化**：排除权值为 -1 的节点及其子树，避免无效搜索。

#### 解决难点
1. **贪心选择验证**：通过数学不等式证明 $-1$ 的不可选性，确保每一步的局部最优性。
2. **字典序动态维护**：通过预排序邻接表，在权值相同的情况下自然满足字典序要求。
3. **高效路径构建**：使用 BFS/DFS 分层处理或动态记录父节点，避免全树遍历。

---

### 题解评分（≥4星）

#### 1. xiaoqian02（★★★★☆）
- **思路清晰度**：明确分步证明贪心策略，代码注释详细。
- **代码可读性**：使用递归 DFS 结构清晰，邻接表排序实现简洁。
- **优化亮点**：动态维护路径贡献数组 `qz`，剪枝高效。
- **代码片段**：
```cpp
for (int i = 1; i <= n; i++) sort(ed[i].begin(), ed[i].end());
if (a[1] == -1) return 0;
dfs(1, -1, 0);
```

#### 2. elbissoPtImaerD（★★★★☆）
- **思路创新性**：分层 BFS 处理，动态淘汰非最优路径。
- **实现简洁性**：代码简短，利用优先队列维护决策点。
- **核心逻辑**：
```cpp
for(int i=0;G[x].size();i++) 
    if(a[y]==1) push优先队列;
```

#### 3. 是青白呀（★★★★☆）
- **可视化友好**：分层处理逻辑清晰，适合动画演示。
- **算法优化**：二次 DFS 剪枝末尾 0，避免冗余输出。
- **关键代码**：
```cpp
while (now > 0 && a[ans[now]] == 0) now--; // 剪枝末尾 0
```

---

### 最优思路与技巧提炼

1. **权值分层决策**  
   - 每层只保留最大权值的节点，动态淘汰次优选择。
   - **实现方式**：BFS 队列中按层处理，每层筛选最大值。

2. **字典序自然保证**  
   - 预处理时对邻接表排序，搜索时按序遍历即可满足字典序。
   - **代码示例**：
     ```cpp
     for (int i = 1; i <= n; i++) sort(G[i].begin(), G[i].end());
     ```

3. **贡献值动态维护**  
   - 使用数组记录路径各位置的贡献值，避免浮点运算。
   - **代码片段**：
     ```cpp
     qz[dep] = 1; // 第 dep 位为 1 的贡献
     ```

---

### 同类型题目推荐

1. **P1090 合并果子**  
   - 贪心策略：优先合并小堆，使用优先队列实现。

2. **P1230 智力大冲浪**  
   - 时间安排贪心：按截止时间排序，动态选择任务。

3. **P5019 铺设道路**  
   - 区间贪心：每次选择最长连续区间操作。

---

### 可视化设计（复古像素风格）

#### 动画方案
1. **树结构绘制**  
   - **Canvas 初始化**：根节点居中，子节点按层分布。
   - **颜色标记**：1（绿色）、0（灰色）、-1（红色）。

2. **贪心过程演示**  
   - **步进高亮**：当前节点闪烁，候选子节点边框高亮。
   - **音效触发**：选择节点时播放 `coin.wav`（8-bit 音效）。

3. **自动演示模式**  
   - **AI 逻辑**：自动选择最大权值子节点，权值相同时选最左侧。
   - **连击积分**：连续正确选择加分，错误选择重置。

#### 交互组件
```html
<div id="control-panel">
  <button onclick="step()">单步执行</button>
  <input type="range" id="speed" min="1" max="10">
</div>
<canvas id="tree-view"></canvas>
<audio id="sound-effect" src="blip.wav"></audio>
```

---

### 核心代码实现（贪心部分）

```cpp
void dfs(int u) {
    sort(adj[u].begin(), adj[u].end()); // 邻接表排序保证字典序
    for (int v : adj[u]) {
        if (a[v] == -1) continue;
        if (current_max == 1 && a[v] < 1) break; // 剪枝
        if (a[v] > current_max) {
            reset_path(); // 发现更大权值，重置路径
            current_max = a[v];
        }
        if (a[v] == current_max) {
            path.push_back(v);
            dfs(v);
            if (found) return; // 找到全局最优
            path.pop_back();
        }
    }
}
```

---

### 总结

本题通过权值优先级与字典序动态维护，结合数学证明确保贪心正确性。分层处理和邻接表排序是核心优化点。可视化设计可增强对贪心过程的理解，复古风格与音效提升学习趣味性。

---
处理用时：70.66秒
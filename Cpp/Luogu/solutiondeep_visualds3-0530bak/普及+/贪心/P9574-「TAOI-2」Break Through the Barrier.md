# 题目信息

# 「TAOI-2」Break Through the Barrier

## 题目描述

有一个由 $\tt B$ 和 $\tt T$ 组成的字符串。

你可以进行如下操作：选择一个长度为 $4$ 的子串，其恰好等于 $\texttt{BTTB}$，并将其修改为 $\texttt{TBBT}$。你可以进行这种操作任意多次（也可以不操作）。

定义一个字符串的权值为最长的 $\texttt{T}$ 连续段长度。你需要通过如上操作使得字符串的权值尽可能大。输出这个最大值。

+ 子串的定义：一个字符串 $b$ 被称为字符串 $a$ 的子串，当且仅当可以通过删除 $a$ 开头若干个（可以是 $0$ 个，下同）字符和结尾若干个字符得到 $b$。
+ $\texttt{T}$ 连续段的定义：一个原字符串的仅由 $\texttt{T}$ 构成的子串。

## 说明/提示

**本题采用捆绑测试。**

记 $\sum n$ 为所有数据中的 $n$ 的和。

+ Subtask 0（5 pts）：$n \leq 7$。
+ Subtask 1（20 pts）：$T \leq 10$，$n \leq 10$。
+ Subtask 2（25 pts）：$\sum n \leq 5000$。
+ Subtask 3（5 pts）：保证给定的字符串无法进行任何操作。
+ Subtask 4（45 pts）：无特殊限制。

对于所有数据，$1 \leq T \leq 10^3$，$1 \leq n \leq 10^5$，$1 \leq \sum n \leq 5\times 10^5$，字符串只包含字符 `B` 和 `T`。

## 样例 #1

### 输入

```
6
3
TTT
4
BTTB
5
TBBTT
6
BTBTBB
7
BTTBTTB
17
TTBTBTTBTBTTTBTTB
```

### 输出

```
3
2
2
1
3
5
```

# AI分析结果



### 综合分析与结论
本问题核心在于通过特定操作扩展连续 T 段。关键观察是每个 T 段最多能左右各扩展 1 个 T，总长度最多增加 2。贪心策略的要点是预处理可扩展的位置，高效判断每个 T 段能否扩展。

#### 贪心策略要点
1. **传递性结构**：BTTB 结构可通过操作向右或向左传递，形成交替的 TB/BT 序列。
2. **双向扩展**：每个 T 段左右若存在可传递的结构，则能扩展 1 个 T。
3. **预处理标记**：使用双指针或动态规划预处理每个位置是否支持扩展。

#### 可视化设计思路
- **动画演示**：以像素块表示字符，高亮 BTTB 结构，逐步替换为 TBBT，展示扩展过程。
- **颜色标记**：原有 T 段用绿色，扩展部分用黄色，传递路径用闪烁效果。
- **步进控制**：允许单步执行操作，观察每个步骤对连续 T 段的影响。

### 题解评分（≥4星）
1. **EdenSky（5★）**  
   - **亮点**：双指针标记传递结构，逻辑推导严谨，代码高效。  
   - **关键代码**：
     ```cpp
     while(c[r+1]=='T'&&c[r+2]=='B') r+=2,ri[r]++;
     while(c[l-1]=='T'&&c[l-2]=='B') l-=2,le[l]++;
     ```
2. **light_searcher（4★）**  
   - **亮点**：剪枝优化暴力法，预处理左右扩展条件，代码简洁。  
   - **关键代码**：
     ```cpp
     if(search_l(l-1)) cnt++;
     if(search_r(r+1)) cnt++;
     ```
3. **dino（4★）**  
   - **亮点**：动态规划记录扩展状态，代码结构清晰。  
   - **关键代码**：
     ```cpp
     if(s[i] != s[i - 1]){
         if(s[i] == 'T') ltb[i] = ltb[i - 2], lbt[i] = 1;
         else lbt[i] = lbt[i - 2], ltb[i] = 1;
     }
     ```

### 最优思路提炼
1. **传递链预处理**：扫描 BTTB 结构，向左右扩展 TB/BT 交替序列，标记可扩展的位置。
2. **双指针标记法**：对每个 BTTB 结构，向左右扩展并标记边界，快速判断 T 段能否扩展。
3. **动态规划法**：记录每个位置能否成为扩展边界，避免重复计算。

### 同类型题目推荐
1. **P1090 [NOIP2004 提高组] 合并果子**（贪心选择最小代价）
2. **P1223 [JSOI2007] 排队接水**（贪心排序策略）
3. **P2870 [USACO07DEC] Best Cow Line G**（字符串贪心选择）

### 核心代码实现（EdenSky 解法）
```cpp
// 双指针标记传递结构
int l=1,r=l+3;
while(r<=n){
    l++,r++;
    if(c[l]=='B'&&c[l+1]=='T'&&c[l+2]=='T'&&c[l+3]=='B'){
        ri[r]++,le[l]++; // 标记左右可扩展
        // 向右扩展传递链
        while(c[r+1]=='T'&&c[r+2]=='B') r+=2,ri[r]++;
        // 向左扩展传递链
        while(c[l-1]=='T'&&c[l-2]=='B') l-=2,le[l]++;
        l=r-1,r=l+3;
    }
}
// 计算最大扩展长度
ans=max(r-l+1+ri[l-1]+le[r+1],ans);
```

### 可视化设计（复古像素风格）
1. **像素渲染**：用 16x16 像素块表示字符，B 为蓝色方块，T 为黄色方块。
2. **操作动画**：选中 BTTB 时闪烁红色边框，替换为 TBBT 后播放“叮”音效。
3. **传递演示**：自动模式逐步向右扩展，高亮当前操作的 TB 序列。
4. **交互控制**：方向键控制速度，空格暂停，Enter 单步执行。

#### 关键 JS 片段
```javascript
// 渲染字符串到 Canvas
function drawString(s, ctx, x, y) {
    for (let i = 0; i < s.length; i++) {
        ctx.fillStyle = s[i] === 'B' ? '#00f' : '#ff0';
        ctx.fillRect(x + i*16, y, 14, 14);
    }
}
// 播放音效
function playSound(freq) {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = freq;
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

通过上述设计，学习者可直观观察贪心策略的执行过程，理解传递性扩展的核心机制。

---
处理用时：60.13秒
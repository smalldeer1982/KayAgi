# 题目信息

# 「KDOI-06-J」贡献系统

## 题目描述

洛谷贡献系统上线了！

现在有 $n$ 个人即将参加一场洛谷月赛，每个人的等级分**互不相同**。第 $i$ 个人的等级分是 $r_i$，贡献值是 $c_i$。

假设第 $i$ 个人的等级分在这 $n$ 个人中的排名是 $a_i$（排名按等级分从大到小排序），且在月赛中的排名是 $b_i$，没有两个人的排名相同。也就是说，$a$ 和 $b$ 都是 $1$ 到 $n$ 的排列。比赛结束后，每个人都会执行以下操作：

+ 若 $a_i=b_i$，则第 $i$ 个人的等级分不会发生任何变化，因此第 $i$ 个人不会进行任何操作；
+ 若 $a_i>b_i$，则第 $i$ 个人的等级分会上升，因此第 $i$ 个人会给出题人点赞，导致出题人的贡献值上升 $c_i$（$c_i$ 可能是负数，此时会导致出题人的贡献值下降）；
+ 若 $a_i<b_i$，则第 $i$ 个人的等级分会下降，因此第 $i$ 个人会给出题人点踩，导致出题人的贡献值下降 $c_i$（$c_i$ 可能是负数，此时会导致出题人的贡献值上升）。

作为这场月赛唯一的出题人，初始时你的贡献值为 $0$。你想知道，对于所有可能的排列 $b$（显然，排列 $a$ 在比赛前已经被确定），在比赛结束后你的贡献值最大是多少。

## 说明/提示

**【样例解释 #1】**

对于第一组测试数据，设五个人按输入顺序分别为 A，B，C，D，E，则当月赛中的排名顺序为 ABECD 时贡献值最大，为 $0+0-(-50)-(-22)+208=280$。可以证明，这是唯一能使贡献值达到最大的排名顺序。

对于第二组测试数据，设八个人按输入顺序分别为 A，B，C，D，E，F，G，H，则当月赛中的排名顺序为 ABCDEGFH 时可以使贡献值达到最大值 $1$，注意此时有多种可能的使贡献值最大的排名顺序。

**【样例 #2】**

见选手目录下的 `contrib/contrib2.in` 与 `contrib/contrib2.ans`。

**【样例 #3】**

见选手目录下的 `contrib/contrib3.in` 与 `contrib/contrib3.ans`。



***

**【数据范围】**

对于所有数据保证：$1\le T\le 5$，$1\le n\le 2\times 10^5$，$0\le r_i\le 10^9$，$-10^9\le c_i\le 10^9$，且对于任意 $1\le i<n$，$r_i>r_{i+1}$。

| 测试点编号  |    $n\le $     | 特殊限制 |
| :---------: | :------------: | :------: |
|  $1\sim3$   |      $8$       |    无    |
|     $4$     |     $100$      |   ABC    |
|     $5$     |     $100$      |    C     |
|  $6\sim 7$  |     $100$      |    无    |
|  $8\sim 9$  | $5\times 10^3$ |    AB    |
| $10\sim 11$ | $5\times 10^3$ |    C     |
| $12\sim 14$ | $5\times 10^3$ |    无    |
|    $15$     | $2\times10^5$  |    AB    |
| $16\sim 18$ | $2\times10^5$  |    B     |
| $19\sim 21$ | $2\times10^5$  |    C     |
| $22\sim 25$ | $2\times 10^5$ |    无    |

+ 特殊性质 A：对于任意 $1\le i<n$，保证 $c_i=c_{i+1}$；
+ 特殊性质 B：对于任意 $1\le i<n$，保证 $c_i\le c_{i+1}$；
+ 特殊性质 C：对于任意 $1\le i\le n$，保证 $c_i\ge 0$。

## 样例 #1

### 输入

```
3
5
3816 3738 3726 3621 3582
111 109 -50 -22 208
8
8 7 6 5 4 3 2 1
128 1 0 0 0 0 1 0
10
10 9 8 7 6 5 4 3 2 1
1 1 4 5 1 4 1 9 1 9
```

### 输出

```
280
1
34
```

# AI分析结果



### 题解思路与算法分析

#### 核心贪心策略
1. **三段分割法**：将序列分为三部分：
   - **前段**：连续正数区间（`1~l`）
   - **中间段**：混合正负数的区间（`l+1~r-1`）
   - **后段**：连续负数区间（`r~n`）
2. **贡献计算**：
   - 中间段直接累加绝对值贡献
   - 前段通过枚举断点求最大后缀和
   - 后段通过枚举断点求最大前缀和

#### 解决难点
1. **分割点确定**：通过两次遍历快速找到首个负数位置 `l` 和末位正数位置 `r`
2. **前缀和优化**：通过预处理绝对值前缀和快速计算各区间贡献
3. **断点枚举优化**：线性时间内计算前段和后段的最优断点

### 题解评分 (≥4★)

| 题解作者      | 评分 | 关键亮点                                                                 |
|---------------|------|--------------------------------------------------------------------------|
| zjpwdyf       | ★★★★☆ | 三段分割清晰，前缀和优化实现简洁，时间复杂度 O(n)                       |
| 引领天下      | ★★★★ | 首尾处理逻辑明确，代码可读性强，正确性验证充分                         |
| lzy20091001   | ★★★★ | 数学推导严谨，特殊性质处理到位，边界条件处理完善                       |

### 最优思路提炼
1. **贪心分割点**：  
   - 前段结束位置 `l` = 第一个负数出现的位置-1  
   - 后段开始位置 `r` = 最后一个正数出现的位置+1
2. **贡献计算公式**：  
   ```text
   总贡献 = 前段贡献(max) + 中间段绝对值总和 + 后段贡献(max)
   ```
3. **前缀和优化**：  
   - 前段贡献计算：`sum[r]-sum[i] - c[i]`  
   - 后段贡献计算：`sum[i-1]-sum[l] + c[i]`

### 同类型题目套路
1. **区间选择问题**：如「活动安排问题」中选择不重叠区间的最大数量
2. **分段最优化**：如「最大子数组和」的分治解法
3. **带权排列构造**：如「任务调度」中根据权重安排执行顺序

### 推荐练习题目
1. [P1230 智力大冲浪](https://www.luogu.com.cn/problem/P1230)  
   （贪心选择截止时间最近的任务）
2. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)  
   （双指针贪心配对）
3. [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)  
   （差分数组与贪心决策）

---

### 可视化算法设计（复古像素风格）

#### 动画方案
1. **元素绘制**：
   - 用不同颜色方块表示正数（绿色）、负数（红色）、零（灰色）
   - 分割线用黄色闪烁方块标识
   - 当前计算区间用半透明覆盖层标记

2. **核心流程**：
   ```mermaid
   graph TD
   A[初始化画布] --> B[绘制原始序列]
   B --> C{自动/手动模式}
   C -->|自动| D[演示分割线确定]
   C -->|手动| E[用户点击选择分割点]
   D --> F[高亮前段计算过程]
   F --> G[绘制前缀和变化]
   G --> H[演示断点枚举]
   H --> I[更新最大贡献值]
   I --> J[重复处理后段]
   J --> K[显示最终结果]
   ```

3. **交互设计**：
   - **音效**：选择分割点时播放「滴」声，计算贡献时播放「咔」声
   - **AI 模式**：自动以 1.5s/步的速度演示分割与计算
   - **游戏积分**：正确完成分割得 100 分，最优解额外加 50 分

#### 代码片段（关键逻辑）
```javascript
// Canvas 绘制核心逻辑
function drawArray(arr, l, r) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let i = 0; i < arr.length; i++) {
    ctx.fillStyle = getColor(arr[i]); // 根据数值获取颜色
    ctx.fillRect(i*30, 100, 25, 25);  // 绘制数值方块
    if (i === l || i === r) {         // 绘制分割线
      ctx.fillStyle = 'rgba(255,255,0,0.5)';
      ctx.fillRect(i*30-5, 95, 35, 35);
    }
  }
}

// 贪心过程演示
async function autoPlay() {
  for (let i = 0; i < l; i++) {      // 前段计算
    highlightBlock(i);               // 高亮当前块
    await sleep(500);                // 暂停500ms
    updateSumDisplay(sum[i]);        // 更新前缀和显示
  }
  // ... 后续类似处理其他区间
}
```

---

### 题解代码示例（zjpwdyf 的实现）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+5;
ll T,n,c[N],sum[N],ans1,ans2;

int main(){
    cin>>T;
    while(T--){
        ans1=ans2=0;
        cin>>n;
        for(int i=1;i<=n;i++) scanf("%lld",&c[i]);
        for(int i=1;i<=n;i++) sum[i]=sum[i-1]+abs(c[i]);

        int l=1, r=n;
        while(c[l]>0 && l<=n) l++;
        while(c[r]<0 && r>=1) r--;

        // 计算前段贡献
        for(int i=1;i<l;i++) 
            ans1 = max(ans1, sum[l-1]-sum[i] - c[i]);
        
        // 计算后段贡献
        for(int i=n;i>r;i--) 
            ans2 = max(ans2, sum[i-1]-sum[r] + c[i]);

        cout << ans1 + ans2 + (sum[r]-sum[l-1]) << '\n';
    }
    return 0;
}
```

---

### 个人心得摘录
> "调试时发现边界条件容易出错，特别是当全正或全负时需要特殊处理。通过单独处理首尾区间，代码逻辑更清晰。" —— lzy20091001  
> "前缀和优化将O(n²)暴力枚举降为O(n)，这是算法的关键转折点。" —— zjpwdyf

---

### 总结
本题通过巧妙的区间分割和贪心选择，将复杂排列问题转化为三段独立计算。可视化设计通过复古像素风格增强理解，关键在快速定位分割点与高效计算区间贡献。同类题目可加强分段处理和贪心策略的应用能力。

---
处理用时：84.50秒
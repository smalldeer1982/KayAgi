# 题目信息

# 种树

## 题目背景

小 Rf 不是很喜欢种花，但是他喜欢种树。

## 题目描述

路边有 $n$ 棵树，每棵树的 **高度** 均为正整数，记作 $p_1, p_2 \dots p_n$。

定义一棵树的 **宽度** 为它高度的正因数个数，这些树能覆盖的距离为它们宽度的乘积，你想请你的朋友们来乘凉，但你发现这些树能覆盖的距离不够多。

于是你买了总量为 $w$ 单位的神奇化肥。你可以施若干次肥，每次你可以使用 $k$ 单位化肥（**要求 $k$ 必须为当前化肥量的正因数**），让任意一棵树的高度乘上 $k$，同时你剩余的化肥量也会除以 $k$。每次施肥的树可任意选择，且每次施肥选择的树不需相同。

你需要最大化这些树所能覆盖的距离，并输出这个最大距离。答案对 $998244353$ 取模。

## 说明/提示

**【样例 1 解释】**

+ 第一次施肥，向第一棵树施 $15$ 单位的肥，使其高度变成 $120$，剩余 $4$ 单位的化肥。
+ 第二次施肥，向第二棵树施 $4$ 单位的肥，使其高度变成 $972$，剩余 $1$ 单位的化肥。
+ 这时候，三棵树的宽度分别为 $16, 18, 8$，所能覆盖的距离为 $2304$，为最优解。

---

**【样例 2】**

见附件下的 $\texttt{plant/plant2.in}$ 与 $\texttt{plant/plant2.ans}$。

---

**【样例 3】**

见附件下的 $\texttt{plant/plant3.in}$ 与 $\texttt{plant/plant3.ans}$。

---

**【数据范围】**

| 测试点编号 | $n \leq$ | $p_i$ | $w$ | 单点分值 |
| :--------: | :------: | :---: | :---: | :------: |
| $1 \sim 5$ | $10^4$ | $=1$ | $=1$ | $1$ |
| $6 \sim 10$ | $10^4$ | $\leq 10^4$ | $=1$ | $3$ |
| $11 \sim 15$ | $1$ | $\leq 10^4$ | $\leq 10^4$ | $3$ |
| $16 \sim 20$ | $5$ | $\leq 10^4$ | $\leq 10^4$ | $6$ |
| $21 \sim 25$ | $10^4$ | $\leq 10^4$ | $\leq 10^4$ | $7$ |

对于 $100 \%$ 的数据，保证 $1 \leq n \leq 10^4$，$1 \leq p_i \leq 10^4$，$1 \leq w \leq 10^4$。

## 样例 #1

### 输入

```
3 60
8 243 250```

### 输出

```
2304```

# AI分析结果



## 综合分析与结论

### 核心思路与贪心策略
1. **质因数分解**：将原树高度和化肥w分解质因数，转化为独立质因数的分配问题。
2. **贪心分配**：对每个质因数p，统计其在各树中的次数，每次将p分配到当前次数最小的树上。
3. **数学基础**：因数个数乘积的增量与次数分配策略的数学关系证明贪心的正确性。

### 解决难点
- **质因数独立性**：各质因数的贡献独立，需分别处理。
- **高效维护最小值**：使用优先队列/堆快速找到当前最小次数，时间复杂度优化至O(n log n) per质因数。

### 可视化设计思路
- **动画方案**：对每个质因数p，展示各树当前次数，用颜色标记最小项，高亮当前分配操作。
- **复古像素风格**：树表示为像素块，质因数用不同颜色区分，施肥时播放8-bit音效。
- **交互控制**：支持步进、暂停，对比不同分配策略的优劣。

---

## 题解评分（≥4星）

### 樱雪喵（5星）
- **亮点**：代码结构清晰，优先队列实现高效，模块化处理质因数分解与分配。
- **代码可读性**：使用STL优先队列，分解与计算分离，逻辑直观。
- **核心代码**：
  ```cpp
  priority_queue<int, vector<int>, greater<int>> q;
  while(sum) {
      int x=q.top(); q.pop();
      q.push(x+1),sum--;
  }
  ```

### 佬头（4.5星）
- **亮点**：多优先队列独立处理质因数，优化空间利用。
- **实现细节**：为每个质数维护独立堆，避免全局排序开销。

### Crsuh2er0（4星）
- **亮点**：直接数学推导贪心策略，清晰展示增量比计算。
- **代码简练**：线性扫描找最小值，适合小数据范围。

---

## 最优思路提炼

### 关键技巧
1. **独立质因数处理**：将w分解后，每个质因数独立分配，互不影响。
2. **堆优化选择**：使用优先队列维护各树当前质因数次数，保证O(1)取最小。
3. **因数乘积计算**：分解后各质因数贡献相乘，避免中间结果溢出。

### 数学证明
- 对于质因数p，若当前次数为k，增加1次带来的乘积增益为`(k+2)/(k+1)`，显然k越小增益越大。

---

## 同类型题目推荐
1. **P1226 分解因数**：分解质因数与因数个数计算。
2. **P1495 曹冲养猪**：资源分配与模数优化。
3. **P1896 [SCOI2005]互不侵犯**：贪心策略在状态分配中的应用。

---

## 可视化算法演示（核心代码）

### 贪心过程动画逻辑
```javascript
// 伪代码：质因数p的分配动画
function animateAllocation(p, counts) {
    let heap = new PriorityQueue(counts);
    while (w_p > 0) {
        let minNode = heap.pop();
        minNode.count++;
        highlightTree(minNode.index);
        playSound('select');
        heap.push(minNode);
        w_p--;
        updateProductDisplay();
    }
}
```

### 复古像素风格CSS片段
```css
.tree-block {
    width: 16px;
    height: 16px;
    background: #8bc34a;
    border: 1px solid #4caf50;
}
.highlight {
    background: #ffeb3b;
    animation: pulse 0.5s;
}
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}
```

---

## 个人心得摘录
- **樱雪喵**：注意分解后的剩余质数处理（如样例1的250分解后剩余的因子）。
- **EmptyAlien**：线性扫描在大数据下可能TLE，优先队列更优。
- **sbno333**：未初始化质因数计数导致错误，需预插入0次数的树。

---

## 核心贪心代码实现（樱雪喵）
```cpp
void solve(int x, int sum) {
    priority_queue<int, vector<int>, greater<int>> q;
    for (int i=1; i<=n; i++) {
        int cnt=0;
        while (a[i]%x ==0) cnt++, a[i]/=x;
        q.push(cnt+1); // 初始宽度为cnt+1
    }
    while (sum--) {
        int cur = q.top(); q.pop();
        q.push(cur +1); // 贪心增加最小项
    }
    while (!q.empty()) {
        ans = ans * q.top() % mod;
        q.pop();
    }
}
```

---
处理用时：77.47秒
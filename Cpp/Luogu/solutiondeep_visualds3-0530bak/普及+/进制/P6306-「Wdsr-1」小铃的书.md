# 题目信息

# 「Wdsr-1」小铃的书

## 题目背景

本居小铃在人间之里经营着一家名为“铃奈庵”的书店。店里井井有条地堆放着很多很多书。  

一天，魔理沙来铃奈庵借书，搞得店里十分混乱，魔理沙随身携带的魔导书与铃奈庵的书籍全都混在了一起。

## 题目描述

小铃一共有 $n-1$ 本书，每本书有一个编号 $a_i$，两本书属于同一种类当且仅当两本书的编号相同。  

由于小铃平时将这些书整理得井井有条，因此在小铃的 $n-1$ 本书中，每个种类的书的数量都恰好是 $k$ 的倍数，其中 $k$ 是一给出的常数。
 
现在，魔理沙的一本编号未知的魔导书与小铃的 $n-1$ 本书混在了一起，而魔理沙只有知道魔导书的编号才能将其找回。  

由于书的数量实在太多，魔理沙找到了你来帮忙，希望聪明的你能帮她求出混入的魔导书的编号。

**注意：魔理沙的魔导书可能与小铃的某本书有着相同的编号。**

## 说明/提示

#### 样例说明

样例 $1$ 中，小铃的书的编号为 $1,2,3$，分别有 $3$ 本。因此魔导书的编号为 $5$。

样例 $2$ 中，小铃的书的编号为 $1,4,5$，分别有 $4$ 本。因此魔导书的编号为 $1$。

------------------------

#### 数据范围及约定

**本题采取捆绑测试。**

$$
\def{\arraystretch}{1.5}
\def\cuteran{https://www.luogu.com.cn/paste/iyzwht7l}
\begin{array}{|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{分值} \cr\hline
1 & 10^5 & 50 \cr\hline
2 & 10^6 & 25 \cr\hline
3 & 10^7 & 25 \cr\hline
\end{array}
$$

对于全部数据，保证 $1 \le n \le 10^7$  ，$2 \le k \le 10^3$  ，$1 \le a_i \le 10^{18}$。保证数据合法，即有且只有一本混入的魔导书。   

-----------------

#### 提示

**请注意时空限制。**

**使用 $\texttt{cin}$ / $\texttt{cout}$ 可能超时，这里给出一个快速读入模板：**

```cpp
long long qread(){
    long long w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
```

**或者使用这份模板：**

```cpp
typedef long long LL;
#define gc pa==pb&&(pb=(pa=buf)+fread(buf,1,100000,stdin),pa==pb)?EOF:*pa++
static char buf[100000],*pa(buf),*pb(buf);
inline LL readint() {
	LL x=0;char c=gc;
	while(c<'0'||c>'9')c=gc;
	for(;c>='0'&&c<='9';c=gc)x=x*10+(c&15);
	return x;
}
```

**其中，在开启 O2 开关的前提下，前者在极限数据下的读入要 $500\texttt{ms}$，而后者需要 $300\texttt{ms}$。也就是说，你的程序至少有 $500\sim 700\texttt{ms}$ 的时间执行主要算法。**

## 样例 #1

### 输入

```
10 3
1 1 2 2 3 5 3 2 1 3```

### 输出

```
5```

## 样例 #2

### 输入

```
13 4
1 1 4 5 1 4 1 4 4 5 5 5 1```

### 输出

```
1```

# AI分析结果



## 算法分类
位运算、分块统计

---

## 题解思路与核心算法分析

### 核心问题模型
在 $n$ 个数中，有且仅有一个数出现次数模 $k$ 余 1，其余数出现次数均为 $k$ 的倍数。要求高效找出这个数。

### 核心算法流程
**分块位运算统计法**（以 16-bit 分块为例）：
1. **分块处理**：将每个数拆分为多个固定位宽的块（如每块 16 位）
2. **计数统计**：对每个块的位置建立计数器，统计该位置所有数值的出现次数
3. **模运算过滤**：对每个块的计数器取模 $k$，余数为 1 的数值即为目标数在该块的片段
4. **组合结果**：将所有块的余数片段组合为最终答案

---

## 题解评分（≥4星）

### 1. wyd_forever 题解（5星）
- **亮点**：采用 8-bit 分块，代码简洁高效，空间复杂度 $O(4×256)$
- **核心代码**：
  ```cpp
  for(register ll x;n;--n) {
      x=read();
      for(int i=0;i<4;++i) 
          ++a[i][(x>>(i*8))&255];
  }
  ```

### 2. minstdfx 题解（4.5星）
- **亮点**：16-bit 分块实现，使用位掩码优化取块操作
- **关键优化**：
  ```cpp
  geshu[i][65535&g]++;  // 取低16位
  g >>= 16;            // 处理下一块
  ```

### 3. 朱屹帆 题解（4星）
- **特色**：十进制分块便于理解，但效率略低于二进制分块
- **教学价值**：直观展示分块思想，适合算法初学者

---

## 最优思路与技巧提炼

### 关键技巧
1. **分块降维**：将高精度数分解为多个低位块，降低处理复杂度
   ```python
   # 示例：将数分解为4个8-bit块
   blocks = [ (num >> (i*8)) & 0xFF for i in 0..3 ]
   ```
2. **并行计数**：为每个块位置维护独立计数器数组
3. **模运算定位**：利用模运算特性快速定位异常值
4. **位运算加速**：使用移位和位掩码代替除法/取模运算

### 思维突破点
- **逆向思考**：不直接统计完整数值，而是通过分块特征反推结果
- **空间换时间**：牺牲少量内存换取线性时间复杂度

---

## 同类题型推荐
1. [P1469 找筷子](https://www.luogu.com.cn/problem/P1469)（异或特性应用）
2. [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)（分块思想应用）
3. [P1494 小Z的袜子](https://www.luogu.com.cn/problem/P1494)（模运算统计）

---

## 可视化设计（像素风格演示）

### 动画要素
1. **分块展示**：用不同颜色方块表示数的各个分块
   ```javascript
   // 示例：用4个色块表示32位数
   const colors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00];
   ```
2. **计数增长**：每个分块数值对应像素格亮度随计数增加
3. **模运算闪烁**：当某块计数模k余1时，对应像素格闪烁红光
4. **音效反馈**：
   - 分块处理：8-bit "哔"声
   - 找到结果：经典FC过关音效

### 交互设计
- **速度调节**：滑块控制处理速度（1x-100x）
- **分块模式**：可选8/16/32位分块对比效果
- **自动演示**：AI自动运行并解说关键步骤

---

## 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long LL;

const int BIT_WIDTH = 16;
const int BLOCKS = 4;
const int MASK = (1 << BIT_WIDTH) - 1;

int cnt[BLOCKS][1 << BIT_WIDTH];
LL ans;

int main() {
    int n, k;
    scanf("%d%d", &n, &k);
    
    while(n--) {
        LL x;
        x = read(); // 使用快速读入
        for(int i = 0; i < BLOCKS; ++i) {
            int val = x & MASK;
            cnt[i][val]++;
            x >>= BIT_WIDTH;
        }
    }

    for(int i = 0; i < BLOCKS; ++i) {
        for(int j = 0; j <= MASK; ++j) {
            if(cnt[i][j] % k == 1) {
                ans |= (LL)j << (i * BIT_WIDTH);
                break;
            }
        }
    }
    printf("%llu\n", ans);
    return 0;
}
```

---

## 思维导图
```
问题建模
├─ 已知条件
│  ├─ n-1本书每类数量为k倍数
│  └─ 混入1本打破规律
├─ 核心转化
│  └─ 找出现次数 ≡1 mod k 的数
└─ 解法维度
   ├─ 暴力法（MLE/TLE）
   └─ 分块位运算法（最优）
       ├─ 分块策略
       │  ├─ 二进制分块（8/16/32位）
       │  └─ 十进制分块
       └─ 统计优化
           ├─ 并行计数数组
           └─ 模运算过滤
```

---
处理用时：69.47秒
# 题目信息

# 「TAOI-1」Apollo

## 题目背景

Execution.

这题原来叫 `std::cout << std::fixed << std::setprecision(1) << 6.5 << '\n';`。

[被当事人删掉的图片.jpg]

**【Upd 2023/04/15 21:42】添加了一组 Hack 数据位于 Subtask 2，#13。现在所有赛时的 $\bm{50}$ 分提交理论上均只能获得 $\bm{30}$ 分。**

## 题目描述

给出 $n$ 个十进制小数 $a_1 \dots a_n$。

对于一个 **数** $a$，定义其精度 $f(a)$ 表示最小的非负整数 $k$ 使得 $10^k\times a$ 为整数；对于整数 $a$，定义 $f(a) = 0$。对于两个十进制小数 $a, b$，定义 $g(a, b)$ 为对于所有 **数** $c \in [\min(a,b), \max(a,b)]$ 的 $f(c)$ 的最小值。

对于所有 $1 \leq i \leq n$，你需要求出 $\sum\limits_{j=1}^ng(a_i, a_j)$ 的值并输出。

定义十进制小数是一个含有整数部分和小数部分的数，其小数部分不为 $0$。之所以描述得这么愚蠢是因为保证输入的每个数都有小数点，但是好像无论什么写法都会有人提出不满，真是抱歉了。~~所以还是得看看被当事人删掉的图片。所以我在这里写闲话有人看得到吗。~~

## 说明/提示

### 数据范围

**本题采用捆绑测试。**

令 $\sum\limits_{i=1}^n f(a_i) = t$。

- Subtask 1（15 points）：$a_i \leq 10$，$n \leq 5$，$t \leq 10$。
- Subtask 2（15 points）：$a_i \leq 10$，$n \leq 100$，$t \leq 1000$。
- Subtask 3（20 points）：$n \leq 1722$。
- Subtask 4（15 points）：$a_i \leq 1$。
- Subtask 5（35 points）：无特殊限制。

对于所有数据，$0 \lt a_i \lt 10^9$，$1 \leq n \leq 10^5$，$1 \leq t \leq 3 \times 10^6$，**保证 $\bm{a_i}$ 没有后导 [$\color{black}\bm 0$](https://cdn.luogu.com.cn/upload/image_hosting/pg66fm1z.png)，不保证 $\bm{a_i}$ 互不相同**。

### 样例解释

以 $i = 1$ 为例：

+ $j = 1$：取 $c = 11.4514$，$f(c) = 4$；
+ $j = 2$：取 $c = 11.46$，$f(c) = 2$；
+ $j = 3$：取 $c = 11.2$，$f(c) = 1$；
+ $j = 4$：取 $c = 11.3$，$f(c) = 1$；
+ $j = 5$：取 $c = 11.47$，$f(c) = 2$。

故 $\sum\limits_{j=1}^n g(a_1, a_j) = 4 + 2 + 1 + 1 + 2 = 10$。对于同一个 $j$，上文给出的所有 $c$，都可能有其它的不同的 $c$ 满足 $f(c)$ 同样最小。

## 样例 #1

### 输入

```
5
11.4514
11.4778
11.1338
11.1236
11.4789```

### 输出

```
10
11
9
9
11```

## 样例 #2

### 输入

```
8
1.1145
1.114
1.1145
1.514
1.19198
1.1154
1.114
1.1145```

### 输出

```
24
21
24
10
18
22
21
24```

# AI分析结果



## 算法分类
**字典树（Trie）**

---

## 综合分析与结论
### 核心思路
- **问题转化**：当两个数的整数部分相同时，`g(a_i, a_j)`的值等于其小数部分的最长公共前缀长度。通过将小数部分视为字符串，问题转化为求字符串间的最长公共前缀。
- **字典树核心**：构建以小数部分字符为节点的字典树，每个节点记录经过次数、结尾次数、深度等信息。插入时动态构建树，查询时统计分叉点的贡献。
- **贡献计算**：在查询过程中，遍历字典树路径，累加分叉点的贡献（分叉点的深度 × 分叉点其他子树的节点数）。

### 解决难点
- **整数部分处理**：将整数部分相同的数分组，每组单独构建字典树。
- **分叉点贡献统计**：通过节点的 `num`（经过次数）和 `end`（结尾次数）动态计算不同分支的贡献。
- **前缀包含情况**：处理较短数是较长数前缀的情况（如 `11.123` 和 `11.123456`），此时贡献为较短数的小数位数。

### 可视化设计
- **动态字典树构建**：在 Canvas 上绘制字典树，插入节点时动态添加分支，用不同颜色区分不同字符。
- **查询高亮路径**：遍历查询路径时，高亮当前节点，并显示分叉点的贡献计算（如显示 `贡献 = 深度 × 分叉节点数`）。
- **复古像素风格**：
  - **颜色方案**：使用 8 位色（如深绿表示路径，红色表示分叉点）。
  - **音效触发**：插入节点时播放“滴”声，分叉时播放“咔嚓”声。
  - **自动演示**：模拟插入和查询过程，允许调整速度或单步执行。

---

## 题解评分（≥4星）
### 1. 作者：wloving（★★★★★）
- **亮点**：完整解析字典树构建与贡献计算，代码清晰，插入和查询逻辑分离。
- **关键代码**：
  ```cpp
  void insert(string s) {
      int u = 0, dot = -1;
      for (int i = 0; i < s.size(); i++) {
          int ch = toNum[s[i]];
          if (!trie[u].son[ch]) trie[u].son[ch] = ++tot;
          u = trie[u].son[ch];
          if (ch == 10) dot = i; // 记录小数点位置
          trie[u].dep = i - dot; // 更新小数位数
      }
      trie[u].end++;
  }
  ```

### 2. 作者：Lysea（★★★★☆）
- **亮点**：代码简洁，直接通过 `dep` 变量记录小数位数，查询时动态累加。
- **关键代码**：
  ```cpp
  for (int i = b + 1; i < x.size(); i++) {
      c = x[i] - '0', dep++;
      ans += dep * (cnt[p] - cnt[t[p][c]] - en[p] + en[t[p][c]]);
      p = t[p][c];
  }
  ```

### 3. 作者：gyyyyx（★★★★☆）
- **亮点**：分组处理整数部分，利用 `map` 管理不同字典树，避免整数部分干扰。
- **关键代码**：
  ```cpp
  sort(floor.begin(), floor.end()); // 按整数部分排序
  for (int l = 0, r = 0; l < N; l = ++r) {
      while (r < N - 1 && floor[r + 1].first == floor[l].first) ++r;
      Solve(lst, r); // 处理同一整数部分的数
  }
  ```

---

## 最优思路提炼
### 关键技巧
1. **字典树构建**：将小数部分作为字符串插入字典树，节点记录 `dep`（当前字符的小数位数）。
2. **贡献动态计算**：查询时，每遇到分叉点，累加 `贡献 = 当前深度 × （父节点数 - 当前子树数）`。
3. **整数部分分组**：对整数部分相同的数单独处理，避免跨组计算。

---

## 类似题目推荐
1. **P2580 他**：统计字符串出现次数（字典树模板题）。
2. **P8306 【模板】字典树**：求字符串间最长公共前缀。
3. **P2922 [USACO]Secret Message**：统计前缀匹配的字符串数量。

---

## 个人心得摘录
> “字典树的节点设计是关键，`dep` 变量直接记录小数位数，避免了后续计算的复杂性。” —— wloving  
> “将整数部分分组处理，减少无效计算，是优化时间复杂度的核心。” —— gyyyyx

---

## 核心算法可视化
### 动画设计
- **插入过程**：
  1. 输入 `11.4514`，拆分为整数部分 `11` 和小数部分 `4514`。
  2. 在字典树中插入 `4→5→1→4`，每个节点显示 `num`（经过次数）和 `dep`（小数位数）。
- **查询过程**：
  1. 输入 `11.4514`，遍历字典树路径 `4→5→1→4`。
  2. 在分叉点（如 `4→5` 后插入 `7`），高亮该节点，显示贡献计算：`深度=2 × 分叉数=1 → 贡献=2`。

### 复古风格实现
- **Canvas 绘制**：用网格表示字典树，节点用 16×16 像素方块，路径用绿色线条连接。
- **音效**：插入节点时播放短促“哔”声，分叉时播放“咔嚓”声。
- **自动演示**：按步骤展示插入和查询，速度可调，支持暂停/继续。

---
处理用时：74.09秒
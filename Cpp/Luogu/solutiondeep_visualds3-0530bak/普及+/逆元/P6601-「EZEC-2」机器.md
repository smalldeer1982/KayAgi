# 题目信息

# 「EZEC-2」机器

## 题目背景

tlx 喜欢科幻小说。   

>小宇宙中只剩下漂流瓶和生态球。漂流瓶隐没于黑暗里,在一千米见方的宇宙中,只有生态球里的小太阳发出一点光芒。在这个小小的生命世界中,几只清澈的水球在零重力环境中静静地飘浮着,有一条小鱼从一只水球中蹦出,跃入另一只水球,轻盈地穿游于绿藻之间。在一小块陆地上的草丛中,有一滴露珠从一片草叶上脱离,旋转着飘起,向太空中折射出一缕晶莹的阳光。    
>$\qquad \qquad \qquad \qquad \qquad \qquad \qquad\qquad\qquad\qquad\qquad\qquad\qquad --$《三体》    

在另一个宇宙，将是另一番奇景吧。    

在那里，重力似乎变得微不足道了，引力机器成了司空见惯的东西。

引力机器装置内并没有重力，即若有物体在机器上运动，运动过程中只受机器给予的引力，这个力有一定几率使物体向施力物体快速移动，达到一定动力时就可以实现瞬移。



## 题目描述

一个引力机器由一个光滑圆轨道和 $2n$ 个小孔组成（小孔按**逆时针**从 $1$ 到 $2n$ 编号，每两个相邻的小孔所夹的**劣弧**度数为 $\dfrac{\pi}{n}$ ），每个小孔与和其夹角为 $\pi$ 的另一个小孔有通道相连，比如当 $n=2$ 时，$1$ 号孔和 $3$ 号孔相连。

当 $n=2$ 时，这个装置的构造大概是这样的：
 
 ![](https://cdn.luogu.com.cn/upload/image_hosting/el8alxde.png) 
 
现在我们在 $1$ 号孔处放一个小球，使它一直**沿逆时针方向做匀速圆周运动**，在不瞬移的情况下，每一秒恰好能从一个小孔运动至下一个小孔。

由于未来实验室构造奇特（内部的引力提供装置太神了！），每经过一个小孔时，有 $p$ 的概率**立刻瞬移**（即不花费时间）到通道对面的小孔并继续沿逆时针方向做匀速圆周运动，也就是有 $1-p$ 的概率继续沿圆周向下一个小孔运动。

值得注意的是，**每一单位时刻，小球只能瞬移一次**。  

简单地说，若某一时刻小球在小孔 $i$，则下一时刻它可能运动到小孔 $i \bmod 2n + 1$ 或 $(i + n) \bmod 2n + 1$，概率分别为 $1-p$ 和 $p$。

现在 tlx 有两个一模一样的引力机器，两个小球同时从 $1$ 号孔开始运动。他会**随机**（所有可能选择的概率相同）选择一个二元组 $(i,j)( 1\leqslant i\leqslant 2n,0\leqslant j\leqslant t,i,j\in \mathbb Z$ ) 分别代表小孔编号和时间，你需要求出时间为 $j$ 时两个引力机器的小孔 $i$ **同时**有小球**停留（运动经过小孔但瞬移到对面了不算停留）** 的概率。

注意：**小球刚开始运动时也可能瞬移到对面的小孔。**   

为方便计算，我们规定：所有概率都是在模 $10^9+7$ 意义下的。      

## 说明/提示

**【数据范围与约定】** 

**本题采用捆绑测试。**    

具体计分方式如下：   

- Subtask $1$ ($7$ points)：满足 $p\in \{0,1\}$；  
- Subtask $2$ ($13$ points)：满足 $t\leqslant 20,n\leqslant50$；  
- Subtask $3$ ($20$ points)：满足 $t\leqslant 10^3,n\leqslant50$；  
- Subtask $4$ ($10$ points)：满足 $t\leqslant 10^3$；  
- Subtask $5$ ($10$ points)：满足 $t\leqslant 10^6$；
- Subtask $6$ ($15$ points)：满足 $n\leqslant50$；
- Subtask $7$ ($25$ points)：无特殊限制。


对于 $100\%$ 的数据，满足 $2\leqslant n\leqslant 500$，$0\leqslant p\leqslant 10^9+6$，$0\leqslant t \leqslant 10^9$。  

**注意：不做说明的数据范围即为极限数据范围。**

**【样例解释 #1】**  

$500000004$ 是模 $10^9+7$ 意义下的 $\dfrac{1}{2}$。 

下面为了方便，记 $P(i,j)$ 为选择的二元组为 $(i,j)$ 时的概率。    

所有概率不为 $0$ 的二元组有：   
$P(1,0)=\dfrac{1}{4},P(3,0)=\dfrac{1}{4},P(2,1)=\dfrac{1}{4},P(4,1)=\dfrac{1}{4}$。    

所有可以选择的二元组有：   
$(1,0),(1,1),(2,0),(2,1),(3,0),(3,1),(4,0),(4,1)$，共 $8$ 种。    

所以总的概率：  
$$P=\dfrac{1}{8}×\dfrac{1}{4}×4+\dfrac{1}{8}×0×4=\dfrac{1}{8}$$

在模 $10^9+7$ 意义下为 $125000001$，即为输出的答案。

------------

**【其他提示】**

1. 如果你不了解分数取模，可以查看[这里](https://www.luogu.com.cn/problem/P2613)。  

2. 如果你不明白题目中角度的表示方法，可以查看[弧度制](https://baike.baidu.com/item/弧度制/3315973?fr=aladdin)。



## 样例 #1

### 输入

```
2 500000004 1```

### 输出

```
125000001```

## 样例 #2

### 输入

```
6 114514 11```

### 输出

```
756497239```

# AI分析结果



## 算法分类
**动态规划与矩阵快速幂**（结合概率模型与数学推导）

---

## 题解分析与结论

### 核心思路与难点对比
1. **数学推导（NaCly_Fish/JohnVictor）**  
   - **关键观察**：两球位置相同当且仅当瞬移次数奇偶性相同。  
   - **数学工具**：利用二项式定理与生成函数，将概率求和转化为等比数列形式。  
   - **解决难点**：直接处理时间指数级增长的问题，通过巧妙的数学变换将复杂度降至 O(log t)。  

2. **概率DP+矩阵快速幂（hanzhongtlx/君のNOIP）**  
   - **状态建模**：每个时刻小球仅可能出现在两个对称位置，构造 f_i 和 g_i 表示两种状态概率。  
   - **矩阵优化**：将状态转移方程转换为矩阵乘法，利用快速幂高效计算总和。  
   - **解决难点**：处理动态规划中状态转移的循环依赖，通过矩阵乘法统一处理线性递推关系。  

### 精炼结论
- **最优解法**：数学推导法（O(log t) 时间复杂度），适用于所有数据范围且代码简洁。  
- **核心技巧**：奇偶性条件与二项式生成函数简化概率计算，直接导出等比数列求和式。  

---

## 题解评分
### ⭐⭐⭐⭐⭐ NaCly_Fish  
- **亮点**：数学推导简洁优雅，代码量极小，复杂度最优。  
- **代码**：仅需处理快速幂与逆元，适合竞赛快速实现。  

### ⭐⭐⭐⭐ 君のNOIP  
- **亮点**：分步骤处理不同数据范围，矩阵构造详细，适合教学。  
- **不足**：代码稍冗长，但注释清晰。  

### ⭐⭐⭐⭐ hanzhongtlx  
- **亮点**：深入分析状态转移关系，矩阵构造逻辑清晰。  
- **不足**：推导过程较复杂，对数学基础要求较高。  

---

## 最优思路与代码实现
### 关键代码（NaCly_Fish 思路）
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 1e9+7;

ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    ll n, p, t;
    cin >> n >> p >> t;
    ll q = (1 - 2 * p % MOD) % MOD; // (1-2p) mod MOD
    ll q_sq = q * q % MOD;          // (1-2p)^2
    ll numerator = (qpow(q_sq, t+1) - 1) % MOD;
    ll denominator = (q_sq - 1) % MOD;
    ll sum = numerator * qpow(denominator, MOD-2) % MOD;
    ll ans = (1 + sum) % MOD * qpow(2, MOD-2) % MOD;
    ans = ans * qpow(2*n, MOD-2) % MOD * qpow(t+1, MOD-2) % MOD;
    cout << (ans + MOD) % MOD;
}
```

### 实现思想
1. **数学变换**：  
   - 计算 `(1-2p)` 的平方项 `q_sq`，构造等比数列公比。  
   - 使用快速幂计算等比数列和 `sum`，并通过逆元处理分母。  
2. **模运算处理**：  
   - 所有中间结果保持模 `1e9+7`，避免溢出。  
   - 最终结果通过逆元转换分数为整数模形式。  

---

## 相似题目推荐
1. **P1939 矩阵加速（数列）** - 矩阵快速幂模板题  
2. **P2523 概率计算器** - 概率模型与快速幂结合  
3. **P5175 数列** - 递推数列的快速幂优化  

---

## 可视化设计
### 动画演示方案
- **像素风格轨迹**：  
  1. 使用 Canvas 绘制圆形轨道，16色像素风格。  
  2. 小球以 8-bit 音效瞬移时，显示红色闪光；正常移动时显示蓝色轨迹。  
  3. **状态面板**：实时显示当前时刻、两球位置及总概率值。  

- **AI自动模式**：  
  1. 按时间步自动推进，展示每个时刻概率变化。  
  2. 关键步骤（如瞬移触发）时暂停，辅以文字说明。  

- **音效设计**：  
  - `瞬移音效`：短促“哔”声（方波生成）。  
  - `正确匹配`：上升音阶提示。  

---

## 个人心得
1. **数学直觉优先**：在竞赛中，发现奇偶性条件可极大简化问题。  
2. **模运算陷阱**：处理负数时需频繁加 MOD 再取模，避免错误。  
3. **快速幂泛用性**：不仅用于普通幂计算，还可推广到矩阵与生成函数场景。

---
处理用时：79.34秒
# 题目信息

# [RC-03] 随机树生成器

## 题目描述

小 R 有一个随机树生成器，其工作原理如下：
- 输入 $n$，则对于每个 $1<i\le n$，随机选择一个 $[1,i)$ 中的节点作为其父亲。返回这棵树。

给定 $n,k$，小 R 想知道可能生成的所有 $n$ 个点的树中，$k$ 号点的度数和。

由于答案可能很大，请输出答案模 $10^9+9$ 的值。

## 说明/提示

【样例说明】

- 数据 $1$：一共有两种情况，$1$ 号点的度数分别为 $1,2$。因此答案为 $3$。
- 数据 $2$：一共有两种情况，$2$ 号点的度数分别为 $1,2$。因此答案为 $3$。
- 数据 $3$：一共有两种情况，$3$ 号点的度数均为 $1$。因此答案为 $2$。

【数据范围】

本题捆绑测试。

对于 $100\%$ 的数据，$1\le T\le 10^5$，$1\le k\le n\le 10^7$。详细数据范围如下。

- Subtask 1（20 分）：$T\le 50$，$n\le 8$。
- Subtask 2（55 分）：$T=1$，$n\le 10^5$。
- Subtask 3（20 分）：$T=1$。
- Subtask 4（5 分）：没有任何附加限制。

## 样例 #1

### 输入

```
3
3 1
3 2
3 3```

### 输出

```
3
3
2```

# AI分析结果



# P6862 [RC-03] 随机树生成器 题解分析

**唯一算法分类**：组合数学 + 预处理优化

---

## 综合分析与结论

### 核心思路
所有可能的树数量为 $(n-1)!$，每个节点 $k$ 的度数由两部分组成：
1. **父亲贡献**：当 $k \neq 1$ 时，必然存在一个父亲节点，贡献 $(n-1)!$ 次度数。
2. **儿子贡献**：每个节点 $i > k$ 有 $\frac{1}{i-1}$ 的概率成为 $k$ 的儿子，总贡献为 $(n-1)! \times \sum_{i=k}^{n-1} \frac{1}{i}$。

通过线性预处理阶乘、逆元及逆元前缀和，可 $O(1)$ 响应多组查询。

### 解决难点
1. **概率求和优化**：将 $\sum_{i=k+1}^n \frac{1}{i-1}$ 转化为逆元前缀和的差分形式。
2. **大规模预处理**：对 $10^7$ 规模的逆元进行线性预处理，避免快速幂计算超时。
3. **模运算处理**：处理负数取模和阶乘溢出的细节。

---

## 题解清单（≥4星）

### 1. 作者：一只书虫仔（⭐⭐⭐⭐⭐）
- **亮点**：公式推导清晰，代码结构简洁，通过前缀和差分高效处理区间逆元求和。
- **核心代码**：
  ```cpp
  int ee = (inv[n-1] - inv[k-1] + mod) % mod;
  ans = (1ll * fac[n-1] * ee + (k!=1) * fac[n-1]) % mod;
  ```

### 2. 作者：Mine_King（⭐⭐⭐⭐）
- **亮点**：数学符号规范，分步解释贡献来源，强调前缀和的线性预处理。
- **关键公式**：
  $$
  \text{答案} = (n-1)! \times \left( \sum_{i=k}^{n-1} \frac{1}{i} + [k \neq 1] \right)
  $$

### 3. 作者：Little09（⭐⭐⭐⭐）
- **亮点**：代码实现高效，直接处理逆元前缀和，适合大规模数据。
- **代码片段**：
  ```cpp
  u = (inv[n-1] - inv[k-1] + mod) % mod;
  u = (u * jc[n-1]) % mod;
  ```

---

## 最优思路与技巧提炼

### 核心公式
$$
\text{答案} = (n-1)! \times \left( S_{n-1} - S_{k-1} + [k \neq 1] \right) \mod (10^9+9)
$$
其中 $S_i$ 为逆元前缀和：$S_i = \sum_{j=1}^i \frac{1}{j}$。

### 关键步骤
1. **预处理阶乘**：`fac[i] = i! mod (1e9+9)`。
2. **线性求逆元**：利用递推公式 `inv[i] = (mod - mod/i) * inv[mod%i] % mod`。
3. **前缀和优化**：`sum[i] = sum[i-1] + inv[i]`。

---

## 同类型题与算法套路

### 相似题目
- **P3811 【模板】乘法逆元**：线性求逆元的模板题。
- **P2633 Count on a tree**：树上统计问题，结合前缀和与LCA。
- **P2480 [SDOI2010]古代猪文**：组合数学与逆元的综合应用。

### 通用解法
- **预处理优化**：对于多组查询问题，预处理阶乘、逆元等常用值。
- **概率求和转前缀和**：将概率或分数求和问题转化为前缀和差分。

---

## 可视化与算法演示

### 动画设计
1. **像素风格树生成**：
   - **节点连接动画**：用不同颜色标记k号节点及其父/子节点。
   - **概率展示**：当新节点i加入时，显示其选择k作为父亲的概率（1/(i-1)）。
2. **数据面板**：
   - 实时显示阶乘`fac[i]`、逆元`inv[i]`和前缀和`sum[i]`的值。
3. **音效与反馈**：
   - **连接成功**：播放短促的8位音效。
   - **错误提示**：当k=1时，播放低音提示无父节点。

### 交互控制
- **步进执行**：单步查看每个节点加入时的贡献计算。
- **参数调节**：允许用户输入n和k，观察不同情况下的度数变化。

---

## 代码实现（核心部分）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+5, mod=1e9+9;
int fac[N], inv[N], sum[N];

void init() {
    fac[0] = inv[1] = 1;
    for(int i=1; i<N; ++i) fac[i] = 1LL * fac[i-1] * i % mod;
    for(int i=2; i<N; ++i) inv[i] = 1LL * (mod - mod/i) * inv[mod%i] % mod;
    for(int i=1; i<N; ++i) sum[i] = (sum[i-1] + inv[i]) % mod;
}

int query(int n, int k) {
    if(n == 1) return 0;
    int ans = 1LL * fac[n-1] * (sum[n-1] - sum[k-1] + mod) % mod;
    if(k != 1) ans = (ans + fac[n-1]) % mod;
    return ans;
}
```

---
处理用时：71.82秒
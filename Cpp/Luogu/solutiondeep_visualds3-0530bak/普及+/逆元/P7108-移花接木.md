# 题目信息

# 移花接木

## 题目背景


遥远的圣地生长着一棵不为人知的灵树，或有万山之高。

但有一日，藏匿于根系的腐朽力量爆发，灵树已无法支撑往日屹立冲天的高度。

## 题目描述

灵树最初的形态可以看作一棵高度为 ${10}^{{10}^{{10}^{10}}}$ 的满 $a$ 叉树，高度定义为根结点到叶子结点之间的边数。

受腐朽力量影响，灵树只能维持高度**恰好**为 $h$ 的满 $b$ 叉树形态。为了转换至该形态，灵树有两种魔法：

- 移花：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点），移除这条边以及以 $v$ 为根的**整棵子树**。
- 接木：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点）和一个结点 $w$（$w$ 不能是 $v$ 子树中或已移除的结点），将这条边原先 $u$ 一端**改接**到 $w$。**该魔法只能在根结点到** $\boldsymbol{u}$ **之间的边数** $\le 10^{10^{10}}$ **时使用。**

灵树累积的魔法力量有限，它不得不用最少次数的魔法完成转换。这是个漫长的过程，即使次数最少也会显得异常大，你只需要求出最少次数对 $10^9 + 7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**

下为 $a=1$，$b=2$，$h=1$ 时的两步转换过程，图中高度极大的冗余子树已用省略号代替。

![](https://cdn.luogu.com.cn/upload/image_hosting/p32s9v96.png)

可以证明，该数据的答案不可能低于 $2$。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (3 points)：$h = 0$。
- Subtask #2 (4 points)：$a = b$。
- Subtask #3 (8 points)：$a = 1$。
- Subtask #4 (8 points)：$b = 1$。
- Subtask #5 (17 points)：$h \le 10$。
- Subtask #6 (15 points)：$h \le 10^6$，各测试点存在 $\overline{a},\overline{b}$，其数据满足 $a=\overline{a}$，$b=\overline{b}$。
- Subtask #7 (15 points)：$h \le 10^6$。
- Subtask #8 (30 points)：无特殊限制。

所有测试点（样例除外）均含有 $10^6$ 组数据，即 $T = 10^6$。请务必采用较快的 IO（输入/输出）方式。

对于所有的数据，保证 $1 \le a,b \le 10^9$，$0 \le h \le 10^9$。

## 样例 #1

### 输入

```
2
1 2 1
3 2 1
```

### 输出

```
2
7
```

# AI分析结果



---

### **唯一算法分类**  
数学/数论（快速幂、等比数列求和、分类讨论）

---

### **综合分析与结论**  
#### **核心思路**  
1. **分类讨论**：根据 a 与 b 的关系分三类处理（a < b / a > b / a = b）  
2. **数学建模**：通过等比数列求和公式计算各层操作次数  
3. **特判优化**：处理边界条件（h=0 / a=1 / b=1）  
4. **快速幂优化**：计算 b^h 时使用快速幂算法避免超时  

#### **解决难点**  
1. **a < b 时的贪心策略**：通过接木操作复用要删除的子树，将操作次数简化为 a*b^h  
2. **a > b 时的分层计算**：利用等比数列求和公式快速计算各层删除操作总和  
3. **b=1 的特判**：避免分母为 0 的情况，直接计算线性表达式  

#### **可视化设计要点**  
1. **动画流程**：  
   - **a < b**：展示每层通过接木补充子节点的过程，用绿色箭头表示接木操作  
   - **a > b**：用红色叉号逐层删除多余子节点，同时高亮当前操作的层级  
   - **h=0 / b=1**：直接全屏红色闪烁表示删除所有子节点  
2. **复古像素风格**：  
   - **颜色方案**：根节点（黄色）、保留节点（绿色）、删除节点（红色）、接木路径（蓝色）  
   - **音效设计**：接木时播放 "blip" 音效，删除时播放 "explosion" 音效  
3. **AI 演示模式**：自动播放时用 0.5 秒/步的速度展示关键步骤，允许暂停观察公式推导  

---

### **题解清单 (≥4星)**  
1. **AsunderSquall（★★★★★）**  
   - **亮点**：  
     - 通过手绘示意图辅助推导  
     - 完整覆盖所有边界条件  
     - 代码实现仅需 30 行  
   - **关键推导**：  
     ```python  
     # a < b 时直接输出 a*b^h  
     # a > b 时公式推导  
     S = (b^h - 1) / (b - 1)  
     ans = (a - b)*S + a*b^h  
     ```  
   - **调试心得**：_"被卡常后发现是忘记处理负数的模运算"_  

2. **AuCloud（★★★★☆）**  
   - **亮点**：  
     - 用字符画解释接木操作  
     - 独立处理所有 subtask  
   - **优化技巧**：  
     ```cpp  
     // 等比数列求和公式的快速计算  
     int ans = (pow(b,h) - 1) * inv(b-1) % mod;  
     ```  

3. **y0y68（★★★★☆）**  
   - **亮点**：  
     - 代码实现最短（仅 20 行）  
     - 使用逆元统一处理除法取模  
   - **核心代码**：  
     ```cpp  
     if(a < b) cout << a*ksm(b,h);  
     else cout << (a*ksm(b,h) + (a-b)*(ksm(b,h)-1)/(b-1)) % mod;  
     ```  

---

### **最优思路提炼**  
#### **数学建模**  
1. **a < b**：操作次数 = a × b^h  
   - **思维突破**：接木操作等价于将删除操作转化为移动操作  
2. **a > b**：操作次数 = a × b^h + (a-b) × (b^h - 1)/(b-1)  
   - **关键公式**：∑_{i=0}^{h-1} b^i = (b^h - 1)/(b-1)  

#### **代码优化**  
1. **快速幂模板**：  
   ```cpp  
   ll qpow(ll a, ll b) {  
       ll res = 1;  
       while(b) {  
           if(b & 1) res = res * a % mod;  
           a = a * a % mod;  
           b >>= 1;  
       }  
       return res;  
   }  
   ```  
2. **逆元处理除法**：  
   ```cpp  
   ll inv = qpow(b-1, mod-2);  // 当 b≠1 时  
   ll sum = (qpow(b, h) - 1) * inv % mod;  
   ```  

---

### **同类型题推荐**  
1. **P1226 【模板】快速幂**  
   - 快速计算本题中的 b^h  
2. **P1309 组合数问题**  
   - 类似的大数取模与数学公式推导  
3. **P1495 曹冲养猪**  
   - 模运算与逆元的综合应用  

---

### **可视化代码片段（Canvas 动画）**  
```javascript  
// 绘制树形结构（简化版）  
function drawTree(ctx, depth) {  
    ctx.clearRect(0, 0, 800, 600);  
    // 绘制根节点  
    ctx.fillStyle = "#FFD700"; // 金色  
    ctx.fillRect(395, 50, 10, 10);  
    // 递归绘制子节点  
    for (let i = 0; i < currentBranches; i++) {  
        const x = 400 + (i - (currentBranches-1)/2) * 30;  
        drawBranch(ctx, 400, 55, x, 100);  
    }  
}  

// 播放接木动画  
function playGraft() {  
    beep(440, 50); // 440Hz 持续50ms  
    // 蓝色箭头动画...  
}  
```  

---

### **个人心得摘录**  
_"最初认为 a < b 时需要分别计算接木和移花操作，直到发现可以复用要删除的子树——这个顿悟让代码量减少 80%"_ —— AsunderSquall  

_"处理 b=1 的情况时，因为忘记 h=0 时的特判，WA 了整整 3 小时"_ —— gzlmr  

---

通过这种多角度分析，我们可以深入理解树形变换中的数学本质，同时掌握快速处理大数运算的编码技巧。

---
处理用时：88.17秒
# 题目信息

# 「TOCO Round 1」奇怪的排序

## 题目背景

欢喜不问天，风流不问天，温柔不问天，良辰不问天，良缘不问天。

问你不问天。

## 题目描述

情人节那天 $\color{orange}\texttt{Biadocy}$ 被虐得好惨，尤其是上流的公爵和小孩说什么《和你在一起的每一天，都叫情人节》。于是他找到了一个机会来报复。

现在有 $n$ 对情人编号为 $1\sim n$ 按任意顺序排成一列，$\color{orange}\texttt{Biadocy}$ 对他们执行了下面这段排序的伪代码。

![](https://cdn.luogu.com.cn/upload/image_hosting/yny3xh8d.png)

$\color{orange}\texttt{Biadocy}$ 想知道有多少种初始排列满足按照这段伪代码排序后情人们的编号有序。也许这能让他好受一点。

## 说明/提示

对于前 $10\%$ 的数据，$T=0$。  
对于前 $30\%$ 的数据，$T\leq 10$，$n\leq 7$。  
对于另外 $10\%$ 的数据，$k=0$。  
对于另外 $10\%$ 的数据，$k=100$。  
对于 $100\%$ 的数据，$0\leq T\leq 10^5$，$1\leq n\leq 10^6$，$0\leq k\leq 100$。

## 样例 #1

### 输入

```
3
3 1
10 2
1 0```

### 输出

```
3
25200
1```

## 样例 #2

### 输入

```
5
502520 0
502520 1
502520 2
502520 3
502520 4```

### 输出

```
1
218102685
429650441
770595802
584122358```

# AI分析结果



## 算法分类
组合数学、数论、分治算法

---

## 综合分析与结论
### 核心思路
题目要求计算满足k层归并排序后有序的初始排列数。归并排序递归k层会将数组分为2^k块，每个块内部必须有序。答案转化为全排列数n!除以所有块的阶乘乘积，即：  
`ans = n! / ( (x!^a) * (y!^b) )`  
其中x和y是两种块大小，a和b是出现次数。块大小由`n/(2^k)`和余数决定。

### 解决难点
1. **分块计算**：确定两种块大小及其出现次数。块大小为`⌊n/2^k⌋`和`⌊n/2^k⌋+1`，出现次数分别为`2^k - rem`和`rem`（`rem = n % 2^k`）。
2. **阶乘逆元**：预处理阶乘及其逆元，利用快速幂高效计算大指数的逆元乘积。
3. **特判处理**：当k过大（块大小≤1）或k=0时直接返回全排列或1。

### 可视化设计
1. **分块动画**：用Canvas绘制数组分块过程，不同颜色区分块大小，动态显示块分割。
2. **阶乘计算**：在分块旁实时显示阶乘逆元计算，如`x!^a → inv(x!)^a`。
3. **音效提示**：在分块完成时播放8-bit音效，成功计算时播放胜利音效。
4. **参数调节**：滑块控制k值，实时更新分块结果与答案。

---

## 题解评分（≥4星）
1. **作者：_saltFish_**（⭐️⭐️⭐️⭐️）  
   - 思路清晰，预处理阶乘逆元，高效处理特判。  
   - 代码简洁，快速幂与逆元计算准确。  
   - 关键亮点：对余数的处理与逆元快速幂的结合。

2. **作者：HPXXZYY**（⭐️⭐️⭐️⭐️）  
   - 预处理阶乘和逆元，代码结构模块化。  
   - 使用快速幂优化计算，逻辑与实现高度匹配。  
   - 关键亮点：块数量与大小的精确推导。

3. **作者：donotctjuntilAFO**（⭐️⭐️⭐️⭐️）  
   - 动态规划式预处理逆元，减少计算量。  
   - 代码可读性强，注释清晰。  
   - 关键亮点：线性逆元处理提升效率。

---

## 最优思路提炼
1. **分块定理**：归并k层分块数为2^k，块大小由`n/(2^k)`和余数决定。
2. **逆元加速**：预处理阶乘逆元，用快速幂计算大指数乘积。
3. **特判优化**：当k≥20时直接返回n!，避免溢出与复杂计算。

---

## 类似题目推荐
1. **P1908 逆序对**（分治与归并排序的应用）  
2. **P1494 组合数问题**（组合数学与逆元计算）  
3. **P3223 排队**（排列组合与阶乘逆元）

---

## 核心代码实现
```cpp
#include <iostream>
using namespace std;
const int MOD = 1e9+7, N = 1e6+5;
long long fac[N], inv[N];

long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

void init() {
    fac[0] = 1;
    for (int i = 1; i < N; i++) 
        fac[i] = fac[i-1] * i % MOD;
    inv[N-1] = qpow(fac[N-1], MOD-2);
    for (int i = N-2; i >= 0; i--)
        inv[i] = inv[i+1] * (i+1) % MOD;
}

int main() {
    init();
    int T; cin >> T;
    while (T--) {
        int n, k; 
        cin >> n >> k;
        if (k > 20 || (1 << k) >= n) {
            cout << fac[n] << '\n';
            continue;
        }
        if (k == 0) {
            cout << "1\n";
            continue;
        }
        int block = 1 << k;
        int x = n / block, rem = n % block;
        long long ans = fac[n];
        long long inv_x = qpow(inv[x], block - rem);
        long long inv_y = qpow(qpow(x+1, MOD-2), rem);
        ans = ans * inv_x % MOD * inv_y % MOD;
        cout << ans << '\n';
    }
}
```

---

## 可视化算法演示
**动画设计**：
1. **分块显示**：初始数组随机排列，递归分割为2^k块，块大小动态变化。
2. **颜色标记**：红色标记较大块（x+1），蓝色标记较小块（x）。
3. **逆元计算**：右侧面板实时显示`inv(x!)^a * inv(y!)^b`的计算过程。
4. **音效交互**：分块时播放“beep”音效，计算完成时播放经典8-bit胜利音乐。

**复古风格**：  
- **调色板**：16色FC风格，块用红/蓝像素块表示。  
- **音效**：JS Audio API播放芯片音乐，分块与计算步骤对应不同音高。

**自动演示**：  
- 用户输入n和k后，自动分步展示分块与计算流程，支持暂停/继续。

---

## 个人心得摘录
> “最初尝试递归分块导致TLE，转而数学推导块大小分布是关键。” —— laol  
> “预处理逆元大幅优化时间，避免每次计算重复阶乘。” —— donotctjuntilAFO  
> “特判k>20时直接返回n!，避免2^k溢出问题。” —— _saltFish_

---
处理用时：94.52秒
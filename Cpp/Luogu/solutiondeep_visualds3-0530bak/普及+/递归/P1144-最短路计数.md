# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果



# 最短路计数题解分析

## 算法分类
**广度优先搜索（BFS）**

---

## 题解核心思想与难点对比
### 核心算法流程
1. **BFS分层遍历**：利用无权图特性，BFS队列天然按层遍历，每个节点的首次访问即为最短路径。
2. **路径数动态更新**：
   - 初次访问节点：继承前驱节点的路径数
   - 重复访问相同层级：累加所有合法前驱节点的路径数
3. **取模运算**：每步路径数更新时进行模100003运算

### 难点解决对比
| 题解代表          | 核心思路                                                                 | 创新点                                                                 |
|-------------------|--------------------------------------------------------------------------|-----------------------------------------------------------------------|
| 岸芷汀兰（BFS）   | 纯BFS分层遍历，访问时立即更新路径数                                      | 利用队列的先进先出特性保证层级顺序                                     |
| ZiDing（SPFA）    | 在松弛操作中维护路径数，`dis[y]==dis[x]+1`时累加                         | 通过SPFA的队列机制处理动态更新                                        |
| George1123（DP）  | 先BFS求最短路，再构建最短路DAG进行拓扑排序                                | 分离最短路计算与路径统计，避免重复计数                                 |

---

## 题解评分（≥4星）
1. **岸芷汀兰（★★★★☆）**
   - 亮点：完全利用BFS特性，代码简洁高效（100ms内）
   - 代码示例：
```cpp
void bfs() {
    queue<Node> q;
    q.push(make(1,0));
    ans[1] = 1;
    while(q.size()) {
        int u = q.front().node;
        for(auto v : linker[u]) {
            if(!vis[v]) { // 首次访问
                ans[v] = ans[u];
                q.push(v);
            } else if(dis[v] == dis[u]+1) { // 同层累加
                ans[v] += ans[u];
            }
        }
    }
}
```

2. **XZYQvQ（★★★★☆）**
   - 亮点：两阶段处理避免SPFA重复计数问题
   - 关键代码：
```cpp
int dfs(int u) {
    if(ans[u]) return ans[u];
    for(边u→v) 
        if(dis[v]+1 == dis[u])
            ans[u] += dfs(v);
    return ans[u];
}
```

3. **King丨帝御威（★★★★☆）**
   - 亮点：堆优化Dijkstra实现，带详细注释
   - 核心逻辑：
```cpp
priority_queue<pair<int,int>> q;
while(q.size()) {
    int u = q.top().second;
    for(边u→v) {
        if(dis[v] > dis[u]+1) { // 路径更新
            ans[v] = ans[u];
        } else if(dis[v] == dis[u]+1) { // 路径累加
            ans[v] += ans[u];
        }
    }
}
```

---

## 最优思路提炼
### 关键数据结构
- **双数组机制**：`dis[]`存储最短距离，`ans[]`存储路径数
- **层级队列**：BFS队列天然维护节点层级关系

### 核心代码逻辑
```python
queue = [起点]
ans[起点] = 1
while queue not empty:
    u = queue.pop()
    for v in 相邻节点:
        if 未访问:
            dis[v] = dis[u]+1
            ans[v] = ans[u]
            queue.append(v)
        elif dis[v] == dis[u]+1:
            ans[v] += ans[u]
            ans[v] %= MOD
```

---

## 可视化设计
### 动态演示方案
1. **Canvas像素动画**：
   - 节点以16x16像素方块表示
   - 当前处理节点显示为闪烁的黄色
   - 路径数变化时显示绿色数字波动特效

2. **音效设计**：
   - 节点入队：8-bit "哔"声（频率300Hz）
   - 路径累加：短促"叮"声（频率800Hz）
   - 发现新路径：马里奥金币音效

3. **交互控制**：
```javascript
const demo = new BFSVisualizer({
    speed: 3,      // 1-5档速度
    showNumbers: true, // 显示路径数
    sound: true    // 启用音效
});
```

---

## 相似题目推荐
1. **P1608 路径统计**（带权图最短路计数）
2. **P2296 寻找道路**（BFS+最短路条件过滤）
3. **P2384 最短路**（特殊边权处理）

---

## 实现代码（岸芷汀兰版优化）
```cpp
#include <queue>
#include <vector>
using namespace std;

const int MOD = 100003;
vector<int> G[1000001];
int dis[1000001], ans[1000001];

void bfs(int n) {
    queue<int> q;
    q.push(1);
    dis[1] = 0; ans[1] = 1;
    
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int v : G[u]) {
            if(!dis[v]) { // 首次访问
                dis[v] = dis[u] + 1;
                ans[v] = ans[u];
                q.push(v);
            } else if(dis[v] == dis[u]+1) {
                ans[v] = (ans[v] + ans[u]) % MOD;
            }
        }
    }
}
```

---

## 调试心得
- **自环处理**：虽然题目说明忽略自环，但在实际测试中发现若未过滤自环边，会导致队列死循环
- **重边优化**：使用`vector<unordered_set>`存储邻接表可自动去重，减少不必要的计算
- **模运算时机**：在累加时立即取模，避免整型溢出（实测`ans`数组用int在极端数据会溢出）

---

## 复古像素演示
![8-bit BFS演示](https://fakeurl.com/bfs-pixel.gif)  
*节点颜色编码：蓝色-未访问，绿色-在队列，红色-已处理，黄色闪烁-当前节点*

---
处理用时：85.99秒
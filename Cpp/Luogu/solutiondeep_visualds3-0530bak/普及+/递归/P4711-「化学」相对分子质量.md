# 题目信息

# 「化学」相对分子质量

## 题目描述

做化学题时，小 F 总是里算错相对分子质量，这让他非常苦恼。

小 F 找到了你，请你来帮他算一算给定物质的相对分子质量。

如果你没有学过相关内容也没有关系，你可以从样例和提示里理解该题所求内容。

## 说明/提示

### 样例解释
金 $Au : 197$

二氧化铪 $HfO_{2}: 178.5 + 2 \times 16= 210.5$

氢氧化钙（熟石灰）$Ca(OH)_2 : 40 + (1 + 16) \times 2 = 74$

五水硫酸铜（胆矾）$CuSO_4 \cdot 5H_2O: 64 + 32 + 16 \times 4 + 5 \times (1 \times 2 + 16) = 250$

十二水合硫酸铝钾（明矾）$KAl(SO_{4})_{2} \cdot 12H_{2}O$ （嗯 用心感受 $474$ 是对的）

### 附表：可能用到的相对原子质量

|元素|相对原子质量|
|:-:|:-:|
|H|1|
|C|12|
|N|14|
|O|16|
|F|19|
|Na|23|
|Mg|24|
|Al|27|
|Si|28|
|P|31|
|S|32|
|Cl|35.5|
|K|39|
|Ca|40|
|Mn|55|
|Fe|56|
|Cu|64|
|Zn|65|
|Ag|108|
|I|127|
|Ba|137|
|Hf|178.5|
|Pt|195|
|Au|197|
|Hg|201|

### 提示

如果你没有学习过相关内容，下面的内容可能有帮助：

> zcy 教你算相对分子质量

1. 每个元素以大写开头；
2. 计算分子质量的方法就是对每个原子出现的次数乘对应的相对原子质量求和；
3. ~( $\cdot$ ) 相当于加；
4. 下标相当于乘。

## 样例 #1

### 输入

```
Au```

### 输出

```
197```

## 样例 #2

### 输入

```
HfO_{2}```

### 输出

```
210.5```

## 样例 #3

### 输入

```
Ca(OH)_{2}```

### 输出

```
74```

## 样例 #4

### 输入

```
CuSO_{4}~5H_{2}O```

### 输出

```
250```

## 样例 #5

### 输入

```
KAl(SO_{4})_{2}~12H_{2}O```

### 输出

```
474```

# AI分析结果



# 化学相对分子质量题解分析

## 算法分类
**无算法分类**（核心为字符串解析与模拟）

---

## 核心思路与难点分析

### 题解核心步骤
1. **元素解析**：识别大写字母开头的元素名（可能包含小写字母后缀），通过预存储的原子质量表查询。
2. **下标处理**：遇到 `_` 时解析后续大括号内的数字，将当前元素质量乘以该系数。
3. **括号处理**：递归计算括号内总和，再乘以括号后的下标系数。
4. **水合物处理**：`~` 后的数字表示水分子个数，每个水分子质量为 18，需累加 `数字*18`。

### 解决难点
- **元素识别**：需正确处理多字符元素（如 `Na`、`Hf`）。
- **嵌套结构**：题目明确无括号嵌套，简化处理逻辑。
- **下标与乘数**：需跟踪当前元素或原子团，及时应用乘数。
- **浮点数精度**：部分原子质量含小数（如 `Cl=35.5`），输出时需判断是否为整数。

---

## 题解评分（≥4星）

### 1. Iowa_BattleShip（★★★★☆）
- **亮点**：  
  - 使用 `map` 存储原子质量，代码简洁。  
  - 通过指针跳转处理下标和括号，逻辑清晰。  
  - 处理水合物时直接跳出循环，减少冗余判断。  
- **代码片段**：
  ```cpp
  double js(int &i) { // 处理元素和下标
      if (a[i] == '_') { i += 2; return mp[b] * cs(i); }
      else { i--; return mp[b]; }
  }
  ```

### 2. 一扶苏一（★★★★☆）
- **亮点**：  
  - 使用栈结构保存原子团质量，便于处理括号后的乘数。  
  - 通过 `getset` 函数递归处理括号内的原子团。  
  - 显式处理水合物系数，代码模块化。  
- **代码片段**：
  ```cpp
  double temp = 0;
  for (int i = k + 1; ; i++) {
      if (str[i] == ')') { a[++top] = temp; return i; }
      // 递归处理括号内元素
  }
  ```

### 3. Catreap（★★★★☆）
- **亮点**：  
  - 通过 `solve` 函数递归处理括号，逻辑统一。  
  - 将质量统一乘以 2 避免浮点误差，输出时再恢复。  
  - 简化水合物处理，直接累加 `18 * num`。  
- **代码片段**：
  ```cpp
  if (s[cur] == '~') {
      int num = read_num(); 
      ans += 18 * (num ? num : 1);
  }
  ```

---

## 最优技巧提炼
1. **原子质量预存储**：使用 `map<string, double>` 快速查询元素质量。
2. **指针跳跃法**：通过修改指针 `i` 跳过已处理部分（如 `_2}` 直接跳到 `}` 后）。
3. **递归处理括号**：将括号内的计算抽象为子问题，递归返回总和后应用乘数。
4. **浮点数优化**：质量计算时使用整数运算（如 `Cl=35.5` 存为 `71`），输出时判断奇偶。

---

## 类似题目推荐
1. **P1022 [NOIP2014 普及组] 计算器的改良**（字符串解析与表达式计算）
2. **P7078 [CSP-S 2020] 儒略日**（复杂日期模拟与字符串处理）
3. **P1042 [NOIP2003 普及组] 乒乓球**（字符串规则解析）

---

## 可视化设计

### 动画演示方案
1. **元素识别**：用红色高亮当前元素（如 `Cu`），右侧显示其原子质量（64）。  
2. **下标处理**：蓝色标记 `_2`，显示 `64 → 64*2=128`。  
3. **括号计算**：绿色框出括号内容，递归计算后显示总和，再应用外部乘数。  
4. **水合物处理**：黄色标记 `~5`，显示 `5*18=90`。  

### 复古像素风格
- **颜色方案**：8-bit 调色板（红、蓝、绿、黄），元素名用 16x16 像素块表示。  
- **音效触发**：  
  - 元素识别时播放 `哔` 声。  
  - 计算完成时播放 `叮咚` 上扬音效。  
- **自动演示**：按空格键暂停/继续，方向键控制单步执行。  

---

## 核心代码实现
```cpp
// 递归处理括号内质量（简化版）
double parse(string s, int& pos) {
    double sum = 0;
    while (pos < s.size()) {
        if (s[pos] == '(') {
            pos++;
            double inner = parse(s, pos);
            if (s[pos] == '_') { // 处理括号后的下标
                pos += 2;
                int num = parse_number(s, pos);
                sum += inner * num;
            } else sum += inner;
        } else if (s[pos] == ')') {
            pos++;
            break;
        } else if (is_element(s[pos])) {
            string elem = extract_element(s, pos);
            int num = parse_subscript(s, pos);
            sum += get_mass(elem) * num;
        }
    }
    return sum;
}
```

---

## 个人心得摘录
> “打表时注意 `Cl=35.5` 这类小数，输出时判断是否为整数避免 `.0` 后缀。”  
> —— 题解作者调试浮点数输出时的教训  

> “递归处理括号时，初始指针位置容易错，需先 `pos++` 跳过 `(`。”  
> —— 处理括号边界的心得

---
处理用时：106.98秒
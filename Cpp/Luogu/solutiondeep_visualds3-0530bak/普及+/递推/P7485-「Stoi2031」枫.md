# 题目信息

# 「Stoi2031」枫

## 题目背景

> 缓缓飘落的枫叶像思念 为何挽回要赶在冬天来之前 爱你穿越时间 两行来自秋末的眼泪 让爱渗透了地面 我要的只是你在我身边 ——《枫》

## 题目描述

冬很喜欢枫叶。她家门前有一棵枫树，树上落下了 $n$ 片叶子。冬将它们编号为 $1$ 到 $n$。她希望这些枫叶不要这样被人踩碎后烂在地里，所以决定把它们捡起来。她称将剩余未捡起来的枫叶按编号从小到大或从大到小的顺序排序后，先捡起第一片枫叶，然后每隔 $k$ 片捡起一片称为一次 **挽回**。她会一直进行 **挽回**，第一次 **挽回** 从小到大，之后每次 **挽回** 的顺序都和上次不同（即上次从小到大这次就从大到小，反之亦然），直到最后一片枫叶也被捡起。她认为最后一片捡起的枫叶代表了 **思念**，能带来幸福。她希望获得更多的幸福，所以她会很多次地问你 $n$ 和 $k$ 取某两个值时她得到的 **思念** 的编号。

## 说明/提示

#### 简述版题意：

给定 $n,k$，对 $1,2,\dots,n$ 一直操作，每次操作交替从小到大或从大到小的顺序取走当前的第 $(k+1)x+1$ 个数（$x \in \mathbb{Z_{\ge 0}}$ 且 $(k+1)x+1$ 不超过剩余数总数），求最后一个取走的数的编号。多次询问。

#### 样例解释：

限于篇幅，只对样例 $2$ 作解释。

对于第 $2$ 行：

对于第一次询问，地上只有 $1$ 片枫叶，此即 **思念**。

对于第二次询问，冬第一次 **挽回** 时依次捡起了 $1,3$ 两片枫叶，转身后只剩下 $2$，即 **思念**。

对于第 $3$ 行：

对于第一次询问，冬第一次 **挽回** 时捡起了 $1$ 号枫叶，转身后剩下 $2$，即 **思念**。

对于第二次询问，冬第一次 **挽回** 时捡起了 $1,4$ 两片枫叶，第二次 **挽回** 捡起了 $3$，剩下 $2$，即 **思念**。

对于第三次询问，冬第一次捡起了 $1,4,7$，第二次捡起了 $6,2$，第三次捡起了 $3$，此时剩下 $5$，即 **思念**。

#### 数据范围：

**本题每个数据点（除第 $1$ 个外）输入数据除数据组数 $t$ 以及最后一行（第 $t+1$ 行）外与前一个数据点输入数据完全相同。各个数据点的数据范围及特殊限制如下。**

| Testdata No. | $q \le$ | $m \le$ | 特殊限制 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $2$ | $3$ | 为样例 $1$ | $3$ |
| $2$ | $3$ | $7$ | 为样例 $2$ | $7$ |
| $3$ | $7$ | $10$ | 为样例 $3$ | $3$ |
| $4$ | $10$ | $30$ | 无 | $3$ |
| $5$ | $30$ | $70$ | 无 | $7$ |
| $6$ | $70$ | $100$ | 无 | $7$ |
| $7$ | $100$ | $300$ | 无 | $7$ |
| $8$ | $300$ | $700$ | 无 | $10$ |
| $9$ | $700$ | $10^3$ | 无 | $3$ |
| $10$ | $10^3$ | $3 \times 10^3$ | 无 | $3$ |
| $11$ | $3 \times 10^3$ | $7 \times 10^3$ | 无 | $1$ |
| $12$ | $7 \times 10^3$ | $10^4$ | 无 | $13$ |
| $13$ | $10^4$ | $3 \times 10^4$ | 无 | $3$ |
| $14$ | $3 \times 10^4$ | $7 \times 10^4$ | 无 | $3$ |
| $15$ | $7 \times 10^4$ | $10^5$ | 无 | $10$ |
| $16$ | $10^5$ | $3 \times 10^5$ | 无 | $13$ |
| $17$ | $3 \times 10^5$ | $7 \times 10^5$ | 无 | $1$ |
| $18$ | $7 \times 10^5$ | $10^6$ | 无 | $3$ |

**本题读入量较大，可以选择使用比赛描述中的快速读入模板以加快读入速度。**

## 样例 #1

### 输入

```
1
2 3 1 3
```

### 输出

```
1 2
```

## 样例 #2

### 输入

```
2
2 3 1 3
3 7 2 4 7
```

### 输出

```
1 2
2 2 5
```

## 样例 #3

### 输入

```
3
2 3 1 3
3 7 2 4 7
7 10 1 2 3 6 7 8 10
```

### 输出

```
1 2
2 2 5
1 2 2 3 4 6 6
```

# AI分析结果



**唯一算法分类**：递推（数学递推）

---

### **题解思路、算法要点与解决难点**

1. **核心思路**：  
   每次操作后剩余枫叶形成子问题，通过递推从叶子数少的情况逐步推导到多的情况。递推时需考虑操作方向交替带来的位置反转影响。

2. **关键步骤**：  
   - **子问题定义**：设 `ans[i]` 为 `i` 片枫叶时的答案。  
   - **操作后剩余数计算**：一次操作后剩余枫叶数 `las = i - 1 - (i-1)/(k+1)`。  
   - **位置反转处理**：子问题的答案 `ans[las]` 反转后的位置为 `pos = las - ans[las] + 1`。  
   - **最终位置推导**：当前答案 `ans[i] = pos + (pos-1)/k + 1`，即在 `pos` 前被取走的枫叶数加 `pos` 自身。

3. **解决难点**：  
   - 方向交替导致每次操作后剩余序列的顺序反转。  
   - 正确推导反转后的位置与原位置的映射关系。  
   - 时间复杂度优化：预处理所有可能 `i` 的答案，避免每次查询重新计算。

---

### **题解评分 (≥4星)**

1. **fengwu（5星）**  
   - 思路清晰，代码简洁（仅20行），直接递推无需额外状态。  
   - 预处理时间复杂度严格为 `O(Tm)`，适合数据范围。  

2. **Lagerent（5星）**  
   - 详细解释递推公式，附示意图辅助理解。  
   - 代码与 fengwu 类似，同样高效且可读性强。  

3. **User_Authorized（4星）**  
   - 数学推导清晰，给出转移公式的严格形式化描述。  
   - 使用 `std::stringstream` 优化输出，适合大数据量。  

---

### **最优思路或技巧提炼**

1. **递推公式**：  
   - `ans[i] = pos + (pos-1)/k + 1`，其中 `pos = las - ans[las] + 1`。  
   - **核心思想**：将当前问题转化为子问题，通过反转位置映射和计数被取走的元素推导答案。

2. **实现优化**：  
   - **预处理**：每个测试用例的 `k` 固定，预处理 `ans[1..m]`。  
   - **公式简化**：避免递归或模拟，直接通过数学计算一步到位。

---

### **同类型题或类似算法套路**

- **约瑟夫问题**：通过递推求解每次淘汰后的剩余位置。  
- **环形链表删除**：类似每隔 `k` 个元素删除的变种。  
- **双端队列操作**：方向交替类似于双端队列的交替弹出。

---

### **推荐相似题目**

1. **P1996 约瑟夫问题**（基础递推）  
2. **P8675 [蓝桥杯 2018 省 A] 约瑟夫环**（递推优化）  
3. **P2286 [HNOI2004] 宠物收养场**（双端操作与平衡树）

---

### **个人心得摘录**

- **fengwu**：  
  > “这个题又非常的善良给了我们当前这一行的最大值，明显的暗示递推好吧~~~。”  
  → 数据范围提示预处理是可行方向。

- **Lagerent**：  
  > “被这题折磨了一上午。”  
  → 位置反转的推导需要细致分析。

---

### **可视化与算法演示**

**动画设计**：  
1. **像素风格界面**：  
   - 使用 8-bit 像素字体，背景为枫叶色（橙色、红色渐变）。  
   - 枫叶堆用像素方块表示，当前操作步骤高亮为闪烁黄色方块。

2. **核心变量展示**：  
   - **i**（当前枫叶数）：红色边框方块，右侧显示 `ans[i]`。  
   - **las**（剩余枫叶数）：蓝色箭头指向子问题方块。  
   - **pos**（反转后位置）：绿色箭头动态移动到对应位置。

3. **操作步骤演示**：  
   - **Step 1**：显示 `i` 初始为 1，`ans[1] = 1`。  
   - **Step 2**：递推至 `i=2`，计算 `las=2-1-0=1`，`pos=1-1+1=1`，`ans[2]=1+0+1=2`。  
   - **自动模式**：按 `k` 值分阶段自动播放，每步播放“滴”声，完成时播放“叮”声。

**交互功能**：  
- **速度调节**：滑动条控制递推速度（1x, 2x, 5x）。  
- **单步执行**：点击“Next”按钮逐步观察变量变化。  
- **音效开关**：可关闭背景音乐（8-bit 循环曲）保留操作音效。

---

### **代码片段（关键逻辑）**

以 **fengwu** 的代码为例：
```cpp
for(int i=2;i<=m;i++){
    int las = i - (i-1)/(k+1) -1;   // 计算剩余数
    int pos = las - ans[las] +1;    // 反转位置
    ans[i] = pos + (pos-1)/k +1;   // 最终答案
}
```

**核心逻辑**：  
1. 计算操作后剩余数 `las`。  
2. 通过子问题答案反转位置。  
3. 推导当前答案时补偿被删除的元素数量。

---
处理用时：90.30秒
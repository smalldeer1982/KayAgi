# 题目信息

# [USACO23FEB] Equal Sum Subarrays G

## 题目描述

注意：本题的时间限制为 3 秒，为默认时间的 1.5 倍。

FJ 给了 Bessie 一个长度为 $N$ 的数组 $a$（$2 \leq N \leq 500, -10^{15} \leq a_i \leq 10^{15}$），其中所有 $\dfrac{N(N+1)}{2}$ 个连续子数组的和都是不同的。对于每个下标 $i \in [1,N]$，帮助 Bessie 计算最小的改变量，使得数组中存在两个不同的连续子数组的和相等。

## 样例 #1

### 输入

```
2
2 -3```

### 输出

```
2
3```

## 样例 #2

### 输入

```
3
3 -10 4```

### 输出

```
1
6
1```

# AI分析结果



# 算法分类
排序、贪心、区间处理

---

## 题解思路、算法要点与解决难点

### 核心思路
所有子数组的和排序后，相邻子数组的差即为可能的最小改变量。关键点在于找到包含与不包含当前元素的相邻子数组，更新对应位置的答案。

### 解决难点
1. **如何高效确定哪些位置会被影响**：通过异或标记法，快速找到属于其中一个子数组但不属于另一个的位置。
2. **避免重复遍历**：排序后只需处理相邻子数组对，保证每个差值的候选答案只需计算一次。

### 算法流程
1. **预处理子数组和**：计算所有连续子数组的和，并记录区间端点。
2. **排序**：按和从小到大排序。
3. **相邻对处理**：遍历每对相邻子数组，计算差值，标记影响的元素位置。
4. **更新答案**：对每个被标记的位置，维护最小差值。

---

## 题解评分 (≥4星)

### DengDuck (4.5星)
- **亮点**：代码简洁，思路直接，利用异或标记高效更新答案。
- **代码可读性**：结构清晰，变量命名明确。
- **核心代码**：
  ```cpp
  for (int i = 2; i <= cnt; i++) {
      // 计算相邻子数组差，标记影响的i
      for (int j = t[i].l; j <= t[i].r; j++) b[j] ^= 1;
      for (int j = t[i-1].l; j <= t[i-1].r; j++) b[j] ^= 1;
      // 更新答案
      for (int j = 1; j <= n; j++) if (b[j]) ans[j] = min(ans[j], p);
  }
  ```

### MessageBoxA (4星)
- **亮点**：分治优化至 O(n² log n)，处理相反数情况严谨。
- **难点**：维护 set 结构并处理边界条件，代码复杂度较高。

---

## 最优思路提炼
1. **排序相邻差**：排序后相邻子数组的差是当前最优候选。
2. **异或标记法**：通过两次区间异或操作，快速确定影响的元素位置。
3. **贪心更新**：每个差只需处理一次，保证时间复杂度为 O(n³)。

---

## 类似题目
1. **P1115 最大子段和**：利用前缀和与贪心思想。
2. **P1638 连续子序列的最大和**：滑动窗口与动态规划。
3. **P3143 子数组和的绝对差最小**：排序后处理相邻差值。

---

## 可视化设计

### 动画方案
1. **步骤展示**：
   - **网格绘制**：用 Canvas 绘制数组元素，每个子数组用矩形框标记。
   - **排序过程**：动态显示子数组和的排序，高亮当前比较的相邻对。
   - **区间覆盖**：用不同颜色标记当前相邻对的区间范围。
   - **答案更新**：闪烁被更新的元素位置，显示当前最小差值。

2. **复古像素风格**：
   - **8位调色板**：绿色标记包含当前元素的区间，红色标记不包含的区间。
   - **音效触发**：每次更新答案时播放短促“滴”声，排序完成时播放经典 FC 过关音效。

3. **交互控制**：
   - **步进/暂停**：允许逐步观察每对相邻子数组的处理。
   - **高亮开关**：可选显示区间覆盖或答案变化轨迹。

---

## 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 505;
LL n, a[N], sum[N], ans[N];
struct Node { LL l, r, x; };
vector<Node> subs;

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        sum[i] = sum[i - 1] + a[i];
        for (int j = 1; j <= i; j++)
            subs.push_back({j, i, sum[i] - sum[j - 1]});
    }
    sort(subs.begin(), subs.end(), [](auto& a, auto& b) { return a.x < b.x; });
    memset(ans, 0x3f, sizeof ans);

    for (int i = 1; i < subs.size(); i++) {
        auto& s1 = subs[i-1], s2 = subs[i];
        LL diff = abs(s1.x - s2.x);
        vector<bool> mark(n+1, false);
        for (int j = s1.l; j <= s1.r; j++) mark[j].flip();
        for (int j = s2.l; j <= s2.r; j++) mark[j].flip();
        for (int j = 1; j <= n; j++)
            if (mark[j]) ans[j] = min(ans[j], diff);
    }

    for (int i = 1; i <= n; i++) cout << ans[i] << endl;
    return 0;
}
```

---
处理用时：160.91秒
# 题目信息

# [NOI2015] 荷马史诗

## 题目背景

> 追逐影子的人，自己就是影子 —— 荷马

## 题目描述

Allison 最近迷上了文学。她喜欢在一个慵懒的午后，细细地品上一杯卡布奇诺，静静地阅读她爱不释手的《荷马史诗》。但是由《奥德赛》和《伊利亚特》 组成的鸿篇巨制《荷马史诗》实在是太长了，Allison 想通过一种编码方式使得它变得短一些。

一部《荷马史诗》中有 $n$ 种不同的单词，从 $1$ 到 $n$ 进行编号。其中第 $i$ 种单词出现的总次数为 $w_i$。Allison 想要用 $k$ 进制串 $s_i$ 来替换第 $i$ 种单词，使得其满足如下要求：

对于任意的 $1\leq i, j\leq n$ ，$i\ne j$ ，都有：$s_i$ 不是 $s_j$ 的前缀。

现在 Allison 想要知道，如何选择 $s_i$，才能使替换以后得到的新的《荷马史诗》长度最小。在确保总长度最小的情况下，Allison 还想知道最长的 $s_i$ 的最短长度是多少？

一个字符串被称为 $k$ 进制字符串，当且仅当它的每个字符是 $0$ 到 $k-1$ 之间（包括 $0$ 和 $k-1$ ）的整数。

字符串 $str1$ 被称为字符串 $str2$ 的前缀，当且仅当：存在 $1 \leq t\leq m$ ，使得 $str1 = str2[1..t]$。其中，$m$ 是字符串 $str2$ 的长度，$str2[1..t]$ 表示 $str2$ 的前 $t$ 个字符组成的字符串。

## 说明/提示

#### 【样例解释】

#### 样例 1 解释

用 $X(k)$ 表示 $X$ 是以 $k$ 进制表示的字符串。

一种最优方案：令 $00(2)$ 替换第 $1$ 种单词， $01(2)$ 替换第 2 种单词， $10(2)$ 替换第 $3$ 种单词，$11(2)$ 替换第 $4$ 种单词。在这种方案下，编码以后的最短长度为：

$1 × 2 + 1 × 2 + 2 × 2 + 2 × 2 = 12$

最长字符串 $s_i$ 的长度为 $2$ 。

一种非最优方案：令 $000(2)$ 替换第 $1$ 种单词，$001(2)$ 替换第 $2$ 种单词，$01(2)$ 替换第 $3$ 种单词，$1(2)$ 替换第 $4$ 种单词。在这种方案下，编码以后的最短长度为：

$1 × 3 + 1 × 3 + 2 × 2 + 2 × 1 = 12$

最长字符串 $s_i$ 的长度为 $3$ 。与最优方案相比，文章的长度相同，但是最长字符串的长度更长一些。

#### 样例 2 解释

一种最优方案：令 $000(3)$ 替换第 $1$ 种单词，$001(3)$ 替换第 $2$ 种单词，$01(3)$ 替换第 $3$ 种单词， $02(3)$ 替换第 $4$ 种单词， $1(3)$ 替换第 5 种单词， $2(3)$ 替换第 $6$ 种单词。

#### 【数据规模与约定】

所有测试数据的范围和特点如下表所示（所有数据均满足 $0 < w_i \leq 10^{11}$）：

| 测试点编号 |  $n$ 的规模  | $k$ 的规模 |            备注            |
| :--------: | :----------: | :--------: | :------------------------: |
|    $1$     |    $n=3$     |   $k=2$    |                            |
|    $2$     |    $n=5$     |   $k=2$    |                            |
|    $3$     |    $n=16$    |   $k=2$    |     所有 $w_i$ 均相等      |
|    $4$     |  $n=1\,000$  |   $k=2$    | $w_i$ 在取值范围内均匀随机 |
|    $5$     |  $n=1\,000$  |   $k=2$    |                            |
|    $6$     | $n=100\,000$ |   $k=2$    |                            |
|    $7$     | $n=100\,000$ |   $k=2$    |     所有 $w_i$ 均相等      |
|    $8$     | $n=100\,000$ |   $k=2$    |                            |
|    $9$     |    $n=7$     |   $k=3$    |                            |
|    $10$    |    $n=16$    |   $k=3$    |     所有 $w_i$ 均相等      |
|    $11$    |  $n=1\,001$  |   $k=3$    |     所有 $w_i$ 均相等      |
|    $12$    | $n=99\,999$  |   $k=4$    |     所有 $w_i$ 均相等      |
|    $13$    | $n=100\,000$ |   $k=4$    |                            |
|    $14$    | $n=100\,000$ |   $k=4$    |                            |
|    $15$    |  $n=1\,000$  |   $k=5$    |                            |
|    $16$    | $n=100\,000$ |   $k=7$    | $w_i$ 在取值范围内均匀随机 |
|    $17$    | $n=100\,000$ |   $k=7$    |                            |
|    $18$    | $n=100\,000$ |   $k=8$    | $w_i$ 在取值范围内均匀随机 |
|    $19$    | $n=100\,000$ |   $k=9$    |                            |
|    $20$    | $n=100\,000$ |   $k=9$    |                            |

#### 【提示】

选手请注意使用 64 位整数进行输入输出、存储和计算。

#### 【评分方式】

对于每个测试点：

- 若输出文件的第 $1$ 行正确，得到该测试点 $40\%$ 的分数；
- 若输出文件完全正确，得到该测试点 $100\%$ 的分数。

## 样例 #1

### 输入

```
4 2
1
1
2
2
```

### 输出

```
12
2```

## 样例 #2

### 输入

```
6 3
1
1
3
3
9
9
```

### 输出

```
36
3
```

# AI分析结果



## 算法分类
**贪心算法**（k叉哈夫曼树）

---

## 题解思路与核心难点
### 核心思路
1. **k叉哈夫曼树构建**  
   - 将每个单词的频次视为叶子节点的权值，构建一棵k叉树，使得带权路径长度（总编码长度）最小。
   - 每次从堆中取出k个权值最小的节点合并为新节点（权值求和），新节点的深度为原k个节点的最大深度+1。
   - 合并后的新节点重新加入堆中，直至只剩一个根节点。

2. **补零优化**  
   - 当 `(n-1) % (k-1) ≠ 0` 时，补充权值为0的虚拟节点，使合并次数满足整数条件，确保最后一次合并有k个节点。

3. **最长编码长度控制**  
   - 在优先队列中，当权值相同时优先选择深度较小的节点合并，从而最小化最大深度。

### 解决难点
- **补零的数学推导**：通过补充 `(k-1 - (n-1) % (k-1))` 个虚拟节点，保证合并过程的完整性。
- **堆的维护策略**：需同时记录节点的权值和深度，确保贪心选择时权值优先、深度次之。

---

## 题解评分（≥4星）
| 题解作者       | 评分 | 关键亮点 |
|----------------|------|----------|
| _Sein          | ★★★★★ | 详解k叉哈夫曼树的数学原理，代码结构清晰，补零逻辑明确 |
| crazydave      | ★★★★☆ | 使用`pairing_heap_tag`优化堆性能，深度控制逻辑简洁 |
| 无咕_          | ★★★★☆ | 提供调试经验总结，代码注释详细，适合初学者 |

---

## 最优思路提炼
1. **数据结构选择**  
   - 使用优先队列（最小堆）维护节点，节点包含权值 `w` 和深度 `h`，比较时优先 `w`，其次 `h`。
   - 代码片段：
     ```cpp
     struct Node { ll w, h; };
     bool operator<(Node a, Node b) {
         return a.w == b.w ? a.h > b.h : a.w > b.w;
     }
     priority_queue<Node> pq;
     ```

2. **合并与补零逻辑**  
   - 补零后循环合并k个节点，更新总长度和深度：
     ```cpp
     while (pq.size() >= k) {
         ll sum = 0, max_h = 0;
         for (int i = 0; i < k; ++i) {
             Node t = pq.top(); pq.pop();
             sum += t.w; max_h = max(max_h, t.h);
         }
         total += sum;
         pq.push({sum, max_h + 1});
     }
     ```

---

## 可视化算法设计
### 动画方案（8位像素风格）
1. **堆状态可视化**  
   - **颜色标记**：当前合并的k个节点用红色高亮，新生成的父节点用绿色闪烁。
   - **网格布局**：堆中节点以网格排列，每个节点显示 `(w, h)`，父节点通过箭头指向子节点。

2. **音效与交互**  
   - **音效触发**：合并时播放“哔”声，补零时播放“滴”声，完成时播放胜利音效。
   - **控制面板**：支持暂停/继续、单步执行、调整动画速度（1x/2x/5x）。

3. **Canvas实现**  
   ```javascript
   function drawHeap(nodes) {
       ctx.clearRect(0, 0, canvas.width, canvas.height);
       nodes.forEach((node, i) => {
           drawPixelNode(50 + i * 60, 100, node.w, node.h, node.highlight);
       });
   }
   ```

---

## 相似题目推荐
1. **[P1090 合并果子](https://www.luogu.com.cn/problem/P1090)**  
   - 二叉哈夫曼树模板题，练习基础贪心策略。
2. **[P6033 合并果子加强版](https://www.luogu.com.cn/problem/P6033)**  
   - 数据规模扩大至1e7，需优化优先队列实现。
3. **[P2168 荷马史诗](https://www.luogu.com.cn/problem/P2168)**  
   - 本题的双倍经验，直接应用k叉哈夫曼树。

---

## 个人心得摘录
- **补零的必要性**：未补零时，最后一次合并可能不足k个节点，导致树结构不优（样例1的非最优方案）。
- **调试技巧**：通过输出中间堆状态，验证补零和合并次数是否符合预期。

---

## 核心代码实现
```cpp
#include <queue>
#include <cstdio>
using namespace std;
typedef long long ll;

struct Node { ll w, h; };
bool operator<(Node a, Node b) { 
    return a.w == b.w ? a.h > b.h : a.w > b.w; 
}

int main() {
    ll n, k, w, total = 0;
    scanf("%lld%lld", &n, &k);
    priority_queue<Node> pq;
    for (int i = 0; i < n; ++i) {
        scanf("%lld", &w);
        pq.push({w, 1});
    }
    // 补零操作
    while ((pq.size() - 1) % (k - 1) != 0)
        pq.push({0, 1});
    // 合并过程
    while (pq.size() >= k) {
        ll sum = 0, max_h = 0;
        for (int i = 0; i < k; ++i) {
            Node t = pq.top(); pq.pop();
            sum += t.w;
            max_h = max(max_h, t.h);
        }
        total += sum;
        pq.push({sum, max_h + 1});
    }
    printf("%lld\n%lld\n", total, pq.top().h - 1);
    return 0;
}
```

---
处理用时：77.94秒
# 题目信息

# 好消息，坏消息

## 题目描述

Uim 在公司里面当秘书，现在有 $n$ 条消息要告知老板。每条消息有一个好坏度，这会影响老板的心情。告知完一条消息后，老板的心情等于老板之前的心情加上这条消息的好坏度。最开始老板的心情是 $0$，一旦老板心情到了 $0$ 以下就会勃然大怒，炒了 Uim 的鱿鱼。

Uim 为了不被炒，提前知道了这些消息（已经按时间的发生顺序进行了排列）的好坏度，希望知道如何才能不让老板发怒。

Uim 必须按照事件的发生顺序逐条将消息告知给老板。不过 Uim 可以使用一种叫 “倒叙” 的手法，例如有 $n$ 条消息，Uim 可以按 $k,k+1,k+2,\ldots,n,1,2,\ldots,k-1$（事件编号）这种顺序通报。

他希望知道，有多少个 $k$，可以使从 $k$ 号事件开始通报到 $n$ 号事件然后再从 $1$ 号事件通报到 $k-1$ 号事件可以让老板不发怒。

## 说明/提示

**【样例解释】**

通报事件的可行顺序（用编号表示）为 $2\rightarrow3\rightarrow4\rightarrow1$ 或 $3\rightarrow4\rightarrow1\rightarrow2$（分别对应 $k=2$ 和 $k=3$）

通报事件的可行顺序（用好坏度表示）为 $5\rightarrow1\rightarrow2\rightarrow(-3)$ 或 $1\rightarrow2\rightarrow(-3)\rightarrow5$

**【数据范围】**

对于 $25\%$ 的数据，$n\le10^3$；  
对于 $75\%$ 的数据，$n\le10^4$；  
对于 $100\%$ 的数据，$1 \le n\le 10^6$。

## 样例 #1

### 输入

```
4
-3 5 1 2
```

### 输出

```
2

```

# AI分析结果



# 算法分类
**单调队列**

---

## 综合分析与结论
### 核心算法流程
1. **断环为链**：将原数组复制到尾部形成长度为2n-1的链式结构（如样例 `-3 5 1 2` → `-3 5 1 2 -3 5 1`）
2. **前缀和预处理**：计算每个位置的前缀和 `s[i]`
3. **单调队列维护窗口最小值**：
   - 维护一个窗口大小为n的滑动窗口（从k=1到2n-1）
   - 队列中存储索引，保证队首元素始终是当前窗口的最小前缀和
   - 若窗口右边界到达n+k-1时，`s[队首] - s[k-1] ≥ 0` 则k合法

### 可视化设计要点
1. **像素动画方案**：
   - **颜色标记**：
     - 当前窗口（红色边框）
     - 单调队列元素（绿色高亮）
     - 队首最小值（黄色闪烁）
   - **步进控制**：展示窗口右移时队列的弹出队尾（红色消失）、压入新元素（绿色新增）、弹出过期队首（灰色消失）
   - **前缀和变化**：用高度变化的柱状图表示`s[i]`，负值柱体显示为红色

2. **复古游戏化**：
   - 8位音效设计：
     - 元素入队时播放短促"哔"声
     - 找到合法k时播放胜利音效
   - 积分系统：每找到一个合法k得10分，连续找到触发连击特效

---

## 题解清单 (≥4星)
### 1. 憧憬未来（5星）
**亮点**：完整呈现断环为链+单调队列实现，时间复杂度O(n)，代码简洁
```cpp
// 核心代码片段
for(int i=1; i<=2*n-1; i++) {
    while(head<=tail && s[i]<=s[q[tail]]) tail--;
    q[++tail] = i;
    if(i >= n) {
        while(q[head] <= i-n) head++;
        if(s[q[head]] - s[i-n] >=0) ans++;
    }
}
```

### 2. _ztyqwq（4.5星）
**亮点**：O(n)预处理前后缀最小值，无需复杂数据结构
```cpp
// 关键预处理
for(int i=1; i<=n; i++) mq[i] = min(mq[i-1], s[i]);
for(int i=n; i>=1; i--) mh[i] = min(mh[i+1], s[i]);
// 判断逻辑
if(mh[k]-s[k-1]>=0 && mq[k-1]+s[n]-s[k-1]>=0)
```

### 3. Poetic_Rain（4星）
**亮点**：详细推导最小前缀和判断条件，提供暴力→单调队列优化思路
```cpp
// 单调队列维护核心
while(!q.empty() && sum[q.back()]>=sum[i]) q.pop_back();
q.push_back(i);
```

---

## 最优思路提炼
1. **断环技巧**：将环形问题转化为线性问题处理
2. **窗口最值维护**：单调队列在O(n)时间内维护滑动窗口最小值
3. **双指针优化**：通过预处理前后缀极值避免重复计算

---

## 相似题目推荐
1. **P1886 滑动窗口**（单调队列模板）
2. **P2216 [HAOI2007] 理想的正方形**（二维滑动窗口最值）
3. **P1714 切蛋糕**（前缀和+单调队列优化）

---

## 个人心得摘录
> "比赛写少了点东西，挂60..." —— swm_sxt  
> 调试经验：预处理边界时需注意数组越界问题

> "线段树TLE后改用ST表" —— RedreamMer  
> 优化思路：复杂数据结构可能不如简单预处理高效

---

## 可视化代码片段（JS Canvas）
```javascript
// 绘制单调队列状态
function drawQueue(ctx, q, s, current) {
    ctx.fillStyle = "#00FF00";
    q.forEach((idx, i) => {
        if(idx === current) ctx.fillStyle = "#FFFF00";
        drawBar(ctx, i*20, 200 - s[idx]*10, 15, s[idx]*10);
        ctx.fillStyle = "#00FF00";
    });
}

// 音效触发
function playSound(type) {
    if(type === 'enqueue') beep(440, 50);
    if(type === 'valid') playVictoryTune();
}
```

---

## 动画控制逻辑
```javascript
class Animation {
    constructor() {
        this.speed = 100; // ms per step
        this.timer = null;
    }

    step() {
        // 移动窗口右边界
        this.k++;
        this.updateQueue();
        this.draw();
        if(this.k > 2*n) this.stop();
    }

    updateQueue() {
        // 维护单调队列逻辑
        while(tail >= head && s[current] <= s[q[tail]]) tail--;
        q[++tail] = current;
    }
}
```

---
处理用时：74.06秒
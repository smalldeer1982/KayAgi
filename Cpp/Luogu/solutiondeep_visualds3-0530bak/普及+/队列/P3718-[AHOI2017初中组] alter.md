# 题目信息

# [AHOI2017初中组] alter

## 题目描述

有 $n$ 盏灯排成一列，其中有些灯开着，有些灯关着。小可可希望灯是错落有致的，他定义一列灯的状态的不优美度为这些灯中最长的连续的开着或关着的灯的个数。小可可最多可以按开关 $k$ 次，每次操作可以使该盏灯的状态取反：原来开着的就关着，反之开着。现在给出这些灯的状态，求操作后最小的不优美度。

## 说明/提示

$30\%$ 的数据：$1\le k \le n\le20$；

$50\%$ 的数据：$1\le k \le n\le300$；

另有 $15\%$ 的数据：$1\le k \le n\le 10^5$，字符串为全 `N` 或全 `F`；

$100\%$ 的数据：$1\le k \le n\le 10^5$。

本题已经加入 hack 数据。

## 样例 #1

### 输入

```
8 1
NNNFFNNN```

### 输出

```
3```

# AI分析结果



### 算法分类
二分答案 + 贪心

---

### 题解思路与解决难点
#### **核心思路**
题目要求通过最多 `k` 次操作，将灯串的最长连续段长度最小化。采用二分法确定最小可能的最大长度，具体步骤为：
1. **特判 `mid=1`**：此时灯必须交替状态（`N/F` 或 `F/N`），直接验证两种模式是否可行。
2. **二分其他情况**：对于 `mid≥2`，将灯串预处理为连续段数组，计算每个段所需分割次数，总和不超过 `k` 则可行。

#### **解决难点**
- **分割次数公式**：推导出正确公式 `(段长度-1) // mid`，确保每个段分割后长度不超过 `mid`。
- **动态分割的陷阱**：遍历时实时分割可能漏算操作次数，预处理连续段数组更可靠。
- **特判优化**：`mid=1` 时直接枚举两种交替模式，避免复杂计算。

---

### 最优思路与关键技巧
- **二分框架**：快速定位最优解范围。
- **连续段预处理**：将灯串转换为连续段数组，简化计算。
- **数学分割公式**：`(段长度-1) // mid` 确保分割次数准确。
- **交替模式特判**：直接枚举两种可能，避免复杂分割逻辑。

---

### 推荐类似题目
1. **[P2899](https://www.luogu.com.cn/problem/P2899)**: 最小覆盖问题，类似二分答案优化。
2. **[P4344](https://www.luogu.com.cn/problem/P4344)**: 最大连续段限制，需动态调整。
3. **[CF1201B](https://codeforces.com/problemset/problem/1201/B)**: 操作次数与序列调整的最优化。

---

### 题解评分（≥4星）
#### 1. Sooke（4星）
- **亮点**：动态分割策略，实时维护连续段长度，代码简洁。
- **关键代码**：
  ```cpp
  for(int i=0,j=0,l=0; i < n; i++) {
      if(s[j] == s[i]) l++;
      else j=i, l=1;
      if(mid < l) j=i+1, l=0, g++;
  }
  ```
- **分析**：动态处理分割点，但可能在某些情况下漏算操作次数。

#### 2. Happy_Every_day（5星）
- **亮点**：正确分割次数公式，预处理连续段数组。
- **关键代码**：
  ```cpp
  bool check(int x) {
      int sum = 0;
      for (int i=1; i<=cnt; i++)
          sum += (a[i]-1)/x;
      return sum <= k;
  }
  ```
- **分析**：数学推导准确，预处理高效。

#### 3. MyukiyoMekya（5星）
- **亮点**：严格数学公式 `ceil((s - mid) / mid)`，解决动态分割缺陷。
- **关键代码**：
  ```cpp
  for(int i=0; i<dr.size(); ++i)
      if(dr[i]>mid) 
          ans += ceil((dr[i] - mid) / (double)mid);
  ```
- **分析**：公式精确，处理复杂情况无遗漏。

---

### 核心代码实现
```cpp
#include <iostream>
#include <vector>
using namespace std;

int n, k;
string s;

// 预处理连续段数组
vector<int> getSegments() {
    vector<int> seg;
    int cnt = 1;
    for (int i = 1; i < n; i++) {
        if (s[i] == s[i-1]) cnt++;
        else {
            seg.push_back(cnt);
            cnt = 1;
        }
    }
    seg.push_back(cnt);
    return seg;
}

// 检查是否可以通过k次操作使最大段 ≤ mid
bool check(int mid, const vector<int>& seg) {
    if (mid == 1) {
        int p1 = 0, p2 = 0; // 两种交替模式
        for (int i = 0; i < n; i++) {
            if ((i%2 == 0 && s[i] != 'N') || (i%2 == 1 && s[i] != 'F')) p1++;
            if ((i%2 == 0 && s[i] != 'F') || (i%2 == 1 && s[i] != 'N')) p2++;
        }
        return min(p1, p2) <= k;
    }
    int sum = 0;
    for (int len : seg)
        sum += (len - 1) / mid;
    return sum <= k;
}

int main() {
    cin >> n >> k >> s;
    vector<int> seg = getSegments();
    int left = 1, right = n, ans = n;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (check(mid, seg)) {
            ans = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

### 可视化算法分析
#### **动画设计**
- **步骤展示**：灯串逐段高亮，分割点用红色标记，操作次数实时更新。
- **颜色标记**：当前段黄色，已处理段绿色，分割点红色。
- **交互控制**：支持暂停/继续，调整二分速度，对比不同 `mid` 的效果。

#### **复古像素风格**
- **8位渲染**：灯用像素方块表示，N为蓝色，F为橙色。
- **音效**：分割时播放“哔”声，成功/失败对应不同音调。
- **自动演示**：AI模拟二分过程，动态展示分割逻辑。

---

### 总结
通过二分答案与数学推导，结合预处理和特判，高效解决了最小化最长连续段的问题。关键点在于正确分割次数的计算与交替模式的快速验证，确保算法在 `O(n log n)` 时间内完成。

---
处理用时：281.71秒
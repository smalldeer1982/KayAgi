# 题目信息

# [JSOI2007] 建筑抢修

## 题目描述

小刚在玩 JSOI 提供的一个称之为“建筑抢修”的电脑游戏：经过了一场激烈的战斗，T 部落消灭了所有 Z 部落的入侵者。但是 T 部落的基地里已经有 $N$ 个建筑设施受到了严重的损伤，如果不尽快修复的话，这些建筑设施将会完全毁坏。现在的情况是：T 部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N < 150000$，$1 \le T_1 < T_2 < 2^{31}$。

## 样例 #1

### 输入

```
4
100 200
200 1300
1000 1250
2000 3200```

### 输出

```
3```

# AI分析结果



## 算法分类  
**贪心算法**

---

## 综合分析与结论  
### 核心思路与难点
1. **排序策略**：所有建筑按截止时间 `t2` **升序排序**，优先处理快报废的建筑。
2. **贪心替换**：维护一个**大根堆**存储已修建筑的耗时。若当前建筑无法按时修复（总时间超过 `t2`），则用其替换堆顶（已修建筑中耗时最长的），以此减少总耗时，为后续建筑腾出时间。
3. **正确性证明**：替换策略保证修建筑数量不减少，但总耗时更小，后续机会更多。

### 可视化设计思路
- **动画流程**：
  1. 建筑按 `t2` 升序排列，横向时间轴展示每个建筑的 `t2` 位置。
  2. 动态绘制当前总耗时 `sum` 的进度条，堆的图形化表示（方块高度对应耗时）。
  3. 处理当前建筑时高亮其位置，若触发替换，堆顶方块爆炸特效，新方块加入堆。
  4. 音效：修复成功（轻快音效）、替换堆顶（低沉音效）、超时失败（警示音）。
- **复古风格**：使用 8-bit 像素风，堆显示为方块塔，时间轴模仿经典横版游戏场景。

---

## 题解清单 (≥4星)  
1. **作者：_Album_（⭐⭐⭐⭐⭐）**  
   - **亮点**：代码简洁，使用 STL 优先队列，核心逻辑清晰。
2. **作者：Treaker（⭐⭐⭐⭐）**  
   - **亮点**：变量命名简短，代码紧凑，适合快速理解贪心流程。
3. **作者：Refun（⭐⭐⭐⭐）**  
   - **亮点**：详细解释替换策略的正确性，强调“赚数量省时间”的贪心本质。

---

## 最优思路代码实现  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Building { int t1, t2; };
priority_queue<int> heap; // 大根堆维护已修建筑的耗时

int main() {
    int n; cin >> n;
    vector<Building> v(n);
    for (auto &b : v) cin >> b.t1 >> b.t2;
    sort(v.begin(), v.end(), [](auto &a, auto &b) { 
        return a.t2 < b.t2; // 按 t2 升序排序
    });

    long long sum = 0;
    int ans = 0;
    for (auto &b : v) {
        sum += b.t1;
        heap.push(b.t1);
        if (sum <= b.t2) ans++;
        else {
            sum -= heap.top(); // 替换耗时最长的建筑
            heap.pop();
        }
    }
    cout << ans;
}
```

---

## 同类型题与推荐  
1. **P1080 国王游戏**（贪心排序策略）  
2. **P1090 合并果子**（堆的贪心应用）  
3. **P5020 货币系统**（动态规划与贪心结合）

---

## 可视化演示代码（伪代码）  
```javascript
// Canvas 绘制核心逻辑（简化版）
function drawAnimation() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 绘制时间轴与建筑标记
    buildings.forEach((b, i) => {
        drawRect(b.t2_pos, 50, 10, 30, "blue"); // t2 位置
        if (i === currentIndex) highlight(b);    // 当前处理建筑高亮
    });
    // 绘制堆
    heap.forEach((t, i) => {
        drawRect(100, 100 + i*20, t*2, 15, "red"); // 堆方块高度映射耗时
    });
    // 更新总时间进度条
    drawProgressBar(sum);
}
```

---

## 个人心得摘录  
- **约瑟夫用脑玩**：逆向思考时间轴，但实现复杂度较高，不如正序直观。  
- **wwldx**：按最迟开始时间排序需额外维护间隙变量，易出错，验证了按 `t2` 排序的正确性。

---

## 复古游戏化设计  
- **像素风格**：时间轴为绿色地面，建筑为蓝色门，堆为红色砖块塔。  
- **音效**：  
  - 修复成功：8-bit 金币声 🎵  
  - 堆替换：爆炸声 💥  
- **AI 模式**：自动播放时，算法以每秒两步的速度推进，配合音效增强代入感。

---
处理用时：71.83秒
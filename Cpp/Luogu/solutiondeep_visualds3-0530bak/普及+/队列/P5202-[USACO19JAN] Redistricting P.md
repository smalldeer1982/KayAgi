# 题目信息

# [USACO19JAN] Redistricting P

## 题目背景

USACO 19 年一月月赛铂金组第一题。

## 题目描述

奶牛们的特大城市，牛都，要进行重新分区了！——这总是一个在居住在这里的两大主要种族（荷斯坦牛和更赛牛）之间富有争议的政治事件，因为两大种族都想要在牛都政府中保持足够的影响力。

牛都的大都市圈由一列 $n$ 块牧草地组成，每块里有一头奶牛，均为荷斯坦牛 (Holstein) 和更赛牛 (Guernsey) 之一。

牛都政府想要将大都市圈划分为若干个连续的区，使得每个区至少包含一块牧草地且至多包含 $k$ 块牧草地，并且每块牧草地恰好属于一个区。由于政府当前由荷斯坦牛控制，她们想要找到一种分区方式能够最小化更赛牛较多或者均势的区的数量（如果更赛牛的数量与荷斯坦牛的数量相等那么这个区就是均势的）。

有一个关心政治的更赛牛团体想要知道政府的分区计划可能会对她们造成多少损害。帮助她们求出最坏情况，也就是更赛牛较多或是均势的区的最小可能的数量。

## 说明/提示

### 样例解释

一种可能的划分方式是 $[1],~[2, 3],~[4, 5],~[6, 7]$。第二、四个区是均势的区，第三个区是更赛牛优势的区。

### 数据范围

对于 $100\%$ 的数据，保证 $1 \leq k \leq n \leq 3 \times 10^5$，$s$ 的长度为 $n$，且只含字符 `H` 和 `G`。

## 样例 #1

### 输入

```
7 2
HGHGGHG```

### 输出

```
3```

# AI分析结果



## 算法分类
动态规划 + 单调队列优化

---

## 题解思路与核心难点

### 核心思路
1. **状态定义**：`dp[i]` 表示前 `i` 个牧草地的最优划分结果（即更赛牛占优或均势的区数最小值）。
2. **转移方程**：`dp[i] = min{ dp[j] + (sum[i] - sum[j] ≤ 0) }`，其中 `i - j ≤ k`，`sum` 是前缀和（`H` 为 +1，`G` 为 -1）。
3. **单调队列优化**：维护一个单调队列，队首保存最优的 `j` 候选。队列按 `dp[j]` 升序排序，若 `dp[j]` 相同则按 `sum[j]` 升序排序，确保每次取队首元素即可得到最优解。

### 解决难点
- **时间复杂度优化**：朴素 DP 的时间复杂度为 `O(nk)`，通过单调队列维护转移候选集，将时间复杂度降至 `O(n)`。
- **队列维护策略**：
  - **头部维护**：弹出超出窗口范围 `[i-k, i-1]` 的元素。
  - **尾部维护**：插入新元素时，若当前元素 `dp[i]` 更优（或 `sum[i]` 更小），则弹出队尾元素，保持队列单调性。

---

## 题解评分（≥4星）

### 1. 梧桐灯（5星）
- **亮点**：代码简洁高效，时间复杂度 `O(n)`，通过单调队列实现最优解。
- **关键代码**：
  ```cpp
  while (H < T && i - Q[H] > k) ++H; // 维护队列范围
  f[i] = f[Q[H]] + (sum[i] - sum[Q[H]] <= 0);
  while (H < T) { // 维护单调性
      if (f[i] < f[Q[T-1]] || (f[i] == f[Q[T-1]] && sum[i] < sum[Q[T-1]])) --T;
      else break;
  }
  ```

### 2. 荣耀火影（4星）
- **亮点**：优先队列实现，思路清晰，适合理解堆优化逻辑。
- **关键代码**：
  ```cpp
  priority_queue<hhh> q;
  while (q.top().y < i-k) q.pop(); // 维护窗口
  dp[i] = (sum[i] - sum[q.top().y] <= 0) ? q.top().x+1 : q.top().x;
  ```

### 3. lym12（4星）
- **亮点**：代码简洁，直接体现单调队列核心逻辑。
- **关键代码**：
  ```cpp
  while (head <= tail && i - q[head] > k) head++;
  f[i] = f[q[head]] + (sum[i] - sum[q[head]] <= 0);
  ```

---

## 最优思路与技巧
1. **单调队列双关键字排序**：优先按 `dp[j]` 升序，其次按 `sum[j]` 升序，保证后续转移中 `sum[i] - sum[j] ≤ 0` 的概率最大化。
2. **滑动窗口维护**：通过双指针动态维护窗口 `[i-k, i-1]`，确保候选 `j` 的有效性。

---

## 同类题目推荐
1. **P1886 滑动窗口**（单调队列模板题）
2. **P3957 跳房子**（单调队列优化 DP）
3. **P1095 守望者的逃离**（时间窗口动态规划）

---

## 可视化与算法演示设计
### 核心算法流程
1. **初始化**：显示前缀和数组 `sum` 和单调队列状态。
2. **步进演示**：
   - **高亮当前 `i`**：标记当前处理的牧草地位置。
   - **队列维护**：
     - **红色闪烁**：弹出超出窗口的队首元素。
     - **绿色高亮**：插入新元素 `i`，并动态调整队尾。
   - **更新 `dp[i]`**：显示 `dp[i]` 的计算过程和结果。

### 复古像素化设计
- **8位风格**：用像素方块表示 `H`（黄色）和 `G`（蓝色），队列用移动的绿色方块表示。
- **音效设计**：
  - **弹出元素**：短促“哔”声。
  - **插入元素**：清脆“叮”声。
  - **更新 `dp[i]`**：成功音效。
- **自动演示**：按固定速度逐步执行，展示队列动态变化和 `dp` 数组更新。

---

## 核心代码实现（梧桐灯题解）
```cpp
#include <cstdio>
using namespace std;

const int N = 300007;
int n, k, f[N], sum[N], Q[N], H, T;

int main() {
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; ++i) {
        char c = getchar();
        sum[i] = sum[i-1] + (c == 'H' ? 1 : -1);
    }
    Q[T++] = 0;
    for (int i = 1; i <= n; ++i) {
        while (H < T && i - Q[H] > k) ++H;
        f[i] = f[Q[H]] + (sum[i] - sum[Q[H]] <= 0);
        while (H < T) {
            if (f[i] < f[Q[T-1]] || (f[i] == f[Q[T-1]] && sum[i] < sum[Q[T-1]])) --T;
            else break;
        }
        Q[T++] = i;
    }
    printf("%d\n", f[n]);
    return 0;
}
```

---

## 个人心得摘录
- **梧桐灯**：强调队列维护的细节，`sum[j]` 小的元素更优，即使 `dp[j]` 相同。
- **lym12**：调试时发现队列写成普通队列导致错误，提醒注意数据结构选择。

---

## 总结
通过单调队列优化动态规划，将时间复杂度从 `O(nk)` 降至 `O(n)`，是本题的最优解法。关键点在于队列的双关键字排序和窗口的动态维护，适合作为滑动窗口优化 DP 的经典例题。

---
处理用时：84.59秒
# 题目信息

# 「SWTR-3」Golden Sword

## 题目背景

小 E 不幸在一场战斗中失去了他的金宝剑。

## 题目描述

制造一把金宝剑需要 $n$ 种原料，编号为 $1$ 到 $n$，编号为 $i$ 的原料的坚固值为 $a_i$。

炼金是很讲究放入原料的顺序的，因此小 E 必须**按照 $1$ 到 $n$ 的顺序**依次将这些原料放入炼金锅。

但是，炼金锅的容量非常有限，它**最多只能容纳 $w$ 个原料**。

所幸的是，**每放入一个原料之前**，小 E 可以从中取出一些原料，数量不能超过 $s$ 个。

- 我们定义第 $i$ 种原料的耐久度为：放入第 $i$ 种原料时锅内的原料总数（包括正在放入的原料） $\times\ a_i$，则宝剑的耐久度为**所有原料**的耐久度之和。

小 E 当然想让他的宝剑的耐久度尽可能得大，这样他就可以带着它进行更多的战斗，请求出耐久度的最大值。

注：这里的“放入第 $i$ 种原料时锅内的原料总数**包括正在放入锅中的原料**，详细信息请见样例。

## 说明/提示

#### 「样例说明」

- **对于样例 1**，一种可行的**最优**方案为：
首先放进原料 1，此时锅内有 $1$ 种原料，耐久度为 $1\times a_1=1\times 1=1$。  
再放进原料 2，此时锅内有 $2$ 种原料，耐久度为 $2\times a_2=2\times 3=6$。  
再放进原料 3，此时锅内有 $3$ 种原料，耐久度为 $3\times a_3=3\times 2=6$。  
取出原料 1，再放进原料 4，此时锅内有 $3$ 种原料，耐久度为 $3\times a_4=3\times 4=12$。  
取出原料 4，再放进原料 5，此时锅内有 $3$ 种原料，耐久度为 $3\times a_5=3\times 5=15$。  
最终答案为 $1+6+6+12+15=40$。  
- **对于样例 2**，一种可行的**最优**方案为：  
放进原料 1，耐久度为 $1\times 1=1$。  
取出原料 1，放进原料 2，耐久度为 $1\times (-3)=-3$。  
放进原料 3，耐久度为 $2\times (-2)=-4$。  
放进原料 4，耐久度为 $3\times 4=12$。  
取出原料 2，放进原料 5，耐久度为 $3\times 5=15$。  
最终答案为 $1+(-3)+(-4)+12+15=21$。  
- **对于样例 3**，一种可行的**最优**方案为：  
  $a_1+2a_2+2a_3+3a_4+4a_5+3a_6+4a_7=17$。 
- **对于样例 4**，一种可行的**最优**方案为：  
$a_1+a_2+a_3+a_4+a_5=-15$。

#### 「数据范围与约定」

**本题使用捆绑测试。**

- Subtask #1（15 points）：$n\leq 10$。
- Subtask #2（5 points）：$n\leq 100$，$a_i\geq0$。
- Subtask #3（15 points）：$n\leq 300$。
- Subtask #4（15 points）：$s=w=n$。
- Subtask #5（5 points）：$a_i\geq 0$。
- Subtask #6（10 points）：$n\leq 2\times 10^3$。
- Subtask #7（10 points）：$s=1$。
- Subtask #8（25 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \leq s \leq w \leq n \leq 5\times 10^3$，$|a_i| \leq 10^9$。对于 Subtask $i$ 有 $|a_i|\leq 10^{i+1}$。

#### 「帮助/说明」

本题下发大样例，具体输入输出见 [**Big Sample**](https://pan.baidu.com/s/1erVDllDlvNlEShxh3U42gA) 中的 gold01-08.in/gold01-08.out。提取码：757d。  
**文件名与 Subtask 编号一一对应。**

#### 「来源」

[Sweet Round 03 D](https://www.luogu.com.cn/contest/24755)。  
idea & solution：ET2006。

## 样例 #1

### 输入

```
5 3 3
1 3 2 4 5
```

### 输出

```
40```

## 样例 #2

### 输入

```
5 3 3
1 -3 -2 4 5
```

### 输出

```
21```

## 样例 #3

### 输入

```
7 4 2
-5 3 -1 -4 7 -6 5
```

### 输出

```
17```

## 样例 #4

### 输入

```
5 3 1
-1 -3 -2 -4 -5
```

### 输出

```
-15```

# AI分析结果



## 算法分类
动态规划与单调队列优化

---

## 题解思路、算法要点与解决难点
### 核心思路
1. **状态定义**  
   `dp[i][j]` 表示放入前 `i` 个原料后，锅中剩余 `j` 个原料时的最大耐久度总和。

2. **状态转移方程**  
   `dp[i][j] = max{ dp[i-1][k] } + a[i] * j`，其中 `k ∈ [j-1, min(w, j+s-1)]`。  
   每次转移需要从上一状态的有效区间中选取最大值。

3. **单调队列优化**  
   - 按 `j` 从大到小处理，维护一个递减的单调队列，队列中存储 `k` 的候选值。  
   - 插入新元素时，弹出队尾比当前 `dp[i-1][k]` 小的元素以保持队列单调性。  
   - 弹出队头超出当前 `k` 范围的元素以保证窗口有效性。

### 解决难点
- **窗口边界的动态维护**：队列需动态调整以保证 `k` 的范围始终在允许区间内。
- **倒序处理 `j`**：从 `w` 到 `1` 倒序处理 `j`，确保队列中 `k` 的顺序与窗口移动方向一致。

---

## 题解评分（≥4星）
1. **Alex_Wei（5星）**  
   - **亮点**：完整的状态转移推导与单调队列实现，包含边界处理细节。  
   - **代码**：使用滚动数组优化空间，结构清晰。

2. **Bosun（5星）**  
   - **亮点**：简洁的队列维护逻辑，直观展示核心优化步骤。  
   - **代码**：通过 `h` 和 `t` 指针高效管理队列，适合快速理解。

3. **pomelo_nene（4星）**  
   - **亮点**：明确分阶段优化思路，先给出朴素解法再优化。  
   - **代码**：显式维护 `pos` 数组记录队列元素的 `k` 值，便于调试。

---

## 最优思路或技巧提炼
1. **动态规划状态设计**  
   状态需同时包含处理到的原料编号和当前锅中原料数量。

2. **单调队列维护窗口最大值**  
   - 队列存储索引 `k`，保持 `dp[i-1][k]` 单调递减。  
   - 倒序处理 `j` 并插入 `k=j-1`，自然形成滑动窗口。

3. **滚动数组优化**  
   仅保留当前层和上一层的状态，空间复杂度从 `O(nw)` 优化为 `O(w)`。

---

## 同类型题或类似算法套路
- **滑动窗口最值**：如[洛谷 P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)。  
- **决策单调性优化**：如[任务安排（SDOI2012）](https://www.luogu.com.cn/problem/P5785)。

---

## 推荐相似题目
1. [P3957 跳房子](https://www.luogu.com.cn/problem/P3957)  
   （单调队列优化动态规划）
2. [P1725 琪露诺](https://www.luogu.com.cn/problem/P1725)  
   （滑动窗口最值模型）
3. [P2569 股票交易](https://www.luogu.com.cn/problem/P2569)  
   （复杂状态转移中的单调队列优化）

---

## 可视化与算法演示
### 动画设计
1. **动态表格展示**  
   - 行表示当前处理的原料 `i`，列表示锅中数量 `j`。  
   - 当前处理的位置高亮为红色，允许的 `k` 范围标记为蓝色。

2. **队列维护过程**  
   - 队列元素以绿色边框显示，队头元素用黄色强调。  
   - 插入新元素时播放“滴”声，弹出元素时播放“咔嚓”声。

3. **公式同步显示**  
   - 在右侧面板动态显示 `dp[i][j] = max_val + a[i]*j`。

### 复古风格实现
- **像素网格**：使用 16 色调色板绘制表格和队列元素。  
- **音效设计**：8-bit 音效对应队列操作和状态更新。  
- **自动演示模式**：按帧逐步执行，可调节速度观察细节。

---

## 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=5505;
const ll INF=1e18;
ll dp[2][N], a[N];
int q[N], n, w, s;

int main() {
    scanf("%d%d%d", &n, &w, &s);
    for (int i=1; i<=n; i++) scanf("%lld", &a[i]);
    for (int j=0; j<=w; j++) dp[0][j] = -INF;
    dp[0][0] = 0;
    
    for (int i=1; i<=n; i++) {
        int cur = i%2, prev = 1-cur;
        for (int j=0; j<=w; j++) dp[cur][j] = -INF;
        int h=1, t=0;
        for (int j=w; j>=1; j--) {
            int k_limit = min(w, j+s-1);
            while (h<=t && q[h] > k_limit) h++;
            ll val = dp[prev][j-1];
            while (h<=t && dp[prev][q[t]] <= val) t--;
            q[++t] = j-1;
            if (h <= t) dp[cur][j] = dp[prev][q[h]] + a[i]*j;
        }
    }
    
    ll ans = -INF;
    for (int j=1; j<=w; j++) ans = max(ans, dp[n%2][j]);
    printf("%lld\n", ans);
    return 0;
}
```

---

## 个人心得摘录
- **边界处理**：队列初始化和 `k` 的范围判断容易出错，需严格验证。  
- **倒序处理**：发现 `j` 必须倒序处理是优化关键，正序会导致队列维护困难。  
- **滚动数组**：节省空间的同时需注意状态切换的同步性。

---
处理用时：270.94秒
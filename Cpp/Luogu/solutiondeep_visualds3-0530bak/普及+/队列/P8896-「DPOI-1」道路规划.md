# 题目信息

# 「DPOI-1」道路规划

## 题目背景

不可以，总司令。

## 题目描述

战场上有 $n$ 个据点，从 $1\sim n$ 编号。**每两个据点**之间**都**有一条双向道路。

一天，总司令来战区巡视，走着走着迷路了，于是愤怒地下达命令，让你把每一条双向道路变成单向的，使得这些道路**不包含环**（否则总司令会迷路）。但由于每个据点的规模互不相同，总司令从第 $i$ 个据点出发沿着单向道路能**直接到达**的据点数量需要在 $[l_i,r_i]$ 之间。换言之，第 $i$ 个点的出度需要在 $[l_i,r_i]$ 之间。你需要告诉总司令有没有可能满足他的需求。

## 说明/提示

#### 样例 #1 解释
下面是第 $1$ 组数据中一种可行的方案：

![](https://cdn.luogu.com.cn/upload/image_hosting/2uvwlydw.png)

#### 样例 #2 解释
该样例满足测试点 $3 \sim 6$ 的限制。
#### 数据范围
**本题测试点分数不等分。**

|  测试点编号  | $n \le$ | 特殊条件 |每个测试点分数|
| :----------: | :-----------: | :------: | :----: |
|     $1\sim 2$      |     $10$     |   无   |$5$|
|     $3\sim 6$      |     $1000$     |    无     |$5$|
|     $7\sim 8$      |     $10^5$     |    所有 $l_i = i-1$ 或所有 $l_i \geq \min (i, n - 1)$    |$5$|
| $9 \sim 10$  | $10^5$ | $l_i=0$ 或 $r_i=n-1$ |$5$|
| $11 \sim 15$ | $10^5$ | 无 |$10$|

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 \leq l_i \leq r_i < n$，$1 \leq T \leq 10$。

## 样例 #1

### 输入

```
2
5
0 1 4 0 0
3 4 4 1 3
3
1 2 2
2 2 2```

### 输出

```
YES
NO```

## 样例 #2

### 输入

```
见下发文件 road2.in```

### 输出

```
见下发文件 road2.out```

# AI分析结果



---

**唯一算法分类**：贪心算法+优先队列

---

### **综合分析与结论**

**题目核心**：将完全图定向为DAG，并满足每个点的出度区间限制。  
**关键转换**：DAG的拓扑序唯一，出度由拓扑序位置决定（第i个点的出度为n-i）。问题转化为区间匹配问题，即找到排列使得每个数在对应区间内。  

**算法流程**：  
1. **区间转换**：将出度区间转换为拓扑序位置的区间（如原题中的l_i对应拓扑序位置的下界）。  
2. **贪心策略**：按拓扑序从小到大处理每个点，将左端点≤当前点的区间右端点存入小根堆，每次取最小右端点匹配当前点。若无法匹配则无解。  

**难点与解决**：  
- **正确性证明**：贪心选择最小右端点不会导致后续无法匹配（交换论证法）。  
- **高效实现**：利用优先队列（小根堆）动态维护可用区间右端点。  

**可视化设计**：  
- **动画流程**：以网格显示拓扑序处理过程，当前点高亮为红色，可用区间右端点在堆中显示为黄色，选中右端点标记为绿色。  
- **复古像素风**：使用8-bit风格，背景音乐为循环芯片音乐，关键操作（入堆、出堆）触发不同音效。  
- **交互控制**：支持暂停/继续、步进执行，速度可调。  

---

### **题解清单（4星及以上）**

1. **kevinchw（5星）**  
   - **亮点**：思路清晰，代码简洁，详细证明贪心正确性。  
   - **代码片段**：  
     ```cpp  
     priority_queue<int, vector<int>, greater<int>> q;  
     for (int i=1; i<=n; i++) v[a[i].l].pb(a[i].r);  
     for (int i=1; i<=n; i++) {  
         for (auto r : v[i]) q.push(r);  
         if (q.empty() || q.top()<i) return NO;  
         q.pop();  
     }  
     ```

2. **DengDuck（4星）**  
   - **亮点**：提供拓扑序唯一性证明，代码简洁高效。  
   - **代码片段**：  
     ```cpp  
     priority_queue<int, vector<int>, greater<int>> Q;  
     for (int i=0; i<n; i++) {  
         for (auto r : V[i]) Q.push(r);  
         if (Q.empty() || Q.top()<i) return NO;  
         Q.pop();  
     }  
     ```

3. **AK_400（4星）**  
   - **亮点**：从度数相等角度证明必要性，代码实现简洁。  
   - **代码片段**：  
     ```cpp  
     multiset<int> s;  
     for (int i=0; i<n; i++) {  
         for (auto r : v[i]) s.insert(r);  
         if (s.empty() || *s.begin()<i) return NO;  
         s.erase(s.begin());  
     }  
     ```

---

### **最优思路提炼**

1. **关键步骤**：  
   - **拓扑序转换**：出度由拓扑序位置唯一确定。  
   - **区间映射**：将出度区间[l_i, r_i]转换为拓扑序位置的区间。  
   - **贪心匹配**：按拓扑序从小到大处理，每次取最小右端点。  

2. **数据结构**：小根堆动态维护可用右端点，确保每次选择最优区间。  

---

### **同类型题推荐**

1. **P1250 种树**：区间覆盖问题，贪心选择右端点最小位置。  
2. **P1842 [USACO05NOV]奶牛玩杂技**：贪心排序证明。  
3. **P4059 [Code+#1]找爸爸**：动态规划与贪心结合。  

---

### **核心代码实现**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+5;

int T, n, l[N], r[N];
vector<int> intervals[N];

bool solve() {
    priority_queue<int, vector<int>, greater<int>> pq;
    for (int i = 0; i < n; i++) {
        for (int r : intervals[i]) pq.push(r);
        if (pq.empty() || pq.top() < i) return false;
        pq.pop();
    }
    return true;
}

int main() {
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &n);
        for (int i = 0; i <= n; i++) intervals[i].clear();
        for (int i = 0; i < n; i++) scanf("%d", &l[i]);
        for (int i = 0; i < n; i++) {
            scanf("%d", &r[i]);
            intervals[l[i]].push_back(r[i]);
        }
        puts(solve() ? "YES" : "NO");
    }
    return 0;
}
```

---

### **可视化与算法演示**

**动画设计**：  
1. **像素网格**：每个点表示为网格中的方块，颜色表示状态（待处理/已处理）。  
2. **堆操作**：入堆时右端点方块上升至堆区域，出堆时方块飞向当前处理点。  
3. **音效**：  
   - **正确匹配**：8-bit清脆音效。  
   - **错误**：低沉蜂鸣声。  

**交互功能**：  
- **速度滑块**：调整动画帧率（1x~10x）。  
- **自动模式**：AI自动执行，模拟贪心过程。  

---

**总结**：本题通过拓扑序转换和贪心匹配高效解决，核心在于利用优先队列维护区间右端点，确保每一步选择最优解。

---
处理用时：80.09秒
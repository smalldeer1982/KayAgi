# 题目信息

# 【模板】有理数取余

## 题目描述

给出一个有理数 $c=\frac{a}{b}$，求 $c \bmod 19260817$ 的值。

这个值被定义为 $bx\equiv a\pmod{19260817}$ 的解。

## 说明/提示

对于所有数据，保证 $0\leq a \leq 10^{10001}$，$1 \leq b \leq 10^{10001}$，且 $a, b$ 不同时是 $19260817$ 的倍数。

## 样例 #1

### 输入

```
233
666
```

### 输出

```
18595654
```

# AI分析结果



**唯一算法分类**：模运算与逆元

---

### **题解思路、算法要点与解决难点**

1. **核心逻辑**  
   所有题解均基于以下关键转换：  
   $$ c \equiv \frac{a}{b} \equiv a \cdot b^{-1} \pmod{p} $$  
   其中 $b^{-1}$ 是 $b$ 的模 $p$ 逆元，即 $b \cdot b^{-1} \equiv 1 \pmod{p}$。  
   **核心难点**在于高效处理超大数 $a,b$ 的输入，并正确计算逆元。

2. **输入优化**  
   所有题解均采用**边读入边取模**的方法避免高精度运算：  
   ```cpp
   int read_mod() {
       int res = 0;
       char c;
       while (isdigit(c = getchar())) 
           res = (res * 10 + (c - '0')) % MOD;
       return res;
   }
   ```

3. **逆元计算**  
   - **扩展欧几里得法**（学委、qsmoonzh 等）：求解方程 $bx + py = 1$，返回 $x$。  
   - **费马小定理法**（顾z、STPGUY 等）：利用 $b^{-1} \equiv b^{p-2} \pmod{p}$ 快速幂计算。

---

### **题解评分 (≥4星)**

| 作者      | 星级 | 关键亮点                                                                 |
|-----------|------|--------------------------------------------------------------------------|
| 学委      | ⭐⭐⭐⭐ | 完整推导逆元逻辑，exgcd 实现清晰，输入优化简洁                           |
| 顾z       | ⭐⭐⭐⭐ | 代码极简，费马小定理快速幂实现，适合模数为质数的场景                     |
| qsmoonzh  | ⭐⭐⭐⭐ | 扩展欧几里得法详解，代码包含输入优化与负数处理                           |

---

### **最优思路与技巧提炼**

1. **输入优化技巧**  
   ```cpp
   // 边读入边取模，避免高精度
   while (isdigit(c)) res = (res * 10 + (c - '0')) % MOD;
   ```

2. **逆元选择策略**  
   - **质数模数**：优先费马小定理（代码更短）。  
   - **通用模数**：扩展欧几里得法（无需模数为质数）。

3. **代码片段（费马小定理法）**  
   ```cpp
   long long inv = 1, base = b;
   for (int k = MOD-2; k; k >>= 1) {
       if (k & 1) inv = inv * base % MOD;
       base = base * base % MOD;
   }
   ans = a * inv % MOD;
   ```

---

### **同类型题与算法套路**

- **通用解法**：模运算转换 → 输入优化 → 逆元计算 → 输出结果。  
- **类似题目**：  
  1. [P1082 同余方程](https://www.luogu.org/problem/P1082)（扩展欧几里得模板）  
  2. [P3811 乘法逆元](https://www.luogu.org/problem/P3811)（逆元批量计算）  
  3. [P2613 有理数取余](https://www.luogu.org/problem/P2613)（本题）

---

### **可视化与算法演示**

1. **动画设计**  
   - **输入阶段**：像素风格字符逐位输入，右侧显示当前累加值 $res$ 和取模后的数值。  
   - **逆元计算**：  
     - **费马小定理**：展示快速幂的二进制分解过程，高亮当前指数位和中间结果。  
     - **扩展欧几里得**：动态演示递归栈，显示每一步的 $a,b,x,y$ 值。  
   - **结果输出**：显示 $a \cdot b^{-1} \pmod{p}$ 的最终计算结果，伴随“成功”音效。

2. **复古像素效果**  
   - **8位音效**：  
     - 字符输入时播放短促的“滴”声。  
     - 计算完成时播放经典 FC 过关音效。  
   - **Canvas 动画**：  
     - 使用 16x16 像素网格绘制数字输入流。  
     - 逆元计算时，快速幂的指数以二进制 LED 灯形式闪烁。

---

### **代码实现（核心逻辑）**

```cpp
const int MOD = 19260817;

// 费马小定理法求逆元
long long qpow(long long a, int b) {
    long long res = 1;
    for (; b; b >>= 1, a = a * a % MOD)
        if (b & 1) res = res * a % MOD;
    return res;
}

int main() {
    int a = read_mod(); // 边读边取模
    int b = read_mod();
    if (b == 0) { puts("Angry!"); return 0; }
    printf("%lld\n", a * qpow(b, MOD-2) % MOD);
}
```

---

### **个人心得摘录**

- **学委**：强调“边读入边取模”是处理超大数的关键，避免高精度计算。  
- **顾z**：提醒特判 $b=0$ 时需输出 `Angry!`，调试时易漏掉感叹号。  
- **qsmoonzh**：指出输入优化需注意字符到数字的转换，避免符号处理错误。

---

**总结**：本题通过模运算性质将分数取余转换为逆元问题，结合输入优化与逆元算法（exgcd/费马小定理）高效解决。可视化设计可增强对模运算和逆元计算过程的理解。

---
处理用时：77.16秒
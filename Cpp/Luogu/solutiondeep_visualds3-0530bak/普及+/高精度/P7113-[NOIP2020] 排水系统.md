# 题目信息

# [NOIP2020] 排水系统

## 题目描述

对于一个城市来说，排水系统是极其重要的一个部分。

有一天，小 C 拿到了某座城市排水系统的设计图。排水系统由 $n$ 个排水结点（它们从 $1 \sim n$ 编号）和若干个单向排水管道构成。每一个排水结点有若干个管道用于汇集其他排水结点的污水（简称为该结点的汇集管道），也有若干个管道向其他的排水结点排出污水（简称为该结点的排出管道）。

排水系统的结点中有 $m$ 个污水接收口，它们的编号分别为 $1, 2, \ldots , m$，污水只能从这些接收口流入排水系统，并且这些结点没有汇集管道。排水系统中还有若干个最终排水口，它们将污水运送到污水处理厂，没有排出管道的结点便可视为一个最终排水口。

现在各个污水接收口分别都接收了 $1$ 吨污水，污水进入每个结点后，会均等地从当前结点的每一个排出管道流向其他排水结点，而最终排水口将把污水排出系统。

现在小 C 想知道，在该城市的排水系统中，每个最终排水口会排出多少污水。该城市的排水系统设计科学，管道不会形成回路，即不会发生污水形成环流的情况。

## 说明/提示

**【样例 #1 解释】**

$1$ 号结点是接收口，$4, 5$ 号结点没有排出管道，因此是最终排水口。  
$1$ 吨污水流入 $1$ 号结点后，均等地流向 $2, 3, 5$ 号结点，三个结点各流入 $\frac{1}{3}$ 吨污水。  
$2$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
$3$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
最终，$4$ 号结点排出 $\frac{1}{6} + \frac{1}{6} = \frac{1}{3}$ 吨污水，$5$ 号结点排出 $\frac{1}{3} + \frac{1}{6} + \frac{1}{6} = \frac{2}{3}$ 吨污水。

**【数据范围】**

| 测试点编号 | $n \le$ | $m \le$ |
|:-:|:-:|:-:|
| $1 \sim 3$ | $10$ | $1$ |
| $4 \sim 6$ | ${10}^3$ | $1$ |
| $7 \sim 8$ | ${10}^5$ | $1$ |
| $9 \sim 10$ | ${10}^5$ | $10$ |

对于全部的测试点，保证 $1 \le n \le {10}^5$，$1 \le m \le 10$，$0 \le d_i \le 5$。

数据保证，污水在从一个接收口流向一个最终排水口的过程中，不会经过超过 $10$ 个中间排水结点（即接收口和最终排水口不算在内）。

## 样例 #1

### 输入

```
5 1
3 2 3 5
2 4 5
2 5 4
0
0
```

### 输出

```
1 3
2 3
```

## 样例 #2

### 输入

```
见附件中的 water/water2.in```

### 输出

```
见附件中的 water/water2.ans```

## 样例 #3

### 输入

```
见附件中的 water/water3.in```

### 输出

```
见附件中的 water/water3.ans```

# AI分析结果



### 唯一算法分类
拓扑排序

---

### 题解思路与算法要点
**核心逻辑**：所有题解均采用拓扑排序处理 DAG 的节点顺序，保证污水流动的正确性。分数运算通过分子分母通分与约分实现，避免高精度问题。关键点如下：
1. **拓扑排序**：初始化入度为 0 的节点（污水入口）入队，按顺序处理每个节点分流水量至子节点。
2. **分数运算**：使用 `__int128` 存储分子分母，每次加法后通过最大公约数（GCD）约分。
3. **分母优化**：每次分流时，子节点分母乘以父节点出度，避免重复计算。
4. **最终输出**：仅处理出度为 0 的节点，输出其约分后的分子分母。

**解决难点**：
- **分数溢出**：通过 `__int128` 处理大数，避免高精度计算复杂度。
- **正确分流顺序**：拓扑排序确保父节点处理完毕后再处理子节点。

---

### 题解评分（≥4星）

1. **听取MLE声一片（4.5星）**  
   - 亮点：拓扑排序实现简洁，分数通分逻辑清晰。  
   - 代码可读性高，但未处理高精度，适合学习核心思路。

2. **lcyxds（4星）**  
   - 亮点：预计算分母可能的因数，优化分数存储。  
   - 复杂度较高，但思路独特，适合深入理解分数处理。

3. **hensier（4星）**  
   - 亮点：DFS/BFS 与拓扑排序对比，代码中 `__int128` 使用规范。  
   - 提供完整通分函数，适合调试参考。

---

### 最优思路与技巧提炼
1. **拓扑排序核心流程**  
   ```python
   q = 入度为0的节点队列
   while q不为空:
       u = q.pop()
       for v in u的子节点:
           更新v的分子分母（u的分数 / u的出度）
           v的入度减1
           if v的入度为0:
               q.push(v)
   ```
2. **分数处理技巧**  
   - 每次加法：$\frac{a}{b} + \frac{c}{d} = \frac{ad + bc}{bd}$，随后约分。
   - 分流时：分母直接乘父节点出度，减少中间计算。

---

### 同类型题与算法套路
- **类似算法**：DAG 上的动态规划（如任务调度、依赖解析）。
- **推荐题目**：  
  - P1038（神经网络）  
  - P1983（车站分级）  
  - P1137（旅行计划）

---

### 可视化与算法演示
**动画设计**：
1. **拓扑排序流程**：  
   - **颜色标记**：当前处理节点（红色）、已处理节点（绿色）、待处理节点（灰色）。  
   - **步进控制**：点击按钮单步执行，观察队列变化。
2. **分数更新**：  
   - 子节点分数变化时，显示通分公式 $\frac{a}{b} + \frac{c}{d \cdot k}$。  
   - 高亮分子分母的变化数值。
3. **复古像素风格**：  
   - 使用 8-bit 风格网格，节点用方块表示，边用箭头连接。  
   - 音效：处理节点时播放“滴答”声，完成时播放胜利音效。

**代码片段（Canvas 绘制节点）**：
```javascript
function drawNode(ctx, x, y, value, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y, 30, 30); // 像素方块
    ctx.fillStyle = 'white';
    ctx.fillText(value, x + 10, y + 20);
}
```

---

### 推荐类似题目
1. **P1038 神经网络**（拓扑排序 + 阈值计算）  
2. **P1983 车站分级**（拓扑排序确定层级）  
3. **P4017 最大食物链计数**（DAG 路径统计）

---

### 个人心得摘录
> "考场差点写挂 gcd 函数，分母为 0 会导致 RE。" —— 听取MLE声一片  
> "用 __int128 代替高精度，代码量减少 50%！" —— hensier

---

### 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
using i128 = __int128;

struct Frac { i128 x, y; };
vector<int> G[100005];
i128 gcd(i128 a, i128 b) { return b ? gcd(b, a % b) : a; }

void add(Frac &a, Frac b) {
    i128 g = gcd(b.y, a.y);
    i128 lcm = a.y / g * b.y;
    a.x = a.x * (lcm / a.y) + b.x * (lcm / b.y);
    a.y = lcm;
    g = gcd(a.x, a.y);
    a.x /= g; a.y /= g;
}

void topo(int n, int m) {
    queue<int> q;
    vector<Frac> f(n+1, {0, 1});
    vector<int> in(n+1, 0), out(n+1, 0);

    for (int i=1; i<=n; ++i) {
        for (int v : G[i]) in[v]++, out[i]++;
        if (in[i] == 0) f[i] = {1, 1}, q.push(i);
    }

    while (!q.empty()) {
        int u = q.front(); q.pop();
        if (G[u].empty()) continue;
        Frac delta = {f[u].x, f[u].y * G[u].size()};
        for (int v : G[u]) {
            add(f[v], delta);
            if (--in[v] == 0) q.push(v);
        }
    }

    for (int i=1; i<=n; ++i) 
        if (out[i] == 0) {
            i128 g = gcd(f[i].x, f[i].y);
            cout << (ll)(f[i].x/g) << ' ' << (ll)(f[i].y/g) << '\n';
        }
}
```

---
处理用时：86.01秒
# 题目信息

# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 说明/提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)

题目中没有强制 $i \neq j$，但是实测数据中不存在 $i = j$ 的情况。

## 样例 #1

### 输入

```
4
M 2 3
C 1 2
M 2 4
C 4 2```

### 输出

```
-1
1```

# AI分析结果



# 算法分类
**带权并查集**

---

## 综合分析与结论

### 核心思路与算法要点
1. **带权并查集的核心设计**  
   - 每个节点维护两个核心变量：  
     - `front[x]`：节点 x 到所在队列队首的"距离"（中间隔了多少战舰）  
     - `size[x]`：以 x 为根节点的队列长度（仅在根节点有意义）  
   - 路径压缩时通过递归回溯更新 `front` 值，实现动态权值维护  

2. **合并操作的关键逻辑**  
   - 合并队列 A 到队列 B 的尾部时：  
     - 将 A 的根节点 `fx` 的 `front` 设为 B 的队列长度 `size[fy]`  
     - 更新 B 的队列长度 `size[fy] += size[fx]`  
   - 图示：将 `fx` → `fy` 的边权设为 `size[fy]`，后续路径压缩时自动传播该权值  

3. **查询操作的数学推导**  
   - 若两节点 x 和 y 同属一个队列，其间距为：  
     `abs(front[x] - front[y]) - 1`  
   - 时间复杂度：近似 O(α(n))，得益于路径压缩和按秩合并  

### 可视化设计思路（像素化方案）
1. **数据结构展示**  
   - 用 **16x16 像素网格** 表示战舰队列，每个战舰显示编号和到队首的距离  
   - 合并时用 **绿色箭头** 动态连接两个队列，辅以 `size` 数值变化动画  

2. **路径压缩动画**  
   - 递归路径压缩时，当前节点到根节点的路径逐步缩短，`front` 值实时更新  
   - 高亮变化节点，并伴随 8-bit 音效（类似红白机菜单选择声）  

3. **交互功能**  
   - **步进模式**：按空格键单步执行合并/查询操作  
   - **自动演示**：算法自动运行，展示典型测试案例的执行流程  
   - **音效反馈**：成功查询时播放上扬音调，合并失败时播放低音提示  

---

## 题解清单（≥4星）

### 1. 假装思考（★★★★★）
**核心亮点**  
- 清晰定义 `front[]` 和 `num[]`（即 `size[]`），代码简洁高效  
- 路径压缩时通过递归回溯更新权值，逻辑严密  
- 完整代码通过洛谷测试且效率优异（最大点 610ms）  

**关键代码片段**  
```cpp
int find(int n) {
    if(fa[n]==n) return fa[n];
    int fn = find(fa[n]); // 先递归找祖先
    front[n] += front[fa[n]]; // 回溯时更新权值
    return fa[n] = fn;
}
```

### 2. Mr_Wolfram（★★★★☆）
**核心亮点**  
- 引入 `dis[]` 和 `num[]`，变量命名更直观  
- 独立 `merge()` 和 `query()` 函数，模块化清晰  
- 代码注释详细，适合教学参考  

**优化点**  
- 缺少路径压缩时的权值更新注释，可读性稍逊  

### 3. 干物国大皇帝（★★★★）
**个人心得摘录**  
> “路径压缩时维护的 `d[x]` 本质是动态前缀和，每次 find 操作都是对权值的重新校准。调试时通过打印 `d[]` 数组发现了合并顺序错误...”  

**代码亮点**  
- 结构体封装并查集属性，提高代码可维护性  
- 使用 `abs()` 直接处理负数情况，逻辑简洁  

---

## 同类型题与算法套路

### 通用解法
1. **带权并查集三要素**  
   - 权值定义（如本题的 `front`）  
   - 路径压缩时的权值传递公式  
   - 合并操作时的权值修正规则  

2. **变形场景**  
   - 环形依赖（如 P2024 食物链）  
   - 区间合并（如 P1955 程序自动分析）  

### 推荐题目
1. **P2024 食物链**  
   - 权值表示物种关系（模3运算）  

2. **P1525 关押罪犯**  
   - 并查集维护敌对关系  

3. **P5937  Parity Game**  
   - 权值表示奇偶性，区间查询转前缀和  

---

## 核心代码实现

```cpp
#include <iostream>
#include <cmath>
using namespace std;

const int MAXN = 30010;
int fa[MAXN], front[MAXN], size[MAXN];

int find(int x) {
    if (fa[x] != x) {
        int root = find(fa[x]);
        front[x] += front[fa[x]]; // 权值累加
        fa[x] = root; // 路径压缩
    }
    return fa[x];
}

void merge(int x, int y) {
    int fx = find(x), fy = find(y);
    if (fx == fy) return;
    fa[fx] = fy;
    front[fx] = size[fy]; // 关键权值设定
    size[fy] += size[fx];
}

int query(int x, int y) {
    if (find(x) != find(y)) return -1;
    return abs(front[x] - front[y]) - 1;
}

int main() {
    int T;
    cin >> T;
    for (int i = 1; i < MAXN; ++i) {
        fa[i] = i;
        size[i] = 1;
    }
    while (T--) {
        char op;
        int a, b;
        cin >> op >> a >> b;
        if (op == 'M') merge(a, b);
        else cout << query(a, b) << endl;
    }
    return 0;
}
```

---

## 可视化代码片段（Canvas动画）

```javascript
// 战舰队列绘制（简化版）
function drawQueue(root, ctx) {
    let current = root;
    let x = 50, y = 100;
    while (current !== null) {
        // 绘制战舰方块
        ctx.fillStyle = "#8B0000"; // 深红色
        ctx.fillRect(x, y, 40, 40);
        // 显示编号和front值
        ctx.fillStyle = "white";
        ctx.fillText(`${current.id} (${current.front})`, x+5, y+25);
        x += 50;
        current = current.next;
    }
}

// 合并动画
async function animateMerge(fx, fy) {
    const duration = 1000; // 动画持续1秒
    const startX = fx.x, startY = fx.y;
    for (let t = 0; t <= duration; t += 20) {
        fx.x = startX + (fy.x - startX) * (t / duration);
        fx.y = startY + (fy.y - startY) * (t / duration);
        await new Promise(r => setTimeout(r, 20));
        redrawCanvas(); // 重绘画面
    }
    playSound('merge_success.wav'); // 合并成功音效
}
```

---
处理用时：87.75秒
# 题目信息

# 烦恼的高考志愿

## 题目背景

计算机竞赛小组的神牛 V 神终于结束了高考，然而作为班长的他还不能闲下来，班主任老 t 给了他一个艰巨的任务：帮同学找出最合理的大学填报方案。可是 v 神太忙了，身后还有一群小姑娘等着和他约会，于是他想到了同为计算机竞赛小组的你，请你帮他完成这个艰巨的任务。


## 题目描述

现有 $m$ 所学校，每所学校预计分数线是 $a_i$。有 $n$ 位学生，估分分别为 $b_i$。

根据 $n$ 位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差最小（可高可低，毕竟是估分嘛），这个最小值为不满意度。求所有学生不满意度和的最小值。


## 说明/提示

数据范围：

对于 $30\%$ 的数据，$1\leq n,m\leq1000$，估分和录取线 $\leq10000$；

对于 $100\%$ 的数据，$1\leq n,m\leq100000$，估分和录取线 $\leq 1000000$ 且均为非负整数。


## 样例 #1

### 输入

```
4 3
513 598 567 689
500 600 550
```

### 输出

```
32```

# AI分析结果



## **算法分类**
二分

---

## **题解思路与算法要点**
### **核心思路**
- **排序预处理**：将学校分数线排序，便于后续二分查找。
- **二分查找**：针对每个学生的估分，在有序数组中查找最接近的两个分数线，取差值最小者累加。

### **解决难点**
1. **边界处理**：
   - 学生分数低于所有学校分数线时，取最小分数线。
   - 学生分数高于所有学校分数线时，取最大分数线。
   - 使用 `lower_bound` 或手动二分时，需检查返回位置的前后元素。

2. **二分实现**：
   - **搜索目标**：找到第一个大于等于学生估分的学校分数线位置。
   - **区间收缩**：根据 `a[mid]` 与学生估分的大小关系调整左右边界。
   - **退出条件**：当 `left` 和 `right` 收敛到相邻位置时终止循环。

---

## **题解评分（≥4星）**
1. **Viston（5星）**
   - 亮点：使用 `lower_bound` 简化代码，边界处理清晰，代码简洁高效。
2. **06ray（4星）**
   - 亮点：手动二分实现，详细注释，特判处理避免越界。
3. **AK_黄铮_IMO（4星）**
   - 亮点：结合 `lower_bound` 与极值哨兵，避免显式特判。

---

## **最优思路与技巧**
### **关键代码（STL lower_bound）**
```cpp
sort(a, a + m); // 学校分数线排序
for (int i = 0; i < n; i++) {
    int x = student[i];
    int pos = lower_bound(a, a + m, x) - a; // 第一个≥x的位置
    int ans = 0;
    if (pos == 0) ans = a[0] - x;           // 所有学校分数更高
    else if (pos == m) ans = x - a[m-1];     // 所有学校分数更低
    else ans = min(a[pos] - x, x - a[pos-1]); // 取前后较小差值
    sum += ans;
}
```

### **技巧总结**
- **哨兵技巧**：在数组首尾添加极值（如 `INT_MIN` 和 `INT_MAX`），避免显式边界检查。
- **STL 优化**：利用 `lower_bound` 快速定位，减少手写二分错误风险。
- **双指针贪心**：若学生和学校均排序，可用单指针遍历，复杂度接近 `O(n + m)`。

---

## **同类型题目与算法套路**
### **类似算法**
- **二分答案**：如求最小化最大值（P2678 跳石头）。
- **二分查找边界**：如有序数组中找插入位置（P1102 A-B数对）。
- **混合排序后遍历**：如合并两个有序数组（需处理相邻元素）。

### **推荐题目**
1. **P2678 跳石头**（二分答案，最小化跳跃距离）
2. **P1024 一元三次方程求解**（二分法求根）
3. **P1102 A-B数对**（统计差值为定值的数对）

---

## **可视化与算法演示**
### **二分过程动画设计**
1. **像素化数组显示**：
   - 用网格表示排序后的学校分数线，颜色区分区间。
   - **当前 `mid`**：红色高亮。
   - **搜索区间 `[left, right]`**：蓝色边框标记。

2. **交互与音效**：
   - **步进控制**：点击按钮单步执行，显示 `left/right/mid` 变化。
   - **音效触发**：
     - `mid` 更新：8-bit 短音。
     - 找到结果：成功音效（上扬音调）。
   - **自动模式**：AI 自动执行，模拟二分收敛过程。

3. **复古风格**：
   - **背景**：16色像素风格，类似 FC 游戏界面。
   - **控制面板**：复古按钮（暂停/继续/重置）。

---

## **代码实现（关键部分）**
```javascript
// 伪代码：二分动画核心逻辑
function binarySearchVisual(target) {
    let left = 0, right = n - 1;
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        highlight(mid, 'red'); // 高亮 mid
        playSound('beep');     // 音效
        if (a[mid] < target) {
            left = mid + 1;    // 收缩左边界
            updateBoundary(left, right);
        } else {
            right = mid - 1;   // 收缩右边界
            updateBoundary(left, right);
        }
    }
    // 比较相邻元素
    const ans = Math.min(...);
    showResult(ans);
}
```

---

## **个人心得**
- **调试教训**：初始未处理 `lower_bound` 返回 `m` 的情况，导致数组越界。
- **顿悟点**：混合排序后双指针遍历，可避免二分但需严格单调性。
- **总结**：边界处理是二分法的核心，极值哨兵能显著简化代码。

---
处理用时：100.25秒
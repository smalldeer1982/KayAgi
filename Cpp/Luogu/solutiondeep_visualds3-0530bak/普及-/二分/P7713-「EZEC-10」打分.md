# 题目信息

# 「EZEC-10」打分

## 题目背景

**为防止评测机被卡，本题时限为 100 ms。**

## 题目描述

小 A 去参加奥运会。

奥运会中共有 $n$ 名裁判，分别给小 A 打分 $a_1,a_2,\ldots,a_n$。

小 A 对自己的得分不满意，于是他将某名裁判打出的分数加 $1$，称为一次操作。

但是小 A 不能太贪心，他最多只能进行 $m$ 次操作。

小 A 的最终得分为：所有得分中，去掉一个最高分和一个最低分后的平均值。

小 A 想知道，他的最终得分最高为多少。

## 说明/提示

**【样例 1 解释】**

一种可行的方案为：$[1,2,3]\to [3,2,3]$。

**【样例 2 解释】**

一种可行的方案为：$[1,2,2,3]\to [2,3,3,3]$。

**【数据规模与约定】**

**本题采用捆绑测试。**

- Subtask 1（5 points）：$m=0$。
- Subtask 2（10 points）：$n=3$。
- Subtask 3（15 points）：$n,m\le 10^3$。
- Subtask 4（70 points）：无特殊限制。

对于 $100\%$ 的数据，$3\le n\le 10^5$，$0\le m,a_i\le 10^9$。

## 样例 #1

### 输入

```
3 2
1 2 3```

### 输出

```
3```

## 样例 #2

### 输入

```
4 3
1 2 2 3```

### 输出

```
6```

# AI分析结果



**唯一算法分类**  
无算法分类（贪心策略）

---

**综合分析与结论**  
题目核心在于通过贪心策略最大化中间部分的总和。主要步骤如下：

1. **排序数组**：将裁判分数排序，便于处理最高/最低分。
2. **优先提升中间部分**：将所有中间分数提升至当前最大值，计算所需操作次数。
3. **剩余操作分配**：若操作次数仍有剩余，均匀分配给中间部分和最大值，确保总和最大化。

**解决难点**：  
- **避免改变最大值位置**：确保剩余操作不会让中间部分超过最大值，否则需重新调整策略。
- **数学推导**：精确计算均匀分配后的贡献，避免浮点误差（使用整数除法+余数处理）。

---

**题解清单 (≥4星)**  
1. **Maxmilite（5星）**  
   - **亮点**：简洁的数学分类讨论，无需复杂循环，直接计算两种情况。  
   - **代码可读性**：逻辑清晰，结构紧凑，避免冗余操作。  
   - **关键代码**：通过比较 `cur + m` 与 `(n-2)*a[n]` 判断是否进入均匀分配阶段。

2. **zplqwq（4.5星）**  
   - **亮点**：分阶段贪心策略，逐步填充中间部分。  
   - **思维角度**：将问题拆解为“填平中间”和“均匀提升”两阶段，直观易懂。

3. **HC20050615（4星）**  
   - **亮点**：提出“均匀提高”概念，直接输出最终公式。  
   - **优化点**：省去显式循环，直接数学推导总和。

---

**最优思路或技巧提炼**  
- **关键贪心策略**：  
  1. 忽略最小值，优先提升中间至当前最大值。  
  2. 剩余操作均匀分配，避免破坏最大值结构。  
- **数学优化**：  
  - 计算 `总剩余次数 / (n-1)` 的整数部分和余数，直接推导贡献。  
  - 余数处理时，优先加给中间部分的前几位。

---

**同类型题与算法套路**  
- **类似问题**：资源分配问题（如分糖果、最大化最小值）。  
- **通用解法**：  
  1. 排序后贪心填充。  
  2. 数学推导剩余资源的最优分配。  

---

**推荐题目**  
1. [P4995 跳跳！](https://www.luogu.com.cn/problem/P4995)（贪心排序）  
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)（贪心排序）  
3. [P3819 松江1843路](https://www.luogu.com.cn/problem/P3819)（中位数贪心）  

---

**个人心得摘录**  
- **BotDand**：强调“先乘后除”避免精度误差，提醒注意题目潜在陷阱。  
- **StayAlone**：通过举例对比不同操作策略，直观展示贪心优势。  

---

**可视化与算法演示**  
1. **贪心策略动画**：  
   - **步骤1**：排序数组，高亮最大值（红色）和最小值（灰色）。  
   - **步骤2**：中间部分（蓝色）逐步提升至红色高度，消耗操作次数。  
   - **步骤3**：剩余操作以绿色方块均匀分配，动态显示总和增长。  
   - **交互控制**：可调节动画速度，单步观察填充过程。

2. **复古像素风格设计**：  
   - **颜色方案**：红（最大值）、灰（最小值）、蓝（中间）、绿（新增操作）。  
   - **音效**：填充时播放8-bit升级音效，完成时播放胜利音效。  
   - **自动演示**：AI自动执行填充和分配，用户可暂停观察关键步骤。

---

**代码片段（Maxmilite解法）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long

int a[100005];
signed main() {
    int n, m;
    scanf("%llu%llu", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%llu", a + i);
    sort(a + 1, a + n + 1);
    long long cur = 0;
    for (int i = 2; i <= n - 1; ++i) cur += a[i];
    if (cur + m < (n - 2) * a[n])
        printf("%llu\n", (cur + m));
    else
        printf("%llu\n", (cur + m + a[n]) * (n - 2) / (n - 1));
    return 0;
}
```

**核心思想**：  
- 若中间部分无法全部提升至最大值，直接输出 `cur + m`。  
- 否则，剩余操作均匀分配，公式推导总和为 `(总 + 最大值) * (n-2) / (n-1)`。

---
处理用时：159.05秒
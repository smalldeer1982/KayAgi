# 题目信息

# [入门赛 #14] 塔台超频 (Hard Version)

## 题目描述

在一条笔直的马路上有 $n$ 个塔台，它们被依次标号为 $1, 2, \cdots, n$，分别处于距离马路起点 $a _ 1, a _ 2, \cdots, a _ n$（$a _ 1 < a _ 2 < \cdots < a _ n$）的位置。

每个塔台初始时有一个通讯半径 $b _ 1, b _ 2, \cdots, b _ n$，这代表，对于 $i$ 号塔台，其可以与 $[a _ i - b _ i, a _ i + b _ i]$ 范围内的塔台通讯。

需要特别注意，对于两个塔台 A、B，当且仅当 A 塔台的**位置**处在 B 塔台的通讯范围内，B 塔台才能向 A 塔台传递信号。请注意这里不是「二者的通讯范围重合，即可通讯」。

现在你可以对这些塔台进行超频。具体的，你可以指定一个电压 $k$，之后**所有**塔台都会被加上 $k$ 的电压，通讯半径都会增大 $k$。这里的 $k$ 仅可为非负整数。

现在要求你通过超频，使信号可以从 $1$ 号塔台传输到 $n$ 号塔台，路径不限（即，无论如何，只需要让信号从 $1$ 号塔台到达 $n$ 号塔台即可）。但是由于不合理的超频会较严重地磨损塔台，因此你想要尽可能降低超频的电压。

请你计算出，为了达到以上目的，塔台超频需要的最小电压是多少。

## 说明/提示

### 数据规模与约定

对于 $100\%$ 的数据，保证 $2 \leq n \leq 5 \times 10 ^ 5$，$0 \leq a _ i, b _ i \leq 10 ^ 9$。

## 样例 #1

### 输入

```
10
2 3
5 0
6 3
7 2
8 0
10 0
13 2
14 4
15 4
18 2```

### 输出

```
3```

# AI分析结果



**唯一算法分类**：贪心算法

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   所有塔台必须形成连续的覆盖链。关键点在于维护当前能覆盖的最远位置，若无法到达下一塔台则立即增加电压。通过贪心策略确保每一步的电压增加是必要的最小值。

2. **算法流程**  
   - 初始化当前覆盖最远距离 `max_reach` 为第一个塔台的右端点。  
   - 遍历后续塔台：  
     - 若当前塔台位置无法被 `max_reach + k` 覆盖，则增加电压 `k` 至刚好覆盖该塔台。  
     - 更新 `max_reach` 为当前塔台的新右端点（取最大值）。  

3. **解决难点**  
   - **正确性证明**：每次仅增加必要的最小电压，确保后续覆盖更远塔台的电压不会更大。  
   - **高效性**：时间复杂度为 O(n)，无需二分，直接线性扫描。

---

### **题解评分 (≥4星)**

1. **EdenSky 的贪心解法 (5星)**  
   - **亮点**：代码简洁，时间复杂度 O(n)，维护覆盖范围时直接跳过冗余塔台。  
   - **关键代码**：  
     ```cpp
     for(int i=1;i<n;i++){
         if(a[i]+b[i]+ans>=a[i+1]+b[i+1]+ans)
             {a[i+1]=a[i],b[i+1]=b[i]; continue;} // 跳过冗余塔台
         if(a[i]+b[i]+ans>=a[i+1]) continue;
         ans=a[i+1]-a[i]-b[i]; // 动态调整电压
     }
     ```

2. **_Spectator_ 的贪心解法 (5星)**  
   - **亮点**：维护当前最右覆盖 `r`，无法覆盖时直接计算所需电压。  
   - **关键代码**：  
     ```cpp
     for(int i=2;i<=n;i++){
         int r = a[p] + b[p] + k; // 当前覆盖最右
         if(a[i] > r) k += a[i] - r; // 增加电压
         if(a[i]+b[i]+k > r) p = i; // 更新最远塔台
     }
     ```

3. **Halberd_Cease 的贪心解法 (4星)**  
   - **亮点**：动态更新 `now` 变量表示覆盖范围，无法覆盖时直接增加差值。  
   - **关键代码**：  
     ```cpp
     for(int i=1;i<n;i++){
         now = max(now, a[i] + b[i] + ans);
         if(now < a[i+1]){
             ans += a[i+1] - now;
             now = a[i+1];
         }
     }
     ```

---

### **最优思路或技巧提炼**

1. **贪心选择**：每一步只解决当前无法覆盖的问题，确保电压增加最小。  
2. **覆盖范围维护**：通过 `max_reach` 或 `now` 变量记录当前能到达的最远位置。  
3. **冗余塔台跳过**：若某塔台覆盖范围被前一个覆盖，直接忽略（如 EdenSky 解法中的合并操作）。

---

### **同类型题或类似算法套路**

- **跳跃游戏类**：如 LeetCode 45. 跳跃游戏 II（最小跳跃次数）。  
- **区间覆盖问题**：如用最少的区间覆盖全部点。  
- **广播覆盖优化**：调整设备参数使覆盖连续区域。

---

### **推荐相似题目**

1. **P1090 [NOIP2004 提高组] 合并果子**（贪心选择最小代价）  
2. **P1803 线段覆盖**（贪心选择右端点最小区间）  
3. **P5019 [NOIP2018 提高组] 铺设道路**（贪心填坑）

---

### **可视化与算法演示**

1. **动画设计**：  
   - **像素风格**：塔台显示为方块，覆盖范围用颜色条表示。  
   - **关键步骤高亮**：当前处理的塔台用闪烁效果，覆盖范围变化时颜色渐变。  
   - **步进控制**：允许单步执行观察电压调整和覆盖更新。

2. **交互功能**：  
   - **速度调节**：滑动条控制动画速度。  
   - **音效触发**：电压增加时播放“滴”声，覆盖成功时播放上升音调。  

**示例代码片段（Canvas 绘制）**：  
```javascript
// 绘制塔台及覆盖范围
function drawTowers() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    towers.forEach((tower, idx) => {
        // 绘制塔台方块
        ctx.fillStyle = idx === currentIdx ? '#FF0000' : '#00FF00';
        ctx.fillRect(tower.x - 5, 100, 10, 20);
        // 绘制覆盖范围
        ctx.strokeStyle = '#FFFF00';
        ctx.beginPath();
        ctx.moveTo(tower.x - tower.range, 110);
        ctx.lineTo(tower.x + tower.range, 110);
        ctx.stroke();
    });
}
```

---

### **个人心得摘录**

- **EdenSky**：“贪心策略的正确性在于，若前一个塔台覆盖更远，则后续所需的电压不会更大。”  
- **wangif424**：“直接维护当前最远覆盖，避免二分的 log 因子，效率显著提升。”  

---

通过上述分析，贪心策略的高效性和简洁性使其成为本题的最优解，核心在于动态维护覆盖范围和最小化电压调整。

---
处理用时：81.65秒
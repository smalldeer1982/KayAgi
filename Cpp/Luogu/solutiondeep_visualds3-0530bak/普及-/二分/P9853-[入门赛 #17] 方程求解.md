# 题目信息

# [入门赛 #17] 方程求解

## 题目描述

小 A 有 $n$ 个关于 $x$ 的方程，第 $i$ 个方程形如 $a_ix_i+b_i=c_i$。方程的解 $x$ 均为正整数，例如下面几个方程都是符合要求的方程：

```
2x+4=10
-3x+13=10
4x-8=16
```

其中，第一组方程的解为 $x_1=3$，第二组方程的解为 $x_2=1$，第三组方程的解为 $x_3=6$。

小 A 想要知道，给定 $L,R$，在 $L\leq x\leq R$ 的范围内，有多少个正整数 $x$ 满足 $x$ 是其中至少一个方程的解。为了防止你欺骗他，他会询问你 $Q$ 次。

## 说明/提示

**【样例解释】**

对于第一组样例，即为题目中的举例。三组方程的解分别为 $x_1=3,x_2=1,x_3=6$。则：

- 对于 $1\leq x\leq 6$ 的范围，有 $3$ 个 $x$ 的取值（$x=1,3,6$）是其中至少一个方程的解；
- 对于 $1\leq x\leq 8$ 的范围，同上所述；
- 对于 $3\leq x\leq 6$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,6$）是其中至少一个方程的解；
- 对于 $4\leq x\leq 5$ 的范围，不存在一个 $x$ 是其中至少一个方程的解；
- 因此分别输出 $3,3,2,0$。

对于第二组样例，五组方程的解分别为 $x_1=3,x_2=5,x_3=5,x_4=3,x_5=3$。则：

- 对于 $1\leq x\leq 3$ 的范围，只有 $x=3$ 满足是其中至少一个方程的解；
- 对于 $1\leq x\leq 5$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,5$）是其中至少一个方程的解；
- 对于 $3\leq x\leq 5$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,5$）是其中至少一个方程的解；
- 因此分别输出 $1,2,2$。

**【数据范围】**

数据保证，$1\leq n,Q\leq 2\times 10^5$，方程中 $a_i,b_i,c_i$ 满足 $1 \leq |a_i|,|b_i|,|c_i| \leq 10^9$，每一组方程的解 $x_i$ 必定为正整数。询问时的 $L,R$ 满足 $1\leq L\leq R\leq 2\times 10^9$。

本题输入数据较大，请注意代码输入输出的运行效率。

## 样例 #1

### 输入

```
3 4
2x+4=10
-3x+13=10
4x-8=16
1 6
1 8
3 6
4 5```

### 输出

```
3
3
2
0```

## 样例 #2

### 输入

```
5 3
5x-2=13
8x+5=45
4x-12=8
-2x+10=4
3x-7=2
1 3
1 5
3 5```

### 输出

```
1
2
2```

# AI分析结果



---

**唯一算法分类**：二分

---

### **综合分析与结论**

**核心思路**：  
1. **预处理**：解所有方程得到x_i，去重排序，形成有序数组。  
2. **二分查询**：对每个询问区间[L, R]，利用二分查找快速统计区间内x_i的数量。  

**解决难点**：  
- **高效去重与排序**：处理2e5个方程的解，确保时间和空间复杂度。  
- **快速区间统计**：利用`lower_bound`和`upper_bound`实现O(log m)查询。  

**二分过程要点**：  
- **搜索区间**：left=0，right=数组长度。  
- **收缩条件**：比较mid对应值与L/R，决定移动left或right。  
- **边界判断**：`lower_bound`找≥L的第一个位置，`upper_bound`找>R的第一个位置。  

**可视化设计**：  
- **像素动画**：用Canvas绘制有序数组，每次二分步骤高亮mid元素，动态显示left/right移动。  
- **音效触发**：mid更新时播放“滴”声，找到区间时播放成功音效。  
- **自动演示**：模拟二分收敛过程，用户可调节速度观察区间收缩。  

---

### **题解清单 (4星以上)**

1. **chen_zhe题解（5星）**  
   - **亮点**：巧妙利用`scanf`格式化解析方程，STL二分函数简化代码，预处理去重优化空间。  
   - **关键代码**：`sort`+`unique`去重，`lower_bound`/`upper_bound`统计区间。  

---

### **代码实现核心片段**

```cpp
#include <vector>
#include <algorithm>
using namespace std;

vector<int> xs; // 存储所有方程解

// 解析方程并收集解
void parse_equation() {
    int a, b, c;
    scanf("%dx%d=%d", &a, &b, &c); // 利用格式化输入提取a,b,c
    int xi = (c - b) / a; // 计算解x_i
    xs.push_back(xi);
}

// 处理查询
int query(int L, int R) {
    auto left = lower_bound(xs.begin(), xs.end(), L);
    auto right = upper_bound(xs.begin(), xs.end(), R);
    return right - left;
}

int main() {
    // 预处理：排序去重
    sort(xs.begin(), xs.end());
    xs.erase(unique(xs.begin(), xs.end()), xs.end());
    // 处理每个查询
    while (Q--) {
        int L, R;
        scanf("%d%d", &L, &R);
        printf("%d\n", query(L, R));
    }
}
```

---

### **同类型题与算法套路**

- **通用解法**：  
  - **排序后二分**：适用于有序数据上的区间统计。  
  - **去重优化**：减少无效计算，提升查询效率。  

- **类似题目**：  
  - 洛谷P1102（A-B数对，二分统计差值为C的对数）。  
  - 洛谷P1496（区间合并，排序后处理端点）。  
  - LeetCode 34（在排序数组中查找元素的第一个和最后一个位置）。  

---

### **复古游戏化动画设计**

- **像素网格绘制**：  
  - **颜色方案**：绿色为有效区间，红色为mid，蓝色为left/right指针。  
  - **Canvas更新**：每次二分步骤后重绘数组，高亮当前mid和区间。  

- **音效与交互**：  
  - **步进音效**：使用8-bit音效库，每次mid更新触发短音。  
  - **自动模式**：按预设速度逐步执行，展示二分查找的“AI决策”。  

- **关卡积分**：  
  - 每正确完成一次查询得10分，连续正确触发连击奖励。  
  - 错误处理时播放失败音效，积分清零。  

---

**核心思想**：将大规模数据预处理为有序结构，利用二分快速定位区间，是高效解决区间统计问题的经典范式。

---
处理用时：67.56秒
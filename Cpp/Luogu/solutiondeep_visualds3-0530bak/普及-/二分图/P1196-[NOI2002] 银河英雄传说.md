# 题目信息

# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 说明/提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)

题目中没有强制 $i \neq j$，但是实测数据中不存在 $i = j$ 的情况。

## 样例 #1

### 输入

```
4
M 2 3
C 1 2
M 2 4
C 4 2```

### 输出

```
-1
1```

# AI分析结果



# 银河英雄传说 - 带权并查集解析与可视化设计

## 唯一算法分类
带权并查集

---

## 综合分析与结论
### 核心算法流程
1. **数据结构设计**：
   - `fa[]`：记录每个战舰的父节点
   - `front[]`：记录每个战舰到所在队列首舰的距离
   - `num[]`：记录每个队列的总战舰数

2. **关键操作**：
```python
# 路径压缩（递归版）
def find(x):
    if fa[x] != x:
        root = find(fa[x])
        front[x] += front[fa[x]]  # 累加路径权值
        fa[x] = root             # 路径压缩
    return fa[x]

# 合并操作
def merge(x, y):
    fx = find(x)
    fy = find(y)
    front[fx] = num[fy]         # x队列首舰到新首舰的距离
    num[fy] += num[fx]          # 更新队列总长
    fa[fx] = fy
```

### 解决难点
- **动态距离维护**：通过递归式路径压缩，在`find`操作中实时更新每个节点到根节点的累计距离
- **队列合并策略**：将合并后的队列首舰距离设为被合并队列的总长度，保证后续查询能正确计算相对位置

---

## 题解清单（≥4星）
1. **假装思考（★★★★★）**
   - 亮点：清晰解释front数组维护原理，代码包含详细注释
   - 代码片段：
```cpp
int find(int n){
    if(fa[n]==n)return fa[n];
    int fn=find(fa[n]);
    front[n] += front[fa[n]]; // 关键路径压缩
    return fa[n] = fn;
}
```

2. **破壁人（★★★★☆）**
   - 亮点：引入s数组记录集合大小，简化合并操作逻辑
   - 调试心得："路径压缩时需先递归处理父节点再更新自身权值"

3. **Mr_Wolfram（★★★★☆）**
   - 亮点：独立设计num数组维护队列长度，代码结构紧凑
   - 代码片段：
```cpp
void merge(int x,int y){
    int r1=find(x),r2=find(y);
    fa[r1]=r2; 
    dis[r1] = dis[r2] + num[r2];
    num[r2] += num[r1];
}
```

---

## 可视化设计
### 复古像素风格演示方案
1. **界面元素**：
   - 战舰队列用不同颜色方块表示（红：队列A，蓝：队列B）
   - 当前操作节点用闪烁边框高亮
   - 右侧面板显示`front[]`和`num[]`的实时数值

2. **动画流程**：
```javascript
// 示例：合并操作动画
function animateMerge(x, y) {
    highlight(x, 'yellow'); // 高亮被移动队列首舰
    drawArrow(x, y);         // 显示合并箭头
    updateNumDisplay(y);    // 更新队列长度显示
    flashFrontValue(x);      // 闪烁显示front[x]变化
}
```

3. **音效设计**：
   - 路径压缩：8-bit "滴"声（每次父节点更新时触发）
   - 成功合并：上升音阶
   - 查询失败：低沉"哔"声

4. **交互功能**：
   - 速度调节滑块（0.5x-4x）
   - 单步执行按钮
   - 队列结构3D视角切换

---

## 相似题目推荐
1. P2342 叠积木（带权并查集基础）
2. P1525 关押罪犯（并查集扩展应用）
3. P2024 食物链（多关系带权处理）

---

## 关键代码实现
```cpp
// 完整核心代码
#include<bits/stdc++.h>
using namespace std;
const int MAXN=30005;
int fa[MAXN], front[MAXN], num[MAXN];

int find(int x) {
    if(fa[x] != x) {
        int root = find(fa[x]);
        front[x] += front[fa[x]];
        fa[x] = root;
    }
    return fa[x];
}

int main() {
    int T; cin >> T;
    for(int i=1; i<=30000; ++i) 
        fa[i]=i, num[i]=1;
        
    while(T--) {
        char op; int x,y;
        cin >> op >> x >> y;
        int fx = find(x), fy = find(y);
        if(op == 'M') {
            front[fx] = num[fy];
            num[fy] += num[fx];
            fa[fx] = fy;
        } else {
            if(fx != fy) cout << -1 << endl;
            else cout << abs(front[x]-front[y])-1 << endl;
        }
    }
    return 0;
}
```

---

通过这种带权并查集的实现，能够在近乎常数时间内完成舰队合并和距离查询，完美满足题目的大数据量要求。可视化设计将抽象的距离计算转化为直观的图形变化，帮助理解路径压缩和权值更新的动态过程。

---
处理用时：65.27秒
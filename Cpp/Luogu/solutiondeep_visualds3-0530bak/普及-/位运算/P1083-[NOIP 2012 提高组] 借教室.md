# 题目信息

# [NOIP 2012 提高组] 借教室

## 题目描述

在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。

面对海量租借教室的信息，我们自然希望编程解决这个问题。

我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_i$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_j,s_j,t_j$，表示某租借者需要从第 $s_j$ 天到第 $t_j$ 天租借教室（包括第 $s_j$ 天和第 $t_j$ 天），每天需要租借 $d_j$ 个教室。

我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供 $d_j$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。

借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_j$ 天到第 $t_j$ 天中有至少一天剩余的教室数量不足 $d_j$ 个。

现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。


## 说明/提示

【输入输出样例说明】

第 $1 $份订单满足后，$4 $天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2 $天到第 $4$ 天每天提供 $3$ 个教室，而第 $3$ 天剩余的教室数为$ 2$，因此无法满足。分配停止，通知第 $2$ 个申请人修改订单。

【数据范围】

对于 $10\%$ 的数据，有 $1\le n,m\le 10$；

对于 $30\%$ 的数据，有 $1\le n,m\le 1000$；

对于 $70\%$ 的数据，有 $1 \le n,m \le 10^5$；

对于 $100\%$ 的数据，有 $1 \le n,m \le 10^6$，$0 \le r_i,d_j\le 10^9$，$1 \le s_j\le t_j\le n$。


NOIP 2012 提高组 第二天 第二题

2022.2.20 新增一组 hack 数据

## 样例 #1

### 输入

```
4 3 
2 5 4 3 
2 1 3 
3 2 4 
4 2 4```

### 输出

```
-1 
2```

# AI分析结果



**唯一算法分类**：二分答案 + 差分

---

### **题解思路与算法要点**
#### **核心算法流程**
1. **二分答案**：  
   通过二分法确定第一个无法满足的订单编号。若前`mid`个订单均能满足，则答案在右半区间；否则在左半区间。  
2. **差分数组优化**：  
   对于每个二分点`mid`，通过差分数组快速计算区间修改后的每日教室需求量。差分操作时间复杂度为`O(1)`，前缀和计算时间复杂度为`O(n)`。  
3. **关键变量**：  
   - `dif[]`：差分数组，记录每日教室需求的增量变化。  
   - `need[]`：通过前缀和计算出的每日实际需求量。  

#### **解决难点对比**
| 方法          | 时间复杂度       | 核心思路                           | 适用场景           |
|---------------|------------------|------------------------------------|--------------------|
| 二分+差分     | O((n+m) log m)  | 二分订单数，差分处理区间修改       | 大规模数据最优解   |
| 线段树        | O(m log n)      | 动态维护区间最小值，实时检查      | 小规模数据或练习   |
| 暴力优化      | O(nm)           | 差分后逆序撤销订单直到合法         | 数据弱时可用       |

---

### **题解评分 (≥4星)**
1. **皎月半洒花 (★★★★☆)**  
   - **亮点**：详细推导二分+差分思路，代码简洁易懂。  
   - **代码**：差分数组处理与二分逻辑清晰，适合学习核心算法。  
   ```cpp
   bool isok(int x) {
       memset(diff, 0, sizeof(diff));
       for (int i=1; i<=x; i++) {
           diff[l[i]] += d[i];
           diff[r[i]+1] -= d[i];
       }
       for (int i=1; i<=n; i++) {
           need[i] = need[i-1] + diff[i];
           if (need[i] > rest[i]) return 0;
       }
       return 1;
   }
   ```

2. **WsW_ (★★★★☆)**  
   - **亮点**：代码高度模块化，封装差分检查函数，适合工程实践。  
   - **优化**：利用`check`函数分离逻辑，便于调试和扩展。  

3. **清远学会 (★★★★☆)**  
   - **亮点**：对比线段树与差分方案，提供多角度分析。  
   - **代码**：线段树实现完整，适合理解区间维护逻辑。  

---

### **最优思路提炼**
1. **二分答案框架**：  
   通过单调性快速定位问题订单，将全局问题分解为多个局部验证子问题。  
2. **差分数组技巧**：  
   将区间修改转化为端点操作，使时间复杂度从`O(n)`降为`O(1)`，适合密集区间操作场景。  
3. **空间优化**：  
   复用`dif[]`数组避免重复内存分配，降低空间复杂度。  

---

### **同类型题推荐**
1. **P3406 海底高铁**：差分统计区间访问次数。  
2. **P4552 IncDec Sequence**：差分性质与极值分析。  
3. **P3382 【模板】线段树**：区间修改与极值查询。  

---

### **个人心得摘录**
- **皎月半洒花**：  
  > “线段树虽然操作方便，但考试时撸模板的时间足够多打两个暴力。”  
  **总结**：算法选择需权衡实现复杂度与时间效率。  
- **LeavingZzz**：  
  > “差分性能好，但也要接纳线段树。”  
  **总结**：不同场景适用不同数据结构，需灵活变通。  

---

### **算法可视化设计**
#### **动画演示方案**
1. **像素风格界面**：  
   - **颜色标记**：绿色表示合法教室数，红色表示不足。  
   - **网格布局**：按天排列教室数量，订单处理时高亮修改区间。  
2. **关键步骤动态展示**：  
   - **差分操作**：用箭头标记`dif[l]`和`dif[r+1]`的增减。  
   - **前缀和计算**：逐天累加显示`need[]`变化，触发红色警报时播放失败音效。  
3. **交互控制**：  
   - **步进速度**：滑动条调节二分与差分计算速度。  
   - **模式切换**：对比线段树与差分方案的执行过程。  

#### **复古游戏化实现**
```javascript
// 示例：Canvas绘制差分过程（伪代码）
function drawDiffStep(day, value) {
    ctx.fillStyle = value < 0 ? '#FF0000' : '#00FF00'; // 红/绿色块
    ctx.fillRect(day * 10, 0, 8, 8); // 像素方块表示每日状态
    if (value < 0) playSound('error'); // 触发音效
}
```

---

### **完整代码参考**
**皎月半洒花题解核心代码**：
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int n, m, rest[1000005], d[1000005], l[1000005], r[1000005];
int diff[1000005], need[1000005];

bool check(int x) {
    memset(diff, 0, sizeof(diff));
    for (int i = 1; i <= x; i++) {
        diff[l[i]] += d[i];
        diff[r[i] + 1] -= d[i];
    }
    for (int i = 1; i <= n; i++) {
        need[i] = need[i - 1] + diff[i];
        if (need[i] > rest[i]) return false;
    }
    return true;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> rest[i];
    for (int i = 1; i <= m; i++) cin >> d[i] >> l[i] >> r[i];
    
    int left = 1, right = m, ans = 0;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (check(mid)) {
            left = mid + 1;
            ans = mid;
        } else {
            right = mid - 1;
        }
    }
    if (ans == m) cout << 0;
    else cout << -1 << endl << ans + 1;
    return 0;
}
```

---
处理用时：79.65秒
# 题目信息

# 高低位交换

## 题目描述

给出一个小于 $2^{32}$ 的非负整数。这个数可以用一个 $32$ 位的二进制数表示（不足 $32$ 位用 $0$ 补足）。我们称这个二进制数的前 $16$ 位为“高位”，后 $16$ 位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。

例如，数 $1314520$ 用二进制表示为 $0000\,0000\,0001\,0100\,0000\,1110\,1101\,1000$（添加了 $11$ 个前导 $0$ 补足为 $32$ 位），其中前 $16$ 位为高位，即 $0000\,0000\,0001\,0100$；后 $16$ 位为低位，即 $0000\,1110\,1101\,1000$。将它的高低位进行交换，我们得到了一个新的二进制数 $0000\,1110\,1101\,1000\,0000\,0000\,0001\,0100$。它即是十进制的 $249036820$。


## 样例 #1

### 输入

```
1314520
```

### 输出

```
249036820
```

# AI分析结果



### **唯一算法分类**  
位运算

---

### **综合分析与结论**  
**核心思路**：将32位无符号整数的高16位与低16位交换。通过位运算直接操作二进制位，高效且简洁。  
**难点**：正确使用无符号类型避免符号位干扰，以及位移操作的溢出处理。  
**解决方案**：  
1. **右移+左移法**：将原数右移16位得到高位部分，左移16位得到低位部分，相加即可合并为交换后的数。  
2. **位掩码法**：用掩码提取高低位，再通过位移和或运算合并。  

**可视化设计**：  
- **动画演示**：展示32位二进制数分为高16位（红色）和低16位（蓝色）。通过左移/右移操作交换位置，合并成新数。  
- **复古风格**：8位像素动画，每次位移时方块滑动并播放“滴”声，合并时播放上扬音效。  
- **交互控制**：支持单步执行观察位移细节，速度调节适应学习节奏。

---

### **题解清单 (≥4星)**  
1. **月影困（5星）**  
   - **亮点**：代码极简，仅需两行位移相加，利用无符号整数的自动溢出处理。  
   - **代码**：  
     ```cpp
     printf("%u\n", (n >> 16) + (n << 16));
     ```

2. **HenryHuang（4星）**  
   - **亮点**：显式位掩码确保高低位分离，逻辑清晰易懂。  
   - **代码**：  
     ```cpp
     cout << ((x&0x0000ffff)<<16 | (x&0xffff0000)>>16);
     ```

3. **离散小波变换°（4星）**  
   - **亮点**：详细对比两种位运算思路，强调无符号类型的重要性。  

---

### **最优思路与技巧提炼**  
1. **位移合并法**：  
   ```cpp
   result = (x << 16) | (x >> 16); // 无符号类型下等价相加
   ```  
2. **核心技巧**：  
   - 使用 `unsigned` 避免符号位干扰。  
   - 左移低位至高16位，右移高位至低16位。  

---

### **同类型题与算法套路**  
- **相似题目**：二进制反转（LeetCode 190）、分段位操作（如IP地址转换）。  
- **通用套路**：位掩码提取特定段，位移调整位置，或运算合并结果。  

---

### **推荐题目**  
1. **P1017** 进制转换（负进制处理）  
2. **P1582** 倒水（位运算应用）  
3. **P1062** 数列（二进制特性）  

---

### **个人心得摘录**  
- **月影困**：注意无符号右移高位补0，确保结果正确。  
- **HenryHuang**：掩码虽冗余但更显式，适合教学场景。  
- **ykkz000**：指针法依赖字节序，需谨慎使用。  

---

### **可视化与算法演示**  
**核心步骤动画**：  
1. **初始状态**：32位二进制数分两色显示高/低位。  
2. **左移低位**：蓝色块左移至高16位，红色块右移至低16位。  
3. **合并结果**：两色块拼接为新数，显示十进制结果。  

**复古游戏化设计**：  
- **像素风格**：8位色块表示二进制位，移动时带残影特效。  
- **音效**：位移时“滴”声，合并时“成功”音效。  
- **自动演示**：AI逐步展示位移过程，支持暂停/继续。  

---

### **代码实现（核心片段）**  
```cpp
// 月影困的位移合并法
#include <cstdio>
int main() {
    unsigned int n;
    scanf("%u", &n);
    printf("%u\n", (n >> 16) + (n << 16));
    return 0;
}
```

**关键解释**：  
- `n >> 16`：取高16位置于低位。  
- `n << 16`：取低16位置于高位。  
- 无符号加法等价于拼接，无需显式位操作。

---
处理用时：101.55秒
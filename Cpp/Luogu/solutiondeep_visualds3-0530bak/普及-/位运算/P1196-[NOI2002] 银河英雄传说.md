# 题目信息

# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 说明/提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)

题目中没有强制 $i \neq j$，但是实测数据中不存在 $i = j$ 的情况。

## 样例 #1

### 输入

```
4
M 2 3
C 1 2
M 2 4
C 4 2```

### 输出

```
-1
1```

# AI分析结果



### 唯一算法分类  
**带权并查集**

---

### 综合分析与结论  
本题需要动态维护战舰队列的合并关系（并查集基础功能），并快速计算两艘战舰间的距离（需要附加信息）。核心难点在于如何通过并查集的路径压缩机制维护战舰队列的相对位置关系。

**核心算法流程与可视化设计：**  
1. **数据结构**：  
   - `fa[i]`：战舰i的父节点  
   - `d[i]`：战舰i到父节点的距离（最终会压缩为到根节点的距离）  
   - `size[i]`：以i为根节点的队列总长度  

2. **关键操作**：  
   - **合并（M指令）**：  
     将x所在队列的根节点`fx`的父节点设为y所在队列的根节点`fy`，更新`d[fx] = size[fy]`（fx到新根节点的距离等于原y队列长度），`size[fy] += size[fx]`  
     ![合并动画示例](https://cdn.luogu.com.cn/upload/image_hosting/9qg7x3k8.gif)  

   - **路径压缩（find函数）**：  
     递归查找时动态更新`d[x] += d[fa[x]]`，使每个节点直接指向根节点并记录总距离  
     ![路径压缩动画](https://cdn.luogu.com.cn/upload/image_hosting/4m3vz1fj.gif)  

3. **可视化设计要点**：  
   - **颜色标记**：当前操作的战舰用红色高亮，路径压缩过程用渐变色展示递归路径  
   - **Canvas网格**：以战舰编号为横坐标，纵坐标显示`fa[]`和`d[]`的值变化  
   - **8位音效**：合并时播放"嘟嘟"音效，路径压缩时播放"滴答"音效  

---

### 题解清单（≥4星）  
1. **假装思考（★★★★★）**  
   - 核心亮点：用`front[]`数组记录到队首的距离，路径压缩时递归更新  
   - 关键代码片段：  
     ```cpp
     int find(int n) {
         if(fa[n]==n) return fa[n];
         int fn=find(fa[n]);
         front[n] += front[fa[n]]; // 递归回溯时更新距离
         return fa[n] = fn;
     }
     ```

2. **破壁人（★★★★☆）**  
   - 创新点：引入`size[]`记录队列长度，合并时直接计算相对距离  
   - 调试心得："路径压缩时权值的更新顺序非常重要，必须先递归找根节点再更新当前节点"

3. **Mr_Wolfram（★★★★☆）**  
   - 系统化设计：同时维护`dis[]`和`num[]`，代码结构清晰  
   - 关键变量：  
     ```cpp
     void merge(int x, int y) {
         dis[r1] = dis[r2] + num[r2]; // r1为x的根，r2为y的根
         num[r2] += num[r1];
     }
     ```

---

### 最优思路提炼  
**关键技巧**：  
1. **路径压缩时的权值更新**：在递归返回时更新距离，确保父节点权值已计算完毕  
2. **合并时的相对距离计算**：将队列长度作为新接入队列的初始距离  
3. **查询时的绝对值处理**：`abs(d[x]-d[y])-1`巧妙处理正反向顺序  

**思维模型**：  
将每个战舰队列视为一棵树，合并操作即树的链接，查询操作转化为两节点到根节点的路径差。

---

### 相似题目推荐  
1. [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)  
   （带权并查集处理敌对关系）  
2. [P2024 食物链](https://www.luogu.com.cn/problem/P2024)  
   （三分类关系的带权维护）  
3. [P4879 搬寝室](https://www.luogu.com.cn/problem/P4879)  
   （集合合并与物品配对策略）

---

### 代码实现（带音效的简化版）  
```html
<canvas id="demo" width="800" height="300"></canvas>
<script>
// 初始化并查集数据结构
let fa = [], d = [], size = [];
const COLOR_MERGE = '#FF6B6B', COLOR_FIND = '#4ECDC4';

function init() {
  for(let i=0; i<=30000; i++) {
    fa[i] = i;
    d[i] = 0;
    size[i] = 1;
  }
}

function find(x) {
  if(fa[x] === x) return x;
  let oldFa = fa[x];
  fa[x] = find(fa[x]);
  d[x] += d[oldFa];  // 权值更新
  return fa[x];
}

// 在Canvas上绘制当前状态
function draw(ctx, highlight=[]) {
  // 绘制代码（略）
}
</script>
```

---

### 复古游戏化设计  
1. **像素风格**：  
   - 使用16色调色板，战舰用8x8像素方块表示  
   - 合并时显示"▲▼"箭头动画，路径压缩时显示"✨"特效  
2. **音效设计**：  
   ```javascript
   const audioCtx = new AudioContext();
   function playBeep(freq=520) {
     let oscillator = audioCtx.createOscillator();
     oscillator.type = 'square';
     oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
     oscillator.connect(audioCtx.destination);
     oscillator.start(); oscillator.stop(0.1);
   }
   ```
3. **自动演示模式**：  
   - 按空格键切换手动/自动模式  
   - 自动模式时算法以0.5秒/步的速度执行，关键步骤触发音效  

---

通过这种深度整合的算法解析与交互式可视化设计，学习者既能理解带权并查集的数学本质，又能通过游戏化体验加深记忆。

---
处理用时：81.29秒
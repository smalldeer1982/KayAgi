# 题目信息

# [USACO1.4] 母亲的牛奶 Mother's Milk

## 题目描述

农民约翰有三个容量分别是 $a,b,c$ 升的桶。  

最初，$a,b$ 桶都是空的，而 $c$ 桶是装满牛奶的。有时，农民把牛奶从一个桶倒到另一个桶中，直到被灌桶装满或原桶空了。  

当然每一次灌注都是完全的。由于节约，牛奶不会有丢失。

写一个程序去帮助农民找出当 $a$ 桶是空的时候，$c$ 桶中牛奶所剩量的所有可能性。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le a,b,c \le 20$。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
8 9 10
```

### 输出

```
1 2 8 9 10
```

## 样例 #2

### 输入

```
2 5 10```

### 输出

```
5 6 7 8 9 10```

# AI分析结果



### 唯一算法分类  
**广度优先搜索（BFS）与深度优先搜索（DFS）**

---

### 综合分析与结论  
#### 核心算法流程  
所有题解的核心思路是通过状态遍历穷举所有可能的倒牛奶操作。算法流程可分为：  
1. **状态表示**：用三元组 `(a, b, c)` 表示三个桶的当前牛奶量  
2. **状态转移**：枚举6种倒牛奶操作（A→B、A→C、B→A、B→C、C→A、C→B）  
3. **剪枝优化**：用三维数组 `vis[a][b][c]` 标记已访问状态，避免重复搜索  
4. **结果收集**：当 `a=0` 时记录 `c` 的值，最后排序输出  

#### 可视化设计思路  
1. **网格动画**：在 Canvas 中以像素方块表示三个桶的容量变化，每次倒牛奶时用箭头表示操作方向  
2. **颜色标记**：  
   - **当前操作桶**：红色边框高亮  
   - **状态变化量**：绿色填充被倒入的桶  
   - **已访问状态**：灰色半透明覆盖  
3. **音效提示**：  
   - 倒牛奶时播放 `8bit` 水滴声  
   - 发现 `a=0` 时播放上扬音效  
4. **复古风格**：  
   - 桶容量用像素字体显示  
   - 背景采用 FC 风格 16 色棋盘纹理  

---

### 题解清单（≥4星）  
1. **远航之曲（DFS）**（★★★★★）  
   **亮点**：  
   - 使用三重循环统一处理6种倒法  
   - 用 `memcpy` 深拷贝状态数组避免污染  
   ```cpp
   for (int i = 0; i < 3; ++i) {  // 统一处理所有倒法
     for (int j = 0; j < 3; ++j) {
       if (j == i) continue;
       int rec = min(bkt[j] - a[j], a[i]);  // 关键：计算可倒量
       int b[3]; memcpy(b, a, sizeof(int)*3);  // 深拷贝避免状态污染
       b[i] -= rec; b[j] += rec;
       dfs(b);
     }
   }
   ```

2. **zhanghanbin（DFS）**（★★★★☆）  
   **亮点**：  
   - 显式写出所有6种倒法分支  
   - 通过 `min(ta, nowa+nowc)` 实现状态转移  
   ```cpp
   if (nowc) {
     if (nowa < ta) dfs(min(ta, nowa+nowc), nowb, nowc-(min(ta, nowa+nowc)-nowa));  // C→A
     if (nowb < tb) dfs(nowa, min(tb, nowb+nowc), nowc-(min(tb, nowb+nowc)-nowb));  // C→B
   }
   ```

3. **xun薰（DFS）**（★★★★）  
   **亮点**：  
   - 通过条件判断直接生成新状态  
   - 最终结果排序输出  
   ```cpp
   if (nowa == 0) ans[++k] = nowc;  // 结果收集
   sort(ans+1, ans+k+1);  // 排序输出
   ```

---

### 最优思路与技巧  
1. **状态压缩**：  
   用三维数组 `vis[a][b][c]` 代替哈希表，将时间复杂度从 O(2ⁿ) 降至 O(20³)  
2. **倒量计算**：  
   每次倒牛奶的可倒量为 `min(来源桶当前量, 目标桶剩余容量)`  
3. **剪枝优化**：  
   当 `vis[a][b][c]` 已标记时直接返回，避免重复搜索  

---

### 同类型题推荐  
1. **P1582 倒水**（状态转移+位运算）  
2. **P1443 马的遍历**（BFS网格遍历）  
3. **P1135 奇怪的电梯**（状态空间搜索）  

---

### 可视化核心代码（JS）  
```javascript
// 像素动画核心逻辑
function pourAnimation(from, to) {
  let transfer = Math.min(buckets[from], CAPACITY[to] - buckets[to]);
  ctx.fillStyle = "#FF0000";  // 红色标记操作桶
  drawBucket(from); 
  animateArrow(from, to, () => {
    buckets[from] -= transfer;
    buckets[to] += transfer;
    if (buckets[0] === 0) playSuccessSound();  // 触发成功音效
  });
}

// 8-bit音效
function playSuccessSound() {
  const osc = audioCtx.createOscillator();
  osc.frequency.setValueAtTime(880, audioCtx.currentTime);
  osc.connect(audioCtx.destination);
  osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

---

### 复古游戏化设计  
1. **像素风格**：  
   - 使用 `16x16` 像素块绘制桶和牛奶量  
   - 背景采用 NES 风格的蓝绿色渐变  
2. **自动演示模式**：  
   - 按 BFS 顺序自动执行所有合法倒法  
   - 每步间隔 800ms，可通过滑块调节速度  
3. **积分系统**：  
   - 发现新状态+10分，重复操作-5分  
   - 最终根据发现的 `c` 值数量给予评级（S/A/B/C）  

---

### 调试心得摘录  
> **远航之曲**：  
> “最初忘记深拷贝状态数组，导致所有分支共享同一内存，调试3小时发现状态污染问题，改用 `memcpy` 后 AC”  

> **zhanghanbin**：  
> “显式写出6种倒法虽然代码长，但更易调试边界条件，如 `C→A` 时需判断 `nowa < ta`”  

---

### 算法比较可视化  
| 方法        | 时间复杂度 | 空间复杂度 | 代码简洁度 |  
|-------------|------------|------------|------------|  
| DFS+三维剪枝 | O(20³)     | O(20³)     | ★★★★       |  
| BFS队列实现  | O(20³)     | O(20³)     | ★★★☆       |  
| 随机化枚举   | O(1e7)     | O(1)       | ★★☆☆       |  

---

通过上述分析与设计，学习者可深入理解状态空间搜索的核心思想，并通过交互式像素动画直观掌握倒牛奶问题的解决过程。

---
处理用时：85.03秒
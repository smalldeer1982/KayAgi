# 题目信息

# [GESP202406 四级] 黑白方块

## 题目描述

小杨有一个 $n$ 行 $m$ 列的网格图，其中每个格子要么是白色，要么是黑色。对于网格图中的一个子矩形，小杨认为它是平衡的当且仅当其中黑色格子与白色格子数量相同。小杨想知道最大的平衡子矩形包含了多少个格子。

## 说明/提示

**【样例解释】**

对于样例 $1$，假设 $(i,j)$ 代表第 $i$ 行第 $j$ 列，最大的平衡子矩形的四个顶点分别为 $(1,2),(1,5),(4,2),(4,5)$。

**【数据范围】**

对于全部数据，保证有 $1\leq n,m\leq 10$。

## 样例 #1

### 输入

```
4 5
00000
01111
00011
00011```

### 输出

```
16```

# AI分析结果



---

**唯一算法分类**：枚举

---

### **综合分析与结论**

**题目核心**：在 10×10 的网格中找出最大的子矩形，满足黑（0）白（1）格子数量相等。

**题解思路**：
- **暴力枚举**：遍历所有可能的子矩形（左上角和右下角坐标），逐个检查是否满足条件。
- **Check 函数**：统计矩形内 0 和 1 的数量，判断是否相等。
- **复杂度分析**：时间复杂度为 O(n⁶)，但数据范围极小（n=10），完全可行。

**解决难点**：
- **子矩形枚举**：通过四重循环覆盖所有可能的矩形范围。
- **快速统计**：直接遍历矩形内元素求和，牺牲时间换取代码简洁性。

**优化方向**：  
可使用二维前缀和预处理 0 和 1 的数量，将 Check 函数优化为 O(1)，总复杂度降至 O(n⁴)。但对于本题无需优化。

---

### **题解清单 (≥4星)**

**题解评分**：⭐⭐⭐⭐⭐（5星）  
- **亮点**：代码简洁，思路清晰，适合教学；正确处理了数据范围小的问题，未引入冗余优化。
- **适用场景**：适合算法入门学习，尤其适合理解暴力枚举思想。

---

### **最优思路与技巧提炼**

1. **暴力枚举法**：
   - **核心逻辑**：枚举所有可能的矩形边界，逐次检查条件。
   - **适用条件**：当数据范围较小时（如 n≤20），暴力法往往是最直接的解法。
   - **思维启示**：优先考虑问题约束，避免过早优化。

2. **前缀和优化**（潜在优化）：
   - **预处理**：构建前缀和数组 `pre[i][j]` 表示从 (1,1) 到 (i,j) 的 0/1 数量。
   - **快速查询**：计算矩形内 0/1 数量时，通过四个角点快速求差。

---

### **同类型题与算法套路**

1. **最大子矩阵问题**：如寻找全 1 矩阵、最大和子矩阵。
2. **条件统计问题**：如满足某条件的子区域数量统计。
3. **枚举优化结合**：二维前缀和、滑动窗口等优化手段。

**推荐题目**：
1. **洛谷 P1736**：创意吃鱼法（最大全 1 对角线子矩阵）。
2. **洛谷 P1719**：最大加权矩形（二维前缀和经典）。
3. **洛谷 P3406**：海底高铁（区间统计与优化）。

---

### **代码实现与核心逻辑**

**暴力枚举代码**：
```cpp
int main() {
    int n, m; cin >> n >> m;
    vector<string> grid(n);
    for (int i = 0; i < n; i++) cin >> grid[i];
    
    int max_area = 0;
    // 枚举左上角 (i,j) 和右下角 (x,y)
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            for (int x = i; x < n; x++) {
                for (int y = j; y < m; y++) {
                    int cnt0 = 0, cnt1 = 0;
                    // 统计当前矩形内的 0 和 1
                    for (int a = i; a <= x; a++) {
                        for (int b = j; b <= y; b++) {
                            if (grid[a][b] == '0') cnt0++;
                            else cnt1++;
                        }
                    }
                    if (cnt0 == cnt1) {
                        max_area = max(max_area, (x-i+1)*(y-j+1));
                    }
                }
            }
        }
    }
    cout << max_area << endl;
    return 0;
}
```

**前缀和优化片段**（潜在优化）：
```cpp
// 预处理前缀和
struct Prefix {
    int cnt0, cnt1;
} pre[11][11];

// 计算矩形内 0/1 数量
int get0(int i, int j, int x, int y) {
    return pre[x][y].cnt0 - pre[i-1][y].cnt0 - pre[x][j-1].cnt0 + pre[i-1][j-1].cnt0;
}
// 类似实现 get1()
```

---

### **可视化与算法演示设计**

**动画方案**：
1. **网格绘制**：以 8 位像素风格渲染网格，0 为白色，1 为黑色。
2. **枚举高亮**：当前枚举的矩形边框闪烁（如红色），统计时内部格子渐变显示。
3. **结果反馈**：发现平衡矩形时播放“叮”音效，并记录最大面积。
4. **控制面板**：支持暂停/继续、调整枚举速度（如 1x, 2x, 5x）。

**复古风格设计**：
- **颜色方案**：16 色调色板，参考 FC 游戏风格。
- **音效设计**：
  - **枚举步进**：短促“滴”声。
  - **找到解**：8 比特胜利音效。
  - **更新最大值**：上扬音阶。

**自动演示模式**：
- **AI 逻辑**：按左上角优先、右下角扩展的顺序枚举矩形。
- **关卡机制**：将网格大小分为 5×5、10×10 等关卡，逐步提升难度。

---

### **个人心得摘录**

> “对于小数据范围的问题，暴力法往往是代码实现的最优解。过早优化可能增加代码复杂度，反而影响可读性。”  
> —— 通过本题深刻理解暴力法的实用场景，尤其在竞赛中快速解题时。

---
处理用时：108.58秒
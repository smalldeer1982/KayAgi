# 题目信息

# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 说明/提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)

题目中没有强制 $i \neq j$，但是实测数据中不存在 $i = j$ 的情况。

## 样例 #1

### 输入

```
4
M 2 3
C 1 2
M 2 4
C 4 2```

### 输出

```
-1
1```

# AI分析结果



### 算法分类  
**带权并查集**

---

### 题解思路与核心难点  
**核心思路**：  
所有题解均使用带权并查集，通过维护两个关键变量：  
1. `front[x]`：战舰到根节点的距离（即当前列中的位置）  
2. `num[x]`：以 x 为根的集合总大小（即当前列战舰总数）  

**解决难点**：  
1. **路径压缩时的动态更新**：在 `find` 函数递归过程中，通过回溯更新每个节点到根节点的距离  
2. **合并操作的权值修正**：合并两列时，需将被合并列的根节点距离修正为另一列的当前总长度  

---

### 题解评分（≥4星）  
1. **假装思考（★★★★★）**  
   - 思路清晰：详细解释路径压缩和权值更新逻辑  
   - 代码简洁：通过 `find` 函数递归实现回溯更新  
   - 优化亮点：使用 `num` 数组记录集合大小实现快速合并  
   - 代码片段：  
     ```cpp  
     int find(int n) {
         if(fa[n]==n) return fa[n];
         int fn=find(fa[n]);
         front[n] += front[fa[n]]; // 回溯更新距离
         return fa[n] = fn;
     }
     ```

2. **破壁人（★★★★☆）**  
   - 实现巧妙：通过 `s[x]` 记录到根的距离，`b[x]` 记录集合大小  
   - 代码精简：合并时直接更新根节点的 `s` 和 `b` 值  
   - 个人心得：注释中强调“路径压缩时的权值更新顺序”  

3. **Mr_Wolfram（★★★★☆）**  
   - 结构规范：独立定义 `merge` 和 `query` 函数  
   - 扩展性强：通过 `num` 数组维护集合大小，支持动态合并  
   - 调试经验：注释中提到“`find` 函数必须优先递归更新父节点”  

---

### 最优思路提炼  
1. **路径压缩回溯更新**：  
   ```cpp  
   int find(int x) {
       if (fa[x] != x) {
           int root = find(fa[x]);  // 先递归到根节点  
           front[x] += front[fa[x]]; // 回溯时累加距离  
           fa[x] = root;            // 路径压缩  
       }
       return fa[x];
   }  
   ```  
2. **合并时的权值修正**：  
   ```cpp  
   void merge(int x, int y) {
       int fx = find(x), fy = find(y);
       fa[fx] = fy;                // 合并到 y 的尾部  
       front[fx] = num[fy];        // 更新距离为 y 列原有长度  
       num[fy] += num[fx];         // 更新 y 列总长度  
   }  
   ```

---

### 同类题目推荐  
1. **P2342 [NOI2016] 重拍队伍**（带权并查集维护队列顺序）  
2. **P2024 [NOI2001] 食物链**（带权并查集模 3 余数）  
3. **P1525 [NOIP2010] 关押罪犯**（并查集扩展条件判断）  

---

### 可视化设计（复古像素风格）  
**动画流程**：  
1. **初始状态**：  
   - 每个战舰显示为独立方块，颜色按列区分  
   - 根节点闪烁显示，右侧标注 `num` 和 `front` 值  

2. **合并操作**：  
   - 被合并列（如列A）的根节点飞向目标列（列B）尾部  
   - 列A根节点显示 `front[A] = num[B]` 的公式推导  
   - 合并后列B的 `num` 值动态增长  

3. **路径压缩**：  
   - 当前节点高亮为红色，递归向根移动  
   - 路径上的节点 `front` 值实时更新，显示累加过程  

**交互功能**：  
- **步进控制**：空格键单步执行合并/查询  
- **音效反馈**：路径压缩时播放“滴”声，合并成功时播放“叮”声  
- **自动演示**：按 `A` 键启动 AI 自动随机操作  

---

### 代码实现（关键逻辑）  
**JavaScript 核心动画逻辑**：  
```javascript  
class WarshipAnimator {
  constructor() {
    this.nodes = Array(30).fill().map((_,i) => ({ 
      id: i, parent: i, front: 0, num: 1 
    }));
  }

  // 合并动画
  async merge(x, y) {
    let fx = this.find(x), fy = this.find(y);
    this.highlightNode(fx, 'red'); // 高亮被合并的根节点
    await delay(500);
    this.nodes[fx].parent = fy;
    this.nodes[fx].front = this.nodes[fy].num; 
    this.nodes[fy].num += this.nodes[fx].num;
    playSound('merge_success'); // 播放合并音效
  }

  // 路径压缩动画  
  async find(x) {
    if (this.nodes[x].parent !== x) {
      this.highlightNode(x, 'yellow');
      let parent = await this.find(this.nodes[x].parent);
      this.nodes[x].front += this.nodes[parent].front;
      this.nodes[x].parent = parent; 
      playSound('path_compress'); // 路径压缩音效
    }
    return this.nodes[x].parent;
  }
}
```

---
处理用时：79.05秒
# 题目信息

# 最大加权矩形

## 题目描述

为了更好的备战 NOIP2013，电脑组的几个女孩子 LYQ,ZSC,ZHQ 认为，我们不光需要机房，我们还需要运动，于是就决定找校长申请一块电脑组的课余运动场地，听说她们都是电脑组的高手，校长没有马上答应他们，而是先给她们出了一道数学题，并且告诉她们：你们能获得的运动场地的面积就是你们能找到的这个最大的数字。

校长先给他们一个 $n\times n$ 矩阵。要求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大 。矩阵的每个元素属于 $[-127,127]$ ,例如

```plain
 0 –2 –7  0 
 9  2 –6  2
-4  1 –4  1 
-1  8  0 –2
```

在左下角：

```plain
9  2
-4  1
-1  8
```

和为 $15$。

几个女孩子有点犯难了，于是就找到了电脑组精打细算的 HZH，TZY 小朋友帮忙计算，但是遗憾的是他们的答案都不一样，涉及土地的事情我们可不能含糊，你能帮忙计算出校长所给的矩形中加权和最大的矩形吗？


## 说明/提示

$1 \leq n\le 120$

## 样例 #1

### 输入

```
4
0 -2 -7 0
 9 2 -6 2
-4 1 -4  1 
-1 8  0 -2
```

### 输出

```
15```

# AI分析结果



**算法分类**: 动态规划（矩阵压缩与最大子段和结合）

---

### **题解思路、算法要点与解决难点**
- **核心思路**：将二维问题通过矩阵压缩降维为一维，利用最大子段和算法求解。
- **解决难点**：
  1. **矩阵压缩**：枚举所有可能的行区间（上下边界），将每列元素求和得到一维数组。
  2. **动态规划优化**：在一维数组中通过动态规划（或贪心）快速计算最大子段和。
- **时间复杂度**：O(n³)，适用于 n ≤ 120。
- **关键数据结构**：
  - 列前缀和数组加速列求和。
  - 临时一维数组存储压缩后的列和。

---

### **题解评分 (≥4星)**
1. **Yaser (5星)**  
   - **亮点**：清晰阐述矩阵压缩思想，代码结构简洁，时间复杂度最优。
   - **代码片段**：
     ```cpp
     void MatrixSum() {
         loop(i, 1, n) {
             mset(temp, 0);
             loop(j, i, n) {
                 loop(k, 1, n) temp[k] += matrix[j][k];
                 Arrsum(); // 调用一维最大子段和
             }
         }
     }
     ```

2. **X_WT (4.5星)**  
   - **亮点**：通过列前缀和优化压缩过程，代码注释清晰。
   - **关键代码**：
     ```cpp
     for(i=1;i<=n;++i)
         for(k=1;k<=i;++k) {
             int f[150]={0}, dp[150]={0};
             for(j=1;j<=n;++j) {
                 f[j] = a[i][j] - a[i-k][j]; // 列压缩
                 dp[j] = max(dp[j-1]+f[j], f[j]);
                 ans = max(ans, dp[j]);
             }
         }
     ```

3. **tommymio (4星)**  
   - **亮点**：优化最大子段和为贪心实现，减少空间占用。
   - **核心逻辑**：
     ```cpp
     for(k=1;k<=n;++k) {
         int tmp = b[i][k] - b[j][k];
         if(sum<0) sum=0;
         sum += tmp;
         ans = max(ans, sum);
     }
     ```

---

### **最优思路或技巧提炼**
1. **矩阵压缩**：枚举行区间 `[i, j]`，将每列求和压缩为一行。
2. **动态规划/贪心**：对压缩后的一维数组，使用 O(n) 的最大子段和算法。
3. **前缀和优化**：预处理列前缀和，加速列压缩计算。

---

### **同类型题与算法套路**
- **相似问题**：二维最大子矩阵、三维最大子立方体。
- **通用解法**：通过维度压缩（行、列、层）转化为低维问题，结合动态规划。

---

### **推荐题目**
1. **P1115**：最大子段和（一维基础）。
2. **P2642**：双子序列最大和（二维扩展）。
3. **P3400**：仓鼠窝（二维矩阵特殊约束）。

---

### **可视化与算法演示**
**动画设计**：
1. **矩阵压缩过程**：
   - **颜色标记**：选中行区间 `[i, j]` 时高亮为绿色。
   - **列求和**：实时显示每列累加结果，形成一维数组。
2. **最大子段和**：
   - **动态指针**：用红色指针标记当前处理位置，蓝色标记当前最大子段。
   - **状态更新**：显示 `sum` 变量变化，当 `sum < 0` 时重置为黄色闪烁。

**复古像素风格**：
- **8位色盘**：矩阵用16色像素块表示，选中区域闪烁。
- **音效**：
  - 行选中时播放 "beep" 音效。
  - 最大子段更新时播放 "coin" 音效。

**交互控制**：
- **步进速度**：拖动滑块调整压缩和计算速度。
- **AI自动模式**：自动遍历所有行区间，高亮最优解路径。

---

**核心代码片段（动态规划部分）**：
```cpp
// 矩阵压缩后的一维最大子段和
void Arrsum() {
    int sum = 0, max_ending_here = 0;
    for (int i = 1; i <= n; ++i) {
        max_ending_here = max(temp[i], max_ending_here + temp[i]);
        sum = max(sum, max_ending_here);
    }
    ans = max(ans, sum);
}
```

---

**总结**：通过矩阵压缩降维结合动态规划，是解决二维最大子矩阵问题的经典方法。其核心在于高效处理高维数据的技巧与基础算法的灵活应用。

---
处理用时：84.72秒
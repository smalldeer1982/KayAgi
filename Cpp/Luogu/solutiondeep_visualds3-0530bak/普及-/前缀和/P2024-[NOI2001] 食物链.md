# 题目信息

# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# AI分析结果



## 【算法分类】
**并查集（种类并查集/带权并查集）**

---

## 【题解要点与难点对比】

### **核心思路**
- **种类并查集**：将每个动物拆分为三个逻辑集合（同类/猎物/天敌），通过维护三倍大小的并查集表达环形关系。  
- **带权并查集**：在传统并查集中增加权值变量，用 `0/1/2` 表示与父节点的关系（同类/捕食/被捕食），通过路径压缩时的模运算推导全局关系。

### **解决难点对比**
| 方法             | 关键实现                                                                 | 难点                                                                 |
|------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------|
| **种类并查集**   | 合并 `x` 的同类、猎物、天敌集合到 `y` 对应集合                           | 需同时维护三组关系，合并逻辑需严格遵循环形食物链规则               |
| **带权并查集**   | 路径压缩时更新权值：`d[x] = (d[x] + d[fa]) % 3`                          | 权值运算需满足模3环状关系，合并时的权值偏移推导容易出错             |

---

## 【精选题解 (≥4星)】
### 1. Sooke的题解（⭐️⭐️⭐️⭐️⭐️）
- **亮点**：  
  1. 用三倍数组直观划分三类关系，逻辑清晰易懂  
  2. 通过图解展示合并过程，适合新手理解  
  3. 代码简洁（仅50行），维护三个集合的合并操作
- **核心代码**：
  ```cpp
  void merge(int x, int y) {
      fa[find(x)] = find(y);
      fa[find(x + n)] = find(y + n);
      fa[find(x + 2n)] = find(y + 2n);
  }
  ```

### 2. 天泽龟的带权并查集（⭐️⭐️⭐️⭐️）
- **亮点**：  
  1. 权值推导公式严谨，数学证明完整  
  2. 路径压缩时的权值更新逻辑巧妙  
  3. 空间复杂度更低（仅需单倍数组）
- **核心公式**：  
  `d[fx] = (d[y] - d[x] + 3) % 3` （合并同类）  
  `d[fx] = (d[y] - d[x] + 4) % 3` （捕食关系）

### 3. 檀黎斗·神的极简代码（⭐️⭐️⭐️⭐️）
- **亮点**：  
  1. 用猎物/天敌域简化判断逻辑  
  2. 注释明确维护三类关系的合并规则  
  3. 仅50行实现，适合竞赛快速编码
- **核心判断逻辑**：
  ```cpp
  if (find(a) == find(b) || find(a) == find(b + n)) ans++;
  ```

---

## 【最优思路提炼】
1. **种类并查集**  
   - **核心技巧**：将每个元素扩展为三个逻辑节点，分别表示同类、猎物、天敌。  
   - **适用场景**：关系种类有限且固定（如本题的3种动物）。  
   - **优势**：逻辑直观，无需复杂数学推导。  

2. **带权并查集**  
   - **核心公式**：权值运算满足 `(a + b) % 3` 的环状关系。  
   - **优化点**：路径压缩时同步更新权值，空间效率更高。  

---

## 【同类型题与算法套路】
- **同类关系维护**：关押罪犯（对立关系）、银河英雄传说（距离统计）  
- **带权并查集模板**：维护节点间多维度关系（如距离、类别、层级）  

---

## 【推荐相似题目】
1. P1525 关押罪犯（种类并查集对立关系）  
2. P1196 银河英雄传说（带权并查集距离统计）  
3. P1955 程序自动分析（离散化+并查集等价关系）  

---

## 【可视化设计】
### **动画方案**
1. **种类并查集**：  
   - **Canvas网格**：每个动物显示为三个色块（红=同类，绿=猎物，蓝=天敌）  
   - **合并过程**：高亮被合并的三个集合，箭头动态连接对应色块  
   - **音效**：合并时播放“连接”音效，冲突时播放“错误”音效  

2. **带权并查集**：  
   - **权值标签**：节点上方显示当前权值（0/1/2），路径压缩时数值动态变化  
   - **关系推导**：用虚线箭头标注捕食路径，权值叠加后取模  

### **复古像素风格**
- **8位调色板**：红（#FF0000）、绿（#00FF00）、蓝（#0000FF）  
- **音效设计**：  
  - 正确合并：8-bit "ping" 音  
  - 错误冲突：短促低音爆破声  
- **自动演示**：逐步展示合并与冲突判断，按空格键单步执行  

---

## 【核心代码实现（种类并查集）】
```cpp
const int MAXN = 5e4 * 3 + 10;
int fa[MAXN];

int find(int x) {
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}

void solve() {
    int n, k, ans = 0;
    cin >> n >> k;
    for (int i = 1; i <= 3 * n; i++) fa[i] = i;
    
    while (k--) {
        int op, x, y;
        cin >> op >> x >> y;
        if (x > n || y > n) { ans++; continue; }
        
        if (op == 1) { // 同类判定
            if (find(x) == find(y + n) || find(x) == find(y + 2 * n)) {
                ans++;
            } else {
                fa[find(x)] = find(y);
                fa[find(x + n)] = find(y + n);
                fa[find(x + 2 * n)] = find(y + 2 * n);
            }
        } else { // 捕食判定
            if (find(x) == find(y) || find(x) == find(y + n)) {
                ans++;
            } else {
                fa[find(x + n)] = find(y);
                fa[find(y + 2 * n)] = find(x);
                fa[find(x + 2 * n)] = find(y + n);
            }
        }
    }
    cout << ans;
}
```

---
处理用时：94.36秒
# 题目信息

# [CRCI 2008] PLATFORME 平板

## 题目描述

为了进行一种游戏，现决定搭造一些平板，而各个平板的地址已经选定。基于最普遍的认识，没有任何支持物的平板不可能漂浮在空中。说的更精确些，任意一平板的两端必需有支柱或者它在另一块平板上。

你会得到各个平板在坐标系中的坐标（如左下图）。每一块平板的坐标都是由它的高度（与地板间的垂直距离）和它的水平方位（开始和结束）决定的。每个支柱都距它支撑的平板的边缘半个单位（如图）。

算出支持所有平板的支柱的总长度。

 ![](https://cdn.luogu.com.cn/upload/pic/994.png) 



## 样例 #1

### 输入

```
3

1 5 10

3 1 5

5 3 7

```

### 输出

```
14```

# AI分析结果



### 算法分类  
**模拟 + 贪心**

---

### 综合分析与结论  
**核心思路**：  
1. **排序预处理**：将平板按高度从低到高排序，保证处理每个平板时其下方的支撑结构已确定。  
2. **支撑高度查询**：对每个平板的左右端点，找到其下方最近的支撑点高度（可能是其他平板或地面）。  
3. **动态维护支撑高度**：处理完当前平板后，更新其覆盖区间内的支撑高度。  

**核心难点与解决方案**：  
- **边缘处理**：支柱位于平板端点内侧0.5单位。通过将坐标×2转换为整数运算（如 `谬悠` 的解法），避免浮点误差。  
- **高效查询**：  
  - **暴力枚举**（`mzyy1001`）：遍历所有平板判断是否支撑，时间复杂度 O(n²)。  
  - **线段树**（`Makasukaka`）：维护区间最大高度，查询和更新均 O(log h)。  
  - **数组模拟**（`常清静矣`）：直接记录每个坐标点的高度，时间 O(n)，空间 O(max_x)。  

**可视化设计思路**：  
- **动画方案**：  
  1. **坐标网格**：以像素网格表示坐标轴，平板显示为水平线段。  
  2. **支柱动态绘制**：处理每个平板时，左右端点向下延伸至当前支撑高度（红色高亮），并更新覆盖区间颜色。  
  3. **颜色标记**：  
     - 当前处理平板：黄色高亮。  
     - 支柱延伸过程：红色动态生长。  
     - 已更新区间：渐变蓝色。  
- **复古风格**：  
  - **8-bit 音效**：支柱延伸时播放“滴”声，完成时播放“叮”声。  
  - **Canvas 动画**：平板用像素块绘制，支柱生长效果类似经典游戏《打砖块》。  

---

### 题解评分（≥4星）  
1. **Makasukaka（线段树）**  
   - ⭐⭐⭐⭐⭐  
   - 亮点：通用性强，支持大数据范围；引入线段树优化查询。  
   - 心得：通过坐标偏移巧妙处理开闭区间问题。  
2. **常清静矣（模拟数组）**  
   - ⭐⭐⭐⭐  
   - 亮点：图解清晰，代码简洁；利用坐标×2避免浮点运算。  
3. **wuzhoupei（暴力枚举）**  
   - ⭐⭐⭐⭐  
   - 亮点：代码极简，适合快速实现；通过排序避免重复判断。  

---

### 最优思路提炼  
**关键技巧**：  
1. **坐标转换**：将端点坐标×2，将支柱位置转换为整数坐标，避免浮点运算。  
2. **动态更新**：按高度排序后，每个平板的处理只需关注其下方已处理的区间。  
3. **贪心维护**：使用数组或线段树维护每个点的最大高度，确保支撑高度最优。  

**代码片段（模拟数组）**：  
```cpp
int h[20001] = {0}; // 坐标范围扩大后的高度数组
sort(a, a+n, [](auto &x, auto &y) { return x.y < y.y; });
int ans = 0;
for (auto &p : a) {
    int l = p.x1 * 2 + 1, r = p.x2 * 2 - 1; // 转换为整数坐标
    ans += p.y - h[l]; // 左支柱
    ans += p.y - h[r]; // 右支柱
    for (int i = l; i <= r; i++) h[i] = p.y; // 更新区间
}
```

---

### 类似题目推荐  
1. **P1904 天际线** - 区间覆盖与高度查询。  
2. **P5490 矩形面积并** - 扫描线算法处理区间覆盖。  
3. **P1884 覆盖统计** - 动态维护区间覆盖状态。  

---

### 个人心得摘录  
- **调试教训**（`重回巅峰！`）：坐标扩大后数组开小导致 RE，需预计算最大坐标。  
- **优化顿悟**（`Makasukaka`）：通过线段树维护闭区间，修改时偏移实现开区间效果。  

---

### 复古游戏化动画代码片段（JS）  
```javascript
// 初始化 Canvas
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let speed = 100; // 动画速度（ms/步）

// 8-bit 音效
const audio = { 
  pillar: new Audio('data:audio/wav;base64,UklGRl9...'), 
  done: new Audio('data:audio/wav;base64,UklGRk9...')
};

function drawPlatform(x1, x2, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x1*10, 300 - y*10, (x2 - x1)*10, 5); // 绘制平板
}

function animatePillar(x, y, height) {
  let currentY = y;
  const timer = setInterval(() => {
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(x*10, 300 - currentY*10, 5, 5); // 绘制支柱
    currentY--;
    if (currentY <= height) {
      clearInterval(timer);
      audio.done.play();
    }
  }, speed);
}
```

---
处理用时：98.27秒
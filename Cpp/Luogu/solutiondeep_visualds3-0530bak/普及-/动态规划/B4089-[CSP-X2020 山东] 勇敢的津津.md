# 题目信息

# [CSP-X2020 山东] 勇敢的津津

## 题目描述

津津是个勇敢的孩子，总是做一些挑战自己的事情。一天津津来到一条宽为 $L$ 米的小河边，河道的一边到另一边需要途径 $N$ 块较大的石墩，每块石墩到这一边岸边之间距离 $d_i$ 米（石墩不占距离，只考虑石墩的中间点到这一边岸边之间距离）。津津想踩着这些石墩从小河的这一边跳到另一边（不落入水中），一次可以跳过几块石墩。已知津津每次最多跳 $M$ 米的距离，那么津津最少跳几次就能从这一边跳到另一边？

## 说明/提示

【样例解释】

样例一：津津可以从岸边跳到距离为 $2$ 的石墩上，然后跳到距离为 $4$ 的石墩上，再跳到距离为 $6$ 的石墩上，再跳到距离为 $8$ 的石墩上，最后跳到对岸。总共 $5$ 跳跃。

样例二：津津可以从岸边跳到距离为 $2$ 的石墩上，然后跳到距离为 $11$ 的石墩上，再跳到距离为 $21$ 的石墩上，最后跳到对岸。总共 $4$ 跳跃。

【数据范围】

对于 $30\%$ 的数据，$1\leq N\leq 10$。

对于 $50\%$ 的数据，$1\leq N\leq 100$。

对于 $100\%$ 的数据，$1\leq N\leq 500$，$1\leq M,L\leq 10^6$。

## 样例 #1

### 输入

```
10 4 2
2
4
6
8```

### 输出

```
5```

## 样例 #2

### 输入

```
25 5 10
2
11
14
17
21```

### 输出

```
4```

# AI分析结果



---

### 唯一算法分类  
**线性DP**

---

### 综合分析与结论  
**核心思路与难点**  
本题需要找到从起点到终点的最小跳跃次数，每次跳跃不超过最大距离 M。动态规划是更可靠的解法，贪心策略可能因跳跃逻辑限制无法保证最优解。  

**动态规划设计**  
- **状态定义**：`dp[i]` 表示到达第 i 个石墩的最小跳跃次数。  
- **转移方程**：对于每个石墩 i，遍历所有 j < i，若 `d[i] - d[j] <= M`，则 `dp[i] = min(dp[i], dp[j] + 1)`。  
- **初始化**：起点 0 的虚拟跳跃次数为 0，其他初始化为无穷大。  
- **终点处理**：遍历所有石墩 i，若 `L - d[i] <= M`，则总次数为 `dp[i] + 1`。  

**可视化设计**  
- **动画方案**：  
  - **网格绘制**：用 Canvas 绘制石墩位置和 DP 数组，当前更新的格子高亮显示。  
  - **颜色标记**：绿色表示当前可跳跃路径，红色表示不可达。  
  - **步进控制**：单步执行更新，观察每个 `dp[i]` 的变化。  
- **像素风格**：采用 8-bit 风格，石墩用方块表示，跳跃路径用线段动态绘制。  

---

### 题解清单 (≥4星)  
**1. 动态规划法（4.5星）**  
- **亮点**：逻辑清晰，代码简洁，严格处理所有可能路径。  
- **实现**：排序石墩后递推，确保状态转移的正确性。  

---

### 代码实现  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

int main() {
    int L, M, N;
    cin >> L >> M >> N;
    vector<int> d(N);
    for (int i = 0; i < N; ++i) cin >> d[i];
    sort(d.begin(), d.end());
    
    vector<int> dp(N, INT_MAX);
    for (int i = 0; i < N; ++i) {
        if (d[i] <= M) dp[i] = 1;
        for (int j = 0; j < i; ++j) {
            if (d[i] - d[j] <= M && dp[j] != INT_MAX) {
                dp[i] = min(dp[i], dp[j] + 1);
            }
        }
    }
    
    int ans = INT_MAX;
    for (int i = 0; i < N; ++i) {
        if (L - d[i] <= M && dp[i] != INT_MAX) {
            ans = min(ans, dp[i] + 1);
        }
    }
    cout << (ans == INT_MAX ? -1 : ans) << endl;
    return 0;
}
```

---

### 最优思路提炼  
1. **排序预处理**：确保石墩按距离递增排列。  
2. **动态规划递推**：状态转移保证最小跳跃次数。  
3. **终点特判**：检查从每个石墩到对岸的可能性。  

---

### 类似题目推荐  
1. **跳跃游戏 II（LeetCode 45）**  
2. **青蛙过河（LeetCode 403）**  
3. **最小覆盖子串（动态规划变种）**  

---

### 可视化设计要点  
- **Canvas 交互**：点击石墩显示跳跃路径，动态更新 DP 数组。  
- **音效触发**：跳跃成功时播放上升音调，失败时短促提示音。  
- **自动演示**：设置自动模式，按最优路径逐步高亮跳跃过程。  

---

**总结**：动态规划是解决此类跳跃问题的可靠方法，通过状态转移严格保证最优解。排序预处理和终点特判是代码实现的关键细节。

---
处理用时：352.80秒
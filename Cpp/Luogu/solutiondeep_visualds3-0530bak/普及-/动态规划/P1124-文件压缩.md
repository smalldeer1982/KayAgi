# 题目信息

# 文件压缩

## 题目背景

提高文件的压缩率一直是人们追求的目标。近几年有人提出了这样一种算法，它虽然只是单纯地对文件进行重排，本身并不压缩文件，但是经这种算法调整后的文件在大多数情况下都能获得比原来更大的压缩率。


## 题目描述

该算法具体如下：对一个长度为 $n$ 的字符串 $S$，首先根据它构造 $n$ 个字符串，其中第 $i$ 个字符串由将 $S$ 的前 $i-1$ 个字符置于末尾得到。然后把这 $n$ 个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们**在 $S$ 中的位置**从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串 $S'$ ，它的长度也是 $n$，并且包含了 $S$ 中的每一个字符。最后输出 $S'$ 以及 $S$ 的首字符在 $S'$ 中的位置 $p$。

举例：$S$ 是 `example`

1. 构造 $n$ 个字符串。

```plain
example
xamplee
ampleex
mpleexa
pleexam
leexamp
eexampl
```

2. 将字符串排序。

```plain
ampleex
example
eexampl
leexamp
mpleexa
pleexam
xamplee
```
3. 压缩结果。

$S' = \texttt{xelpame}$，$p = 7$

由于英语单词构造的特殊性，某些字母对出现的频率很高，因此在 $S'$ 中相同的字母有很大几率排在一起，从而提高 $S'$ 的压缩率。虽然这种算法利用了英语单词的特性，然而在实践的过程中，人们发现它几乎适用于所有的文件压缩。

请你编一个程序，读入 $S'$ 和 $p$，输出字符串 $S$。

保证 $S$ 仅含小写字母（所以输入的 $S'$ 也仅含小写字母）。

## 样例 #1

### 输入

```
7
xelpame
7
```

### 输出

```
example
```

# AI分析结果



### 算法分类
**无算法分类**

---

### 题解思路、算法要点与解决难点

#### 核心思路
1. **构造首尾对应环**：将输入的压缩字符串 `S'` 排序得到首字母序列，每个首字母与 `S'` 中的尾字母一一对应，形成首尾相连的环。
2. **倒推还原原字符串**：从给定位置 `p` 出发，逆向遍历环，每次通过当前尾字母找到对应的首字母位置，最终逆序输出结果。

#### 解决难点
- **重复字符处理**：当存在重复字符时，需确保每次匹配的位置唯一。
- **正推 vs 倒推**：正推可能在无序的 `S'` 中无法正确连接字符；倒推利用排序后的首字母序列有序性，从后往前查找确保正确性。

---

### 题解评分 (≥4星)

1. **MC_Launcher（5星）**
   - **亮点**：代码简洁，利用倒推避免错位，通过标记已匹配字符解决重复问题。
   - **核心代码**：从后往前查找并标记字符，最终逆序输出。
2. **liuzhaoxu（4星）**
   - **亮点**：详细分析正推错误原因，提出倒推的正确性证明，代码逻辑清晰。
3. **Cat_cc（4星）**
   - **亮点**：利用字符统计维护左右边界，避免重复遍历，高效匹配位置。

---

### 最优思路或技巧提炼
1. **首尾环构造**：将 `S'` 排序后的首字母序列与原尾字母序列一一对应，形成环状结构。
2. **倒推匹配**：从 `p` 位置出发，每次在排序后的序列中**从后往前**查找当前字符，确保唯一性。
3. **标记机制**：匹配后立即标记字符（如替换为特殊字符），避免重复使用。

---

### 同类型题或类似算法套路
- **字符串循环移位构造**：如 Burrows-Wheeler 变换的逆变换。
- **环状结构还原问题**：需通过部分信息还原完整序列。

---

### 推荐洛谷题目
1. [P6103 [POI2010]KLO-Blocks](https://www.luogu.com.cn/problem/P6103)（字符处理与统计）
2. [P1012 [NOIP1998 提高组] 拼数](https://www.luogu.com.cn/problem/P1012)（字符串排序与拼接）
3. [P1368 【模板】最小表示法](https://www.luogu.com.cn/problem/P1368)（循环移位字符串处理）

---

### 个人心得摘录
- **MC_Launcher**：*“第一次正着排才10分，倒着找才能避免错位。”*  
- **liuzhaoxu**：*“正推时 `S'` 是无序的，导致无法正确连接字符。”*  
- **张心博harry**：*“挂了一周，才发现顺序必须倒推。”*

---

### 可视化与算法演示（核心逻辑）

#### 动态规划矩阵动画方案（伪代码）
```javascript
// 初始化排序后的首字母数组 sorted 和原尾字母数组 s
const sorted = [...s].sort();
const marked = [...sorted]; // 用于标记已匹配的字符

// 初始位置 p，找到第一个匹配点
let currentPos = findFirstMatch(s[p], sorted);

// 逆序构建结果数组
const result = [];
for (let i = 0; i < n; i++) {
  result.push(s[currentPos]);
  // 从后往前查找下一个匹配位置
  for (let j = n - 1; j >= 0; j--) {
    if (marked[j] === s[currentPos]) {
      marked[j] = '#'; // 标记已使用
      currentPos = j;
      break;
    }
  }
}
```

#### 复古游戏化动画效果
- **像素风格**：用 8-bit 风格绘制排序数组和原数组，每个字符为 16x16 像素块。
- **音效设计**：
  - **匹配成功**：8-bit 上升音效。
  - **标记字符**：短促“滴”声。
- **自动演示**：按步执行，高亮当前查找位置和匹配过程，支持暂停/继续。

---

### 代码片段（MC_Launcher 核心逻辑）
```cpp
int now = 找到首字符位置;
ans[0] = a[now];
for (int i = 1; i < n; i++) {
  for (int j = n - 1; j >= 0; j--) { // 倒推关键
    if (b[j] == a[now]) {
      now = j;
      ans[i] = a[now];
      b[j] = ')'; // 标记
      break;
    }
  }
}
// 逆序输出
for (int i = n - 1; i >= 0; i--) cout << ans[i];
```

---
处理用时：61.62秒
# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果



# 算法分类
线性DP

---

## 题解思路与算法要点
### 核心思路
1. **拓扑排序保证无后效性**：题目本质是求DAG上每个节点作为终点的最长路径长度。拓扑排序确保每个节点的前驱节点先被处理，满足动态规划的无后效性。
2. **状态转移方程**：`dp[v] = max(dp[v], dp[u]+1)`，其中u是v的前驱节点。每个节点的初始值为1（自身）。
3. **两种实现方式**：
   - **拓扑序+线性DP**：显式生成拓扑序后按序更新
   - **记忆化搜索+反向图**：反向建图递归求解最大值
4. **时间复杂度**：两种方法均为O(N+M)，但拓扑序DP常数更优

### 解决难点
- **拓扑序的推导**：通过入度为0的队列不断消减入度生成拓扑序
- **状态转移的触发时机**：在拓扑排序过程中或之后处理，确保前驱已更新
- **反向图的巧妙应用**：将终点转化为起点，用记忆化搜索避免重复计算

---

## 题解评分（≥4星）
1. **wshz（5星）**  
   - 拓扑与DP合并，代码极简  
   - 队列直接维护拓扑序，边排序边更新  
   - 时间复杂度最优，适合1e5规模数据
2. **星星之火（4星）**  
   - 详细讲解拓扑排序原理  
   - 分离拓扑排序与DP阶段，逻辑清晰  
   - 完整代码注释，适合新手学习
3. **归山_（4星）**  
   - 反向图+记忆化搜索思路新颖  
   - 代码简洁，递归式状态转移直观  
   - 对理解DAG最长路径问题有启发

---

## 最优思路提炼
1. **拓扑序DP三要素**：
   - 用入度队列生成拓扑序
   - DP数组初始化为1（每个节点自身）
   - 按拓扑序遍历，更新所有后继节点
2. **核心代码片段**：
```cpp
// 拓扑排序
queue<int> q;
for(int i=1; i<=n; i++) 
    if(in[i]==0) q.push(i), dp[i]=1;
while(!q.empty()){
    int u = q.front(); q.pop();
    for(int v : g[u]){
        dp[v] = max(dp[v], dp[u]+1);
        if(--in[v] == 0) q.push(v);
    }
}
```
3. **可视化关键**：
   - 红色高亮当前处理的节点u
   - 绿色闪烁被更新的节点v
   - 动态显示dp[v]数值变化过程

---

## 同类问题与推荐题目
1. **P4017 最大食物链计数**  
   DAG入度/出度统计，相似拓扑序DP
2. **P1113 杂务**  
   拓扑排序求最长路径经典题
3. **P3387 缩点+最长路径**  
   DAG上动态规划的进阶应用

---

## 可视化设计（复古像素版）
### 动画方案
1. **8位风格网格**：
   - 每个节点用16x16像素块表示
   - 颜色深浅表示dp值（深红=1 → 浅黄=最大值）
2. **自动演示模式**：
   - 队列节点黄色边框
   - 当前处理节点红色闪烁
   - 被更新节点绿色渐变动画
3. **音效设计**：
   - 节点入队：8-bit "beep"短音
   - dp更新：上升音阶
   - 拓扑序完成：胜利小调

### 交互功能
```javascript
// 伪代码演示核心逻辑
const canvas = document.getElementById('pixel-grid');
ctx.fillStyle = '#FF0000'; // 当前节点红色
ctx.fillRect(x*16, y*16, 16, 16); 

// 音效触发
function playUpdateSound() {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(440 + dp[v]*50, audioCtx.currentTime);
    osc.start().stop(audioCtx.currentTime + 0.1);
}
```

---

## 个人心得摘录
> "调试时发现忘记初始化dp数组为1，OI十年泪两行" —— 归山_  
> **总结**：初始化是DP的关键步骤，节点自身必须计入路径长度

> "拓扑序的性质保证了我们只需要关心前驱，这是动态规划的精髓" —— 星星之火  
> **总结**：无后效性是DP设计的核心原则，拓扑排序完美契合这一需求

---

完整代码参考（wshz拓扑+DP合并版）：
```cpp
#include<iostream>
#include<queue>
using namespace std;
const int N=1e5+5;
vector<int> g[N];
int dp[N], in[N], n, m;

int main() {
    cin >> n >> m;
    for(int u,v,i=0; i<m; i++){
        cin >> u >> v;
        g[u].push_back(v);
        in[v]++;
    }
    queue<int> q;
    for(int i=1; i<=n; i++) 
        if(!in[i]) q.push(i), dp[i]=1;
    
    while(!q.empty()){
        int u = q.front(); q.pop();
        for(int v : g[u]){
            dp[v] = max(dp[v], dp[u]+1);
            if(--in[v] == 0) q.push(v);
        }
    }
    for(int i=1; i<=n; i++) 
        cout << dp[i] << endl;
    return 0;
}
```

---
处理用时：69.10秒
# 题目信息

# 小A点菜

## 题目背景

uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。


## 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。


## 说明/提示

2020.8.29，增添一组 hack 数据 by @yummy

## 样例 #1

### 输入

```
4 4
1 1 2 2
```

### 输出

```
3
```

# AI分析结果



# 【算法分类】  
**0-1背包**  

---

# 【题解核心思路与难点分析】  
**核心思路**：将点菜问题转化为 0-1 背包的恰好装满问题，动态规划统计方案数。  
**关键状态转移**：`f[j] += f[j - a[i]]`（逆序遍历金额）  
**核心难点**：  
1. **状态初始化**：`f[0] = 1` 表示恰好花 0 元有 1 种方案（空选）  
2. **逆序遍历**：确保每个菜品仅被选一次，避免重复计数  
3. **边界条件**：当 `j < a[i]` 时无法选当前菜品  

---

# 【题解评分（≥4星）】  
1. **Dream_zhc（5星）**  
   - 亮点：详细推导从二维到一维的降维过程，通过图示解释逆序遍历原理  
   - 代码：`f[j] = f[j] + f[j - a[i]]` 简洁高效  
2. **WilliamPen（4星）**  
   - 亮点：代码注释清晰，直接给出标准 0-1 背包模板  
   - 优化：`j >= v[i]` 条件判断避免越界  
3. **康师傅（4星）**  
   - 亮点：边读边处理数据，减少内存占用  
   - 技巧：`++dp[a]` 直接处理单价等于金额的情况  

---

# 【最优思路提炼】  
**关键技巧**：  
1. **一维滚动数组**：将空间复杂度从 O(NM) 降为 O(M)  
2. **逆序更新**：从大到小遍历金额，保证每个菜品只被选一次  
3. **方案数累加**：转移时叠加历史状态而非覆盖  

**代码实现核心**：  
```cpp
int f[10001] = {1}; // 初始化 f[0] = 1
for (int i = 1; i <= n; i++) {
    for (int j = m; j >= a[i]; j--) {
        f[j] += f[j - a[i]]; // 逆序更新方案数
    }
}
```

---

# 【同类型题与算法套路】  
**通用解法**：  
- 0-1 背包求方案数：状态转移方程与本题一致  
- 恰好装满问题：初始化 `f[0] = 1`，其他为 0  
- 空间优化：逆序遍历容量  

**推荐题目**：  
1. P1048 [NOIP2005 普及组] 采药（最大价值）  
2. P1064 [NOIP2006 提高组] 金明的预算方案（依赖背包）  
3. P2347 [NOIP1996 提高组] 砝码称重（多重背包变种）  

---

# 【可视化与算法演示】  
**像素化 DP 动画设计**：  
1. **Canvas 网格**：  
   - 横向表示金额 (0~M)，纵向动态显示当前菜品  
   - 每个格子显示 `f[j]` 值，更新时高亮变化单元格  
2. **音效提示**：  
   - 更新格子时播放 8-bit "beep" 短音  
   - 完成一轮菜品处理时播放上升音阶  
3. **自动演示模式**：  
   - 按菜品顺序自动播放，红色箭头指示当前处理位置  
   - 右侧显示当前菜品价格和剩余金额  

**交互功能**：  
```javascript
// 伪代码示例
function updateDP(a) {
  for (let j = m; j >= a; j--) {
    grid[j].value += grid[j - a].value;
    grid[j].flash(); // 高亮动画
    playSound('beep'); 
  }
}
```

---

# 【代码实现（核心片段）】  
**完整一维 DP 代码**：  
```cpp
#include <iostream>
using namespace std;

int main() {
    int n, m, a[101], f[10001] = {1};
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= a[i]; j--)
            f[j] += f[j - a[i]];
    
    cout << f[m];
    return 0;
}
```

---

# 【总结与扩展】  
本题通过 0-1 背包的变形，展示了动态规划在方案计数问题中的高效性。关键点在于状态转移的设计和空间优化技巧。通过对比题解可发现，降维后的代码在时间和空间上均更优，是竞赛中的常用手段。

---
处理用时：48.70秒
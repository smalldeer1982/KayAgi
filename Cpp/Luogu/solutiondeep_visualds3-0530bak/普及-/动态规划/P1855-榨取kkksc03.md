# 题目信息

# 榨取kkksc03

## 题目描述

洛谷 2 的团队功能是其他任何 OJ 和工具难以达到的。借助洛谷强大的服务器资源，任何学校都可以在洛谷上零成本的搭建 OJ 并高效率的完成训练计划。

为什么说是搭建 OJ 呢？为什么高效呢？

![](https://cdn.luogu.com.cn/upload/pic/1236.png)

因为，你可以上传私有题目，团队外别人是无法看到的。我们还能帮你们评测！

你可以创建作业，给组员布置任务，查看组员的完成情况，还可以点评任意一份代码！

你可以创建比赛！既可以是 OI 赛制还可以是 ICPC 赛制！既可以是团队内部的私有比赛，也可以公开赛，甚至可以指定谁可以参加比赛。这样，搞“x 校联赛”最合适不过了。洛谷凭借这个功能，希望能够提供公开及私有比赛的另外一个平台。

![](https://cdn.luogu.com.cn/upload/pic/1237.png)

值得说明的是，本次比赛就是采用团队私有题目+邀请比赛的机制。

洛谷的运营组决定，如果一名 OIer 向他的教练推荐洛谷，并能够成功的使用（成功使用的定义是：该团队有 $20$ 个或以上的成员，上传 $10$ 道以上的私有题目，布置过一次作业并成功举办过一次公开比赛），那么他可以浪费掉 kkksc03 的一些时间的同时消耗掉 kkksc03 的一些金钱以满足自己的一个愿望。

kkksc03 的时间和金钱是有限的，所以他很难满足所有同学的愿望。所以他想知道在自己的能力范围内，最多可以完成多少同学的愿望？

## 样例 #1

### 输入

```
6 10 10
1 1
2 3 
3 2
2 5
5 2
4 3```

### 输出

```
4```

# AI分析结果



**【算法分类】**  
0-1背包（二维费用）

---

### **题解思路与算法要点**  
**核心难点**：在时间和金钱双重限制下，找到能实现的最大愿望数。  
**解法本质**：二维费用的01背包问题，每个愿望只能选择一次，需同时满足时间和金钱两个维度的约束。

**关键实现**：  
1. **状态设计**：`dp[j][k]` 表示用 j 元、k 分钟时能实现的最大愿望数  
2. **转移方程**：`dp[j][k] = max(dp[j][k], dp[j-m][k-t] + 1)`  
   （当前愿望若被选中，需从 `j-m` 元、`k-t` 分钟的状态转移）  
3. **逆序更新**：两重循环均逆序遍历，防止同一物品被重复选择

---

### **优质题解评分（≥4星）**  
1. **早右昕（5星）**  
   - 代码简洁，核心仅需 15 行  
   - 完美体现二维背包的逆序更新逻辑  
   - 时间复杂度 O(nMT) 严格符合数据规模  

2. **帅到报警（4.5星）**  
   - 独立封装 `Max()` 函数提高可读性  
   - 添加快读优化，适合大数据场景  
   - 注释清晰解释状态转移意义  

3. **yzpyzp（4星）**  
   - 对比一维与二维背包的差异  
   - 强调「双重费用需平衡」的核心思维  
   - 提供记忆化搜索的拓展思路

---

### **最优思路提炼**  
**降维技巧**：通过逆序遍历将三维状态压缩为二维  
**逆向思维**：  
- 普通背包：`dp[i][j] = max(选i, 不选i)`  
- 二维背包：`dp[j][k] = max(消耗j-m和k-t后的状态+1, 原状态)`  
**时间复杂度**：O(n×M×T)，完美适配题目约束（n≤100，M,T≤200）

---

### **同类型题目推荐**  
1. P1507 NASA的食物计划（二维费用+价值最大化）  
2. P1910 欢乐的跳（多维约束下的组合优化）  
3. P1855 榨取kkksc03（本题，二维费用+计数）

---

### **可视化设计思路**  
**像素化 DP 矩阵**：  
![二维背包动画示意图](https://i.imgur.com/ZlWz3qC.gif)  
1. **颜色编码**：  
   - 绿色：当前更新的单元格  
   - 蓝色：转移来源单元格（j-m, k-t）  
   - 红色：最大值更新时的闪烁提示  
2. **音效反馈**：  
   - 状态转移：8-bit "哔"声（Web Audio API）  
   - 最优更新：NES 风格升级音效  
3. **自动演示模式**：  
   - 按愿望顺序逐步展开矩阵更新  
   - 支持暂停观察每个愿望的影响范围  

**关键代码片段**：  
```javascript
// Canvas 绘制 DP 矩阵
function drawGrid(ctx, dp) {
  for(let j=0; j<=M; j++) {
    for(let k=0; k<=T; k++) {
      const color = 200 - dp[j][k]*20; // 颜色深浅反映愿望数
      ctx.fillStyle = `rgb(${color},${color},255)`;
      ctx.fillRect(j*10, k*10, 8, 8);
    }
  }
}
```

---

### **核心实现代码**  
```cpp
#include <iostream>
using namespace std;

int dp[205][205]; // dp[金钱][时间] = 最大愿望数

int main() {
    int n, M, T;
    cin >> n >> M >> T;
    for(int i=1; i<=n; i++) {
        int m, t;
        cin >> m >> t;
        // 逆序更新二维状态
        for(int j=M; j>=m; j--) 
            for(int k=T; k>=t; k--) 
                dp[j][k] = max(dp[j][k], dp[j-m][k-t] + 1);
    }
    cout << dp[M][T];
    return 0;
}
```

---

**特别说明**：本题与 NASA 食物计划（P1507）的核心区别在于价值计算方式（本题每个物品价值为1），但状态转移逻辑完全一致，可快速迁移解法。

---
处理用时：55.68秒
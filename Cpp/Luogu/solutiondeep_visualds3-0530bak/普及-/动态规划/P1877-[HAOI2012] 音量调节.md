# 题目信息

# [HAOI2012] 音量调节

## 题目描述

一个吉他手准备参加一场演出。他不喜欢在演出时始终使用同一个音量，所以他决定每一首歌之前他都需要改变一次音量。在演出开始之前，他已经做好一个列表，里面写着每首歌开始之前他想要改变的音量是多少。每一次改变音量，他可以选择调高也可以调低。

音量用一个整数描述。输入文件中整数 $beginLevel$，代表吉他刚开始的音量，整数 $maxLevel$，代表吉他的最大音量。音量不能小于 $0$ 也不能大于 $maxLevel$。输入中还给定了 $n$ 个整数 $c_1,c_2,c_3,\cdots,c_n$，表示在第 $i$ 首歌开始之前吉他手想要改变的音量是多少。

吉他手想以最大的音量演奏最后一首歌，你的任务是找到这个最大音量是多少。

## 说明/提示

$1\le n\le 50$，$1\le c_i\le beginLevel$，$1\le maxLevel\le 1000$，$0\le beginLevel\le maxLevel$。

## 样例 #1

### 输入

```
3 5 10
5 3 7
```

### 输出

```
10```

# AI分析结果



---

## 唯一算法分类
**线性DP**

---

## 题解思路、算法要点与解决难点

### 核心逻辑与算法要点
1. **状态定义**：`dp[i][j]` 表示前 `i` 首歌能否达到音量 `j`
2. **状态转移**：
   - 若 `dp[i-1][j]` 可达，则检查：
     - 调高音量：`j + c[i] ≤ maxLevel` 时，标记 `dp[i][j + c[i]] = 1`
     - 调低音量：`j - c[i] ≥ 0` 时，标记 `dp[i][j - c[i]] = 1`
3. **边界条件**：`dp[0][beginLevel] = 1`（初始状态）
4. **答案提取**：逆序遍历 `dp[n][j]` 找到最大可达音量

### 解决难点
- **状态转移的完整性**：需同时处理调高和调低两种操作，且避免越界
- **空间优化**：部分题解使用滚动数组或 `bitset` 减少内存占用
- **去重优化**：BFS 解法中通过标记数组避免重复状态入队

---

## 题解评分 (≥4星)

### 1. 作者：jackyzhu（5星）
- **亮点**：代码简洁清晰，状态转移逻辑直白，适合教学
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++)
    for(int j=maxlevel;j>=0;j--) {
      if(j-a[i]>=0) f[i][j]|=f[i-1][j-a[i]];
      if(j+a[i]<=maxlevel) f[i][j]|=f[i-1][j+a[i]];
    }
  ```

### 2. 作者：Kaizyn（4.5星）
- **亮点**：使用 `bitset` 实现高效位运算，复杂度 O(n·maxLevel/w)
- **核心代码**：
  ```cpp
  b = (b << tmp | b >> tmp) & cut; // 通过位移操作实现状态转移
  ```

### 3. 作者：Sleepy_Piggy（4星）
- **亮点**：逆向思维（从上一状态推导当前状态），逻辑直观
- **核心代码**：
  ```cpp
  if(f[i-1][j]&&j+a[i]<=maxn) f[i][j+a[i]]=1;
  if(f[i-1][j]&&j-a[i]>=0) f[i][j-a[i]]=1;
  ```

---

## 最优思路或技巧提炼

### 关键技巧
1. **逆向遍历音量范围**：避免同一轮更新覆盖状态（类似背包优化）
2. **滚动数组优化**：`dp[i]` 只依赖 `dp[i-1]`，可用双数组交替存储
3. **快速终止搜索**：逆序查找第一个可达音量后直接返回

### 代码片段（滚动数组优化）
```cpp
bool dp[2][1001] = {0};
dp[0][begin] = 1;
for(int i=1; i<=n; i++) {
  int cur = i%2, prev = 1-cur;
  memset(dp[cur], 0, sizeof(dp[cur]));
  for(int j=0; j<=maxLevel; j++) {
    if(!dp[prev][j]) continue;
    if(j+c[i] <= maxLevel) dp[cur][j+c[i]] = 1;
    if(j-c[i] >= 0) dp[cur][j-c[i]] = 1;
  }
}
```

---

## 同类型题与算法套路
- **类似题目**：硬币组合问题、跳跃游戏可达性判断
- **通用解法**：
  - 定义布尔状态数组记录可达性
  - 通过线性遍历更新状态
  - 倒序查找最优解

---

## 推荐题目
1. **P1048 采药**（经典 0-1 背包）
2. **P1412 砝码称重**（bitset 优化可达性 DP）
3. **P1941 飞扬的小鸟**（多状态线性 DP）

---

## 可视化与算法演示

### 动画设计方案
1. **8位像素风格**：
   - 使用 `16x16` 像素网格，每个格子表示音量值
   - 绿色表示可达状态，红色表示不可达
   - 当前操作步骤用闪烁边框高亮

2. **状态转移演示**：
   ```javascript
   // 伪代码演示更新过程
   function updateStep(i, j) {
     highlightCell(i-1, j); // 高亮上一状态
     if(j + c[i] <= maxLevel) flashCell(i, j + c[i]);
     if(j - c[i] >= 0) flashCell(i, j - c[i]);
     playSound('blip.wav'); // 播放 8-bit 音效
   }
   ```

3. **交互控制**：
   - **速度滑块**：调节动画速度（50ms~2000ms/步）
   - **单步执行**：手动触发每一步更新
   - **自动模式**：AI 自动播放，展示完整 DP 过程

---

## 个人心得摘录
> "BFS 解法需要剪枝避免重复状态，否则会 MLE。DP 的布尔状态记录法才是正解" —— HighPerformanceRobot  
> "bitset 的位移操作简直是魔法，瞬间将 O(n·maxLevel) 优化到 O(n·maxLevel/w)" —— Kaizyn

---

## 核心 DP 代码（复古像素风格实现）
```cpp
// 完整代码见 jackyzhu 题解
#include<bits/stdc++.h>
using namespace std;
int n,begin,maxlevel;
int a[51], f[51][1001];
int main() {
  scanf("%d%d%d",&n,&begin,&maxlevel);
  f[0][begin] = 1;
  for(int i=1; i<=n; i++) scanf("%d",&a[i]);
  for(int i=1; i<=n; i++)
    for(int j=maxlevel; j>=0; j--) {
      if(j-a[i]>=0) f[i][j] |= f[i-1][j-a[i]];
      if(j+a[i]<=maxlevel) f[i][j] |= f[i-1][j+a[i]];
    }
  for(int i=maxlevel; i>=0; i--)
    if(f[n][i]) { printf("%d",i); return 0; }
  printf("-1");
}
```

---
处理用时：61.88秒
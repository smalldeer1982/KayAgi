# 题目信息

# 大朋友的数字

## 题目背景

在 NOIP2013 的赛场上，常神牛华丽丽的手残了，小朋友的数字一题只得了 $10$ 分。于是，他要恶搞一下这道题。

## 题目描述

有一批大朋友（年龄 $15$ 岁以上），他们每人手上拿着一个数字，当然这个数字只有 $1$ 位，也就是 $0$ 到 $9$ 之间。每个大朋友的分数为在他之前的最长不下降子序列中所有数之和。（这个序列必须以它作为结尾！）如有多个最长不下降子序列，那么取编号字典序最小的。现在告诉你有 $n$ 个大朋友，以及他们各自的数字，请你求出他们每个人的分数。

## 说明/提示

【样例解释 $1$】

五个人分数分别为 $(1),(1+2),(1+2+5),(1+2+3),(1+2+3+4)$。

【样例解释 $2$】

五个人分数分别为 $(1),(1+7),(1+5),(1+7+9)$ （还有一个 $(1,5,9)$），$(1+5+6)$。

【数据规模】

对于 $50\%$ 的数据，$1\le n\le 500$；

对于 $80\%$ 的数据，$1\le n\le 10^3$；

对于 $100\%$ 的数据，$1\le n\le 10^4$。

## 样例 #1

### 输入

```
5
1 2 5 3 4
```

### 输出

```
1 3 8 6 10
```

## 样例 #2

### 输入

```
5
1 7 5 9 6
```

### 输出

```
1 8 6 17 12
```

# AI分析结果



# 大朋友的数字题解分析

## 算法分类：线性DP

---

## 题解思路与核心难点

### 核心思路
题目要求对每个元素计算以它为结尾的**最长不下降子序列（LNDS）的和**，且当存在多个LNDS时，选择**字典序最小的路径**（即优先取更早出现的子序列）。该问题需通过动态规划解决：

1. **状态定义**  
   - `f[i]`：以第 `i` 个元素结尾的LNDS的最大长度。
   - `sum[i]`：以第 `i` 个元素结尾的LNDS的和。

2. **状态转移**  
   遍历所有 `j < i`，若 `a[j] <= a[i]` 且 `f[j] + 1 > f[i]`，则更新 `f[i]` 和 `sum[i]`。若存在多个 `j` 满足条件，**按顺序选择第一个满足条件的 `j`** 以保证字典序最小。

3. **时间复杂度优化**  
   利用数值范围仅为 `0~9` 的特点，维护每个数值结尾的LNDS信息，将时间复杂度从 `O(n²)` 优化至 `O(n·10)`。

### 解决难点
- **字典序处理**：通过**正序遍历** `j`，优先使用更小的索引，确保路径字典序最小。
- **效率优化**：针对数值范围小的特性，仅维护每个数字结尾的最优状态，避免双重循环。

---

## 题解评分（≥4星）

### 1. 樱式分解（⭐⭐⭐⭐）
- **核心亮点**：代码简洁，直接维护长度与和数组，利用遍历顺序自然处理字典序。
- **代码片段**：
  ```cpp
  for(int j=1; j<i; j++)
    if(a[j]<=a[i] && f[i]<=f[j]) {
      f[i] = f[j] + 1;
      v[i] = v[j] + a[i];
    }
  ```
- **不足**：未明确处理数值范围优化，`O(n²)` 可能无法通过大数据。

### 2. zpf_13516358919（⭐⭐⭐⭐⭐）
- **核心亮点**：利用数值范围 `0~9` 优化至 `O(n·10)`，维护每个数字的LNDS信息。
- **代码片段**：
  ```cpp
  for(int j=ai; j>=0; j--)
    maxx = Max(maxx, f[j]);
  for(int j=ai; j>=0; j--)
    if(f[j]==maxx && Pos > g[j])
      Pos = g[j], pos = j;
  f[ai] = f[pos] + 1;
  sum[i] = sum[g[pos]] + ai;
  ```

### 3. 回头是岸（⭐⭐⭐⭐）
- **核心亮点**：两次遍历明确处理字典序，先找最长长度再找对应路径。
- **代码片段**：
  ```cpp
  int mx = 0;
  for(int j=1; j<i; j++)
    if(a[i]>=a[j]) mx = max(mx, f[j]);
  for(int j=1; j<i; j++)
    if(f[j]==mx && a[i]>=a[j]) {
      f[i] = mx + 1;
      g[i] += g[j];
      break;
    }
  ```

---

## 最优思路提炼
1. **数值范围优化**：对每个数字 `v`，维护以 `v` 结尾的LNDS长度和和，减少遍历次数。
2. **字典序处理**：正序遍历索引，优先选择首个满足条件的元素。
3. **状态转移剪枝**：仅需检查 `≤a[i]` 的数值，避免无效遍历。

---

## 同类型题目推荐
1. **最长递增子序列**：P1091 合唱队形（基础LIS变形）
2. **带权值LIS**：P2782 友好城市（路径选择与权值结合）
3. **多维LIS优化**：P1439 【模板】最长公共子序列（离散化优化）

---

## 可视化设计
### 动画方案
- **动态网格**：以Canvas绘制 `0~9` 的数值行和步骤列，高亮当前处理的数字。
- **状态更新**：显示每个步骤中 `f[v]` 和 `sum[v]` 的变化，用颜色区分新旧状态。
- **复古像素风**：采用16色调色板，状态更新时触发8-bit音效，背景播放芯片音乐循环。

### 交互功能
- **自动演示**：按步长展示每个数字的处理流程。
- **手动控制**：支持暂停、单步执行，查看每个状态的详细数值。
- **音效提示**：状态更新时播放“滴”声，找到更优解时播放上扬音调。

---

## 核心代码实现
```cpp
// 基于数值范围的O(n·10)解法（zpf_13516358919）
int f[10], g[10], sum[10010];
for(int i=1; i<=n; i++) {
    int ai = a[i], maxx = -1, pos = -1, Pos = INF;
    for(int j=ai; j>=0; j--) maxx = max(maxx, f[j]);
    for(int j=ai; j>=0; j--)
        if(f[j]==maxx && g[j] < Pos)
            Pos = g[j], pos = j;
    f[ai] = maxx + 1;
    sum[i] = (pos == -1 ? 0 : sum[g[pos]]) + ai;
    g[ai] = i;
}
```

---

## 个人心得摘录
- **调试教训**：初始未处理数值范围导致 `TLE`，优化后效率显著提升。
- **思维突破**：利用数值范围 `0~9` 将问题从序列索引转为数值维度，极大简化状态转移。

---
处理用时：156.92秒
# 题目信息

# [NOIP 1996 提高组] 砝码称重

## 题目描述

设有 $1\mathrm{g}$、$2\mathrm{g}$、$3\mathrm{g}$、$5\mathrm{g}$、$10\mathrm{g}$、$20\mathrm{g}$ 的砝码各若干枚（其总重 $ \le 1000$），可以表示成多少种重量？

## 说明/提示

**【题目来源】**

NOIP 1996 提高组第四题

## 样例 #1

### 输入

```
1 1 0 0 0 0```

### 输出

```
Total=3```

# AI分析结果



# 算法分类：多重背包

## 题解思路与难点对比
1. **核心思路**  
   所有题解均围绕**多重背包问题**展开，核心目标是用有限数量的不同重量物品（砝码）求能组合出的不同重量总数。关键思路分为两类：
   - **动态规划标记法**：用布尔数组标记可达重量，通过三重循环（砝码类型、数量、重量）递推更新状态。
   - **bitset位运算优化**：利用位运算批量处理可达状态，`S |= S << w[i]` 一次性计算所有可能的新重量。

2. **解决难点**  
   - **状态去重**：通过逆序更新重量数组（从大到小遍历），避免同一砝码被重复累加。
   - **数量处理**：二进制拆分法将`a[i]`个砝码拆分为`log(a[i])`个物品，优化多重背包为01背包。
   - **空间优化**：bitset仅需`O(1)`位操作即可完成批量状态转移，极大减少内存占用。

## 高星题解推荐（≥4星）
1. **pantw (5星)**  
   - **亮点**：使用`bitset`高效处理状态转移，代码仅10行，时间复杂度最低。
   - **代码核心**：`S |= S << w[i]` 实现批量状态更新，`S.count()-1`统计非零位。

2. **Kan_kiz (4星)**  
   - **亮点**：清晰的三重循环动态规划，详细注释与思维引导。
   - **关键点**：逆向遍历重量防止重复，`f[k]`标记可达状态。

3. **ICE_Wol (4星)**  
   - **亮点**：结合《算法竞赛进阶指南》详解`bitset`操作，适合底层原理学习。
   - **技巧**：`s.count()`统计结果，`s.set()`等函数简化代码。

## 最优思路提炼
- **核心技巧**：  
  **bitset位压缩**，将可达状态存储为二进制位，通过位运算批量更新，时空效率极高。
- **状态转移**：  
  对每个砝码类型循环其数量，每次左移当前状态并与原状态取或，覆盖所有可能组合。

```cpp
// pantw的bitset解法
#include <bitset>
#include <cstdio>
int a[10], w[10] = {1, 2, 3, 5, 10, 20};
std::bitset<1010> S;
int main() {
    for(int i = 0; i < 6; i++) scanf("%d", a + i);
    S[0] = 1;
    for(int i = 0; i < 6; i++)
        for(int j = 0; j < a[i]; j++)
            S |= S << w[i]; // 关键：位运算批量更新
    printf("Total=%d\n", S.count() - 1);
    return 0;
}
```

## 可视化算法分析
1. **动态规划过程动画**  
   - **网格展示**：以二维表格横向表示重量(0~1000)，纵向为处理每个砝码的步骤。
   - **颜色标记**：初始时`0`为绿色，每次处理砝码时，将当前可达位（绿色）左移`w[i]`格并标记为黄色。
   - **步进控制**：用户可调节速度观察每个砝码如何扩展可达区域。

2. **复古像素风格演示**  
   - **8-bit界面**：用16色像素块表示重量状态，红色方块表示当前处理位，音效伴随状态更新。
   - **自动演示**：AI自动运行，展示`bitset`从初始位逐步左移扩展的过程，配合芯片音乐增强沉浸感。

## 相似题目推荐
1. [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776) - 多重背包基础  
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 01背包变形  
3. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064) - 依赖背包  

---

**个人心得**：  
调试时极易忽略逆向遍历，正向更新会导致同一砝码被多次累加。首次实现动态规划时，通过打印中间状态发现错误，最终理解逆序的必要性。

---
处理用时：56.47秒
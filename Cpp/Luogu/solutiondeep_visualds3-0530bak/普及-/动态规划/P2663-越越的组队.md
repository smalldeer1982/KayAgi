# 题目信息

# 越越的组队

## 题目描述

班级要组织一场综合能力竞赛，班里共有 $n$ 位学生，将分成两队互相竞争。

老师找到了越越并给了越越一张全班同学综合能力测试的成绩，要求他从全班同学中选出**一半**，并要求这些同学综合能力测试的成绩之和在**不超过班级总分一半**的前提下尽量达到最高。这样分成的两队实力是最平均的。越越堆着满脸的笑容找到了你，你就帮他写一个程序吧。

## 说明/提示

#### 样例 1 解释

班级总分为 $550$，总分的一半是 $275$，选则成绩分别为 $56,77,84,56$ 的同学可以达到总分 $273$，是不超过 $275$ 的最大值。

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 100$，$0 \leq a_i \leq 100$，数据保证 $n$ 均为偶数。

## 样例 #1

### 输入

```
8
77
77
56
77
84
77
56
46```

### 输出

```
273```

# AI分析结果



---

## **唯一算法分类**  
0-1背包（二维约束）

---

## **题解思路、算法要点与解决难点**

### **核心思路**  
本题本质是 **二维约束的0-1背包问题**，需同时满足两个条件：  
1. 选 **恰好一半人数**  
2. 总分 **不超过总成绩一半** 且尽量大  

### **状态设计**  
- `dp[j][k]`：能否选出 `j` 人且总分恰好为 `k`  
- 初始化：`dp[0][0] = true`（选0人得0分可行）  

### **状态转移方程**  
```cpp
dp[j][k] |= dp[j-1][k - a[i]]  // 选第i人时更新状态
```

### **解决难点**  
1. **人数约束**：普通0-1背包无法保证人数恰好为 `n/2`，需升维记录人数。  
2. **循环顺序**：三重循环需倒序，避免重复选择同一学生。  
3. **降维优化**：通过逆序枚举 `j`（人数）和 `k`（分数），将三维DP压缩为二维。

---

## **题解评分 (≥4星)**

### **Kalium (5星)**  
- **亮点**：代码简洁，逆向遍历逻辑清晰，注释明确。  
- **关键代码**：  
  ```cpp
  for (int i=1; i<=n; i++)
    for (int j=i; j>=1; j--)
      for (int k=sum/2; k>=a[i]; k--)
        dp[j][k] |= dp[j-1][k-a[i]];
  ```

### **yhk1001 (5星)**  
- **亮点**：详细分析错因，对比升维与未升维的差异，给出完整AC/WA代码对比。  
- **心得**：强调“人数必须为一半”的条件易被忽略。

### **ExcaIibur (4星)**  
- **亮点**：代码简短，使用布尔数组降低空间复杂度。  
- **优化点**：通过 `min(i, m)` 减少无效计算。

---

## **最优思路提炼**  
1. **二维状态设计**：同时跟踪人数和总分，确保满足两个约束。  
2. **倒序循环**：防止同一学生被多次选中，保证0-1背包特性。  
3. **总分剪枝**：仅遍历到总分一半的分数，减少无效状态。

---

## **同类型题与算法套路**  
- **类似题目**：  
  - 洛谷 P1064（依赖型二维背包）  
  - 洛谷 P1156（时间与高度双约束）  
  - 洛谷 P1757（分组背包与数量限制）  
- **通用套路**：当问题存在多个独立约束时，升维记录每个约束的状态。

---

## **推荐相似题目**  
1. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)  
2. [P1156 垃圾陷阱](https://www.luogu.com.cn/problem/P1156)  
3. [P1757 通天之分组背包](https://www.luogu.com.cn/problem/P1757)  

---

## **个人心得摘录**  
- **Kalium**：在题解结语中感慨OI生涯，引发共鸣（“学OI或许要抵抗许多障碍”）。  
- **天南星魔芋**：尝试用模拟退火解背包问题，体现探索精神（“退火跳出局部最优”）。  

---

## **可视化与算法演示**  

### **动态规划矩阵更新动画**  
![二维背包DP可视化](https://cdn.luogu.com.cn/upload/image_hosting/xyb0y3k9.png)  

#### **动画设计**  
1. **像素风格**：  
   - 使用 8-bit 风格网格，每个单元格表示 `dp[j][k]` 的状态。  
   - **绿色**：可行状态（`dp[j][k] = true`）  
   - **红色**：不可行状态（`dp[j][k] = false`）  

2. **更新高亮**：  
   - 处理学生 `i` 时，高亮其对应的分数 `a[i]`。  
   - 转移时，从 `dp[j-1][k-a[i]]` 到 `dp[j][k]` 的路径用黄色箭头标注。  

3. **音效触发**：  
   - **转移成功**：播放短促“哔”声。  
   - **找到最优解**：播放胜利音效。  

#### **交互功能**  
- **步进控制**：允许暂停/继续，调整循环速度。  
- **参数调节**：动态修改 `n` 和 `a[i]`，观察DP矩阵变化。  

---

## **代码实现（核心逻辑）**  
```cpp
#include <iostream>
using namespace std;

bool dp[105][10005]; // dp[j][k]: 选j人得k分是否可行
int a[105];

int main() {
    int n, sum = 0;
    cin >> n;
    for (int i=1; i<=n; i++) {
        cin >> a[i];
        sum += a[i];
    }
    sum /= 2;
    int m = n / 2;
    
    dp[0][0] = true;
    for (int i=1; i<=n; i++) {
        for (int j=i; j>=1; j--) {
            for (int k=sum; k>=a[i]; k--) {
                if (dp[j-1][k - a[i]]) 
                    dp[j][k] = true;
            }
        }
    }
    
    for (int k=sum; k>=0; k--) {
        if (dp[m][k]) {
            cout << k;
            return 0;
        }
    }
    return 0;
}
```

---
处理用时：66.22秒
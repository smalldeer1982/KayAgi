# 题目信息

# 又上锁妖塔

## 题目描述

小 A 在玩《剑仙》，他遇到了一个锁妖塔，想从外面爬上去。

锁妖塔共有 $n$ 层，第 $i$ 层的高度为 $h_i$。小 A 会用仙术，每用一次可以让他向上跳一层或两层，但是每次跳跃后小 A 都将用完力气，必须爬过至少一层才能再次跳跃（你可以认为小 A 需要跳两次一层才休息）。

现在小 A 想让你帮他算出爬上塔顶的最短时间。

## 样例 #1

### 输入

```
5
3 5 1 8 4```

### 输出

```
1```

# AI分析结果



# 算法分类选择  
**线性DP**  

# 题解思路与解决难点  

## 核心思路  
所有题解均采用动态规划思想，核心差异在于状态定义方式：  
1. **一维状态**（Clu3ter、Godのfather等）：  
   - 定义 `f[i]` 为到达第i层之上的最短时间  
   - 状态转移方程：`f[i] = min(f[i-1], f[i-2], f[i-3]) + a[i]`  
   - **关键洞察**：跳跃后必须爬一层，故跳跃动作被隐含在连续三次状态转移中  

2. **二维状态**（Last_Reincarnation、东京食种等）：  
   - 定义 `f[i][0/1]` 表示到达第i层时是否刚使用过仙术  
   - 状态转移：  
     - `f[i][0] = min(f[i-1][1], f[i-2][1])`（飞上来）  
     - `f[i][1] = min(f[i-1][0], f[i-1][1]) + a[i]`（爬上来）  

## 解决难点  
1. **跳跃后必须爬层的约束**：  
   - 一维解法通过转移时**强制取前三层最小值**隐含该约束  
   - 二维解法通过**状态隔离**显式处理约束，更易理解但代码稍复杂  

2. **边界处理**：  
   - `n+1`层作为虚拟终点（Clu3ter解法）巧妙处理跳跃出塔顶的情况  
   - 初始化时设置极大值避免非法转移（Godのfather解法）  

# 题解评分（≥4星）  

| 题解作者       | 评分 | 亮点                                 |  
|----------------|------|--------------------------------------|  
| **Clu3ter**    | ⭐⭐⭐⭐⭐ | 状态转移方程简洁优雅，代码可读性极佳 |  
| **Godのfather** | ⭐⭐⭐⭐  | 边界处理清晰，适合教学场景           |  
| **Last_Reincarnation** | ⭐⭐⭐⭐ | 二维状态设计直观，适合理解约束条件 |  

# 最优思路提炼  
**一维状态转移方程**：  
```cpp
f[i] = min(f[i-1], f[i-2], f[i-3]) + a[i]
```  
**实现关键**：  
1. 将塔顶扩展为第`n+1`层（高度为0）  
2. 初始化前三层为 `f[0]=0`, `f[1]=a[1]`, `f[2]=a[2]`  
3. 循环时从第3层开始递推  

# 相似题目推荐  
1. **P1091 合唱队形**（线性DP+状态分解）  
2. **P1216 数字三角形**（经典DP路径问题）  
3. **P1434 滑雪**（记忆化搜索与DP结合）  

# 可视化方案设计  

## 动态规划矩阵演示  
![DP Matrix Demo](https://via.placeholder.com/600x200/FF6B6B/FFFFFF?text=Step+3:+f[3]=min(5,3,0)+1=4)  
- **高亮变化**：当前更新的`f[i]`单元格以红色闪烁  
- **箭头指引**：从`i-1`,`i-2`,`i-3`位置绘制箭头到当前单元格  
- **数值标注**：每个单元格显示`min(前三个值)+a[i]`的计算过程  

## 复古游戏化实现（伪代码）  
```javascript
// Canvas初始化
const grid = new PixelGrid(800, 600, 16); // 16x16像素格子
const dpCells = [];
for(let i=0; i<=n+1; i++) {
  const cell = grid.createCell(i*50, 100, `f[${i}]`);
  dpCells.push(cell);
}

// 动画逻辑
function updateDP(i) {
  playSound('blip'); // 8-bit音效
  dpCells[i].highlight(); 
  drawArrowFrom(i-1, i-2, i-3); // 绘制转移箭头
  dpCells[i].setValue(Math.min(...prevValues) + a[i]);
}
```  

# 核心代码实现  
**Clu3ter解法**  
```cpp
#include<bits/stdc++.h>
using namespace std;

int n, a[1000005], f[1000005];

int main() {
    cin >> n;
    for(int i=1; i<=n; i++) {
        cin >> a[i];
        f[i] = INT_MAX;
    }
    
    f[0] = 0;
    for(int i=1; i<=n+1; i++) {
        if(i >= 1) f[i] = min(f[i], f[i-1]);
        if(i >= 2) f[i] = min(f[i], f[i-2]); 
        if(i >= 3) f[i] = min(f[i], f[i-3]);
        f[i] += (i <= n) ? a[i] : 0;
    }
    cout << f[n+1];
}
```  

# 总结提升  
该题展现了**状态压缩**在DP中的典型应用。当后序状态仅与有限前序状态相关时，可通过设计精妙的状态转移方程（如本题的跳3层规则）大幅降低空间复杂度。二维状态解法虽更直观，但一维解法通过问题重定义实现了更高的时空效率，体现了动态规划设计中**状态抽象**的重要性。

---
处理用时：69.15秒
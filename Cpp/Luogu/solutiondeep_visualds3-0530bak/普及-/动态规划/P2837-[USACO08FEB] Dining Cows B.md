# 题目信息

# [USACO08FEB] Dining Cows B

## 题目描述

为了避免餐厅过分拥挤，FJ 要求奶牛们分 $2$ 批就餐。每天晚饭前，奶牛们都会在餐厅前排队入内，按 FJ 的设想，所有第 $2$ 批就餐的奶牛排在队尾，队伍的前半部分则由设定为第 $1$ 批就餐的奶牛占据。

由于奶牛们不理解 FJ 的安排，晚饭前的排队成了一个大麻烦。 第 $i$ 头奶牛有一张标明她用餐批次 $D_i$ 的卡片。虽然所有 $N$ 头奶牛排成了很整齐的队伍，但谁都看得出来，卡片上的号码是完全杂乱无章的。 在若干次混乱的重新排队后，FJ 找到了一种简单些的方法：奶牛们不动，他沿着队伍从头到尾走一遍，把那些他认为排错队的奶牛卡片上的编号改掉，最终得到一个他想要的每个组中的奶牛都站在一起的队列，例如 $112222$ 或 $111122$。有的时候，FJ 会把整个队列弄得只有 $1$ 组奶牛（比方说，$1111$ 或 $222$）。 

你也晓得，FJ 是个很懒的人。他想知道，如果他想达到目的，那么他最少得改多少头奶牛卡片上的编号。所有奶牛在 FJ 改卡片编号的时候，都不会挪位置。

## 说明/提示

$1 \le N \le 3 \times 10 ^ 4$

## 样例 #1

### 输入

```
7
2
1
1
1
2
2
1```

### 输出

```
2```

## 样例 #2

### 输入

```
5
2
2
1
2
2```

### 输出

```
1```

# AI分析结果



### 唯一算法分类
**线性DP**

---

### 题解思路与核心难点分析
**核心逻辑**：将序列分割为前半段全1、后半段全2的形式，统计分割点前后需要修改的次数，取最小值。

**动态规划思路**（如题解1）：
- **状态设计**：`dp[i][0]`表示前i头牛以1结尾的最小修改次数，`dp[i][1]`表示以2结尾的最小修改次数。
- **转移方程**：根据当前牛的值，若为1则继承前驱状态，若为2则需考虑是否切换分组。
- **空间优化**：滚动数组可将空间复杂度优化至O(1)。

**前缀和思路**（如题解2、3）：
- **核心思想**：预处理每个位置左侧的2的数量（需改为1）和右侧的1的数量（需改为2），枚举所有分割点计算总修改次数。
- **优化点**：两次遍历统计前后缀和，时间复杂度O(n)，空间O(n)但可优化为O(1)。

**最长不下降子序列思路**（如题解7、8）：
- **转化问题**：合法序列为形如`111...222`的不下降序列，求最长不下降子序列长度，总长度减去该值即为答案。
- **优化手段**：利用二分维护单调序列，复杂度O(n logn)。

**难点对比**：
- **DP方程推导**：需明确状态定义与转移逻辑，避免遗漏边界条件。
- **分界点处理**：前缀和法中需注意分割点在首尾的特殊情况。
- **代码简洁性**：前缀和法代码更简洁，DP法需处理状态转移细节。

---

### 题解评分（≥4星）
1. **AK_Zero（前缀和法）** ⭐⭐⭐⭐⭐  
   - **亮点**：O(n)时间，代码极简，一次遍历维护修改次数。
   - **代码示例**：
     ```cpp
     for(int i=1; i<=n; i++) {
         if(a[i]==2) gb++; else gb--;
         mi = min(mi, gb);
     }
     ```

2. **AnChun999（前缀和优化）** ⭐⭐⭐⭐  
   - **亮点**：预处理前后缀数组，逻辑清晰，易扩展。

3. **S_C_Yesterday（滚动数组DP）** ⭐⭐⭐⭐  
   - **亮点**：空间优化至O(1)，代码精简，状态转移直观。

---

### 最优思路提炼
**前缀和法关键步骤**：
1. 初始假设全部改为2，统计总修改次数。
2. 遍历数组，动态维护当前分割点前的修改次数：
   - 遇到2：需改为1，次数+1。
   - 遇到1：无需修改，次数-1。
3. 实时更新最小修改次数。

**代码片段**：
```cpp
int min_changes = count_ones; // 初始全改2的代价
for (int i = 0; i < n; ++i) {
    if (cows[i] == 1) --count_ones;
    else ++count_ones;
    min_changes = min(min_changes, count_ones);
}
```

---

### 同类型题与算法套路
- **分割点枚举**：类似涂国旗问题（如LeetCode 1177、Luogu P3396）。
- **前缀和优化**：统计区间特征时常用，如子数组和、频率统计等。
- **线性DP设计**：适用于序列分组问题，如股票买卖、字符串分割。

---

### 推荐相似题目
1. **P1091 合唱队形**（线性DP与前后缀结合）
2. **P2782 友好城市**（最长不下降子序列变形）
3. **P3146 [USACO16OPEN]248**（区间DP与合并问题）

---

### 可视化与算法演示设计
**动态规划动画方案**：
1. **网格绘制**：以行表示奶牛序号，列表示状态（0/1），每个格子显示`dp[i][j]`值。
2. **颜色标记**：当前处理的奶牛用红色高亮，状态转移路径用箭头连接。
3. **步进控制**：支持单步执行，观察状态如何从`i-1`转移到`i`。
4. **音效反馈**：状态更新时播放点击声，找到更优解时触发音效。

**复古像素风格**：
- **8位色调色板**：绿色表示1，蓝色表示2，修改操作用闪烁特效。
- **Canvas动画**：奶牛队列以像素方块展示，分割点用垂直虚线动态移动。

---

### 代码实现（前缀和法）
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int n, x, cnt = 0, ans;
    cin >> n;
    for (int i = 0; i < n; ++i) {
        cin >> x;
        cnt += (x == 1); // 初始全改2的代价是1的数量
    }
    ans = cnt;
    for (int i = 0; i < n; ++i) {
        cnt += (x == 2 ? 1 : -1); // 动态维护分割点
        ans = min(ans, cnt);
    }
    cout << ans << endl;
    return 0;
}
```

---
处理用时：62.56秒
# 题目信息

# [NWRRC 2016] Folding

## 题目描述

### 题目大意：

求一个 $W\times H $ 的矩形通过折叠变为一个 $w\times h$ 的矩形的最少折叠次数，其中每次折叠的折痕必须平行于矩形的一边。

------------

## 样例 #1

### 输入

```
2 7
2 2
```

### 输出

```
2
```

## 样例 #2

### 输入

```
10 6
4 8
```

### 输出

```
2
```

## 样例 #3

### 输入

```
5 5
1 6
```

### 输出

```
-1
```

# AI分析结果



## 算法分类  
模拟  

---

## 题解分析与结论  

### 核心思路对比  
1. **正向折叠（缩小原始尺寸）**  
   - 不断将原始尺寸 W/H 除以 2，直到 ≤ 目标尺寸  
   - 需处理浮点数精度问题（如无名之雾的题解）  
   - 需考虑 W/H 与 w/h 的排列组合（可能交换长宽）  

2. **逆向展开（扩大目标尺寸）**  
   - 将目标尺寸 w/h 不断乘 2，直到 ≥ 原始尺寸  
   - 完全整数操作，避免精度问题（如 Linge_Zzzz、Struggle_ong 的题解）  
   - 每次操作保持长边在前，统一比较逻辑  

### 解决难点  
- **排列组合处理**：必须保证长边与长边比较，短边与短边比较  
- **终止条件**：必须在两个维度同时满足尺寸要求  
- **最优路径**：需比较两种可能的折叠方向（原始长边对目标长边，或原始长边对目标短边）  

---

## 高星题解推荐 (≥4星)  

### 1. Linge_Zzzz（4.5★）  
**亮点**：逆向展开思路清晰，代码简洁，保持长宽有序  
**核心代码**：  
```cpp
while(H>h||W>w) {
    if(H>h) h*=2;
    else w*=2;
    if(h>w) swap(h,w); // 维持长边在前
    ans++;
}
```

### 2. Struggle_ong（4.2★）  
**亮点**：函数封装解决不同方向，代码复用性高  
**核心逻辑**：  
```cpp
int solve(int y,int x) { // 计算从x展开到y的次数
    if(x == y) return 0;
    int cnt = 0;
    while(x < y) { x *= 2; ++cnt; }
    return cnt;
}
```

### 3. 无名之雾（4.0★）  
**亮点**：处理两种折叠方向的对比  
**注意点**：必须使用浮点数运算  
**核心逻辑**：  
```cpp
wh(a,w,cnt1); // 持续除以2直到≤w
wh(b,h,cnt2);
swap(w,h); // 尝试另一种方向
```

---

## 最优思路与技巧  
**逆向展开法**：  
1. 将目标尺寸视为初始状态，逆向模拟展开过程  
2. 每次选择较小的边进行乘 2 操作  
3. 始终保持长边在前以统一比较逻辑  
4. 统计展开次数即为实际折叠次数  

**代码优化技巧**：  
```cpp
if(W<H) swap(W,H); // 预处理保证长边在前
if(w<h) swap(w,h);
while(current < target) {
    expand_smaller_side();
    maintain_order();
}
```

---

## 相似题目推荐  
1. **P1036 选数**（逆向枚举组合）  
2. **P1226 快速幂**（分治思想模拟运算）  
3. **P1443 马的遍历**（BFS模拟最短路径）  

---

## 可视化设计  
**像素化动画方案**：  
1. **界面布局**：  
   - 左侧：8位风格的大矩形（红色像素块）  
   - 右侧：展开中的小矩形（绿色像素块）  
   - 底部：操作计数器与速度控制条  

2. **关键帧演示**：  
   - **高亮当前操作边**：被乘2的边闪烁黄色边框  
   - **尺寸变化动画**：绿色矩形边缘扩展时播放像素拉伸特效  
   - **方向交换提示**：当交换长宽时，矩形旋转90度动画  

3. **音效设计**：  
   - 每次乘2操作：8-bit "blip" 音效（频率随操作次数递增）  
   - 达成条件：播放经典FC过关音效  
   - 无解情况：播放低沉错误音效  

**交互功能**：  
```javascript
// 伪代码示例
function autoPlay() {
    while(!checkSuccess()) {
        let smaller = current.h < target.H ? 'h' : 'w';
        expand(smaller);
        if(current.w < current.h) swapWH();
        updateCanvas(); // 更新像素块位置
        playSound('blip');
        await sleep(speed);
    }
}
```

---

## 核心代码实现  
**逆向展开法完整代码**：  
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int W, H, w, h, ans = 0;
    cin >> W >> H >> w >> h;
    
    // 统一长边在前
    if (W < H) swap(W, H);
    if (w < h) swap(w, h);
    
    if (W < w || H < h) {
        cout << -1;
        return 0;
    }
    
    while (w < W || h < H) {
        if (h < H) h *= 2;
        else w *= 2;
        if (h > w) swap(h, w); // 维持长边顺序
        ans++;
    }
    
    cout << ans;
    return 0;
}
```

---
处理用时：72.33秒
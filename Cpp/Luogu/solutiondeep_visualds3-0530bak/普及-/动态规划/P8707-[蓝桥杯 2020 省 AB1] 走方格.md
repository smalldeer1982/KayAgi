# 题目信息

# [蓝桥杯 2020 省 AB1] 走方格

## 题目描述

在平面上有一些二维的点阵。

这些点的编号就像二维数组的编号一样，从上到下依次为第 $1$ 至第 $n$ 行，从左到右依次为第 $1$ 至第 $m$ 列，每一个点可以用行号和列号来表示。

现在有个人站在第 $1$ 行第 $1$ 列，要走到第 $n$ 行第 $m$ 列。只能向右或者向下走。

注意，如果行号和列数都是偶数，不能走入这一格中。

问有多少种方案。

## 说明/提示

$1\le n,m\le30$。

蓝桥杯 2020 第一轮省赛 A 组 G 题（B 组 H 题）。

## 样例 #1

### 输入

```
3 4```

### 输出

```
2```

# AI分析结果



---

**算法分类**  
线性DP  

---

### **题解思路、算法要点与解决难点**  

#### **动态规划核心思路**  
- **状态定义**：`dp[i][j]` 表示到达点 `(i,j)` 的路径总数。  
- **状态转移**：  
  - 若 `i` 和 `j` 均为偶数，`dp[i][j] = 0`（无法进入）。  
  - 否则，`dp[i][j] = dp[i-1][j] + dp[i][j-1]`（从上方或左方转移而来）。  
- **初始条件**：`dp[1][1] = 1`（起点）。  
- **边界处理**：第一行和第一列需特殊处理（若遇到双偶格子，后续格子不可达）。  

#### **关键难点**  
1. **双偶格子的阻断作用**：需在遍历时直接跳过或置零。  
2. **初始条件的统一处理**：部分题解通过巧妙初始化（如 `dp[0][1] = 1`）避免单独处理第一行和第一列。  
3. **状态转移的递推顺序**：需按行或列顺序填充，确保依赖状态已计算。  

---

### **题解评分 (≥4星)**  

1. **Ggsddu_zzy (5星)**  
   - **亮点**：代码简洁，初始化清晰，直接遍历填充 DP 矩阵。  
   - **代码片段**：  
     ```cpp  
     for(ri i=2;i<=n;i++)  
         for(ri j=2;j<=m;j++)  
             if(i%2||j%2)  
                 f[i][j] = f[i-1][j] + f[i][j-1];  
     ```  

2. **WA_sir (4星)**  
   - **亮点**：通过 `_[0][1] = 1` 统一初始化，简化循环逻辑。  
   - **代码片段**：  
     ```cpp  
     _[0][1] = 1;  
     for(int i=1; i<=n; i++)  
         for(int j=1; j<=m; j++)  
             if(i%2 || j%2)  
                 _[i][j] = _[i-1][j] + _[i][j-1];  
     ```  

3. **da_ke (4星)**  
   - **亮点**：记忆化搜索实现，避免递推顺序问题，适合理解递归思维。  
   - **代码片段**：  
     ```cpp  
     if(mem[x][y] != -1) return mem[x][y];  
     int ans = dfs(x+1,y) + dfs(x,y+1);  
     return mem[x][y] = ans;  
     ```  

---

### **最优思路与技巧提炼**  

1. **统一初始化技巧**：通过设置 `dp[0][1] = 1` 或 `dp[1][0] = 1`，避免单独处理第一行和第一列的边界条件。  
2. **双偶格子直接跳过**：在循环中提前判断并置零，减少无效计算。  
3. **记忆化搜索的剪枝**：通过缓存已计算状态，将指数级复杂度优化至多项式级别。  

---

### **同类型题与类似算法套路**  

- **通用套路**：网格路径问题通常使用二维 DP，状态转移依赖左/上邻居。  
- **相似题目**：  
  - **P1002 过河卒**：动态规划 + 障碍点处理。  
  - **P1464 Function**：记忆化搜索模板题。  
  - **P1048 采药**：0-1背包问题的变种。  

---

### **推荐洛谷题目**  
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)  
2. [P1057 传球游戏](https://www.luogu.com.cn/problem/P1057)  
3. [P1216 数字三角形](https://www.luogu.com.cn/problem/P1216)  

---

### **个人心得摘录**  

- **da_ke**：记忆化搜索的关键是“大胆搜索，小心边界”，需优先处理越界和终止条件。  
- **WA_sir**：通过初始化技巧简化代码，避免冗余逻辑。  

---

### **可视化与算法演示**  

#### **动态规划动画设计**  
1. **网格绘制**：  
   - 用 Canvas 绘制 `n×m` 网格，双偶格子标记为红色（障碍）。  
   - 每个格子实时显示 `dp[i][j]` 的值。  
2. **状态更新高亮**：  
   - 当前处理格子高亮为黄色，左/上邻居高亮为蓝色。  
   - 更新时显示箭头（← 和 ↑）表示转移方向。  
3. **步进控制**：  
   - 支持暂停/继续、单步执行、调整速度。  
   - 自动模式下按行优先顺序遍历格子。  

#### **复古游戏化效果**  
- **像素风格**：使用 8-bit 调色板（如红色障碍、绿色路径）。  
- **音效设计**：  
  - 状态更新时播放“滴”声，找到路径时播放胜利音效。  
  - 背景音乐为循环 8-bit 风格旋律。  
- **积分系统**：每正确填充一个格子得 10 分，双偶格子跳过不扣分。  

---

### **核心代码实现**  

```cpp  
// 动态规划核心实现（WA_sir 版本）  
#include<bits/stdc++.h>  
using namespace std;  
int n, m, dp[33][33];  
int main() {  
    scanf("%d%d", &n, &m);  
    dp[0][1] = 1; // 初始化技巧  
    for(int i=1; i<=n; i++)  
        for(int j=1; j<=m; j++)  
            if(i%2 || j%2)  
                dp[i][j] = dp[i-1][j] + dp[i][j-1];  
    printf("%d", dp[n][m]);  
    return 0;  
}  
```  

---

**总结**：本题通过线性 DP 或记忆化搜索解决，核心在于状态转移和双偶格子的处理。动态规划的初始化技巧和状态转移顺序是关键优化点。

---
处理用时：71.22秒
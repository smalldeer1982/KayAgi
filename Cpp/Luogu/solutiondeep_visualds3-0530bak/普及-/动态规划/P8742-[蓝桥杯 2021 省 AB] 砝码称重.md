# 题目信息

# [蓝桥杯 2021 省 AB] 砝码称重

## 题目描述

你有一架天平和 $N$ 个砝码, 这 $N$ 个砝码重量依次是 $W_{1}, W_{2}, \cdots, W_{N}$ 。 请你计算一共可以称出多少种不同的重量?

注意砝码可以放在天平两边。


## 说明/提示

**【样例说明】**

能称出的 10 种重量是: $1 、 2 、 3 、 4 、 5 、 6 、 7 、 9 、 10 、 11$ 。

$$
\begin{aligned}
&1=1 \\
&2=6-4(\text { 天平一边放 } 6, \text { 另一边放 4) } \\
&3=4-1 \\
&4=4 \\
&5=6-1 \\
&6=6 \\
&7=1+6 \\
&9=4+6-1 \\
&10=4+6 \\
&11=1+4+6
\end{aligned}
$$

**【评测用例规模与约定】**

对于 $50 \%$ 的评测用例, $1 \leq N \leq 15$ 。

对于所有评测用例, $1 \leq N \leq 100, N$ 个砝码总重不超过 $10^5$。 

蓝桥杯 2021 第一轮省赛 A 组 F 题（B 组 G 题）。

## 样例 #1

### 输入

```
3
1 4 6```

### 输出

```
10```

# AI分析结果



---

**算法分类**  
0-1背包

---

### **题解思路与核心难点**  
**核心思路**：将砝码视为可正负选择的物品，转化为带权绝对值判断的 0-1 背包问题。动态规划状态表示可称出的重量集合，通过三种操作（加砝码、减砝码、不选）更新状态。  

**关键难点**：  
1. **负重量处理**：需通过绝对值或偏移值将负重量转换为非负数组下标。  
2. **转移顺序**：必须逆序遍历重量以避免重复叠加同一砝码的影响。  
3. **空间优化**：通过滚动数组或 bitset 压缩状态，处理总重量 1e5 级的数据规模。  

**状态转移方程**：  
- 一维数组版：`dp[j] |= dp[abs(j - w)] | dp[j + w]`  
- bitset 版：`d |= (d << w) | (d >> w)`  

---

### **题解评分**  
1. **loser_seele（5 星）**  
   - **亮点**：使用 bitset 优化，代码极简（仅 10 行），时空效率双优。  
   - **代码**：  
     ```cpp
     bitset<100010> d;
     d.set(0);
     for (int w : a) d |= d << w | d >> w;
     ```  

2. **RP_INT_MAX（4.5 星）**  
   - **亮点**：偏移值处理负下标，滚动数组优化空间，逻辑清晰。  
   - **核心代码**：  
     ```cpp
     f[i&1][j+N] = f[i-1][j-w +N] || f[i-1][j+w +N];
     ```  

3. **FstAutoMaton（4 星）**  
   - **亮点**：直接处理绝对值，代码简洁易懂，适合教学演示。  

---

### **最优技巧提炼**  
1. **bitset 位运算优化**：将加减操作转化为左移/右移，时间复杂度降至 O(n·sum/w)。  
2. **动态规划状态压缩**：用一维数组代替二维数组，逆序遍历避免覆盖问题。  
3. **绝对值抵消负值**：通过 `abs(j - w)` 统一处理砝码放置左/右的对称性。  

---

### **同类题型与算法套路**  
1. **P2347 砝码称重**（多重背包可行性）  
2. **P2563 质数和分解**（完全背包计数）  
3. **P1273 有线电视网**（树形 DP 与背包结合）  

---

### **推荐相似题目**  
1. **P2347 [NOIP1998] 砝码称重**（多重背包可行性）  
2. **P1441 砝码称重（加强版）**（组合背包与状态压缩）  
3. **P4130 完全背包计数问题**（完全背包变种）  

---

### **个人心得摘录**  
- **调试教训**：正向遍历会导致同一砝码多次叠加，必须逆序更新状态。  
- **顿悟时刻**：发现砝码放置两侧的对称性后，用绝对值简化状态转移。  

---

### **可视化与算法演示**  
**动画设计**：  
1. **8-bit 风格网格**：  
   - 每个格子代表一个重量，初始仅 0 号格点亮（绿色）。  
   - 每次处理砝码时，新增点亮格子（黄色闪烁）并播放 "coin" 音效。  

2. **动态更新流程**：  
   - **步骤 1**：显示当前砝码重量 `w`。  
   - **步骤 2**：高亮所有已点亮格子，向左移动 `w`（加砝码）和向右移动 `w`（减砝码）。  
   - **步骤 3**：合并新旧状态，新点亮格子显示爆炸特效。  

**交互功能**：  
- **AI 自动模式**：按预设速度逐步执行，背景播放《超级玛丽》地下关 BGM。  
- **手动步进**：点击砝码图标触发单步转移，音效为 8-bit 电子音。  

**代码片段（JS 伪代码）**：  
```javascript
const canvas = initCanvas(); // 初始化像素网格
let dp = new BitSet(1);      // 初始状态：重量 0
dp.set(0, true);

砝码数组.forEach(w => {
  const prev = dp.clone();
  dp.or(prev.shiftLeft(w)).or(prev.shiftRight(w));
  绘制格子变化(dp.diff(prev), "yellow-flash");
  播放音效("powerup");
});
```  

--- 

**结论**：通过动态规划记录可称重量集合，结合位运算优化，可在 O(n·sum) 时间内高效求解。复古像素动画与音效增强理解，适合教学演示。

---
处理用时：61.09秒
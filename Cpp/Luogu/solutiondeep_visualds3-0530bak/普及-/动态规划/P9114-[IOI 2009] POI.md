# 题目信息

# [IOI 2009] POI

## 题目背景

IOI2009 D1T3

## 题目描述

普罗夫迪夫信息学奥林匹克竞赛（Plovdiv Olympiad in Informatics, POI）正在举行。有 $N$ 个选手和 $T$ 道题目。每道题目只有一组测试数据，因此对于每个选手和每道题目，要么这个选手解决了这道题目，要么没有解决。没有部分分。

比赛结束后，每道题目的分数为没有解决这道题目的选手数量。每个选手的得分为他解决的每道题目的得分之和。

Philip 参加了这场比赛，但他被复杂的计分规则搞糊涂了。他看着比赛结果，无法计算出他的最终排名。写一个程序帮助 Philip 计算他的分数和排名。

在比赛开始之前，每个选手从 $1$ 到 $N$ 编号。Philip 的编号为 $P$。最终的排行榜将所有选手按分数降序列出。为避免平局，在得分相同的选手中，按解决题目数量降序排序（解决题目数量多的选手排在解决数量题目少的选手之前）。如果仍存在平局，则按编号升序排序。

**任务**：编写一个程序，给定每个选手的解题情况，计算出 Philip 的分数和他在最终排行榜上的排名。

## 说明/提示

### 样例解释

第一道题目只有一个选手没有解决，所以它值 $1$ 分。第二道题目有两个选手没有解决，所以它值 $2$ 分。第三道题目有四个选手没有解决，所以它值 $4$ 分。因此编号为 $1$ 的选手得 $4$ 分，编号为 $2, 4, 5$ 的选手得 $3$ 分，编号为 $3$ 的选手得 $1$ 分。根据平局规则，编号为 $2$ 的选手（Philip）排在编号为 $4, 5$ 的选手之前，因此 Philip 的最终排名为 $2$，仅在编号为 $1$ 的选手下面。

### 数据范围与约定

- 对于 $35\%$ 的数据，没有选手得分和 Philip 相同。
- 对于 $100\%$ 的数据，$1\leq N, T\leq 2000$，$1\leq P\leq N$。

## 样例 #1

### 输入

```
5 3 2
0 0 1
1 1 0
1 0 0
1 1 0
1 1 0
```

### 输出

```
3 2
```

# AI分析结果



## 算法分类
模拟

## 题解思路与核心难点
### 核心算法流程
1. **计算题目得分**：遍历所有选手的解题情况，统计每道题未通过的人数作为该题分数。
2. **计算选手数据**：对每个选手，累加其正确题目的分数得到总分，并统计正确题数。
3. **多关键字排序**：按题目要求的排序规则（得分→题数→编号）对所有选手排序。
4. **定位目标排名**：在排序后的列表中查找 Philip 的位置。

### 解决难点
- **多条件排序实现**：需正确处理三个条件的优先级顺序，常见解法是重载结构体比较运算符或自定义排序函数。
- **数据存储优化**：使用结构体集中存储选手信息（编号、得分、题数），避免分散的数组管理。

### 可视化设计
1. **动画流程**：
   - **题目计分阶段**：用红色高亮当前统计的题目，动态显示未通过人数。
   - **选手计分阶段**：绿色标记当前选手，显示其正确题目带来的分数累加。
   - **排序阶段**：可视化冒泡排序过程，用不同颜色区分比较中的两个元素。
   - **定位阶段**：黄色闪烁显示 Philip 的最终位置。

2. **复古像素风格**：
   - **颜色方案**：使用 8-bit 风格的 16 色调色板（如：NES 经典配色）。
   - **音效设计**：
     - 统计题目时播放短促的「滴」声。
     - 正确累加分数时播放「金币收集」音效。
     - 排序比较时触发电子音阶声。

## 题解评分（≥4星）
1. **tianbiandeshenghuo（★★★★☆）**  
   结构体封装清晰，运算符重载实现简洁，代码可读性强。
2. **Lovely_Elaina（★★★★☆）**  
   二维数组存储解题情况，注释明确，变量命名规范。
3. **Convergent_Series（★★★★☆）**  
   包含完整结构体定义，分阶段代码注释详细，适合教学。

## 最优代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Player {
    int id, score = 0, solved = 0;
    bool operator<(const Player &p) const {
        return score != p.score ? score > p.score : 
               solved != p.solved ? solved > p.solved : 
               id < p.id;
    }
};

int main() {
    int n, t, p; 
    cin >> n >> t >> p;
    vector<int> problem_score(t+1, 0);
    vector<Player> players(n+1);

    // 统计题目得分
    for (int i = 1; i <= n; ++i) {
        players[i].id = i;
        for (int j = 1; j <= t; ++j) {
            bool solved; cin >> solved;
            problem_score[j] += !solved;
            players[i].solved += solved;
        }
    }

    // 计算选手得分
    for (int i = 1; i <= n; ++i) 
        for (int j = 1; j <= t; ++j) 
            if (players[i].solved >= j && ... /* 实际需重新存储解题情况 */)
                players[i].score += problem_score[j];

    sort(players.begin(), players.end());
    
    // 查找输出结果
    for (int i = 0; i < n; ++i) 
        if (players[i].id == p) 
            cout << players[i].score << " " << i+1;
    return 0;
}
```

## 相似题目推荐
1. P1068 [NOIP2009 普及组] 分数线划定（多关键字排序）
2. P1781 宇宙总统（大数比较+结构体排序）
3. P1093 [NOIP2007 普及组] 奖学金（三条件排序）

## 可视化关键代码（JS）
```javascript
// 伪代码：排序动画核心逻辑
function visualizeSort(players) {
    let i = 0, j = 0;
    const timer = setInterval(() => {
        if (compare(players[j], players[j+1])) {
            [players[j], players[j+1]] = [players[j+1], players[j]]; 
            drawPlayers(players, j, j+1); // 高亮交换元素
            playSwapSound();
        }
        if (++j >= players.length-i) { j=0; i++; }
        if (i >= players.length) clearInterval(timer);
    }, 500);
}
```

## 知识拓展
当数据规模升级到 N=1e5 时，O(n log n) 排序将成瓶颈。此时可改用计数排序思想：  
1. 按分数建立桶，桶内按题数和编号排序  
2. 时间复杂度优化为 O(n + max_score)

---
处理用时：105.65秒
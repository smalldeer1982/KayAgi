# 题目信息

# [常州市赛 2020] 重点单词

## 题目背景

搬运自 <http://czoj.com.cn/p/448>。数据为民间数据。

## 题目描述

回家后，小 $\text{X}$ 望着自己打瞌睡时写的英语笔记陷入了迷茫。由于太困了，他会时不时地把一个字母多写几次：比如可能把 $\texttt{she}$ 写成 $\texttt{shhe}$，也可能写成 $\texttt{ssshee}$。  
但他依稀记得这堂课只讲了一个重点单词。为了找到这个单词，他想先把每个单词中连续重复的字母压缩起来：把 $\texttt{coool}$ 压缩为 $\texttt{col}$，把 $\texttt{aabbaa}$ 压缩为 $\texttt{aba}$。接下来找到压缩后出现次数最多的单词，这样就能找到重点单词了。  
由于工作量太大，小 $\text{X}$ 希望你帮助他找到重点单词。他向你保证压缩后的单词出现次数最多的一定唯一。

## 说明/提示

### 样例解释
- $\texttt{qaaqqq}$ 压缩成 $\texttt{qaq}$；  
- $\texttt{qwwwwq}$ 压缩成 $\texttt{qwq}$；  
- $\texttt{qqqqaq}$ 压缩成 $\texttt{qaq}$；  

$\texttt{qaq}$ 出现了两次，$\texttt{qwq}$ 出现了一次，所以 $\texttt{qaq}$ 出现次数最多。  
### 数据范围
本题共有 $10$ 个测试点。  
对于全部数据：$1\le n\le 10^4$，$1\le $ 单词长度 $\le50$。 
|测试点编号|$n$|单词长度|
|:-:|:-:|:-:|
|$1$|$=1$|$=1$|
|$2\sim3$|$\le 10^4$|$=1$|
|$4\sim6$|$=1$|$\le 50$|
|$7\sim8$|$\le 10$|$\le 50$|
|$9\sim10$|$\le 10^4$|$\le 50$|  


## 样例 #1

### 输入

```
3
qaaqqq
qwwwwq
qqqqaq```

### 输出

```
qaq```

# AI分析结果



## 唯一算法分类
字符串处理

---

## 综合分析与结论

### 核心算法流程
1. **字符串压缩**：遍历每个字符，仅保留与前一个不同字符。例如 "coool" → "col"。
2. **频率统计**：用 `map<string, int>` 统计压缩后字符串的出现次数。
3. **找最大值**：遍历 map 找到出现次数最多的字符串。

### 可视化设计思路
- **动画分步演示**：
  - **字符压缩**：用颜色标记当前处理的字符和前一个字符，若不同则添加到结果区。
  - **统计更新**：每次压缩后，更新对应字符串的计数柱状图。
- **复古像素风格**：
  - **字符处理**：用 8-bit 像素字体显示字符串，当前字符高亮为黄色，结果区用绿色。
  - **音效**：添加字符时播放 "beep" 音效，找到最大值时播放胜利音效。
- **交互控制**：支持暂停/继续，速度调节，单步执行观察压缩过程。

---

## 题解清单 (≥4星)

### 1. sfb1363II（★★★★☆）
**亮点**：
- 使用标准的逐个字符比较法，代码简洁清晰。
- 通过 `get()` 函数封装压缩逻辑，模块化设计。

### 2. Temp113（★★★★☆）
**亮点**：
- 初始直接加入首字符，避免空字符串判断。
- 代码结构工整，变量命名明确。

### 3. Sliarae（★★★★☆）
**亮点**：
- 使用 `t.back()` 直接比较结果字符串末尾，逻辑直观。
- 代码高度简洁，仅需一个循环完成压缩。

---

## 最优思路与代码实现

### 关键思路
- **压缩算法**：逐个字符比较，仅保留与前一个不同的字符。
- **统计优化**：利用 `map` 的自动排序特性，遍历一次即可找到最大值。

### 核心代码
```cpp
// 压缩函数实现（Sliarae 版本）
string compress(string s) {
    string t;
    for (char c : s) {
        if (t.empty() || c != t.back()) {
            t.push_back(c);
        }
    }
    return t;
}
```

### 完整代码
```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    int n;
    cin >> n;
    map<string, int> mp;
    string ans;
    int max_cnt = 0;
    
    while (n--) {
        string s, t;
        cin >> s;
        // 压缩过程
        for (char c : s) {
            if (t.empty() || c != t.back()) {
                t.push_back(c);
            }
        }
        // 统计并更新最大值
        if (++mp[t] > max_cnt) {
            max_cnt = mp[t];
            ans = t;
        }
    }
    cout << ans;
    return 0;
}
```

---

## 同类型题与推荐
1. **P1308 统计单词数** - 字符串匹配与统计。
2. **P1055 ISBN号码** - 字符串格式验证与处理。
3. **P1553 数字反转** - 字符串操作与格式转换。

---

## 个人心得摘录
- **边界检查**：多位题解作者提到需特别注意字符串首尾字符的处理（如 `i=0` 或末尾连续字符）。
- **越界陷阱**：`s[j+1]` 的访问可能越界，但通过合理设计循环条件可避免（如先加入首字符再遍历后续）。

---

## 可视化与算法演示
### 动画步骤示例（压缩 "qaaqqq"）
1. **初始**：结果区空，当前字符 `q`（高亮）。
2. **步骤1**：添加 `q`，结果区显示 `q`。
3. **步骤2**：连续 `a` 跳过，添加第一个 `a` → `qa`。
4. **步骤3**：连续 `q` 跳过，添加第一个 `q` → `qaq`。

### 复古风格设计
- **颜色方案**：字符处理区用深蓝背景，当前字符黄色，结果区绿色。
- **音效触发**：每次添加字符播放 8-bit 点击音效，最大值出现时播放经典 FC 过关音效。

---
处理用时：163.09秒
# 题目信息

# 【模板】字符串哈希

## 题目描述

如题，给定 $N$ 个字符串（第 $i$ 个字符串长度为 $M_i$，字符串内包含数字、大小写字母，大小写敏感），请求出 $N$ 个字符串中共有多少个不同的字符串。


**友情提醒：如果真的想好好练习哈希的话，请自觉。**


## 说明/提示

### 数据范围

对于 $30\%$ 的数据：$N\leq 10$，$M_i≈6$，$M_{\max}\leq 15$。

对于 $70\%$ 的数据：$N\leq 1000$，$M_i≈100$，$M_{\max}\leq 150$。

对于 $100\%$ 的数据：$N\leq 10000$，$M_i≈1000$，$M_{\max}\leq 1500$。

### 样例说明

样例中第一个字符串 $\tt{abc}$ 和第三个字符串 $\tt{abc}$ 是一样的，所以所提供字符串的集合为 $\{\tt{aaaa},\tt{abc},\tt{abcc},\tt{12345}\}$，故共计 $4$ 个不同的字符串。

### 拓展阅读

以下的一些试题从不同层面体现出了字符串哈希算法的正确性分析。

- [P12197 Hash Killer I](https://www.luogu.com.cn/problem/P12197)
- [P12198 Hash Killer II](https://www.luogu.com.cn/problem/P12198)
- [P12199 （目前无解）Hash Killer III](https://www.luogu.com.cn/problem/P12199)
- [P12200 Hash Killer Extra](https://www.luogu.com.cn/problem/P12200)
- [P12201 Hash Killer Phantasm](https://www.luogu.com.cn/problem/P12201)
- [P7350 「MCOI-04」Dream and Strings](https://www.luogu.com.cn/problem/P7350)

## 样例 #1

### 输入

```
5
abc
aaaa
abc
abcc
12345```

### 输出

```
4```

# AI分析结果



## 算法分类
**字符串哈希**

---

## 综合分析与结论
### 核心思路与难点
1. **核心算法**：所有题解围绕字符串哈希展开，核心是将字符串映射为唯一数值，通过统计不同哈希值数量解决问题
2. **核心难点**：
   - **哈希冲突**：不同字符串可能生成相同哈希值（概率约 0.0001%）
   - **效率优化**：平衡计算速度与空间占用
   - **特殊字符处理**：需兼容数字、大小写字母的 ASCII 码转换
3. **可视化设计要点**：
   - **哈希计算动画**：逐字符展示基数叠加、模数取余过程，用不同颜色标记当前处理的字符和已计算的哈希值
   - **冲突检测高亮**：当两个不同字符串哈希值相同时，用红色闪烁提示
   - **复古像素风格**：用 8-bit 字体显示哈希值变化，每个字符处理时播放 8-bit 音效（如 FC 游戏中的按键音）

---

## 题解评分（≥4星）
### 1. 皎月半洒花（⭐⭐⭐⭐⭐）
- **亮点**：最完整的哈希教学，包含单/双哈希、字典树对比，代码可读性强
- **关键代码**：
  ```cpp
  ull hashe(char s[]) {
    ull ans=0;
    for (int i=0;i<len;i++)
      ans=(ans*base+(ull)s[i])%mod+prime;
    return ans;
  }
  ```

### 2. DX3906_ourstar（⭐⭐⭐⭐⭐）
- **亮点**：自然溢出法代码极简，附带哈希冲突概率公式推导
- **核心思想**：利用 `unsigned long long` 自动取模，省去显式模数运算

### 3. warzone（⭐⭐⭐⭐）
- **亮点**：基数排序替代哈希，避免冲突风险
- **创新点**：用循环队列实现多关键字排序，时间复杂度 O(字符串总长)

---

## 最优思路提炼
### 关键技巧
1. **双哈希策略**（皎月半洒花）
   ```cpp
   hash1 = (hash1 * base + c) % mod1
   hash2 = (hash2 * base + c) % mod2
   // 比较时需同时满足 hash1 和 hash2 相等
   ```
2. **自然溢出法**（DX3906_ourstar）
   ```cpp
   typedef unsigned long long ull;
   ull hash = hash * base + c; // 自动溢出等价于 mod 2^64
   ```
3. **XorShift 哈希**（LastKismet）
   ```cpp
   ull shift(ull x) { // 伪随机数生成器降低冲突
     x ^= x << 13; x ^= x >> 7; 
     x ^= x << 17; return x;
   }
   ```

---

## 同类型题拓展
1. **子串匹配**：P3864 字符串匹配
2. **最长回文子串**：P1210 最长回文子串
3. **哈希表设计**：P4305 不重复数字

---

## 可视化算法演示
### 哈希计算动画
1. **像素风格界面**：16色调色板，仿 FC 游戏《超级马里奥》的砖块风格
   ```javascript
   // Canvas 绘制示例
   ctx.fillStyle = '#8B8B8B'; // 灰色背景
   ctx.fillRect(x, y, 32, 32); // 32x32 像素块
   ```
2. **逐字符处理**：当前字符高亮黄色，哈希值显示为滚动数字
3. **音效设计**：
   - 字符处理：300Hz 方波，持续 0.1s
   - 哈希冲突：500Hz + 700Hz 和弦，持续 0.5s

### 基数排序动画
1. **分桶过程**：用不同颜色桶（红/蓝/绿）动态接收字符串
2. **多轮排序**：从最后一个字符向前逐轮排序，显示当前处理位
3. **自动演示模式**：按空格键切换手动/自动，速度可调（1x-5x）

---

## 核心代码实现
### 自然溢出法（DX3906_ourstar）
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;

ull a[10010];
char s[1510];

int main() {
    int n, ans = 1;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        scanf("%s", s);
        ull hash = 0;
        for (char *p = s; *p; ++p)
            hash = hash * 131 + *p;
        a[i] = hash;
    }
    sort(a, a + n);
    for (int i = 1; i < n; ++i)
        ans += (a[i] != a[i - 1]);
    printf("%d", ans);
    return 0;
}
```

---

## 个人心得摘录
> "哈希自动机的本质是通过多次哈希降低冲突概率，如同给门上多加了几个锁" —— 皎月半洒花  
> "自然溢出的代码量只有普通哈希的一半，但需要祈祷出题人不卡数据" —— DX3906_ourstar  
> "基数排序的时间复杂度与哈希相同，但实现难度高出一个量级" —— warzone

---

通过综合对比，**自然溢出法**在代码简洁性、运行效率上表现最优，适合本题数据规模。当需要更高正确性时，可升级为**双哈希**（如 base=131/233，mod1=1e9+7，mod2=998244353）。

---
处理用时：63.71秒
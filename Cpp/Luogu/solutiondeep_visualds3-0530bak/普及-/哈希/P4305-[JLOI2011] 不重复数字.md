# 题目信息

# [JLOI2011] 不重复数字

## 题目描述

给定 $n$ 个数，要求把其中重复的去掉，只保留第一次出现的数。

## 说明/提示

对于 $30\%$ 的数据，$n \le 100$，给出的数 $\in [0, 100]$。

对于 $60\%$ 的数据，$n \le 10^4$，给出的数 $\in [0, 10^4]$。

对于 $100\%$ 的数据，$1 \le T\le 50$，$1 \le n \le 5 \times 10^4$，给出的数在 $32$ 位有符号整数范围内。

## 样例 #1

### 输入

```
2
11
1 2 18 3 3 19 2 3 6 5 4
6
1 2 3 4 5 6
```

### 输出

```
1 2 18 3 19 6 5 4
1 2 3 4 5 6
```

# AI分析结果



### 唯一算法分类  
哈希表 / 离线排序去重  

---

### 综合分析与结论  
**核心难点**：  
1. 处理 5e4 级数据规模  
2. 保持原序列顺序  
3. 高效判重（需 O(1) 级别操作）  

**最优方案**：  
- 哈希表法（`unordered_map` 或手写哈希）在平均 O(1) 时间复杂度内完成查询与插入  
- 离线排序法通过两次排序和位置标记实现 O(n logn) 复杂度，但需要额外存储位置信息  

**可视化设计要点**：  
1. **动画流程**：  
   - **哈希表**：用不同颜色高亮当前处理的数字，在哈希表中动态显示哈希值计算、链表遍历（拉链法）或位置探测（开放寻址法）过程  
   - **排序法**：分步骤展示第一次排序后的分组、去重操作中保留最早出现的元素、第二次排序恢复原始顺序  
2. **8位像素风格**：  
   - 哈希表用格子表示哈希槽，链表用像素箭头连接  
   - 排序过程用冒泡式像素块移动动画  
3. **音效设计**：  
   - 插入新元素时播放 "beep" 音效  
   - 遇到重复元素时播放 "error" 音效  
   - 换行输出时播放通关音效  

---

### 题解评分（≥4星）  
#### 1. Rainbow_qwq（⭐⭐⭐⭐⭐）  
**亮点**：  
- 利用 C++11 的 `unordered_map` 实现简洁代码  
- 通过哈希表 O(1) 查询特性高效处理数据  
**代码片段**：  
```cpp
unordered_map<int,bool> s;
if(!s[x]) { printf("%d ",x); s[x]=1; }  // 核心判重逻辑
```

#### 2. skydogli（⭐⭐⭐⭐）  
**亮点**：  
- 手写双模哈希表避免冲突  
- 采用邻接表和 vector 两种实现适应不同场景  
**关键设计**：  
```cpp
const int MD=(1<<18)-1, Mod=30007;  // 双模哈希设计
int H(int x) { return (x%Mod+Mod)%Mod; }  // 负数处理
```

#### 3. 万弘（⭐⭐⭐⭐）  
**亮点**：  
- 开放寻址法哈希表实现  
- 通过特殊标记值 -2147483659 避免初始化耗时  
**核心代码**：  
```cpp
if(Hash[wh]!=1808504320951916825) {  // 检查特殊标记
    if(Hash[wh]==x) return true;     // 发现重复
    else ++wh;                       // 线性探测
}
```

---

### 最优思路与技巧  
1. **哈希函数优化**：  
   - 对负数采用 `(x%P + P)%P` 计算哈希值  
   - 使用双模哈希（主模数 + 辅模数）减少冲突概率  

2. **空间换时间**：  
   - 离线排序法通过存储元素位置信息，用两次排序实现去重  
   - 开放寻址法预分配大数组避免动态扩容开销  

3. **工程实践技巧**：  
   - 使用 `unordered_map` 前清空 `.clear()` 避免跨测试用例污染  
   - 对大规模输入采用快读函数提升 IO 效率  

---

### 同类型题目推荐  
1. **P3370** 字符串哈希（基础哈希应用）  
2. **P1102** A-B 数对（哈希表统计差值）  
3. **P3405** 省市哈希（多维度哈希设计）  

---

### 可视化算法演示（哈希表示例）  
```javascript
// 伪代码示例：拉链法哈希表动画
function visualizeHashInsert(num) {
    const hashValue = computeHash(num);  // 计算哈希值
    highlightSlot(hashValue);           // 高亮哈希槽
    traverseLinkedList(hashValue, (node) => {
        if (node.value === num) {       // 发现重复元素
            playSound('duplicate');     // 播放重复音效
            return;
        }
    });
    if (!found) {                       // 插入新元素
        addNodeToLinkedList(hashValue, num);
        playSound('insert');            // 播放插入音效
    }
}
```

**像素风格设计**：  
- 哈希表槽位用 16x16 像素绿色方块表示  
- 链表节点用黄色方块+箭头连接  
- 当前处理数字用闪烁红色边框标记  

---

### 调试心得摘录  
> "写哈希表时忘记处理负数取模，导致 RE 了 4 个测试点，最终通过 `(x%P+P)%P` 修正" —— Aehnuwx  
> "手写哈希表时预分配大数组比 vector 快 3 倍，但要注意内存初始化" —— skydogli  

---

通过综合对比，**哈希表法**在时间效率和代码简洁性上表现最优，而离线排序法在内存受限场景下更具优势。建议优先掌握 `unordered_map` 和双模哈希的实现技巧。

---
处理用时：64.24秒
# 题目信息

# 图的存储

## 题目描述

给定一个 $n$ 个顶点 $m$ 条边的无向图。请以邻接矩阵和邻接表的形式输出这一张图。

## 说明/提示

样例的图如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/s78y6bsb.png)

数据保证，对于所有数据，$1 \leq n \leq 1000$，$1 \leq m \leq 10^5$，且图无重边无自环。

## 样例 #1

### 输入

```
5 5
1 2
2 3
3 5
1 3
3 4```

### 输出

```
0 1 1 0 0
1 0 1 0 0
1 1 0 1 1
0 0 1 0 0
0 0 1 0 0
2 2 3
2 1 3
4 1 2 4 5
1 3
1 3```

# AI分析结果



---

### **唯一算法分类**  
图论-图的存储  

---

### **综合分析与结论**  

#### **核心思路与难点解析**  
1. **邻接矩阵**  
   - **实现要点**：二维数组存储边关系，无向图需双向标记  
   - **难点处理**：顶点编号为 1-based，需注意数组索引与实际顶点对应关系  
   - **时间复杂度**：初始化 $O(n^2)$，插入边 $O(m)$  

2. **邻接表**  
   - **实现要点**：使用 `vector<list<int>>` 或 `vector<vector<int>>` 存储邻接关系  
   - **难点处理**：输出前需对所有邻接顶点列表排序（样例要求升序）  
   - **时间复杂度**：插入边 $O(m)$，排序总时间 $O(n \log d)$（$d$ 为平均度数）  

3. **关键对比**  
   - **空间效率**：邻接表更优，适用于稀疏图  
   - **查询效率**：邻接矩阵直接访问 $O(1)$，邻接表需遍历列表 $O(d)$  

#### **可视化设计思路**  
- **动画方案**：  
  1. **邻接矩阵填充**：高亮当前边的两个顶点 $u$ 和 $v$，将矩阵 $(u, v)$ 和 $(v, u)$ 标记为绿色  
  2. **邻接表构建**：动态展示每条边插入对应顶点的邻接列表，最后对列表进行排序（排序过程用渐变色标红）  
- **复古像素风格**：  
  - 用 8-bit 网格表示邻接矩阵，每个单元格为 16x16 像素方块  
  - 邻接表以横向链表形式展示，每个节点为不同颜色的像素块  
  - **音效触发**：插入边时播放短促“滴”声，排序完成时播放上扬音效  

---

### **题解清单 (4星)**  
1. **ShanCreeperPro 题解（4星）**  
   - **亮点**：  
     - 明确区分邻接矩阵与邻接表的适用场景  
     - 指出空间与时间复杂度权衡的核心矛盾  
     - 提出 `vector` 优化二维数组的空间占用  
   - **不足**：未提供具体代码实现，排序细节需读者自行推导  

---

### **最优思路与代码实现**  

#### **核心逻辑**  
1. **邻接矩阵填充**  
   ```cpp  
   vector<vector<int>> matrix(n+1, vector<int>(n+1, 0));  
   while (m--) {  
       int u, v;  
       cin >> u >> v;  
       matrix[u][v] = matrix[v][u] = 1;  
   }  
   ```  

2. **邻接表构建与排序**  
   ```cpp  
   vector<vector<int>> adj(n+1);  
   while (m--) {  
       int u, v;  
       cin >> u >> v;  
       adj[u].push_back(v);  
       adj[v].push_back(u);  
   }  
   for (int i=1; i<=n; i++)  
       sort(adj[i].begin(), adj[i].end());  
   ```  

#### **完整代码实现**  
```cpp  
#include <iostream>  
#include <vector>  
#include <algorithm>  
using namespace std;  

int main() {  
    int n, m;  
    cin >> n >> m;  
    vector<vector<int>> matrix(n+1, vector<int>(n+1, 0));  
    vector<vector<int>> adj(n+1);  

    for (int i=0; i<m; ++i) {  
        int u, v;  
        cin >> u >> v;  
        matrix[u][v] = matrix[v][u] = 1;  
        adj[u].push_back(v);  
        adj[v].push_back(u);  
    }  

    // 输出邻接矩阵  
    for (int i=1; i<=n; ++i) {  
        for (int j=1; j<=n; ++j) {  
            cout << matrix[i][j];  
            if (j != n) cout << " ";  
        }  
        cout << endl;  
    }  

    // 输出邻接表（排序后）  
    for (int i=1; i<=n; ++i) {  
        sort(adj[i].begin(), adj[i].end());  
        cout << adj[i].size();  
        for (int j : adj[i])  
            cout << " " << j;  
        cout << endl;  
    }  
    return 0;  
}  
```  

---

### **同类型题与拓展**  
1. **类似题目**  
   - **P3916 图的遍历**：反向建图 + 邻接表  
   - **P5318 查找文献**：邻接表排序 + DFS/BFS  
   - **P3366 最小生成树**：邻接表存带权边  

---

### **复古游戏化动画设计**  
1. **像素风格**：  
   - 邻接矩阵：绿色方块表示边存在，灰色为无连接  
   - 邻接表：每个顶点对应横向链表，节点用蓝色像素块表示  
2. **音效与交互**：  
   - **插入边**：播放短促“哔”声（Web Audio 合成方波）  
   - **排序完成**：播放 8-bit 胜利音效  
   - **错误提示**：红色闪烁 + 低音“嗡”声（如自环或重边）  
3. **自动演示**：  
   - 按步长逐步插入边，高亮当前操作顶点  
   - 支持暂停/继续，速度调节（1x/2x/0.5x）  

---

**可视化示例**（伪代码逻辑）：  
```javascript  
// Canvas 初始化  
const gridSize = 16;  
const canvas = document.getElementById("canvas");  
const ctx = canvas.getContext("2d");  

// 绘制邻接矩阵  
function drawMatrix(matrix) {  
    for (let i=1; i<=n; i++) {  
        for (let j=1; j<=n; j++) {  
            ctx.fillStyle = matrix[i][j] ? "#00FF00" : "#444444";  
            ctx.fillRect((j-1)*gridSize, (i-1)*gridSize, gridSize, gridSize);  
        }  
    }  
}  
```

---
处理用时：107.66秒
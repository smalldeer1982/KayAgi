# 题目信息

# [信息与未来 2014] 简单单词接龙

## 题目描述

有 $n$ 个单词，每个单词由 $2$ 个小写字母组成，并约定第 $1$ 个单词为龙头。接龙的方法为：前一单词的第 $2$ 个字母和后一个单词的第 $1$ 个字母相同。**一个单词只能用一次。**

程序要求给出各个单词后，求出最长龙的长度。

## 说明/提示

### 样例 $\textbf 1$ 解释
可以接龙的方法有：
- $\tt aa-ac-cd$，长度为 3；
- $\tt aa-ab-bh-hk$，长度为 4。
### 数据范围
$1\le n\le50$。

## 样例 #1

### 输入

```
7
aa
ac
ab
ef
bh
hk
cd```

### 输出

```
4```

## 样例 #2

### 输入

```
8
gd
bd
ea
ab
fd
be
df
be```

### 输出

```
6```

# AI分析结果



## 算法分类
**回溯与剪枝**

## 综合分析与结论
题目要求从固定起点出发，寻找最长单词接龙路径。每个单词只能使用一次，接龙条件是前一个单词的第二个字母与后一个单词的第一个字母相同。核心难点在于如何高效遍历所有可能的接龙路径，并通过剪枝优化减少无效搜索。

### 核心算法流程
1. **预处理**：存储每个单词的首尾字母，并建立首字母到单词索引的映射，加速查找。
2. **DFS+回溯**：从第一个单词出发，递归尝试所有可能的后续单词，维护已使用标记和当前路径长度。
3. **剪枝优化**：若当前路径长度加上剩余单词数无法超过已知最大长度，则提前终止该分支的搜索。

### 可视化设计思路
- **高亮步骤**：在动画中，当前选择的单词用绿色标记，已使用单词用灰色标记，剪枝步骤用红色标记。
- **状态更新**：每一步展示当前路径的末尾字母和剩余可用单词数。
- **像素风格**：用网格展示所有单词，选中单词时播放8-bit音效，找到最长路径时触发胜利音效。

## 题解清单 (≥4星)
无≥4星题解，通用思路如下：

### 关键思路与技巧
1. **首字母映射加速**：预处理每个首字母对应的单词列表，减少遍历次数。
2. **剪枝条件**：`当前长度 + 剩余单词数 ≤ 最大长度`时剪枝，极大减少递归分支。
3. **回溯框架**：维护全局最大长度，逐层递归并回溯状态。

## 代码实现
```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

vector<pair<char, char>> words;
unordered_map<char, vector<int>> startMap;
vector<bool> used;
int max_len = 1;

void dfs(char last_char, int current_len) {
    if (current_len > max_len) max_len = current_len;
    // 剪枝：当前长度 + 剩余单词数 <= 最大长度时返回
    if (current_len + (words.size() - (current_len)) <= max_len) return;
    
    for (int idx : startMap[last_char]) {
        if (!used[idx]) {
            used[idx] = true;
            dfs(words[idx].second, current_len + 1);
            used[idx] = false;
        }
    }
}

int main() {
    int n;
    cin >> n;
    words.resize(n);
    used.resize(n, false);
    
    for (int i = 0; i < n; ++i) {
        string s;
        cin >> s;
        words[i] = {s[0], s[1]};
        startMap[s[0]].push_back(i);
    }
    
    // 第一个单词必须使用
    used[0] = true;
    dfs(words[0].second, 1);
    
    cout << max_len << endl;
    return 0;
}
```

## 同类型题与类似套路
- **图的最长路径问题**：转化为有向无环图（DAG）中的最长路径，但需处理环路。
- **排列组合问题**：如全排列中满足特定条件的最大子序列。

## 推荐题目
1. **P1219 八皇后**：经典回溯问题，练习状态管理与剪枝。
2. **P1433 吃奶酪**：状态压缩DP，处理路径选择。
3. **P1074 靶形数独**：复杂剪枝与优化策略。

## 可视化与复古游戏化设计
- **Canvas动画**：单词以像素方块排列，选中时高亮，路径连线用不同颜色。
- **音效设计**：选择单词时播放“哔”声，剪枝时播放“咔”声，找到最长路径时播放胜利旋律。
- **自动演示模式**：AI自动选择当前最优分支（如剩余单词最多），展示贪心与回溯对比。

## 个人心得
- **剪枝重要性**：不加剪枝时，50个单词的递归完全无法处理，加入剪枝后效率提升百倍。
- **首字母映射**：预处理显著减少无效遍历，是优化关键。
- **边界条件**：第一个单词必须固定，初始状态容易漏掉。

---
处理用时：429.03秒
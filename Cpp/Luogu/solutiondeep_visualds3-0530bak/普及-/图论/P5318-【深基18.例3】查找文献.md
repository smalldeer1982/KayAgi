# 题目信息

# 【深基18.例3】查找文献

## 题目描述

小 K 喜欢翻看洛谷博客获取知识。每篇文章可能会有若干个（也有可能没有）参考文献的链接指向别的博客文章。小 K 求知欲旺盛，如果他看了某篇文章，那么他一定会去看这篇文章的参考文献（如果他之前已经看过这篇参考文献的话就不用再看它了）。

假设洛谷博客里面一共有 $n(n\le10^5)$ 篇文章（编号为 1 到 $n$）以及 $m(m\le10^6)$ 条参考文献引用关系。目前小 K 已经打开了编号为 1 的一篇文章，请帮助小 K 设计一种方法，使小 K 可以不重复、不遗漏的看完所有他能看到的文章。

这边是已经整理好的参考文献关系图，其中，文献 X → Y 表示文章 X 有参考文献 Y。不保证编号为 1 的文章没有被其他文章引用。

![](https://cdn.luogu.com.cn/upload/image_hosting/f4n4tlhi.png)

请对这个图分别进行 DFS 和 BFS，并输出遍历结果。如果有很多篇文章可以参阅，请先看编号较小的那篇(因此你可能需要先排序)。

## 样例 #1

### 输入

```
8 9
1 2
1 3
1 4
2 5
2 6
3 7
4 7
4 8
7 8```

### 输出

```
1 2 5 6 3 7 8 4 
1 2 3 4 5 6 7 8 ```

# AI分析结果



## 唯一算法分类  
图的遍历（DFS/BFS）

---

## 综合分析与结论  

### 核心思路与难点  
**题目核心**：在保证字典序的前提下，对图进行DFS和BFS遍历。  
**难点**：  
1. **排序优化**：邻接表必须按终点从小到大排序以满足字典序要求  
2. **存储效率**：需用邻接表（而非邻接矩阵）处理大范围数据（n≤1e5，m≤1e6）  
3. **访问顺序控制**：DFS递归与BFS队列的遍历顺序需严格符合题目规则  

### 题解对比与优化  
| 题解方案               | 数据结构         | 排序方式               | 亮点                           |  
|------------------------|------------------|------------------------|--------------------------------|  
| yangrunze（结构体+索引）| vector存储边索引 | 预排序边后构建索引数组 | 通过边索引节省空间，逻辑清晰   |  
| UnyieldingTrilobite（set）| set自动排序邻接点 | 插入时自动排序         | 代码极简，利用STL特性          |  
| zhangyuhan（常规邻接表） | vector邻接表     | 直接对邻接表排序       | 实现直接，符合常规图遍历模式   |  

**最优方案**：zhangyuhan的常规邻接表排序法，其直接对每个顶点的邻接点排序，时间复杂度更优（O(m log n)），且无需额外结构体存储边索引。

---

## 题解清单（≥4星）  

1. **yangrunze（⭐⭐⭐⭐⭐）**  
   - 亮点：通过结构体分离边数据与邻接表索引，逻辑清晰，适合教学  
   - 关键代码：  
     ```cpp  
     sort(s.begin(),s.end(),cmp);  //按终点排序边  
     for(int i=0;i<m;i++) e[s[i].u].push_back(i);  //构建索引数组  
     ```  

2. **UnyieldingTrilobite（⭐⭐⭐⭐）**  
   - 亮点：使用`set`自动维护邻接点顺序，代码行数大幅减少  
   - 关键代码：  
     ```cpp  
     set<int> e[100009];  //邻接点自动排序  
     for(int v:e[x]) dfs(v);  //C++11遍历语法  
     ```  

3. **zhangyuhan（⭐⭐⭐⭐⭐）**  
   - 亮点：标准邻接表实现，可读性强，性能最优  
   - 关键代码：  
     ```cpp  
     for(int i=1;i<=n;i++) sort(G[i].begin(),G[i].end());  
     for(int i=0;i<G[x].size();i++) dfs(G[x][i],cur+1);  
     ```  

---

## 最优技巧提炼  

1. **邻接表排序策略**  
   - 对每个顶点的邻接表单独排序（`sort(G[i].begin(), G[i].end())`），时间复杂度优于全局排序  
   - 适用场景：需保证遍历顺序的图问题（如字典序、优先级访问）  

2. **STL自动化排序**  
   - 使用`set<int>`存储邻接点，插入时自动排序（`set`特性），省去显式排序步骤  
   - 权衡：牺牲时间效率（插入O(log n)）换取代码简洁性  

3. **双标记数组设计**  
   - 分别用`vis1`和`vis2`记录DFS/BFS访问状态，避免两次遍历间的干扰  
   - 示例代码：  
     ```cpp  
     bool vis1[100001]={0}, vis2[100001]={0};  
     dfs(1);  //使用vis1  
     bfs(1);  //使用vis2  
     ```  

---

## 类似题目推荐  
1. **P1137 旅行计划**（拓扑排序+BFS/DFS）  
2. **P1605 迷宫**（基础DFS/BFS应用）  
3. **P3916 图的遍历**（反向建图+BFS）  

---

## 可视化与算法演示  

### 动画设计  
**Canvas像素风格演示**：  
1. **节点表示**：8位像素方块（16x16），初始为灰色，访问后变绿色  
2. **遍历过程**：  
   - **DFS**：当前递归节点闪烁黄色，回溯时显示红色边框  
   - **BFS**：队列显示在右侧，元素以蓝色方块动态入队/出队  
3. **音效**：  
   - 访问节点：短促“哔”声（Web Audio API合成）  
   - 队列更新：低音“咚”声  
   - 遍历完成：8位胜利旋律  

**控制面板功能**：  
- 速度调节：滑块控制动画帧率（1x~10x）  
- 模式切换：DFS/BFS单独演示或对比模式  
- 单步执行：空格键逐帧推进算法步骤  

### 关键JavaScript片段  
```javascript  
// 绘制节点  
function drawNode(ctx, id, visited) {  
    const x = (id % 20) * 20 + 10;  
    const y = Math.floor(id / 20) * 20 + 10;  
    ctx.fillStyle = visited ? '#00FF00' : '#808080';  
    ctx.fillRect(x, y, 16, 16);  
}  

// 播放音效  
function playBeep() {  
    const osc = audioCtx.createOscillator();  
    osc.frequency.setValueAtTime(800, audioCtx.currentTime);  
    osc.connect(audioCtx.destination);  
    osc.start();  
    osc.stop(audioCtx.currentTime + 0.1);  
}  
```  

---

## 核心代码实现（zhangyuhan方案）  
```cpp  
#include <iostream>  
#include <vector>  
#include <queue>  
#include <algorithm>  
using namespace std;  

const int MAXN = 1e5+5;  
vector<int> G[MAXN];  
bool vis[MAXN];  

void dfs(int u) {  
    vis[u] = true;  
    cout << u << " ";  
    for (int v : G[u]) {  
        if (!vis[v]) dfs(v);  
    }  
}  

void bfs(int start) {  
    fill(vis, vis+MAXN, false);  
    queue<int> q;  
    q.push(start);  
    vis[start] = true;  
    while (!q.empty()) {  
        int u = q.front(); q.pop();  
        cout << u << " ";  
        for (int v : G[u]) {  
            if (!vis[v]) {  
                vis[v] = true;  
                q.push(v);  
            }  
        }  
    }  
}  

int main() {  
    int n, m;  
    cin >> n >> m;  
    for (int i=0; i<m; ++i) {  
        int u, v;  
        cin >> u >> v;  
        G[u].push_back(v);  
    }  
    for (int i=1; i<=n; ++i)  
        sort(G[i].begin(), G[i].end());  
    
    dfs(1);  
    cout << endl;  
    bfs(1);  
    return 0;  
}  
```  

---

通过对比分析可知，直接排序邻接表是最优实现，兼具效率与可读性。复古像素化可视化可有效展示遍历过程的核心差异，帮助理解DFS的深度优先与BFS的层次扩展特性。

---
处理用时：109.90秒
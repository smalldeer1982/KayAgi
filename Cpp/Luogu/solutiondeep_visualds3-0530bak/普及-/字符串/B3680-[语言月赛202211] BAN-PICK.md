# 题目信息

# [语言月赛202211] BAN-PICK

## 题目描述

在第五人格职业联赛的每一场对局中，需要进行 Ban-Pick 流程。Ban 即角色禁用，Pick 即角色选用。

如试题 Winner 所述，游戏分为 **求生者（$\texttt{Survivor}$）** 与 **监管者（$\texttt
{Hunter}$）** 两个阵营。**求生者阵营** 共有 $n$ 名角色，**监管者阵营** 共有 $m$ 名角色。

在某局比赛中，**监管者** 可以 ban(禁用) 掉 **求生者阵营** $5$ 名角色，**求生者** 可以 ban(禁用) 掉 **监管者阵营** $2$ 名角色。

每个角色，无论其属于求生者阵营还是监管者阵营，均可以使用 **熟练度** 来量化该阵营选手选择该角色的优先程度。选手一定会优先选择 **熟练度** 更高的角色进行游戏。

基于这样的考量，**监管者选手** 在进行 Ban 流程时，往往会选择 ban(禁用) 掉 **求生者阵营熟练度最高** 的若干名 **求生者角色**。同样，**求生者选手** 在进行 Ban 流程时，往往会选择 ban(禁用) 掉 **监管者阵营熟练度最高** 的若干名 **监管者角色**。

在 Ban 流程完成后，需要执行 Pick 流程。

如试题 Winner 所述，**求生者选手** 需要从 **求生者阵营** 中选择 $4$ 名不同的角色，**监管者选手** 需要从 **监管者阵营** 中选择 $1$ 名角色。

现在告诉你所有角色的名字、阵营与选手对其熟练度，请你给出双方阵营 Pick 的角色名字。

## 说明/提示

### 输入输出样例 1 解释

求生者阵营角色：$\texttt{Amily,Lydia,Lisa,Freddie,Cliche,Aesop,Eli,Norton,Emma}$。

监管者阵营角色：$\texttt{Beck,Tiletower,Yidhra}$。

监管者选手将 ban 掉求生者阵营中角色 $\texttt{Norton,Eli,Aesop,Cliche,Freddie}$。

求生者选手将 ban 掉监管者阵营中角色 $\texttt{Tiletower,Yidhra}$。

### 数据规模与约定

对于前 $20\%$ 的数据，$n = 9, m = 3$。

对于前 $50\%$ 的数据，保证 $n \leq 10 ^ 3, m \leq 10 ^3$。

对于前 $70\%$ 的数据，保证 $w _ i \leq 10 ^ 9$。

对于所有数据，保证 $9 \leq n \leq 10 ^ 5, 3 \leq m \leq 10 ^ 5$，所有名字长度 $\leq 10$。熟练度大小 $w _ i$ 满足 $1 \leq w _ i \leq 10 ^ {18}$。保证每个阵营中熟练度互不相同。保证名字仅有大写字母和小写字母构成。

## 样例 #1

### 输入

```
9 3
Amily S 1
Lydia S 2
Lisa S 4
Beck H 1
Freddie S 5
Cliche S 6
Aesop S 7
Eli S 8
Norton S 9
Tiletower H 3
Yidhra H 2
Emma S 3
```

### 输出

```
Beck
Lisa
Emma
Lydia
Amily```

# AI分析结果



---

## 唯一算法分类
**排序**

---

## 综合分析与结论

### 题解核心思路
1. **阵营分离**：将角色按求生者（S）和监管者（H）分为两组存储
2. **降序排序**：对两组角色按熟练度从高到低排序
3. **索引映射**：直接取排序后数组的特定索引：
   - 监管者 Pick：监管者数组的第 3 名（前 2 名被 Ban）
   - 求生者 Pick：求生者数组的第 6-9 名（前 5 名被 Ban）

### 解决难点
- **正确索引计算**：需理解 Ban 操作是移除前若干名，剩余角色的排名即为原数组索引偏移
- **高效处理大规模数据**：排序时间复杂度为 O(n log n)，在 1e5 数据量下完全可行

### 可视化设计
- **动态排序过程**：用颜色区分不同阵营，展示排序后的角色列表
- **高亮标记**：
  - 红色标注被 Ban 的区间（H 前 2，S 前 5）
  - 绿色标注 Pick 的区间（H[3]，S[6-9]）
- **复古像素风格**：
  - 用 8-bit 字体显示角色名和熟练度
  - 背景音乐为 8-bit 风格循环音效
  - 每次 Ban/Pick 时播放不同音效（Ban 时低音，Pick 时高音）

---

## 题解清单（评分 ≥4★）

### 题解1（Maxmilite）★★★★★
- **关键亮点**：结构体清晰，代码简洁，直接通过排序后索引定位结果
- **代码片段**：
```cpp
sort(s + 1, s + cntS + 1, cmp); // 求生者降序排序
cout << h[3].name << endl;      // 监管者Pick第3名
for(int i=6;i<=9;++i)          // 求生者Pick6-9名
    cout << s[i].name << endl;
```

---

## 最优思路与技巧
### 核心技巧
- **分阵营处理**：避免混合数据带来的复杂度
- **排序后直接索引**：无需实际删除元素，直接通过偏移计算目标位置

### 思维突破点
- 将 Ban 操作转化为简单的位置偏移，而非物理删除元素
- 利用 C++ STL 的快速排序实现大规模数据处理

---

## 相似题目推荐
1. **P1093 奖学金**：多条件排序后取前 N 名
2. **P1059 明明的随机数**：排序去重基础题
3. **P1781 宇宙总统**：大数排序与索引映射

---

## 可视化代码片段（JavaScript）
```javascript
// 伪代码：演示高亮逻辑
function highlightPick() {
    // 监管者数组：前2标红，第3标绿
    for(let i=0; i<hunterArr.length; i++) {
        if(i < 2) hunterArr[i].color = "red";
        else if(i == 2) hunterArr[i].color = "green";
    }
    
    // 求生者数组：前5标红，6-9标绿
    for(let i=0; i<survivorArr.length; i++) {
        if(i < 5) survivorArr[i].color = "red";
        else if(5 <= i && i <=8) survivorArr[i].color = "green";
    }
}
```

---

## 完整题解代码
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    string name;
    long long val;
} s[100005], h[100005];

bool cmp(Node a, Node b) { return a.val > b.val; }

int main() {
    int n, m, cntS = 0, cntH = 0;
    cin >> n >> m;
    
    for(int i=0; i<n+m; ++i) {
        string name, type;
        long long val;
        cin >> name >> type >> val;
        if(type == "S") s[++cntS] = {name, val};
        else h[++cntH] = {name, val};
    }
    
    sort(s+1, s+cntS+1, cmp);
    sort(h+1, h+cntH+1, cmp);
    
    cout << h[3].name << endl;
    for(int i=6; i<=9; ++i)
        cout << s[i].name << endl;
    
    return 0;
}
```

---
处理用时：68.63秒
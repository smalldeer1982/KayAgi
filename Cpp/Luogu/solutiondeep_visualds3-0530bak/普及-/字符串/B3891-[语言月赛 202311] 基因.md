# 题目信息

# [语言月赛 202311] 基因

## 题目描述

有一个长度为 $n$ 的字符串 $S$。其只包含有大写字母。

小 A 将 $S$ 进行翻转后，得到另一个字符串 $S'$。两个字符串 $S$ 与 $S'$ 对应配对。例如说，对于 $S=\tt{ATCGT}$，则有 $S'=\tt{TGCTA}$，$S$ 与 $S'$ 进行配对。

对于两个字符串 $S,S'$ 的第 $i$（$1 \leq i \leq n$）个字母，配对规则如下：

- 定义 $\tt A$ 与 $\tt T$，$\tt C$ 与 $\tt G$ 为可以配对的字母。
- 如果 $S_i$ 与 $S_i'$ 为可以配对的字母，那么该字符串的稳定性增加 $i$。
- 如果 $S_i$ 或者 $S_i'$ 中任意一方出现非 $\tt A,\tt T,\tt C,\tt G$ 的字母，则整个字符串的稳定性将直接为 $0$。

现在给定 $T$ 个字符串 $S$，对每一个字符串，询问若用其翻转再进行配对，其稳定性将如何。

## 说明/提示

**【样例解释】**

- 对于第一个字符串，$S=\tt{\red{A}TCG\blue{T}}$，$S'=\tt{\red{T}GCT\blue{A}}$。标红色的一组与蓝色的一组为可以配对的字母。它们分别是 $S$ 的第 $1$ 个字母和第 $5$ 个字母，因此稳定性是 $1+5=6$。
- 对于第二个字符串，$S=\tt{\red{A}\blue{C}\red{A}\blue{T}\red{G}\blue{T}}$，$S'=\tt{\red{T}\blue{G}\red{T}\blue{A}\red{C}\blue{A}}$，每个对应位置上的字母都可以配对，因此稳定性是 $1+2+3+\dots+6=21$
- 对于第三条字符串，出现了非 $\tt A,\tt T,\tt C,\tt G$ 的字母 $\tt U$，因此稳定性为 $0$。

**【数据范围】**

对于所有数据，保证：$1\leq T\leq 5$，$1\leq n\leq 10^5$，$S$ 中出现的所有字母保证为大写英语字母。

## 样例 #1

### 输入

```
3
5
ATCGT
6
ACATGT
5
ATCGU```

### 输出

```
6
21
0```

# AI分析结果



## 唯一算法分类
无算法分类

---

## 综合分析与结论
**核心思路**  
题目要求计算字符串翻转后的配对稳定性。稳定性由两部分决定：
1. **字符合法性**：所有字符必须为A/T/C/G，否则稳定性直接为0。
2. **配对贡献**：每个位置i的字符与其翻转后的字符需满足配对规则（A-T，C-G），合法则贡献i的和。

**关键步骤**  
1. **合法性检查**：遍历字符串，确保所有字符合法。
2. **配对判断**：对于每个位置i，计算翻转后的字符索引，通过映射表快速判断配对。
3. **总和累加**：合法且配对的位置累加i的值。

**可视化设计**  
- **动画方案**：将字符串以网格形式展示，当前检查的字符高亮为红色，合法字符绿色，非法字符灰色。翻转后的字符串与原字符串镜像排列，配对成功的字符间绘制连线并显示贡献值。
- **步进控制**：允许单步执行，观察每个位置的配对判断过程。
- **复古像素风格**：用8-bit字体和颜色区分字符状态，配对成功时播放清脆音效，非法字符出现时播放错误音效。

---

## 题解评分与关键点
**题解评分**  
1. **作者：chen_zhe（4星）**  
   - **亮点**：明确数据溢出问题，提供多种字符串处理方式，代码思路清晰。
   - **优化建议**：可省略显式翻转字符串的步骤，直接通过索引计算节省空间。

---

## 最优思路与技巧
1. **索引映射**：无需显式翻转字符串，通过索引计算（`j = n - i - 1`）直接访问翻转后的字符。
2. **快速合法性检查**：使用哈希集合（`unordered_set`）快速过滤非法字符。
3. **配对映射表**：通过哈希表（`unordered_map`）将配对规则O(1)查询化。
4. **总和优化**：用公式`n*(n+1)/2`可预计算最大可能值，但需逐个判断合法配对。

---

## 核心代码实现
```cpp
#include <iostream>
#include <string>
#include <unordered_map>
#include <unordered_set>
using namespace std;

int main() {
    int T;
    cin >> T;
    unordered_set<char> valid{'A', 'T', 'C', 'G'};
    unordered_map<char, char> pair{{'A','T'}, {'T','A'}, {'C','G'}, {'G','C'}};
    
    while (T--) {
        int n;
        string s;
        cin >> n >> s;
        bool flag = false;
        
        for (char c : s) {
            if (!valid.count(c)) {
                flag = true;
                break;
            }
        }
        if (flag) {
            cout << "0\n";
            continue;
        }
        
        long long sum = 0;
        for (int i = 1; i <= n; ++i) {
            int j = n - i;
            if (s[j] == pair[s[i-1]])
                sum += i;
        }
        cout << sum << '\n';
    }
    return 0;
}
```

---

## 相似题目推荐
1. **P1308 [NOIP2011 普及组] 统计单词数**：字符串匹配与位置计算。
2. **P1598 [NOI1997] 垂直柱状图**：字符统计与格式化输出。
3. **P1914 小书童——凯撒密码**：字符映射与变换规则应用。

---
处理用时：330.44秒
# 题目信息

# [NOIP 2003 普及组] 乒乓球

## 题目背景

国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中 $11$ 分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白 $11$ 分制和 $21$ 分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。

## 题目描述

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在 $11$ 分制和 $21$ 分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中 $\texttt W$ 表示华华获得一分，$\texttt L$ 表示华华对手获得一分）：

$\texttt{WWWWWWWWWWWWWWWWWWWWWWLW}$

在 $11$ 分制下，此时比赛的结果是华华第一局 $11$ 比 $0$ 获胜，第二局 $11$ 比 $0$ 获胜，正在进行第三局，当前比分 $1$ 比 $1$。而在 $21$ 分制下，此时比赛结果是华华第一局 $21$ 比 $0$ 获胜，正在进行第二局，比分 $2$ 比 $1$。如果一局比赛刚开始，则此时比分为 $0$ 比 $0$。直到分差大于或者等于 $2$，才一局结束。

**注意：当一局比赛结束后，下一局立刻开始**。

你的程序就是要对于一系列比赛信息的输入（$\texttt{WL}$ 形式），输出正确的结果。


## 说明/提示

每行至多 $25$ 个字母，最多有 $2500$ 行。

（注：事实上有一个测试点有 $2501$ 行数据。）

**【题目来源】**

NOIP 2003 普及组第一题

## 样例 #1

### 输入

```
WWWWWWWWWWWWWWWWWWWW
WWLWE
```

### 输出

```
11:0
11:0
1:1

21:0
2:1
```

# AI分析结果



## 算法分类
模拟

---

## 题解思路与解决难点

### 核心算法逻辑
1. **输入处理**：连续读取字符直到遇到'E'，过滤非WL字符  
2. **分数统计**：遍历每个字符累加华华和对手的得分  
3. **结束条件判断**：当 max(得分) ≥ k 且分差 ≥2 时结算一局  
4. **边界处理**：遍历结束后输出未完成的比分

### 难点对比分析
| 题解差异点        | 解决思路                                                                 | 优劣分析                     |
|-------------------|--------------------------------------------------------------------------|------------------------------|
| 输入存储方式      | 使用string拼接输入（DengDuck） vs 字符数组（__assassin_）                | string更简洁，数组更易索引   |
| 分制处理复用      | 抽象为work函数（DengDuck） vs 复制代码块（mairuisheng）                  | 函数复用减少代码冗余         |
| 结束条件判断形式  | `max(a,b)>=k && abs(a-b)>=2` vs `(a>=k&&a-b>=2)||(b>=k&&b-a>=2)`         | 前者更简洁，后者更直观       |
| 比分输出时机      | 立即输出后清零 vs 缓存结果最后统一输出                                   | 立即输出更节省内存           |

---

## 题解评分（≥4星）

### [⭐⭐⭐⭐⭐] DengDuck（函数复用版）
**核心亮点**：  
1. 函数抽象处理不同分制，代码复用率高  
2. 使用C++11的range-based for循环提升可读性  
3. 正确处理连续输入和边界条件

### [⭐⭐⭐⭐] qhr2023（三元运算符版）
**核心亮点**：  
1. 使用三元运算符精简得分逻辑  
2. 函数式调用结构清晰  
3. 代码总行数最少（仅16行）

### [⭐⭐⭐⭐] lucky_Mrzhao（输入预处理版）
**独特优势**：  
1. 单独处理输入中的非法字符  
2. 使用`max()`和`abs()`标准化条件判断  
3. 包含详细的本地调试提示

---

## 最优思路提炼

### 关键实现技巧
1. **函数抽象**：将分制参数化处理（见代码片段）  
```cpp
void Work(int Lim) {
    for(char i:S) {
        if(i=='W') A++;
        if(i=='L') B++;
        if(max(A,B)>=Lim && abs(A-B)>=2) {
            cout << A << ":" << B << endl;
            A = B = 0; // 重置分数
        }
    }
    printf("%d:%d\n\n",A,B); // 处理未完成局
}
```

2. **输入过滤**：使用`while(cin>>C)`自动跳过空白符  
3. **结束判断优化**：`max(A,B)>=k`比`A>=k || B>=k`少一次判断  

### 易错点防御
1. **最后比分输出**：遍历结束后必须输出未完成的比分  
2. **局间清零顺序**：先输出再重置，避免漏掉最后一局  
3. **分差判断**：必须严格≥2分，而非＞2分  

---

## 同类题目推荐
1. **P1563 玩具谜题**（方向模拟）  
2. **P1055 ISBN号码**（字符处理与校验）  
3. **P1328 生活大爆炸版石头剪刀布**（规则模拟）

---

## 算法可视化设计

### 核心动画逻辑
```javascript
// 伪代码示例
class PingpongAnim {
    constructor(data) {
        this.records = data.replace(/[^WL]/g, '').split('') // 过滤输入
        this.scores = { w:0, l:0, mode:11 }
    }
    
    nextStep() {
        const char = this.records.shift()
        char === 'W' ? this.scores.w++ : this.scores.l++
        
        // 高亮当前得分变化
        highlightScore(char)
        
        if(this.checkEnd()) {
            drawResult(this.scores) // 绘制比分
            resetScores()           // 清零动画
        }
    }
    
    checkEnd() {
        const {w, l, mode} = this.scores
        return Math.max(w,l)>=mode && Math.abs(w-l)>=2
    }
}
```

### 复古风格实现
1. **像素绘制**：使用8x8像素块表示比分，每得一分闪烁对应区域  
2. **音效设计**：
   - `W得分`：NES风格的"叮"声（三角波）  
   - `L得分`：低音鼓声  
   - `局结束`：短促的上行音阶
3. **自动演示**：按原始输入顺序自动播放，支持暂停/加速

---

## 完整题解代码
```cpp
#include<bits/stdc++.h>
using namespace std;

string S;
char C;
int A, B;

void Work(int Lim) {
    A = B = 0;
    for(char c : S) {
        c == 'W' ? A++ : B++;
        if(max(A, B) >= Lim && abs(A - B) >= 2) {
            cout << A << ":" << B << endl;
            A = B = 0;
        }
    }
    cout << A << ":" << B << "\n\n";
}

int main() {
    while(cin >> C && C != 'E') 
        if(C == 'W' || C == 'L') S += C;
    
    Work(11);
    Work(21);
    return 0;
}
```

---

## 心得分野
**DengDuck的调试经验**：  
> "本地测试时发现输入无法终止，最后意识到需要Ctrl+Z生成EOF信号。这提示我们，在线评测与本地环境的输入终止方式可能存在差异，应特别注意边界条件的测试。"

**qhr2023的优化启示**：  
> "最初使用两个独立的循环处理11分和21分，后来发现函数抽象能减少50%的代码量。这证明了代码复用在实际开发中的重要性，特别是处理规则相似的场景。"

---
处理用时：63.94秒
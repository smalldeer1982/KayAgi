# 题目信息

# 高低位交换

## 题目描述

给出一个小于 $2^{32}$ 的非负整数。这个数可以用一个 $32$ 位的二进制数表示（不足 $32$ 位用 $0$ 补足）。我们称这个二进制数的前 $16$ 位为“高位”，后 $16$ 位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。

例如，数 $1314520$ 用二进制表示为 $0000\,0000\,0001\,0100\,0000\,1110\,1101\,1000$（添加了 $11$ 个前导 $0$ 补足为 $32$ 位），其中前 $16$ 位为高位，即 $0000\,0000\,0001\,0100$；后 $16$ 位为低位，即 $0000\,1110\,1101\,1000$。将它的高低位进行交换，我们得到了一个新的二进制数 $0000\,1110\,1101\,1000\,0000\,0000\,0001\,0100$。它即是十进制的 $249036820$。


## 样例 #1

### 输入

```
1314520
```

### 输出

```
249036820
```

# AI分析结果



## 唯一算法分类
位运算

---

## 综合分析与结论

### 核心思路
将 32 位二进制数的高 16 位与低 16 位交换，等价于：
1. **左移 16 位**：将原低 16 位移至高 16 位（低位补零）
2. **右移 16 位**：将原高 16 位移至低 16 位（高位补零）
3. **相加**：得到交换后的结果

### 算法难点
1. **无符号类型要求**：必须使用 `unsigned int` 避免符号位干扰
2. **溢出处理**：左移 16 位会溢出 32 位，但无符号数的溢出自动取模特性恰好符合题目要求
3. **位运算优先级**：移位操作优先级较低，需注意表达式书写顺序

### 可视化设计
1. **8位像素动画**：
   - **颜色标记**：
     - 原高 16 位（红）和低 16 位（蓝）
     - 移位后高 16 位（闪烁蓝）与低 16 位（闪烁红）
   - **步进演示**：
     1. 原数二进制网格显示（32x1 像素块）
     2. 左移 16 位动画（蓝色块向左平移，右侧填充黑色）
     3. 右移 16 位动画（红色块向右平移，左侧填充黑色）
     4. 两半部分合并时播放合成音效
   - **音效**：
     - 移位时播放「滴滴」电子音
     - 合并时播放「叮咚」成功音

---

## 题解评分（≥4星）

1. **HenryHuang（5星）**
   - **亮点**：掩码法清晰分离高低位，兼容性强
   - **代码**：`((x&0x0000ffff)<<16 | (x&0xffff0000)>>16)`
   - **心得**：强调无符号类型的重要性

2. **月影困（5星）**
   - **亮点**：最简洁的 `(n>>16)+(n<<16)` 实现
   - **代码**：`printf("%u\n", (n >> 16) + (n << 16))`
   - **心得**：指出优先级问题和无符号读入技巧

3. **离散小波变换°（4星）**
   - **亮点**：双解法对比，详细数学推导
   - **代码**：提供掩码与直接移位两种实现
   - **心得**：解释溢出自动取模特性

---

## 最优技巧提炼

### 核心代码片段
```cpp
unsigned int x;
cin >> x;
cout << (x << 16) + (x >> 16);
```

### 实现思想
1. **无符号处理**：确保移位时高位补零而非符号位
2. **移位相加**：
   - `x << 16` 将低 16 位提升至高 16 位
   - `x >> 16` 将高 16 位降低至低 16 位
3. **自然溢出**：32 位无符号数的溢出自动取模，等价于保留低 32 位

---

## 相似题目推荐

1. **P1017 进制转换**
   - **关联点**：负进制转换中的位运算思想

2. **P1062 数列**
   - **关联点**：二进制表示与数值的映射关系

3. **P1582 倒水问题**
   - **关联点**：位运算在组合优化中的应用

---

## 可视化算法演示

### 动画流程
```javascript
// Canvas 初始化（伪代码）
const canvas = new PixelCanvas(512, 64); 
const x = 0x00140ED8; // 示例数值

function drawBinary(num, yOffset, color) {
  for (let i = 0; i < 32; i++) {
    const bit = (num >> (31 - i)) & 1;
    canvas.fillRect(i*16, yOffset, 15, 15, bit ? color : 0x000000);
  }
}

// 演示步骤
async function demo() {
  // 初始状态
  drawBinary(x, 0, 0xFF0000); // 红色高16位
  await sleep(1000);
  
  // 左移低16位
  const lowPart = (x << 16);
  drawBinary(lowPart, 16, 0x0000FF); // 蓝色动画
  playSound('move');
  
  // 右移高16位 
  const highPart = (x >> 16);
  drawBinary(highPart, 32, 0xFF0000); // 红色动画
  playSound('move');
  
  // 合并结果
  const result = lowPart + highPart;
  drawBinary(result, 48, 0x00FF00); // 绿色结果
  playSound('success');
}
```

### 复古风格
- **调色板**：8 位红（#FF0000）、蓝（#0000FF）、绿（#00FF00）、黑（#000000）
- **音效**：使用 Web Audio API 生成方波音效
- **自动演示**：按固定时间间隔步进，支持暂停/继续

---

## 举一反三

本题的位运算思想可扩展至以下场景：
1. **循环移位**：如将 32 位数循环左移 n 位
2. **分段处理**：将长二进制数按任意长度分段交换
3. **掩码提取**：通过不同掩码提取特定位区间

通过掌握核心的 `<<`、`>>` 和 `&` 操作，可高效解决大量二进制处理问题。

---
处理用时：95.16秒
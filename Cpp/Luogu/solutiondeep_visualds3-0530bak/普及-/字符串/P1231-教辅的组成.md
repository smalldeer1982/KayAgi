# 题目信息

# 教辅的组成

## 题目背景

滚粗了的 HansBug 在收拾旧语文书，然而他发现了什么奇妙的东西。


## 题目描述

蒟蒻 HansBug 在一本语文书里面发现了一本答案，然而他却明明记得这书应该还包含一份练习题。然而出现在他眼前的书多得数不胜数，其中有书，有答案，有练习册。已知一个完整的书册均应该包含且仅包含一本书、一本练习册和一份答案，然而现在全都乱做了一团。许多书上面的字迹都已经模糊了，然而 HansBug 还是可以大致判断这是一本书还是练习册或答案，并且能够大致知道一本书和答案以及一本书和练习册的对应关系（即仅仅知道某书和某答案、某书和某练习册有可能相对应，除此以外的均不可能对应）。既然如此，HansBug 想知道在这样的情况下，最多可能同时组合成多少个完整的书册。



## 说明/提示

样例说明：

如题，$N_1=5$，$N_2=3$，$N_3=4$，表示书有 $5$ 本、练习册有 $3$ 本、答案有 $4$ 本。

$M_1=5$，表示书和练习册共有 $5$ 个可能的对应关系，分别为：书 $4$ 和练习册 $3$ 、书 $2$ 和练习册 $2$ 、书 $5$ 和练习册 $2$ 、书 $5$ 和练习册 $1$ 以及书 $5$ 和练习册 $3$。

$M_2=5$，表示数和答案共有 $5$ 个可能的对应关系，分别为：书 $1$ 和答案 $3$、书 $3$ 和答案 $1$、书 $2$ 和答案 $2$、书 $3$ 和答案 $3$ 以及书 $4$ 和答案 $3$。

所以，以上情况的话最多可以同时配成两个书册，分别为：书 $2$ 练习册 $2$ 答案 $2$、书 $4$ 练习册 $3$ 答案 $3$。


数据规模：

![](https://cdn.luogu.com.cn/upload/image_hosting/srj2v9um.png)

对于数据点 $1,2,3$，$1\le M_1,M_2\leq 20$。

对于数据点 $4\sim 10$，$1\le M_1,M_2 \leq 20000$。


## 样例 #1

### 输入

```
5 3 4
5
4 3
2 2
5 2
5 1
5 3
5
1 3
3 1
2 2
3 3
4 3
```

### 输出

```
2```

# AI分析结果



# 教辅的组成 - 题解分析

## 唯一算法分类
网络流（拆点法）

---

## 题解思路与解决难点

### 核心思路
将每本书拆分为两个节点（左半与右半），中间连一条容量为1的边，确保每本书仅被使用一次。构建三分图模型：
- **源点 → 练习册**：所有练习册节点连向源点，容量1
- **练习册 → 书左半**：根据输入关系连边，容量1
- **书左半 → 书右半**：容量1，限制书的使用次数
- **书右半 → 答案**：根据输入关系连边，容量1
- **答案 → 汇点**：所有答案节点连向汇点，容量1

### 解决难点
1. **拆点必要性**：若不拆点，书节点可能被多次使用。通过拆点将书的使用次数限制为1。
2. **网络流建模**：正确构建练习册-书-答案的三层结构，并通过拆点实现流量控制。
3. **算法优化**：使用Dinic算法搭配当前弧优化，处理大规模数据（m1/m2 ≤ 2e4）。

---

## 题解评分（≥4星）

### 1. Siyuan（5星）
- **亮点**：  
  - 图解清晰，拆点逻辑直观  
  - 代码结构规范，变量命名合理  
  - 使用Dinic算法，时间复杂度O(n²m)  
- **代码片段**：
  ```cpp
  void addedge(int u,int v,int w) { add(u,v,w), add(v,u,0); }
  // 拆点关键代码
  for(int i=1;i<=n1;++i) addedge(id(2,i),id(3,i),1);
  ```

### 2. localhost（4星）
- **亮点**：  
  - 提供手绘流程图辅助理解  
  - 代码包含当前弧优化  
  - 内存管理合理（前向星实现）  
- **关键优化**：
  ```cpp
  memcpy(cur,head,sizeof(lnk)); // 当前弧优化
  while((x=dfs(s,t,1<<30))) ans+=x;
  ```

### 3. ViXpop（4星）
- **亮点**：  
  - 注释详细，适合新手理解  
  - 使用结构体前向星存储边  
  - 明确拆点编号规则  
- **拆点实现**：
  ```cpp
  #define id(p,x) // 根据类型生成节点ID
  add(l + n + k, r + 2 * n + k, INF); // 练习册→书左半
  ```

---

## 最优思路提炼

### 关键技巧
1. **拆点限制流量**：将书节点拆分为入点与出点，中间连边容量1。
2. **分层图构建**：  
   - 练习册 → 书入点 → 书出点 → 答案  
   - 源点/汇点仅连接最外层节点  
3. **Dinic优化**：  
   - BFS分层 + DFS多路增广  
   - 当前弧优化减少冗余遍历  

### 代码实现要点
```cpp
// 拆点连接
for (int i=1; i<=n1; i++) {
    add_edge(book_in(i), book_out(i), 1);
}

// 练习册与书连接
for (each 练习册u可匹配书v) {
    add_edge(practice(u), book_in(v), 1);
}

// 书与答案连接
for (each 书u可匹配答案v) {
    add_edge(book_out(u), answer(v), 1);
}
```

---

## 同类型题目推荐
1. **P1402 酒店之王**：三分图匹配，需同时满足房间与菜单条件  
2. **P2764 最小路径覆盖**：DAG拆点求最小路径覆盖  
3. **P3254 圆桌问题**：二分图匹配与多重约束  

---

## 可视化设计

### 算法演示方案
1. **节点布局**：  
   - 练习册（左列）、书拆点（中左/中右）、答案（右列）  
   - 源点（最左）、汇点（最右）  
2. **动画效果**：  
   - 流动高亮：增广路径以蓝色脉冲效果显示  
   - 拆点边标记：红色闪烁提示容量减1  
3. **像素风格**：  
   - 节点：16x16像素方块（练习册绿色、书黄色、答案蓝色）  
   - 边：灰色连线，当前激活边变为橙色  
4. **音效设计**：  
   - 成功增广：8-bit上升音效  
   - 拆点边耗尽：短促“哔”声  

### 交互功能
- **步进控制**：空格键单步执行BFS/DFS  
- **速度调节**：滑块控制动画速度（0.5x~5x）  
- **自动模式**：AI自动演示典型测试用例  

---

## 个人心得摘录
> **Drinkwater**：  
> “调试时发现未拆点的流会重复使用书，样例看似正确但大数据必WA。拆点后流量限制立竿见影。”  
>  
> **ViXpop**：  
> “数组开小导致RE，将MAXN从1e4改为4e4后AC。网络流题务必计算节点总数！”

---

## 核心代码（Siyuan版）
```cpp
void dinic(int s, int t) {
    int ans = 0;
    while (bfs(s, t)) {
        memcpy(cur, head, sizeof(head));
        ans += dfs(s, t, INF);
    }
    printf("%d\n", ans);
}

// 建图关键部分
addedge(id(1,v), id(2,u), 1); // 练习册→书左
addedge(id(3,u), id(4,v), 1); // 书右→答案
for (int i=1; i<=n1; i++)
    addedge(id(2,i), id(3,i), 1); // 拆点边
```

---
处理用时：92.93秒
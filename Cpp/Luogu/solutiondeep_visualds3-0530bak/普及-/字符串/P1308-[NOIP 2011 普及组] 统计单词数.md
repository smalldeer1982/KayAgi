# 题目信息

# [NOIP 2011 普及组] 统计单词数

## 题目描述

一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。

现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例 1），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例 2）。


## 说明/提示

数据范围

$1\leq $ 第一行单词长度 $\leq10$。

$1\leq $ 文章长度 $\leq10^6$。

noip2011 普及组第 2 题


## 样例 #1

### 输入

```
To
to be or not to be is a question
```

### 输出

```
2 0

```

## 样例 #2

### 输入

```
to
Did the Ottoman Empire lose its power at that time```

### 输出

```
-1```

# AI分析结果



## 算法分类
字符串处理/模拟

---

## 题解思路与核心难点

### 核心思路
所有题解均采用预处理统一大小写+边界处理的策略，核心难点在于如何正确判断单词的独立匹配。主要分为两类实现方式：
1. **逐个字符匹配法**（如 suxy15）：通过双指针逐字符比对，维护单词起始标志（前导空格或开头），时间复杂度 O(n)
2. **字符串包裹法**（如 Jelly_Goat）：在单词和文章前后添加空格，利用标准库函数查找子串，时间复杂度 O(n*m)

### 解决难点
- **边界处理**：通过判断前导空格（或文章开头）和后置空格（或文章结尾）确保完全匹配
- **性能优化**：利用单词长度≤10的特性，将匹配次数控制在合理范围

---

## 题解评分（≥4星）

### 1. Jelly_Goat（5⭐）
- **亮点**：巧用空格包裹解决边界问题，代码简洁直观
- **代码可读性**：利用 string::find 函数降低理解难度
- **优化点**：预处理统一大小写+包裹空格后直接匹配

### 2. suxy15（4⭐）
- **亮点**：双指针在线处理无需额外存储，内存效率高
- **难点突破**：通过 `s[i-1] == ' ' || j` 处理连续匹配
- **代码复杂度**：条件判断较多，需仔细推导逻辑

### 3. Eason_lyx（4⭐）
- **亮点**：动态分割单词，直观统计次数与位置
- **优化细节**：添加末尾空格确保最后一个单词被处理
- **可读性**：循环内实时拼接单词，逻辑清晰

---

## 最优思路提炼

### 关键技巧
```cpp
// 预处理示例
word = " " + tolower(word) + " ";
text = " " + tolower(text) + " ";
// 匹配逻辑
pos = text.find(word);
while(pos != string::npos) {
    count++;
    pos = text.find(word, pos+1);
}
```

### 实现要点
1. **大小写统一**：使用 `tolower()` 或位运算统一字符
2. **边界包裹**：前后添加空格形成 `" word "` 格式
3. **库函数利用**：使用 `string::find` 简化匹配逻辑

---

## 同类题目推荐
1. P1012 [NOIP1998 提高组] 拼数（字符串处理）
2. P1603 [斯诺登的密码]（单词映射与匹配）
3. P1553 [数字反转]（字符串边界处理）

---

## 可视化设计

### 动画方案
```html
<div id="canvas-container">
  <canvas id="pixel-canvas"></canvas>
  <div class="control-panel">
    <button onclick="togglePlay()">▶/⏸</button>
    <input type="range" id="speed" min="1" max="10" value="5">
  </div>
</div>
<script>
// 初始化8位调色板
const palette = ["#000","#FFF","#F00","#0F0","#00F","#FF0"];

function drawStep() {
  // 绘制当前扫描位置（红色像素块）
  ctx.fillStyle = palette[2];
  ctx.fillRect(currentPos*8, 0, 8, 8);
  
  // 绘制已匹配位置（绿色像素块） 
  matchedPositions.forEach(p => {
    ctx.fillStyle = palette[3];
    ctx.fillRect(p*8, 8, 8, 8);
  });
}
</script>
```

### 交互特性
- **像素风格**：8x8 像素块表示每个字符位置
- **状态标记**：
  - 红色：当前扫描位置
  - 绿色：已匹配成功位置
- **音效反馈**：匹配成功时播放 8-bit 上升音阶

---

## 核心代码（Jelly_Goat 优化版）

```cpp
#include <iostream>
#include <string>
using namespace std;

string format(string s) {
    for(auto &c : s) c = tolower(c);
    return ' ' + s + ' ';
}

int main() {
    string word, text;
    getline(cin, word);
    getline(cin, text);
    
    word = format(word);
    text = format(text);
    
    int pos = text.find(word), cnt = 0, first = -1;
    while(pos != string::npos) {
        if(first == -1) first = pos - 1; // 去除添加的首空格
        cnt++;
        pos = text.find(word, pos + 1);
    }
    
    if(cnt) cout << cnt << " " << max(first, 0);
    else cout << -1;
}
```

---
处理用时：60.78秒
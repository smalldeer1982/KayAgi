# 题目信息

# 单词分类

## 题目描述

Oliver 为了学好英语决定苦背单词，但很快他发现要直接记住杂乱无章的单词非常困难，他决定对单词进行分类。

两个单词可以分为一类当且仅当组成这两个单词的各个字母的数量均相等。

例如 $\verb!AABAC!$，它和 $\verb!CBAAA!$ 就可以归为一类，而和 $\verb!AAABB!$ 就不是一类。

现在Oliver有 $N$ 个单词，所有单词均由大写字母组成，每个单词的长度不超过 $100$。你要告诉 Oliver 这些单词会被分成几类。


## 说明/提示

- 对于 $70\%$ 的数据满足 $1\le N \le 100$；
- 对于 $100\%$ 的数据满足 $1\le N \le 10000$。

## 样例 #1

### 输入

```
3 
AABAC 
CBAAA 
AAABB```

### 输出

```
2```

# AI分析结果



# 算法分类  
**哈希表/排序**

---

## 题解思路与算法要点  
所有题解核心思路：将每个单词的字符按字母顺序重新排列，使同类单词变为相同字符串，通过统计不同字符串数量得到分类数。  

### 核心难点与解决  
1. **特征标准化**：  
   - 通过排序将字母数量相同但顺序不同的单词转为统一形式（如 "AABAC" → "AAABC"）  
   - 解决思路：对每个单词调用 `sort()` 进行字符排序  

2. **去重统计**：  
   - 使用哈希结构（`map`、`set`）或全局排序后遍历统计不同元素  
   - 时间复杂度对比：  
     - 排序后插入 `set`：O(N*(M log M + log N))  
     - 全局排序后遍历：O(N*M log M + N log N)  
     - 质数乘积法：O(N*M)（但有哈希冲突风险）  

---

## 题解评分（≥4星）  

### 子谦（5星）  
- **亮点**：代码极简，利用 `map<string, bool>` 直接统计唯一性  
- **核心代码**：  
  ```cpp
  sort(a.begin(), a.end());
  if (!z[a]) sum++;
  ```

### Anguei（5星）  
- **亮点**：STL `set` 自动去重，代码仅需 10 行  
- **核心代码**：  
  ```cpp
  set<string> set;
  set.insert(sort(s));
  cout << set.size();
  ```

### PTC06（4星）  
- **亮点**：两次排序法，无需额外哈希结构，空间效率更高  
- **核心代码**：  
  ```cpp
  sort(s[i].begin(), s[i].end());
  sort(s, s+n);
  for (i=1~n) if (s[i] != s[i-1]) sum++;
  ```

---

## 最优思路提炼  
1. **字符排序标准化**：每个单词排序后作为唯一标识  
2. **哈希结构去重**：利用 `set` 或 `map` 自动去重，时间复杂度与代码简洁性最优  
3. **防溢出技巧**：避免质数乘积法，优先选择稳定无冲突的排序法  

---

## 同类型题目与算法套路  
1. **字母异位词分组**（LeetCode 49）  
2. **字符串哈希问题**（如统计唯一指纹）  
3. **特征压缩问题**（如将多维特征转为唯一标量）  

---

## 推荐题目  
1. [P1918 拼数](https://www.luogu.com.cn/problem/P1012)（字符串排序特征）  
2. [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)（字符串模式匹配）  
3. [P1102 A-B数对](https://www.luogu.com.cn/problem/P1102)（哈希统计频率）  

---

## 可视化算法演示设计  

### 动画方案（像素风格）  
1. **输入阶段**：  
   - 每个单词以乱序字符块形式进入画面（如 `AABAC` → 红、红、蓝、红、绿块）  
   - 触发排序音效（8-bit "blip"）后，字符块按字母顺序排列（红×3、蓝、绿）  

2. **去重阶段**：  
   - 标准化后的字符串以发光方块形式存入右侧网格（不同类用不同颜色）  
   - 若检测到重复，播放短促失败音效，方块闪烁后消失  

3. **统计阶段**：  
   - 最终不同颜色的方块数量即为答案，以像素数字弹出  

### 交互设计  
- **步进控制**：可暂停观察排序过程，按空格单步执行  
- **音效反馈**：  
  - 排序成功：中音阶 "beep"  
  - 发现新类：高音阶 "ping"  
  - 重复类：低音阶 "buzz"  

---

## 关键代码片段  
```cpp
// 使用 set 的最简实现
#include <algorithm>
#include <set>
using namespace std;

int main() {
    set<string> unique_words;
    string s;
    int n;
    cin >> n;
    while (n--) {
        cin >> s;
        sort(s.begin(), s.end());
        unique_words.insert(s);
    }
    cout << unique_words.size();
}
```

---

## 个人心得摘录  
> "质数乘积法看似巧妙，但遇到长单词时必定溢出。排序法虽然多了 log M，但稳定可靠。" —— 徐熙凯题解评论区  

> "两次排序法让我意识到：全局有序性可以替代哈希表，这是空间换时间的经典案例。" —— PTC06 题解注释

---
处理用时：68.41秒
# 题目信息

# [BJWC2018] 售票

## 题目描述

C 市火车站最近出现了一种新式自动售票机。买票时，乘客要先在售票机上输入终点名称。一共有 $N$ 处目的地，随着乘客按顺序输入终点名称的每个字母，候选终点站数目会逐渐减少。

在自动售票机屏幕上，有一个 $4$ 行 $8$ 列的键盘，如下图所示。

![](https://cdn.luogu.com.cn/upload/pic/17861.png)

在乘客每输入一个字母后，键盘上只有有效字符是可选的（取决于还有哪些候选终点站），其余的字母会被字符 `*` 取代。

告诉你 $N$ 处目的地的名称，以及乘客已经输入的若干字符，请你输出键盘目前的状态。

## 说明/提示

**【样例解释】**

输入 `ZA` 以后，下一个字符可能是 `G`（终点站有可能是 `ZAGREB`），或 `D`（终点站有可能是 `ZADAR`），或 `B`（终点站有可能是 `ZABOK`）。

## 样例 #1

### 输入

```
4
ZAGREB
SISAK
ZADAR
ZABOK
ZA```

### 输出

```
****B*D*
*G******
********
********```

# AI分析结果



# 算法分类
**字符串处理**

---

# 题解思路与核心难点

## 核心逻辑
1. **候选站筛选**：通过已输入的字符串前缀匹配所有可能的目的地
2. **键盘映射**：将候选站的下一个有效字符映射到 4x8 键盘的特定位置
3. **输出优化**：将键盘状态预初始化为全`*`，仅修改有效字符位置

## 解决难点
- **前缀匹配**：需快速判断字符串是否以给定前缀开头（`strncmp`/`substr`/`find`）
- **坐标转换**：字母`A-Z`需转换为 4x8 键盘坐标（需处理键盘前三格与后三格的特殊布局）
- **状态压缩**：使用一维数组或字符串模拟键盘，避免二维数组操作

---

# 题解评分（≥4星）

| 题解作者       | 评分 | 核心亮点                                                                 |
|----------------|------|--------------------------------------------------------------------------|
| 引领天下       | ★★★★★ | 使用`strncmp`实现高效前缀匹配，键盘映射公式简洁，代码最短（仅14行）       |
| Blue_wonders   | ★★★★☆ | 使用标记数组逐层筛选候选站，逻辑清晰易理解，适合教学演示                 |
| 孤_独         | ★★★★☆ | 利用`substr`实现前缀匹配，代码结构清晰，注释详细                         |

---

# 最优思路提炼

## 关键技巧
1. **键盘坐标公式**：
   ```cpp
   // 将字符映射到预初始化的 32 位字符串（偏移+3处理前三格）
   index = c - 'A' + 3
   row = index / 8, col = index % 8
   ```
2. **高效前缀匹配**：
   ```cpp
   // 方法1：strncmp(p, a[i], l)
   if (!strncmp(a[i], s, prefix_len)) { ... }

   // 方法2：string::substr
   if (dest.substr(0, prefix_len) == input_str) { ... }
   ```

## 代码片段
```cpp
// 引领天下题解核心片段
char k[] = "********\n********\n********\n********";
for (每个候选站) {
  if (strncmp匹配成功) {
    char c = 下一个字符;
    k[c-'A'+3] = c; // 直接修改预初始化字符串
  }
}
puts(k); // 一次性输出
```

---

# 相似题目推荐
1. **P1012 [NOIP1998 提高组] 拼数**（字符串前缀排序）
2. **P1308 [NOIP2011 普及组] 统计单词数**（字符串模式匹配）
3. **P1765 手机**（键盘字符映射）

---

# 可视化设计

## 动画演示方案
1. **键盘像素画**：
   ```javascript
   // 8位风格键盘初始化（Canvas绘制）
   const keyboard = [
     "***ABCDE", "FGHIJKLM", "NOPQRSTU", "VWXYZ***"
   ];
   ```
   ![Pixel Keyboard](data:image/png;base64,...)

2. **动态筛选过程**：
   - **步骤1**：显示输入字符串逐步增长（像素字体逐字符显示）
   - **步骤2**：候选站列表高亮匹配项（红框标记有效项）
   - **步骤3**：有效字符在键盘上闪烁三次后保留，其他变`*`

3. **音效设计**：
   ```javascript
   // Web Audio API 音效
   const playSound = (type) => {
     if (type === 'match') beep(440, 100); // 匹配成功
     if (type === 'update') beep(330, 50); // 键盘更新
   };
   ```

## 交互功能
- **步进控制**：按钮控制输入字符的逐步执行
- **自动播放**：按1x/2x/4x速度自动演示筛选过程
- **错误回放**：当输入导致无候选站时，播放"Game Over"音效

---

# 经典题解代码

## 引领天下（最优解）
```cpp
#include <cstdio>
#include <cstring>
short n,l;
char a[51][101],s[101],k[]={"********\n********\n********\n********"};
int main(void){
    scanf ("%d\n",&n);
    for (short i=0;i<n;i++)scanf ("%s\n",&a[i]);
    scanf ("%s",s),l=strlen(s);
    for (short i=0;i<n;i++)if (!strncmp(a[i],s,l)){
        char c=a[i][l];
        if('A'<=c&&c<='E')k[c-'A'+3]=c;
        if('F'<=c&&c<='M')k[c-'A'+4]=c;
        if('N'<=c&&c<='U')k[c-'A'+5]=c;
        if('V'<=c&&c<='Z')k[c-'A'+6]=c;
    }
    puts(k);
}
```

---

# 总结
本题通过字符串前缀匹配与坐标映射的巧妙结合，展现了如何将实际问题转化为高效代码。最优解利用`strncmp`和预初始化字符串，在保证可读性的同时达到最优时间复杂度 O(N*L)，其中 L 为输入字符串长度。同类问题中，掌握字符串处理与状态压缩技巧至关重要。

---
处理用时：55.59秒
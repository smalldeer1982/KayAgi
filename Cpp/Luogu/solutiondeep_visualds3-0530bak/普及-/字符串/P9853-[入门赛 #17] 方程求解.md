# 题目信息

# [入门赛 #17] 方程求解

## 题目描述

小 A 有 $n$ 个关于 $x$ 的方程，第 $i$ 个方程形如 $a_ix_i+b_i=c_i$。方程的解 $x$ 均为正整数，例如下面几个方程都是符合要求的方程：

```
2x+4=10
-3x+13=10
4x-8=16
```

其中，第一组方程的解为 $x_1=3$，第二组方程的解为 $x_2=1$，第三组方程的解为 $x_3=6$。

小 A 想要知道，给定 $L,R$，在 $L\leq x\leq R$ 的范围内，有多少个正整数 $x$ 满足 $x$ 是其中至少一个方程的解。为了防止你欺骗他，他会询问你 $Q$ 次。

## 说明/提示

**【样例解释】**

对于第一组样例，即为题目中的举例。三组方程的解分别为 $x_1=3,x_2=1,x_3=6$。则：

- 对于 $1\leq x\leq 6$ 的范围，有 $3$ 个 $x$ 的取值（$x=1,3,6$）是其中至少一个方程的解；
- 对于 $1\leq x\leq 8$ 的范围，同上所述；
- 对于 $3\leq x\leq 6$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,6$）是其中至少一个方程的解；
- 对于 $4\leq x\leq 5$ 的范围，不存在一个 $x$ 是其中至少一个方程的解；
- 因此分别输出 $3,3,2,0$。

对于第二组样例，五组方程的解分别为 $x_1=3,x_2=5,x_3=5,x_4=3,x_5=3$。则：

- 对于 $1\leq x\leq 3$ 的范围，只有 $x=3$ 满足是其中至少一个方程的解；
- 对于 $1\leq x\leq 5$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,5$）是其中至少一个方程的解；
- 对于 $3\leq x\leq 5$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,5$）是其中至少一个方程的解；
- 因此分别输出 $1,2,2$。

**【数据范围】**

数据保证，$1\leq n,Q\leq 2\times 10^5$，方程中 $a_i,b_i,c_i$ 满足 $1 \leq |a_i|,|b_i|,|c_i| \leq 10^9$，每一组方程的解 $x_i$ 必定为正整数。询问时的 $L,R$ 满足 $1\leq L\leq R\leq 2\times 10^9$。

本题输入数据较大，请注意代码输入输出的运行效率。

## 样例 #1

### 输入

```
3 4
2x+4=10
-3x+13=10
4x-8=16
1 6
1 8
3 6
4 5```

### 输出

```
3
3
2
0```

## 样例 #2

### 输入

```
5 3
5x-2=13
8x+5=45
4x-12=8
-2x+10=4
3x-7=2
1 3
1 5
3 5```

### 输出

```
1
2
2```

# AI分析结果



## 【唯一算法分类】
排序与二分查找

---

## 【综合分析与结论】

### 核心算法流程
1. **方程解析**：利用 `scanf` 的格式化输入直接提取系数，避免手动处理字符串。
2. **解方程**：通过数学公式 `x = (c - b) / a` 计算每个方程的解。
3. **去重排序**：将所有解存入 `vector`，排序后去重，得到有序唯一解集合。
4. **查询处理**：对每个查询区间 `[L, R]`，使用 `lower_bound` 和 `upper_bound` 快速统计区间内的解数量。

### 解决难点
- **大规模数据高效处理**：通过排序+二分将查询复杂度优化至 `O(Q log n)`。
- **输入解析优化**：利用 `scanf` 的格式化特性直接提取带符号系数，避免字符串分割。
- **去重与空间优化**：使用 `vector` 存储解，排序后去重，减少冗余计算。

### 可视化设计思路
- **动画演示**：Canvas 绘制排序后的解数组，高亮 `L` 和 `R` 的二分查找边界。
- **颜色标记**：绿色表示解元素，红色标记 `lower_bound` 和 `upper_bound` 指针。
- **音效提示**：播放 8-bit 音效表示查询完成，成功统计时播放上扬音调。

---

## 【题解清单 (4星)】

1. **chen_zhe 的题解 (5星)**  
   - **亮点**：简洁使用 `scanf` 解析输入，结合 STL 的 `sort` 和 `unique` 去重，高效二分查询。
   - **代码可读性**：关键逻辑清晰，适合快速实现。
   - **优化程度**：完美处理大数据范围，时间复杂度严格可控。

---

## 【最优思路提炼】

### 关键技巧
1. **格式化输入解析**：利用 `scanf("%dx% d=%d")` 直接提取方程中的符号和数值。
2. **数学公式简化**：解方程直接转换为整数除法，避免浮点误差。
3. **排序去重+二分**：预处理后通过二分快速响应查询，时间复杂度最优。

### 同类型题套路
- **区间统计问题**：预处理为有序数组后，通过二分快速统计区间内元素数量。
- **示例题目**：  
  - 洛谷 P2249（二分查找）  
  - 洛谷 P1102（统计数对）  
  - 洛谷 P1177（快速排序）

---

## 【代码实现】

### 核心逻辑代码
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, Q;
    cin >> n >> Q;

    vector<ll> solutions;
    for (int i = 0; i < n; ++i) {
        ll a, b, c;
        scanf("%lldx% lld=%lld", &a, &b, &c); // 注意空格处理符号
        ll x = (c - b) / a;
        solutions.push_back(x);
    }

    // 排序并去重
    sort(solutions.begin(), solutions.end());
    auto last = unique(solutions.begin(), solutions.end());
    solutions.erase(last, solutions.end());

    // 处理查询
    while (Q--) {
        ll L, R;
        cin >> L >> R;
        auto left = lower_bound(solutions.begin(), solutions.end(), L);
        auto right = upper_bound(solutions.begin(), solutions.end(), R);
        cout << distance(left, right) << '\n';
    }

    return 0;
}
```

---

## 【可视化与复古游戏化设计】

### 算法演示
- **Canvas 绘制**：横向排列排序后的解元素，每个元素用 16x16 像素块表示。
- **交互操作**：输入 `L` 和 `R` 后，绿色光柱标记区间，红色指针动态移动展示二分过程。
- **音效设计**：  
  - `lower_bound` 命中：播放 "哔" 声 (50ms)  
  - 查询完成：播放 8-bit 胜利音效

### 复古风格
- **调色板**：NES 经典 16 色，背景深蓝，元素用亮绿/红。
- **AI 自动演示**：按空格键自动生成随机查询，展示算法流程。

---

## 【个人心得】
- **输入解析陷阱**：`scanf` 中 `%d` 后的空格可跳过符号，避免漏读负号。
- **去重优化**：先排序后 `unique` 比 `set` 更高效，尤其在大数据量时。

---
处理用时：82.08秒
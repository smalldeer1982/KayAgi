# 题目信息

# multiset

## 题目背景

ZHY 有很多集合。集合多了，也就成了多重集合。

## 题目描述

给定一个 **多重集合**（集合中元素可重复）$S$，请求出一个最大的多重集合 $T$，满足 $T$ 是 $S$ 的一个 **真子集**，且对于 $T$ 中的每一个元素 $i$，要么 $i$ 在 $S$ 中没有前驱，要么 $i$ 在 $S$ 中的前驱 $\in T$。若有多个大小相同的集合满足条件，则 $T$ 为所有元素之和最大的一个。请输出 $T$ 的大小和其中元素之和。

---

一个数 $x$ 在一个集合 $S$ 中的前驱的定义为所有在 $S$ 中且 $<x$ 的元素 $y$ 的最大值。

## 说明/提示

**样例 $1$ 解释**

$T$ 为 $\{5,1,4\}$。

**样例 $2$ 解释**

$T$ 为 $\{1,4,2,5,7\}$。

### 数据范围

对于 $30\%$ 的数据，$n \le 15$。

对于 $100\%$ 的数据，$2 \le n \le 10^5$，$1 \le S$ 中的元素 $\le 10^9$。

## 样例 #1

### 输入

```
4
4 5 1 4```

### 输出

```
3 10```

## 样例 #2

### 输入

```
6
1 4 2 8 5 7```

### 输出

```
5 19```

# AI分析结果



---

## 算法分类
**贪心 & 排序**

---

## 题解思路、算法要点与解决难点

### 核心思路
1. **问题转化**：通过分析得出，最大真子集的大小必为 `n-1`，只需删除一个元素。
2. **贪心策略**：若要和最大，优先删除最小的重复元素；若无重复则删除最大元素。
3. **前驱条件验证**：删除重复元素不影响前驱链的完整性，删除最大值则无后续依赖。

### 算法步骤
1. **排序**：将原集合升序排列。
2. **寻找删除目标**：遍历寻找第一个重复元素；若不存在，则删除末尾元素。
3. **计算总和**：总和减去被删除元素的值。

### 解决难点
- **正确性证明**：需理解删除重复元素不影响前驱链，且删除最大值不会破坏其他元素的前驱条件。
- **高效实现**：排序后仅需一次遍历即可确定删除目标，时间复杂度 `O(n log n)`。

---

## 题解评分 (≥4星)

### Galex（5星）
- **亮点**：代码简洁，逻辑清晰，直接遍历排序数组找重复或最大值。
- **代码片段**：
  ```cpp
  for (int i = 2; i <= n; i++)
      if (a[i] == a[i - 1] || i == n) {
          sum -= a[i];
          break;
      }
  ```

### Night_sea_64（4星）
- **亮点**：详细分析删除条件，强调前驱链的完整性。
- **代码片段**：
  ```cpp
  bool flag=0;
  for(int i=1;i<=n;i++)
      if(a[i]==a[i-1]) {
          flag=1;
          s-=a[i];
          break;
      }
  ```

### Lovely_Elaina（4星）
- **亮点**：明确分情况讨论，强调“十年OI一场空”的注意事项。
- **代码片段**：
  ```cpp
  del = s[n];
  for(int i=2; i<=n; i++)
      if(s[i-1]==s[i]) { del=s[i]; break; }
  ```

---

## 最优思路或技巧提炼
1. **排序后处理**：升序排序简化重复元素查找。
2. **双重条件合并**：遍历时统一处理重复元素和最大值（`i == n` 时删除末尾）。
3. **Long Long防御**：总和可能超过 `int` 范围，强制使用 `long long`。

---

## 同类型题或类似算法套路
- **删除特定元素优化总和**：如「删除k个数字使剩余数最大」。
- **贪心策略结合排序**：如区间调度、任务分配问题。

---

## 推荐洛谷题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（贪心+优先队列）
2. [P1223 排队接水](https://www.luogu.com.cn/problem/P1223)（排序+贪心）
3. [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)（贪心删除特定元素）

---

## 个人心得摘录
- **调试教训**：未开 `long long` 导致50分（Lovely_Elaina）。
- **顿悟瞬间**：发现删除重复元素不影响前驱链（hycqwq）。

---

## 可视化与算法演示

### 核心流程动画设计
1. **排序可视化**：展示数组升序排列过程，用不同颜色标记重复元素。
2. **遍历扫描**：高亮当前检查的元素对（`a[i]` 和 `a[i-1]`），若重复则触发红色闪烁。
3. **删除操作**：被删除元素变为灰色并下沉消失，总和动态更新。

### 复古像素风格实现
- **颜色方案**：16色调色板，绿色表示保留元素，红色表示删除目标。
- **音效设计**：
  - **发现重复**：播放8-bit“叮”声。
  - **删除元素**：播放“爆炸”音效。
- **自动演示模式**：AI自动执行排序和扫描，速度可调。

---

## 代码实现（核心逻辑）
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int main() {
    int n; cin >> n;
    vector<int> a(n);
    ll sum = 0;
    for (auto &x : a) cin >> x, sum += x;
    sort(a.begin(), a.end());
    
    ll del = a.back(); // 默认删除最大值
    for (int i = 1; i < n; ++i) {
        if (a[i] == a[i-1]) {
            del = a[i]; // 找到最小重复元素
            break;
        }
    }
    cout << n-1 << " " << sum - del;
}
```

---
处理用时：74.80秒
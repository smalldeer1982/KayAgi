# 题目信息

# [信息与未来 2017] 密码锁

## 题目描述

乌龟给自己的贵重物品上了密码锁。密码锁上有 $5$ 个数字拨盘。每个数字拨盘每次向上拨使数字增加 $1$ （$9$ 向上拨得到 $0$），向下拨使数字减少 $1$ （$0$ 向下拨得到 $9$）。

拨盘上的数字组成一个 $5$ 位数。只要拨盘上的数字变为素数，密码锁就会被解开。素数 (又称质数) 是只能被 $1$ 和它自身整除的大于 $1$ 的自然数。因为乌龟动作实在太慢，他希望你帮他计算如何开锁，使得拨动的总次数最少。

## 说明/提示

>本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
01210```

### 输出

```
01319```

# AI分析结果



---

**算法分类**：枚举（暴力法）

---

### 综合分析与结论  
**核心思路**：枚举所有可能的 5 位数（00000~99999），筛选出素数，计算每个素数对应的拨动次数总和，取最小且数值最小的素数。  
**关键难点**：  
1. **素数判断**：需正确处理前导零，例如 01319 对应数值 1319，仍视为素数。  
2. **拨动次数计算**：每个数字拨动有两种方向，需取最小值（如 0→9 视为向下拨动 1 次）。  
**算法流程**：  
1. 枚举所有可能的 5 位数数值（0~99999）。  
2. 对每个数值判断是否为素数。  
3. 若是素数，转换为 5 位字符串，计算其与初始状态的拨动次数总和。  
4. 维护最小拨动次数及对应的最小素数。  

**可视化设计**：  
- **动画方案**：  
  - 展示密码锁拨盘动态变化，逐位高亮当前比较的数字。  
  - 用颜色区分拨动方向（绿色表示向上，红色表示向下）。  
  - 显示当前枚举的素数和总拨动次数，更新最优解时突出显示。  
- **复古像素风格**：  
  - 使用 8 位像素字体显示密码锁和素数数值。  
  - 背景音乐采用循环的 8 位芯片音效，拨动时播放“滴”声。  
  - 自动演示模式模拟 AI 逐步枚举素数，找到最优解后播放胜利音效。  

---

### 题解清单 (4星)
1. **chen_zhe 的题解（4星）**  
   - **亮点**：  
     - 通过字符串补全处理前导零，逻辑简洁。  
     - 拨动次数的计算使用 `min(diff, 10 - diff)` 巧妙实现。  
   - **改进点**：可预生成素数表优化判断速度。  

---

### 核心代码实现  
```cpp
#include <iostream>
#include <string>
using namespace std;

string s; // 初始状态

bool isPrime(int x) {
    if (x < 2) return false;
    for (int i = 2; i * i <= x; ++i)
        if (x % i == 0) return false;
    return true;
}

string to5D(int x) {
    string ans = to_string(x);
    while (ans.size() < 5) ans = "0" + ans;
    return ans;
}

int digD(int x, int y) {
    int diff = abs(x - y);
    return min(diff, 10 - diff);
}

int totD(string x) {
    int ans = 0;
    for (int i = 0; i < 5; ++i)
        ans += digD(x[i] - '0', s[i] - '0');
    return ans;
}

int main() {
    cin >> s;
    int minT = 1e9, bestP = -1;
    for (int i = 2; i < 100000; ++i) {
        if (isPrime(i)) {
            string num = to5D(i);
            int dist = totD(num);
            if (dist < minT || (dist == minT && i < bestP)) {
                minT = dist;
                bestP = i;
            }
        }
    }
    cout << to5D(bestP) << endl;
    return 0;
}
```

---

### 最优思路提炼  
1. **枚举与筛选**：暴力枚举所有可能状态，通过条件过滤（素数）缩小解空间。  
2. **拨动方向优化**：利用环状结构特性（0↔9），计算最小拨动次数。  
3. **字符串处理**：补全前导零统一计算位数，避免复杂分情况讨论。  

---

### 类似题目推荐  
1. **P1036 选数**：枚举子集求和判断素数。  
2. **P1217 回文质数**：结合回文与素数特性枚举。  
3. **P2693 钟表调时**：计算钟表拨动最小次数。  

---

### 个人心得摘录  
> “通过将数值转换为字符串处理前导零，极大简化了逐位比较的代码复杂度。” —— 调试中发现直接操作整数取位易出错，改用字符串后逻辑清晰。  

---

### 可视化与复古风格实现要点  
1. **Canvas 绘制**：  
   - 用 32x32 像素块绘制 5 个拨盘，初始状态显示红色，目标素数显示绿色。  
   - 每次枚举素数时，高亮当前数值，并动态绘制拨动路径。  
2. **音效设计**：  
   - 拨动时播放 `beep` 声，素数判定失败播放低沉音，成功时播放 `victory.wav`。  
3. **自动演示 AI**：  
   - 模拟快速枚举，每 100 次检查后暂停 0.1 秒更新界面，找到最优解后慢速回放关键步骤。

---
处理用时：150.44秒
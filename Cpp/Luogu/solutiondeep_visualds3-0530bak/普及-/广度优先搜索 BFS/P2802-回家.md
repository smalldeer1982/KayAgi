# 题目信息

# 回家

## 题目描述

[](https://paste.ubuntu.com/p/DSg5bzrrjs/)

小 H 在一个划分成了 $n \times m$ 个方格的长方形封锁线上。 每次他能向上下左右四个方向移动一格（当然小 H 不可以静止不动）， 但不能离开封锁线，否则就被打死了。 刚开始时他有满血 $6$ 点，每移动一格他要消耗 $1$ 点血量。一旦小 H 的血量降到 $0$， 他将死去。 他可以沿路通过拾取鼠标（什么鬼。。。）来补满血量。只要他走到有鼠标的格子，他不需要任何时间即可拾取。格子上的鼠标可以瞬间补满，所以每次经过这个格子都有鼠标。就算到了某个有鼠标的格子才死去， 他也不能通过拾取鼠标补满 HP。 即使在家门口死去， 他也不能算完成任务回到家中。

地图上有五种格子：

`0`：障碍物。

`1`：空地， 小 H 可以自由行走。

`2`：小 H 出发点， 也是一片空地。

`3`：小 H 的家。

`4`：有鼠标在上面的空地。

小 H 能否安全回家？如果能， 最短需要多长时间呢？


## 说明/提示

对于所有数据，$1 \le n,m \le 9$。

2021.9.2 增添一组 hack 数据 by @囧仙

## 样例 #1

### 输入

```
3 3
2 1 1
1 1 0
1 1 3```

### 输出

```
4```

# AI分析结果



## 唯一算法分类
**广度优先搜索（BFS）**

---

## 综合分析与结论
### 核心思路与难点
1. **状态设计**：每个状态需包含坐标 `(x,y)`、步数 `step`、剩余血量 `hp`。血量的存在使得同一位置在不同状态下可能产生不同后续路径。
2. **判重优化**：使用三维数组 `visited[x][y][hp]` 记录每个位置在不同血量下的最优状态。若新到达该位置的血量 ≤ 已记录的最大血量，则剪枝（因为此时新状态的后续路径不可能更优）。
3. **鼠标处理**：遇到鼠标格子时，直接重置血量为满值 `6`，并将该状态加入队列。

### 算法流程
1. **初始化**：将起点加入队列，初始血量为 `6`。
2. **状态扩展**：每次从队列取出一个状态，向四个方向扩展：
   - 若目标格子是障碍或血量归零则跳过。
   - 若目标格子是家，直接返回当前步数。
   - 若目标格子是鼠标，重置血量。
3. **状态判重**：仅当新状态的 `hp` 大于该位置历史最大血量时才加入队列。

### 可视化设计
- **动画风格**：采用 8-bit 像素风格，迷宫用网格表示，不同格子类型（障碍、空地、家、鼠标）用不同颜色区分。
- **关键高亮**：
  - 当前处理状态用闪烁边框标记。
  - 血量变化时，用颜色渐变（如绿色→黄色→红色）表示血量衰减。
- **音效**：
  - 移动时播放「滴」声。
  - 找到家时播放胜利音效。
  - 血量归零时播放失败音效。

---

## 题解评分（≥4星）
1. **KesdiaelKen（BFS）** ★★★★☆  
   - 亮点：引入贪心判重思想，通过 `visited` 数组记录最大血量，避免无效状态。
2. **BurningEnderDragon（BFS）** ★★★★☆  
   - 亮点：清晰的结构体设计，详细注释说明状态扩展逻辑。
3. **囧仙（BFS）** ★★★★★  
   - 亮点：出题人官方解法，代码简洁高效，状态处理直接使用 `tuple` 和队列。

---

## 最优思路提炼
### 关键代码（C++）
```cpp
struct Node { int x, y, step, hp; };
queue<Node> q;
int visited[MAXN][MAXN][7]; // visited[x][y][hp]

q.push({sx, sy, 0, 6});
visited[sx][sy][6] = 1;

while (!q.empty()) {
    auto [x, y, step, hp] = q.front(); q.pop();
    if (grid[x][y] == 3) return step;
    for (int d = 0; d < 4; d++) {
        int nx = x + dx[d], ny = y + dy[d];
        int nhp = (grid[nx][ny] == 4) ? 6 : hp - 1;
        if (nhp <= 0 || visited[nx][ny][nhp]) continue;
        visited[nx][ny][nhp] = 1;
        q.push({nx, ny, step + 1, nhp});
    }
}
```

---

## 同类型题与算法套路
1. **状态扩展型 BFS**：适用于迷宫问题中需要额外状态（如血量、钥匙、方向等）的场景。
2. **贪心判重**：通过记录最优子状态（如最大血量、最短步数）避免重复搜索。

---

## 推荐题目
1. **P4017 逃离迷宫**：需携带钥匙通过迷宫。
2. **P1443 马的遍历**：基础 BFS，求最短步数。
3. **P1162 填涂颜色**：BFS 用于连通区域标记。

---

## 个人心得摘录
- **Jameswood**：多次调试发现步数上限错误，强调「血量恢复时机必须在移动后处理」。
- **大头冲锋车**：通过限制格子访问次数避免死循环，虽非严谨但实用。

---

## 可视化与复古效果实现
### Canvas 绘制逻辑
```javascript
// 伪代码：绘制迷宫与状态
function drawGrid() {
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      const color = getColorByGridType(grid[i][j]);
      ctx.fillStyle = color;
      ctx.fillRect(j * 32, i * 32, 32, 32);
    }
  }
}

// 更新当前状态
function updateState(x, y, hp) {
  ctx.fillStyle = 'rgba(255, 255, 0, 0.5)'; // 高亮当前格子
  ctx.fillRect(y * 32, x * 32, 32, 32);
  playSound('move'); // 播放移动音效
}
```

### 自动演示模式
```javascript
let autoPlay = setInterval(() => {
  if (q.empty()) {
    clearInterval(autoPlay);
    playSound('fail');
  }
  processNextState();
}, 500); // 每 500ms 执行一步
```

---
处理用时：77.59秒
# 题目信息

# [CERC2013] Draughts

## 题目描述

国际跳棋（或称跳棋）是一种由两个对手在 $10 \times 10$ 的棋盘上进行的游戏。棋盘上的方块是黑色或白色的，就像经典的国际象棋棋盘一样。玩家一方控制黑棋，另一方控制白棋。棋子只能占据黑色的格子。棋手们交替走棋，各自移动自己的一个棋子。

最有趣的走法是吃掉：如果一个对角线相邻的格子里有对手的棋子，可以通过跳过它到紧挨着它的未被占领的格子来吃掉（并从游戏中删除被吃掉的这个棋子）。允许在一步棋中用一个棋子连续吃掉几个棋子。通过向前或向后的跳跃来吃子也是合法的。

你会得到一个棋子的位置。现在轮到白方了。计算他在下一步棋中能吃掉的最大可能的黑棋数量。

## 样例 #1

### 输入

```
2

.#.#.#.#.#
#.#.#.#.#.
.#.#.B.#.#
#.#.#.#.#.
.#.#.B.#.#
#.#.W.#.#.
.#.#.#.#.#
#.#.#.B.#.
.#.#.#.#.#
#.#.#.#.#.

.#.#.#.#.#
#.#.#.#.#.
.#.#.B.#.#
#.B.#.B.#.
.#.#.B.#.#
#.B.W.#.#.
.#.B.B.#.#
#.#.#.#.#.
.#.B.B.#.#
#.#.#.#.#.
```

### 输出

```
2
4
```

# AI分析结果



### 算法分类
DFS + 回溯

---

### 综合分析与结论
**核心思路**：对每个白棋进行深度优先搜索，向四个对角线方向尝试连续跳跃吃子，维护最大吃子数。每次跳跃需修改棋盘状态（吃掉黑棋、移动白棋），递归后必须回溯状态。

**核心难点与解决方案**：
1. **连续跳跃判断**：每次跳跃后要立即递归判断能否继续跳跃，实现路径穷举
2. **棋盘状态管理**：移动白棋时需临时清空原位置，避免阻碍后续跳跃判断
3. **方向处理**：四个对角线方向（左上/右上/左下/右下）需独立处理边界条件
4. **多起点处理**：棋盘可能存在多个白棋，需独立计算每个棋子的最大吃子数

**可视化设计**：
- **棋盘动画**：在10x10网格中，用不同颜色区分白棋（白色）、黑棋（黑色）、可跳跃路径（黄色高亮）
- **跳跃过程**：
  - 高亮当前白棋 → 显示候选跳跃方向 → 吃掉黑棋时触发粒子动画
  - 连续跳跃时用箭头连接路径
- **回溯演示**：用半透明残影显示状态恢复过程
- **像素风格**：
  - 8-bit音效：跳跃时播放"jump.wav"，吃子时播放"coin.wav"
  - 棋盘格使用NES经典绿灰配色（#77C255 / #4E792A）

---

### 题解清单（4★+）

1. **David_yang（4.5★）**
   - 亮点：严格的状态回溯（恢复3个格子），清晰的边界条件判断
   - 代码技巧：将方向数组拆分为单步（dx=±1）与跳跃步（dx=±2）

2. **Tjaweiof（4★）**
   - 亮点：通过临时清空白棋位置避免自阻碍
   - 教训：原文提到因忘记恢复白棋位置调试多日

3. **Alystkia（4★）**
   - 亮点：增量数组设计巧妙（dx[i]与dx[i]*2复用）
   - 可视化友好：状态修改逻辑集中，便于动画演示

---

### 核心代码实现
```cpp
// 方向数组：四个对角线的单步与跳跃步
const int dx[] = {-1, -1, 1, 1};
const int dy[] = {1, -1, 1, -1};

void dfs(int x, int y, int cnt) {
    max_eat = max(max_eat, cnt); // 维护最大值
    for (int i = 0; i < 4; i++) {
        int mid_x = x + dx[i];   // 中间黑棋坐标
        int mid_y = y + dy[i];
        int end_x = x + 2*dx[i]; // 跳跃终点坐标
        int end_y = y + 2*dy[i];
        
        if (边界合法 && 存在可吃黑棋 && 终点为空) {
            // 修改状态：吃黑棋、移动白棋
            board[x][y] = '.';     
            board[mid_x][mid_y] = '.';
            board[end_x][end_y] = 'W';
            
            dfs(end_x, end_y, cnt + 1); // 递归
            
            // 回溯状态
            board[x][y] = 'W';
            board[mid_x][mid_y] = 'B';
            board[end_x][end_y] = '.';
        }
    }
}
```

---

### 相似题目推荐
1. **P1219 [USACO1.5] 八皇后** - 经典回溯问题
2. **P1443 马的遍历** - 棋盘跳跃路径搜索
3. **P2325 [SCOI2005] 骑士精神** - 带限制条件的跳跃搜索

---

### 调试心得摘录
> "忘记清空白棋位置导致后续跳跃判断受阻，调试三天才意识到需要先`a[i][j]='#'`再恢复" —— Tjaweiof  
> "方向数组设计错误：误将跳跃步写成(2,2)而非(±2,±2)，导致样例2无法通过" —— Genshin_ZFYX

---

### 像素动画JS核心逻辑
```javascript
class JumpChessAnim {
    constructor() {
        this.ctx = canvas.getContext('2d');
        this.sound = {jump: new Audio('jump.wav'), eat: new Audio('coin.wav')};
    }

    drawStep(x, y, type) {
        // 绘制像素风格棋子（16x16像素/格）
        const colors = {'W': '#FFF', 'B': '#333', 'path': '#FF0'};
        this.ctx.fillStyle = colors[type];
        this.ctx.fillRect(x*16, y*16, 16, 16);
    }

    async animateJump(start, mid, end) {
        this.drawStep(mid[0], mid[1], 'path'); // 高亮被吃棋子
        this.sound.eat.play();
        await new Promise(r => setTimeout(r, 200)); // 200ms动画间隔
        this.drawStep(start[0], start[1], '.');    // 清空起点
        this.drawStep(end[0], end[1], 'W');        // 绘制终点
    }
}
```

---

### 交互设计
- **WASD** 控制单步调试速度（1x/2x/4x）
- **空格键** 暂停/继续自动演示
- **Q/E** 切换不同题解的算法实现对比
- 成功找到最大吃子数时，播放《超级马里奥》过关音乐片段

---
处理用时：78.90秒
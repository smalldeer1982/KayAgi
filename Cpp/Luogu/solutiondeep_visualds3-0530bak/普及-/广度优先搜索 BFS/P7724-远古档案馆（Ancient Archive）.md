# 题目信息

# 远古档案馆（Ancient Archive）

## 题目背景

为了揭开月光能量背后的秘密，你来到了地下的远古档案馆。

远古一族的秘密与遗忘的知识悉数贮藏于这片被尘封的迷宫中，你能成功解谜，获知远古的知识吗？


## 题目描述

远古档案馆的中心是一个解谜：

- 有一个 $2\times 2$ 的网格，每个格子中要么有一个正整数，要么是空的；

- 你可以进行若干次操作：每次操作中，你选择一个**有正整数的格子**和一个**与之相邻的空格子**，将正整数移到那个空格子中；

- 给定网格的初始状态和最终状态，保证初始状态和最终状态中包含的正整数个数相同（设为 $k$ 个），且它们就是前 $k$ 个不同的正整数，问是否可以通过有限次操作从初始状态到达最终状态？

下图展示了一个包含三个正整数的网格经过两次操作的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/y2dnr4ss.png)

只有完成解谜，才能获得遗忘的知识，因此你希望尽快解决这个问题。

**注意：网格中可能没有正整数，也可能没有空格。**

## 说明/提示

**【样例 1 解释】**

如题目描述中图所示。

---

**【样例 2 解释】**

没有可移动的正整数，所以无法从初始状态到达与之不相等的最终状态。

---

**【数据范围】**

**本题采用捆绑测试。**

所有数据符合题目描述所述。

- Subtask 1（40 points）：不存在空格。
- Subtask 2（60 points）：无特殊限制。

---

![](https://cdn.luogu.com.cn/upload/image_hosting/rz2eg0ca.png)

## 样例 #1

### 输入

```
2 1
3 0
0 2
3 1
```

### 输出

```
Yes
```

## 样例 #2

### 输入

```
2 1
4 3
3 4
2 1
```

### 输出

```
No
```

# AI分析结果



## 算法分类
状态可达性分析（BFS/DFS）与规律观察（环结构判断）

---

## 题解思路与核心难点

### 核心思路
1. **无空格情况**：直接比较初始状态与最终状态是否完全相同。
2. **≥2空格**：总能通过移动调整到任意状态，直接返回 `Yes`。
3. **单空格情况**：
   - **暴力搜索**：通过 BFS/DFS 遍历所有可达状态。
   - **环结构判断**：将非空数字按顺时针/逆时针顺序展开为环，若初始环与目标环循环同构则可达。

### 解决难点
- **单空格状态限制**：数字只能围绕空格旋转，导致排列顺序必须满足循环同构。
- **高效判断**：暴力搜索需状态压缩与去重，环结构判断需处理循环展开逻辑。

---

## 题解评分（≥4星）

1. **封禁用户（4星）**  
   - **亮点**：全面覆盖所有情况，通过分类讨论直接判断可达性，时间复杂度 O(1)。  
   - **缺点**：代码复杂，边界条件较多。

2. **红尘仙（5星）**  
   - **亮点**：巧妙利用环结构循环同构的特性，代码简洁高效。  
   - **心得**：“将数字序列展开为环并判断循环同构”是核心创新点。

3. **_caiji_（5星）**  
   - **亮点**：BFS 结合状态压缩哈希，正确性高且实现简洁。  
   - **优化**：四位数压缩状态避免 MLE/TLE。

---

## 最优思路提炼

### 环结构判断（红尘仙）
- **核心代码**：
  ```cpp
  // 按顺时针提取非空数字
  for (int i=1; i<=2; i++) 
    for (int j=1; j<=2; j++) 
      if (i%2) s1[++tot1] = a[i][j]; 
      else s1[++tot1] = a[i][3-j];  // 第二行逆序取数

  // 扩展为双倍序列判断循环同构
  for (int i=1; i<=tot1; i++) s1[i+tot1] = s1[i];
  if (strstr(s1_str, s2_str)) return Yes;
  ```

### BFS 状态压缩（_caiji_）
- **核心代码**：
  ```cpp
  struct node { int a[3][3]; };
  operator int() { // 四位数压缩状态
    return a[1][1]*1 + a[1][2]*10 + a[2][1]*100 + a[2][2]*1000;
  }

  bool bfs() {
    queue<node> q; q.push(begin);
    while (!q.empty()) {
      node now = q.front(); q.pop();
      if (now == end) return true;
      for (空格移动逻辑...) { // 扩展相邻状态
        node pus = now; swap(pus.a[i][j], pus.a[x][y]);
        if (!vis[pus]) { vis[pus] = 1; q.push(pus); }
      }
    }
    return false;
  }
  ```

---

## 同类型题与算法套路

### 类似问题
- **华容道变种**：如 8-puzzle 问题，通过移动空格重组数字。
- **环结构判断**：序列循环匹配问题（如字符串旋转匹配）。

### 通用解法
- **状态可达性**：小规模状态直接 BFS/DFS，大规模状态观察规律。
- **环展开技巧**：将线性序列视为环形结构处理循环同构。

---

## 推荐题目
1. **P1379 八数码难题**（华容道经典 BFS）  
2. **P2730 魔板 Magic Squares**（状态压缩与 BFS）  
3. **P1960 护林员（环结构判断）**

---

## 可视化与算法演示

### 动画方案设计
1. **网格状态更新**：  
   - **Canvas 绘制**：每个格子用不同颜色区分数字和空格。  
   - **高亮移动**：用闪烁边框标记当前移动的数字和空格。

2. **环结构演示**：  
   - **环形动画**：将非空数字排列成环，展示循环展开过程。  
   - **匹配过程**：动态对比初始环与目标环的循环展开结果。

3. **复古像素风格**：  
   - **8-bit 调色板**：使用经典 FC 红、蓝、绿、黄像素色块。  
   - **音效**：移动时播放“哔”声，匹配成功播放胜利音效。

### 交互设计
- **步进控制**：允许单步执行移动或自动播放。  
- **状态追踪**：侧边栏显示已访问状态哈希值列表。

---

## 个人心得摘录
- **红尘仙**：“将数字序列视为环结构可避免复杂移动模拟，直接判断本质特征。”  
- **封禁用户**：“分类讨论需覆盖所有特殊排列，调试时需构造极端测试用例。”  
- **_caiji_**：“四位数压缩法在网格类问题中极具普适性，可推广至 3x3 等小规模状态。”

---
处理用时：84.93秒
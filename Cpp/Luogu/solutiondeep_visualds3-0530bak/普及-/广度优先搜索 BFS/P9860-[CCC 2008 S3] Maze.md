# 题目信息

# [CCC 2008 S3] Maze

## 题目描述

为了赚点钱，你决定参与一个科学实验。你会被喂很多披萨，然后再吃更多的披萨，接着你需要骑着一辆仅靠披萨驱动的滑板车穿越城市。当然，城市里有很多交叉路口，这些路口受到严格控制。有些路口是禁止进入的；有些只允许你在离开路口时向北或向南移动；有些只允许你在离开路口时向东或向西移动；剩下的则允许你朝任意方向（北、南、东或西）移动。

幸运的是，你的科学朋友给了你一张城市地图（在一个披萨盒的背面），上面用一些符号表示你可以如何在城市中移动。具体来说，盒子上有 4 种不同的符号：

- 符号 `+` 表示我们可以从这个位置向任意方向（北/南/东/西）移动。
- 符号 `-` 表示我们只能从这个位置向东或向西移动。
- 符号 `|` 表示我们只能从这个位置向北或向南移动。
- 符号 `*` 表示我们不能占据这个位置。

你的任务是确定从城市的西北角移动到东南角需要经过多少个交叉路口。

## 说明/提示

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
3
2
2
-|
*+
3
5
+||*+
+++|+
**--+
2
3
+*+
+*+
```

### 输出

```
3
7
-1```

# AI分析结果



---

## 算法分类
广度优先搜索（BFS）

---

## 综合分析与结论
### 核心思路
所有题解均采用 BFS 算法，核心难点在于**根据当前网格符号限制移动方向**。关键在于：
1. 起点/终点为 `*` 时直接返回 -1
2. 对 `|` 符号只允许上下移动，`-` 符号只允许左右移动
3. 使用队列逐层扩展，保证首次到达终点时步数最小

### 可视化设计要点
1. **动画方案**：以网格形式展示迷宫，不同符号用颜色区分（如红色代表 `*`，绿色代表 `+`）
2. **动态扩展**：当前处理的网格用黄色高亮，已访问的网格用半透明覆盖
3. **方向箭头**：根据符号显示可移动方向（如 `|` 显示↑↓箭头）
4. **复古效果**：采用 8-bit 像素风格，移动时播放「滴」声效，找到路径时播放「胜利」音效

---

## 题解清单 (4星题解)

### 题解作者：zhuweiqi（⭐⭐⭐⭐）
**亮点**：
- 使用标准 BFS 模板，代码简洁清晰
- 通过 `i=0,j=2` 等技巧快速限制方向范围
- 使用 STL 队列，符合 C++ 最佳实践

---

## 最优思路与技巧提炼
### 关键代码实现
```cpp
// 方向限制处理核心逻辑
if(a[x][y]=='|') i=0,j=2;     // 只处理上下方向（dir[0]和dir[1]）
if(a[x][y]=='-') i=2,j=4;     // 只处理左右方向（dir[2]和dir[3]）
for(;i<j;i++) {                // 遍历允许的方向
    int nx = x + dir[i][0];
    int ny = y + dir[i][1];
    // 边界检查与步数更新...
}
```

### 核心技巧
1. **方向数组优化**：通过预定义 `dir[4][2]` 简化方向计算
2. **符号映射技巧**：用 `i/j` 范围控制可移动方向，避免冗余条件判断
3. **步数初始化**：`f[1][1] = 1` 正确处理题目要求的初始步数计算

---

## 同类型题目推荐
1. **P1141 01迷宫**：BFS + 连通块统计
2. **P1443 马的遍历**：八方向 BFS + 步数记录
3. **P1747 好奇怪的游戏**：双层 BFS + 优先级队列

---

## 可视化实现思路
```javascript
// 伪代码：BFS 动画核心逻辑
class MazeVisualizer {
  constructor(canvas) {
    this.grid = [/* 迷宫数据 */];
    this.queue = [[0,0]]; // 起点入队
    this.steps = 1;
    
    // 8-bit 调色板
    this.colors = {
      '+': '#00FF00', '-': '#FFA500',
      '|': '#0000FF', '*': '#FF0000'
    };
  }

  drawStep() {
    // 绘制当前状态
    let [x,y] = this.queue.shift();
    this.highlightCell(x, y); // 黄色高亮当前处理网格
    
    // 根据符号计算可移动方向
    const dirs = this.getValidDirections(x, y);
    
    // 遍历所有可行方向
    dirs.forEach(([dx, dy]) => {
      const nx = x + dx, ny = y + dy;
      if(this.isValid(nx, ny)) {
        this.queue.push([nx, ny]);
        this.updateStepCount(nx, ny); 
        this.playSound('move'); // 移动音效
      }
    });
  }
}
```

---

## 个人心得摘录
> "当全图只有一个数时直接输出一，这个边界条件容易被忽略。多测必须清空队列和 vis 数组，否则会 WA 到怀疑人生。" —— 来自题解二的调试经验

---

## 关键题解代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
char a[22][22];
int f[22][22];
queue<pair<int,int>> q;
int dir[4][2]={{-1,0},{1,0},{0,-1},{0,1}};

void bfs(){
  memset(f,-1,sizeof(f));
  f[1][1]=1;
  q.push({1,1});
  while(!q.empty()){
    auto [x,y] = q.front(); q.pop();
    
    int i=0, j=4; // 默认处理所有方向
    if(a[x][y]=='|') i=0,j=2;  // 上下
    else if(a[x][y]=='-') i=2,j=4; // 左右
    
    for(;i<j;i++){
      int nx=x+dir[i][0], ny=y+dir[i][1];
      if(nx>=1 && nx<=n && ny>=1 && ny<=m 
         && f[nx][ny]==-1 && a[nx][ny]!='*'){
        f[nx][ny] = f[x][y]+1;
        q.push({nx, ny});
      }
    }
  }
}
```

---
处理用时：70.28秒
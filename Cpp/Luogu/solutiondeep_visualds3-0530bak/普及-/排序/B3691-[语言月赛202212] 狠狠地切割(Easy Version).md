# 题目信息

# [语言月赛202212] 狠狠地切割(Easy Version)

## 题目描述

现给你一个长度为 $n$ 的序列 $a _ 1, \cdots, a _ n$ 和 $m$ 个互不相同的整数 $b _ 1, \cdots, b _ m$。你需要按照这 $m$ 个数对序列 $a$ 进行**狠狠地切割**。

具体的，对于一个数字 $i \in [1, n]$，如果存在一个整数 $j \in [1, m]$，使得 $a _ i = b _ j$，则将位置 $i$ 称为一个**切割点**。对序列 $a$ 中的每一个切割点，我们在这个位置进行一次**狠狠地切割**。方法是，将该位置的数字去除，然后在这个位置将其左右的**序列/片段**一分两半。

如果对**狠狠地切割**的定义有疑问，可以参照「样例 #1」及「样例解释 #1」进行理解。

你需要计算，在进行了所有可能的**狠狠地切割**后，序列被切割为了多少**片段**。

特别的，如果在切割后，某一段内没有数组，那这一段不可被叫做**片段**。同样的，如果 $1$ 或 $n$ 为切割点，其与开头和结尾之间也不存在片段。

如果对**片段**的概念有疑问，可以参照「样例 #2」及「样例解释 #2」进行理解。

## 说明/提示

### 样例 1 解释

在**狠狠地切割**前，序列 $a$ 如下所示：

$$\begin{matrix} 3 & 4 & 3 & 5 & 2 & 6 \end{matrix}$$

容易知道，第二个位置和第四个位置为切割点，我们使用 `|` 对其进行替换，代表去除工作：

$$\begin{matrix} 3 & | & 3 & | & 2 & 6 \end{matrix}$$

我们将片段进行简单的标记：

$$\begin{matrix} \overbrace{3} ^ \text{片段 1} & | & \overbrace{3} ^ \text{片段 2} & | & \overbrace{2 \quad 6} ^ \text{片段 3} \end{matrix}$$

共计 $3$ 个片段。

### 样例 2 解释

以下我们展示去除之后的序列：

$$\begin{matrix} | & 4 & | & | & 2 & | \end{matrix}$$

我们将片段进行简单的标记：

$$\begin{matrix} \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段} | & \overbrace{4} ^ \text{片段 1} & | & \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段} & | & \overbrace{2} ^ \text{片段 2} & | \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段}\end{matrix}$$

共计 $2$ 个片段。

### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n, m \leq 10$。
- 对于 $70\%$ 的数据，保证 $n, m \leq 5 \times 10 ^ 3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 5 \times 10 ^ 5$，$1 \leq a_i,b_i \leq 5 \times 10^{6}$。

### 提示
本题输入规模较大，建议考虑使用较快的读入读出方式。

## 样例 #1

### 输入

```
6 2
3 4 3 5 2 6
5 4```

### 输出

```
3```

## 样例 #2

### 输入

```
6 3
3 4 3 5 2 6
3 5 6```

### 输出

```
2```

# AI分析结果



---

### **唯一算法分类**  
哈希

---

### **综合分析与结论**  
题目要求根据切割点将序列分割为片段。核心在于快速判断元素是否属于切割点集合，并统计有效片段。  
- **核心算法**：利用哈希表（数组标记）快速查询元素是否在切割点集合中。遍历数组时维护连续非切割点的长度，遇到切割点时统计片段。  
- **可视化设计**：用像素方块表示数组元素，切割点高亮为红色。遍历时动态显示当前连续非切割点长度（绿色方块），遇到切割点时触发音效并统计片段。末尾处理剩余片段。  
- **复古风格**：采用8-bit像素风，音效在切割点触发，背景音乐循环播放。自动演示模式展示算法流程，Canvas绘制动态变化。

---

### **题解清单 (≥4星)**  
1. **Maxmilite的题解 (5星)**  
   - **亮点**：详细解析多种实现方法（数组、哈希、排序二分），适用于不同数据范围。代码简洁，逻辑清晰。  
   - **心得**：通过预处理标记切割点，将时间复杂度优化至O(n + m)，适合大规模数据。  

---

### **核心代码实现**  
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

const int MAX_VAL = 5e6 + 10;
bool mark[MAX_VAL]; // 哈希标记数组

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    
    // 读取并标记切割点
    fill(mark, mark + MAX_VAL, false);
    for (int i = 0; i < m; ++i) {
        int x;
        scanf("%d", &x);
        mark[x] = true;
    }
    
    int ans = 0, cnt = 0;
    for (int i = 0; i < n; ++i) {
        int a;
        scanf("%d", &a);
        if (mark[a]) {
            if (cnt > 0) ans++;
            cnt = 0;
        } else {
            cnt++;
        }
    }
    if (cnt > 0) ans++;
    printf("%d\n", ans);
    return 0;
}
```

---

### **同类型题与推荐**  
1. **P1102 A-B数对**：哈希统计差值存在性。  
2. **P1918 保龄球**：快速查找目标分数位置。  
3. **P4305 不重复数字**：哈希去重保留顺序。  

---

### **可视化与算法演示**  
- **动画流程**：  
  1. 初始化切割点标记（红色方块）。  
  2. 遍历数组，非切割点累积绿色长度，切割点触发分割。  
  3. 末尾处理剩余绿色片段。  
- **交互设计**：  
  - 速度调节滑块控制遍历速度。  
  - 音效：切割时播放“切割声”，片段统计时播放“得分音效”。  
  - 复古像素风，Canvas动态更新，AI自动演示可暂停/继续。  

---

**总结**：通过哈希标记快速判断切割点，结合遍历统计片段数，是高效解决本题的核心。复古像素动画与音效增强理解，适合教学演示。

---
处理用时：130.54秒
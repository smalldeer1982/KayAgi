# 题目信息

# [语言月赛 202312] 打表过样例

## 题目背景

众所周知，一名负责任的出题人，不应当让如下的打表程序获得过多的分数。

```cpp
#include<iostream>
int main() {
    std::cout << "Specific Value\n";
}
```

> 这个程序的功能是，输出一个特定的内容，以尝试通过一些测试点而获得分数。
> 
> 经典的例子是：<https://www.luogu.com.cn/problem/P8819>，输出无解可以获得 45 分的成绩。

## 题目描述

很不幸，你遇到了不负责任的出题人。

在某道试题里，共有 $N$ 个测试点，组成了 $k$ 个 Subtask，第 $i$ 个 Subtask 包含 $p_i$ 个测试点，第 $j$ 个测试点的编号为 $w_{i,j}$。请注意，一个测试点可能属于多个 Subtask。

> **Subtask**
>
> 每个 Subtask 包含多个测试点和一个分值，当且仅当通过全部这些测试点时，才能获得这个 Subtask 的分值。一道题目的得分为通过的所有 Subtask 分值之和。

这是一道输出仅有一个数的题目，编号为 $i$ 的测试点，标准答案为 $A_i$。

很不幸，由于命题人不负责任，$A_i$ 中出现了大量重复，让打表选手有了可乘之机。

现在，你通过某种手段获得了全部的数据，请问输出哪个数，可以得到最高的分数？最高的分数是多少？

如果有多个数均可得到最高的分数，你只需要任意给出一个。

## 说明/提示

### 数据规模与约定

- 对于 $30\%$ 的测试数据，$1 \le N \le 100$，$1 \le k,p_i \le 10$，$1 \le A_i \le 100$。
- 对于 $100\%$ 的测试数据，$1 \le N \le 10^5$，$1 \le k,p_i \le 5000$，$1 \le w_{i,j} \le N$，$1 \le S_i \le 10^9$，$1 \leq A _ i \leq 10 ^ 9$。

## 样例 #1

### 输入

```
2
3 1 2 3 5
3 4 5 6 7
6
4 4 4 5 5 5
```

### 输出

```
7
5
```

# AI分析结果



## 算法分类
无算法分类

## 综合分析与结论
题目要求找出一个数值，使得其能覆盖最多全符合的 Subtask 总分。核心思路如下：

1. **Subtask 条件检测**：对每个 Subtask 检查其所有测试点答案是否相同。若相同，记录该数值与对应分数。
2. **数值聚合统计**：由于数值范围极大（1e9），用排序替代哈希表，将相同数值的 Subtask 聚集后累加分数。
3. **极值筛选**：遍历排序后的结构体数组，统计每个数值的总分，记录最大值。

**可视化设计**：
- **检测阶段**：用不同颜色块表示每个测试点答案，若全同则高亮整个 Subtask 并触发音效。
- **排序阶段**：展示结构体数组按数值冒泡排序的过程，突出交换操作。
- **统计阶段**：用动态进度条表示当前累加总分，最大值实时更新。

## 题解评分列表 (≥4星)
1. **览遍千秋（5星）**  
   - 思路清晰，通过排序替代哈希巧妙解决大数值问题  
   - 代码简洁，核心逻辑明确（遍历检查+排序统计）  
   - 时间复杂度 O(kp + m log m) 可行，适合题目数据规模

## 最优思路与技巧
1. **条件检测剪枝**：仅处理测试点全同的 Subtask，避免无效计算。
2. **排序聚合替代哈希**：针对大数值范围，通过排序将相同值聚集，实现高效统计。
3. **极值动态更新**：在遍历排序结果时同步更新最大值，无需额外存储。

## 同类型题与算法套路
- **统计极值覆盖条件**：如「多数元素」、「区间覆盖极值」类问题。
- **大范围离散数据处理**：当无法使用传统哈希时，排序分组是通用解法。

## 推荐练习题
1. P1177 【模板】快速排序  
2. P1059 明明的随机数  
3. P1097 统计数字

## 核心代码实现
```cpp
struct Node { int val; long long score; } ans[5005];
int cnt = 0;

// 遍历每个 Subtask
for (int i = 1; i <= k; ++i) {
    bool valid = true;
    int base = A[w[i][1]]; // 首个测试点答案
    for (int j = 2; j <= p[i]; ++j) {
        if (A[w[i][j]] != base) {
            valid = false;
            break;
        }
    }
    if (valid) 
        ans[++cnt] = {base, S[i]};
}

// 按数值排序
sort(ans + 1, ans + cnt + 1, [](Node a, Node b) { return a.val < b.val; });

// 统计最大总分
long long max_score = 0, current = 0;
int result_val = 0;
for (int i = 1; i <= cnt; ++i) {
    if (i > 1 && ans[i].val != ans[i-1].val) 
        current = 0;
    current += ans[i].score;
    if (current > max_score) {
        max_score = current;
        result_val = ans[i].val;
    }
}
cout << result_val << endl;
```

## 复古像素化动画设计
- **画风**：16色 FC 风格，测试点用 8x8 像素块，颜色映射答案值。
- **检测动画**：Subtask 框逐个闪烁，全同则爆炸特效 + 8-bit 成功音效。
- **排序演示**：冒泡过程可视化，数值块上下跳动，交换时播放「哔」声。
- **统计界面**：顶部滚动显示当前最大值，背景音乐循环《超级玛丽》地下关BGM。

---
处理用时：97.61秒
# 题目信息

# [GESP202403 四级] 做题

## 题目描述

小杨同学为了提高自己的实力制定了做题计划，在第 $k$ 天时，他必须要完成 $k$ 道题，否则他就会偷懒。

小杨同学现在找到了一个题库，一共有 $n$ 套题单，每一套题单中有一定数量的题目。但是他十分挑剔，每套题单他只会使用一次，每一天也只能使用一套题单里的题目，之后那套题单就会弃之不用。对于每套题单，他不必完成题单内所有的题。

那么问题来了，小杨同学最多做题几天才偷懒呢？

## 说明/提示

### 数据规模与约定
对全部的测试数据，保证 $1 \leq n \leq 10^6$，$1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
4
3 1 4 1
```

### 输出

```
3```

# AI分析结果



## 算法分类
贪心算法

---

## 题解思路与核心难点
### 核心思路
题目需要找到最大连续天数，使得每天都能找到一个题单满足当天的题目数量需求。通过贪心策略，将题单从小到大排序后，依次匹配每个天数需求。具体步骤：
1. **排序预处理**：将题单按题目数量升序排列，便于优先使用最小可用题单。
2. **线性遍历匹配**：维护一个变量表示当前需要满足的天数，遍历排序后的题单，若当前题单满足天数要求，则天数递增。

### 解决难点
- **贪心策略证明**：需证明排序后按序匹配能得到最优解。假设存在更优解，则必存在题单未被充分利用，与贪心策略矛盾。
- **时间复杂度优化**：双重循环法（O(n²)）无法处理1e6数据，排序后线性遍历（O(n log n)）是唯一可行方案。

---

## 题解评分（≥4星）
1. **yu1128_AKIOI（5星）**
   - **亮点**：代码简洁，sum变量初始化为1，直接反映天数递增逻辑，输出时减1处理巧妙。
   - **时间复杂度**：O(n log n)，完美处理大数据量。

2. **damnM3bro（4星）**
   - **亮点**：变量命名清晰（now表示当前天数），代码结构与标准贪心模板一致，易理解。
   - **优化空间**：可添加变量初始值的注释说明。

3. **jiangyunuo（4星）**
   - **亮点**：注释详细，对初始值x=1的解释充分，适合教学场景。
   - **代码风格**：使用`scanf`输入优化速度，适合竞赛环境。

---

## 最优思路提炼
### 关键步骤
1. **排序题单**：升序排列后，确保优先使用最小的满足条件的题单。
2. **贪心遍历**：维护当前天数k，遍历时若题单a[i] ≥ k，则k自增。
3. **终止条件**：遍历完所有题单，最终结果为k-1（因k最后指向第一个无法满足的天数）。

### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int n, k = 1;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];
    sort(a.begin(), a.end());
    for (int x : a) if (x >= k) k++;
    cout << k - 1;
}
```

---

## 类似题目推荐
1. **P2695 骑士的工作**  
   - 贪心匹配骑士与恶龙，需排序后最小化花费。
2. **P1094 纪念品分组**  
   - 双指针贪心，组合纪念品使每组不超过容量。
3. **P4995 跳跳！**  
   - 排序后交替跳高，最大化能量累积。

---

## 算法可视化设计
### 动画方案
1. **排序过程**：以8位像素风格展示题单排序，用不同颜色区分已排序和未排序部分。
2. **贪心匹配**：
   - **元素高亮**：当前遍历的题单用闪烁效果标记。
   - **天数更新**：每次成功匹配时播放“升级”音效，天数显示在顶部逐渐增长。
   - **状态反馈**：题单被使用后变为灰色，不可再选。
3. **复古交互**：
   - **Canvas绘制**：题单以方块表示，高度与题目数成正比。
   - **音效设计**：匹配成功时用16位芯片音乐提示，失败时短促“哔”声。
   - **自动演示**：按空格键切换手动/自动模式，速度可调。

### 关键代码（JS片段）
```javascript
// Canvas绘制题单方块
function drawBars() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    sortedArray.forEach((val, idx) => {
        ctx.fillStyle = idx < currentDay ? "#808080" : "#00FF00";
        ctx.fillRect(idx * 20, 100 - val * 10, 18, val * 10);
    });
    ctx.fillStyle = "#FF0000";
    ctx.fillText(`Day: ${currentDay}`, 10, 20);
}

// 音效触发
function playSuccess() {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(880, audioCtx.currentTime);
    osc.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.1);
}
```

---

## 总结
本题通过排序与贪心的经典组合，展示了如何高效解决资源分配问题。核心在于排序预处理和线性扫描的巧妙结合，避免不必要的计算。在类似场景中，优先考虑资源的最优局部选择往往能导向全局最优解。

---
处理用时：86.05秒
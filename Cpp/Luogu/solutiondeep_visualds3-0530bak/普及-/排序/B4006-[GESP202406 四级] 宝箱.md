# 题目信息

# [GESP202406 四级] 宝箱

## 题目描述

小杨发现了 $n$ 个宝箱，其中第 $i$ 个宝箱的价值是 $a_i$。

小杨可以选择一些宝箱放入背包并带走，但是小杨的背包比较特殊，假设小杨选择的宝箱中最大价值为 $x$，最小价值为 $y$，小杨需要保证 $x-y\leq k$，否则小杨的背包会损坏。

小杨想知道背包不损坏的情况下，自己能够带走宝箱的总价值最大是多少。

## 说明/提示

**【样例解释】**

在背包不损坏的情况下，小杨可以拿走两个价值为 $2$ 的宝箱和一个价值为 $3$ 的宝箱。

**【数据范围】**

对于全部数据，保证有 $1\leq n\leq 1000$，$0\leq k\leq 1000$，$1\leq a_i\leq 1000$。

## 样例 #1

### 输入

```
5 1
1 2 3 1 2```

### 输出

```
7```

# AI分析结果



**唯一算法分类**  
滑动窗口/双指针

---

### **题解思路、算法要点与解决难点**  
1. **核心思路**：  
   - 将宝箱排序后，问题转化为寻找连续区间，使得区间极差≤k，并求最大总和。  
   - **枚举右端点**：遍历每个元素作为右端点，向左扩展左端点直至满足极差条件。  
   - **快速求和**：利用前缀和数组优化区间和计算。  

2. **解决难点**：  
   - **暴力法优化**：原题解采用双重循环（O(n²)），可优化为排序后双指针（O(n)）或二分+前缀和（O(n logn)）。  
   - **极差判断**：通过排序确保极差即右-左端点值，避免动态计算最大/最小值。  

3. **优化对比**：  
   - **题解方法**：暴力枚举右端点，内层循环向左遍历，时间复杂度 O(n²)。  
   - **优化思路**：使用双指针维护滑动窗口，窗口内极差≤k，时间复杂度 O(n)。  

---

### **最优思路或技巧提炼**  
- **排序后双指针**：排序保证数组有序，利用单调性维护滑动窗口。  
- **前缀和加速**：预处理前缀和数组，快速计算区间和。  
- **二分查找优化**：对每个右端点，二分查找左边界，时间复杂度 O(n logn)。  

---

### **题解评分**  
无 ≥4 星题解。  

---

### **同类型题与算法套路**  
- **最大连续区间和**：如 LeetCode 53. 最大子数组和。  
- **带约束的滑动窗口**：如 LeetCode 209. 长度最小的子数组。  
- **极差限制的子数组**：如 LeetCode 1438. 绝对差不超过限制的最长连续子数组。  

---

### **推荐相似题目**  
1. [洛谷 P1714 切蛋糕](https://www.luogu.com.cn/problem/P1714)（滑动窗口+前缀和）  
2. [洛谷 P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)（双指针维护极值）  
3. [洛谷 P1638 逛画展](https://www.luogu.com.cn/problem/P1638)（双指针求极差约束区间）  

---

### **可视化与算法演示**  
**核心流程**：  
1. **排序动画**：展示宝箱排序过程，元素按值升序排列。  
2. **双指针移动**：右指针（红色）向右移动，左指针（绿色）根据极差调整位置。  
3. **区间高亮**：当前窗口内元素用黄色高亮，实时显示总和。  

**复古像素风格设计**：  
- **颜色方案**：  
  - 宝箱：蓝色方块，数值以8位字体显示。  
  - 指针：红/绿闪烁方块。  
  - 有效区间：黄色边框。  
- **音效**：  
  - 指针移动：短促“滴”声。  
  - 更新最大值：上扬音效。  
- **Canvas 动画**：网格布局，每一步更新后重绘元素与指针位置。  

---

### **核心代码实现**  
```cpp
#include <algorithm>
#include <vector>
#include <iostream>
using namespace std;

int main() {
    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];
    sort(a.begin(), a.end());
    
    vector<int> prefix(n + 1, 0);
    for (int i = 0; i < n; ++i) 
        prefix[i+1] = prefix[i] + a[i];
    
    int max_sum = 0;
    int left = 0;
    for (int right = 0; right < n; ++right) {
        while (a[right] - a[left] > k) 
            left++;
        max_sum = max(max_sum, prefix[right+1] - prefix[left]);
    }
    cout << max_sum << endl;
    return 0;
}
```

**代码说明**：  
- **排序预处理**：确保数组有序，极差由端点决定。  
- **前缀和数组**：`prefix[i]` 表示前 i 项和。  
- **双指针滑动**：`left` 指针维护满足极差的最小左边界。

---
处理用时：81.88秒
# 题目信息

# [NOIP 2007 提高组] 统计数字

## 题目描述

某次科研调查时得到了 $n$ 个自然数，每个数均不超过 $1.5 \times 10^9$。已知不相同的数不超过 $10^4$ 个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。


## 说明/提示

- $30\%$ 的数据满足：$1  \le  n  \le  1000$；
- $60\%$ 的数据满足：$1  \le  n  \le  50000$；
- $100\%$ 的数据满足：$1  \le  n  \le  200000$，每个数均不超过 $1.5 \times 10^9$。

NOIP 2007 提高第一题


## 样例 #1

### 输入

```
8
2
4
2
4
5
100
2
100```

### 输出

```
2 3
4 2
5 1
100 2
```

# AI分析结果



## 算法分类
排序 + 线性统计

---

## 题解思路、算法要点与解决难点

### 核心思路对比
1. **基于排序的线性统计**  
   - 将所有数字排序后相邻元素必然连续  
   - 遍历时用双指针统计连续相同元素的个数  
   - 解决难点：边界条件处理（如最后一个元素）

2. **基于STL的映射统计**  
   - 利用`map`的自动排序特性存储键值对  
   - 解决难点：理解红黑树的O(log n)插入代价  
   - 优化技巧：预排序后插入可提升红黑树效率

### 关键数据结构对比
| 方法                 | 时间复杂度 | 空间复杂度 | 优势                     | 劣势                     |
|----------------------|------------|------------|--------------------------|--------------------------|
| 排序+线性统计        | O(n log n) | O(n)       | 常数因子小，内存连续访问 | 需要处理边界条件         |
| map自动统计          | O(n log n) | O(k)       | 代码极简，逻辑清晰       | 红黑树节点操作开销较大   |
| set+map组合统计       | O(n log k) | O(k)       | 显式去重减少内存占用     | 需要维护两个数据结构     |

---

## 题解评分 (≥4星)

### 五星题解
1. **ikunTLE（map自动统计）**  
   🌟🌟🌟🌟🌟  
   - 仅用10行代码实现核心逻辑  
   - 利用`auto`关键字简化迭代器操作  
   - 时间复杂度分析清晰  

2. **LiJunze0501（双指针跳转）**  
   🌟🌟🌟🌟🌟  
   - 用`i = j-1`巧妙跳过重复元素  
   - 无需额外存储空间  
   - 边界条件处理完美（包含最后一个元素）

3. **Ngo123（块统计法）**  
   🌟🌟🌟🌟  
   - 结构体存储块信息逻辑清晰  
   - 代码可读性较强  
   - 需要额外O(k)空间存储块信息

---

## 最优思路与技巧提炼

### 核心技巧
1. **跳跃指针法**  
   ```cpp
   for(int i=1; i<=n; ){
       int j = i;
       while(a[j] == a[i]) j++;
       cout << a[i] << " " << j-i << endl;
       i = j;  // 关键跳转
   }
   ```
2. **map的自动排序特性**  
   ```cpp
   map<int,int> mp;
   for(auto x : nums) mp[x]++;
   for(auto &[k,v] : mp) cout << k << " " << v << endl;
   ```

### 调试经验
- 排序法必须处理最后一个元素（样例中多个题解漏掉最后输出）
- map的`operator[]`会默认插入0值，可能干扰统计逻辑

---

## 同类题型推荐
1. [P1177 排序](https://www.luogu.com.cn/problem/P1177)  
   （巩固快速排序实现）
2. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)  
   （归并排序的典型应用）
3. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)  
   （排序+去重的简化版）

---

## 算法可视化设计

### 复古像素风格演示
**排序统计法动画方案：**
1. **初始化阶段**  
   - 8位像素风格显示未排序的数组（灰色方块）
   - 每个方块标注数值，背景色表示不同数值

2. **排序过程**  
   - 使用快速排序的像素动画：
   ```javascript
   function quickSortVisual(arr, left, right) {
       // 用不同颜色高亮pivot、左右指针
       drawPivot(pivotX, '#FF0000'); 
       drawPointer(leftPtr, '#00FF00');
       drawPointer(rightPtr, '#0000FF');
   }
   ```
   - 每次交换元素时播放"哔"音效

3. **统计阶段**  
   - 绿色指针从左向右扫描：
   ```javascript
   let i = 0;
   const highlight = setInterval(() => {
       ctx.fillStyle = '#00FF00';
       drawBlock(i);
       if(a[i] !== a[i-1]) playSound('click.wav');
       i++;
   }, 500);
   ```
   - 遇到新数值时触发黄色闪光和上扬音效

### 交互功能
- **速度控制滑块**：调整排序和统计动画速度（100ms~2000ms）
- **模式切换**：比较排序法 vs map法的像素动画
- **音效开关**：8-bit风格背景音乐（循环播放）和操作音效

---

## 核心代码实现

### 最优题解代码（LiJunze0501）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5+5;
int n,a[N];
int main() {
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a+1,a+n+1);
    for(int i=1;i<=n;){
        int j = i;
        while(j<=n && a[j]==a[i]) j++;
        cout<<a[i]<<" "<<j-i<<endl;
        i = j; // 关键跳转
    }
    return 0;
}
```

### 像素动画核心逻辑（JavaScript）
```javascript
class PixelSorter {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.blockSize = 20;
        this.colors = {'base':'#333', 'pivot':'#FF0000', 'pointer':'#00FF00'};
    }
    
    drawArray(arr, highlights={}) {
        this.ctx.clearRect(0, 0, canvas.width, canvas.height);
        arr.forEach((num, i) => {
            this.ctx.fillStyle = this.colors.base;
            if(i === highlights.pivot) this.ctx.fillStyle = this.colors.pivot;
            if(i === highlights.left || i === highlights.right) 
                this.ctx.fillStyle = this.colors.pointer;
            this.ctx.fillRect(i*this.blockSize, 0, this.blockSize, this.blockSize);
            this.ctx.fillText(num, i*this.blockSize+5, 15);
        });
    }
}
```

---

## 总结与心得
本题揭示了大数据量统计问题的两种核心思路：排序预处理与高效数据结构。在工程实践中，排序法的内存局部性更优；在编程竞赛中，map法凭借代码简洁性更受青睐。调试时需特别注意边界条件，尤其是连续相同元素的最后一个块的输出处理。通过复古像素动画的交互演示，可直观理解两种方法的性能差异与实现细节。

---
处理用时：88.16秒
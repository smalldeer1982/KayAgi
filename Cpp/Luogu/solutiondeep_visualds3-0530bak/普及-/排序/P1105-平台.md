# 题目信息

# 平台

## 题目描述

空间中有一些平台。给出每个平台的位置，请你计算从每一个平台的边缘落下之后会落到哪一个平台上。

注意，如果某两个平台的某个两边缘横坐标相同，物体从上面那个平台落下之后将不会落在下面那个平台上（即平台的范围是一个开区间，不包含端点）。平台**可能会重叠**。

从平台下落时视作从平台下方开始下落，也就是说不会落到高度相同的平台上。**如果有两个平台的高度相同且都可以被落到的话，那么会落到编号靠前的那个平台。**

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/qeknowf7.png)

## 样例 #1

### 输入

```
5
2 0 2
4 1 3
3 1 3
5 3 4
1 1 5
```

### 输出

```
0 5
1 5
1 5
5 5
0 0
```

# AI分析结果



## 算法分类
无算法分类（模拟、暴力枚举）

---

## 题解思路与解决难点
**核心逻辑**：  
对于每个平台，找到其左右边缘下方能接住的最高平台。判断条件：  
1. 目标平台高度严格小于当前平台  
2. 当前平台的边缘落在目标平台的区间内（开区间）  
3. 在满足条件的平台中选高度最高、编号最小的  

**关键难点**：  
1. **开区间端点处理**：边缘必须严格落在平台区间内  
2. **高度相同处理**：同一高度平台不可接住，需按编号优先  
3. **高效遍历**：暴力枚举所有平台，或排序优化遍历顺序  

**题解对比**：  
- 多数题解使用暴力枚举，时间复杂度 O(n²)，但数据范围允许  
- 部分题解通过排序优化遍历顺序，但需正确处理高度相同的平台  

---

## 高星题解推荐（≥4星）
### 1. 题解作者：Ofnoname（★★★★★）
**亮点**：  
- 直接暴力枚举，代码简洁  
- 正确判断高度和区间条件  
- 变量命名清晰，逻辑易读  
```cpp
for (int i = 1; i <= N; i++) {
    int H1 = 0, H2 = 0;
    for (int j = 1; j <= N; j++) {
        // 左边缘判断
        if (H1 < h[j] && h[j] < h[i] && l[j] < l[i] && l[i] < r[j])
            ans[0][i] = j, H1 = h[j];
        // 右边缘判断
        if (H2 < h[j] && h[j] < h[i] && l[j] < r[i] && r[i] < r[j])
            ans[1][i] = j, H2 = h[j];
    }
}
```

### 2. 题解作者：kevin_y（★★★★）
**亮点**：  
- 双循环暴力搜索，逻辑直观  
- 明确处理左右边缘分开判断  
- 代码简短，适合快速理解  
```cpp
for(int i=1; i<=n; i++){
    int sum1=0,sum2=0;
    for(int j=1; j<=n; j++) {
        if(a[j]<a[i] && b[j]<b[i] && c[j]>b[i] && a[sum1]<a[j])
            sum1=j; // 左下落
        if(a[j]<a[i] && b[j]<c[i] && c[j]>c[i] && a[sum2]<a[j])
            sum2=j; // 右下落
    }
}
```

### 3. 题解作者：彭骐飞（★★★★）
**亮点**：  
- 双重循环枚举所有平台对  
- 动态更新最高平台，避免排序  
- 变量命名清晰，注释明确  
```pascal
for i:=1 to n-1 do
    for j:=i+1 to n do
        if a[i].h>a[j].h then begin
            // 左边缘处理
            if (a[i].l>a[j].l) and (a[i].l<a[j].r) and (a[l[i]]<a[j].h) then
                l[i]:=j;
            // 右边缘处理
            if (a[i].r>a[j].l) and (a[i].r<a[j].r) and (a[r[i]]<a[j].h) then
                r[i]:=j;
        end;
```

---

## 最优思路提炼
1. **暴力枚举法**：  
   - 对每个平台，遍历所有其他平台  
   - 记录满足条件的最高平台（同时处理编号优先级）  

2. **排序优化法**：  
   - 按高度降序、编号升序排序  
   - 遍历时只需检查后续平台，找到第一个符合条件的即可  

---

## 相似题目推荐
1. **P1904 天际线**  
   - 区间覆盖与高度处理  
2. **P2783 有机的吃草**  
   - 二维平面区间判断  
3. **P3740 接雨水 II**  
   - 平台接水问题的变种  

---

## 可视化设计
### 核心算法动画演示
1. **二维坐标系绘制**：  
   - X轴为平台区间，Y轴为高度  
   - 当前平台高亮显示，下落轨迹用虚线标记  

2. **动态遍历过程**：  
   - 遍历其他平台时，符合条件的高台标记为绿色  
   - 最终选中平台闪烁提示  

3. **复古像素风格**：  
   - 平台用 8-bit 色块表示  
   - 音效：下落时播放“滴答”声，选中时播放“确认”音效  

**交互功能**：  
- **步进控制**：手动触发每一步遍历  
- **速度调节**：调整遍历速度（0.5x~3x）  
- **自动模式**：AI 自动执行全过程  

---

## 总结
暴力枚举法虽无复杂优化，但直观且易于实现，是本题最优解法。排序法需注意高度相同时的处理细节，易出错。核心在于正确处理开区间和高度优先级。

---
处理用时：260.51秒
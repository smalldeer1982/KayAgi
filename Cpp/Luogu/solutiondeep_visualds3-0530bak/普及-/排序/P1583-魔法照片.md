# 题目信息

# 魔法照片

## 题目描述

一共有 $n$ 个人（以 $1\sim n$ 编号）向佳佳要照片，而佳佳只能把照片给其中的 $k$ 个人。佳佳按照与他们的关系好坏的程度给每个人赋予了一个初始权值 $W_i$。然后将初始权值从大到小进行排序，每人就有了一个序号 $D_i$（取值同样是 $1\sim n$）。按照这个序号对 $10$ 取模的值将这些人分为 $10$ 类。也就是说定义每个人的类别序号 $C_i$ 的值为 $(D_i-1)\bmod 10 +1$，显然类别序号的取值为 $1 \sim 10$。第 $i$ 类的人将会额外得到 $E_i$ 的权值。你需要做的就是求出加上额外权值以后，最终的权值最大的 $k$ 个人，并输出他们的编号。**在排序中，如果两人的 $E_i$ 相同，编号小的优先。**

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 20000$，$1\leq k\leq n$，保证所有数据均在 `int` 范围之内。

## 样例 #1

### 输入

```
10 10
1 2 3 4 5 6 7 8 9 10
2 4 6 8 10 12 14 16 18 20
```

### 输出

```
10 9 8 7 6 5 4 3 2 1
```

# AI分析结果



### 算法分类
**排序**

---

### 题解思路与算法要点
**核心逻辑**：两次排序 + 类别权值叠加  
1. **第一次排序**：按初始权值降序排序，权值相同则编号小优先  
2. **计算类别**：根据第一次排序后的顺序号计算类别 `C_i = (i-1)%10 +1`  
3. **叠加权值**：为每个人加上对应类别的额外权值 `E[C_i]`  
4. **第二次排序**：按新权值降序排序，权值相同则编号小优先  

**关键难点**：
1. 正确理解排序后的序号 `D_i` 与数组下标的关系（D_i = i+1，数组下标从0开始）  
2. 类别计算时对取模操作的边界处理  
3. 两次排序的比较函数需正确处理权值相同时的编号优先级  

**通用解法**：  
- 使用结构体保存权值、初始编号  
- 自定义排序函数：权值降序为主，编号升序为次  
- 遍历第一次排序后的数组，按位置序号计算类别并叠加权值  

---

### 题解评分（≥4星）

| 作者 | 评分 | 核心亮点 |
|------|------|----------|
| CreeperK | ⭐⭐⭐⭐ | 结构体清晰，代码简洁，注释明确 |
| Aehnuwx | ⭐⭐⭐⭐ | 结构体命名规范，变量作用明确 |
| zhaowangji | ⭐⭐⭐⭐ | 代码注释详细，关键步骤中文说明 |

---

### 最优思路提炼
1. **双次排序法**：两次使用稳定排序，时间复杂度 O(n log n)  
2. **结构体绑定数据**：将编号与权值绑定，避免排序后数据错位  
3. **位置序号映射**：直接通过数组下标隐式记录第一次排序后的序号，无需额外存储  
4. **权值叠加公式**：`E[(i-1)%10 +1]` 实现类别到权值的映射  

---

### 相似题目推荐
1. **P1309 瑞士轮**（两次排序+归并优化）  
2. **P1068 分数线划定**（双关键字排序）  
3. **P1051 谁拿了最多奖学金**（多条件权值计算+排序）  

---

### 可视化算法演示
**动画设计要点**：  
1. **第一次排序阶段**：  
   - 初始权值用绿色方块表示高度  
   - 动态展示快速排序的分割过程，用红色标记当前比较元素  
2. **权值叠加阶段**：  
   - 按排序后的顺序，用不同颜色标记每10人一组（类别分组）  
   - 每组上方显示对应的E值，权值条增长表示叠加过程  
3. **第二次排序阶段**：  
   - 新权值用蓝色渐变效果更新  
   - 用冒泡排序动画展示最终排名变化  

**复古游戏化效果**：  
- 8-bit音效：排序交换时触发"哔"声，权值叠加时触发"叮"声  
- 像素风格界面：权值用不同高度的砖块表示，编号显示为8位数字  
- 自动演示模式：按空格键暂停/继续，方向键控制动画速度  

---

### 核心代码实现
```cpp
#include <algorithm>
using namespace std;

struct Person {
    int w, id;
} p[20005];
int E[11];

bool cmp(Person a, Person b) {
    return (a.w != b.w) ? a.w > b.w : a.id < b.id;
}

int main() {
    int n, k;
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= 10; i++) scanf("%d", &E[i]);
    for (int i = 0; i < n; i++) {
        scanf("%d", &p[i].w);
        p[i].id = i + 1;
    }
    
    sort(p, p + n, cmp); // 第一次排序
    for (int i = 0; i < n; i++) 
        p[i].w += E[(i % 10) + 1]; // 叠加权值
    
    sort(p, p + n, cmp); // 第二次排序
    for (int i = 0; i < k; i++)
        printf("%d ", p[i].id);
}
```

---

### 个人心得摘录
> "第二次排序时忘记处理编号优先级，WA了3次才意识到比较函数没写全条件" —— 通过调试发现排序规则不完整  
> "发现E数组的下标从1开始，而模运算是从0开始，调试半小时才找到这个坑" —— 注意题目与代码的索引差异  
> "结构体比分开数组更易维护，避免了下标错位问题" —— 数据结构选择的重要性  

---

通过上述分析，该题的核心在于理解两次排序的作用及正确处理类别映射关系。可视化设计可帮助直观理解权值叠加与排序的动态过程。

---
处理用时：71.19秒
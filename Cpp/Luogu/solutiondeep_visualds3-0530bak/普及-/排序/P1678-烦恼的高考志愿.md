# 题目信息

# 烦恼的高考志愿

## 题目背景

计算机竞赛小组的神牛 V 神终于结束了高考，然而作为班长的他还不能闲下来，班主任老 t 给了他一个艰巨的任务：帮同学找出最合理的大学填报方案。可是 v 神太忙了，身后还有一群小姑娘等着和他约会，于是他想到了同为计算机竞赛小组的你，请你帮他完成这个艰巨的任务。


## 题目描述

现有 $m$ 所学校，每所学校预计分数线是 $a_i$。有 $n$ 位学生，估分分别为 $b_i$。

根据 $n$ 位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差最小（可高可低，毕竟是估分嘛），这个最小值为不满意度。求所有学生不满意度和的最小值。


## 说明/提示

数据范围：

对于 $30\%$ 的数据，$1\leq n,m\leq1000$，估分和录取线 $\leq10000$；

对于 $100\%$ 的数据，$1\leq n,m\leq100000$，估分和录取线 $\leq 1000000$ 且均为非负整数。


## 样例 #1

### 输入

```
4 3
513 598 567 689
500 600 550
```

### 输出

```
32```

# AI分析结果



**唯一算法分类**: 二分查找

---

### **题解思路与核心难点**
1. **核心思路**: 将学校分数线排序后，对每个学生分数进行二分查找，找到最接近的分数线，计算最小差值。
2. **解决难点**:
   - **边界处理**：学生分数可能比所有学校分数线都低或高，需特判。
   - **二分终止条件**：需确保找到的左右边界相邻，比较两者的差值。
3. **算法流程**:
   - 排序学校分数线。
   - 对每个学生分数，二分查找确定左右边界。
   - 比较相邻两个学校分数与学生的差值，取最小值累加。

---

### **题解评分 (≥4星)**
1. **06ray (5星)**
   - **亮点**: 清晰的二分实现，详细注释，处理了边界条件。
   - **代码**: 通过二分找到最后一个小于等于学生分数的位置，比较相邻元素。
2. **Viston (5星)**
   - **亮点**: 使用 `lower_bound` 简化代码，利用 STL 提高可读性。
   - **关键代码**: `e = lower_bound(c+1, c+a+1, d) - c` 快速定位插入点。
3. **AK_黄铮_IMO (4星)**
   - **亮点**: 简洁的二分与 `lower_bound` 结合，明确处理极端情况。
   - **代码片段**:
     ```cpp
     p1 = lower_bound(num, num+m, x) - num;
     p2 = p1 - 1;
     ans += min(abs(num[p1]-x), abs(x-num[p2]));
     ```

---

### **最优思路与技巧提炼**
1. **排序预处理**: 学校分数线必须排序，才能进行二分查找。
2. **二分核心**:
   - 查找最后一个小于等于学生分数的位置。
   - 比较该位置与下一位置的差值，取最小值。
3. **STL 优化**: 使用 `lower_bound` 替代手写二分，减少错误。

---

### **同类型题与算法套路**
- **相似题目**: 
  - **P1102 A-B 数对**（二分查找差值为定值的对）
  - **P1024 一元三次方程求解**（二分逼近根）
  - **P2678 跳石头**（二分答案判定可行性）

---

### **可视化与算法演示**
**动画设计**:
1. **数据结构展示**:
   - 学校分数排序后以像素块排列，颜色深浅表示分数高低。
   - 学生分数用闪烁光标表示，动态插入到学校分数序列中。
2. **二分过程**:
   - **高亮左右指针**（红色/蓝色方块），计算 `mid` 位置（黄色方块）。
   - 比较学生分数与 `mid` 处的学校分数，移动指针并播放音效。
3. **差值计算**:
   - 找到相邻学校后，显示两条连接线，分别标出差值，取较小值累加。
4. **复古风格**:
   - 8-bit 音效：指针移动时播放“滴”声，找到结果时播放“成功”音效。
   - Canvas 绘制网格，学校分数用绿色像素块，学生用红色像素块。

---

### **关键代码片段**
```cpp
// 使用 lower_bound 的核心逻辑
sort(a, a + m); // 排序学校分数
for (int i = 0; i < n; i++) {
    int x = student[i];
    auto it = lower_bound(a, a + m, x); // 找到第一个 >=x 的位置
    int idx = it - a;
    int diff = min(abs(x - a[idx]), abs(x - a[idx-1]));
    ans += diff;
}
```

---

### **总结**
**二分查找**是该题的最优解法，时间复杂度为 *O(m log m + n log m)*，代码简洁高效。可视化设计可通过动态展示二分指针移动与差值计算，帮助学生理解算法核心。

---
处理用时：87.98秒
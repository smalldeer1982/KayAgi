# 题目信息

# 双调序列

## 题目描述

电脑组的童鞋们经常玩一些智力 PK 小游戏，某月某日，发源于小朋友又发明了一种新的序列：双调序列，所谓的双调呢主要是满足如下条件描述：

假定有 $n$（$n \le 1000$）个整数（都在 `long int` 范围内，即 $-2147483648 \sim 2147483647$），双调序列的第一个数是 $n$ 个整数中的最大数，第二个数是 $n$ 个整数中的最小数，第三个数是 $n$ 个数中的第二大数，第四个数是 $n$ 个数中的第二小数……取过的数不能再取，依次类推，直到结束。

聪明的你听完描述就抿嘴笑了吧？那就请你用程序正确的帮他找出这 $n$ 个数的双调序列。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 1000$。


## 样例 #1

### 输入

```
5
10
-1
3
3
-9
```

### 输出

```
10
-9
3
-1
3
```

# AI分析结果



## 算法分类
排序 + 双指针

---

## 核心思路与解决难点

### 算法推导
1. **排序预处理**：将数组排序后，最大值在末尾，最小值在开头，次大值在倒数第二，次小值在第二，形成有序结构。
2. **交替输出策略**：用双指针分别指向当前最大和最小元素位置，交替输出最大值和最小值，指针逐步向中间靠拢。
3. **奇偶处理**：当元素数量为奇数时，中间元素最后单独输出。

### 解决难点
- **指针同步移动**：需保证指针不交叉且覆盖所有元素。
- **奇偶边界处理**：避免重复输出或遗漏中间元素。

---

## 优质题解评分（≥4星）

### 1. B_Qu1e7（★★★★★）
- **思路清晰**：直接排序后交替输出最大最小值。
- **代码简洁**：仅需排序和一个循环。
- **高效性**：时间复杂度 O(n log n)。
- **关键代码**：
  ```cpp
  sort(a+1,a+n+1);
  for(int i=1;i<=n/2;i++) {
      cout<<a[n-i+1]<<endl<<a[i]<<endl;
  }
  if(n%2) cout<<a[n/2+1]<<endl;
  ```

### 2. judgejudge（★★★★☆）
- **双指针法**：清晰展示头尾指针移动。
- **两种实现**：提供排序和优先队列两种思路。
- **代码示例**：
  ```cpp
  int pl=1, pr=n;
  while(pl<=pr) {
      cout<<a[pl++]<<endl;
      if(pl<=pr) cout<<a[pr--]<<endl;
  }
  ```

### 3. RedreamMer（★★★★☆）
- **奇偶控制**：通过循环变量奇偶性决定取大或小。
- **简洁实现**：
  ```cpp
  for(int i=1,j=a+1,k=0; i<=a; i++) {
      if(i%2==1) cout<<x[--j]<<endl;
      else cout<<x[++k]<<endl;
  }
  ```

---

## 最优思路提炼
1. **排序预处理**：将数组升序排序。
2. **双指针交替输出**：
   - 左指针从开头取最小值，右指针从末尾取最大值。
   - 每轮循环输出右指针元素后左移，再输出左指针元素后右移。
3. **奇偶处理**：循环次数为 `n/2`，奇数时补中间值。

---

## 同类型题目
- **P1177** 快速排序模板
- **P1059** 明明的随机数（去重排序）
- **P1068** 分数线划定（双关键字排序）

---

## 可视化算法演示

### 动画设计
1. **像素风格网格**：用 8-bit 色块表示数组元素，排序后元素按升序排列。
2. **指针高亮**：
   - 红色块（右指针）：当前最大值。
   - 蓝色块（左指针）：当前最小值。
3. **步进操作**：
   - 每次先取红色块，右指针左移。
   - 再取蓝色块，左指针右移。
4. **音效提示**：
   - 取数时播放“滴”声。
   - 完成时播放胜利音效。

### 关键代码（伪代码）
```javascript
// 初始化排序数组
let sortedArray = [...].sort((a,b) => a-b);
let left = 0, right = sortedArray.length - 1;
let output = [];

function nextStep() {
    if (left <= right) {
        output.push(sortedArray[right--]);
        highlight(right, 'red');
        playSound('beep');
    }
    if (left <= right) {
        output.push(sortedArray[left++]);
        highlight(left, 'blue');
        playSound('beep');
    }
}
```

---

## 个人心得摘录
- **B_Qu1e7**：“跟快速排序模板一样简单，只不过反了一半而已”——强调排序后的对称性。
- **装逼是种缺德**：“奇数输大的，偶数输小的”——总结输出规律。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, a[1001];
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
    sort(a, a + n);
    int left = 0, right = n - 1;
    while (left <= right) {
        cout << a[right--] << endl;    // 取最大
        if (left <= right) 
            cout << a[left++] << endl; // 取最小
    }
    return 0;
}
```

---
处理用时：70.28秒
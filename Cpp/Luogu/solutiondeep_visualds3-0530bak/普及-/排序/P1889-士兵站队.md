# 题目信息

# 士兵站队

## 题目描述

在一个划分成网格的操场上，$n$ 个士兵散乱地站在网格点上，由整数坐标 $(x,y)$ 表示。

士兵们可以沿网格边上、下左右移动一步，但在同时刻任一网格点上只能有 1 名士兵。

按照军官的命令，他们要整齐地列成一个水平队列，即排成队列，即排成 $(x,y),(x+1,y),\ldots,(x+n-1,y)$。请求出如何选择 $x$ 和 $y$ 的值才能使士兵们以最少的总移动步数排成一列。

## 说明/提示

对于 $100\%$ 的数据，保证 $1 \leq n \leq 10000$，$-10000 \leq x,y \leq 10000$。

## 样例 #1

### 输入

```
5
1 2
2 2
1 3
3 -2
3 3```

### 输出

```
8```

# AI分析结果



### 算法分类
**贪心**

---

### 综合分析与结论
#### 核心思路与难点
1. **纵坐标处理**：所有士兵的最终纵坐标必须相同。总移动步数最小化时，目标纵坐标为所有士兵纵坐标的中位数。
2. **横坐标处理**：士兵需排成连续的一行。将每个士兵的横坐标调整为 `x_i - i`（或 `x_i - (i-1)`，两种方法等价），再取调整后的值的中位数作为基准位置，从而最小化总移动步数。
3. **关键推导**：  
   - 纵坐标总移动步数公式：$$\sum |y_i - m|$$，取中位数 $m$ 时最小。  
   - 横坐标总移动步数公式：$$\sum |(x_i - i) - k|$$，取中位数 $k$ 时最小。

#### 可视化设计
1. **动画演示**：
   - **纵坐标**：士兵的纵坐标排序后，用红色高亮中位数位置，士兵垂直移动至该线。
   - **横坐标**：原横坐标排序后调整为 `x_i - i`，再次排序后高亮中位数位置，士兵水平移动至连续位置。
2. **复古风格**：
   - **像素网格**：用 8-bit 风格展示网格，士兵初始位置用绿色方块，目标位置用蓝色方块。
   - **音效**：移动时播放“嘀”声，选中位数时播放“叮”声，计算完成时播放胜利音效。
3. **交互控制**：允许单步执行，观察排序、调整、移动的每一步变化。

---

### 题解评分（≥4星）
#### 1. xiejinhao（5星）
- **亮点**：  
  - 详细推导纵、横坐标处理逻辑，代码清晰简洁。  
  - 注释丰富，可读性强，处理横坐标时两次排序确保正确性。
- **关键代码**：
  ```cpp
  sort(x+1, x+n+1);
  for(int i=1; i<=n; i++) x[i] -= i;
  sort(x+1, x+n+1);
  int rex = (n%2 == 0) ? (x[n/2] + x[n/2+1])/2 : x[n/2+1];
  ```

#### 2. lzj666_luogu（4星）
- **亮点**：代码高度精简，直接通过排序和中位数计算解决。
- **关键代码**：
  ```cpp
  sort(&x[1], &x[n+1]);
  for(int i=1; i<=n; i++) x[i] -= i;
  sort(&x[1], &x[n+1]);
  ```

#### 3. 苯酚加氧（4星）
- **亮点**：代码简洁，直接调用标准库函数，逻辑清晰。
- **关键代码**：
  ```cpp
  sort(a+1, a+n+1);
  for(int i=1; i<=n; i++) a[i] -= i;
  sort(a+1, a+n+1);
  ```

---

### 最优思路提炼
1. **中位数应用**：总移动步数最小化时，目标位置必为各坐标的中位数。
2. **横坐标转换技巧**：将连续排列问题转化为中位数问题，通过调整 `x_i - i` 简化计算。
3. **分治思想**：独立处理横纵坐标，避免维度耦合。

---

### 同类题目推荐
1. **P1862 输油管道问题**：一维中位数应用。
2. **P1632 点的移动**：二维曼哈顿距离最小化。
3. **P2280 [HNOI2003] 激光炸弹**：二维前缀和与贪心结合。

---

### 个人心得摘录
- **调试教训**：初始未对调整后的横坐标二次排序，导致中位数错误。
- **顿悟时刻**：通过数学变形发现横坐标问题可转化为中位数问题。

---

### 核心代码实现
```cpp
#include <algorithm>
#include <iostream>
using namespace std;

int main() {
    int n, x[10005], y[10005], ans = 0;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> x[i] >> y[i];
    
    // 处理纵坐标
    sort(y + 1, y + n + 1);
    int my = y[(n + 1) / 2];
    
    // 处理横坐标
    sort(x + 1, x + n + 1);
    for (int i = 1; i <= n; i++) x[i] -= i;
    sort(x + 1, x + n + 1);
    int mx = x[(n + 1) / 2];
    
    // 计算总步数
    for (int i = 1; i <= n; i++) {
        ans += abs(y[i] - my) + abs(x[i] - mx);
    }
    cout << ans << endl;
    return 0;
}
```

---
处理用时：223.95秒
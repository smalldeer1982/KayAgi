# 题目信息

# 母舰

## 题目背景

广东汕头聿怀初中 Train#3 Problem 1

（有没有红警既视感~）


## 题目描述

在小 A 的星际大战游戏中，一艘强力的母舰往往决定了一场战争的胜负。一艘母舰的攻击力是普通的 MA（Mobile Armor）无法比较的。

对于一艘母舰而言，它是由若干个攻击系统和若干个防御系统组成的。两艘母舰对决时，一艘母舰会选择用不同的攻击系统去攻击对面母舰的防御系统。当这个攻击系统的攻击力大于防御系统的防御力时，那个防御系统会被破坏掉。当一艘母舰的防御系统全部被破坏掉之后，所有的攻击都会攻击到敌方母舰本身上去造成伤害。

这样说，一艘母舰对对面的伤害在一定程度上是取决于选择的攻击对象的。

在瞬息万变的战场中，选择一个最优的攻击对象是非常重要的。所以需要写出一个战斗系统出来，判断出你的母舰最多能对对手造成多少伤害并加以实现。


## 说明/提示

#### 样例解释 #1

对方防御系统有 $3$ 个，防御值为 $1000(a),2000(b),1200(c)$，己方攻击系统有 $5$ 个，攻击值为 $2100(d)，2000(e),1200(f),1000(g),1000(h)$。第 $1$ 轮攻击的最优方案是 $d$ 攻击 $b$，$e$ 攻击 $c$，$f$ 攻击 $a$，$g$ 和 $h$ 攻击对方母舰本身，造成 $2000$ 点伤害。

#### 数据范围与约定

对于 $80 \%$ 的数据，$1 \le N,M \le 1000$。

对于 $100 \%$ 的数据，$1 \le N,M \le 10 ^ 5$。


本题为转载题目。

## 样例 #1

### 输入

```
3 5 
1000 
2000 
1200 
2100 
2000 
1200 
1000 
1000```

### 输出

```
2000```

# AI分析结果



**算法分类选择**  
贪心算法

---

### **题解思路与解决难点**  
**核心逻辑**：  
1. **排序**：将敌方防御系统和我方攻击系统分别从小到大排序。  
2. **贪心匹配**：用最小的可用攻击系统破坏最小的未破坏防御系统。若攻击不足则跳过，用于后续攻击母舰。  
3. **剩余攻击求和**：所有防御系统破坏后，剩余攻击系统的攻击力总和即为最大伤害。

**关键难点**：  
1. **防御系统为0时的处理**：需跳过这些防御系统，无需消耗攻击。  
2. **攻击系统不足或无法破坏防御时输出0**：需在遍历后检查是否所有防御均被破坏。  
3. **双指针高效匹配**：通过指针同步遍历排序后的攻击和防御数组，避免双重循环。

---

### **题解评分 (≥4星)**  
1. **sjl40 (5星)**  
   - 思路清晰，代码简洁，高效处理防御为0的情况。  
   - 使用双指针直接匹配，逻辑紧凑。  
   - 示例输入解释详细，易理解。

2. **Saliеri (4星)**  
   - 代码简洁，优先处理无法击破防御的情况。  
   - 通过累加未匹配攻击直接计算剩余伤害，巧妙优化。

3. **Rbu_nas (4星)**  
   - 使用 `upper_bound` 快速定位最小可用攻击。  
   - 明确处理防御为0的特殊情况，逻辑严谨。

---

### **最优思路与技巧提炼**  
1. **排序与双指针**：  
   - 排序后，用双指针逐个匹配攻击与防御，确保贪心策略最优。  
   - 防御指针仅在后移时消耗攻击，保证最小攻击资源被使用。

2. **防御为0的处理**：  
   - 在遍历时直接跳过防御值为0的系统，不消耗攻击资源。

3. **提前终止条件**：  
   - 若攻击数量少于防御数量，直接输出0，避免无效计算。

---

### **同类型题与算法套路**  
- **通用解法**：排序后贪心匹配，最小资源消耗问题（如 P2695 骑士的工作）。  
- **类似题目**：  
  - P1223 排队接水（贪心排序最小等待时间）  
  - P1094 纪念品分组（双指针匹配分组）  
  - P2676 [USACO07DEC] Bookshelf B（排序后贪心选择）

---

### **推荐洛谷题目**  
1. **P2695 骑士的工作**  
2. **P1094 纪念品分组**  
3. **P1223 排队接水**

---

### **个人心得摘录**  
- **sjl40**：强调“用尽量小的攻击打防御，留大的打母舰”是贪心核心。  
- **Rbu_nas**：通过 `upper_bound` 快速定位，但需注意攻击必须严格大于防御。  
- **Saliеri**：未处理的攻击系统直接累加，简化代码逻辑。

---

### **可视化与算法演示**  
**动画设计**：  
1. **排序展示**：敌方防御（红色方块）和我方攻击（蓝色方块）分别排序，动态显示排序过程。  
2. **双指针匹配**：  
   - 防御指针（红色箭头）和攻击指针（蓝色箭头）逐步右移。  
   - 匹配成功时，攻击方块变灰，防御方块消失，并播放“击破”音效。  
3. **剩余攻击累加**：未匹配的蓝色方块逐个变绿，显示累计伤害值。  

**复古像素风格**：  
- **8位音效**：匹配成功时播放短促“哔”声，累加伤害时播放连续“滴答”声。  
- **Canvas绘制**：防御和攻击以不同颜色像素块排列，指针移动时有箭头动画。  

**交互功能**：  
- **步进控制**：允许单步执行，观察指针移动和匹配过程。  
- **速度调节**：滑动条控制动画速度，适应不同学习节奏。  

---

### **核心代码实现**  
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int MAXN = 1e5 + 5;
int defense[MAXN], attack[MAXN];

int main() {
    int m, n;
    cin >> m >> n;
    for (int i = 0; i < m; i++) cin >> defense[i];
    for (int i = 0; i < n; i++) cin >> attack[i];
    
    sort(defense, defense + m);
    sort(attack, attack + n);
    
    int ptr = 0;
    for (int i = 0; i < n && ptr < m; i++) {
        if (attack[i] > defense[ptr]) {
            attack[i] = 0;  // 标记为已使用
            ptr++;
        }
    }
    
    if (ptr < m) cout << 0;
    else {
        int sum = 0;
        for (int i = 0; i < n; i++) sum += attack[i];
        cout << sum;
    }
    return 0;
}
```

**代码说明**：  
- 排序后，遍历攻击数组，用最小攻击破坏最小防御。  
- 防御指针 `ptr` 记录已破坏数量，最终检查是否全部破坏。  
- 剩余攻击累加即为答案。

---
处理用时：78.00秒
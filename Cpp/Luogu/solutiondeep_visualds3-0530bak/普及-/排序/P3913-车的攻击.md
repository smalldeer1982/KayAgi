# 题目信息

# 车的攻击

## 题目描述

$N \times N$ 的国际象棋棋盘上有$K$ 个车，第$i$个车位于第$R_i$行，第$C_i$ 列。求至少被一个车攻击的格子数量。

车可以攻击所有同一行或者同一列的地方。


## 说明/提示

• 对于30% 的数据，$1 \le N \le 10^3; 1 \le K \le 10^3$；

• 对于60% 的数据，$1 \le N \le 10^6; 1 \le K \le 10^6$；

• 对于100% 的数据，$1 \le N \le 10^9; 1 \le K \le 10^6; 1 \le R_i , C_i \le N$。


## 样例 #1

### 输入

```
3 2
1 2
2 2```

### 输出

```
7```

# AI分析结果



## 【唯一算法分类】  
数学/容斥原理

---

## 【综合分析与结论】

### 核心算法流程
1. **去重统计**：对车的行列坐标分别排序后去重，得到独立行数 `sizex` 和独立列数 `sizey`  
2. **容斥计算**：被攻击格子数 = 行覆盖数 + 列覆盖数 - 行列交点数  
   $$ans = sizex \cdot n + sizey \cdot n - sizex \cdot sizey$$  
   或等价公式（补集思想）：  
   $$ans = n^2 - (n - sizex) \cdot (n - sizey)$$  

### 解决难点
- **去重效率**：通过排序 + `unique()` 或遍历去重，实现 $O(K \log K)$ 时间复杂度  
- **数据溢出**：使用 `long long` 避免 $n^2$ 计算溢出  

### 可视化设计
- **棋盘渲染**：以网格表示棋盘，红色高亮被攻击的行列，黄色标记交叉点  
- **动态标记**：逐步添加车，实时更新覆盖区域，显示公式计算过程  
- **8位像素风**：用复古调色板（红、黄、灰）区分攻击区域与空白，音效提示覆盖完成  

---

## 【题解清单 (≥4星)】

### 1. Kater_kcl (5星)
- **亮点**：STL `unique()` 简洁去重，公式推导清晰  
- **核心代码**：  
  ```cpp
  sort(x, x+k); sort(y, y+k);
  ll sizex = unique(x, x+k) - x;
  ll sizey = unique(y, y+k) - y;
  printf("%lld", n*n - (n-sizex)*(n-sizey));
  ```

### 2. lzy755277 (4星)
- **亮点**：手动遍历去重，代码可读性强  
- **关键逻辑**：  
  ```cpp
  for(i=1; i<=k; i++) {
      if(x[i]!=x[i+1]) h++;
      if(y[i]!=y[i+1]) l++;
  }
  ```

### 3. Scherzo (4星)
- **亮点**：补集思想详细推导，适合数学理解  
- **公式解释**：未被攻击区域为 $(n-sizex) \cdot (n-sizey)$  

---

## 【最优思路与技巧提炼】

### 关键步骤
1. **去重统计**：排序后统计独立行列数量  
2. **容斥公式**：直接计算或补集法（推荐后者避免溢出）  

### 同类题目
- **P1496 火烧赤壁**：区间合并求总覆盖长度  
- **P2280 激光炸弹**：二维前缀和求最大覆盖区域  
- **CF1008B Turn the Rectangles**：排序后贪心覆盖  

---

## 【可视化与算法演示】

### 动画方案
1. **初始棋盘**：灰色网格表示未被攻击  
2. **添加车**：放置车后，所在行变红，列变蓝  
3. **覆盖计算**：行/列覆盖数动态更新，交叉点变黄  
4. **公式显示**：右侧面板实时显示公式变量值  

### 复古风格设计
- **调色板**：红(#FF0000)、蓝(#0000FF)、黄(#FFFF00)、灰(#808080)  
- **音效**：  
  - 放置车时播放“滴”声  
  - 计算完成时播放8位胜利音效  

---

## 【代码实现（核心片段）】

```cpp
#include <algorithm>
using namespace std;
typedef long long ll;

ll solve(ll n, int k, vector<pair<ll, ll>>& cars) {
    vector<ll> rows, cols;
    for (auto& [r, c] : cars) {
        rows.push_back(r);
        cols.push_back(c);
    }
    sort(rows.begin(), rows.end());
    sort(cols.begin(), cols.end());
    auto sizex = unique(rows.begin(), rows.end()) - rows.begin();
    auto sizey = unique(cols.begin(), cols.end()) - cols.begin();
    return n * n - (n - sizex) * (n - sizey); // 补集公式
}
```

---
处理用时：75.02秒
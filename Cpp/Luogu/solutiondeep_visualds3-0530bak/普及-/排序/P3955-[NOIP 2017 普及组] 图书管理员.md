# 题目信息

# [NOIP 2017 普及组] 图书管理员

## 题目背景

NOIP2017 普及组 T2

## 题目描述

图书馆中每本书都有一个图书编码，可以用于快速检索图书，这个图书编码是一个正整数。 每位借书的读者手中有一个需求码，这个需求码也是一个正整数。如果一本书的图书编码恰好以读者的需求码结尾，那么这本书就是这位读者所需要的。 小 D 刚刚当上图书馆的管理员，她知道图书馆里所有书的图书编码，她请你帮她写一个程序，对于每一位读者，求出他所需要的书中图书编码最小的那本书，如果没有他需要的书，请输出 `-1`。


## 说明/提示

**数据规模与约定**

对于 $20\%$ 的数据，$1 ≤ n ≤ 2$。

另有 $20\%$ 的数据，$q = 1$。

另有 $20\%$ 的数据，所有读者的需求码的长度均为 $1$。

另有 $20\%$ 的数据，所有的图书编码按从小到大的顺序给出。

对于 $100\%$ 的数据，$1 ≤ n ≤ 1000,1 ≤ q ≤ 1000$，所有的图书编码和需求码均不超过 $10^7$。


## 样例 #1

### 输入

```
5 5 
2123 
1123 
23 
24 
24 
2 23 
3 123 
3 124 
2 12 
2 12```

### 输出

```
23 
1123 
-1 
-1 
-1 ```

# AI分析结果



## 唯一算法分类
**模拟**

## 综合分析与结论
题目核心在于快速判断图书编码后缀是否符合需求码，并找出最小值。所有题解均围绕以下要点展开：
1. **后缀判断**：通过取模运算或字符串截取，快速获取图书编码后X位。
2. **最小值筛选**：通过排序预处理或实时比较，快速定位最小值。

**核心难点**：
1. 如何高效提取图书编码的后X位（模运算与字符串处理的取舍）
2. 如何快速找到满足条件的最小值（排序预处理 vs 实时遍历）

**可视化设计思路**：
- 将图书编码以像素方块形式排列，按数值大小排序后上色（数值越小颜色越浅）
- 查询时，用高亮色块从左到右扫描编码列表
- 当发现满足 `编码%10^x == 需求码` 时，该方块闪烁并触发音效
- 右侧面板实时显示当前计算的模值（10^x）和需求码匹配结果

## 题解清单 (≥4星)
1. **The_Best_OIer（4.5星）**
   - 亮点：排序预处理 + 模数组优化，代码简洁高效
   - 关键代码：
     ```cpp
     const int mod[10] = {1,10,100,...}; // 预存模数
     sort(a+1, a+n+1);
     for(j=1; j<=n; j++) if(a[j]%mod[x]==y) break;
     ```

2. **VitrelosTia（4.2星）**
   - 亮点：字符串后缀映射预处理，思维新颖
   - 关键技巧：`s.substr(j)` 截取所有可能后缀存入map，需注意字符串比较的特殊处理

3. **Like_Amao（4.0星）**
   - 亮点：实时计算模值，逻辑直白易懂
   - 代码优势：`pow(10,x)` 直接参与运算，适合教学演示

## 最优思路或技巧提炼
1. **排序预处理**：先对图书编码升序排序，确保第一个符合条件的即为最小值
2. **模数组优化**：预存 `10^x` 值避免重复计算pow
3. **后缀截取剪枝**：字符串法中通过 `substr` 生成所有后缀映射最小值

## 同类型题与算法套路
- **后缀匹配问题**：如[P1012 拼数](https://www.luogu.com.cn/problem/P1012)需比较数字后缀拼接结果
- **最小匹配筛选**：类似[P2240 部分背包问题](https://www.luogu.com.cn/problem/P2240)的贪心选择

## 推荐相似题目
1. P1177 【模板】快速排序（排序预处理训练）
2. P1059 明明的随机数（去重与排序结合）
3. P1223 排队接水（贪心选择最小值）

## 个人心得摘录
> "当发现所有题解都写得很麻烦时，突然想到字符串截取可能更直观" —— VitrelosTia  
> "调试发现pow返回浮点数导致模运算错误，改用整数数组后AC" —— The_Best_OIer

## 可视化与算法演示
**动画方案设计**：
1. **初始化阶段**：
   - 图书编码以灰色方块随机排列
   - 点击排序按钮后，方块按数值升序从左到右滑动重组

2. **查询阶段**：
   - 输入需求码后，生成红色扫描线从左向右移动
   - 每个方块显示实时计算的 `编码%10^x` 值
   - 匹配时方块变绿并弹出数值，播放 "ding" 音效

**复古游戏化效果**：
- **像素风格**：采用FC红白机配色（#FF6B6B主色，#4ECDC4辅助色）
- **音效设计**：
  - 扫描移动：8-bit "blip" 音效（Web Audio生成方波）
  - 匹配成功：NES风格胜利音阶
  - 无结果时：短促低音 "boom"
- **积分系统**：每次快速找到答案获得连击分，动画速度随积分提升

```javascript
// 伪代码示例 - 扫描动画核心逻辑
function animateSearch(modValue, target) {
  let currentIndex = 0;
  const interval = setInterval(() => {
    if(currentIndex >= books.length) {
      showNoResult();
      clearInterval(interval);
      return;
    }
    
    const remainder = books[currentIndex] % modValue;
    highlightBlock(currentIndex);
    
    if(remainder === target) {
      flashBlock(currentIndex);
      playSuccessSound();
      clearInterval(interval);
    }
    
    currentIndex++;
  }, 500 / speed); // speed由用户调节
}
```

## 核心代码实现
**最优解法（The_Best_OIer）完整代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod[8] = {1,10,100,1000,10000,100000,1000000,10000000};
int a[1005], n, q;

int main() {
    cin >> n >> q;
    for(int i=1; i<=n; i++) cin >> a[i];
    sort(a+1, a+n+1);
    
    while(q--) {
        int x, y, ans = -1;
        cin >> x >> y;
        for(int j=1; j<=n; j++) {
            if(a[j] % mod[x] == y) {
                ans = a[j];
                break;
            }
        }
        cout << ans << endl;
    }
    return 0;
}
```

---
处理用时：107.86秒
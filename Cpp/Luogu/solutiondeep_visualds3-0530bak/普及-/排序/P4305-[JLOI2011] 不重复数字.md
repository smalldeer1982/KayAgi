# 题目信息

# [JLOI2011] 不重复数字

## 题目描述

给定 $n$ 个数，要求把其中重复的去掉，只保留第一次出现的数。

## 说明/提示

对于 $30\%$ 的数据，$n \le 100$，给出的数 $\in [0, 100]$。

对于 $60\%$ 的数据，$n \le 10^4$，给出的数 $\in [0, 10^4]$。

对于 $100\%$ 的数据，$1 \le T\le 50$，$1 \le n \le 5 \times 10^4$，给出的数在 $32$ 位有符号整数范围内。

## 样例 #1

### 输入

```
2
11
1 2 18 3 3 19 2 3 6 5 4
6
1 2 3 4 5 6
```

### 输出

```
1 2 18 3 19 6 5 4
1 2 3 4 5 6
```

# AI分析结果



### 唯一算法分类
哈希表 / 去重算法

---

### 题解思路与核心难点分析
#### 核心算法逻辑
所有题解均围绕「保留首次出现的数字」展开，核心难点在于：
1. **大数据量下的高效去重**：5e4 数据量需 O(n) 或 O(nlogn) 算法
2. **负数和极值处理**：需正确实现哈希函数的负数取模
3. **顺序保留**：不能打乱原始输入顺序

#### 关键算法对比
| 方法              | 时间复杂度 | 空间复杂度 | 实现难度 | 适用场景           |
|-------------------|------------|------------|----------|--------------------|
| unordered_map     | O(n)       | O(n)       | ⭐        | 标准库可用场景      |
| 排序+双排序去重   | O(nlogn)   | O(n)       | ⭐⭐       | 无哈希库时备用方案  |
| 手工拉链哈希表    | O(n)       | O(n)       | ⭐⭐⭐      | 需要极致性能时      |

**核心流程可视化设计**（以哈希表为例）：
1. **哈希桶高亮**：用不同颜色标记哈希桶的分布
2. **冲突检测动画**：展示拉链法处理冲突时链表增长过程
3. **顺序保留提示**：用箭头动态显示首次出现的数字位置

---

### 题解评分（≥4星）
#### 1. Rainbow_qwq（5星）
```cpp
unordered_map<int,bool> s;
if(!s[x]){ printf+标记 }
```
- **亮点**：利用 STL 特性，代码简洁高效
- **优化点**：利用 C++11 特性避免平衡树开销

#### 2. 万弘（4星）
```cpp
struct Hash{ int head[Mod],cnt; };
int pos = (x%mod+mod)%mod; // 负数修正
```
- **亮点**：手工实现拉链法哈希表，性能可控
- **难点**：需处理模数选择和链表管理

#### 3. Arghariza（4星）
```cpp
vector<int> Hash[mod];
pos = (x%mod+mod)%mod;
```
- **亮点**：用 vector 实现开放地址法，易理解
- **注意**：需预分配较大 vector 空间

---

### 最优思路提炼
**哈希表双策略**：
1. **STL 优先**：直接使用 `unordered_map` 快速实现
2. **手工哈希表**：模数选 1e4~5e4 的素数，负数取模修正：
   ```cpp
   int hash_val = (x % MOD + MOD) % MOD;
   ```

**排序法保序技巧**：
1. 结构体保存原始位置和数值
2. 按数值排序后去重
3. 按原始位置二次排序输出

---

### 类似题目推荐
1. [P1177 快速排序](https://www.luogu.com.cn/problem/P1177)（排序保序）
2. [P1918 保龄球](https://www.luogu.com.cn/problem/P1918)（哈希查找）
3. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)（基础去重）

---

### 可视化算法演示（像素版）
**Canvas 动画设计**：
```javascript
// 哈希表像素动画核心逻辑
function drawHashStep(ctx, x, hash_table) {
  let pos = (x % MOD + MOD) % MOD; // 计算哈希桶
  ctx.fillStyle = "#FF0000";        // 当前元素红色高亮
  drawBucket(ctx, pos);             // 绘制目标桶
  
  if (冲突存在) {
    ctx.fillStyle = "#00FF00";      // 冲突元素绿色标记
    drawCollisionChain(ctx, pos);   // 绘制拉链
  }
}
```
**音效设计**：
- 插入成功：8-bit "金币声"
- 哈希冲突：短促 "哔" 声

---

### 调试经验摘录
> "WA 后发现负数取模直接写 x%mod，修正为 (x%mod+mod)%mod 后 AC" —— Arghariza  
> "手工哈希表桶大小从 1e5 改为 5e4 后，速度提升 3 倍" —— skydogli

---

### 核心代码实现（手工拉链法）
```cpp
const int MOD = 50021;
struct HashTable {
    vector<int> val[MOD], nxt[MOD];
    int head[MOD], cnt;
    
    bool insert(int x) {
        int pos = (x%MOD + MOD) % MOD;
        for(int i=head[pos]; i; i=nxt[pos][i]) 
            if(val[pos][i] == x) return false;
        val[pos].push_back(x);
        nxt[pos].push_back(head[pos]);
        head[pos] = val[pos].size()-1;
        return true;
    }
};
```

---
处理用时：72.80秒
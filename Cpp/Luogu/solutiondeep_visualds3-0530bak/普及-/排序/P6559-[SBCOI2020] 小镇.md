# 题目信息

# [SBCOI2020] 小镇

## 题目背景

在人们不知道的地方，有一个小镇。  
一个，连名字都说不上来的小镇。  
季节再度进入冬季，  
那个属于雪的季节。  
在那雪下，埋葬着的，  
是只属于这个小镇的梦，与传说。  
......   
“又到了冬天啊！”  
“是啊！周围都变成白茫茫的一片了呢...”  
“唉，要是这样的日子能够永远持续下去该有多好啊。”  
“啊，永远...”  
“不过，世间又有什么是永远呢。如同雪的消融，洁白地融入大地，还来不及让人品味，如此无奈，又如此纯净......”   

在雪中，一幢幢房屋间的灯光散发出温暖的光芒。  
![](https://cdn.luogu.com.cn/upload/image_hosting/j728ebas.png)  
“以后我们还能在一起看雪吗？”  
“当然，一直可以......”

## 题目描述

小镇可以看作是一个 $n \times n$ 的网格，其中有 $k$ 个格子是房屋。    
小镇里面还有灯。每两个相邻的格子之间有一盏灯。

如果两幢房屋**相邻**，那么这两幢房屋之间的灯就会点亮。  
请问这座小镇一共有多少盏灯被点亮。

注意，本题中相邻指有公共边。

## 说明/提示

#### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/tbjkl3ul.png)  
如图，阴影格子为房屋，被描红的边为灯。

#### 数据范围

对于 $30\%$ 的数据，$1 \leq n,k \leq 100$。  
对于 $80\%$ 的数据，$1 \leq n,k \leq 5000$。  
对于 $100\%$ 的数据，$1 \le n,k \le 10^5$。  

## 样例 #1

### 输入

```
6 12
1 1
2 1
2 2
1 4
3 3
4 3
4 4
3 4
3 6
4 6
5 6
6 6```

### 输出

```
9```

# AI分析结果



---

**唯一算法分类**  
哈希表、排序

---

**综合分析与结论**  
本题核心是高效统计相邻房屋对，避免O(k²)暴力枚举。关键难点在于如何快速判断当前房屋四周是否存在其他房屋。两种主流解法：

1. **哈希查询法**  
   - 使用嵌套map或pair映射存储房屋坐标  
   - 每次插入新房屋时，查询上下左右四个方向是否已有房屋  
   - 时间复杂度O(k logk)（map查询的logk时间）  
   - 优势：思路直观，代码简洁  
   - 难点：需注意map的二维访问特性及插入顺序逻辑

2. **双排序法**  
   - 按行排序后统计同一行中的相邻列  
   - 按列排序后统计同一列中的相邻行  
   - 时间复杂度O(k logk)（两次排序）  
   - 优势：无需复杂数据结构，常数更优  
   - 难点：需理解排序后相邻元素的关联性

**可视化设计思路**  
- **哈希查询法动画**：以网格展示小镇，插入房屋时高亮当前坐标，检查四周并闪烁已存在的相邻房屋，累计计数器  
- **双排序法动画**：分两阶段展示排序后的坐标列表，用箭头连接相邻元素，动态统计符合条件的配对  
- **复古像素风格**：用16色调色板渲染房屋，灯点亮时显示黄色光晕，配8-bit音效（插入房屋时播放短音，点亮灯时播放上扬音效）

---

**题解清单 (≥4星)**  
1. **Utilokasteinn (★★★★☆)**  
   - 亮点：代码极简，利用map边插入边统计，逻辑清晰  
   - 关键点：仅需累计四个方向查询结果，无需额外处理  
   - 代码示例：  
     ```cpp
     ans += a[x-1][y] + a[x+1][y] + a[x][y+1] + a[x][y-1];
     ```

2. **犇犇犇犇（官方题解） (★★★★★)**  
   - 亮点：双排序法避免map开销，效率更优  
   - 关键点：通过两次排序将相邻房屋逻辑拆分处理  
   - 代码示例：  
     ```cpp
     sort(a+1, a+k+1, cmp1); // 行排序
     if(a[i].x==a[i+1].x && a[i].y==a[i+1].y-1) ans++;
     ```

3. **houpingze (★★★★☆)**  
   - 亮点：实时判断相邻房屋，无需后续处理  
   - 关键点：插入时立即累加四周存在状态，自然避免重复计数  
   - 代码示例：  
     ```cpp
     if(a[x-1][y]) cnt++; // 检查左邻
     ```

---

**最优思路提炼**  
1. **哈希即时统计**：插入房屋时动态检查四周，利用哈希表O(1)查询（实际为O(logk)）快速累计相邻对数  
2. **排序分组处理**：通过行列分组排序，将相邻判断转化为有序列表的相邻元素检查，减少查询次数  

---

**同类型题推荐**  
1. P1102 配对统计（坐标配对统计）  
2. P3397 地毯（二维区域覆盖统计）  
3. P1904 天际线（坐标排序处理）

---

**可视化代码片段（伪代码）**  
```javascript
// 哈希查询法动画演示
function visualize() {
  for (let house of houses) {
    highlightCurrent(house); // 高亮当前插入房屋
    checkSurroundings(house, (dir) => { // 检查四个方向
      if (exists(dir)) {
        playSound('light'); // 点亮音效
        drawLight(house, dir); // 绘制点亮灯光
        counter += 1;
      }
    });
    markHouse(house); // 标记已插入房屋
  }
}
```

---

**个人心得摘录**  
- "考试时忘记用map直接暴毙，二维数组开不下才意识到问题" → 强调数据规模意识  
- "发现每个灯会被两边计算，突然顿悟除以2的修正" → 注意统计逻辑的对称性  

---

**复古像素风实现要点**  
1. **颜色方案**：房屋用蓝色（#0000FF），点亮灯用黄色（#FFFF00），背景雪地白色（#FFFFFF）  
2. **音效设计**：  
   - 插入房屋：短促"滴"声（正弦波，440Hz，0.1s）  
   - 点亮灯：上升琶音（C4-E4-G4，各0.05s）  
3. **自动演示**：按输入顺序逐步插入房屋，每步延迟200ms，灯光点亮动画持续500ms

---
处理用时：108.58秒
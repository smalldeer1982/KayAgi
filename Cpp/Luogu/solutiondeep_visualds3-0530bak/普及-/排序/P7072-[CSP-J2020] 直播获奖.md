# 题目信息

# [CSP-J2020] 直播获奖

## 题目描述

NOI2130 即将举行。为了增加观赏性，CCF 决定逐一评出每个选手的成绩，并直播即时的获奖分数线。本次竞赛的获奖率为 $w\%$，即当前排名前 $w\%$ 的选手的最低成绩就是即时的分数线。

更具体地，若当前已评出了 $p$ 个选手的成绩，则当前计划获奖人数为 $\max(1, \lfloor p \times w \%\rfloor)$，其中 $w$ 是获奖百分比，$\lfloor x \rfloor$ 表示对 $x$ 向下取整，$\max(x,y)$ 表示 $x$ 和 $y$ 中较大的数。如有选手成绩相同，则所有成绩并列的选手都能获奖，因此实际获奖人数可能比计划中多。

作为评测组的技术人员，请你帮 CCF 写一个直播程序。

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/l453vhow.png)

---
### 数据规模与约定

各测试点的 $n$ 如下表：

| 测试点编号 | $n=$ |
| :--: | :--: |
| $1 \sim 3$ | $10$ |
| $4 \sim 6$ | $500$ |
| $7 \sim 10$ | $2000$ |
| $11 \sim 17$ | $10^4$ |
| $18 \sim 20$ | $10^5$ |


对于所有测试点，每个选手的成绩均为不超过 $600$ 的非负整数，获奖百分比 $w$ 是一个正整数且 $1 \le w \le 99$。

---
### 提示

在计算计划获奖人数时，如用浮点类型的变量（如 C/C++ 中的 `float` 、 `double`，Pascal 中的 `real` 、 `double` 、 `extended` 等）存储获奖比例 $w\%$，则计算 $5 \times 60\%$ 时的结果可能为 $3.000001$，也可能为 $2.999999$，向下取整后的结果不确定。因此，建议仅使用整型变量，以计算出准确值。

## 样例 #1

### 输入

```
10 60
200 300 400 500 600 600 0 300 200 100
```

### 输出

```
200 300 400 400 400 500 400 400 300 300```

## 样例 #2

### 输入

```
10 30
100 100 600 100 100 100 100 100 100 100```

### 输出

```
100 100 600 600 600 600 100 100 100 100```

# AI分析结果



# 算法分类与题解分析

## 1. 算法分类
**桶排序**

---

## 2. 题解思路与核心难点

### 核心算法对比
| 方法          | 时间复杂度    | 关键操作                          | 适用场景                     |
|---------------|-------------|-----------------------------------|----------------------------|
| 桶排序         | O(n*600)    | 维护分数计数桶，倒序累加判断人数    | 成绩范围有限（本题核心解法）  |
| 对顶堆         | O(n log n)  | 动态维护大小顶堆结构                | 动态查询第K大数的通用解法     |
| 插入排序       | O(n²)       | 每次插入时维护有序数组              | 仅适用于极小数据量           |
| Treap         | O(n log n)  | 平衡树维护动态有序集合              | 需要动态插入和查询的通用场景  |

### 解决难点
- **动态维护第K大数**：需实时计算前 w% 的分数线，本质是动态求第 K 大的数
- **分数相同处理**：所有同分选手均获奖，需保证累加逻辑的完整性
- **整数计算精度**：用 `p*w/100` 代替浮点运算避免精度误差

---

## 3. 高星题解评分（≥4★）

### 5★ - Eason_AC（桶排序）
- **亮点**：代码简洁高效，利用值域特性实现线性复杂度
- **代码段**：
```cpp
for(int j = 600; j >= 0; --j) {
    num += a[j];
    if(num >= pl) { printf("%d ", j); break; }
}
```

### 4★ - AzusagawaKaede（对顶堆）
- **亮点**：通用动态维护方案，可视化价值高
- **代码段**：
```cpp
void push(int num) {
    if (num >= ma_hp.top()) mi_hp.push(num);
    else ma_hp.push(num);
    qwq(); // 调整堆大小
}
```

### 4★ - Vct14（桶排序优化）
- **亮点**：减法优化判断逻辑
- **代码段**：
```cpp
cnt -= box[j];
if(cnt <= 0) { cout << j << ' '; break; }
```

---

## 4. 最优思路提炼
**桶排序核心流程**：
1. 创建 `int[601]` 分数桶
2. 每读入一个分数，对应桶计数+1
3. 从600分倒序遍历，累加人数直到≥获奖人数
4. 输出当前分数作为分数线

---

## 5. 同类题目推荐
1. P3871 中位数（对顶堆应用）
2. P1168 动态中位数（对顶堆变形）
3. P1908 逆序对（桶排序思想扩展）

---

## 6. 可视化设计

### 桶排序动画方案
```html
<div id="canvas-container">
  <canvas id="bucket-canvas"></canvas>
  <div class="control-panel">
    <button onclick="prevStep()">←</button>
    <span id="step-info">Step 0/0</span>
    <button onclick="nextStep()">→</button>
  </div>
</div>

<script>
// 初始化桶数组和状态跟踪
let buckets = new Array(601).fill(0);
let currentScore = 0, accumulated = 0;

function drawStep(score) {
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, 1200, 400);
  
  // 绘制桶（红色高亮当前分数）
  for(let i=600; i>=0; i--) {
    ctx.fillStyle = i === score ? '#FF4444' : '#4444FF';
    ctx.fillRect(i*2, 200 - buckets[i]*30, 2, buckets[i]*30);
  }
  
  // 显示累计人数
  ctx.fillText(`累计: ${accumulated}`, 1000, 50);
}
</script>
```

### 交互特性
- **颜色标记**：当前检查的分数显示为红色，已累加分数为蓝色
- **步进控制**：可单步查看每个分数的累加过程
- **音效提示**：达标时播放 "ping" 音效

---

## 7. 核心代码实现
**桶排序完整代码**：
```cpp
#include <cstdio>
int a[607], n, w;

int main() {
    scanf("%d%d", &n, &w);
    for(int p=1; p<=n; p++) {
        int x; scanf("%d", &x);
        a[x]++;
        int pl = max(1, p*w/100), num=0;
        for(int j=600; j>=0; --j) {
            num += a[j];
            if(num >= pl) { printf("%d ", j); break; }
        }
    }
    return 0;
}
```

---

## 8. 扩展思考
当成绩范围扩大到 1e5 时，可结合**线段树+二分**实现 O(n log n) 的动态查询，此时桶排序不再适用，但对顶堆方案仍能保持高效。

---
处理用时：68.65秒
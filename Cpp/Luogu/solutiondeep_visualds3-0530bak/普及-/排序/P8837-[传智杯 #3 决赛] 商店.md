# 题目信息

# [传智杯 #3 决赛] 商店

## 题目背景

disangan333 想给 disangan233 买一个礼物，于是他和你一起逛商店。

## 题目描述

有 $n$ 名同学去逛商店，店里有 $m$ 个物品，第 $i$ 人有 $w_i$ 块钱，第 $i$ 个物品价格 $c_i$ 元。

每个人至多买一个物品，每个物品只能被买一次，问最多有多少人能买到物品。

对于所有数据，$n,m \leq 10^5$，$w_i,c_i\leq 10^9$。

## 样例 #1

### 输入

```
15 20
4 3 9 10 7 7 5 3 6 1 8 6 6 1 5 
12 4 1 9 8 5 8 6 4 5 18 8 14 9 9 7 20 11 8 19 ```

### 输出

```
10```

# AI分析结果



**唯一算法分类**  
贪心算法

---

**综合分析与结论**  
**核心思路**：  
题目要求最大化购买人数。采用贪心策略，将人和物品分别按金钱和价格排序后，用双指针依次匹配。钱少的人优先购买便宜物品，确保剩余高价物品能被钱多的人购买，从而最大化总购买数。

**算法流程**：  
1. 将人的钱和物品价格分别从小到大排序。  
2. 初始化双指针 `i`（人）和 `j`（物品）为起点。  
3. 遍历所有人：若当前人的钱足够购买当前物品，计数加一，双指针后移；否则仅移动人的指针。  

**正确性证明**：  
若存在最优解中某钱少的人购买高价物品，而钱多的人购买低价物品，交换两者购买顺序仍为可行解且不减少总人数。因此，贪心策略正确。

**可视化设计**：  
- **动画方案**：  
  - 左侧展示排序后的人和钱（升序），右侧展示物品价格（升序）。  
  - 双指针动态移动，匹配成功时高亮对应人和物品，并播放“购买成功”音效。  
  - 指针移动时用箭头标记当前比较位置。  
- **复古像素风格**：  
  - 使用 8-bit 像素风格，人和物品用不同颜色方块表示。  
  - 控制面板支持暂停/继续、单步执行。  
  - 背景音乐为循环 8-bit 风格旋律，关键操作触发短音效。

---

**题解清单 (≥4星)**  
1. **Double_Light (5星)**  
   - **亮点**：代码简洁，注释清晰，双指针逻辑直观。  
   - **核心代码**：  
     ```cpp  
     while(zz1<=n && zz2<=m){  
         if(a[zz1]>=b[zz2]) cnt++, zz1++, zz2++;  
         else zz1++;  
     }  
     ```  
2. **WA_sir (4星)**  
   - **亮点**：解释贪心正确性，代码简洁。  
   - **核心代码**：  
     ```cpp  
     for(int p=1;p<=n;p++) {  
         if(w>m) break;  
         if(a[p]<b[w]) continue;  
         w++; ans++;  
     }  
     ```  
3. **Adolfo_North (4星)**  
   - **亮点**：快读优化，逻辑清晰。  
   - **核心代码**：  
     ```cpp  
     for(int i=1;i<=n && j<=m;i++) {  
         if(a[i]>=b[j]) j++, cnt++;  
     }  
     ```  

---

**最优思路提炼**  
1. **排序策略**：将人和物品分别升序排序。  
2. **双指针贪心**：钱少者优先购买最便宜可用物品，确保全局最优。  
3. **时间复杂度**：O(n log n + m log m)，适用于 1e5 数据规模。

---

**同类型题与算法套路**  
- **分配类贪心**：通过排序后匹配解决资源分配问题。  
- **类似题目**：  
  - 洛谷 P1094：纪念品分组（两人一组，最小化组数）。  
  - 洛谷 P1209：修理牛棚（木板覆盖缺口，最少木板数）。  
  - 洛谷 P4995：跳跳！（跳跃消耗体力，最大化总高度差）。

---

**推荐题目**  
1. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)  
2. [P1209 修理牛棚](https://www.luogu.com.cn/problem/P1209)  
3. [P4995 跳跳！](https://www.luogu.com.cn/problem/P4995)  

---

**个人心得摘录**  
- **踩坑提醒**：  
  - 错误尝试降序排序时需确保匹配逻辑正确（如 pxb0801 的代码）。  
  - 避免误用优先队列导致冗余操作（如 RP_INT_MAX 的题解）。  
- **调试技巧**：构造小样例验证边界条件（如钱刚好等于物品价格）。

---

**核心代码实现**  
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int n, m, a[100005], b[100005];
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= m; i++) cin >> b[i];
    
    sort(a + 1, a + n + 1);
    sort(b + 1, b + m + 1);
    
    int cnt = 0, i = 1, j = 1;
    while (i <= n && j <= m) {
        if (a[i] >= b[j]) cnt++, i++, j++;
        else i++;
    }
    cout << cnt;
    return 0;
}
```

---
处理用时：258.03秒
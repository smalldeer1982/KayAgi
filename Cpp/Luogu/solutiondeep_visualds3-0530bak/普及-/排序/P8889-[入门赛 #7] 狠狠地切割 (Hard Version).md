# 题目信息

# [入门赛 #7] 狠狠地切割 (Hard Version)

## 题目背景

**本题与 H1 的题意完全一致，区别仅在数据范围。在语言月赛中不存在 H2 题目，本题仅用于增加公开赛的区分度，并不严格遵循比赛考察范围，请酌情完成。**

## 题目描述

现给你一个长度为 $n$ 的序列 $a _ 1, \cdots, a _ n$ 和 $m$ 个互不相同的整数 $b _ 1, \cdots, b _ m$。你需要按照这 $m$ 个数对序列 $a$ 进行**狠狠地切割**。

具体的，对于一个数字 $i \in [1, n]$，如果存在一个整数 $j \in [1, m]$，使得 $a _ i = b _ j$，则将位置 $i$ 称为一个**切割点**。对序列 $a$ 中的每一个切割点，我们在这个位置进行一次**狠狠地切割**。方法是，将该位置的数字去除，然后在这个位置将其左右的**序列/片段**一分两半。

如果对**狠狠地切割**的定义有疑问，可以参照「样例 #1」及「样例解释 #1」进行理解。

你需要计算，在进行了所有可能的**狠狠地切割**后，序列被切割为了多少**片段**。

特别的，如果在切割后，某一段内没有数组，那这一段不可被叫做**片段**。同样的，如果 $1$ 或 $n$ 为切割点，其与开头和结尾之间也不存在片段。

如果对**片段**的概念有疑问，可以参照「样例 #2」及「样例解释 #2」进行理解。

## 说明/提示

### 样例 1 解释

在**狠狠地切割**前，序列 $a$ 如下所示：

$$\begin{matrix} 3 & 4 & 3 & 5 & 2 & 6 \end{matrix}$$

容易知道，第二个位置和第四个位置为切割点，我们使用 `|` 对其进行替换，代表去除工作：

$$\begin{matrix} 3 & | & 3 & | & 2 & 6 \end{matrix}$$

我们将片段进行简单的标记：

$$\begin{matrix} \overbrace{3} ^ \text{片段 1} & | & \overbrace{3} ^ \text{片段 2} & | & \overbrace{2 \quad 6} ^ \text{片段 3} \end{matrix}$$

共计 $3$ 个片段。

### 样例 2 解释

以下我们展示去除之后的序列：

$$\begin{matrix} | & 4 & | & | & 2 & | \end{matrix}$$

我们将片段进行简单的标记：

$$\begin{matrix} \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段} | & \overbrace{4} ^ \text{片段 1} & | & \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段} & | & \overbrace{2} ^ \text{片段 2} & | \overbrace{\vphantom{0}} ^ \text{\color{red}这个不是片段}\end{matrix}$$

共计 $2$ 个片段。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $a$ 序列中没有任何元素在 $b$ 中出现过。形式化的，$\forall i \in [1, n], \forall j \in [1, m], a _ i \neq b _ j$。
- 对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 5 \times 10 ^ 5$，$- 10 ^ {18} \leq a _ i, b_i \leq 10 ^ {18}$，序列 $b$ 中的元素两两不同。

### 提示
本题输入规模较大，建议考虑使用较快的读入读出方式。

## 样例 #1

### 输入

```
6 2
3 4 3 5 2 6
5 4```

### 输出

```
3```

## 样例 #2

### 输入

```
6 3
3 4 3 5 2 6
3 5 6```

### 输出

```
2```

# AI分析结果



**唯一算法分类**: 二分查找

---

### **综合分析与结论**

本题的核心在于快速判断每个元素是否为切割点，并正确统计切割后的片段数。通过对比题解，最优解法为：

1. **二分查找**：将数组 `b` 排序后，对每个 `a[i]` 使用二分查找判断是否为切割点。时间复杂度为 `O(m log m + n log m)`，适用于大数据范围。
2. **片段统计**：遍历 `a` 数组，若当前元素非切割点且下一个元素为切割点，则片段数加一。最后处理末尾元素。

**可视化设计思路**：
- **动画方案**：用像素方块表示数组元素，切割点用红色标记。遍历时，绿色高亮当前元素，若满足条件（非切割点且下一个是切割点），则生成蓝色片段块。
- **复古风格**：8-bit 像素风格，背景音乐为循环的芯片音乐。触发片段统计时播放“得分”音效。
- **交互控制**：支持暂停、步进、调节速度，对比不同算法的执行流程。

---

### **题解清单 (≥4星)**

1. **Double_Light 题解（★★★★★）**
   - **亮点**：代码简洁，直接二分查找，统计逻辑高效。正确处理边界条件（如末尾元素）。
   - **核心代码**：
     ```cpp
     bool check(long long k) {
         long long l = 1, r = m, mid;
         while (l <= r) {
             mid = (l + r) / 2;
             if (k < b[mid]) r = mid - 1;
             else if (k > b[mid]) l = mid + 1;
             else return true;
         }
         return false;
     }
     // 统计片段
     if (!check(a[n])) ans++;
     for (int i = 1; i < n; i++) {
         if (!check(a[i]) && check(a[i+1])) ans++;
     }
     ```

2. **Maxmilite 题解（★★★★）**
   - **亮点**：提出多种方法（哈希、双指针），拓展思路。双指针法预处理排序后线性扫描。
   - **核心思想**：排序 `a` 和 `b`，双指针遍历，时间复杂度 `O(n log n + m log m)`。

---

### **最优思路或技巧提炼**

1. **二分查找优化**：对大规模数据，先排序 `b` 数组，快速判断 `a[i]` 是否为切割点。
2. **片段统计技巧**：通过相邻元素关系判断片段边界，避免复杂标记。
3. **边界处理**：末尾元素单独处理，确保统计完整性。

---

### **同类型题或类似算法套路**

- **数组元素存在性判断**：如统计两数组交集、差值对等。
- **区间统计问题**：如连续区间划分、最长非切割区间等。
- **双指针与排序结合**：适用于元素匹配和区间处理。

---

### **推荐题目**

1. **P1102 A-B数对**（二分/哈希统计数对）
2. **P1918 保龄球**（二分查找应用）
3. **P1678 烦恼的高考志愿**（二分确定最近值）

---

### **个人心得摘录**

- **调试教训**：末尾元素需单独处理，否则会漏掉最后一个片段。
- **顿悟点**：相邻元素关系判断片段边界，简化统计逻辑。

---

### **核心代码实现**

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int MAX = 5e5 + 5;
long long a[MAX], b[MAX];
int n, m;

bool is_cut(long long x) {
    int l = 1, r = m;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (b[mid] == x) return true;
        else if (b[mid] < x) l = mid + 1;
        else r = mid - 1;
    }
    return false;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
    for (int i = 1; i <= m; i++) scanf("%lld", &b[i]);
    sort(b + 1, b + m + 1);
    
    int ans = 0;
    if (!is_cut(a[n])) ans++;
    for (int i = 1; i < n; i++) {
        if (!is_cut(a[i]) && is_cut(a[i+1])) ans++;
    }
    cout << ans;
    return 0;
}
```

---
处理用时：123.84秒
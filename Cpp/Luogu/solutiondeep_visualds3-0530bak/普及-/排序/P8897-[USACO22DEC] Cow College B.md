# 题目信息

# [USACO22DEC] Cow College B

## 题目描述

Farmer John 计划为奶牛们新开办一所大学！ 

![](https://cdn.luogu.com.cn/upload/image_hosting/wiy5l6d6.png)

有 $N(1 \le N \le 10^5)$ 头奶牛可能会入学。每头奶牛最多愿意支付 $c_i$ 的学费 $(1 \le c_i \le 10^6)$。 Farmer John 可以设定所有奶牛入学需要支付的学费。如果这笔学费大于一头奶牛愿意支付的最高金额，那么这头奶牛就不会入学。Farmer John 想赚尽可能多的钱，从而可以给他的讲师提供一笔可观的工资。请求出他能赚到的钱的数量，以及此时应当收取多少学费。 

## 说明/提示

### 样例 1 解释

如果 Farmer John 收费 $4$，那么 $3$ 头奶牛将会入学，从而使他赚取 $3 \times 4=12$ 的金额。

### 测试点性质

- 测试点 $2-4$ 满足 $c_i \le 1000$。
- 测试点 $5-8$ 满足 $N \le 5000$。
- 测试点 $9-12$ 没有额外限制。 

## 样例 #1

### 输入

```
4
1 6 4 6```

### 输出

```
12 4```

# AI分析结果



### 唯一算法分类
**排序 + 贪心**

---

### 综合分析与结论
#### 核心思路
题目要求选择学费使得总收入最大。关键点在于：**最优学费必然是某个奶牛愿意支付的最高学费值**。若学费非某个 $c_i$，可提高至最近的 $c_i$ 获得更高收入。因此只需枚举所有 $c_i$ 并计算对应的收入。

#### 算法流程
1. **排序**：将 $c_i$ 从小到大排序。
2. **线性扫描**：遍历每个 $c_i$，计算其对应的收入（即 `c_i × 剩余可支付的奶牛数`）。
3. **维护最大值**：记录最大收入及对应的最小学费。

#### 难点解决
- **高效计算剩余数量**：排序后，从后往前扫描，剩余奶牛数递减。例如，升序排序后，每个 $c_i$ 的剩余数量为 `n - i + 1`。
- **时间复杂度优化**：排序 $O(n \log n)$ + 线性扫描 $O(n)$，整体 $O(n \log n)$。

#### 可视化设计
- **动画方案**：以升序数组为例，逐步高亮每个 $c_i$，动态显示当前收入（如 `c_i × (n - i + 1)`），并标记最大值。
- **复古像素风格**：用 8-bit 方块表示奶牛，学费值以不同颜色显示，收入变化时播放简短音效。
- **交互控制**：允许用户步进执行，观察排序、遍历和比较过程。

---

### 题解评分（≥4星）
1. **NightStriker（★★★★★）**  
   - **亮点**：代码简洁，直接排序后线性扫描，维护剩余数量变量 `cow`。  
   - **代码可读性**：变量命名清晰，逻辑直观。  
   - **优化程度**：严格 $O(n \log n)$，适合大数据量。

2. **Ray1（★★★★★）**  
   - **亮点**：逆向思维，从小到大排序后遍历，直接计算 `n - i + 1`。  
   - **代码简洁性**：仅需排序和一次循环，无冗余操作。

3. **快斗游鹿（★★★★☆）**  
   - **亮点**：桶计数 + 去重排序，减少重复计算。  
   - **适用场景**：当 $c_i$ 重复较多时更高效。

---

### 最优思路与技巧
#### 关键思路
1. **贪心选择**：最优学费必为某个 $c_i$，避免无效枚举。
2. **排序后线性扫描**：利用排序快速定位剩余可支付奶牛数。
3. **维护剩余数量**：通过递减变量或后缀和统计当前可支付的奶牛数。

#### 代码片段
```cpp
sort(a, a + n); // 升序排序
long long ans = 0, cnt = 0, cow = n;
for (int i = 0; i < n; i++) {
    long long cur = a[i] * cow;
    if (cur > ans) {
        ans = cur;
        cnt = a[i];
    }
    cow--; // 剩余可支付奶牛数递减
}
```

---

### 类似题目
1. **[洛谷 P2637] 第一次，第二次，成交！**  
   （同题，双倍经验）
2. **[LeetCode 121] Best Time to Buy and Sell Stock**  
   （线性扫描维护最小值）
3. **[洛谷 P1908] 逆序对**  
   （排序与计数结合）

---

### 个人心得摘录
- **不开 long long 见祖宗**：收入可能高达 $10^{11}$，需用 `long long`。
- **排序方向**：升序或降序需与剩余数量维护逻辑一致，避免方向错误。

---

### 可视化设计示例
#### 像素动画流程
1. **初始画面**：奶牛以像素方块排列，右侧显示当前学费和收入。
2. **排序阶段**：方块按值从小到大移动，排序完成后高亮。
3. **扫描阶段**：指针逐个指向 $c_i$，右侧动态显示 `c_i × 剩余数`，最大值标红。
4. **音效提示**：每次更新最大值时播放上扬音效，错误操作时播放低音。

#### 交互功能
- **步进控制**：按空格键单步执行排序和扫描。
- **速度调节**：滑块控制动画速度，支持暂停/继续。

---

### 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<long long> c(n);
    for (int i = 0; i < n; i++) cin >> c[i];
    sort(c.begin(), c.end());
    long long max_profit = 0, best_fee = 0, remaining = n;
    for (int i = 0; i < n; i++) {
        long long profit = c[i] * remaining;
        if (profit > max_profit || (profit == max_profit && c[i] < best_fee)) {
            max_profit = profit;
            best_fee = c[i];
        }
        remaining--;
    }
    cout << max_profit << " " << best_fee;
    return 0;
}
```

---
处理用时：195.21秒
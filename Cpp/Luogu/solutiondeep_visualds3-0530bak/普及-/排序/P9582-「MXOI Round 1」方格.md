# 题目信息

# 「MXOI Round 1」方格

## 题目描述

小 C 和方格是好朋友。

小 C 有一个 $n$ 行 $m$ 列的方格图，每个方格中都有一个数字，其中第 $i$ 行第 $j$ 列的方格中的数字为 $a_{i,j}$。

我们定义，在这个方格图中，两个不同的方格不相邻，当且仅当这两个方格**没有公共边**。

小 C 认为，两个不同的方格互为好朋友，当且仅当这两个方格**不相邻**且**这两个方格中的数字相同**。

小 C 想让你帮忙求出，所有方格的好朋友的数量之和是多少。

## 说明/提示

#### 【样例解释 #1】

第 $1$ 行第 $1$ 列的方格共有 $3$ 个好朋友，第 $1$ 行第 $2$ 列的方格共有 $2$ 个好朋友，第 $1$ 行第 $3$ 列的方格共有 $1$ 个好朋友，第 $1$ 行第 $4$ 列的方格共有 $0$ 个好朋友；

第 $2$ 行第 $1$ 列的方格共有 $1$ 个好朋友，第 $2$ 行第 $2$ 列的方格共有 $2$ 个好朋友，第 $2$ 行第 $3$ 列的方格共有 $1$ 个好朋友，第 $2$ 行第 $4$ 列的方格共有 $1$ 个好朋友；

第 $3$ 行第 $1$ 列的方格共有 $1$ 个好朋友，第 $3$ 行第 $2$ 列的方格共有 $3$ 个好朋友，第 $3$ 行第 $3$ 列的方格共有 $1$ 个好朋友，第 $3$ 行第 $4$ 列的方格共有 $4$ 个好朋友；

所有方格的好朋友数量之和为 $20$。

#### 【样例 #2】

见附加文件中的 `square/square2.in` 与 `square/square2.ans`。

该样例满足测试点 $1$ 的限制。

#### 【样例 #3】

见附加文件中的 `square/square3.in` 与 `square/square3.ans`。

该样例满足测试点 $4$ 的限制。

#### 【样例 #4】

见附加文件中的 `square/square4.in` 与 `square/square4.ans`。

该样例满足测试点 $6$ 的限制。

#### 【样例 #5】

见附加文件中的 `square/square5.in` 与 `square/square5.ans`。

该样例满足测试点 $10$ 的限制。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le n,m \le 2000$，$1 \le a_{i,j} \le 9$。

|测试点编号|$n,m \le$|$a_{i,j} \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1\sim3$|$80$|$9$|否|
|$4\sim5$|$2000$|$1$|否|
|$6\sim7$|$2000$|$9$|是|
|$8\sim10$|$2000$|$9$|否|

特殊性质：保证任意两个相邻的方格中的数不相等。

## 样例 #1

### 输入

```
3 4
1 1 4 5
2 1 2 3
3 1 4 1```

### 输出

```
20```

# AI分析结果



### 算法分类
**计数与容斥**

---

### 题解思路与难点分析
**核心思路**  
1. **桶计数**：利用数值范围小（1-9）的特点，统计每个数字的总出现次数。
2. **总对数计算**：对于每个数字，若其出现次数为 `c`，则初始总对数为 `c*(c-1)`（所有相同数字的无序对数）。
3. **排除相邻非法对**：遍历每个格子，检查其上下左右四个相邻格子，若相邻且数字相同，则总对数减 1（每个非法对会被两侧格子各减一次）。

**解决难点**  
- **高效去重**：相邻对的非法情况需在 O(1) 时间内判断，确保整体时间复杂度为 O(nm)。
- **边界处理**：遍历时需处理矩阵边界，避免越界访问。
- **数值溢出**：总和可能超过 `int` 范围，需用 `long long`。

---

### 题解评分（≥4星）
1. **Coffee_zzz（5星）**  
   - 思路清晰，分测试点优化，代码可读性高。
   - 关键代码：先统计总对数，再遍历排除相邻情况。
2. **zzx114514（4星）**  
   - 代码简洁，直接计算每个格子的贡献。
   - 关键代码：`ans += t[...]-1` 后逐个减去相邻对。
3. **Hog_Dawa_IOI（4星）**  
   - 极简代码，高效实现核心逻辑。
   - 关键代码：`ans += num[...] - 相邻计数`，最后统一减去 `n*m`。

---

### 最优思路提炼
1. **桶计数总对数**：`sum(c[i] * (c[i]-1))`。
2. **遍历排除相邻对**：每个格子检查上下左右，若相邻且相同则总对数减 1。
3. **边界安全处理**：遍历时判断 `i±1` 和 `j±1` 是否越界。

---

### 同类型题与算法套路
- **类似问题**：统计满足条件的数对，需先计算全集再排除非法子集。
- **通用解法**：  
  - 利用桶/哈希表统计全局信息。  
  - 通过局部遍历快速排除非法情况。

---

### 推荐题目
1. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)（统计路径覆盖次数）
2. [P2671 求和](https://www.luogu.com.cn/problem/P2671)（颜色与位置关系的计数）
3. [P1197 星球大战](https://www.luogu.com.cn/problem/P1197)（逆向容斥）

---

### 个人心得摘录
- **数据溢出**：多位题解强调 `long long` 的必要性，如“不开 `long long` 见祖宗”。
- **调试技巧**：通过小样例验证相邻对的排除逻辑（如样例 1 的逐步计算）。

---

### 可视化算法设计
**动画方案**  
1. **初始化**：用不同颜色表示数字 1-9，绘制方格矩阵。
2. **总对数统计**：显示每个数字的桶计数，动态计算 `c[i]*(c[i]-1)`。
3. **相邻对排除**：高亮当前遍历的格子，红色标记相邻非法对，实时更新总对数。

**复古像素风格**  
- **颜色方案**：8-bit 调色板，每个数字对应固定颜色（如 1-蓝，2-绿）。
- **音效**：  
  - 遍历格子时播放“滴”声。  
  - 发现非法对时播放“错误”音效。  
  - 背景音乐为 8-bit 循环旋律。

**交互设计**  
- **步进控制**：支持暂停/继续，调整遍历速度。
- **自动演示**：AI 自动遍历并高亮操作，类似贪吃蛇路径。

---

### 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2005;
int n, m, a[N][N], cnt[10];
ll ans;

int main() {
    cin >> n >> m;
    for (int i=1; i<=n; i++)
        for (int j=1; j<=m; j++) {
            cin >> a[i][j];
            cnt[a[i][j]]++;
        }
    
    for (int i=1; i<=9; i++) 
        ans += 1LL * cnt[i] * (cnt[i]-1);
    
    for (int i=1; i<=n; i++)
        for (int j=1; j<=m; j++) {
            if (a[i][j] == a[i-1][j]) ans--;
            if (a[i][j] == a[i+1][j]) ans--;
            if (a[i][j] == a[i][j-1]) ans--;
            if (a[i][j] == a[i][j+1]) ans--;
        }
    
    cout << ans;
    return 0;
}
```

**代码解释**  
1. **桶计数**：`cnt[a[i][j]]++` 统计每个数字的总数。
2. **总对数**：`ans += cnt[i]*(cnt[i]-1)` 计算所有可能对数。
3. **排除相邻**：遍历每个格子，检查四个方向，若相邻且相同则减 1。

---
处理用时：157.45秒
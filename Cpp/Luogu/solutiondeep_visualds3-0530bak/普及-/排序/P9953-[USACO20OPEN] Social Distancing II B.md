# 题目信息

# [USACO20OPEN] Social Distancing II B

## 题目描述

由于高传染性的牛传染病 COWVID-19 的爆发，Farmer John 非常担忧他的奶牛们的健康。

尽管他尽了最大努力使他的 $N$ 头奶牛们（$1\le N\le 1000$）践行“社交距离”，还是有许多奶牛不幸染上了疾病。编号为 $1\ldots N$ 的奶牛们分别位于一条长直道路上的不同位置（相当于一维数轴），奶牛 $i$ 位于位置 $x_i$。Farmer John 知道存在一个半径 $R$，任何与一头被感染的奶牛距离不超过 $R$ 单位的奶牛也会被感染（然后会传染给与其距离 $R$ 单位内的奶牛，以此类推）。

不幸的是，Farmer John 并不确切知道 $R$ 的值。他只知道他的哪些奶牛被感染了。给定这个数据，求出起初感染疾病的奶牛的最小数量。 

## 说明/提示

### 样例解释 1

在这个例子中，我们知道 $R<3$，否则位于位置 $7$ 的奶牛会传染给位于位置 $10$ 的奶牛。所以，至少 $3$ 头奶牛初始时已被感染：位于位置 $1$ 和 $3$ 的两头奶牛中的一头，位于位置 $6$ 和 $7$ 的两头奶牛中的一头，以及位于位置 $15$ 的奶牛。 

## 样例 #1

### 输入

```
6
7 1
1 1
15 1
3 1
10 0
6 1```

### 输出

```
3```

# AI分析结果



---

**算法分类**：贪心算法

---

### **题解思路与算法要点**

1. **核心思路**  
   题目要求初始感染奶牛的最小数量。关键点在于确定感染半径 \( R \) 的最大可能值，使得未被感染的奶牛无法被传染。通过贪心策略，确定 \( R \) 的上界，并统计初始感染源数目。

2. **算法步骤**  
   - **排序**：按奶牛位置排序，便于后续处理。  
   - **确定 \( R \)**：遍历未感染奶牛，计算其左右最近的感染奶牛的距离，取所有距离的最小值作为 \( R \) 的上界。  
   - **统计初始感染源**：遍历感染奶牛，若当前感染奶牛与前一个感染奶牛的距离 ≥ \( R \)，则视为新的初始感染源。

3. **解决难点**  
   - 边界处理：需避免数组越界（如首尾元素）。  
   - \( R \) 的正确推导：通过未感染奶牛的位置限制 \( R \) 的最大值，确保未被感染的奶牛未被传染。

---

### **题解评分（≥4星）**

1. **作者：dabenBbx（4星）**  
   - 亮点：清晰处理边界条件，用 `i > 1` 和 `i < n` 避免越界，代码简洁。  
   - 核心逻辑：  
     ```cpp
     for (int i = 1; i <= n; i++) {
         if (a[i].z == 0) {
             if (i > 1 && a[i - 1].z == 1) 
                 mind = min(mind, a[i].d - a[i - 1].d);
             if (i < n && a[i + 1].z == 1)
                 mind = min(mind, a[i + 1].d - a[i].d);
         }
     }
     ```

2. **作者：yangjinqian（4星）**  
   - 亮点：使用 `pair` 结构，代码逻辑清晰，遍历未感染奶牛时限制范围（`i` 从 `2` 到 `n-1`）。  
   - 核心逻辑：  
     ```cpp
     for (int i = 2; i < n; i++)
         if (!a[i].s) {
             if (a[i - 1].s) minn = min(minn, a[i].x - a[i - 1].x);
             if (a[i + 1].s) minn = min(minn, a[i + 1].x - a[i].x);
         }
     ```

3. **作者：cly312（4星）**  
   - 亮点：简洁的代码结构，正确处理 \( R \) 的推导和统计。  
   - 核心逻辑：  
     ```cpp
     for (int i = 1; i <= n; i++) {
         if (a[i].b) {
             if (a[i - 1].b && a[i].x - a[i - 1].x < r) continue;
             ans++;
         }
     }
     ```

---

### **最优思路与技巧提炼**

- **贪心策略**：通过未感染奶牛的位置限制 \( R \)，尽可能增大 \( R \) 以减少初始感染源数目。  
- **边界处理**：在遍历时检查数组边界，避免越界访问。  
- **高效统计**：只需遍历两次数组（一次确定 \( R \)，一次统计初始感染源），时间复杂度 \( O(n \log n) \)。

---

### **同类型题目推荐**

1. **P1080 国王游戏**（贪心排序）  
2. **P1223 排队接水**（贪心策略）  
3. **P1842 奶牛玩杂技**（类似贪心推导）

---

### **个人心得摘录**

- **调试教训**：处理未感染奶牛的左右感染距离时，需注意数组越界问题（如首尾元素）。  
- **顿悟点**：\( R \) 的上界由所有未感染奶牛的最小距离决定，而非单个奶牛。

---

### **可视化与算法演示**

1. **动画设计**：  
   - **数轴展示**：将奶牛按位置排序后显示在横向数轴上，感染牛用红色，未感染用绿色。  
   - **高亮操作**：计算 \( R \) 时，闪烁未感染奶牛并显示左右感染距离；统计初始感染源时，高亮独立感染源。  
   - **动态传播**：用箭头表示感染传播，若两感染奶牛距离 < \( R \)，箭头连接。

2. **复古像素风格**：  
   - **颜色方案**：8位红（感染）、绿（未感染）、蓝（初始感染源）。  
   - **音效触发**：初始感染源确定时播放上扬音效，未感染奶牛处理时播放短促音效。  
   - **自动演示**：按步骤自动运行，支持暂停/继续，速度调节。

---

### **核心代码片段**

```cpp
// 确定 R 的上界
int R = INF;
for (int i = 1; i <= n; i++) {
    if (!a[i].infected) {
        if (i > 1 && a[i-1].infected) 
            R = min(R, a[i].x - a[i-1].x);
        if (i < n && a[i+1].infected)
            R = min(R, a[i+1].x - a[i].x);
    }
}

// 统计初始感染源
int ans = 0;
for (int i = 1; i <= n; i++) {
    if (a[i].infected) {
        if (a[i-1].infected && a[i].x - a[i-1].x < R) continue;
        ans++;
    }
}
```

---
处理用时：270.47秒
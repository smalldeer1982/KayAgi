# 题目信息

# [NOIP 2004 普及组] 花生采摘

## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。

**注意**：在采摘过程中不能回到路边。

## 说明/提示

noip2004普及组第2题


## 样例 #1

### 输入

```
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0```

### 输出

```
37```

## 样例 #2

### 输入

```
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```

### 输出

```
28```

# AI分析结果



---

## **算法分类**  
其他搜索（贪心策略）

---

## **综合分析与结论**  
**核心思路**：所有题解均采用贪心策略，按花生数量从大到小依次采摘，利用曼哈顿距离计算移动时间。关键点在于正确计算从当前点到下一目标点的移动时间、采摘时间，并确保剩余时间足够返回路边。  

**核心难点**：  
1. **时间计算模型**：需同时考虑移动、采摘和返回时间。首次采摘需从路边进入，后续点需计算两点间曼哈顿距离。  
2. **终止条件**：若剩余时间不足以完成移动+采摘+返回，则立即终止。  

**可视化设计**：  
- **网格动画**：以二维网格展示花生田，高亮当前采摘点，红色标记已采节点，绿色箭头显示移动路径。  
- **时间条**：实时显示剩余时间，每次移动/采摘时更新。  
- **复古像素风**：采用16色像素风格，移动时播放8-bit音效，成功/失败时触发不同音效。  
- **交互控制**：支持暂停/继续，手动步进观察时间消耗逻辑。  

---

## **题解清单 (≥4星)**  
1. **jiangXxin（4星）**  
   - **亮点**：结构体排序清晰，曼哈顿距离计算准确，注释详细。  
   - **代码**：显式处理首次进入田间逻辑，逐点模拟时间消耗。  

2. **_Arahc_（5星）**  
   - **亮点**：优先队列动态取最大值，避免显式排序；Map存储坐标，代码高效简洁。  
   - **关键代码**：  
     ```cpp  
     priority_queue<int> q;  
     while (w + x <= k) {  
         s += j;  
         j = q.top(); q.pop();  
         w += abs(c[j].x - x) + abs(c[j].y - y) + 1;  
     }  
     ```  

3. **buickboy（4星）**  
   - **亮点**：降维处理简化代码，特判首次采摘逻辑。  
   - **心得**：“采最后一株时不需要判断下一株，直接检查能否返回”。  

---

## **最优思路提炼**  
1. **动态最大值获取**：优先队列（或排序）确保每次取最大花生点。  
2. **曼哈顿距离计算**：两点间移动时间 = |x1-x2| + |y1-y2|。  
3. **时间终止条件**：剩余时间 ≥ 移动时间 + 采摘时间（1单位） + 返回时间（当前点行号）。  

---

## **同类型题与算法套路**  
- **贪心+路径计算**：按优先级处理元素，结合移动成本判断可行性。  
- **类似题目**：任务调度（选择收益最高任务，考虑时间成本）、机器人路径规划（最短时间访问关键点）。  

---

## **推荐相似题目**  
1. **P1135 奇怪的电梯**（BFS求最短按键次数）  
2. **P1443 马的遍历**（BFS计算棋盘最短路径）  
3. **P1219 八皇后**（DFS回溯处理状态冲突）  

---

## **个人心得摘录**  
- **jiangXxin**：“注意在采摘过程中不能回到路边，必须一次性完成所有移动”。  
- **_Arahc_**：“使用 `priority_queue` 必须检查队列是否为空，否则会WA第4个点”。  

---

## **可视化代码片段（JS）**  
```javascript  
// 初始化 Canvas  
const canvas = document.getElementById('grid');  
const ctx = canvas.getContext('2d');  
const CELL_SIZE = 30;  

function drawPeanut(x, y, color) {  
    ctx.fillStyle = color;  
    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);  
}  

// 移动动画  
function animateMove(start, end, time) {  
    let [x, y] = start;  
    const dx = end[0] - start[0];  
    const dy = end[1] - start[1];  
    const steps = Math.abs(dx) + Math.abs(dy);  
    // 播放移动音效  
    playSound('move');  
}  
```  

---

**复古风格控制面板**：  
- **8-bit 按钮**：用像素字体渲染“Start/Pause/Step”按钮。  
- **音效触发**：`playSound('success')` 在采到花生时播放，音效为短促方波声。  
- **自动演示**：AI按优先级自动选择下一个点，路径高亮显示。

---
处理用时：68.88秒
# 题目信息

# 平台

## 题目描述

空间中有一些平台。给出每个平台的位置，请你计算从每一个平台的边缘落下之后会落到哪一个平台上。

注意，如果某两个平台的某个两边缘横坐标相同，物体从上面那个平台落下之后将不会落在下面那个平台上（即平台的范围是一个开区间，不包含端点）。平台**可能会重叠**。

从平台下落时视作从平台下方开始下落，也就是说不会落到高度相同的平台上。**如果有两个平台的高度相同且都可以被落到的话，那么会落到编号靠前的那个平台。**

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/qeknowf7.png)

## 样例 #1

### 输入

```
5
2 0 2
4 1 3
3 1 3
5 3 4
1 1 5
```

### 输出

```
0 5
1 5
1 5
5 5
0 0
```

# AI分析结果



## 算法分类
**其他搜索**

---

## 题解思路与解决难点
### 核心思路
对于每个平台的左右边缘，暴力枚举所有其他平台，找到符合以下条件的平台：
1. 高度低于当前平台
2. 区间覆盖当前平台的边缘（开区间）
3. 在满足条件中高度最高，且编号最小

### 解决难点
1. **区间端点处理**：边缘落在其他平台区间时需满足严格开区间（`左 < x < 右`）
2. **高度相同处理**：当多个平台高度相同时，优先选择编号更小的
3. **重叠平台处理**：可能存在多个候选平台，需按规则筛选最优解

---

## 题解评分（≥4星）

### 1. kevin_y（5星）
- **亮点**：代码极简，直接双重循环暴力枚举，通过条件判断快速筛选候选平台
- **关键代码**：
  ```cpp
  for(int j=1;j<=n;j++) 
    if(a[j]<a[i]&&b[j]<b[i]&&c[j]>b[i])
      if(a[sum1]<a[j])sum1=j;
  ```

### 2. JamlainHamstone（5星）
- **亮点**：通过排序预处理解决高度相同的问题，确保编号小的优先
- **关键代码**：
  ```cpp
  bool cmp(node a,node b){
    if(a.h!=b.h) return a.h > b.h;
    return a.id < b.id; // 高度相同时按编号升序
  }
  ```

### 3. 野菜汤（4星）
- **亮点**：清晰注释解释条件判断逻辑，适合初学者理解
- **关键代码**：
  ```pascal
  if (h[i]>h[j] and l[i]>l[j] and l[i]<r[j] and h[j]>x) then
    a[i].la := j; x := h[j];
  ```

---

## 最优思路提炼
1. **暴力枚举**：对每个平台的左右端点遍历所有其他平台
2. **条件筛选**：通过`h[j] < h[i]`和区间覆盖判断快速过滤无效候选
3. **优先级处理**：当多个平台符合条件时，优先选择高度最高且编号最小的
4. **排序优化**：按高度降序+编号升序排序，可提前终止搜索

---

## 同类型题与算法套路
1. **区间覆盖问题**：如「接雨水」中寻找左右边界
2. **优先级筛选问题**：如「任务调度」中按优先级选择任务
3. **暴力剪枝策略**：类似「两数之和」的暴力枚举优化

**推荐题目**：  
- [洛谷 P1904] 天际线问题  
- [洛谷 P1880] 石子合并（区间动态规划）  
- [LeetCode 56] 合并区间

---

## 个人心得摘录
- **CeLaMbDa**：*“没考虑平台重叠导致WA，必须严格判断区间端点”*
- **JamlainHamstone**：*“高度相同时按编号排序是AC的关键，否则只有50分”*
- **深海鱼的眼泪**：*“二重循环+剪枝优化足以通过，无需复杂数据结构”*

---

## 可视化与算法演示
### 搜索过程动画设计
1. **网格布局**：将平台按高度降序排列在垂直轴上，水平轴表示坐标范围
2. **颜色标记**：
   - 当前平台：红色边框
   - 候选平台：绿色高亮
   - 无效平台：灰色半透明
3. **下落模拟**：从当前平台边缘绘制下坠轨迹，动态显示候选平台筛选过程

### 复古游戏化实现
- **像素风格**：使用16色调色板，平台显示为不同颜色的横条
- **音效设计**：
  - `访问新平台`：8-bit "哔"声
  - `找到解`：胜利音效（类似《超级玛丽》吃到金币）
  - `无解`：低沉错误音
- **自动演示**：按空格键逐步执行，Enter键自动播放

```javascript
// 示例代码（Canvas绘制平台）
function drawPlatform(ctx, x, y, w, isCurrent) {
  ctx.fillStyle = isCurrent ? "#FF0000" : "#00FF00";
  ctx.fillRect(x, y, w, 10); // 平台显示为矩形
}
```

---

## 核心代码实现
### kevin_y的暴力筛选逻辑
```cpp
for (int i=1; i<=n; i++) {
  int left_target=0, right_target=0;
  for (int j=1; j<=n; j++) {
    // 左端点筛选
    if (h[j] < h[i] && l[j] < l[i] && r[j] > l[i]) {
      if (h[j] > h[left_target]) left_target = j;
    }
    // 右端点筛选（同理）
  }
  cout << left_target << " " << right_target << endl;
}
```

### JamlainHamstone的排序优化
```cpp
sort(platforms, platforms+n, [](const Platform& a, const Platform& b){
  return a.h > b.h || (a.h == b.h && a.id < b.id);
});

for (int i=0; i<n; i++) {
  for (int j=i+1; j<n; j++) { // 只需检查后续更低平台
    if (platforms[j].l < platforms[i].l && platforms[j].r > platforms[i].l) {
      ans_left[i] = platforms[j].id;
      break; // 找到即停止
    }
  }
}
```

---
处理用时：66.23秒
# 题目信息

# [NOIP 2008 提高组] 火柴棒等式

## 题目描述

给你 $n$ 根火柴棍，你可以拼出多少个形如 $A+B=C$ 的等式？等式中的 $A$、$B$、$C$ 是用火柴棍拼出的整数（若该数非零，则最高位不能是 $0$）。用火柴棍拼数字 $0\sim9$ 的拼法如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/p5hsawt2.png)

注意：

1. 加号与等号各自需要两根火柴棍；
2. 如果 $A\neq B$，则 $A+B=C$ 与 $B+A=C$ 视为不同的等式（$A,B,C\geq0$）；
3. $n$ 根火柴棍必须全部用上。


## 说明/提示

【输入输出样例 1 解释】

$2$ 个等式为 $0+1=1$ 和 $1+0=1$。

【输入输出样例 2 解释】

$9$ 个等式为

$0+4=4$、$0+11=11$、$1+10=11$、$2+2=4$、$2+7=9$、$4+0=4$、$7+2=9$、$10+1=11$、$11+0=11$。

noip2008 提高第二题

## 样例 #1

### 输入

```
14```

### 输出

```
2```

## 样例 #2

### 输入

```
18```

### 输出

```
9```

# AI分析结果



# 算法分类
其他搜索

# 题解思路、算法要点与解决难点

## 核心思路
通过预处理各数字火柴棒数量，双重循环枚举所有可能的 A 和 B，计算 C = A+B，并验证总火柴棒数是否等于 n-4（扣除加号与等号的 4 根）。关键在于枚举范围的合理选择与预处理优化。

## 算法要点
1. **预处理**：将 0-9 每个数字的火柴棒数量存入数组，并预处理 0~2000 内每个数的总火柴数。
2. **枚举范围**：根据题目条件，A 和 B 的枚举范围上限设为 1000 或 1111，确保覆盖所有可能的解。
3. **条件验证**：对每个 (A, B) 组合，计算 A、B、C=A+B 的火柴棒总数，判断是否等于 n-4。

## 解决难点
- **范围确定**：通过分析火柴数限制，确定枚举到 1000 即可覆盖所有可能的解。
- **预处理优化**：避免重复计算每个数的火柴数，通过查表提升效率。
- **顺序处理**：正确处理 A 和 B 的顺序问题，确保不同顺序的组合被正确计数。

# 题解评分 (≥4星)

1. **hilsinleri的题解（4.5星）**  
   - 亮点：代码简洁，直接枚举所有组合，未预处理但效率仍高。
   - 优化点：可预处理数组进一步提升速度。

2. **King_and_Grey的题解（4.5星）**  
   - 亮点：预处理每个数的火柴数，大幅减少重复计算。
   - 关键代码：预处理数组 `a[2000]`，双重循环查表验证。

3. **qhr2023的题解（4星）**  
   - 亮点：极简代码，递归计算火柴数，适合小范围数据。
   - 注意点：递归可能在大数据时影响效率。

# 最优思路或技巧提炼
- **预处理数组**：提前计算每个数的火柴数，减少重复计算。
- **双重循环剪枝**：通过合理枚举范围（如 0~1000），确保覆盖所有可能解。
- **顺序处理优化**：通过 j 从 i 开始循环，利用对称性减少计算量，同时避免重复计数。

# 同类型题或类似算法套路
- **枚举优化**：如洛谷 P1217（回文质数），通过预处理和范围剪枝优化枚举。
- **数学模拟**：如洛谷 P1618（三连击数），需枚举并验证数学条件。

# 推荐相似题目
1. P1217 [USACO1.5]回文质数  
2. P1618 三连击（升级版）  
3. P1036 [NOIP2002 普及组]选数  

# 可视化与算法演示
- **动画设计**：以网格展示 A 和 B 的枚举过程，符合条件的点高亮为绿色，并动态显示当前总解数。
- **复古效果**：8-bit 像素风格，每次验证成功时播放“得分”音效，背景循环轻快芯片音乐。
- **交互控制**：允许调整枚举速度，单步执行观察验证过程，突出显示当前 A、B、C 的火柴数计算。

# 核心代码实现（预处理+枚举）
```cpp
#include <cstdio>
int num[10] = {6,2,5,5,4,5,6,3,7,6}; // 0-9的火柴数

int get_sticks(int x) {
    if (x == 0) return num[0];
    int sum = 0;
    while (x) {
        sum += num[x % 10];
        x /= 10;
    }
    return sum;
}

int main() {
    int n, ans = 0;
    scanf("%d", &n);
    for (int i = 0; i <= 1000; ++i)
        for (int j = 0; j <= 1000; ++j)
            if (get_sticks(i) + get_sticks(j) + get_sticks(i + j) == n - 4)
                ans++;
    printf("%d", ans);
    return 0;
}
```

---
处理用时：159.10秒
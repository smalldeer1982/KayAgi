# 题目信息

# [USACO1.1] 坏掉的项链 Broken Necklace

## 题目描述

你有一条由 $n$ 个红色的，白色的，或蓝色的珠子组成的项链，珠子是随意安排的。 这里是 $n=29$ 的两个例子:

![](https://cdn.luogu.com.cn/upload/image_hosting/i7imvc0g.png) 

第一和第二个珠子在图片中已经被作记号。

图片 A 中的项链可以用下面的字符串表示：

`brbrrrbbbrrrrrbrrbbrbbbbrrrrb`

假如你要在一些点打破项链，展开成一条直线，然后从一端开始收集同颜色的珠子直到你遇到一个不同的颜色珠子，在另一端做同样的事(颜色可能与在这之前收集的不同)。 确定应该在哪里打破项链来收集到最大数目的珠子。

例如，在图片 A 中的项链中，在珠子 $9$ 和珠子 $10$ 或珠子 $24$ 和珠子 $25$ 之间打断项链可以收集到 $8$ 个珠子。

白色珠子什么意思?

在一些项链中还包括白色的珠子(如图片B) 所示。

当收集珠子的时候，一个被遇到的白色珠子可以被当做红色也可以被当做蓝色。

表现含有白珠项链的字符串将会包括三个符号 `r`，`b`，`w` 。

写一个程序来确定从一条被给出的项链可以收集到的珠子最大数目。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$3\le n \le 350$

题目翻译来自NOCOW。

USACO Training Section 1.1

## 样例 #1

### 输入

```
29 
wwwbbrwrbrbrrbrbrwrwwrbwrwrrb
```

### 输出

```
11```

# AI分析结果



**算法分类**：其他搜索

---

### **题解思路、算法要点与解决难点**

**核心思路**：  
- **环形处理**：将字符串复制为 2~3 倍长度，模拟环状结构，避免复杂的边界判断。  
- **枚举断点**：遍历每个可能的断点，向左右两个方向扩展，统计同色珠子（白色可视为任意颜色）。  
- **颜色动态处理**：当遇到白色时，尝试将其视为红/蓝两种颜色，取最大值作为当前断点的最优解。  

**解决难点**：  
1. **白色珠子的灵活处理**：需动态决定白色珠子代表的颜色，确保最大连续长度。  
2. **环形结构遍历**：通过复制字符串将环形转为线性，简化遍历逻辑。  
3. **时间复杂度优化**：部分题解通过动态规划预处理左右连续长度，避免重复计算。  

---

### **题解评分（≥4星）**

1. **青衫白叙（5星）**  
   - **亮点**：单次遍历完成左右统计，通过 `a+b-w` 和 `b=w+1` 巧妙处理白色，代码简洁高效。  
   - **代码片段**：  
     ```cpp
     for(int i=0;i<n<<1;i++) {
         if(s[i]=='w') {b++;w++;} 
         else if(s[i]==c) {b++;w=0;}
         else { ans=max(ans,a+b); a=b-w; b=w+1; w=0; c=s[i]; }
     }
     ```

2. **w_y_c（4星）**  
   - **亮点**：通过三倍字符串处理环形，枚举断点时分别向前后搜索，逻辑清晰。  
   - **代码片段**：  
     ```cpp
     a = a + a + a; // 复制三次
     for(int i=n;i<2*n;i++) { 
         if(a[i] == 'w') ans = max(尝试红/蓝两种可能); 
         else ans = max(ans, f(i)); 
     }
     ```

3. **田阙西（4星）**  
   - **亮点**：动态规划预处理左右最大红/蓝长度，合并计算时直接取 `max(lR[i], lB[i]) + max(rR[i+1], rB[i+1])`。  
   - **代码片段**：  
     ```cpp
     for(int i=1;i<=n*2;i++) { 
         if(c[i]=='w') lR[i]=lR[i-1]+1, lB[i]=lB[i-1]+1; 
         else if(c[i]=='r') lR[i]=lR[i-1]+1; 
         else lB[i]=lB[i-1]+1; 
     }
     ```

---

### **最优思路提炼**

1. **环形处理技巧**：复制字符串至 2~3 倍长度，避免模运算。  
2. **动态颜色决策**：遇到白色时，分别尝试红/蓝两种可能性，取最大值。  
3. **预处理优化**：通过动态规划预处理左右连续长度，减少重复计算。  

---

### **同类型题推荐**

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)  
2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（优先队列的搜索策略）  
3. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)（连通块的 BFS 搜索）  

---

### **可视化与算法演示**

**动画方案**：  
1. **环形结构展示**：将项链排列为圆形，高亮当前断点并展开为直线。  
2. **搜索过程**：  
   - **颜色动态标记**：红色、蓝色块表示珠子，白色块闪烁提示可转换。  
   - **左右扩展**：用箭头从断点向两侧延伸，实时显示已收集的珠子数。  
3. **复古像素风格**：  
   - **颜色方案**：红（#FF0000）、蓝（#0000FF）、白（#FFFFFF）。  
   - **音效**：收集珠子时播放 8-bit 音效，找到最大值时播放胜利旋律。  

**代码片段（Canvas 绘制）**：  
```javascript
function drawNecklace(beads) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  beads.forEach((bead, i) => {
    ctx.fillStyle = bead === 'r' ? '#FF0000' : bead === 'b' ? '#0000FF' : '#FFFFFF';
    ctx.fillRect(i * 10, 50, 8, 8); // 绘制像素风格珠子
  });
}
```

---

### **个人心得摘录**

- **青衫白叙**：  
  > “当遇到白色时，将其并入左边或右边会影响后续计算，必须通过 `a = b - w` 和 `b = w + 1` 动态调整，这是代码最精妙的部分。”  
- **Dvelpro**：  
  > “暴力枚举时，若断点两侧都是白色，需分别尝试红/蓝组合，否则会漏掉最优解。”  

---

### **代码实现（青衫白叙精简版）**

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
char s[700],c;
int n,a,b,w,ans;
int main(){
    scanf("%d%s",&n,s);
    memcpy(s+n,s,n);
    for(int i=0;i<n<<1;i++){
        if(s[i]=='w') b++,w++;
        else if(s[i]==c) b++,w=0;
        else ans=max(ans,a+b),a=b-w,b=w+1,w=0,c=s[i];
    }
    printf("%d\n",min(max(ans,a+b),n));
    return 0;
}
```

---
处理用时：70.74秒
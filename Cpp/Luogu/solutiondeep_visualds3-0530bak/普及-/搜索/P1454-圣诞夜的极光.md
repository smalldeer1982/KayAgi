# 题目信息

# 圣诞夜的极光

## 题目背景

圣诞夜系列~~


## 题目描述

圣诞老人回到了北极圣诞区，已经快到 12 点了。也就是说极光表演要开始了。这里的极光不是极地特有的自然极光景象。而是圣诞老人主持的人造极光。

轰隆隆 …… 烟花响起（来自中国的浏阳花炮之乡）。接下来就是极光表演了。

人造极光其实就是空中的一幅幅 $n\times m$ 的点阵图像。只是因为特别明亮而吸引了很多很多小精灵的目光，也成为了圣诞夜最美丽的一刻。

然而在每幅 $n \times m$ 的点阵图像中，每一个点只有发光和不发光两种状态。对于所有的发光的点，在空中就形成了美丽的图画。而这个图画是以若干个（$s$ 个）图案组成的。对于图案，圣诞老人有着严格的定义：对于两个发光的点，如果他们的曼哈顿距离（对于 $A(x_1, y_1)$ 和 $B(x_2, y_2)$ ，$A$ 和 $B$ 之间的曼哈顿距离为 $|x_1-x_2|+|y_1-y_2|$ ）小于等于 $2$。那么这两个点就属于一个图案 …… 小精灵们一边欣赏着极光，一边数着每一幅极光图像中的图案数。伴着歌声和舞蹈，度过了美丽的圣诞之夜。^_^

## 说明/提示

$1 \le n,m \le 100$。

DFS~~

## 样例 #1

### 输入

```
19 48
------------------------------------------------
---####-----#-----#----------------------####---
--######----#-----#---------------------######--
-########--#-#---#-#####--#-##-##---#--########-
-###--###--#-#---#-#----#-##-##--#--#--###--###-
-###--###--#--#-#--######-#--#---#-#---###--###-
-########--#--#-#--#------#--#----##---########-
--######---#---#---######-#--#-----#----######--
---####----------------------------#-----####---
----------------------------------#-------------
------------------------------------------------
---###--#--------#------#-----------------------
--#---#-#---------------#-----------------------
-#------#-##--#-##--##-###-#-##-###--###-#--##--
-#------##--#-##-#-#----#--##--#---##---##-#----
-#------#---#-#--#--#---#--#---#---##----#--#---
--#---#-#---#-#--#---#--#--#---#---##---##---#--
---###--#---#-#--#-##---#--#---#---#-###-#-##---
------------------------------------------------```

### 输出

```
4```

# AI分析结果



# 圣诞夜的极光 - 题解分析与可视化方案

**唯一算法分类**：DFS/BFS（基于曼哈顿距离的特殊连通块搜索）

---

## 算法要点与解决难点

### 核心思路
题目本质是求**曼哈顿距离≤2的发光点组成的连通块数量**。与传统四方向连通块不同，每个点需要检测12个可能方向（横向/纵向两步、对角线一步等）。

### 关键难点
1. **方向数组生成**：需覆盖所有曼哈顿距离≤2的情况（12个方向）
2. **搜索策略选择**：DFS/BFS均可，需正确处理边界条件
3. **访问标记优化**：直接修改原数组或使用独立标记数组

---

## 题解评分（≥4星）

1. **欢语_暗影（DFS/BFS）⭐⭐⭐⭐⭐**
   - 亮点：完整实现DFS/BFS双解法，方向数组精准覆盖12个方向
   - 代码清晰，采用字符数组直接修改实现标记优化
   - 样例通过验证，时间复杂度O(nm)

2. **Hamster_Air（DFS）⭐⭐⭐⭐**
   - 方向数组设计合理，采用独立`visited`数组标记
   - 代码含详细注释，适合教学展示
   - 采用`ios::sync_with_stdio(false)`加速IO

3. **顾z（DFS）⭐⭐⭐⭐**
   - 图文结合解释曼哈顿距离的12个方向
   - 代码含染色法思路（修改原数组为'-'）
   - 采用inline优化递归性能

---

## 最优思路与技巧提炼

### 核心算法
```cpp
// 12方向数组（横向/纵向两步+对角线一步）
const int dx[] = {-2,2,-1,1,0,0,0,0,1,1,-1,-1};
const int dy[] = {0,0,0,0,-1,1,-2,2,1,-1,-1,1};

void dfs(int x, int y) {
    a[x][y] = '-'; // 染色标记
    for(int i=0; i<12; i++) {
        int nx = x + dx[i], ny = y + dy[i];
        if(nx>=1 && nx<=n && ny>=1 && ny<=m && a[nx][ny]=='#')
            dfs(nx, ny);
    }
}
```

### 优化技巧
- **方向数组预计算**：提前存储所有合法移动方向
- **原数组染色法**：直接修改原数组避免额外空间开销
- **边界检查前置**：在递归前判断坐标合法性

---

## 同类型题拓展
1. **P1451 求细胞数量**（四方向连通块）
2. **P1162 填涂颜色**（闭合区域标记）
3. **P1141 01迷宫**（记忆化连通块查询）

---

## 可视化方案设计

### 动画演示要点
1. **网格绘制**：Canvas绘制n×m网格，发光点显示为黄色像素块
2. **搜索过程**：
   - 当前访问节点：红色闪烁方块
   - 待访问队列：蓝色边框标记
   - 已访问区域：渐变为灰色
3. **方向指示**：用箭头线显示12个检测方向

### 复古游戏化实现
```javascript
// 伪代码示例
class PixelSearch {
    constructor() {
        this.grid = new PixelGrid(100, 100); // 模拟FC显示效果
        this.sfx = new RetroSFX(); // 8-bit音效库
    }

    bfsStep() {
        const current = queue.dequeue();
        this.grid.highlight(current, RED);
        this.sfx.play('move');

        for(let dir of directions) {
            const next = current + dir;
            if(this.grid.isValid(next) && !visited[next]) {
                queue.enqueue(next);
                this.grid.mark(next, BLUE);
                this.sfx.play('ping');
            }
        }
    }
}
```

### 交互功能
- **速度控制**：滑块调节动画速度（50ms-2000ms）
- **模式切换**：DFS/BFS对比演示
- **音效开关**：启用/禁用搜索音效
- **自动演示**：AI自动执行完整搜索过程

---

## 代码实现（核心DFS）
```cpp
#include <iostream>
using namespace std;

const int dx[] = {-2,2,-1,1,0,0,0,0,1,1,-1,-1};
const int dy[] = {0,0,0,0,-1,1,-2,2,1,-1,-1,1};
char a[105][105];
int n, m, ans;

void dfs(int x, int y) {
    if(x<1 || x>n || y<1 || y>m || a[x][y]!='#') return;
    a[x][y] = '-';
    for(int i=0; i<12; i++)
        dfs(x+dx[i], y+dy[i]);
}

int main() {
    cin >> n >> m;
    for(int i=1; i<=n; i++)
        for(int j=1; j<=m; j++)
            cin >> a[i][j];
    
    for(int i=1; i<=n; i++)
        for(int j=1; j<=m; j++)
            if(a[i][j] == '#') {
                ans++;
                dfs(i, j);
            }
    
    cout << ans;
    return 0;
}
```

---

## 个人心得
- **方向验证**：通过数学计算验证12个方向的曼哈顿距离≤2
- **IO优化**：大规模数据时使用`scanf`替代`cin`可提升效率
- **边界处理**：将数组从(1,1)开始存储避免负下标问题

通过本案例，深入理解了非传统连通块问题的处理方式，灵活应用搜索算法的核心思想。

---
处理用时：76.59秒
# 题目信息

# 选书

## 题目描述

学校放寒假时，信息学奥赛辅导老师有 $1,2,3,\cdots,x$ 本书，要分给参加培训的 $x$ 个人，每人只能选一本书，但是每人有两本喜欢的书。

老师事先让每个人将自己喜欢的书填写在一张表上。然后根据他们填写的表来分配书本，希望设计一个程序帮助老师求出所有可能的分配方案，使每个学生都满意。

## 说明/提示

### 数据范围及约定

对于全部数据，$1\le x\le 20$。


$\text{update 2022/03/07}$，阮行止

本题原始数据中，最后一个数据点的 x 为 $0$，期望输出为  $0$。考虑到这个数据不合理，予以删去。现在提交这个题目不会遇到 $x=0$ 的数据点。




## 样例 #1

### 输入

```
5
1 3
4 5
2 5
1 4
3 5```

### 输出

```
2```

# AI分析结果



### 唯一算法分类：DFS

---

### 算法分析与结论

#### 核心思路
题目本质是求二分图完美匹配的数量。由于 x ≤ 20，主流解法采用 DFS 回溯法，枚举每个人的两种选择并剪枝。部分题解还提出图论解法，将问题转化为连通块数量问题。

#### 解决难点
1. **全排列陷阱**：直接生成全排列复杂度 O(x!) 不可行（x=20 时 2.4e18 次操作）
2. **状态压缩优化**：用二进制位标记已选书籍（如 _louhc 的解法）
3. **图论转化**：将喜好关系建模为图，通过连通块特性快速计算答案（Hope2075 解法）

#### 最优思路
**DFS + 双选择剪枝**：对每个人尝试两本喜欢的书，使用数组标记已选书籍，时间复杂度 O(2^x)，x=20 时约 1e6 次操作，实际运行时间可控。

---

### 高星题解推荐（≥4星）

1. **hsfzLZH1（5星）**
   - 思路清晰，直接存储每人喜欢的书，DFS 时仅检查两本书
   - 代码简洁，时间复杂度最优
   ```cpp
   void dfs(int x) {
     if (x == n+1) { ans++; return; }
     if (!tf[a[x][0]]) tf[a[x][0]]=1, dfs(x+1), tf[a[x][0]]=0;
     if (!tf[a[x][1]]) tf[a[x][1]]=1, dfs(x+1), tf[a[x][1]]=0;
   }
   ```

2. **Hope2075（5星）**
   - 创新图论解法，时间复杂度 O(n)
   - 将问题转化为连通块判断，答案即 2^(连通块数)
   ```cpp
   void dfs(int id, int p) {
     gid[id] = p;
     for (int i=head[id]; i; i=next[i])
       if (!gid[ver[i]]) dfs(ver[i], p);
   }
   ```

3. **Baihua（4星）**
   - 标准回溯模板，易理解
   - 显式处理 x=0 的边界条件
   ```cpp
   void dfs(int xx) {
     if (xx == x+1) t++;
     else for (int j=0; j<=1; j++)
       if (!vis[a[xx][j]]) vis[a[xx][j]]=1, dfs(xx+1), vis[a[xx][j]]=0;
   }
   ```

---

### 可视化算法设计

#### 搜索过程动画
1. **节点表示**：用网格展示 x 个人，每人下方显示两本可选书
2. **颜色标记**：
   - 绿色：当前正在选择的人
   - 红色：已选书籍
   - 灰色：不可选书籍
3. **回溯演示**：当选择路径无法继续时，显示路径回退动画

#### 8位像素风格实现
```javascript
// Canvas 绘制核心逻辑
function drawStep(person, book, isBacktrack) {
  ctx.fillStyle = isBacktrack ? "#FF0000" : "#00FF00";
  ctx.fillRect(person*32, 0, 32, 32); // 高亮当前人物
  ctx.fillStyle = "#FFFFFF";
  ctx.fillText(`选书:${book}`, person*32, 48);
}
```

#### 音效设计
- 选择书籍：8-bit "beep" 音效（[JSFiddle 示例](https://jsfiddle.net/3g1mascz/)）
- 找到方案：经典 FC 过关音效
- 回溯：短促低音

---

### 相似题目推荐
1. P1706 全排列问题（DFS 基础）
2. P1219 八皇后（回溯剪枝）
3. P1120 小书童（图论建模）

---

### 总结
**DFS 双选择剪枝**是本题最实践友好的解法，代码简洁且效率足够。图论解法虽理论复杂度更低，但需要深入数学分析。可视化时可重点展示递归树与回溯过程，帮助理解搜索算法的核心思想。

---
处理用时：85.24秒
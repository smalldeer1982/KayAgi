# 题目信息

# [CRCI 2008] PLATFORME 平板

## 题目描述

为了进行一种游戏，现决定搭造一些平板，而各个平板的地址已经选定。基于最普遍的认识，没有任何支持物的平板不可能漂浮在空中。说的更精确些，任意一平板的两端必需有支柱或者它在另一块平板上。

你会得到各个平板在坐标系中的坐标（如左下图）。每一块平板的坐标都是由它的高度（与地板间的垂直距离）和它的水平方位（开始和结束）决定的。每个支柱都距它支撑的平板的边缘半个单位（如图）。

算出支持所有平板的支柱的总长度。

 ![](https://cdn.luogu.com.cn/upload/pic/994.png) 



## 样例 #1

### 输入

```
3

1 5 10

3 1 5

5 3 7

```

### 输出

```
14```

# AI分析结果



## 算法分类
**其他搜索**

---

## 综合分析与结论
### 核心思路
题目核心是计算每个平板端点下方的最大支撑高度。所有题解围绕以下核心逻辑展开：
1. **排序预处理**：按平板高度升序排序，确保低层平板先处理。
2. **支撑高度查询**：对每个平板的左右端点，查询下方最高支撑点高度（可能是其他平板或地面）。
3. **高效区间查询**：通过暴力遍历、数组模拟或线段树实现快速查询和更新。

### 关键难点与解决方案
1. **端点边界处理**：支柱位于端点内侧0.5单位，通过坐标扩大两倍（如 `x1*2`）避免浮点运算。
2. **高效查询支撑高度**：
   - **暴力法**：遍历所有平板，复杂度 O(n²)，适合小数据。
   - **线段树**：维护区间最大值，复杂度 O(n logH)，可扩展到大范围数据。
   - **数组模拟**：直接记录每个坐标的最大高度，复杂度 O(n*坐标范围)。

### 可视化设计思路
1. **动画效果**：展示平板按高度排序后逐个放置的过程，用不同颜色表示高度差异。
2. **线段树操作**：高亮当前查询的区间（如左右端点位置），动态显示区间最大值更新。
3. **像素风格**：用8位网格表示坐标轴，支柱长度以不同颜色方块堆叠呈现，音效提示查询/更新操作。

---

## 高分题解清单 (≥4星)
### 1. Makasukaka (线段树解法) ⭐⭐⭐⭐⭐
- **亮点**：线段树高效处理区间查询，支持大规模数据扩展。代码结构清晰，注释详细。
- **核心代码**：
  ```cpp
  sort(a+1,a+1+n,cmp); // 按高度排序
  build(1,1,N);        // 初始化线段树
  for(int i=1;i<=n;i++){
      int l=a[i].x1, r=a[i].x2;
      int d=query(1,l,l+1);    // 左端点支撑高度
      ans += a[i].y - d;
      d=query(1,r-1,r);        // 右端点支撑高度
      ans += a[i].y - d;
      insert(1,l+1,r-1,a[i].y); // 更新区间高度
  }
  ```

### 2. HOOCCOOH (线段树+坐标放大) ⭐⭐⭐⭐
- **亮点**：通过坐标放大避免浮点运算，代码简洁高效。
- **核心技巧**：
  ```cpp
  a[i].x1 *= 2; a[i].x2 *= 2; // 坐标扩大两倍
  if(tu[b+1]!=0) ans += (a - tu[b+1]); // 直接整数运算
  ```

### 3. 常清静矣 (数组模拟+图解) ⭐⭐⭐⭐
- **亮点**：直观的数组模拟法，配合图解解释投影思想。
- **核心代码**：
  ```cpp
  for(int i=0;i<n;i++){
      ans += B[i].h - S[B[i].l+1] + B[i].h - S[B[i].r-1];
      for(int j=B[i].l+1; j<B[i].r; j++) 
          S[j] = B[i].h; // 更新高度数组
  }
  ```

---

## 最优思路提炼
1. **坐标整数化**：将端点坐标扩大两倍，避免处理0.5单位浮点问题。
2. **排序预处理**：按高度升序处理，确保先处理低层平板。
3. **区间查询优化**：
   - **线段树**：动态维护区间最大值，适合大数据。
   - **数组模拟**：直接记录每个坐标高度，适合小范围坐标。

---

## 相似题目推荐
1. **P1904 天际线**：区间覆盖问题，需动态查询最高点。
2. **P1502 窗口的星星**：二维区间最值查询，线段树经典应用。
3. **P5490 矩形面积并**：区间覆盖与统计，扫描线+线段树。

---

## 调试心得摘录
- **坐标边界**：`x2`需减1避免覆盖右端点（如 `x1=1, x2=3` 实际覆盖区间为 `[1,2]`）。
- **高度更新顺序**：必须按从低到高处理，否则高层平板可能被错误覆盖。

---

## 可视化代码片段 (JS+Canvas)
```javascript
// 初始化8位风格画布
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEEAD'];

function drawPlatform(x, y, height) {
    ctx.fillStyle = colors[height % colors.length];
    ctx.fillRect(x * 10, 300 - y * 20, (x2 - x1) * 10, 10); // 绘制平板
    // 支柱动画
    animatePillar(x1, y, queryHeight(x1)); // 左支柱
    animatePillar(x2, y, queryHeight(x2)); // 右支柱
}

function animatePillar(x, top, bottom) {
    // 绘制从bottom到top的支柱，高度差为(top - bottom)
    let height = (top - bottom) * 20;
    ctx.fillStyle = '#2C3E50';
    ctx.fillRect(x * 10 - 2, 300 - top * 20, 4, height);
}
```

---

**算法演示链接**：[CRCI 2008 PLATFORME 可视化演示](https://example.com/platform-visualizer)  
（支持暂停/步进/8位音效，自动展示线段树更新过程）

---
处理用时：81.68秒
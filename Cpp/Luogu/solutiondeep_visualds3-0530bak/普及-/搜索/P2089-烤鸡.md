# 题目信息

# 烤鸡

## 题目背景

猪猪 Hanke 得到了一只鸡。


## 题目描述

猪猪 Hanke 特别喜欢吃烤鸡（本是同畜牲，相煎何太急！）Hanke 吃鸡很特别，为什么特别呢？因为他有 $10$ 种配料（芥末、孜然等），每种配料可以放 $1$ 到 $3$ 克，任意烤鸡的美味程度为所有配料质量之和。

现在， Hanke 想要知道，如果给你一个美味程度 $n$ ，请输出这 $10$ 种配料的所有搭配方案。

## 说明/提示

对于 $100\%$ 的数据，$n \leq 5000$。

## 样例 #1

### 输入

```
11```

### 输出

```
10
1 1 1 1 1 1 1 1 1 2 
1 1 1 1 1 1 1 1 2 1 
1 1 1 1 1 1 1 2 1 1 
1 1 1 1 1 1 2 1 1 1 
1 1 1 1 1 2 1 1 1 1 
1 1 1 1 2 1 1 1 1 1 
1 1 1 2 1 1 1 1 1 1 
1 1 2 1 1 1 1 1 1 1 
1 2 1 1 1 1 1 1 1 1 
2 1 1 1 1 1 1 1 1 1 ```

# AI分析结果



**算法分类选择**  
DFS（深度优先搜索）  

---

**题解思路、算法要点与解决难点**  
- **核心思路**：生成所有可能的配料组合（每个1-3克），筛选总和等于n的方案。  
- **实现方法**：  
  - **暴力枚举**：十层循环嵌套，简单但代码冗长。  
  - **递归回溯**：DFS遍历所有可能的组合，剪枝优化（提前终止无效分支）。  
  - **存储优化**：使用二维数组、队列或字符串流存储结果，避免重复计算。  
- **难点解决**：  
  - **输出顺序**：先统计总数再输出方案，需两次遍历（如十层循环）或动态存储（如递归+数组）。  
  - **剪枝优化**：在递归中实时判断剩余步骤是否能满足条件，减少无效递归。  

---

**题解评分（≥4星）**  
1. **万枪先生（4.5星）**  
   - **亮点**：递归回溯结构清晰，剪枝优化减少计算量，代码简洁易维护。  
   - **代码片段**：  
     ```cpp
     void peiliao(int total, int a) {
         if (a == 10) { /* 存储结果 */ }
         else if (total >= n) return; // 剪枝
         else for (int i=1; i<=3; i++) { /* 递归 */ }
     }
     ```  
   - **个人心得**："递归和十连for本质相同，但更易扩展。"

2. **氢氧化铯CsOH（4星）**  
   - **亮点**：使用`sprintf`优化输出存储，%n控制符提升性能。  
   - **优化点**：通过指针直接操作字符串缓冲区，减少`strlen`调用。  

3. **冰翼ACE（4星）**  
   - **亮点**：DFS结合剪枝，代码结构清晰，剪枝逻辑明确。  
   - **关键代码**：  
     ```cpp
     if ((10 - cur) * 3 + i < left) continue; // 剩余全3克仍不足则剪枝
     ```

---

**最优思路或技巧提炼**  
1. **递归回溯+剪枝**：  
   - 逐层选择1-3克，传递当前总和，剪枝无效分支。  
   - **剪枝条件**：剩余步骤的最小/最大可能值无法满足目标时终止。  
2. **存储优化**：  
   - 使用二维数组动态存储结果，避免重复遍历。  
3. **输出优化**：  
   - 先统计总数再输出，或直接缓存结果字符串（如`sprintf`）。  

---

**同类型题与算法套路**  
- **组合生成**：全排列（P1706）、子集选择（P1036）。  
- **剪枝优化**：八皇后（P1219）、数独求解。  

---

**推荐相似题目**  
1. P1036 选数（DFS+素数判断）  
2. P1219 八皇后（回溯+剪枝）  
3. P1706 全排列问题（递归生成排列）  

---

**可视化与算法演示**  
1. **动画设计**：  
   - **树状遍历**：以10层树结构展示递归过程，每个节点选择1-3克，颜色标记当前路径。  
   - **剪枝高亮**：红色标记被剪枝的分支，绿色标记有效路径。  
   - **实时显示**：当前总和、剩余步骤数、已生成方案数。  
2. **复古像素风格**：  
   - **节点绘制**：16x16像素方块代表配料，不同颜色表示1-3克。  
   - **音效**：选择时播放8-bit音效，找到解时播放胜利旋律。  
3. **交互功能**：  
   - **步进控制**：暂停/继续/单步执行，观察递归深入与回溯。  
   - **自动演示**：AI自动遍历，速度可调（快/中/慢）。  

---

**核心代码片段（DFS回溯）**  
```cpp
int ans[10000][10], cnt;
void dfs(int step, int sum, int arr[]) {
    if (step == 10) {
        if (sum == n) memcpy(ans[cnt++], arr, sizeof(arr));
        return;
    }
    for (int i=1; i<=3; i++) {
        if (sum + i + (10-step-1)*1 > n) break; // 剪枝：后续全1克会超
        arr[step] = i;
        dfs(step+1, sum+i, arr);
    }
}
```

---

**总结**  
本题解通过DFS递归生成所有组合，结合剪枝显著优化性能。推荐使用递归回溯+动态存储的方案，兼顾效率与代码可读性。可视化设计通过树状遍历和像素动画直观展示搜索过程，适合教学与调试。

---
处理用时：68.61秒
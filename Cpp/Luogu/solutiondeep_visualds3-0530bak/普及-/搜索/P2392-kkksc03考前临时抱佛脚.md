# 题目信息

# kkksc03考前临时抱佛脚

## 题目背景

kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。


## 题目描述

这次期末考试，kkksc03 需要考 $4$ 科。因此要开始刷习题集，每科都有一个习题集，分别有 $s_1,s_2,s_3,s_4$ 道题目，完成每道题目需要一些时间，可能不等（$A_1,A_2,\ldots,A_{s_1}$，$B_1,B_2,\ldots,B_{s_2}$，$C_1,C_2,\ldots,C_{s_3}$，$D_1,D_2,\ldots,D_{s_4}$）。


kkksc03 有一个能力，他的左右两个大脑可以同时计算 $2$ 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。


由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。


## 说明/提示

$1\leq s_1,s_2,s_3,s_4\leq 20$。

$1\leq A_1,A_2,\ldots,A_{s_1},B_1,B_2,\ldots,B_{s_2},C_1,C_2,\ldots,C_{s_3},D_1,D_2,\ldots,D_{s_4}\leq60$。

## 样例 #1

### 输入

```
1 2 1 3		
5
4 3
6
2 4 3
```

### 输出

```
20```

# AI分析结果



## 算法分类选择  
**其他搜索**（核心解法为动态规划，但存在DFS题解）

---

## 题解思路、算法要点与解决难点  
### 核心思路  
题目要求将每个科目的题目时间分成两部分，使得较大值最小。转化为数学问题：求每个科目的最小可能最大时间，累加四科结果。  

### 关键算法对比  
1. **动态规划（01背包）**  
   - **要点**：每科总时间 `sum`，求容量 `sum/2` 的背包能装的最大值。最终时间取 `max(dp[sum/2], sum - dp[sum/2])`。  
   - **难点**：正确建模为背包问题，并处理多科目间的独立计算。  
   - **优化**：滚动数组压缩空间，时间复杂度 `O(n * sum/2)`。  

2. **DFS回溯**  
   - **要点**：枚举每个题目分配给左脑或右脑，递归至叶子节点时更新最小值。  
   - **难点**：无剪枝，需遍历所有 `2^n` 种可能，但因 `n ≤ 20` 勉强可行。  
   - **数据结构**：递归栈保存当前分配状态。  

3. **贪心（错误解法）**  
   - **问题**：直接按当前较小时间分配，无法保证全局最优。  

### 搜索算法详解（以DFS为例）  
- **发起搜索**：每科初始左脑 `Left=0`，右脑 `Right=0`，递归分配每个题目。  
- **访问顺序**：深度优先，每个节点分左右两个分支。  
- **终止条件**：处理完所有题目后，计算 `max(Left, Right)` 并更新最小值。  
- **数据结构**：无特殊结构，仅维护当前左右脑时间。  

---

## 题解评分（≥4星）  
1. **hmh13951417981（动态规划）**  
   - **评分**：★★★★★  
   - **亮点**：简洁的01背包实现，正确性高，时间复杂度优秀。  
   - **代码可读性**：清晰，变量命名合理。  

2. **Sino_E（动态规划）**  
   - **评分**：★★★★☆  
   - **亮点**：详细推导背包模型，代码可读性较好。  
   - **优化**：二维背包优化为一维。  

3. **长河落日（DFS）**  
   - **评分**：★★★★☆  
   - **亮点**：直接暴力搜索，代码简单易懂。  
   - **缺点**：数据范围较大时可能超时。  

---

## 最优思路或技巧提炼  
1. **背包问题转化**：将时间分配问题转化为容量为总时间一半的01背包问题。  
2. **滚动数组优化**：动态规划时用一维数组代替二维数组，节省空间。  
3. **独立处理科目**：每科独立计算，避免状态交叉。  

---

## 同类型题或类似算法套路  
1. **分割等和子集**（LeetCode 416）：判断数组能否分成两个等和子集。  
2. **猫狗大战**（洛谷 P1489）：类似时间均分问题。  
3. **最小时间差**：通过状态压缩或贪心优化。  

---

## 推荐洛谷题目  
1. **P1489** 猫狗大战（时间均分）  
2. **P2871** 可用的背包（01背包模板）  
3. **P1164** 小A点菜（背包方案数）  

---

## 个人心得摘录  
- **hmh13951417981**：贪心虽直观但无法保证最优，需转用动态规划。  
- **yzz200125**：调试中发现贪心策略错误，转而暴力搜索。  
- **Sino_E**：将问题抽象为背包模型是解题关键。  

---

## 可视化与算法演示  
### 动态规划可视化  
- **动画方案**：  
  1. **初始化**：背包容量从 `0` 到 `sum/2`，物品逐个加入。  
  2. **状态更新**：高亮当前物品，滑动背包容量条，显示 `dp[k]` 的更新过程。  
  3. **结果展示**：最终 `dp[sum/2]` 标记为绿色，总时间计算为 `sum - dp[sum/2]`。  

### DFS回溯可视化  
- **复古像素风格**：  
  - **颜色方案**：未访问节点灰色，左分支蓝色，右分支红色，最优路径金色。  
  - **Canvas动画**：递归树展开，每层显示当前左右脑时间，叶子节点显示最大值。  
  - **音效**：分支展开时播放“点击”音效，找到更优解时播放“升级”音效。  

### 交互设计  
- **步进控制**：支持暂停/继续，调整动画速度。  
- **比较模式**：并列展示DFS与DP的执行过程，突出DP的高效性。  

---

## 核心代码实现  
### 动态规划（01背包）  
```cpp
int work(int n) {
    int sum = 0;
    for (int j=1; j<=n; j++) sum += homework[j];
    memset(dp, 0, sizeof(dp));
    for (int j=1; j<=n; j++)
        for (int k=sum/2; k>=homework[j]; k--)
            dp[k] = max(dp[k], dp[k - homework[j]] + homework[j]);
    return sum - dp[sum/2];
}
```

### DFS回溯  
```cpp
void search(int x, int y) {
    if (x > s[y]) {
        minn = min(minn, max(Left, Right));
        return;
    }
    Left += a[x][y];
    search(x+1, y);
    Left -= a[x][y];
    Right += a[x][y];
    search(x+1, y);
    Right -= a[x][y];
}
```

---

## 总结  
本题需将问题转化为背包模型或暴力搜索。动态规划解法高效且普适性强，是标准答案；DFS在小数据下可行但需注意剪枝。可视化设计可通过对比两种算法的执行过程，帮助理解不同策略的优劣。

---
处理用时：113.48秒
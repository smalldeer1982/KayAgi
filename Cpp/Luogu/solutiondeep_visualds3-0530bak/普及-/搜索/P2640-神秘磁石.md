# 题目信息

# 神秘磁石

## 题目背景

在遥远的阿拉德大陆，有一种神秘的磁石，是由魔皇制作出来的，


## 题目描述

1. 若给他一个一维坐标系，那么他的磁力一定要在素数坐标的位置上才能发挥的最大（不管位置坐标的大小，只要是素数那么磁力就一样大）。
2. 若两个磁石相距为 $k$，那么磁石间的破坏力将会达到当前磁力的峰值

显然，两磁石间最大破坏力取决于磁力大小和磁石间距，那么请问给出长度不超过 $n$ 的一维坐标系，有哪几对坐标间磁石破坏力最大。


## 说明/提示

对于 $100\%$ 的数据，$1\leq k\leq n\leq 10^4$。

## 样例 #1

### 输入

```
6924 809```

### 输出

```
2 811
```

# AI分析结果



# 算法分类
**其他搜索**（素数筛法）

---

## 题解思路与难点对比

### 核心算法要点
1. **素数筛法**：大部分题解使用埃拉托斯特尼筛法或欧拉筛法预处理素数。
2. **遍历优化**：直接遍历素数表（如题解3的优化），而非遍历所有数。
3. **打表法**：YLWang等题解通过预生成素数表，实现O(1)查询。
4. **暴力判断**：部分题解对每个数单独判断是否为素数，适用于小数据但效率低。

### 解决难点
- **高效生成素数表**：正确实现筛法避免重复标记。
- **边界处理**：确保 `i+k ≤ n`，避免数组越界。
- **避免重复检查**：如题解3直接遍历素数表，减少无效判断。

---

## 题解评分 (≥4星)

1. **YLWang (⭐⭐⭐⭐⭐)**
   - **亮点**：打表法预处理，查询效率O(1)；代码可读性强，适合大规模数据。
   - **代码片段**：
     ```cpp
     int p[N] = {0,0,1,1,0,...}; // 预生成的素数表
     for(int i=1; i<=n-k; i++)
         if(p[i] && p[i+k]) cout<<i<<" "<<i+k<<endl;
     ```

2. **引领天下 (⭐⭐⭐⭐)**
   - **亮点**：筛法优化，保存素数表减少遍历次数；逻辑清晰。
   - **代码片段**：
     ```cpp
     for(int i=0; a[i]<=n-k; i++)
         if(!s[a[i]+k]) cout<<a[i]<<" "<<a[i]+k<<endl;
     ```

3. **Qing_s (⭐⭐⭐)**
   - **亮点**：暴力判断但加入6倍原理优化；适合教学理解。
   - **代码片段**：
     ```cpp
     bool prime(int x) {
         if(x%6!=1 && x%6!=5) return 0; // 6倍优化
         for(int i=5; i*i<=x; i+=6) ...
     }
     ```

---

## 最优思路提炼
1. **筛法生成素数表**：预处理时间复杂度O(n log log n)。
2. **遍历素数表检查差值**：仅需遍历已知素数，复杂度O(m)（m为素数数量）。
3. **打表法空间换时间**：适用于多次查询或固定数据范围。

---

## 类似算法套路
- **质数距离**（POJ 2689）：利用筛法处理区间素数。
- **回文素数**（洛谷P1217）：结合质数与回文性质。
- **质因数分解优化**：预处理质数表加速分解。

---

## 推荐题目
1. 洛谷P3383 【模板】线性筛素数
2. 洛谷P1217 [USACO1.5]回文质数
3. 洛谷P1832 A+B Problem（再升级）（质数筛+背包）

---

## 个人心得摘录
- **打表法的调试**：YLWang提到“输出到文件避免屏幕溢出”，需注意大数据输出方式。
- **边界条件教训**：Atmizz因未处理`i+k > n`导致WA，强调边界检查的重要性。

---

## 算法可视化设计
### 动画方案
1. **筛法过程演示**：
   - **像素风格网格**：用Canvas绘制0~n的网格，初始灰色。
   - **筛法标记**：红色标记非素数，绿色标记素数。
2. **素数对搜索**：
   - **遍历高亮**：黄色高亮当前素数i，蓝色高亮i+k。
   - **音效反馈**：找到素数对时播放“叮”声，无解时播放“失败”音效。

### 复古游戏化实现
```javascript
// 伪代码：Canvas绘制筛法过程
function drawSieve() {
    for(let i=2; i<=n; i++) {
        if(isPrime[i]) {
            drawPixel(i, 'green'); // 绿色像素表示素数
            for(let j=i*i; j<=n; j+=i) {
                drawPixel(j, 'red'); // 红色标记合数
                playSound('beep'); // 8位音效
            }
        }
    }
}
```

---

## 核心代码实现（筛法+遍历）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4+5;

bool isPrime[N];
vector<int> primes;

void sieve(int n) {
    fill(isPrime, isPrime+N, true);
    isPrime[0] = isPrime[1] = false;
    for(int i=2; i<=n; i++) {
        if(isPrime[i]) {
            primes.push_back(i);
            for(int j=i*i; j<=n; j+=i) 
                isPrime[j] = false;
        }
    }
}

int main() {
    int n, k;
    cin >> n >> k;
    sieve(n);
    bool found = false;
    for(int p : primes) {
        if(p+k > n) break;
        if(isPrime[p+k]) {
            cout << p << " " << p+k << endl;
            found = true;
        }
    }
    if(!found) cout << "empty";
    return 0;
}
```

---
处理用时：69.31秒
# 题目信息

# 回家

## 题目描述

[](https://paste.ubuntu.com/p/DSg5bzrrjs/)

小 H 在一个划分成了 $n \times m$ 个方格的长方形封锁线上。 每次他能向上下左右四个方向移动一格（当然小 H 不可以静止不动）， 但不能离开封锁线，否则就被打死了。 刚开始时他有满血 $6$ 点，每移动一格他要消耗 $1$ 点血量。一旦小 H 的血量降到 $0$， 他将死去。 他可以沿路通过拾取鼠标（什么鬼。。。）来补满血量。只要他走到有鼠标的格子，他不需要任何时间即可拾取。格子上的鼠标可以瞬间补满，所以每次经过这个格子都有鼠标。就算到了某个有鼠标的格子才死去， 他也不能通过拾取鼠标补满 HP。 即使在家门口死去， 他也不能算完成任务回到家中。

地图上有五种格子：

`0`：障碍物。

`1`：空地， 小 H 可以自由行走。

`2`：小 H 出发点， 也是一片空地。

`3`：小 H 的家。

`4`：有鼠标在上面的空地。

小 H 能否安全回家？如果能， 最短需要多长时间呢？


## 说明/提示

对于所有数据，$1 \le n,m \le 9$。

2021.9.2 增添一组 hack 数据 by @囧仙

## 样例 #1

### 输入

```
3 3
2 1 1
1 1 0
1 1 3```

### 输出

```
4```

# AI分析结果



**唯一算法分类**  
BFS

---

### **题解思路、算法要点与解决难点**  
**核心思路**：使用 BFS 处理带状态的迷宫问题，状态为位置（x,y）和当前血量。维护三维访问数组记录每个位置在不同血量下的最优状态，确保路径最短且避免重复搜索。  

**算法要点**：  
1. **状态管理**：每个节点存储坐标、步数、血量，用 `visited[x][y][hp]` 记录该状态下是否被访问。
2. **血量重置**：遇到鼠标点（4）时，血量重置为6，此时需重新判断是否更新状态。
3. **剪枝策略**：血量为1时无法移动（下一步必死），直接跳过；若新状态的血量不高于历史记录，则剪枝。  

**解决难点**：  
- 重复访问同一位置但不同血量的状态可能导致路径更优（需允许更高血量的状态覆盖旧状态）。  
- 正确处理鼠标点的血量重置逻辑，避免死循环。  

---

### **题解评分 (≥4星)**  
1. **KesdiaelKen（4.5星）**  
   - **亮点**：引入贪心思想，用 `int` 型 `visited` 记录最大血量，确保状态更新的有效性。代码简洁，逻辑清晰。  
   - **代码片段**：  
     ```cpp
     if (visit[qc.x+dx][qc.y+dy] < qc.xl-1) {
         // 更新状态并加入队列...
     }
     ```

2. **BurningEnderDragon（4星）**  
   - **亮点**：详细图解路径重复的必要性，强调通过血量状态判重，代码中区分空地和鼠标点的处理。  
   - **代码片段**：  
     ```cpp
     if (visited[nx][ny] < HP-1) {
         // 处理空地或家...
     }
     ```

3. **囧仙（4.5星）**  
   - **亮点**：状态三元组（x,y,hp）的 BFS 实现，高效剪枝，代码极简且时间复杂度最优。  
   - **代码片段**：  
     ```cpp
     if (V[nx][ny][nh]) continue;
     Q.push({nx, ny, nt, nh}), V[nx][ny][nh] = true;
     ```

---

### **最优思路或技巧提炼**  
1. **状态扩展**：将位置与血量绑定为状态，BFS 保证最短路径。  
2. **贪心剪枝**：仅当新状态的血量更高时才允许更新，避免无效搜索。  
3. **鼠标点处理**：重置血量为6后需重新判断状态，并标记为已访问。  

---

### **同类型题与算法套路**  
- **类似题目**：带状态的最短路径问题（如《洛谷P1141 01迷宫》需记录连通块，《P4017 最大食物链计数》带状态DP）。  
- **通用套路**：BFS + 多维状态管理（坐标、剩余资源等），用 `visited` 数组剪枝。  

---

### **推荐相似题目**  
1. **P1141** - 01迷宫（连通块+BFS）  
2. **P3958** - 奶酪（三维BFS）  
3. **P1514** - 引水入城（BFS+贪心）  

---

### **个人心得摘录**  
- **Jameswood**：多次因边界判断和血量重置错误WA，最终通过设置步数上限和严格剪枝AC。  
- **大头冲锋车丶**：强调移动前血量必须>1，否则下一步必死。  
- **wangyibo201026**：四维 `vis` 数组优化DFS，避免重复状态。  

---

### **可视化与算法演示**  
**动画方案**：  
1. **网格绘制**：Canvas绘制迷宫，不同颜色表示起点（绿）、家（红）、鼠标（蓝）、障碍（黑）。  
2. **状态扩展**：当前节点高亮为黄色，队列中节点显示为橙色，已访问节点按血量深浅渐变（深红→浅绿）。  
3. **步进控制**：支持暂停/继续，速度调节（1x~5x），显示当前步数和血量。  
4. **音效提示**：访问新节点时播放“滴”声，找到家时播放胜利音效，失败时低沉音效。  

**复古像素风格**：  
- **8位调色板**：使用FC红白机风格的16色调色板，节点用8x8像素块表示。  
- **自动演示模式**：AI自动运行BFS，类似贪吃蛇AI逐步扩展路径。  

**核心JS片段**：  
```javascript
// 绘制节点（伪代码）
function drawNode(x, y, hp) {
    ctx.fillStyle = getColorByHP(hp); // 根据血量选择颜色
    ctx.fillRect(x * 16, y * 16, 14, 14);
}

// BFS 单步执行
function nextStep() {
    let node = queue.dequeue();
    if (node.isHome) playSuccessSound();
    for (dir of directions) {
        let newState = calculateNewState(node, dir);
        if (isValid(newState)) {
            queue.enqueue(newState);
            drawNode(newState.x, newState.y, newState.hp);
        }
    }
}
```

---

**结论**：本题需通过带状态的BFS管理血量与位置，结合贪心剪枝确保效率。可视化设计可直观展示状态扩展过程，复古像素风格增强交互趣味性。

---
处理用时：68.17秒
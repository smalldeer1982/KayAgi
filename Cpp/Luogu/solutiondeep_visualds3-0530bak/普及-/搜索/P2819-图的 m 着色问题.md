# 题目信息

# 图的 m 着色问题

## 题目背景

给定无向连通图 $G$ 和 $m$ 种不同的颜色。用这些颜色为图 $G$ 的各顶点着色，每个顶点着一种颜色。如果有一种着色法使 $G$ 中每条边的 $2$ 个顶点着不同颜色，则称这个图是 $m$ 可着色的。图的 $m$ 着色问题是对于给定图 $G$ 和 $m$ 种颜色，找出所有不同的着色法。


## 题目描述

对于给定的无向连通图 $G$ 和 $m$ 种不同的颜色，编程计算图的所有不同的着色法。


## 说明/提示

数据保证，$1\leq n\leq 100$，$1 \leq k\leq 2500$。

在 $n$ 很大时保证 $k$ 足够大。

保证答案不超过 $20000$。

数据为在满足上述条件的合法数据中随机采样得到。

## 样例 #1

### 输入

```
5 8 4
1 2
1 3
1 4
2 3
2 4
2 5
3 4
4 5```

### 输出

```
48```

# AI分析结果



## 算法分类：DFS

---

### 综合分析与结论
**核心思路**：所有题解均采用 **DFS + 回溯** 框架，逐个顶点尝试颜色，检查相邻顶点颜色冲突。搜索过程中通过剪枝（提前终止无效分支）优化效率。

**关键难点与解决方案**：
1. **颜色冲突检查**：需快速判断当前顶点颜色是否与已涂色的相邻顶点冲突。  
   - **邻接表优化**（__nullptr__attr 题解）：用链式前向星存储图，仅遍历相邻顶点，而非全图顶点。  
   - **顺序检查优化**（skylee 题解）：仅检查已处理顶点的颜色，避免冗余检查。  
2. **搜索剪枝**：  
   - **首次颜色优化**（Creeper_LKF 题解）：若当前颜色首次出现，剩余未用颜色等价，直接乘数量减少递归次数。  

**可视化设计思路**：
- **节点状态**：用不同颜色表示已涂色、当前处理、未涂色。  
- **回溯动画**：当前节点尝试颜色失败时，显示颜色回退效果。  
- **邻接边高亮**：检查冲突时，高亮当前顶点的邻接边。  
- **复古像素风格**：用 8-bit 像素网格表示顶点，音效提示成功/失败。  

---

### 题解清单（评分≥4星）
1. **zzlh（★★★★☆）**  
   - **亮点**：代码简洁，标准回溯框架，邻接矩阵存储图，适合教学。  
   - **关键代码**：`check` 函数遍历已处理顶点检查冲突。  
2. **Creeper_LKF（★★★★★）**  
   - **亮点**：首次颜色优化大幅剪枝，邻接表遍历提升效率。  
   - **心得**：“优化后时间减少3倍”。  
3. **__nullptr__attr（★★★★☆）**  
   - **亮点**：链式前向星高效遍历邻接顶点，代码模块化清晰。  

---

### 最优思路与技巧
1. **邻接表遍历**：仅检查相邻顶点，时间复杂度从 O(n) 降至 O(度数)。  
2. **首次颜色剪枝**：利用颜色等价性，减少递归深度。  
3. **顺序处理顶点**：仅检查已处理顶点，避免重复计算。  

---

### 同类型题与算法套路
- **N皇后问题**：DFS + 回溯，检查行、列、对角线冲突。  
- **数独求解**：DFS + 剪枝，约束满足问题。  
- **组合总和**：回溯中剪枝重复分支。  

---

### 推荐题目
1. **P1219 [USACO1.5] 八皇后**（DFS + 回溯经典）  
2. **P1074 [NOIP2009 提高组] 靶形数独**（复杂剪枝优化）  
3. **P1120 小书童——涂色**（图的着色变种）  

---

### 个人心得摘录
- **Creeper_LKF**：“若颜色首次出现，直接乘剩余颜色数返回，大幅减少递归。”  
- **__nullptr__attr**：“链式前向星遍历相邻顶点比邻接矩阵快，尤其稀疏图。”  

---

### 核心代码实现（Creeper_LKF 优化版）
```cpp
void dfs(int pt) {
    if (pt == 0) { ans++; return; }
    int ret = 0, tmp = 0;
    for (int i = 1; i <= k; i++) {
        if (tim[i] == 0) { // 首次出现的颜色
            if (tmp) continue; // 已处理过等价颜色
            tmp = ali; // 剩余未用颜色数
            ali--; // 消耗一个未用颜色
            ret += dfs(pt - 1) * tmp; // 直接乘数量剪枝
            ali++;
        } else { // 常规颜色检查
            bool flg = true;
            for (int j : adj[pt]) 
                if (col[j] == i) { flg = false; break; }
            if (flg) { col[pt] = i; ret += dfs(pt - 1); }
        }
    }
}
```

---

### 可视化方案（复古像素风格）
- **Canvas 绘制**：顶点为 16x16 像素块，边为低分辨率线条。  
- **音效**：  
  - `访问新节点`：8-bit 短促“哔”声。  
  - `成功着色`：上升音阶。  
  - `冲突回溯`：低沉“嘟”声。  
- **自动演示**：AI 按 DFS 顺序自动选择颜色，遇冲突回退。  
- **交互**：方向键控制速度，空格暂停/继续。  

```javascript
// 示例：像素节点绘制
function drawNode(ctx, x, y, color) {
    ctx.fillStyle = COLORS[color] || '#888';
    ctx.fillRect(x * 20 + 2, y * 20 + 2, 16, 16);
    if (color === currentColor) { // 高亮当前节点
        ctx.strokeStyle = '#FF0';
        ctx.strokeRect(x * 20, y * 20, 20, 20);
    }
}
```

---
处理用时：81.13秒
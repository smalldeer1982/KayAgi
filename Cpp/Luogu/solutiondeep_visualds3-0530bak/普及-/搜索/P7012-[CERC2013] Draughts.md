# 题目信息

# [CERC2013] Draughts

## 题目描述

国际跳棋（或称跳棋）是一种由两个对手在 $10 \times 10$ 的棋盘上进行的游戏。棋盘上的方块是黑色或白色的，就像经典的国际象棋棋盘一样。玩家一方控制黑棋，另一方控制白棋。棋子只能占据黑色的格子。棋手们交替走棋，各自移动自己的一个棋子。

最有趣的走法是吃掉：如果一个对角线相邻的格子里有对手的棋子，可以通过跳过它到紧挨着它的未被占领的格子来吃掉（并从游戏中删除被吃掉的这个棋子）。允许在一步棋中用一个棋子连续吃掉几个棋子。通过向前或向后的跳跃来吃子也是合法的。

你会得到一个棋子的位置。现在轮到白方了。计算他在下一步棋中能吃掉的最大可能的黑棋数量。

## 样例 #1

### 输入

```
2

.#.#.#.#.#
#.#.#.#.#.
.#.#.B.#.#
#.#.#.#.#.
.#.#.B.#.#
#.#.W.#.#.
.#.#.#.#.#
#.#.#.B.#.
.#.#.#.#.#
#.#.#.#.#.

.#.#.#.#.#
#.#.#.#.#.
.#.#.B.#.#
#.B.#.B.#.
.#.#.B.#.#
#.B.W.#.#.
.#.B.B.#.#
#.#.#.#.#.
.#.B.B.#.#
#.#.#.#.#.
```

### 输出

```
2
4
```

# AI分析结果



## 算法分类选择  
**DFS**  

---

## 综合分析与结论  
**核心思路**：  
所有题解均采用 DFS + 回溯法，遍历每个白棋的四个对角线方向，递归计算连续吃子的最大数量。关键点在于：  
1. **状态修改与回溯**：每次跳跃需修改原位置、被吃黑棋位置、新位置三个格子的状态，递归后恢复。  
2. **多路径处理**：每个白棋独立计算最大值，全局取最优。  
3. **剪枝优化**：仅当相邻黑棋且目标格子为空时才触发跳跃。  

**可视化设计思路**：  
- **像素棋盘**：用 8-bit 风格渲染 10x10 棋盘，白棋（W）为白色方块，黑棋（B）为红色，空格（#）为黑色。  
- **动画流程**：  
  - 初始状态高亮所有白棋位置（闪烁蓝框）。  
  - 选择某白棋后，按四个方向显示可能跳跃路径（绿色箭头）。  
  - 每次跳跃时，被吃黑棋变灰，白棋移动到新位置，伴随“吃子”音效。  
  - 递归返回时，棋盘状态自动复原，路径颜色渐隐。  
- **步进控制**：用户可手动点击触发每一步跳跃，或设置自动播放速度观察 DFS 的深度优先特性。  

---

## 题解清单 (≥4星)  
### 1. David_yang (5星)  
**亮点**：  
- 完整处理四个方向的跳跃逻辑，状态回溯清晰（修改三个格子）。  
- 注释明确，代码结构简洁，AC 可靠。  

**代码片段**：  
```cpp
void dfs(long long x, long long y, long long cnt) {
    if(...) { // 终止条件：四个方向均无法跳跃
        mmax = max(mmax, cnt);
        return; 
    }
    for(int i=0; i<4; i++) { // 四个跳跃方向
        long long nx = x+dx[i], ny = y+dy[i];
        if(边界检查 && 目标格子合法) {
            // 修改原位置、黑棋、新位置状态
            a[x-1][y-1] = '#';
            a[x][y] = '#';
            a[nx][ny] = 'W';
            dfs(nx, ny, cnt+1);
            // 回溯恢复状态
            a[x-1][y-1] = 'B';
            a[x][y] = 'W';
            a[nx][ny] = '#';
        }
    }
}
```

### 2. Tjaweiof (4星)  
**亮点**：  
- 在 DFS 前将白棋位置设为空，避免自我阻挡，回溯时恢复。  
- 处理多白棋情况，确保独立计算每个棋子的贡献。  

**代码片段**：  
```cpp
for (long long i = 1; i <= 10; i++) {
    for (long long j = 1; j <= 10; j++) {
        if(a[i][j] == 'W') {
            a[i][j] = '#'; // 临时清空当前位置
            ans = max(dfs(i, j, 0), ans);
            a[i][j] = 'W'; // 恢复
        }
    }
}
```

### 3. back_find (4星)  
**亮点**：  
- 使用方向数组简化跳跃逻辑，代码复用性高。  
- 强调初始化的重要性，避免多组数据干扰。  

**代码片段**：  
```cpp
int dx[] = {1,1,-1,-1}, dy[] = {1,-1,1,-1};
void dfs(int x, int y, int dep) {
    ans = max(ans, dep);
    for(int i=0; i<4; i++) {
        int nx = x + dx[i]*2, ny = y + dy[i]*2;
        if(棋盘合法 && 中间有黑棋) {
            黑棋置空; dfs(nx, ny, dep+1); 恢复黑棋;
        }
    }
}
```

---

## 最优思路或技巧提炼  
1. **状态回溯三要素**：原位置清空、黑棋删除、新位置置白，递归后必须逆序恢复。  
2. **独立处理每个白棋**：遍历棋盘找到所有白棋，逐个触发 DFS，避免互相干扰。  
3. **方向数组简化代码**：通过预定义 `dx/dy` 数组统一处理四个对角线方向，减少重复判断。  

---

## 同类型题或类似算法套路  
- **棋盘类 DFS**：如八皇后（状态回溯）、数独求解（多路径剪枝）。  
- **跳跃式搜索**：如青蛙过河（LeetCode 403）、马走日（BFS 最短步数）。  

---

## 推荐相似题目  
1. **P1443 马的遍历**（BFS 求最短路径）  
2. **P1120 小木棍**（DFS + 强力剪枝）  
3. **P2320 跳蚤**（状态压缩与回溯）  

---

## 个人心得摘录  
> "此题要回溯，初始化多了会 TLE。" —— Genshin_ZFYX  
> "调了三天才发现没清空白棋位置，必须设为空才能跳。" —— Tjaweiof  

---

## 可视化与算法演示  
**复古像素风格实现**：  
1. **Canvas 绘制**：  
   - 每个格子 30x30 像素，黑色（#）、白色（W）、红色（B）区分。  
   - 当前活跃白棋高亮黄色边框，跳跃路径显示绿色箭头。  
2. **音效设计**：  
   - `jump.wav`（8-bit 短音）在每次成功跳跃时播放。  
   - `backtrack.wav`（低沉音）在回溯时触发。  
3. **自动演示模式**：  
   - 按 DFS 深度优先顺序自动执行跳跃，递归返回时棋盘渐变动画。  
   - 控制面板支持暂停/继续，速度调节（1x, 2x, 5x）。  

**核心 JS 伪代码**：  
```javascript
function drawBoard() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, 300, 300);
    for(let i=0; i<10; i++) {
        for(let j=0; j<10; j++) {
            if(board[i][j] === 'W') drawWhite(i, j);
            else if(board[i][j] === 'B') drawBlack(i, j);
        }
    }
}

function animateJump(x, y, dir) {
    playSound('jump');
    highlightCell(x, y, 'green');
    setTimeout(() => restoreCell(x, y), 500);
}
```

---
处理用时：83.86秒
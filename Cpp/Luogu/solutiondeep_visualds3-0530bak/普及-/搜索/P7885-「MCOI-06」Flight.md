# 题目信息

# 「MCOI-06」Flight

## 题目描述

书虫需要移动他的[盾构机](https://www.luogu.com.cn/problem/P7569)。

书虫将 MC 空间抽象为二维平面。他的盾构机现在在 $(a,b)$，而书虫想把盾构机移动到 $(c,d)$。

书虫每一步可以将盾构机向东南西北任何方向行动。但是这盾构机有一个限制：相邻两步不能向同一个方向走！

给定 $(a,b)$ 和 $(c,d)$，请计算书虫最少需要几步将盾构机移动到终点。

求书虫的最少步数。可以证明，他永远可以到达终点。



## 说明/提示

#### 样例 1 解释

 - 对于第一组，最优策略为 $(-2,0)\rarr(-2,1)$。
 - 对于第二组，最优策略为 $(0,1)\rarr(1,1)\rarr(1,2)\rarr(2,2)\rarr(2,3)\rarr(3,3)$。
 - 对于第三组，最优策略之一为 $(-1,1)\rarr (0,1)\rarr(0,0)\rarr(1,0)\rarr(1,1)$。

#### 数据规模与约定

**本题采用捆绑测试。**

 - Subtask 1（29 pts）：$0\le a,b,c,d\le 3$。
 - Subtask 2（29 pts）：$a=c$。
 - Subtask 3（42 pts）：无特殊限制。

对于所有数据，$1\le T\le 10^5$，$|a|,|b|,|c|,|d|\le10^{18}$。

## 样例 #1

### 输入

```
3
-2 0 -2 1
0 1 3 3
-1 1 1 1```

### 输出

```
1
5
4```

# AI分析结果



# **「MCOI-06」Flight 题解分析**

## **唯一算法分类**
数学/几何（基于曼哈顿距离与奇偶性推导）

---

## **综合分析与结论**

### **核心思路**
所有题解均发现以下规律：
1. 设 `dx = |a-c|`, `dy = |b-d|`，问题转化为从 `(0,0)` 到 `(dx, dy)` 的最短步数。
2. 当 `dx == dy` 时，直接走对角线，步数为 `dx + dy`。
3. 当 `dx != dy` 时，**奇偶性**是关键：
   - 若 `dx` 和 `dy` 的差值为**偶数**，步数为 `2 * max(dx, dy)`。
   - 若差值为**奇数**，步数为 `2 * max(dx, dy) - 1`。

### **解决难点**
- **方向交替限制**：相邻步方向不同，导致无法直接走直线。
- **数学抽象**：将路径问题转化为差值奇偶性判断。
- **大数据处理**：所有解法均通过 `O(1)` 公式计算，无需复杂算法。

---

## **题解评分（≥4星）**

### 1. **苏联小渣（5星）**
- **亮点**：公式最简洁，直接 `2 * max(dx, dy) - (差值 % 2)`。
- **代码**：仅需 10 行，无冗余计算。
```cpp
int dx = abs(a-c), dy = abs(b-d);
printf("%lld\n", 2*max(dx, dy) - (dx - dy) % 2);
```

### 2. **雨伞CKY（4星）**
- **亮点**：通过表格归纳同一行/列的步数规律，推导严谨。
- **代码**：清晰判断奇偶性，但 `swap` 操作稍显冗余。

### 3. **persimmon2008（4星）**
- **亮点**：分情况讨论的图示帮助理解，但代码中 `ans += x*2` 可优化。

---

## **最优思路提炼**
**关键公式**：`步数 = 2 * max(dx, dy) - (dx - dy) % 2`  
**推导要点**：
1. **曼哈顿距离**：优先走对角线，步数为 `min(dx, dy) * 2`。
2. **剩余距离处理**：剩余直线距离 `k = abs(dx - dy)`，奇偶性决定是否需要额外调整。

---

## **同类型题推荐**
1. **P2735 [USACO3.4] 网络破坏**（曼哈顿距离与网格路径）
2. **P3958 [NOIP2017 提高组] 奶酪**（三维空间几何与路径判断）
3. **P1008 三连击**（数字排列与数学规律）

---

## **可视化与算法演示**

### **复古像素动画设计**
- **网格绘制**：用 8-bit 风格绘制二维网格，起点 `(0,0)` 和终点 `(dx, dy)` 用不同颜色标记。
- **移动路径**：
  - **之字形路径**（当 `dx == dy`）：交替向右/向上移动，高亮方向变化。
  - **绕行路径**（当 `dx != dy`）：展示绕行时的方向切换（如右→上→右→下）。
- **音效提示**：
  - **移动音效**：每次方向切换时播放 8-bit 音效。
  - **完成音效**：到达终点时播放胜利旋律。

### **关键代码（伪代码）**
```javascript
// 计算步数公式
function calculateSteps(dx, dy) {
    return 2 * Math.max(dx, dy) - (Math.abs(dx - dy) % 2);
}

// 绘制路径动画
function drawPath(dx, dy) {
    let x = 0, y = 0, dir = null;
    while (x < dx || y < dy) {
        let nextDir = chooseDirection(x, y, dx, dy, dir);
        movePixel(x, y, nextDir); // 更新坐标并绘制
        dir = nextDir;
    }
}
```

---

## **个人心得摘录**
> "通过枚举小数据归纳规律，发现奇偶性是解题关键。调试时需注意 `abs` 处理负值，避免方向错误。"  
> —— 雨伞CKY

---

## **代码实现（核心逻辑）**
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        long long a, b, c, d;
        scanf("%lld%lld%lld%lld", &a, &b, &c, &d);
        long long dx = abs(a - c), dy = abs(b - d);
        printf("%lld\n", 2 * max(dx, dy) - (abs(dx - dy) % 2));
    }
    return 0;
}
```

---
处理用时：70.94秒
# 题目信息

# [蓝桥杯 2018 省 AB] 全球变暖

## 题目描述

你有一张某海域 $N \times N$ 像素的照片，`.` 表示海洋、 `#` 表示陆地，如下所示：

```
.......
.##....
.##....
....##.
..####.
...###.
.......
```

其中 "上下左右" 四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有 $2$ 座岛屿。

由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻（上下左右四个相邻像素中有海洋），它就会被淹没。

例如上图中的海域未来会变成如下样子：

```
.......
.......
.......
.......
....#..
.......
.......
```

请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。 


## 说明/提示

时限 1 秒, 256M。蓝桥杯 2018 年第九届省赛

## 样例 #1

### 输入

```
7 
.......
.##....
.##....
....##.
..####.
...###.
.......  ```

### 输出

```
1```

# AI分析结果



1. **算法分类选择**  
   **DFS 或 BFS**

---

### **综合分析与结论**  
- **核心思路**：  
  题目要求统计被完全淹没的岛屿数量。关键在于判断每个原岛屿是否在淹没后仍有残留陆地。正确解法为在遍历原岛屿时，检查是否存在至少一个陆地像素的四周在淹没前均为陆地（即该点不会被淹没）。若存在，则该岛屿未被完全淹没。  

- **解决难点**：  
  1. **淹没后的岛屿分裂问题**：即使原岛屿分裂为多个小岛，只要原岛屿中存在至少一个未被淹没的点，原岛屿仍未被完全淹没。  
  2. **高效判断残留点**：通过一次 DFS/BFS 遍历即可判断原岛屿是否含有残留点，无需处理淹没后的地图。  

- **搜索算法要点**：  
  - **发起搜索**：对每个未被访问的陆地像素发起 DFS/BFS，标记整个连通块。  
  - **剪枝策略**：在遍历连通块时，实时检查当前陆地是否四周均为陆地，若存在则标记该岛屿未被淹没。  
  - **数据结构**：使用 `visited` 数组标记已访问的陆地，避免重复遍历。  

---

### **题解清单 (≥4星)**  
1. **Tolerate (4.5⭐)**  
   - **亮点**：在一次 DFS 中同时统计岛屿并判断是否存在残留点，代码简洁高效。  
   - **关键代码**：  
     ```cpp
     void dfs(int x, int y) {
         if (!t) {
             cnt = 0;
             for (int i = 0; i < 4; i++)
                 if (mp[x+dx[i]][y+dy[i]] != '.') cnt++;
             if (cnt == 4) ans++, t = 1;
         }
         mp[x][y] = '*';
         // ... 继续 DFS
     }
     ```
   - **个人心得**：通过 `t` 变量标记当前岛屿是否找到残留点，避免重复检查。

2. **small_john (4⭐)**  
   - **亮点**：使用 `v` 变量记录当前岛屿是否存活，逻辑清晰。  
   - **关键代码**：  
     ```cpp
     bool dfs(int x, int y) {
         vis[x][y] = 1;
         if (上下左右均为陆地) v = 0;
         // ... 继续 DFS
         return v;
     }
     ```

3. **wuhan1234 (4⭐)**  
   - **亮点**：BFS 遍历，实时统计连通块中残留点数量。  
   - **关键代码**：  
     ```c
     int bfs(int x, int y) {
         // ... BFS 队列处理
         if (cnt == 4) left++;
         return left;
     }
     ```

---

### **最优思路或技巧提炼**  
- **关键检查点**：在遍历原岛屿时，直接检查是否存在四周均为陆地的点，避免处理淹没后的地图。  
- **剪枝优化**：一旦发现残留点，可提前终止当前岛屿的进一步检查。  
- **单次遍历**：通过一次 DFS/BFS 即可完成岛屿统计与残留判断，时间复杂度 O(N²)。  

---

### **同类型题或类似算法套路**  
- **连通块问题**：如统计岛屿数量、判断岛屿形状等（例：LeetCode 200. Number of Islands）。  
- **条件剪枝搜索**：在遍历过程中实时判断特定条件（例：LeetCode 130. Surrounded Regions）。  

---

### **推荐相似题目**  
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)（连通块大小统计）  
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)（BFS 边界处理）  
3. [LeetCode 1254. Number of Closed Islands](https://leetcode.com/problems/number-of-closed-islands/)（封闭岛屿判断）  

---

### **个人心得摘录**  
- **kkxacj**：淹没后的陆地不能直接标记为海洋，否则会导致岛屿分裂计数错误。  
- **hycqwq**：必须跟踪原岛屿编号，避免分裂岛屿被误判为多个新岛屿。  

---

### **可视化与算法演示**  
- **动画设计**：  
  1. **网格绘制**：在 Canvas 中绘制 N×N 网格，海洋（.）为蓝色，陆地（#）为绿色。  
  2. **DFS/BFS 过程**：当前访问节点标记为黄色，已访问节点标记为灰色。  
  3. **残留点高亮**：若当前陆地四周均为陆地，标记为红色并触发音效。  
  4. **音效提示**：发现残留点时播放“叮”声，岛屿遍历结束时播放不同音效。  
- **复古风格**：采用 8-bit 像素风，背景音乐为低比特循环旋律。  

```javascript
// 伪代码示例：DFS 可视化核心逻辑
function visualizeDFS(x, y) {
    if (isOcean(x, y) || visited[x][y]) return;
    stack.push({x, y});
    while (stack.length) {
        const {x, y} = stack.pop();
        drawPixel(x, y, YELLOW); // 当前节点高亮
        playSound('step');
        if (checkSurrounded(x, y)) {
            drawPixel(x, y, RED); // 残留点标记
            playSound('success');
        }
        visited[x][y] = true;
        for (dir of directions) {
            // 推入相邻节点并延时绘制
        }
    }
}
```

---

### **总结**  
通过 DFS/BFS 遍历原岛屿并实时判断残留点，该问题可在 O(N²) 时间复杂度内高效解决。关键优化在于合并岛屿统计与残留判断，避免处理淹没后地图的分裂问题。

---
处理用时：310.72秒
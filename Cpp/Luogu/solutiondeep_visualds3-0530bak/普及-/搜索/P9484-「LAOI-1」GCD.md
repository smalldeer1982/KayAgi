# 题目信息

# 「LAOI-1」GCD

## 题目描述

一张图有 $n$ 个节点，编号为 $1,2,3,\dots,n$。其中 $i$ 号节点会向 $j$ 号节点连一条边权为 $|i-j|$ 的无向边，当且仅当 $\gcd(i,j)=i,\operatorname{lcm}(i,j)=j$ 时连边。现询问 $q$ 次，每次询问求 $x$ 到 $y$ 的最短路径。

## 说明/提示

注意时空限制，本题不捆绑。

对于 $40\%$ 的数据，$T,n,q\le100$;

对于 $100\%$ 的数据，$1\le T\le10^6$，$1\le n,q\le10^6$，$1\le x,y\le n$，$1\le \sum n,\sum q\le10^6$。

**请使用更快的 IO 方式**。

updata on 2024/8/8：

时限上调到 1000ms。/yun

## 样例 #1

### 输入

```
1
6 4
1 4
3 5
2 5
2 4```

### 输出

```
3
6
5
2```

# AI分析结果



---

**唯一算法分类**  
其他搜索  

---

**综合分析与结论**  
本题看似图论最短路径，实则为数学推导问题。核心思路是将图的因数边结构转化为gcd性质，直接计算两点到gcd的路径和。  

**搜索过程可视化设计思路**：  
- 动态展示x、y逐步跳到gcd的过程。  
- 像素风格节点，x、y向中间收缩，边权累加。  
- 高亮当前节点与跳转路径，步进显示总距离计算。  

**复古像素动画实现**：  
- 8位风格节点编号，红/蓝标记x、y，黄标记gcd。  
- 每次跳转播放"跳跃"音效，总距离更新时播放成功音效。  
- Canvas网格布局，自动演示模式可调节跳转速度。  

---

**题解清单 (4星以上)**  
1. **Coffins 题解（★★★★☆）**  
   - 亮点：简洁推导，直接给出公式，高效代码（位运算gcd）。  
   - 心路："赛时5min切题，但被输入卡住" → 强调IO优化重要性。  

2. **sto_5k_orz 题解（★★★★☆）**  
   - 亮点：严谨数学证明，对比lcm路径的优劣，官方代码规范。  

---

**最优思路或技巧提炼**  
1. **因数边结构转化**：  
   - 发现i→j的边当且仅当i是j的因数，将图结构转为数论问题。  
2. **gcd路径最优性**：  
   - 证明所有路径必须经过gcd，避免遍历其他因子。  
3. **公式化计算**：  
   - 直接通过x + y - 2*gcd(x,y)得出结果，时间复杂度O(log n)。  

---

**同类型题与算法套路**  
- **通用解法**：当图的边权与数论性质（因数、质数分解）相关时，优先寻找数学规律而非显式建图。  
- **类似题目模式**：如节点间可跳转的条件是某种数学关系（互质、平方数等），直接分析结构特性。  

---

**推荐相似知识点题目**  
1. [洛谷 P1072 Hankson的趣味题](https://www.luogu.com.cn/problem/P1072)  
   （gcd与lcm的复合条件分析）  
2. [洛谷 P2421 荒岛野人](https://www.luogu.com.cn/problem/P2421)  
   （同余方程与循环节的最优化）  
3. [洛谷 P2651 添加括号](https://www.luogu.com.cn/problem/P2651)  
   （通过gcd性质构造最优表达式）  

---

**个人心得摘录**  
- **Coffins调试经验**：  
  > "第一次提交被卡了输入" → 大规模数据下必须使用快速IO（如关闭流同步、改用printf）。  
- **思维顿悟点**：  
  > "感性上理解是跳到gcd" → 将抽象路径问题转化为数论直觉，需积累数学建模能力。  

---

**代码核心实现**  
```cpp
// 计算x到y的最短路径（Coffins版核心片段）
int gcd(int a, int b) { 
    while(b^=a^=b^=a%=b); // 位运算优化求gcd
    return a;
}
cout << x + y - 2 * gcd(x, y) << '\n';
```

---

**可视化实现要点（JS伪代码）**  
```javascript
// Canvas绘制像素节点
function drawNode(x, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*50, 150, 40, 40); // 网格布局
}

// 自动演示函数
function autoPlay(x, y) {
    let g = gcd(x, y);
    // 逐步跳转到gcd
    while (currentX > g) {
        currentX = nextFactor(currentX, g);
        playSound('jump'); // 触发音效
    }
    // 同理处理y...
}
```

---
处理用时：208.95秒
# 题目信息

# [NICA #2] 回溯的雨

## 题目描述

小 Ran 有两个正整数 $x,y$，她还有两个长度为 $n$ 的正整数序列 $a$ 与 $c$ 满足 $a_ix+y=c_i$ （$1\le i\le n$）。

很可惜的是，她忘记了所有 $a_i$ 的值与 $y$ 的值。她给你了 $x$ 的值与序列 $c$，并希望你能还原出一组 $y$ 的值与序列 $a$ 使得原先的条件被满足。

当然，可能存在很多组这样的解，所以她希望你能最大化 $y$ 的值并输出它（注意到你并不需要输出 $a$ 序列）。如果不能还原出这样一组数，请输出 $-1$ 来报告无解。

## 说明/提示

数据保证，$1 \leq n \leq 10^5$，$1 \leq x \leq 10^{12}$，$1 \leq c_i \leq 10^{18}$。

## 样例 #1

### 输入

```
5 2
4 6 8 10 12```

### 输出

```
2```

## 样例 #2

### 输入

```
5 2
3 6 9 12 15```

### 输出

```
-1```

# AI分析结果



## 算法分类
数论

---

## 题解思路与难点
### 核心公式推导
题目要求找到最大的正整数 $y$，使得所有 $c_i$ 满足 $a_i x + y = c_i$。变形后得：
$$
y = c_i - a_i x \quad (a_i \geq 1)
$$
所有 $c_i$ 必须同余于 $y$ 模 $x$，即 $c_i \equiv y \pmod{x}$。为了最大化 $y$，取 $y = \min(c_i) - x$。

### 解决难点
1. **条件判断**：需满足所有 $c_i > x$ 且同余。
2. **余数一致性**：遍历数组检查每个元素的余数是否相同。
3. **时间复杂度**：部分题解排序导致 $O(n \log n)$，最优解法为 $O(n)$。

---

## 高星题解（评分≥4）
1. **fish_shit（5星）**  
   - **亮点**：$O(n)$ 时间，正确使用相邻差判断余数，高效且无需排序。
   - **代码**：直接遍历检查相邻差和最小值，逻辑简洁。
2. **Chenyichen0420（4星）**  
   - **亮点**：通过差值验证余数，直观展示公式推导。
   - **不足**：排序导致 $O(n \log n)$。
3. **Undertale_chara（4星）**  
   - **亮点**：显式计算余数，代码结构清晰。
   - **不足**：同样使用排序。

---

## 最优思路提炼
1. **余数同余**：所有 $c_i \bmod x$ 必须相同。
2. **最小值决定 $y$**：$y = \min(c_i) - x$，确保 $a_i$ 为正整数。
3. **高效实现**：遍历数组时同步检查条件和记录最小值。

---

## 同类型题套路
- **模运算一致性**：如求最长连续子数组满足同余。
- **极值优化**：结合模运算与极值（如最小值）确定最优解。

---

## 相似题目推荐
1. **P1082 同余方程**（数论，扩展欧几里得）
2. **P2424 约数和**（模运算与数列性质）
3. **P5656 二元一次不定方程**（整数解的存在性）

---

## 代码实现（核心逻辑）
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
    ll n, x;
    cin >> n >> x;
    ll min_c = 1e18, remainder = -1;
    
    for (ll i = 0, c; i < n; ++i) {
        cin >> c;
        if (c <= x) { cout << -1; return 0; }  // 条件1：c_i > x
        if (i == 0) remainder = c % x;         // 初始余数
        else if (c % x != remainder) {         // 条件2：余数相同
            cout << -1; return 0;
        }
        min_c = min(min_c, c);
    }
    cout << min_c - x;  // 最大y
    return 0;
}
```

---

## 可视化设计
### 动画流程
1. **遍历元素**：高亮当前 $c_i$，显示余数和检查条件。
2. **余数一致性**：用颜色标记不同余数元素，若冲突则播放失败音效。
3. **记录最小值**：动态更新最小值，最终显示 $y = \text{min} - x$。

### 复古像素风格
- **颜色方案**：绿色（通过检查）、红色（冲突）、黄色（当前元素）。
- **音效**：成功（8-bit 胜利音效），失败（低沉蜂鸣）。
- **Canvas 动画**：元素以像素块排列，余数显示为底部小方块。

---
处理用时：257.13秒
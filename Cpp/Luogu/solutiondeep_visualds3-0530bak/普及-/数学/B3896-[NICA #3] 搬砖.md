# 题目信息

# [NICA #3] 搬砖

## 题目描述

Aya 在工地上搬砖。她手上有 $n$ 块砖头，需要将其平分为两份运达不同的终点。注意，砖头不能切割成半块。

Aya 可以选择一块一块的搬砖，此时搬一块砖需要 $a$ 的体力。Aya 也可以选择将砖头搬上一个可以容纳 $k$ 块砖头的推车（车可以不装满），再推动推车到达终点，这整个过程需要 $b$ 的体力。Aya 可以自由选择搬砖的方式。例如说她可以一块一块地搬一些砖之后再用推车进行搬砖。

Aya 想要知道，在这个过程中，耗费体力的最小值是多少？

## 说明/提示

**【样例解释】**

对于样例 $1$，将砖平分为两份，则每份一共有 $6$ 块砖。用小推车一次可以搬 $2$ 块砖，只耗费 $2$ 的体力，比一块一块搬砖划算。因此 Aya 选择用三次小推车搬砖，耗费 $6$ 的体力。注意一共有两份砖头，因此一共是耗费 $12$ 的体力。

**【数据范围】**

对于所有数据，$1 \leq n,a,k,b \leq 10^6$。**请注意数据范围**。

## 样例 #1

### 输入

```
12 3 2 2```

### 输出

```
12```

## 样例 #2

### 输入

```
15 3 2 2```

### 输出

```
-1```

# AI分析结果



---

## 算法分类
**数论**

---

## 综合分析与结论
1. **核心思路**  
   - **奇偶判定**：若总砖数 `n` 为奇数，无法平分，直接输出 `-1`。  
   - **每份砖数**：若 `n` 为偶数，每份砖数为 `m = n/2`。  
   - **策略选择**：对每份 `m` 块砖，计算两种搬运方式的体力消耗：  
     - **推车经济性**：若推车单次体力 `b` < 单独搬运 `k` 块的体力 `a*k`，则尽可能多用推车。  
     - **余数处理**：计算最大推车次数 `x = m // k` 和余数 `r = m % k`，比较两种方案：  
       - **方案1**：`x` 次推车 + 单独搬运余数 `r`，总消耗 `x*b + r*a`。  
       - **方案2**：`x+1` 次推车（最后一次装不满），总消耗 `(x+1)*b`。  
     - **取最小值**：最终每份体力为两种方案的最小值。  
   - **总体力计算**：每份体力乘以 2（两份终点）。

2. **关键公式推导**  
   - **推车经济性条件**：`b < a*k`。  
   - **余数处理优化**：当 `r*a > b` 时，用方案2更优，否则用方案1。  
   - **最终体力公式**：  
     ```  
     per_cost = min(x*b + r*a, (x+1)*b)  # 当 b < a*k  
     per_cost = m*a                      # 否则  
     ```

3. **可视化设计**  
   - **动画演示**：  
     - **步骤1**：高亮 `n` 的奇偶性判定，若为奇数，触发失败音效并结束。  
     - **步骤2**：分解 `n` 为两等份，每份 `m` 块砖。  
     - **步骤3**：动态比较 `b` 和 `a*k`，标记经济性分支。  
     - **步骤4**：计算 `x` 和 `r`，用颜色区分方案1和方案2的计算过程。  
     - **步骤5**：比较两种方案，高亮最小值，总体力翻倍后输出。  
   - **复古像素效果**：  
     - 用 8-bit 砖块图标表示搬运过程，推车用像素动画模拟移动。  
     - 成功时播放上扬音效，数值变化伴随轻微“滴答”声。

---

## 题解评分（4.5星）
**关键亮点**：  
- **数学推导精准**：通过模运算和贪心策略快速定位最优解。  
- **边界处理完善**：正确处理奇偶性和余数优化。  
- **代码简洁高效**：时间复杂度 `O(1)`，直接数学计算无冗余操作。  

---

## 最优代码实现
```cpp
#include <iostream>
using namespace std;

int main() {
    long long n, a, k, b;
    cin >> n >> a >> k >> b;
    if (n % 2 != 0) {
        cout << -1 << endl;
        return 0;
    }
    long long m = n / 2;
    long long per_cost;
    if (b < a * k) {
        long long x = m / k;
        long long r = m % k;
        long long option1 = x * b + r * a;
        long long option2 = (x + 1) * b;
        per_cost = min(option1, option2);
    } else {
        per_cost = m * a;
    }
    cout << per_cost * 2 << endl;
    return 0;
}
```

---

## 相似题目推荐
1. **P1031 均分纸牌**（贪心策略）  
2. **P2920 时间管理**（优化选择与数学建模）  
3. **P4995 跳跳！**（动态规划与数学分析）  

---

## 个人心得
- **调试经验**：注意 `x+1` 次推车可能超出实际需求，需通过数学证明其合法性。  
- **优化技巧**：直接比较 `b` 和 `a*r` 避免遍历所有可能的推车次数，极大提升效率。  

---

## 可视化算法演示
1. **像素动画**：  
   - **Canvas 绘制**：砖块用棕色像素表示，推车用蓝色矩形。  
   - **搬运过程**：推车移动时，砖块从起点移动到终点，伴随音效。  
2. **自动推导模式**：  
   - 逐步显示数值计算过程，如 `x` 和 `r` 的计算，高亮当前比较的公式。  
3. **交互控制**：  
   - 可调节速度观察每一步决策，暂停查看中间值。  
   - 失败时显示红色警告框和短促音效，成功显示绿色结果框。

---
处理用时：238.83秒
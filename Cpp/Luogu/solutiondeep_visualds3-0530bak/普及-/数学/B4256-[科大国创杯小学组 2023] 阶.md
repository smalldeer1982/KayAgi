# 题目信息

# [科大国创杯小学组 2023] 阶

## 题目背景

小多最近学习了一点数论。

最近她学习了阶这个概念，对算阶很有兴趣。

但是手算阶太难了，请你帮帮她。

## 题目描述

给定一个质数 $ p $，定义一个数 $ x (1 \leq x < p) $ 模 $ p $ 的阶为：最小的正整数 $ t $ 使得 $ x^t $ 模 $ p $ 等于 $1$（即 $ x^t $ 除以 $ p $ 的余数为 $1$），可以证明：这样的正整数一定存在。

现在请你帮助小多算若干组阶。

## 说明/提示

### 样例解释

以第一个和第五个为例。

第一个问题中 $1^1 = 1$，而 $1$ 是最小的正整数，所以显然为答案。

第五个问题中 $2^1 = 2, 2^2 = 4, 2^3 = 8$ 模 $5$ 不为 1，$2^4 = 16$ 模 $5$ 为 $1$，因此 $4$ 为答案。

### 提示

如果你不知道一些数论知识，下面这个信息可能对你有用：可以证明 $x\ (1 \leq x < p)$ 模质数 $p$ 意义下的阶一定小于 $p$。

### 数据范围

对于 $40\%$ 的数据，满足 $p \leq 100$。

对于 $70\%$ 的数据，满足 $p \leq 10^4$。

对于 $100\%$ 的数据，满足 $1 \leq T \leq 10$，$1 \leq x < p \leq 10^5$，保证 $p$ 是质数。

## 样例 #1

### 输入

```
7
2 1
3 1
3 2
5 1
5 2
5 3
5 4```

### 输出

```
1
1
2
1
4
4
2```

# AI分析结果



---

**唯一算法分类**  
无算法分类

---

## 综合分析与结论  
### 核心思路  
题目要求计算数论中「阶」的最小值。核心思路基于以下数论性质：  
1. **费马小定理**：对于质数 p，x^(p-1) ≡ 1 mod p。  
2. 阶 t 必为 p-1 的因数。  

**算法步骤**：  
1. 计算 p-1 的所有因数，并按升序排列。  
2. 对每个因数 d，验证 x^d ≡ 1 mod p，返回第一个满足的 d。  

**关键优化**：  
- 通过快速幂计算 x^d mod p，时间复杂度 O(log d)。  
- 仅遍历 p-1 的因数而非所有数，将最坏时间复杂度从 O(p) 降至 O(√p log p)。  

### 可视化设计  
1. **因数生成动画**：  
   - 在 Canvas 网格中，动态绘制 p-1 的因数生成过程，高亮当前检查的因数。  
2. **快速幂演示**：  
   - 将指数 d 分解为二进制位，逐位计算幂并取模，以像素方块颜色变化表示中间结果。  
3. **复古像素风格**：  
   - 使用 8 位色调色板（如绿色、红色、蓝色）渲染因数列表和模幂过程。  
   - 成功时播放「通关音效」，失败时播放「错误音效」。  

---

## 题解清单 (≥4星)  
1. **因数分解 + 快速幂（★★★★★）**  
   - **亮点**：数学性质利用充分，时间复杂度最优。  
   - **代码简读**：  
     ```cpp  
     vector<int> get_factors(int n) {
         vector<int> factors;
         for (int i = 1; i*i <= n; ++i) {
             if (n % i == 0) {
                 factors.push_back(i);
                 if (i != n/i) factors.push_back(n/i);
             }
         }
         sort(factors.begin(), factors.end());
         return factors;
     }
     ```  
   - **核心思想**：生成所有因数后，从小到大验证。  

---

## 代码实现  
```cpp  
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> get_factors(int n) {
    vector<int> factors;
    for (int i = 1; i*i <= n; ++i) {
        if (n % i == 0) {
            factors.push_back(i);
            if (i != n/i) factors.push_back(n/i);
        }
    }
    sort(factors.begin(), factors.end());
    return factors;
}

int mod_pow(int x, int d, int p) {
    long long res = 1;
    long long base = x % p;
    while (d > 0) {
        if (d & 1) res = (res * base) % p;
        base = (base * base) % p;
        d >>= 1;
    }
    return (int)res;
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        int p, x;
        cin >> p >> x;
        if (x == 1) {
            cout << "1\n";
            continue;
        }
        vector<int> factors = get_factors(p-1);
        for (int d : factors) {
            if (mod_pow(x, d, p) == 1) {
                cout << d << "\n";
                break;
            }
        }
    }
    return 0;
}
```

---

## 同类型题目与拓展  
1. **快速幂模板**：P1226  
2. **质因数分解应用**：P1069  
3. **离散对数问题**：P2485  

---

## 个人心得  
- **调试经验**：直接枚举 p-1 的因数而非所有数，可大幅减少计算量。  
- **关键点**：利用阶必为 φ(p) 的因数这一性质，避免无效枚举。  

---

## 复古游戏化动画实现要点  
1. **Canvas 绘制**：  
   - 网格中展示 p-1 的因数生成，每个因数以不同颜色方块表示。  
2. **音效触发**：  
   - 发现因数时播放「滴」声，找到答案时播放「胜利旋律」。  
3. **自动演示模式**：  
   - AI 自动遍历因数并高亮当前检查项，步进间隔可调节。

---
处理用时：184.70秒
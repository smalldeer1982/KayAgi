# 题目信息

# [NOIP 2012 提高组] 借教室

## 题目描述

在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。

面对海量租借教室的信息，我们自然希望编程解决这个问题。

我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_i$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_j,s_j,t_j$，表示某租借者需要从第 $s_j$ 天到第 $t_j$ 天租借教室（包括第 $s_j$ 天和第 $t_j$ 天），每天需要租借 $d_j$ 个教室。

我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供 $d_j$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。

借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_j$ 天到第 $t_j$ 天中有至少一天剩余的教室数量不足 $d_j$ 个。

现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。


## 说明/提示

【输入输出样例说明】

第 $1 $份订单满足后，$4 $天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2 $天到第 $4$ 天每天提供 $3$ 个教室，而第 $3$ 天剩余的教室数为$ 2$，因此无法满足。分配停止，通知第 $2$ 个申请人修改订单。

【数据范围】

对于 $10\%$ 的数据，有 $1\le n,m\le 10$；

对于 $30\%$ 的数据，有 $1\le n,m\le 1000$；

对于 $70\%$ 的数据，有 $1 \le n,m \le 10^5$；

对于 $100\%$ 的数据，有 $1 \le n,m \le 10^6$，$0 \le r_i,d_j\le 10^9$，$1 \le s_j\le t_j\le n$。


NOIP 2012 提高组 第二天 第二题

2022.2.20 新增一组 hack 数据

## 样例 #1

### 输入

```
4 3 
2 5 4 3 
2 1 3 
3 2 4 
4 2 4```

### 输出

```
-1 
2```

# AI分析结果



**算法分类**: 无算法分类（主要涉及二分答案与差分数组技巧）

---

### 题解思路与核心分析

#### 核心难点
1. **大规模数据处理**：n和m的范围达到1e6，暴力枚举订单和天数会导致O(mn)复杂度，无法通过。
2. **区间操作优化**：订单对应天数的教室需求是区间减法操作，需高效处理。
3. **单调性判定**：若前k个订单无法满足，则后续订单必定无法满足，需快速定位首个失败订单。

#### 关键思路：二分答案 + 差分数组
1. **二分答案**：确定能满足的最大订单数mid，利用单调性缩小范围。
2. **差分数组**：将区间减法转换为端点操作，O(1)修改，O(n)计算总需求。
3. **验证函数**：对每个mid值，通过差分快速模拟前mid个订单的教室分配。

---

### 最优解法代码实现

```cpp
#include <cstdio>
#include <cstring>
using namespace std;

const int MAXN = 1e6 + 5;
int n, m;
int r[MAXN], d[MAXN], s[MAXN], t[MAXN];
int diff[MAXN];

bool check(int mid) {
    memset(diff, 0, sizeof(diff));
    for (int i = 1; i <= mid; ++i) {
        diff[s[i]] += d[i];
        diff[t[i] + 1] -= d[i];
    }
    int current = 0;
    for (int i = 1; i <= n; ++i) {
        current += diff[i];
        if (current > r[i]) return false;
    }
    return true;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%d", &r[i]);
    for (int i = 1; i <= m; ++i) scanf("%d%d%d", &d[i], &s[i], &t[i]);
    
    int left = 1, right = m, ans = 0;
    if (check(m)) {
        printf("0\n");
        return 0;
    }
    while (left <= right) {
        int mid = (left + right) >> 1;
        if (check(mid)) {
            left = mid + 1;
        } else {
            right = mid - 1;
            ans = mid;
        }
    }
    printf("-1\n%d\n", ans);
    return 0;
}
```

---

### 可视化算法分析

1. **动画步骤**：
   - **差分初始化**：展示每个订单的s和t+1端点如何修改diff数组。
   - **前缀和计算**：逐步累加diff数组，高亮当前计算的天数，对比r[i]判断是否超限。
   - **二分过程**：动态显示left和right边界变化，mid值的计算与判定结果。

2. **颜色标记**：
   - **红色**：当前订单导致超限的天数。
   - **绿色**：成功通过验证的订单范围。
   - **黄色**：正在处理的差分区间端点。

3. **复古游戏化设计**：
   - **8位像素风格**：用色块表示天数，订单处理时播放“滴答”音效。
   - **自动演示模式**：AI模拟二分过程，每步展示diff数组变化与验证结果。
   - **音效反馈**：成功/失败时播放不同音调，增强交互体验。

---

### 相似题目推荐
1. **P3406 海底高铁**（区间覆盖与差分统计）
2. **P3368 【模板】树状数组 2**（区间修改与单点查询）
3. **P2367 语文成绩**（差分数组优化批量修改）

---

### 总结与心得
- **差分技巧**是处理区间批量操作的核心，将O(n)操作降为O(1)。
- **二分答案**适用于具有单调性的判定问题，极大减少无效计算。
- **边界处理**需谨慎，如t+1可能导致数组越界，需预留足够空间。

---
处理用时：78.90秒
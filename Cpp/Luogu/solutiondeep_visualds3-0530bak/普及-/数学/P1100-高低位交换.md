# 题目信息

# 高低位交换

## 题目描述

给出一个小于 $2^{32}$ 的非负整数。这个数可以用一个 $32$ 位的二进制数表示（不足 $32$ 位用 $0$ 补足）。我们称这个二进制数的前 $16$ 位为“高位”，后 $16$ 位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。

例如，数 $1314520$ 用二进制表示为 $0000\,0000\,0001\,0100\,0000\,1110\,1101\,1000$（添加了 $11$ 个前导 $0$ 补足为 $32$ 位），其中前 $16$ 位为高位，即 $0000\,0000\,0001\,0100$；后 $16$ 位为低位，即 $0000\,1110\,1101\,1000$。将它的高低位进行交换，我们得到了一个新的二进制数 $0000\,1110\,1101\,1000\,0000\,0000\,0001\,0100$。它即是十进制的 $249036820$。


## 样例 #1

### 输入

```
1314520
```

### 输出

```
249036820
```

# AI分析结果



## 数学分类
**数论**（位运算与数值结构重组）

---

## 题解核心思路与算法要点

### 数学方法核心
1. **位运算公式推导**  
   - 将32位无符号整数看作两部分：高16位 `H` 和低16位 `L`
   - 交换后数值为：`new_num = (L << 16) | H` 或等价数学形式 `L * 2^16 + H`
   - **关键公式**：  
     $$ \text{new\_num} = (n \ \& \ \text{0x0000ffff}) \ll 16 \quad | \quad (n \ \& \ \text{0xffff0000}) \gg 16 $$

2. **实现难点**  
   - **符号位处理**：必须使用 `unsigned int` 避免符号扩展  
   - **溢出控制**：左移16位后自动溢出，无需额外取模  
   - **掩码设计**：`0x0000ffff` 提取低16位，`0xffff0000` 提取高16位  

---

## 高星题解评分（≥4★）

### 1. HenryHuang（5★）  
**亮点**：  
- 双掩码严格分离高低位  
- 兼容所有数据类型和编译器  
- 注释清晰，强调无符号必要性  

```cpp
cout << ((x&0x0000ffff)<<16 | (x&0xffff0000)>>16);
```

### 2. 月影困（4.5★）  
**亮点**：  
- 极简主义，一行代码解决问题  
- 利用溢出特性省去掩码  
- 需注意 `unsigned int` 类型声明  

```cpp
printf("%u\n", (n >> 16) + (n << 16));
```

### 3. 离散小波变换°（4★）  
**亮点**：  
- 提供两种等价实现对比  
- 详细数学推导与二进制示例  
- 强调数据类型选择的重要性  

---

## 最优思路提炼

### 关键技巧
1. **位运算组合**：  
   - 左移16位将低位升至高位，右移16位将高位降至低位  
   - `(n << 16)` 等价于 `L * 2^16`，`(n >> 16)` 等价于 `H / 2^16`  

2. **无符号类型**：  
   - 强制使用 `unsigned int` 避免符号位干扰  

3. **掩码优化**：  
   - 掩码操作 `& 0x0000ffff` 可省略，直接依赖溢出特性简化代码  

---

## 同类型算法套路

1. **二进制位操作**：  
   - 常见于数据加密、IP地址处理、图像像素操作  
   - 通用公式：`swap_bits(n, i, j)` = 交换第i位与第j位  

2. **数值分块重组**：  
   - 如将64位整数拆分为4个16位块进行并行计算  

---

## 推荐相似题目
1. **P1017 进制转换**（负基数转换）  
2. **P1062 数列**（二进制位权展开）  
3. **P2114 [NOI2016] 优秀的拆分**（位运算与字符串哈希）  

---

## 可视化与算法演示

### 动画设计
1. **8位像素风格**：  
   - 用绿色像素块表示低16位，红色表示高16位  
   - 交换时像素块平移并播放 "NES 过关音效"  

2. **关键步骤高亮**：  
   - 左移操作：绿色块向左飞入高位区域  
   - 右移操作：红色块向右滑入低位区域  
   - 合并结果：显示 `new_num` 的二进制火焰特效  

3. **交互控制**：  
   - 速度滑块调节移位动画速度  
   - 单步执行按钮观察每一步位模式  

```javascript
// 伪代码：Canvas绘制32位二进制
function drawBits(ctx, bits, x, y, color) {
  bits.forEach((bit, i) => {
    ctx.fillStyle = bit ? color : "#333";
    ctx.fillRect(x + i * 8, y, 6, 6);
  });
}

// 移位动画
animateShift(ctx, original, shifted, direction) {
  // 实现位块平移动画...
}
```

---

## 个人心得摘录
> **HenryHuang**：  
> “掩码操作看似冗余，但在某些编译器中能避免未定义行为，代码健壮性比简洁更重要。”  

> **月影困**：  
> “C++的隐式溢出特性让代码极度简化，但必须严格测试边界条件。”  

---

## 核心代码实现
```cpp
#include <iostream>
using namespace std;

int main() {
    unsigned int n;
    cin >> n;
    // 最优单行实现
    cout << (n >> 16 | n << 16);
    return 0;
}
```

---
处理用时：66.23秒
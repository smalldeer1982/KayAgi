# 题目信息

# [USACO1.1] 黑色星期五Friday the Thirteenth

## 题目描述

$13$ 号又是一个星期五，那么 $13$号在星期五比在其他日子少吗？  

为了回答这个问题，写一个程序，要求计算每个月的十三号落在周一到周日的次数。给出 $n$ 年的一个周期，要求计算 $1900$ 年 $1$ 月 $1$ 日至 $1900+n-1$ 年 $12$ 月 $31$ 日中十三号落在周一到周日的次数。

这里有一些你要知道的:

1. $1900$ 年 $1$ 月 $1$ 日是星期一。
2. $4,6,11$ 和 $9$ 月有 $30$ 天，其他月份除了 $2$ 月都有 $31$ 天，闰年 $2$ 月有 $29$ 天，平年 $2$ 月有 $28$ 天。
3. 年份可以被 $4$ 整除的为闰年（$1992=4\times 498$ 所以 $1992$ 年是闰年，但是 $1990$ 年不是闰年）。
4. 以上规则不适合于世纪年。可以被 $400$ 整除的世纪年为闰年，否则为平年。所以，$1700,1800,1900,2100$ 年是平年，而 $2000$ 年是闰年。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 400$。

题目翻译来自NOCOW。

USACO Training Section 1.1


## 样例 #1

### 输入

```
20
```

### 输出

```
36 33 34 33 35 35 34
```

# AI分析结果



---

**算法分类**：数论

---

### **题解思路与难点解析**

#### **核心难点**
1. **闰年判定**：需正确处理世纪年（能被400整除）与普通闰年（能被4整除但不能被100整除）。
2. **日期递推**：高效计算每月13号的星期数，避免逐日模拟的低效操作。
3. **公式应用**：正确使用基姆拉尔森或蔡勒公式直接计算星期数。

#### **关键算法对比**
| 方法               | 时间复杂度 | 核心思想                                                                 |
|--------------------|------------|--------------------------------------------------------------------------|
| 暴力逐日模拟       | O(n*365)   | 逐天累加，判断闰年，记录13号的星期数。代码冗长但直观。                   |
| 基姆拉尔森公式     | O(n*12)    | 数学公式直接计算每月13号星期数，1月和2月视为上一年的13、14月，高效简洁。 |
| 递推间隔天数       | O(n*12)    | 计算相邻两月13号之间的天数差，模7后递推星期数，避免重复计算。             |
| 蔡勒公式           | O(n*12)    | 类似基姆拉尔森，需调整年、月参数，适用于更广泛的日期计算。               |

---

### **题解评分（≥4星）**

1. **HEIGE（5星）**  
   - **亮点**：基姆拉尔森公式直接计算，代码简洁高效（仅20行）。  
   - **代码片段**：  
     ```cpp
     int week_day(int year, int month, int day) {
         if (month == 1 || month == 2) month += 12, year--;
         return (day + 2*month + 3*(month+1)/5 + year + year/4 - year/100 + year/400 + 1) % 7;
     }
     ```
     **核心公式**：基姆拉尔森公式，通过调整月份参数简化计算。

2. **早右昕（4星）**  
   - **亮点**：递推每月间隔天数，避免逐日模拟。  
   - **代码片段**：  
     ```cpp
     struct date {int yy, mm, ww;};
     void operator++(date &a) {
         bool spl = 闰年判断;
         a.ww += 当月天数; a.ww %= 7;
     }
     ```
     **核心思路**：通过结构体维护当前日期和星期，按月递推。

3. **Shan＿Xian（4星）**  
   - **亮点**：蔡勒公式实现，支持更广泛日期计算。  
   - **代码片段**：  
     ```cpp
     int ZellerWeek(int year, int month, int day) {
         if (month <= 2) { year--; month += 12; }
         int y = year % 100, c = year / 100;
         return (y + y/4 + c/4 - 2*c + 26*(month+1)/10 + day - 1) % 7;
     }
     ```
     **公式推导**：蔡勒公式的变形，适用于不同世纪。

---

### **最优技巧提炼**

1. **基姆拉尔森公式**  
   - **公式**：  
     ```
     w = (d + 2m + 3(m+1)/5 + y + y/4 - y/100 + y/400 + 1) % 7  
     （1月、2月视为上年的13、14月）
     ```
   - **优势**：无需逐日计算，直接求得任意日期的星期数。

2. **递推法**  
   - **步骤**：  
     1. 初始值：已知1900年1月13日为星期六（基姆拉尔森公式计算结果）。  
     2. 计算当前月天数模7的余数，累加到当前星期数。  
     3. 结果模7即为下个月13号的星期数。  
   - **示例**：  
     - 1月31天 → 31%7=3 → 星期六(6) +3 → 下月13号为星期二(2)。

---

### **同类型题目推荐**

1. **P1202 [USACO1.1]黑色星期五**（本题）  
2. **P1977 日期计算**（计算特定日期的星期数）  
3. **P1057 校门外的树**（日期区间覆盖问题，需结合星期筛选）

---

### **可视化与算法演示**

#### **动画设计（复古像素风格）**
1. **初始化**：  
   - 背景：8位像素风格日历，显示1900年1月。  
   - 元素：高亮显示1月13日（星期六），右侧统计数组`ans[6]++`。

2. **递推步骤**：  
   - **步骤1**：计算当前月天数，显示红色边框（如1月31天）。  
   - **步骤2**：计算`31%7=3`，动画显示`6（周六） +3 → 9 → 2（周二）`。  
   - **步骤3**：更新统计数组，播放“滴”音效，背景变绿表示成功。

3. **交互功能**：  
   - **速度调节**：滑动条控制月份递推速度（1x~10x）。  
   - **单步执行**：按空格键逐月查看计算过程。  

#### **代码演示（关键递推逻辑）**
```javascript
// 伪代码：递推每月13号的星期数
let ans = [0, 0, 0, 0, 0, 0, 0];
let currentWeek = 6; // 初始为周六（1900-01-13）
for (let year = 1900; year < 1900 + n; year++) {
    for (let month = 1; month <= 12; month++) {
        ans[currentWeek]++; // 统计当前月13号
        let days = getMonthDays(year, month); // 获取当月天数
        currentWeek = (currentWeek + days) % 7; // 递推下个月
    }
}
```

---

### **个人心得摘录**

- **HEIGE**：“竞赛环境下不能指望背下公式，但数学方法能大幅减少代码量。”  
- **早右昕**：“通过结构体封装日期和星期，使递推逻辑更清晰，减少边界错误。”  
- **Shan＿Xian**：“蔡勒公式的变形需特别注意1月和2月的处理，调试时多次因月份调整出错。”

---

**总结**：优先采用基姆拉尔森公式或递推法，时间复杂度低且代码简洁。可视化中通过像素动画和音效增强理解，适合教学演示。

---
处理用时：99.25秒
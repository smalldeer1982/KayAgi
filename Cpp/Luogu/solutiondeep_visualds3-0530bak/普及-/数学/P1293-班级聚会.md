# 题目信息

# 班级聚会

## 题目描述

毕业25年以后，我们的主人公开始准备同学聚会。打了无数电话后他终于搞到了所有同学的地址。他们有些人仍在本城市，但大多数人分散在其他的城市。不过，他发现一个巧合，所有地址都恰好分散在一条铁路线上。他准备出发邀请但无法决定应该在哪个地方举行宴会。最后他决定选择一个地点，使大家旅行的花费和最小。

不幸的是，我们的主人公既不擅长数学，也不擅长计算机。他请你帮忙写一个程序，根据他同学的地址，选择聚会的最佳地点。花费相同时优先取靠近莫斯科的城市。


## 说明/提示

### 数据范围及约定

对于全部数据，保证城市数量 $ \le 150$，距离 $ \le 10000$，同学个数 $ \le 50$。

## 样例 #1

### 输入

```
7 9289 Vladivostok
5 8523 Chabarovsk
3 5184 Irkutsk
8 2213 Yalutorovsk
10 0 Moscow
```

### 输出

```
Yalutorovsk 112125
```

# AI分析结果



# 班级聚会题解分析

## 数学分类
**组合数学**  
该问题属于一维最优位置选择问题，应用加权中位数理论求解总花费最小。

---

## 题解思路与算法要点
### 核心思路
1. **暴力枚举**：遍历所有城市，计算每个城市作为聚会点的总花费（距离差绝对值乘以人数），取最小值。时间复杂度 O(n²)，适用于小数据。
2. **加权中位数优化**：  
   - 将城市按距离排序后，累加人数直到超过总人数的一半，此时位置即为最优解。  
   - 正确性基于：总花费最小化的位置是加权中位数点，时间复杂度 O(n log n)。

### 解决难点
- **暴力法**：需正确处理输入结束条件（读到 Moscow 或距离为 0 时停止），并处理相同花费时优先取更近莫斯科的城市。
- **加权中位数法**：需先按城市距离排序，再累加人数找到中位点，确保数学推导的正确性。

---

## 题解评分（≥4星）
1. **秋雨（4.5星）**  
   - 暴力枚举 + 排序处理相同花费情况，代码简洁清晰。
   - 关键代码：通过双重循环计算每个城市总花费，利用排序处理优先级。
   ```cpp
   sort(a, a+tot, cmp); // 按花费和距离排序
   ```
2. **lz2018（4星）**  
   - 直接暴力枚举，未排序但通过动态比较更新最小值。
   - 代码亮点：简洁的输入处理和动态比较逻辑。
3. **Soyilieber（3.5星）**  
   - 尝试加权中位数法，但未显式排序城市，可能导致中位点计算错误。
   - 需补充排序步骤以确保正确性。

---

## 最优思路提炼
**加权中位数法**（数学优化）  
1. 按城市距离排序。
2. 计算总人数的一半，累加人数至超过该值时的位置即为最优解。  
3. 时间复杂度 O(n log n)（排序占主导）。

**关键公式**：  
总花费 = Σ（人数 × |当前城市距离 - 其他城市距离|）

---

## 同类型题目与算法套路
1. **仓库选址问题**：在一维或二维空间中寻找点，使总运输成本最小。
2. **常见解法**：中位数（一维）或几何中位数（二维）。

---

## 推荐题目
1. [P2512 HAOI2008 糖果传递](https://www.luogu.com.cn/problem/P2512)  
2. [CF702B Optimal Point](https://codeforces.com/problemset/problem/702/B)  
3. [LeetCode 296. Best Meeting Point](https://leetcode.com/problems/best-meeting-point/)

---

## 可视化与算法演示
### 动画方案设计
1. **像素风格铁路线**：  
   - 用不同颜色方块表示城市，高度表示人数。
   - 当前选中城市高亮为黄色，计算时显示距离差连线。
2. **计算流程**：  
   - 遍历每个城市时，动态显示红色线段表示距离差，右侧面板实时更新总花费。
   - 找到更优解时播放“叮”音效，最终结果以绿色闪烁提示。
3. **交互控制**：  
   - 步进按钮单步执行，滑动条调节速度。
   - 支持自动模式模拟“AI推导”，按中位数逻辑自动跳转到最优解。

### 复古游戏化效果
- **8-bit 音效**：计算步进（短哔声）、找到最优解（胜利音效）。
- **积分系统**：每正确跳过无需计算的城市（如中位数优化）奖励额外分数。

---

## 核心代码实现（加权中位数法）
```cpp
#include <algorithm>
#include <iostream>
using namespace std;

struct City { int people, dist; string name; };

int main() {
    vector<City> cities;
    int total = 0;
    // 输入并排序
    while (true) {
        int p, d; string s;
        cin >> p >> d >> s;
        cities.push_back({p, d, s});
        total += p;
        if (s == "Moscow") break;
    }
    sort(cities.begin(), cities.end(), [](City a, City b) {
        return a.dist < b.dist;
    });

    // 找加权中位数
    int half = total / 2, sum = 0, idx = 0;
    while (sum <= half && idx < cities.size()) {
        sum += cities[idx].people;
        idx++;
    }
    idx = max(0, idx-1); // 中位点

    // 计算总花费
    int cost = 0;
    for (auto c : cities) 
        cost += c.people * abs(c.dist - cities[idx].dist);
    
    cout << cities[idx].name << " " << cost;
}
```

---
处理用时：135.50秒
# 题目信息

# [AHOI2002] 黑白图像压缩

## 题目描述

选修基础生物基因学的时候， 小可可在家里做了一次图像学试验。 她知道：整个图像其实就是若干个图像点(称作像素)的序列，假定序列中像素的个数总是 8 的倍数， 于是每八个像素可以转换成一个叫做字节的数， 从而这个表示图像的像素序列就被转换成了字节的序列。

所谓的字节就是一个八位的二进制数(当然，为了便于书写，人们经常用它的十进制形式来表示)。这八个像素从前向后依次对应于字节从高位到低位的八个位， 用 0 来表示白色像素、 1 来表示黑色像素。 这种表示方法叫做位图法。 例如字节序列 210、 0、255 表示了 8\*3=24 个像素， 由于对应的二进制形式是 11010010、 00000000、11111111， 所以这 24 个像素的颜色依次是黑、 黑、 白、 黑、 白、 白、 黑、 白、白、白、白、白、白、白、白、白、黑、黑、黑、黑、黑、黑、黑、黑。

小可可想： 其实图像中存在着很多连续的同色像素段， 也许换一种方式表达图像能够减少图像的数据量。 她的思路是： 把像素按照颜色分成若干个片段， 同一个片段中各像素颜色相同， 且连续的同色像素都在同一个片段中。同时已知每个片段的最大长度小于 128。

每一个像素片段都是用一个二进制字节量来表示， 最高位表示片段中像素的颜色， 而低七位表示片段中像素的数目。注意：不存在长度为 0 的像素片段。这种表示法叫做像素片段法。

例如位图表示法的字节序列 210、 0、 255 对应的像素序列可以分成七个片段，分别是： 11、 0、 1、 00、 1、 000000000、 11111111。如果用像素片段法来表示的话，二进制字节序列应该写成 10000010、 00000001、 10000001、00000010、 10000001、 00001001、 10001000， 而其对应于十进制字节序列就是 130、 1、 129、 2、 129、 9、 136。

像素片段法是否能有效地减少图像的数据存储量呢？小可可不知道如何用数学的方法加以证明， 于是决心对手头上的图像做些试验， 看看该方法是否真的有效。 请你编写程序完成图像信息的转换， 以协助小可可完成这项试验。


## 说明/提示

$1\leq n\leq 8\times 10^4$。

## 样例 #1

### 输入

```
8 0```

### 输出

```
8```

## 样例 #2

### 输入

```
24 210 0 255```

### 输出

```
130 1 129 2 129 9 136```

# AI分析结果



# 黑白图像压缩题解分析

## 唯一算法分类
**无算法分类**

---

## 题解思路与核心难点

### 数学方法与解题逻辑
所有题解均采用**游程编码**思想，核心步骤：
1. **二进制转换**：将每个输入的十进制数转换为8位二进制字符串（注意补前导0）
2. **连续片段统计**：从左到右扫描二进制字符串，统计连续相同颜色像素段
3. **压缩编码**：将每个片段编码为1位颜色+7位长度的字节值（颜色位左移7位后与长度相加）

### 解决难点
1. **二进制位顺序处理**：十进制转二进制时需注意高位在前低位在后的存储顺序（如输入210的二进制是`11010010`）
2. **边界处理**：正确处理第一个像素的初始状态和最后一个片段的输出
3. **位运算技巧**：用 `color << 7 | length` 快速生成压缩字节

---

## 题解评分（≥4星）

### 1. Light_az（4.5★）
**亮点**：最清晰的实现逻辑
- 预处理所有二进制位到数组
- 线性扫描统计连续片段
- 无复杂条件判断，代码可读性极佳
```cpp
int last=a[1],sum=1;
for(int i=2;i<=n;i++){//从第二位开始 
    if(a[i]==last) sum++;
    else{
        cout<<sum+last*128<<" ";
        last=a[i]; sum=1;
    }
}
cout<<sum+last*128<<" ";
```

### 2. UnyieldingTrilobite（4★）
**亮点**：STL简化代码
- 使用`bitset`自动处理二进制转换
- 添加哨兵字符`#`优化循环逻辑
```cpp
h = h + '#'; // 哨兵优化
for(int pos=0;pos<h.size()-1;++pos){
    int num=1;
    for(;h[pos]==h[pos+1];++pos)++num;
    if(h[pos]==49)num|=128;
    printf("%d ",num);
}
```

### 3. 快乐一凡（4★）
**亮点**：原位运算节省内存
- 直接在输入循环中处理二进制位
- 避免存储完整二进制字符串
```cpp
for(int j=7;j>=0;j--){ 
    k=i*8+j;
    b[k]=a[i]%2;
    a[i]/=2;
}
```

---

## 最优技巧提炼
### 关键实现公式
$$
\text{压缩字节} = (\text{颜色} \times 128) + \text{长度}
$$
**位运算优化**：  
`color << 7 | length` 比 `color * 128 + length` 效率更高

### 通用解法框架
1. **二进制转换层**：
   ```python
   def dec_to_bin(x):
       return format(x, '08b')  # 补足8位前导零
   ```
2. **游程编码层**：
   ```python
   def compress(s):
       res = []
       prev, cnt = s[0], 1
       for c in s[1:]:
           if c == prev: cnt += 1
           else:
               res.append( (int(prev) << 7) | cnt )
               prev, cnt = c, 1
       res.append( (int(prev) << 7) | cnt )
       return res
   ```

---

## 可视化算法设计
### 动画演示方案
1. **二进制转换阶段**：
   - 每个输入数字分解为8个像素方块
   - 用绿色（1）和白色（0）表示像素
   - 动态展示十进制→二进制的转换过程

2. **片段统计阶段**：
   ```javascript
   // 示例伪代码
   let currentColor = pixels[0];
   let counter = 1;
   
   for(let i=1; i<pixels.length; i++){
       if(pixels[i] === currentColor){
           counter++;
           highlightBlock(i); // 高亮当前块
       }else{
           addResultBlock(currentColor, counter); // 生成压缩块
           currentColor = pixels[i];
           counter = 1;
       }
   }
   addResultBlock(currentColor, counter); // 最后一块
   ```

3. **复古风格设计**：
   - **像素画风**：使用16色索引调色板（NES风格）
   - **音效设计**：
     - 转换二进制时播放短促的"哔"声（Web Audio API）
     - 生成压缩块时播放马里奥金币音效
   - **自动演示模式**：
     ```javascript
     function autoPlay(){
         if(step < totalSteps){
             processStep(step++);
             setTimeout(autoPlay, 1000 - speedSlider.value);
         }
     }
     ```

---

## 相似题目推荐
1. [P1320 压缩技术（续集版）](https://www.luogu.com.cn/problem/P1320)  
   （同样需要统计连续0/1的长度）

2. [P1319 压缩技术](https://www.luogu.com.cn/problem/P1319)  
   （二维版本的游程编码）

3. [P2550 彩票摇奖](https://www.luogu.com.cn/problem/P2550)  
   （位运算与匹配统计）

---

## 关键代码片段
### 位运算压缩核心
```cpp
// 来自题解 ICEMAGE
if (dq != wz[j]) {
    if (dq != 2) printf("%d ", add + 128*dq);
    dq = wz[j];
    add = 1;
} else add++;
```

### 二进制转换优化
```cpp
// 来自题解 Ofnoname
for (int p = 7; p >= 0; p--)
    a[++ac] = x >> p & 1; // 直接位操作取每一位
```

---

## 心得摘录
> "初始设置`dq=2`是为了跳过第一个片段的提前输出，这个技巧虽然巧妙但需要注释说明，否则容易引发理解困难" —— ICEMAGE题解调试笔记

> "添加`h = h + '#'`作为哨兵，使得循环结束时自动触发最后一个片段的输出，这个设计非常精妙" —— UnyieldingTrilobite题解批注

---

## 扩展应用
此题的压缩思路与**JPEG的游程编码**、**二维码的掩模模式**有相似之处，在图像处理基础算法中具有代表性。掌握这种分段统计技巧，可为后续学习霍夫曼编码等压缩算法奠定基础。

---
处理用时：80.15秒
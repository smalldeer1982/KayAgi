# 题目信息

# [PA 2015] Kieszonkowe

## 题目描述

给定 $n$ 个数，请从中选出若干个数，使得总和为偶数。

请最大化这个总和。

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 10^6$，$1\le a_i\le 10^3$。

## 样例 #1

### 输入

```
5
2 4 3 3 3```

### 输出

```
12```

# AI分析结果



### 数学分类选择
**数论**

---

### 题解思路与算法要点
**核心逻辑**：  
所有数总和为偶数时直接输出；总和为奇数时，需减去最小的奇数使其变为偶数。  
**数学推导**：  
- 奇偶性定理：奇数 + 奇数 = 偶数，偶数 ± 偶数 = 偶数  
- 总和为奇数 ⟹ 奇数个数必为奇数个  
- 减去最小的奇数 ⟹ 保证剩余总和最大  

**解决难点**：  
1. **高效找最小奇数**：无需排序，遍历时实时记录最小奇数（O(n)）  
2. **边界处理**：n=1且唯一数为奇数时无解  

**优化手段**：  
- 输入时直接累加总和并记录最小奇数，避免二次遍历或排序  

---

### 题解评分（≥4星）

| 作者 | 星级 | 关键亮点 |
|------|-----|---------|
| Yukinoshita_Yukino | ⭐⭐⭐⭐ | 线性时间找最小奇数，代码简洁高效 |
| Error_Eric | ⭐⭐⭐⭐ | 数学推导清晰，代码极致优化（压行版） |
| 霍士弘 | ⭐⭐⭐⭐ | 无解条件处理严谨，代码逻辑完整 |

---

### 最优思路提炼
**贪心策略**：  
1. 计算总和，若为偶数直接输出  
2. 若为奇数：  
   - 找到最小奇数并减去  
   - 特判 n=1 且该数为奇数的无解情况  

**代码实现技巧**：  
```cpp
int sum = 0, min_odd = INF;
for (int x : nums) {
    sum += x;
    if (x % 2) min_odd = min(min_odd, x);
}
if (sum % 2) sum -= min_odd;
```

---

### 同类型题套路
**常见数论套路**：  
1. 奇偶性转换：通过加减奇数调整总和奇偶性  
2. 极值优化：用最小代价（如减去最小奇数）达到目标性质  
3. 边界特判：单元素、全奇/偶等特殊场景  

---

### 推荐题目
1. **P5710 数的性质**（奇偶性判断与条件组合）  
2. **P1036 选数**（子集和奇偶性+质数判定）  
3. **P1149 火柴棒等式**（奇偶性优化枚举）  

---

### 可视化与算法演示
**像素化动画设计**：  
1. **元素高亮**：  
   - 绿色：偶数  
   - 红色：奇数，当前最小奇数闪烁  
2. **运算过程**：  
   - 第一帧：所有数堆叠显示，动态累加总和  
   - 若总和奇数：扫描红色方块，标记最小奇数后爆炸消失  
3. **音效设计**：  
   - "滴"声：选中偶数  
   - "哔"声：选中奇数  
   - 失败音效：无解时播放 8-bit 低沉音效  

**Canvas 伪代码**：  
```javascript
// 初始化参数
let sum = 0, minOdd = Infinity;
nums.forEach(num => {
    sum += num;
    if (num % 2 === 1) {
        minOdd = Math.min(minOdd, num);
        drawPixel(num, 'red', x, y); // 红色像素表示奇数
    } else {
        drawPixel(num, 'green', x, y); // 绿色像素表示偶数
    }
});
// 播放音效与动画
if (sum % 2 === 1) {
    playSound('beep'); // 提示需要减奇数
    highlightMinOdd(minOdd); // 最小奇数闪烁
    sum -= minOdd;
    animateExplosion(minOdd); // 爆炸动画
}
```

---

### 核心代码实现
**最优解代码**（Yukinoshita_Yukino 优化版）：  
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, sum = 0, min_odd = INT_MAX;
    scanf("%d", &n);
    for (int i = 0, x; i < n; ++i) {
        scanf("%d", &x);
        sum += x;
        if (x % 2) min_odd = min(min_odd, x);
    }
    if (n == 1 && sum % 2) printf("NIESTETY");
    else printf("%d", sum % 2 ? sum - min_odd : sum);
    return 0;
}
```

**关键点**：  
- 单次遍历同时计算总和和最小奇数  
- 特判直接内联，无需额外分支  

---

### 总结
本题通过奇偶性分析，结合贪心策略在 O(n) 时间内解决大规模数据问题。可视化设计通过像素动画强化了“找最小奇数”的关键步骤，游戏化元素增强学习趣味性。

---
处理用时：60.85秒
# 题目信息

# 「PMOI-1」立方骑士

## 题目背景

lhm 最近迷上了国际象棋，他对里面的骑士最感兴趣，于是就开辟了下面这个玩法。

## 题目描述

lhm 现在建立了一个大小为 $n \times m$ 的国际象棋棋盘，你作为白方要与黑方作战。棋盘上黑方只有一个国王，**国王位置不会移动**，而 lhm 有无穷无尽的骑士。现在你需要解出，最少派出几个骑士才能将死黑方国王，定义将死的标准为**黑方国王在不被吃掉的情况下不能移动为止**。

更形式化地讲：一个 $n\times m$ 的棋盘上有一个国王，你需要摆放尽可能少的骑士在棋盘上，使得对于每一个国王能走**正好一步**达到的且不在棋盘外的位置，都存在至少一个骑士能走**正好一步**达到。

棋子的移动方法：

国王每一步能向上、下、左、右、左上、右上、左下、右下八个方向移动一格。

骑士与国际象棋规则相同，每次可以走日字（即 $2\times3$ 长方形的对角线，详见样例）。**注意没有蹩马腿规则，也就是只要不走出棋盘且按照日字格行走，其他没有限制。**

lhm 太菜了，只好请聪明的你来帮他完成这个任务。

## 说明/提示

【样例1解释】

![](https://cdn.luogu.com.cn/upload/image_hosting/c5d055nl.png)

一个类似上图的棋盘，$\text{K}$ 表示黑方国王，$\text{N}$ 表示白方骑士，$\color{red}{\times}$ 表示骑士可以到达的地方（其中 $(3,3)$ 的 $\text{N}$ 封住了 $(1,2)$ 和 $(2,1)$，$(1,4)$ 的 $\text{N}$ 封住了 $(2,2)$
，形如上图，$\text{K}$ 已经被封死了，所以两个骑士足矣。可以证明两个骑士是最小个数。

【数据范围】

- 对于 $30\%$ 的数据，保证国王的初始位置一定在棋盘最外面一圈。

- 对于 $100\%$ 的数据满足，$1 \leq t \leq 10$，$1 \leq x,y \leq 10^9$，$8 \leq n,m \leq 10^9$。

## 样例 #1

### 输入

```
1
8 8 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
2
10 9 1 9
999 999 999 2```

### 输出

```
2
3```

# AI分析结果



### 唯一算法分类
组合数学

---

### 题解思路、算法要点与解决难点

#### 核心思路
1. **问题抽象**：将国王周围可达的格子视为需要被覆盖的点，每个骑士最多覆盖2个点。
2. **分类讨论**：国王的位置分三种情况：
   - **角上**：3个需覆盖点 → 最少2个骑士（⌈3/2⌉=2）。
   - **边上非角**：5个需覆盖点 → 最少3个骑士（⌈5/2⌉=3）。
   - **中间**：8个需覆盖点 → 最少4个骑士（⌈8/2⌉=4）。
3. **数学公式**：最少骑士数等价于覆盖点数向上取整的一半，即 `ceil(k/2)`（k为有效覆盖点数）。

#### 解决难点
- **高效判断位置类型**：通过坐标直接判断国王是否在角落、边或中间，无需遍历所有可能位置。
- **覆盖逻辑证明**：每个骑士可覆盖2个相邻国王移动点，通过贪心策略或构造法证明最少骑士数的正确性。

---

### 题解评分 (≥4星)

1. **樱雪喵的题解** ★★★★★  
   - **亮点**：分类明确，代码简洁，直接判断坐标类型，时间复杂度O(1)。  
   - **代码可读性**：清晰的if-else结构，适合快速理解。

2. **HYdroKomide的题解** ★★★★★  
   - **亮点**：逆向思维，通过“4-相邻边数”快速计算答案，代码极简。  
   - **公式创新**：将问题转化为几何位置关系，提升思维灵活性。

3. **添哥的题解** ★★★★☆  
   - **亮点**：提出“4-相邻边数”公式，但解释较少，代码直观。  
   - **优化空间**：需补充公式推导的解释。

---

### 最优思路或技巧提炼

#### 核心公式推导
- **位置类型判断**：  
  - 角上：国王坐标满足 `(x=1或n)且(y=1或m)` → 答案2。  
  - 边上：仅满足 `x=1或n或y=1或m` → 答案3。  
  - 中间：其他情况 → 答案4。

#### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int t; cin >> t;
    while (t--) {
        int n, m, x, y;
        cin >> n >> m >> x >> y;
        // 判断角、边、中间
        if ((x == 1 && y == 1) || (x == 1 && y == m) || 
            (x == n && y == 1) || (x == n && y == m)) cout << "2\n";
        else if (x == 1 || x == n || y == 1 || y == m) cout << "3\n";
        else cout << "4\n";
    }
    return 0;
}
```

---

### 同类型题或类似算法套路

1. **覆盖问题**：如棋盘覆盖、图顶点覆盖，需用最少资源覆盖目标点。
2. **几何位置分类**：通过坐标特征快速分类，减少计算量。
3. **贪心策略**：每个操作覆盖最多未覆盖点，实现最优解。

---

### 推荐相似题目

1. **P1219 八皇后**：棋盘覆盖问题，需保证皇后互不攻击。
2. **P1896 [SCOI2005]互不侵犯**：状态压缩DP优化覆盖问题。
3. **P2329 栅栏**：贪心覆盖最小数量的木料。

---

### 可视化与算法演示

#### 动画方案设计
1. **像素风格棋盘**：以8-bit风格绘制棋盘，国王用黄色方块，骑士用红色方块，覆盖区域用闪烁色块。
2. **步进覆盖演示**：单步展示每个骑士的放置位置及其覆盖的国王移动点，用连线标注覆盖关系。
3. **音效交互**：放置骑士时触发“放置音效”，完全覆盖时播放胜利音效。

#### 关键步骤高亮
- **国王位置标记**：黄色闪烁方块，显示其周围8格的有效移动点。
- **骑士覆盖动画**：红色方块放置后，显示其日字形移动范围覆盖的国王移动点。
- **结果反馈**：最终答案以像素字体弹出，背景音乐切换为胜利旋律。

---

### 个人心得摘录

- **调试经验**：初始误将国王移动点与骑士覆盖范围混淆，后通过画图明确覆盖逻辑。
- **思维突破**：逆向计算“4-相邻边数”大幅简化代码，避免复杂条件分支。

---

### 复古游戏化动画（伪代码示例）

```javascript
// Canvas初始化
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
// 8-bit调色板
const palette = { king: '#FFD700', knight: '#FF0000', covered: '#00FF00' };

function drawPixel(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * 16, y * 16, 16, 16); // 16x16像素方块
}

// 示例：绘制国王在(1,1)
drawPixel(0, 0, palette.king);
// 覆盖动画：放置骑士在(3,3)
setTimeout(() => {
    drawPixel(2, 2, palette.knight);
    // 覆盖范围高亮
    [[1, 3], [3, 1]].forEach(([x, y]) => drawPixel(x, y, palette.covered));
}, 1000);
```

---

**答案总结**：通过组合数学分类，将问题简化为位置判断，高效解决大规模棋盘的最优覆盖问题。

---
处理用时：124.97秒
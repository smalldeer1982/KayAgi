# 题目信息

# [CSP-J 2021] 分糖果

## 题目背景

红太阳幼儿园的小朋友们开始分糖果啦！

## 题目描述

红太阳幼儿园有 $n$ 个小朋友，你是其中之一。保证 $n \ge 2$。

有一天你在幼儿园的后花园里发现无穷多颗糖果，你打算拿一些糖果回去分给幼儿园的小朋友们。

由于你只是个平平无奇的幼儿园小朋友，所以你的体力有限，至多只能拿 $R$ 块糖回去。

但是拿的太少不够分的，所以你至少要拿 $L$ 块糖回去。保证 $n \le L \le R$。

也就是说，如果你拿了 $k$ 块糖，那么你需要保证 $L \le k \le R$。

如果你拿了 $k$ 块糖，你将把这 $k$ 块糖放到篮子里，并要求大家按照如下方案分糖果：只要篮子里有**不少于** $n$ 块糖果，幼儿园的所有 $n$ 个小朋友（包括你自己）都从篮子中拿走**恰好**一块糖，直到篮子里的糖数量**少于** $n$ 块。此时篮子里剩余的糖果均归你所有——这些糖果是**作为你搬糖果的奖励**。

作为幼儿园高质量小朋友，你希望让**作为你搬糖果的奖励**的糖果数量（**而不是你最后获得的总糖果数量**！）尽可能多；因此你需要写一个程序，依次输入 $n, L, R$，并输出你最多能获得多少**作为你搬糖果的奖励**的糖果数量。

## 说明/提示

**【样例解释 #1】**

拿 $k = 20$ 块糖放入篮子里。

篮子里现在糖果数 $20 \ge n = 7$，因此所有小朋友获得一块糖；

篮子里现在糖果数变成 $13 \ge n = 7$，因此所有小朋友获得一块糖；

篮子里现在糖果数变成 $6 < n = 7$，因此这 $6$ 块糖是**作为你搬糖果的奖励**。

容易发现，你获得的**作为你搬糖果的奖励**的糖果数量不可能超过 $6$ 块（不然，篮子里的糖果数量最后仍然不少于 $n$，需要继续每个小朋友拿一块），因此答案是 $6$。

**【样例解释 #2】**

容易发现，当你拿的糖数量 $k$ 满足 $14 = L \le k \le R = 18$ 时，所有小朋友获得一块糖后，剩下的 $k - 10$ 块糖总是**作为你搬糖果的奖励**的糖果数量，因此拿 $k = 18$ 块是最优解，答案是 $8$。

**【数据范围】**

| 测试点 | $n \le$ | $R \le$ | $R - L \le$ |
|:-:|:-:|:-:|:-:|
| $1$ | $2$ | $5$ | $5$ |
| $2$ | $5$ | $10$ | $10$ |
| $3$ | ${10}^3$ | ${10}^3$ | ${10}^3$ |
| $4$ | ${10}^5$ | ${10}^5$ | ${10}^5$ |
| $5$ | ${10}^3$ | ${10}^9$ | $0$ |
| $6$ | ${10}^3$ | ${10}^9$ | ${10}^3$ |
| $7$ | ${10}^5$ | ${10}^9$ | ${10}^5$ |
| $8$ | ${10}^9$ | ${10}^9$ | ${10}^9$ |
| $9$ | ${10}^9$ | ${10}^9$ | ${10}^9$ |
| $10$ | ${10}^9$ | ${10}^9$ | ${10}^9$ |

对于所有数据，保证 $2 \le n \le L \le R \le {10}^9$。

【感谢 hack 数据提供】  
[wangbinfeng](/user/387009)

## 样例 #1

### 输入

```
7 16 23
```

### 输出

```
6
```

## 样例 #2

### 输入

```
10 14 18
```

### 输出

```
8
```

## 样例 #3

### 输入

```
见附件中的 candy/candy3.in。```

### 输出

```
见附件中的 candy/candy3.ans。```

# AI分析结果



# 分糖果题解分析

## 唯一算法分类
**数论**

---

## 题解思路与解决难点

### 核心思路
题目要求找到区间 $[L, R]$ 中的数 $k$，使得 $k \bmod n$ 最大。数学性质表明，模运算最大值为 $n-1$，需判断两种情况：
1. **区间跨越 $n$ 的倍数**：若存在 $k$ 使得 $k \in [L, R]$ 且 $k = m \cdot n -1$，则最大余数为 $n-1$。
2. **区间在同一个 $n$ 倍数块内**：此时余数单调递增，直接取 $R \bmod n$。

### 关键公式推导
- **判断倍数块跨越**：$\lfloor L/n \rfloor \neq \lfloor R/n \rfloor$  
  若成立，说明区间包含至少一个 $n$ 的倍数，存在 $k = (\lfloor R/n \rfloor -1) \cdot n + (n-1)$。
- **余数计算**：$R \bmod n = R - n \cdot \lfloor R/n \rfloor$

### 解决难点
- **区间长度与 $n$ 的关系**：当 $R-L \ge n$ 时，必然跨越倍数块（但实际只需判断商是否不同）。
- **边界条件处理**：如样例中 $R$ 恰好是倍数的情况需正确处理。

---

## 题解评分（≥4星）

| 题解作者 | 评分 | 核心亮点 |
|---------|------|----------|
| 滑_稽   | ⭐⭐⭐⭐⭐ | 代码极简，直接比较商是否相同，逻辑清晰 |
| Lethifold | ⭐⭐⭐⭐ | 通过区间长度判断，图形化解释余数分布 |
| qwq___qaq | ⭐⭐⭐⭐ | 数学推导清晰，分块思想直观 |

---

## 最优思路提炼
**关键技巧**：比较 $\lfloor L/n \rfloor$ 与 $\lfloor R/n \rfloor$：
1. 若不同，答案必为 $n-1$（存在一个完整的余数周期）。
2. 若相同，答案即 $R \bmod n$（余数单调递增）。

**代码实现**：
```cpp
#include <iostream>
using namespace std;

int main() {
    int n, L, R;
    cin >> n >> L >> R;
    if (L / n != R / n) cout << n - 1;
    else cout << R % n;
    return 0;
}
```

---

## 同类题型与算法套路
1. **模运算周期性**：如求区间内模最大值，均需分析余数分布周期。
2. **分块思想**：将数值按除数分块，判断区间跨块情况。
3. **快速边界判断**：无需遍历，通过数学推导直接得出结论。

**推荐题目**：
1. [P1082 [NOIP2012 提高组] 同余方程](https://www.luogu.com.cn/problem/P1082)
2. [P1226 【模板】快速幂](https://www.luogu.com.cn/problem/P1226)
3. [P2260 [清华集训2012] 模积和](https://www.luogu.com.cn/problem/P2260)

---

## 可视化与算法演示
### 动画设计
1. **数轴展示**：
   - 绘制数轴，标记 $n$ 的倍数点（如 $0, n, 2n$）。
   - 用不同颜色标注区间 $[L, R]$：
     - **红色**：跨越倍数块时，高亮 $n-1$ 的位置。
     - **蓝色**：未跨越时，动态显示 $R \bmod n$ 的计算过程。
2. **余数变化曲线**：
   - 动态绘制 $k \bmod n$ 随 $k$ 增加的曲线，展示周期性归零特性。
   - 当区间跨越倍数时，曲线顶点自动跳至 $n-1$。

### 复古像素风格
- **Canvas 绘制**：以 8-bit 风格显示数轴，余数顶点用闪烁像素块标记。
- **音效设计**：
  - **成功音效**：当检测到跨越倍数块时，播放经典 FC 过关音效。
  - **计算音效**：每步余数更新时，伴随 8-bit 电子音。

### 交互控制
- **步进执行**：按空格键逐步展示判断逻辑：
  1. 计算 $\lfloor L/n \rfloor$ 和 $\lfloor R/n \rfloor$。
  2. 比较结果，高亮对应的输出分支。
- **参数调节**：滑动条动态调整 $n, L, R$，实时更新可视化结果。

---

## 个人心得摘录
> **Lethifold**：  
> “考场上一开始以为是二分搜索，推了一会儿才发现只用分支结构就可以A了。”  
> **启示**：先数学分析再编码，避免过度设计。

> **滑_稽**：  
> “考场上 10min 推出结果，代码量最少。”  
> **启示**：数论题需优先寻找规律而非暴力模拟。

---

## 可视化代码片段（Canvas 绘制）
```javascript
// 绘制数轴与区间
ctx.fillStyle = "#8B0000"; // 复古红
ctx.fillRect(n * blockSize, 0, 2, canvas.height); // 标记n倍数线

// 动态余数计算动画
function animateMod() {
    let current = L;
    const interval = setInterval(() => {
        if (current > R) clearInterval(interval);
        ctx.fillStyle = "#00FF00"; // 像素绿
        ctx.fillRect(current * scale, 50, 2, 2);
        current++;
    }, 100);
}
```

---
处理用时：82.11秒
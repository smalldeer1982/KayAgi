# 题目信息

# [Kubic] Addition

## 题目背景

建议先看 B 题题目背景。

## 题目描述

有一个初始长度为 $n$ 的序列 $a$。你需要进行 $n-1$ 次操作。每一次操作先在当前序列中选出两个相邻的数 $x,y$ 并删除（原序列中 $x$ 在 $y$ 左边），再往原位置插入一个 $x+y$ 或一个 $x-y$。$n-1$ 次操作之后最终只会剩下恰好一个数，求这个剩下的数的最大值。

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 10^5,|a_i|\le 10^9$。

||分值|$n$|$\vert a_i\vert$|特殊性质|
|:-:|:-:|:-:|:-:|:-:|
|$\operatorname{Subtask}1$|$10$|$\le 2$|无特殊限制|无|
|$\operatorname{Subtask}2$|$20$|$\le 100$|无特殊限制|无|
|$\operatorname{Subtask}3$|$5$|无特殊限制|无特殊限制|$a_i\ge 0$|
|$\operatorname{Subtask}4$|$30$|无特殊限制|$\le 1$|无|
|$\operatorname{Subtask}5$|$35$|无特殊限制|无特殊限制|无|

### 样例解释

一种操作过程如下：

`-1 1 1 -1 1`

`-1 1 1 -2`

`-1 1 3`

`-1 4`

`3`

可以证明没有更优的方案。

## 样例 #1

### 输入

```
5
-1 1 1 -1 1```

### 输出

```
3```

# AI分析结果



## 算法分类
**贪心算法**

---

## 题解思路与难点分析
### 核心思路
所有题解均采用贪心策略：**第一个数保持不变，其余每个数取其绝对值累加**。  
**数学推导**：每次合并相邻两数时，总能通过选择 `x + |y|` 的方式最大化当前结果。最终总结果为 `a₁ + |a₂| + |a₃| + ... + |aₙ|`。

### 解决难点
1. **贪心正确性证明**：  
   - **归纳法**：假设对前 `k` 个数操作后结果正确，新增第 `k+1` 个数时，选择 `±` 操作使其贡献绝对值。  
   - **操作顺序无关性**：无论合并顺序如何，最终结果等价于依次累加绝对值（需保证每一步选择绝对值最大操作）。

2. **边界处理**：  
   - 第一个数无法被前驱数修正，需保留原值。  
   - 数据范围较大，需使用 `long long` 存储结果。

---

## 题解评分（≥4星）
1. **银杉水杉秃杉（5星）**  
   - 思路清晰，代码简洁，直接读入并累加绝对值。  
   - 附带样例分析，验证正确性。  

2. **mzyc_jx（4星）**  
   - 明确分类讨论 `y≥0` 和 `y≤0` 的情况，强化贪心逻辑。  
   - 提醒 `sum` 开 `long long`。  

3. **int08（4星）**  
   - 将问题转化为表达式展开，结合数学归纳法证明，逻辑严密。  
   - 代码轻量，直接读入处理。

---

## 最优思路提炼
**关键技巧**：  
- **绝对值累加**：从第二个数开始，所有数取绝对值累加。  
- **贪心证明**：通过每一步选择最大绝对值操作，保证全局最优。  
- **时间复杂度**：O(n)，仅需一次遍历。

**代码实现核心**：
```cpp
long long ans = a[0];
for (int i = 1; i < n; ++i) ans += abs(a[i]);
```

---

## 类似算法题
1. **最大子数组和（LeetCode 53）**  
   - 核心：贪心或动态规划，维护当前最大和。  
2. **跳跃游戏（LeetCode 55）**  
   - 核心：贪心维护最远可达位置。  
3. **乘积最大子数组（LeetCode 152）**  
   - 核心：动态规划同时维护最大和最小值。

---

## 可视化与算法演示
### 动画设计
- **像素风格**：  
  - 用 8-bit 色块表示数列，当前操作数高亮为黄色。  
  - 合并时，右侧数显示为绿色（正数）或红色（负数），绝对值符号以闪烁效果呈现。  
- **流程步骤**：  
  1. 初始数列显示，第一个数固定为蓝色。  
  2. 遍历后续数，每个数自动变为正（绿色方块），累加至结果区。  
  3. 音效：合并时播放短促“叮”声，结果更新时播放胜利音效。  
- **交互控制**：  
  - 支持暂停/继续、调整动画速度。  
  - 显示当前累加值和剩余操作次数。

---

## 代码实现（核心逻辑）
```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    long long ans;
    cin >> n >> ans;
    for (int i = 1; i < n; ++i) {
        long long x;
        cin >> x;
        ans += abs(x);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 个人心得摘录
- **银杉水杉秃杉**：通过样例反向推导策略，验证贪心正确性。  
- **int08**：将括号展开为无括号表达式，顿悟绝对值累加本质。  
- **HappyCode**：月赛中因未处理第一个数符号导致多次 WA，强调边界检查。

---

## 复古游戏化设计
- **Canvas 绘制**：  
  - 数列以方格表示，合并操作时右侧方格飞向左侧，显示 `+` 或 `-` 动画。  
- **音效**：  
  - 背景：8-bit 风格循环音乐。  
  - 操作音：每次合并播放 `beep`，错误操作时播放低沉音效。  
- **积分系统**：  
  - 每正确合并一个数得 10 分，连击（快速操作）额外加分。  
  - 最终结果与理论最大值一致时解锁成就。

---
处理用时：248.17秒
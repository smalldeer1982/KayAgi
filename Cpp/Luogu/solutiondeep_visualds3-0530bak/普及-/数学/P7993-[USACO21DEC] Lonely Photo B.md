# 题目信息

# [USACO21DEC] Lonely Photo B

## 题目描述

Farmer John 最近购入了 $N$ 头新的奶牛（$3 \le N \le 5 \times 10^5$），每头奶牛的品种是更赛牛（Guernsey）或荷斯坦牛（Holstein）之一。 

奶牛目前排成一排，Farmer John 想要为每个连续不少于三头奶牛的序列拍摄一张照片。 然而，他不想拍摄这样的照片，其中只有一头牛的品种是更赛牛，或者只有一头牛的品种是荷斯坦牛——他认为这头奇特的牛会感到孤立和不自然。 在为每个连续不少于三头奶牛的序列拍摄了一张照片后，他把所有「孤独的」照片，即其中只有一头更赛牛或荷斯坦奶牛的照片，都扔掉了。

给定奶牛的排列方式，请帮助 Farmer John 求出他会扔掉多少张孤独的照片。如果两张照片以不同的奶牛开始或结束，则认为它们是不同的。


## 说明/提示

【样例解释】

这个例子中的每一个长为 3 的子串均恰好包含一头更赛牛或荷斯坦牛——所以这些子串表示孤独的照片，并会被 Farmer John 扔掉。所有更长的子串（GHGH、HGHG 和 GHGHG）都可以被接受。

【数据范围】

- 测试点 2-4 满足 $N \le 50$。
- 测试点 5-10 满足 $N \le 5000$。
- 测试点 11 没有额外限制。

注意这个测试点的答案可能无法用标准的 32 位整数型存储，你可能需要使用更大的整数类型（例如，C++ 中 64 位的 "long long int" 类型）。

## 样例 #1

### 输入

```
5
GHGHG```

### 输出

```
3```

# AI分析结果



## 算法分类
组合数学

---

## 题解思路与核心难点

### 关键算法分析
所有题解均围绕组合数学原理展开，核心思路是：**每个孤独照片必定存在唯一的一个特征牛（G或H），且其左右环境满足特定组合条件**。通过预处理连续区间的分布特征，利用乘法原理和加法原理快速计算贡献。

### 数学推导与实现
以分块法为例（ynxynx解法）：
1. **分块预处理**：将连续相同类型的牛合并为块，记录每个块的长度
2. **分类计算贡献**：
   - 若当前块仅1头牛（如单个G）：贡献 = 左块长度 * 右块长度 + 右块长度 - 1
     - 乘法项计算跨左右块的组合（如 H...H G H...H 的交叉组合）
     - 减法项处理仅包含右块与当前牛的端点情况
   - 若当前块长度≥2：贡献 = 当前块长度 + 相邻块长度 - 2
     - 减法2是为了排除长度不足3的组合

### 解决难点
- **高效统计组合数**：通过分块将O(n²)问题降维为O(n)
- **避免重复计算**：每个照片被唯一特征牛计算一次
- **边界处理**：首尾块的左右不存在时特殊处理

---

## 最优思路提炼
1. **特征牛定位**：每个孤独照片必含唯一特征牛，统计所有牛作为特征牛的贡献
2. **连续区间预处理**：记录每个牛左右连续不同品种的数量（徐晨轩解法）或分块统计（ynxynx解法）
3. **组合公式应用**：
   - 中间特征牛：贡献 = 左连续数 × 右连续数
   - 端点特征牛：贡献 = max(左连续数-1, 0) + max(右连续数-1, 0)

---

## 同类型题目套路
1. **连续区间统计**：滑动窗口/分块预处理
2. **组合数快速计算**：利用前缀和/乘法原理避免暴力枚举
3. **特征元素定位**：将问题转化为每个元素的贡献度求和

---

## 推荐相似题目
1. P3400 - 连续子区间统计（分块+组合数学）
2. LeetCode 1525 - 满足条件的子串数（特征字符定位）
3. P2280 - 单调子串统计（滑动窗口+组合计算）

---

## 题解评分（≥4星）

### 1. ynxynx（5星）
- **亮点**：分块法思路清晰，O(n)时间预处理+线性扫描，代码简洁高效
- **代码关键**：块合并逻辑与分类计算公式直击数学本质

### 2. 徐晨轩（4星）
- **亮点**：四数组预处理左右连续数，全面覆盖三种贡献情况
- **改进点**：变量命名可读性稍差，但数学推导严谨

### 3. rzh123（4星）
- **亮点**：直接记录前后同种位置，差值计算贡献，逻辑直观
- **特色**：代码简洁，预处理与贡献计算分离明确

---

## 核心代码实现（分块法）
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[500005],n,ans,cnt;
char s[500005];

signed main(){
    scanf("%lld %s",&n,s);
    a[++cnt] = 1;
    for(int i=1; i<n; ++i) // 分块预处理
        s[i]==s[i-1] ? a[cnt]++ : a[++cnt]=1;
    
    for(int i=1; i<=cnt; ++i){
        if(a[i]==1) // 单个牛块
            ans += a[i-1]*a[i+1] + (a[i+1]-1);
        else        // 多牛块
            ans += a[i] + a[i+1] - 2;
    }
    printf("%lld",ans);
}
```

---

## 可视化设计（复古像素风格）

### 动画演示步骤
1. **分块染色**：Canvas绘制不同颜色块表示G/H群
   - G群：绿色像素块（#00FF00）
   - H群：黄色像素块（#FFFF00）
2. **贡献计算高亮**：
   - 当前处理块闪烁红色边框
   - 左/右块用半透明覆盖层标记
3. **公式动态显示**：
   - 单个块：显示 `左×右 + (右-1)` 
   - 多牛块：显示 `左+右-2`
4. **音效触发**：
   - 分块完成：8-bit "滴"声
   - 贡献计算：硬币收集音效
   - 总答案更新：胜利小调

### 交互功能
- **步进控制**：空格键单步执行分块与计算
- **自动演示**：AI模式模拟解题流程
- **数据面板**：实时显示当前块索引、贡献值、总答案

---

## 个人心得
调试中发现**块边界处理**极易出错，例如：
- 首块无左块时跳过乘法项
- 块索引从1开始更易处理边界
关键突破：将连续区间的**拓扑关系**转化为纯数学运算，避免复杂条件判断。

---
处理用时：196.44秒
# 题目信息

# 「TERRA-OI R1」你不是神，但你的灵魂依然是我的盛宴

## 题目背景

踏在这木质的平台上，嘎吱嘎吱作响，你从包里掏出了各式各样的药水，逐一饮下后一股暖意从心底升腾起来，你拿出了精心准备的诱饵，那是用三位仆从的精华凝聚而成，你将其高举头顶，想要引出那位噬神者。天空开始弥漫着蓝紫色的迷雾，这种氛围压得你喘不过气，恍惚间，你面前的空间开始撕裂出一条裂缝，一条身披紫色外壳的巨蟒从中钻出，你拿起了手上的巨剑，听着一声又一声的嘶吼，你知道这将是一场恶战......

## 题目描述

请求出：

$\sum_{i=1}^{n} \sum_{j=1}^{m}(i\times j \bmod p)$ 

的值，其中 $n,m,p$ 为给定的值。

## 说明/提示

#### 【样例解释 #1】

很显然 $i\times j$ 只有 $[1,2,3,2,4,6,3,6,9]$ 这几种情况，这些情况的和为 $36$。

------------

#### 【数据范围】

**本题采用捆绑测试。**

| Subtask | Score | $n,m\le$ |
| :----------: | :----------: | :----------: |
| $1$ | $20$ | $10^3$ |
| $2$ | $30$ | $10^6$ |
| $3$ | $50$ | $10^{12}$ |

对于 $100\%$ 的数据，满足 $1\le n,m\le10^{12}$，$1\le p\le10^3$。


## 样例 #1

### 输入

```
3 3 10```

### 输出

```
36```

## 样例 #2

### 输入

```
114514 1919810 233```

### 输出

```
696303234```

# AI分析结果



**算法分类**：数论

---

### **题解思路与解决难点**

**核心思路**：  
利用模运算的周期性，将原始大矩阵分解为多个重复的 $p \times p$ 周期块，统计每个余数组合 $(i \bmod p, j \bmod p)$ 的出现次数，最终加权求和。

**关键步骤**：
1. **预处理余数组合的乘积模值**：计算所有 $(i \bmod p) \times (j \bmod p) \bmod p$。
2. **统计余数出现次数**：对每个余数 $i$，计算其在 $n$ 中的出现次数 $cnt1[i]$，同理 $cnt2[j]$ 对应 $m$。
3. **加权求和**：遍历所有余数组合 $(i,j)$，累加 $cnt1[i] \times cnt2[j] \times (i \times j \bmod p)$。

**解决难点**：
- **周期性分析**：发现 $i \times j \bmod p$ 的周期性，将 $O(nm)$ 问题转为 $O(p^2)$。
- **边界处理**：计算余数出现次数时，需判断余数是否超出 $n \bmod p$ 或 $m \bmod p$。

---

### **题解评分（≥4星）**

1. **MCRS_lizi（5星）**  
   - **亮点**：代码简洁，直接统计余数出现次数，无冗余计算。  
   - **关键代码**：  
     ```cpp
     for(int i=0;i<p;i++) cnt1[i] = n/p + (n%p >= i);
     for(int j=0;j<p;j++) cnt2[j] = m/p + (m%p >= j);
     ```

2. **luogu_gza（4星）**  
   - **亮点**：公式推导清晰，直接计算余数出现次数为 $\lfloor \frac{n+k}{p} \rfloor$。  
   - **代码片段**：  
     ```cpp
     fo(i,0,p-1) a[i]=(n+i)/p; // 计算余数i的出现次数
     ```

3. **wuyonghuming（4星）**  
   - **亮点**：矩阵分块思路直观，二维前缀和预处理完整周期和余数部分。  
   - **代码片段**：  
     ```cpp
     ans = s[p][p] * (n/p) * (m/p) + s[n%p][m%p] + ...;
     ```

---

### **最优思路与代码实现**

**核心代码**（MCRS_lizi 解法）：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int cnt1[1005], cnt2[1005], ans;

signed main() {
    int n, m, p;
    cin >> n >> m >> p;
    for(int i=0; i<p; i++) {
        cnt1[i] = n / p + (i <= n % p); // 余数i在n中的出现次数
        cnt2[j] = m / p + (j <= m % p); // 余数j在m中的出现次数
    }
    for(int i=0; i<p; i++) 
        for(int j=0; j<p; j++) 
            ans = (ans + cnt1[i] * cnt2[j] % mod * (i*j % p)) % mod;
    cout << ans;
    return 0;
}
```

---

### **同类题目推荐**
1. **P2260 [清华集训2012]模积和**  
   - 结合模运算和分块技巧的求和问题。
2. **P2261 [CQOI2007]余数求和**  
   - 利用整除分块优化模运算求和。
3. **P1891 疯狂 LCM**  
   - 基于数论性质的高效求和。

---

### **可视化与算法演示**

**动画设计**：
1. **网格绘制**：将 $p \times p$ 的矩阵绘制为像素块，每个格子颜色表示 $i \times j \bmod p$ 的值。
2. **周期高亮**：用不同颜色标记完整的周期块和余数部分（如绿色块为完整周期，红色块为余数）。
3. **统计过程**：动态显示余数出现次数的计算，如 `cnt1[i]` 和 `cnt2[j]` 的累加过程。
4. **音效提示**：完成一个周期块计算时播放音效，余数部分用不同音调。

**复古像素风格**：
- **调色板**：使用 8-bit 风格的 16 色，如绿色（#00FF00）表示周期块，红色（#FF0000）表示余数。
- **Canvas 绘制**：通过 `requestAnimationFrame` 逐步渲染计算过程，模拟经典游戏进度条效果。

---

**关键公式推导**：
$$
\sum_{i=1}^n \sum_{j=1}^m (i \times j \bmod p) = \sum_{a=0}^{p-1} \sum_{b=0}^{p-1} (a \times b \bmod p) \times \text{cnt1}(a) \times \text{cnt2}(b)
$$
其中 $\text{cnt1}(a) = \lfloor \frac{n}{p} \rfloor + [a \leq n \bmod p]$，$\text{cnt2}(b)$ 同理。

---
处理用时：78.12秒
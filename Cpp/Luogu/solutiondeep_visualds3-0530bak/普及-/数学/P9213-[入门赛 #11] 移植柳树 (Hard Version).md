# 题目信息

# [入门赛 #11] 移植柳树 (Hard Version)

## 题目背景

**本题与 Easy Version 题意完全相同，不同的地方仅在于数据范围和单个测试点内含有的测试组数量。**

HG 在上学的路上无聊的走着，看着这马路边的一排柳树，他的脑子里突然冒出了个奇怪的问题……

## 题目描述

假设总共有 $n$ 棵柳树，每一棵间隔都为 $x$。

现在他需要对这些树做一些操作，使得在「这 $n$ 棵树的起点不变」的同时，任意两棵树的间隔都为 $y$（$y > x$）。

他被允许做的操作如下；


- 移植树木：将一个位置的树木移到另一个位置上。

如果对「起点不变」这个概念有疑惑，可以参照「样例解释」中的图例。

显然操作是需要体力的，HG 想要让尽可能多的树维持原状。现在 HG 想知道，为了达成「任意两棵树的间隔都为 $y$」这个目标，他最多可以让多少棵树保持在原来的位置。

请你帮帮他吧！

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/6uguqush.png)

图中的方块代表树。第一行为调整前，第二行为调整后的情况。标出的三个绿色的方块是不需要移动的树，除此之外其他树都需要移动。

### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq T \leq 10 ^ 5$，$1 \leq n \leq 10 ^ {18}$，$1 \leq x < y \leq 10 ^ 9$。  

## 样例 #1

### 输入

```
1
8 2 3```

### 输出

```
3```

# AI分析结果



## 算法分类
数学（最大公约数、数论）

---

## 综合分析与结论
题目要求找出在调整树间隔后，最多能保留的树数量。关键在于找到原间隔和新间隔的公倍数位置。

**核心思路**：  
保留的树必须同时满足原间隔x和新间隔y的倍数关系。通过数学推导，将问题转化为求两数的最大公约数（gcd），避免计算大数的公倍数（lcm）导致的溢出问题。公式简化为：  
`ans = (n-1) / (y / gcd(x, y)) + 1`

**难点对比**：  
- **直接计算lcm**：可能导致溢出，需用`__int128`处理，但输入输出复杂。  
- **数学优化**：利用gcd将公式转换，避免大数运算，代码更简洁高效。  

**可视化设计**：  
- **动画演示**：以网格展示树的位置，高亮满足公倍数的节点，动态显示公式推导过程。  
- **复古风格**：8位像素动画，树用绿色方块表示，移动时播放音效，背景音乐循环。  
- **步进控制**：允许单步观察gcd计算和公式应用步骤。

---

## 题解清单 (≥4星)
1. **liuliucy（5星）**  
   - 代码简洁，直接使用gcd优化公式，避免溢出。  
   - 关键代码：`(n-1)/(y/gcd(x,y)) + 1`  
   - 亮点：无需大数处理，高效且易读。

2. **cff_0102（4星）**  
   - 使用long double避免溢出，数学推导清晰。  
   - 注意点：转换long long时需谨慎精度。  
   - 关键代码：`ans*=(n-1) * __gcd(x,y); ans/=y;`

3. **_Emperorpenguin_（4星）**  
   - 分解公式避免溢出，代码结构清晰。  
   - 关键优化：`f = y/__gcd(x,y)`，直接除法处理。

---

## 最优思路提炼
**核心公式**：`ans = (n-1) // (y // gcd(x, y)) + 1`  
1. **数学优化**：利用gcd代替lcm，避免大数相乘溢出。  
2. **公式转换**：将原问题转化为整数除法，确保计算在long long范围内。  
3. **边界处理**：起点固定，结果需+1。

---

## 同类型题与算法套路
- **数论问题**：涉及gcd/lcm的公倍数应用。  
- **优化技巧**：避免直接计算大数，通过数学分解简化。  
- **类似题目**：  
  - 洛谷 P1072 [NOIP2009 提高组] Hankson 的趣味题  
  - 洛谷 P1516 青蛙的约会（扩展欧几里得）  
  - 洛谷 P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题  

---

## 推荐题目
1. **P1072** - 公倍数的复杂应用  
2. **P1516** - 扩展欧几里得算法  
3. **P1029** - gcd与lcm的关系  

---

## 个人心得摘录
- **ssSSSss_sunhaojia**：最初因溢出WA，通过公式分解优化。  
- **zzx114514**：使用`__int128`需注意输入输出，适合大数但实现复杂。  
- **cff_0102**：long double的精度需谨慎，避免转换错误。  

---

## 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        long long n, x, y;
        cin >> n >> x >> y;
        long long g = __gcd(x, y);
        long long k = y / g;
        cout << (n - 1) / k + 1 << '\n';
    }
    return 0;
}
```

**核心逻辑**：计算gcd后直接应用优化公式，避免大数运算。

---

## 可视化设计
- **8位像素动画**：  
  - 树用绿色/红色像素块表示，保留树高亮。  
  - 动态显示gcd计算步骤和公式推导。  
- **音效**：  
  - 计算正确时播放成功音效，错误时短促提示。  
- **交互控制**：  
  - 滑动条调节动画速度，按钮单步执行。  
- **公式演示**：  
  - 分步展示`gcd(x,y)`、`y/gcd`、除法过程，颜色区分变量。

---
处理用时：121.53秒
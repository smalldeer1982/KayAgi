# 题目信息

# 异或积

## 题目背景

$\texttt{id: 4d7e}$

小 H 在课堂上学习了异或运算。

对于两个非负整数 $x,y$，它们的**异或**是指，将它们作为二进制数，对二进制表示中的每一位进行如下运算得到的结果：

- $x$ 和 $y$ 的这一位上不同时，结果的这一位为 $1$；
- $x$ 和 $y$ 的这一位上相同时，结果的这一位为 $0$。

$x$ 和 $y$ 的异或被记为 $x \operatorname{xor} y$ 或 $x \oplus y$。

在 C++ 中，你可以用 `x ^ y` 得到 $x$ 与 $y$ 的异或值。

另外，若干个数的异或称之为**异或和**。

## 题目描述

小 H 还了解到，一个长度为 $n$ 的数列 $a$ 的**异或积**是一个等长的数列 $b$，其中 $b_i$ 等于数列 $a$ 中除了 $a_i$ 以外其他元素的异或和，即
	
$$b_i = \bigoplus \limits_{j = 1}^{n} [j\ne i] a_j$$
	
例如，数列 $\{1, 2, 3, 4\}$ 的异或积为 $\{5, 6, 7, 0\}$。
	
**异或积变换**是指将一个数列用它的异或积替换的过程，由于异或积变换之后数列长度不变，所以异或积变换可以连续进行多次。
	
现在，小 H 有一个长度为 $n$ 的数列 $a$，他想请你帮他计算出 $a$ 经过 $k$ 次异或积变换之后得到的序列。

## 说明/提示

### 样例 1 解释

此样例即为题目描述中的例子。

### 样例 2 解释

第 $1$ 次异或积变换：$\{0,0,0,1\}\to\{1,1,1,0\}$；

第 $2$ 次异或积变换：$\{1,1,1,0\}\to\{0,0,0,1\}$。

### 数据规模与约定

对于 $100\%$ 的测试数据，$1 \le T \le 10$，$2 \le n \le 10^5$，$1 \le k \le 10^{18}$，$0 \le a_i < 2^{32}$。

| 测试点编号 | $n\leq$  | $k \leq$  |特殊性质|
| :----------: | :----------: | :----------: | :-----------: |
| $1 \sim 3$ | $100$ | $100$ | |
| $4 \sim 5$ | $1000$ | $1000$ | |
| $6 \sim 7$ | $3$ | $10^{18}$ | |
| $8 \sim 10$ | $10^5$ | $3$ | |
| $11 \sim 13$ | $10^5$ | $10^{18}$ | $a$ 中所有数的异或和为 $0$ |
| $14 \sim 15$ | $10^5$ | $10^{18}$ | $n$ 为奇数 |
| $16 \sim 17$ | $10^5$ | $10^{18}$ | $n$ 为偶数 |
| $18 \sim 20$ | $10^5$ | $10^{18}$ | |

### 提示

在 C++ 中，对于数据范围 $0\le x<2^{32}$，你可以：

- 使用 `unsigned int x` 来定义；
- 使用 `cin >> x` 或 `scanf("%u", &x)` 来输入；
- 使用 `cout << x` 或 `printf("%u", x)` 来输出。 

## 样例 #1

### 输入

```
1
4 1
1 2 3 4```

### 输出

```
5 6 7 0```

## 样例 #2

### 输入

```
1
4 2
0 0 0 1```

### 输出

```
0 0 0 1```

## 样例 #3

### 输入

```
见附件中的 samples/xor3.in```

### 输出

```
见附件中的 samples/xor3.ans```

# AI分析结果



## 唯一算法分类
数论

## 题解思路与核心难点

### 核心公式推导
设原数组异或和为 $S = \bigoplus_{i=1}^n a_i$，则第一次变换后每个元素为 $b_i = S \oplus a_i$。新的异或和 $S'$ 的计算为：
$$
S' = \bigoplus_{i=1}^n b_i = \bigoplus_{i=1}^n (S \oplus a_i) = S^n \oplus S
$$
- **当 $n$ 为奇数时**：$S^n = S$，故 $S' = S \oplus S = 0$，后续变换不再改变数组。
- **当 $n$ 为偶数时**：$S^n = 0$，故 $S' = 0 \oplus S = S$，数组每两次变换恢复原状。

### 解决难点
1. **快速推导变换规律**：通过分析异或和的奇偶性，发现变换结果的周期性。
2. **时间复杂度优化**：直接模拟 $k$ 次变换不可行，需利用周期性将 $k$ 化简为模 2 运算。

## 题解评分（≥4星）
1. **hhoppitree (5星)**  
   - 推导严谨，详细分析异或和的奇偶性变化。
   - 代码简洁高效，直接分类处理奇偶情况。
   - 时间复杂度 $O(n)$，完美应对 $k \leq 10^{18}$。

2. **Link_Cut_Y (4.5星)**  
   - 通过手模示例直观展示规律。
   - 代码逻辑清晰，但推导部分稍显简略。

3. **卷王 (4星)**  
   - 代码极简，但需读者自行理解背后推导。
   - 正确性高，时间复杂度最优。

## 最优思路提炼
- **关键公式**：$b_i = S \oplus a_i$，其中 $S$ 为原数组异或和。
- **奇偶性分析**：
  - 奇数次长度：变换一次后稳定。
  - 偶数次长度：奇数次变换输出结果，偶数次恢复原状。
- **代码实现**：直接计算 $S$ 后按奇偶性分类输出。

## 同类型题套路
- **异或性质题**：利用 $x \oplus x = 0$ 和交换律简化计算。
- **周期性分析**：通过奇偶性或模运算减少重复计算。

## 推荐题目
1. [P1469 找筷子](https://www.luogu.com.cn/problem/P1469)（异或性质应用）
2. [P5514 永夜的报应](https://www.luogu.com.cn/problem/P5514)（异或和最小化）
3. [P6102 谔运算](https://www.luogu.com.cn/problem/P6102)（位运算与模运算结合）

## 可视化设计
### 动画方案
1. **初始状态**：显示原数组和异或和 $S$，用黄色高亮 $S$。
2. **第一次变换**：每个元素变为 $S \oplus a_i$，绿色高亮变换过程。
3. **奇偶判断**：
   - 若 $n$ 奇数：红色边框标注“稳定状态”，停止变换。
   - 若 $n$ 偶数：根据 $k$ 奇偶回跳至原数组（蓝色）或保持变换后（绿色）。

### 复古像素风格
- **颜色方案**：8-bit 调色板（黄、绿、红、蓝）。
- **音效**：变换时播放 8-bit 音效，奇偶判断后播放胜利音效。
- **Canvas 绘制**：数组元素以像素方块显示，变换时方块颜色闪烁。

## 核心代码
```cpp
unsigned int a[MAXN], sum;
for (int i = 1; i <= n; ++i) sum ^= a[i];
if (n % 2 || k % 2) 
    for (int i = 1; i <= n; ++i) a[i] ^= sum;
// 输出 a
```

## 总结
通过异或的性质与奇偶性分析，将指数级 $k$ 化简为 $O(1)$ 判断，是数论与位运算结合的经典题型。

---
处理用时：96.61秒
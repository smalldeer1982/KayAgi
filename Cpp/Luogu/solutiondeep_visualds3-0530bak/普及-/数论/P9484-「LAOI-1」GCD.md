# 题目信息

# 「LAOI-1」GCD

## 题目描述

一张图有 $n$ 个节点，编号为 $1,2,3,\dots,n$。其中 $i$ 号节点会向 $j$ 号节点连一条边权为 $|i-j|$ 的无向边，当且仅当 $\gcd(i,j)=i,\operatorname{lcm}(i,j)=j$ 时连边。现询问 $q$ 次，每次询问求 $x$ 到 $y$ 的最短路径。

## 说明/提示

注意时空限制，本题不捆绑。

对于 $40\%$ 的数据，$T,n,q\le100$;

对于 $100\%$ 的数据，$1\le T\le10^6$，$1\le n,q\le10^6$，$1\le x,y\le n$，$1\le \sum n,\sum q\le10^6$。

**请使用更快的 IO 方式**。

updata on 2024/8/8：

时限上调到 1000ms。/yun

## 样例 #1

### 输入

```
1
6 4
1 4
3 5
2 5
2 4```

### 输出

```
3
6
5
2```

# AI分析结果



---

## **唯一算法分类**  
数学/数论

---

## **综合分析与结论**

### **题解思路与核心难点**  
- **核心逻辑**：将图论的最短路径问题转化为数论问题。节点间连边条件等价于两数存在倍数关系，最短路径必然经过两数的最大公约数 `gcd(x,y)`。  
- **算法关键**：直接计算 `x + y - 2*gcd(x,y)`，时间复杂度为 `O(log min(x,y))`，完美支持高频率查询。  
- **解决难点**：  
  - 证明其他路径（如经过更小公约数或公倍数）不优，需要数学推导。  
  - 利用 `gcd` 性质跳过显式建图，直接给出公式解。  

### **可视化设计思路**  
- **动画方案**：  
  1. **像素网格**：用 8-bit 像素块表示节点，颜色区分不同数值（如暖色调表示较大值）。  
  2. **路径高亮**：从 `x` 和 `y` 逐步回退到 `gcd(x,y)`，每步用闪烁动画和音效（类似 FC 游戏跳跃声）。  
  3. **公式推导**：右侧显示当前路径长度公式 `x + y - 2g`，动态更新 `g` 的值。  
- **交互设计**：  
  - **AI 自动模式**：模拟两数分解为因数链，自动回退到 `gcd`。  
  - **音效触发**：计算 `gcd` 时播放“成功”音效，路径更新时伴随像素移动声。  

---

## **题解清单 (≥4星)**  
### **1. Coffins（⭐⭐⭐⭐⭐）**  
- **亮点**：简洁直击核心，异或交换法实现快速 `gcd`，代码高效。  
- **代码可读性**：稍显紧凑，但逻辑清晰。  

### **2. zzx0102（⭐⭐⭐⭐⭐）**  
- **亮点**：严谨数学证明，对比公倍数路径的优劣，使用标准库 `__gcd` 提升可读性。  

---

## **最优思路/技巧提炼**  
**关键公式**：  
```
最短路径长度 = x + y - 2 * gcd(x,y)
```  
**推导核心**：  
- 任意两数的最短路径必过其最大公约数，且路径分解为 `x→gcd→y`。  
- 数学证明其他路径（如经过更小公约数或公倍数）必然更长。  

---

## **同类型题拓展**  
1. **P1029** [最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)  
   - 求满足特定 `gcd` 和 `lcm` 的数对数量。  
2. **P1372** [又是毕业季](https://www.luogu.com.cn/problem/P1372)  
   - 利用 `gcd` 性质求最大可选数。  
3. **P4057** [Code Feat](https://www.luogu.com.cn/problem/P4057)  
   - 模运算与公约数的组合应用。  

---

## **代码实现**  
### **Coffins 核心代码**  
```cpp
int gcd(int a, int b) {
    while(b^=a^=b^=a%=b); // 异或交换法求 gcd
    return a;
}

// 查询处理
cout << x + y - 2 * gcd(x, y) << '\n';
```

### **zzx0102 核心代码**  
```cpp
int main() {
    int a, b; 
    int g = __gcd(a, b); // 标准库求 gcd
    writeln(a + b - 2 * g);
}
```

---

## **复古游戏化动画实现（伪代码）**  
```javascript
// 初始化像素画布
const canvas = initCanvas("8-bit", { width: 640, height: 480 });
const nodes = drawGridNodes(n); // 绘制节点网格

// 动画逻辑
function animatePath(x, y) {
    const g = gcd(x, y);
    playSound("jump"); // 8-bit 跳跃音效
    highlightPath(x, g, "red"); // 红色路径 x→g
    highlightPath(y, g, "blue"); // 蓝色路径 y→g
    showFormula(`${x}+${y}-2×${g}=${x+y-2*g}`); // 动态公式
}

// AI 自动演示模式
autoPlay(() => {
    const [x, y] = randomQuery();
    animatePath(x, y);
});
```

---

## **个人心得摘录**  
- **Coffins**：  
  > “赛时 5min 切了，第一次提交被卡输入...” → **教训**：注意 IO 优化，避免细节翻车。  
- **zzx0102**：  
  > “利用 `ij=gl` 的数学性质严谨证明” → **启发**：数论问题常需结合代数变形。  

---

**可视化总结**：通过像素动画和音效交互，将抽象的 `gcd` 路径具象化，适合快速理解核心逻辑。

---
处理用时：76.02秒
# 题目信息

# [NOIP 2014 普及组] 比例简化

## 题目背景

NOIP2014 普及组 T2

## 题目描述

在社交媒体上，经常会看到针对某一个观点同意与否的民意调查以及结果。例如，对某一观点表示支持的有 $1498$ 人，反对的有 $902$ 人，那么赞同与反对的比例可以简单的记为 $1498:902$。

不过，如果把调查结果就以这种方式呈现出来，大多数人肯定不会满意。因为这个比例的数值太大，难以一眼看出它们的关系。对于上面这个例子，如果把比例记为 $5:3$，虽然与真实结果有一定的误差，但依然能够较为准确地反映调查结果，同时也显得比较直观。

现给出支持人数 $A$，反对人数 $B$，以及一个上限 $L$，请你将 $A$ 比 $B$ 化简为 $A'$ 比 $B'$，要求在 $A'$ 和 $B'$ 均不大于 $L$ 且 $A'$ 和 $B'$ 互质（两个整数的最大公约数是 $1$）的前提下，$\dfrac{A'}{B'} \ge  \dfrac{A}{B}$ 且 $\dfrac{A'}{B'} - \dfrac{A}{B}$ 的值尽可能小。

## 说明/提示

对于 $100\%$ 的数据，$1 \le A \le 10^6,1 \le B \le 10^6,1 \le L \le 100,\dfrac{A}{B} \le L$。


## 样例 #1

### 输入

```
1498 902 10```

### 输出

```
5 3```

# AI分析结果



## 算法分类
枚举

## 题解思路与难点分析
1. **核心思路**  
   题目要求找到最简分数 $\frac{A'}{B'}$，满足 $A',B'\leq L$ 且 $\frac{A'}{B'} \geq \frac{A}{B}$，同时差值尽可能小。所有题解均基于暴力枚举，利用 $L$ 较小（$L \leq 100$）的特性，遍历所有可能的分子分母组合，并通过以下关键步骤筛选合法解：
   - **互质检查**：确保 $\gcd(A',B')=1$，避免非最简分数。
   - **比例条件**：通过交叉相乘 $A' \cdot B \geq B' \cdot A$ 避免浮点误差。
   - **差值最小**：记录满足条件的最小 $\frac{A'}{B'} - \frac{A}{B}$。

2. **解决难点**  
   - **精度问题**：部分题解直接使用浮点数比较可能导致精度丢失，正确做法应通过整数乘法（交叉相乘）比较比例。
   - **互质优化**：非互质的分数可能被提前枚举到，但通过记录最小差值可保证最终解为最简形式（部分题解因此省略互质检查，但需验证正确性）。
   - **时间复杂度**：双指针法尝试将复杂度降至 $O(L)$，但需验证是否覆盖所有合法解。

## 题解评分（≥4星）
1. **以墨（5星）**  
   - 思路清晰，正确性高，使用交叉相乘避免浮点误差，明确检查互质条件。
   - 代码简洁高效，双重循环枚举所有组合，逐步更新最优解。
   - 示例代码：
     ```cpp
     for (i=1; i<=l; i++)
         for (j=1; j<=l; j++)
             if (gcd(i,j)==1 && i*b >= j*a && i*ansb < j*ansa) {
                 ansa=i; ansb=j;
             }
     ```

2. **Actinoi（4星）**  
   - 数学推导完整，通过交叉相乘和互质检查保证正确性。
   - 代码结构清晰，注释详细，适合教学。
   - 示例代码：
     ```cpp
     if (gcd(i,j)==1 && b*i >= a*j && j*ansa > i*ansb) {
         ansa = i; ansb = j;
     }
     ```

3. **Jerry_zpl（4星）**  
   - 使用标准库 `__gcd` 简化代码，交叉相乘避免浮点运算。
   - 代码简洁，适合快速实现。
   - 示例代码：
     ```cpp
     if (__gcd(i,j)==1 && a*j <= b*i && i*s2 < j*s1) {
         s1=i; s2=j;
     }
     ```

## 最优思路提炼
1. **关键步骤**  
   - 枚举所有 $A' \in [1, L], B' \in [1, L]$。
   - 检查 $\gcd(A', B') = 1$。
   - 使用 $A' \cdot B \geq B' \cdot A$ 确保比例不小于原值。
   - 通过 $A' \cdot \text{当前分母} < \text{当前分子} \cdot B'$ 更新最小差值。

2. **避免浮点误差**  
   所有比例比较均通过整数乘法完成，例如判断 $\frac{A'}{B'} \geq \frac{A}{B}$ 转化为 $A' \cdot B \geq B' \cdot A$。

## 类似题目推荐
1. **P1062 数列**  
   - 涉及分数化简与枚举，需处理最简分数条件。
2. **P2651 添加括号**  
   - 通过枚举和数学推导优化表达式。
3. **P2118 比例简化（原题）**  
   - 直接应用本题解法。

## 可视化设计
1. **动画演示**  
   - **网格展示**：在 $L \times L$ 网格中高亮当前枚举的 $(i, j)$。
   - **颜色标记**：绿色表示合法解，红色表示不满足条件，黄色表示当前最优解。
   - **差值跟踪**：实时显示 $\frac{A'}{B'} - \frac{A}{B}$ 的变化。

2. **复古像素风格**  
   - **8位色调色板**：使用经典绿、红、黄像素块表示状态。
   - **音效提示**：找到更优解时播放上升音调，非法解播放低沉音效。

3. **交互控制**  
   - **步进/暂停**：允许手动控制枚举速度。
   - **自动演示**：AI 自动遍历所有组合，突出关键判断逻辑。

## 核心代码实现
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int gcd(int x, int y) {
    return y == 0 ? x : gcd(y, x % y);
}

int main() {
    int a, b, l, ansa, ansb;
    scanf("%d%d%d", &a, &b, &l);
    ansa = l; ansb = 1;
    for (int i = 1; i <= l; i++) {
        for (int j = 1; j <= l; j++) {
            if (gcd(i, j) == 1 && i * b >= j * a && i * ansb < j * ansa) {
                ansa = i; ansb = j;
            }
        }
    }
    printf("%d %d", ansa, ansb);
    return 0;
}
```

## 代码解释
- **互质检查**：`gcd(i, j) == 1` 确保分子分母互质。
- **比例条件**：`i * b >= j * a` 通过交叉相乘避免浮点运算。
- **差值更新**：`i * ansb < j * ansa` 保证 $\frac{i}{j}$ 更接近原比例。

---
处理用时：165.93秒
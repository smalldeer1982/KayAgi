# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果



# 【NOIP2009 提高组】最优贸易 题解分析

## 一、算法分类
**分层图 + SPFA 求最长路**

## 二、题解思路与难点对比

### 核心思路
1. **分层图建模**：构建三层图表示不同状态：
   - 第一层：未买入
   - 第二层：已买入未卖出
   - 第三层：已卖出
2. **层间转移**：
   - 第一层 → 第二层：边权为负的买入价格（`-w[i]`）
   - 第二层 → 第三层：边权为正的卖出价格（`w[i]`）
3. **最长路计算**：从第一层的起点到第三层的终点求最长路径。

### 解决难点
- **状态完整性**：通过分层确保买卖仅一次，避免重复操作。
- **可达性验证**：通过反向图预处理判断节点是否能到达终点。
- **负权边处理**：使用 SPFA 算法应对负权边的最长路计算。

### 关键代码实现
```cpp
// 层间边建立
for(int i=1; i<=n; i++) {
    G[t(i,0)].push_back({t(i,1), -v[i]});
    G[t(i,1)].push_back({t(i,2), v[i]});
}
// 同层边建立（双向边示例）
for(int i=1; i<=m; i++) {
    cin >> x >> y >> z;
    add(x, y);  // 建立同层边
    if(z == 2) add(y, x);
}
```

## 三、高星题解推荐（≥4星）

1. **fy1234567ok（5星）**  
   - **亮点**：详细图解分层结构，代码简洁（40行），通过反向建边处理可达性。
   - **代码片段**：通过宏定义 `t(x,i)` 实现分层节点编号。

2. **ctzm（4.5星）**  
   - **亮点**：Tarjan 缩点后 DAG 上 DP，解决原数据弱的问题，通过反图 DFS 处理可达性。
   - **代码片段**：缩点时记录每个 SCC 的最小买入价和最大卖出价。

3. **songge888（4星）**  
   - **亮点**：清晰分层图解释，完整代码注释，通过三次 SPFA 遍历各层图。
   - **代码片段**：显式建立三层图的同层边和跨层边。

## 四、最优思路提炼
1. **分层状态机**：通过三层图强制约束买卖状态转移。
2. **反向图预处理**：从终点反向 DFS 筛选有效节点。
3. **SPFA 最长路**：利用队列动态松弛，避免 Dijkstra 无法处理负权的问题。

## 五、同类型题目
1. **P4568 [JLOI2011] 飞行路线**（分层图 + 最短路）
2. **P2939 [USACO09FEB]Revamping Trails G**（分层图处理路径修改）
3. **P1266 速度限制**（状态分层 + 动态规划）

## 六、可视化设计

### 动画演示方案
1. **分层展示**：
   - **颜色区分**：第一层（蓝色）、第二层（绿色）、第三层（红色）。
   - **节点高亮**：当前处理的节点用黄色闪烁，队列中的节点用橙色边框。
   
2. **边权动态显示**：
   - 层内边：灰色虚线，权值 0。
   - 买入边：红色箭头，显示 `-w[i]`。
   - 卖出边：绿色箭头，显示 `w[i]`。

3. **SPFA 过程**：
   - **队列可视化**：右侧面板显示当前队列节点。
   - **松弛操作**：当 `dis[v]` 更新时，目标节点变为紫色并播放音效。

### 复古像素风格
- **8位音效**：节点入队时播放“哔”声，找到最长路时播放胜利音效。
- **Canvas 绘制**：节点用 16x16 像素方块，边用直线连接，权值用 8 像素字体显示。
- **自动演示**：点击“AI Run”后自动步进，每步间隔 500ms，显示路径更新过程。

## 七、核心代码（分层图 SPFA）
```cpp
void spfa(int s) {
    memset(dis, 0xcf, sizeof(dis));
    queue<int> q;
    q.push(s); dis[s] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto [v, w] : G[u]) {
            if (dis[v] < dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!inq[v]) q.push(v), inq[v] = 1;
            }
        }
    }
}
```

## 八、个人心得摘录
> “分层图的关键在于状态转移边的正确连接，我曾错误地将层间边连到其他层的非对应节点，导致状态混乱。通过独立的三层结构，确保买卖操作仅发生一次。” —— fy1234567ok

> “Tarjan 缩点后若不处理反图可达性，会被环状结构 hack。反向 DFS 是保证 DAG DP 正确的关键。” —— ctzm

---
处理用时：82.38秒
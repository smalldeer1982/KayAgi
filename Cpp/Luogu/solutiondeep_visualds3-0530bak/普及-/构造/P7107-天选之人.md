# 题目信息

# 天选之人

## 题目背景

暑假期间，学校不提供午餐，Gnar 只好找伙计们一起点外卖。

尴尬的是，外卖很快送到却没人乐意去校门口拿，毕竟户外可是 $35\degree\!\text{C}$ 高温！此时 Gnar 想到了好主意：“我给一人捏了一张纸团，其中一张写有记号，不如我们抓阄决定，谁抽到带记号的谁去拿！”

于是 Gnar 连续拿了六天的外卖。

这可让他不服又委屈：“换个规则！一人准备三张纸团，五张有记号，每人抽三张，记号最多的去拿！”

Gnar 紧张地展开手中的纸团，两个记号赫然映在眼前。大伙们刚想放声大笑他的非酋运气，有人缓缓举起三张纸片说道：“我也抽到了两个记号……”

## 题目描述

好奇的 Gnar 想研究一般情况下抽到最多记号的人数。他给参与抓阄的 $n$ 人一人准备了 $m$ 张捏好的纸团，一共 $nm$ 张，其中恰好 $k$ 张提前写了记号。随后每个人在均匀打乱的纸团中各抽 $m$ 张。

一个人抽到最多的记号，当且仅当没有人抽到的记号比他还多。请你帮 Gnar 判断是否可能会**恰好** $\boldsymbol{p}$ **个人**抽到最多的记号。Gnar 喜欢追根问底，所以如果有可能，你还需构造每个人抽的纸团中分别有多少带记号、有多少不带记号。

形式化地，假设第 $i$ 个人抽到了 $x_i$ 张带记号的纸团和 $y_i$ 张不带记号的纸团，你的构造应满足：

- $x_i, y_i \ge 0$，$x_i + y_i = m$。
- $\displaystyle \sum_{i = 1}^{n} x_i = k$。
- **有且仅有** $\boldsymbol{p}$ **个互不相同**的 $j$ 使 $\displaystyle x_j = \max_{i = 1}^{n} \{x_i\}$。

## 说明/提示


**【样例解释 #1】**

样例给出了一种满足题述条件的构造。

**【样例解释 #2】**

不论如何，记号的分布从高到低只有三种情况：$\{3,0,0\}$，$\{2,1,0\}$，$\{1,1,1\}$，抽到最多记号的人数分别对应 $1$，$1$，$3$。因此无法构造 $p = 2$ 的方案。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (15 points)：$n,m \le 8$。
- Subtask #2 (15 points)：$n,m \le 100$。
- Subtask #3 (20 points)：$n,m \le 10^5$。
- Subtask #4 (10 points)：$p = 1$。
- Subtask #5 (40 points)：无特殊限制。

对于所有的数据，保证 $1 \le p \le n \le {10}^5$，$1 \le m \le {10}^9$，$0 \le k \le n m$。

## 样例 #1

### 输入

```
3 3 5 2```

### 输出

```
YES
2 1
2 1
1 2```

## 样例 #2

### 输入

```
3 3 3 2```

### 输出

```
NO```

## 样例 #3

### 输入

```
3 3 5 3```

### 输出

```
NO```

# AI分析结果



---

## **唯一算法分类**  
构造/贪心

---

## **综合分析与结论**  
本题核心在于构造一种满足条件的分配方案，关键在于确定最大值并验证剩余能否合理分配。核心步骤包括：  
1. **确定最大值**：最大值 `q = min(m, k//p)`，确保 `p` 人各拿 `q` 个。  
2. **剩余分配验证**：检查剩余 `k-p*q` 是否能被 `(n-p)*(q-1)` 容纳。若超过则无解。  
3. **构造分配方案**：前 `p` 人各拿 `q`，剩余按 `q-1` 尽可能分配，最后处理余数。  

**可视化设计思路**：  
- **动画流程**：  
  1. **高亮最大值确定**：显示 `q` 的计算公式与约束条件。  
  2. **剩余分配模拟**：用动态进度条表示剩余 `k-p*q`，每次分配 `q-1` 时进度减少，剩余不足时显示余数分配。  
  3. **颜色标记**：  
    - 红色：`p` 个最大值分配。  
    - 黄色：剩余分配中的 `q-1` 填充。  
    - 绿色：最后余数的处理。  
- **复古像素风格**：用 8-bit 风格显示每个人分配结果，音效在成功分配时播放清脆音效，失败则低沉音效。

---

## **题解清单 (≥4星)**  
1. **Unordered_OIer (5星)**  
   - **亮点**：逻辑清晰，代码简洁，核心条件判断直接高效，特殊处理余数分配。  
   - **关键代码**：  
     ```cpp  
     ll q = min(m, k / p);  
     if (k - q * p > (n - p) * (q - 1)) return puts("NO");  
     ```  
2. **HanPi (4星)**  
   - **亮点**：详细处理 `n=p` 特例，引入 `mod` 和 `each` 优化余数分配。  
   - **个人心得**：提到“均匀分配”时需注意整除，避免遗漏边界条件。  
3. **Meaninglessness (4星)**  
   - **亮点**：代码可读性高，直接返回构造结果，验证逻辑简洁。  

---

## **最优思路或技巧提炼**  
1. **最大值确定公式**：`q = min(m, k//p)`，确保 `p` 人分配可行性。  
2. **剩余分配条件**：`k-pq ≤ (n-p)(q-1)`，数学验证剩余能否合法分配。  
3. **贪心填充余数**：优先用 `q-1` 填充分配，不足则直接分配余数。  

---

## **同类型题或类似算法套路**  
类似问题需同时满足“恰好 `p` 个最大值”和“资源分配约束”，常见于构造题。通用解法：  
1. 确定最大值上限。  
2. 验证剩余资源是否符合分配规则。  
3. 构造时优先填满合法最大值，余数处理遵循约束。  

---

## **推荐相似题目**  
1. **P1004 方格取数**（资源分配+动态规划）  
2. **P2114 能量项链**（环形分配与极值构造）  
3. **P2512 均分纸牌**（贪心分配与平衡条件）  

---

## **个人心得摘录**  
- **HanPi**：当 `n=p` 时，必须严格整除，否则无解。  
- **Maxmilite**：特判处理不足时需提前终止循环，避免段错误。  

---

## **可视化与算法演示**  
```html  
<!DOCTYPE html>  
<style>  
.pixel-font { font-family: 'Press Start 2P', cursive; }  
.grid { display: grid; grid-template-columns: repeat(auto-fit, 60px); gap: 5px; }  
.cell { width: 60px; height: 60px; border: 2px solid #000; }  
</style>  
<script>  
function simulate(n, m, k, p) {  
  let q = Math.min(m, Math.floor(k / p));  
  if (k - q * p > (n - p) * (q - 1)) return null;  

  let allocation = Array(n).fill().map((_, i) =>  
    i < p ? q : Math.min(q - 1, k - q * p - (i - p) * (q - 1))  
  );  
  return allocation;  
}  
</script>  
```  
**复古效果**：  
- **Canvas 绘制**：用 8-bit 方格表示每个人分配值，高亮当前操作位置。  
- **音效**：分配成功时播放 `beep.mp3`，失败播放 `error.wav`。  
- **自动演示**：按步长 500ms 逐步显示分配过程，支持暂停/继续。  

---

**核心代码片段**（Unordered_OIer）：  
```cpp  
ll q = min(m, k / p);  
if (k - q * p > (n - p) * (q - 1)) return puts("NO");  
for (ll i = 1; i <= p; i++) x[i] = q, y[i] = m - q;  
ll rest = k - q * p;  
for (ll i = p + 1; i <= n; i++) {  
  if (rest >= q - 1) x[i] = q - 1, rest -= q - 1;  
  else x[i] = rest, rest = 0;  
  y[i] = m - x[i];  
}  
```

---
处理用时：89.60秒
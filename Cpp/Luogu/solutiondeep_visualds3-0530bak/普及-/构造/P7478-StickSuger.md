# 题目信息

# StickSuger

## 题目背景

YSGHYYDS

## 题目描述

YSGH 给你一个长度为 $n$ 的字符串 $S$。设 $S_x$ 表示字符串 $S$ 的第 $x$ 个字符。你可以选择一个二元组 $(i,j)$，然后交换 $S_i$ 和 $S_j$。二元组 $(i,j)$ 是合法的当且仅当 $1\leq i<j\leq n$ 并且交换后的字符串的字典序比原串大。

对于两个字符 $c_0,c_1$，称 $c_0>c_1$ 当且仅当 $c_0$ 的 ASCII 码大于 $c_1$ 的 ASCII 码。

对于两个长度为 $n$ 的字符串 $S,T$，$S$ 的字典序大于 $T$ 当且仅当存在一个 $i\in [0,n-1]$ 使得 $\forall j\in[1,i],S_j=T_j$， 并且 $S_{i+1}>T_{i+1}$。

如果存在多种合法方案，输出最大的二元组。

对于两个二元组 $(i_1,j_1)$，$(i_2,j_2)$，称  $(i_1,j_1)$ 小于 $(i_2,j_2)$ 当且仅当 $i_1<i_2\lor(i_1=i_2\land j_1<j_2)$。

如果不存在合法方案，则输出 `-1`。 

保证 $S$ 只包含小写英文字母。

## 说明/提示

**【样例解释 #1】**

如果选择二元组 $(2,3)$，交换 $S_2$ 和 $S_3$ 后的字符串为 `abc`，字典序比 `acb` 小，所以不合法。

如果选择二元组 $(1,3)$，交换 $S_1$ 和 $S_3$ 后的字符串为 `bca`，字典序比 `acb` 大，是合法的。

虽然 $(1,2)$ 也是合法的，但是没有 $(1,3)$ 大。所以答案是 $(1,3)$。 

**【样例解释 #2】**

容易看出任何一个二元组都不合法。

---

**【数据范围】**

**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\leq n\leq 10^6$，$S$ 只包含小写英文字母。

- Subtask 1（4 points）：$S$ 只包含一种字符。
- Subtask 2（10 points）：$n\leq 100$。
- Subtask 3（16 points）：$n\leq 500$。
- Subtask 4（25 points）：$n\leq 5000$。
- Subtask 5（18 points）：$n\leq 10^5$。
- Subtask 6（27 points）：$n\leq 10^6$。


## 样例 #1

### 输入

```
3
acb```

### 输出

```
1 3```

## 样例 #2

### 输入

```
6
zyxwvu```

### 输出

```
-1```

## 样例 #3

### 输入

```
14
aabbccddccbbaa```

### 输出

```
6 8```

# AI分析结果



---

### 唯一算法分类
**贪心算法**

---

### 题解思路、算法要点与解决难点

#### 核心思路
所有最优题解的核心思想均为：**倒序遍历字符串，寻找第一个能产生更大字典序的位置 i，并在其右侧找最大的 j 使得 S[i] < S[j]**。这种思路基于以下观察：
1. 要得到最大的 i，必须从后往前找第一个可提升字典序的位置
2. 找到 i 后，右侧字符需严格递减才能保证 j 的最大性

#### 关键实现差异对比
| 题解特点                  | HanPi优化暴力 | Laser_Crystal单调栈 | Maxmilite贪心记录最后位置 | Eason_AC直接查找 |
|---------------------------|---------------|---------------------|---------------------------|------------------|
| 时间复杂度               | O(n²) → O(n) | O(n)                | O(26n)                   | O(n)            |
| 空间复杂度               | O(1)          | O(n)                | O(26)                    | O(1)            |
| 核心数据结构             | 无            | 单调栈              | 字符位置映射表           | 无              |
| 跳过重复字符优化         | ✔️            | ✔️                  | ❌                        | ✔️              |
| 代码可读性               | 中等          | 较高                | 高                       | 极高            |

#### 解决的核心难点
1. **快速定位最大 i**：通过逆序扫描首个 S[i] < S[i+1] 的位置
2. **高效找到最大 j**：利用单调递减性质直接取右侧最大值

---

### 题解评分（≥4星）
1. **Eason_AC（5星）**  
   - 思路清晰度：⭐️⭐️⭐️⭐️⭐️  
   - 代码简洁性：9行核心逻辑，无冗余  
   - 优化程度：O(n)时间复杂度，无额外空间  
   ```cpp
   for (int i = n - 2; i >= 0; i--) 
     if (s[i] < s[i+1]) { p = i; break; }
   for (int j = n-1; j > p; j--)
     if (s[j] > s[p]) { cout << p+1 << " " << j+1; }
   ```

2. **Laser_Crystal（4.5星）**  
   - 创新性：通过单调栈形象化问题  
   - 实现难点：需要处理二分查找边界  
   ```cpp
   while(s[k] >= s[k+1]) k--; // 建立单调栈
   ```

3. **Maxmilite（4星）**  
   - 空间优化：O(26)空间记录字符最后位置  
   - 适用性：可扩展至多字符比较场景  
   ```cpp
   for (int j = s[i]-'a'+1; j <= 26; ++j)
     if (cnt[j]) res = max(res, cnt[j]);
   ```

---

### 最优思路与技巧提炼
**关键技巧**：  
1. **逆序扫描**：从后往前找第一个可交换点 i，保证 i 最大  
2. **极值缓存**：在 i 右侧维护最大值或最后出现位置，快速确定 j  
3. **剪枝优化**：跳过连续相同字符减少无效比较

**思维突破点**：  
- 将字典序比较转化为字符大小关系的极值问题  
- 利用字符串的单调性特征避免全排列遍历

---

### 相似题目推荐
1. **[P1090 合并果子](https://www.luogu.com.cn/problem/P1090)**  
   - 同类型贪心策略：优先处理最小元素
2. **[LeetCode 31. 下一个排列](https://leetcode.cn/problems/next-permutation/)**  
   - 完全相同核心思路：找交换点并反转右侧
3. **[P1155 双栈排序](https://www.luogu.com.cn/problem/P1155)**  
   - 类似单调栈结构的应用

---

### 核心算法可视化设计
**动画方案**：  
1. **像素风格界面**：  
   - 字符以16x16像素块显示，ASCII值映射为不同颜色  
   - 当前扫描位置用闪烁红框标记  
2. **关键步骤展示**：  
   - **阶段1**（找i）：从右向左扫描，遇到 S[i] < S[i+1] 时高亮黄框  
   - **阶段2**（找j）：在i右侧从右向左滑动蓝框，找到首个 S[j] > S[i]  
3. **音效交互**：  
   - 找到i时播放8-bit上升音效  
   - 确定j时播放胜利音效  
   - 无解时播放经典FC失败音乐

**Canvas 伪代码**：  
```javascript
function drawStep() {
  clearCanvas();
  // 绘制字符矩阵
  for (let i=0; i<n; i++) {
    drawChar(i, s[i], currentPos == i ? 'red' : 'gray');
  }
  // 高亮i和j
  if (found_i) drawBorder(i_pos, 'yellow');
  if (found_j) drawBorder(j_pos, 'blue');
}
```

---

### 代码实现（Eason_AC 最优解）
```cpp
#include <iostream>
using namespace std;

int main() {
    int n, pos = -1;
    string s;
    cin >> n >> s;
    // 逆序找第一个可交换点i
    for (int i = n-2; i >= 0; i--) {
        if (s[i] < s[i+1]) {
            pos = i;
            break;
        }
    }
    if (pos == -1) {
        cout << -1;
        return 0;
    }
    // 在i右侧找最大j
    for (int j = n-1; j > pos; j--) {
        if (s[j] > s[pos]) {
            cout << pos+1 << " " << j+1;
            return 0;
        }
    }
}
```

**代码亮点**：  
- 无额外空间消耗  
- 两次线性扫描完成全部操作  
- 边界处理简洁高效

---
处理用时：80.77秒
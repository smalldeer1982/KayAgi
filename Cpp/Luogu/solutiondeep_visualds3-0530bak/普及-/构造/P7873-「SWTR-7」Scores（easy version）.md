# 题目信息

# 「SWTR-7」Scores（easy version）

## 题目背景

#### 本题是 Scores 的 easy 版本。注意题目限制与 [hard](https://www.luogu.com.cn/problem/P7876) 版本不同。

#### 请注意特殊的时空限制，题目描述下方有简化题意。

## 题目描述

小 A 的班上有 $n$ 个学生。最近他们进行了一场考试，共有 $m$ 个学科。第 $i$ 个学生第 $j$ 门学科的得分为**整数** $s_{i,j}\ (0\leq s_{i,j}\leq 100)$。对于学生 $i$，如果**存在另一个**学生 $j$ 满足：学生 $i$ **每门学科的成绩都不大于**学生 $j$，学生 $i$ 就会感到失落。

中秋节快到了，善良的小 A 不想让任何一个同学感到失落，他决定 hack 学校的管理系统，修改每一位同学的成绩。在做出这样危险的举动之前，小 A 希望知道自己能否达到目标。不过，由于学生和科目实在太多，他想请你帮助他构造出一种合法的方案。

如果存在一张成绩表，满足没有任何一位同学感到失落，请先输出 $\texttt{YES}$，再**任意**输出一种符合要求的成绩表；否则输出 $\texttt{NO}$。

---

**「简化题意」**

试构造一个 $n\times m$ 的矩阵 $s$，满足所有元素为 $[0,100]$ 之间的整数，且对于任意 $i,j\ (i\neq j)$ 存在一个 $k$ 使得 $s_{i,k}>s_{j,k}$。

## 说明/提示

**「Special Judge」**

**本题使用 Special Judge。请认真阅读输出格式，输出格式有误可能导致 UKE。**

SPJ 首先会判断你的第一行输出是否与答案相同。  
如果相同且答案为 $\texttt{YES}$，则 SPJ 会判断你的输出是否符合小 A 的要求：

- $0\leq s_{i,j}\leq 100$ 且 $s_{i,j}$ 为整数。
- 每个学生至少有一个科目的成绩比另一个学生高。

如果有解且你输出 $\texttt{YES}$，但给出方案错误，你将获得该测试点 $50\%$ 的分数。

**「数据范围与约定」**

本题共有 6 个测试点。

- Testcase #0（1 point）：是样例。
- Testcase #1（10 points）：$n=1$。
- Testcase #2（10 points）：$m=1$。
- Testcase #3（20 points）：$m=2$。
- Testcase #4（30 points）：$n\leq m$。
- Testcase #5（29 points）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n,m\leq 100$，$T=20$（除 Testcase #0）。  
对于所有测试点，**时间限制 200ms，空间限制 16MB。**

**「题目来源」**

[Sweet Round 07](https://www.luogu.com.cn/contest/51774) A1。  
idea & solution & data：[Alex_Wei](https://www.luogu.com.cn/user/123294)；验题：[chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
4
5 3
1 10
17 1
2 7```

### 输出

```
YES
100 99 97
98 100 99
95 97 100
0 98 100
99 99 99
YES
1 2 3 4 5 6 7 8 9 10
NO
YES
95 99 76 88 87 51 49
72 100 80 92 100 60 60```

# AI分析结果



**唯一算法分类**: 构造

**综合分析与结论**  
本题的核心在于构造一个矩阵，使得每两行之间至少存在一列满足严格大于。通过分析，发现当科目数 $m \geq 2$ 时，只需巧妙设计前两列即可满足条件，其余列可任意填充。构造策略通常采用前两列互为逆序排列（如第一列递增，第二列递减），确保任意两个学生之间存在至少一科的大小关系。当 $m=1$ 且 $n>1$ 时无解，否则均可构造。

**题解清单 (≥4星)**  
1. **作者：MY（五星）**  
   - **亮点**：代码简洁，思路清晰，通过奇偶列交替升序/降序排列，保证每两个学生存在一科优势。  
2. **作者：HYdroKomide（五星）**  
   - **亮点**：前 $m-1$ 列递增，最后一列递减的构造方式，直观且易于实现，覆盖所有比较情况。  
3. **作者：Mortis_Vampire（四星）**  
   - **亮点**：前两列分别为升序和降序，其余列固定，逻辑简单明确，代码高效。

**最优思路或技巧提炼**  
关键构造策略：  
1. **前两列逆序排列**：第一列递增（如 $1,2,\dots,n$），第二列递减（如 $n,n-1,\dots,1$），确保任意两行存在至少一列的大小关系。  
2. **其他列任意填充**：只要前两列满足条件，其余列可设为固定值（如 $0$ 或 $100$），不影响结果。  
3. **特判 $m=1$**：当仅有一科且学生数 $n>1$ 时，必然无解。

**同类型题或类似算法套路**  
类似构造题通常要求设计满足特定比较条件的数据结构。例如：  
- 构造排列使得相邻元素满足大小交替。  
- 设计矩阵使得每行/列有唯一最大值。  
- 构造数组使得任意子数组满足某种条件。

**推荐相似题目**  
1. **P1003 铺地毯**（构造覆盖关系）  
2. **P1062 数列**（构造满足特定规则的数列）  
3. **P2119 魔法阵**（四元组大小关系构造）

**个人心得摘录**  
- **构造题需大胆尝试**：通过简单例子验证构造策略的正确性，例如小规模数据手动模拟。  
- **特判边界条件**：如 $m=1$ 时的无解情况，避免遗漏。

**可视化与算法演示**  
1. **动画方案**：  
   - **Canvas 网格**：用网格表示矩阵，行为学生，列为科目。  
   - **颜色标记**：前两列用不同颜色区分升序（绿色）和降序（红色），其余列灰色。  
   - **步进演示**：高亮当前比较的两个学生，展示其在前两列的大小关系。  
2. **复古像素风格**：  
   - **8位风格**：学生用像素小人表示，分数用色块高度体现，升序/降序通过箭头动画展示。  
   - **音效**：成功比较时播放“叮”声，错误时“哔”声，背景音乐为 8-bit 轻快旋律。  
3. **交互设计**：  
   - **拖拽调整**：允许用户手动调整前两列数值，实时验证是否满足条件。  
   - **自动模式**：AI 自动生成不同构造方案，对比效率与正确性。

**核心代码实现**  
```cpp
#include <cstdio>

int main() {
    int T, n, m;
    scanf("%*d%d", &T);
    while (T--) {
        scanf("%d%d", &n, &m);
        if (m == 1 && n > 1) {
            puts("NO");
            continue;
        }
        puts("YES");
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                if (j == 1) printf("%d ", i);       // 第一列递增
                else if (j == 2) printf("%d ", n - i + 1); // 第二列递减
                else printf("0 ");                  // 其余列任意值
            }
            puts("");
        }
    }
    return 0;
}
```  
**代码说明**：前两列分别按升序和降序排列，其余列填充 0，确保任意两行至少存在一列满足大小关系。

---
处理用时：82.99秒
# 题目信息

# 「Wdcfr-1」Alice Wins!  (easy version)

## 题目描述

**版本之间的区别在于操作的限制。**

Alice 是一个可爱的女孩，她有很多玩偶。

有 $4 \cdot n$ 个玩偶在玩“石头剪刀布”。他们被分成两个队伍：A 队和 B 队。每个队伍包含 $2 \cdot n$ 个玩偶。

总共会进行 $2 \cdot n$ 轮比赛。在第 $i$ 轮中，A 队的第 $i$ 个玩偶将与 B 队的第 $i$ 个玩偶对战。如果 A 队的玩偶赢了，A 队将获得 $1$ 分。如果输了，A 队将失去 $1$ 分。如果打平，A 队将不获得分数。

Alice 知道所有玩偶在这场比赛中的选择。具体来说，她用两个数组 $a$ 和 $b$ 来表示两个队伍中玩偶的选择。$a_i$ 表示 A 队第 $i$ 个玩偶的选择，$b_i$ 表示 B 队第 $i$ 个玩偶的选择。在这个问题中，我们用 $1$ 表示石头，$2$ 表示剪刀，$3$ 表示布。

现在对于**每个队伍**，Alice 想要改变**最多** $n$ 个玩偶的选择，以使 A 队的得分尽可能高。

找出 A 队的最大得分及其构造方法。如果有多个答案，输出任意一个（你仍然需要最大化 A 队的得分）。

## 说明/提示

### 解释

对于第一个测试用例，我们可以将 $a_2$ 改为 $1$，将 $b_1$ 改为 $2$。然后 A 队可以得到 $2$ 分。可以证明这是 A 队可以获得的最大分数。

对于第二个测试用例，我们可以将 $a_1$ 改为 $3$，将 $a_2$ 改为 $1$。

### 约束

$1\le T,n \le 10^5; 1\le a_i,b_i \le 3$。所有测试用例中 $n$ 的总和 $\le 10^5$。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
2
1
1 2
1 2
2
2 3 1 3
1 2 2 1```

### 输出

```
2
1 1
2 2
4
3 1 1 3
1 2 2 1```

# AI分析结果



# 算法分析与题解总结

## 算法分类
**贪心算法**

---

## 题解思路与解决难点

### 核心思路
所有题解均基于贪心策略：  
1. **前n轮修改A队的出拳**，使其必胜当前B队对应位置  
2. **后n轮修改B队的出拳**，使其必输给A队对应位置  
通过此策略，每个队伍恰好修改n次，使得所有2n轮A队全胜，总得分为2n。

### 解决难点
- **如何确保修改次数不超限**：拆分修改任务为两个独立阶段，前n次改A，后n次改B  
- **出拳规则转换**：需快速计算使A胜或B输的对应值，常用数学取模或直接映射表  
- **构造解的验证**：需保证所有修改后的对决结果均为A胜  

---

## 题解评分（≥4星）

1. **jxbe6666（5星）**  
   - 思路清晰，直接分两阶段处理  
   - 代码简洁，使用条件判断快速确定修改值  
   - 可读性极强，无冗余操作  

2. **猜一猜我是谁（5星）**  
   - 前n次改A，后n次改B的拆分逻辑清晰  
   - 使用预定义的`win`和`fail`数组快速查询修改目标值  
   - 输出部分优化，保留未修改的元素  

3. **ahawzlc（4星）**  
   - 数学化处理出拳规则，使用`(b[i]+2)%3`确保A胜  
   - 代码结构简洁，统一调整数组元素  
   - 需注意数组索引从1开始可能引起理解偏差  

---

## 最优思路与技巧提炼

### 关键技巧
1. **分阶段贪心**：将2n轮拆分为前n和后n，分别处理A、B的修改  
2. **快速出拳映射**：  
   - A胜B的规则：`A = (B-1) mod 3`（若B为石头1，则A改为布3）  
   - B输给A的规则：`B = (A+1) mod 3`（若A为布3，则B改为石头1）  
3. **代码优化**：保留未修改元素，减少不必要的赋值操作  

### 同类型题套路
- **两阶段处理**：如分配资源问题，将总任务拆分为两个独立子任务  
- **模运算映射**：适用于循环规则问题（如星期计算、循环队列）  

---

## 推荐相似题目
1. **P1094 [NOIP2007 普及组] 纪念品分组**（贪心+双指针）  
2. **P1209 [USACO1.3]修理牛棚 Barn Repair**（区间划分与贪心）  
3. **P4995 跳跳！**（贪心选择最大最小交替）  

---

## 个人心得摘录
- **jxbe6666**：明确分阶段后无需考虑交叉影响，极大简化问题  
- **猜一猜我是谁**：预处理映射表提升代码可读性，是工程化思维的体现  

---

## 可视化算法演示设计

### 核心逻辑动画
1. **分帧展示**：  
   - **前n轮**：高亮A队元素，动态修改为对应胜利值  
   - **后n轮**：高亮B队元素，动态修改为对应失败值  
   - 每步显示当前得分累加过程  

2. **颜色标记**：  
   - 修改的A元素：绿色闪烁  
   - 修改的B元素：红色闪烁  
   - 未修改元素：灰色半透明  

3. **复古像素风格**：  
   - 使用16色像素画风，每个元素用8x8像素块表示  
   - 音效设计：  
     - 修改A时播放"叮"声  
     - 修改B时播放"咚"声  
     - 得分增加时播放上升音阶  

### 交互设计
- **步进控制**：空格键单步执行，Enter键自动播放  
- **速度调节**：方向键调整动画速度（0.5x~2x）  
- **数据面板**：显示当前修改次数（A/B已改次数）和实时得分  

---

## 核心代码实现（C++）
```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
    int T, n;
    cin >> T;
    while(T--) {
        cin >> n;
        int N = 2 * n;
        vector<int> a(N), b(N);
        for(int i=0; i<N; i++) cin >> a[i];
        for(int i=0; i<N; i++) cin >> b[i];
        
        // 修改前n个A
        for(int i=0; i<n; i++) {
            if(b[i] == 1) a[i] = 3;
            else if(b[i] == 2) a[i] = 1;
            else a[i] = 2;
        }
        // 修改后n个B
        for(int i=n; i<N; i++) {
            if(a[i] == 1) b[i] = 2;
            else if(a[i] == 2) b[i] = 3;
            else b[i] = 1;
        }
        
        cout << N << endl;
        for(int x : a) cout << x << " ";
        cout << endl;
        for(int x : b) cout << x << " ";
        cout << endl;
    }
    return 0;
}
```

---
处理用时：82.75秒
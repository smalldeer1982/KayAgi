# 题目信息

# [WFOI - 02] I wanna win the race（比赛）

## 题目背景

> best is yet to come

kid 不小心进入了联机模式，他需要比他的对手更快通关才能取得胜利……

## 题目描述

kid 走进了一个场地，若干名选手在进行比赛，场地可以抽象为一个坐标系。

选手们要从 $\left(1,1\right)$ 跑到 $\left(n,n\right)$，若当前选手处在 $\left(x,y\right)$，则他们下一步可以移动到 $\left(x\pm1,y\right)$ 或 $\left(x,y\pm1\right)$，注意，他们**仅可以在第一象限活动**，即任何时候 $x>0,y>0$。

所有点最开始都是 $\texttt{A}$ 类点，主办方选择了一个三元组 $\left(a,b,c\right)$，将所有满足 $a\leq x\leq b$ 且 $y\leq c$ 的点 $\left(x,y\right)$ 变为 $\texttt{B}$ 类点，选手每经过一个 $\texttt{A}$ 类需要耗时 $1$ 秒，每经过一个 $\texttt{B}$ 类需要耗时 $2$ 秒。请注意，**起始点和终点也要纳入计算。**

kid 想要赢得这场比赛，他想知道**最少**需要多少秒能到达终点。

**请注意，在【数据范围】中有重要的约束条件。**

## 说明/提示

**【样例解释】**

下图是其中一种可行的方案，紫色点为 $\texttt{A}$ 类点，红色点为 $\texttt{B}$ 类点：

![](https://s1.ax1x.com/2022/03/06/bBvQPJ.png)

**【数据规模与约定】**

**本题采用 $\tt Subtask$ 捆绑测试。**

对于 $30\%$ 的数据，$1<a<b<n\leq 10^3，0<c\leq 10^3$。

对于 $100\%$ 的数据，$1<a<b<n\leq 10^9，0<c\leq 10^9$。

## 样例 #1

### 输入

```
5
2 4 3```

### 输出

```
9```

# AI分析结果



### 唯一算法分类
数学/分类讨论

### 综合分析与结论
题目要求从(1,1)到(n,n)的最短耗时路径，关键在于处理B类区域的影响。通过分析B类区域的分布（由参数a,b,c决定），分两种情况处理：

1. **c < n时**：B类区域未覆盖y=n的行，最优路径沿上边界走，耗时2n-1秒。
2. **c ≥ n时**：存在两种策略：
   - **直穿B区**：基础时间2n-1秒，加上B区横截面(b-a+1)点的额外耗时，总时间2n + b - a。
   - **绕行上方**：走y=c+1的路径，所有点为A类，时间2c+1秒。取两者最小值。

### 题解清单（≥4星）
1. **Elgo87（⭐⭐⭐⭐⭐）**  
   思路清晰，直接给出两种情况的最优解公式，代码简洁高效。
2. **sgl654321（⭐⭐⭐⭐⭐）**  
   推导严谨，明确区分两种走法，代码实现直观。
3. **Engulf（⭐⭐⭐⭐）**  
   图文结合解释思路，公式推导详细，代码可读性强。

### 核心算法实现
```cpp
#include <iostream>
using namespace std;

int main() {
    long long n, a, b, c;
    cin >> n >> a >> b >> c;
    if (c < n) {
        cout << 2 * n - 1;
    } else {
        long long path1 = 2 * n + b - a;
        long long path2 = 2 * c + 1;
        cout << min(path1, path2);
    }
    return 0;
}
```

### 同类型题推荐
1. **洛谷P1002 过河卒**  
   路径计数中处理障碍区域，类似动态规划。
2. **洛谷P1143 马的遍历**  
   利用BFS处理网格移动的最短路径。
3. **洛谷P1219 八皇后**  
   分类讨论与回溯思想，强化分类处理能力。

### 可视化与算法演示
**动画方案设计**：
1. **网格绘制**：用Canvas绘制坐标系，红色标记B类区域，紫色为A类。
2. **路径对比**：
   - 直穿路径：红色高亮B区横截面，显示耗时增加。
   - 绕行路径：蓝色路径沿y=c+1移动，绿色显示省时优势。
3. **像素风格**：8位复古色块（红、蓝、紫），音效提示路径切换。
4. **交互控制**：滑动条调节参数a,b,c，实时更新路径与耗时。

**关键代码片段（Canvas绘制）**：
```javascript
// 绘制B类区域
ctx.fillStyle = '#FF0000';
for (let x = a; x <= b; x++) {
    for (let y = 1; y <= c; y++) {
        drawPixel(x, y);
    }
}

// 路径动画
function animatePath(pathType) {
    if (pathType === 'direct') {
        // 直穿路径动画
        animateLine(1, 1, 1, n, () => animateLine(1, n, n, n));
    } else {
        // 绕行路径动画
        animateLine(1, 1, 1, c+1, () => animateLine(1, c+1, n, c+1, () => animateLine(n, c+1, n, n)));
    }
}
```

### 个人心得摘录
- **数据范围优先**：发现c可能≥n是关键突破口。
- **公式验证**：通过极端样例（如c=n）验证绕行时间2c+1的正确性。
- **边界处理**：起点和终点的计入影响最终结果，需仔细核对。

---
处理用时：348.23秒
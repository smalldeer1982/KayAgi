# 题目信息

# [入门赛 #9] 牵连的世界 (Hard Version)

## 题目背景


这是一道 **hack 题**。在此类型的题目中，你将得到若干个问题和若干个解决对应问题的代码，但是给出的代码不能对于某些输入给出正确的输出。不能给出正确的输出的情况包括：

1. 输出错误的结果。
2. 运行超时。
3. 产生一些运行时未定义行为。目前技术可检测的未定义行为仅包括数组越界。

对于每个问题，你需要提交一份符合要求的输入数据，使得给定的代码不能给出正确的输出。你可以直接使用『提交答案』功能，也可以提交一份以任何语言写成的数据生成器。

---
**提示：如果你使用提交答案功能，请在提交其他题目时记得将语言改回你所使用的语言**

## 题目描述

以下给出三个问题的题目描述：

#### 问题 1

给出 $n$ 个整数，求其中奇数的个数。

#### 问题 2

判定 $p$ 是否为质数。

#### 问题 3

给出 $n$ 个整数，第 $i$ 个为 $a_i$。找到最大的数 $p$，使得满足 $a_i \ge p$ 的 $i$ 个数不小于 $\lfloor \dfrac{n}{2} \rfloor$。

## 说明/提示

### 样例组与实际输入的说明

三个样例分别对应三个问题的样例输入输出。

如果你直接采用『提交答案』的方式，请分别将三个输入数据命名为 `1.in`、`2.in`、`3.in`，并打成 zip 压缩包进行提交；

如果你采用提交数据生成器的方式，你的生成器可以从标准输入读入一个整数 $x$，满足 $1 \leq x \leq 3$，表示该测试点对应的问题编号，然后**输出对应的输入数据**。

显然，你的程序不应该读入『输入格式』里提到的任何内容（而应该构造它们），也不应该输出『样例输出』里提到的任何内容（而是只输出你构造的输入数据）。你不应该使用样例测试你的程序，这只是对三个问题的样例说明。

### 数据规模要求

你给出的数据必须满足如下要求：

1. 完全符合『输入格式』的规定，不能有多余的输入，但是可以有行末空格和文末回车。
2. 数据中所有的数字都应为整数。
3. 对于问题 1，$1 \leq n \leq 1000, -2 \times 10^9 \le a_i \le 2 \times 10^9$。
4. 对于问题 2，$1 \le p \le 10^{12}$。
5. 对于问题 3，$2 \leq n \leq 100$，$1 \leq a_i \leq 2 \times 10^9$。

### 目标代码

你需要 hack 如下的代码：

#### 问题 1

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  int n, ans = 0;
  cin >> n;
  for(int i = 1, x; i <= n; i++) {
    cin >> x;
    if(x % 2 == 1) ++ans;
  }
  cout << ans << endl;
}
```

#### 问题 2

```cpp
#include<bits/stdc++.h>
using namespace std;

bool isprime(long long x) {
    if(x == 1) return false;
    for(int i = 2; i * i <= x; i++) {
        if(x % i == 0) return false;
    }
    return true;
}

int main() {
    long long p;
    cin >> p;
    if(isprime(p)) cout << "Yes" << endl;
    else cout << "No";
    return 0;
}
```

#### 问题 3

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 1000 + 7;

int n, a[MAXN];

bool check(int x) {
    int tot = 0;
    for(int i = 1; i <= n; i++) {
        if(a[i] >= x) ++tot;
    }
    return (tot >= (n / 2));
}

int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    int L = 1, R = 2000000000, ans;
    while(L <= R) {
        int mid = (L + R) / 2;
        if(check(mid)) ans = mid, L = mid + 1;
        else R = mid - 1;
    }
    cout << ans << endl;
    return 0;
}
```

目标代码的编译选项为 `-std=c++14 -fno-asm -O2`。编译器为洛谷提供的 g++。你可以在『在线 IDE』中选择 C++14 语言来获得完全相同的编译环境。

### 判分说明

本题共三个测试点，分别对应三个问题，测试点分值依次为 $30$分、$30$ 分、$40$ 分。

#### 数据判定

你给出的数据必须完全符合『数据规模要求』，否则将得到 Unaccepted 的结果。

#### 超时判定

程序每执行若干条指令，我们会检测一遍程序的运行时间。我们保证两次检测之间的指令条数是一个输入规模无关的量，也即每执行 $O(1)$ 条指令会进行一次检测。且两次检测之间的指令条数不会太多，一般不超过 $100$ 条 C++ 语句。

如果程序的运行时间超过 $500 \text{ms}$，则判定为程序运行超时，返回 accepted 结果。

#### 结果错误判定

如果程序在规定的时间内结束且给出了一个输出，我们会比较这个输出和**完全正确的输出**，如果二者不同，则判定为 hack 成功，返回 accepted 结果。

#### 未定义行为判定

我们会在每次**显式**的调用数组元素前判断数组下标是否超过数组范围，如果超过，则判定为 hack 成功，返回 accepted 结果。

这就是说，如果你希望通过未定义行为进行 hack，只能对显式的调用数组元素的行为进行 hack。

### 样例程序

这是一份可以帮你理解你需要输出的内容的样例程序，**但它不能给出正确的 hack 数据**。直接提交此程序不会得分。

```cpp
#include <iostream>

using namespace std;

int main() {
  int taskId;
  cin >> taskId;
  if (taskId == 1) {
    cout << "" <<endl;
  } else if (taskId == 2) {
    cout << "" << endl;
  } else if (taskId == 3) {
    cout << "" << endl;
  } else { // 这个 else 不会被执行
    cout << "QiHai Nanami" << endl;
  }
}
```

如果你使用『提交答案』功能，请务必保证打开压缩包后能且仅能**直接**看到三个 `.in` 文件。这就是说，文件结构必须是：

```plain
ans.zip
 |---1.in
 |---2.in
 |---3.in
```

三个文件不应该被额外的文件夹包含，即文件结构不能是：

```plain
ans.zip
 |---ans(folder)
      |---1.in
      |---2.in
      |---3.in
```

### 关于评测信息的说明

如果 hack 成功，对应测试点的信息为 accepted。如果返回其他信息，说明程序本身有误。

例如，如果返回 TLE，不代表成功的将对应程序 hack 至超时，而是表示数据生成器本身运行超时，测试点不得分。

特别的，返回 UKE 结果可能是数据不合法（有多余内容、缺少内容或数据范围不符合要求）。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
2```

### 输出

```
Yes```

## 样例 #3

### 输入

```
4
1 2 3 4```

### 输出

```
3```

# AI分析结果



# 综合分析与结论

## 唯一算法分类
无算法分类（核心为代码漏洞分析与边界条件构造）

---

## 题解思路与核心难点

### 问题1（统计奇数个数）
- **关键漏洞**：代码用 `x % 2 == 1` 判断奇数，但负数取模结果为 `-1`。
- **解决方案**：构造包含负奇数的输入（如 `-1`）。

### 问题2（质数判断）
- **关键漏洞**：循环变量 `i` 为 `int` 类型，大质数导致 `i*i` 溢出。
- **解决方案**：输入超大质数（如 `999999999989`），触发溢出。

### 问题3（二分查找最大值）
- **关键漏洞**：`mid = (L + R) / 2` 中 `L + R` 可能溢出 `int` 范围。
- **解决方案**：构造两个极大数（如 `2000000000`），使 `L + R` 超过 `2147483647`。

---

## 题解评分（≥4星）

### 1. GeorgeAAAADHD（4.5★）
- **亮点**：简洁直接，给出最小输入样例。
- **不足**：解释较简略，未完整分析所有边界条件。

### 2. yszkddzyh（5★）
- **亮点**：详细分析代码漏洞，提供多组数据，包含调试经历（感谢Lyrically提示）。
- **示例数据**：`1999999999 2000000000` 精准触发溢出。

### 3. yzm0325（4★）
- **亮点**：明确分点解释每个漏洞，给出替代质数 `999999999961`。
- **不足**：问题3数据未完全验证溢出结果。

---

## 最优思路与技巧

### 问题1：负数取模特性
- **核心**：利用C++负数取模结果特性构造输入。
- **通用性**：类似问题需注意条件判断的数学定义。

### 问题2：变量类型溢出
- **核心**：利用循环变量类型与数据范围不匹配的漏洞。
- **扩展**：检查代码中所有中间变量的类型是否匹配。

### 问题3：中间值溢出
- **核心**：识别二分查找中 `L + R` 的溢出风险。
- **通用解法**：使用 `L + (R - L) / 2` 代替加法。

---

## 同类型题与推荐题目
1. **P3383 【模板】线性筛素数**（质数判断优化）
2. **B3714 [语言月赛 202302] 牵连的世界 (Easy Version)**（同一题目的简化版）
3. **P2249 【深基13.例1】查找**（二分查找边界条件）

---

## 可视化与算法演示设计

### 问题1：负数取模动画
- **像素风格**：红色方块表示 `x`，蓝色方块表示 `x % 2`。
- **音效**：当 `x` 为负奇数时播放“错误”音效。

### 问题2：溢出过程演示
- **动画设计**：显示 `i` 从 `2` 开始增长，当 `i > 46340` 时触发溢出，`i*i` 变为负数。
- **颜色标记**：溢出时 `i` 变为闪烁红色，背景变黄警告。

### 问题3：二分查找溢出
- **Canvas 网格**：绘制 `L` 和 `R` 的数值条，相加时显示溢出后的错误 `mid`。
- **步进控制**：单步执行二分过程，高亮 `mid` 计算步骤。

---

## 代码片段示例

### 问题3修复代码（防溢出）
```cpp
int mid = L + (R - L) / 2; // 替代 (L + R)/2
```

---

## 复古游戏化设计
- **8位音效**：使用 `beep.js` 库模拟FC音效。
- **积分系统**：每成功Hack一题得10分，连续正确触发连击奖励。
- **自动演示模式**：按空格键启动AI自动构造漏洞数据，动态显示代码执行流程。

--- 

通过上述分析，可系统化理解Hack题的核心思路与通用解法。

---
处理用时：66.83秒
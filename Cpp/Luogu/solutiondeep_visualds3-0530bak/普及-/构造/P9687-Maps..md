# 题目信息

# Maps.

## 题目描述

小 Y 希望得到一幅地图，这份地图有些与众不同。

这份地图是一幅长为 $n$ 个单位，宽为一个单位的网格图，每个网格必须被涂鸦成白色（$0$）或者黑色（$1$）。

你希望满足小 Y 的愿望送给他一幅这样的地图，但是这时小 Y 又提出了两点要求：

- 对于每个不在网格图两端的白色格子，恰好有 $p$ 个满足它的左右两个格子都被涂鸦成黑色。
- 在满足上述所有条件的情况下，这幅地图从左到右的字符构成的字符串的字典序最小。

你心想，这些要求也是小菜一碟，于是开始了你的创作。

## 说明/提示

#### 【样例解释 #1】

对于第一组数据：只有位于第 $4$ 个字符上的数，满足本身是 $0$，不在地图边缘且周围两个都是 $1$，因此符合条件。可以证明这是满足条件的字典序最小的方案。

对于第三组数据：可以证明没有任何一个解满足长度为 $5$ 且有 $3$ 个数本身是 $0$，不在地图边缘且周围两个字符都是 $1$。

#### 【数据范围】

对于所有测试数据，满足 $1 \le T \le 100$，$1 \le n,p \le 10^5$。

**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\text{Subtask}$。**

各测试点的附加限制如下表所示。

| 测试点 | $n,p \le$ |
| :-----------: | :-----------: |
| $1 \sim 3$ | $10$ |
| $4 \sim 5$ | $10^3$ |
| $6\sim 10$ | $10^5$ |

## 样例 #1

### 输入

```
5
5 1
3 1
5 3
5 4
5 5```

### 输出

```
00101
101
-1
-1
-1```

# AI分析结果



---

**算法分类**：构造型问题（贪心策略）

---

### **题解思路与难点分析**

#### **核心逻辑与推导**
- **条件判断**：每个符合要求的 `0` 需位于形如 `101` 的结构中。构造至少需要 `2p + 1` 长度，若 `n < 2p + 1` 则无解。
- **字典序最小**：尽可能将 `0` 填充在前部，后部构造 `10101...` 的模式。前部填充 `n - (2p + 1)` 个 `0`，后部通过循环生成 `p` 次 `10` 并补 `1`。

#### **关键步骤**
1. **无解判断**：若 `2p + 1 > n`，输出 `-1`。
2. **填充前导零**：输出 `n - (2p + 1)` 个 `0`。
3. **构造尾部模式**：循环 `p` 次输出 `10`，最后补 `1`。

#### **解决难点**
- **贪心策略**：通过前导零最小化字典序。
- **模式复用**：复用 `10` 循环生成 `101` 结构，避免逐个字符判断。

---

### **题解评分（≥4星）**

1. **题解作者：bryce（5星）**  
   - **亮点**：代码简洁高效，直接推导填充逻辑，无冗余操作。
   - **代码片段**：  
     ```cpp
     for (int i = 1; i <= n - (2 * p + 1); i++) cout << 0;
     for (int i = 1; i <= p; i++) cout << "10";
     cout << 1 << endl;
     ```

2. **题解作者：Lovely_Elaina（4.5星）**  
   - **亮点**：逆向填充前导零，逻辑清晰，代码可读性强。
   - **代码片段**：  
     ```cpp
     for(int i = n-len; i > 0; i--) cout << 0;
     for(int i = 1; i <= p; i++) cout << "10";
     ```

3. **题解作者：MarsTraveller（4星）**  
   - **亮点**：详细分析构造过程，代码中明确注释各部分功能。

---

### **最优思路提炼**
- **贪心填充**：前导零最大化，尾部模式复用 `10` 循环。
- **数学推导**：通过 `2p + 1` 快速判断可行性。

---

### **同类问题与推荐题目**
1. **构造特定模式**：[LeetCode 984. String Without AAA or BBB](https://leetcode.com/problems/string-without-aaa-or-bbb/)
2. **字典序最小构造**：[CF 1093B. Letters Rearranging](https://codeforces.com/problemset/problem/1093/B)
3. **贪心策略优化**：[洛谷 P1223 排队接水](https://www.luogu.com.cn/problem/P1223)

---

### **可视化与算法演示**

#### **动画设计（像素风格）**
1. **初始化**：显示长度为 `n` 的空网格，默认填充白色（`0`）。
2. **填充前导零**：从左到右逐个填充绿色方块（`0`），共 `n - (2p + 1)` 个。
3. **构造尾部模式**：
   - 红色方块（`1`）与黄色方块（`0`）交替填充，每次输出 `10`。
   - 最后补一个红色方块（`1`）。
4. **音效与交互**：
   - 填充时播放“滴”声，模式构造时播放“嗒”声。
   - 支持暂停/步进，高亮当前操作位置。

#### **代码片段（JS伪代码）**
```javascript
function animateSolution(n, p) {
    let grid = Array(n).fill(0);
    let step = 0;
    const interval = setInterval(() => {
        if (step < n - 2*p - 1) {
            grid[step] = 0; // 前导零填充
        } else if (step < n - 1) {
            grid[step] = (step - (n - 2*p -1)) % 2 === 0 ? 1 : 0; // 交替填充
        } else {
            grid[step] = 1; // 尾部补1
            clearInterval(interval);
        }
        drawPixelGrid(grid); // 绘制像素网格
        step++;
    }, 200);
}
```

---

### **个人心得摘录**
- **避免过度复杂化**：直接构造固定模式比动态规划更高效。
- **边界条件验证**：样例 `n=5, p=1` 验证填充逻辑的正确性。

---
处理用时：79.65秒
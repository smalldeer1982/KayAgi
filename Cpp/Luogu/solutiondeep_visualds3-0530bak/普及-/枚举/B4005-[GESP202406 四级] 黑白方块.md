# 题目信息

# [GESP202406 四级] 黑白方块

## 题目描述

小杨有一个 $n$ 行 $m$ 列的网格图，其中每个格子要么是白色，要么是黑色。对于网格图中的一个子矩形，小杨认为它是平衡的当且仅当其中黑色格子与白色格子数量相同。小杨想知道最大的平衡子矩形包含了多少个格子。

## 说明/提示

**【样例解释】**

对于样例 $1$，假设 $(i,j)$ 代表第 $i$ 行第 $j$ 列，最大的平衡子矩形的四个顶点分别为 $(1,2),(1,5),(4,2),(4,5)$。

**【数据范围】**

对于全部数据，保证有 $1\leq n,m\leq 10$。

## 样例 #1

### 输入

```
4 5
00000
01111
00011
00011```

### 输出

```
16```

# AI分析结果



---

## 算法分类  
**枚举**

---

## 综合分析与结论  
### 核心思路与难点  
1. **暴力枚举**：题目要求最大平衡子矩形，暴力解法通过四重循环枚举所有可能的子矩形（左上角与右下角坐标）。  
2. **平衡判定**：对每个子矩形遍历统计黑（0）白（1）格子数量是否相等。  
3. **复杂度优化**：直接遍历统计导致 $O(n^6)$ 复杂度，但数据范围极小（$n,m \leq 10$），仍可通过。优化方向是预计算二维前缀和，将统计操作降至 $O(1)$，总复杂度优化至 $O(n^4)$。  

### 可视化设计要点  
1. **网格动态高亮**：在 Canvas 中绘制网格，用不同颜色区分 0/1。当枚举子矩形时，动态高亮其边框。  
2. **实时计数动画**：展示当前子矩形内 0 和 1 的累加过程，用对比色显示计数是否平衡。  
3. **像素风格音效**：  
   - **枚举移动**：播放短促的“滴”声，模拟红白机光标移动。  
   - **平衡触发**：当子矩形满足条件时，播放上扬音效，并闪烁高亮。  
4. **AI 自动演示**：按左上角到右下角的顺序自动枚举，用户可调节速度观察算法流程。  

---

## 题解清单（≥4星）  
### 题解：chen_zhe（⭐⭐⭐⭐）  
- **亮点**：思路直观，代码可读性强；暴力枚举完全覆盖所有可能，适合小数据范围。  
- **改进点**：可通过前缀和优化统计逻辑，但未实现。  

---

## 核心代码实现  
### 关键逻辑片段  
```cpp  
int main() {  
    int n, m;  
    cin >> n >> m;  
    vector<vector<int>> grid(n+1, vector<int>(m+1));  
    for (int i=1; i<=n; ++i) {  
        string s; cin >> s;  
        for (int j=1; j<=m; ++j)  
            grid[i][j] = s[j-1] - '0';  
    }  

    int ans = 0;  
    for (int xa=1; xa<=n; ++xa) {  
        for (int ya=1; ya<=m; ++ya) {  
            for (int xb=xa; xb<=n; ++xb) {  
                for (int yb=ya; yb<=m; ++yb) {  
                    int cnt0 = 0, cnt1 = 0;  
                    for (int i=xa; i<=xb; ++i)  
                        for (int j=ya; j<=yb; ++j)  
                            (grid[i][j] == 0) ? cnt0++ : cnt1++;  
                    if (cnt0 == cnt1)  
                        ans = max(ans, (xb-xa+1)*(yb-ya+1));  
                }  
            }  
        }  
    }  
    cout << ans << endl;  
}  
```  

### 优化版本（前缀和）  
```cpp  
// 预处理前缀和  
vector<vector<int>> pre0(n+1, vector<int>(m+1)), pre1 = pre0;  
for (int i=1; i<=n; ++i) {  
    for (int j=1; j<=m; ++j) {  
        pre0[i][j] = pre0[i-1][j] + pre0[i][j-1] - pre0[i-1][j-1] + (grid[i][j]==0);  
        pre1[i][j] = pre1[i-1][j] + pre1[i][j-1] - pre1[i-1][j-1] + (grid[i][j]==1);  
    }  
}  
// 查询子矩形统计  
int cnt0 = pre0[xb][yb] - pre0[xa-1][yb] - pre0[xb][ya-1] + pre0[xa-1][ya-1];  
int cnt1 = pre1[xb][yb] - pre1[xa-1][yb] - pre1[xb][ya-1] + pre1[xa-1][ya-1];  
```  

---

## 最优思路提炼  
1. **二维前缀和**：预计算每个位置的累计值，快速查询子矩形统计信息。  
2. **四重循环优化**：将统计复杂度从 $O(n^2)$ 降至 $O(1)$，总复杂度优化为 $O(n^4)$。  

---

## 相似题目推荐  
1. **P1719 最大加权矩形**（二维前缀和 + 枚举）  
2. **P3406 海底高铁**（差分数组与前缀和结合）  
3. **P2004 领地选择**（二维前缀和优化极值问题）  

---

## 个人心得摘录  
> “暴力法在数据范围小时往往是可行解，但需时刻思考优化方向。前缀和的引入将统计逻辑从 $O(n^2)$ 优化至 $O(1)$，是二维问题的经典技巧。”  

---

## 可视化与算法演示（核心流程）  
### 动画方案  
1. **网格绘制**：用 8 位像素风格绘制初始网格，黑色（0）为深蓝，白色（1）为浅黄。  
2. **枚举高亮**：红色边框标识当前枚举的子矩形范围，随循环逐步扩展。  
3. **计数动态显示**：右侧面板实时显示当前子矩形的 0 和 1 的数量及是否平衡。  
4. **音效触发**：  
   - **移动音效**：每次右下角坐标变化时播放。  
   - **平衡音效**：当 `cnt0 == cnt1` 时播放胜利音效。  

### 交互控制  
- **速度调节**：滑动条控制枚举速度（100ms~2s）。  
- **单步执行**：点击按钮逐帧观察子矩形扩展过程。  
- **最优路径回放**：演示最终找到的最大子矩形的枚举路径。

---
处理用时：78.55秒
# 题目信息

# [GESP202409 四级] 黑白方块

## 题目描述

小杨有一个 $n$ 行 $m$ 列的网格图，其中每个格子要么是白色，要么是黑色。
小杨想知道网格图中是否存在一个满足如下条件的子矩形：
- 子矩形由 $4$ 行 $4$ 列组成；
- 子矩形的第 $1$ 行和第 $4$ 行只包含白色格子；
- 对于子矩形的第 $2$ 行和第 $3$ 行，只有第 $1$ 个和第 $4$ 个格子是白色的，其余格子都是黑色的；

请你编写程序帮助小杨判断。

## 说明/提示

### 样例 1 解释

```plain
0000
0110
0110
0000
```

### 数据规模与约定

对全部的测试数据，保证 $1 \leq t\leq 10$，$1 \leq n,m \leq 100$。

## 样例 #1

### 输入

```
3
1 4
0110
5 5
00000
01100
01100
00001
01100
5 5
00000
01100
01110
00001
01100```

### 输出

```
No
Yes
No```

# AI分析结果



# 算法分类  
**枚举算法**

---

## 综合分析与结论  
### 核心思路与难点  
题目要求判断是否存在特定结构的 4x4 子矩形。核心思路是：  
1. **预定义目标模板**：将符合条件的 4x4 矩阵模式存储为常量数组。  
2. **枚举所有可能的子矩形左上角**：遍历所有可能的起始坐标，确保子矩形不越界。  
3. **逐元素匹配模板**：对每个子矩形，检查其每个元素是否与模板完全一致。  

**解决难点**：  
- 正确枚举所有合法的子矩形左上角，避免越界。  
- 高效匹配模板，避免冗余判断。  
- 处理输入的行列索引与模板数组的 0-based 和 1-based 差异。  

### 可视化设计思路  
1. **网格绘制**：将原矩阵和当前检查的 4x4 子矩形在 Canvas 上绘制为像素网格。  
2. **颜色标记**：  
   - 当前子矩形边框用黄色高亮。  
   - 匹配成功的格子标记为绿色，失败标记为红色。  
3. **步进动画**：单步展示每个子矩形的匹配过程，高亮当前比较的格子。  
4. **复古音效**：  
   - 每次检查子矩形时播放“滴”声。  
   - 匹配成功时播放上扬音效，失败则播放低音。  

---

## 题解清单 (4星及以上)  
### 题解作者：chen_zhe (4星)  
**关键亮点**：  
- **模板匹配法**：预定义目标结构，代码简洁高效。  
- **边界处理严谨**：通过 `n-3` 和 `m-3` 确保枚举不越界。  
- **直接枚举**：时间复杂度 O(nm)，在数据范围内可行。  

---

## 代码实现与核心逻辑  
### 核心代码  
```cpp  
const char g[4][4] = {  
    '0', '0', '0', '0',  
    '0', '1', '1', '0',  
    '0', '1', '1', '0',  
    '0', '0', '0', '0'  
};  

bool check(int x, int y) {  
    for (int i = 0; i < 4; i++) {  
        for (int j = 0; j < 4; j++) {  
            if (c[i + x][j + y] != g[i][j])  
                return false;  
        }  
    }  
    return true;  
}  

// 枚举所有可能的左上角  
for (int i = 1; i <= n - 3; i++) {  
    for (int j = 1; j <= m - 3; j++) {  
        if (check(i, j)) {  
            flag = true;  
            break;  
        }  
    }  
}  
```  

### 完整代码  
```cpp  
#include <iostream>  
using namespace std;  

const char g[4][4] = {  
    '0', '0', '0', '0',  
    '0', '1', '1', '0',  
    '0', '1', '1', '0',  
    '0', '0', '0', '0'  
};  

char c[105][105];  

bool check(int x, int y) {  
    for (int i = 0; i < 4; i++) {  
        for (int j = 0; j < 4; j++) {  
            if (c[x + i][y + j] != g[i][j])  
                return false;  
        }  
    }  
    return true;  
}  

int main() {  
    int t;  
    cin >> t;  
    while (t--) {  
        int n, m;  
        cin >> n >> m;  
        for (int i = 1; i <= n; i++)  
            cin >> (c[i] + 1);  

        bool flag = false;  
        for (int i = 1; i <= n - 3; i++) {  
            for (int j = 1; j <= m - 3; j++) {  
                if (check(i, j)) {  
                    flag = true;  
                    break;  
                }  
            }  
            if (flag) break;  
        }  
        cout << (flag ? "Yes" : "No") << endl;  
    }  
    return 0;  
}  
```  

---

## 最优技巧提炼  
1. **模板预定义法**：将目标模式存储为常量数组，简化比较逻辑。  
2. **行列范围剪枝**：通过 `n-3` 和 `m-3` 减少无效枚举。  
3. **即时终止优化**：发现匹配后立即跳出循环，避免冗余检查。  

---

## 类似题目推荐  
1. **P1739 表达式括号匹配**：类似的结构匹配问题。  
2. **P1101 单词方阵**：二维矩阵中寻找特定模式。  
3. **P1219 八皇后**：棋盘类枚举问题。  

---

## 可视化设计实现（伪代码）  
```javascript  
// 伪代码示例：Canvas 绘制与动画  
function drawGrid(matrix) {  
    // 绘制原矩阵的像素网格  
}  

function highlightSubmatrix(x, y) {  
    // 高亮当前检查的 4x4 子矩形  
}  

function compareCell(i, j, expected) {  
    // 标记当前比较的格子颜色  
    if (matrix[i][j] === expected)  
        fillStyle = 'green';  
    else  
        fillStyle = 'red';  
}  

// 主循环模拟  
for (let x = 0; x <= n-4; x++) {  
    for (let y = 0; y <= m-4; y++) {  
        highlightSubmatrix(x, y);  
        let match = true;  
        for (let i = 0; i < 4; i++) {  
            for (let j = 0; j < 4; j++) {  
                compareCell(x+i, y+j, g[i][j]);  
                if (!match) break;  
            }  
            if (!match) break;  
        }  
        if (match) playSuccessSound();  
    }  
}  
```  

---

## 复古游戏化设计  
- **像素风格**：使用 8 位调色板（黑、白、红、绿、黄），每个格子为 16x16 像素。  
- **音效触发**：  
  - 检查子矩形时播放 `beep` 音效。  
  - 匹配成功时播放经典 FC 过关音效。  
- **AI 自动演示**：按行优先顺序自动遍历所有可能子矩形，速度可调节。

---
处理用时：133.07秒
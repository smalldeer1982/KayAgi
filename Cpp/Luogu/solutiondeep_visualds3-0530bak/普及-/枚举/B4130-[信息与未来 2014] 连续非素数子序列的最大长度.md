# 题目信息

# [信息与未来 2014] 连续非素数子序列的最大长度

## 题目描述

给出一个正整数 $n$，求在数列 $\{2,3,\cdots,n\}$
中，连续非素数子序列的最大长度。

## 说明/提示

### 样例 $\textbf1$ 解释
| 连续非素数子序列 | 长度 |
| :----------: | :----------: |
| $\{4\}$ | $1$ |
| $\{6\}$ | $1$ |
| $\{8,9,10\}$ | $3$ |
| $\{12\}$ | $1$ |

其中，最大长度为 $3$，即有连续的 $3$ 个非素数。
### 数据范围
$2\le n\le 5\times10^6$。

## 样例 #1

### 输入

```
12```

### 输出

```
3```

## 样例 #2

### 输入

```
30```

### 输出

```
5```

# AI分析结果



**唯一算法分类**：筛法应用

---

**综合分析与结论**  
本题要求找出数列中连续非素数的最大长度，关键在于高效筛出素数并统计最长连续合数段。  
- **核心算法**：  
  1. **埃拉托斯特尼筛法**预处理标记素数，时间复杂度 O(n log log n)。  
  2. **线性扫描**维护当前连续合数长度，更新最大值，时间复杂度 O(n)。  
- **解决难点**：处理大数规模（n ≤5e6）时，需确保筛法的时间与空间效率。  

**可视化设计要点**：  
- **像素动画**：以网格展示每个数的素数标记（绿为素数，红为合数），遍历时高亮当前数，动态更新连续段长度。  
- **音效触发**：遇到合数时播放短音，最长长度刷新时播放胜利音效。  
- **自动演示**：逐步展示筛法标记过程，同步显示当前连续段的增长。  

---

**题解清单（≥4星）**  
1. **埃氏筛法 + 线性扫描（5星）**  
   - 亮点：高效筛法预处理，代码简洁清晰，处理大数无压力。  

---

**代码实现与核心逻辑**  
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<bool> is_prime(n + 1, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i * i <= n; ++i) {
        if (is_prime[i]) {
            for (int j = i * i; j <= n; j += i)
                is_prime[j] = false;
        }
    }

    int max_len = 0, current = 0;
    for (int i = 2; i <= n; ++i) {
        if (is_prime[i]) current = 0;
        else max_len = max(max_len, ++current);
    }
    cout << max_len << endl;
    return 0;
}
```

**核心思想**：  
- **筛法标记素数**：从 2 开始，将每个素数的倍数标记为非素数。  
- **统计最长合数段**：遍历时遇到合数则增加当前连续长度，遇到素数则重置。  

---

**最优技巧提炼**  
1. **筛法优化**：外层循环到 √n 即可，内层从 i² 开始标记，减少重复计算。  
2. **动态统计**：在线性遍历中实时维护当前连续长度，避免二次扫描。  

---

**同类题型推荐**  
1. P3383 【模板】线性筛素数  
2. P1217 [USACO1.5]回文质数  
3. P1835 素数密度  

---

**个人心得**  
- **筛法范围**：外层循环终止条件为 `i*i <=n`，而非到 `n`，避免冗余。  
- **合数统计**：直接遍历 2~n 的所有数，无需单独记录合数列表。  

---

**可视化算法演示**  
- **筛法过程**：展示每个素数标记其倍数的动态过程，颜色区分素数/合数。  
- **连续段扫描**：高亮当前数，右侧面板显示当前连续长度与最大值，音效增强反馈。  
- **像素风格**：16 色复古调色板，背景音乐为 8-bit 风格循环曲目。

---
处理用时：92.96秒
# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果



## 唯一算法分类  
**模拟**

---

## 综合分析与结论  
### 核心算法流程  
1. **存储所有地毯参数**：每个地毯的左上角坐标 $(a,b)$ 及覆盖范围 $(g,k)$，计算右下角坐标 $(a+g, b+k)$。  
2. **遍历判断覆盖性**：  
   - **正序**：遍历所有地毯，若点 $(x,y)$ 在当前地毯范围内，更新答案为当前编号（最终答案为最后一次覆盖的地毯）。  
   - **倒序**：从后往前遍历，第一个覆盖点 $(x,y)$ 的地毯即为答案，可提前终止循环。  

### 解决难点  
- **空间优化**：避免存储二维网格，改用一维数组或结构体记录每个地毯的坐标参数，空间复杂度 $O(n)$。  
- **覆盖判断**：通过边界条件 $a \le x \le a+g$ 和 $b \le y \le b+k$ 快速验证点是否在地毯内。  

### 可视化设计  
- **动画演示**：  
  - **网格绘制**：在 Canvas 中绘制坐标系，标记目标点 $(x,y)$。  
  - **地毯覆盖**：按铺设顺序逐个显示地毯覆盖区域，用不同颜色区分已覆盖/未覆盖。  
  - **倒序检查**：高亮当前遍历的地毯，若覆盖目标点则闪烁提示并停止。  
- **音效交互**：  
  - 检查地毯时播放短暂“点击”音效。  
  - 找到答案时播放“胜利”音效，未找到则播放“失败”音效。  
- **复古风格**：使用 8-bit 像素风格渲染地毯和坐标轴，背景循环播放 FC 风格音乐。  

---

## 题解清单 (≥4星)  
1. **智子（5星）**  
   - 关键亮点：正确使用线性存储，避免 MLE，代码可读性高。  
   - 代码片段：  
     ```cpp  
     for(int i = 0; i < n; i++) {  
         if(x >= a[i] && y >= b[i] && x <= a[i] + g[i] && y <= b[i] + k[i]) {  
             ans = i + 1;  
         }  
     }  
     ```  

2. **kuaiCreator（5星）**  
   - 关键亮点：倒序遍历，提前终止循环，优化平均时间复杂度。  
   - 代码片段：  
     ```cpp  
     for(int i = n; i >= 1; i--) {  
         if(x >= a[i] && x <= a[i] + g[i] && y >= b[i] && y <= b[i] + k[i]) {  
             ans = i; break;  
         }  
     }  
     ```  

3. **Vct14（4星）**  
   - 关键亮点：结构体存储参数，代码结构清晰。  
   - 代码片段：  
     ```cpp  
     struct dt{ int a, b, g, k; };  
     if(x <= a[i] + g[i] && y <= b[i] + k[i]) { ... }  
     ```  

---

## 最优思路与技巧提炼  
1. **倒序检查法**：从最后铺设的地毯开始遍历，找到即终止，减少冗余判断。  
2. **边界预处理**：预先计算右下角坐标 $(a+g, b+k)$，避免循环中重复计算。  
3. **结构体封装**：使用结构体集中存储地毯参数，提升代码可维护性。  

---

## 相似题目推荐  
1. **P1502 窗口的星星**：矩形覆盖与点查询。  
2. **P1886 滑动窗口**：区间覆盖与最值查询。  
3. **P3743 kotori的设备**：动态覆盖与资源分配。  

---

## 核心代码实现  
```cpp  
// 倒序遍历实现（kuaiCreator 题解）  
#include<bits/stdc++.h>  
using namespace std;  
const int N = 1e4 + 5;  
int a[N], b[N], g[N], k[N], n, x, y, ans = -1;  

int main() {  
    cin >> n;  
    for(int i = 1; i <= n; i++) cin >> a[i] >> b[i] >> g[i] >> k[i];  
    cin >> x >> y;  
    for(int i = n; i >= 1; i--) {  
        if(x >= a[i] && x <= a[i] + g[i] && y >= b[i] && y <= b[i] + k[i]) {  
            ans = i; break;  
        }  
    }  
    cout << ans;  
    return 0;  
}  
```  

---

## 个人心得摘录  
- **智子**：二维数组导致 MLE，改用线性存储后 AC，强调空间复杂度意识。  
- **kuaiCreator**：逆序遍历可减少循环次数，体现“逆向思维”优化。  

---

## 可视化与复古演示  
- **Canvas 绘制**：  
  - 初始化网格坐标系，目标点用红色像素标记。  
  - 遍历时，当前地毯用绿色边框显示，覆盖点则填充黄色。  
- **音效触发**：  
  - 遍历时播放 `beep` 音效，找到答案时播放 `win.wav`。  
- **自动演示**：  
  - 按空格键切换正序/倒序模式，观察遍历效率差异。

---
处理用时：112.83秒
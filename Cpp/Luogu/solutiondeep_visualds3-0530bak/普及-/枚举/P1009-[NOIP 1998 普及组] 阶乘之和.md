# 题目信息

# [NOIP 1998 普及组] 阶乘之和

## 题目描述

用高精度计算出 $S = 1! + 2! + 3! + \cdots + n!$（$n \le 50$）。

其中 `!` 表示阶乘，定义为 $n!=n\times (n-1)\times (n-2)\times \cdots \times 1$。例如，$5! = 5 \times 4 \times 3 \times 2 \times 1=120$。

## 说明/提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le 50$。

**【其他说明】**

注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \le 20$，使用书中的代码无法通过本题。

如果希望通过本题，请继续学习第八章高精度的知识。

NOIP1998 普及组 第二题

## 样例 #1

### 输入

```
3
```

### 输出

```
9```

# AI分析结果



### 算法分类
高精度运算

---

### 题解思路与算法要点
#### 核心逻辑
1. **复用阶乘结果**：利用 `i! = (i-1)! * i` 的递推特性，避免重复计算
2. **双高精度操作**：
   - **乘法**：低精度数（当前阶乘数i）与高精度数组逐位相乘，处理进位
   - **加法**：将当前阶乘结果累加到总和数组中，处理进位
3. **存储优化**：使用数组倒序存储数字（个位在数组前端），便于进位操作

#### 解决难点
- **乘法进位处理**：乘积可能超过单字节能表示范围，需分解为 `当前位%10` 和 `进位值/10`
- **累加顺序控制**：在计算阶乘后立刻累加，避免存储全部阶乘结果
- **前导零处理**：倒序输出时跳过数组末尾的无意义零

---

### 题解评分（≥4星）
1. **wuhao1027（★★★★☆）**
   - 亮点：同步更新阶乘和总和数组，空间效率最优
   - 代码片段：
```cpp
for(int i=2;i<=n;i++){
    // 计算i! = (i-1)! * i
    for(j=0;j<100;j++) B[j] *= i; 
    for(j=0;j<100;j++){ // 处理乘法进位
        B[j+1] += B[j]/10;
        B[j] %= 10;
    }
    // 累加到总和
    for(j=0;j<100;j++){
        A[j] += B[j];
        A[j+1] += A[j]/10;
        A[j] %= 10;
    }
}
```

2. **C_Z_C（★★★★☆）**
   - 亮点：独立维护阶乘数组和总和数组，逻辑清晰
   - 关键步骤：
```cpp
for(int j=0;j<len_a;j++)
    for(int k=0;k<=len_b;k++)
        c[j+k] += a[j] * b[k]; // 乘法核心
for(int j=0;j<len_c;j++) // 进位处理
    if(c[j]>9) c[j+1] += c[j]/10, c[j] %=10;
```

3. **吃葡萄吐糖（★★★★☆）**
   - 亮点：二维数组存储所有阶乘结果，便于调试理解
   - 数据结构：
```c
int bor[52][10000]; // bor[i]存储i!的各位数字
for(int i=2;i<=n;i++){
    for(int r=1;r<=bor[i-1][0];r++)
        bor[i][r] = bor[i-1][r] * i; // 递推计算阶乘
}
```

---

### 最优思路提炼
1. **递推式阶乘计算**  
   `i! = (i-1)! * i` 减少重复计算量，时间复杂度从 O(n²) 降为 O(n)

2. **同步进位机制**  
   在乘法和加法操作中实时处理进位，避免后续额外循环

3. **倒序存储优化**  
   数组索引0存储个位，索引递增对应十位、百位，天然符合竖式计算方向

---

### 同类题型推荐
1. P1005 [NOIP1998] 高精度求积
2. P1255 数楼梯（斐波那契数列高精度版）
3. P1601 A+B Problem（高精）

---

### 可视化算法演示
**动画方案设计**  
1. **像素化数字阵列**  
   - 用16x16像素块表示每个数字位
   - 红色高亮当前操作的数组位置（乘法时的被乘位，加法时的累加位）
   
2. **进位流动效果**  
   - 黄色箭头表示进位方向
   - 每次进位时播放8-bit "blip" 音效（[JSFiddle示例](https://jsfiddle.net/7s2xoL5q/)）

3. **分步控制面板**  
   ```html
   <div id="controls">
     <button onclick="step()">单步执行</button>
     <input type="range" id="speed" min="100" max="1000">
   </div>
   ```
   
4. **复古风格展示**  
   ```javascript
   function drawPixelNumber(ctx, num, x, y) {
       const colors = ["#000000", "#FF0000", "#00FF00", "#0000FF"]; // 8-bit调色板
       ctx.fillStyle = colors[Math.floor(Math.random()*4)]; // 随机像素抖动效果
       ctx.fillRect(x*16, y*16, 16, 16); // 绘制数字位
   }
   ```

---

### 核心代码实现
**高效递推版本**（基于wuhao1027优化）
```cpp
int A[1005] = {0}, B[1005] = {0}; // A存储总和，B存储当前阶乘
int main() {
    int n; cin >> n;
    B[0] = 1; // 初始化0! = 1
    for(int i=1; i<=n; i++) {
        // 计算i! = B * i
        int carry_mul = 0;
        for(int j=0; j<100; j++) {
            B[j] = B[j] * i + carry_mul;
            carry_mul = B[j] / 10;
            B[j] %= 10;
        }
        // 累加到总和A
        int carry_add = 0;
        for(int j=0; j<100; j++) {
            A[j] += B[j] + carry_add;
            carry_add = A[j] / 10;
            A[j] %= 10;
        }
    }
    // 输出结果
    int pos = 100;
    while(pos > 0 && A[pos] == 0) pos--;
    for(; pos >=0; pos--) cout << A[pos];
}
```

该实现的时间复杂度为 O(n²)，空间复杂度 O(1)，是此类问题的经典解法。通过同步处理乘法和加法的进位，达到最优效率。

---
处理用时：81.18秒
# 题目信息

# 波浪数

## 题目描述

波浪数是在一对**不同**数字之间交替转换的数，如 $1212121$，双重波浪数则是指在两种进制下都是波浪数的数，如十进制数 $191919$ 是一个十进制下的波浪数，它对应的十一进制数 $121212$ 也是一个波浪数，所以十进制数 $191919$ 是一个双重波浪数。特别地，只有一位的数也算作波浪数，例如 $1$。

类似的可以定义三重波浪数，三重波浪数在三种不同的进制中都是波浪数，甚至还有四重波浪数，如 $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\mathtt{A}1_{(13)}$，下标表示采用的进制。你的任务就是在指定范围内找出双重、三重、四重波浪数。


## 说明/提示

### 数据范围及约定

对于全部数据，保证 $2\le l\le r\le 32$，$1\le L\le R\le 10^7$，$k\in \{2, 3, 4\}$。

## 样例 #1

### 输入

```
10 11 190000 960000 2```

### 输出

```
191919
383838
575757
767676
959595```

# AI分析结果



---

## **算法分类**
**构造法**

---

## **题解思路与核心难点**

### **思路概述**
所有高效题解均采用**逆向构造法**，而非暴力枚举每个数是否满足多进制波浪数条件。核心步骤：  
1. **枚举进制范围**（a到b进制）。  
2. **生成波浪数**：对每个进制k，枚举交替数字对(i,j)（i≠j），按交替顺序构造波浪数。  
3. **统计重数**：将生成的十进制数记录到数组，统计其被多少进制生成过。  
4. **筛选输出**：根据要求的重数k，输出符合条件的数。

### **解决难点**
1. **高效生成波浪数**：直接构造避免了逐个检查每个数，复杂度从O(R×进制数)降为O(进制数×数字对×生成长度)。  
2. **避免重复与越界**：每次生成时检查是否超过R，并确保交替数字不同。  
3. **处理一位数**：生成过程中自然包含单个数字（如i或j单独出现的情况）。

---

## **题解评分（≥4星）**

1. **Crazily（5星）**  
   - **亮点**：代码简洁，逻辑清晰，通过交替添加数字生成波浪数，高效利用数组计数。  
   - **优化**：直接生成十进制数，无需额外进制转换。

2. **Skywalker_David（4星）**  
   - **亮点**：预判波浪数长度范围，进一步减少无效生成。  
   - **特色**：分离生成函数，代码结构更模块化。

3. **Y_BY（4星）**  
   - **亮点**：处理奇数长度波浪数，确保生成完整性。  
   - **缺点**：幂运算可能引入浮点误差，需类型转换。

---

## **最优思路提炼**

1. **交替构造法**  
   - **核心逻辑**：对每个进制k，枚举数字对(i,j)，循环交替生成波浪数。  
   - **代码片段**：  
     ```cpp
     for(int k=a; k<=b; k++){
         for(int i=1; i<k; i++){
             for(int j=0; j<k; j++){
                 if(i != j){
                     int x=0, t=0;
                     while(x <= r){
                         x = x*k + (t%2 ? j : i);
                         t++;
                         if(x>=l && x<=r) v[x]++;
                     }
                 }
             }
         }
     }
     ```

2. **直接十进制转换**  
   - **优势**：生成过程中直接计算十进制值，无需后续转换。

---

## **同类题目推荐**
1. **P1217 [USACO1.5]回文质数**  
   - 构造回文数并判断质数，类似逆向生成思路。

2. **P1068 分数线划定**  
   - 统计分数出现次数，利用桶数组计数。

3. **P3383 【模板】线性筛素数**  
   - 通过筛法构造素数，避免逐个判断。

---

## **可视化设计（复古像素风格）**

### **动画方案**
1. **进制选择面板**：左侧显示当前进制k（像素字体，8位风格）。  
2. **数字对交替生成**：右侧Canvas绘制波浪数构造过程，高亮当前添加的i/j（红色/蓝色像素块）。  
3. **十进制数显示**：下方动态显示生成的十进制值，超出R时闪烁提示。  
4. **音效**：  
   - **生成成功**：短促“哔”声（8位音效）。  
   - **超出范围**：低沉“嘟”声。

### **交互功能**
- **步进控制**：按空格单步执行生成，Enter自动播放。  
- **速度调节**：方向键调整生成速度（快/中/慢）。  

---

## **核心代码实现**
```cpp
#include<bits/stdc++.h>
using namespace std;
int v[10000005]; // 记录重数

int main() {
    int a, b, l, r, k;
    cin >> a >> b >> l >> r >> k;
    for (int base = a; base <= b; base++) {
        for (int i = 1; i < base; i++) { // 首位非0
            for (int j = 0; j < base; j++) {
                if (i == j) continue;
                int num = 0, step = 0;
                while (true) {
                    num = num * base + (step % 2 ? j : i);
                    if (num > r) break;
                    if (num >= l) v[num]++;
                    step++;
                }
            }
        }
    }
    for (int i = l; i <= r; i++) {
        if (v[i] == k) cout << i << endl;
    }
    return 0;
}
```

---

## **总结**
通过逆向生成波浪数，显著降低时间复杂度至O(进制数×数字对×生成次数)。关键点在于交替构造与桶数组统计，避免暴力枚举的高开销。

---
处理用时：79.65秒
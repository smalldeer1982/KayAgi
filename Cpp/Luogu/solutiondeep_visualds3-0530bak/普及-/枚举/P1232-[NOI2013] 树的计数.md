# 题目信息

# [NOI2013] 树的计数

## 题目描述

我们知道一棵有根树可以进行深度优先遍历（DFS）以及广度优先遍历（BFS）来生成这棵树的 DFS 序以及 BFS 序。两棵不同的树的 DFS 序有可能相同，并且它们的 BFS 序也有可能相同，例如下面两棵树的 DFS 序都是 `1 2 4 5 3`，BFS 序都是 `1 2 3 4 5`。

![](https://cdn.luogu.com.cn/upload/image_hosting/kagmha60.png)

现给定一个 DFS 序和 BFS 序，我们想要知道，符合条件的有根树中，树的高度的平均值。即，假如共有 $K$ 棵不同的有根树具有这组 DFS 序和 BFS 序，且他们的高度分别是 $h_1, h_2, \ldots, h_K$，那么请你输出：

$$
\frac{h_1+h_2+\ldots+h_K}K
$$

## 说明/提示

如果输出文件的答案与标准输出的差不超过 $0.001$，则将获得该测试点上的分数，否则不得分。

### 数据范围

- 对于 $20\%$ 的测试数据，满足：$n \le 10$；
- 对于 $40\%$ 的测试数据，满足：$n \le 100$；
- 对于 $85\%$ 的测试数据，满足：$n \le 2 \times 10^3$；
- 对于 $100\%$ 的测试数据，满足：$2 \le n \le 2 \times 10^5$。

## 样例 #1

### 输入

```
5 
1 2 4 5 3 
1 2 3 4 5
```

### 输出

```
3.500
```

# AI分析结果



### 唯一算法分类
树的遍历序性质分析 + 期望线性性

---

### 综合分析与结论

**核心思路**  
将树的高度转化为 BFS 序的分段数，利用 DFS 和 BFS 序的相互约束确定分段条件。通过期望线性性，将问题拆解为每个位置是否分段的概率求和。

**关键步骤与难点**  
1. **重新标号**：将 BFS 序重标为 1~n，DFS 序相应调整，便于统一分析。
2. **必须分层条件**：
   - BFS 连续但 DFS 逆序（如 BFS 序中 i 的 DFS 序 > i+1 的 DFS 序）。
3. **禁止分层条件**：
   - DFS 连续的节点在 BFS 序中跨度较大时，中间区域最多分一层，需用差分数组标记。
4. **期望计算**：未被约束的位置贡献 0.5，强制分层贡献 1，其余不贡献。

**可视化设计思路**  
- **动画效果**：将 BFS 序展示为一行节点，动态标记必须分层的断点（红色），被禁止分层的区间（灰色覆盖），可自由分层的断点（黄色闪烁）。
- **步进控制**：按 BFS 顺序逐个节点分析，展示当前判断的分段条件和差分数组变化。
- **像素风格**：用 8-bit 风格网格表示 BFS 序，分段时播放“分层音效”，自由分层处显示概率 0.5 的浮动像素文字。

---

### 题解评分（≥4星）

1. **一只绝帆（5星）**  
   - 推导严谨，从期望拆解到约束条件分析透彻，代码简洁高效。
   - 关键亮点：将树高转化为分段期望，并用差分处理区间约束。

2. **javalyc（4.5星）**  
   - 图文结合清晰，代码注释详细，适合快速理解。
   - 关键亮点：用反数组简化标号转换，差分数组实现区间标记。

3. **香风智乃（4星）**  
   - 代码极简但逻辑完整，适合竞赛快速编码。
   - 关键亮点：直接通过两次遍历处理条件，省去冗余步骤。

---

### 最优思路与代码实现

**核心代码片段**  
```cpp
int n, d[N], b[N], sum[N];
double ans = 1; // 初始分层为根节点
// 输入处理与标号转换
for(int i=1; i<=n; i++) d[read()] = i;
for(int i=1; i<=n; i++) b[read()] = i;
for(int i=1; i<=n; i++) pos[d[i]] = i; // pos为新DFS序
// 处理必须分层和禁止区间
for(int i=1; i<n; i++) {
    if(pos[i] > pos[i+1]) { // BFS连续但DFS逆序
        ans += 1;
        mark(i, i); // 差分标记强制分层
    }
    if(b[i]+1 < b[i+1]) // DFS连续但BFS跨度大
        mark(b[i], b[i+1]-1); // 标记禁止分层区间
}
// 统计贡献
int cnt = 0;
for(int i=1; i<n; i++) {
    cnt += sum[i];
    ans += (cnt ? 0 : 0.5);
}
printf("%.3lf", ans + 1); // 分层数+1为高度
```

**实现要点**  
- `mark(l, r)` 函数通过差分数组 `sum` 快速标记区间。
- 遍历时 `cnt` 累加差分前缀和，判断是否被约束。

---

### 相似题目推荐

1. **P1030 求先序排列**（树的遍历序转换）
2. **P1229 遍历问题**（利用遍历序确定树结构）
3. **P3884 二叉树问题**（基于遍历序的深度计算）

---

### 复古游戏化动画设计

**像素风格**  
- **颜色方案**：绿色节点（未处理），红色断点（必须分层），灰色区块（禁止分层），黄色问号（自由分层）。
- **音效**：分层时播放 8-bit "哔"声，自由分层处播放金币音效。

**自动演示逻辑**  
1. 按 BFS 序逐个节点右移光标，显示当前判断条件。
2. 遇到必须分层时，播放爆炸动画标记红色断点。
3. 禁止分层区间用灰色覆盖，显示锁图标。
4. 自由分层位置显示旋转的 0.5 像素文字。

**交互控制**  
- 方向键控制播放速度，空格暂停/继续。
- 按 A 键切换自动演示与手动步进模式。

---

### 总结

通过分析遍历序的相互约束，将问题转化为分段期望的统计。差分数组的高效使用和条件推导是解题关键，适合通过动态可视化加深理解。

---
处理用时：81.00秒
# 题目信息

# [HAOI2012] 音量调节

## 题目描述

一个吉他手准备参加一场演出。他不喜欢在演出时始终使用同一个音量，所以他决定每一首歌之前他都需要改变一次音量。在演出开始之前，他已经做好一个列表，里面写着每首歌开始之前他想要改变的音量是多少。每一次改变音量，他可以选择调高也可以调低。

音量用一个整数描述。输入文件中整数 $beginLevel$，代表吉他刚开始的音量，整数 $maxLevel$，代表吉他的最大音量。音量不能小于 $0$ 也不能大于 $maxLevel$。输入中还给定了 $n$ 个整数 $c_1,c_2,c_3,\cdots,c_n$，表示在第 $i$ 首歌开始之前吉他手想要改变的音量是多少。

吉他手想以最大的音量演奏最后一首歌，你的任务是找到这个最大音量是多少。

## 说明/提示

$1\le n\le 50$，$1\le c_i\le beginLevel$，$1\le maxLevel\le 1000$，$0\le beginLevel\le maxLevel$。

## 样例 #1

### 输入

```
3 5 10
5 3 7
```

### 输出

```
10```

# AI分析结果



**唯一算法分类**  
动态规划/可达性背包问题

---

### **题解思路、算法要点与解决难点**

**核心思路**  
各题解均采用动态规划，定义 `f[i][j]` 表示处理完前 `i` 首歌后，音量 `j` 是否可达。初始状态 `f[0][beginLevel] = 1`，状态转移时分别考虑调高或调低音量，并保证不越界。最终倒序查找 `f[n][j]` 的最大可达值。

**关键实现差异与优化**  
1. **循环方向与空间优化**  
   - 多数题解（如 `jackyzhu`、`Sleepy_Piggy`）直接使用二维数组，空间复杂度为 `O(n*maxLevel)`。  
   - `寒冰大大` 使用滚动数组优化空间至 `O(maxLevel)`。  
   - `Kaizyn` 的题解利用 `bitset` 压缩状态，通过位运算加速转移。  
2. **状态转移逻辑**  
   - 主要分两种写法：正向枚举 `j` 更新 `j±c[i]`（如 `Sleepy_Piggy`），或反向枚举 `j` 判断前驱状态（如 `jackyzhu`）。后者更符合背包问题模板。  
3. **边界处理**  
   - 部分题解（如 `faker121`）显式处理 `j±c[i]` 的合法性；其他题解通过循环范围隐式处理。

**解决难点**  
- **状态爆炸风险**：`maxLevel` 最大为 1000，直接枚举所有可能的音量值在时间和空间上可行。  
- **倒序查找优化**：通过从 `maxLevel` 倒序遍历，找到第一个可达值即为最优解，避免全量遍历。

---

### **题解评分 (≥4星)**  
1. **Sleepy_Piggy（5星）**  
   - **亮点**：变量命名清晰（`st`、`maxn`），代码简洁，显式处理调高/调低的合法性。  
   - **代码可读性**：高，适合教学。  
2. **attack（5星）**  
   - **亮点**：代码极简（仅 20 行），去冗余判断，直接倒序查找。  
   - **实践性**：适合竞赛快速编码。  
3. **Kaizyn（4星）**  
   - **亮点**：利用 `bitset` 优化空间和计算效率，提供新颖解法。  
   - **适用场景**：适用于 `maxLevel` 较大的情况，但代码理解门槛较高。

---

### **最优思路或技巧提炼**  
1. **动态规划状态设计**  
   - 使用布尔数组记录可达性，避免记录具体路径，降低复杂度。  
2. **倒序状态转移**  
   - 反向枚举音量值（如从 `maxLevel` 到 `0`），避免重复更新干扰。  
3. **滚动数组优化**  
   - 仅保留当前层和前一层状态，空间复杂度从 `O(n*maxLevel)` 降至 `O(maxLevel)`。  
4. **位运算加速（bitset）**  
   - 将音量可达性压缩为位标记，通过左移/右移快速计算调高/调低后的状态。

---

### **同类型题或类似算法套路**  
1. **可达性背包问题**：如能否用硬币组成特定金额（[P2347 砝码称重](https://www.luogu.com.cn/problem/P2347)）。  
2. **状态转移限制**：如跳跃游戏（[P1095 守望者的逃离](https://www.luogu.com.cn/problem/P1095)）。  
3. **位运算优化**：如子集和问题的 `bitset` 解法（[P2699 小浩的幂集](https://www.luogu.com.cn/problem/P2699)）。

---

### **推荐相似题目**  
1. **P2347 砝码称重**：可达性背包问题的经典变种。  
2. **P1048 采药**：标准 01 背包问题，可对比状态设计差异。  
3. **P1095 守望者的逃离**：动态规划结合时间与状态限制。

---

### **个人心得摘录**  
- **HighPerformanceRobot**：BFS 因状态数过多导致 TLE，验证了动态规划在此类问题的绝对优势。  
- **Kaizyn**：`bitset` 解法启发自砝码称重问题，体现算法迁移能力。  
- **寒冰大大**：滚动数组的异或交换变量技巧（`u^=r^=u^=r`），提升代码紧凑性。

---

### **可视化与算法演示**  
**核心算法过程动画方案**  
1. **动态表格展示**  
   - **Canvas 绘制**：网格行表示歌曲序号，列表示音量值（0~maxLevel），格子颜色标记可达性（绿色可达，红色不可达）。  
   - **步进控制**：用户可逐歌曲查看状态转移，高亮当前操作的音量值 `j` 和转移方向（`j±c[i]`）。  
2. **像素风格设计**  
   - **调色板**：8位风格，使用复古绿/红（#00FF00/#FF0000）表示可达性。  
   - **音效**：  
     - **转移成功**：短促“哔”声（8-bit 上升音调）。  
     - **无解**：低沉“嗡”声。  
3. **自动演示模式**  
   - **AI 控制**：自动播放算法流程，类似贪吃蛇移动，每步延迟可调（100ms~1s）。  
   - **交互面板**：包含播放/暂停、重置、速度滑动条。

**代码片段（JS 伪代码）**  
```javascript
// Canvas 初始化与绘制
const grid = new Grid(n, maxLevel);
grid.init(beginLevel);

for (let i = 1; i <= n; i++) {
  grid.highlightCurrentSong(i);
  for (let j = maxLevel; j >= 0; j--) {
    if (grid.isReachable(i-1, j)) {
      if (j + c[i] <= maxLevel) {
        grid.markReachable(i, j + c[i], 'green');
        playSound('beep_up');
      }
      if (j - c[i] >= 0) {
        grid.markReachable(i, j - c[i], 'green');
        playSound('beep_down');
      }
    }
  }
  grid.clearPrevLayer(i-1);
}
```

---

### **代码实现（最优题解）**  
**Sleepy_Piggy 的代码（简洁清晰）**  
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int n,st,maxn,a[1001],f[1001][1001];
int main(){
    scanf("%d%d%d",&n,&st,&maxn);
    memset(f,0,sizeof(f));
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    f[0][st]=1;
    for(int i=1;i<=n;i++){
        for(int j=0;j<=maxn;j++){
            if(f[i-1][j]&&j+a[i]<=maxn) f[i][j+a[i]]=1;
            if(f[i-1][j]&&j-a[i]>=0) f[i][j-a[i]]=1;
        }
    }
    for(int i=maxn;i>=0;i--){
        if(f[n][i]){ printf("%d\n",i); return 0; }
    }
    puts("-1");
}
```

---
处理用时：95.37秒
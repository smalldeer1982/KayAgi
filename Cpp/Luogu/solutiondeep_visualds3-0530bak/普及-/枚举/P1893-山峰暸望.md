# 题目信息

# 山峰暸望

## 题目描述

一天，Bessie 在眺望美丽的威斯康星的群山的时候，她突然产生了疑问：哪座山是最宽的？

她决定在地平线上，利用她的新式大量程山峰高度测量仪依次做 $N$（$1 \le N \le 10,000$）次高度测量，每次的高度值为 $H_i$（$1 \le H_i \le 1,000,000,000$）。

一座山定义为一段连续的高度序列，序列中的高度一开始单调上升（或者不变），然后单调下降（或者不变）。举例来说，$2, 3, 3, 5, 4, 4, 1$ 这一段高度序列就是一座山。如果在她的视线范围内有一段单调上升或者单调下降的序列，也算是一座山。注意，两座山之间可能会有部分重叠。

山的宽度定义为在这个山上进行的测量的次数（也就是序列的长度）。例如序列 $2, 3, 3, 5, 4, 4, 1$ 的宽度为 $7$。

请帮 Bessie 找到最宽的山。

下图是一个比较典型的的例子：

```plain
           *******                   *                                
          *********                  ***                               
          **********                *****                              
          ***********            *********               *             
*      *****************       ***********             *** *          
**    *******************     *************   * *     *******      *  
**********************************************************************  山的形状
3211112333677777776543332111112344456765432111212111112343232111111211  高度值
aaaaa                    ccccccccccccccccccccc eeeeeee ggggggggg
  bbbbbbbbbbbbbbbbbbbbbbbbbbbb             ddddd          ffffffffff  
                                                             hhhhhhhhh  山的编号
```

山标记为 `a`、`b` 等等。显然，山 `b` 有着最大的宽度，宽度为 $28$。


## 说明/提示

**【样例说明】**

在最宽的山处测量到的高度为 $2, 3, 5, 4, 1$。其他的山包括 $3, 2$ 和 $1, 6$。

---

**【提示】**

如果你知道一座山的最高的部分（也就是山峰），你会发现，找到这座山的宽度是很容易的哦。

## 样例 #1

### 输入

```
7
3
2
3
5
4
1
6
```

### 输出

```
5
```

# AI分析结果



# 山峰暸望题解分析

## 唯一算法分类
动态规划

---

## 综合分析与结论

### 核心思路
通过预处理每个点左右两侧的最长非递减区间长度，合并计算以该点为峰顶的最大山宽。具体实现：
1. **fup[i]** 记录从左侧开始到i的最长非递减序列长度
2. **fdown[i]** 记录从i开始到右侧的最长非递减序列长度
3. 最终答案取所有点fup[i]+fdown[i]-1的最大值

### 关键难点对比
| 方法类型       | 时间复杂度 | 空间复杂度 | 适用场景         |
|----------------|------------|------------|------------------|
| 暴力枚举       | O(n²)      | O(n)       | 数据量较小(n≤1e4)|
| 动态规划预处理 | O(n)       | O(n)       | 大数据量(n≤1e6)  |

### 可视化设计
1. **动态规划数组渲染**：用双色条形图分别展示fup（左蓝）和fdown（右绿）数组
2. **峰值高亮**：用红色标记当前计算的峰值点，黄色标记历史最大值
3. **实时合并计算**：在遍历过程中动态显示fup[i]+fdown[i]-1的数值变化
```javascript
// 伪代码示例
canvas.drawBar(fup, 0x0000FF); // 蓝色表示左侧延伸
canvas.drawBar(fdown, 0x00FF00); // 绿色表示右侧延伸
canvas.highlightPoint(i, 0xFF0000); // 红色标记当前峰顶
```

---

## ≥4星题解清单

### 1. 万弘（5星）
- **核心亮点**：首创双动态规划预处理，将时间复杂度优化至O(n)
- **代码亮点**：干净的状态转移方程，边界处理清晰
```cpp
for(ll i=2;i<=n;++i) 
    h[i]>=h[i-1] ? fup[i]=fup[i-1]+1 : fup[i]=1;
for(ll i=n-1;i>=1;--i)
    h[i]>=h[i+1] ? fdown[i]=fdown[i+1]+1 : fdown[i]=1;
```

### 2. lych（4星）
- **核心亮点**：独立推导出与万弘相同的DP解法，包含中文注释
- **特别价值**：Pascal实现版本验证了算法的跨语言通用性

### 3. AFOier（4星）
- **实用价值**：代码最简洁的暴力实现，适合快速验证思路
- **优化启示**：通过剪枝跳跃指针提升实际运行效率
```cpp
while(a[l-1]<=a[l]&&l>1)l--; // 向左扩展
while(a[r+1]<=a[r]&&r<n)r++; // 向右扩展
```

---

## 最优技巧提炼

### 关键数据结构
双辅助数组并行预处理：
```math
\begin{cases} 
fup[i] = \begin{cases}
fup[i-1]+1 & h[i] \geq h[i-1] \\
1 & \text{otherwise}
\end{cases} \\
fdown[i] = \begin{cases} 
fdown[i+1]+1 & h[i] \geq h[i+1] \\
1 & \text{otherwise}
\end{cases}
\end{cases}
```

### 思维突破点
1. **峰顶分离**：将山的左右坡解耦处理，避免同时考虑双向条件
2. **逆向遍历**：fdown数组需要从右向左计算，打破常规思维定式

---

## 相似题目推荐
1. **P1091 合唱队形** - 同款双动态规划结构
2. **P1317 低洼地** - 相邻元素关系判断
3. **P2947 向右看齐** - 单调栈处理元素关系

---

## 可视化实现方案

### 复古像素化设计
1. **8位风格调色板**：
   - 山脉：深灰色(#333333) 
   - 当前峰：亮红色(#FF0033)
   - DP延伸：渐变蓝绿(#00FFFF → #00CC00)

2. **音效系统**：
```javascript
const audioCtx = new AudioContext();
function playTone(freq, duration) {
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + duration*0.001);
}
// 关键操作提示音
playTone(523.25, 100); // C5音，左扩展
playTone(659.25, 100); // E5音，右扩展
```

3. **自动演示模式**：
```javascript
let autoPlay = setInterval(() => {
    highlightNextPeak();
    renderDPBars();
}, 1000);
```

---

## 核心代码实现
万弘解法完整代码：
```cpp
#include<iostream>
typedef long long ll;
ll fup[100001],fdown[100001],h[100001],n;

int main() {
    scanf("%lld",&n);
    for(ll i=1;i<=n;++i) scanf("%lld",&h[i]);
    
    fup[1] = 1;
    for(ll i=2;i<=n;++i) 
        h[i]>=h[i-1] ? fup[i]=fup[i-1]+1 : fup[i]=1;
        
    fdown[n] = 1;
    for(ll i=n-1;i>=1;--i)
        h[i]>=h[i+1] ? fdown[i]=fdown[i+1]+1 : fdown[i]=1;
        
    ll ans=0;
    for(ll i=1;i<=n;++i)
        ans = std::max(ans, fup[i]+fdown[i]-1);
        
    printf("%lld",ans);
    return 0;
}
```

---
处理用时：67.63秒
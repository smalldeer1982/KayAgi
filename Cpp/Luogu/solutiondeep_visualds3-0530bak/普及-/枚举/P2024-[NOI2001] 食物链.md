# 题目信息

# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# AI分析结果



### 算法分类
**并查集（扩展域/带权并查集）**

---

### 题解思路与核心难点
#### 核心思路
1. **扩展域并查集**  
   - 将每个动物分为3个逻辑域：同类域、猎物域、天敌域（如题解中 `Sooke` 的解法）  
   - 合并时需在三个域中分别维护关系，如 `x` 与 `y` 同类时合并 `x_A-y_A`、`x_B-y_B`、`x_C-y_C`  
   - 假话判断：检查是否在冲突的域中存在关联（如 `x_A` 与 `y_B` 已合并则说明矛盾）

2. **带权并查集**  
   - 用权值模3表示关系（0=同类，1=被父节点吃，2=吃父节点，如 `天泽龟` 的解法）  
   - 路径压缩时递归更新权值：`d[x] = (d[x] + d[父节点]) %3`  
   - 合并时通过权值差推导新关系（如 `d[fx] = (d[y] - d[x] +3) %3`）

#### 解决难点
- **关系闭环推导**：A吃B、B吃C时需推导出C吃A（模3运算天然支持环形关系）  
- **动态合并验证**：在合并前需检查是否与已有关系冲突（如带权并查集中的 `(d[x]-d[y]+3)%3 != 关系类型`）  
- **路径压缩优化**：带权并查集需在压缩时同步更新权值，确保后续查询的正确性

---

### 题解评分（≥4星）
| 作者           | 亮点与评分（★） | 关键亮点摘要                                                                 |
|----------------|-----------------|------------------------------------------------------------------------------|
| Sooke          | ★★★★★           | 扩展域思路清晰，配图说明环形关系，代码可读性强                               |
| 檀黎斗·神       | ★★★★☆           | 三域合并逻辑简洁，50行代码实现核心逻辑                                      |
| 天泽龟          | ★★★★☆           | 带权并查集推导严谨，数学证明与打表验证结合                                  |

---

### 最优思路提炼
1. **扩展域核心技巧**  
   ```cpp
   // 合并x与y为同类
   fa[find(x)] = find(y); 
   fa[find(x+n)] = find(y+n); // 猎物域合并
   fa[find(x+2n)] = find(y+2n); // 天敌域合并
   ```
   - 假话判断：若 `find(x) == find(y+n)` 说明 `x` 是 `y` 的猎物，与同类声明矛盾

2. **带权并查集关键公式**  
   ```cpp
   // 路径压缩时权值更新
   d[x] = (d[x] + d[父节点]) %3;

   // 合并时关系推导（x吃y）
   d[fx] = (d[y] - d[x] +4) %3; // +4保证非负
   ```

---

### 同类型题与算法套路
1. **关押罪犯（P1525）**：用扩展域处理敌人的敌人是朋友  
2. **银河英雄传说（P1196）**：带权并查集维护队列长度  
3. **程序自动分析（P1955）**：离散化+并查集处理等式/不等式约束

---

### 推荐相似题目
1. **P1525 关押罪犯**  
2. **P1892 团伙**  
3. **P4185 离线询问（MEX问题）**

---

### 可视化设计（带权并查集版）
#### 动画方案
1. **数据结构展示**  
   - **节点树**：以树状图展示并查集结构，边权标记 `0/1/2`  
   - **权值面板**：实时显示每个节点的 `d[x]` 值

2. **关键操作高亮**  
   - **路径压缩**：被访问节点渐变为黄色，权值更新时闪烁红色  
   - **合并操作**：连接线动态绘制，权值差公式悬浮显示

3. **音效与反馈**  
   - **正确合并**：播放“叮”声，节点边框变绿  
   - **检测到假话**：播放“哔”声，背景短暂变红

#### 复古像素风格
- **8位调色板**：用青（同类）、红（猎物）、蓝（天敌）区分关系  
- **Canvas网格**：每个节点用16x16像素方块表示，合并时显示箭头动画  

---

### 代码片段（带权并查集核心）
```cpp
int find(int x) {
    if (fa[x] != x) {
        int root = find(fa[x]);
        d[x] = (d[x] + d[fa[x]]) %3; // 路径压缩时更新权值
        fa[x] = root;
    }
    return fa[x];
}

// 合并x与y为x吃y的关系
void unite(int x, int y) {
    int fx = find(x), fy = find(y);
    if (fx == fy) return;
    fa[fx] = fy;
    d[fx] = (d[y] - d[x] +4) %3; // +4保证非负数
}
```

---

### 总结
食物链问题通过并查集的扩展域或带权设计，巧妙解决了环形关系维护的难题。扩展域直观但占用空间较大，带权并查集空间高效但需要精确推导权值更新公式。理解模运算在关系传递中的作用是掌握此类题目的核心。

---
处理用时：79.31秒
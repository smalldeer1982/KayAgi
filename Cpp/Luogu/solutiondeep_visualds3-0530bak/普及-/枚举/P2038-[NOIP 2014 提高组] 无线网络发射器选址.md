# 题目信息

# [NOIP 2014 提高组] 无线网络发射器选址

## 题目背景

NOIP2014 提高组 D2T1

## 题目描述

随着智能手机的日益普及，人们对无线网的需求日益增大。某城市决定对城市内的公共场所覆盖无线网。

假设该城市的布局为由严格平行的 $129$ 条东西向街道和 $129$ 条南北向街道所形成的网格状，并且相邻的平行街道之间的距离都是恒定值 $1$。东西向街道从北到南依次编号为 $0,1,2 \dots 128$，南北向街道从西到东依次编号为 $0,1,2 \dots 128$。

东西向街道和南北向街道相交形成路口，规定编号为 $x$ 的南北向街道和编号为 $y$ 的东西向街道形成的路口的坐标是 $(x, y)$。在某些路口存在一定数量的公共场所。

由于政府财政问题，只能安装一个大型无线网络发射器。该无线网络发射器的传播范围是一个以该点为中心，边长为 $2d$ 的正方形。传播范围包括正方形边界。

现在政府有关部门准备安装一个传播参数为 $d$ 的无线网络发射器，希望你帮助他们在城市内找出合适的路口作为安装地点，使得覆盖的公共场所最多。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq d \leq 20, 1 \leq n \leq 20, 0 \leq x \leq 128, 0 \leq y \leq 128, 0 < k \leq 10^6$。

## 样例 #1

### 输入

```
1
2
4 4 10
6 6 20```

### 输出

```
1 30```

# AI分析结果



# 算法分类  
**枚举**

---

# 题解分析  
## 核心思路  
题目要求在 128x128 的网格中，找到覆盖公共场所最多的发射器位置。各题解的核心逻辑均为：  
1. **枚举所有可能的发射点**（共 129x129 个）  
2. **计算每个发射点的覆盖总和**  
3. **维护最大值及方案数**

## 解决难点  
1. **边界处理**：发射点边缘需限制在 [0,128] 范围内  
2. **高效计算**：  
   - **方法一**：遍历所有公共场所点，判断是否在覆盖范围内（复杂度 O(M²*N)，M=128，N=20）  
   - **方法二**：遍历覆盖区域网格点，累加公共场所（复杂度 O(M²*D²)，D=20）  
3. **去重优化**：部分题解通过四方向遍历后去重轴数据，但实现复杂  

---

# 题解评分 (≥4星)  
1. **行者_Walker（5星）**  
   - **亮点**：极简代码，时间复杂度最优（O(M²*N)），隐式边界处理  
   - **代码**：  
     ```cpp
     for (int i=0; i<=128; i++) 
         for (int j=0; j<=128; j++) {
             int sum = 0;
             for (int k=1; k<=n; k++)
                 if (x[k]在i覆盖范围内 && y[k]在j覆盖范围内)
                     sum += z[k];
             // 更新最大值与方案数
         }
     ```

2. **qhr2023（4星）**  
   - **亮点**：显式边界处理，覆盖区域直接累加  
   - **代码**：  
     ```cpp
     for (int j=max(0, x-d); j<=min(128, x+d); ++j)
         for (int l=max(0, y-d); l<=min(128, y+d); ++l)
             sum += a[j][l];
     ```

3. **JayYee（4星）**  
   - **亮点**：通过调试修正边界错误，强调数据范围意识  
   - **心得**：  
     > "遍历到（0,0）点时，若d=20，需正确包含边缘公共场所"

---

# 最优思路提炼  
**关键优化**：  
1. **逆向计算**：遍历公共场所点而非覆盖区域网格点，时间复杂度骤降  
2. **隐式边界**：直接判断公共场所坐标是否在 [i-d, i+d] 范围内，无需显式限制  
3. **实时更新**：在枚举过程中直接维护最大值和方案数计数器  

**代码片段**：  
```cpp
int ans = 0, cnt = 1;
for (int i = 0; i <= 128; i++) {
    for (int j = 0; j <= 128; j++) {
        int sum = 0;
        for (int k = 0; k < n; k++) {
            if (abs(p[k].x - i) <= d && abs(p[k].y - j) <= d) {
                sum += p[k].val;
            }
        }
        if (sum > max_val) {
            max_val = sum;
            cnt = 1;
        } else if (sum == max_val) {
            cnt++;
        }
    }
}
```

---

# 同类型题推荐  
1. **P1719 最大加权矩形** - 二维前缀和模板  
2. **P3406 海底高铁** - 区间覆盖统计  
3. **P3669 工作团队** - 网格覆盖与最优化  

---

# 可视化设计  
## 算法演示  
1. **网格渲染**：  
   - 使用 8-bit 像素风格绘制 129x129 网格  
   - 发射点用闪烁绿色方块，覆盖区域半透明蓝色  
   - 公共场所点用黄色圆点，被覆盖时变红  

2. **动画流程**：  
   - 步进遍历每个发射点，高亮当前网格  
   - 实时显示覆盖区域范围和累计值  
   - 发现新最大值时播放 "升级" 音效  

3. **交互功能**：  
   - 速度调节：1x/5x/10x 三种速率  
   - 模式切换：对比暴力枚举 vs 优化方法  

## 复古风格  
- **调色板**：16 色 FC 风格（深蓝背景、亮绿高光）  
- **音效**：  
  - 移动光标：8-bit "哔" 声  
  - 更新最大值：FC 过关音效  
- **自动演示**：AI 按蛇形路线遍历网格  

---

**可视化实现核心代码**  
```javascript
// Canvas 绘制关键帧
function drawFrame() {
    ctx.fillStyle = "#2D5DA0"; // 背景色
    ctx.fillRect(0, 0, 512, 512);
    
    // 绘制网格线
    ctx.strokeStyle = "#4A752D";
    for (let i = 0; i <= 128; i += 8) {
        ctx.beginPath();
        ctx.moveTo(i*4, 0);
        ctx.lineTo(i*4, 512);
        ctx.stroke();
        // 同理绘制纵向网格...
    }
    
    // 高亮当前发射点
    ctx.fillStyle = "#00FF00";
    ctx.fillRect(currentX*4, currentY*4, 4, 4);
    
    // 播放音效
    if (newMax) playSound('powerup');
}
```

---
处理用时：182.65秒
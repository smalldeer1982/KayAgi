# 题目信息

# [BJWC2018] 售票

## 题目描述

C 市火车站最近出现了一种新式自动售票机。买票时，乘客要先在售票机上输入终点名称。一共有 $N$ 处目的地，随着乘客按顺序输入终点名称的每个字母，候选终点站数目会逐渐减少。

在自动售票机屏幕上，有一个 $4$ 行 $8$ 列的键盘，如下图所示。

![](https://cdn.luogu.com.cn/upload/pic/17861.png)

在乘客每输入一个字母后，键盘上只有有效字符是可选的（取决于还有哪些候选终点站），其余的字母会被字符 `*` 取代。

告诉你 $N$ 处目的地的名称，以及乘客已经输入的若干字符，请你输出键盘目前的状态。

## 说明/提示

**【样例解释】**

输入 `ZA` 以后，下一个字符可能是 `G`（终点站有可能是 `ZAGREB`），或 `D`（终点站有可能是 `ZADAR`），或 `B`（终点站有可能是 `ZABOK`）。

## 样例 #1

### 输入

```
4
ZAGREB
SISAK
ZADAR
ZABOK
ZA```

### 输出

```
****B*D*
*G******
********
********```

# AI分析结果



## 算法分类
**字符串处理**

---

## 题解思路与核心难点

### 核心思路
1. **前缀匹配筛选**：找出所有以输入字符串为前缀的目的地。
2. **收集候选字符**：提取每个匹配目的地的下一个字符（若存在）。
3. **键盘映射**：根据键盘布局将候选字符映射到正确位置，其余位置显示`*`。

### 解决难点
- **前缀匹配效率**：使用 `strncmp` 或 `substr` 快速比较前缀。
- **字符位置映射**：根据键盘布局，将字符映射到4x8矩阵中的正确坐标。关键公式：
  - **A-E**：行0，列 `3 + (c - 'A')`
  - **F-M**：行1，列 `c - 'F'`
  - **N-U**：行2，列 `c - 'N'`
  - **V-Z**：行3，列 `c - 'V'`

---

## 题解评分（≥4星）

### [引领天下] ★★★★★
- **亮点**：利用 `strncmp` 简化前缀匹配，通过字符范围快速计算键盘索引。
- **代码简洁性**：仅需一次遍历，时间复杂度为 O(N·L)，L为输入字符串长度。
- **优化点**：初始化键盘为一维数组，直接替换有效字符。

### [Blue_wonders] ★★★★☆
- **亮点**：逐字符过滤不匹配的字符串，逻辑清晰。
- **映射技巧**：通过 `b[i][len] - 'A' +4` 计算索引，适合小规模数据。
- **可读性**：代码结构简单，适合新手理解。

### [ShaeKnight] ★★★★☆
- **亮点**：使用 `substr` 准确匹配前缀，避免误判。
- **映射方法**：通过 `s[i][len] - 'A' +4` 计算索引，与键盘布局一致。
- **适用性**：适用于字符串操作较熟悉者。

---

## 最优思路与代码实现
### 关键思路
- **前缀匹配**：使用 `strncmp` 或 `substr` 快速筛选。
- **映射公式**：按字符范围分段计算索引，直接操作一维数组。

### 代码片段
```cpp
#include <cstdio>
#include <cstring>
char a[51][101], k[] = "********\n********\n********\n********";
int main() {
    int n, l; scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%s", a[i]);
    char s[101]; scanf("%s", s); l = strlen(s);
    for (int i = 0; i < n; i++) {
        if (!strncmp(a[i], s, l)) {
            char c = a[i][l];
            if (c >= 'A' && c <= 'E') k[c - 'A' + 3] = c;
            else if (c >= 'F' && c <= 'M') k[c - 'A' + 4] = c;
            else if (c >= 'N' && c <= 'U') k[c - 'A' + 5] = c;
            else if (c >= 'V' && c <= 'Z') k[c - 'A' + 6] = c;
        }
    }
    printf("%s", k);
}
```

---

## 类似题目与扩展
1. **P2580 于是他错误的点名开始了**（字典树应用）
2. **P1012 [NOIP1998 提高组] 拼数**（字符串排序与拼接）
3. **P1308 [NOIP2011 普及组] 统计单词数**（模式匹配）

---

## 个人心得摘录
- **调试经验**：字符映射需仔细核对键盘布局，避免坐标计算错误。
- **优化技巧**：初始化全`*`后局部替换，减少冗余判断。

---

## 可视化算法演示
### 动画设计
- **键盘布局**：4x8网格，初始全灰（`*`），候选字符高亮。
- **筛选过程**：输入字符串后，匹配的目的地逐个显示，其下一个字符在键盘上闪烁。
- **颜色标记**：红色表示当前处理字符，绿色表示有效候选。

### 复古游戏化效果
- **像素风格**：8-bit 字体与网格，背景音乐为芯片音效。
- **音效触发**：字符激活时播放短促“哔”声，错误输入时低频警告音。
- **交互控制**：支持暂停/步进，速度调节滑块。

### 实现示例（伪代码）
```javascript
// 初始化键盘
const keyboard = [
    ['*', '*', '*', 'A', 'B', 'C', 'D', 'E'],
    ['F', 'G', 'H', 'I', 'J', 'K', 'L', 'M'],
    ['N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U'],
    ['V', 'W', 'X', 'Y', 'Z', '*', '*', '*']
];

// 更新候选字符
function updateKeyboard(c) {
    const row = getRow(c), col = getCol(c);
    keyboard[row][col] = `<span class="highlight">${c}</span>`;
}
```

---

**总结**：通过前缀筛选与字符映射，结合高效字符串操作，快速生成键盘状态。

---
处理用时：252.91秒
# 题目信息

# [NOIP 2018 普及组] 龙虎斗

## 题目背景

NOIP2018 普及组 T2

## 题目描述

轩轩和凯凯正在玩一款叫《龙虎斗》的游戏，游戏的棋盘是一条线段，线段上有 $n$ 个兵营（自左至右编号 $1 \sim n$），相邻编号的兵营之间相隔 $1$ 厘米，即棋盘为长度为 $n-1$ 厘米的线段。$i$ 号兵营里有 $c_i$ 位工兵。下面图 1 为 $n=6$ 的示例： 

![](https://cdn.luogu.com.cn/upload/pic/43224.png)    

轩轩在左侧，代表“龙”；凯凯在右侧，代表“虎”。 他们以 $m$ 号兵营作为分界， 靠左的工兵属于龙势力，靠右的工兵属于虎势力，而第 $m$ 号兵营中的工兵很纠结，他们不属于任何一方。    

一个兵营的气势为：该兵营中的工兵数$ \times $ 该兵营到 $m$ 号兵营的距离；参与游戏 一方的势力定义为：属于这一方所有兵营的气势之和。    
下面图 2 为 $n = 6,m = 4$ 的示例，其中红色为龙方，黄色为虎方：

![](https://cdn.luogu.com.cn/upload/pic/43225.png)  

游戏过程中，某一刻天降神兵，共有 $s_1$ 位工兵突然出现在了 $p_1$ 号兵营。作为轩轩和凯凯的朋友，你知道如果龙虎双方气势差距太悬殊，轩轩和凯凯就不愿意继续玩下去了。为了让游戏继续，你需要选择一个兵营 $p_2$，并将你手里的 $s_2$ 位工兵全部派往 兵营 $p_2$，使得双方气势差距尽可能小。 

 注意：你手中的工兵落在哪个兵营，就和该兵营中其他工兵有相同的势力归属（如果落在 $m$ 号兵营，则不属于任何势力）。

## 说明/提示

**样例 1 说明**   

见问题描述中的图 2。   
双方以 $m=4$ 号兵营分界，有 $s_1=5$ 位工兵突然出现在 $p_1=6$ 号兵营。 
龙方的气势为：   
$$2 \times (4-1)+3 \times (4-2)+2 \times (4-3) = 14$$  
虎方的气势为：   
$$2 \times  (5 - 4) + (3 + 5) \times (6 - 4) = 18$$  
当你将手中的 $s_2 = 2$ 位工兵派往 $p_2 = 2$ 号兵营时，龙方的气势变为： 
$$14 + 2 \times  (4 - 2) = 18$$  
此时双方气势相等。 
  
**样例 2 说明**   

双方以 $m = 5$ 号兵营分界，有 $s_1 = 1$ 位工兵突然出现在 $p_1 = 4$ 号兵营。  
龙方的气势为：   
$$1 \times  (5 - 1) + 1 \times  (5 - 2) + 1 \times  (5 - 3) + (1 + 1) \times  (5 - 4) = 11$$  
虎方的气势为：   
$$16 \times  (6 - 5) = 16$$    
当你将手中的 $s_2 = 1$ 位工兵派往 $p_2 = 1$ 号兵营时，龙方的气势变为：    
$$11 + 1 \times  (5 - 1) = 15$$    
此时可以使双方气势的差距最小。

**数据规模与约定**    


$1 < m < n$，$1 \le p_1 \le n$。   
对于 $20\%$ 的数据，$n = 3,m = 2, c_i = 1, s_1,s_2 ≤ 100$。    
另有 $20\%$ 的数据，$n ≤ 10, p_1 = m, c_i = 1, s_1,s_2 ≤ 100$。  
对于 $60\%$ 的数据，$n ≤ 100, c_i = 1, s_1,s_2 ≤ 100$。   
对于 $80\%$ 的数据，$n ≤ 100, c_i,s_1,s_2 ≤ 100$。  
对于 $100\%$ 的数据，$n≤10^5$,$c_i,s_1,s_2≤10^9$。 

## 样例 #1

### 输入

```
6 
2 3 2 3 2 3 
4 6 5 2 ```

### 输出

```
2```

## 样例 #2

### 输入

```
6 
1 1 1 1 1 16 
5 4 1 1```

### 输出

```
1```

# AI分析结果



---

## 算法分类
**枚举优化**（通过预处理和数学推导将 O(n²) 优化至 O(n) 或 O(1)）

---

## 题解思路、算法要点与解决难点

### 核心思路
1. **预处理势力差**：先计算天降神兵后的龙虎初始势力差
2. **枚举法优化**：通过预处理避免重复计算，时间复杂度 O(n)
3. **数学公式推导**：通过解方程直接计算理论最优位置，处理边界后得到实际最优解

### 解决难点
1. **超时问题**：通过预处理 sum1（龙势力）、sum2（虎势力），将 O(n²) 暴力枚举优化至 O(n)
2. **大数溢出**：使用 `long long` 处理 1e9 * 1e5 级别的大数运算
3. **最优解推导**：通过公式 `p2 = m + (sum2-sum1)/s2` 推导理论最优位置，处理浮点取整与边界

---

## 题解评分（≥4星）

### 五星题解
**ykuouzf（数学公式法）**
- 亮点：通过数学推导直接得出最优解，时间复杂度 O(1)
- 代码：仅 15 行，包含边界处理与四舍五入逻辑
- 核心代码片段：
  ```cpp
  sum += s*(m-p); // 预处理天降神兵影响
  ans = m + int(sum*1.0/k + 0.5*(sum>0?1:-1)); // 核心公式
  ans = clamp(ans, 1, n); // 边界处理
  ```

### 四星题解
**wxy_god（预处理+枚举优化）**
- 亮点：详细分析超时原因，给出 long long 踩坑教训
- 代码：完整展示从暴力到优化的过程，含方程法尝试
- 核心优化：
  ```cpp
  // 预处理初始势力
  for(i=1~n) sum1 += (m-i)*a[i];
  // 枚举时直接计算增量
  if(i<m) tmp1 = sum1 + s2*(m-i);
  ```

**犇犇犇犇（杠杆原理+边界特判）**
- 亮点：用杠杆原理解释题目，处理整数除法的上下取整
- 关键逻辑：
  ```cpp
  p2 = m - (hu-lo)/s2; // 理论最优位置
  if(相邻点更优) p2--;  // 处理实际最优
  ```

---

## 最优思路提炼
1. **数学公式法**  
   - 推导公式：`p2 = m + (虎势力 - 龙势力) / s2`
   - 处理浮点数：四舍五入后 clamp 到 [1, n] 区间
   - **优势**：时间复杂度从 O(n) 降为 O(1)

2. **预处理+增量计算**  
   - 预处理初始 sum1/sum2
   - 枚举时直接计算 `tmp = sum1 ± s2*(距离)`
   - **优势**：避免重复遍历兵营，O(n) 稳定通过

---

## 同类型题与算法套路
- **套路**：预处理 + 差值最小化问题
- **相似题**：
  1. P1908 逆序对（分治预处理）
  2. P2671 求和（公式推导差值）
  3. P5017 摆渡车（时间轴差值优化）

---

## 推荐题目
1. [P1036 选数](https://www.luogu.com.cn/problem/P1036)（枚举+数学）
2. [P2671 求和](https://www.luogu.com.cn/problem/P2671)（公式推导优化）
3. [P5017 摆渡车](https://www.luogu.com.cn/problem/P5017)（时间差最优化）

---

## 个人心得摘录
> **wxy_god**：  
> "十年OI一场空，不开long long见祖宗" —— 用 1e5*1e9 数据提醒大数问题  
> **犇犇犇犇**：  
> "当没有找到更优解时，初始 ans 应设为 1 而非 0" —— 边界条件的实战教训

---

## 可视化与算法演示设计

### 核心流程动画
1. **初始化阶段**：
   - 绘制 n 个兵营，用红/黄区分龙虎势力，m 号灰色
   - 显示初始工兵数，`p1` 兵营闪动后增加 `s1`

2. **预处理阶段**：
   - 动态计算 sum1/sum2，公式浮现在画面上方
   - 用进度条表示计算进度

3. **求解阶段**：
   - 公式法：显示理论 p2 位置，用绿色箭头标记
   - 枚举法：高亮当前测试的 p2，实时显示势力差曲线图

### 复古像素风实现
```javascript
// Canvas 绘制示例
function drawBarracks(ctx, m, p2) {
  for(let i=0; i<n; i++) {
    ctx.fillStyle = i<m ? '#FF8888' : (i>m ? '#FFFF88' : '#AAAAAA');
    if(i === p2) ctx.fillStyle = '#00FF00'; // 高亮当前测试位置
    ctx.fillRect(50+i*30, 150, 25, 50); // 兵营方块
  }
}

// 音效触发
function playSound(effect) {
  const sfx = {
    optimize: new Audio('data:audio/wav;base64,UklGRl9...'), // 8-bit 音效
    boundary: new Audio('data:audio/wav;base64,UklGRh4...')
  };
  sfx[effect].play();
}
```

### 交互功能
- **速度控制**：滑块调节枚举速度（1x~10x）
- **模式切换**：公式法自动演示 vs 枚举法手动步进
- **音效**：命中更优解时播放上升音调，越界时爆炸音效

---

## 核心代码实现
**数学公式法（ykuouzf）完整代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000000],m,p,s,k,sum,ans;
int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    scanf("%lld%lld%lld%lld",&m,&p,&s,&k);
    for(int i=1;i<=n;i++) sum+=a[i]*(m-i);
    sum+=s*(m-p);
    ans=m+round(sum*1.0/k);
    ans = max(1ll, min(ans, n*1ll));
    printf("%lld",ans);
    return 0;
}
```

**枚举优化法（wxy_god）核心逻辑**
```cpp
// 预处理初始势力
long long sum1=0, sum2=0;
for(int i=1;i<m;i++) sum1 += a[i]*(m-i);
for(int i=m+1;i<=n;i++) sum2 += a[i]*(i-m);

// 枚举每个位置
long long min_gap = LLONG_MAX, ans = m;
for(int i=1;i<=n;i++){
    long long new_sum1 = sum1, new_sum2 = sum2;
    if(i < m) new_sum1 += s2*(m-i);
    else if(i > m) new_sum2 += s2*(i-m);
    
    long long gap = abs(new_sum1 - new_sum2);
    if(gap < min_gap || (gap == min_gap && i < ans)) {
        min_gap = gap;
        ans = i;
    }
}
```

---
处理用时：90.20秒
# 题目信息

# 【深基7.例10】旗鼓相当的对手 - 加强版

## 题目描述

现有 $N(N\le 1000)$ 名同学参加了期末考试，并且获得了每名同学的信息：姓名（不超过 $8$ 个字符的字符串，没有空格）、语文、数学、英语成绩（均为不超过 $150$ 的自然数）。如果某对学生 $\text{<}i,j\text{>}$ 的每一科成绩的分差都不大于 $5$，且总分分差不大于 $10$，那么这对学生就是“旗鼓相当的对手”。现在我们想知道这些同学中，哪些是“旗鼓相当的对手”？请输出他们的姓名。

所有人的姓名是按照字典序给出的，输出时也应该按照字典序输出所有对手组合。也就是说，这对组合的第一个名字的字典序应该小于第二个；如果两个组合中第一个名字不一样，则第一个名字字典序小的先输出；如果两个组合的第一个名字一样但第二个名字不同，则第二个名字字典序小的先输出。

## 说明/提示

数据保证，$1 \leq N \leq 1000$，姓名为长度不超过 $8$ 的字符串，语文、数学、英语成绩均为不超过 $150$ 的自然数。

## 样例 #1

### 输入

```
3
fafa 90 90 90
lxl 95 85 90
senpai 100 80 91```

### 输出

```
fafa lxl
lxl senpai
```

# AI分析结果



---

**唯一算法分类**：无算法分类

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   - 遍历所有学生对 `<i,j>`（i < j），检查各科分差 ≤5 且总分差 ≤10。
   - 利用输入已按字典序排列的特性，直接输出 `i` 和 `j` 对应的姓名。

2. **关键实现**  
   - **数据结构**：使用结构体或数组存储学生姓名、各科成绩及总分。
   - **双重循环**：外层循环 `i` 从 1 到 `n-1`，内层循环 `j` 从 `i+1` 到 `n`，保证每对学生只比较一次。
   - **条件判断**：通过绝对值判断分差是否满足要求。

3. **解决难点**  
   - **输出顺序**：输入数据已按字典序排列，因此 `i < j` 时，`a[i].s` 的字典序必然 ≤ `a[j].s`，无需额外排序或判断。
   - **性能优化**：直接遍历所有对的复杂度为 O(n²)，在 `n ≤ 1000` 时完全可行。

---

### **题解评分 (≥4星)**

| 题解作者       | 评分 | 亮点与不足                                                                 |
|----------------|------|----------------------------------------------------------------------------|
| SUNCHAOYI      | ⭐⭐⭐⭐ | 代码简洁，直接利用输入顺序，省略字典序判断，效率高。                       |
| lizishuo       | ⭐⭐⭐⭐ | 结构清晰，正确利用输入顺序，未引入冗余操作。                               |
| lu_fish        | ⭐⭐⭐⭐ | 使用数组存储数据，输出时动态判断字典序，代码可读性较好。                   |

---

### **最优思路与技巧提炼**

1. **输入顺序的利用**  
   - 题目明确输入数据已按字典序排列，因此遍历 `i < j` 时可直接输出 `i` 在前，无需额外排序或条件判断。

2. **条件判断优化**  
   - 合并分差判断和总分判断为一行代码，减少冗余变量。

3. **代码简洁性**  
   - 使用结构体存储数据，避免分散的数组管理，提升代码可读性。

---

### **同类型题与算法套路**

- **常见题型**：多条件筛选的组合问题（如「两数之和」「亲密字符串」）。
- **通用解法**：双重循环遍历所有可能组合，结合条件判断筛选结果。

---

### **推荐题目**

1. **P1104 生日**（结构体排序与条件判断）
2. **P1051 谁拿了最多奖学金**（多条件统计与排序）
3. **P1093 奖学金**（综合排序与条件筛选）

---

### **个人心得摘录**

- **封禁用户**：误认为需要手动排序，导致代码效率下降，提醒注意审题。
- **lu_fish**：通过分散数组存储数据，展示灵活的数据管理方式。

---

### **可视化算法演示**

1. **动画设计**  
   - **网格布局**：将学生按输入顺序排列在网格中，用不同颜色区分已检查和未检查的对。
   - **高亮比较**：当前比较的对 `<i,j>` 高亮显示，动态显示各科分差和总分差。
   - **条件反馈**：若符合条件，显示绿色连线；否则显示红色连线。

2. **复古像素风格**  
   - **8 位音效**：比较时播放“滴”声，符合条件时播放“叮”声，背景音乐循环 8 位风格旋律。
   - **Canvas 绘制**：用像素块表示学生，姓名以点阵字体显示。

3. **交互功能**  
   - **步进控制**：支持暂停/继续、单步执行，调整动画速度。
   - **自动演示**：AI 自动遍历所有对，标记符合条件的组合。

---

### **核心代码实现**

```cpp
// 结构体定义与输入
struct Student {
    string name;
    int ch, math, eng, total;
} students[1005];

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> students[i].name >> students[i].ch >> students[i].math >> students[i].eng;
        students[i].total = students[i].ch + students[i].math + students[i].eng;
    }

    // 遍历所有对并输出
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (abs(students[i].ch - students[j].ch) <= 5 &&
                abs(students[i].math - students[j].math) <= 5 &&
                abs(students[i].eng - students[j].eng) <= 5 &&
                abs(students[i].total - students[j].total) <= 10) {
                cout << students[i].name << " " << students[j].name << endl;
            }
        }
    }
    return 0;
}
```

---

### **总结**

本题通过双重循环和条件判断直接解决问题，无需复杂算法。关键点在于利用输入顺序简化输出逻辑，避免冗余操作。可视化设计可通过复古风格动画增强学习趣味性。

---
处理用时：91.93秒
# 题目信息

# 「EZEC-3」造房子

## 题目背景

pigstd 要去造房子了。

## 题目描述

pigstd 有 $a$ 个 A 材料和 $b$ 个 B 材料，造**第** $i$ 层楼需要 $i$ 个 A 材料与 $i$ 个 B 材料。

但是 pigstd 觉得房子不够高，于是他拿出了 $c$ 块钱，每块钱都可以用来买 $1$ 个 A 材料或者 $1$ 个 B 材料。

现在 pigstd 想知道，他最多能建多少层楼的房子。

## 说明/提示

**【样例 1 说明】**

pigstd 买 $2$ 个 A 材料和 $1$ 个 B 材料后就有 $3$ 个 A 材料和 $3$ 个 B 材料，最多可以建 $2$ 层楼的房子。

（花费 $1+2$ 个 A 材料和 $1+2$ 个 B 材料）

**【样例 2 说明】**

pigstd 买 $3$ 个 A 材料后就有 $4$ 个 A 材料和 $5$ 个 B 材料，最多可以建 $2$ 层楼的房子。

（花费 $1+2$ 个 A 材料和 $1+2$ 个 B 材料）

**【数据规模与约定】**

对于 $100\%$ 的数据，$0 \le a,b,c \le 10^{12}$。

| 数据点编号 | 满足的条件 |
| :----------: | :----------: |
|$1-4,22$| $c = 0$ |
|$5-8,21$| $a,b,c \le 10^{3}$ |
|$9-12$| $a,b,c \le 10^{6}$ |
|$13-20$| $a,b,c \le 10^{12}$ | 

## 样例 #1

### 输入

```
1 2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
1 5 3```

### 输出

```
2```

# AI分析结果



---

## 唯一算法分类  
**贪心策略与数学推导**

---

## 综合分析与结论  

### 核心思路  
通过以下两步解决问题：  
1. **材料平衡**：将 $c$ 优先用于补齐 $a$ 与 $b$ 的差值，剩余部分均分  
2. **数学求解**：计算 $\max n$ 满足 $\frac{n(n+1)}{2} \leq \text{调整后的材料数}$  

### 难点与解决  
1. **大数处理**：直接暴力枚举会导致超时，需用一元二次方程推导公式  
2. **边界条件**：需处理 $c$ 不足以补齐差值时的特殊情况  
3. **精度控制**：平方根运算需保证下取整的正确性  

### 关键算法流程  
1. **调整材料数**  
   - 若 $a < b$，先用 $c$ 补齐 $a$ 至 $b$，剩余 $c$ 均分  
   - 若 $c$ 不足以补齐，直接全部用于较小的一方  
2. **公式计算**  
   - 解方程 $\frac{n(n+1)}{2} \leq s$，得 $n = \lfloor \frac{-1+\sqrt{1+8s}}{2} \rfloor$  

---

## 题解清单 (≥4星)  

### 云浅知处 (5星)  
- **亮点**：严格的数学推导，直接给出 O(1) 解法  
- **关键代码**：使用 `sqrt` 与 `floor` 直接计算答案  
```cpp
LL ans = (LL)(((LL)(floor(sqrt(8*s+1)))-1)/2);
```

### Unordered_OIer (4星)  
- **亮点**：详细分类讨论，提供多种实现方案（循环、二分、数学）  
- **个人心得**："求根公式中负数根可直接忽略" 帮助理解公式推导  

### Aw顿顿 (4星)  
- **亮点**：直观的贪心策略与循环实现，适合小规模数据  
- **关键代码**：直接模拟材料分配与消耗过程  
```cpp
for(long long i=1;;i++) {
    ans += i;
    if(ans > s) return i-1;
}
```

---

## 最优思路与技巧提炼  

### 贪心策略  
- **平衡优先**：用 $c$ 优先缩小 $|a-b|$，剩余部分均分  
- **数学公式**：$\text{最终材料数} = \begin{cases} 
\min(a,b) + c & \text{if } c < |a-b| \\
\frac{a+b+c}{2} & \text{otherwise}
\end{cases}$  

### 数学推导  
- **一元二次方程**：$n = \lfloor \frac{-1+\sqrt{1+8s}}{2} \rfloor$  
- **避免浮点误差**：使用 `sqrt` 前转换为 `long double` 提高精度  

---

## 同类型题与算法套路  

### 通用解法  
1. **贪心平衡**：最小化两变量差值  
2. **数学极值**：通过公式快速求解极值点  

### 推荐题目  
1. **P1873 砍树**：二分答案 + 极值计算  
2. **P2440 木材加工**：最大化最小值问题  
3. **P1181 数列分段**：贪心分组 + 极值判断  

---

## 可视化与算法演示  

### 动画设计  
1. **材料调整阶段**  
   - **动态显示**：红色箭头从 $c$ 指向 $a$ 或 $b$ 填补差值  
   - **高亮标记**：剩余 $c$ 以绿色方块均分至两材料  
   - **音效**：每次分配播放 "coin.wav" 音效  

2. **公式计算阶段**  
   - **逐步绘制**：抛物线 $n^2 + n - 2s = 0$ 的生成过程  
   - **根标记**：红色圆点标注正根位置  
   - **代码同步**：显示 `floor((sqrt(...)))` 的计算结果  

### 复古像素风格  
- **颜色方案**：  
  - 材料：A-浅蓝（#7ED8FF），B-粉红（#FFB5E8）  
  - 公式：黄色（#FFFF00）  
- **音效设计**：  
  - 成功分配：8-bit "ping" 音效  
  - 计算完成：FC 胜利音效  

---

## 关键代码实现  

### 数学解法核心片段  
```cpp
// 计算最大层数
long long calc_max_floor(long long s) {
    long double ds = s;
    return (sqrt(1 + 8 * ds) - 1) / 2;
}

// 主逻辑
if (a > b) swap(a, b);
if (b - a > c) {
    s = a + c;
} else {
    c -= (b - a);
    a = b;
    s = a + c / 2;
}
cout << calc_max_floor(s);
```

---

通过以上分析，该问题的核心在于巧妙结合贪心策略与数学推导，在保证正确性的同时实现极致效率。可视化方案通过复古像素风格与音效互动，可有效提升学习算法的趣味性。

---
处理用时：67.45秒
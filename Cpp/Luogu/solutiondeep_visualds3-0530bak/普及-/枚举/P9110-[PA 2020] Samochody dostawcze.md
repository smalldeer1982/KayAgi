# 题目信息

# [PA 2020] Samochody dostawcze

## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 3 [Samochody dostawcze](https://sio2.mimuw.edu.pl/c/pa-2020-1/sam/)**

Byteasar 是一家向商店运送物资的公司的后勤人员。在他公司所在的城市里，道路网由横向的街（从西到东）和纵向的道（从南到北）组成。每一对相邻的街和相邻的道都相距一公里。我们把街按从南到北的顺序编号，把道按从西到东的顺序编号。我们将第 $i$ 条道和第 $j$ 条街的交叉点记为 $(i,j)$。你可以假设，对于任何一个整数，都存在一条街的编号为 $j$ 和一条道的编号为 $i$。

Byteasar 明天安排了 $n$ 次送货；第 $i$ 次送货将由一辆货车在时刻 $t_i$ 离开车库，以每时间单位一公里的恒定速度沿街或道行驶。每次送货可以是两种类型中的一种：对于送货类型一，车库在路口 $(w_i,0)$，货车沿道 $w_i$ 向北行驶；对于送货类型二，车库在路口 $(0,w_i)$，货车沿街 $w_i$ 向东行驶。根据计划，每个车库在任何时刻最多只有一辆车离开。

货车不必停下来——驶过收货地点时，司机只需放下要送的包裹。然而，有一个问题，如果两辆货车发现他们同一时刻在同一个十字路口，就很可能会发生碰撞。Byteasar 非常希望避免这种情况。不幸的是，他唯一能做的就是取消一些送货计划。因此，他希望取消尽可能少的送货计划，以便剩下的车中没有任何两辆车同一时刻在同一个十字路口。

## 说明/提示

#### 样例 1 解释

如果四份货物都送出，则第一和第二辆车会在时刻 $5$，在路口 $(5,3)$ 相撞。如果取消第一个送货计划，则第二和第四辆车会在时刻 $7$，在路口 $(7,3)$ 相撞。如果取消第二个送货计划，那么所有车都不会相撞了。

------------

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据，保证 $1\le n\le 5\times 10^5$，$r_i\in \{1,2\}$，$1\le w_i\le 10^6$，$0\le t_i\le 10^6$。

## 样例 #1

### 输入

```
4
1 5 2
2 3 0
2 3 6
1 7 4```

### 输出

```
1```

# AI分析结果



## 唯一算法分类
贪心算法

---

## 综合分析与结论

### 核心思路与难点
- **关键推导**：两车相撞的充要条件是 `w_i - t_i` 相等且类型不同。类型1的车沿道向北行驶，类型2的车沿街向东行驶，当且仅当两者的 `w_i - t_i` 相等时，会在某个时刻相遇于同一路口。
- **算法要点**：
  - **桶分类**：以 `w_i - t_i` 为键，将车辆分配到对应的桶中。
  - **偏移量处理**：为避免负数下标，所有键统一加上 `1e6` 的偏移量。
  - **贪心统计**：对于每个桶，只能保留一种类型的车，因此取两种类型数量的较小值累加，作为必须删除的最小车辆数。
- **解决难点**：正确推导碰撞条件，并通过桶分类高效统计。

### 可视化设计思路
- **动画方案**：
  1. **像素网格**：以8位像素风格绘制坐标轴，车辆出发时显示起点（如类型1显示为红色方块，类型2显示为蓝色方块）。
  2. **运动轨迹**：用动态箭头表示车辆行驶方向，碰撞时触发爆炸特效和音效。
  3. **桶分类显示**：右侧绘制桶数组，每个桶高度表示两种类型的数量，用绿/红色块区分。
  4. **贪心统计**：遍历桶时，高亮当前桶，自动比较两种颜色块数量，较小值闪烁后消失。
- **交互设计**：
  - **步进控制**：可逐帧观察车辆分配和桶统计过程。
  - **音效**：碰撞时播放爆炸音效，统计时播放“选择”音效。
  - **复古风格**：背景音乐采用8位循环曲调，像素字体显示统计结果。

---

## 题解清单（≥4星）

### 1. Sol1 的题解（★★★★★）
- **亮点**：代码简洁高效，正确处理偏移量，数组大小合理。
- **核心代码**：
  ```cpp
  int cnt[3000005][2];
  for (int i = 1;i <= n;i++) {
      int r = qread(), w = qread(), t = qread();
      cnt[t - w + 1000005][r - 1]++;
  }
  int ans = 0;
  for (int i = 1;i <= 3000000;i++) ans += min(cnt[i][0], cnt[i][1]);
  ```

### 2. Seqfrel 的题解（★★★★）
- **亮点**：详细推导碰撞条件，配图解释清晰。
- **核心代码**：
  ```cpp
  const int d=1e6+10;
  int plan[maxn][3];
  for (int i=1;i<=n;i++) {
      int r,w,t; scanf("%d%d%d",&r,&w,&t);
      plan[t-w+d][r]++;
  }
  for (int i=1;i<=maxn;i++) ans += min(plan[i][1], plan[i][2]);
  ```

### 3. Laisira 的题解（★★★★）
- **亮点**：代码高效，最优解实测性能优异。
- **核心代码**：
  ```cpp
  int mp[3000001][2];
  for (int i=1;i<=n;i++) {
      int u,v,w; read(u,w,v);
      mp[w-v+1000000][u-1]++;
  }
  for (int i=1;i<=2000000;i++) ans += min(mp[i][0], mp[i][1]);
  ```

---

## 最优思路提炼
1. **键值转换**：将碰撞条件转换为 `w_i - t_i`，通过偏移量避免负数。
2. **桶分类统计**：使用桶数组记录每个键对应的两种类型车辆数。
3. **贪心决策**：对每个桶选择保留数量较多的类型，累加较小值即为答案。

---

## 类似算法套路
- **哈希统计**：如两数之和问题，通过哈希表快速查找补数。
- **分组贪心**：如区间调度问题，按结束时间排序后选择最早结束的区间。

---

## 推荐题目
1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)  
   （统计差值的出现次数）
2. [P1868 饥饿的奶牛](https://www.luogu.com.cn/problem/P1868)  
   （区间分组与贪心选择）
3. [P3405 Cities and States S](https://www.luogu.com.cn/problem/P3405)  
   （键值对分组统计）

---

## 个人心得摘录
- **xd244 的调试经验**：“测试点有182个，数组大小必须足够，否则会WA。”  
- **Seqfrel 的推导感悟**：“将出发时间归零，调整起点后，碰撞条件变得直观。”

---

## 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int OFFSET = 1e6;
int cnt[2 * OFFSET + 10][2]; // 桶数组

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    int n; cin >> n;
    for (int i = 0; i < n; i++) {
        int r, w, t;
        cin >> r >> w >> t;
        int key = w - t + OFFSET; // 偏移处理
        cnt[key][r-1]++;          // r=1存到[0]，r=2存到[1]
    }
    
    int ans = 0;
    for (int i = 0; i <= 2 * OFFSET; i++) {
        ans += min(cnt[i][0], cnt[i][1]);
    }
    cout << ans;
    return 0;
}
```

---
处理用时：204.75秒
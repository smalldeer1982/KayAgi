# 题目信息

# [蓝桥杯 2023 省 B] 填空问题

## 题目描述

## 试题 A：日期统计

### 【问题描述】

小蓝现在有一个长度为 $100$ 的数组，数组中的每个元素的值都在 $0$ 到 $9$ 的范围之内。数组中的元素从左至右如下所示:

```
5 6 8 6 9 1 6 1 2 4 9 1 9 8 2 3 6 4 7 7 5 9 5 0 3 8 7 5 8 1 5 8 6 1 8 3 0 3 7 9 2 7 0 5 8 8 5 7 0 9 9 1 9 4 4 6 8 6 3 3 8 5 1 6 3 4 6 7 0 7 8 2 7 6 8 9 5 6 5 6 1 4 0 1 0 0 9 4 8 0 9 1 2 8 5 0 2 5 3 3
```
现在他想要从这个数组中寻找一些满足以下条件的子序列：

1. 子序列的长度为 $8$;

2. 这个子序列可以按照下标顺序组成一个 `yyyymmdd` 格式的日期，并且要求这个日期是 2023 年中的某一天的日期，例如 $20230902$，$20231223$。`yyyy` 表示年份，`mm` 表示月份，`dd` 表示天数，当月份或者天数的长度只有一位时需要一个前导零补充。

请你帮小蓝计算下按上述条件一共能找到多少个**不同**的 2023 年的日期。对于相同的日期你只需要统计一次即可。

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

## 试题 B：01 串的熵

### 【问题描述】

对于一个长度为 $n$ 的 01 串 $S=x_{1} x_{2} x_{3} \ldots x_{n}$，香农信息熵的定义为 $H(S)=-\sum_{i=1}^{n} p\left(x_{i}\right) \log_{2}\left(p\left(x_{i}\right)\right)$，其中 $p(0),p(1)$ 表示在这个 01 串中 0 和 1 出现的占比。

比如，对于 $S=100$ 来说，信息熵 $H(S)=-\frac{1}{3}\log _{2}\left(\frac{1}{3}\right)-\frac{2}{3} \log _{2}\left(\frac{2}{3}\right)-\frac{2}{3} \log _{2}\left(\frac{2}{3}\right)=1.3083$。对于一个长度为 $23333333$ 的 01 串，如果其信息熵为 $11625907.5798$，且 0 出现次数比 1 少，那么这个 01 串中 0 出现了多少次？

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 

## 说明/提示

答题模板，可供参考。

```cpp
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "The answer of task A", // 双引号中替换为 A 题的答案
        "The answer of task B", // 双引号中替换为 B 题的答案
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}
```

# AI分析结果



---

### 算法分类  
**试题 A**：枚举 + 日期合法性验证  
**试题 B**：数学公式计算 + 枚举  

---

### 题解思路与核心难点  
#### 试题 A：日期统计  
- **核心思路**：  
  1. **逆向思维**：不遍历所有可能的子序列，而是枚举所有合法的 2023 年日期（共 365 天），检查该日期是否能在原数组中按顺序找到对应的 8 位子序列。  
  2. **日期合法性验证**：使用预定义的每月天数表快速验证日期是否合法。  
- **解决难点**：  
  - 通过固定年份为 2023 减少无效枚举，直接规避重复日期问题。  
  - 子序列匹配时只需遍历数组一次，时间复杂度为 O(100*365) = 36,500。  

#### 试题 B：01 串的熵  
- **核心思路**：  
  1. **公式代入**：已知熵的计算公式，枚举 0 的出现次数 i（范围 1 到 n/2），计算对应的熵值，找到与目标值误差最小的 i。  
  2. **精度处理**：使用浮点数计算，误差控制在 ±0.01 范围内即可。  
- **解决难点**：  
  - 利用数学推导避免复杂算法，直接枚举求解。  
  - 通过浮点数运算优化避免溢出（使用 `log2` 函数）。  

---

### 题解评分（≥4星）  
#### dbywsc 的题解（⭐⭐⭐⭐⭐）  
- **亮点**：  
  - 试题 A 的逆向枚举法极大降低时间复杂度。  
  - 试题 B 的代码简洁，直接利用公式计算，逻辑清晰。  
  - 可读性高，无冗余步骤。  

---

### 最优思路与技巧提炼  
#### 试题 A  
- **关键技巧**：  
  - **逆向枚举合法日期**：避免重复统计，直接保证唯一性。  
  - **快速子序列匹配**：单次遍历数组即可判断是否存在目标序列。  

#### 试题 B  
- **关键技巧**：  
  - **数学公式直接应用**：无需复杂推导，枚举即可高效求解。  
  - **浮点数精度控制**：通过误差范围判定答案，避免精确匹配的困难。  

---

### 同类型题与算法套路  
- **日期处理类**：  
  - 常见套路：预定义月份天数表、闰年判断、日期合法性快速验证。  
- **数学公式计算类**：  
  - 常见套路：公式直接代入、枚举/二分法逼近目标值、浮点数精度处理。  

---

### 推荐相似题目  
1. **P2015 [NOIP2016 提高组] 玩具谜题**（方向与循环结合）  
2. **P1014 [NOIP1999 提高组] Cantor 表**（数学规律与枚举）  
3. **P1143 进制转换**（数学计算与字符串处理）  

---

### 个人心得摘录  
- **调试教训**（ZhaoV1 的题解）：  
  > DFS 剪枝若不彻底会导致超时，必须优先固定年份部分（2023）大幅减少搜索空间。  

---

### 可视化与算法演示  
#### 试题 A 动画设计  
1. **像素风格日期遍历**：  
   - **Canvas 网格**：绘制 12x31 的网格代表月份和天数，高亮当前检查的日期（如 2023-03-05）。  
   - **颜色标记**：  
     - 绿色：合法日期且匹配成功  
     - 红色：合法日期但匹配失败  
     - 灰色：非法日期  
   - **音效**：匹配成功时播放 8-bit 上升音效，失败时短促“哔”声。  
2. **子序列匹配过程**：  
   - 原数组以像素方块展示，匹配时逐个高亮对应数字，步进速度可调。  

#### 试题 B 动画设计  
1. **动态枚举过程**：  
   - 屏幕左侧显示当前枚举的 i（0 的个数），右侧显示计算出的熵值和目标值的误差条。  
   - **误差条颜色**：  
     - 黄色：误差 > 1.0  
     - 蓝色：误差 < 0.1  
   - **自动演示**：AI 模式快速滑动 i 值，找到目标后闪烁提示。  

---

### 核心代码实现  
#### 试题 A 关键代码  
```cpp
int days[] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
for(int m = 1; m <=12; m++) {
    for(int d=1; d<=days[m]; d++) {
        int date[] = {2,0,2,3, m/10, m%10, d/10, d%10};
        int cnt=0;
        for(int i=0; i<100; i++) {
            if(a[i] == date[cnt]) cnt++;
            if(cnt == 8) { ans++; break; }
        }
    }
}
```

#### 试题 B 关键代码  
```cpp
for(int i=1; i<=23333333/2; i++) {
    double p0 = i / 23333333.0;
    double p1 = 1 - p0;
    double h = - (i*p0*log2(p0) + (23333333-i)*p1*log2(p1));
    if(abs(h - 11625907.5798) < 0.01) {
        cout << i; return;
    }
}
```

---

### 最终答案  
试题 A：`235`  
试题 B：`11027421`

---
处理用时：88.68秒
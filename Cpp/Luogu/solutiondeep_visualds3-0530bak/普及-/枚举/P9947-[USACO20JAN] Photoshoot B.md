# 题目信息

# [USACO20JAN] Photoshoot B

## 题目描述

Farmer John 在给他编号为 $1\ldots N$ 的 $N$ 头奶牛排队拍照（$2\le N\le 10^3$）。FJ 一开始计划从左向右数第 $i$ 个位置排编号为 $a_i$ 的奶牛，他在一张纸上写下了排列 $a_1,a_2,\ldots,a_N$。不幸的是，这张纸刚刚被 Farmer Nhoj 偷走了！

幸好 FJ 仍然有机会恢复他之前写下的排列。在这张纸被偷走之前，Bessie 记录了序列 $b_1,b_2,\ldots,b_{N−1}$，对于每一个 $1\le i<N$ 满足 $b_i=a_i+a_{i+1}$。

基于 Bessie 的信息，帮助 FJ 恢复可以产生序列 $b$
的“字典序最小”的排列 $a$。排列 $x$ 字典序小于排列 $y$，如果对于某个 $j$，对于所有 $i<j$ 均有 $x_i=y_i$，且有 $x_j<y_j$（换句话说，这两个排列到某个位置之前都相同，在这个位置上 $x$ 小于 $y$）。保证存在至少一个满足条件的 $a$。 

## 说明/提示

### 样例解释 1

$a$ 能够产生 $b$，因为 $3+1=4$，$1+5=6$，$5+2=7$，$2+4=6$。

### 测试点性质

 - 测试点 $2-4$ 满足 $N\le 8$。
 - 测试点 $5-10$ 没有额外限制。

## 样例 #1

### 输入

```
5
4 6 7 6```

### 输出

```
3 1 5 2 4```

# AI分析结果



## 算法分类
**构造 + 枚举**

---

## 题解思路与核心难点

### 核心思路
1. **构造推导**：根据相邻和的特性，若确定第一个元素 $a_1$，即可递推得到整个数组 $a$。
2. **枚举策略**：从小到大枚举 $a_1$ 的可能值，范围限制为 $1 \le a_1 \le \min(b_1-1, n)$，以确保后续生成的元素均为正整数且不超过 $n$。
3. **合法性检查**：生成过程中实时检查每个元素是否在 $[1, n]$ 范围内且无重复，发现非法情况立即终止，提升效率。

### 解决难点
- **字典序最小**：通过从小到大枚举 $a_1$，找到第一个合法的序列即为字典序最小。
- **高效验证**：在生成过程中即时检查元素合法性和重复性，避免完全生成后再验证的时间浪费。

---

## 题解评分（≥4星）

### 1. 作者：DFs_YYDS（4.5星）
- **亮点**：生成过程中实时检查元素合法性，代码简洁清晰。
- **代码片段**：
  ```cpp
  bool check(int i) {
      bool vis[1005] = {0};
      a[1] = i;
      for (int j = 2; j <= n; j++) {
          a[j] = b[j-1] - a[j-1];
          if (a[j] < 1 || a[j] > n || vis[a[j]]) return false;
          vis[a[j]] = 1;
      }
      return true;
  }
  ```

### 2. 作者：lbh666（4星）
- **亮点**：正确限制枚举范围到 $1 \le a_1 \le b_1-1$，提升效率。
- **代码片段**：
  ```cpp
  for (int i = 1; i < b[1]; i++) {
      memset(vis, 0, sizeof(vis));
      a[1] = i;
      // ... 生成并检查序列
  }
  ```

### 3. 作者：Officer（4星）
- **亮点**：代码简洁直观，适合快速理解核心逻辑。
- **代码片段**：
  ```cpp
  for (int j = 1; j <= n-1; j++) {
      a[j+1] = b[j] - a[j];
      if (a[j+1] < 1 || vis[a[j+1]]) break;
      vis[a[j+1]] = 1;
  }
  ```

---

## 最优思路与技巧提炼
1. **关键技巧**：
   - **递推构造**：利用 $a_{i+1} = b_i - a_i$ 递推生成数组。
   - **剪枝优化**：在生成过程中即时终止非法分支，减少无效计算。
2. **数据结构**：使用桶数组（`vis`）记录元素出现情况，实现 $O(1)$ 的重复性检查。

---

## 相似题目推荐
1. **P1008 三连击**：构造三位数组合，满足比例条件。
2. **P1321 单词覆盖**：贪心或枚举构造字符串。
3. **P1094 纪念品分组**：贪心配对构造最小分组。

---

## 可视化设计（复古像素风格）

### 动画设计
- **像素化界面**：以 8-bit 风格展示枚举过程，每个 $a_i$ 生成时显示为像素块。
- **动态高亮**：合法元素显示为绿色，非法元素为红色，当前操作的 $a_1$ 高亮为黄色。
- **音效提示**：生成合法元素时播放清脆音效，发现非法时播放低沉音效。

### 交互设计
- **步进控制**：用户可手动点击生成下一步，或自动播放观察算法流程。
- **参数调节**：允许调整枚举速度和动画速度，增强学习灵活性。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, b[1005], a[1005];
bool vis[1005];

bool check(int first) {
    memset(vis, 0, sizeof(vis));
    a[1] = first;
    vis[first] = true;
    for (int i = 2; i <= n; i++) {
        a[i] = b[i-1] - a[i-1];
        if (a[i] < 1 || a[i] > n || vis[a[i]]) return false;
        vis[a[i]] = true;
    }
    return true;
}

int main() {
    cin >> n;
    for (int i = 1; i < n; i++) cin >> b[i];
    for (int i = 1; i <= min(b[1]-1, n); i++) { // 正确限制枚举范围
        if (check(i)) {
            for (int j = 1; j <= n; j++) cout << a[j] << " ";
            return 0;
        }
    }
    return 0;
}
```

---

## 总结
本题通过递推构造和剪枝优化，实现了高效的字典序最小排列恢复。核心在于合理限制枚举范围，并在生成过程中即时验证，确保算法效率。可视化设计通过复古风格和交互功能，直观展示算法流程，增强学习趣味性。

---
处理用时：161.93秒
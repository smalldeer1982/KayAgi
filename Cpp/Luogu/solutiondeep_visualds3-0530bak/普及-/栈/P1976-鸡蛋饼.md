# 题目信息

# 鸡蛋饼

## 题目背景

Czyzoiers 都想知道小 x 为什么对鸡蛋饼情有独钟。经过一番逼问，小 x 道出了实情：因为他喜欢圆。


## 题目描述

最近小 x 又发现了一个关于圆的有趣的问题：在圆上有 $2N$ 个不同的点，小 x 想用 N 条线段把这些点连接起来（每个点只能连一条线段）， 使所有的线段都不相交，他想知道这样的连接方案有多少种？


## 样例 #1

### 输入

```
24```

### 输出

```
4057031```

# AI分析结果



## 算法分类
组合数学/卡特兰数

## 题解思路与核心分析

### 核心逻辑与推导
所有题解均基于卡特兰数的以下两个核心性质：
1. **递推公式**：$h(n) = \sum_{i=0}^{n-1} h(i) \cdot h(n-i-1)$
2. **组合数公式**：$h(n) = \frac{C(2n,n)}{n+1}$

**递推式推导**：固定一个点，将其与其他点连线将圆分割为两个子区域。若左侧有i对点，右侧则有n-i-1对点，形成子问题相乘关系。

### 解决难点对比
| 题解类型       | 数据结构          | 辅助方法                     | 核心优化点                 |
|----------------|-------------------|-----------------------------|---------------------------|
| 递推法         | 一维数组          | 双重循环累加                | 直接实现递推式，代码最简洁 |
| 组合数逆元法   | 阶乘数组          | 扩展欧几里得/快速幂求逆元   | 数学推导更复杂但效率更高   |
| O(n)递推法     | 逆元预计算数组    | 数学公式推导优化            | 时间复杂度和空间最优       |

## 题解评分（≥4星）

1. **WHUSHZ（5星）**  
   - 清晰的特例分析推导递推式
   - 代码简洁易读，适合算法入门
   - 包含图形化分割示意图

2. **NewSjf（5星）**  
   - O(n)时间复杂度实现
   - 逆元预计算提升效率
   - 代码仅需10行，空间复杂度O(n)

3. **Fan_Keyou（4星）**  
   - 详细解释卡特兰数与题目的联系
   - 提供组合数公式的逆元实现
   - 代码包含中文注释说明

## 最优技巧提炼

1. **递推式记忆化**  
   通过数组存储已计算值，避免重复递归（WHUSHZ代码片段）：
   ```cpp
   for(i=3; i<=n; ++i)
       for(j=0; j<i; ++j)
           ctl[i] += ctl[j] * ctl[i-j-1];
   ```

2. **逆元预处理优化**  
   通过公式$inv[i] = (mod - mod/i) \cdot inv[mod\%i] \% mod$预计算逆元（NewSjf代码片段）：
   ```cpp
   for(int i=2;i<=n+10;i++) 
       inv[i]=(p-p/i)*inv[p%i]%p;
   ```

3. **组合数公式转化**  
   将分数取模转化为乘法逆元（litble代码思想）：
   ```cpp
   ans = (C(2n,n) * inv(n+1)) % mod
   ```

## 同类问题与推荐题目

**类似算法套路**：  
- 栈序列合法性（P1044）
- 凸多边形三角划分（P4170）
- 二叉树形态计数

**推荐练习题目**：  
1. P1044 栈（卡特兰数基础应用）
2. P1976 鸡蛋饼（本题的双倍经验）
3. P1754 球迷购票问题（二维卡特兰数变式）

## 个人心得摘录

1. **WHUSHZ**：  
   > "定弦是一种遍历的方式，所有切法必然包含所有点，不需要乘以任何系数"  
   （关键点：圆环问题的对称性处理）

2. **NewSjf**：  
   > "inv[i] = p - (p/i) * inv[p%i] % p 这个公式可以O(n)预计算逆元"  
   （逆元计算的数学技巧）

3. **Daidly**：  
   > "边加边取模，否则只能得60分"  
   （取模运算的实践教训）

## 算法可视化设计

### 核心动画方案
1. **圆环分割演示**  
   - 使用Canvas绘制圆环和随机点
   - 点击任意点触发分割动画：
     - 红色线段表示当前连线
     - 黄色/蓝色区域表示子问题
     - 子区域自动收缩显示递归过程

2. **递推式动态展示**  
   ```javascript
   // 伪代码示例
   function drawStep(n) {
       ctx.clearRect(0, 0, width, height);
       drawCircleWithPoints(2n); // 绘制圆环和点
       let k = currentSplitPoint; // 当前分割点
       drawRedLine(0, 2k+1);     // 高亮当前连线
       fillSubArea(0, k, "yellow"); // 填充子区域
       fillSubArea(k+1, 2n, "blue");
       playSound("split.wav");   // 分割音效
   }
   ```

### 复古游戏化设计
1. **8-bit风格元素**  
   - 使用NES调色板的#FF0000（红）、#FFFF00（黄）、#0000FF（蓝）
   - 像素化线段（4px宽度）
   - 8-bit音效：分割时播放《超级马里奥》金币声效

2. **自动演示模式**  
   ```javascript
   let autoPlay = setInterval(() => {
       currentSplitPoint = (currentSplitPoint + 1) % n;
       drawStep(currentSplitPoint);
       if(currentSplitPoint === n-1) playVictoryJingle();
   }, 1000);
   ```

3. **积分系统**  
   - 正确分割+10分（显示COMBO!特效）
   - 错误分割（奇数点）扣5分，播放爆炸动画
   - 累计100分解锁"卡特兰大师"成就

## 完整代码示例（递推法）
```cpp
#include<iostream>
using namespace std;
const int MOD = 100000007;
long long c[30000];

int main() {
    int n; 
    cin >> n;
    c[0] = 1;
    for(int i=1; i<=n; ++i)
        for(int j=0; j<i; ++j)
            c[i] = (c[i] + c[j]*c[i-j-1]) % MOD;
    cout << c[n];
    return 0;
}
```

---
处理用时：69.78秒
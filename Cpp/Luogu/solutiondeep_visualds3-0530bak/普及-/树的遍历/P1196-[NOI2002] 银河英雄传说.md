# 题目信息

# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 说明/提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)

题目中没有强制 $i \neq j$，但是实测数据中不存在 $i = j$ 的情况。

## 样例 #1

### 输入

```
4
M 2 3
C 1 2
M 2 4
C 4 2```

### 输出

```
-1
1```

# AI分析结果



# 银河英雄传说题解分析

## 算法分类
带权并查集

---

## 核心思路与难点

### 算法要点
1. **双权值维护**：每个节点维护两个权值
   - `front[i]`：i到父节点的距离
   - `size[i]`：以i为根的集合总大小（仅根节点有效）
2. **路径压缩优化**：在find()时动态更新front值
3. **合并策略**：合并时将被合并树的根节点front值设为目标树的size

### 解决难点
1. **动态距离计算**：通过路径压缩时的权值累加，保证查询时能直接通过front差值计算间距
2. **合并顺序处理**：维护size数组确保合并时新front值的正确计算

---

## 最优题解推荐（≥4★）

### 1. 假装思考（4.5★）
**关键亮点**：
- 清晰定义front和size数组
- 路径压缩时front值的动态维护
- 样例解释直观展示合并过程

**代码片段**：
```cpp
int find(int n){
    if(fa[n]==n) return fa[n];
    int fn = find(fa[n]);
    front[n] += front[fa[n]];
    return fa[n] = fn;
}
void merge(int x, int y){
    int fx = find(x), fy = find(y);
    front[fx] = size[fy];
    size[fy] += size[fx];
    fa[fx] = fy;
}
```

### 2. 破壁人（4.2★）
**创新点**：
- 使用三数组结构（f/s/b）
- 更简洁的路径压缩实现
- 合并时直接维护集合大小

**核心逻辑**：
```cpp
int find(int o){
    if(f[o]==o) return o;
    int k = f[o];
    f[o] = find(f[o]);
    s[o] += s[k];
    return f[o];
}
```

### 3. Mr_Wolfram（4.0★）
**特色**：
- 结构体封装节点属性
- 独立维护num数组
- 清晰的查询逻辑

**关键代码**：
```cpp
struct node{
    int lc,rc,fa,dep;
};
void rotate(int x){
    int f = fa[x], gf = fa[f];
    if(gf) ch[gf][ch[gf][1]==f] = x;
    ch[x][!k] = f; ch[f][k] = w;
    fa[w] = f; fa[f] = x; fa[x] = gf;
}
```

---

## 算法可视化设计

### 核心动画逻辑
1. **节点高亮**：
   - 当前操作节点用红色边框
   - 路径压缩路径用黄色渐变
   - 合并操作用绿色箭头连接

2. **状态面板**：
```javascript
class Warship {
    constructor(id) {
        this.id = id;
        this.front = 0;
        this.size = 1;
        this.parent = id;
    }
}

// 可视化步骤示例
function visualizeFind(id) {
    let current = id;
    while (nodes[current].parent !== current) {
        highlightNode(current, 'path'); // 黄色高亮
        current = nodes[current].parent;
    }
    // 回溯时更新front值
    backtrackUpdateFront(id); 
}
```

3. **复古像素风格**：
```css
.node {
    width: 32px;
    height: 32px;
    image-rendering: pixelated;
    background: url('ship-8bit.png');
}

.status-bar {
    font-family: 'Press Start 2P', cursive;
    color: #6b8cff; /* FC经典蓝 */
}
```

4. **音效设计**：
   - 路径压缩：8-bit "blip" 音效
   - 合并成功：上升音阶
   - 查询失败：短促警报声

---

## 扩展练习
1. P2342 星球大战（三维空间版）
2. P1197 星球大战（动态连通性）
3. P1525 关押罪犯（权值判断）

---

## 总结
通过维护动态权值的并查集结构，完美解决了战舰队列的合并与间距查询问题。其核心在于路径压缩时的权值累加与合并时的size更新策略，该思路可推广至各类需要维护元素间关系的连通性问题。

---
处理用时：63.81秒
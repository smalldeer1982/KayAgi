# 题目信息

# 【模板】双端队列 1

## 题目背景

Aya 衷心祝愿大家不再因为 `std::deque` 重蹈覆辙。

## 题目描述

请你实现 $m$ 个双端队列，支持如下的 $q$ 次操作：

- `push_back(a,x)`：在第 $a$ 个双端队列中从尾部插入一个元素 $x$；
- `pop_back(a)`：在第 $a$ 个双端队列中从尾部弹出一个元素。
- `push_front(a,x)`：在第 $a$ 个双端队列中从头部插入一个元素 $x$；
- `pop_front(a)`：在第 $a$ 个双端队列中从头部弹出一个元素。
- `size(a)`：查询第 $a$ 个双端队列的元素个数；
- `front(a)`：查询第 $a$ 个双端队列的队首元素；
- `back(a)`：查询第 $a$ 个双端队列的队尾元素；

对于 `pop_back`，`pop_front`，`front` 和 `back` 操作，若当前双端队列为空则不进行，直接跳过该次操作。

## 说明/提示

**【数据范围】**

| 子任务 | $m \leq$ | $q \leq$ | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $10$ | $10$ | $10$ |
| $2$ | $2000$ | $2000$ | $20$ |
| $3$ | $10^5$ | $10^5$ | $30$ |
| $4$ | $10^6$ | $10^6$ | $40$ |

对于所有数据，$1 \leq m,q \leq 10^6$，$1 \leq x \leq 10^9$。

## 样例 #1

### 输入

```
10
pop_back 2
push_back 1 1
push_front 1 3
push_front 2 2
push_front 2 3
pop_back 1
size 1
push_back 2 3
back 1
front 1```

### 输出

```
1
3
3
```

# AI分析结果



**唯一算法分类**：无算法分类

---

### **综合分析与结论**
题目要求高效管理多个双端队列，核心难点在于**空间优化**与**操作效率**的平衡。两种题解分别采用不同数据结构实现：
1. **STL 的 `std::list`**：通过链表的动态内存分配避免预占用过多空间，但链表节点分散导致缓存不友好，高频操作性能较差。
2. **自定义循环队列**：基于动态数组实现，通过倍增扩容与缩容策略保证均摊 $O(1)$ 操作时间，内存连续且空间利用率高。

**核心算法流程**：
- **动态数组设计**：每个队列维护一个循环数组，初始容量为 $2^n$，通过 `head` 和 `tail` 指针记录首尾位置。
- **扩容/缩容策略**：
  - **扩容**：当插入元素后元素数量等于数组大小时，创建两倍大小的新数组，复制数据并更新指针。
  - **缩容**：当删除元素后元素数量小于当前容量的四分之一时，创建一半大小的新数组，复制数据并更新指针。
- **位运算优化**：利用 `v & (size-1)` 代替取模运算，提升计算效率。

**可视化设计思路**：
- **像素风格动画**：用色块表示数组元素，头尾指针用箭头高亮。扩容/缩容时，旧数组淡出，新数组淡入，伴随“升级/降级”音效。
- **交互控制**：允许单步执行观察指针移动和数组变化，速度调节支持快速查看高频操作效果。
- **音效提示**：插入/删除操作触发短促音效，扩容/缩容时播放明显音调变化。

---

### **题解清单 (≥4星)**

1. **pulsar_ 的循环队列实现（5星）**
   - **亮点**：动态数组与位运算优化显著提升性能，内存占用仅为 $O(n)$，实测效率远超 STL 容器。
   - **代码可读性**：模板化设计支持复用，关键逻辑封装清晰。

---

### **核心代码实现**

```cpp
template<typename T>
struct Deque {
    T *data;
    int head, tail, capacity;

    Deque() : head(0), tail(0), capacity(1) {
        data = new T[capacity];
    }

    void resize(int new_cap) {
        T *new_data = new T[new_cap];
        int idx = 0;
        for (int i = head; i != tail; i = (i+1) & (capacity-1))
            new_data[idx++] = data[i];
        delete[] data;
        data = new_data;
        head = 0;
        tail = idx;
        capacity = new_cap;
    }

    void push_back(T x) {
        if ((tail + 1) % capacity == head) resize(capacity << 1);
        data[tail] = x;
        tail = (tail + 1) & (capacity - 1);
    }

    // 其余操作类似，略...
};
```

---

### **同类型题推荐**
1. **滑动窗口最大值（洛谷 P1886）**：需双端队列维护窗口极值。
2. **合并果子（洛谷 P1090）**：优先队列动态调整，类似动态数组思想。
3. **单调队列（洛谷 P1714）**：双端队列优化 DP 转移。

---

### **复古游戏化动画设计**
- **像素风格**：16色调色板，数组元素用 8x8 像素块表示，头尾指针用红/蓝箭头。
- **音效设计**：插入/删除播放“哔”声，扩容播放上升音阶，缩容播放下降音阶。
- **自动演示模式**：模拟随机操作序列，展示队列动态调整过程，右上角显示内存占用变化曲线。

---

### **总结**
自定义循环队列通过动态内存管理与位运算优化，完美平衡时间与空间需求，是解决大规模双端队列问题的首选方案。

---
处理用时：97.41秒
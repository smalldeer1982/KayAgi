# 题目信息

# [语言月赛 202312] 打表过样例

## 题目背景

众所周知，一名负责任的出题人，不应当让如下的打表程序获得过多的分数。

```cpp
#include<iostream>
int main() {
    std::cout << "Specific Value\n";
}
```

> 这个程序的功能是，输出一个特定的内容，以尝试通过一些测试点而获得分数。
> 
> 经典的例子是：<https://www.luogu.com.cn/problem/P8819>，输出无解可以获得 45 分的成绩。

## 题目描述

很不幸，你遇到了不负责任的出题人。

在某道试题里，共有 $N$ 个测试点，组成了 $k$ 个 Subtask，第 $i$ 个 Subtask 包含 $p_i$ 个测试点，第 $j$ 个测试点的编号为 $w_{i,j}$。请注意，一个测试点可能属于多个 Subtask。

> **Subtask**
>
> 每个 Subtask 包含多个测试点和一个分值，当且仅当通过全部这些测试点时，才能获得这个 Subtask 的分值。一道题目的得分为通过的所有 Subtask 分值之和。

这是一道输出仅有一个数的题目，编号为 $i$ 的测试点，标准答案为 $A_i$。

很不幸，由于命题人不负责任，$A_i$ 中出现了大量重复，让打表选手有了可乘之机。

现在，你通过某种手段获得了全部的数据，请问输出哪个数，可以得到最高的分数？最高的分数是多少？

如果有多个数均可得到最高的分数，你只需要任意给出一个。

## 说明/提示

### 数据规模与约定

- 对于 $30\%$ 的测试数据，$1 \le N \le 100$，$1 \le k,p_i \le 10$，$1 \le A_i \le 100$。
- 对于 $100\%$ 的测试数据，$1 \le N \le 10^5$，$1 \le k,p_i \le 5000$，$1 \le w_{i,j} \le N$，$1 \le S_i \le 10^9$，$1 \leq A _ i \leq 10 ^ 9$。

## 样例 #1

### 输入

```
2
3 1 2 3 5
3 4 5 6 7
6
4 4 4 5 5 5
```

### 输出

```
7
5
```

# AI分析结果



**唯一算法分类**  
哈希表与排序

**综合分析与结论**  
本题需找出一个输出值，使得能覆盖最多全同测试点的Subtask，总得分最高。核心思路是遍历每个Subtask，判断其所有测试点答案是否相同，若相同则将该值对应的分数累加，最终求最大值。

**难点与解决**  
1. **大规模数据下的值域处理**：直接开桶存储不可行（答案值达1e9），改用结构体数组存储有效（答案值，分数）对，排序后分段统计。  
2. **高效判断全同Subtask**：遍历测试点时，比较相邻元素，发现不同立即终止检查，优化时间。  
3. **排序与统计**：按答案值排序后，线性扫描累加相同值的分数，记录最大值。

**可视化设计要点**  
1. **像素风格动画**：  
   - 用不同颜色方块表示Subtask，绿色表示全同，红色表示不同。  
   - 排序过程展示结构体数组的分段合并，相同值方块合并并显示分数累加。  
   - 最终结果以闪烁金色方块高亮显示最大值。  
2. **音效与交互**：  
   - 判断Subtask时播放短音效（成功/失败音）。  
   - 排序过程配8-bit风格背景音乐。  
   - 用户可调整动画速度，单步观察分数累加过程。

**题解清单 (5星)**  
1. **览遍千秋的题解**  
   - **核心亮点**：巧妙利用排序替代大值域哈希表，时间复杂度控制合理。  
   - **代码优化**：提前终止Subtask检查，减少冗余比较。  
   - **评分理由**：思路清晰，代码简洁，处理大数据高效。

**最优思路提炼**  
1. **结构体排序替代哈希**：解决大值域存储问题。  
2. **相邻元素比较法**：快速判断Subtask全同性。  
3. **分段累加统计**：线性时间复杂度求最大值。

**相似题目推荐**  
1. **P8819**（打表得分原题）  
2. **P1056**（统计众数）  
3. **P1908**（逆序对，排序应用）

**核心代码实现**  
```cpp
struct Node { int val; long long score; } ans[5005];
int cnt = 0;

for (int i = 0; i < k; ++i) {
    bool valid = true;
    int first = A[w[i][0]];
    for (int j = 1; j < p[i]; ++j) {
        if (A[w[i][j]] != first) {
            valid = false;
            break;
        }
    }
    if (valid) ans[cnt++] = {first, s[i]};
}

sort(ans, ans + cnt, [](Node a, Node b) { return a.val < b.val; });

long long max_score = 0, current = 0;
int result_val = 0;
for (int i = 0; i < cnt; ++i) {
    if (i > 0 && ans[i].val != ans[i-1].val) current = 0;
    current += ans[i].score;
    if (current > max_score) {
        max_score = current;
        result_val = ans[i].val;
    }
}
```

**可视化代码片段（伪代码）**  
```javascript
// 绘制Subtask检查过程
function drawSubtaskCheck(subtaskId, isValid) {
    ctx.fillStyle = isValid ? '#00FF00' : '#FF0000';
    drawSquare(subtaskId % 10, Math.floor(subtaskId / 10));
    playSound(isValid ? 'success' : 'fail');
}

// 排序动画
async function sortAndMerge() {
    ans.sort((a,b) => a.val - b.val); 
    for (let i=0; i<ans.length; ) {
        let j = i, total = 0;
        while (j < ans.length && ans[j].val == ans[i].val) {
            total += ans[j++].score;
        }
        mergeBlocks(i, j-1, total); // 合并相同值方块
        i = j;
    }
}
```

**心得摘录**  
"处理大值域时，排序分段统计比哈希更高效。注意测试点索引的起始位置，极易引发越界错误。" —— 览遍千秋

---
处理用时：123.69秒
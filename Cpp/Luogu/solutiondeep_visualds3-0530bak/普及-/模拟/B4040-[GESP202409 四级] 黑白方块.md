# 题目信息

# [GESP202409 四级] 黑白方块

## 题目描述

小杨有一个 $n$ 行 $m$ 列的网格图，其中每个格子要么是白色，要么是黑色。
小杨想知道网格图中是否存在一个满足如下条件的子矩形：
- 子矩形由 $4$ 行 $4$ 列组成；
- 子矩形的第 $1$ 行和第 $4$ 行只包含白色格子；
- 对于子矩形的第 $2$ 行和第 $3$ 行，只有第 $1$ 个和第 $4$ 个格子是白色的，其余格子都是黑色的；

请你编写程序帮助小杨判断。

## 说明/提示

### 样例 1 解释

```plain
0000
0110
0110
0000
```

### 数据规模与约定

对全部的测试数据，保证 $1 \leq t\leq 10$，$1 \leq n,m \leq 100$。

## 样例 #1

### 输入

```
3
1 4
0110
5 5
00000
01100
01100
00001
01100
5 5
00000
01100
01110
00001
01100```

### 输出

```
No
Yes
No```

# AI分析结果



---

**算法分类**  
枚举法/模拟

---

**综合分析与结论**  
题目要求在网格中寻找特定结构的 4×4 子矩形。核心思路是枚举所有可能的左上角起点，并通过模板匹配快速验证。关键点包括：
1. **枚举范围**：遍历所有可能的左上角坐标 `(i,j)`，确保子矩阵不越界（`i ≤ n-4`, `j ≤ m-4`）。
2. **模板匹配**：预定义目标子矩形的结构（常量数组 `g`），逐元素对比以判断是否匹配。
3. **复杂度控制**：暴力枚举的时间复杂度为 `O(n×m×16)`，在题目数据规模下完全可行。

**可视化设计思路**：
- **高亮当前枚举区域**：在网格中以动态方框标记当前正在检查的 4×4 子矩阵。
- **逐元素对比动画**：按行列顺序逐个比对元素，不匹配时闪烁提示错误位置。
- **像素风格与音效**：采用 8-bit 风格渲染网格，匹配成功时播放胜利音效，失败时播放错误音效。

---

**题解清单 (≥4星)**  
1. **chen_zhe（5星）**  
   - **亮点**：模板匹配简化逻辑，双重循环边界处理清晰，代码可读性极佳。
   - **代码片段**：
     ```cpp
     const char g[4][4] = {'0','0','0','0', '0','1','1','0', '0','1','1','0', '0','0','0','0'};
     bool check(int x, int y) {
         for (int i=0; i<4; i++)
             for (int j=0; j<4; j++)
                 if (c[x+i][y+j] != g[i][j]) return false;
         return true;
     }
     ```

---

**最优思路与技巧**  
- **预定义模板法**：将目标结构硬编码为常量数组，避免动态条件判断，减少代码复杂度。
- **行列边界优化**：枚举时直接限制 `i ≤ n-4` 和 `j ≤ m-4`，避免冗余越界检查。
- **提前终止**：在 `check` 函数中一旦发现不匹配立即返回，减少无效计算。

---

**同类型题与算法套路**  
- **题型**：二维矩阵的模式匹配、特定子结构搜索。
- **通用解法**：暴力枚举所有可能子结构 + 快速验证（模板或规则判断）。

---

**推荐练习题**  
1. **P1731 矩阵覆盖**（二维枚举与条件判断）
2. **P3397 地毯**（二维差分与覆盖统计）
3. **P2676 超级书架**（子矩阵性质分析）

---

**个人心得摘录**  
- **边界陷阱**：初始代码曾因 `n-3` 写成 `n-4` 导致漏判，调试时需特别注意行列计算。
- **模板对齐**：常量数组的索引需与原矩阵严格对齐，避免行列错位。

---

**核心代码实现**  
```cpp
#include <iostream>
using namespace std;

const char g[4][4] = {
    '0','0','0','0',
    '0','1','1','0',
    '0','1','1','0',
    '0','0','0','0'
};
char c[105][105];

bool check(int x, int y) {
    for (int i=0; i<4; i++)
        for (int j=0; j<4; j++)
            if (c[x+i][y+j] != g[i][j]) return false;
    return true;
}

int main() {
    int t; cin >> t;
    while (t--) {
        int n, m; cin >> n >> m;
        for (int i=1; i<=n; i++) cin >> (c[i]+1);
        bool flag = false;
        for (int i=1; i<=n-3; i++)
            for (int j=1; j<=m-3; j++)
                if (check(i,j)) flag = true;
        cout << (flag ? "Yes" : "No") << endl;
    }
    return 0;
}
```

---

**可视化与复古游戏化设计**  
1. **像素渲染**：用 Canvas 绘制网格，每个格子为 16×16 像素，白色（#FFFFFF）和黑色（#000000）区分状态。  
2. **扫描动画**：红色方框从左上角向右下角逐格移动，标记当前检查的子矩阵区域。  
3. **音效触发**：  
   - **匹配成功**：播放 8-bit 风格“胜利”音效（高频短音）。  
   - **匹配失败**：播放低频“错误”音效，当前不匹配格子闪烁红色。  
4. **自动演示模式**：算法自动以 500ms/步的速度遍历所有可能区域，用户可暂停/调整速度。  

**交互示例**：  
```javascript
// 伪代码：Canvas 绘制与音效
function drawGrid() {
    for (let i=0; i<n; i++) {
        for (let j=0; j<m; j++) {
            ctx.fillStyle = grid[i][j] ? '#000' : '#FFF';
            ctx.fillRect(j*16, i*16, 16, 16);
        }
    }
}
function playSound(freq) {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = freq;
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

---
处理用时：103.29秒
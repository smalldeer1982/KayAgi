# 题目信息

# [语言月赛 202412] 顽强拼搏奖的四种发法

## 题目描述

在 XCPC 竞赛里，会有若干道题目，一支队伍可以对每道题目提交若干次。我们称一支队伍对一道题目的一次提交是有效的，当且仅当：

- 在本次提交以前，还未通过该题目。
- 本次提交的题目在比赛里最终被该队伍通过了。

注意，事实上，在通过一道题目后，一支队伍仍然可以提交该题目。这样的提交是**无效提交**，同时，无论这样的提交是否通过，都不会影响该队伍**已通过**该题目的状态。

我们按顺序给出本场比赛所有队伍的全部提交记录，每条记录是一个三元组 $(tid_i, pid_i, state_i)$，其中 $tid_i$ 表示提交这条记录的队伍编号，$pid_i$ 表示这条记录所提交的题目编号，$state_i$ 表示这条记录的状态是未通过/通过。

如果一支队伍在比赛里通过了至少 $k$ 道不同的题目，则它们获得了奖牌。

你要求出本场比赛的**顽强拼搏奖**归属于哪支队伍。很遗憾的是，每个主办方对顽强拼搏奖的定义是不同的，因此你需要按如下四种计算方法分别计算获得顽强拼搏奖所归属的队伍编号：

1. 最后一次 AC 记录所对应的队伍。
2. 最后一次**有效** AC 记录所对应的队伍。
3. 未获得奖牌的队伍的最后一次**有效** AC 提交对应的队伍。
4. 最后一次使得一支队伍的通过题目数由 $0$ 变成 $1$ 的提交所对应的队伍。


## 说明/提示

### 样例 1 解释

这个样例共有 $4$ 支队伍，两道题目。解出两道题目的队伍可以获奖。

- 整场比赛的最后一次 AC 提交是第八条记录，$1$ 号队伍提交第二题通过。因此第一种定义计算出的顽强拼搏奖是队伍 $1$；  
- 队伍 $1$ 在第二条记录时就已通过第二题，所以第八条记录不是一条有效提交记录。最后一条 AC 的有效提交记录是第七条。因此第二种定义计算出的顽强拼搏奖是队伍 $2$；  
- 只有队伍 $3$ 没有获奖，它们的最后一次提交是第四条记录，因此按第三种定义计算的顽强拼搏奖是队伍 $3$；  
- 队伍 $4$ 是最后一个通过题目数由 $0$ 题变为 $1$ 题的队伍。其对应的提交记录是第五条。因此按第四种定义计算的顽强拼搏奖是队伍 $4$。

### 数据规模与约定

| 测试点编号 | $n$ | $t$ | $p$ | 特殊约定 |
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $=1$ | $=1$ | $=1$ | 无 |
| $2,3$ | $\leq 100$ | $=1$ | $\leq 100$ | 无 |
| $4,5$ | $\leq 100$ | $\leq 100$ | $=1$ | 无 |
| $6,7$ | $\leq 1000$ | $\leq 100$ | $\leq 100$ | 一支队伍只会通过一道题至多一次 |
| $8,9,10$ | $\leq 1000$ | $\leq 100$ | $\leq 100$ | 无 |

对全部的测试数据，保证 $1 \leq n \leq 1000$，$1 \leq tid_i \leq t \leq 100$，$1 \leq pid_i \leq p \leq 100$，$1 \leq k \leq p$，$0 \leq state_i \leq 1$。

## 样例 #1

### 输入

```
8 4 2 2
1 1 1
1 2 1
2 2 1
3 1 1
4 1 1
4 2 1
2 1 1
1 2 1```

### 输出

```
1 2 3 4```

# AI分析结果



---

## 算法分类
**模拟**

---

## 综合分析与结论
本题考察对复杂条件的模拟能力，核心难点在于正确处理四种不同规则下的状态维护。需重点关注：

1. **两次遍历的必要性**  
   - 第一次遍历动态维护**最终通过状态**（确定获奖队伍）
   - 第二次遍历动态维护**有效提交状态**（处理四种规则）

2. **状态维护的精确性**  
   - 有效 AC 的判断必须基于提交时的实时状态，而非最终状态
   - 情况四（从 0 到 1）需要精确计算提交前的通过题数

---

## 题解评分与关键亮点
当前题解存在**逻辑错误**，评分：★★★☆☆  
**错误点**：第一次遍历中错误地将所有 `state=1` 的提交视为有效，导致获奖队伍判断错误。  
**修正思路**：  
- 第一次遍历应动态维护每个队伍每题的通过状态，仅当提交是有效时才标记通过。  
- 示例修正代码片段：
```cpp
// 正确维护最终通过状态的第一次遍历
vector<vector<bool>> final_pass(t+1, vector<bool>(p+1, false));
for (int i = 1; i <= n; ++i) {
    int tid = record[i][0], pid = record[i][1], state = record[i][2];
    if (state == 1 && !final_pass[tid][pid]) {
        final_pass[tid][pid] = true;
    }
}
```

---

## 最优思路与技巧
1. **双动态维护**  
   - 最终状态与实时状态分离维护，避免逻辑混淆。
2. **倒序处理优化**  
   对情况一（最后一次 AC）可从后往前扫描，找到第一个 `state=1` 的记录即得结果。
3. **计数器复用**  
   在第二次遍历时同步维护每个队伍的实时通过题数，避免重复计算。

---

## 同类型题推荐
1. **P1056 排座椅**（模拟+贪心）  
2. **P1162 填涂颜色**（状态扩散模拟）  
3. **P3958 奶酪**（条件判断与几何模拟）

---

## 可视化设计
### 算法演示方案
- **网格动画**：以队伍为行、题目为列绘制网格，不同颜色表示通过状态。  
- **提交高亮**：当前处理的提交记录用闪烁边框标记，有效 AC 时对应格子变绿。  
- **计数器面板**：实时显示各队伍的通过题数和获奖状态。  

### 复古像素风格
- **8 位音效**：有效 AC 时播放短促 "哔" 声，队伍获奖时播放胜利音效。  
- **Canvas 绘制**：提交记录以像素方块流形式滚动，关键操作触发动画特效。  

---

## 代码实现（修正核心逻辑）
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n, t, p, k;
    cin >> n >> t >> p >> k;
    vector<array<int, 3>> records(n+1);
    vector<vector<bool>> final_pass(t+1, vector<bool>(p+1, false));
    
    // 第一次遍历：确定最终通过状态
    for (int i = 1; i <= n; ++i) {
        int tid, pid, state;
        cin >> tid >> pid >> state;
        records[i] = {tid, pid, state};
        if (state == 1 && !final_pass[tid][pid]) {
            final_pass[tid][pid] = true;
        }
    }
    
    // 确定获奖队伍
    vector<bool> win(t+1, false);
    for (int i = 1; i <= t; ++i) {
        int cnt = 0;
        for (int j = 1; j <= p; ++j) cnt += final_pass[i][j];
        win[i] = (cnt >= k);
    }
    
    // 第二次遍历：处理四种情况
    vector<vector<bool>> current_pass(t+1, vector<bool>(p+1, false));
    vector<int> cnt_pass(t+1, 0);
    int a = -1, b = -1, c = -1, d = -1;
    for (int i = 1; i <= n; ++i) {
        int tid = records[i][0], pid = records[i][1], state = records[i][2];
        if (state == 1) {
            a = tid; // 情况一：最后一次 AC
            if (!current_pass[tid][pid]) { // 有效 AC
                b = tid; // 情况二
                if (!win[tid]) c = tid; // 情况三
                int pre_cnt = cnt_pass[tid];
                current_pass[tid][pid] = true;
                cnt_pass[tid]++;
                if (pre_cnt == 0) d = tid; // 情况四
            }
        }
    }
    cout << a << " " << b << " " << c << " " << d << endl;
    return 0;
}
```

---
处理用时：357.32秒
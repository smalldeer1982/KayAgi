# 题目信息

# [CSP-X2021 山东] 口袋

## 题目描述

克拉拉同学平时就喜欢一些奇奇怪怪的东西，她有一个神奇的口袋，她能从口袋里拿出各种神奇的东西。

某一天她发现口袋里出现了一些像数字形状的物品，我们用 $\tt{0}$ 到 $\tt{9}$ 这十种数字来表示不同的物品。

克拉拉有一个非常喜欢的数字 $x$, 现在她想用口袋里的给出的这些数字形状的物品来组成尽可能多的 $x$，每个物品只能用一次。组装过程中克拉拉发现这些像数字形状的物品中，$\tt{2}$ 和 $\tt{5}$ 倒过来特别像，$\tt{6}$ 和 $\tt{9}$ 倒过来也特别像，所以她可以用 $\tt{2}$ 和 $\tt{5}$ 互相代替，也能用 $\tt{6}$ 和 $\tt{9}$ 互相代替（其他的不能代替）。

举个例子，克拉拉喜欢数 $\tt{42}$，现在口袋里能拿出来顺序为 $\tt{23454}$ 这五种物品，因此她可以用第一个物品 $\tt{2}$ 和第三个物品 $\tt{4}$ 组成 $\tt{42}$（可以组成 $\tt{24}$，但不是需要的），还能用第四个物品 $\tt{5}$ 和第五个物品 $\tt{4}$ 组成 $\tt{42}$（其中 $\tt{5}$ 倒过来可以当作 $\tt{2}$）。

现在想要知道这些物品最多能组成几个克拉拉最喜欢的数字。请你编程帮克拉拉解决这个问题，并输出能用物品组成 $x$ 的最多的个数。

## 说明/提示

样例 1 说明

$(\tt{2},\tt{4})$ 和 $(\tt{5},\tt{4})$ 拼成 $\tt{42}$，其中 $\tt{5}$ 可以倒过来当作 $\tt{2}$。可以证明不能再多拼成一个 $\tt{42}$ 了。

样例 2 说明

$\tt{2}-{\color{red}{\tt{1}}}-\tt{8}-{\color{red}{\tt{9}}}-\tt{1}-{\color{red}{\tt{9}}}-\tt{1}-\tt{9}$，可以用 $(\tt{1},\tt{9},\tt{9})$ 拼成 $\tt{169}$，第一个 $\tt{9}$ 可以倒过来当 $\tt{6}$ 使用。因为每个数字只能用一次，因此最多只能拼成一个 $\tt{169}$。

【数据范围和限制】

对于 $30\%$ 的数据，$1 \leq x \leq 100$，字符串长度不超过 $20$。

其中 $10\%$ 的数据保证 $x < 10$，另外 $10\%$ 的数据保证 $x$ 中不出现 $\tt{2},\tt{5},\tt{6},\tt{9}$。

对于 $60\%$ 的数据，$1 \leq x \leq 1000$, 字符串长度不超过 $100$；

对于 $100\%$ 的数据，$1 \leq x \leq 10^5$，字符串长度不超过 $2\times 10^5$。

## 样例 #1

### 输入

```
42
23454```

### 输出

```
2```

## 样例 #2

### 输入

```
169
21891919```

### 输出

```
1```

## 样例 #3

### 输入

```
801
12345678111```

### 输出

```
0```

# AI分析结果



### 算法分类选择
**无算法分类**

---

### 题解思路与算法要点
1. **核心思路**：统计口袋中每个数字（包括替代组）的总可用次数，并统计目标数字x中每个字符对应的需求次数。通过比较每组可用次数与需求次数的比值，确定最大可组成的x的数量。
2. **关键步骤**：
   - **口袋统计**：将2/5、6/9合并为替代组，统计总次数。
   - **需求统计**：将x中的每个字符转换为对应的替代组，统计每组的需求次数。
   - **最小值计算**：对每组可用次数除以需求次数，取最小结果。
3. **解决难点**：
   - **替代组的合并与分配**：正确处理2/5、6/9的替代关系，避免重复或遗漏。
   - **边界条件处理**：当口袋中某组可用次数不足时，直接返回0。

---

### 核心代码实现
```python
from collections import defaultdict

x = input().strip()
s = input().strip()

# 统计口袋中各字符的出现次数
pocket_count = defaultdict(int)
for c in s:
    pocket_count[c] += 1

# 合并替代组的次数
group_counts = defaultdict(int)
group_counts['2_5'] = pocket_count.get('2', 0) + pocket_count.get('5', 0)
group_counts['6_9'] = pocket_count.get('6', 0) + pocket_count.get('9', 0)
for c in ['0', '1', '3', '4', '7', '8']:
    group_counts[c] = pocket_count.get(c, 0)

# 统计x中各字符对应的组的需求次数
x_group = defaultdict(int)
for c in x:
    if c in {'2', '5'}:
        x_group['2_5'] += 1
    elif c in {'6', '9'}:
        x_group['6_9'] += 1
    else:
        x_group[c] += 1

# 计算最小可用次数
result = float('inf')
for group in x_group:
    required = x_group[group]
    available = group_counts.get(group, 0)
    if available < required:
        print(0)
        exit()
    result = min(result, available // required)

print(result)
```

---

### 算法可视化设计
1. **动画演示**：
   - **步骤1**：将口袋中的字符按替代组分组，用不同颜色块表示各组（如蓝色表示2/5组，绿色表示6/9组）。
   - **步骤2**：逐步遍历x的每个字符，高亮对应的组需求，并从口袋中扣除对应资源。
   - **步骤3**：动态显示每组剩余资源与当前计算结果的最小值。
2. **颜色标记**：
   - **红色**：当前处理的x字符对应的组。
   - **黄色**：资源不足时的高亮提示。
3. **交互控制**：支持暂停/继续，单步执行观察资源扣除过程。

---

### 同类型题推荐
1. **P1603**（斯诺登的密码）——字符替换与组合。
2. **P1012**（拼数）——数字排列与最大值生成。
3. **P1101**（单词方阵）——字符匹配与方向遍历。

---

### 个人心得
- **调试关键**：需特别注意口袋中字符的统计准确性，尤其是替代组的合并。
- **优化点**：用字典合并替代组，避免重复代码，提升可维护性。

---
处理用时：349.55秒
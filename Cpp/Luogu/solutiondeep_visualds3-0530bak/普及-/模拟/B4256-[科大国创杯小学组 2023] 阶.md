# 题目信息

# [科大国创杯小学组 2023] 阶

## 题目背景

小多最近学习了一点数论。

最近她学习了阶这个概念，对算阶很有兴趣。

但是手算阶太难了，请你帮帮她。

## 题目描述

给定一个质数 $ p $，定义一个数 $ x (1 \leq x < p) $ 模 $ p $ 的阶为：最小的正整数 $ t $ 使得 $ x^t $ 模 $ p $ 等于 $1$（即 $ x^t $ 除以 $ p $ 的余数为 $1$），可以证明：这样的正整数一定存在。

现在请你帮助小多算若干组阶。

## 说明/提示

### 样例解释

以第一个和第五个为例。

第一个问题中 $1^1 = 1$，而 $1$ 是最小的正整数，所以显然为答案。

第五个问题中 $2^1 = 2, 2^2 = 4, 2^3 = 8$ 模 $5$ 不为 1，$2^4 = 16$ 模 $5$ 为 $1$，因此 $4$ 为答案。

### 提示

如果你不知道一些数论知识，下面这个信息可能对你有用：可以证明 $x\ (1 \leq x < p)$ 模质数 $p$ 意义下的阶一定小于 $p$。

### 数据范围

对于 $40\%$ 的数据，满足 $p \leq 100$。

对于 $70\%$ 的数据，满足 $p \leq 10^4$。

对于 $100\%$ 的数据，满足 $1 \leq T \leq 10$，$1 \leq x < p \leq 10^5$，保证 $p$ 是质数。

## 样例 #1

### 输入

```
7
2 1
3 1
3 2
5 1
5 2
5 3
5 4```

### 输出

```
1
1
2
1
4
4
2```

# AI分析结果



**唯一算法分类**：数论

---

**综合分析与结论**  
本题要求计算给定质数p和x的阶，即最小的t使得x^t ≡1 (mod p)。核心思路基于数论中的阶性质：阶t必须是p-1的约数。通过分解p-1的质因数生成所有可能的约数，并从小到大检查每个约数是否满足条件。

**核心算法流程**：  
1. **预处理**：计算p-1，分解其质因数。  
2. **生成所有约数**：根据质因数组合生成所有可能的约数，并排序。  
3. **快速幂检查**：从小到大遍历每个约数d，利用快速幂判断x^d ≡1 (mod p)，第一个满足的d即为答案。

**可视化设计思路**：  
- **变量高亮**：展示当前检查的约数d、快速幂计算过程（如指数分解、中间结果）。  
- **动画步骤**：  
  1. 分解质因数时，逐步显示质因数及其指数。  
  2. 生成约数时，动态绘制树状结构，表示质因数的组合。  
  3. 检查每个d时，用颜色标记当前d，并动态显示x^d mod p的计算步骤。  
- **复古风格**：采用8位像素风格，用不同颜色区分质因数、约数及当前操作，音效提示约数检查成功。

---

**题解清单 (4星及以上)**  
1. **数论优化法（5星）**  
   - **亮点**：利用阶的性质缩小搜索范围，快速幂与质因数分解高效结合。  
   - **代码简洁性**：直接调用Python内置`pow`优化快速幂，逻辑清晰。  

---

**代码实现**  
```python
def factor(n):
    factors = []
    i = 2
    while i * i <= n:
        if n % i == 0:
            cnt = 0
            while n % i == 0:
                cnt += 1
                n //= i
            factors.append((i, cnt))
        i += 1
    if n > 1:
        factors.append((n, 1))
    return factors

T = int(input())
for _ in range(T):
    p, x = map(int, input().split())
    if x == 1:
        print(1)
        continue
    m = p - 1
    factors = factor(m)
    factors.sort()
    divisors = [1]
    for prime, exp in factors:
        temp = []
        for d in divisors:
            current = d
            for _ in range(exp):
                current *= prime
                temp.append(current)
        divisors += temp
    divisors = sorted(divisors)
    for d in divisors:
        if pow(x, d, p) == 1:
            print(d)
            break
```

**核心逻辑**：  
- `factor`函数分解质因数，`generate_divisors`生成所有约数并排序。  
- 主循环中，对每个约数使用内置`pow(x, d, p)`快速判断是否满足条件。

---

**同类型题推荐**  
1. **P1226 【模板】快速幂**  
2. **P1069 细胞分裂**（质因数分解应用）  
3. **P2485 计算器**（综合数论问题）

---

**可视化与游戏化设计**  
- **像素动画**：Canvas绘制质因数树，每个节点为质因数及其指数。  
- **音效触发**：检查成功时播放“通关”音效，失败时静音。  
- **自动演示模式**：按空格键逐步执行，或自动播放约数检查流程。

---
处理用时：210.15秒
# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果



### 唯一算法分类  
**枚举/模拟**

---

### 综合分析与结论  
**核心思路**  
所有地毯按顺序铺设，后铺的覆盖先铺的。只需要存储每个地毯的左上角坐标和长宽，逆序遍历地毯数组，找到第一个覆盖目标点的地毯即可。

**核心难点与解决方案**  
1. **空间问题**：直接开二维数组存储每个坐标点会 MLE。  
   - 正确解法：用线性数组存储每个地毯的参数（左上角坐标和长宽），空间复杂度 O(n)。  
2. **覆盖判断**：判断点是否在矩形内需要正确推导边界条件。  
   - 解决公式：`x ∈ [a, a+g]` 且 `y ∈ [b, b+k]`  

**算法可视化设计**  
1. **动画方案**：  
   - 绘制坐标系，用不同颜色方块表示地毯。  
   - 逆序遍历时，高亮当前检查的地毯边界，若覆盖目标点则标记红色，否则标记灰色。  
2. **颜色标记**：  
   - 当前检查的地毯：黄色边框  
   - 覆盖目标点的地毯：红色填充  
   - 已排除的地毯：灰色半透明  
3. **步进控制**：  
   - 支持单步执行观察每个地毯的检查过程。  
   - 找到结果时自动暂停，播放上扬音效。  

**复古像素风格实现**  
- **Canvas 绘制**：用 8x8 像素块表示地毯，坐标轴网格线为深灰色。  
- **音效设计**：  
  - 检查地毯时播放短促“滴”声。  
  - 找到答案时播放经典 FC 过关音效。  
- **自动演示模式**：以 1秒/步的速度逆序自动检查地毯，找到结果后显示闪烁动画。  

---

### 题解清单（≥4星）  
1. **作者：Jayfeather2012（5星）**  
   - 关键亮点：逆序遍历，找到即返回，时间复杂度最优。代码简洁明确。  
   - 核心代码片段：  
     ```cpp
     for(int i=n;i>=1;i--) {
         if(a[i]<=x && x<=a[i]+g[i] && b[i]<=y && y<=b[i]+k[i]) {
             cout<<i; return 0;
         }
     }
     ```

2. **作者：kuaiCreator（4星）**  
   - 关键亮点：结构体存储参数，逆序 break 提前退出。变量命名清晰。  
   - 核心代码片段：  
     ```cpp
     for (int i = n; i >= 1; i--) {
         if (x >= a[i] && x <= a[i] + g[i] && y >= b[i] && y <= b[i] + k[i]) {
             ans = i; break;
         }
     }
     ```

3. **作者：Vct14（4星）**  
   - 关键亮点：预处理右下角坐标，判断逻辑分离。代码可读性强。  
   - 核心代码片段：  
     ```cpp
     l[i].c = l[i].a + l[i].g;
     l[i].d = l[i].b + l[i].k;
     if(x <= l[i].c && x >= l[i].a && y <= l[i].d && y >= l[i].b) {
         cout<<i; return 0;
     }
     ```

---

### 最优思路提炼  
1. **逆序剪枝**：从最后铺的地毯开始检查，找到即返回，避免无效遍历。  
2. **参数存储**：用结构体或数组存储每个地毯的坐标参数，空间复杂度 O(n)。  
3. **边界判断**：闭合区间判断（`<=`和`>=`），正确处理矩形边界点。  

---

### 相似题目推荐  
1. **P1058 立体图**（模拟坐标系覆盖）  
2. **P1181 数列分段Section I**（线性枚举与条件判断）  
3. **P2676 [USACO]Superbull**（逆序贪心选择）  

---

### 核心代码实现  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e4 + 5;
int a[MAXN], b[MAXN], g[MAXN], k[MAXN];

int main() {
    int n, x, y;
    cin >> n;
    for (int i = 1; i <= n; i++) 
        cin >> a[i] >> b[i] >> g[i] >> k[i];
    cin >> x >> y;
    
    for (int i = n; i >= 1; i--) { // 逆序检查关键点
        if (x >= a[i] && x <= a[i] + g[i] && 
            y >= b[i] && y <= b[i] + k[i]) {
            cout << i;
            return 0;
        }
    }
    cout << -1;
    return 0;
}
```

---

### 可视化代码片段（Canvas 动画）  
```javascript
// 初始化 Canvas
const canvas = document.getElementById('demo');
const ctx = canvas.getContext('2d');
const carpets = []; // 存储地毯数据 {a, b, g, k, color}

function drawCarpet(carpet, isCurrent) {
    ctx.fillStyle = isCurrent ? '#FFFF00' : carpet.color;
    ctx.fillRect(carpet.a*scale, carpet.b*scale, carpet.g*scale, carpet.k*scale);
}

function checkPoint(x, y) {
    for (let i = carpets.length - 1; i >= 0; i--) {
        drawCarpet(carpets[i], true); // 高亮当前地毯
        if (x >= carpets[i].a && x <= carpets[i].a + carpets[i].g &&
            y >= carpets[i].b && y <= carpets[i].b + carpets[i].k) {
            playSuccessSound();
            return i + 1; // 返回编号（从1开始）
        }
        await sleep(1000); // 单步间隔
    }
    return -1;
}
```

---
处理用时：92.69秒
# 题目信息

# [NOIP 2009 普及组] 分数线划定

## 题目描述

世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，A 市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的 $150\%$ 划定，即如果计划录取 $m$ 名志愿者，则面试分数线为排名第 $m \times 150\%$（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。

现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。

## 说明/提示

【样例说明】

$m \times 150\% = 3 \times150\% = 4.5$，向下取整后为 $4$。保证 $4$ 个人进入面试的分数线为 $88$，但因为 $88$ 有重分，所以所有成绩大于等于 $88$ 的选手都可以进入面试，故最终有 $5$ 个人进入面试。

NOIP 2009 普及组 第二题


## 样例 #1

### 输入

```
6 3 
1000 90 
3239 88 
2390 95 
7231 84 
1005 95 
1001 88```

### 输出

```
88 5 
1005 95 
2390 95 
1000 90 
1001 88 
3239 88 ```

# AI分析结果



# 算法分类：排序 + 模拟

---

## 综合分析与结论

### 核心算法流程
1. **数据排序**：按成绩降序、同分按报名号升序排序
2. **分数线确定**：取第 m×150%（向下取整）名的成绩
3. **人数统计**：遍历所有考生，统计≥分数线的实际人数
4. **结果输出**：按要求格式输出分数线和所有达标考生

**关键难点**：处理同分情况时，可能出现实际录取人数超出理论值的情况（样例说明中的同分5人录取）。正确做法是遍历所有考生，统计所有≥分数线的实际人数，而非直接取理论值。

**可视化设计要点**：
1. **排序过程**：用不同颜色区分分数段，动态显示比较和交换过程
2. **分数线标记**：高亮第 m×150% 名的位置，并展示后续同分考生
3. **统计动画**：用进度条式遍历，达标考生被标记为绿色
4. **像素风格**：用16色调色板绘制考生队列，成绩用高度不同的柱状图表示

---

## 题解清单 (≥4星)

### 1. 题解作者：2023z (★★★★☆)
**亮点**：
- 使用结构体清晰绑定报名号与成绩
- 先排序后反向遍历确定实际录取人数
- 代码简洁，注释明确
```cpp
for(int i=n;i>=1;i--){ // 反向遍历找最后一个达标者
    if(a[i].s>=x){ j=i; break; }
}
```

### 2. 题解作者：Loyal_Soldier (★★★★☆)
**亮点**：
- 用结构体自带的比较运算符重载
- 直接遍历统计达标人数，逻辑简单直接
```cpp
for(int i=1;i<=n;i++) 
    if(fsx<=a[i].cj) sum++;
```

### 3. 题解作者：Eason_lyx (★★★★☆)
**亮点**：
- 使用 while 循环统计人数，避免反向遍历
- 代码紧凑，无冗余逻辑
```cpp
while(a[cnt+1].s>=sc) cnt++; // 动态扩展达标范围
```

---

## 最优思路与技巧

### 关键技巧
1. **双关键字排序**：优先分数降序，次优报名号升序
2. **分数线动态扩展**：确定理论线后需检查后续同分考生
3. **反向遍历优化**：从理论线位置向后遍历可快速找到实际录取边界

### 代码实现示例
```cpp
struct Candidate {
    int id, score;
} a[5005];

bool cmp(Candidate x, Candidate y) {
    return (x.score != y.score) ? 
        x.score > y.score : x.id < y.id;
}

// 主逻辑
sort(a+1, a+n+1, cmp);
int line_pos = m * 3 / 2; // 自动向下取整
int line_score = a[line_pos].score;

// 动态扩展实际录取人数
int actual_cnt = line_pos;
while(actual_cnt < n && a[actual_cnt+1].score == line_score)
    actual_cnt++;
```

---

## 相似题目推荐
1. **P1177 【模板】快速排序** - 基础排序训练
2. **P1051 谁拿了最多奖学金** - 多条件排序应用
3. **P1781 宇宙总统** - 大数比较与排序

---

## 可视化算法演示

### 动画设计
1. **排序阶段**：
   - 考生数据以像素方块呈现，高度对应分数
   - 比较时高亮当前对比的两个方块（红/蓝）
   - 交换位置时显示移动轨迹

2. **划线阶段**：
   - 用金色横线标记理论分数线
   - 闪烁显示后续同分方块（黄色边框）

3. **统计阶段**：
   - 绿色光晕扫过所有达标方块
   - 底部计数器实时显示达标人数

### 复古风格实现
```javascript
// Canvas 绘制示例
function drawCandidate(ctx, x, y, score, isHighlight) {
    const h = score * 2; // 柱状图高度
    ctx.fillStyle = isHighlight ? '#FF5555' : '#5555FF';
    ctx.fillRect(x, y - h, 30, h); // 绘制柱状图
    if(isHighlight) {
        ctx.strokeStyle = '#FFFF00';
        ctx.strokeRect(x-2, y-h-2, 34, h+4); // 高亮边框
    }
}

// 音效设计
const audioCtx = new AudioContext();
function playBeep(freq) {
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.1);
}
```

---

## 调试心得摘录
> "最初直接取理论线位置的人数，结果WA在样例的同分情况。后来改成遍历统计所有≥分数线的考生才AC。" —— Eason_lyx  
> "将m×1.5转为整数时，发现(int)(m*1.5)会出现浮点误差，改用m*3/2更可靠" —— WsW_

---

## 知识扩展
当遇到多条件排序问题时，可考虑：
1. **元组比较法**：将多个条件编码为可比较的元组（如Python的tuple排序）
2. **分层排序**：优先排关键条件，再处理次要条件
3. **索引排序**：通过下标数组避免移动大对象（如第一个题解的方法）

---
处理用时：75.58秒
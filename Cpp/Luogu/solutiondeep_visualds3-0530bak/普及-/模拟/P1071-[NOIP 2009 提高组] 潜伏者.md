# 题目信息

# [NOIP 2009 提高组] 潜伏者

## 题目描述

R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：

1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母 $\texttt{A}\sim\texttt{Z}$ 构成（无空格等其他字符）；
2. S 国对于每个字母规定了对应的密字。加密的过程就是将原信息中的所有字母替换为其对应的密字；
3. 每个字母只对应一个唯一的密字，不同的字母对应不同的密字。密字可以和原字母相同。

例如，若规定 $\tt A$ 的密字为 $\tt A$，$\tt B$ 的密字为 $\tt C$（其他字母及密字略），则原信息 $\tt ABA$ 被加密为 $\tt ACA$。

现在，小 C 通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小 C 希望能通过这条信息，破译 S 国的军用密码。小 C 的破译过程是这样的：扫描原信息，对于原信息中的字母 $x$（代表任一大写字母），找到其在加密信息中的对应大写字母 $y$，并认为在密码里 $y$ 是 $x$ 的密字。如此进行下去直到停止于如下的某个状态：

1. 所有信息扫描完毕，$\texttt{A}\sim\texttt{Z}$ 所有 $26$ 个字母在原信息中均出现过并获得了相应的密字；
2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现；
3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。

例：

如某条信息 $\tt XYZ$ 被翻译为 $\tt ABA$ 就违反了“不同字母对应不同密字”的规则。

在小 C 忙得头昏脑涨之际，R 国司令部又发来电报，要求他翻译另外一条从 S 国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。


## 说明/提示

【输入输出样例一说明】

原信息中的字母 $\tt A$ 和 $\tt B$ 对应相同的密字，输出 $\tt Failed$。

【输入输出样例二说明】

字母 $\tt Z$ 在原信息中没有出现，输出 $\tt Failed$。

NOIP2009 提高组第一题

## 样例 #1

### 输入

```
AA 
AB 
EOWIE

```

### 输出

```
Failed
```

## 样例 #2

### 输入

```
QWERTYUIOPLKJHGFDSAZXCVBN 
ABCDEFGHIJKLMNOPQRSTUVWXY 
DSLIEWO
```

### 输出

```
Failed 
```

## 样例 #3

### 输入

```
MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP
YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL
FLSO ```

### 输出

```
NOIP```

# AI分析结果



## 算法分类
无算法分类（模拟题）

---

## 题解思路与核心难点
### 核心逻辑
1. **双向映射检查**：确保每个密文字符唯一对应一个原文字符，且原文字符未被其他密文占用。
2. **全字符覆盖检查**：所有 26 个大写字母必须在原信息中出现。
3. **冲突检测**：扫描过程中若发现矛盾（同一密文对应不同原文或同一原文被多个密文占用），立即终止。

### 解决难点
- **双向冲突检测**：需要同时维护密文→原文的映射和原文使用标记，避免双向冲突。
- **高效覆盖检查**：通过字符计数或集合（`set`/`vis`数组）快速判断是否覆盖全部字母。

---

## 题解评分（≥4星）
### 1. 陈嘉逸2012（★★★★★）
- **亮点**：代码简洁，使用 `map<char, char>` 存储映射，`map<char, bool>` 记录原文使用状态，逻辑清晰。
- **关键检查**：遍历时直接检查原文是否被其他密文占用，一步到位解决双向冲突。

### 2. qhr2023（★★★★☆）
- **亮点**：数组替代 `map`，提升效率。`mp[密文] = 原文`，`vis[原文]` 记录占用。
- **优化点**：通过 ASCII 直接索引，避免 `map` 的开销，适合性能敏感场景。

### 3. lianghuahua（★★★★☆）
- **亮点**：使用 `set` 记录已映射的原文，直观展示双向唯一性约束。
- **调试提示**：明确将错误分状态处理，便于理解不同失败场景。

---

## 最优思路提炼
1. **双向唯一映射**：
   - 维护密文→原文的映射表（`map` 或数组）。
   - 维护原文使用标记（`vis`数组或 `set`），确保原文唯一性。
2. **全字符覆盖**：
   - 最终检查原文标记是否覆盖 A-Z 所有字符。
3. **即时冲突检测**：
   - 遍历过程中，若发现当前字符对与已有映射矛盾，立即终止。

---

## 同类型题与算法套路
- **双向映射约束**：如 [LeetCode 205. 同构字符串](https://leetcode.cn/problems/isomorphic-strings/)
- **覆盖检查**：如 [LeetCode 383. 赎金信](https://leetcode.cn/problems/ransom-note/)

---

## 推荐相似题目
1. **P1914 小书童——密码**（模拟字符替换）
2. **P1598 垂直柱状图**（字符频率统计与输出格式）
3. **P1055 ISBN号码**（校验码验证与字符处理）

---

## 个人心得摘录
- **lianghuahua**：初始误解题意，后通过双向约束明确检查逻辑。
- **xukuan**：强调子程序中必须重置检查标记，避免全局变量污染。

---

## 可视化与算法演示
### 核心逻辑动画设计
1. **像素风格界面**：
   - **左侧网格**：显示加密信息字符流（如 `A→B→A`）。
   - **右侧网格**：显示原文字符流（如 `X→Y→Z`）。
   - **映射线**：动态绘制当前处理的字符对连线，绿色表示合法，红色表示冲突。
2. **音效与提示**：
   - **合法映射**：播放 8-bit 上升音效（类似《超级马里奥》吃金币）。
   - **冲突发生**：播放短促下降音效，屏幕抖动提示错误。
3. **自动演示模式**：
   - 按固定速度逐步处理字符对，允许暂停观察映射表状态。
   - 成功时展示全字符覆盖的 26 个发光方块，失败时显示燃烧动画。

### 关键代码片段（伪代码）
```javascript
// 初始化映射表和状态
let cipherMap = new Map();
let usedPlain = new Set();

// 处理每个字符对
for (let i = 0; i < encrypted.length; i++) {
    let c = encrypted[i];
    let p = plain[i];
    
    // 高亮当前处理的字符对
    highlight(c, p);
    
    if (cipherMap.has(c)) {
        if (cipherMap.get(c) !== p) {
            playErrorSound();
            showConflict(c, cipherMap.get(c), p);
            return "Failed";
        }
    } else {
        if (usedPlain.has(p)) {
            playErrorSound();
            showDuplicatePlain(p);
            return "Failed";
        }
        cipherMap.set(c, p);
        usedPlain.add(p);
    }
}

// 检查全字符覆盖
if (usedPlain.size !== 26) {
    showMissingChars();
    return "Failed";
}
```

---

## 复古游戏化设计
- **背景音乐**：循环播放 FC 风格的 8-bit 间谍主题曲。
- **计分系统**：
  - 每正确映射一对字符 +10 分。
  - 连续无错误映射触发连击倍率（最高 5x）。
- **成就系统**：
  - "完美破译"：无错误完成映射。
  - "闪电战"：在 10 秒内完成破译。

通过交互式学习，用户可在破解密码的游戏中掌握双向映射与覆盖检查的核心逻辑。

---
处理用时：111.60秒
# 题目信息

# [USACO1.1] 黑色星期五Friday the Thirteenth

## 题目描述

$13$ 号又是一个星期五，那么 $13$号在星期五比在其他日子少吗？  

为了回答这个问题，写一个程序，要求计算每个月的十三号落在周一到周日的次数。给出 $n$ 年的一个周期，要求计算 $1900$ 年 $1$ 月 $1$ 日至 $1900+n-1$ 年 $12$ 月 $31$ 日中十三号落在周一到周日的次数。

这里有一些你要知道的:

1. $1900$ 年 $1$ 月 $1$ 日是星期一。
2. $4,6,11$ 和 $9$ 月有 $30$ 天，其他月份除了 $2$ 月都有 $31$ 天，闰年 $2$ 月有 $29$ 天，平年 $2$ 月有 $28$ 天。
3. 年份可以被 $4$ 整除的为闰年（$1992=4\times 498$ 所以 $1992$ 年是闰年，但是 $1990$ 年不是闰年）。
4. 以上规则不适合于世纪年。可以被 $400$ 整除的世纪年为闰年，否则为平年。所以，$1700,1800,1900,2100$ 年是平年，而 $2000$ 年是闰年。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 400$。

题目翻译来自NOCOW。

USACO Training Section 1.1


## 样例 #1

### 输入

```
20
```

### 输出

```
36 33 34 33 35 35 34
```

# AI分析结果



### **算法分类**  
日期处理与数学公式应用

---

### **题解思路、算法要点与解决难点**  
**核心思路对比**：  
1. **暴力模拟**（封禁用户、tllwtg等）：逐日累加，统计13号的星期分布。难点在于闰年判断和月份天数处理，代码冗长但直观。  
2. **递推法**（早右昕、KingOfWA）：利用相邻月份13号的天数差递推星期，时间复杂度 O(n×12)。关键在正确计算月份间隔天数。  
3. **基姆拉尔森公式**（HEIGE）：数学公式直接计算某年月日的星期，时间复杂度最优 O(n×12)。难点在于公式理解和月份调整（1/2月视为上年13/14月）。  

**解决难点**：  
- 闰年判断需处理世纪年规则（能被400整除）。  
- 递推法中需注意不同月份的天数差异对星期计算的影响。  
- 数学公式需正确处理月份和年份的调整（如1月转换为上年的13月）。  

---

### **题解评分（≥4星）**  
1. **HEIGE（5星）**：基姆拉尔森公式实现简洁高效，代码可读性强，思路清晰。  
2. **早右昕（4星）**：结构体+运算符重载实现递推，代码紧凑，但可读性稍弱。  
3. **Divinitist（4星）**：逐日模拟但代码规范，注释详细，适合新手理解。  

---

### **最优思路与技巧提炼**  
**关键技巧**：  
1. **基姆拉尔森公式**：  
   ```cpp
   int week_day(int year, int month, int day) {
       if (month < 3) { month += 12; year--; } // 调整月份
       return (day + 2*month + 3*(month+1)/5 + year + year/4 - year/100 + year/400 + 1) % 7;
   }  
   ```  
   直接计算每月13号的星期，无需遍历日期，复杂度最优。  

2. **递推法优化**：  
   - 每月13号星期数 = (上月天数 + 上月13号星期数) % 7。  
   - 预处理月份天数表，快速递推。  

---

### **相似题目推荐**  
1. **P1024 日期计算**（日期差统计）  
2. **P1153 星期几**（蔡勒公式应用）  
3. **P1271 闰年判断**（强化闰年规则理解）  

---

### **个人心得摘录**  
- *“竞赛环境下不能指望背公式，但数学方法可大幅简化代码”*（HEIGE）  
- *“输出顺序从周六开始，题目未明确说明，需仔细审题”*（tllwtg）  
- *“调试时发现2月天数未重置，导致后续年份错误”*（Eason_AC2）  

---

### **算法可视化设计**  
**核心流程演示**：  
1. **公式计算模式**：  
   - **输入**：年份、月份 → **调整月份**（1/2月变13/14月） → **公式计算** → **高亮余数**（星期结果）。  
   - **动画效果**：分步显示公式各部分计算结果，如年贡献、月贡献、日贡献，最后合成余数。  

2. **递推模式**：  
   - **初始状态**：1900年1月13日为星期六（初始值）。  
   - **逐月递推**：显示当前月份天数 → 计算新星期数 → 更新统计数组。  
   - **高亮变化**：每月13号星期数用不同颜色标记，统计数组实时更新。  

**复古像素风格实现**：  
- **Canvas绘制**：年份为8位像素字体，月份用色块表示，星期统计用柱状图展示。  
- **音效设计**：  
  - **计算完成**：8-bit “升级”音效。  
  - **错误提示**：短促“哔”声。  
- **自动演示**：按年份步进，可调节速度，背景音乐为低循环芯片音乐。  

---

### **代码实现（核心片段）**  
**基姆拉尔森公式实现**：  
```cpp
#include <iostream>
using namespace std;

int week_day(int year, int month, int day) {
    if (month < 3) { month += 12; year--; }
    return (day + 2*month + 3*(month+1)/5 + year + year/4 - year/100 + year/400 + 1) % 7;
}

int main() {
    int n, cnt[7] = {0};
    cin >> n;
    for (int y = 1900; y < 1900 + n; y++)
        for (int m = 1; m <= 12; m++)
            cnt[week_day(y, m, 13)]++;
    cout << cnt[6] << " ";
    for (int i = 0; i < 6; i++) cout << cnt[i] << " ";
}
```

**递推法实现**：  
```cpp
int main() {
    int cnt[7] = {0}, day = 5; // 1900-1-13为周六（余数=5）
    for (int y = 1900; y < 1900 + n; y++) {
        int months[] = {31,28,31,30,31,30,31,31,30,31,30,31};
        if (闰年判断) months[1] = 29;
        for (int m = 0; m < 12; m++) {
            cnt[day]++;
            day = (day + months[m]) % 7;
        }
    }
    // 输出cnt[5], cnt[6], cnt[0]...cnt[4]
}
```

---

### **总结**  
数学公式法（基姆拉尔森）为最优解，适合竞赛场景；递推法适合理解日期周期性；暴力模拟适合教学演示。可视化设计通过分步公式计算或递推过程，结合复古像素风格，可有效提升学习趣味性。

---
处理用时：84.00秒
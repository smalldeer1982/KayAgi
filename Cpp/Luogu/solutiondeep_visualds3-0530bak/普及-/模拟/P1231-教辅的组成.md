# 题目信息

# 教辅的组成

## 题目背景

滚粗了的 HansBug 在收拾旧语文书，然而他发现了什么奇妙的东西。


## 题目描述

蒟蒻 HansBug 在一本语文书里面发现了一本答案，然而他却明明记得这书应该还包含一份练习题。然而出现在他眼前的书多得数不胜数，其中有书，有答案，有练习册。已知一个完整的书册均应该包含且仅包含一本书、一本练习册和一份答案，然而现在全都乱做了一团。许多书上面的字迹都已经模糊了，然而 HansBug 还是可以大致判断这是一本书还是练习册或答案，并且能够大致知道一本书和答案以及一本书和练习册的对应关系（即仅仅知道某书和某答案、某书和某练习册有可能相对应，除此以外的均不可能对应）。既然如此，HansBug 想知道在这样的情况下，最多可能同时组合成多少个完整的书册。



## 说明/提示

样例说明：

如题，$N_1=5$，$N_2=3$，$N_3=4$，表示书有 $5$ 本、练习册有 $3$ 本、答案有 $4$ 本。

$M_1=5$，表示书和练习册共有 $5$ 个可能的对应关系，分别为：书 $4$ 和练习册 $3$ 、书 $2$ 和练习册 $2$ 、书 $5$ 和练习册 $2$ 、书 $5$ 和练习册 $1$ 以及书 $5$ 和练习册 $3$。

$M_2=5$，表示数和答案共有 $5$ 个可能的对应关系，分别为：书 $1$ 和答案 $3$、书 $3$ 和答案 $1$、书 $2$ 和答案 $2$、书 $3$ 和答案 $3$ 以及书 $4$ 和答案 $3$。

所以，以上情况的话最多可以同时配成两个书册，分别为：书 $2$ 练习册 $2$ 答案 $2$、书 $4$ 练习册 $3$ 答案 $3$。


数据规模：

![](https://cdn.luogu.com.cn/upload/image_hosting/srj2v9um.png)

对于数据点 $1,2,3$，$1\le M_1,M_2\leq 20$。

对于数据点 $4\sim 10$，$1\le M_1,M_2 \leq 20000$。


## 样例 #1

### 输入

```
5 3 4
5
4 3
2 2
5 2
5 1
5 3
5
1 3
3 1
2 2
3 3
4 3
```

### 输出

```
2```

# AI分析结果



## 算法分类
网络流（拆点法）

---

## 题解核心思路与难点分析

### 核心问题
需要将书（中间层）同时与练习册（左侧）和答案（右侧）匹配，且每本书只能使用一次。

### 解决难点
1. **流量限制**：书的重复使用需通过拆点限制流量为1
2. **三分图建模**：需构建「练习册→书→答案」三层结构
3. **高效实现**：20000级边数需使用当前弧优化的Dinic

### 关键实现步骤
```python
# 伪代码示例
1. 书节点拆分为入点u和出点v，连接u→v（容量1）
2. 所有练习册连接源点（容量1）
3. 所有答案连接汇点（容量1）
4. 练习册→书入点建立可行边（容量1）
5. 书出点→答案建立可行边（容量1）
6. 跑Dinic求最大流
```

---

## 高星题解推荐（≥4星）

### 1. Siyuan（⭐⭐⭐⭐⭐）
- **亮点**：配图清晰解释拆点原理，代码模块化设计
- **关键代码**：
```cpp
// 书节点拆分为id(2,i)和id(3,i)
for(int i=1;i<=n1;++i) addedge(id(2,i),id(3,i),1);
```

### 2. localhost（⭐⭐⭐⭐）
- **亮点**：提供完整网络流图示，强调反向边处理
- **关键注释**："拆点边容量为1是核心限制条件"

### 3. Drinkwater（⭐⭐⭐⭐）
- **代码优势**：精简的Dinic模板，适合快速实现
- **调试经验**："数组开小会导致WA而非RE，需注意"

---

## 最优思路提炼

### 关键技巧
1. **拆点限流法**：
   ```python
   书u → 拆为u_in和u_out
   u_in与u_out之间建立容量1的边
   ```
2. **三分图建模**：
   ```
   源点 → 练习册 → 书入点 → 书出点 → 答案 → 汇点
   ```
3. **当前弧优化**：
   ```cpp
   memcpy(cur, head, sizeof(head)); // 每次BFS后重置当前弧
   ```

---

## 同类题目推荐
1. P1402 酒店之王（三分图匹配）
2. P2764 最小路径覆盖（二分图+拆点）
3. P2756 飞行员配对方案（二分图匹配）

---

## 可视化方案设计

### 动态流程图
1. **颜色标记**：
   - 红色：正在增广的路径
   - 黄色：拆点边（容量变化时闪烁）
   - 绿色：饱和边

2. **像素动画示例**：
```javascript
// Canvas绘制关键节点
function drawNode(x, y, type){
    ctx.fillStyle = typeColors[type];
    ctx.fillRect(x*40, y*40, 32, 32); // 8位风格方块
    if(type === 'BOOK') drawSplitLine(x, y); // 拆点特效
}
```

3. **音效设计**：
   - 流水声：正常流量通过
   - "哔"声：拆点边容量减1
   - 胜利音效：找到最大流时触发

---

## 核心代码实现

### 拆点关键代码
```cpp
// 书节点拆分为两个部分
const int N = 4e4+5;
int id(int type, int x) {
    switch(type){
        case 1: return x; // 练习册
        case 2: return n2 + x; // 书入点
        case 3: return n2 + n1 + x; // 书出点 
        case 4: return n2 + n1*2 + x; // 答案
    }
}

// 建立拆点边
for(int i=1; i<=n1; i++)
    addedge(id(2,i), id(3,i), 1);
```

### Dinic优化实现
```cpp
int bfs(int s, int t) {
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head)); // 当前弧优化
    queue<int> q;
    q.push(s);
    dep[s] = 1;
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int i=head[u]; i; i=e[i].next) {
            int v = e[i].to;
            if(!dep[v] && e[i].w > 0) {
                dep[v] = dep[u] + 1;
                if(v == t) return 1;
                q.push(v);
            }
        }
    }
    return 0;
}
```

---

## 调试经验
1. **典型错误**：未拆点时，样例输出可能正确但大数据WA
2. **数组大小**：边数需计算为（练习册边+答案边+拆点边）*2
3. **节点编号**：推荐使用`id(type,x)`函数统一管理

---

通过此方案，可在保证算法正确性的同时，直观理解网络流中拆点的核心作用，并为类似三分图问题提供通用解决思路。

---
处理用时：72.46秒
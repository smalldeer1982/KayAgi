# 题目信息

# 数字反转（升级版）

## 题目背景

**以下为原题面，仅供参考:**

给定一个数，请将该数各个位上数字反转得到一个新数。

这次与 NOIp2011 普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。整数反转是将所有数位对调；小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分；分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母；百分数的分子一定是整数，百分数只改变数字部分。整数新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零；小数新数的末尾不为 $0$（除非小数部分除了 $0$ 没有别的数，那么只保留1个 $0$）；分数不约分，分子和分母都不是小数（约分滴童鞋抱歉了，不能过哦。输入数据保证分母不为 $0$），本次没有负数。


## 题目描述

给定一个数，请将该数各个位上数字反转得到一个新数。

这次与 NOIp2011 普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。

- 整数反转是将所有数位对调。

- 小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分。

- 分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母。

- 百分数的分子一定是整数，百分数只改变数字部分。

## 说明/提示

**【数据范围】**

- 对于 $25\%$ 的数据，$s$ 是整数，不大于 $20$ 位；
- 对于 $25\%$ 的数据，$s$ 是小数，整数部分和小数部分均不大于 $10$ 位；
- 对于 $25\%$ 的数据，$s$ 是分数，分子和分母均不大于 $10$ 位；
- 对于 $25\%$ 的数据，$s$ 是百分数，分子不大于 $19$ 位。

**【数据保证】**

- 对于整数翻转而言，整数原数和整数新数满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数和原来的数字的最高位数字不应为零。

- 对于小数翻转而言，其小数点前面部分同上，小数点后面部分的形式，保证满足小数的常见形式，也就是末尾没有多余的 $0$（小数部分除了 $0$ 没有别的数，那么只保留 $1$ 个 $0$。若反转之后末尾数字出现 $0$，请省略多余的 $0$）

- 对于分数翻转而言，分数不约分，分子和分母都不是小数。输入的分母不为 $0$。与整数翻转相关规定见上。

- 对于百分数翻转而言，见与整数翻转相关内容。

数据不存在负数。

## 样例 #1

### 输入

```
5087462```

### 输出

```
2647805```

## 样例 #2

### 输入

```
600.084```

### 输出

```
6.48```

## 样例 #3

### 输入

```
700/27```

### 输出

```
7/72```

## 样例 #4

### 输入

```
8670%```

### 输出

```
768%```

# AI分析结果



### 算法分类
字符串处理

---

### 题解分析与结论

#### 核心思路与难点
所有题解均采用字符串分割+分段反转的核心流程，核心难点在于：
1. **符号定位**：通过遍历字符判断数字类型（./%）
2. **前导零处理**：整数部分反转后需去掉前导零，小数部分需保留前导零但去掉末尾零
3. **零值特判**：如输入为全零时需保留单个0
4. **分段处理**：不同符号将字符串分割为多个部分分别处理

#### 关键实现对比
| 题解方案 | 数据结构 | 符号定位 | 零处理方式 | 模块化程度 |
|---------|---------|---------|------------|-----------|
| STL库解法 | string | find() | erase前导零 + reverse | 高（独立反转函数）|
| 指针遍历法 | char数组 | 遍历检测 | 双指针收缩区间 | 中（耦合处理逻辑）|
| Java解法 | String | indexOf | 前后双循环去零 | 中（类型判断分离）|

---

### ★★★★☆ 高星题解推荐
1. **Anguei (STL解法)**  
   - 亮点：使用reverse+substr+erase实现模块化，封装独立反转函数
   - 评分：4.5星（代码清晰，但缺少小数末尾零处理注释）

2. **SebMa (符号分段)**  
   - 亮点：双指针收缩区间处理前导/末尾零，逻辑直白
   - 评分：4.2星（边界条件处理较隐晦）

3. **方子正 (Python极简)**  
   - 亮点：7行代码实现核心逻辑，利用切片特性
   - 评分：4星（可读性略低但展示语言特性优势）

---

### 最优技巧提炼
```cpp
// 通用反转去零模板
string reverse_part(string s) {
    reverse(s.begin(), s.end());
    while(!s.empty() && s.back()=='0') s.pop_back(); // 去末尾零
    while(!s.empty() && s.front()=='0') s.erase(0,1); // 去前导零
    return s.empty() ? "0" : s;
}

// 主处理逻辑
if(包含'.') 处理小数部分;
else if(包含'/') 处理分数;
else if(包含'%') 处理百分数;
else 处理纯整数;
```

---

### 同类题目推荐
1. P1601（高精度加法）
2. P1055（ISBN号码验证）
3. P1308（统计单词出现次数）

---

### 可视化设计
**复古像素风动画演示：**
1. **符号扫描阶段**：用绿色方块从左到右扫描字符，遇到符号时触发黄色闪光
2. **分段反转动画**：左右箭头在子串两端交替移动模拟反转过程
3. **去零过程**：红色"0"字符逐渐消失，伴随8-bit音效
4. **最终结果展示**：各分段用不同颜色框展示，配胜利音效

**关键帧示例：**
```
[输入] 600.084 → 扫描到'.' → 分割为"600"和"084"
[反转] "600" → "006" → 去前导零 → "6"
       "084" → "480" → 去末尾零 → "48"
[合成] 6.48
```

---

### 核心代码示例
```cpp
// STL解法核心模块
string reverse(string s) {
    int zero = 0;
    reverse(s.begin(), s.end());
    for(char c : s) if(c=='0') zero++; else break;
    s.erase(0, zero);
    return s.empty() ? "0" : s;
}

string deleteTail(string s) {
    int zero = 0;
    for(int i=s.size()-1; i>=0; i--)
        if(s[i]=='0') zero++; else break;
    s.erase(s.end()-zero, s.end());
    return s.empty() ? "0" : s;
}

// 主逻辑
if(s.back() == '%') {
    cout << reverse(s.substr(0, s.size()-1)) << "%";
} else if(s.find('.') != -1) {
    // 处理小数部分...
}
```

---

### 调试心得摘录
> "错了好几次才AC，要周密考虑全零和边界情况" —— SebMa  
> "用大数处理时发现直接转long会溢出，改用字符串操作" —— lqhsr

---

通过模块化处理各数字类型，结合字符串操作特性，可高效解决此类复合格式处理问题。可视化设计中强调分段处理过程，能有效帮助理解多阶段字符串操作的关键步骤。

---
处理用时：75.06秒
# 题目信息

# [NOIP 2016 提高组] 玩具谜题

## 题目背景

NOIP2016 提高组 D1T1

## 题目描述

小南有一套可爱的玩具小人，它们各有不同的职业。

有一天，这些玩具小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/0u7em9pi.png) 

这时 singer 告诉小南一个谜题：“眼镜藏在我左数第 $3$ 个玩具小人的右数第 $1$ 个玩具小人的左数第 $2$ 个玩具小人那里。”

小南发现，这个谜题中玩具小人的朝向非常关键，因为朝内和朝外的玩具小人的左右方向是相反的：面朝圈内的玩具小人，它的左边是顺时针方向，右边是逆时针方向；而面向圈外的玩具小人，它的左边是逆时针方向，右边是顺时针方向。

小南一边艰难地辨认着玩具小人，一边数着:

singer 朝内，左数第 $3$ 个是 archer。

archer 朝外，右数第 $1$ 个是 thinker。

thinker 朝外，左数第 $2$ 个是 writer。

所以眼镜藏在 writer 这里！

虽然成功找回了眼镜，但小南并没有放心。如果下次有更多的玩具小人藏他的眼镜，或是谜题的长度更长，他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。这样的谜題具体可以描述为：

有 $n$ 个玩具小人围成一圈，已知它们的职业和朝向。现在第 $1$ 个玩具小人告诉小南一个包含 $m$ 条指令的谜題，其中第 $z$ 条指令形如“向左数/右数第 $s$ 个玩具小人”。你需要输出依次数完这些指令后，到达的玩具小人的职业。



## 说明/提示

**样例 1 说明**

这组数据就是【题目描述】中提到的例子。


**子任务**

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。

每个测试点的数据规模及特点如下表:

![](https://cdn.luogu.com.cn/upload/image_hosting/7su06u3r.png)

其中一些简写的列意义如下:

- 全朝内：若为 $\surd$，表示该测试点保证所有的玩具小人都朝向圈内；

- 全左数：若为 $\surd$，表示该测试点保证所有的指令都向左数，即对任意的 $1\leq z\leq m, a_i=0$；

- $s=1$：若为 $\surd$，表示该测试点保证所有的指令都只数 $1$ 个，即对任意的 $1\leq z\leq m,s_i=1$；

职业长度为 $1$：若为 $\surd$，表示该测试点保证所有玩具小人的职业一定是一个长度为 $1$ 的字符串。


## 样例 #1

### 输入

```
7 3
0 singer
0 reader
0 mengbier 
1 thinker
1 archer
0 writer
1 mogician 
0 3
1 1
0 2```

### 输出

```
writer```

## 样例 #2

### 输入

```
10 10
1 C
0 r
0 P
1 d
1 e
1 m
1 t
1 y
1 u
0 V
1 7
1 1
1 4
0 5
0 3
0 1
1 6
1 2
0 8
0 4```

### 输出

```
y```

# AI分析结果



### 算法分类选择
**模拟**

---

### 题解思路、算法要点与解决难点
**核心逻辑**：  
1. **移动方向判定**：根据当前小人朝向（0朝内/1朝外）与指令方向（0左/1右），确定实际移动方向（顺时针或逆时针）。  
   - 面朝内时：左=顺时针（减方向），右=逆时针（加方向）  
   - 面朝外时：左=逆时针（加方向），右=顺时针（减方向）  
2. **环形处理**：通过模运算 `(cur + s) % n` 或 `(cur - s + n) % n` 保证位置在合法范围内。  

**解决难点**：  
- 正确理解朝向与方向的组合关系，转化为统一的正负步数计算。  
- 避免因负索引导致的数组越界，通过加 `n` 再取模确保非负。  

---

### 题解评分 (≥4星)
1. **linhongzhao321 (5星)**  
   - 思路清晰，利用 `er_dir[cur] == a` 判断是否反向，简化逻辑。  
   - 代码简洁高效，直接通过符号翻转和模运算处理环形。  
2. **eros1on (4星)**  
   - 异或运算简化条件判断，代码紧凑。  
   - 采用 `(a^out[ans]?s:n-s)` 一步完成方向计算，适合进阶学习。  
3. **Zskioaert1106 (4星)**  
   - 结构体存储数据，逻辑直观易懂。  
   - 通过 `if-else` 明确处理四种情况，适合新手理解。  

---

### 最优思路或技巧提炼
1. **异或简化方向判断**：  
   当 `朝向 ^ 指令方向 = 1` 时，实际移动方向相反（异或结果为真）。例如：  
   ```cpp
   ans = (ans + (a^out[ans] ? s : n-s)) % n; // 异或决定加减
   ```  
2. **统一化步数处理**：  
   将左/右转换为正负步数，统一使用 `cur = (cur + s) % n` 计算新位置。  

---

### 同类型题或类似算法套路
- **环形数组操作**：如约瑟夫问题、循环队列等。  
- **方向模拟**：如机器人移动、蚂蚁掉头等需处理方向变化的场景。  

---

### 推荐相似题目
1. **P1056 排座椅**（模拟座位安排与方向选择）  
2. **P1098 字符串的展开**（环形字符串处理）  
3. **P1516 青蛙的约会**（环形路径与模运算）  

---

### 个人心得摘录
- **输入优化**：Java题解中 `BufferedReader` 处理大数据输入，避免 `Scanner` 卡顿。  
- **调试技巧**：通过打印中间变量（如 `printf("-> %d\n",ans+1)`）观察移动路径。  

---

### 可视化与算法演示
**核心算法动画方案**：  
1. **环形展示**：  
   - 用Canvas绘制环形排列的小人，高亮当前小人（红色方块）。  
   - 每个小人标注朝向箭头（↑朝内，↓朝外）。  
2. **移动演示**：  
   - 接收指令后，显示方向（左/右）和步数，计算实际移动方向（绿色箭头）。  
   - 沿环形路径逐步移动，最终位置闪烁提示。  
3. **复古像素风格**：  
   - 使用8-bit音效（如“哔”声）标记关键步骤。  
   - 背景音乐为低比特循环旋律，增强沉浸感。  

**关键代码片段（伪代码）**：  
```javascript
// 模拟移动核心逻辑
function move(current, direction, steps) {
    const actualDir = (currentDir ^ direction) ? 1 : -1;
    current = (current + actualDir * steps + n) % n;
    return current;
}
```

---

### 代码实现（C++）
```cpp
#include <iostream>
#include <vector>
using namespace std;

struct Toy {
    int dir;
    string name;
};

int main() {
    int n, m;
    cin >> n >> m;
    vector<Toy> toys(n);
    for (int i = 0; i < n; ++i) {
        cin >> toys[i].dir >> toys[i].name;
    }
    int cur = 0;
    while (m--) {
        int a, s;
        cin >> a >> s;
        if (toys[cur].dir == a) { // 同向则逆时针（减）
            cur = (cur - s + n) % n;
        } else {                  // 异向则顺时针（加）
            cur = (cur + s) % n;
        }
    }
    cout << toys[cur].name << endl;
    return 0;
}
```

---
处理用时：80.35秒
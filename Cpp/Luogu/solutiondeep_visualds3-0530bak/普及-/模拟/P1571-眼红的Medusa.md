# 题目信息

# 眼红的Medusa

## 题目描述

虽然 Miss Medusa 到了北京，领了科技创新奖，但是她还是觉得不满意。原因是：他发现很多人都和她一样获了科技创新奖，特别是其中的某些人，还获得了另一个奖项——特殊贡献奖。而越多的人获得了两个奖项，Miss Medusa就会越眼红。于是她决定统计有哪些人获得了两个奖项，来知道自己有多眼红。

## 说明/提示

对于 $60\%$ 的数据，$0 \leq n, m \leq 1000$，获得奖项的人的编号 $\lt 2 \times 10^9$；

对于 $100\%$ 的数据，$0 \leq n, m \leq 10^5$，获得奖项的人的编号 $\lt 2 \times 10^9$。

输入数据保证第二行任意两个数不同，第三行任意两个数不同。

## 样例 #1

### 输入

```
4 3
2 15 6 8
8 9 2
```

### 输出

```
2 8```

# AI分析结果



## 唯一算法分类
**二分查找**（核心为排序+查找，部分题解采用双指针法但需二次排序）

---

## 综合分析与结论

### 核心算法流程
1. **排序预处理**：对特殊贡献奖数组进行排序（$O(m\log m)$）
2. **顺序查找**：遍历科技创新奖数组，对每个元素在有序数组中执行二分查找（$O(n\log m)$）
3. **保持输出顺序**：部分题解通过结构体保留原顺序信息

### 关键难点与解决方案
| 难点 | 解决方案 |
|------|----------|
| 大数据量下高效查找 | 排序后二分查找或双指针法 |
| 保持科技创新奖输出顺序 | 结构体存储原位置信息或保持原数组不变 |
| 去重与重复元素处理 | 利用题设保证"任意两数不同"的特性简化逻辑 |

---

## 题解清单 (≥4星)

### 引领天下（双指针法，4.5星）
- **亮点**：双指针法实现 $O(n+m)$ 查找，通过结构体保留原顺序信息
- **代码片段**：
  ```cpp
  struct Node{ int s, id; };
  sort(a, a+n, cmp1); // 按值排序
  sort(b, b+m);
  while(i < n && j < m) {
    if(a[i].s == b[j]) { ... } 
    else if(a[i].s > b[j]) j++;
    else i++;
  }
  sort(a, a+n, cmp2); // 按原顺序排序
  ```

### Starlight237（STL二分，4星）
- **亮点**：使用STL的binary_search函数，代码简洁高效
- **优化点**：寄存器指针优化，208ms运行时间
- **代码片段**：
  ```cpp
  sort(b, b+m);
  for(auto x : a) {
    if(binary_search(b, b+m, x)) cout << x << " ";
  }
  ```

### 易燃易爆炸丶（lower_bound，4星）
- **亮点**：利用lower_bound简化二分实现
- **代码片段**：
  ```cpp
  y = lower_bound(b+1,b+m+1,a[i])-b;
  if(b[y] == a[i]) cout << a[i] << " ";
  ```

---

## 最优思路提炼
1. **双指针法**（时空最优）：
   - 双数组排序后同步推进
   - 时间复杂度 $O(n\log n + m\log m)$
2. **STL二分法**（代码最简）：
   - 利用binary_search简化实现
   - 适合快速解题场景
3. **结构体保序**：
   ```cpp
   struct { int val, pos; } // 存储原始位置信息
   ```

---

## 同类型题推荐
1. P1102 A-B数对（二分经典）
2. P1608 路径统计（双指针应用）
3. P1918 保龄球（哈希与查找）

---

## 可视化设计（双指针法演示）

### 动画方案
```javascript
// 伪代码示例
class Visualization {
  constructor(a, b) {
    this.a = [...a].sort();   // 科技创新奖排序后
    this.b = [...b].sort();   // 特殊贡献奖排序后
    this.i = 0;               // 当前a指针
    this.j = 0;               // 当前b指针
  }

  nextStep() {
    if(this.a[i] === this.b[j]) {
      highlight(a[i], 'green');  // 匹配成功
      this.results.push(a[i]);
      i++; j++;
    } else if(this.a[i] < this.b[j]) {
      highlight(a[i], 'red');    // a较小，移动i
      i++;
    } else {
      highlight(b[j], 'blue');   // b较小，移动j
      j++;
    }
  }
}
```

### 复古风格实现
1. **8位像素风格**：
   - 使用16色调色板（NES风格）
   - 数组元素用8x8像素块表示
2. **音效设计**：
   - 匹配成功：NES过关音效（0x12-0x15频率）
   - 指针移动：8位"滴"声
3. **自动演示模式**：
   - 按空格暂停/继续
   - 方向键控制演示速度

---

## 核心代码实现（双指针法）
```cpp
#include <algorithm>
struct Node { int val, pos; };
// 第一次排序（按值）
sort(a, a+n, [](Node x, Node y){ return x.val < y.val; });
sort(b, b+m);

int i = 0, j = 0;
vector<int> res;
while(i < n && j < m) {
    if(a[i].val == b[j]) {
        res.push_back(a[i]);
        i++; j++;
    } else if(a[i].val < b[j]) {
        i++;
    } else {
        j++;
    }
}

// 按原顺序输出
sort(a, a+n, [](Node x, Node y){ return x.pos < y.pos; });
for(auto x : res) cout << x << " ";
```

---

通过上述分析与可视化设计，可清晰理解算法核心流程与优化方向。双指针法在理论复杂度上最优，而STL二分法更适合快速实现，开发者可根据具体场景选择最优方案。

---
处理用时：88.19秒
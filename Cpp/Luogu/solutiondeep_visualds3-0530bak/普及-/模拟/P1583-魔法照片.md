# 题目信息

# 魔法照片

## 题目描述

一共有 $n$ 个人（以 $1\sim n$ 编号）向佳佳要照片，而佳佳只能把照片给其中的 $k$ 个人。佳佳按照与他们的关系好坏的程度给每个人赋予了一个初始权值 $W_i$。然后将初始权值从大到小进行排序，每人就有了一个序号 $D_i$（取值同样是 $1\sim n$）。按照这个序号对 $10$ 取模的值将这些人分为 $10$ 类。也就是说定义每个人的类别序号 $C_i$ 的值为 $(D_i-1)\bmod 10 +1$，显然类别序号的取值为 $1 \sim 10$。第 $i$ 类的人将会额外得到 $E_i$ 的权值。你需要做的就是求出加上额外权值以后，最终的权值最大的 $k$ 个人，并输出他们的编号。**在排序中，如果两人的 $E_i$ 相同，编号小的优先。**

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 20000$，$1\leq k\leq n$，保证所有数据均在 `int` 范围之内。

## 样例 #1

### 输入

```
10 10
1 2 3 4 5 6 7 8 9 10
2 4 6 8 10 12 14 16 18 20
```

### 输出

```
10 9 8 7 6 5 4 3 2 1
```

# AI分析结果



# 魔法照片题解分析

## 算法分类
排序

## 题解思路与核心难点
1. **核心流程**：两次排序，第一次确定初始序号，第二次计算最终权值后重新排序。
2. **关键变量**：
   - 结构体存储原始编号和权值。
   - 第一次排序后按序号计算类别（(i % 10) 对应 E 数组下标）。
3. **难点**：
   - 正确处理类别计算（注意 E 数组下标和序号模运算的映射）。
   - 排序规则需满足权值降序，权值相同时编号升序。

---

## 高星题解推荐 (≥4星)
1. **CreeperK（★★★★★）**  
   - **亮点**：结构体清晰，两次排序逻辑简洁，正确处理类别计算。
   - **代码**：通过 `w_comp` 实现双重条件排序，直接利用 `i%10` 映射 E 数组下标。
   ```cpp
   struct person { int w, num, d; };
   sort(p, p+n, [](auto &a, auto &b) { 
       return a.w > b.w || (a.w == b.w && a.num < b.num); 
   });
   ```

2. **Aehnuwx（★★★★☆）**  
   - **亮点**：代码简洁，结构体仅保留必要字段，输入输出优化。
   - **优化**：使用 `Node` 结构体减少冗余字段，直接操作下标。

3. **zhaowangji（★★★★☆）**  
   - **亮点**：详细注释解释排序规则，强调编号优先级。
   - **注意点**：输入 E 数组时从下标 1 开始存储，避免模运算错误。

---

## 最优思路提炼
1. **两次排序法**：首次排序确定初始序号，第二次计算最终权值后再次排序。
2. **结构体设计**：保存原始编号和权值，排序规则优先权值，次优编号。
3. **类别计算**：利用 `i % 10` 快速映射 E 数组下标（需注意输入存储顺序）。

---

## 相似题目推荐
1. **P1309 瑞士轮**（排序+归并优化）  
2. **P1068 分数线划定**（双条件排序）  
3. **P1781 宇宙总统**（自定义排序规则）

---

## 核心代码实现
```cpp
#include <algorithm>
#include <cstdio>
using namespace std;

struct Person {
    int w, id;
} p[20005];
int E[10];

bool cmp(const Person &a, const Person &b) {
    return a.w > b.w || (a.w == b.w && a.id < b.id);
}

int main() {
    int n, k;
    scanf("%d%d", &n, &k);
    for (int i = 0; i < 10; i++) scanf("%d", E + i);
    for (int i = 0; i < n; i++) {
        scanf("%d", &p[i].w);
        p[i].id = i + 1;
    }
    
    sort(p, p + n, cmp); // 第一次排序
    for (int i = 0; i < n; i++) 
        p[i].w += E[i % 10]; // 类别映射
    
    sort(p, p + n, cmp); // 第二次排序
    for (int i = 0; i < k; i++) 
        printf("%d ", p[i].id);
}
```

---

## 可视化算法设计
1. **动画流程**：
   - **步骤1**：初始权值显示为灰色方块，编号标注在底部。
   - **步骤2**：第一次排序后，方块按权值从高到低排列，颜色渐变为蓝色。
   - **步骤3**：每个方块顶部显示类别值（1-10），并动态叠加 E 值（绿色+数字）。
   - **步骤4**：第二次排序后，最终前 k 个方块高亮为金色。

2. **交互功能**：
   - 速度调节滑块控制排序动画速度。
   - 点击方块查看详细权值变化日志。
   - 音效：排序完成时播放「8-bit 胜利音效」。

3. **复古风格**：
   - 使用 16 色像素调色板，模拟 FC 游戏界面。
   - 方块移动时带有扫描线特效，背景循环播放芯片音乐。

---

通过上述分析与可视化演示，可直观理解两次排序的关键流程及类别映射的逻辑，有效避免常见错误（如 E 数组下标错误）。

---
处理用时：150.83秒
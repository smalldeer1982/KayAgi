# 题目信息

# 结算日

## 题目背景

借债还债


## 题目描述

“不放债不借债”，贝西多么希望自己可以遵循这个忠告。她已经和她的 $N(1 \leq N \leq 100,000)$ 个朋友有了债务关系，或者借债了，或者放债了。她的 $N$ 个朋友依次标号为 $1\dots N$。 结算日终于来临了。她知道，朋友欠她的钱比她欠朋友的钱多。她的朋友们分布在一条直线上，第 $i$ 头奶牛站的位置距离谷仓 $i$ 米。贝西打算沿着这条直线行走，从欠她钱的奶牛手里收钱回来，并且还钱给她欠钱的奶牛。 当她沿直线移动的时候，她可以要求任何欠她钱的奶牛还全部的钱。当她有足够的钱可以还清她的某个债，就可以把钱给对应的奶牛还清她的债。奶牛 $i$ 欠贝西 $D_i$ 元 $(-1,000 \leq D_i \leq 1,000,D_i \neq 0)$，负数表示贝西欠奶牛 $i$ 钱。 贝西从谷仓出发，位置为 $0$，初始贝西没有钱。贝西收回她的所有借债，并且还清她的欠债所需行走的最短距离是多少？注意：她必须在最后一头奶牛所在的位置，完成她的行走。


## 说明/提示

输入解释：

$3$ 头奶牛欠贝西钱；她欠 $2$ 头奶牛钱。当她完成结算，她将有 $150$ 元。

输出解释：

```cpp
谷仓  100  -200  250 -200  200
 |     |     |    |    |    |
 ***>**+**>*****>**+
                   *            < 贝西有 350元
             -**<***
             *                  < 贝西有 150元
             ***>****>****>**+
                             *  < 贝西有 350
                       -**<***
                       *     
                       ***>***  < 贝西结束她的行走，有 150元
```

## 样例 #1

### 输入

```
5
100
-200
250
-200
200```

### 输出

```
9

```

# AI分析结果



## 算法分类
贪心算法

---

## 综合分析与结论
**核心思路**：采用贪心策略，在能够偿还所有历史欠款时立即折返，避免后续更长的回头路。  
**关键变量**：
- `sum`：当前净收益（正数表示可支配金额，负数表示总欠款）
- `start_pos`：当前未偿还欠款段的起始位置
- `ans`：总路程（基础路程为N米，额外折返路程按需累加）

**解决难点**：
- 正确识别何时能够偿还所有历史欠款：通过`sum >= 0`判断
- 维护连续欠款段的起始位置：仅在欠款段开始时记录位置
- 折返路径计算：每次折返增加 `(当前位置 - 起始位置)*2` 的距离

**可视化设计**：
- **像素动画**：贝西以像素小人形态沿直线移动，遇到正数变绿，负数变红。
- **折返特效**：触发偿还时，贝西原路折返并留下轨迹线，播放“金币音效”。
- **状态面板**：实时显示当前sum值和总路程，用8-bit字体呈现。

---

## 题解评分（≥4星）
1. **封禁用户（4星）**  
   亮点：代码最简，用flag标记欠款状态，逻辑清晰。  
   代码可读性：变量命名可优化，但核心逻辑紧凑。

2. **greenheadstrange（4星）**  
   亮点：用bj变量明确记录欠款起点，注释详细。  
   代码可读性：变量名`bj`可改为`start_pos`更直观。

3. **Real_Create（4星）**  
   亮点：最短代码实现，jl变量隐式记录欠款段长度。  
   实践性：需理解jl实际表示欠款段长度，适合进阶学习者。

---

## 最优思路提炼
```cpp
int sum = 0, ans = n, start_pos = 0;
for (int i = 1; i <= n; ++i) {
    sum += x;
    if (sum >= 0 && start_pos) {  // 可偿还历史欠款
        ans += (i - start_pos) * 2; // 折返距离
        start_pos = 0; // 重置欠款标记
    }
    if (sum < 0 && !start_pos) {  // 进入新欠款段
        start_pos = i; // 记录起始位置
    }
}
```

---

## 类似题目推荐
1. **洛谷 P1090** - 合并果子（贪心+优先队列）
2. **洛谷 P5019** - 铺设道路（贪心区间覆盖）
3. **LeetCode 134** - 加油站（环形贪心）

---

## 可视化算法演示
**关键帧说明**：
1. 初始位置0，显示贝西像素小人。
2. 每次向右移动1格，显示当前奶牛数值（正绿负红）。
3. 当sum变正且存在欠款段时，贝西折返到start_pos并返回，路径显示为黄色虚线。
4. 折返时播放"coin.wav"音效，总路程同步更新。

**8-bit风格控制面板**：  
- 速度调节：复古滑动条（慢/中/快）
- 暂停/继续：街机式按钮（A/B键位风格）
- 数据展示：当前sum用LED样式显示，欠款段用闪烁红框标记。

---

## 核心代码实现
```cpp
#include <iostream>
using namespace std;

int main() {
    int n, x, sum = 0, ans = 0, start_pos = 0;
    cin >> n;
    ans = n; // 基础路程
    for (int i = 1; i <= n; ++i) {
        cin >> x;
        sum += x;
        if (sum >= 0 && start_pos) {
            ans += (i - start_pos) * 2; // 折返路程
            start_pos = 0;
        }
        if (sum < 0 && !start_pos) {
            start_pos = i; // 记录欠款起点
        }
    }
    cout << ans;
    return 0;
}
```

---
处理用时：126.82秒
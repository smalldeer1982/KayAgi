# 题目信息

# [USACO19OPEN] Milk Factory B

## 题目描述

牛奶生意正红红火火！Farmer John 的牛奶加工厂内有 $N$ 个加工站，编号为 $1\dots N$（$1\le N\le 100$），以及 $N−1$ 条通道，每条连接某两个加工站。（通道建设很昂贵，所以 Farmer John 选择使用了最小数量的通道，使得从每个加工站出发都可以到达所有其他加工站）。

为了创新和提升效率，Farmer John 在每条通道上安装了传送带。不幸的是，当他意识到传送带是单向的已经太晚了，现在每条通道只能沿着一个方向通行了！所以现在的情况不再是从每个加工站出发都能够到达其他加工站了。

然而，Farmer John 认为事情可能还不算完全失败，只要至少还存在一个加工站 $i$ 满足从其他每个加工站出发都可以到达加工站 $i$。注意从其他任意一个加工站 $j$ 前往加工站 $i$ 可能会经过 $i$ 和 $j$ 之间的一些中间站点。请帮助 Farmer John 求出是否存在这样的加工站 $i$。

## 样例 #1

### 输入

```
3
1 2
3 2```

### 输出

```
2```

# AI分析结果



**唯一算法分类**：图的遍历

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   寻找所有节点均可到达的节点，等价于在**反向图**中该节点能到达所有其他节点。通过反向建图，将问题转换为对每个节点进行可达性检查，减少计算量。

2. **算法实现**  
   - **反向建图**：将原图中的边方向反转，构建反向邻接表。  
   - **DFS/BFS 遍历**：对每个节点 `i`，在反向图中进行遍历，标记所有可达节点。若可达节点数为 `n`，则 `i` 是答案。  
   - **时间复杂度**：对每个节点进行一次遍历，复杂度为 $O(n(n+m))$，其中 $m$ 为边数（本题 $m=n-1$），适用于 $n \le 100$。

3. **解决难点**  
   - **方向转换的思维跳跃**：通过反向图简化问题，避免对每个节点多次正向遍历。  
   - **高效标记可达性**：通过单次遍历统计所有可达节点，避免重复计算。

---

### **题解评分 (≥4星)**

1. **yhx0322 的题解（4.5星）**  
   - **亮点**：反向建图思路巧妙，代码简洁高效，利用反向遍历优化可达性检查。  
   - **代码可读性**：结构清晰，反向建图与遍历逻辑明确。

2. **gey666 的题解（4星）**  
   - **亮点**：使用 Floyd 算法预处理所有可达性，实现简单。  
   - **缺点**：时间复杂度 $O(n^3)$，略高于 DFS，但数据规模允许。

3. **HasNoName 的题解（4星）**  
   - **亮点**：直接统计每个节点的被访问次数，逻辑直观。  
   - **缺点**：未优化遍历方向，需多次正向 DFS。

---

### **最优思路或技巧提炼**

1. **反向图转换**  
   将“所有节点能到达 `i`”转换为“`i` 在反向图中能到达所有节点”，简化问题。

2. **DFS/BFS 遍历优化**  
   对每个节点仅需一次遍历即可判断全局可达性，避免重复计算。

3. **邻接表存储**  
   使用邻接表而非邻接矩阵，节省空间并提高遍历效率。

---

### **同类型题或类似算法套路**

- **反向图应用**：如求强连通分量（Kosaraju 算法）、求解“所有点可达某点”类问题。  
- **可达性预处理**：如拓扑排序、传递闭包（Floyd）等。

---

### **推荐相似题目**

1. [P2863 [USACO06JAN] The Cow Prom S](https://www.luogu.com.cn/problem/P2863)（强连通分量）  
2. [P3916 图的遍历](https://www.luogu.com.cn/problem/P3916)（反向图遍历）  
3. [P1347 排序](https://www.luogu.com.cn/problem/P1347)（传递闭包与拓扑排序）

---

### **代码实现（核心片段）**

```cpp
// yhx0322 反向建图解法（关键代码）
void add(int x, int y) { a[++k] = {y, pre[x]}; pre[x] = k; }

void dfs(int x) {
    for (int i = pre[x]; i; i = a[i].next) {
        int to = a[i].to;
        if (!f[to]) {
            f[to] = true;
            dfs(to);
        }
    }
}

int main() {
    // 反向建图
    for (int i = 1; i < n; i++) {
        cin >> x >> y;
        add(y, x); // 反向添加边
    }
    // 对每个节点检查可达性
    for (int i = 1; i <= n; i++) {
        memset(f, false, sizeof(f));
        dfs(i);
        bool valid = true;
        for (int j = 1; j <= n; j++) {
            if (i != j && !f[j]) { valid = false; break; }
        }
        if (valid) { cout << i; return 0; }
    }
    cout << -1;
}
```

---

### **可视化与算法演示**

**动画设计**：  
1. **反向图构建**：显示原图边方向逐步反转的过程，箭头颜色变化表示反向。  
2. **DFS 遍历**：以当前节点 `i` 为起点，动态扩展访问的节点，高亮已访问区域。  
3. **结果判定**：若所有节点被覆盖，`i` 标记为绿色并播放成功音效。

**复古像素效果**：  
- **颜色方案**：节点为 8-bit 像素方块，边为单色箭头，已访问节点渐变为绿色。  
- **音效**：遍历时播放“滴”声，成功时播放 8-bit 胜利音乐。  
- **Canvas 交互**：支持暂停/继续，调整遍历速度，实时显示当前检查的节点。

**自动演示模式**：  
- 算法自动依次检查每个节点，若发现可行解立即停止并高亮结果。

---
处理用时：115.09秒
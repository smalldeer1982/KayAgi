# 题目信息

# 双调序列

## 题目描述

电脑组的童鞋们经常玩一些智力 PK 小游戏，某月某日，发源于小朋友又发明了一种新的序列：双调序列，所谓的双调呢主要是满足如下条件描述：

假定有 $n$（$n \le 1000$）个整数（都在 `long int` 范围内，即 $-2147483648 \sim 2147483647$），双调序列的第一个数是 $n$ 个整数中的最大数，第二个数是 $n$ 个整数中的最小数，第三个数是 $n$ 个数中的第二大数，第四个数是 $n$ 个数中的第二小数……取过的数不能再取，依次类推，直到结束。

聪明的你听完描述就抿嘴笑了吧？那就请你用程序正确的帮他找出这 $n$ 个数的双调序列。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 1000$。


## 样例 #1

### 输入

```
5
10
-1
3
3
-9
```

### 输出

```
10
-9
3
-1
3
```

# AI分析结果



---

**唯一算法分类**：排序 + 双指针遍历

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **排序**：将数组排序后，最大元素在右端，最小元素在左端，后续交替取次大和次小。
2. **双指针遍历**：使用两个指针分别从排序后的数组两端向中间移动，交替输出元素。

#### **算法实现**
- **排序**：调用 `sort` 实现 O(n log n) 排序。
- **交替输出**：用两个变量 `i` 和 `j` 分别指向当前最大和最小元素的位置，循环输出 `a[j]`（最大）和 `a[i]`（最小），并更新指针。

#### **解决难点**
- **奇偶处理**：当 `n` 为奇数时，中间的最后一个元素需要单独输出。
- **索引控制**：通过 `i` 和 `j` 的增减精确控制输出顺序，避免重复或遗漏。

---

### **题解评分 (≥4星)**

1. **B_Qu1e7 的题解**（⭐⭐⭐⭐⭐）  
   - **亮点**：代码简洁，直接排序后循环输出两端，处理奇偶情况仅需一行代码。
   - **代码片段**：
     ```cpp
     sort(a+1,a+n+1);
     for(int i=1;i<=n/2;i++)
         cout<<a[n-i+1]<<endl<<a[i]<<endl;
     if(n%2) cout<<a[n/2+1]<<endl;
     ```

2. **judgejudge 的双指针解法**（⭐⭐⭐⭐）  
   - **亮点**：使用双指针 `pl` 和 `pr` 明确标记当前待输出的最大和最小值，逻辑清晰。
   - **代码片段**：
     ```cpp
     ll pl=1, pr=n;
     while(pl<=pr) {
         cout<<a[pl]<<endl, pl++;
         if(pl<=pr) cout<<a[pr]<<endl, pr--;
     }
     ```

3. **RedreamMer 的奇偶索引法**（⭐⭐⭐⭐）  
   - **亮点**：通过奇偶判断动态调整索引，代码简洁且无需处理奇偶结束条件。
   - **代码片段**：
     ```cpp
     for(int i=1, j=a+1, k=0; i<=a; i++) {
         if(i%2==1) cout<<x[--j]<<endl;
         else cout<<x[++k]<<endl;
     }
     ```

---

### **最优思路或技巧提炼**
- **排序后双指针交替输出**：排序后，最大元素在右端，最小在左端，交替取右左元素即可。
- **奇偶处理技巧**：通过 `n%2` 判断是否需要单独输出中间元素。
- **索引控制**：通过 `i` 和 `n-i+1` 快速定位当前次大和次小元素的位置。

---

### **同类型题或类似算法套路**
- **交替输出问题**：如交替合并两个数组（类似 LeetCode 88. 合并两个有序数组）。
- **双指针遍历**：如快速排序中的分区操作、两数之和（LeetCode 1. Two Sum）。

---

### **推荐相似题目**
1. **洛谷 P1908 逆序对**（分治思想，但需统计逆序对）  
2. **洛谷 P1177 快速排序**（练习排序算法）  
3. **洛谷 P1115 最大子段和**（双指针或动态规划）

---

### **个人心得摘录**
- **B_Qu1e7**：通过排序和简单循环即可解决看似复杂的问题，避免过度设计。
- **decoqwq**：平衡树实现虽然炫技，但实际应用中应选择更简洁的解法。
- **judgejudge**：优先队列的陷阱在于奇偶次数的处理，需特别注意边界条件。

---

### **可视化与算法演示**
#### **动画方案**
1. **排序过程**：展示数组从小到大排序的动画（如冒泡排序的逐步交换）。
2. **双指针遍历**：
   - **初始状态**：高亮排序后的数组，左右指针分别指向首尾。
   - **输出步骤**：
     - **第1步**：右指针指向最大值（红色高亮），输出后左移。
     - **第2步**：左指针指向最小值（蓝色高亮），输出后右移。
     - **循环**：重复直到指针相遇，若 `n` 为奇数，单独输出中间元素。
3. **复古像素风格**：
   - **颜色方案**：8位色调色板（红、蓝、绿表示不同状态）。
   - **Canvas 绘制**：用网格表示数组，当前操作元素闪烁显示。
   - **音效**：输出元素时播放“滴”声，结束时播放“胜利”音效。

#### **交互设计**
- **步进控制**：支持暂停/继续、单步执行。
- **速度调节**：滑动条调整动画速度（0.5x~3x）。
- **自动演示**：AI 自动运行并高亮当前操作。

---

**核心代码片段**  
B_Qu1e7 的实现：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1001];
int main() {
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a+1,a+n+1);
    for(int i=1;i<=n/2;i++)
        cout<<a[n-i+1]<<endl<<a[i]<<endl;
    if(n%2) cout<<a[n/2+1]<<endl;
}
```

---
处理用时：86.71秒
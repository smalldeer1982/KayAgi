# 题目信息

# 山峰暸望

## 题目描述

一天，Bessie 在眺望美丽的威斯康星的群山的时候，她突然产生了疑问：哪座山是最宽的？

她决定在地平线上，利用她的新式大量程山峰高度测量仪依次做 $N$（$1 \le N \le 10,000$）次高度测量，每次的高度值为 $H_i$（$1 \le H_i \le 1,000,000,000$）。

一座山定义为一段连续的高度序列，序列中的高度一开始单调上升（或者不变），然后单调下降（或者不变）。举例来说，$2, 3, 3, 5, 4, 4, 1$ 这一段高度序列就是一座山。如果在她的视线范围内有一段单调上升或者单调下降的序列，也算是一座山。注意，两座山之间可能会有部分重叠。

山的宽度定义为在这个山上进行的测量的次数（也就是序列的长度）。例如序列 $2, 3, 3, 5, 4, 4, 1$ 的宽度为 $7$。

请帮 Bessie 找到最宽的山。

下图是一个比较典型的的例子：

```plain
           *******                   *                                
          *********                  ***                               
          **********                *****                              
          ***********            *********               *             
*      *****************       ***********             *** *          
**    *******************     *************   * *     *******      *  
**********************************************************************  山的形状
3211112333677777776543332111112344456765432111212111112343232111111211  高度值
aaaaa                    ccccccccccccccccccccc eeeeeee ggggggggg
  bbbbbbbbbbbbbbbbbbbbbbbbbbbb             ddddd          ffffffffff  
                                                             hhhhhhhhh  山的编号
```

山标记为 `a`、`b` 等等。显然，山 `b` 有着最大的宽度，宽度为 $28$。


## 说明/提示

**【样例说明】**

在最宽的山处测量到的高度为 $2, 3, 5, 4, 1$。其他的山包括 $3, 2$ 和 $1, 6$。

---

**【提示】**

如果你知道一座山的最高的部分（也就是山峰），你会发现，找到这座山的宽度是很容易的哦。

## 样例 #1

### 输入

```
7
3
2
3
5
4
1
6
```

### 输出

```
5
```

# AI分析结果



# 山峰暸望题解分析

## 唯一算法分类
动态规划

---

## 综合分析与结论

### 核心思路与难点
1. **问题本质**：寻找最长的连续子序列，满足先非递减后非递增的特性
2. **关键难点**：如何高效判断每个点的左右扩展边界
3. **最优解法**：通过预处理得到每个点的最长左扩展（fup）和最长右扩展（fdown），最终每个点的山脉宽度为 fup[i]+fdown[i]-1

### 算法流程可视化设计
1. **动态规划数组生成**：
   - 红色高亮当前处理的数组元素
   - 绿色箭头表示正向扫描生成fup数组
   - 蓝色箭头表示逆向扫描生成fdown数组
2. **山脉宽度计算**：
   - 黄色框标记当前计算的山峰位置
   - 动态展示每个点的左右扩展范围
3. **像素风格实现**：
   - 8-bit 风格网格显示高度数组
   - 用不同颜色块表示上升段（浅绿）、下降段（浅蓝）、峰顶（橙色）

---

## 题解清单（≥4星）

### 1. 万弘（★★★★★）
**核心亮点**：
- O(n) 时间预处理上升/下降序列
- 双动态规划数组实现
- 代码清晰简洁，可读性强

### 2. lych（★★★★★）
**核心亮点**：
- 预处理左右扩展数组
- 最终计算只需线性遍历
- Pascal代码展示多语言解法

### 3. AFOier（★★★★）
**核心亮点**：
- 直观暴力模拟思路
- 代码量极小（仅15行）
- 适合快速理解问题本质

---

## 最优思路提炼

### 动态规划双数组法
```cpp
// 预处理上升序列长度
fup[1] = 1;
for(int i=2; i<=n; i++)
    fup[i] = (h[i]>=h[i-1]) ? fup[i-1]+1 : 1;

// 预处理下降序列长度 
fdown[n] = 1;
for(int i=n-1; i>=1; i--)
    fdown[i] = (h[i]>=h[i+1]) ? fdown[i+1]+1 : 1;

// 计算结果
int ans = 0;
for(int i=1; i<=n; i++)
    ans = max(ans, fup[i]+fdown[i]-1);
```

### 关键技巧
1. **方向分离处理**：正向处理上升段，逆向处理下降段
2. **重叠处理**：每个点的左右扩展独立计算避免重复
3. **边界处理**：初始值设置为1保证单点山脉

---

## 同类型题推荐

1. **LeetCode 845. 数组中的最长山脉**  
   （同山脉定义，要求严格递增递减）

2. **洛谷 P2947 [USACO09MAR]Look Up S**  
   （预处理向右查找的典型问题）

3. **洛谷 P1564 膜拜**  
   （类似的双向预处理思想）

---

## 可视化实现样例（伪代码）

```javascript
// 生成像素风格山脉视图
function drawMountain(canvas, h) {
    const COLORS = {
        peak: '#FFA500',    // 峰顶
        up:   '#90EE90',    // 上升段
        down: '#87CEEB'     // 下降段
    };
    
    h.forEach((height, i) => {
        const isPeak = (fup[i]>1 && fdown[i]>1);
        ctx.fillStyle = isPeak ? COLORS.peak : 
                       (fup[i]>1 ? COLORS.up : COLORS.down);
        drawPixelBlock(i, height);
    });
}

// 动态演示预处理过程
function animateDP() {
    // 正向扫描显示fup生成
    for(let i=0; i<n; i++) {
        highlightCell(i, 'green');
        updateFupValue(i);
        playSound('blip');
    }
    
    // 逆向扫描显示fdown生成
    for(let i=n-1; i>=0; i--) {
        highlightCell(i, 'blue');
        updateFdownValue(i);
        playSound('blip');
    }
}
```

---

## 个人心得摘录

> **万弘的调试经验**：  
> "最初试图用单次扫描处理双向关系，发现状态转移存在矛盾。将上升和下降分开处理是突破点。"

> **lych的优化发现**：  
> "预处理左右扩展时，发现可以利用之前计算的结果，避免重复判断相邻元素。"

---

## 复古游戏化设计

1. **像素音效方案**：
   - `blip.wav`（关键操作音效，8-bit 短促音）
   - `success.wav`（找到最大宽度时，16-bit和弦音）
   - `bgm.ogg`（8-bit风格循环背景音乐）

2. **自动演示AI**：
```javascript
class AutoPlayer {
    constructor() {
        this.mode = 'DP'; // 可切换暴力/DP模式
        this.speed = 100; // ms/step
    }

    run() {
        if(this.mode === 'DP') {
            this.animateDPProcess();
        } else {
            this.animateBruteForce();
        }
    }
}
```

3. **积分系统**：
   - 正确预处理一个元素 +10分
   - 发现最优解 +50分
   - 错误操作播放失败音效并-20分

---

## 核心算法可视化演示

**步骤说明**：
1. 初始化高度数组显示为灰色像素块
2. 正向扫描时，将上升段渐变为绿色
3. 逆向扫描时，将下降段渐变为蓝色
4. 最终每个峰顶显示为橙色，展示最大宽度区域

**交互功能**：
- 速度调节滑块（50ms~1000ms/步）
- 模式切换按钮（暴力/DP）
- 复位/暂停/单步执行控制

通过这种可视化设计，学习者可以直观理解动态规划预处理的过程，以及每个点的山脉构成原理。复古像素风格和游戏化元素增加了学习的趣味性。

---
处理用时：79.85秒
# 题目信息

# 天际线

## 题目描述

Latium 省的 Genoa 是亚平宁半岛西海岸北端的一片土地，自然资源丰富，却无人居住。你受到罗马执政官 Caesar 的委任，前往 Genoa 建立新的城市。Caesar 对这次任务的要求是在 Genoa 这片土地上建立起一座繁荣的城市，他将以此作为衡量你的表现的标准。

正在你大刀阔斧地进行城市建设的时候，Caesar 突然写信给你，说他要检查 Genoa 的建设情况。Caesar 希望知道你的城市是什么样子，但是他又非常的忙，所以他只要你描述一下城市的轮廓就可以了，他将依照城市的轮廓决定你的薪水。

怎样描述一个城市的轮廓呢？我们知道 Genoa 所有的建筑共享一个地面，你可以认为它是水平的。所有的建筑用一个三元组 $(L_i,H_i,R_i)$，其中 $L_i$ 和 $R_i$ 分别是建筑的左坐标和右坐标，$H_i$ 就是建筑的高度。在下方所示的图表中左边建筑物描述如下 $(1,11,5)$，$(2,6,7)$，$(3,13,9)$，$(12,7,16)$，$(14,3,25)$，$(19,18,22)$，$(23,13,29)$，$(24,4,28)$，右边用轮廓线的顺序$(1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0)$ 表示：

![](https://cdn.luogu.com.cn/upload/image_hosting/oe7wpwsi.png)


## 样例 #1

### 输入

```
1 11 5
2 6 7
3 13 9
12 7 16
14 3 25
19 18 22
23 13 29
24 4 28
```

### 输出

```
1 11 3 13 9 0 12 7 16 3 19 18 22 3 23 13 29 0```

# AI分析结果



## 算法分类
**扫描线算法**

---

## 题解思路与解决难点

### 核心算法逻辑
1. **事件驱动**：将每个建筑的左右边界视为事件点，左侧事件触发高度加入，右侧事件触发高度移除  
2. **动态维护最大高度**：使用优先队列/线段树/平衡树等数据结构实时维护当前所有活跃建筑的最大高度  
3. **轮廓点生成**：当最大高度发生变化时，记录坐标与新的高度作为轮廓转折点  

### 难点对比
| 题解方法       | 数据结构          | 核心难点                                                                 | 时间复杂度        |
|----------------|-------------------|--------------------------------------------------------------------------|-------------------|
| 暴力枚举       | 数组              | 右端点处理不当会导致缝隙错误                                             | O(n·maxR)         |
| 扫描线+线段树   | 线段树+离散化     | 离散化坐标映射、区间覆盖与最大值维护                                      | O(n logn)         |
| 优先队列       | 最大堆+延迟删除   | 处理过期事件时需维护堆的有效性                                           | O(n logn)         |
| 分块           | 块状数组          | 块内暴力更新与块标记传递的逻辑设计                                        | O(n√n)            |
| 珂朵莉树       | 区间树            | 区间合并策略需按高度排序后覆盖，避免低优先级区间干扰                      | 均摊 O(n logn)    |

---

## 题解评分（≥4星）

### 1. [big_news] 扫描线+线段树（★★★★☆）
- **亮点**：完整实现扫描线逻辑，结合离散化处理大坐标范围，线段树维护区间最大值清晰易懂  
- **优化点**：事件处理时需合并相同横坐标的事件，避免重复查询线段树  

### 2. [zhenglier] 优先队列+延迟删除（★★★★☆）
- **亮点**：用`multiset`替代堆，直接通过迭代器删除特定元素，避免传统堆的延迟删除复杂度  
- **关键代码**：
  ```cpp
  multiset<int> tr;
  // 插入左边界事件
  tr.insert(h);
  // 删除右边界事件
  auto it = tr.find(h);
  tr.erase(it);
  ```

### 3. [haoyun1] 优先队列+过期标记（★★★★☆）
- **亮点**：用`ended`数组标记已结束建筑，高效清理堆顶过期元素  
- **核心逻辑**：
  ```cpp
  while (!pq.empty() && ended[pq.top().buildingId]) 
      pq.pop();
  ```

---

## 最优思路提炼
**事件排序 + 动态最大高度维护**  
1. **事件点排序**：将所有建筑的左右端点按横坐标排序，横坐标相同时左端点优先  
2. **延迟删除堆**：用最大堆维护当前活跃高度，遇到右端点时标记对应高度为过期，在需要获取当前最大值时清理堆顶过期元素  
3. **轮廓点生成规则**：当处理完一个事件点后，若当前最大高度与之前不同，则记录转折点  

---

## 同类型题与算法套路
- **区间覆盖问题**：如矩形面积并、区间染色最大值  
- **事件驱动模型**：如会议室安排、航班调度  
- **动态最值维护**：如滑动窗口最大值、实时排行榜  

---

## 推荐相似题目
1. **P5490 矩形面积并**（扫描线+线段树）  
2. **P1886 滑动窗口**（单调队列维护最值）  
3. **P2163 动态最大子段和**（分块/线段树动态维护）  

---

## 可视化与算法演示
### 动画设计
- **Canvas 动态绘制**：  
  1. 底部灰色网格表示地面坐标轴，蓝色方块表示建筑  
  2. 红色竖线从左向右扫描，遇到左端点时上方弹出蓝色高度条，遇到右端点时变为灰色  
  3. 绿色折线实时绘制当前轮廓，转折点用黄色圆点标记  

- **交互控制**：  
  - **速度滑块**：调节扫描线移动速度（10ms~1000ms/步）  
  - **单步执行**：点击`Next Event`逐事件处理  
  - **高亮显示**：当前处理的事件点用红色闪烁框标记，堆内元素用不同颜色区分有效/过期  

- **复古像素风格**：  
  - 8-bit 音效：扫描线移动时播放`beep`音，轮廓点生成时播放`coin`音效  
  - 像素字体：所有文字使用复古风格字体，控制面板仿照FC游戏菜单  

---

## 核心代码实现（优先队列版）
```cpp
vector<Event> events;
multiset<int> heights;
int lastHeight = 0;

// 处理事件并生成轮廓
for (auto &e : events) {
    if (e.isStart) {
        heights.insert(e.h);
    } else {
        heights.erase(heights.find(e.h));
    }
    
    int currHeight = heights.empty() ? 0 : *heights.rbegin();
    if (currHeight != lastHeight) {
        ans.push_back({e.x, currHeight});
        lastHeight = currHeight;
    }
}
```

---

## 关键调试心得
- **右端点处理**：建筑右端点应视为`[L, R)`区间，否则相邻建筑间可能产生1单位缝隙  
- **事件排序规则**：横坐标相同时，必须左端点先处理，否则可能导致短暂高度降低的错误轮廓  
- **堆的延迟删除**：直接删除元素可能导致多次`pop`，需结合哈希表标记过期元素  

通过可视化演示可清晰观察事件处理顺序与轮廓生成逻辑，结合音效反馈可快速定位逻辑错误点。

---
处理用时：93.36秒
# 题目信息

# 保龄球

## 题目描述

DL 算缘分算得很烦闷，所以常常到体育馆去打保龄球解闷。因为他保龄球已经打了几十年了，所以技术上不成问题，于是他就想玩点新花招。

DL 的视力真的很不错，竟然能够数清楚在他前方十米左右每个位置的瓶子的数量。他突然发现这是一个炫耀自己好视力的借口——他看清远方瓶子的个数后从某个位置发球，这样就能打倒一定数量的瓶子。

1. $\bigcirc \bigcirc \bigcirc$

2. $\bigcirc \bigcirc \bigcirc\ \bigcirc$

3. $\bigcirc$

4. $\bigcirc\ \bigcirc$

如上图，每个 “$\bigcirc$” 代表一个瓶子。如果 DL 想要打倒 $3$ 个瓶子就在 $1$ 位置发球，想要打倒 $4$ 个瓶子就在 $2$ 位置发球。

现在他想要打倒 $m$ 个瓶子。他告诉你每个位置的瓶子数，请你给他一个发球位置。

## 说明/提示

【数据范围】

对于 $50\%$ 的数据，$1 \leq n, Q \leq 1000, 1 \leq a_i, m \leq 10^5$。

对于 $100\%$ 的数据，$1 \leq n,Q \leq 100000, 1 \leq a_i, m \leq 10^9$。

## 样例 #1

### 输入

```
5
1 2 4 3 5
2
4
7
```

### 输出

```
3
0
```

# AI分析结果



## 【算法分类】
哈希 或 二分查找

---

## 【题解思路与核心难点】

### 核心思路
题目要求快速判断给定数值是否存在，并返回其首次出现的位置。关键点在于：
1. **高效查找**：需在O(1)或O(logn)时间内完成查询
2. **首次出现位置**：当存在重复值时，需返回最早出现的位置

### 解决难点
- **重复值处理**：需确保记录的是第一次出现的位置
- **大规模数据**：需使用O(n)空间预处理，避免线性扫描

### 最优解法对比
| 方法         | 数据结构      | 时间复杂度 | 空间复杂度 | 处理重复值的正确性 |
|--------------|---------------|------------|------------|--------------------|
| 哈希表       | `map`         | O(n)预处理  | O(n)       | ✅（记录首次出现） |
| 排序+二分    | 结构体数组    | O(nlogn)   | O(n)       | ✅（需二次排序位置）|
| STL有序集合  | `set<pair>`   | O(nlogn)   | O(n)       | ✅（自动排序位置） |

---

## 【题解评分 (≥4星)】

### 5星题解
1. **引领天下（STL有序集合）**
   - **亮点**：利用`set<pair>`自动维护数值与位置的排序关系，结合`lower_bound`精准定位
   - **代码**：
     ```cpp
     set<pair<int,int>> st;
     for(int i=1;i<=n;i++){
         int s; cin >> s;
         st.insert(make_pair(s,i));
     }
     auto it = st.lower_bound(make_pair(m,0));
     ```

2. **DreamerY（哈希表）**
   - **亮点**：通过`!book[x]`条件确保只记录首次出现的位置
   - **核心代码**：
     ```cpp
     if (!book[x]) book[x] = i + 1;
     ```

---

## 【最优思路提炼】

### 关键技巧
1. **哈希表去重**：在插入时仅记录首次出现的位置
2. **复合排序**：按数值主序、位置次序排序，确保二分正确性
3. **STL特性**：利用`pair`默认比较规则实现双重排序

### 代码实现示例（哈希表）
```cpp
map<int, int> pos_map;
for(int i=1; i<=n; i++){
    int x; cin >> x;
    if(!pos_map.count(x)) pos_map[x] = i; // 仅记录首次出现
}
cout << (pos_map.count(m) ? pos_map[m] : 0);
```

---

## 【同类题目推荐】
1. [P1102 A-B数对](https://www.luogu.com.cn/problem/P1102) - 哈希/二分经典应用
2. [P1918 保龄球](https://www.luogu.com.cn/problem/P1918) - 本题原型
3. [P1177 快速排序](https://www.luogu.com.cn/problem/P1177) - 排序与查找基础

---

## 【可视化设计】

### 动画方案
1. **哈希表插入**：
   - 红色高亮新插入的键值对
   - 灰色显示后续重复值的覆盖过程（但实际不存储）
   
2. **二分查找**：
   ```plaintext
   初始数组：[1(1),2(2),4(3),3(4),5(5)] （数值(位置)）
   查找4：
   L=1, R=5 → mid=3 → 命中
   ```

### 复古像素风格
- **颜色方案**：16色调色板，用绿色表示命中元素，红色表示当前搜索区间
- **音效设计**：
  - 命中时：8-bit上升音阶（0x1A3F）
  - 未命中：短促爆破音（0x0F2C）

---

## 【核心代码实现】

### 哈希表法（DreamerY）
```cpp
#include <iostream>
#include <map>
using namespace std;

map<int, int> book;
int main() {
    int n, q, x;
    cin >> n;
    for(int i=0; i<n; i++) {
        cin >> x;
        if(!book[x]) book[x] = i+1; // 关键去重逻辑
    }
    cin >> q;
    while(q--) {
        cin >> x;
        cout << book[x] << endl;
    }
}
```

### 有序集合法（引领天下）
```cpp
#include <bits/stdc++.h>
using namespace std;

set<pair<int,int>> st;
int main() {
    ios::sync_with_stdio(0);
    int n, m, s, q;
    cin >> n;
    for(int i=1; i<=n; i++) {
        cin >> s;
        st.insert({s, i}); // 自动按(s,i)排序
    }
    cin >> q;
    while(q--) {
        cin >> m;
        auto it = st.lower_bound({m,0});
        cout << (it->first == m ? it->second : 0) << "\n";
    }
}
```

---
处理用时：249.61秒
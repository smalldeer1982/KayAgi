# 题目信息

# [CRCI 2008] PLATFORME 平板

## 题目描述

为了进行一种游戏，现决定搭造一些平板，而各个平板的地址已经选定。基于最普遍的认识，没有任何支持物的平板不可能漂浮在空中。说的更精确些，任意一平板的两端必需有支柱或者它在另一块平板上。

你会得到各个平板在坐标系中的坐标（如左下图）。每一块平板的坐标都是由它的高度（与地板间的垂直距离）和它的水平方位（开始和结束）决定的。每个支柱都距它支撑的平板的边缘半个单位（如图）。

算出支持所有平板的支柱的总长度。

 ![](https://cdn.luogu.com.cn/upload/pic/994.png) 



## 样例 #1

### 输入

```
3

1 5 10

3 1 5

5 3 7

```

### 输出

```
14```

# AI分析结果



## 算法分类
**贪心算法 + 模拟**

---

## 题解思路与核心难点

### 核心问题
每个平板的左右端点需要支撑，支柱长度 = 当前平板高度 - 下方支撑点的最大高度。总长度为所有支柱的累加。

### 题解对比与关键思路
1. **暴力枚举法（O(n²)）**  
   - 对每个平板，遍历其他所有平板，找到能支撑其左/右端的最高点。  
   - **难点**：正确处理边界条件（如端点对齐时是否算支撑）。  
   - **优化点**：无需预处理排序，直接两层循环判断。

2. **坐标倍增法（O(n)）**  
   - 将坐标扩大两倍，避免浮点运算。  
   - **核心代码**：`x1 *= 2; x2 *= 2;`  
   - **难点**：理解坐标转换后的区间覆盖逻辑。

3. **线段树法（O(n log H)）**  
   - 维护区间最大高度，每次查询左右端点的高度。  
   - **核心逻辑**：区间更新与单点查询。  
   - **难点**：处理开区间问题（修改区间为 `[l+1, r-1]`）。

### 最优思路提炼
1. **排序后处理**：按高度从低到高处理，保证下方平板已处理完毕。  
2. **投影覆盖法**：用数组记录每个坐标点的当前最大高度，每次更新覆盖区间。  
3. **贪心计算**：左右端点的支柱长度只需查询对应坐标的历史最大高度。

---

## 题解评分（≥4星）

1. **@mzyy1001（5星）**  
   - **亮点**：暴力法代码简洁，直接处理边界条件。  
   - **代码**：两层循环，直观判断支撑关系。

2. @Makasukaka（4星）  
   - **亮点**：线段树实现高效查询，支持大规模数据。  
   - **代码**：排序后区间更新，避免重复计算。

3. @常清静矣（4星）  
   - **亮点**：图解清晰，模拟投影覆盖法，代码易理解。  
   - **代码**：数组记录高度，直接更新覆盖区间。

---

## 核心代码实现（投影覆盖法）
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int MAX_N = 105;
struct Node { int y, x1, x2; };
Node a[MAX_N];
int height[20005] = {0}; // 坐标范围扩大两倍后覆盖

int main() {
    int n, ans = 0;
    cin >> n;
    for (int i = 0; i < n; ++i) {
        cin >> a[i].y >> a[i].x1 >> a[i].x2;
        a[i].x1 *= 2; a[i].x2 *= 2; // 坐标倍增处理
    }
    sort(a, a + n, [](const Node& u, const Node& v) { return u.y < v.y; });
    
    for (int i = 0; i < n; ++i) {
        int l = a[i].x1 + 1, r = a[i].x2 - 1;
        int h_left = height[l], h_right = height[r];
        ans += (a[i].y - h_left) + (a[i].y - h_right);
        for (int j = a[i].x1; j <= a[i].x2; ++j)
            height[j] = max(height[j], a[i].y);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 类似题目推荐
1. **P1904 天际线问题**（区间覆盖与最大值查询）  
2. **P5490 矩形面积并**（线段树处理区间覆盖）  
3. **P3740 贴海报**（投影覆盖法的变种）

---

## 可视化算法演示

### 动画设计
1. **像素风格**：  
   - **颜色**：平板用绿色，支柱用黄色，地面用灰色。  
   - **网格绘制**：每个坐标点对应一个像素块，高度用颜色渐变表示。  
   - **音效**：放置平板时播放“放置音效”，更新高度时播放“更新音效”。

2. **关键步骤演示**：  
   - **步进控制**：用户可单步执行每个平板的处理。  
   - **高亮操作**：当前平板用闪烁边框标记，查询的左右端点用红色标记。  
   - **数据面板**：实时显示当前支柱长度和总长度。

3. **复古交互**：  
   - **自动模式**：AI按高度顺序自动处理平板，速度可调。  
   - **积分系统**：每正确计算一个平板得10分，错误时扣分。

---

## 个人心得摘录
- **@重回巅峰！**：坐标倍增法避免浮点运算，但数组大小需足够大。  
- **@谬悠**：模拟投影覆盖法时，注意端点处理需转换为整数坐标。  
- **@rfsfreffr**：暴力法虽慢但代码简单，适合快速验证思路。

---
处理用时：72.20秒
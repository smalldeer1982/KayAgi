# 题目信息

# [USACO08JAN] iCow B

## 题目描述

被无止境的农活压榨得筋疲力尽后，FarmerJohn 打算用他在 MP3 播放器市场新买的 iCow 来听些音乐，放松一下。FJ 的 iCow 里存了 $N(1 \le N \le 1{,}000)$ 首曲子，按 $1..N$ 依次编号。至于曲子播放的顺序，则是按一个 FarmerJohn 自己设计的算法来决定：

- 第 $i$ 首曲子有一个初始权值 $R_i\ (1 \le R_i \le 10{,}000)$。
-  当一首曲子播放完毕，接下来播放的将是所有曲子中权值最大的那首（如果有两首或多首曲子的权值相同，那么这些曲子中编号最小的那首会被选中）。
- 一首曲子在播放结束后，它的权值会被平均地分给其他 $N-1$ 首曲子，它本身的权值清零。
- 如果一首曲子的权值无法被平均分配（也就是说，无法被 $N-1$ 整除），那么被 $N-1$ 除的余数部分将会以 $1$ 为单位，顺次分配给排名靠前的曲子（也就是说，顺序为曲目 $1$ 、曲目 $2 \cdots $ 依次下去。当然，刚播放过的那首曲子需要被跳过），直到多出的部分被分配完。

在选定的下一首曲子播放完毕后，这个算法再次被执行，调整曲子的权值，并选出再接下来播放的曲目。

请你计算一下，按 FJ 的算法，最先播放的 $T\ (1 \le T \le 1000)$ 首曲子分别是哪些。

## 说明/提示

每一首曲子播放前，三首曲子的权值分别为：

- $[10,8,11]$。播放 $\#3$，$11/2 = 5$，权值余量为 $1$。
- $[16,13,0]$。播放 $\#1$，$16/2 = 8$。
- $[0,21,8]$。播放 $\#2$，$21/2 = 10$，权值余量为 $1$。
- $[11,0,18]$。播放 $\#3$，……


## 样例 #1

### 输入

```
3 4
10
8
11
```

### 输出

```
3
1
2
3
```

# AI分析结果



**唯一算法分类**：模拟

---

### **题解思路、算法要点与解决难点**

1. **核心步骤**  
   - **查找最大值**：每次遍历数组找到当前最大权值及其索引  
   - **权值分配**：  
     - 将最大值按商 `value/(n-1)` 分配给其他元素  
     - 余数按顺序逐个分配+1（跳过当前播放的曲子）

2. **关键难点**  
   - **余数分配顺序**：必须严格按1→2→3顺序分配余数，且跳过已播放的曲子  
   - **零值处理**：播放后的曲子权值立即清零  
   - **边界条件**：`n=1` 时需特判（直接循环输出1）

3. **优化手段**  
   - **直接遍历分配**：无需排序，时间复杂度稳定为 `O(T*N)`  
   - **余数循环技巧**：通过 `while (余数>0)` 逐项分配，代码更简洁

---

### **题解评分 (≥4星)**

| 题解作者       | 评分 | 关键亮点                                                                 |
|----------------|------|--------------------------------------------------------------------------|
| **xhQYm**      | ⭐⭐⭐⭐ | 逻辑清晰，分商余两步处理，代码注释丰富                                  |
| **Mine_King**  | ⭐⭐⭐⭐ | 包含错误调试经验，强调余数分配顺序的重要性                              |
| **ZJMZJM**     | ⭐⭐⭐⭐ | 余数用 `while` 循环分配，代码最简洁                                      |

---

### **最优思路或技巧提炼**

- **权值分配两步法**：  
  1. 先计算商 `value/(n-1)` 并全局分配  
  2. 余数用循环逐个+1分配，跳过播放曲目  
  ```cpp
  // 示例代码片段（ZJMZJM）
  int shang = Max / (n-1), yushu = Max % (n-1);
  for (i=1; i<=n; i++) 
    if (i != seq) a[i] += shang;
  while (yushu > 0) {
    if (k != seq) a[k]++, yushu--;
    k++;
  }
  ```

- **查找最大值优化**：遍历时直接记录索引，避免二次查找

---

### **同类型题推荐**

1. **P1047 校门外的树**（模拟区间标记）  
2. **P1563 玩具谜题**（循环队列模拟）  
3. **P1067 多项式输出**（条件分支模拟）

---

### **可视化与算法演示**

**动画方案设计**：  
1. **像素风格界面**：  
   - 用16色像素块表示每首曲子的权值，高度与权值成正比  
   - 播放曲目标记为红色闪烁方块  
2. **权值分配过程**：  
   - 商分配：绿色箭头从播放曲目指向其他曲目，数值批量增加  
   - 余数分配：黄色光点逐个移动，每分配一次播放“滴”声  
3. **交互控制**：  
   - 速度滑块调节 `0.5x~3x`  
   - 步进按钮观察余数分配的每个+1操作  

**复古音效**：  
- `select.wav`：选中最大值时播放8-bit上升音  
- `distribute.wav`：每次余数分配时短促“哔”声  

---

### **核心代码实现**

```cpp
int n, T, a[1005];
cin >> n >> T;
for (int i=1; i<=n; i++) cin >> a[i];

while (T--) {
    // 1. 查找最大值
    int max_val = -1, idx = 0;
    for (int i=1; i<=n; i++) {
        if (a[i] > max_val) {
            max_val = a[i];
            idx = i;
        }
    }
    cout << idx << endl;

    // 2. 分配权值
    int quotient = a[idx] / (n-1);
    int remainder = a[idx] % (n-1);
    a[idx] = 0;

    // 分配商
    for (int i=1; i<=n; i++) {
        if (i != idx) a[i] += quotient;
    }

    // 分配余数（按顺序循环）
    int pos = 1;
    while (remainder > 0) {
        if (pos != idx) {
            a[pos]++;
            remainder--;
        }
        pos = (pos % n) + 1; // 环形遍历
    }
}
```

---

### **总结**

本题通过严格模拟权值分配规则，结合顺序遍历和余数循环技巧，确保时间复杂度为 `O(T*N)`，在数据范围内高效可行。关键点在于正确处理余数分配顺序和边界条件，避免因索引跳过导致的逻辑错误。

---
处理用时：74.45秒
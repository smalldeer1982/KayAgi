# 题目信息

# 神秘磁石

## 题目背景

在遥远的阿拉德大陆，有一种神秘的磁石，是由魔皇制作出来的，


## 题目描述

1. 若给他一个一维坐标系，那么他的磁力一定要在素数坐标的位置上才能发挥的最大（不管位置坐标的大小，只要是素数那么磁力就一样大）。
2. 若两个磁石相距为 $k$，那么磁石间的破坏力将会达到当前磁力的峰值

显然，两磁石间最大破坏力取决于磁力大小和磁石间距，那么请问给出长度不超过 $n$ 的一维坐标系，有哪几对坐标间磁石破坏力最大。


## 说明/提示

对于 $100\%$ 的数据，$1\leq k\leq n\leq 10^4$。

## 样例 #1

### 输入

```
6924 809```

### 输出

```
2 811
```

# AI分析结果



## 【唯一算法分类】  
线性筛法（欧拉筛）

---

## 【题解思路、算法要点与解决难点】  
**核心思路**：  
1. **素数生成**：通过线性筛法（欧拉筛）高效生成 `n` 范围内的素数表，时间复杂度为 `O(n)`。  
2. **遍历判断**：遍历所有素数，检查 `当前素数 + k` 是否也是素数且不超过 `n`。  

**解决难点**：  
1. **高效生成素数**：线性筛法通过标记每个合数的最小质因子，避免重复标记，显著提升效率。  
2. **避免冗余检查**：直接遍历素数数组而非所有数字，减少无效判断。  

---

## 【题解评分 (≥4星)】  
1. **引领天下 (5星)**  
   - **亮点**：使用线性筛法生成素数表，维护素数数组直接遍历，时间复杂度最优。  
   - **代码简洁性**：清晰的主逻辑和预处理分离，适合快速理解。  

2. **YLWang (4星)**  
   - **亮点**：打表法预处理素数标记，查询时直接 `O(1)` 判断，适合多次查询场景。  
   - **缺点**：预处理代码较长，需额外文件操作。  

3. **likztime (4星)**  
   - **亮点**：Miller-Rabin 算法展示概率性素数测试，适合大数场景。  
   - **缺点**：实现复杂，本题数据规模下略显冗余。  

---

## 【最优思路或技巧提炼】  
1. **线性筛法**：  
   ```cpp  
   void sieve() {
       memset(is_prime, true, sizeof(is_prime));
       is_prime[0] = is_prime[1] = false;
       for (int i = 2; i <= n; i++) {
           if (is_prime[i]) primes.push_back(i);
           for (int p : primes) {
               if (i * p > n) break;
               is_prime[i * p] = false;
               if (i % p == 0) break; // 关键优化：保证只标记一次
           }
       }
   }
   ```  
2. **素数对遍历**：  
   ```cpp  
   for (int p : primes) {
       if (p + k > n) break;
       if (is_prime[p + k]) cout << p << " " << p + k << endl;
   }
   ```  

---

## 【同类型题或类似算法套路】  
1. **孪生素数对**：寻找相差为2的素数对。  
2. **连续素数区间**：在给定范围内找连续素数组成的子数组。  
3. **筛法扩展**：如区间筛法、质因数分解预处理。  

---

## 【推荐题目】  
1. **P3383** 【模板】线性筛素数  
2. **P1217** [USACO1.5]回文质数  
3. **P1304** 哥德巴赫猜想  

---

## 【可视化与算法演示】  
**核心逻辑动画设计**：  
1. **筛法过程**：  
   - **网格显示**：数字从2到n排列成网格，被标记为合数时变为红色，素数保持绿色。  
   - **高亮当前数**：当前处理的素数 `i` 显示为黄色，其倍数逐步标记为红色。  
   - **音效**：标记合数时播放“哔”声，找到素数时播放“叮”声。  

2. **素数对搜索**：  
   - **步进显示**：遍历素数数组时，当前素数 `p` 高亮为蓝色，检查 `p+k` 时高亮为紫色。  
   - **成功匹配**：若 `p+k` 是素数，两者同时闪烁并播放“胜利”音效。  

**复古像素风格**：  
- **8位调色板**：使用经典FC游戏的16色调色板（如绿色、红色、黄色）。  
- **Canvas动画**：用像素方块表示数字，筛法过程类似“扫雷”动态效果。  

---

## 【代码片段（线性筛法核心）】  
```cpp  
#include <vector>
#include <cstring>
using namespace std;

const int MAX_N = 1e4 + 5;
bool is_prime[MAX_N];
vector<int> primes;

void sieve(int n) {
    memset(is_prime, true, sizeof(is_prime));
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i <= n; i++) {
        if (is_prime[i]) primes.push_back(i);
        for (int p : primes) {
            if (i * p > n) break;
            is_prime[i * p] = false;
            if (i % p == 0) break;
        }
    }
}
```  

---

## 【个人心得摘录】  
- **调试教训**：初始忘记处理 `i % p == 0` 导致重复标记，需严格遵循线性筛法逻辑。  
- **优化顿悟**：直接遍历素数数组而非全范围，减少循环次数约90%（实测数据）。  

--- 

通过上述分析和实现，可高效解决素数对问题，并为类似题目提供通用优化思路。

---
处理用时：82.39秒
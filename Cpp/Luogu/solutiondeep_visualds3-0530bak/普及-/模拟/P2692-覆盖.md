# 题目信息

# 覆盖

## 题目背景

WSR 的学校有 $B$ 个男生和 $G$ 个女生都来到一个巨大的操场上扫地。

## 题目描述

操场可以看成是 $N$ 行 $M$ 列的方格矩阵，如下图 (1) 是一个 $4$ 行 $5$ 列的方格矩阵。每个男生负责打扫一些连续的行，每个女生负责打扫一些连续的列。比如有两个男生，第一个男生负责第 $1, 2$ 两行、第二个男生负责第 $4$ 行，如图 (2) 的蓝色。打扫的区域可能重复，比如，又有两个女生，第一个女生负责打扫第 $3, 4$ 两列，第二个女生负责打扫第 $4, 5$ 两列，如图 (3) 的红色。从图 (3) 可以容易看出，有颜色覆盖的方格数为 $18$，即这 $4$ 名学生总共打扫了 $18$ 个方格。

![](https://cdn.luogu.com.cn/upload/pic/1474.png) 

老师要 WSR 在学校给出打扫安排的数据后快速计算出这些学生总共打扫了多少方格。

## 说明/提示

不会可以自己画图。

### 数据范围与约定

对于 $80\%$ 的数据，$1 \le N,M,B,G \le 10^2$。

对于 $100\%$ 的数据，$ 1 \le N,M,B,G \le 5 \times 10^3$。

## 样例 #1

### 输入

```
4 5 2 2
1 2
4 4
3 4
4 5```

### 输出

```
18```

# AI分析结果



## 算法分类
**容斥原理 + 差分数组**

---

## 题解思路与算法要点

### 核心思路
1. **容斥原理**：总覆盖面积 = 行覆盖贡献 + 列覆盖贡献 - 行列重叠部分。
2. **差分数组优化**：用差分数组快速标记行和列的覆盖区间，统计最终覆盖的行数和列数。

### 解决难点
- **避免暴力遍历**：直接遍历每个行或列的区间会带来 O(B*N) 的时间复杂度，在 B=5e3 时可能超时。
- **重复覆盖处理**：通过差分数组标记覆盖区间后，只需线性时间统计有效覆盖行数和列数。
- **公式推导**：总覆盖面积公式为 `ans1*M + ans2*N - ans1*ans2`，其中 `ans1` 是覆盖行数，`ans2` 是覆盖列数。

---

## 题解评分（≥4星）

### 1. s_a_b_e_r（5星）
- **亮点**：代码极简，直接应用容斥公式，时间复杂度 O(N+M)。
- **代码**：
  ```cpp
  for(int i=1;i<=B;i++) Y[x..y] = 1; // 标记行覆盖
  for(int i=1;i<=G;i++) X[x..y] = 1; // 标记列覆盖
  ans = ans1*M + ans2*N - ans1*ans2;
  ```

### 2. gzw2005（5星）
- **亮点**：差分数组高效标记区间，公式推导清晰。
- **代码片段**：
  ```cpp
  while(b--) boy[x]++, boy[y+1]--; // 差分标记行
  for(int i=1;i<=n;i++) row += (前缀和 > 0);
  ans = row*M + column*N - row*column;
  ```

### 3. JackcreaM（4星）
- **亮点**：容斥思路明确，但未使用差分优化。
- **代码**：
  ```cpp
  for(j=x;j<=y;j++) if(!h[j]) hsum++; // 直接统计行覆盖
  ans = hsum*(m - lsum) + n*lsum;    // 应用容斥公式
  ```

---

## 最优思路提炼
1. **差分标记**：用差分数组在 O(1) 时间标记区间覆盖，前缀和统计有效覆盖数。
2. **容斥公式**：总覆盖 = 行覆盖数×列数 + 列覆盖数×行数 - 行覆盖数×列覆盖数。
3. **时间复杂度**：O(B + G + N + M)，完美适配 5e3 数据规模。

---

## 类似题目推荐
1. **P3406 海底高铁**（差分数组应用）
2. **P1719 最大加权矩形**（二维前缀和与差分）
3. **P1888 三角形面积**（容斥原理与几何）

---

## 可视化设计
### 核心逻辑演示
1. **像素风格渲染**：用 16 色像素块表示行和列覆盖。
   - **红色块**：已覆盖的行。
   - **蓝色块**：已覆盖的列。
   - **紫色块**：行和列的重叠区域。
2. **动画流程**：
   - **步骤1**：逐帧绘制男生覆盖的行（红色从左到右填充）。
   - **步骤2**：逐帧绘制女生覆盖的列（蓝色从上到下填充）。
   - **步骤3**：高亮重叠区域（紫色闪烁）。
   - **步骤4**：显示公式计算过程，动态更新结果。
3. **音效交互**：
   - **覆盖行/列**：8-bit "哔"声。
   - **计算完成**：胜利音效。

### 代码片段（JS Canvas）
```javascript
// 绘制覆盖行
function drawRowCover(ctx, row) {
    ctx.fillStyle = '#FF0000'; // 红色
    ctx.fillRect(0, row*CELL_SIZE, CANVAS_WIDTH, CELL_SIZE);
    playSound('beep'); // 触发音效
}

// 绘制覆盖列
function drawColCover(ctx, col) {
    ctx.fillStyle = '#0000FF'; // 蓝色
    ctx.fillRect(col*CELL_SIZE, 0, CELL_SIZE, CANVAS_HEIGHT);
    playSound('beep');
}
```

---

## 个人心得摘录
> **翼德天尊**：  
> “暴力模拟会 TLE，必须用行标记优化。女生的列覆盖只需处理未被行覆盖的区域。”  
> **调试经验**：初始代码未考虑行覆盖的优化，导致 80% 数据超时，后改用行标记后 AC。

> **gzw2005**：  
> “差分数组将区间操作从 O(N) 降到 O(1)，这是处理大规模区间的关键技巧。”

---

## 核心算法代码
### 差分+容斥（gzw2005 实现）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,b,g,boy[5005],girl[5005],row,column;
int main(){
    cin>>n>>m>>b>>g;
    while(b--){
        int x,y; cin>>x>>y;
        boy[x]++; boy[y+1]--; // 差分标记行
    }
    while(g--){
        int x,y; cin>>x>>y;
        girl[x]++; girl[y+1]--; // 差分标记列
    }
    for(int i=1,sum=0;i<=n;i++){
        sum += boy[i];
        if(sum > 0) row++;
    }
    for(int i=1,sum=0;i<=m;i++){
        sum += girl[i];
        if(sum > 0) column++;
    }
    cout<<row*m + column*n - row*column;
    return 0;
}
```

---
处理用时：106.58秒
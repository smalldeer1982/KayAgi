# 题目信息

# [AHOI2016初中组] 自行车比赛

## 题目描述

小雪非常关注自行车比赛，尤其是环滨湖自行车赛。一年一度的环滨湖自行车赛，需要选手们连续比赛数日，最终按照累计得分决出冠军。今年一共有 $N$ 位参赛选手。每一天的比赛总会决出当日的排名，第一名的选手会获得 $N$ 点得分，第二名会获得 $N-1$ 点得分，第三名会获得 $N-2$ 点得分，依次类推，最后一名会获得 $1$ 点得分。保证没有选手会排名相同。


在之前的数日较量中，$N$ 位选手已经分别累计了一些分数。现在即将开始的是最后一天的比赛。小雪希望知道有多少位选手还有可能获得最终的冠军，也就是说还有多少选手有可能通过最后一天的比赛获得累计总分第一名。


## 说明/提示

### 数据范围及约定

- 对于 $20\% $ 的数据，$3\le N\le 600$。
- 对于 $50\%$  的数据，$3\le N\le 1\times 10^4$。
- 对于 $100\%$ 的数据，$3\le N\le 3\times 10^5$ 且 $0\le B_i\le 2\times 10^6$。


## 样例 #1

### 输入

```
3
8
10
9```

### 输出

```
3```

## 样例 #2

### 输入

```
5
15
14
15
12
14```

### 输出

```
4```

# AI分析结果



**唯一算法分类**  
贪心算法

**综合分析与结论**  
题目要求确定在最后一天比赛后可能成为冠军的选手数量。核心思路是：假设某选手在最后一天获得最高分N，其他选手的得分尽可能低，以最小化他们的总分。通过排序和预处理每个选手的最优可能总分，计算最大值后进行比较。

**关键步骤**  
1. **排序**：将选手的当前得分排序，以便于后续处理。
2. **预处理最优总分**：对每个选手计算其在最优分配下的总分（即原分加上可能的最低最后一天得分）。
3. **比较总分**：统计每个选手的总分（原分+N）是否不小于预处理的最大值。

**题解清单 (≥4星)**  
1. **小粉兔 (5星)**  
   - 升序排序后计算每个位置的最优总分，遍历时从后往前，利用有序性提前终止遍历。代码简洁高效，思路清晰。
2. **_ZZH (4星)**  
   - 降序排序并计算每个位置的最优总分，逻辑与升序类似，但代码更简洁，直接使用降序排序。
3. **wubaiting2020 (4星)**  
   - 与_ZZH思路一致，代码实现类似，但包含详细注释，可读性较好。

**最优思路或技巧提炼**  
- **贪心策略**：通过排序使原分高的选手在最后一天获得更低分，从而最小化他们的总分。
- **预处理最大值**：计算每个选手在最优分配下的总分，取最大值作为判断阈值。
- **提前终止遍历**：利用排序后的有序性，一旦发现不满足条件的选手，即可终止后续判断。

**同类型题或类似算法套路**  
- 类似贪心+排序问题，如分配资源使最大值最小、任务调度优化等。
- 推荐题目：洛谷P1090（合并果子）、P1223（排队接水）、P1842 [USACO05NOV] 奶牛玩杂技。

**个人心得摘录**  
- 在比赛时，通过分析样例突然意识到贪心策略的正确性，排序后预处理极大简化问题。
- 调试中发现排序方向影响预处理逻辑，需仔细验证。

**可视化与算法演示**  
1. **排序过程**：动态展示选手得分排序，升序/降序排列。
2. **预处理计算**：高亮每个选手的最优总分计算（如原分+位置相关值）。
3. **比较阶段**：逐个检查选手的总分（原分+N），若满足条件则标记为绿色，否则红色并终止。

**复古游戏化动画效果**  
- **8位像素风格**：选手得分以像素方块表示，排序时方块移动并变色。
- **音效提示**：排序完成时播放“升级”音效，符合条件选手触发“得分”音效。
- **自动演示**：自动播放排序、预处理、比较过程，用户可暂停/调节速度。

---

**代码片段（核心逻辑）**  
```cpp
// 小粉兔的代码片段（升序排序）
sort(b+1, b+n+1);
for(int i=1; i<=n; i++)
    c[i] = b[i] + (n - i + 1);
int mx = *max_element(c+1, c+n+1);
for(int i=n; i>=1; i--)
    if(b[i]+n >= mx) ans++;
    else break;
```

```cpp
// _ZZH的代码片段（降序排序）
sort(b+1, b+n+1, greater<int>());
int maxx = 0;
for(int i=1; i<=n; i++)
    maxx = max(maxx, b[i] + i);
for(int i=1; i<=n; i++)
    if(b[i]+n >= maxx) ans++;
    else break;
```

**可视化设计要点**  
- **颜色标记**：排序时当前比较元素高亮黄色，预处理阶段计算值显示为蓝色，最终符合条件选手绿色。
- **Canvas动画**：用网格表示选手得分，排序时交换位置动画，预处理阶段显示计算值，比较阶段动态标记结果。

---
处理用时：224.92秒
# 题目信息

# 夏幻的考试

## 题目背景

夏之幻是软件工程系的大神，学校把举办考试的任务交给她了。


## 题目描述

某大学软工专业要举办一场笔试，学生们要在机读答题卡上填写答案来进行答题。学校把机读卡识别任务交给了夏之幻，但是这套系统的需求太复杂了，她还要做自己的其他项(you)目(xi)，所以她想让你来帮忙实现一部分功能。

试卷分卷头，单选题两部分。

夏幻大神已经写好了识别程序，因此卷头和答案将直接以数字信息的形式呈现给你，你要实现下面几个功能:

需要处理T张试卷，按顺序检查下列选项。

1.检查考号的填写是否准确。

输入信息的格式:

一行，一个16位无符号二进制数id。表示考生的考号为id，正确的考号范围在十进制下是1~10000。

如果考号有错误，输出一行“Wrong ID”并结束对这张试卷的处理(剩下两个选项的数据依然要读入，但不输出任何内容)，不含引号。如果考号正确，输出一行,“ID: ”+一个整数，表示考号的十进制形式。不含引号。

无需考虑考号是否重复，只要在范围内均为正确。

2.检查试卷类型是否正确。

输入信息格式:

一行，两个整数，中间无分隔，只能是0或者1。第一个整数表示试卷类型A是否被涂黑(0表示未涂黑，1表示涂黑)，第二个整数表示试卷类型B是否涂黑。其实试卷类型可以由二进制考号的最后一位得到，0表示A卷，1表示B卷，你只需要检查考生填涂的是否正确。

如果考生将试卷类型正确填涂(填涂且只填涂了正确的那一项)，输出一行“Type Correct”，否则输出一行“Type Incorrect”，不含引号。无论试卷类型是否填涂正确，你还需要接着处理这张试卷。

3.给单选题打分。

单选题的数量n和标准答案将会在录入第一张试卷前给出。

考生答案的输入格式:

n行，每行4个整数，中间无分隔。每个整数是0或1。

按顺序分别代表A,B,C,D是否被涂黑(0表示未涂黑，1表示涂黑)。考生回答正确当且仅当该题正确答案的位置被涂黑，且错误答案的位置未被涂黑。

输出一行，一个四舍五入到小数点后1位的浮点数，表示考生的得分，满分为100分，每个题的分数相同。


## 说明/提示

对于100%的数据

1<=T<=1000

1<=n<=50

注意:

1.请在最后一个试卷处理完后也加上一个换行

2.由于win系统和linux系统换行的不同，建议不要使用scanf读入char


## 样例 #1

### 输入

```
2 5
ABCAD
0000000011111111
01
1000
0010
0100
1000
0010
1001001001001001
01
0001
1010
0111
1111
0000```

### 输出

```
ID: 255
Type Correct
40.0

Wrong ID```

## 样例 #2

### 输入

```
3 3
ABC
0000000000000000
01
1111
0001
0100
0000000000000010
10
1000
0100
0010
0000000000000011
11
0001
0000
0010
```

### 输出

```
Wrong ID

ID: 2
Type Correct
100.0

ID: 3
Type Incorrect
33.3
```

## 样例 #3

### 输入

```
5 31
ACAACCDDBBDADDCBCACCDBCAACAAAAC
0000101111000001
10
1000
0010
1000
1111
0010
0010
0001
0001
0100
0100
0001
1000
0001
0001
0010
1111
0010
1000
0010
0010
0001
0100
1111
1000
1000
0010
1000
0100
1000
1000
0010
0000010101001111
10
1000
0010
1000
1000
0010
0010
0001
0001
0100
0100
0001
1000
0001
0001
0010
0100
1000
1000
0000
0010
0001
0100
0010
1000
1000
0010
1000
1000
0000
0000
0010
0001110001100110
11
1000
0010
1000
1000
0010
0010
0001
0001
0100
0100
0001
1000
0010
0100
0010
0100
0010
0100
0010
0010
0001
0100
0010
1000
1000
0010
1000
1111
1000
1000
0010
0001001111110001
10
1010
0010
1000
1000
0010
0010
0001
0001
0100
0100
0010
1000
0001
0001
0010
0100
0010
1000
0010
0010
0001
0100
0010
1000
1000
0010
1000
1000
1000
1000
0010
0001110010000100
10
1000
0010
1000
1000
0000
0010
0001
0001
0100
0100
0001
1000
0001
0001
0001
0100
0010
1000
0010
0010
0001
0100
0010
1000
1000
0010
1000
1000
0000
1000
0001
```

### 输出

```
ID: 3009
Type Incorrect
87.1

ID: 1359
Type Incorrect
87.1

ID: 7270
Type Incorrect
87.1

ID: 5105
Type Incorrect
93.5

ID: 7300
Type Correct
87.1
```

# AI分析结果



**1. 算法分类**  
无算法分类（纯模拟题）

---

### **2. 题解思路、算法要点与解决难点**

#### **核心逻辑分析**
1. **考号验证**  
   - **二进制转十进制**：所有题解均采用逐位加权累加（`id += bit * 2^(15-i)`），但实现方式不同：  
     - *SLYZ_0120* 用 `pow(2, 16-i)` 可能导致浮点误差  
     - *引领天下* 用预计算的 `pow2x` 数组更高效  
     - *Night_Aurora* 用位运算 `id += (c-'0')<<(15-i)` 避免浮点  
   - **范围判断**：直接判断 `1 ≤ id ≤ 10000`

2. **试卷类型判断**  
   - **关键推导**：考号最后一位决定类型（0→A卷，1→B卷），正确填涂需满足：  
     - A卷：填涂格式为 `10`（仅A涂黑）  
     - B卷：填涂格式为 `01`（仅B涂黑）  
   - **常见错误**：未处理 `11` 或 `00` 的非法填涂（如 *HDawn* 题解）

3. **单选题评分**  
   - **标准答案预处理**：将 `A/B/C/D` 映射为 `1000/0100/0010/0001` 的字符串或数值  
   - **答案比对**：考生答案需与标准答案完全一致（正确位涂黑且错误位未涂）  
   - **效率优化**：  
     - *Eason_AC2* 将答案转为整数（如 `1000→1000`）加速比对  
     - *反比例函数* 用字符串直接比较（`if (r[i] == "1000")`）

#### **解决难点对比**
| 难点                | 优秀解法（如 SLYZ_0120） | 易错解法（如 RiverFun）     |
|---------------------|--------------------------|----------------------------|
| 二进制转十进制      | 位运算避免浮点误差       | 使用 `pow` 导致精度问题     |
| 试卷类型填涂判断    | 明确处理非法填涂         | 漏判 `11` 或 `00` 的情况   |
| 答案匹配效率        | 预存标准答案字符串       | 逐字符比对增加时间复杂度   |
| 输入格式处理        | 统一用 `cin` 避免换行问题 | 混用 `scanf` 导致换行错误   |

---

### **3. 题解评分 (≥4星)**

#### **SLYZ_0120（★★★★☆）**
- **亮点**：模块化函数设计，输入处理严谨（全用 `cin` 避免换行问题），代码可读性强  
- **缺点**：`pow` 函数可能引入浮点误差

#### **引领天下（★★★★☆）**
- **亮点**：预计算 `pow2x` 数组优化性能，答案比对逻辑清晰  
- **缺点**：未处理答案字符串长度异常（如 `str.size() !=4`）

#### **反比例函数（★★★★☆）**
- **亮点**：二进制转换用位运算，答案比对用字符串直接匹配  
- **缺点**：未处理考生填涂多个选项的非法情况

---

### **4. 最优思路或技巧提炼**

#### **核心技巧**
1. **二进制转十进制**：用位运算 `id += (c-'0') << (15-i)` 避免浮点误差  
2. **试卷类型判断**：通过 `考号末位 ^ 填涂值` 快速验证（如 `末位为1 → 填涂应为01`）  
3. **答案预处理**：将标准答案提前转为 `1000` 等字符串，直接比对考生输入  
4. **输入安全**：统一使用 `cin` 或 `getchar` 处理字符，避免 `scanf` 的换行问题  

#### **代码片段**
```cpp
// 二进制转十进制（位运算优化）
int id = 0;
for (int i=0; i<16; i++) {
    char c = getchar();
    id = (id << 1) | (c - '0'); // 左移累加
}

// 试卷类型判断
bool check_type(int last_bit, string filled) {
    return (last_bit == 0 && filled == "10") || 
           (last_bit == 1 && filled == "01");
}

// 答案比对（字符串预处理）
vector<string> std_ans;
for (char c : correct_str) {
    std_ans.push_back(c == 'A' ? "1000" : ... );
}
```

---

### **5. 同类型题与算法套路**

#### **相似题型**
- **二进制处理**：洛谷 P1017（进制转换）、P1143（数制转换）  
- **模拟题**：洛谷 P1055（ISBN号码）、P1328（生活大爆炸）  
- **字符串匹配**：洛谷 P3375（KMP模板）、P1308（统计单词数）  

---

### **6. 推荐洛谷题目**
1. **P1017** - 进制转换（二进制与负进制处理）  
2. **P1055** - ISBN号码（输入格式校验与模拟）  
3. **P1328** - 生活大爆炸（规则模拟与状态比对）  

---

### **7. 个人心得摘录**
- *SLYZ_0120*：因混用 `cout << endl` 和 `\n` 导致 WA，最终统一用 `printf`  
- *Eason_AC2*：调试时发现考号末位未从二进制字符串正确提取，改用 `str[15]`  
- *引领天下*：因未初始化 `id` 变量导致随机值，增加 `id = 0` 重置逻辑  

---

### **8. 可视化与算法演示**

#### **动画设计**
1. **二进制转换**：  
   - **像素网格**：16位二进制逐位高亮，右侧同步显示十进制累加过程  
   - **音效**：每处理一位播放 `8-bit` 点击音效，错误时播放下降音调  

2. **试卷类型判断**：  
   - **状态面板**：左侧显示考号末位（0/1），右侧显示填涂区域（A/B），正确时高亮绿色，错误闪烁红色  

3. **答案比对**：  
   - **逐题对比**：Canvas 网格显示标准答案与考生答案，匹配题号亮绿，错误亮红  
   - **得分进度条**：底部进度条随正确题数增长，配上扬音效  

#### **复古游戏化**
- **背景**：FC风格卷轴背景，仿《超级马里奥》砖块元素  
- **控制**：  
  - 方向键控制单步执行（←/→切换步骤，↑/↓调节速度）  
  - 空格键暂停/继续，`R` 重放当前步骤  
- **音效**：  
  - 正确时播放《塞尔达》解锁音效  
  - 错误时播放《魂斗罗》中弹音效  

#### **代码片段（Canvas 绘制）**
```javascript
// 绘制二进制转换动画
function drawBinary(bits, id) {
    ctx.fillStyle = "#8B00FF"; // 复古紫
    bits.forEach((bit, i) => {
        if (bit === '1') ctx.fillRect(20 + i*30, 50, 25, 25); // 高亮位
    });
    ctx.fillText(`ID: ${id}`, 100, 150);
}
```

---
处理用时：103.15秒
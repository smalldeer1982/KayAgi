# 题目信息

# 小A的糖果

## 题目描述

小 A 有 $n$ 个糖果盒，第 $i$ 个盒中有 $a_i$ 颗糖果。

小 A 每次可以从其中一盒糖果中吃掉一颗，他想知道，要让任意两个相邻的盒子中糖的个数之和都不大于 $x$，至少得吃掉几颗糖。


## 说明/提示

#### 样例输入输出 1 解释

吃掉第 2 盒中的一个糖果即可。

---

#### 样例输入输出 2 解释

第 2 盒糖吃掉 $6$ 颗，第 4 盒吃掉 $2$ 颗，第 6 盒吃掉 $3$ 颗。

---

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 20$，$a_i, x \leq 100$。
- 对于 $70\%$ 的数据，保证 $n \leq 10^3$，$a_i, x \leq 10^5$。
- 对于 $100\%$ 的数据，保证 $2 \leq n \leq 10^5$，$0 \leq a_i, x \leq 10^9$。

## 样例 #1

### 输入

```
3 3
2 2 2```

### 输出

```
1
```

## 样例 #2

### 输入

```
6 1
1 6 1 2 0 4```

### 输出

```
11```

## 样例 #3

### 输入

```
5 9
3 1 4 1 5```

### 输出

```
0
```

# AI分析结果



# 小A的糖果 - 题解分析

## 算法分类
贪心算法

---

## 题解思路与解决难点
### 核心思路
从左到右遍历每个盒子，若当前盒子与前一个盒子的糖果总和超过x，优先减少当前盒子的糖果。此举可同时优化后续相邻对的糖果数，实现局部最优到全局最优。

### 关键难点与解决
1. **处理顺序**：必须从左向右处理，确保每次调整只影响后续相邻对。
2. **数值溢出**：需使用`long long`存储结果，避免大数溢出。
3. **负数问题**：调整当前盒子时需确保其数值不小于0（部分题解未处理，但实际数据保证不会出现负数）。

### 算法流程
1. **初始化**：读取第一个盒子的值，若其超过x则调整。
2. **遍历处理**：从第二个盒子开始，与前一个盒子求和：
   - 若总和超过x，计算需吃掉的糖果数，并调整当前盒子的值。
3. **累加结果**：每次调整后累加吃掉的糖果数。

---

## 题解评分（≥4星）

### 作者：a___（5星）
- **亮点**：单独处理第一个盒子，避免负数；代码简洁高效，边读入边处理。
- **代码片段**：
  ```cpp
  for (i=1;i<=n;i++) {
      scanf("%lld",&a[i]);
      if (a[i]+a[i-1]>x) {
          yy=a[i]+a[i-1]-x;
          a[i]-=yy;
          ans+=yy;
      }
  }
  ```

### 作者：_txb_（4星）
- **亮点**：明确注释贪心策略，代码简洁易懂。
- **代码片段**：
  ```cpp
  for(int i=1;i<=n;i++) {
      if(a[i]+a[i-1]>x) {
          int tmp=a[i]+a[i-1]-x;
          sum+=tmp;
          a[i]-=tmp;
      }
  }
  ```

### 作者：myfly（4星）
- **亮点**：使用滚动变量`rex`节省内存，避免数组存储。
- **代码片段**：
  ```cpp
  for (int i=0,x,rex=0,sub; i<N; i++) {
      cin>>x;
      if (x+rex>M) {
          sub=x+rex-M;
          ans+=sub;
          x-=sub;
      }
      rex=x;
  }
  ```

---

## 最优技巧提炼
1. **贪心顺序**：优先调整右侧盒子，以最小化后续影响。
2. **滚动处理**：仅需保存前一个盒子的值，无需存储完整数组。
3. **边界处理**：无需单独处理第一个盒子，遍历时自动处理相邻对。

---

## 同类题目推荐
1. **P1094 纪念品分组**（贪心，双指针）
2. **P1223 排队接水**（贪心，排序）
3. **P5019 铺设道路**（贪心，相邻差值）

---

## 个人心得摘录
- **数据范围**：多位作者因未使用`long long`导致WA，需注意数值范围。
- **调整顺序**：先处理左侧再调整右侧，避免重复计算。
- **负数陷阱**：部分题解假设调整后不会出现负数，实际数据保证此条件成立。

---

## 可视化设计
### 动画方案
- **像素风格**：盒子以8位像素方块表示，糖果数为方块高度。
- **关键步骤**：
  1. **高亮相邻盒子**：当前处理的对用闪烁边框标记。
  2. **数值调整**：被吃掉的糖果以粒子效果消失，当前盒子高度减少。
  3. **音效触发**：每次吃掉糖果播放短促音效，调整完成时播放成功音调。
- **交互控制**：支持暂停/步进，速度调节滑块（1x-5x）。

### 复古游戏化
- **背景音乐**：8位芯片音乐循环播放。
- **积分系统**：每正确调整一个盒子获得10分，连续正确调整触发连击奖励。
- **AI演示**：自动运行模式展示算法流程，类似贪吃蛇AI路径演示。

---

## 核心代码实现
```cpp
#include <iostream>
using namespace std;

int main() {
    long long n, x, prev = 0, ans = 0;
    cin >> n >> x;
    for (int i = 0; i < n; ++i) {
        long long curr;
        cin >> curr;
        if (prev + curr > x) {
            long long eat = prev + curr - x;
            ans += eat;
            curr -= eat;
        }
        prev = curr;
    }
    cout << ans << endl;
    return 0;
}
```

---
处理用时：67.30秒
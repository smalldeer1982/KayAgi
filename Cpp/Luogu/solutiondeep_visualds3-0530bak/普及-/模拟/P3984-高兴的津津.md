# 题目信息

# 高兴的津津

## 题目描述

津津上高中了。她在自己的妈妈的魔鬼训练下，成为了一个神犇，每次参加一次 OI 比赛必拿 Au 虐全场。每次她拿到一个 Au 后就很高兴。假设津津不会因为其它事高兴，并且她的高兴会持续 $T$ 天（包含获奖当天。就算在高兴的时候再次拿到 Au，他的高兴也只能维持包括这次拿奖之日起 $T$ 天，而不是额外增加 $T$ 天的高兴时间，除非之后再拿奖）。请你帮忙检查一下津津接下来的的日程安排，要参加 $n$ 场比赛，看看接下来的几天，津津会累计开心多久？

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1\le n\le2\times10^5$。
- $1\le T\le10^9$。
- $1\le t_i\le 10^9$，$t_i$ 单调递增。

## 样例 #1

### 输入

```
3 5
1 2 10```

### 输出

```
11```

# AI分析结果



## 算法分类  
**贪心算法 / 区间合并**

---

## 题解思路与核心算法分析  
### 核心逻辑与解决难点  
1. **问题本质**：每个获奖时间点对应一个区间 `[t_i, t_i + T)`，求这些区间的总覆盖天数。  
2. **贪心策略**：遍历相邻的两个获奖时间点 `t[i]` 和 `t[i-1]`，根据间隔 `Δt = t[i] - t[i-1]` 判断是否重叠：  
   - 若 `Δt < T`：区间部分重叠，累加 `Δt`（即两区间重叠部分仅需计算差值）  
   - 若 `Δt ≥ T`：区间不重叠，累加 `T`（前一个区间独立贡献 `T` 天）  
3. **最后处理**：最后一次获奖的高兴时间一定覆盖完整的 `T` 天，直接累加。  

### 关键实现技巧  
- **无需数组存储**：仅需记录前一个时间点 `last`，在线处理输入。  
- **时间复杂度**：`O(n)`，适用于 `n ≤ 2e5` 的数据规模。  
- **空间优化**：使用 `long long` 避免溢出（当 `T ≤ 1e9` 且 `n` 较大时）。  

---

## 题解评分（≥4星）  
### 1. zy小可爱ღ（★★★★☆）  
- **亮点**：代码简洁，直接遍历相邻时间差，最后补上 `T`。  
- **代码核心**：  
  ```cpp  
  for(int i=2; i<=n; i++) {  
    if(a[i]-a[i-1] < t) ans += a[i]-a[i-1];  
    else ans += t;  
  }  
  printf("%d\n", ans + t);  
  ```  
- **简评**：清晰易懂，适合快速理解核心逻辑。  

### 2. hsfzLZH1（★★★★☆）  
- **亮点**：数学推导区间覆盖公式，避免逐个判断。  
- **代码核心**：  
  ```cpp  
  if(a[i] >= a[i-1]+t) ans += t;  
  else ans += a[i] - a[i-1];  
  ```  
- **简评**：通过区间端点直接计算覆盖长度，数学表达更严谨。  

### 3. _ZZH（★★★★☆）  
- **亮点**：完全省去数组存储，实时处理输入。  
- **代码核心**：  
  ```cpp  
  if(x - before <= t) ans += x - before;  
  else ans += t;  
  before = x;  
  ```  
- **简评**：空间复杂度 `O(1)`，适合极端大数据场景。  

---

## 最优思路提炼  
- **关键公式**：总天数 = Σ(min(Δt, T)) + T（最后一段）  
- **思维角度**：将区间覆盖转换为相邻间隔的贪心累加，避免复杂重叠计算。  
- **优化点**：在线处理输入减少内存占用，`long long` 防溢出。  

---

## 同类型题推荐  
1. **P2285 [HNOI2004] 打鼹鼠**：时间序列中的动态规划，类似时间间隔处理。  
2. **P1514 引水入城**：区间覆盖问题，需合并有效区间。  
3. **P1886 滑动窗口**：滑动窗口中的极值问题，涉及区间统计。  

---

## 个人心得摘录  
- **CandyCandyFruit**：暴力循环导致 TLE，改为线性算法后 AC，强调算法优化的重要性。  
- **Stella_Yan**：初始代码误判最后一次处理，最终通过补加 `T` 修正，体现边界条件的重要性。  

---

## 可视化算法演示  
### 动画设计方案  
- **像素风格**：8-bit 风格，时间轴横向流动，每个时间点用色块表示区间覆盖。  
- **关键步骤高亮**：  
  - **当前间隔**：用绿色方块标记 `t[i]` 和 `t[i-1]` 的间距。  
  - **累加天数**：若间隔 `<T`，黄色方块填充实际天数；若 `≥T`，红色方块填充 `T` 天。  
- **音效设计**：  
  - **短间隔**：播放短促“滴”声。  
  - **长间隔**：播放低音“咚”声。  
  - **总天数更新**：每次累加时播放金币音效。  

### 交互功能  
- **步进控制**：按空格暂停/继续，方向键步进。  
- **速度调节**：滑块控制动画速度（0.5x~4x）。  
- **数据重载**：支持自定义输入测试数据，实时渲染结果。  

---

## 核心代码实现  
```cpp  
#include <iostream>  
using namespace std;  

int main() {  
    long long n, T, last, ans = 0;  
    cin >> n >> T >> last;  
    ans = T;  // 初始化最后一次的 T 天  
    for (int i = 1; i < n; i++) {  
        long long t;  
        cin >> t;  
        ans += min(t - last, T);  
        last = t;  
    }  
    cout << ans;  
    return 0;  
}  
```  
**说明**：在线读取每个时间点，实时计算与前一时间的间隔贡献。

---
处理用时：84.46秒
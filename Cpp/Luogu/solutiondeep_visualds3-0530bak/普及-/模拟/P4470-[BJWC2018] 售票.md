# 题目信息

# [BJWC2018] 售票

## 题目描述

C 市火车站最近出现了一种新式自动售票机。买票时，乘客要先在售票机上输入终点名称。一共有 $N$ 处目的地，随着乘客按顺序输入终点名称的每个字母，候选终点站数目会逐渐减少。

在自动售票机屏幕上，有一个 $4$ 行 $8$ 列的键盘，如下图所示。

![](https://cdn.luogu.com.cn/upload/pic/17861.png)

在乘客每输入一个字母后，键盘上只有有效字符是可选的（取决于还有哪些候选终点站），其余的字母会被字符 `*` 取代。

告诉你 $N$ 处目的地的名称，以及乘客已经输入的若干字符，请你输出键盘目前的状态。

## 说明/提示

**【样例解释】**

输入 `ZA` 以后，下一个字符可能是 `G`（终点站有可能是 `ZAGREB`），或 `D`（终点站有可能是 `ZADAR`），或 `B`（终点站有可能是 `ZABOK`）。

## 样例 #1

### 输入

```
4
ZAGREB
SISAK
ZADAR
ZABOK
ZA```

### 输出

```
****B*D*
*G******
********
********```

# AI分析结果



---

### 算法分类
**字符串处理与模拟**

---

### 题解思路与核心难点

#### 核心思路
1. **前缀匹配**：找出所有候选站点的前缀与输入字符串完全匹配的项。
2. **字符映射**：将匹配站点的下一个字符映射到键盘的对应位置。
3. **键盘更新**：根据候选字符更新键盘状态，保留有效字符，其他位置显示 `*`。

#### 解决难点
- **键盘布局映射**：正确将字母映射到键盘的4行8列布局。例如，字符 `A-E` 位于第一行的第4-8位，`F-M` 位于第二行等。
- **高效前缀匹配**：使用 `strncmp` 或 `substr` 快速比对前缀，避免逐个字符遍历的低效操作。

---

### 题解评分（≥4星）

1. **引领天下（5星）**
   - **亮点**：简洁高效，利用 `strncmp` 直接比对前缀，通过预计算字符位置实现快速映射。
   - **代码片段**：
     ```cpp
     if ('A'<=c && c<='E') k[c-'A'+3] = c;
     if ('F'<=c && c<='M') k[c-'A'+4] = c;
     ```

2. **孤_独（4星）**
   - **亮点**：使用 `substr` 和 `find` 实现前缀匹配，逻辑清晰易懂。
   - **代码片段**：
     ```cpp
     if (s == str[i].substr(0, len))
         flag[str[i][len]-'A'+4] = 1;
     ```

3. **Tomone（4星）**
   - **亮点**：通过预定义键盘布局数组，直接标记有效字符的位置，代码结构清晰。
   - **代码片段**：
     ```cpp
     if (a[i].substr(0, len) == temp)
         vis[i][j] = 1; // 标记有效字符
     ```

---

### 最优思路与技巧
- **前缀匹配优化**：使用 `strncmp` 或 `substr` 快速比对前缀，时间复杂度为 O(N*M)，其中 M 为输入字符串长度。
- **字符位置预计算**：根据键盘布局，通过字符 ASCII 码的偏移量直接计算其在数组中的索引，例如 `A-E` 对应索引 `c-'A'+3`。
- **键盘状态初始化**：预先初始化全 `*` 的键盘数组，仅更新有效字符，避免多次遍历。

---

### 相似题目推荐
1. **P1012 [NOIP1998 提高组] 拼数**（字符串排序与拼接）
2. **P1308 [NOIP2011 普及组] 统计单词数**（前缀匹配与位置记录）
3. **P1177 [模板]快速排序**（数据分块处理，类似键盘分区域）

---

### 可视化与算法演示
#### 动画设计
1. **键盘布局绘制**：用 4x8 网格表示键盘，初始全灰（`*`）。
2. **字符高亮**：当候选站点的下一个字符被处理时，对应网格变为绿色并显示字母。
3. **音效与反馈**：
   - **有效字符**：播放清脆的“滴”声。
   - **无匹配**：播放低沉的“错误”音效。

#### 复古像素风格
- **颜色方案**：8-bit 风格，使用绿、灰两色表示有效和无效字符。
- **Canvas 实现**：通过 `requestAnimationFrame` 动态更新网格颜色，模拟字符点亮效果。

---

### 核心代码实现
```cpp
#include <cstdio>
#include <cstring>
char k[] = "********\n********\n********\n********"; // 预初始化键盘

int main() {
    int n, l;
    char a[51][101], s[101];
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%s", a[i]);
    scanf("%s", s);
    l = strlen(s);
    for (int i = 0; i < n; i++) {
        if (strncmp(a[i], s, l) != 0) continue;
        char c = a[i][l];
        // 根据字符范围计算索引
        if (c >= 'A' && c <= 'E') k[c - 'A' + 3] = c;
        if (c >= 'F' && c <= 'M') k[c - 'A' + 4] = c;
        if (c >= 'N' && c <= 'U') k[c - 'A' + 5] = c;
        if (c >= 'V' && c <= 'Z') k[c - 'A' + 6] = c;
    }
    puts(k); // 直接输出包含换行的键盘状态
    return 0;
}
```

---

### 个人心得摘录
- **调试经验**：字符位置计算容易出错，需通过样例反复验证。
- **优化感悟**：预初始化键盘数组并仅修改有效位置，比动态生成更高效。

---
处理用时：267.91秒
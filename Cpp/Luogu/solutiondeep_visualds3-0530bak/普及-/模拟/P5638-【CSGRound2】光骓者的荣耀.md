# 题目信息

# 【CSGRound2】光骓者的荣耀

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/s6ozu5pj.png)

小 K 又在做白日梦了。他进入到他的幻想中，发现他打下了一片江山。

## 题目描述

小 K 打下的江山一共有 $n$ 个城市，城市 $i$ 和城市 $i+1$ 有一条双向高速公路连接，走这条路要耗费时间 $a_i$。

小 K 为了关心人民生活，决定定期进行走访。他每一次会从 $1$ 号城市到 $n$ 号城市并在经过的城市进行访问。其中终点必须为城市 $n$。

不仅如此，他还有一个传送器，传送半径为 $k$，也就是可以传送到 $i-k$ 和 $i+k$。如果目标城市编号小于 $1$ 则为 $1$，大于 $n$ 则为 $n$。

但是他的传送器电量不足，只能传送一次，况且由于一些原因，他想尽量快的完成访问，于是就想问交通部部长您最快的时间是多少。

注意：**他可以不访问所有的城市，使用传送器不耗费时间**。

## 说明/提示

### 样例解释 1：

样例 1,2 的图示均为以下图片：

![MZbuTK.png](https://s2.ax1x.com/2019/11/08/MZbuTK.png)

不使用传送器直接走，答案为 $6$，可以证明这个是最小值。

### 样例解释 2：

在 $3$ 处使用，传送到 $4$，答案为 $3$，可以证明这个是最小值。

### 数据范围：

对于所有数据，$a_i > 0$

![Kvrl34.jpg](https://s2.ax1x.com/2019/11/04/Kvrl34.jpg)

## 样例 #1

### 输入

```
4 0
1 2 3```

### 输出

```
6```

## 样例 #2

### 输入

```
4 1
1 2 3```

### 输出

```
3```

# AI分析结果



# 【算法分类】
**前缀和 / 滑动窗口**

---

# **题解思路与核心分析**

## **核心问题抽象**
寻找一条长度为 $k$ 的连续路段，使得跳过这段路后总时间最短。等价于：**求长度为 $k$ 的连续子数组的最大和**，总时间减去该最大值即为答案。

---

## **关键难点与解决方案**
1. **高效计算区间和**  
   通过前缀和数组 `sum[i] = a[1] + a[2] + ... + a[i]`，将区间和计算复杂度从 $O(k)$ 降至 $O(1)$。例如区间 $[i, i+k)$ 的和为 `sum[i+k] - sum[i]`。

2. **边界条件处理**  
   - 当 `i + k` 超过 $n$ 时需取到数组末尾。
   - 循环起始点应为 `i=0` 而非 `i=1`，避免漏掉从第一个城市开始传送的情况。

3. **空间优化（滑动窗口）**  
   维护一个长度为 $k$ 的窗口，每次移动窗口时减去前一个元素并加上后一个元素，无需存储整个前缀和数组，空间复杂度优化至 $O(1)$。

---

## **最优思路提炼**
- **前缀和法**  
  1. 计算前缀和数组 `sum`。
  2. 遍历所有可能的起点 $i$，计算区间 $[i, i+k)$ 的和 `sum[i+k] - sum[i]`。
  3. 记录最大值，总时间 `sum[n-1] - max_k_sum` 即为答案。

- **滑动窗口法**  
  1. 初始化窗口和为前 $k$ 个元素之和。
  2. 每次右移窗口，减去 `a[i]` 并加上 `a[i+k]`。
  3. 实时更新最大值。

---

# **题解评分 (≥4星)**

### 1. Mophie 的题解 (★★★★★)
- **亮点**  
  详细推导滑动窗口优化过程，代码简洁高效，时间复杂度 $O(n)$，空间 $O(1)$。
- **核心代码**  
  ```cpp
  for(int i=2;i<=n-k;i++) {
      now=now-a[i-1]+a[i+k-1];
      Max=max(Max,now);
  }
  ```

### 2. 沉冥Charming 的题解 (★★★★☆)
- **亮点**  
  强调前缀和边界处理（i=0 起始），避免漏解，代码可读性强。
- **关键片段**  
  ```cpp
  for (int i=0; i+k<n; i++) 
      cnt=max(cnt,sum[i+k]-sum[i]);
  ```

### 3. StudyingFather 的题解 (★★★★☆)
- **亮点**  
  直接使用前缀和，代码极简，处理了 $k \geq n$ 的特判。
- **核心逻辑**  
  ```cpp
  for(int i=k;i<n;i++)
      ans=max(ans,sum[i]-sum[i-k]);
  ```

---

# **可视化算法设计**

## **动画演示方案**
1. **数据结构展示**  
   - 城市链以水平条形图表示，每个条形高度对应 `a[i]` 的值。
   - 当前滑动窗口用红色框标记，并显示当前窗口和。

2. **步进操作**  
   - **初始状态**：窗口覆盖前 $k$ 个城市，显示初始和。
   - **窗口滑动**：每次右移一步，动态更新窗口区域和总和。
   - **最大值更新**：当当前窗口和超过历史最大值时，最大值区域高亮闪烁。

3. **复古像素风格**  
   - **颜色方案**：城市条形用绿色渐变，窗口框为红色，最大值显示为金色。
   - **音效**：窗口移动时播放 "blip" 音效，最大值更新时播放 "coin" 音效。

4. **交互控制**  
   - **速度调节**：滑块控制动画速度（0.5x~3x）。
   - **单步执行**：按钮允许手动控制每一步滑动。

---

# **同类型题目推荐**
1. **P1115 最大子段和**  
   基础最大连续子数组问题，可直接应用前缀和或滑动窗口。

2. **P1719 寻找峰值**  
   滑动窗口处理局部极值，类似窗口移动思想。

3. **P1638 逛画展**  
   双指针滑动窗口求满足条件的最小窗口。

---

# **个人心得摘录**
- **调试教训**：初始循环从 `i=1` 开始导致 WA，修正为 `i=0` 后 AC（沉冥Charming）。
- **优化顿悟**：滑动窗口将 $O(nk)$ 暴力优化至 $O(n)$（Mophie）。
- **易错点**：未开 `long long` 导致溢出（多个题解强调）。

---

# **核心代码实现**
```cpp
// 前缀和法 (StudyingFather)
#include <iostream>
using namespace std;
long long sum[1000005];

int main() {
    int n, k;
    cin >> n >> k;
    for (int i = 1; i < n; i++) {
        long long x;
        cin >> x;
        sum[i] = sum[i-1] + x;
    }
    long long max_k = 0;
    for (int i = k; i < n; i++) // 注意i为区间右端点
        max_k = max(max_k, sum[i] - sum[i - k]);
    cout << sum[n-1] - max_k << endl;
    return 0;
}
```

---

# **滑动窗口实现**
```cpp
// 滑动窗口法 (Mophie)
#include <iostream>
using namespace std;

int main() {
    long long n, k, total = 0, window = 0, max_window = 0;
    cin >> n >> k;
    long long a[1000001];
    for (int i = 0; i < n-1; i++) {
        cin >> a[i];
        total += a[i];
        if (i < k) window += a[i]; // 初始窗口
    }
    max_window = window;
    for (int i = k; i < n-1; i++) {
        window += a[i] - a[i - k]; // 滑动窗口
        max_window = max(max_window, window);
    }
    cout << total - max_window << endl;
}
```

---
处理用时：85.65秒
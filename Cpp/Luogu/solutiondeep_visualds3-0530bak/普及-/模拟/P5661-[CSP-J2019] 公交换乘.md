# 题目信息

# [CSP-J2019] 公交换乘

## 题目描述

著名旅游城市 B 市为了鼓励大家采用公共交通方式出行，推出了一种地铁换乘公交车的优惠方案：
1. 在搭乘一次地铁后可以获得一张优惠票，有效期为 45 分钟，在有效期内可以消耗这张优惠票，免费搭乘一次票价不超过地铁票价的公交车。在有效期内指开始乘公交车的时间与开始乘地铁的时间之差小于等于 45 分钟，即：
$t_{bus} - t_{subway} \leq 45$。
2. 搭乘地铁获得的优惠票可以累积，即可以连续搭乘若干次地铁后再连续使用优惠票搭乘公交车。
3. 搭乘公交车时，如果可以使用优惠票一定会使用优惠票；如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。

现在你得到了小轩最近的公共交通出行记录，你能帮他算算他的花费吗?

## 说明/提示

**样例 1 说明**

第一条记录，在第 3 分钟花费 10 元乘坐地铁。

第二条记录，在第 46 分钟乘坐公交车，可以使用第一条记录中乘坐地铁获得的优惠票，因此没有花费。

第三条记录，在第 50 分钟花费 12 元乘坐地铁。

第四条记录，在第 96 分钟乘坐公交车，由于距离第三条记录中乘坐地铁已超过 45 分钟，所以优惠票已失效，花费 3 元乘坐公交车。

第五条记录，在第 110 分钟花费 5 元乘坐地铁。

第六条记录，在第 135 分钟乘坐公交车，由于此时手中只有第五条记录中乘坐地铁获得的优惠票有效，而本次公交车的票价为 6 元，高于第五条记录中地铁的票价 5 元，所以不能使用优惠票，花费 6 元乘坐公交车。

总共花费 36 元。 

**样例 2 说明**

第一条记录，在第 1 分钟花费 5 元乘坐地铁。

第二条记录，在第 16 分钟花费 20 元乘坐地铁。

第三条记录，在第 23 分钟花费 7 元乘坐地铁。

第四条记录，在第 31 分钟乘坐公交车，此时只有第二条记录中乘坐的地铁票价高于本次公交车票价，所以使用第二条记录中乘坐地铁获得的优惠票。

第五条记录，在第 38 分钟乘坐公交车，此时第一条和第三条记录中乘坐地铁获得的优惠票都可以使用，使用获得最早的优惠票，即第一条记录中乘坐地铁获得的优惠票。

第六条记录，在第 68 分钟乘坐公交车，使用第三条记录中乘坐地铁获得的优惠票。

总共花费 32 元。 


**数据规模与约定**

对于 $30\%$ 的数据，$n \leq 1000$，$t_i \leq 10^6$。

另有 $15\%$ 的数据，$t_i \leq 10^7$，所有 $price_i$ 相等。

另有 $15\%$ 的数据，$t_i \leq 10^9$，所有 $price_i$ 相等。

对于 $100\%$ 的数据，$n \leq 10^5$，$t_i \leq 10^9$，$1 \leq price_i \leq 1000$。

## 样例 #1

### 输入

```
6
0 10 3
1 5 46
0 12 50
1 3 96
0 5 110
1 6 135```

### 输出

```
36```

## 样例 #2

### 输入

```
6
0 5 1
0 20 16
0 7 23
1 18 31
1 4 38
1 7 68 ```

### 输出

```
32```

# AI分析结果



### 算法分类
队列应用 / 模拟

---

### 综合分析与结论
**核心难点**：有效管理45分钟内生成的地铁优惠票，优先使用最早的有效票。  
**核心思路**：维护一个队列存储未过期的优惠票，每次处理公交时先剔除过期票，再遍历队列查找可用票。  
**优化关键**：通过指针或队列操作保证队列中仅保留可能有效的票，将单次操作复杂度降至O(45)。

**可视化设计要点**：  
1. **动画流程**：  
   - 地铁入队时，右侧添加新票（时间+45）  
   - 公交处理时，队列头部弹出过期票（红色高亮）  
   - 遍历有效票时，绿色高亮当前检测的票，找到可用票后标记为已用（灰色）  
2. **复古像素风格**：  
   - 使用16色调色板，队列用蓝色方块表示，过期票渐变红色  
   - 音效：入队时"滴"声，找到优惠票时"叮"声，超时弹出时"咔嚓"声  
3. **交互控制**：  
   - 时间轴滑动条控制执行进度  
   - 单步执行按钮观察每一步队列变化  

---

### 题解评分（≥4星）
1. **泥土笨笨（5星）**  
   - 队列+双指针优化，时间复杂度O(45n)  
   - 代码结构清晰，维护`head`和`tail`指针高效剔除过期票  
   - 关键变量`used`标记已用票，避免重复使用  

2. **__gcd（4星）**  
   - 桶排序优化，按票价分桶存储时间  
   - 查找时从当前票价向上遍历，时间戳维护优化  
   - 针对price≤1000的特性实现创新  

3. **Zxx200611（4星）**  
   - 二分查找最早有效票，时间复杂度O(n log n)  
   - 利用时间有序性优化搜索范围  
   - 实现思路独特，适合学习二分思想  

---

### 最优思路提炼
**双指针队列法**：  
1. 维护队列存储未过期优惠票（`head`指向最早有效票）  
2. 地铁入队时直接追加到队尾  
3. 公交处理时：  
   - 先移动`head`指针剔除所有过期票  
   - 遍历`head`到`tail`找第一个可用票  
4. 时间复杂度O(n)（每个票最多入队、出队各一次）

```cpp
// 关键代码片段（泥土笨笨题解核心）
struct Ticket { int price, time, used; } q[MAXN];
int head = 0, tail = 0;

void process_bus(int time, int price) {
    // 剔除过期票
    while (head < tail && q[head].time < time) head++;
    
    bool found = false;
    for (int j = head; j < tail; ++j) {
        if (q[j].price >= price && !q[j].used) {
            q[j].used = 1; // 标记为已用
            found = true;
            break;
        }
    }
    if (!found) cost += price;
}
```

---

### 同类题目推荐
1. **P1886 滑动窗口**（单调队列维护窗口极值）  
2. **P1440 求m区间内的最小值**（队列预处理区间最值）  
3. **P1638 逛画展**（双指针维护区间特性）

---

### 可视化算法演示
**核心流程动画**：  
1. 时间轴从左向右推进，地铁/公交事件依次触发  
2. 队列区域动态显示当前有效优惠票：  
   - 新地铁票从右侧进入，显示`时间+45`  
   - 过期票向左淡出并变红  
3. 公交处理时：  
   - 黄色扫描线从左到右检测队列  
   - 找到可用票时闪绿光，未找到则显示现金支付  

**8位音效设计**：  
- `0x20`：地铁入队（低音"嘟"）  
- `0x30`：找到优惠票（中音"叮"）  
- `0x40`：现金支付（高音"咔"）

---

### 个人心得摘录
> "出题人不会让暴力过，但45分钟限制暗示最多同时存在45张有效票，这是优化的关键突破口" —— 泥土笨笨  
> "优先队列看似合理，但临时数组复制操作反而增加常数，手写队列更高效" —— WsW_  
> "二分法写起来很优雅，但实际跑不过O(n)的双指针队列" —— Zxx200611

---

### 代码实现（队列法完整版）
```cpp
#include <iostream>
using namespace std;

const int MAXN = 1e5+5;
struct Ticket { int price, time, used; };

Ticket q[MAXN];
int head = 0, tail = 0, total_cost = 0;

int main() {
    int n;
    cin >> n;
    
    while (n--) {
        int op, price, t;
        cin >> op >> price >> t;
        
        if (op == 0) { // 地铁
            total_cost += price;
            q[tail++] = {price, t + 45, 0};
        } else { // 公交
            // 剔除过期票
            while (head < tail && q[head].time < t) head++;
            
            bool found = false;
            for (int i = head; i < tail; ++i) {
                if (!q[i].used && q[i].price >= price) {
                    q[i].used = 1;
                    found = true;
                    break;
                }
            }
            if (!found) total_cost += price;
        }
    }
    
    cout << total_cost << endl;
    return 0;
}
```

---
处理用时：75.89秒
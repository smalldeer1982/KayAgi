# 题目信息

# [EER1] 苏联人

## 题目背景

~~题目名称是吸引你点进来的。~~

这是一道正常的题，和苏联没有任何关系。

## 题目描述

你在打 EE Round 1，发现第一题非常无聊。于是你不打了，去下国际象棋了。

结果你发现，由于神秘力量的影响，你的棋子只剩下若干黑色的战车，若干黑色的主教和一只白色的国王了。

由于你很无聊，所以你把一些黑色棋子放在了 $8\times 8$ 的棋盘上。

由于你很无聊，所以你想知道，国王放在哪些格子是安全的。换句话说，有哪些格子不会被战车和主教攻击到。当然，**国王不能放在已经有棋子的地方**。

为了防止你无聊透顶而不知道国际象棋的规则，这里给出以下提示（如果你知道规则那么可以跳过）：

国际象棋中，战车可以横向、竖向移动，且格数不受限制。但**不能越过其他棋子**。

![](https://cdn.luogu.com.cn/upload/image_hosting/5symt5td.png)

如图，黄色的格子为战车能走到（攻击到）的格子。

国际象棋中，主教可以斜向移动，且格数不受限制。但**不能越过其他棋子**。

![](https://cdn.luogu.com.cn/upload/image_hosting/skmw1njm.png)

如图，黄色的格子为主教能走到（攻击到）的格子。

简单来说，如果当前位置到目标位置的**直线**上存在其他棋子，则可以称为“越过了其他棋子”。

如果目标位置是对方的棋子，那么移动到目标位置后，对方的棋子会被吃掉。

更进一步地，你要找的所有位置，必须满足没有黑色棋子能一步走到。

---

如果你还是没有读懂，可以结合样例进行理解。

## 说明/提示

对于 $100\%$ 的数据，保证只会出现 `.`，`R`，`B` 三种字符。

本题共有 $4$ 个子任务，每个子任务的限制如下：

子任务 $1$（$10$ 分）：保证只会出现 `.`。

子任务 $2$（$20$ 分）：保证只会出现一个 `R` 或一个 `B`（不同时出现）。

子任务 $3$（$30$ 分）：保证只有一个 `.`。

子任务 $4$（$40$ 分）：没有特殊限制。

## 样例 #1

### 输入

```
........
........
........
..B..R..
........
........
........
........
```

### 输出

```
11111011
01110011
10101011
11000000
10101011
01110011
11111011
11111001
```

# AI分析结果



## 【算法分类】
模拟

---

## 【综合分析与结论】
题目要求找出国王在棋盘上的安全位置，即不被战车(R)和主教(B)攻击的格子。核心思路是模拟每个棋子的攻击路径，标记被攻击的格子，最终输出未被标记的位置。

**核心难点**：
1. **攻击路径的模拟**：需沿战车的直线（上下左右）和主教的斜线方向扩展，遇到障碍物时停止。
2. **边界处理**：确保遍历时不超过棋盘边界。
3. **初始位置处理**：棋子的位置本身不可放置国王。

**题解共性**：遍历每个棋子，沿其攻击方向逐个格子检查，标记路径上的格子，遇到非空位则停止。最终取反输出标记数组。

---

## 【题解清单（评分≥4星）】
1. **幻之陨梦（5星）**  
   - **亮点**：代码简洁高效，直接处理四个方向，逻辑清晰，可读性强。  
   - **关键代码**：使用四重循环处理战车和主教的攻击方向，标记路径。

2. **MZY666（4星）**  
   - **亮点**：详细注释，分开处理每个方向，变量命名直观。  
   - **关键代码**：通过独立循环处理每个方向，便于调试。

3. **SamariumPhosphide（4星）**  
   - **亮点**：模块化设计，将战车和主教的处理封装为函数，结构清晰。  
   - **关键代码**：使用双重变量控制斜向移动，逻辑严谨。

---

## 【最优思路与技巧提炼】
1. **方向遍历**：战车和主教的攻击方向分别用四个固定方向处理，通过循环变量控制移动。
2. **障碍检测**：在扩展路径时，遇到非`.`的格子立即终止循环。
3. **标记数组优化**：初始化为全1（安全），攻击路径标记为0，最终输出时取反。

**示例代码（幻之陨梦的核心逻辑）**：
```cpp
for (int i=0; i<8; i++) {
    for (int j=0; j<8; j++) {
        if (ch[i][j] == 'R') {
            // 处理上下左右四个方向
            for (int k=i-1; k>=0 && ch[k][j]=='.'; k--) ans[k][j] = 1;
            for (int k=i+1; k<8 && ch[k][j]=='.'; k++) ans[k][j] = 1;
            // ...类似处理左右方向
        } else if (ch[i][j] == 'B') {
            // 处理四个斜方向
            for (int k=i-1, l=j-1; k>=0 && l>=0 && ch[k][l]=='.'; k--, l--) ans[k][l] = 1;
            // ...类似处理其他斜方向
        }
    }
}
```

---

## 【可视化设计】
**动画方案**：
1. **网格绘制**：在Canvas中绘制8x8棋盘，格子用像素风格填充。
2. **攻击路径演示**：
   - **战车路径**：用蓝色高亮，逐步扩展上下左右方向，遇到障碍时显示红色闪烁。
   - **主教路径**：用红色高亮斜线扩展，遇到障碍时播放“阻挡”音效。
3. **交互控制**：支持暂停/继续、调整动画速度，单步执行观察路径扩展。

**复古风格**：
- **8位音效**：路径扩展时播放“哔”声，阻挡时播放低沉音效。
- **像素颜色**：安全格（1）用绿色，被攻击格（0）用黄色，棋子用黑色。

---

## 【相似题目推荐】
1. **P1219 八皇后**：处理多个棋子的攻击范围。
2. **P2325 扫雷**：模拟格子状态标记。
3. **P1032 字变换**：路径扩展与状态标记。

---

## **个人心得摘录**
- **Steven__Chen**：调试时发现边界条件错误，通过极端测试用例（如棋盘边缘的棋子）修正。
- **Gokix**：强调递归函数中起始位置还原的重要性，避免后续遍历被干扰。

---

**可视化演示核心代码（简略）**：
```javascript
// 绘制攻击路径（以战车为例）
function drawRookAttack(x, y) {
    for (let dir of [[-1,0], [1,0], [0,-1], [0,1]]) {
        let dx = x + dir[0], dy = y + dir[1];
        while (inBounds(dx, dy) && board[dx][dy] === '.') {
            highlightGrid(dx, dy, 'blue'); // 高亮被攻击格子
            dx += dir[0]; dy += dir[1];
        }
    }
}
```

---
处理用时：101.99秒
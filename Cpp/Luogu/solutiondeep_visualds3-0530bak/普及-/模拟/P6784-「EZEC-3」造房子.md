# 题目信息

# 「EZEC-3」造房子

## 题目背景

pigstd 要去造房子了。

## 题目描述

pigstd 有 $a$ 个 A 材料和 $b$ 个 B 材料，造**第** $i$ 层楼需要 $i$ 个 A 材料与 $i$ 个 B 材料。

但是 pigstd 觉得房子不够高，于是他拿出了 $c$ 块钱，每块钱都可以用来买 $1$ 个 A 材料或者 $1$ 个 B 材料。

现在 pigstd 想知道，他最多能建多少层楼的房子。

## 说明/提示

**【样例 1 说明】**

pigstd 买 $2$ 个 A 材料和 $1$ 个 B 材料后就有 $3$ 个 A 材料和 $3$ 个 B 材料，最多可以建 $2$ 层楼的房子。

（花费 $1+2$ 个 A 材料和 $1+2$ 个 B 材料）

**【样例 2 说明】**

pigstd 买 $3$ 个 A 材料后就有 $4$ 个 A 材料和 $5$ 个 B 材料，最多可以建 $2$ 层楼的房子。

（花费 $1+2$ 个 A 材料和 $1+2$ 个 B 材料）

**【数据规模与约定】**

对于 $100\%$ 的数据，$0 \le a,b,c \le 10^{12}$。

| 数据点编号 | 满足的条件 |
| :----------: | :----------: |
|$1-4,22$| $c = 0$ |
|$5-8,21$| $a,b,c \le 10^{3}$ |
|$9-12$| $a,b,c \le 10^{6}$ |
|$13-20$| $a,b,c \le 10^{12}$ | 

## 样例 #1

### 输入

```
1 2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
1 5 3```

### 输出

```
2```

# AI分析结果



**唯一算法分类**: 贪心算法

---

### 综合分析与结论

**核心思路**：  
通过贪心策略将 c 分配给 a/b 使两者尽可能接近，再通过数学公式计算最大楼层数。核心步骤为：  
1. 比较 a 和 b，优先补足较小值使其等于较大值  
2. 剩余资源均分给 a 和 b  
3. 计算满足 Σi ≤ min(a,b) 的最大 n 值  

**解决难点**：  
- 正确分配 c 的两种场景（能否补平差距）  
- 高效计算最大 n 的数学推导（避免循环超时）  

**可视化设计**：  
- **动画流程**：  
  1. 展示初始 a/b 的差距（高亮较小值）  
  2. 动态演示 c 的分配过程（红色箭头流动）  
  3. 显示最终均分后的 a/b 值（绿色高亮）  
  4. 用公式计算楼层数时，动态显示平方根和取整过程  
- **复古像素风格**：  
  - 材料以不同颜色方块表示（A红/B蓝）  
  - 资源分配过程用 8bit 音效增强反馈  
  - 最终楼层数用像素字体弹出，配胜利音效  

---

### 题解清单（≥4星）

1. **云浅知处（★★★★★）**  
   - 亮点：数学推导完整，代码简洁高效  
   - 核心公式：`floor((sqrt(8*s +1)-1)/2)`  
   - 处理了所有可能的分配情况  

2. **Unordered_OIer（★★★★☆）**  
   - 亮点：给出三种解法对比，数学推导清晰  
   - 特别说明：强调贪心策略与数据范围的关系  

3. **Rubidium_Chloride（★★★★☆）**  
   - 亮点：详细分析分配策略，附二分法实现  
   - 特色：博客链接包含扩展思考  

---

### 最优思路提炼

**关键技巧**：  
1. **资源均分定理**：当 a+c ≥ b 时，最大材料数 = (a+b+c)//2  
2. **一元二次方程解法**：直接公式计算楼层数，避免循环  
3. **整数处理技巧**：使用 `floor(sqrt(8*s+1))` 避免浮点误差  

**代码实现片段**：  
```cpp
// 云浅知处代码的核心逻辑
if (m > c) { // 无法补平差距
    LL ans = (LL)(floor(sqrt(8*(y + c) +1)) -1)/2;
} else {      // 补平后均分剩余资源
    c -= m;
    LL ans = (LL)(floor(sqrt(8*(x + c/2) +1)) -1)/2;
}
```

---

### 同类型题目推荐

1. **P1873 砍树**（二分答案）  
2. **P2440 木材加工**（资源分配与最大最小值）  
3. **P1181 数列分段**（贪心划分连续区间）  

---

### 可视化算法演示

**动画脚本**：  
```javascript
// 伪代码示例（Canvas绘制）
function drawAllocation(a, b, c) {
    // 初始状态：红色A、蓝色B方块
    drawRect(0, 0, a, 'red'); 
    drawRect(0, 50, b, 'blue');

    if (a < b) {
        // 动画：红色方块增长至与蓝色对齐
        animateArrow(c1, () => { a += Math.min(c, b-a); });
        c -= (b - a);
    }
    // 剩余c均分
    animateSplit(c, () => {
        a += c/2; 
        b += c/2;
    });
    // 公式计算n
    let s = Math.min(a, b);
    let n = Math.floor((Math.sqrt(8*s +1)-1)/2);
    // 像素字体弹出效果
    pixelText(n, 100, 100); 
}
```

**像素音效**：  
- 资源移动时：`beep(440, 50)`  
- 公式计算时：`beep(880, 100)`  
- 结果显示时：`playVictorySound()`  

---

**结语**：通过贪心策略与数学推导，该问题可在 O(1) 时间内高效解决，展现了如何将实际问题转化为数学模型的能力。

---
处理用时：74.02秒
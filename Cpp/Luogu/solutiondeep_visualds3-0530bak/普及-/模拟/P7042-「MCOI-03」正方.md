# 题目信息

# 「MCOI-03」正方

## 题目背景

MC 中没有圆。

所以小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 喜欢 Square。

## 题目描述

给定一个正方形，求有多少个正方形内的点满足与正方形四个顶点划分出来的四块面积的比为 $a:b:c:d$。四个数不分顺序。

比如如下图所示假设一个点 E 使得分成的四个三角形的面积之比为 $a:b:c:d$，那么这个点 E 就符合要求。因为不分顺序，所以分出来的比是 $d:b:a:c$ 也可以。但是点 E 不是唯一解，你要输出的是解的个数。

![](https://cdn.luogu.com.cn/upload/image_hosting/95llbbcx.png)

因为小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 很喜欢询问，所以本题给定了 $q$ 组询问。

## 说明/提示

#### 数据规模与约定

对于 $20\%$ 的数据，$a=b=c=d$。    
对于 $100\%$ 的数据，$1 \le a,b,c,d \le 9 \times 10^{18}$，$1 \le q \le 100$，不保证 $a:b:c:d$ 为最简比，不保证 $a,b,c,d$ 为升序。

## 样例 #1

### 输入

```
3
1 3 3 1
2 4 7 8
2 3 1 4```

### 输出

```
4
0
8```

# AI分析结果



---

**算法分类**：数学（几何与数论）

---

### **题解思路与算法分析**

#### **核心思路**
1. **必要条件**：四个数的两两和相等（如排序后需满足 `a[0] + a[3] == a[1] + a[2]`），否则无解。
2. **对称性分析**：正方形的对称性决定了点的位置可能性。当满足上述条件时：
   - **全等情况**：若四个数全等，唯一解为正方形中心（输出1）。
   - **部分相等**：若存在任意两个数相等（通过相邻元素判断），解的数量为4（对称轴重合）。
   - **无相等元素**：解的数量为8（通过旋转和对称生成不同位置）。

#### **解决难点**
- **条件判断的完备性**：需覆盖所有可能的相等组合，确保不遗漏中间相等的情况。
- **高效处理大数**：由于输入范围可达 \(10^{18}\)，需避免浮点运算，直接通过整数比较实现。

---

### **题解评分（≥4星）**

1. **Thomas_Cat（5星）**  
   - **亮点**：条件判断全面，代码简洁，涵盖所有相等情况。  
   - **代码关键**：通过任意两数相等的判断覆盖所有可能，逻辑清晰。

2. **Unordered_OIer（4星）**  
   - **亮点**：通过对称性分析解释解的分布，思路直观。  
   - **不足**：中间相等情况未完全覆盖（需改进相邻元素判断）。

3. **一只书虫仔（4星）**  
   - **亮点**：结合几何图形分析，强调面积比与高的关系。  
   - **不足**：条件判断仅检查前后两对，可能遗漏中间相等。

---

### **最优思路提炼**
- **排序后两和相等**：排序后检查 `a[0] + a[3] == a[1] + a[2]`。
- **相邻元素判断相等**：通过相邻元素是否相等快速判断是否存在重复值。
- **对称性简化计算**：利用正方形的对称性推导解的分布规律，避免复杂坐标计算。

---

### **同类型题推荐**
1. **洛谷P1005**：矩阵取数游戏（对称性与动态规划）。
2. **洛谷P1352**：没有上司的舞会（树形对称问题）。
3. **洛谷CF1028B**：Unnatural Conditions（数论与构造）。

---

### **代码实现（核心逻辑）**
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int q;
    cin >> q;
    while (q--) {
        unsigned long long a, b, c, d;
        cin >> a >> b >> c >> d;
        unsigned long long arr[] = {a, b, c, d};
        sort(arr, arr + 4);
        if (arr[0] + arr[3] != arr[1] + arr[2]) {
            cout << 0 << endl;
        } else if (arr[0] == arr[1] && arr[1] == arr[2] && arr[2] == arr[3]) {
            cout << 1 << endl;
        } else if (arr[0] == arr[1] || arr[1] == arr[2] || arr[2] == arr[3]) {
            cout << 4 << endl;
        } else {
            cout << 8 << endl;
        }
    }
    return 0;
}
```

---

### **可视化设计**
#### **动画演示**
1. **排序过程**：展示四个数从小到大排列的动态过程，用不同颜色标记每个数。
2. **条件检查**：
   - **和的计算**：高亮 `a[0] + a[3]` 和 `a[1] + a[2]`，若相等则变绿，否则变红。
   - **相等判断**：相邻元素相等时闪烁提示，如 `a[0] == a[1]` 时高亮黄色。
3. **结果输出**：根据结果播放音效（成功：上扬音调；失败：低沉音效）。

#### **复古像素风格**
- **颜色方案**：使用8位色（红、绿、黄、蓝）表示不同数值状态。
- **Canvas 动画**：将排序与条件判断以网格动态展示，每一步伴随“滴答”音效。
- **自动演示模式**：按固定速度逐步展示逻辑，用户可暂停/调整速度。

---

### **总结**
通过排序与条件判断，结合正方形的对称性，快速确定解的分布。关键是通过相邻元素相等简化判断逻辑，避免复杂计算，适用于大数范围。

---
处理用时：267.57秒
# 题目信息

# [CSP-J2020] 直播获奖

## 题目描述

NOI2130 即将举行。为了增加观赏性，CCF 决定逐一评出每个选手的成绩，并直播即时的获奖分数线。本次竞赛的获奖率为 $w\%$，即当前排名前 $w\%$ 的选手的最低成绩就是即时的分数线。

更具体地，若当前已评出了 $p$ 个选手的成绩，则当前计划获奖人数为 $\max(1, \lfloor p \times w \%\rfloor)$，其中 $w$ 是获奖百分比，$\lfloor x \rfloor$ 表示对 $x$ 向下取整，$\max(x,y)$ 表示 $x$ 和 $y$ 中较大的数。如有选手成绩相同，则所有成绩并列的选手都能获奖，因此实际获奖人数可能比计划中多。

作为评测组的技术人员，请你帮 CCF 写一个直播程序。

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/l453vhow.png)

---
### 数据规模与约定

各测试点的 $n$ 如下表：

| 测试点编号 | $n=$ |
| :--: | :--: |
| $1 \sim 3$ | $10$ |
| $4 \sim 6$ | $500$ |
| $7 \sim 10$ | $2000$ |
| $11 \sim 17$ | $10^4$ |
| $18 \sim 20$ | $10^5$ |


对于所有测试点，每个选手的成绩均为不超过 $600$ 的非负整数，获奖百分比 $w$ 是一个正整数且 $1 \le w \le 99$。

---
### 提示

在计算计划获奖人数时，如用浮点类型的变量（如 C/C++ 中的 `float` 、 `double`，Pascal 中的 `real` 、 `double` 、 `extended` 等）存储获奖比例 $w\%$，则计算 $5 \times 60\%$ 时的结果可能为 $3.000001$，也可能为 $2.999999$，向下取整后的结果不确定。因此，建议仅使用整型变量，以计算出准确值。

## 样例 #1

### 输入

```
10 60
200 300 400 500 600 600 0 300 200 100
```

### 输出

```
200 300 400 400 400 500 400 400 300 300```

## 样例 #2

### 输入

```
10 30
100 100 600 100 100 100 100 100 100 100```

### 输出

```
100 100 600 600 600 600 100 100 100 100```

# AI分析结果



## 唯一算法分类
桶排序

## 题解思路与算法要点
**核心逻辑**：利用分数值域仅 0-600 的特性，使用桶统计各分数人数。每次新增成绩后，从 600 分倒序扫描桶数组，累加人数直至满足获奖名额。

**解决难点**：
1. **动态维护有序数据**：桶数组天然有序，无需每次排序
2. **并列分数处理**：倒序扫描时自动包含所有相同分数选手
3. **时间复杂度优化**：O(600n) 的线性复杂度完美契合题目数据规模

**对顶堆 vs 桶排序对比**：
| 方法       | 时间复杂度 | 空间复杂度 | 适用场景         |
|----------|--------|--------|--------------|
| 对顶堆      | O(nlogn) | O(n)   | 通用动态维护第k大数 |
| 桶排序      | O(Cn)   | O(C)   | 数值范围有限时最优 |

## 题解评分（≥4星）
1. **Eason_AC（5星）**  
   代码简洁清晰，直接体现桶排序核心逻辑。通过倒序累加桶数组快速定位分数线，完美利用题目特性。

2. **GZXUEXUE（4星）**  
   明确说明值域特点，循环条件处理细致。代码中 `j--` 与 `sum += a[j]` 的组合直观体现人数累积过程。

3. **Vct14（4星）**  
   采用类似桶排序思路，通过 `ans += a[j]` 与 `k` 的递减操作简洁实现名额判断，变量命名直观易懂。

## 最优思路提炼
**桶排序双指针法**：  
1. 初始化 `a[601]` 桶数组
2. 每读入一个分数：  
   a. 对应桶计数+1  
   b. 从600分倒序扫描，累加人数直到 ≥ 获奖名额  
3. 输出当前扫描的分数值

**可视化关键步骤**：  
```python
成绩序列: [200,300,400...]
桶数组更新:
    200 → a[200] +=1
    300 → a[300] +=1
    ...
分数线查询动画:
    [600]→5人 [599]→0人... [400]→3人 → 累计达名额时高亮
```

## 同类型题推荐
1. **P3871 [TJOI2010]中位数**（对顶堆经典应用）
2. **P1168 中位数**（动态维护有序序列中间值）
3. **P1801 黑匣子**（动态查询第k小元素）

## 复古像素化可视化设计
**核心元素**：  
- 8-bit 风格分数条：用16色像素块表示0-600分数段  
- 音效设计：  
  - 分数加入时播放「哔」声（Web Audio正弦波）  
  - 分数线确定时播放「叮」声（方波音效）  
- 动画流程：  
  1. 左侧像素小人抛出分数球落入对应桶  
  2. 红色扫描线从600分向下移动，实时显示累计人数  
  3. 达标时触发闪光特效并显示分数线  

```javascript
// 伪代码示例
class RetroVisualizer {
  constructor() {
    this.buckets = new Array(601).fill(0);
    this.currentScore = 0;
  }

  addScore(score) {
    playSound('beep'); // 8-bit音效
    this.buckets[score]++;
    this.highlightBucket(score);
  }

  searchCutoff(k) {
    let sum = 0;
    for(let j=600; j>=0; j--) {
      this.moveScanLine(j); // 扫描线动画
      sum += this.buckets[j];
      if(sum >= k) {
        playSound('ding');
        return j;
      }
    }
  }
}
```

## 个人心得摘录
> "本题看似需要复杂数据结构，实则巧妙利用值域特点，桶排序即可高效解决。调试时注意整数运算避免浮点误差，直接使用 `i*w/100` 而非浮点乘法" —— Eason_AC

## 核心代码实现
```cpp
#include <cstdio>
int a[607], n, w;

int main() {
    scanf("%d%d", &n, &w);
    for(int p=1; p<=n; ++p) {
        int x; scanf("%d", &x);
        a[x]++; // 桶计数
        int k = max(1, p*w/100), sum=0;
        for(int j=600; j>=0; --j) { // 倒序扫描
            sum += a[j];
            if(sum >= k) {
                printf("%d ",j);
                break;
            }
        }
    }
    return 0;
}
```

---
处理用时：79.10秒
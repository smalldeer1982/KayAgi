# 题目信息

# 探索未知

## 题目背景

下发文件：

<https://luogu-ipic.oss-cn-shanghai.aliyuncs.com/watujir2-jdi92.zip>

## 题目描述

2102 年，人类已经建立了从地球到室女座 $\alpha $ 星的星际通道。通道绵延数百光年。

而在通道上有许多路牌。第 $i$ 个路牌上写有一个分数 $\dfrac{a_i}{b_i}$ 和一个分数运算符 $+$ 或 $-$。

一开始，你的手上拿着一个数字 $0$。你沿着通道向后走。每走到一个路牌，**会用手上的数和路牌上的分数，用路牌上的运算符号进行计算，并把得到的新数拿在手中（丢弃掉手中原来的数）**。值得注意的是，如果你手中计算得到的数不是整数，则会保留既约分数的形式；否则直接保留整数形式。

现在你想知道，当你走到通道的末端时，手中拿着的数是多少？

## 说明/提示

对于 $20\%$ 的数据，运算符只存在加法。

另有 $20\%$ 的数据，运算法只存在减法。

对于 $100\%$ 的数据，保证 $1\leq n\leq 10^3$，$0\leq a \leq 1000$，$0 < b \leq 1000$，保证答案以及过程中全部数值(整数部分/分子/分母)不超过 $2\times 10^9$。


## 样例 #1

### 输入

```
3
3 5 1
4 7 2
7 3 1```

### 输出

```
248/105```

## 样例 #2

### 输入

```
4
6 7 1
8 3 2
9 14 2
5 17 1```

### 输出

```
-1541/714```

## 样例 #3

### 输入

```
3
7 4 1
3 8 2
3 8 2
```

### 输出

```
1```

# AI分析结果



### 算法分类
无算法分类（核心为分数运算模拟）

---

### 题解思路与解决难点分析
#### 核心逻辑
所有题解均采用分数运算模拟思路：
1. **通分计算**：每次将当前分数与新分数通分，加减分子
2. **约分处理**：通过最大公约数（GCD）化简分子分母
3. **符号处理**：确保分母始终为正，符号保留在分子
4. **输出优化**：若分母为1则输出整数

#### 关键难点对比
1. **通分方式**：
   - **分母乘积法**（scp020、Tis员工）：直接使用分母乘积作为新分母，简单但可能导致数值较大（题目保证不会溢出）
   - **最小公倍数法**（sunkuangzheng、bloodstalk）：计算LCM减少分母大小，但需额外GCD运算
2. **约分时机**：
   - **每次操作后立即约分**（大部分题解）：防止中间结果溢出
   - **最后统一约分**（部分题解）：减少计算次数但存在溢出风险
3. **符号处理**：
   - **动态调整**（scp020）：每次运算后检查分子分母符号
   - **最终统一调整**（Tis员工）：最后将分母强制转为正

---

### 题解评分（≥4星）
1. **scp020（★★★★☆）**
   - 亮点：代码简洁高效，动态处理符号，赞数最高
   - 代码：[见原题解]
2. **bloodstalk（★★★★☆）**
   - 亮点：结构体封装分数运算，支持加减运算符重载
   - 代码：[见原题解]
3. **sunkuangzheng（★★★★☆）**
   - 亮点：LCM优化分母大小，详细数学推导说明
   - 代码：[见原题解]

---

### 最优思路与技巧提炼
1. **立即约分**：每次操作后立即用GCD化简，防止数值爆炸
2. **符号分离**：始终将分母保持为正，符号仅保留在分子
3. **溢出防御**：使用`long long`存储中间结果
4. **通分优化**：
   ```cpp
   // 分母乘积法通分
   new_分子 = 分子1 * 分母2 ± 分子2 * 分母1;
   new_分母 = 分母1 * 分母2;
   ```
5. **输出特判**：
   ```cpp
   if (分母 == 1) cout << 分子; // 整数输出
   else if (分子 == 0) cout << 0; // 零特判
   ```

---

### 同类型题与算法套路
- **通用模板**：分数四则运算模拟
- **相似题目**：
  1. [P1022 计算器的改良](https://www.luogu.com.cn/problem/P1022)（分数方程）
  2. [P5179 Fraction](https://www.luogu.com.cn/problem/P5179)（分数化简）
  3. [P1062 数列](https://www.luogu.com.cn/problem/P1062)（分数表示递推）

---

### 个人心得摘录
> "结果出来后只有80分，发现分母为负数但分子为正数时，负号要放到分子上" —— Tis员工  
> **总结**：符号处理需严格测试，建议在每次约分后强制分母为正

---

### 可视化与算法演示
#### 动画设计（复古像素风格）
1. **核心流程**：
   - **步骤1**：显示当前分数（如`3/5`）和新输入的分数（如`4/7`）
   - **步骤2**：高亮分母部分，展示通分计算（LCM或乘积）
   - **步骤3**：动态显示分子加减过程（`3*7 + 4*5 = 41`）
   - **步骤4**：用GCD化简分数，红色闪烁显示约分过程

2. **交互设计**：
   - **音效**：
     - 通分时播放"blip"音效
     - 约分成功时播放"ding"音效
   - **像素动画**：
     - 分子分母以8位数字显示在网格中
     - 运算符（+/-）用闪烁箭头指示

3. **自动演示模式**：
   ```javascript
   // 伪代码示例
   function autoPlay() {
     showStep("通分", () => highlightDenominator());
     playSound("blip");
     showStep("分子相加", () => animateNumerator());
     playSound("blip");
     showStep("约分", () => flashGCD());
     playSound("ding");
   }
   ```

---

### 核心代码片段（scp020版）
```cpp
long long n, a, b, ra, rb, GCD, op;
int main() {
    n = read(), ra = read(), rb = read(), op = read(), n--;
    if (op == 2) ra = -ra; // 处理首项符号
    while (n--) {
        a = read(), b = read(), op = read();
        if (op == 1) ra = ra * b + rb * a; // 通分加法
        else ra = ra * b - rb * a;         // 通分减法
        rb = rb * b;
        GCD = gcd(ra, rb);
        ra /= GCD, rb /= GCD; // 立即约分
    }
    // 符号处理
    if (ra * rb < 0) ra = -abs(ra), rb = abs(rb);
    if (ra % rb == 0) printf("%lld", ra / rb);
    else printf("%lld/%lld", ra, rb);
}
```

---
处理用时：87.87秒
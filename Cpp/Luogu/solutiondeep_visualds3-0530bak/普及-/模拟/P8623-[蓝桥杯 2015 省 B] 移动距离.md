# 题目信息

# [蓝桥杯 2015 省 B] 移动距离

## 题目描述

X 星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为 $1,2,3, \cdots $ 。

当排满一行时，从下一行相邻的楼往反方向排号。

比如：当小区排号宽度为 $6$ 时，开始情形如下：

```
1  2  3  4  5  6
12 11 10 9  8  7
13 14 15 .....
```

我们的问题是：已知了两个楼号 $m$ 和 $n$，需要求出它们之间的最短移动距离。（不能斜线方向移动）

## 说明/提示

时限 1 秒, 256M。

蓝桥杯 2015 年省赛 B 组 H 题。

## 样例 #1

### 输入

```
6 8 2```

### 输出

```
4```

## 样例 #2

### 输入

```
4 7 20```

### 输出

```
5```

# AI分析结果



---

**算法分类**：数学模拟（坐标转换）

---

### **题解思路与难点对比**

#### **核心思路**
所有题解的核心在于将楼号转换为二维坐标，再计算曼哈顿距离。关键差异在于坐标转换的方式：

1. **遍历模拟法**（如 what_can_I_do）：逐个计算每个楼号的坐标，时间复杂度为 O(max(m,n))，不适用于大数。
2. **数学公式法**（如 CEFqwq、安舒阳）：通过整除和取模直接计算行、列，时间复杂度 O(1)。

#### **解决难点**
- **行号计算**：楼号从 1 开始，行号为 `(m-1) // w`（避免整除错误）。
- **列号奇偶行处理**：偶数行正序，奇数行逆序。需处理 `m % w == 0` 的边界情况。

---

### **题解评分（≥4星）**

1. **CEFqwq（5星）**  
   - 思路清晰，直接公式计算坐标。  
   - 代码简洁，处理奇偶行逻辑高效。  
   ```cpp
   q1=(n-1)/w; p1 = (q1%2==0) ? n%w : w-n%w+1;
   ```

2. **安舒阳（4.5星）**  
   - 通过楼号减一简化计算，避免边界问题。  
   ```cpp
   m--; y1 = m/w; x1 = (y1%2) ? w-1 - (m%w) : m%w;
   ```

3. **SilverLi（4星）**  
   - 代码极简，统一奇偶行判断逻辑。  
   ```cpp
   if(X1%2==1) Y1=w-1-Y1; // 奇偶行逆序处理
   ```

---

### **最优思路提炼**
**关键公式**：  
- 行号：`row = (m-1) // w`  
- 列号：  
  ```plaintext
  if row 是偶数 → col = (m-1) % w + 1  
  if row 是奇数 → col = w - (m-1) % w
  ```
**代码实现**：  
```cpp
void get_coord(int m, int w, int &x, int &y) {
    y = (m - 1) / w;
    int mod = (m - 1) % w;
    x = (y % 2 == 0) ? mod + 1 : w - mod;
}
```

---

### **类似题目推荐**
1. **P1141 01迷宫**（曼哈顿距离扩展）  
2. **P2239 螺旋矩阵**（蛇形矩阵坐标转换）  
3. **P1518 方块转换**（矩阵变换与坐标映射）

---

### **可视化算法演示**
**动画设计**：  
1. **像素网格**：用 Canvas 绘制宽度为 w 的网格，不同颜色区分奇偶行方向（蓝色正序，红色逆序）。  
2. **坐标标记**：高亮目标楼号 m 和 n 的位置，显示其坐标。  
3. **步进控制**：  
   - 输入 w, m, n 后，自动计算并绘制路径。  
   - 单步展示行号计算、列号奇偶处理过程。  

**复古风格**：  
- **8位音效**：计算坐标时播放“滴”声，完成时播放胜利音效。  
- **像素颜色**：奇偶行用不同色调（如 0x00FF00 和 0xFF0000）。  

---

### **核心代码（CEFqwq 改进版）**
```cpp
#include <iostream>
using namespace std;

int main() {
    int w, m, n;
    cin >> w >> m >> n;
    auto coord = [w](int x) {
        int row = (x - 1) / w;
        int col = (row % 2) ? w - (x - 1) % w : (x - 1) % w + 1;
        return make_pair(col, row);
    };
    auto [x1, y1] = coord(m);
    auto [x2, y2] = coord(n);
    cout << abs(x1 - x2) + abs(y1 - y2);
    return 0;
}
```

---

通过数学公式直接计算坐标，避免了低效的遍历，代码简洁高效，适用于所有规模的数据。

---
处理用时：79.42秒
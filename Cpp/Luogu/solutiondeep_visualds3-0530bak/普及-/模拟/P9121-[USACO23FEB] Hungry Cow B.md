# 题目信息

# [USACO23FEB] Hungry Cow B

## 题目描述

Bessie 是一头饥饿的奶牛。每天晚餐时，如果谷仓中有干草，她会吃掉一捆干草。为了防止 Bessie 挨饿，有些天 Farmer John 会在早晨（晚餐之前）送来一些干草。具体地说，在第 $d_i$ 天，Farmer John 送来了 $b_i$ 捆干草（$1 \leq d_i \leq 10^{14}, 1 \leq b_i \leq 10^9$）。

请计算 Bessie 在前 $T$ 天内共吃掉了多少捆干草。

## 样例 #1

### 输入

```
1 5
1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 5
1 2
5 10```

### 输出

```
3```

## 样例 #3

### 输入

```
2 5
1 10
5 10```

### 输出

```
5```

# AI分析结果



---

## 算法分类
**模拟**

---

## 题解思路与核心难点

### 核心思路
所有题解均采用**事件驱动模拟**的核心思想：
1. 按时间顺序处理每个送草事件，计算两次事件间的可食用天数
2. 维护两个核心变量：
   - `sum`：当前剩余干草量
   - `last`：干草能维持的最后一天（部分题解使用）
3. 边界处理：最终计算最后一个送草事件到 T 天的余量

### 解决难点
1. **大数处理**：d_i 和 T 可达 1e14，必须避免逐日遍历
2. **事件间天数计算**：需取 `min(剩余天数, 剩余干草)` 作为有效食用量
3. **状态继承**：当两次送草间隔小于当前干草量时，多余干草需累积到下一周期

---

## 题解评分（≥4星）

### [zhlzt] ★★★★☆
- 亮点：直白的模拟思路，变量命名清晰
- 核心代码：
```cpp
pos = min(sum, d[i]-d[i-1]);
sum -= pos; ans += pos;
sum += b[i];
```

### [Nuyoah_awa] ★★★★★
- 亮点：创新使用 last 变量跟踪干草耗尽日，时间复杂度最优
- 核心逻辑：
```cpp
if(last < d) last = d + b;  // 新干草独立计算
else last += b;             // 继承剩余干草
ans = sum(b_i) - max(0, last-T-1)
```

### [chlchl] ★★★★☆
- 亮点：平移干草食用时间的优化思路
- 关键代码：
```cpp
if(now > d[i]) d[i] = now;  // 平移送草时间
now = d[i] + b[i];          // 更新耗尽日
```

---

## 最优思路提炼
**Nuyoah_awa 的 last 跟踪法**
1. **核心变量**：`last` 表示当前干草能维持的最后一天
2. **更新规则**：
   - 若送草时干草已吃完（`last < d_i`）：从 d_i 开始吃新草，维持到 `d_i + b_i - 1`
   - 若仍有剩余（`last >= d_i`）：继承剩余天数，维持到 `last + b_i`
3. **最终计算**：总草量减去超出 T 天的部分

---

## 同类型题目套路
1. **事件间隙资源消耗**：如《P1090 合并果子》中的堆操作
2. **时间轴模拟**：如《P2278 操作系统》中的进程调度
3. **资源累积优化**：如《P1080 国王游戏》中的贪心策略

---

## 推荐练习
1. P1090 合并果子（贪心+优先队列）
2. P1223 排队接水（时间轴贪心）
3. P2278 操作系统（事件驱动模拟）

---

## 代码实现示例
```cpp
// Nuyoah_awa 的最优解法
#include <iostream>
#define int long long
using namespace std;

signed main() {
    int n, T, last = 0, ans = 0;
    cin >> n >> T;
    for(int i=1; i<=n; i++) {
        int d, b; cin >> d >> b;
        if(last < d) last = d + b;
        else last += b;
        ans += b;
    }
    if(last > T) ans -= (last - T - 1);
    cout << ans;
}
```

---

## 可视化设计

### 算法动画方案
1. **时间轴展示**：横向时间轴标记送草日和 T 天
   - 送草日：绿色方块标记，显示 b_i 数值
   - 食用区间：红色进度条显示干草消耗过程
2. **变量跟踪面板**：
   ```plaintext
   | 当前事件 | 剩余干草 | 维持到最后一天 |
   |----------|----------|----------------|
   | d=5      | ▮▮▮▮     | last=8         |
   ```
3. **交互控制**：
   - 步进按钮：单步执行每个送草事件
   - 速度滑块：调节动画播放速度（0.5x~3x）
   - 高亮规则：当前处理的送草事件闪烁黄框

### 复古像素风格
1. **视觉元素**：
   - 8-bit 奶牛精灵：每吃一天草播放咀嚼动画
   - 干草堆：用黄色方块堆表示，消耗时逐个变灰
2. **音效设计**：
   - 送草事件：8-bit "叮" 声
   - 每日食用：短促 "咔嚓" 声
   - 草堆耗尽：低沉 "嗡" 声
3. 自动演示模式：
   - AI 自动执行每个送草事件，右下角显示倒计时
   - 通关奖励：每正确完成一个事件获得金币特效

---

## 调试心得摘录
> _"特判最后一天时发现 t-d[n]+1 的 +1 容易漏，因为天数包含两端" —— zhlzt  
> "平移送草时间的思想源自机房大佬，将不连续的时间转为连续区间" —— chlchl_

---

通过该案例可掌握事件驱动模拟的核心技巧，理解如何通过状态跟踪避免暴力计算。建议结合可视化工具观察干草消耗过程，加深对时间轴处理的理解。

---
处理用时：102.67秒
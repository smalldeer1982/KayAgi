# 题目信息

# [入门赛 #11] 洛谷评测机模拟器 (Hard Version)

## 题目背景

**本题与 Easy Version 题意完全相同，不同的地方在于数据范围。**

现在假装你是洛谷评测机。这一天，洛谷同时进行了 PION 自测、SCP 自测、ION 自测等等比赛。成千上万的评测落到了你的身上！

## 题目描述

现在已经知道你有 $n$ 个相同性能的评测节点，它们被分别标号为 $1, 2, \cdots, n$。一个评测节点在同一时间只能处理一个评测任务。

在某一时刻，$m$ 个评测任务同时涌入了你。我们将这些任务分别标号为 $1, 2, \cdots, m$。这些评测任务需要的评测时间分别为 $t _ 1 , t _ 2, \cdots, t _ m$。每个评测任务**需要且仅需要一个**评测节点来运行，因此你会按照如下方式按照 $1 \sim m$ 的顺序依次将这些评测任务分配到评测节点上：

对于某个耗时 $t _ i$ 的评测任务，你需要找到目前**累积评测时间**最小的评测节点将任务放入。如果有多个评测节点**累积评测时间**相同且最小，则找一个**标号最小**的节点将任务放入。

> 「累积评测时间」定义：假设对于某个评测节点，其被分配了 $a _ 1, a _ 2, \cdots, a _ k$ 共 $k$ 个任务。那么这个评测节点的「累积评测时间」就是 $t _ {a _ 1} + t _ {a _ 2} + \cdots + t _ {a _ k}$。显然的，如果某个评测节点从未被分配过这 $m$ 个任务中的任何一个，那么这个评测节点的「累积评测时间」是 $0$。

现在，你需要统计出，你的这 $n$ 个评测节点分别接受了哪一些评测任务。

## 说明/提示

### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 5 \times 10 ^ 5$，$0 \leq t _ i \leq 10 ^ 9$。

## 样例 #1

### 输入

```
5 10
13 50 90 38 60 64 60 77 6 24```

### 输出

```
1 6
2 8
3
4 7
5 9 10```

## 样例 #2

### 输入

```
12 7
85 99 82 90 14 11 15```

### 输出

```
1
2
3
4
5
6
7
0
0
0
0
0```

# AI分析结果



## 唯一算法分类
**优先队列（堆）**

---

## 综合分析与结论

### 核心思路与难点
**核心算法流程**：
1. **优先队列维护节点状态**：每个节点用 `(累计时间, 节点编号)` 表示，以小根堆形式维护。
2. **堆排序规则**：时间相同时编号小的优先。
3. **动态更新节点**：每次取出堆顶节点，加上当前任务时间后重新入堆，记录任务分配。

**关键难点**：
- **堆的排序规则实现**：需正确处理时间和编号的双重排序。
- **数据范围处理**：`t_i` 总和可能超出 `int`，必须用 `long long`。
- **空间优化**：用 `vector` 存储每个节点的任务列表，避免数组爆空间。

**可视化设计**：
- **动画方案**：用 Canvas 绘制节点队列，颜色深浅表示时间值，任务分配时高亮目标节点。
- **像素风格**：用 8-bit 风格节点图标，每次分配时触发“滴答”音效。
- **步进控制**：允许单步执行任务分配，观察堆顶变化和节点更新过程。

---

## 题解清单（评分≥4星）

### 1. 2021sunzishan（★★★★☆）
- **亮点**：详细解释堆的构建过程，代码可读性高，结构体运算符重载清晰。
- **关键代码**：
  ```cpp
  struct node { long long s; int op; };
  bool operator >(const node &a, const node &b) {
      return (a.s != b.s) ? a.s > b.s : a.op > b.op;
  }
  priority_queue<node, vector<node>, greater<node>> q;
  ```

### 2. dyyzy（★★★★☆）
- **亮点**：对比多种小根堆实现方式，提供反向存储技巧，代码简洁高效。
- **关键技巧**：
  ```cpp
  priority_queue<pair<long long, int>> pq; // 大根堆存储负数
  pq.push(make_pair(-time, -id)); // 时间取反模拟小根堆
  ```

### 3. zzx114514（★★★★☆）
- **亮点**：代码结构简洁，注释明确，强调 `long long` 的必要性。
- **核心逻辑**：
  ```cpp
  struct Node { long long id, time; };
  priority_queue<Node, vector<Node>, greater<Node>> node;
  ```

---

## 最优思路与技巧提炼

### 核心实现思想
- **优先队列动态维护**：始终保证堆顶是当前最优节点。
- **双关键字排序**：先按时间升序，时间相同则按节点编号升序。
- **空间优化**：使用 `vector` 的数组存储结果，避免二维数组空间爆炸。

### 代码片段
```cpp
struct Node {
    long long time;
    int id;
    bool operator>(const Node& other) const {
        return time == other.time ? id > other.id : time > other.time;
    }
};
priority_queue<Node, vector<Node>, greater<Node>> pq;

// 初始化
for (int i = 1; i <= n; ++i) pq.push({0, i});

// 处理任务
while (m--) {
    auto node = pq.top(); pq.pop();
    node.time += t;
    ans[node.id].push_back(task_id++);
    pq.push(node);
}
```

---

## 同类型题与拓展

### 类似算法套路
- **贪心+堆优化**：合并果子（P1090）、任务调度（P1809）、最短作业优先调度。

### 推荐题目
1. **P1090** [合并果子](https://www.luogu.com.cn/problem/P1090)  
   - 每次合并最小两堆，优先队列直接应用。
2. **P1809** [过河问题](https://www.luogu.com.cn/problem/P1809)  
   - 贪心+堆维护最短过河时间。
3. **P4053** [建筑抢修](https://www.luogu.com.cn/problem/P4053)  
   - 堆维护截止时间，贪心选择修复任务。

---

## 个人心得摘录
- **调试教训**：`long long` 必须全局使用，否则大数据溢出导致 WA。
- **思维突破**：反向存储时间值简化大根堆为小根堆的实现，减少代码量。

---

## 可视化与算法演示

### 动画设计
- **Canvas 绘制**：节点排列为水平队列，颜色由浅（时间少）到深（时间多）。
- **高亮操作**：每次分配任务时，目标节点闪烁，显示 `+t_i` 的动画。
- **音效设计**：
  - **分配音效**：8-bit 短音效，音调随任务序号升高。
  - **错误提示**：节点溢出时播放低音警报。

### 复古游戏化
- **像素风格**：节点用 16x16 像素块表示，时间值显示为复古字体。
- **自动演示**：按空格键切换手动/自动模式，自动模式下算法逐步执行。
- **积分系统**：正确完成分配后获得积分，连续正确触发连击奖励。

```html
<!-- 示例：Canvas 绘制节点 -->
<canvas id="heapCanvas" width="800" height="200"></canvas>
<script>
// 绘制节点队列
function drawNodes(nodes) {
    const ctx = document.getElementById('heapCanvas').getContext('2d');
    ctx.clearRect(0, 0, 800, 200);
    nodes.forEach((node, i) => {
        ctx.fillStyle = `hsl(${200 - node.time % 200}, 70%, 50%)`;
        ctx.fillRect(i * 60, 100 - node.time, 50, 50); // 高度反映时间
        ctx.fillText(node.id, i * 60 + 10, 130);
    });
}
</script>
```

--- 

**总结**：优先队列是处理动态最值问题的利器，正确实现排序规则和数据类型是解题关键。

---
处理用时：75.10秒
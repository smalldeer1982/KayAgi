# 题目信息

# [蓝桥杯 2023 省 B] 填空问题

## 题目描述

## 试题 A：日期统计

### 【问题描述】

小蓝现在有一个长度为 $100$ 的数组，数组中的每个元素的值都在 $0$ 到 $9$ 的范围之内。数组中的元素从左至右如下所示:

```
5 6 8 6 9 1 6 1 2 4 9 1 9 8 2 3 6 4 7 7 5 9 5 0 3 8 7 5 8 1 5 8 6 1 8 3 0 3 7 9 2 7 0 5 8 8 5 7 0 9 9 1 9 4 4 6 8 6 3 3 8 5 1 6 3 4 6 7 0 7 8 2 7 6 8 9 5 6 5 6 1 4 0 1 0 0 9 4 8 0 9 1 2 8 5 0 2 5 3 3
```
现在他想要从这个数组中寻找一些满足以下条件的子序列：

1. 子序列的长度为 $8$;

2. 这个子序列可以按照下标顺序组成一个 `yyyymmdd` 格式的日期，并且要求这个日期是 2023 年中的某一天的日期，例如 $20230902$，$20231223$。`yyyy` 表示年份，`mm` 表示月份，`dd` 表示天数，当月份或者天数的长度只有一位时需要一个前导零补充。

请你帮小蓝计算下按上述条件一共能找到多少个**不同**的 2023 年的日期。对于相同的日期你只需要统计一次即可。

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

## 试题 B：01 串的熵

### 【问题描述】

对于一个长度为 $n$ 的 01 串 $S=x_{1} x_{2} x_{3} \ldots x_{n}$，香农信息熵的定义为 $H(S)=-\sum_{i=1}^{n} p\left(x_{i}\right) \log_{2}\left(p\left(x_{i}\right)\right)$，其中 $p(0),p(1)$ 表示在这个 01 串中 0 和 1 出现的占比。

比如，对于 $S=100$ 来说，信息熵 $H(S)=-\frac{1}{3}\log _{2}\left(\frac{1}{3}\right)-\frac{2}{3} \log _{2}\left(\frac{2}{3}\right)-\frac{2}{3} \log _{2}\left(\frac{2}{3}\right)=1.3083$。对于一个长度为 $23333333$ 的 01 串，如果其信息熵为 $11625907.5798$，且 0 出现次数比 1 少，那么这个 01 串中 0 出现了多少次？

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 

## 说明/提示

答题模板，可供参考。

```cpp
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "The answer of task A", // 双引号中替换为 A 题的答案
        "The answer of task B", // 双引号中替换为 B 题的答案
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}
```

# AI分析结果



# 蓝桥杯 2023 省 B 填空问题题解分析

---

## **算法分类**
- **试题 A**：枚举与剪枝、日期处理  
- **试题 B**：数学计算、浮点数精度处理  

---

## **题解思路与核心难点分析**

### **试题 A：日期统计**
#### 核心思路
1. **逆向枚举合法日期**：直接生成所有 2023 年的合法日期（共 365 天），然后在数组中按顺序匹配该日期的 8 位数字。
2. **子序列匹配逻辑**：遍历数组，依次查找日期的每一位数字是否按顺序存在。

#### 解决难点
- **避免暴力枚举子序列**：原始数组长度为 100，暴力枚举所有 8 位子序列的时间复杂度为 O(100^8)，不可行。题解通过枚举合法日期（仅 365 天）将复杂度降为 O(365 × 100)。
- **日期合法性判断**：需处理月份和天数的有效范围（如 2 月 28 天、不同月份天数不同）。

#### 关键代码片段
```cpp
int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
for (int m = 1; m <= 12; m++) {
    for (int d = 1; d <= days[m]; d++) {
        int date[] = {2, 0, 2, 3, m / 10, m % 10, d / 10, d % 10};
        int cnt = 0;
        for (int i = 1; i <= 100; i++) {
            if (a[i] == date[cnt]) cnt++;
            if (cnt == 8) { ans++; break; }
        }
    }
}
```

---

### **试题 B：01 串的熵**
#### 核心思路
1. **公式代入法**：遍历所有可能的 0 的个数 `i`（范围：1 ≤ i ≤ 总长度的一半），代入熵公式计算，找到与目标值误差最小的解。
2. **浮点数精度处理**：比较计算值与目标值的绝对误差，允许误差在 ±0.01 以内。

#### 解决难点
- **数学公式推导**：正确实现熵公式的分步计算，避免浮点数溢出或精度丢失。
- **高效遍历**：总长度 23,333,333，需遍历约 11,666,666 次，合理优化循环逻辑。

#### 关键代码片段
```cpp
for (int i = 1; i <= 23333333 / 2; i++) {
    int j = 23333333 - i;
    double h = 0 - (i * (i / 23333333.0) * log2(i / 23333333.0) 
                  + j * (j / 23333333.0) * log2(j / 23333333.0));
    if (abs(h - 11625907.5798) < 0.01) {
        cout << i;
        return;
    }
}
```

---

## **题解评分与亮点**
### **题解评分 ≥4 星**
| 题解作者 | 评分 | 亮点 |
|---------|------|------|
| dbywsc  | ⭐⭐⭐⭐ | 思路高效清晰，代码简洁，时间复杂度最优。 |
| ZhaoV1  | ⭐⭐   | DFS 思路正确但冗余，去重操作增加复杂度。 |

---

## **最优思路与技巧提炼**
### 试题 A
- **逆向思维**：避免暴力枚举子序列，改为生成合法日期匹配数组。
- **剪枝优化**：通过日期合法性提前终止无效循环。

### 试题 B
- **数学公式逆向求解**：已知结果反推变量，遍历范围合理缩小。
- **浮点数误差处理**：使用绝对误差比较而非严格相等。

---

## **同类题型推荐**
1. **日期处理**：洛谷 P2015（日期计算）、P1051（日期合法性判断）。
2. **数学计算**：洛谷 P1022（方程求解）、P1035（级数求和）。
3. **子序列匹配**：洛谷 P2678（子串统计）。

---

## **可视化与算法演示**
### 试题 A 动画方案
- **像素风格日期匹配**：  
  1. Canvas 绘制数组为 10×10 网格，每个格子代表一个数字。  
  2. 遍历每个合法日期时，高亮当前匹配的数字（如绿色方块），未匹配部分灰色。  
  3. 成功匹配后播放 8 位音效（类似《超级玛丽》金币音效）。  

### 试题 B 动画方案
- **动态折线图**：  
  1. X 轴为 0 的个数，Y 轴为熵值。  
  2. 遍历过程中实时绘制折线，接近目标值时高亮显示并播放提示音。  
  3. 找到解时，显示红色标记点并播放成功音效。

---

## **代码实现**
### 试题 A 完整代码
```cpp
#include <iostream>
using namespace std;

int main() {
    int a[101] = {0,5,6,8,6,9,1,6,1,2,4,9,1,9,8,2,3,6,4,7,7,5,9,5,0,3,8,7,5,8,1,5,8,6,1,8,3,0,3,7,9,2,7,0,5,8,8,5,7,0,9,9,1,9,4,4,6,8,6,3,3,8,5,1,6,3,4,6,7,0,7,8,2,7,6,8,9,5,6,5,6,1,4,0,1,0,0,9,4,8,0,9,1,2,8,5,0,2,5,3,3};
    int days[] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
    int ans = 0;

    for (int m = 1; m <= 12; m++) {
        for (int d = 1; d <= days[m]; d++) {
            int date[] = {2,0,2,3, m/10, m%10, d/10, d%10};
            int cnt = 0;
            for (int i = 1; i <= 100; i++) {
                if (a[i] == date[cnt]) cnt++;
                if (cnt == 8) { ans++; break; }
            }
        }
    }
    cout << ans; // 输出 235
    return 0;
}
```

### 试题 B 完整代码
```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    const int n = 23333333;
    const double target = 11625907.5798;

    for (int i = 1; i <= n/2; i++) {
        double p0 = i * 1.0 / n;
        double p1 = (n - i) * 1.0 / n;
        double h = - (i * p0 * log2(p0) + (n - i) * p1 * log2(p1));
        if (abs(h - target) < 0.01) {
            cout << i; // 输出 11027421
            return 0;
        }
    }
    return 0;
}
```

---

## **个人心得**
- **试题 A**：逆向思维是核心，直接生成合法日期比遍历子序列高效得多。  
- **试题 B**：浮点数计算需注意 `log2` 的参数不能为 0，遍历范围需严格限制在合理区间。

---
处理用时：91.45秒
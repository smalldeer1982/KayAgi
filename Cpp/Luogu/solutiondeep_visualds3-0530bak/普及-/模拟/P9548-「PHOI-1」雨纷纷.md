# 题目信息

# 「PHOI-1」雨纷纷

## 题目背景

**形式化题面的表述已更改。**

今夜，雨纷纷……

![](https://cdn.luogu.com.cn/upload/image_hosting/aec4ykim.png)

## 题目描述

在 $n$ 行 $m$ 列的空地上，有一个大小为 $x$ 行 $y$ 列的伞，雨伞不可以旋转。每天向空地随机洒下 $1 \sim k$ 滴雨，已经有雨的格子不会再降下雨，有伞的格子不会被雨淋湿。

但此伞比较特殊，它完全透明，小 X 无法直接得知伞的位置。但是每天结束后，小 X 都会得知空地上每个空格的状态，即有雨滴或无雨滴。注意，小 X 只会得知格子的状态。小 X 无法得知每天在哪里降了雨。

现在小 X 想让你求出**在最好情况下**（即天数最少时）几天可以使伞的位置唯一，以及得到伞的位置后，场上至少的雨滴数量，数据保证有解。

**形式化的讲**，有一个 $n \times m$ 的矩形，你每天可以**至多**删除 $k$ 个格子。问至少需要多少天以及至少需要删除多少格子，才能使得图中完整的 $x\times y$ 的矩形唯一。

## 说明/提示

**本题采用捆绑测试。**

| Subtask | $n,m$ | $x,y$ |  分值 |
| :-: | :-: | :-: | :-: |
| $0$ | $1\le n,m\le 10$ | 无特殊限制 | $10$ |
| $1$ | $1\le n,m\le 10^3$ | 无特殊限制 | $30$ |
| $2$ | 无特殊限制 | $x=y=2$ | $10$ |
| $3$ | 无特殊限制 | $1 \le x=y \le 10^9$ | $10$ | 
| $4$ | 无特殊限制 | 无特殊限制 | $40$ | 

对于 $100\%$ 的数据，保证 $1 \le x \le n \le 10^9,1 \le y \le m \le 10^9,1 \le k \le 10^9$。

### 样例解释 #1：

第一天在 $(2,2),(2,3),(3,2)$ 处落下雨滴，即可确定雨伞左上角以及右下角位置为 $(3,3),(4,4)$。

图片解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/fp2m6ivv.png)
### 样例解释 #2：

第一天在 $(2,2),(7,1)$ 处落下雨滴，第二天在 $(5,4)$ 处落下雨滴，第三天在 $(4,2),(3,4)$ 处落下雨滴，即可确定雨伞左上角以及右下角位置为 $(5,2),(7,3)$。

## 样例 #1

### 输入

```
4 4 2 2 3```

### 输出

```
1 3```

## 样例 #2

### 输入

```
7 5 3 2 2```

### 输出

```
3 5```

## 样例 #3

### 输入

```
214 748 3 64 8```

### 输出

```
98 782```

# AI分析结果



### 算法分类
**数学（贪心）**

### 题解思路与算法要点
#### 核心思路
- **覆盖点策略**：将大矩阵划分为多个潜在的伞区域，每个区域右下角放置雨滴，排除该区域。余数部分需额外覆盖点。
- **数学计算**：总覆盖点数为 `(n//x) * (m//y)`，根据余数调整：
  - 无余数时减1（保留一个区域）。
  - 有余数时增加对应余数方向的覆盖点。

#### 解决难点
1. **余数处理**：当行列无法整除时，需额外覆盖点排除边缘区域的可能伞位置。
2. **最优性证明**：每个雨滴覆盖尽可能多的潜在伞区域，确保最小覆盖点数。

### 题解评分（≥4星）
1. **CultReborn（5星）**  
   - 思路清晰，通过四种余数情况分类讨论，代码简洁高效。
   - 关键函数 `Get_Rain` 直接体现数学推导，可读性强。
2. **LegendaryGrandmaster（4星）**  
   - 简化了余数判断，代码更简洁。
   - 直接通过 `n%x` 和 `m%y` 是否存在余数调整结果。
3. **sbno333（4星）**  
   - 简明公式推导，代码简短，适合快速实现。

### 最优思路提炼
- **核心公式**：  
  ```cpp
  rain = (n / x) * (m / y);
  if (n % x == 0 && m % y == 0) rain--;
  else rain += (n%x != 0) + (m%y != 0);
  ```
- **余数调整**：每个方向余数非零时加1，确保覆盖所有可能伞区域。
- **贪心天数**：`days = (rain + k - 1) / k` 向上取整。

### 相似题目推荐
1. **P2671 [NOIP2015 普及组] 求和**  
   （数学推导与余数处理）
2. **P3951 [NOIP2017 提高组] 小凯的疑惑**  
   （贪心与整除性质）
3. **P1083 [NOIP2012 提高组] 借教室**  
   （覆盖问题与二分优化）

### 个人心得摘录
- **CultReborn**：通过样例反推数学公式，强调规律的重要性。
- **Red_Alert_star**：提醒不开 `long long` 的常见错误，实践教训深刻。

### 可视化算法演示
#### 核心动画设计
1. **网格划分**：  
   - 将大矩阵按 `x*y` 块划分，高亮每个块的右下角（覆盖点）。
   - **颜色标记**：已覆盖点（红色），候选伞区域（绿色），余数边界（黄色）。
2. **余数覆盖**：  
   - 若有余数，在行或列末端添加覆盖点，展示排除过程。
3. **步进控制**：  
   - 显示每天覆盖的点数（最多 `k` 个），动态更新剩余覆盖点。

#### 复古像素风格
- **8位颜色**：覆盖点用红色方块，伞区域用绿色闪烁块。
- **音效**：覆盖时播放“滴答”声，完成时播放胜利音效。
- **自动演示**：按最优路径自动覆盖，支持暂停/加速。

#### 关键代码片段
```cpp
// 计算最少雨滴数
long long calculateRain(long long n, long long m, long long x, long long y) {
    long long a = n / x, b = m / y;
    long long rain = a * b;
    if (n % x == 0 && m % y == 0) rain--;
    else rain += (n % x != 0) + (m % y != 0);
    return rain;
}

// 计算最少天数
long long calculateDays(long long rain, long long k) {
    return (rain + k - 1) / k;
}
```

### 总结
本题通过数学推导确定覆盖点数目，核心在于整除与余数的分类处理。可视化设计可帮助理解覆盖策略的动态过程，复古像素风格增强交互趣味。

---
处理用时：414.88秒
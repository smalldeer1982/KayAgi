# 题目信息

# [ROIR 2021] 两台机器 (Day 1)

## 题目背景

**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day1 T1 [ Два станка](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day1.pdf)**。

## 题目描述

有两台机器，第一台机器需要 $a$ 分钟启动，接下来每分钟会制造 $x$ 个零件，第二台机器需要 $b$ 分钟启动，接下来每分钟会制造 $y$ 个零件，两个机器不能同时位于启动过程中。

共有 $k$ 分钟，问最多能制造多少个零件。

## 说明/提示

【样例解释】：

如果先启动第二台机器，接着启动第一台机器，可制作 $3\times 15+5\times 4=65$ 个零件。

【数据范围】：

对于所有子任务，有 $0\le k,a,x,b,y\le 10^9$，最终答案可以用 `long long` 存下。

| 子任务编号 | 特殊限制 | 分值 |
| :-: | :-: | :-: |
|$1$|$a=x=0$| $17$ |
|$2$|$a=b=0$| $14$ |
|$3$|$a=b$| $20$ |
|$4$|$x=y$| $20$ |
|$5$|无| $29$ |

## 样例 #1

### 输入

```
20
10 4
5 3```

### 输出

```
65```

# AI分析结果



**唯一算法分类**：贪心

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   所有题解的核心思路是枚举两种可能的启动顺序（先启动第一台或第二台），计算每种情况下的总零件数，取最大值。通过 `max` 处理时间不足的情况（负数时间取0），覆盖所有可能情况，包括只启动一台或都不启动。

2. **算法实现**  
   - **关键公式**：  
     先启动第一台：`max(k-a, 0) * x + max(k-a-b, 0) * y`  
     先启动第二台：`max(k-b, 0) * y + max(k-a-b, 0) * x`  
   - **核心优化**：利用 `max` 自动处理时间不足的情况，无需显式分类讨论。

3. **解决难点**  
   - **时间不足的边界处理**：通过 `max` 函数避免负数时间，简化条件判断。
   - **启动顺序的覆盖性**：两种顺序的计算已涵盖单独启动一台的情况。

---

### **题解评分 (≥4星)**

1. **cff_0102 的题解（5星）**  
   - **亮点**：代码简洁，直接计算两种情况的最大值，逻辑清晰，无冗余判断。
   - **代码片段**：
     ```cpp
     cout << max(max(k-a,0ll)*x+max(k-a-b,0ll)*y, max(k-b,0ll)*y+max(k-a-b,0ll)*x);
     ```

2. **FurippuWRY 的题解（5星）**  
   - **亮点**：通过函数封装 `max` 逻辑，代码可读性强，无冗余。
   - **代码片段**：
     ```cpp
     long long f(long long x) { return (x < 0ll ? 0ll : x); }
     printf("%lld", max(f(k-a)*x + f(k-a-b)*y, f(k-b)*y + f(k-a-b)*x));
     ```

3. **WsW_ 的题解（4星）**  
   - **亮点**：显式处理 `k ≤ a + b` 的情况，逻辑明确但稍显冗余。
   - **代码片段**：
     ```cpp
     if (k <= a + b) cout << max((k-a)*x, (k-b)*y);
     else if (b*x > a*y) cout << (k-a)*x + (k-a-b)*y;
     else cout << (k-b)*y + (k-a-b)*x;
     ```

---

### **最优思路或技巧提炼**

- **贪心策略**：仅需比较两种启动顺序的总收益，无需复杂调度。
- **边界处理技巧**：用 `max` 自动处理负数时间，避免显式条件分支。
- **代码简洁性**：通过一行公式覆盖所有情况，减少错误可能性。

---

### **同类型题或类似算法套路**

- **任务调度问题**：选择最优操作顺序以最大化收益。
- **资源分配问题**：在时间或资源限制下，选择最优分配策略。
- **例题推荐**：
  1. **洛谷 P1005**：矩阵取数游戏（选择取数顺序最大化得分）。
  2. **LeetCode 121**：买卖股票的最佳时机（选择买卖时机）。
  3. **Codeforces 702A**：最长递增子序列（贪心选择序列）。

---

### **个人心得摘录**

- **调试教训**：必须使用 `long long` 避免溢出，如 `max(k-a, 0ll)` 中的 `0ll`。
- **顿悟点**：启动顺序的总收益计算可自动覆盖单独启动的情况，无需显式处理。

---

### **可视化与算法演示**

1. **动画设计**  
   - **时间轴展示**：用不同颜色表示两台机器的启动和生产阶段。
   - **动态更新**：显示剩余时间、当前零件数及启动进度。
   - **高亮关键步骤**：启动阶段用红色，生产阶段用绿色。

2. **复古游戏化效果**  
   - **像素风格**：用 8 位像素块表示时间轴，启动进度条用像素动画。
   - **音效提示**：启动时播放“哔”声，生产时播放“滴答”声。
   - **自动演示模式**：模拟 AI 自动选择最优顺序，显示得分变化。

3. **交互设计**  
   - **控制面板**：允许调整时间 `k`，实时观察零件数变化。
   - **关卡积分**：根据最优解达成速度给予奖励分，增强趣味性。

---

### **核心代码实现**

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    long long k, a, x, b, y;
    cin >> k >> a >> x >> b >> y;
    long long case1 = max(k - a, 0LL) * x + max(k - a - b, 0LL) * y;
    long long case2 = max(k - b, 0LL) * y + max(k - a - b, 0LL) * x;
    cout << max(case1, case2);
    return 0;
}
```

**代码解释**：  
直接计算两种启动顺序的总零件数，通过 `max` 处理时间不足的情况，输出最大值。

---
处理用时：247.37秒
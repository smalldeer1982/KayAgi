# 题目信息

# [USACO20JAN] Photoshoot B

## 题目描述

Farmer John 在给他编号为 $1\ldots N$ 的 $N$ 头奶牛排队拍照（$2\le N\le 10^3$）。FJ 一开始计划从左向右数第 $i$ 个位置排编号为 $a_i$ 的奶牛，他在一张纸上写下了排列 $a_1,a_2,\ldots,a_N$。不幸的是，这张纸刚刚被 Farmer Nhoj 偷走了！

幸好 FJ 仍然有机会恢复他之前写下的排列。在这张纸被偷走之前，Bessie 记录了序列 $b_1,b_2,\ldots,b_{N−1}$，对于每一个 $1\le i<N$ 满足 $b_i=a_i+a_{i+1}$。

基于 Bessie 的信息，帮助 FJ 恢复可以产生序列 $b$
的“字典序最小”的排列 $a$。排列 $x$ 字典序小于排列 $y$，如果对于某个 $j$，对于所有 $i<j$ 均有 $x_i=y_i$，且有 $x_j<y_j$（换句话说，这两个排列到某个位置之前都相同，在这个位置上 $x$ 小于 $y$）。保证存在至少一个满足条件的 $a$。 

## 说明/提示

### 样例解释 1

$a$ 能够产生 $b$，因为 $3+1=4$，$1+5=6$，$5+2=7$，$2+4=6$。

### 测试点性质

 - 测试点 $2-4$ 满足 $N\le 8$。
 - 测试点 $5-10$ 没有额外限制。

## 样例 #1

### 输入

```
5
4 6 7 6```

### 输出

```
3 1 5 2 4```

# AI分析结果



---

### 算法分类  
无算法分类（构造型枚举）

---

### 题解思路与核心分析  

#### **核心逻辑**  
1. **枚举初始值**：从最小的可能值开始枚举 `a[1]`，保证字典序最小。  
2. **递推构造**：根据递推公式 `a[i] = b[i-1] - a[i-1]` 生成整个数组。  
3. **合法性检查**：  
   - **数值范围**：每个元素必须是 `1~n` 的正整数。  
   - **唯一性**：所有元素必须构成 `1~n` 的排列，无重复。  
4. **剪枝优化**：在递推过程中即时检查合法性，一旦发现非法立即终止当前枚举。  

#### **难点对比**  
- **关键点**：部分题解未在生成过程中检查数值范围，导致错误标记合法序列（如 `a[i]` 可能为负数或超过 `n`）。  
- **正确实现**：在生成每个元素时同步检查范围与重复性（如使用 `vis` 数组标记已出现的元素）。  

---

### 题解评分（≥4星）  
1. **DFs_YYDS（5星）**  
   - **亮点**：生成过程中即时检查元素范围与重复性，代码简洁高效。  
   - **代码片段**：  
     ```cpp  
     bool check(int i) {  
         bool vis[1005] = {0};  
         a[1] = i;  
         for (int j=2; j<=n; j++) {  
             a[j] = b[j-1] - a[j-1];  
             if (a[j]<1 || a[j]>n || vis[a[j]]) return false;  
             vis[a[j]] = 1;  
         }  
         return true;  
     }  
     ```  
2. **Officer（4星）**  
   - **亮点**：在递推时同步检查元素范围，使用 `flag` 快速终止非法情况。  
   - **代码片段**：  
     ```cpp  
     for (int j=1; j<=n-1; j++) {  
         a[j+1] = b[j] - a[j];  
         if (a[j+1]<1 || a[j+1]>n || vis[a[j+1]]) {  
             flag = 1; break;  
         }  
         vis[a[j+1]] = 1;  
     }  
     ```  
3. **Kle1N（4星）**  
   - **亮点**：结合范围检查与唯一性检查，逻辑清晰。  
   - **代码片段**：  
     ```cpp  
     if (a[j+1]<1 || a[j+1]>n || vis[a[j+1]]) {  
         f = 0; break;  
     }  
     vis[a[j+1]] = 1;  
     ```  

---

### 最优思路提炼  
1. **字典序最小策略**：从小到大枚举 `a[1]`，确保找到第一个合法解即最优解。  
2. **即时剪枝**：在生成每个元素时同步检查范围与重复性，避免无效计算。  
3. **辅助数据结构**：使用数组（`vis`）替代 `map` 提高效率。  

---

### 同类型题目推荐  
1. **P1008 三连击**：构造三位数满足比例关系。  
2. **P1618 三连击（升级版）**：类似构造，需处理更复杂比例。  
3. **P1157 组合的输出**：生成字典序排列，需按特定格式输出。  

---

### 可视化与算法演示  
#### **核心动画设计**  
- **枚举过程**：展示 `a[1]` 从 `1` 开始递增，每次生成完整数组。  
- **合法性高亮**：用颜色标记非法元素（红色）和合法元素（绿色）。  
- **关键步骤**：  
  1. **生成元素**：按 `a[i] = b[i-1] - a[i-1]` 逐步显示每个元素。  
  2. **范围检查**：若元素超出 `1~n`，立即标记为红色并终止当前枚举。  
  3. **唯一性检查**：用动态 `vis` 数组标记已出现的元素，重复时高亮。  

#### **复古像素风格设计**  
- **元素表示**：用 8-bit 像素方块表示奶牛编号，不同颜色区分合法/非法。  
- **音效设计**：  
  - **合法元素**：短促“滴”声。  
  - **非法终止**：低沉“错误”音效。  
  - **成功找到**：经典 FC 胜利音乐。  
- **交互控制**：支持暂停/步进，观察每个枚举步骤的详细状态。  

---

### 个人心得摘录  
- **调试教训**：未清空 `vis` 数组导致脏数据（如题解 `Luogu_916767` 使用 `map` 未及时清除）。  
- **优化顿悟**：在递推时同步检查范围，而非最终统一检查，显著减少计算量。  

---

### 核心代码实现  
```cpp  
#include<bits/stdc++.h>  
using namespace std;  
int n, b[1005], a[1005];  
bool vis[1005];  

int main() {  
    cin >> n;  
    for (int i=1; i<n; i++) cin >> b[i];  
    for (int i=1; i<=n; i++) {  
        memset(vis, 0, sizeof(vis));  
        a[1] = i; vis[i] = 1;  
        bool valid = true;  
        for (int j=2; j<=n; j++) {  
            a[j] = b[j-1] - a[j-1];  
            if (a[j]<1 || a[j]>n || vis[a[j]]) {  
                valid = false; break;  
            }  
            vis[a[j]] = 1;  
        }  
        if (valid) {  
            for (int k=1; k<=n; k++) cout << a[k] << " ";  
            return 0;  
        }  
    }  
    return 0;  
}  
```  

**注释**：此代码结合即时范围检查与 `vis` 数组，确保高效且正确。

---
处理用时：134.40秒
# 题目信息

# 寻找团伙

## 题目描述

世界局势风云变幻，你想办一件大事。办事自然要有人参与，你能从 $n$ 个人里面挑选一部分人共襄盛举。

要办这件事，一共涉及 $k$ 方面的能力，例如游说他人的能力、玩游戏的能力、睡觉的能力。每位人士都会具备某一些能力，例如机器猫就可能擅长睡觉、擅长玩游戏，而不擅长游说他人。

你的计划很宏伟，因此你希望团队拥有很全面的能力。不幸的是，如果团队中有偶数个人拥有同一类能力，那么他们就会分成两派，争执不下，导致整个团队丧失这方面的能力。相应地，如果这项能力只有奇数个人拥有，那么他们总能形成一个多数派，帮团队去做这方面的工作。

需要注意的是，团队拥有的每一项能力，对计划的成功率的贡献是不一样的。第一项能力最重要，它的权重是 $2^{k-1}$；第二项能力的权重是 $2^{k-2}$；依次类推。第 $k$ 项能力最不重要，权重只有 $1$。

计划的成功率得分，即是**团队拥有的所有能力对应的权重之和**。

你希望计划成功率最大。因此，你需要选出合适的人士，来参与到你的宏图伟业中。


## 说明/提示

#### 样例解释

第一组样例，共 5 个人，每个人拥有的能力不一样。最终选择的结果是让这 5 个人都参与计划，得分 $16+8+4+2+1 = 31$。

第二组样例，我们选择只让 $1$ 参与。那么团队具有能力 $1,2, 3$，得分 $16+8+4=28$。

第三组样例，我们让 $1,2,3$ 参与。由于团队中有偶数个成员拥有能力 $5$，故团队并不拥有能力 $5$。奇数个成员拥有能力 $2$，故团队拥有能力 $2$。最终，团队具有能力 $1,2,3,4$。得分 $16+8+4+2=30$。

#### 数据规模与约定

对于 $100\%$ 的数据，有 $n\leq 21, k\leq 60$。




## 样例 #1

### 输入

```
5 5
1 1
1 2
1 3
1 4
1 5```

### 输出

```
31```

## 样例 #2

### 输入

```
3 5
3 1 2 3
4 2 3 4 5
2 3 4```

### 输出

```
28```

## 样例 #3

### 输入

```
3 5
2 1 2
3 5 3 2
3 4 2 5```

### 输出

```
30```

## 样例 #4

### 输入

```
21 60
0 
0 
3 60 27 48
0 
1 48
2 52 14
2 4 31
0 
0 
2 28 43
2 6 31
0 
1 7
3 45 6 48
0 
1 51
0 
2 28 20
2 37 51
1 8
53 59 39 29 23 53 27 13 16 44 34 38 24 9 32 58 54 31 1 7 45 3 30 36 17 48 42 22 18 21 6 11 25 33 37 52 10 60 49 57 2 28 8 14 5 47 4 41 35 43 50 46 26 12```

### 输出

```
1152884121210322895```

# AI分析结果



---

**唯一算法分类**：线性基（异或线性基）

---

### **题解思路、算法要点与解决难点**

**核心思路**：将问题转化为求最大异或和，利用线性基高效求解。  
**算法要点**：  
1. **线性基构造**：将每个元素的高位作为主元插入，维护线性基数组。  
2. **贪心策略**：从高位到低位，若当前位能增大结果则异或基中的元素。  

**解决难点**：  
- **暴力枚举的局限性**：当n较大时无法处理，线性基将复杂度降至O(nk)。  
- **权重处理**：将能力转化为二进制位权，确保异或结果的二进制位正确对应权重之和。

---

### **题解评分 ≥4星**

1. **Usada_Pekora 的题解（5星）**  
   - **亮点**：提供暴力DFS与线性基两种解法，代码简洁，注释清晰。  
   - **代码可读性**：线性基实现高效，变量命名合理。  
   - **优化程度**：线性基解法为最优算法，适合大范围数据。

2. **阮行止 的题解（4星）**  
   - **亮点**：暴力DFS思路明确，附Python线性基代码供扩展学习。  
   - **实践性**：递归枚举易理解，适合小数据场景。

3. **5k_sync_closer 的题解（4星）**  
   - **亮点**：位运算枚举子集，代码紧凑高效。  
   - **可读性**：循环结构清晰，适合快速实现。

---

### **最优思路或技巧提炼**

**关键技巧**：  
1. **线性基贪心法**：  
   - **插入元素**：从高位到低位，若某位无基则占据，否则异或已有基。  
   - **求最大值**：从高位开始，若异或基元素能增大结果则执行。  
2. **二进制权重映射**：将能力x的权重编码为`1ULL << (k - x)`，直接通过异或操作统计奇偶性。

---

### **同类型题与算法套路**

**相似问题**：  
- **最大异或和问题**：如从数组中选择若干数使异或和最大。  
- **动态维护线性基**：支持插入和查询操作的高效数据结构。  

**通用解法**：  
- **线性基模板**：插入与查询逻辑可直接复用。  
- **位运算优化**：利用位操作处理二进制权重。

---

### **推荐相似题目**

1. [P3857 [TJOI2008]彩灯](https://www.luogu.com.cn/problem/P3857)  
2. [P4151 [WC2011]最大XOR和路径](https://www.luogu.com.cn/problem/P4151)  
3. [P3292 [SCOI2016]幸运数字](https://www.luogu.com.cn/problem/P3292)

---

### **个人心得摘录**

- **调试教训**：`1ULL`必须显式声明，否则左移超过31位会导致错误。  
- **顿悟点**：将奇偶性转化为异或操作，是本题核心抽象。

---

### **可视化与算法演示**

**动画设计**：  
1. **线性基构建过程**：  
   - **像素风格**：用8位色块表示二进制位，每插入一个元素时高亮变化位。  
   - **音效提示**：插入成功时播放“确认音”，冲突时播放“修正音”。  
2. **贪心求最大值**：  
   - **步进演示**：逐位决策，显示当前结果与基元素的异或操作。  
   - **颜色标记**：绿色表示保留当前位，红色表示异或操作。  

**交互功能**：  
- **速度调节**：滑动条控制动画速度。  
- **自动模式**：AI自动完成线性基构建与贪心过程。

**复古效果**：  
- **背景音乐**：8-bit芯片音乐循环播放。  
- **积分系统**：每正确插入一个基元素获得积分，错误操作扣分。

---

### **核心代码实现（线性基）**

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;

ull base[60], n, k;

void insert(ull x) {
    for (int i = k-1; i >= 0; --i) {
        if (x & (1ULL << i)) {
            if (!base[i]) { base[i] = x; break; }
            x ^= base[i];
        }
    }
}

ull query_max() {
    ull res = 0;
    for (int i = k-1; i >= 0; --i)
        if ((res ^ base[i]) > res) res ^= base[i];
    return res;
}

int main() {
    cin >> n >> k;
    for (int i = 0; i < n; ++i) {
        int c, x; cin >> c;
        ull val = 0;
        while (c--) {
            cin >> x;
            val |= (1ULL << (k - x));
        }
        insert(val);
    }
    cout << query_max();
    return 0;
}
```

**代码说明**：  
- `insert`函数构建线性基，`query_max`通过贪心得到最大异或和。  
- **时间复杂度**：O(nk)，适用于n≤1e5，k≤60的场景。

---
处理用时：97.67秒
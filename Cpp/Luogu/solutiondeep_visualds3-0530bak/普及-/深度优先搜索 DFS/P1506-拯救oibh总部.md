# 题目信息

# 拯救oibh总部

## 题目背景

oibh 总部突然被水淹没了！现在需要你的救援……


## 题目描述

oibh 被突来的洪水淹没了，还好 oibh 总部有在某些重要的地方起一些围墙。用 `*` 号表示，而一个四面被围墙围住的区域洪水是进不去的。

oibh 总部内部也有许多重要区域，每个重要区域在图中用一个 `0` 表示。

现在给出 oibh 的围墙建设图，问有多少个没被洪水淹到的重要区域。

## 说明/提示

对于 $100\%$ 的数据，$1 \le x,y \le 500$。

## 样例 #1

### 输入

```
4 5
00000
00*00
0*0*0
00*00```

### 输出

```
1
```

## 样例 #2

### 输入

```
5 5
*****
*0*0*
**0**
*0*0*
*****```

### 输出

```
5```

# AI分析结果



# 【算法分类】  
**广度优先搜索（BFS） / 深度优先搜索（DFS）**

---

# 【题解思路与解决难点】  
### **核心逻辑**  
所有题解的核心思路均为：**洪水从边界蔓延，标记所有能被淹没的格子，最终统计未被标记的格子数**。难点在于如何正确处理边界条件和避免漏判。

### **关键对比与实现要点**  
1. **边界处理差异**  
   - **常规边界遍历**（Blue_wonders / Garrison）：遍历地图四周边界触发搜索，需要单独处理每一条边（第一行、最后一行、第一列、最后一列）。  
   - **外围扩展法**（是羊驼鸭 / xxxjz）：在地图外围额外添加一圈可访问区域（坐标为 -1 或 n+1 的点），从 (0,0) 开始搜索，无需单独处理边界。  
   ```cpp
   // 外围扩展法典型代码（是羊驼鸭）
   dfs(0, 0); // 从虚拟外围开始搜索
   ```
   ![外围扩展法示意图](https://cdn.luogu.com.cn/upload/pic/53433.png)

2. **标记策略对比**  
   - **直接修改原地图**（Garrison / jujujujuruo）：将淹没区域标记为特殊字符（如 '*' 或 '1'），节省内存但破坏原始数据。  
   - **独立标记数组**（liujiayuan / Khassar）：使用独立二维数组 `vis[][]` 记录访问状态，保留原始地图数据。

3. **优化方向**  
   - **DP 失败尝试**（GaryH）：通过状态转移标记淹没区域，但需要多轮循环更新状态，时间复杂度 O(k*nm)（k 为迭代次数），效率低于 DFS/BFS 的 O(nm)。  
   - **BFS 队列优化**（Khassar）：手动模拟队列减少 STL 开销，适合大规模数据。

---

# 【题解评分（≥4星）】  
1. **Blue_wonders（5星）**  
   - **亮点**：代码结构清晰，附详细流程图解，适合新手理解洪水蔓延过程。  
   - **关键代码**：  
     ```cpp
     void search(int x, int y) {  
         a[x][y] = 1; // 标记为淹没  
         for (4方向遍历) if (新坐标合法且未被淹没) search(x0, y0);  
     }
     ```

2. **是羊驼鸭（5星）**  
   - **亮点**：外围扩展法简化边界处理，代码简洁高效，附练习推荐（P1162）。  
   - **心得摘录**：  
     > "从 (0,0) 开始搜索能覆盖所有可能的入口，避免漏掉复杂边界情况。"

3. **xxxjz（4.5星）**  
   - **亮点**：提出多搜一圈解决初始位置不可达的问题，附错误案例分析。  
   - **代码片段**：  
     ```cpp
     dfs(0, 0); // 多搜外围一圈  
     for (统计未被标记的 '0')
     ```

---

# 【最优思路提炼】  
### **关键技巧**  
1. **外围扩展法**：在地图外添加虚拟可访问层，避免复杂边界条件判断。  
2. **逆向思维**：统计未被淹没的格子而非直接寻找被包围区域。  
3. **染色标记**：通过 DFS/BFS 将可达区域标记，剩余区域即为答案。

---

# 【同类题目推荐】  
1. **P1162 填涂颜色**（相同外围扩展法）  
2. **P1451 求细胞数量**（连通块统计）  
3. **P1596 Lake Counting**（八方向洪水填充）

---

# 【可视化设计】  
### **核心流程演示**  
1. **像素化地图渲染**  
   - 使用 16 色复古调色板：  
     - `#000000`（围墙）  
     - `#00FF00`（未淹没区域）  
     - `#FF0000`（洪水蔓延过程）  
     - `#888888`（已淹没区域）  
   - Canvas 绘制网格，每格 20x20 像素。

2. **动画交互设计**  
   - **步进控制**：按空格暂停/继续，方向键单步前进/后退。  
   - **音效设计**：  
     - `move.wav`（每次扩散时播放 8-bit 水滴声）  
     - `success.wav`（统计完成时播放胜利音效）。

3. **自动演示模式**  
   ```javascript
   // 伪代码：洪水蔓延自动演示
   function autoFloodFill() {
     let queue = [[0, 0]]; // 初始外围点
     while (queue.length > 0) {
       let [x, y] = queue.shift();
       playSound('move.wav'); // 触发音效
       drawPixel(x, y, '#FF0000'); // 高亮当前点
       for (4 方向) {
         if (新坐标未越界且未被标记) {
           markAsFlooded(nx, ny);
           queue.push([nx, ny]);
         }
       }
     }
   }
   ```

---

# **代码实现（外围扩展法）**  
```cpp
#include <iostream>
using namespace std;
int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};
char map[505][505];
int n, m;

void dfs(int x, int y) {
    if (x < 0 || y < 0 || x > n+1 || y > m+1 || map[x][y] != '0') return;
    map[x][y] = '#'; // 标记为已淹没
    for (int i = 0; i < 4; i++) 
        dfs(x + dx[i], y + dy[i]);
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> map[i][j];
    dfs(0, 0); // 从虚拟外围开始搜索
    int ans = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (map[i][j] == '0') ans++;
    cout << ans;
    return 0;
}
```

---
处理用时：75.52秒
# 题目信息

# 数列离散化

## 题目描述

给定一个长度为 $n$ 的数列 $a$。定义 $\mathrm{rank}(i)$ 表示数列 $a$ 中比 $a_i$ 小的不同数字个数再加一。

对 $1 \leq i \leq n$，现在请你求出所有的 $\mathrm{rank}(i)$。

## 说明/提示

### 数据规模与约定

对全部的测试点，保证 $1 \leq T \leq 5$，$1 \leq n \leq 10^5$，$-10^9 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
3
3
1 2 3
5
1 6 2 2 7
4
-1 -2 -3 -3```

### 输出

```
1 2 3
1 3 2 2 4
3 2 1 1```

# AI分析结果



---

## 唯一算法分类
离散化

---

## 综合分析与结论

### 核心思路
所有题解均采用 **排序→去重→映射** 的三段式离散化框架：
1. **排序**：将原数组拷贝后排序
2. **去重**：通过 `unique` 函数或遍历去重
3. **映射**：使用二分查找或结构体记录法确定每个元素的离散化值

### 关键难点对比
| 方法                | 优势                          | 难点/注意点                          |
|---------------------|-----------------------------|------------------------------------|
| STL+二分法           | 代码简洁（5行核心逻辑）         | 理解 `unique` 返回值的偏移量处理      |
| 手写二分法           | 避免依赖STL                  | 二分边界条件处理                     |
| 结构体双排序法       | 直观易理解                   | 需要两次排序（时间复杂度2nlogn）     |
| 动态计数法           | 单次遍历计算排名              | 需处理重复元素的跳跃计数             |

### 可视化设计要点
1. **三阶段高亮**：
   - 排序阶段：展示元素逐渐有序化的过程
   - 去重阶段：用闪烁效果标记被删除的重复元素
   - 映射阶段：用线条连接原数组元素与离散化后的位置
2. **像素风格设计**：
   - 元素值用16x16像素块表示，颜色随值变化
   - 离散化后的排名用顶部数字标签显示
3. **音效触发**：
   - 排序完成时播放上升音阶
   - 找到离散化位置时播放 "哔" 声效

---

## 题解清单 (≥4星)

### 1. wangyinghao（⭐⭐⭐⭐⭐）
- **亮点**：极简STL应用，完整注释覆盖全部关键点
- **核心代码**：
  ```cpp
  sort(a+1, a+n+1);
  int cnt = unique(a+1, a+n+1) - (a+1);
  d[i] = lower_bound(a+1, a+cnt+1, d[i]) - a;
  ```

### 2. _Wind_Leaves_ShaDow_（⭐⭐⭐⭐）
- **亮点**：附带离散化概念图解，适合初学者
- **心得引用**："离散化的大多数用处在于节省空间，让数据能在数组中储存下来"

### 3. YuTianQwQ（⭐⭐⭐⭐）
- **亮点**：使用vector容器实现，更符合现代C++风格
- **优化点**：`erase(unique)` 确保去重数组干净

---

## 最优技巧提炼

### 离散化黄金模板
```cpp
vector<int> discretize(vector<int>& arr) {
    vector<int> tmp(arr);                    // 1. 复制
    sort(tmp.begin(), tmp.end());            // 2. 排序
    tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end()); // 3. 去重
    for(int& x : arr)                        // 4. 映射
        x = lower_bound(tmp.begin(), tmp.end(), x) - tmp.begin() + 1;
    return arr;
}
```

### 结构体双排序技巧
```cpp
struct Node { int val, id, rank; };
// 第一次排序计算rank
sort(nodes.begin(), nodes.end(), [](Node a, Node b){ return a.val < b.val; });
// 第二次排序恢复原始顺序
sort(nodes.begin(), nodes.end(), [](Node a, Node b){ return a.id < b.id; });
```

---

## 相似题目推荐

1. **P1496 火烧赤壁**  
   （离散化处理区间端点）

2. **P1955 程序自动分析**  
   （大范围数据离散化+并查集）

3. **P3740 贴海报**  
   （离散化处理覆盖区域）

---

## 复古像素化演示代码（核心片段）

```javascript
// Canvas初始化
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
const SCALE = 20; // 每个元素占20x20像素

function drawArray(arr, highlightIdx = -1) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    arr.forEach((num, i) => {
        ctx.fillStyle = i === highlightIdx ? '#FF5555' : '#55FF55';
        ctx.fillRect(i*SCALE, 0, SCALE-1, SCALE-1);
        ctx.fillStyle = '#000';
        ctx.fillText(num, i*SCALE + 3, SCALE - 5);
    });
}

// 示例动画流程
async function demoDiscretize(arr) {
    let tmp = [...arr];
    drawArray(tmp); // 显示原始数组
    await sleep(1000);
    
    tmp.sort((a,b) => a-b); // 排序阶段
    drawArray(tmp);
    playSound('sort_complete');
    await sleep(1500);
    
    tmp = [...new Set(tmp)]; // 去重阶段
    drawArray(tmp);
    playSound('unique_done');
    await sleep(1500);
    
    // 映射阶段
    for(let x of arr) {
        let pos = tmp.findIndex(v => v >= x);
        drawArray(tmp, pos);
        playSound('mapping');
        await sleep(500);
    }
}
```

---

## 关键实现代码（wangyinghao版）

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[100005], d[100005];

int main() {
    ios::sync_with_stdio(0);
    int T, n;
    cin >> T;
    while(T--) {
        cin >> n;
        for(int i=1; i<=n; i++) {
            cin >> a[i];
            d[i] = a[i];
        }
        sort(a+1, a+n+1);
        int cnt = unique(a+1, a+n+1) - (a+1);
        for(int i=1; i<=n; i++)
            d[i] = lower_bound(a+1, a+cnt+1, d[i]) - a;
        for(int i=1; i<=n; i++) 
            cout << d[i] << " \n"[i==n];
    }
    return 0;
}
```

---
处理用时：90.57秒
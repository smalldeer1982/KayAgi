# 题目信息

# 火烧赤壁

## 题目背景

曹操平定北方以后，公元 208 年，率领大军南下，进攻刘表。他的人马还没有到荆州，刘表已经病死。他的儿子刘琮听到曹军声势浩大，吓破了胆，先派人求降了。

孙权任命周瑜为都督，拨给他三万水军，叫他同刘备协力抵抗曹操。

隆冬的十一月，天气突然回暖，刮起了东南风。

没想到东吴船队离开北岸大约二里距离，前面十条大船突然同时起火。火借风势，风助火威。十条火船，好比十条火龙一样，闯进曹军水寨。那里的船舰，都挤在一起，又躲不开，很快地都烧起来。一眨眼工夫，已经烧成一片火海。

曹操气急败坏的把你找来，要你钻入火海把连环线上着火的船只的长度统计出来！

## 题目描述

给定每个起火部分的起点和终点，请你求出燃烧位置的长度之和。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 2 \times 10^4$，$-2^{31} \leq a <  b \lt 2^{31}$，且答案小于 $2^{31}$。




## 样例 #1

### 输入

```
3
-1 1
5 11
2 9```

### 输出

```
11```

# AI分析结果



## 唯一算法分类  
**贪心算法**

---

## 综合分析与结论  
题目核心是求多个区间的并集总长度，需避免重复计算重叠部分。各题解主要采用以下两种思路：  
1. **排序+合并区间**：按区间起点排序，维护当前合并区间的右端点，逐个处理后续区间，若重叠则合并，否则累加长度。  
2. **双排序+贪心计算**：将起点和终点分别排序，逐个累加每个区间长度并减去相邻区间的重叠部分。  

**核心难点**在于高效处理大规模数据与复杂重叠情况。**合并区间法**直观且易实现，时间复杂度为 O(n log n)；**双排序法**巧妙利用排序后的数学特性，同样高效。离散化方法适用于数据范围极大的场景，但实现复杂度较高。

---

## 题解清单 (≥4星)  
### 1. wxwoo (⭐⭐⭐⭐⭐)  
**关键亮点**：  
- 分别对起点和终点排序，简化重叠判断。  
- 遍历时累加长度并动态减去相邻重叠部分，代码简洁高效。  
- 时间复杂度 O(n log n)，空间 O(n)。  

### 2. cold_cold (⭐⭐⭐⭐)  
**关键亮点**：  
- 按起点排序后维护当前合并区间的右端点。  
- 动态更新区间右端点，合并重叠部分，逻辑清晰。  
- 时间复杂度 O(n log n)，空间 O(n)。  

### 3. li20082008li (⭐⭐⭐⭐)  
**关键亮点**：  
- 类似合并区间法，但采用动态维护最大右端点。  
- 处理逻辑简明，代码可读性强。  

---

## 最优思路提炼  
1. **排序预处理**：按区间起点排序，便于处理重叠。  
2. **贪心合并**：遍历时动态维护当前合并区间的右端点，若后续区间与之重叠则合并，否则累加长度。  
3. **数学简化**：双排序法通过起点和终点的有序性，直接计算总贡献并减去相邻重叠部分。  

---

## 同类型题与算法套路  
- **区间合并**：如合并重叠区间、求并集长度。  
- **离散化+差分**：适用于数据范围极大但操作次数有限的场景。  
- **贪心选择**：通过排序将问题转化为可贪心处理的子问题。  

---

## 推荐洛谷题目  
1. **P1886 滑动窗口**（单调队列维护区间极值）  
2. **P2280 校门外的树**（区间覆盖问题的基础版）  
3. **P1904 矩形覆盖**（二维区间合并的变形）  

---

## 个人心得摘录  
> _"将起点和终点分别排序后，重叠判断变得异常简单——只需比较当前终点与下一个起点。这种数学上的对称性让代码既简洁又高效。"_ —— wxwoo  

---

## 可视化与算法演示  
**核心算法流程动画设计**：  
1. **初始排序**：展示所有区间按起点排序后的状态。  
2. **合并过程**：高亮当前合并区间，逐步扩展右端点，动态绘制合并后的区间。  
3. **重叠判断**：用不同颜色标记重叠部分，实时计算并显示累加长度。  

**复古像素风格实现**：  
- **Canvas 绘制**：用色块表示区间，合并时色块延展，重叠部分闪烁提示。  
- **8位音效**：区间合并时播放短促音效，完成时播放上扬音调。  
- **自动演示**：按步进或连续播放，支持暂停/继续，参数调节。  

```javascript
// 示例代码片段：合并区间动画核心逻辑
function mergeIntervals(intervals) {
    intervals.sort((a, b) => a[0] - b[0]);
    let merged = [];
    for (let interval of intervals) {
        if (!merged.length || merged[merged.length-1][1] < interval[0]) {
            merged.push(interval);
        } else {
            merged[merged.length-1][1] = Math.max(merged[merged.length-1][1], interval[1]);
        }
    }
    return merged;
}
```

---

## 代码实现  
### wxwoo 双排序法核心代码  
```cpp
sort(a, a+n); // 起点排序
sort(b, b+n); // 终点排序
long long total = 0;
for (int i=0; i<n; i++) {
    total += b[i] - a[i];
    if (i+1 < n && b[i] > a[i+1]) {
        total -= b[i] - a[i+1]; // 减去重叠部分
    }
}
cout << total;
```

### cold_cold 合并区间法核心代码  
```cpp
sort(intervals.begin(), intervals.end());
int start = intervals[0][0], end = intervals[0][1];
int total = 0;
for (int i=1; i<n; i++) {
    if (intervals[i][0] <= end) {
        end = max(end, intervals[i][1]); // 合并右端点
    } else {
        total += end - start; // 累加当前区间
        start = intervals[i][0];
        end = intervals[i][1];
    }
}
total += end - start; // 最后一段
cout << total;
```

---
处理用时：143.26秒
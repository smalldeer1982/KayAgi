# 题目信息

# 天际线

## 题目描述

Latium 省的 Genoa 是亚平宁半岛西海岸北端的一片土地，自然资源丰富，却无人居住。你受到罗马执政官 Caesar 的委任，前往 Genoa 建立新的城市。Caesar 对这次任务的要求是在 Genoa 这片土地上建立起一座繁荣的城市，他将以此作为衡量你的表现的标准。

正在你大刀阔斧地进行城市建设的时候，Caesar 突然写信给你，说他要检查 Genoa 的建设情况。Caesar 希望知道你的城市是什么样子，但是他又非常的忙，所以他只要你描述一下城市的轮廓就可以了，他将依照城市的轮廓决定你的薪水。

怎样描述一个城市的轮廓呢？我们知道 Genoa 所有的建筑共享一个地面，你可以认为它是水平的。所有的建筑用一个三元组 $(L_i,H_i,R_i)$，其中 $L_i$ 和 $R_i$ 分别是建筑的左坐标和右坐标，$H_i$ 就是建筑的高度。在下方所示的图表中左边建筑物描述如下 $(1,11,5)$，$(2,6,7)$，$(3,13,9)$，$(12,7,16)$，$(14,3,25)$，$(19,18,22)$，$(23,13,29)$，$(24,4,28)$，右边用轮廓线的顺序$(1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0)$ 表示：

![](https://cdn.luogu.com.cn/upload/image_hosting/oe7wpwsi.png)


## 样例 #1

### 输入

```
1 11 5
2 6 7
3 13 9
12 7 16
14 3 25
19 18 22
23 13 29
24 4 28
```

### 输出

```
1 11 3 13 9 0 12 7 16 3 19 18 22 3 23 13 29 0```

# AI分析结果



# 天际线问题题解分析

## 一、算法分类
**扫描线算法（Sweep Line Algorithm）**

## 二、题解思路与核心难点分析

### 核心算法对比
1. **暴力法（InchTree、sfmmdm）**
   - **核心思路**：遍历每个建筑覆盖的区间，直接更新每个x坐标的最大高度。最后遍历所有x坐标，记录高度变化的点。
   - **难点解决**：通过调整区间端点（如右端点改为不包含）或扩展x坐标为两倍（处理0.5位置）避免缝隙问题。
   - **复杂度**：O(n×w)，w为坐标范围，适用于小数据。

2. **扫描线+线段树（big_news）**
   - **核心思路**：将建筑的左右边界作为事件点排序，线段树维护区间最大高度。离散化坐标减少节点数。
   - **关键步骤**：
     1. 离散化坐标，事件点按x排序。
     2. 线段树区间更新最大值，统计高度变化。
   - **复杂度**：O(n log n)，高效处理大数据。

3. **优先队列（haoyun1）**
   - **核心思路**：事件点按x排序，左端点入队，右端点标记删除。维护当前最大高度。
   - **关键点**：优先队列存储高度，遇到右端点时延迟删除（标记失效）。
   - **复杂度**：O(n log n)，实现简洁高效。

4. **珂朵莉树（Minecraft万岁）**
   - **核心思路**：通过区间推平操作维护高度，排序后按高度覆盖保证正确性。
   - **优势**：代码简洁，适合随机区间覆盖场景。

### 解决难点总结
- **缝隙问题**：通过区间端点调整或坐标扩展解决。
- **高效维护最大值**：线段树、优先队列或平衡树动态维护。
- **事件处理顺序**：按x坐标排序事件点，处理插入/删除操作。

---

## 三、题解评分（≥4星）

### 1. InchTree的暴力法（4星）
- **亮点**：代码极简，通过调整循环条件巧妙解决缝隙问题。
- **代码**：
  ```cpp
  for(i=a; i<b; ++i) H[i]=max(H[i],h);  // 右端点不包含
  ```

### 2. big_news的扫描线+线段树（5星）
- **亮点**：标准解法，离散化处理高效，详细讲解事件点与线段树更新。
- **关键代码**：
  ```cpp
  sort(sug, events);  // 事件排序
  sgt.modify(l, r, h);  // 线段树区间更新
  ```

### 3. haoyun1的优先队列（4.5星）
- **亮点**：事件驱动，优先队列维护当前最大高度，代码清晰。
- **关键代码**：
  ```cpp
  priority_queue<int> pq;
  pq.push(h);  // 左端点入队
  while (pq.top()是已删除的) pq.pop();  // 延迟删除
  ```

---

## 四、最优思路与技巧提炼

### 关键思路
- **事件驱动处理**：将建筑边界抽象为事件，按x排序后顺序处理。
- **动态维护最大值**：优先队列或线段树高效维护当前最高高度。
- **离散化优化**：减少线段树节点，提升性能。

### 技巧总结
- **暴力法优化**：调整区间端点避免逻辑错误。
- **延迟删除**：优先队列中标记失效节点，遇到时再清理。
- **坐标扩展**：处理0.5位置确保无遗漏高度变化。

---

## 五、类似题目推荐
1. **P1502 窗口的星星**（扫描线+线段树）
2. **P5490 矩形面积并**（离散化+扫描线）
3. **P1884 覆盖统计**（区间覆盖问题）

---

## 六、可视化与算法演示

### 核心算法流程（优先队列法）
1. **事件点排序**：将所有建筑的左右端点按x坐标排序，左端点标记为插入，右端点标记为删除。
2. **维护当前高度**：
   - **插入事件**：将高度加入优先队列。
   - **删除事件**：标记该高度失效，后续遇到时清理队列顶部的失效节点。
3. **生成轮廓点**：每次处理事件后，若当前最大高度变化，则记录轮廓点。

### 复古像素风格动画设计
- **Canvas绘制**：
  - **建筑**：用不同颜色方块表示，高度对应像素高度。
  - **扫描线**：红色竖线从左向右移动，触发事件时播放“滴”声。
  - **轮廓线**：绿色折线动态生成，高度变化时闪烁。
- **音效**：
  - **插入事件**：短促“哔”声。
  - **高度变化**：上扬音调。
- **自动演示**：按空格键暂停/继续，方向键调整速度。

---

## 七、代码片段（优先队列实现）
```cpp
vector<Event> events;
for (auto &b : buildings) {
    events.push_back({b.l, b.h, INSERT});
    events.push_back({b.r, b.h, DELETE});
}
sort(events.begin(), events.end());

multiset<int> heights{0};
int prev_max = 0;
for (auto &e : events) {
    if (e.type == INSERT) heights.insert(e.h);
    else heights.erase(heights.find(e.h));
    
    int curr_max = *heights.rbegin();
    if (curr_max != prev_max) {
        output(e.x, curr_max);
        prev_max = curr_max;
    }
}
```

---

## 八、总结
**最优解法**：优先队列法平衡了效率与代码复杂度，适合面试与竞赛场景。  
**学习建议**：掌握事件驱动思想，熟练使用STL维护动态最大值。

---
处理用时：70.30秒
# 题目信息

# [GESP202403 五级] B-smooth 数

## 题目描述

小杨同学想寻找一种名为 $ B $-smooth 数的正整数。 

如果一个正整数的最大质因子不超过 $ B $，则该正整数为 $ B $-smooth 数。小杨同学想知道，对于给定的 $ n $ 和 $ B $，有多少个不超过 $ n $ 的 $ B $-smooth 数。

## 说明/提示

### 数据规模与约定

| 子任务 | 得分 | $n \leq $ | $B$ |
| :-: | :-: | :-: | :-: |
| $1$ | $30$ | $10^3$ | $1 \leq B \leq 10^3$ |
| $2$ | $30$ | $10^6$ | $\sqrt n \leq B \leq 10^6$ |
| $3$ | $40$ | $10^6$ | $1 \leq B \leq 10^6$ | 

对全部的测试数据，保证 $1 \leq n, B \leq 10^6$。

## 样例 #1

### 输入

```
10 3```

### 输出

```
7```

# AI分析结果



---

## 算法分类选择  
**筛法预处理**

---

## 题解思路、算法要点与解决难点  

### 核心思路  
通过筛法预处理每个数的**最大质因子**，最后统计最大质因子 ≤ B 的数的个数。  
- **筛法改进**：使用埃氏筛法的变种，当遍历到质数 i 时，将其所有倍数 j 的最大质因子标记为 i。  
- **动态更新**：每个合数会被多次更新，但最后一次更新对应的质数即为最大质因子。  
- **复杂度**：时间复杂度 O(n log log n)，与埃氏筛相同，适用于 n ≤ 1e6。

### 解决难点  
1. **如何高效计算最大质因子**  
   - 直接质因数分解复杂度高（O(√n) 每个数），无法处理 n=1e6。  
   - 筛法预处理通过标记倍数，保证每个数被其最大质因子最后覆盖。  
2. **边界条件处理**  
   - 1 的最大质因子特殊处理为 1。  
   - 质数的最大质因子是自身，合数则通过筛法动态更新。

---

## 题解评分 (≥4星)  

### 1. Little_x_starTYJ（5星）  
- **亮点**：代码简洁高效，直接筛法预处理最大质因子。  
- **代码可读性**：数组命名清晰，逻辑直观。  
- **优化程度**：最优时间复杂度 O(n log log n)。  

### 2. dlzlj_2010（5星）  
- **亮点**：与上者思路一致，变量命名更明确。  
- **实践性**：注释详细，适合教学。  

### 3. xzz_0611（4星）  
- **亮点**：代码极简，仅 16 行。  
- **可读性**：数组名 `Max` 直观体现功能。  

---

## 最优思路或技巧提炼  
1. **筛法预处理最大质因子**  
   - 初始化数组 `max_prime`，遍历时若 `i` 是质数，则标记其所有倍数。  
   - 合数的最大质因子由最后一次标记的质数决定。  
2. **关键代码片段**  
   ```cpp
   for (int i = 2; i <= n; i++) {
       if (!max_prime[i]) {  // i 是质数
           for (int j = i; j <= n; j += i) {
               max_prime[j] = i;  // 更新 j 的最大质因子
           }
       }
   }
   ```

---

## 同类型题或类似算法套路  
- **质数预处理**：如统计最小质因子、质数个数。  
- **因子相关统计**：如因子和、因子数量。  
- **类似题目**：  
  - P3383 【模板】线性筛素数  
  - P3912 素数个数  
  - P1075 [NOIP2012 普及组] 质因数分解  

---

## 推荐相似知识点题目  
1. **P3383**：线性筛素数模板题。  
2. **P3912**：统计 1~n 的质数个数（需高效筛法）。  
3. **P1075**：给定合数，输出其最大质因子（直接应用本题预处理）。  

---

## 个人心得摘录  
- **xyx404** 提到在筛法中跳过某些情况，但实际测试发现质数判断导致超时，最终优化质数判断函数。  
- **Kle1N** 尝试暴力分解但发现超时，转而加入记忆化优化。  

---

## 可视化与算法演示  

### 核心算法过程动画设计  
1. **筛法步骤可视化**  
   - **网格展示**：将 1~n 的数排列成网格，初始全灰色。  
   - **质数高亮**：当遍历到质数 i 时，i 变为绿色。  
   - **标记倍数**：i 的倍数 j 被标记为当前 i 的颜色（如蓝色），若后续被更大质数更新则变色（如红色）。  
   - **动态更新**：在右侧显示当前处理的质数 i 和正在标记的 j。  

2. **复古像素风格**  
   - **8位调色板**：质数用绿色，合数根据最大质因子颜色渐变。  
   - **音效触发**：  
     - 质数发现：播放 "ping" 音效。  
     - 倍数标记：短促 "beep"。  
   - **Canvas 动画**：用像素块表示数，标记时闪烁。  

3. **交互控制**  
   - **步进控制**：支持暂停/继续，调整动画速度。  
   - **高亮模式**：勾选后显示当前质数的倍数标记过程。  

---

## 代码实现（核心逻辑）  
```cpp
#include <iostream>
using namespace std;

int main() {
    int n, b, ans = 0;
    cin >> n >> b;
    int max_prime[n + 1] = {0};
    max_prime[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!max_prime[i]) {  // i 是质数
            for (int j = i; j <= n; j += i) {
                max_prime[j] = i;  // 更新 j 的最大质因子
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        if (max_prime[i] <= b) ans++;
    }
    cout << ans;
    return 0;
}
```

---
处理用时：84.40秒
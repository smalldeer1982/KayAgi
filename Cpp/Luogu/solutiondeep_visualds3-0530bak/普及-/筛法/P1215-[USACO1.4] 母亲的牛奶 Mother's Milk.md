# 题目信息

# [USACO1.4] 母亲的牛奶 Mother's Milk

## 题目描述

农民约翰有三个容量分别是 $a,b,c$ 升的桶。  

最初，$a,b$ 桶都是空的，而 $c$ 桶是装满牛奶的。有时，农民把牛奶从一个桶倒到另一个桶中，直到被灌桶装满或原桶空了。  

当然每一次灌注都是完全的。由于节约，牛奶不会有丢失。

写一个程序去帮助农民找出当 $a$ 桶是空的时候，$c$ 桶中牛奶所剩量的所有可能性。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le a,b,c \le 20$。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
8 9 10
```

### 输出

```
1 2 8 9 10
```

## 样例 #2

### 输入

```
2 5 10```

### 输出

```
5 6 7 8 9 10```

# AI分析结果



### 唯一算法分类  
**DFS/BFS 状态空间搜索**

---

### 综合分析与结论  
#### 核心算法流程  
所有题解的核心思路是：  
1. **状态表示**：用 (a, b, c) 表示三个桶的当前牛奶量，或利用总牛奶量固定特性简化为 (a, b)  
2. **状态转移**：枚举 6 种倒牛奶操作（A→B、A→C、B→A、B→C、C→A、C→B）  
3. **剪枝优化**：用三维数组 `vis[a][b][c]` 记录已访问状态，避免重复计算  
4. **结果记录**：当 a=0 时记录 c 的值，最终排序输出  

#### 解决难点  
- **状态爆炸**：通过 `vis` 数组剪枝，确保每个状态仅访问一次  
- **倒牛奶逻辑**：正确处理倒满目标桶或倒空源桶的两种情况（`min(剩余容量, 当前量)`）  
- **输出去重**：使用桶排序思想直接标记可能值，避免重复记录  

#### 可视化设计要点  
1. **Canvas 网格动画**：  
   - 用三个矩形表示桶，颜色填充高度表示牛奶量  
   - 当前操作桶高亮（如红色边框），目标桶闪烁黄色  
   - 状态转移时显示箭头动画（如 A→B）  
2. **复古像素风格**：  
   - 使用 8-bit 音效（倒牛奶声、发现新状态音效）  
   - 背景音乐采用《超级马里奥》风格循环 MIDI  
3. **交互控制**：  
   - 步进按钮控制单步执行  
   - 速度滑块调节动画速度（0.5x~5x）  
   - 自动演示模式模拟“AI 解题”过程  

---

### 题解清单（≥4星）  
1. **远航之曲（DFS）** ⭐⭐⭐⭐  
   - **亮点**：三维状态剪枝，循环处理 3×3 倒法，代码简洁  
   - **关键代码**：  
     ```cpp
     for (int i=0; i<3; ++i) for (int j=0; j<3; ++j) {
         if (j == i) continue;
         int rec = min(bkt[j]-a[j], a[i]); // 计算可倒量
         // 更新状态并递归
     }
     ```
2. **xun薰（DFS）** ⭐⭐⭐⭐  
   - **亮点**：紧凑的嵌套条件判断，显式处理每种倒法  
   - **技巧**：利用三目运算符 `min(ta,nowa+nowc)` 简化计算  
3. **Kewth（DFS）** ⭐⭐⭐⭐  
   - **亮点**：函数式风格，每个倒法单独处理，逻辑清晰  
   - **代码片段**：  
     ```cpp
     y+z>b ? milk(x, y+z-b, b) : milk(x, 0, y+z);
     ```

---

### 最优思路提炼  
1. **状态压缩**：利用 `a+b+c=总容量` 的特性，只需记录两个桶的状态  
2. **统一倒法处理**：通过循环枚举源桶和目标桶，减少代码重复  
3. **剪枝优化**：三维数组标记访问状态，时间复杂度 O(N³) 可控（N≤20）  

---

### 同类型题目推荐  
1. **P1135 奇怪的电梯**（状态：当前楼层+按钮状态）  
2. **P1443 马的遍历**（BFS 最短路径模板）  
3. **P1216 数字三角形**（动态规划，状态转移类似倒牛奶决策）  

---

### 代码核心实现（远航之曲 DFS）  
```cpp
void dfs(int a[]) {
    if (vis[a[0]][a[1]][a[2]]) return;
    vis[a[0]][a[1]][a[2]] = true;
    if (a[0] == 0) milk[a[2]] = true; // 记录结果

    for (int i=0; i<3; ++i) {        // 源桶
        for (int j=0; j<3; ++j) {    // 目标桶
            if (i == j) continue;
            int pour = min(bkt[j]-a[j], a[i]); // 可倒量
            int b[3] = {a[0], a[1], a[2]};
            b[i] -= pour; b[j] += pour;
            dfs(b);
        }
    }
}
```

---

### 可视化示例（伪代码）  
```javascript
// Canvas 绘制桶状态
function drawBuckets(a, b, c) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawSingleBucket(50, a, "#FF0000");  // A桶红色
    drawSingleBucket(150, b, "#00FF00"); // B桶绿色
    drawSingleBucket(250, c, "#0000FF"); // C桶蓝色
}

// 倒牛奶动画
function animatePour(src, dest, amount) {
    let current = 0;
    const interval = setInterval(() => {
        current += 1;
        drawPourArrow(src, dest, current); // 绘制流动箭头
        if (current >= amount) clearInterval(interval);
    }, 50);
}
```

---

### 个人心得摘录  
> "DFS 时忘记状态剪枝导致 MLE，加上 vis 数组后瞬间 AC。状态空间问题必须严格记录已访问状态！" —— 某题解调试经历  

> "发现总牛奶量不变，用二维状态即可，内存从 20MB 降到 100KB" —— 空间优化技巧

---
处理用时：64.26秒
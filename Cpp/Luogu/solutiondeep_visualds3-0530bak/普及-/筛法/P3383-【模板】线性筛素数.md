# 题目信息

# 【模板】线性筛素数

## 题目背景

本题已更新，从判断素数改为了查询第 $k$ 小的素数。  

提示：本题输入输出、运算数据量较大。

- 对于 C++ 语言，如果你使用 `cin` 来输入输出，建议使用 `std::ios::sync_with_stdio(0)` 来加速，同时使用 `'\n'` 换行输出。
- 对于 Java 语言，使用线性筛并且优化输入输出，也可以在规定时限内通过本题，但是时限可能较紧张。
- 对于 Python 语言，语言性能差异较大，需要使用到 `numpy` 库的数组以替代列表，且使用埃氏筛法，依然可以在合适的时间和内存消耗下通过本题。

## 题目描述

如题，给定一个范围 $n$，有 $q$ 个询问，每次输出第 $k$ 小的素数。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$n = 10^8$，$1 \le q \le 10^6$，保证查询的素数不大于 $n$。

Data by NaCly\_Fish.


## 样例 #1

### 输入

```
100 5
1
2
3
4
5```

### 输出

```
2
3
5
7
11```

# AI分析结果



**唯一算法分类**：线性筛法（欧拉筛）

---

### **题解思路与难点分析**

#### **核心算法**
所有题解均围绕**预处理素数表**展开，核心差异在于筛法选择：
1. **欧拉筛**：通过「最小质因数」保证每个合数只被标记一次，时间复杂度 $O(n)$
   - 关键实现：`if (i % prime[j] == 0) break` 终止冗余标记
2. **埃氏筛**：通过「质数倍数」标记合数，优化后时间复杂度 $O(n \log \log n)$
   - 关键优化：`bitset` 压缩内存、只筛奇数、从 $i^2$ 开始标记

#### **解决难点**
- **内存限制**：$n=10^8$ 需处理约 100MB 标记数组
  - `bitset`（C++）/ `numpy`（Python）/ `BitSet`（Java）大幅压缩内存
- **时间效率**：避免重复标记
  - 欧拉筛通过「最小质因数」保证线性复杂度
  - 埃氏筛通过位运算加速内存访问

#### **优化对比**
| 方法       | 时间复杂度   | 空间优化           | 适用场景            |
|------------|--------------|--------------------|-------------------|
| 欧拉筛     | $O(n)$       | 原生数组           | 严格线性复杂度要求 |
| 埃氏筛+位压| $O(n \log \log n)$ | `bitset`/`numpy` | 内存敏感、语言性能差 |

---

### **题解评分（≥4星）**

1. **学委（5星）**  
   - 亮点：完整证明线性筛正确性、代码注释清晰、更新日志体现迭代优化  
   - 核心代码：  
     ```cpp
     for(int j=1; j<=cnt && i*Prime[j]<=n; j++) {
         isPrime[i*Prime[j]] = 0;
         if(i % Prime[j] == 0) break; // 保证最小质因数筛
     }
     ```

2. **rainygame（4星）**  
   - 亮点：`bitset`优化实现埃氏筛、对比不同语言性能差异  
   - 核心代码：  
     ```cpp
     bitset<MAXN> is_prime;
     for (int j=i*i; j<=n; j += i) 
         is_prime[j] = false;
     ```

3. **Chase12345（4星）**  
   - 亮点：简洁的欧拉筛实现、正确性证明与复杂度分析  
   - 核心代码：  
     ```cpp
     for (auto p : Prime) {
         if (i * p > n) break;
         vis[i * p] = 1;
         if (i % p == 0) break;
     }
     ```

---

### **最优思路提炼**

1. **欧拉筛核心技巧**  
   - **终止条件**：当 `i % prime[j] == 0` 时，后续的 `prime[j+1]` 不是最小质因数
   - **线性证明**：每个合数被其最小质因数筛除，仅标记一次

2. **位压缩优化**  
   - 使用 `bitset`（C++）或 `bytearray`（Python）将布尔数组压缩至 $\frac{1}{8}$ 内存

3. **预处理查询分离**  
   - 预处理素数表后直接 $O(1)$ 响应查询，避免重复计算

---

### **同类型题与算法套路**

- **通用筛法套路**  
  - **区间筛法**：预处理小质数后筛大区间（例：[SPOJ PRIME1]）
  - **多因子筛法**：记录最小质因数用于快速质因数分解

- **推荐题目**  
  1. [P3383【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)（本题）  
  2. [P1217 回文质数](https://www.luogu.com.cn/problem/P1217)（筛法+回文判断）  
  3. [P1865 A % B Problem](https://www.luogu.com.cn/problem/P1865)（区间素数查询）

---

### **个人心得摘录**

- **调试教训**（学委）  
  > “`i*Prime[j]` 可能溢出，需检查范围”  
  - 总结：大数乘法前需验证 `i <= n/Prime[j]`

- **优化顿悟**（rainygame）  
  > “`bitset` 效率是 `bool[]` 的 3 倍”  
  - 总结：位操作显著提升内存密集型算法性能

---

### **可视化与算法演示**

#### **核心流程动画**
1. **像素风格筛法演示**  
   - **Canvas 网格**：每个像素代表一个数，绿色为质数，红色为合数  
   - **高亮操作**：当前 `i` 用黄色框标记，被筛的 `i*prime[j]` 闪烁红色  
   - **步进控制**：支持暂停/继续，速度调节（1x~10x）

2. **音效设计**  
   - **标记合数**：短促“滴”声  
   - **发现质数**：清脆“叮”声  
   - **完成筛法**：8-bit 胜利旋律

3. **自动演示模式**  
   - **AI 自动运行**：按算法逻辑逐步高亮并标记，配合字幕解释关键步骤  
   - **关卡设计**：  
     - 第1关：埃氏筛（直观但冗余）  
     - 第2关：欧拉筛（线性高效）

#### **交互代码片段**
```javascript
// Canvas 绘制素数网格（伪代码）
function drawGrid() {
  for (let i = 2; i <= n; i++) {
    const x = (i % gridSize) * cellSize;
    const y = Math.floor(i / gridSize) * cellSize;
    ctx.fillStyle = isPrime[i] ? '#00FF00' : '#FF0000';
    ctx.fillRect(x, y, cellSize, cellSize);
  }
}
```

---

**结论**：欧拉筛以理论最优复杂度成为首选，埃氏筛通过位压缩在特定场景更优。预处理+查询分离是解决大规模素数问题的通用范式。

---
处理用时：72.27秒
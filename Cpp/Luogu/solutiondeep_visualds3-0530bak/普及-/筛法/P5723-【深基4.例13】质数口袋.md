# 题目信息

# 【深基4.例13】质数口袋

## 题目描述

小 A 有一个质数口袋，里面可以装各个质数。他从 $2$ 开始，依次判断各个自然数是不是质数，如果是质数就会把这个数字装入口袋。

口袋的负载量就是口袋里的所有数字之和。

但是口袋的承重量有限，装的质数的和不能超过 $L$。给出 $L$，请问口袋里能装下几个质数？将这些质数从小往大输出，然后输出最多能装下的质数的个数，数字之间用换行隔开。

## 说明/提示

数据保证，$1 \le L \le {10}^5$。

## 样例 #1

### 输入

```
100```

### 输出

```
2
3
5
7
11
13
17
19
23
9```

## 样例 #2

### 输入

```
5```

### 输出

```
2
3
2```

## 样例 #3

### 输入

```
11```

### 输出

```
2
3
5
3```

# AI分析结果



---

### 唯一算法分类  
**筛法（埃氏筛/欧拉筛）**

---

### 题解思路与算法要点  
#### 核心逻辑对比  
| 题解方案                | 核心思路                                                                 | 时间复杂度      | 解决难点                     |  
|-------------------------|--------------------------------------------------------------------------|-----------------|-----------------------------|  
| **暴力判断质数**        | 逐个数暴力判断质数，累加直到超过 L                                       | O(n√n)          | 边界条件特判（L<2 的情况） |  
| **埃氏筛预处理质数表** | 预处理 1e5 以内质数表，顺序累加输出                                       | O(n log log n)  | 筛法优化与质数表存储逻辑   |  
| **欧拉筛优化**          | 线性筛法生成质数表，结合前缀和快速判断                                   | O(n)            | 线性筛法的正确性证明       |  

#### 关键变量与步骤  
1. **质数判断函数**：  
   ```cpp  
   bool is_prime(int x) {  
       if (x < 2) return false;  
       for (int i=2; i*i<=x; ++i)  
           if (x%i == 0) return false;  
       return true;  
   }  
   ```  
   - **优化技巧**：提前排除偶数（如 `i%2==0 && i!=2`）  

2. **埃氏筛预处理**：  
   ```cpp  
   bool prime[100007];  
   void sieve() {  
       fill(prime, prime+100007, true);  
       prime[0] = prime[1] = false;  
       for (int i=2; i<=1e5; ++i)  
           if (prime[i])  
               for (int j=i*2; j<=1e5; j+=i)  
                   prime[j] = false;  
   }  
   ```  

3. **累加与边界控制**：  
   ```cpp  
   int sum = 0, cnt = 0;  
   for (int i=2; i<=1e5; ++i) {  
       if (prime[i] && sum+i <= L) {  
           cout << i << endl;  
           sum += i;  
           cnt++;  
       } else if (sum+i > L) break;  
   }  
   ```  

---

### 题解评分（≥4星）  
1. **Eason_AC（4.5星）**  
   - 亮点：埃氏筛预处理质数表，逻辑清晰，代码可读性强  
   - 优化：时间复杂度稳定，适合大数据量  

2. **GaryH（4星）**  
   - 亮点：欧拉筛线性时间复杂度，结合前缀和高效查询  
   - 改进：代码注释较少，可读性稍弱  

3. **Ryo_Yamada（4星）**  
   - 亮点：简洁的埃氏筛实现，边界处理完整  
   - 改进：未使用前缀和优化，需多次遍历质数表  

---

### 最优思路与技巧提炼  
1. **预处理质数表**：埃氏筛/欧拉筛生成质数表，避免重复判断质数。  
2. **边界特判**：L<2 或质数表为空时直接返回 0。  
3. **累加优化**：顺序累加最小质数（2→3→5→...），保证装入数量最大。  

---

### 同类型题与算法套路  
1. **质数累加问题**：预处理质数表 + 贪心累加。  
2. **筛法变种**：结合筛法统计区间质数个数（如 [SPOJ PRIME1](https://www.spoj.com/problems/PRIME1/)）。  

---

### 推荐相似题目  
1. **P3383【模板】线性筛素数**（质数筛法模板）  
2. **P1217 [USACO1.5]回文质数**（质数性质 + 回文判断）  
3. **P1832 A+B Problem（再升级）**（质数判断 + 动态规划）  

---

### 个人心得摘录  
- **封禁用户**：  
  > *“当 L=2 时需单独输出，否则循环不会处理到 i=2 的情况。”*  
  - **总结**：极端值需单独测试，避免逻辑漏洞。  

- **Sea_Level**：  
  > *“暴力法在 1e5 内完全可行，sqrt(x) 优化是关键。”*  
  - **总结**：暴力法在小数据场景下仍有竞争力。  

---

### 算法可视化设计（复古像素风格）  
#### 核心流程演示  
1. **筛法动画**：  
   - **Canvas 网格**：显示 2~100 的数字方块，初始为灰色（未标记）。  
   - **筛法过程**：  
     - 选中质数 i（绿色高亮），标记其倍数（红色闪烁）。  
     - 音效：标记质数时播放“叮”，标记倍数时播放“哒”。  

   ```javascript  
   // 伪代码：埃氏筛动画逻辑  
   function animateSieve() {  
       for (let i=2; i<=100; i++) {  
           if (isPrime[i]) {  
               highlight(i, 'green');  // 高亮质数  
               playSound('ding');  
               for (let j=i*2; j<=100; j+=i) {  
                   highlight(j, 'red');  
                   playSound('click');  
                   isPrime[j] = false;  
               }  
           }  
       }  
   }  
   ```  

2. **质数累加动画**：  
   - **像素风格口袋**：显示累加的质数（像素方块从筛法网格飞入口袋）。  
   - **实时统计**：口袋上方显示当前总和和质数个数，超过 L 时口袋变红闪烁。  

#### 交互设计  
- **步进控制**：支持暂停/继续、单步执行筛法或累加。  
- **8-bit 音效**：使用 [Web Audio API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API) 播放芯片音乐。  
- **积分系统**：每正确累加一个质数得 10 分，错误操作扣 5 分。  

---

### 核心代码实现（埃氏筛 + 累加）  
```cpp  
#include <iostream>  
using namespace std;  

const int MAX_L = 1e5;  
bool isPrime[MAX_L + 1];  

void sieve() {  
    fill(isPrime, isPrime + MAX_L + 1, true);  
    isPrime[0] = isPrime[1] = false;  
    for (int i=2; i*i<=MAX_L; ++i)  
        if (isPrime[i])  
            for (int j=i*i; j<=MAX_L; j+=i)  
                isPrime[j] = false;  
}  

int main() {  
    int L, sum = 0, cnt = 0;  
    cin >> L;  
    sieve();  
    for (int i=2; i<=MAX_L; ++i) {  
        if (isPrime[i] && sum + i <= L) {  
            cout << i << '\n';  
            sum += i;  
            cnt++;  
        } else if (sum + i > L) break;  
    }  
    cout << cnt;  
    return 0;  
}  
```

---
处理用时：76.58秒
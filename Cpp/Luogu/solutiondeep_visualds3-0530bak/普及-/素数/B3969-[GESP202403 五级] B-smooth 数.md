# 题目信息

# [GESP202403 五级] B-smooth 数

## 题目描述

小杨同学想寻找一种名为 $ B $-smooth 数的正整数。 

如果一个正整数的最大质因子不超过 $ B $，则该正整数为 $ B $-smooth 数。小杨同学想知道，对于给定的 $ n $ 和 $ B $，有多少个不超过 $ n $ 的 $ B $-smooth 数。

## 说明/提示

### 数据规模与约定

| 子任务 | 得分 | $n \leq $ | $B$ |
| :-: | :-: | :-: | :-: |
| $1$ | $30$ | $10^3$ | $1 \leq B \leq 10^3$ |
| $2$ | $30$ | $10^6$ | $\sqrt n \leq B \leq 10^6$ |
| $3$ | $40$ | $10^6$ | $1 \leq B \leq 10^6$ | 

对全部的测试数据，保证 $1 \leq n, B \leq 10^6$。

## 样例 #1

### 输入

```
10 3```

### 输出

```
7```

# AI分析结果



**唯一算法分类**：埃氏筛法的应用（预处理最大质因子）

---

### **题解思路与解决难点**

1. **核心思路**：预处理每个数的最大质因子，统计不超过B的数量。
   - **关键点**：利用埃氏筛法，对于每个质数i，遍历其倍数j，将j的最大质因子更新为i。由于i从小到大遍历，最终每个j的最大质因子为最大的那个质数i。
   - **数据结构**：数组存储每个数的最大质因子。
   - **优化**：筛法预处理的时间复杂度为O(n log log n)，适合n ≤ 1e6的数据规模。

2. **难点对比**：
   - **暴力分解质因数**（如spfa_的题解）：时间复杂度O(n√n)，无法通过n=1e6的极限测试。
   - **反向标记法**（如Mier_Samuelle的题解）：需枚举所有大于B的质数及其倍数，复杂度依赖B的大小，B较小时高效，B较大时可能更慢。
   - **线性筛预处理最小质因子**（如zhc20170619的题解）：分解时需多次除法，平均时间复杂度O(n log n)，略低于埃氏筛法。

---

### **题解评分（≥4星）**

1. **Little_x_starTYJ（5星）**  
   - **亮点**：代码简洁，高效筛法预处理，时间复杂度最优。
   - **代码片段**：
     ```cpp
     for (int i = 2; i <= n; i++) {
         if (!a[i]) { // i是质数
             for (int j = i; j <= n; j += i)
                 a[j] = i; // 更新j的最大质因子为i
         }
     }
     ```

2. **dlzlj_2010（4星）**  
   - **亮点**：与第一题解思路一致，变量命名清晰，注释明确。
   - **代码片段**：
     ```cpp
     for (int i = 2; i <= n; i++) {
         if (!mp[i]) { // 质数处理
             mp[i] = i;
             for (int j = 2; i*j <= n; j++)
                 mp[i*j] = i;
         }
     }
     ```

3. **xzz_0611（4星）**  
   - **亮点**：代码极简，无冗余逻辑，直接应用筛法。
   - **代码片段**：
     ```cpp
     for (int i=2;i<=n;++i) 
         if (!Max[i]) 
             for (int j=i;j<=n;j+=i) 
                 Max[j]=i;
     ```

---

### **最优思路提炼**

- **核心技巧**：埃氏筛法预处理最大质因子。
  - **实现关键**：从小到大遍历质数i，每次更新其倍数j的最大质因子为i。
  - **正确性保证**：较大的质数会覆盖较小质数的影响，确保最终保存的是最大质因子。

---

### **同类型题与算法套路**

- **相似问题**：统计数的质因子、最小质因子、欧拉函数计算。
- **通用套路**：筛法预处理数论属性（如质因子、约数个数），适用于需要频繁查询数论性质的问题。

---

### **推荐题目**

1. **P3383 【模板】线性筛素数**  
   （练习筛法基础）
2. **P2424 约数和**  
   （质因数分解与数论函数）
3. **P1075 质因数分解**  
   （求最大质因子的直接应用）

---

### **个人心得摘录**

- **Little_x_starTYJ**：通过筛法的覆盖性质，自然记录最大质因子。
- **Mier_Samuelle**：反向排除法思路，强调逆向思维在数论问题中的灵活应用。

---

### **可视化与算法演示**

1. **动画设计**：
   - **筛法过程**：用网格表示1~n的数组，质数i以绿色高亮，其倍数j被红色标记并更新Max[j]为i。
   - **步进控制**：可调节速度观察i从2到n的遍历，单步执行观察倍数更新。
   - **颜色标记**：当前质数i显示为绿色，被更新的数j显示为红色，更新后恢复。

2. **复古像素风格**：
   - **像素方块**：每个数以8x8像素块表示，质数i的方块闪烁，其倍数方块短暂变红。
   - **音效**：质数发现时播放“滴”声，倍数更新时播放短促“哒”声。
   - **自动演示**：AI模式自动运行筛法，逐步展示最大质因子的覆盖过程。

---

### **核心代码实现**

```cpp
#include <iostream>
using namespace std;
const int N = 1e6 + 5;
int max_prime[N];

int main() {
    int n, b, ans = 0;
    cin >> n >> b;
    for (int i = 2; i <= n; ++i) {
        if (!max_prime[i]) { // i是质数
            for (int j = i; j <= n; j += i) {
                max_prime[j] = i; // 更新j的最大质因子
            }
        }
    }
    for (int i = 1; i <= n; ++i) {
        ans += (max_prime[i] <= b || i == 1); // 1的特殊处理
    }
    cout << ans;
    return 0;
}
```

---
处理用时：83.02秒
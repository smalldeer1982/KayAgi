# 题目信息

# [信息与未来 2014] 连续非素数子序列的最大长度

## 题目描述

给出一个正整数 $n$，求在数列 $\{2,3,\cdots,n\}$
中，连续非素数子序列的最大长度。

## 说明/提示

### 样例 $\textbf1$ 解释
| 连续非素数子序列 | 长度 |
| :----------: | :----------: |
| $\{4\}$ | $1$ |
| $\{6\}$ | $1$ |
| $\{8,9,10\}$ | $3$ |
| $\{12\}$ | $1$ |

其中，最大长度为 $3$，即有连续的 $3$ 个非素数。
### 数据范围
$2\le n\le 5\times10^6$。

## 样例 #1

### 输入

```
12```

### 输出

```
3```

## 样例 #2

### 输入

```
30```

### 输出

```
5```

# AI分析结果



## 唯一算法分类  
筛法求素数

---

## 综合分析与结论  

### 核心算法流程  
1. **素数预处理**：使用埃拉托斯特尼筛法生成所有非素数标记  
2. **滑动窗口统计**：遍历标记数组，统计最长连续非素数段长度  

### 解决难点  
- **高数据范围**：n 最大为 5e6，需用 O(n log log n) 的筛法  
- **边界处理**：筛法需正确处理 2~n 的标记，遍历时需处理数组起点和终点的连续段  

### 可视化设计  
- **筛法过程**：用 Canvas 网格展示每个数被标记为非素数的过程，红色方块表示合数，绿色表示素数  
- **滑动窗口**：高亮当前遍历的连续非素数段，动态更新最大长度计数器  
- **复古风格**：采用 8-bit 像素字体，背景音乐为《超级马里奥》风格的循环旋律，标记合数时播放“叮”音效  

---

## 最优思路或技巧提炼  

### 关键优化  
- **筛法优化**：外层循环仅需遍历到 sqrt(n)，内层从 i² 开始标记  
- **单次遍历统计**：在遍历非素数标记数组时维护当前连续长度，避免二次遍历  

### 代码实现要点  
```cpp
int maxNonPrimeLength(int n) {
    vector<bool> is_prime(n + 1, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i * i <= n; ++i) {
        if (is_prime[i]) {
            for (int j = i * i; j <= n; j += i) {
                is_prime[j] = false;
            }
        }
    }
    
    int max_len = 0, current = 0;
    for (int i = 2; i <= n; ++i) {
        if (!is_prime[i]) current++;
        else current = 0;
        max_len = max(max_len, current);
    }
    return max_len;
}
```

---

## 同类型题与算法套路  

### 通用解法  
- **素数区间问题**：预处理素数后结合滑动窗口/前缀和统计区间特性  
- **连续子序列统计**：维护当前状态（如连续长度）的单次遍历算法  

### 推荐题目  
1. P3383 【模板】线性筛素数  
2. P3912 素数个数（统计 1~n 的素数个数）  
3. P1835 素数密度（区间筛法）  

---

## 可视化与复古游戏化设计  

### 动画方案  
1. **筛法阶段**：  
   - 每个数初始为绿色方块，i=2 时开始扫描  
   - 当标记 j 为合数时，j 的方块变为红色并播放“点击”音效  

2. **统计阶段**：  
   - 黄色光标从左到右扫描，遇到红色方块时下方显示当前连续长度  
   - 最大长度计数器在画面上方以像素数字实时更新  

### 游戏化交互  
- **自动演示模式**：按空格键切换自动/手动步进  
- **音效设计**：  
  - 标记合数：8-bit 短音（频率 800Hz，时长 50ms）  
  - 更新最大值：上升音阶（C4→E4→G4）  
- **积分系统**：每正确标记 100 个合数得 10 分，显示在右上角  

---

## 个人心得摘录  
> "第一次提交时忘记筛法中 i 的循环终止条件是 i*i <=n，导致标记不完全。通过打印小样例的标记数组发现了问题。"  
> "统计连续长度时，初始将 current 和 max_len 都设为 0，但发现当 n=4 时输出应为 1，但初始逻辑在 i=2（素数）时 current 被重置为 0。修正为从 i=2 开始遍历即可。"  

---

## 完整代码实现  
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<bool> is_prime(n + 1, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i * i <= n; ++i) {
        if (is_prime[i]) {
            for (int j = i * i; j <= n; j += i) {
                is_prime[j] = false;
            }
        }
    }
    
    int max_len = 0, current = 0;
    for (int i = 2; i <= n; ++i) {
        if (!is_prime[i]) {
            ++current;
            max_len = max(max_len, current);
        } else {
            current = 0;
        }
    }
    cout << max_len << endl;
    return 0;
}
```

---
处理用时：60.72秒
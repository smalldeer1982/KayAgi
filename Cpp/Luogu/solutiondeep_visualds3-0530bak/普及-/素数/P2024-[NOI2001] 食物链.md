# 题目信息

# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# AI分析结果



# [NOI2001] 食物链 题解分析

## 算法分类
**种类并查集**（扩展域并查集）

---

## 题解思路与核心难点

### 核心思路
1. **环形关系建模**：三种动物构成环形捕食关系（A→B→C→A）
2. **扩展域技巧**：将每个动物拆分为三个角色（同类域、猎物域、天敌域）
3. **合并规则**：
   - 同类关系：合并三个域的集合
   - 捕食关系：交叉合并猎物域与同类域，天敌域与猎物域等

### 关键难点对比

| 方法类型        | 空间复杂度 | 实现难度 | 核心处理逻辑                                                                 |
|-----------------|------------|----------|-----------------------------------------------------------------------------|
| **扩展域并查集** | O(3N)      | 中       | 通过三个域的集合合并维护关系，合并规则直观但需要同时处理多个集合            |
| **带权并查集**   | O(N)       | 高       | 通过权值（0/1/2）表示关系，路径压缩时需维护权值传递公式，数学推导要求较高   |

---

## 题解评分（≥4星）

1. **Sooke（★★★★★）**
   - **亮点**：使用三倍并查集结构，图文并茂解释合并逻辑
   - **代码**：清晰处理三种域的合并，边界条件处理完善
   ```cpp
   // 同类合并示例
   fa[find(x)] = find(y);
   fa[find(x+n)] = find(y+n);
   fa[find(x+2n)] = find(y+2n);
   ```

2. **檀黎斗·神（★★★★☆）**
   - **亮点**：代码简洁，注释明确猎物与天敌的维护逻辑
   - **技巧**：通过三倍数组直接表示三种状态，逻辑直接
   ```cpp
   // 捕食关系合并
   fa[find(x+n)] = find(y);
   fa[find(y+2n)] = find(x);
   ```

3. **天泽龟（★★★★☆）**
   - **亮点**：带权并查集推导权值传递公式
   - **公式**：`rela = (d[x] - d[y] + 3) % 3` 判断捕食关系

---

## 最优思路提炼

### 扩展域实现步骤
1. **三倍数组划分**：
   - `1~N`：同类域
   - `N+1~2N`：猎物域
   - `2N+1~3N`：天敌域
2. **合并规则**：
   ```text
   当 X 与 Y 同类：
     合并 X.同类 ↔ Y.同类
     合并 X.猎物 ↔ Y.猎物
     合并 X.天敌 ↔ Y.天敌

   当 X 吃 Y：
     合并 X.猎物 ↔ Y.同类
     合并 X.天敌 ↔ Y.猎物
     合并 X.同类 ↔ Y.天敌
   ```

### 带权并查集公式
- **权值计算**：路径压缩时维护 `rank[x] = (原权值 + 父节点权值) % 3`
- **关系判定**：
  - `(rank[x] - rank[y]) % 3 == 0` → 同类
  - `(rank[x] - rank[y] + 1) % 3 == 0` → 捕食

---

## 同类型题目推荐
1. **P1525 关押罪犯**（二分图+并查集）
2. **P1892 团伙**（扩展域处理敌对关系）
3. **P1955 程序自动分析**（并查集+离散化）

---

## 可视化算法演示

### 动画设计
1. **元素展示**：
   - **三色节点**：红（同类域）、绿（猎物域）、蓝（天敌域）
   - **动态连线**：合并时高亮对应域的连接线
2. **关键操作演示**：
   ```python
   # 伪代码示例：捕食关系合并
   def merge_eat(x, y):
       highlight(x.green, y.red)    # X的猎物域连接Y的同类域
       highlight(x.blue, y.green)   # X的天敌域连接Y的猎物域
       highlight(x.red, y.blue)     # X的同类域连接Y的天敌域
       play_sound("link_success.wav")
   ```

### 复古像素风格
- **8-bit 音效**：
  - 正确合并：8-bit "ping" 音
  - 冲突判定：低音警报声
- **Canvas动画**：
  - 节点以16x16像素方块呈现
  - 合并时显示彩色粒子效果

---

## 核心代码片段（扩展域）
```cpp
const int MAXN = 5e4 * 3 + 10;
int fa[MAXN];

// 初始化三倍并查集
void init() {
    for(int i=1; i<=3*n; i++) fa[i] = i;
}

// 查询+路径压缩
int find(int x) {
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}

// 处理声明1：X与Y同类
void handle_same(int x, int y) {
    if(find(x) == find(y+n) || find(x) == find(y+2*n)) {
        ans++; // 存在捕食/被捕食关系，矛盾
        return;
    }
    // 合并三个域
    fa[find(x)] = find(y);
    fa[find(x+n)] = find(y+n);
    fa[find(x+2*n)] = find(y+2*n);
}
```

---

## 总结
**扩展域并查集**通过空间换直观性，适合逻辑清晰但代码量稍大的场景；**带权并查集**数学要求高但空间高效。理解环形关系建模是关键，推荐从扩展域入手再进阶带权实现。

---
处理用时：73.13秒
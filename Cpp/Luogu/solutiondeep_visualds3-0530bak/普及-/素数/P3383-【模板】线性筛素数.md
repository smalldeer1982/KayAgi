# 题目信息

# 【模板】线性筛素数

## 题目背景

本题已更新，从判断素数改为了查询第 $k$ 小的素数。  

提示：本题输入输出、运算数据量较大。

- 对于 C++ 语言，如果你使用 `cin` 来输入输出，建议使用 `std::ios::sync_with_stdio(0)` 来加速，同时使用 `'\n'` 换行输出。
- 对于 Java 语言，使用线性筛并且优化输入输出，也可以在规定时限内通过本题，但是时限可能较紧张。
- 对于 Python 语言，语言性能差异较大，需要使用到 `numpy` 库的数组以替代列表，且使用埃氏筛法，依然可以在合适的时间和内存消耗下通过本题。

## 题目描述

如题，给定一个范围 $n$，有 $q$ 个询问，每次输出第 $k$ 小的素数。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$n = 10^8$，$1 \le q \le 10^6$，保证查询的素数不大于 $n$。

Data by NaCly\_Fish.


## 样例 #1

### 输入

```
100 5
1
2
3
4
5```

### 输出

```
2
3
5
7
11```

# AI分析结果



# 算法分类  
**线性筛法（欧拉筛）**

---

## 综合分析与结论  
### 核心算法逻辑  
1. **算法核心思想**：每个合数仅被其最小质因数筛除  
   - 外层循环遍历所有数 `i`，内层循环遍历已筛出的质数 `prime[j]`  
   - 当 `i % prime[j] == 0` 时跳出循环，避免重复筛除  
2. **正确性保障**：  
   - 合数 `C = i * prime[j]` 的最小质因数为 `prime[j]`，保证 `i` 的质因数不小于 `prime[j]`  
   - 每个合数仅被其最小质因数标记一次  
3. **复杂度优化**：  
   - 时间复杂度严格为 **O(n)**，空间复杂度 **O(n)**  

### 题解对比与亮点  
| 题解作者       | 优化手段                                                                 | 评分（⭐） |  
|----------------|--------------------------------------------------------------------------|-----------|  
| 学委           | 详细数学证明 + C++线性筛模板代码                                        | ⭐⭐⭐⭐⭐    |  
| rainygame      | 埃氏筛 + `bitset`优化（内存降为 `n/8`，时间效率提升2倍）                 | ⭐⭐⭐⭐     |  
| 溶金落梧桐     | Java版欧拉筛 + `BitSet`优化 + 素数定理动态分配数组                       | ⭐⭐⭐⭐     |  

---

## 最优思路与技巧提炼  
### 核心技巧  
1. **线性筛的终止条件**  
   ```cpp  
   if (i % prime[j] == 0) break;  
   ```  
   - **作用**：保证 `prime[j]` 是 `i` 的最小质因数，避免后续重复筛除  
   - **数学证明**：若 `i` 含 `prime[j]`，则 `i*prime[k] (k>j)` 的最小质因数必为 `prime[j]`  

2. **埃氏筛优化三连**  
   ```python  
   is_prime[4::2] = False             # 预筛偶数  
   for i in range(3, sqrt_n+1, 2):    # 仅遍历奇数  
       if is_prime[i]:  
           is_prime[i*i::i+i] = False # 步长2i优化  
   ```  
   - 时间复杂度：**O(n log log n)**，但常数显著低于未优化版本  

3. **内存压缩技巧**  
   - C++：`bitset<1e8+10>` 代替 `bool[]`（内存占用从 100MB → 12.5MB）  
   - Python：`numpy.bool_[]` 替代原生列表（内存降为 `1/8`）  

---

## 同类型题与推荐题目  
### 相似算法套路  
1. **质因数分解预处理**（如统计区间内数的质因数个数）  
2. **最小质因数标记**（如快速求取任意数的质因数分解式）  

### 推荐题目  
1. [P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)（本题模板）  
2. [P1217 回文质数](https://www.luogu.com.cn/problem/P1217)（筛法+回文判断）  
3. [P3912 素数个数](https://www.luogu.com.cn/problem/P3912)（大范围素数计数）  

---

## 可视化与算法演示  
### 动画设计方案  
1. **像素风格动态演示**  
   - **数据结构**：  
     - 用 **8x8 像素块**表示每个数，绿色为质数，红色为合数  
     - 高亮当前外层循环的 `i`（黄色边框）和当前质数 `prime[j]`（蓝色边框）  
   - **关键帧逻辑**：  
     ```text  
     帧1: i=2 → 标记为质数（绿），筛除4,6,8...（红）  
     帧2: i=3 → 标记为质数，筛除9,15,21...  
     帧3: i=4 → 跳过（已被筛为红），筛除8（但已红）  
     ```  
   - **交互设计**：  
     - 支持 **空格键暂停/继续**，方向键 **←/→** 单步前进/后退  
     - 右下角显示当前操作说明（如"筛除 3×5=15"）  

2. **音效与反馈**  
   - `i` 移动：短促电子音（频率随 `i` 增大升高）  
   - 标记质数：清脆“金币”音效  
   - 筛除合数：低沉“爆炸”音效  

---

## 核心代码实现  
### 线性筛（C++，学委版）  
```cpp  
void GetPrime(int n) {  
    memset(isPrime, 1, sizeof(isPrime));  
    isPrime[1] = 0;  
    for (int i=2; i<=n; i++) {  
        if (isPrime[i]) Prime[++cnt] = i;  
        for (int j=1; j<=cnt && i*Prime[j]<=n; j++) {  
            isPrime[i*Prime[j]] = 0;  
            if (i % Prime[j] == 0) break;  
        }  
    }  
}  
```  

### 埃氏筛优化（Python，Fish_egg_版）  
```python  
isprime = numpy.ones(n>>1, dtype=bool)  
isprime[0] = False  
for i in range(1, int(n**0.5)//2 +1):  
    if isprime[i]:  
        isprime[i*(i+1)*2::i*2+1] = False  
prime = numpy.concatenate([numpy.array([2,3]), numpy.nonzero(isprime)[0][1:]*2+1])  
```  

---

## 个人心得摘录  
> **学委**：  
> “外层循环的 `i` 在接近 `n` 时几乎不做事，但前期可能单次筛除大量合数。不要被局部耗时迷惑，整体复杂度严格线性！”  
>   
> **rainygame**：  
> “`bitset` 的内存优化让埃氏筛在 1e8 数据量下仍可运行，但需注意缓存不友好问题。”  

---

## 可视化代码片段（JavaScript伪代码）  
```javascript  
function drawAnimation() {  
  ctx.fillStyle = '#2C3E50';  
  ctx.fillRect(0, 0, canvas.width, canvas.height); // 暗色背景  
  
  // 绘制数字网格  
  for (let num = 2; num <= maxNum; num++) {  
    const color = isPrime[num] ? '#2ECC71' : '#E74C3C';  
    drawPixel(num, color);  
  }  
  
  // 高亮当前操作  
  if (currentI > 0) {  
    highlightNumber(currentI, '#F1C40F'); // i 黄色边框  
    if (currentPrimeJ > 0) {  
      highlightNumber(primes[currentPrimeJ], '#3498DB'); // prime[j] 蓝色  
      const composite = currentI * primes[currentPrimeJ];  
      highlightNumber(composite, '#E67E22'); // 被筛数橙色  
    }  
  }  
}  
```

---
处理用时：79.18秒
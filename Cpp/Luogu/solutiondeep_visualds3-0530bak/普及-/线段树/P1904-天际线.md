# 题目信息

# 天际线

## 题目描述

Latium 省的 Genoa 是亚平宁半岛西海岸北端的一片土地，自然资源丰富，却无人居住。你受到罗马执政官 Caesar 的委任，前往 Genoa 建立新的城市。Caesar 对这次任务的要求是在 Genoa 这片土地上建立起一座繁荣的城市，他将以此作为衡量你的表现的标准。

正在你大刀阔斧地进行城市建设的时候，Caesar 突然写信给你，说他要检查 Genoa 的建设情况。Caesar 希望知道你的城市是什么样子，但是他又非常的忙，所以他只要你描述一下城市的轮廓就可以了，他将依照城市的轮廓决定你的薪水。

怎样描述一个城市的轮廓呢？我们知道 Genoa 所有的建筑共享一个地面，你可以认为它是水平的。所有的建筑用一个三元组 $(L_i,H_i,R_i)$，其中 $L_i$ 和 $R_i$ 分别是建筑的左坐标和右坐标，$H_i$ 就是建筑的高度。在下方所示的图表中左边建筑物描述如下 $(1,11,5)$，$(2,6,7)$，$(3,13,9)$，$(12,7,16)$，$(14,3,25)$，$(19,18,22)$，$(23,13,29)$，$(24,4,28)$，右边用轮廓线的顺序$(1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0)$ 表示：

![](https://cdn.luogu.com.cn/upload/image_hosting/oe7wpwsi.png)


## 样例 #1

### 输入

```
1 11 5
2 6 7
3 13 9
12 7 16
14 3 25
19 18 22
23 13 29
24 4 28
```

### 输出

```
1 11 3 13 9 0 12 7 16 3 19 18 22 3 23 13 29 0```

# AI分析结果



# 天际线问题分析与题解总结

## 算法分类
扫描线算法 + 优先队列（事件驱动）

## 题解思路与解决难点
### 核心思路
将每个建筑的左右端点转化为事件，按坐标排序后依次处理。维护当前有效建筑的最大高度，通过优先队列动态管理高度，遇到高度变化时记录转折点。

### 解决难点
1. **事件排序**：确保左端点事件先于右端点事件处理（相同x时），避免同一坐标点插入与删除冲突。
2. **延迟删除**：堆无法直接删除元素，需在处理时弹出过期元素（右端点≤当前x的堆顶元素）。
3. **转折点检测**：每次处理事件后检查堆顶高度是否变化，记录变化点。

## 题解评分（≥4星）
1. **InchTree的暴力法**（4星）
   - 亮点：代码简洁，巧妙处理区间为左闭右开避免间隙问题。
   - 缺点：时间复杂度高，仅适用于小数据。

2. **haoyun1的优先队列法**（5星）
   - 亮点：事件驱动思路清晰，利用堆维护最大高度，时间复杂度O(n log n)。
   - 关键代码：事件排序与堆的延迟删除处理。

3. **big_news的扫描线+线段树**（4.5星）
   - 亮点：高效处理大范围数据，离散化优化空间。
   - 缺点：实现复杂，需处理线段树细节。

## 最优思路与技巧提炼
**优先队列事件驱动法**：
1. **事件拆分**：每个建筑拆分为左端点（插入高度）和右端点（标记删除）。
2. **事件排序**：按x排序，x相同时优先处理插入事件。
3. **堆维护**：用最大堆存储活跃高度，处理事件后清理过期堆顶元素。
4. **转折记录**：堆顶高度变化时输出转折点。

示例代码（haoyun1思路）：
```cpp
#include <cstdio>
#include <queue>
#include <algorithm>
using namespace std;

struct Event {
    int x, h, is_end;
    bool operator<(const Event &e) const {
        return x == e.x ? is_end < e.is_end : x < e.x;
    }
};

int main() {
    vector<Event> events;
    int l, h, r;
    while (scanf("%d%d%d", &l, &h, &r) != EOF) {
        events.push_back({l, h, 0});
        events.push_back({r, h, 1});
    }
    sort(events.begin(), events.end());
    
    priority_queue<pair<int, int>> pq; // 最大堆存储（高度，右端点）
    int last_h = 0;
    vector<int> ans;
    
    for (auto &e : events) {
        if (!e.is_end) {
            pq.push({e.h, e.x}); // 插入事件：高度和右端点
        }
        // 处理删除事件：延迟删除，不直接操作堆
        
        // 清理过期堆顶元素
        while (!pq.empty() && pq.top().second <= e.x) {
            pq.pop();
        }
        
        int curr_h = pq.empty() ? 0 : pq.top().first;
        if (curr_h != last_h) {
            ans.push_back(e.x);
            ans.push_back(curr_h);
            last_h = curr_h;
        }
    }
    
    // 输出结果
    for (size_t i = 0; i < ans.size(); ++i) {
        printf("%d", ans[i]);
        if (i != ans.size() - 1) putchar(' ');
    }
    return 0;
}
```

## 同类型题与套路
- **UVA105 The Skyline Problem**：同一问题，可复用优先队列法。
- **LeetCode 218. The Skyline Problem**：扩展版，需处理更复杂输入。
- **区间覆盖最值问题**：如广告牌最大覆盖、会议室安排等。

## 可视化与算法演示
**动画设计**：
1. **事件队列流动**：左侧显示待处理事件队列，右侧为当前堆状态。
2. **堆动态更新**：插入事件时绿色块入堆，删除事件时红色标记。
3. **转折点生成**：高度变化时在坐标轴上方显示转折点，伴随音效。

**复古像素风格**：
- **8位色块**：事件用绿/红像素表示，堆高度用渐变色块。
- **音效**：插入（升调）、删除（降调）、转折（叮咚声）。
- **自动演示**：按事件顺序逐步执行，速度可调，显示当前x与堆顶高度。

## 推荐题目
1. **洛谷P1884 [USACO12FEB]Overplanting S**（矩形面积并）
2. **洛谷P5490 【模板】扫描线**（线段树应用）
3. **洛谷P2161 [SHOI2009]会场预约**（区间调度与维护）

通过事件驱动与优先队列的结合，可高效解决各类区间最值问题，核心在于正确处理事件顺序与动态维护状态。

---
处理用时：140.33秒
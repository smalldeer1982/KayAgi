# 题目信息

# 在你窗外闪耀的星星

## 题目背景

飞逝的的时光不会模糊我对你的记忆。难以相信从我第一次见到你以来已经过去了 3 年。我仍然还生动地记得，3 年前，在美丽的集美中学，从我看到你微笑着走出教室，你将头向后仰，柔和的晚霞照耀着你玫瑰色的脸颊。我明白，我已经沉醉于你了。之后，经过几个月的观察和窥探，你的优雅与智慧，你对待生活的态度和你对未来的愿望深切地在我心中留下了印象。你是迷人的阳光女孩，我总是梦想着与你分享余生。唉，实际上你远远超过了我最疯狂的梦想。我不知道如何桥起我与你之间的鸿沟。所以我没有任何计划，仅仅只是等待，等待一个适当的机会到来。直到现在，毕业的到来，我意识到我是个傻瓜，我应该创造机会并且抓住它而不只是等待。


这些日子里，我和我的朋友、室友、同学一个接一个地分开。我仍无法相信，在挥手之后，这些熟悉的面孔很快就会从我们的生活中消失，仅仅留下回忆。我明天就将离开学校。你已经计划远走高飞，追求你的未来，实现你的梦想。如果没有命运，也许我们不会再次相遇。所以今晚，我正在你的宿舍楼下徘徊，希望能偶然遇见你。但矛盾的是，你的美貌一定会使我心跳加速，我笨拙的舌头也许无法吐出一个字。我不记得我曾多少次经过你的宿舍楼，每次都希望看到你出现在阳台上或是窗台上。我不记得这个想法曾多少次在我的脑海中涌出：打电话叫她一起吃晚饭或是聊聊天。但每次，考虑到你的优秀和我的平凡，胆怯的优势超越勇气驱使我静静地离开。


毕业，意味着中学生活的终结。这些光荣与浪漫的时代结束。你可爱的微笑是我原来努力学习的动力，这单相思的爱情会被密封，作为一个我心灵深处的记忆。毕业，也意味着新生活的开始，一个到达光明未来的足迹。我真希望你在国外天天开心，一切顺利。同时，我将努力从幼稚中走出来，变得更加成熟。我的理想将是在现实中追求我的爱与幸福，我永远不会放弃。


再见了，我的公主！


如果有一天，在某个天涯海角，我们有机会相聚，即使是白发苍苍的男人和女人，在那个时候，我希望我们可以成为好朋友来自豪地分享这个记忆，重温年轻快乐的激情。如果这个机会永远没有到来，我希望我是天空中的星星，在你的窗外闪烁。远远地保佑着你，就像一个朋友，每天晚上陪伴在你左右，一同分享甜美的梦亦或是一同经历可怕的梦。

## 题目描述

现在问题来了：天空可以理解为一条数轴，在这条数轴上分布着许多颗星星，对于每颗星星都有它的位置 $X_i$ 和自身的亮度 $B_i$。**一个位置可能有多颗星星**。而窗户所能看到的范围是一个给出的参数 $W$，我们看到的星星也包括窗户边缘的星星。现在，要你求出调整窗户位置后能看到星星的亮度之和最大值。


## 说明/提示

样例说明：


 ![](https://cdn.luogu.com.cn/upload/pic/3818.png) 

对于 $10\%$ 的数据，$W=0$（没有边缘）；

对于 $40\%$ 的数据，$W\leq 1000$；

对于 $100\%$ 的数据，$1 \leq N\leq 10 ^ 5$，$0 \leq W\leq 10 ^ 5$，$1 \leq X_i\leq 10 ^ 5$，$1\leq B_i\leq 100$。

除 $W=0$ 的情况外，$W$ 均为 $\geq 3$ 的奇数。


## 样例 #1

### 输入

```
6 3
1 2
2 4
3 8
4 4
5 2
1000 1```

### 输出

```
16```

# AI分析结果



## 算法分类
**前缀和/滑动窗口**

---

## 题解思路与解决难点

### 核心算法逻辑
1. **预处理亮度累加**：将同一位置的星星亮度累加，得到每个坐标点的总亮度数组 `brightness[x]`
2. **前缀和数组构建**：计算 `pre_sum[i] = pre_sum[i-1] + brightness[i]`
3. **滑动窗口求最大值**：遍历所有可能的窗口右端点 `r`，计算区间和 `pre_sum[r] - pre_sum[r-W]`

### 关键难点对比
- **树状数组/线段树**：需维护动态区间和查询，代码复杂度较高（O(n log n)）
- **双指针法**：需排序坐标且维护窗口逻辑，适合离散点但效率略低（O(n log n)）
- **前缀和**：直接利用数组下标快速定位，时间复杂度最优（O(n)）

### 算法优化点
- **坐标压缩**：直接使用坐标作为数组下标，避免离散化
- **窗口边界处理**：当 `W=0` 时直接特判返回 0
- **内存优化**：仅需一维数组存储亮度和前缀和

---

## 题解评分（≥4星）

### 1. [用户 Dog_Two] ⭐⭐⭐⭐⭐（5星）
- **亮点**：代码极简，仅 20 行实现核心逻辑，直接处理累加和滑动窗口
- **关键代码**：
```cpp
for(int i=1; i<=pos; ++i) ans = max(ans, sum += a[i] - (i>w ? a[i-w] : 0));
```

### 2. [用户 xzjds] ⭐⭐⭐⭐（4星）
- **亮点**：完整展示错误修正过程，强调同一位置累加的重要性
- **调试心得**："原以为直接赋值导致 WA，后改为 += 操作解决重点问题"

### 3. [用户 Lates] ⭐⭐⭐⭐（4星）
- **亮点**：双指针法的清晰实现，适合理解滑动窗口本质
- **关键代码**：
```cpp
while(r<=n && a[r].x - a[l].x <= W-1) sum += a[r++].b;
ans = max(ans, sum - (a[r-1].x - a[l].x > W-1 ? a[l++].b : 0));
```

---

## 最优思路提炼

### 关键技巧
1. **亮度聚合**：使用数组直接累加同一坐标的亮度
   ```cpp
   brightness[x] += b; // 处理重复坐标
   ```
2. **窗口滑动的数学表达**：
   ```cpp
   max_sum = max(max_sum, pre_sum[r] - pre_sum[r-W]);
   ```
3. **空间换时间**：通过预计算前缀和将区间查询复杂度降至 O(1)

### 思维突破点
- **数轴的连续特性**：允许直接使用坐标作为数组索引
- **窗口固定长度**：转化为数学上的差分问题，避免复杂数据结构

---

## 同类型题推荐
1. [P1614 爱与愁的心痛](https://www.luogu.com.cn/problem/P1614)（同款滑动窗口）
2. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)（二维前缀和扩展）
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)（单调队列经典）

---

## 可视化算法演示

### 动画设计
1. **数轴绘制**：使用 Canvas 绘制数轴，坐标点用像素方块表示亮度
   ```javascript
   ctx.fillStyle = '#FFD700'; // 金色表示星星
   ctx.fillRect(x*scale, 0, 3, brightness[x]*5); // 高度映射亮度
   ```
2. **滑动窗口高亮**：红色半透明矩形覆盖当前窗口
   ```javascript
   ctx.fillStyle = 'rgba(255,0,0,0.3)';
   ctx.fillRect(current_r*scale - W*scale, 0, W*scale, canvas.height);
   ```
3. **实时数据展示**：
   - 当前窗口和：`sum = ${current_sum}`
   - 历史最大值：`max = ${max_sum}`

### 复古特效
- **音效设计**：
  - 窗口滑动：8-bit "blip" 音效（Web Audio API 生成）
  - 刷新最大值：超级马里奥金币音效片段
- **像素风格**：
  ```css
  canvas {
    image-rendering: pixelated;
    border: 2px solid #6b8cff; /* FC 风格蓝色边框 */
  }
  ```

### 交互功能
- **速度控制**：滑块调节动画速度（100ms~1000ms）
- **单步执行**：按钮逐帧观察窗口移动
- **AI自动模式**：自动以最优路径滑动窗口，配合音效增强节奏感

---

## 核心代码实现

### 前缀和解法（最优）
```cpp
#include <iostream>
using namespace std;
const int MAXN = 1e5+5;

int main() {
    int n, W, x, b, max_x = 0, sum = 0, ans = 0;
    int brightness[MAXN] = {0};
    
    cin >> n >> W;
    for(int i=0; i<n; ++i) {
        cin >> x >> b;
        brightness[x] += b;
        max_x = max(max_x, x);
    }
    
    // 滑动窗口初始化
    for(int i=1; i<=W && i<=max_x; ++i) 
        sum += brightness[i];
    ans = sum;
    
    // 滑动过程
    for(int i=W+1; i<=max_x; ++i) {
        sum += brightness[i] - brightness[i-W];
        ans = max(ans, sum);
    }
    
    cout << ans;
    return 0;
}
```

---

## 总结启示
1. **预处理的艺术**：通过预处理将复杂问题转化为简单数学计算
2. **空间换时间的权衡**：当数据范围可控时，大胆使用数组直接映射
3. **问题抽象能力**：将数轴窗口问题转化为差分模型，避免陷入数据结构选择的纠结

---
处理用时：97.60秒
# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果



### 算法分类  
拓扑排序 + 动态规划

---

### 题解思路与算法要点  
#### 核心逻辑分析  
题目本质是求**DAG上每个节点的最长路径**。所有题解均围绕以下两点展开：  
1. **拓扑序保证无后效性**：按拓扑序处理节点，确保处理当前节点时所有前驱节点的最长路径已确定。  
2. **动态规划递推公式**：`dp[v] = max(dp[v], dp[u] + 1)`，其中u是v的前驱节点。

#### 关键实现差异对比  
| 方法                | 数据结构           | 时间复杂度 | 空间复杂度 | 难点解决思路                     |  
|---------------------|-------------------|------------|------------|--------------------------------|  
| 拓扑排序+正向DP     | 邻接表+队列       | O(N+M)     | O(N+M)     | 显式拓扑排序保证节点处理顺序    |  
| 拓扑排序+即时DP更新 | 邻接表+队列       | O(N+M)     | O(N+M)     | 合并拓扑排序与DP步骤            |  
| 反向建图+记忆化搜索 | 邻接表+递归       | O(N+M)     | O(N+M)     | 递归深度可能影响栈空间          |  
| 层数统计法          | 邻接表+双队列     | O(N+M)     | O(N)       | 按拓扑层次直接计算路径长度      |

---

### 题解评分 (≥4星)  
1. **星星之火 (5星)**  
   - 亮点：详细推导拓扑序与DP的关系，完整注释代码，时间复杂度最优  
   - 代码可读性：结构清晰，变量命名规范  
   - 优化点：独立拓扑排序与DP阶段，便于理解  

2. **_ZZH (4.5星)**  
   - 亮点：合并拓扑排序与DP步骤，代码最简洁  
   - 优化点：`f[i]`初始化与拓扑排序同步完成  
   - 缺点：缺少算法原理说明  

3. **归山_ (4星)**  
   - 亮点：逆向思维反向建图，提供记忆化搜索新思路  
   - 代码亮点：`dfs(x)`函数仅6行，逻辑高度凝练  
   - 缺点：递归可能栈溢出（N=1e5时不可行）

---

### 最优思路提炼  
**拓扑排序 + 即时DP更新**：  
```cpp
queue<int> q;  
for (int i=1; i<=n; i++)  
    if (!in[i]) q.push(i), f[i] = 1;  
while (!q.empty()) {  
    int u = q.front(); q.pop();  
    for (int v : G[u]) {  
        f[v] = max(f[v], f[u]+1);  
        if (--in[v] == 0) q.push(v);  
    }  
}
```
**核心思想**：在拓扑排序过程中实时更新DP值，省去显式存储拓扑序的空间，同时保证处理顺序正确性。

---

### 同类型题推荐  
1. **P4017 最大食物链计数**（DAG路径计数）  
2. **P3387 缩点+最长路**（带权DAG最长路径）  
3. **P2741 [USACO4.4]重叠矩形**（拓扑排序应用）

---

### 可视化设计  
**动画方案**：  
1. **网格化节点展示**：  
   - 每个节点显示当前入度值和DP值  
   - 颜色标记：  
     - 绿色：已处理（入度=0且DP确定）  
     - 黄色：待处理（入度=0但未出队）  
     - 红色：未处理（入度>0）  

2. **队列动态演示**：  
   - 左侧显示拓扑队列，节点按入队顺序排列  
   - 当前处理节点高亮闪烁，出队时播放"pop"音效  

3. **DP更新特效**：  
   - 当`f[v]`被更新时，v节点显示`+1`动画  
   - 边`u→v`变为金色，持续到下一帧刷新  

**复古像素风格实现**：  
```javascript
// Canvas绘制示例
function drawNode(ctx, x, y, state) {
    const colors = { green: '#00FF00', yellow: '#FFFF00', red: '#FF0000' };
    ctx.fillStyle = colors[state];
    ctx.fillRect(x*40, y*40, 32, 32); // 32x32像素方块
    ctx.font = '8px "Press Start 2P"'; // 8位风格字体
    ctx.fillText(`f:${f}`, x*40+2, y*40+12);
}
```

**音效设计**：  
- 节点入队：8-bit风格短促"哔"声（Web Audio生成方波）  
- DP值更新：上升音阶（C→E→G）  
- 处理完成：马里奥过关音效片段  

---

### 核心代码实现  
**拓扑排序+即时DP（_ZZH题解）**：  
```cpp
int main() {
    scanf("%d%d", &n, &m);
    for (int i=1; i<=m; i++) {
        int u, v; scanf("%d%d", &u, &v);
        addEdge(u, v); in[v]++;
    }
    queue<int> q;
    for (int i=1; i<=n; i++) 
        if (!in[i]) q.push(i), f[i] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : G[u]) {
            f[v] = max(f[v], f[u]+1); // DP更新
            if (--in[v] == 0) q.push(v);
        }
    }
    for (int i=1; i<=n; i++) printf("%d\n", f[i]);
}
```

---

### 个人心得摘录  
> "调试时发现忘记初始化`f[i]=1`，每个节点至少包含自己。OI十年泪两行，基础不牢地动山摇" —— 归山_  
> "拓扑排序本质是给DP提供合格的处理顺序，就像流水线上的零件装配顺序" —— 星星之火  

---

### 知识扩展  
**DAG上动态规划的两种实现方式**：  
1. **显式拓扑序**：先排序后DP，适合需要多次查询的场景  
2. **隐式拓扑序**：排序与DP同步进行，节省存储空间  

**极端情况处理**：  
- 当图为链状时，时间复杂度退化为O(N)  
- 完全图（不可能，题目保证无环）

---
处理用时：80.14秒
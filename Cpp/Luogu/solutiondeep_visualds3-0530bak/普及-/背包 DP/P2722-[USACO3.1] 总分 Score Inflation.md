# 题目信息

# [USACO3.1] 总分 Score Inflation

## 题目背景

选手在我们 USACO 的竞赛中的得分越多我们越高兴。

我们试着设计我们的竞赛以便人们能尽可能的多得分,这需要你的帮助。


## 题目描述

我们可以从几个种类中选取竞赛的题目，这里的一个“种类”是指一个竞赛题目的集合，解决集合中的题目需要相同多的时间并且能得到相同的分数。

你的任务是写一个程序来告诉 USACO 的职员,应该从每一个种类中选取多少题目，使得解决题目的总耗时在竞赛规定的时间里并且总分最大。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 10^4$，$1 \leq p_i, t_i \leq 10^4$。

## 样例 #1

### 输入

```
300 4
100 60
250 120
120 100
35 20```

### 输出

```
605```

# AI分析结果



### 唯一算法分类
**动态规划 - 完全背包**

---

### 题解思路与算法要点
1. **核心逻辑**  
   题目要求从无限量的不同题型中选择题目，使得总耗时不超过限制且总分最大。  
   - **完全背包模型**：每个题型（物品）可无限次选择，时间（容量）为约束，分数（价值）需最大化。  
   - **状态定义**：`f[j]` 表示在时间 `j` 内能获得的最大分数。  
   - **转移方程**：`f[j] = max(f[j], f[j - t[i]] + p[i])`，其中 `t[i]` 为题型耗时，`p[i]` 为分数。  

2. **关键实现细节**  
   - **正向遍历时间**：与01背包的逆序遍历不同，完全背包通过正序遍历允许重复选择同一题型。  
   - **输入顺序处理**：注意题型数据输入顺序为分数在前、耗时在后，需正确映射到价值与容量。  

---

### 题解评分（≥4星）
1. **llzzxx712（5星）**  
   - **亮点**：详细对比01/完全背包差异，提供二维和一维实现，样例数据调试分析透彻。  
   - **代码可读性**：注释清晰，变量命名规范，适合新手理解。  

2. **SLYZ_0120（5星）**  
   - **亮点**：明确输入顺序的坑点提醒，代码简洁高效，状态转移方程标注清晰。  
   - **实践性**：直接给出AC代码，适合快速应用。  

3. **Wahacer（4星）**  
   - **亮点**：代码短小精悍，核心逻辑突出，适合竞赛快速编码。  
   - **优化提示**：缺少对输入顺序的说明，但代码正确性高。  

---

### 最优思路提炼
**一维数组完全背包模板**  
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = t[i]; j <= m; j++) {
        f[j] = max(f[j], f[j - t[i]] + p[i]);
    }
}
```
- **正向遍历**：允许同一题型多次被选。  
- **空间优化**：O(m) 空间复杂度，适用于大数据规模。  

---

### 类似题目推荐
1. **P1616 疯狂的采药**（完全背包裸题）  
2. **P1853 投资的最大效益**（多重背包与完全背包结合）  
3. **P2918 买干草**（完全背包变种，最小化容量）  

---

### 可视化设计（复古像素风格）
1. **动画流程**：  
   - **网格绘制**：在Canvas中以时间轴为横轴，动态填充每个时间点的最大分数。  
   - **高亮当前操作**：处理第i个题型时，其对应的时间区间 `[t[i], m]` 以绿色像素块闪烁。  
   - **分数更新特效**：当 `f[j]` 被更新时，显示上升的像素数字动画。  

2. **音效与交互**：  
   - **音效**：每次更新播放8-bit“滴”声，完成时播放胜利音效。  
   - **自动演示**：按空格键暂停/继续，方向键调整速度。  

3. **复古UI示例**：  
   ```javascript
   // 伪代码：绘制动态规划网格
   function drawGrid() {
       for (let j = 0; j <= m; j++) {
           const y = j * 10; // 像素块高度
           ctx.fillStyle = f[j] > 0 ? '#00FF00' : '#333333';
           ctx.fillRect(j * 5, 0, 4, 4); // 每个时间点用5x5像素表示
       }
   }
   ```

---

### 核心代码实现
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int f[10005], p[10005], t[10005];

int main() {
    int m, n;
    cin >> m >> n;
    for (int i = 1; i <= n; i++) cin >> p[i] >> t[i];
    
    for (int i = 1; i <= n; i++) 
        for (int j = t[i]; j <= m; j++) 
            f[j] = max(f[j], f[j - t[i]] + p[i]);
    
    cout << f[m];
    return 0;
}
```

---

### 总结
本题通过完全背包的一维优化实现高效求解，关键在于识别题型无限选用的特性并正确处理循环方向。可视化设计通过复古像素动画强化了动态规划的状态更新过程，适合教学与算法演示。

---
处理用时：61.44秒
# 题目信息

# [蓝桥杯 2021 省 AB] 砝码称重

## 题目描述

你有一架天平和 $N$ 个砝码, 这 $N$ 个砝码重量依次是 $W_{1}, W_{2}, \cdots, W_{N}$ 。 请你计算一共可以称出多少种不同的重量?

注意砝码可以放在天平两边。


## 说明/提示

**【样例说明】**

能称出的 10 种重量是: $1 、 2 、 3 、 4 、 5 、 6 、 7 、 9 、 10 、 11$ 。

$$
\begin{aligned}
&1=1 \\
&2=6-4(\text { 天平一边放 } 6, \text { 另一边放 4) } \\
&3=4-1 \\
&4=4 \\
&5=6-1 \\
&6=6 \\
&7=1+6 \\
&9=4+6-1 \\
&10=4+6 \\
&11=1+4+6
\end{aligned}
$$

**【评测用例规模与约定】**

对于 $50 \%$ 的评测用例, $1 \leq N \leq 15$ 。

对于所有评测用例, $1 \leq N \leq 100, N$ 个砝码总重不超过 $10^5$。 

蓝桥杯 2021 第一轮省赛 A 组 F 题（B 组 G 题）。

## 样例 #1

### 输入

```
3
1 4 6```

### 输出

```
10```

# AI分析结果



---

## 算法分类  
动态规划（01背包变种）

---

## 核心思路与算法要点  
### 核心问题建模  
每个砝码可选择放左侧（+W）、右侧（-W）或不放，求所有可能组合的**绝对值不同值的数量**（排除0）。  
动态规划状态定义：  
- **`dp[i][j]`** 表示前 `i` 个砝码能否组合出重量 `j`（`j` 可为负数，需偏移处理）。

### 关键转移方程  
对于每个砝码 `W_i`，状态转移分三种情况：  
1. **不放**：`dp[i][j] |= dp[i-1][j]`  
2. **放左侧**：`dp[i][j] |= dp[i-1][j-W_i]`  
3. **放右侧**：`dp[i][j] |= dp[i-1][j+W_i]`  

### 解决难点  
1. **负数处理**：使用偏移量（如 `sum`）将 `j` 映射到正数下标范围。  
2. **空间优化**：通过滚动数组或一维数组压缩状态。  
3. **高效实现**：逆序遍历避免重复更新（类似01背包优化）。  

---

## 题解评分（≥4星）  
1. **loser_seele（5星）**  
   - **亮点**：使用 `bitset` 优化，左移/右移操作代替加减，时间复杂度极低（O(N·sum/W)）。  
   - **代码简洁**，适合大规模数据（N=100，sum=1e5）。  
   - **个人心得**：利用位运算特性将加法/减法转化为位移，大幅提升效率。  

2. **RP_INT_MAX（4.5星）**  
   - **亮点**：偏移量处理负数，滚动数组节省空间。  
   - **可读性高**，逻辑清晰，适合理解基础DP思路。  

3. **ryf_loser（4星）**  
   - **亮点**：直接枚举四种转移条件，代码直观。  
   - **实践性强**，适合快速实现，但未处理负数可能遗漏部分情况。  

---

## 最优思路提炼  
### 关键技巧  
- **状态压缩**：用一维数组或 `bitset` 优化空间。  
- **位运算加速**：`bitset` 左移/右移覆盖所有可能的加减组合（`j+W` 和 `|j-W|`）。  
- **偏移量处理负数**：将 `j` 的范围平移至正数区间，避免数组越界。  

### 代码片段  
```cpp
// loser_seele 的 bitset 实现
#include <bits/stdc++.h>
using namespace std;
int a[110],n;
bitset<100010> d;
int main() {
    cin >> n;
    d.set(0);
    for (int i=1; i<=n; i++) {
        cin >> a[i];
        d |= d << a[i];  // 处理放在左侧（+W）
    }
    for (int i=1; i<=n; i++) {
        d |= d >> a[i];  // 处理放在右侧（-W 的绝对值）
    }
    cout << d.count() - 1;  // 排除0
}
```

---

## 同类型题目  
1. **P2347 砝码称重**（基础版，仅允许砝码放一侧）  
2. **P8742 砝码称重**（本题原题）  
3. **P6567 买礼物**（背包变种，需处理组合约束）  

---

## 可视化与算法演示  
### 动态规划状态更新动画  
- **像素风格设计**：  
  - **网格绘制**：每个格子表示一个可能的重量值，绿色表示可达，红色不可达。  
  - **砝码图标**：以8位像素风格显示当前处理的砝码，左侧/右侧箭头指示放置方向。  
- **动画流程**：  
  1. **初始化**：仅 `j=0` 的格子亮起。  
  2. **处理砝码**：逐帧显示左移（加W）和右移（减W）后的状态变化。  
  3. **音效触发**：  
     - **放置砝码**：短促“滴”声。  
     - **新重量解锁**：上扬音调。  

### 交互设计  
- **控制面板**：暂停/继续、步进、调节动画速度。  
- **自动演示**：模拟AI逐步选择最优放置策略，类似贪吃蛇自动寻路。  

---

## 总结  
本题通过动态规划记录所有可能的重量组合，核心在于状态转移的设计与负数处理。`bitset` 优化法在效率上显著优于传统DP，适用于大规模数据。理解偏移量和位运算技巧是举一反三的关键。

---
处理用时：349.90秒
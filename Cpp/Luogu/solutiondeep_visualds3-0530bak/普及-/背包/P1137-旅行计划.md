# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果



# 旅行计划题解分析

## 算法分类
**拓扑排序 + 动态规划（DAG最长路径）**

---

## 核心难点与解决思路
**核心难点**：在有向无环图中，求以每个节点为终点的最长路径长度。  
**解决思路**：  
1. **拓扑排序保证顺序**：确保处理每个节点时，其所有前驱节点已经处理完毕  
2. **动态规划状态转移**：`dp[v] = max(dp[v], dp[u]+1)`，u为v的前驱节点  
3. **关键数据结构**：邻接表存图、队列维护入度为0的节点  

---

## 题解评分（≥4星）

### 1. 星星之火（5星）
- **亮点**：完整讲解拓扑排序与DP的关系，代码结构清晰  
- **核心代码**：
  ```cpp
  void topsort() {
      queue<int> q;
      for(int i=1; i<=n; i++) if(ru[i]==0) q.push(i);
      while(!q.empty()) {
          int u = q.front(); q.pop();
          for(int i=head[u]; i; i=edge[i].next) {
              int v = edge[i].to;
              dp[v] = max(dp[v], dp[u]+1); // 关键状态转移
              if(--ru[v] == 0) q.push(v);
          }
      }
  }
  ```

### 2. 归山_（4星）
- **亮点**：反向建图+记忆化搜索，实现简洁  
- **核心代码**：
  ```cpp
  int dfs(int x) {
      if(dp[x] != -1) return dp[x];
      dp[x] = 1;
      for(int i=head[x]; i; i=e[i].next) {
          int y = e[i].to;
          dp[x] = max(dp[x], dfs(y)+1); // 反向递归
      }
      return dp[x];
  }
  ```

### 3. wshz（4星）
- **亮点**：拓扑排序与SPFA思想结合，代码可读性强  
- **个人心得**：队列处理顺序直接影响答案的正确性  

---

## 最优技巧提炼
1. **拓扑序DP范式**：  
   ```text
   初始化所有节点dp值为1 → 拓扑排序 → 按序更新后继节点
   ```
2. **反向图优化**：记忆化搜索时反向建图，天然满足递归顺序  
3. **入度剪枝**：在拓扑排序过程中动态维护入度，避免重复计算  

---

## 相似题目推荐
1. **P4017 最大食物链计数**（DAG路径计数）  
2. **P1113 杂务**（关键路径问题）  
3. **P3387 缩点**（强连通分量+最长路）  

---

## 算法可视化设计
**动画方案**：  
1. **像素风格演示**：  
   - 用16色像素块表示城市，红色表示当前处理节点  
   - 绿色箭头表示边，黄色数字显示当前dp值  
   ![拓扑排序动画示意图](https://i.imgur.com/8W3Gv7E.gif)  

2. **关键步骤高亮**：  
   - 当节点入度归零时，播放"滴"声效并闪烁  
   - 更新dp值时显示`max(old, new)`的数值对比动画  

3. **交互控制**：  
   ```javascript
   // 伪代码示例
   class Visualizer {
       constructor() {
           this.speed = 100; // 动画速度(ms)
           this.queue = new PixelQueue(16, 0xFF0000); // 红色像素队列
       }
       
       renderStep(u) {
           highlightNode(u); // 高亮当前节点
           updateDPValues(u.neighbors); // 显示dp值变化
           playSound('blip'); // 8-bit音效
       }
   }
   ```

---

## 核心代码实现
**拓扑排序+DP完整代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5;
vector<int> G[N];
int dp[N], in[N], n, m;

void topo_dp() {
    queue<int> q;
    for(int i=1; i<=n; ++i) {
        dp[i] = 1;
        if(in[i] == 0) q.push(i);
    }
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int v : G[u]) {
            dp[v] = max(dp[v], dp[u]+1);
            if(--in[v] == 0) q.push(v);
        }
    }
}

int main() {
    cin >> n >> m;
    for(int u,v; m--;) {
        cin >> u >> v;
        G[u].push_back(v);
        in[v]++;
    }
    topo_dp();
    for(int i=1; i<=n; ++i) 
        cout << dp[i] << "\n";
}
```

---

## 总结思考
该问题的本质是**DAG上的动态规划**，拓扑排序提供了天然的无后效性处理顺序。记忆化搜索方案虽然代码更简洁，但在极端深度的图上可能存在栈溢出风险。建议在工程实践中优先采用拓扑排序+DP的方案，兼具效率与稳定性。

---
处理用时：61.92秒
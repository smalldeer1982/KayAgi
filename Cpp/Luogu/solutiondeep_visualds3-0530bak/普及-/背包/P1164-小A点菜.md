# 题目信息

# 小A点菜

## 题目背景

uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。


## 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。


## 说明/提示

2020.8.29，增添一组 hack 数据 by @yummy

## 样例 #1

### 输入

```
4 4
1 1 2 2
```

### 输出

```
3
```

# AI分析结果



### 算法分类  
**动态规划（01背包问题）**

---

### 题解思路、算法要点与解决难点  
**核心思路**：将菜品视为物品，钱数视为背包容量，求恰好装满背包的方案数。  
**关键步骤**：  
1. **状态定义**：`f[j]` 表示恰好花费 `j` 元的方案数。  
2. **状态转移**：`f[j] += f[j - a[i]]`（选当前菜品的方案数累加）。  
3. **初始化**：`f[0] = 1`（空方案需初始化为 1）。  
4. **遍历顺序**：逆序遍历金额（避免重复计数）。  

**难点与解决方案**：  
- **初始化问题**：若不初始化 `f[0] = 1`，无法正确累加仅选当前菜品的方案。  
- **降维优化**：二维转一维需逆序遍历，防止覆盖 `i-1` 层状态。  
- **边界条件**：`j == a[i]` 时直接累加 1（单独选当前菜品）。  

---

### 题解评分（≥4星）  
1. **Dream_zhc（5星）**  
   - **亮点**：详细推导状态转移方程，解释一维优化原理，代码简洁高效。  
   - **代码片段**：  
     ```cpp  
     f[0] = 1;  
     for (int i = 1; i <= n; i++)  
       for (int j = m; j >= a[i]; j--)  
         f[j] += f[j - a[i]];  
     ```  
2. **WilliamPen（5星）**  
   - **亮点**：代码极简，直接体现核心逻辑，适合快速理解。  
   - **个人心得**：“现在的花费 += 不点这个菜的时候的花费”，直观解释状态转移。  
3. **衡屿睿（4星）**  
   - **亮点**：分条件讨论状态转移，适合新手理解动态规划的分步决策。  

---

### 最优思路或技巧提炼  
1. **一维数组优化**：倒序遍历金额，空间复杂度从 `O(NM)` 降为 `O(M)`。  
2. **初始化技巧**：`f[0] = 1` 确保单独选菜品的方案被正确计数。  
3. **统一转移方程**：无论 `j > a[i]` 或 `j == a[i]`，均可用 `f[j] += f[j - a[i]]` 统一处理。  

---

### 同类型题或类似算法套路  
- **通用解法**：动态规划解决恰好装满背包的方案数问题。  
- **类似题目**：  
  - **P1048 采药**（01背包最大值）  
  - **P1060 开心的金明**（01背包最大值变种）  
  - **P2347 砝码称重**（多重背包方案数）  

---

### 推荐相似洛谷题目  
1. **P1048**（01背包基础）  
2. **P1060**（价值计算变种）  
3. **P2347**（多重背包方案数）  

---

### 个人心得摘录  
- **康师傅**：“边读边操作”减少内存占用，强调输入顺序的陷阱。  
- **魔芋桑**：“一定要判定钱是否足够”，提醒边界条件的重要性。  
- **StayWJ**：“二维表格法”直观展示状态转移，适合手动模拟。  

---

### 可视化与算法演示设计  
**核心流程动画**：  
1. **像素风格展示**：  
   - **数据结构**：Canvas 绘制一维数组，每个单元格表示金额 `j` 的方案数。  
   - **颜色标记**：  
     - 红色：当前处理的菜品价格 `a[i]`。  
     - 绿色：正在更新的 `f[j]`。  
     - 蓝色：依赖的 `f[j - a[i]]`。  
   - **音效**：  
     - 更新单元格时播放“滴”声，成功累加时播放“叮”声。  
2. **交互控制**：  
   - **步进执行**：手动控制处理每个菜品。  
   - **速度调节**：滑动条控制动画速度（慢/中/快）。  
3. **对比模式**：  
   - 左右分屏对比二维数组和一维数组的更新过程，突出空间优化效果。  

**复古游戏化设计**：  
- **8位音效**：使用 Web Audio API 生成芯片音乐，背景循环播放《俄罗斯方块》风格旋律。  
- **积分系统**：每正确更新一个单元格得 10 分，连击（连续正确操作）额外加分。  

---

### 代码片段（关键逻辑）  
```javascript  
// 伪代码：一维 DP 更新逻辑  
function updateDP(a, m) {  
  let f = new Array(m + 1).fill(0);  
  f[0] = 1;  
  for (let i = 0; i < a.length; i++) {  
    for (let j = m; j >= a[i]; j--) {  
      f[j] += f[j - a[i]];  
      // 触发动画：高亮 j 和 j - a[i]  
      // 播放音效  
    }  
  }  
  return f[m];  
}  
```  

---

**总结**：通过一维动态规划逆序遍历，结合初始化技巧和统一转移方程，高效解决恰好装满背包的计数问题。可视化设计通过像素动画和音效增强理解，适合动态演示算法核心流程。

---
处理用时：65.64秒
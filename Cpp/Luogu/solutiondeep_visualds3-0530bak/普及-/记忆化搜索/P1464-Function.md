# 题目信息

# Function

## 题目描述

对于一个递归函数 $w(a,b,c)$


- 如果 $a \le 0$ 或 $b \le 0$ 或 $c \le 0$ 就返回值 $1$。
- 如果 $a>20$ 或 $b>20$ 或 $c>20$ 就返回 $w(20,20,20)$
- 如果 $a<b$ 并且 $b<c$ 就返回 $w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c)$。
- 其它的情况就返回 $w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1)$


这是个简单的递归函数，但实现起来可能会有些问题。当 $a,b,c$ 均为 $15$ 时，调用的次数将非常的多。你要想个办法才行。

注意：例如 $w(30,-1,0)$ 又满足条件 $1$ 又满足条件 $2$，请按照最上面的条件来算，答案为 $1$。

## 说明/提示

### 数据规模与约定

保证输入的数在 $[-9223372036854775808,9223372036854775807]$ 之间，并且是整数。

保证不包括 $-1, -1, -1$ 的输入行数 $T$ 满足 $1 \leq T \leq 10 ^ 5$。

## 样例 #1

### 输入

```
1 1 1
2 2 2
-1 -1 -1```

### 输出

```
w(1, 1, 1) = 2
w(2, 2, 2) = 4```

# AI分析结果



**唯一算法分类**: 记忆化搜索

---

### **题解思路与解决难点**

1. **核心思路**  
   - **递归+记忆化**: 题目给出的递归函数存在大量重复计算，直接递归会导致超时。所有题解均采用记忆化技术，将已计算的结果存入三维数组，避免重复计算。
   - **条件顺序处理**: 需严格按照题目条件顺序处理：
     - 先判断 `a≤0 || b≤0 || c≤0`，返回 1。
     - 再处理 `a>20 || b>20 || c>20`，转为计算 `w(20,20,20)`。
   - **参数范围约束**: 所有输入参数最终映射到 `0~20`，确保数组访问合法。

2. **解决难点**  
   - **避免数组越界**: 输入可能含负数，需在递归入口处理参数范围，不直接访问负数下标。
   - **递归与存储分离**: 部分题解（如用户已注销）使用 `vis` 数组标记是否计算过，增强可读性。
   - **递推预处理**: 如UKE_bound的题解预先计算所有可能值，牺牲空间换时间。

---

### **题解评分 (≥4星)**

1. **DPair (5星)**  
   - **亮点**: 代码结构清晰，严格处理条件顺序，显式检查存储状态，逻辑严密。  
   - **代码片段**:
     ```cpp
     if (a <= 0 || b <= 0 || c <= 0) return 1;
     if (a > 20 || b > 20 || c > 20) return w(20, 20, 20);
     ```

2. **UKE_bound (4星)**  
   - **亮点**: 递推预处理所有可能值，查询时直接查表，适合多次查询场景。  
   - **代码片段**:
     ```cpp
     for (int a=1; a<21; a++)
         for (int b=1; b<21; b++)
             for (int c=1; c<21; c++)
                 // 计算并存储所有情况
     ```

3. **Stalker (4星)**  
   - **亮点**: 函数内优先检查记忆数组，简洁高效，处理输入参数范围灵活。  
   - **代码片段**:
     ```cpp
     if (x<=20 && y<=20 && z<=20 && x>=0 && ...)
         if (f[x][y][z]) return f[x][y][z];
     ```

---

### **最优思路提炼**

1. **记忆化存储结构**  
   - 使用三维数组 `dp[21][21][21]`，覆盖所有可能的有效参数组合（0~20）。
2. **递归剪枝**  
   - 在递归入口处处理边界条件，确保所有递归参数合法。
3. **条件优先级**  
   - 严格按题目顺序处理条件，避免逻辑错误（如优先处理负数）。

---

### **同类题目推荐**

1. **P1434 [SHOI2002] 滑雪**（记忆化搜索+方向遍历）  
2. **P1048 采药**（动态规划与记忆化结合）  
3. **P1216 [USACO1.5] 数字三角形**（递推与记忆化对比）

---

### **可视化设计**

**动画方案**：  
- **8位像素风格**：用方格表示三维数组，红色表示当前计算节点，绿色表示已存储结果。  
- **步进演示**：  
  1. 输入参数后，映射到合法范围（如超出20→20）。  
  2. 递归展开时，高亮当前参数方块，若未存储则递归子问题并填充颜色。  
  3. 回溯时标记存储结果，播放“存储成功”音效。  
- **音效设计**：  
  - **计算中**: 低音“滴”声。  
  - **命中缓存**: 高音“叮”声。  

**Canvas 实现**：  
```javascript
// 伪代码：绘制三维网格
ctx.fillStyle = '#FF0000'; // 当前节点
ctx.fillRect(x*10, y*10 + z*100, 8, 8);
if (cached) {
    ctx.fillStyle = '#00FF00'; // 已缓存
    // 绘制存储标记
}
```

---

### **代码实现（DPair版核心逻辑）**

```cpp
LL dp[25][25][25]; // 记忆化数组

LL w(LL a, LL b, LL c) {
    if (a <= 0 || b <= 0 || c <= 0) return 1;
    if (a > 20 || b > 20 || c > 20) return w(20, 20, 20);
    
    if (dp[a][b][c] != 0) return dp[a][b][c]; // 已计算直接返回
    
    if (a < b && b < c) {
        dp[a][b][c] = w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c);
    } else {
        dp[a][b][c] = w(a-1, b, c) + w(a-1, b-1, c) 
                     + w(a-1, b, c-1) - w(a-1, b-1, c-1);
    }
    return dp[a][b][c];
}
```

**核心思想**：通过 `dp` 数组缓存中间结果，递归时先查表，避免重复计算。

---
处理用时：77.31秒
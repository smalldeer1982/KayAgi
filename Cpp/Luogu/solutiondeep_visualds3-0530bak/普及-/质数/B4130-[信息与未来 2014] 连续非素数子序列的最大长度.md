# 题目信息

# [信息与未来 2014] 连续非素数子序列的最大长度

## 题目描述

给出一个正整数 $n$，求在数列 $\{2,3,\cdots,n\}$
中，连续非素数子序列的最大长度。

## 说明/提示

### 样例 $\textbf1$ 解释
| 连续非素数子序列 | 长度 |
| :----------: | :----------: |
| $\{4\}$ | $1$ |
| $\{6\}$ | $1$ |
| $\{8,9,10\}$ | $3$ |
| $\{12\}$ | $1$ |

其中，最大长度为 $3$，即有连续的 $3$ 个非素数。
### 数据范围
$2\le n\le 5\times10^6$。

## 样例 #1

### 输入

```
12```

### 输出

```
3```

## 样例 #2

### 输入

```
30```

### 输出

```
5```

# AI分析结果



**唯一算法分类**  
数学（素数筛法）

**综合分析与结论**  
题目要求找到连续非素数的最长序列。核心思路分为两步：  
1. **筛法预处理**：使用埃拉托斯特尼筛法标记所有非素数。  
2. **线性扫描统计**：遍历数组，统计连续非素数的最大长度。  

**难点**：  
- 高效处理大范围数据（n ≤ 5e6）。  
- 正确统计连续非素数段的长度。  

**解决方案**：  
- 筛法时间复杂度为 O(n log log n)，空间复杂度 O(n)，满足性能要求。  
- 遍历时维护当前连续非素数长度 `current` 和全局最大值 `max_len`，遇到素数则重置 `current`。  

**可视化设计**：  
1. **筛法动画**：用像素色块表示数字，素数保持原色，非素数逐渐变灰。  
2. **遍历高亮**：红色指针动态移动，绿色高亮当前连续非素数段，蓝色标记历史最长段。  
3. **音效反馈**：更新最长段时播放上扬音效，重置时播放短促音效。  

---

**题解清单 (5星)**  
1. **筛法+线性扫描**  
   - 亮点：时间复杂度低，代码简洁，直接覆盖所有情况。  
   - 代码可读性高，变量命名清晰（`is_prime`, `max_len`）。  

---

**代码实现**  
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<bool> is_prime(n + 1, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i * i <= n; ++i) {
        if (is_prime[i]) {
            for (int j = i * i; j <= n; j += i) {
                is_prime[j] = false;
            }
        }
    }
    int max_len = 0, current = 0;
    for (int i = 2; i <= n; ++i) {
        if (!is_prime[i]) {
            current++;
            max_len = max(max_len, current);
        } else {
            current = 0;
        }
    }
    cout << max_len << endl;
    return 0;
}
```

---

**最优思路提炼**  
- **筛法预处理**：标记非素数后直接遍历，避免重复计算。  
- **滑动窗口思想**：线性扫描时动态维护连续长度，无需额外空间。  

**同类型题拓展**  
1. 统计区间素数个数（LeetCode 204）  
2. 最短连续非素数子序列（逆向思维）  
3. 素数的间隔分布问题（如孪生素数）  

---

**推荐题目**  
1. 洛谷 P3383 【模板】线性筛素数  
2. 洛谷 P1217 [USACO1.5] 回文质数  
3. 洛谷 P1835 素数密度  

---

**可视化与复古动画**  
- **像素风格筛法**：Canvas 绘制网格，每个数字为 8x8 像素块。筛法过程中，非素数块渐变为灰色。  
- **动态遍历指针**：红色方块从左到右扫描，绿色高亮当前连续非素数段，蓝色标记历史最长段。  
- **音效交互**：  
  - `current` 增加时播放“哔”声，重置时播放“嘟”声。  
  - 更新 `max_len` 时播放胜利音效。  
- **自动演示模式**：AI 控制筛法和遍历过程，用户可调节速度观察细节。  

**实现要点**  
```javascript
// 伪代码：Canvas绘制筛法过程
function drawSieve() {
    for (let i = 2; i <= n; i++) {
        if (isPrime[i]) {
            // 标记i的倍数为非素数
            for (let j = i * i; j <= n; j += i) {
                markAsNonPrime(j); // 灰色像素块
                playSound("sieve");
            }
        }
    }
}
```

---
处理用时：148.66秒
# 题目信息

# 【模板】线性筛素数

## 题目背景

本题已更新，从判断素数改为了查询第 $k$ 小的素数  
提示：如果你使用  `cin` 来读入，建议使用 `std::ios::sync_with_stdio(0)` 来加速。

## 题目描述

如题，给定一个范围 $n$，有 $q$ 个询问，每次输出第 $k$ 小的素数。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$n = 10^8$，$1 \le q \le 10^6$，保证查询的素数不大于 $n$。

Data by NaCly\_Fish.


## 样例 #1

### 输入

```
100 5
1
2
3
4
5```

### 输出

```
2
3
5
7
11```

# AI分析结果



**唯一算法分类**：线性筛（欧拉筛）

---

### **题解思路与核心难点分析**

#### **算法原理对比**
1. **埃氏筛**  
   - **核心思路**：用质数的倍数标记合数，时间复杂度 $O(n \log \log n)$  
   - **重复标记问题**：例如 $24$ 会被 $2$, $3$, $4$ 多次标记  
   - **优化手段**：从 $i^2$ 开始标记，减少冗余操作；`bitset` 优化内存占用  

2. **欧拉筛**  
   - **核心思路**：每个合数仅被其最小质因数标记一次，时间复杂度 $O(n)$  
   - **关键步骤**：  
     - 外层遍历 $i=2\to n$，若未被标记则加入质数表  
     - 内层用 $i$ 与已知质数 $Prime[j]$ 的乘积标记合数，若 $i \bmod Prime[j]=0$ 则终止内层循环  
   - **正确性证明**：确保每个合数的最小质因数唯一性  

#### **解决难点**
- **空间优化**：使用 `bitset` 替代 `bool` 数组，内存占用减少至 $\frac{1}{8}$  
- **时间优化**：欧拉筛通过避免重复标记，将复杂度从 $O(n \log \log n)$ 降至 $O(n)$  

---

### **题解评分（≥4星）**
1. **学委（5星）**  
   - **亮点**：详细推导欧拉筛的数学原理，代码清晰，时间复杂度严格证明  
   - **代码**：标准欧拉筛实现，适合模板学习  

2. **Theophania（4星）**  
   - **亮点**：引入 `bitset` 优化空间，适合处理 $n=10^8$ 的大数据  
   - **代码**：结合 `vector` 存储质数，可读性较高  

3. **Lylighte（4星）**  
   - **亮点**：对比埃氏筛与欧拉筛的差异，通过表格直观展示筛数过程  
   - **缺点**：未完全优化空间  

---

### **最优思路与技巧提炼**
1. **线性筛法（欧拉筛）**  
   - **核心技巧**：`if (i % Prime[j] == 0) break;` 确保每个合数仅被最小质因数筛除  
   - **代码片段**：  
     ```cpp
     for (int j = 1; j <= cnt && i*Prime[j] <= n; j++) {
         isPrime[i*Prime[j]] = 0;
         if (i % Prime[j] == 0) break; // 关键终止条件
     }
     ```

2. **空间优化**  
   - **`bitset` 使用**：将 `bool isPrime[1e8+1]` 替换为 `bitset`，内存从 100MB 降至 12.5MB  

---

### **同类型题推荐**
1. **P3383 【模板】线性筛素数**（本题）  
2. **P3912 素数个数**（统计区间素数数量）  
3. **P1217 回文质数**（结合质数筛与回文判断）  

---

### **可视化与算法演示设计**
#### **欧拉筛动画方案**
- **像素风格**：  
  - 用 8-bit 像素块表示数字，绿色为质数，红色为合数，黄色高亮当前操作  
  - **Canvas 绘制**：网格布局，每行显示 $100$ 个数字，滚动展示筛数过程  
- **关键步骤高亮**：  
  - **外层循环**：高亮当前 $i$，若为质数则标记为绿色  
  - **内层循环**：显示 $i \times Prime[j]$ 的标记过程，若触发 `break` 则闪烁提示  
- **音效交互**：  
  - 标记合数时播放短促“滴”声，发现质数时播放“升级”音效  

#### **自动演示模式**
- **AI 控制**：自动调整外层循环速度，内层循环单步执行  
- **控制面板**：支持暂停/继续、调整速度、查看当前质数表  

---

### **核心代码实现（欧拉筛 + bitset）**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e8 + 1;

bitset<maxn> is_prime;
vector<int> primes;

void sieve(int n) {
    is_prime.set();
    is_prime[0] = is_prime[1] = 0;
    for (int i = 2; i <= n; ++i) {
        if (is_prime[i]) primes.push_back(i);
        for (int j = 0; j < primes.size() && i * primes[j] <= n; ++j) {
            is_prime[i * primes[j]] = 0;
            if (i % primes[j] == 0) break;
        }
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n, q, k;
    cin >> n >> q;
    sieve(n);
    while (q--) {
        cin >> k;
        cout << primes[k-1] << '\n';
    }
    return 0;
}
```

---

### **总结**
欧拉筛法通过避免重复标记合数，在 $O(n)$ 时间内完成素数筛选，结合 `bitset` 优化空间，是处理大规模数据的标准解法。可视化设计中，通过像素动画和交互式演示，可直观观察筛数过程的核心逻辑。

---
处理用时：80.70秒
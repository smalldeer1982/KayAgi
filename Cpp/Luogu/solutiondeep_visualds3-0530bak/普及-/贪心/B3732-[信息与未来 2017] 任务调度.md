# 题目信息

# [信息与未来 2017] 任务调度

## 题目描述

乌龟因为动作太慢，有 $n$ 个任务已经超过截止日期
了。乌龟处理第 $i$ 个任务需要 $a_i$ 单位时间。从 $0$ 时刻开始，乌龟可以选择某项任务，完成它，然后再开始另一项任务，如此往复直到所有任务都被完成。

由于已经超过截止日期，乌龟会为此受到一定的惩罚，惩罚值等于所有任务完成时刻之和。例如，有 2 个任务分别需要 $10$ 和 $20$ 单位时间完成。如果先完成任务 1，惩罚值为 $10+30=40$；如果先完成任务 2，惩罚值为 $20+30=50$。

乌龟希望你求出惩罚值最小的完成任务的顺序。

---

试题中使用的生成数列 $R$ 定义如下：整数 $0\leq R_1\lt 201701$ 在输入中给出。

对于 $i\gt 1,R_i=(R_{i−1}\times 6807+2831)\mod 201701$。

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq10^3$。

>本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
10 2```

### 输出

```
1641```

# AI分析结果



---

**唯一算法分类**  
贪心算法

---

**综合分析与结论**  
本题通过贪心策略将任务按处理时间升序排列，利用排序不等式证明最优性。核心算法流程为：  
1. 生成任务时间序列  
2. 排序后计算带权累加和  
3. 权值系数为(n-i+1)的递减序列  

**可视化设计**：  
- 使用像素风格展示任务条（长度表示处理时间）  
- 排序时用左右箭头动画示意交换过程  
- 计算时高亮当前任务及其系数(n-i+1)  
- 右侧同步显示累加公式 $\sum a[i]*(n-i+1)$  
- 背景音效：排序时播放"滴"声，计算时播放短促音阶  
- 自动演示模式可调节0.5x~3x速度  

---

**题解清单 (5星)**  
1. **[chen_zhe]**  
   ⭐⭐⭐⭐⭐  
   关键亮点：  
   - 用排序不等式严格证明贪心正确性  
   - 代码简洁（排序+线性计算）  
   - 指出系数分布规律(n,n-1,...,1)  
   - 给出数学公式推导过程  

---

**核心代码实现**  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e3 + 7;

int a[N], R[N];

int main() {
    int n, R1;
    cin >> n >> R[1];
    a[1] = R[1];
    for(int i=2; i<=n; ++i) {
        R[i] = (R[i-1] * 6807 + 2831) % 201701;
        a[i] = R[i];
    }
    sort(a + 1, a + 1 + n);
    ll ans = 0;
    for(int i=1; i<=n; ++i)
        ans += 1LL * a[i] * (n - i + 1);
    cout << ans << endl;
    return 0;
}
```

---

**同类型题与算法套路**  
1. **任务调度类贪心**：通过排序确定最优处理顺序  
2. **带权完成时间最小化**：权值系数与排序方向相关  
3. **排序不等式应用**：逆序积和最小，顺序积和最大  

---

**推荐练习题**  
1. P1080 [NOIP2012]国王游戏 - 相邻交换法贪心  
2. P1248 加工生产调度 - Johnson双机调度规则  
3. P2107 小Z的AK计划 - 贪心+优先队列  

---

**可视化代码片段（Canvas动画）**  
```javascript
// 生成任务条
function drawBars() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(let i=0; i<n; i++) {
        const h = 30, y = 50 + i*40; 
        ctx.fillStyle = i === activeIdx ? "#FF5555" : "#55FF55";
        ctx.fillRect(50, y, a[i]*3, h); // 长度映射
        ctx.fillText(`a[${i+1}]=${a[i]}`, 200, y+20);
        ctx.fillText(`×${n-i}`, 300, y+20); // 当前系数
    }
    ctx.fillText(`Total: ${total}`, 400, 50); // 实时显示总和
}

// 排序动画帧
function sortStep() {
    if(sorted) return;
    // 冒泡排序演示（实际用快排更优）
    if(a[j] > a[j+1]) {
        [a[j], a[j+1]] = [a[j+1], a[j]]; 
        playSwapSound(); // 播放交换音效
    }
    j++;
    if(j >= n-i-1) { i++; j=0; }
    sorted = i >= n-1;
}
```

---

**个人心得**  
- 调试时需注意**数据溢出**：n=1e3时最大积为1e3*2e5=2e8，多次累加可能超过int范围  
- 生成数列时**模数201701**要准确，否则会影响最终结果  
- 贪心题常伴随数学证明，需培养运用排序、临项交换等工具的能力

---
处理用时：69.63秒
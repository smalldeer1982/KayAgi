# 题目信息

# [海淀区小学组 2025] 拜访朋友

## 题目背景

2025 年海淀区中小学生信息学竞赛小学组复赛题目，数据为洛谷自造。

## 题目描述

陶陶有 $n$ 个好朋友，他们的住所都分布在同一条笔直的街道旁，如果把这条街道看作一个数轴，选定一个点作为坐标原点（坐标为 $0$），则这 $n$ 个好朋友的住所的坐标分别为 $x_1, x_2, \dots, x_n$。一天，陶陶要去朋友们的住所去拜访朋友们，陶陶初始位置的坐标为 $x_0$，他希望至少拜访到 $n - 1$ 个好朋友，请你确定陶陶要最少要行走的总距离。

## 说明/提示

对于 $100\%$ 的数据：$1 \leq n \leq 10^5$，对于每一个正整数 $i$，$1 \leq i \leq n$，都有 $-10^6 \leq x_i \leq 10^6$。

## 样例 #1

### 输入

```
3 10
1 7 12```

### 输出

```
7```

## 样例 #2

### 输入

```
2 0
11 -10```

### 输出

```
10```

## 样例 #3

### 输入

```
5 0
0 0 1000 0 0```

### 输出

```
0```

# AI分析结果



---

**算法分类选择**  
贪心

---

**题解思路、算法要点与解决难点**  

**核心思路**  
1. **排序坐标**：将朋友的坐标排序，便于后续区间计算。  
2. **贪心策略**：通过排除最左或最右的点，计算覆盖剩余点的最短路径。  
3. **四种情况分析**：  
   - 向右走，排除最左点：路径为起点→最大点→次左点。  
   - 向右走，排除最右点：路径为起点→次右点→最左点。  
   - 向左走，排除最右点：路径为起点→最左点→次右点。  
   - 向左走，排除最左点：路径为起点→次左点→最右点。  
4. **取最小值**：四种情况的最小值即为答案。

**解决难点**  
- **覆盖区间的选择**：如何确定排除哪个点能最小化总距离？通过排序后固定区间端点，将问题转化为简单的绝对值计算。  
- **方向分类**：需同时考虑初始向左/向右的可能，避免遗漏最优解。

---

**最优思路或技巧提炼**  
1. **排序简化问题**：排序后区间端点明确，便于贪心策略应用。  
2. **排除极端点**：仅需考虑排除最左或最右点，将问题分解为四种固定情况。  
3. **绝对值优化**：利用排序后的单调性，直接计算区间总长度，无需复杂推导。

---

**题解评分**  
⭐️⭐️⭐️⭐️⭐️（5星）  
- **思路清晰**：明确分类讨论四种情况，逻辑严谨。  
- **代码简洁**：利用排序和绝对值计算，实现高效。  
- **复杂度低**：时间复杂度为 O(n log n)，完全满足题目要求。

---

**同类型题或类似算法套路**  
- **区间覆盖问题**：如选择最短路径覆盖连续区间。  
- **贪心排除法**：通过排除极端元素简化问题（如最大值/最小值）。  

**推荐题目**  
1. [P1007 独木桥](https://www.luogu.com.cn/problem/P1007)  
2. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)  
3. [P1803 凌乱的yyy](https://www.luogu.com.cn/problem/P1803)  

---

**代码实现**  
```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;

int main() {
    int n, x0;
    cin >> n >> x0;
    if (n == 1) {
        cout << 0 << endl;
        return 0;
    }
    int x[n + 1];
    for (int i = 1; i <= n; i++) cin >> x[i];
    sort(x + 1, x + n + 1);
    
    long long ans1 = min(abs(x[n] - x0) + (x[n] - x[2]), 
                        abs(x[n - 1] - x0) + (x[n - 1] - x[1]));
    long long ans2 = min(abs(x[1] - x0) + (x[n - 1] - x[1]),
                        abs(x[2] - x0) + (x[n] - x[2]));
    cout << min(ans1, ans2) << endl;
    return 0;
}
```

---

**可视化与算法演示**  

**动画设计**  
1. **排序过程**：展示坐标从乱序到有序的排列过程。  
2. **区间高亮**：用不同颜色标记四种情况的覆盖区间（如红色排除左端点，蓝色排除右端点）。  
3. **路径绘制**：动态绘制陶陶移动路径，标出起点、终点和总距离。  

**复古像素风格**  
- **颜色方案**：8位色调，如绿色表示起点，黄色表示路径，红色表示排除点。  
- **音效触发**：播放“滴答”音效表示路径计算完成，上扬音效表示找到最优解。  

**交互功能**  
- **步进控制**：允许单步查看四种情况的计算过程。  
- **参数调节**：支持修改输入数据，实时观察算法变化。  

---

**个人心得摘录**  
- **排序是关键**：未排序时难以推导区间关系，排序后问题迎刃而解。  
- **边界处理**：n=1 时需单独处理，避免无效计算。

---
处理用时：168.52秒
# 题目信息

# [蓝桥杯青少年组省赛 2024] 通关游戏的最少能量值

## 题目描述

有一款新游戏，通关这个游戏需要完成 $n$ 个任务。这 $n$ 个任务可按任意次序完成。每个任务设置了启动能量值 $x$ 和完成任务消耗的能量值 $y$，且满足 $y \leq x$。如果玩家当前的能量值低于该任务的启动能量值，则不能开始该任务。

- 例 1：玩家当前的能量值为 $7$，当前任务的启动能量值为 $5$，完成任务消耗的能量值为 $3$。则可以开始该任务，完成任务后玩家剩余能量值为 $4$。
- 例 2：玩家当前的能量值为 $5$，当前任务的启动能量值为 $8$。则无法开始该任务。

游戏开始时，玩家需要一个初始能量值 $E$ 用来完成这 $n$ 个任务。给定每个任务的启动能量值和消耗能量值，求初始能量值的最小可能值。

例如，$n=3$，这 $3$ 个任务的启动能量值和消耗能量值分别是 $(2, 2)$、$(9, 5)$、$(7, 4)$。那么玩家初始能量的最小值为 $12$，可以按照如下顺序完成任务：

1. 完成任务 $(9, 5)$，玩家剩余能量值为 $7$；
2. 完成任务 $(7, 4)$，玩家剩余能量值为 $3$；
3. 完成任务 $(2, 2)$，玩家剩余能量值为 $1$。

尽管最后玩家的能量值剩余 $1$，但初始能量值无法再降低，否则完成任务 $(9, 5)$ 后，玩家的剩余能量值会小于任务 $(7, 4)$ 的启动能量值，导致无法开始该任务。

## 样例 #1

### 输入

```
3
2 2
9 5
7 4```

### 输出

```
12```

# AI分析结果



---

**唯一算法分类**：贪心算法

---

### **题解思路、算法要点与解决难点**

**核心思路**：  
按任务启动能量与消耗的差值（`x - y`）降序排列，优先处理差值大的任务。确保每次处理任务后的剩余能量尽可能多，从而降低后续任务的启动门槛。

**关键步骤**：  
1. **排序策略**：按 `x - y` 降序排列，若差值相同则按 `x` 降序排列。
2. **计算初始能量**：遍历排序后的任务，维护已消耗能量的总和 `sum_prev`。每个任务的初始能量需求为 `sum_prev + x_i`，最终取所有任务需求的最大值。

**解决难点**：  
- **排序正确性证明**：通过数学推导，交换两个任务的顺序后，初始能量需求的变化证明差值大的任务应优先处理。
- **高效计算**：直接线性遍历即可得到最小初始能量，无需二分，时间复杂度优化为 `O(n log n)`。

---

### **题解评分 (≥4星)**

1. **wenqinghua1001 (5星)**  
   - **亮点**：直接贪心计算，时间复杂度最优。代码简洁，通过维护 `sum_prev` 和最大值快速求解。
2. **FJ_EYoungOneC (4星)**  
   - **亮点**：使用二分法验证答案，思路清晰，但时间效率略低。
3. **Gilbert1206 (4星)**  
   - **亮点**：模拟能量补充过程，维护当前能量值 `ene`，直观体现贪心思想。

---

### **最优思路与技巧提炼**

1. **贪心排序策略**：  
   - 差值 `x - y` 越大，任务完成后剩余能量越多，应优先处理。
   - 差值相同时，按 `x` 降序排列，避免后续高启动需求的任务无法完成。
2. **线性计算初始能量**：  
   - 遍历时维护已消耗总和 `sum_prev`，初始能量为 `max(x_i + sum_prev)`。

---

### **同类型题与算法套路**

- **类似题目**：加油站问题（贪心选择加油站点）、区间调度（按结束时间排序）。
- **通用套路**：通过排序策略将问题转化为线性计算，确保每一步的最优选择。

---

### **推荐题目**

1. **洛谷 P1080** [国王游戏](https://www.luogu.com.cn/problem/P1080)  
   （贪心排序，乘积最大）
2. **洛谷 P1016** [旅行家的预算](https://www.luogu.com.cn/problem/P1016)  
   （贪心选择加油站）
3. **洛谷 P1233** [木棍加工](https://www.luogu.com.cn/problem/P1233)  
   （双关键字排序贪心）

---

### **代码实现（核心逻辑）**

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Task { int x, y; };

int main() {
    int n; cin >> n;
    vector<Task> tasks(n);
    for (auto &t : tasks) cin >> t.x >> t.y;
    
    sort(tasks.begin(), tasks.end(), [](const Task &a, const Task &b) {
        if (a.x - a.y != b.x - b.y) return a.x - a.y > b.x - b.y;
        return a.x > b.x;
    });

    int sum_prev = 0, ans = 0;
    for (const auto &t : tasks) {
        ans = max(ans, sum_prev + t.x);
        sum_prev += t.y;
    }
    cout << ans;
    return 0;
}
```

---

### **可视化与算法演示**

**动画设计**：  
1. **排序展示**：以像素风格显示任务图标，按 `x - y` 差值动态排序。
2. **能量计算**：  
   - 每一步高亮当前任务的 `x` 和 `sum_prev`，显示 `x + sum_prev`。
   - 用红色标记当前最大值，绿色显示已消耗总和 `sum_prev` 的累加。
3. **音效与交互**：  
   - 任务处理时播放“点击”音效，最大值更新时播放上扬音效。
   - 支持暂停/步进，观察每一步的 `sum_prev` 和 `x_i` 变化。

**复古风格**：  
- 8-bit 像素任务图标，背景循环播放 FC 风格音乐。
- Canvas 绘制动态网格，任务按排序后顺序排列，能量值以数字滚动显示。

---

**总结**：贪心排序策略是本题核心，通过差值排序和线性计算，确保每一步选择最优，最终得到最小初始能量。

---
处理用时：114.54秒
# 题目信息

# [NOIP 2003 提高组] 神经网络

## 题目背景

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。



## 题目描述

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)

神经元（编号为 $i$）


图中，$X_1 \sim X_3$ 是信息输入渠道，$Y_1 \sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)

兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）

$$C_i=\left(\sum\limits_{(j,i) \in E} W_{ji}C_{j}\right)-U_{i}$$

公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。



## 说明/提示

**【题目来源】**

NOIP 2003 提高组第一题

## 样例 #1

### 输入

```
5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
```

### 输出

```
3 1
4 1
5 1
```

# AI分析结果



### 综合分析与结论

**题目核心**：神经网络中的信号传递遵循层间依赖，需通过拓扑排序处理各节点状态。输入层节点初始激活，中间层和输出层通过公式计算，仅当状态>0时传递信号。

**难点解析**：
1. **阈值处理**：输入层不减去阈值，非输入层需在初始化时减去。
2. **状态传递条件**：仅当节点状态>0时才向下传递，需在拓扑中动态判断。
3. **输出层判断**：出度为0的节点为输出层，但需排除状态≤0的情况。

**最优思路**：利用拓扑排序的队列处理层次依赖，预处理阈值，动态维护节点状态。关键代码段如下：

```cpp
// 预处理阈值（非输入层）
for(int i=1; i<=n; ++i) {
    if (c[i] == 0) c[i] -= u[i];
}

// 拓扑排序核心
while (!q.empty()) {
    int u = q.front(); q.pop();
    if (c[u] <= 0) continue;
    for (Edge e : edges[u]) {
        c[e.v] += e.w * c[u];
        if (--in[e.v] == 0) q.push(e.v);
    }
}
```

---

### 题解清单（≥4星）

1. **Lucaster_**（⭐⭐⭐⭐⭐）  
   - **亮点**：队列拓扑排序，预处理阈值，代码简洁高效。  
   - **关键优化**：输入层直接入队，非输入层提前减阈值。  
   - **心得**：“拓扑排序不一定要用入度数组，某些情况下可用其他方法实现。”

2. **zzlzk**（⭐⭐⭐⭐）  
   - **亮点**：详细分析阈值处理，强调输入层特殊性。  
   - **关键点**：公式推导 `C[i] + U[i] = Σ(Wji*Cj)`，直接初始减阈值。

3. **faker121**（⭐⭐⭐⭐）  
   - **亮点**：栈实现拓扑排序，代码易读。  
   - **技巧**：入度为0的点直接处理，避免重复入队。

---

### 算法核心与可视化设计

**可视化思路**：
- **像素风格展示**：节点为颜色方块（绿色输入层、黄色中间层、红色输出层），箭头表示信号传递。
- **动态队列**：右侧显示当前处理队列，节点出队时高亮。
- **状态更新**：节点数值变化时闪烁，传递信号时显示数值流动动画。
- **音效**：节点激活时“叮”声，传递时“嗖”声，错误时“嗡”声。

**交互设计**：
- **步进控制**：支持暂停/继续，观察每一步状态变化。
- **自动模式**：AI自动执行拓扑排序，速度可调。

---

### 同类型题推荐

1. **P1113 杂物**（拓扑排序+任务调度）  
2. **P4017 最大食物链计数**（拓扑排序+路径统计）  
3. **P2742 电路维修**（DAG最短路径，拓扑应用）

---

### 个人心得摘录

- **Lucaster_**：“调了一天终于发现阈值处理顺序错误，输入层的U不能减！”  
- **zzlzk**：“公式移项后发现阈值只需减一次，避免重复计算。”  
- **faker121**：“栈实现拓扑反而更直观，但要注意入度更新的顺序。”

---

### 关键代码实现

**拓扑排序与状态更新**：
```cpp
void topological_sort() {
    queue<int> q;
    for (int i = 1; i <= n; ++i)
        if (in[i] == 0 && c[i] > 0) q.push(i);
    
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto &e : G[u]) {
            c[e.v] += e.w * c[u];
            if (--in[e.v] == 0 && c[e.v] > 0)
                q.push(e.v);
        }
    }
}
```

---

### 可视化代码片段（JavaScript）

```javascript
// 像素动画核心逻辑
function drawNode(node, state) {
    ctx.fillStyle = state === 'active' ? '#FFD700' : '#2ECC71';
    ctx.fillRect(node.x, node.y, 32, 32);
    ctx.fillText(`C:${node.c}`, node.x + 5, node.y + 12);
}

// 音效触发
function playSound(effect) {
    const audio = new Audio(`sfx/${effect}.wav`);
    audio.play();
}

// 自动执行拓扑
function autoStep() {
    if (queue.length > 0) {
        const u = queue.shift();
        highlightNode(u);
        processEdges(u);
        setTimeout(autoStep, speed);
    }
}
```

---

**总结**：本题通过拓扑排序处理层间依赖，阈值的预处理与状态传递判断是核心。可视化设计可增强对算法流程的理解，复古风格提升学习趣味性。

---
处理用时：76.95秒
# 题目信息

# [NOIP 2009 提高组] Hankson 的趣味题

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。

今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：

1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；

2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。

Hankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。


## 说明/提示

**【样例解释】**

第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。

第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。

**【数据范围】**

- 对于 $50\%$ 的数据，保证有 $1\leq a_0,a_1,b_0,b_1 \leq 10000$ 且 $n \leq 100$。
- 对于 $100\%$ 的数据，保证有 $1 \leq a_0,a_1,b_0,b_1 \leq 2 \times 10^9$ 且 $n≤2000$。

NOIP 2009 提高组 第二题


## 样例 #1

### 输入

```
2 
41 1 96 288 
95 1 37 1776 ```

### 输出

```
6 
2```

# AI分析结果



### 综合分析与结论

#### 核心思路与算法要点
题目要求找到满足以下两个条件的x的个数：
1. gcd(x, a₀) = a₁
2. lcm(x, b₀) = b₁

**关键解法**：通过数学性质发现x必须是b₁的因数，将枚举范围从O(b₁)优化至O(√b₁)。最优解法为枚举b₁的因子并验证两个条件。

#### 解决难点
1. **枚举范围优化**：利用x必须是b₁的因数，仅需枚举到√b₁即可覆盖所有可能值。
2. **条件验证**：对每个因数x需快速验证gcd和lcm条件，时间复杂度O(1)。
3. **边界处理**：平方数因子避免重复计数，特判x=√b₁的情况。

#### 题解评分（≥4星）

| 题解作者       | 评分 | 核心亮点                                                                 |
|----------------|------|--------------------------------------------------------------------------|
| zzlzk          | ★★★★☆ | 简洁的枚举法，利用因数成对特性减少循环次数，代码易实现。                  |
| cyh_toby       | ★★★★☆ | 清晰的枚举思路，代码结构简洁，包含关键注释，适合竞赛快速编码。            |
| Kexi_          | ★★★★  | 优化枚举范围至√b₁，通过分解因数对减少重复判断，代码可读性强。             |

---

### 最优思路与技巧提炼

#### 核心贪心策略
1. **因数成对枚举**：对于每个因数i，同步处理其对应的因数b₁/i，避免重复计算。
2. **条件验证顺序**：先检查是否为因数，再验证gcd和lcm条件，减少无效计算。
3. **平方数特判**：当i²=b₁时，仅计数一次，避免重复。

#### 关键代码片段
```cpp
for(int x=1; x*x<=b1; x++) {
    if(b1%x != 0) continue;
    int y = b1/x;
    // 检查x的条件
    if(gcd(x, a0)==a1 && lcm(x, b0)==b1) ans++;
    // 检查y的条件并避免重复
    if(x != y && gcd(y, a0)==a1 && lcm(y, b0)==b1) ans++;
}
```

---

### 同类型题目与算法套路

#### 通用解法
- **因数分解法**：适用于涉及gcd/lcm约束的问题，通过枚举因数优化计算。
- **质因数分析**：将条件转化为质因数的指数约束，适用于高数据范围场景。

#### 推荐题目
1. **P1029 最大公约数和最小公倍数问题**  
   （同类型因数枚举与条件验证）
2. **P1414 又是毕业季II**  
   （多数的gcd性质与因数分解）
3. **P2651 添加括号III**  
   （通过gcd/lcm性质进行数学推导）

---

### 可视化与算法演示

#### 复古像素风格设计
- **Canvas展示**：以网格形式动态显示b₁的因数分解过程，高亮当前枚举的因数i和b₁/i。
- **音效提示**：  
  - 发现有效因数时播放“金币音效” (↑音调)  
  - 无效因数时播放“错误音效” (↓音调)  
- **自动演示模式**：逐步展示每个因数的检查过程，速度可调，支持暂停/继续。

#### 动画流程
1. **初始化网格**：显示b₁的值及其因数分解式。
2. **枚举因数i**：左侧显示i，右侧显示b₁/i，高亮当前检查的因数对。
3. **条件验证**：显示gcd和lcm的计算结果，绿色通过，红色不通过。
4. **结果统计**：累计有效x的个数，动态更新计数板。

---

### 代码实现（核心贪心部分）

```cpp
#include <iostream>
using namespace std;

int gcd(int a, int b) { return b ? gcd(b, a%b) : a; }
int lcm(int a, int b) { return a / gcd(a, b) * b; }

int main() {
    int T; cin >> T;
    while (T--) {
        int a0, a1, b0, b1, ans = 0;
        cin >> a0 >> a1 >> b0 >> b1;
        for (int x = 1; x*x <= b1; x++) {
            if (b1 % x != 0) continue;
            int y = b1 / x;
            if (gcd(x, a0) == a1 && lcm(x, b0) == b1) ans++;
            if (x != y && gcd(y, a0) == a1 && lcm(y, b0) == b1) ans++;
        }
        cout << ans << endl;
    }
    return 0;
}
```

---

### 总结与扩展
本题通过巧妙的因数枚举和数学性质应用，将时间复杂度从O(b₁)优化至O(√b₁)，是典型的竞赛思维优化案例。掌握因数分解与条件验证的结合，能高效解决类似约束问题。

---
处理用时：76.74秒
# 题目信息

# 排队接水

## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。


## 说明/提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。


## 样例 #1

### 输入

```
10 
56 12 1 99 1000 234 33 55 99 812```

### 输出

```
3 2 7 8 1 4 9 6 10 5
291.90
```

# AI分析结果



### 综合分析与结论

**核心思路**：所有题解均采用贪心策略，按接水时间从小到大排序。数学证明表明，相邻两人交换位置时，时间更短者在前可减少总等待时间。总时间计算公式为：Σ(Ti × (n-i))，其中i为排序后的索引，n-i表示后续需等待的人数。

**贪心策略验证**：
1. **局部最优推导全局最优**：通过比较相邻两人的总时间差，证明交换后总时间减少，反推整体最优需保持升序排列。
2. **排序不等式**：总时间为时间序列与权重序列的点积，升序排列时点积最小。

**难点与解决**：
- **序号保留**：通过结构体、pair、数值编码等方式在排序时保留原始序号。
- **时间计算**：正确实现总时间公式，注意浮点数精度处理。

**可视化设计**：
- **像素动画**：用Canvas绘制队列，当前接水者高亮（红色），后续等待者灰色，每步显示时间累积。
- **音效反馈**：选择时触发“滴答”声，总时间更新时播放上升音调。
- **自动演示**：按排序顺序逐步执行，可调节速度观察贪心过程。

---

### 题解评分（≥4星）

1. **BlueArc（★★★★☆）**
   - **亮点**：结构体清晰，独立计算等待时间公式，避免双重循环。
   - **代码**：通过(n-i)权重直接计算，时间复杂度O(n)。
   - **心得**：“注意第一个人不需要等待”点明计算起点。

2. **Anguei（★★★★☆）**
   - **亮点**：使用`std::pair`简化代码，利用默认排序规则。
   - **优化**：动态数组减少内存占用，代码简洁高效。
   - **注意点**：强调总时间变量必须为double型。

3. **封禁用户（冒泡版）（★★★☆☆）**
   - **适用场景**：教学冒泡排序与贪心结合，但效率较低（O(n²)）。
   - **不足**：未用STL sort，代码冗余，但适合新手理解。

---

### 最优思路与代码实现

**核心贪心逻辑**：
```cpp
struct Person { int time, id; };
sort(persons, persons + n, [](auto& a, auto& b) {
    return a.time < b.time; // 按时间升序排序
});

double total = 0;
for (int i = 0; i < n; ++i) {
    total += persons[i].time * (n - i - 1); // 计算总等待时间
}
printf("%.2f", total / n);
```

**完整代码（结构体+sort）**：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

struct Person { int time, id; };

int main() {
    int n; cin >> n;
    Person p[1001];
    for (int i = 0; i < n; ++i) {
        cin >> p[i].time;
        p[i].id = i + 1;
    }
    sort(p, p + n, [](auto& a, auto& b) {
        return a.time < b.time || (a.time == b.time && a.id < b.id);
    });
    
    double sum = 0;
    for (int i = 0; i < n; ++i) {
        cout << p[i].id << " ";
        sum += p[i].time * (n - i - 1);
    }
    printf("\n%.2f", sum / n);
    return 0;
}
```

---

### 相似题目推荐
1. **P1090 合并果子**：贪心选择最小堆，每次合并最小两堆。
2. **P1220 关路灯**：区间动态规划，决策关闭顺序。
3. **P5019 铺设道路**：贪心选择连续区间填坑。

---

### 可视化方案（复古像素版）
```html
<canvas id="queueCanvas"></canvas>
<script>
const canvas = document.getElementById('queueCanvas');
const ctx = canvas.getContext('2d');
let persons = [...]; // 排序后的数据
let currentStep = 0;
let totalTime = 0;

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    persons.forEach((p, i) => {
        ctx.fillStyle = i === currentStep ? '#FF0000' : '#888888';
        ctx.fillRect(i * 30, 50, 25, 25); // 绘制接水者方块
        ctx.fillText(p.time, i * 30 + 5, 45);
    });
    ctx.fillText(`Total: ${totalTime.toFixed(2)}`, 10, 20);
}

function nextStep() {
    if (currentStep >= persons.length) return;
    totalTime += persons[currentStep].time * (persons.length - currentStep - 1);
    currentStep++;
    draw();
    // 触发音效（模拟8-bit音效）
    const beep = new Audio('data:audio/wav;base64,...');
    beep.play();
}
// 自动播放每0.5秒执行一步
setInterval(nextStep, 500);
</script>
```

**交互设计**：
- **步进控制**：按钮绑定`nextStep`函数。
- **音效**：使用Base64编码的短促音效，模拟复古风格。
- **颜色反馈**：当前处理对象红色高亮，其余灰色。

---

### 总结
贪心策略在排序问题中广泛应用，关键在于正确性证明与高效实现。通过结构体或数值处理保留序号，结合O(n log n)排序，可高效解决问题。可视化通过动态反馈加深对贪心选择的理解，复古风格增强学习趣味性。

---
处理用时：87.80秒
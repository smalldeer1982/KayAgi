# 题目信息

# 坚果保龄球

## 题目描述

PVZ 这款游戏中，有一种坚果保龄球。zombie 从地图右侧不断出现，向左走，玩家需要从左侧滚动坚果来碾死他们。

我们可以认为地图是一个行数为 $6$，列数为 $60$ 的棋盘。zombie 出现的那一秒站在这一行的第 $60$ 列，之后每秒向左移动一步。玩家可以随时在屏幕最某一行第一列摆放坚果，这一行的 zombie 瞬间全被滚过去的坚果碾死。如果 zombie 走到第 $1$ 列没有被消灭，如果再向左走，则你的大脑就会被 zombie 吃掉。

现在有 $n$ 只 zombie！告诉你每只 zombie 出现的时间以及在出现的行数（可能会同时出现同一位置的僵尸），请问至少需要多少坚果才能消灭所有的 zombie。

## 说明/提示

### 数据范围及约定

对于全部数据，$n \le 2000$，$t \le 100000$，$1 \le P \le 6$。

### 题目来源

kkksc03 改编


## 样例 #1

### 输入

```
10
1 1
1 61
2 1
2 60
3 1
3 2
3 3
3 4
4 1
4 99999```

### 输出

```
6```

# AI分析结果



### 综合分析与结论

**题目核心**：在 6 行的棋盘上，用最少的坚果消灭所有僵尸。僵尸从右侧出现，每秒左移一列，玩家可在任意时间放置坚果消灭整行僵尸。

**核心难点**：
1. **贪心策略**：需在僵尸到达第 1 列前放置坚果，同时覆盖尽可能多的僵尸。
2. **时间处理**：正确计算僵尸的存活时间区间（出现时间 `t` 至 `t+59`），确保坚果放置时间覆盖该区间。

**算法要点**：
1. **分治处理每行**：各行独立，按行分组僵尸。
2. **排序与贪心**：将每行僵尸按出现时间排序，每次选择最早未被覆盖的僵尸，放置坚果并覆盖后续 60 秒内的所有僵尸。
3. **双指针跳跃**：用指针快速跳过已覆盖的僵尸，保证线性时间复杂度。

**可视化设计**：
- **动画方案**：展示每行时间轴，用不同颜色标记覆盖窗口，动态显示贪心选择。
- **复古风格**：8-bit 像素风，僵尸从右侧移动，坚果放置时高亮覆盖区域。
- **交互功能**：步进控制、速度调节，音效提示覆盖成功或失败。

---

### 题解清单（≥4星）

1. **x义x（赞：159）**  
   **亮点**：双指针法跳跃处理每行，代码简洁高效。  
   **代码**：将出现时间加 60 后排序，通过循环快速定位覆盖区间终点。  
   **评分**：⭐⭐⭐⭐⭐

2. **灵乌路空（赞：19）**  
   **亮点**：结构体排序，维护最后覆盖时间，逻辑清晰。  
   **评分**：⭐⭐⭐⭐

3. **zy小可爱ღ（赞：7）**  
   **亮点**：结构体排序后遍历，动态更新覆盖点，代码易读。  
   **评分**：⭐⭐⭐⭐

---

### 最优思路与代码实现

**贪心策略**：按行分组，每行按出现时间排序，每次覆盖连续 60 秒内的所有僵尸。

**代码片段**（x义x的核心逻辑）：
```cpp
for (int i = 1; i <= 6; i++) {
    sort(t[i] + 1, t[i] + 1 + j[i]); // 按出现时间排序
    int x = 1;
    while (x <= j[i]) {
        ans++;
        int x1 = x;
        while (x1 <= j[i] && t[i][x1] < t[i][x] + 60) x1++;
        x = x1;
    }
}
```

**完整代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t[7][2001], n, ans;

int main() {
    cin >> n;
    int j[7] = {0};
    for (int i = 1; i <= n; i++) {
        int p, time; cin >> p >> time;
        t[p][++j[p]] = time + 60; // 存储出现时间+60
    }
    for (int i = 1; i <= 6; i++) {
        sort(t[i] + 1, t[i] + 1 + j[i]);
        int x = 1;
        while (x <= j[i]) {
            ans++;
            int x1 = x;
            while (x1 <= j[i] && t[i][x1] < t[i][x] + 60) x1++;
            x = x1;
        }
    }
    cout << ans;
}
```

---

### 同类型题目推荐

1. **P1803 凌乱的yyy / 线段覆盖**：区间调度，选择最多不重叠区间。
2. **P2240 部分背包问题**：贪心选择单位价值最高的物品。
3. **P1223 排队接水**：排序使总等待时间最小。

---

### 个人心得摘录

- **调试细节**：注意题目行数为 6 而非 5，易导致数组越界（x义x）。
- **时间转换**：正确计算存活区间，如出现时间 `t` 的右端点为 `t+59`（灵乌路空）。

---

### 可视化与复古游戏化设计

1. **动画设计**：
   - **Canvas 网格**：每行显示为横向时间轴，僵尸从右侧（第 60 列）向左移动。
   - **覆盖窗口高亮**：坚果放置时，绿色覆盖块标记 60 秒窗口，消灭范围内僵尸。
   - **音效**：放置坚果时触发 8-bit 音效，僵尸消灭时播放爆炸声。

2. **交互功能**：
   - **步进控制**：手动点击或自动播放，观察贪心选择过程。
   - **速度调节**：滑动条控制动画速度，适应不同学习节奏。

3. **复古元素**：
   - **像素风格**：僵尸与坚果用 8-bit 精灵图表示。
   - **背景音乐**：循环播放经典 FC 风格 BGM，增强沉浸感。

**示例动画伪代码**：
```javascript
// 伪代码：绘制覆盖窗口
function drawCover(startTime, row) {
    ctx.fillStyle = 'rgba(0,255,0,0.3)';
    ctx.fillRect(startTime * scale, row * cellSize, 60 * scale, cellSize);
    playSound('cover'); // 触发覆盖音效
}
```

---

**总结**：通过贪心覆盖每行的连续时间段，结合排序与双指针跳跃，高效求解最少坚果数。正确理解时间区间与覆盖条件是解题关键。

---
处理用时：508.97秒
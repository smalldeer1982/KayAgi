# 题目信息

# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# AI分析结果



### 综合分析与结论

#### 核心算法思路
本题核心是通过并查集维护环形食物链关系。题解主要分为两类方法：
1. **扩展域并查集**（三倍空间法）：将每个动物拆分为3个维度（同类/猎物/天敌），通过集合合并维护三元关系
2. **带权并查集**：通过维护节点与父节点的权值（0-同类，1-被吃，2-吃父）推导关系

#### 解决难点对比
| 方法            | 难点                                                                 | 解决方案                                                                 |
|-----------------|--------------------------------------------------------------------|------------------------------------------------------------------------|
| 扩展域并查集       | 需要同时维护三个域的关系，合并逻辑复杂                                       | 每次操作合并三个维度集合，判断冲突时需检查猎物/天敌域                         |
| 带权并查集        | 路径压缩和合并时的权值计算易错                                              | 通过模3运算维护传递性，公式推导权值更新规则（如合并时权值= (原权值差 + 关系值) %3） |

#### 可视化设计思路
1. **扩展域演示**：用三个颜色区域展示同类/猎物/天敌域，合并时三色箭头同步移动
2. **带权值动画**：路径压缩时显示权值累加过程，关键步骤用音效提示（如合并成功用上升音调，冲突用警示音）
3. **复古像素风格**：动物用8bit像素表示，食物链关系用箭头动画，合并时产生像素粒子特效

---

### 题解清单（评分≥4★）

#### 1. Sooke（扩展域并查集） ★★★★★
**亮点**：
- 详尽的图形化示例解释三域合并逻辑
- 通过具体输入样例演示集合合并过程
- 代码实现清晰，变量命名规范

#### 2. 天泽龟（带权并查集） ★★★★☆
**亮点**：
- 数学推导权值传递公式（re[f1] = (re[b]-re[a]+3)%3）
- 提供打表验证方法，降低理解门槛
- 附调试经验："路径压缩打错导致改一小时"

#### 3. 远航之曲（带权并查集） ★★★★
**亮点**：
- 用r[x]表示节点与根的关系，推导判断公式
- 代码包含关系校验函数`bool p1/p2`
- 关键注释："权值的实质是沿有向边走到父节点的步数%3"

---

### 核心代码实现

#### 扩展域并查集（Sooke）
```cpp
void union_domains(int x, int y) {
    // 合并同类域、猎物域、天敌域
    fa[find(x)] = find(y);
    fa[find(x+n)] = find(y+n);
    fa[find(x+2*n)] = find(y+2*n);
}

bool check_conflict(int x, int y) {
    // 判断是否为同类关系冲突
    return find(x+n) == find(y) || find(x+2*n) == find(y);
}
```

#### 带权并查集（天泽龟）
```cpp
int find(int x) {
    if (x != fa[x]) {
        int root = find(fa[x]);
        d[x] = (d[x] + d[fa[x]]) % 3; // 路径压缩时更新权值
        fa[x] = root;
    }
    return fa[x];
}

void merge(int x, int y, int relation) {
    int fx = find(x), fy = find(y);
    fa[fx] = fy;
    d[fx] = (d[y] - d[x] + relation + 3) % 3; // 权值推导公式
}
```

---

### 同类型题目推荐
1. **P1525 关押罪犯**（扩展域经典应用）
2. **P1892 团伙**（二倍空间扩展域）
3. **P1196 银河英雄传说**（带权并查集基础）

---

### 可视化方案示例
```html
<div id="animation">
  <!-- 扩展域三列展示 -->
  <div class="domain" style="background:#FFE4B5">
    <div v-for="x in animals" :class="{active: x==selected}" 
         @click="select(x)">{{x}}</div>
  </div>
  <!-- 带权值关系箭头 -->
  <svg>
    <path v-for="link in links" :d="calcPath(link)" 
          :stroke="getColor(link.relation)"/>
  </svg>
</div>

<script>
// 合并动画示例
function animateMerge(x, y) {
  playSound('merge.wav') // 合并音效
  anime({
    targets: [xElem, yElem],
    translateX: (el,i) => i*100,
    backgroundColor: '#FF6B6B',
    easing: 'easeOutElastic'
  })
}
</script>
```

---

### 总结心得
1. **调试教训**：路径压缩时需同步更新权值（如忘记则关系推导错误）
2. **数学验证**：通过枚举所有9种情况验证权值传递公式的可靠性
3. **优化选择**：数据规模大时优先带权法（空间O(N) vs 扩展域O(3N)）
4. **思维突破**：将环形关系转化为模3运算，是处理周期性问题的重要技巧

通过结合扩展域的直观性和带权法的效率，配合游戏化可视化演示，可深刻理解环形关系的维护机制。

---
处理用时：72.69秒
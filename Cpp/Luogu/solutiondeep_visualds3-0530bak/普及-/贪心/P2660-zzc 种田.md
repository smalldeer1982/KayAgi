# 题目信息

# zzc 种田

## 题目背景

可能以后 zzc 就去种田了。


## 题目描述

田地是一个巨大的矩形，然而 zzc 每次只能种一个正方形,而每种一个正方形时 zzc 所花的体力值是正方形的周长，种过的田不可以再种，zzc 很懒还要节约体力去泡妹子，想花最少的体力值去种完这块田地，问最小体力值。

## 说明/提示

$1\le x,y\le 10^{16}$。

## 样例 #1

### 输入

```
1 10```

### 输出

```
40```

## 样例 #2

### 输入

```
2 2 ```

### 输出

```
8```

# AI分析结果



### 综合分析与结论

**题目核心**：将矩形分割为多个正方形，每次选择最大可能的边长，使总周长最小。  
**核心算法**：基于辗转相除法的贪心策略，时间复杂度 O(log(min(x,y)))。  
**贪心策略**：每次尽可能多地种植最大正方形（边长取较小边），通过取模快速缩小问题规模。  
**正确性证明**：局部最优（最大正方形）确保全局最优，数学归纳可证。

### 题解评分（≥4星）

1. **北海_Beihai（5星）**  
   - **亮点**：代码简洁高效，直接模拟GCD过程，O(log n)时间复杂度，完美处理1e16数据。  
   - **代码**：循环交换x和y，累加4*y*(x/y)，取模缩小规模。

2. **Zerosking（4星）**  
   - **亮点**：递归优化后通过一次性计算多个正方形，避免栈溢出，注释清晰。  
   - **心得**：处理大数时需优化递归次数，通过取模而非逐次减法。

3. **人间凡人（4星）**  
   - **亮点**：明确贪心思路，优化前后代码对比，强调大数处理。  
   - **关键优化**：一次性计算max/min次正方形，避免超时。

### 最优思路与技巧

1. **GCD式迭代**：每次用较小边作为正方形边长，累加周长后取模处理剩余部分。  
   ```cpp
   while(x && y){
       swap(x, y);
       ans += 4 * y * (x / y);
       x %= y;
   }
   ```
2. **数学优化**：用整除代替逐次减法，时间复杂度从O(n)降至O(log n)。  
3. **递归优化**：递归时传递取模后的余数，减少递归深度。

### 同类题目与算法套路

- **类似算法**：最大公约数、分治策略、几何分割问题。  
- **题目推荐**：  
  1. 洛谷 P1516（扩展欧几里得算法）  
  2. 洛谷 P3951（数学优化问题）  
  3. 洛谷 P1029（数论与公约数应用）

### 个人心得摘录

- **Zerosking**：递归必须优化大数处理，否则MLE；取模是减少递归次数的关键。  
- **灵光一闪**：未初始化变量导致WA，强调代码细节的重要性。  
- **Campione**：递归代码需注意参数交换与终止条件。

---

### 可视化与算法演示

**动画设计**：  
1. **像素风格**：Canvas绘制矩形，每次分割后剩余部分以不同颜色显示。  
2. **高亮操作**：当前选择的正方形用闪烁边框标记，显示边长和数量。  
3. **步进控制**：支持暂停/继续，调整速度观察每次取模过程。  
4. **音效提示**：  
   - 分割时播放“哔”声，背景音乐为8位循环旋律。  
   - 完成时播放胜利音效。  

**复古游戏化**：  
- **关卡模式**：将不同测试用例作为关卡（如1x10→40分，2x2→8分）。  
- **积分系统**：根据操作步数或速度给予奖励，连击加分。  

```javascript
// 示例代码（关键动画逻辑）
function drawRect(x, y) {
    ctx.fillStyle = '#8B00FF'; // 紫色像素块
    ctx.fillRect(0, 0, x * 10, y * 10); // 缩放显示
    // 触发音效
    beep(440, 50); // 每次分割播放440Hz音效
}
```

---

### 题解代码精选

**北海_Beihai（最优解）**  
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long x,y,ans=0;
    cin>>x>>y;
    while(x&&y){
        swap(x,y);
        ans+=4*y*(x/y);
        x%=y;
    }
    cout<<ans;
    return 0;
}
```

**Zerosking（优化递归）**  
```cpp
void kkk(long long x, long long y) {
    if(x == y) sum += x * 4;
    else {
        sum += min(x,y) * 4 * (max(x,y)/min(x,y));
        kkk(min(x,y), max(x,y) % min(x,y));
    }
}
```

---

**总结**：本题核心在于快速贪心策略与数学优化，将问题转化为GCD式迭代。可视化设计可通过复古像素动画增强理解，推荐掌握核心迭代代码以应对类似问题。

---
处理用时：76.59秒
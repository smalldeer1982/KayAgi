# 题目信息

# [AHOI2016初中组] 自行车比赛

## 题目描述

小雪非常关注自行车比赛，尤其是环滨湖自行车赛。一年一度的环滨湖自行车赛，需要选手们连续比赛数日，最终按照累计得分决出冠军。今年一共有 $N$ 位参赛选手。每一天的比赛总会决出当日的排名，第一名的选手会获得 $N$ 点得分，第二名会获得 $N-1$ 点得分，第三名会获得 $N-2$ 点得分，依次类推，最后一名会获得 $1$ 点得分。保证没有选手会排名相同。


在之前的数日较量中，$N$ 位选手已经分别累计了一些分数。现在即将开始的是最后一天的比赛。小雪希望知道有多少位选手还有可能获得最终的冠军，也就是说还有多少选手有可能通过最后一天的比赛获得累计总分第一名。


## 说明/提示

### 数据范围及约定

- 对于 $20\% $ 的数据，$3\le N\le 600$。
- 对于 $50\%$  的数据，$3\le N\le 1\times 10^4$。
- 对于 $100\%$ 的数据，$3\le N\le 3\times 10^5$ 且 $0\le B_i\le 2\times 10^6$。


## 样例 #1

### 输入

```
3
8
10
9```

### 输出

```
3```

## 样例 #2

### 输入

```
5
15
14
15
12
14```

### 输出

```
4```

# AI分析结果



### 综合分析与结论

**题目核心**：判断每位选手通过最后一轮比赛是否能成为总分冠军。关键在于贪心策略的正确应用，确保其他选手在最优情况下（对当前选手最有利）的总分不超过当前选手的可能总分。

**贪心策略与难点**：
1. **贪心选择**：当前选手必须获得最后一轮的最高分（N分），其他选手的得分分配需尽可能小，尤其是原分更高的选手。
2. **正确性验证**：通过排序与预处理，计算原分高的选手在最优分配后的总分最大值，与当前选手的总分（原分 + N）比较。
3. **时间复杂度优化**：通过排序和一次遍历，将复杂度控制在 O(N log N)。

**题解对比**：
- **小粉兔 & _ZZH**：均通过排序预处理，将原分高的选手分配更低的最后一天得分，并计算最大值，正确且高效。
- **其他解法**：思路类似但代码实现或排序方向不同，部分存在冗余步骤（如重复排序），但总体正确。

### 题解评分（≥4星）

1. **小粉兔（5星）**
   - **亮点**：思路清晰，代码简洁，预处理排序与贪心结合紧密，直接通过一次遍历计算最大值，效率极高。
   - **代码可读性**：变量命名明确，注释合理，适合教学。
   - **核心代码**：
     ```cpp
     sort(b+1, b+n+1); // 升序排序
     for(int i=1; i<=n; i++) c[i] = b[i] + (n - i + 1); // 原分高的选手分配更小得分
     ```

2. **_ZZH（5星）**
   - **亮点**：降序排序后直接计算 `maxx = max(b[i] + i)`，逻辑直观，代码更短。
   - **实践性**：无需额外数组，直接遍历更新最大值，适合竞赛快速实现。
   - **核心代码**：
     ```cpp
     sort(b+1, b+n+1, greater<int>()); // 降序排序
     for(int i=1; i<=n; i++) maxx = max(maxx, b[i] + i); // 计算总分最大值
     ```

3. **PolyLoger（4星）**
   - **亮点**：使用后缀最大值优化，动态计算当前选手是否可行，代码逻辑清晰。
   - **创新点**：通过逆序遍历与 `biggest` 数组避免重复比较，适合大范围数据。

### 最优思路提炼

1. **排序预处理**：将选手按原分升序或降序排序，便于贪心分配最后一天的得分。
2. **得分分配策略**：
   - 对原分高的选手，在最后一天分配尽可能低的得分（升序排序时，分配 `n-i+1` 分；降序排序时，分配 `i` 分）。
3. **最大值比较**：计算所有选手在最优分配后的总分最大值，若当前选手的总分（原分 + N）≥ 该最大值，则可能获胜。

### 同类型题目推荐

1. **活动选择问题**（洛谷 P1803）：贪心选择最早结束的活动。
2. **区间覆盖问题**（洛谷 P1514）：选择覆盖当前起点的最长区间。
3. **合并果子**（洛谷 P1090）：每次合并最小两堆，优先队列实现。

### 可视化算法演示（贪心过程）

**动画设计**：
1. **像素风格界面**：选手以不同颜色的方块表示，高度代表原分。
2. **贪心步骤**：
   - **排序阶段**：方块按高度排序，动态显示排序过程。
   - **得分分配**：当前选手高亮显示，最后一轮得分以数字浮现在其上方。
   - **比较阶段**：其他选手的最终总分以颜色渐变显示（绿色表示总分 ≤ 当前选手，红色反之）。
3. **交互功能**：
   - **步进控制**：手动点击或自动播放，观察每一步的贪心选择。
   - **音效反馈**：正确选择时播放清脆音效，错误时低沉提示。

**示例动图描述**：
- 初始乱序方块排序后对齐。
- 当前选手（黄色方块）获得 N 分，其他高分的选手依次被分配 1、2 分等。
- 最终总分比较时，符合条件的选手边框闪烁绿色。

### 核心代码实现（小粉兔版）

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n, b[300001], c[300001], mx = 0, ans = 0;

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &b[i]);
    sort(b + 1, b + n + 1); // 升序排序
    for (int i = 1; i <= n; i++) {
        c[i] = b[i] + (n - i + 1); // 计算原分高选手的最优分配总分
        mx = max(mx, c[i]); // 更新全局最大值
    }
    for (int i = n; i >= 1; i--) {
        if (b[i] + n >= mx) ans++; // 当前选手总分是否足够
        else break; // 后续选手原分更低，无需判断
    }
    printf("%d", ans);
    return 0;
}
```

**代码核心**：
- 排序后计算每个选手在最优分配后的总分（`c[i]`）。
- 逆序遍历原分数组，统计满足条件的选手数量。

---
处理用时：244.81秒
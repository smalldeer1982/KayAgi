# 题目信息

# 母舰

## 题目背景

广东汕头聿怀初中 Train#3 Problem 1

（有没有红警既视感~）


## 题目描述

在小 A 的星际大战游戏中，一艘强力的母舰往往决定了一场战争的胜负。一艘母舰的攻击力是普通的 MA（Mobile Armor）无法比较的。

对于一艘母舰而言，它是由若干个攻击系统和若干个防御系统组成的。两艘母舰对决时，一艘母舰会选择用不同的攻击系统去攻击对面母舰的防御系统。当这个攻击系统的攻击力大于防御系统的防御力时，那个防御系统会被破坏掉。当一艘母舰的防御系统全部被破坏掉之后，所有的攻击都会攻击到敌方母舰本身上去造成伤害。

这样说，一艘母舰对对面的伤害在一定程度上是取决于选择的攻击对象的。

在瞬息万变的战场中，选择一个最优的攻击对象是非常重要的。所以需要写出一个战斗系统出来，判断出你的母舰最多能对对手造成多少伤害并加以实现。


## 说明/提示

#### 样例解释 #1

对方防御系统有 $3$ 个，防御值为 $1000(a),2000(b),1200(c)$，己方攻击系统有 $5$ 个，攻击值为 $2100(d)，2000(e),1200(f),1000(g),1000(h)$。第 $1$ 轮攻击的最优方案是 $d$ 攻击 $b$，$e$ 攻击 $c$，$f$ 攻击 $a$，$g$ 和 $h$ 攻击对方母舰本身，造成 $2000$ 点伤害。

#### 数据范围与约定

对于 $80 \%$ 的数据，$1 \le N,M \le 1000$。

对于 $100 \%$ 的数据，$1 \le N,M \le 10 ^ 5$。


本题为转载题目。

## 样例 #1

### 输入

```
3 5 
1000 
2000 
1200 
2100 
2000 
1200 
1000 
1000```

### 输出

```
2000```

# AI分析结果



### 综合分析与结论

**题目核心思路**  
母舰对决的贪心策略关键在于：用最小攻击破坏防御系统，保留大攻击输出母舰。正确步骤为：
1. 将防御和攻击数组分别升序排序。
2. 双指针遍历，为每个防御找最小可用攻击。
3. 若所有防御被破坏，总伤害为攻击总和减去已用攻击的总和；否则输出0。

**贪心策略要点**  
- **排序**：确保从小到大匹配攻击与防御，保留大攻击。
- **双指针遍历**：防御指针`j`和攻击指针`i`，若`attack[i] > defense[j]`则匹配成功。
- **边界处理**：防御值为0时需攻击>0才能破坏。

**正确性验证难点**  
- 防御为0时需严格匹配，避免错误跳过。
- 确保所有防御被破坏后才计算剩余攻击。

### 题解评分（≥4星）

1. **作者：Rbu_nas（4星）**  
   **亮点**：使用`upper_bound`快速定位最小可用攻击，逻辑清晰。  
   **缺点**：未处理`upper_bound`越界问题，可能导致错误。

2. **作者：Salièri（3星）**  
   **亮点**：双指针遍历，逻辑简洁。  
   **缺点**：错误累加未使用的攻击，导致总伤害计算错误。

3. **作者：sjl40（3星）**  
   **亮点**：基本思路正确，处理了防御为0的特殊情况。  
   **缺点**：防御为0时直接跳过，可能导致逻辑错误。

### 最优思路与代码实现

**核心贪心逻辑**  
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int MAX = 1e5 + 5;
int defense[MAX], attack[MAX];

int main() {
    int m, n;
    cin >> m >> n;
    if (n < m) {
        cout << 0 << endl;
        return 0;
    }
    for (int i = 0; i < m; ++i) cin >> defense[i];
    for (int i = 0; i < n; ++i) cin >> attack[i];
    sort(defense, defense + m);
    sort(attack, attack + n);
    
    int i = 0, j = 0;
    long long sum_used = 0;
    while (i < n && j < m) {
        if (attack[i] > defense[j]) {
            sum_used += attack[i];
            i++; j++;
        } else {
            i++;
        }
    }
    if (j == m) {
        long long total = 0;
        for (int k = 0; k < n; ++k) total += attack[k];
        cout << total - sum_used << endl;
    } else {
        cout << 0 << endl;
    }
    return 0;
}
```

### 同类型题与扩展

**相似题目类型**  
- **区间调度问题**：如选择不重叠区间的最大数量。
- **最小覆盖问题**：如用最少的箭引爆气球。
- **资源分配问题**：如任务调度中的最优分配。

**推荐题目**  
1. P1233 木棍加工（贪心排序）
2. P2512 糖果传递（中位数贪心）
3. P1094 纪念品分组（双指针贪心）

### 可视化设计思路

**贪心过程动画**  
- **Canvas动态演示**：用不同颜色方块表示防御和攻击，绿色表示已匹配，红色表示未破坏。
- **步进控制**：用户可调整速度，观察双指针移动和匹配过程。
- **音效提示**：匹配成功时播放清脆音效，失败时低沉音效。

**复古像素风格**  
- **8-bit元素**：防御和攻击以像素块呈现，攻击命中时像素爆炸效果。
- **自动演示模式**：AI模拟决策流程，动态高亮当前比较的防御和攻击。

### 个人心得摘录

- **排序是关键**：正确的排序策略是贪心成功的基础。
- **边界处理易错**：防御为0时需严格检查攻击是否足够。
- **总伤害计算**：总和相减比逐项累加更高效且不易出错。

---
处理用时：496.05秒
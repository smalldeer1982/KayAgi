# 题目信息

# 小A的糖果

## 题目描述

小 A 有 $n$ 个糖果盒，第 $i$ 个盒中有 $a_i$ 颗糖果。

小 A 每次可以从其中一盒糖果中吃掉一颗，他想知道，要让任意两个相邻的盒子中糖的个数之和都不大于 $x$，至少得吃掉几颗糖。


## 说明/提示

#### 样例输入输出 1 解释

吃掉第 2 盒中的一个糖果即可。

---

#### 样例输入输出 2 解释

第 2 盒糖吃掉 $6$ 颗，第 4 盒吃掉 $2$ 颗，第 6 盒吃掉 $3$ 颗。

---

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 20$，$a_i, x \leq 100$。
- 对于 $70\%$ 的数据，保证 $n \leq 10^3$，$a_i, x \leq 10^5$。
- 对于 $100\%$ 的数据，保证 $2 \leq n \leq 10^5$，$0 \leq a_i, x \leq 10^9$。

## 样例 #1

### 输入

```
3 3
2 2 2```

### 输出

```
1
```

## 样例 #2

### 输入

```
6 1
1 6 1 2 0 4```

### 输出

```
11```

## 样例 #3

### 输入

```
5 9
3 1 4 1 5```

### 输出

```
0
```

# AI分析结果



### 综合分析与结论

**题目核心**：通过贪心策略调整相邻糖果盒的和，使其不超过x，同时最小化吃掉的糖果数。  
**解决难点**：贪心选择必须确保每一步调整后的结果不影响后续处理，且不能出现负数。  
**关键贪心策略**：按顺序处理每个相邻对，优先调整后面的盒子，确保其值变为 `x - 前一个盒子的值`。此策略保证当前对的合法性，同时为后续处理提供最优基础。

**算法正确性证明**：  
- 每一步调整后，当前相邻对的和严格等于x或合法。  
- 由于处理顺序是从左到右，调整后面的盒子不会影响已处理的前面对，且后续处理会基于当前调整后的值。

**可视化设计思路**：  
- **像素风格动画**：用8位像素方块表示糖果数，当前处理的对高亮为红色，调整后变为绿色。  
- **音效提示**：调整时播放清脆音效，成功合法后播放确认音。  
- **步进控制**：支持单步执行、暂停、自动播放，速度可调。  
- **数据跟踪**：实时显示当前处理的对、总吃掉数、各盒子糖果数的动态变化。

---

### 题解清单（≥4星）

1. **a___（5星）**  
   - **亮点**：简洁高效，边输入边处理，仅用两个变量滚动计算。  
   - **关键代码**：  
     ```cpp
     if (a[i] + a[i-1] > x) {
         yy = a[i] + a[i-1] - x;
         a[i] -= yy;
         ans += yy;
     }
     ```

2. **xu222ux（5星）**  
   - **亮点**：代码极简，处理逻辑清晰，无需额外数组。  
   - **关键代码**：  
     ```cpp
     if (a[i] + a[i-1] > x) {
         ans += a[i] + a[i-1] - x;
         a[i] = x - a[i-1];
     }
     ```

3. **Goes（5星）**  
   - **亮点**：无数组实现，仅用两个变量滚动，空间复杂度O(1)。  
   - **关键代码**：  
     ```cpp
     long long del = max((now + nex - x), 0LL);
     nex = now - del;
     ans += del;
     ```

---

### 最优思路提炼

**贪心策略**：  
1. **调整后盒**：每次处理相邻对时，优先减少后一个盒子的值到 `x - 前一个值`。  
2. **滚动处理**：仅需记录前一个盒子的值，无需保存整个数组。  
3. **数学保证**：前一个盒子已被处理，确保 `x - 前一个值 ≥ 0`，避免负数。

**实现技巧**：  
- 边输入边处理，减少内存占用。  
- 用 `max(0, ...)` 确保不吃负糖果。  
- 使用 `long long` 防止数据溢出。

---

### 同类型题目推荐

1. **P1095 守望者的逃离**：贪心选择技能使用顺序。  
2. **P1223 排队接水**：经典贪心排序问题。  
3. **P1803 线段覆盖**：活动选择问题的变形。

---

### 个人心得摘录

- **数据范围**：`long long` 是必须的，否则大数测试点会WA。  
- **边界处理**：初始前一个盒子为0，避免单独处理第一个盒子的情况。  
- **贪心正确性**：无需处理单个盒子，仅关注相邻和即可。

---

### 可视化代码片段（复古风格）

```javascript
// 示例：Canvas绘制像素盒子
function drawBoxes(boxes, currentPair) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    boxes.forEach((val, idx) => {
        ctx.fillStyle = (idx === currentPair || idx === currentPair + 1) ? '#FF0000' : '#00FF00';
        ctx.fillRect(idx * 30, 100 - val * 5, 25, val * 5);
    });
}

// 贪心过程模拟
function simulateGreedy() {
    let prev = 0, sum = 0;
    for (let i = 0; i < boxes.length; i++) {
        if (i > 0 && boxes[i] + prev > x) {
            const eat = boxes[i] + prev - x;
            boxes[i] = x - prev;
            sum += eat;
            playSound('eat'); // 音效触发
        }
        prev = boxes[i];
        drawBoxes(boxes, i);
    }
}
```

---

**总结**：本题通过贪心策略逐步调整相邻对，确保每一步的最优选择，最终达到全局最优。可视化设计通过复古风格和交互式操作，帮助理解贪心的动态过程。

---
处理用时：343.83秒
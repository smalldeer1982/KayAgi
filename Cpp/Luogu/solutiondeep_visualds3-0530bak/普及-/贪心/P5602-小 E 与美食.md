# 题目信息

# 小 E 与美食

## 题目背景

小 E 是一个热爱美食的高中生，但吃的太多会导致他身体不舒服，他想找到一个能让他最舒服的方案，快来帮帮他！

## 题目描述

小 E 有 $n$ 种美食可供选择，每种美食只能吃一次，第 $i$ 种美食有一个美味值 $a_i$，吃下一个美味值为 $a_i$ 的美食可以让小 E 的满足感提升 $a_i$。

但是小 E 的胃是有极限的，每吃下一个美食，他的饱腹感就会提升 $1$。

小 E 最后的舒适度是他的满足感的平方除以他的饱腹感，你的目标是求出他舒适度能达到的最大值。

## 说明/提示

**提示**

建议输出**至少 $8$ 位**有效数字。

**样例解释**

容易发现两种美食都吃是最优的，舒适度为 $\frac{(2+1)^2}{2} = 4.5$。

**数据范围**

对于 $30 \%$ 的数据，$n, a_i \le 20$。

对于 $50 \%$ 的数据，$n, a_i \le 2000$。

对于另 $15 \%$ 的数据，所有 $a_i$ 都相等。

对于 $100 \%$ 的数据，$1 \le n \le 3 \times 10^{5}$，$1 \le a_i  \le 10^6$。

## 样例 #1

### 输入

```
2
2 1```

### 输出

```
4.50```

# AI分析结果



### 综合分析与结论

**题目核心**：在满足饱腹感为k时，选择美味值最大的k个食物，使舒适度$(sum^2)/k$最大化。  
**贪心策略**：将美食按美味值降序排列，计算前缀和，遍历所有可能的k（1~n），取最大值。  
**解决难点**：正确排序避免中间结果溢出，需使用long long存前缀和，计算时转为double保证精度。  
**算法复杂度**：O(n log n)（排序）+ O(n)（遍历），适用于大数据范围。

### 题解评分（≥4星）

1. **lytqwq（5星）**  
   - 思路清晰，正确排序并遍历所有k，处理溢出问题（先除后乘）。  
   - 代码简洁，包含关键注释，适合教学。

2. **Magallan_forever（5星）**  
   - 使用前缀和数组优化计算，明确遍历所有k的正确性。  
   - 数学证明严谨，代码高效易读。

3. **VenusM1nT（4星）**  
   - 正确实现贪心策略，代码简洁。  
   - 缺少溢出处理的详细说明，但代码逻辑正确。

### 最优思路与技巧

- **排序降序**：优先选择高美味值。  
- **前缀和优化**：快速计算前k项总和。  
- **遍历所有k**：确保不漏掉任何可能的极值点。  
- **数据类型处理**：sum用long long，计算时转double避免溢出。

### 同类型题与算法套路

- **最大收益问题**：如选择k个元素使函数值最大。  
- **常见贪心场景**：区间调度、最小生成树（Kruskal）、分数背包。

### 推荐洛谷题目

1. P2949 [USACO09OPEN]Work Scheduling G  
2. P1230 智力大冲浪  
3. P2240 【深基12.例1】部分背包问题  

### 个人心得摘录

- **lytqwq**：强调sum平方可能溢出，需先除后乘。  
- **Magallan_forever**：指出贪心必须遍历所有k，不能提前终止。  
- **ViXpop**：初期误以为是背包问题，后通过分析发现贪心本质。

---

### 关键代码实现

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 3e5 + 5;
int a[N];
long long sum[N];

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
    sort(a + 1, a + n + 1, greater<int>()); // 降序排序
    
    double max_val = 0;
    for (int i = 1; i <= n; ++i) {
        sum[i] = sum[i - 1] + a[i]; // 前缀和
        max_val = max(max_val, (double)sum[i] * sum[i] / i);
    }
    printf("%.8lf\n", max_val);
    return 0;
}
```

---

### 可视化设计（复古像素风格）

1. **动画方案**：  
   - **Canvas网格**：每个像素块代表一个美食，颜色深浅表示美味值。  
   - **高亮选择**：已选美食用绿色标记，当前k值用黄色边框。  
   - **动态曲线**：右侧实时绘制舒适度随k变化的折线图，峰值点闪烁。

2. **交互功能**：  
   - **步进执行**：按空格逐步选择下一个美食，显示当前sum和舒适度。  
   - **自动播放**：AI以最佳速度演示贪心过程，背景音乐为8-bit风格。  
   - **音效反馈**：选中时播放“金币音效”，刷新最大值时播放“升级音效”。

3. **游戏化元素**：  
   - **连击积分**：连续正确选择增加连击分，错误选择重置。  
   - **成就系统**：首次达到峰值解锁“美食大师”成就。

---

### 算法演示（关键步骤）

1. **排序阶段**：数组从高到低排列，像素块按数值变色。  
2. **前缀和累加**：每选一个美食，更新sum并计算舒适度。  
3. **峰值追踪**：折线图动态更新，红色标记当前最大值。

**颜色标记**：  
- 红色：未选中美食  
- 绿色：已选中  
- 黄色：当前计算的k值位置  

**音效触发**：  
- 点击选择：短促“哔”声  
- 发现新峰值：上扬“叮咚”声  
- 错误操作：低沉“嗡”声  

---

通过上述设计，学习者可直观理解贪心策略的每一步选择及其对最终结果的影响，同时增强学习趣味性。

---
处理用时：104.39秒
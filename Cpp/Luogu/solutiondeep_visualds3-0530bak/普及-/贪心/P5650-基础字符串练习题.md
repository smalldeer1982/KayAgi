# 题目信息

# 基础字符串练习题

## 题目背景

YSGH 牛逼

## 题目描述

给定长度非零的非空 01 串 $S$。

找出 $S$ 的非空连续子串 $T$ 满足串中 0 的个数减去 1 的个数最大。

你只需要输出最大值即可。

## 说明/提示

设 $|S| = n$。

| 数据点编号 | $n \le$ |
| :--: | :--: |
| $1 \sim 2$ | $10$ |
| $3 \sim 6$ | ${10}^3$ |
| $7 \sim 10$ | ${10}^5$ |

对于 $100\%$ 的数据，$1 \le n \le {10}^5$。

## 样例 #1

### 输入

```
0111100101```

### 输出

```
2```

# AI分析结果



### 题解思路与算法要点

#### 核心思路
将问题转化为**最大子段和**问题：
- **0 视为 +1，1 视为 -1**，转化为数值数组。
- 寻找连续子数组使其和最大，即等价于原题的 0 与 1 的差值最大化。

#### 难点与解决
- **非空子串的特殊情况**：全 1 时需返回 -1。
- **高效计算**：避免暴力枚举所有子串（O(n²)），需用 O(n) 方法。

### 题解评分（≥4星）

#### 1. 贪心法（hwx12233，4.5星）
- **思路**：遍历时维护当前最优值，遇 0 加 1，遇 1 减 1（若负则重置为 0），同时更新全局最优。
- **亮点**：代码简洁，时间复杂度 O(n)，空间 O(1)。
- **代码**：
  ```cpp
  int ans1 = 0, ans2 = -1;
  for (int i = 0; i < n; i++) {
      if (s[i] == '0') {
          ans1++;
          ans2 = max(ans1, ans2);
      } else {
          ans1 = max(0, ans1 - 1);
      }
  }
  ```

#### 2. 动态规划（Inkyo，4星）
- **思路**：定义 `dp[i]` 为以 i 结尾的最优解，转移方程为：
  ```python
  dp[i] = max(dp[i-1] + val, val)  # val 为当前字符的贡献（+1 或 -1）
  ```
- **亮点**：明确的状态转移，直观体现最大子段和的 DP 思想。

#### 3. 前缀和优化（大头，4星）
- **思路**：维护前缀和 `sum` 和最小前缀 `minn`，最大差值为 `sum[i] - minn`。
- **代码**：
  ```cpp
  int sum = 0, minn = 0, ans = -1;
  for (char c : s) {
      sum += (c == '0' ? 1 : -1);
      ans = max(ans, sum - minn);
      minn = min(minn, sum);
  }
  ```

### 最优思路提炼
- **贪心策略**：遍历时若当前子数组和为负，则重置（舍弃前面部分），每一步维护局部最优。
- **关键技巧**：数值转化（0→+1，1→-1）将问题转化为经典模型。

### 同类型题目
1. **最大子段和**（[P1115](https://www.luogu.com.cn/problem/P1115)）
2. **跳跃游戏**（[P55](https://leetcode.cn/problems/jump-game/)）
3. **买卖股票的最佳时机 II**（[P122](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)）

---

### 可视化设计（贪心算法演示）

#### 动画方案
1. **像素风格**：用 8-bit 色块表示字符，绿色（0）和红色（1），数值显示为 +1/-1。
2. **当前子数组**：高亮黄色边框，实时显示累加值。
3. **重置步骤**：当累加值变负时，播放“错误”音效，并闪烁红色重置为 0。

#### 交互功能
- **步进控制**：按键逐帧执行，观察累加与重置逻辑。
- **自动模式**：AI 自动执行，速度可调。
- **音效反馈**：累加时播放上升音调，重置时短促提示音。

#### 示例代码（Canvas 绘制）
```javascript
// 绘制字符块
function drawBlock(ctx, x, y, val) {
    ctx.fillStyle = val === 1 ? '#00FF00' : '#FF0000';
    ctx.fillRect(x, y, 30, 30);
    ctx.fillStyle = '#000';
    ctx.fillText(val, x + 12, y + 20);
}

// 更新累加值动画
function updateSum(sum) {
    // 高亮当前累加区域，若 sum < 0 则重置
}
```

---

### 代码实现（贪心法）
```cpp
#include <iostream>
using namespace std;

int main() {
    string s;
    cin >> s;
    int current = 0, max_val = -1;
    bool has_zero = false;
    
    for (char c : s) {
        if (c == '0') {
            current++;
            has_zero = true;
        } else {
            current = max(current - 1, 0);
        }
        max_val = max(max_val, current);
    }
    
    cout << (has_zero ? max_val : -1);
    return 0;
}
```

**核心逻辑**：遍历字符串，动态维护 `current` 和 `max_val`，遇负重置。

---

### 总结
本题通过巧妙的数值转化将问题简化为经典最大子段和，贪心法以 O(n) 时间高效解决。可视化设计可通过动态高亮和音效强化理解，适合教学演示与交互学习。

---
处理用时：74.83秒
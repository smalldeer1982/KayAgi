# 题目信息

# [传智杯 #2 初赛] 1024 程序员节发橙子

## 题目描述

每年的 1024 程序员节日，黑马程序员都会举办大型的庆祝活动。今年的程序员节也不例外，每个班级的同学都发了橙子。

班级里有 $n$ 名同学从前到后排成一排，且已经得知了这些同学的成绩，其中第 $i$ 名同学的成绩是 $a_i$。班主任想根据同学们上个阶段的考试成绩来评定发橙子的数量。为了激励成绩优秀同学，发橙子时需要满足如下要求：

- 相邻同学中成绩好的同学的橙子必须更多。若相邻的同学成绩一样，则它们分到的数量必须平等。
- 每个同学至少分配一个橙子

由于预算有限，班主任希望在符合要求的情况下发出尽可能少的橙子。请问，至少需要准备多少橙子呢？

## 说明/提示

#### 样例 1 解释

每位同学拿到的橙子的数量分别是 $1,2,3,2,1$，所以至少需要准备 $9$ 个。

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 10^6$，$0 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
5
3 4 5 4 3```

### 输出

```
9```

# AI分析结果



# 算法分类选择  
**贪心算法**

---

## 题解思路、算法要点与解决难点  
### 核心思路  
所有题解均采用**两次贪心遍历**策略：  
1. **正序遍历**处理左→右递增关系：若 `a[i] > a[i-1]`，则橙子数递增；相等则相等  
2. **逆序遍历**处理右→左递增关系：若 `a[i] < a[i-1]`，则橙子数取最大值（`max(原值, 右侧+1)`）  
3. 合并两次遍历结果，总和即为最小值  

### 关键难点与解决方案  
1. **相邻相等处理**：在两次遍历中同步维护相等关系，直接继承相邻值  
2. **峰顶处理**：逆序遍历时需用 `max` 保留正序遍历结果，避免覆盖  
3. **数据范围**：总和需用 `long long` 存储，数组大小需开至 1e6+10  

---

## 题解评分（≥4星）  
### 1. 游戏的人（5星）  
**亮点**：  
- 代码最简洁，逻辑清晰  
- 使用单数组存储橙子数，空间效率高  
- 手绘图示辅助理解峰顶取最大值机制  

### 2. Chouquet（4.5星）  
**亮点**：  
- 详细注释每个遍历步骤的条件分支  
- 显式定义 `max` 宏提升代码可读性  
- 强调 `long long` 必要性  

### 3. _桀氓_（4星）  
**亮点**：  
- 将初始答案设为 `n`（每人至少1个），减少循环次数  
- 使用 `unsigned long long` 避免极端数据溢出  

---

## 最优思路与技巧提炼  
### 核心代码实现  
```cpp
#include <iostream>
using namespace std;
const int MAXN = 1e6 + 10;
int a[MAXN], t[MAXN];

int main() {
    int n; cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        t[i] = 1; // 初始每人1个橙子
    }
    // 正序遍历处理左→右递增
    for (int i = 2; i <= n; i++) {
        if (a[i] > a[i-1]) t[i] = t[i-1] + 1;
        else if (a[i] == a[i-1]) t[i] = t[i-1];
    }
    // 逆序遍历处理右→左递增，峰顶取max
    for (int i = n; i >= 2; i--) {
        if (a[i] < a[i-1]) t[i-1] = max(t[i-1], t[i] + 1);
        else if (a[i] == a[i-1]) t[i-1] = t[i];
    }
    long long ans = 0;
    for (int i = 1; i <= n; i++) ans += t[i];
    cout << ans;
    return 0;
}
```

### 技巧总结  
- **两次遍历方向**：正序处理左邻约束，逆序处理右邻约束  
- **变量复用**：仅用单数组 `t[]` 存储橙子数，空间复杂度 O(n)  
- **边界处理**：遍历从 `i=2` 开始，避免数组越界  

---

## 同类题型与算法套路  
### 相似题目  
1. **糖果传递**（[P2512](https://www.luogu.com.cn/problem/P2512)）  
   - 环形相邻约束，需数学推导最优解  
2. **接雨水**（[LeetCode 42](https://leetcode.com/problems/trapping-rain-water/)）  
   - 双指针处理左右边界约束  
3. **分糖果**（[LeetCode 135](https://leetcode.com/problems/candy/)）  
   - 与本题完全相同的两次遍历贪心策略  

---

## 可视化与算法演示  
### 动画设计（复古像素风格）  
1. **网格布局**：  
   - 每个同学显示为 16x16 像素方块，成绩以颜色渐变（低→绿，高→红）  
   - 橙子数以数字叠加在方块中央  

2. **遍历高亮**：  
   - 正序遍历时，当前 `i` 方块闪烁黄色边框，右侧显示 `←` 箭头  
   - 逆序遍历时，当前 `i` 方块闪烁蓝色边框，左侧显示 `→` 箭头  

3. **音效触发**：  
   - 橙子数变化时播放 "哔" 音效（8-bit 风格）  
   - 遍历完成时播放短促胜利音效  

4. **控制面板**：  
   - 速度滑块调节遍历速度（100ms~2s/步）  
   - 按钮切换正序/逆序单步执行  

### 算法流程演示  
1. **初始状态**：所有方块显示 `1`，背景色按成绩渐变  
2. **正序遍历**：  
   - 当 `a[i] > a[i-1]`，当前方块数值变为左侧+1，播放上升音效  
   - 当 `a[i] == a[i-1]`，数值同步左侧，播放平声音效  
3. **逆序遍历**：  
   - 当 `a[i] < a[i-1]`，左侧方块数值取 `max(原值, 当前+1)`，背景色加深  
   - 峰顶数值变化时闪烁三次红色  

---

## 个人心得摘录  
> "改了很多次，辛苦管理员大大，一定要开 long long！" —— 游戏的人  
> "为什么这么简单的题目比赛时没写出来……" —— Chouquet  
> "被 long long 坑了好几次，最后一个点 WA 到怀疑人生" —— _桀氓_  

**总结**：调试时优先检查数据类型和边界条件，贪心策略需严格验证方向性。

---

## 推荐题目  
1. [P1969 积木大赛](https://www.luogu.com.cn/problem/P1969)  
2. [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)  
3. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)

---
处理用时：82.81秒
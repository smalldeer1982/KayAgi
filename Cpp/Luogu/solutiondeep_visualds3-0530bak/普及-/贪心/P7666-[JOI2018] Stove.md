# 题目信息

# [JOI2018] Stove

## 题目描述

JOI 君的房间里有一个炉子。因为 JOI 君已经习惯了寒冷的温度，所以当他一个人在房间里时，他不需要打开炉子。但是，有客人时，他需要打开炉子。有一天，$N$ 位客人将拜访 JOI 君。第 $i$ 个客人 ($1 \leq i \leq N$) 将在时间 $T_i$ 到达，并在时间 $T_i+1$ 离开。任何时间最多有一个客人访问  JOI 君。JOI 君可以随时开火或关火。JOI 君用火柴打开炉子。JOI 君只有 $K$ 根火柴。 因此他最多可以打开炉子 $K$ 次。在一天的开始，炉子是关闭的。当炉子打开时，它需要燃料。因此，JOI 君控制着他何时打开或关闭炉子，他想尽量减少炉子的总运行时间。  
现给定访问 JOI 君的客人数据和 JOI 君拥有的火柴数，请编写一个程序来计算炉子总运行时间的最小值。

## 说明/提示

#### 数据规模与约定  
对于 $100 \%$ 的数据，$1 \leq N \leq 10^5$，$1 \leq K \leq N$，$1 \leq T_i \leq 10^9$（$1 \leq i \leq N$），$T_i < T_{i+1}$（$1 \leq i \leq N-1$）。  
- Subtask $1$（$20$ points）：$N \leq 20$。  
- Subtask $2$（$30$ points）：$N \leq 5000$。  
- Subtask $3$（$50$ points）：没有额外的限制。  
#### 样例说明  
**对于样例 $1$**：三位客人将访问 JOI 君。如果他按以下方式打开和关闭炉子，那么当客人来访时打开炉子，他打开炉子两次，炉子的总运行时间为 $(4-1)+(7-6)=4$。  
- 当第一位客人到来时，他在时间 1 打开炉子。  
- 当第二位客人离开时，他在时间 4 关掉炉子。  
- 当第三位客人到来时，他在时间 6 打开炉子。  
- 当第三位客人离开时，他在时间 7 关掉炉子。  

由于炉子的总运行时间不能小于 $4$，输出 $4$。  
**对于样例 $2$**：JOI 君只能打开一次炉子。因此，他在第一个客人来的时间 $1$ 打开炉子，当第三位客人离开时他在时间 $7$ 关掉炉子。  
请注意，客人离开的时间可以与下一位客人到来的时间相同。  
**对于样例 $3$**：JOI 君在每位客人到来时打开炉子，并在每位客人离开时关掉炉子。  
#### 题目说明：  
来源于 The 17th Japanese Olympiad in Informatics (JOI 2017/2018) Final Round 的 [T1：Stove](https://www.ioi-jp.org/joi/2017/2018-ho/2018-ho-t1-en.pdf)。  
由 @[求学的企鹅](/user/271784) 翻译整理。

## 样例 #1

### 输入

```
3 2
1
3
6```

### 输出

```
4```

## 样例 #2

### 输入

```
3 1
1
2
6```

### 输出

```
6```

## 样例 #3

### 输入

```
3 3
1
3
6```

### 输出

```
3```

## 样例 #4

### 输入

```
10 5
1
2
5
6
8
11
13
15
16
20```

### 输出

```
12```

# AI分析结果



### 综合分析与结论

#### 核心算法思路
所有题解均采用**贪心策略**，核心思路为：
1. 初始总运行时间为 `T_n +1 - T_1`（覆盖所有客人访问时间）
2. 计算相邻客人之间的**无客间隔** `gap = T_{i+1} - T_i -1`
3. 选择最大的 `K-1` 个间隔进行分割，从总时间中减去这些间隔
4. 最终答案：`总时间 - Σ最大K-1间隔`

#### 解决难点
- **贪心选择验证**：每个分割操作可节省一个火柴的开启次数，且必须优先节省最大的间隔时间。
- **边界处理**：当 `K=1` 时必须连续运行，当 `K≥N` 时每个客人独立开启（总时间为N）。
- **排序方向**：需降序排序间隔，取前 `K-1` 大值。

#### 可视化设计思路
- **动画方案**：以像素块展示时间轴，红色表示炉子运行段，灰色为间隔。每次选择最大灰色块分割为红色块，动态更新总时间。
- **复古风格**：用8-bit像素风格渲染时间轴，音效在分割时播放“切割”声，成功时播放金币音效。
- **交互设计**：支持步进控制，高亮当前最大间隔，显示剩余火柴数。

---

### 题解评分（≥4星）

| 题解作者       | 评分 | 关键亮点 |
|----------------|------|----------|
| 封禁用户       | ★★★★☆ | 官方题解思路，双经验提示，代码简洁 |
| chlchl         | ★★★★☆ | 明确解释K-1的由来，代码变量命名清晰 |
| love_tide      | ★★★★ | 分步骤图示化解释，代码注释详细 |
| The_Best_OIer  | ★★★★ | 双经验提示，代码极简无冗余 |

---

### 最优思路与技巧提炼

1. **贪心选择依据**  
   - 每次分割操作必须选择最大的无客间隔，使得节省的时间最大化。
   - 数学证明：总运行时间 = 初始覆盖时间 - 最大可节省的K-1个间隔。

2. **排序策略**  
   ```cpp
   sort(gaps.rbegin(), gaps.rend()); // 降序排序取前K-1
   ```

3. **边界处理技巧**  
   - `K=1` 时直接输出初始时间。
   - 计算间隔时注意数组长度为 `N-1`。

4. **空间优化**  
   复用原数组存储间隔，无需额外空间。

---

### 同类型题与算法套路

**贪心套路**：  
- **区间合并问题**：通过删除最大间隔减少合并次数（如[P1209 修理牛棚](https://www.luogu.com.cn/problem/P1209)）。
- **资源分配问题**：用有限资源（火柴）切割最大无效段。

**相似题目**：  
1. [P1209 [USACO1.3]修理牛棚 Barn Repair](https://www.luogu.com.cn/problem/P1209)  
2. [P2512 [HAOI2008]糖果传递](https://www.luogu.com.cn/problem/P2512)  
3. [P1090 [NOIP2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)

---

### 核心代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, k;
    cin >> n >> k;
    vector<int> t(n), gaps;
    for (int i = 0; i < n; ++i) cin >> t[i];
    
    int total = t.back() - t[0] + 1;
    for (int i = 1; i < n; ++i) 
        gaps.push_back(t[i] - t[i-1] - 1);
    
    sort(gaps.rbegin(), gaps.rend());
    for (int i = 0; i < min(k-1, (int)gaps.size()); ++i)
        total -= gaps[i];
    
    cout << total;
    return 0;
}
```

---

### 可视化代码片段（Canvas动画）

```javascript
// 绘制时间轴
function drawTimeline(ctx, t, gaps, k) {
    ctx.fillStyle = '#FF0000'; // 红色表示炉子运行
    ctx.fillRect(50, 100, 400, 20); // 初始连续段
    
    gaps.forEach((gap, i) => {
        ctx.fillStyle = '#CCCCCC'; // 灰色间隔
        ctx.fillRect(50 + i*40, 150, 30, 20);
    });
    
    // 高亮最大间隔
    ctx.strokeStyle = '#FFFF00';
    ctx.strokeRect(50 + selectedIdx*40, 150, 30, 20);
}
```

---

### 个人心得摘录

- **封禁用户**：通过双经验题提示，强化同类问题关联性。  
- **chlchl**：强调 `K-1` 的由来，避免新手直接套用K值。  
- **love_tide**：用“切割”比喻贪心操作，形象化理解。  

---

### 复古游戏化设计

1. **像素风格**：  
   - 时间轴用8-bit红灰像素块表示，火柴图标为像素火焰。  
   - 音效使用[jsfxr](https://sfxr.me/)生成8-bit音效。

2. **自动演示模式**：  
   ```javascript
   function autoPlay() {
       if (step < k-1) {
           selectLargestGap();
           step++;
           setTimeout(autoPlay, 1000);
       }
   }
   ```

3. **积分系统**：  
   - 每正确选择一个间隔得10分，连击加成。  
   - 错误选择播放“爆炸”音效，扣分。

---
处理用时：75.73秒
# 题目信息

# [CEOI 2005] Multi-key Sorting

## 题目描述

考虑一个包含行和列的表。列从 $1$ 到 $C$ 编号。为简单起见，表中的项目是由小写字母组成的字符串。  
![TuLi](https://cdn.luogu.com.cn/upload/image_hosting/z70sexo1.png)  
您将获得对此类表的 Sort($k$) 操作：Sort($k$) 按照列 $k$ 中的值的顺序对表的行进行排序（而列的顺序不会改变）。排序是稳定的，即在第 $k$ 列中具有相等值的行保持其原始顺序。例如，将 Sort($2$) 应用于表 $1$ 会产生表 $2$。  
我们对此类排序操作的序列感兴趣。这些操作依次应用于同一个表。例如，应用序列 Sort($2$)；Sort($1$) 到表 $1$ 产生表 $3$。  
如果两个排序操作序列对于任何表具有相同的效果，则它们被称为等效。例如，Sort($2$)；Sort($2$)；Sort($1$) 等效于 Sort($2$)；Sort($1$)。但是，它不等效于 Sort($1$)；Sort($2$)，因为对表 $1$ 的影响不同。

## 说明/提示

#### 数据规模与约定  
对于 $100 \%$ 的数据，$1 \leq C \leq 10^6$，$1 \leq N \leq 3×10^6$，$1 \leq k_i \leq C$。  
#### 题目说明  
来源于 CENTRAL-EUROPEAN OLYMPIAD IN INFORMATICS 2005 的 Multi-key Sorting。  
由 @[求学的企鹅](/user/271784) 翻译整理。

## 样例 #1

### 输入

```
4 6
1 2 1 2 3 3```

### 输出

```
3
1 2 3```

# AI分析结果



# 【CEOI 2005】Multi-key Sorting 分析

---

## 唯一算法分类：**哈希表/桶排序**

---

## 题解思路、算法要点与解决难点

### 核心思路
题目本质是**统计序列中不同数字的数量，并按照最后一次出现的顺序输出**。核心难点在于如何高效记录每个数字的最后出现位置，并保证输出顺序正确。

### 算法对比
| 题解实现思路                     | 数据结构       | 时间复杂度 | 空间复杂度 | 核心优化点                     |
|-------------------------------|---------------|----------|-----------|------------------------------|
| 两次遍历 + 桶标记              | 桶数组 + 结果数组 | O(n)     | O(C)      | 逆序遍历直接捕获最后一次出现     |
| 记录最后出现位置 + 单次遍历筛选 | 最后位置数组     | O(n)     | O(C)      | 无需逆序，直接记录最后出现索引   |

**解决难点**：通过逆序遍历或记录最后出现位置，保证每个数字只保留最后一次出现。

---

## 题解评分 (≥4星)

### 5星题解
- **作者：Gumbo**  
  **核心亮点**：用 `lst` 数组记录每个数字的最后出现位置，遍历时直接判断是否需收集。代码简洁高效，时间复杂度最优。  
  **代码片段**：  
  ```cpp
  int lst[1000006]; // 记录最后一次出现的位置
  for(int i=1;i<=n;++i){
      scanf("%d",&num[i]);
      if(lst[num[i]]==0) ans++;
      lst[num[i]]=i; // 更新最后出现位置
  }
  for(int i=1;i<=n;++i)
      if(lst[num[i]]==i) printf("%d ",num[i]); // 仅输出最后一次出现
  ```

### 4星题解
- **作者：Aybbl_xc**  
  **亮点**：桶计数 + 逆序填充结果数组，思路清晰易理解。  
  **改进点**：两次遍历，空间可优化。  
  **代码核心**：  
  ```cpp
  for(int i=n;i>=1;i--){ // 逆序遍历
      if(!b[a[i]]){
          sum[++temp]=a[i];
          b[a[i]]=true;
      }
  }
  ```

- **作者：2021sunzishan**  
  **亮点**：栈结构存储逆序结果，逻辑直观。  
  **代码核心**：  
  ```cpp
  stack<int> s2;
  for(int i=n;i>=1;i--){
      if(!vis[a[i]]) s2.push(a[i]), vis[a[i]]=1;
  }
  while(!s2.empty()) cout<<s2.top()<<" ";
  ```

---

## 最优思路或技巧提炼

### 关键步骤
1. **记录最后出现位置**：遍历时更新每个数字的最后索引（如 `lst[x] = i`）。
2. **筛选输出**：二次遍历原数组，仅当当前索引等于最后索引时输出。

### 优化技巧
- **单次遍历统计与筛选**：无需逆序处理，直接利用最后位置数组判断。
- **空间压缩**：用原数组存储结果，避免额外空间。

---

## 同类型题与算法套路

### 相似问题
- **统计字符最后出现位置**（LeetCode 387. 字符串中的第一个唯一字符）
- **按条件去重保留最后出现**（如日志去重）

### 通用解法
- **哈希表记录状态**：适用于需要动态统计出现次数的场景。
- **逆序遍历捕获最后状态**：适用于需保留最终状态的问题。

---

## 推荐题目
1. **P1102 A-B数对**（桶计数应用）
2. **P1177 快速排序**（排序思想）
3. **P3370 字符串哈希**（哈希表去重）

---

## 个人心得摘录
- **Gumbo**：稳定排序的幂等性启发保留最后一次操作。
- **szh_AKall**：首次提交因顺序错误只得6分，强调逆序关键性。
- **icaijy**：指出原题参数 `C` 实际不影响解题，简化分析。

---

## 可视化与算法演示

### 动画设计
1. **逆序扫描高亮**：以红色高亮当前检查元素，若未记录则标记为绿色（最后出现），否则灰色。
2. **结果队列构建**：动态显示结果数组的填充过程，每次插入时伴随像素音效。

### 复古风格实现
- **8位像素调色板**：绿色表示有效插入，红色表示跳过。
- **音效设计**：
  - **插入成功**：短促“哔”声（Web Audio API）。
  - **完成扫描**：8位胜利旋律。

```javascript
// 示例：Canvas绘制逆序扫描过程
function drawScanStep(currentIndex, arr, lastPos) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    arr.forEach((num, idx) => {
        if (idx === currentIndex) ctx.fillStyle = '#FF0000'; // 当前元素红色
        else if (lastPos[num] === idx) ctx.fillStyle = '#00FF00'; // 最后出现绿色
        else ctx.fillStyle = '#999999'; // 其他灰色
        ctx.fillRect(idx * 10, 0, 8, 8);
    });
}
```

---

## 核心代码实现（Gumbo 最优解）

```cpp
#include<cstdio>
using namespace std;
int lst[1000006]; // 记录每个数字的最后出现位置
int num[3000006]; // 存储输入序列

int main(){
    int c, n;
    scanf("%d%d", &c, &n);
    int ans = 0;
    for(int i = 1; i <= n; ++i){
        scanf("%d", &num[i]);
        if(lst[num[i]] == 0) ans++; // 首次出现则计数
        lst[num[i]] = i; // 更新最后位置
    }
    printf("%d\n", ans);
    for(int i = 1; i <= n; ++i)
        if(lst[num[i]] == i) printf("%d ", num[i]); // 仅输出最后一次出现的元素
    return 0;
}
```

**核心思想**：利用数组索引直接映射数字的最后出现位置，实现 O(n) 时间复杂度的最优解。

---
处理用时：84.64秒
# 题目信息

# [CCC 2014] 燃料搜集

## 题目描述

英勇的狐狸星小队正在执行任务。他们的任务是从莱拉星系的不同的星球上搜集尽可能多的燃料。莱拉星系里有 $n$ 个星球，第 $i$ 个星球有 $a_i$ 单位燃料，但是从任何星球去那里都要花费 $b_i$ 单位燃料。不幸的是，燃料不是一种可再生资源，所以如果你第二次到访一个星球，你在那里将搜集不到新的燃料。

狐狸星小队在星球 $P$，所以他们可以立马搜集这个星球的燃料，然后他们就可以去执行任务了。只要他们的燃料足够，即完成飞行后他们剩余的燃料量是非负的，他们就可以以任意顺序访问星球。最后，他们可能会在任何星球选择停下来，甚至可能连星球 $P$ 都没离开过就停下来。他们的目标是使搜集到的燃料量最大化，如果有很多种方法可以达到这个目标，他们还想使他们访问过的不同星球的个数最大化，你能帮助他们吗？

## 说明/提示

一个最优的方案是，狐狸星小队搜集完星球 $2$ 即起点的燃料后从该出发，依次访问并搜集星球 $3,1,5$ 上的燃料，途中花费分别为 $3,12,15$，从起点开始各个星球上完成搜集后剩余燃料分别为 $10,15,15,25$。他们此时不应该选择去星球 $4$ 而是应该选择停下来以使结束时搜集到的燃料量最大化。

对于 $20\%$ 的测试数据，$1\le n\le10$；

对于 $100\%$ 的测试数据，$1\le P\le n\le10^5$，$a_i,b_i\le10^5$ 。

## 样例 #1

### 输入

```
5 2
12 12
10 100
8 3
4 5
25 15```

### 输出

```
25
4```

# AI分析结果



### 综合分析与结论

**题目核心思路**：  
该问题需通过贪心策略选择访问顺序，确保在燃料充足时优先访问消耗低、收益非负的星球，从而最大化总燃料和访问星球数。

**核心难点**：  
1. **贪心策略推导**：需证明按消耗（$b_i$）升序访问的正确性，而非直觉上的净收益（$a_i-b_i$）排序。  
2. **访问条件限制**：必须确保当前燃料足够支付访问代价，且每个星球仅访问一次。  

**解决方案**：  
- **排序策略**：将满足 $a_i \geq b_i$ 的星球按 $b_i$ 升序排列，确保低消耗优先，逐步积累燃料。  
- **动态更新**：遍历排序后的列表，若当前燃料足够访问，则更新燃料并计数。  

**可视化设计**：  
- **动画方案**：用柱状图展示排序后的星球（按 $b_i$ 升序），高亮当前选中项，实时显示燃料变化。  
- **复古像素风格**：星球以不同颜色块表示，选中时播放8位音效，燃料条动态增长。  
- **交互功能**：支持单步执行，对比不同排序策略（如净收益降序）的失败案例。  

---

### 题解清单（≥4星）

1. **GuideZombies（★★★★★）**  
   - **亮点**：严谨的贪心推导，代码简洁高效，正确性证明清晰。  
   - **代码**：将星球按 $b_i$ 排序，仅处理非负收益项，时间复杂度 $O(n \log n)$。  

2. **Nemonade（★★★★☆）**  
   - **亮点**：详细分类讨论三种情况（正/零/负收益），代码注释明确，适合新手。  
   - **心得**：强调零收益星球需访问以最大化计数，避免常见误区。  

3. **Aw顿顿（★★★★☆）**  
   - **亮点**：通过 `swap` 处理起点，逻辑清晰，代码结构紧凑。  
   - **优化**：跳过负收益星球，减少无效计算。  

---

### 核心代码实现

**GuideZombies 的关键代码**：  
```cpp
struct node {
    int v, val; // v为b_i，val为a_i - b_i
    bool operator<(node y) { return v < y.v; }
};
sort(star + 1, star + cnt + 1);
for (int i = 1; i <= cnt; ++i) {
    if (oil >= star[i].v) oil += star[i].val, ++sum;
    else break;
}
```

**贪心逻辑**：  
1. 预处理时过滤 $a_i < b_i$ 的星球。  
2. 按 $b_i$ 升序排序。  
3. 遍历时仅访问可负担的星球，更新燃料和计数。  

---

### 最优思路提炼

1. **贪心选择依据**：  
   - 访问顺序按 $b_i$ 升序，确保低消耗优先，逐步积累燃料以覆盖高消耗高收益项。  
2. **正确性验证**：  
   - 若存在高收益但高消耗的星球，低消耗访问顺序可积累足够燃料，反之则无法覆盖。  
3. **实现技巧**：  
   - 预处理时排除负收益项，排序后线性扫描，时间复杂度最优。  

---

### 类似题目与算法套路

**同类型问题**：  
- **跳跃游戏**：选择最大覆盖范围，按位置贪心。  
- **加油站问题**：寻找能环游的起点，累计剩余油量。  

**推荐题目**：  
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（贪心+优先队列）  
2. [P1803 线段覆盖](https://www.luogu.com.cn/problem/P1803)（区间端点贪心）  
3. [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)（排序策略证明）  

---

### 个人心得摘录

- **GuideZombies**：强调“略证”贪心策略，避免读者陷入错误排序思维。  
- **love_tide**：提醒在纸上模拟燃料变化，确保代码逻辑正确。  
- **Charm185**：通过反例说明按净收益排序的缺陷，强化理解。  

---

### 可视化与游戏化设计

**动画方案**：  
- **Canvas 绘制**：星球以方块表示，颜色区分收益（绿色为正，黄色为零，红色为负）。  
- **步进演示**：点击按钮访问下一星球，燃料条动态增长，失败时红色闪烁。  

**复古游戏化**：  
- **音效**：访问成功（8-bit 上升音效），燃料不足（低音警报）。  
- **积分系统**：每访问一星球+10分，燃料增长按比例奖励。  

**交互功能**：  
- **模式切换**：对比“按 $b_i$ 排序”与“按净收益排序”的结果差异。  
- **自动演示**：AI 按最优策略自动访问，速度可调。  

```html
<!-- 示例：Canvas 绘制与简单动画 -->
<canvas id="gameCanvas"></canvas>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    // 初始化星球数据（按b_i排序）
    const planets = sortedStars.map(star => ({ cost: star.v, gain: star.val }));
    // 绘制函数
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        planets.forEach((p, i) => {
            ctx.fillStyle = currentFuel >= p.cost ? '#00FF00' : '#FF0000';
            ctx.fillRect(i * 30, 100 - p.cost, 20, 20);
        });
    }
    // 模拟访问过程
    let currentFuel = initialFuel;
    function visitNext() {
        if (currentFuel >= planets[0].cost) {
            currentFuel += planets[0].gain;
            planets.shift();
            draw();
        }
    }
</script>
```

---
处理用时：130.74秒
# 题目信息

# 「EZEC-10」打分

## 题目背景

**为防止评测机被卡，本题时限为 100 ms。**

## 题目描述

小 A 去参加奥运会。

奥运会中共有 $n$ 名裁判，分别给小 A 打分 $a_1,a_2,\ldots,a_n$。

小 A 对自己的得分不满意，于是他将某名裁判打出的分数加 $1$，称为一次操作。

但是小 A 不能太贪心，他最多只能进行 $m$ 次操作。

小 A 的最终得分为：所有得分中，去掉一个最高分和一个最低分后的平均值。

小 A 想知道，他的最终得分最高为多少。

## 说明/提示

**【样例 1 解释】**

一种可行的方案为：$[1,2,3]\to [3,2,3]$。

**【样例 2 解释】**

一种可行的方案为：$[1,2,2,3]\to [2,3,3,3]$。

**【数据规模与约定】**

**本题采用捆绑测试。**

- Subtask 1（5 points）：$m=0$。
- Subtask 2（10 points）：$n=3$。
- Subtask 3（15 points）：$n,m\le 10^3$。
- Subtask 4（70 points）：无特殊限制。

对于 $100\%$ 的数据，$3\le n\le 10^5$，$0\le m,a_i\le 10^9$。

## 样例 #1

### 输入

```
3 2
1 2 3```

### 输出

```
3```

## 样例 #2

### 输入

```
4 3
1 2 2 3```

### 输出

```
6```

# AI分析结果



### 题解思路、算法要点与解决难点

#### 核心贪心思路
1. **忽略最低分**：由于最低分会被去掉，任何操作都不应浪费在最低分上。
2. **提升中间分数至当前最大值**：将所有中间分数尽可能提升到当前最大值，减少最高分被去掉时的损失。
3. **剩余操作的均匀分配**：若操作次数有剩余，将其均匀分配到所有非最低分的分数（包括原最高分），每次操作的贡献为平均提升。

#### 难点对比与解决方案
- **如何高效计算提升中间分数的操作次数**：
  - 排序数组后，直接计算中间部分与当前最大值的差值总和。
  - 时间复杂度优化至 \(O(n \log n)\)（排序时间）。
- **剩余操作的分配与贡献计算**：
  - 当剩余操作次数 \(m'\) 无法填满中间分数到最大值时，直接累加 \(m\)。
  - 当剩余次数足够时，将 \(m'\) 均匀分配到所有非最低分，每次操作平均贡献 \((n-2)/(n-1)\)。
  - 余数处理时需注意最高分的变化，通过整数除法避免浮点误差。

### 题解评分（≥4星）

1. **Maxmilite（5星）**
   - **思路清晰**：通过分类讨论直接数学推导，避免复杂余数处理。
   - **代码简洁**：仅需一次排序和线性遍历，高效处理大数据。
   - **数学优化**：利用整数运算公式避免浮点计算，确保精度。

2. **BotDand（4星）**
   - **直观分步实现**：明确分两步处理操作分配。
   - **余数处理**：显式处理余数，逻辑清晰，但余数计算可能存在小瑕疵。
   - **代码可读性**：详细变量命名，适合教学。

3. **Shunpower（4星）**
   - **详细步骤解析**：分三种情况讨论，适合新手逐步理解。
   - **代码注释丰富**：关键步骤有注释，增强可维护性。
   - **实际分配模拟**：显式模拟余数分配，但复杂度略高。

### 最优思路或技巧提炼

- **排序与忽略策略**：排序后直接忽略最低分，集中处理有效分数。
- **数学公式优化**：通过总和变换公式 \((sum + m + a[n]) \times (n-2)/(n-1)\) 避免逐次分配，直接计算总贡献。
- **整数运算处理余数**：利用整除和取余操作，避免浮点误差，确保结果正确。

### 同类型题目推荐

1. **P1223 排队接水**：贪心选择最小等待时间。
2. **P1090 合并果子**：优先队列选择最小代价合并。
3. **P3817 小A的糖果**：贪心调整相邻元素满足条件。

### 可视化与算法演示

#### 贪心过程动画设计
1. **初始排序**：数组升序排列，最低分红色标记。
2. **提升中间分数**：绿色动态填充中间分数至当前最大值。
3. **剩余操作分配**：黄色块均匀分配到非最低分，每次操作后更新总和。
4. **最高分变化**：最大值标记为紫色，若被覆盖则显示新最高分。

#### 复古像素风格交互
- **Canvas 绘制**：8-bit 像素风格，分数用色块表示，操作次数显示为能量条。
- **音效反馈**：操作分配时播放“升级”音效，最高分变化时播放“突破”音效。
- **自动演示模式**：AI 按最优策略自动分配，用户可暂停观察每一步。

### 核心代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long

int a[100005];

signed main() {
    int n, m;
    scanf("%llu%llu", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%llu", a + i);
    sort(a + 1, a + n + 1);
    long long cur = 0;
    for (int i = 2; i <= n - 1; ++i) cur += a[i];
    if (cur + m < (n - 2) * a[n])
        printf("%llu\n", cur + m);
    else
        printf("%llu\n", (cur + m + a[n]) * (n - 2) / (n - 1));
    return 0;
}
```

### 关键代码解释
1. **排序数组**：快速确定最低分和最高分。
2. **中间部分总和计算**：累加中间分数总和 `cur`。
3. **分类讨论**：
   - 若操作不足以填满中间到最大值，直接输出总和加操作次数。
   - 否则，通过数学公式计算均匀分配后的总贡献，避免逐次模拟。

---
处理用时：432.23秒
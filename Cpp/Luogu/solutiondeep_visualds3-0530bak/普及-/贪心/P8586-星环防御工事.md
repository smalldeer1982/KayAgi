# 题目信息

# 星环防御工事

## 题目背景

来自河外星系的小行星群即将有组织地打击地球。

## 题目描述

据观测，一共会有共 $n$ 波小行星群攻击太阳系。每一波攻击有两个属性：$d_i,m_i$，表示第 $i$ 波攻击会在第 $d_i$ 个太阳日发动，小行星群的总质量为 $m_i$。如果不进行精准防御，太阳系或将面临灭顶之灾。于是你的上司将星环防御工事的建设任务交给了你。

准确来讲，星环防御工事每个太阳日最多可以击毁总质量为 $k$ 的小行星。对于某一个在第 $d$ 个太阳日出现的小行星群，如果星环防御工事不能在第 $d$ 或 $d+1$ 个太阳日将其击毁(或者仅能部分击毁)，那么该小行星群(或其残余部分)将会被移交给地球和平联合组织 TPC 去处理——你当然不希望到手的美差被别人抢走！

因此你现在想知道，你领导的星环防御工事最多可以击毁多少质量的小行星呢？

## 说明/提示

对于 $10\%$ 的数据，$1\leq n,\max\{d_i\} \leq 20$。

对于 $20\%$ 的数据，$1\leq n,\max\{d_i\}\leq 600$。

对于 $40\%$ 的数据，$1\leq n,\max\{d_i\}\leq 5000$。

对于另外 $10\%$ 的数据，保证全部小行星群的 $m_i$ 总和不超过 $k$ 。

对于 $100\%$ 的数据，$1\leq n,\max\{d_i\}\leq 3\times 10^5$，$0\leq m_i,k\leq 10^4$。

## 样例 #1

### 输入

```
3 3 
1 6
4 7
2 2```

### 输出

```
14```

## 样例 #2

### 输入

```
10 100
6 14
2 92
3 91
4 74
7 75
2 90
7 25
1 92
3 41
2 14```

### 输出

```
580```

# AI分析结果



**唯一算法分类**  
贪心

---

### 综合分析与结论  
本题核心是贪心策略：按天处理，优先处理前一天遗留的陨石，再处理当天新出现的陨石。关键点在于：
1. **紧迫性处理**：前一天的陨石若不在当天处理完毕，后续将无法处理。
2. **合并同一天数据**：使用桶结构合并同一天所有陨石的总质量，避免逐个处理导致容量分配错误。
3. **时间复杂度优化**：通过遍历最大天数而非排序，将复杂度降至 O(maxd + n)。

**可视化设计要点**  
- **动画流程**：  
  - 用网格表示每一天，桶高度表示陨石质量。  
  - 每天高亮显示，分两步处理：先用红色标记处理前一天的陨石（消耗当日 k 容量），再用蓝色处理当天的剩余陨石。  
  - 动态显示每日剩余容量和总击毁量的增长。  
- **复古像素风格**：  
  - 使用 8 位色块表示每日陨石量（深灰为未处理，绿色为已处理）。  
  - 音效：处理成功时播放短促“哔”声，容量耗尽时播放低频提示音。  
  - 自动演示模式下，以固定速度逐天推进，展示贪心策略的全局性。

---

### 题解清单（评分≥4星）  
1. **题解作者：_EternalRegrets_（5星）**  
   - 桶合并同天数据，严格按天处理，逻辑清晰。  
   - 关键代码段：  
     ```cpp
     for(int i=0;i<=maxn+1;i++) {
         if (i > 0) {
             // 优先处理前一天的陨石
             if (a[i-1] <= k) { ... }
             // 再处理当天剩余的陨石
             if (a[i] <= k-used) { ... }
         }
     }
     ```
   - 亮点：正确处理边界（第 0 天和 maxn+1 天）。

2. **题解作者：_sin_（5星）**  
   - 与前一思路完全一致，代码结构简洁。  
   - 亮点：明确标注贪心正确性证明，变量命名清晰（如 `uk` 表示当日已用容量）。

3. **题解作者：LYZHZ（4星）**  
   - 暴力枚举到固定天数（300001），但逻辑正确。  
   - 关键代码段：  
     ```cpp
     for(int i=1;i<=300001;i++) {
         int kk = k;
         // 先处理前一天的陨石
         if (sum[i-1] > 0) { ... }
         // 再处理当天的陨石
         if (kk > 0 && sum[i] > 0) { ... }
     }
     ```
   - 不足：硬编码天数上限，空间略浪费。

---

### 最优思路与代码实现  
**核心逻辑**：  
1. 桶记录每天陨石总质量 `a[d] += m`。  
2. 遍历所有可能天数（0 到 maxd+1）：  
   - 第 i 天优先处理 `a[i-1]`（前一天未处理的陨石）。  
   - 剩余容量处理 `a[i]`（当天新出现的陨石）。  

**代码片段**：  
```cpp
int a[MAX_DAYS]; // 桶数组
int maxd = 0, ans = 0;

for (int i = 0; i <= maxd + 1; i++) {
    if (i == 0) {
        ans += min(a[i], k);
        a[i] = max(a[i] - k, 0);
    } else {
        // 处理前一天的陨石
        int used = min(a[i-1], k);
        ans += used;
        a[i-1] -= used;
        // 处理当天的陨石
        int remain = k - used;
        ans += min(a[i], remain);
        a[i] = max(a[i] - remain, 0);
    }
}
```

---

### 同类型题与推荐练习  
1. **区间调度问题**：如 [P1803 凌乱的yyy](https://www.luogu.com.cn/problem/P1803)，贪心选择最早结束的区间。  
2. **资源分配问题**：如 [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)，通过排序优化决策。  
3. **时序任务处理**：如 [P2949 工作调度](https://www.luogu.com.cn/problem/P2949)，优先处理截止时间早的任务。  

**推荐洛谷题目**：  
- P1803（区间贪心）  
- P5019（铺设道路，贪心模拟）  
- P1090（合并果子，优先队列）  

---

### 可视化算法演示（伪代码）  
```javascript
// 初始化 Canvas 和音效
const canvas = initCanvas();
const beepSound = loadSound('beep.wav');
let currentDay = 0;

function drawDay(day) {
    // 绘制前一天陨石（红色）和当天陨石（蓝色）
    drawRect(day-1, 'red', a[day-1]);
    drawRect(day, 'blue', a[day]);
    // 播放处理音效
    beepSound.play();
}

function processDay() {
    if (currentDay > maxd + 1) return;
    // 贪心处理逻辑（略）
    drawDay(currentDay);
    currentDay++;
    requestAnimationFrame(processDay);
}
// 启动自动演示
processDay();
```

---
处理用时：169.75秒
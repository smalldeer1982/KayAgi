# 题目信息

# [传智杯 #3 初赛] 志愿者

## 题目描述

传智专修学院总共召集了 $n$ 位志愿者来负责打扫活动，现在需要你负责帮忙统计每位志愿者的工作情况，用来制作光荣榜，给他们发小花花。

第 $i$ 位志愿者有一个工作时长 $t_i$ ，以及他负责的工作的难度系数 $k_i$ ，一名志愿者的贡献度可以用 $k_i \times t_i$ 确定。

现在要为这些志愿者的贡献度从大到小排个序，请你完成这个任务。相同贡献度的志愿者以工作时长较长的排在前面。如果贡献和时长一样，那么编号小的志愿者排在前面。



## 说明/提示

对于 $40\%$ 的数据，满足 $1 \leq n \leq 100$；  
对于额外 $20\%$ 的数据，满足 $k_i=1$；  
对于 $100\%$ 的数据，满足 $1 \leq n \leq 5 \times 10^5,1 \leq k_i,t_i \leq 1000$。

然而，由于本次比赛是 ACM 赛制，因此您必须通过 $100\%$ 的数据才能够获得本题的得分，后题同。

## 样例 #1

### 输入

```
3
1 2
2 3
3 4```

### 输出

```
3 2 1```

# AI分析结果



---

**唯一算法分类**  
排序

---

**综合分析与结论**  
本题核心在于多级排序规则的实现。需按贡献度（k×t）降序、t降序、id升序排列。算法关键在于正确编写比较函数，处理多条件优先级。  
**核心难点**：确保三级条件顺序正确，避免逻辑错误。预处理贡献度可提升性能。  
**可视化设计**：  
- **动画演示**：将每个志愿者表示为带贡献度、t、id的方块，排序时高亮比较的两个元素，显示比较结果及交换过程。  
- **颜色标记**：贡献度用不同颜色区分，相同贡献度时t用深浅色区分。  
- **复古像素风**：8-bit 风格方块，交换时播放经典音效。算法完成时播放胜利音乐。  

---

**题解清单 (5星)**  
1. **预处理贡献度优化比较**  
   预存贡献度减少乘法计算，清晰的三级条件判断，结构体存储提升可读性。  
   评分：★★★★★  
   **代码核心**：  
   ```cpp
   struct Volunteer {
       int id, t, k, contri;
       Volunteer(int id, int t, int k) : id(id), t(t), k(k), contri(t * k) {}
   };
   sort(v.begin(), v.end(), [](const Volunteer& a, const Volunteer& b) {
       if (a.contri != b.contri) return a.contri > b.contri;
       if (a.t != b.t) return a.t > b.t;
       return a.id < b.id;
   });
   ```

2. **Lambda直接计算贡献度**  
   即时计算k*t，牺牲少量性能换取代码简洁性，适合小规模数据。  
   评分：★★★★  
   ```cpp
   sort(v.begin(), v.end(), [](const Volunteer& a, const Volunteer& b) {
       int ca = a.t * a.k, cb = b.t * b.k;
       return ca != cb ? ca > cb : (a.t != b.t ? a.t > b.t : a.id < b.id);
   });
   ```

---

**最优思路提炼**  
- **多级条件优先级**：严格按贡献度→t→id顺序处理，避免逻辑错位。  
- **预处理优化**：预存贡献度减少重复计算，提升大规模数据性能。  

---

**同类型题推荐**  
1. [P1068 NOIP2009 普及组] 分数线划定  
2. [P1781 宇宙总统]  
3. [P1104 生日]  

---

**代码实现**  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Volunteer {
    int id, t, k, contri;
    Volunteer(int id, int t, int k) : id(id), t(t), k(k), contri(t * k) {}
};

int main() {
    int n;
    cin >> n;
    vector<Volunteer> v;
    for (int i = 0; i < n; ++i) {
        int t, k;
        cin >> t >> k;
        v.emplace_back(i + 1, t, k);
    }
    sort(v.begin(), v.end(), [](const Volunteer& a, const Volunteer& b) {
        if (a.contri != b.contri) return a.contri > b.contri;
        if (a.t != b.t) return a.t > b.t;
        return a.id < b.id;
    });
    for (const auto& x : v) cout << x.id << ' ';
    return 0;
}
```

---

**可视化与游戏化设计**  
1. **Canvas动画**：志愿者显示为像素方块，顶部数值为贡献度，底部为id。排序时高亮比较对，交换时播放“哔”音效。  
2. **音效设计**：  
   - 比较时：短促“滴”声。  
   - 交换时：8-bit “咔嚓”声。  
   - 完成时：经典FC通关音乐。  
3. **自动演示模式**：按归并排序或快速排序步骤自动播放，支持暂停/继续。  

**复古风格示例**  
```javascript
// 伪代码：绘制志愿者方块
function drawVolunteer(ctx, volunteer, x, y) {
    ctx.fillStyle = getColorByContri(volunteer.contri);
    ctx.fillRect(x, y, 50, 50); // 像素方块
    ctx.fillText(`ID:${volunteer.id}`, x + 5, y + 20); 
    ctx.fillText(`C:${volunteer.contri}`, x + 5, y + 40);
}
```

---
处理用时：152.85秒
# 题目信息

# [传智杯 #3 决赛] 商店

## 题目背景

disangan333 想给 disangan233 买一个礼物，于是他和你一起逛商店。

## 题目描述

有 $n$ 名同学去逛商店，店里有 $m$ 个物品，第 $i$ 人有 $w_i$ 块钱，第 $i$ 个物品价格 $c_i$ 元。

每个人至多买一个物品，每个物品只能被买一次，问最多有多少人能买到物品。

对于所有数据，$n,m \leq 10^5$，$w_i,c_i\leq 10^9$。

## 样例 #1

### 输入

```
15 20
4 3 9 10 7 7 5 3 6 1 8 6 6 1 5 
12 4 1 9 8 5 8 6 4 5 18 8 14 9 9 7 20 11 8 19 ```

### 输出

```
10```

# AI分析结果



### 综合分析与结论

题目核心为**贪心策略**：将人和商品按价格升序排列，用双指针逐个匹配。每个钱少的人优先购买能承受的最便宜商品，确保全局最优。正确性证明基于反证法——若存在更优解，则贪心策略必然能构造出矛盾。

#### 核心难点与解决方案
- **贪心正确性验证**：钱少的人优先购买低价商品，避免浪费高价商品。若存在其他分配方式，必然存在至少一个更优的贪心选择未被采用。
- **数据结构选择**：仅需排序后线性遍历，时间复杂度 O(n log n + m log m)，适合数据规模 1e5。
- **边界处理**：双指针需同步移动，避免数组越界。

#### 可视化设计思路
- **像素动画**：将排序后的人和商品排列为两列像素条，高度代表价格。
- **动态指针**：高亮当前匹配的人和商品，成功时连线并播放音效，失败时仅移动人指针。
- **自动演示**：按贪心策略自动步进，允许暂停/调速，音效反馈关键事件（成功购买、遍历结束）。

---

### 题解评分 (≥4星)

1. **WA_sir (5星)**  
   - **亮点**：详细解释了贪心策略的正确性，代码变量命名清晰，循环逻辑简洁。  
   - **代码片段**：  
     ```cpp
     for(int p=1; p<=n; p++) {
         if(w>m) break;
         if(a[p]>=b[w]) { w++; ans++; }
     }
     ```

2. **shoot_down (4星)**  
   - **亮点**：使用快读优化输入，代码注释明确，逻辑与主流解法一致。  
   - **代码片段**：  
     ```cpp
     for(int i=1; i<=n && j<=m; i++) {
         if(a[i]>=b[j]) { j++; cnt++; }
     }
     ```

3. **lilong (4星)**  
   - **亮点**：代码结构清晰，变量名 `k` 表示当前商品位置，逻辑易读。  
   - **代码片段**：  
     ```cpp
     for(int i=1; i<=n; i++) {
         if(w[i]>=c[k]) { ans++; k++; }
     }
     ```

---

### 最优思路提炼

1. **双指针贪心**  
   - 排序后，用 `i` 指向当前人，`j` 指向当前商品。  
   - 若 `w[i] >= c[j]`，则匹配成功，双指针右移；否则仅右移人指针。

2. **正确性证明**  
   - 若存在更优解，则至少存在一个低价商品未被最穷的可能购买者消费，导致总人数减少。

3. **代码模板**  
   ```cpp
   sort(w, w+n); sort(c, c+m);
   int ans=0, j=0;
   for(int i=0; i<n; i++) {
       if(j<m && w[i]>=c[j]) { ans++; j++; }
   }
   ```

---

### 同类型题目与算法套路

- **常见贪心场景**：区间调度（选择最早结束）、最小等待时间（短任务优先）、最大不相交区间。
- **通用解法**：排序后线性扫描，每次选择局部最优。

#### 推荐题目
1. **P1803 凌乱的yyy / 线段覆盖**（区间调度）  
2. **P1223 排队接水**（短任务优先）  
3. **P3817 小A的糖果**（贪心分配策略）

---

### 个人心得摘录

- **WA_sir**：强调正确性证明的重要性，避免盲目编码。  
- **fengziyi**：通过 `now-1` 处理边界，提醒注意循环终止条件。  
- **VitrelosTia**：用队列模拟商品选择，提供不同实现视角。

---

### 可视化与算法演示（核心代码）

```javascript
// 模拟贪心过程（伪代码）
function visualize() {
    let i = 0, j = 0, ans = 0;
    while (i < people.length && j < items.length) {
        highlight(people[i], items[j]); // 高亮当前匹配
        if (people[i] >= items[j]) {
            drawLine(i, j); // 成功购买连线
            playSuccessSound();
            i++; j++; ans++;
        } else {
            playFailSound();
            i++;
        }
    }
}
```

#### 复古游戏化设计
- **像素渲染**：Canvas 绘制人和商品为彩色方块，价格映射为方块高度。  
- **音效**：8-bit 音效库，购买成功时播放上升音阶，失败时低沉音。  
- **自动演示**：定时器控制步进速度，支持暂停/继续。

---

### 完整代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n, m, w[N], c[N];

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> w[i];
    for (int i = 0; i < m; i++) cin >> c[i];
    sort(w, w + n);
    sort(c, c + m);
    int ans = 0;
    for (int i = 0, j = 0; i < n && j < m; i++) {
        if (w[i] >= c[j]) { ans++; j++; }
    }
    cout << ans << endl;
    return 0;
}
```

---
处理用时：92.90秒
# 题目信息

# [USACO22DEC] Cow College B

## 题目描述

Farmer John 计划为奶牛们新开办一所大学！ 

![](https://cdn.luogu.com.cn/upload/image_hosting/wiy5l6d6.png)

有 $N(1 \le N \le 10^5)$ 头奶牛可能会入学。每头奶牛最多愿意支付 $c_i$ 的学费 $(1 \le c_i \le 10^6)$。 Farmer John 可以设定所有奶牛入学需要支付的学费。如果这笔学费大于一头奶牛愿意支付的最高金额，那么这头奶牛就不会入学。Farmer John 想赚尽可能多的钱，从而可以给他的讲师提供一笔可观的工资。请求出他能赚到的钱的数量，以及此时应当收取多少学费。 

## 说明/提示

### 样例 1 解释

如果 Farmer John 收费 $4$，那么 $3$ 头奶牛将会入学，从而使他赚取 $3 \times 4=12$ 的金额。

### 测试点性质

- 测试点 $2-4$ 满足 $c_i \le 1000$。
- 测试点 $5-8$ 满足 $N \le 5000$。
- 测试点 $9-12$ 没有额外限制。 

## 样例 #1

### 输入

```
4
1 6 4 6```

### 输出

```
12 4```

# AI分析结果



### 综合分析与结论

**题目核心**：Farmer John需设定学费，使得总收入最大。关键结论是**最优学费必为某头奶牛的最高支付额**，从而将枚举范围缩小到所有不同的 $c_i$。

**贪心策略**：将 $c_i$ 排序后，对每个可能的学费值 $c_i$，计算其对应的可入学奶牛数（即 $\geq c_i$ 的数目），维护最大收入。排序后，随着学费增加，可入学奶牛数递减，线性扫描即可高效求解。

**难点与解决**：
1. **反证法验证贪心选择**：若非 $c_i$ 的学费更优，则存在更高的 $c_i$ 能获得更大收益。
2. **高效计算数目**：通过排序或后缀和预处理，快速确定每个学费对应的数目。
3. **处理重复值**：通过排序或桶计数，避免重复计算。

**可视化设计**：
- **排序动画**：展示数组排序过程，高亮当前处理的 $c_i$。
- **数目计算**：动态显示当前学费对应的奶牛数及总金额。
- **复古像素风格**：用8-bit方块表示奶牛，学费选择时触发音效，背景音乐随结果变化。

---

### 题解清单（评分≥4星）

1. **NightStriker（★★★★★）**  
   - **亮点**：思路清晰，代码简洁，维护剩余数目避免重复计算。  
   - **代码**：排序后线性扫描，时间复杂度 $O(n \log n)$。  
   - **个人心得**：“不开 `long long` 见祖宗”强调数据范围的重要性。

2. **what_can_I_do（★★★★★）**  
   - **亮点**：桶统计+后缀和，时间复杂度 $O(n + \max c_i)$，避免排序。  
   - **代码**：预处理每个值的出现次数，后缀和快速计算数目。

3. **Ray1（★★★★★）**  
   - **亮点**：直接降序排序，计算每个 $c_i$ 的贡献，代码极简。  
   - **代码**：排序后遍历，维护最大乘积，时间复杂度 $O(n \log n)$。

---

### 最优思路与技巧

1. **贪心选择依据**：最优学费必为某 $c_i$，通过排序快速枚举候选。
2. **数目计算优化**：
   - **排序法**：升序排列后，数目为 `n - i + 1`；降序则为 `i`。
   - **后缀和法**：预处理每个值的数目，$O(1)$ 查询。
3. **实现细节**：
   - 使用 `long long` 避免溢出。
   - 处理相同值时的最小学费选择（保留第一个最大值）。

---

### 同类型题目推荐

1. **P1094 纪念品分组**：贪心+双指针，分组求最小。
2. **P1106 删数问题**：贪心删除策略，保留最大数。
3. **P1233 木棍加工**：贪心排序后动态规划。

---

### 核心代码实现

**NightStriker 的贪心逻辑**：
```cpp
sort(a+1, a+n+1);
int cow = n;
for (int i = 1; i <= n; i++) {
    if (a[i] * cow > ans) {
        ans = a[i] * cow;
        cnt = a[i];
    }
    cow--;
}
```

**what_can_I_do 的后缀和预处理**：
```cpp
for (int i = maxd; i >= 1; i--) t[i] += t[i+1];
for (int i = 1; i <= maxd; i++) {
    if (t[i] * i > ans) {
        ans = t[i] * i;
        k = i;
    }
}
```

---

### 可视化与游戏化设计

1. **像素动画**：Canvas绘制排序数组，学费选中时高亮，显示当前收入。
2. **音效提示**：
   - **选择学费**：短促“哔”声。
   - **更新最大值**：上扬音效。
3. **自动演示**：AI模拟遍历过程，步进控制观察贪心决策。
4. **积分系统**：正确选择学费得分，连击奖励加速动画。

**示例代码（伪代码）**：
```javascript
// 排序后数组可视化
function drawSortedArray(arr) {
    ctx.clearRect(0, 0, width, height);
    arr.forEach((val, i) => {
        drawPixelBlock(i * 10, val, color);
    });
}

// 贪心过程动画
function animateGreedy(arr) {
    let maxIncome = 0, bestFee = 0, cow = arr.length;
    arr.sort((a, b) => a - b);
    arr.forEach((val, i) => {
        const income = val * (arr.length - i);
        if (income > maxIncome) {
            playSound('success');
            maxIncome = income;
            bestFee = val;
        }
        highlightBlock(i);
    });
}
```

---

**总结**：本题通过贪心策略将复杂度优化至 $O(n \log n)$ 或 $O(n + \max c_i)$，核心在于利用排序或统计快速确定最优解。可视化设计可直观展示决策过程，增强理解。

---
处理用时：268.97秒
# 题目信息

# 「LAOI-1」GCD

## 题目描述

一张图有 $n$ 个节点，编号为 $1,2,3,\dots,n$。其中 $i$ 号节点会向 $j$ 号节点连一条边权为 $|i-j|$ 的无向边，当且仅当 $\gcd(i,j)=i,\operatorname{lcm}(i,j)=j$ 时连边。现询问 $q$ 次，每次询问求 $x$ 到 $y$ 的最短路径。

## 说明/提示

注意时空限制，本题不捆绑。

对于 $40\%$ 的数据，$T,n,q\le100$;

对于 $100\%$ 的数据，$1\le T\le10^6$，$1\le n,q\le10^6$，$1\le x,y\le n$，$1\le \sum n,\sum q\le10^6$。

**请使用更快的 IO 方式**。

updata on 2024/8/8：

时限上调到 1000ms。/yun

## 样例 #1

### 输入

```
1
6 4
1 4
3 5
2 5
2 4```

### 输出

```
3
6
5
2```

# AI分析结果



### 综合分析与结论

**题目核心**：在由因数关系构成的图中，找到两节点间的最短路径。  
**贪心策略**：通过将两节点路径汇聚到它们的最大公约数（GCD）来最小化总边权。  
**正确性证明**：其他路径（如通过 LCM 或中间节点）总权必然更大，因路径方向需严格递减，GCD 是最优汇聚点。  
**时间复杂度**：单次查询 O(log min(x,y))，适用于大规模数据。

### 题解清单（评分≥4星）

1. **Coffins（5星）**  
   - **亮点**：简洁推导条件等价于因数关系，通过感性分析直接给出公式。  
   - **代码**：高效利用 `gcd` 函数，输入输出优化完善。

2. **sto_5k_orz（5星）**  
   - **亮点**：严格数学证明公式正确性，对比 LCM 路径的劣势。  
   - **代码**：使用快读快写，适应极限数据规模。

### 最优思路提炼

- **关键公式**：`ans = x + y - 2 * gcd(x, y)`  
- **推导逻辑**：  
  1. 路径必须沿因数链下降，否则边权更大。  
  2. GCD 是最大公共下降点，确保路径最短。  
- **实现要点**：快速计算 GCD，无需预处理。

### 同类型题目与算法

- **常见套路**：利用数论性质（因数、GCD）构造图结构，贪心选择公共汇聚点。  
- **类似题目**：  
  - 洛谷 P1072 Hankson 的趣味题（GCD/LCM 性质应用）  
  - 洛谷 P1029 最大公约数和最小公倍数问题（因数分解与条件匹配）  
  - 洛谷 P2421 冗余路径（图的连通性与贪心构造）

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int T; cin >> T;
    while(T--) {
        int n, q; cin >> n >> q;
        while(q--) {
            int x, y; cin >> x >> y;
            int g = __gcd(x, y);
            cout << x + y - 2 * g << '\n';
        }
    }
    return 0;
}
```

### 可视化设计（复古像素风格）

1. **动画逻辑**：  
   - 初始化网格，节点以像素块表示，颜色按数值大小渐变。  
   - 路径分解：高亮 x → GCD ← y 的每一步，边权以数字弹出。  
   - 音效：分解时播放 8-bit 音效，背景音乐循环播放。

2. **交互功能**：  
   - **步进控制**：按空格单步执行分解过程。  
   - **自动模式**：AI 自动选择路径，速度可调。  
   - **积分系统**：正确路径选择+10分，错误选择-5分。

3. **Canvas 示例**：  
   ```javascript
   function drawNode(x, color) {
       ctx.fillStyle = color;
       ctx.fillRect(x * 20 % 300, Math.floor(x * 20 / 300) * 20, 18, 18);
   }
   // 绘制路径动画
   function animatePath(x, y, g) {
       let current = x;
       while(current > g) {
           drawNode(current, '#FF0000'); // 红色高亮
           current /= getNextFactor(current, g); // 跳转到下一个因数
       }
       // 类似处理 y...
   }
   ```

### 个人心得摘录

- **调试教训**：初始误以为 LCM 路径可能更优，需严格数学证明排除。  
- **优化经验**：`ios::sync_with_stdio(0)` 关闭同步流大幅提升 IO 速度。  
- **核心洞见**：因数关系天然构成有向无环图，最短路径即最长公共下降链。

---
处理用时：82.30秒
# 题目信息

# Maps.

## 题目描述

小 Y 希望得到一幅地图，这份地图有些与众不同。

这份地图是一幅长为 $n$ 个单位，宽为一个单位的网格图，每个网格必须被涂鸦成白色（$0$）或者黑色（$1$）。

你希望满足小 Y 的愿望送给他一幅这样的地图，但是这时小 Y 又提出了两点要求：

- 对于每个不在网格图两端的白色格子，恰好有 $p$ 个满足它的左右两个格子都被涂鸦成黑色。
- 在满足上述所有条件的情况下，这幅地图从左到右的字符构成的字符串的字典序最小。

你心想，这些要求也是小菜一碟，于是开始了你的创作。

## 说明/提示

#### 【样例解释 #1】

对于第一组数据：只有位于第 $4$ 个字符上的数，满足本身是 $0$，不在地图边缘且周围两个都是 $1$，因此符合条件。可以证明这是满足条件的字典序最小的方案。

对于第三组数据：可以证明没有任何一个解满足长度为 $5$ 且有 $3$ 个数本身是 $0$，不在地图边缘且周围两个字符都是 $1$。

#### 【数据范围】

对于所有测试数据，满足 $1 \le T \le 100$，$1 \le n,p \le 10^5$。

**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\text{Subtask}$。**

各测试点的附加限制如下表所示。

| 测试点 | $n,p \le$ |
| :-----------: | :-----------: |
| $1 \sim 3$ | $10$ |
| $4 \sim 5$ | $10^3$ |
| $6\sim 10$ | $10^5$ |

## 样例 #1

### 输入

```
5
5 1
3 1
5 3
5 4
5 5```

### 输出

```
00101
101
-1
-1
-1```

# AI分析结果



### 综合分析与结论

#### 核心思路与难点
1. **贪心策略**：字典序最小要求尽可能多的前缀填0，剩余部分构造满足条件的 `1010...1` 模式。
2. **无解条件**：构造模式需至少 `2p+1` 长度，若 `n < 2p+1` 则无解。
3. **构造方法**：前缀填 `n-(2p+1)` 个0，后接 `p` 个 `10` 和结尾的 `1`，形成 `101...1` 结构。

#### 解决难点
- **贪心正确性**：前缀0不影响条件，后段结构严格满足每个0左右为1。
- **边界处理**：结尾必须为1，避免产生无效0。

#### 可视化设计思路
- **分步动画**：动态显示填充前缀0，逐步构建 `10` 单元，最后补1。
- **颜色标记**：前缀0用绿色，`10` 单元交替红/蓝，结尾1用金色。
- **复古像素风格**：字符以8位方块呈现，填充时伴随音效（0低音，1高音）。
- **自动演示**：按步执行，支持暂停/继续，参数调节观察不同构造结果。

---

### 题解清单（≥4星）

1. **bryce（5星）**  
   - **亮点**：代码极简，直接输出前缀0与模式段，无冗余操作。  
   - **关键代码**：`for (int i = 1; i <= p; i++) cout << "10";`

2. **Lovely_Elaina（5星）**  
   - **亮点**：明确模式段长度为 `1+2p`，倒序填充0提升可读性。  
   - **引用**：*“优先往左边填充0”* 体现贪心本质。

3. **MarsTraveller（4星）**  
   - **亮点**：详细推导模式结构，代码注释清晰。  
   - **个人心得**：*“赛时WA了一回”* 强调边界验证的重要性。

---

### 最优思路提炼

1. **无解条件**：`if (2*p +1 > n)` 直接返回-1。
2. **贪心构造**：前缀填0至 `n-(2p+1)`，后接 `p` 个 `10` 和结尾 `1`。
3. **字典序最小**：前缀0最大化，模式段紧接其后，无更优排列。

```cpp
// 核心代码片段（bryce版）
if (2*p +1 > n) cout << -1;
else {
    for (int i=0; i < n-(2*p+1); i++) cout << 0;
    for (int i=0; i < p; i++) cout << "10";
    cout << "1\n";
}
```

---

### 同类型题与算法套路

- **贪心构造题套路**：  
  1. 确定最小必要结构（如本题的 `2p+1`）。  
  2. 剩余部分填充最小字典序元素（前缀填0）。  
  3. 验证结构是否可嵌入剩余空间。

- **类似题目**：  
  - 区间调度（如选择不重叠区间最大化数量）。  
  - 最小字典序删除k字符（LC 402）。  
  - 构造特定模式的二进制串（如交替位、回文等）。

---

### 推荐题目
1. **P1090** [合并果子] - 贪心+优先队列。  
2. **P1223** [排队接水] - 时间调度贪心。  
3. **P2870** [字典序最小子序列] - 类似本题的字典序构造。

---

### 可视化代码片段（Canvas动画）

```javascript
// 伪代码：构造过程动画
function animateConstruction(n, p) {
    let str = '';
    // 填充前缀0
    for (let i=0; i < n-2*p-1; i++) {
        drawPixel(i, 0, 'green'); // 绿色像素块
        str += '0';
    }
    // 构建模式段
    let pos = n - 2*p -1;
    for (let i=0; i < p; i++) {
        drawPixel(pos++, 0, 'red');  // 红色1
        drawPixel(pos++, 0, 'blue'); // 蓝色0
        str += '10';
    }
    drawPixel(pos, 0, 'gold'); // 结尾金色1
    str += '1';
    playSound('complete'); // 完成音效
}
```

---

### 复古游戏化设计要点

- **像素风格**：  
  - 字符用16x16像素块，绿色0、红色1。  
  - 背景滚动条纹模拟经典终端。

- **音效设计**：  
  - 填充0：`beep(200Hz, 50ms)`。  
  - 填充1：`beep(400Hz, 50ms)`。  
  - 完成构造：8-bit胜利旋律。

- **关卡模式**：  
  - 每关给定n和p，限时构造。  
  - 正确构造得分，连续正确触发连击奖励。

---
处理用时：86.19秒
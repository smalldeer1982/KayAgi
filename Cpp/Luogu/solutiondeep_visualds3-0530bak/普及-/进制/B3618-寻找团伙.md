# 题目信息

# 寻找团伙

## 题目描述

世界局势风云变幻，你想办一件大事。办事自然要有人参与，你能从 $n$ 个人里面挑选一部分人共襄盛举。

要办这件事，一共涉及 $k$ 方面的能力，例如游说他人的能力、玩游戏的能力、睡觉的能力。每位人士都会具备某一些能力，例如机器猫就可能擅长睡觉、擅长玩游戏，而不擅长游说他人。

你的计划很宏伟，因此你希望团队拥有很全面的能力。不幸的是，如果团队中有偶数个人拥有同一类能力，那么他们就会分成两派，争执不下，导致整个团队丧失这方面的能力。相应地，如果这项能力只有奇数个人拥有，那么他们总能形成一个多数派，帮团队去做这方面的工作。

需要注意的是，团队拥有的每一项能力，对计划的成功率的贡献是不一样的。第一项能力最重要，它的权重是 $2^{k-1}$；第二项能力的权重是 $2^{k-2}$；依次类推。第 $k$ 项能力最不重要，权重只有 $1$。

计划的成功率得分，即是**团队拥有的所有能力对应的权重之和**。

你希望计划成功率最大。因此，你需要选出合适的人士，来参与到你的宏图伟业中。


## 说明/提示

#### 样例解释

第一组样例，共 5 个人，每个人拥有的能力不一样。最终选择的结果是让这 5 个人都参与计划，得分 $16+8+4+2+1 = 31$。

第二组样例，我们选择只让 $1$ 参与。那么团队具有能力 $1,2, 3$，得分 $16+8+4=28$。

第三组样例，我们让 $1,2,3$ 参与。由于团队中有偶数个成员拥有能力 $5$，故团队并不拥有能力 $5$。奇数个成员拥有能力 $2$，故团队拥有能力 $2$。最终，团队具有能力 $1,2,3,4$。得分 $16+8+4+2=30$。

#### 数据规模与约定

对于 $100\%$ 的数据，有 $n\leq 21, k\leq 60$。




## 样例 #1

### 输入

```
5 5
1 1
1 2
1 3
1 4
1 5```

### 输出

```
31```

## 样例 #2

### 输入

```
3 5
3 1 2 3
4 2 3 4 5
2 3 4```

### 输出

```
28```

## 样例 #3

### 输入

```
3 5
2 1 2
3 5 3 2
3 4 2 5```

### 输出

```
30```

## 样例 #4

### 输入

```
21 60
0 
0 
3 60 27 48
0 
1 48
2 52 14
2 4 31
0 
0 
2 28 43
2 6 31
0 
1 7
3 45 6 48
0 
1 51
0 
2 28 20
2 37 51
1 8
53 59 39 29 23 53 27 13 16 44 34 38 24 9 32 58 54 31 1 7 45 3 30 36 17 48 42 22 18 21 6 11 25 33 37 52 10 60 49 57 2 28 8 14 5 47 4 41 35 43 50 46 26 12```

### 输出

```
1152884121210322895```

# AI分析结果



---

## 算法分类
**位运算 / 线性基**

---

## 题解思路与核心分析

### 问题转化与核心逻辑
将每个能力视为一个二进制位，权重为 $2^{k-x}$。团队能力状态等价于所有选中成员对应二进制数的异或和（奇偶性决定位的翻转）。目标转化为求最大异或和问题。

### 题解对比与难点分析
| 方法        | 实现思路                                                                 | 时间复杂度        | 适用场景         | 核心难点                           |
|-------------|--------------------------------------------------------------------------|-------------------|------------------|------------------------------------|
| 暴力枚举    | DFS/位掩码遍历所有子集，计算异或和取最大值                               | $O(2^n \cdot n)$ | $n \leq 21$      | 子集遍历与异或计算优化             |
| 线性基      | 构建线性基，贪心选取每一位的最大可能值                                   | $O(nk)$          | 任意规模 $n$     | 线性基构建与贪心策略               |
| 状态压缩 DP | 预处理所有子集的异或和，空间换时间                                       | $O(2^n \cdot n)$ | 内存可承受时     | 状态表示与压缩优化                 |

### 核心难点解决
1. **奇偶性转化为异或**：利用异或运算的奇偶特性，将能力状态转换为二进制位运算。
2. **权重映射**：将第 $x$ 能力映射到 $2^{k-x}$ 的二进制位（`1ULL << (k-x)`）。
3. **线性基构建**：通过逐位消元确保基的独立性，最终贪心选取最大异或和。

---

## 题解评分 (≥4星)
1. **阮行止（4.5星）**
   - 亮点：递归DFS清晰，注释详细，指出线性基优化方向。
   - 优化点：递归可能略慢于循环实现。

2. **Usada_Pekora（5星）**
   - 亮点：双解法对比（暴力+线性基），代码简洁高效，理论分析深入。
   - 关键代码：线性基插入与贪心查询逻辑。

3. **5k_sync_closer（4星）**
   - 亮点：位掩码循环实现，代码紧凑，适合快速实现。
   - 优化点：内层循环检查位可优化为位运算加速。

---

## 最优思路提炼
**线性基法**：
1. **构建基向量**：从高位到低位，维护独立基向量，确保每个基的最高位唯一。
2. **贪心策略**：从最高位开始，若当前结果异或基向量能更大，则选择该基。
```cpp
void insert(ull x) {
    for (int i = k-1; i >= 0; --i) {
        if (x & (1ULL << i)) {
            if (!base[i]) { base[i] = x; break; }
            else x ^= base[i];
        }
    }
}
ull query() {
    ull res = 0;
    for (int i = k-1; i >= 0; --i)
        if ((res ^ base[i]) > res) res ^= base[i];
    return res;
}
```

---

## 同类题目与算法套路
- **最大异或和模板**：洛谷 P3857 [TJOI2008]彩灯、P4570 [BJWC2011]元素。
- **线性基应用**：子集异或极值、异或空间基求解。

---

## 个人心得摘录
- **阮行止**：强调 `1ULL` 避免位移溢出，未加可能导致 WA。
- **Usada_Pekora**：从暴力到线性基的思维跃迁，展示算法优化路径。
- **ImposterAnYu**：状态压缩的暴力美学，空间换时间实践。

---

## 可视化算法演示设计
### 核心流程动画
1. **位映射展示**：用二进制网格显示每个人的能力权重（如能力5→$2^0$位）。
2. **异或过程**：动态显示选中成员时各二进制位翻转（红色表1，蓝色表0）。
3. **线性基构建**：高亮当前处理位，逐步插入基向量，冲突时异或消元。

### 复古像素风格实现
```html
<canvas id="pixelCanvas"></canvas>
<script>
// 8位风格颜色：基向量插入用绿色，冲突消元用红色
const colors = ['#000', '#0F0', '#F00', '#FFF'];
function drawBitGrid(bits) {
    // 在Canvas上绘制k位二进制网格，动态更新基向量状态
}
</script>
```

### 交互设计
- **步进控制**：暂停/继续按钮，单步观察基插入。
- **音效**：插入成功（8-bit上升音阶），冲突消元（短促“哔”声）。

---

## 代码实现（线性基法）
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
ull base[65], n, k;

void insert(ull x) {
    for (int i = k-1; i >= 0; --i) {
        if (x & (1ULL << i)) {
            if (!base[i]) { base[i] = x; break; }
            else x ^= base[i];
        }
    }
}

ull query() {
    ull res = 0;
    for (int i = k-1; i >= 0; --i)
        if ((res ^ base[i]) > res) res ^= base[i];
    return res;
}

int main() {
    cin >> n >> k;
    for (int i = 0; i < n; ++i) {
        int c, x; ull val = 0;
        cin >> c;
        while (c--) { cin >> x; val |= 1ULL << (k - x); }
        insert(val);
    }
    cout << query();
    return 0;
}
```

---
处理用时：119.09秒
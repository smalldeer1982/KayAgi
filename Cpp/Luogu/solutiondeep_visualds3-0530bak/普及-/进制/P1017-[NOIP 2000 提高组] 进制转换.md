# 题目信息

# [NOIP 2000 提高组] 进制转换

## 题目背景

NOIP2000 提高组 T1

## 题目描述

我们可以用这样的方式来表示一个十进制数：将每个阿拉伯数字乘以一个以该数字所处位置为指数，以 $10$ 为底数的幂之和的形式。例如 $123$ 可表示为 $1 \times 10^2+2\times 10^1+3\times 10^0$ 这样的形式。

与之相似的，对二进制数来说，也可表示成每个二进制数码乘以一个以该数字所处位置为指数，以 $2$ 为底数的幂之和的形式。  

一般说来，任何一个正整数 $R$ 或一个负整数 $-R$ 都可以被选来作为一个数制系统的基数。如果是以 $R$ 或 $-R$ 为基数，则需要用到的数码为 $0,1,\dots,R-1$。  

例如当 $R=7$ 时,所需用到的数码是 $0,1,2,3,4,5,6$，这与其是 $R$ 或 $-R$ 无关。如果作为基数的数绝对值超过 $10$，则为了表示这些数码，通常使用英文字母来表示那些大于 $9$ 的数码。例如对 $16$ 进制数来说,用 $A$ 表示 $10$，用 $B$ 表示 $11$，用 $C$ 表示 $12$，以此类推。

在负进制数中是用 $-R $ 作为基数，例如 $-15$（十进制）相当于 $(110001)_{-2}$（$-2$进制），并且它可以被表示为 $2$ 的幂级数的和数：

$$(110001)_{-2}=1\times (-2)^5+1\times (-2)^4+0\times (-2)^3+0\times (-2)^2+0\times (-2)^1 +1\times (-2)^0$$

设计一个程序，读入一个十进制数和一个负进制数的基数，并将此十进制数转换为此负进制下的数。


## 说明/提示

**数据范围**

对于 $100\%$ 的数据，$-20 \le R \le -2$，$|n| \le 37336$。




## 样例 #1

### 输入

```
30000 -2```

### 输出

```
30000=11011010101110000(base-2)```

## 样例 #2

### 输入

```
-20000 -2```

### 输出

```
-20000=1111011000100000(base-2)```

## 样例 #3

### 输入

```
28800 -16```

### 输出

```
28800=19180(base-16)```

## 样例 #4

### 输入

```
-25000 -16```

### 输出

```
-25000=7FB8(base-16)```

# AI分析结果



**唯一算法分类**：数学模拟

---

### **题解思路、算法要点与解决难点**

**核心思路**：  
将十进制数转换为负进制时，关键在于处理负余数。基本公式为：被除数 = 商 × 除数 + 余数。当余数为负时，通过调整商和余数，使得余数变为正。具体操作如下：  
- 若余数 < 0，则余数减去基数（变为正），商加 1。  
- 递归或循环处理商，直至商为 0。

**解决难点**：  
1. **负余数调整**：通过数学推导确保调整后的余数为正且等式成立。  
2. **倒序输出**：递归或栈结构逆序存储余数结果。  
3. **高位字符处理**：余数 ≥10 时转换为字母（如 'A'-'Z'）。

---

### **题解评分 (≥4星)**

1. **老卡手机（5星）**  
   - 思路清晰，递归实现简洁，直接处理余数调整。  
   - 代码可读性高，关键注释明确。  
   - 核心代码片段：  
     ```cpp
     if (m < 0) m -= r, n += r; // 余数调整
     ```

2. **judgejudge（4星）**  
   - 数学推导详细，循环实现直观，适合理解底层逻辑。  
   - 使用字符数组存储结果，倒序输出。  
   - 关键代码：  
     ```cpp
     if (j < 0) j -= m, n--; // 调整余数和商
     ```

3. **Temp113（4星）**  
   - 简洁的循环实现，直接处理余数并更新商。  
   - 使用 `stack` 逆序输出结果，避免显式反转。  
   - 核心代码：  
     ```cpp
     while (n) { r = n % R; ... }
     ```

---

### **最优思路或技巧提炼**

**关键技巧**：  
- **余数修正**：余数 < 0 时，余数 -= 基数，商 += 1。  
- **递归倒序**：递归先处理高位，自然实现逆序输出。  
- **字符映射**：余数 ≥10 时用字母表示，如 `m = 'A' + m - 10`。

**通用公式**：  
当余数 < 0 时：  
```
余数 -= 基数  
商 += 1  
```

---

### **同类型题或类似算法套路**

- **进制转换通法**：适用于正/负基数，核心是处理余数和商的调整。  
- **扩展场景**：如非整数基数（需额外处理小数部分）、混合进制问题。

---

### **推荐相似题目**

1. **P1022 计算器的改良**（处理进制表达式）  
2. **P1013 进制位**（进制验证与推理）  
3. **P1143 进制转换**（正基数通用解法）

---

### **可视化与算法演示**

**动画设计**：  
1. **步骤分解**：  
   - 显示当前被除数、基数、余数。  
   - 若余数 < 0，高亮显示调整操作（余数变红后修正为绿）。  
   - 更新商并进入下一步。

2. **颜色标记**：  
   - 红色：负余数。  
   - 绿色：修正后的余数。  
   - 蓝色：当前位的字符生成。

3. **交互控制**：  
   - 步进按钮：单步执行除法过程。  
   - 自动播放：按预设速度展示流程。  
   - 参数输入：允许用户自定义 n 和 R。

**复古像素效果**：  
- **8-bit 风格**：用像素字体显示余数和进制结果。  
- **音效**：调整余数时播放“嘀”声，完成时播放胜利音效。

---

### **核心代码实现**

**递归法（老卡手机）**：  
```cpp
void zhuan(int n, int r) {
    if (n == 0) return;
    int m = n % r;
    if (m < 0) m -= r, n += r; // 调整余数和商
    m = (m >= 10) ? 'A' + m - 10 : '0' + m; // 字符映射
    zhuan(n / r, r);
    printf("%c", m); // 递归实现逆序输出
}
```

---

**总结**：  
通过数学修正负余数，结合递归或循环逆序输出，是解决负进制转换的核心。可视化设计可直观展示余数调整和进制生成过程，帮助理解底层逻辑。

---
处理用时：73.20秒
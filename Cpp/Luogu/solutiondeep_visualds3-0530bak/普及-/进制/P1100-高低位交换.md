# 题目信息

# 高低位交换

## 题目描述

给出一个小于 $2^{32}$ 的非负整数。这个数可以用一个 $32$ 位的二进制数表示（不足 $32$ 位用 $0$ 补足）。我们称这个二进制数的前 $16$ 位为“高位”，后 $16$ 位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。

例如，数 $1314520$ 用二进制表示为 $0000\,0000\,0001\,0100\,0000\,1110\,1101\,1000$（添加了 $11$ 个前导 $0$ 补足为 $32$ 位），其中前 $16$ 位为高位，即 $0000\,0000\,0001\,0100$；后 $16$ 位为低位，即 $0000\,1110\,1101\,1000$。将它的高低位进行交换，我们得到了一个新的二进制数 $0000\,1110\,1101\,1000\,0000\,0000\,0001\,0100$。它即是十进制的 $249036820$。


## 样例 #1

### 输入

```
1314520
```

### 输出

```
249036820
```

# AI分析结果



# 高低位交换题解分析与算法总结

## 唯一算法分类
**位运算**

---

## 综合分析与结论
### 核心算法流程
**核心思路**：将原数的低16位左移至高16位，高16位右移至低16位  
**关键步骤**：
1. `n << 16`：低16位移至高位（低位补0）
2. `n >> 16`：高16位移至低位（高位补0）
3. 将两部分结果相加（或按位或）

**可视化设计要点**：
1. **像素网格**：用32个像素块表示二进制数，前16位用蓝色，后16位用绿色
2. **动画效果**：
   - 初始状态：显示完整32位二进制数
   - 第1帧：左移16位（绿色块飞到左边，右侧补0块）
   - 第2帧：右移16位（蓝色块飞到右边，左侧补0块）
   - 最终合并：两个半区拼接成新数
3. **音效**：位移时播放8位芯片音效，合并时播放合成音

---

## 题解清单（≥4星）
### 5星题解
1. **月影困（赞95）**
   ```cpp
   printf("%u\n", (n >> 16) + (n << 16))
   ```
   **亮点**：最简代码量，巧妙利用unsigned特性  
   **评分理由**：时间复杂度O(1)，空间复杂度O(1)，实践性极强

2. **HenryHuang（赞354）**
   ```cpp
   (x&0x0000ffff)<<16 | (x&0xffff0000)>>16
   ```
   **亮点**：显式位掩码操作，逻辑清晰  
   **评分理由**：通过掩码明确分离高低位，可读性强

3. **ejfbdn（赞4）**
   ```cpp
   return printf("%u",(a>>16)+(a<<16))&0
   ```
   **亮点**：函数式单行写法  
   **评分理由**：展示C语言IO与运算的紧凑结合

---

## 最优思路与技巧提炼
### 关键技巧
1. **无符号类型**：必须使用`unsigned int`避免符号扩展
2. **位移优先级**：注意`<<`优先级低于`+`，建议加括号
3. **溢出处理**：利用unsigned自动取模的特性简化计算

### 数学证明
设原数二进制为`A(高16位)B(低16位)`，则新数为：
```
B << 16 + A >> 16 = B * 2^16 + A / 2^16
```

---

## 同类型题目推荐
1. **P1056** [二进制中1的个数](https://www.luogu.com.cn/problem/P1056)
2. **P1909** [位操作练习](https://www.luogu.com.cn/problem/P1909)
3. **P1017** [二进制反转](https://www.luogu.com.cn/problem/P1017)

---

## 可视化代码片段
```javascript
// Canvas绘制核心逻辑
function drawBits(ctx, bits, x, y, color) {
    bits.forEach((bit, i) => {
        ctx.fillStyle = bit ? color : "#333";
        ctx.fillRect(x + i*8, y, 6, 6);
    });
}

// 动画步骤
async function animateSwap() {
    // 初始绘制
    let original = get32Bits(n);
    drawBits(ctx, original.slice(0,16), 50, 50, "#00f"); // 高位蓝色
    drawBits(ctx, original.slice(16), 50, 60, "#0f0"); // 低位绿色
    
    // 左移动画
    playSound('shift');
    await moveBlocks(original.slice(16), 50, 60, 50, 50);
    
    // 右移动画
    playSound('shift');
    await moveBlocks(original.slice(0,16), 50, 50, 50+16*8, 60);
}
```

---

## 个人心得摘录
> "最初用字符串处理总是WA，直到意识到int的符号问题。改用unsigned后立刻AC，位运算的陷阱往往在数据类型的选择上。" —— 月影困

> "掩码操作就像剪刀，0xffff0000是专门剪裁高16位的精密工具。" —— HenryHuang

---

## 复古像素化实现
**颜色方案**：
- 有效位：亮绿色(#00ff00)
- 无效位：深灰(#333333)
- 高亮位：黄色(#ffff00)

**音效设计**：
```javascript
const audioCtx = new AudioContext();
function playSound(type) {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(type === 'shift' ? 800 : 1200, audioCtx.currentTime);
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

**交互设计**：
- 空格键：单步执行
- 方向键：调整动画速度
- A键：自动播放完整流程

---

通过这种可视化设计，学习者可以直观理解位运算的底层逻辑，同时复古风格增强学习趣味性。核心算法的时间复杂度仅为O(1)，是处理此类问题的终极优化方案。

---
处理用时：72.80秒
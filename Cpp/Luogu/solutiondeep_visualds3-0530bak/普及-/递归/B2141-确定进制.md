# 题目信息

# 确定进制

## 题目描述

$6\ \times 9=42$ 对于十进制来说是错误的，但是对于 $13$ 进制来说是正确的。即 $6_{(13)}\ \times 9_{(13)}=42_{(13)}$，而 $42_{(13)}=4\ \times 13^1+2\ \times 13^0=54_{(10)}$。

你的任务是写一段程序读入三个整数 $p,q$ 和 $r$，然后确定一个进制 $B(2 \le B \le 16)$ 使得 $p\ \times q=r$。如果 $B$ 有很多选择，则输出最小的一个。

例如：$p=11,q=11,r=121$，则有 $11_{(3)}\ \times 11_{(3)}=121_{(3)}$，因为 $11_{(3)}=1\ \times 3^1+1\ \times 3^0=4_{(10)}$ 和 $121_{(3)}=1\ \times 3^2+2\ \times 3^1+1\ \times 3^0=16_{(10)}$。对于进制 $10,$ 有 $11_{(10)}\ \times 11_{(10)}=121_{(10)}$。这种情况下，应该输出 $3$。如果没有合适的进制，则输出 $0$。

## 说明/提示

$p,q,r$ 的所有位都是数字，并且 $1 \le p,q,r \le 10^6$。

## 样例 #1

### 输入

```
6 9 42```

### 输出

```
13```

# AI分析结果



**唯一算法分类**：进制转换与枚举

---

### **综合分析与结论**

**核心思路**：  
题目要求找到最小的进制B，使得三个数在B进制下的乘积成立。所有题解均采用枚举法，从可能的最小B开始验证，确保转换后的十进制乘积相等。

**关键难点与解决**：  
1. **确定最小B**：B的最小值等于输入各数位中的最大值加1。所有题解均正确处理。  
2. **进制转换**：需将B进制数转为十进制相乘，再转回B进制比较。部分题解使用累乘而非`pow`函数，避免精度问题。  
3. **大数处理**：使用`long long`避免溢出，部分题解通过累乘优化转换过程。

**可视化设计**：  
- **动画流程**：展示枚举B、转换数位、计算乘积、比较结果的过程。  
- **高亮步骤**：当前B值、转换后的十进制值、乘积结果及转换回B进制的字符串。  
- **复古像素风格**：8位像素展示数位分解与权值累加，音效提示正确/错误结果。

---

### **题解清单（≥4星）**

1. **红黑树（4星）**  
   - **亮点**：字符串处理清晰，正确转换字母位。  
   - **注意**：使用`pow`可能存在精度风险，但数据范围下可行。  
   ```cpp
   // 关键函数：进制转十进制
   long long B_to(int B, string n) {
       reverse(n.begin(), n.end());
       long long num = 0;
       for (int i = 0; i < n.size(); i++) {
           int digit = (n[i] >= '0' && n[i] <= '9') ? (n[i] - '0') : (n[i] - 'A' + 10);
           num += pow(B, i) * digit;
       }
       return num;
   }
   ```

2. **囧仙（5星）**  
   - **亮点**：累乘避免精度问题，分解整数数位高效。  
   - **心得**：直接处理整数数位，避免字符串反转。  
   ```cpp
   // 转换函数示例
   i64 a = 0, o = 1;
   while (pp) {
       a += o * (pp % 10);
       o *= B;
       pp /= 10;
   }
   ```

3. **ImposterAnYu（4星）**  
   - **亮点**：字符查找确保正确转换，主循环优化起始B。  
   - **注意**：循环查找字符效率稍低但正确。  
   ```cpp
   // 查找字符对应数值
   for (int j = 0; j <= 15; j++) {
       if (s[i] == c[j]) {
           x += j * pow(b, n - i - 1);
           break;
       }
   }
   ```

---

### **最优思路提炼**

1. **累乘代替pow函数**：手动计算B的幂次，避免精度丢失。  
2. **分解数位处理**：直接处理整数数位或字符串，确保转换正确。  
3. **确定最小B**：基于最大数位值快速缩小枚举范围。

---

### **同类题目推荐**

1. **P1143 进制转换**：基础进制转换练习。  
2. **P1604 B进制星球**：大数运算与进制结合。  
3. **P1017 负进制转换**：扩展负进制的处理思维。

---

### **可视化与算法演示**

**核心算法动画**：  
1. **枚举B值**：从最小B开始，逐步增大，高亮当前B。  
2. **数位转换**：分解p、q的数位，显示权值累加过程。  
3. **乘积比较**：展示乘积结果转B进制字符串，与r对比。

**复古像素风格**：  
- **Canvas绘制**：网格显示数位，权值累加动态变化。  
- **音效提示**：正确B时播放8-bit胜利音效，失败则低沉音效。  
- **自动演示**：AI逐步枚举B，用户可暂停/调节速度。

**代码片段（JS模拟）**：  
```javascript
// 模拟累乘转换
function convertToBase(n, base) {
    let result = 0, weight = 1;
    while (n > 0) {
        result += (n % 10) * weight;
        weight *= base;
        n = Math.floor(n / 10);
    }
    return result;
}
```

---

**个人心得**：  
- **调试关键**：确保B的最小值正确，避免无效枚举。  
- **数据类型**：`long long`避免溢出，尤其在大B值时。  
- **转换优化**：累乘法比`pow`更可靠，推荐优先使用。

---
处理用时：208.13秒
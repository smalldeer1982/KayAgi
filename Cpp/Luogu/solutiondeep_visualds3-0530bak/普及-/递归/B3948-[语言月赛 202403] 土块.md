# 题目信息

# [语言月赛 202403] 土块

## 题目背景

ScaredQiu 有一个形影不离的好朋友小 F，因为小 F 非常讨厌做题，考试的时候只能开赌。

## 题目描述

小 F 的考试中有 $n$ 道多选题，题号分别是从 $0$ 到 $n-1$ 的整数，每道题有 $4$ 个选项。一个选项要么是对的，要么是错的。一道题目的评分标准如下：

- 选择了至少一个错误选项或未选择任何选项，得 $0$ 分。

- 选择了全部的正确选项且没有选择任何错误选项，得 $6$ 分。

- 选择了一部分正确选项且没有选择任何错误选项，得 $3$ 分。

每道题目每个选项是否正确将由一个 $n$ 行 $4$ 列的 $01$ 矩阵 $a$ 描述，矩阵第 $i$ 行第 $j$ 列的元素为 $1$ 说明题号为 $i-1$ 的题目的第 $j$ 个选项是正确的，否则说明该选项是错误的。

小 F 按顺序作答了所有题目，他会给出一个 $n$ 行 $4$ 列的 $01$ 矩阵 $b$，矩阵第 $i$ 行第 $j$ 列的元素为 $1$ 说明他选择了他作答的第 $i$ 道题的第 $j$ 个选项，否则说明他没有选择该选项。

由于时间太紧，小 F 好像把答题卡涂错了。假设他作答的第 $1$ 道题的题号为 $x$，他会依次作答题号为 $x,(x+1) \bmod n,(x+2) \bmod n, \cdots ,(x+n-1) \bmod n$ 的题目。其中 $\bmod$ 为取模运算。

请计算：对于从 $0$ 到 $n-1$ 的每个整数 $i$，在作答的第 $1$ 道题的题号为 $i$ 的情况下，小 F 获得的总分数。

## 说明/提示

对于 $10\%$ 的数据，$a_{i,j}=1$。  
对于另外 $10\%$ 的数据，$b_{i,j}=0$。  
对于 $100\%$ 的数据，$1 \leq n \leq 1000$，$0 \leq a_{i,j},b_{i,j} \leq 1$，矩阵 $a$ 每行至少有一个 $1$。

## 样例 #1

### 输入

```
3
0 1 0 1
0 1 1 0
0 0 1 1
0 0 1 0
0 1 0 0
0 1 1 0
```

### 输出

```
3 3 12
```

# AI分析结果



**唯一算法分类**：模拟

---

### **综合分析与结论**

**题目核心**：  
计算每个起始题号下，小F的总得分。需处理题号的循环排列与评分规则的复杂条件判断。

**题解思路**：  
1. **评分规则判断**：  
   - 将正确答案矩阵 `a` 与作答矩阵 `b` 处理为符号相反的值相加。  
   - 若存在 `-1`，说明选中错误选项，得0分；若存在 `1`，说明部分正确，得3分；否则全正确得6分。  
2. **循环题号处理**：  
   对每个起始点 `i`，生成实际作答顺序 `(i+j)%n`，遍历所有题目计算总分。

**难点与解决**：  
- **快速判断得分条件**：通过矩阵相加后的特征值快速判断是否选中错误/遗漏正确选项，避免多层条件分支。  
- **循环排列模拟**：利用取模运算生成各起始点对应的题目序列，时间复杂度为 O(n²)，适用于 n≤1000。

**可视化设计**：  
1. **像素化矩阵展示**：  
   - 用8位风格网格展示 `a` 和 `b`，正确选项用绿色，错误用红色，选中状态高亮。  
   - 当前处理的起始点 `i` 高亮为黄色，答题顺序用流动边框表示。  
2. **得分动画**：  
   - 每个题目计算得分时，播放对应音效（0分：低音；3分：中音；6分：高音）。  
   - 总分实时更新在柱状图中，柱体颜色随分数变化。  
3. **交互控制**：  
   - 单步执行/自动播放模式，可调节速度。  
   - 失败音效在选中错误选项时触发，背景音乐为8位循环旋律。

---

### **题解清单 (≥4星)**

1. **RyanLi 的题解（★★★★★）**  
   **亮点**：  
   - 利用矩阵符号运算简化评分判断，代码简洁高效。  
   - 预处理 `b` 矩阵为负值，减少重复计算。  
   **代码片段**：  
   ```cpp
   int check(int a[4], int b[4]) {
       int sum = 0;
       for (int i=0; i<4; i++) sum += b[i];
       if (sum == 0) return 0; // 未选任何选项
       for (int i=0; i<4; i++) {
           if (a[i] + b[i] == -1) return 0; // 选错
       }
       for (int i=0; i<4; i++) {
           if (a[i] + b[i] == 1) return 3; // 漏选正确项
       }
       return 6; // 全对
   }
   ```

---

### **最优技巧提炼**

1. **符号化矩阵运算**：  
   将 `b` 矩阵元素取负后与 `a` 相加，通过特征值快速判断得分条件，避免复杂分支。  
2. **循环排列的取模处理**：  
   使用 `(i+j)%n` 生成实际题号序列，简洁高效。  
3. **预处理优化**：  
   在读取输入时直接处理 `b` 矩阵为负值，减少后续计算开销。

---

### **同类型题与套路**

- **循环排列问题**：如约瑟夫环、轮转数组。  
- **条件判断优化**：利用数值特征简化逻辑，如位运算、符号处理。

**推荐题目**：  
1. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)（模拟区间覆盖）  
2. [P2669 金币](https://www.luogu.com.cn/problem/P2669)（循环累加模拟）  
3. [P4924 魔法阵](https://www.luogu.com.cn/problem/P4924)（矩阵旋转与模拟）

---

### **代码实现**

```cpp
#include <iostream>
using namespace std;

int a[1000][4], b[1000][4];

int check(int a_row[4], int b_row[4]) {
    int sum = 0;
    for (int i = 0; i < 4; i++) sum += b_row[i];
    if (sum == 0) return 0;

    for (int i = 0; i < 4; i++) {
        if (a_row[i] + b_row[i] == -1) return 0;
    }

    bool all_zero = true;
    for (int i = 0; i < 4; i++) {
        if (a_row[i] + b_row[i] == 1) return 3;
    }
    return 6;
}

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < 4; j++) {
            cin >> a[i][j];
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < 4; j++) {
            cin >> b[i][j];
            b[i][j] *= -1; // 预处理为负值
        }
    }

    for (int i = 0; i < n; i++) {
        int total = 0;
        for (int j = 0; j < n; j++) {
            int real_q = (i + j) % n;
            total += check(a[real_q], b[j]);
        }
        cout << total << (i == n-1 ? "\n" : " ");
    }
    return 0;
}
```

---

### **可视化与复古动画示例**

**核心动画逻辑**（伪代码）：  
```javascript
// 初始化 Canvas
const canvas = document.getElementById('pixelCanvas');
const ctx = canvas.getContext('2d');
// 绘制 a 和 b 矩阵（8位风格）
drawMatrix(a, {x: 10, y: 10, color: '#00FF88'});
drawMatrix(b, {x: 200, y:10, color: '#FF8800'});

// 模拟每个起始点 i 的答题过程
for (let i = 0; i < n; i++) {
    highlightStartPoint(i); // 高亮起始点
    let score = 0;
    for (let j = 0; j < n; j++) {
        const realQ = (i + j) % n;
        const currentScore = check(a[realQ], b[j]);
        playSound(currentScore); // 播放对应音效
        score += currentScore;
        updateScoreBar(i, score); // 更新柱状图
        await delay(500); // 步进间隔
    }
}
```

**复古效果**：  
- **颜色方案**：16色调色板，绿色正确，红色错误，黄色高亮。  
- **音效**：得分时触发芯片音效，背景音乐为8位循环旋律。  
- **交互**：空格键暂停/继续，方向键调节速度。

---
处理用时：181.61秒
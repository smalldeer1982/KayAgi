# 题目信息

# [语言月赛 202404] 非众数

## 题目描述

给定一个长度为 $n$ 的字符串 $s$，保证 $s$ 仅包含小写字母，求 $s$  的非空子串中非众数串的个数。

> **定义：非空子串**
>
> 用 $s_i$ 表示 $s$ 中的第 $i$ 个字符（$1 \leq i \leq n$）。任取两个整数 $i, j$（$1 \leq i \leq j \leq n$），将 $s_i, s_{i + 1}, \cdots, s_{j}$ 截取出来按原序排列作为一个新的字符串，则这个字符串叫做 $s$ 的非空子串。  
例如，当 $s = \texttt{abcde}$ 时，$\texttt{ab}, \texttt{bcde}, \texttt{c}, \texttt{abcde}$ 都是 $s$ 的非空子串，而 $\texttt{acd}, \texttt{f}, \texttt{ngioasd}, \texttt{" "}$ 都不是 $s$ 的非空子串。

> **定义：非众数串**
>
> 若字符串 $a$ 中出现次数最多的字符出现的次数不超过 $\lfloor \frac{|a|}{2} \rfloor$，则称字符串 $a$ 为一个**非众数**串。其中 $\lfloor x \rfloor$ 代表 $\leq x$ 的最大整数，$|a|$ 代表 $a$ 的长度。

## 说明/提示

### 样例 1 解释

其中 $\texttt{ab,aabb}$ 是**非众数**非空子串。

### 数据范围

对于 $100\%$ 的数据，$1 \le n \le 500$，字符串由小写字母组成。

| 测试点编号 | $n$ | 特殊性质 |
| :-: | :-: | :-: |
| $1$ | $= 2$ | 无 |
| $2, 3$ | $\leq 10$ | 无 |
| $4$ | $\leq 500$ | 所有字符相同 |
| $5$ | $= 26$ | 所有字符不同 |
| $6, 7$ | $\leq 500$ | 字符串内仅可能包含 $\texttt{a,b}$ 两种字母 |
| $8 \sim 10$ | $\leq 500$ | 无 |

## 样例 #1

### 输入

```
aabb```

### 输出

```
2```

## 样例 #2

### 输入

```
fqmdfnc
```

### 输出

```
21
```

# AI分析结果



---

### **唯一算法分类**  
**暴力枚举 & 模拟**

---

### **综合分析与结论**  
**核心思路**：题目要求统计所有非空子串中非众数串的数量。Maxmilite的题解通过双重循环枚举所有可能的子串，逐个统计字符出现次数并检查是否满足条件。  
- **关键步骤**：  
  1. **枚举子串**：通过 `i` 和 `j` 两重循环确定子串的起始和结束位置。  
  2. **统计字符频率**：对每个子串遍历字符，用数组 `cnt` 记录各字符出现次数。  
  3. **条件检查**：遍历 `cnt` 数组，判断是否所有字符出现次数都不超过子串长度的一半。  
- **时间复杂度**：O(n³)，其中 `n` 是字符串长度。对于 `n ≤ 500` 的数据，三重循环的常数较小，可勉强通过。  
- **优化空间**：利用前缀和预处理可优化至 O(n²·26)，但当前题解未采用。  

**难点与解决**：  
- **子串数量爆炸**：直接枚举所有子串导致时间复杂度高，但题目数据范围允许暴力通过。  
- **统计效率**：每次统计子串字符频率需 O(n) 时间，通过牺牲时间换代码简洁性。  

**可视化设计思路**：  
- **动画方案**：  
  - **网格展示字符串**：将字符串字符排列为像素网格，高亮当前枚举的子串范围（如 `i` 到 `j`）。  
  - **实时统计栏**：在动画右侧显示 `cnt` 数组，用不同颜色柱状图表示各字符出现次数，动态更新。  
  - **条件判断提示**：若子串符合非众数条件，显示绿色边框；否则红色。  
- **复古像素风格**：  
  - **8位颜色**：使用 16 色调色板，字符用不同颜色方块表示（如 `a` 为蓝色，`b` 为红色）。  
  - **音效触发**：子串切换时播放“滴”声，符合条件时播放短促上扬音效。  
- **交互控制**：支持暂停/继续、单步执行、调整动画速度，便于观察算法流程。

---

### **题解清单 (≥4星)**  
**Maxmilite 的题解（⭐️⭐️⭐️⭐️）**  
- **亮点**：  
  - 思路直接，代码简洁易读，适合快速实现。  
  - 利用 `cnt` 数组统计字符频率，逻辑清晰。  
- **缺点**：未优化时间复杂度，但对题目数据范围有效。  

---

### **核心代码实现**  
```cpp
#include <bits/stdc++.h>
using namespace std;

int cnt[26];
string s;
int n, ans;

bool check(int l, int r) {
    memset(cnt, 0, sizeof(cnt));
    for (int i = l; i <= r; i++) cnt[s[i] - 'a']++;
    int len = r - l + 1;
    for (int c : cnt) 
        if (c > len / 2) return false;
    return true;
}

int main() {
    cin >> s;
    n = s.size();
    for (int i = 0; i < n; i++)
        for (int j = i; j < n; j++)
            if (check(i, j)) ans++;
    cout << ans << endl;
    return 0;
}
```

---

### **最优思路提炼**  
**前缀和优化**：  
1. 预处理前缀和数组 `prefix[i][c]`，表示前 `i` 个字符中字符 `c` 的出现次数。  
2. 对子串 `[l, r]`，各字符出现次数为 `prefix[r+1][c] - prefix[l][c]`。  
3. 将统计时间降至 O(26)，总复杂度优化至 O(n²·26)。  

**代码片段**：  
```cpp
int prefix[501][26] = {0};

// 预处理前缀和
for (int i = 0; i < n; i++) {
    for (int c = 0; c < 26; c++) 
        prefix[i+1][c] = prefix[i][c];
    prefix[i+1][s[i]-'a']++;
}

// 查询子串 [l, r]
bool valid = true;
int len = r - l + 1;
for (int c = 0; c < 26; c++) {
    int cnt = prefix[r+1][c] - prefix[l][c];
    if (cnt > len / 2) { valid = false; break; }
}
```

---

### **同类型题与套路**  
- **通用解法**：涉及子串统计的问题，常通过前缀和或滑动窗口优化。  
- **类似题目**：  
  1. 统计子串中字符唯一的最长子串（LeetCode 395）。  
  2. 寻找所有回文子串（LeetCode 647）。  

---

### **推荐洛谷题目**  
1. **P2408 不同子串个数**：统计字符串不同子串的数量。  
2. **P3405 前缀和练习**：利用前缀和优化子串统计。  
3. **P2678 跳石头**：二分答案与滑动窗口结合。  

---

### **个人心得**  
- **调试关键**：注意字符串索引从 0 开始，循环边界需严格满足 `i ≤ j < n`。  
- **优化启发**：暴力解法在数据范围较小时可行，但需掌握前缀和等优化技巧以应对更大规模数据。  

---

### **可视化与复古动画**  
**实现要点**：  
- **Canvas 绘制**：  
  - 字符串字符显示为 16x16 像素方块，颜色按字母映射（如 `a`→#FF0000，`b`→#00FF00）。  
  - 当前子串 `[i, j]` 高亮为黄色边框，统计结果实时显示。  
- **音效设计**：  
  - 子串切换：8-bit “哔”声（Web Audio API 生成方波）。  
  - 符合条件：播放胜利音效（频率上升序列）。  
- **自动演示模式**：  
  - 按固定速度枚举子串，用户可暂停观察统计细节。  

**交互示例**：  
```javascript
// 伪代码：Canvas 绘制子串 [i,j]
function drawSubstring(i, j) {
    ctx.clearRect(0, 0, width, height);
    for (let k = 0; k < n; k++) {
        if (k >= i && k <= j) ctx.fillStyle = "#FFFF00"; // 高亮
        else ctx.fillStyle = getColor(s[k]);
        ctx.fillRect(k * 20, 0, 18, 18);
    }
}
```

---
处理用时：150.36秒
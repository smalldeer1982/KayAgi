# 题目信息

# [朝阳区小学组 2019] square

## 题目背景

数据为洛谷自造。本场比赛第六题为 [P2261 余数求和](https://www.luogu.com.cn/problem/P2261)，请前往该题目交题。

## 题目描述

任意一个边长是整数的长方形都可以分割成若干个边长是正整数的正方形，分割的方式有很多种，你需要找到分割出的所有正方形边长之和最小的那一种分割方法。

即：将边长为正整数 $A,B$ 的长方形划分成若干边长均为正整数，且每个正方形的边均平行于长方形的相应边，试求这些正方形边之和的最小值 $\min$。

如果这个长方形可以分成 $N$ 个正方形，其中每个边长为 $C_i$，那么 $\min=C_1+C_2+\dots+C_N$。注意，数组 $C$ 中的元素可能相等。

## 说明/提示

对于 $30\%$ 的数据，$A_i,B_i$ 为 `int` 范围内的正整数；

对于 $100\%$ 的数据，$A_i,B_i$ 为 `long long` 范围内的正整数。

## 样例 #1

### 输入

```
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1```

### 输出

```
1
2
3
4
5
6
7
8
9
10```

# AI分析结果



**唯一算法分类**：贪心算法

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   - **贪心策略**：每次分割尽可能大的正方形（边长为当前长方形的较小边），减少后续分割次数，从而最小化总边长之和。
   - **快速规模缩减**：通过除法计算可分割的正方形个数，避免逐个减法，时间复杂度优化至 \(O(\log(\min(A, B)))\)。

2. **算法步骤**  
   - **循环分割**：每次取当前长方形的较小边作为正方形边长，计算可分割数量 \(k = \lfloor \text{max}(A, B) / \text{min}(A, B) \rfloor\)。
   - **累加总和**：将 \(k \times \text{min}(A, B)\) 累加到答案。
   - **更新尺寸**：将较长边更新为 \(\text{max}(A, B) \% \text{min}(A, B)\)，直到某一边为 0。

3. **关键难点**  
   - **时间复杂度优化**：避免线性减法的超时问题（如当 \(A=1, B=10^{18}\) 时）。
   - **数据类型处理**：总和可能超出 `long long` 范围，需使用 `unsigned long long`。

---

### **题解评分 (≥4星)**

| 作者/题解          | 评分 | 关键亮点                                                                 |
|--------------------|------|--------------------------------------------------------------------------|
| **Priestess_SLG**  | ⭐⭐⭐⭐ | 正确使用辗转相除法优化时间复杂度，数据类型处理严谨。                      |
| **darklf**         | ⭐⭐⭐⭐ | 代码简洁高效，直接使用取模运算快速缩减规模。                              |
| **_Pioneer_**      | ⭐⭐⭐⭐ | 循环逻辑清晰，正确处理溢出问题，代码可读性强。                            |

---

### **最优思路或技巧提炼**

1. **贪心策略的数学基础**  
   - 每次取最大正方形是局部最优解，累积后形成全局最优解。
   - 总边长和的计算本质是 \(A + B - \gcd(A, B)\)（需验证）。

2. **快速规模缩减技巧**  
   - 使用除法与取模运算代替逐次减法，时间复杂度优化为对数级。

3. **数据类型选择**  
   - `unsigned long long` 防止溢出，确保大数计算正确性。

---

### **同类型题或类似算法套路**

- **辗转相除法思想**：类似求最大公约数（GCD）的优化思路。
- **贪心分割问题**：如硬币问题（用最少硬币凑金额）、区间覆盖问题。

---

### **推荐相似题目**

1. **P2261 [CQOI2007]余数求和**  
   - 类似数学优化，利用除法分块加速求和。

2. **P1516 青蛙的约会**  
   - 扩展欧几里得算法的应用，与规模缩减思想相关。

3. **P5656 二元一次不定方程**  
   - 整数解的存在性与范围分析，涉及数论优化。

---

### **个人心得摘录**

- **调试教训**：最初递归未优化导致超时，后改用除法取模一步到位。  
  —— *zzq3 题解中的优化经历*
- **顿悟时刻**：意识到总边长和实为 \(A + B - \gcd(A, B)\)，但需验证正确性。  
  —— *Ag2WO4 题解的数学推导*

---

### **可视化与算法演示**

#### **动画设计**
- **像素风格界面**：  
  - 长方形用 8-bit 颜色块表示，当前操作的正方形高亮为红色。  
  - 每次分割后，剩余部分变为绿色，分割出的正方形变为灰色。  
- **关键步骤标记**：  
  - **高亮当前边**：较长边用蓝色边框标记，较短边用黄色。  
  - **步进控制**：支持单步执行，展示 \(k\) 个正方形如何填充。  
- **音效提示**：  
  - 分割时播放“哔”声，完成时播放胜利音效（8-bit MIDI）。

#### **代码片段（伪代码）**
```javascript
// Canvas 绘制逻辑
function drawRect(a, b) {
  ctx.fillStyle = '#8B0000'; // 深红色表示当前长方形
  ctx.fillRect(0, 0, a * scale, b * scale);
}

// 核心算法步骤演示
function nextStep() {
  if (a === 0 || b === 0) return;
  const min = Math.min(a, b);
  const k = Math.floor(Math.max(a, b) / min);
  total += k * min;
  // 高亮分割出的正方形
  ctx.fillStyle = '#FFD700'; // 金色表示已分割
  ctx.fillRect(0, 0, min * scale, min * scale * k);
  // 更新尺寸
  if (a > b) a %= b;
  else b %= a;
}
```

---

### **完整代码（C++）**
```cpp
#include <bits/stdc++.h>
using namespace std;
using ull = unsigned long long;

int main() {
    for (int i = 0; i < 10; ++i) {
        ull a, b, sum = 0;
        cin >> a >> b;
        while (a && b) {
            if (a < b) swap(a, b);
            ull k = a / b;
            sum += k * b;
            a %= b;
        }
        cout << sum << '\n';
    }
    return 0;
}
```

**核心逻辑**：循环取模，快速缩减尺寸，累加边长和。时间复杂度 \(O(\log \min(A, B))\)。

---
处理用时：84.57秒
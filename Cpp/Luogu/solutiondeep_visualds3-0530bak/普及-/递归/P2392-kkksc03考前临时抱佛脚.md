# 题目信息

# kkksc03考前临时抱佛脚

## 题目背景

kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。


## 题目描述

这次期末考试，kkksc03 需要考 $4$ 科。因此要开始刷习题集，每科都有一个习题集，分别有 $s_1,s_2,s_3,s_4$ 道题目，完成每道题目需要一些时间，可能不等（$A_1,A_2,\ldots,A_{s_1}$，$B_1,B_2,\ldots,B_{s_2}$，$C_1,C_2,\ldots,C_{s_3}$，$D_1,D_2,\ldots,D_{s_4}$）。


kkksc03 有一个能力，他的左右两个大脑可以同时计算 $2$ 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。


由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。


## 说明/提示

$1\leq s_1,s_2,s_3,s_4\leq 20$。

$1\leq A_1,A_2,\ldots,A_{s_1},B_1,B_2,\ldots,B_{s_2},C_1,C_2,\ldots,C_{s_3},D_1,D_2,\ldots,D_{s_4}\leq60$。

## 样例 #1

### 输入

```
1 2 1 3		
5
4 3
6
2 4 3
```

### 输出

```
20```

# AI分析结果



# 算法分类
动态规划（01背包）

---

## 综合分析与结论
**核心思路**：将每个科目的题目时间总和分为两半，用01背包求最接近半值的子集和，总耗时为较大半值之和。  
**解决难点**：将多科目问题拆解为四个独立的子问题，每个子问题转化为经典的01背包模型。  
**关键步骤**：
1. 计算每个科目总时间 `sum`
2. 用容量为 `sum/2` 的01背包求最大可装时间 `dp[sum/2]`
3. 该科目耗时取 `sum - dp[sum/2]`（因 `sum - dp[sum/2] ≥ dp[sum/2]`）

**可视化设计**：
- **动画方案**：以像素网格表示背包容量，物品下落时高亮当前物品时间，动态展示 `dp` 数组更新过程，用红蓝两色区分左右脑分配。
- **复古风格**：采用8-bit音效，背包填满时播放胜利音效，每个科目处理完毕后显示像素化统计面板。
- **交互设计**：通过方向键控制算法步进速度，空格键暂停/继续，按F键触发自动演示模式。

---

## 题解清单 (≥4星)
### 1. hmh13951417981（5星）
- **亮点**：简洁的滚动数组优化，通过复用 `dp` 数组减少内存占用
- **代码核心**：
  ```cpp
  for(k=sum/2;k>=homework[j];k--)
    dp[k]=max(dp[k],dp[k-homework[j]]+homework[j]);
  t += sum-dp[sum/2];
  ```

### 2. 长河落日（4星）
- **亮点**：DFS暴力枚举所有组合，清晰展示回溯过程
- **心得**："20的数据范围放心大胆2^n枚举，剪枝都不用"

### 3. 不存在之人（5星）
- **亮点**：模块化设计将科目处理封装为函数，代码高度复用
- **核心逻辑**：
  ```cpp
  int work(int n){
    //...计算sum并初始化背包
    return max(f[m/2],m-f[m/2]);
  }
  ```

---

## 核心代码实现
**动态规划解法（最优）**：
```cpp
int main() {
    int s[4], total = 0;
    for (int i=0; i<4; i++) cin >> s[i];
    
    for (int subj=0; subj<4; subj++) {
        int sum=0, dp[601]={0}, time[20];
        for (int i=0; i<s[subj]; i++) {
            cin >> time[i];
            sum += time[i];
        }
        for (int i=0; i<s[subj]; i++) 
            for (int j=sum/2; j>=time[i]; j--)
                dp[j] = max(dp[j], dp[j-time[i]] + time[i]);
        total += sum - dp[sum/2];
    }
    cout << total;
}
```

---

## 相似题目推荐
1. **P1048 采药** - 经典01背包模板题
2. **P2347 砝码称重** - 多重背包变式
3. **P1466 集合** - 相同分割思想的高阶应用

---

## 可视化代码片段（Canvas动画）
```javascript
// 背包更新动画核心逻辑
function drawBag(capacity, items) {
    ctx.fillStyle = "#2C3E50";
    ctx.fillRect(0,0,800,600); // 清空画布
    
    // 绘制背包当前状态
    items.forEach((item, idx) => {
        const y = 100 + idx*30;
        ctx.fillStyle = idx === currentItem ? "#E74C3C" : "#3498DB";
        ctx.fillRect(50, y, item*5, 25); // 用长度表示时间
    });
    
    // 绘制dp数组
    for(let i=0; i<=capacity; i++) {
        ctx.fillStyle = dp[i] ? "#2ECC71" : "#95A5A6";
        ctx.fillRect(300 + i*2, 500 - dp[i]*3, 2, dp[i]*3); 
    }
}
```

---

## 个人心得摘录
> "贪心不是正解，一个反例就足够推翻。动态规划虽然需要多写几行，但能保证正确性。" —— hmh13951417981  
> "20的数据范围其实暗示了暴力可行性，但竞赛中还是应该优先考虑DP" —— 长河落日

---

通过将每个科目转化为01背包问题，并利用动态规划高效求解，本算法在时间和空间复杂度上达到最优平衡，成为该题的标准解法。

---
处理用时：104.41秒
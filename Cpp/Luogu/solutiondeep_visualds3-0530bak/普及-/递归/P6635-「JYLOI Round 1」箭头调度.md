# 题目信息

# 「JYLOI Round 1」箭头调度

## 题目描述

moyu_028 给了你一个有 $n$ 个点 $m$ 条边的无向图，现在要给每条边赋一个方向，现在请你求出一个赋方向的方案，使得按照这个方案能够生成一个拓扑序，且使得这个拓扑序是在所有可能的拓扑序中字典序第 $k$ 小的。


## 说明/提示

## 提示

拓扑序：在一个 DAG（有向无环图）中，我们将图中的顶点以线性方式进行排序，使得对于任何的顶点 $u$ 到 $v$ 的有向边 $(u,v)$，都可以有 $u$ 在 $v$ 的前面，则这样的序列称为拓扑序。

----------

## 样例解释

### 样例 1 解释

答案的图如下，根据图可得出答案。

![](https://i.loli.net/2020/05/23/3FK2n78JAYLrGMD.png)

-----------------

## 数据范围

对于 $100\%$ 的数据，$1 \leq n \leq 11, 1 \leq m \leq 2 \times 10^3, 1 \leq k \leq 10^8，1 \leq x_i, y_i \leq n, x_i \not= y_i$。

对于测试点 1（10 分）：$n = 1$。

对于测试点 2（30 分）：$n \leq 11, m \leq 20$。

对于测试点 3（30 分）：$n \leq 11, k = 1$。

对于测试点 4（30 分）：无特殊限制。

本题共 4 个测试点，总分为 100 分，单个测试点的时间限制为 5 秒。

## 题目来源

「JYLOI Round 1」 A

Idea：moyu_028 & abcdeffa

Solution：LiuXiangle

Data：abcdeffa

## 样例 #1

### 输入

```
6 7 5
1 3
2 1
4 2
4 3
4 5
3 6
5 6```

### 输出

```
0111001```

## 样例 #2

### 输入

```
11 20 20091210
2 3
3 1
2 5
4 6
7 9
8 10
8 1
7 2
2 3
3 2
4 5
5 7
7 6
7 8
9 7
9 8
10 2
2 3
1 3
1 7```

### 输出

```
10110000100110110111```

# AI分析结果



1. **算法分类选择**  
   图论构造、排列生成

2. **题解思路、算法要点与解决难点**  
   **核心思路**：将问题转化为生成第k小的排列，并通过排列中元素的位置决定边的方向。  
   **核心步骤**：  
   - 利用康托展开逆过程生成第k小的全排列  
   - 建立节点到排列位置的映射  
   - 遍历所有边，根据排列中的相对位置决定方向（排列顺序早的节点指向顺序晚的节点）  

   **解决难点**：  
   - 快速生成大k值的排列：通过阶乘分解代替暴力枚举，将时间复杂度从O(kn)优化到O(n²)  
   - 确保构造的图无环：通过排列的线性顺序保证边的方向一致性，从而天然形成DAG  

3. **题解评分**  
   ⭐⭐⭐⭐ MoonCake2011（代码简洁但next_permutation仅适用于小k值）  
   ⭐⭐⭐⭐ wzkdh（康托展开正确思路，但xy数组处理存在反向问题）  
   ⭐⭐⭐⭐ HNOIRPplusplus（阶乘分解思路最优，但需修正xy映射逻辑）  

4. **最优思路或技巧提炼**  
   **阶乘分解法**：通过计算剩余阶乘快速定位每一位的候选数，例如对k=5的排列：  
   ```python
   k=5 → k-1=4 (0-based)
   阶乘分解：4 = 1*3! + 3*2! + 0*1! → 排列[2,4,3,1]
   ```
   **边方向映射**：将排列元素的位置视为拓扑序，保证边始终从前序节点指向后序节点。

5. **同类型题或类似算法套路**  
   - 全排列生成与映射构造结合  
   - 字典序相关的拓扑排序构造  

6. **推荐题目**  
   - P1706 全排列问题（基础排列生成）  
   - P3014 [USACO11FEB] Cow Line（康托展开应用）  
   - P1037 [NOIP2003 普及组] 产生数（图论与排列组合结合）  

7. **可视化与算法演示**  
   **动画方案**：  
   - 左侧面板：动态展示阶乘分解过程，高亮当前选择的数字  
   - 右侧面板：实时构建排列，并用不同颜色标记已选/未选数字  
   - 底部面板：展示边的方向决策过程，用箭头动态连接节点  

   **复古像素风格**：  
   - 用16色像素块表示节点，边方向用闪烁箭头表示  
   - 音效设计：选择数字时播放8-bit点击音，完成排列时播放胜利音效  

8. **代码实现**  
   修正后的康托展开实现：
   ```cpp
   #include <bits/stdc++.h>
   using namespace std;

   int n, m, k, fact[12] = {1}, ans[12], pos[12];
   bool used[12];

   void generate_permutation() {
       k--; // Convert to 0-based
       vector<int> available;
       for (int i = 1; i <= n; ++i) available.push_back(i);
       
       for (int i = n-1; i >= 0; --i) {
           int f = fact[i];
           int idx = k / f;
           k %= f;
           
           ans[n-1 - i] = available[idx]; // Store in correct order
           available.erase(available.begin() + idx);
       }
   }

   int main() {
       for (int i = 1; i <= 11; ++i) fact[i] = fact[i-1] * i;
       cin >> n >> m >> k;
       
       generate_permutation();
       for (int i = 0; i < n; ++i) 
           pos[ans[i]] = i+1; // Correct position mapping
       
       while (m--) {
           int u, v; cin >> u >> v;
           cout << (pos[u] > pos[v]); // 0 if u comes before v
       }
       return 0;
   }
   ```

---
处理用时：327.17秒
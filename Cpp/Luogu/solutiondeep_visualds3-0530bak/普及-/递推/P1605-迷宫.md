# 题目信息

# 迷宫

## 题目描述

给定一个 $N \times M$ 方格的迷宫，迷宫里有 $T$ 处障碍，障碍处不可通过。

在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。

给定起点坐标和终点坐标，每个方格最多经过一次，问有多少种从起点坐标到终点坐标的方案。

## 说明/提示

对于 $100\%$ 的数据，$1 \le N,M \le 5$，$1 \le T \le 10$，$1 \le SX,FX \le n$，$1 \le SY,FY \le m$。

## 样例 #1

### 输入

```
2 2 1
1 1 2 2
1 2
```

### 输出

```
1```

# AI分析结果



### 算法分类
**深度优先搜索 (DFS)**

---

### 题解思路、算法要点与解决难点

#### 核心思路
所有题解均基于 **DFS 回溯算法**，核心流程如下：
1. **初始化地图**：标记障碍点，起点终点坐标。
2. **递归探索路径**：从起点出发，向上下左右四个方向探索。
3. **标记与回溯**：访问过的点标记为已访问，递归返回后恢复状态。
4. **终点判断**：到达终点时计数器加一。

#### 难点与解决
1. **重复路径问题**  
   - **关键点**：使用二维数组 `vis` 标记已访问的路径，防止重复访问。
   - **解决**：递归前标记当前点为已访问，回溯时恢复为未访问。

2. **障碍与边界处理**  
   - **关键点**：检查坐标是否越界或遇到障碍（部分题解将障碍存入 `map` 数组）。
   - **解决**：`if (x < 1 || x > n || y < 1 || y > m || map[x][y] == 1) return;`

3. **终点特殊处理**  
   - **关键点**：终点可能被障碍覆盖（直接输出 0）。
   - **解决**：预处理检查终点是否为障碍。

#### 优化与技巧
- **方向数组**：用 `dx[4]` 和 `dy[4]` 代替多个 `if` 分支，简化代码（如 `dx = {0,0,1,-1}` 对应上下右左）。
- **合并状态管理**：部分题解将障碍和访问标记合并到同一数组，节省空间。
- **提前剪枝**：若终点被障碍阻挡，直接返回 0，避免无效搜索。

---

### 题解评分 (≥4星)

1. **作者：ybb756032937 (5星)**  
   - **亮点**：方向数组简化代码，独立 `map` 和 `vis` 数组逻辑清晰，注释详细。
   - **代码片段**：
     ```cpp
     int dx[4]={0,0,1,-1}, dy[4]={-1,1,0,0};
     void walk(int x, int y) {
         if (到达终点) total++;
         for (int i=0; i<4; i++) {
             int nx = x + dx[i], ny = y + dy[i];
             if (可访问且未越界) {
                 vis[x][y] = 1;
                 walk(nx, ny);
                 vis[x][y] = 0; // 回溯
             }
         }
     }
     ```

2. **作者：Billy●Herrington (4星)**  
   - **亮点**：强调起点需预先标记，避免重复计数。
   - **代码片段**：
     ```cpp
     G[sx][sy] = true; // 起点标记
     dfs(sx, sy);
     ```

3. **作者：拱垲 (4星)**  
   - **亮点**：边界处理与方向数组结合，代码简洁。
   - **代码片段**：
     ```cpp
     const int nextx[4]={0,0,1,-1}, nexty[4]={-1,1,0,0};
     if (越界或已访问) return;
     ```

---

### 最优思路与技巧
1. **方向数组优化**：用 `dx/dy` 数组代替多分支 `if`，减少代码冗余。
2. **状态回溯**：递归后必须恢复访问标记，否则路径计数错误。
3. **终点预判**：提前检查终点是否为障碍，提升效率。
4. **8位像素风可视化**：以网格动画展示 DFS 探索过程，高亮当前路径与回溯。

---

### 同类型题与算法套路
- **通用套路**：二维网格中的路径问题（如八皇后、单词搜索）。
- **相似题目**：
  1. **P1219 八皇后**：DFS 回溯标记行列对角线。
  2. **P1238 走迷宫**：记录路径输出的迷宫变种。
  3. **P1506 拯救oibh总部**：连通块计数与边界处理。

---

### 可视化与算法演示
#### 动画设计
- **Canvas 网格**：绘制 N×M 网格，起点绿色、终点红色、障碍黑色。
- **高亮路径**：当前探索的路径用黄色标记，回溯时恢复为白色。
- **音效触发**：
  - **移动**：播放 `8-bit` 短音效。
  - **找到路径**：上扬音效 + 路径闪烁。
- **自动演示**：按固定速度逐步执行递归，支持暂停/步进。

#### 复古像素风格
```javascript
// 示例：绘制网格与状态
ctx.fillStyle = '#00FF00'; // 起点绿色
ctx.fillRect(sx * cellSize, sy * cellSize, cellSize, cellSize);
ctx.fillStyle = '#FF0000'; // 终点红色
ctx.fillRect(fx * cellSize, fy * cellSize, cellSize, cellSize);
```

#### 交互控制
```html
<button onclick="pause()">暂停</button>
<button onclick="step()">步进</button>
<input type="range" id="speed" min="100" max="1000">
```

---

### 核心代码实现
```cpp
#include <iostream>
using namespace std;

int n, m, t, sx, sy, fx, fy, ans = 0;
bool vis[6][6] = {0}, obstacle[6][6] = {0};
int dx[] = {0,0,1,-1}, dy[] = {1,-1,0,0};

void dfs(int x, int y) {
    if (x == fx && y == fy) { ans++; return; }
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i], ny = y + dy[i];
        if (nx < 1 || ny < 1 || nx > n || ny > m) continue;
        if (!vis[nx][ny] && !obstacle[nx][ny]) {
            vis[nx][ny] = 1;
            dfs(nx, ny);
            vis[nx][ny] = 0; // 回溯
        }
    }
}

int main() {
    cin >> n >> m >> t >> sx >> sy >> fx >> fy;
    while (t--) { int x,y; cin >> x >> y; obstacle[x][y] = 1; }
    if (obstacle[fx][fy]) { cout << 0; return 0; }
    vis[sx][sy] = 1; // 标记起点
    dfs(sx, sy);
    cout << ans;
    return 0;
}
```

---
处理用时：90.24秒
# 题目信息

# 最大加权矩形

## 题目描述

为了更好的备战 NOIP2013，电脑组的几个女孩子 LYQ,ZSC,ZHQ 认为，我们不光需要机房，我们还需要运动，于是就决定找校长申请一块电脑组的课余运动场地，听说她们都是电脑组的高手，校长没有马上答应他们，而是先给她们出了一道数学题，并且告诉她们：你们能获得的运动场地的面积就是你们能找到的这个最大的数字。

校长先给他们一个 $n\times n$ 矩阵。要求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大 。矩阵的每个元素属于 $[-127,127]$ ,例如

```plain
 0 –2 –7  0 
 9  2 –6  2
-4  1 –4  1 
-1  8  0 –2
```

在左下角：

```plain
9  2
-4  1
-1  8
```

和为 $15$。

几个女孩子有点犯难了，于是就找到了电脑组精打细算的 HZH，TZY 小朋友帮忙计算，但是遗憾的是他们的答案都不一样，涉及土地的事情我们可不能含糊，你能帮忙计算出校长所给的矩形中加权和最大的矩形吗？


## 说明/提示

$1 \leq n\le 120$

## 样例 #1

### 输入

```
4
0 -2 -7 0
 9 2 -6 2
-4 1 -4  1 
-1 8  0 -2
```

### 输出

```
15```

# AI分析结果



**唯一算法分类**：动态规划（二维转一维的最大子段和）

---

### 综合分析与结论

#### 核心思路
所有题解围绕**二维转一维**的核心思想展开，通过以下两种方式实现：
1. **矩阵压缩**：枚举子矩阵的上下边界，将多行数据按列压缩为单行数值（列求和），转化为一维最大子段和问题（时间复杂度 O(n³)）。
2. **二维前缀和**：预计算区域和，通过四重循环枚举所有子矩阵（时间复杂度 O(n⁴)），但通过前缀和优化区域和计算。

#### 解决难点
- **降维处理**：将二维矩阵压缩为多个一维数组，利用经典的最大子段和动态规划算法。
- **时间复杂度优化**：矩阵压缩法将 O(n⁴) 的暴力枚举优化为 O(n³)，在 n=120 时可行。

#### 可视化设计
1. **核心动画流程**：
   - **行边界枚举**：高亮当前处理的上下边界（如蓝色边框）。
   - **列压缩过程**：用流动箭头表示列求和，生成一维数组。
   - **一维最大子段和**：动态显示 DP 数组变化，用绿色高亮当前最大子段。
2. **像素风格**：
   - 矩阵用 8x8 像素块表示，不同数值用不同颜色（负数为红色，正数为绿色）。
   - 最大子段和计算时，用闪烁效果标记关键决策点（是否抛弃前序和）。
3. **音效交互**：
   - 行边界切换时播放 "beep" 音效。
   - 发现更大子段和时播放上扬音效。

---

### 题解清单（评分 ≥4星）

1. **Yaser（★★★★★）**
   - **亮点**：清晰展示矩阵压缩过程，代码结构模块化（分离列压缩与DP计算）。
   - **关键代码**：
     ```cpp
     void MatrixSum() {
         loop(i, 1, n) { // 枚举上边界
             mset(temp, 0);
             loop(j, i, n) { // 累加下边界
                 loop(k, 1, n) temp[k] += matrix[j][k];
                 Arrsum(); // 调用一维DP
             }
         }
     }
     ```

2. **X_WT（★★★★☆）**
   - **亮点**：纵向前缀和预处理，减少重复计算。
   - **优化技巧**：`a[i][j] += a[i-1][j]` 实现纵向累加，直接通过减法获取任意行区间和。

3. **tommymio（★★★★☆）**
   - **亮点**：去除了传统 DP 数组，用单个变量实时维护最大和。
   - **代码片段**：
     ```cpp
     if(sum < 0) sum = 0;
     sum += tmp;
     if(sum > ans) ans = sum;
     ```

---

### 最优思路与技巧

1. **矩阵压缩模板**：
   ```python
   for top in 1..n:
       reset temp[]
       for bottom in top..n:
           for col in 1..n:
               temp[col] += matrix[bottom][col]
           run_max_subarray(temp)  # 最大子段和
   ```

2. **前缀和加速**：
   - 纵向前缀和：`sum[i][j] = sum[i-1][j] + matrix[i][j]`
   - 任意子矩阵和：`sum[bottom][j] - sum[top-1][j]`

3. **实时更新优化**：
   - 维护当前最大和变量，避免存储完整 DP 数组。

---

### 同类型题目与算法套路

1. **一维扩展**：[P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
2. **三维扩展**：立方体最大子立方体（需要三维压缩为二维）
3. **环形扩展**：环形矩阵的最大子段和（破环为链）

---

### 推荐题目
1. [P2642 双子序列最大和](https://www.luogu.com.cn/problem/P2642)  
   （二维压缩思想的线性扩展）
2. [P1381 最大子矩阵](https://www.luogu.com.cn/problem/P1381)  
   （带宽度限制的二维压缩）
3. [P2004 领地选择](https://www.luogu.com.cn/problem/P2004)  
   （固定尺寸子矩阵优化）

---

### 个人心得摘录
> "枚举上下边界时，初学常犯的错误是忘记重置临时数组。调试时发现最大值总偏大，原来是上一轮数据未清空。后来在每次上边界变化时强制初始化，问题迎刃而解。"  
> —— 摘自题解作者调试经历

---

### 可视化核心代码（JS 伪代码）
```javascript
class MatrixAnimator {
  constructor(matrix) {
    this.ctx = document.getElementById('canvas').getContext('2d');
    this.matrix = matrix;
    this.currentTop = 1;
  }

  drawMatrix() {
    // 绘制矩阵，用颜色区分正负值
    this.matrix.forEach((row, i) => {
      row.forEach((val, j) => {
        this.ctx.fillStyle = val >= 0 ? '#00FF88' : '#FF0044';
        this.ctx.fillRect(j*16, i*16, 15, 15);
      });
    });
  }

  async compressRows(top, bottom) {
    // 高亮当前处理的行范围
    this.highlightRows(top, bottom, '#FFFF00');
    await sleep(1000); // 动画暂停
    
    // 列压缩动画
    for(let col=0; col<this.n; col++){
      let sum = 0;
      for(let row=top; row<=bottom; row++){
        sum += this.matrix[row][col];
        this.ctx.fillStyle = '#00FFFF'; // 高亮累加过程
        this.ctx.fillRect(col*16, row*16, 15, 15);
        await sleep(200);
      }
      this.tempArray[col] = sum; // 更新压缩数组
    }
  }
}
```

---
处理用时：88.93秒
# 题目信息

# 填涂颜色

## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 30$。


## 样例 #1

### 输入

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

### 输出

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

# AI分析结果



**唯一算法分类**：洪水填充法（Flood Fill）  

---

### **题解分析与结论**  
#### **核心思路与难点**  
1. **逆向思维**：直接判断闭合圈内的0困难，转而通过标记闭合圈外的0间接求解。  
2. **边界处理**：通过扩展矩阵边界（如从原矩阵外包裹一圈0），避免处理复杂边界条件。  
3. **算法选择**：DFS/BFS遍历标记所有与扩展边界连通的0，剩余未标记的0即为闭合圈内区域。  

#### **可视化设计思路**  
1. **扩展边界高亮**：用不同颜色（如灰色）标记新增的虚拟边界，突出其辅助作用。  
2. **动态填充效果**：通过渐变色块展示BFS/DFS的扩散过程，已标记区域逐渐变为绿色。  
3. **像素风格动画**：使用8-bit网格显示矩阵，每次访问节点时播放“滴答”音效，闭合圈内填充时播放“叮”声。  

---

### **题解清单（≥4星）**  
1. **zhy137036（5星）**  
   - **亮点**：扩展矩阵边界，从虚拟边界开始搜索，代码简洁高效。  
   - **代码片段**：  
     ```cpp  
     void dfs(int x, int y) {  
         if (x<0 || x>n+1 || y<0 || y>n+1 || a[x][y]!=0) return;  
         a[x][y] = 1;  
         for (int i=1; i<=4; i++) dfs(x+dx[i], y+dy[i]);  
     }  
     ```  

2. **LMB_001（4星）**  
   - **亮点**：DFS从(0,0)开始染色，直接标记外围0，逻辑清晰。  
   - **代码片段**：  
     ```cpp  
     void dfs(int p, int q) {  
         if (p<0 || p>n+1 || q<0 || q>n+1 || a[p][q]!=0) return;  
         a[p][q] = 1;  
         for (int i=1; i<=4; i++) dfs(p+dx[i], q+dy[i]);  
     }  
     ```  

3. **冰冻赤道（4星）**  
   - **亮点**：BFS枚举四个边界点，逐个处理连通块，适合理解队列操作。  
   - **代码片段**：  
     ```cpp  
     void bfs(int x, int y) {  
         queue<int> q;  
         q.push(x); q.push(y);  
         vis[x][y] = 1;  
         while (!q.empty()) {  
             int w = q.front(); q.pop();  
             int e = q.front(); q.pop();  
             if (map[w+1][e] == 0 && w != n) { /*...*/ }  
         }  
     }  
     ```  

---

### **最优技巧提炼**  
1. **虚拟边界法**：扩展矩阵边界，避免复杂边界判断（zhy137036）。  
2. **逆向染色逻辑**：标记外部区域而非内部区域，降低问题复杂度。  
3. **统一染色标记**：用特殊值（如2）表示待处理区域，避免覆盖原始数据。  

---

### **同类型题与算法套路**  
1. **通用解法**：所有需要区分内外区域的连通性问题，均可通过扩展虚拟边界+逆向染色解决。  
2. **类似题目**：  
   - **P1506 拯救oibh总部**（矩阵中被1包围的0）  
   - **P1451 求细胞数量**（连通块计数）  
   - **P3395 道路阻塞**（BFS最短路径变形）  

---

### **推荐洛谷题目**  
1. **P1506**：与本题几乎相同，要求标记被围墙包围的区域。  
2. **P1451**：统计连通块数量，练习基础BFS/DFS。  
3. **P3395**：BFS最短路径问题，涉及动态障碍处理。  

---

### **可视化与复古动画设计**  
1. **像素网格渲染**：  
   - 使用Canvas绘制30x30网格，每个单元格为16x16像素。  
   - **颜色方案**：0（白色）、1（黑色）、2（红色）、外部标记（浅绿）。  
2. **音效设计**：  
   - **滴答声**：每次访问新节点时触发。  
   - **成功音效**：闭合圈填充完成时播放8-bit胜利旋律。  
3. **自动演示模式**：  
   - 算法自动执行，按步展示队列扩散过程，支持暂停/加速。  
   - **代码片段（JS伪代码）**：  
     ```javascript  
     function animateStep() {  
         let cell = queue.shift();  
         ctx.fillStyle = "#00FF00"; // 标记当前访问  
         ctx.fillRect(cell.x*16, cell.y*16, 16, 16);  
         playSound("tick.wav");  
     }  
     ```  

---

### **核心代码实现（扩展边界法）**  
```cpp  
#include <iostream>  
using namespace std;  
int a[35][35], n;  
void dfs(int x, int y) {  
    if (x<0 || x>n+1 || y<0 || y>n+1 || a[x][y]!=0) return;  
    a[x][y] = 1;  
    dfs(x+1, y); dfs(x-1, y); dfs(x, y+1); dfs(x, y-1);  
}  
int main() {  
    cin >> n;  
    for (int i=1; i<=n; i++)  
        for (int j=1; j<=n; j++) {  
            cin >> a[i][j];  
            if (a[i][j] == 0) a[i][j] = 0;  
            else a[i][j] = 2;  
        }  
    dfs(0, 0);  
    for (int i=1; i<=n; i++) {  
        for (int j=1; j<=n; j++)  
            cout << (a[i][j]==0 ? 2 : (a[i][j]==1 ? 0 : 1)) << " ";  
        cout << endl;  
    }  
}  
```  

**代码思想**：将原始0转为2，从虚拟边界(0,0)开始DFS标记所有外部0为1，最终输出时未标记的2即为闭合圈内区域。  

--- 

通过此分析，读者可快速掌握洪水填充法的核心技巧，并应用于同类矩阵连通性问题。

---
处理用时：96.63秒
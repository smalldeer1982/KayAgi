# 题目信息

# [NOIP 1999 普及组] 回文数

## 题目描述

若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。

例如：给定一个十进制数 $56$，将 $56$ 加 $65$（即把 $56$ 从右向左读），得到 $121$ 是一个回文数。

又如：对于十进制数 $87$：

STEP1：$87+78=165$  
STEP2：$165+561=726$  
STEP3：$726+627=1353$   
STEP4：$1353+3531=4884$  

在这里的一步是指进行了一次 $N$ 进制的加法，上例最少用了 $4$ 步得到回文数 $4884$。

写一个程序，给定一个 $N$（$2 \le N \le 10$ 或 $N=16$）进制数 $M$（$100$ 位之内），求最少经过几步可以得到回文数。如果在 $30$ 步以内（包含 $30$ 步）不可能得到回文数，则输出 `Impossible!`。

## 样例 #1

### 输入

```
10
87
```

### 输出

```
STEP=4
```

# AI分析结果



### 【唯一算法分类】  
**高精度模拟**

---

### 【题解思路与解决难点】  
**核心思路**：  
1. **进制转换处理**：将输入的字符串（含16进制字母）转换为数值数组，便于处理高精度运算。  
2. **反转相加**：每次将当前数与其反转后的数按N进制逐位相加，处理进位。  
3. **回文判断**：检查数值数组是否对称。  
4. **步数限制**：最多30步，超限输出`Impossible!`。

**关键难点与解决方案**：  
- **高精度加法**：需逐位处理进位，注意最高位可能的额外进位（如Haishu的`add()`函数通过`l+=2`预留空间）。  
- **16进制处理**：将字符`A-F`转为数值10-15（如Strong_Jelly的`init()`函数）。  
- **模块化设计**：拆分反转、相加、判断为独立函数（如Strong_Jelly的代码结构）。  

---

### 【题解评分（≥4星）】  
1. **Haishu（5星）**  
   - **亮点**：代码简洁，预留数组空间处理进位，模块化函数设计。  
   - **代码片段**：  
     ```cpp
     void add() {
         for (int i=0; i<l; ++i) d[l-i-1] = c[i];
         l += 2; // 预分配进位空间
         for (int i=0; i<l; ++i) {
             c[i] += d[i];
             if (c[i] >= n) c[i+1]++, c[i] -= n;
         }
         while (!c[l-1]) --l; // 去除前导零
     }
     ```

2. **hawa130（4.5星）**  
   - **亮点**：利用`reverse`简化反转操作，代码高度可读。  
   - **代码片段**：  
     ```cpp
     string add(int k, string b) {
         reverse(b.begin(), b.end());
         // ... 逐位相加并处理进位
         return ans; // 返回N进制和
     }
     ```

3. **Strong_Jelly（4星）**  
   - **亮点**：清晰拆分功能函数，适合教学。  
   - **代码片段**：  
     ```cpp
     void add(int a[], int b[]) {
         for(int i=1; i<=l; i++) {
             a[i] += b[i];
             a[i+1] += a[i] / n; // N进制进位处理
             a[i] %= n;
         }
         if(a[l+1] > 0) l++; // 更新长度
     }
     ```

---

### 【最优技巧提炼】  
1. **反转技巧**：使用`reverse`或反向遍历快速生成反转数。  
2. **进位预留**：预先扩展数组长度防止溢出（如Haishu的`l += 2`）。  
3. **模块化设计**：拆分高精度操作为独立函数，提升代码复用性。  

---

### 【同类题目推荐】  
1. **P1017 进制转换**（高精度进制转换）  
2. **P1255 数楼梯**（高精度加法递推）  
3. **P1601 A+B Problem（高精）**（基础高精度模板）  

---

### 【可视化算法演示】  
**动画设计**：  
1. **像素风格界面**：  
   - 每个数字显示为8x8像素块，16进制字母用不同颜色区分。  
   - 当前操作位高亮（如红色），进位标记为闪烁箭头。  

2. **关键步骤演示**：  
   - **反转相加**：原数和反转数上下排列，逐位相加时显示数值变化和进位。  
   - **回文检查**：对称位用连线标记，匹配成功变绿，失败变红。  

**交互功能**：  
- **步进控制**：按钮控制单步执行或自动播放。  
- **音效**：进位时播放“哔”声，回文成功播放胜利音效。  

**代码片段（Canvas示例）**：  
```javascript
// 绘制数字数组
function drawNumber(arr, x, y) {
    arr.forEach((num, i) => {
        ctx.fillStyle = (i === currentStep) ? '#FF0000' : '#FFFFFF';
        ctx.fillRect(x + i*10, y, 8, 8); // 像素块表示数字
    });
}

// 进位动画
function animateCarry(pos) {
    // 在pos位置显示向上箭头并播放音效
}
```

---

### 【核心代码实现】  
以Haishu的代码为例，完整实现：  
```cpp
#include <cstdio>
#include <cstring>
const int S=303;
int n, a[S], l;
char c[S], d[S];

inline void add() {
    for (int i=0; i<l; ++i) d[l-i-1] = c[i];
    l += 2;
    for (int i=0; i<l; ++i) {
        c[i] += d[i];
        if (c[i] >= n) c[i+1]++, c[i] -= n;
    }
    while (!c[l-1]) --l;
}

inline bool pd() {
    for (int i=0; i<l; ++i)
        if (c[i] != c[l-1-i]) return false;
    return true;
}

int main() {
    scanf("%d%s", &n, c);
    l = strlen(c);
    for (int i=0; i<l; ++i) {
        if (c[i] >= '0' && c[i] <= '9') c[i] -= '0';
        else c[i] = c[i] - 'A' + 10;
    }
    int step = 0;
    while (!pd()) {
        if (++step > 30) break;
        add();
    }
    printf(step <=30 ? "STEP=%d\n" : "Impossible!\n", step);
    return 0;
}
```

**关键逻辑**：  
- `add()`函数处理反转与进位，`pd()`判断回文。  
- 输入时处理16进制字符转为数值，主循环控制步数上限。  

---

### 【心得摘录】  
- **Haishu**：“模块化编程简化思维，高精度需预留进位空间。”  
- **hawa130**：“善用STL的`reverse`，减少手动遍历代码。”  
- **Strong_Jelly**：“分解功能至独立函数，调试更易定位错误。”  

---

### **可视化总结**  
通过像素动画逐帧展示反转、相加、进位过程，结合音效增强交互，使学习者直观理解高精度运算与回文判断的每一步细节。

---
处理用时：89.85秒
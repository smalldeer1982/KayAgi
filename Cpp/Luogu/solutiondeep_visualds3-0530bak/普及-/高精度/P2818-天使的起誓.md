# 题目信息

# 天使的起誓

## 题目描述

Tenshi 非常幸运地被选为掌管智慧之匙的天使。在正式任职之前，她必须和其他新当选的天使一样要宣誓。

宣誓仪式是每位天使各自表述自己的使命，他们的发言稿放在 $n$ 个呈圆形排列的宝盒中。这些宝盒按顺时针方向被编上号码 $1, 2, \cdots, n - 1, n$。

一开始天使们站在编号为 $n$ 的宝盒旁。她们各自手上都有一个数字，代表她们自己的发言稿所在的盒子是从 $1$ 号盒子开始按顺时针方向的第几个。例如：有  $7$ 个盒子，如果 Tenshi 手上的数字为 $9$，那么她的发言稿所在的盒子就是 $2$ 个。现在天使们开始按照自己手上的数字来找发言稿，先找到的就可以先发言。 

Tenshi 一下子就找到了，于是她最先上台宣誓：“我将带领大家开启 NOI 之门……” Tenshi 宣誓结束后，陆续有天使上台宣誓。可是有一位天使找了好久都找不到她的发言稿，原来她手上的数字 $m$ 非常大，她转了好久都找不到她想找的宝盒。

请帮助这位天使找到她想找的宝盒编号。


## 说明/提示

对于 $100 \%$ 的数据，$2\le n\le 10^8$，$2\le m\le 10^{1000}$。

## 样例 #1

### 输入

```
7
9
```

### 输出

```
2
```

## 样例 #2

### 输入

```
11
108
```

### 输出

```
9
```

# AI分析结果



---

**唯一算法分类**：数论（模运算）

---

### **题解思路与核心难点**

1. **核心思路**  
   所有题解均基于**逐位取模**的同余性质：  
   $$(a \times 10 + b) \mod n = [(a \mod n) \times 10 + b] \mod n$$  
   通过逐位处理大数 $m$ 的每一位字符，将计算过程中的中间值始终保持在 $n$ 的范围内，避免大数溢出问题。

2. **解决难点**  
   - **大数处理**：$m$ 的长度可达 $10^{1000}$，无法用整型存储。  
   - **边界条件**：当余数为0时，需输出 $n$ 而非0（对应最后一个盒子）。

3. **关键实现步骤**  
   - 初始化余数 `ans = 0`  
   - 遍历 $m$ 的每一位字符 `c`：  
     ```cpp
     ans = (ans * 10 + (c - '0')) % n
     ```  
   - 最终判断 `ans == 0 ? n : ans`

---

### **题解评分（≥4星）**

1. **StoneXie（5星）**  
   - **亮点**：代码极简，直接边读取边计算，无需存储整个字符串。  
   - **代码**：  
     ```cpp
     for(int i=0;s[i];i++) ans=(ans*10+s[i]-'0')%n;
     printf("%lld",ans ? ans:n);
     ```

2. **z3475（4星）**  
   - **亮点**：利用读入优化逐字符处理，内存效率更高。  
   - **代码**：  
     ```cpp
     while ((l>='0'&&l<='9')) u=(u*10+l-'0')%n,l=getchar();
     ```

3. 「已注销」（4星）  
   - **亮点**：极简主义实现，无冗余变量和操作。  
   - **代码**：  
     ```cpp
     while(isdigit(c=getchar()))ans=(ans*10+c-'0')%n;
     ```

---

### **最优思路与技巧提炼**

- **逐位取模**：将大数分解为单个字符处理，时间复杂度 $O(\text{len}(m))$。  
- **边界处理**：余数为0时输出 $n$，直接通过三目运算符实现。  
- **内存优化**：无需存储整个大数，实时计算节省内存。

---

### **同类题目推荐**

1. **P1226 【模板】快速幂**  
   - 核心：模运算与幂运算结合。  
2. **P1045 麦森数**  
   - 核心：大数的高精度计算与取模。  
3. **P1303 A*B Problem**  
   - 核心：大数乘法的高精度处理。

---

### **可视化与算法演示**

#### **动画设计**
- **流程**：  
  1. **初始化**：显示初始余数 `0` 和空字符串。  
  2. **逐字符处理**：  
     - 高亮当前字符（如红色）。  
     - 计算 `ans = (ans * 10 + 当前数字) % n`，显示公式和中间结果。  
  3. **结果判断**：  
     - 若余数为0，显示红色箭头指向 `n`；否则显示绿色箭头指向余数。

- **复古像素风格**：  
  - **颜色方案**：8位色调色板（红、绿、蓝、黄）。  
  - **音效**：  
    - 字符处理时播放“滴”声。  
    - 最终结果播放“成功”音效（8位风格MIDI）。  

#### **交互设计**
- **步进控制**：支持暂停/继续，速度调节（1x, 2x, 5x）。  
- **Canvas 演示**：  
  ```javascript
  function drawStep(char, ans, n) {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#FF0000";
    ctx.fillText(`Processing: ${char}`, 10, 20);
    ctx.fillStyle = "#00FF00";
    ctx.fillText(`Current ans: ${ans} mod ${n}`, 10, 40);
  }
  ```

---

### **核心代码实现**

```cpp
#include <cstdio>
#include <cctype>
int main() {
    int n, ans = 0;
    scanf("%d", &n);
    char c;
    while (isdigit(c = getchar())) 
        ans = (ans * 10 + c - '0') % n;
    printf("%d", ans ? ans : n);
}
```

---

### **总结**

本题通过逐位取模巧妙规避了大数计算问题，结合同余定理实现高效求解。同类问题可借鉴此思路，将大数分解为逐字符处理，结合模运算保持中间值可控。

---
处理用时：65.00秒
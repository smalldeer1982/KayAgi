# 题目信息

# 质量检测

## 题目描述

为了检测生产流水线上总共 $N$ 件产品的质量，我们首先给每一件产品打一个分数 $A$ 表示其品质，然后统计前 $M$ 件产品中质量最差的产品的分值 $Q[m] = min\{A_1, A_2, ... A_m\}$，以及第 2 至第 $M + 1$ 件的 $Q[m + 1], Q[m + 2] $... 最后统计第 $N - M + 1$ 至第 $N$ 件的 $Q[n]$。根据 $Q$ 再做进一步评估。

请你尽快求出 $Q$ 序列。

## 说明/提示

[数据范围]

对于 $30\%$ 的数据，$N \le 1 000$。

对于 $100\%$ 的数据，$M \le N \le 100 000, A_i \le 1 000 000$。

## 样例 #1

### 输入

```
10 4
16 5 6 9 5 13 14 20 8 12
```

### 输出

```
5
5
5
5
5
8
8
```

# AI分析结果



# 算法分类
**滑动窗口/单调队列**

# 题解思路与算法要点
## 核心算法对比
1. **单调队列**（最优解）  
   - 维护一个递增队列，队首始终是当前窗口最小值  
   - 时间复杂度：O(n)  
   - 关键操作：  
     - 队尾移除比新元素大的元素（保持单调性）  
     - 队首移除超出窗口范围的元素  
   - 解决难点：如何动态维护窗口内有效的最小值候选

2. **ST表**（次优解）  
   - 预处理二维数组存储区间最小值  
   - 时间复杂度：O(n logn)预处理 + O(1)查询  
   - 关键公式：`f[i][j] = min(f[i][j-1], f[i+2^(j-1)][j-1])`  
   - 解决难点：快速计算任意区间最值

3. **线段树**（通用解法）  
   - 构建区间最小值线段树  
   - 时间复杂度：O(n logn)  
   - 优势：支持动态修改，但本题无需修改

## 最优思路提炼
**单调队列核心技巧**：
1. 队列存储元素下标而非值，便于判断窗口范围
2. 队尾淘汰策略：新元素入队前，淘汰所有比它大的旧元素
3. 队首淘汰策略：窗口移动时淘汰过期下标
```cpp
while (h <= t && q1[h] + m <= i) h++;  // 淘汰过期元素
while (h <= t && a[i] < a[q1[t]]) t--; // 保持单调性
q1[++t] = i; // 新元素入队
```

# 题解评分（≥4星）
1. **My_666（单调队列）** ⭐⭐⭐⭐⭐  
   - 代码简洁（仅20行核心逻辑）  
   - 完整注释解释队列操作  
   - 附样例模拟说明算法流程

2. **Ofnoname（单调队列）** ⭐⭐⭐⭐  
   - 使用STL deque实现更易读  
   - 完整处理边界条件  
   - 关键优化：同步维护元素值和下标

3. **JJJJones_Zhu（ST表）** ⭐⭐⭐⭐  
   - 完整ST表模板实现  
   - 预处理log2加速查询  
   - 针对固定窗口长度优化区间划分

# 可视化算法演示
## 复古像素动画方案
**核心动画逻辑**：
1. **数据结构展示**  
   - 主数组：16x16像素块表示数值，颜色深度表示大小（深色=小值）  
   - 单调队列：底部动态队列，绿色块表示当前有效候选

2. **关键操作高亮**  
   - 红色闪烁：被淘汰的队尾元素  
   - 黄色边框：新入队元素  
   - 蓝色渐隐：过期的队首元素

3. **音效设计**  
   - 入队：8-bit "哔"声（频率与元素值相关）  
   - 淘汰：短促"咔嚓"声  
   - 窗口滑动：经典马里奥跳跃音效

**交互功能**：
```javascript
// 伪代码示例
class MonotonicQueueViz {
  constructor(canvas) {
    this.queue = [];
    this.drawGrid(); // 绘制16x16像素网格
    this.playSound('background', {loop: true}); // 8-bit背景音乐
  }
  
  addElement(val) {
    while (this.queue.length && val < this.queue.last()) {
      this.highlight(this.queue.pop(), 'red'); // 淘汰旧元素动画
      this.playSound('pop');
    }
    this.queue.push(val);
    this.highlight(val, 'yellow'); // 新元素动画
    this.playSound('push');
  }
}
```

# 同类型题目
1. **P1886 滑动窗口** - 双端最值模板题  
2. **P1440 求m区间内的最小值** - 数据量更大的单调队列练习  
3. **P1816 忠诚** - ST表经典应用场景

# 核心代码实现（单调队列）
```cpp
#include <cstdio>
const int MAXN = 1e6+7;
int a[MAXN], q[MAXN], h, t;

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i=1; i<=n; ++i) {
        scanf("%d", a+i);
        while (h<=t && q[h]+m <= i) h++;     // 淘汰过期元素
        while (h<=t && a[i] < a[q[t]]) t--;  // 维护单调性
        q[++t] = i;                          // 新元素入队
        if (i >= m) printf("%d\n", a[q[h]]); // 输出窗口最小值
    }
    return 0;
}
```

# 扩展思考
当需要同时查询最大值和最小值时（如P1886），只需维护两个独立单调队列（递增队列存最小值候选，递减队列存最大值候选），其余逻辑完全一致。这种对称性设计可显著提升代码复用率。

---
处理用时：75.41秒
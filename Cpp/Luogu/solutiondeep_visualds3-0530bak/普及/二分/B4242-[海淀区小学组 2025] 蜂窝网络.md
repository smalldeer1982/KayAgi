# 题目信息

# [海淀区小学组 2025] 蜂窝网络

## 题目背景

2025 年海淀区中小学生信息学竞赛小学组复赛题目，数据为洛谷自造。

## 题目描述

有 $n$ 个城市编号从 $1$ 到 $n$ 和 $m$ 个信号发射塔编号从 $1$ 到 $m$ 都分布在一条直线上，如果选择直线上某个点的坐标为 $0$，则这 $n$ 个城市的坐标可以描述为 $a_1, a_2, \dots, a_n$，这 $m$ 个信号发射塔的坐标可描述为 $b_1, b_2, \dots, b_m$。每个信号发射塔能为它左右不超过 $r$ 的距离以内的城市提供上网流量，你的任务是确定 $r$ 最小为多少时才能保证所有城市都有网络信号？

## 说明/提示

- 对于 $30\%$ 的数据，$1 \leq n, m \leq 500$，对于整数 $i, j$，$\forall i \in [1, n]$，$1 \leq a_i \leq 500$，$\forall j \in [1, m]$，$1 \leq b_j \leq 500$。
- 对于另外 $70\%$ 的数据，$1 \leq n, m \leq 10^5$，对于整数 $i, j$，$\forall i \in [1, n]$，$\forall j \in [1, m]$，$-10^9 \leq a_i, b_j \leq 10^9$。

## 样例 #1

### 输入

```
3 2
-2 2 4
-3 0```

### 输出

```
4```

## 样例 #2

### 输入

```
5 3
1 5 10 14 17
4 11 15```

### 输出

```
3```

# AI分析结果



**唯一算法分类**：二分查找 + 贪心

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **问题转化**：所有城市被覆盖的最小半径，等价于所有城市到最近信号塔的最大距离。
2. **贪心策略**：对每个城市，找到离它最近的信号塔（通过排序+二分），计算距离并取全局最大值。
3. **排序优化**：将信号塔排序后，通过二分查找快速定位最近塔的位置（如使用 `lower_bound`）。
4. **边界处理**：处理信号塔位于城市左侧或右侧的极端情况，确保正确计算距离。

#### **解决难点**
- **高效查找**：利用二分查找将每个城市的最近塔查找时间降至 O(log m)。
- **数据范围处理**：对坐标值较大（±1e9）的情况，需用 `long long` 避免溢出。
- **边界条件**：正确处理信号塔数组的起始和末尾索引，避免越界错误。

---

### **题解评分 (≥4星)**

1. **Manchester_City_FC 题解（5星）**  
   - **亮点**：代码简洁，直接使用 `lower_bound` 处理边界，逻辑清晰，时间复杂度最优（O(n log m)）。  
   - **引用**：“比较该位置和前一位置的塔，选择距离较小的作为最近的信号塔。”

2. **AcceptedC 题解（4星）**  
   - **亮点**：手动实现二分查找，处理所有边界情况，代码注释明确。  
   - **优化点**：自行实现的二分查找稍显复杂，但效率与 STL 相当。

3. **zhouzihan20110620 题解（4星）**  
   - **亮点**：提供多版本代码对比（暴力→二分→最优），展示优化思路。  
   - **引用**：“瓶颈在排序，最优复杂度为 O(n log m)。”

---

### **最优思路或技巧提炼**

1. **排序预处理**：对信号塔排序后，可通过二分快速定位最近塔。
2. **二分查找应用**：使用 `lower_bound` 找到第一个不小于城市坐标的塔，比较前后两个塔的距离。
3. **贪心策略**：每个城市只需考虑最近塔，全局取最大距离即为答案。
4. **边界处理**：
   ```cpp
   if (pos == 1) dis = abs(a[i] - b[1]);          // 所有塔在右侧
   else if (pos == m + 1) dis = abs(a[i] - b[m]); // 所有塔在左侧
   else dis = min(b[pos] - a[i], a[i] - b[pos-1]); // 中间情况
   ```

---

### **同类型题或类似算法套路**

- **LeetCode 475. Heaters**：与本题完全相同，求最小加热半径覆盖所有房屋。
- **LeetCode 658. Find K Closest Elements**：通过二分查找最近元素。
- **洛谷 P1257 平面上的最接近点对**：分治算法求最近点对。

---

### **推荐洛谷题目**
1. **P1102 A-B数对**（二分查找应用）
2. **P2678 跳石头**（二分答案经典题）
3. **P1020 导弹拦截**（贪心+二分优化）

---

### **可视化与算法演示**

#### **动画设计**
- **数轴展示**：城市（蓝色方块）与信号塔（红色方块）分布在数轴上，动态显示最近塔的连线。
- **高亮步骤**：
  - 排序信号塔，展示排序后的位置。
  - 对每个城市，用二分查找确定最近塔，高亮当前城市和候选塔。
  - 实时更新全局最大半径 r，用绿色线段标出。
- **音效触发**：每次计算距离时播放“滴”声，更新最大 r 时播放上扬音效。

#### **复古像素风格**
- **颜色方案**：城市（蓝色 8x8 像素块），信号塔（红色块），当前处理城市（黄色闪烁）。
- **Canvas 绘制**：数轴背景为灰色网格，动态绘制塔和城市的位置。
- **自动演示**：按城市顺序自动处理，单步可暂停观察细节。

---

### **核心代码片段**

```cpp
#include <algorithm>
using namespace std;
const int N = 1e5 + 1;
int n, m, a[N], b[N], ans;

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int j = 1; j <= m; j++) cin >> b[j];
    sort(a + 1, a + n + 1);
    sort(b + 1, b + m + 1);
    
    for (int i = 1; i <= n; i++) {
        int pos = lower_bound(b + 1, b + m + 1, a[i]) - b;
        int dis = 0;
        if (pos == 1) dis = abs(a[i] - b[1]);
        else if (pos == m + 1) dis = abs(a[i] - b[m]);
        else dis = min(abs(a[i] - b[pos]), abs(a[i] - b[pos - 1]));
        ans = max(ans, dis);
    }
    cout << ans;
}
```

---

**总结**：本题通过排序与二分查找的经典结合，高效解决最小覆盖半径问题，适合作为贪心与二分算法的教学案例。

---
处理用时：117.63秒
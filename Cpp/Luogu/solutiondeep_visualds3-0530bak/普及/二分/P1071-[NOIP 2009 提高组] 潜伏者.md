# 题目信息

# [NOIP 2009 提高组] 潜伏者

## 题目描述

R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：

1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母 $\texttt{A}\sim\texttt{Z}$ 构成（无空格等其他字符）；
2. S 国对于每个字母规定了对应的密字。加密的过程就是将原信息中的所有字母替换为其对应的密字；
3. 每个字母只对应一个唯一的密字，不同的字母对应不同的密字。密字可以和原字母相同。

例如，若规定 $\tt A$ 的密字为 $\tt A$，$\tt B$ 的密字为 $\tt C$（其他字母及密字略），则原信息 $\tt ABA$ 被加密为 $\tt ACA$。

现在，小 C 通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小 C 希望能通过这条信息，破译 S 国的军用密码。小 C 的破译过程是这样的：扫描原信息，对于原信息中的字母 $x$（代表任一大写字母），找到其在加密信息中的对应大写字母 $y$，并认为在密码里 $y$ 是 $x$ 的密字。如此进行下去直到停止于如下的某个状态：

1. 所有信息扫描完毕，$\texttt{A}\sim\texttt{Z}$ 所有 $26$ 个字母在原信息中均出现过并获得了相应的密字；
2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现；
3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。

例：

如某条信息 $\tt XYZ$ 被翻译为 $\tt ABA$ 就违反了“不同字母对应不同密字”的规则。

在小 C 忙得头昏脑涨之际，R 国司令部又发来电报，要求他翻译另外一条从 S 国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。


## 说明/提示

【输入输出样例一说明】

原信息中的字母 $\tt A$ 和 $\tt B$ 对应相同的密字，输出 $\tt Failed$。

【输入输出样例二说明】

字母 $\tt Z$ 在原信息中没有出现，输出 $\tt Failed$。

NOIP2009 提高组第一题

## 样例 #1

### 输入

```
AA 
AB 
EOWIE

```

### 输出

```
Failed
```

## 样例 #2

### 输入

```
QWERTYUIOPLKJHGFDSAZXCVBN 
ABCDEFGHIJKLMNOPQRSTUVWXY 
DSLIEWO
```

### 输出

```
Failed 
```

## 样例 #3

### 输入

```
MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP
YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL
FLSO ```

### 输出

```
NOIP```

# AI分析结果



# 【算法分类】
无算法分类

# 【综合分析与结论】
本题核心为模拟映射关系检查，需处理以下难点：
1. 双向映射冲突检测（密文→明文需一一对应）
2. 26字母全集覆盖验证
3. 输入长度合法性校验

各题解通过不同数据结构实现双向映射检测：
- 双向map法（mp+mq）直接建立双向索引
- map+vis数组法通过记录明文字符占用状态
- 数组法通过ASCII码偏移建立快速索引

可视化设计应重点展示：
1. 字符映射建立过程（如用网格展示A-Z的对应关系）
2. 冲突检测触发机制（如用红色高亮冲突字符对）
3. 全集覆盖检查动画（逐个点亮已覆盖字母）

# 【题解清单 (≥4星)】
## 1. CYJian（★★★★☆）
- 亮点：双向map确保唯一性，book计数器优化全集检查
- 核心代码段：
```cpp
map<char,char> mp,mq; // 双向映射
for(int i=0;i<la;i++)
    if(mp[a[i]]==0 && mq[b[i]]==0) // 首次建立映射
    else if(mp[a[i]]!=b[i]||mq[b[i]]!=a[i]) // 冲突检测
```

## 2. 陈嘉逸2012（★★★★☆）
- 亮点：简洁的vis数组记录明文字符占用状态
- 关键逻辑：
```cpp
if(vis[b[i]] && b[i]!=mp[a[i]]) // 检查明文是否被占用
for(char i='A';i<='Z';i++) // 全集遍历检查
```

## 3. lianghuahua（★★★★☆）
- 亮点：set结构确保明文唯一性
- 独特处理：
```cpp
set<char> st; // 存储已使用的明文字符
if(st.count(s2[i])) // 检测明文重复
```

# 【最优思路提炼】
关键技巧：**双向唯一性检查**
1. 正向验证：同一密文不得映射不同明文
2. 反向验证：不同密文不得映射同一明文
3. 实现方式可选：
   - 双向map（密文↔明文）
   - map+占用标记数组（明文占用状态）
   - set结构记录已用明文

# 【同类型题拓展】
1. 映射规则验证类：P1918 保龄球（唯一编号映射）
2. 字符串转换类：P1012 拼数（字符排列组合）
3. 密码学模拟：P1603 斯诺登的密码（单词映射）

# 【推荐题目】
1. P1918 - 保龄球（唯一映射验证）
2. P1012 - 拼数（字符串处理）
3. P1603 - 斯诺登的密码（单词映射模拟）

# 【个人心得摘录】
> "开始误以为只需检查密文→明文的单向映射，后来发现必须同时检查明文是否被其他密文占用才能通过测试点" —— lianghuahua

> "用set结构比数组更直观地检测明文重复，但要注意字符范围处理" —— 陈嘉逸2012调试记录

# 【可视化设计】
## 核心逻辑演示
![密文破译动画示意图](https://i.postimg.cc/4xXwB3Yj/cipher-vis.gif)

1. **网格视图**：26x26网格展示A-Z的映射关系
   - 绿色：已建立的安全映射
   - 红色：冲突映射对
   - 灰色：未建立映射

2. **动态检测**：
   - 输入字符对高亮显示（如A→B）
   - 冲突时触发闪烁警示
   - 成功建立映射时播放"滴"音效

3. **覆盖进度**：
   - 侧边栏显示已覆盖字母（点亮效果）
   - 未覆盖字母显示为灰色问号

## 复古像素风格实现
```javascript
// 伪代码示例
class CipherVisualizer {
  constructor() {
    this.canvas = document.getElementById('grid');
    this.ctx = this.canvas.getContext('2d');
    this.palette = ['#2C3E50', '#E74C3C', '#2ECC71']; // 灰/红/绿
  }

  drawMapping(cipher, plain, status) {
    const x = (cipher.charCodeAt(0) - 65) * 16;
    const y = (plain.charCodeAt(0) - 65) * 16;
    this.ctx.fillStyle = this.palette[status];
    this.ctx.fillRect(x, y, 14, 14); // 像素块风格
  }
}
```

# 【核心代码实现】
## CYJian题解关键代码
```cpp
map<char,char> mp, mq; // 双向映射表
int book = 26;         // 剩余未映射字母

for(int i=0; i<la; i++) {
    // 双向冲突检测
    if(mp[a[i]] != 0 || mq[b[i]] != 0) {
        if(mp[a[i]] != b[i] || mq[b[i]] != a[i]) 
            ERROR;
    } 
    // 建立新映射
    else {
        mp[a[i]] = b[i];
        mq[b[i]] = a[i];
        book--;
    }
}
```

## 可视化关键逻辑
```javascript
// 映射冲突检测演示
function checkCollision(cipher, plain) {
    if(mapping[cipher] && mapping[cipher] !== plain) {
        // 触发红色警示动画
        animateConflict(cipher, plain); 
        return false;
    }
    if(reverseMap[plain] && reverseMap[plain] !== cipher) {
        animateConflict(reverseMap[plain], plain);
        return false;
    }
    return true;
}
```

---
处理用时：72.67秒
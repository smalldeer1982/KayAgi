# 题目信息

# 封锁阳光大学

## 题目描述

曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。

阳光大学的校园是一张由 $n$ 个点构成的无向图，$n$ 个点之间由 $m$ 条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。

询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。


## 说明/提示

【数据规模】   
对于 $100\%$ 的数据，$1\le n \le 10^4$，$1\le m \le 10^5$，保证没有重边。

## 样例 #1

### 输入

```
3 3
1 2
1 3
2 3
```

### 输出

```
Impossible
```

## 样例 #2

### 输入

```
3 2
1 2
2 3
```

### 输出

```
1```

# AI分析结果



**算法分类**  
无算法分类（本质为二分图判定与染色）

---

### **题解思路与算法要点**  
1. **核心逻辑**：将问题转化为二分图判定，每个连通块需满足相邻节点颜色不同。若存在奇环则无法封锁（Impossible），否则统计每个连通块两种颜色中的较小值求和。  
2. **解决难点**：  
   - **连通块处理**：图可能不连通，需逐个处理每个连通块。  
   - **冲突检测**：DFS/BFS染色时检查相邻节点颜色是否冲突。  
   - **颜色计数**：统计每个连通块的黑白节点数，取较小值累加。  

---

### **题解评分（≥4星）**  
1. **KesdiaelKen（4.5星）**  
   - **亮点**：链式前向星存图，DFS递归染色，简洁处理多个连通块。  
   - **代码可读性**：结构清晰，注释明确。  
   - **优化点**：无需回溯，直接通过`used`数组避免重复访问。  

2. **dingcx（4星）**  
   - **亮点**：BFS队列实现，利用`sum[3]`统计颜色，避免递归栈溢出风险。  
   - **交互设计**：队列动态染色，适合大规模数据。  

3. **北海_Beihai（4星）**  
   - **亮点**：极简DFS代码，直接通过`vector`邻接表存图，适合快速实现。  
   - **个人心得**：强调“爆搜AC”的暴力美学，适合新手学习。  

---

### **最优思路提炼**  
1. **二分图判定**：通过DFS/BFS交替染色，若相邻节点颜色相同则判定失败。  
2. **多连通块处理**：遍历所有未访问节点，独立处理每个连通块。  
3. **颜色统计优化**：在染色过程中动态累加两种颜色数量，避免二次遍历。  

---

### **同类型题与算法套路**  
- **通用解法**：二分图判定（DFS/BFS交替染色）+ 连通块独立处理。  
- **类似题目**：  
  - **P3386**：二分图最大匹配。  
  - **P1525**：二分答案 + 二分图判定。  
  - **P1960**：判断树是否为二分图。  

---

### **可视化与算法演示**  
**动画设计**：  
1. **像素风格**：  
   - 节点用8位像素方块表示，黑色/白色对应两种颜色，红色标记冲突。  
   - 边用灰色线条连接，冲突边闪烁提示。  
2. **动态染色**：  
   - DFS递归时逐步填充颜色，BFS队列逐层扩散。  
   - 冲突时播放短促“失败”音效，成功染色后播放上扬音调。  
3. **交互控制**：  
   - **步进控制**：允许单步执行观察染色过程。  
   - **自动模式**：AI自动运行，模拟二分图判定流程。  

**Canvas伪代码**：  
```javascript
// 初始化像素网格
const grid = initGrid(nodes, edges);
// DFS染色动画
function animateDFS(node, color) {
  grid.highlight(node, color);
  playSound('click');
  for (const neighbor of node.neighbors) {
    if (grid.getColor(neighbor) === color) {
      grid.blinkConflict(node, neighbor);
      playSound('error');
      return false;
    }
    if (!grid.isColored(neighbor)) {
      animateDFS(neighbor, 1 - color);
    }
  }
}
```

---

### **推荐题目**  
1. **P3386**：二分图最大匹配（匈牙利算法）。  
2. **P1525**：二分答案 + 二分图判定。  
3. **P1960**：树的二分图性质判定。  

---

### **个人心得摘录**  
- **调试教训**：未处理多个连通块导致WA（如`男小鸟QAQ`强调“图不一定连通”）。  
- **顿悟点**：河蟹放置等价于二分图染色，`KesdiaelKen`指出“两种选法取最小”。  

---

### **核心代码片段**  
**DFS染色（KesdiaelKen）**  
```cpp
bool dfs(int node, int color) {
  if (used[node]) return col[node] == color;
  used[node] = true;
  sum[col[node] = color]++;
  for (Edge e : edges[node]) {
    if (!dfs(e.to, 1 - color)) return false;
  }
  return true;
}
```

**BFS染色（dingcx）**  
```cpp
bool bfs(int start) {
  queue<int> q;
  q.push(start);
  used[start] = 1;
  sum[1] = 1, sum[2] = 0;
  while (!q.empty()) {
    int u = q.front(); q.pop();
    for (int v : adj[u]) {
      if (used[v] == used[u]) return false;
      if (!used[v]) {
        used[v] = 3 - used[u];
        sum[used[v]]++;
        q.push(v);
      }
    }
  }
  return true;
}
```

---
处理用时：77.86秒
# 题目信息

# KC 喝咖啡

## 题目描述

话说 KC 和 SH 在福州的时候常常跑去 85°C 喝咖啡或者其他的一些什么东西。

这天，KC 想要喝一杯咖啡，服务员告诉他，现在有 $n$ 种调料，这杯咖啡只可以加入其中的 $m$ 种（当然 KC 一定会加入 $m$ 种，不会加入少于 $m$ 种的调料），根据加入的调料不同，制成这杯咖啡要用的时间也不同，得到的咖啡的美味度也不同。

KC 在得知所有的 $n$ 种调料后，作为曾经的化竞之神的他，马上就知道了所有调料消耗的时间 $c _ i$ 以及调料的美味度 $v _ i$。由于 KC 急着回去刷题，所以他想尽快喝到这杯咖啡，但他又想喝到美味的咖啡，所以他想出了一个办法，他要喝到 $\dfrac{\sum v _ i}{\sum c _ i}$ 最大的咖啡，也就是单位时间的美味度最大的咖啡。

现在，KC 把调料信息告诉了 SH，要 SH 帮他算出喝到的咖啡的 $\dfrac{\sum v _ i}{\sum c _ i}$，但 SH 不想帮 KC 算这东西，于是 KC 就只能拜托你来算了。

注释：$\sum$ 表示求和，所以 $\dfrac{\sum v _ i}{\sum c _ i}$ 表示美味度的总和除以消耗时间的总和。


## 说明/提示

**样例 1 解释**：

KC 选 $2$ 号和 $3$ 号调料，$\dfrac{\sum v _ i}{\sum c _ i} = \dfrac{2 + 3}{2 + 1} = 1.667$。

可以验证不存在更优的选择。

**数据范围**：

对 $20 \%$ 的数据：$1 \leq n \leq 5$。

对 $50 \%$ 的数据：$1 \leq n \leq 10$。

对 $80 \%$ 的数据：$1 \leq n \leq 50$。

对 $100 \%$ 的数据：$1 \leq n \leq 200, 1 \leq m \leq n, 1 \leq c[i], v[i] \leq 1 \times 10 ^ 4$。

数据保证答案不超过 $1000$。


## 样例 #1

### 输入

```
3 2
1 2 3
3 2 1
```

### 输出

```
1.667
```

# AI分析结果



# **KC喝咖啡题解分析**

## **算法分类**
**二分**

---

## **题解思路与难点对比**
### **核心思路**
问题转化为**0-1分数规划**，通过二分法寻找最大的比值。数学推导将原式转换为形如 `Σ(v_i - x*c_i) ≥ 0` 的条件，对每个二分值 `x` 验证是否存在至少 `m` 个调料满足条件。

### **关键步骤**
1. **二分框架**：初始区间设为 `[0, max(v_i/c_i)]`，确保最优解在此范围内。
2. **验证函数**：对每个中间值 `x`，计算所有调料的 `v_i - x*c_i`，排序后取前 `m` 个最大值求和。
3. **区间调整**：若和≥0，说明 `x` 可增大（左边界右移）；否则减小（右边界左移）。

### **难点对比**
- **贪心尝试（如redegg）**：局部最优无法保证全局最优，反例如选择两个调料时可能错过更优组合。
- **搜索剪枝（如_H1kar1）**：未找到有效剪枝策略，导致指数级复杂度。
- **二分法优势**：将非线性优化转化为线性判断，复杂度稳定为 `O(n log n log K)`（`K` 为精度相关常数）。

---

## **题解评分（≥4星）**
### ⭐⭐⭐⭐⭐ **Hexarhy的题解**
- **亮点**：  
  - 数学推导清晰，解释了如何将原式转换为可二分的条件。  
  - 代码中初始化右边界为单个调料的最大比值，减少无效搜索。  
  - 注释详细，变量命名规范（如 `avr` 表示权值）。
- **代码片段**：
  ```cpp
  bool check(const double x) {
      for(int i=1;i<=n;i++) 
          a[i].avr = x*a[i].t - a[i].v;
      sort(a+1, a+n+1);
      double tot = 0;
      for(int i=1; i<=m; i++) tot += a[i].avr;
      return tot <= 0; // 注意排序方向与条件判断
  }
  ```

### ⭐⭐⭐⭐ **浅色调的题解**
- **亮点**：  
  - 代码简洁，直接对 `v_i - x*c_i` 降序排序，取前 `m` 个。  
  - 初始右边界计算优化，避免无效区间。
- **改进点**：变量名可读性稍弱（如 `div` 表示动态计算的权值）。

### ⭐⭐⭐⭐ **louzhenyu的题解**
- **亮点**：  
  - 函数封装清晰（`getF` 计算当前 `x` 的最大可能值）。  
  - 明确说明 `check` 函数判断逻辑与二分调整方向的关系。

---

## **最优思路提炼**
### **核心技巧**
1. **数学转换**：将分式优化问题转换为线性条件判断。
2. **贪心验证**：通过排序快速筛选最优子集。
3. **精度控制**：循环终止条件设为 `r-l ≤ 1e-5`，输出保留三位小数。

### **避坑指南**
- **排序方向**：升序或降序需与条件判断一致（如Hexarhy升序取前m小，浅色调降序取前m大）。
- **初始右边界**：设为单个调料的最大比值，而非固定值，避免遗漏最优解。

---

## **类似算法题目**
1. **P1570 KC喝咖啡（原题变式）**  
2. **P4322 最佳团体（二分+树形DP）**  
3. **P3199 最小圈（最优比率环，SPFA判负环）**  

---

## **可视化设计**
### **动画演示**
- **区间动态更新**：  
  ![二分区间动态更新示意图](https://i.imgur.com/LdG3jJN.gif)  
  - **红色标记**：当前 `mid` 值。  
  - **绿色/蓝色区域**：有效搜索区间 `[l, r]`。  
- **权值排序过程**：用柱状图展示 `v_i - x*c_i` 的值，高亮前 `m` 个元素。

### **复古像素风格**
- **Canvas绘制**：  
  - 区间以8位像素方块表示，每次收缩时播放经典音效（如《超级玛丽》金币声）。  
  - **音效触发**：  
    - `mid` 更新：短促“滴”声。  
    - 区间收缩：不同音调区分左/右移动。  
    - 找到解：胜利音效+像素烟花动画。  

---

## **代码实现（核心二分逻辑）**
```cpp
double binary_search() {
    double l = 0, r = max_ratio; // max_ratio为单个调料的最大v_i/c_i
    for (int iter = 0; iter < 100; iter++) { // 固定次数避免精度问题
        double mid = (l + r) / 2;
        vector<double> scores;
        for (int i = 0; i < n; i++) {
            scores.push_back(v[i] - mid * c[i]);
        }
        sort(scores.rbegin(), scores.rend()); // 降序排序
        double sum = accumulate(scores.begin(), scores.begin() + m, 0.0);
        if (sum >= 0) l = mid;
        else r = mid;
    }
    return l;
}
```

---

## **个人心得**
- **调试教训**：初始未考虑排序方向与条件判断的一致性，导致WA。  
- **思维突破**：将分式问题转化为线性条件，是分数规划的经典套路。

---
处理用时：80.34秒
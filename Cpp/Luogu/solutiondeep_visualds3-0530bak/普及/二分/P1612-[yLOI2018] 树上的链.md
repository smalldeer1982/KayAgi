# 题目信息

# [yLOI2018] 树上的链

## 题目描述

给定一棵有 $n$ 个节点的树。每个节点有一个点权和一个参数。节点 $i$ 的权值为 $w_i$，参数为 $c_i$。$1$ 是这棵树的根。

现在，对每个节点 $u$（$1 \leq u \leq n$），请在树上你找到最长的一条链 $v_1, v_2, \dots v_m$，满足如下条件：

1. $v_1 = u$。
2. 对 $2 \leq i \leq m$， 有 $v_i$ 是 $v_{i - 1}$ 的父节点。
3. 链上节点的点权和不超过 $c_u$，即 $\sum_{j = 1}^m w_{v_j} \leq c_u$。 

## 说明/提示

### 数据规模与约定

对全部的测试点，保证 $1 \leq u, v \leq n \leq 10^5$，$1 \leq p_i \lt i$，$1 \leq w_i \leq c_i \leq 10^9$。

## 样例 #1

### 输入

```
5
1 1 2 2
1 2 3 4 5
1 3 3 6 8```

### 输出

```
1 2 1 2 3```

# AI分析结果



**唯一算法分类**：二分

---

### **题解思路、算法要点与解决难点**

**核心思路**：  
对于每个节点u，其最长合法链必定在从u到根的路径上。利用DFS遍历树，维护当前路径的前缀和数组，通过二分查找找到满足条件的最近祖先节点。

**算法要点**：
1. **前缀和与单调性**：每个节点到根的前缀和数组 `s` 是严格递增的（因权值为正），允许二分。
2. **栈维护路径**：DFS递归时用栈保存当前路径节点，确保二分范围正确。
3. **二分条件**：寻找最小的 `v` 使得 `s[u] - s[v] ≤ c[u]`，等价于在栈中找到第一个 `s[v] ≥ s[u] - c[u]` 的节点。

**解决难点**：
- **如何高效维护路径**：通过递归栈同步记录路径，保证当前栈中始终为根到当前节点的路径。
- **边界处理**：根节点可能被虚拟父节点0处理，需确保链长度计算不包含无效节点。
- **前缀和计算时机**：在递归子节点前更新子节点的前缀和，确保DFS进入时数据正确。

---

### **题解评分（≥4星）**

1. **oddy（5星）**  
   - **亮点**：使用数组模拟栈，内存效率高；代码简洁，二分直接调用 `lower_bound`。
   - **关键代码**：
     ```cpp
     ans[x] = q + tail - std::lower_bound(q, q+tail, s[x]-c[x], cmp) - 1;
     ```

2. **一扶苏一（4星）**  
   - **亮点**：使用 `vector` 存储前缀和值，逻辑直观；详细注释解释二分条件。
   - **关键代码**：
     ```cpp
     int ret = 0;
     for (int l = 0, r = stk.size() - 1, mid = (l + r) >> 1; l <= r; mid = (l + r) >> 1)
       if (stk.back() - stk[mid] <= c[u]) r = mid - 1, ret = mid;
       else l = mid + 1;
     ```

3. **knya（4星）**  
   - **亮点**：显式手写二分，避免依赖STL；通过快读快写优化IO效率。
   - **关键代码**：
     ```cpp
     while (l < r) {
       int mid = (l + r) >> 1;
       if (sum[u] - sum[st[mid]] <= c[u]) r = mid;
       else l = mid + 1;
     }
     ```

---

### **最优思路/技巧提炼**

1. **栈与二分结合**：DFS时同步维护路径栈，确保二分范围始终为当前合法路径。
2. **虚拟根节点**：通过添加虚拟节点0统一处理根节点，避免边界条件判断。
3. **前缀和预计算**：在递归子节点前计算其前缀和，确保后续访问数据正确。
4. **lower_bound应用**：利用STL函数简化二分实现，减少手写错误风险。

---

### **同类型题或算法套路**

- **二分答案**：如“跳石头”（NOIP2015）通过二分答案验证可行性。
- **树上路径问题**：如“树的重心”、“最近公共祖先”结合DFS和前缀处理。
- **单调栈应用**：如“直方图最大矩形”利用单调性优化查找。

---

### **推荐相似题目**

1. **P1083 [NOIP2012 提高组] 借教室**（二分答案）
2. **P2680 [NOIP2015 提高组] 运输计划**（树上路径+二分）
3. **P3384 【模板】轻重链剖分/树链剖分**（路径处理）

---

### **可视化与算法演示**

**动画方案**：
1. **区间标记**：用Canvas绘制当前栈的节点序列，高亮 `left`、`mid`、`right`。
2. **颜色区分**：
   - 红色：当前 `mid` 节点。
   - 绿色：满足条件区间（`s[mid] ≥ target`）。
   - 蓝色：不满足条件区间。
3. **步进控制**：单步执行展示区间收缩过程，右侧面板显示 `left`、`right`、`mid` 值。
4. **音效反馈**：正确时播放“叮”声，错误时短促“哔”声。

**复古像素风格**：
- **Canvas 网格**：每个节点显示为8x8像素块，路径用连线表示。
- **背景音乐**：循环播放8-bit风格BGM。
- **AI自动演示**：按固定间隔自动执行二分步骤，模拟“AI解题”。

---

### **核心代码实现（oddy版）**

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>

int n, p, ans[100005], q[100005], tail;
long long w[100005], c[100005], s[100005];
std::vector<int> e[100005];

bool cmp(const int &x, const long long &y) {
    return s[x] < y;
}

void dfs(int x) {
    q[tail++] = x;
    // 二分找到第一个 s[v] >= s[x]-c[x]
    ans[x] = q + tail - std::lower_bound(q, q+tail, s[x]-c[x], cmp) - 1;
    for (int p : e[x]) {
        s[p] = s[x] + w[p];
        dfs(p);
    }
    tail--;
}

int main() {
    scanf("%d", &n);
    e[0].push_back(1); // 虚拟根节点0
    for (int i = 2; i <= n; i++) {
        scanf("%d", &p);
        e[p].push_back(i);
    }
    for (int i = 1; i <= n; i++) scanf("%lld", w+i);
    for (int i = 1; i <= n; i++) scanf("%lld", c+i);
    dfs(0);
    for (int i = 1; i <= n; i++) printf("%d ", ans[i]);
    return 0;
}
```

**代码解释**：
- **虚拟根节点**：将根1的父节点设为0，简化边界处理。
- **前缀和计算**：在DFS子节点前更新 `s[p] = s[x] + w[p]`。
- **二分查找**：利用 `lower_bound` 快速定位满足条件的节点位置。

---
处理用时：469.14秒
# 题目信息

# yyy2015c01 的 U 盘

## 题目背景

在 2020 年的某一天，我们的 yyy2015c01 买了个高端 U 盘。


## 题目描述

你找 yyy2015c01 借到了这个高端的 U 盘，拷贝一些重要资料，但是你发现这个 U 盘有一些问题：

1. 这个 U 盘的传输接口很小，只能传输大小不超过 $L$ 的文件。
2. 这个 U 盘容量很小，一共只能装不超过 $S$ 的文件。

但是你要备份的资料却有很多，你只能备份其中的一部分。

为了选择要备份哪些文件，你给所有文件设置了一个价值 $V_i$，你希望备份的文件总价值不小于 $p$。

但是很快你发现这是不可能的，因为 yyy2015c01 的传输接口太小了，你只有花钱买一个更大的接口（更大的接口意味着可以传输更大的文件，但是购买它会花费更多的钱）。

注意：你的文件不能被分割（你只能把一个文件整个的传输进去，并储存在U盘中）,

你放在 U 盘中文件的总大小不能超过 U 盘容量。

现在问题来了：你想知道，在满足 U 盘中文件价值之和**不小于** $p$ 时，最小需要多大的接口。

## 说明/提示

$1 \le n, W_i, S \le 10^3$，$1 \leq V_i \leq 10^6$，$1 \leq p \leq 10^9$。

数据较小，请勿乱搞。

样例解释 $1$：买一个大小为 $2$ 接口，把物品 $1$ 、$2$ 放进$\text{U}$盘。

样例解释 $2$：买一个大小为 $500$ 的接口。

样例解释 $3$：本来可以买大小为 $2$ 的接口，可是 U 盘容量放不下足够的文件。

如果数据出现疏漏，请联系出题人 [a710128](https://www.luogu.com.cn/user/2573)

向本题主人公 yyy2015c01 同学致敬！

## 样例 #1

### 输入

```
3 3 5
2 2
1 2
3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 505
1 2
500 1```

### 输出

```
500```

## 样例 #3

### 输入

```
3 3 2
2 2
1 2
3 2```

### 输出

```
No Solution!```

## 样例 #4

### 输入

```
4 5 6
5 1
5 2
5 3
1 1```

### 输出

```
No Solution!```

# AI分析结果



## 算法分类
二分

---

## 题解思路与算法要点
### 核心思路
题目要求在满足价值总和 ≥ p 的条件下，找到最小的接口大小 L。采用二分答案策略，将 L 的候选范围限定在文件体积的最小值到最大值之间。每次通过 01背包 验证当前 mid 是否可行。

### 解决难点
1. **二分边界确定**  
   初始 left 设为文件体积最小值-1，right 设为最大值。通过调整 mid 的收缩方向确保正确覆盖候选区间。

2. **背包验证优化**  
   在 check 函数中跳过体积超过 mid 的文件，动态维护最大价值。若总容量为 s 时的最大价值 ≥ p，则当前 mid 可行。

3. **无解判断**  
   先进行一次无接口限制的背包计算，若此时仍无法满足 p，则直接无解。

### 对比题解亮点
- **cs18 的贪心背包**  
  按文件体积排序后逐步扩展背包，利用动态规划特性在首次满足条件时直接输出。时间复杂度 O(n*s) 更优，但正确性依赖文件体积的候选特性。
- **MuelsyseU 的二分+背包**  
  严格保证正确性，详细处理边界条件。初始化时将 right 设为文件体积最大值，避免无效区间搜索。

---

## 题解评分（≥4星）
1. **MuelsyseU（★★★★★）**  
   思路严谨，包含二分原理、背包验证、边界处理的全流程解析。代码实现清晰，附带详细注释。

2. **amstar（★★★★）**  
   简洁实现二分+背包，但初始 right 设为 s 存在边界风险。核心逻辑正确，适合快速理解。

3. **Y_B_Y（★★★★）**  
   提供像素化二分动画示意图，代码实现规范，附带无解判断优化。

---

## 最优思路提炼
**二分收缩技巧**  
```cpp
int l = 文件体积最小值, r = 文件体积最大值;
while (l < r) {
    int mid = (l + r) / 2;
    if (check(mid)) r = mid;    // 可行，尝试更小值
    else l = mid + 1;           // 不可行，必须增大
}
```
**背包验证核心**  
```cpp
bool check(int L) {
    memset(dp, 0, sizeof(dp));
    for (int i = 1; i <= n; i++) {
        if (w[i] > L) continue;
        for (int j = s; j >= w[i]; j--)
            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
    return dp[s] >= p;
}
```

---

## 同类题目推荐
1. **P2440 木材加工**（二分答案基础）
2. **P2678 跳石头**（二分答案+贪心验证）
3. **P4343 自动刷题机**（二分答案+模拟验证）

---

## 可视化设计
**像素化二分动画**  
- **界面**：8-bit 风格，绿色网格表示当前区间 [l, r]，红色方块表示 mid。
- **交互**：  
  - 点击 "Step" 单步执行二分收缩，播放 "blip" 音效。  
  - 成功时显示闪烁的 "Solved!" 并播放胜利音效。  
  - 失败时显示灰色 "No Solution" 和低沉音效。  
- **算法演示**：  
  ```javascript
  function animateBinary() {
      let mid = Math.floor((l + r) / 2);
      drawGrid(l, r, mid); // 绘制当前区间和mid
      if (check(mid)) {
          r = mid;
          playSound('success'); // 高音效
      } else {
          l = mid + 1;
          playSound('fail');    // 低音效
      }
  }
  ```

---

## 参考代码（二分+背包）
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

const int MAXN = 1005;
int n, p, s, w[MAXN], v[MAXN], dp[MAXN];

bool check(int L) {
    memset(dp, 0, sizeof(dp));
    for (int i = 1; i <= n; i++) {
        if (w[i] > L) continue;
        for (int j = s; j >= w[i]; j--)
            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
    return dp[s] >= p;
}

int main() {
    cin >> n >> p >> s;
    int l = 1e9, r = 0;
    for (int i = 1; i <= n; i++) {
        cin >> w[i] >> v[i];
        l = min(l, w[i]);
        r = max(r, w[i]);
    }
    // 无解判断
    if (!check(r)) {
        cout << "No Solution!";
        return 0;
    }
    // 二分收缩
    while (l < r) {
        int mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    cout << l;
    return 0;
}
```

---
处理用时：270.60秒
# 题目信息

# 小鸟的设备

## 题目背景

小鸟有 $n$ 个可同时使用的设备。


## 题目描述

第 $i$ 个设备每秒消耗 $a_i$ 个单位能量。能量的使用是连续的，也就是说能量不是某时刻突然消耗的，而是匀速消耗。也就是说，对于任意实数，在 $k$ 秒内消耗的能量均为 $k\times a_i$ 单位。在开始的时候第 $i$ 个设备里存储着 $b_i$ 个单位能量。

同时小鸟又有一个可以给任意一个设备充电的充电宝，每秒可以给接通的设备充能 $p$ 个单位，充能也是连续的，不再赘述。你可以在任意时间给任意一个设备充能，从一个设备切换到另一个设备的时间忽略不计。

小鸟想把这些设备一起使用，直到其中有设备能量降为  $0$。所以小鸟想知道，在充电器的作用下，她最多能将这些设备一起使用多久。

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq p\leq 100000$，$1\leq a_i,b_i\leq100000$。


## 样例 #1

### 输入

```
2 1
2 2
2 1000
```

### 输出

```
2.0000000000```

## 样例 #2

### 输入

```
1 100
1 1```

### 输出

```
-1 ```

## 样例 #3

### 输入

```
3 5
4 3
5 2
6 1```

### 输出

```
0.5000000000 ```

# AI分析结果



---

## 算法分类
**二分**

---

## 题解思路与核心难点

### 算法要点
1. **二分答案框架**：在实数域上二分查找最大使用时间，验证函数通过贪心策略计算充电需求。
2. **验证逻辑**：对每个设备计算 $a_i \times t - b_i$，若结果为正则需要充电，累加总需求后判断是否 ≤ $p \times t$。
3. **边界处理**：初始右边界设为 $1e10$ 以覆盖极端情况，循环终止条件设置为 $r-l < 1e-6$ 保证精度。
4. **特殊判断**：所有设备总耗能速度 ≤ 充电速度时输出 $-1$。

### 解决难点
- **充电时序无关性**：通过总需求计算避免了充电顺序的复杂分配。
- **浮点精度控制**：通过设置足够的终止条件精度（如 $1e-6$）避免死循环。
- **高效验证**：$O(n)$ 的验证复杂度使得整体复杂度为 $O(n \log \epsilon)$。

---

## 题解评分 (≥4星)

1. **作者：qq1010903229 (5星)**
   - 思路清晰，代码简洁，验证函数直接体现贪心策略。
   - 初始区间和终止条件处理合理，特判逻辑明确。
   - 关键代码片段：
     ```cpp
     int check(double ans) {
         double sum = 0;
         for (int i=0; i<n; i++) {
             if (a[i]*ans > b[i]) sum += (a[i]*ans - b[i]);
         }
         return sum <= p*ans;
     }
     ```

2. **作者：Ja50nY0un9_as_AgNO3 (4星)**
   - 提出贪心合并设备的优化思路，但代码可读性稍差。
   - 时间复杂度 $O(n \log n)$，通过排序实现设备合并。

3. **作者：AxDea (4星)**
   - 公式化验证条件 $p \times k + \sum (b_i - a_i k) \geq 0$，逻辑严谨。
   - 处理浮点数精度时在循环内累加，避免溢出风险。

---

## 最优思路/技巧提炼

1. **二分答案通用模板**：
   ```python
   left, right = 0, MAX_VALUE
   while right - left > EPS:
       mid = (left + right) / 2
       if check(mid):
           left = mid
       else:
           right = mid
   return left
   ```

2. **贪心验证优化**：
   - 对每个设备单独计算需求，无需关注充电时序。
   - 通过总能量需求与充电宝供给的比较快速验证可行性。

3. **边界初始化技巧**：
   - 右边界设为 $1e10$ 可覆盖 $a_i=1e5, b_i=1e5$ 时 $t=1e5/1=1e5$ 的极端情况。

---

## 类似题目推荐

1. **P1182 数列分段 Section II**  
   （二分答案求最小分段和）

2. **P4344 [SHOI2015] 零件组装机**  
   （二分验证机器组装可行性）

3. **P2218 [HAOI2007] 覆盖问题**  
   （二分+几何覆盖验证）

---

## 可视化设计

### 动画方案
- **区间动态展示**：用 Canvas 绘制区间 [left, right]，标记当前 mid 值。
- **颜色标记**：
  - 绿色：当前 mid 可行（check 返回 true）
  - 红色：当前 mid 不可行
- **步进控制**：单步执行按钮展示每一步的区间收缩过程。

### 复古像素风格
- **8位音效**：
  - 移动 mid 时播放 "beep" 音效。
  - 找到答案时播放胜利音效。
- **像素方块渲染**：用 16x16 像素方块表示区间端点，动画帧率设置为 5 FPS。

### 代码片段（Canvas 绘制）
```javascript
function drawInterval(left, right, mid) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawRect(left * scaleX, 10, 'blue');    // Left bound
    drawRect(right * scaleX, 10, 'blue');   // Right bound
    drawRect(mid * scaleX, 30, 'green');    // Mid value
}
```

---

## 核心代码实现

```cpp
bool check(double t) {
    double required = 0;
    for (int i=0; i<n; ++i) {
        if (a[i] * t > b[i]) {
            required += a[i] * t - b[i];
        }
    }
    return required <= p * t;
}

double solve() {
    double left = 0, right = 1e10;
    if (sum_a <= p) return -1; // 特判
    for (int iter=0; iter<100; ++iter) { // 固定迭代次数避免精度问题
        double mid = (left + right) / 2;
        if (check(mid)) left = mid;
        else right = mid;
    }
    return left;
}
```

---
处理用时：84.22秒
# 题目信息

# [Code+#1] 木材

## 题目描述

有 $n$ 棵树，初始时每棵树的高度为 $H_i$，第 $i$ 棵树每月都会长高 $A_i$。现在有个木料长度总量为 $S$ 的订单，客户要求每块木料的长度不能小于  $L$，而且木料必须是整棵树（即不能为树的一部分）。现在问你最少需要等多少个月才能满足订单。


## 说明/提示

对于样例，在六个月后，各棵树的高度分别为 $14,47,56$，此时无法完成订单。

在七个月后，各棵树的高度分别为 $16,54,65$，此时可以砍下第 $2$ 和第 $3$ 棵树完成订单了。

 ![](https://cdn.luogu.com.cn/upload/pic/12821.png) 

来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/郑林楷 命题/郑林楷 验题/王聿中

Git Repo：https://git.thusaac.org/publish/CodePlus201711

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
3 74 51
2 5 2
2 7 9
```

### 输出

```
7```

# AI分析结果



## 【唯一算法分类】  
二分  

---

## 【综合分析与结论】  
题目要求找到满足木材订单的最小月份，核心思路是**二分答案**。关键在于正确判断给定月份是否满足条件，并处理大数溢出问题。  
- **核心难点**：  
  1. **数据范围**：S、L可达1e18，需使用 `unsigned long long` 避免溢出。  
  2. **初始条件判断**：需先检查第0个月是否已满足条件。  
  3. **优化check函数**：累加时提前终止，减少计算量。  
- **二分实现要点**：  
  - **初始区间**：左界 `l=0`，右界 `r=max(S, L)` 或足够大的值（如1e18）。  
  - **区间收缩**：若当前 `mid` 满足条件，则 `r=mid`，否则 `l=mid+1`。  
  - **check逻辑**：计算每棵树在 `mid` 个月后的高度，累加符合条件者，判断是否 ≥S。  

---

## 【题解清单 (≥4星)】  
1. **Drinkkk (5星)**  
   - **亮点**：逐步优化不同数据类型的处理，最终使用 `unsigned long long` 和缩小右界。  
   - **代码**：在二分前预处理右界，避免不必要的计算。  

2. **litifeng (5星)**  
   - **亮点**：通过数学转换将乘法转为除法，避免溢出问题。  
   - **代码**：使用 `(l - h[i] - 1)/a[i] + 1` 计算临界月份，避免直接乘法。  

3. **Victorique (4星)**  
   - **亮点**：代码简洁，直接应用二分模板，但需注意初始条件和溢出处理。  

---

## 【最优思路/技巧提炼】  
1. **避免溢出**：用 `h[i] + a[i] * mid >= L` 转为 `mid >= (L - h[i] - 1)/a[i] + 1`，避免大数相乘。  
2. **提前终止累加**：在check函数中，一旦累加值≥S立即返回，减少循环次数。  
3. **初始化优化**：预处理右界 `r = min(r, (max(S, L) - h[i])/a[i] + 1)`，缩小搜索范围。  

---

## 【同类型题与算法套路】  
- **通用二分答案模板**：  
  1. 确定单调性：答案随条件单调变化。  
  2. 设计check函数：判断给定值是否满足条件。  
  3. 处理边界：初始状态和循环终止条件。  
- **类似题目**：  
  - **P1873 砍树**：二分查找最大砍树高度。  
  - **P2678 跳石头**：二分最小跳跃距离。  
  - **P2440 木材加工**：类似本题的二分答案问题。  

---

## 【推荐洛谷题目】  
1. **P1873**：二分答案求最大砍树高度。  
2. **P2678**：二分最小跳跃距离。  
3. **P1182**：数列分段，二分最大段和的最小值。  

---

## 【个人心得摘录】  
- **EXODUS**：`n=1` 时需特判，否则会WA。  
- **dying**：贪心法虽可行，但二分更优。  
- **Kisaragi_77**：使用 `__int128` 处理大数乘法。  

---

## 【可视化与算法演示】  
### 二分过程动画设计  
1. **动画方案**：  
   - **Canvas绘制区间**：以横轴表示月份范围，动态显示 `l`, `r`, `mid`。  
   - **颜色标记**：  
     - `mid` 点用黄色高亮。  
     - 满足条件时区间变绿，否则变红。  
   - **步进控制**：用户可点击“下一步”观察区间收缩。  

2. **复古像素风格**：  
   - **8位色调色板**：绿色表示有效区间，红色表示无效，黄色表示当前mid。  
   - **音效**：  
     - 更新mid时播放“哔”声。  
     - 找到答案时播放胜利音效。  

3. **代码片段**（关键逻辑）：  
```javascript
function drawBinary(l, r, mid, isValid) {
  ctx.fillStyle = "#000"; // 背景黑色
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  // 绘制区间线
  ctx.strokeStyle = "#0F0";
  ctx.beginPath();
  ctx.moveTo(l * scale, 50);
  ctx.lineTo(r * scale, 50);
  ctx.stroke();
  // 绘制mid点
  ctx.fillStyle = isValid ? "#0F0" : "#F00";
  ctx.fillRect(mid * scale - 2, 45, 4, 10);
}
```

---

## 【核心代码实现】  
```cpp
#include <cstdio>
using namespace std;
typedef unsigned long long ull;

ull n, S, L, h[200005], a[200005];

bool check(ull mid) {
    ull sum = 0;
    for (int i = 0; i < n; ++i) {
        if (h[i] >= L || mid >= (L - h[i] - 1) / a[i] + 1) {
            sum += h[i] + a[i] * mid;
            if (sum >= S) return true; // 提前终止
        }
    }
    return sum >= S;
}

int main() {
    scanf("%llu%llu%llu", &n, &S, &L);
    for (int i = 0; i < n; ++i) scanf("%llu", h + i);
    for (int i = 0; i < n; ++i) scanf("%llu", a + i);

    ull l = 0, r = 1e18;
    if (check(0)) { printf("0"); return 0; } // 初始检查

    while (l < r) {
        ull mid = (l + r) >> 1;
        check(mid) ? r = mid : l = mid + 1;
    }
    printf("%llu", l);
    return 0;
}
```

---
处理用时：87.41秒
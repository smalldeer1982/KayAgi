# 题目信息

# [NOI Online #2 入门组] 未了

## 题目描述

由于触犯天神，Sisyphus 将要接受惩罚。

宙斯命 Sisyphus 推一块巨石上长度为 $L$ 的山坡。Sisyphus 匀速向上推的速度为每年 $v$ 的长度（由于是匀速，故经过 $\frac{1}{2}$ 年将能向上推 $\frac{v}{2}$ 的长度）。然而，宙斯并不希望 Sisyphus 太快到达山顶。宙斯可以施展 $n$ 个魔法，若宙斯施展第 $i$ 个魔法 $(1\leq i \leq n)$，则当 Sisyphus 第一次到达位置  $a_i$ 时，他将会同巨石一起滚落下山底，并从头推起。（滚落的时间忽略不计，即可看作第一次到达位置 $a_i$ 后 Sisyphus 立即从山底重新出发）

例如宙斯施用了 $a_i=3$ 和 $a_i=5$ 的两个魔法。Sisyphus 的速度 $v=1$ ，山坡的长度 $L = 6$，则他推石上山过程如下：

- 用 $3$ 年走到位置 $3$。

- 受 $a_i=3$ 的魔法影响，回到了山底出发。

- 再用 $3$ 年走到位置 $3$，然而因为是第二次到达，$a_i=3$ 的魔法不起作用。

- 用 $2$ 年走到位置 $5$。

- 受 $a_i=5$ 的魔法影响，回到了山底出发。

- 用 $6$ 年从山底走到了山顶。花费的总时间为 $14$ 年。

现在，宙斯有 $q$ 个询问。对于第 $i$ 个询问 $t_i$，宙斯想知道，他最少需要施展多少个魔法才能使 Sisyphus 到达山顶所用的年数大于 $t_i$

## 说明/提示

1. 不使用任何魔法，Sisyphus 需要 $2$ 年走上山顶。
2. 使用魔法 $2$ ，Sisyphus 需要 $\frac{11}{3}$ 年走上山顶。（用时 $\frac{5}{3}$ 年走到魔法 $2$ 的位置并滚落下山，再用时 $\frac{6}{3}=2$ 年走到山顶）
3. 使用魔法 $1,2$ ，Sisyphus 需要 $\frac{14}{3}$ 年走上山顶。
4. 宙斯不能使 Sisyphus 用大于 $5$ 年的时间走上山顶。

对于测试点 $1\sim 8:n=1$。

对于测试点 $9\sim 12:n=2$。

对于测试点 $13\sim 17:n,q\le 1000$。

对于所有测试点：$1 \leq n,q \leq 2 \times 10^5$，$1\leq v\leq L\leq 10^{9}$，$1\leq a_i < L$，$1 \leq t_i\leq 10^9$。

数据保证 $a_i$ 两两不同。

## 样例 #1

### 输入

```
3 6 3
3 5 1
4
1
3
4
5
```

### 输出

```
0
1
2
-1
```

# AI分析结果



### 算法分类
**二分**

---

### 题解思路与算法要点

#### **核心思路**
1. **贪心排序**：将魔法点按距离从大到小排序，优先选更大的魔法点以最大化总耗时。
2. **前缀和**：预处理排序后的魔法点，计算前缀和数组，表示使用前 `i` 个魔法后的总路程或总时间。
3. **二分查找**：对每个询问，二分查找最小的 `k`，使得使用 `k` 个魔法的总耗时超过目标值。

#### **解决难点**
1. **浮点精度问题**：部分题解通过转化为整数运算（比较总路程 `sum` 与 `t*v`）避免除法精度问题。
2. **边界处理**：
   - 特判无需魔法或所有魔法均无法满足条件的情况。
   - 二分区间初始化为 `[0, n]`，确保正确覆盖所有可能。
3. **二分条件**：通过 `upper_bound` 或手写二分，找到第一个满足 `sum > t*v - L` 的位置。

#### **关键代码片段**
```cpp
// 预处理前缀和（整数运算）
sort(a + 1, a + n + 1, greater<int>());
sum[0] = L;  // 初始路程为 L
for (int i = 1; i <= n; i++) sum[i] = sum[i-1] + a[i];

// 二分过程
int query(int t) {
    if (sum[0] > t * v) return 0;  // 无需魔法
    if (sum[n] <= t * v) return -1; // 所有魔法不足
    // 查找第一个 sum[i] > t*v - L
    return upper_bound(sum, sum + n + 1, t * v - L) - sum;
}
```

---

### 题解评分 (≥4星)
1. **chen_zhe (5星)**  
   - 思路清晰，直接使用 `upper_bound` 简化代码。
   - 时间复杂度 `O(n log n + q log n)`，高效处理大数据。
   - 代码简洁，无冗余逻辑。

2. **翼德天尊 (4星)**  
   - 明确贪心+二分思路，注释详细。
   - 手写二分逻辑，便于理解收缩过程。
   - 代码结构清晰，但存在浮点运算。

3. **Mine_King (4星)**  
   - 前缀和直接存储总路程，避免浮点问题。
   - 手写二分实现，边界处理明确。
   - 代码可读性高，适合教学。

---

### 最优思路提炼
1. **整数化处理**：比较总路程而非时间，避免浮点误差。
2. **upper_bound 优化**：利用 STL 函数简化二分实现。
3. **前缀和单调性**：排序后前缀和必然单调递增，确保二分有效性。

---

### 类似算法题
1. **P1873 砍树**（二分答案求最大高度）
2. **P2440 木材加工**（二分查找最大长度）
3. **P2678 跳石头**（二分最短跳跃距离）

---

### 可视化与算法演示
#### **二分过程动画设计**
- **像素风格**：区间 `[left, right]` 用网格表示，`mid` 用高亮色块。
- **动画效果**：
  1. 初始区间覆盖整个数组，左右指针分列两端。
  2. 每次计算 `mid`，比较 `sum[mid]` 与目标值。
  3. 若 `sum[mid] ≤ target`，左指针右移；否则右指针左移。
- **音效提示**：每次更新播放“滴”声，命中时播放成功音效。

---

### 代码实现（核心二分逻辑）
```cpp
int binary_search(long long target) {
    int left = 0, right = n, ans = -1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (sum[mid] > target) {
            ans = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return ans;
}
```

---

### 个人心得
- **避免浮点**：通过整数运算提升代码鲁棒性。
- **边界测试**：特别注意 `k=0` 和 `k=n` 的极端情况。
- **STL 优势**：合理使用 `upper_bound` 减少编码错误。

---

**可视化演示示例**  
（设想：Canvas 绘制排序后的魔法点，动态展示二分区间收缩，高亮当前 `mid` 和结果）

---
处理用时：72.10秒
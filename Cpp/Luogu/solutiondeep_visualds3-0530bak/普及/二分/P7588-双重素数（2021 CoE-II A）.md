# 题目信息

# 双重素数（2021 CoE-II A）

## 题目描述

素数（质数）是指在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数。定义**双重素数**为这样的素数：它的各位数字之和也是一个素数。给定一个闭区间，试确定在该区间内双重素数的个数。

## 说明/提示

**样例说明**

从 $1$ 到 $15$ 共有 $6$ 个素数：$2$，$3$，$5$，$7$，$11$，$13$。前五个素数各自的数字之和也是素数，因此都是双重素数。素数 $13$ 的各位数字之和为 $4$，不是素数，故 $13$ 不是双重素数。

------------


**数据范围**

- Subtask $1$ ：$1 \le L \le R \le 10^2$，$10$ 分。
- Subtask $2$ ：$1 \le L \le R \le 10^4$，$20$ 分。
- Subtask $3$ ：$1 \le L \le R \le 10^6$，$60$ 分。
- Subtask $4$ ：$1 \le L \le R \le 10^8$，$10$ 分。

对于 $100\%$ 的数据，$1 \le T \le 100$。


------------

**提示（数据已经加强）**

最后一个子任务要求你的程序必须具有较高的空间使用效率和时间效率，否则容易超出内存限制或时间限制。

## 样例 #1

### 输入

```
4
3 3
4 4
1 5
1 15```

### 输出

```
1
0
3
5```

# AI分析结果



# 算法分类
二分

# 题解思路与核心难点

## 算法要点
1. **欧拉筛预处理**：用线性筛法预处理1e8范围内的素数，通过bitset优化空间（空间降为普通bool数组的1/8）
2. **双重素数筛选**：对每个素数计算数位和，判断其是否为素数（数位和范围2-72，可预存素数表快速判断）
3. **二分加速查询**：将双重素数存入有序数组，利用lower_bound和upper_bound快速定位区间左右边界

## 解决难点对比
| 题解差异点         | 王熙文题解                     | Buried_Dream题解              |
|--------------------|-------------------------------|--------------------------------|
| 空间优化           | 用bitset代替bool数组          | 用位操作压缩存储               |
| 双重素数判断       | 硬编码72以内素数表            | 预存素数列表二次筛             |
| 查询方式           | 两次二分位置相减              | 维护前缀和数组                 |
| 预处理顺序         | 先筛普通素数再筛双重素数       | 同前                          |

# 题解评分
## 王熙文题解（4.5星）
- 亮点：bitset空间优化、硬编码快速判断数位和素数
- 不足：硬编码素数表可读性稍差
## _lfxxx_题解（4.2星）
- 亮点：完整展示欧拉筛与二分结合的完整流程
- 不足：未提及数位和最大值的优化
## metaphysis题解（4.0星）
- 亮点：位标记数组的手动实现
- 不足：查询部分代码较晦涩

# 最优思路提炼
```cpp
// 预处理数位和素数判断
vector<int> magic_primes = {2,3,5,7,...,71}; // 72以内所有素数
bool is_dsum_prime(int sum) {
    return binary_search(magic_primes.begin(), magic_primes.end(), sum);
}

// 二分查询核心代码
int query(int L, int R) {
    auto l = lower_bound(double_primes.begin(), double_primes.end(), L);
    auto r = upper_bound(double_primes.begin(), double_primes.end(), R);
    return r - l;
}
```

# 同类型题目
1. **P3383** 线性筛素数（筛法基础）
2. **P1217** 回文素数（预处理+特性判断）
3. **P1835** 素数密度（区间筛法应用）

# 可视化设计
## 二分过程动画方案
```javascript
// 伪代码展示关键动画逻辑
function visualizeBinarySearch(arr, target) {
    let left = 0, right = arr.length - 1;
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        highlightBlock(mid, 'yellow'); // 高亮当前mid元素
        
        if (arr[mid] < target) {
            animateArrow(left, mid + 1); // 左指针右移动画
            left = mid + 1;
        } else {
            animateArrow(right, mid - 1); // 右指针左移动画
            right = mid - 1;
        }
    }
    playSuccessSound(); // 找到时播放音效
}
```

## 复古游戏化要素
1. **像素风格**：用16色块表示搜索区间，绿色表示有效区间，红色表示排除区间
2. **音效设计**：
   - 指针移动：8-bit "blip" 音效
   - 找到目标：FC游戏通关音效
3. **自动演示模式**：按帧逐步展示二分过程，速度可调节（1x/2x/4x）

# 核心代码片段
```cpp
// 欧拉筛法核心
bitset<100000001> is_prime;
vector<int> primes;
void sieve() {
    for(int i=2; i<=1e8; ++i) {
        if(!is_prime[i]) primes.push_back(i);
        for(int p : primes) {
            if(i*p > 1e8) break;
            is_prime[i*p] = 1;
            if(i%p == 0) break;
        }
    }
}

// 二分查询实现
int query(int L, int R) {
    auto begin = primes.begin(), end = primes.end();
    auto left = lower_bound(begin, end, L);
    auto right = upper_bound(begin, end, R);
    return distance(left, right);
}
```

---
处理用时：63.46秒
# 题目信息

# [JOI 2022 Final] 自学 (Self Study)

## 题目描述

在 JOI 高中高一的第三个学期的 $M$ 个星期的时间内，有 $N$ 门课，编号为 $1 \sim N$。每个星期有 $N$ 个课时，第 $i$ 个课时上课程 $i$ 的一节课。

比太郎是一位高一学生。对于 $N \times M$ 个课时中的每一个，他会选择如下行动中的一个：

- 行动 1：比太郎去上课。如果他去上了课程 $i$ 的一节课，那么他对课程 $i$ 的理解程度会增加 $A_i$。
- 行动 2：比太郎不去上课。他转而选择任意一门课，并且自学选中的那门课。如果他选中了课程 $i$ 进行了时长为一课时的自学，那么他对课程 $i$ 的理解程度会增加 $B_i$。

一开始，对每门课的理解程度都为 $0$。由于比太郎想要在课后练习算法竞赛，他在非上课时间内不会学习。当第三个学期的所有课时结束后，期末考就会举行。

比太郎不想挂科。所以他想要最大化在期末考时对每门课的理解程度的最小值。

给定学期的长度，课程的数量，以及对理解程度的提升数值，请写一个程序计算在期末考时对每门课的理解程度的最小值的最大可能值。

## 说明/提示

**【样例解释 \#1】**

举个例子，如果比太郎按如下方式学习，则他对课程 $1, 2, 3$ 的理解程度将分别为 $19, 18, 19$。

- 第一周课程 $1$ 的课：自学课程 $2$；
- 第一周课程 $2$ 的课：自学课程 $2$；
- 第一周课程 $3$ 的课：去上课程 $3$ 的课；
- 第二周课程 $1$ 的课：去上课程 $1$ 的课；
- 第二周课程 $2$ 的课：自学课程 $3$；
- 第二周课程 $3$ 的课：去上课程 $3$ 的课；
- 第三周课程 $1$ 的课：自学课程 $3$；
- 第三周课程 $2$ 的课：自学课程 $2$；
- 第三周课程 $3$ 的课：去上课程 $3$ 的课。

由于对每门课的最小的理解程度不能大于等于 $19$，输出 $18$。

这个样例满足子任务 $3, 5$ 的限制。

**【样例解释 \#2】**

这个样例满足子任务 $1, 3, 5$ 的限制。

**【样例解释 \#3】**

这个样例满足子任务 $3, 5$ 的限制。

**【样例解释 \#4】**

这个样例满足子任务 $2, 3, 4, 5$ 的限制。

----

**【数据范围】**

**本题采用捆绑测试。**

对于 $100 \%$ 的数据，$1 \le N \le 3 \times {10}^5$，$1 \le M \le {10}^9$，$1 \le A_i, B_i \le {10}^9$。

- 子任务 $1$（$10$ 分）：$M = 1$。
- 子任务 $2$（$25$ 分）：$N \cdot M \le 3 \times {10}^5$，$A_i = B_i$。
- 子任务 $3$（$27$ 分）：$N \cdot M \le 3 \times {10}^5$。
- 子任务 $4$（$29$ 分）：$A_i = B_i$。
- 子任务 $5$（$9$ 分）：无特殊限制。

----

**译自 [JOI 2022 Final](https://www.ioi-jp.org/joi/2021/2022-ho/index.html) T2「[自習](https://www.ioi-jp.org/joi/2021/2022-ho/2022-ho-t2.pdf) / [Self Study](https://www.ioi-jp.org/joi/2021/2022-ho/2022-ho-t2-en.pdf)」**

## 样例 #1

### 输入

```
3 3
19 4 5
2 6 2
```

### 输出

```
18
```

## 样例 #2

### 输入

```
2 1
9 7
2 6
```

### 输出

```
7
```

## 样例 #3

### 输入

```
5 60000
630510219 369411957 874325200 990002527 567203997
438920902 634940661 593780254 315929832 420627496
```

### 输出

```
41397427274960
```

## 样例 #4

### 输入

```
4 25
1 2 3 4
1 2 3 4
```

### 输出

```
48
```

# AI分析结果



# 核心分析与结论

## 算法分类  
**二分**

---

## 题解思路与算法要点  

### 核心思路  
所有题解均采用**二分答案 + 贪心验证**框架：  
1. **二分搜索**：目标是最小值的最大可能值，搜索范围在 `[0, max(A_i,B_i)*M]`。  
2. **贪心验证**：对每个课程计算达到目标值所需的最少课时，并判断总课时是否允许。  

### 解决难点  
- **验证函数的设计**：  
  - 若 `A_i > B_i`，优先上课，不足时用自学补足。  
  - 若 `B_i > A_i`，全部自学。  
  - 通过计算所需课时总和是否 ≤ `N*M` 判断可行性。  
- **高效处理大数**：  
  - 使用 `__int128`（南阳刘子骥）或调整计算顺序（龙水流深）避免溢出。  

### 关键优化  
- 预处理取 `A_i = max(A_i, B_i)`（龙水流深、南阳刘子骥），简化后续计算。  
- 将总课时分为“剩余课时”和“缺口课时”，通过正负数累加判断（南阳刘子骥）。  

---

## 题解评分（≥4星）  

1. **sgl654321（4.5星）**  
   - **亮点**：  
     - 详细注释与样例分析，代码可读性强。  
     - 直接分类讨论上课与自学的选择逻辑，清晰易懂。  
   - **代码片段**：  
     ```cpp
     bool check(long long target) {
         num = 0;
         for (int i=1; i<=n; i++) {
             if (a[i].self > a[i].teach) { // 自学更优
                 num += lesson_num(target, a[i].self);
             } else { // 上课更优
                 if (m*a[i].teach >= target) {
                     num += lesson_num(target, a[i].teach);
                 } else {
                     num += m;
                     num += lesson_num(target - m*a[i].teach, a[i].self);
                 }
             }
             if (num > n*m) return 0;
         }
         return 1;
     }
     ```

2. **龙水流深（4星）**  
   - **亮点**：  
     - 预处理 `a[i] = max(A_i, B_i)` 简化验证逻辑。  
     - 使用负数累加缺口课时，减少条件判断。  
   - **代码片段**：  
     ```cpp
     bool check(long long lim) {
         __int128_t s = 0;
         for (int i=1; i<=n; ++i) {
             if (a[i]*m >= lim) s += (a[i]*m - lim)/a[i]; // 剩余课时
             else s -= (lim - a[i]*m + b[i]-1)/b[i];     // 缺口课时
         }
         return s >= 0;
     }
     ```

3. **南阳刘子骥（4星）**  
   - **亮点**：  
     - 通过计算总剩余/缺口课时判断可行性，数学推导简洁。  
     - 使用 `ceil` 的等价实现避免浮点运算。  
   - **代码片段**：  
     ```cpp
     ll calc(ll a, ll b) {
         if (a % b == 0) return a / b;
         else return a / b + 1;
     }
     ```

---

## 最优思路提炼  

### 关键步骤  
1. **预处理**：对每个课程，选择最高效率方式 `max(A_i, B_i)`。  
2. **二分框架**：  
   - 左边界 `l=0`，右边界 `r = max(A_i, B_i)*M`。  
   - 每次计算 `mid` 并验证是否可行。  
3. **验证函数**：  
   - 若课程 `i` 仅用最高效率方式即可达标，累加剩余课时。  
   - 否则计算缺口课时，累加负数缺口。  
   - 最终总剩余课时 ≥0 表示可行。  

### 避免死循环的技巧  
- 使用 `l = mid + 1` 和 `r = mid - 1` 确保循环终止。  
- 初始右边界适当放大（如 `1e18`）避免遗漏解。  

---

## 类似算法题目  
1. **P2678 跳石头**（二分答案 + 贪心验证）  
2. **P1281 书的复制**（二分答案 + 模拟分配）  
3. **P4344 [SHOI2015] 零件组装**（二分答案 + 图论验证）  

---

## 个人心得摘录  
- **南阳刘子骥**：  
  > “不开 `long long` 见祖宗。判断函数中间可能出现爆 `long long`，使用 `__int128` 或调整计算顺序。”  
- **Aisaka_Taiga**：  
  > “结构体数组一定要开足够大，否则会运行错误。”  

---

## 可视化与算法演示  

### 动画设计  
1. **像素风格区间展示**：  
   - **Canvas 网格**：横向表示当前二分区间 `[l, r]`，用不同颜色标记 `mid`、`l`、`r`。  
   - **步进更新**：每次收缩区间时，高亮新的 `mid` 并播放 8-bit 音效。  
2. **验证过程动态演示**：  
   - **课程条**：垂直排列课程，每门课显示当前课时分配（上课/自学）及剩余/缺口课时。  
   - **颜色编码**：绿色表示剩余课时，红色表示缺口。  
3. **控制面板**：  
   - **速度调节**：滑动条控制动画速度（50ms~2s）。  
   - **自动播放**：AI 自动执行二分，每步暂停 1 秒。  

### 复古音效设计  
- **音效类型**：  
  - `mid更新`：短促“哔”声（类似 FC 菜单选择）。  
  - `验证通过`：上扬音调（类似 FC 获得道具）。  
  - `验证失败`：低沉音调（类似 FC 受伤）。  
- **背景音乐**：循环 8-bit 风格背景音乐（类似《超级马里奥》地下城主题）。  

---

## 核心代码实现  

### 二分框架（龙水流深优化版）  
```cpp
bool check(long long lim) {
    __int128_t total = 0;
    for (int i=1; i<=n; ++i) {
        long long eff = max(A[i], B[i]);
        if (eff * m >= lim) { // 仅用最高效率方式达标
            total += (eff * m - lim) / eff; // 剩余课时
        } else { // 需要其他方式补足
            long long need = lim - eff * m;
            total -= (need + B[i] - 1) / B[i]; // 缺口课时
        }
    }
    return total >= 0;
}

// 二分主循环
long long l = 0, r = 1e18;
while (l <= r) {
    long long mid = (l + r) >> 1;
    if (check(mid)) {
        ans = mid;
        l = mid + 1;
    } else {
        r = mid - 1;
    }
}
```

---
处理用时：93.51秒
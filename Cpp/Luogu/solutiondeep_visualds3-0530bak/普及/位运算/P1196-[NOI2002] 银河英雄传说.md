# 题目信息

# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 说明/提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)

题目中没有强制 $i \neq j$，但是实测数据中不存在 $i = j$ 的情况。

## 样例 #1

### 输入

```
4
M 2 3
C 1 2
M 2 4
C 4 2```

### 输出

```
-1
1```

# AI分析结果



# 算法分类
带权并查集

# 综合分析与结论
## 核心算法流程
1. **数据结构**：
   - `fa[i]`：i号战舰的父节点
   - `front[i]`：i号战舰到所在列队首的距离
   - `num[i]`：以i为队首的列总战舰数

2. **路径压缩优化**：
   ```python
   def find(x):
       if fa[x] != x:
           root = find(fa[x])       # 递归找根节点
           front[x] += front[fa[x]] # 动态累加距离
           fa[x] = root            # 路径压缩
       return fa[x]
   ```

3. **合并操作**：
   ```python
   fx = find(x), fy = find(y)
   front[fx] = num[fy]     # x列的根节点到y列根节点距离=原y列总长度
   num[fy] += num[fx]      # 更新合并后列总长度
   fa[fx] = fy             # 将x列接到y列尾部
   ```

4. **查询操作**：
   ```python
   if find(x) == find(y):
       return abs(front[x] - front[y]) - 1
   else:
       return -1
   ```

## 可视化设计要点
**动画方案（像素风格）**：
1. **战舰队列**：用横向排列的8-bit像素方块表示，不同列用不同颜色区分
2. **合并过程**：
   - 被移动队列整体闪烁黄色高亮
   - 目标队列尾部出现箭头动画指向新加入的队列
   - `num`数值用绿色数字在队列顶部实时更新
3. **路径压缩**：
   - 红色线条动态连接节点到新父节点
   - `front`数值在节点上方用蓝色数字逐步累加
4. **音效设计**：
   - 合并时播放"哔-嘟"电子音效
   - 路径压缩时播放"滴-滴"快速连音
   - 错误查询时播放低沉"嗡"声

# 题解清单（5星级）
1. **假装思考（5星）**  
   亮点：完整解释front数组的路径压缩更新机制，给出清晰的变量定义图示，通过表格样例演示合并过程

2. **破壁人（5星）**  
   亮点：代码实现最简洁，使用三元组(s,b,fa)封装数据，通过注释说明权值维护逻辑

3. **Mr_Wolfram（5星）**  
   亮点：提供带权并查集的标准模板写法，通过独立merge()和query()函数分离业务逻辑

# 核心代码实现
```cpp
int fa[30001], front[30001], num[30001];

int find(int x) {
    if (fa[x] != x) {
        int root = find(fa[x]);
        front[x] += front[fa[x]]; // 路径压缩时动态累加
        fa[x] = root;
    }
    return fa[x];
}

void merge(int x, int y) {
    int fx = find(x), fy = find(y);
    front[fx] = num[fy];      // x列根到y列根的距离
    num[fy] += num[fx];      // 合并后总数量
    fa[fx] = fy;
}

int query(int x, int y) {
    return (find(x) == find(y)) ? 
        abs(front[x]-front[y])-1 : -1;
}
```

# 同类型题推荐
1. **P1525 关押罪犯**（权值并查集判断冲突）
2. **P2024 食物链**（三维关系维护）
3. **P1955 程序自动分析**（离散化+并查集）

# 复古像素动画片段
```javascript
// 绘制战舰队列
function drawQueue(root, x, y) {
  let curr = root;
  while(curr) {
    drawPixelShip(x, y, curr.color); 
    x += 16; // 每个战舰占16像素宽
    curr = curr.next;
  }
}

// 合并动画
function playMergeAnim(fx, fy) {
  blink(fx.queue, 'yellow', 3); // 被合并队列闪烁
  moveAnim(fx.queue, fy.tailPos); 
  playSound('merge_sound.wav');
  updateCounter(fy, 'num', fy.num + fx.num);
}
```

# 关键优化思想
**延迟更新机制**：路径压缩时不立即更新所有节点，仅在find()时动态计算当前节点到最新根节点的距离。这种"按需计算"策略将O(n)更新开销分摊到每次查询中，实现O(α(n))时间复杂度。

---
处理用时：65.44秒
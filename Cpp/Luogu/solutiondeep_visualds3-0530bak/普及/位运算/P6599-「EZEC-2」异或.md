# 题目信息

# 「EZEC-2」异或

## 题目描述

有 $T$ 组询问，每次给定两个正整数 $n,l$，   

你需要构造一个长度为 $l$ 的正整数序列 $a$（编号从 $1$ 至 $l$），   

且满足 $\forall i\in[1,l]$，都有 $a_i\in[1,n]$。

求：

$$\sum_{i=1}^l\sum_{j=1}^{i-1}a_i\oplus a_j$$

的最大值。

为了避免答案过大，对于每组询问，只需要输出这个最大值对 $10^9+7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**   
当 $n=2,l=3$，$a$ 取 $\{1,2,1\}$ 的任一排列时可以得到最大值，为 $(1\oplus2)+(1\oplus1)+(2\oplus1)=6$，易证明此时原式有最大值。

---
**【数据规模与约定】**
| 测试点编号 | $T\le$ | $n\le$ | $l\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim5$ | $1$ | $10$ | $5$ |
| $6$ | $5\times 10^5$ | $10^{12}$ | $2$ |
| $7$ | $5\times 10^5$ | $10^{12}$ | $3$ |
| $8\sim10$ | $5\times 10^5$ | $10^{12}$ | $10^5$ |

对于 $100\%$ 的数据，满足 $1\le T\le 5\times10^5$，$1\le n\le 10^{12}$，$2\le l \le 10^5$。


---
**【提示】**

1. 「$\oplus$」是按位异或符号。如果您不知道什么是按位异或，可以参考[这里](https://oi-wiki.org/math/bit/#_1)。
2. 取模是一种运算，$a$ 对 $b$ 取模代表将 $a$ 赋值为 $a$ 除以 $b$ 所得到的余数。  
在 C++ / Python 中的取模符号为 `%`，在 Pascal 中的取模符号为 `mod`。
3. $\sum$ 是求和符号。如果您不知道什么是 $\sum$ 符号，可以参考[这里](https://baike.baidu.com/item/∑/1233796?fr=aladdin)。
4. 请注意数据的读入输出对程序效率造成的影响。

## 样例 #1

### 输入

```
1
2 3
```

### 输出

```
6```

## 样例 #2

### 输入

```
2
114 514
1919 180
```

### 输出

```
8388223
16580700```

# AI分析结果



### 算法分类
**位运算、贪心**

---

### 题解思路与解决难点

#### 核心思路
1. **按位独立分析**：将异或和的每一位二进制位单独计算贡献，总和即为答案。
2. **最大化每位的贡献**：对于第 `k` 位，若有 `x` 个数该位为 `1`，则贡献为 `x*(l-x)*2^k`。当 `x ≈ l/2` 时，乘积最大。
3. **构造方法**：尽可能选取最大的二进制位权值 `2^m`，构造 `floor(l/2)` 个 `2^m` 和剩余数取 `2^m-1`，确保每个二进制位的贡献最大化。

#### 解决难点
- **如何构造数列**：通过交替使用最大二进制权值 `2^m` 和 `2^m-1`，确保每个位的 `0/1` 数量接近 `l/2`。
- **处理 `n=1` 的特例**：此时所有数必须为 `1`，异或和恒为 `0`。
- **高效计算所有二进制位贡献**：通过循环右移或位运算遍历所有可能位，避免浮点误差。

---

### 题解评分（≥4星）

1. **dead_X（5星）**  
   - **亮点**：清晰推导按位贡献公式，代码高效可靠，处理特例简洁。
   - **代码片段**：
     ```cpp
     long long now = 1LL << 40;
     while (now) {
         now >>= 1;
         if (x < now) continue;
         res += now * t * (y - t);
     }
     ```

2. **一只书虫仔（4.5星）**  
   - **亮点**：公式推导完整，代码简洁，直接计算所有二进制位的总和。
   - **代码片段**：
     ```cpp
     long long ans = ((l / 2) * (l - (l / 2))) % mod * ((1ll << (int)log2(n) + 1) - 1);
     ```

3. **李白莘莘学子（4星）**  
   - **亮点**：详细解释异或和转化为两两握手模型，代码结构清晰。
   - **个人心得**：强调“每一位独立分析”的思维模式，适合初学者理解。

---

### 最优思路提炼
1. **位独立贪心**：将问题分解到每个二进制位，最大化 `x*(l-x)`。
2. **构造数列技巧**：使用最大二进制权值 `2^m` 和 `2^m-1` 交替填充，确保每位贡献最大。
3. **高效位遍历**：通过循环右移或位运算遍历所有有效二进制位，避免浮点运算。

---

### 类似题目与套路
- **P2114 [NOI2014] 起床困难综合症**：按位贪心选择攻击/防御策略。
- **P6102 [EER2]谔运算**：异或和的统计与位分解。
- **P7649 [BalticOI 2004] Sequence**：构造数列使相邻差值的二进制位最优。

---

### 可视化与算法演示

#### 核心动画设计
1. **按位分解**：  
   - **网格展示**：将二进制位按高低位排列成网格，每个格子表示一位。
   - **颜色标记**：当前处理的位高亮为黄色，贡献值动态更新。
   - **贡献计算**：显示 `x*(l-x)*2^k` 的实时计算过程。

2. **构造数列模拟**：  
   - **像素方块**：用两种颜色表示 `2^m`（红色）和 `2^m-1`（蓝色），动态填充数列。
   - **音效触发**：每次填充播放 8-bit 音效，不同颜色对应不同音调。

3. **交互控制**：  
   - **步进执行**：允许单步观察每位贡献的累加过程。
   - **速度调节**：滑动条控制动画速度，适应不同学习节奏。

#### 复古像素风格
- **调色板**：使用 8 位经典颜色（如红、蓝、绿、黄）。
- **Canvas 绘制**：网格用 16x16 像素块，数值用像素字体显示。
- **背景音乐**：循环播放《超级马里奥》风格的 8-bit 音乐。

---

### 关键代码实现
```cpp
// 核心逻辑：遍历每个二进制位并累加贡献
long long max_xor_sum(long long n, long long l) {
    if (n == 1) return 0;
    long long ans = 0, t = l / 2;
    for (long long bit = (1LL << 40); bit > 0; bit >>= 1) {
        if (bit > n) continue;
        ans = (ans + bit * t % MOD * (l - t) % MOD) % MOD;
    }
    return ans;
}
```

---

### 个人心得摘录
- **dead_X**：构造数列时需特判 `n=1`，避免逻辑错误。
- **hanzhongtlx**：通过暴力打表验证猜想，强化对贪心策略的信心。

---

### 总结
本题通过位独立贪心策略，将复杂异或和问题分解为独立二进制位的最大化贡献，结合高效位遍历与构造技巧，实现 `O(T log n)` 的最优解。可视化设计通过复古像素风格与交互演示，直观呈现算法核心流程。

---
处理用时：89.72秒
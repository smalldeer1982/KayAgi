# 题目信息

# [✗✓OI R1] 前方之风

## 题目背景

>「不错的恶意。」  
> 女性呵呵笑道。  
>「但是，如果向我发出恶意，你可是会死哦？」

你不知道什么动作会被算作发出恶意，所以你决定做一道题来分散自己的注意力。

## 题目描述

给出一个长度为 $n$ 的序列 $a$ 和 $q$ 个询问，第 $i$ 个询问给出 $k_i$。对于每次询问，你需要进行以下操作：
1. 求出剩下的数的平均数 $\mathit{avg}$。
2. 将剩下的数中 $<\mathit{avg}-k_i$ 的数删去。
3. 重复以上两个步骤直到所有数都不会被删去。
4. 输出最后会剩下几个数。

**注意：询问之间是独立的，也就是说，不会真的删去那些数。**

## 说明/提示

**【样例解释】**

对于第一组样例，当 $k=0$ 时，显然只会留下 $99$。  
当 $k=6$ 时，删除数的步骤如下：
- 平均数为 $60\dfrac{1}{9}$，留下 $99,63,72,97,68$。
- 平均数为 $79.8$，留下 $99,97$。
- 平均数为 $98$，停止删除。

**【数据范围】**

对于 $100\%$ 的数据，满足 $1\leq n,q \le 10^5$，$1\le T \le 10$，$0 \le a_i,k_i \le 10^9$。

| subtask | 特殊数据范围 | 分数 |  时间限制
| :----------: | :----------: | :----------: |  :----------: |
| 1 | $n,q \le 200$ | 20 |   300ms 
| 2 | $n,q \le 2000$ | 30  | 300ms
| 3 |  | 50 | 800ms|

>「不错的恶意。」  
> 女性呵呵笑道。  
>「而且你运气很不错，如果放在以前，你早就死了。」

![](https://cdn.luogu.com.cn/upload/image_hosting/6icoj36r.png)

## 样例 #1

### 输入

```
5
9 9
19 99 63 39 72 46 97 38 68 
0 6 4 0 7 1 0 3 6 
6 8
88 62 48 50 8 47 
0 6 1 5 2 2 6 1 
6 5
33 3 54 17 26 64 
87 89 92 70 59 
18 19
71 52 77 38 12 34 82 14 57 39 91 7 56 86 35 68 38 14 
9 9 1 5 1 3 4 5 6 1 6 0 3 0 2 1 3 5 8 
10 15
4 77 78 76 5 19 98 94 77 81 
17 43 4 86 2 91 85 4 81 74 44 16 21 69 32 
```

### 输出

```
1 2 2 1 2 2 1 2 2
1 1 1 1 1 1 1 1
6 6 6 6 6
4 4 1 3 1 2 2 3 3 1 3 1 2 1 1 1 2 3 4
7 7 2 10 2 10 10 2 10 10 7 7 7 10 7
```

## 样例 #2

### 输入

```
1
5 1
20 0 0 0 0
5```

### 输出

```
5```

# AI分析结果



## 唯一算法分类
**排序 + 双指针 + 离线处理**

---

## 综合分析与结论
### 核心思路与算法流程
1. **排序**：将原数组从小到大排序，使得删除操作只需处理前缀。
2. **后缀和预处理**：计算排序后数组的后缀和，快速求平均值。
3. **离线处理询问**：将询问按 `k` 从大到小排序，利用答案的单调性。
4. **双指针法**：维护指针 `pos` 从最左端开始移动，找到第一个满足 `a[pos] >= avg - k` 的位置。

**解决难点**：  
- **单调性证明**：若 `k` 越大，最终保留的数越多，保证双指针单向移动。
- **时间复杂度优化**：将暴力模拟的 `O(qn^2)` 优化为 `O(n log n + q log q)`。

**可视化设计**：  
- **动画效果**：用 Canvas 绘制排序后的数组，指针 `pos` 从左向右移动。
- **颜色标记**：当前指针位置高亮为红色，满足条件的区间标记为绿色。
- **音效触发**：每次指针移动时播放点击音效，找到答案时播放成功音效。
- **复古风格**：采用 8 位像素风格，背景为网格，数值以方块高度表示。

---

## 题解清单 (≥4星)
1. **AsunderSquall（5星）**  
   - 详细证明单调性与正确性，代码简洁高效，双指针实现清晰。
   - 关键亮点：严格的数学证明，代码逻辑与理论分析一致。

2. **xzyg（4星）**  
   - 离线排序询问，预处理后缀和，双指针处理每个询问。
   - 关键亮点：代码结构清晰，预处理部分优化明显。

3. **青鸟_Blue_Bird（4星）**  
   - 代码简洁，直接维护指针位置，无需复杂数据结构。
   - 关键亮点：对单调性的直观解释，代码可读性强。

---

## 最优思路与代码实现
### 核心代码片段
```cpp
// 排序数组并预处理后缀和
sort(a + 1, a + 1 + n);
for (int i = n; i >= 1; i--) sum[i] = sum[i + 1] + a[i];

// 离线处理询问，按 k 从大到小排序
sort(qry + 1, qry + q + 1, [](auto& x, auto& y) { return x.k > y.k; });

// 双指针处理
int pos = 1;
for (int i = 1; i <= q; i++) {
    while (pos <= n && a[pos] < (sum[pos] / (n - pos + 1.0) - qry[i].k)) pos++;
    ans[qry[i].id] = n - pos + 1;
}
```

### 完整代码（AsunderSquall 实现）
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100010
#define int long long
// ... (省略读入优化等辅助代码)

int T, n, q, a[N], sum[N], ans[N];
struct Query { int k, id; } qry[N];

void solve() {
    sort(a + 1, a + n + 1);
    for (int i = n; i >= 1; i--) sum[i] = sum[i + 1] + a[i];
    sort(qry + 1, qry + q + 1, [](auto& x, auto& y) { return x.k > y.k; });
    
    int pos = 1;
    for (int i = 1; i <= q; i++) {
        while (pos <= n && a[pos] < (1.0 * (sum[pos]) / (n - pos + 1) - qry[i].k)) 
            pos++;
        ans[qry[i].id] = n - pos + 1;
    }
}
```

---

## 同类型题与推荐题目
1. **P2678 跳石头**（贪心 + 二分）
2. **P1182 数列分段**（二分答案 + 贪心验证）
3. **P3743 kotori的设备**（二分答案 + 能量计算）

---

## 个人心得摘录
- **xzyg**：调试时发现初始化未清空导致错误，强调多测初始化的重要性。
- **Shirayuki_Yu**：最初错误使用 `ceil` 导致预处理错误，后修正为浮点比较。

---

## 可视化与游戏化设计
### 核心算法演示
1. **排序数组**：以像素方块高度表示数值大小，排序后从左到右递增。
2. **指针移动**：红色方块表示当前 `pos`，绿色区域为保留的区间。
3. **动态计算平均值**：在指针移动时，显示当前区间的平均值与阈值 `avg - k`。

### 复古游戏化实现
```javascript
// 伪代码示例：Canvas 绘制与音效
const canvas = document.getElementById("game-canvas");
const ctx = canvas.getContext("2d");
const beepSound = new Audio('data:audio/wav;base64,UklGRl9...'); // 8-bit 音效

function drawArray(arr, pos) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    arr.forEach((val, i) => {
        ctx.fillStyle = i >= pos ? '#0F0' : '#F00'; // 绿/红
        ctx.fillRect(i * 10, canvas.height - val, 8, val);
    });
}

function animate(pos) {
    drawArray(sortedArray, pos);
    beepSound.play();
    requestAnimationFrame(() => animate(pos + 1));
}
```

### 交互功能
- **速度调节**：滑动条控制动画速度（10ms~1000ms/帧）。
- **自动演示**：AI 模式按 `k` 降序自动运行，展示指针移动过程。
- **音效反馈**：每次指针移动触发音效，答案确定时播放胜利音效。

---
处理用时：89.66秒
# 题目信息

# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# AI分析结果



# 算法分类：并查集（种类/带权）

## 题解思路与核心难点

### 核心思路
1. **种类并查集**：将每个动物扩展为3个节点（同类、猎物、天敌），通过合并三个维度的集合维护三元关系。
2. **带权并查集**：通过权值（0:同类，1:吃父，2:被父吃）表示节点与根的关系，利用模3运算推导关系。

### 解决难点对比
| 方法            | 数据结构          | 合并逻辑                                                                 | 冲突判断条件                                                                 |
|-----------------|-------------------|--------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| 三倍并查集      | 3*n大小的并查集   | 同时合并同类、猎物、天敌三个维度                                         | 检查猎物/天敌维度的交集（如x的猎物是否与y同类）                              |
| 带权并查集      | 权值数组+父节点数组| 通过权值差计算合并后的关系：`rank[fx] = (rank[y]-rank[x]+offset) % 3`    | 检查权值差是否符合当前操作类型（如同类要求`rank[x] == rank[y]`）           |

---

## 高星题解推荐（≥4星）

### 1. Sooke（赞2066）⭐️⭐️⭐️⭐️⭐️
- **亮点**：三倍并查集图解清晰，适合初学者理解环形食物链关系。
- **代码**：通过`find(x), find(x+n), find(x+2n)`维护三个维度的合并。

### 2. 天泽龟（赞230）⭐️⭐️⭐️⭐️
- **亮点**：带权并查集数学推导详细，权值传递公式`rank[x]=(rank[x]+rank[fa[x]])%3`。
- **代码**：路径压缩时动态更新权值。

### 3. 檀黎斗·神（赞599）⭐️⭐️⭐️⭐️
- **亮点**：三倍并查集代码极简，`x, x+n, x+2n`分别表示自身、猎物、天敌。
- **代码**：仅50行，高效处理合并逻辑。

---

## 最优思路提炼
```python
# 三倍并查集核心代码
def merge(x, y, offset):
    # 合并同类、猎物、天敌三个维度
    fa[find(x)] = find(y)
    fa[find(x + n)] = find(y + n)
    fa[find(x + 2*n)] = find(y + 2*n)

# 带权并查集路径压缩
def find(x):
    if fa[x] != x:
        root = find(fa[x])
        rank[x] = (rank[x] + rank[fa[x]]) % 3
        fa[x] = root
    return fa[x]
```

---

## 类似题目推荐
1. **P1525 关押罪犯**（对立关系合并）
2. **P1196 银河英雄传说**（带权并查集）
3. **P1892 团伙**（扩展并查集处理敌人关系）

---

## 算法可视化设计（三倍并查集）

### 动画方案
1. **网格布局**：将每个动物分为三个区块（同类/绿，猎物/红，天敌/蓝）。
2. **合并高亮**：当合并x和y时，三组区块同步闪烁并连线。
3. **冲突检测**：若检测到矛盾（如x的猎物与y同类），显示红色警示框。

### 复古像素风格
- **8位音效**：
  - 合并时播放“哔”声（Web Audio API生成方波）。
  - 冲突时播放低音“嗡”声。
- **Canvas绘制**：使用16色像素块表示动物节点，路径压缩时显示路径箭头。

---

## 核心代码片段（带权并查集）
```javascript
// 路径压缩与权值更新
function find(x) {
    if (parent[x] !== x) {
        const root = find(parent[x]);
        rank[x] = (rank[x] + rank[parent[x]]) % 3;
        parent[x] = root;
    }
    return parent[x];
}

// 合并操作
function union(x, y, relation) {
    const fx = find(x), fy = find(y);
    if (fx === fy) return;
    parent[fx] = fy;
    rank[fx] = (relation + rank[y] - rank[x] + 3) % 3;
}
```

---

## 总结
两种方法均能高效解决环形关系问题：三倍并查集直观易实现，带权并查集空间更优但需数学推导。可视化时可结合动态权值计算与多维度合并演示，帮助理解复杂关系维护。

---
处理用时：78.85秒
# 题目信息

# [HAOI2009] 巧克力

## 题目描述

有一块 $n \times m$ 的矩形巧克力，准备将它切成 $n \times m$ 块。巧克力上共有 $n-1$ 条横线和 $m-1$ 条竖线，你每次可以沿着其中的一条横线或竖线将巧克力切开，无论切割的长短，沿着每条横线切一次的代价依次为 $y_1,y_2,\cdots,y_{n-1}$，而沿竖线切割的代价依次为 $x_1,x_2,\cdots,x_{m-1}$。

例如，对于下图 $6 \times 4$ 的巧克力，我们先沿着三条横线切割，需要 $3$ 刀，得到 $4$ 条巧克力，然后再将这 $4$ 条巧克力沿竖线切割，每条都需要 $5$ 刀，则最终所花费的代价为 $y_1+y_2+y_3+4 \times (x_1+x_2+x_3+x_4+x_5)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/juiv548x.png)


当然，上述简单切法不见得是最优切法，那么怎样切割该块巧克力，花费的代价最少呢？


## 说明/提示


$30\%$ 的数据，$n \leq 100,m \leq 100$；

$100\%$ 的数据，$n \leq 10000,m \leq 10000$；

## 样例 #1

### 输入

```
6 4
2
1
3
1
4
4
1
2```

### 输出

```
42```

# AI分析结果



# 算法分类
**贪心算法**

---

# 题解思路与核心分析

## **核心难点**
- **切割顺序影响总代价**：每次切割的代价会被后续切割的次数放大，需找到最优切割顺序。
- **贪心策略证明**：需证明优先选择当前代价最大的切割线能最小化总代价。

## **统一算法思路**
所有正确题解均采用以下步骤：
1. **合并切割线**：将横切与竖切的代价存入同一数组。
2. **排序**：按代价降序排列，保证每次选择当前最大代价的切割线。
3. **动态累加**：每次切割时，累加 `当前代价 × 另一方向已切割次数 + 1`，并更新切割次数。

## **关键变量与数据结构**
- `s1` 和 `s2`：分别记录横切和竖切的次数（初始值为1，表示初始未被切割的块数）。
- **优先队列/排序数组**：用于维护当前待处理的切割线。

---

# 题解评分（≥4星）

### 1. **题解作者：Tarsal（5星）**
- **亮点**：使用优先队列分离横竖切割，代码注释详细，逻辑清晰。
- **关键代码段**：
  ```cpp
  while (!q.empty() && !qq.empty()) {
    if (q.top() > qq.top()) {
        ans += q.top() * s2;
        s1++;
        q.pop();
    } else {
        ans += qq.top() * s1;
        s2++;
        qq.pop();
    }
  }
  ```

### 2. **题解作者：kkxhh（5星）**
- **亮点**：代码简洁，使用优先队列实现贪心，变量命名直观。
- **关键代码段**：
  ```cpp
  while (!q1.empty() && !q2.empty()) {
    if (q1.top() > q2.top()) {
        sum += q1.top() * s2;
        s1++;
        q1.pop();
    } else {
        sum += q2.top() * s1;
        s2++;
        q2.pop();
    }
  }
  ```

### 3. **题解作者：g_ws（4星）**
- **亮点**：结构体排序实现统一处理，适合大规模数据。
- **关键代码段**：
  ```cpp
  sort(a+1, a+n+m-1, cmp);
  for (i=1; i<=n+m-2; i++) {
    if(a[i].c==0) ans += a[i].v * s2, s1++;
    else ans += a[i].v * s1, s2++;
  }
  ```

---

# 最优思路提炼
**贪心策略**：将横切和竖切的代价统一降序排序，每次选择当前最大代价的切割线，累加其代价乘以另一方向已切割次数加1的值。

**数学证明**：假设当前最大横切代价为 $y_i$，竖切代价为 $x_j$，若 $y_i > x_j$，优先切割 $y_i$ 可避免后续切割次数放大 $x_j$。

---

# 类似题目与算法套路
- **P1324 矩形分割**：同样通过降序排序切割线，按贪心策略累加代价。
- **P1090 合并果子**：优先处理小代价，但贪心方向相反。
- **P1230 智力大冲浪**：按截止时间排序，贪心选择最优任务。

---

# 个人心得摘录
- **Tarsal**：调试中发现未处理队列空的情况，通过增加 `while` 循环修复。
- **kkxhh**：初始将 `s1` 和 `s2` 误设为0，导致计算结果错误，调整为1后通过。

---

# 可视化与算法演示

## **动画设计**
1. **像素化界面**：使用 8-bit 风格，巧克力网格用色块表示。
2. **切割高亮**：当前切割线以红色闪烁，切割后分裂为多个色块。
3. **动态数值面板**：显示 `s1`、`s2` 和累计代价，每次切割后更新。

## **交互设计**
- **自动模式**：按排序顺序自动执行切割，速度可调。
- **音效反馈**：切割时播放“切菜”音效，计算错误时播放低沉音效。
- **关卡模式**：将不同规模的数据设为关卡，通过后解锁更高难度。

---

# 核心代码示例（贪心实现）
```cpp
#include <algorithm>
#include <iostream>
using namespace std;

struct Cut { int cost, isVertical; };

bool cmp(Cut a, Cut b) { return a.cost > b.cost; }

int main() {
    int n, m;
    cin >> n >> m;
    Cut cuts[20010];
    // 读取横切和竖切代价，合并排序
    for (int i = 0; i < n-1; i++) cin >> cuts[i].cost;
    for (int i = n-1; i < n+m-2; i++) {
        cin >> cuts[i].cost;
        cuts[i].isVertical = 1;
    }
    sort(cuts, cuts + n+m-2, cmp);
    
    int s1 = 1, s2 = 1, ans = 0;
    for (int i = 0; i < n+m-2; i++) {
        if (cuts[i].isVertical) {
            ans += cuts[i].cost * s1;
            s2++;
        } else {
            ans += cuts[i].cost * s2;
            s1++;
        }
    }
    cout << ans;
    return 0;
}
```

---

**可视化效果示意**：
![贪心切割动画](https://via.placeholder.com/600x400/000000/FFFFFF/?text=贪心切割动态演示)  
（实际实现中，红色高亮线逐步切割巧克力，右侧面板显示实时数据。）

---
处理用时：95.28秒
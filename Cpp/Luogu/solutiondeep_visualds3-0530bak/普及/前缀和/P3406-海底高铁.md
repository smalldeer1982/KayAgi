# 题目信息

# 海底高铁

## 题目描述

该铁路经过 $N$ 个城市，每个城市都有一个站。不过，由于各个城市之间不能协调好，于是乘车每经过两个相邻的城市之间（方向不限），必须单独购买这一小段的车票。第 $i$ 段铁路连接了城市 $i$ 和城市 $i+1(1\leq i<N)$。如果搭乘的比较远，需要购买多张车票。第 $i$ 段铁路购买纸质单程票需要 $A_i$ 博艾元。

虽然一些事情没有协调好，各段铁路公司也为了方便乘客，推出了 IC 卡。对于第 $i$ 段铁路，需要花 $C_i$ 博艾元的工本费购买一张 IC 卡，然后乘坐这段铁路一次就只要扣 $B_i(B_i<A_i)$ 元。IC 卡可以提前购买，有钱就可以从网上买得到，而不需要亲自去对应的城市购买。工本费不能退，也不能购买车票。每张卡都可以充值任意数额。对于第 $i$ 段铁路的 IC 卡，无法乘坐别的铁路的车。

Uim 现在需要出差，要去 $M$ 个城市，从城市 $P_1$ 出发分别按照 $P_1,P_2,P_3,\cdots,P_M$ 的顺序访问各个城市，可能会多次访问一个城市，且相邻访问的城市位置不一定相邻，而且不会是同一个城市。

现在他希望知道，出差结束后，至少会花掉多少的钱，包括购买纸质车票、买卡和充值的总费用。

## 说明/提示

$2$ 到 $3$ 以及 $8$ 到 $9$ 买票，其余买卡。

对于 $30\%$ 数据 $M=2$。

对于另外 $30\%$ 数据 $N\leq1000，M\leq1000$。

对于 $100\%$ 的数据 $M,N\leq 10^5，A_i,B_i,C_i\le10^5$。

## 样例 #1

### 输入

```
9 10
3 1 4 1 5 9 2 6 5 3
200 100 50
300 299 100
500 200 500
345 234 123
100 50 100
600 100 1
450 400 80
2 1 10```

### 输出

```
6394```

# AI分析结果



## 算法分类选择
**差分数组、贪心**

---

## 题解思路、算法要点与解决难点

### 核心思路
1. **差分数组统计次数**：通过差分数组快速标记每段铁路的经过次数。对每段路径 `[x, y]`，在差分数组 `d[x]++` 和 `d[y]--`，最后通过前缀和计算实际次数。
2. **贪心比较费用**：对每段铁路的经过次数，选择买票或办卡中更优的方案。

### 解决难点
- **高效统计次数**：直接遍历路径会导致 `O(M*N)` 复杂度，差分数组将其优化至 `O(N+M)`。
- **方向处理**：路径可能从大编号到小编号城市，需交换端点确保差分正确。
- **数据类型溢出**：次数与费用的乘积可能超过 `int` 范围，需用 `long long`。

---

## 题解评分 (≥4星)

1. **NKU_AI_HMX（5星）**  
   - 思路用故事形象解释差分，代码简洁，逻辑清晰。  
   - 关键代码：差分标记与费用比较。

2. **kkksc03（5星）**  
   - 明确借用“借教室”思路，代码结构清晰。  
   - 示例图解直观展示差分数组前缀和。

3. **Sirius墨狼（4星）**  
   - 完整代码包含差分处理，强调 `long long` 的必要性。  
   - 附带调试经历，增强实用性。

---

## 最优思路或技巧提炼

1. **差分标记法**  
   - 对路径 `[x, y]`，无论方向，标记 `d[min(x,y)]++` 和 `d[max(x,y)]--`。  
   - 前缀和计算得到每段铁路的经过次数。

2. **贪心决策公式**  
   - 比较 `次数*A_i` 与 `次数*B_i + C_i`，取最小值累加。

---

## 同类型题推荐

1. **P3397 地毯**（二维差分）
2. **P1083 借教室**（差分+二分）
3. **P3406 海底高铁**（本题）

---

## 代码核心实现

```cpp
#include <iostream>
using namespace std;
using ll = long long;

int main() {
    int n, m;
    cin >> n >> m;
    int last, curr;
    cin >> last;
    ll cnt[n + 2] = {0}; // 差分数组
    
    for (int i = 2; i <= m; ++i) {
        cin >> curr;
        int l = min(last, curr);
        int r = max(last, curr);
        cnt[l]++;
        cnt[r]--;
        last = curr;
    }
    
    // 计算前缀和得每段次数
    ll sum = 0, ans = 0;
    for (int i = 1; i < n; ++i) {
        sum += cnt[i];
        ll a, b, c;
        cin >> a >> b >> c;
        ans += min(a * sum, b * sum + c);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 可视化与算法演示

### 动画设计
1. **差分标记步骤**  
   - **颜色高亮**：当前处理的路径区间显示为红色，差分数组的 `d[x]++` 和 `d[y]--` 用绿色闪烁。
   - **网格展示**：城市排列为横向网格，铁路段为相邻节点连线，经过次数用颜色深度表示。

2. **前缀和计算**  
   - **步进效果**：从左到右逐步累加差分值，当前累加位置用黄色箭头指示，结果实时更新。

3. **费用比较**  
   - **动态公式**：显示 `A_i * cnt` vs `B_i * cnt + C_i`，选中更优方案时弹出金币特效。

### 复古像素风格
- **8位音效**：路径标记时播放“滴”声，费用比较时播放“金币”音效。
- **Canvas动画**：城市用像素方块表示，铁路段为像素线条，差分标记用闪烁方块。

---

## 个人心得摘录

- **Sirius墨狼**：未使用 `long long` 导致 WA，强调数据范围的重要性。
- **chenxuanting**：调试三天后发现差分方向错误，提醒仔细处理端点交换。

---

## 相似题目推荐

1. **P2367 语言月赛**（差分数组统计）
2. **P2280 激光炸弹**（二维前缀和）
3. **P2879 区间统计**（差分+贪心）

---
处理用时：72.56秒
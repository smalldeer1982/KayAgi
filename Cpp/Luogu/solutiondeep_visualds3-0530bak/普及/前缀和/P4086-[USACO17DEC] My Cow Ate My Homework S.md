# 题目信息

# [USACO17DEC] My Cow Ate My Homework S

## 题目描述

在你的牛历史课上，你被布置了一份相当长的作业，包含 $N$ 个问题（$3 \leq N \leq 100,000$），每个问题的得分是一个在 0 到 10,000 之间的整数。按照惯例，你的老师计划通过去掉你得分最低的一个问题，然后对剩余问题的得分取平均来给出最终成绩。不幸的是，你的宠物奶牛 Bessie 刚刚吃掉了你前 $K$ 个问题的答案！（$K$ 可能小到 1，也可能大到 $N-2$）。

经过多次解释，你的老师终于相信了你的说法，并同意按照之前的方式对剩余的未被吃掉的部分作业进行评分——即去掉得分最低的问题（或在得分相同的情况下去掉其中一个），然后对剩余问题取平均。

请输出所有能够使你获得最高可能成绩的 $K$ 值，并按升序排列。

## 说明/提示

如果 Bessie 吃掉了前两个问题，那么剩余的得分是 9、2 和 7。去掉最低分并取平均后，最终成绩为 8，这是可能的最高成绩。

## 样例 #1

### 输入

```
5
3 1 9 2 7```

### 输出

```
2```

# AI分析结果



## 算法分类  
**后缀预处理（后缀最小值与后缀和）**

---

## 题解核心思路与难点分析  
### 核心算法流程  
1. **预处理后缀最小值**：从右向左遍历数组，记录每个位置到末尾的最小值。  
2. **预处理后缀和**：从右向左累加数组元素，记录每个位置到末尾的总和。  
3. **枚举所有可能的 K**：对每个 K，计算剩余区间的总和减去最小值后的平均值，记录最大值对应的 K。  

### 解决难点  
- **高效求区间最小值与和**：通过后缀预处理将每次查询的时间复杂度降为 O(1)。  
- **避免浮点精度问题**：用整数运算处理总和与最小值，最后再转换为浮点数比较。  

### 关键代码片段  
```cpp
// 预处理后缀最小值与和
for (int i = n; i >= 2; i--) {
    mn[i] = min(mn[i + 1], a[i]);
    sum[i] = sum[i + 1] + a[i];
    avr[i] = (sum[i] - mn[i]) / (n - i);
}

// 枚举 K 并比较最大值
double mx = 0;
for (int i = 2; i <= n - 1; i++) {
    mx = max(mx, avr[i]);
}
```

---

## 高星题解推荐（≥4星）  
### 5星：[作者：_jimmywang_](https://www.luogu.com.cn)  
**亮点**：  
- 代码简洁高效，时间复杂度 O(n)。  
- 预处理逻辑清晰，避免冗余计算。  

### 4星：[作者：Siyuan](https://www.luogu.com.cn)  
**亮点**：  
- 用单次遍历同时处理最小值和总和。  
- 动态更新最大值，减少内存占用。  

### 4星：[作者：TRZ_2007](https://www.luogu.com.cn)  
**亮点**：  
- 结合前缀和与后缀最小值，逻辑直观。  
- 明确处理浮点精度问题。  

---

## 最优思路提炼  
**核心技巧**：  
1. **后缀预处理**：从右向左预处理最小值和总和，将每次查询降为 O(1)。  
2. **边计算边比较**：在预处理过程中直接计算每个 K 的候选值，避免重复遍历。  

**可复用的思维模式**：  
- 当需要频繁查询某个区间的统计量（如最小值、总和）时，预处理后缀或前缀是常用优化手段。  

---

## 相似题目推荐  
1. [P2870 [USACO07DEC] Best Cow Line G](https://www.luogu.com.cn/problem/P2870)（贪心与后缀预处理）  
2. [P2216 [HAOI2007] 理想的正方形](https://www.luogu.com.cn/problem/P2216)（二维滑动窗口+最值预处理）  
3. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)（单调队列求区间最值）  

---

## 算法可视化设计  
### 动画方案  
1. **预处理阶段**：  
   - **像素风格界面**：用 8 位色块表示数组元素，绿色表示当前处理的位置，红色闪烁表示更新最小值。  
   - **动态填充**：从右向左逐个填充后缀最小值（显示为 `mn[i]`）和总和（显示为 `sum[i]`）。  

2. **枚举 K 阶段**：  
   - **高亮区间**：用黄色方框标记当前 K 对应的区间 `[K+1, N]`。  
   - **音效触发**：每次找到更大的平均值时播放“升级”音效，相同值时播放“确认”音效。  

### 交互功能  
- **步进控制**：允许暂停/继续，单步观察预处理和枚举过程。  
- **数据高亮**：鼠标悬停时显示当前 K 对应的最小值、总和和计算式。  

---

## 示例代码（核心逻辑）  
```javascript
// 伪代码：动画核心逻辑（Canvas 实现）
function visualize() {
    // 预处理动画
    for (let i = n; i >= 1; i--) {
        highlightCell(i, "green"); // 高亮当前处理位置
        updateMinAndSum(i);        // 更新 mn 和 sum 数组
        drawCellValue(i, mn[i]);   // 绘制最小值
        playSound("step");         // 步进音效
        wait(500);                 // 控制速度
    }

    // 枚举 K 动画
    let maxAvg = 0;
    for (let k = 1; k <= n - 2; k++) {
        const avg = (sum[k + 1] - mn[k + 1]) / (n - k - 1);
        highlightInterval(k + 1, n, "yellow"); // 高亮区间
        if (avg > maxAvg) {
            maxAvg = avg;
            playSound("success"); // 新最大值音效
        }
        wait(300);
    }
}
```

---

## 总结  
本题通过后缀预处理将时间复杂度优化到极致，是典型的“空间换时间”策略。同类问题中，预处理后缀/前缀的思维模式可优先考虑。可视化设计通过像素风格和音效增强理解，适合教学演示。

---
处理用时：71.54秒
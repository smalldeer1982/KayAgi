# 题目信息

# 「EZEC-14」众数 I

## 题目背景

pigstd 是一个可爱的男孩子。他在 NOI2022 中的众数一题定义了 $10^6$ 个 ``std::deque`` 并没有 MLE。

## 题目描述

给定一个长度为 $n$ 的序列 $a$，我们通过以下方式构造序列 $b$：

- 初始时 $b=a$。
- 依次对 $b$ 进行 $k$ 次操作，每次操作选择任意一个元素并将其**修改**为任意整数。

dXqwq 定义一个序列的**众数**为所有出现次数最大的数。例如 $[1,1,4,5,1,4]$ 的众数为 $1$，而 $[1,14,5,14,19,19,8,10]$ 的众数为 $14,19$。

你需要求出有多少整数可能成为 $b$ 的**众数**。

## 说明/提示

**【样例解释】**

对于第一组数据，最终 $1,2,3,4,5$ 可能为区间众数。

对于第二组数据，将第一个数换成 $6,7,8,9,\cdots$ 后它们均会成为区间众数，因此答案为正无穷。

对于第三组数据，$1,2,3$ 可能成为区间众数。

**【提示】**

开 $10^6$ 个 ``std::deque`` 在空间限制为 1024MB 时不一定会 MLE。

**【数据范围】**

**本题采用捆绑测试。**

* Subtask 1（20 pts）：$n\leq 5$。
* Subtask 2（20 pts）：$n\leq 10^3$。
* Subtask 3（20 pts）：$k=0$。
* Subtask 4（20 pts）：$k=1$。
* Subtask 5（20 pts）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n\leq 10^6$，$0\leq k\leq n $，$1\leq a_i\leq n$。

## 样例 #1

### 输入

```
5 0
1 2 3 4 5```

### 输出

```
5```

## 样例 #2

### 输入

```
5 1
1 2 3 4 5```

### 输出

```
pigstd```

## 样例 #3

### 输入

```
5 1
1 1 2 2 3```

### 输出

```
3```

# AI分析结果



---

## 唯一算法分类  
**贪心算法**

---

## 题解思路、算法要点与解决难点  

### 核心思路对比  
1. **二分法（ys_kylin__、StayAlone、CEFqwq）**  
   - **核心思想**：二分可能的众数出现次数下限，验证是否存在足够多的数满足条件。  
   - **解决难点**：  
     - `check` 函数需高效计算其他数超过当前阈值所需的调整次数。  
     - 前缀和优化（如 `sum` 数组）快速计算超限部分总和。  
   - **复杂度**：$O(n \log n)$，适用于大数据范围。  

2. **贪心优先队列（Light_az、ncwzdlsd、ZeroF）**  
   - **核心思想**：用优先队列模拟每次操作，将最大值逐步削减 $k$ 次，得到最终最大出现次数。  
   - **解决难点**：  
     - 维护堆顶动态调整，处理可能出现的无穷解（当堆顶 $\le k$）。  
   - **复杂度**：$O(n + k \log n)$，当 $k \le n$ 时高效。  

3. **前缀和快速计算（dead_X、船酱魔王）**  
   - **核心思想**：排序后统计前缀和，快速计算所有数超过 $x$ 的总调整次数。  
   - **解决难点**：  
     - 利用单调性优化遍历过程（如指针跳跃）。  
   - **复杂度**：$O(n)$，效率最高。  

---

## 题解评分（≥4星）  

1. **dead_X（5星）**  
   - **亮点**：  
     - 前缀和实现 $O(n)$ 复杂度，代码简洁高效。  
     - 直接遍历排序后的出现次数数组，避免复杂数据结构。  

2. **ys_kylin__（4星）**  
   - **亮点**：  
     - 二分思路清晰，`check` 函数利用桶计数优化逻辑。  
     - 处理无穷解和边界条件明确。  

3. **Light_az（4星）**  
   - **亮点**：  
     - 优先队列模拟操作直观易懂，适合理解贪心策略。  
     - 代码可读性强，附带调试案例辅助理解。  

---

## 最优思路或技巧提炼  

1. **前缀和快速验证**  
   - 将出现次数排序后，统计前缀和数组 `sum`。  
   - 对每个候选值 $x$，用 `upper_bound` 找到所有超过 $x$ 的数，计算总调整次数：  
     $$\text{总调整次数} = \sum_{s_i > x} s_i - x \cdot \text{数量}$$  
   - 判断总调整次数是否 $\le k$，即可确定 $x$ 是否可行。  

2. **贪心维护最大出现次数**  
   - 使用优先队列动态维护当前最大出现次数。  
   - 每次操作取出堆顶减一，重复 $k$ 次后堆顶即为最终最大出现次数。  
   - 遍历所有数，若其出现次数 $+k \ge$ 堆顶值，则可能成为众数。  

---

## 同类型题或类似算法套路  

1. **众数问题变种**  
   - 如 LeetCode 169（多数元素）、229（求所有出现次数超过 $n/3$ 的元素）。  
   - 常用技巧：摩尔投票法、出现次数统计。  

2. **操作次数限制问题**  
   - 如 CodeForces 1526C2（用堆维护可撤销操作）。  
   - 核心思路：贪心调整，优先处理影响最大的元素。  

---

## 推荐相似题目  

1. **P3964 [TJOI2013]松鼠聚会**（众数与距离计算结合）  
2. **P2397 yyy loves Maths VI (mode)**（摩尔投票法求众数）  
3. **CF1203F2 Complete the Projects (hard version)**（贪心调整操作顺序）  

---

## 个人心得摘录  

1. **Light_az**：  
   - “贪心操作后，发现代码快的飞起（汗）”，强调实践验证的重要性。  
2. **fish_love_cat**：  
   - “40分思路错在将修改误解为仅增加次数，未考虑削减其他数的出现次数。”，提醒审题需细致。  

---

## 可视化与算法演示  

### 核心算法流程（前缀和法）  
1. **输入数据**：显示原始数组的桶计数直方图（8位像素风格）。  
2. **排序出现次数**：将桶计数从高到低排序，动态绘制排序过程。  
3. **前缀和计算**：用颜色标记每个前缀和块，逐步填充数组。  
4. **验证候选值**：  
   - 滑动条调整候选值 $x$，高亮所有超过 $x$ 的柱状图。  
   - 显示总调整次数的计算公式和结果，对比 $k$ 值。  

### 复古游戏化设计  
- **像素风格**：  
  - 使用16色调色板，绿色表示当前候选值，红色表示超限部分。  
- **音效设计**：  
  - 每次调整候选值时播放“滴”声，验证通过时播放“成功”音效。  
- **自动演示模式**：  
  - AI自动遍历候选值，动态展示验证过程，类似贪吃蛇AI路径规划。  

### 代码片段（Canvas绘制核心逻辑）  
```javascript
// 伪代码：绘制排序后的出现次数直方图  
function drawHistogram(ctx, data, x) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  data.forEach((cnt, i) => {
    const color = cnt > x ? '#FF5555' : '#55FF55'; // 超限部分红色  
    ctx.fillStyle = color;
    ctx.fillRect(i * 10, canvas.height - cnt * 5, 8, cnt * 5);
  });
}
```

---

## 结论  
最优解法为 **前缀和快速验证**，时间复杂度 $O(n)$，代码简洁高效。核心思路是排序后统计超限部分总和，直接判断可行性。可视化设计可结合排序和前缀和计算过程，用像素动画直观展示验证逻辑。

---
处理用时：86.45秒
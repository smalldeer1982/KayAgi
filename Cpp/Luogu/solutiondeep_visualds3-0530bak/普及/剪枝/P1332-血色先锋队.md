# 题目信息

# 血色先锋队

## 题目背景

巫妖王的天灾军团终于卷土重来，血色十字军组织了一支先锋军前往诺森德大陆对抗天灾军团，以及一切沾有亡灵气息的生物。孤立于联盟和部落的血色先锋军很快就遭到了天灾军团的重重包围，现在他们将主力只好聚集了起来，以抵抗天灾军团的围剿。可怕的是，他们之中有人感染上了亡灵瘟疫，如果不设法阻止瘟疫的扩散，很快就会遭到灭顶之灾。大领主阿比迪斯已经开始调查瘟疫的源头。原来是血色先锋军的内部出现了叛徒，这个叛徒已经投靠了天灾军团，想要将整个血色先锋军全部转化为天灾军团！无需惊讶，你就是那个叛徒。在你的行踪败露之前，要尽快完成巫妖王交给你的任务。

## 题目描述

军团是一个 $n$ 行 $m$ 列的矩阵，每个单元是一个血色先锋军的成员。感染瘟疫的人，每过一个小时，就会向四周扩散瘟疫，直到所有人全部感染上瘟疫。你已经掌握了感染源的位置，任务是算出血色先锋军的领主们感染瘟疫的时间，并且将它报告给巫妖王，以便对血色先锋军进行一轮有针对性的围剿。

## 说明/提示

#### 输入输出样例 1 解释

如下图，标记出了所有人感染瘟疫的时间以及感染源和领主的位置。

![](https://cdn.luogu.com.cn/upload/image_hosting/3j3g02cn.png)

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n,m\le500$，$1\le a,b\le10^5$。

## 样例 #1

### 输入

```
5 4 2 3
1 1
5 4
3 3
5 3
2 4
```

### 输出

```
3
1
3```

# AI分析结果



**算法分类**：多源广度优先搜索（BFS）

---

### **题解思路与核心难点**
1. **核心逻辑**  
   - **多源BFS**：将所有感染源作为初始起点，同时加入队列进行扩散，每个位置的感染时间为其首次被访问的步数。  
   - **曼哈顿距离暴力法**：直接计算每个领主到所有感染源的曼哈顿距离，取最小值作为答案。

2. **算法对比与难点**  
   - **暴力法**（qianfujia、liuqy）：  
     - **优点**：代码简单，无需复杂数据结构。  
     - **缺点**：时间复杂度为 O(A*B)，无法通过 A/B=1e5 的极端数据。  
     - **关键变量**：`maxx[i]` 记录第 i 个领主的最小感染时间。  
   - **多源BFS**（llzzxx712、sinsop90）：  
     - **优点**：时间复杂度 O(N*M)，适合大规模网格。  
     - **难点**：需正确初始化队列（所有感染源同时入队），标记已访问节点，避免重复计算。  
     - **关键变量**：`map[x][y]` 存储每个位置的感染时间，`vis[x][y]` 标记是否已感染。

---

### **题解评分（≥4星）**
1. **qianfujia（暴力法）**  
   - **评分**：★★★☆☆  
   - **亮点**：代码极简，适用于小数据；曼哈顿距离计算巧妙。  
   - **缺点**：数据量大时超时。

2. **llzzxx712（多源BFS）**  
   - **评分**：★★★★☆  
   - **亮点**：标准多源BFS实现，注释清晰；通过队列实现层次遍历。  
   - **优化点**：队列使用数组而非STL，提升效率。

3. **sinsop90（多源BFS）**  
   - **评分**：★★★★☆  
   - **亮点**：结构体封装队列节点，支持步数记录；处理多个感染源时直接入队。  
   - **个人心得**：强调感染源需同时入队，避免逐个处理。

---

### **最优思路与技巧提炼**
1. **多源BFS核心流程**  
   ```cpp
   // 初始化队列（所有感染源入队）
   for (感染源 (x, y)) {
       queue.push({x, y, 0});
       vis[x][y] = true;
   }
   // BFS扩散
   while (!queue.empty()) {
       auto [x, y, step] = queue.front();
       for (四个方向) {
           int nx = x + dx[i], ny = y + dy[i];
           if (nx越界 || ny越界 || vis[nx][ny]) continue;
           vis[nx][ny] = true;
           map[nx][ny] = step + 1;
           queue.push({nx, ny, step + 1});
       }
   }
   ```

2. **关键优化点**  
   - **队列初始化**：所有感染源需同时入队，保证层级同步。  
   - **标记访问**：避免重复计算，每个节点仅首次访问时记录最短时间。  
   - **空间压缩**：使用二维数组直接存储时间，无需额外数据结构。

---

### **同类题目推荐**
1. **P1443 马的遍历**：单源BFS计算棋盘最短路径。  
2. **P1162 填涂颜色**：多源扩散标记连通区域。  
3. **P1135 奇怪的电梯**：BFS处理状态转移问题。

---

### **可视化设计（多源BFS）**
1. **动画方案**  
   - **颜色标记**：感染源为红色，已感染区域渐变为橙色，未感染为灰色。  
   - **扩散效果**：每一步显示队列扩展边界，动态更新领主感染时间。  
   - **步进控制**：支持暂停/继续，拖动进度条观察扩散过程。

2. **复古像素风格**  
   - **8位调色板**：红色（#FF0000）、橙色（#FFA500）、灰色（#808080）。  
   - **音效设计**：扩散时播放“滴”声，领主感染时播放“叮”声。  
   - **Canvas绘制**：网格化渲染，每个格子代表一个矩阵单元。

---

### **核心代码实现**
```cpp
// 多源BFS核心代码（llzzxx712 题解优化版）
#include<bits/stdc++.h>
using namespace std;
const int dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};
int n, m, a, b, map[505][505];
bool vis[505][505];
queue<tuple<int, int, int>> q;

void bfs() {
    while (!q.empty()) {
        auto [x, y, step] = q.front(); q.pop();
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx < 1 || ny < 1 || nx > n || ny > m || vis[nx][ny]) 
                continue;
            vis[nx][ny] = true;
            map[nx][ny] = step + 1;
            q.emplace(nx, ny, step + 1);
        }
    }
}

int main() {
    cin >> n >> m >> a >> b;
    memset(map, 0x3f, sizeof(map));
    while (a--) {
        int x, y; cin >> x >> y;
        q.emplace(x, y, 0);
        map[x][y] = 0;
        vis[x][y] = true;
    }
    bfs();
    while (b--) {
        int x, y; cin >> x >> y;
        cout << map[x][y] << endl;
    }
    return 0;
}
```

---

**总结**：多源BFS是本题的最优解，兼顾时间效率和代码简洁性，暴力法仅适用于小数据场景。可视化设计通过动态扩散和复古风格增强理解，同类题目可举一反三。

---
处理用时：72.91秒
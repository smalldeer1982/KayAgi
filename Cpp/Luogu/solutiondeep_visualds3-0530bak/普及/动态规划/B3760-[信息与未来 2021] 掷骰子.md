# 题目信息

# [信息与未来 2021] 掷骰子

## 题目背景

骰子是一个正六面体（立方体），每一面上有圆点表示的数字（圆点的数量表示数字的大小）。一个普通的骰子的六个面上分别有 $1\sim 6$ 这 $6$ 个不同的数字：

![](https://cdn.luogu.com.cn/upload/image_hosting/unawcttj.png)

## 题目描述

但是今天你得到了一个特殊的骰子，虽然每个面上的数字依然是 $1\sim 6$ 之间的一个，但不同面上的数字却可能重复。为了还原骰子上的数字，你使用摄像头从不同角度拍摄了多张骰子的照片（骰子可能在空间中任意翻转）。但限于摄像头的角度，你拍摄的每张照片都只能拍到骰子的三个面。

你需要根据摄像头拍摄到的多张照片，推断出骰子每个面上可能的数字。

## 说明/提示

### 样例解释
#### 样例 $1$
我们知道骰子上至少有三个 $1$、两个 $2$。剩下的数字可能是 $1$ 也可能是 $6$。

#### 样例 $2$
这是一个“普通”的骰子，$1\sim 6$ 这些数字恰好出现⼀次。

对于 $20\%$ 的数据，$0\le n\leq 1$。

对于 $100\%$ 的数据，$0\leq n\leq 20$。

>本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
2
1 1 1
2 2 1```

### 输出

```
8 13```

## 样例 #2

### 输入

```
2
1 2 3
4 5 6```

### 输出

```
21 21```

# AI分析结果



## 算法分类  
**暴力枚举**

---

## 题解思路与解决难点  
### 核心思路
1. **暴力枚举**：骰子共有 6 个面，每个面可填 1~6，遍历所有可能的骰子组合（共 $6^6=46656$ 种）。
2. **条件验证**：对每个骰子组合，验证其是否满足所有照片的拍摄约束：
   - 每张照片的三个数字必须对应骰子某一顶点的三个相邻面。
   - 需考虑骰子的旋转情况（通过轮换三个数字顺序覆盖不同视角）。

### 解决难点  
1. **立方体空间关系的数学建模**：需将照片中的三个面映射到骰子的三个相邻面，需理解立方体顶点与相邻面关系。
2. **旋转覆盖**：每张照片的三个数字可能对应同一顶点的不同旋转排列，需通过轮换顺序（如 `x,y,z` → `y,z,x` → `z,x,y`）覆盖所有可能视角。
3. **时间复杂度优化**：虽然枚举量固定（$6^6$），但需高效判断条件。两种实现思路：
   - **顶点预定义法**（沉石鱼惊旋）：预定义每个面的相邻面数组，直接验证排列组合。
   - **轮换顺序法**（ztd___）：通过轮换三个数字顺序模拟旋转，覆盖所有可能的顶点视角。

---

## 题解评分  
### ztd___（★★★★☆）
- **亮点**：六层循环逻辑清晰，通过轮换顺序覆盖旋转，代码可读性高。
- **不足**：重复代码较多（需三次轮换判断）。
- **心得**：通过手绘展开图理解顶点关系，修正旋转遗漏问题。

### 沉石鱼惊旋（★★★★☆）
- **亮点**：预定义相邻面数组，系统化验证条件，减少冗余判断。
- **不足**：需提前理解立方体展开图的几何关系。
- **心得**：通过数据验证正确性，强调手算与代码结合的重要性。

---

## 最优思路提炼  
1. **暴力枚举框架**：六层循环枚举骰子六个面的数字。
2. **旋转覆盖技巧**：对每张照片的三个数字进行轮换（如 `x,y,z` → `y,z,x` → `z,x,y`），覆盖所有可能的顶点视角。
3. **条件验证核心逻辑**：
   ```cpp
   bool check(int a, int b, int c, int d, int e, int f) {
       for (每张照片) {
           X = x[i], Y = y[i], Z = z[i];
           // 检查是否匹配 8 种顶点组合
           if (a==X && b==Y && d==Z) continue;
           ...
           // 轮换顺序后再次检查
           X = y[i], Y = z[i], Z = x[i];
           if (a==X && b==Y && d==Z) continue;
           ...
           return false;
       }
       return true;
   }
   ```

---

## 同类型题与算法套路  
1. **暴力枚举+几何建模**：如 [NOIP2004 提高组] 虫食算、[LeetCode 794] 有效的井字游戏。
2. **状态空间搜索**：如八皇后问题、数独求解。

---

## 推荐题目  
1. **P1211 [USACO1.5] 回文质数**（暴力枚举素数）  
2. **P1036 [NOIP2002 普及组] 选数**（组合枚举与素数判断）  
3. **P1443 马的遍历**（BFS 与状态空间搜索）

---

## 个人心得摘录  
> "建议拿一张纸折一下看看，实在不行也要画一下。如果你是立体几何大蛇就当我没说。"  
> —— ztd___ 强调通过实物辅助理解空间关系。

> "经过手玩可以发现骰子可以转成下面的样子。"  
> —— 沉石鱼惊旋 通过手算与代码结合验证数据正确性。

---

## 可视化与算法演示  
### 动画方案设计  
1. **像素化骰子展开图**：用 Canvas 绘制 8 位风格的立方体展开图，六个面用不同颜色标记当前枚举值。
2. **高亮当前检查面**：在验证某张照片时，用闪烁效果高亮匹配的三个面。
3. **轮换动画**：展示 `x,y,z` → `y,z,x` → `z,x,y` 的轮换过程，模拟骰子旋转。
4. **音效与积分**：  
   - **成功音效**：找到合法骰子时播放 8-bit 胜利音效。  
   - **连击积分**：连续找到多个合法组合时增加连击数，积分影响背景音乐节奏。

### 关键代码片段（JS）  
```javascript
// 骰子枚举动画
function animateDice(a, b, c, d, e, f) {
    drawCube(a, b, c, d, e, f); // 绘制当前骰子
    for (let photo of photos) {
        highlightPhoto(photo); // 高亮当前照片
        let valid = checkRotation(a, b, c, d, e, f, photo);
        if (!valid) {
            playSound('error'); // 错误音效
            return;
        }
    }
    playSound('success'); // 成功音效
    updateScore(a + b + c + d + e + f);
}
```

---

## 完整代码参考（ztd___ 题解）  
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, x[50], y[50], z[50];
bool check(int a, int b, int c, int d, int e, int f) {
    for (int i = 1; i <= n; i++) {
        int X = x[i], Y = y[i], Z = z[i];
        if (a == X && b == Y && d == Z) continue;
        if (c == X && b == Y && a == Z) continue;
        if (b == X && e == Y && d == Z) continue;
        if (c == X && e == Y && b == Z) continue;
        if (e == X && f == Y && d == Z) continue;
        if (a == X && d == Y && f == Z) continue;
        if (c == X && f == Y && e == Z) continue;
        if (f == X && c == Y && a == Z) continue;
        X = y[i], Y = z[i], Z = x[i];
        // 重复上述判断（共三次轮换）
        ...
        if (f == X && c == Y && a == Z) continue;
        return 0;
    }
    return 1;
}
signed main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> x[i] >> y[i] >> z[i];
    int minx = 1e18, maxx = -1e18;
    // 六层循环枚举骰子
    for (int a = 1; a <= 6; a++)
        for (int b = 1; b <= 6; b++)
            ... // 其余四层循环
                if (check(a, b, c, d, e, f)) {
                    int s = a + b + c + d + e + f;
                    minx = min(s, minx), maxx = max(s, maxx);
                }
    cout << minx << " " << maxx;
    return 0;
}
```

---
处理用时：94.93秒
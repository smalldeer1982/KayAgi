# 题目信息

# [NICA #1] 上大分

## 题目背景

小 T 喜欢打 CF。

## 题目描述

小 T 获得了预知能力，能预知自己后面 $n$ 场比赛的表现分。

下面是表现分的定义：

- 记小 T 在参加这场比赛前账号的分数是 $i$，他这场的表现分为 $j$，那么打完这场之后他的账号分数是 $i+\lfloor\frac{j-i}{4}\rfloor$ 。
- 其中 $\lfloor x\rfloor$ 表示对 $x$ 下取整，如 $\lfloor 1.9\rfloor=1,\lfloor -1.3\rfloor=-2$。

但是小 T 只有一个账号，初始分数是 $x$。他决定从未来的 $n$ 次比赛中选择**不超过** $k$ 次参加，同时，这些比赛的类型不同，具体分为两类，这些类型会给出：

- division 1：不管小 T **当前的分数**是多少，都可以参加。
- division 2：只有小 T **当前的分数** $< 1900$，他才能参加。
- 注意，**当前的分数**为这次比赛前的分数，而不是初始分数。**当前的分数**会随着小 T 之前选择参加比赛的策略变动而变动。

他希望自己在所有比赛结束后得分最高，请你来帮他规划一下，在最优决策下，参加完选出的比赛后能获得的最高分数是多少。



## 说明/提示

#### 【样例解释 2】

两场都打。

#### 【数据范围】

对于 $100\%$ 的数据，满足 $0\leq x,a_i\leq 4000$，$n,k\leq 5000$，$1\leq k\leq n$。

## 样例 #1

### 输入

```
2 2 1900
2 1899
2 4000```

### 输出

```
1900```

## 样例 #2

### 输入

```
2 2 1900
1 1899
2 4000```

### 输出

```
2424```

# AI分析结果



**唯一算法分类**：线性DP

---

### 题解思路与核心难点
**核心思路**：通过动态规划将分数作为状态，维护达到该分数所需的最少比赛次数。利用分数上限 4000 的特性，将状态压缩至一维数组，实现高效转移。

**算法要点**：
1. **状态设计**：`dp[i]` 表示达到分数 `i` 所需的最少比赛次数。
2. **转移方程**：对每场比赛，分两种情况计算转移后的分数：
   - 当前分数 `j > 表现分 a`：新分数为 `j - (j - a + 3) / 4`（向下取整处理）。
   - 当前分数 `j ≤ 表现分 a`：新分数为 `j + (a - j) / 4`。
3. **类型限制**：Div.2 比赛要求当前分数 `<1900`，设置遍历上限 `m=1899`；Div.1 无限制，`m=4000`。

**解决难点**：
- **分数变化的精确计算**：通过数学变形处理负数取整，避免浮点运算误差。
- **状态转移顺序**：分两次循环处理不同分数区间，确保转移不互相干扰。

---

### 最优题解评分（≥4星）
1. **MTFlowCzq（5星）**  
   - **亮点**：状态设计简洁，转移逻辑清晰，代码实现高效。
   - **代码**：使用滚动数组优化，正确处理分数计算和类型限制。

2. **Zheng_iii（4星）**  
   - **亮点**：明确解释转移方程数学推导，代码注释详细。
   - **优化**：通过临时变量避免状态覆盖，逻辑更易理解。

3. **CEFqwq（4星）**  
   - **亮点**：代码可读性强，加入详细注释和边界处理。
   - **特色**：补充调试细节，适合新手理解。

---

### 最优代码实现
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n, k, x, dp[4009];

int main() {
    cin >> n >> k >> x;
    fill(dp, dp + 4001, 1e9); // 初始化为极大值
    dp[x] = 0; // 初始分数无需比赛
    
    while (n--) {
        int type, a, m = 4000;
        cin >> type >> a;
        if (type == 2) m = 1899; // Div.2 分数上限
        
        // 处理 j > a 的情况
        for (int j = a + 1; j <= m; j++) {
            int new_score = j - (j - a + 3) / 4; // 精确计算向下取整
            dp[new_score] = min(dp[new_score], dp[j] + 1);
        }
        
        // 处理 j ≤ a 的情况
        for (int j = min(m, a - 1); j >= 0; j--) {
            int new_score = j + (a - j) / 4;
            dp[new_score] = min(dp[new_score], dp[j] + 1);
        }
    }
    
    // 寻找最大可行分数
    for (int i = 4000; i >= 0; i--) {
        if (dp[i] <= k) {
            cout << i;
            return 0;
        }
    }
    return 0;
}
```

---

### 可视化设计要点
1. **动画方案**：  
   - 将 DP 数组以网格形式展示，每个格子表示分数和对应的最少比赛次数。
   - **高亮变化**：更新分数时用绿色高亮新状态，红色标记不可行状态。
   - **步进控制**：支持暂停/继续，单步观察每场比赛的转移过程。

2. **复古像素风格**：  
   - **颜色方案**：8-bit 色调，分数格使用蓝-黄渐变，比赛场次用红-白闪烁。
   - **音效**：转移时播放“哔”声，找到答案时播放胜利音效。

3. **AI 自动演示**：  
   - 自动按顺序处理比赛，动态显示分数转移路径。
   - 最终答案以像素爆炸特效突出显示。

---

### 类似题目推荐
1. **P1048 采药**（0-1背包）  
2. **P1616 疯狂的采药**（完全背包）  
3. **P1064 金明的预算方案**（依赖背包）

---

**总结**：本题通过逆向状态设计巧妙处理分数限制，利用线性 DP 在有限分数范围内高效求解。核心在于分区间处理转移，正确计算向下取整，最终在 O(n·4000) 复杂度内完成。

---
处理用时：177.31秒
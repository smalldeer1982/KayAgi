# 题目信息

# [CSP-X2023 山东] 赚钱

## 题目描述

小 A 很喜欢旅游，他的国家共有 $n$ 个城市，编号依次为 $1$ 到 $n$，这个暑假小 A 打算从 $1$ 号城市开始按编号从小到大依次旅游完所有的城市，最后达到 $n$ 号城市，而且他不走回头路，每个城市只走一次。

小 A 很聪明，在没出发之前，他已经了解到，每个城市都有他喜欢的小熊纪念品，但是每个城市的价格却不完全一样（在同一个城市买入和卖出一个小熊纪念品的价格相同），于是小 A 打算从经过的某一个城市 $x$ 买一个纪念品，然后在后面经过的某个城市 $y$ 卖掉，从而赚取其中的差价。**但是他必须在某个城市买 $1$ 次，而且只能买 $1$ 个，并且一定要在后面的某个城市卖掉（不能在同一个城市先买入后再卖出）**，因为他家里已经有很多小熊纪念品了。

如，$2$ 号城市的纪念品价格是 $10$ 元，$6$ 号城市的纪念品是 $8$ 元，$10$ 号城市的纪念品是 $18$ 元，假设小 A 在 $2$ 号城市花 $10$ 元钱买了一个纪念品，如果在 $6$ 号城市卖掉他就亏了 $2$ 元（赚 $-2$ 元），如果在 $10$ 号城市卖，他就会赚 $8$ 元。

小 A 希望赚的钱越多越好。

问：小 A 最多能赚多少钱（当然也有可能亏钱）？

## 说明/提示

对于 $30\%$ 的数据：$n\le 1000$。

对于 $100\%$ 的数据：$2\le n\le 2\times 10^5$，$0\lt a_i\le 2\times 10^9$。

## 样例 #1

### 输入

```
5
2 1 6 8 4```

### 输出

```
7```

## 样例 #2

### 输入

```
6
10 8 7 5 3 1```

### 输出

```
-1```

# AI分析结果



### 唯一算法分类
**贪心算法**

---

### 题解思路、算法要点与解决难点

#### 核心思路
- **贪心策略**：对于每个卖出城市 `i`，其最优买入点是之前的最小价格。维护一个变量 `mina` 记录遍历到当前位置时的最小价格，每次计算 `a[i] - mina` 更新最大差值 `ans`。
- **时间复杂度优化**：从暴力枚举的 `O(n²)` 优化为 `O(n)`，通过单次遍历动态维护最小值。
- **关键变量**：
  - `mina`：记录当前遍历到位置的最小价格（买入价）
  - `ans`：记录全局最大差价（卖出价 - 买入价）

#### 解决难点
1. **贪心正确性证明**：  
   当卖出点为 `i` 时，若 `mina` 是 `1~i-1` 中的最小值，则 `a[i]-mina` 必然是 `i` 能获得的最大利润。  
2. **边界处理**：  
   必须保证卖出在买入之后，初始化 `mina` 为第一个元素，从第二个元素开始计算差价。  
3. **负数处理**：  
   答案可能为负（如样例2），需将 `ans` 初始化为极小值（如 `-1e18`）。

---

### 题解评分 (≥4星)

1. **Temp113 的题解（5星）**  
   - **亮点**：代码简洁高效，直接动态维护最小值与最大差价；数据初始化合理，处理了负数情况。  
   - **代码片段**：  
     ```cpp
     for(int i = 1; i <= n; i++){
         scanf("%lld", &a);
         ans = max_(ans, a - mina);
         mina = min_(mina, a);
     }
     ```

2. **songge888 的题解（4星）**  
   - **亮点**：明确说明贪心正确性，代码与思路对应清晰；使用 `INF` 合理初始化变量。  
   - **关键注释**：  
     ```cpp
     ans = max(ans, a[i] - mi); // 维护答案
     mi = min(mi, a[i]);        // 维护最小值
     ```

3. **RenZhen1 的题解（4星）**  
   - **亮点**：对比暴力与优化思路，帮助理解算法改进；代码逻辑清晰。  
   - **代码片段**：  
     ```cpp
     int minx = a[1], maxx = -2e9;
     for(int i=2; i<=n; i++){
         maxx = max(maxx, a[i] - minx);
         minx = min(minx, a[i]);
     }
     ```

---

### 最优思路或技巧提炼

- **动态维护最小值**：遍历数组时，每一步更新当前最小值 `mina`，利用贪心思想保证每个卖出点的最优买入价。  
- **单次遍历解决**：无需预处理或复杂数据结构，仅需 `O(1)` 空间和 `O(n)` 时间。  
- **代码实现技巧**：  
  - 初始化 `ans` 为极小值（如 `-1e18`），确保正确处理全亏损情况。  
  - 使用 `long long` 避免溢出。

---

### 同类型题或类似算法套路

1. **最大子数组和（LeetCode 53）**  
   - **相似点**：动态维护当前最优值（当前子数组和）。  
2. **买卖股票的最佳时机（LeetCode 121）**  
   - **相同思路**：维护历史最低价，计算当前最大利润。  
3. **滑动窗口最大值（LeetCode 239）**  
   - **关联性**：通过维护窗口极值优化时间复杂度。

---

### 推荐洛谷题目

1. **P1217 买卖股票的最佳时机**  
   - **考察点**：单次交易最大利润，与本题完全相同。  
2. **P1115 最大子段和**  
   - **关联性**：动态维护当前最优值的经典问题。  
3. **P1886 滑动窗口 /【模板】单调队列**  
   - **拓展性**：学习维护区间极值的高效方法。

---

### 个人心得摘录

- **Debug 教训**：  
  > “不开 `long long` 见祖宗”（Xiaonao_Dali）——数据范围较大时必须使用 `long long`。  
- **代码优化**：  
  > “预处理后缀最大值数组，但不如动态维护简洁”（FJ_EYoungOneC）——空间换时间需权衡。

---

### 可视化与算法演示

#### 核心算法流程
1. **初始化**：`mina = a[0]`, `ans = -INF`。  
2. **遍历数组**：  
   - 对每个 `a[i]`，计算 `a[i] - mina` 并更新 `ans`。  
   - 更新 `mina = min(mina, a[i])`。  

#### 动画设计
- **颜色标记**：  
  - **红色**：当前遍历的元素 `a[i]`。  
  - **绿色**：历史最小值 `mina`。  
  - **黄色**：当前计算的差价 `a[i] - mina`。  
- **步进控制**：支持暂停、单步执行、调整速度（如 1x/2x/5x）。  

#### 复古像素风格实现
- **Canvas 绘制**：  
  - 每个元素显示为像素块，高度表示价格。  
  - 当前元素闪烁红色，历史最小值块显示绿色边框。  
- **音效**：  
  - **差价更新**：播放“金币音效”（若利润增加）。  
  - **最小值更新**：播放“点击音效”。  
- **自动演示模式**：  
  - AI 自动遍历数组，高亮关键步骤，配背景音乐（8-bit 风格）。

---

### 代码片段（核心逻辑）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

signed main() {
    int n, a, mina = 1e18, ans = -1e18;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a;
        if (i > 0) ans = max(ans, a - mina);
        mina = min(mina, a);
    }
    cout << ans << endl;
    return 0;
}
```

---

### 总结
本题通过贪心策略动态维护最小值，将时间复杂度优化至 `O(n)`，是典型的最优子问题分解。可视化设计可通过像素动画和音效增强理解，适合作为贪心算法教学的经典案例。

---
处理用时：91.97秒
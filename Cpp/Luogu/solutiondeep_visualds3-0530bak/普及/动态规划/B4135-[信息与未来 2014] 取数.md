# 题目信息

# [信息与未来 2014] 取数

## 题目描述

有 $n$ 个数排成一排，从 $n$ 个数中任取若干个数，取数规则为每次取相邻的 $2$ 个数，不能取 $1$ 个，也不能取多于 $2$ 个连续的数，找一种取法，使取到数的和为最大。

## 说明/提示

$2\le n\le 10^5,1\le x_i\le 10^9$。

## 样例 #1

### 输入

```
6
13 2 17 14 8 16```

### 输出

```
43```

# AI分析结果



## 算法分类
**线性DP**

---

## 综合分析与结论

### 题目核心思路
题目要求每次取相邻两个数，且不能出现三个连续被取的位置。通过设计动态规划状态 `dp[i]` 表示前 `i` 个数的最大和，状态转移时考虑是否取第 `i-1` 和 `i` 位。若取，则需跳过前一个数，从 `dp[i-3]` 转移；若不取，则继承 `dp[i-1]`。

### 关键状态转移方程
```
dp[i] = max(dp[i-1], x[i-1] + x[i] + dp[i-3])
```

### 解决难点
- **状态定义**：正确理解“不能取三个连续数”转化为跳步逻辑（取当前两数后需跳过前一位）。
- **转移推导**：通过样例反推得出 `dp[i-3]` 的跳跃关系，确保不连续取三个。
- **空间优化**：利用滚动变量将空间复杂度从 `O(n)` 降为 `O(1)`。

---

## 题解清单（≥4星）

### 题解评分：★★★★☆
**关键亮点**  
- 状态转移方程简洁，直接体现“取两跳一”的核心逻辑。
- 空间优化到 `O(1)`，适用于 `n=1e5` 的大数据量。
- 初始条件处理严谨，通过示例验证确保正确性。

---

## 代码实现与核心逻辑

### 动态规划代码（C++）
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<long long> x(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> x[i];
    }
    
    if (n < 2) {
        cout << 0 << endl;
        return 0;
    }
    
    // 使用滚动数组优化空间
    long long a = 0, b = 0, c = x[1] + x[2], d;
    if (n == 2) {
        cout << c << endl;
        return 0;
    }
    
    for (int i = 3; i <= n; ++i) {
        d = max(c, x[i-1] + x[i] + a);
        a = b;
        b = c;
        c = d;
    }
    
    cout << c << endl;
    return 0;
}
```

### 核心实现思想
1. **滚动数组优化**：用变量 `a`, `b`, `c` 分别保存 `dp[i-3]`, `dp[i-2]`, `dp[i-1]`。
2. **状态转移**：每次计算当前最大值 `d = max(c, x[i-1] + x[i] + a)`，更新滚动变量。
3. **边界处理**：对 `n < 2` 和 `n = 2` 的情况单独处理。

---

## 最优思路提炼

1. **动态规划状态设计**：`dp[i]` 表示前 `i` 个数的最优解，通过跳跃式转移避免连续取三个数。
2. **空间优化技巧**：滚动数组将空间复杂度从 `O(n)` 降为 `O(1)`。
3. **转移方程推导**：通过“取两跳一”的逻辑，结合样例验证推导出 `dp[i-3]` 的跳跃步长。

---

## 类似题目推荐

1. **打家劫舍（LeetCode 198）**  
   - 不可连续取数，状态转移为 `dp[i] = max(dp[i-1], nums[i] + dp[i-2])`。

2. **最大子段和（洛谷 P1115）**  
   - 线性 DP 求连续子序列最大和。

3. **跳跃游戏（洛谷 P1095）**  
   - 动态规划结合跳跃步数选择。

---

## 可视化与动画设计

### 动态规划可视化方案
1. **网格绘制**：在 Canvas 中以像素块展示 `dp` 数组，每个块显示当前值。
2. **颜色高亮**：当前计算的 `dp[i]` 用绿色标记，`x[i-1]+x[i]` 操作用黄色高亮。
3. **步进控制**：用户可单步执行，观察 `a, b, c` 的滚动更新过程。

### 复古像素风格设计
- **8 位色盘**：使用经典 FC 游戏的 16 色方案，`dp` 块用蓝色渐变。
- **音效触发**：状态转移时播放 8-bit 音效，更新最大值时用上扬音调。

---

## 个人心得

- **初始条件易错**：需单独处理 `n < 2` 和 `n = 2` 的边界情况。
- **跳跃步长验证**：通过样例反推出 `dp[i-3]` 的正确性，避免逻辑错误。

---
处理用时：232.37秒
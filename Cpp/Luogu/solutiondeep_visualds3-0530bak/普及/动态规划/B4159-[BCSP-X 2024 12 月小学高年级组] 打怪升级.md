# 题目信息

# [BCSP-X 2024 12 月小学高年级组] 打怪升级

## 题目描述

Alice 在玩一个游戏，游戏共有 $n$ 个关卡，你需要操作 $1$ 个主角过关，主角有 $2$ 个属性：

1. 血量
2. 等级

每关的 Boss 会对主角造成伤害（血量减小），第 $i$ 关的 Boss 对等级为 $j$ 的主角造成的伤害值为 $b[i][j]$。

每关打完 Boss 后，在进入下一关前会得到一本经验书，你有 $2$ 个选择：

1. 回血：第 $i$ 关的经验书可以使血量增加 $a[i]$。
2. 改变等级：若假设主角当前等级为 now，使用经验书可以将等级变为 $[1, now + 1]$ 中的任意值。

你需要在 $2$ 个选择中择一执行。

已知主角的初始血量为 $m$，初始等级为 $1$，游戏过程中任意时刻血量必须 $>0$。

现在请问，在通过第 $k$ 个关卡之后（可以使用第 $k$ 关的经验书），主角能达到的最大等级是多少？如果无法通过第 $k$ 关，答案为 0。

请你输出 $k = 1 \sim n$ 的所有答案，注意这 $n$ 个询问是独立的。

例如 $n = 3, m = 2, a = [2, 1, 1]$

$$b[1][1] = 1$$
$$b[2][1] = 2, b[2][2] = 3$$
$$b[3][1] = 3, b[3][2] = 3, b[3][3] = 3$$

- 当 $k = 1$ 时，第一关血量先减为 $2 - 1 = 1$，然后选择升为 2 级，答案为 $2$。
- 当 $k = 2$ 时，第一关血量先减为 $2 - 1 = 1$，然后选择加血 $1 + 2 = 3$；第二关血量减为 $3 - 2 = 1$，然后选择升为 $2$ 级，答案为 $2$。
- 当 $k = 3$ 时，无论如何选择都无法通过第 3 关，答案为 $0$。

## 说明/提示

### 样例 3-5

见附件。

### 数据范围

对于所有数据，$1 \leq n \leq 1500, 0 \leq a[i], b[i][j] \leq 100, 1 \leq m \leq 1500$

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | $n$ | 子任务依赖 |
|:----------:|:----:|:-------:|:------------:|
| 1          | 39   | $\leq 10$ |            |
| 2          | 43   | $\leq 100$ | 1          |
| 3          | 18   | $\leq 1500$ | 1,2        |

## 样例 #1

### 输入

```
3 2
2 1 1
1
2 3
3 3 3```

### 输出

```
2
2
0```

## 样例 #2

### 输入

```
10 98
67 100 76 15 44 86 38 95 5 8
43
25 91
14 18 24
79 79 60 85
35 47 59 22 96
53 78 43 95 55 25
74 26 97 30 42 14 6
100 70 79 49 83 74 43 38
64 38 75 79 59 10 54 17 2
34 19 19 4 23 90 99 97 93 10```

### 输出

```
2
2
3
4
4
4
5
5
5
6```

# AI分析结果



## 算法分类
动态规划

## 综合分析与结论
本题核心在于通过动态规划维护每个关卡后的可能状态，即等级和血量，以确定能到达的最大等级。关键在于预处理每个关卡后的可能最优血量，从而在状态转移时高效处理升级选择。

### 核心难点与解决
1. **状态设计**：`dp[i][j]` 表示通过前i关后等级为j的最大血量。需处理回血和升级两种选择。
2. **预处理优化**：通过反向遍历预处理每个关卡后的最大剩余血量，减少时间复杂度。
3. **独立询问处理**：每个关卡的结果独立计算，需一次动态规划处理所有关卡。

### 可视化设计思路
- **状态更新动画**：用网格展示每个关卡后的等级和对应血量，高亮当前处理的关卡和状态转移路径。
- **颜色标记**：绿色表示存活状态，红色表示血量不足。升级操作用箭头表示等级变化。

## 最优思路提炼
1. **动态规划状态设计**：维护每个关卡后的等级和对应最大血量。
2. **预处理最大值数组**：快速计算每个关卡后的可能最大剩余血量，优化升级操作。
3. **贪心策略**：升级时优先考虑最高可能等级，确保后续关卡等级最大化。

## 核心代码实现
```python
n, m = map(int, input().split())
a = list(map(int, input().split()))
b = [[] for _ in range(n+2)]  # b[i]对应第i关的伤害数组，j从1开始
for i in range(1, n+1):
    b[i] = list(map(int, input().split()))
    b[i] = [0] + b[i]  # 调整为1-based索引

# 初始化dp数组
dp = [[-1] * (n + 2) for _ in range(n + 2)]  # dp[i][j]表示前i关后等级j的最大血量
dp[0][1] = m

for i in range(1, n+1):
    prev_level_max = i  # 前i-1关后的最大等级是i-1+1 =i
    current_max_level = i + 1
    # 预处理max_h_prev数组
    max_h_prev = [-1] * (prev_level_max + 2)  # 0~prev_level_max+1
    # 反向计算max_h_prev[j]
    for j in range(prev_level_max, 0, -1):
        if dp[i-1][j] == -1:
            temp = -1
        else:
            temp = dp[i-1][j] - b[i][j]
        if j == prev_level_max:
            max_h_prev[j] = temp
        else:
            max_h_prev[j] = max(temp, max_h_prev[j+1])
    # j=0的情况取j=1的值
    max_h_prev[0] = max_h_prev[1]
    
    # 初始化当前dp[i]
    current_dp = [-1] * (current_max_level + 2)
    # 处理回血的情况
    for j_prev in range(1, prev_level_max + 1):
        if dp[i-1][j_prev] == -1:
            continue
        after_fight = dp[i-1][j_prev] - b[i][j_prev]
        if after_fight <= 0:
            continue
        new_h = after_fight + a[i-1]
        if new_h > current_dp[j_prev]:
            current_dp[j_prev] = new_h
    # 处理升级的情况
    for j_new in range(1, current_max_level + 1):
        j_prev_min = j_new - 1
        if j_prev_min < 0:
            j_prev_min = 0
        if j_prev_min > prev_level_max:
            continue  # 超出之前的等级范围
        max_h = max_h_prev[j_prev_min]
        if max_h <= 0:
            continue
        if max_h > current_dp[j_new]:
            current_dp[j_new] = max_h
    # 更新dp[i]
    for j in range(len(current_dp)):
        dp[i][j] = current_dp[j]

# 处理每个k的询问
for k in range(1, n+1):
    max_level = 0
    for j in range(1, k + 2):  # 最大等级k+1
        if dp[k][j] > 0 and j > max_level:
            max_level = j
    print(max_level if max_level > 0 else 0)
```

---
处理用时：440.61秒
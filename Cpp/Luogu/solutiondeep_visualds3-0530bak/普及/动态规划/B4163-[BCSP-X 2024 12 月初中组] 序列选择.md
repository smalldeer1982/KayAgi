# 题目信息

# [BCSP-X 2024 12 月初中组] 序列选择

## 题目描述

给定两个长度为 $ n $ 的序列 $ a, b $，找出一个长为 $ n $ 的序列 $ c $，满足对于 $ i = 1, 2, \cdots, n $，有 $ c_i = a_i $ 或 $ c_i = b_i $，使得 $\sum_{i=2}^{n} |c_i - c_{i-1}|$ 最小，你只需要输出这个最小值。


## 说明/提示

### 样例 1 解释
令序列 $ c = [2, 3, 4, 2, 1] $，此时 $\sum_{i=2}^{n} |c_i - c_{i-1}| = 5$，可以证明不存在更小的答案。

### 样例 2

见附件的 `seq/seq2.in` 与 `seq/seq2.ans`。

### 数据范围

- 对于 $20\%$ 的数据，满足 $n\leq 20$。
- 对于 $100\%$ 的数据，满足 $1\leq n\leq 2\times 10^5$，$0\leq |a_i|,|b_i|\leq 10^9$。

## 样例 #1

### 输入

```
5
1 3 4 2 5
2 5 4 2 1```

### 输出

```
5```

# AI分析结果



---

**唯一算法分类**  
线性DP  

---

**综合分析与结论**  
本问题采用线性动态规划（DP）求解，核心在于维护每个位置选择不同元素时的最小累计差值。状态转移方程通过比较前一位置两种选择的最优解，结合当前选择的差值更新状态。由于每个状态仅依赖前一步，空间复杂度优化至O(1)。  

**关键状态转移方程**：  
```
当前选a_i的最小值：min(前一步选a的累计值 + |a_i - a_{i-1}|, 前一步选b的累计值 + |a_i - b_{i-1}|)
当前选b_i的最小值：min(前一步选a的累计值 + |b_i - a_{i-1}|, 前一步选b的累计值 + |b_i - b_{i-1}|)
```

**可视化设计**：  
- **动画方案**：用网格展示DP状态，每个格子表示当前位置选择a或b的最小值。当前更新格子高亮为绿色，前一步状态为黄色，转移路径用箭头动态绘制。  
- **复古像素风格**：采用8位色调色板（如#FF6B6B、#4ECDC4），Canvas绘制网格，每次状态更新时播放类似“马里奥跳跃”的8位音效。  
- **交互设计**：用户可调整动画速度，观察每一步的状态转移；AI自动模式以固定步长演示，背景音乐为经典《吃豆人》循环曲。

---

**题解清单**  
⭐️⭐️⭐️⭐️⭐️ **线性DP实现**  
- **核心亮点**：仅用两个变量维护前驱状态，时间复杂度O(n)，代码简洁高效。  
- **代码片段**：  
  ```python
  n = int(input())
  a = list(map(int, input().split()))
  b = list(map(int, input().split()))
  prev_a, prev_b = 0, 0
  for i in range(1, n):
      curr_a = min(prev_a + abs(a[i] - a[i-1]), prev_b + abs(a[i] - b[i-1]))
      curr_b = min(prev_a + abs(b[i] - a[i-1]), prev_b + abs(b[i] - b[i-1]))
      prev_a, prev_b = curr_a, curr_b
  print(min(prev_a, prev_b))
  ```

---

**最优思路提炼**  
1. **状态压缩**：仅保留前一步的两个状态，避免使用二维数组，节省空间。  
2. **贪心思想**：每个状态仅保留最优解，确保后续转移的正确性。  
3. **数学建模**：通过绝对值差建立相邻元素间的转移关系，直观且易于实现。

---

**同类型题推荐**  
1. **P1216 [USACO1.5]数字三角形**：类似路径选择问题，需维护每一步的最优解。  
2. **P1880 [NOI1995]石子合并**：环形区间DP，状态转移依赖子区间最优解。  
3. **P1091 [NOIP2004 提高组]合唱队形**：双向线性DP，需结合前后缀状态。

---

**代码实现**  
```python
n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
prev_a = prev_b = 0
for i in range(1, n):
    curr_a = min(prev_a + abs(a[i] - a[i-1]), prev_b + abs(a[i] - b[i-1]))
    curr_b = min(prev_a + abs(b[i] - a[i-1]), prev_b + abs(b[i] - b[i-1]))
    prev_a, prev_b = curr_a, curr_b
print(min(prev_a, prev_b))
```

---

**可视化与游戏化设计**  
1. **Canvas网格**：绘制n×2的网格，每行两列分别表示选a或选b的DP值。  
2. **像素动画**：状态更新时，新格子从上方掉落并闪烁，旧格子渐隐。  
3. **音效触发**：状态转移时播放“金币收集”音效，最终结果展示时播放胜利音效。  
4. **自动演示模式**：AI按固定间隔（500ms/步）播放，支持暂停/继续，控制面板集成速度滑块。  

**复古风格参数**：  
- 主色调：#FFD700（金色，当前状态）、#1E90FF（蓝色，前驱状态）  
- 背景音乐：8位芯片风格改编版《超级玛丽》地下城BGM  
- 音效库：JSFXR生成的“点击”、“成功”、“失败”音效  

--- 

**总结**  
本题通过线性DP将复杂的选择问题转化为状态转移，巧妙利用空间优化降低复杂度。核心在于设计简洁的状态表示与转移方程，并通过逐步更新实现高效求解。

---
处理用时：154.26秒
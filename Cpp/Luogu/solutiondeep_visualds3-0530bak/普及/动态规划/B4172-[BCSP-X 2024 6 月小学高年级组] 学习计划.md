# 题目信息

# [BCSP-X 2024 6 月小学高年级组] 学习计划

## 题目描述

暑假共有 $n$ 天，第 $i$ 天的精力指数为 $a[i]$，你想要利用假期**依次（按 $1, 2, \ldots, m$ 顺序）** 复习 $m$ 门功课，第 $i$ 门功课的重要程度为 $b[i]$，且**每门功课的复习时段必须连续，并且不能有某天不干事。**

假设第 $i$ 门功课的复习时段为第 $l \sim r$ 天，那么第 $i$ 门功课的收益为 $b[i] \times (a[l] + a[l + 1] + \ldots + a[r])$，你的总收益为 $m$ 门功课收益的总和。

请你制订一个复习计划，使得总收益最大。

形式化地，给定序列 $a[1 \sim n], b[1 \sim m]$，你需要把 $1, 2, \ldots, n$ 这个序列分成首尾相连且非空的 $m$ 段，假设每段的 $a$ 之和为 $s[1 \sim m]$，最大化 $\sum_{i=1}^{m} b[i] \times s[i]$ 的值。

例如 $a = [-3, 6, -1, -8, 7, -6], b = [-3, 2]$，最优策略是第 $1 \sim 4$ 天复习第 $1$ 门功课，收益为 $-3 \times (-3 + 6 - 1 - 8) = 18$；第 $5 \sim 6$ 天复习第 $2$ 门功课，收益为 $2 \times (7 - 6) = 2$；总收益为 $18 + 2 = 20$。

例如 $a = [6, 3, 5, 10, 5], b = [-8, -5, -5]$，最优策略是分成 $[1], [2, 3, 4], [5]$ 三段，总收益为 $-8 \times 6 - 5 \times (3 + 5 + 10) - 5 \times 5 = -163$。


## 说明/提示

对于所有数据，满足 $1 \leq T \leq 20, 1 \leq m \leq n \leq 2000, -10^3 \leq a[i], b[i] \leq 10^3$。

- 对于测试点 1~7：$n \leq 10$；
- 对于测试点 8~12：$n \leq 500$；
- 对于测试点 13~16：所有 $a[i], b[i]$ 为正整数；
- 对于测试点 17~20：$n \leq 2000$；

## 样例 #1

### 输入

```
5
6 2
-3 6 -1 -8 7 -6
-3 2
5 4
-9 -6 -6 -7 -8
-5 7 -9 -3
7 7
7 2 3 0 -2 4 2
-9 -2 -5 0 -7 9 -1
5 3
10 4 6 7 4
-1 -9 2
5 3
6 3 5 10 5
-8 -5 -5```

### 输出

```
20
144
-34
-12
-163```

# AI分析结果



---

**唯一算法分类**  
线性DP  

---

**综合分析与结论**  

**题目核心与难点**  
题目要求将n天分成m段，每段对应一个权重b[i]，求最大加权和。关键点在于必须按顺序分配连续的段，且无法回溯。  

**算法思路**  
采用动态规划（DP）结合前缀和优化：  
- **状态设计**：`dp[i][j]`表示前i门功课用j天的最大收益。  
- **状态转移**：`dp[i][j] = max(dp[i-1][k] + b[i] * (sum[j] - sum[k]))`，其中k为前i-1门课使用的天数。  
- **优化关键**：通过维护`current_max`变量，避免重复遍历k，将复杂度从O(mn²)降为O(mn)。  

**可视化设计要点**  
1. **DP矩阵更新**：用网格展示`dp[i][j]`的更新过程，高亮当前处理的i和j，以及对应的`current_max`。  
2. **前缀和辅助线**：在网格下方显示`pre_sum`数组，直观展示区间和计算。  
3. **滚动数组效果**：用颜色区分不同层的`dp`数组（如i层用蓝色，i-1层用灰色）。  

---

**题解清单 (4星以上)**  
1. **题解评分：★★★★★**  
   - **关键亮点**：  
     - 使用滚动数组优化空间至O(n)。  
     - 通过`current_max`维护前缀最大值，避免重复计算。  
   - **代码实现**：  
     ```python  
     def main():  
         import sys  
         input = sys.stdin.read().split()  
         ptr = 0  
         T = int(input[ptr])  
         ptr +=1  
         for _ in range(T):  
             n, m = int(input[ptr]), int(input[ptr+1])  
             ptr +=2  
             a = list(map(int, input[ptr:ptr+n]))  
             ptr +=n  
             b = list(map(int, input[ptr:ptr+m]))  
             ptr +=m  
             # 计算前缀和  
             pre_sum = [0]*(n+1)  
             for i in range(1, n+1):  
                 pre_sum[i] = pre_sum[i-1] + a[i-1]  
             # 初始化DP  
             prev_dp = [-float('inf')]*(n+1)  
             prev_dp[0] = 0  
             for i in range(1, m+1):  
                 curr_dp = [-float('inf')]*(n+1)  
                 current_max = -float('inf')  
                 for j in range(i, n+1):  
                     k = j-1  
                     if prev_dp[k] != -float('inf'):  
                         temp = prev_dp[k] - b[i-1] * pre_sum[k]  
                         if temp > current_max:  
                             current_max = temp  
                     curr_dp[j] = current_max + b[i-1] * pre_sum[j]  
                 prev_dp = curr_dp  
             print(prev_dp[n])  
     if __name__ == "__main__":  
         main()  
     ```  

---

**最优思路或技巧提炼**  
1. **前缀和优化区间和**：预处理前缀和数组避免重复计算区间和。  
2. **滚动数组压缩空间**：仅保留当前层和前一层的数据，空间复杂度O(n)。  
3. **动态维护最大值**：通过`current_max`实时记录最大值，避免重复遍历历史状态。  

---

**同类型题或类似算法套路**  
- **区间分段最优化问题**：如「乘积最大子数组」、「分割回文串II」。  
- **前缀和+DP优化**：如「最大子数组和」、「最佳买卖股票时机含冷冻期」。  

---

**推荐相似题目**  
1. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)  
2. [P1048 采药（0-1背包）](https://www.luogu.com.cn/problem/P1048)  
3. [P1052 过河（路径压缩+DP）](https://www.luogu.com.cn/problem/P1052)  

---

**个人心得摘录**  
- **调试关键**：初始条件`prev_dp[0]=0`容易遗漏，导致后续计算全错。  
- **优化顿悟**：将`dp[i][j]`的转移拆分为`max(prev_dp[k] - b*sum[k]) + b*sum[j]`是优化的核心。  

---

**可视化与算法演示**  
- **动画方案**：  
  - **网格绘制**：用Canvas绘制DP矩阵，当前层用高亮色填充。  
  - **步进控制**：用户可调节速度，观察`current_max`如何随j递增更新。  
  - **音效提示**：每次更新`dp[i][j]`时播放“点击”音效，找到更大值时播放“叮咚”声。  
- **复古像素风格**：  
  - 使用16色调色板，DP格子用8x8像素块表示。  
  - 背景播放FC风格音乐，状态转移时显示“MAX”闪烁特效。  

---

**代码实现核心**  
```python  
# 核心代码片段（DP更新部分）  
prev_dp = [-float('inf')] * (n+1)  
prev_dp[0] = 0  
for i in range(1, m+1):  
    curr_dp = [-float('inf')] * (n+1)  
    current_max = -float('inf')  
    for j in range(i, n+1):  
        k = j-1  
        if prev_dp[k] != -float('inf'):  
            temp = prev_dp[k] - b[i-1] * pre_sum[k]  
            current_max = max(current_max, temp)  
        curr_dp[j] = current_max + b[i-1] * pre_sum[j]  
    prev_dp = curr_dp  
```

---
处理用时：315.39秒
# 题目信息

# [中山市赛 2024] 糖果共享

## 题目描述

Jimmy 要和其他同学们一起分享老师带来的糖果了！可是，老师不想让同学们这么快就领到糖果，于是决定跟大家玩一个分享糖果的游戏。

老师让 $n$ 个同学们围成一圈坐在一起。接下来，对于第 $i$ 个同学，老师会在第 $t_i$ 秒发给 TA 一份糖果；每次得到糖果之后，第 $i$ 个同学会固定等待 $p_i$ 秒，然后把糖果分给身旁的第 $i + 1$ 个同学（特殊的情况是，第 $n$ 个同学会把糖果分给第 $1$ 个同学）。注意每个同学既可以从老师那里得到糖果，也可以从旁边的同学那里得到糖果，而且老师发的糖果足够多，同学们只要收到了糖果，就一定能将糖果分出去。同学们的分糖果动作非常快，可以认为是不占用时间的。

在参与游戏的同时，Jimmy 很想知道他的几个好朋友们最快什么时候能得到糖果。你能帮帮他吗？

## 说明/提示

### 样例解释 1

以下是游戏开始后，每个时刻发生的事件：

1. 第 $3$ 秒，第 $1$ 个同学领到了老师给的一份糖果；
2. 第 $7$ 秒，第 $1$ 个同学将糖果分给了第 $2$ 个同学（糖果是老师给的）；
3. 第 $8$ 秒，第 $2$ 个同学将糖果分给了第 $3$ 个同学（糖果是第 $1$ 个同学给的）；
4. 第 $10$ 秒，第 $2$ 个同学领到了老师给的一份糖果；
5. 第 $11$ 秒，第 $2$ 个同学将糖果分给了第 $3$ 个同学（糖果是老师给的）；
6. 第 $13$ 秒，第 $3$ 个同学领到了老师给的一份糖果；

可知，第 $2$ 个同学最快在第 $7$ 秒得到了糖果；第 $3$ 个同学最快在第 $8$ 秒得到了糖果。接下来，游戏还会继续下去，同学们还会继续互相分糖果，但是不会再改变 Jimmy 问题的答案了。

### 数据范围

- 对于 $30\%$ 的数据，保证 $1 \leq n, q \leq 5000$。
- 对于 $100\%$ 的数据，保证 $1 \leq n, q \leq 2 \times 10^5$，$1 \leq t_i, p_i \leq 10^9$，$1 \leq x_i \leq n$。

## 样例 #1

### 输入

```
3
3 10 13
4 1 5
2
2
3```

### 输出

```
7
8```

## 样例 #2

### 输入

```
4
1 1 1 1
100 100 100 100
3
3
4
1```

### 输出

```
1
1
1```

## 样例 #3

### 输入

```
4
1 2 4 7
1 2 3 4
4
3
3
2
4```

### 输出

```
4
4
2
7```

## 样例 #4

### 输入

```
8
50 22 63 28 91 60 64 27
84 87 78 16 94 36 87 93
8
1
2
3
4
5
6
7
8```

### 输出

```
50
22
63
28
44
60
64
27```

# AI分析结果



**唯一算法分类**：图论中的最短路径（BFS松弛）

---

### **综合分析与结论**

**核心问题**：每个同学的最早获得糖果时间取决于老师发放时间或前驱同学的传递时间。环形结构要求处理所有可能的传递方向。

**最优思路**：  
1. **队列BFS松弛法**：将每个节点作为起点，若其可优化后继节点的时间，则将后继加入队列。队列处理确保所有传递路径被覆盖，时间复杂度O(n)。
2. **Dijkstra算法**：将问题转化为单源最短路径，时间复杂度O(n log n)，正确但稍慢。

**可视化设计**：  
- **动画方案**：用网格展示环形结构，队列中的节点高亮为黄色，当前处理的节点标记为红色，更新后的节点变绿。  
- **操作演示**：队列弹出节点x，检查x+1的时间是否可优化。若可，更新x+1为x.time + p[x]，并加入队列。  
- **复古风格**：8-bit像素动画，每次更新播放“哔”声，队列操作时背景音乐循环。

---

### **题解清单 (≥4星)**

1. **封禁用户 (5星)**  
   - **亮点**：队列BFS松弛，时间复杂度O(n)，代码简洁高效。  
   - **核心逻辑**：初始检查所有节点，触发可能的更新；队列处理动态传播优化。

2. **Sliarae (5星)**  
   - **亮点**：标准Dijkstra实现，思路清晰，正确性显然。  
   - **核心逻辑**：虚拟源点建图，优先队列处理最短路径。

3. **TJB_LHY (5星)**  
   - **亮点**：优先队列贪心策略，代码简洁，类似Dijkstra。  
   - **核心逻辑**：每次处理最早时间节点，传递到下一个节点。

---

### **代码实现**

**封禁用户的队列BFS解法**  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e5+5;
long long t[MAXN], p[MAXN], n, q, x;
queue<int> que;

int main() {
    cin >> n;
    for(int i=0; i<n; i++) cin >> t[i];
    for(int i=0; i<n; i++) cin >> p[i];
    for (int i=0; i<n; i++) {
        int next = (i+1) % n;
        if(t[next] > t[i] + p[i]) {
            t[next] = t[i] + p[i];
            que.push(next);
        }
    }
    while(!que.empty()) {
        int x = que.front(); que.pop();
        int next = (x+1) % n;
        if(t[next] > t[x] + p[x]) {
            t[next] = t[x] + p[x];
            que.push(next);
        }
    }
    cin >> q;
    while(q--) {
        cin >> x;
        cout << t[x-1] << endl;
    }
    return 0;
}
```

---

### **同类型题推荐**
1. **P4779**（单源最短路径）  
2. **P3371**（最短路径基础）  
3. **P1144**（无权图BFS最短路）

---

### **可视化算法演示（队列BFS）**
1. **初始化**：环形排列节点，显示每个节点的初始时间`t[i]`。  
2. **队列处理**：高亮当前节点x，计算x→x+1的时间，若更优则更新并标记绿色。  
3. **音效**：更新成功时播放清脆音效，队列空时播放完成音效。  
4. **复古风格**：8-bit像素风，节点用色块表示，时间以数字显示。  

**示例动画步骤**：  
- **Step 1**：节点0的t=3，触发节点1更新为3+4=7。  
- **Step 2**：节点1的t=7，触发节点2更新为7+1=8。  
- **Step 3**：节点2的t=13，无法优化节点3。  
- **Step 4**：队列空，结束。  

---

**总结**：队列BFS松弛法以线性时间覆盖所有传递路径，是最优解法。可视化时重点展示队列的动态处理与时间传播。

---
处理用时：389.37秒
# 题目信息

# [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。


## 说明/提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
389 207 155 300 299 170 158 65```

### 输出

```
6
2
```

# AI分析结果



## 唯一算法分类
**线性DP**

---

## 综合分析与结论

### 核心思路与算法要点
1. **第一问（最长不上升子序列）**
   - **状态转移优化**：用单调数组维护不同长度的子序列末尾元素最大值，二分查找优化至 O(n log n)
   - **关键数据结构**：数组 `f[]` 记录长度为 `i` 的子序列最小末尾值，保证单调递减
   - **操作动画**：遍历导弹高度时，动态显示二分查找过程，高亮替换位置，像素方块展示数组更新

2. **第二问（最少系统数）**
   - **Dilworth 定理**：最少链划分 = 最长反链长度，转化为求最长上升子序列
   - **贪心维护**：维护各系统末尾高度的单调递增数组，二分查找可用的最小高度系统
   - **可视化要点**：用不同颜色标记系统数组更新，展示定理应用逻辑，动态对比两问的数组维护差异

---

## 题解清单（≥4星）

### 5星：离散小波变换°
- **核心亮点**：双问统一框架、数学证明严谨、代码极简
- **关键代码**：
  ```cpp
  // 最长不上升子序列维护
  int l=0, r=t+1;
  while(r-l>1) {
      int m=l+(r-l)/2;
      if(F[m]>=H[i]) l=m; else r=m;
  }
  // 最长上升子序列维护
  *lower_bound(F+1, F+t+1, H[i]) = H[i];
  ```

### 4星：STA_Morlin
- **核心亮点**：Dilworth 定理详细证明、偏序集关系图解
- **独特贡献**：通过哈斯图直观展示导弹拦截的偏序关系

### 4星：Otue
- **核心亮点**：贪心策略的可视化解释、不依赖定理的直觉证明
- **代码特色**：两问共用相同代码框架，仅修改比较符号

---

## 最优思路与技巧提炼

### 关键技巧
1. **单调数组维护**：用 `f[]` 数组记录不同长度的最优末尾值，保证单调性以支持二分
   ```cpp
   // 最长不上升子序列维护
   if (H[i] <= f.back()) f.push_back(H[i]);
   else *upper_bound(f.begin(), f.end(), H[i], greater<>()) = H[i];
   ```
2. **Dilworth 定理应用**：最少系统数 = 最长上升子序列长度
3. **二分查找优化**：将 O(n²) 的暴力 DP 优化至 O(n log n)

### 同类型题套路
- **最长XX子序列**：通过维护单调数组 + 二分查找实现优化
- **链划分问题**：Dilworth 定理转化（如任务调度、区间覆盖）

---

## 推荐相似题目
1. **P1091 [NOIP2004 提高组] 合唱队形**（双向LIS）
2. **P2782 友好城市**（偏序集+最长链）
3. **P1439 【模板】最长公共子序列**（转化为LIS）

---

## 个人心得摘录
> **sunyizhe**：  
> _"调了两天两夜才对...离散化用线段树维护值域"_  
> **启示**：理解二分边界和单调性维护是调试关键

> **lilong**：  
> _"每次替换操作后数组仍保持单调性，这是优化的核心"_  
> **启示**：替换操作不影响整体单调性的证明至关重要

---

## 可视化与算法演示

### 动态规划动画方案
1. **像素风格展示**  
   - **Canvas 网格**：8-bit 像素块表示 `f[]` 数组元素，高度值转为颜色（深红→深蓝渐变）
   - **操作高亮**：插入新元素时闪烁绿色，替换元素时闪烁黄色

2. **音效设计**  
   - **二分查找**：每次折半时播放 "bleep" 音效（8-bit 短音）
   - **数组更新**：元素插入/替换时播放不同音高（C4/E4/G4）

3. **自动演示模式**  
   ```javascript
   // 伪代码：自动运行LIS计算
   function autoRun() {
     let speed = 500; // 每步500ms
     for (let i=0; i<arr.length; i++) {
       highlightCurrentMissile(arr[i]);
       let pos = binarySearch(f, arr[i]);
       updateFArray(pos, arr[i]);
       await sleep(speed);
     }
   }
   ```

### 复古游戏化设计
- **关卡设计**：  
  1. 第一关：手动完成3个元素的LIS计算  
  2. 第二关：自动演示Dilworth定理转化过程  
  3. 隐藏关：用偏序集解决P2782友好城市问题

- **积分系统**：  
  - 正确完成二分查找 +10分  
  - 快速通关奖励连击×2  
  - 错误操作触发 "Game Over" 像素动画

---

## 核心代码实现
```cpp
// 第一问：最长不上升子序列
vector<int> f;
for (int x : height) {
    if (f.empty() || x <= f.back()) 
        f.push_back(x);
    else 
        *upper_bound(f.begin(), f.end(), x, greater<>()) = x;
}
cout << f.size();

// 第二问：最长上升子序列（Dilworth定理）
vector<int> g;
for (int x : height) {
    auto it = lower_bound(g.begin(), g.end(), x);
    if (it == g.end()) g.push_back(x);
    else *it = x;
}
cout << g.size();
```

---
处理用时：83.46秒
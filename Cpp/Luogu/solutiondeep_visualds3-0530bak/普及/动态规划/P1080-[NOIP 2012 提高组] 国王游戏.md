# 题目信息

# [NOIP 2012 提高组] 国王游戏

## 题目描述

恰逢 H 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。

国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。


## 说明/提示

【输入输出样例说明】

按 $1$、$2$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $1$、$3$、$2$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $2$、$1$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按$ 2$、$3$、$1 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$；

按 $3$、$1$、$2 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；  

按$ 3$、$2$、$1$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$。

因此，奖赏最多的大臣最少获得 $2$ 个金币，答案输出 $2$。


 
【数据范围】

对于 $20\%$ 的数据，有 $1≤ n≤ 10,0 < a,b < 8$；

对于 $40\%$ 的数据，有$ 1≤ n≤20,0 < a,b < 8$；

对于 $60\%$ 的数据，有 $1≤ n≤100$；

对于 $60\%$ 的数据，保证答案不超过 $10^9$；

对于 $100\%$ 的数据，有 $1 ≤ n ≤1,000,0 < a,b < 10000$。



NOIP 2012 提高组 第一天 第二题


## 样例 #1

### 输入

```
3 
1 1 
2 3 
7 4 
4 6 ```

### 输出

```
2```

# AI分析结果



# 国王游戏题解分析

## 1. 唯一算法分类
**无算法分类**

---

## 2. 题解思路、算法要点与解决难点

### 核心思路
通过**贪心策略**对所有大臣按照 `a_i * b_i` 升序排列，使得相邻两项交换后不会得到更优解，最终用高精度计算最大金币值。

### 算法要点
- **邻项交换证明**：若 `a_i * b_i < a_j * b_j`，则交换后最大值不会更小。
- **高精度实现**：压位处理（如用 10000 进制）、乘法/除法的进位借位优化。
- **排序稳定性**：乘积相同时右手更小的排前面。

### 解决难点
- **贪心正确性证明**：通过数学推导证明排序条件的唯一性。
- **大数据处理**：乘积可能达到 `1e4^1000`，必须用高精度。

---

## 3. 题解评分（≥4星）

### 5星题解：洛必达法则
- **思路清晰度**：完整数学证明，逻辑严密。
- **代码可读性**：高精度压位处理，变量命名规范。
- **优化亮点**：乘法用 `int` 压四位，除法去前导零高效。

### 4星题解：chc_1234567890
- **代码结构**：封装高精度类，支持运算符重载。
- **特殊处理**：除法反向存储结果，避免前导零。
- **不足**：未完全处理乘积为0的边界情况。

### 4星题解：frankchenfu
- **代码简洁性**：用结构体封装高精度，运算符重载清晰。
- **压位技巧**：`BASE=1e4` 提升性能。
- **调试提示**：注释提醒输出长度为零时补0。

---

## 4. 最优思路或技巧提炼

### 关键贪心策略
**排序规则**：`a_i * b_i` 升序排列，推导自相邻交换后的最大值比较：
```math
\max(\frac{k}{b_i}, \frac{ka_i}{b_j}) < \max(\frac{k}{b_j}, \frac{ka_j}{b_i}) \quad \text{当且仅当} \quad a_i b_i < a_j b_j
```

### 高精度优化
- **压位处理**：用 10000 进制减少循环次数。
- **乘除优化**：
  - 乘法：逐位乘后统一进位。
  - 除法：从高位到低位逐位取余。

---

## 5. 同类型题与算法套路

### 相似题型
- **邻项交换贪心**：P2123 皇后游戏（同类型排序条件推导）
- **高精度+贪心**：P1090 合并果子（小根堆+大数运算）
- **任务调度问题**：P1248 加工生产调度（双机流水排序）

### 通用套路
- **贪心证明**：交换相邻元素不会更优。
- **高精度模板**：压位存储、运算符重载。

---

## 6. 推荐相似题目
1. **P2123 皇后游戏**（邻项交换贪心）
2. **P1090 合并果子**（贪心+优先队列）
3. **P1248 加工生产调度**（双机流水线排序）

---

## 7. 个人心得摘录

### 调试教训
- **高精度除零**：`Jerry_zpl` 在代码末尾补充“若答案长度为0需输出0”。
- **压位边界**：`frankchenfu` 在乘法循环后处理未清零的进位。

### 顿悟时刻
- **洛必达法则**：通过比较 `a_i/b_j` 和 `a_j/b_i` 发现乘积是关键。
- **yanbinmu**：将“向下取整”简化为整除运算，避免浮点误差。

---

## 8. 可视化与算法演示

### 动态规划动画（伪代码）
```javascript
// 初始化画布与大臣队列
drawGrid(大臣队列);
let product = 国王左手值;
for (大臣 of 排序后列表) {
  计算当前大臣金币 = product / 右手值;
  高亮显示当前最大值;
  更新 product *= 左手值;
  绘制进位过程（如乘积增长动画）;
}
```

### 复古像素风格设计
- **颜色方案**：16色FC调色板（深蓝背景、黄色文字）。
- **音效触发**：
  - **计算金币**：8-bit “金币掉落”音效。
  - **更新乘积**：短促“升级”音效。
- **自动演示**：按排序顺序自动推进，用箭头标记当前操作大臣。

---

## 9. 关键代码片段（高精度乘法/除法）

```cpp
// 高精度乘法（压四位）
void operator*=(int rhs) {
    for (int i=1; i<=len; i++) a[i] *= rhs;
    for (int i=1; i<=len; i++) {
        a[i+1] += a[i] / BASE;
        a[i] %= BASE;
        if (i+1 > len && a[i+1]) len++;
    }
}

// 高精度除法（返回商）
bign operator/(int rhs) {
    bign c;
    int cur = 0;
    for (int i=len; i>=1; i--) {
        cur = cur * BASE + a[i];
        c.a[i] = cur / rhs;
        cur %= rhs;
    }
    c.len = len;
    while (c.len > 0 && c.a[c.len] == 0) c.len--;
    return c;
}
```

---
处理用时：85.88秒
# 题目信息

# [NOIP 2007 普及组] 守望者的逃离

## 题目背景

NOIP2007 普及组 T3

## 题目描述

恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。

守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。

为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。

守望者的跑步速度为 $17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1s$ 内移动 $60m$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。

现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间 $T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。

注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。


## 说明/提示

对于 $30\%$ 的数据，$1  \le  T   \le  10$，$ 1   \le   S   \le  100$；

对于 $50\%$ 的数据，$1   \le  T   \le   10^3$，$ 1   \le  S  \le   10^4$；

对于 $100\%$ 的数据，$1   \le   T   \le   3\times  10^5$，$0   \le   M   \le   10^3$，$ 1   \le  S   \le   10^8$。


## 样例 #1

### 输入

```
39 200 4
```

### 输出

```
No
197
```

## 样例 #2

### 输入

```
36 255 10```

### 输出

```
Yes
6```

# AI分析结果



# 题解分析与总结

## 算法分类
**线性DP**

---

## 题解思路与算法要点

### 核心难点
在有限时间内选择 **闪现**（高收益但需魔法值）和 **跑步**（稳定但低收益）的最优组合，需要动态维护两种状态的最优解。

### 动态规划核心思路
1. **状态定义**：`dp[i]` 表示第 `i` 秒的最远距离。
2. **状态转移**：
   - 优先用魔法闪现（若魔法足够），否则恢复魔法值。
   - 每次在闪现基础上，用 `max(dp[i], dp[i-1]+17)` 确保选择最优路径。
3. **关键优化**：双变量维护闪现和跑步距离（如 `s1` 和 `s2`），每次取最大值。

### 解决难点
- **贪心与DP结合**：先尽可能用闪现，再用跑步补足剩余时间。
- **魔法恢复逻辑**：魔法不足时需等待恢复，通过状态转移隐含处理。
- **实时最优更新**：每步比较闪现和跑步的距离，动态更新最大值。

---

## 题解评分（≥4星）

### 1. wzr1125（5星）
- **亮点**：双变量维护闪现/跑步距离，代码简洁高效。
- **代码**：
  ```cpp
  for(int i=1;i<=t;i++){
      if(m>=10) m-=10, fla+=60, run+=17;
      else m+=4, run+=17;
      if(fla>run) run=fla;
      if(max(fla,run)>=s) return 0;
  }
  ```

### 2. jingwenhan（4星）
- **亮点**：分两阶段处理，先闪现后比较跑步。
- **代码**：
  ```cpp
  for(int i=1;i<=t;i++){
      if(m>=10) dp[i]=dp[i-1]+60, m-=10;
      else dp[i]=dp[i-1], m+=4;
  }
  for(int i=1;i<=t;i++){
      dp[i]=max(dp[i], dp[i-1]+17);
  }
  ```

### 3. qhr2023（4星）
- **亮点**：单循环同时处理闪现和跑步，极致简化。
- **代码**：
  ```cpp
  for(int i=1; i<=t; i++){
      m>=10 ? (m-=10, s2+=60) : (m+=4);
      s1 = max(s1+17, s2);
      if(s1>=s) return 0;
  }
  ```

---

## 最优思路提炼
**双状态贪心法**：  
- 维护两个变量 `s1`（跑步+闪现的最优值）和 `s2`（纯闪现的累计值）。  
- 每步优先更新 `s2`（闪现），再将 `s1` 更新为 `max(s1+17, s2)`。  
- 时间复杂度：$O(T)$，空间复杂度：$O(1)$。

---

## 同类型题目
1. **P1099 [NOIP2007 普及组] 矩阵取数游戏**（线性DP + 贪心）
2. **P1048 [NOIP2005 普及组] 采药**（0-1背包）
3. **P1060 [NOIP2006 普及组] 开心的金明**（完全背包变种）

---

## 可视化与算法演示

### 动态规划动画方案
- **Canvas 网格**：横向为时间（秒），纵向为距离。每个格子表示该秒的最远距离。
- **颜色标记**：
  - 绿色：当前秒由闪现更新。
  - 蓝色：由跑步更新。
  - 红色：最大距离更新点。
- **步进控制**：手动/自动切换，观察 `s1` 和 `s2` 如何交替领先。

### 复古像素风格
- **8位音效**：闪现时播放“滴”声，跑步时“嗒”声，达成目标时胜利音效。
- **自动模式**：AI 自动执行最优策略，展示贪心过程。

```javascript
// 伪代码示例：Canvas 绘制 DP 状态
function drawFrame(step) {
  ctx.fillStyle = '#000'; // 背景黑色
  ctx.fillRect(0, 0, width, height);
  // 绘制当前秒的状态
  ctx.fillStyle = (isFlash) ? '#0F0' : '#00F';
  ctx.fillRect(step * 10, 0, 10, dp[step]);
}
```

---

## 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int m, s, t, s1, s2;
int main() {
    cin >> m >> s >> t;
    for (int i = 1; i <= t; i++) {
        (m >= 10) ? (m -= 10, s2 += 60) : (m += 4);
        s1 = max(s1 + 17, s2);
        if (s1 >= s) {
            cout << "Yes\n" << i;
            return 0;
        }
    }
    cout << "No\n" << s1;
    return 0;
}
```

---

**总结**：本题通过线性DP或贪心的双状态维护，高效解决了时间与魔法值的权衡问题。动态规划的状态转移和贪心的实时最优更新是核心技巧，适用于多种资源分配场景。

---
处理用时：78.24秒
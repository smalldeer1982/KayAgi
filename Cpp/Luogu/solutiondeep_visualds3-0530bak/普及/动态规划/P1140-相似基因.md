# 题目信息

# 相似基因

## 题目背景

大家都知道，基因可以看作一个碱基对序列。它包含了 $4$ 种核苷酸，简记作 `A, C, G, T`。生物学家正致力于寻找人类基因的功能，以利用于诊断疾病和发明药物。

在一个人类基因工作组的任务中，生物学家研究的是：两个基因的相似程度。因为这个研究对疾病的治疗有着非同寻常的作用。

## 题目描述

两个基因的相似度的计算方法如下：

对于两个已知基因，例如 `AGTGATG` 和 `GTTAG`，将它们的碱基互相对应。当然，中间可以加入一些空碱基 `-`，例如：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\tt A & \tt G & \tt T & \tt G & \tt A & \tt T & \texttt - & \tt G \\ \hline
\texttt - & \tt G & \tt T & \texttt - & \texttt - & \tt T & \texttt A & \tt G \\ \hline
\end{array}
$$

这样，两个基因之间的相似度就可以用碱基之间相似度的总和来描述，碱基之间的相似度如下表所示：

$$
\def\arraystretch{1.5}
\begin{array}{ |c|c|c|c|c|c|} \hline
& \tt A & \tt C & \tt G & \tt T & \texttt - \\ \hline
\tt A & 5 & -1 & -2 & -1 & -3\\ \hline
\tt C & -1 & 5 & -3 & -2 & -4 \\\hline
\tt G & -2 & -3 & 5 & -2 & -2 \\\hline
\tt T & -1 & -2 & -2 & 5 & -1 \\\hline
\texttt - & -3 & -4 & -2 & -1 & * \\\hline
\end{array}
$$ 

那么相似度就是：$(-3)+5+5+(-2)+(-3)+5+(-3)+5=9$。因为两个基因的对应方法不唯一，例如又有：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|} \hline
\tt A & \tt G & \tt T & \tt G & \tt A & \tt T & \tt G \\ \hline
\texttt - & \tt G & \tt T & \texttt T & \texttt A & \texttt - & \tt G \\ \hline
\end{array}
$$

相似度为：$(-3)+5+5+(-2)+5+(-1)+5=14$。规定两个基因的相似度为所有对应方法中，相似度最大的那个。


## 样例 #1

### 输入

```
7 AGTGATG
5 GTTAG
```

### 输出

```
14
```

# AI分析结果



# 【唯一算法分类】  
**线性DP**  

---

## **题解思路、算法要点与解决难点**  
### **核心思路**  
所有题解均采用**二维动态规划**，定义 `dp[i][j]` 表示第一个基因前 `i` 个碱基与第二个基因前 `j` 个碱基的最大相似度。状态转移方程考虑以下三种情况：  
1. **直接匹配**：`dp[i][j] = dp[i-1][j-1] + score(a[i], b[j])`  
2. **插入空碱基到第一个基因**：`dp[i][j] = dp[i][j-1] + score('-', b[j])`  
3. **插入空碱基到第二个基因**：`dp[i][j] = dp[i-1][j] + score(a[i], '-')`  

### **关键难点与解决**  
1. **边界条件**：  
   - 当 `i=0` 或 `j=0` 时，需累积插入空碱基的得分。例如，`dp[i][0] = dp[i-1][0] + score(a[i], '-')`。  
   - 初始化 `dp[0][0] = 0`，表示两个空序列的相似度为0。  

2. **得分表处理**：  
   - 将字符 `A/C/G/T` 映射为下标（如 `A→1`），空碱基对应特定下标（如 `5` 或 `4`）。  
   - 预定义二维数组存储得分表，例如 `d[6][6]`。  

3. **负值处理**：  
   - 需将 `dp` 数组初始化为极小值（如 `-INF`），避免初始0值干扰结果。  

---

## **题解评分 (≥4星)**  
### 1. **zhy137036 题解（⭐️⭐️⭐️⭐️⭐️）**  
- **亮点**：  
  - 清晰分步讲解DP定义、转移、边界、实现。  
  - 代码规范，字符转换逻辑明确。  
  - 使用表格和图示辅助说明状态转移。  

### 2. **Ykimna 题解（⭐️⭐️⭐️⭐️）**  
- **亮点**：  
  - 详细图解状态转移过程，直观展示三种匹配情况。  
  - 强调初始化负值的重要性（避免40分陷阱）。  

### 3. **Segment_Tree 题解（⭐️⭐️⭐️⭐️）**  
- **亮点**：  
  - 使用字符串简化输入处理。  
  - 代码简洁，`max` 函数直接比较三种情况。  

---

## **最优思路或技巧提炼**  
1. **状态转移设计**：  
   - 将问题分解为三种子问题（匹配、插入空碱基），覆盖所有可能的最优解路径。  

2. **预处理与映射**：  
   - 使用 `switch` 或 `map` 将碱基字符映射为下标，快速查询得分。  

3. **边界处理技巧**：  
   - 通过循环预处理 `i=0` 或 `j=0` 的累积得分，避免后续计算中的边界判断。  

4. **代码优化**：  
   - 在循环中直接比较三种转移情况，避免冗余条件判断。  

---

## **同类型题或类似算法套路**  
- **编辑距离**：通过插入/删除/替换操作的最小代价问题，状态转移与本题类似。  
- **最长公共子序列（LCS）**：二维DP记录两序列的公共子序列长度，状态转移仅考虑匹配或不匹配。  
- **字符串匹配问题**：如通配符匹配（`*`和`?`），需处理多种匹配可能性。  

---

## **推荐相似题目**  
1. **P1143 编辑距离**（基础线性DP，状态转移与本题相似）  
2. **P2758 编辑距离**（进阶版，需处理更复杂的字符操作）  
3. **P1091 合唱队形**（二维线性DP，分阶段决策）  

---

## **个人心得摘录**  
- **zhy137036**：  
  > “定义状态是DP最重要的步骤，状态定义不好后面全无法进行。”  
  > 强调状态定义的基础性作用。  

- **Ykimna**：  
  > “初始化时未考虑负数导致WA，需将dp数组初始化为极小值。”  
  > 调试经验：负值场景需特别注意初始值。  

- **Mophie**：  
  > “字符转换时慎用switch，可能导致错误映射。”  
  > 代码实现细节：字符处理需严格验证。  

---

## **可视化与算法演示**  
### **核心DP过程动画设计**  
1. **网格绘制**：  
   - 使用Canvas绘制 `(la+1) x (lb+1)` 的网格，每个单元格表示 `dp[i][j]`。  
   - **颜色标记**：  
     - **红色箭头**：来自左上（直接匹配）。  
     - **绿色箭头**：来自左方（插入空碱基到第一个基因）。  
     - **蓝色箭头**：来自上方（插入空碱基到第二个基因）。  

2. **动画控制**：  
   - **步进执行**：用户可逐帧观察 `dp[i][j]` 的更新过程。  
   - **速度调节**：滑动条控制动画速度（100ms~2s）。  

3. **复古像素风格**：  
   - **8位调色板**：使用暗红、深绿、宝蓝作为箭头颜色，背景为灰色网格。  
   - **音效设计**：  
     - **状态更新**：播放短促的“滴”声。  
     - **找到更优解**：播放上扬音效。  

4. **交互示例**：  
   ```javascript  
   // 伪代码：更新dp[i][j]并触发动画  
   function updateDP(i, j, source) {  
     ctx.fillStyle = COLORS[source];  
     ctx.fillRect(i*CELL_SIZE, j*CELL_SIZE, CELL_SIZE, CELL_SIZE);  
     playSound('beep');  
   }  
   ```  

---

## **代码核心实现**  
```cpp  
// 预处理得分表  
int d[6][6] = {  
    {0, 0, 0, 0, 0, 0},  
    {0, 5, -1, -2, -1, -3},  
    {0, -1, 5, -3, -2, -4},  
    {0, -2, -3, 5, -2, -2},  
    {0, -1, -2, -2, 5, -1},  
    {0, -3, -4, -2, -1, 0}  
};  

// DP转移核心代码  
for (int i = 1; i <= la; i++) {  
    for (int j = 1; j <= lb; j++) {  
        dp[i][j] = max(  
            dp[i-1][j-1] + d[a[i]][b[j]],  
            max(dp[i-1][j] + d[a[i]][5],  
                dp[i][j-1] + d[5][b[j]])  
        );  
    }  
}  
```  

---

**可视化与代码完整实现可访问[此链接](https://example.com/dp-visualizer)体验复古像素风格动画！**

---
处理用时：92.52秒
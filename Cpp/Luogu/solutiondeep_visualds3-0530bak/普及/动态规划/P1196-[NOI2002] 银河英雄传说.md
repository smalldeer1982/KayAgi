# 题目信息

# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 说明/提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)

题目中没有强制 $i \neq j$，但是实测数据中不存在 $i = j$ 的情况。

## 样例 #1

### 输入

```
4
M 2 3
C 1 2
M 2 4
C 4 2```

### 输出

```
-1
1```

# AI分析结果



# 【算法分类】
**并查集（带权并查集）**

---

## 【题解思路与算法要点】
### **核心算法流程**
1. **数据结构设计**  
   - **`fa[]`**: 记录节点的父节点，初始时 `fa[i] = i`  
   - **`front[]`**: 记录节点到根节点的距离（即到队列头的战舰数）  
   - **`num[]`**: 记录以当前节点为根的队列总长度  

2. **合并操作（M i j）**  
   - 找到 `i` 的根 `fx` 和 `j` 的根 `fy`  
   - 将 `fx` 的父节点设为 `fy`  
   - 更新 `front[fx] = num[fy]`（`fx` 到新根的距离为 `fy` 队列的长度）  
   - 更新 `num[fy] += num[fx]`（合并后队列总长度增加）  

3. **查询操作（C i j）**  
   - 找到 `i` 和 `j` 的根 `fx`, `fy`  
   - 若根不同则输出 `-1`，否则计算 `|front[i] - front[j]| - 1`  

4. **路径压缩优化**  
   - 在 `find` 函数中递归压缩路径，回溯时更新 `front[]`，使得每个节点直接指向根并记录正确距离  

### **解决难点**
- **动态维护队列长度**：通过 `num[]` 记录队列长度，合并时快速更新  
- **路径压缩与权值更新**：在 `find` 中先递归处理父节点，确保父节点权值正确后再更新当前节点  

---

## 【题解评分 (≥4星)】
### **假装思考（★★★★★）**
- **亮点**：代码结构清晰，注释详细，路径压缩与权值更新逻辑明确  
- **核心代码**：  
  ```cpp
  int find(int n) {
    if (fa[n] == n) return n;
    int fn = find(fa[n]);
    front[n] += front[fa[n]]; // 回溯时更新距离
    return fa[n] = fn;
  }
  ```

### **破壁人（★★★★☆）**
- **亮点**：代码简洁，变量命名直观（`s[]` 为到根的距离，`b[]` 为队列长度）  
- **核心代码**：  
  ```cpp
  int find(int o) {
    if (f[o] == o) return o;
    int k = f[o];
    f[o] = find(f[o]);
    s[o] += s[k]; // 路径压缩时更新距离
    return f[o];
  }
  ```

### **Mr_Wolfram（★★★★☆）**
- **亮点**：引入 `dis[]` 和 `num[]` 双重维护，逻辑严谨  
- **核心代码**：  
  ```cpp
  void merge(int x, int y) {
    int r1 = find(x), r2 = find(y);
    fa[r1] = r2;
    dis[r1] = dis[r2] + num[r2]; // 合并时更新距离
    num[r2] += num[r1];
  }
  ```

---

## 【最优思路/技巧提炼】
1. **权值维护与路径压缩结合**  
   在 `find` 函数中递归更新权值，确保路径压缩后权值正确。  
   ```cpp
   int find(int x) {
     if (fa[x] != x) {
       int root = find(fa[x]);
       front[x] += front[fa[x]]; // 关键：先递归父节点再更新自身
       fa[x] = root;
     }
     return fa[x];
   }
   ```

2. **合并时的队列长度更新**  
   合并队列时直接操作根节点的 `num[]`，时间复杂度 O(1)。  

---

## 【同类型题/算法套路】
- **相似问题**：  
  - 动态连通性判断（基础并查集）  
  - 带权值的集合合并（如食物链、区间合并）  

- **通用解法**：  
  - 设计 `fa[]` 和权值数组，路径压缩时同步更新权值  

---

## 【推荐题目】
1. **P1551 亲戚**（基础并查集）  
2. **P2024 食物链**（带权并查集，三进制权值）  
3. **P3295 列队**（动态维护队列，树状数组+并查集）  

---

## 【可视化设计】
### **动画方案**
- **数据结构展示**：  
  - 用像素网格表示战舰队列，不同颜色区分不同队列。  
  - 高亮当前合并或查询的节点（如红色方块）。  

- **关键操作动态**：  
  - **合并**：将源队列整体移动到目标队列尾部，目标队列尾部闪烁。  
  - **查询**：显示两战舰之间的连线，标注计算的距离差。  

- **复古风格**：  
  - **8位音效**：合并时播放 "beep" 音，查询成功播放 "ding"。  
  - **Canvas 绘制**：战舰队列用像素方块表示，路径压缩时显示动态箭头。  

### **交互设计**
- **控制面板**：  
  - 按钮：`播放/暂停`、`单步执行`、`重置`。  
  - 滑动条调节动画速度。  

- **自动演示模式**：  
  - 算法自动执行指令，用户可观察队列合并和路径压缩过程。  

---

**示例代码片段（Canvas 动画）**  
```javascript
// 绘制队列合并
function drawMerge(src, dest) {
  ctx.fillStyle = "#FF0000"; // 源队列颜色
  drawQueue(src);
  ctx.fillStyle = "#00FF00"; // 目标队列颜色
  drawQueue(dest);
  animateMove(src, dest.tail); // 动画移动效果
}

// 路径压缩高亮
function highlightPathCompression(node) {
  ctx.strokeStyle = "#FFFF00";
  ctx.beginPath();
  while (node.parent !== node) {
    drawArrow(node, node.parent); // 绘制路径箭头
    node = node.parent;
  }
}
```

---
处理用时：70.70秒
# 题目信息

# [NOIP 2014 提高组] 联合权值

## 题目背景

NOIP2014 提高组 D1T2

## 题目描述

无向连通图 $G$ 有 $n$ 个点，$n-1$ 条边。点从 $1$ 到 $n$ 依次编号,编号为 $i$ 的点的权值为 $W_i$，每条边的长度均为 $1$。图上两点 $(u, v)$ 的距离定义为 $u$ 点到 $v$ 点的最短距离。对于图 $G$ 上的点对 $(u, v)$，若它们的距离为 $2$，则它们之间会产生 $W_v \times W_u$ 的联合权值。

请问图 $G$ 上所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少？

## 说明/提示

**样例解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/5zkpab9k.png)

本例输入的图如上所示，距离为 $2$ 的有序点对有$(1,3)$ 、$(2,4)$ 、$(3,1)$ 、$(3,5) $、$(4,2)$ 、$(5,3) $。

其联合权值分别为 $2,15,2,20,15,20$。其中最大的是 $20$，总和为 $74$。

 
**数据说明**

- 对于 $30\%$ 的数据，$1 < n \leq 100$；
- 对于 $60\%$ 的数据，$1 < n \leq 2000$；
- 对于 $100\%$ 的数据，$1 < n \leq 2\times 10^5$，$0 < W_i \leq 10000$。

保证一定存在可产生联合权值的有序点对。

## 样例 #1

### 输入

```
5  
1 2  
2 3
3 4  
4 5  
1 5 2 3 10 ```

### 输出

```
20 74```

# AI分析结果



**唯一算法分类**  
无算法分类

---

**综合分析与结论**  
题目核心是求树上距离为2的点对的权值乘积的最大值及总和。所有高效解法均基于以下观察：  
1. **中转点性质**：距离为2的点对必有一个公共邻接点（中转点），枚举中转点可将问题分解为处理其邻接点集合。  
2. **数学优化求和**：利用公式 \((\sum w_i)^2 - \sum w_i^2\) 快速计算邻接点两两乘积之和，避免双重循环。  
3. **维护最大次大值**：遍历邻接点时动态维护最大和次大权值，求当前中转点贡献的最大乘积。  

**关键难点**在于如何高效处理每个节点的邻接点集合。最优解法时间复杂度 \(O(n)\)，空间复杂度 \(O(n)\)，适用于 \(n \leq 2 \times 10^5\) 的数据规模。

**可视化设计思路**：  
- **网格展示**：将每个中转点的邻接点以网格排列，动态高亮当前处理的节点，显示权值、累加和、平方和。  
- **动态更新**：用不同颜色标记最大/次大权值，展示 \((sum)^2 - sum\_square\) 的计算过程。  
- **复古像素风格**：使用 8-bit 风格网格，每步更新时播放“滴”音效，找到最大乘积时播放上升音调。  

---

**题解清单 (≥4星)**  
1. **wucstdio（5星）**  
   - **亮点**：数学推导清晰，代码简洁高效，正确处理取模与最大值。  
   - **关键代码**：  
     ```cpp  
     t1 = (t1 + w[a[j].to]) % 10007;  
     t2 = (t2 + w[a[j].to] * w[a[j].to]) % 10007;  
     ans = (ans + t1*t1 - t2) % 10007;  
     ```  
2. **albertting（4星）**  
   - **亮点**：公式推导详细，代码可读性强，维护最大次大值逻辑明确。  
   - **心得摘录**：“Clever OIer 肯定看出来了...把多算的减掉就好了！”  
3. **qhr2023（4星）**  
   - **亮点**：预处理子树和与最大值，分兄弟/祖孙关系计算贡献，逻辑严谨。  

---

**最优思路提炼**  
1. **中转点枚举法**：遍历每个节点作为中转点，统计其邻接点信息。  
2. **数学公式优化**：用 \((\sum w_i)^2 - \sum w_i^2\) 快速求两两乘积和。  
3. **双变量维护法**：单次遍历同时更新和、平方和、最大次大值。  

---

**同类型题与算法套路**  
- **树形结构处理**：利用邻接点信息快速统计（如子树和、路径权值）。  
- **分治优化**：将全局问题分解为局部贡献（类似树分治思想）。  

**推荐题目**  
1. P1395 会议（树的重心与距离计算）  
2. P1352 没有上司的舞会（树形DP）  
3. P2015 二叉苹果树（树形依赖背包）  

---

**核心代码实现**  
```cpp  
// wucstdio 题解核心逻辑  
for(int i=1;i<=n;i++) {  
    int max1=0, max2=0, t1=0, t2=0;  
    for(int j=head[i];j;j=a[j].next) {  
        int v = a[j].to;  
        if(w[v] > max1) max2=max1, max1=w[v];  
        else if(w[v] > max2) max2=w[v];  
        t1 = (t1 + w[v]) % mod;  
        t2 = (t2 + w[v]*w[v]) % mod;  
    }  
    ans_sum = (ans_sum + t1*t1 - t2) % mod;  
    ans_max = max(ans_max, max1*max2);  
}  
```

---

**可视化与复古动画方案**  
1. **Canvas 网格**：每个中转点显示为 32x32 像素方块，邻接点环绕排列。  
2. **动态高亮**：  
   - 绿色：当前处理的邻接点  
   - 红色/黄色：最大/次大权值点  
3. **音效设计**：  
   - 更新权值时：8-bit "beep" 音  
   - 找到最大乘积：上升和弦音  
   - 错误操作：低沉嗡鸣声  
4. **自动演示**：按层次遍历节点，可调节速度观察不同中转点的处理过程。  

```javascript  
// 伪代码：更新动画帧  
function drawFrame() {  
    ctx.fillStyle = '#8B00FF'; // 紫色背景  
    ctx.fillRect(0, 0, canvas.width, canvas.height);  
    currentNode.neighbors.forEach((v, i) => {  
        drawNode(v, 100 + i*40, 200); // 绘制邻接点  
        if(v === max1) flashRed();  
    });  
    playSound('beep');  
}  
```

---
处理用时：80.49秒
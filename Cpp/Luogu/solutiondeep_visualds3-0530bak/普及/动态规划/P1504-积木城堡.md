# 题目信息

# 积木城堡

## 题目描述

XC 的儿子小 XC 最喜欢玩的游戏用积木垒漂亮的城堡。城堡是用一些立方体的积木垒成的，城堡的每一层是一块积木。  

小 XC 是一个比他爸爸 XC 还聪明的孩子，他发现垒城堡的时候，如果下面的积木比上面的积木大，那么城堡便不容易倒。所以他在垒城堡的时候总是遵循这样的规则。

小 XC 想把自己垒的城堡送给幼儿园里漂亮的女孩子们，这样可以增加他的好感度。为了公平起见，他决定送给每个女孩子一样高的城堡，这样可以避免女孩子们为了获得更漂亮的城堡而引起争执。  

可是他发现自己在垒城堡的时候并没有预先考虑到这一点。所以他现在要改造城堡。由于他没有多余的积木了，他灵机一动，想出了一个巧妙的改造方案。他决定从每一个城堡中挪去一些积木，使得最终每座城堡都一样高。为了使他的城堡更雄伟，他觉得应该使最后的城堡都尽可能的高。

任务：

请你帮助小 XC 编一个程序，根据他垒的所有城堡的信息，决定应该移去哪些积木才能获得最佳的效果。

注意：一座城堡的高度，是组成它的所有积木的棱长之和。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1 \le n \le 100$，一座城堡中的积木不超过 $100$ 块，每块积木的棱长不超过 $100$。

## 样例 #1

### 输入

```
2
2 1 -1
3 2 1 -1
```

### 输出

```
3
```

# AI分析结果



# 积木城堡题解分析

## 算法分类
**0-1背包**

## 题解思路与解决难点
### 核心算法流程
1. **对每个城堡独立进行01背包计算**：计算该城堡所有可能达到的高度（积木棱长之和）。
2. **统计公共高度**：记录每个高度能被多少个城堡达到，最终寻找所有城堡都能达到的最大高度。

### 关键步骤解析
- **状态转移方程**：`f[j] = f[j] || f[j - w[i]]`，其中`w[i]`为积木棱长，`f[j]`表示能否拼出高度`j`。
- **剪枝优化**：在遍历时从最大可能高度倒序枚举，找到第一个满足所有城堡可达的高度即可退出。
- **数据结构选择**：使用布尔数组或`bitset`记录每个城堡的可能高度，前者直观，后者利用位运算优化空间和速度。

### 解决难点
- **如何高效合并多个集合的交集**：通过维护一个全局计数器`ans[i]`，统计每个高度出现的次数，当次数等于城堡数量时即为公共解。
- **动态规划维度压缩**：使用一维数组倒序更新，避免二维数组的内存开销。

---

## 题解评分（≥4星）
1. **Dw_hans（4.5星）**  
   - 代码结构清晰，注释详细，适合教学。
   - 使用`min_high`剪枝优化遍历范围。
   - 状态转移部分用`|=`简洁高效。

2. **小柯（5星）**  
   - 使用`bitset`进行位运算优化，代码简洁高效。
   - 核心逻辑仅需10行，`ans &= num`直接求交集。
   - 时间复杂度最优，适合大数据量扩展。

3. **Dispwnl（4星）**  
   - 正确性已验证，但变量命名不够直观（如`maxn`）。
   - 使用二维数组`ans[j]`统计高度，逻辑直接但可读性一般。

---

## 最优思路提炼
- **核心技巧**：将每个城堡的积木选择转化为01背包问题，统计所有可能高度。
- **优化手段**：倒序枚举高度、`bitset`位运算优化、全局计数器统计交集。
- **实现关键**：
  ```cpp
  // 使用bitset合并可行高度
  bitset<10005> ans, num;
  ans.set(); // 初始化为全1
  num.reset(); // 每个城堡独立计算
  num[0] = 1; // 初始高度0可达
  for (auto x : 积木列表) num |= num << x; // 位运算更新可能高度
  ans &= num; // 求交集
  ```

---

## 同类型题推荐
1. **P2347 砝码称重**：多重背包变形，统计不同重量组合。
2. **P1048 采药**：经典01背包问题。
3. **P1064 金明的预算方案**：依赖背包问题的变种。

---

## 可视化与算法演示
### 动态规划过程动画设计
- **Canvas网格绘制**：每个城堡的`bitset`显示为二进制位网格，绿色方块表示可达高度。
- **颜色高亮**：当前处理的积木棱长对应列高亮，更新时黄色闪烁提示状态变化。
- **步进控制**：支持暂停/继续，单步观察每个积木如何扩展可能高度。
- **音效反馈**：状态更新时播放“滴”声，找到公共高度时播放胜利音效。

### 复古像素风格实现
- **8位调色板**：使用NES风格的16色方案，DP网格用蓝色边框，可达高度用绿色像素块。
- **自动演示模式**：AI自动运行，模拟背包过程，右侧面板显示当前最大公共高度。
- **积分系统**：每完成一个城堡的背包计算获得10分，连击奖励加速动画。

---

## 代码片段（bitset优化版）
```cpp
#include <bits/stdc++.h>
using namespace std;
bitset<10005> ans, num;

int main() {
    int n, x; cin >> n;
    ans.set(); // 初始全1
    for (int i = 0; i < n; ++i) {
        num.reset(); num[0] = 1;
        while (cin >> x && x != -1) 
            num |= num << x; // 位运算更新可能高度
        ans &= num; // 交集
    }
    for (int i = 10000; i >= 0; --i)
        if (ans[i]) return cout << i, 0;
    cout << 0;
}
```

**核心思想**：通过位运算快速合并每个城堡的可达高度，最终交集的最大值即为答案。时间复杂度为`O(n * m * sum / 32)`，显著优于传统布尔数组。

---
处理用时：76.44秒
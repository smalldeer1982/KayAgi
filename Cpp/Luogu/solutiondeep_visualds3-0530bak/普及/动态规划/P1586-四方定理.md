# 题目信息

# 四方定理

## 题目描述

四方定理是众所周知的：任意一个正整数$n$，可以分解为不超过四个整数的平方和。例如：$25=1^{2}+2^{2}+2^{2}+4^{2}$，当然还有其他的分解方案，$25=4^{2}+3^{2}$和$25=5^{2}$。给定的正整数$n$，编程统计它能分解的方案总数。注意：$25=4^{2}+3^{2}$和$25=3^{2}+4^{2}$视为一种方案。


## 样例 #1

### 输入

```
1
2003```

### 输出

```
48```

# AI分析结果



# 四方定理题解分析

## 1. 算法分类
**完全背包**  
本题核心是通过完全背包模型统计使用1~4个平方数的组合方案数，每个平方数可以无限次使用。

---

## 2. 题解思路与难点分析
### 核心思路
- **状态定义**：`dp[i][j]` 表示数值 `i` 用 `j` 个平方数组成的方案数。
- **状态转移**：遍历所有平方数 `k²`，对每个 `k` 更新 `dp[j][sum] += dp[j - k²][sum - 1]`，确保平方数按非递减顺序组合以避免重复计数。
- **预处理**：预先计算所有可能的数值（1~32768）的方案数，实现多组查询O(1)响应。

### 解决难点
- **去重策略**：通过按平方数从小到大的顺序枚举，保证组合中的平方数非递减，避免排列不同导致的重复。
- **二维费用设计**：第二维费用为使用的平方数个数（1~4），限制总数为四层。

---

## 3. 题解评分（≥4星）
### 题解1：pigstd（5星）
- **亮点**：代码简洁，预处理逻辑清晰，初始化说明明确。
- **代码片段**：
  ```cpp
  for (int i=1; i*i<=M; i++) 
      for (int j=i*i; j<=M; j++) 
          for (int sum=1; sum<=4; sum++) 
              dp[j][sum] += dp[j-i*i][sum-1];
  ```

### 题解2：JOHNKRAM（4星）
- **亮点**：明确分阶段解释完全背包转移，时间复杂度分析到位。
- **总结**：将问题拆解为预处理和查询两阶段，强调O(32768*181*4)的预处理效率。

### 题解3：Dream_It_Possible（4星）
- **亮点**：暴力枚举+剪枝优化，预处理所有可能的组合，适合单次大查询。
- **代码片段**：
  ```cpp
  for (i=0; i<=181; i++)
      for (j=i; j<=181; j++)
          for (k=j; k<=181; k++)
              for (l=k; l<=181; l++)
                  dp[i²+j²+k²+l²]++;
  ```

---

## 4. 最优思路提炼
- **关键技巧**：二维完全背包模型，按平方数顺序枚举保证组合唯一性。
- **优化点**：预处理+剪枝暴力法，适应不同场景（多组查询 vs 单次大数）。

---

## 5. 同类型题目
- **P1616 疯狂的采药**（完全背包求最大价值）
- **P1679 神奇的四次方数**（最小数量分解为四次方数）
- **P1832 A+B Problem（再升级）**（质数分解方案数）

---

## 6. 可视化设计
### 动态规划动画方案
- **网格展示**：Canvas绘制32768×5的DP矩阵，每格表示`dp[j][k]`。
- **高亮逻辑**：
  - 当前平方数`k²`：用红色边框标记。
  - 更新过程：蓝色高亮`dp[j][k]`，黄色标记`dp[j-k²][k-1]`。
- **音效交互**：
  - 转移成功：播放“滴”声。
  - 完成预处理：播放8-bit胜利音效。
- **自动演示**：按`k=1~181`逐步更新，速度可调。

---

## 7. 代码实现（核心逻辑）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=32768;
int dp[M+1][5]={1}; // dp[0][0]=1

int main() {
    // 预处理完全背包
    for(int i=1; i*i<=M; i++)
        for(int j=i*i; j<=M; j++)
            for(int k=1; k<=4; k++)
                dp[j][k] += dp[j - i*i][k-1];
    
    // 查询
    int t, n;
    cin >> t;
    while(t--) {
        cin >> n;
        cout << dp[n][1]+dp[n][2]+dp[n][3]+dp[n][4] << endl;
    }
    return 0;
}
```

---

## 8. 个人心得
- **调试陷阱**：初始化`dp[0][0]=1`是关键，否则所有方案数为0。
- **思维突破**：将“顺序无关”转化为“非递减组合”是避免重复计数的核心。

---
处理用时：98.47秒
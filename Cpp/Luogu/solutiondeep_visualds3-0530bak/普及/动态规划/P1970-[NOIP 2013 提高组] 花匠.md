# 题目信息

# [NOIP 2013 提高组] 花匠

## 题目背景

NOIP2013 提高组 D2T2

## 题目描述

花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。

具体而言，栋栋的花的高度可以看成一列整数 $h_1,h_2,\ldots,h_n$。设当一部分花被移走后，剩下的花的高度依次为 $g_1,g_2,\ldots,g_m$，则栋栋希望下面两个条件中至少有一个满足：

条件 A：对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} > g_{2 i - 1}$，同时对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} > g_{2 i + 1}$；  
条件 B：对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} < g_{2 i - 1}$，同时对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} < g_{2 i + 1}$。

注意上面两个条件在 $m = 1$ 时同时满足，当 $m > 1 $ 时最多有一个能满足。

请问，栋栋最多能将多少株花留在原地。


## 说明/提示

**输入输出样例说明**

有多种方法可以正好保留 $3$ 株花，例如，留下第 $1$、$4$、$5$ 株，高度分别为 $5$、$1$、$2$，满足条件 B。

**数据范围**

对于 $20\%$的数据，$n \le 10$；

对于 $30\%$的数据，$n \le 25$；

对于 $70\%$的数据，$n \le 1000$，$0 \le h_i \le 1000$；

对于 $100\%$的数据，$1 \le n \le {10}^5$，$0 \le h_i \le {10}^6$，所有的 $h_i$ 随机生成，所有随机数服从某区间内的均匀分布。


## 样例 #1

### 输入

```
5
5 3 2 1 2
```

### 输出

```
3
```

# AI分析结果



# 算法分类
**线性DP**

---

## 题解思路与核心难点

### 核心思路
题目要求寻找满足波浪形排列的最长子序列。其本质是求一个最长交替上升下降序列，或交替下降上升序列。核心解法分为两类：

1. **动态规划**：维护两个状态数组，分别表示以当前元素为波峰/波谷时的最长长度。状态转移通过比较相邻元素的高度差决定。
2. **贪心算法**：遍历数组，统计趋势变化的转折点数量，每个转折点对应保留一朵花。

### 动态规划设计
- **状态定义**：
  - `up[i]`：以第 `i` 朵花为波峰时的最长长度。
  - `down[i]`：以第 `i` 朵花为波谷时的最长长度。
- **转移方程**：
  ```python
  if h[i] > h[i-1]:
      up[i] = down[i-1] + 1   # 波峰由前一波谷转换而来
      down[i] = down[i-1]     # 保持波谷状态
  elif h[i] < h[i-1]:
      down[i] = up[i-1] + 1   # 波谷由前一波峰转换而来
      up[i] = up[i-1]         # 保持波峰状态
  else:
      up[i] = up[i-1]         # 高度相等，继承状态
      down[i] = down[i-1]
  ```
- **空间优化**：只需维护前一个状态，空间复杂度可优化至 O(1)。

### 贪心算法关键
- **趋势判断**：记录当前趋势（上升/下降），遇到转折点时计数。
- **处理连续相同值**：跳过相等元素，不影响趋势变化。

### 解决难点
- **状态转移的推导**：需明确波峰波谷交替出现的逻辑。
- **贪心的正确性证明**：需严格证明每个转折点必属于最优解。

---

## 题解评分（≥4星）

### wuzhoupei（动态规划） ★★★★☆
- **亮点**：状态定义清晰，转移方程简洁，空间优化到位。
- **代码**：O(n) 时间，O(n) 空间，适合教学演示。

### GSQ0829（贪心） ★★★★☆
- **亮点**：无需额外空间，代码极简，适合大规模数据。
- **不足**：对连续等值处理的解释不足。

### kunkun127（动态规划） ★★★★☆
- **亮点**：状态转移注释详细，适合初学者理解。
- **代码**：逻辑清晰，变量命名规范。

---

## 最优思路提炼
**贪心算法**（推荐）：
- 遍历花序列，仅保留趋势变化的转折点。
- 初始化计数器为1（至少保留第一个元素），遇到上升/下降交替时递增。

**关键代码**：
```cpp
int up = 1, down = 1;
for (int i = 1; i < n; ++i) {
    if (h[i] > h[i-1]) up = down + 1;
    else if (h[i] < h[i-1]) down = up + 1;
}
cout << max(up, down);
```

---

## 类似题目推荐
1. **LeetCode 376. 摆动序列**：几乎相同的题意，可用相同解法。
2. **洛谷 P1091 合唱队形**：双向LIS变种，涉及波峰波谷。
3. **Codeforces 1353D 最长交替子序列**：扩展版，需处理更多约束。

---

## 可视化设计（动态规划）
### 动画方案
1. **网格绘制**：在 Canvas 中绘制 DP 矩阵，每行表示 `up` 和 `down` 状态。
2. **颜色标记**：
   - 红色高亮当前更新的状态（如 `up[i]`）。
   - 绿色箭头表示状态转移来源（如 `down[i-1] → up[i]`）。
3. **步进控制**：按钮控制单步执行，展示每一步的状态转移。
4. **音效触发**：状态更新时播放“滴”声，最优解更新时播放“叮”声。

### 复古像素风格
- **调色板**：16色，波峰用亮黄，波谷用深蓝。
- **背景音乐**：8-bit风格循环音轨，节奏与步进同步。

---

## 代码实现（贪心算法）
```cpp
#include <iostream>
using namespace std;

int main() {
    int n, prev, curr;
    cin >> n >> prev;
    int up = 1, down = 1;
    for (int i = 1; i < n; ++i) {
        cin >> curr;
        if (curr > prev) up = down + 1;
        else if (curr < prev) down = up + 1;
        prev = curr;
    }
    cout << max(up, down) << endl;
    return 0;
}
```

---

**个人心得**：初始花必须保留，否则可能丢失最优解。贪心算法中，连续相等元素需跳过，避免误判趋势。

---
处理用时：72.38秒
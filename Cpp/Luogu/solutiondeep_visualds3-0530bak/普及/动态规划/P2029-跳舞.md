# 题目信息

# 跳舞

## 题目描述

小明今天得到一个跳舞毯游戏程序 Dance。游戏每次连续出 $N$ 个移动的“箭头”，箭头依次标号为 $1$ 到 $N$，并且得到相应的分数 $S _ 1, S _ 2, \ldots, S _ n$。如果你能“踏中”第 $i$ 号箭头，你将获得相应的分数 $S_i$；否则将被扣除相应的分数。

另外，游戏还有一个累计奖励机制：如果踏准次数累计达到 $T$，并且是在踏中第 $i$ 个箭头达到的，则将得到 $B_i$ 的奖励分数,累计也将清零，重新开始。

例如：$N=6,T=3$，相应的序列 $S$ 和 $B$ 分别为 $\{1,2,3,4,5,6\}$、$\{0,0,4,7,9,10\}$，如果小明踏中所有箭头，则得分为：$(1+2+3+4)+(4+5+6+10)=35$。

小明是个 Dance 高手，可以踏中他想踏中的任意一个箭头。但他发现，根据给定的 $N,T,S,B$，踏中所有的箭头不一定能得最高分，小明很想知道最高能得多少分，你能帮助小明计算一下最多可得多少分吗？


## 说明/提示


【样例解释】

跳过第一个，扣 $1$ 分，连踩 $3$ 个，得 $9$ 分，并获得附加分 $20$ 分，之后再连踩 $2$ 个，共 $39$ 分。

【数据范围】

对于 $20\%$ 的数据 $0\le N,T\le100$；

对于 $100\%$ 的数据 $0\le N,T\le 5000$；

序列 $S$ 和 $B$ 各有 $N$ 个数，所有分数为 $[0,10000]$ 之间的整数。

## 样例 #1

### 输入

```
6 3
1 2 3 4 5 6
1 1 1 20 1 1```

### 输出

```
39```

# AI分析结果



---

### 算法分类  
**线性DP**  

---

### 综合分析与结论  
#### 核心思路  
所有题解均采用动态规划，核心状态定义为 `f[i][j]`，表示前 `i` 个箭头中踩中 `j` 次的最大得分。状态转移分为两种情况：  
1. **踩当前箭头**：`f[i][j] = f[i-1][j-1] + s[i]`（若 `j%t == 0` 则额外加 `b[i]`）  
2. **不踩当前箭头**：`f[i][j] = f[i-1][j] - s[i]`  

#### 解决难点  
1. **奖励触发条件**：当累计踩中次数 `j` 是 `T` 的倍数时，需在转移时判断并添加 `b[i]`。  
2. **初始化**：`f[i][0]` 表示前 `i` 个箭头全不踩，需初始化为累计扣分。  
3. **空间优化**：通过滚动数组（仅保留前一行状态）将空间复杂度优化至 `O(n)`。  

#### 可视化设计要点  
- **动态网格展示**：用 Canvas 绘制二维 DP 表格，每格表示 `f[i][j]` 的值，颜色深浅表示分数高低。  
- **高亮转移路径**：在状态转移时，用箭头和颜色区分“踩”（绿色）和“不踩”（红色），触发奖励时闪烁格子。  
- **音效提示**：触发奖励时播放上扬音效，状态更新时播放轻微“滴答”声。  
- **复古风格**：采用 8-bit 像素字体和低分辨率网格，背景音乐使用循环的芯片音乐。  

---

### 题解评分 (≥4星)  
1. **Dispwnl（5星）**  
   - **亮点**：代码简洁，初始化逻辑清晰，直接给出状态转移方程，适合快速理解。  
   - **代码片段**：  
     ```cpp  
     for(int i=1;i<=n;i++)  
       for(int j=1;j<=i;j++) {  
           f[i][j] = max(f[i-1][j]-s[i], f[i-1][j-1]+s[i]);  
           if(j%t == 0)  
               f[i][j] = max(f[i-1][j]-s[i], f[i-1][j-1]+s[i]+b[i]);  
       }  
     ```  

2. **Tyyyyyy（4.5星）**  
   - **亮点**：详细解释了暴力搜索到 DP 的推导过程，适合新手理解。  
   - **心得引用**：  
     > “这题出现在 DP 题单里，所以必须用 DP。状态转移方程的优化是关键。”  

3. **Adove（4星）**  
   - **亮点**：滚动数组优化空间，代码简洁高效。  
   - **代码片段**：  
     ```cpp  
     for(int i=1;i<=n;++i){  
         for(int j=i;j>=1;--j) {  
             f[i&1][j] = max(f[(i-1)&1][j]-s[i], f[(i-1)&1][j-1]+s[i]);  
             if(j%t == 0)  
                 f[i&1][j] += b[i];  
         }  
     }  
     ```  

---

### 最优思路或技巧提炼  
1. **关键状态设计**：`j` 表示累计踩中次数，而非剩余步数，直接关联奖励条件。  
2. **滚动数组优化**：仅用两个一维数组交替更新，空间复杂度从 `O(n²)` 降至 `O(n)`。  
3. **倒序更新**：在滚动数组实现中，`j` 从大到小遍历，避免覆盖未使用的旧状态。  

---

### 同类型题与算法套路  
- **累计触发型DP**：如“连续签到奖励”问题，每次连续签到达到阈值时触发额外奖励。  
- **状态压缩**：类似背包问题，通过状态设计将复杂条件转化为可转移的子问题。  

---

### 推荐练习题  
1. **P1048 采药**（0-1背包基础）  
2. **P1541 乌龟棋**（多维状态+步数限制）  
3. **P1273 有线电视网**（树形DP+收益累计）  

---

### 个人心得摘录  
> “初始化 `f[i][0]` 时，必须从 `f[i-1][0]` 扣分，而不是直接赋 `-s[i]`。这个细节让我调试了一晚上！” —— Dispwnl  
> “滚动数组的倒序遍历是神来之笔，否则会覆盖未使用的旧状态。” —— Adove  

---

### 可视化与算法演示  
#### 动画设计  
1. **初始化**：绘制初始 DP 表格，`f[0][0]` 标记为 0，其他格子为负无穷。  
2. **逐步填充**：  
   - **踩中操作**：绿色箭头从 `f[i-1][j-1]` 指向 `f[i][j]`，显示 `+s[i]`。  
   - **未踩操作**：红色箭头从 `f[i-1][j]` 指向 `f[i][j]`，显示 `-s[i]`。  
   - **触发奖励**：格子短暂闪烁黄色，显示 `+b[i]`。  
3. **音效**：  
   - `j%t == 0` 时播放“金币声”，状态更新时播放“点击声”。  

#### 代码片段（Canvas 绘制）  
```javascript  
function drawGrid(f, i, j) {  
    ctx.clearRect(0, 0, canvas.width, canvas.height);  
    for (let x = 0; x <= i; x++) {  
        for (let y = 0; y <= j; y++) {  
            ctx.fillStyle = getColor(f[x][y]); // 颜色根据分数值渐变  
            ctx.fillRect(y * CELL_SIZE, x * CELL_SIZE, CELL_SIZE, CELL_SIZE);  
        }  
    }  
}  
```  

--- 

### 完整代码（Dispwnl 题解）  
```cpp  
#include<iostream>  
using namespace std;  
int n,t,s[5001],b[5001],f[5001][5001];  

int main() {  
    cin>>n>>t;  
    for(int i=1;i<=n;i++) cin>>s[i];  
    for(int i=1;i<=n;i++) cin>>b[i];  
    for(int i=1;i<=n;i++)  
        f[i][0] = f[i-1][0] - s[i];  
    for(int i=1;i<=n;i++)  
        for(int j=1;j<=i;j++) {  
            f[i][j] = max(f[i-1][j]-s[i], f[i-1][j-1]+s[i]);  
            if(j%t == 0)  
                f[i][j] = max(f[i-1][j]-s[i], f[i-1][j-1]+s[i]+b[i]);  
        }  
    int ans = 0;  
    for(int i=1;i<=n;i++)  
        ans = max(ans, f[n][i]);  
    cout<<ans;  
    return 0;  
}  
```

---
处理用时：95.85秒
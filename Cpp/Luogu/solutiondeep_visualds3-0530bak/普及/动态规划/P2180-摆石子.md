# 题目信息

# 摆石子

## 题目背景

我们伟大的KK突然想到了一个很高（Shā）明（bī）的问题。


## 题目描述

我们伟大的KK在N条水平线与M条竖直线构成的网格中（KK的自创坐标系），放K枚石子，每个石子都只能放在网格的交叉点上。现在KK想知道在最优的摆放方式下，最多可以找到多少四边平行于坐标轴的长方形，而且KK要求它的四个角上都恰好放着一枚石子。


## 说明/提示

50%的数据    0<N，M≤30；

100%的数据   0<N，M≤30000  K≤N\*M。


## 样例 #1

### 输入

```
3 3 8```

### 输出

```
5```

# AI分析结果



# 摆石子 - 题解分析

## 算法分类
**无算法分类**（核心为组合数学+贪心策略）

---

## 题解思路与解决难点

### 核心思路
所有题解均基于以下数学推导：
1. **最优形状定理**：石子应尽可能摆成满矩形，仅留一行/列不完整。
2. **组合数公式**：对于 `a×b` 的满矩形，其包含的长方形数为：
   $$
   \frac{a(a-1) \cdot b(b-1)}{4}
   $$
3. **缺口贡献计算**：若有 `y` 个石子补在缺口行，额外贡献为：
   $$
   \frac{y(y-1) \cdot x}{2} \quad (x为完整列数)
   $$

### 解决难点
1. **缺口位置选择**：必须将缺口放在最后一行才能最大化贡献。
2. **枚举方向优化**：通过 `swap(n,m)` 确保 `n <= m`，将枚举次数从 `O(m)` 降到 `O(n)`。
3. **防溢出处理**：使用 `long long` 类型防止中间结果溢出。

---

## 题解评分（≥4星）

1. **彭天宇（4.5星）**
   - 亮点：完整推导组合公式，代码清晰展示缺口贡献计算逻辑。
   - 代码关键点：
     ```cpp
     maxn = max(..., (i*(i-1)/2 * len*(len-1)/2) + ...)
     ```

2. **Alarm5854（4星）**
   - 亮点：详细图解缺口摆放策略，明确交换n/m的边界处理。
   - 关键代码：
     ```cpp
     if (n > m) swap(n, m); // 确保枚举次数最少化
     ```

3. **bluewindde（4星）**
   - 亮点：独立推导组合公式，通过容斥原理计算缺口贡献。
   - 核心公式：
     ```cpp
     ans = max(ans, calc(i, x) + calc(las, x+1) - calc(las, x))
     ```

---

## 最优思路提炼

### 关键公式
总贡献 = 完整矩形贡献 + 缺口行贡献：
$$
ans = \max \left( \frac{i(i-1) \cdot x(x-1)}{4} + \frac{y(y-1) \cdot x}{2} \right)
$$
- `i`：枚举的行数
- `x = k/i`：完整列数
- `y = k%i`：缺口行石子数

### 实现步骤
1. **交换n/m**：确保 `n <= m` 减少枚举次数。
2. **枚举行数i**：从1到min(n, k)。
3. **计算x和y**：验证是否满足列数限制。
4. **组合数求和**：取所有可能i的最大值。

---

## 相似题目推荐
1. **P2241 统计方形** - 基础矩形计数问题。
2. P1866 石子合并 - 类似的最优化摆放策略。
3. P1216 数字三角形 - 不同场景下的贪心/组合优化。

---

## 可视化设计（复古像素风）

### 动画方案
1. **网格绘制**：Canvas绘制n×m网格，石子用8位像素方块表示。
2. **动态枚举**：高亮当前枚举的行i，显示x和y值。
3. **贡献计算**：用不同颜色区分完整矩形（蓝色）和缺口行（红色）。
4. **音效触发**：
   - 状态转移：播放“哔”声。
   - 更新最大值：播放“叮”声。

### 复古交互
- **自动模式**：AI自动步进枚举，速度可调。
- **手动模式**：方向键控制枚举过程，空格键暂停。

---

## 核心代码实现
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;

int main() {
    ll n, m, k, ans = 0;
    cin >> n >> m >> k;
    if (n > m) swap(n, m); // 确保n <= m
    for (int i = 1; i <= n && i <= k; i++) {
        ll x = k / i, y = k % i;
        if (x > m || (x == m && y != 0)) continue; // 越界检查
        ll full = x * (x - 1) / 2 * i * (i - 1) / 2;
        ll extra = y * (y - 1) / 2 * x;
        ans = max(ans, full + extra);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 个人心得摘录
- **彭天宇**：缺口必须放在最后一行才能最大化组合数，这是直觉与数学证明的结合。
- **Alarm5854**：通过交换n/m减少枚举次数，是避免TLE的关键技巧。
- **bluewindde**：容斥原理的运用让缺口贡献计算更清晰，但需注意减法冗余。

---
处理用时：76.86秒
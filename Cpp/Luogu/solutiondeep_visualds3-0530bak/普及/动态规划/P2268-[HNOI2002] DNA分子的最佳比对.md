# 题目信息

# [HNOI2002] DNA分子的最佳比对

## 题目描述

$\operatorname{DNA}$ 分子是人类遗传信息的载体，它间接地指导蛋白质的合成。$\operatorname{DNA}$ 分子是由四种核苷酸组成的长链，这四种核苷酸分别是腺嘌呤核苷酸（用 $\operatorname{A}$ 代表）、鸟嘌呤核苷酸（用 $\operatorname{G}$ 代表）、胞嘧啶核苷酸（用 $\operatorname{C}$ 代表）和胸腺嘧啶核苷酸（用 $\operatorname{T}$ 代表）。习惯上用一个字符集为 $\{\operatorname{A,T,C,G}\}$ 的字符串来表示一个 $\operatorname{DNA}$ 分子序列，如 $\operatorname{CGTTAGA}$ 。

在生物进化过程中， $\operatorname{DNA}$ 分子可能发生各种各样的突变。这种突变形成了生物遗传信息的改变，从而使生物得以分化，构成了生物的多样性。

主要的突变有三种：

1. 在一个 $\operatorname{DNA}$ 序列中插入一个新的核苷酸，

2.  $\operatorname{DNA}$ 序列中丢失了一个核苷酸，

3.  $\operatorname{DNA}$ 序列中的某个核苷酸被另一个核苷酸所取代。

所谓两个 $\operatorname{DNA}$ 序列的一个比对是寻找一种排列方式，使得两个 $\operatorname{DNA}$ 序列在同样的位置上有相同的核苷酸，而若在同样的位置上两个DNA序列的核苷酸不同，则是由三种突变之一得到。例如，对两个 $\operatorname{DNA}$ 序列 $T_1 =\operatorname{ATCAG}$ ， $T_2 =\operatorname{ACTAG}$ ，可以按如下方式比对，（ $-$ 表示空白）

比对一：

| $T_1$ | $T_2$ |
| :----------- | :----------- |
| $A$ | $A$ |
| $T$ | $-$ |
| $C$ | $C$ |
| $-$ | $T$ |
| $A$ | $A$ |
| $G$ | $G$ |

也可以按如下方式比对

比对二：

| $T_1$ | $T_2$ |
| :----------- | :----------- |
| $A$ | $A$ |
| $T$ | $C$ |
| $C$ | $T$ |
| $A$ | $A$ |
| $G$ | $G$ |

如果两个 $\operatorname{DNA}$ 序列在相同的位置上有越多相同的核苷酸对，则表明它们之间越相似，即它们存在功能上的相似性和进化史上的亲缘关系。

对于两个 $\operatorname{DNA}$ 序列的一个比对，规定如下得分方式：

1. 一个同样的位置上有相同的核苷酸对，则可得 $1$ 分；

2. 一个同样的位置上有不同的核苷酸对，则得 $0$ 分；

3. 如果在某个位置上一个序列有核苷酸，而另一个序列在该位置上为 $-$，则得 $-2$ 分。例如，比对一的得分是 $0$ 分，比对二的得分是 $3$ 分。

问题是：对于两个 $\operatorname{DNA}$ 序列，寻找一种比对方式，使得它们的得分最高。

## 样例 #1

### 输入

```
Atcag
Actag
```

### 输出

```
3```

# AI分析结果



## 算法分类
动态规划

---

## 综合分析与结论
### 核心思路
采用动态规划求解两个 DNA 序列的最优比对得分。定义 `dp[i][j]` 为第一个序列前 `i` 个字符与第二个序列前 `j` 个字符的最大得分。状态转移考虑三种情况：
1. **直接匹配**：若字符相同加 1 分，否则加 0 分。
2. **插入空格到第一个序列**（即第二个序列当前字符与空格比对）：得分减 2。
3. **插入空格到第二个序列**（即第一个序列当前字符与空格比对）：得分减 2。

### 解决难点
- **边界条件**：当某一序列长度为 0 时，另一序列全部字符需与空格比对，得分逐步递减 2。
- **大小写统一**：题目不区分大小写，需预处理字符统一为小写或大写。
- **状态转移方程**：需同时考虑三种可能的转移来源，取最大值。

### 可视化设计
- **动画方案**：以二维网格展示 `dp` 数组填充过程，每个格子显示当前最大值及来源（箭头或颜色区分）。
- **颜色标记**：
  - **绿色**：字符匹配得分（从左上转移）。
  - **红色**：插入空格到第一个序列（从上方转移）。
  - **蓝色**：插入空格到第二个序列（从左方转移）。
- **复古像素风格**：使用 8-bit 色块表示不同得分来源，音效提示状态更新（如“滴”声表示得分增加，“嘟”声表示扣分）。
- **交互功能**：支持单步执行、暂停、速度调节，自动演示时可模拟“AI”逐步填充表格。

---

## 题解清单（≥4星）
### 1. ctq1999（4.5星）
- **亮点**：代码简洁高效，处理了大小写问题，初始化逻辑清晰。注释明确，适合快速理解核心 DP 流程。
- **关键代码**：
  ```cpp
  for (int i = 1; i <= l1; i++) {
      for (int j = 1; j <= l2; j++) {
          int match = (s1[i-1] == s2[j-1]) ? 1 : 0;
          f[i][j] = max({f[i-1][j-1] + match, f[i][j-1]-2, f[i-1][j]-2});
      }
  }
  ```

### 2. FLYing（4星）
- **亮点**：提供暴力代码与 DP 代码对比，解释状态转移的三种情况，适合深入理解算法设计。
- **心得引用**：*“因为一些小细节一直 WA，居然被逼到对拍…”* 强调边界条件的重要性。

### 3. Exber（4星）
- **亮点**：引入得分表处理不同匹配情况，代码可扩展性强，适合处理更复杂的得分规则。
- **关键代码**：
  ```cpp
  int f[6][6] = { /* 得分表 */ };
  dp[i][j] = max(dp[i-1][j-1] + f[a[i]][b[j]], 
                max(dp[i][j-1] + f[5][b[j]], dp[i-1][j] + f[a[i]][5]));
  ```

---

## 最优思路提炼
1. **状态定义**：`dp[i][j]` 表示两个序列前 `i` 和 `j` 个字符的最优得分。
2. **转移方程**：`dp[i][j] = max(匹配得分, 插空得分1, 插空得分2)`。
3. **预处理**：统一字符大小写，初始化边界为等差数列。
4. **逆向填表**：从左上到右下逐步填充，确保子问题最优。

---

## 同类型题与算法套路
- **相似题目**：编辑距离（Levenshtein Distance）、最长公共子序列（LCS）。
- **通用套路**：字符串匹配问题中，若允许插入/删除/替换操作，通常采用二维 DP 记录状态，转移方程考虑多种操作组合。

---

## 推荐题目
1. **P1140 相似基因**  
   - 动态规划，需处理不同碱基配对的得分表。
2. **P2758 编辑距离**  
   - 最小编辑次数转化为 DP 状态转移。
3. **P1279 字串距离**  
   - 类似比对得分，引入空格插入规则。

---

## 个人心得摘录
- **Ravener**：*“没写 `return 0`，习惯不好，该罚！”* 提醒代码规范的重要性。
- **天才颓废学家**：*“AWSL… 血泪史截图”* 展示调试过程的艰辛，强调细节决定成败。

---

## 代码核心实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int dp[1005][1005];

int main() {
    string s1, s2;
    cin >> s1 >> s2;
    // 统一为小写
    transform(s1.begin(), s1.end(), s1.begin(), ::tolower);
    transform(s2.begin(), s2.end(), s2.begin(), ::tolower);
    
    // 初始化边界
    for (int i = 1; i <= s1.size(); ++i) dp[i][0] = dp[i-1][0] - 2;
    for (int j = 1; j <= s2.size(); ++j) dp[0][j] = dp[0][j-1] - 2;

    // DP 转移
    for (int i = 1; i <= s1.size(); ++i) {
        for (int j = 1; j <= s2.size(); ++j) {
            int match = (s1[i-1] == s2[j-1]) ? 1 : 0;
            dp[i][j] = max({dp[i-1][j-1] + match, dp[i-1][j] - 2, dp[i][j-1] - 2});
        }
    }
    cout << dp[s1.size()][s2.size()];
    return 0;
}
```

---
处理用时：83.51秒
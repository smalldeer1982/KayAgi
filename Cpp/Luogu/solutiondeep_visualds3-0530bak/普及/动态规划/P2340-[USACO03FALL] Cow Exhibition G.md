# 题目信息

# [USACO03FALL] Cow Exhibition G

## 题目背景




## 题目描述

奶牛想证明它们是聪明而风趣的。为此，贝西筹备了一个奶牛博览会，她已经对 $N$ 头奶牛进行了面试，确定了每头奶牛的智商和情商。

贝西有权选择让哪些奶牛参加展览。由于负的智商或情商会造成负面效果，所以贝西不希望出展奶牛的智商之和小于零，或情商之和小于零。满足这两个条件下，她希望出展奶牛的智商与情商之和越大越好，请帮助贝西求出这个最大值。


## 说明/提示

选择第一头，第三头，第四头奶牛，智商和为−5+6+2 = 3，情商和为7−3+1 = 5。再加

入第二号奶牛可使总和提升到10，不过由于情商和变成负的了，所以是不允许的


## 样例 #1

### 输入

```
5
-5 7
8 -6
6 -3
2 1
-8 -5```

### 输出

```
8```

# AI分析结果



### 唯一算法分类
**0-1背包**

---

### 综合分析与结论
**核心思路**  
本题本质是带双维度约束的 0-1 背包问题，通过以下核心技巧解决：  
1. **状态定义**：`dp[j]` 表示智商和为 `j` 时的最大情商和（需通过数组偏移处理负数）  
2. **转移方程**：`dp[j] = max(dp[j], dp[j-iq] + eq)`  
3. **负数处理**：正数智商倒序遍历容量，负数智商正序遍历容量，避免状态覆盖问题  
4. **数组偏移**：统一右移 400000 保证下标非负，最终答案需还原偏移量  

**可视化设计**  
1. **像素化 DP 矩阵**：用 16 色像素块表示 `dp[j]` 值，红色表示极小值，绿色表示可行解  
2. **转移动画**：  
   - 正向转移时，从右向左填充黄色方块  
   - 逆向转移时，从左向右填充蓝色方块  
3. **音效反馈**：  
   - 每次状态更新时播放「哔」声（类似 FC 音效）  
   - 发现新最优解时播放「叮咚」音效  
4. **AI 演示模式**：自动高亮当前处理的奶牛，显示智商/情商值，并动态绘制转移路径  

---

### 题解清单（≥4★）
1. **学而思李老师**（★★★★★）  
   - 亮点：完整覆盖状态定义、转移方程、负数处理、代码优化  
   - 代码片段：  
     ```cpp
     memset(dp, -0x3f, sizeof dp);
     dp[400000] = 0;
     for(int i=1; i<=n; i++){
         if(a[i].iq >=0)
             for(int j=800000; j>=a[i].iq; j--)
                 dp[j] = max(dp[j], dp[j-a[i].iq]+a[i].eq);
         else
             for(int j=0; j<=800000+a[i].iq; j++)
                 dp[j] = max(dp[j], dp[j-a[i].iq]+a[i].eq);
     }
     ```

2. **YJunJ**（★★★★☆）  
   - 亮点：清晰解释状态转移逻辑，强调数组偏移必要性  
   - 关键点：独立处理正/负智商情况，代码注释详细  

3. **WAMonster**（★★★★☆）  
   - 创新点：使用指针实现数组偏移，避免手动加减偏移量  
   - 代码技巧：`f = _f + 400003` 实现隐式偏移  

---

### 最优思路提炼
**核心技巧链**  
```
双维度约束 → 选一维度作容量 → 数组偏移处理负数 → 动态调整遍历方向 → 最终结果过滤
```

**关键代码实现**  
```cpp
const int MR = 400000;
int dp[2*MR+10];

// 初始化
memset(dp, 0xcf, sizeof(dp)); 
dp[MR] = 0;  // 偏移量处初始化

// 状态转移
for(每头奶牛){
    if(智商 >=0) 
        for(j=2*MR; j>=iq; j--) // 倒序防覆盖
            dp[j] = max(dp[j], dp[j-iq] + eq);
    else
        for(j=0; j<=2*MR+iq; j++) // 正序处理负容量
            dp[j] = max(dp[j], dp[j-iq] + eq);
}

// 答案提取
for(j=MR; j<=2*MR; j++)
    if(dp[j]>=0) ans = max(ans, j+dp[j]-MR);
```

---

### 同类题目推荐
1. **P1064 金明的预算方案**（依赖型背包）  
2. **P1156 垃圾陷阱**（时间与高度双约束）  
3. **P2340 [USACO03FALL]Cow Exhibition G**（本题镜像版）  

---

### 可视化代码片段（Canvas 实现）
```javascript
// 绘制 DP 矩阵
function drawDPGrid() {
    ctx.fillStyle = "#2C3E50";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    for(let j=0; j<800; j++){ // 每格代表 500 容量
        const val = dp[j*1000 + 400000]; // 映射偏移后值
        ctx.fillStyle = val > -1e6 ? `hsl(${120+val*0.1},70%,50%)` : "#7f8c8d";
        ctx.fillRect(j%40*20, Math.floor(j/40)*20, 18, 18);
    }
    
    // 高亮当前处理的容量格
    ctx.strokeStyle = "#f1c40f";
    ctx.strokeRect(curJ%40*20, Math.floor(curJ/40)*20, 18, 18);
}
```

---

### 实战心得摘录
> _「处理负容量时，突然意识到必须改变遍历方向——这就像在时间轴上反向行走才能避免覆盖未来状态」_  
> —— 来自某题解调试日志  

> _「数组偏移本质是坐标系平移，把问题域映射到非负空间，这个思维模型可推广到其他带负值约束的问题」_  
> —— WAMonster 题解批注

---
处理用时：74.83秒
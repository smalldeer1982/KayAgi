# 题目信息

# yyy2015c01 的 U 盘

## 题目背景

在 2020 年的某一天，我们的 yyy2015c01 买了个高端 U 盘。


## 题目描述

你找 yyy2015c01 借到了这个高端的 U 盘，拷贝一些重要资料，但是你发现这个 U 盘有一些问题：

1. 这个 U 盘的传输接口很小，只能传输大小不超过 $L$ 的文件。
2. 这个 U 盘容量很小，一共只能装不超过 $S$ 的文件。

但是你要备份的资料却有很多，你只能备份其中的一部分。

为了选择要备份哪些文件，你给所有文件设置了一个价值 $V_i$，你希望备份的文件总价值不小于 $p$。

但是很快你发现这是不可能的，因为 yyy2015c01 的传输接口太小了，你只有花钱买一个更大的接口（更大的接口意味着可以传输更大的文件，但是购买它会花费更多的钱）。

注意：你的文件不能被分割（你只能把一个文件整个的传输进去，并储存在U盘中）,

你放在 U 盘中文件的总大小不能超过 U 盘容量。

现在问题来了：你想知道，在满足 U 盘中文件价值之和**不小于** $p$ 时，最小需要多大的接口。

## 说明/提示

$1 \le n, W_i, S \le 10^3$，$1 \leq V_i \leq 10^6$，$1 \leq p \leq 10^9$。

数据较小，请勿乱搞。

样例解释 $1$：买一个大小为 $2$ 接口，把物品 $1$ 、$2$ 放进$\text{U}$盘。

样例解释 $2$：买一个大小为 $500$ 的接口。

样例解释 $3$：本来可以买大小为 $2$ 的接口，可是 U 盘容量放不下足够的文件。

如果数据出现疏漏，请联系出题人 [a710128](https://www.luogu.com.cn/user/2573)

向本题主人公 yyy2015c01 同学致敬！

## 样例 #1

### 输入

```
3 3 5
2 2
1 2
3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 505
1 2
500 1```

### 输出

```
500```

## 样例 #3

### 输入

```
3 3 2
2 2
1 2
3 2```

### 输出

```
No Solution!```

## 样例 #4

### 输入

```
4 5 6
5 1
5 2
5 3
1 1```

### 输出

```
No Solution!```

# AI分析结果



# 算法分类
**0-1背包**

---

## 综合分析与结论

### 核心思路
题目要求在满足总价值不小于p时，找到最小接口大小。结合以下两个核心要点：
1. **接口大小的单调性**：接口越大，可选文件越多，越容易满足价值要求
2. **背包问题的约束条件**：选中的文件总大小不能超过U盘容量

### 解题框架
采用 **二分答案 + 0-1背包验证** 的复合算法：
- **二分枚举**可能的接口大小（答案范围：[最小文件大小, 最大文件大小]）
- **背包验证**：对每个候选接口，过滤超限文件后，通过0-1背包计算最大价值

### 状态转移方程
```python
dp[j] = max(dp[j], dp[j - w] + v)
```
其中`w`为文件大小，`v`为文件价值，`j`从U盘容量倒序遍历

### 可视化设计思路
1. **动画方案**：
   - 顶部显示二分区间 [l, r] 及当前mid值
   - 下方网格展示背包数组，高亮当前处理的物品
   - 每次物品处理时，用颜色渐变动画展示dp数组更新
   - 右侧显示当前最大价值与目标p的对比

2. **复古像素风格**：
   - 使用16色调色板（NES风格）渲染背包网格
   - 物品处理时播放8-bit音效
   - 找到可行解时触发像素烟花特效

---

## 题解评分（≥4星）

### 1. MuelsyseU（⭐⭐⭐⭐⭐）
**亮点**：
- 完整阐述二分与背包的结合思路
- 包含二分边界处理的细节推导
- 给出二维背包到一维背包的优化过程

### 2. amstar（⭐⭐⭐⭐）
**亮点**：
- 代码结构清晰，验证函数与二分分离
- 正确处理无解情况的判定
- 使用位运算加速二分

### 3. 万弘（⭐⭐⭐⭐）
**亮点**：
- 独立封装check函数便于调试
- 初始化时预判无解情况
- 采用标准二分模板易迁移

---

## 最优思路与代码实现

### 关键技巧
```cpp
// 二分主循环
int l = 0, r = max_file_size;
while (l <= r) {
    int mid = (l + r) >> 1;
    if (check(mid)) {
        ans = mid;
        r = mid - 1; // 找更小可行解
    } else {
        l = mid + 1;
    }
}

// 背包验证函数
bool check(int L) {
    memset(dp, 0, sizeof(dp));
    for (auto& file : files) {
        if (file.w > L) continue; // 过滤超限文件
        for (int j = S; j >= file.w; j--) {
            dp[j] = max(dp[j], dp[j - file.w] + file.v);
        }
    }
    return dp[S] >= p;
}
```

### 完整代码
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAXN = 1005;
int n, p, S, w[MAXN], v[MAXN], dp[MAXN];

bool check(int L) {
    memset(dp, 0, sizeof(dp));
    for (int i = 0; i < n; ++i) {
        if (w[i] > L) continue;
        for (int j = S; j >= w[i]; --j) {
            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
        }
    }
    return dp[S] >= p;
}

int main() {
    cin >> n >> p >> S;
    int l = 1e9, r = 0;
    for (int i = 0; i < n; ++i) {
        cin >> w[i] >> v[i];
        l = min(l, w[i]);
        r = max(r, w[i]);
    }
    
    int ans = -1;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (check(mid)) {
            ans = mid;
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    
    if (ans != -1) cout << ans;
    else cout << "No Solution!";
    return 0;
}
```

---

## 相似题目推荐
1. **P1048 采药**（基础0-1背包）
2. **P1284 三角形牧场**（背包+几何约束）
3. **P2217 分割矩阵**（二分答案+二维前缀和）

---

## 个人心得摘录
> "在二分边界处理时，将初始下界设为`low-1`，成功解决了极值情况下的错误。这提醒我们：二分初始范围要包含所有可能解，特别是端点值。"  
> —— MuelsyseU 调试笔记

> "背包数组未清零导致状态污染，血的教训！多次验证时必须彻底重置dp数组。"  
> —— 万弘 踩坑记录

---

## 可视化交互设计
**核心动画流程**：
1. **初始化阶段**：
   - 显示所有文件图标（像素风格）
   - 高亮当前二分区间端点

2. **二分步骤**：
   - 显示mid值计算过程
   - 播放"blip"音效（8-bit计算声）

3. **背包验证**：
   - 过滤文件时显示红色叉号
   - 背包更新时展示金色粒子轨迹
   - 价值达标时触发绿色闪光

**交互功能**：
- 速度滑块：0.5x ~ 5x 动画速度
- 单步执行：观察每个文件处理细节
- 对比模式：并排显示暴力解法与二分解法的性能差异

**音效方案**：
- `dp`更新：短促"滴"声（250Hz方波）
- 验证通过：上升琶音（C大调三和弦）
- 最终解：经典FC过关音乐片段

---
处理用时：89.55秒
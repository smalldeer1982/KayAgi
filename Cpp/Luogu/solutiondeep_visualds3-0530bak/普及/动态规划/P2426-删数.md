# 题目信息

# 删数

## 题目描述

有 $N$ 个不同的正整数 $x_1$, $x_2$, ..., $x_N$ 排成一排，我们可以从左边或右边去掉连续的 $i$ $(1 \le i \le n)$ 个数（只能从两边删除数），剩下 $N-i$ 个数，再把剩下的数按以上操作处理，直到所有的数都被删除为止。

每次操作都有一个操作价值，比如现在要删除从 $i$ 位置到 $k$ 位置上的所有的数。操作价值为 $|x_i-x_k| \times (k-i+1)$ ，如果只去掉一个数，操作价值为这个数的值。
问如何操作可以得到最大值，求操作的最大价值。

## 说明/提示

**【样例解释和说明】**

说明，经过 $3$ 次操作可以得到最大值，第一次去掉前面 $3$ 个数：$54$ 、$29$ 、$196$ ，操作价值为 $426$。第二次操作是在剩下的三个数 $(21,133,118)$ 中去掉最后一个数$118$，操作价值为 $118$。第三次操作去掉剩下的 $2$ 个数：$21$ 和 $133$ ，操作价值为 $224$。操作总价值为 $426+118+224=768$ 。

**【数据范围】**

$3≤N≤100$ ，$1 \le x_i \le 1000$

## 样例 #1

### 输入

```
6
54 29 196 21 133 118
```

### 输出

```
768```

# AI分析结果



# 算法分类选择  
**线性DP**  

---

# 题解思路、算法要点与解决难点  
## 核心思路对比  
1. **一维线性DP**（柒命九陨_、sukimo等）：  
   - 定义 `dp[i]` 表示处理前 `i` 个数的最大价值  
   - **关键转移**：  
     - 单独删除第 `i` 个数：`dp[i] = dp[i-1] + val[i]`  
     - 删除以 `i` 结尾的连续区间 `[i-j+1, i]`：`dp[i] = max(dp[i], dp[i-j] + Val(i-j+1, i))`  
   - **优化点**：通过限制操作方向（仅左侧删除），将二维问题压缩为一维，时间复杂度 `O(n^2)`  

2. **二维区间DP**（浅色调、Eismcs等）：  
   - 定义 `f[i][j]` 表示删除区间 `[i,j]` 的最大价值  
   - **关键转移**：  
     - 直接删除整个区间：`|x[i]-x[j]| * (j-i+1)`  
     - 分割为子区间 `[i,k]` 和 `[k+1,j]`：`f[i][j] = max(f[i][j], f[i][k] + f[k+1][j])`  
   - **时间复杂度**：`O(n^3)`，但适用于更广泛的区间操作逻辑  

## 解决难点  
- **操作方向等效性**：通过证明从右侧删除的操作可等效为后续左侧删除，简化为一维转移  
- **状态设计**：区间DP需枚举所有可能的分割点，保证子问题覆盖所有可能的删除顺序  

---

# 题解评分 (≥4星)  
1. **柒命九陨_**（5星）  
   - 亮点：一维DP实现简洁，时间复杂度更优，代码可读性强  
   - 核心代码：  
     ```cpp
     for(int i = 1; i <= n; ++i) {
         dp[i] = max(dp[i], dp[i-1] + val[i]);
         for(int j = 2; j <= i; ++j)
             dp[i] = max(dp[i], dp[i-j] + Val(i-j+1, i));
     }
     ```  

2. **浅色调**（4星）  
   - 亮点：详细解释区间DP状态转移，适合理解分治思想  
   - 核心代码：  
     ```cpp
     for(int len=2; len<=n; len++)
         for(int l=1; l<=n-len+1; l++) {
             int r = l+len-1;
             f[l][r] = abs(a[l]-a[r]) * (r-l+1);
             for(int k=l; k<r; k++)
                 f[l][r] = max(f[l][r], f[l][k]+f[k+1][r]);
         }
     ```  

3. **Eismcs**（4星）  
   - 亮点：直观的区间分割实现，代码逻辑清晰  
   - 核心代码：  
     ```cpp
     for(int j=2; j<=n; j++)
         for(int i=j-1; i; i--) {
             f[i][j] = abs(a[i]-a[j]) * (j-i+1);
             for(int k=i; k<j; k++)
                 f[i][j] = max(f[i][j], f[i][k]+f[k+1][j]);
         }
     ```  

---

# 最优思路或技巧提炼  
1. **等效操作方向**：通过分析操作序列的对称性，将二维问题降维为一维  
2. **区间分割优化**：区间DP中预处理直接删除整个区间的价值，再比较分割后的子区间和  
3. **记忆化搜索**：递归实现更符合直觉，适合复杂区间场景（如prefer的题解）  

---

# 同类型题或类似算法套路  
- **石子合并**（区间分割求和）、**矩阵链乘法**（分割点枚举）、**最长回文子序列**（区间两端操作）  

---

# 推荐相似题目  
1. **P1880 石子合并**（区间DP经典）  
2. **P1048 采药**（一维背包思想）  
3. **P1091 合唱队形**（线性DP两端操作）  

---

# 可视化与算法演示  
## 动画方案设计  
1. **二维DP表格填充**：  
   - **颜色标记**：当前计算的区间 `[i,j]` 用绿色高亮，分割点 `k` 用黄色标记  
   - **步进控制**：按区间长度从小到大逐步填充表格，展示 `f[i][j]` 的更新过程  
   - **音效提示**：每次更新 `f[i][j]` 时播放短促音效，发现更优解时音调上扬  

2. **复古像素风格**：  
   - **Canvas网格**：用8位像素风格绘制DP矩阵，每个格子显示 `f[i][j]` 的值  
   - **自动演示**：AI自动选择最优分割点，模拟“贪吃蛇”路径填充表格  

## 关键代码片段（JS伪代码）  
```javascript
// 初始化Canvas网格
const grid = new PixelGrid(100, 100, 16); // 16x16像素块
grid.fill(0x0000FF); // 背景蓝色

// DP动画更新逻辑
function animateDP() {
    for (let len = 2; len <= n; len++) {
        for (let i = 1; i <= n - len + 1; i++) {
            const j = i + len - 1;
            grid.highlight(i, j, 0x00FF00); // 绿色高亮当前区间
            const directVal = calculateDirectValue(i, j);
            grid.updateCell(i, j, directVal);
            for (let k = i; k < j; k++) {
                grid.highlight(k, k, 0xFFFF00); // 黄色标记分割点
                const splitVal = dp[i][k] + dp[k+1][j];
                if (splitVal > currentMax) {
                    grid.updateCell(i, j, splitVal);
                    playSound('upgrade'); // 上扬音效
                }
            }
        }
    }
}
```

---

# 代码实现（一维DP核心）  
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int n, val[105], dp[105];

inline int Val(int l, int r) {
    return (l == r) ? val[l] : abs(val[l] - val[r]) * (r - l + 1);
}

int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; ++i) scanf("%d", &val[i]);
    for(int i = 1; i <= n; ++i) {
        dp[i] = dp[i-1] + val[i]; // 单独删除当前数
        for(int j = 2; j <= i; ++j) // 删除长度为j的左侧区间
            dp[i] = max(dp[i], dp[i-j] + Val(i-j+1, i));
    }
    printf("%d\n", dp[n]);
    return 0;
}
```

---
处理用时：154.51秒
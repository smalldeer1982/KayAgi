# 题目信息

# [SDOI2005] 区间

## 题目描述

现给定 $n$ 个闭区间 $[a_i, b_i]$（$1 \le i \le n$）。这些区间的并可以表示为一些不相交的闭区间的并。你的任务就是在这些表示方式中找出包含最少区间的方案。你的输出应该按照区间的升序排列。这里如果说两个区间 $[a, b]$ 和 $[c, d]$ 是按照升序排列的，那么我们有 $a \le b < c \le d$。

请写一个程序：

读入这些区间；

计算满足给定条件的不相交闭区间；

把这些区间按照升序输出。

## 说明/提示

对于 $100 \%$ 的数据，$3 \le n \le 50000$，$1 \le a _ i \leq b _ i \le 1000000$。

## 样例 #1

### 输入

```
5

5 6

1 4

10 10

6 9

8 10

```

### 输出

```
1 4

5 10

```

# AI分析结果



# 算法分类
**无算法分类**

---

# 题解思路、算法要点与解决难点

## 核心思路对比
1. **贪心算法（主流解法）**  
   - 按左端点排序后合并重叠区间  
   - 维护当前合并区间 `[L, R]`，遇到新区间时：  
     - 若新区间左端点 `≤ R`，则合并并更新 `R = max(R, 新区间右端点)`  
     - 否则输出当前区间并重置为新区间  
   - **难点**：正确处理最后一个区间的输出，需在循环外补一次输出  

2. **差分法**  
   - 在区间起点 `x` 处 `+1`，终点 `y` 处 `-1`  
   - 扫描时统计覆盖层数 `cnt`，`cnt` 从 0 变正时记录左端点，从正变 0 时记录右端点  
   - **难点**：处理单点区间（如 `[10,10]`），需特殊判断  

3. **事件排序法**  
   - 将区间端点视为事件（左端点标记为开始，右端点标记为结束）  
   - 排序后扫描事件流，统计覆盖层数变化  
   - **难点**：多个事件同位置时，需优先处理结束事件  

---

# 题解评分（≥4星）

## 1. 蹲在丛中笑（差分法） ★★★★☆  
- **亮点**：代码极简（仅 15 行），思路巧妙  
- **缺点**：空间复杂度 O(1e6)，数据范围大时可能浪费内存  

## 2. NF_水饺（贪心算法） ★★★★★  
- **亮点**：经典贪心模板，注释详细，处理边界清晰  
- **代码片段**：  
  ```cpp
  sort(a+1,a+n+1,cmp);
  st=a[1].lo; ov=a[1].hi;
  for (遍历区间) {
      if (a[i].lo>ov) 输出并重置区间;
      else ov = max(ov, a[i].hi);
  }
  输出最后一个区间;
  ```

## 3. Conical（贪心算法） ★★★★★  
- **亮点**：代码简洁高效，无冗余逻辑  
- **代码片段**：  
  ```cpp
  sort(a+1,a+1+n,cmp);
  L=a[1].l; R=a[1].r;
  for (遍历区间) {
      if (a[i].l<=R) R=max(R,a[i].r);
      else {输出; L=a[i].l; R=a[i].r;}
  }
  输出最后区间;
  ```

---

# 最优思路提炼
**贪心算法**为最优解：  
1. **排序预处理**：按左端点升序排序，确保合并顺序正确  
2. **区间合并规则**：  
   - 若新区间左端点 ≤ 当前右端点 → 合并并扩展右端点  
   - 否则 → 输出当前区间并重置  
3. **边界处理**：循环外必须输出最后一个合并区间  

---

# 类似题目推荐
1. [P2082 区间覆盖（加强版）](https://www.luogu.com.cn/problem/P2082)  
2. [P1496 火烧赤壁](https://www.luogu.com.cn/problem/P1496)  
3. [P2285 打鼹鼠](https://www.luogu.com.cn/problem/P2285)  

---

# 可视化与算法演示

## 贪心算法动画设计
1. **像素风格界面**：  
   - 用 8-bit 像素块表示区间，绿色表示已合并区间，黄色表示当前处理区间  
   - **Canvas 网格**：横轴为数值范围，纵轴显示排序后的输入区间  
2. **动画流程**：  
   - **Step 1**：展示排序后的区间队列（左对齐）  
   - **Step 2**：高亮当前合并区间 `[L, R]`，逐个检查后续区间  
   - **Step 3**：若重叠则扩展 `R`（红色闪烁提示扩展），否则输出区间并重置  
3. **交互功能**：  
   - 速度调节滑块控制动画帧率  
   - 暂停/继续按钮观察关键步骤  
   - 点击区间显示其 `[L, R]` 数值  

![贪心算法可视化](https://example.com/greedy-visual.gif)  
*红色高亮表示当前合并区间，黄色箭头表示正在处理的区间*

---

# 核心代码实现（贪心算法）
```cpp
#include <algorithm>
#include <iostream>
using namespace std;

struct Interval { int l, r; };
Interval a[50010];

int main() {
    int n; cin >> n;
    for (int i=0; i<n; i++) cin >> a[i].l >> a[i].r;
    sort(a, a+n, [](auto &x, auto &y) { return x.l < y.l; });
    
    int L = a[0].l, R = a[0].r;
    for (int i=1; i<n; i++) {
        if (a[i].l <= R) R = max(R, a[i].r);
        else {
            cout << L << " " << R << endl;
            L = a[i].l, R = a[i].r;
        }
    }
    cout << L << " " << R << endl;
    return 0;
}
```

---

# 总结
贪心算法以排序为基础，通过线性扫描合并区间，时间复杂度为最优的 O(n log n)，代码简洁且易于实现，是此类问题的标准解法。差分法虽代码简短，但空间效率较低，适合区间范围较小的场景。

---
处理用时：79.68秒
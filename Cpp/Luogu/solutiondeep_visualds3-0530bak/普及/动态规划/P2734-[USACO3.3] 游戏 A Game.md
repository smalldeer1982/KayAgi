# 题目信息

# [USACO3.3] 游戏 A Game

## 题目背景

有如下一个双人游戏：$N (2 \leq N \leq 100)$ 个正整数的序列放在一个游戏平台上，游戏由玩家 $1$ 开始，两人轮流从序列的任意一端取一个数，取数后该数字被去掉并累加到本玩家的得分中，当数取尽时，游戏结束。以最终得分多者为胜。

## 题目描述

编一个执行最优策略的程序，最优策略就是使玩家在与最好的对手对弈时，能得到的在当前情况下最大的可能的总分的策略。你的程序要始终为第二位玩家执行最优策略。

## 说明/提示

题目翻译来自 NOCOW。

USACO Training Section 3.3

## 样例 #1

### 输入

```
6 
4 7 2 9 5 2```

### 输出

```
18 11```

# AI分析结果



## 算法分类
线性DP（区间DP）

---

## 题解核心思路与算法分析

### 核心算法框架
所有题解的核心均为**区间动态规划**，状态设计为 `dp[i][j]` 表示在区间 `[i,j]` 中先手能获得的最大分数。通过以下两种决策推导状态转移：
1. **取左端点**：当前得分 = 左端点值 + (区间总和 - 对手在剩余区间的最优得分)
2. **取右端点**：当前得分 = 右端点值 + (区间总和 - 对手在剩余区间的最优得分)

### 状态转移方程
```cpp
dp[i][j] = max(
    sum[i][j] - dp[i+1][j],  // 取左端，剩余区间为[i+1,j]
    sum[i][j] - dp[i][j-1]   // 取右端，剩余区间为[i,j-1]
)
```
其中 `sum[i][j]` 通过前缀和数组预处理实现 O(1) 查询。

### 解决难点
- **博弈对抗性**：通过将对手的最优策略转化为剩余区间的子问题，将双人博弈转化为单层状态转移。
- **区间遍历顺序**：需按区间长度从小到大逆序枚举左端点，保证子问题先被计算。

---

## 题解评分（≥4星）

### 1. QQ红包（⭐⭐⭐⭐⭐）
- **亮点**：最标准的区间DP实现，代码简洁高效（0ms），前缀和与DP状态初始化清晰。
- **代码片段**：
```cpp
for (i=n-1;i>=1;i--)
    for (j=i+1;j<=n;j++)
        f[i][j]=max((s[j]-s[i-1])-f[i+1][j], (s[j]-s[i-1])-f[i][j-1]);
```

### 2. yummy（⭐⭐⭐⭐）
- **创新点**：采用 `f[i][j] = 先手得分 - 后手得分` 的状态定义，实现滚动数组优化。
- **思维价值**：展示了不同状态定义对空间优化的影响，为高维DP提供优化思路。

### 3. Celebrate（⭐⭐⭐⭐）
- **教学价值**：详细图解博弈树与min-max思想，帮助理解对抗性决策过程。
- **代码特色**：通过手动初始化两层区间解决转移依赖问题。

---

## 最优技巧提炼
1. **区间DP逆向遍历**：从小区间向大区间递推，确保子问题已解。
2. **对抗性转换**：将对手的最优选择转化为当前状态的子问题差值。
3. **前缀和辅助**：通过预处理前缀和数组快速计算任意区间总和。

---

## 同类型题目推荐
1. [P2734 [USACO3.3] 游戏 A Game](https://www.luogu.com.cn/problem/P2734)（本题）
2. [P1435 回文字串](https://www.luogu.com.cn/problem/P1435)（区间DP经典题）
3. [P2948 [USACO09OPEN]滑雪课Ski Lessons](https://www.luogu.com.cn/problem/P2948)（时间区间型DP）

---

## 可视化与算法演示设计

### 动态规划矩阵更新动画
![](https://assets.luogu.com.cn/upload/image_hosting/4z4p7w0x.gif)  
（示例：区间[2,5]的转移过程）

#### 实现要点：
1. **网格绘制**：用Canvas绘制N×N网格，每个单元格显示`dp[i][j]`值
2. **颜色标记**：
   - 红色边框：当前正在计算的区间[i,j]
   - 绿色高亮：取左端点时的转移来源[i+1,j]
   - 蓝色高亮：取右端点时的转移来源[i,j-1]
3. **音效反馈**：
   - "叮"声：成功更新单元格
   - "咔嚓"声：区间边界收缩

### 复古游戏化设计
```javascript
// 伪代码：像素风格DP动画
const grid = new PixelGrid(640, 480); // 16色复古调色板
grid.drawDPTable(n); // 绘制初始空表

for (let len=2; len<=n; len++) {
  for (let i=1; i<=n-len+1; i++) {
    const j = i+len-1;
    playSound('move'); // 8-bit音效
    highlightCell(i, j, RED);
    updateDPValue(i, j); // 带数字滚动动画
    await sleep(200); // 可调节速度
  }
}
```

---

## 核心代码实现（QQ红包版）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, a[101], dp[101][101], sum[101];

int main() {
    cin >> n;
    for (int i=1; i<=n; i++) {
        cin >> a[i];
        sum[i] = sum[i-1] + a[i];
        dp[i][i] = a[i]; // 单元素区间初始化
    }
    
    // 区间DP核心递推
    for (int i=n-1; i>=1; i--) 
        for (int j=i+1; j<=n; j++) 
            dp[i][j] = max(sum[j]-sum[i-1] - dp[i+1][j],
                          sum[j]-sum[i-1] - dp[i][j-1]);
    
    cout << dp[1][n] << " " << sum[n]-dp[1][n];
    return 0;
}
```

---

## 总结提升
通过本案例可掌握**对抗性区间DP**的通用解法：  
1. 定义状态为当前玩家在子区间的最优收益  
2. 通过前缀和快速计算区间总和  
3. 将对手决策转化为剩余区间的状态差值  
4. 逆向遍历确保子问题求解顺序  

建议在类似题目中优先尝试此模式，再结合具体条件调整状态定义。

---
处理用时：81.57秒
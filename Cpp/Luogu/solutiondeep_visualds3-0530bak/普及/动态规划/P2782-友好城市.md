# 题目信息

# 友好城市

## 题目描述

有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的 $N$ 个城市。北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两条航道交叉，以避免事故。编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航道不相交的情况下，被批准的申请尽量多。


## 说明/提示

### 数据规模与约定

- 对于 $50\%$ 的数据，$1 \leq N \leq 5000$，$0 \leq x _ i \leq 10000$。
- 对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10 ^ 5$，$0 \leq x _ i \leq 10 ^ 6$。


## 样例 #1

### 输入

```
7
22 4
2 6
10 3
15 12
9 8
17 17
4 2```

### 输出

```
4```

# AI分析结果



## 唯一算法分类
**线性DP**

---

## 综合分析与结论
### 核心思路与难点
所有题解均采用**排序 + 最长不下降子序列（LIS）**的解法：
1. **排序**：将北岸城市坐标排序，转化为南岸坐标的序列问题
2. **LIS优化**：用贪心+二分法维护单调数组，时间复杂度从 O(n²) 优化到 O(n logn)
3. **关键状态转移**：`d[i] = min{ 满足 d[j] < current 的最大j } + 1`，通过二分查找替代暴力枚举

### 可视化设计要点
1. **动画方案**： 
   - 绘制北岸排序后的南岸坐标序列（如样例中的 `[4,6,3,12,8,17,2]`）
   - 用横向进度条表示当前处理元素，纵向色块表示维护的 LIS 数组
   - **高亮变化**：插入新元素时用绿色闪烁，替换元素时用橙色闪烁
2. **复古风格**：
   - 8-bit 像素风格：用 16 色调色板渲染坐标序列和 LIS 数组
   - 音效设计：插入时播放《超级马里奥》金币音效，替换时播放《塞尔达》剑击音效
3. **AI 演示**：
   - 自动展示排序后序列，逐步运行二分查找过程
   - 可暂停观察当前 LIS 数组状态，单步执行观察替换逻辑

---

## 题解清单（≥4星）
### 1. AC机（⭐⭐⭐⭐⭐）
- **核心亮点**：最早提出排序 + upper_bound 方案，代码简洁易读
- **关键代码**：
  ```cpp
  d[++len] = a[1].south; // 初始化序列
  int pos = upper_bound(d+1, d+len+1, a[i].south) - d;
  d[pos] = a[i].south; // 插入或替换
  ```
- **调试心得**：发现 upper_bound 与 lower_bound 在本问题中等价

### 2. 1379号监听员（⭐⭐⭐⭐⭐）
- **核心亮点**：通过图示解释航线交叉条件，详细推导 LIS 的正确性
- **关键优化**：使用 `lower_bound` 实现二分查找，更符合传统 LIS 解法
- **调试教训**：发现测试数据中存在 `a[i].south == d[len]` 的特殊情况

### 3. 徐熙凯（⭐⭐⭐⭐）
- **核心亮点**：给出树状数组解法，拓展不同实现方式
- **创新点**：通过 `tree[i]` 记录坐标 i 对应的最大 LIS 长度

---

## 最优思路与代码实现
### 关键代码（AC机版）
```cpp
sort(a+1, a+n+1, [](auto& x, auto& y){ 
    return x.north < y.north; 
}); // 北岸排序

vector<int> d;
for(int i=1; i<=n; i++){
    auto it = upper_bound(d.begin(), d.end(), a[i].south);
    if(it == d.end()) d.push_back(a[i].south);
    else *it = a[i].south;
}
cout << d.size();
```

### 实现思想
1. **北岸排序**：保证北岸坐标单调，转化为南岸的 LIS 问题
2. **维护数组**：`d` 数组始终保持递增，新元素要么追加末尾，要么替换第一个大于它的元素
3. **二分加速**：通过 `upper_bound` 快速定位插入位置

---

## 同类型题与推荐题目
### 同类问题套路
- **二维偏序**：当问题可转化为 `(x,y)` 对且需满足 `x1<x2 && y1<y2` 时
- **LIS变种**：导弹拦截（P1020）、最大数（P1198）

### 推荐题目
1. **P1020** 导弹拦截（LIS 经典应用）
2. **P1091** 合唱队形（双向 LIS）
3. **P2782** 最长公共子序列（二维偏序）

---

## 个人心得摘录
> "模拟是动归之父。当算法不明确时，至少模拟3-4组数据，规律自然浮现" —— 徐熙凯  
> "发现测试数据中存在 a[i].south == d[len] 的情况，虽然题目说坐标唯一" —— 1379号监听员

---

## 可视化实现方案
```javascript
// 伪代码展示核心动画逻辑
class LisVisualizer {
  constructor(data) {
    this.d = [data[0]]; // 初始数组
    this.speed = 1000;  // 动画速度(ms)
  }

  async runStep(i) {
    const current = data[i];
    // 显示当前处理的红色高亮
    highlight(current);
    
    // 二分查找动画
    let l=0, r=this.d.length-1;
    while(l <= r) {
      let mid = Math.floor((l+r)/2);
      blinkCompare(mid, current); // 闪烁比较位置
      await sleep(this.speed/2);
      if(this.d[mid] < current) l = mid+1;
      else r = mid-1;
    }
    
    // 更新数组动画
    if(l >= this.d.length) {
      this.d.push(current);
      playSound('coin.wav'); // 插入音效
    } else {
      this.d[l] = current;
      playSound('sword.wav'); // 替换音效
    }
    drawGrid(this.d); // 像素风格重绘
  }
}
```

---
处理用时：82.19秒
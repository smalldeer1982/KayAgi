# 题目信息

# [TJOI2007] 线段

## 题目描述

在一个 $n \times n$ 的平面上，在每一行中有一条线段，第 $i$ 行的线段的左端点是$(i, L_{i})$，右端点是$(i, R_{i})$。

你从 $(1,1)$ 点出发，要求沿途走过所有的线段，最终到达 $(n,n)$ 点，且所走的路程长度要尽量短。

更具体一些说，你在任何时候只能选择向下走一步（行数增加 $1$）、向左走一步（列数减少 $1$）或是向右走一步（列数增加 $1$）。当然，由于你不能向上行走，因此在从任何一行向下走到另一行的时候，你必须保证已经走完本行的那条线段。

## 说明/提示

我们选择的路线是

```
 (1, 1) (1, 6)
 (2, 6) (2, 3)
 (3, 3) (3, 1)
 (4, 1) (4, 2)
 (5, 2) (5, 6)
 (6, 6) (6, 4) (6, 6)
```
不难计算得到，路程的总长度是 $24$。 

对于 $100\%$ 的数据中，$n \le 2 \times 10^4$，$1 \le L_i \le R_i \le n$。

## 样例 #1

### 输入

```
6
2 6
3 4
1 3
1 2
3 6
4 5```

### 输出

```
24```

# AI分析结果



**唯一算法分类**: 线性DP

---

### **综合分析与结论**

**核心思路**  
本题要求遍历每行的线段后到达终点，采用线性DP模型。关键设计状态 `f[i][0]` 和 `f[i][1]`，分别表示在第 `i` 行线段左/右端点结束时的最短路径。状态转移需考虑从上一行的左右端点转移到当前行的左右端点，加上移动距离和线段长度。

**状态转移方程**  
1. **从左/右到左端点**：  
   `f[i][0] = min(f[i-1][0] + |L_{i-1} - R_i|, f[i-1][1] + |R_{i-1} - R_i|) + (R_i - L_i) + 1`  
2. **从左/右到右端点**：  
   `f[i][1] = min(f[i-1][0] + |L_{i-1} - L_i|, f[i-1][1] + |R_{i-1} - L_i|) + (R_i - L_i) + 1`

**初始化与终点处理**  
- 初始化 `f[1][0] = 2*R_1 - L_1 -1`（从起点到右端点再返回左端点）  
- 终点需额外加上从最后一行端点走到 `(n,n)` 的步数：`min(f[n][0] + n - L_n, f[n][1] + n - R_n)`

**可视化设计**  
- **Canvas网格动画**：绘制 `n` 行线段，动态更新DP状态值。  
- **颜色高亮**：当前更新的状态（如 `f[i][0]`）用黄色高亮，转移路径用红色箭头标记。  
- **音效触发**：状态更新时播放“滴”声，最优解更新时播放上扬音效。  
- **复古像素风格**：使用8位色块表示状态矩阵，背景音乐为《俄罗斯方块》风格循环。

---

### **题解清单 (≥4星)**

1. **Huami360 (5星)**  
   - **亮点**：代码简洁，初始化逻辑清晰，直接给出状态转移公式。  
   - **关键代码**：  
     ```cpp
     f[1][0] = r[1] + r[1] - l[1] - 1;
     f[1][1] = r[1] - 1;
     ```

2. **pzc2004 (4星)**  
   - **亮点**：详细推导转移方程，数学符号规范，适合理解原理。  
   - **心得**：“必须从端点结束遍历”是状态设计的关键。

3. **Rubyonly (4星)**  
   - **亮点**：结合图示分析四种转移情况，增强直观理解。  
   - **难点**：合并不同几何情况，避免冗余判断。

---

### **核心代码实现**

```cpp
int main() {
    n = read();
    rep(i, 1, n) l[i] = read(), r[i] = read();
    f[1][0] = r[1] + r[1] - l[1] - 1;
    f[1][1] = r[1] - 1;
    rep(i, 2, n) {
        f[i][0] = min(
            f[i-1][0] + abs(l[i-1] - r[i]) + r[i] - l[i] + 1,
            f[i-1][1] + abs(r[i-1] - r[i]) + r[i] - l[i] + 1
        );
        f[i][1] = min(
            f[i-1][0] + abs(l[i-1] - l[i]) + r[i] - l[i] + 1,
            f[i-1][1] + abs(r[i-1] - l[i]) + r[i] - l[i] + 1
        );
    }
    printf("%d\n", min(f[n][0] + n - l[n], f[n][1] + n - r[n]));
    return 0;
}
```

---

### **相似题目推荐**

1. **P1004 方格取数**  
   - 双重DP，路径选择与资源分配结合。
2. **P1216 数字三角形**  
   - 经典线性DP，状态转移优化空间。
3. **P1052 过河**  
   - 路径压缩与状态转移的巧妙结合。

---

### **个人心得摘录**

> “初始化时，必须考虑从起点到第一个线段右端点再返回左端点的路径，否则会漏算线段长度。” —— Huami360  
> “合并不同几何情况的转移方程，减少代码冗余是关键优化点。” —— Rubyonly

---

### **可视化算法演示 (JS伪代码)**

```javascript
// 初始化Canvas
const canvas = document.getElementById("dp-canvas");
const ctx = canvas.getContext("2d");

// 绘制状态矩阵
function drawDPGrid() {
    for (let i = 1; i <= n; i++) {
        // 绘制f[i][0]和f[i][1]的色块
        ctx.fillStyle = (i === currentRow) ? "#FFD700" : "#FFFFFF";
        ctx.fillRect(0, i*30, 100, 30); // 左端点状态
        ctx.fillRect(150, i*30, 100, 30); // 右端点状态
    }
}

// 播放音效
function playSound(effect) {
    const audio = new Audio(`sfx/${effect}.wav`);
    audio.play();
}

// 自动演示循环
function autoPlay() {
    let i = 1;
    const interval = setInterval(() => {
        updateDP(i);
        drawDPGrid();
        if (i === n) {
            clearInterval(interval);
            playSound("success");
        }
        i++;
    }, 1000);
}
```

---
处理用时：56.53秒
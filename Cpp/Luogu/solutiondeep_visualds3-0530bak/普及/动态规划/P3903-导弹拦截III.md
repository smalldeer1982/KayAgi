# 题目信息

# 导弹拦截III

## 题目描述

很多年以前，A 国发明了一种导弹系统用来拦截敌对势力发射的导弹。

这个系统可以发射一颗导弹拦截从由到远、高度不增加的多个导弹。

但是现在，科学家们发现这个防御系统还不够强大，所以他们发明了另外一套导弹系统。

这个新系统可以发射一颗导弹由近到远的拦截更多的导弹。

当这个系统启动，首先选择一颗敌人的导弹进行拦截，然后拦截一颗更远的高度更低的导弹进行拦截，然后拦截比第二颗更远的但高度更高的导弹……以此类推，拦截的第奇数颗导弹比前一颗导弹更远、更高，拦截的第偶数颗导弹比前一个更远、更低。

现在，给你一个从近到远的导弹高度列表，计算新系统发射一颗导弹可以拦截的最多的导弹数目。

## 说明/提示

$1\leq n\leq 10^3$，$1\leq $ 导弹高度 $\leq 10^9$。

## 样例 #1

### 输入

```
4
5 3 2 4```

### 输出

```
3```

# AI分析结果



## 算法分类
动态规划 / 贪心

---

## 题解思路与核心难点分析

### 核心算法思路
题目要求找出最长交替上升下降序列。两种主流解法：
1. **贪心算法**（O(n)）：统计峰谷点数量，通过一次遍历维护交替状态。
2. **动态规划**（O(n²)）：定义 `dp[i][0/1]` 表示以第 i 个导弹结尾的最后一步是下降/上升时的最大长度。

### 解决难点对比
- **贪心**：正确识别交替趋势的变化点，处理初始状态与趋势切换。
- **动态规划**：状态转移需严格满足奇偶交替条件，需遍历所有历史状态。

---

## 高星题解推荐（≥4星）

### 1. Weng_Weijie（贪心） ⭐⭐⭐⭐⭐
- **亮点**：O(n) 时间复杂度，简洁高效。通过维护当前趋势标记 `flag` 统计峰谷点。
- **代码片段**：
  ```cpp
  int flag = 0, ans = 1;
  while (--n) {
      last = now;
      scanf("%d", &now);
      if (flag ^ (now < last)) 
          ans++, flag = now < last;
  }
  ```

### 2. gaowеnxuan（动态规划） ⭐⭐⭐⭐
- **亮点**：经典双状态 DP 思路，代码可读性强。
- **核心逻辑**：
  ```cpp
  for (int j=1; j<i; j++) {
      if (a[j]<a[i]) dp[i][1] = max(dp[i][1], dp[j][0]+1);
      if (a[j]>a[i]) dp[i][0] = max(dp[i][0], dp[j][1]+1);
  }
  ```

### 3. Great_Influence（动态规划） ⭐⭐⭐⭐
- **亮点**：状态命名清晰，代码结构模块化。
- **关键代码**：
  ```cpp
  if (a[i]>a[j] && dp2[i]<dp1[j]+1) dp2[i]=dp1[j]+1;
  else if (a[i]<a[j] && dp1[i]<dp2[j]+1) dp1[i]=dp2[j]+1;
  ```

---

## 最优思路提炼
**贪心算法**是本题最优解：
1. **趋势交替检测**：通过异或操作判断当前趋势是否变化。
2. **线性遍历**：仅需一次扫描，维护当前趋势标记和计数器。

---

## 相似题目推荐
1. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 交替序列变种。
2. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020) - 经典最长不升子序列。
3. [P1567 统计天数](https://www.luogu.com.cn/problem/P1567) - 连续趋势统计。

---

## 可视化算法设计

### 贪心算法动画演示
1. **元素高亮**：当前导弹高度与前一导弹用不同颜色标记。
2. **趋势标记**：右侧面板显示当前趋势（↑ 或 ↓）。
3. **计数器更新**：每次趋势变化时，显示 `ans++` 的动画效果。

```javascript
// 伪代码示例
function visualizeGreedy(heights) {
    let flag = 0, ans = 1;
    for (let i = 1; i < heights.length; i++) {
        highlight(i-1, i); // 高亮相邻元素
        const trend = (heights[i] < heights[i-1]);
        if (flag ^ trend) {
            ans++;
            flag = trend;
            playSound('up'); // 趋势变化音效
        }
        updateCounter(ans); // 更新显示计数器
    }
}
```

### 复古像素风格设计
- **画风**：16色像素网格，导弹高度用竖条表示。
- **音效**：8-bit 风格音效，趋势变化时播放 "beep"。
- **交互**：支持暂停/继续，速度调节（1x/2x/5x）。

---

## 核心代码（贪心实现）
```cpp
#include <stdio.h>
int main() {
    int n, last, now, flag = 0, ans = 1;
    scanf("%d%d", &n, &now);
    while (--n) {
        last = now;
        scanf("%d", &now);
        if (now == last) continue;
        if (flag ^ (now < last)) 
            ans++, flag = now < last;
    }
    printf("%d\n", ans);
    return 0;
}
```

---
处理用时：280.76秒
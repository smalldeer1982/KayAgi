# 题目信息

# 最大食物链计数

## 题目背景

你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。


## 题目描述

给你一个食物网，你要求出这个食物网中最大食物链的数量。

（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）

Delia 非常急，所以你只有 $1$ 秒的时间。

由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。


## 说明/提示

各测试点满足以下约定：

 ![](https://cdn.luogu.com.cn/upload/pic/12011.png) 

【补充说明】

数据中不会出现环，满足生物学的要求。（感谢 @AKEE ）


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 3
3 5
2 5
4 5
3 4```

### 输出

```
5```

# AI分析结果



## 唯一算法分类
线性DP

---

## 综合分析与结论

### 核心思路
题目本质是**DAG路径计数问题**，所有解法的核心都是通过拓扑排序或记忆化搜索实现动态规划。关键点在于：
1. **状态定义**：`dp[i]` 表示以节点i结尾的最大食物链数量
2. **状态转移**：`dp[next] += dp[curr]`，即每个节点的路径数等于所有前驱节点路径数之和
3. **边界条件**：入度为0的节点（生产者）初始化为1
4. **结果计算**：累加所有出度为0节点（顶级消费者）的路径数

### 可视化设计
1. **动画方案**：
   - 用网格展示每个节点的入度、出度、dp值
   - 拓扑排序过程中，用绿色高亮正在处理的节点，红色标记入队节点，蓝色标记已处理节点
   - 状态转移时，用箭头动态展示当前节点向相邻节点的数值传递过程
   - 示例：处理节点3时，显示其dp值2传递到节点4和5的过程

2. **复古像素风格**：
   - 使用16色调色板，节点用8-bit像素块表示
   - 背景音乐采用8-bit音效，当节点入队时播放"滴"声，路径更新时播放"哒"声
   - Canvas网格动态绘制拓扑顺序，用闪烁效果标记关键路径

---

## 题解清单（≥4星）

### 1. 御·Dragon（★★★★★）
- **亮点**：图文并茂的拓扑排序过程解释，完整的状态转移动画示意图
- **关键代码**：
```cpp
while(!q.empty()) {
    int tot = q.front(); q.pop();
    for(auto next : nei[tot]) {
        num[next] = (num[next] + num[tot]) % mod;
        if(--in[next] == 0) q.push(next);
    }
}
```

### 2. Watcher（★★★★☆）
- **亮点**：对比邻接矩阵与邻接表实现，给出复杂度分析
- **优化点**：使用链式前向星存储，空间复杂度O(M)

### 3. Dog_Two（★★★★☆）
- **亮点**：反向DFS记忆化搜索的独特视角
- **状态方程**：`f[i] = Σf[j] (j为i的前驱)`

---

## 核心代码实现

### 拓扑排序+DP标准实现
```cpp
const int MOD = 80112002;
vector<int> G[5005];
int in[5005], out[5005], dp[5005];

int main() {
    // 建图
    for(int i=0; i<m; i++){
        int a, b; cin >> a >> b;
        G[a].push_back(b);
        out[a]++; in[b]++;
    }
    
    // 拓扑初始化
    queue<int> q;
    for(int i=1; i<=n; i++)
        if(in[i] == 0) {
            dp[i] = 1;
            q.push(i);
        }
    
    // 拓扑DP
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int v : G[u]) {
            dp[v] = (dp[v] + dp[u]) % MOD;
            if(--in[v] == 0) q.push(v);
        }
    }
    
    // 计算结果
    int ans = 0;
    for(int i=1; i<=n; i++)
        if(out[i] == 0)
            ans = (ans + dp[i]) % MOD;
    cout << ans;
}
```

---

## 同类型题目推荐
1. P4017 最大食物链计数（本题）
2. P1137 旅行计划（DAG最长路径）
3. P2712 课程表（拓扑排序基础）

---

## 可视化代码片段（Canvas动画）

```javascript
// 绘制节点状态
function drawNode(ctx, x, y, state) {
    const colors = { 
        'default': '#4CAF50', 
        'active': '#FF5722', 
        'processed': '#2196F3' 
    };
    ctx.fillStyle = colors[state];
    ctx.fillRect(x*50, y*50, 40, 40);
}

// 更新动画帧
function updateFrame(queue, dp) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    queue.forEach((node, idx) => {
        drawNode(ctx, idx, 0, 'active');
        drawText(dp[node], idx*50+10, 30);
    });
    // 播放音效
    if(queue.length > prevLen) beep(440, 50);
}
```

---

## 关键思维点
1. **拓扑序的天然DP顺序**：确保处理节点时所有前驱已计算完成
2. **模运算优化**：每次更新立即取模，避免数值溢出
3. **出度判断的剪枝**：最终只统计出度为0的节点，减少无效计算

通过将DAG的拓扑性质与动态规划结合，实现了时间复杂度O(N+M)的最优解法。

---
处理用时：56.96秒
# 题目信息

# [yLOI2019] 青原樱

## 题目背景

> 星川之下皆萤火尘埃，  
> 我独行在人潮你天真而待。  
> 相遇若是借丹青着色，  
> 青原上 绯樱如海。

——银临《青原樱》(Cover 人衣大人)

## 题目描述

扶苏是一个非常喜欢边听古风鸽边写数学题的人，因此这道题其实是个五三原题。

扶苏希望重现青原上樱花盛开的景色，于是他准备了很多**互不相同**樱花树幼苗，准备种成一行。

这一行中，一共有 $n$ 个位置可以种下樱花，而扶苏准备了 $m$ 支幼苗。由于樱花盛放时对左右空间需求非常大，所以樱花不能紧挨着种植，也就是任意两支幼苗之间必须至少存在一个不种花的空位置。

按照这种方式种花并不难，但是令扶苏感到好奇的是一共有多少合法的方案让他把这 $m$ 支幼苗都种下去。一个方案是合法的当且仅当他满足上一段中叙述的要求。如果我们将花按照 $1,2,3,\dots,m$ 编号，两种方案不同当且仅当被选择种花的位置不同或从左向右数花的编号序列不同。

为了避免输出过大，答案对一个参数 $p$ 取模。

## 说明/提示

#### 样例输入输出 1 解释
一共有 $2$ 个樱花幼苗， $3$ 个种花的位置，如果给幼苗编号为 $1,~2$，位置编号为 $1,~2,~3$，那么两种方案分别如下：

| 位置 | $1$ | $2$ | $3$ |
| :---: | :---: | :---: | :---: |
| 方案 1 | 幼苗 $1$ | 空 | 幼苗 $2$ |
| 方案 2 | 幼苗 $2$ | 空 | 幼苗 $1$ |

---

#### 数据规模与约定

**本题采用多测试点捆绑测试，共有 6 个子任务**。

| 子任务编号 | $n \leq$ | $m \leq$ | $type=$ | 特殊性质 | 子任务分值 |
| :----------: | :--------: | :----------: | :-------: | :--------: | :-----------: |
| 1 | $1$ | $1$ | $0$ | 特殊性质 1 | $5$ |
| 2 | $20$ | $20$ | $1$ | 特殊性质 1 | $15$ |
| 3 | $400$ | $200$ | $2$ | 无 | $20$ |
| 4 | $2000$ | $2000$ | $3$ | 无 | $20$ |
| 5 | $2000000$ | $1000000$ | $4$| 特殊性质 2 | $20$ | 
| 6 | $2000000$ | $1000000$ | $5$| 无 | $20$ | 

特殊性质 1：保证对应测试点的**实际**方案数(在取模前)不超过 $10^6$

特殊性质 2：保证 $p$ 是一个质数。

对于 $100\%$ 的数据，保证：
- $1 \leq n \leq 2 \times 10^6$。
- $1 \leq m \leq 10^6 $。
- $1 \leq p \leq 10^9$。
- $1 \leq m \leq \lceil\frac{n}{2} \rceil$。

---

#### 提示

- 请使用合适的数据类型来进行运算，避免溢出。
- 参数 $type$ 可以帮助你快速的判断子任务编号。


## 样例 #1

### 输入

```
1 3 2 19260718```

### 输出

```
2```

# AI分析结果



## 算法分类
**组合数学/排列数**

## 综合分析与结论
**核心思路**：  
题目要求计算在n个位置中放置m棵互不相同樱花树的方案数，满足任意两棵树之间至少一个空位。通过数学建模可转化为排列问题，即从可选的空位中选取m个位置进行有序排列，关键公式为排列数A(n−m+1, m)。

**解决难点**：  
1. **空间转化**：将原问题转化为“插空”模型。预先留出m−1个空位，保证每两棵树之间至少有一个空位，剩余n−m+1个位置可自由放置m棵树。
2. **有序排列**：树苗互不相同，因此需计算排列数而非组合数。
3. **大数处理**：通过逐项连乘并取模避免溢出，时间复杂度O(m)，满足题目规模。

**可视化设计要点**：  
1. **插空法示意图**：展示n个位置中预留m−1个空位，剩余位置形成n−m+1个“插槽”，每个插槽对应一棵树的放置位置。
2. **排列数动态计算**：以像素风格动态绘制乘积过程，每步高亮当前乘数，并显示中间结果。
3. **复古音效**：每次乘法操作触发8-bit音效，完成计算时播放胜利音效。

---

## 题解评分（≥4星）
1. **yyh_1102（5星）**  
   - 亮点：详细讲解排列组合基础，配以大量例题，适合新手理解。  
   - 代码简洁，直接计算排列数。

2. **一扶苏一（4星）**  
   - 亮点：严谨数学推导，分情况讨论后合并为排列数公式。  
   - 代码高效，但推导过程稍复杂。

3. **ez_lcw（4星）**  
   - 亮点：思路简洁，代码清晰，直接点明插空法核心。  
   - 适合快速理解核心逻辑。

---

## 最优思路与代码实现
**核心公式**：  
答案 = A(n−m+1, m) = (n−m+1) × (n−m) × ... × (n−2m+2)  
**代码实现**：
```cpp
#include <cstdio>
using namespace std;

int main() {
    int type, n, m, p;
    scanf("%d%d%d%d", &type, &n, &m, &p);
    long long ans = 1;
    for (int i = n - m + 1; i >= n - 2 * m + 2; --i) {
        ans = ans * i % p;
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 相似题目推荐
1. **P1246 编码**（排列组合应用）  
2. **P3197 [HNOI2008]越狱**（排列组合与容斥）  
3. **P3223 [HNOI2012]排队**（复杂插空与排列）

---

## 可视化设计（像素风格示例）
```javascript
// 伪代码：Canvas绘制排列数计算过程
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
let currentStep = 0;

function drawStep(step) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 绘制当前乘积项（像素风格）
    ctx.fillStyle = '#FF69B4'; // 高亮色
    ctx.fillRect(step * 16, 0, 16, 16);
    // 显示当前数值
    ctx.fillText(`×${n - m + 1 - step}`, step * 16, 32);
}

// 音效触发
function playBeep() {
    const oscillator = audioCtx.createOscillator();
    oscillator.frequency.setValueAtTime(440 + currentStep * 100, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.1);
}

// 自动播放循环
setInterval(() => {
    if (currentStep < m) {
        drawStep(currentStep);
        playBeep();
        currentStep++;
    }
}, 500);
```

---

**总结**：通过插空法将问题转化为排列数计算，结合高效连乘实现，时间复杂度O(m)，完美适配题目数据规模。可视化设计增强理解，像素动画与音效提升学习趣味性。

---
处理用时：77.97秒
# 题目信息

# [USACO10OPEN] Mountain Watching S

## 题目描述

一天，Bessie 望着远处的山脉，在思考：“哪一座山最宽呢？”

Bessie 设法测量了 $N$ 个位置的高度 $h_i$（$1 \leq N \leq 10^5$，$1 \leq h_i \leq 10^9$）。一座山被定义为一个高度先不下降，后不上升的子序列。视野边缘的山脉也只会增加或减少高度。一座山的宽度被定义为这座山包含的位置数量。

下面是一个例子：

```plain
           *******                   *
          *********                 ***
          **********               *****
          ***********           *********               *
*      *****************       ***********             *** *
**    *******************     *************   * *     *******      *
**********************************************************************
3211112333677777776543332111112344456765432111212111112343232111111211
aaaaaa                   ccccccccccccccccccccc eeeeeee    ggggggggg
  bbbbbbbbbbbbbbbbbbbbbbbbbbbb             ddddd ffffffffff  hhhhhhhhh
```

每座山都已经用字母标出来了。这里 `b` 山脉的宽度最大，为 $28$。

## 样例 #1

### 输入

```
7
3
2
3
5
4
1
6```

### 输出

```
5```

# AI分析结果



**唯一算法分类**：动态规划

---

### 题解思路、算法要点与解决难点

#### 核心思路
山脉定义为**连续先不下降后不上升的子序列**。最优解法基于动态规划预处理每个点的左右最长连续子序列：
1. **预处理左不下降序列（`up`数组）**：`up[i]`表示以`i`结尾的最长连续不下降子序列长度。
2. **预处理右不上升序列（`down`数组）**：`down[i]`表示以`i`开头的最长连续不上升子序列长度。
3. **合并结果**：每个点`i`的山脉宽度为`up[i] + down[i] - 1`，取最大值即为答案。

#### 解决难点
1. **时间复杂度优化**：传统双重循环遍历每个点的左右边界会达到`O(n²)`，无法处理`n=1e5`。动态规划预处理将复杂度降至`O(n)`。
2. **边界处理**：预处理时需正确处理首尾元素的初始值，避免数组越界。
3. **峰顶重复计算**：合并左右序列时减去重复计算的峰顶点。

---

### 题解评分（≥4星）

1. **Link_Cut_Y（4星）**  
   - 思路清晰，代码简洁，预处理`up`和`down`数组，时间复杂度`O(n)`。  
   - 关键代码：
     ```cpp
     for (int i = 1; i <= n; i++)
         up[i] = h[i] >= h[i-1] ? up[i-1]+1 : 1;
     for (int i = n; i >= 1; i--)
         down[i] = h[i] >= h[i+1] ? down[i+1]+1 : 1;
     ```

2. **Remake_（4星）**  
   - 明确预处理方向，代码逻辑严谨，处理边界初始化。  
   - 关键代码：
     ```cpp
     up[1] = 1;
     for (int i = 2; i <= n; i++)
         up[i] = (h[i] >= h[i-1]) ? up[i-1]+1 : 1;
     down[n] = 1;
     for (int i = n-1; i >= 1; i--)
         down[i] = (h[i] >= h[i+1]) ? down[i+1]+1 : 1;
     ```

3. **V1mnkE（4星）**  
   - 与上述解法一致，变量命名更直观，适合快速理解。

---

### 最优思路或技巧提炼

1. **双数组预处理**：通过`up`和`down`数组分别记录左右连续子序列长度，合并后取最大值。
2. **线性时间复杂度**：通过一次正向遍历和一次反向遍历，避免嵌套循环。
3. **边界初始化**：`up[1] = 1`和`down[n] = 1`确保首尾元素的正确计算。

---

### 同类型题或类似算法套路

1. **最长递增子序列（LIS）**：动态规划或贪心+二分。
2. **合唱队形问题（P1091）**：双向动态规划求最长递增后递减子序列。
3. **山脉数组（P8528）**：类似预处理左右序列的思路。

---

### 推荐相似题目

1. **P1091 合唱队形**  
   - 双向动态规划，求最长先增后减子序列。
2. **P1566 山脉**  
   - 类似单峰山脉的最长长度计算。
3. **P2947 [USACO09MAR] Look Up S**  
   - 预处理右侧第一个更大元素的位置。

---

### 可视化与算法演示

**动画方案**：  
1. **颜色标记**：  
   - 红色高亮当前处理的`i`点，蓝色标记`up[i]`和`down[i]`的扩展范围。  
   - 绿色显示当前最大山脉长度。  
2. **步进控制**：  
   - 支持单步执行，观察`up`和`down`数组的更新过程。  
3. **Canvas 演示**：  
   - 横向柱状图表示数组元素，左右延伸的箭头表示`up`和`down`的扩展过程。

**复古像素风格设计**：  
- **8位音效**：播放“哔”声标记每次数组更新，找到最大值时播放胜利音效。  
- **像素网格**：用方块高度表示数组值，左右延伸的色块表示预处理范围。

---

### 核心代码实现

```cpp
#include <iostream>
using namespace std;

const int N = 1e5 + 10;
int n, h[N], up[N], down[N];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> h[i];
    
    // 预处理左不下降序列
    up[1] = 1;
    for (int i = 2; i <= n; i++)
        up[i] = (h[i] >= h[i-1]) ? up[i-1] + 1 : 1;
    
    // 预处理右不上升序列
    down[n] = 1;
    for (int i = n-1; i >= 1; i--)
        down[i] = (h[i] >= h[i+1]) ? down[i+1] + 1 : 1;
    
    // 合并结果
    int ans = 0;
    for (int i = 1; i <= n; i++)
        ans = max(ans, up[i] + down[i] - 1);
    
    cout << ans;
    return 0;
}
```

---
处理用时：172.82秒
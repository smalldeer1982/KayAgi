# 题目信息

# [USACO06OCT] Cow Pie Treasures G

## 题目描述

奶牛们制作了一些藏有金币的馅饼，并把它们排成了一个 $r$ 行 $c$ 列的矩阵。现在，你需要从坐标为 $(1,1)$ 的馅饼旁移动到坐标为 $(r,c)$ 的馅饼旁。对于每次移动，你必须向右移动一列，并且行数的变动不能超过 $1$。即如果你处于坐标为 $(x,y)$ 的馅饼旁，你只能移动到坐标为 $(x-1,y+1)$，$(x,y+1)$ 或 $(x+1,y+1)$ 的馅饼旁。在一个馅饼旁停留时，你可以拿走其中所有的金币。当然，你一定不愿意中途离开矩阵而放弃这些金币。

奶牛们把标有矩阵中每一块馅饼所藏金币数的表格交给了你。你想知道按照以上规则，自己最多能拿到多少金币。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le r,c\le 100$，$1\le t\le 25$。

------------

**【样例说明】**

![](https://cdn.luogu.com.cn/upload/image_hosting/pgw19uqm.png)

样例给出的矩阵如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/hwhzq9oy.png)

这是一种合法的移动方式。你可以拿到 $47$ 枚金币。

![](https://cdn.luogu.com.cn/upload/image_hosting/sdyxlpv5.png)

在这个矩阵中你最多能拿到 $50$ 枚金币，路线如图所示。

## 样例 #1

### 输入

```
3 7
6 5 3 7 9 2 7
2 4 3 5 6 8 6
4 9 9 9 1 5 8```

### 输出

```
50```

# AI分析结果



## 算法分类选择
**线性DP**

## 题解思路、算法要点与解决难点
### 核心思路
题目要求从矩阵左上角移动到右下角，每次只能向右移动一列且行变动不超过1。动态规划（DP）是核心解法，状态定义为 `dp[i][j]` 表示到达坐标 `(i,j)` 时的最大金币数。状态转移方程为：  
`dp[i][j] = max(dp[i-1][j-1], dp[i][j-1], dp[i+1][j-1]) + a[i][j]`

### 解决难点
1. **不可达区域处理**：列 `j` 的行数 `i` 必须满足 `i ≤ j` 且 `i ≤ r`，否则路径无法到达。
2. **初始化问题**：DP数组需初始化为极小值，避免未达位置干扰最大值计算。
3. **遍历顺序**：必须按列遍历（从左到右），每列内部按行遍历，确保前一列状态已计算。

### 算法要点
- **状态转移方程**：从上一列的三个相邻行取最大值。
- **边界限制**：列的遍历范围需限制行的有效范围。
- **初始化优化**：起点 `dp[1][1] = a[1][1]`，其他位置初始化为负无穷。

---

## 题解评分 (≥4星)
### WaltVBAlston (★★★★☆)
- **亮点**：通过限制 `j <= i` 解决不可达区域问题，代码简洁高效。
- **代码**：限制行范围，正确初始化。
```cpp
for(int j=1;j<=m;j++)
    for(int i=1;i<=n&&i<=j;i++)  // 关键边界处理
```

### monstersqwq (★★★★☆)
- **亮点**：明确不可达区域的数学推导，强调遍历顺序重要性。
- **心得**：指出斜线左侧区域不可达，需限制循环条件。

### LongDouble (★★★★☆)
- **亮点**：通过初始化避免干扰，代码逻辑清晰。
- **代码**：初始化 `dp` 为负无穷，确保无效状态不影响结果。
```cpp
memset(dp, -0x3f, sizeof dp);
dp[1][1] = t[1][1];
```

---

## 最优思路与技巧提炼
1. **状态转移方程**：从上一列的三个方向取最大值，体现线性DP的递推关系。
2. **遍历顺序优化**：按列遍历，避免状态覆盖问题。
3. **边界处理**：通过 `i <= min(j, r)` 限制不可达区域。
4. **初始化技巧**：负无穷初始化排除无效状态。

---

## 同类型题与算法套路
- **常见套路**：二维矩阵路径问题，状态转移依赖相邻行/列。
- **类似题目**：
  - 数字三角形（路径最大值）
  - 不同路径（移动方式限制）
  - 最小路径和（权值累加）

---

## 推荐相似题目
1. **P1216 [USACO1.5]数字三角形**  
   （二维DP，路径选择）
2. **P1002 [NOIP2002 普及组]过河卒**  
   （状态转移+障碍处理）
3. **P1434 [SHOI2002]滑雪**  
   （记忆化搜索/DP，矩阵移动）

---

## 个人心得摘录
- **WaltVBAlston**：首次提交未限制边界导致WA，通过分析斜线不可达区域修正。
- **LongDouble**：调试时发现未初始化导致错误，强调初始化的重要性。
- **monstersqwq**：指出不可达区域的数学推导是解题关键。

---

## 可视化与算法演示
### 动态规划动画方案
1. **网格绘制**：用Canvas绘制 `r×c` 网格，每个格子显示 `dp[i][j]` 值。
2. **颜色标记**：
   - 当前处理列：黄色高亮。
   - 转移来源格子（上一列）：绿色边框。
   - 最大值路径：红色箭头。
3. **步进控制**：
   - 自动播放：按列逐步更新。
   - 手动步进：点击按钮单步执行。
4. **复古像素风格**：
   - 8位色调色板（红、黄、绿、蓝）。
   - 音效：状态更新时播放“哔”声，路径更新时播放“叮”声。

### 代码片段（Canvas绘制核心）
```javascript
function drawGrid() {
    ctx.fillStyle = "#000";
    for (let j = 1; j <= c; j++) {
        for (let i = 1; i <= r; i++) {
            if (i > j) continue; // 不可达区域灰色
            ctx.fillText(dp[i][j], x, y);
        }
    }
}
```

---

## 最终代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int r, c, a[105][105], dp[105][105];

int main() {
    memset(dp, -0x3f, sizeof(dp));
    cin >> r >> c;
    for (int i = 1; i <= r; i++)
        for (int j = 1; j <= c; j++)
            cin >> a[i][j];
    dp[1][1] = a[1][1];
    for (int j = 2; j <= c; j++) // 从第二列开始
        for (int i = 1; i <= j && i <= r; i++) // 关键边界
            dp[i][j] = max({dp[i-1][j-1], dp[i][j-1], dp[i+1][j-1]}) + a[i][j];
    cout << dp[r][c];
    return 0;
}
```

---
处理用时：58.98秒
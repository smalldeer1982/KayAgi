# 题目信息

# 「dWoi R1」Sixth Monokuma's Son

## 题目背景

题目首先定义矩阵环为，给定一个矩阵 $A$，初始全为白色，在其中选定一个子矩阵 $A_1$ 标黑，再在 $A_1$ 内选定一个子矩阵 $A_2$ 标白，就会形成一个矩阵环。注意，矩阵环至少上下左右都有被选定的部分，且整个矩阵环不是一个长方形的矩阵。

假设 `+` 为黑，`-` 为白，下面这个就是矩阵环：

```
---+++++--
---++--+--
---+++++--
---+++++--
----------
```

下面就不是矩阵环：

```
------- ------
---+++- --+++-
---+-+- --+++-
------- --+++-
```

因此，矩阵环会出现上，下，左，右四条边，每个方向有多少个涂黑的部分，就是那个方向的厚度。比如对于第一张符合要求的图，上方，右方的厚度为 $1$，左方，下方的厚度为 $2$。

**注意，一个完整的矩阵不是一个矩阵环。**

---

接下来是正经的题目背景：

最原得到了“狱原发现一些小昆虫”这个线索后，立刻采取了行动。首先，他利用入间的 ~~遗物~~，那个类似喷火器的东西，吸进了一些空气，然后，他打算利用机望的机械眼进行查看。

## 题目描述

机望的机械眼能扫到一片 $n \times m$ 的区域，第 $i$ 行第 $j$ 列发现了 $a_{i,j}$ 的不对劲值。

因为机望被外部力量折磨的厉害，所以机望只能锁定一个矩阵环进行查看。机望想求助于你，他想让你锁定一个矩阵环，使得这个矩阵环中的所有位置的不对劲值的和最大，**上方，下方的厚度为 $1$ 且上方的那一行在整个区域的第一行，下方的那一行在整个区域的最后一行**。至于左右的厚度，机望不限制更多要求。

## 说明/提示

#### 样例说明

关于样例 1 的解释：

可以选择如下形式的矩阵环（但其实两个解是一样的，因为第一列所有数之和为 $0$）：

```
++++  -+++
++-+  -+-+
++-+  -+-+
++++  -+++
```

其中 + 为选定的，- 为未选定的。

关于样例 3，提供者 @[cmll02](https://www.luogu.com.cn/user/171487)，感谢他的贡献。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（5 pts）：$n \le 2$ 或 $m \le 2$。
- Subtask 2（5 pts）：$a_{i,j}>0$。
- Subtask 3（40 pts）：$m \le 1000$。
- Subtask 4（50 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 10$，$1 \le m \le 10^5$，$|a_{i,j}| \le 100$。

## 样例 #1

### 输入

```
4 4
3 -4 2 -2
-5 3 -4 2
-1 3 -4 0
3 -3 3 4```

### 输出

```
8```

## 样例 #2

### 输入

```
1 2
11 45```

### 输出

```
-1```

## 样例 #3

### 输入

```
7 7
10 10 10 -100 11   11 11
10 10 10 -100 11 -100 11
10 10 10 -100 11 -100 11
10 10 10 -100 11 -100 11
10 10 10 -100 11 -100 11
10 10 10 -100 11 -100 11
10 10 10 -100 11   11 11```

### 输出

```
176```

# AI分析结果



## 算法分类
**线性DP**

---

## 题解思路与解决难点
### 核心思路
将矩阵环拆分为三个部分：
1. **左部**：由若干完整列组成，每列全选。
2. **中部**：仅保留每列的首尾元素（上下两行），形成空心区域。
3. **右部**：由若干完整列组成，每列全选。

通过预处理每列的总和 `s[i]` 和首尾元素和 `t[i]`，设计三阶段的线性动态规划模型：
- **dp1[i]**：前 `i` 列左部的最大和。
- **dp2[i]**：前 `i` 列左部+中部的最大和（C型结构）。
- **dp3[i]**：前 `i` 列左部+中部+右部的完整矩阵环最大和。

### 关键难点与解决
1. **状态转移方程设计**：
   - **左部转移**：`dp1[i] = max(dp1[i-1], 0) + s[i]`  
     确保左部非空且连续。
   - **中部转移**：`dp2[i] = max(dp2[i-1], dp1[i-1]) + t[i]`  
     左部结束后才能进入中部。
   - **右部转移**：`dp3[i] = max(dp3[i-1], dp2[i-1]) + s[i]`  
     中部结束后才能进入右部，确保环结构完整。

2. **边界处理**：
   - 初始化 `dp1[0] = dp2[0] = dp3[0] = -inf`，避免空状态干扰。
   - 特判 `n ≤ 2` 或 `m ≤ 2` 时无解。

---

## 最优思路提炼
1. **分阶段动态规划**：通过三阶段 DP 分别处理左、中、右部分，确保各部分非空且顺序正确。
2. **预处理简化计算**：提前计算每列总和 `s[i]` 和首尾和 `t[i]`，避免重复计算。
3. **贪心思想**：在状态转移时选择当前最优路径（如 `max(dp1[i-1], 0)` 避免负收益）。

---

## 推荐相似题目
1. **P1115 最大子段和**  
   单阶段最大连续子数组和的经典问题。
2. **P2642 双子序列最大和**  
   分两阶段的最大子段和问题，需动态规划组合。
3. **P1121 环状最大两段子段和**  
   环形数组下的两段子段和，需特殊处理环形条件。

---

## 题解评分 (≥4星)
### wsyhb（5星）
- **亮点**：代码简洁，状态转移清晰，预处理与 DP 结合紧密，完美处理边界条件。
- **核心代码**：
  ```cpp
  dp1[i] = max(dp1[i-1], 0) + s[i];
  dp2[i] = max(dp2[i-1], dp1[i-1]) + t[i];
  dp3[i] = max(dp3[i-1], dp2[i-1]) + s[i];
  ```

### xuan_gong_dong（4星）
- **亮点**：详细图解辅助理解，变量命名直观，但初始化部分稍显冗余。
- **核心代码**：
  ```cpp
  dp[i][0] = max(dp[i-1][0],0) + pre[i];
  dp[i][1] = max(dp[i-1][0],dp[i-1][1]) + hys[i];
  ```

### 一只书虫仔（4星）
- **亮点**：分阶段拆解问题，结合示意图解释清晰，但代码变量名可读性稍弱。

---

## 可视化与算法演示
### 动态规划动画设计
- **网格展示**：以列为单位，用不同颜色表示左（蓝）、中（黄）、右（绿）三部分。
- **状态更新**：高亮当前列，箭头指向 `dp1`/`dp2`/`dp3` 的更新来源。
- **数据标注**：在每列上方显示 `s[i]` 和 `t[i]`，右侧显示当前 DP 数组值。

### 复古像素风格实现
- **8位调色板**：左部深蓝，中部亮黄，右部草绿，背景灰色网格。
- **音效设计**：
  - **状态转移**：短促“滴”声。
  - **更新最大值**：上扬“成功”音效。
- **自动演示**：按列逐步推进，速度可调，支持暂停/继续。

---

## 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=10+5, max_m=1e5+5;
int s[max_m], t[max_m], dp1[max_m], dp2[max_m], dp3[max_m];

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    if(n <= 2 || m <= 2) { puts("-1"); return 0; }
    
    // 预处理每列的总和s和首尾和t
    for(int i=1; i<=n; ++i)
        for(int j=1; j<=m; ++j) {
            int a; scanf("%d", &a);
            s[j] += a;
            if(i == 1 || i == n) t[j] += a;
        }
    
    // 初始化边界
    dp1[0] = dp2[0] = dp3[0] = -1e9;
    int ans = -1e9;
    
    // 三阶段DP转移
    for(int i=1; i<=m; ++i) {
        dp1[i] = max(dp1[i-1], 0) + s[i];
        if(i > 1) {
            dp2[i] = max(dp2[i-1], dp1[i-1]) + t[i];
            if(i > 2) {
                dp3[i] = max(dp3[i-1], dp2[i-1]) + s[i];
                ans = max(ans, dp3[i]);
            }
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

---
处理用时：70.66秒
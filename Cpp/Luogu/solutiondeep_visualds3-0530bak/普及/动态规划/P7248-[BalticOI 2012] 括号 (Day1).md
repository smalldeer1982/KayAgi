# 题目信息

# [BalticOI 2012] 括号 (Day1)

## 题目描述

一个合法括号序列的定义如下：

- () 和 [] 是合法括号序列
- 若 A 是合法括号序列，则 (A) 和 [A] 也是合法括号序列
- 若 A 和 B 都是合法括号序列，则 AB 也是合法括号序列

在包含至少一对方括号的合法括号序列中，我们可以将 [ 和 ] 都用 ( 代替，这样就能够得到一个不合法括号序列。

例如 (( 和 ((((())) 都是不合法括号序列，前者可以由合法括号序列 \[] 转化而来，后者可以通过 \[]((()))，(\[](()))，((\[]())) 和 (((\[]))) 这四种合法括号序列转化而来。

现在给出一个不合法括号序列，求有多少种合法括号序列，在将其中的方括号用 ( 代替后，可以得到给定的括号序列。

## 说明/提示

**【样例解释#1】** 

满足条件的合法括号序列有两种：\[]() 和 ([])。

**【数据范围】**

- 对于 20% 的数据，满足 $n \leq 50$
- 对于 50% 的数据，满足 $n \leq 1000$
- 对于 100% 的数据，满足 $2\leq n \leq 30000$

**【说明】**

译自 [BalticOI 2012 Day1 T1. Brackets](http://www.boi2012.lv/data/day1/eng/brackets.pdf)

## 样例 #1

### 输入

```
4
((()```

### 输出

```
2```

## 样例 #2

### 输入

```
8
((((((((```

### 输出

```
14```

# AI分析结果



**【唯一算法分类】**  
动态规划

---

**【题解思路、算法要点与解决难点】**  
**核心思路**：将原问题转化为统计纯圆括号合法序列的数量。合法括号序列中的方括号替换为圆括号后，得到的序列必为纯圆括号的合法序列。通过逆向思维，只需计算给定序列对应的合法纯圆括号序列数。

**算法实现**：  
1. **状态定义**：`dp[i][j]` 表示处理到第 `i` 个字符时，未匹配的左括号数量为 `j` 的方案数。  
2. **状态转移**：  
   - 当前字符为 `)`：只能从前一状态 `j+1` 转移，即 `dp[i][j] = dp[i-1][j+1]`。  
   - 当前字符为 `(`：可从两个方向转移，新增左括号（`j-1→j`）或匹配右括号（`j+1→j`），即 `dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]`。  
3. **空间优化**：使用滚动数组（交替两行）将空间复杂度从 `O(n²)` 降为 `O(n)`。  
4. **边界处理**：`j` 的范围限制为 `0 ≤ j ≤ min(i, n-i)`，确保左括号数量不超过剩余位置可匹配的上限。

**解决难点**：  
- **问题转化**：通过数学证明将复杂的中括号替换问题转化为纯圆括号序列计数。  
- **状态转移优化**：利用滚动数组和循环范围限制，使 `O(n²)` 算法在 `n=3e4` 的数据下通过卡常通过。

---

**【题解评分 (≥4星)】**  
1. **quest_2（5星）**  
   - **亮点**：详细推导问题转化过程，解释状态转移逻辑，提供官方题解背景分析，代码清晰并附注释。  
   - **引用心得**：提到“官方题解复杂度是假的，但通过卡常可通过”，体现对时间复杂度的深入思考。  
2. **xw_qwq（4星）**  
   - **亮点**：代码简洁高效，明确标注转移方程，适合快速理解核心逻辑。  
3. **船酱魔王（4星）**  
   - **亮点**：提出匹配关系的充要条件分析，代码中优化循环边界（`opt = 1 + n/2`），减少无效计算。

---

**【最优思路或技巧提炼】**  
1. **逆向思维**：将中括号替换问题转化为纯圆括号序列计数，避免直接处理混合括号的复杂性。  
2. **滚动数组**：通过交替使用两行数组，大幅降低空间占用，适用于线性动态规划问题。  
3. **范围剪枝**：在循环中限制 `j ≤ min(i, n-i)`，减少无效状态转移，优化常数。  
4. **数学证明辅助设计**：通过严格证明合法括号序列的对应关系，确保算法正确性。

---

**【同类型题或类似算法套路】**  
- **括号匹配类问题**：如最长有效括号、不同括号组合生成，常用动态规划或栈结构。  
- **滚动数组优化**：常见于背包问题、字符串编辑距离等需要降维的场景。  
- **状态压缩DP**：通过状态转移的对称性或单调性减少计算量。

---

**【推荐相似题目】**  
1. [P7914 括号匹配（CSP-S 2021）](https://www.luogu.com.cn/problem/P7914)  
   - **关键词**：括号匹配变种、动态规划。  
2. [LeetCode 22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)  
   - **关键词**：生成所有合法括号组合，回溯/动态规划。  
3. [P1944 最长括号匹配](https://www.luogu.com.cn/problem/P1944)  
   - **关键词**：栈结构、贪心策略。

---

**【个人心得摘录】**  
- **quest_2**：强调“评测机速度远大于理论值”，启示考场应敢于尝试看似超时的算法。  
- **船酱魔王**：指出“每对匹配左侧必须为左括号”，简化了充要条件判断，避免无效状态枚举。

---

**【可视化与算法演示】**  
**动画方案**：  
1. **网格绘制**：  
   - 横向为字符位置 `i`，纵向为未匹配左括号数 `j`，每个格子表示 `dp[i][j]`。  
   - 使用不同颜色标记转移来源（如红色箭头表示从 `j+1` 转移，蓝色箭头表示从 `j-1` 转移）。  
2. **滚动效果**：  
   - 当前处理行（`i & 1`）高亮显示，上一行（`(i-1) & 1`）渐隐，直观体现滚动数组的空间优化。  
3. **音效提示**：  
   - 每次转移时播放轻微“滴答”声，成功更新状态时触发上扬音调。  

**复古像素风格**：  
- **调色板**：使用 8 位风格的绿色（未匹配数 `j`）、黄色（当前字符）、红色（转移箭头）。  
- **Canvas 实现**：  
  ```javascript
  // 示例代码：绘制 dp 网格
  const canvas = document.getElementById("grid");
  const ctx = canvas.getContext("2d");
  // 绘制当前行和箭头
  function drawStep(i, j, fromJ) {
    ctx.fillStyle = "#00FF00"; // 绿色背景
    ctx.fillRect(i * 10, j * 10, 10, 10);
    // 绘制红色箭头（从 fromJ 到 j）
    ctx.beginPath();
    ctx.moveTo((i-1)*10 +5, fromJ*10 +5);
    ctx.lineTo(i*10 +5, j*10 +5);
    ctx.strokeStyle = "#FF0000";
    ctx.stroke();
  }
  ```

---

**【核心代码片段】**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1e9 + 9;
int dp[2][30005];

int main() {
    int n; cin >> n;
    dp[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        char c; cin >> c;
        int max_j = min(i, n - i);
        for (int j = 0; j <= max_j; j++) {
            if (j == 0 || c == ')') {
                dp[i & 1][j] = dp[(i-1) & 1][j + 1];
            } else {
                dp[i & 1][j] = (dp[(i-1) & 1][j + 1] + dp[(i-1) & 1][j - 1]) % MOD;
            }
        }
    }
    cout << dp[n & 1][0];
    return 0;
}
```

**代码说明**：  
- 使用滚动数组 `dp[2][30005]`，通过 `i & 1` 切换当前行。  
- 内层循环限制 `j ≤ min(i, n-i)`，优化计算量。  
- 根据当前字符类型选择转移方式，最终输出 `dp[n & 1][0]` 即为答案。

---
处理用时：87.26秒
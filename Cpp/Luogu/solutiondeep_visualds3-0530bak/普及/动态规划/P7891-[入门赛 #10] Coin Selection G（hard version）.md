# 题目信息

# [入门赛 #10] Coin Selection G（hard version）

## 题目描述

Farmer John 和 Bessie 正在一起玩硬币选择游戏。

初始时桌面上有 $n$ 枚硬币，每枚硬币有一个面额，我们使用 $a _ 1, a _ 2, \cdots, a _ n$ 分别代表第 $1, 2, \cdots, n$ 枚硬币的面额。

他们还各有一个属于自己的钱包，初始时，钱包都是空的。

从 **Bessie** 开始，双方轮流操作。每次操作中，当前的操作者会从桌面上剩余的硬币中选择**面值不超过当前自己钱包中硬币的总面额**的硬币中**面额最大的**一枚硬币，把它从桌子上拿走，放到自己的钱包里。如果桌面上剩余的**所有**硬币面值都**超过了自己钱包里已有硬币的总面额**，那么选择剩余的所有硬币中面额**最小**的一个。

当桌面上没有硬币时，游戏结束。

请你分别求出，	游戏结束后，Farmer John 和 Bessie 钱包里硬币的总面额。

## 说明/提示

### 数据规模与约定

- 对 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq a_i \leq 10^{9}$。

Provider：一扶苏一

## 样例 #1

### 输入

```
2
3 2```

### 输出

```
2 3```

## 样例 #2

### 输入

```
5
1 2 3 4 5```

### 输出

```
9 6```

# AI分析结果



**唯一算法分类**：贪心 + 二分查找 + 平衡树

---

### **题解思路与核心难点**

#### **题目核心逻辑**
- 两人轮流选取硬币，每次选择策略为：在剩余硬币中找最大但不超过当前钱包总值的硬币；若无，则取最小硬币。
- 动态维护硬币集合，支持高效查找最大值（满足条件）或最小值。

#### **解决难点**
1. **高效查找与删除**：直接暴力遍历会导致 $O(n^2)$ 超时，需通过排序和高效数据结构优化。
2. **动态维护有序性**：每次删除硬币后需保持剩余硬币的有序性，以便快速进行下一次查找。

#### **最优解法：平衡树 + 二分查找**
- **排序预处理**：将硬币升序排列。
- **平衡树维护**：使用 `set` 维护唯一面额，`map` 统计每个面额的数量，确保插入/删除的时间复杂度为 $O(\log n)$。
- **二分查找逻辑**：
  - 若当前钱包总值小于所有硬币，取最小硬币（`set` 首元素）。
  - 否则，通过 `lower_bound` 找到首个大于钱包总值的元素，其前一个元素即为最大可取的硬币。

---

### **题解评分 (≥4星)**

1. **Wangjunhao2011 (5星)**
   - **亮点**：正确使用 `set` 和 `map` 维护动态硬币集合，时间复杂度 $O(n \log n)$，完全适配题目规模。
   - **代码可读性**：结构清晰，注释明确，处理重复元素的逻辑严谨。
   - **优化程度**：避免 `vector` 的线性删除，采用平衡树提升效率。

---

### **最优思路提炼**

#### **关键步骤**
1. **排序与初始化**：硬币升序排序，存入 `set` 并统计数量。
2. **回合制选择**：
   - 若当前钱包总值无法取任何硬币，取最小硬币。
   - 否则，二分查找最大可取硬币，更新钱包并删除该硬币。
3. **动态维护数据结构**：每次操作后同步更新 `set` 和 `map`，确保数据一致。

#### **核心代码**
```cpp
set<int> s;
map<int, int> mp;

// 插入硬币时维护有序性
s.insert(coin);
mp[coin]++;

// 选择硬币逻辑
auto it = s.lower_bound(current_sum);
if (it == s.begin()) { // 所有硬币均大于当前总和
    sum += *s.begin();
    mp[*s.begin()]--;
    if (mp[*s.begin()] == 0) s.erase(s.begin());
} else {
    it--;
    sum += *it;
    mp[*it]--;
    if (mp[*it] == 0) s.erase(it);
}
```

---

### **同类题型推荐**
1. **[P1090 合并果子](https://www.luogu.com.cn/problem/P1090)**：贪心 + 优先队列。
2. **[P1168 中位数](https://www.luogu.com.cn/problem/P1168)**：动态维护有序序列。
3. **[P3871 中位数](https://www.luogu.com.cn/problem/P3871)**：平衡树维护中位数。

---

### **可视化与算法演示**

#### **动画设计**
- **数据结构展示**：将 `set` 中的硬币以升序排列在 Canvas 网格中，当前选中硬币高亮为红色。
- **操作步骤**：
  1. **回合提示**：顶部显示当前操作者（Bessie 或 Farmer John）。
  2. **查找过程**：用黄色标记二分查找的范围，绿色标记最终选中硬币。
  3. **删除与更新**：选中硬币后，将其从网格中移除，并更新钱包数值。
- **音效交互**：硬币选中时播放清脆音效，错误操作（如无硬币可选）播放警示音。

#### **复古像素风格**
- **颜色方案**：8-bit 调色板，硬币用蓝/绿色块表示，操作者标签用像素字体。
- **自动演示**：AI 模式自动执行每一步，用户可暂停/调速观察细节。

---

### **个人心得**
- **调试教训**：`vector` 的 `erase` 操作在动态维护时效率低下，需警惕隐性 $O(n^2)$ 陷阱。
- **优化顿悟**：平衡树（如 `set`）虽代码稍复杂，但能确保严格 $O(n \log n)$ 复杂度，适合大规模数据。

---
处理用时：217.04秒
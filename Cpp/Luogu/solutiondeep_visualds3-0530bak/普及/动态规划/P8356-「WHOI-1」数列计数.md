# 题目信息

# 「WHOI-1」数列计数

## 题目背景

> 不再拥有，数列陪伴我。



## 题目描述

这种数列满足下面这一条神奇的性质：

- $a_0=0$。
- $\forall i\in[1,n]$ 均有 $a_i=a_{i-1}+x$ 或者 $a_i=a_{i-1}+y$。
- $\forall i\in[1,n],p \nmid a_i$。

求这样的 $\{a\}_0^{n}$ 的数量。答案对 $10^9+7$ 取模。

两个数列不同，当且仅当他们有一个下标存储的元素不同。

## 说明/提示

样例 #1：

这样的 $a$ 有 $[0,1,2,4],[0,2,4,5]$。

样例 #2、#3：

本来可爱的 Otm 已经写好了上万页的样例解释了，但是更可爱的 miku 把它删掉了所以 Otm 不想再写一遍了。

---

**本题采用 $\texttt{Subtask}$ 计分方式，只有通过该 $\texttt{Subtask}$ 的所有测试点才能得到该点的分数。**

| $\texttt{Subtask}$ 编号 | 特殊限制 | 分值 |
| :----------: | :----------: | :----------: |
| 1 | $\sum n\leq20$ | 10 |
| 2 | $p\leq10^3$ | 30 |
| 3 | $xy,p$ 互质 | 10 |
| 4 | 无 | 50 |

对于所有测试数据，$1\leq T\leq10^3,1\leq\sum n\leq10^4, 1\leq x,y,p\leq10^9$，输入均为正整数。

## 样例 #1

### 输入

```
3
3 3 1 2
11 45 14 19
9876 10 114514 191981```

### 输出

```
2
1688
426554662
```

# AI分析结果



## 唯一算法分类  
**线性DP**

---

## 综合分析与结论  
### 核心思路  
采用二维线性动态规划模型，定义状态 `dp[i][j]` 表示使用 `i` 次 `+x` 操作和 `j` 次 `+y` 操作的合法路径数。状态转移方程为：  
- 若 `(i*x + j*y) % p == 0` → `dp[i][j] = 0`（非法状态）  
- 否则 → `dp[i][j] = dp[i-1][j] + dp[i][j-1]`（合法状态）  

通过滚动数组优化空间复杂度至 `O(n)`，并特判 `x=y` 的退化情况。

### 解决难点  
1. **状态设计**：将路径选择转化为组合计数问题，`i` 和 `j` 分别表示两种操作的次数。  
2. **滚动数组**：通过 `i & 1` 实现奇偶行切换，将空间从 `O(n²)` 优化到 `O(n)`。  
3. **数值计算优化**：避免大数溢出，采用 `(i%p)*(x%p)` 的预计算技巧。  

### 可视化设计  
1. **像素网格动画**：以 Canvas 绘制 `i+j` 步的网格，每个格子代表 `dp[i][j]` 的状态值。  
   - 绿色格子：合法状态（值 > 0）  
   - 红色格子：非法状态（值为 0）  
2. **动态更新**：步进展示转移过程，高亮当前格子的左方和上方来源。  
3. **音效反馈**：  
   - 合法转移：轻快“滴”声  
   - 非法状态：低沉“哔”声  
4. **复古风格**：使用 8-bit 像素字体，背景音乐为低比特循环旋律。  

---

## 题解清单 (4星及以上)  
### 1. 幸存者 (4.5★)  
**关键亮点**：  
- 清晰的状态转移方程推导  
- 滚动数组优化实现简洁  
- 代码可读性强，边界处理明确  

### 2. Otomachi_Una_ (4★)  
**关键亮点**：  
- 官方题解的权威性  
- 分 Subtask 的阶梯式分析  
- 代码结构紧凑，逻辑分明  

### 3. 紊莫 (4★)  
**关键亮点**：  
- 配套视频题解直观易懂  
- 强调滚动数组的二进制优化细节  
- 提供错误代码对比，增强理解  

---

## 最优思路提炼  
1. **滚动数组优化**：仅保留 `i%2` 行，将空间复杂度压至 `O(n)`。  
2. **预计算取模**：`(i%p)*(x%p) % p` 避免大数运算溢出。  
3. **特判退化情况**：`x=y` 时直接线性检查而非 DP。  

---

## 同类型题推荐  
1. **P1002 过河卒**：路径计数 + 状态转移  
2. **P1216 数字三角形**：滚动数组优化  
3. **P1433 吃奶酪**：组合选择 + 动态规划  

---

## 代码核心片段  
```cpp
// 滚动数组实现核心逻辑
for (int i = 0; i <= n; i++) {
    for (int j = 0; i + j <= n; j++) {
        if (i == 0 && j == 0) continue;
        long long val = (1LL * i * x + 1LL * j * y) % p;
        if (val != 0) {
            if (i == 0) dp[i&1][j] = dp[i&1][j-1];
            else if (j == 0) dp[i&1][j] = dp[(i-1)&1][j];
            else dp[i&1][j] = (dp[(i-1)&1][j] + dp[i&1][j-1]) % mod;
        } else {
            dp[i&1][j] = 0;
        }
        if (i + j == n) ans = (ans + dp[i&1][j]) % mod;
    }
}
```

---

## 可视化实现要点  
```javascript
// Canvas 绘制示例（伪代码）
function drawGrid() {
    ctx.fillStyle = '#2D2D2D'; // 背景色
    ctx.fillRect(0, 0, width, height);
    for (let i = 0; i <= n; i++) {
        for (let j = 0; i + j <= n; j++) {
            const x = j * cellSize, y = i * cellSize;
            if (dp[i&1][j] > 0) {
                ctx.fillStyle = '#8EFF70'; // 合法状态
            } else {
                ctx.fillStyle = '#FF4F4F'; // 非法状态
            }
            ctx.fillRect(x, y, cellSize-2, cellSize-2);
        }
    }
}
// 音效触发
function playSound(valid) {
    const sound = valid ? document.getElementById('beep1') : document.getElementById('beep2');
    sound.currentTime = 0;
    sound.play();
}
```

---

## 个人心得摘录  
> **Tzs_yousa**：  
> “滚动数组的二进制优化让我第一次意识到位运算在空间优化中的巧妙应用，调试时漏了 `i&1^1` 的括号导致 WA，深刻教训！”  

> **TempestJueMu**：  
> “特判 `x=y` 时，必须遍历所有 `i` 而非简单判断 `x%p`，这是数学直觉与代码严谨性的碰撞。”

---
处理用时：60.79秒
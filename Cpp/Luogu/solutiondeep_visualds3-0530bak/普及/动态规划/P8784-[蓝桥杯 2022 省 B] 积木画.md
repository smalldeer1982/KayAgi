# 题目信息

# [蓝桥杯 2022 省 B] 积木画

## 题目描述

小明最近迷上了积木画，有这么两种类型的积木，分别为 $I$ 型（大小为 $2$ 个单位面积) 和 $L$ 型 (大小为 $3$ 个单位面积):

![I 型积木](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_3d61ad9326a0012c9fdag-10.jpg)

同时，小明有一块面积大小为 $2 \times N$ 的画布，画布由 $2 \times N$ 个 $1 \times 1$ 区域构成。小明需要用以上两种积木将画布拼满，他想知道总共有多少种不同的方式? 积木可以任意旋转，且画布的方向固定。

## 说明/提示

**【样例说明】**

五种情况如下图所示, 颜色只是为了标识不同的积木:
![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_3d61ad9326a0012c9fdag-11.jpg)

**【评测用例规模与约定】**

对于所有测试用例，$1 \leq N \leq 10^7$。

蓝桥杯 2022 省赛 B 组 G 题。

## 样例 #1

### 输入

```
3```

### 输出

```
5```

# AI分析结果



---

## 算法分类  
**线性DP**

---

## 题解思路与算法分析  
### 核心思路  
题目本质是**状态压缩的线性DP**，通过分析积木填充规律，推导出递推式 `F(n) = 2*F(n-1) + F(n-3)`。关键点在于：  
1. **状态定义**：`F(n)` 表示填满 `2×n` 画布的方案数。  
2. **转移推导**：基于最后一步操作的可能情况（竖放I型、横放两个I型、L型组合），通过数学归纳化简得到递推式。  
3. **优化技巧**：利用滚动变量将空间复杂度优化至 `O(1)`，适应 `N ≤ 1e7` 的规模。  

### 解决难点  
- **L型积木的填补逻辑**：L型积木旋转后形成特定缺口，需结合后续I型或L型积木填补，推导时需考虑所有可能的填补路径。  
- **递推式化简**：通过消去求和项，将复杂的分支情况转化为简洁的线性递推关系。  

---

## 题解评分（≥4星）  
1. **Infinite_Eternity（★★★★★）**  
   - 思路清晰，数学推导严谨，代码简洁高效，空间优化到位。  
   - 关键亮点：通过数学归纳化简递推式，适合大规模数据。  
2. **what_can_I_do（★★★★）**  
   - 通过观察规律直接得出递推式，代码简洁，但缺少严格推导。  
3. **WaterSun（★★★★）**  
   - 滚动数组优化实现，代码空间效率高，思路与最优解一致。  

---

## 最优思路提炼  
1. **递推式核心**：`F(n) = 2*F(n-1) + F(n-3)`，通过最后一步放置I型或L型组合推导。  
2. **滚动变量优化**：仅保留前三个状态变量，空间复杂度 `O(1)`。  
3. **数学归纳**：将复杂的组合情况转化为线性递推，避免多重循环。  

---

## 同类型题与算法套路  
- **线性DP递推**：如爬楼梯问题（斐波那契）、瓷砖覆盖问题。  
- **状态压缩**：通过分析操作对状态的影响，合并冗余状态。  

---

## 相似题目推荐  
1. [P1192 台阶问题](https://www.luogu.com.cn/problem/P1192)  
2. [P1255 数楼梯](https://www.luogu.com.cn/problem/P1255)  
3. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)  

---

## 代码实现（核心逻辑）  
```cpp
#include <stdio.h>
const int mod = 1e9 + 7;
int main() {
    int n, a = 1, b = 1, c = 2, d = 5;
    scanf("%d", &n);
    if (n == 0) printf("1");
    else if (n == 1) printf("1");
    else if (n == 2) printf("2");
    else if (n == 3) printf("5");
    else {
        for (int i = 4; i <= n; ++i) {
            int next = (2LL * d + a) % mod; // 2*d + F(i-3)
            a = b; b = c; c = d; d = next;  // 滚动更新
        }
        printf("%d", d);
    }
    return 0;
}
```

---

## 可视化设计要点  
1. **8位像素风格**：  
   - 使用复古绿色网格表示 `2×N` 画布，积木用不同颜色方块表示（I型蓝色，L型红色）。  
   - DP状态更新时，当前列高亮黄色，前驱状态闪烁提示。  
2. **Canvas动画**：  
   - 动态绘制积木填充过程，展示每一步的放置选择及对应DP状态。  
3. **音效交互**：  
   - 放置积木时播放8位“点击”音效，状态更新时播放上升音调。  
4. **自动演示模式**：  
   - AI自动选择最优填充路径，按递推式逐步展示填充动画。  

---

## 个人心得摘录  
> “L型积木的填补逻辑容易遗漏反向旋转的情况，通过画图辅助分析后，发现其对称性可统一处理为乘2。” —— Infinite_Eternity  
> “观察前几项数值规律是快速验证递推式有效性的捷径。” —— what_can_I_do  

--- 

**可视化与交互示例**（伪代码逻辑）：  
```javascript
// 伪代码：Canvas绘制DP状态转移
function drawDPGrid(n) {
    const colors = ['#00F', '#F00', '#0F0']; // I型、L型、高亮
    for (let i = 0; i <= n; i++) {
        drawColumn(i, colors[getStateColor(i)]); // 根据状态着色
        if (i >= 3) drawArrow(i-3, i);           // 表示F(i-3)的贡献
    }
}
```

---
处理用时：72.67秒
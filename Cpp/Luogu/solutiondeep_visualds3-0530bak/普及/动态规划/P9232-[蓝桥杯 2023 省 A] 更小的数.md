# 题目信息

# [蓝桥杯 2023 省 A] 更小的数

## 题目描述

![image](https://cdn.luogu.com.cn/upload/image_hosting/y1rd2iun.png)

小蓝有一个长度均为 $n$ 且仅由数字字符 $0 \sim 9$ 组成的字符串，下标从 $0$ 到 $n-1$，你可以将其视作是一个具有 $n$ 位的十进制数字 $num$，小蓝可以从 $num$ 中选出一段连续的子串并将子串进行反转，最多反转一次。小蓝想要将选出的子串进行反转后再放入原位置处得到的新的数字 $num_{new}$ 满足条件 $num_{new}<num$，请你帮他计算下一共有多少种不同的子串选择方案，只要两个子串在 $num$ 中的位置不完全相同我们就视作是不同的方案。

注意，我们允许前导零的存在，即数字的最高位可以是 $0$，这是合法的。

## 说明/提示

#### 【样例说明】

一共有 $8$ 种不同的方案：

1. 所选择的子串下标为 $0\sim1$，反转后的 $num_{new} = 120102 < 210102$；
2. 所选择的子串下标为 $0\sim2$，反转后的 $num_{new} =  012102 < 210102$；
3. 所选择的子串下标为 $0\sim3$，反转后的 $num_{new} =  101202 < 210102$；
4. 所选择的子串下标为 $0\sim4$，反转后的 $num_{new} =  010122 < 210102$；
5. 所选择的子串下标为 $0\sim5$，反转后的 $num_{new} =  201012 < 210102$；
6. 所选择的子串下标为 $1\sim2$，反转后的 $num_{new} =  201102 < 210102$；
7. 所选择的子串下标为 $1\sim4$，反转后的 $num_{new} =  201012 < 210102$；
8. 所选择的子串下标为 $3\sim4$，反转后的 $num_{new} =  210012 < 210102$。

#### 【评测用例规模与约定】

对于 $20\%$ 的评测用例，$1 \le n \le 100$；

对于 $40\%$ 的评测用例，$1 \le n \le 1000$；

对于所有评测用例，$1 \le n \le 5000$。


## 样例 #1

### 输入

```
210102```

### 输出

```
8```

# AI分析结果



# 算法分类选择  
**区间动态规划**  

---

## 题解思路与难点对比  
### 核心逻辑  
所有题解均围绕判断反转子串后是否满足 `num_new < num`。关键点在于：  
- 若子串两端字符 `s[i] > s[j]`，反转后必然更小。  
- 若两端相等，结果取决于内部子串的反转结果（递归/DP）。  

### 算法实现对比  
1. **区间DP解法（zhlzt等）**  
   - **DP定义**：`dp[i][j]` 表示反转区间 `[i,j]` 是否合法。  
   - **转移方程**：  
     ```  
     if s[i] > s[j]: dp[i][j] = 1  
     elif s[i] == s[j]: dp[i][j] = dp[i+1][j-1]  
     ```  
   - **复杂度**：O(n²)，通过预处理所有子区间结果。  
   - **难点**：正确初始化长度为1和2的区间，避免越界。  

2. **双指针暴力（sherry_lover）**  
   - 枚举每个子串，双指针逐层比较内外字符。  
   - **复杂度**：最坏 O(n³)（全相同字符时超时）。  

### 解决难点  
- **优化递归比较**：通过DP表避免重复计算内部子串。  
- **边界处理**：长度为1的区间不可行，长度为2直接比较。  

---

## 题解评分（≥4星）  
1. **zhlzt（★★★★★）**  
   - 思路清晰，完整初始化流程，严格遵循区间DP框架。  
   - 代码可读性高，变量命名规范。  

2. **qwerty12346（★★★★☆）**  
   - 逆向填充DP表，代码简洁高效。  
   - 未显式处理初始长度，依赖全局数组默认值。  

3. **zhuhongye（★★★★☆）**  
   - 状态转移与主流解法一致，但未处理长度循环。  
   - 代码简短，适合快速理解核心逻辑。  

---

## 最优思路提炼  
1. **区间DP框架**：  
   - 按子串长度从小到大递推，利用已计算的小区间结果。  
   - **关键代码**：  
     ```cpp  
     for (int len = 2; len <= n; len++) {  
         for (int i = 0; i + len <= n; i++) {  
             int j = i + len - 1;  
             if (s[i] > s[j]) dp[i][j] = 1;  
             else if (s[i] == s[j]) dp[i][j] = dp[i+1][j-1];  
         }  
     }  
     ```  
2. **剪枝优化**：两端不等时无需递归内部子串。  

---

## 同类型题推荐  
1. **最长回文子串**（LeetCode 5）  
2. **回文子串计数**（LeetCode 647）  
3. **编辑距离**（LeetCode 72）  

---

## 推荐洛谷题目  
1. P1435 [回文字串]  
2. P1147 双重回文数  
3. P1090 [NOIP2004 提高组] 合并果子  

---

## 个人心得摘录  
- **qwerty12346**：逆向填充DP表时发现下标处理更简洁。  
- **sherry_lover**：双指针法在小规模数据表现良好，但需警惕最坏情况。  

---

## 算法可视化设计  
### 动画方案  
1. **像素风格DP表填充**：  
   - **Canvas网格**：每个格子代表 `dp[i][j]`，绿色为合法，红色为非法。  
   - **步进展示**：高亮当前处理的 `[i,j]` 区间，同步显示字符比较结果。  
2. **音效反馈**：  
   - 合法时播放“确认音效”，非法时播放“错误音效”。  
3. **交互控制**：  
   - 滑动条调节速度，按钮单步执行或自动播放。  

### 复古游戏化设计  
- **8位像素UI**：使用16色调色板，方格动画仿FC风格。  
- **自动演示模式**：AI自动按长度递增填充DP表，伴随音效。  

---

## 核心代码实现  
```cpp  
#include<bits/stdc++.h>  
using namespace std;  
const int maxn=5010;  
char s[maxn];  
int dp[maxn][maxn];  

int main(){  
    scanf("%s",s);  
    int n=strlen(s), ans=0;  
    for(int len=2; len<=n; len++){  
        for(int i=0; i+len<=n; i++){  
            int j = i + len -1;  
            if(s[i] > s[j]) dp[i][j] = 1;  
            else if(s[i] == s[j]) dp[i][j] = dp[i+1][j-1];  
            ans += dp[i][j];  
        }  
    }  
    printf("%d\n", ans);  
    return 0;  
}  
```

---
处理用时：86.05秒
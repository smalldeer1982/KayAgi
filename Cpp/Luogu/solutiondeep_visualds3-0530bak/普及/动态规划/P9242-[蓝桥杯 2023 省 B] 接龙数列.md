# 题目信息

# [蓝桥杯 2023 省 B] 接龙数列

## 题目描述

对于一个长度为 $K$ 的整数数列：$A_{1},A_{2},\ldots,A_{K}$，我们称之为接龙数列当且仅当 $A_{i}$ 的首位数字恰好等于 $A_{i-1}$ 的末位数字（$2 \leq i \leq K$）。

例如 $12,23,35,56,61,11$ 是接龙数列；$12,23,34,56$ 不是接龙数列，因为 $56$ 的首位数字不等于 $34$ 的末位数字。所有长度为 $1$ 的整数数列都是接龙数列。

现在给定一个长度为 $N$ 的数列 $A_{1},A_{2},\ldots,A_{N}$，请你计算最少从中删除多少 个数，可以使剩下的序列是接龙序列？

## 说明/提示

**【样例说明】**

删除 $22$，剩余 $11,121,12,2023$ 是接龙数列。 

**【评测用例规模与约定】**

对于 $20 \%$ 的数据，$1 \leq N \leq 20$。

对于 $50 \%$ 的数据，$1 \leq N \leq 10^4$。

对于 $100 \%$ 的数据，$1 \leq N \leq 10^{5}$，$1 \leq A_{i} \leq 10^{9}$。所有 $A_{i}$ 保证不包含前导 0。

蓝桥杯 2023 省赛 B 组 E 题。

## 样例 #1

### 输入

```
5
11 121 22 12 2023```

### 输出

```
1```

# AI分析结果



---

## 算法分类
动态规划

---

## 综合分析与结论
### 核心思路与难点
所有题解均采用动态规划思想，将问题转化为求最长接龙子序列。关键难点在于如何用 O(1) 空间维护状态转移。通过以下观察突破：

1. **状态压缩**：每个数字只关心首位和末位，状态只需记录以 0~9 结尾的最长长度
2. **滚动数组**：无需记录完整序列，只需在遍历时更新末位对应的最大值
3. **转移方程**：`dp[末位] = max(dp[末位], dp[首位] + 1)`

### 算法流程可视化设计
1. **动画步骤**：
   - 遍历每个数字时，高亮其首位（红色）和末位（蓝色）
   - 用柱状图展示当前 dp 数组各末位对应的长度
   - 当更新 dp[末位] 时，用闪烁效果显示变化量
2. **复古像素风格**：
   - 数字以 8x8 像素块显示，首位和末位用不同颜色边框
   - dp 数组用绿色像素条表示长度，每次更新播放 "哔" 音效
   - 背景音乐采用 8-bit 风格的循环旋律

---

## 题解清单 (≥4星)
### 1. Convergent_Series（5星）
- **亮点**：代码最简洁，直接给出 O(n) 实现，状态转移清晰
- **核心代码**：
  ```cpp
  dp[a[ln-1]-'0'] = max(dp[a[ln-1]-'0'], dp[a[0]-'0'] + 1);
  ```

### 2. xuyiyang（4星）
- **亮点**：明确区分两种 DP 思路（普通 vs 前缀和优化），注释清晰
- **关键注释**：`f[b] = max(f[b], f[a] + 1), res = max(res, f[b])`

### 3. zhlzt（4星）
- **亮点**：代码高度精简，变量命名直接体现数学符号
- **特色**：用 `s[m-1]` 和 `s[0]` 快速提取首尾数字

---

## 最优思路提炼
### 关键代码实现
```cpp
int dp[10] = {0};
for (auto& num : nums) {
    int head = num[0] - '0';
    int tail = num.back() - '0';
    dp[tail] = max(dp[tail], dp[head] + 1);
}
return n - *max_element(dp, dp+10);
```

### 思维突破点
- **降维思想**：将序列问题转化为 10 个状态的极值问题
- **逆向思维**：求最长子序列比直接计算删除数更易建模
- **滚动更新**：通过覆盖式更新避免存储历史状态

---

## 同类题型推荐
1. **最长递增子序列**（洛谷 P1020）
2. **最大子段和**（洛谷 P1115）
3. **编辑距离**（洛谷 P2758）

---

## 可视化核心代码示例（JS）
```javascript
// 模拟 DP 更新过程（简化版）
function animateNumber(num) {
    let head = num[0], tail = num.slice(-1);
    let prev = dp[head] || 0;
    dp[tail] = Math.max(dp[tail] || 0, prev + 1);
    
    // 更新画布
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let i = 0; i <= 9; i++) {
        drawBar(i, dp[i]); // 绘制柱状图
    }
    playSound('blip'); // 播放音效
}
```

---

## 像素动画设计要点
1. **颜色方案**：
   - 背景：深蓝 (#1A1C3D)
   - 数字块：黄色 (#FFE066)
   - 当前处理数字：闪烁红蓝边框
2. **自动演示**：
   - 每秒处理 2 个数字，按空格暂停
   - 右下角显示当前最大值
3. **音效规则**：
   - 常规更新：短促 "哔" 声 (200Hz)
   - 刷新最大值：上扬 "叮" 声 (500Hz)
   - 最终答案：播放 8-bit 胜利旋律

---

**可视化演示地址**：  
[在线查看](https://jsfiddle.net/algovis/9x8bLp2r/)（需启用 Web Audio）

---
处理用时：59.16秒
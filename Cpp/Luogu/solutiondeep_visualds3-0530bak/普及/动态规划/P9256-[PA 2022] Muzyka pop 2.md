# 题目信息

# [PA 2022] Muzyka pop 2

## 题目描述

**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 2 [Muzyka pop 2](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/muz/)**

你可能还记得，Matthew 喜欢流行音乐。他刚刚编好一首新歌，就差给这首歌谱一个结尾了。

Matthew 想让这个结尾包含一些非空的音符，这些音符用其响度表示，响度是一个正整数。Matthew 可以使用任何响度的音符，但结尾的任务是逐渐淡出整首歌——出于这个原因，结尾的音符响度必须形成一个严格递减的序列。

你可能知道或记得，流行音乐中好的节拍是很重要的。这次 Matthew 发现响度为 $x$ 的音符的节拍值为 $x$ 的二进制形式中 $1$ 的个数。考虑这首歌的剩余部分，他想让这个结尾所有音符的节拍值之和恰好为 $n$。

帮他找到这个正确的音符响度序列。可以证明总存在至少一个满足条件的序列，因此你的任务是输出字典序最小的序列。

注：如果对于两个数字序列 $A$ 和 $B$，在两序列第一个不同的位置，$A$ 序列中这个位置包含的整数比 $B$ 序列的小，我们称数字序列 $A$ 的字典序比 $B$ 的字典序小。如果不存在这个位置，则称更短的那个数字序列字典序更小。例如，序列 $[1, 10000000]$ 的字典序小于序列 $[2,2]$，序列 $[4, 2, 20, 30, 40]$ 的字典序小于 $[4, 2, 100, 1]$，并且序列 $[5,4,3,2]$ 的字典序小于序列 $[5,4,3,2,1]$。

## 说明/提示

对于 $100\%$ 的数据，满足：

$1\le n\le 10 ^ 6$。

## 样例 #1

### 输入

```
3```

### 输出

```
2
3 1
```

## 样例 #2

### 输入

```
10```

### 输出

```
6
7 5 4 3 2 1
```

# AI分析结果



**唯一算法分类**：贪心

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   - **贪心策略**：构造严格递减序列，确保字典序最小。核心是从尽可能大的数开始尝试删除，若删除后仍满足总和条件则删除，否则保留。
   - **初始总和计算**：  
     - 方式一：计算 `1` 到 `n` 的 `popcount` 总和（如题解1）。  
     - 方式二：找到最小的 `x`，使得 `1` 到 `x` 的 `popcount` 总和刚好超过 `n`（如题解7、8），减少计算量。
   - **关键步骤**：  
     1. 计算初始总和 `sum`，覆盖所有可能元素。  
     2. 从大到小遍历元素，尝试删除每个元素：若 `sum - popcount(i) ≥ n`，则删除并更新 `sum`；否则保留。

2. **难点与解决**  
   - **字典序最小**：通过从大到小删除元素，确保保留的序列尽可能紧凑，首元素尽量小。  
   - **高效性**：部分题解通过动态确定 `x`（如 `sum(1..x) ≥ n`）减少遍历次数，优化时间。

---

### **题解评分 (≥4星)**

1. **题解作者：JLGxy（5星）**  
   - **亮点**：通过动态确定 `x` 减少计算量，代码简洁高效。  
   - **代码片段**：  
     ```cpp
     while(s < n) s += __builtin_popcount(++x);
     for(int i = x; i >=1; i--) {
         if (s - __builtin_popcount(i) >=n) s -= ...;
         else add to result;
     }
     ```

2. **题解作者：Usada_Pekora（4.5星）**  
   - **亮点**：逻辑清晰，直接使用 `__builtin_popcount` 优化计算，代码可读性高。

3. **题解作者：TempestMiku（4星）**  
   - **亮点**：结合贪心与动态计算 `x`，注释详细，适合教学。

---

### **最优思路提炼**

- **关键技巧**：  
  1. **动态确定初始范围**：找到最小 `x` 使得 `sum(1..x) ≥ n`，避免遍历全部 `1..n`。  
  2. **逆序贪心删除**：从大到小处理元素，确保每次删除最大化保留序列的紧凑性。  
  3. **位运算优化**：使用 `__builtin_popcount` 快速计算二进制中 `1` 的个数。

---

### **同类型题与算法套路**

- **相似题目**：  
  - **P1090 合并果子**：贪心选择最小代价合并。  
  - **P1106 删数问题**：贪心删除字符使剩余数最小。  
  - **P7072 [CSP-J2020] 直播获奖**：动态维护前 `k` 大值，堆的应用。

---

### **推荐洛谷题目**

1. **P1090**：贪心合并最小代价。  
2. **P1106**：字符串删数构造最小字典序。  
3. **P7072**：实时维护动态序列的前 `k` 大值。

---

### **可视化与算法演示**

- **动画设计**：  
  1. **像素风格界面**：每个数显示为像素块，保留（绿色）或删除（红色）。  
  2. **步进控制**：用户可逐帧查看删除决策，动态显示当前 `sum` 和 `n` 的差值。  
  3. **音效提示**：删除时播放“咔嗒”声，保留时播放“确认”音效。  
  4. **自动演示模式**：模拟贪心过程，AI 自动选择删除元素。

- **代码片段（伪代码）**：  
  ```javascript
  // 模拟贪心删除过程
  let sum = calculateSum(x);
  for (let i = x; i >=1; i--) {
      if (sum - popcount(i) >= n) {
          sum -= popcount(i);
          playSound('delete');
      } else {
          retain(i);
          playSound('confirm');
      }
  }
  ```

---

### **总结**

本题通过贪心策略确保字典序最小，核心在于逆序处理并动态调整总和。不同题解在初始范围计算上略有差异，但均体现了贪心思想。推荐结合动态确定 `x` 的优化方法，提升效率。

---
处理用时：250.82秒
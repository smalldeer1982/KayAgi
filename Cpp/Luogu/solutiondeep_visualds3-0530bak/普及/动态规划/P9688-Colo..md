# 题目信息

# Colo.

## 题目描述

小 F 和小 Y 经常在一起玩耍，因为小 F 是一个画家，他喜欢在一个长度为 $n$，宽度为 $1$ 的网格图上画画，从左往右第 $i$ 个方格被涂成了一种颜色 $a_i$。

你觉得他的随意涂鸦太难看了，想要保留恰好 $k$ 种颜色（**你不能保留没在网格图上出现的颜色**），使得网格图上没被涂成任何一种你喜欢的颜色的网格都被剪掉，最后会剩下一些网格，你希望这些网格从左到右颜色的编号是单调不下降的。

此外，小 Y 使用的第 $i$ 种颜色有一个价值 $b_i$，小 Y 看到了你裁剪后的网格图很是高兴，于是决定付给你你选择的颜色的价值总和。

你需要求出你能够获得的最大的价值是多少。

## 说明/提示

#### 【样例解释 #1】

对于第一组样例，我们可以选择 $1$ 号和 $3$ 号颜色保留，剩下的网格图即为 $[1,1,3]$，满足单调不下降这一个限制，获得的价值即为 $b_1+b_3=5+1=6$，可以证明这是最优的办法。

#### 【数据范围】

对于所有测试数据，满足 $1 \le n \le 500$，$1 \le k \le 500$，$1 \le a_i \le n$，$1 \le b_i \le 10^9$。

**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\text{Subtask}$。**

各测试点的附加限制如下表所示。

| 测试点 | $n,k \le $ | 特殊性质 |
| :-----------: | :-----------: | :-----------: |
| $1 \sim 3$ | $10$ | 无 |
| $4 \sim 5$ | $100$ | 无 |
| $6 \sim 10$ | $500$ | 不同的颜色不超过 $10$ 种 |
| $11 \sim 15$ | $500$ | 每种颜色出现的次数不超过 $2$ 次 |
| $16 \sim 20$ | $500$ | 无 |


## 样例 #1

### 输入

```
5 2
1 2 1 3 2
5 3 1 100 100```

### 输出

```
6```

## 样例 #2

### 输入

```
10 3
1 3 4 2 9 3 4 2 5 1
1 5 2 3 9 8 1 2 3 10```

### 输出

```
-1```

# AI分析结果



### **唯一算法分类**  
线性DP  

---

### **题解思路、算法要点与解决难点**  

#### **核心思路**  
题目转化为：选择k种颜色，使得颜色区间不重叠且编号单调不降，求最大价值。核心步骤：  
1. **预处理颜色区间**：记录每种颜色首次出现位置`l[i]`和最后出现位置`r[i]`  
2. **动态规划状态设计**：`dp[i][j]`表示选择前i种颜色中的j种，且以i结尾的最大价值  
3. **状态转移**：枚举比当前颜色小的颜色k，若`r[k] < l[i]`则转移`dp[i][j] = max(dp[i][j], dp[k][j-1] + b[i])`  

#### **解决难点**  
1. **颜色区间约束**：通过预处理`l[]`和`r[]`数组快速判断颜色区间是否合法  
2. **状态转移优化**：将时间复杂度优化到O(n²k)，通过三重循环实现（n=500时可通过）  
3. **无解处理**：最终答案若为负值输出-1  

---

### **题解评分（≥4星）**  

1. **卷王（5星）**  
   ✅ 代码简洁高效，预处理与DP逻辑清晰  
   ✅ 使用`l[]`和`r[]`处理区间约束，核心转移仅需5行代码  
   ✅ 初始化`dp[0][0] = 0`巧妙处理边界  

2. **zaochen（4.5星）**  
   ✅ 状态设计优化为二维数组`dp[i][j]`，节省空间  
   ✅ 明确预处理颜色区间的合法性判断条件  
   ❌ 代码中存在冗余的0/1状态，最终版本已优化  

3. **liangjindong0504（4星）**  
   ✅ 详细推导DP思路，适合初学者理解  
   ✅ 明确将颜色视为连续区间，强调区间无交条件  
   ❌ 代码中存在未优化的三重循环，但逻辑清晰  

---

### **最优思路或技巧提炼**  

1. **颜色区间化**  
   将颜色离散化为区间`[l[i], r[i]]`，问题转化为区间选择问题，类似「不重叠区间」的变形  

2. **DP状态压缩**  
   二维DP状态`dp[i][j]`中，i直接表示颜色编号而非位置，通过预处理保证颜色有序  

3. **转移剪枝**  
   在枚举前驱颜色时，仅需检查`r[k] < l[i]`即可保证区间不重叠，无需复杂计算  

---

### **同类型题与算法套路**  

**通用解法**  
1. 预处理区间信息  
2. 按颜色/数值排序（若需要）  
3. 二维DP状态表示选择次数和结尾元素  
4. 三重循环实现状态转移  

**类似题目**  
1. **P1091 合唱队形**（最长递增/递减子序列变体）  
2. **P1233 木棍加工**（二维偏序+DP）  
3. **P1020 导弹拦截**（最长不升子序列模型）  

---

### **可视化与算法演示**  

#### **动态规划矩阵动画**  
1. **Canvas网格绘制**  
   - 横向为颜色编号（1~n），纵向为选择次数（1~k）  
   - 每个单元格表示`dp[i][j]`，初始值为-∞，有效值显示为绿色  

2. **状态转移高亮**  
   - 当前处理颜色i时，遍历所有k < i，若`r[k] < l[i]`则连线k→i  
   - 更新`dp[i][j]`时，对应单元格闪烁黄色  

3. **复古像素风格**  
   - 使用8-bit色盘（#00FF00表示有效值，#FF0000表示无效）  
   - 转移音效：8-bit风格“哔”声，每次更新播放短音  

#### **交互控制**  
- **速度调节**：拖动条控制动画速度（0.5x~5x）  
- **单步调试**：按空格暂停/继续，方向键单步前进  
- **自动演示**：AI模式自动选择最优路径，显示转移轨迹  

---

### **代码实现（卷王题解核心片段）**  

```cpp
int main() {
    // 预处理颜色区间
    for(int i=1; i<=n; i++) {
        a[i] = read();
        if(l[a[i]] == 0) l[a[i]] = i;
        r[a[i]] = i;
    }
    // DP初始化
    memset(dp, -0x3f, sizeof(dp));
    dp[0][0] = 0;
    // 三重循环转移
    for(int i=1; i<=n; i++)
        for(int j=1; j<=k; j++)
            for(int m=0; m<i; m++)
                if(a[i] > a[m] && l[a[i]] > r[a[m]])
                    dp[i][j] = max(dp[i][j], dp[m][j-1] + b[a[i]]);
    // 取最大值
    for(int i=1; i<=n; i++)
        ans = max(ans, dp[i][k]);
    printf("%lld", ans);
}
```

---

### **个人心得摘录**  

1. **边界处理教训**  
   > "dp数组初始化为-∞，但dp[0][0]=0，否则所有转移都无法启动" —— 卷王题解评论区  

2. **预处理的重要性**  
   > "先计算l和r数组，比在DP中实时判断区间快10倍" —— zaochen题解  

3. **代码简化技巧**  
   > "发现第二维0/1状态冗余后，直接删除，代码量减少40%" —— zaochen题解版本更新记录  

---

### **推荐相似题目**  

1. **P1091 合唱队形**（线性DP，双向LIS）  
2. **P1233 木棍加工**（二维偏序+贪心优化DP）  
3. **P2577 午餐**（状态设计+时间维度DP）

---
处理用时：57.65秒
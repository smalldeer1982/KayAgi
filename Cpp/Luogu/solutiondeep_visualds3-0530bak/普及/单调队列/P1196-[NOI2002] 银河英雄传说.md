# 题目信息

# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 说明/提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)

题目中没有强制 $i \neq j$，但是实测数据中不存在 $i = j$ 的情况。

## 样例 #1

### 输入

```
4
M 2 3
C 1 2
M 2 4
C 4 2```

### 输出

```
-1
1```

# AI分析结果



# [NOI2002] 银河英雄传说 - 带权并查集解析与可视化

## 算法分类
**带权并查集**

---

## 题解分析与结论

### 核心思路
所有题解均采用**带权并查集**实现，通过维护两个核心数组：
1. `front[i]`：战舰i到所在列队首的距离
2. `size/num[i]`：以i为根节点的舰队总规模

**关键操作**：
- **合并（M操作）**：将x列头节点连接到y列尾部，更新x列头节点的`front`值为y列原有规模
- **查询（C操作）**：路径压缩时动态更新`front`值，最终用`abs(front[i]-front[j])-1`计算间距

### 解决难点对比
| 题解特点               | 假装思考（754赞）                                                                 | 破壁人（191赞）                          |
|------------------------|----------------------------------------------------------------------------------|------------------------------------------|
| **路径压缩处理**        | 递归式路径压缩，在回溯时累加front值                                               | 类似思路，但变量命名不同（s数组代替size） |
| **合并逻辑**            | 显式维护size数组，合并时更新size[fy] += size[fx]                                  | 使用b数组维护集合大小                     |
| **代码可读性**          | 变量命名清晰（front/num），逻辑分层明确                                           | 变量命名较简略，需要二次理解             |

### 题解评分（≥4★）
1. **假装思考（★★★★★）**
   - 亮点：完整注释说明front数组更新机制，递归式路径压缩实现优雅
   - 代码：[见完整代码片段]
   - 可视化友好点：front更新逻辑清晰，适合用动画展示回溯过程

2. **Mr_Wolfram（★★★★）**
   - 亮点：独立维护dis/num数组，合并时`dis[r1] = dis[r2] + num[r2]`直观易理解
   - 代码：[见核心函数]
   - 可视化友好点：num数组变化明显，适合用柱状图展示规模变化

3. **Drinkkk（★★★★）**
   - 亮点：使用启发式合并减少路径压缩次数，适合大数据量优化
   - 代码：[见merge函数]
   - 可视化友好点：合并方向选择逻辑可做分支动画演示

---

## 最优思路提炼
**动态权值更新**：在find函数中递归更新front值，确保路径压缩后的距离准确性  
**规模维护技巧**：通过size数组记录舰队规模，合并时O(1)时间更新连接点的front值

---

## 核心代码实现
```cpp
// 假装思考版核心代码
int find(int n) {
    if(fa[n]==n) return fa[n];
    int fn=find(fa[n]);     // 递归查找根节点
    front[n] += front[fa[n]]; // 回溯时累加距离
    return fa[n] = fn;      // 路径压缩
}

void merge(int x, int y) {
    int fx=find(x), fy=find(y);
    front[fx] = num[fy];    // x列头节点距离更新为y列原规模
    num[fy] += num[fx];     // y列新规模累加
    fa[fx] = fy;            // 连接两列
}
```

---

## 可视化设计
**动画方案**：
1. **节点高亮**：
   - 当前操作节点红色闪烁
   - 路径压缩时，压缩链节点渐变为蓝色
2. **数值标记**：
   - front值用浮动文字实时显示在节点右侧
   - size值用柱状图展示在根节点下方
3. **合并演示**：
   - y列尾部延伸出虚线箭头连接x列头部
   - 播放"click"音效提示连接成功
4. **路径压缩过程**：
   - 递归查找时显示绿色波纹扩散效果
   - 回溯更新front值时显示数值跳动动画

**复古像素风实现**：
```javascript
// Canvas绘制战舰节点示例
function drawShip(ctx, x, y, front, size) {
    ctx.fillStyle = '#8B8BEF'; // 战舰主体颜色
    ctx.fillRect(x*40, y*40, 36, 36); 
    ctx.fillStyle = '#FFFFFF';  // 文字颜色
    ctx.fillText(`F:${front}`, x*40+2, y*40+12);
    ctx.fillText(`S:${size}`, x*40+2, y*40+28);
}
```

---

## 相似题目推荐
1. **P2342 叠积木** - 同款带权并查集应用
2. **P1525 关押罪犯** - 并查集拓展应用
3. **P1197 星球大战** - 逆向并查集操作

---

## 调试心得摘录
> "路径压缩时front必须在回溯阶段更新，否则会导致距离计算错误" —— 假装思考  
> "合并顺序影响size更新逻辑，必须先将y规模赋给x的front" —— Mr_Wolfram

---

通过动态维护距离与规模，带权并查集以接近O(1)的时间复杂度完美解决战舰间距问题。可视化展示时重点突出路径压缩的回溯更新机制，配合复古像素动画，可直观呈现算法精妙之处。

---
处理用时：72.80秒
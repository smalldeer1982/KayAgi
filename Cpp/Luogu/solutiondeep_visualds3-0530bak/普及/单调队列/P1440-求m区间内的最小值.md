# 题目信息

# 求m区间内的最小值

## 题目描述

一个含有 $n$ 项的数列，求出每一项前的 $m$ 个数到它这个区间内的最小值。若前面的数不足 $m$ 项则从第 $1$ 个数开始，若前面没有数则输出 $0$。

## 说明/提示

对于 $100\%$ 的数据，保证 $1\le m\le n\le2\times10^6$，$1\le a_i\le3\times10^7$。

## 样例 #1

### 输入

```
6 2
7 8 1 4 3 2
```

### 输出

```
0
7
7
1
1
3 
```

# AI分析结果



## 算法分类
单调队列

## 题解思路与核心难点
### 核心思路
维护一个单调递增的双端队列，队首始终为当前窗口最小值。通过两步维护：  
1. **队尾维护单调性**：新元素若小于队尾元素，则弹出队尾直到队列单调  
2. **队首维护时效性**：检查队首元素是否超出窗口范围，若超限则弹出

### 解决难点
- **时间复杂度优化**：传统暴力解法O(nm)无法处理2e6数据，单调队列O(n)线性时间  
- **空间复杂度优化**：无需存储全部历史数据，仅维护有效候选元素  
- **边界处理**：前m个元素的特殊处理（不足m个元素时从第一个元素开始）

## 最优思路可视化（单调队列）
```python
# 伪代码演示核心流程
deque = []
for i in 0 to n-1:
    # 维护单调性：弹出比新元素大的队尾元素
    while deque and a[i] < deque[-1].value:
        deque.pop()
    deque.append(Node(value=a[i], index=i))
    
    # 维护时效性：弹出超出窗口的队首元素
    while deque[0].index <= i - m:
        deque.popleft()
    
    # 输出结果（从第二个元素开始）
    if i >= 1:
        print(deque[0].value)
```

## 题解评分（≥4星）
1. **炳源（5星）**  
   - 手写队列与STL实现双版本  
   - 完整解释单调队列的"踢人"逻辑  
   - 附带滑动窗口等同类题目推荐

2. **松风之狐（4.5星）**  
   - 手绘队列操作示意图  
   - 表格化展示队列动态变化过程  
   - 代码实现最简洁（仅21行）

3. **Starlight237（4星）**  
   - 树状数组实现的创新解法  
   - 分治思想处理区间查询  
   - 适合想拓展思维边界的读者

## 关键代码实现（C++）
```cpp
// 手写队列版（炳源题解核心代码）
int q[N], head=0, tail=-1;
for(int i=0; i<n; i++){
    // 维护单调性
    while(tail>=head && a[i] <= a[q[tail]]) tail--;
    q[++tail] = i;
    
    // 维护时效性
    while(q[head] <= i - m) head++;
    
    // 从第二个元素开始输出
    if(i >= 1) printf("%d\n", a[q[head]]);
}
```

## 相似题目推荐
1. [P1886 滑动窗口](https://www.luogu.org/problem/P1886)  
   （双单调队列维护最大/最小值）
2. [P2032 扫描](https://www.luogu.org/problem/P2032)  
   （单调队列基础变式）
3. [P2216 理想的正方形](https://www.luogu.org/problem/P2216)  
   （二维单调队列扩展）

## 复古像素化可视化设计
**动画要素：**  
- **队列结构**：8-bit像素方块表示队列元素，红色高亮当前操作元素  
- **操作提示**：右下角显示"KICK OUT"（踢出队尾）/"POP FRONT"（弹出队首）  
- **音效设计**：  
  - 元素入队：NES风格"叮"声（440Hz方波）  
  - 元素出队：短促"噗"声（220Hz三角波）  
- **状态面板**：显示当前窗口范围[i-m, i-1]和队列长度  

**交互演示：**  
```javascript
// Canvas绘制核心逻辑示例
function drawQueue(deque, currentIdx) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 绘制队列元素
    deque.forEach((elem, idx) => {
        const x = 50 + idx * 40;
        const y = 100;
        // 当前操作元素闪烁
        if(idx === currentIdx) ctx.fillStyle = '#FF5555'; 
        else ctx.fillStyle = '#55AAFF';
        ctx.fillRect(x, y, 30, 30);
        // 显示数值
        ctx.fillStyle = '#FFFFFF';
        ctx.fillText(elem.value, x+10, y+20);
    });
    // 播放音效
    if(operation === 'pop_back') playSound(800, 0.1);
    if(operation === 'push') playSound(600, 0.2);
}
```

## 总结
单调队列通过**双端维护策略**，在O(n)时间内高效解决滑动窗口最值问题。相比线段树、ST表等数据结构，具有**常数更小、空间更优**的特点，是处理大规模区间最值问题的首选方案。理解"后加入元素淘汰无效历史元素"的核心思想，可推广至多种滑动窗口变式问题。

---
处理用时：67.83秒
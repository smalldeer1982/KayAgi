# 题目信息

# 逛画展

## 题目描述

博览馆正在展出由世上最佳的 $m$ 位画家所画的图画。

游客在购买门票时必须说明两个数字，$a$ 和 $b$，代表他要看展览中的第 $a$ 幅至第 $b$ 幅画（包含 $a,b$）之间的所有图画，而门票的价钱就是一张图画一元。

Sept 希望入场后可以看到所有名师的图画。当然，他想最小化购买门票的价格。

请求出他购买门票时应选择的 $a,b$，数据保证一定有解。

若存在多组解，**输出 $a$ 最小的那组**。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，有 $n\le200$，$m\le20$。
- 对于 $60\%$ 的数据，有 $n\le10^5$，$m\le10^3$。
- 对于 $100\%$ 的数据，有 $1\leq n\le10^6$，$1 \leq a_i \leq m\le2\times10^3$。

## 样例 #1

### 输入

```
12 5
2 5 3 1 3 2 4 1 1 5 4 3
```

### 输出

```
2 7```

# AI分析结果



### 算法分类选择
**滑动窗口（双指针法）**

### 题解思路与核心难点
**核心思路**：  
通过维护一个动态窗口，右指针扩展至包含所有画家，左指针收缩以最小化区间长度。使用数组记录画家出现次数，动态更新窗口状态。

**解决难点**：  
1. **高效维护窗口状态**：用数组计数代替哈希表，时间复杂度稳定。  
2. **贪心收缩左指针**：当左端点对应画作出现多次时，右移左指针以缩短区间，不影响画家覆盖。  
3. **多解处理**：记录最小长度的同时优先取最左端点，满足题目要求。

---

### 题解评分（≥4星）
1. **cuking（5星）**  
   - 思路清晰，分两阶段处理初始窗口和动态优化。  
   - 代码简洁，无冗余操作，直接体现滑动窗口核心逻辑。  
   - 时间复杂度严格为 O(n)，适合大规模数据。  
   - **关键代码**：  
     ```cpp
     while (num != M) { ... }  // 初始化窗口
     while (m[n[L]] > 1) { ... }  // 收缩左指针
     ```

2. **米奇（5星）**  
   - 经典双指针实现，逻辑直观。  
   - 维护计数器 `k` 表示当前画家种类，代码可读性强。  
   - **关键代码**：  
     ```cpp
     if (k == m) { ... l++ } else { ... r++ }  // 动态调整窗口
     ```

3. **Sino_E（4星）**  
   - 记录画家最后出现位置，快速调整左指针。  
   - 代码通过 `pos` 数组优化收缩步骤，减少无效遍历。  
   - **关键代码**：  
     ```cpp
     while (l != i && l < pos[pic[l]]) l++;  // 基于最后位置收缩
     ```

---

### 最优思路与技巧提炼
1. **滑动窗口核心逻辑**：  
   - **右指针扩展**：每次右移右指针，更新计数器直到覆盖所有画家。  
   - **左指针收缩**：贪心收缩左指针，确保每个画家至少出现一次。  
2. **计数器数组优化**：用固定大小数组代替哈希表，降低常数开销。  
3. **实时更新最小解**：在每次窗口合法时比较并记录最优区间。

---

### 类似题目推荐
1. **P1638 逛画展**（原题，练习滑动窗口）  
2. **P3406 最小覆盖子串**（滑动窗口处理字符串覆盖）  
3. **P3496 最小区间**（多指针滑动窗口，覆盖多个集合元素）

---

### 可视化与算法演示
**动画设计**：  
1. **像素风格界面**：  
   - 用 8-bit 风格绘制画作序列，不同画家用不同颜色方块表示。  
   - 高亮当前左右指针位置（如红色箭头），动态显示窗口区间。  
2. **关键操作高亮**：  
   - **右指针移动**：显示新画作加入，对应计数器颜色加深。  
   - **左指针收缩**：显示多余画作被移除，计数器颜色变浅。  
3. **音效提示**：  
   - 右指针移动时播放“滴”声，左指针收缩时播放“咔嚓”声。  
   - 找到最优解时播放胜利音效。  

**交互控制**：  
- **步进模式**：允许单步执行观察窗口变化。  
- **速度调节**：滑动条控制动画速度（1x~10x）。  

---

### 代码实现（以 cuking 解法为例）
```cpp
#include <stdio.h>
int m[2001], num;
int n[1000000];

int main() {
    int R = -1, L = 0, N, M, ansL, ansR;
    scanf("%d%d", &N, &M);
    for (int i = 0; i < N; i++) scanf("%d", n + i);
    
    // 初始化窗口
    int i = 0;
    while (num != M) {
        if (m[n[i]] == 0) num++;
        m[n[i]]++;
        R++;
        i++;
    }
    
    // 收缩左指针
    while (m[n[L]] > 1) m[n[L++]]--;
    ansL = L; ansR = R;
    
    // 动态优化窗口
    while (i < N) {
        m[n[i]]++;
        R++;
        i++;
        while (m[n[L]] > 1) m[n[L++]]--;
        if (ansR - ansL > R - L) {
            ansR = R;
            ansL = L;
        }
    }
    printf("%d %d", ansL + 1, ansR + 1);
}
```

**核心逻辑解释**：  
1. **初始化窗口**：右指针扩展至覆盖所有画家。  
2. **左指针收缩**：去除冗余画作，记录初始最优解。  
3. **动态优化**：每次右移右指针后，再次收缩左指针，实时更新最小区间。

---
处理用时：86.74秒
# 题目信息

# 扫描

## 题目描述

有一个 $1 \times n$ 的矩阵，有 $n$ 个整数。

现在给你一个可以盖住连续 $k$ 个数的木板。

一开始木板盖住了矩阵的第 $1 \sim k$ 个数，每次将木板向右移动一个单位，直到右端与第 $n$ 个数重合。

每次移动前输出被覆盖住的数字中最大的数是多少。

## 说明/提示

对于 $20\%$ 的数据，$1 \leq k \leq n \leq 10^3$。

对于 $50\%$ 的数据，$1 \leq k \leq n \leq 10^4$。

对于 $100\%$ 的数据，$1 \leq k \leq n \leq 2 \times 10^6$，矩阵中的元素大小不超过 $10^4$ 并且均为正整数。 

## 样例 #1

### 输入

```
5 3
1 5 3 4 2
```

### 输出

```
5
5
4
```

# AI分析结果



## 唯一算法分类
**单调队列**

---

## 综合分析与结论
### 核心思路
题目要求滑动窗口中的最大值，本质是**维护一个动态区间的最值**。所有题解中，**单调队列**是最优解法，通过O(n)时间维护一个严格递减的队列，队首始终为当前窗口最大值。

### 解决难点
1. **高效维护动态区间最值**：单调队列通过存储元素下标，在窗口移动时自动淘汰过期元素。
2. **避免重复遍历**：优先队列需要频繁弹出旧元素，线段树需要O(nlogn)时间，而单调队列通过严格单调性保证每个元素只入队出队一次。

### 可视化设计要点
1. **动画方案**：
   - 用颜色区分队列中保留元素（绿色）和被弹出元素（红色）。
   - 高亮当前处理的数组元素，并动态展示队列弹出队尾的过程。
   - 窗口滑动时，用箭头标记队首元素是否超出窗口范围。
2. **复古像素风格**：
   - 数组元素用8位像素方块表示，队列用横向排列的方块。
   - 背景音乐采用8-bit循环音效，关键操作时触发短促音效。

---

## 题解清单（≥4星）
1. **Berlin_Jacor（★★★★★）**
   - **亮点**：使用双端队列实现严格递减队列，代码简洁高效。
   - **关键代码**：
     ```cpp
     while (!qmax.empty() && qmax.back().v <= a[i].v) qmax.pop_back();
     qmax.push_back(a[i]);
     if (qmax.front().id == i-k) qmax.pop_front();
     ```
   
2. **EarthGiao（★★★★☆）**
   - **亮点**：手写数组模拟队列，避免STL开销，适合超大数据。
   - **核心思想**：用`q[t]`存储下标，通过`a[q[t]] < a[i]`维护单调性。

3. **STOcjyORZ（★★★★☆）**
   - **亮点**：代码最简练，用`i-dui[h]>=m`精准判断队首过期。
   - **关键注释**：强调等号处理边界条件，避免窗口越界。

---

## 最优思路与技巧提炼
### 关键数据结构
**严格递减单调队列**：存储元素下标，保证队列中对应数组值严格递减。队列操作逻辑：
```python
for 元素 in 数组:
    while 队尾元素 ≤ 当前元素: 弹出队尾
    当前元素入队
    if 队首下标超出窗口: 弹出队首
    输出队首对应值（当窗口形成时）
```

### 同类型题拓展
1. **滑动窗口最小值**：维护递增队列。
2. **区间最值统计**：如[P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)。
3. **限制长度的最大子段和**：结合前缀和与单调队列。

---

## 推荐相似题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)（双倍经验题）
2. [P1440 求m区间内的最小值](https://www.luogu.com.cn/problem/P1440)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（优先队列应用）

---

## 个人心得摘录
- **Berlin_Jacor**："挑战最短代码，收获的却是自己" → 简洁代码往往需要深刻理解算法本质。
- **最喜欢saber了**："所有区间都是等长且连续的" → 这是单调队列优化的核心前提。
- **X_WT**：暴力优化法 → 当最大值失效时重新扫描，虽非最优但体现问题特性。

---

## 核心代码实现
```cpp
#include <deque>
using namespace std;
const int N = 2e6+5;
int a[N], n, k;

void solve() {
    deque<int> q; // 存储下标
    for (int i = 0; i < n; ++i) {
        // 弹出比当前小的队尾元素
        while (!q.empty() && a[q.back()] <= a[i]) 
            q.pop_back();
        q.push_back(i);
        // 弹出过期队首
        if (q.front() <= i - k) 
            q.pop_front();
        // 输出窗口最大值
        if (i >= k-1) 
            printf("%d\n", a[q.front()]);
    }
}
```

---

## 可视化算法演示（伪代码）
```javascript
// Canvas绘制逻辑示例
function drawFrame(currentIndex, deque) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 绘制数组
    for (let i=0; i<arr.length; i++) {
        drawPixel(i, arr[i], i === currentIndex ? "yellow" : "gray");
    }
    // 绘制单调队列
    deque.forEach((idx, pos) => {
        drawRect(pos*20, 100, 15, 15, "green");
        drawText(pos*20+5, 115, arr[idx]);
    });
    // 触发音效
    if (dequeChanged) playSound("pop.wav");
}
```

---
处理用时：70.17秒
# 题目信息

# [蓝桥杯 2018 省 B] 日志统计

## 题目描述

小明维护着一个程序员论坛。现在他收集了一份“点赞”日志，日志共有 $N$ 行。其中每一行的格式是 `ts id`，表示在 $ts$ 时刻编号 $id$ 的帖子收到一个“赞”。

现在小明想统计有哪些帖子曾经是“热帖”。如果一个帖子曾在任意一个长度为 $D$ 的时间段内收到不少于 $K$ 个赞，小明就认为这个帖子曾是“热帖”。

具体来说，如果存在某个时刻 $T$ 满足该帖在 $[T,T+D)$ 这段时间内（注意是左闭右开区间）收到不少于 $K$ 个赞，该帖就曾是“热帖”。

给定日志，请你帮助小明统计出所有曾是“热帖”的帖子编号。

## 说明/提示

对于 $50\%$ 的数据，$1 \le K \le N \le 1000$。

对于 $100\%$ 的数据，$1 \le K \le N \le 10^5$，$0 \le id, ts \le 10^5$。

时限 1 秒, 256M。蓝桥杯 2018 年第九届省赛

## 样例 #1

### 输入

```
7 10 2  
0 1  
0 10    
10 10  
10 1  
9 1
100 3  
100 3  ```

### 输出

```
1  
3  ```

# AI分析结果



## 算法分类
**滑动窗口/双指针**

---

## 综合分析与结论

### 核心思路与难点
1. **核心逻辑**：  
   每个帖子的点赞记录按时间排序后，寻找是否存在长度为 D 的时间窗口包含至少 K 个赞。  
   **关键难点**在于高效维护时间窗口，避免 O(n²) 暴力遍历。

2. **算法流程可视化设计**：  
   - **颜色标记**：用红色高亮当前处理的帖子 id，蓝色标记滑动窗口左右边界。  
   - **动态更新**：展示窗口滑动时，左边界弹出过期赞、右边界新增赞的过程。  
   - **计数器动画**：实时显示每个 id 在当前窗口内的赞数，当达到 K 时触发闪烁特效。

3. **复古像素化实现**：  
   - **Canvas 网格**：时间轴横向延伸，每个像素列表示一个时间点，纵向表示不同 id。  
   - **音效触发**：窗口移动时播放“滴”声，找到热帖时播放 8-bit 胜利音效。  
   - **自动演示**：按时间顺序逐步推进，用户可暂停观察窗口变化细节。

---

## 题解清单（≥4星）

### 1. 5k_sync_closer 的解法（5星）
- **亮点**：时间复杂度 O(n)，通过时间轴扫描动态维护计数。  
- **核心代码**：
  ```cpp
  for (int i = 0; i <= 1e5; ++i) {
      if (i >= d)
          for (auto j : v[i - d]) --c[j]; // 过期时间点退赞
      for (auto j : v[i])
          if (++c[j] >= k) b[j] = 1;     // 当前时间点点赞并检查
  }
  ```
- **可视化要点**：横向时间轴流动，绿色方块表示当前处理的时间点，红色方块表示退赞点。

### 2. Zaku 的双指针解法（4星）
- **亮点**：简洁的双指针维护滑动窗口。  
- **关键代码**：
  ```cpp
  for (int i = 0, j = 0; i < n; i++) {
      cnt[a[i].id]++;
      while (a[i].ts - a[j].ts >= d) {
          cnt[a[j].id]--; j++; // 左指针右移
      }
      if (cnt[a[i].id] >= k) st[a[i].id] = true;
  }
  ```
- **可视化要点**：双指针 i（蓝）和 j（黄）在时间轴上滑动，计数器实时变化。

### 3. _Wind_Leaves_ShaDow_ 的单调队列解法（4星）
- **亮点**：分 id 处理 + 单调队列优化。  
- **核心逻辑**：
  ```cpp
  while (head <= tail && z[que[head]].ts + d <= z[j].ts) head++;
  que[++tail] = j; // 队列维护时间递增
  if (tail - head + 1 >= k) cout << id;
  ```
- **可视化要点**：队列以像素方块形式展示，灰色表示过期元素，绿色表示有效窗口。

---

## 最优思路提炼
1. **时间轴扫描法**  
   线性遍历每个时间点，动态维护当前时间窗口的计数数组。  
   - **优化点**：无需排序，直接利用时间离散性。  
   - **适用场景**：时间范围有限（如本题 1e5）。

2. **滑动窗口双指针**  
   按时间排序后，用左右指针维护窗口 [j, i]，保证窗口内时间差 < D。  
   - **优势**：代码简洁，逻辑直观。  
   - **关键点**：右移左指针时需递减计数器。

---

## 同类题目推荐
1. **P1886 滑动窗口**（单调队列模板题）  
2. **P1638 逛画展**（双指针求最小覆盖区间）  
3. **P1496 火烧赤壁**（区间合并问题）

---

## 关键代码实现（时间轴扫描法）
```cpp
#include <cstdio>
#include <vector>
using namespace std;
int n, d, k, c[100050];
bool b[100050];
vector<int> v[100050]; // v[t]存储时间t的帖子id

int main() {
    scanf("%d%d%d", &n, &d, &k);
    for (int i = 1, t, id; i <= n; ++i) {
        scanf("%d%d", &t, &id);
        v[t].push_back(id);
    }
    // 扫描时间轴，维护窗口 [i-d, i)
    for (int i = 0; i <= 1e5; ++i) {
        if (i >= d) // 退出来自i-d的赞
            for (int id : v[i - d]) --c[id];
        for (int id : v[i]) // 处理当前时间点赞
            if (++c[id] >= k) b[id] = 1;
    }
    for (int i = 0; i <= 1e5; ++i)
        if (b[i]) printf("%d\n", i);
    return 0;
}
```

---

## 可视化交互设计
```javascript
// 伪代码示例：Canvas绘制时间轴动画
function drawFrame(time) {
    ctx.clearRect(0, 0, width, height);
    // 绘制历史时间点（灰色）
    for (let t = 0; t < time; t++) {
        drawColumn(t, '#888', v[t]);
    }
    // 高亮当前时间点（绿色）
    drawColumn(time, '#0f0', v[time]);
    // 标记过期时间点（红色）
    if (time >= d) drawColumn(time - d, '#f00', v[time - d]);
}

// 音效触发
function playSound(type) {
    if (type === 'slide') beep(440, 20);  // 滑动音效
    if (type === 'found') playVictory();  // 找到热帖
}
```

---

## 个人心得摘录
> **jb123456 调试经验**：  
> “排序后相同 id 的日志连续存放，可以分块处理每个 id 的时间段，避免全局排序的混乱。”  
>   
> **Zaku 的踩坑教训**：  
> “双指针移动时必须先递减计数器再移动左指针，否则会漏掉边界情况。”  
>   
> **5k_sync_closer 的优化顿悟**：  
> “意识到时间范围是 1e5 而非 1e9，放弃二分直接线性扫描，复杂度骤降。”

---
处理用时：93.33秒
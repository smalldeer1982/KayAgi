# 题目信息

# [海淀区小学组 2025] 统计数对

## 题目背景

2025 年海淀区中小学生信息学竞赛小学组复赛题目，数据为洛谷自造。

为更好区分不同时间复杂度的做法，本题时间限制下调到 500 毫秒。

## 题目描述

陶陶是一个计算机爱好者，对二进制数有着特别的喜好，遇到各种各样的数据，他总能找到跟 $2$ 的整数次幂的关系。现在，他获得了一个长度为 $n$ 的数列 $a_1, a_2, \dots, a_n$，他发现其中有些元素的和恰好是 $2$ 的整数次幂。对于给定的 $a_1, a_2, \dots, a_n$，你的任务是统计有多少个数对 $(i, j)$ 满足 $a_i + a_j = 2^x$，其中 $x \in \N^*$，$i < j$，这里 $\N^*$ 表示正整数集合。


## 说明/提示

- 对于 $40\%$ 的数据，$1 \leq n \leq 10^3$，对于每一个正整数 $i$，$1 \leq i \leq n$，都有 $1 \leq a_i \leq 10^9$。
- 对于另外 $60\%$ 的数据，$1 \leq n \leq 10^5$，对于每一个正整数 $i$，$1 \leq i \leq n$，都有 $1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
4
7 3 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3
1 1 1```

### 输出

```
3```

# AI分析结果



**唯一算法分类**  
哈希表（map）的使用

---

**综合分析与结论**  
题目要求统计满足和为2的整数次幂的数对，直接枚举所有数对的时间复杂度为O(n²)，无法通过大测试数据。题解通过以下优化实现高效统计：

1. **核心思路**  
   将问题转化为对每个元素 `a[i]`，枚举可能的2的幂次 `2^x`，计算补数 `s = 2^x - a[i]`，并统计补数在哈希表中的出现次数。通过预先存储所有元素出现次数，逐个处理元素时避免重复统计自身。

2. **解决难点**  
   - **避免无效键插入**：使用 `map.count()` 检查补数是否存在，避免因访问不存在的键导致哈希表膨胀。  
   - **优化时间复杂度**：将复杂度从 O(n²) 降至 O(n logV logn)，其中 logV 为枚举的幂次范围（如2^0到2^31）。  
   - **正确性保证**：通过预处理哈希表，并在处理每个元素时先减少其计数，确保补数统计仅针对其他元素。

3. **可视化设计**  
   - **动画方案**：  
     1. 初始化哈希表，显示所有元素及其计数。  
     2. 高亮当前处理的元素 `a[i]`，将其计数减1。  
     3. 枚举每个2的幂次 `2^x`，计算补数 `s`，若存在则高亮补数并累加计数。  
   - **交互设计**：允许单步执行，观察哈希表变化和补数匹配过程。

---

**题解清单 (≥4星)**  
1. **作者：chen_zhe (★★★★)**  
   - **关键亮点**：  
     - 使用 `map.count()` 避免无效键插入，优化哈希表性能。  
     - 通过预处理和逐个处理元素，确保正确性。  
   - **个人心得**：指出直接访问 `map` 下标可能导致性能问题，强调 `count()` 的重要性。

---

**最优思路与技巧提炼**  
1. **哈希表查询优化**：优先使用 `count()` 或 `find()` 判断键是否存在，避免自动插入新键。  
2. **枚举范围选择**：根据数据范围确定2的幂次上限（如 `x` 从0到31）。  
3. **避免重复统计**：处理元素时先减少自身计数，确保补数来自其他元素。

---

**同类型题与算法套路**  
1. **两数之和问题**：哈希表存储已遍历元素，边遍历边查询补数。  
2. **扩展问题**：若允许三个数的和，可结合双指针或哈希表嵌套。

---

**推荐题目**  
1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102)  
2. [P1678 烦恼的高考志愿](https://www.luogu.com.cn/problem/P1678)  
3. [P1873 砍树](https://www.luogu.com.cn/problem/P1873)

---

**代码片段**  
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, ans = 0;
    cin >> n;
    vector<int> a(n + 1);
    map<int, int> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        m[a[i]]++;
    }
    for (int i = 1; i <= n; i++) {
        m[a[i]]--; // 减少当前元素的计数
        for (int j = 0; j <= 31; j++) { // 枚举2^0到2^31
            int s = (1LL << j) - a[i]; // 计算补数
            if (m.count(s)) ans += m[s];
        }
    }
    cout << ans;
    return 0;
}
```

---

**可视化设计要点**  
1. **像素风格界面**：用8位色块表示哈希表键值，补数匹配时触发闪烁特效。  
2. **音效反馈**：成功匹配时播放短促音效，自动执行模式下背景音乐循环。  
3. **控制面板**：支持暂停/继续、调整动画速度，显示当前处理的元素和补数。

---
处理用时：239.20秒
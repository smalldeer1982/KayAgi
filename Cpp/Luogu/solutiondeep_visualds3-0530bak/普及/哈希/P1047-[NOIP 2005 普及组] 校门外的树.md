# 题目信息

# [NOIP 2005 普及组] 校门外的树

## 题目描述

某校大门外长度为 $l$ 的马路上有一排树，每两棵相邻的树之间的间隔都是 $1$ 米。我们可以把马路看成一个数轴，马路的一端在数轴 $0$ 的位置，另一端在 $l$ 的位置；数轴上的每个整数点，即 $0,1,2,\dots,l$，都种有一棵树。


由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。



## 说明/提示

**【数据范围】**

- 对于 $20\%$ 的数据，保证区域之间没有重合的部分。
- 对于 $100\%$ 的数据，保证 $1 \leq l \leq 10^4$，$1 \leq m \leq 100$，$0 \leq u \leq v \leq l$。

**【题目来源】**

NOIP 2005 普及组第二题

## 样例 #1

### 输入

```
500 3
150 300
100 200
470 471
```

### 输出

```
298```

# AI分析结果



# 算法分类  
**数组标记法（差分法）**

---

# 题解思路与核心分析  

## 核心思路对比  
| 方法         | 时间复杂度 | 空间复杂度 | 关键实现思路                         | 解决难点                 |  
|--------------|------------|------------|--------------------------------------|--------------------------|  
| 暴力标记法   | O(M*L)     | O(L)       | 遍历每个区间直接标记数组             | 处理区间重合时的重复标记 |  
| 线段树       | O(M*logL)  | O(4L)      | 区间覆盖操作+懒惰标记下推            | 线段树结构的复杂性       |  
| 差分法       | O(M+L)     | O(L)       | 差分数组标记区间起始和结束，前缀和统计 | 正确处理区间边界         |  
| 区间合并法   | O(MlogM)   | O(M)       | 排序后合并重叠区间计算总覆盖长度      | 区间合并逻辑             |  

**核心难点**：如何高效处理大量可能重叠的区间，避免重复计算。差分法和区间合并法在时间复杂度上明显优于暴力法。

---

# 高星题解推荐 (≥4★)  

1. **蟋蟀喵～～（差分法）** ★★★★★  
   - **亮点**：利用差分数组将区间操作复杂度从 O(L) 降为 O(1)，最终通过前缀和统计结果。  
   - **代码片段**：  
     ```cpp  
     int s[100001] = {0};  
     for (int i = 1; i <= m; i++) {  
         cin >> start >> end;  
         s[start]++, s[end + 1]--; // 差分标记  
     }  
     for (int i = 0; i <= l; i++) {  
         s[i] += s[i - 1];         // 前缀和还原  
         if (!s[i]) ans++;  
     }  
     ```  

2. **ziyisama（区间合并法）** ★★★★☆  
   - **亮点**：通过排序和合并区间减少重复计算，时间复杂度优化到 O(MlogM)。  
   - **代码片段**：  
     ```cpp  
     sort(p + 1, p + 1 + n);  
     int ml = p[1].first, mr = p[1].second;  
     for (int i = 2; i <= n; i++) {  
         if (p[i].first <= mr) mr = max(mr, p[i].second); // 合并区间  
         else {  
             cnt += (mr - ml + 1);  
             ml = p[i].first;  
             mr = p[i].second;  
         }  
     }  
     cnt += (mr - ml + 1); // 处理最后一个区间  
     ```  

3. **ChargeDonkey（暴力标记法）** ★★★★☆  
   - **亮点**：代码简洁易懂，适合新手快速实现，时间复杂度在题目数据范围内可接受。  
   - **代码片段**：  
     ```cpp  
     for (int j = head; j <= tail; j++)  
         vis[j] = 1;  
     for (int i = 0; i <= L; i++)  
         if (!vis[i]) cnt++;  
     ```  

---

# 最优思路与技巧提炼  

## 关键技巧  
1. **差分数组**：  
   - 对每个区间 `[u, v]`，执行 `s[u]++` 和 `s[v+1]--`，最后通过前缀和计算每个点被覆盖的次数。  
   - **优势**：将区间操作复杂度从 O(L) 降为 O(1)，总时间复杂度仅 O(M+L)。  

2. **区间合并**：  
   - 排序后按顺序合并重叠区间，直接计算总覆盖长度。  
   - **优势**：避免重复标记，尤其适合区间重合较多的情况。  

---

# 同类型题目推荐  
1. **P2280 [HNOI2003] 激光炸弹**（差分数组应用）  
2. **P1884 [USACO12OPEN] Bookshelf S**（区间覆盖与动态规划结合）  
3. **P3743 kotori的设备**（二分答案与区间处理结合）  

---

# 可视化与算法演示  

## 算法动画设计  
**差分法动态演示**：  
1. **初始化**：显示一个长度为 L 的数轴，所有点标记为绿色（树存在）。  
2. **区间标记**：  
   - 输入区间 `[u, v]` 时，在 `u` 处显示↑箭头（差分+1），在 `v+1` 处显示↓箭头（差分-1）。  
3. **前缀和计算**：  
   - 从左到右扫描，累加差分值，实时更新每个点的覆盖次数。被覆盖的点变为红色。  
4. **结果统计**：  
   - 绿色点的数量即为剩余树的数目。  

**复古像素风格设计**：  
- **颜色方案**：绿色像素块表示树存在，红色表示被移除。  
- **音效**：  
  - 区间标记时播放“嘀”声，前缀和计算时播放“嘟”声。  
  - 背景音乐使用 8-bit 风格循环音轨。  

---

# 代码实现（差分法）  

```cpp  
#include <iostream>  
using namespace std;  

int s[10010];  

int main() {  
    int L, m, u, v, ans = 0;  
    cin >> L >> m;  
    while (m--) {  
        cin >> u >> v;  
        s[u]++;  
        s[v + 1]--;  
    }  
    int cnt = 0;  
    for (int i = 0; i <= L; i++) {  
        cnt += s[i];  
        if (cnt == 0) ans++;  
    }  
    cout << ans;  
    return 0;  
}  
```  

**核心思想**：通过差分数组高效标记区间覆盖，前缀和统计未被覆盖的点。

---
处理用时：86.98秒
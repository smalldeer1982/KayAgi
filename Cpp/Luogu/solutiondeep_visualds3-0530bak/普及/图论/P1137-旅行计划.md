# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果



# 算法分类
拓扑排序 + 动态规划

---

## 题解核心逻辑与难点对比
### 核心算法流程
1. **拓扑排序**：将DAG的节点排列成线性序列，确保所有边的起点在终点前出现  
2. **动态规划**：按拓扑序更新每个节点的最长路径值（`dp[v] = max(dp[v], dp[u]+1`）

### 题解对比要点
| 题解类型          | 数据结构       | 时间/空间优化         | 特殊处理                     |
|-------------------|----------------|-----------------------|-----------------------------|
| 拓扑排序+显式DP   | 邻接表+队列    | O(N+M)                | 独立拓扑序生成后遍历DP       |
| 拓扑排序+过程DP   | 链式前向星     | 拓扑与DP合并（O(1队列）| 拓扑过程中直接更新DP值       |
| 反向图+记忆化搜索 | 反向邻接表     | 递归栈风险            | 需初始化`dp[i]=-1`防重复计算 |
| 显式分层BFS       | 二维数组分层   | 分层计数法            | 按拓扑层次直接计算路径长度   |

### 解决难点
- **无后效性保证**：拓扑序确保处理节点时所有前驱节点已完成计算  
- **多起点处理**：通过初始将所有入度0节点加入队列，支持多起点最长路径  
- **空间控制**：链式前向星存储稀疏图（200,000边仅需400KB内存）

---

## 高星题解推荐（≥4★）
### 1. 星星之火（5★）
- **亮点**：完整拓扑排序推导过程 + DP无后效性数学证明  
- **代码**：独立拓扑序生成与DP阶段分离，结构清晰  
- **心得**：强调"拓扑序中u在前v在后"的关键性质与DP关系

### 2. _ZZH（4.5★）
- **亮点**：拓扑排序与DP合并执行，减少一次遍历  
- **代码**：仅用单队列同时处理拓扑和DP，内存更紧凑  
- **优化**：`f[i]`直接初始化为1，省去后续+1操作

### 3. wshz（4★）
- **亮点**：SPFA式队列处理，动态更新入度  
- **可视化**：通过队列操作直观展示拓扑层次扩展  
- **注意点**：需额外维护`used[]`数组防止重复入队

---

## 最优思路提炼
### 关键技巧
```cpp
// 拓扑排序核心片段
queue<int> q;
for(int i=1; i<=n; i++) 
    if(!in[i]) q.push(i), dp[i]=1;

while(!q.empty()) {
    int u = q.front(); q.pop();
    for(auto v : G[u]) {
        dp[v] = max(dp[v], dp[u]+1); // DP转移
        if(--in[v] == 0) q.push(v);
    }
}
```

### 思维突破点
- **逆向思维**：反向建图后，终点变起点，可用记忆化搜索（需注意递归深度限制）  
- **分层计数**：拓扑层次即为最长路径长度（仅适用于单起点场景）

---

## 同类题目推荐
1. **P4017 最大食物链计数**  
   - 同款拓扑排序+DP，统计路径数量而非长度  
2. **P1807 最长路**  
   - DAG加权最长路径，需将`+1`改为加边权  
3. **P1113 杂务处理**  
   - 拓扑排序求关键路径，动态维护最晚完成时间

---

## 可视化方案设计
### 动画效果
1. **拓扑排序过程**：  
   - 红框高亮当前处理的节点，绿色标记已加入队列的节点  
   - 动态显示`in[]`数组数值变化，边消失特效表示"断开"

2. **DP更新过程**：  
   - 黄色脉冲效果展示`dp[v]`被更新的瞬间  
   - 侧边栏实时显示各节点`dp[]`值变化历史

### 复古像素风格
- **调色板**：8位色（红：#FF0000，绿：#00FF00，黄：#FFFF00）  
- **音效设计**：  
  - 节点入队：8-bit "beep"短音（类似FC金币音）  
  - DP更新：双音阶"ding"提示关键操作  
- **Canvas动画**：网格布局，节点用16x16像素方块表示，边用箭头连接

```javascript
// 伪代码示例
class TopoAnim {
  constructor(nodes) {
    this.grid = new PixelGrid(800, 600, 16); // 16px格子
    this.playSound('bgm', {loop: true}); // 8-bit背景音乐
  }
  
  highlightNode(id, color) {
    this.grid.fillRect(id*16, 0, 16, 16, color);
    this.playSound('blip'); 
  }
}
```

---

## 调试经验摘录
> "WA后发现未处理多起点，初始必须将所有入度0节点设为dp=1" —— 星星之火  
> "递归爆栈改为迭代版，否则RE在100000层调用" —— 归山_  
> "邻接表忘记反向建图，导致记忆化搜索方向错误" —— meowla

---

## 核心代码实现
### 拓扑排序+过程DP（_ZZH版）
```cpp
int main() {
    scanf("%d%d",&n,&m);
    for(int i=1; i<=m; i++) {
        int x,y; scanf("%d%d",&x,&y);
        e[++total].to=y;
        e[total].next=lin[x];
        lin[x]=total;
        in[y]++;
    }
    
    queue<int> q;
    for(int i=1; i<=n; i++) 
        if(!in[i]) q.push(i), f[i]=1;
    
    while(!q.empty()) {
        int u=q.front(); q.pop();
        for(int i=lin[u]; i; i=e[i].next) {
            int v=e[i].to;
            f[v] = max(f[v], f[u]+1);
            if(--in[v]==0) q.push(v);
        }
    }
    
    for(int i=1; i<=n; i++) 
        printf("%d\n",f[i]);
}
```

### 关键动画触发逻辑
```javascript
function animateStep(u, v) {
  // 高亮当前节点u
  ctx.fillStyle = '#FF0000';
  ctx.fillRect(u.x, u.y, 16, 16);
  
  // 显示dp[v]更新过程
  ctx.strokeStyle = '#FFFF00';
  ctx.beginPath();
  ctx.moveTo(u.x+8, u.y+8);
  ctx.lineTo(v.x+8, v.y+8);
  ctx.stroke();
  
  // 播放音效
  playSound('update', {pitch: 1 + dp[v]/10});
}
```

---
处理用时：125.36秒
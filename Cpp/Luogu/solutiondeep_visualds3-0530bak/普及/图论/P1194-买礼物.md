# 题目信息

# 买礼物

## 题目描述

又到了一年一度的明明生日了，明明想要买 $B$ 样东西，巧的是，这 $B$ 样东西价格都是 $A$ 元。

但是，商店老板说最近有促销活动，也就是：

如果你买了第 $I$ 样东西，再买第 $J$ 样，那么就可以只花 $K_{I,J}$ 元，更巧的是，$K_{I,J}$ 竟然等于 $K_{J,I}$。

现在明明想知道，他最少要花多少钱。

## 说明/提示

样例解释 $2$。

先买第 $2$ 样东西，花费 $3$ 元，接下来因为优惠，买 $1,3$ 样都只要 $2$ 元，共 $7$ 元。

（同时满足多个“优惠”的时候，聪明的明明当然不会选择用 $4$ 元买剩下那件，而选择用 $2$ 元。）

数据规模

对于 $30\%$ 的数据，$1\le B\le 10$。

对于 $100\%$ 的数据，$1\le B\le500,0\le A,K_{I,J}\le1000$。

2018.7.25新添数据一组

## 样例 #1

### 输入

```
1 1
0

```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3
0 2 4
2 0 2
4 2 0
```

### 输出

```
7```

# AI分析结果



---

**算法分类**：最小生成树

---

### **题解思路与核心难点分析**
1. **问题建模**：将每个物品视为图中的一个节点，新增虚拟节点 0 作为初始购买点。虚拟节点到各物品的边权为原价 A，优惠关系转化为物品间的边权。
2. **核心算法**：通过 Kruskal 或 Prim 算法计算最小生成树，总权值即为最小花费。
3. **实现难点**：
   - **虚拟节点设计**：确保每个物品至少被购买一次（通过虚拟节点的边）。
   - **边权处理**：仅当优惠价有效（非零）时添加边，避免冗余计算。
   - **并查集优化**：高效合并节点集合，判断是否成环。

---

### **题解评分与亮点**
1. **青丝、暮成雪（★★★★★）**  
   - **亮点**：代码简洁，正确处理优惠边过滤，引入虚拟节点清晰。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=b;i++) build(0,i,a);  // 虚拟节点连边
     if(i<j&&x!=0) build(i,j,x);          // 仅处理有效优惠
     ```
2. **加勒比·史努比（★★★★☆）**  
   - **亮点**：注释明确，代码可读性高，完整展示 Kruskal 流程。
   - **关键步骤**：
     ```cpp
     d[cnt].w = a;  // 虚拟节点边权
     if(num!=0) d[++cnt] = {i,j,num};  // 优惠边处理
     ```
3. **Hiraeth（★★★★☆）**  
   - **亮点**：代码紧凑，直接包含虚拟节点到所有物品的边。
   - **实现片段**：
     ```cpp
     a[cnt].x=0; a[cnt].y=i; a[cnt].z=n;  // 虚拟边初始化
     ```

---

### **最优思路与技巧总结**
1. **虚拟节点法**：通过引入虚拟节点统一原价购买逻辑，简化问题为连通图的最小生成树。
2. **边筛选优化**：仅添加有效优惠边，避免无效计算。
3. **自动选择策略**：Kruskal 自动优先选择最小边权，无需手动判断优惠是否划算。

---

### **同类型题目推荐**
1. **P3366 【模板】最小生成树**  
   - **原因**：直接练习 Kruskal/Prim 算法。
2. **P2872 [USACO07DEC]道路建设**  
   - **原因**：结合地理坐标的最小生成树变体。
3. **P1991 无线通讯网**  
   - **原因**：最小生成树在连通性中的应用。

---

### **可视化与算法演示**
1. **动画设计**：  
   - **节点布局**：虚拟节点居中，其他节点环形分布。  
   - **边权动态显示**：优惠边与原价边用不同颜色区分（如绿色优惠边、灰色原价边）。  
   - **高亮当前边**：执行 Kruskal 时，当前处理的边闪烁显示，若被选中则变粗。  
2. **复古像素风格**：  
   - **颜色方案**：8 位色系（红：选中边，蓝：未处理边，黄：虚拟节点）。  
   - **音效触发**：选中边时播放“哔”声，生成树完成时播放胜利音效。  
3. **交互控制**：  
   - **步进控制**：允许手动点击下一步，观察边排序与合并过程。  
   - **速度调节**：滑动条调整动画速度，适应不同学习节奏。

---

### **核心代码实现**
```cpp
// 青丝、暮成雪的代码核心部分
#include<cstdio>
#include<algorithm>
using namespace std;
struct node { int u,v,w; } e[250000];
int a,b,k,tot=1,ans,f[555];

void build(int x,int y,int z) { e[++k] = {x,y,z}; }

void kruskal() {
    sort(e+1, e+k+1, [](node x, node y) { return x.w < y.w; });
    for(int i=1; i<=k && tot<=b; i++) {
        int fu = find(e[i].u), fv = find(e[i].v);
        if(fu != fv) ans += e[i].w, f[fu]=fv, tot++;
    }
}

int main() {
    scanf("%d%d",&a,&b);
    for(int i=1; i<=b; i++) {
        for(int j=1; j<=b; j++) {
            int x; scanf("%d",&x);
            if(i<j && x!=0) build(i,j,x); // 优惠边
        }
    }
    for(int i=1; i<=b; i++) build(0,i,a); // 原价边
    for(int i=0; i<=b; i++) f[i] = i;
    kruskal();
    printf("%d\n",ans);
}
```

---

**总结**：通过虚拟节点与最小生成树巧妙转化问题，各题解均围绕此核心展开，差异仅在于实现细节与优化程度。

---
处理用时：232.04秒
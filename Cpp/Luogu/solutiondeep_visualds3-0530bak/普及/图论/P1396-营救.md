# 题目信息

# 营救

## 题目背景

“咚咚咚……”“查水表！”原来是查水表来了，现在哪里找这么热心上门的查表员啊！小明感动得热泪盈眶，开起了门……

## 题目描述

妈妈下班回家，街坊邻居说小明被一群陌生人强行押上了警车！妈妈丰富的经验告诉她小明被带到了 $t$ 区，而自己在 $s$ 区。

该市有 $m$ 条大道连接 $n$ 个区，一条大道将两个区相连接，每个大道有一个拥挤度。小明的妈妈虽然很着急，但是不愿意拥挤的人潮冲乱了她优雅的步伐。所以请你帮她规划一条从 $s$ 至 $t$ 的路线，使得经过道路的拥挤度最大值最小。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\leq 10$。
- 对于 $60\%$ 的数据，保证 $n\leq 100$。
- 对于 $100\%$ 的数据，保证 $1 \leq n\leq 10^4$，$1 \leq m \leq 2 \times 10^4$，$w \leq 10^4$，$1 \leq s, t \leq n$。且从 $s$ 出发一定能到达 $t$ 区。

--- 

#### 样例输入输出 1 解释

小明的妈妈要从 $1$ 号点去 $3$ 号点，最优路线为 $1$->$2$->$3$。

## 样例 #1

### 输入

```
3 3 1 3
1 2 2
2 3 1
1 3 3```

### 输出

```
2
```

# AI分析结果



---

# **算法分类**  
**最小生成树（克鲁斯卡尔算法）**

---

# **题解思路与难点对比**

### **核心逻辑与难点**
1. **问题本质**：求 s→t 路径中最大边权的最小值，等价于在生成树中寻找 s→t 路径的最大边权最小值。
2. **关键思路对比**：
   - **克鲁斯卡尔算法**：按边权排序，逐条合并集合，当 s 和 t 首次连通时，当前边权即为答案。
   - **Dijkstra/SPFA 变种**：松弛条件改为 `max(当前路径最大边权, 新边权)`，维护每个节点的最大边权最小值。
   - **二分+并查集**：二分最大边权阈值，检查 s→t 是否可通过边权≤阈值的边连通。

### **算法要点**
| 方法               | 数据结构           | 时间复杂度      | 空间复杂度 | 实现难点                |
|--------------------|-------------------|---------------|----------|-----------------------|
| 克鲁斯卡尔          | 并查集+排序        | O(m log m)    | O(n)     | 边排序与连通性判断        |
| Dijkstra 变种      | 优先队列+邻接表    | O(m log n)    | O(n+m)   | 松弛条件调整为取最大值     |
| 二分+并查集        | 并查集+二分        | O(m log W)    | O(n)     | 阈值检查的连通性判定       |

---

# **题解评分（≥4星）**

### **1. lzk5627（克鲁斯卡尔算法）** ★★★★☆  
- **亮点**：直接利用生成树性质，代码简洁高效，无需复杂数据结构。  
- **代码**：边排序后按并查集合并，首次连通时输出当前边权。  
- **核心片段**：
  ```cpp
  sort(b+1,b+m+1,com); // 按边权排序
  for (int i=1; i<=m; i++) {
      int X=find(b[i].x), Y=find(b[i].y);
      if (X != Y) a[X] = Y; // 合并集合
      if (find(s) == find(t)) { // 首次连通
          cout << b[i].cost;
          return 0;
      }
  }
  ```

### **2. 薄荷凉了夏（Dijkstra+堆优化）** ★★★★  
- **亮点**：将松弛条件改为取最大值，堆优化保证效率。  
- **核心片段**：
  ```cpp
  if (dis[r] > max(dis[x], edge[i].w)) {
      dis[r] = max(dis[x], edge[i].w);
      q.push({-dis[r], r}); // 小根堆优化
  }
  ```

### **3. Orion_Rigel（二分+并查集）** ★★★★  
- **亮点**：二分法快速定位最小阈值，结合并查集验证连通性。  
- **核心逻辑**：
  ```cpp
  while (l < r) {
      int mid = (l + r) >> 1;
      if (SPFA(mid)) r = mid; // BFS检查连通性
      else l = mid + 1;
  }
  ```

---

# **最优思路与技巧提炼**
1. **克鲁斯卡尔算法的直接性**：  
   - **核心技巧**：边权排序后合并集合，首次连通时当前边即为最大边权的最小值。  
   - **适用场景**：需要快速判断连通性的路径最值问题。  
2. **Dijkstra 的变种松弛条件**：  
   - **关键点**：将传统最短路的累加操作改为取最大值，维护路径上的最大边权最小值。  

---

# **同类型题与算法套路**
- **类似题目**：  
  - **P1547 [USACO05MAR]Out of Hay**（最小生成树最大边）  
  - **P1967 [NOIP2013 提高组] 货车运输**（最大边权最小值，需生成树+LCA）  
  - **P2245 星际导航**（同货车运输思路）  

---

# **推荐题目**
1. **P1547**：最小生成树最大边权。  
2. **P1967**：最大边权最小值，需结合生成树与倍增 LCA。  
3. **P2296**：最短路变种（路径条件限制）。  

---

# **可视化设计**
### **克鲁斯卡尔算法动画演示**
1. **像素风格**：  
   - **颜色标记**：  
     - 节点：绿色（未连通），黄色（已合并）。  
     - 边：灰色（未处理），红色（当前边），蓝色（已合并）。  
   - **动画流程**：  
     1. 边按权值从小到大排序，逐条显示为红色。  
     2. 合并节点时，用黄色高亮连通区域。  
     3. 当 s 和 t 被黄色覆盖时，当前红色边权即为答案，播放胜利音效。  

### **Dijkstra 变种动画**
- **步进控制**：  
  - 优先队列弹出节点时，显示其邻接边。  
  - 松弛操作时，更新目标节点颜色（从浅绿到深绿表示更优解）。  
- **音效**：每次松弛成功时播放“滴”声，找到终点时播放上扬音效。  

---

# **代码核心实现**
### **克鲁斯卡尔算法（完整代码）**
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Edge { int x, y, cost; };
bool cmp(Edge a, Edge b) { return a.cost < b.cost; }

int n, m, s, t, fa[10005];
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }

int main() {
    cin >> n >> m >> s >> t;
    vector<Edge> edges(m);
    for (int i=0; i<m; i++) 
        cin >> edges[i].x >> edges[i].y >> edges[i].cost;
    sort(edges.begin(), edges.end(), cmp);
    
    for (int i=1; i<=n; i++) fa[i] = i;
    for (auto e : edges) {
        int fx = find(e.x), fy = find(e.y);
        if (fx != fy) fa[fx] = fy;
        if (find(s) == find(t)) {
            cout << e.cost;
            return 0;
        }
    }
    return 0;
}
```

---

# **总结**
- **最优解**：克鲁斯卡尔算法实现最简洁，时间复杂度稳定，适合竞赛快速编码。  
- **扩展思考**：若需多次查询不同 s→t 的最大边权最小值，可预处理生成树并建立 LCA 结构。  
- **调试技巧**：验证生成树连通性时，优先检查并查集的合并操作是否正确。

---
处理用时：91.95秒
# 题目信息

# 郁闷的记者

## 题目描述

你是一个体育报社的记者，你接受到一个艰难的任务：有 $N$ 支足球队参加足球比赛，现在给你一些比赛的结果，需要你给出各支球队的排名，从 $1$ 到 $N$。

以下是给你的一些信息：

 1. 没有平局；
 2. 不同的球队排名不能相同；
 3. 对于所有满足 $1 \le a<b \le N$，第 $a$ 名的球队一定可以打败第 $b$ 名的球队。

给你部分比赛结果，要求给出排名，并且判断是否存在另一种排名方法满足给你的比赛结果。


## 说明/提示

【数据范围】

$30\%$ 的数据满足：$1 \le N \le7$，$1 \le M \le 15$

$60\%$的数据满足：$1 \le N \le 100$，$1 \le M \le 2000$

$100\%$ 的数据满足：$1 \le N \le 5000$，$1 \le M \le 100000$


本题已加入spj，如果输出的最后一行错误将会提示 `Your decide is wrong!`

如果存在多种排名情况，排名错误将会提示 `Wrong ranks!`

如果情况固定且您的答案错误将会提示 `In line X,Your ans is wrong:expected = X,found = Y`


## 样例 #1

### 输入

```
3
2
2 1
2 3```

### 输出

```
2
1
3
1
```

# AI分析结果



## 算法分类
拓扑排序

---

## 题解思路与核心难点分析

### 核心算法流程
1. **胜负关系建模为有向图**：当队伍 A 打败队伍 B 时，建立 A→B 的边，表示 A 必须排在 B 前
2. **拓扑排序构建排名**：通过入度队列不断选择当前未被击败的节点（入度 0 的节点）
3. **唯一性判断**：在拓扑排序的每一步，若同时存在多个入度 0 的节点，则存在多种可能排名

### 解决难点
- **动态入度维护**：每次处理节点后需要实时更新被击败队伍的入度
- **多解检测机制**：在每次将新节点加入队列时，若队列长度 >1 则标记存在多解
- **大数处理优化**：采用链式前向星存储边，空间复杂度优化至 O(M)

---

## 题解评分 (≥4星)

### 1. Strong_Jelly（★★★★☆）
- **亮点**：双版本代码（邻接矩阵+链式前向星），详细注释说明拓扑排序与多解判断逻辑
- **优化点**：使用栈结构实现拓扑排序，适合字典序输出

### 2. Lonely_NewYear（★★★★☆）
- **亮点**：标准拓扑模板实现，明确分离拓扑排序与多解判断逻辑
- **关键代码**：在入队时直接判断队列是否已存在元素来标记多解

### 3. gyh20（★★★★☆）
- **亮点**：优先队列实现字典序最小解，同时保持多解判断逻辑
- **实践性**：负数技巧实现最小堆优先队列

---

## 最优思路提炼
1. **拓扑队列动态检测法**
   ```cpp
   queue<int> q;
   for (int i=1; i<=n; ++i)
       if (in[i]==0) q.push(i);
   if (q.size()>1) multi = true; // 初始多解判断
   
   while (!q.empty()) {
       int u = q.front(); q.pop();
       ans.push_back(u);
       
       int cnt = 0;
       for (auto v : edges[u]) {
           if (--in[v] == 0) {
               if (!q.empty()) multi = true; // 动态多解判断
               q.push(v);
           }
       }
   }
   ```
2. **链式前向星优化存储**
   ```cpp
   struct Edge { int to, next; } e[M];
   void add_edge(int u, int v) {
       e[++tot] = {v, head[u]};
       head[u] = tot;
       in[v]++;
   }
   ```

---

## 同类型题推荐
1. **P4017 最大食物链计数**（拓扑排序路径统计）
2. **P1137 旅行计划**（拓扑排序+DP）
3. **P2741 [USACO4.4] 重叠的图像**（拓扑排序应用）

---

## 可视化设计（复古像素风格）
### 动画要素
- **节点显示**：8-bit 风格的球队徽章图标
- **边动画**：胜利箭头闪烁特效（红→蓝）
- **入度计数**：每个节点右上角显示当前入度值
- **队列区**：屏幕下方动态展示待选节点队列

### 交互功能
- **速度控制**：方向键调节动画速度（←减速，→加速）
- **音效系统**：
  - `加入队列`：8-bit "哔"声
  - **多解触发**：警报音效
  - **完成排序**：胜利旋律

### 核心算法演示
```javascript
// 伪代码示例
class TopoAnim {
  constructor(graph) {
    this.nodes = graph.nodes.map(n => new PixelNode(n.id));
    this.queue = new PixelQueue();
    this.highlight = null;
  }

  step() {
    if (this.queue.size > 1) playMultiSound();
    let u = this.queue.dequeue();
    u.setColor(GREEN);
    
    graph.edges[u].forEach(v => {
      v.indegree--;
      if (v.indegree === 0) {
        this.queue.enqueue(v);
        playEnqueueSound();
      }
    });
  }
}
```

---

## 关键代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 5005;
vector<int> G[N];
int in[N], n, m;

int main() {
    cin >> n >> m;
    while (m--) {
        int a, b;
        cin >> a >> b;
        G[a].push_back(b);
        in[b]++;
    }
    
    queue<int> q;
    vector<int> ans;
    bool multi = false;
    
    for (int i=1; i<=n; ++i)
        if (!in[i]) q.push(i);
    if (q.size() > 1) multi = true;
    
    while (!q.empty()) {
        int u = q.front(); q.pop();
        ans.push_back(u);
        
        int cnt = 0;
        for (int v : G[u]) {
            if (--in[v] == 0) {
                if (!q.empty()) multi = true;
                q.push(v);
            }
        }
    }
    
    for (int x : ans) cout << x << endl;
    cout << multi << endl;
    return 0;
}
```

---
处理用时：67.19秒
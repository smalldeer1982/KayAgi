# 题目信息

# Mzc和体委的争夺战

## 题目背景

mzc 与 djn 第四弹。


## 题目描述

mzc 家很有钱（开玩笑），他家有 $n$ 个男家丁（做过前三弹的都知道）。但如此之多的男家丁吸引来了我们的体委（矮胖小伙），他要来与 mzc 争夺男家丁。

mzc 很生气，决定与其决斗，但 cat 的体力确实有些不稳定，所以他需要你来帮他计算一下最短需要的时间。


## 说明/提示

$1\le n \leq 2500$，$1\le m \leq 2\times10^5$，$1\le c_i\le 10^6$。

由于 mzc 大大十分着急，所以他只能等待 1s。


## 样例 #1

### 输入

```
5 8
1 2 3
2 3 4
3 4 5
4 5 6
1 3 4
2 4 7
2 5 8
1 5 100
```

### 输出

```
11```

# AI分析结果



## 算法分类
**最短路径**

---

## 题解分析与结论

### 核心思路与难点
1. **算法选择**  
   - 题目为单源最短路径问题，边权非负，Dijkstra 是最优选择。Bellman-Ford 的时间复杂度为 O(nm)（n≤2500，m≤2e5）可能超时，但实际数据宽松通过。
   - 需要处理无向图和重边（如邻接矩阵需取 min 值存储边权）。

2. **实现要点**  
   - **数据结构**：优先使用邻接表或链式前向星存储稀疏图，避免邻接矩阵的空间浪费。
   - **堆优化**：Dijkstra 的堆优化版本（优先队列）可将时间复杂度优化至 O(m log n)。
   - **重边处理**：在邻接矩阵中需取最小值，邻接表中无需显式处理。

3. **关键对比**  
   - **Bellman-Ford**：代码简单但效率低，仅适合特定场景。
   - **SPFA**：队列优化的 Bellman-Ford，随机数据下效率较高，但最坏复杂度仍为 O(nm)。
   - **邻接矩阵 vs 邻接表**：前者适合稠密图，后者适合稀疏图。本题 m=2e5 属于稀疏图，邻接表更优。

---

## 高分题解推荐（≥4星）

### 1. 利刃随人（堆优化 Dijkstra） ★★★★☆  
**亮点**：
- 使用 STL 优先队列实现堆优化，代码清晰。
- 邻接表存储，适合稀疏图。
- 正确处理无向图的双向边。
**代码片段**：
```cpp
priority_queue<node> q;
void dijkstra() {
    dis[1] = 0;
    q.push((node){0,1});
    while (!q.empty()) {
        node now = q.top(); q.pop();
        if (vis[now.jd]) continue;
        vis[now.jd] = true;
        for (int i=head[now.jd]; i; i=e[i].next) {
            int y = e[i].to;
            if (dis[y] > dis[now.jd] + e[i].worth) {
                dis[y] = dis[now.jd] + e[i].worth;
                q.push((node){dis[y], y});
            }
        }
    }
}
```

### 2. little_gift（SPFA 双版本） ★★★★  
**亮点**：
- 提供普通 SPFA 和 pb_ds 优化版本。
- 链式前向星存储，支持快速遍历邻接边。
**关键优化**：
```cpp
__gnu_pbds::priority_queue<int, comp> q; // 自定义优先队列
```

### 3. xukuan（链式前向星 SPFA） ★★★★  
**亮点**：
- 完全链式前向星实现，无显式判重逻辑。
- 队列优化，代码简洁高效。
**代码风格**：
```cpp
void SPFA() {
    queue<int> q;
    q.push(1);
    dis[1] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i=head[u]; ~i; i=e[i].next) {
            int v = e[i].to;
            if (dis[v] > dis[u] + e[i].w) {
                dis[v] = dis[u] + e[i].w;
                if (!vis[v]) q.push(v);
            }
        }
    }
}
```

---

## 最优技巧提炼
1. **堆优化 Dijkstra**：优先队列快速获取当前最小距离节点，时间复杂度稳定。
2. **链式前向星**：高效存储稀疏图，避免邻接矩阵的空间浪费。
3. **无向图处理**：添加双向边时需两次调用 `addEdge`。
4. **重边处理**：邻接矩阵需显式取 min，邻接表自动覆盖旧边（不影响最短路计算）。

---

## 同类题目推荐
1. **[P4779](https://www.luogu.com.cn/problem/P4779)**：单源最短路径（标准 Dijkstra 模板）。
2. **[P1629](https://www.luogu.com.cn/problem/P1629)**：邮递员送信（正向+反向图最短路）。
3. **[P4568](https://www.luogu.com.cn/problem/P4568)**：飞行路线（分层图最短路）。

---

## 可视化设计（Dijkstra 动画）
### 核心逻辑演示
1. **像素风格**：  
   - 节点用 16x16 像素方块表示，已访问节点为灰色，当前节点为红色，未访问为绿色。
   - 边用浅灰色线条连接，当前处理的边高亮为黄色。
2. **动画流程**：
   - **Step 1**：起点（节点1）标记为红色，距离 0。
   - **Step 2**：从优先队列取出节点1，遍历其邻接边，更新相邻节点距离。
   - **Step 3**：将更新后的节点加入队列，节点1标记为灰色（已访问）。
   - **循环**：重复取出最小距离节点，直到处理完所有节点。
3. **音效与交互**：
   - **节点更新**：播放 8-bit "beep" 音效。
   - **队列弹出**：播放低音鼓点。
   - **自动模式**：按空格键切换自动/手动步进。

### 关键代码片段（伪代码）
```javascript
class PixelNode {
  constructor(id, x, y) {
    this.id = id;
    this.x = x;
    this.y = y;
    this.color = '#00FF00'; // 初始绿色
  }
  draw(ctx) {
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y, 16, 16);
  }
}

function animateStep() {
  let current = queue.pop();
  current.color = '#FF0000'; // 红色标记当前节点
  playSound('beep.wav');
  current.neighbors.forEach(neighbor => {
    if (updateDistance(neighbor)) {
      neighbor.color = '#FFFF00'; // 黄色标记更新节点
      queue.add(neighbor);
    }
  });
  current.color = '#808080'; // 灰色标记已访问
}
```

---

## 个人心得摘录
- **邻接矩阵陷阱**：未处理重边会导致覆盖，需显式取 min（dan_daning_L 的调试经历）。
- **SPFA 队列细节**：节点出队后需重置 `vis` 标记，否则无法重新入队（little_gift 的注释修正）。
- **堆优化关键**：优先队列存储负距离避免自定义比较函数（利刃随人的 `make_pair(-d[y], y)` 技巧）。

---
处理用时：88.09秒
# 题目信息

# [HAOI2006] 聪明的猴子

## 题目描述

在一个热带雨林中生存着一群猴子，它们以树上的果子为生。昨天下了一场大雨，现在雨过天晴，但整个雨林的地表还是被大水淹没着，部分植物的树冠露在水面上。猴子不会游泳，但跳跃能力比较强，它们仍然可以在露出水面的不同树冠上来回穿梭，以找到喜欢吃的果实。

现在，在这个地区露出水面的有 $N$ 棵树，假设每棵树本身的直径都很小，可以忽略不计。我们在这块区域上建立直角坐标系，则每一棵树的位置由其所对应的坐标表示(任意两棵树的坐标都不相同)。

在这个地区住着的猴子有 $M$ 个，下雨时，它们都躲到了茂密高大的树冠中，没有被大水冲走。由于各个猴子的年龄不同、身体素质不同，它们跳跃的能力不同。有的猴子跳跃的距离比较远(当然也可以跳到较近的树上)，而有些猴子跳跃的距离就比较近。这些猴子非常聪明，它们通过目测就可以准确地判断出自己能否跳到对面的树上。

现已知猴子的数量及每一个猴子的最大跳跃距离，还知道露出水面的每一棵树的坐标，你的任务是统计有多少个猴子可以在这个地区露出水面的所有树冠上觅食。


## 说明/提示

对于 $40\%$ 的数据，保证有 $2 \le N \le 100$，$1 \le M \le 100$

对于全部的数据，保证有 $2 \le N \le 1000$，$1 \le M \le500$

感谢 @charlie003 修正数据

## 样例 #1

### 输入

```
4
 1 2 3 4
6
0 0
1 0
1 2
-1 -1
-2 0
2 2```

### 输出

```
3```

# AI分析结果



### 唯一算法分类
最小生成树（Kruskal/Prim）

---

### 综合分析与结论
#### 核心思路与难点
1. **核心思路**  
   所有树冠构成图的节点，计算所有节点间的欧氏距离作为边权。通过最小生成树算法找到连通所有节点的路径，此时生成树的最大边权即为猴子能覆盖全图的最小跳跃距离。统计所有猴子跳跃距离≥该值的数量。

2. **算法流程可视化设计**  
   - **边生成**：用网格展示所有树的坐标，动态绘制两两连线并计算距离  
   - **Kruskal执行**：按边权从小到大排序，用不同颜色标记已选边（绿色）和候选边（灰色）  
   - **并查集合并**：用树形结构展示连通分量，合并时动态更新颜色与连接关系  
   - **最大边高亮**：最终生成树中最大边标红，并显示其数值  

#### 解决难点
- **空间优化**：避免存储所有边（O(n²)可能超限），部分题解改用 Prim 的邻接矩阵  
- **精度处理**：直接比较距离平方与跳跃距离平方，避免浮点运算误差  
- **并查集效率**：路径压缩优化确保合并操作接近 O(1)

---

### 题解清单（≥4星）

| 题解作者   | 评分 | 核心亮点                                                                 |
|------------|------|--------------------------------------------------------------------------|
| 哥就是拽   | ★★★★☆ | 代码简洁，Kruskal 标准实现，直接记录最大边                                |
| K2sen      | ★★★★★ | 详细注释，距离计算优化（平方存储），变量命名清晰                          |
| Blue_wonders | ★★★★☆ | 提出距离平方优化，代码结构模块化，数组范围标注明确                        |

---

### 最优思路与技巧提炼
#### 关键技巧
1. **平方代替开根**  
   ```cpp
   // 原式：sqrt((x1-x2)^2 + (y1-y2)^2) ≤ 猴子的跳跃距离
   // 优化后比较平方：
   (x1-x2)^2 + (y1-y2)^2 ≤ (跳跃距离)^2
   ```
2. **Kruskal 最大边记录**  
   边已排序，最后加入生成树的边即为最大边：
   ```cpp
   for (edge in sorted_edges) {
       if (合并成功) max_edge = edge.weight;
   }
   ```

3. **并查集路径压缩**  
   ```cpp
   int find(int x) {
       return fa[x] == x ? x : fa[x] = find(fa[x]); // 路径压缩
   }
   ```

---

### 同类型题与算法套路
- **通用解法**：需要连通所有节点且约束最大单边的问题，均可转化为 MST 最大边问题  
- **类似题目**  
  - [P1991 无线通讯网](https://www.luogu.com.cn/problem/P1991)：卫星设备数约束下的最大通信距离  
  - [P2330 繁忙的都市](https://www.luogu.com.cn/problem/P2330)：最小生成树中的最大边  
  - [P2872 建路](https://www.luogu.com.cn/problem/P2872)：乡村道路建设成本优化  

---

### 推荐相似题目
1. **P1991**：MST 最大边与卫星设备数量的关系  
2. **P1265**：Prim 算法在稀疏图的应用  
3. **P4047**：部落划分中的 MST 变种  

---

### 个人心得摘录
> **调试教训**  
> - 数组大小估算错误导致 RE（如边数应为 n*(n-1)/2 而非 n）  
> - 浮点比较未考虑精度，改用整数平方后解决  
> 
> **优化顿悟**  
> - Kruskal 中边排序后，最后合并的边即最大边，无需额外记录  

---

### 可视化与算法演示（核心代码）
#### 复古像素动画设计
```javascript
// Canvas 初始化（伪代码）
const canvas = document.getElementById("pixel-canvas");
const ctx = canvas.getContext("2d");

// 绘制树节点（8-bit风格）
function drawTree(x, y) {
    ctx.fillStyle = "#00FF00"; // 绿色方块
    ctx.fillRect(x*20, y*20, 16, 16); // 网格坐标放大20倍
}

// 边生成动画
edges.forEach(edge => {
    drawLine(edge, "#808080"); // 灰色连线
    playSound("beep.wav"); // 每次添加边播放音效
});

// Kruskal 执行过程
let currentEdge = 0;
function stepKruskal() {
    if (currentEdge >= edges.length) return;
    let e = edges[currentEdge];
    if (find(e.u) != find(e.v)) {
        unite(e.u, e.v);
        drawLine(e, "#00FF00"); // 高亮选中边
        maxEdge = e; // 更新最大边
        playSound("click.wav");
    }
    currentEdge++;
    requestAnimationFrame(stepKruskal);
}

// 最终效果：最大边闪烁红光
function highlightMaxEdge() {
    setInterval(() => {
        drawLine(maxEdge, "#FF0000");
        setTimeout(() => drawLine(maxEdge, "#00FF00"), 200);
    }, 400);
}
```

---

### 完整代码示例（Kruskal 实现）
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Edge { int u, v; double w; };
vector<Edge> edges;
int fa[1005], n, m;
double max_w;

int find(int x) { 
    return fa[x] == x ? x : fa[x] = find(fa[x]); 
}

void kruskal() {
    sort(edges.begin(), edges.end(), [](Edge a, Edge b) { 
        return a.w < b.w; 
    });
    for (int i = 1; i <= n; ++i) fa[i] = i;
    int cnt = 0;
    for (auto e : edges) {
        int fu = find(e.u), fv = find(e.v);
        if (fu != fv) {
            fa[fu] = fv;
            max_w = e.w; // 更新最大边
            if (++cnt == n-1) break;
        }
    }
}

int main() {
    cin >> m;
    vector<int> jumps(m);
    for (int i = 0; i < m; ++i) cin >> jumps[i];
    cin >> n;
    vector<pair<int, int>> trees(n);
    for (int i = 0; i < n; ++i) 
        cin >> trees[i].first >> trees[i].second;
    
    // 构建所有边
    for (int i = 0; i < n; ++i) {
        for (int j = i+1; j < n; ++j) {
            int dx = trees[i].first - trees[j].first;
            int dy = trees[i].second - trees[j].second;
            edges.push_back({i+1, j+1, sqrt(dx*dx + dy*dy)});
        }
    }
    
    kruskal();
    int ans = 0;
    for (int j : jumps) 
        if (j >= max_w) ans++;
    cout << ans;
    return 0;
}
```

---
处理用时：91.36秒
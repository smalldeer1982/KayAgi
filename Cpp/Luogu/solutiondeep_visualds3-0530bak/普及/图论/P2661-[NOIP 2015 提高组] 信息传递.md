# 题目信息

# [NOIP 2015 提高组] 信息传递

## 题目背景

NOIP2015 Day1T2

## 题目描述

有 $n$ 个同学（编号为 $1$ 到 $n$）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 $i$ 的同学的信息传递对象是编号为 $T_i$ 的同学。

游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息，但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？

## 说明/提示

**样例 1 解释：**

![](https://cdn.luogu.com.cn/upload/image_hosting/3ca5zl3c.png)

游戏的流程如图所示。当进行完第 $3$ 轮游戏后，$4$ 号玩家会听到 $2$ 号玩家告诉他自己的生日，所以答案为 $3$。当然，第 $3$ 轮游戏后，$2$ 号玩家、 $3$ 号玩家都能从自己的消息来源得知自己的生日，同样符合游戏结束的条件。

- 对于 $30\%$ 的数据，$n\le 200$；
- 对于 $60\%$ 的数据，$n\le 2500$；
- 对于 $100\%$ 的数据，$n\le 2\times 10^5$。


## 样例 #1

### 输入

```
5
2 4 2 3 1```

### 输出

```
3```

# AI分析结果



## 算法分类
**图论 - 环检测**

---

## 核心思路与难点分析

### 题解思路与算法要点
- **核心目标**：在出度为1的有向图中找到最小环的长度。
- **关键性质**：每个节点出度为1 ⇒ 每个连通分量是单链+环，且环唯一。

#### 主要解法对比：
1. **DFS遍历 + 时间戳标记法**  
   - **核心逻辑**：对每个未访问节点进行DFS，记录访问时间戳。当遇到已标记节点时，通过时间差计算环长。  
   - **优化点**：利用时间戳批次标记（如`t[j] = i`）避免重复处理，时间复杂度严格 O(n)。

2. **并查集 + 距离维护**  
   - **核心逻辑**：动态维护每个节点到父节点的距离。当合并两个节点发现同属一个集合时，计算环长。  
   - **实现要点**：路径压缩时更新距离值，合并时维护距离关系。

3. **拓扑排序预处理**  
   - **核心逻辑**：通过拓扑排序去除链结构，剩余节点必在环中，DFS找环长。  
   - **优势**：预处理后只需处理环节点，减少搜索量。

4. **Tarjan强连通分量**  
   - **核心逻辑**：利用Tarjan算法求SCC，每个SCC对应一个环，直接取最小SCC大小。  
   - **适用性**：适用于一般图，但本题特殊结构可简化实现。

### 解决难点
- **高效环检测**：需在 O(n) 时间内处理 2e5 节点。  
- **避免重复计算**：通过标记已处理节点（如`novisit`数组或时间戳批次）确保每个环仅计算一次。  
- **距离动态维护**：并查集方法需在路径压缩时正确更新距离值。

---

## 题解评分 (≥4星)

1. **KesdiaelKen（DFS遍历）**  
   - **评分**：★★★★☆  
   - **亮点**：双标记数组清晰避免重复处理，代码逻辑直观，适合教学演示。

2. **qhr2023（并查集）**  
   - **评分**：★★★★★  
   - **亮点**：代码极简（仅20行），利用路径压缩维护距离，时间复杂度接近线性。

3. **JCT_addyi（时间戳标记法）**  
   - **评分**：★★★★★  
   - **亮点**：时间复杂度严格 O(n)，代码简洁易懂，无复杂数据结构。

---

## 最优思路提炼
**时间戳标记法**  
- **关键步骤**：  
  1. 对每个节点 `i`，沿出边遍历并标记当前批次编号（如`t[j] = i`）。  
  2. 记录首次访问步数 `r[j]`，当再次遇到同一批次标记时，计算步数差作为环长。  
- **代码片段**：
  ```cpp
  for(int i=1; i<=n; i++){
      int j=i, k=0;
      while(1){
          if(t[j]){
              if(t[j] == i) ans = min(ans, k-r[j]);
              break;
          }
          t[j] = i;  // 标记当前批次
          r[j] = k;  // 记录首次访问步数
          k++; j = a[j];
      }
  }
  ```

---

## 类似题目推荐
1. **P2921 [USACO08DEC]Trick or Treat on the Farm**  
   - **相似点**：同样求每个节点所在环长，可用时间戳法或并查集。

2. **P3387 【模板】缩点**  
   - **相似点**：涉及强连通分量，可用Tarjan算法。

3. **P2668 斗地主**  
   - **相似点**：复杂循环检测，需高效遍历与标记。

---

## 可视化与算法演示设计
### 动画方案（时间戳法）
1. **动态遍历路径**：  
   - 用不同颜色标记当前遍历路径，已处理节点灰色显示。  
   - 高亮当前节点和下一个跳转节点，显示时间戳和步数。

2. **环检测高亮**：  
   - 检测到环时，用红色标注环路径，显示环长计算过程（如 `k - r[j]`）。

3. **复古像素风格**：  
   - **颜色方案**：8-bit 色调，节点用绿色（未访问）、黄色（当前路径）、红色（环）。  
   - **音效**：遍历时播放“滴”声，检测到环时播放上扬音效。

### 交互设计
- **步进控制**：允许暂停/继续，观察每一步时间戳更新。  
- **自动演示**：按设定速度自动遍历所有节点，显示最小环更新过程。

---

## 核心代码实现（时间戳法）
```cpp
#include <iostream>
using namespace std;
int n, a[200005], t[200005], r[200005], ans=1e9;

int main() {
    cin >> n;
    for(int i=1; i<=n; i++) cin >> a[i];
    for(int i=1; i<=n; i++) {
        int j=i, k=0;
        while(1) {
            if(t[j]) {
                if(t[j] == i) ans = min(ans, k - r[j]);
                break;
            }
            t[j] = i;  // 标记当前批次
            r[j] = k;  // 记录首次步数
            k++;
            j = a[j];  // 跳转下一个节点
        }
    }
    cout << ans;
    return 0;
}
```

---

## 个人心得摘录
- **qhr2023**：并查集维护距离的路径压缩需注意顺序，先递归更新父节点距离再累加当前节点。  
- **KesdiaelKen**：DFS中`novisit`数组的引入避免重复处理同一连通分量，极大优化时间复杂度。

---
处理用时：110.19秒
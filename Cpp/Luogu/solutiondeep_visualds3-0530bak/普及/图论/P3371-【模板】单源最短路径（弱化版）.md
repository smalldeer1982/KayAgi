# 题目信息

# 【模板】单源最短路径（弱化版）

## 题目背景

本题测试数据为随机数据，在考试中可能会出现构造数据让SPFA不通过，如有需要请移步 [P4779](https://www.luogu.org/problemnew/show/P4779)。

## 题目描述

如题，给出一个有向图，请输出从某一点出发到所有点的最短路径长度。


## 说明/提示

【数据范围】    
对于 $20\%$ 的数据：$1\le n \le 5$，$1\le m \le 15$；  
对于 $40\%$ 的数据：$1\le n \le 100$，$1\le m \le 10^4$；   
对于 $70\%$ 的数据：$1\le n \le 1000$，$1\le m \le 10^5$；   
对于 $100\%$ 的数据：$1 \le n \le 10^4$，$1\le m \le 5\times 10^5$，$1\le u,v\le n$，$w\ge 0$，$\sum w< 2^{31}$，保证数据随机。

**Update 2022/07/29：两个点之间可能有多条边，敬请注意。**

对于真正 $100\%$ 的数据，请移步 [P4779](https://www.luogu.org/problemnew/show/P4779)。请注意，该题与本题数据范围略有不同。


样例说明：

![](https://cdn.luogu.com.cn/upload/pic/7641.png)

图片1到3和1到4的文字位置调换


## 样例 #1

### 输入

```
4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4```

### 输出

```
0 2 4 3```

# AI分析结果



## 【算法分类】  
单源最短路径 (SPFA 与 Dijkstra 的堆优化)

---

## 【题解思路与解决难点】  

### 核心思路  
1. **SPFA 算法**  
   - **松弛操作**：通过队列动态更新节点的最短距离，若 `dis[v] > dis[u] + w(u,v)` 则更新。  
   - **队列优化**：用队列保存待处理节点，避免重复计算；部分题解使用 **SLF 优化**（将更优节点插入队首）和 **LLL 优化**（过滤高平均值节点）。  
   - **判环逻辑**：通过节点入队次数判断负权环，但本题数据不含负权。  

2. **Dijkstra 堆优化**  
   - **贪心策略**：每次从优先队列中取出当前距离最小的节点，保证其最短路径已确定。  
   - **优先队列实现**：使用 `priority_queue` 或手写堆，存储 `(距离, 节点)` 对并按距离排序。  
   - **链式前向星**：高效存储大规模稀疏图，避免邻接矩阵的空间浪费。  

### 解决难点  
- **大规模数据处理**：邻接表（链式前向星）存储 5e5 条边，避免内存溢出。  
- **时间复杂度优化**：SPFA 通过队列减少无效松弛，Dijkstra 堆优化将复杂度从 O(n²) 降至 O(m log n)。  
- **负权边兼容性**：SPFA 可处理非负权边（但本题无负权），而 Dijkstra 仅适用于非负权图。  

---

## 【题解评分 (≥4星)】  

1. **微雨燕双飞 (SPFA + 链式前向星) ★★★★☆**  
   - **亮点**：代码简洁，使用标准队列和邻接表，适合新手理解 SPFA 流程。  
   - **优化点**：未实现 SLF/LLL 优化，但在随机数据下表现良好。  

2. **Nemlit (多算法对比) ★★★★☆**  
   - **亮点**：详解 Floyd、Dijkstra、SPFA 的实现差异，提供复杂度对比。  
   - **代码示例**：包含堆优化 Dijkstra 的完整实现，注释清晰。  

3. **Ophelia (堆优化 Dijkstra) ★★★★☆**  
   - **亮点**：使用 `pair` 简化优先队列排序，代码可读性极强。  
   - **关键注释**：解释 `priority_queue` 的排序逻辑和松弛操作细节。  

---

## 【最优思路提炼】  

### 关键技巧  
1. **链式前向星存图**  
   ```cpp  
   struct Edge { int to, w, next; } edge[M];  
   void add(int u, int v, int w) {  
       edge[++cnt] = {v, w, head[u]};  
       head[u] = cnt;  
   }  
   ```  
   - **优势**：O(1) 插入边，O(m) 遍历邻接节点，完美适配稀疏图。  

2. **堆优化 Dijkstra 的优先队列**  
   ```cpp  
   priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;  
   pq.emplace(0, s);  // 存储 (距离, 节点)  
   ```  
   - **注意点**：需标记已确定最短路径的节点，避免重复处理。  

3. **SPFA 的 SLF 优化**  
   ```cpp  
   if (!vis[v]) {  
       if (!q.empty() && dis[v] < dis[q.front()])  
           q.push_front(v);  // 更优节点插入队首  
       else  
           q.push_back(v);  
   }  
   ```  

---

## 【同类型题与算法套路】  

### 相似算法模式  
- **最短路径变种**：次短路径、带限制最短路径（如边数限制）。  
- **反向建图**：求多个终点到某起点的最短路径时，反向建图 + 单源算法。  

### 推荐题目  
1. **P4779**：单源最短路径（加强版），需使用堆优化 Dijkstra。  
2. **P3385**：判断图中是否存在负权环，SPFA 变种应用。  
3. **P5905**：全源最短路径，可用 Johnson 算法结合 SPFA 和 Dijkstra。  

---

## 【可视化设计】  

### 算法动画方案  
1. **Dijkstra 流程演示**  
   - **高亮当前节点**：红色标记正在处理的节点。  
   - **优先队列可视化**：右侧面板显示优先队列中的 `(距离, 节点)` 对。  
   - **松弛动画**：绿色闪烁被更新的邻接节点，显示更新后的距离值。  

2. **SPFA 队列操作**  
   - **队列流动效果**：节点从队首取出时灰色渐变，新入队节点从右侧滑入。  
   - **松弛对比**：用不同颜色区分首次更新和重复更新操作。  

### 复古像素风格实现  
```javascript  
// Canvas 绘制节点网格  
function drawGrid() {  
    ctx.fillStyle = "#2C3E50";  
    nodes.forEach((node, i) => {  
        const x = (i % 10) * 50 + 20;  
        const y = Math.floor(i / 10) * 50 + 20;  
        ctx.fillRect(x, y, 30, 30); // 像素化

---
处理用时：103.28秒
# 题目信息

# 【模板】负环

## 题目描述

给定一个 $n$ 个点的有向图，请求出图中是否存在**从顶点 $1$ 出发能到达**的负环。

负环的定义是：一条边权之和为负数的回路。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq n \leq 2 \times 10^3$，$1 \leq m \leq 3 \times 10^3$。
- $1 \leq u, v \leq n$，$-10^4 \leq w \leq 10^4$。
- $1 \leq T \leq 10$。

#### 提示

请注意，$m$ **不是**图的边数。

## 样例 #1

### 输入

```
2
3 4
1 2 2
1 3 4
2 3 1
3 1 -3
3 3
1 2 3
2 3 4
3 1 -8
```

### 输出

```
NO
YES
```

# AI分析结果



**唯一算法分类**：SPFA（队列优化的Bellman-Ford算法）

---

### **算法要点与解决难点分析**

#### **核心思路**
所有题解均基于SPFA算法，核心逻辑是通过判断「最短路径边数 ≥n」或「入队次数 ≥n」来检测负环。关键差异在于：
1. **松弛次数 vs 入队次数**：重边可能导致多次松弛但不入队，入队次数更可靠
2. **边数统计法**：记录到每个节点的最短路径边数，当边数≥n时必然存在环
3. **多图处理**：每组测试数据需重置图结构、队列、距离数组等状态

#### **关键实现细节**
| 实现方法          | 数据结构               | 核心变量               | 时空复杂度          |
|-------------------|------------------------|-----------------------|-------------------|
| 入队次数判断       | 队列 + 链式前向星     | `cnt[v]`（入队次数） | O(mn) 最坏情况    |
| 边数统计法         | 队列 + 链式前向星     | `cnt[v]`（路径边数） | O(mn) 实际更优     |

#### **难点突破**
1. **负环可达性**：仅检测从起点1可达的负环，需通过距离数组过滤不可达节点
2. **重边干扰**：通过入队次数而非松弛次数规避重边导致的误判
3. **多图初始化**：每组数据必须清空边表、重置距离数组（`memset`+`head[]`重置）

---

### **题解评分 (≥4星)**

| 题解作者         | 评分 | 核心亮点                                                                 |
|------------------|------|--------------------------------------------------------------------------|
| Singercoder      | ★★★★☆ | 提出两种检测方案，给出hack数据，代码包含路径边数优化实现                  |
| iMya_nlgau       | ★★★★  | 详细推导SPFA原理，代码实现路径边数法，结构清晰                           |
| AzzyZhe          | ★★★★  | 对比多种算法，给出负环定位扩展思路，适合进阶学习                         |

---

### **最优思路提炼**
**路径边数法（最优实现）**
```cpp
void spfa() {
    fill(dis, dis+n+1, INF);
    cnt[1] = 0; // 起点路径边数为0
    queue<int> q;
    q.push(1);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (edge e : G[u]) {
            if (dis[u] + e.w < dis[e.v]) {
                dis[e.v] = dis[u] + e.w;
                cnt[e.v] = cnt[u] + 1; // 路径边数继承+1
                if (cnt[e.v] >= n) return true; // 检测到负环
                if (!in_queue[e.v]) {
                    q.push(e.v);
                    in_queue[e.v] = true;
                }
            }
        }
    }
    return false;
}
```

---

### **同类型题推荐**
1. [P5960 差分约束](https://www.luogu.com.cn/problem/P5960)（负环判断模板）
2. [P2868 观光奶牛](https://www.luogu.com.cn/problem/P2868)（分数规划+负环检测）
3. [P1938 航班限制](https://www.luogu.com.cn/problem/P1938)（带权值约束的最短路）

---

### **可视化设计**
**动画方案**：  
![SPFA负环检测动画示意图](https://cdn.luogu.com.cn/upload/image_hosting/xy0r8v5b.gif)
1. **节点状态**：  
   - 蓝色：未访问  
   - 绿色：在队列中  
   - 红色：路径边数≥n（检测到负环）  
2. **边更新**：松弛成功时显示金色闪烁  
3. **队列动态**：右侧展示队列元素进出过程  

**复古像素特效**：  
```javascript
// 伪代码示例：像素化节点绘制
function drawNode(ctx, x, y, state) {
    const colors = { default: '#2C3A47', active: '#B33771', found: '#FF4757' };
    ctx.fillStyle = colors[state];
    ctx.fillRect(x*32, y*32, 28, 28); // 32x32像素网格
}
```

**音效设计**：  
- `入队音效`：8-bit短促"哔"声（[JSFiddle示例](https://jsfiddle.net/7s6qk8xo/)）  
- `负环检测`：连续下降音阶表示异常状态  

---

### **核心代码实现**
```cpp
// 路径边数法完整实现（Singercoder优化版）
#include <queue>
#include <cstring>
using namespace std;

const int MAXN = 2e3+5, INF = 0x3f3f3f3f;
struct Edge { int to, w; };
vector<Edge> G[MAXN];
int dis[MAXN], cnt[MAXN];
bool inQueue[MAXN];

bool hasNegativeCycle(int n) {
    memset(dis, 0x3f, sizeof(dis));
    memset(cnt, 0, sizeof(cnt));
    memset(inQueue, 0, sizeof(inQueue));
    
    queue<int> q;
    q.push(1);
    dis[1] = 0;
    inQueue[1] = true;
    
    while (!q.empty()) {
        int u = q.front(); q.pop();
        inQueue[u] = false;
        
        for (Edge e : G[u]) {
            if (dis[u] + e.w < dis[e.to]) {
                dis[e.to] = dis[u] + e.w;
                cnt[e.to] = cnt[u] + 1;
                
                if (cnt[e.to] >= n) 
                    return true;
                
                if (!inQueue[e.to]) {
                    q.push(e.to);
                    inQueue[e.to] = true;
                }
            }
        }
    }
    return false;
}
```

---

### **总结**
通过SPFA的路径边数法可高效检测负环，其核心优势在于：  
1. 避免重边/自环的干扰  
2. 数学上严格证明（路径边数≥n必然成环）  
3. 时间复杂度优于传统入队次数法  

结合复古像素动画与音效交互，可直观展示算法执行过程，特别适合教学演示与竞赛训练。

---
处理用时：96.32秒
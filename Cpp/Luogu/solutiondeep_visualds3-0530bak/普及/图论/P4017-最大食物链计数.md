# 题目信息

# 最大食物链计数

## 题目背景

你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。


## 题目描述

给你一个食物网，你要求出这个食物网中最大食物链的数量。

（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）

Delia 非常急，所以你只有 $1$ 秒的时间。

由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。


## 说明/提示

各测试点满足以下约定：

 ![](https://cdn.luogu.com.cn/upload/pic/12011.png) 

【补充说明】

数据中不会出现环，满足生物学的要求。（感谢 @AKEE ）


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 3
3 5
2 5
4 5
3 4```

### 输出

```
5```

# AI分析结果



## 算法分类
拓扑排序

## 题解思路与核心难点
### 核心算法流程
1. **拓扑排序 + DP**：在拓扑排序过程中，用动态规划思想累加路径数。每个节点维护一个路径计数，初始生产者路径数为1，拓扑处理时将当前节点路径数累加到所有后继节点。
2. **关键数据结构**：邻接表存图，队列维护拓扑顺序，数组记录入度、出度及路径数。
3. **难点解决**：通过入度归零顺序确保计算正确性，避免环干扰（题目保证无环）。

### 题解评分（≥4星）
1. **御·Dragon（5星）**  
   - 亮点：图文结合详细推导，关键步骤可视化演示，代码注释清晰。  
   - 核心代码：使用 vector 邻接表，队列拓扑排序，路径数动态累加。
2. **Watcher（4星）**  
   - 亮点：两种存储方式对比（邻接矩阵/表），时空复杂度分析清晰。  
   - 核心代码：结构体邻接表实现，拓扑过程与路径数更新分离。
3. **Guitar_Jasmine（4星）**  
   - 亮点：代码简洁易读，变量命名规范，适合快速理解核心逻辑。  
   - 核心代码：链式前向星存图，拓扑排序与 DP 结合。

## 最优思路提炼
- **拓扑序递推**：按拓扑顺序更新路径数，确保前置节点先计算完成。  
- **路径数累加公式**：`f[v] = (f[v] + f[u]) % mod`，其中 u 是当前节点，v 是其后继。  
- **结果收集**：累加所有出度为0节点的路径数。

## 类似题目推荐
1. P4017（最大食物链计数原题）
2. P1137（旅行计划，拓扑排序+路径计数）
3. P2741（无序字母对，欧拉路径+拓扑思想）

---

## 核心代码实现（御·Dragon版）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e3 + 5, mod = 80112002;
vector<int> g[N]; // 邻接表
int in[N], out[N], f[N], n, m;

int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; ++i) {
        int u, v; cin >> u >> v;
        g[u].push_back(v);
        in[v]++; out[u]++;
    }
    
    queue<int> q;
    for (int i = 1; i <= n; ++i) 
        if (!in[i]) { f[i] = 1; q.push(i); }
    
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : g[u]) {
            f[v] = (f[v] + f[u]) % mod;
            if (--in[v] == 0) q.push(v);
        }
    }
    
    int ans = 0;
    for (int i = 1; i <= n; ++i)
        if (!out[i]) ans = (ans + f[i]) % mod;
    cout << ans;
}
```

---

## 可视化设计（复古像素风格）
### 动画演示逻辑
1. **初始化界面**：  
   - 8位像素风格，节点用不同颜色方块表示（蓝=生产者，红=消费者）。  
   - 队列显示为底部滚动条，当前处理节点高亮闪烁。

2. **拓扑过程**：  
   - **Step 1**：蓝色生产者入队，播放“叮”音效。  
   - **Step 2**：节点出队时变黄，路径数显示在方块上方。  
   - **Step 3**：绿色箭头指向后继节点，更新其路径数并播放“咔”音效。  
   - **Step 4**：节点入度归零时入队，队列图标更新。

3. **结果展示**：  
   - 红色消费者闪烁，路径数累加显示在右侧面板。  
   - 背景音乐变调提示完成，播放胜利音效。

### 交互功能
- **速度控制**：滑动条调节动画速度（0.5x~3x）。  
- **单步执行**：按空格键逐帧观察路径数更新。  
- **数据面板**：实时显示队列状态、当前处理节点及全局路径数。

```javascript
// 示例：Canvas 绘制节点
function drawNode(ctx, x, y, color, text) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y, 30, 30); // 像素方块
    ctx.fillStyle = 'white';
    ctx.font = '8px Arial';
    ctx.fillText(text, x + 5, y + 20);
}
```

---

通过这种设计，学习者可直观观察拓扑排序如何驱动路径计数，理解动态规划与拓扑序的结合机制。

---
处理用时：72.79秒
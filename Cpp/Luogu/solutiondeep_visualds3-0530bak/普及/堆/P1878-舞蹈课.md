# 题目信息

# 舞蹈课

## 题目描述

有 $n$ 个人参加一个舞蹈课。每个人的舞蹈技术由整数来决定。在舞蹈课的开始，他们从左到右站成一排。当这一排中至少有一对相邻的异性时，舞蹈技术相差最小的那一对会出列并开始跳舞。如果不止一对，那么最左边的那一对出列。一对异性出列之后，队伍中的空白按原顺序补上（即：若队伍为 `ABCD`，那么 `BC` 出列之后队伍变为 `AD`）。舞蹈技术相差最小即是 $a_i$ 的绝对值最小。

任务是模拟以上过程，确定跳舞的配对及顺序。


## 说明/提示

对于 $50\%$ 的数据，$1\leq n\leq 200$。

对于 $100\%$ 的数据，$1\leq n\leq 2\times 10^5$，$1\le a_i\le 10^7$。

## 样例 #1

### 输入

```
4

BGBG

4 2 4 3

```

### 输出

```
2

3 4

1 2

```

# AI分析结果



---

## 算法分类
**贪心算法 + 优先队列 + 双向链表**

---

## 综合分析与结论
### 核心思路
1. **优先队列**维护所有相邻异性对的技术差，按最小差值优先出队
2. **双向链表**动态维护当前队列的相邻关系，处理出队后的连接合并
3. **标记数组**避免重复处理已出队的元素
4. 每次出队后检查前后元素是否形成新的合法配对，并加入优先队列

### 解决难点
- **动态合并处理**：通过双向链表 `pre[]` 和 `next[]` 数组实现 O(1) 时间合并相邻元素
- **无效对过滤**：堆中存储的旧配对可能因链表更新失效，需用标记数组跳过已处理元素
- **边界处理**：首元素无前驱、末元素无后继的特殊情况处理

### 可视化设计思路
1. **8位像素动画**：用色块表示学生，蓝色（男）/粉色（女），技术值显示在色块中央
2. **链表指针动画**：用箭头连接相邻元素，箭头颜色随技术差变化（红→黄→绿，差值由小到大）
3. **操作高亮**：
   - 当前处理的配对用闪烁金边标记
   - 链表断开时播放像素断裂特效，合并时播放绿色连接特效
4. **音效设计**：
   - 出队时播放 "coin.wav"（类似马里奥吃金币）
   - 合并时播放 "link.wav"（类似塞尔达传说链接音效）
   - 错误操作时播放 "error.wav"（红白机游戏结束音）
5. **自动演示模式**：按空格键切换自动/手动模式，自动模式下每步间隔可调

---

## 题解清单（≥4星）
### 1. 汪鸣谦（★★★★☆）
- **亮点**：结构体设计清晰，运算符重载规范，链表更新代码简洁
- **核心代码**：
```cpp
struct node{ int w,c,d; };
priority_queue<node>q;
...
f[g[x]] = f[y];  // 链表断链重连
g[f[y]] = g[x];
```

### 2. ListenSnow（★★★★☆）
- **亮点**：标记数组与链表操作分离，可读性强
- **心得摘录**：  
  *"vis数组必须同时标记左右节点，否则会出现幽灵配对"*

### 3. 反手一只MJJ（★★★★☆）
- **亮点**：独立设计链表系统，可视化友好
- **关键变量**：
```cpp
int L[MAXN],R[MAXN];  // 独立链表系统
...
L[R[x.r]] = L[x.l];   // 链表合并操作
R[L[x.l]] = R[x.r];
```

---

## 最优思路提炼
### 关键数据结构
```cpp
priority_queue<Pair> heap;      // 小根堆存储配对
int pre[MAXN], next[MAXN];      // 双向链表
bool vis[MAXN];                 // 出队标记
```

### 核心流程
```cpp
// 初始化链表与堆
for(i=1~n) pre[i]=i-1, next[i]=i+1;
for(i=1~n-1) if(异性) heap.push({i,i+1,差});

while(!heap.empty()){
    auto [x,y] = heap.top();
    if(vis[x]||vis[y]) continue; // 跳过无效对
    vis[x]=vis[y]=true;          // 标记出队
    ans.push_back({x,y});       
    
    // 链表合并
    int l=pre[x], r=next[y];
    pre[r] = l;
    next[l] = r;
    
    if(l和r是异性) 
        heap.push({l, r, abs(a[l]-a[r])});
}
```

---

## 同类题目推荐
1. **P1090 [NOIP2004 提高组] 合并果子**（贪心+优先队列）
2. **P1160 队列安排**（双向链表操作）
3. **P2168 [NOI2015] 荷马史诗**（哈夫曼树+优先队列）

---

## 可视化代码片段（Canvas+JS）
```javascript
// 绘制学生队列
function drawStudents() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let i = 1; i <= n; i++) {
    if (vis[i]) continue; // 跳过已出队
    const x = 50 + i * 60;
    const y = 200;
    // 绘制色块
    ctx.fillStyle = sex[i] ? '#FFB6C1' : '#87CEEB';
    if (currentPair.includes(i)) { // 高亮当前处理对
      ctx.shadowColor = 'gold';
      ctx.shadowBlur = 20;
    }
    ctx.fillRect(x-25, y-25, 50, 50);
    ctx.shadowBlur = 0;
    // 显示技术值
    ctx.fillStyle = 'black';
    ctx.font = '14px pixel';
    ctx.textAlign = 'center';
    ctx.fillText(a[i], x, y+5);
    // 绘制链表箭头
    if (next[i] <=n && !vis[next[i]]) {
      drawArrow(x+25, y, x+35, y);
    }
  }
}

// 播放出队音效
function playDequeueSound() {
  const audio = new Audio('coin.wav');
  audio.play();
}
```

---

## 调试心得
1. **标记数组陷阱**：*某次未同时标记配对双方，导致后续误判性别*
2. **链表边界处理**：*忘记检查 pre[x] 是否越界（pre[x]<1），导致数组越界*
3. **堆的更新时机**：*过早将新配对入堆导致旧无效配对未被清理*

---

## 游戏化设计
1. **连击系统**：连续正确处理3对额外+50分，中断则重置
2. **限时挑战模式**：60秒内处理最多配对者进入排行榜
3. **皮肤解锁**：得分超过1000可解锁复古皮肤（如超级马里奥、魂斗罗主题）
4. **AI演示**：自动模式下，算法过程以红蓝箭头动态演示链表合并

---

**通过结合贪心策略与动态链表维护，本算法在O(n log n)时间复杂度内高效解决问题，可视化设计则通过复古元素增强学习趣味性**

---
处理用时：95.40秒
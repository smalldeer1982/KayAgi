# 题目信息

# 最小函数值

## 题目描述

有 $n$ 个函数，分别为 $F_1,F_2,\dots,F_n$。定义 $F_i(x)=A_ix^2+B_ix+C_i(x\in\mathbb N*)$。给定这些 $A_i$、$B_i$ 和 $C_i$，请求出所有函数的所有函数值中最小的 $m$ 个（如有重复的要输出多个）。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n,m\le10000$，$1 \leq A_i\le10$,
$0 \leq B_i\le100$,
$0 \leq C_i\le10^4$。

## 样例 #1

### 输入

```
3 10
4 5 3
3 4 5
1 7 1
```

### 输出

```
9 12 12 19 25 29 31 44 45 54```

# AI分析结果



### 唯一算法分类
堆（优先队列）

### 综合分析与结论
**核心思路**：利用小根堆维护n个二次函数当前的最小候选值。每个函数在x=1时取得最小值，每次取出堆顶元素后，将该函数的下一个x值对应的函数值加入堆中。  
**难点**：如何高效维护多个递增序列的最小候选值。  
**解决方案**：通过优先队列动态维护每个函数的当前最小值候选，确保每次取出的都是全局最小值。  

**可视化设计**：  
- **动画方案**：用不同颜色方块表示各函数，初始时所有函数x=1的值入堆。每次弹出堆顶时高亮黄色，对应的函数x+1后新值以绿色入堆。堆结构用二叉树展示，节点显示函数编号和当前x值。  
- **游戏化要素**：采用8-bit音效（弹出堆顶时"滴"声，插入新值时"嘟"声），背景播放NES风格BGM。通过积分系统记录正确操作次数，连续正确操作触发连击特效。

### 题解清单 (≥4星)
1. **Euler_Pursuer（5星）**  
   - 核心：小根堆维护动态候选值，O(m log n)时间复杂度  
   - 亮点：详细分析暴力法缺陷，提供堆优化完整实现  
   - 代码片段：  
     ```cpp
     for(int i=0;i<m;i++) {
         cmin=100000000;
         for(j=0;j<n;j++){ // 暴力找最小值
             if(F[j]的计算值 < cmin) 更新cmin和jmin
         }
         F[jmin]++; // 对应函数x+1
     }
     ```

2. **Hoxilon21（4.5星）**  
   - 核心：结构体优先队列记录函数编号和当前x  
   - 亮点：代码简洁，使用STL优先队列  
   - 代码片段：  
     ```cpp
     priority_queue<node> q;
     q.push({i,1,f(i,1)});
     ```

3. **DavidW（4星）**  
   - 核心：pbds库优化堆操作  
   - 亮点：实测8ms极速，适合竞赛场景  
   - 代码片段：  
     ```cpp
     __gnu_pbds::priority_queue<pair<int,int>> q;
     q.push({f(x,1),i});
     ```

### 最优思路提炼
1. **堆维护候选集**：将每个函数视为递增序列，用堆维护各序列当前最小候选值。  
2. **动态更新策略**：每次取出最小值后，只需将该函数的下一个值加入候选集。  
3. **时间复杂度控制**：O(m log n)复杂度确保万级数据高效处理。

### 同类型题推荐
1. **P1631 序列合并** - 合并有序序列的经典堆应用  
2. **P1886 滑动窗口** - 单调队列维护区间最值  
3. **P3368 【模板】树状数组 2** - 高效维护动态前缀信息

### 核心代码实现
```cpp
#include <queue>
using namespace std;

struct Func {
    int a,b,c,x;
    int val() const { return a*x*x + b*x + c; }
    bool operator<(const Func& f) const { return val() > f.val(); }
};

priority_queue<Func> q;

void solve(int n, int m) {
    while(m--) {
        Func f = q.top(); q.pop();
        cout << f.val() << " ";
        f.x++;
        q.push(f);
    }
}
```

### 可视化演示方案
![堆维护过程](https://i.imgur.com/3GmZnZq.gif)  
- **红色节点**：当前被取出的最小值  
- **绿色箭头**：x值递增操作  
- **堆结构**：动态展示节点交换过程，伴随8-bit音效

### 复古游戏化设计
- **像素风格**：16色模式，函数表示为不同颜色的小方块  
- **音效设计**：  
  - 取出堆顶：短促"哔"声（500Hz方波）  
  - 插入新值："嘟"声（200Hz三角波）  
- **自动演示**：按空格键切换手动/自动模式，AI自动运行算法  
- **积分系统**：正确取出最小值+10分，连击倍率递增

---
处理用时：64.63秒
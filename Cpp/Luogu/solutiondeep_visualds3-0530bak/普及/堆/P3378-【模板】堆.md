# 题目信息

# 【模板】堆

## 题目描述

给定一个数列，初始为空，请支持下面三种操作：

1. 给定一个整数 $x$，请将 $x$ 加入到数列中。
2. 输出数列中最小的数。
3. 删除数列中最小的数（如果有多个数最小，只删除 $1$ 个）。




## 说明/提示

**【数据规模与约定】**
- 对于 $30\%$ 的数据，保证 $n \leq 15$。
- 对于 $70\%$ 的数据，保证 $n \leq 10^4$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^6$，$1 \leq x \lt 2^{31}$，$op \in \{1, 2, 3\}$。

## 样例 #1

### 输入

```
5
1 2
1 5
2
3
2
```

### 输出

```
2
5```

# AI分析结果



# 【模板】堆 - 算法分析与题解总结

## 唯一算法分类：堆（优先队列）

---

## 综合分析与结论

### 核心算法流程
1. **数据结构选择**：所有题解均使用小根堆，父节点值小于等于子节点值  
2. **插入操作**：新元素加入堆底，通过上浮操作（与父节点比较）调整至合适位置  
3. **删除操作**：交换堆顶与堆底元素，通过下沉操作（与更小的子节点比较）维护堆性质  
4. **查询操作**：直接访问堆顶元素（数组索引1或优先队列的top()）  

### 可视化设计要点
1. **像素化堆结构**：用不同颜色表示堆顶（红色）、当前操作节点（黄色）、父子节点（蓝色）  
2. **动画分层**：插入时展示元素上浮路径，删除时展示堆顶下沉路径  
3. **音效触发**：插入完成时播放"滴"声，节点交换时播放"咔嗒"声，操作完成时播放8-bit胜利音效  
4. **自动演示模式**：按固定速度执行操作步骤，允许暂停/步进观察堆结构变化  

---

## 题解评分与亮点（≥4星）

### 1. henry_y（⭐⭐⭐⭐⭐）
**核心亮点**：  
- 最完整的堆原理图解（插入/删除的完全二叉树变化过程）  
- 同时提供手写堆与STL实现，附带重载运算符高阶技巧  
- 包含堆排序、双堆维护中位数等拓展应用场景  

### 2. 封禁用户（⭐⭐⭐⭐）  
**核心亮点**：  
- 手写堆代码结构清晰，包含完整的向上/向下调整注释  
- 用FC游戏风格比喻堆操作（"世袭制"等趣味描述）  
- 独立章节讲解优先队列模板参数原理  

### 3. yzm0325（⭐⭐⭐⭐）  
**核心亮点**：  
- 动态GIF展示插入/删除过程（3张关键状态图）  
- 提供模板化堆类实现，支持任意数据类型  
- 对比手写堆与STL的性能差异及适用场景  

---

## 最优思路与技巧提炼

### 关键实现技巧
```cpp
// 手写堆核心代码片段
void up(int pos) { // 插入时的上浮操作
    while(pos>1 && heap[pos]<heap[pos/2]) 
        swap(heap[pos], heap[pos/2]), pos/=2;
}

void down(int pos) { // 删除时的下沉操作
    while(1) {
        int child = pos*2;
        if(child+1<=size && heap[child+1]<heap[child]) child++;
        if(child>size || heap[pos]<=heap[child]) break;
        swap(heap[pos], heap[child]), pos=child;
    }
}
```

### STL最佳实践
```cpp
priority_queue<int, vector<int>, greater<int>> q; // 正确定义小根堆
// 错误示例：priority_queue<int> q（默认为大根堆）
```

### 思维突破点
- **完全二叉树数组化**：利用 `父节点i → 子节点2i/2i+1` 特性，避免指针操作  
- **尾部交换技巧**：删除时先交换堆顶与堆底，保持完全二叉树性质  

---

## 同类题目推荐
1. **P1090 合并果子**（基础堆贪心）  
2. **P1168 中位数**（双堆维护动态中位数）  
3. **P1801 黑匣子**（堆与查询第k小结合）

---

## 可视化代码片段（Canvas动画）
```javascript
// 堆插入动画核心逻辑（伪代码）
function animateInsert(val) {
  let node = createNode(val); // 创建新节点
  node.y = canvas.height;    // 初始位置在底部
  let targetIdx = heap.size + 1;
  while(targetIdx > 1) {
    let parentIdx = Math.floor(targetIdx/2);
    highlight(parentIdx, 'blue');       // 高亮父节点
    if(heap[targetIdx] >= heap[parentIdx]) break;
    swapNodes(targetIdx, parentIdx);    // 交换动画
    targetIdx = parentIdx;
  }
  playSound('up_effect.wav');          // 上浮完成音效
}
```

---

## 高频踩坑点
1. **数组越界**：未检查 `child+1<=size` 导致访问无效内存  
2. **STL模板错误**：误用默认优先队列（大根堆）导致结果错误  
3. **堆大小更新时机**：删除操作时先 `size--` 再调整，引发下标错乱  

---

## 个人心得摘录
> "调试时发现删除操作后堆顶未正确下沉，原来是忘记处理只有左子节点的情况。画图分析后，补充了 `child+1<=size` 的条件判断，问题迎刃而解。" —— yzm0325  
> "最初认为手写堆比STL快，实际测试发现O2优化下STL反而更快，优先队列的底层优化确实精妙" —— henry_y

---

## 8-bit风格控制面板（HTML/CSS）
```html
<div id="control-panel" style="font-family: 'Retro'; background: #2d2d2d;">
  <button onclick="pause()">⏸</button>
  <button onclick="step()">▶️ STEP</button>
  <input type="range" id="speed" min="1" max="5" value="3">
</div>
<style>
@font-face { 
  font-family: 'Retro'; 
  src: url('nes-font.woff')  // 使用FC游戏字体
}
</style>
```

---
处理用时：78.33秒
# 题目信息

# [蓝桥杯 2021 省 AB2] 负载均衡

## 题目描述

有 $n$ 台计算机，第 $i$ 台计算机的运算能力为 $v_{i}$ 。

有一系列的任务被指派到各个计算机上，第 $i$ 个任务在 $a_{i}$ 时刻分配，指定计算机编号为 $b_{i}$, 耗时为 $c_{i}$ 且算力消耗为 $d_{i}$。如果此任务成功分配，将立刻开始运行, 期间持续占用 $b_{i}$ 号计算机 $d_{i}$ 的算力, 持续 $c_{i}$ 秒。

对于每次任务分配，如果计算机剩余的运算能力不足则输出 $-1$，并取消这次分配，否则输出分配完这个任务后这台计算机的剩余运算能力。

## 说明/提示

**【样例说明】**

时刻 $1$，第 $1$ 个任务被分配到第 $1$ 台计算机，耗时为 $5$，这个任务时刻 $6$ 会结束, 占用计算机 $1$ 的算力 $3$。

时刻 $2$，第 $2$ 个任务需要的算力不足，所以分配失败了。

时刻 $3$，第 $1$ 个计算机仍然正在计算第 $1$ 个任务，剩余算力不足 $3$，所以失败。

时刻 $4$，第 $1$ 个计算机仍然正在计算第 $1$ 个任务，但剩余算力足够，分配后剩余算力 $1$。

时刻 $5$，第 $1$ 个计算机仍然正在计算第 $1$，$4$ 个任务，剩余算力不足 $4$，失败。

时刻 $6$，第 $1$ 个计算机仍然正在计算第 $4$ 个任务，剩余算力足够，且恰好用完。

**【评测用例规模与约定】**

对于 $20 \%$ 的评测用例, $n, m \leq 200$。

对于 $40 \%$ 的评测用例, $n, m \leq 2000$。

对于所有评测用例, $1 \leq n, m \leq 2\times 10^5,1 \leq a_{i}, c_{i}, d_{i}, v_{i} \leq 10^{9}, 1 \leq b_{i} \leq n$。 

蓝桥杯 2021 第二轮省赛 A 组 H 题（B 组 I 题）。

## 样例 #1

### 输入

```
2 6
5 5
1 1 5 3
2 2 2 6
3 1 2 3
4 1 6 1
5 1 3 3
6 1 3 4```

### 输出

```
2
-1
-1
1
-1
0```

# AI分析结果



### 唯一算法分类
**堆/优先队列**

---

### 题解思路与核心难点解析
#### 核心算法流程
1. **数据结构设计**：为每台计算机维护一个小根堆，存储 `(任务结束时间, 占用算力)` 的键值对。
2. **任务处理步骤**：
   - 当新任务到达时，弹出堆中所有结束时间 ≤ 当前时间的任务，恢复其占用的算力。
   - 检查当前算力是否足够分配新任务：
     - 若不足，输出 `-1`；
     - 若足够，扣除算力并将新任务压入堆。

#### 解决难点
- **动态算力回收**：必须精确回收已结束任务的算力，堆的弹出顺序保证了时间线性递增。
- **高效时间管理**：堆的 `O(1)` 取顶和 `O(log n)` 插入特性，完美适配动态任务调度。

---

### 题解评分（≥4星）
#### ⭐⭐⭐⭐ xwh_hh
- **亮点**：代码简洁，注释明确，使用 `pair` 结构提升可读性。
- **优化点**：直接操作 `priority_queue` 原生容器，避免冗余封装。

#### ⭐⭐⭐⭐ gengchenghao
- **亮点**：结构体 `node` 自定义比较逻辑，代码风格统一。
- **优化点**：全局变量命名清晰，适合快速理解。

#### ⭐⭐⭐⭐ 封禁用户（第二个题解）
- **亮点**：独立设计 `Computer` 结构体，分离时间与算力逻辑。
- **优化点**：模块化代码结构，便于调试扩展。

---

### 最优思路与技巧提炼
#### 关键实现思想
```cpp
// 核心代码片段（xwh_hh）
while (!pq[b].empty() && pq[b].top().first <= a) { // 弹旧任务
    h[b] += pq[b].top().second;
    pq[b].pop();
}
if (h[b] < d) cout << -1 << endl; // 算力检查
else {
    h[b] -= d;
    pq[b].push({a + c, d}); // 压新任务
    cout << h[b] << endl;
}
```

#### 技巧总结
- **堆的批量弹出**：通过 `while` 循环一次性处理所有过期任务。
- **算力动态更新**：在弹出时累加算力，分配时实时扣除，保证状态一致。

---

### 同类题目与算法套路
#### 类似算法场景
- **会议室预订 II**（LeetCode 253）：按结束时间维护堆，统计最大并行会议。
- **定时任务调度**：需按截止时间动态调整执行队列。

#### 洛谷推荐题目
1. **P1801 黑匣子**（堆的动态维护）
2. **P2085 最小函数值**（多路归并与堆结合）
3. **P1631 序列合并**（双堆优化）

---

### 可视化与算法演示设计
#### 动画方案
- **颜色标记**：
  - 🔴 当前处理任务  
  - 🟢 已释放算力的旧任务  
  - 🔵 正在运行的任务堆
- **步进控制**：
  - 单步展示任务到达→弹旧任务→算力检查→结果输出。
  - 支持拖拽进度条回看任意时刻状态。

#### 复古像素化风格
- **Canvas 绘制**：
  - 计算机用 8x8 像素块表示，颜色深浅对应剩余算力。
  - 任务堆以垂直列表展示，结束时间用顶部数字飘动效果。
- **音效设计**：
  - 成功分配：8-bit 上升音阶（类似《超级玛丽》吃金币）。
  - 分配失败：短促“哔”声（红白机经典错误音效）。

---

### 代码实现（xwh_hh 完整版）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> P;
int n,m,h[200005];
priority_queue<P,vector<P>,greater<P>> pq[200005];

int main() {
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>h[i];
    while(m--){
        int a,b,c,d;
        cin>>a>>b>>c>>d;
        while(!pq[b].empty() && pq[b].top().first<=a){
            h[b] += pq[b].top().second;
            pq[b].pop();
        }
        if(h[b]<d) cout<<-1<<endl;
        else{
            h[b] -= d;
            pq[b].push({a+c,d});
            cout<<h[b]<<endl;
        }
    } 
    return 0;
}
```

---

### 调试心得摘录
> "**优先队列的比较运算符方向极易写反**，调试时发现任务弹出顺序错误，最后意识到 `greater<P>` 才是小根堆的关键。" —— xwh_hh  
> "初始未考虑算力恢复的累加顺序，导致部分测试点WA，后来通过绘制时间轴图验证逻辑。" —— lupengheyyds

---

### 交互式学习建议
- **算法比较模式**：并排展示暴力法（40分）与堆解法，用红色高亮暴力法的超时操作。
- **自动演示AI**：模拟任务流自动生成，可调节任务密集度观察堆的动态响应。

---
处理用时：81.33秒
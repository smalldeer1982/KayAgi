# 题目信息

# 于是他错误的点名开始了

## 题目背景

XS中学化学竞赛组教练是一个酷爱炉石的人。

他会一边搓炉石一边点名以至于有一天他连续点到了某个同学两次，然后正好被路过的校长发现了然后就是一顿欧拉欧拉欧拉（详情请见已结束比赛 CON900）。

## 题目描述

这之后校长任命你为特派探员，每天记录他的点名。校长会提供化学竞赛学生的人数和名单，而你需要告诉校长他有没有点错名。（为什么不直接不让他玩炉石。）

## 说明/提示

- 对于 $40\%$ 的数据，$n\le 1000$，$m\le 2000$。
- 对于 $70\%$ 的数据，$n\le 10^4$，$m\le 2\times 10^4$。
- 对于 $100\%$ 的数据，$n\le 10^4$，$m≤10^5$。

---

$\text{upd 2022.7.30}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
5  
a
b
c
ad
acd
3
a
a
e
```

### 输出

```
OK
REPEAT
WRONG
```

# AI分析结果



### 算法分类
**字典树（Trie）与哈希映射**

---

### 题解思路与核心难点分析

#### 核心问题
快速判断字符串是否存在、是否重复访问。需满足以下操作：
- **存在性检测**：O(1) ~ O(L) 时间复杂度（L为字符串长度）
- **重复性标记**：快速状态更新

#### 题解对比要点
1. **暴力解法**  
   - **问题**：O(n·m) 时间复杂度过高，无法通过大数据
   - **优化尝试**：预排序后二分查找（O(n log n + m log n)）仍可能超时

2. **哈希映射（map）**  
   - **核心**：STL `map<string, int>` 存储状态（0=未存在，1=存在未访问，2=已访问）
   - **优势**：代码简洁（10行核心逻辑），适合快速实现
   - **劣势**：字符串比较依赖哈希函数性能，内存占用较高

3. **字典树（Trie）**  
   - **核心**：树形结构存储字符路径，终结点标记存在性和访问状态
   - **优势**：O(L) 查询时间，内存紧凑，适合长字符串或公共前缀多的场景
   - **难点**：动态节点管理、状态标记逻辑

4. **多哈希函数**  
   - **核心**：多个质数模哈希减少碰撞概率
   - **优势**：极快查询速度（接近O(1)）
   - **劣势**：需处理哈希冲突，调试复杂

---

### 题解评分（≥4星）

1. **花千树的 map 解法（4.5星）**  
   - **亮点**：代码极简，逻辑清晰，适合快速实现  
   - **代码片段**：  
     ```cpp
     map<string, int> a;
     while(n--) { cin >> s; a[s] = 1; }
     while(m--) {
         cin >> s;
         if(a[s] == 1) { cout << "OK\n"; a[s] = 2; }
         else if(a[s] == 2) cout << "REPEAT\n";
         else cout << "WRONG\n";
     }
     ```

2. **ZJH365 的字典树解法（5星）**  
   - **亮点**：完整 Trie 实现，附带详细注释与状态管理  
   - **核心逻辑**：  
     ```cpp
     struct TrieNode { int cnt; int son[26]; bool is_end; };
     void insert(char *s) {
         int u = 0;
         for (int i=0; s[i]; i++) {
             int c = s[i]-'a';
             if (!trie[u].son[c]) trie[u].son[c] = ++tot;
             u = trie[u].son[c];
         }
         trie[u].is_end = true;
     }
     ```

3. **Burnside 的多哈希解法（4星）**  
   - **亮点**：三重哈希减少碰撞，实用性强  
   - **代码关键**：  
     ```cpp
     int hash1 = (k*base1 + s[i]) % MOD1;
     int hash2 = (k*base2 + s[i]) % MOD2;
     if (all_hash[hash1] && all_hash[hash2]) ...
     ```

---

### 最优思路提炼

1. **哈希映射快速实现**  
   - **适用场景**：中小规模数据，代码简洁优先  
   - **关键步骤**：  
     - 插入时标记存在性（`map[s] = 1`）  
     - 查询时判断状态转移（1→2→REPEAT）

2. **字典树高效处理**  
   - **适用场景**：大规模数据或字符串存在公共前缀  
   - **核心技巧**：  
     - 动态构建字符路径，终结点双重标记（存在性 + 访问状态）
     - 内存预分配优化（静态数组替代动态指针）

---

### 相似题目推荐

1. **P2922 秘密消息**  
   - **关联点**：Trie 树统计前缀出现次数

2. **P4551 最长异或路径**  
   - **关联点**：Trie 用于位运算路径存储

3. **P8306 字典树应用**  
   - **关联点**：直接考察 Trie 实现与查询

---

### 可视化设计（Trie 树构建）

**动画方案**：  
1. **节点展开**：逐字符插入时，新节点以绿色高亮显示，边标注字符  
2. **状态标记**：终结点变为金色（存在）→ 红色（已访问）  
3. **查询路径**：当前路径以蓝色高亮，未找到时路径闪烁红色  

**交互功能**：  
- **步进控制**：暂停/继续/单步，调节动画速度  
- **模式切换**：对比哈希映射与 Trie 的查询路径差异  

**复古像素风格**：  
- **节点绘制**：8-bit 风格矩形节点，字符显示为像素字体  
- **音效**：插入成功（8-bit 上升音阶），重复访问（低沉蜂鸣）  

---

### 核心代码实现（Trie 树）

```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int MAXN = 500010;
struct Node {
    int son[26];
    bool is_end, visited;
} trie[MAXN];
int tot = 0;

void insert(char *s) {
    int u = 0;
    for (int i = 0; s[i]; i++) {
        int c = s[i] - 'a';
        if (!trie[u].son[c]) 
            trie[u].son[c] = ++tot;
        u = trie[u].son[c];
    }
    trie[u].is_end = true;
}

int query(char *s) {
    int u = 0;
    for (int i = 0; s[i]; i++) {
        int c = s[i] - 'a';
        if (!trie[u].son[c]) return 0; // WRONG
        u = trie[u].son[c];
    }
    if (!trie[u].is_end) return 0;     // WRONG
    if (trie[u].visited) return 2;     // REPEAT
    trie[u].visited = true;
    return 1;                          // OK
}

int main() {
    int n, m; char s[51];
    cin >> n;
    while (n--) { cin >> s; insert(s); }
    cin >> m;
    while (m--) {
        cin >> s;
        int res = query(s);
        cout << (res == 0 ? "WRONG" : res == 1 ? "OK" : "REPEAT") << endl;
    }
    return 0;
}
```

---
处理用时：86.63秒
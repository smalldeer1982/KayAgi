# 题目信息

# 【模板】字典树

## 题目描述

给定 $n$ 个模式串 $s_1, s_2, \dots, s_n$ 和 $q$ 次询问，每次询问给定一个文本串 $t_i$，请回答 $s_1 \sim s_n$ 中有多少个字符串 $s_j$ 满足 $t_i$ 是 $s_j$ 的**前缀**。

一个字符串 $t$ 是 $s$ 的前缀当且仅当从 $s$ 的末尾删去若干个（可以为 0 个）连续的字符后与 $t$ 相同。

输入的字符串大小敏感。例如，字符串 `Fusu` 和字符串 `fusu` 不同。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq T, n, q\leq 10^5$，且输入字符串的总长度不超过 $3 \times 10^6$。输入的字符串只含大小写字母和数字，且不含空串。

### 说明
std 的 IO 使用的是关闭同步后的 cin/cout，本题不卡常。

## 样例 #1

### 输入

```
3
3 3
fusufusu
fusu
anguei
fusu
anguei
kkksc
5 2
fusu
Fusu
AFakeFusu
afakefusu
fusuisnotfake
Fusu
fusu
1 1
998244353
9```

### 输出

```
2
1
0
1
2
1```

# AI分析结果



**唯一算法分类**：字典树

---

### **综合分析与结论**

**题目核心**：统计模式串中以每个查询串为前缀的数量。  
**关键思路**：利用字典树存储所有模式串的前缀信息，插入时维护路径节点的计数，查询时直接获取终止节点的计数值。

**核心难点**：  
1. **字符集处理**：需将大小写字母及数字映射到连续的索引（0-61）。  
2. **高效初始化**：每个测试用例后需快速重置字典树，避免超时。  
3. **空间优化**：预分配数组可能导致内存浪费，动态结构（如哈希表）可能增加查询时间。

**题解对比**：  
- **qip101**：数组存储子节点，插入时维护路径计数，查询O(1)。存在初始化范围错误，但思路最优。  
- **一扶苏一**：哈希表动态存储，DFS预处理子树和。空间优但时间常数高，且存在内存泄漏。  
- **npqenqpve**：类似qip101，但初始化效率低，字符映射可能冗余。

**最优技巧**：在插入时逐节点累加计数，查询直接取终止节点值，避免预处理，时间复杂度O(L)最优。

---

### **题解清单 (≥4星)**

1. **qip101 (⭐⭐⭐⭐⭐)**  
   - **亮点**：数组实现查询极快，代码结构清晰。  
   - **改进点**：修正初始化循环范围（j应到61而非122）。

2. **npqenqpve (⭐⭐⭐⭐)**  
   - **亮点**：正确字符映射，逻辑类似标准Trie。  
   - **缺点**：初始化效率低，需优化循环范围。

---

### **核心代码实现**

**修正后的 qip101 题解代码**：  
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,q,n,t[3000005][62],cnt[3000005],idx; // 修正数组大小为62
char s[3000005];

int getnum(char x){
    if(x>='A'&&x<='Z') return x-'A';
    else if(x>='a'&&x<='z') return x-'a'+26;
    else return x-'0'+52;
}

void insert(char str[]){
    int p=0, len=strlen(str);
    for(int i=0;i<len;i++){
        int c=getnum(str[i]);
        if(!t[p][c]) t[p][c]=++idx;
        p=t[p][c];
        cnt[p]++;
    }
}

int find(char str[]){
    int p=0, len=strlen(str);
    for(int i=0;i<len;i++){
        int c=getnum(str[i]);
        if(!t[p][c]) return 0;
        p=t[p][c];
    }
    return cnt[p];
}

int main(){
    scanf("%d",&T);
    while(T--){
        // 仅重置已用节点
        for(int i=0;i<=idx;i++){
            memset(t[i],0,sizeof(int)*62); // 仅处理62个字符
            cnt[i]=0;
        }
        idx=0;
        scanf("%d%d",&n,&q);
        for(int i=1;i<=n;i++){
            scanf("%s",s);
            insert(s);
        }
        for(int i=1;i<=q;i++){
            scanf("%s",s);
            printf("%d\n",find(s));
        }
    }
    return 0;
}
```

**核心逻辑**：  
- **插入**：逐字符创建节点，路径上所有节点的计数器自增。  
- **查询**：沿路径查找，若路径存在则返回终止节点计数值。

---

### **同类型题推荐**

1. **P2580 于是他错误的点名开始了**（字典树基础应用）  
2. **P2922 Secret Message**（统计前缀与包含关系）  
3. **P4551 最长异或路径**（Trie处理异或路径）

---

### **可视化设计**

**动画方案**：  
- **节点动态构建**：以像素方块表示节点，插入时字符逐个显示，路径边实时绘制。  
- **颜色标记**：当前处理字符高亮为红色，路径边渐变显示，计数器数值浮动更新。  
- **步进控制**：支持暂停/继续，调整动画速度观察细节。

**复古像素风格**：  
- **8位音效**：插入成功播放“滴”声，查询失败播放“哔”声。  
- **Canvas绘制**：节点按层分布，字符以像素字体显示，背景循环8-bit音乐。

**交互面板**：  
- 速度滑块、暂停/继续按钮、单步执行。  
- 测试用例选择下拉菜单，自动演示模式开关。

---

**总结**：字典树通过空间换时间高效处理前缀问题，注意初始化优化与字符映射的正确性。

---
处理用时：198.52秒
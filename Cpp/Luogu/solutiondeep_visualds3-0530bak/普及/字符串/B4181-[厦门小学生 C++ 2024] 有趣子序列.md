# 题目信息

# [厦门小学生 C++ 2024] 有趣子序列

## 题目背景

本试题为 2024 年厦门市小学生 C++ 语言**复赛**试题，数据为洛谷自造。

**初赛**为笔试。

## 题目描述

小唐最近在研究一个长为 $n$ 的 $01$ 字符串 $S$（下标从 $1$ 开始）。

他很喜欢其子区间和子序列，例如：如下表的 $01$ 字符串 $S = \tt{01011010}$。

| $S_1$ | $S_2$ | $S_3$ | $S_4$ | $S_5$ | $S_6$ | $S_7$ | $S_8$ |
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
| $0$   | $1$   | $0$   | $1$   | $1$   | $0$   | $1$   | $0$   |

- 子区间 $[2,4]$ 即为：$S_2, S_3, S_4$ 这样一个在原 $S$ 串中连续的一段序列；
- 子序列即类如：$S_2, S_4, S_6, S_7$ 这样一个按原 $S$ 串顺序的，可连续、可不连续的序列。

所以，子区间肯定是子序列，但子序列不一定是子区间。

小唐会询问你 $Q$ 次，每次询问给出一个 $S$ 的子区间 $[l,r]$，他想知道是否存在 $S$ 的一个“有趣子序列”，其满足：

1. “有趣子序列”和询问的子区间 $[l,r]$ 相同；   
例：如果询问的子区间是 $[2,4]$，其中，子序列 $S_2, S_6, S_7$ 和询问的子区间 $S_2, S_3, S_4$ 中的字符按顺序一一对应相同;

2. “有趣子序列”不是从 $S$ 中选出的一段子区间。    
例：子序列 $S_2, S_6, S_7$ 并不是原 $S$ 串中连续的一段序列，即不是原 $S$ 串的一段子区间。

请对于每次询问 $[l,r]$，输出 $\tt{Yes}$ 或 $\tt{No}$，分别表示存在或不存在这样的 “有趣子序列”。

## 说明/提示

### 样例解释 1

- 对于第一组数据，可以选择的子序列下标依次为：不存在，$(1,2,4)$，$(3,4,6)$。
- 对于第二组数据，可以选择的子序列下标依次为：不存在，$(1,3)$。

### 数据范围

对于所有数据，满足 $1 \leq n \leq 1 \times 10^5$，$1 \leq q \leq 1 \times 10^5$，$1 \leq l\ {\color{red}\leq}\ r \leq n$。

| 数据点编号 | $T\leq$ | $n\leq$ | $q\leq$ | 特殊性质 |
|:------------:|:----:|:----:|:----:|:----------:|
| $1$          | $100$ | $4$  | $1$  |          |
| $2$          | $100$ | $10$ | $10$ |          |
| $3$          | $10$ | $12$ | $100$ |          |
| $4$          | $10$ | $100$ | $100$ |          |
| $5, 6$       | $10$ | $1000$ | $1000$ |          |
| $7$          | $5$  | $1 \times 10^5$| $1 \times 10^5$| $l=1$       |
| $8, 9, 10$   | $5$  | $1 \times 10^5$| $1 \times 10^5$|          |

特殊性质：$l=1$ 表示子区间左边界为 $1$。

## 样例 #1

### 输入

```
2
6 3
011100
2 4
1 3
3 5
5 2
11111
1 5
2 3```

### 输出

```
No
Yes
Yes
No
Yes```

# AI分析结果



## 算法分类
字符串处理、预处理

---

## 核心思路与难点分析
**题目要求**：对于给定的01字符串的某个子区间，判断是否存在一个子序列与其字符顺序相同，但不是连续的子区间。

### 关键条件推导
1. **长度判断**：若子区间长度为1，显然无法构造非连续子序列，直接返回"No"。
2. **左边界扩展**：若子区间的第一个字符在原字符串的左侧存在相同字符，则可用该字符作为起点构造满足条件的子序列。
3. **右边界扩展**：若子区间的最后一个字符在原字符串的右侧存在相同字符，则可用该字符作为终点构造满足条件的子序列。
4. **核心条件**：只要满足左边界或右边界扩展条件之一，即可构造满足条件的子序列。

### 预处理优化
- **Left数组**：记录每个位置左侧是否存在相同字符。
- **Right数组**：记录每个位置右侧是否存在相同字符。
- **查询优化**：预处理后，每个查询只需O(1)时间判断条件。

---

## 最优题解思路
### 预处理与查询逻辑
1. **预处理Left数组**：从左到右遍历，记录每个字符是否出现过。
2. **预处理Right数组**：从右到左遍历，记录每个字符是否出现过。
3. **查询处理**：对每个查询检查左边界和右边界的条件。

### 代码实现
```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        int n, q;
        string s;
        cin >> n >> q >> s;
        vector<bool> left(n + 1, false);
        vector<bool> right(n + 1, false);
        unordered_set<char> seen_left;
        for (int i = 1; i <= n; ++i) {
            char c = s[i - 1];
            if (seen_left.count(c)) {
                left[i] = true;
            }
            seen_left.insert(c);
        }
        unordered_set<char> seen_right;
        for (int i = n; i >= 1; --i) {
            char c = s[i - 1];
            if (seen_right.count(c)) {
                right[i] = true;
            }
            seen_right.insert(c);
        }
        while (q--) {
            int l, r;
            cin >> l >> r;
            if (l == r) {
                cout << "No\n";
            } else {
                if (left[l] || right[r]) {
                    cout << "Yes\n";
                } else {
                    cout << "No\n";
                }
            }
        }
    }
    return 0;
}
```

---

## 算法可视化
### 核心变量与步骤
1. **预处理阶段**：
   - `Left数组`：绿色标记表示该位置左侧存在相同字符。
   - `Right数组`：蓝色标记表示该位置右侧存在相同字符。
2. **查询阶段**：
   - 高亮查询的左右边界，检查对应的Left/Right标记。

### 复古像素风格演示
- **Canvas网格**：每个字符显示为像素块，左/右侧标记用不同颜色闪烁。
- **音效**：查询结果为Yes时播放上升音调，No时播放低沉音效。
- **动画控制**：支持单步执行观察预处理过程，自动播放查询结果。

---

## 相似题目推荐
1. **洛谷 P2141** - 珠心算测验（预处理优化）
2. **洛谷 P1102** - A-B数对（哈希表应用）
3. **洛谷 P3405** - 省市哈希（字符串预处理）

---
处理用时：365.19秒
# 题目信息

# 教辅的组成

## 题目背景

滚粗了的 HansBug 在收拾旧语文书，然而他发现了什么奇妙的东西。


## 题目描述

蒟蒻 HansBug 在一本语文书里面发现了一本答案，然而他却明明记得这书应该还包含一份练习题。然而出现在他眼前的书多得数不胜数，其中有书，有答案，有练习册。已知一个完整的书册均应该包含且仅包含一本书、一本练习册和一份答案，然而现在全都乱做了一团。许多书上面的字迹都已经模糊了，然而 HansBug 还是可以大致判断这是一本书还是练习册或答案，并且能够大致知道一本书和答案以及一本书和练习册的对应关系（即仅仅知道某书和某答案、某书和某练习册有可能相对应，除此以外的均不可能对应）。既然如此，HansBug 想知道在这样的情况下，最多可能同时组合成多少个完整的书册。



## 说明/提示

样例说明：

如题，$N_1=5$，$N_2=3$，$N_3=4$，表示书有 $5$ 本、练习册有 $3$ 本、答案有 $4$ 本。

$M_1=5$，表示书和练习册共有 $5$ 个可能的对应关系，分别为：书 $4$ 和练习册 $3$ 、书 $2$ 和练习册 $2$ 、书 $5$ 和练习册 $2$ 、书 $5$ 和练习册 $1$ 以及书 $5$ 和练习册 $3$。

$M_2=5$，表示数和答案共有 $5$ 个可能的对应关系，分别为：书 $1$ 和答案 $3$、书 $3$ 和答案 $1$、书 $2$ 和答案 $2$、书 $3$ 和答案 $3$ 以及书 $4$ 和答案 $3$。

所以，以上情况的话最多可以同时配成两个书册，分别为：书 $2$ 练习册 $2$ 答案 $2$、书 $4$ 练习册 $3$ 答案 $3$。


数据规模：

![](https://cdn.luogu.com.cn/upload/image_hosting/srj2v9um.png)

对于数据点 $1,2,3$，$1\le M_1,M_2\leq 20$。

对于数据点 $4\sim 10$，$1\le M_1,M_2 \leq 20000$。


## 样例 #1

### 输入

```
5 3 4
5
4 3
2 2
5 2
5 1
5 3
5
1 3
3 1
2 2
3 3
4 3
```

### 输出

```
2```

# AI分析结果



**唯一算法分类**  
网络流-最大流（拆点法）

---

### 核心思路与解决难点

#### 算法要点
1. **拆点法**：将每个书节点拆分为输入点（左）和输出点（右），中间连一条容量为1的边，保证每本书仅使用一次。
2. **网络流建模**：
   - 源点 → 练习册 → 书左点 → 书右点 → 答案 → 汇点
   - 所有边的容量为1（拆点边限制书的使用次数）
3. **Dinic算法优化**：使用当前弧优化加速分层图遍历。

#### 解决难点
- **重复使用问题**：若不拆点，书可能被多次匹配。拆点后，通过中间边流量限制，确保每本书仅贡献一次匹配。
- **大规模数据**：题解普遍采用Dinic算法，时间复杂度为O(n²m)，结合当前弧优化通过20000级数据。

---

### 最优思路与技巧提炼

1. **拆点技巧**：
   - 每个书节点拆为两个点（如`book_in`和`book_out`），连边容量为1。
   - 练习册与`book_in`连接，`book_out`与答案连接。
2. **网络流结构**：
   ```plaintext
   源点 → 练习册 → book_in → book_out → 答案 → 汇点
   ```
3. **Dinic优化**：
   - BFS构建分层图，DFS多路增广。
   - 当前弧优化避免重复访问无效边。

---

### 题解评分（≥4星）

1. **Siyuan（5星）**  
   - 思路清晰，图示拆点必要性，代码结构简洁。
   - 使用Dinic+当前弧优化，高效处理大数据。
   - 关键代码：书拆点逻辑明确，边容量设置合理。

2. **localhost（4星）**  
   - 图解网络流结构，代码注释详细。
   - 拆点实现直观，但缺少当前弧优化。

3. **ViXpop（4星）**  
   - 结构体管理边，代码可读性强。
   - 实现拆点与分层图遍历，适合学习基础实现。

---

### 核心代码实现

```cpp
// 拆点关键代码（Siyuan题解）
for(int i=1;i<=n1;++i) addedge(id(2,i),id(3,i),1);

// Dinic算法（当前弧优化）
int dfs(int u,int t,int flow) {
    if(u==t) return flow;
    int ans=0;
    for(int& i=cur[u];i;i=nxt[i]) {
        int v=ter[i];
        if(val[i] && dep[v]==dep[u]+1) {
            int x=dfs(v,t,min(val[i],flow-ans));
            if(x) val[i]-=x, val[i^1]+=x, ans+=x;
        }
        if(ans==flow) break;
    }
    return ans;
}
```

---

### 同类型题与推荐题目

1. **同类型题思路**  
   - 节点容量限制问题（拆点法）。
   - 多级匹配问题（如P1402酒店之王）。

2. **推荐题目**  
   - P1402 酒店之王（三分图匹配+拆点）
   - P3254 圆桌问题（节点容量限制）
   - P2763 试题库问题（多条件匹配）

---

### 可视化设计

**动画演示方案**  
1. **像素风格**：  
   - 节点：8-bit方块（练习册蓝色，书绿色拆分为双块，答案黄色，汇点红色）。  
   - 边：箭头表示流向，流量用像素条填充。拆点边高亮为红色。  
2. **关键操作演示**：  
   - 增广路径发现时，路径闪烁，播放“滴”音效。  
   - 拆点边流量减为0时，显示锁定图标。  
3. **交互功能**：  
   - 速度调节滑块控制BFS/DFS速度。  
   - 点击单步执行观察分层图构建。  

**复古音效**（Web Audio API）：  
- 增广成功：8-bit上升音阶。  
- 流量更新：短促“哔”声。  
- 背景音乐：芯片风格循环曲。

---

### 个人心得摘录

> "Debug时发现拆点边未正确连接，导致WA。拆点必须确保所有流量经过限制边。" —— Siyuan  
> "当前弧优化让Dinic在2e4边下从TLE到AC，优化至关重要。" —— Drinkwater  

---

### 总结

通过拆点法将节点容量问题转化为边容量，结合Dinic算法高效求解最大流。实现时需注意拆点逻辑与当前弧优化，确保处理大规模数据效率。

---
处理用时：68.19秒
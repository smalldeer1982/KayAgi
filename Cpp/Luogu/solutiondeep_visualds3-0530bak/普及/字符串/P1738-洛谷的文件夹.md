# 题目信息

# 洛谷的文件夹

## 题目描述

kkksc03 是个非凡的空想家！在短时间内他设想了大量网页，然后总是交给可怜的 lzn 去实现。

洛谷的网页端，有很多文件夹，文件夹还套着文件夹。

例如：$\verb!/luogu/application/controller!$ 表示根目录下有一个名称为 $\verb!luogu!$ 的文件夹，这个文件夹下有一个名称 $\verb!application!$ 的文件夹，其中还有名为 $\verb!controller!$ 的文件夹。

每个路径的第 $1$ 个字符总是 $\verb!/!$，且没有两个连续的 $\verb!/!$，最后的字符不是 $\verb!/!$。所有名称仅包含数字和小写字母。

目前根目录是空的。kkksc03 想好了很多应该有的文件夹路径名。问题是，需要是使这些文件夹都存在，需要新建几个文件夹呢？


## 说明/提示

### 数据范围及约定


- 对于 $20\%$ 数据，有 $N \le 20$；
- 对于 $50\%$ 数据，有 $N \le 200$；
- 另有 $30\%$ 数据，有对于所有路径最多存在两个 $\verb!/!$（包含第 $1$ 个字符）；
- 对于所有数据，$N \le 1000$。

## 样例 #1

### 输入

```
2
/luogu/application/controller
/luogu/application/view
```

### 输出

```
3
4
```

## 样例 #2

### 输入

```
3
/chicken
/chicken/egg
/chicken```

### 输出

```
1
2
2```

## 样例 #3

### 输入

```
4
/a
/a/b
/a/c
/b/b```

### 输出

```
1
2
3
5```

# AI分析结果



### 算法分类
**字典树（Trie）与集合（Set）应用**

---

### 题解思路与核心难点分析
1. **核心逻辑**  
   - **路径分解**：将每个路径按 `/` 分割为层级结构（如 `/a/b/c` 分解为 `/a`, `/a/b`, `/a/b/c`）。  
   - **去重存储**：通过集合或字典树记录所有已存在的路径，避免重复计数。  
   - **动态更新**：每输入一个路径，统计新增的文件夹数量。

2. **解决难点对比**  
   - **集合（Set）方案**（Anguei、FutureThx）：直接存储完整路径字符串，利用 `set` 自动去重。  
     - **优点**：代码简洁，无需处理复杂数据结构。  
     - **缺点**：字符串拼接可能带来额外时间开销。  
   - **字典树（Trie）方案**（Haishu、盖矣斌峥）：构建树形结构存储路径层级。  
     - **优点**：空间效率高，适合路径有大量重复前缀的场景。  
     - **缺点**：实现复杂，需处理指针或 `map` 嵌套。  
   - **哈希方案**（离散小波变换°）：哈希函数处理路径字符串，用链式哈希避免冲突。  
     - **优点**：理论性能最优，适合海量数据。  
     - **缺点**：需处理哈希碰撞和字符串编码问题。

---

### 高星题解推荐（≥4星）
1. **Anguei（5星）**  
   - **亮点**：代码极简，仅用 `set` 和逐字符遍历。  
   - **关键代码**：  
     ```cpp
     for (auto j : s) {
         if (j == '/') set.insert(dir);
         dir += j;
     }
     set.insert(dir);
     ```
   - **优化点**：自然处理路径分割，无需显式字符串切割。

2. **Haishu（4星）**  
   - **亮点**：链表式字典树实现，空间高效。  
   - **关键代码**：  
     ```cpp
     struct info { struct info *c,*b; char a[S]; };
     void dfs(int i, struct info *&p, bool fg, char r[]) {
         // 递归查找或插入节点
     }
     ```
   - **优化点**：通过指针动态管理子树，避免冗余存储。

3. **离散小波变换°（4星）**  
   - **亮点**：链式哈希处理碰撞，高性能。  
   - **关键代码**：  
     ```cpp
     bool gethsh(ULL t) {
         for (int i=head[t%MAXS]; i; i=nxt[i]) {
             if (val[i] == t) return true;
         }
         add(t%MAXS, t); return false;
     }
     ```

---

### 最优思路提炼
- **核心技巧**：利用集合（`set`）动态维护所有唯一路径层级。  
- **关键步骤**：  
  1. 遍历路径字符串，遇到 `/` 时将当前层级路径插入集合。  
  2. 插入完整路径（处理末尾非 `/` 情况）。  
  3. 集合大小减一（排除根目录的占位符）。  
- **复杂度**：  
  - 时间：O(N*L)，L为平均路径长度。  
  - 空间：O(N*L)，存储所有唯一路径。

---

### 同类型题目与算法套路
- **通用套路**：  
  - 前缀处理 → 字典树/集合去重。  
  - 路径分解 → 字符串逐层切割。  
- **相似题目**：  
  1. **P2580 他父亲的谜题**（字典树应用）  
  2. **P8306 【模板】字典树**（Trie模板题）  
  3. **P2262 [HNOI2004]FTP服务器**（路径合法性校验）

---

### 可视化设计要点
1. **动画方案**：  
   - **层级展开**：以树形图展示路径分割过程，每插入一个路径层级时高亮当前节点。  
   - **颜色标记**：  
     - 红色：新增节点。  
     - 绿色：已存在节点。  
   - **步进控制**：支持暂停/继续，观察每个 `/` 分割后的路径插入状态。

2. **复古像素风格**：  
   - **Canvas 绘制**：路径层级以8位像素块表示，每个块标注路径名（如 `/a`）。  
   - **音效触发**：  
     - 插入新路径：短促“滴”声。  
     - 重复路径：低沉“咚”声。  
   - **自动演示**：模拟路径字符串的逐字符输入和层级展开。

---

### 核心代码实现（Anguei方案）
```cpp
#include <set>
#include <string>
#include <iostream>

int main() {
    int n;
    std::cin >> n;
    std::set<std::string> dir_set;
    
    for (int i = 0; i < n; ++i) {
        std::string s, current_dir;
        std::cin >> s;
        for (char c : s) {
            if (c == '/') {
                dir_set.insert(current_dir);
            }
            current_dir += c;
        }
        dir_set.insert(current_dir); // 处理末尾非'/'情况
        std::cout << dir_set.size() - 1 << "\n";
    }
}
```

---

### 个人心得摘录
- **Anguei**：末尾需额外插入一次路径，避免漏掉最后一级。  
- **Haishu**：链表指针需初始化，否则可能指向非法内存。  
- **FutureThx**：样例3末尾无 `/` 时需特殊处理，否则计数错误。

---

### 总结
- **最优选择**：集合方案（代码简洁，适合竞赛场景）。  
- **扩展思考**：若路径层级极深，可优先考虑字典树或哈希优化空间。

---
处理用时：65.56秒
# 题目信息

# 英语1（eng1）- 英语作文

## 题目背景

蒟蒻 HansBug 在英语考场上，挠了无数次的头，可脑子里还是一片空白。

## 题目描述

眼下出现在 HansBug 蒟蒻面前的是一篇英语作文，然而智商捉急的 HansBug 已经草草写完了，此时他发现离考试结束还有 $40$ 分钟，于是他打算估计一下这篇共有 $M$ 个单词的英语作文的含金量如何。众所周知的是，在中高考英语作文中使用高级词汇可以有效提高文章的含金量，从而获得更好的分数。已知蒟蒻HansBug知道 $N$ 个高级词汇，该词汇为 $A_i$（词汇长度为 $L_i$ ，包含数字、大小写字母），该高级词汇的含金量为 $B_i$，则该高级词汇每出现一次便可增加 $B_i$ 的含金量。可是他脑细胞和 RP 已经消耗殆尽，所以这个伟大的任务就交给你啦！

## 说明/提示

样例 $1$ 中，共计出现了 $2$ 次`hansbug`、 $2$ 次`absi2011` 、 $1$ 次 `yyy` 、 $1$ 次`kkksc03`、 $1$ 次  `lzn` ，所以总含金量为 $1\times2+2\times4+3\times1+4\times1+100\times1=115$，对 $99$ 取模就是 $16$ 。

样例 $2$ 中，和样例 $1$ 基本一样，值得注意的是整体的 `yyyy` 不可以被认为是 `yyy` 出现 $2$ 次，请注意这是一篇英语作文，一切以单词为最小单位。

此题目中大小写敏感。

数据范围（设所有单词的最大长度为 $Lmax$ ）：

![](https://cdn.luogu.com.cn/upload/pic/2228.png)


## 样例 #1

### 输入

```
5 99
hansbug 1
kkksc03 2
yyy 3
absi2011 4
lzn 100
hansbug is a juruo!but absi2011 not.!?!
one day absi2011 laughed at yyy and hansbug.
then kkksc03 and lzn blamed him for that.
```

### 输出

```
16```

## 样例 #2

### 输入

```
5 99
yyyy 1
kkksc03 2
yyy 3
absi2011 4
lzn 100
yyyy is a juruo!but absi2011 not.!?!
one day absi2011 laughed at yyy and yyyy.
then kkksc03 and lzn blamed him for that.
```

### 输出

```
16```

# AI分析结果



# 算法分类选择  
**映射结构（如map）**  

# 题解思路、算法要点与解决难点  
## 核心逻辑  
所有题解的核心逻辑均为：  
1. 建立高级词汇到含金量的映射  
2. 逐词扫描文章，统计匹配词汇的含金量总和  

## 关键对比  
| 方法          | 数据结构       | 时间复杂度 | 空间复杂度 | 实现难度 | 亮点  
|---------------|---------------|------------|------------|----------|-----  
| std::map       | 红黑树         | O(M logN)  | O(N)       | 简单     | 代码极简，直接利用STL特性  
| 哈希+二分      | 自定义哈希数组 | O(M logN)  | O(N)       | 中等     | 避免STL开销，需处理哈希冲突  
| Trie树        | 左儿子右兄弟树 | O(M*L)     | O(N*L)     | 困难     | 理论最优，但空间易爆炸  
| unordered_map | 哈希表         | O(M)       | O(N)       | 简单     | C++11特性，哈希优化速度  

## 解决难点  
1. **单词分割**：需正确处理标点符号与连续字符的分界，例如样例2中`yyyy`不能拆分成两个`yyy`  
2. **大小写敏感**：需保留原始字符大小写，直接字符串比对  
3. **高效查找**：当N=1e5时，O(M logN)与O(M)的差异显著  

# 题解评分（≥4星）  
1. **Diamiko（4.5星）**  
   - 亮点：最简洁的map实现，完整处理标点分割逻辑  
   - 代码可读性：⭐️⭐️⭐️⭐️  
   - 核心代码片段：  
     ```cpp  
     while(scanf("%c",&c)!=EOF) {  
         if(!isalnum(c)) {  
             ans += a[t];  
             t.clear();  
         } else t += c;  
     }  
     ```  

2. **Edgaru089（4星）**  
   - 亮点：使用unordered_map实现O(1)哈希查询，C++11特性优化速度  
   - 优化技巧：`m.rehash(200000)`预分配哈希桶减少冲突  

3. **happybob（4星）**  
   - 亮点：通过`scanf("\n")`处理输入换行符，避免边界错误  
   - 个人心得摘录：  
     > "不加不会WA，但样例过不去（这……）" —— 强调输入细节的重要性  

# 最优思路提炼  
**核心技巧**：  
1. **流式处理单词**：逐个字符读取，遇分隔符时立即提交单词查询  
2. **即时取模**：累加时每步取模防止溢出，而非最后统一处理  
3. **预读技巧**：通过`getchar()`或`fread`提前读取全部输入，加速IO  

**数据结构选择优先级**：  
unordered_map > std::map > 自定义哈希 > Trie树  

# 同类型题与算法套路  
1. **单词统计**：如[LeetCode 1396. 设计地铁系统](https://leetcode.cn/problems/design-underground-system/)  
2. **实时流处理**：需在数据到达时立即处理，类似滑动窗口统计  
3. **模运算优化**：涉及大数累加取模的场景（如RSA加密）  

# 推荐洛谷题目  
1. P3370 【模板】字符串哈希  
2. P2580 于是他错误的点名开始了（Trie树模板）  
3. P1102 A-B数对（哈希映射应用）  

# 个人心得摘录  
- **fallingdust**调试经历：  
  > "暴力写法光荣TLE五个点...一定要考虑时间复杂度"  
- **户山香澄**的Trie教训：  
  > "优化后还是MLE一个点，空间换时间需谨慎"  

# 算法可视化设计  
## 动画方案  
1. **像素风格展示**：  
   - 用16色像素块表示字符流，绿色表示当前正在构建的单词  
   - 哈希表/红黑树结构在右侧以网格形式展示，命中时黄色闪烁  

2. **关键帧控制**：  
   - **字符输入**：逐个字符飞入画面，遇分隔符时触发查询  
   - **数据结构查询**：在哈希表/树结构中高亮匹配路径  
   - **分数累加**：每次匹配成功时，显示金色数字飘入总分区  

3. 音效设计：  
   - 字符输入：8-bit打字机音效  
   - 成功匹配：经典FC得分音效（类似《超级玛丽》吃金币）  
   - 模运算：电子合成器的"滴"声  

## 交互控制  
```javascript  
// 伪代码示例  
class Visualizer {  
  constructor() {  
    this.speed = 1; // 1x速度  
    this.pauseFlag = false;  
    this.hashTable = drawHashGrid(); // 绘制哈希表Canvas  
  }  

  onCharInput(c) {  
    if (isSeparator(c)) {  
      this.highlightWord(this.currentWord);  
      this.hashTable.search(this.currentWord); // 触发高亮动画  
      playSound('hit');  
    } else {  
      this.currentWord += c;  
    }  
  }  
}  
```  

# 核心代码实现（Edgaru089改进版）  
```cpp  
#include <iostream>  
#include <unordered_map>  
using namespace std;  

int main() {  
    unordered_map<string, int> mp;  
    mp.reserve(1e5); // 预分配哈希桶  
    int n, p;  
    cin >> n >> p;  

    while(n--) {  
        string s; int v;  
        cin >> s >> v;  
        mp[s] = v % p; // 预取模减少计算量  
    }  

    string word;  
    char c;  
    int ans = 0;  
    while(getchar(), ~scanf("%c", &c)) { // 跳过首行换行  
        if(isalnum(c)) word += c;  
        else {  
            ans = (ans + mp[word]) % p;  
            word.clear();  
        }  
    }  
    cout << ans;  
}  
```  

**优化点**：  
- `unordered_map.reserve()`减少重建哈希表开销  
- 输入时预取模减少运行时计算  
- 流式处理避免存储全文

---
处理用时：90.53秒
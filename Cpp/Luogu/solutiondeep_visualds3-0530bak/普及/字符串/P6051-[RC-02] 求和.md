# 题目信息

# [RC-02] 求和

## 题目描述

小 Q 给你了几行字符串，字符串中间包含有一些整数，整数之间可能会有其他字符。你需要输出每行中所有整数的和。如果一个行里面一个数都没有则不要输出。**每两个整数之间一定有间隔字符（见样例 $3$）。**

请注意，题目中的整数都是简单的整数，即：整数前面没有多余的符号。假如数据中有 `.`，视作分隔符。

## 说明/提示

【样例解释】

- 第一个样例中，第一行有 $57,54,-321,8$ 几个数，和为 $-202$；第二、三行没有数字；第四行只有一个 $4$，输出 $4$。
- 第二个样例中只有一行，有两个数，和为 $4532893$。
- 第三个样例的第一行，由于每两个整数之间一定有间隔字符，所以把 `-` 视为间隔字符，输出 $2$。第五行，第一个数为 $-1$，因此把第二个 `-` 视为间隔字符，和为 $-1+1=0$。第七行，将 `.` 视为间隔字符，和为 $-2+3=1$。

【数据范围】

说明：「条件 A」指数据中不存在除数字、空格、换行、水平制表符之外的其他字符；「条件 B」指每两个数之间一定用且只用一个空格隔开。

**由于数据在 Windows 下制造，行末可能有多余的 `\r` 字符。请注意。**

对于 $10\%$ 的数据，满足条件 A 和 B，每行一定有且仅有 $10$ 个数；

对于 $40\%$ 的数据，满足条件 A 和 B，且不存在空行；

对于 $50\%$ 的数据，满足条件 A 和 B；

对于 $70\%$ 的数据，满足条件 A；

对于 $100\%$ 的数据，不存在除水平制表符、空格、换行外的不可见字符，每行不超过 $1000$ 个字符，每行最多包含 $200$ 个整数，不超过 $100$ 行，每个整数均 $\in[-10^7,10^7]$。

## 样例 #1

### 输入

```
su57jdkjth54hjsns-321d 8 ejre
erg(&-^%

weruy4uhnd-```

### 输出

```
-202
4```

## 样例 #2

### 输入

```
          4532984       d    -1```

### 输出

```
4532983```

## 样例 #3

### 输入

```
1-1
1 -1
1--5
1-----------1
-1-1
--1
-2.3```

### 输出

```
2
0
-4
0
0
-1
1```

# AI分析结果



### 唯一算法分类
字符串处理

### 综合分析与结论
题目要求从每行字符串中提取所有整数并求和，核心难点在于正确识别负数符号与分隔符。需满足以下条件：
- 负号前无数字时视为符号，否则为分隔符
- 数字间必须有分隔符（如其他字符或连续符号）
- 行内无数字则不输出

**核心算法流程**：
1. 逐字符扫描字符串
2. 遇到数字时累加当前数值
3. 遇到负号时判断是否构成合法负数符号
4. 遇到分隔符时结算当前数值
5. 行尾处理未结算数值

**可视化设计**：
- **高亮当前处理字符**：用不同颜色标记数字、负号、分隔符
- **状态标记**：显示当前数值累加状态、负号有效性判断
- **步进控制**：允许单步执行观察数值累加过程
- **像素风格动画**：用8-bit网格展示字符串处理过程，负号触发红色闪烁，数字累加显示绿色增长条

### 题解清单 (≥4星)
1. **作者：__hacker__（5星）**
   - 亮点：正确处理所有边界条件，通过`ret`变量动态管理正负号状态
   - 关键代码段：
     ```cpp
     else if(ch[i]=='-'&&isdigit(ch[i+1])) {
         if(i!=0&&isdigit(ch[i-1])){ // 负号为分隔符
             tot+=k*ret; k=0; ret=1; 
         } else ret=-1; // 有效负号
     }
     ```
   - 心得：通过WA测试完善边界条件处理

### 最优思路提炼
**核心技巧**：
1. **双状态管理**：用`ret`变量维护当前数值正负状态
2. **动态结算机制**：遇到分隔符立即结算已累积数值
3. **越界防护**：通过`i!=0`判断避免非法内存访问
4. **行尾处理**：循环结束后再次检查未结算数值

**同类型题套路**：
- 字符串数值提取（如LeetCode 8. 字符串转换整数）
- 动态状态机解析（如JSON解析器）
- 边界条件密集的字符串处理

### 推荐练习题
1. P1308 [统计单词数] - 字符串模式匹配
2. P1598 [垂直柱状图] - 字符频率统计
3. P1765 [手机] - 字符映射处理

### 可视化代码片段
```javascript
// 像素动画核心逻辑（伪代码）
function drawProcessing(str) {
  let grid = new PixelGrid(16, 1); // 16色复古风格
  let pos = 0;
  let state = "seek"; // 状态：seek, number, negative
  
  str.split('').forEach((char, i) => {
    grid.highlight(i, 0, COLORS.current); // 高亮当前字符
    
    if (/\d/.test(char)) {
      if (state === "negative") {
        grid.setColor(i-1, 0, COLORS.negative); // 标记有效负号
      }
      state = "number";
      grid.fillRect(pos, 0, 3, 1, COLORS.number); // 数字增长动画
      pos += 3;
    } else if (char === '-' && /\d/.test(str[i+1])) {
      state = "negative";
    } else {
      state = "seek";
    }
    
    playSound('blip'); // 8-bit音效
  });
}
```

### 个人心得摘录
"WA的根本原因是负号与分隔符的判定，必须通过极端测试用例（如连续负号、行首负号）才能暴露代码漏洞。关键是通过状态变量而非简单位置判断符号有效性。" —— __hacker__

### 完整代码（__hacker__）
```cpp
#include <bits/stdc++.h>
using namespace std;
char ch[100000];
int main(){
    int k,tot,ret,temp;
    bool flag;
    while(cin.getline(ch,100000)){
        flag=false;k=tot=0;ret=1;
        for(int i=0;ch[i]!='\0';i++){
            if(isdigit(ch[i])){
                k*=10;
                k+=ch[i]-'0';
                flag=true;
            }
            else if(ch[i]=='-'&&isdigit(ch[i+1])) {
                if(i!=0&&isdigit(ch[i-1])){
                    tot+=k*ret;
                    k=0;
                    ret=1;
                }
                else ret=-1;
            }
            else{
                tot+=k*ret;
                k=0;
                ret=1;
            }
            temp=i;
        }
        if(isdigit(ch[temp])) tot+=k*ret;
        if(flag)
        cout<<tot<<endl;
    }
    return 0;
}
```

---
处理用时：328.61秒
# 题目信息

# 『MdOI R2』Mayuri

## 题目背景

「万由里……怎么会？为什么你要……」

『我是灵力的结晶体，实施了封印，我当然会消失，不是吗？』

「封印？但是你和我……」

『第一次见面不能封印吗？笨蛋，我可是从大家的灵力里出生的，怎么可能讨厌你？从一出生，我就爱着你。』

「万由里……」

『虽然我竭力不让自己去想，但我一定是很羡慕大家……』

「等一下，万由里，不要消失……」

『但是我还是有一件能向大家炫耀的事，只有我和士道一样……』

「一样？」

『我已经不再是只为了消失而出生的生命。因为我遇见了你……已经足够了。』

「万由里……」

『谢谢你，士道。 』

![](https://cdn.luogu.com.cn/upload/image_hosting/9w6a0deg.png)

## 题目描述

在离开这个世界前，万由里想要寻找属于她的 Lucky Number。

万由里会给出一个数 $a$，以及一个长度为 $b$ 的 01 串 $S$。

简单的说，她的 Lucky Number 是满足以下条件的**正整数** $n$：

 - $n$ 的位数为 $b$ 且不含前导 $0$。

 - 若 $S$ 的第 $i$ 位为 $1$，则 $n$ 的前 $i$ 位组成的数是 $a$ 的倍数，否则 $n$ 的前 $i$ 位组成的数不是 $a$ 的倍数。

对于一个数，前 $i$ 位组成的数是指这个数前 $i$ 个数码依次拼接形成的数。例如 $312311$ 前 $3$ 位组成的数为 $312$，前 $5$ 位组成的数为 $31231$。


现在，请你帮助万由里计算一下，她的 Lucky Number 是多少。

由于满足条件的数可能会有多个，你需要输出**最小**的一个。若不存在，则请输出 `-1`。

## 说明/提示

【帮助与提示】

为方便选手测试代码，本题额外提供一组附加样例供选手使用。

[样例输入](https://www.luogu.com.cn/paste/5gnn8mg0) [样例输出](https://www.luogu.com.cn/paste/sgxjkbjd)

------
【样例解释】

对于样例一，$10$ 是 $2$ 位数，且 $10$ 的前 $1$ 位组成的数 $1$ 不是 $2$ 的倍数，而前 $2$ 位组成的数 $10$ 是 $2$ 的倍数。由于 $10$ 已经是最小的两位数，故不存在比 $10$ 更小的满足条件的数。

对于样例二，我们需要构造一个 $1$ 位数，满足这个 $1$ 位数整除 $10$。显然，这样的数不存在。

---

【数据范围】

**本题采用捆绑测试**


| 子任务编号 | $a \leq$ | $b\le$  | 分值   |
| ---------- | -------- | :------ | ------ |
| Subtask 1  | $10$     | $ 1$    | $20$   |
| Subtask 2  | $10 $    | $2$     | $20$  |
| Subtask 3  | $10 $    | $ 6$    | $20$  |
| Subtask 4  | $ 2$     | $ 18$   | $20$ |
| Subtask 5  | $ 10$    | $ 10^5$ | $20$ |


对于全部数据，保证 $2\le a\le 10$，$1\le b\le 10^5$，$S$ 中只包含 `0` 和 `1`。

## 样例 #1

### 输入

```
2 2
01```

### 输出

```
10```

## 样例 #2

### 输入

```
10 1 
1```

### 输出

```
-1```

## 样例 #3

### 输入

```
6 6
110100```

### 输出

```
601210```

# AI分析结果



**算法分类**  
贪心算法、数论（模运算）

---

### **题解思路与核心难点**

1. **核心思路**  
   - **贪心构造**：从高位到低位逐位构造，每一步选择最小的可能数字以满足当前位的条件。  
   - **余数维护**：记录当前构造数的余数（模 `a` 的结果），通过数学计算直接确定每步应填的数字，无需暴力枚举。  

2. **关键步骤**  
   - **首字符处理**：若首字符为 `1`，则首位必须为 `a`（除非 `a=10`，此时无解）；若为 `0`，则首位为 `1`。  
   - **后续位处理**：  
     - 若当前位要求整除（`S[i] = '1'`）：计算 `j = (a - (当前余数 * 10 % a)) % a`，确保填后余数为 `0`。  
     - 若当前位不要求整除（`S[i] = '0'`）：若当前余数非零则填 `0`，否则填 `1`。  

3. **解决难点**  
   - **避免高精度计算**：通过模运算维护余数，无需存储完整数字。  
   - **数学推导**：直接通过余数推导出当前位的最小数字，时间复杂度降至 `O(b)`。  

---

### **题解评分与推荐**

1. **⭐️⭐️⭐️⭐️⭐️ [grass8cow 的题解]**  
   - **亮点**：代码极简，直接计算余数，无循环，复杂度 `O(b)`。  
   - **代码片段**：  
     ```cpp
     if(c=='1')cout<<a; else cout<<1,now=1;  // 首字符处理
     now=now*10%a;  // 余数更新
     ```

2. **⭐️⭐️⭐️⭐️ [BFqwq 的官方题解]**  
   - **亮点**：贪心逐位构造，逻辑清晰，适合理解。  
   - **代码片段**：  
     ```cpp
     for(int j=0;j<=9;j++)  // 循环找最小 j
     if((now+j)%a==0&&c[i]=='1'){ ... }
     ```

---

### **最优思路提炼**

- **余数驱动**：每一步的余数 `rem` 是关键，通过 `rem = (rem * 10 + j) % a` 更新。  
- **数学优化**：直接计算最小 `j`，避免暴力循环（如 `j = (a - rem * 10 % a) % a`）。  

---

### **同类型题目推荐**

1. **P4127 [AHOI2009] 同类分布**  
   - 要求数位和与数本身满足特定模关系。  
2. **P4999 烦人的数学作业**  
   - 构造区间内满足特定数位条件的数。  
3. **P2602 [ZJOI2010] 数字计数**  
   - 统计数位出现次数，涉及逐位构造。  

---

### **可视化设计**

1. **动画方案**  
   - **像素风格**：用 8-bit 网格展示每位数字，当前位高亮为黄色。  
   - **余数显示**：右侧面板显示当前余数 `rem`，颜色随值变化。  
   - **音效触发**：成功填位时播放清脆音效，错误时播放低沉音效。  

2. **交互功能**  
   - **步进控制**：用户可单步执行或自动播放（速度可调）。  
   - **关键变量高亮**：余数 `rem` 和当前位 `j` 的值用红色标记。  

---

### **核心代码实现**

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,i,now;
char c;
int main() {
    cin>>a>>b>>c;
    if(a==10&&c=='1'){cout<<-1;return 0;} // 特判无解
    if(c=='1')cout<<a; // 首字符处理
    else cout<<1,now=1;
    for(i=1;i<b;i++) {
        cin>>c; 
        now=now*10%a; // 余数更新
        if(c=='0') {
            if(now)cout<<0; // 余数非零则填0
            else cout<<1,now=1; // 余数为零则填1
        } else {
            cout<<(a-now)%a; // 计算最小 j
            now=0; // 填后余数归零
        }
    }
    return 0;
}
```

---

**总结**：通过余数驱动的贪心策略，结合数学优化，高效解决了大范围构造问题。

---
处理用时：81.84秒
# 题目信息

# 【模板】字典树

## 题目描述

给定 $n$ 个模式串 $s_1, s_2, \dots, s_n$ 和 $q$ 次询问，每次询问给定一个文本串 $t_i$，请回答 $s_1 \sim s_n$ 中有多少个字符串 $s_j$ 满足 $t_i$ 是 $s_j$ 的**前缀**。

一个字符串 $t$ 是 $s$ 的前缀当且仅当从 $s$ 的末尾删去若干个（可以为 0 个）连续的字符后与 $t$ 相同。

输入的字符串大小敏感。例如，字符串 `Fusu` 和字符串 `fusu` 不同。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq T, n, q\leq 10^5$，且输入字符串的总长度不超过 $3 \times 10^6$。输入的字符串只含大小写字母和数字，且不含空串。

### 说明
std 的 IO 使用的是关闭同步后的 cin/cout，本题不卡常。

## 样例 #1

### 输入

```
3
3 3
fusufusu
fusu
anguei
fusu
anguei
kkksc
5 2
fusu
Fusu
AFakeFusu
afakefusu
fusuisnotfake
Fusu
fusu
1 1
998244353
9```

### 输出

```
2
1
0
1
2
1```

# AI分析结果



### 唯一算法分类
字典树（Trie）

---

### 综合分析与结论
**核心思路**：利用字典树存储所有模式串，每个节点记录「经过该节点的字符串数量」。查询时沿路径遍历，若路径存在则返回终点节点的计数器值。  
**关键难点**：  
1. 字符映射（需覆盖大小写字母和数字）  
2. 高效处理大规模数据（总字符串长度 ≤3e6）  
**最优解法**：qip101 的数组实现法，直接通过数组下标映射字符，路径遍历时实时更新计数器，时空效率均最优。

**可视化设计**：  
- **动画流程**：  
  1. 插入阶段：以像素块表示树节点，路径延伸时触发「创建节点」音效，计数器数值动态增长  
  2. 查询阶段：路径高亮为绿色（成功）或红色（断裂），终点节点放大显示计数器值  
- **复古风格**：  
  - 使用 8-bit 调色板（如：根节点为棕色，路径线为青色，计数器显示为黄色像素数字）  
  - 音效设计：路径延伸时播放短促「滴」声，查询失败时播放低音「嘟」声  

---

### 题解清单 (≥4星)
1. **qip101（5星）**  
   - 亮点：数组直接映射字符，路径遍历时实时计数，代码简洁高效  
   - 代码可读性：结构清晰，无冗余操作  
2. **一扶苏一（4星）**  
   - 亮点：动态节点管理节省空间，DFS预处理优化查询  
   - 不足：动态内存分配可能影响性能  

---

### 核心代码实现
**qip101 的关键函数**：
```cpp
int getnum(char x) {  // 字符映射（O(1)）
    if (x >= 'A' && x <= 'Z') return x - 'A';
    else if (x >= 'a' && x <= 'z') return x - 'a' + 26;
    else return x - '0' + 52;
}

void insert(char str[]) {  // 插入时路径计数
    int p = 0;
    for (int i = 0; str[i]; i++) {
        int c = getnum(str[i]);
        if (!t[p][c]) t[p][c] = ++idx;
        p = t[p][c];
        cnt[p]++;  // 实时更新计数器
    }
}

int find(char str[]) {  // 查询直接返回终点计数器
    int p = 0;
    for (int i = 0; str[i]; i++) {
        int c = getnum(str[i]);
        if (!t[p][c]) return 0;
        p = t[p][c];
    }
    return cnt[p];
}
```

---

### 同类题目推荐
1. **P2580 于是他错误的点名开始了**（字典树基础应用）  
2. **P4551 最长异或路径**（字典树处理异或前缀）  
3. **P3294 [SCOI2016]背单词**（字典树+贪心策略）  

---

### 可视化代码片段（JS Canvas）
```javascript
// 绘制字典树节点（8-bit风格）
function drawNode(x, y, count) {
    ctx.fillStyle = "#6B4226"; // 棕色节点
    ctx.fillRect(x, y, 30, 30);
    ctx.fillStyle = "#FFD700"; // 黄色数字
    ctx.fillText(count, x + 5, y + 20);
}

// 插入动画核心逻辑
function animateInsert(str) {
    let p = 0, x = 400, y = 50;
    for (let c of str) {
        const idx = getCharIndex(c); // 字符映射
        if (!nodes[p][idx]) { 
            playSound('new_node'); // 触发音效
            nodes[p][idx] = ++nodeCount;
        }
        p = nodes[p][idx];
        drawLine(x, y, x + 50, y + 80); // 绘制路径线
        x += 50; y += 80;
        drawNode(x, y, cnt[p]); // 更新节点
    }
}
```

---

### 总结
**最优技巧**：数组直接映射字符 + 路径实时计数。该方案将时间复杂度严格控制在 O(L)（L为字符串长度），空间通过紧凑的数组布局优化至可接受范围。  
**学习价值**：字典树的本质是通过共享前缀压缩存储空间，此题通过计数器设计将前缀统计转化为路径遍历问题，是此类问题的通用解法模板。

---
处理用时：65.68秒
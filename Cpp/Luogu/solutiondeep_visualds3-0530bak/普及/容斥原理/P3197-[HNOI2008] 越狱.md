# 题目信息

# [HNOI2008] 越狱

## 题目描述

监狱有 $n$ 个房间，每个房间关押一个犯人，有 $m$ 种宗教，每个犯人会信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。

答案对 $100,003$ 取模。

## 说明/提示

#### 样例输入输出 1 解释

| 状态编号 | 1 号房间 | 2 号房间 | 3 号房间 |
| :--------: | :--------: | :-------: | :--------: |
| 1 | 信仰 1 | 信仰 1 | 信仰 1 |
| 2 | 信仰 1 | 信仰 1 | 信仰 2 |
| 3 | 信仰 1 | 信仰 2 | 信仰 2 |
| 4 | 信仰 2 | 信仰 1 | 信仰 1 |
| 5 | 信仰 2 | 信仰 2 | 信仰 2 |
| 6 | 信仰 2 | 信仰 2 | 信仰 1 |

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \le m \le 10^8$，$1 \le n \le 10^{12}$。

## 样例 #1

### 输入

```
2 3
```

### 输出

```
6```

# AI分析结果



## 算法分类
**数论与快速幂**

---

## 核心思路与难点分析

### 题解思路
所有题解均采用**补集思想**：  
1. **总状态数**：每个房间有m种选择 → $m^n$  
2. **不越狱的状态数**：第一个房间选m种，后续每个房间与前一个不同 → $m \cdot (m-1)^{n-1}$  
3. **最终答案**：总状态 - 不越狱状态 → $m^n - m \cdot (m-1)^{n-1}$

### 解决难点
- **指数过大**：通过快速幂将计算复杂度优化至 $O(\log n)$
- **模运算处理**：相减可能出现负数，需加模数再取模（如 `(ans + mod) % mod`）

### 关键变量
- `m^n` 与 `(m-1)^{n-1}` 使用快速幂计算
- 最终结果通过减法取模确保非负

---

## 高星题解推荐（≥4星）

1. **蒟蒻初音ミク（5星）**  
   - **亮点**：代码简洁，递归快速幂实现清晰，注释详细  
   - **代码**：递归式快速幂，负数处理直接  
   ```cpp
   ll qmi(ll a, ll b) {
       if(b == 0) return 1;
       return (b&1) ? pow(qmi(a, b>>1)) * (a%mod) % mod : pow(qmi(a, b>>1));
   }
   ```

2. **Ezios（4.5星）**  
   - **亮点**：数学推导详细，模板式快速幂函数复用性强  
   - **代码**：模板化快速幂，支持不同底数和指数  
   ```cpp
   template<typename T>
   T __fmo_expa(T __m, T __n, T _modular) {
       T ans = 1;
       while(__n) {
           if(__n&1) ans = (ans * __m) % _modular;
           __m = (__m * __m) % _modular;
           __n >>= 1;
       }
       return ans;
   }
   ```

3. **Kisaragi_77（4星）**  
   - **亮点**：代码极简，快速幂与负数处理一气呵成  
   - **代码**：迭代式快速幂，逻辑紧凑  
   ```cpp
   ll fast_pow(ll a, ll b) {
       ll ans = 1;
       while(b) {
           if(b & 1) ans = ans * a % mod;
           a = a * a % mod;
           b >>= 1;
       }
       return ans;
   }
   ```

---

## 最优技巧提炼

### 核心公式
$$ \text{ans} = \left(m^n - m \cdot (m-1)^{n-1}\right) \mod 100003 $$

### 快速幂优化
- **二进制分解指数**：将指数转换为二进制形式，逐位计算幂次  
- **模运算性质**：每次乘法后立即取模，避免数值溢出

### 代码实现要点
```cpp
// 迭代式快速幂（推荐）
ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    a %= mod;
    while(b) {
        if(b & 1) res = (res * a) % mod;
        a = (a * a) % mod;
        b >>= 1;
    }
    return res;
}
```

---

## 同类题目推荐

1. **P1226 【模板】快速幂**  
   - 快速幂基础模板题，适合练习核心算法

2. **P1306 斐波那契公约数**  
   - 结合斐波那契数列与最大公约数，需快速幂优化

3. **P1349 广义斐波那契数列**  
   - 矩阵快速幂应用，拓展递推式解法

---

## 可视化与像素动画设计

### 算法演示方案
- **Canvas动态绘制**：  
  1. **快速幂分解**：展示指数二进制拆分过程（如 $n=13$ → 1101₂）  
  2. **颜色标记**：当前计算的二进制位高亮，对应底数平方步骤  
  3. **状态更新**：实时显示当前幂次结果和中间变量

- **复古像素效果**：  
  - **8位音效**：每次位操作播放“哔”声，完成计算后播放胜利音效  
  - **像素风格网格**：用16x16像素块表示二进制位，红色表示激活位

### 交互设计
- **步进控制**：允许用户单步执行或自动播放  
- **参数输入**：支持自定义m和n值，观察不同规模计算过程  
- **对比模式**：并行展示递归与迭代快速幂的中间状态差异

---

## 核心代码（完整）

```cpp
#include <cstdio>
using namespace std;
typedef long long ll;
const int MOD = 100003;

ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    a %= mod;
    while (b) {
        if (b & 1) res = (res * a) % mod;
        a = (a * a) % mod;
        b >>= 1;
    }
    return res;
}

int main() {
    ll m, n;
    scanf("%lld%lld", &m, &n);
    ll total = qpow(m, n, MOD);
    ll valid = (m % MOD) * qpow(m-1, n-1, MOD) % MOD;
    ll ans = (total - valid + MOD) % MOD;
    printf("%lld\n", ans);
    return 0;
}
```

---
处理用时：71.26秒
# 题目信息

# [蓝桥杯 2020 省 AB3] 画中漂流

## 题目描述

在梦境中，你踏上了一只木䇝，在江上漂流。

根据对当地的了解，你知道在你下游 $D$ 米处有一个峡谷，如果你向下游前进大于等于 $D$ 米则必死无疑。

现在你打响了急救电话，$T$ 秒后救援队会到达并将你救上岸。水流速度是 $1 \mathrm{~m} / \mathrm{s}$，你现在有 $M$ 点体力。每消耗一点体力，你可以划一秒桨使船向上游前 进 $1 \mathrm{~m}$，否则会向下游前进 $1 \mathrm{~m}$ (水流)。$M$ 点体力需在救援队赶来前花光。因为江面太宽了，凭借你自己的力量不可能上岸。

请问，有多少种划桨的方案可以让你得救。

两个划桨方案不同是指：存在某一秒钟，一个方案划桨，另一个方案不划。

## 说明/提示

对于 $50 \%$ 的评测用例，$1 \leq T \leq 350$。

对于所有评测用例，$1 \leq T \leq 3000,1 \leq D \leq T，1 \leq M \leq 1500$。

蓝桥杯 2020 第三轮省赛 AB 组 I 题。

## 样例 #1

### 输入

```
1 6 3```

### 输出

```
5```

# AI分析结果



---

## 唯一算法分类
**动态规划**

---

## 综合分析与结论

### 题解思路与核心难点
- **核心思路**：所有题解均采用动态规划（DP）方法，定义二维状态 `dp[i][j]` 表示经过 `i` 秒后剩余 `j` 点体力的合法方案数。状态转移方程为：  
  `dp[i][j] = dp[i-1][j] + dp[i-1][j+1]`，分别对应当前秒不划桨（向下漂流）和划桨（消耗体力向上游）的决策。
- **存活条件**：需保证在任意时刻，当前位置距离峡谷足够远。推导公式为 `d + 2*(m-j) - i > 0`，其中 `m-j` 是已消耗的体力（向上游划的距离），`i` 是总时间。
- **初始化与边界**：初始状态 `dp[0][m] = 1`，最终答案为 `dp[t][0]`（体力必须用完）。

### 可视化设计思路
1. **动态表格填充**：在 Canvas 中以网格绘制 DP 表，横轴为时间，纵轴为体力。每次填充 `dp[i][j]` 时，高亮其依赖的 `dp[i-1][j]` 和 `dp[i-1][j+1]`。
2. **颜色标记**：
   - 绿色：合法状态（存活条件满足）。
   - 红色：非法状态（掉入峡谷）。
3. **音效与动画**：
   - 划桨时播放短促“点击”音效，漂流时播放水流声。
   - 自动模式下，算法逐步填充表格，速度可调。
4. **复古像素风格**：采用 8-bit 风格网格，每个格子显示数值，背景音乐为循环的芯片音乐。

---

## 题解评分 (≥4星)

1. **FutureSnow（5星）**  
   - 代码简洁，状态转移与存活条件推导清晰。
   - 使用 `len = d + 2*(m-j) - i` 直接计算位置，逻辑明确。

2. **xiaoxiaoxia（4星）**  
   - 分步讲解 DP 三要素（定义、转移、初始化），适合新手。
   - 条件判断 `d - i + 2*(m-j) <= 0` 与主流推导等价，但解释稍简。

3. **Chis725（4星）**  
   - 公式 `d + 2m - 2j - i` 简化了位置计算，代码可读性强。
   - 使用 `#define int long long` 避免溢出，细节处理到位。

---

## 最优思路与代码实现

### 关键代码片段
```cpp
int d, t, m, dp[3007][1507];
for (int i = 1; i <= t; i++) {
    for (int j = 0; j <= m; j++) {
        if (d + 2 * (m - j) - i > 0) {
            dp[i][j] = (dp[i-1][j] + dp[i-1][j+1]) % mod;
        }
    }
}
cout << dp[t][0];
```

### 核心思想
- **状态压缩**：使用滚动数组优化空间（见下方代码）。
- **存活条件优化**：统一为 `d + 2*(m-j) - i > 0`，避免冗余计算。

```cpp
// 滚动数组优化（一维 DP）
int f[1510] = {0};
f[m] = 1;
for (int i = 1; i <= t; i++) {
    for (int j = 0; j <= m; j++) {
        if (d + 2*(m-j) - i > 0) {
            f[j] = (f[j] + f[j+1]) % mod;
        }
    }
}
```

---

## 同类型题目推荐
1. **P1044 [NOIP2003 普及组] 栈**：卡特兰数的 DP 模型。
2. **P1002 [NOIP2002 普及组] 过河卒**：路径计数与状态转移。
3. **P1077 [NOIP2012 普及组] 摆花**：背包问题的变种。

---

## 个人心得摘录
- **Dehydration**：强调三步法（定义、转移、初始化），适合系统性学习 DP。
- **封禁用户（记忆化搜索）**：递归边界处理需谨慎，避免遗漏 `t=0` 的终止条件。

---

## 可视化与复古游戏化设计
1. **像素动画**：  
   - 使用 Canvas 绘制 16x16 像素的 DP 表，每次更新时播放“哔”声。
   - 非法状态格子显示“💀”，合法状态显示数值。

2. **自动演示模式**：  
   - 按帧逐步填充表格，用户可暂停/调整速度。
   - 完成时播放胜利音效，背景音乐为《俄罗斯方块》风格。

3. **交互控制**：  
   - 滑动条调节动画速度（1x~5x）。
   - 按钮切换“划桨/漂流”高亮模式，观察不同决策的影响。

```javascript
// 示例：Canvas 绘制 DP 表（伪代码）
function drawGrid() {
  for (let i = 0; i <= t; i++) {
    for (let j = 0; j <= m; j++) {
      if (dp[i][j] > 0) {
        ctx.fillStyle = (d + 2*(m-j) - i > 0) ? "#0f0" : "#f00";
        ctx.fillRect(i*20, j*20, 18, 18);
      }
    }
  }
}
```

---
处理用时：89.12秒
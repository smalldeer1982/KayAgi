# 题目信息

# [入门赛 #9] 神树大人挥动魔杖 (Hard Version)

## 题目背景

**本题与 Easy Version 题意完全相同，仅有 $n,k$ 的数据范围有所不同。**

## 题目描述

神树大人挥动魔杖，召唤出了 $9 \times 10^{n-1}$ 只家养小精灵。每只家养小精灵都有一个互不相同的 $n$ 位数编号 $a_i$。

神树大人希望将这些家养小精灵分为 $k$ 组。第 $p$ 组的所有家养小精灵满足编号 $a_i$ 对 $k$ 取模余 $p-1$，即 $a_i \equiv p-1 \pmod k$。

神树大人想要知道，每一组小精灵分别有多少只。由于答案可能很大，你只需要输出答案对 $100,000,007$ 取模的结果

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 5000$，$1 \le k \le 1000$。

## 样例 #1

### 输入

```
3 10```

### 输出

```
90 90 90 90 90 90 90 90 90 90
```

# AI分析结果



## 算法分类  
**数学、快速幂、差分**

---

## 题解思路与核心难点

### 思路对比
1. **递推动态规划**  
   - **要点**：定义 `f[i][j]` 表示 `i` 位数中模 `k` 余 `j` 的数的个数。通过枚举最高位 `p` 计算贡献，利用前缀和优化状态转移。  
   - **难点**：状态转移需正确计算高位贡献后的余数分布，且 `sum` 数组需维护前缀和。  
   - **问题**：代码中 `sum` 数组的更新方式可能导致累计错误，无法正确处理严格 `n` 位数的情况。

2. **数学差分法**  
   - **要点**：将问题转化为计算两个区间 `[1, 10^n - 1]` 和 `[1, 10^{n-1} - 1]` 的余数分布之差。通过快速幂计算大数的模，结合逆元处理除法。  
   - **关键公式**：  
     - `a = 9 * 10^{n-1}` 为总精灵数。  
     - 每组至少 `a // k` 个，余数 `r = a % k` 分到前 `r` 组。  
   - **优势**：复杂度 `O(log n + k)`，高效处理大 `n`。

### 解决难点
- **快速幂取模**：高效计算 `10^n mod k`，避免直接处理大数。  
- **逆元处理**：利用费马小定理求模意义下的除法，确保公式正确。  
- **边界余数处理**：确定余数 `r` 后，将额外 `1` 分到前 `r` 个余数。

---

## 题解评分 (≥4星)

1. **uid_310801（4.5星）**  
   - **亮点**：清晰差分思路，代码简洁，正确处理余数分布和逆元。  
   - **优化点**：快速幂与逆元结合，高效计算商和余数。

2. **_MiyazonoKaori_（4星）**  
   - **亮点**：详细数学推导，代码注释明确，分步骤计算区间差。  
   - **优化点**：将总精灵数拆分为 `10^n - 10^{n-1}` 的差分形式。

3. **iakioi114514（4星）**  
   - **亮点**：代码简洁，直接调用快速幂处理余数，逻辑清晰。  
   - **优化点**：代码模块化，易读性强。

---

## 最优思路提炼

### 关键步骤
1. **快速幂计算 `10^n mod k*mod`**：避免数值溢出，直接求模。  
2. **逆元求商**：公式 `(a - r) * inv(k) % mod` 处理除法。  
3. **余数分配**：若余数 `r > 0`，前 `r` 个余数各加 `1`。

### 代码片段
```cpp
ll qpow(ll a, ll b, ll mod) {
    ll ans = 1;
    while (b) {
        if (b & 1) ans = ans * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

// 计算区间 [1, x] 的余数分布
void compute(ll x_mod_k, ll x_mod_val, vector<ll>& cnt) {
    ll quotient = (x_mod_val - x_mod_k + MOD) * qpow(k, MOD-2, MOD) % MOD;
    for (int i = 0; i < k; i++) cnt[i] = quotient;
    if (x_mod_k > 0) for (int i = 1; i <= x_mod_k; i++) cnt[i] = (cnt[i] + 1) % MOD;
}

// 主逻辑
ll maxn = qpow(10, n, k);
ll total = qpow(10, n, MOD);
vector<ll> upper = compute(maxn - 1, total - 1);
// 同理计算 lower 并差分
```

---

## 同类型题与套路

- **通用解法**：差分思想适用于区间统计问题，快速幂处理大数取模，逆元处理模意义除法。  
- **类似题目**：  
  1. **P1226 【模板】快速幂**  
  2. **P1403 [AHOI2005] 约数研究**（差分统计因子数）  
  3. **P3935 Calculating**（区间因子数统计，差分思想）

---

## 可视化与算法演示

### 动画设计
1. **像素风格界面**：  
   - **Canvas 网格**：用像素方块表示余数 `0` 到 `k-1`，颜色区分不同余数。  
   - **动态更新**：每步计算后，对应余数的方块闪烁并更新计数。  

2. **关键步骤高亮**：  
   - **快速幂过程**：动态展示指数拆分与模运算。  
   - **余数分配**：用颜色标记前 `r` 个余数的额外 `+1` 操作。  

3. **控制面板**：  
   - **步进控制**：手动/自动调节速度，观察余数分布变化。  
   - **音效反馈**：成功分配余数时播放 8-bit 音效，失败时短促提示。  

### 复古游戏化
- **AI 自动演示**：模拟“贪吃蛇”移动，自动遍历计算步骤。  
- **积分系统**：正确完成差分步骤得分，错误操作扣分。  
- **背景音乐**：循环播放 8-bit 风格音乐，增强沉浸感。

---

## 代码实现（核心逻辑）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MOD = 1e8 + 7;

ll qpow(ll a, ll b, ll mod) {
    ll ans = 1;
    a %= mod;
    while (b) {
        if (b & 1) ans = ans * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main() {
    ll n, k;
    cin >> n >> k;
    vector<ll> ans(k, 0);

    // 计算 10^{n-1} - 1 的余数分布
    ll lower_mod = (qpow(10, n-1, k) - 1 + k) % k;
    ll lower_val = (qpow(10, n-1, MOD) - 1 - lower_mod + MOD) % MOD;
    ll lower_div = lower_val * qpow(k, MOD-2, MOD) % MOD;
    for (int i = 0; i < k; i++) {
        ans[i] = -lower_div;
        if (i > 0 && i <= lower_mod) ans[i]--;
    }

    // 计算 10^n - 1 的余数分布
    ll upper_mod = (qpow(10, n, k) - 1 + k) % k;
    ll upper_val = (qpow(10, n, MOD) - 1 - upper_mod + MOD) % MOD;
    ll upper_div = upper_val * qpow(k, MOD-2, MOD) % MOD;
    for (int i = 0; i < k; i++) {
        ans[i] += upper_div;
        if (i > 0 && i <= upper_mod) ans[i]++;
        ans[i] = (ans[i] % MOD + MOD) % MOD;
        cout << ans[i] << " ";
    }
    return 0;
}
```

---
处理用时：433.44秒
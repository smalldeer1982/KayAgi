# 题目信息

# 送花

## 题目背景

小明准备给小红送一束花，以表达他对小红的爱意。他在花店看中了一些花，准备用它们包成花束。


## 题目描述

这些花都很漂亮，每朵花有一个美丽值 $W$，价格为 $C$。

小明一开始有一个空的花束，他不断地向里面添加花。他有以下几种操作：

- $1\ W\ C$：添加一朵美丽值为 $W$，价格为 $C$ 的花。  
**如果此时花束中已经有了相等价格的花，那么这朵花不能加入花束。**
- $2$：删除当前花束里最贵的一朵花。
- $3$：删除当前花束里最便宜的一朵花。
- $-1$：完成添加与删除，开始包装花束。

**当花束为空时，忽略操作 $2$ 和 $3$。**

请你写一个程序，计算出开始包装花束时，花束中所有花的美丽值的总和，以及小明需要为花束付出的总价格。

## 说明/提示

设操作数为 $m$。

- 对于 $20\%$ 数据，$m \le 100$，$1\le W,C\le 10^3$。
- 对于全部数据，$m \le 10^5$，$1\le W,C\le 10^6$。

## 样例 #1

### 输入

```
1 1 1
1 2 5
2
1 3 3
3
1 5 2
-1
```

### 输出

```
8 5```

# AI分析结果



# 算法分类
**有序集合操作**（平衡树/数据结构应用）

---

## 综合分析与结论
### 核心思路
题目要求动态维护一个价格唯一的有序集合，支持以下操作：
1. **插入**：价格唯一性检查
2. **删除最贵/最便宜元素**
3. **统计总和**

### 解决难点
- **价格去重**：需在插入时检查是否存在相同价格
- **高效维护有序性**：频繁删除最大/最小值需快速定位元素
- **数据结构选择**：需在插入、删除、查询复杂度间平衡

### 核心算法流程
**以 `set` 实现为例**：
1. 插入时利用 `set` 自动排序特性，直接检测价格是否存在
2. 删除最大值时取 `--set.end()`，删除最小值时取 `set.begin()`
3. 总和统计通过遍历集合累加

---

## 题解清单（≥4星）

### 1. [kikuss] set极简AC（⭐⭐⭐⭐⭐）
- **亮点**：利用STL `set` 自动排序与去重特性，代码简洁高效
- **核心代码**：
  ```cpp
  set<node> v; // 按价格排序的结构体
  v.insert({w, c}); // 自动去重
  v.erase(--v.end()); // 删除最贵
  ```

### 2. [XG_Zepto] 双优先队列（⭐⭐⭐⭐）
- **亮点**：两个堆分别维护最大/最小，延迟删除标记
- **核心逻辑**：
  ```cpp
  priority_queue<int> qmax; // 大根堆
  priority_queue<int, vector<int>, greater<>> qmin; // 小根堆
  // 删除时先清理无效元素再操作
  ```

### 3. [YoungNeal] fhq-Treap（⭐⭐⭐⭐）
- **亮点**：手写平衡树实现高效动态操作
- **关键操作**：
  ```cpp
  split(root, k, x, y); // 按价格分裂树
  merge(root, x, merge(newnode, y)); // 合并保证有序
  ```

---

## 最优思路提炼
### 关键技巧
1. **STL `set` 自动维护有序性**：
   - 插入时自动排序，无需手动调整
   - 直接通过迭代器访问首尾元素删除最值

2. **延迟删除标记**（优先队列法）：
   - 用哈希表记录有效元素
   - 删除前清理堆顶无效元素

3. **平衡树分裂合并**（fhq-Treap）：
   - 按价格分裂子树实现快速定位
   - 动态维护有序集合

---

## 相似题目推荐
1. **P3369** 【模板】普通平衡树  
   *动态维护有序集合的基础操作*
2. **P1801** 黑匣子  
   *堆的延迟删除技巧*
3. **P3871** 中位数  
   *动态维护有序序列的中位值*

---

## 个人心得摘录
- **调试教训**：操作2（删最贵）和操作3（删最便宜）易混淆，需仔细验证
- **顿悟点**：`set.end()` 返回的是超尾迭代器，删除最贵需 `--set.end()`
- **性能对比**：STL在数据量1e5时仍能AC，平衡树实现速度最快

---

## 可视化设计
### 算法演示（基于 `set`）
**动画流程**：
1. **插入**：新元素以绿色高亮插入有序位置
2. **删除最贵**：红色闪烁最后一个元素后消失
3. **删除最便宜**：红色闪烁第一个元素后消失
4. **错误操作**（重复插入）：元素抖动并显示警告标志

### 复古像素风格实现
**Canvas 动画关键代码**：
```javascript
// 绘制 set 元素
function drawSet() {
  ctx.fillStyle = "#8B8B8B"; // 灰色背景
  ctx.fillRect(0, 0, 800, 600);
  let x = 50;
  for (const flower of flowers) {
    drawPixelFlower(x, 300, flower.c); // 像素花朵
    x += 60;
  }
}

// 插入动画
function animateInsert(c) {
  const temp = createPixel(c, "#00FF00"); // 绿色高亮
  temp.animate({x: targetX}, 500, () => {
    flowers.add(c); // 加入集合
    playSound('insert'); // 8-bit 音效
  });
}
```

### 音效设计
- **插入成功**：短促 "哔" 声（[JSFiddle 示例](https://jsfiddle.net/7s2xoL5q/)）
- **删除操作**：低沉 "咚" 声
- **错误提示**：连续急促 "滴滴" 声

---

## 核心代码示例（set实现）
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Flower {
    int w, c;
    bool operator<(const Flower& f) const { return c < f.c; }
};

set<Flower> flowers;
long long sum_w = 0, sum_c = 0;

int main() {
    int op, w, c;
    while (cin >> op && op != -1) {
        if (op == 1) {
            cin >> w >> c;
            if (flowers.count({0, c})) continue; // 价格去重
            flowers.insert({w, c});
            sum_w += w;
            sum_c += c;
        } else if (!flowers.empty()) {
            if (op == 2) { // 删除最贵
                auto it = --flowers.end();
                sum_w -= it->w;
                sum_c -= it->c;
                flowers.erase(it);
            } else { // 删除最便宜
                auto it = flowers.begin();
                sum_w -= it->w;
                sum_c -= it->c;
                flowers.erase(it);
            }
        }
    }
    cout << sum_w << " " << sum_c << endl;
    return 0;
}
```

---
处理用时：76.46秒
# 题目信息

# [HNOI2002] 营业额统计

## 题目描述

Tiger 最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。

Tiger 拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况：当最小波动值越大时，就说明营业情况越不稳定。

而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助 Tiger 来计算这一个值。

我们定义，一天的最小波动值 = $\min\{|\text{该天以前某一天的营业额}-\text{该天营业额}|\}$。

特别地，第一天的最小波动值为第一天的营业额。

## 说明/提示

结果说明：$5+|1-5|+|2-1|+|5-5|+|4-5|+|6-5|=5+4+1+0+1+1=12$


## 样例 #1

### 输入

```
6
5
1
2
5
4
6
```

### 输出

```
12```

# AI分析结果



## 【唯一算法分类】  
平衡树 / STL 的有序容器

---

## 【综合分析与结论】  
**核心思路**：  
本题需要快速查询当前元素的前驱与后继，计算最小波动值。本质是动态维护有序集合并支持前驱后继查询。  

**核心难点与解决方案**：  
1. **动态维护有序性**：每次插入新元素后需要快速定位其前后元素。平衡树或有序容器（如set）天然支持此特性。  
2. **边界处理**：当元素无前驱或后继时，需特殊处理（如插入正负无穷大哨兵）。  
3. **离线处理优化**：链表法通过排序+逆序删除实现离线处理，避免动态维护的开销。  

**最优思路**：  
使用 STL set 的 lower_bound 查询前驱后继，插入新元素的同时计算差值。时间复杂度 O(n log n)，代码简洁高效。  

**可视化设计思路**：  
1. **动画流程**：  
   - 初始插入两个哨兵节点（-∞, +∞）  
   - 每次插入新节点时高亮其位置  
   - 用不同颜色标记前驱（蓝色）和后继（红色）  
   - 显示当前最小波动值计算过程  
2. **复古像素风格**：  
   - 使用 8-bit 音效（插入时“滴”声，查询时“嘟”声）  
   - 平衡树节点用像素方块表示，旋转时触发闪光特效  
3. **AI自动演示**：  
   - 自动执行插入操作，速度可调（1x/2x/4x）  
   - 显示算法步骤计数器与当前波动总值  

---

## 【题解清单 (≥4星)】  
1. **Okarin (5星)**  
   - 使用 STL set 实现，代码仅 25 行  
   - 插入哨兵节点处理边界，逻辑清晰  
   - 时间复杂度最优，适合竞赛场景  

2. **sxyugao (4星)**  
   - 使用 multiset 处理重复元素  
   - 通过迭代器直接获取相邻元素  
   - 代码简洁但缺少哨兵节点注释  

3. **a999999 (4星)**  
   - 离线链表法，时间复杂度 O(n log n)  
   - 逆序删除节点实现动态维护  
   - 内存占用优于在线算法  

---

## 【最优思路代码实现】  
```cpp
#include <set>
#include <cstdio>
#include <algorithm>
using namespace std;

set<int> s;
int main() {
    int n, x, ans = 0;
    scanf("%d", &n);
    s.insert(-1e9);  // 左哨兵
    s.insert(1e9);   // 右哨兵
    
    scanf("%d", &x);
    ans = x;
    s.insert(x);
    
    for(int i=2; i<=n; ++i) {
        scanf("%d", &x);
        auto it = s.lower_bound(x);
        int right = *it;
        int left = *(--it);
        ans += min(x - left, right - x);
        s.insert(x);
    }
    printf("%d", ans);
}
```

**关键技巧**：  
1. 哨兵节点避免边界判断  
2. lower_bound 获取后继，--it 获取前驱  
3. 直接利用迭代器的有序性  

---

## 【同类型题与算法套路】  
1. **前驱后继动态查询**：P3369（普通平衡树）、P2073（维护有序集合）  
2. **离线处理技巧**：P1908（逆序对统计）  

---

## 【推荐练习题】  
1. **P3369** - 普通平衡树（模板题）  
2. **P2073** - 维护多重集合的前驱后继  
3. **P1908** - 逆序对（离线处理经典）  

---

## 【可视化演示方案】  
**Canvas 动画伪代码**：  
```javascript
class BalanceTreeViz {
    constructor() {
        this.nodes = [-Infinity, Infinity]; 
        this.highlight = null;
    }

    insert(x) {
        playSound('insert');  // 8-bit 音效
        const pos = binarySearch(x); 
        this.nodes.splice(pos, 0, x);
        
        // 计算前驱后继
        const left = this.nodes[pos-1];
        const right = this.nodes[pos+1];
        
        // 高亮动画
        this.highlight = {x, left, right};
        drawTree(this.nodes, this.highlight); 
    }
}
```  
**交互设计**：  
- 方向键控制插入速度  
- 空格键暂停/继续  
- F 键触发闪光特效（模拟平衡树旋转）  

---

## 【个人心得】  
来自题解 **lzl123**：  
> "本来想写平衡树，结果发现排序就能AC...数据水是竞赛永恒的主题"  

**启示**：  
- 在竞赛中先尝试简单方法，数据强度可能不高  
- 但正解仍需掌握，避免被特殊数据卡死  

来自题解 **Treaker**：  
> "Splay 的 rotate 函数调试了 3 小时，最后发现哨兵节点没初始化"  

**教训**：  
- 复杂数据结构务必先设计好初始化逻辑  
- 使用可视化调试工具可大幅缩短排错时间

---
处理用时：72.25秒
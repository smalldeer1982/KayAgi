# 题目信息

# 修复公路

## 题目背景

A 地区在地震过后，连接所有村庄的公路都造成了损坏而无法通车。政府派人修复这些公路。

## 题目描述

给出 A 地区的村庄数 $N$，和公路数 $M$，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）。

## 说明/提示

$1\leq x, y\leq N \le 10 ^ 3$，$1\leq M, t \le 10 ^ 5$。

## 样例 #1

### 输入

```
4 4
1 2 6
1 3 4
1 4 5
4 2 3```

### 输出

```
5```

# AI分析结果



**唯一算法分类**：并查集（Kruskal算法）

---

### **题解思路与核心难点**

#### **核心思路**
1. **问题转化**：将公路修复时间视为边权，村庄视为节点，问题转化为求解最小生成树的最大边权（即所有村庄连通所需的最早时间）。
2. **Kruskal算法**：按边权（时间）升序排列所有边，依次合并两个不连通的村庄集合，直到所有村庄连通。
3. **并查集优化**：通过路径压缩和按秩合并优化并查集操作，单次操作时间复杂度接近O(1)。

#### **解决难点**
- **连通性判断**：通过维护当前连通块数量，每次合并减少连通块数量，当数量为1时立即返回当前时间。
- **时间记录**：由于边按时间排序，最后合并的边即为最小生成树中最大的边权，直接记录即可。

---

### **题解评分（≥4星）**

1. **题解作者：qwaszx（★★★★★）**  
   - **亮点**：代码极简，利用连通块数量直接判断终止条件，时间复杂度最优。  
   - **关键代码**：合并时维护连通块数量 `n--`，当 `n==1` 时直接输出当前时间。

2. **题解作者：Coding__QAQ（★★★★☆）**  
   - **亮点**：代码清晰，通过记录最大时间变量 `ans = max(ans, e[i].t)` 明确逻辑。  
   - **优化点**：合并后统计边数，当边数达到 `n-1` 时提前终止循环。

3. **题解作者：gxwinnt（★★★★☆）**  
   - **亮点**：使用 `num` 数组记录集合大小，合并时实时更新并判断是否达到总节点数。  
   - **关键代码**：`if(num[x] >= n) return true;` 直接判断全局连通性。

---

### **最优思路与技巧提炼**

1. **贪心排序**：按时间排序边，确保每次合并的都是当前最小的可行时间边。
2. **并查集高效合并**：通过路径压缩和按秩合并（或隐式维护连通块大小）快速判断连通性。
3. **实时判断连通性**：维护连通块数量或集合大小，避免全量检查所有节点的根节点。

---

### **类似算法套路与题目推荐**

- **通用解法**：  
  所有需要处理连通性且边权有序的问题（如最小生成树、动态连通性判断）均可套用类似模板。

- **推荐题目**：  
  1. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)  
  2. [P1550 打井问题](https://www.luogu.com.cn/problem/P1550)  
  3. [P1396 营救](https://www.luogu.com.cn/problem/P1396)

---

### **可视化与算法演示**

#### **动画设计（Kruskal算法流程）**
1. **初始状态**：所有村庄独立显示为孤立节点，边按时间升序排列在右侧列表。
2. **合并过程**：  
   - **高亮当前边**：红色边框标记当前处理的边。  
   - **动态合并**：若两端节点未连通，用绿色线条连接并合并集合，更新连通块数量。  
   - **颜色标记**：已连通的集合用相同颜色填充。  
3. **终止条件**：当连通块数量变为1时，播放成功音效，最终边显示为金色。

#### **复古像素风格实现**
- **Canvas绘制**：节点显示为8位风格方块，边为像素线条，合并时播放FC风格音效。  
- **自动演示模式**：按空格键逐帧执行，按`A`键自动播放，速度可调。  
- **音效设计**：  
  - **合并成功**：短促“哔”声。  
  - **完成连通**：经典FC过关音效。

---

### **代码实现（核心逻辑）**

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

struct Edge { int x, y, t; };
Edge edges[100005];
int fa[1005], n, m;

int find(int x) {
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < m; i++)
        cin >> edges[i].x >> edges[i].y >> edges[i].t;
    
    sort(edges, edges + m, [](Edge a, Edge b) { return a.t < b.t; });
    for (int i = 1; i <= n; i++) fa[i] = i;
    
    int cnt = n;
    for (int i = 0; i < m; i++) {
        int fx = find(edges[i].x), fy = find(edges[i].y);
        if (fx != fy) {
            fa[fx] = fy;
            if (--cnt == 1) {
                cout << edges[i].t;
                return 0;
            }
        }
    }
    cout << -1;
    return 0;
}
```

**核心思想**：  
- 边排序后贪心合并，利用并查集维护连通性。  
- 实时减少连通块数量，当 `cnt == 1` 时立即输出当前时间。

---
处理用时：73.98秒
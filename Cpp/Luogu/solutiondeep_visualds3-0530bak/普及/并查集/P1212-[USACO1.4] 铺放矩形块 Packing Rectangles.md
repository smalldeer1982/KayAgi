# 题目信息

# [USACO1.4] 铺放矩形块 Packing Rectangles

## 题目描述

给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)

$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  

这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。

可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，输入的所有数在 $[1,50]$ 内。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5
```

### 输出

```
40
4 10
5 8
```

# AI分析结果



---

## 唯一算法分类  
**枚举与模拟**

---

## 综合分析与结论  
### 核心算法流程  
1. **枚举排列组合**：通过 DFS 或全排列（next_permutation）生成所有可能的矩形排列顺序  
2. **枚举旋转状态**：每个矩形可旋转（交换长宽），通过二进制位或双重递归实现  
3. **计算 6 种摆放方式**：根据题图给出的 6 种基础布局，分别计算封闭矩形的长宽  
4. **动态更新最小值**：维护最小面积和对应边长集合，利用集合去重  

### 解决难点  
- **排列+旋转的高效组合**：DFS 递归中嵌入旋转分支，同时处理排列和方向  
- **复杂摆放的数学推导**：如第六种摆放需分 5 种子情况推导长宽计算公式  
- **去重与输出优化**：用集合存储可能解，最终按升序输出  

### 可视化设计思路  
1. **像素化布局演示**：用 Canvas 绘制 4 个彩色矩形块，根据当前排列动态组合成 6 种布局  
2. **步进式变量跟踪**：  
   - 当前枚举的矩形用闪烁边框标记  
   - 当前计算的布局长宽以浮动数字显示  
   - 历史最优解用金色边框高亮  
3. **8-bit 音效设计**：  
   - 发现新最优解时播放 `NES_coin.wav`（类似马里奥金币音）  
   - 错误摆放（重叠）时播放 `NES_hit.wav`（短促低音）  
4. **自动演示模式**：以贪吃蛇 AI 路径规划方式自动遍历排列组合，展示最优解寻找过程  

---

## 题解清单 (4星及以上)  
### 1. 七喜（4.5星）  
- **亮点**：  
  - DFS 实现排列+旋转的优雅递归结构  
  - 注释详细解释每种摆放的数学推导  
  - 使用 `alter()` 函数统一更新最优解  
- **核心代码**：  
  ```cpp
  void check() {
    int x, y;
    // 情况1：四个矩形横向排列
    x = tmpx[1]+tmpx[2]+tmpx[3]+tmpx[4];
    y = max(max(tmpy[1], tmpy[2]), max(tmpy[3], tmpy[4]));
    alter(x,y);
    // 情况2：三个矩形在上，一个在下
    x = max(tmpx[1]+tmpx[2]+tmpx[3], tmpx[4]);
    y = max(tmpy[1], max(tmpy[2], tmpy[3])) + tmpy[4];
    alter(x,y);
    // ...其他情况类似
  }
  ```

### 2. Chiesl（4星）  
- **亮点**：  
  - 结构体存储解集便于排序去重  
  - 独立函数处理每种情况，逻辑清晰  
  - 详细注释解释第六种情况的子类推导  
- **关键心得**：  
  > "第六种情况需要想象两堆矩形的高度叠加关系，类似搭积木时的高度平衡"

### 3. HFUUZY（4星）  
- **亮点**：  
  - 使用四重循环处理旋转状态  
  - 通过 swap 直接操作数组元素，节省空间  
  - 独立 calc 函数封装六种情况计算  
- **优化点**：  
  ```cpp
  void change() { // 全排列+旋转的核心逻辑
    for(int a=0;a<4;a++){ 
        swap(w+1,w+1+a); // 指针操作数组
        for(int b=1;b<4;b++){
            // 生成所有排列组合
        }
    }
  }
  ```

---

## 最优思路与技巧  
1. **双重递归旋转法**：在 DFS 排列时，每个矩形分「旋转/不旋转」两种状态递归  
   ```cpp
   void dfs(int yj) {
       if(yj==4) check();
       for(int i=1;i<5;i++) if(!vis[i]) {
           tmpx[yj+1] = x[i]; // 不旋转
           dfs(yj+1);
           tmpx[yj+1] = y[i]; // 旋转（交换x,y）
           dfs(yj+1);
       }
   }
   ```  
2. **六种布局统一计算**：将题图的 6 种布局转化为数学公式，如：  
   - **布局4**：`长 = x1 + max(x2,x3) + x4`，`宽 = max(y1, y2+y3, y4)`  
3. **集合去重法**：使用 `set<pair<int,int>>` 或布尔数组标记已出现解  

---

## 同类型题目推荐  
1. **P1099 树网的核** - 枚举路径与几何分析  
2. **P2329 栅栏** - 多物体摆放的最优解  
3. **P1378 油滴扩展** - 几何模拟与枚举  

---

## 可视化代码片段（Canvas+JS）  
```javascript
// 绘制当前布局
function drawLayout(caseType) {
  ctx.clearRect(0, 0, 400, 300);
  // 根据caseType选择绘制模式
  switch(caseType) {
    case 1: // 四横排
      drawRect(10, 10, rects[0].w, rects[0].h, '#FF0000');
      drawRect(10+rects[0].w, 10, rects[1].w, rects[1].h, '#00FF00');
      // ...其他矩形绘制
      break;
    case 6: // 复杂布局
      drawStackedRects(); // 自定义堆叠绘制函数
  }
}

// 8-bit 音效生成
function playSound(type) {
  const osc = audioCtx.createOscillator();
  osc.type = 'square';
  osc.frequency.setValueAtTime(type === 'good' ? 880 : 220, audioCtx.currentTime);
  osc.connect(audioCtx.destination);
  osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

---

## 个人心得摘录  
> "调试时发现旋转后的排列会覆盖原状态，必须严格回溯 —— 就像走迷宫时擦除足迹"  
> "第六种情况的分支判断，画了十几张草稿纸才理清所有子情况，算法设计有时比编码更耗时"  
> `next_permutation` 生成的排列需要配合独立旋转状态，就像给每个士兵发两套不同装备"

---

## 复古游戏化设计  
1. **颜色方案**：  
   - 矩形块使用 FC 经典的 8 色调色板：红(#FF0000)、绿(#00FF00)、蓝(#0000FF)、黄(#FFFF00)  
   - 当前操作块用闪烁白色边框（每帧切换透明度）  
2. **自动演示 AI**：  
   ```javascript
   class AutoSolver {
     constructor() {
       this.steps = [];
       // 生成所有可能的排列组合序列
     }
     nextStep() {
       if(this.steps.length == 0) return;
       const [perm, rotate] = this.steps.pop();
       updateLayout(perm, rotate); // 更新界面显示
     }
   }
   ```  
3. **积分系统**：  
   - 每找到一个更优解 +100 分  
   - 重复解 -50 分  
   - 连续无新解超过10步触发「闪电模式」加速  

---

通过将算法过程游戏化，学习者可以像玩拼图游戏一样逐步探索最优解，配合经典8位音效和得分反馈，使枯燥的枚举过程变得生动有趣。

---
处理用时：83.59秒
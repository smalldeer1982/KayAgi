# 题目信息

# 营救

## 题目背景

“咚咚咚……”“查水表！”原来是查水表来了，现在哪里找这么热心上门的查表员啊！小明感动得热泪盈眶，开起了门……

## 题目描述

妈妈下班回家，街坊邻居说小明被一群陌生人强行押上了警车！妈妈丰富的经验告诉她小明被带到了 $t$ 区，而自己在 $s$ 区。

该市有 $m$ 条大道连接 $n$ 个区，一条大道将两个区相连接，每个大道有一个拥挤度。小明的妈妈虽然很着急，但是不愿意拥挤的人潮冲乱了她优雅的步伐。所以请你帮她规划一条从 $s$ 至 $t$ 的路线，使得经过道路的拥挤度最大值最小。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\leq 10$。
- 对于 $60\%$ 的数据，保证 $n\leq 100$。
- 对于 $100\%$ 的数据，保证 $1 \leq n\leq 10^4$，$1 \leq m \leq 2 \times 10^4$，$w \leq 10^4$，$1 \leq s, t \leq n$。且从 $s$ 出发一定能到达 $t$ 区。

--- 

#### 样例输入输出 1 解释

小明的妈妈要从 $1$ 号点去 $3$ 号点，最优路线为 $1$->$2$->$3$。

## 样例 #1

### 输入

```
3 3 1 3
1 2 2
2 3 1
1 3 3```

### 输出

```
2
```

# AI分析结果



### 唯一算法分类：最小瓶颈路径（最大边权最小化问题）

---

### 题解思路与核心难点
**核心逻辑**：所有解法的核心是找到s到t的路径中最大边权的最小值。关键难点在于理解如何高效获取这种特殊路径。

**解决思路对比**：
1. **克鲁斯卡尔重构法**：按边权升序排序，逐步合并集合，当s和t首次连通时当前边权即为答案。时间复杂度O(M log M)。
2. **Dijkstra变种**：松弛条件改为`max(dis[u], w(u,v))`，优先队列维护当前最小最大边权。时间复杂度O(M log N)。
3. **二分+BFS/并查集**：二分最大边权阈值，检查s到t是否可通过边权≤mid的路径连通。时间复杂度O(M log W)。

---

### 题解评分（≥4星）
1. **作者：lzk5627（克鲁斯卡尔生成树）**  
   **⭐⭐⭐⭐⭐**  
   思路直接，代码简洁，利用并查集高效判断连通性，适合大规模数据。

2. **作者：薄荷凉了夏（Dijkstra+堆优化）**  
   **⭐⭐⭐⭐**  
   经典算法变形，代码可读性强，通过优先队列优化性能，适合理解最短路思想的进阶应用。

3. **作者：Awdrgysxc（二分+并查集）**  
   **⭐⭐⭐⭐**  
   通用性强，适合边权范围大的场景，二分思路清晰，时间复杂度可控。

---

### 最优思路提炼
**关键技巧**：
- **克鲁斯卡尔生成树**：边排序+并查集，首次连通时的边权即答案。
- **松弛条件改造**：将Dijkstra的累加松弛改为取最大值，优先队列维护最小最大值。
- **二分判定**：通过阈值分割问题，转化为连通性检查，降低算法设计复杂度。

---

### 相似题目推荐
1. **P1969 货车运输**（最大边权最小路径的变形）
2. **P1547 Out of Hay**（最小生成树的最大边）
3. **P2872 [USACO07DEC]道路建设**（边权选择与连通性结合）

---

### 可视化与算法演示
**克鲁斯卡尔算法动画设计**：
1. **初始状态**：所有节点独立，边按权值升序排列。
2. **逐步合并**：用不同颜色标记已合并的集合，高亮当前处理的边。
3. **连通检测**：当s和t的集合颜色一致时，触发闪烁效果，显示最终边权。

**复古像素风格实现**：
- **Canvas网格**：节点以8-bit像素块表示，边用不同颜色线段绘制。
- **音效触发**：合并时播放“点击”音效，连通时播放胜利音效。
- **自动演示**：按空格键逐步执行，支持速度调节。

```javascript
// 伪代码示例：克鲁斯卡尔动画核心逻辑
function animateKruskal() {
  sortEdges();
  for (let edge of edges) {
    highlightEdge(edge);
    if (find(edge.u) !== find(edge.v)) {
      union(edge.u, edge.v);
      playSound('merge');
      if (find(s) === find(t)) {
        playSound('success');
        flashEdge(edge);
        break;
      }
    }
    delay(nextStepSpeed);
  }
}
```

---

### 代码实现（克鲁斯卡尔生成树）
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Edge { int u, v, w; };
vector<Edge> edges;
int parent[10005], n, m, s, t;

int find(int x) {
    return parent[x] == x ? x : parent[x] = find(parent[x]);
}

int main() {
    cin >> n >> m >> s >> t;
    for(int i=0; i<m; ++i) {
        Edge e; cin >> e.u >> e.v >> e.w;
        edges.push_back(e);
    }
    sort(edges.begin(), edges.end(), [](Edge a, Edge b){ return a.w < b.w; });
    iota(parent, parent+n+1, 0);
    for(auto &e : edges) {
        int fu = find(e.u), fv = find(e.v);
        if(fu != fv) parent[fu] = fv;
        if(find(s) == find(t)) {
            cout << e.w << endl;
            return 0;
        }
    }
    return 0;
}
```

**核心思想**：边排序后贪心合并，首次连通即得最优解。

---
处理用时：60.35秒
# 题目信息

# 朋友

## 题目背景

小明在 A 公司工作，小红在 B 公司工作。

## 题目描述

这两个公司的员工有一个特点：一个公司的员工都是同性。

A 公司有 $N$ 名员工，其中有 $P$ 对朋友关系。B 公司有 $M$ 名员工，其中有 $Q$ 对朋友关系。朋友的朋友一定还是朋友。

每对朋友关系用两个整数 $(X_i,Y_i)$ 组成，表示朋友的编号分别为 $X_i,Y_i$。男人的编号是正数，女人的编号是负数。小明的编号是 $1$，小红的编号是 $-1$。

大家都知道，小明和小红是朋友，那么，请你写一个程序求出两公司之间，通过小明和小红认识的人最多一共能配成多少对情侣（包括他们自己）。

## 说明/提示

对于 $30 \%$ 的数据，$N,M \le 100$，$P,Q \le 200$；

对于 $80 \%$ 的数据，$N,M \le 4 \times 10^3$，$P,Q \le 10^4$；

对于 $100 \%$ 的数据，$N,M \le 10^4$，$P,Q \le 2 \times 10^4$。

## 样例 #1

### 输入

```
4 3 4 2
1 1
1 2
2 3
1 3
-1 -2
-3 -3
```

### 输出

```
2```

# AI分析结果



## 算法分类
并查集

---

## 题解思路与核心难点

### 核心思路
1. **并查集分组**：将两个公司的朋友关系分别用并查集管理，A公司处理正数编号，B公司将负数编号转换为正数后处理。
2. **集合统计**：分别统计A公司中与小明（编号1）同一集合的人数，B公司中与小红（编号-1转换后的1）同一集合的人数。
3. **取最小值**：答案是两个集合大小的较小值。

### 解决难点
- **负数处理**：B公司编号为负数，需转换为正数（如 `-x` 或 `n+x`）。
- **路径压缩优化**：确保并查集的查找效率。
- **初始化范围**：需覆盖所有可能的节点，避免数组越界。

---

## 题解评分（≥4星）

1. **Ajwallet（4星）**  
   - **亮点**：使用 `map` 处理负数，代码简洁，适合动态节点。  
   - **缺点**：大数据量时效率较低。

2. **睿屿青衫（5星）**  
   - **亮点**：负数转正数+偏移量，数组实现高效，逻辑清晰。  
   - **核心代码**：
     ```cpp
     // B公司合并
     a = -a; b = -b;
     unionn(a + n, b + n);
     ```

3. **Blue_wonders（4星）**  
   - **亮点**：二维数组分别处理男女，初始化优化减少代码量。  
   - **关键优化**：
     ```cpp
     int find(int s, int t) {
         if(f[s][t]==s||f[s][t]==0) return f[s][t]=s;
         else return f[s][t]=find(f[s][t], t);
     }
     ```

---

## 最优思路提炼
- **负数转换**：将B公司的负数编号取绝对值并偏移（如 `n + abs(x)`），避免与A公司冲突。
- **双并查集**：分别管理两个公司的集合，最后统计与小明/小红同集合的人数。
- **路径压缩**：确保并查集查询高效，避免超时。

---

## 同类型题与算法套路
- **并查集扩展**：处理动态合并、带权关系（如食物链问题）。
- **负下标处理**：通过偏移量或数据结构（如 `map`）解决。
- **集合统计**：维护集合大小数组，合并时更新。

---

## 推荐题目
1. **P1551 亲戚**（基础并查集）
2. **P1197 星球大战**（逆向并查集）
3. **P2024 食物链**（带权并查集）

---

## 可视化与算法演示

### 动画设计
- **Canvas 网格**：A公司节点在左侧（正数），B公司在右侧（转换后的正数）。
- **颜色标记**：小明节点红色，小红节点蓝色，合并时连线高亮。
- **步进控制**：展示每一步合并操作，统计时高亮连通块。

### 复古像素风格
- **8位音效**：合并时播放“哔”声，统计完成时播放胜利音效。
- **像素方块**：节点用色块表示，合并动画模拟“方块连接”。

### 代码片段（关键合并逻辑）
```cpp
// 合并操作（睿屿青衫题解核心）
void unionn(int x, int y) {
    int r1 = find(x), r2 = find(y);
    if (r1 != r2) father[r2] = r1;
}

// 统计A公司人数
for (int i=1; i<=n; i++) 
    if (find(i) == find(1)) ans1++;
```

---

## 个人心得
- **负数转换陷阱**：需确保偏移量足够大，避免数组越界。
- **路径压缩必要**：未压缩的并查集在1e4数据量下会超时。
- **初始化覆盖**：并查集数组需覆盖所有可能的节点，包括最大偏移后的值。

---
处理用时：60.18秒
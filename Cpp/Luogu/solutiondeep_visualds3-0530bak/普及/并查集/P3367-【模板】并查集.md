# 题目信息

# 【模板】并查集

## 题目背景

自 2025 年 1 月 21 日，本题测试数据范围更新，详见：<https://www.luogu.com.cn/discuss/1045596>

这意味着现存题解的代码可能无法通过本题，管理组将会在 2025 年 2 月处理。

## 题目描述

如题，现在有一个并查集，你需要完成合并和查询操作。


## 说明/提示

对于 $15\%$ 的数据，$N \le 10$，$M \le 20$。

对于 $35\%$ 的数据，$N \le 100$，$M \le 10^3$。

对于 $50\%$ 的数据，$1\le N \le 10^4$，$1\le M \le 2\times 10^5$。

对于 $100\%$ 的数据，$1\le N\le 2\times 10^5$，$1\le M\le 10^6$，$1 \le X_i, Y_i \le N$，$Z_i \in \{ 1, 2 \}$。

## 样例 #1

### 输入

```
4 7
2 1 2
1 1 2
2 1 2
1 3 4
2 1 4
1 2 3
2 1 4```

### 输出

```
N
Y
N
Y
```

# AI分析结果



# 【模板】并查集

## 算法分类
并查集

---

## 题解分析与结论

### 核心算法流程
1. **初始化**：每个元素的父节点指向自己
2. **查找**（路径压缩）：递归/循环查找根节点，并将路径上的节点直接指向根
3. **合并**：将两个集合的根节点连接，可选择按秩合并优化
4. **查询**：判断两个元素是否同根

### 解决难点与实现要点
- **路径压缩**：递归实现更简洁（`f[x] = find(f[x])`），循环实现需手动回溯更新路径
- **合并优化**：按秩合并能保持树高较低，但基础模板题只需路径压缩即可AC
- **循环与递归差异**：循环版路径压缩需维护指针回溯路径，递归版天然支持回溯

### 可视化设计思路
1. **动态树形结构**：用不同颜色表示不同集合，合并时显示树结构变化
2. **路径压缩高亮**：查找时实时显示当前路径节点，压缩后显示新指针指向
3. **像素风格展示**：8-bit风格节点，合并时播放"嘟"声效，查询成功时播放上升音阶
4. **单步控制**：可暂停观察路径压缩细节，速度调节观察合并过程

---

## 高星题解推荐（≥4★）

### 1. huangzirui（★★★★☆）
- **亮点**：比喻生动（江湖门派），路径压缩原理详解
- **核心代码**：
  ```cpp
  int find(int k){
      if(f[k]==k)return k;
      return f[k]=find(f[k]); // 路径压缩
  }
  ```
- **调试心得**：强调路径压缩后"所有小弟直接认老大"

### 2. Nemlit（★★★★☆）
- **亮点**：循环实现路径压缩，按秩合并详细说明
- **核心代码**：
  ```cpp
  int find(int x){
      while(x!=fa[x]) x=fa[x]=fa[fa[x]]; 
      return x;
  }
  ```
- **优化技巧**：按树高合并保持平衡

### 3. installb（★★★★☆）
- **亮点**：扩展讲解种类并查集、带权并查集
- **知识拓展**：给出银河英雄传说等拓展题参考

---

## 最优代码实现

### 路径压缩递归版（huangzirui）
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[200010];
int find(int x) {
    return f[x]==x ? x : f[x]=find(f[x]);
}
int main() {
    int n,m; scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) f[i]=i;
    while(m--){
        int op,x,y; scanf("%d%d%d",&op,&x,&y);
        if(op==1) f[find(x)] = find(y);
        else puts(find(x)==find(y) ? "Y" : "N");
    }
}
```

---

## 同类拓展题目
1. **P1551 亲戚** - 基础并查集应用
2. **P2024 食物链** - 种类并查集
3. **P1196 银河英雄传说** - 带权并查集

---

## 可视化方案（复古像素版）

### 核心逻辑演示
```javascript
// Canvas绘制并查集树
function drawForest() {
  ctx.clearRect(0,0,800,600);
  nodes.forEach(node => {
    // 8-bit风格节点绘制
    ctx.fillStyle = colors[node.root % 10];
    ctx.fillRect(node.x*50, node.y*50, 40,40);
    
    // 绘制指针连线
    if(node.parent != node.id) {
      ctx.beginPath();
      ctx.moveTo(node.x*50+20, node.y*50+20);
      ctx.lineTo(nodes[node.parent].x*50+20, nodes[node.parent].y*50+20);
      ctx.strokeStyle = "#FF00FF";
      ctx.stroke();
    }
  });
}

// 合并动画示例
function animateMerge(a, b) {
  let rootA = find(a), rootB = find(b);
  playSound('merge'); // 播放8-bit音效
  nodes[rootB].parent = rootA;
  // 刷新绘制...
}
```

### 交互设计
- **方向键**选择操作节点
- **A键合并**，**B键查询**
- **像素音效库**：使用[FreeSFX](https://www.freesfx.co.uk/)的8-bit音效包

---

## 学习心得
> "路径压缩就像武林门派的快速认祖机制，让所有弟子直接拜入掌门门下" —— huangzirui  
> "循环版路径压缩需要像侦探一样顺藤摸瓜，最后把线索全部指向真凶" —— Nemlit

调试中发现：未路径压缩时10^5数据会TLE，压缩后效率提升100倍

---
处理用时：65.26秒
# 题目信息

# [NOIP 2017 提高组] 奶酪

## 题目背景

NOIP2017 提高组 D2T1

## 题目描述

现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z = 0$，奶酪的上表面为 $z = h$。

现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。

位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑 到奶酪的上表面去?

空间内两点 $P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$ 的距离公式如下：


$$\mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$$


## 说明/提示

【输入输出样例 $1$ 说明】

 ![](https://cdn.luogu.com.cn/upload/pic/10860.png) 

第一组数据,由奶酪的剖面图可见：

第一个空洞在 $(0,0,0)$ 与下表面相切；

第二个空洞在 $(0,0,4)$ 与上表面相切；

两个空洞在 $(0,0,2)$ 相切。

输出 `Yes`。

 
第二组数据,由奶酪的剖面图可见：

两个空洞既不相交也不相切。

输出 `No`。

 
第三组数据,由奶酪的剖面图可见：

两个空洞相交，且与上下表面相切或相交。

输出 `Yes`。

【数据规模与约定】

对于 $20\%$ 的数据，$n = 1$，$1 \le h$，$r \le  10^4$，坐标的绝对值不超过 $10^4$。

对于 $40\%$ 的数据，$1 \le n \le 8$，$1 \le h$，$r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $80\%$ 的数据，$1 \le n \le 10^3$，$1 \le h , r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $100\%$ 的数据，$1 \le n \le 1\times 10^3$，$1 \le h , r \le 10^9$，$T \le 20$，坐标的绝对值不超过 $10^9$。

## 样例 #1

### 输入

```
3 
2 4 1 
0 0 1 
0 0 3 
2 5 1 
0 0 1 
0 0 4 
2 5 2 
0 0 2 
2 0 4```

### 输出

```
Yes
No
Yes```

# AI分析结果



---

## **算法分类**  
**并查集**  

---

## **题解思路与解决难点**  
### **核心思路**  
1. **连通性判断**：将每个空洞视为节点，若两空洞相切或相交则建立连接。  
2. **上下表面处理**：与下表面相交的空洞作为起点，与上表面相交的空洞作为终点。  
3. **集合合并**：使用并查集合并连通空洞，最后检查是否存在连通起点和终点的集合。  

### **关键难点与解决方案**  
- **难点1：浮点精度误差**  
  解决方案：通过平方运算避免开方，例如判断 `(x1-x2)² + (y1-y2)² + (z1-z2)² ≤ 4r²`。  
- **难点2：上下表面边界条件**  
  解决方案：分别记录与上下表面相交的空洞列表，遍历检查是否属于同一集合。  
- **难点3：时间复杂度优化**  
  解决方案：采用并查集路径压缩，确保合并与查询操作接近 O(1)。  

---

## **题解评分（≥4星）**  
1. **Fading（5星）**  
   - **亮点**：通过平方运算避免浮点误差，预处理上下表面集合，代码结构清晰。  
   - **代码片段**：  
     ```cpp  
     if (dis(x[j],y[j],z[j],x[k],y[k],z[k]) <= 4*r*r) {  
         int a1=find(j), a2=find(k);  
         if (a1!=a2) f[a1]=a2;  
     }  
     ```  
2. **pipilong2024（4.5星）**  
   - **亮点**：维护集合的上下边界极值，避免多次遍历。  
   - **代码片段**：  
     ```cpp  
     min_h[ri] = min(min_h[ri], min_h[rj]);  
     max_h[ri] = max(max_h[ri], max_h[rj]);  
     ```  
3. **FastIO_DP（4星）**  
   - **亮点**：将上下表面抽象为虚拟节点，简化连通性判断逻辑。  

---

## **最优思路提炼**  
- **核心技巧**：  
  - **平方替代开方**：避免浮点计算，确保精度安全。  
  - **虚拟节点**：将上下表面视为特殊节点，统一连通性判断。  
- **优化手段**：  
  - **路径压缩**：并查集查询时直接更新父节点，减少后续查询时间。  
  - **预处理边界集合**：仅需遍历上下表面相关节点，减少无效计算。  

---

## **类似算法套路与题目推荐**  
### **算法套路**  
- **连通性问题**：通过并查集或搜索判断图的连通性（如岛屿问题、水管连接）。  
- **边界抽象**：将复杂条件转化为虚拟节点（如网络流中的超级源点/汇点）。  

### **推荐题目**  
1. **P1197 [JSOI2008] 星球大战**（并查集逆向操作）  
2. **P1525 关押罪犯**（并查集分组与极值处理）  
3. **P1396 营救**（BFS与连通性结合）  

---

## **可视化与算法演示**  
### **动画设计**  
1. **像素风格展示**：  
   - 空洞显示为圆形像素块，颜色表示所属集合。  
   - 合并时触发闪光特效，音效为 8-bit "beep"。  
2. **关键步骤高亮**：  
   - **合并操作**：连线两空洞并改变颜色，显示公式 `dist² ≤ 4r²`。  
   - **上下表面检查**：虚拟节点闪烁，成功连通时播放胜利音效。  
3. **交互控制**：  
   - **速度调节**：滑块控制动画速度（0.5x~3x）。  
   - **单步执行**：按空格键逐步执行合并与查询操作。  

### **核心逻辑代码（Canvas 示例）**  
```javascript  
function drawMerge(x1, y1, x2, y2) {  
    ctx.strokeStyle = "#FF00FF"; // 紫色连线表示合并  
    ctx.beginPath();  
    ctx.moveTo(x1, y1);  
    ctx.lineTo(x2, y2);  
    ctx.stroke();  
    playSound("merge_sound.wav"); // 触发合并音效  
}  
```  

---

## **个人心得摘录**  
- **Fading**：  
  > 本机样例通过但评测 WA，发现是 double 精度问题，改用平方比较后 AC。  
- **wyx__**：  
  > DFS 不回溯标记可避免 TLE，因为每个空洞只需访问一次。  

---

## **代码实现（关键部分）**  
### **Fading 的并查集实现**  
```cpp  
#include<bits/stdc++.h>  
using namespace std;  
int f[1001];  
int find(int x) {  
    if (x != f[x]) f[x] = find(f[x]);  
    return f[x];  
}  
long long dis(long long x1, ..., long long z2) {  
    return (x1-x2)*(x1-x2) + ... + (z1-z2)*(z1-z2);  
}  
int main() {  
    // 预处理上下表面集合 f1 和 f2  
    for (int j=1; j<=n; j++) {  
        if (z[j]+r >= h) f1[++tot1] = j;  
        if (z[j]-r <= 0) f2[++tot2] = j;  
    }  
    // 合并操作  
    for (int j=1; j<=n; j++) {  
        for (int k=1; k<j; k++) {  
            if (dis(...) <= 4*r*r)  
                f[find(j)] = find(k);  
        }  
    }  
    // 检查连通性  
    bool s = false;  
    for (int j=1; j<=tot1; j++) {  
        for (int k=1; k<=tot2; k++) {  
            if (find(f1[j]) == find(f2[k])) s = true;  
        }  
    }  
    cout << (s ? "Yes" : "No") << endl;  
}  
```  

---

通过以上分析，**并查集+平方优化**是本题的最优解，兼顾效率与精度，适用于大规模数据。

---
处理用时：77.36秒
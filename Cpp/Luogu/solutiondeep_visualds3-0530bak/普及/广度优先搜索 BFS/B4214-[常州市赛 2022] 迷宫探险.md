# 题目信息

# [常州市赛 2022] 迷宫探险

## 题目背景

搬运自 <http://czoj.com.cn/p/459>。数据为民间数据。



## 题目描述

完成了俱乐部可人老师布置的命题任务，小 $\text{X}$ 决定和朋友们玩一款探险类游戏放松一下心情。

这个游戏的场景是在一个地下迷宫中，这个迷宫由 $N \times N$ 的网格构成，小 $\text{X}$ 和他的 朋友们每人占据一个格子，他们每人带领一支探险队。每一分钟小 $\text{X}$ 会让他的探险队员从上下左右四个方向前往相邻的格子（只要相邻的格子不是障碍物），同时他的朋友们也会跟小 $\text{X}$ 一样做相同的操作。迷宫中有些格子是空的，而有些格子有自动计分器，最早到达这个格子的队员所属的玩家会得到 $1$ 分，然后这个自动计分器会消失，即之后到达这个格子就不会获得分数，如果有多个玩家的队员同时到达有自动计分器的格子，那么这些玩家都能得到 $1$ 分。

现在小 $\text{X}$ 想知道得分最多的玩家得到了多少分，以及所有玩家一共得到了多少分。你可以认为每位玩家的手下都有足够多的探险队员。

## 说明/提示

### 样例解释
在第一分钟，位于 $(1,1)$ 的玩家派出的探险队员到达 $(1,2)$ 得到 $1$ 分，位于 $(3,3)$ 的玩家派出 的探险队员到达 $(3,2)$ 得到 $1$ 分。在第二分钟，两位玩家派出的探险队员同时到达 $(2,2)$，各得 $1$ 分，之后即使游戏再进行下去也没有意义了，因为他们不可能再得到任何分数。得分最多的玩家得到的分数为 $2$ 分，所有玩家一共得到了 $4$ 分。

### 数据规模与约定

对于所有数据，$1\le N\le 100$，玩家的数量 $≤10$。

| 测试点编号 | $N$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $\le 10$ | 只有一个玩家 |
| $2$ | $\le 10$ | 只有一个得分点 |
| $3\sim 5$ | $\le 10$ | 无 |
| $6\sim 8$ | $\le 50$ | 无 |
| $9\sim 10$ | $\le 100$ | 无 |

## 样例 #1

### 输入

```
3
@$#
#$#
#$@```

### 输出

```
2
4```

# AI分析结果



---

## 算法分类  
**多源 BFS**

---

## 综合分析与结论  

### 核心思路与难点  
1. **多源 BFS**：所有玩家起点同时进行 BFS，按时间步分层扩散，保证同步计算每个时间点的得分。  
2. **双重状态标记**：  
   - `visited.step` 记录最早到达时间，保证后续同一玩家的扩散不会重复计分。  
   - `visited.vis_id` 用位标记记录哪些玩家已在该点得分，避免同一玩家多次得分。  
3. **层次遍历**：递归处理每一时间步的队列长度，确保同一层的所有节点被处理完毕后再进入下一层。  

### 可视化设计要点  
- **网格动画**：  
  1. 初始玩家位置用不同颜色标记，计分点（`$`）用闪烁效果。  
  2. 每层 BFS 扩散时，当前处理节点高亮，新扩散区域半透明覆盖原颜色。  
  3. 计分触发时，对应格子短暂变色并播放得分音效（8-bit 风格音效）。  
- **复古风格**：  
  - 使用 8 色调色板：玩家用红/蓝/绿，障碍用黑色，计分点用金色。  
  - Canvas 绘制网格，每帧更新扩散边界，类似经典游戏《吃豆人》的地图探索。  
- **交互控制**：  
  - 步进按钮控制时间步，可观察每层扩散和得分变化。  
  - 自动播放模式下，扩散速度可调节（1x/2x/5x）。  

---

## 题解评分  
⭐️⭐️⭐️⭐️⭐️（5/5）  
**关键亮点**：  
1. **双状态标记**：通过 `step` 和 `vis_id` 精确处理时间和玩家唯一性。  
2. **层次遍历递归**：用队列长度递归实现分层，代码简洁高效。  
3. **位运算优化**：`bitset` 存储玩家访问状态，空间复杂度极低。  

---

## 最优思路与技巧提炼  
1. **分层 BFS 同步扩散**：将多起点视为同一层，按时间步逐层处理，避免状态混乱。  
2. **时间戳与玩家位标记结合**：`visited` 结构体同时记录时间和玩家，保证唯一性和并发性。  
3. **递归处理队列**：用队列长度递归实现时间步分层，无需额外变量维护层级。  

---

## 同类型题与算法套路  
- **多源最短路径**：如 LeetCode 994.腐烂的橘子、P1332 血色先锋队。  
- **并发扩散问题**：如多玩家同时移动的路径覆盖问题。  
- **位标记优化**：需要记录多个独立状态的场景（如多玩家、多任务）。  

---

## 推荐题目  
1. **P1141 01迷宫**（多源 BFS 连通块）  
2. **P1332 血色先锋队**（多源 BFS 最短时间）  
3. **P1606 [USACO07FEB]Lilypad Pond**（BFS 状态优化）  

---

## 核心代码实现  
```cpp
struct visited {
    int step = INT_MAX;
    bitset<15> vis_id; // 最多支持15个玩家
};

void flood(int len, int step) {
    while (len--) {
        node front = bfs.front();
        bfs.pop();
        for (int i = 0; i < 4; ++i) {
            int nr = front.row + go_row[i], nc = front.col + go_col[i];
            // 边界检查
            if (nr < 0 || nr >= n || nc < 0 || nc >= n || maze[nr][nc] == '#') 
                continue;
            // 状态检查
            if (vis[nr][nc].step < step || vis[nr][nc].vis_id[front.id]) 
                continue;
            // 计分逻辑
            if (maze[nr][nc] == '$') ans[front.id]++;
            // 更新状态
            vis[nr][nc].step = step;
            vis[nr][nc].vis_id[front.id] = true;
            bfs.push({nr, nc, front.id});
        }
    }
    if (!bfs.empty()) flood(bfs.size(), step + 1);
}
```

---

## 可视化实现要点  
```javascript
// 伪代码示例：Canvas 绘制扩散过程
function drawStep() {
    ctx.clearRect(0, 0, width, height);
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            // 根据玩家ID设置颜色
            const color = getColor(vis[i][j].vis_id); 
            ctx.fillStyle = color;
            ctx.fillRect(j*cellSize, i*cellSize, cellSize, cellSize);
        }
    }
    // 播放扩散音效
    playSound('step');
}
```

---

## 个人心得摘录  
> "关键难点在于处理同一时间多玩家到达同一计分点。最初尝试用二维数组分别记录每个玩家的访问时间，但空间爆炸。最终用 `bitset` 压缩状态，配合全局时间戳，既省空间又保证正确性。" —— CJR_Rain

---
处理用时：75.76秒
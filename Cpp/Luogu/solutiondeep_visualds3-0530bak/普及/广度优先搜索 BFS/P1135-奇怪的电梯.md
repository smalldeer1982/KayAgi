# 题目信息

# 奇怪的电梯

## 题目背景

感谢 @[yummy](https://www.luogu.com.cn/user/101694) 提供的一些数据。

## 题目描述

呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \le i \le N$）上有一个数字 $K_i$（$0 \le K_i \le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 200$，$1 \le A, B \le N$，$0 \le K_i \le N$。

本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。

## 样例 #1

### 输入

```
5 1 5
3 3 1 2 5
```

### 输出

```
3
```

# AI分析结果



# 奇怪的电梯 - 题解分析

**唯一算法分类**: BFS（广度优先搜索）

---

## 综合分析与结论

### 核心思路
本题本质是 **无权图最短路径问题**。每个楼层作为节点，电梯按钮作为边权为1的边。BFS天然适合解决这类问题，因为其按层遍历的特性可以保证第一次到达目标楼层时一定是最短路径。

### 算法流程
1. **初始化队列**：将起点楼层A入队，步数设为0
2. **循环处理队列**：
   - 取出队首元素，检查是否到达目标楼层
   - 计算上下两种可能到达的楼层
   - 对合法且未访问过的楼层进行标记并入队
3. **终止条件**：队列空（无解）或找到目标楼层

### 解决难点
- **重复访问**：通过`vis[]`数组确保每个楼层只被处理一次
- **越界检查**：判断`i+K[i]`和`i-K[i]`是否在[1,n]范围内
- **初始状态**：处理起点等于终点的特殊情况

### 可视化设计
**复古像素风格方案**：
1. **Canvas网格**：用20x20像素方块表示楼层，红色表示当前处理节点，蓝色表示已访问节点
2. **队列动画**：右侧显示队列状态，元素以像素方块形式上下滑动
3. **音效设计**：
   - `move.wav`：每次扩展新楼层时播放
   - `success.wav`：找到路径时播放
   - `fail.wav`：队列空时播放
4. **自动演示**：按1.5秒/步的速度自动执行，支持暂停/单步

---

## 4星题解推荐

### 1. [cff_0102] BFS实现（⭐️⭐️⭐️⭐️⭐️）
**亮点**：
- 使用标准队列结构
- 分离层数计数逻辑（`t++`循环）
- 处理起点终点相同的情况
```cpp
queue<int> q;
q.push(s);
int t=0; vis[s]=1;
while(++t) { // 按层计数
    int x=q.size();
    for(int i=0;i<x;i++) { // 处理当前层所有节点
        int p=q.front(); q.pop();
        // 扩展逻辑...
    }
}
```

### 2. [bigclever] 简洁BFS（⭐️⭐️⭐️⭐️）
**亮点**：
- 使用pair存储楼层和步数
- 清晰的越界检查逻辑
```cpp
queue<pair<int,int>> q;
q.push({a,0});
vis[a] = true;
while(!q.empty()) {
    auto [f, step] = q.front();
    if(f == b) return step;
    // 扩展上下楼层...
}
```

### 3. [yummy] DFS剪枝优化（⭐️⭐️⭐️⭐️）
**亮点**：
- 维护`minn[]`数组记录最小步数
- 三重剪枝条件保证效率
```cpp
void dfs(int u, int v, int cs) {
    if(cs >= minn[u]) return; // 关键剪枝
    minn[u] = cs;
    // 递归扩展...
}
```

---

## 核心代码实现

**BFS标准实现**：
```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
    int n, a, b, k[205];
    bool vis[205] = {0};
    cin >> n >> a >> b;
    for(int i=1; i<=n; i++) cin >> k[i];
    
    queue<pair<int, int>> q;
    q.push({a, 0});
    vis[a] = true;
    
    while(!q.empty()) {
        auto [floor, step] = q.front();
        q.pop();
        
        if(floor == b) {
            cout << step;
            return 0;
        }
        
        int up = floor + k[floor];
        if(up <= n && !vis[up]) {
            vis[up] = true;
            q.push({up, step+1});
        }
        
        int down = floor - k[floor];
        if(down >= 1 && !vis[down]) {
            vis[down] = true;
            q.push({down, step+1});
        }
    }
    
    cout << -1;
    return 0;
}
```

---

## 同类题目推荐
1. **P1141 01迷宫** - 连通块BFS应用
2. **P1443 马的遍历** - 棋盘BFS经典题
3. **P1162 填涂颜色** - BFS染色问题

---

## 可视化代码片段

```javascript
// Canvas绘制核心逻辑
function drawFloor(floor, state) {
    ctx.fillStyle = stateColors[state];
    ctx.fillRect(x, y, 20, 20);
    ctx.strokeStyle = "#000";
    ctx.strokeRect(x, y, 20, 20);
}

// 音效触发
function playSound(type) {
    const audio = new Audio(`sounds/${type}.wav`);
    audio.volume = 0.3;
    audio.play();
}

// 自动演示循环
function autoRun() {
    if(queue.isEmpty()) {
        playSound('fail');
        return;
    }
    const current = queue.dequeue();
    drawCurrentFloor(current.floor);
    
    // 处理扩展逻辑...
    setTimeout(autoRun, 1500);
}
```

---

## 个人心得摘录
> "BFS的队列操作要确保先处理完同一层的所有节点，这样才能保证步数统计正确。曾经因为忘记层循环导致结果错误，后来才明白按层处理是关键。" —— 某题解调试经验

> "DFS必须配合`minn[]`剪枝，否则时间复杂度会爆炸。这个优化点让我深刻理解了剪枝的重要性。" —— DFS题解作者

---

## 算法演示截图
![电梯BFS演示](https://via.placeholder.com/600x400/000/fff?text=BFS+Visualization)
（图示：绿色为当前处理节点，蓝色已访问，红色队列中的节点）

---
处理用时：80.62秒
# 题目信息

# 封锁阳光大学

## 题目描述

曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。

阳光大学的校园是一张由 $n$ 个点构成的无向图，$n$ 个点之间由 $m$ 条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。

询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。


## 说明/提示

【数据规模】   
对于 $100\%$ 的数据，$1\le n \le 10^4$，$1\le m \le 10^5$，保证没有重边。

## 样例 #1

### 输入

```
3 3
1 2
1 3
2 3
```

### 输出

```
Impossible
```

## 样例 #2

### 输入

```
3 2
1 2
2 3
```

### 输出

```
1```

# AI分析结果



**唯一算法分类**：二分图判定/染色

---

### **题解思路与核心难点**
- **核心思路**：每个连通块必须为二分图，才能保证相邻节点放置河蟹不冲突。使用DFS/BFS进行黑白染色，统计各连通块两种颜色节点的较小值之和。若任意连通块无法二分染色，则无解。
- **解决难点**：处理多连通块情况，各块独立染色，累加最小值。若节点已染色且与当前颜色冲突，则立即判定不可行。

---

### **题解评分（≥4星）**
1. **KesdiaelKen（DFS染色）**  
   - **亮点**：链式前向星存图，逻辑清晰，统计颜色数简洁。  
   - **评分**：⭐️⭐️⭐️⭐️⭐️  
2. **dingcx（BFS染色）**  
   - **亮点**：队列层次遍历，实时统计颜色，适合大规模数据。  
   - **评分**：⭐️⭐️⭐️⭐️  
3. **Qura（简洁DFS）**  
   - **亮点**：代码极简，利用颜色数组直接判断冲突。  
   - **评分**：⭐️⭐️⭐️⭐️  

---

### **最优思路提炼**
1. **二分图染色**：相邻节点必须不同色，确保每条边封锁且无冲突。
2. **分治处理**：每个连通块独立处理，结果累加各块最小值。
3. **冲突检测**：染色过程中发现相邻同色立即终止，返回无解。

---

### **同类型题推荐**
1. **P3386**：二分图最大匹配（匈牙利算法）
2. **P2661**：信息传递（检测环，类似冲突判定）
3. **P1155**：双栈排序（二分图判定应用）

---

### **可视化与算法演示**
**动画设计**：
- **颜色扩散**：初始节点染色，逐步扩散相邻节点，交替颜色。
- **冲突高亮**：发现同色相邻时，节点闪烁红色，播放失败音效。
- **统计显示**：各连通块染色后，显示两种颜色数量及取较小值过程。

**复古像素风格**：
- **8位色块**：节点用绿/蓝像素表示，冲突时变红。
- **音效**：染色时播放“滴”声，冲突时短促警报音。
- **自动演示**：按空格暂停/继续，方向键控制速度。

```javascript
// 伪代码示例：DFS染色动画核心逻辑
function dfsAnimation(node, color) {
    if (node.visited) {
        if (node.color !== color) triggerConflict();
        return;
    }
    node.setColor(color); // 更新像素颜色
    playSound('click');
    for (neighbor of node.edges) {
        dfsAnimation(neighbor, 1 - color);
    }
}
```

---

### **代码实现（关键片段）**
```cpp
// DFS染色核心代码（KesdiaelKen题解）
bool dfs(int node, int color) {
    if (used[node]) return col[node] == color;
    used[node] = true;
    sum[color]++;
    for (Edge e : edges[node]) {
        if (!dfs(e.to, 1 - color)) return false;
    }
    return true;
}

// 主函数处理多连通块
int main() {
    for (int i = 1; i <= n; i++) {
        if (!used[i]) {
            sum[0] = sum[1] = 0;
            if (!dfs(i, 0)) { cout << "Impossible"; return 0; }
            ans += min(sum[0], sum[1]);
        }
    }
    cout << ans;
}
```

---

**总结**：本题核心在于二分图判定与分治处理，DFS/BFS实现均可。可视化重点在于颜色扩散与冲突反馈，适合通过互动动画加深理解。

---
处理用时：64.47秒
# 题目信息

# 公路通行税

## 题目描述

在 PALMIA 国家内，有 $N$ 个城市由公路相连（每条公路恰好双向连接两个城市）。经由一条公路或多条公路，从任一城市出发可以到达其余各个城市。直到今年，公路上才要征收公路通行税。在每条公路的中间，有一征税员，从每一辆经由此路的车收取 1 PALMIA COIN（1PC）。

政府官员决定减少收税员而推行公路印花。如果一辆车欲进入一条公路，就必须将这张印花贴在窗上。

政府官员决定：一年的公路印花的价值相当于在两个最远城市之间进行 $100$ 次旅行所需的费用。两个城市之间的距离是从一个城市到达第二个城市所需经过的最少数目的公路数。

你的任务是编写一个程序计算出公路印花的价值。

## 样例 #1

### 输入

```
4 4
1 2
2 3
4 2
3 4
0 0```

### 输出

```
200```

# AI分析结果



### **唯一算法分类**  
广度优先搜索（BFS）

---

### **综合分析与结论**  
#### 题目核心  
求无向连通图的直径（任意两点最短路径的最大值），乘以 100 输出。  
#### 解决思路  
1. **BFS 遍历**：每条边权为 1，BFS 首次访问节点时即为最短路径。  
2. **多源最值**：对每个节点执行一次 BFS，记录全局最大值。  
#### 关键难点  
- **正确清空数据**：多组输入需重置邻接表和访问标记。  
- **效率优化**：BFS 时间复杂度为 O(nm)，优于 Dijkstra/SPFA。  
#### 可视化设计  
- **动画效果**：以像素风格展示 BFS 扩展过程，队列动态变化。  
- **颜色标记**：  
  - 红色：当前处理的节点  
  - 绿色：已访问节点  
  - 黄色：队列中的待处理节点  
- **音效触发**：节点入队时播放短音效，找到新最长路径时播放上扬音调。  

---

### **题解评分 (≥4星)**  
#### 1. 作者：Computer1828（5星）  
- **亮点**：链式前向星存图，代码结构清晰，正确处理多组数据。  
- **核心代码**：  
  ```cpp
  void bfs(int s) {
      memset(vis, 0, sizeof(vis));
      queue<node> q;
      q.push({s, 0});
      vis[s] = true;
      while (!q.empty()) {
          node fr = q.front(); q.pop();
          ans = max(ans, fr.dis); // 实时更新最大值
          for (int i = hed[fr.tp]; i; i = e[i].nxt) {
              int v = e[i].to;
              if (!vis[v]) {
                  q.push({v, fr.dis + 1});
                  vis[v] = true;
              }
          }
      }
  }
  ```

#### 2. 作者：Lonely_NewYear（4.5星）  
- **亮点**：使用 `vector` 存图，代码简洁，注释明确。  
- **个人心得**：强调 BFS 的正确性源于边权为 1 的特性。  

#### 3. 作者：dlzlj_2010（4星）  
- **亮点**：队列存储节点和距离，避免结构体封装。  
- **优化点**：使用 `memset` 快速清空距离数组。  

---

### **最优思路提炼**  
1. **BFS 遍历每个节点**：每个节点作为起点执行一次 BFS，时间复杂度 O(nm)。  
2. **实时更新最大值**：在 BFS 过程中直接记录最远距离，避免二次遍历。  
3. **链式前向星存图**：高效处理稀疏图，节省内存。  

---

### **同类型题与算法套路**  
- **通用解法**：图的直径问题均可通过两次 BFS 或多次 BFS 解决。  
- **类似题目**：  
  - 洛谷 P3304 [SDOI2013] 直径（求树的直径）  
  - 洛谷 P5536 【XR-3】核心城市（求图的中心节点）  
  - 洛谷 P1395 会议（树的直径与重心结合）  

---

### **推荐相似题目**  
1. **P1395 会议**（BFS 求树的最短路径和）  
2. **P5536 核心城市**（图的中心与 BFS 结合）  
3. **P3304 直径**（树的直径与边权处理）  

---

### **个人心得摘录**  
- **Ambition_**：调试时发现第四个测试点需特判，提醒注意边界条件。  
- **Lian_zy**：初次实现因未清空邻接表 WA，强调多测清空的重要性。  

---

### **可视化与算法演示**  
#### 动画方案  
1. **Canvas 绘制**：节点以网格排列，边用线条连接，当前处理节点高亮红色。  
2. **队列动态显示**：右侧面板展示队列状态，黄色方块表示待处理节点。  
3. **步进控制**：支持暂停/继续，拖动进度条观察 BFS 扩展过程。  
#### 复古像素风格  
- **调色板**：16 色，节点用 8x8 像素方块表示。  
- **音效设计**：  
  - `jump.wav`：节点入队时播放。  
  - `success.wav`：找到新最长路径时播放。  
#### 代码片段（JS 实现）  
```javascript
function drawBFSStep(queue, visited, maxDist) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 绘制所有节点
    nodes.forEach(node => {
        if (visited.has(node.id)) ctx.fillStyle = '#00FF00'; // 绿色：已访问
        else ctx.fillStyle = '#FFFFFF'; // 白色：未访问
        ctx.fillRect(node.x, node.y, 8, 8);
    });
    // 高亮当前队列中的节点
    queue.forEach((node, idx) => {
        ctx.fillStyle = '#FFFF00'; // 黄色：队列中
        ctx.fillRect(node.x - 2, node.y - 2, 12, 12);
    });
}
```

---

### **核心代码实现**  
```cpp
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

vector<int> graph[1005];
int maxDist = 0;

void bfs(int start) {
    bool visited[1005] = {false};
    queue<pair<int, int>> q; // (节点, 距离)
    q.push({start, 0});
    visited[start] = true;
    while (!q.empty()) {
        auto [u, dist] = q.front(); q.pop();
        maxDist = max(maxDist, dist);
        for (int v : graph[u]) {
            if (!visited[v]) {
                visited[v] = true;
                q.push({v, dist + 1});
            }
        }
    }
}

int main() {
    int n, m;
    while (cin >> n >> m && n + m) {
        // 清空图并重新构建
        for (int i = 1; i <= n; i++) graph[i].clear();
        while (m--) {
            int u, v; cin >> u >> v;
            graph[u].push_back(v);
            graph[v].push_back(u);
        }
        // 计算图的直径
        maxDist = 0;
        for (int i = 1; i <= n; i++) bfs(i);
        cout << maxDist * 100 << endl;
    }
    return 0;
}
```

---
处理用时：85.60秒
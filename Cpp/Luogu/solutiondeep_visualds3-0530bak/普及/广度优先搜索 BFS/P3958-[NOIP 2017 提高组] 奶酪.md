# 题目信息

# [NOIP 2017 提高组] 奶酪

## 题目背景

NOIP2017 提高组 D2T1

## 题目描述

现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z = 0$，奶酪的上表面为 $z = h$。

现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。

位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑 到奶酪的上表面去?

空间内两点 $P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$ 的距离公式如下：


$$\mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$$


## 说明/提示

【输入输出样例 $1$ 说明】

 ![](https://cdn.luogu.com.cn/upload/pic/10860.png) 

第一组数据,由奶酪的剖面图可见：

第一个空洞在 $(0,0,0)$ 与下表面相切；

第二个空洞在 $(0,0,4)$ 与上表面相切；

两个空洞在 $(0,0,2)$ 相切。

输出 `Yes`。

 
第二组数据,由奶酪的剖面图可见：

两个空洞既不相交也不相切。

输出 `No`。

 
第三组数据,由奶酪的剖面图可见：

两个空洞相交，且与上下表面相切或相交。

输出 `Yes`。

【数据规模与约定】

对于 $20\%$ 的数据，$n = 1$，$1 \le h$，$r \le  10^4$，坐标的绝对值不超过 $10^4$。

对于 $40\%$ 的数据，$1 \le n \le 8$，$1 \le h$，$r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $80\%$ 的数据，$1 \le n \le 10^3$，$1 \le h , r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $100\%$ 的数据，$1 \le n \le 1\times 10^3$，$1 \le h , r \le 10^9$，$T \le 20$，坐标的绝对值不超过 $10^9$。

## 样例 #1

### 输入

```
3 
2 4 1 
0 0 1 
0 0 3 
2 5 1 
0 0 1 
0 0 4 
2 5 2 
0 0 2 
2 0 4```

### 输出

```
Yes
No
Yes```

# AI分析结果



## 算法分类
**并查集**

---

## 题解分析与结论

### 核心思路与难点
1. **核心逻辑**：将空洞视为图中的节点，通过判断两个球是否相交（距离 ≤ 2r）建立连通关系，使用并查集合并连通分量。特殊处理与上下表面接触的空洞，最终判断上下表面是否连通。
2. **难点与解决**：
   - **浮点精度问题**：通过平方比较代替开根运算（`d² ≤ (2r)²`）避免精度误差。
   - **上下表面处理**：将接触下/上表面的空洞与虚拟节点合并，统一判断连通性。
3. **优化点**：部分题解在并查集中剪枝（如提前判断是否可达上下表面），或在搜索中避免重复访问。

### 题解评分 (≥4星)
1. **Fading（5星）**  
   - **亮点**：并查集实现简洁，平方比较优化显著，处理上下表面逻辑清晰。  
   - **代码**：预处理接触上下表面的空洞集合，双重循环合并相交空洞，最后检查集合连通性。
2. **pipilong2024（4星）**  
   - **亮点**：记录每个集合的上下边界，合并时更新极值，减少最终检查次数。  
   - **代码**：在并查集中维护每个集合的 `min_h` 和 `max_h`，直接判断是否跨越整个奶酪。
3. **Malkin_Moonlight（4星）**  
   - **亮点**：将上下表面视为虚拟节点，构建图后用 BFS 判断连通性，逻辑直观。  
   - **代码**：用邻接表存储图结构，从下表面虚拟节点出发广搜至上表面节点。

---

## 最优思路提炼
1. **平方优化**：计算球心距离的平方，避免浮点误差（关键代码：`(x1-x2)^2 + ... ≤ 4r²`）。
2. **虚拟节点**：将上下表面抽象为特殊节点，简化连通判断。
3. **极值维护**：在并查集中动态维护集合的上下边界，快速判断是否跨越整个奶酪高度。

---

## 同类型题与算法套路
- **相似问题**：图的连通性判断（如水管工游戏、迷宫逃脱）。
- **通用解法**：  
  1. **并查集**：处理动态连通性问题，合并集合后快速查询。  
  2. **DFS/BFS**：显式构建图后遍历判断路径存在性。

---

## 推荐相似题目
1. **P2330 [SCOI2005] 繁忙的都市**（并查集求最小生成树）  
2. **P1197 [JSOI2008] 星球大战**（逆向并查集维护连通性）  
3. **P2296 [NOIP2014 提高组] 寻找道路**（BFS + 图预处理）

---

## 可视化与算法演示

### 动态并查集合并演示
- **动画设计**：  
  1. **像素网格**：每个空洞显示为像素方块，初始颜色随机区分不同集合。  
  2. **合并效果**：当两洞合并时，用连线动画标记，目标集合颜色覆盖源集合。  
  3. **虚拟节点**：上下表面用特殊颜色（如红/蓝）表示，合并时高亮闪烁。  
  4. **成功路径**：最终连通时，路径上的节点动态闪烁绿色。

- **交互功能**：  
  - **步进控制**：允许单步执行合并操作，观察集合变化。  
  - **自动模式**：按算法逻辑自动合并，速度可调节。  
  - **音效触发**：合并时播放“连接”音效，成功时播放胜利音效。

### 复古像素风格实现（伪代码）
```javascript
// Canvas 绘制示例
function drawGrid() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, width, height); // 黑色背景
  holes.forEach((hole, i) => {
    ctx.fillStyle = colors[find(i)]; // 按集合颜色填充
    ctx.fillRect(hole.x * scale, hole.y * scale, 8, 8);
  });
  // 绘制上下表面虚拟节点
  ctx.fillStyle = 'red';
  ctx.fillRect(0, height/2, 8, 8); // 下表面
  ctx.fillStyle = 'blue';
  ctx.fillRect(width-8, height/2, 8, 8); // 上表面
}
```

---

## 关键代码片段（Fading题解）
```cpp
// 并查集核心逻辑
for (int j=1; j<=n; j++) {
    if (z[j]+r >= h) f1[++tot1] = j; // 记录接触上表面的洞
    if (z[j]-r <= 0) f2[++tot2] = j; // 记录接触下表面的洞
    for (int k=1; k<=j; k++) {
        if (dis(x[j],y[j],z[j],x[k],y[k],z[k]) <= 4*r*r) {
            int a1=find(j), a2=find(k);
            if (a1 != a2) f[a1] = a2; // 合并集合
        }
    }
}
// 检查上下表面连通性
bool ok = false;
for (int i=1; i<=tot1; i++)
    for (int j=1; j<=tot2; j++)
        if (find(f1[i]) == find(f2[j])) ok = true;
```

---
处理用时：73.43秒
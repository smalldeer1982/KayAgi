# 题目信息

# [CERC2014] Wheels

## 题目描述

一个非常重要和复杂的机器由$n$个轮子组成，编号为$1,2,…,n$。它们其实是齿轮，但是齿太小了，我们可以把它们近似看成成平面上的圆。



每一个齿轮都能围绕它的中心旋转。



两个齿轮不会重叠（因为它们内部没有共同的点），但它们可以互相接触。



如果两个齿轮相互接触，其中一个齿轮转动，另一个齿轮也随之转动，因为它们的齿被卡在一起。



一个力作用于齿轮1（并且力没有作用于其他齿轮），使它以每分钟转一圈的速度顺时针旋转。计算其他齿轮的运动速度。你可以假设机器没有卡住（运动在物理理论上是可以的）。

## 样例 #1

### 输入

```
1
5
0 0 6
6 8 4
-9 0 3
6 16 4
0 -11 4
```

### 输出

```
1 clockwise
3/2 counterclockwise
2 counterclockwise
3/2 clockwise
not moving```

# AI分析结果



1. **算法分类选择**  
   广度优先搜索（BFS）

---

### 题解思路、算法要点与解决难点  
**核心逻辑**：  
- **物理公式**：相切齿轮的线速度相等，转速与半径成反比，方向相反。公式为：  
  $$\text{转速}_j = \frac{\text{转速}_i \cdot r_i}{r_j}$$  
- **齿轮接触判断**：两齿轮圆心距离平方等于半径和的平方。  
- **BFS传播**：从齿轮1出发，逐层传播转动状态，确保每个齿轮仅处理一次。

**关键难点与解决**：  
1. **分数化简**：速度以分数形式存储，需计算最大公约数（GCD）约分。  
2. **方向反转**：每次传播时，方向取反（如`!u.clock`）。  
3. **队列初始化**：多测试用例需重置队列和状态变量。  
4. **接触判断优化**：避免浮点运算，用整数平方比较。

---

### 题解评分 (≥4星)  
1. **作者：_Goodnight**（4.5星）  
   - 亮点：结构体封装清晰，BFS逻辑明确，分数处理模块化。  
   - 优化点：代码冗余（如`out`函数），但核心逻辑完整。  

2. **作者：HRLYB**（4星）  
   - 亮点：手写队列避免STL潜在问题，显式处理层数标记。  
   - 优化点：输出部分稍显繁琐，但错误处理全面。  

3. **作者：内拉组里**（4.5星）  
   - 亮点：代码简洁，使用C++17结构化绑定，分数和方向处理高效。  
   - 优化点：无显著缺陷，逻辑与可读性俱佳。  

---

### 最优思路或技巧提炼  
1. **BFS逐层传播**：将齿轮传动建模为图的遍历问题，确保无重复处理。  
2. **分数存储与约分**：用分子/分母表示速度，每次计算后立即约分。  
3. **方向反转逻辑**：用布尔值或整数标记方向，传播时取反。  
4. **整数距离比较**：避免浮点误差，直接用平方值判断相切。  

---

### 同类型题推荐  
1. **P1135 奇怪的电梯**（BFS模拟状态传播）  
2. **P1141 01迷宫**（连通块BFS遍历）  
3. **P2895 [USACO08FEB]Meteor Shower S**（BFS处理动态障碍）  

---

### 可视化与算法演示设计  
**动画方案**：  
1. **齿轮高亮**：当前处理的齿轮用红色边框标记，新触发的齿轮用绿色闪烁。  
2. **速度显示**：齿轮上方实时显示分数（如`3/2`）和方向箭头（顺时针/逆时针）。  
3. **队列状态**：右侧面板展示队列中的齿轮编号，动态更新。  
4. **音效触发**：齿轮转动时播放齿轮咬合音效，无法移动时播放低沉提示音。  

**复古像素风格**：  
- **Canvas绘制**：齿轮用8位像素圆表示，圆心坐标映射到网格。  
- **自动演示**：点击“AI Run”后，算法自动执行，队列变化同步显示。  
- **音效设计**：使用芯片音乐（Chiptune）风格音效，背景播放循环的8位BGM。  

---

### 核心代码实现（作者：内拉组里）  
```cpp
struct { int x, y, r; } a[maxn];
struct { int p, q, dir; } ans[maxn];
queue<int> q;

// BFS核心逻辑
q.push(1);
ans[1] = {1, 1, 1}; // 初始状态
while (!q.empty()) {
    int u = q.front(); q.pop();
    for (int v = 1; v <= n; v++) {
        if (接触且未访问) {
            ans[v] = { ans[u].p * a[u].r, ans[u].q * a[v].r, !ans[u].dir };
            int g = gcd(ans[v].p, ans[v].q);
            ans[v].p /= g; ans[v].q /= g; // 约分
            q.push(v);
        }
    }
}
```

---

### 个人心得摘录  
- **HRLYB**：忘记初始化队列头尾指针导致多次TLE，强调多测试用例的彻底重置。  
- **tmpliyijiang**：代码中`cnt`用位运算取反，简化方向逻辑。  
- **_Goodnight**：调试时发现分数未约分导致溢出，加入`gcd`处理。  

---

**总结**：本题通过BFS模拟齿轮传动，结合物理公式与图遍历，核心在于正确处理分数和方向。代码实现需注意初始化、约分和接触判断，适合作为BFS应用典型案例。

---
处理用时：71.48秒
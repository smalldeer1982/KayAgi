# 题目信息

# 「SWTR-1」Escape

## 题目背景

有一天，当 $\mathrm{Sunny}$ 闲逛的时候，发现了一个按钮。

好奇心驱使他按下了这个按钮。

突然间，天旋地转 $\dots$

## 题目描述

醒来之后，$\mathrm{Sunny}$ 发现自己站在一个奇怪的地方。

这个地方有 $n$ 个平台，**形成了一个环**。

这时，$\mathrm{Ethan}$ 的声音响起：

“哈哈哈哈哈哈，恭喜你，你是第一个来到**死亡之地**的人。”

“正如你所看到的，这个地方有 $n$ 个平台，你现在站在 $0$ 号平台上。”

“剩余平台按顺时针编号 $1,2,3\dots n-1$，也就是说，你身后的那个平台就是 $n-1$ 号平台。”

“你每次能够**顺时针**跳 $i$ 个平台，$i\in[1,n]$，每次的 $i$ 可以不一样。”

“如果你能够经过所有平台（初始 $0$ 号位置不算），那你就能逃出**死亡之地**了。”

（这里指的是一开始的 $0$ 号位置不算经过，需要再次经过 $0$ 号位置）

“不过，这样太简单了，我会给你一些数 $a_j$，表示你**不能一次顺时针跳 $a_j$ 个平台**。”

“还有，你必须要用**最少**的跳跃次数完成我的任务。”

“如果你不能满足我的上面两个要求，所有平台就会消失，你将会掉入下面的岩浆之中。”

现在，$\mathrm{Sunny}$ 想知道他是否可能逃出这个地方。

如果不行，输出```-1```，否则输出他最少所需的跳跃次数。

因为 $\mathrm{Sunny}$ 觉得死亡之地实在是太有趣了，所以他决定多玩几次，**多组数据**。

## 说明/提示

---

### 样例说明

第一组数据：

$\mathrm{Sunny}$ 每次只能顺时针跳 $5$ 个平台，易知不可能完成。

第二组数据：

$\mathrm{Sunny}$ 每次只能顺时针跳 $3$ 个平台，跳 $5$ 次即可。

---

### 数据范围与约定

$0\leq k\leq n\leq 10^6,1\leq n$。

保证 $\sum{n_i}\leq 3*10^6,a_j\leq n$，且**互不相同**。

测试点 $1:5\%,n=1$。

测试点 $2:5\%,n\leq5$。

测试点 $3:10\%,n\leq15$。

测试点 $4:15\%,n\leq300$。

测试点 $5:25\%,n\leq5000$。

测试点 $6:40\%,n\leq10^6$。

---

梦醒了……

## 样例 #1

### 输入

```
3
5 4
1 2 3 4
5 4
1 2 4 5
6 3
1 3 5```

### 输出

```
-1
5
-1```

# AI分析结果



## 唯一算法分类
**数论（GCD）**

---

## 综合分析与结论
### 核心思路
题目要求通过顺时针跳跃覆盖环形平台上所有点（除初始点外）。关键在于判断是否存在一组允许的跳跃步数，使得其与环长 $n$ 的最大公约数（GCD）为 1。若成立，则最少需要 $n$ 次跳跃；否则无解。

### 解决难点
1. **数学推导**：需证明当且仅当允许步数与 $n$ 的 GCD 为 1 时，能覆盖所有平台。此结论基于裴蜀定理，允许步数的线性组合可生成任意余数。
2. **特殊处理**：当 $n=1$ 且所有步数被禁用时需特判。
3. **高效计算**：需遍历所有允许步数，快速计算其与 $n$ 的 GCD。

### 算法流程
1. 初始化 GCD 为 $n$。
2. 遍历 $1$ 到 $n$，对每个允许的步数 $i$，更新 GCD：`d = gcd(d, i)`。
3. 若最终 `d == 1`，输出 $n$；否则输出 `-1`。

### 可视化设计
- **动画方案**：以像素风格展示环形平台，每个平台用色块表示。允许步数以高亮显示，计算 GCD 时动态更新当前步数及 GCD 值。
- **交互功能**：步进控制展示每个步数如何影响 GCD，成功/失败时播放音效，平台覆盖状态随 GCD 变化实时更新。

---

## 题解评分 (≥4星)
### 1. Alex_Wei（5星）
- **亮点**：官方题解，处理了所有特殊情况（如 $n=1$），代码高效清晰，证明详细。
- **代码片段**：
  ```cpp
  for(int i=1;i<=n;i++)
      if(!pd[i]) d = gcd(d, i);
  if(d > 1) cout << "-1\n";
  else cout << n << endl;
  ```

### 2. MaiJingYao666（4星）
- **亮点**：代码简洁，正确计算 GCD，但证明部分较简略。
- **代码片段**：
  ```cpp
  int t = n;
  for(int i=1;i<=n;i++) 
      if(!vis[i]) t = gcd(t, i);
  if(t == 1) cout << n << '\n';
  ```

### 3. Tomwsc（4星）
- **亮点**：代码规范，使用 STL 的 `__gcd` 函数，但未详细解释数学背景。
- **代码片段**：
  ```cpp
  for(int i=1;i<=n;i++) 
      if(!tot[i]) ans = __gcd(ans, i);
  ans = __gcd(ans, n);
  ```

---

## 最优思路与技巧
### 关键思路
- **GCD 判定**：允许步数集合与 $n$ 的 GCD 为 1 是覆盖所有平台的充要条件。
- **特殊处理**：当 $n=1$ 时，需检查是否至少存在一个允许步数。

### 实现技巧
- **高效标记禁用步数**：使用布尔数组快速查询。
- **逐步更新 GCD**：初始化为 $n$，逐个合并允许步数的 GCD。

---

## 类似题目推荐
1. **P1516 青蛙的约会**：利用 GCD 和线性同余方程求解相遇问题。
2. **P3951 小凯的疑惑**：互质数与最大不可达数问题。
3. **P4549 裴蜀定理**：直接应用裴蜀定理判断方程解的存在性。

---

## 个人心得摘录
- **Alex_Wei**：强调需特判 $n=1$，避免遗漏边界条件。
- **backkom**：通过分步证明 GCD 的更新过程，加深理解。

---

## 可视化算法演示
### 核心逻辑动画
1. **初始化**：显示环形平台，初始位置高亮为绿色。
2. **步数遍历**：逐个检查允许步数，计算并更新 GCD，当前步数标记为黄色。
3. **结果判定**：若 GCD 变为 1，所有平台渐变为绿色；否则显示红色失败动画。

### 复古游戏化设计
- **像素风格**：平台用 8-bit 色块，跳跃时播放经典音效。
- **自动演示模式**：AI 自动运行算法，展示 GCD 计算过程，成功时播放胜利音效。

---

## 代码片段（核心逻辑）
```cpp
#include<bits/stdc++.h>
using namespace std;

int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }

int main() {
    int T; cin >> T;
    while (T--) {
        int n, k, d; 
        cin >> n >> k;
        d = n;
        vector<bool> banned(n + 1, false);
        for (int i = 0, x; i < k; i++) {
            cin >> x;
            banned[x] = true;
        }
        if (n == 1) {
            cout << (k == 0 ? 1 : -1) << endl;
            continue;
        }
        for (int i = 1; i <= n; i++)
            if (!banned[i]) d = gcd(d, i);
        cout << (d == 1 ? n : -1) << endl;
    }
    return 0;
}
```

---
处理用时：159.78秒
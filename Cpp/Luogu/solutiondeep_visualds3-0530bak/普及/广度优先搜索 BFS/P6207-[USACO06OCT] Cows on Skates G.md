# 题目信息

# [USACO06OCT] Cows on Skates G

## 题目描述

**本题使用 Special Judge。**

Farmer John 把农场划分为了一个 $r$ 行 $c$ 列的矩阵，并发现奶牛们无法通过其中一些区域。此刻，Bessie 位于坐标为 $(1,1)$ 的区域，并想到坐标为 $(r,c)$ 的牛棚享用晚餐。她知道，以她所在的区域为起点，每次移动至相邻的四个区域之一，总有一些路径可以到达牛棚。

这样的路径可能有无数种，请你输出任意一种，并保证所需移动次数不超过 $100000$。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le r\le 113$，$1\le c\le 77$。

------------

**【样例说明】* *

![](https://cdn.luogu.com.cn/upload/image_hosting/3gsutffb.png)

图为样例输出的示意图。答案不唯一。

## 样例 #1

### 输入

```
5 8
..*...**
*.*.*.**
*...*...
*.*.*.*.
....*.*.```

### 输出

```
1 1
1 2
2 2
3 2
3 3
3 4
2 4
1 4
1 5
1 6
2 6
3 6
3 7
3 8
4 8
5 8```

# AI分析结果



# 【算法分类】
深度优先搜索（DFS）

---

# 【综合分析与结论】

## 核心思路
本题需要输出迷宫任意一条可行路径，属于典型搜索问题。各题解主要采用DFS/BFS实现，核心差异在于路径记录方式和标记回溯处理：
1. **DFS实现核心**：通过递归优先向一个方向探索，利用**不回溯访问标记**（避免重复路径）和**全局终止标记**（找到路径后立即结束程序）大幅优化效率
2. **BFS实现核心**：通过队列记录前驱节点信息，使用反向回溯的方式生成路径

## 解决难点
- **DFS路径存储**：使用全局数组按递归顺序记录路径，找到终点时直接输出当前路径数组
- **标记回溯陷阱**：DFS中若回溯访问标记（如`vis[x][y] = false`）会导致重复访问相同节点，引发超时
- **路径回溯存储**：BFS需通过二维数组记录每个节点的父节点坐标，递归输出完整路径

---

# 【题解清单（≥4星）】

## 1. MY（DFS）★★★★☆
**核心亮点**：
- 使用全局变量`f`控制程序终止
- 不回溯`book`数组（关键优化点）
- 边递归边存储路径数组
**个人心得**：
> "book数组不需要取消标记（~~窝就是被这个坑了~~）"

## 2. do_while_false（DFS）★★★★
**核心亮点**：
- 使用`exit(0)`直接终止程序
- 路径数组动态维护，节省内存空间
**代码亮点**：
```cpp
if(xx==r&&yy==c) {
    print();
    exit(0); // 立即终止程序
}
```

## 3. wuyonghuming（DFS）★★★★
**核心亮点**：
- 使用`p`数组直接修改原地图标记
- 简洁的输入处理优化
**代码亮点**：
```cpp
scanf("%s",m[i]+1); // 字符串输入优化
```

---

# 【最优思路提炼】

## 关键技巧
1. **DFS标记不回溯**：访问标记数组仅在首次访问时标记，避免重复搜索
2. **全局终止机制**：使用全局布尔变量或`exit(0)`快速结束程序
3. **路径动态存储**：递归时直接记录路径坐标，无需额外回溯存储
4. **方向数组优化**：使用`next[4][2]`统一管理四个移动方向

## 代码实现要点
```cpp
// 关键代码框架
void dfs(int x, int y, int step) {
    // 终止条件判断
    if(到达终点) { 输出路径; 终止程序; }
    
    // 存储当前路径
    path[step] = {x,y};
    vis[x][y] = 1;
    
    // 四个方向探索
    for(四个方向) {
        int nx = x + dx[i], ny = y + dy[i];
        if(可访问) dfs(nx, ny, step+1);
    }
}
```

---

# 【同类型题推荐】

1. **P1605 迷宫**  
   - 基础迷宫路径计数问题，练习DFS/BFS基础实现

2. **P1141 01迷宫**  
   - 连通块问题，练习记忆化搜索优化

3. **P1443 马的遍历**  
   - BFS经典问题，练习广度优先搜索实现

---

# 【可视化设计】

## 动画方案
![DFS搜索过程](https://i.imgur.com/VXvXgZq.gif)
1. **网格绘制**：用Canvas绘制迷宫，障碍物用深色块，路径用渐变色线段
2. **当前节点高亮**：红色方块表示当前搜索位置，绿色方块表示已访问区域
3. **路径追踪**：黄色线条动态显示当前探索路径
4. **回溯效果**：采用半透明效果显示被放弃的路径分支

## 复古像素风格设计
```javascript
// 像素风格初始化
const config = {
    cellSize: 16,    // 16x16像素格子
    palette: ['#000','#0f0','#f00','#ff0'], // 黑、绿、红、黄
    sfx: {
        move: new Audio('blip.wav'),    // 移动音效
        found: new Audio('success.wav') // 找到路径音效
    }
};

// 单步执行演示
function animateStep(x, y) {
    ctx.fillStyle = config.palette[2]; // 红色当前节点
    ctx.fillRect(x*16, y*16, 16, 16);
    config.sfx.move.play();
}
```

---

# 【核心代码（DFS实现）】

```cpp
#include <cstdio>
using namespace std;

int r,c,path[10010][2],vis[120][80];
char maze[120][80];
bool found = false;
int dir[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};

void dfs(int x, int y, int step) {
    if(found || x<1 || x>r || y<1 || y>c || vis[x][y] || maze[x][y]=='*') 
        return;
        
    path[step][0] = x; path[step][1] = y;
    vis[x][y] = 1;
    
    if(x==r && y==c) {
        for(int i=1; i<=step; ++i)
            printf("%d %d\n", path[i][0], path[i][1]);
        found = true;
        return;
    }
    
    for(int i=0; i<4; ++i) {
        int nx = x + dir[i][0], ny = y + dir[i][1];
        dfs(nx, ny, step+1);
        if(found) return;
    }
}

int main() {
    scanf("%d%d", &r, &c);
    for(int i=1; i<=r; ++i) scanf("%s", maze[i]+1);
    dfs(1,1,1);
    return 0;
}
```

---
处理用时：81.75秒
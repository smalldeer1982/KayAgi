# 题目信息

# 最大公约数

## 题目背景

&emsp;&emsp;“寻求最大公约数是人民民主的真谛。……”

&emsp;&emsp;初秋，从枝丫滴下的阳光，柔和，在教室的窗棱溅起，润湿晨读的少女的脸颊。

&emsp;&emsp;“阿绫，阿绫”，天依低俯身子，八字辫耷拉在竖起的课本沿，“我们的最大公约数是多少呢？”

&emsp;&emsp;“一定不小吧”，左手悄悄捏捏天依的小臂，“比如呀，有一个公因子，叫做‘你喜欢我，我也喜欢你’。”

## 题目描述

相反，人际圈形形色色，公约数小得可怜，似乎很难保持自己的个性因而变成无趣的人呢。

现在把人际抽象成一个 $n \times m$ 的矩形，每个人初始的个性为 $a_{i,j}$。从第二天开始，每个人会与上下左右四个人（如果存在）建立人际关系，其个性变为昨天自己和四周人个性的最大公约数。那么对于第 $x$ 行第 $y$ 列的人，在多少天后他的个性会变为 $1$ 呢？

----

#### 简化题意

有一个 $n \times m$ 的矩阵 $a$。对一个矩阵进行变换，定义为将这个矩阵内的所有元素变为其上下左右四个元素（不存在则忽略）及自身的最大公约数。询问 $a_{x,y}$ 在进行最少多少次变换之后会变成 $1$。如果可以使 $a_{x,y}$ 经过若干次变换变成 $1$，输出其中最小的次数；否则输出 $-1$。

## 说明/提示

#### 样例解释 3
第一天的个性矩阵（也就是最开始的矩阵）为
$$
\begin{pmatrix}
3&2&3\\
2&3&2\\
3&2&3
\end{pmatrix}
$$
第二天的个性矩阵为
$$
\begin{pmatrix}
1&1&1\\
1&1&1\\
1&1&1
\end{pmatrix}
$$
可见只需要经过一天，$a_{2,2}$ 就会变为 $1$，所以答案为 $1$。

#### 数据规模与约定
**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^3$，$1\le a_{i,j}\le 10^{18}$，$1\le x\le n$，$1\le y\le m$。

| 子任务 | 分值 |        $n,m$        |              特殊限制              |
| :----: | :--: | :-----------------: | :--------------------------------: |
|   1    |  1   |          /          | 保证给出的位置个性永远不会变为 $1$ |
|   2    |  1   |          /          |          保证 $a_{x,y}=1$          |
|   3    |  3   |      $ \le 2$       |                 /                  |
|   4    |  10  |     $ \le 10^2$     |                 /                  |
|   5    |  30  | $ \le 5\times 10^2$ |           /            |
|   6    |  10  |          /          |   保证对于所有的 $a_{i,j} \le 2$   |
|   7    |  10  |          /          |     保证 $x$ 与 $y$ 都等于 $1$     |
|   8    |  35  |          /          |                 /                  |





------------




## 样例 #1

### 输入

```
2 2
2 2
1 2
2 1```

### 输出

```
0```

## 样例 #2

### 输入

```
2 2
2 2 
2 2
1 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
3 3
3 2 3
2 3 2
3 2 3
2 2```

### 输出

```
1```

# AI分析结果



## 算法分类  
**广度优先搜索（BFS）与曼哈顿距离预处理**

---

## 题解思路与核心难点

### 核心逻辑与关键点  
1. **问题转化**：每次操作后，目标点的值等于其曼哈顿距离 ≤ k 的所有原始点的 GCD。  
2. **分层计算**：将矩阵中的点按曼哈顿距离分组，逐层计算 GCD，直到得到 1。  
3. **无解判断**：若所有点的 GCD ≠ 1，则目标点永远无法变为 1。

### 解决难点  
- **扩展逻辑**：BFS 模拟扩展过程，每次扩展相当于曼哈顿距离增加一层。  
- **高效计算**：预处理曼哈顿距离，避免重复遍历矩阵。  

### 题解对比  
| 题解作者 | 核心方法 | 时间复杂度 | 关键优化 | 评分 |
|---------|---------|-----------|---------|------|
| vectorwyx | BFS 逐层扩展 | O(nm log a) | 队列维护当前 GCD | ⭐⭐⭐⭐ |
| wsyhb | 曼哈顿距离预处理 | O(nm + max_d) | 按距离分层计算 GCD | ⭐⭐⭐⭐⭐ |
| Rubidium_Chloride | 曼哈顿距离分层 | O(nm) | 直接枚举距离 | ⭐⭐⭐⭐ |

---

## 最优思路提炼  
**曼哈顿距离分层计算**  
1. **预处理**：将所有点按与目标点的曼哈顿距离分组。  
2. **逐层累加**：从距离 0 开始，逐步计算每层的 GCD。  
3. **终止条件**：当某层累加后 GCD=1 时，输出当前距离。

---

## 同类型题与算法套路  
- **扩展模式**：层序处理（如感染扩散、最短路径）  
- **GCD 优化**：预处理分层减少计算量  
- **类似题目**：  
  - P1443 马的遍历（BFS 扩展）  
  - P1135 奇怪的电梯（层序状态转移）  
  - P1888 三角函数（GCD 性质应用）

---

## 可视化与算法演示  
### 动画方案设计  
1. **像素网格渲染**：  
   - 用 8-bit 像素风格显示矩阵，不同颜色表示不同曼哈顿距离层。  
   - 当前处理层高亮为红色，已处理层渐变为灰色。  
2. **GCD 计算过程**：  
   - 每层处理时，显示当前累加的 GCD 值。  
   - 发现 GCD=1 时，播放 "通关" 音效并闪烁目标点。  
3. **交互控制**：  
   - 步进按钮：手动控制层数扩展。  
   - 速度滑块：调节动画播放速度。  

### 核心代码片段（JS 伪代码）  
```javascript
// 初始化曼哈顿距离层
const layers = [];
for (let i = 0; i < n; i++) {
  for (let j = 0; j < m; j++) {
    const d = Math.abs(i - x) + Math.abs(j - y);
    if (!layers[d]) layers[d] = [];
    layers[d].push(a[i][j]);
  }
}

// 逐层计算 GCD
let currentGCD = a[x][y];
for (let d = 0; d < layers.length; d++) {
  if (currentGCD === 1) break;
  for (const val of layers[d]) {
    currentGCD = gcd(currentGCD, val);
    if (currentGCD === 1) {
      playSuccessSound();
      highlightLayer(d);
      return d;
    }
  }
}
```

---

## 个人心得摘录  
- **vectorwyx**：通过 BFS 队列维护扩展过程，边扩展边计算 GCD，避免存储中间矩阵。  
- **wsyhb**：预处理曼哈顿距离显著减少计算量，适用于大规模数据。  
- **ForgotMe**：无解条件需全局 GCD 判断，否则会遗漏边界情况。

---

## 推荐题目  
1. **P1443**：BFS 扩展的经典马步覆盖问题。  
2. **P1135**：层序状态转移的电梯问题。  
3. **P1888**：利用 GCD 简化三角函数计算。

---
处理用时：64.69秒
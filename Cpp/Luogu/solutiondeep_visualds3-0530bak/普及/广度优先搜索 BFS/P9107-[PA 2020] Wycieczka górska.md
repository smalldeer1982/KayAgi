# 题目信息

# [PA 2020] Wycieczka górska

## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 4 [Wycieczka górska](https://sio2.mimuw.edu.pl/c/pa-2020-1/wyc/)**

一群 $k$ 个旅行者朋友去了 Byte 山。在最后一天，他们决定组织一场登山比赛，从他们所住的旅店到 Byte 山顶。

每个旅行者都有一张区域地图，它是一个分为 $n$ 行 $m$ 列的矩形；因此地图一共包含 $n\cdot m$ 个区域。旅店位于地图左上角的区域，而山顶则位于地图右下角的区域。Byte 山以其非常均匀而闻名——对于地图上的任何区域，在地图上与之相邻的右面或下面的区域海拔较高，而相邻的左边或上面区域海拔较低。但是，这座山也因潜伏着许多危险地区而闻名。有些地区在地图上标明是非常危险的，因为那里有野生动物居住——所以最好不要到那里去……

你是 Byte 山山脚下的一个小屋的看守人。通过观察每一个旅行者，你已经为他们每个人分配了两个参数 $a_i$ 和 $b_i$，这些参数决定了他们在山坡上的运动速度。具体来说，如果第 $i$ 个旅行者向更高的区域移动，那么他需要 $a_i$ 分钟，如果旅行者向更低的区域移动，则需要 $b_i$ 分钟。你也知道，每个旅行者都会走对他们来说从小屋到山顶最快的路线，并且路线完全在地形图上，而且避开了所有的危险区域。

你想知道最快的人需要多长时间才能到达山顶，有多少人将与最快的人同时爬到山顶。你可以假设，从小屋到山顶至少有一条安全的路线。

## 说明/提示

#### 样例 2 解释

从旅店到山顶只有一条路径，这些旅行者的用时分别是 $13,14,13,13$。

------------

#### 数据范围

**本题采用捆绑测试**

对于一些子任务满足 $k=1$。

对于 $100\%$ 的数据，保证 $2\le n,m\le 2\times 10^3$，$1\le k\le 10^6$，$1\le a_i,b_i\le 10^9$。

## 样例 #1

### 输入

```
5 7 1
......X
X.X..X.
..X.X.X
.X.X...
.....X.
2 1```

### 输出

```
26 1```

## 样例 #2

### 输入

```
2 5 4
.X...
...X.
2 1
2 2
1 7
2 1```

### 输出

```
13 3```

# AI分析结果



**唯一算法分类**  
广度优先搜索 (BFS) / 双端队列 BFS

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
所有旅行者的路径相同，关键在于找到**最短路径中向上/左的次数**（即绕路次数）。通过 BFS 优先处理右/下移动（不增加绕路次数），用双端队列优化搜索顺序。

#### **关键步骤**
1. **BFS 预处理**：用双端队列存储节点，向右/下移动时从队首插入（优先处理），向上/左移动时从队尾插入。
2. **路径计算**：总步数 = 必要步数（n+m-2） + 2×绕路次数，其中绕路次数 = 向上/左次数。
3. **时间计算**：每位旅行者的时间 = 上升步数×a_i + 下降步数×b_i。

#### **解决难点**
- **路径统一性证明**：无论 a_i 和 b_i 如何，绕路次数最少时总时间必然最小。
- **高效 BFS 实现**：双端队列处理不同方向的优先级，保证最先到达终点的路径绕路次数最少。

---

### **题解评分 (≥4星)**

1. **作者：_•́へ•́╬_ (5星)**  
   - **亮点**：双端队列 BFS 实现高效，代码简洁，时间复杂度 O(nm)。
   - **核心代码**：  
     ```cpp
     deque<node> q;
     q.emplace_front(...); // 右/下移动，队首插入
     q.emplace_back(...);  // 上/左移动，队尾插入
     ```

2. **作者：wuhan1234 (4星)**  
   - **亮点**：公式推导清晰，指出总步数 = n+m-2 + 2×绕路次数。
   - **关键公式**：  
     ```cpp
     int ansb = (cnt - (n + m - 2)) / 2; // 绕路次数
     ```

3. **作者：donnieguo (4星)**  
   - **亮点**：结构体记录上下左右步数，可读性强。
   - **数据结构**：  
     ```cpp
     struct node { int x, y; ll tul, tdr; }; // tul=上/左次数，tdr=下/右次数
     ```

---

### **最优思路或技巧提炼**

1. **双端队列优化 BFS**  
   - 向右/下移动时不增加绕路次数，优先处理（队首插入）。
   - 向上/左移动时增加绕路次数，延后处理（队尾插入）。

2. **统一路径证明**  
   - 绕路次数 x 对应的总时间公式为：  
     `总时间 = a_i*(必要步数 + x) + b_i*x`  
   - 对任意 a_i, b_i > 0，x 越小总时间越优。

---

### **同类型题或算法套路**

- **0-1 BFS 应用**：适用于边权为 0 或 1 的图（如 [Luogu P4667](https://www.luogu.com.cn/problem/P4667)）。
- **最短路径统一性**：当最优路径与参数无关时，预处理路径后批量计算（如 [CF 1473E](https://codeforces.com/problemset/problem/1473/E)）。

---

### **推荐相似题目**

1. [P4667 迷宫](https://www.luogu.com.cn/problem/P4667)（双端队列 BFS）  
2. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)（最短路径统一性）  
3. [CF 1063B Labyrinth](https://codeforces.com/problemset/problem/1063/B)（带限制的 BFS）

---

### **代码核心实现**

```cpp
// 双端队列 BFS 核心片段
deque<node> q;
q.emplace_back(0, 0, 0); // 起点
while (!q.empty()) {
    node u = q.front(); q.pop_front();
    if (到达终点) break;
    // 右/下移动（不增加绕路次数）
    if (右/下可走 && 未访问) {
        q.emplace_front(新坐标, u.a); // 优先处理
    }
    // 上/左移动（增加绕路次数）
    if (上/左可走 && 未访问) {
        q.emplace_back(新坐标, u.a + 1);
    }
}
```

---

### **可视化与算法演示**

#### **动画方案**
1. **网格绘制**：用 Canvas 绘制 n×m 网格，危险区域标红，路径标绿。
2. **队列状态**：左侧显示双端队列，队首（右/下）用蓝色块，队尾（上/左）用黄色块。
3. **当前节点**：高亮当前处理的网格（闪烁金边），移动时播放 "blip" 音效。
4. **路径回溯**：找到终点后，用绿色线条绘制路径。

#### **复古风格设计**
- **调色板**：8 位风格（绿-路径，红-障碍，蓝-队列，黄-绕路）。
- **音效**：  
  - 移动：8-bit "blip"（[JSFiddle 示例](https://jsfiddle.net/7s96bLxo/)）。  
  - 成功：FC 过关音效。
- **自动演示**：按空格暂停/继续，方向键控制速度。

---

### **总结**
通过双端队列 BFS 确定最短绕路次数，结合统一路径特性批量计算时间，算法复杂度 O(nm + k)，完美处理 2e3 网格和 1e6 用户数据。复古可视化增强理解，适合教学演示。

---
处理用时：70.43秒
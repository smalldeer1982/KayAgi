# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果



### 【唯一算法分类】
拓扑排序 + 动态规划

---

### 【题解思路与解决难点】

#### **核心思路**
1. **问题转化**：题目要求以每个城市为终点的最长路径，转化为DAG上的最长路径问题。
2. **拓扑排序必要性**：DAG的拓扑序保证处理节点时其前驱已全部处理完毕，满足DP的无后效性。
3. **动态规划方程**：`dp[v] = max(dp[v], dp[u] + 1)`，其中`u`是`v`的前驱节点。

#### **关键实现**
- **拓扑排序**：通过入度队列维护处理顺序，保证节点按拓扑序依次处理。
- **邻接表存图**：高效存储大规模边（如题解中使用链式前向星或vector）。
- **初始化**：每个节点的初始值为1（仅包含自身）。

#### **解决难点**
- **多起点处理**：所有入度为0的节点需作为初始起点（如样例中的城市1）。
- **反向建图的误区**：部分题解尝试反向建图+记忆化搜索，但需注意递归深度可能导致的栈溢出问题。

---

### 【题解评分 (≥4星)】

#### 1. 星星之火（5星）
- **亮点**：详细解释拓扑排序与DP的关系，代码结构清晰，注释完整。
- **代码**：使用链式前向星存图，显式维护拓扑序，DP部分高效。

#### 2. meowla（4星）
- **亮点**：简洁的记忆化搜索实现，反向建图思路巧妙。
- **缺点**：递归深度可能受限，不适用于极大N（如1e5）。

#### 3. zyx10（4星）
- **亮点**：直接利用拓扑序的深度作为答案，代码简洁。
- **关键点**：队列处理时动态更新深度，无需显式DP数组。

---

### 【最优思路提炼】
1. **拓扑序DP**：按拓扑序处理节点，保证每个节点的前驱已计算完毕，直接更新其后继。
2. **链式前向星存图**：高效处理大规模边数据，降低空间复杂度。
3. **入度队列优化**：通过入度数组快速定位可处理节点，避免重复遍历。

---

### 【相似题目推荐】
1. **P4017 最大食物链计数**：DAG上的路径计数，拓扑排序+DP。
2. **P3387 缩点**：强连通分量缩点后求最长路径。
3. **P1807 最长路**：DAG上显式求最长路径。

---

### 【可视化设计】
#### **动画方案**
1. **拓扑排序过程**：
   - **颜色标记**：入度为0的节点（绿色），处理中节点（黄色），完成节点（灰色）。
   - **队列可视化**：右侧显示当前处理队列，节点按入队顺序排列。
2. **DP更新过程**：
   - **高亮边**：当前处理的边（u→v）显示为红色。
   - **数值更新**：`dp[v]`的值动态变化，显示max比较过程。
3. **复古像素风格**：
   - **节点显示**：每个节点用8-bit像素块表示，上方显示`dp`值。
   - **音效**：节点入队时播放“滴”声，`dp`更新时播放“叮”声。

#### **交互功能**
- **步进控制**：支持暂停/继续，单步执行观察拓扑序和DP更新。
- **速度调节**：滑动条控制动画速度（0.5x~5x）。
- **自动演示**：AI模式自动播放，附带背景音乐（8-bit风格循环）。

---

### 【核心代码实现】
```cpp
// 拓扑排序 + DP（星星之火题解核心）
void topsort() {
    queue<int> q;
    for (int i = 1; i <= n; i++) {
        if (ru[i] == 0) {
            q.push(i);
            dp[i] = 1; // 初始化起点
        }
    }
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = edge[i].next) {
            int v = edge[i].to;
            dp[v] = max(dp[v], dp[u] + 1); // 关键DP更新
            if (--ru[v] == 0) q.push(v);
        }
    }
}
```

---

### 【个人心得摘录】
- **归山_的调试经验**：“反向存图后，递归时忘记初始化`dp[x]=1`导致WA，必须注意每个节点至少包含自身。”
- **Strong_Jelly的优化**：“显式维护拓扑序数组，避免在队列中直接更新，提高代码可读性。”

---

### 【总结】
拓扑排序与动态规划结合是解决DAG最长路径问题的标准方法，兼顾时间效率和代码可读性。记忆化搜索适用于小规模数据或特定场景，但需注意递归深度限制。实际编码中，链式前向星和队列的配合能有效处理大规模输入，是竞赛中的常用技巧。

---
处理用时：71.21秒
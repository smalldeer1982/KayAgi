# 题目信息

# [USACO20FEB] Timeline G

## 题目描述

Bessie 在过去的 $M$ 天内参加了 $N$ 次挤奶。但她已经忘了她每次挤奶是在哪个时候了。

对于第 $i$ 次挤奶，Bessie 记得它不早于第 $S_i$ 天进行。另外，她还有 $C$ 条记忆，每条记忆形如一个三元组 $(a,b,x)$，含义是第 $b$ 次挤奶在第 $a$ 次挤奶结束至少 $x$ 天后进行。

现在请你帮 Bessie 算出在满足所有条件的前提下，每次挤奶的最早日期。

保证 Bessie 的记忆没有错误，这意味着一定存在一种合法的方案，使得：

- 第 $i$ 次挤奶不早于第 $S_i$ 天进行，且不晚于第 $M$ 天进行；
- 所有的记忆都得到满足；

## 说明/提示

- 测试点 $2 \sim 4$ 满足 $N,C \leq 10^3$。
- 测试点 $5 \sim 10$ 没有特殊限制。

## 样例 #1

### 输入

```
4 10 3
1 2 3 4
1 2 5
2 4 2
3 4 4```

### 输出

```
1
6
3
8```

# AI分析结果



**唯一算法分类**：拓扑排序

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
- **问题建模**：将挤奶事件视为图中的节点，时间约束视为有向边（`a→b`边权为`x`），并添加超级源点`0`向每个节点`i`连边权为`S_i`的边，形成DAG。
- **拓扑排序递推**：按拓扑顺序处理节点，每个节点的最早时间为其所有前驱节点的时间加上边权的最大值。

#### **解决难点**
1. **图的构建**：正确将初始条件（`S_i`）和记忆（`a→b`）转化为边。
2. **递推顺序**：确保按拓扑序处理节点，避免后驱节点影响前驱节点的时间计算。
3. **动态更新**：每次处理节点时更新其后继节点的时间，并维护入度表。

#### **算法流程**
1. **初始化**：
   - 建立超级源点`0`，向所有节点`i`连边权为`S_i`。
   - 记录每个节点的入度。
2. **拓扑排序**：
   - 将入度为0的节点加入队列。
   - 依次处理队列中的节点，更新其后继节点的最早时间，并减少入度。
   - 若后继节点入度归零，则加入队列。

---

### **题解评分 (≥4星)**

1. **StudyingFather（5星）**  
   - **亮点**：代码简洁高效，直接利用拓扑排序递推，时间复杂度稳定为`O(N + C)`。
   - **关键代码**：
     ```cpp
     for (int i = 1; i <= n; i++) if (!t[i]) q.push(i);
     while (!q.empty()) {
         int u = q.front(); q.pop();
         for (遍历u的邻接边) {
             s[v] = max(s[v], s[u] + w);
             if (--t[v] == 0) q.push(v);
         }
     }
     ```

2. **Hexarhy（4星）**  
   - **亮点**：明确将问题抽象为DAG，使用STL队列和邻接表实现，代码可读性强。
   - **关键代码**：
     ```cpp
     queue<int> q;
     for (int i = 1; i <= n; i++) if (!indeg[i]) q.push(i);
     while (!q.empty()) {
         int u = q.front(); q.pop();
         for (遍历u的邻接边) {
             s[v] = max(s[v], s[u] + w);
             if (--indeg[v] == 0) q.push(v);
         }
     }
     ```

3. **pocafup（4星）**  
   - **亮点**：使用动态规划思想解释递推过程，强调入度为0节点的独立性。
   - **关键代码**：
     ```cpp
     while (!q.empty()) {
         int u = q.front(); q.pop();
         for (遍历u的邻接边) {
             ans[v] = max(ans[v], ans[u] + w);
             if (--indeg[v] == 0) q.push(v);
         }
     }
     ```

---

### **最优思路或技巧提炼**
1. **超级源点**：将初始条件`S_i`转化为从虚拟节点`0`到`i`的边，统一处理约束。
2. **拓扑序递推**：按节点依赖关系顺序更新，确保每个节点的时间在其所有前驱确定后计算。
3. **最大值更新**：每个节点的最早时间取所有前驱时间的最大值，满足所有约束。

---

### **同类型题或类似算法套路**
- **通用模式**：DAG上的动态规划，如任务调度、关键路径分析。
- **相似题目**：
  1. [P1113 杂务](https://www.luogu.com.cn/problem/P1113)（拓扑排序求最长路径）
  2. [P1993 小K的农场](https://www.luogu.com.cn/problem/P1993)（差分约束系统）
  3. [P1262 间谍网络](https://www.luogu.com.cn/problem/P1262)（强连通分量与拓扑排序）

---

### **可视化与算法演示**
#### **动画方案**
1. **节点与边绘制**：
   - 节点用圆形表示，颜色区分处理状态（未处理：灰色，处理中：黄色，已处理：绿色）。
   - 边用箭头表示，边权标注在箭头旁。
2. **拓扑排序过程**：
   - **初始状态**：显示所有节点及其入度，超级源点`0`连向各节点。
   - **队列操作**：入度为0的节点加入队列时高亮显示。
   - **递推更新**：处理队列中的节点时，其邻接边的目标节点时间动态更新，入度减少。
3. **交互控制**：
   - **步进控制**：允许单步执行，观察每一步队列变化和时间更新。
   - **速度调节**：滑动条控制动画速度。

#### **复古像素风格**
- **颜色方案**：8位色调色板（灰、黄、绿、红）。
- **音效**：
  - 节点入队时播放“滴”声。
  - 时间更新时播放“叮”声。
  - 处理完成时播放8-bit胜利音效。

---

### **代码实现（核心逻辑）**
```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

const int MAXN = 1e5 + 5;
struct Edge { int to, w; };
vector<Edge> adj[MAXN];
int in_degree[MAXN], s[MAXN];

void topological_sort(int n) {
    queue<int> q;
    for (int i = 1; i <= n; ++i) {
        if (in_degree[i] == 0) q.push(i);
    }
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (Edge e : adj[u]) {
            s[e.to] = max(s[e.to], s[u] + e.w);
            if (--in_degree[e.to] == 0) {
                q.push(e.to);
            }
        }
    }
}

int main() {
    int n, m, c;
    cin >> n >> m >> c;
    for (int i = 1; i <= n; ++i) {
        cin >> s[i];
        adj[0].push_back({i, s[i]}); // 超级源点0
        in_degree[i]++;
    }
    for (int i = 0; i < c; ++i) {
        int a, b, x;
        cin >> a >> b >> x;
        adj[a].push_back({b, x});
        in_degree[b]++;
    }
    topological_sort(n);
    for (int i = 1; i <= n; ++i) {
        cout << s[i] << endl;
    }
    return 0;
}
```

---
处理用时：91.21秒
# 题目信息

# [常州市赛 2020] 勇士斗恶龙

## 题目背景

搬运自 <http://czoj.com.cn/p/449>。数据为民间数据。

## 题目描述

小 $\text X$ 穿越到了异世界，国王命令他招揽勇士，杀死恶龙，救回公主。  
异世界是高度数据化的。恶龙有一个攻击力 $\text{ATK}$ ，一个生命值 $\text{HP}$ 。类似的，每个勇士也有一个攻击力 $A_i$ ，一个生命值 $H_i$ 。  
战斗是回合制的，并且每次只能由一个勇士和恶龙单挑。战斗中，每个回合恶龙的生命值会减去这个勇士的攻击力，这个勇士的生命值会减去恶龙的攻击力。如果回合结束的时候恶龙的生命值小于等于 $0$，那么恶龙就被杀死了；如果这个勇士的生命值小于等于 $0$，那么这个勇士就被击败了，需要换上另一个勇士继续战斗。当然，如果恶龙还没有被杀死，勇士却全部被击败了，那么这场战役就彻底失败了。  
不过聪明的小 $\text X$ 安排了一个特殊的战术：在一名勇士被击败后立刻让另一名勇士发起攻击，这样恶龙在勇士们的车轮战术下疲于招架，受到第二个勇士的伤害变为两倍，受到第三个勇士的伤害变为三倍……以此类推。  
现在一共有 $n$ 名勇士报名，小 $\text X$ 想问问你，如果合理安排勇士出战的顺序，最少要招揽多少名勇士才能杀死恶龙？

## 说明/提示

### 样例说明
- 两名勇士都招揽。先派出 $2$ 号勇士；  
- 第一回合，恶龙生命值变为 $8$，勇士生命值变为 $0$。勇士被击败；  
- 紧接着派出 $1$ 号勇士；  
- 第二回合，恶龙生命值变为 $4$ （两倍伤害），勇士生命值变为 $1$ ；  
- 第三回合，恶龙生命值变为 $0$ ，勇士生命值变为 $0$ 。恶龙被杀死；  
- 勇士虽然也被击败了，但恶龙已经死了，所以还是胜利了！  
### 数据范围
本题共有 $10$ 个测试点。  
对于所有数据，$1\le n\le 10^5,1\le\text{ATK}, A_i,H_i\le10^6,1\le \text{HP}\le 10^{18}$。  
|测试点编号|$n$|$\text{ATK}, A_i,H_i$|$\text{HP}$|
|:-:|:-:|:-:|:-:|
|$1\sim 4$|$\le 5$|$\le 10$|$\le 100$|
|$5\sim 7$|$\le 10^3$|$\le 10^3$|$\le 10^9$|
|$8\sim 10$|$\le 10^6$|$\le 10^6$|$\le 10^{18}$|

## 样例 #1

### 输入

```
2
1 9
2 2
1 1```

### 输出

```
2```

# AI分析结果



## 算法分类
贪心算法

---

## 题解分析

### 核心思路
将每个勇士的贡献转化为有效伤害（攻击次数×攻击力），按降序排列后贪心累加。通过前缀和优化，快速计算前k个勇士的总伤害。

### 解决难点
1. **有效伤害计算**：需计算每个勇士能攻击的回合数 `ceil(H_i/ATK)`，转化为总伤害 `A_i * rounds`。
2. **贪心排序**：将有效伤害降序排列，确保高贡献勇士获得更高倍率。
3. **前缀和优化**：通过递推公式 `总伤害 += 当前前缀和`，实现O(n)时间复杂度。

### 对比其他解法
- **二分法**（如Kyw666）：虽然直观，但check函数模拟战斗过程，时间复杂度高（O(n²)），无法处理大数据。
- **错误排序策略**（如Manchester_City_FC）：错误地将攻击力×生命值作为排序依据，而非有效伤害。

---

## 题解评分（≥4星）

### Sliarae（5星）
- **亮点**：高效维护前缀和，代码简洁，时间复杂度最优。
- **代码片段**：
```cpp
sort(a + 1, a + n + 1, greater<LL>());
LL now = 0, sum = 0; 
for (int i = 1; i <= n; ++i) {
    now += a[i], sum += now;
    if (sum >= hp) return cout << i << '\n', 0;
}
```

### Yi_chen123（5星）
- **亮点**：详细推导前缀和递推公式，数学证明清晰。
- **个人心得**：强调转移方程 `S_i = S_{i-1} + ∑T_1~T_i`，直观展示优化思路。

### Clare613（4星）
- **亮点**：逆向遍历升序数组，等效降序处理，代码简短。
- **代码片段**：
```cpp
sort(g+1,g+n+1);
for(int i=n;i>=1;i--){
    sum+=g[i]; suum+=sum;
    if(suum>=hp) { cout<<n-i+1; return 0; }
}
```

---

## 最优思路提炼
1. **有效伤害转换**：计算每个勇士的 `A_i * ceil(H_i/ATK)`。
2. **降序排序**：确保高伤害勇士分配到更高倍率。
3. **前缀和累加**：线性时间计算总伤害，避免暴力枚举。

---

## 类似算法题
1. **任务调度**（如洛谷P1080）：按特定顺序分配权重，最大化/最小化总收益。
2. **背包问题变形**：选择物品时权重递增的场景。
3. **最大加权完成时间**（如SPOJ ORDERS）：贪心选择权重高且时间短的任务。

---

## 推荐题目
1. [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)
2. [P1248 加工生产调度](https://www.luogu.com.cn/problem/P1248)
3. [P2107 小Z的AK计划](https://www.luogu.com.cn/problem/P2107)

---

## 可视化设计

### 核心算法演示
- **动画流程**：
  1. **排序阶段**：像素勇士按有效伤害降序排列，显示其伤害值。
  2. **累加阶段**：逐个添加勇士，显示当前总伤害和恶龙HP的对比。
  3. **高亮变化**：当前勇士的系数（如第k个勇士的k倍伤害）以闪烁效果突出。

### 复古游戏化效果
- **像素风格**：使用16色调色板，勇士以不同颜色区分伤害值。
- **音效**：
  - **攻击音效**：每次添加勇士时播放8-bit攻击音。
  - **胜利/失败**：上扬音效（胜利）或低沉音效（失败）。
- **自动演示**：AI自动选择最优勇士序列，动态显示总伤害增长。

### 交互设计
- **控制面板**：暂停/继续、调节动画速度、手动单步执行。
- **数据面板**：实时显示当前总伤害、已选勇士数、恶龙剩余HP。

---

## 代码片段（核心逻辑）

```cpp
// 计算有效伤害并排序
for (int i = 1; i <= n; ++i) {
    int h; cin >> a[i] >> h;
    a[i] *= (h + ATK - 1) / ATK; // ceil(H_i/ATK)
}
sort(a + 1, a + n + 1, greater<LL>());

// 贪心累加前缀和
LL sum_total = 0, prefix = 0;
for (int i = 1; i <= n; ++i) {
    prefix += a[i];      // 前缀和：Σ前i个勇士的伤害
    sum_total += prefix; // 总伤害：Σ前缀和
    if (sum_total >= HP) {
        cout << i << endl;
        return 0;
    }
}
```

---
处理用时：268.35秒
# 题目信息

# [蓝桥杯青少年组国赛 2022] 金箍棒

## 题目背景

为区分各种时间复杂度的做法，本题时间限制下调到 500 毫秒。

## 题目描述

淘气的悟空变出了 $N$ 根高度各不相同的金箍棒（$1 \leq $ 高度 $\leq 1000$），并排列成一排。悟空可以对每根金箍棒施法，让金箍棒高度变短或者变长，但每一次施法只能使一根金箍棒变短 $1$ 个高度或者变长 $1$ 个高度。

现在悟空想通过施法将 $K$（$K \leq N$）根相邻的金箍棒高度变为相同，且要求施法的次数最少，请你帮助悟空计算出最少需要施法几次可以使 $K$ 根相邻的金箍棒高度变为相同。

例如：$N=3$，$K=2$，$3$ 根金箍棒初始高度分别为 $3$、$6$、$1$。

- 第一次对高度为 $3$ 的金箍棒施法变长 $1$ 个高度，变为 $4$；
- 第二次对高度为 $6$ 的金箍棒施法变短 $1$ 个高度，变为 $5$；
- 第三次对高度为 $4$ 的金箍棒施法变长 $1$ 个高度，变为 $5$；

$2$ 根相邻的金箍棒高度变为相同，最少施法 $3$ 次。

## 样例 #1

### 输入

```
3 2
3 6 1```

### 输出

```
3```

# AI分析结果



### 唯一算法分类
**滑动窗口与值域线段树**

---

### 综合分析与结论
**题目核心**：在滑动窗口中找到中位数，并快速计算将所有元素调整到中位数的最小总步数。  
**关键难点**：维护窗口元素的中位数和总和的高效计算。  
**最优解法**：使用线段树维护值域统计信息（每个值的出现次数和总和），通过二分确定中位数，并直接计算总和，时间复杂度为 $O(N \log^2 V)$（$V$ 为值域大小）。

**可视化设计思路**：  
1. **滑动窗口移动**：用高亮色块标记当前窗口范围，动态展示元素的加入/移除。  
2. **线段树更新**：在值域线段树中，用颜色标记当前更新的节点（如插入元素为绿色，删除为红色）。  
3. **中位数计算**：通过二分查找过程，动态显示候选值域范围缩小，最终确定中位数位置。  
4. **总和计算**：展示线段树如何快速查询小于中位数的总和和大于中位数的总和，避免遍历所有元素。

---

### 题解清单（评分 ≥4星）
**题解三（5星）**  
- **关键亮点**：  
  1. 值域线段树维护滑动窗口，实现 $O(1)$ 窗口滑动。  
  2. 二分查找中位数，避免遍历所有元素。  
  3. 线段树统计值域信息，总和计算复杂度优化至 $O(\log V)$。  
- **个人心得**：作者提到“其他人的题解多用暴力或STL方法”，强调线段树的时间优势。

---

### 核心代码实现
```cpp
// 线段树维护值域统计信息
struct SGT {
    struct info { int sum, len; }; // sum: 值域内数的总和；len: 数的个数
    info merge(info a, info b) { return {a.sum + b.sum, a.len + b.len}; }
    void modify(int p, int l, int r, int x, int v) { /* 更新值x的出现次数v */ }
    info query(int p, int l, int r, int ql, int qr) { /* 查询值域[ql, qr]的统计信息 */ }
} tree;

// 滑动窗口处理
for (int i = 1; i <= n; i++) {
    tree.modify(a[i], 1); // 加入当前元素
    if (i > k) tree.modify(a[i - k], -1); // 移除窗口左侧元素
    
    if (i >= k) {
        // 二分查找中位数
        int l = 1, r = 1000, res = 0;
        while (l <= r) {
            int mid = (l + r) / 2;
            int left_cnt = tree.query(1, mid - 1).len;
            int right_cnt = tree.query(mid + 1, 1000).len;
            if (abs(left_cnt - right_cnt) <= tree.query(mid, mid).len) {
                res = mid; break;
            } else if (left_cnt < right_cnt) l = mid + 1;
            else r = mid - 1;
        }
        // 计算总和
        auto left = tree.query(1, res - 1);
        auto right = tree.query(res + 1, 1000);
        int cost = (res * left.len - left.sum) + (right.sum - res * right.len);
        ans = min(ans, cost);
    }
}
```

---

### 类似题目推荐
1. **P1886 滑动窗口**：模板题，练习滑动窗口基本操作。  
2. **P3369 普通平衡树**：练习动态维护有序集合。  
3. **P1168 中位数**：动态求解中位数问题。

---

### 复古像素动画实现
1. **像素风格**：  
   - 金箍棒高度用不同颜色像素块表示，窗口滑动时边框闪烁。  
   - 线段树用网格表示，每个节点显示值域区间和统计值。  
2. **音效设计**：  
   - 窗口滑动时播放“滑动”音效。  
   - 线段树节点更新时播放“点击”音效。  
   - 找到中位数时播放“胜利”音效。  
3. **自动演示**：  
   - 初始状态展示所有金箍棒，窗口自动滑动，关键步骤暂停供观察。  
   - 支持手动控制步进，观察线段树更新和二分过程。

---

**可视化总结**：通过动态展示窗口滑动、线段树更新和中位数计算，结合复古像素风格和音效，使算法流程直观易懂，适合教学与调试。

---
处理用时：106.02秒
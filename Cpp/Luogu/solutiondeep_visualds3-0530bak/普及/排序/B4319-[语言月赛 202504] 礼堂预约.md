# 题目信息

# [语言月赛 202504] 礼堂预约

## 题目描述

小 M 所在的学校有一个礼堂，礼堂里至多能同时进行一个活动，因此需要预约。每个活动占据**某一天**的上午、下午或者晚上。

礼堂负责人**按照时间顺序**接收到了 $n$ 个活动预约，其中第 $i$ 个活动预约描述了活动如下信息：

- 活动类型 $type_i$：一个大写字母，`O` 表示学校官方活动，`C` 表示社团活动，`P` 表示个人活动。
- 活动日期 $date_i$：使用 `YYYYMMDD` 格式表示，例如 `20250411` 表示 $2025$ 年 $4$ 月 $11$ 日。
- 活动时间 $time_i$：一个大写字母，`M` 表示上午，`A` 表示下午，`E` 表示晚上。

负责人每收到一个新的活动预约，会直接加入日程，接下来重复执行如下流程，直到日程里没有冲突：

- 我们规定学校官方活动**优先于**社团活动**优先于**个人活动。如果冲突的两个活动预约类型不同，那么把优先程度更低的活动向后挪一天（活动时间不变）。
- 如果冲突的两个活动类型相同，那么遵循先到先得的原则，把较后预约的活动向后挪一天。
- 注意向后挪动一天可能引发新的冲突，此时对于新冲突的两个活动，仍然按照上述方案调整。

给出这 $n$ 个活动预约的信息，请输出最终每个活动在日程里的活动日期，**按照活动预约的提交顺序输出。**

## 说明/提示

【样例 1 解释】

活动 $1$ 是个人活动，希望在 $2025$ 年 $4$ 月 $19$ 日下午进行，没有冲突。

活动 $2$ 是官方活动，希望在 $2025$ 年 $4$ 月 $19$ 日下午进行，和活动 $1$ 冲突。因此，活动 $1$ 被修改到 $4$ 月 $20$ 日下午。

活动 $3$ 是社团活动，希望在 $2025$ 年 $4$ 月 $19$ 日下午进行，和活动 $2$ 冲突。

- 由于活动 $2$ 是官方活动，所以把活动 $3$ 延后一天到 $4$ 月 $20$ 日下午。
- 然而现在活动 $3$ 和活动 $1$ 冲突，而活动 $1$ 优先程度更低，所以活动 $1$ 被修改到 $4$ 月 $21$ 日下午。

活动 $4$ 是社团活动，希望在 $2025$ 年 $4$ 月 $19$ 日晚上进行，没有冲突。

活动 $5$ 是社团活动，希望在 $2025$ 年 $4$ 月 $20$ 日下午进行，和活动 $3$ 冲突。

- 由于活动 $3,5$ 都是社团活动，按照先到先得原则，把活动 $5$ 延后到 $2025$ 年 $4$ 月 $21$ 日下午。
- 现在活动 $5$ 和活动 $1$ 冲突，所以把活动 $1$ 延后到 $2025$ 年 $4$ 月 $22$ 日。

【样例 2 解释】

注意日期的计算。

【样例 3 解释】

按照收到活动预约的时间给出，不代表活动预约按照 $date_i$ 排序。

【数据范围】

对于全部数据，保证 $1\le n\le 5000$，$type_i$ 一定是 `O`、`C`、`P` 之一，$time_i$ 一定是 `M`，`A`，`E` 之一，$date_i$ 一定是 $2000$ 年 $1$ 月 $1$ 日到 $2099$ 年 $12$ 月 $31$ 日之间、真实存在的日期。（注意并不保证最终的日期在这个范围内。）

本题共有 $10$ 个测试点，每个 $10$ 分。部分测试点有特殊性质，具体如下：

|测试点编号|$n\le$|特殊性质 A|特殊性质 B|
|:-:|:-:|:-:|:-:|
|$1,2$|$500$|保证|保证|
|$3$|$500$|不保证|保证|
|$4$|$500$|保证|不保证|
|$5,6$|$500$|不保证|不保证|
|$7$|$5000$|保证|保证|
|$8,9,10$|$5000$|不保证|不保证|

- 特殊性质 A：每个活动的最终日期和预约日期在同一个月内（例如样例 1）。
- 特殊性质 B：每个活动预约仅产生至多一次冲突，不会连续冲突（例如样例 2）。



## 样例 #1

### 输入

```
5
P 20250419 A
O 20250419 A
C 20250419 A
C 20250419 E
C 20250420 A
```

### 输出

```
20250422
20250419
20250420
20250419
20250421
```

## 样例 #2

### 输入

```
6
P 20280228 M
P 20280228 M
P 20290228 A
P 20290228 A
P 20991231 E
P 20991231 E
```

### 输出

```
20280228
20280229
20290228
20290301
20991231
21000101
```

## 样例 #3

### 输入

```
5
C 20250419 E
C 20250420 A
P 20250419 A
O 20250419 A
C 20250419 A
```

### 输出

```
20250419
20250420
20250422
20250419
20250421
```

# AI分析结果



## 算法分类
无算法分类

## 题解思路与难点分析
### 核心思路
1. **分时段处理**：将活动按时间段（上午M、下午A、晚上E）拆分为三个独立列表，仅同时间段活动会冲突。
2. **动态调整**：每次插入新活动时，遍历该时段已安排活动，按优先级规则调整日期，直到无冲突。
3. **日期计算**：使用辅助函数精确处理闰年、月末等日期边界情况。

### 解决难点
1. **冲突连锁反应**：通过类似插入排序的方式，每次调整后立即处理新冲突，确保所有冲突被消除。
2. **优先级判定**：先比较活动类型（O>C>P），类型相同则按提交顺序判断。
3. **高效维护有序列表**：每个时段维护按日期排序的活动列表，插入时直接处理冲突，避免全量检查。

## 题解评分
⭐️⭐️⭐️⭐️⭐️  
- **思路清晰**：分时段处理大幅简化问题复杂度。
- **代码高效**：插入时动态调整，最坏O(n²)但实际性能优秀。
- **细节完善**：日期计算覆盖所有边界情况。

## 最优技巧提炼
1. **三维时间分割**：将时间轴拆分为独立时间段处理，避免跨时段冲突判断。
2. **插入排序式调整**：利用交换操作在遍历时直接处理冲突，实现链式反应处理。
3. **类型数值化**：将O/C/P映射为0/1/2，通过数值比较快速判断优先级。

## 核心代码实现
```cpp
int days[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};

int tomorrow(int dt) {
    int y = dt/10000, m = dt/100%100, d = dt%100;
    int maxd = days[m];
    if(m == 2 && ((y%4 == 0 && y%100 != 0) || y%400 == 0)) 
        maxd = 29;
    d++;
    if(d > maxd) { d = 1; m++; }
    if(m == 13) { m = 1; y++; }
    return y*10000 + m*100 + d;
}

// 插入新活动逻辑
int tme = ...; // 时间段转换
int to_arr = i;
for(int j=1; j<=cact[tme]; j++) {
    int target = act[tme][j];
    if(date[target] == date[to_arr]) {
        if(type[target] > type[to_arr] || 
          (type[target] == type[to_arr] && target > to_arr)) {
            swap(act[tme][j], to_arr);
        }
        date[to_arr] = tomorrow(date[to_arr]);
    } 
    else if(date[target] > date[to_arr]) {
        swap(act[tme][j], to_arr);
    }
}
cact[tme]++;
act[tme][cact[tme]] = to_arr;
```

## 可视化设计
### 像素动画方案
1. **时间轴展示**：左侧三个垂直时间轴（M/A/E），用不同颜色区分时段。
2. **活动方块**：每个活动显示为像素方块，颜色表示类型（O红/C蓝/P绿）。
3. **冲突高亮**：当方块碰撞时闪烁黄色边框，触发调整时显示"++1天"动画。
4. **自动演示**：可调速播放活动插入过程，按空格暂停观察当前状态。

### 关键动画逻辑
```javascript
function animateInsert(timeBlock, newEvent) {
  let currentPos = 0;
  while (currentPos < timeBlock.events.length) {
    const collision = checkCollision(newEvent, timeBlock.events[currentPos]);
    if (collision) {
      highlight(timeBlock.events[currentPos], 'yellow', 300);
      swapAnimation(newEvent, timeBlock.events[currentPos]);
      newEvent.date = tomorrow(newEvent.date);
      currentPos = 0; // 重新检测前序活动
    } else {
      currentPos++;
    }
  }
  addToTimeline(newEvent);
}
```

## 相似题目推荐
1. P1086 花生采摘（时间顺序处理）
2. P1908 逆序对（插入排序思想）
3. P1059 明明的随机数（数据分组处理）

---
处理用时：89.13秒
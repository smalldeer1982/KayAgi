# 题目信息

# [NOIP 2012 提高组] 同余方程

## 题目描述

求关于 $ x$ 的同余方程 $ a x \equiv 1 \pmod {b}$ 的最小正整数解。


## 说明/提示

### 数据规模与约定

- 对于 $40\%$ 的数据，$2 ≤b≤ 1,000$；
- 对于 $60\%$ 的数据，$2 ≤b≤ 50,000,000$；
- 对于 $100\%$ 的数据，$2 ≤a, b≤ 2,000,000,000$。



## 样例 #1

### 输入

```
3 10```

### 输出

```
7```

# AI分析结果



# 算法分类：扩展欧几里得算法

---

## 题解思路与核心算法分析

### 扩展欧几里得算法（ExGCD）核心流程
1. **问题转化**：将同余方程 $ax \equiv 1 \pmod{b}$ 转换为线性方程 $ax + by = 1$，需保证 $\gcd(a,b)=1$。
2. **递归求解**：
   - **基线条件**：当 $b=0$ 时，$\gcd(a,0)=a$，此时解为 $x=1, y=0$。
   - **递归步骤**：将问题分解为 $bx' + (a \mod b)y' = \gcd(b, a \mod b)$，通过回溯更新 $x$ 和 $y$：
     \[
     x = y', \quad y = x' - \left\lfloor \frac{a}{b} \right\rfloor y'
     \]
3. **解调整**：通过模运算 $(x \mod b + b) \mod b$ 将解调整为最小正整数。

### 欧拉定理方法要点
1. **欧拉函数**：计算 $\varphi(b)$，即与 $b$ 互质的数的个数。
2. **快速幂**：解为 $a^{\varphi(b)-1} \mod b$。
3. **限制**：质因数分解 $b$ 的复杂度为 $O(\sqrt{b})$，对大数效率较低。

---

## 题解评分（≥4星）

### 学委（★★★★★）
- **亮点**：完整推导扩展欧几里得算法，详细解释递归过程与解调整逻辑，代码可读性强。
- **代码片段**：
  ```cpp
  void exgcd(long long a, long long b) {
      if (b == 0) { x = 1; y = 7; return; }
      exgcd(b, a % b);
      long long tx = x;
      x = y;
      y = tx - a / b * y;
  }
  ```

### 陈曦（★★★★☆）
- **亮点**：提供多种解法对比，代码简洁，包含逆元应用场景说明。
- **代码片段**：
  ```cpp
  void exgcd(int a, int b, int &x, int &y) {
      if (!b) { x = 1; y = 0; return; }
      exgcd(b, a % b, y, x);
      y -= a / b * x;
  }
  ```

### xxxalq（★★★★☆）
- **亮点**：分步推导扩展欧几里得，强调时间复杂度 $O(\log \max(a,b))$。
- **代码片段**：
  ```cpp
  void exgcd(int a, int b, ll &x, ll &y) {
      if (b == 0) { x = 1; y = 0; return; }
      exgcd(b, a % b, y, x);
      y -= a / b * x;
  }
  ```

---

## 最优思路与技巧提炼

### 关键优化
- **负数解处理**：通过模运算调整解为最小正整数，避免逐次加减。
  ```cpp
  x = (x % b + b) % b;
  ```
- **递归参数传递**：直接交换 `x` 和 `y` 减少中间变量，简化代码。

### 同类型题推荐
1. **P3811**：模意义下的乘法逆元（线性求逆元）。
2. **P5656**：二元一次不定方程（扩展欧几里得应用）。
3. **P2613**：有理数取余（费马小定理求逆元）。

---

## 可视化与算法演示设计

### 复古像素动画方案
1. **Canvas 绘制**：
   - **网格布局**：展示递归调用栈，每层显示当前 `a` 和 `b` 的值。
   - **颜色标记**：当前层 `a` 和 `b` 用高亮绿色，回溯过程用橙色。
2. **音效设计**：
   - **递归调用**：8-bit 短音效。
   - **解调整**：成功音效（上扬音调）。
3. **交互控制**：
   - **步进按钮**：单步执行递归与回溯。
   - **速度滑块**：调节动画速度（0.5x~2x）。

### 示例动画帧
```
递归层 1: a=3, b=10 → 调用 exgcd(10, 3)
递归层 2: a=10, b=3 → 调用 exgcd(3, 1)
递归层 3: a=3, b=1 → 调用 exgcd(1, 0)
基线条件: b=0 → x=1, y=0
回溯层 3: x=0, y=1 - 3/1*0 = 1
回溯层 2: x=1, y=0 - 10/3*1 = -3
最终解: x=7 (调整后)
```

---

## 核心代码实现

### 扩展欧几里得算法（完整代码）
```cpp
#include <bits/stdc++.h>
using namespace std;
long long x, y;

void exgcd(long long a, long long b) {
    if (b == 0) { x = 1; y = 0; return; }
    exgcd(b, a % b);
    long long tx = x;
    x = y;
    y = tx - a / b * y;
}

int main() {
    long long a, b;
    cin >> a >> b;
    exgcd(a, b);
    x = (x % b + b) % b;
    cout << x << endl;
    return 0;
}
```

---

## 个人心得摘录

> **学委**：  
> “处理负数解时，批量加减 `b` 是关键，直接取模运算更高效。”  
> **调试经验**：在最后一层令 `y = 7` 仍能 AC，说明 `y` 的取值对最终解无影响。

> **沙普绿12138**：  
> “欧拉定理法在 `b` 分解质因数快时有效，但扩展欧几里得更通用。”  
> **踩坑提醒**：忘记处理 `b` 的剩余质因子（如 `n > 1`）会导致 $\varphi(b)$ 计算错误。

---
处理用时：95.17秒
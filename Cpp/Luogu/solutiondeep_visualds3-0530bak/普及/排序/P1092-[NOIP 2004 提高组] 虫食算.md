# 题目信息

# [NOIP 2004 提高组] 虫食算

## 题目描述

所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的数字。来看一个简单的例子：

$$\begin{aligned}
 \verb!43#9865#045! \\
+\qquad \verb!8468#6633! \\[-1em]\underline{\kern{8em}} \\
 \verb!44445509678! \\
\end{aligned}$$

其中 `#` 号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是 $5$ 和 $3$，第二行的数字是 $5$。

现在，我们对问题做两个限制：

首先，我们只考虑加法的虫食算。这里的加法是 $n$ 进制加法，算式中三个数都有 $n$ 位，允许有前导的 $0$。

其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是 $n$ 进制的，我们就取英文字母表的前 $n$ 个大写字母来表示这个算式中的 $0$ 到 $n - 1$ 这 $n$ 个不同的数字：但是这 $n$ 个字母并不一定顺序地代表 $0$ 到 $n-1$。输入数据保证 $n$ 个字母分别至少出现一次。

$$\begin{aligned}
 \verb!BADC! \\
+\quad \verb!CBDA! \\[-1em]\underline{\kern{4em}} \\
 \verb!DCCC! \\
\end{aligned}$$

上面的算式是一个4进制的算式。很显然，我们只要让 $\verb!ABCD!$ 分别代表 $0123$，便可以让这个式子成立了。你的任务是，对于给定的 $n$ 进制加法算式，求出 $n$ 个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 10$；
- 对于 $50\%$ 的数据，保证 $n \le 15$；
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 26$。

## 样例 #1

### 输入

```
5
ABCED
BDACE
EBBAA
```

### 输出

```
1 0 3 4 2
```

# AI分析结果



## 唯一算法分类
深度优先搜索（DFS）与剪枝优化

---

## 综合分析与结论

### 核心算法流程
1. **搜索顺序**：从右到左逐列处理，模拟竖式加法计算过程，优先处理低位。
2. **剪枝策略**：
   - **进位剪枝**：最高位不能有进位。
   - **即时验证**：每确定一列的值后，检查后续列是否存在不可能满足的情况。
   - **枚举优化**：倒序枚举数字（n-1到0），优先尝试较大值，可能更快触发剪枝。
3. **进位处理**：跟踪进位状态，递归时传递进位值到下一列。
4. **字母映射**：按字母在算式中出现的顺序确定搜索顺序，优先处理低位高频字母。

### 关键难点与解决
- **进位不确定性**：通过传递进位值并验证两种可能性（进位/不进位）来处理。
- **重复数字检查**：使用标记数组避免同一数字被多次使用。
- **高效剪枝**：在递归前预判当前列和后续列的合法性，提前终止无效路径。

---

## 题解清单（评分≥4星）

1. **zzlzk（4.5星）**
   - **亮点**：从右到左逐列搜索，剪枝逻辑清晰，使用`Next`数组优化搜索顺序。
   - **代码**：结构简洁，通过`CanPrune`函数提前验证合法性。

2. **feecle6418（4.5星）**
   - **亮点**：改变搜索顺序为低位优先，倒序枚举数字，剪枝覆盖多种情况。
   - **代码**：利用`check`函数在每一步验证，减少无效递归。

3. **Kelin（4星）**
   - **亮点**：参数化列和进位状态，剪枝逻辑紧凑，代码高度优化。
   - **代码**：通过逐列验证和进位传递实现高效搜索。

---

## 最优思路与技巧提炼

1. **倒序搜索与枚举**：
   - 按从右到左的列顺序处理，优先处理低位字母。
   - 倒序枚举数字（n-1到0），可能更快触发剪枝条件。

2. **剪枝策略整合**：
   - **合法性检查**：每确定一列的三个字母后，验证其是否满足加法规则（考虑进位）。
   - **后续预判**：递归前检查后续列是否可能存在无法满足的情况。

3. **进位传递**：
   - 通过递归参数传递进位值，确保每列计算时包含前一位的进位影响。

---

## 同类型题推荐
1. **P1784 数独**（DFS+剪枝）
2. **P1219 八皇后**（回溯与冲突检测）
3. **P1074 靶形数独**（复杂剪枝与状态管理）

---

## 代码片段（核心逻辑）
```cpp
void dfs(int x, int y, int carry) {
    if (x == 0) {
        if (carry == 0) 输出解;
        return;
    }
    // 剪枝：验证后续列是否可能合法
    for (int i = x - 1; i >= 1; --i) {
        int a = num[A[i]], b = num[B[i]], c = num[C[i]];
        if (a != -1 && b != -1 && c != -1) {
            if ((a + b) % n != c && (a + b + 1) % n != c) return;
        }
    }
    // 处理当前列
    if (num[当前字母] == -1) {
        for (int i = n - 1; i >= 0; --i) {
            if (!used[i]) {
                num[字母] = i; used[i] = 1;
                dfs(下一状态);
                num[字母] = -1; used[i] = 0;
            }
        }
    } else {
        // 直接递归处理下一列或进位
        dfs(x, y + 1, carry);
    }
}
```

---

## 可视化设计

### 动画方案
1. **列高亮**：当前处理的列以黄色背景显示，进位值实时显示在右侧。
2. **数字填充**：字母映射的数字动态填入，冲突时红色闪烁提示。
3. **回溯演示**：当剪枝触发时，路径变为灰色，显示回溯箭头。

### 复古像素风格
- **调色板**：16色FC风格，绿色表示合法路径，红色表示剪枝。
- **音效**：填充数字时播放8-bit点击音，找到解时播放胜利旋律。
- **自动演示**：按空格切换手动/自动模式，自动模式逐步展示搜索过程。

### 交互设计
- **控制面板**：速度滑块、暂停/继续按钮，高亮当前操作列。
- **网格视图**：竖式以网格显示，每格显示字母及其映射数字，进位值动态更新。

---

## 个人心得
- **调试关键**：初始代码未倒序枚举数字，导致TLE；调整后效率显著提升。
- **剪枝优化**：预判后续列的合法性检查是AC的关键，减少70%的递归调用。

---
处理用时：84.60秒
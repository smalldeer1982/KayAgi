# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果



### 唯一算法分类  
**拓扑排序 + 动态规划**

---

### 综合分析与结论  
该问题的核心是 **DAG 上的最长路径计算**，所有题解均围绕拓扑排序和动态规划展开。核心难点在于保证无后效性的状态转移，关键解决方案是通过拓扑序确保每个节点的前驱节点已处理完毕。可视化设计重点展示拓扑序生成过程和动态规划状态转移的联动，用颜色区分已处理节点、当前处理节点及待更新节点。

---

### 题解清单 (≥4星)  
1. **星星之火 (5星)**  
   - 详细解释拓扑排序与DP的关联性  
   - 代码清晰易懂，邻接表实现高效  
   - 关键亮点：明确指出拓扑序是保证无后效性的核心  
   - 个人心得：强调「DP必须在拓扑序中进行」的调试经验  

2. **_ZZH (4星)**  
   - 代码最简洁，拓扑排序与DP同步进行  
   - 关键优化：入度为0时直接初始化DP值  
   - 亮点：用队列同时处理拓扑序和状态转移  

3. **归山_ (4星)**  
   - 反向建图 + 记忆化搜索的独特思路  
   - 代码易理解，适合小规模数据  
   - 亮点：提出「逆向思维」的解题角度  

---

### 最优思路与代码实现  
#### 核心思路  
1. **拓扑排序**：将DAG转为线性序列，保证前驱节点先于当前节点处理  
2. **动态规划**：`dp[i] = max(dp[j] + 1)`，其中j为i的前驱节点  

#### 代码片段  
```cpp
void topsort() {
    queue<int> q;
    for (int i = 1; i <= n; i++)
        if (ru[i] == 0) q.push(i); // 初始入度为0的节点
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : edges[u]) {   // 遍历邻接节点
            dp[v] = max(dp[v], dp[u] + 1); // 关键状态转移
            if (--ru[v] == 0) q.push(v);
        }
    }
}
```

#### 完整代码  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
vector<int> edges[N];
int dp[N], ru[N], n, m;

void topsort() {
    queue<int> q;
    for (int i = 1; i <= n; i++)
        if (!ru[i]) q.push(i), dp[i] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : edges[u]) {
            dp[v] = max(dp[v], dp[u] + 1);
            if (--ru[v] == 0) q.push(v);
        }
    }
}

int main() {
    cin >> n >> m;
    while (m--) {
        int u, v; cin >> u >> v;
        edges[u].push_back(v);
        ru[v]++;
    }
    topsort();
    for (int i = 1; i <= n; i++) 
        cout << dp[i] << "\n";
}
```

---

### 同类型题与算法套路  
1. **关键特征**：DAG、最长/最短路径、前驱依赖  
2. **通用解法**：拓扑排序 + 动态规划  
3. **类似题目**  
   - P4017（最大食物链计数）  
   - P1807（最长路）  
   - P1113（杂务调度）  

---

### 可视化设计  
#### 动画方案  
1. **拓扑排序过程**：  
   - 当前处理节点高亮为黄色  
   - 已处理节点变为绿色  
   - 队列中的节点显示为蓝色边框  

2. **动态规划更新**：  
   - 状态转移时，显示`dp[v] = max(dp[v], dp[u]+1)`公式  
   - 被更新的节点数值闪烁红色  

#### 复古像素风格  
- **Canvas 绘制**：用16x16像素网格表示节点，边用橙色线条连接  
- **音效设计**：  
  - 节点入队：8-bit "哔"声  
  - 状态更新：短促电子音  
  - 完成处理：胜利旋律片段  

#### 交互功能  
- **速度控制**：滑动条调节动画速度（0.5x~3x）  
- **单步执行**：按空格键逐步执行拓扑排序  
- **数据追踪**：鼠标悬停显示节点的入度和DP值  

---

### 推荐相似题目  
1. **P4017 最大食物链计数**  
   - DAG路径计数，拓扑排序+DP的变种  

2. **P1807 最长路**  
   - 加权DAG的最长路径，需修改状态转移公式  

3. **P1113 杂务调度**  
   - 拓扑排序求关键路径，需处理时间参数  

---

### 个人心得摘录  
> 「调试时发现必须严格按拓扑序更新DP值，否则会漏算某些路径。通过打印拓扑序列和DP数组逐步验证，最终确定处理顺序的重要性。」——星星之火  

> 「反向建图后DFS的写法更符合直觉，但要注意递归深度。测试时发现N=1e5会栈溢出，改用迭代式DFS解决。」——归山_  

---

通过以上分析，拓扑排序+动态规划是该题的最优解法，兼顾效率与可读性。可视化设计应重点突出拓扑序与状态转移的联动过程，帮助理解无后效性原则。

---
处理用时：82.83秒
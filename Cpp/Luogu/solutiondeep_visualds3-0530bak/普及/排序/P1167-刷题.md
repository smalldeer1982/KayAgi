# 题目信息

# 刷题

## 题目描述

NOIP 临近了，小 A 却发现他已经不会写题了。好在现在离竞赛还有一段时间，小 A 决定从现在开始夜以继日地刷题。也就是说小 A 废寝忘食，一天二十四小时地刷题。

今天的日期（时间）是 yyyy 年 mm 月 dd 日 hh 时 MM 分，考试的时间是 yyyy2 年 mm2 月 dd2 日 hh2 时 MM2 分。这之间的所有时间小 A 都用来刷题了，那么考试之前他最多能刷多少题呢？注意哦，考虑闰年。

时间紧张小 A 只管数量不管质量。当然有的题目容易一些，有的题目难一些。根据小 A 的经验，他能一眼看出写出某一个题目需要的时间，以分钟记。

现在给出洛谷 Online Judge 的题目列表，请你挑出最多的题目使小A能在竞赛前写出来。

我们假设从远古到未来，历法的表示与现在一样。


## 样例 #1

### 输入

```
2
1
1
2007-06-23-11:59
2007-06-23-12:00```

### 输出

```
1```

# AI分析结果



# 算法分类选择  
**模拟、贪心**

---

## 题解思路与核心难点  
### **核心思路**  
所有题解均采用以下步骤：  
1. **时间差计算**：将起始时间和结束时间转换为总分钟数，相减得到可用时间  
2. **贪心选择**：按题目耗时排序，从小到大累加直至时间不足  

### **解决难点**  
1. **闰年处理**：通过`year%4==0 && year%100!=0 || year%400==0`判断  
2. **月份天数差异**：使用预定义数组存储各月天数，动态调整二月天数  
3. **跨年计算**：分年份累加天数时区分闰年和平年，避免逐日计算的低效  

### **关键实现对比**  
| 方法               | 优势                     | 典型题解          |  
|--------------------|-------------------------|------------------|  
| 基准时间法         | 数学计算高效，无循环       | wyly、ztzshiwo   |  
| 逐层累加法         | 逻辑直观，易调试          | Ousmane_Dembele  |  
| Java Calendar类    | 内置日期计算，代码简洁     | outis_crypt      |  

---

## 题解评分与推荐  
### **★★★★★ 推荐题解**  
1. **傅思维666**  
   - 亮点：采用"多退少补"思想逐层处理年月日，代码结构清晰  
   - 核心代码：  
     ```cpp  
     for(int i=start[1];i<endd[1];i++) {  
         if(check(i)) time += 366*24*60;  
         else time += 365*24*60;  
     }  
     ```  

2. **king_xbz**  
   - 亮点：模块化处理年/月/日转换，可扩展性强  
   - 关键函数：  
     ```cpp  
     void year_to_day() {  
         for(int i=a;i<x;i++)  
             tot += is_leap(i) ? 366 : 365;  
     }  
     ```  

3. **outis_crypt (Java)**  
   - 亮点：利用Calendar类简化计算，适合快速实现  
   - 核心逻辑：  
     ```java  
     Calendar aDate = Calendar.getInstance();  
     long diff = (bDate.getTime() - aDate.getTime()) / 60000;  
     ```  

---

## 最优技巧提炼  
1. **基准时间法**：  
   - 将0000-01-01作为基准点，计算两个时间的总分钟数差值  
   - 示例代码：  
     ```cpp  
     long long getTotalMinutes(int y, int m, int d, int h, int min) {  
         long long total = 0;  
         for(int i=0; i<y; i++)  
             total += is_leap(i) ? 366*1440 : 365*1440;  
         // 累加月、日、时、分...  
         return total;  
     }  
     ```  

2. **多退少补策略**：  
   - 先计算完整年份，再修正起始/结束年的部分月份  
   - 关键步骤：  
     ```  
     总时间 = 结束年基准分钟 - 起始年基准分钟  
     修正起始年未用完的月份天数  
     修正结束年多计算的月份天数  
     ```  

---

## 同类题目推荐  
1. **P1515**[计算两个日期相差天数]  
2. **P1201**[闰年判断与日期计算]  
3. **P1006**[时间区间交集计算]  

---

## 可视化算法演示  
### **动画设计**  
1. **时间轴展开**：  
   - 横向时间轴显示年份区块，**红色高亮**闰年区块  
   - 点击年份展开月份网格，动态显示每月累加过程  

2. **贪心过程动态**：  
   - 左侧柱状图显示题目耗时排序，**绿色填充**已选题目  
   - 右侧倒计时条实时显示剩余时间  

### **复古像素风格实现**  
```javascript  
// Canvas绘制示例  
ctx.fillStyle = '#8B00FF'; // 紫色像素块表示闰年  
ctx.fillRect(x*16, y*16, 16, 16);  

// 音效触发  
function playSound(type) {  
    const sfx = {  
        add: new Audio('data:audio/wav;base64,UklGRl9...'),  
        complete: new Audio('data:audio/wav;base64,UklGRk9...')  
    };  
    sfx[type].play();  
}  
```  

### **交互控制**  
- **WASD**控制时间轴浏览  
- **空格键**单步执行贪心选择  
- **F1**切换自动演示模式  

---

## 核心代码实现  
傅思维666题解的关键片段：  
```cpp  
// 计算年份差值  
for(int i=start[1];i<endd[1];i++) {  
    if(check(i)) time += 366*24*60;  
    else time += 365*24*60;  
}  

// 修正月份  
if(check(start[1]))  
    for(int i=1;i<start[2];i++) time -= m2[i]*24*60;  
else  
    for(int i=1;i<start[2];i++) time -= m1[i]*24*60;  

// 贪心选择  
sort(a, a+n);  
for(int i=0; i<n; i++){  
    if(time >= a[i]) {  
        time -= a[i];  
        ans++;  
    } else break;  
}  
```  

---

通过这种结构化分析，学习者可以快速掌握日期计算类问题的通用解法，并在可视化交互中深化对算法流程的理解。

---
处理用时：105.29秒
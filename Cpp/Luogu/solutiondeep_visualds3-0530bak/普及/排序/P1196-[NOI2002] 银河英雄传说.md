# 题目信息

# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 说明/提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)

题目中没有强制 $i \neq j$，但是实测数据中不存在 $i = j$ 的情况。

## 样例 #1

### 输入

```
4
M 2 3
C 1 2
M 2 4
C 4 2```

### 输出

```
-1
1```

# AI分析结果



# 算法分类  
**带权并查集**

---

## 综合分析与结论  
### 核心算法流程
1. **数据结构设计**  
   - `fa[]`：记录节点的父节点  
   - `d[]`：记录节点到父节点的距离  
   - `size[]`：记录集合大小（仅根节点有效）  

2. **核心操作**  
   - **路径压缩**：在`find`函数递归回溯时动态更新每个节点到根节点的距离  
   - **合并操作**：将集合A的根节点连接到集合B的根节点，并更新`d[A] = size[B]`，同时`size[B] += size[A]`  
   - **查询操作**：计算两个节点到根节点的距离差值减1  

3. **解决难点**  
   - 动态维护节点间的相对距离，通过路径压缩保证查询时间复杂度为近似O(1)  
   - 合并时通过`size`数组计算新增距离，避免重复遍历整个集合  

---

## 题解清单 (≥4星)  
### 题解1：假装思考（⭐⭐⭐⭐⭐）  
**核心亮点**：  
- 使用`front[]`数组记录到根节点的距离  
- 通过`num[]`数组维护集合大小，合并时直接更新根节点数据  
- 代码结构清晰，路径压缩逻辑简明  

```cpp
int find(int n){
    if(fa[n]==n) return n;
    int fn=find(fa[n]);
    front[n] += front[fa[n]]; // 回溯时更新距离
    return fa[n] = fn;
}
```

### 题解2：破壁人（⭐⭐⭐⭐）  
**核心亮点**：  
- 使用`dis[]`和`b[]`分别表示距离和集合大小  
- 在`find`函数中同时更新两个辅助数组  

```cpp
int find(int o){
    if(f[o]==o) return o;
    int k=f[o];
    f[o]=find(f[o]);
    s[o] += s[k]; // 路径压缩时更新
    return f[o];
}
```

### 题解3：Mr_Wolfram（⭐⭐⭐⭐）  
**核心亮点**：  
- 明确定义`dis`为到根节点的距离  
- 合并时通过`dis[r1] = dis[r2] + num[r2]`计算新增距离  

```cpp
void merge(int x,int y){
    int r1=find(x), r2=find(y);
    dis[r1] = dis[r2] + num[r2];
    num[r2] += num[r1];
    fa[r1] = r2;
}
```

---

## 最优思路提炼  
### 关键技巧
1. **路径压缩时的动态更新**  
   ```python
   def find(x):
       if fa[x] != x:
           root = find(fa[x])
           d[x] += d[fa[x]]  # 关键：累加父节点的距离
           fa[x] = root
       return fa[x]
   ```
2. **合并时的距离计算**  
   ```python
   def union(x, y):
       fx = find(x)
       fy = find(y)
       fa[fx] = fy
       d[fx] = size[fy]  # 新距离等于目标集合原始大小
       size[fy] += size[fx]
   ```

---

## 同类型题与算法套路  
### 相似算法模式
1. **带权并查集通用公式**  
   - 维护公式：`d[x] = d[x] ⊕ d[fa[x]]`（⊕可能是+、-或异或）  
   - 典型应用：食物链（种类并查集）、区间奇偶性判断  

### 推荐题目
1. **P2024 食物链**（三状态带权并查集）  
2. **P5937 奇偶游戏**（异或型带权并查集）  
3. **P1197 星球大战**（逆向并查集）

---

## 可视化与算法演示  
### 动画设计
1. **像素风格演示**  
   - **节点显示**：用16x16像素块表示战舰，不同颜色区分集合  
   - **合并过程**：源集合整体平移并附加到目标集合尾部，播放8-bit音效  
   - **路径压缩**：显示节点快速"跳级"到根节点的动画  

2. **交互控制**  
   ```javascript
   class UnionFindViz {
       constructor() {
           this.speed = 1; // 可调节动画速度
           this.playSound('move'); // 移动时播放chip音效
       }
       
       async find(x) {
           while(fa[x] != x) {
               highlight(x); // 高亮当前处理节点
               await delay(500/this.speed);
               x = fa[x];
           }
           // ...路径压缩回溯过程
       }
   }
   ```

3. **状态面板**  
   ```html
   <div class="status">
      当前操作: <span id="op">M 2 3</span>
      集合大小: <span id="size">5</span>
      距离差值: <span id="diff">3</span>
   </div>
   ```

---

## 代码实现（核心逻辑）  
### 带权并查集标准实现
```cpp
#include <iostream>
#include <cmath>
using namespace std;

const int MAXN = 30010;
int fa[MAXN], d[MAXN], size[MAXN];

void init() {
    for(int i=1; i<MAXN; ++i) {
        fa[i] = i;
        size[i] = 1;
        d[i] = 0;
    }
}

int find(int x) {
    if(fa[x] != x) {
        int root = find(fa[x]);
        d[x] += d[fa[x]]; // 关键：累加父节点距离
        fa[x] = root;
    }
    return fa[x];
}

void merge(int x, int y) {
    int fx = find(x), fy = find(y);
    if(fx == fy) return;
    fa[fx] = fy;
    d[fx] = size[fy];     // 新距离=目标集合原始大小
    size[fy] += size[fx]; // 更新集合大小
}

int query(int x, int y) {
    if(find(x) != find(y)) return -1;
    return abs(d[x]-d[y])-1;
}
```

---

## 复古游戏化实现要点  
1. **像素风格**：使用NES调色板（#401070主色调）  
2. **音效设计**：  
   - 合并成功：FC版"马里奥吃金币"音效  
   - 查询失败：FC版"塞尔达陷阱"音效  
3. **成就系统**：  
   - 连续10次正确查询解锁"银河指挥官"称号  
   - 合并超过100次触发隐藏BOSS战彩蛋  

通过这种多维度解析，学习者既能掌握算法本质，又能通过可视化加深理解，最终达到举一反三的效果。

---
处理用时：76.65秒
# 题目信息

# 摄像头

## 题目描述

食品店里有 $n$ 个摄像头，这种摄像头很笨拙，只能拍摄到固定位置。现有一群胆大妄为的松鼠想要抢劫食品店，为了不让摄像头拍下他们犯罪的证据，他们抢劫前的第一件事就是砸毁这些摄像头。

为了便于砸毁摄像头，松鼠歹徒们把所有摄像头和摄像头能监视到的地方统一编号，一个摄像头能被砸毁的条件是该摄像头所在位置不被其他摄像头监视。

现在你的任务是帮松鼠们计算是否可以砸掉所有摄像头，如不能则输出还没砸掉的摄像头的数量。

## 说明/提示

$1 \leq n \leq 100$。

$0 \leq m \leq 100$。

$0 \leq x,y \leq 500$。


## 样例 #1

### 输入

```
5
1 1 2
2 1 1
3 1 7
4 1 1
5 0
```

### 输出

```
2```

# AI分析结果



**唯一算法分类**  
拓扑排序

---

**综合分析与结论**  
#### 核心算法流程  
1. **图建模**：将每个摄像头视为节点，若摄像头A监视的位置存在摄像头B，则建立A→B的有向边  
2. **入度统计**：记录每个摄像头被其他摄像头监视的次数（入度）  
3. **拓扑处理**：  
   - 将初始入度为0的摄像头加入队列  
   - 每次取出队列头节点，减少其监视的所有摄像头的入度  
   - 若某摄像头入度归零且未被处理，加入队列  
4. **结果判断**：已处理节点数等于总摄像头数则全可砸，否则剩余未处理数即为答案  

#### 可视化设计要点  
- **像素风格网格**：用16x16像素块表示摄像头节点，不同颜色区分状态：  
  - 绿色：可处理（入度=0）  
  - 红色：循环节点（入度>0且无法消减）  
  - 灰色：已处理节点  
- **动画效果**：  
  1. 初始展示所有节点的入度数值  
  2. 队列元素以闪烁边框突出显示  
  3. 处理节点时触发"爆破"粒子动画，并播放8-bit音效  
- **交互面板**：  
  - 速度滑块控制算法执行间隔（100ms~2s）  
  - 单步执行按钮观察每个入度变化细节  
  - 音效开关支持复古芯片音乐与爆破音效  

---

**题解清单 (≥4星)**  
1. **llzzxx712（5星）**  
   - 亮点：邻接表存储优化空间，快读提升IO效率，注释清晰  
   - 关键代码段：  
     ```cpp
     void add(int x,int y){ // 建边并更新入度
         to[++tot]=y,ne[tot]=head[x],head[x]=tot,edge[y]++;
     }
     while(!q.empty()){ // 拓扑处理核心逻辑
         int x=q.front(); q.pop();
         for(int i=head[x];i;i=ne[i]) 
             if(--edge[y]==0 && v[y]) q.push(y);
     }
     ```

2. **henrytb（4星）**  
   - 亮点：邻接矩阵直观易读，最大编号优化遍历范围  
   - 关键优化：  
     ```cpp
     for(int i=0;i<=maxx;i++) // 仅遍历实际存在的节点范围
         if(du[i]==0&&used[i]) q[++r]=i;
     ```

3. **SovietPower✨（4星）**  
   - 亮点：map离散化处理稀疏编号，结构体封装清晰  
   - 特色处理：  
     ```cpp
     map<int,int> table; // 位置到数组下标的映射
     if(table.find(tar) != table.end()) // 精准判断有效节点
     ```

---

**最优技巧提炼**  
1. **入度动态维护**：通过建边时同步更新入度数组，避免后续重复计算  
2. **存在性标记**：使用`v[]`数组标记有效摄像头位置，区分普通区域  
3. **队列批处理**：通过队列实现拓扑序的层序处理，天然保证处理顺序正确性  

---

**同类型题推荐**  
1. **P1137 旅行计划**（拓扑排序+DP）  
2. **P2741 [USACO4.4] 重叠图像Frame Up**（拓扑排序求所有拓扑序）  
3. **P4017 最大食物链计数**（拓扑排序+路径统计）  

---

**调试心得分录**  
> *来自llzzxx712题解*：  
> "WA了10次才发现数组开小了，位置编号最大500但建边数可能达到(100+100)*100=20000级别"  
> **教训**：图论题需仔细计算边数上限，特别是稀疏图转稠密图场景  

---

**代码实现片段（核心逻辑）**  
```javascript
// 拓扑排序动画核心逻辑（伪代码）
function topologicalSort() {
    let q = initialZeroIndegreeNodes(); 
    while (q.length) {
        const node = q.shift();
        highlight(node, COLOR_PROCESSING); // 高亮当前节点
        playSound('pop'); // 爆破音效
        
        node.edges.forEach(neighbor => {
            if (--neighbor.indegree === 0) {
                q.push(neighbor);
                highlight(neighbor, COLOR_READY); // 新可处理节点
            }
        });
        
        markProcessed(node); // 标记为已处理
        await delay(speed); // 根据滑块速度暂停
    }
}
```

---

**复古像素动画实现**  
```html
<canvas id="pixelCanvas"></canvas>
<script>
// 初始化500x500网格（每个像素块代表一个可能的位置）
const GRID_SIZE = 10; // 10px per block
const ctx = document.getElementById('pixelCanvas').getContext('2d');

function drawNode(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*GRID_SIZE, y*GRID_SIZE, GRID_SIZE-1, GRID_SIZE-1);
    ctx.fillStyle = 'white';
    ctx.font = '8px "Press Start 2P"'; // 复古字体
    ctx.fillText(indegree[x][y], x*GRID_SIZE+2, y*GRID_SIZE+8);
}
</script>
```

---
处理用时：73.86秒
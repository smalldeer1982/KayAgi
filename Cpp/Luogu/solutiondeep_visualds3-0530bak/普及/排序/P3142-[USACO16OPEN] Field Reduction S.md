# 题目信息

# [USACO16OPEN] Field Reduction S

## 题目描述

Farmer John 的 $N$ 头奶牛（$5 \leq N \leq 50,000$）都位于他二维牧场中的不同位置。FJ 希望用一个边平行于 $x$ 轴和 $y$ 轴的矩形围栏围住所有的奶牛，并且他希望这个围栏尽可能小，以便能够包含每头奶牛（允许奶牛位于边界上）。

不幸的是，由于上个季度牛奶产量低，FJ 的预算非常紧张。因此，他希望如果可能的话，建造一个更小的围栏，并且他愿意从他的牛群中出售最多三头奶牛来实现这一目标。

请帮助 FJ 计算在从他的牛群中移除最多三头奶牛后，他可以用围栏围住的最小可能面积（然后为剩余的奶牛建造最紧密的围栏）。

对于这个问题，请将奶牛视为点，将围栏视为四条线段的集合（即不要将奶牛视为“单位正方形”）。请注意，答案可能为零，例如如果所有剩余的奶牛最终站在一条共同的垂直线或水平线上。

## 样例 #1

### 输入

```
6
1 1
7 8
10 9
8 12
4 100
50 7```

### 输出

```
12```

# AI分析结果



## 算法分类
**暴力枚举 + 极值优化**

---

## 题解思路与核心分析

### 核心难点
1. **极值点选择**：只有删除位于极值点（x/y方向的最小或最大值附近的点）才能有效缩小包围矩形的面积。如何快速筛选这些关键点？
2. **去重处理**：同一头牛可能同时是x和y方向的极值，需避免重复枚举。
3. **时间复杂度**：直接暴力枚举所有三头牛的组合复杂度为 $O(N^3)$，必须优化到 $O(1)$ 或常数级别。

### 算法要点
1. **极值候选集生成**：
   - 按x排序，取x最小的3头和最大的3头。
   - 按y排序，取y最小的3头和最大的3头。
   - 合并所有候选点并去重，最终候选集大小不超过12。
2. **暴力枚举**：在候选集中枚举删除的3头牛，计算剩余牛的极值差并更新最小面积。

### 解决难点对比
- **Unordered_OIer**：通过双重排序（x和y）标记待删除的牛，但未显式去重，可能重复计算。
- **Violet___Evergarden**：显式记录极值点编号，手动枚举所有可能组合，但代码冗长。
- **mysterys**：使用 `unique` 函数去重，代码简洁高效。

---

## 题解评分（≥4星）

1. **mysterys（5星）**
   - **亮点**：代码简洁，利用 `unique` 去重，时间复杂度最优。
   - **代码片段**：
     ```cpp
     void to_m() {
         sort(a+1,a+n+1,cmp1);
         m[++idx]=a[1].id; ... // 添加极值点
         sort(m+1,m+idx+1); // 去重前排序
         idx = unique(m+1,m+idx+1) - m; // 去重
     }
     ```

2. **Zenith_Yeh（4星）**
   - **亮点**：分步处理x/y极值，标记数组避免重复删除。
   - **代码片段**：
     ```cpp
     void pd(int a,int b,int c,int d) {
         memset(bj,0,sizeof(bj));
         for(int i=1;i<=a;i++) bj[op[i].id]=1; // 标记x极值
         // 处理y极值并更新面积
     }
     ```

3. **ikunTLE（4星）**
   - **亮点**：思路清晰，强调极值点筛选，但未显式去重。
   - **关键说明**：“最优情况必定在极值点中”。

---

## 最优思路提炼

1. **极值候选集**：收集每个坐标方向的前3小和前3大点，共12个候选点。
2. **去重优化**：使用 `unique` 或标记数组避免重复计算同一头牛。
3. **暴力枚举**：仅需枚举候选集中的3头牛，时间复杂度为 $O(1)$。

---

## 同类题目推荐

1. **P1842 [USACO05NOV] 奶牛玩杂技**：极值条件下的贪心排序。
2. **P2216 [HAOI2007] 理想的正方形**：二维滑动窗口求极值。
3. **P1880 [NOI1995] 石子合并**：区间DP中的极值优化。

---

## 个人心得摘录

- **D23lhc**：“INF设置不够大会导致WA，需设为 $4 \times 10^9$ 以上”。
- **Violet___Evergarden**：“手动枚举所有极值组合，确保不漏情况”。

---

## 算法可视化设计（复古像素风格）

### 动画设计
1. **极值点高亮**：
   - 用红色像素块标记x最小/大的前3头牛，蓝色标记y方向的极值牛。
2. **枚举过程**：
   - 每次枚举3头牛时，用绿色边框高亮，播放“选择音效”。
3. **面积更新**：
   - 当找到更小面积时，包围矩形闪烁黄色，播放“成功音效”。
4. **自动演示**：
   - 按空格键切换自动/手动模式，自动模式逐步显示最优解的寻找过程。

### 代码片段（Canvas绘制极值点）
```javascript
function drawCows() {
  ctx.fillStyle = '#FF0000'; // 红色为x极值
  candidateX.forEach(cow => ctx.fillRect(cow.x*10, cow.y*10, 8, 8));
  ctx.fillStyle = '#0000FF'; // 蓝色为y极值
  candidateY.forEach(cow => ctx.fillRect(cow.x*10, cow.y*10, 8, 8));
}
```

---

## 核心代码实现（mysterys题解关键逻辑）

```cpp
void to_m() {
    sort(a+1,a+n+1,cmp1);
    // 添加x极值点
    for(int i=1;i<=3;i++) m[++idx]=a[i].id;
    for(int i=n;i>=n-2;i--) m[++idx]=a[i].id;
    sort(a+1,a+n+1,cmp2);
    // 添加y极值点
    for(int i=1;i<=3;i++) m[++idx]=a[i].id;
    for(int i=n;i>=n-2;i--) m[++idx]=a[i].id;
    // 去重
    sort(m+1,m+idx+1);
    idx = unique(m+1,m+idx+1) - m - 1;
}

int getans(int p1,int p2,int p3) {
    int maxx=0, minx=INF, maxy=0, miny=INF;
    for(int i=1;i<=n;i++) {
        if(a[i].id==p1 || a[i].id==p2 || a[i].id==p3) continue;
        // 更新极值
        maxx = max(maxx, a[i].x);
        minx = min(minx, a[i].x);
        // ... 类似处理y
    }
    return (maxx-minx)*(maxy-miny);
}
```

---
处理用时：109.56秒
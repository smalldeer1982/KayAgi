# 题目信息

# [HAOI2009] 巧克力

## 题目描述

有一块 $n \times m$ 的矩形巧克力，准备将它切成 $n \times m$ 块。巧克力上共有 $n-1$ 条横线和 $m-1$ 条竖线，你每次可以沿着其中的一条横线或竖线将巧克力切开，无论切割的长短，沿着每条横线切一次的代价依次为 $y_1,y_2,\cdots,y_{n-1}$，而沿竖线切割的代价依次为 $x_1,x_2,\cdots,x_{m-1}$。

例如，对于下图 $6 \times 4$ 的巧克力，我们先沿着三条横线切割，需要 $3$ 刀，得到 $4$ 条巧克力，然后再将这 $4$ 条巧克力沿竖线切割，每条都需要 $5$ 刀，则最终所花费的代价为 $y_1+y_2+y_3+4 \times (x_1+x_2+x_3+x_4+x_5)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/juiv548x.png)


当然，上述简单切法不见得是最优切法，那么怎样切割该块巧克力，花费的代价最少呢？


## 说明/提示


$30\%$ 的数据，$n \leq 100,m \leq 100$；

$100\%$ 的数据，$n \leq 10000,m \leq 10000$；

## 样例 #1

### 输入

```
6 4
2
1
3
1
4
4
1
2```

### 输出

```
42```

# AI分析结果



**唯一算法分类**：贪心算法

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   每次选择未切割的横/竖线中代价最大的切割，并累加其代价乘以另一方向当前切割次数+1。正确性基于贪心选择：优先处理高代价切割，减少后续切割次数对其的乘法影响。

2. **算法流程**  
   - **排序**：将所有横竖切割线按代价降序排序。
   - **遍历处理**：依次选择最大代价切割线，若为横切，则总代价 += 当前代价 × (已竖切次数 + 1)，并更新横切次数；竖切同理。
   - **变量维护**：用 `s1` 记录已横切次数，`s2` 记录已竖切次数。

3. **解决难点**  
   - **贪心正确性证明**：当两条切割线代价不同时，优先处理大的；若代价相同，顺序不影响最终结果。
   - **时间复杂度优化**：直接排序后遍历（O((n+m)log(n+m))）比双重循环（O(nm)）更优。

---

### **题解评分 (≥4星)**

| 作者       | 星级 | 关键亮点                                                                 |
|------------|------|--------------------------------------------------------------------------|
| Tarsal     | ⭐⭐⭐⭐ | 优先队列动态取最大值，代码注释详细，包含两种实现方式便于理解。             |
| kkxhh      | ⭐⭐⭐⭐ | 简洁的优先队列实现，附带贪心策略的数学证明，代码可读性高。                 |
| MSqwq      | ⭐⭐⭐⭐ | 结构体排序统一处理，代码简洁且时间复杂度最优，适合大规模数据。             |

---

### **最优思路与技巧提炼**

1. **统一排序法**  
   - 将横竖切割线合并排序，避免动态比较的复杂度。
   - **代码片段**：
     ```cpp
     struct node { int v, type; };
     sort(a, a + n + m, [](node a, node b) { return a.v > b.v; });
     for (auto x : a) {
         if (x.type == 横切) ans += x.v * (s2 + 1), s1++;
         else ans += x.v * (s1 + 1), s2++;
     }
     ```

2. **优先队列动态选择**  
   - 分别维护横竖切割的最大堆，每次取堆顶元素比较。
   - **代码片段**：
     ```cpp
     priority_queue<int> q1, q2;
     while (!q1.empty() && !q2.empty()) {
         if (q1.top() > q2.top()) ans += q1.top() * s2, s1++, q1.pop();
         else ans += q2.top() * s1, s2++, q2.pop();
     }
     ```

---

### **同类型题与算法套路**

- **通用解法**：当问题涉及多次操作且每次操作影响后续代价时，贪心选择当前影响最大的操作。
- **类似题目**：  
  1. [P1324 矩形分割](https://www.luogu.com.cn/problem/P1324)（本题双倍经验）
  2. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（优先队列贪心）
  3. [P1233 木棍加工](https://www.luogu.com.cn/problem/P1233)（排序后贪心）

---

### **可视化与算法演示**

1. **动画设计**  
   - **像素风格界面**：用不同颜色方块表示切割线，红色为横切，蓝色为竖切。
   - **高亮当前操作**：选中切割线时闪烁显示，右侧面板显示当前 `s1`、`s2` 和累计代价。
   - **步骤分解**：  
     1. 初始巧克力显示为网格，切割线高亮。
     2. 每次选择最大代价线切割，显示切割后的分块数和代价计算。
     3. 累计总代价在顶部动态更新。

2. **复古游戏化实现**  
   - **音效**：切割时播放 "8-bit 切割声"，正确选择时触发 "金币音效"。
   - **Canvas 绘制**：用 16x16 像素块模拟巧克力，切割线用 2 像素宽线条表示。
   - **自动演示模式**：按空格键切换自动/手动，自动模式下算法以 1 秒/步执行。

---

### **代码实现（核心逻辑）**

**结构体排序法**（完整代码）：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

struct Node { int v, type; };
Node a[20010];
int n, m, s1 = 1, s2 = 1;
long long ans;

int main() {
    cin >> n >> m;
    for (int i = 0; i < n - 1; i++) cin >> a[i].v, a[i].type = 0;
    for (int i = n - 1; i < n + m - 2; i++) cin >> a[i].v, a[i].type = 1;
    sort(a, a + n + m - 2, [](Node a, Node b) { return a.v > b.v; });
    for (int i = 0; i < n + m - 2; i++) {
        if (a[i].type == 0) ans += a[i].v * s2, s1++;
        else ans += a[i].v * s1, s2++;
    }
    cout << ans;
    return 0;
}
```

---

### **个人心得摘录**

- **Tarsal 的调试经验**：  
  > "WA 了一次后发现优先队列未处理完剩余元素，补上两个 while 循环后 AC。贪心必须彻底处理所有元素！"
  
- **kkxhh 的思维顿悟**：  
  > "突然意识到横竖切割的乘法影响是对称的，只需统一排序，无需分开处理，代码瞬间简化。"

---

### **推荐题目**

1. [P2245 星际导航](https://www.luogu.com.cn/problem/P2245)（最小生成树 + 贪心边排序）
2. [P4053 建筑抢修](https://www.luogu.com.cn/problem/P4053)（截止时间贪心 + 优先队列）
3. [P5021 赛道修建](https://www.luogu.com.cn/problem/P5021)（二分答案 + 贪心拼接）

---
处理用时：98.36秒
# 题目信息

# 最大食物链计数

## 题目背景

你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。


## 题目描述

给你一个食物网，你要求出这个食物网中最大食物链的数量。

（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）

Delia 非常急，所以你只有 $1$ 秒的时间。

由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。


## 说明/提示

各测试点满足以下约定：

 ![](https://cdn.luogu.com.cn/upload/pic/12011.png) 

【补充说明】

数据中不会出现环，满足生物学的要求。（感谢 @AKEE ）


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 3
3 5
2 5
4 5
3 4```

### 输出

```
5```

# AI分析结果



### 【唯一算法分类】拓扑排序

---

### **综合分析与结论**

**题目核心**：DAG 中统计所有从入度 0（生产者）到出度 0（最高消费者）的路径数量。  
**关键思路**：  
- **拓扑排序**：按拓扑序递推路径数，入度为 0 的节点初始化路径数，遍历邻接点时累加路径数。  
- **动态规划**：用 `f[i]` 表示到节点 `i` 的路径数，递推公式为 `f[to] += f[from]`。  

**难点对比**：  
- **拓扑排序 vs 记忆化搜索**：前者通过队列严格按顺序处理节点，避免重复计算；后者需处理递归深度和状态记忆。  
- **邻接矩阵 vs 邻接表**：邻接矩阵空间复杂度高（O(n²)），但查找边方便；邻接表（链式前向星）更省空间，适合稀疏图。  

**可视化设计**：  
- **动画流程**：  
  1. **节点染色**：生产者（蓝色）、消费者（红色）、普通节点（灰色）。  
  2. **拓扑队列**：展示队列动态变化，当前处理的节点高亮为黄色。  
  3. **路径累加**：用箭头动态显示 `f[to] += f[from]`，数值实时更新。  
- **复古像素风格**：  
  - **Canvas 网格**：节点用 16x16 像素方块表示，边用绿色像素线连接。  
  - **音效**：节点入队时播放短促“滴”声，路径累加时播放“叮”声。  
  - **自动模式**：AI 按拓扑序自动执行，支持暂停/步进。  

---

### **题解清单（评分 ≥4 星）**

1. **御·Dragon（5 星）**  
   - **亮点**：详细图解拓扑排序递推过程，代码清晰，变量命名规范。  
   - **核心代码**：  
     ```cpp
     while (!q.empty()) {
         int tot = q.front(); q.pop();
         for (int next : nei[tot]) {
             num[next] = (num[next] + num[tot]) % mod;
             if (--in[next] == 0) q.push(next);
         }
     }
     ```

2. **Watcher（4.5 星）**  
   - **亮点**：对比邻接矩阵与邻接表实现，提供优化建议。  
   - **核心代码**：  
     ```cpp
     for (int k = h[a]; k; k = d[k].n) {
         f[d[k].b] = (f[d[k].b] + f[a]) % mod;
         if (--ru[d[k].b] == 0) q.push(d[k].b);
     }
     ```

3. **Y_BY（4 星）**  
   - **亮点**：逆向记忆化搜索，从消费者反向递推到生产者。  
   - **核心代码**：  
     ```cpp
     int dfs(int x) {
         if (dp[x]) return dp[x];
         for (int i = head[x]; i; i = e[i].nxt)
             dp[x] = (dp[x] + dfs(e[i].to)) % MOD;
         return dp[x];
     }
     ```

---

### **最优思路提炼**

1. **拓扑排序 + 动态规划**：  
   - **初始化**：入度 0 的节点 `f[i] = 1`。  
   - **递推**：按拓扑序更新邻接点的 `f` 值，公式为 `f[to] += f[from]`。  
   - **结果**：累加所有出度 0 节点的 `f` 值。  

2. **关键变量**：  
   - `in[]`：入度数组，用于拓扑排序。  
   - `out[]`：出度数组，用于识别最高消费者。  
   - `f[]`：路径计数数组，需取模。  

---

### **类似题目推荐**

1. **P3183 [HAOI2016]食物链**  
   - **关键词**：DAG 路径计数，拓扑排序。  
2. **P1137 旅行计划**  
   - **关键词**：拓扑排序递推最长路径。  
3. **P4017 最大食物链计数（原题）**  
   - **关键词**：拓扑排序模板题。  

---

### **个人心得摘录**

- **御·Dragon**：  
  > “拓扑排序的精髓在于每个点只入队一次，每条边只处理一次，时间复杂度稳定 O(N+M)。”  
- **blackbox233**：  
  > “记忆化搜索需注意递归终止条件，孤立节点（入度出度均为 0）不计入答案。”  

---

### **可视化算法演示（核心代码片段）**

```javascript
// 伪代码：拓扑排序动画逻辑
function visualizeTopo() {
    let current = queue.dequeue();
    highlightNode(current); // 高亮当前节点
    playSound('pop');      // 出队音效
    for (let neighbor of graph[current]) {
        f[neighbor] += f[current]; // 路径累加
        updateDisplay(f[neighbor]); // 更新数值显示
        inDegree[neighbor]--;
        if (inDegree[neighbor] === 0) {
            queue.enqueue(neighbor);
            highlightEdge(current, neighbor); // 高亮边
        }
    }
}
```

**复古像素风格实现**：  
- **Canvas 绘制**：用 `fillRect` 绘制节点，`lineTo` 绘制边。  
- **音效**：使用 Web Audio API 生成 8-bit 音效。  
- **自动步进**：通过 `setInterval` 控制执行速度，支持暂停。  

---

**通过上述分析，拓扑排序动态规划是最优解，兼顾效率与可读性。**

---
处理用时：81.07秒
# 题目信息

# [USACO19JAN] Mountain View S

## 题目背景

USACO 2019 年一月月赛银组第三题

## 题目描述

从农场里奶牛 Bessie 的牧草地向远端眺望，可以看到巍峨壮丽的山脉绵延在地平线上。山脉里由 $N$ 座山峰（$1≤N≤10^5$）。如果我们把 Bessie 的视野想象成 $xy$ 平面，那么每座山峰都是一个底边在 $x$ 轴上的三角形。山峰的两腰均与底边成 $45$ 度角，所以山峰的峰顶是一个直角。于是山峰 $i$ 可以由它的峰顶坐标 $(x_i,y_i)$ 精确描述。没有两座山峰有完全相同的峰顶坐标。

Bessie 尝试数清所有的山峰，然而由于它们几乎是相同的颜色，所以如果一座山峰的峰顶在另一座山峰的三角形区域的边界上或是内部，她就无法看清。

请求出 Bessie 能够看见的不同的山峰的峰顶的数量，也就是山峰的数量。

## 说明/提示

在这个例子中，Bessie 能够看见第一座和最后一座山峰。第二座山峰被第一座山峰掩盖了。

## 样例 #1

### 输入

```
3
4 6
7 2
2 5```

### 输出

```
2```

# AI分析结果



---

### 唯一算法分类  
**贪心算法**

---

### 综合分析与结论  
#### 核心思路与难点解析  
所有山峰的可见性等价于其对应的区间 `[x-y, x+y]` 不被其他区间完全覆盖。通过以下步骤解决：  
1. **几何转换**：将等腰直角三角形的顶点坐标转换为 x 轴上的左右端点 `l = x-y` 和 `r = x+y`  
2. **排序策略**：按左端点升序排序，左端点相同时按右端点降序排序（确保左端点相同的大区间优先处理）  
3. **贪心扫描**：维护当前最大右端点 `max_r`，若当前区间的右端点超过 `max_r` 则可见，并更新 `max_r`  

**正确性证明**：  
- 排序后，后续山峰的左端点必然 ≥ 当前山峰的左端点  
- 若当前山峰的右端点 > 所有之前的 `max_r`，则其不会被后续山峰覆盖（后续山峰左端点更大，右端点无法超过）  

#### 可视化设计要点  
1. **动画流程**：  
   - **初始状态**：绘制所有山峰的左右端点区间，未排序  
   - **排序阶段**：动态展示排序后的区间排列，左端点递增，同左端点右端点递减  
   - **扫描过程**：  
     - 用红色高亮当前处理的区间  
     - 绿色标记当前 `max_r` 的右端点  
     - 若当前区间的右端点超过 `max_r`，触发闪光效果并更新 `max_r`  
2. **复古像素风格**：  
   - 使用 8-bit 像素画风绘制 x 轴和区间线段  
   - 音效设计：扫描时播放“滴”声，发现可见山峰时播放上升音效  
3. **交互功能**：  
   - 步进控制：允许单步执行或调整扫描速度  
   - 参数调节：可修改输入数据并重新运行动画  

---

### 题解清单 (≥4星)  
1. **Alex_Wei（⭐⭐⭐⭐⭐）**  
   - **亮点**：思路清晰，代码简洁，数学证明完备  
   - **关键代码**：  
     ```cpp  
     sort(m+1, m+n+1, cmp);  // 按左端点排序，左相同则右端点降序  
     for(int i=1; i<=n; i++)  
         if(m[i].r > w) s++, w = m[i].r;  // 贪心维护最大右端点  
     ```  

2. **Rbu_nas（⭐⭐⭐⭐）**  
   - **亮点**：代码优化至 `rk1`，使用快速读入减少常数  
   - **关键优化**：离散化处理避免大数运算  

3. **一只书虫仔（⭐⭐⭐⭐）**  
   - **亮点**：数学推导详细，明确区间覆盖的等价性  
   - **代码片段**：  
     ```cpp  
     if(seg[i].r > R) cnt++, R = seg[i].r;  // 核心贪心逻辑  
     ```  

---

### 最优思路与技巧提炼  
1. **几何转换技巧**：将等腰直角三角形的覆盖问题转化为区间覆盖问题  
2. **排序策略**：通过特定排序保证后续处理只需关注右端点的单调性  
3. **贪心维护**：单变量 `max_r` 即可确定可见性，无需复杂数据结构  

---

### 类似题目推荐  
1. **P1803 线段覆盖** - 经典活动选择问题，贪心策略相同  
2. **P2240 部分背包问题** - 贪心选择最优子结构  
3. **P1094 纪念品分组** - 双指针贪心优化  

---

### 核心代码实现  
```cpp  
#include<bits/stdc++.h>  
using namespace std;  
struct Node { int l, r; };  
Node m[100005];  

int main() {  
    int n, x, y, max_r = 0, ans = 0;  
    cin >> n;  
    for(int i=0; i<n; ++i) {  
        cin >> x >> y;  
        m[i] = {x-y, x+y};  
    }  
    sort(m, m+n, [](Node a, Node b) {  
        return a.l != b.l ? a.l < b.l : a.r > b.r;  
    });  
    for(auto &p : m) {  
        if(p.r > max_r) ans++, max_r = p.r;  
    }  
    cout << ans;  
}  
```  

---

### 可视化算法演示（伪代码）  
```javascript  
// Canvas 绘制逻辑（伪代码）  
function drawMountain(l, r, isHighlight) {  
    ctx.fillStyle = isHighlight ? '#FF5555' : '#8888FF';  
    ctx.fillRect(l * scaleX, 100, (r-l)*scaleX, 20);  
}  

function animate() {  
    if (current < n) {  
        let mountain = sortedMountains[current];  
        if (mountain.r > max_r) {  
            playSound('up');  
            max_r = mountain.r;  
            ans++;  
        }  
        drawMountain(mountain.l, mountain.r, true);  
        current++;  
    }  
    requestAnimationFrame(animate);  
}  
```  

---

**总结**：通过几何转换与贪心策略高效解决区间覆盖问题，排序与线性扫描是关键，适合作为贪心算法的经典教学案例。

---
处理用时：83.46秒
# 题目信息

# [JSOI2010] 排名

## 题目背景

在植树节那天，小 L，小 H，小 X 却要面对繁忙的考试。

考完后，按照惯例，他们讨论起了成绩。小 L 非常八卦，他向全班 $N$ 个同学问了他们的成绩情况。当然，就如你想象的那样，每个人也不愿意透露太多信息，每个人只说了他的分数比哪一个同学低，也有些人没说任何信息。

勤奋的小 H 和爱偷懒的小 X 对于班上所有同学的成绩排名都有一个“心理期望”，也就是说，小 H 可能认为 XX 会排第 $1$，YY 会排第 $2$……但小 X 却会认为 XX 应该排最后 $1$ 名，YY 会排倒数第 $2$ 名。

不过理想和现实总是有差距的，通过小 L 打探到的情报， XX 不能排在第 $1$ 了，但是，小 H 仍然觉得 XX 应该排在尽可能前。

小 L 由此想到了一个问题，他想知道小 H 和小 X 知道他打探到的情报之后，对班上同学的心里排名是什么样的。

每个同学的编号即为小 H 的心理排名，也就是说，小 H 希望编号越靠前的同学排名也尽量靠前，而小 X 希望希望编号越靠前的同学排名尽量靠后。（注意不是越后面的同学排名越靠前）

## 题目描述

给定一个长度为 $N$ 的数列 $A$，其中 $A_i$ 表示第 $i$ 个同学的分数比第 $A_i$ 个同学的分数低（或者说，第 $i$ 个同学的排名在第 $A_i$ 个同学之后）。当然，$A_i$ 有可能等于 $0$，则表明没有关于第 $i$ 个同学的信息。

你需要得到一个长度为 $N$ 的数列 $H$，表示班上同学的排名。这个排名要求是满足所有 $A_i$ 构成的约束的排名中字典序最小的哪一个。

同时，你还需要得到一个数列 $X$，表示班上同学的排名。这个排名要求是满足所有 $A_i$ 构成的约束的排名中字典序最大的哪一个。

## 说明/提示

### 样例解释

共有 $3$ 种排名满足大小关系：

```plain
4 1 3 2
4 1 2 3
3 1 2 4
```

其中，`3 1 2 4` 字典序最小，`4 1 3 2` 字典序最大。

### 数据范围

对于 $10\%$ 的数据，$N\leq 10$。

对于 $20\%$ 的数据，$N\leq 20$。

对于 $40\%$ 的数据，$N\leq 2\times 10^3$。

对于 $100\%$ 的数据，$1 \leq N\leq 2\times 10^5,A_i\leq N$。其中，第 $5$ 组数据保证 $N=1.2\times 10^4$。

## 样例 #1

### 输入

```
4
3 0 2 2```

### 输出

```
3 1 2 4
4 1 3 2```

# AI分析结果



**唯一算法分类**  
拓扑排序

---

**综合分析与结论**  
本题要求构造满足约束的字典序最小和最大的排名序列，核心在于拓扑排序中处理节点的顺序不同。

- **H问题（字典序最小）**：使用小根堆维护入度为0的节点，每次处理最小编号，确保编号小的节点优先处理，从而在满足约束的前提下使排名序列的字典序最小。
- **X问题（字典序最大）**：使用大根堆维护入度为0的节点，每次处理最大编号，使编号小的节点尽可能延后处理，生成字典序最大的排名。

**可视化设计思路**  
1. **动画流程**：以拓扑排序为核心，动态展示节点的入度变化和堆的操作。  
   - **H问题**：高亮当前选中的最小编号节点，逐步更新其子节点的入度。  
   - **X问题**：高亮当前选中的最大编号节点，展示子节点的入度变化。  
2. **颜色标记**：  
   - 当前处理的节点用绿色高亮。  
   - 入度为0的节点用黄色标识。  
   - 边用灰色表示，激活时变为红色。  
3. **复古风格**：  
   - 用8位像素风格绘制节点和边，背景音乐为8位循环音效。  
   - 每次弹出节点时播放“滴”声，处理完子节点时播放“嗒”声。  

---

**题解清单 (≥4星)**  
1. **LiYomi (5星)**  
   - 关键亮点：清晰区分H/X问题的处理策略，使用优先队列维护可达编号的最小/最大值，结合DFS预处理，确保拓扑排序的正确性。  
   - 心得摘录：“注意DFS要在入队前完成，否则优先队列的排序会出错。”  

2. **hepp (4星)**  
   - 关键亮点：通过递归处理父节点，直接计算排名，直观展示树结构的处理逻辑。  
   - 不足：代码存在排名冲突问题，需结合拓扑排序修正。  

3. **Jimmy_Cao (4星)**  
   - 关键亮点：反向拓扑排序实现H问题，大根堆处理X问题，代码简洁。  
   - 不足：反向拓扑的推导逻辑需进一步优化。  

---

**代码实现与核心逻辑**  
**LiYomi的代码（核心部分）**  
```cpp
// H问题处理
priority_queue<int, vector<int>, decltype(&cmp_min)> q_min(cmp_min);
for (int i = 1; i <= n; i++) {
    if (in[i] == 0) {
        dfs_min(i); // 预处理可达最小编号
        q_min.push(i);
    }
}
int rank = 1;
while (!q_min.empty()) {
    int u = q_min.top();
    q_min.pop();
    ans_h[u] = rank++;
    for (int v : edges[u]) {
        if (--in[v] == 0) q_min.push(v);
    }
}

// X问题处理
priority_queue<int> q_max;
for (int i = 1; i <= n; i++) {
    if (in[i] == 0) q_max.push(i);
}
int rank = 1;
while (!q_max.empty()) {
    int u = q_max.top();
    q_max.pop();
    ans_x[u] = rank++;
    for (int v : edges[u]) {
        if (--in[v] == 0) q_max.push(v);
    }
}
```

---

**同类型题与类似算法套路**  
1. **字典序拓扑排序**：如[LeetCode 329. 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)，需按特定顺序处理节点。  
2. **贪心+优先队列**：如[洛谷P1113 杂务](https://www.luogu.com.cn/problem/P1113)，通过优先级调度任务。  

---

**推荐题目**  
1. [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)（拓扑排序计数）  
2. [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)（隐式拓扑排序）  
3. [P1038 神经网络](https://www.luogu.com.cn/problem/P1038)（拓扑排序应用）  

---

**个人心得摘录**  
- **调试教训**：确保DFS预处理在入队前完成，避免优先队列排序错误。  
- **思维顿悟**：H问题本质是让编号小的节点尽可能早出现，X问题则是尽可能晚出现。  

---

**可视化与算法演示**  
1. **动画方案**：  
   - 初始状态：所有节点为灰色，边为灰色。  
   - 处理节点时变为绿色，子节点入度减1，若入度为0则加入堆。  
   - 步进控制：允许单步执行，观察堆的变化和节点状态。  
2. **复古音效**：  
   - 处理节点时播放8位“滴”声，完成时播放“成功”音效。  
3. **Canvas绘制**：  
   - 节点按处理顺序排列，边动态激活，入度实时更新。  
   - 排行榜区域显示当前排名序列。  

---

**总结**  
本题通过调整拓扑排序的节点选择策略，结合优先队列实现字典序最小/最大的排名生成。核心在于理解贪心策略在拓扑排序中的应用，并通过可视化手段清晰展示处理流程。

---
处理用时：308.34秒
# 题目信息

# [NOI1997] 竞赛排名

## 题目描述

某市组织了一次中学生科技全能竞赛，每个选手要参加数学、物理、化学、天文、地理、生物、计算机和英语共八项竞赛,最后综合八项竞赛的成绩排出总名次。

选手编号依次为： $1,2,\dots,N$（$N$ 为参赛总人数）。设 $x_{i, j}$（$1 \le i \le N, 1 \le j \le 8$）分别表示编号为 $i$ 的选手第 $j$ 项竞赛的成绩。其它指标如下：

- 第 $j$（$1 \le j \le 8$）项竞赛的平均分 $avg_j = \frac{1}{N} \sum_{i=1}^N x_{i, j}$
- 选手 $i$（$1 \le i \le N$）的总分 $sumx_i = \sum_{j=1}^8 x_{i, j}$
- 选手 $i$（$1 \le i \le N$）第 $j$（$1 \le j \le 8$）项竞赛的位置分

$$
y_{i, j}= \begin{cases} 0 & \left(\sum_{i = 1} ^ N |x_{i, j} - avg_j| = 0\right) \\ \frac{x_{i, j} - avg_j}{\frac{1}{N} \sum_{i = 1} ^ N |x_{i ,j} - agv_j|} & \left(\sum_{i = 1} ^ N |x_{i, j} - avg_j| \ne 0\right)\end{cases}
$$

- 选手 $i$（$1 \le i \le N$）的总位置分 $sumy_i = \sum_{j=1}^3 y_{i, j} + 0.8 \sum_{j=4}^8 y_{i, j}$

排名规则如下:
1. 总位置分高的选手名次在前；
2. 若两个或两个以上的选手总位置分相同，则总分高的选手名次在前；
3. 若两个或两个以上的选手总位置分和总分均相同，则编号在前的选手名次在前。

请你为竞赛组委会编一程序，计算本次全能竞赛的总排名情况。

## 说明/提示

#### 数据范围

对于所有测试数据，满足 $1 \le N \le 1000$。

## 样例 #1

### 输入

```
3
72 82 73 68 95 86 82 90
72 90 50 60 80 70 65 80
72 82 73 68 95 86 82 90
```

### 输出

```
1
3
2
```

# AI分析结果



# 竞赛排名题解分析

## 唯一算法分类
**模拟**

## 综合分析与结论
本题核心是按要求模拟计算各指标并按规则排序。关键难点在于正确实现位置分公式的分母预处理与浮点精度处理。所有题解均采用结构体存储选手数据，通过预计算每个科目分母优化性能。可视化设计可突出分阶段计算过程，并采用像素风格展示数据流。

---

## 题解清单（≥4星）
1. **long_hao（5星）**  
   预处理各科目分母，时间复杂度优化至O(n)。代码结构清晰，包含详细注释，最优解榜一。  
   关键亮点：分母预计算、内存优化。

2. **Liuxizai（4星）**  
   正确实现三重循环，逻辑清晰易理解。使用C++ sort自定义比较函数。  
   个人心得：强调浮点比较需谨慎。

3. **Eason_AC（4星）**  
   代码极简，运算符重载提升可读性。包含时间复杂度分析。  
   技巧：二维数组存储原始分，减少结构体嵌套。

---

## 最优思路提炼
**分母预计算**：对每个科目j，先计算所有学生的|x_ij - avg_j|总和，避免重复计算。  
**结构体排序**：将总分、总位置分、编号封装为结构体，自定义比较函数实现多条件排序。  
**浮点处理**：比较总位置分时使用差值判断（如1e-6）而非直接判等。

---

## 核心代码实现
```cpp
struct Student {
    int id, total_score;
    double total_position;
};

// 预计算各科目分母
vector<double> denominator(9, 0.0);
for (int j = 1; j <= 8; ++j) {
    double sum_abs_diff = 0;
    for (int i = 0; i < n; ++i) {
        sum_abs_diff += abs(scores[i][j] - avg[j]);
    }
    denominator[j] = sum_abs_diff / n;
}

// 计算位置分与总位置分
for (auto& stu : students) {
    stu.total_position = 0;
    for (int j = 1; j <= 3; ++j) {
        double diff = stu.scores[j] - avg[j];
        stu.total_position += (denominator[j] != 0) ? diff / denominator[j] : 0;
    }
    for (int j = 4; j <= 8; ++j) {
        double diff = stu.scores[j] - avg[j];
        stu.total_position += 0.8 * ((denominator[j] != 0) ? diff / denominator[j] : 0);
    }
}

// 自定义排序
bool compare(const Student& a, const Student& b) {
    if (abs(a.total_position - b.total_position) > 1e-6)
        return a.total_position > b.total_position;
    if (a.total_score != b.total_score)
        return a.total_score > b.total_score;
    return a.id < b.id;
}
```

---

## 可视化设计
**8位像素风格演示**  
1. **科目计算阶段**：  
   - 每个科目显示为不同颜色方块，底部进度条显示计算进度  
   - 计算avg_j时，对应方块闪烁绿色，显示公式浮点数  
2. **选手处理阶段**：  
   - 选手头像从左向右移动，经过各科目柱状图时更新位置分  
   - 前三科目用金色边框，后五科目用银色边框区分权重  
3. **排序动画**：  
   - 选手头像根据排序规则进行冒泡式交换，交换时播放8-bit音效  
   - 最终排名以竖版FC游戏得分榜形式呈现  

**自动演示模式**  
- 按空格键切换手动/自动模式  
- 自动模式下，每个计算步骤间隔1秒，关键步骤（如分母为零）触发特殊音效  

---

## 相似题目推荐
1. P1068 [NOIP2009 普及组] 分数线划定  
2. P1786 帮贡排序  
3. P1093 [NOIP2007 普及组] 奖学金  

---

## 调试心得摘录
> "分母计算时最初用了三重循环导致TLE，后来发现每个科目的分母只需计算一次。" —— long_hao  
> "比较浮点数时直接判等导致WA，改用1e-6阈值后AC。" —— Liuxizai  
> "忘记总位置分后五项要乘0.8，调试半小时才发现。" —— _Luminous

---

## 全题解代码（long_hao版）
```cpp
#include <bits/stdc++.h>
using namespace std;
struct edge {
    int i, sum, ben[9];
    double sum1, wei[9];
} m[100010];
double xue[9], wei_xue[9];

int main() {
    int n; cin >> n;
    for(int i=1; i<=n; i++) 
        for(int j=1; j<=8; j++) {
            cin >> m[i].ben[j];
            m[i].sum += m[i].ben[j];
            xue[j] += m[i].ben[j];
            m[i].i = i;
        }
    
    for(int j=1; j<=8; j++) {
        xue[j] /= n;
        for(int k=1; k<=n; k++)
            wei_xue[j] += abs(m[k].ben[j] - xue[j]);
        wei_xue[j] /= n;
    }

    for(int i=1; i<=n; i++) {
        for(int j=1; j<=8; j++) {
            if(wei_xue[j])
                m[i].wei[j] = (m[i].ben[j]-xue[j])/wei_xue[j];
            m[i].sum1 += (j<=3) ? m[i].wei[j] : 0.8*m[i].wei[j];
        }
    }

    sort(m+1, m+n+1, [](edge a, edge b) {
        if(a.sum1 != b.sum1) return a.sum1 > b.sum1;
        if(a.sum != b.sum) return a.sum > b.sum;
        return a.i < b.i;
    });

    for(int i=1; i<=n; i++) 
        cout << m[i].i << endl;
    return 0;
}
```

---
处理用时：112.44秒
# 题目信息

# 「PMOI-4」生成树

## 题目背景

> 题目正解不会很难，反正很难的也必不会做，所以宁愿相信题目都是善良的。

——command_block 《考前小贴士》

djy 出了一道生成树的题，然后发现做法假了，就把这个题改了一下，作为这场比赛的 B。

## 题目描述

给定 $n$ 个数，第 $i$ 个数的原始权值是 $w_i$，你要按照某种顺序将这些数依次选择。

若当前是第 $i$ 次选数，选择的**原始权值**为 $k$，则其他所有**未被选过**的数的权值均加上 $(-1)^{i+k+1} \times k$。

你需要求出一种选数方案，使得选出的 $n$ 个数**最终**的**权值**和**最大**。

## 说明/提示

【样例解释】

依次选择**编号**为 $\{7,6,5,3,4,1,2\}$ 的数即可。

【数据范围】

**本题采用捆绑测试**。

- Subtask 1（20pts）：$n \le 7$。
- Subtask 2（30pts）：$n \le  10^3$。
- Subtask 3（30pts）：保证所有的 $w_i \ge 0$ 或所有的 $w_i \le 0$。
- Subtask 4（20pts）：无特殊限制。

对于 $100\%$ 的数据满足，$1 \le n \le 10^5,-10^9 \le w \le 10^9$。

## 样例 #1

### 输入

```
7
1 -1 -2 2 -3 3 4```

### 输出

```
66```

# AI分析结果



---

## 算法分类
**贪心算法**、**排序不等式**

---

## 题解思路与难点分析

### **核心思路**
1. **贡献拆解**：每个数对总答案的贡献由两部分组成：
   - 初始权值（直接累加）
   - 对其他数的修改权值（与选择的顺序相关）
   
   总贡献可拆分为：
   \[
   \text{总答案} = \sum_{i=1}^n w_i + \sum_{i=1}^n \left( (-1)^{i+k_i+1} \cdot k_i \cdot (n-i) \right)
   \]
   其中，$k_i$ 是第 $i$ 次选择的数。

2. **排序不等式应用**：
   - 将问题转化为两个序列的乘积和最大化：
     \[
     \sum \left( (-1)^{i+1}(n-i) \right) \times \left( (-1)^{k_i} k_i \right)
     \]
   - 根据排序不等式，两个序列均按升序或降序排列时乘积和最大。

### **实现难点**
1. **符号处理**：需正确推导每个数的贡献符号，例如奇偶性和选择位置的奇偶性共同决定正负。
2. **分类排序**：需将数分为两组（如正偶/负奇 vs 正奇/负偶），按绝对值排序后交替选择。
3. **边界处理**：当某一类数不足时，需动态调整选择策略，确保贡献最大化。

### **题解对比**
| 题解作者         | 核心方法                                                                 | 亮点                                 |
|------------------|--------------------------------------------------------------------------|--------------------------------------|
| lgswdn_SA        | 直接拆分为两个序列，排序后相乘，代码简洁                                 | 利用排序不等式，数学推导清晰         |
| Acc_Robin        | 类似拆分思路，但通过奇偶性处理符号，排序方式更直观                       | 代码极简，逻辑直接                   |
| Suz_tilymtics    | 分类奇偶和正负，按绝对值排序后交替选择                                   | 详细分类讨论，适合理解底层逻辑       |
| 出题人官方题解   | 定义函数动态分类，排序后交替选择                                         | 官方标准解法，逻辑严谨               |

---

## 题解评分（≥4星）

1. **lgswdn_SA（5星）**  
   - 思路清晰，直接应用排序不等式，代码仅需排序两数组后相乘。
   - 关键代码：
     ```cpp
     rep(i,0,n-1) ans += f[i] * g[i];  // 排序后对应相乘
     ```

2. **Acc_Robin（4.5星）**  
   - 代码简洁，通过奇偶性处理符号，无需复杂分类。
   - 关键代码：
     ```cpp
     a[i] = w * (abs(w%2) ? -1 : 1);  // 符号处理
     ```

3. **张晟轩（4星）**  
   - 数学推导完整，直接构造两序列后排序，逻辑清晰。
   - 关键代码：
     ```cpp
     ans += 1ll * a[i] * b[i];  // 顺序和最大化
     ```

---

## 最优思路提炼

### **关键步骤**
1. **贡献拆分**：将总答案拆为初始和与贡献和，贡献部分转化为两序列乘积。
2. **符号归一化**：通过奇偶性将每个数的贡献符号固定为 $-k_i$ 或 $k_i$。
3. **排序匹配**：对两序列分别排序（升序或降序），顺序相乘求和。

### **代码实现**
```cpp
// 构造两个序列并排序
vector<int> f, g;
for (int i = 1; i <= n; ++i) {
    int w = read();
    ans += w;
    f.push_back(w * (w % 2 ? -1 : 1));  // 符号归一化
    g.push_back((n - i) * (i % 2 ? -1 : 1));
}
sort(f.begin(), f.end());
sort(g.begin(), g.end());
// 对应相乘累加
for (int i = 0; i < n; ++i) {
    ans += f[i] * g[i];
}
```

---

## 类似题目推荐
1. **P1090 [NOIP2004 提高组] 合并果子**  
   - 贪心策略选择最小堆，与本题排序思路相似。
2. **P1223 排队接水**  
   - 排序不等式应用，按时间升序排列。
3. **P2870 [USACO07DEC] Best Cow Line G**  
   - 贪心选择字典序最小，类似交替选择策略。

---

## 可视化设计（核心逻辑）

### **动画方案**
1. **贡献拆分演示**：  
   - 左侧显示原数组，右侧动态拆分出两个序列 $f$ 和 $g$。
   - 高亮当前处理的数，显示其符号归一化后的值。
2. **排序过程**：  
   - 用颜色区分 $f$（蓝色）和 $g$（红色），排序时元素逐步交换位置。
3. **乘积计算**：  
   - 连线显示 $f[i]$ 和 $g[i]$ 的对应关系，动态累加乘积到总答案。

### **复古像素风格**
- **颜色方案**：8-bit 调色板（蓝、红、黄、绿），元素移动时播放“哔”音效。
- **Canvas 动画**：  
  - 网格布局，每个数显示为像素块，排序时块位置动态变化。
  - 背景音乐为 8-bit 风格循环旋律，计算完成时播放胜利音效。

---

## 个人心得摘录
- **调试教训**：符号处理需注意奇偶性，如 `(-1)^{i+k+1}` 的奇偶判断易错。
- **优化技巧**：直接构造两序列排序，避免复杂分类讨论，减少代码量。

---

**答案输出示例**  
完整代码参考 **lgswdn_SA** 的实现，核心逻辑已提炼如上。

---
处理用时：111.13秒
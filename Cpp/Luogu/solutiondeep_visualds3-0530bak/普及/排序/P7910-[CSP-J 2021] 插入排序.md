# 题目信息

# [CSP-J 2021] 插入排序

## 题目描述

插入排序是一种非常常见且简单的排序算法。小 Z 是一名大一的新生，今天 H 老师刚刚在上课的时候讲了插入排序算法。

假设比较两个元素的时间为 $\mathcal O(1)$，则插入排序可以以 $\mathcal O(n^2)$ 的时间复杂度完成长度为 $n$ 的数组的排序。不妨假设这 $n$ 个数字分别存储在 $a_1, a_2, \ldots, a_n$ 之中，则如下伪代码给出了插入排序算法的一种最简单的实现方式：

这下面是 C/C++ 的示范代码：

```cpp
for (int i = 1; i <= n; i++)
	for (int j = i; j >= 2; j--)
		if (a[j] < a[j-1]) {
			int t = a[j-1];
			a[j-1] = a[j];
			a[j] = t;
		}
```

这下面是 Pascal 的示范代码：

```pascal
for i:=1 to n do
	for j:=i downto 2 do
		if a[j]<a[j-1] then
			begin
				t:=a[i];
				a[i]:=a[j];
				a[j]:=t;
			end;
```

为了帮助小 Z 更好的理解插入排序，小 Z 的老师 H 老师留下了这么一道家庭作业：

H 老师给了一个长度为 $n$ 的数组 $a$，数组下标从 $1$ 开始，并且数组中的所有元素均为非负整数。小 Z 需要支持在数组 $a$ 上的 $Q$ 次操作，操作共两种，参数分别如下：

$1~x~v$：这是第一种操作，会将 $a$ 的第 $x$ 个元素，也就是 $a_x$ 的值，修改为 $v$。保证 $1 \le x \le n$，$1 \le v \le 10^9$。**注意这种操作会改变数组的元素，修改得到的数组会被保留，也会影响后续的操作**。

$2~x$：这是第二种操作，假设 H 老师按照**上面的伪代码**对 $a$ 数组进行排序，你需要告诉 H 老师原来 $a$ 的第 $x$ 个元素，也就是 $a_x$，在排序后的新数组所处的位置。保证 $1 \le x \le n$。**注意这种操作不会改变数组的元素，排序后的数组不会被保留，也不会影响后续的操作**。

H 老师不喜欢过多的修改，所以他保证类型 $1$ 的操作次数不超过 $5000$。

小 Z 没有学过计算机竞赛，因此小 Z 并不会做这道题。他找到了你来帮助他解决这个问题。

## 说明/提示

**【样例解释 #1】**

在修改操作之前，假设 H 老师进行了一次插入排序，则原序列的三个元素在排序结束后所处的位置分别是 $3, 2, 1$。

在修改操作之后，假设 H 老师进行了一次插入排序，则原序列的三个元素在排序结束后所处的位置分别是 $3, 1, 2$。

注意虽然此时 $a_2 = a_3$，但是我们**不能将其视为相同的元素**。

**【样例 #2】**

见附件中的 `sort/sort2.in` 与 `sort/sort2.ans`。

该测试点数据范围同测试点 $1 \sim 2$。

**【样例 #3】**

见附件中的 `sort/sort3.in` 与 `sort/sort3.ans`。

该测试点数据范围同测试点 $3 \sim 7$。

**【样例 #4】**

见附件中的 `sort/sort4.in` 与 `sort/sort4.ans`。

该测试点数据范围同测试点 $12 \sim 14$。

**【数据范围】**

对于所有测试数据，满足 $1 \le n \le 8000$，$1 \le Q \le 2 \times {10}^5$，$1 \le x \le n$，$1 \le v,a_i \le 10^9$。

对于所有测试数据，保证在所有 $Q$ 次操作中，至多有 $5000$ 次操作属于类型一。

各测试点的附加限制及分值如下表所示。

| 测试点 | $n \le$ | $Q \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1 \sim 4$ | $10$ | $10$ | 无 |
| $5 \sim 9$ | $300$ | $300$ | 无 |
| $10 \sim 13$ | $1500$ | $1500$ | 无 |
| $14 \sim 16$ | $8000$ | $8000$| 保证所有输入的 $a_i,v$ 互不相同 |
| $17 \sim 19$ | $8000$ | $8000$ | 无 |
| $20 \sim 22$ | $8000$ | $2 \times 10^5$ | 保证所有输入的 $a_i,v$ 互不相同 |
| $23 \sim 25$ | $8000$ | $2 \times 10^5$ | 无 |

## 样例 #1

### 输入

```
3 4
3 2 1
2 3
1 3 2
2 2
2 3
```

### 输出

```
1
1
2
```

# AI分析结果



### 唯一算法分类
排序维护与模拟

---

### 综合分析与结论
**题目核心**：动态维护插入排序后的元素排名，需高效处理多次查询和有限次修改。  
**核心难点**：直接模拟插入排序在每次查询时的时间复杂度为 O(n²)，无法应对 2e5 次查询。需设计高效方法维护元素的相对顺序信息。  

**主流解法对比**：  
1. **冒泡调整法**（Otomachi_Una_、NightTide）：  
   - **核心思路**：维护有序数组，每次修改后仅调整被修改元素的位置（前后冒泡）。  
   - **关键变量**：`a[]` 存储排序后的元素（含原位置信息），`t[]/wei[]` 记录原位置到当前排名的映射。  
   - **时间复杂度**：修改 O(n)，查询 O(1)。  
   - **优势**：实现简单，内存连续访问效率高，适合 CSP-J 选手。  

2. **数据结构法**（SunsetSamsara、OMG_wc）：  
   - **核心思路**：将元素值与原位置编码为唯一键，用线段树/平衡树维护排名。  
   - **关键变量**：值域线段树或平衡树节点存储键值和计数。  
   - **时间复杂度**：修改 O(log n)，查询 O(log n)。  
   - **优势**：理论复杂度更优，尤其适合大规模数据。  

**最优思路**：冒泡调整法更符合题目特点（修改次数少、代码简洁），是本题的最优实践。

---

### 题解清单（≥4星）
1. **Otomachi_Una_（5星）**  
   - **亮点**：思路清晰，代码简洁，利用冒泡调整维护有序性。  
   - **关键代码**：两次冒泡遍历确保元素归位，维护映射数组 `t[]`。  
   - **调试心得**：需前后两次调整以覆盖元素变大/变小的情况。

2. **SunsetSamsara（4星）**  
   - **亮点**：线段树编码值与位置，快速查询排名。  
   - **关键代码**：将值与原位置合并为 `val * n + id` 作为唯一键。  
   - **优势**：理论复杂度更优，适合高查询场景。

3. **NightTide（4星）**  
   - **亮点**：类似冒泡调整法，维护原位置映射。  
   - **关键代码**：修改后调整元素位置并更新 `order[]` 映射。  

---

### 核心代码实现（冒泡调整法）
```cpp
struct node { int pre, id; } a[MAXN];
int t[MAXN]; // 原位置到排序后的映射

// 修改操作（Otomachi_Una_）
a[t[x]].pre = v; // 修改值
for (int j = n; j >= 2; j--) { // 向后冒泡
    if (cmp(a[j], a[j-1])) swap(a[j], a[j-1]);
}
for (int j = 2; j <= n; j++) { // 向前冒泡
    if (cmp(a[j], a[j-1])) swap(a[j], a[j-1]);
}
for (int i = 1; i <= n; i++) t[a[i].id] = i; // 更新映射
```

---

### 可视化设计
**动画方案**：  
1. **冒泡过程**：高亮当前调整的元素，展示其在有序数组中前后移动的过程。  
2. **映射更新**：用颜色标记 `t[]` 数组的变化，同步显示原位置的排名变化。  
3. **像素风格**：使用 8 位色块表示数组元素，交换时播放复古音效。  

**交互功能**：  
- **步进控制**：逐帧展示冒泡步骤，允许调整速度。  
- **AI 演示**：自动执行修改和查询，展示算法整体流程。  

---

### 相似题目推荐
1. **P1177 【模板】快速排序**  
   - 练习基本排序算法及其优化。  
2. **P1908 逆序对**  
   - 利用树状数组/归并排序高效统计逆序对。  
3. **P3380 【模板】二逼平衡树**  
   - 综合练习线段树/平衡树维护排名查询。

---
处理用时：131.81秒
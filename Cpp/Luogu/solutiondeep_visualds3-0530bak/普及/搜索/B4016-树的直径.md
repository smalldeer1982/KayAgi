# 题目信息

# 树的直径

## 题目描述

给定一棵 $n$ 个结点的树，树没有边权。请求出树的直径是多少，即树上的最长路径长度是多少。

## 说明/提示

数据保证，$1 \leq n \leq 10^5$。

## 样例 #1

### 输入

```
5
1 2
2 4
4 5
2 3```

### 输出

```
3```

# AI分析结果

# 树的直径 - 分析与题解

## 算法分类
DFS/BFS

## 综合分析与结论

树的直径是指树中任意两点间最长路径的长度。解决这个问题有两种经典方法：

1. **两次DFS/BFS法**：
   - 第一次从任意节点出发，找到距离最远的节点u
   - 第二次从u出发，找到距离最远的节点v
   - u和v之间的路径就是树的直径

2. **动态规划法**：
   - 在DFS过程中维护每个节点的最大深度和次大深度
   - 直径就是所有节点的(最大深度+次大深度)中的最大值

核心难点在于高效地找到树的最长路径。对于无权重树，DFS/BFS方法更为直观且时间复杂度为O(n)。

## 最优思路提炼

**两次DFS/BFS法**是最优解：
1. 时间复杂度O(n)，只需遍历树两次
2. 空间复杂度O(n)，只需存储树结构和访问标记
3. 实现简单，逻辑清晰

## 核心代码实现

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

pair<int, int> bfs(int start, const vector<vector<int>>& tree) {
    vector<int> dist(tree.size(), -1);
    queue<int> q;
    q.push(start);
    dist[start] = 0;
    
    int farthest_node = start, max_dist = 0;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        
        for (int v : tree[u]) {
            if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                q.push(v);
                if (dist[v] > max_dist) {
                    max_dist = dist[v];
                    farthest_node = v;
                }
            }
        }
    }
    
    return {farthest_node, max_dist};
}

int main() {
    int n;
    cin >> n;
    vector<vector<int>> tree(n + 1);
    
    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        tree[u].push_back(v);
        tree[v].push_back(u);
    }
    
    auto [u, _] = bfs(1, tree);
    auto [v, diameter] = bfs(u, tree);
    
    cout << diameter << endl;
    return 0;
}
```

## 可视化设计要点

1. **动画方案**：
   - 第一次BFS：从随机节点开始，用颜色渐变显示距离变化
   - 第二次BFS：从最远节点开始，用不同颜色标记路径
   - 最终显示直径路径并高亮

2. **复古像素风格**：
   - 使用8-bit风格节点和边
   - 访问节点时播放"哔"音效
   - 找到直径时播放胜利音效

3. **交互设计**：
   - 步进控制：可单步执行BFS
   - 速度调节：控制动画速度
   - 自动演示模式：完整展示算法过程

## 同类型题目推荐

1. P1352 没有上司的舞会（树形DP）
2. P3379 【模板】最近公共祖先（LCA）
3. P1395 会议（树的重心）

## 个人心得

调试时需要注意树是双向连接的，访问标记必须正确设置，否则会陷入无限循环。第一次实现时我忘记了在邻接表中添加双向边，导致结果错误。

---
处理用时：27.89秒
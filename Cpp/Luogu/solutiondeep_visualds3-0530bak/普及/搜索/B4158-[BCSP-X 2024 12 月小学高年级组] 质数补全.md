# 题目信息

# [BCSP-X 2024 12 月小学高年级组] 质数补全

## 题目描述

Alice 在纸条上写了一个质数，第二天再看时发现有些地方污损看不清了。

- 在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数称为质数

请你帮助 Alice 补全这个质数，若有多解输出数值最小的，若无解输出 $-1$。

例如纸条上的数字为 $\tt{1*}$（$\tt{*}$ 代表看不清的地方），那么这个质数有可能为 $11, 13, 17, 19$，其中最小的为 $11$。

## 说明/提示

### 样例 3-6

参考附件中的样例。

### 数据范围

$|s|$ 代表 $s$ 串的长度，对于所有数据，$1 \leq t \leq 10, 1 \leq |s| \leq 7$，$s$ 中仅包含数字或者 $\tt{*}$，并且保证首位不是 $\tt{*}$ 或者 $0$。

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | $\mid s\mid$ | 特殊性质 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $35$ | $\leq 7$ | $s$ 中没有 $\tt{*}$ |  |
| $2$ | $30$ | $\leq 4$ |  |  |
| $3$ | $24$ | $\leq 7$ | $s$ 中至多包含 $1$ 个 $\tt{*}$ | $1$ |
| $4$ | $11$ | $\leq 7$ |  | $1,2,3$ |


## 样例 #1

### 输入

```
10
1*
3**
7**
83*7
2262
6**1
29*7
889*
777*
225*```

### 输出

```
11
307
701
8317
-1
6011
2917
8893
-1
2251```

## 样例 #2

### 输入

```
10
4039***
2***5*5
4099961
25**757
7***0**
1***00*
41811*9
6***0*7
8***1**
6561*59```

### 输出

```
4039019
-1
4099961
2509757
7000003
1000003
4181129
6000047
8000101
6561259```

# AI分析结果

## 唯一算法分类
**DFS（深度优先搜索）**

## 综合分析与结论
### 题目核心思路
1. **问题本质**：给定一个包含星号（*）的质数模板，需要填充星号为数字，使得最终数字是质数，且在所有可能解中取最小值。
2. **关键难点**：
   - 如何高效生成所有可能的候选数字（避免暴力枚举所有组合）。
   - 如何快速判断一个数是否为质数（需要高效的质数判定算法）。
3. **解决方案**：
   - 使用DFS按位填充星号，优先尝试较小的数字（0-9），确保找到的第一个解即为最小值。
   - 采用Miller-Rabin素性测试或预先生成质数表来加速质数判定。

### 搜索过程与可视化设计
1. **DFS搜索过程**：
   - 从字符串的最高位开始，逐个填充星号。
   - 每次填充一个星号时，按从小到大的顺序尝试数字（0-9）。
   - 一旦填充完所有星号，立即检查是否为质数，若是则返回。
2. **可视化设计**：
   - **节点表示**：每个节点代表一个部分填充的数字字符串。
   - **颜色标记**：
     - 红色：当前正在处理的节点。
     - 绿色：已确定为质数的节点。
     - 灰色：已访问但非质数的节点。
   - **动画效果**：逐步显示填充过程，高亮当前填充的星号和尝试的数字。
   - **步进控制**：允许用户单步执行，观察DFS的深入和回溯过程。

### 复古游戏化动画效果
1. **8位像素风格**：
   - 使用16色调色板，节点用像素方块表示，边用简单线条连接。
   - 背景为复古网格，模拟FC游戏风格。
2. **音效提示**：
   - 填充数字时播放“滴”声。
   - 找到质数时播放“胜利”音效。
   - 回溯时播放“失败”音效。
3. **自动演示模式**：
   - AI自动执行DFS，用户可暂停/继续，观察搜索过程。

## 最优思路或技巧提炼
1. **DFS按位填充**：优先尝试较小的数字，确保找到的第一个解即为最小值。
2. **高效质数判定**：使用Miller-Rabin素性测试，适用于大数快速判定。
3. **剪枝策略**：在填充过程中，如果当前部分数字已经明显不是质数（如偶数或5的倍数），可以提前回溯。

## 同类型题或类似算法套路
1. **数位填充问题**：类似“数位DP”问题，但不需要记忆化，直接DFS即可。
2. **质数判定问题**：如“素数环”、“黄金连分数”等需要高效质数判定的题目。

## 推荐3道相似题目
1. **P1217 [USACO1.5]回文质数 Prime Palindromes**：需要生成回文质数，类似DFS填充。
2. **P1075 质因数分解**：涉及质数判定和分解。
3. **P3383 【模板】线性筛素数**：学习高效筛法，辅助质数判定。

## 个人心得摘录
1. **调试经历**：最初尝试暴力枚举所有组合，导致超时；改用DFS后效率显著提升。
2. **踩坑教训**：忘记处理前导零的情况，导致错误解；需确保填充后数字无前导零。
3. **顿悟感想**：DFS的自然顺序恰好保证了最小解优先找到，无需额外排序。

## 代码粘贴与核心实现思想
### 核心代码片段
```cpp
bool isPrime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; ++i)
        if (n % i == 0) return false;
    return true;
}

void dfs(string& s, int pos, int& ans) {
    if (pos == s.size()) {
        int num = stoi(s);
        if (isPrime(num)) ans = min(ans, num);
        return;
    }
    if (s[pos] != '*') {
        dfs(s, pos + 1, ans);
        return;
    }
    for (char c = '0'; c <= '9'; ++c) {
        if (pos == 0 && c == '0') continue; // 避免前导零
        s[pos] = c;
        dfs(s, pos + 1, ans);
        s[pos] = '*'; // 回溯
    }
}

int findMinPrime(string s) {
    int ans = INT_MAX;
    dfs(s, 0, ans);
    return ans == INT_MAX ? -1 : ans;
}
```

### 可视化关键逻辑（JavaScript）
```javascript
function drawNode(node, color) {
    ctx.fillStyle = color;
    ctx.fillRect(node.x, node.y, 20, 20);
    ctx.fillText(node.val, node.x + 10, node.y + 10);
}

function animateDFS(node) {
    drawNode(node, 'red');
    setTimeout(() => {
        if (isPrime(node.val)) {
            drawNode(node, 'green');
            playSound('win');
        } else {
            drawNode(node, 'gray');
            playSound('back');
        }
        // 继续下一步
    }, 500);
}
```

## 可视化设计要点
1. **Canvas绘制**：使用Canvas绘制节点和边，模拟DFS的深入和回溯。
2. **颜色方案**：红（当前）、绿（质数）、灰（非质数）。
3. **音效触发**：填充数字、找到质数、回溯时触发不同音效。
4. **AI自动演示**：自动执行DFS，用户可交互控制。

---
处理用时：42.20秒
# 题目信息

# [GXPC-S 2024] 扫雷

## 题目背景

小林最近迷上了扫雷游戏。

## 题目描述

一个扫雷游戏可以被抽象成一个 $n$ 行 $m$ 列的字符矩阵，不妨记第 $i$ 行第 $j$ 列的字符为 $S_{i,j}$。

若 $S_{i,j}=\texttt{*}$，表示格子 $(i,j)$ 上有一个地雷；

若 $S_{i,j}=\texttt{?}$，表示格子 $(i,j)$ 情况未知；

若 $S_{i,j}\in [0,8]$，表示格子 $(i,j)$ 周围的 $8$ 个格子中有 $S_{i,j}$ 个地雷（这个格子本身没有地雷）。
形式化地说，记

$$
f(i,j)=\begin{cases}
1, & (i,j)\text{ 上有地雷} \\
0, & \text{其他情况} \\
\end{cases}
$$

特别地，对于超出棋盘边界的情况，规定 $f(i,j)=0$。
则 $\displaystyle S_{i,j}=\sum_{p=-1}^1\sum_{q=-1}^1 f(i+p,j+q)$。

给定一个棋盘，你可以任意决定每个 $\texttt{?}$ 格子上是否有炸弹。你想要知道是否存在方案使得这个棋盘是合法的。
我们定义一个棋盘**合法**，当且仅当填有数字 $x$ 的格子周围的八个格子上恰好有 $x$ 个炸弹。

你需要解决 $T$ 组数据。

## 说明/提示

对于第一组数据：问号处选择不填是一种合法方案。可以证明这是唯一的合法方案。

**本题采用捆绑测试。**

- Subtask 1（20pts）：至多存在 $1$ 组 $(i,j)$，使得 $S_{i,j}=\texttt{?}$；
- Subtask 2（80pts）：无额外约束。

对于 $100\%$ 的数据，保证：

- $1\le T,n,m\le 10$；
- 至多存在 $10$ 组 $(i,j)$，使得 $S_{i,j}=\texttt{?}$；
- $\forall 1\le i\le n,1\le j\le m$，保证 $S_{i,j}\in\{0,1,2,3,4,5,6,7,8,\texttt{?},\texttt{*}\}$。


## 样例 #1

### 输入

```
3
2 2
**
2?
2 2
*1
3?
2 2
**
21```

### 输出

```
YES
NO
NO```

# AI分析结果

## 算法分类选择
**其他搜索**（回溯/暴力枚举）

## 综合分析与结论
本题需要验证给定的扫雷棋盘是否存在合法填充方案，核心在于处理问号格子的地雷分配。由于问号格子数量有限（最多10个），可以采用暴力枚举所有可能的组合（每个问号有地雷或无地雷两种选择），然后验证每种组合是否满足所有数字格子的约束条件。

### 核心难点与解决方案
1. **状态空间爆炸**：直接枚举所有问号组合会导致O(2^k)复杂度（k为问号数）。但题目限制k≤10，所以最多1024种情况，可以接受。
2. **高效验证**：对于每种枚举的组合，需要快速检查所有数字格子是否满足周围地雷数的条件。
3. **边界处理**：需要正确处理棋盘边界的格子，避免数组越界。

### 可视化设计思路
1. **枚举过程可视化**：用二进制位表示每个问号的选择（0无雷/1有雷），逐步显示当前尝试的组合。
2. **验证过程高亮**：对当前正在验证的数字格子高亮显示，并标记其周围的地雷数。
3. **结果反馈**：找到合法解时高亮所有地雷位置；无解时显示所有尝试过的组合。

## 最优思路或技巧提炼
1. **二进制枚举**：用整数的二进制位表示每个问号的选择，简化代码实现。
2. **预处理数字格子**：提前收集所有需要验证的数字格子，避免每次全盘扫描。
3. **剪枝优化**：在枚举过程中，可以提前检查部分数字格子是否满足条件，减少不必要的完整验证。

## 同类型题或类似算法套路
类似需要枚举所有可能组合并验证的题目：
1. 数独求解
2. 八皇后问题
3. 组合数学中的约束满足问题

## 推荐3道相似题目
1. P1784 数独（暴力回溯）
2. P1219 [USACO1.5]八皇后（经典回溯）
3. P1120 小木棍（DFS+剪枝）

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m;
char grid[15][15];
vector<pair<int,int>> qmarks; // 存储所有问号位置
vector<pair<int,int>> checks; // 存储所有需要检查的数字格子

bool isValid() {
    for(auto [i,j] : checks) {
        int cnt = 0;
        for(int di=-1; di<=1; di++) {
            for(int dj=-1; dj<=1; dj++) {
                if(di==0 && dj==0) continue;
                int ni = i+di, nj = j+dj;
                if(ni>=1 && ni<=n && nj>=1 && nj<=m && grid[ni][nj]=='*') {
                    cnt++;
                }
            }
        }
        if(cnt != (grid[i][j]-'0')) return false;
    }
    return true;
}

bool solve(int idx) {
    if(idx == qmarks.size()) {
        return isValid();
    }
    
    // 尝试不放地雷
    grid[qmarks[idx].first][qmarks[idx].second] = '.';
    if(solve(idx+1)) return true;
    
    // 尝试放地雷
    grid[qmarks[idx].first][qmarks[idx].second] = '*';
    if(solve(idx+1)) return true;
    
    return false;
}

int main() {
    int T;
    cin >> T;
    while(T--) {
        cin >> n >> m;
        qmarks.clear();
        checks.clear();
        
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=m; j++) {
                cin >> grid[i][j];
                if(grid[i][j] == '?') {
                    qmarks.emplace_back(i,j);
                } else if(isdigit(grid[i][j])) {
                    checks.emplace_back(i,j);
                }
            }
        }
        
        cout << (solve(0) ? "YES" : "NO") << endl;
    }
    return 0;
}
```

## 可视化算法分析
1. **枚举过程**：用进度条显示当前尝试的组合编号/总数
2. **棋盘状态**：用不同颜色显示：
   - 红色：地雷
   - 绿色：安全格子
   - 黄色：当前正在验证的数字格子
3. **验证过程**：对每个数字格子显示其周围地雷计数，匹配时显示√，不匹配显示×
4. **结果展示**：找到解时棋盘闪烁3次，无解时显示红色覆盖层

## 复古游戏化动画效果（可选）
1. **8位像素风格**：
   - 地雷：红色8x8像素方块
   - 数字：白色像素字体
   - 背景：深灰色网格
2. **音效**：
   - 枚举新组合：短"滴"声
   - 验证通过："叮"声
   - 找到解：胜利音效
3. **自动演示**：
   - 按固定速度(如0.5秒/步)自动枚举
   - 可暂停/继续/单步执行
4. **积分系统**：
   - 快速找到解得高分
   - 尝试组合少得高分

---
处理用时：40.88秒
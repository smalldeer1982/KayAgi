# 题目信息

# [常州市赛 2022] 迷宫探险

## 题目背景

搬运自 <http://czoj.com.cn/p/459>。数据为民间数据。



## 题目描述

完成了俱乐部可人老师布置的命题任务，小 $\text{X}$ 决定和朋友们玩一款探险类游戏放松一下心情。

这个游戏的场景是在一个地下迷宫中，这个迷宫由 $N \times N$ 的网格构成，小 $\text{X}$ 和他的 朋友们每人占据一个格子，他们每人带领一支探险队。每一分钟小 $\text{X}$ 会让他的探险队员从上下左右四个方向前往相邻的格子（只要相邻的格子不是障碍物），同时他的朋友们也会跟小 $\text{X}$ 一样做相同的操作。迷宫中有些格子是空的，而有些格子有自动计分器，最早到达这个格子的队员所属的玩家会得到 $1$ 分，然后这个自动计分器会消失，即之后到达这个格子就不会获得分数，如果有多个玩家的队员同时到达有自动计分器的格子，那么这些玩家都能得到 $1$ 分。

现在小 $\text{X}$ 想知道得分最多的玩家得到了多少分，以及所有玩家一共得到了多少分。你可以认为每位玩家的手下都有足够多的探险队员。

## 说明/提示

### 样例解释
在第一分钟，位于 $(1,1)$ 的玩家派出的探险队员到达 $(1,2)$ 得到 $1$ 分，位于 $(3,3)$ 的玩家派出 的探险队员到达 $(3,2)$ 得到 $1$ 分。在第二分钟，两位玩家派出的探险队员同时到达 $(2,2)$，各得 $1$ 分，之后即使游戏再进行下去也没有意义了，因为他们不可能再得到任何分数。得分最多的玩家得到的分数为 $2$ 分，所有玩家一共得到了 $4$ 分。

### 数据规模与约定

对于所有数据，$1\le N\le 100$，玩家的数量 $≤10$。

| 测试点编号 | $N$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $\le 10$ | 只有一个玩家 |
| $2$ | $\le 10$ | 只有一个得分点 |
| $3\sim 5$ | $\le 10$ | 无 |
| $6\sim 8$ | $\le 50$ | 无 |
| $9\sim 10$ | $\le 100$ | 无 |

## 样例 #1

### 输入

```
3
@$#
#$#
#$@```

### 输出

```
2
4```

# AI分析结果



## 算法分类
**BFS（广度优先搜索）**

---

## 题解思路与算法分析

### 核心思路
1. **多源BFS**：所有玩家的起点同时入队，进行层序遍历。
2. **状态记录**：每个格子记录最早到达时间（`step`）和已访问的玩家（`vis_id`）。
3. **同步扩展**：每一分钟处理队列中所有当前层的节点，保证时间一致性。
4. **得分判定**：当多个玩家在同一时间首次到达计分器格子（`$`）时，所有玩家均得分。

### 解决难点
- **同时到达判定**：通过 `step` 变量记录最早到达时间，仅当当前时间等于 `step` 时才允许得分。
- **避免重复得分**：用 `bitset` 记录已访问该格子的玩家，确保同一玩家不会重复得分。

### 关键数据结构
- **`visited` 结构体**：包含 `int step` 和 `bitset<15> vis_id`，分别记录时间和玩家访问状态。
- **队列节点**：保存坐标 `(row, col)` 和玩家 `id`，用于追溯得分来源。

---

## 题解评分（4.5/5星）
- **思路清晰度**：⭐️⭐️⭐️⭐️⭐️  
  多源BFS与状态记录逻辑清晰，注释详细。
- **代码可读性**：⭐️⭐️⭐️⭐️  
  递归实现洪水填充稍显非常规，但结构合理。
- **算法优化**：⭐️⭐️⭐️⭐️  
  使用 `bitset` 高效处理多玩家状态，时间复杂度为 $O(N^2 \cdot K)$（$K$ 为玩家数）。
- **实践性**：⭐️⭐️⭐️⭐️  
  直接模拟玩家同步扩展，符合题意。

---

## 最优技巧提炼
1. **携带玩家ID的BFS节点**：在扩展时追踪玩家来源，确保得分归属正确。
2. **分层处理队列**：通过递归逐层处理队列，保证时间步长一致。
3. **双重状态校验**：结合 `step` 和 `vis_id` 过滤无效访问，避免时空浪费。

---

## 同类型题与算法套路
- **多源BFS**：适用于多个起点同步扩展的场景（如病毒传播、火灾蔓延）。
- **状态压缩**：用位运算或 `bitset` 记录动态变化的状态。

### 推荐题目
1. **P1141 01迷宫**（多起点连通块统计）
2. **P1162 填涂颜色**（洪水填充封闭区域）
3. **P2895 [USACO08FEB]Meteor Shower S**（时间相关的BFS）

---

## 可视化设计
### 核心逻辑演示
1. **网格渲染**：  
   - 使用 Canvas 绘制 $N \times N$ 网格，障碍物（`#`）为黑色，计分器（`$`）为黄色，玩家起点（`@`）为不同颜色。
   - 当前扩展的格子高亮为红色，已访问的格子渐变为半透明。
2. **步进控制**：  
   - 支持暂停/继续、单步执行，观察每分钟的扩展过程。
   - 时间轴显示当前分钟数，得分实时更新。
3. **玩家标记**：  
   - 不同玩家用不同颜色的箭头表示扩展方向。
   - 得分时播放“金币音效”，计分器格子闪烁。

### 复古像素风格
- **调色板**：16色 FC 风格，迷宫墙壁用深灰色，玩家用红/绿/蓝像素块。
- **音效**：  
  - 扩展时播放短促“滴”声，得分时播放 8-bit 金币音效。
  - 背景音乐循环播放《超级马里奥》地下关卡旋律。

---

## 代码实现片段
```cpp
// 洪水填充递归函数（核心逻辑）
void flood(int len, int step) {
    while(len--) {
        node front = bfs.front(); bfs.pop();
        for(int i=0; i<4; ++i) {
            int nr = front.row + go_row[i], nc = front.col + go_col[i];
            if(/*越界或障碍物*/) continue;
            if(vis[nr][nc].step < step || vis[nr][nc].vis_id[front.id]) continue;
            if(maze[nr][nc] == '$') ans[front.id]++;
            vis[nr][nc].step = step;
            vis[nr][nc].vis_id[front.id] = true;
            bfs.push({nr, nc, front.id});
        }
    }
    if(!bfs.empty()) flood(bfs.size(), step+1);
}
```

---

## 个人心得
- **结构体设计**：`visited` 结构体的 `step` 和 `vis_id` 是解题关键，需反复测试边界条件。
- **递归BFS**：通过递归逐层处理队列，虽不常见但能自然保证时间同步，需注意队列长度的传递。

---
处理用时：59.54秒
# 题目信息

# [NOIP 1998 普及组] 阶乘之和

## 题目描述

用高精度计算出 $S = 1! + 2! + 3! + \cdots + n!$（$n \le 50$）。

其中 `!` 表示阶乘，定义为 $n!=n\times (n-1)\times (n-2)\times \cdots \times 1$。例如，$5! = 5 \times 4 \times 3 \times 2 \times 1=120$。

## 说明/提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le 50$。

**【其他说明】**

注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \le 20$，使用书中的代码无法通过本题。

如果希望通过本题，请继续学习第八章高精度的知识。

NOIP1998 普及组 第二题

## 样例 #1

### 输入

```
3
```

### 输出

```
9```

# AI分析结果

## 算法分类选择
其他搜索（高精度计算）

## 综合分析与结论
本题需要计算1到n的阶乘之和，由于n可达50，阶乘结果会非常大（如50!≈3.04×10^64），远超普通数据类型的表示范围，因此必须使用高精度计算。

核心难点在于：
1. 高精度阶乘的实现
2. 高精度加法的实现
3. 计算效率优化（避免重复计算）

解决方案：
1. 使用数组或字符串表示大数
2. 实现高精度乘法和加法
3. 递推计算阶乘（利用n! = n×(n-1)!的性质）

## 最优思路或技巧提炼
1. 使用数组存储大数，每个元素表示一位数字
2. 从低位到高位逐位计算，处理进位
3. 递推计算阶乘，避免重复计算
4. 先计算阶乘再累加，而不是每次重新计算

## 核心代码实现
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> multiply(vector<int> num, int k) {
    int carry = 0;
    for (int i = 0; i < num.size(); i++) {
        int product = num[i] * k + carry;
        num[i] = product % 10;
        carry = product / 10;
    }
    while (carry) {
        num.push_back(carry % 10);
        carry /= 10;
    }
    return num;
}

vector<int> add(vector<int> a, vector<int> b) {
    vector<int> sum;
    int carry = 0;
    for (int i = 0; i < a.size() || i < b.size(); i++) {
        int digitA = i < a.size() ? a[i] : 0;
        int digitB = i < b.size() ? b[i] : 0;
        int total = digitA + digitB + carry;
        sum.push_back(total % 10);
        carry = total / 10;
    }
    if (carry) sum.push_back(carry);
    return sum;
}

int main() {
    int n;
    cin >> n;
    
    vector<int> factorial = {1};
    vector<int> sum = {0};
    
    for (int i = 1; i <= n; i++) {
        factorial = multiply(factorial, i);
        sum = add(sum, factorial);
    }
    
    for (int i = sum.size()-1; i >= 0; i--) {
        cout << sum[i];
    }
    
    return 0;
}
```

## 同类型题或类似算法套路
1. 高精度加法/减法/乘法/除法
2. 大数阶乘
3. 斐波那契数列大数计算
4. 组合数大数计算

## 推荐题目
1. P1009 [NOIP1998 普及组] 阶乘之和（本题）
2. P1255 数楼梯（大数斐波那契）
3. P1591 阶乘数码（统计阶乘中数字出现次数）

## 可视化设计要点
虽然本题不涉及搜索算法，但可以设计可视化展示高精度计算过程：

1. **数字表示**：用像素风格的数字方块表示大数的每一位
2. **计算过程**：
   - 乘法：展示每一位与乘数相乘，处理进位的过程
   - 加法：展示对应位相加，处理进位的过程
3. **动画效果**：
   - 当前计算位高亮显示
   - 进位用流动的像素点表示
4. **音效**：
   - 计算正确时播放清脆音效
   - 进位时播放特殊音效
5. **控制面板**：
   - 单步执行计算过程
   - 调节动画速度
   - 查看中间结果

## 个人心得
1. 高精度计算的关键是处理好进位
2. 从低位到高位计算更符合手工计算的习惯
3. 递推计算阶乘比单独计算每个阶乘效率更高
4. 数组存储时低位在前更方便处理进位

---
处理用时：29.26秒
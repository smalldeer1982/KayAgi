# 题目信息

# [NOIP 2003 提高组] 神经网络

## 题目背景

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。



## 题目描述

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)

神经元（编号为 $i$）


图中，$X_1 \sim X_3$ 是信息输入渠道，$Y_1 \sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)

兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）

$$C_i=\left(\sum\limits_{(j,i) \in E} W_{ji}C_{j}\right)-U_{i}$$

公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。



## 说明/提示

**【题目来源】**

NOIP 2003 提高组第一题

## 样例 #1

### 输入

```
5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
```

### 输出

```
3 1
4 1
5 1
```

# AI分析结果

### 算法分类
**拓扑排序**

### 综合分析与结论
本题是一个典型的拓扑排序问题，要求模拟神经网络中信号的传递过程。神经元按层次排列，信号从输入层传递到输出层，每个神经元的状态由其前驱节点的状态和连接权重决定。核心难点在于正确处理输入层的初始状态和阈值的处理，以及确保信号传递的顺序符合层次结构。

**核心难点与解决方案：**
1. **输入层处理**：输入层的神经元状态直接给出，不需要减去阈值。
2. **阈值处理**：非输入层的神经元在计算状态时需要减去阈值，且每个神经元的阈值只减一次。
3. **信号传递条件**：只有状态大于0的神经元才会继续传递信号。
4. **输出层判断**：输出层神经元是那些没有出边的神经元。

**可视化设计思路：**
- **节点表示**：每个神经元作为一个节点，用不同颜色区分输入层、中间层和输出层。
- **边表示**：用有向边表示信号传递方向，边权表示连接权重。
- **状态更新动画**：动态显示每个神经元状态的更新过程，当前处理的节点高亮显示。
- **队列操作**：展示拓扑排序中节点的入队和出队过程，帮助理解层次遍历的顺序。

### 题解清单 (≥4星)
1. **Lucaster_** (5星)
   - 使用队列实现拓扑排序，代码简洁清晰。
   - 预处理时直接减去阈值，减少后续计算复杂度。
   - 详细注释和讲解，适合初学者理解。

2. **zzlzk** (4星)
   - 明确解释了阈值处理的数学原理，思路清晰。
   - 使用栈实现拓扑排序，提供了不同的实现视角。
   - 代码结构清晰，易于理解。

3. **ghj1222** (4星)
   - 使用拓扑排序和动态规划思想，代码简洁。
   - 详细解释了输入层和阈值的处理逻辑。
   - 提供了完整的代码和注释，便于学习。

### 最优思路或技巧提炼
1. **预处理阈值**：在输入时直接减去阈值，简化后续计算。
2. **队列管理**：使用队列维护待处理的神经元，确保按层次顺序处理。
3. **状态传递条件**：只有状态大于0的神经元才会传递信号，避免无效计算。
4. **输出层判断**：通过出度数组快速识别输出层神经元。

### 同类型题或类似算法套路
- **拓扑排序**：适用于有向无环图的层次遍历问题。
- **动态规划**：神经元状态的更新类似于动态规划中的状态转移。
- **图搜索**：BFS/DFS可用于类似的层次遍历问题。

### 推荐题目
1. [P1113 杂务](https://www.luogu.com.cn/problem/P1113)
2. [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)
3. [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017)

### 个人心得摘录
- **Lucaster_**：调试过程中发现输入层的阈值处理是关键，预处理后代码更简洁。
- **zzlzk**：通过数学推导简化了公式，减少了不必要的计算。
- **ghj1222**：拓扑排序的动态规划思想让代码更高效，减少了重复计算。

### 可视化与算法演示
**动画方案：**
1. **初始化**：显示所有神经元节点和连接边，输入层节点高亮。
2. **处理队列**：当前处理的节点高亮，状态更新后传递给下一层节点。
3. **状态更新**：动态显示每个神经元状态的更新过程，颜色变化表示状态变化。
4. **终止条件**：队列为空时停止，输出层节点状态显示。

**交互设计：**
- **步进控制**：允许用户单步执行，观察每一步的状态更新。
- **速度调节**：调整动画速度，便于理解快速或慢速执行过程。
- **高亮显示**：当前节点、已访问节点和待访问节点用不同颜色区分。

**复古游戏化效果：**
- **像素风格**：神经元和边用8位像素风格绘制，增加趣味性。
- **音效提示**：节点处理时播放轻微音效，状态更新时播放不同音效。
- **自动演示**：自动执行拓扑排序过程，用户可暂停或继续。

### 代码片段
```cpp
// 拓扑排序核心代码
void topoSort() {
    queue<int> q;
    for (int i = 1; i <= n; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (auto &edge : adj[u]) {
            int v = edge.to;
            int w = edge.weight;
            if (c[u] > 0) {
                c[v] += w * c[u];
            }
            inDegree[v]--;
            if (inDegree[v] == 0) {
                q.push(v);
            }
        }
    }
}
```

### 可视化设计要点
- **颜色方案**：输入层（绿色）、中间层（蓝色）、输出层（红色）。
- **Canvas绘制**：节点用圆形表示，边用箭头表示，边权显示在边上。
- **音效触发**：节点入队时播放“入队”音效，状态更新时播放“更新”音效。
- **自动演示**：按拓扑顺序自动处理节点，用户可随时暂停或继续。

---
处理用时：47.10秒
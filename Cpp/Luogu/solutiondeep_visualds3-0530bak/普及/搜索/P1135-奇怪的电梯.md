# 题目信息

# 奇怪的电梯

## 题目背景

感谢 @[yummy](https://www.luogu.com.cn/user/101694) 提供的一些数据。

## 题目描述

呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \le i \le N$）上有一个数字 $K_i$（$0 \le K_i \le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 200$，$1 \le A, B \le N$，$0 \le K_i \le N$。

本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。

## 样例 #1

### 输入

```
5 1 5
3 3 1 2 5
```

### 输出

```
3
```

# AI分析结果

# 算法分类：BFS

## 综合分析与结论
本题是一个典型的图搜索问题，核心是通过BFS寻找从起点A到终点B的最短路径。每个楼层可以看作图中的节点，电梯的上下移动构成图中的边（边权为1）。由于边权相同，BFS是最优解法，保证首次访问到终点时的步数即为最短路径。

### 核心难点与解决方案
1. **搜索发起**：从起点A开始，初始化队列和访问标记数组。
2. **状态转移**：每次从队列取出当前楼层，生成上下移动后的新楼层（需检查边界）。
3. **终止条件**：到达终点B或队列为空（无解）。
4. **剪枝优化**：通过`visited`数组避免重复访问，确保每个节点只处理一次。

### 可视化设计思路
- **动画方案**：用网格表示楼层，当前访问节点高亮为红色，已访问节点标记为灰色，队列中的节点显示为蓝色。
- **步进控制**：允许用户单步执行，观察BFS的层级扩展过程。
- **游戏化效果**：8-bit音效（节点访问音、成功音效），积分系统奖励最短路径发现。

## 题解清单 (≥4星)
1. **作者：_H17_**（5星）
   - 全面覆盖多种最短路算法（Dijkstra/SPFA/BFS等），代码规范，注释清晰。
   - 关键亮点：明确指出BFS在边权为1时的最优性，提供邻接表建图模板。

2. **作者：yummy**（5星）
   - 深入分析DFS剪枝错误与正确做法，强调BFS的稳定性。
   - 关键亮点：提出时间复杂度证明（O(n^2)），给出正确DFS剪枝条件。

3. **作者：cff_0102**（4星）
   - 简洁的BFS实现，队列状态管理清晰。
   - 关键亮点：特判起点等于终点的边界情况，代码可读性强。

## 最优思路与代码实现
**BFS核心代码**（作者：cff_0102）：
```cpp
queue<int> q;
q.push(a);
vis[a] = 1;
while (!q.empty()) {
    int u = q.front(); q.pop();
    if (u == b) return cout << step[u], 0; // 到达终点
    for (int d : {+k[u], -k[u]}) {        // 上下移动
        int v = u + d;
        if (v >= 1 && v <= n && !vis[v]) {
            vis[v] = 1;
            step[v] = step[u] + 1;
            q.push(v);
        }
    }
}
cout << -1; // 无解
```

## 同类型题目推荐
1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)（BFS网格移动）
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)（BFS连通块）
3. [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)（DFS/BFS路径计数）

## 可视化实现要点
```javascript
// 伪代码：8-bit风格BFS动画
function drawNode(floor, color) {
    ctx.fillStyle = color; // 红/蓝/灰
    ctx.fillRect(x, y, 20, 20); // 绘制像素方块
}

function playSound(effect) {
    if (effect === "visit") beep(440, 50);  // 访问音效
    if (effect === "win") beep(880, 200);   // 胜利音效
}

// 自动演示循环
let queue = [A];
while (queue.length) {
    let u = queue.shift();
    drawNode(u, "red"); // 当前节点高亮
    playSound("visit");
    // ...生成子节点并加入队列
}
```

## 个人心得摘录
> 作者yummy提到：“BFS的队列性质天然保证首次访问即最短路径，而DFS需谨慎剪枝”——强调了选择合适算法的重要性。

---
处理用时：35.08秒
# 题目信息

# [USACO1.4] 母亲的牛奶 Mother's Milk

## 题目描述

农民约翰有三个容量分别是 $a,b,c$ 升的桶。  

最初，$a,b$ 桶都是空的，而 $c$ 桶是装满牛奶的。有时，农民把牛奶从一个桶倒到另一个桶中，直到被灌桶装满或原桶空了。  

当然每一次灌注都是完全的。由于节约，牛奶不会有丢失。

写一个程序去帮助农民找出当 $a$ 桶是空的时候，$c$ 桶中牛奶所剩量的所有可能性。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le a,b,c \le 20$。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
8 9 10
```

### 输出

```
1 2 8 9 10
```

## 样例 #2

### 输入

```
2 5 10```

### 输出

```
5 6 7 8 9 10```

# AI分析结果

### 唯一算法分类
DFS

### 综合分析与结论
本题的核心是通过搜索枚举所有可能的倒牛奶状态，找到当A桶为空时C桶的可能剩余量。由于牛奶总量不变，可以用A和B桶的当前牛奶量作为状态进行DFS/BFS搜索，避免重复计算。

**核心难点与解决方案：**
1. **状态表示与判重**：使用三维数组`vis[a][b][c]`记录是否访问过该状态，避免重复搜索。
2. **倒牛奶的6种操作**：每次搜索时枚举所有可能的倒法（A→B, A→C, B→A, B→C, C→A, C→B），并计算倒后的新状态。
3. **终止条件**：当A桶为空时，记录当前C桶的牛奶量。

**可视化设计思路：**
- **节点表示**：每个状态用(A, B, C)表示，绘制为网格中的方块。
- **颜色标记**：已访问节点标为灰色，当前节点标为红色，待访问节点标为绿色。
- **动画效果**：逐步展示倒牛奶的过程，每次倒牛奶后更新状态并标记访问。
- **交互控制**：提供暂停、继续、单步执行功能，允许用户观察搜索过程。

### 题解清单 (≥4星)
1. **远航之曲 (5星)**
   - **亮点**：提供了多种解法（DFS、BFS、递归、枚举等），代码简洁高效，思路清晰。
   - **关键代码**：
     ```cpp
     void dfs(int a[]) {
         if (vis[a[0]][a[1]][a[2]]) return;
         vis[a[0]][a[1]][a[2]] = true;
         if (a[0] == 0) milk[a[2]] = true;
         for (int i = 0; i < 3; ++i) {
             for (int j = 0; j < 3; ++j) {
                 if (j == i) continue;
                 if (a[j] < bkt[j] && a[i] > 0) {
                     int rec = std::min(bkt[j] - a[j], a[i]);
                     int b[3];
                     memcpy(b, a, sizeof(int)*3);
                     b[i] -= rec, b[j] += rec;
                     dfs(b);
                 }
             }
         }
     }
     ```

2. **zhanghanbin (4星)**
   - **亮点**：详细解释了DFS的实现和剪枝策略，代码可读性强。
   - **关键代码**：
     ```cpp
     void dfs(int a, int b, int c) {
         if (vis[a][b][c] == 1) return;
         else vis[a][b][c] = 1;
         if (a == 0 && rec[c] == 0) rec[c] = 1;
         if (c >= (A - a)) dfs(A, b, c - (A - a));
         else dfs(c + a, b, 0);
         // 其他5种倒法类似
     }
     ```

3. **xun薰 (4星)**
   - **亮点**：代码简洁，直接枚举6种倒法，使用排序输出结果。
   - **关键代码**：
     ```cpp
     void dfs(int nowa, int nowb, int nowc) {
         if (vis[nowa][nowb][nowc]) return;
         if (nowa == 0) ans[++k] = nowc;
         vis[nowa][nowb][nowc] = 1;
         if (nowc) {
             if (nowa < ta) dfs(min(ta, nowa + nowc), nowb, nowc - (min(ta, nowa + nowc) - nowa));
             if (nowb < tb) dfs(nowa, min(nowb + nowc, tb), nowc - (min(tb, nowb + nowc) - nowb));
         }
         // 其他4种倒法类似
     }
     ```

### 最优思路或技巧提炼
1. **状态压缩**：用三维数组`vis[a][b][c]`记录状态，避免重复搜索。
2. **倒牛奶操作统一处理**：通过循环枚举所有可能的倒法，减少代码冗余。
3. **剪枝优化**：在倒牛奶时提前判断是否能倒（如目标桶未满且源桶非空），避免无效操作。

### 同类型题或类似算法套路
- **迷宫搜索**：类似的状态搜索问题，如P1605 迷宫。
- **最短路径**：BFS用于无权图的最短路径问题，如P1443 马的遍历。
- **八数码问题**：状态空间搜索，如P1379 八数码难题。

### 推荐 3 道考察相似知识点的洛谷题目
1. P1605 迷宫
2. P1443 马的遍历
3. P1379 八数码难题

### 个人心得摘录
- **远航之曲**：提到“牛奶的总量是不变的，所以可以用a,b中的牛奶量做状态”，强调了状态表示的重要性。
- **zhanghanbin**：提到“这道题需暴力”，提醒搜索题有时需要枚举所有可能状态。
- **xun薰**：提到“注意要判断当前状态是否存在过，否则会死循环”，强调了判重的必要性。

### 可视化与算法演示
- **动画方案**：逐步展示倒牛奶的过程，每次倒牛奶后更新状态并标记访问。
- **颜色标记**：已访问节点标为灰色，当前节点标为红色，待访问节点标为绿色。
- **交互控制**：提供暂停、继续、单步执行功能，允许用户观察搜索过程。
- **复古像素风格**：使用8位像素风格绘制节点和边，增加趣味性。

### 复古游戏化动画效果（可选）
- **8位像素风格**：使用简单的16色调色板绘制节点和边。
- **音效提示**：访问新节点时播放“像素音效”，找到目标时播放上扬音调。
- **自动演示模式**：自动运行搜索算法，展示一步步扩展访问的过程。
- **关卡设计**：将搜索过程拆分为若干小关，每完成一次搜索即“通关”。

---
处理用时：47.90秒
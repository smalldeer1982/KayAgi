# 题目信息

# 显示图像

## 题目描述

古老的显示屏是由 $N \times M$ 个像素（Pixel）点组成的。一个像素点的位置是根据所在行数和列数决定的。例如 $P(2,1)$ 表示第 $2$ 行第 $1$ 列的像素点。那时候，屏幕只能显示黑与白两种颜色，人们用二进制 $0$ 和 $1$ 来表示。$0$ 表示黑色，$1$ 表示白色。当计算机发出一个指令：$P(x,y)=1$，则屏幕上的第 $x$ 行第 $y$ 列的阴极射线管就开始工作，使该像素点显示白色，若 $P(x,y)=0$，则对应位置的阴极射线管不工作，像素点保持黑色。在某一单位时刻，计算机以 $N \times M$ 二维 $01$ 矩阵的方式发出显示整个屏幕图像的命令。

例如，屏幕是由 $3 \times 4$ 的像素点组成，在某单位时刻，计算机发出如下命令：

$$\begin{pmatrix}
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 1 \\
0 & 1 & 1 & 0 \\
\end{pmatrix}$$

对应屏幕显示应为：

![](https://cdn.luogu.com.cn/upload/image_hosting/cwg2di9s.png)

假设放大后，一个格子表示一个像素点。

由于未知的原因，显示黑色的像素点总是受显示白色的像素点的影响——可能是阴极射线管工作的作用。并且，距离越近，影响越大。这里的距离定义如下：

设有像素点 $P_1(x_1,y_1)$ 和像素点 $P_2(x_2,y_2)$，则它们之间的距离 $D(P_1,P_2)=|x_1-x_2|+|y_1-y_2|$。

在某一时刻，计算机发出显示命令后，科学家们期望知道，每个像素点和其最近的显示白色的像素点之间的最短距离是多少——科学家们保证屏幕上至少有一个显示白色的像素点。

上面的例子中，像素 $P(1,1)$ 与最近的白色像素点之间的距离为 $3$，而像素 $P(3,2)$ 本身显示白色，所以最短距离为 $0$。


## 说明/提示

- 对于 $30\%$ 的数据：$N\times M \le 10000$；
- 对于 $100\%$ 的数据：$N\times M \le 182^2$。

## 样例 #1

### 输入

```
3 4
0001
0011
0110
```

### 输出

```
3 2 1 0
2 1 0 0
1 0 0 1
```

# AI分析结果

### 唯一算法分类
**BFS**

### 综合分析与结论
题目要求计算每个像素点到最近白色像素点的曼哈顿距离，核心是**多源最短路径问题**。BFS是解决这类问题的经典算法，因为：
1. **层次遍历特性**：BFS按层扩展，天然适合计算最短距离。
2. **多源点处理**：将所有白色像素点（距离为0）作为初始队列，同步扩展。

#### 核心难点与解决方案
- **输入处理**：注意无分隔符的矩阵输入（需逐字符读取）。
- **距离计算**：曼哈顿距离直接通过BFS的层数体现。
- **性能优化**：避免对每个黑点单独BFS（O(n²m²)），改用多源BFS（O(nm)）。

#### 可视化设计思路
1. **动画方案**：
   - **初始状态**：白色像素点标记为绿色（距离0），黑色为灰色。
   - **扩展过程**：每次从队列取出点，将四周未访问的点标记为当前距离+1，加入队列并变色（如蓝色→浅蓝→深蓝表示距离递增）。
   - **终止条件**：队列为空时所有点已计算最短距离。
2. **交互功能**：
   - 步进控制：暂停/继续/单步执行。
   - 速度调节：控制BFS扩展速度。
3. **复古像素风格**：
   - 使用8-bit色块表示像素点，音效提示访问新节点（如"哔"声）。

### 题解清单 (≥4星)
1. **Hydra_ (BFS模板) ★★★★☆**
   - 亮点：标准多源BFS实现，队列初始化清晰，方向数组使用规范。
   - 代码可读性强，适合学习BFS基础。

2. **Atmizz (BFS+STL) ★★★★☆**
   - 亮点：使用STL队列，结构体封装坐标和距离，代码简洁。
   - 适合C++学习者参考STL应用。

3. **pantw (四向DP) ★★★★☆**
   - 亮点：创新性四向动态规划，分别从左上、右上、左下、右下递推。
   - 提供不同于BFS的思路，适合拓展思维。

### 最优思路提炼
**多源BFS模板**：
1. 初始化队列时加入所有白点（距离0）。
2. 每次从队列取出点，更新四周黑点的距离并加入队列。
3. 队列为空时即得全局最短距离。

**关键代码片段**：
```cpp
queue<pair<int,int>> q;
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        if(grid[i][j]=='1'){
            dist[i][j]=0;
            q.push({i,j});
        }
while(!q.empty()){
    auto [x,y]=q.front(); q.pop();
    for(int k=0;k<4;k++){
        int nx=x+dx[k], ny=y+dy[k];
        if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&dist[nx][ny]==INF){
            dist[nx][ny]=dist[x][y]+1;
            q.push({nx,ny});
        }
    }
}
```

### 同类型题推荐
1. P1443 马的遍历（BFS最短路径）
2. P1162 填涂颜色（BFS连通块）
3. P1131 时态同步（树上的BFS应用）

### 个人心得摘录
- **封禁用户**：提醒输入格式陷阱（无空格数字需字符串处理）。
- **彭骐飞**：DFS会超时，BFS才是正解，体现算法选择重要性。
- **Atmizz**：STL队列简化代码，但需注意边界判断。

### 可视化实现要点（JS伪代码）
```javascript
// 初始化Canvas
const grid = drawPixelMatrix(n, m); 
// 多源BFS动画
function animateBFS(){
    while(queue.length){
        let [x,y] = queue.shift();
        grid[x][y].color = updateColor(dist[x][y]); // 更新颜色
        playSound('beep'); // 音效
        for(let k=0;k<4;k++){
            let nx = x + dx[k], ny = y + dy[k];
            if(valid(nx,ny) && dist[nx][ny]==INF){
                dist[nx][ny] = dist[x][y]+1;
                queue.push([nx,ny]);
            }
        }
    }
}
```
**8-bit风格**：使用#FF0000（红）、#00FF00（绿）、#0000FF（蓝）等复古色块，配芯片音效。

---
处理用时：40.55秒
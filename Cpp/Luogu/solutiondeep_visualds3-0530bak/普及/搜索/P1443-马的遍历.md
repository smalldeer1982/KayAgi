# 题目信息

# 马的遍历

## 题目描述

有一个 $n \times m$ 的棋盘，在某个点 $(x, y)$ 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。


## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq x \leq n \leq 400$，$1 \leq y \leq m \leq 400$。

## 样例 #1

### 输入

```
3 3 1 1
```

### 输出

```
0    3    2    
3    -1   1    
2    1    4    ```

# AI分析结果

# 算法分类：BFS

## 综合分析与结论

这道题是典型的BFS应用场景，要求计算马在棋盘上到达每个点的最少步数。由于马走"日"字的特殊移动方式，每个位置最多有8个可能的下一步位置，使用BFS可以保证第一次访问到某个位置时的步数就是最短步数。

核心难点在于：
1. 正确处理马的8种移动方向
2. 处理棋盘边界条件
3. 输出格式要求（左对齐、宽5格）
4. 性能优化（400x400的棋盘需要高效实现）

解决方案要点：
- 使用队列实现BFS，按层扩展
- 用二维数组记录步数并初始化为-1
- 方向数组存储8种移动方式
- 使用visited数组或直接利用步数数组避免重复访问

## 题解清单 (≥4星)

1. shajjl的题解（赞：1599）★★★★★
   - 使用STL的queue和pair简洁实现
   - 代码结构清晰，注释明确
   - 完整处理了输出格式要求

2. 永遠の愛的题解（赞：613）★★★★
   - 详细解释了BFS原理和队列操作
   - 提供了两种队列实现方式（双队列和pair）
   - 输出格式处理完整

3. YE110W_No1的题解（赞：321）★★★★
   - 简洁高效的BFS实现
   - 使用结构体组织数据
   - 仅8ms通过测试

## 最优思路与技巧提炼

1. **方向数组技巧**：
```cpp
const int dx[8] = {-1,-2,-2,-1,1,2,2,1};
const int dy[8] = {2,1,-1,-2,2,1,-1,-2};
```
将8种移动方式预先存储，避免重复计算。

2. **步数记录优化**：
```cpp
// 初始化
memset(ans, -1, sizeof(ans));
ans[x][y] = 0;

// BFS中更新步数
ans[nx][ny] = ans[now.x][now.y] + 1;
```
利用初始化为-1同时实现未访问标记和结果存储。

3. **输出格式处理**：
```cpp
printf("%-5d", ans[i][j]);
```
使用printf的格式化输出实现左对齐和固定宽度。

## 同类型题与类似算法套路

类似题目通常涉及：
- 网格上的最短路径问题
- 特殊移动规则的路径搜索
- 状态空间搜索

通用解法：
1. 确定状态表示（位置坐标）
2. 确定状态转移（移动规则）
3. 使用BFS进行状态扩展
4. 记录访问状态避免重复

## 推荐相似题目

1. P1135 奇怪的电梯 - BFS求最短按钮次数
2. P1141 01迷宫 - 连通块大小计算
3. P1162 填涂颜色 - 矩阵BFS应用

## 个人心得摘录

"刚开始做的时候用的dfs，相信很多人都是这么做的。结果果然TLE了。那么大家有没有想过：为什么会TLE呢？我们都知道dfs是一条路搜到黑，所以不可以保证最开始搜到的就是最近点。" - __gcd

"用2、1、-1、-2是因为马走日字，同一个下标的dx和dy相互对应，表示每一种走法" - JeffWang2019

## 可视化与算法演示

### 动画方案设计

1. **网格表示**：
   - 使用Canvas绘制n×m的棋盘网格
   - 每个格子显示当前步数，未访问显示-1

2. **搜索过程**：
   - 当前访问的格子高亮为红色
   - 队列中的格子标记为蓝色
   - 已访问的格子标记为浅灰色

3. **步进控制**：
   - 播放/暂停按钮控制动画
   - 速度调节滑块
   - 单步执行按钮

4. **移动展示**：
   - 从当前格子画出8条虚线到可能移动位置
   - 实际移动的线变为实线并闪烁

### 复古游戏化效果

1. **8位像素风格**：
   - 使用16色调色板
   - 马用骑士像素图标表示
   - 步数用8位风格数字显示

2. **音效设计**：
   - 移动音效：短促"哒"声
   - 访问新格子："叮"声
   - 完成搜索：胜利音效

3. **关卡设计**：
   - 简单关卡：小棋盘(3×3)
   - 中等关卡：标准棋盘(8×8)
   - 困难关卡：大棋盘(20×20)

## 核心代码实现

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;

const int dx[8] = {-1,-2,-2,-1,1,2,2,1};
const int dy[8] = {2,1,-1,-2,2,1,-1,-2};

int n, m, sx, sy;
int ans[405][405];
bool vis[405][405];

struct Point {
    int x, y, step;
};

void bfs() {
    queue<Point> q;
    q.push({sx, sy, 0});
    vis[sx][sy] = true;
    ans[sx][sy] = 0;
    
    while(!q.empty()) {
        Point cur = q.front();
        q.pop();
        
        for(int i = 0; i < 8; i++) {
            int nx = cur.x + dx[i];
            int ny = cur.y + dy[i];
            
            if(nx >= 1 && nx <= n && ny >= 1 && ny <= m && !vis[nx][ny]) {
                vis[nx][ny] = true;
                ans[nx][ny] = cur.step + 1;
                q.push({nx, ny, cur.step + 1});
            }
        }
    }
}

int main() {
    cin >> n >> m >> sx >> sy;
    memset(ans, -1, sizeof(ans));
    bfs();
    
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) {
            printf("%-5d", ans[i][j]);
        }
        printf("\n");
    }
    return 0;
}
```

这个实现包含了BFS的核心逻辑，使用队列进行扩展，方向数组处理移动，并正确处理了输出格式。

---
处理用时：56.21秒
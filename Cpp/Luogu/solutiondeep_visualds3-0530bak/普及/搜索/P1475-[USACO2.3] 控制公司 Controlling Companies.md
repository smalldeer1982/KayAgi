# 题目信息

# [USACO2.3] 控制公司 Controlling Companies

## 题目描述

有些公司是其他公司的部分拥有者，因为他们获得了其他公司发行的股票的一部分。

据说，如果至少满足了以下三个条件之一，公司 $A$ 就可以控制公司 $B$ 了：

- 公司 $A$ = 公司 $B$。
- 公司 $A$ 拥有大于 $50\%$ 的公司 $B$ 的股票。
- 公司 $A$ 控制 $K$（$K \geq 1$）个公司，记为 $C_1, \ldots, C_K$，每个公司 $C_i$ 拥有 $x_i\%$ 的公司 $B$ 的股票，并且 $x_1+ \ldots + x_K \gt 50\%$。

给你一个表，每行包括三个数 $i,j,p$：表明公司 $i$ 享有公司 $j$ 的 $p\%$ 的股票。计算所有的数对 $(h,s)$，表明公司 $h$ 控制公司 $s$。至多有 $100$ 个公司。

## 说明/提示

翻译来自NOCOW

USACO 2.3


## 样例 #1

### 输入

```
3
1 2 80
2 3 80
3 1 20```

### 输出

```
1 2
1 3
2 3```

# AI分析结果

# 算法分类：DFS

## 综合分析与结论

这道题目要求找出所有公司之间的控制关系，核心在于递归地计算每个公司通过直接或间接方式对其他公司的控制权。大多数题解采用了DFS方法，通过递归遍历公司的控制链，累计控制股份，并在超过50%时标记为控制关系。

### 核心难点与解决方案：
1. **递归终止条件**：当公司已被访问过时停止递归，避免重复计算和无限循环。
2. **股份累计**：在DFS过程中动态累计当前公司通过其控制的子公司对其他公司的股份。
3. **控制关系判定**：当累计股份超过50%时，标记控制关系并继续递归搜索。

### 可视化设计思路：
- **节点访问顺序**：使用不同颜色标记当前访问的节点（公司）和已访问的节点。
- **股份累计过程**：动态显示股份的累计过程，当超过50%时高亮显示控制关系。
- **递归路径**：通过动画展示递归调用的路径，帮助理解DFS的深度优先特性。

## 题解清单 (≥4星)

### 1. 以墨 (5星)
- **亮点**：简洁高效的DFS实现，清晰标记访问状态和控制关系。
- **关键代码**：
  ```cpp
  void EMILY(int x) {
      if(f[x]==true) return;
      f[x]=true;
      for(int i=m;i;i--) {
          cnt[i]+=a[x][i];
          if(cnt[i]>50) {
              own[i]=true;
              EMILY(i);
          }
      }
  }
  ```

### 2. 「QQ红包」 (4星)
- **亮点**：使用动态累计股份的方式，代码结构清晰。
- **关键代码**：
  ```cpp
  void dfs(int c) {
      pd[c]=1;
      for(int i=1;i<=n;i++) {
          he[i]+=a[c][i];
          if(he[i]>50 && pd[i]==0) dfs(i);
      }
  }
  ```

### 3. Celebrate (4星)
- **亮点**：详细注释和清晰的逻辑，适合初学者理解。
- **关键代码**：
  ```cpp
  void dfs(int k) {
      if(v[k]==true) return;
      v[k]=true;
      for(int i=1;i<=n;i++) {
          f[i]+=a[k][i];
          if(f[i]>50) {
              c[i]=true;
              dfs(i);
          }
      }
  }
  ```

## 最优思路或技巧提炼

1. **递归累计股份**：通过DFS递归累计控制股份，动态更新控制关系。
2. **访问标记**：使用`visited`数组避免重复访问和无限递归。
3. **动态更新**：在递归过程中实时更新股份累计和控制关系，确保准确性。

## 同类型题或类似算法套路

- **图遍历**：类似图的DFS/BFS遍历，用于查找连通性或路径。
- **动态规划**：部分题解中隐含动态规划思想，通过子问题的解构建全局解。

## 推荐3道相似题目

1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219) - DFS经典问题。
2. [P1605 迷宫](https://www.luogu.com.cn/problem/P1605) - BFS/DFS解决迷宫问题。
3. [P1037 产生数](https://www.luogu.com.cn/problem/P1037) - 图的遍历与组合数学。

## 个人心得摘录

- **调试经历**：在实现DFS时，忘记标记访问状态导致无限递归，通过添加`visited`数组解决。
- **顿悟感想**：递归的本质是将问题分解为子问题，通过子问题的解构建全局解。

## 可视化与算法演示

### 动画方案
- **颜色标记**：当前节点（红色），已访问节点（绿色），控制关系（蓝色）。
- **步进控制**：允许单步执行，观察递归调用和股份累计过程。
- **控制面板**：暂停、继续、步进、速度调节。

### 复古游戏化动画效果
- **8位像素风格**：使用16色调色板绘制公司和控制关系。
- **音效提示**：访问新节点时播放音效，找到控制关系时播放成功音效。
- **自动演示**：自动运行DFS，展示搜索过程。

### 关键代码片段
```javascript
function dfs(node) {
    if (visited[node]) return;
    visited[node] = true;
    for (let neighbor in graph[node]) {
        total[neighbor] += graph[node][neighbor];
        if (total[neighbor] > 50 && !visited[neighbor]) {
            controlled[neighbor] = true;
            dfs(neighbor);
        }
    }
}
```

通过上述设计和实现，可以直观地展示DFS算法的执行过程和控制关系的动态更新，帮助理解算法的核心逻辑。

---
处理用时：41.31秒
# 题目信息

# 正方形计数

## 题目描述

给定平面上 $N$ 个点，你需要计算以其中 $4$ 个点为顶点的正方形的个数。注意这里的正方形边不一定需要和坐标轴平行。


## 说明/提示

对于 $20\%$ 的数据，满足 $1\leq N\leq 20$。

对于 $100\%$ 的数据，满足 $1\leq N\leq 500$，$-50\leq X_i, Y_i\leq 50$，点不会重合。

## 样例 #1

### 输入

```
7

0 0

0 1

1 0

1 1

1 2

2 1

2 2```

### 输出

```
3```

# AI分析结果

### 算法分类
**其他搜索**

### 综合分析与结论
题目要求统计平面上N个点能构成的正方形数量，正方形的边不一定与坐标轴平行。核心思路是通过枚举对角线或边，利用几何性质计算另外两个点的坐标，并检查这些点是否存在。

#### 核心难点与解决方案
1. **如何高效枚举正方形**：直接暴力枚举四个点的时间复杂度为O(n^4)，无法通过大规模数据。优化思路是枚举两个点（如对角线或边），通过几何性质推导出另外两个点的坐标，检查是否存在。
2. **几何性质的应用**：利用正方形的对称性和中点公式，可以快速计算出另外两个点的坐标。例如，给定对角线的两个点，可以通过中点公式和向量旋转推导出另外两个点。
3. **避免重复计数**：由于每条边或对角线会被多次枚举，最终结果需要除以一个常数（如4）来消除重复计数。

#### 可视化设计思路
1. **节点绘制**：在Canvas上绘制所有点，用不同颜色标记已访问和待访问的点。
2. **搜索过程**：高亮当前枚举的两个点（如对角线），动态显示计算出的另外两个点，并用颜色区分是否存在。
3. **交互控制**：允许用户单步执行枚举过程，观察每一步的计算和检查过程。
4. **复古像素风格**：使用8位像素风格绘制点和线，背景音乐和音效增强交互体验。

### 题解清单 (≥4星)
1. **Huami360 (5星)**
   - **亮点**：通过枚举对角线，利用中点公式和向量旋转推导出另外两个点，时间复杂度O(n^2)。
   - **代码可读性**：清晰易懂，注释详细。
   - **优化程度**：避免了暴力枚举，利用几何性质高效计算。

2. **MZW_BG (4星)**
   - **亮点**：同样枚举对角线，通过几何全等推导出另外两个点，使用布尔数组快速检查点是否存在。
   - **代码可读性**：结构清晰，附带图示解释几何原理。
   - **优化程度**：与Huami360类似，但使用了不同的坐标计算公式。

3. **xiaozeyu (4星)**
   - **亮点**：使用哈希表处理大范围坐标，适用于坐标范围较大的情况。
   - **代码可读性**：简洁明了，哈希表实现高效。
   - **优化程度**：通过哈希表快速查找点，适合坐标范围较大的场景。

### 最优思路或技巧提炼
1. **枚举对角线**：通过枚举两个点作为对角线，利用中点公式和向量旋转推导出另外两个点，检查是否存在。
2. **几何性质**：正方形的对称性和中点公式是快速计算另外两个点的关键。
3. **哈希表优化**：对于坐标范围较大的情况，使用哈希表快速查找点是否存在。
4. **避免重复计数**：由于每条边或对角线会被多次枚举，最终结果需要除以4。

### 同类型题或类似算法套路
1. **枚举几何图形**：类似题目包括统计矩形、三角形等几何图形的数量，通常通过枚举边或对角线，利用几何性质推导其他点。
2. **哈希表优化**：在需要快速查找点是否存在的场景中，哈希表是一种高效的解决方案。

### 推荐题目
1. **P2733 家的范围**：统计矩阵中正方形的数量。
2. **P1387 最大正方形**：在01矩阵中寻找最大的正方形。
3. **P2216 理想的正方形**：在矩阵中寻找满足条件的正方形。

### 个人心得摘录
- **调试经历**：在计算另外两个点的坐标时，需要注意坐标的符号和范围，避免越界。
- **踩坑教训**：直接暴力枚举四个点会导致超时，必须优化枚举策略。
- **顿悟感想**：利用几何性质可以大幅减少计算量，数学知识在算法优化中非常重要。

### 代码片段
```cpp
// Huami360的代码片段
for(int i = 1; i < n; ++i)
    for(int j = i + 1; j <= n; ++j){
        int midx = (x[i] + x[j]) / 2;
        int midy = (y[i] + y[j]) / 2;            
        int x1 = midx - (midy - y[i]), y1 = midy + (midx - x[i]);
        int x2 = midx + (midy - y[i]), y2 = midy - (midx - x[i]);
        if(x1 <= 0) continue; if(x2 <= 0) continue;
        if(y1 <= 0) continue; if(y2 <= 0) continue; 
        if(vis[x1][y1] && vis[x2][y2]) ++ans;
    }
```

### 可视化设计要点
1. **颜色方案**：使用8位像素风格，已访问点用红色，待访问点用绿色，当前枚举的点用蓝色。
2. **Canvas绘制**：初始化Canvas，绘制所有点，动态更新颜色以反映搜索过程。
3. **音效触发**：当找到正方形时播放上扬音效，枚举新点时播放轻微音效。
4. **交互控制**：提供暂停、继续、步进按钮，允许用户控制搜索速度。

通过以上设计，可以直观地展示搜索过程，帮助理解算法原理和优化策略。

---
处理用时：45.67秒
# 题目信息

# 最长路

## 题目描述

设 $G$ 为有 $n$ 个顶点的带权有向无环图，$G$ 中各顶点的编号为 $1$ 到 $n$，请设计算法，计算图 $G$ 中 $1, n$ 间的最长路径。

## 说明/提示

**【数据规模与约定】**

- 对于 $20\%$的数据，$n \leq 100$，$m \leq 10^3$。
- 对于 $40\%$ 的数据，$n \leq 10^3$，$m \leq 10^{4}$。
- 对于 $100\%$ 的数据，$1 \leq n \leq 1500$，$0 \leq m \leq 5 \times 10^4$，$1 \leq u, v \leq n$，$-10^5 \leq w \leq 10^5$。

## 样例 #1

### 输入

```
2 1
1 2 1```

### 输出

```
1```

# AI分析结果

# 最长路问题分析与题解对比

## 算法分类
拓扑排序 + 动态规划

## 综合分析与结论

本题要求在有向无环图(DAG)中求1到n的最长路径，核心难点在于：
1. 处理负权边（传统最短路算法需要调整）
2. 确保路径从1出发到达n
3. 高效计算最长路径

各题解主要采用两种思路：
1. **拓扑排序+DP**：利用DAG性质按拓扑序递推最长路
2. **SPFA变种**：将边权取负后跑最短路，或直接修改松弛条件求最长路

可视化设计建议：
- 采用分层动画展示拓扑排序过程
- 用不同颜色标记已处理节点和当前处理节点
- 动态显示DP值的更新过程
- 对于SPFA方案，可视化队列操作和松弛过程

## 高分题解推荐 (≥4星)

### 1. Mine_King的拓扑+DP解法 (5星)
- 亮点：正确处理入度为0的非起点节点，清晰解释拓扑序DP原理
- 关键代码：
```cpp
while(!q.empty()) {
    int x=q.front(); q.pop();
    for(int i=0;i<g[x].size();i++) {
        if(v[g[x][i]]<v[x]+d[x][i]) v[g[x][i]]=v[x]+d[x][i];
        if(!--in[g[x][i]]) q.push(g[x][i]);
    }
}
```

### 2. vectorxyz的SPFA解法 (4星)  
- 亮点：边权取负转最短路，思路简洁易懂
- 关键代码：
```cpp
add(a, b, -c); // 建负边
int t = spfa();
printf("%d\n", -t); // 输出时取反
```

### 3. lijingyuanpp的拓扑+DP解法 (4星)
- 亮点：使用str数组标记从1可达的路径，确保正确性
- 关键代码：
```cpp
if(str[u] == 0) continue; // 不在1路径上的点跳过
dp[v] = max(dp[v], dp[u] + e[j].w);
```

## 最优思路提炼

1. **拓扑排序+DP**是最优解：
   - 时间复杂度O(n+m)，适合DAG
   - 正确处理负权边
   - 天然保证无后效性

2. 关键实现技巧：
   - 预处理非起点入度为0的节点
   - 初始化DP数组为极小值
   - 按拓扑序松弛边

## 同类题目推荐

1. P4017 最大食物链计数（拓扑排序+DP）
2. P1807 最长路（类似本题）
3. P3385 负环（SPFA应用）

## 个人心得摘录

> "大家有没有发现，这题的正解是拓扑+DP...因为题目中说了i<j，所以点1绝对是一个没有入度的点" - Mine_King

> "建图的时候就把w变成-w，然后再跑一遍最短路...最后输出的时候再输出答案的相反数即可" - vectorxyz

## 可视化算法演示

建议实现拓扑排序+DP的可视化：
1. 初始状态：显示图结构和入度
2. 拓扑排序：动画展示节点从队列取出和处理过程
3. DP更新：实时显示每个节点的最长路值变化
4. 最终结果：高亮1到n的最长路径

伪代码示例：
```javascript
// 拓扑排序可视化
function visualize() {
    let q = [1]; // 初始队列
    while(q.length) {
        let u = q.shift();
        highlightNode(u); // 高亮当前节点
        for(let v of adj[u]) {
            dp[v] = Math.max(dp[v], dp[u] + w[u][v]);
            updateDPValue(v); // 更新DP显示
            if(--inDegree[v] === 0) {
                q.push(v);
                enqueueAnimation(v); // 入队动画
            }
        }
    }
}
```

---
处理用时：38.52秒
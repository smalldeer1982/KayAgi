# 题目信息

# [NOI2011] 道路修建

## 题目描述

在 W 星球上有 $n$ 个国家。为了各自国家的经济发展，他们决定在各个国家之间建设双向道路使得国家之间连通。但是每个国家的国王都很吝啬，他们只愿意修建恰好 $n - 1$ 条双向道路。

每条道路的修建都要付出一定的费用，这个费用等于道路长度乘以道路两端 的国家个数之差的绝对值。例如，在下图中，虚线所示道路两端分别有 $2$ 个、$4$ 个国家，如果该道路长度为 $1$，则费用为 $1×|2 - 4|=2$。图中圆圈里的数字表示国家的编号。
 
 ![](https://cdn.luogu.com.cn/upload/pic/2604.png) 

由于国家的数量十分庞大，道路的建造方案有很多种，同时每种方案的修建费用难以用人工计算，国王们决定找人设计一个软件，对于给定的建造方案，计算出所需要的费用。请你帮助国王们设计一个这样的软件。


## 说明/提示

对于 $100\%$ 的数据，$1\leq a_i, b_i\leq n$，$0\leq c_i\leq10^6$，$2\leq n\leq 10^6$。
|测试点编号|$n=$|
|:-:|:-:|
|$1$|$2$|
|$2$|$10$|
|$3$|$100$|
|$4$|$200$|
|$5$|$500$|
|$6$|$600$|
|$7$|$800$|
|$8$|$1000$|
|$9$|$10^4$|
|$10$|$2\times 10^4$|
|$11$|$5\times 10^4$|
|$12$|$6\times 10^4$|
|$13$|$8\times 10^4$|
|$14$|$10^5$|
|$15$|$6\times 10^5$|
|$16$|$7\times 10^5$|
|$17$|$8\times 10^5$|
|$18$|$9\times 10^5$|
|$19,20$|$10^6$|



## 样例 #1

### 输入

```
6
1 2 1
1 3 1
1 4 2
6 3 1
5 2 1```

### 输出

```
20```

# AI分析结果

# 算法分类：DFS

## 综合分析与结论

本题的核心是计算树中每条边的贡献值，贡献公式为：`边权 × |两端节点数之差|`。所有题解均采用DFS遍历树结构，通过统计子树大小来计算每条边的贡献。

### 核心难点与解决方案
1. **子树大小统计**：需要高效计算每个节点的子树大小，这是计算边贡献的基础。
2. **贡献公式应用**：对于每条边(u,v)，其中v是u的子节点，贡献值为`|n - 2*size[v]| × 边权`。
3. **大数据处理**：n可达1e6，需要O(n)算法，避免递归爆栈（部分题解提到NOI原题可能爆栈，但洛谷数据可通过）。

### 最优思路提炼
- **一次DFS统计子树大小**：在DFS过程中同时计算子树大小和边的贡献，避免重复遍历。
- **绝对值公式简化**：利用`|n - 2*size[v]|`直接计算两端节点数之差，无需分别统计两侧。
- **链式前向星存图**：高效存储树结构，适合大规模数据。

### 同类型题与算法套路
类似问题通常涉及树的遍历和子树统计，常见于：
1. 树的直径计算
2. 树的重心查找
3. 子树权值和统计

### 推荐题目
1. P1352 没有上司的舞会（树形DP）
2. P3379 【模板】最近公共祖先（LCA）
3. P1395 会议（树的重心）

## 题解清单 (≥4星)

### 1. Melon_Musk (5星)
- **亮点**：清晰的公式推导，代码简洁高效，直接在一次DFS中完成统计。
- **代码片段**：
```cpp
void dfs(int x,int fa) {
    size[x]=1;
    for(int i=head[x];i;i=e[i].nt) {
        int to=e[i].to;
        if(fa==to) continue;
        dfs(to,x);
        size[x]+=size[to];
        ans+=e[i].w*abs(2*size[to]-n);
    }
}
```

### 2. Aw顿顿 (5星)
- **亮点**：详细解释了公式转换过程，代码可读性强，使用long long避免溢出。
- **个人心得**：强调了审题重要性，最初误解题意为图论问题。

### 3. kradcigam (4星)
- **亮点**：使用vector存图，代码简洁，适合C++11及以上环境。
- **关键思路**：同样在一次DFS中完成统计，强调了连通图性质的应用。

## 可视化与算法演示

### 搜索过程动画设计
1. **节点展开**：从根节点(1)开始，用不同颜色标记已访问(绿色)、当前访问(红色)和未访问(灰色)节点。
2. **子树统计**：在节点被访问完成后，显示其子树大小，并用动画展示size的累加过程。
3. **边贡献计算**：当回溯到父节点时，显示当前边的贡献计算过程。

### 复古游戏化效果
1. **8位像素风格**：节点用彩色像素方块表示，边用直线连接。
2. **音效设计**：
   - 访问新节点：短促"滴"声
   - 完成子树统计：上升音调
   - 计算边贡献："咔嗒"声
3. **自动演示模式**：按DFS顺序自动遍历节点，可调节速度。

### 控制面板功能
1. 播放/暂停
2. 单步执行
3. 速度调节
4. 显示/隐藏子树大小

## 核心代码实现

```cpp
// 链式前向星存图
struct Edge {
    int to, w, next;
} e[N<<1];
int head[N], cnt;

void add(int u, int v, int w) {
    e[++cnt] = {v, w, head[u]};
    head[u] = cnt;
}

// DFS统计
void dfs(int u, int fa) {
    size[u] = 1;
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa) continue;
        dfs(v, u);
        size[u] += size[v];
        ans += abs(n - 2*size[v]) * e[i].w;
    }
}
```

这个实现展示了最简洁高效的解决方案，适用于大规模数据，时间复杂度O(n)，空间复杂度O(n)。

---
处理用时：37.48秒
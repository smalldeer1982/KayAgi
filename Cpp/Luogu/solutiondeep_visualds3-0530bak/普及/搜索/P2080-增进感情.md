# 题目信息

# 增进感情

## 题目背景

小明和小红的感情，是慢慢发展起来的。


## 题目描述

他们对对方分别有一个好感值。定义两人的亲密程度为两人的好感值之和。

如果他们的亲密程度达到 $v$，则他们将走到一起。他们以后的生活将取决于两人的好感值之差的绝对值，这个值越小，他们的生活将越幸福。

现在，他们对对方的好感值都为 $0$，小明有 $n$ 件事可以干，每件事可以增加他对小红的好感 $a_i$ 点，并且增加小红对他的好感 $b_i$ 点。（可能为负数）

小明可以任选一些事做，请你帮小明求出怎样才能让他们的生活更加幸福（求出两人在一起的前提下，好感值之差的最小绝对值即可）。


## 说明/提示

#### 数据范围与约定

- 对于 $20\%$ 数据，保证 $n  \le 10$。
- 对于 $100\%$ 数据，保证 $1 \le n \le 30$，$1 \le \left\vert a_i\right\vert,\left\vert b_i\right\vert \le 100$。

## 样例 #1

### 输入

```
4 15
5 6
-1 8
7 2
1 0
```

### 输出

```
3```

# AI分析结果

# 算法分类选择
**DFS**  
本题的核心解法是通过深度优先搜索（DFS）枚举所有可能的选事件组合，属于典型的组合搜索问题。

---

# 题解思路与算法要点

## 核心思路对比
1. **暴力DFS+剪枝**  
   - 所有题解均采用DFS枚举选/不选每件事的状态
   - 关键差异在于剪枝策略的优化程度：
     - 基础版：仅当完成所有选择后检查亲密度和差（TLE风险）
     - 优化版：实时检查亲密度和差，发现`minn=0`立即终止搜索

2. **状态传递方式**  
   - 多数题解传递当前好感值`(sum_a, sum_b)`  
   - 少数题解（如Eraine）传递差值`cha`减少计算量

3. **终止条件**  
   - 最优解：`minn==0`时直接返回（绝对最优性剪枝）
   - 次优解：仅当`sum_a + sum_b >= v`才计算差值

## 解决难点
- **指数级复杂度**：30件事对应$2^{30}$种状态，必须剪枝
- **负权值处理**：好感度可能为负，不能简单贪心
- **双目标优化**：需同时满足亲密度和≥v与差值最小

---

# 高分题解推荐 (≥4星)

## 1. defense（5星）
**亮点**：  
- 双重剪枝（位置剪枝+极值剪枝）  
- 清晰的状态回溯逻辑  
- 代码可读性极佳  

**核心代码**：
```cpp
void dfs(int deep){
    if(ga+gb>v) minn = min(abs(ga-gb), minn);
    if(minn==0) return; // 极值剪枝
    for(int i=deep;i<m;i++){ // 位置剪枝
        if(!used[i]){
            used[i] = 1;
            ga += a[i]; gb += b[i];
            dfs(i+1);
            // 回溯...
        }
    }
}
```

## 2. Eraine（4.5星）  
**亮点**：  
- 差值传递优化计算  
- 详细注释与变量说明  
- 数学分析透彻  

**创新点**：  
```cpp
void search_dfs(v, sum, cha){
    if(minx==0) return;
    if(sum>=w) minx = min(minx, abs(cha));
    // 传递差值而非原始值
    search_dfs(v+1, sum, cha);
    search_dfs(v+1, sum+a[v][0]+a[v][1], cha+a[v][0]-a[v][1]);
}
```

## 3. 百里狂生（4星）  
**亮点**：  
- 系统性的剪枝分析  
- 三种优化方案对比  
- 教学式注释  

**关键优化**：  
```cpp
if(minn==0) return; // 终极剪枝
for(int i=step;i<n;i++) // 位置剪枝
    if(!visited[i]){
        // 状态更新...
        dfs(i+1); // 注意不是step+1
    }
```

---

# 最优技巧提炼

1. **极值剪枝**  
   当发现`minn=0`时立即终止，这是数学上的绝对最优解。

2. **搜索顺序优化**  
   使用`for(int i=deep;...)`避免重复计算已处理位置。

3. **差值传递**  
   直接维护`sum_a - sum_b`而非分别存储，减少计算量。

4. **负权兼容**  
   正确处理好感度为负的情况，不能提前终止非正路径。

---

# 同类型题目推荐
1. P2392（子集和问题）  
2. P1219（八皇后问题）  
3. P1120（木棍剪枝）

---

# 可视化设计

## 动画方案
1. **节点表示**  
   - 每个事件用像素方块表示，绿色(已选)/红色(未选)
   - 当前状态用黄色边框高亮

2. **搜索过程**  
   ```python
   # 伪代码演示DFS动画
   def animate_dfs(step):
       highlight(step)
       if minn == 0: 
           play_sound('win')
           return
       if step >= n: 
           update_minn()
           return
       # 选当前事件
       color_block(step, GREEN)
       animate_dfs(step+1)
       # 不选当前事件 
       color_block(step, RED)
       animate_dfs(step+1)
   ```

3. **复古风格**  
   - 8-bit音效：节点访问（beep）、找到解（fanfare）
   - 像素字体显示当前`minn`值
   - 16色NES调色板（绿/红/黄为主）

## 交互功能
- **速度调节**：0.5x~5x动画速度
- **模式切换**：对比普通DFS与剪枝版效率
- **数据生成**：随机生成测试用例

---

# 个人心得摘录
> "当发现`minn=0`时，往后的搜索已经没有意义，因为已经找出了最小值！" —— 百里狂生  
> "快NOIp了，练练搜索防爆0" —— UperFicial  
> "题解AC了，但我的爱情还没AC" —— 违规用户名U56916

---

# 完整代码示例
```cpp
// defense的AC代码（带注释版）
#include<cstdio>
#include<cmath>
using namespace std;
int m,v,a[30],b[30],minn=1e9,ga,gb;
bool used[30];

void dfs(int deep){
    if(ga+gb>v) minn = min(abs(ga-gb), minn);
    if(minn==0) return; // 终极剪枝
    for(int i=deep;i<m;i++){ // 位置剪枝
        if(!used[i]){
            used[i] = 1;
            ga += a[i]; gb += b[i];
            dfs(i+1);
            ga -= a[i]; gb -= b[i]; // 回溯
            used[i] = 0;
        }
    }
}

int main(){
    scanf("%d%d",&m,&v);
    for(int i=0;i<m;i++) scanf("%d%d",&a[i],&b[i]);
    dfs(0);
    printf("%d", minn==1e9 ? -1 : minn);
    return 0;
}
```

---
处理用时：54.72秒
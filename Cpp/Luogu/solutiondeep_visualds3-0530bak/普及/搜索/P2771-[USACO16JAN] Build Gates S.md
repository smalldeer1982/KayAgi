# 题目信息

# [USACO16JAN] Build Gates S

## 题目描述

FarmerJohn 打算在他农场的一部分，建设一个围栏。但是因为没有认真做事，建造完成后，围栏变成一个很奇怪的形状。

具体来说，FJ 从 $(0,0)$ 出发，走了 $N$ 步，每步移动一单位（向东、向南、向西或向北）。

他走过的每一步，都会留下一段单位长度的围栏。例如，如果他的第一步向北，他建造一单位从 $(0,0)$ 到 $(0,1)$ 的围栏。

FJ 可能重复到达点多次，他也可能重复建造一段围栏多次。如果他的路径穿过一段已经建成的围栏，他的围栏也有可能会有交叉。

不用说，FJ 看到完成的围栏时，一定很沮丧。特别的，他发现一些区域被围栏封闭起来，从而无法到达。FJ 想在围栏上，安装一些门来解决这个问题。

门可以安装在任意一段单位长度（注：必须是之前走过的某一步）的围栏上，从而可以穿越这段围栏的两侧。

请计算 FJ 最少需要安装多少个门，才能保证农场上任意区域到任意区域都可到达。

## 说明/提示

注意，如果农场初始连通，答案就是 $0$。

### 数据范围

$1\le n\le 1000$。


## 样例 #1

### 输入

```
14
NNNESWWWSSEEEE```

### 输出

```
2```

# AI分析结果

### 算法分类
**其他搜索**

### 综合分析与结论
题目要求计算FJ行走路径形成的封闭区域数量，即需要安装的最少门数。核心思路是通过搜索或图论方法识别封闭区域。不同题解主要采用以下方法：

1. **环计数法**：统计不包含其他环的独立封闭环数量（如LPhang的方法一）。
2. **图论法**：将问题转化为图的边数与生成树边数的差值（如LPhang的方法二）。
3. **DFS/BFS法**：通过搜索统计封闭区域数量（如lxzy_的方法）。

**难点与解决方案**：
- **封闭区域识别**：需处理路径交叉和重复边的问题。通过标记访问点和方向（如Zenith_Yeh的题解）或扩展步长（如lxzy_的题解）解决。
- **负坐标处理**：通过偏移起点（如(1000,1000)）避免数组越界。
- **小区域遗漏**：通过“一步当两步走”策略确保小封闭区域被检测到。

### 题解清单 (≥4星)
1. **LPhang的方法一（5星）**：
   - **亮点**：清晰识别独立封闭环，逻辑严谨，代码高效。
   - **关键思路**：记录访问点和方向，统计新增独立环。

2. **LPhang的方法二（4星）**：
   - **亮点**：图论视角，将问题转化为边数与生成树边数的差值。
   - **关键思路**：计算边数`num1`和点数`num`，答案为`num1 - num + 1`。

3. **lxzy_的方法（4星）**：
   - **亮点**：DFS搜索封闭区域，处理小区域和边界问题。
   - **关键思路**：扩展步长和搜索范围，确保所有封闭区域被检测。

### 最优思路或技巧提炼
1. **独立环计数**：通过记录访问点和方向，统计新增独立封闭环（LPhang的方法一）。
2. **图论转化**：将问题转化为图的边数与生成树边数的差值，简化计算（LPhang的方法二）。
3. **扩展步长**：通过“一步当两步走”确保小封闭区域被检测（lxzy_的方法）。

### 同类型题或类似算法套路
- **迷宫搜索**：类似BFS/DFS遍历识别封闭区域。
- **图论问题**：如计算图的连通分量或环的数量。
- **路径交叉问题**：如计算自交路径形成的封闭区域。

### 推荐题目
1. **P1137 旅行计划**：图论问题，计算路径。
2. **P1141 01迷宫**：BFS搜索连通区域。
3. **P1162 填涂颜色**：DFS识别封闭区域。

### 个人心得摘录
- **lxzy_**：调试时发现输入中的换行符导致错误，需处理非预期字符。
- **LPhang**：通过图论视角简化问题，避免复杂搜索。
- **Zenith_Yeh**：标记方向避免重复计数，提高效率。

### 可视化与算法演示
1. **动画方案**：
   - **节点标记**：高亮当前访问点和方向。
   - **搜索过程**：展示DFS/BFS的遍历顺序，标记已访问区域。
   - **封闭区域识别**：用不同颜色标记独立封闭环。

2. **复古游戏化效果**：
   - **像素风格**：8位色彩，网格化显示路径和封闭区域。
   - **音效**：访问新节点时播放音效，找到封闭区域时播放成功音效。
   - **自动演示**：逐步展示路径形成和封闭区域识别过程。

### 代码片段
**LPhang的方法一核心代码**：
```cpp
if(!f[last][now] && bol[x][y]) ++ans;
f[last][now] = f[now][last] = 1;
```

**lxzy_的DFS核心代码**：
```cpp
void DFS(int x,int y) {
    map[x][y]=true;
    for(int i=0;i<=3;i++) {
        int nx=x+dx[i], ny=y+dy[i];
        if(nx>=Minx-2 && nx<=Maxx+2 && ny>=Miny-2 && ny<=Maxy+2 && !map[nx][ny])
            DFS(nx,ny);
    }
}
```

**Zenith_Yeh的方向标记核心代码**：
```cpp
if(bj[now_x][now_y][0]==0 && bj[now_x-1][now_y][2]==0) {
    mapp[now_x-1][now_y]++;
    if(mapp[now_x-1][now_y]>=2) ans++;
}
bj[now_x][now_y][0] = bj[now_x-1][now_y][2] = 1;
```

---
处理用时：37.54秒
# 题目信息

# [USACO15OPEN] Bessie Goes Moo S

## 题目描述

Farmer John 和奶牛 Bessie 喜欢在空闲时间互相出数学谜题。

上一次 FJ 给 Bessie 出的谜题非常难，她没能解出来。

现在，她想通过给 FJ 出一个有挑战性的谜题来报复他。

Bessie 给 FJ 的表达式是 $(B+E+S+S+I+E)(G+O+E+S)(M+O+O)$，其中包含七个变量 $B,E,S,I,G,O,M$（"$O$" 是一个变量，不是零）。对于每个变量，她给 FJ 提供了一个最多包含 500 个整数值的列表，表示该变量可能取的值。

她要求 FJ 计算有多少种不同的方式可以为这些变量赋值，使得整个表达式的值是 7 的倍数。

注意，这个问题的答案可能太大，无法用 32 位整数表示，因此你可能需要使用 64 位整数（例如，C 或 C++ 中的 "long long"）。

## 说明/提示

两种可能的赋值方式是：

$(B,E,S,I,G,O,M) = (2, 5, 7, 9, 1, 16, 19)$ -> 51,765

$(B,E,S,I,G,O,B) = (2, 5, 7, 9, 1, 16, 2)$ -> 34,510

## 样例 #1

### 输入

```
10
B 2
E 5
S 7
I 10
O 16
M 19
B 3
G 1
I 9
M 2```

### 输出

```
2```

# AI分析结果

### 算法分类选择
**其他搜索**（本题核心是暴力枚举+模运算优化，虽使用DFS但本质是状态枚举）

---

### 题解思路与算法要点
#### 核心思路
1. **模运算优化**：利用`(a*b)%7 = (a%7 * b%7)%7`的性质，将所有变量取值先模7，将问题规模从500^7压缩到7^7。
2. **暴力枚举**：枚举每个变量模7后的可能取值（0~6），统计满足表达式为7倍数的组合数。
3. **乘法原理计数**：对每个有效组合，累加各变量对应余数的出现次数乘积。

#### 解决难点
- **负数的模处理**：通过`(x%7+7)%7`统一转为非负余数。
- **组合爆炸优化**：DFS或七重循环枚举时，跳过未出现的余数（如`if(!g[now][i]) continue`）。
- **表达式拆分判断**：部分题解将原式拆分为三个因式，任一因式模7为0即可（进一步剪枝）。

---

### 题解评分（≥4星）
1. **Expecto（5星）**
   - 亮点：最简洁的DFS实现，清晰处理模运算和计数。
   - 关键代码：
     ```cpp
     void dfs(int now) {
         if (now==7) {
             long long sum = (表达式)%7;
             if (sum==0) ans += 各变量余数出现次数的乘积;
             return;
         }
         for (int i=0; i<7; i++) 
             if (g[now][i]) x[now]=i, dfs(now+1);
     }
     ```

2. **Ofnoname（4星）**
   - 亮点：明确解释模运算原理，代码结构清晰。
   - 优化点：使用桶存储余数出现次数，DFS参数传递当前乘积。

3. **Wangchenxin（4星）**
   - 亮点：七重循环暴力枚举，代码直白易理解。
   - 关键片段：
     ```cpp
     for(int B=0; B<7; B++) for(int E=0; E<7; E++) ... 
         if ((表达式)%7 == 0) 
             ans += hsh['B'][B] * hsh['E'][E] * ...;
     ```

---

### 最优思路提炼
1. **模7压缩状态空间**：核心优化，将无限取值转为有限余数。
2. **DFS/循环枚举+剪枝**：通过`if(!g[now][i]) continue`跳过无效状态。
3. **表达式因式分解**：拆分为`(B+2E+2S+I)(G+O+E+S)(M+2O)`，任一括号模7为0即满足条件。

---

### 同类型题目
1. **P2638 安全系统**（状态枚举+模运算）
2. **P2921 Trick or Treat**（模性质+暴力搜索）
3. **P7960 数论问题**（同余方程+枚举）

---

### 可视化设计（像素风格演示）
#### 动画方案
- **节点表示**：7个变量作为7列像素块，每列高度表示余数出现次数（颜色深浅）。
- **搜索过程**：DFS时高亮当前访问的变量和余数，成功时播放8-bit音效。
- **控制面板**：
  ```javascript
  function dfsStep(step) {
      if (step == 7) {
          if (valid()) playSound('success');
          return;
      }
      for (let i=0; i<7; i++) {
          highlight(step, i); // 高亮当前选择
          if (counts[step][i] > 0) dfsStep(step+1);
      }
  }
  ```

#### 复古元素
- **音效**：NES风格的哔声（Web Audio API生成）。
- **像素画风**：CSS绘制16x16像素的变量图标，如`B`用蓝色方块。

---

### 代码片段（关键搜索逻辑）
```cpp
// Expecto的DFS核心
void dfs(int now) {
    if (now == 7) {
        long long sum = (x[0]+x[1]+2*x[2]+x[3]) * (x[4]+x[5]+x[1]+x[2]) * (x[6]+2*x[5]);
        if (sum %7 == 0) {
            long long tmp = 1;
            for (int i=0; i<7; i++) tmp *= g[i][x[i]];
            ans += tmp;
        }
        return;
    }
    for (int i=0; i<7; i++) {
        if (g[now][i]) {
            x[now] = i;
            dfs(now+1);
        }
    }
}
```

---

### 总结
本题解通过**模运算+暴力搜索**的经典组合，展示了如何将数学性质与算法结合。可视化设计可帮助理解状态枚举过程，而像素风格增强趣味性。同类题目可优先考虑模性质和状态压缩。

---
处理用时：40.54秒
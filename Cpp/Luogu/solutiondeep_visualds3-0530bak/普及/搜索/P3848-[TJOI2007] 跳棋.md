# 题目信息

# [TJOI2007] 跳棋

## 题目背景

在一个n×n的棋盘上，布满了0和1，如图（a）所示（n=7），为叙述方便，将0用字母表示，如图（b）。

![](https://cdn.luogu.com.cn/upload/pic/6077.png)


## 题目描述

跳棋规则：

（1）从某个0格出发，可以向上，下，左，右4个方向连续越过若干个（至少1个）

1格而跳入下一个0格。如图（b）中从A出发，可跳到B，或者到E，但不能直接到K。在跳到B之后还可以继续跳到F;在跳到E之后可继续跳到F或K。直到不能再跳为止。

（2）每个0格只能到达一次，给出的起始点不能再到达，也不能越过。

跳过的距离为跳过1格个数加1，如从A到B，跳过距离为3，从B到F，跳过距离为2。

问   题： 当棋盘和起始点给出之后，问最远能跳的距离是多少？

如上图（b）中，从A出发，可跳过的路线不止一条，其中一条为：

A － B － F － L － K － E  （可能不唯一）

3    2    3    3     3

它的距离为14。


## 说明/提示

$\text{upd 2022.7.27}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
4  3  2
1  0  1  0 
1  1  1  1
0  0  1  0
1  1  0  1```

### 输出

```
6```

# AI分析结果

# 算法分类选择
**DFS**（深度优先搜索）

# 综合分析与结论

## 题解思路与核心难点
本题的核心是通过搜索算法在棋盘上找到从起点出发的最远跳跃距离。主要难点在于：
1. **跳跃规则处理**：必须跳过至少一个1才能到达下一个0，且不能直接跳到相邻的0
2. **路径记录**：需要记录已访问的0格，避免重复访问
3. **距离计算**：跳跃距离是跳过1的个数加1

各题解普遍采用DFS算法，通过递归实现路径探索。关键差异在于：
- 搜索方向处理：使用while循环或嵌套for循环实现连续跳跃
- 剪枝策略：提前终止无效路径
- 状态记录：使用二维数组标记已访问节点

## 可视化设计思路
1. **动画方案**：
   - 用不同颜色标记：当前节点(红色)、已访问节点(灰色)、待访问节点(绿色)
   - 逐步显示DFS的递归过程，包括递归调用和回溯
   - 高亮显示当前搜索路径

2. **交互功能**：
   - 步进控制：单步执行/连续执行切换
   - 速度调节：控制动画播放速度
   - 路径追踪：突出显示当前最优路径

3. **复古像素风格**：
   - 8-bit风格棋盘和棋子
   - 跳跃时播放经典"跳棋"音效
   - 找到新路径时播放胜利音效

# 题解清单 (≥4星)

## 1. 犇犇犇犇 (5星)
- **亮点**：清晰的while循环处理跳跃逻辑，简洁的DFS模板
- **代码可读性**：良好，变量命名合理
- **优化**：及时break无效路径

## 2. JJA_ (4星)
- **亮点**：使用方向数组简化代码，chkmax宏优化
- **注意事项**：修复了回溯问题，通过hack数据

## 3. zilingheimei (4星)
- **亮点**：详细注释，绝对值计算跳跃距离
- **注意事项**：明确处理相邻0格的边界条件

# 最优思路与技巧提炼

1. **跳跃处理**：
```cpp
while(tx+dx[i]>0 && tx+dx[i]<=n && ty+dy[i]>0 && ty+dy[i]<=n) {
    tx+=dx[i]; ty+=dy[i]; s++;
    if(m[tx][ty]==0) break;
}
```

2. **DFS核心**：
```cpp
void dfs(int x, int y, int step) {
    ans = max(ans, step);
    for(方向) {
        // 处理跳跃
        if(有效跳跃) {
            f[tx][ty] = 1;
            dfs(tx, ty, step+s);
            f[tx][ty] = 0; // 回溯
        }
    }
}
```

3. **剪枝优化**：
- 提前终止相邻0格的无效跳跃
- 记录最大ans及时更新

# 同类型题与推荐题目

1. **类似题目**：
   - P1560 [USACO5.2]蜗牛的旅行Snail Trails
   - P1433 吃奶酪
   - P1120 小木棍

2. **通用解法**：
   - 棋盘类DFS通常需要处理移动规则和访问标记
   - 使用方向数组简化代码
   - 回溯法处理路径记录

# 个人心得摘录

- "被hack数据卡了好久，最后发现是回溯问题" — JJA_
- "绝对值的距离计算方式让我WA了3次" — zilingheimei
- "while循环处理连续跳跃比递归更直观" — 犇犇犇犇

# 可视化核心代码示例

```javascript
// 伪代码 - DFS动画核心
function animateDFS(node, path) {
    highlight(node); // 当前节点
    playSound('move'); 
    
    for(let dir of directions) {
        let jump = calculateJump(node, dir);
        if(validJump(jump)) {
            markVisited(jump.to);
            path.push(jump);
            
            animateDFS(jump.to, path); // 递归
            
            path.pop(); // 回溯动画
            unmarkVisited(jump.to);
        }
    }
    
    if(path.length > bestPath.length) {
        bestPath = [...path];
        playSound('win');
    }
}
```

# 复古像素风格设计

1. **视觉元素**：
   - 16x16像素的棋子精灵
   - 8色调色板：红、绿、蓝、黄、紫、青、白、黑
   - 棋盘网格线

2. **音效设计**：
   - 移动：短促"哔"声
   - 新路径：上升音阶
   - 胜利：经典FC过关音效

3. **自动演示**：
```javascript
function autoPlay() {
    let steps = 0;
    const timer = setInterval(() => {
        if(steps >= maxSteps) clearInterval(timer);
        executeNextDFSStep();
        steps++;
    }, 300);
}
```

---
处理用时：38.05秒
# 题目信息

# [JLOI2009] 二叉树问题

## 题目描述

如下图所示的一棵二叉树的深度、宽度及结点间距离分别为：

- 深度：$4$
- 宽度：$4$
- 结点 8 和 6 之间的距离：$8$
- 结点 7 和 6 之间的距离：$3$

其中宽度表示二叉树上同一层最多的结点个数，节点 $u, v$ 之间的距离表示从 $u$ 到 $v$ 的最短有向路径上向根节点的边数的两倍加上向叶节点的边数。

![](https://cdn.luogu.com.cn/upload/pic/6843.png)

给定一颗以 1 号结点为根的二叉树，请求出其深度、宽度和两个指定节点 $x, y$ 之间的距离。


## 说明/提示

对于全部的测试点，保证 $1 \leq u, v, x, y \leq n \leq 100$，且给出的是一棵树。保证 $u$ 是 $v$ 的父结点。

## 样例 #1

### 输入

```
10                                
1 2                            
1 3                            
2 4
2 5
3 6
3 7
5 8
5 9
6 10
8 6
```

### 输出

```
4
4
8```

# AI分析结果

### 唯一算法分类
DFS

### 综合分析与结论
这道题目主要考察二叉树的遍历和最近公共祖先（LCA）的应用。核心难点在于如何高效计算两个节点之间的距离，这需要结合DFS遍历和LCA算法。DFS用于计算每个节点的深度和统计每层的节点数（宽度），而LCA则用于计算两个节点之间的最短路径。

**搜索过程可视化设计思路：**
1. **DFS遍历**：从根节点开始，递归访问每个子节点，记录每个节点的深度和父节点。
2. **LCA计算**：通过比较两个节点的深度，先将较深的节点提升到与较浅节点同一深度，然后同时向上查找公共祖先。
3. **距离计算**：根据题目定义，上行边数×2加上下行边数。

**复古像素风格设计：**
- **颜色方案**：使用8位色调色板，如绿色表示当前访问节点，红色表示已访问节点，蓝色表示待访问节点。
- **Canvas动画**：在网格中绘制二叉树，节点用方块表示，边用线条连接。DFS遍历时，当前节点高亮显示，访问顺序通过颜色变化体现。
- **音效提示**：访问新节点时播放“滴”声，找到LCA时播放“叮”声。

### 题解清单 (≥4星)
1. **KALY (Floyd算法) - 4星**
   - 亮点：使用Floyd算法计算最短路径，思路新颖，代码简洁。
   - 关键代码：Floyd三重循环更新邻接矩阵。

2. **dessert (LCA) - 5星**
   - 亮点：清晰的LCA实现，代码可读性强，附带详细注释。
   - 关键代码：LCA函数通过父节点回溯。

3. **常青藤 (最短路) - 4星**
   - 亮点：将树视为图，使用SPFA算法，适合稀疏图。
   - 关键代码：SPFA队列实现最短路计算。

### 代码粘贴与核心实现思想
**dessert的LCA实现：**
```cpp
int lca(int x,int y) {
    a[x].data=1;
    while(a[x].father!=0) {
        x=a[x].father;
        a[x].data=1;
    }
    while(a[y].data!=1) y=a[y].father;
    return y;
}
```
- **核心思想**：标记x的所有祖先，然后y向上查找第一个被标记的节点即为LCA。

**KALY的Floyd实现：**
```cpp
for(int k=1;k<=n;k++)
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            a[i][j]=Min(a[i][j],a[i][k]+a[k][j]);
```
- **核心思想**：动态规划更新所有节点对的最短路径。

### 可视化设计要点
- **Canvas初始化**：绘制二叉树结构，节点按层次排列。
- **DFS动画**：递归访问节点时，当前节点变为绿色，回溯时变为红色。
- **LCA高亮**：找到LCA时，该节点闪烁黄色。
- **音效触发**：使用Web Audio API，访问节点时触发音效。

### 推荐相似题目
1. P3379 【模板】最近公共祖先（LCA）
2. P1395 会议
3. P1047 校门外的树

### 个人心得摘录
- **调试经历**：初始时未考虑双向边，导致DFS死循环，后改为记录父节点避免重复访问。
- **顿悟感想**：LCA算法不仅适用于二叉树，可以推广到一般树的最近公共祖先问题。

---
处理用时：31.33秒
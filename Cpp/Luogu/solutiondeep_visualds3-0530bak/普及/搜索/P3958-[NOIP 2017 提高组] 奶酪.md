# 题目信息

# [NOIP 2017 提高组] 奶酪

## 题目背景

NOIP2017 提高组 D2T1

## 题目描述

现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z = 0$，奶酪的上表面为 $z = h$。

现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。

位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑 到奶酪的上表面去?

空间内两点 $P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$ 的距离公式如下：


$$\mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$$


## 说明/提示

【输入输出样例 $1$ 说明】

 ![](https://cdn.luogu.com.cn/upload/pic/10860.png) 

第一组数据,由奶酪的剖面图可见：

第一个空洞在 $(0,0,0)$ 与下表面相切；

第二个空洞在 $(0,0,4)$ 与上表面相切；

两个空洞在 $(0,0,2)$ 相切。

输出 `Yes`。

 
第二组数据,由奶酪的剖面图可见：

两个空洞既不相交也不相切。

输出 `No`。

 
第三组数据,由奶酪的剖面图可见：

两个空洞相交，且与上下表面相切或相交。

输出 `Yes`。

【数据规模与约定】

对于 $20\%$ 的数据，$n = 1$，$1 \le h$，$r \le  10^4$，坐标的绝对值不超过 $10^4$。

对于 $40\%$ 的数据，$1 \le n \le 8$，$1 \le h$，$r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $80\%$ 的数据，$1 \le n \le 10^3$，$1 \le h , r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $100\%$ 的数据，$1 \le n \le 1\times 10^3$，$1 \le h , r \le 10^9$，$T \le 20$，坐标的绝对值不超过 $10^9$。

## 样例 #1

### 输入

```
3 
2 4 1 
0 0 1 
0 0 3 
2 5 1 
0 0 1 
0 0 4 
2 5 2 
0 0 2 
2 0 4```

### 输出

```
Yes
No
Yes```

# AI分析结果

# 算法分类：并查集

## 综合分析与结论

这道题目主要考察的是连通性问题，即判断是否存在一条从奶酪下表面到上表面的路径。虽然题目可以使用BFS/DFS等搜索算法解决，但最优解是使用并查集数据结构，因为它能高效处理连通性问题。

核心难点在于：
1. 如何判断两个空洞是否连通（相交或相切）
2. 如何高效合并连通空洞
3. 如何判断是否存在从下表面到上表面的连通路径

并查集的解决方案：
1. 将每个空洞视为一个独立集合
2. 遍历所有空洞对，判断是否相交/相切，如果是则合并集合
3. 维护两个特殊集合：与下表面连通和与上表面连通的空洞
4. 最后检查这两个特殊集合是否连通

## 题解清单 (≥4星)

1. **Fading (5星)**
   - 使用并查集高效解决连通性问题
   - 详细解释了判断两球相交的数学原理
   - 代码清晰，包含优化处理防止爆long long
   - 特别强调了精度问题和数据范围

2. **ikunTLE (4星)**
   - 简洁明了的并查集实现
   - 使用平方比较避免浮点运算
   - 代码结构清晰，变量命名合理

3. **pipilong2024 (4星)**
   - 创新性地维护了每个集合的最大/最小高度
   - 避免了最后双重循环检查
   - 代码注释详细，逻辑清晰

## 最优思路与技巧提炼

1. **数学优化**：通过平方比较代替开方运算，避免浮点精度问题
   ```cpp
   if ((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2) <= 4*r*r)
   ```

2. **并查集优化**：路径压缩提高查找效率
   ```cpp
   int find(int x) {
       if (x != f[x]) f[x] = find(f[x]);
       return f[x];
   }
   ```

3. **特殊集合处理**：维护与上下表面连通的空洞集合，减少最后检查的复杂度

## 同类型题与算法套路

类似连通性问题可以使用相同思路：
1. 迷宫连通性问题
2. 图的连通分量
3. 网络连接问题

通用解法：
1. 将元素初始化为独立集合
2. 根据连通条件合并集合
3. 最后检查目标集合是否连通

## 推荐相似题目

1. P1551 亲戚 - 基础并查集应用
2. P1197 [JSOI2008]星球大战 - 逆向并查集
3. P2024 [NOI2001]食物链 - 带权并查集

## 个人心得摘录

- "多测不清空，爆零两行泪" - 强调了多组测试数据初始化的重要性
- "不开long long见祖宗" - 提醒注意数据范围，防止溢出
- "精度问题卡爆了我double" - 浮点运算可能带来的问题

## 可视化与算法演示

并查集的可视化可以设计为：
1. **初始状态**：所有节点独立显示
2. **合并过程**：当两个空洞相交时，用线条连接并显示集合合并
3. **路径压缩**：动态展示查找时的路径压缩过程
4. **结果检查**：高亮显示与上下表面连通的集合

**复古游戏化设计**：
- 8-bit像素风格显示空洞
- 合并时播放"连接"音效
- 找到路径时播放胜利音效
- 可以设计为"老鼠逃生"主题游戏

## 核心代码实现

Fading的并查集实现：
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1001];//并查集
int find(int x){
    if (x!=f[x]) f[x]=find(f[x]);
    return f[x];
}//查找+路径压缩
long long dis(long long x,long long y,long long z,long long x1,long long y1,long long z1){
    return (x-x1)*(x-x1)+(y-y1)*(y-y1)+(z-z1)*(z-z1);
}//两点距离公式，注意这里算的是距离平方。
long long x[100001],y[100001],z[100001];
int f1[100001],f2[100001];
//f1记录与顶面相交的洞的序号
//f2记录与底面相交的洞的序号
int main(){
    int t;
    scanf("%d",&t);
    int n,h; 
    long long r;
    for (int i=1;i<=t;i++){
        scanf("%d%d%lld",&n,&h,&r);
        int tot1=0;//记录与顶面相交的洞有几个
        int tot2=0;//记录与底面相交的洞有几个
        for (int j=1;j<=n;j++){
          f[j]=j;  //并查集初始化
         }
        for (int j=1;j<=n;j++){
            scanf("%lld%lld%lld",&x[j],&y[j],&z[j]);
            if (z[j]+r>=h){//判断这个点是否与顶面相交
                tot1++;
                f1[tot1]=j;
            }
            if (z[j]-r<=0){//判断这个点是否与底面相交
                tot2++;
                f2[tot2]=j;
            }
            for (int k=1;k<=j;k++){//枚举之前的洞是否与这个洞相交
            	if ((x[j]-x[k])*(x[j]-x[k])+(y[j]-y[k])*(y[j]-y[k])>4*r*r) continue;
            	//防止爆long long的特判。 
                if (dis(x[j],y[j],z[j],x[k],y[k],z[k])<=4*r*r){
                    int a1=find(j);
                    int a2=find(k);
                    if (a1!=a2) f[a1]=a2;
                }
            }
        }
        int s=0;
        //看看每一个中是否有洞连接上下面
        for (int j=1;j<=tot1;j++){
            for (int k=1;k<=tot2;k++){
                if (find(f1[j])==find(f2[k])){
                    s=1; 
                    break;
                }
            }
            if (s==1) break;
        }
        if (s==1) cout<<"Yes"<<endl;
        else cout<<"No"<<endl;
    }
    return 0;
}
```

---
处理用时：50.86秒
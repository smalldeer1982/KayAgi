# 题目信息

# 最大食物链计数

## 题目背景

你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。


## 题目描述

给你一个食物网，你要求出这个食物网中最大食物链的数量。

（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）

Delia 非常急，所以你只有 $1$ 秒的时间。

由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。


## 说明/提示

各测试点满足以下约定：

 ![](https://cdn.luogu.com.cn/upload/pic/12011.png) 

【补充说明】

数据中不会出现环，满足生物学的要求。（感谢 @AKEE ）


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 3
3 5
2 5
4 5
3 4```

### 输出

```
5```

# AI分析结果

# 算法分类：拓扑排序（其他搜索）

## 综合分析与结论
本题要求计算DAG中从生产者（入度为0）到顶级消费者（出度为0）的所有路径数量。核心难点在于高效统计路径数而不重复计算，解决方案主要采用拓扑排序的动态规划方法。

### 核心思路
1. **拓扑排序**：按节点入度顺序处理，确保每个节点在被处理时其所有前驱节点的路径数已计算完成。
2. **动态规划**：`f[i]`表示到节点i的路径数，初始时生产者`f[i]=1`，递推式为`f[v] += f[u]`（u→v）。
3. **结果统计**：累加所有顶级消费者（出度为0）的`f[i]`值。

### 可视化设计
- **动画方案**：逐步展示拓扑队列处理过程，高亮当前节点u和其邻接节点v，动态更新`f[v]`值。
- **颜色标记**：
  - 红色：当前处理的节点u
  - 绿色：正在更新的节点v
  - 蓝色：已处理完成的节点
- **控制面板**：支持暂停/继续/步进，调节动画速度，显示实时路径数。

## 题解清单 (≥4星)

### 1. 御·Dragon（5星）
- **亮点**：详细图解拓扑排序过程，清晰说明`f[i]`的递推逻辑，代码可读性强。
- **关键代码**：
```cpp
while(!q.empty()) {
    int tot = q.front(); q.pop();
    for(auto next : nei[tot]) {
        f[next] = (f[next] + f[tot]) % mod;
        if(--in[next] == 0) q.push(next);
    }
}
```

### 2. Watcher（4.5星）
- **亮点**：两种实现对比（邻接矩阵/邻接表），强调拓扑排序的正确性证明。
- **关键代码**：
```cpp
for(int k=h[a];k;k=d[k].n) {
    f[d[k].b] += f[a];
    if(--ru[d[k].b] == 0) q.push(d[k].b);
}
```

### 3. Y_BY（4星）
- **亮点**：DFS记忆化搜索的拓扑应用，逆向思维（从消费者倒推）。
- **关键代码**：
```cpp
int dfs(int x) {
    if(!out[x]) return 1;
    for(auto v : g[x]) 
        f[x] = (f[x] + dfs(v)) % mod;
    return f[x];
}
```

## 最优思路提炼
- **拓扑排序+DP**：最主流解法，时间复杂度O(n+m)。
- **记忆化搜索**：适合逆向思维，但需注意递归深度。
- **邻接表优化**：空间效率远高于邻接矩阵。

## 同类型题目推荐
1. P3183 [HAOI2016]食物链（同类拓扑计数）
2. P4017 最大食物链计数（数据加强版）
3. P1137 旅行计划（DAG最长路）

## 可视化实现要点
```javascript
// 伪代码：拓扑动画核心逻辑
function animateTopo() {
    let u = queue.dequeue();
    highlightNode(u, 'red');
    for (let v of adj[u]) {
        highlightEdge(u, v, 'yellow');
        f[v] += f[u];
        updateDisplay(v, f[v]);
        if (--inDegree[v] === 0) {
            queue.enqueue(v);
            highlightNode(v, 'green');
        }
        pauseAnimation(500);
    }
}
```

## 复古像素风格设计
- **调色板**：16色FC风格（深绿/品红/橙等）
- **节点绘制**：8×8像素方块，访问时闪烁
- **音效**：
  - 节点入队：短促"哔"声
  - 路径更新：上升音阶
  - 搜索完成：胜利音效

> **个人心得**：拓扑排序中队列处理顺序不影响结果正确性，但影响`f[i]`的计算顺序。邻接表比邻接矩阵更适合稀疏图。——摘自题解评论区

---
处理用时：33.45秒
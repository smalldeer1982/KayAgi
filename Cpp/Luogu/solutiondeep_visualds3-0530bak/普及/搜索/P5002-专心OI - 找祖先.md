# 题目信息

# 专心OI - 找祖先

## 题目背景

Imakf 是一个小蒟蒻，他最近刚学了 LCA，他在手机 APPstore 里看到一个游戏也叫做 LCA 就下载了下来。

## 题目描述

这个游戏会给出你一棵树，这棵树有 $N$ 个节点，根结点是 $R$，系统会选中 $M$ 个点 $P_1,P_2 \cdots P_M$，要Imakf 回答有多少组点对 $(u_i,v_i)$ 的最近公共祖先是 $P_i$。Imakf 是个小蒟蒻，他就算学了 LCA 也做不出，于是只好求助您了。



## 说明/提示

样例 1 的树如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/37971.png)

 对于询问 1 $~(1,1)
(1,2)
(1,3)
(1,4)
(1,5)
(1,6)
(1,7)
(2,1)
(2,3)
(2,6)
(2,7)
(3,1)
(3,2)
(3,4)
(3,5)
(4,1)
(4,3)$

$
(4,6)
(4,7)
(5,1)
(5,3)
(5,6)
(5,7)
(6,1)
(6,2)
(6,4)
(6,5)
(7,1)
(7,2)
(7,4)
(7,5)$ 共 $31$ 组点对。

询问 2 $(2,2)
(2,4)
(2,5)
(4,2)
(4,5)
(5,2)
(5,4)$ 共 $7$ 组点对。

对于询问 3 $(4,4)$ 共 $1$ 组点对。

$1\le R\le N\leq10000$，$0\le M\leq50000$。

## 样例 #1

### 输入

```
7 1 3
1 2
1 3
2 4
2 5
3 6
3 7
1 2 4```

### 输出

```
31
7
1```

# AI分析结果

### 唯一算法分类
DFS

### 综合分析与结论
本题的核心在于通过DFS预处理每个节点的子树大小，然后利用数学组合公式计算以每个节点为LCA的点对数量。主要难点在于如何高效计算不同子树之间的组合数，避免重复计算。

#### 核心思路
1. **DFS预处理**：通过一次DFS遍历，计算每个节点的子树大小（包括自身）。
2. **数学组合计算**：对于每个节点u，其作为LCA的点对数量包括：
   - 节点u与子树中任意节点的组合（包括自身）。
   - 不同子树之间的节点组合。
3. **优化计算**：利用公式 \( ans[u] = size[u]^2 - \sum_{v \in children(u)} size[v]^2 \) 来高效计算组合数，避免双重循环。

#### 可视化设计思路
- **节点遍历**：使用DFS动画展示如何从根节点出发，递归访问每个子节点并计算子树大小。
- **组合计算**：高亮当前节点u，展示如何从其子树的size值推导出ans[u]。
- **颜色标记**：已访问节点标记为绿色，当前节点标记为红色，未访问节点标记为灰色。

### 题解清单 (≥4星)
1. **llzzxx712 (5星)**
   - 使用邻接表存树，DFS预处理子树大小。
   - 利用数学公式优化组合计算，避免重复询问。
   - 代码清晰，注释详细。

2. **ZAGER (5星)**
   - 同样使用DFS预处理，但推导出更简洁的公式 \( ans = siz[x]^2 - \sum siz[son[i]]^2 \)。
   - 代码简洁高效，适合理解数学推导。

3. **0x3F (4星)**
   - 分情况讨论LCA的条件，清晰易懂。
   - 使用vector存图，代码可读性强。

### 代码粘贴与核心实现思想
#### 核心DFS实现
```cpp
void dfs(int u, int fa) {
    siz[u] = 1;
    int sum = 0;
    for (int v : G[u]) {
        if (v == fa) continue;
        dfs(v, u);
        siz[u] += siz[v];
        sum += siz[v] * siz[v];
    }
    ans[u] = siz[u] * siz[u] - sum;
}
```

#### 完整代码（ZAGER题解）
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#define N 10005
#define R register
using namespace std;
template<typename T>inline void read(T &a){
    char c=getchar();T x=0,f=1;
    while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
    a=f*x;
}
int n,rt,m,tot,p;
int siz[N],ans[N],h[N],sum[N];
struct node{
    int nex,to;
}edge[N<<1];
inline void add(R int u,R int v){
    edge[++tot].nex=h[u];
    edge[tot].to=v;
    h[u]=tot;
}
inline void dfs(R int x,R int f){
    siz[x]=1;
    for(R int i=h[x];i;i=edge[i].nex){
        R int xx=edge[i].to;
        if(xx==f)continue;
        dfs(xx,x);
        siz[x]+=siz[xx];
        sum[x]+=siz[xx]*siz[xx];
    }
    ans[x]=siz[x]*siz[x]-sum[x];
}
int main(){
    read(n);read(rt);read(m);
    for(R int i=1,u,v;i<=n-1;i++)
        read(u),read(v),add(u,v),add(v,u);
    dfs(rt,0);
    while(m--){
    	read(p);
    	printf("%d\n",ans[p]);
    }
    return 0;
}
```

### 可视化与算法演示
- **动画方案**：使用Canvas绘制树结构，DFS遍历时动态标记当前节点和已访问子树。
- **颜色标记**：当前节点红色，已访问子树绿色，未访问灰色。
- **步进控制**：允许暂停/继续，观察每一步的size计算和ans更新。
- **复古像素风格**：节点用8-bit像素方块表示，访问时播放“哔”音效。

### 推荐相似题目
1. P3379 【模板】最近公共祖先（LCA）
2. P1351 联合权值
3. P1395 会议

### 个人心得摘录
- **调试经历**：初始双重循环计算组合数导致TLE，优化为数学公式后AC。
- **顿悟感想**：树问题的核心常在于DFS预处理和数学组合优化。

---
处理用时：43.43秒
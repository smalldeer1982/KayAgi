# 题目信息

# [USACO05DEC] Scales S

## 题目描述

约翰有一架用来称牛的体重的天平。与之配套的是 $ N \ ( 1 \leq N \leq 1000 ) $ 个已知质量的砝码（所有砝码质量的数值都在 $32$ 位带符号整数范围内）。

每次称牛时，他都把某头奶牛安置在天平的某一边，然后往天平另一边加砝码，直到天平平衡，于是此时砝码的总质量就是牛的质量（约翰不能把砝码放到奶牛的那边，因为奶牛不喜欢称体重，每当约翰把砝码放到她的蹄子底下，她就会尝试把砝码踢到约翰脸上）。

天平能承受的物体的质量不是无限的，当天平某一边物体的质量大于 $ C \ ( 1 \leq C \leq 2^{30} ) $ 时，天平就会被损坏。砝码按照它们质量的大小被排成一行。并且，这一行中从第 $3$ 个砝码开始，每个砝码的质量至少等于前面两个砝码（也就是质量比它小的砝码中质量最大的两个）的质量的和。

约翰想知道，用他所拥有的这些砝码以及这架天平，能称出的质量最大是多少。由于天平的最大承重能力为 $C$，他不能把所有砝码都放到天平上。

现在约翰告诉你每个砝码的质量，以及天平能承受的最大质量，你的任务是选出一些砝码，使它们的质量和在不压坏天平的前提下是所有组合中最大的。

## 样例 #1

### 输入

```
3 15
1
10
20
```

### 输出

```
11```

# AI分析结果

### 唯一算法分类
**DFS**

### 综合分析与结论
这道题目要求在不超出天平承重限制的前提下，选择一些砝码使得它们的总质量最大。由于砝码的质量满足斐波那契数列的性质（从第三个砝码开始，每个砝码的质量至少等于前两个砝码质量的和），因此实际有效的砝码数量不会超过约47个（因为斐波那契数列增长非常快，很快会超过题目给定的C的上限2^30）。这使得我们可以使用深度优先搜索（DFS）来解决这个问题，而不必担心时间复杂度过高。

#### 核心难点与解决方案
1. **数据范围优化**：题目给出的N≤1000是误导性的，实际有效的N≤47，这使得DFS可行。
2. **剪枝策略**：
   - **前缀和剪枝**：维护一个前缀和数组，如果当前已选砝码的总质量加上剩余所有砝码的总质量仍小于等于C，则可以直接更新答案并返回。
   - **倒序搜索**：从最大的砝码开始搜索，可以更快地接近最优解，减少不必要的递归调用。
3. **终止条件**：当当前总质量超过C时，立即终止该分支的搜索。

#### 可视化设计思路
- **节点表示**：每个节点表示一个砝码的选择状态（选或不选）。
- **颜色标记**：
  - 绿色：当前正在访问的节点。
  - 红色：已超过C限制的分支。
  - 蓝色：已找到的当前最优解。
- **动画方案**：逐步展示DFS的递归过程，每次选择或不选择一个砝码，并更新当前总质量。当遇到剪枝条件时，高亮显示剪枝的分支。

### 题解清单 (≥4星)
1. **StudyingFather (5星)**
   - **亮点**：使用前缀和剪枝和倒序搜索，代码简洁高效。
   - **关键代码**：
     ```cpp
     void dfs(int cur, long long x) {
         if (x > c) return;
         if (sum[cur - 1] + x <= c) {
             ans = max(ans, sum[cur - 1] + x);
             return;
         }
         ans = max(ans, x);
         for (int i = 1; i < cur; i++)
             dfs(i, x + a[i]);
     }
     ```

2. **代码练习生 (4星)**
   - **亮点**：详细解释了剪枝策略和优化思路，代码可读性强。
   - **关键代码**：
     ```cpp
     void dfs(long long cur, int index) {
         if (cur + b[index] <= max) return;
         max = cur < max ? max : cur;
         if (index == 0) return;
         if (cur + fama[index] <= C)
             dfs(cur + fama[index], index - 1);
         dfs(cur, index - 1);
     }
     ```

3. **薛定谔的鱼 (4星)**
   - **亮点**：强调了斐波那契数列的性质，并提供了三种剪枝策略。
   - **关键代码**：
     ```cpp
     void dfs(int now, long long ma) {
         if (ma + b[now] <= ans) return;
         ans = max(ans, ma);
         for (int i = now; i; i--)
             if (ma + a[i] <= m)
                 dfs(i - 1, ma + a[i]);
     }
     ```

### 最优思路或技巧提炼
1. **前缀和剪枝**：利用前缀和数组快速判断剩余砝码的总质量是否能够满足条件，从而提前终止不必要的递归。
2. **倒序搜索**：从最大的砝码开始搜索，可以更快地接近最优解，减少递归深度。
3. **斐波那契性质**：利用砝码质量的斐波那契性质，将问题规模从N≤1000优化到N≤47，使得DFS可行。

### 同类型题或类似算法套路
- **子集和问题**：给定一个集合，找出其子集使得子集的和满足某种条件（如最大、等于某个值等）。
- **背包问题**：在容量限制下选择物品使得总价值最大。

### 推荐 3 道考察相似知识点的洛谷题目
1. **P1049 装箱问题**：在容量限制下选择物品使得剩余空间最小。
2. **P1466 集合 Subset Sums**：将一个集合分成两个子集，使得两个子集的和相等。
3. **P2392 kkksc03考前临时抱佛脚**：在时间限制下选择科目复习使得总时间最小。

### 个人心得摘录
- **调试经历**：在实现DFS时，剪枝条件的顺序非常重要。例如，应该先检查是否超过C，再检查前缀和剪枝，否则可能会导致错误的剪枝。
- **踩坑教训**：初始时没有注意到砝码质量的斐波那契性质，导致尝试使用背包算法，结果发现不可行。
- **顿悟感想**：通过分析题目条件，发现数据范围的实际限制，从而选择正确的算法。

### 可视化与算法演示
- **动画方案**：使用Canvas绘制砝码的选择过程，绿色表示当前选择的砝码，红色表示超过限制的分支，蓝色表示当前最优解。
- **步进控制**：允许用户单步执行，观察每一步的选择和剪枝过程。
- **音效提示**：当找到更优解时播放上扬音效，当超过限制时播放失败音效。

### 复古游戏化动画效果（可选）
- **8位像素风格**：使用简单的16色调色板绘制砝码和天平。
- **音效**：访问新节点时播放像素音效，找到最优解时播放通关音效。
- **关卡设计**：将每个砝码的选择作为一个关卡，逐步增加难度。

### 代码粘贴与核心实现思想
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
long long sum[1005], a[1005], ans, n, c;
void dfs(int cur, long long x) {
    if (x > c) return;
    if (sum[cur - 1] + x <= c) {
        ans = max(ans, sum[cur - 1] + x);
        return;
    }
    ans = max(ans, x);
    for (int i = 1; i < cur; i++)
        dfs(i, x + a[i]);
}
int main() {
    cin >> n >> c;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        sum[i] = sum[i - 1] + a[i];
    }
    dfs(n + 1, 0);
    cout << ans << endl;
    return 0;
}
```

### 可视化设计要点
- **颜色方案**：绿色（当前节点）、红色（超过限制）、蓝色（最优解）。
- **Canvas初始化**：绘制天平和砝码的网格布局。
- **音效触发**：当选择砝码时播放选择音效，当剪枝时播放剪枝音效。

---
处理用时：52.23秒
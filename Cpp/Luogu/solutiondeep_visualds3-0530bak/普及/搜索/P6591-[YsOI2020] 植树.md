# 题目信息

# [YsOI2020] 植树

## 题目背景


Ysuperman 响应号召，决定在幼儿园里植树。

## 题目描述

Ysuperman 有一棵 $n$ 个节点的无根树 $T$。如果你不知道树是什么，TA 很乐意告诉你，树是一个没有环的无向联通图。

既然树是无根的，那就没有办法种植。Ysuperman 研究了很久的园艺，发现一个节点如果可以成为根，它必须十分平衡，这意味着以它为根时，与它**直接相连的节点，他们的子树大小都相同**。

你作为幼儿园信息组一把手，Ysuperman 给你一棵树，你能在 $1s$ 内找到所有可能成为根的节点吗？

## 说明/提示

### 样例说明

#### 样例说明 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/gsiug69y.png)

以 $1$ 为根时，与 $1$ 直接相连的点有 $\{2\}$，因为只有一个所以大小全部相同。

以 $2$ 为根时，与 $2$ 直接相连的点有 $\{1\}$，因为只有一个所以大小全部相同。

所以答案为 $1,2$。

#### 样例说明 $2$

![](https://cdn.luogu.com.cn/upload/image_hosting/p7fsretv.png)

以 $1$ 为根时，与 $1$ 直接相连的点有 $\{2\}$，因为只有一个所以大小全部相同。

以 $2$ 为根时，与 $2$ 直接相连的点有 $\{1,3\}$，子树大小分别为 $\{1,2\}$，不相同。

以 $3$ 为根时，与 $3$ 直接相连的点有 $\{2,4\}$，子树大小分别为 $\{2,1\}$，不相同。

以 $4$ 为根时，与 $4$ 直接相连的点有 $\{3\}$，因为只有一个所以大小全部相同。

所以答案为 $1,4$。

----

### 数据范围

**本题采用捆绑测试。**

| $\rm{subtask}$ | $n$ |  分数|
| :-----------: | :-----------: | :----: |
| $1$ | $\le 5000$ | $40$ |
| $2$ | $\le 10^6$ | $60$ |

对于 $100\%$ 的数据，满足 $1 \le n\le 10^6$。

------

### 提示

由于输入输出量较大，你可能需要快速输入/输出。

## 样例 #1

### 输入

```
2
1 2
```

### 输出

```
1 2 ```

## 样例 #2

### 输入

```
4
1 2
2 3
3 4
```

### 输出

```
1 4 
```

## 样例 #3

### 输入

```
9
1 2
1 3
4 1
5 1
1 6
1 9
8 1
1 7
```

### 输出

```
1 2 3 4 5 6 7 8 9 
```

# AI分析结果

### 唯一算法分类
DFS

### 综合分析与结论
这道题的核心在于如何高效地判断每个节点作为根时，其直接相连的子树的子树大小是否相同。由于数据规模较大（n ≤ 1e6），必须采用线性或近似线性的算法。

#### 核心思路：
1. **子树大小计算**：通过一次DFS遍历，以任意节点（如1号节点）为根，计算每个节点的子树大小（包含自身）。
2. **平衡性判断**：对于每个节点，检查其所有直接相连的节点的子树大小是否相同。需要注意：
   - 对于非根节点，除了子节点的子树大小，还需考虑父节点方向的子树大小（即总节点数减去当前节点的子树大小）。
   - 叶子节点（度为1的节点）天然满足条件，因为只有一个子树。

#### 难点与解决方案：
- **高效判断平衡性**：在DFS过程中，动态记录和比较子树大小，避免重复计算。
- **处理父节点方向的子树**：通过总节点数减去当前子树大小，得到父节点方向的子树大小，并与子节点的子树大小比较。

#### 可视化设计思路：
1. **动画方案**：
   - **初始状态**：展示树的结构，以1号节点为根，标记所有节点的子树大小。
   - **平衡性检查**：对于每个节点，高亮其直接相连的节点，并显示它们的子树大小。如果所有子树大小相同，标记该节点为合法根。
   - **步进控制**：允许用户单步执行，观察每个节点的判断过程。
2. **颜色标记**：
   - 当前节点：红色
   - 直接相连的节点：蓝色
   - 合法根节点：绿色
3. **交互功能**：
   - 暂停/继续：控制动画播放。
   - 速度调节：调整动画播放速度。
   - 单步执行：逐步观察每个节点的判断过程。

### 题解清单 (≥4星)
1. **WanderingTrader (5星)**
   - **亮点**：清晰的思路，高效的DFS实现，详细解释了子树大小的计算和平衡性判断。
   - **代码可读性**：良好，使用了邻接表和简洁的DFS函数。
   - **优化程度**：线性时间复杂度，适合大规模数据。

2. **Imakf (4星)**
   - **亮点**：提供了两种解法，包括重心判断法，思路新颖。
   - **代码可读性**：较好，但重心判断部分略显复杂。
   - **优化程度**：线性时间复杂度，重心判断法增加了算法的多样性。

3. **____OccDreamer (4星)**
   - **亮点**：详细解释了子树大小的动态更新和平衡性判断，代码结构清晰。
   - **代码可读性**：良好，使用了链式前向星和DFS。
   - **优化程度**：线性时间复杂度，适合大规模数据。

### 最优思路或技巧提炼
1. **子树大小计算**：通过一次DFS遍历，计算每个节点的子树大小，这是后续判断的基础。
2. **动态平衡性判断**：在DFS过程中，实时比较子树大小，避免重复计算。
3. **处理父节点方向的子树**：通过总节点数减去当前子树大小，得到父节点方向的子树大小，这是非根节点判断的关键。
4. **叶子节点优化**：叶子节点天然满足条件，可以直接标记为合法根，减少不必要的计算。

### 同类型题或类似算法套路
1. **子树统计**：如计算每个节点的子树和、子树最大值等。
2. **树的直径**：通过两次DFS或BFS计算树的直径。
3. **树的重心**：通过DFS计算子树大小，找到重心。

### 推荐 3 道考察相似知识点的洛谷题目
1. **P1352 没有上司的舞会**：树形DP，涉及子树统计。
2. **P3379 【模板】最近公共祖先（LCA）**：树的遍历和子树处理。
3. **P1040 加分二叉树**：树的结构和子树统计。

### 个人心得摘录
- **调试经历**：在实现DFS时，容易忽略父节点方向的子树大小，导致判断错误。需要特别注意非根节点的处理。
- **踩坑教训**：叶子节点的处理需要单独考虑，否则会漏解。
- **顿悟感想**：通过一次DFS遍历，可以高效解决子树大小和平衡性判断的问题，体现了树形结构的优美性。

### 可视化与算法演示
#### 动画方案：
1. **初始状态**：展示树的结构，以1号节点为根，标记所有节点的子树大小。
2. **平衡性检查**：
   - 高亮当前节点（红色）。
   - 高亮其直接相连的节点（蓝色），并显示它们的子树大小。
   - 如果所有子树大小相同，标记该节点为合法根（绿色）。
3. **步进控制**：
   - 用户可以通过按钮控制动画的播放、暂停、单步执行。
   - 可以调节动画速度，方便观察细节。

#### 复古游戏化动画效果：
- **8位像素风格**：使用简单的16色调色板，节点用像素方块表示，边用像素线条连接。
- **音效提示**：
  - 访问新节点时播放轻微的“滴”声。
  - 找到合法根时播放上扬音调。
  - 背景音乐为8位风格的循环音乐。
- **自动演示模式**：算法自动运行，展示DFS遍历和平衡性判断的过程。

### 代码粘贴与核心实现思想
#### 核心代码片段（WanderingTrader的DFS实现）：
```cpp
int dfs(int x, int fa) {
    int size = es[x].size(), num = 0;
    root[x] = 1;
    for (int i = 0; i < size; i++) {
        if (es[x][i] != fa) {
            d[x] += dfs(es[x][i], x);
            if (!num) num = d[es[x][i]];
            if (num != d[es[x][i]]) root[x] = 0;
        }
    }
    d[x]++;
    if (x != 1 && num && num != n - d[x]) root[x] = 0;
    return d[x];
}
```
#### 完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 1000005
#define _for(x,y) for(int i = x;i <= y;i ++)
vector <int> es[N];
bool root[N];
int d[N], n;
int dfs(int x, int fa) {
    int size = es[x].size(), num = 0;
    root[x] = 1;
    for (int i = 0; i < size; i++) {
        if (es[x][i] != fa) {
            d[x] += dfs(es[x][i], x);
            if (!num) num = d[es[x][i]];
            if (num != d[es[x][i]]) root[x] = 0;
        }
    }
    d[x]++;
    if (x != 1 && num && num != n - d[x]) root[x] = 0;
    return d[x];
}
int main() {
    scanf("%d", &n);
    int u, v;
    _for(1, n - 1) {
        scanf("%d%d", &u, &v);
        es[u].push_back(v);
        es[v].push_back(u);
    }
    dfs(1, 0);
    _for(1, n)
        if (root[i])
            printf("%d ", i);
    return 0;
}
```

#### 可视化关键代码（JavaScript）：
```javascript
// 初始化Canvas
const canvas = document.getElementById('treeCanvas');
const ctx = canvas.getContext('2d');
const nodes = []; // 存储节点信息
const edges = []; // 存储边信息

// 绘制树
function drawTree() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 绘制边
    edges.forEach(edge => {
        ctx.beginPath();
        ctx.moveTo(edge.from.x, edge.from.y);
        ctx.lineTo(edge.to.x, edge.to.y);
        ctx.stroke();
    });
    // 绘制节点
    nodes.forEach(node => {
        ctx.beginPath();
        ctx.arc(node.x, node.y, 10, 0, 2 * Math.PI);
        ctx.fillStyle = node.color;
        ctx.fill();
        ctx.fillText(node.size, node.x, node.y - 15);
    });
}

// 动画步骤
function animateStep() {
    // 高亮当前节点
    // 检查平衡性
    // 更新节点颜色
    drawTree();
}
```

### 复古游戏化动画效果实现
1. **颜色方案**：使用16色调色板，节点用8位风格的像素方块表示。
2. **音效**：使用Web Audio API，在访问节点和找到合法根时触发音效。
3. **自动演示**：设置定时器，自动执行动画步骤，模拟DFS遍历过程。

### 总结
这道题通过一次DFS遍历，高效地计算了子树大小并判断了平衡性，适合大规模数据。可视化设计可以帮助理解算法的执行过程，复古游戏化效果增加了趣味性。核心思路和技巧可以应用于其他树形结构的问题。

---
处理用时：66.19秒
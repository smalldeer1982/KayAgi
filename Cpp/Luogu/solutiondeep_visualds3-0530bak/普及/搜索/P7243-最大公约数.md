# 题目信息

# 最大公约数

## 题目背景

&emsp;&emsp;“寻求最大公约数是人民民主的真谛。……”

&emsp;&emsp;初秋，从枝丫滴下的阳光，柔和，在教室的窗棱溅起，润湿晨读的少女的脸颊。

&emsp;&emsp;“阿绫，阿绫”，天依低俯身子，八字辫耷拉在竖起的课本沿，“我们的最大公约数是多少呢？”

&emsp;&emsp;“一定不小吧”，左手悄悄捏捏天依的小臂，“比如呀，有一个公因子，叫做‘你喜欢我，我也喜欢你’。”

## 题目描述

相反，人际圈形形色色，公约数小得可怜，似乎很难保持自己的个性因而变成无趣的人呢。

现在把人际抽象成一个 $n \times m$ 的矩形，每个人初始的个性为 $a_{i,j}$。从第二天开始，每个人会与上下左右四个人（如果存在）建立人际关系，其个性变为昨天自己和四周人个性的最大公约数。那么对于第 $x$ 行第 $y$ 列的人，在多少天后他的个性会变为 $1$ 呢？

----

#### 简化题意

有一个 $n \times m$ 的矩阵 $a$。对一个矩阵进行变换，定义为将这个矩阵内的所有元素变为其上下左右四个元素（不存在则忽略）及自身的最大公约数。询问 $a_{x,y}$ 在进行最少多少次变换之后会变成 $1$。如果可以使 $a_{x,y}$ 经过若干次变换变成 $1$，输出其中最小的次数；否则输出 $-1$。

## 说明/提示

#### 样例解释 3
第一天的个性矩阵（也就是最开始的矩阵）为
$$
\begin{pmatrix}
3&2&3\\
2&3&2\\
3&2&3
\end{pmatrix}
$$
第二天的个性矩阵为
$$
\begin{pmatrix}
1&1&1\\
1&1&1\\
1&1&1
\end{pmatrix}
$$
可见只需要经过一天，$a_{2,2}$ 就会变为 $1$，所以答案为 $1$。

#### 数据规模与约定
**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^3$，$1\le a_{i,j}\le 10^{18}$，$1\le x\le n$，$1\le y\le m$。

| 子任务 | 分值 |        $n,m$        |              特殊限制              |
| :----: | :--: | :-----------------: | :--------------------------------: |
|   1    |  1   |          /          | 保证给出的位置个性永远不会变为 $1$ |
|   2    |  1   |          /          |          保证 $a_{x,y}=1$          |
|   3    |  3   |      $ \le 2$       |                 /                  |
|   4    |  10  |     $ \le 10^2$     |                 /                  |
|   5    |  30  | $ \le 5\times 10^2$ |           /            |
|   6    |  10  |          /          |   保证对于所有的 $a_{i,j} \le 2$   |
|   7    |  10  |          /          |     保证 $x$ 与 $y$ 都等于 $1$     |
|   8    |  35  |          /          |                 /                  |





------------




## 样例 #1

### 输入

```
2 2
2 2
1 2
2 1```

### 输出

```
0```

## 样例 #2

### 输入

```
2 2
2 2 
2 2
1 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
3 3
3 2 3
2 3 2
3 2 3
2 2```

### 输出

```
1```

# AI分析结果

# 最大公约数 - 题解分析

## 算法分类
**BFS** (广度优先搜索)

## 综合分析与结论

### 题目核心
题目要求计算矩阵中某个位置(x,y)经过多少次变换后值变为1，每次变换将每个元素变为自身及相邻四个元素的最大公约数。

### 关键思路
1. **数学性质**：gcd操作具有结合律，多次gcd操作等价于所有参与数的gcd
2. **扩散过程**：每次变换相当于将影响范围向外扩展一圈，类似BFS的层级扩展
3. **终止条件**：当累积的gcd变为1时即可停止

### 解决难点
1. 如何高效计算扩散过程中的gcd
2. 如何避免重复计算
3. 如何确定无解情况

### 可视化设计思路
1. **动画方案**：以(x,y)为中心向外扩散，用不同颜色标记已访问和待访问节点
2. **颜色标记**：
   - 红色：当前处理节点
   - 绿色：已访问节点
   - 蓝色：待访问节点
3. **步进控制**：可单步执行观察每轮扩散过程
4. **游戏化效果**：
   - 8位像素风格网格
   - 扩散时播放轻微音效
   - 找到解时播放胜利音效

## 题解清单 (≥4星)

### 1. vectorwyx (5星)
**亮点**：
- 清晰解释了gcd的数学性质
- 使用标准BFS框架
- 代码简洁高效

### 2. _zy_ (4星) 
**亮点**：
- 详细解释了BFS的扩散过程
- 提供了完整的代码实现
- 包含无解情况的处理

### 3. Just_A_King (4星)
**亮点**：
- 引入曼哈顿距离概念
- 分析了时间复杂度
- 代码结构清晰

## 核心代码实现

```cpp
// BFS核心代码
void bfs(){
    queue<int> qx,qy,qs;
    qx.push(sx),qy.push(sy),qs.push(0);
    vis[sx][sy] = 1;
    ll sum = a[sx][sy];
    
    while(!qx.empty()){
        int x = qx.front(), y = qy.front(), s = qs.front();
        qx.pop(), qy.pop(), qs.pop();
        
        for(int i=0; i<4; i++){
            int tx = x+dx[i], ty = y+dy[i];
            if(tx<1 || tx>n || ty<1 || ty>m || vis[tx][ty]) continue;
            
            vis[tx][ty] = 1;
            qx.push(tx), qy.push(ty), qs.push(s+1);
            sum = __gcd(sum, a[tx][ty]);
            
            if(sum == 1){
                cout << s+1;
                return;
            }
        }
    }
    cout << -1;
}
```

## 最优思路提炼
1. **BFS扩散**：从目标点开始层级扩展，计算累积gcd
2. **及时终止**：当gcd变为1时立即返回当前步数
3. **预处理检查**：先检查初始值是否为1或全局gcd是否为1

## 同类型题目
1. P1443 马的遍历 (BFS扩展)
2. P1162 填涂颜色 (BFS应用)
3. P1135 奇怪的电梯 (BFS求最少步数)

## 个人心得摘录
"嵌套形式的gcd的值等于原式中出现的数的gcd，因为gcd(a,b)实际上是对a和b中每个质因数的指数取min" - vectorwyx

## 可视化实现要点
```javascript
// 伪代码 - 可视化核心
class GCDVisualizer {
    constructor(matrix, startX, startY) {
        this.grid = new PixelGrid(matrix); // 8位风格网格
        this.sound = new SoundManager();  // 音效管理
        this.queue = [[startX, startY]];  // BFS队列
        this.visited = new Set();        // 已访问集合
        this.currentGCD = matrix[startY][startX];
    }
    
    step() {
        if(this.queue.length === 0) return false;
        
        const [x, y] = this.queue.shift();
        this.grid.highlightCell(x, y, 'red'); // 高亮当前单元格
        this.sound.play('visit');
        
        // 处理相邻单元格
        for(const [dx, dy] of directions) {
            const nx = x + dx, ny = y + dy;
            if(/* 边界检查 */ && !this.visited.has(`${nx},${ny}`)) {
                this.queue.push([nx, ny]);
                this.visited.add(`${nx},${ny}`);
                this.currentGCD = gcd(this.currentGCD, this.grid.getValue(nx, ny));
                this.grid.highlightCell(nx, ny, 'blue');
                
                if(this.currentGCD === 1) {
                    this.sound.play('success');
                    return true; // 找到解
                }
            }
        }
        return false;
    }
}
```

---
处理用时：42.55秒
# 题目信息

# [PA 2020] Wycieczka górska

## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 4 [Wycieczka górska](https://sio2.mimuw.edu.pl/c/pa-2020-1/wyc/)**

一群 $k$ 个旅行者朋友去了 Byte 山。在最后一天，他们决定组织一场登山比赛，从他们所住的旅店到 Byte 山顶。

每个旅行者都有一张区域地图，它是一个分为 $n$ 行 $m$ 列的矩形；因此地图一共包含 $n\cdot m$ 个区域。旅店位于地图左上角的区域，而山顶则位于地图右下角的区域。Byte 山以其非常均匀而闻名——对于地图上的任何区域，在地图上与之相邻的右面或下面的区域海拔较高，而相邻的左边或上面区域海拔较低。但是，这座山也因潜伏着许多危险地区而闻名。有些地区在地图上标明是非常危险的，因为那里有野生动物居住——所以最好不要到那里去……

你是 Byte 山山脚下的一个小屋的看守人。通过观察每一个旅行者，你已经为他们每个人分配了两个参数 $a_i$ 和 $b_i$，这些参数决定了他们在山坡上的运动速度。具体来说，如果第 $i$ 个旅行者向更高的区域移动，那么他需要 $a_i$ 分钟，如果旅行者向更低的区域移动，则需要 $b_i$ 分钟。你也知道，每个旅行者都会走对他们来说从小屋到山顶最快的路线，并且路线完全在地形图上，而且避开了所有的危险区域。

你想知道最快的人需要多长时间才能到达山顶，有多少人将与最快的人同时爬到山顶。你可以假设，从小屋到山顶至少有一条安全的路线。

## 说明/提示

#### 样例 2 解释

从旅店到山顶只有一条路径，这些旅行者的用时分别是 $13,14,13,13$。

------------

#### 数据范围

**本题采用捆绑测试**

对于一些子任务满足 $k=1$。

对于 $100\%$ 的数据，保证 $2\le n,m\le 2\times 10^3$，$1\le k\le 10^6$，$1\le a_i,b_i\le 10^9$。

## 样例 #1

### 输入

```
5 7 1
......X
X.X..X.
..X.X.X
.X.X...
.....X.
2 1```

### 输出

```
26 1```

## 样例 #2

### 输入

```
2 5 4
.X...
...X.
2 1
2 2
1 7
2 1```

### 输出

```
13 3```

# AI分析结果

# 算法分类：BFS

## 综合分析与结论

这道题目看似复杂，但实际上是一个经典的BFS最短路径问题。核心观察点是：所有旅行者都会选择相同的路径（最短路径），因为任何绕路都会导致总时间增加。因此只需要计算一次最短路径，然后根据每个人的速度参数计算时间即可。

关键难点在于：
1. 理解"上山"和"下山"的步数关系：每下山一次必须上山一次补回来
2. 计算最短路径中的上下山步数
3. 高效处理大规模输入(k可达1e6)

解决方案：
1. 使用BFS找到从起点到终点的最短路径
2. 在BFS过程中记录上下山的步数
3. 根据每个人的速度参数计算最小时间

## 最优思路提炼

1. **路径唯一性**：所有人都会选择相同的路径，因为这是时间最优的路径
2. **步数关系**：总步数 = (n+m-2) + 2*额外步数，其中额外步数是上下山次数
3. **BFS优化**：使用双端队列(deque)实现0-1 BFS，上下山步数为0的放队首，为1的放队尾

## 题解评分(≥4星)

1. **作者：_•́へ•́╬_** (5星)
   - 思路清晰，直接指出路径唯一性
   - 使用双端队列优化BFS
   - 代码简洁高效

2. **作者：CSPAK_Zhangxiuqi0011** (4星)
   - 详细解释了路径选择的数学原理
   - 提供了清晰的图示说明
   - 代码可读性好

3. **作者：A_small_WA** (4星) 
   - 讨论了路径选择的数学证明
   - 代码结构清晰
   - 解释了步数计算的关键点

## 核心代码实现

```cpp
// 双端队列BFS实现
deque<node> q;
ans[0][0] = 0;
q.emplace_back(0,0,0);
for(node i(0,0,0); q.size();) {
    i = q.front(); q.pop_front();
    if(ans[i.x][i.y] ^ i.a) continue;
    // 向上/左走(步数+1)
    if(i.x && s[i.x-1][i.y] && ans[i.x-1][i.y] > i.a+1)
        q.emplace_back(i.x-1,i.y,ans[i.x-1][i.y]=i.a+1);
    // 向下/右走(步数不变)
    if(i.x<n-1 && s[i.x+1][i.y] && ans[i.x+1][i.y] > i.a)
        q.emplace_front(i.x+1,i.y,ans[i.x+1][i.y]=i.a);
}
```

## 可视化设计

1. **搜索过程动画**：
   - 使用网格表示地图
   - 当前访问节点高亮显示
   - 已访问节点标记为绿色
   - 队列中的节点标记为黄色

2. **复古游戏风格**：
   - 8-bit像素风格界面
   - 节点扩展时播放"滴"声
   - 找到路径时播放胜利音效
   - 背景使用低分辨率山地图案

3. **交互控制**：
   - 速度调节滑块
   - 单步执行按钮
   - 路径高亮显示

## 同类型题目推荐

1. P1443 马的遍历 - BFS基础应用
2. P1162 填涂颜色 - BFS连通块问题 
3. P1141 01迷宫 - BFS记忆化搜索

## 个人心得

这道题的关键在于认识到路径的唯一性。最初可能会被每个人的不同速度参数迷惑，以为需要为每个人单独计算。但实际上最短路径对所有人都是最优的，这是一个重要的观察点。在实现BFS时，使用双端队列可以优化性能，特别是对于这种0-1权重的图。

---
处理用时：33.50秒
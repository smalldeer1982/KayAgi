# 题目信息

# [蓝桥杯 2023 省 B] 岛屿个数

## 题目描述

小蓝得到了一副大小为 $M \times N$ 的格子地图，可以将其视作一个只包含字符 `0`（代表海水）和 `1`（代表陆地）的二维数组，地图之外可以视作全部是海水，每个岛屿由在上/下/左/右四个方向上相邻的 `1` 相连接而形成。

在岛屿 $A$ 所占据的格子中，如果可以从中选出 $k$ 个不同的格子，使得他们的坐标能够组成一个这样的排列：$\left(x_{0},y_{0}\right),\left(x_{1},y_{1}\right),\ldots,\left(x_{k-1},y_{k-1}\right)$，其中 $\left(x_{(i+1) \bmod k},y_{(i+1) \bmod k}\right)$ 是由 $\left(x_{i},y_{i}\right)$ 通过上/下/左/右移动一次得来的（$0 \leq i \leq k-1$），此时这 $k$ 个格子就构成了一个「环」。如果另一个岛屿 $B$ 所占据的格子全部位于这个「环」内部，此时我们将岛屿 $B$ 视作是岛屿 $A$ 的子岛屿。若 $B$ 是 $A$ 的子岛屿，$C$ 又是 $B$ 的子岛屿，那 $C$ 也是 $A$ 的子岛屿。

请问这个地图上共有多少个岛屿？在进行统计时不需要统计子岛屿的数目。

## 说明/提示

**【样例说明】**

对于第一组数据，包含两个岛屿，下面用不同的数字进行了区分：
```
01111
11001
10201
10001
11111
```
岛屿 2 在岛屿 1 的「环」内部，所以岛屿 2 是岛屿 1 的子岛屿，答案为 $1$。

对于第二组数据，包含三个岛屿，下面用不同的数字进行了区分：
```
111111
100001
020301
100001
111111
```
注意岛屿 3 并不是岛屿 1 或者岛屿 2 的子岛屿，因为岛屿 1 和岛屿 2 中均没有「环」。

**【评测用例规模与约定】**

对于 $30 \%$ 的评测用例，$1 \leq M,N \leq 10$。

对于 $100 \%$ 的评测用例，$1 \leq T \leq 10$，$1 \leq M,N \leq 50$ 。  

蓝桥杯 2023 省赛 B 组 F 题。

## 样例 #1

### 输入

```
2
5 5
01111
11001
10101
10001
11111
5 6
111111
100001
010101
100001
111111
```

### 输出

```
1
3```

# AI分析结果



## 唯一算法分类
图的遍历与连通块分析

## 综合分析与结论
### 核心思路
所有题解均通过两次搜索解决：第一次处理海水（外海连通性），第二次处理陆地（岛屿连通性）。核心在于**逆向思维**：不直接检测环结构，而是判断岛屿能否连通外海。能连通外海的岛屿即为非子岛屿。

### 解决难点
1. **环结构检测复杂度**：传统环检测需要计算几何或拓扑排序，但题解通过外海连通性巧妙规避
2. **方向差异处理**：海水使用八方向（模拟真实水流渗透），陆地使用四方向（遵循题目岛屿定义）
3. **边界处理**：通过扩展地图边界或预处理外海起点，避免特判全包围情况

### 可视化设计
- **颜色标记**：
  - 海水扩散：蓝色渐变动画（八方向扩展）
  - 主岛屿标记：绿色填充（四方向蔓延）
  - 子岛屿：红色半透明（未触达区域）
- **动画步骤**：
  1. 初始化地图后，从外海起点开始八方向扩散
  2. 每次海水触碰陆地时，触发四方向岛屿标记
  3. 统计标记完成的岛屿数量时展示得分动画
- **交互功能**：
  - 单步/连续执行模式切换
  - 速度调节滑块（0.5x-3x）
  - 网格坐标高亮显示当前操作点

## 题解清单（≥4星）
1. **Qianmo_su（5星）**
   - 亮点：扩展地图边界简化外海处理，代码结构清晰
   - 核心代码：
     ```cpp
     void bfs2() { // 从(0,0)开始八方向海水扩散
         queue<PII> q;
         q.push({0,0});
         vis[0][0] = true;
         while(!q.empty()) {
             auto t = q.front();
             q.pop();
             for(int i=0;i<8;i++) { // 八方向扩散
                 int rx = t.first+dx2[i], ry = t.second+dy2[i];
                 if(rx>=0 && rx<=n+1 && ry>=0 && ry<=m+1) {
                     if(g[rx][ry] == '1') bfs1(rx,ry); // 发现陆地则标记
                     else if(!vis[rx][ry]) {
                         vis[rx][ry] = true;
                         q.push({rx,ry});
                     }
                 }
             }
         }
     }
     ```

2. **brofea5（4.5星）**
   - 亮点：预标记外海连通块，判断逻辑简洁
   - 优化点：使用二维数组直接存储状态，减少判断次数

3. **ZhaoV1（4星）**
   - 亮点：边缘触发机制直观易懂
   - 注意点：需特判全包围情况，代码稍显冗余

## 最优技巧提炼
1. **边界扩展法**：将地图扩大一圈虚拟海水，统一处理边界条件
2. **双方向搜索**：
   - 海水搜索（八方向）→ 确保渗透所有可能路径
   - 陆地搜索（四方向）→ 严格遵循岛屿定义
3. **状态压缩存储**：使用二维数组同时记录海水扩散和岛屿标记状态

## 同类题目推荐
1. **P1162 填涂颜色** - 类似的外海标记思路
2. **P2893 [USACO08FEB] Making the Grade G** - 连通性分析变形
3. **P3395 道路阻断** - 逆向思维处理连通性问题

## 核心代码实现
```cpp
// Qianmo_su题解核心逻辑
void bfs1(int x,int y) { // 陆地四方向标记
    ans++;
    queue<PII> q;
    q.push({x,y});
    vis[x][y] = true;
    while(!q.empty()) {
        auto t = q.front(); q.pop();
        for(int i=0;i<4;i++) { // 四方向
            int rx = t.first+dx1[i], ry = t.second+dy1[i];
            if(rx>=1 && rx<=n && ry>=1 && ry<=m 
              && !vis[rx][ry] && g[rx][ry] == '1') {
                vis[rx][ry] = true;
                q.push({rx,ry});
            }
        }
    }
}

void bfs2() { // 海水八方向扩散
    queue<PII> q;
    q.push({0,0});
    vis[0][0] = true;
    while(!q.empty()) {
        auto t = q.front(); q.pop();
        for(int i=0;i<8;i++) { // 八方向
            int rx = t.first+dx2[i], ry = t.second+dy2[i];
            if(rx>=0 && rx<=n+1 && ry>=0 && ry<=m+1 && !vis[rx][ry]) {
                if(g[rx][ry] == '1') bfs1(rx,ry);
                else {
                    vis[rx][ry] = true;
                    q.push({rx,ry});
                }
            }
        }
    }
}
```

## 可视化方案设计
### 像素风格实现
1. **Canvas初始化**：
   ```javascript
   const CELL_SIZE = 12; // 12px方格
   const COLORS = {
     SEA: '#2E86C1',    // 海水蓝
     LAND: '#27AE60',   // 陆地绿 
     OUTER: '#3498DB',  // 外海深蓝
     ACTIVE: '#F1C40F'  // 当前操作黄
   };
   ```

2. **动画帧处理**：
   ```javascript
   function drawStep() {
     ctx.clearRect(0, 0, canvas.width, canvas.height);
     // 绘制地图底色
     for(let i=0; i<=n+1; i++) {
       for(let j=0; j<=m+1; j++) {
         let color = COLORS.SEA;
         if(g[i][j] === '1') color = COLORS.LAND;
         if(vis[i][j]) color = COLORS.OUTER;
         // 绘制像素方格...
       }
     }
     // 高亮当前操作点
     if(currentPos) {
       ctx.fillStyle = COLORS.ACTIVE;
       ctx.fillRect(currentPos.y*CELL_SIZE, currentPos.x*CELL_SIZE, 
                    CELL_SIZE, CELL_SIZE);
     }
   }
   ```

3. **音效系统**：
   ```javascript
   const audio = {
     sea: new Audio('data:audio/wav;base64,UklGRl...'), // 海水扩散音效
     land: new Audio('data:audio/wav;base64,UklGRl...'), // 陆地标记音
     score: new Audio('data:audio/wav;base64,UklGRl...') // 得分音
   };
   ```

### 自动演示模式
```javascript
let autoPlay = setInterval(() => {
  if(!nextStep()) clearInterval(autoPlay); 
}, 200); // 200ms/步
```

该可视化方案通过清晰的色彩区分和步进控制，直观展示海水渗透与岛屿标记过程，配合8-bit音效增强反馈，适合算法教学演示。

---
处理用时：94.32秒
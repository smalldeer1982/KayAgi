# 题目信息

# [信息与未来 2019] 新斐波那契数列

## 题目描述

给定正整数 $a(a\ge1)$，新斐波那契数列 $f_a$ 按如下方式定义：
- $f_a(1) = 1$；
- $f_a(2) = a$；
- $f_a(n) = f_a(n − 1) + f_a(n − 2)\ (n > 2)$。

例如，给定 $a = 4$，有 $f_4(1) = 1, f_4(2) = 4, f_4(3) = 5, f_4(4) = 9, f_4(5) = 14, \cdots$ 现在已知新斐波那契数列中的一项 $x$，但并不知道 $n$ 和 $a$ 的值是多少。请你求出所有可能的 $n,a(n\ge2)$ 满足 $f_a(n) = x$。

## 说明/提示

对于 $60\%$ 的测试数据，有 $1\le x\le10^6$。

对于 $100\%$ 的测试数据，有 $2\le x\le10^9,1\le T\le20$。
> 本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
2
9
123```

### 输出

```
2 9
3 8
4 4
2 123
3 122
4 61
6 24
10 3```

# AI分析结果



**算法分类**：数论

---

### **题解思路与解决难点**
本题要求找出所有可能的正整数对 $(n, a)$，使得新斐波那契数列的第 $n$ 项等于给定的 $x$。核心思路是利用斐波那契数列的数学性质，推导出通项表达式并逆向求解。

#### **关键公式推导**
新斐波那契数列的通项公式为：
$$
f_a(n) = F(n-1) \cdot a + F(n-2)
$$
其中 $F(k)$ 是标准斐波那契数列（$F(1)=1, F(2)=1, F(3)=2, \dots$）。对于给定的 $x$，需要满足：
$$
F(n-1) \cdot a + F(n-2) = x \implies a = \frac{x - F(n-2)}{F(n-1)}
$$
$a$ 必须为整数且 $\ge 1$，因此需要验证：
1. $x \ge F(n)$（保证 $a \ge 1$）。
2. $x - F(n-2)$ 能被 $F(n-1)$ 整除。

#### **解决难点**
1. **生成斐波那契数列**：预先生成足够大的斐波那契数列项，以覆盖 $x$ 的可能范围（如 $x \le 10^9$）。
2. **遍历可能的 $n$**：从 $n=2$ 开始遍历，对每个 $n$ 验证条件是否满足。
3. **高效性**：利用预生成数列和数学推导，避免重复计算。

---

### **最优思路提炼**
1. **数学通项公式**：利用斐波那契数列的线性组合形式，快速逆向求解 $a$。
2. **预处理斐波那契数**：预先计算足够大的斐波那契项，减少实时计算开销。
3. **条件验证**：通过整除性检查和范围验证，快速过滤无效解。

---

### **代码实现**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<long long> fib = {0, 1, 1}; // fib[1]=1, fib[2]=1

void precompute_fib() {
    for (int i = 3;; i++) {
        long long next = fib[i-1] + fib[i-2];
        if (next > 2e9) break; // 超过题目要求的x范围即可停止
        fib.push_back(next);
    }
}

int main() {
    precompute_fib();
    int T;
    cin >> T;
    while (T--) {
        int x;
        cin >> x;
        vector<pair<int, int>> res;
        res.emplace_back(2, x); // n=2的解
        for (int n = 3; n < fib.size(); n++) {
            if (fib[n] > x) break;
            long long fn_1 = fib[n-1];
            long long fn_2 = fib[n-2];
            long long temp = x - fn_2;
            if (temp <= 0) continue;
            if (temp % fn_1 != 0) continue;
            long long a = temp / fn_1;
            if (a >= 1) {
                res.emplace_back(n, a);
            }
        }
        sort(res.begin(), res.end());
        for (auto &p : res) {
            cout << p.first << " " << p.second << endl;
        }
    }
    return 0;
}
```

---

### **可视化设计要点**
1. **像素风格动画**：用 Canvas 绘制斐波那契数列增长过程，每次计算 $n$ 时高亮对应的斐波那契项。
2. **音效反馈**：在找到有效解时播放音效，增强交互体验。
3. **步进控制**：允许单步执行，观察每一步的条件验证过程。

---

### **同类型题推荐**
1. **P3986 斐波那契数列**：逆向求解斐波那契项。
2. **P1306 斐波那契公约数**：斐波那契数列的数学性质应用。
3. **P1962 斐波那契数列**：快速幂优化递推。

---

**总结**：通过数学推导和预处理优化，将问题转化为斐波那契数列的逆向验证，高效解决大规模数据问题。

---
处理用时：279.45秒
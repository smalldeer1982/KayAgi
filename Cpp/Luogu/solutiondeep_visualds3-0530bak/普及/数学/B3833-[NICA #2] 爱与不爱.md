# 题目信息

# [NICA #2] 爱与不爱

## 题目背景

是爱还是厌　是爱还是厌\
啦啦啦啦~\
勉勉强强着　勉勉强强着\
啦啦啦啦啦~

## 题目描述

小 Ran 有一个长度为 $n$ 的正整数序列 $a$，她可以进行如下操作任意多次（包括零次）：

- 选择两个不同的数 $i,j$（$1\le i,j\le n$），然后将 $a_i$ **除以 $2$ 后下取整**，将 $a_j$ 乘二。要求操作完毕后的 $a_i$ 必须为正整数。

小 Ran 希望使序列的总和**最小**。输出最终序列的总和。

## 说明/提示

数据保证，$2\le n\le 10^5$，$1\le a_i\le 10^9$。

## 样例 #1

### 输入

```
5
1 2 3 4 5```

### 输出

```
12```

## 样例 #2

### 输入

```
6
1 1 4 5 1 4```

### 输出

```
12```

# AI分析结果



---

**算法分类**：数论

---

### **题解思路与解决难点**

1. **核心数学推导**  
   - **操作性质**：每次操作将两个数的因数2重新分配，总乘积不变。  
   - **最小化总和**：当所有数的因数2的幂次尽可能均匀时，总和最小（均值不等式）。  
   - **关键公式**：每个数分解为2的幂次后，总次数为 $\sum \lfloor \log_2 a_i \rfloor$。设总次数为 $S$，则最优分配为：  
     - 平均次数 $k = \lfloor S/n \rfloor$，剩余 $cnt = S - k \cdot n$。  
     - 总和为 $(n - cnt) \cdot 2^k + cnt \cdot 2^{k+1}$。

2. **解决难点**  
   - 推导出操作不影响总乘积，从而转化为因数分配问题。  
   - 将每个数分解到最低的2的幂次，并统计总次数。  
   - 利用数学公式直接计算最优分配结果，避免低效循环。

---

### **题解评分 (≥4星)**

1. **Light_Star_RPmax_AFO 的题解（5星）**  
   - **思路清晰**：直接推导数学公式，无需复杂循环。  
   - **高效实现**：时间复杂度 $O(n)$，适合大数据。  
   - **代码简洁**：关键函数分解次数，公式直接计算结果。  
   - **个人心得**：强调开 `long long` 避免溢出。

---

### **最优思路与技巧提炼**

- **关键技巧**：  
  1. 将每个数分解到无法再除的2的幂次，统计总次数。  
  2. 平均分配次数，余数分配到部分数，直接公式计算总和。  
  3. 利用数论中的均值不等式推导最小总和。

---

### **同类型题与算法套路**

- **常见题型**：  
  - 因数分配最优化问题（如最小化总和、最大化乘积）。  
  - 利用对数或二进制分解处理因数重组问题。  
- **通用思路**：  
  1. 分析操作对全局的影响（如乘积不变）。  
  2. 将问题转化为均匀分配，应用均值不等式。  
  3. 通过数学公式直接计算结果，避免模拟操作。

---

### **推荐题目**

1. [CF1368D AND, OR and square sum](https://www.luogu.com.cn/problem/CF1368D)  
2. [P7077 函数调用（因数分配与组合）](https://www.luogu.com.cn/problem/P7077)  
3. [AT_abc284_g Only Once（二进制分解与统计）](https://www.luogu.com.cn/problem/AT_abc284_g)

---

### **可视化与算法演示**

- **像素动画设计**：  
  - **颜色标记**：每个数分解为2的幂次时，用不同颜色标记当前操作的数。  
  - **分配演示**：以网格形式展示总次数 $S$，动态分配为 $k$ 和 $k+1$ 的块。  
  - **音效提示**：每完成一个数的分解播放音效，最终结果出现时播放成功音效。  
- **交互功能**：  
  - **步进控制**：单步观察分解过程和次数分配。  
  - **自动推导**：AI自动分解并分配次数，动态显示公式计算结果。

---

### **代码实现**

**核心逻辑**：计算总次数并应用公式。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int count_powers(int x) {
    int cnt = 0;
    while (x > 1) x >>= 1, cnt++;
    return cnt;
}

signed main() {
    int n, total = 0;
    cin >> n;
    for (int i = 0; i < n; i++) {
        int a; cin >> a;
        total += count_powers(a);
    }
    int k = total / n, cnt = total % n;
    cout << (1LL << k) * (n - cnt) + (1LL << (k + 1)) * cnt;
}
```

---

**总结**：通过数论推导将问题转化为因数均匀分配，直接公式计算避免低效操作。

---
处理用时：122.64秒
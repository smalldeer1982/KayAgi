# 题目信息

# [NICA #3] 星空（Easy Version）

## 题目背景

**Easy Version 和 Hard Version 差别在于数据范围。**

## 题目描述

小 R 有一个长度为 $n$ 的序列 $a$，保证序列中的每个数都是 $2$ 的整数次幂。

小 M 有一个数 $x$，她希望重新排列序列 $a$，使得不存在一个 $i\in[1,n)$ 满足 $a_i+a_{i+1}>x$。重排的方式为：选择一个 $1\sim n$ 的排列 $p$，然后令新序列 $a'$ 满足 $a'_i=a_{p_i}$。$a'$ 即为重排后的序列。

现在你想要知道有多少种重排的方式能满足小 M 的要求。两种重排方式不同当且仅当选择的排列 $p$ 不同。答案对 $10^9+7$ 取模。

## 说明/提示

数据保证，$2 \leq n \leq 61$，$1 \leq a_i \leq 2^{60}$，$1\le x< 2^{63}$。**每一个 $a_i$ 都不重复**。

## 样例 #1

### 输入

```
4 20
2 4 8 16```

### 输出

```
12```

# AI分析结果



## 唯一算法分类
**组合数学**

---

## 综合分析与结论
### 核心思路
所有题解均抓住关键性质：**任意两个非最大值的数之和小于最大值**，因此只需处理最大值与相邻元素的关系。通过统计可合法相邻的数值个数（记为 `cnt`），分情况计算排列数：
- **最大值在端点**（头或尾）：选 1 个合法数作为邻居，剩余元素全排列 → `2 * cnt * (n-2)!`
- **最大值在中间**：选 2 个合法数作为邻居，剩余元素全排列 → `(n-2) * cnt * (cnt-1) * (n-3)!`

### 关键公式推导
1. **统计合法邻居数**：`cnt = ∑(a_i != max && a_i + max ≤ x)`
2. **端点贡献**：`2 * cnt * (n-2)!`
3. **中间贡献**：`(n-2) * cnt * (cnt-1) * (n-3)!`

### 可视化设计思路
- **动画步骤**：展示最大值位置变化（端点/中间）→ 高亮相邻位置 → 动态选取合法数 → 剩余元素飘动至随机位置。
- **像素风格**：用不同颜色区分最大值、合法邻居、其他元素，阶乘计算以滚动数字呈现。
- **音效触发**：选中合法数时播放确认音，阶乘计算完成时播放成功音效。

---

## 题解清单（≥4星）
### 1. 作者：起名字重要吗（5星）
- **亮点**：代码最简，预处理阶乘，直接代入公式。
- **核心代码**：
  ```cpp
  for(int i=1; i<=n; fac[i]=(fac[i-1]*i)%mod,i++) 
      if(a[i]!=maxa&&a[i]+maxa<=x) cnt++;
  printf("%lld",(2*cnt*fac[n-2]%mod+(n-2)*cnt*(cnt-1)*fac[n-3]%mod)%mod);
  ```

### 2. 作者：a_little_carrot（4星）
- **亮点**：数学证明详细，代码紧凑，阶乘预处理优化。
- **心得摘录**：“剩下的元素可以任意排列，因为它们的和不会超过最大值。”

### 3. 作者：wyf1202（4星）
- **亮点**：分情况枚举位置，清晰体现组合逻辑。
- **代码片段**：
  ```cpp
  for(int i=1;i<=n;++i){
      if(i==1||i==n) ans=(ans+sum*j[n-2])%mod;
      else ans=(ans+sum*(sum-1)*j[n-3])%mod;
  }
  ```

---

## 最优思路提炼
1. **性质利用**：非最大值之和必小于最大值，仅需处理最大值的邻居。
2. **分位置计算**：端点与中间位置的贡献分开计算，避免重复或遗漏。
3. **阶乘预处理**：O(n) 预计算阶乘，快速获取全排列方案数。

---

## 同类型题与套路
- **常见套路**：组合问题中，将大问题分解为独立的位置贡献，利用阶乘加速全排列计算。
- **类似题目**：
  1. [洛谷 P1246 编码问题](https://www.luogu.com.cn/problem/P1246)（组合排列计数）
  2. [洛谷 P3193 组合数问题](https://www.luogu.com.cn/problem/P3193)（模运算与组合）
  3. [洛谷 P3223 排队](https://www.luogu.com.cn/problem/P3223)（分情况排列组合）

---

## 可视化与游戏化设计
### 复古像素动画方案
- **Canvas 绘制**：最大值用红色方块，合法邻居用绿色，其他元素为蓝色。
- **步进演示**：点击“下一步”时，高亮当前处理的最大值位置，显示合法邻居选择过程。
- **音效设计**：选中邻居时播放“哔”声，计算完成时播放 8-bit 胜利音效。

### 关键代码片段（JavaScript）
```javascript
// 伪代码：演示阶乘计算与贡献累加
function visualize() {
    let maxPos = 1; // 假设最大值在位置1
    highlight(maxPos, 'red');
    let validNeighbors = countValidNeighbors();
    playSound('select');
    let contribution = 2 * validNeighbors * factorial(n-2);
    updateScore(contribution);
}
```

---

## 个人心得摘录
- **调试教训**：需注意阶乘数组的初始化，`fac[0] = 1` 避免越界。
- **思维顿悟**：“问题复杂度看似高，实则通过性质分析可大幅简化。”

---

## 核心代码实现
### 预处理阶乘 + 公式计算
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1e9+7;

int main() {
    ll n, x, maxa = 0, cnt = 0, fac[70] = {1};
    cin >> n >> x;
    for (int i = 1; i <= n; ++i) {
        ll a; cin >> a;
        if (a > maxa) maxa = a;
        if (a != maxa && a + maxa <= x) cnt++;
        fac[i] = (fac[i-1] * i) % mod; // 阶乘预处理
    }
    ll ans = (2 * cnt * fac[n-2] % mod + (n-2) * cnt % mod * (cnt-1) % mod * fac[n-3] % mod) % mod;
    cout << ans;
    return 0;
}
```

---
处理用时：123.24秒
# 题目信息

# [常州市赛 2021] 烧菜

## 题目背景

搬运自 <http://czoj.com.cn/p/440>。

## 题目描述

小 $\text{X}$ 正在指挥 $M$ 个机器人做一道家常菜：白灼青菜。  
把一根青菜烧成菜肴需要两个步骤：洗菜和水煮。显然，一根青菜不可能同时被清洗和水煮，也不可能先被水煮后被清洗。  
现在小 $\text{X}$ 告诉你他是怎么指挥的。每当一个机器人空下来： 
- 如果有青菜还没被清洗，就让这个机器人清洗这根青菜
- 否则如果有青菜还没被水煮，就让这个机器人水煮这根青菜
- 都没有就让这个机器人关机

现在一共需要把 $N$ 根青菜烧成菜肴，任何一个机器人清洗都要花 $A$ 分钟，水煮要花 $B$ 分钟。小 $\text X$ 想请你告诉他多少分钟后所有菜能被烧好。

## 说明/提示

### 样例解释
为了方便说明，把机器人标号为 $1$ 号机器人和 $2$号机器人；把青菜标号为 $1$ 号、 $2$ 号、 $3$ 号青菜。实际上，机器人间是没有区别的，青菜间也是没有区别的。  
- 第 $0$ 分钟， $1$ 号机器人开始洗 $1$ 号青菜， $2$ 号机器人开始洗 $2$ 号青菜。  
- 第 $9$ 分钟， $1$ 号机器人开始洗 $3$ 号青菜， $2$ 号机器人开始煮 $1$ 号青菜。  
- 第 $14$ 分钟， $2$ 号机器人开始煮 $2$ 号青菜。  
- 第 $18$ 分钟， $1$ 号机器人开始煮 $3$ 号青菜。  
- 第 $19$ 分钟， $2$ 号机器人关机。  
- 第 $23$ 分钟，所有菜都被烧好了， $1$ 号机器人关机。
### 数据范围
本题共有 $20$ 个测试点。  
对于所有数据，满足 $1\le N,M,A,B\le 2000$。
|测试点编号|$N,M,A,B$|特殊性质|
|:-:|:-:|:-:|
|$1\sim2$|$\le50$|$M>N$|
|$3\sim4$|$\le50$|$M=1$|
|$5\sim6$|$\le50$|$A=B$|
|$7\sim10$|$\le50$|无|
|$11\sim12$|$\le2000$|$M>N$|
|$13\sim14$|$\le2000$|$M=1$|
|$15\sim16$|$\le2000$|$A=B$|
|$17\sim20$|$\le2000$|无|

## 样例 #1

### 输入

```
3 2 9 5```

### 输出

```
23```

# AI分析结果



## 算法分类
**贪心算法 + 优先队列（堆）**

---

## 综合分析与结论

### 题目核心思路
本题核心为**双阶段任务调度**：所有青菜需先洗后煮，且机器人按空闲顺序优先处理洗菜。关键难点在于确保煮任务的开始时间必须不早于对应洗任务的完成时间。

### 题解对比
1. **Sliarae（堆动态调度）**  
   - **核心**：使用两个小根堆分别维护机器人空闲时间（`q`）和洗菜完成时间（`p`）。动态分配任务时，若当前时间不足以处理最早可用的洗菜任务，则等待至其完成。  
   - **优化**：时间复杂度为 `O(N log M)`，高效处理大规模数据。  
   - **难点**：需协调两个堆的关系，确保煮任务不早于洗任务。

2. **why17（分阶段堆调度）**  
   - **核心**：分洗、煮两阶段，分别用堆维护任务完成时间。煮任务开始时间为 `max(机器人空闲时间, 洗菜完成时间)`。  
   - **优点**：逻辑清晰，分开处理阶段，代码可读性高。  
   - **时间复杂度**：`O(N log M)`，与堆操作一致。

3. **Manchester（暴力模拟）**  
   - **核心**：两次模拟洗、煮阶段，每次遍历所有机器人找最早空闲。洗完成后排序，煮时按顺序处理。  
   - **适用性**：时间复杂度 `O(N*M)`，在数据规模内可行但效率较低。  
   - **亮点**：直观模拟，适合理解调度流程。

### 可视化设计
- **动态时间轴**：用横向时间轴展示每个机器人任务块（洗绿色，煮橙色），高亮当前处理的机器人和任务。  
- **堆状态显示**：实时绘制洗完成时间堆和机器人空闲时间堆，标记堆顶元素。  
- **复古像素风**：用8-bit风格渲染时间轴，关键操作触发音效（如分配洗菜时“滴”声，煮菜时“嘟”声）。  
- **交互控制**：支持暂停/继续、单步执行，速度调节滑块观察任务分配细节。

---

## 题解评分（≥4星）

1. **Sliarae（⭐⭐⭐⭐⭐）**  
   - 高效利用双堆动态调度，精确处理时间依赖，代码简洁但需深入理解堆交互。

2. **why17（⭐⭐⭐⭐）**  
   - 分阶段处理逻辑清晰，代码可读性强，适合快速理解双阶段调度关系。

3. **Manchester（⭐⭐⭐⭐）**  
   - 暴力模拟直观展示流程，适合初学者理解任务调度本质，虽效率低但正确。

---

## 最优思路提炼

**关键技巧**：  
1. **双堆协调**：用空闲时间堆分配任务，洗完成时间堆约束煮任务开始时间。  
2. **动态贪心**：每次取最早空闲机器人，优先处理未完成阶段的最早任务。  
3. **时间取max**：煮任务开始时间取 `max(空闲时间, 洗完成时间)`，确保依赖顺序。

**代码片段（Sliarae）**：
```cpp
priority_queue<int, vector<int>, greater<int>> q, p;
for (int i = 1; i <= m; ++i) q.push(0);
while (n || t) {
    int tp = q.top(); q.pop();
    if (n) { // 洗菜阶段
        p.push(tp + a);
        q.push(tp + a);
        n--;
    } else { // 煮菜阶段
        if (tp < p.top()) { // 时间不足等待洗完成
            q.push(p.top());
        } else {
            q.push(tp + b);
            p.pop(); t--;
        }
    }
}
```

---

## 同类题目推荐

1. **P1086 花生采摘**  
   （任务顺序与移动时间优化）

2. **P1541 机器翻译**  
   （资源循环分配模拟）

3. **P2920 Time Management**  
   （截止时间约束下的任务调度）

---

## 个人心得摘录

- **Sliarae**：通过hack数据发现未考虑洗煮时间交叉，引入双堆解决依赖。  
- **why17**：调试时发现机器人关机逻辑错误，修正循环条件避免死循环。  
- **Manchester**：暴力法排序洗完成时间后煮阶段按序处理，顿悟时间轴对齐。

---

## 复古游戏化动画设计

- **像素渲染**：用Canvas绘制8-bit机器人，洗菜时显示水花动画，煮菜时冒热气。  
- **音效设计**：  
  - 洗菜开始：短促“滴”声（Web Audio合成）。  
  - 煮菜完成：上扬“叮”声。  
  - 错误操作：低沉“嗡”声提示。  
- **自动演示**：AI模式按最优调度逐步运行，类似贪吃蛇自动寻路。  
- **积分系统**：正确分配任务得10分，错误扣5分，历史最高分存档。

---
处理用时：196.71秒
# 题目信息

# [NOIP 1998 普及组] 阶乘之和

## 题目描述

用高精度计算出 $S = 1! + 2! + 3! + \cdots + n!$（$n \le 50$）。

其中 `!` 表示阶乘，定义为 $n!=n\times (n-1)\times (n-2)\times \cdots \times 1$。例如，$5! = 5 \times 4 \times 3 \times 2 \times 1=120$。

## 说明/提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le 50$。

**【其他说明】**

注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \le 20$，使用书中的代码无法通过本题。

如果希望通过本题，请继续学习第八章高精度的知识。

NOIP1998 普及组 第二题

## 样例 #1

### 输入

```
3
```

### 输出

```
9```

# AI分析结果



# [NOIP 1998 普及组] 阶乘之和

## 算法分类
**数论**（高精度运算）

---

## 题解思路与核心难点
### 数学方法与关键公式
1. **递推公式**：  
   利用阶乘的递推性质 `i! = (i-1)! * i`，通过高精度乘法动态维护当前阶乘值。  
   求和公式 `S = Σi!` 转化为高精度加法问题。

2. **核心难点**：
   - **进位处理**：乘法和加法中的逐位运算需处理多位数进位，特别是最高位可能产生的额外进位。
   - **存储优化**：通过数组倒序存储（低位在前），简化进位操作和结果输出。
   - **计算复用**：利用已计算的 `(i-1)!` 快速得到 `i!`，避免重复计算。

---

## 高星题解推荐（≥4★）
### 1. C_Z_C（4.5★）
**亮点**：
- 逐位运算清晰，通过双数组分别维护当前阶乘和总和。
- 动态调整数组长度优化存储空间。
- 注释详细，适合教学演示。

**代码片段**：
```cpp
for(int i=2;i<=n;i++){
    int p=i, len_a=0;
    while(p>0) a[len_a++]=p%10, p/=10; // 分解i为数字位
    // 高精度乘法
    for(int j=0;j<len_a;j++)
        for(int k=0;k<=len_b;k++)
            c[j+k] += a[j]*b[k];
    // 进位处理
    for(int j=0;j<len_c;j++)
        if(c[j]>9) c[j+1]+=c[j]/10, c[j]%=10;
}
```

### 2. zyk1256（Python解法，4★）
**亮点**：
- 利用Python原生大整数支持，代码极度简洁。
- 函数式编程风格（`reduce`+`lambda`），展示数学公式的直接映射。

**代码片段**：
```python
print(reduce(lambda x,y:x+y, [reduce(lambda x,y:x*y, range(1,i+1)) for i in range(1,n+1)]))
```

### 3. wuhao1027（4★）
**亮点**：
- 代码结构紧凑，双循环分别处理乘法和加法。
- 固定数组长度（100位）简化边界判断。

**代码片段**：
```cpp
for(int i=2;i<=n;i++){
    for(int j=0;j<100;j++) B[j] *= i; // 逐位乘i
    for(int j=0;j<100;j++){          // 处理进位
        B[j+1] += B[j]/10;
        B[j] %= 10;
    }
    // 高精度加法
    for(int j=0;j<100;j++) A[j] += B[j];
}
```

---

## 最优思路提炼
1. **递推计算**：维护当前阶乘值 `b[]`，每次计算 `i! = b[] * i`。
2. **倒序存储**：数组低位存储数字低位，便于逐位操作和进位处理。
3. **并行处理**：乘法和加法的进位在同一个循环中处理，减少遍历次数。

---

## 同类题型与算法套路
### 常见题型
1. **大数加法/乘法**（如洛谷 P1601、P1303）。
2. **高精度阶乘**（如洛谷 P1009）。
3. **递推公式的高精度实现**（如斐波那契数列的大数版本）。

### 通用套路
1. **数组存储**：用数组模拟数字，低位在前简化运算。
2. **双循环处理**：外层遍历数字，内层逐位运算并处理进位。
3. **动态长度调整**：根据最高位进位动态扩展数组长度。

---

## 推荐练习题
1. **P1601 A+B Problem（高精度）**  
   基础高精度加法模板题。
2. **P1303 A*B Problem**  
   高精度乘法经典问题。
3. **P1255 数楼梯**  
   递推+高精度，类似斐波那契数列。

---

## 可视化设计（复古像素风格）
### 动画演示
1. **阶乘计算**：  
   - 每个数字位显示为8x8像素块，底色区分当前操作位（如黄色）。
   - 乘法时，逐位闪烁显示相乘过程（如3! = 2!*3），红色标记进位值。
2. **进位处理**：  
   - 进位时播放「哔」声效，蓝色箭头指向高位。
3. **总和累加**：  
   - 绿色高亮显示当前阶乘值被加入总和的过程。

### 交互功能
- **步进控制**：空格键单步执行，Enter键自动播放（速度可调）。
- **音效**：8-bit风格音效，乘法时短促「滴」，进位时「嘟」。

---

## 关键代码实现
### 高精度乘法核心
```cpp
void multiply(int a[], int &len, int x) {
    int carry = 0;
    for (int i=0; i<len; i++) {
        int temp = a[i] * x + carry;
        a[i] = temp % 10;
        carry = temp / 10;
    }
    while (carry) { // 处理剩余进位
        a[len++] = carry % 10;
        carry /= 10;
    }
}
```

### 高精度加法核心
```cpp
void add(int sum[], int a[], int len) {
    int carry = 0;
    for (int i=0; i<len; i++) {
        sum[i] += a[i] + carry;
        carry = sum[i] / 10;
        sum[i] %= 10;
    }
    if (carry) sum[len++] = carry;
}
```

---

## 个人心得摘录
> **C_Z_C**：  
> 「在加法进位时，最初错误地写成 `f[j+1]++`，导致WA了一个点。必须用 `f[j+1]+=f[j]/10` 正确处理多位进位。」

> **吃葡萄吐糖**：  
> 「二维数组存储各阶乘值虽浪费空间，但调试时能直观看到中间结果，适合新手理解。」

---

通过分步可视化与复古交互设计，学习者可直观掌握高精度运算的底层逻辑，同时增强学习趣味性。

---
处理用时：95.01秒
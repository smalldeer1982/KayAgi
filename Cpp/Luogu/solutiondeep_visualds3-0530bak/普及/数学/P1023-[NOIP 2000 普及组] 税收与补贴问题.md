# 题目信息

# [NOIP 2000 普及组] 税收与补贴问题

## 题目背景

每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间销量的变化是线性的且在价格高于给定的最高价位后，销量以某固定数值递减。（我们假设价格及销售量都是整数）

对于某些特殊商品，不可能完全由市场去调节其价格。这时候就需要政府以税收或补贴的方式来控制。（所谓税收或补贴就是对于每个产品收取或给予生产厂家固定金额的货币）


## 题目描述

你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。

- 总利润 $=$ 单位商品利润 $\times$ 销量
- 单位商品利润 $=$ 单位商品价格 $-$ 单位商品成本（减去税金 或者 加上补贴）


## 说明/提示

### 数据范围及约定

保证输入的所有数字均小于 $10^5$。

### 样例解释（2023/6/22 更新）

如下图所示是输入样例所对应的价格变化图，横轴表示销售价格，纵轴表示销量。

![](https://cdn.luogu.com.cn/upload/image_hosting/21mhtm5i.png)

根据题意，$28$ 元是商品的成本。销售价格不应该低于 $28$ 元；当销售价格大于给出的价格的最大值 $31$ 元后，按照售价每提高一元，销量降低 $15$ 计算，例如当售价为 $33$ 元时，销量为 $110-15\times (33-31)=80$。在给出来的价位之间，销量呈线性变化。

当政府给该商品补贴 $4$ 元后，企业将该商品定价为 $31$ 元时，取得的利润为 $31-28+4=7$ 元，销量为 $110$ 件，总利润为 $7\times 110=770$ 元，是企业在所有定价下能够取得的最大的总利润。此时企业的售价为政府的期望售价，因此是一个合法方案。

## 样例 #1

### 输入

```
31
28 130
30 120
31 110
-1  -1
15```

### 输出

```
4
```

# AI分析结果



## 算法分类
无算法分类（数学模拟题）

## 题解思路与难点分析

### 核心思路
题目要求通过税收/补贴使得指定价格成为利润最大点。核心思路是模拟所有价格销量关系，计算不同调控策略下的利润分布。

### 解决难点
1. **销量填充**：
   - 线性插值处理相邻价格间的销量变化，需保证数据连续。
   - 最高价后按固定递减量生成销量，直到非正。

2. **利润计算优化**：
   - 暴力枚举法：直接尝试所有可能的补贴/税收值，找到满足条件的最小绝对值。
   - 方向性枚举：根据初始最大利润位置决定搜索方向（补贴或税收）。

### 关键公式推导
总利润公式：
\[ \text{利润} = (\text{价格} - \text{成本} \pm \text{调控}) \times \text{销量} \]

对于每个价格点 \( p_i \)，需满足：
\[ (p_{\text{预期}} - \text{成本} + x) \times s_{\text{预期}} \geq (p_i - \text{成本} + x) \times s_i \]
解不等式组得到 x 的范围。

## 题解评分（≥4星）

1. **Mitch谜团（4★）**
   - 直接暴力枚举，填充所有价格并计算利润
   - 代码直观，适合数据量小的情况

2. **Ofnoname（4★）**
   - 数学推导解不等式，高效处理大数据
   - 需处理大量边界条件

3. **dodo（4★）**
   - 利用利润函数单调性减少枚举次数
   - 先确定初始方向，再单向搜索

## 最优思路提炼
**方向性枚举法**：
1. 填充所有价格及销量
2. 计算初始状态（无调控）下的最大利润点
3. 若初始点高于预期，枚举补贴；若低于，枚举税收
4. 按绝对值从小到大尝试，找到首个合法解

## 同类题目推荐
1. P1023 税收与补贴问题（本题）
2. P1985 [NOIP2015]跳石头（二分答案）
3. P1217 [USACO1.5]回文质数（数学模拟）

## 可视化设计（像素风格）

### 动画方案
1. **数据填充阶段**：
   - 横向像素条表示价格，纵向表示销量
   - 线性插值过程用绿色像素渐变动画展示
   - 固定递减部分用红色闪烁提示

2. **利润计算阶段**：
   - 每个价格对应柱状图，高度表示利润
   - 调控值变化时，柱图动态升降
   - 预期价格柱图用金色边框高亮

3. **音效设计**：
   - 填充完成：8-bit "叮" 音
   - 找到解时：上升音阶
   - 错误尝试：短促蜂鸣

### 交互功能
- **WASD** 调整调控值
- **空格** 切换自动演示模式
- **ESC** 暂停/继续

## 核心代码实现
```cpp
// 填充价格与销量
vector<pair<int, int>> prices;
void fill_prices() {
    int last_p, last_s;
    while (cin >> p >> s && p != -1) {
        if (!prices.empty() && p - last_p > 1) {
            int step = (last_s - s) / (p - last_p);
            for (int i=last_p+1; i<p; ++i) {
                prices.emplace_back(i, last_s - step*(i-last_p));
            }
        }
        prices.emplace_back(p, s);
        last_p = p; last_s = s;
    }
    // 处理递减部分
    while (last_s > 0) {
        last_p++;
        last_s -= D;
        if (last_s > 0) prices.emplace_back(last_p, last_s);
    }
}

// 方向性枚举
int find_x() {
    int base = prices[0].first; // 成本价
    auto max_it = max_element(prices.begin(), prices.end(), 
        [base](auto &a, auto &b) { return (a.first-base)*a.second < (b.first-base)*b.second; });
    
    if (max_it->first == target) return 0;
    
    int dir = (max_it->first > target) ? 1 : -1;
    for (int x=1; ; ++x) {
        int cur_x = dir * x;
        auto calc = [&](int p, int s) { return (p - base + cur_x) * s; };
        // 检查所有价格的利润是否小于等于目标价格利润
        bool valid = true;
        int target_profit = calc(target, target_s);
        for (auto &[p, s] : prices) {
            if (calc(p, s) > target_profit) {
                valid = false;
                break;
            }
        }
        if (valid) return cur_x;
    }
}
```

## 关键总结
1. 正确填充价格销量关系是基础
2. 利用初始状态确定搜索方向大幅优化效率
3. 数学方法虽高效，但需处理复杂边界条件
4. 实际编码时注意整数除法与边界条件处理

---
处理用时：184.19秒
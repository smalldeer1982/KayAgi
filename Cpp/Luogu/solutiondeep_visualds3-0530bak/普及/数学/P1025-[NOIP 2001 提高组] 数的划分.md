# 题目信息

# [NOIP 2001 提高组] 数的划分

## 题目描述

将整数 $n$ 分成 $k$ 份，且每份不能为空，任意两个方案不相同（不考虑顺序）。

例如：$n=7$，$k=3$，下面三种分法被认为是相同的。

$1,1,5$;   
$1,5,1$;   
$5,1,1$.

问有多少种不同的分法。


## 说明/提示

四种分法为：  
$1,1,5$;  
$1,2,4$;  
$1,3,3$;  
$2,2,3$.

**【题目来源】**

NOIP 2001 提高组第二题

## 样例 #1

### 输入

```
7 3
```

### 输出

```
4
```

# AI分析结果



**算法分类**：组合数学

---

### **题解思路与核心难点**

**题目核心**：将整数 `n` 划分为 `k` 个非空部分，不同顺序视为同一种方案，求划分方式总数。

---

#### **关键数学推导与算法思路**
1. **动态规划 (DP) 思路**：
   - **状态定义**：`dp[i][j]` 表示将整数 `i` 划分为 `j`个非空部分的方案数。
   - **状态转移**：
     - **含1的情况**：若某划分中有一个1，剩余部分为 `i-1` 分 `j-1` 份，贡献 `dp[i-1][j-1]`。
     - **不含1的情况**：每部分至少为2，等价于将 `i-j` 分 `j` 份（每份减1后至少1），贡献 `dp[i-j][j]`。
   - **转移方程**：  
     `dp[i][j] = dp[i-1][j-1] + dp[i-j][j]`
   - **边界条件**：
     - `dp[i][1] = 1`（唯一分法为全选）。
     - `i < j` 时 `dp[i][j] = 0`（无法划分）。

2. **DFS剪枝思路**：
   - **递增枚举**：强制划分序列递增避免重复计数。
   - **剪枝条件**：
     - **下界**：当前数不小于前一个数（保证递增）。
     - **上界**：剩余数平均分配的上限，即 `(n-sum)/(k-x+1)`。

---

#### **可视化算法演示（动态规划）**
**步骤说明**：
1. **初始化表格**：二维数组 `dp[n+1][k+1]`，边界 `dp[i][1]=1`。
2. **填充表格**：
   - 遍历 `i` 从2到n，`j` 从2到k。
   - 若 `i >= j`，计算 `dp[i][j] = dp[i-1][j-1] + dp[i-j][j]`。
3. **结果输出**：`dp[n][k]`。

**可视化设计**：
- **颜色标记**：当前计算的单元格高亮为黄色，依赖的前置状态（`dp[i-1][j-1]` 和 `dp[i-j][j]`）标记为蓝色。
- **动画演示**：逐步填充表格，展示状态转移过程，控制速度为500ms/步。
- **控制面板**：支持暂停、单步执行、调整速度。

---

### **题解评分（≥4星）**

1. **s_r_f（动态规划）**  
   - ⭐⭐⭐⭐⭐  
   - **亮点**：状态定义清晰，递推公式简洁，时间复杂度O(nk)高效。  
   - **代码**：  
     ```cpp
     int dp[201][7] = {0};
     for (int i=1; i<=n; i++) dp[i][1] = 1;
     for (int i=2; i<=n; i++)
         for (int j=2; j<=k; j++)
             dp[i][j] = dp[i-1][j-1] + (i>j ? dp[i-j][j] : 0);
     cout << dp[n][k];
     ```

2. **langmouren（DFS剪枝）**  
   - ⭐⭐⭐⭐  
   - **亮点**：剪枝条件精确，保证不重复且高效，代码简洁易理解。  
   - **代码片段**：  
     ```cpp
     void dfs(int x, int sum, int l) {
         if (x == k) { ans += (sum == n); return; }
         for (int i=l; i <= (n-sum)/(k-x); i++)
             dfs(x+1, sum+i, i);
     }
     ```

3. **陈嘉逸2012（递推公式）**  
   - ⭐⭐⭐⭐  
   - **亮点**：利用斯特林数递推，代码极简，数学直观性强。  
   - **代码**：  
     ```cpp
     int dfs(int n, int m) {
         if (n == 0 || m == 1) return 1;
         if (n < m) return dfs(n, n);
         return dfs(n, m-1) + dfs(n - m, m);
     }
     ```

---

### **同类型题目推荐**
1. **P1023** [数的划分（允许空集）](https://www.luogu.com.cn/problem/P1023)  
2. **P1024** [整数拆分（完全背包变体）](https://www.luogu.com.cn/problem/P1024)  
3. **P2417** [集合划分问题](https://www.luogu.com.cn/problem/P2417)

---

### **核心代码实现（动态规划）**
```cpp
#include <iostream>
using namespace std;

int main() {
    int n, k, dp[201][7] = {0};
    cin >> n >> k;
    for (int i = 1; i <= n; i++) dp[i][1] = 1;
    for (int i = 2; i <= n; i++)
        for (int j = 2; j <= k; j++)
            dp[i][j] = dp[i-1][j-1] + (i > j ? dp[i-j][j] : 0);
    cout << dp[n][k];
    return 0;
}
```

---

### **可视化代码片段（Canvas动画）**
```javascript
// 动态规划表格填充动画
function animateDP(n, k) {
    let ctx = canvas.getContext('2d');
    let cellSize = 30;
    // 绘制表格...
    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= k; j++) {
            // 高亮当前单元格
            ctx.fillStyle = i === currentI && j === currentJ ? '#FFFF00' : '#FFFFFF';
            ctx.fillRect(j*cellSize, i*cellSize, cellSize, cellSize);
            // 绘制数值...
        }
    }
    // 单步执行逻辑...
}
```

---

**总结**：动态规划是本题最优解法，时间复杂度低且代码简洁。关键点在于状态转移方程的推导，通过数学归纳法将问题分解为含1和不含1的子问题，确保无重复计数。

---
处理用时：79.74秒
# 题目信息

# [NOIP 2003 提高组] 传染病控制

## 题目背景

本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

---

近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。


## 题目描述

研究表明，这种传染病的传播具有两种很特殊的性质；

第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。


第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。


这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。


你的程序要针对给定的树，找出合适的切断顺序。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 300$。

**【题目来源】**

NOIP 2003 提高组第四题

## 样例 #1

### 输入

```
7 6
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
```

# AI分析结果



**唯一算法分类**  
组合数学

---

**综合分析与结论**  
本题核心在于通过树形结构的组合优化选择切断路径。所有题解均采用分层DFS策略，预处理子树规模后通过回溯枚举切断方案。关键难点在于正确维护父子关系与子树规模，避免重复计算。

**关键公式与推导**  
1. 子树规模预处理公式：  
   size[u] = 1 + Σsize[child]  
   通过DFS递归计算每个节点的子树规模，为后续切断决策提供快速计算依据  

2. 最优解递推关系：  
   ans = min(n - max_saved)  
   max_saved通过DFS维护当前保存的最大人数

**可视化设计思路**  
采用分层树形结构展示，通过以下动画步骤演示：  
1. 初始树结构以像素风格渲染，根节点为红色方块  
2. 每层节点用不同颜色边框标记（如第二层蓝色、第三层绿色）  
3. 选择切断节点时触发闪光特效，其子树瞬间变为灰色  
4. 右侧面板显示当前保存人数与剩余层数  
5. 关键步骤触发8-bit音效（选择节点-上升音，切断成功-金币音）

---

**题解清单 (≥4星)**  
1. **RikoHere (★★★★☆)**  
   - 亮点：分层预处理+动态回溯，clean/reclean函数清晰管理状态  
   - 代码结构模块化，通过优先队列处理层级关系  

2. **基础不牢 (★★★★☆)**  
   - 亮点：使用结构体存储父子关系，动态更新感染标记  
   - 引入提前终止条件优化搜索过程  

3. **欧鹰 (★★★★☆)**  
   - 亮点：直接标记子树实现快速状态切换  
   - 引入树形DP预处理加速决策  

---

**核心代码实现**  
```python
# 子树切断与恢复的核心逻辑
def dfs(depth, saved):
    global max_saved
    if depth > max_depth:
        max_saved = max(max_saved, saved)
        return
    
    current_layer = layers[depth]
    for node in current_layer:
        if not is_cut_ancestor(node):
            # 切断子树并递归
            cut_size = cut_subtree(node) 
            dfs(depth+1, saved + cut_size)
            restore_subtree(node)
    
    # 提前终止条件
    if all_cut(current_layer):
        max_saved = max(max_saved, saved)
```

---

**同类型题目推荐**  
1. P2015 二叉苹果树（树形DP）  
2. P1352 没有上司的舞会（树形选择）  
3. P2014 选课（树形依赖背包）  

---

**可视化实现要点**  
```javascript
// 像素风格渲染核心逻辑
class PixelTree {
  constructor(ctx) {
    this.ctx = ctx;
    this.nodeSize = 16;
    this.colors = ['#FF0000', '#0000FF', '#00FF00']; // 层级颜色
  }

  drawNode(x, y, layer) {
    this.ctx.fillStyle = this.colors[layer % 3];
    this.ctx.fillRect(x, y, this.nodeSize, this.nodeSize);
    
    // 绘制连接线
    if (parent) {
      this.ctx.beginPath();
      this.ctx.moveTo(parent.x, parent.y);
      this.ctx.lineTo(x, y);
      this.ctx.strokeStyle = '#FFFFFF';
      this.ctx.stroke();
    }
  }

  // 切断动画特效
  cutEffect(node) {
    let alpha = 1.0;
    const animate = () => {
      alpha -= 0.1;
      this.ctx.fillStyle = `rgba(128,128,128,${alpha})`;
      this.ctx.fillRect(node.x, node.y, this.nodeSize, this.nodeSize);
      if (alpha > 0) requestAnimationFrame(animate);
    };
    animate();
    playSound('cut'); // 触发8-bit音效
  }
}
```

---

**个人心得摘录**  
> "调试时发现切断标记未正确回溯，导致后续层级的计算污染状态。通过引入独立标记栈实现精确状态回滚。"  
> "预处理子树规模是性能关键，直接减少30%的递归调用次数"  
> "链式测试用例暴露了层级判断漏洞，促使增加提前终止条件"  

---

**扩展思考**  
该问题的变种可引入动态树结构（节点随时间增加），此时需结合离线处理与时间戳标记。对于大规模数据（n≥1e5），可采用树链剖分+贪心选择进行近似求解。

---
处理用时：67.48秒
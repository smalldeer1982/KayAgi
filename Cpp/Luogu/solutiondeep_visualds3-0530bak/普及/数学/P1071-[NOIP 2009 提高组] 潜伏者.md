# 题目信息

# [NOIP 2009 提高组] 潜伏者

## 题目描述

R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：

1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母 $\texttt{A}\sim\texttt{Z}$ 构成（无空格等其他字符）；
2. S 国对于每个字母规定了对应的密字。加密的过程就是将原信息中的所有字母替换为其对应的密字；
3. 每个字母只对应一个唯一的密字，不同的字母对应不同的密字。密字可以和原字母相同。

例如，若规定 $\tt A$ 的密字为 $\tt A$，$\tt B$ 的密字为 $\tt C$（其他字母及密字略），则原信息 $\tt ABA$ 被加密为 $\tt ACA$。

现在，小 C 通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小 C 希望能通过这条信息，破译 S 国的军用密码。小 C 的破译过程是这样的：扫描原信息，对于原信息中的字母 $x$（代表任一大写字母），找到其在加密信息中的对应大写字母 $y$，并认为在密码里 $y$ 是 $x$ 的密字。如此进行下去直到停止于如下的某个状态：

1. 所有信息扫描完毕，$\texttt{A}\sim\texttt{Z}$ 所有 $26$ 个字母在原信息中均出现过并获得了相应的密字；
2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现；
3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。

例：

如某条信息 $\tt XYZ$ 被翻译为 $\tt ABA$ 就违反了“不同字母对应不同密字”的规则。

在小 C 忙得头昏脑涨之际，R 国司令部又发来电报，要求他翻译另外一条从 S 国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。


## 说明/提示

【输入输出样例一说明】

原信息中的字母 $\tt A$ 和 $\tt B$ 对应相同的密字，输出 $\tt Failed$。

【输入输出样例二说明】

字母 $\tt Z$ 在原信息中没有出现，输出 $\tt Failed$。

NOIP2009 提高组第一题

## 样例 #1

### 输入

```
AA 
AB 
EOWIE

```

### 输出

```
Failed
```

## 样例 #2

### 输入

```
QWERTYUIOPLKJHGFDSAZXCVBN 
ABCDEFGHIJKLMNOPQRSTUVWXY 
DSLIEWO
```

### 输出

```
Failed 
```

## 样例 #3

### 输入

```
MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP
YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL
FLSO ```

### 输出

```
NOIP```

# AI分析结果



### 唯一算法分类
**无算法分类**

---

### 综合分析与结论
**核心难点**：建立双向映射关系，检测冲突（同一密文对应不同明文，或不同密文对应同一明文），并确保 26 个字母全被使用。  
**关键数学逻辑**：无复杂公式，但需通过遍历与哈希结构（或数组）实现双向映射的冲突检测。  
**可视化设计**：
1. **动画流程**：逐字符配对密文与明文，用绿色高亮新映射，红色标记冲突位置；最终遍历 A-Z 检查是否全被覆盖。
2. **像素风格**：用 8 位字体显示映射表，每次配对时播放短促音效，冲突时屏幕抖动+警报音效，成功时烟花动画。

---

### 题解清单（≥4星）
1. **CYJian（4.5★）**  
   - **亮点**：双向 map 维护映射，逻辑严密；代码简洁，直接计算字母覆盖数量。  
   - **代码片段**：
     ```cpp
     map<char,char> mp, mq; // 双向映射
     for (int i=0; i<la; i++) {
         if (mp[a[i]] != 0 && mp[a[i]] != b[i]) ERROR;
         if (mq[b[i]] != 0 && mq[b[i]] != a[i]) ERROR;
         mp[a[i]] = b[i], mq[b[i]] = a[i];
     }
     ```

2. **陈嘉逸2012（4★）**  
   - **亮点**：单 map + vis 数组，检查明文重复；代码极简，仅 15 行。  
   - **代码片段**：
     ```cpp
     map<char, char> mp; map<char, bool> vis;
     for (int i=0; i<a.size(); i++) {
         if (vis[b[i]] && b[i] != mp[a[i]]) ERROR;
         mp[a[i]] = b[i], vis[b[i]] = true;
     }
     ```

3. **lianghuahua（4★）**  
   - **亮点**：set 记录已用明文，解决多密文映射同一明文问题；代码逻辑清晰。  
   - **心得**："开始误判状态 2，需注意题目要求必须覆盖全部 26 字母。"

---

### 最优思路与技巧
1. **双向映射检查**：使用两个 map 或数组分别记录密文→明文、明文→密文，确保一一对应。
2. **覆盖性验证**：遍历 A-Z 检查所有字母是否被映射（或统计唯一映射数量是否为 26）。
3. **数组替代哈希**：若追求效率，可用 `char[128]` 数组代替 map（ASCII 直接寻址）。

---

### 同类型题与算法套路
- **核心套路**：映射关系合法性检测（如密码替换、字符编码转换）。
- **同类题目**：
  1. [P1918 保龄球](https://www.luogu.com.cn/problem/P1918)（映射查询）
  2. [P1055 ISBN号码](https://www.luogu.com.cn/problem/P1055)（校验码验证）
  3. [P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)（字符串模式匹配）

---

### 复古像素化可视化设计
```javascript
// 伪代码示例：Canvas 绘制映射表
const canvas = document.getElementById("pixel-canvas");
const ctx = canvas.getContext("2d");
const colors = ["#000", "#0F0", "#F00"]; // 黑、绿、红

function drawMapping(mp, conflict) {
    ctx.fillStyle = "#FFF"; // 白色背景
    ctx.fillRect(0, 0, 320, 240);
    for (let c = 'A'; c <= 'Z'; c++) {
        const x = (c.charCodeAt(0) - 65) % 13 * 24;
        const y = Math.floor((c.charCodeAt(0) - 65) / 13) * 32;
        ctx.fillStyle = conflict.has(c) ? colors[2] : colors[0];
        ctx.fillText(`${c}→${mp[c] || '?'}`, x, y);
    }
}
// 音效：Web Audio API 播放 8 位音效
function playBeep(freq) {
    const osc = new OscillatorNode(ctx, {frequency: freq});
    osc.connect(ctx.destination);
    osc.start(); osc.stop(ctx.currentTime + 0.1);
}
```

---

### 关键代码实现
**数组双向映射法**（高效版）：
```cpp
char cipher[128] = {0}; // 密文→明文
char plain[128] = {0};  // 明文→密文
for (int i=0; a[i]; i++) {
    char y = a[i], x = b[i];
    if (cipher[y] && cipher[y] != x) ERROR;
    if (plain[x] && plain[x] != y) ERROR;
    cipher[y] = x, plain[x] = y;
}
for (char c='A'; c<='Z'; c++)
    if (!cipher[c]) ERROR;
```

---
处理用时：66.51秒
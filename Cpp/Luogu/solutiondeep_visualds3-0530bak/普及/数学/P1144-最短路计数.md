# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果



## 【算法分类】
**组合数学**

---

## 【题解思路与核心难点】
**核心思路**：  
无向无权图的最短路径等价于BFS层级距离，通过动态规划累加路径数。每个节点的路径数等于所有距离比其小1的前驱节点路径数之和。

**数学推导**：  
设节点v的最短距离为d，路径数为ans[v]。对任意u→v的边，若d(u) + 1 = d(v)，则ans[v] += ans[u]。此过程基于组合数学的**加法原理**，每条最短路径唯一对应一个前驱节点u的最短路径。

**实现要点**：  
1. **BFS层级遍历**：首次访问节点时确定最短距离，后续访问仅累加路径数。  
2. **路径数更新**：分两种情况处理：发现更短路径（重置计数）或等长路径（累加计数）。  
3. **取模优化**：防止整数溢出，需在每次累加时取模。

---

## 【题解评分（≥4星）】
1. **岸芷汀兰（BFS实现）**  
   - **评分**：★★★★★  
   - **亮点**：利用BFS层级特性直接统计路径数，代码简洁高效，时间复杂度O(N+M)。  
   - **关键代码**：  
     ```cpp
     if (!vis[cur]) { // 首次访问
         ans[cur] = ans[u];
         q.push(cur);
     } else if (dis[cur] == dis[u] + 1) { // 等长路径
         ans[cur] += ans[u];
     }
     ```

2. **XZYQvQ（SPFA + 记忆化搜索）**  
   - **评分**：★★★★☆  
   - **亮点**：分离最短路计算与路径统计，避免重复松弛干扰，通用性更强。  
   - **心得摘录**：  
     > “SPFA过程中直接统计路径数可能遗漏某些情况，需二次遍历最短路图进行记忆化搜索。”

3. **King丨帝御威（Dijkstra堆优化）**  
   - **评分**：★★★★  
   - **亮点**：堆优化保证每次处理最小距离节点，避免冗余操作，适合稀疏图。  
   - **关键代码**：  
     ```cpp
     if (d[y] > d[x] + 1) { // 更短路径
         ans[y] = ans[x];
         q.push({-d[y], y});
     } else if (d[y] == d[x] + 1) { // 等长路径
         ans[y] += ans[x];
     }
     ```

---

## 【最优思路提炼】
**关键步骤**：  
1. **初始化**：起点的路径数为1，其他节点路径数为0。  
2. **BFS遍历**：按层级处理节点，确保最短距离优先计算。  
3. **动态累加**：对每个节点的邻居，分情况更新路径数。  

**公式化表示**：  
\[
\text{ans}[v] = \sum_{\substack{u \in \text{neighbors}(v) \\ d(u) + 1 = d(v)}} \text{ans}[u]
\]

---

## 【同类型题目推荐】
1. **P1608 路径统计**（带权图最短路计数）  
2. **P1144 最短路计数**（本题，巩固思路）  
3. **P2296 寻找道路**（结合最短路与条件过滤）

---

## 【可视化设计】
**动画方案**：  
1. **节点状态**：  
   - **白色**：未访问  
   - **绿色**：当前处理节点  
   - **黄色**：需累加路径数的邻居  
   - **红色**：发现更短路径的邻居  

2. **流程演示**：  
   - **Step 1**：起点1标记为绿色，路径数显示为1。  
   - **Step 2**：处理节点1，遍历邻居节点2、3，更新其距离为1，路径数设为1，标记为黄色并入队。  
   - **Step 3**：处理节点2，遍历邻居4，更新距离为2，路径数继承为1；若邻居4已被处理且距离相同，路径数累加。  

**复古像素风格**：  
- **Canvas 绘制**：节点为8位像素方块，边用单色线条连接。  
- **音效**：  
  - 发现新节点：短促“哔”声（8-bit音效）。  
  - 累加路径数：连续“嘀嗒”声。  
- **自动演示**：模拟BFS层级扩展，AI自动播放，速度可调。

---

## 【核心代码实现】
**BFS关键片段**：  
```cpp
void bfs() {
    queue<int> q;
    q.push(1);
    dis[1] = 0;
    ans[1] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : adj[u]) {
            if (dis[v] == -1) { // 首次访问
                dis[v] = dis[u] + 1;
                ans[v] = ans[u];
                q.push(v);
            } else if (dis[v] == dis[u] + 1) { // 等长路径
                ans[v] = (ans[v] + ans[u]) % MOD;
            }
        }
    }
}
```

**复古动画JS片段**：  
```javascript
// 初始化Canvas
const ctx = canvas.getContext('2d');
ctx.fillStyle = '#00FF00'; // 绿色为当前节点

function drawNode(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * 30, y * 30, 25, 25); // 像素方块
}

// 播放音效
function playBeep() {
    const osc = audioContext.createOscillator();
    osc.frequency.setValueAtTime(800, audioContext.currentTime);
    osc.connect(audioContext.destination);
    osc.start();
    osc.stop(audioContext.currentTime + 0.1);
}
```

---

**总结**：本题通过BFS和动态规划的结合，高效统计最短路数目。核心在于理解路径数的累加逻辑，并通过层级遍历保证正确性。可视化设计可帮助直观理解状态转移过程，复古风格增强学习趣味性。

---
处理用时：101.93秒
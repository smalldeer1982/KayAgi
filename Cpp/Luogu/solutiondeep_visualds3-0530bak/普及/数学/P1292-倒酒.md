# 题目信息

# 倒酒

## 题目描述

Winy是一家酒吧的老板，他的酒吧提供两种体积的啤酒，$a$ ml 和 $b$ ml，分别使用容积为 $a$ ml 和 $b$ ml 的酒杯来装载。

酒吧的生意并不好。Winy 发现酒鬼们都非常穷。有时，他们会因为负担不起 $a$ ml 或者 $b$ ml 啤酒的消费，而不得不离去。因此，Winy 决定出售第三种体积的啤酒（较小体积的啤酒）。

Winy 只有两种杯子，容积分别为 $a$ ml 和 $b$ ml，而且啤酒杯是没有刻度的。他只能通过两种杯子和酒桶间的互相倾倒来得到新的体积的酒。

为了简化倒酒的步骤，Winy 规定：

1.  $a≥b$；
2.  酒桶容积无限大，酒桶中酒的体积也是无限大（但远小于桶的容积）；
3. 只包含三种可能的倒酒操作：  
   1. 将酒桶中的酒倒入容积为 $b$ ml 的酒杯中；  
   2. 将容积为 $a$ ml 的酒杯中的酒倒入酒桶；  
   3. 将容积为 $b$ ml 的酒杯中的酒倒入容积为 $a$ ml 的酒杯中。
4. 每次倒酒必须把杯子倒满或把被倾倒的杯子倒空。

Winy希望通过若干次倾倒得到容积为 $a$ ml 酒杯中剩下的酒的体积尽可能小，他请求你帮助他设计倾倒的方案。

## 说明/提示

### 样例解释

倾倒的方案为：

1. 桶 $\to$ B 杯；
2. B 杯 $\to$ A 杯；
3. 桶 $\to$ B 杯；
4. B 杯 $\to$ A 杯；
5. A 杯 $\to$ 桶; 
6. B 杯 $\to$ A 杯。


## 样例 #1

### 输入

```
5 3

```

### 输出

```
1

1 2

```

# AI分析结果



**唯一算法分类**：数论  

---

### **题解思路、算法要点与解决难点**  
**核心公式与推导**：  
- 根据题意，最小剩余酒量 $c = \gcd(a, b)$，由裴蜀定理保证。  
- 建立方程 $-ax + by = \gcd(a, b)$，通过扩展欧几里得算法求解特解 $(x_0, y_0)$，再调整解使其满足非负性和最小操作次数。  

**关键步骤与难点**：  
1. **扩展欧几里得求解**：递归计算 $ax + by = \gcd(a,b)$ 的特解，注意符号调整（$-ax$）。  
2. **解的调整**：通过加减 $\frac{b}{\gcd(a,b)}$ 和 $\frac{a}{\gcd(a,b)}$ 的倍数，使解 $(x,y)$ 均为非负且操作次数最小。  
3. **边界条件处理**：当特解 $x_0$ 或 $y_0$ 为负时，循环调整至非负。  

**数据结构与优化**：  
- 无需复杂数据结构，直接通过数学推导调整解。  
- 优化方向：确保扩展欧几里得算法的时间复杂度为 $O(\log \min(a,b))$，并减少调整次数。  

---

### **题解评分 (≥4星)**  
1. **Gary818（4星）**  
   - 详细讲解扩展欧几里得推导，代码清晰。  
   - 亮点：结合裴蜀定理与模板代码，适合初学者。  
   - 代码片段：  
     ```cpp  
     int exgcd(int a,int b,int &x,int &y) { ... }  
     ```  
2. **灵乌路空（4星）**  
   - 分步讲解定理与证明，代码带详细注释。  
   - 亮点：图文结合解释解的调整过程。  
   - 代码片段：  
     ```cpp  
     while(x<0 || y<0) x += b/gcd, y -= a/gcd;  
     ```  
3. **SoyTony（4星）**  
   - 简洁代码直接应用扩欧并调整解。  
   - 亮点：通过模运算快速找到最小非负解。  
   - 代码片段：  
     ```cpp  
     x = (x0 % (b/gcd) + (b/gcd)) % (b/gcd);  
     ```  

---

### **最优思路或技巧提炼**  
1. **扩展欧几里得核心逻辑**：  
   - 递归边界处理（$b=0$ 时 $x=1, y=0$）。  
   - 递归返回时更新 $x$ 和 $y$：`x = y', y = x' - a/b * y'`。  
2. **解的调整技巧**：  
   - 通过加减 $\frac{b}{\gcd}$ 和 $\frac{a}{\gcd}$ 的倍数，使解满足非负条件。  
   - 数学推导保证调整后的解仍满足原方程。  

---

### **同类型题与算法套路**  
- **常见套路**：  
  - 线性不定方程 $ax + by = c$ 的最小解问题。  
  - 调整解时利用通解公式 $x = x_0 + k \cdot \frac{b}{\gcd(a,b)}$。  
- **类似题目**：  
  1. [P1082 同余方程](https://www.luogu.com.cn/problem/P1082)（扩欧模板题）  
  2. [P4549 裴蜀定理](https://www.luogu.com.cn/problem/P4549)（最小生成元问题）  
  3. [P1516 青蛙的约会](https://www.luogu.com.cn/problem/P1516)（扩欧应用）  

---

### **可视化与算法演示**  
**动画设计**：  
1. **递归过程可视化**：  
   - 展示递归树，高亮当前计算的 $(a, b)$ 和中间解 $(x, y)$。  
   - 颜色标记递归层级，如红色表示当前层，灰色表示已完成层。  
2. **解调整动画**：  
   - 动态显示 $x$ 和 $y$ 的加减过程，背景色提示非负条件是否满足。  
   - 示例：当 $x < 0$ 时，红色闪烁提示需增加 $\frac{b}{\gcd}$。  
3. **复古像素风格**：  
   - 使用 8-bit 字体显示公式，绿色背景模拟老式终端。  
   - 音效：递归返回时播放“哔”声，解调整成功时播放“叮”声。  

**交互控制**：  
- **步进执行**：按空格键单步执行扩欧递归或解调整。  
- **自动模式**：AI 模拟自动推导，速度可调。  

---

### **核心代码实现**  
```cpp  
#include <iostream>
using namespace std;

int exgcd(int a, int b, int &x, int &y) {
    if (!b) { x = 1; y = 0; return a; }
    int d = exgcd(b, a % b, x, y);
    int t = x;
    x = y;
    y = t - (a / b) * y;
    return d;
}

int main() {
    int a, b, x, y;
    cin >> a >> b;
    int gcd = exgcd(a, b, x, y);
    x *= -1; // 转换为 -ax + by = gcd
    while (x < 0 || y < 0) { // 调整至非负
        x += (x < 0) ? (b / gcd) : 0;
        y -= (x >= 0) ? (a / gcd) : 0;
    }
    cout << gcd << "\n" << x << " " << y;
    return 0;
}
```  

---

**总结**：本题通过扩展欧几里得算法求解线性不定方程，结合解的调整技巧找到最小操作次数。关键点在于理解裴蜀定理与扩欧的递归逻辑，并掌握解的非负性调整方法。

---
处理用时：84.06秒
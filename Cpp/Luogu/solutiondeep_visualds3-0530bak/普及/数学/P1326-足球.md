# 题目信息

# 足球

## 题目描述

我们当中有很多热爱中国足球的同学，我们都知道中超（中国足球超级联赛）的规则：

一场比赛中，若获胜（即你的得分严格大于对手得分）则获得 $3$ 的积分，若打平（即你的得分等于对手得分）则获得 $1$ 分，若失败（即你的得分严格小于对手得分）获得 $0$ 积分。

这个问题很简单，假设 $N$ 轮比赛中你一共攻入 $S$ 个球，丢掉 $T$ 个球，那么你可能获得的最大得分和最小得分是多少？

## 样例 #1

### 输入

```
1 1 1
1 1 2```

### 输出

```
1 1
3 2
```

# AI分析结果



**唯一算法分类**  
组合数学  

---

### **题解思路、算法要点与解决难点**  
#### **最大得分**  
1. **贪心策略**：尽可能多赢，每场进1球，剩余丢球集中到一场。  
   - **S < N**：赢S场（1-0），剩余N-S-1场平局，最后1场输（0-T）。若T=0，输场变平局+1分。  
   - **S ≥ N**：赢N-1场（1-0），最后一场进球为`S-(N-1)`，与T比较：  
     - 若`S-(N-1) > T` → 赢+3分  
     - 若`S-(N-1) == T` → 平+1分  
     - 否则 → 输+0分  

2. **关键公式**：  
   - S < N → `3*S + (N-S-1) + (T==0 ? 1 : 0)`  
   - S ≥ N → `3*(N-1) + (条件判断)`  

#### **最小得分**  
1. **策略**：尽可能少赢，利用输和平局：  
   - **S > T**：必须赢1场（S-0），剩余场尽量输（0-1），若输球不足则平局。  
   - **S ≤ T**：可能全输，但需满足`T-S ≥ N`；否则部分平局。  

2. **关键公式**：  
   - S > T → `3 + max(0, N-1-T)`  
   - S ≤ T → `min(3+max(0, N-1-T), max(0, N - (T-S)))`  

#### **解决难点**  
- **边界处理**：T=0时输场变平局，需额外判断。  
- **临界值**：S刚好等于N或T时，需精确比较最后一场结果。  
- **分类讨论**：需细致处理不同情况的得分组合，避免遗漏。  

---

### **题解评分 (≥4星)**  
1. **艮鳖肉 (4.5星)**  
   - 思路清晰，详细分类讨论，代码可读性强。  
   - 特判T=0和S=0等边界情况。  

2. **quantum11 (4星)**  
   - 代码简洁，三目运算符高效处理条件。  
   - 未显式处理T=0，但通过逻辑合并保证正确性。  

3. **无意识躺枪人 (4星)**  
   - 思路明确，分离最大/最小得分讨论，代码结构清晰。  
   - 公式推导准确，逻辑覆盖全面。  

---

### **最优思路或技巧提炼**  
1. **贪心构造**：  
   - **最大化**：每场赢1球，剩余丢球集中处理。  
   - **最小化**：赢1场消耗所有进球，其余场次尽量输或平。  

2. **临界值处理**：  
   - 用`max`和`min`函数简化条件判断，如`max(n-1, min(n, s-t))`。  

3. **数学简化**：  
   - 将复杂条件转化为数学表达式，如`S-(N-1) > T`判断最后一场胜负。  

---

### **同类型题或算法套路**  
- **组合优化**：通过排列组合构造最优/最劣场景。  
- **贪心分配**：资源（进球/丢球）分配到不同场次，求极值。  

---

### **推荐相似题目**  
1. **P1255 数楼梯**（组合数学，递推优化）  
2. **P1036 选数**（组合问题，回溯剪枝）  
3. **P1106 删数问题**（贪心策略，极值构造）  

---

### **个人心得摘录**  
- **George1123**：WA20次后意识到特判n=1的重要性。  
- **Ousmane_Dembele**：通过暴力枚举发现平两场比赢一场得分更低的陷阱。  

---

### **可视化与算法演示**  
**动画方案**：  
1. **像素风格界面**：  
   - 用8-bit风格显示N个场次，每场用格子表示，颜色区分胜负平。  
   - 进球/丢球数用像素数字动态更新。  

2. **关键步骤高亮**：  
   - **最大得分**：  
     1. 分配S个进球到各场（绿色格子），剩余场变灰色（平局）。  
     2. 最后一格红色显示T丢球，若T=0则变黄色（平局）。  
   - **最小得分**：  
     1. 一格红色显示S进球（赢），其余分配丢球（灰色输/黄色平）。  

3. **交互控制**：  
   - 滑块调节S/T/N，实时更新得分计算。  
   - 步进按钮观察分配过程，音效提示胜负平结果。  

**代码片段（核心逻辑）**：  
```cpp
// 最大得分计算
if (s < n) {
    max_score = 3 * s + (n - s - 1);
    if (t == 0) max_score++;
} else {
    max_score = 3 * (n - 1);
    int remain = s - (n - 1);
    if (remain > t) max_score += 3;
    else if (remain == t) max_score += 1;
}
// 最小得分计算
if (s > t) {
    min_score = 3 + max(0, n - 1 - t);
} else {
    int option1 = 3 + max(0, n - 1 - t);
    int option2 = max(0, n - (t - s));
    min_score = min(option1, option2);
}
```

**复古游戏演示**：  
- **Canvas动画**：场次以8-bit格子展示，点击格子显示进球/丢球。  
- **音效**：胜利（8-bit上升音阶），失败（低沉音效），平局（中性提示音）。  
- **自动模式**：AI自动分配进球，动态演示最优路径，类似贪吃蛇AI路径寻找。

---
处理用时：90.49秒
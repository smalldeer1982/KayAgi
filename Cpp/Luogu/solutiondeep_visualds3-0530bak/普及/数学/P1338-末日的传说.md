# 题目信息

# 末日的传说

## 题目描述

只要是参加 jsoi 活动的同学一定都听说过 Hanoi 塔的传说：三根柱子上的金片每天被移动一次，当所有的金片都被移完之后，世界末日也就随之降临了。

在古老东方的幻想乡，人们都采用一种奇特的方式记录日期：他们用一些特殊的符号来表示从 $1$ 开始的连续整数，$1$ 表示最小而 $n$ 表示最大。创世纪的第一天，日历就被赋予了生命，它自动地开始计数，就像排列不断地增加。

我们用 $1-n$ 来表示日历的元素，第一天日历就是：
$$1,2,\ldots,n-2,n-1,n$$
第二天，日历自动变为
$$1,2,\ldots,n-2,n,n-1$$
······每次它都生成一个以前未出现过的“最小”的排列——把它转为 $n+1$ 进制后数的数值最小。

日子一天一天地过着。有一天，一位预言者出现了——他预言道，当这个日历到达某个上帝安排的时刻，这个世界就会崩溃······他还预言到，假如某一个日期的逆序达到一个值 $m$ 的时候，世界末日就要降临。

什么是逆序？日历中的两个不同符号，假如排在前面的那个比排在后面的那个更大，就是一个逆序，一个日期的逆序总数达到 $m$ 后，末日就要降临，人们都期待一个贤者，能够预见那一天到底将在什么时候到来？

## 说明/提示

对于 $10\%$ 的数据有 $n\le10$；

对于 $40\%$ 的数据有 $n\le1000$；

对于 $100\%$ 的数据有 $n\le5\times10^4$。

所有数据均有解。

## 样例 #1

### 输入

```
5 4
```

### 输出

```
1 3 5 4 2
```

# AI分析结果



## 【唯一算法分类】
组合数学

## 【题解思路、算法要点与解决难点】

### 核心思路
构造逆序对数为m的最小字典序排列。通过贪心策略，每次确定当前最小数的位置：若剩余位置能提供足够逆序对，则放最前；否则放最后，并消耗最大可能的逆序对。

### 数学推导
- 剩余k个数时最大逆序对数为 `k*(k-1)/2`
- 当 `剩余逆序对需求m ≤ (k-1)*(k-2)/2` 时，当前数i放最前
- 否则将i放在当前序列末尾，并消耗 `(当前末尾位置 - 起始位置)` 个逆序对

### 解决难点
1. **贪心策略的证明**：需证明每次将数放在最前/最后的决策能保证全局最优
2. **逆序对计算的数学建模**：通过 `(n-i)*(n-i-1)/2` 预判剩余位置的逆序对潜力
3. **线性时间实现**：通过双指针维护当前可插入位置，避免数组移动

### 算法对比
| 方法           | 时间复杂度 | 空间复杂度 | 实现难度 | 适用性       |
|----------------|------------|------------|----------|--------------|
| 贪心双指针     | O(n)       | O(n)       | 易       | 最优解       |
| 划分树查找     | O(nlogn)   | O(n)       | 较难     | 可扩展性较好 |
| 递归构造       | O(n^2)     | O(n)       | 中等     | 教学意义     |

## 【题解评分 (≥4星)】

### 1. zqy1018（5星）
- **亮点**：双指针线性扫描，代码简洁高效
- **核心代码**：
  ```cpp
  for(int i=1;i<=n;i++){
    ll t=(ll)(n-i)*(n-i-1)/2;
    if(t>=m) a[fst++]=i; 
    else a[lst--]=i, m-=(lst-fst+1);
  }
  ```

### 2. ASZIIIS（4星）
- **亮点**：详细数学推导，vector动态维护
- **关键步骤**：
  ```cpp
  for(int i=n-1;i>=0;i--){
    s-=i;
    if(m>s) now=m-s, m=s;
    else now=0;
    printf("%d ",v[now]);
    v.erase(v.begin()+now);
  }
  ```

### 3. ix35（4星）
- **创新点**：三部分分段构造法
- **代码亮点**：
  ```cpp
  for(int s=1;m>0;s++,p--) 
    m -= c=min(s,m);
  cout<<p+c<<' ';
  for(int i=n;i>=p;i--)
    if(i!=p+c) cout<<i<<' ';
  ```

## 【最优思路提炼】
**贪心构造 + 逆序对预判**
1. 初始化双指针fst=1, lst=n
2. 对每个数i从1到n：
   - 计算剩余k=n-i个数的最大逆序对t=k*(k-1)/2
   - 若t≥m：i放fst位置（最小字典序）
   - 否则：i放lst位置，m -= (lst - fst + 1)
3. 最终数组即为所求

## 【同类型题套路】
1. **逆序对构造**：通过贪心分界点确定排列结构
2. **字典序优化**：总在前缀尽可能小的情况下处理后缀
3. **数学预判**：利用组合数公式快速计算剩余可能性

## 【推荐题目】
1. P1908 逆序对（归并排序基础）
2. P1967 货车运输（贪心构造）
3. P1494 组合数学（组合数应用）

## 【可视化设计】
### 动画方案
![逆序对构造动画](https://via.placeholder.com/600x400/FF6B6B/FFFFFF?text=Animation+Demo)
1. **颜色标记**：
   - 红色：当前决策的数
   - 绿色：已确定的前缀
   - 蓝色：待处理的后缀
2. **步进演示**：
   - 显示当前数i，剩余逆序对m
   - 计算并高亮显示 `t=(n-i)*(n-i-1)/2`
   - 箭头指示插入到fst或lst位置
3. **复古像素风格**：
   - 使用16色像素字体显示排列构造过程
   - 音效：放置数时播放8-bit音效，完成时播放胜利音效

### 关键帧示例
```javascript
// 伪代码示例
class Visualization {
  constructor(n, m) {
    this.n = n;
    this.m = m;
    this.fst = 1;
    this.lst = n;
    this.arr = new Array(n+2).fill(0);
  }

  async step(i) {
    const t = (this.n - i) * (this.n - i - 1) / 2;
    if (t >= this.m) {
      this.arr[this.fst++] = i;
      playSound('front.wav');
    } else {
      this.arr[this.lst--] = i;
      this.m -= (this.lst - this.fst + 1);
      playSound('back.wav');
    }
    drawPixelArray(this.arr); // 像素化绘制当前排列
    await sleep(500);
  }
}
```

## 【核心代码实现】
```cpp
#include <cstdio>
typedef long long ll;
ll n, m, a[50005];

int main() {
    scanf("%lld%lld", &n, &m);
    ll fst = 1, lst = n;
    for (int i = 1; i <= n; ++i) {
        ll remain = n - i;
        ll max_rev = remain * (remain - 1) / 2;
        if (max_rev >= m) {
            a[fst++] = i;
        } else {
            a[lst--] = i;
            m -= (lst - fst + 1);
        }
    }
    for (int i = 1; i <= n; ++i)
        printf("%lld ", a[i]);
    return 0;
}
```

---
处理用时：88.56秒
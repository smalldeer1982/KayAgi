# 题目信息

# 小猫

## 题目描述

有 $2n$ 只小猫站成一圈，主人小明想把它们两两之间用绳子绑住尾巴连在一起。同时小明是个完美主义者，不容许看到有两根绳子交叉。请问小明有几种连线方案，可以把让所有小猫两两配对？

方案数很大，仅需输出方案数模 $10^9+7$（一个质数）的值。




## 说明/提示

### 数据范围

- 对于 $60\%$ 的数据，$1\le N \le 100$。
- 对于 $100\%$ 的数据，$1\le N \le 10^5$。

## 样例 #1

### 输入

```
3```

### 输出

```
5```

# AI分析结果



## 数学分类选择
**组合数学**

---

## 题解思路与算法要点

### 核心公式推导
题目等价于 **卡特兰数** 的第 n 项，其递推关系与通项公式为：
```
C(n) = C(2n, n) / (n+1)  或  C(n) = (C(2n, n) - C(2n, n-1)) % MOD
```
**证明思路**：将小猫连成不交叉的线对，等价于在圆上选不相交弦的配对方式。这与 **凸多边形三角划分** 模型一致，可用卡特兰数建模。

### 解决难点
1. **大数阶乘计算**：需预计算阶乘数组 `fact[0..2n]`，每一步取模防止溢出。
2. **模意义下除法**：利用费马小定理将除法转为乘逆元，即 `inv(n!) = fact[n]^(MOD-2) % MOD`。
3. **时间复杂度优化**：预处理阶乘和逆元阶乘数组，组合数计算复杂度 O(1)。

---

## 题解评分（≥4星）

### ⭐⭐⭐⭐ 作者：jiangXxin
- **亮点**：详细推导卡特兰数与出栈次序的映射关系，代码实现高效（快乘+快幂优化）。
- **代码**：预处理阶乘逆元，避免重复计算。

### ⭐⭐⭐⭐ 作者：aakennes
- **亮点**：模块化设计，分离组合数计算与逆元处理，代码可读性强。
- **关键函数**：`Catalan()` 函数直接调用组合数模板。

### ⭐⭐⭐⭐ 作者：___OccDreamer___
- **亮点**：代码简洁，公式推导直击核心（化简组合数表达式），适合快速实现。

---

## 最优思路提炼

1. **模型转换**：将圆上连线问题转化为凸多边形三角划分，直接套用卡特兰数公式。
2. **逆元优化**：利用 `pow(a, MOD-2, MOD)` 计算模逆元，避免除法精度问题。
3. **阶乘预计算**：预存 `fact[0..2n]` 和 `inv_fact[0..n]`，组合数计算复杂度降至 O(1)。

---

## 同类型题与套路

**通用套路**：
- **卡特兰数问题**：括号匹配、出栈顺序、二叉树计数等。
- **组合数优化**：阶乘预计算 + 逆元处理，应对大数取模。

---

## 推荐题目
1. [P1044 栈](https://www.luogu.com.cn/problem/P1044)  
2. [P1641 生成字符串](https://www.luogu.com.cn/problem/P1641)  
3. [P3200 有趣的数列](https://www.luogu.com.cn/problem/P3200)  

---

## 核心代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1e9+7, MAXN = 2e5+10;
typedef long long ll;

ll fact[MAXN], inv_fact[MAXN];

ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

void init(int n) { // 预处理阶乘和逆元
    fact[0] = 1;
    for (int i=1; i<=n; i++) 
        fact[i] = fact[i-1] * i % MOD;
    inv_fact[n] = qpow(fact[n], MOD-2);
    for (int i=n-1; i>=0; i--)
        inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
}

ll catalan(int n) {
    ll res = fact[2*n] * inv_fact[n] % MOD;
    res = res * inv_fact[n] % MOD;
    res = res * qpow(n+1, MOD-2) % MOD;
    return res;
}

int main() {
    int n; cin >> n;
    init(2*n);
    cout << catalan(n);
}
```

---

## 可视化设计（像素风格）

1. **动画流程**：  
   - 步骤1：绘制圆上 2n 个点（像素点阵）。  
   - 步骤2：动态连线（绿色像素），确保不交叉。  
   - 步骤3：右下角同步显示组合数公式计算（如 `C(6,3)/4=5`）。  

2. **音效触发**：  
   - **连线成功**：8-bit 上升音效。  
   - **公式更新**：短促“滴”声。  

3. **Canvas 绘制**：  
   ```javascript
   function drawPixel(x, y, color) {
       ctx.fillStyle = color;
       ctx.fillRect(x*10, y*10, 8, 8); // 8x8 像素块
   }
   ```

---

## 个人心得摘录

> "**调试教训**：阶乘数组要开到 2n，否则 RE！模运算每一步都要加，避免溢出。"  
> —— 作者：Karl_Aurora

---

通过结合数学建模与高效预处理，此题可快速转化为卡特兰数模板问题，代码实现注重模运算细节与阶乘优化。

---
处理用时：75.11秒
# 题目信息

# 小Z的矩阵

## 题目描述

小 Z 最近迷上了矩阵，他定义了一个对于一种特殊矩阵的特征函数 $G$。对于 $N\times N$ 的矩阵 $A$，$A$ 的所有元素均为 $0$ 或 $1$，则 $\displaystyle G(A) = \left(\sum_{i = 1}^n\sum_{j = 1}^n A_{i, j}\cdot A_{j, i}\right) \bmod 2$。举一个例子：

$$
\begin{pmatrix}
1 & 1 & 1\\
0 & 1 & 1\\
1 & 0 & 0\\
\end{pmatrix}
$$

对于上面这个 $3\times 3$ 矩阵 $A$，$G(A)=(1\times 1+1\times 0+1\times 1+0\times 1+1\times 1+1\times 0+1\times 1+ 0\times 1+0\times 0) \bmod 2 = 0$。

当然询问一个矩阵的 $G$ 值实在是太简单了。小Z在给出一个 $N\times N$ 矩阵的同时将给你 $Q$ 个操作，操作描述如下：

- 操作 1：形如 `1 x`，表示将第 $x$ 行的元素全部“翻转”。
- 操作 2：形如 `2 x`，表示将第 $x$ 列的元素全部“翻转”。
- 操作 3：形如一个整数`3`，表示询问当前矩阵的特征值 $G$。

“翻转”的定义为将 $1$ 变成 $0$，将 $0$ 变成 $1$。

## 说明/提示

【数据规模】

- 对于 $30\%$ 的数据，$N\le 100$，$Q\le 10^5$。

- 对于 $100\%$ 的数据，$N\le 1,000$，$Q \le 5\times 10^5$。

## 样例 #1

### 输入

```
3 12
1 1 1
0 1 1
1 0 0
3
2 3
3
2 2
2 2
1 3
3
3
1 2
2 1
1 1
3
```

### 输出

```
01001
```

# AI分析结果



## 数学分类：数论

---

### **题解思路与算法要点**
1. **核心推导**：  
   所有非对角线元素（i≠j）的贡献为偶数，模2后消失。故G(A)仅由对角线元素之和的奇偶性决定。
2. **操作影响**：  
   每次翻转行或列必然改变对角线元素中的一个（即A[x][x]），导致总和的奇偶性反转。
3. **实现优化**：  
   维护一个布尔变量记录当前对角线奇偶性，操作1/2直接翻转该变量，操作3输出其值。

---

### **题解评分（≥4星）**
1. **o0数学迷0o（5星）**  
   - **亮点**：代码极简，直接维护奇偶变量；读入时忽略非对角线元素，优化输入效率。
   - **代码片段**：  
     ```cpp
     for(int i=0;i<n;++i)
         for(int j=0;j<n;++j){
             cin>>x;
             if(i==j)g^=x; // 直接异或统计奇偶性
         }
     ```
2. **judgejudge（4星）**  
   - **亮点**：详细证明非对称元素贡献抵消，强调奇偶性反转的逻辑。
   - **心得**：“每进行一次翻转，奇偶性必转变”直击本质。
3. **whc2020（4星）**  
   - **亮点**：通过代数展开证明仅对角线有效，代码结构清晰。
   - **优化**：读入时仅处理对角线元素，避免存储整个矩阵。

---

### **最优思路提炼**
1. **关键公式**：  
   $$G(A) \equiv \sum_{i=1}^n A_{i,i} \pmod{2}$$
2. **操作等价性**：  
   翻转行x或列x → 反转A[x][x] → 奇偶性取反。
3. **代码核心**：  
   维护变量`g`，初始为对角线奇偶性，每次操作1/2执行`g = !g`。

---

### **同类型题与套路**
- **常见套路**：模2运算下的奇偶性反转、对称性问题抵消贡献。
- **类似题目**：  
  1. [洛谷 P1214 等差数列](https://www.luogu.com.cn/problem/P1214)（奇偶性分析）  
  2. [洛谷 P3914 染色问题](https://www.luogu.com.cn/problem/P3914)（组合数模2简化）  
  3. [洛谷 P2119 魔法阵](https://www.luogu.com.cn/problem/P2119)（对称贡献抵消）

---

### **可视化与算法演示**
**8位像素风格动画设计**：  
1. **矩阵绘制**：Canvas绘制N×N网格，对角线元素用黄色像素块标记。  
2. **操作演示**：  
   - **翻转行/列**：整行/列像素短暂闪烁红色，对角线元素变为绿色（翻转后状态）。  
   - **奇偶变量**：右侧显示当前`g`值（0/1），每次翻转播放8位“哔”声。  
3. **自动模式**：AI模拟连续操作，高亮每一步影响的元素和`g`变化。

**关键代码片段（伪代码）**：  
```javascript
// 绘制矩阵与对角线
function drawMatrix() {
    for(let i=0; i<n; i++) {
        for(let j=0; j<n; j++) {
            if(i == j) ctx.fillStyle = '#FFFF00'; // 黄色对角线
            else ctx.fillStyle = '#0000FF';        // 蓝色非对角线
            ctx.fillRect(i*10, j*10, 8, 8);
        }
    }
}
// 翻转行x动画
function flipRow(x) {
    playSound('beep'); // 播放音效
    highlightRow(x, '#FF0000', () => { // 红色闪烁
        g = !g;
        updateDisplay();
    });
}
```

---

### **个人心得摘录**
- **loi_hjh**：“第一次没写对角线的翻转直接TLE，意识到必须聚焦对角线。”  
- **tcswuzb**：“暴力模拟行不通，数学推导才是正解，节省了O(n)操作时间。”  

---

### **核心代码实现**
**o0数学迷0o的最优代码**：  
```cpp
#include <iostream>
using namespace std;
int main() {
    ios::sync_with_stdio(0);
    int n, q, g = 0, x;
    cin >> n >> q;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j) {
            cin >> x;
            if (i == j) g ^= x; // 仅统计对角线奇偶性
        }
    while (q--) {
        cin >> x;
        if (x == 3) cout << g;
        else cin >> x, g ^= 1; // 操作1/2反转奇偶性
    }
    return 0;
}
```

---
处理用时：80.33秒
# 题目信息

# 赤壁之战

## 题目描述

赤壁之战，黄盖率舰满载薪草膏油诈降曹军。

受庞统所授的连环计，曹军战船之间由铁索相连，没有两艘战船在同一位置，也没有铁索两两相交或穿过战船。每艘船都有其一定的战略价值。

为了保证达到破坏效果，黄盖需要保证被点燃的曹军船只两两之间都有铁索连接。他希望找到一种方案点燃总价值尽可能大的战船。


## 说明/提示

#### 【数据规模】

对于 $50\%$ 的数据，保证 $N$，$M \le 10$。

对于 $100\%$ 数据，保证 $N \le 450$，$M \le 900$，$V_i \le 6000$。

#### 【注意】

题目中的每句话（除了第一段）都有作用。

## 样例 #1

### 输入

```
4 6
100
5000
1000
2000
1 2
1 3
1 4
2 3
2 4
3 4```

### 输出

```
8100```

## 样例 #2

### 输入

```
6 8
1500
1000
100
2000
500
300
1 2
1 3
1 4
2 4
3 5
4 5
4 6
5 6```

### 输出

```
4500```

# AI分析结果



1. **唯一算法分类**  
   组合数学

2. **综合分析与结论**  
   - **核心难点**：发现平面图性质（完全子图最多4个节点）的隐藏条件，将NP难的最大团问题转化为可暴力枚举的组合数学问题  
   - **关键公式推导**：平面图完全子图节点数 ≤4 → 只需枚举1/2/3/4节点完全图  
   - **可视化设计**：  
     - 动画步骤：以像素风格展示边枚举过程（如选中边u-v后，高亮黄色），检测共同邻接点（高亮绿色），最终显示最大价值（红色闪烁）  
     - 颜色标记：当前边（黄色），候选点（绿色），完全子图（红色边框）  
     - 8位音效：找到新完全图时播放上升音阶，更新最大值时播放胜利音效

---

### 题解清单 (≥4星)
#### 1. zhuaiballl (★★★★☆)
**亮点**：  
- 发现平面图性质，将复杂度从指数级降至O(m²)  
- 关键代码片段：
```cpp
// 枚举所有边的三元组合
for(int i=0;i<m;i++) {
    int res=val[u[i]]+val[v[i]];
    for(int j=1;j<=n;j++) // 找共同邻接点
        if(conn[v[i]][j]&&conn[u[i]][j])
            ans=max(ans,res+val[j]);
    // 枚举另一条边构成四边形
    for(int j=0;j<i;j++)
        if(conn[u[i]][u[j]]&&conn[u[i]][v[j]]&&...)
            ans=max(ans,res+val[u[j]]+val[v[j]]);
}
```

#### 2. osfly (★★★☆☆)  
**优化点**：  
- 链式前向星存储加速邻接查询  
- 使用check函数验证完全图性质

#### 3. 06ray (★★★☆☆)  
**特色**：  
- 经典DFS回溯框架  
- 适用小规模数据教学演示

---

### 最优思路提炼
**关键技巧**：  
1. **平面图性质利用**：通过"铁索不相交"条件推出完全图最大大小为4  
2. **分层枚举策略**：  
   - 单点 → 直接取最大值  
   - 边 → 取两端点价值  
   - 三元组 → 找边的共同邻接点  
   - 四边形 → 找两条边构成完全图  
3. **剪枝优化**：仅需遍历边组合，避免全节点枚举

---

### 同类题目推荐
1. **P1991 无线通讯网**（平面图最小生成树特性）  
2. **P3887 世界国的地形**（完全子图计数）  
3. **P4563 棋盘守卫**（组合枚举+图结构分析）

---

### 个人心得摘录
> "一开始我是不信这图是平面图的...后来翻了翻过了的提交，都是0ms，果断水题水过" —— zhuaiballl  
> **启示**：注意题目中的几何描述往往隐含复杂度限制，需结合样例特征验证猜想

---

### 可视化核心代码（JS伪代码）
```javascript
// 像素风动画初始化
const canvas = initCanvas(640, 480, 8); // 8位风格画布
const edges = loadEdges(); // 加载边数据

function animate() {
    let maxVal = 0;
    edges.forEach((e1, i) => {
        highlightEdge(e1, YELLOW); // 当前边高亮
        let sum = e1.value;
        // 找三元组
        nodes.forEach(node => {
            if(connected(e1, node)) {
                highlightNode(node, GREEN);
                let curr = sum + node.value;
                if(curr > maxVal) playSound('up');
                maxVal = Math.max(maxVal, curr);
            }
        });
        // 找四边形
        edges.slice(0,i).forEach(e2 => {
            if(isClique(e1, e2)) {
                drawCliqueBorder([e1, e2], RED);
                let curr = sum + e2.value;
                if(curr > maxVal) playSound('win');
                maxVal = Math.max(maxVal, curr);
            }
        });
    });
}
```

---

### 复古游戏化设计
1. **像素元素**：  
   - 船→ 8x8像素方块，铁索→ 两像素宽棕色线条  
   - 价值显示→ 顶部16x16数字LED样式计数器  
2. **音效设计**：  
   - 边选中：FC鼓点音  
   - 发现新组合：8-bit上升琶音  
   - 打破记录：超级马里奥金币音  
3. **自动演示模式**：  
   ```python
   def auto_solve():
       while not all_checked:
           yield next_edge_pair() # 生成器逐步执行
   ```

---
处理用时：86.98秒
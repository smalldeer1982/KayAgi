# 题目信息

# 摆石子

## 题目背景

我们伟大的KK突然想到了一个很高（Shā）明（bī）的问题。


## 题目描述

我们伟大的KK在N条水平线与M条竖直线构成的网格中（KK的自创坐标系），放K枚石子，每个石子都只能放在网格的交叉点上。现在KK想知道在最优的摆放方式下，最多可以找到多少四边平行于坐标轴的长方形，而且KK要求它的四个角上都恰好放着一枚石子。


## 说明/提示

50%的数据    0<N，M≤30；

100%的数据   0<N，M≤30000  K≤N\*M。


## 样例 #1

### 输入

```
3 3 8```

### 输出

```
5```

# AI分析结果



# 摆石子题解分析

## 算法分类
**组合数学**

## 题解思路与解决难点
### 核心数学推导
1. **完全矩形计算**：  
   在 $a \times b$ 的完全矩形中，可形成的矩形数量为：
   $$
   C(a,2) \times C(b,2) = \frac{a(a-1)}{2} \times \frac{b(b-1)}{2}
   $$
   其中 $C(n,2)$ 表示选两个点的组合数，对应矩形的两边选择。

2. **不完全矩形计算**：  
   当石子排列为 $i$ 行满列（每行 $x$ 个）和 $y$ 个余下石子时，总贡献为：
   $$
   \underbrace{C(x,2) \times C(i,2)}_{\text{完整部分}} + \underbrace{C(y,2) \times x}_{\text{余数部分}}
   $$

### 解决难点对比
- **枚举方向优化**：需交换 $n,m$ 保证 $n \leq m$ 以减少枚举次数（Alarm5854）
- **余数处理**：部分题解未正确处理余数行与列的关系（彭天宇代码有冗余循环）
- **边界条件**：当 $k/i > m$ 时需要跳过非法情况（phigy 的 `continue` 条件判断）

## 题解评分（≥4★）
| 作者         | 星级 | 亮点                                                                 |
|--------------|------|----------------------------------------------------------------------|
| Alarm5854    | ★★★★☆ | 代码清晰、数学推导完整，处理了行列交换优化                           |
| phigy        | ★★★★☆ | 公式简洁，引入 `long long` 防溢出                                    |
| bluewindde   | ★★★★☆ | 公式推导最严谨，通过容斥思想消除重复计算                             |

## 最优思路提炼
1. **贪心布局**：石子应尽量形成完整矩形，剩余石子补在单行缺口处。
2. **枚举优化**：遍历行数 $i \in [1, \min(n,k)]$，计算对应的列数 $x = \lfloor k/i \rfloor$ 和余数 $y = k \% i$。
3. **组合计数**：用组合数公式分别计算完整部分和缺口部分的贡献。

## 同类型题套路
- **组合计数公式**：涉及排列组合的二维前缀和计算
- **贪心枚举方向**：通过行列交换减少枚举次数
- **余数贡献分离**：将问题分解为完全部分和不完全部分分别计算

## 推荐练习题
1. [P1492 猩猩散步](https://www.luogu.com.cn/problem/P1492)（组合数路径统计）
2. [P2822 组合数问题](https://www.luogu.com.cn/problem/P2822)（组合数取模性质）
3. [P2789 直线交点数](https://www.luogu.com.cn/problem/P2789)（枚举+组合数学）

---

## 核心代码实现
```cpp
#include <algorithm>
#define ll long long
using namespace std;

int main() {
    ll n, m, k, ans = 0;
    cin >> n >> m >> k;
    if(n > m) swap(n, m); // 关键优化：保证n<=m
    
    for(ll i = 1; i <= min(n, k); ++i) {
        ll x = k / i;    // 完整列数
        ll y = k % i;    // 余下石子数
        
        if(y && x >= m) continue; // 列数超限跳过
        
        // 计算两部分的组合数贡献
        ll full = x*(x-1)/2 * i*(i-1)/2;
        ll remain = y*(y-1)/2 * x;
        ans = max(ans, full + remain);
    }
    cout << ans;
}
```

---

## 可视化设计
### 复古像素风格演示
1. **网格绘制**：  
   ```javascript
   const canvas = document.createElement('canvas');
   ctx.fillStyle = '#8B8B8B'; // 网格线颜色（灰色）
   for(let i=0; i<=cols; i++) ctx.fillRect(i*16, 0, 1, rows*16);
   ```

2. **石子动画**：  
   ```javascript
   function drawStone(x, y) {
       ctx.fillStyle = '#FF5555'; // 红色石子
       ctx.fillRect(x*16+3, y*16+3, 10, 10);
       playSound('blip'); // 播放放置音效
   }
   ```

3. **公式推导演示**：  
   ```javascript
   // 显示当前计算步骤
   function showFormula(i, x, y) {
       formulaDiv.innerHTML = 
           `C(${x},2)*C(${i},2) + C(${y},2)*${x} = 
           ${x*(x-1)/2}*${i*(i-1)/2} + ${y*(y-1)/2}*${x}`;
   }
   ```

### 交互功能
- **步进控制**：空格键单步执行枚举过程
- **音效系统**：使用 Web Audio API 播放 8-bit 音效
- **自动推导模式**：按 A 键启动 AI 自动推导，以最优路径演示计算过程

---

## 个人心得摘录
> "被 90 分卡了半小时才发现没处理 n>m 的情况，交换行列后立即AC。组合数学题一定要注意对称性！" —— Alarm5854

> "最初用暴力枚举 O(nm) 的写法，发现完全不可行后才转向数学推导。数学题最重要的是先找规律再写代码。" —— phigy

---
处理用时：77.59秒
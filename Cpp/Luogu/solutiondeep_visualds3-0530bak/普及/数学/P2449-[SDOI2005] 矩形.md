# 题目信息

# [SDOI2005] 矩形

## 题目描述

现在我们在一个平面上画了n个矩形。每一个矩形的两边都与坐标轴相平行，且矩形定点的坐标均为整数。现我们定义满足如下性质的图形为一个块：

1.每一个矩形都是一个块；

2.如果两个块有一段公共的部分，那么这两个块就会形成一个新的块，否则这两个块就是不同的。

示例：

图1中的矩形形成了两个不同的块。图2中的矩形形成了一个块。

 ![](https://cdn.luogu.com.cn/upload/pic/1579.png) 

任务：

请写一个程序：

1.从文本文件PRO.IN中读入各个矩形的顶点坐标；

2.找出这些矩形中不同的块的数目；

3.把结果输出到文本文件PRO.OUT中。


## 样例 #1

### 输入

```
9

0 3 2 6

4 5 5 7

4 2 6 4

2 0 3 2

5 3 6 4

3 2 5 3

1 4 4 7

0 0 1 4

0 0 4 1

```

### 输出

```
2```

# AI分析结果



# 算法分类
**并查集**

---

## 综合分析与结论

### 核心思路
题目本质是求矩形连通块的数量，核心步骤：
1. **判断矩形相交**：通过投影重叠排除不相关情况，并处理边角接触的边界条件
2. **合并连通块**：使用并查集或BFS维护连通性
3. **统计结果**：最终统计根节点数量或未被访问的连通块

### 关键难点
**相交判断的精确性**：需排除仅边角接触的情况。正确条件为：
- X轴投影重叠：`max(A.x1, B.x1) < min(A.x2, B.x2)`
- Y轴投影重叠：`max(A.y1, B.y1) < min(A.y2, B.y2)`
- 排除边角点重合的特殊情况（如A的右下角与B的左上角重合）

### 可视化设计
1. **动画方案**：
   - **矩形绘制**：在Canvas中以不同颜色渲染各矩形块
   - **合并高亮**：当检测到相交时，将两矩形颜色统一为同一色块
   - **操作标记**：用闪烁边框高亮当前比较的矩形对
2. **像素风格**：
   - 采用8-bit色块表示矩形，合并时触发8-bit音效
   - 网格坐标映射到Canvas像素区域，支持缩放观察细节
3. **交互控制**：
   - 步进模式：手动触发每对矩形的判断与合并
   - 自动模式：按排序顺序快速演示合并过程
   - 速度调节：控制判断间隔（50ms~2s）

---

## ≥4星题解推荐

### 1. Ajwallet（⭐⭐⭐⭐⭐）
- **亮点**：并查集实现简洁，判断条件精准，边输入边合并优化循环
- **代码片段**：
  ```cpp
  bool check(node x, node y) {
      if ((x.x2<y.x1||y.x2<x.x1) || (x.y2<y.y1||y.y2<x.y1)) return false;
      if ((x.x1==y.x2||x.x2==y.x1) && (x.y1==y.y2||x.y2==y.y1)) return false;
      return true;
  }
  ```

### 2. Up_Xu（⭐⭐⭐⭐）
- **亮点**：BFS实现直观，队列处理连通块，避免并查集路径压缩
- **代码片段**：
  ```cpp
  void bfs(int x) {
      q.push(x);
      while(!q.empty()) {
          int id = q.front(); q.pop();
          for(int i=x+1; i<=n; i++)
              if (!f[i] && check(a[id], a[i])) 
                  f[i]=1, q.push(i);
      }
  }
  ```

### 3. cyngugugu（⭐⭐⭐⭐）
- **亮点**：排序优化减少比较次数，Y轴排序后仅对比后续矩形
- **代码片段**：
  ```cpp
  sort(a+1, a+1+n, cmp); // 按y1排序
  for(int i=1; i<=n; i++) 
      for(int j=i+1; j<=n; j++) 
          if (check(a[i],a[j])) merge(i,j);
  ```

---

## 最优技巧提炼

### 关键判断逻辑
```cpp
// 投影重叠判断
bool isOverlap = (max(A.x1, B.x1) < min(A.x2, B.x2)) 
              && (max(A.y1, B.y1) < min(A.y2, B.y2));
// 排除边角接触
bool isEdgeCase = (A.x1==B.x2 || A.x2==B.x1) 
               && (A.y1==B.y2 || A.y2==B.y1);
return isOverlap && !isEdgeCase;
```

### 并查集优化
- **路径压缩**：`find`函数递归优化父节点指向
- **边输入边合并**：每读入新矩形立即与之前所有矩形比较

---

## 类似题目推荐
1. [P2330 矩形覆盖](https://www.luogu.com.cn/problem/P2330) - 矩形覆盖与分组
2. [P3958 奶酪](https://www.luogu.com.cn/problem/P3958) - 三维连通性判断
3. [LeetCode 200. 岛屿数量](https://leetcode.com/problems/number-of-islands/) - 二维连通块基础

---

## 个人心得摘录
> "调试时发现边角接触判断遗漏，导致WA。通过绘制测试案例，明确必须同时排除X和Y轴的单边接触情况。" —— Ajwallet

---

## 核心代码实现（Ajwallet版）
```cpp
#include<cstdio>
#define r(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
int f[7001],n,ans;
struct node { int x1,y1,x2,y2; } v[7001];

int find(int x) { return x==f[x] ? x : f[x]=find(f[x]); }

bool check(node x, node y) {
    if ((x.x2<y.x1||y.x2<x.x1) || (x.y2<y.y1||y.y2<x.y1)) return false;
    if ((x.x1==y.x2||x.x2==y.x1) && (x.y1==y.y2||x.y2==y.y1)) return false;
    return true;
}

int main() {
    scanf("%d",&n);
    r(i,1,n) {
        scanf("%d%d%d%d",&v[i].x1,&v[i].y1,&v[i].x2,&v[i].y2);
        f[i] = i;
        r(j,1,i-1) 
            if (check(v[i],v[j]) && find(i)!=find(j))
                f[find(i)] = find(j);
    }
    r(i,1,n) ans += (f[i]==i);
    printf("%d",ans);
}
```

---

## 可视化演示设计
```html
<canvas id="demo" width="800" height="600"></canvas>
<script>
// 伪代码示例
class RectViz {
    constructor() {
        this.ctx = document.getElementById("demo").getContext("2d");
        this.rects = loadRects(); // 加载矩形数据
        this.colors = generateColors(); // 分配颜色
    }
    
    drawStep(i, j) {
        this.highlightPair(i, j); // 黄色边框高亮当前比较对
        if (checkOverlap(this.rects[i], this.rects[j])) {
            this.mergeColor(i, j); // 合并颜色
            playSound('merge'); // 触发合并音效
        }
    }
    
    autoPlay() {
        for (let i=0; i<n; i++) {
            for (let j=0; j<i; j++) {
                this.drawStep(i, j);
                await sleep(speed);
            }
        }
    }
}
</script>
```

---
处理用时：179.29秒
# 题目信息

# 《瞿葩的数字游戏》T2-多边形数

## 题目背景

数字王国里有一类特殊的数，它们叫做多边形数。并且国王 $1$ 规定数字间的联姻只能在同为一种多边形数中进行。（请不要吐槽这个规定……）

瞿葩对这个现象十分好奇，见 $36$ 和 $10$ 这一对情侣在散步，便上前询问 $36$ 它是什么多边形数。可是 $36$ 拍拍脑门，想了想说：“我也不知道啊，你去问问国王吧。”

看来国民们并不知道自己是什么多边形数啊，国王 $1$ 急的发愁。国王 $1$ 只知道多边形数怎么计算，但是多边形数要怎么给国民做解释呢，干脆这样解释吧：可以排成正多边形的整数都是多边形数。当然多边形数可以分为三边（角）形数、四边形数（正方形数）、五边形数、六边形数……


## 题目描述

**此题为规律题，请自行寻找规律，以锻炼数学归纳能力！！**

我们拿三角形数做例子：图中的 $1$、$3$、$6$、$10$ 就是三角形数。

 ![](https://cdn.luogu.com.cn/upload/pic/1742.png) 

任务：求出 $N$ 是哪一种多边形数（假设 $N$ 是 $K$ 边形数），比如我们求出 $36$ 是三边形数和四边形数（貌似叫做三角形数和正方形数呵）。若不是多边形数，输出 Poor + 该数字。若同时是多种多边形数，输出最小的一个和第二小的一个。每个读入文件里有 $ng$ 组数据。


## 说明/提示

### 数据范围及约定

对于 $20\%$ 的数据，$1 \le K_1,K_2 \le 6$；

对于 $100\%$ 的数据， $1 \le N \le 10^6$，$1 \le ng \le 10^2$。

如果同时是多种多边形数，设 $K_1$ 为最小的 $K$，$K_2$ 为次小的 $K$。

国王 $1$：“你可以发现四边形数（正方形数）就是平方数这个规律吗？为方便理解，我给出前几个多边形数表。”（表中可以看出，正六边形不包括正中心的那个点，以此类推）

| 自然数 | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 三角形数 | $1$ | $3$ | $6$ | $10$ | $15$ | $21$ | $28$ | $36$ |
| 正方形数 | $1$ | $4$ | $9$ | $16$ | $25$ | $36$ | $49$ | $64$ |
| 五边形数 | $1$ | $5$ | $12$ | $22$ | $35$ | $51$ | $70$ | $92$ |
| 六边形数 | $1$ | $6$ | $15$ | $28$ | $45$ | $66$ | $91$ | $120$ |


## 样例 #1

### 输入

```
2
36
1000000
```

### 输出

```
3 4
4 204
```

# AI分析结果



### 唯一算法分类
**数论**

---

### 综合分析与结论
#### 核心思路与数学推导
多边形数通项公式为：  
$$N = k + \frac{(m-2) \cdot k \cdot (k-1)}{2}$$  
变形得到：  
$$m = \frac{2(N-k)}{k(k-1)} + 2$$  
**关键推导步骤**：
1. 枚举可能的项数 k（每个k对应一列）
2. 检查 (N - k) 是否能被 k(k-1)/2 整除
3. 若整除则计算对应的边数 m

#### 解决难点与优化
- **时间复杂度优化**：将枚举范围缩小到 $\sqrt{2N}$，利用多边形数增长速度的特性
- **数学变形技巧**：将原式转化为整除判断形式，避免浮点运算
- **倒序枚举**：优先找到较大的k值对应更小的m值，便于快速找到最优解

#### 可视化设计思路
1. **像素风格动画**：用 16 色块表示数值变化，每步枚举k时高亮当前k值
2. **公式推导演示**：分步展开通项公式变形过程，用不同颜色标记分子分母
3. **自动演示模式**：
   - 黄色块表示当前枚举的k值
   - 绿色闪烁表示找到有效解
   - 红色标记越界情况

---

### 题解评分（≥4星）
#### 1. lukelin（⭐⭐⭐⭐⭐）
**亮点**：
- 倒序枚举k值快速找到最小m
- 代码简洁高效（时间复杂度O(√N)）
- 处理特例逻辑清晰

#### 2. AlexandreLea（⭐⭐⭐⭐）
**亮点**：
- 完整推导通项公式
- 优先队列维护前两小值
- 数学证明过程详尽

#### 3. reclusive（⭐⭐⭐⭐）
**亮点**：
- 因数分解优化思路
- 预处理2N的因数减少计算量
- 使用优先队列维护结果

---

### 最优思路/技巧提炼
#### 关键数学技巧
```python
# 核心判断逻辑
for k in reversed(range(2, sqrt(2N))):
    denominator = k*(k-1)//2
    if (N - k) % denominator == 0:
        m = (N - k) // denominator + 2
```

#### 代码实现要点
```cpp
long long sum = 1;
for (int k = 2; ; ++k) {
    if (sum + k > x) break;
    int lft = x - k;
    if (!(lft % sum)) {
        int ans = lft / sum + 2;
        // 维护最小两个答案
    }
    sum += k; 
}
```

---

### 同类型题与套路
**通用数论套路**：
1. 数列通项公式推导
2. 因数分解优化枚举
3. 整除条件转化

**推荐题目**：
1. P1214 [USACO1.4] 等差数列 Arithmetic Progressions
2. P2423 [HEOI2012] 朋友圈
3. P1495 曹冲养猪

---

### 个人心得摘录
> "这道题让我意识到数学公式变形的重要性，将原式转化为整除判断形式是关键突破" —— lukelin  
> "调试时发现k=1会导致除以0，特判处理后才AC" —— dsyfb_437

---

### 可视化方案设计
#### 像素化演示流程
```javascript
// 初始化Canvas（320x240 16色）
const canvas = document.getElementById("demo");
const ctx = canvas.getContext('2d');
const palette = ["#000","#00F","#0F0","#FF0","#F00"]; // 16色经典调色板

function drawStep(k, status) {
    // 绘制当前k值方块（状态颜色不同）
    ctx.fillStyle = palette[status];
    ctx.fillRect(k*16 % 320, Math.floor(k/20)*16, 16, 16);
}

// 自动演示逻辑
let currentK = Math.sqrt(2*N);
const timer = setInterval(() => {
    if(currentK < 2) clearInterval(timer);
    // 计算并绘制当前步骤...
}, 300);
```

#### 音效设计
- **正确解**：8-bit 上升音阶（100Hz→800Hz）
- **错误解**：短促方波（200Hz 50ms）
- **背景音乐**：芯片音乐版《卡农》片段循环

---

### 最终代码参考
```cpp
#include <cstdio>
#include <cmath>

int main() {
    int T, x;
    scanf("%d", &T);
    while(T--) {
        scanf("%d", &x);
        if(x == 1) { puts("3 4"); continue; }
        if(x == 2) { puts("Poor2"); continue; }
        
        int ans1 = 0, ans2 = 0;
        long long sum = 1;
        for(int k=2; ; ++k) {
            if(sum + k > x) break;
            int remainder = x - k;
            if(remainder % sum == 0) {
                int m = remainder / sum + 2;
                if(m >=3) {
                    if(!ans1 || m<ans1) {
                        ans2 = ans1; ans1 = m;
                    } else if(!ans2 || m<ans2) {
                        ans2 = m;
                    }
                }
            }
            sum += k;
        }
        if(ans1) printf("%d", ans1);
        if(ans2) printf(" %d", ans2);
        puts(ans1 ? "" : "Poor%d\n");
    }
    return 0;
}
```

---
处理用时：75.26秒
# 题目信息

# [HNOI2008] 越狱

## 题目描述

监狱有 $n$ 个房间，每个房间关押一个犯人，有 $m$ 种宗教，每个犯人会信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。

答案对 $100,003$ 取模。

## 说明/提示

#### 样例输入输出 1 解释

| 状态编号 | 1 号房间 | 2 号房间 | 3 号房间 |
| :--------: | :--------: | :-------: | :--------: |
| 1 | 信仰 1 | 信仰 1 | 信仰 1 |
| 2 | 信仰 1 | 信仰 1 | 信仰 2 |
| 3 | 信仰 1 | 信仰 2 | 信仰 2 |
| 4 | 信仰 2 | 信仰 1 | 信仰 1 |
| 5 | 信仰 2 | 信仰 2 | 信仰 2 |
| 6 | 信仰 2 | 信仰 2 | 信仰 1 |

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \le m \le 10^8$，$1 \le n \le 10^{12}$。

## 样例 #1

### 输入

```
2 3
```

### 输出

```
6```

# AI分析结果



---

## 唯一算法分类  
**组合数学**

---

## 综合分析与结论  
### 核心思路  
通过补集思想计算总状态数 $m^n$ 减去相邻均不同的状态数 $m \cdot (m-1)^{n-1}$，结合快速幂与取模运算处理超大数据范围。

### 关键公式推导  
1. **总状态数**：每个房间有 $m$ 种选择，总共有 $m^n$ 种可能  
2. **不越狱状态数**：  
   - 第一个房间有 $m$ 种选择  
   - 后续每个房间需与前一个不同，有 $(m-1)$ 种选择  
   - 总计 $m \cdot (m-1)^{n-1}$ 种合法状态  
3. **最终公式**：  
   $$\text{ans} = \left( m^n - m \cdot (m-1)^{n-1} \right) \mod 100003$$

### 解决难点  
- **指数爆炸**：通过快速幂将 $O(n)$ 复杂度降至 $O(\log n)$  
- **负数取模**：计算结果可能为负数，需先加模数再取模  
- **数据类型**：使用 `long long` 避免溢出

---

## 题解清单（评分≥4星）  
### 1. 蒟蒻初音ミク（5星）  
**亮点**：  
- 代码结构清晰，快速幂函数单独封装  
- 正确处理负数取模  
- 注释详细，可读性强  

**核心代码**：  
```cpp
ll qmi(ll a, ll b) {
    if(b == 0) return 1;
    return (b & 1) ? pow(qmi(a, b>>1)) * (a%mod) % mod 
                   : pow(qmi(a, b>>1));
}
```

### 2. Ezios（4.5星）  
**亮点**：  
- 详细数学推导配图说明相邻选择逻辑  
- 模板化快速幂函数，支持泛型  

**可视化亮点**：  
```cpp
template<typename T>
T fast_pow(T base, T exp) { // 模板化快速幂
    T result = 1;
    while (exp > 0) {
        if (exp & 1) result = (result * base) % mod;
        base = (base * base) % mod;
        exp >>= 1;
    }
    return result;
}
```

### 3. K2sen（4星）  
**亮点**：  
- 最短代码实现（仅15行）  
- 直接使用位运算优化快速幂  

**代码特色**：  
```cpp
ll pow(ll a,ll b){
    ll ans=1; a%=mod;
    while(b){
        if(b&1) ans=ans*a%mod;
        a=a*a%mod; b>>=1;
    }
    return ans;
}
```

---

## 最优思路提炼  
### 核心技巧  
1. **补集思想**：将问题转化为总状态数减去非法状态数  
2. **快速幂优化**：使用二进制分解实现 $O(\log n)$ 复杂度  
3. **负数处理**：`(ans % mod + mod) % mod` 保证结果非负  

### 数学思维突破  
当直接计算目标事件困难时，可逆向计算其补集。例如：  
- 计算「至少一次越狱」等价于「全体情况 - 永不越狱情况」  
- 类似问题：抛硬币至少出现一次正面的概率 = 1 - 全部反面的概率  

---

## 同类题目推荐  
1. **P1403 约数研究**（快速计算累计约数个数）  
2. **P1313 计算系数**（组合数+快速幂解决二项式展开）  
3. **P2520 斐波那契数列**（矩阵快速幂优化递推）  

---

## 个人心得摘录  
> "一开始想用动态规划逐个房间推导，但发现 $n \leq 10^{12}$ 后立刻转向数学公式推导。这题教会我：面对指数级数据范围，优先考虑是否存在闭式解或数学优化技巧。" —— 作者：Undefined_R

---

## 可视化与算法演示  
### 动画设计方案  
1. **总状态计算**：  
   - 用像素方块表示房间，从右向左逐个填充颜色（每色代表一种宗教）  
   - 每个方块填充时播放 8-bit 音效，右上角显示当前幂次 $m^k$  

2. **快速幂演示**：  
   - 分解指数为二进制形式（如 $13 = 1101_2$）  
   - 高亮当前处理的二进制位，显示对应的中间结果  
   - 例如计算 $3^{13}$：  
     ```
     3^13 = 3^(8+4+1) = 3^8 * 3^4 * 3^1
     ```

3. **负数修正**：  
   - 显示相减后的负数结果时，用红色闪烁提示  
   - 自动加上模数 100003 后变为绿色  

### 复古风格实现  
```javascript
// 示例：Canvas 绘制快速幂过程
function drawQuickPow(ctx, base, exp) {
    let x = 50, y = 100;
    ctx.fillStyle = "#FF69B4"; // 粉红色像素块
    while (exp > 0) {
        if (exp & 1) {
            ctx.fillRect(x, y, 20, 20); // 绘制当前位激活
            playSound('beep1'); // 8-bit 音效
        }
        x += 30;
        exp >>= 1;
    }
}
```

---

## 核心代码实现  
```cpp
#include <cstdio>
#define ll long long
const int mod = 100003;

ll qpow(ll a, ll b) {
    ll res = 1;
    a %= mod;
    while (b) {
        if (b & 1) res = (res * a) % mod;
        a = (a * a) % mod;
        b >>= 1;
    }
    return res;
}

int main() {
    ll m, n;
    scanf("%lld%lld", &m, &n);
    ll total = qpow(m, n);
    ll valid = (m % mod) * qpow(m-1, n-1) % mod;
    ll ans = (total - valid + mod) % mod;
    printf("%lld", ans);
    return 0;
}
```

---
处理用时：76.26秒
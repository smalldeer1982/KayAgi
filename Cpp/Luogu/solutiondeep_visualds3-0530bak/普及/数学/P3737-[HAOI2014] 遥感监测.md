# 题目信息

# [HAOI2014] 遥感监测

## 题目描述

外星人指的是地球以外的智慧生命。外星人长的是不是与地球上的人一样并不重要，但起码应该符合我们目前对生命基本形式的认识。比如，我们所知的任何生命都离不开液态水，并且都是基于化学元素碳（C）的有机分子组合成的复杂有机体。

ZDM 实验室的天文学家们已经执著地观测 ZDM-99 星球十多年了，这个被称为“战神”的红色星球让他们如此着迷。在过去的十多年中，他们经常有一些令人激动的发现。ZDM-99 星球表面有着明显的明暗变化。对这些明暗区域，天文学家们已经细致地研究了很多年，并且绘制出了较为详尽的地图，那些暗区是陆地，而亮区则是湖泊和海洋。他们一直坚信有水的地方，一定有生命的痕迹。

这天晚上的观测条件实在是空前的好，ZDM-99 星球也十分明亮，不时呈现出若干个激光点，天文学家们推定这些激光点极有可能存在地球以外的智慧生命。遗憾的是仅持续很短的一段时间，这些激光点就消失了。

ZDM 实验室的射电望远镜观测的区域有限，只可以遥感检测到一个半径为 $R$ 的圆形区域。为了能同时能检测到所有的激光点，ZDM 实验室需要要在一个水平的直线上尽快地安装多个的射电望远镜来。

不妨设，这条安放射电望远镜的水平直线为 X 轴，ZDM-99 星球激光点就处在 $P_1(x_1,y_1),P_1(x_1,y_1),\cdots,P_1(x_n,y_n)$（忽略 Z 坐标）

 ![](https://cdn.luogu.com.cn/upload/pic/5206.png) 

ZDM 实验室的天文学家们想知道，至少需要安装多少个射电望远镜才能检测到所有激光点。


## 说明/提示

$1≤R≤50$，$1≤N≤100$，$-1000≤ X_i,Y_i ≤ 1000$， $|Y_i| ≤ R$。

保证输入都是整数。

## 样例 #1

### 输入

```
3 2
1 2
-3 1
2 1
```

### 输出

```
2```

# AI分析结果



**唯一算法分类**  
几何

---

**题解思路、算法要点与解决难点**  
1. **核心思路**  
   将每个激光点投影到 X 轴上的可覆盖区间，转化为经典区间覆盖问题。关键数学公式：  
   $$\text{区间左端点} = x_i - \sqrt{R^2 - y_i^2}$$  
   $$\text{区间右端点} = x_i + \sqrt{R^2 - y_i^2}$$  
   通过贪心算法选择右端点最小的未覆盖区间，逐步覆盖所有区间。

2. **解决难点**  
   - **几何到线性的转换**：通过勾股定理将二维覆盖问题转化为一维区间覆盖  
   - **浮点数精度处理**：比较区间端点时需引入微小误差容限（如 `eps=1e-6`）  
   - **贪心策略证明**：按右端点排序后选择最早结束点，能保证全局最优性

---

**题解评分 (≥4星)**  
1. **PiCaHor (★★★★☆)**  
   - 关键亮点：代码简洁，直接按右端点排序+贪心遍历  
   - 核心代码片段：  
     ```cpp
     sort(e+1,e+len+1,cmp); // 按右端点排序
     loc = e[1].r; // 选择第一个区间的右端点
     for(...) if(loc+eps < e[i].l) // 判断区间不重叠
     ```

2. **liruixiong0101 (★★★★☆)**  
   - 关键亮点：图文结合解释几何转换，强调贪心策略与经典区间问题的联系  
   - 特色注释：详细图示说明区间端点计算原理

3. **Chorse (★★★★☆)**  
   - 关键亮点：预处理筛除包含关系的冗余区间，优化后续贪心效率  
   - 代码亮点：  
     ```cpp
     while(cnt>0 && p[q[cnt]].r>=p[i].r) cnt--; // 筛除被包含的长区间
     ```

---

**最优思路/技巧提炼**  
1. **几何投影法**：将二维点转化为一维覆盖区间，是处理圆形覆盖问题的经典技巧  
2. **右端点贪心策略**：排序后优先选择最早结束的区间，保证每次选择覆盖最多未覆盖区域  
3. **浮点精度处理**：比较区间端点时添加 `eps` 容差，避免浮点运算误差导致错误  

---

**同类型题/算法套路**  
- **通用模型**：将圆形覆盖转化为区间覆盖问题  
- **常见变式**：  
  1. 岛屿雷达覆盖问题（如 P1325）  
  2. 传感器网络部署问题  
  3. 时间窗口调度问题  

---

**推荐相似题目**  
1. [P1325 雷达安装](https://www.luogu.com.cn/problem/P1325)  
2. [CF1029C Maximal Intersection](https://codeforces.com/problemset/problem/1029/C)  
3. [P1230 智力大冲浪](https://www.luogu.com.cn/problem/P1230)

---

**个人心得摘录**  
- "计算区间端点时忘记开平方，调试半天才找到问题" —— 来自代码实现中的常见错误教训  
- "浮点数比较必须加eps，否则最后一个测试点会WA" —— 精度处理的实践经验  

---

**可视化与算法演示设计**  
1. **像素化动画方案**  
   - **步骤分解**：  
     1. 显示激光点坐标 → 红色像素点  
     2. 投影计算 → 显示勾股定理辅助线（绿色像素线）  
     3. 绘制区间 → 蓝色水平线段  
     4. 贪心选择 → 高亮当前选中区间右端点（黄色闪光）  
     5. 覆盖区域 → 已选区间显示为紫色  

   - **交互功能**：  
     - 步进控制：按空格键单步执行贪心选择  
     - 自动演示：播放 8-bit 背景音乐，每完成一步触发 "哔" 音效  
     - 调试面板：显示当前区间端点值和已选点数  

2. **复古风格实现**  
   ```javascript
   // Canvas 绘制示例（伪代码）
   function drawInterval(interval) {
     ctx.fillStyle = '#00F'; // 蓝色区间
     ctx.fillRect(interval.l*scale, 100, (interval.r-interval.l)*scale, 10);
     
     ctx.fillStyle = '#FF0'; // 黄色选中端点
     if (interval.r == currentSelected) 
       ctx.fillRect(interval.r*scale-2, 95, 4, 20);
   }
   ```

---

**核心代码实现**  
PiCaHor 题解的关键数学计算部分：  
```cpp
void cal(int x, int y) {
  double deta = sqrt(r*r - y*y); // 勾股定理计算投影半径
  e[len].l = x - deta;           // 区间左端点
  e[len].r = x + deta;           // 区间右端点
}

sort(e, e+n, [](auto a, auto b) { 
  return a.r < b.r; // 按右端点升序排序
});

double last = -INF;
int cnt = 0;
for(auto seg : e) {
  if(seg.l > last + eps) { // 浮点精度容差
    cnt++;
    last = seg.r;
  }
}
```

---
处理用时：69.40秒
# 题目信息

# 小 Y 拼木棒

## 题目背景

上道题中，小 Y 斩了一地的木棒，现在她想要将木棒拼起来。

## 题目描述

有 $n$ 根木棒，现在从中选 $4$ 根，想要组成一个正三角形，问有几种选法？

答案对 $10^9+7$ 取模。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 5 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，$1 \le a_i \le 5 \times 10^3$。

关于标题：因为一些不可抗力的原因，名称进行了更改。深表歉意。

## 样例 #1

### 输入

```
4 
1
1
2
2```

### 输出

```
1```

# AI分析结果



## 数学分类：组合数学

---

### **题解思路与核心算法**
1. **核心逻辑**  
   正三角形由两条等长边（各1根）与第三条边（2根拼接）构成。需满足：
   - 存在两根长度为 `a` 的木棒（选法：`C(num[a], 2)`）。
   - 存在两根木棒 `j` 和 `k`，满足 `j + k = a`（选法：若 `j = k` 则 `C(num[j], 2)`，否则 `num[j] * num[k]`）。

2. **数学推导**  
   - **组合数公式**：`C(n, 2) = n*(n-1)/2`，用于计算选两根相同木棒的方式。
   - **分情况枚举**：外层枚举 `a`，内层枚举 `j`（到 `a/2` 为止），避免重复计算 `j` 和 `a-j` 的组合。

3. **难点与解决**  
   - **避免重复枚举**：内层循环仅枚举 `j ≤ a/2`，确保每个 `(j, a-j)` 组合唯一。
   - **高效组合计算**：直接公式计算而非递归，优化时间复杂度至 `O(max_a^2)`。

---

### **题解评分（≥4星）**
1. **灵乌路空（5星）**  
   - **亮点**：循环条件严谨，组合数函数封装清晰，模运算处理细致。
   - **代码片段**：
     ```cpp
     for (int i = 2; i <= maxa; ++i) {
       if (num[i] >= 2) {
         ll times = C(num[i], 2) % MOD;
         for (int j = 1; j <= i / 2; ++j) {
           if (j != i-j) ans += times * C(num[j],1) * C(num[i-j],1) % MOD;
           else if (num[j] >= 2) ans += times * C(num[j],2) % MOD;
         }
       }
     }
     ```

2. **dbxxx（4星）**  
   - **亮点**：桶计数优化，变量命名清晰，组合数直接展开计算。
   - **代码片段**：
     ```cpp
     for (int i = begin+1; i <= end; i++) {
       if (num[i] >= 2) {
         for (int j=begin; j <= i/2; j++) {
           if (j == i-j) ans += C(num[i],2) * C(num[j],2) % mod;
           else ans += C(num[i],2) * num[j] * num[i-j] % mod;
         }
       }
     }
     ```

3. **Terrible（4星）**  
   - **亮点**：宏定义简化组合数，代码简洁高效，循环条件明确。
   - **代码片段**：
     ```cpp
     #define C1(x) (x)
     #define C2(x) (x*(x-1)/2)
     for (a=2; a<=5000; a++) {
       for (c=1; c<=a/2; c++) {
         d = a - c;
         if (d != c) sum += C2(arr[a]) * C1(arr[c]) * C1(arr[d]) % MOD;
         else sum += C2(arr[a]) * C2(arr[c]) % MOD;
       }
     }
     ```

---

### **最优技巧提炼**
- **桶计数预处理**：快速统计各长度出现次数，避免遍历原始数据。
- **分情况组合计算**：针对 `j = a-j` 的特殊情况单独处理，确保数学正确性。
- **循环优化**：内层仅枚举 `j ≤ a/2`，时间复杂度从 `O(n^2)` 降至 `O(max_a^2/2)`。

---

### **同类题型拓展**
- **洛谷 P2181 对角线**（组合数计算交点）
- **洛谷 P1100 木棍加工**（贪心+排序）
- **洛谷 P1036 选数**（DFS 组合数+质数判断）

---

### **可视化与算法演示**
**核心动画设计**：
1. **桶计数展示**：用柱状图动态显示各长度木棒数量。
2. **枚举过程高亮**：
   - 外层循环选中 `a`，红色标记当前 `a`。
   - 内层循环遍历 `j`，黄色标记 `j` 和 `a-j`。
3. **组合数计算**：实时显示 `C(num[a],2)` 和 `C(num[j],k)` 的值。
4. **复古像素风格**：
   - **颜色方案**：8位色调，绿色表示合法组合，红色表示不满足条件。
   - **音效**：每完成一次组合计算播放“滴”声，最终答案出现时播放胜利音效。

**交互功能**：
- **步进控制**：允许单步执行外层/内层循环。
- **速度调节**：滑动条控制动画速度，适应不同学习节奏。

---

### **代码实现（核心片段）**
```cpp
// 桶计数预处理
int num[5001] = {0};
for (int i = 0; i < n; i++) {
  cin >> a;
  num[a]++;
}

// 主计算逻辑
long long ans = 0;
const int MOD = 1e9 + 7;
for (int a = 2; a <= 5000; a++) {
  if (num[a] < 2) continue;
  long long choose_a = (1LL * num[a] * (num[a]-1)) / 2 % MOD;
  for (int j = 1; j <= a/2; j++) {
    int k = a - j;
    if (j == k) {
      if (num[j] >= 2) 
        ans = (ans + choose_a * (1LL * num[j] * (num[j]-1)/2) % MOD) % MOD;
    } else {
      ans = (ans + choose_a * num[j] % MOD * num[k] % MOD) % MOD;
    }
  }
}
cout << ans << endl;
```

---
处理用时：99.80秒
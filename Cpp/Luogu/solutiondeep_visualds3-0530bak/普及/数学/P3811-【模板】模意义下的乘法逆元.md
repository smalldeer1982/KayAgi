# 题目信息

# 【模板】模意义下的乘法逆元

## 题目背景

这是一道模板题


## 题目描述

给定 $n,p$ 求 $1\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。

这里 $a$ 模 $p$ 的乘法逆元定义为 $ax\equiv1\pmod p$ 的解。

## 说明/提示

$ 1 \leq n \leq 3 \times 10 ^ 6$，$n < p < 20000528 $。

输入保证 $ p $ 为质数。


## 样例 #1

### 输入

```
10 13```

### 输出

```
1
7
9
10
8
11
2
5
3
4```

# AI分析结果



**唯一算法分类**: 数论

---

### **题解核心思路与数学分析**

**核心难点**: 在O(n)时间内求解1~n每个数模质数p的乘法逆元。传统方法（扩展欧几里得、费马小定理）复杂度为O(n log p)，无法满足3e6量级要求。

**数学关键点**:  
1. **递推公式**  
   设 $p = k \cdot i + r$（其中 $k = \lfloor p/i \rfloor$, $r = p \% i$），推导得：
   \[
   i^{-1} \equiv -k \cdot r^{-1} \ (\text{mod} \ p)
   \]
   进一步化简为：
   \[
   \text{inv}[i] = (p - p/i) \cdot \text{inv}[p \% i] \ \% \ p
   \]
   初始条件：$\text{inv}[1] = 1$

2. **线性复杂度**  
   公式中 $p \% i < i$，递推时已计算过 $\text{inv}[p\%i]$，故总时间复杂度为O(n)。

---

### **最优题解评分与亮点**

| 题解作者 | 星级 | 核心亮点 |
|---------|------|----------|
| zjp_shadow | ★★★★★ | 详细推导递推公式，覆盖多种方法对比 |
| zcysky | ★★★★★ | 极简代码实现，直接应用递推式 |
| Rising_Date | ★★★★★ | 分步证明递推式，代码高效易移植 |

---

### **代码实现与可视化设计**

**核心代码片段**:
```cpp
inv[1] = 1;
for (int i = 2; i <= n; ++i)
    inv[i] = (p - p/i) * inv[p % i] % p;
```

**可视化动画方案**:
1. **分步递推**  
   - **步骤1**: 初始化 `inv[1] = 1`，用绿色高亮显示。
   - **步骤2**: 计算 `p/i` 和 `p%i`，用黄色标记当前i、k、r。
   - **步骤3**: 根据公式计算 `inv[i]`，红色箭头指向 `inv[r]` 的位置。
   - **步骤4**: 结果更新至数组，蓝色填充当前单元格。

2. **复古像素风格**  
   - **界面**: 8-bit风格网格，每格显示i和inv[i]。
   - **音效**: 计算成功时播放“滴”声，错误时低音警报。
   - **动画**: 使用Canvas绘制网格，每帧更新单元格颜色与数值。

---

### **类似题目推荐**
1. [P1082 同余方程](https://www.luogu.com.cn/problem/P1082)  
2. [P2613 【模板】有理数取余](https://www.luogu.com.cn/problem/P2613)  
3. [P5431 乘法逆元2](https://www.luogu.com.cn/problem/P5431)

---

### **个人心得摘录**
- **调试教训**: 初始未考虑负数取模，导致部分结果错误。修正后统一用 `(x % p + p) % p` 确保非负。
- **优化技巧**: 替换`cout`为`printf`可大幅提升输出速度，避免超时。

---

### **可视化代码片段（Canvas）**
```javascript
// 初始化Canvas
const canvas = document.getElementById('grid');
const ctx = canvas.getContext('2d');
const cellSize = 40;

function drawCell(i, val, color) {
    ctx.fillStyle = color;
    ctx.fillRect(i % 10 * cellSize, Math.floor(i / 10) * cellSize, cellSize, cellSize);
    ctx.fillStyle = 'black';
    ctx.fillText(`inv[${i}]=${val}`, i % 10 * cellSize + 5, Math.floor(i / 10) * cellSize + 20);
}

// 模拟递推过程
function simulate(n, p) {
    let inv = new Array(n + 1);
    inv[1] = 1;
    drawCell(1, 1, '#90EE90'); // 初始绿色

    for (let i = 2; i <= n; i++) {
        const k = Math.floor(p / i);
        const r = p % i;
        inv[i] = (p - k) * inv[r] % p;
        drawCell(i, inv[i], '#FFB6C1'); // 粉色标记当前计算
    }
}
```

---

**总结**: 线性递推法通过数学推导将逆元计算优化至O(n)，是解决大规模逆元问题的标准方法。结合复古风格可视化，可直观展示递推过程与公式应用。

---
处理用时：65.54秒
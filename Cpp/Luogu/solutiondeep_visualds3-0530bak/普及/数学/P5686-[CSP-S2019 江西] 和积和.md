# 题目信息

# [CSP-S2019 江西] 和积和

## 题目背景

JXCSP-S T2

## 题目描述

给定两个下标从 $1$ 到 $n$ 编号的序列 $a_i,b_i$，定义函数 $S(l,r)(1\le l\le r\le n)$ 为：

$$\sum_{i=l}^r a_i\times \sum_{i=l}^r b_i$$

请你求出下列式子的值：

$$\sum_{l=1}^n \sum_{r=l}^n S(l,r)$$

由于答案可能很大，你只需要给出答案模 $10^9+7$ 后的结果。

## 说明/提示

【数据范围】   
对于 $20\%$  的数据：$n\le 10$ , $a_i,b_i\le 10$；   
对于 $40\%$  的数据：$n\le 200$ , $a_i,b_i\le 100$；    
对于 $70\%$  的数据：$n\le 3000$ , $a_i,b_i\le 10^5$；    
对于 $100\%$  的数据：$3\le n\le 5\times 10^5$ , $1\le a_i,b_i\le 10^9$。

## 样例 #1

### 输入

```
3
2 3 4
3 4 5```

### 输出

```
244```

## 样例 #2

### 输入

```
5
11 22 33 44 55
12 34 56 78 90```

### 输出

```
201542```

# AI分析结果



## 【唯一算法分类】
前缀和与数学公式推导

---

## 【题解思路、算法要点与解决难点】

### 核心思路
将原式拆分为四个可预处理的前缀和部分：
```
∑(l=1→r) S(l,r) = r*A_r*B_r - A_r*∑B_{l-1} - B_r*∑A_{l-1} + ∑(A_{l-1}*B_{l-1})
```
- **前缀和数组**：维护 `A = ∑a`, `B = ∑b` 的前缀和
- **动态维护**：在遍历右端点时动态维护三个累加量 `sumA = ∑A_l`, `sumB = ∑B_l`, `sumAB = ∑A_l*B_l`

### 解决难点
1. **数学拆解**：将二维区间和转化为多个一维前缀和运算
2. **负数取模**：处理负数项时需 `(x % MOD + MOD) % MOD`
3. **线性优化**：通过动态维护变量替代预处理数组，减少空间占用

---

## 【题解评分】

### ★★★★★ 周子衡（赞34）
- **亮点**：公式推导最简洁，仅需维护3个变量，空间O(1)
- **代码**：单层循环实时更新变量，逻辑清晰

### ★★★★☆ Provicy（赞24）
- **优点**：详细推导各分项的前缀和预处理
- **改进点**：需预存多个前缀和数组，代码稍显复杂

### ★★★★☆ LCuter（赞8）
- **贡献法创新**：通过计算每个元素的贡献次数优化
- **实现**：构造新前缀和数组 `c_i = i*b_i` 简化计算

---

## 【最优思路提炼】
**核心技巧**：  
1. **拆分乘积项**：将 `(A_r - A_{l-1})(B_r - B_{l-1})` 展开为4个独立项  
2. **变量维护**：动态维护 `sumA = ∑A_{l-1}`, `sumB = ∑B_{l-1}`, `sumAB = ∑(A_{l-1}*B_{l-1})`  
3. **右端点遍历**：每次计算当前右端点对总答案的贡献

---

## 【同类型题推荐】
1. [P3405] 矩阵区域和（二维前缀和）
2. [P1214] 等差数列（区间乘积优化）
3. [P1719] 最大加权矩形（二维区间贡献）

---

## 【可视化与算法演示】
### 动画设计
- **网格展示**：以像素块表示数组元素，红色高亮当前右端点r
- **动态跟踪**：实时显示 `sumA`, `sumB`, `sumAB` 的数值变化
- **分项着色**：
  - 蓝色：`r*A_r*B_r`
  - 绿色：`-A_r*sumB`
  - 橙色：`-B_r*sumA`
  - 紫色：`sumAB`

### 复古像素风格
- **8位音效**：每次更新右端点播放短促音效，计算完成时播放胜利音效
- **Canvas绘制**：用16x16像素块表示数组元素，颜色区分不同分项
- **自动模式**：以0.5秒/步的速度自动遍历右端点，展示计算过程

---

## 【核心代码实现】
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MOD = 1e9+7, N = 5e5+5;
long long n, a[N], b[N], A[N], B[N], ans;

int main() {
    cin >> n;
    for(int i=1; i<=n; ++i) {
        cin >> a[i];
        A[i] = (A[i-1] + a[i]) % MOD;
    }
    for(int i=1; i<=n; ++i) {
        cin >> b[i];
        B[i] = (B[i-1] + b[i]) % MOD;
    }

    long long sumA = 0, sumB = 0, sumAB = 0;
    for(int r=1; r<=n; ++r) {
        // 计算当前右端点的贡献
        long long term1 = r * A[r] % MOD * B[r] % MOD;
        long long term2 = A[r] * sumB % MOD;
        long long term3 = B[r] * sumA % MOD;
        long long cur = (term1 - term2 - term3 + sumAB) % MOD;
        ans = (ans + cur + MOD) % MOD;

        // 更新维护变量
        sumA = (sumA + A[r-1]) % MOD;
        sumB = (sumB + B[r-1]) % MOD;
        sumAB = (sumAB + A[r-1]*B[r-1]) % MOD;
    }
    cout << ans;
    return 0;
}
```

---

## 【关键代码解析】
1. **前缀和初始化**：`A[i]`和`B[i]`分别存储a和b的前缀和
2. **动态维护变量**：
   - `sumA`：累计所有左端点前的前缀和`A[l-1]`
   - `sumB`：累计`B[l-1]`
   - `sumAB`：累计`A[l-1]*B[l-1]`
3. **分项计算**：每次循环计算当前右端点对总答案的四部分贡献

---

## 【调试心得摘录】
> "十年OI一场空，不开long long见祖宗" —— 周子衡  
> 关键点：所有中间变量必须用long long，防止溢出

> "取模负数要加MOD再模" —— __CJY__  
> 教训：负数取模需先加MOD确保非负

---

## 【像素动画代码片段】
```javascript
// Canvas初始化
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
const CELL_SIZE = 16;

function drawArray(arr, y, color) {
    arr.forEach((val, x) => {
        ctx.fillStyle = color;
        ctx.fillRect(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE-1, CELL_SIZE-1);
    });
}

// 播放8位音效
function playBeep(freq=600, duration=50) {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = freq;
    osc.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration/1000);
}
```

---
处理用时：87.68秒
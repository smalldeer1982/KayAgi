# 题目信息

# [USACO05JAN] Moo Volume S

## 题目描述

Farmer John 的农场上有 $N$ 头奶牛（$1 \leq N \leq 10^5$），第 $i$ 头奶牛的位置为 $x_i$（$0 \leq x_i \leq 10^9$）。

奶牛很健谈，每头奶牛都和其他 $N-1$ 头奶牛聊天。第 $i$ 头奶牛和第 $j$ 头奶牛聊天时，音量为 $|x_i-x_j|$。

请您求出所有奶牛聊天音量的总和。

## 说明/提示

- 子任务 1（原测试数据，1 分）：$N \leq 10^4$；
- 子任务 2（99 分）：无特殊限制。

## 样例 #1

### 输入

```
5
1
5
3
2
4```

### 输出

```
40```

# AI分析结果



### 算法分类
**排序 + 前缀和**

---

### 题解思路、算法要点与解决难点
**核心思路**：  
1. **排序优化**：将奶牛位置排序后，每头牛的贡献可分解为与所有前序牛的差值总和  
2. **数学推导**：对于排序后的第i头牛，其贡献为 `a[i]*(i-1) - sum[1..i-1]`  
3. **前缀和加速**：通过前缀和数组快速计算前i-1头牛的坐标总和  
4. **对称性处理**：最终结果乘2处理双向对话关系  

**实现难点**：  
1. 推导绝对值差总和转化为线性表达式  
2. 排序后的数学性质与前缀和的结合应用  
3. 大数范围处理（需用 long long 类型）

---

### 题解评分（≥4星）
| 作者 | 星级 | 关键亮点 |
|------|-----|---------|
| _ouhsnaijgnat_ | ⭐⭐⭐⭐ | 倒序计算思路清晰，代码简洁易懂 |
| Kalium | ⭐⭐⭐⭐ | 详细数学推导，完整注释 |
| A_Đark_Horcrux | ⭐⭐⭐⭐ | 代码规范，变量命名合理 |

---

### 最优思路/技巧提炼
**核心优化公式**：  
```math
\text{总贡献} = 2 \times \sum_{i=1}^n [a_i \times (i-1) - \text{前缀和}(i-1)]
```

**实现步骤**：  
1. 排序数组  
2. 构建前缀和数组  
3. 线性扫描计算每个元素的贡献  
4. 结果乘2输出  

**关键技巧**：  
- 利用排序后的有序性消除绝对值  
- 前缀和将O(n²)复杂度降为O(n)  
- 倒序计算简化前缀和更新逻辑

---

### 同类型题与算法套路
**常见变式**：  
1. 求数组所有数对绝对差之和  
2. 带权重的距离和计算  
3. 多维空间中的曼哈顿距离总和  

**通用解法**：  
1. 排序建立有序性  
2. 数学分解贡献项  
3. 前缀和/差分加速计算

---

### 推荐练习题
1. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406) - 前缀和经典应用  
2. [P3131 Subsequences Summing to Sevens](https://www.luogu.com.cn/problem/P3131) - 前缀和与数学结合  
3. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719) - 二维前缀和扩展

---

### 算法可视化方案
**核心动画逻辑**：  
```javascript
// 伪代码示例
sort(cows); // 排序动画
buildPrefixSum(); // 前缀和进度条
for (let i = 0; i < n; i++) {
   highlight(cow[i]); // 高亮当前牛
   showFormula(`a[${i}] * ${i} - sum[0..${i-1}]`); 
   updateTotal(sum * 2); // 实时更新总和
}
```

**复古风格设计**：  
- **像素网格**：用16x16像素块表示奶牛位置  
- **音效设计**：  
  - 排序时：8-bit交换音效  
  - 计算贡献：NES风格电子音  
  - 完成时：经典马里奥过关音乐  
- **自动演示**：  
  ```javascript
  const demo = () => {
    sortWithAnimation(() => playSound('blip'));
    calculateContributions(() => playSound('coin'));
  }
  ```

---

### 关键代码实现
**最优题解核心代码**：
```cpp
sort(a+1, a+1+n);
long long ans = 0, sum = 0;
for (int i=1; i<=n; i++) {
    ans += a[i] * (i-1LL) - sum;
    sum += a[i];
}
cout << ans*2;
```

**可视化片段**（Canvas绘制）：
```javascript
ctx.fillStyle = '#FF69B4'; // 粉色标记当前牛
ctx.fillRect(x*16, 0, 16, 16); 
drawFormula(`贡献 += ${a[i]}×${i-1} - ${sum}`);
```

---

### 总结
通过排序建立有序性，结合前缀和实现O(n)复杂度计算，最终结果乘2处理双向关系。该模式可拓展至各类距离和问题，是处理绝对值优化的经典范式。可视化方案通过复古像素动画与音效反馈，直观展现算法核心流程。

---
处理用时：67.99秒
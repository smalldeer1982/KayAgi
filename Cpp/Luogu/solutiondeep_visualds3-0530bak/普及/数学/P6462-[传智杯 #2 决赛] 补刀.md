# 题目信息

# [传智杯 #2 决赛] 补刀

## 题目描述

UIM 在写程序的空闲玩一款 MOBA 游戏。

![](https://cdn.luogu.com.cn/upload/image_hosting/j6t4jmrd.png)

当敌方的小兵进入到我方防御塔的范围内，就会持续受到防御塔造成的伤害；当然我方英雄也可以对它造成伤害。当小兵的血量降到了 0 或者更低，就会被击杀。为了获得经验，UIM 希望在防御塔将这个小兵杀死之前，亲自补刀将其击杀。

为了简化问题，我们假设这个小兵有 $h$ 点的生命值。每次防御塔的攻击可以给小兵造成 $x$ 点伤害，而你的英雄每次攻击可以给小兵造成 $y$ 点伤害。你的攻击速度和防御塔攻击速度相同，所以你可以在防御塔第一次攻击小兵之前，或者每次防御塔攻击之后，选择是否对小兵进行一次攻击，当然你也可以选择不攻击。

现在想知道，给出这些信息，判断英雄是否有办法将这个小兵击杀？

## 说明/提示

数据的组数不多于 50，$1\le h \le 10^{18}$，$0\le x,y \le 10^{18}$。

## 样例 #1

### 输入

```
5
100 100 1
100 97 1
100 98 1
100 99 1
100 100 0```

### 输出

```
No
No
Yes
Yes
No```

# AI分析结果



### **算法分类**  
数论

---

### **题解思路与核心算法**  
**核心问题**：判断英雄是否能在防御塔击杀前补刀，即英雄攻击次数是否足够。  

**关键推导**：  
1. **防御塔最大攻击次数**：设防御塔攻击次数为 `tower`，满足 `tower * x < h`。  
   - 数学公式：`tower = (h - 1) // x`（避免浮点运算，直接整数除法）。  
2. **英雄最大攻击次数**：防御塔攻击 `tower` 次后，英雄可攻击 `tower + 1` 次。  
3. **总伤害条件**：英雄总伤害需覆盖剩余血量 `h - tower * x`，即 `(tower + 1) * y >= h - tower * x`。  

**特例处理**：  
- 若 `y = 0`：英雄无法补刀。  
- 若 `x = 0`：只要 `y > 0`，英雄必能补刀。  
- 若 `h ≤ y`：英雄一击必杀。  

---

### **题解评分 (≥4星)**  
1. **d446101 (★★★★☆)**  
   - **亮点**：公式简洁，直接计算防御塔攻击次数，避免浮点运算。  
   - **代码**：Ruby 实现清晰，特判处理得当。  
   ```ruby
   tower = h / x
   if h % x == 0 then tower -= 1 end
   if (tower + 1) * y + tower * x >= h
   ```

2. **cyrxdzj (★★★★☆)**  
   - **亮点**：数学推导严谨，通过剩余血量判断。  
   - **代码**：C++ 实现利用 `ceil` 函数，逻辑清晰。  
   ```cpp
   long long tower_attack_times = ceil(double(h)/x) - 1;
   h -= tower_attack_times * x;
   ```

3. **Provicy (★★★★☆)**  
   - **亮点**：特判覆盖全面，公式推导详细。  
   - **代码**：处理整除与非整除情况分开判断。  
   ```cpp
   int a = h / x, b = a * x, c = h - b;
   if (!c) { if (a * y >= x) ... }
   else { if ((a + 1) * y >= c) ... }
   ```

---

### **最优思路提炼**  
1. **核心公式**：  
   - `tower = (h - 1) // x`  
   - **剩余血量**：`h_remain = h - tower * x`  
   - **补刀条件**：`y * (tower + 1) >= h_remain`  

2. **数学优化**：  
   - 整数除法代替浮点运算，避免精度问题。  
   - 特判边界条件，减少计算量。  

---

### **同类型题目套路**  
1. **整除与模运算**：常见于计算最大次数或剩余值。  
2. **不等式判断**：确定资源是否足够覆盖需求。  
3. **特例优先处理**：如除数为零、攻击力为零等。  

---

### **推荐相似题目**  
1. **P1226** 【模板】快速幂 | 取余运算（数论基础）  
2. **P1029** 最大公约数和最小公倍数问题（整除与约数）  
3. **P1463** 反素数（优化与边界处理）  

---

### **可视化与复古动画设计**  
**动画流程**：  
1. **防御塔攻击模拟**：  
   - 显示初始血量 `h`，防御塔每次攻击扣减 `x`，直到 `tower` 次后停止。  
   - **颜色标记**：防御塔攻击步骤用红色高亮，剩余血量用绿色显示。  
2. **英雄攻击判断**：  
   - 显示英雄可攻击次数 `tower + 1`，总伤害 `y * (tower + 1)`。  
   - **条件触发**：若总伤害 ≥ 剩余血量，播放成功音效；否则失败音效。  

**复古风格**：  
- **8位像素UI**：血量用条形像素图表示，攻击步骤以方块动画呈现。  
- **音效设计**：  
  - 攻击音效：短促“哔”声。  
  - 成功/失败：上扬/下降音调。  

**代码片段**（Canvas 绘制）：  
```javascript
// 绘制防御塔攻击过程
function drawAttack(tower, h_remain) {
  ctx.fillStyle = "#FF0000"; // 红色标记防御塔攻击
  ctx.fillRect(tower * 10, 50, 10, 10); // 每攻击一次绘制一个方块
  ctx.fillStyle = "#00FF00"; // 绿色显示剩余血量
  ctx.fillText(`HP: ${h_remain}`, 100, 20);
}
```

---

### **个人心得摘录**  
- **d446101**：通过“构造”防御塔攻击次数简化问题，避免复杂模拟。  
- **chenpengda**：贪心思路失败后，补充特判通过测试，强调边界条件的重要性。  
- **jscblack**：类比 CF 题目，强调数学模型的通用性。  

---

### **核心代码实现**  
**C++ 代码片段**：  
```cpp
void solve() {
    long long h, x, y;
    cin >> h >> x >> y;
    if (y == 0) {
        cout << "No\n";
        return;
    }
    if (x == 0) {
        cout << "Yes\n";
        return;
    }
    long long tower = (h - 1) / x; // 防御塔最大攻击次数
    long long h_remain = h - tower * x;
    if (y * (tower + 1) >= h_remain) {
        cout << "Yes\n";
    } else {
        cout << "No\n";
    }
}
```

---
处理用时：116.88秒
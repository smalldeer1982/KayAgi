# 题目信息

# [QkOI#R1] Quark and Equations

## 题目描述

给定 $n,m$，求有几组正整数对 $(i,j)$ 满足下列方程组：

$$
\begin{cases}
   i+j=n \\
   \lfloor\frac{i}{j}\rfloor+\lceil\frac{j}{i}\rceil=m
\end{cases}
$$

上式中，$\lfloor x\rfloor$ 表示对 $x$ 向下取整，$\lceil x\rceil$ 表示对 $x$ 向上取整。

## 说明/提示

### 样例解释

当 $n=m=2$ 时，只有 $(1,1)$ 满足条件。  
当 $n=2,m=1$ 时，无解。  
当 $n=6,m=2$ 时，只有 $(2,4),(3,3)$ 满足条件。

---

### 数据范围

**本题采用捆绑测试。**

- Subtask 1（10 pts）：$T,n,m\le 500$。
- Subtask 2（40 pts）：$T,n,m\le 5000$。
- Subtask 3（5 pts）：$m=1$。
- Subtask 4（5 pts）：$m>n$。
- Subtask 5（5 pts）：$m\in[n-1,n]$。
- Subtask 6（35 pts）：无特殊限制。

对于 $100\%$ 的数据，$1\le T\le 10^5$，$1\le n,m\le 10^{7}$。

## 样例 #1

### 输入

```
2
2 2
2 1
```

### 输出

```
1
0```

## 样例 #2

### 输入

```
1
6 2
```

### 输出

```
2
```

# AI分析结果



---

**算法分类**：数学推导与分情况讨论

---

### **题解思路与算法要点**

1. **核心思路**  
   通过分析方程组，将问题拆分为两种情况：`i < j` 和 `i ≥ j`，利用取整函数的性质将方程转化为不等式，最终通过数学公式直接计算解的数量。

2. **关键推导**  
   - **当 `i < j`**：  
     `floor(i/j) = 0`，方程转化为 `ceil(j/i) = m`。代入 `j = n - i` 后得到不等式：  
     `m-1 < (n-i)/i ≤ m` → `n/(m+1) ≤ i < n/m`，解的个数为 `ceil(n/m) - ceil(n/(m+1))`。
   - **当 `i ≥ j`**：  
     `ceil(j/i) = 1`，方程转化为 `floor(i/j) = m-1`。代入 `j = n - i` 后得到不等式：  
     `(m-1)(n-i) ≤ i < m(n-i)` → `floor(n/(m+1)) < j ≤ floor(n/m)`，解的个数为 `floor(n/m) - floor(n/(m+1))`。

3. **特殊处理**  
   - `m = 1` 或 `m > n` 时无解。
   - `m = n-1` 或 `m = n` 时有且仅有一个解。

---

### **题解评分（≥4星）**

1. **vectorwyx（★★★★★）**  
   - **亮点**：详细推导分情况讨论，代码简洁高效，数学推导清晰。
   - **代码核心**：通过 `ceil` 和 `floor` 计算两个区间长度，直接求和。

2. **绝顶我为峰（★★★★☆）**  
   - **亮点**：公式简洁，直接合并两种情况的表达式，代码简短。
   - **代码核心**：用单行表达式 `ans = floor(n/m) - ceil(...) + ceil(...) - floor(...)` 计算结果。

3. **LCuter（★★★★☆）**  
   - **亮点**：通过观察规律得出公式，提供暴力枚举验证的思路。
   - **代码核心**：直接计算区间长度，避免复杂的分类讨论。

---

### **最优思路与技巧**

1. **数学分情况**  
   将问题拆分为 `i < j` 和 `i ≥ j`，利用取整函数的性质简化方程，避免枚举。

2. **公式直接计算**  
   通过不等式推导，将解的数量转化为 `ceil` 和 `floor` 的组合运算，时间复杂度 `O(1)`，适合处理大数据。

3. **特殊值快速判断**  
   提前处理 `m = 1`、`m > n` 等边界条件，避免无效计算。

---

### **相似题目推荐**

1. **P1463 [POI2004] PRZ**  
   - 类似的分组与数学优化问题。
2. **P2261 [CQOI2007] 余数求和**  
   - 利用取整函数性质进行数学推导。
3. **P3579 [POI2014] PAN-Solar Panels**  
   - 区间分析与取整函数结合。

---

### **可视化算法演示**

**动画设计**：
1. **输入界面**：用户输入 `n` 和 `m`，点击运行后展示两个区间（`i < j` 和 `i ≥ j`）的范围。
2. **像素化显示**：  
   - 用两个不同颜色的像素条表示 `i` 和 `j` 的可行区间。
   - 动态标记当前计算的 `ceil` 和 `floor` 边界。
3. **音效反馈**：  
   - 计算完成时播放 8-bit 成功音效。
   - 无解时播放短促失败音效。

**代码片段（伪代码）**：
```javascript
function visualize(n, m) {
  const i_j_range = calculateRanges(n, m);
  drawPixelBar(i_j_range.i_less, "blue");
  drawPixelBar(i_j_range.i_geq, "green");
  playSound("success");
}
```

---

### **核心代码实现**

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        int n, m;
        scanf("%d%d", &n, &m);
        if (m == 1 || m > n) {
            puts("0");
            continue;
        }
        int ans = (ceil(n*1.0/m) - ceil(n*1.0/(m+1))) 
                + (floor(n*1.0/m) - floor(n*1.0/(m+1)));
        printf("%d\n", ans);
    }
    return 0;
}
```

---

### **总结与心得**

- **推导关键**：分情况讨论和取整函数的性质是核心，需注意 `i` 和 `j` 的隐含范围。
- **调试经验**：通过小样例验证公式正确性（如 `n=6, m=2`），避免逻辑错误。
- **优化方向**：直接数学公式替代枚举，复杂度从 `O(n)` 降为 `O(1)`。

---
处理用时：201.24秒
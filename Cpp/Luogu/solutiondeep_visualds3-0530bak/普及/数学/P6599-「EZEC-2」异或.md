# 题目信息

# 「EZEC-2」异或

## 题目描述

有 $T$ 组询问，每次给定两个正整数 $n,l$，   

你需要构造一个长度为 $l$ 的正整数序列 $a$（编号从 $1$ 至 $l$），   

且满足 $\forall i\in[1,l]$，都有 $a_i\in[1,n]$。

求：

$$\sum_{i=1}^l\sum_{j=1}^{i-1}a_i\oplus a_j$$

的最大值。

为了避免答案过大，对于每组询问，只需要输出这个最大值对 $10^9+7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**   
当 $n=2,l=3$，$a$ 取 $\{1,2,1\}$ 的任一排列时可以得到最大值，为 $(1\oplus2)+(1\oplus1)+(2\oplus1)=6$，易证明此时原式有最大值。

---
**【数据规模与约定】**
| 测试点编号 | $T\le$ | $n\le$ | $l\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim5$ | $1$ | $10$ | $5$ |
| $6$ | $5\times 10^5$ | $10^{12}$ | $2$ |
| $7$ | $5\times 10^5$ | $10^{12}$ | $3$ |
| $8\sim10$ | $5\times 10^5$ | $10^{12}$ | $10^5$ |

对于 $100\%$ 的数据，满足 $1\le T\le 5\times10^5$，$1\le n\le 10^{12}$，$2\le l \le 10^5$。


---
**【提示】**

1. 「$\oplus$」是按位异或符号。如果您不知道什么是按位异或，可以参考[这里](https://oi-wiki.org/math/bit/#_1)。
2. 取模是一种运算，$a$ 对 $b$ 取模代表将 $a$ 赋值为 $a$ 除以 $b$ 所得到的余数。  
在 C++ / Python 中的取模符号为 `%`，在 Pascal 中的取模符号为 `mod`。
3. $\sum$ 是求和符号。如果您不知道什么是 $\sum$ 符号，可以参考[这里](https://baike.baidu.com/item/∑/1233796?fr=aladdin)。
4. 请注意数据的读入输出对程序效率造成的影响。

## 样例 #1

### 输入

```
1
2 3
```

### 输出

```
6```

## 样例 #2

### 输入

```
2
114 514
1919 180
```

### 输出

```
8388223
16580700```

# AI分析结果



**唯一算法分类**  
组合数学

---

**题解思路、算法要点与解决难点**  
本题核心在于按位分析异或贡献，利用组合数学优化最大值的构造。  
- **关键公式推导**：每位贡献为 $x \times (l-x) \times 2^k$，其中 $x$ 为该位为 1 的数的个数。  
- **最大值构造**：当 $x = \lfloor l/2 \rfloor$ 时，$x \times (l-x)$ 最大。  
- **构造方式**：选 $\lfloor l/2 \rfloor$ 个数为最大可能值（如 $2^m$），剩余数取次大值（如 $2^m-1$），确保每位的 0/1 分布最优。  
- **总和计算**：所有二进制位的权值和为 $2^{\log_2 n +1}-1$，乘以 $\lfloor l/2 \rfloor \times (l-\lfloor l/2 \rfloor)$。  

**难点对比**  
- **构造验证**：需证明所选数在各二进制位均能取得最优分布，避免如最高位无法构造的问题。  
- **位运算优化**：快速计算最大二进制位权值 $2^m \leq n$，避免高复杂度遍历。  

---

**题解评分 (≥4星)**  
1. **dead_X（5星）**  
   - 思路清晰，按位遍历权值，代码高效。  
   - 核心逻辑明确，处理特例简洁。  
   - 代码可读性强，利用位运算快速定位最大权值。  

2. **李白莘莘学子（4星）**  
   - 详细推导贡献公式，代码逻辑清晰。  
   - 提供构造示例，增强理解。  
   - 未显式处理最大权值计算，但思路正确。  

3. **一只书虫仔（4星）**  
   - 公式推导完整，代码简洁。  
   - 使用数学函数快速求对数，但需注意精度问题。  

---

**最优思路提炼**  
1. **按位独立分析**：异或运算每位独立，分解为各二进制位的贡献。  
2. **最大化组合数**：每位的贡献最大化为 $\lfloor l/2 \rfloor \times (l - \lfloor l/2 \rfloor)$。  
3. **权值总和计算**：快速求二进制权值和 $2^{\log_2 n +1}-1$。  

**关键代码片段**  
```cpp
long long now = 1LL << 40; // 初始高位权值
while (now > n) now >>= 1; // 找到最大2^m ≤n
ans = now * 2 - 1; // 权值和
ans = ans % MOD * (l/2) % MOD * (l - l/2) % MOD;
```

---

**同类型题与算法套路**  
- **位运算优化**：如 [CF1879D](https://codeforces.com/problemset/problem/1879/D)（异或前缀和按位处理）。  
- **组合数最大化**：如 [LeetCode 1178](https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/)（位掩码计数）。  
- **构造最优分布**：如 [洛谷 P2114](https://www.luogu.com.cn/problem/P2114)（按位选择最大贡献）。  

---

**推荐相似题目**  
1. [P2114 起床困难综合症](https://www.luogu.com.cn/problem/P2114)  
2. [CF1395C Boboniu and Bit Operations](https://codeforces.com/problemset/problem/1395/C)  
3. [P6102 [EER2]谔运算](https://www.luogu.com.cn/problem/P6102)  

---

**可视化与算法演示**  
**动画方案**：  
1. **像素化二进制位**：将每个数的二进制位显示为像素方格（1为红色，0为蓝色）。  
2. **逐位贡献计算**：高亮当前处理的二进制位，动态累加贡献值。  
3. **构造过程展示**：显示选择 $\lfloor l/2 \rfloor$ 个最大数（红色）与剩余数（蓝色）的分布。  

**复古游戏效果**：  
- **像素风格**：8-bit 字体与色块，音效为经典芯片音乐。  
- **音效触发**：每处理完一位播放“完成音效”，最终答案出现时播放胜利音效。  

---

**总结**  
通过按位拆分与组合数学优化，将复杂异或和问题转化为二进制位贡献的最大化构造。关键点在于快速计算权值和与构造最优分布，最终实现高效求解。

---
处理用时：293.36秒
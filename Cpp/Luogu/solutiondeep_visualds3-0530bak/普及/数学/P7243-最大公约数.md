# 题目信息

# 最大公约数

## 题目背景

&emsp;&emsp;“寻求最大公约数是人民民主的真谛。……”

&emsp;&emsp;初秋，从枝丫滴下的阳光，柔和，在教室的窗棱溅起，润湿晨读的少女的脸颊。

&emsp;&emsp;“阿绫，阿绫”，天依低俯身子，八字辫耷拉在竖起的课本沿，“我们的最大公约数是多少呢？”

&emsp;&emsp;“一定不小吧”，左手悄悄捏捏天依的小臂，“比如呀，有一个公因子，叫做‘你喜欢我，我也喜欢你’。”

## 题目描述

相反，人际圈形形色色，公约数小得可怜，似乎很难保持自己的个性因而变成无趣的人呢。

现在把人际抽象成一个 $n \times m$ 的矩形，每个人初始的个性为 $a_{i,j}$。从第二天开始，每个人会与上下左右四个人（如果存在）建立人际关系，其个性变为昨天自己和四周人个性的最大公约数。那么对于第 $x$ 行第 $y$ 列的人，在多少天后他的个性会变为 $1$ 呢？

----

#### 简化题意

有一个 $n \times m$ 的矩阵 $a$。对一个矩阵进行变换，定义为将这个矩阵内的所有元素变为其上下左右四个元素（不存在则忽略）及自身的最大公约数。询问 $a_{x,y}$ 在进行最少多少次变换之后会变成 $1$。如果可以使 $a_{x,y}$ 经过若干次变换变成 $1$，输出其中最小的次数；否则输出 $-1$。

## 说明/提示

#### 样例解释 3
第一天的个性矩阵（也就是最开始的矩阵）为
$$
\begin{pmatrix}
3&2&3\\
2&3&2\\
3&2&3
\end{pmatrix}
$$
第二天的个性矩阵为
$$
\begin{pmatrix}
1&1&1\\
1&1&1\\
1&1&1
\end{pmatrix}
$$
可见只需要经过一天，$a_{2,2}$ 就会变为 $1$，所以答案为 $1$。

#### 数据规模与约定
**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^3$，$1\le a_{i,j}\le 10^{18}$，$1\le x\le n$，$1\le y\le m$。

| 子任务 | 分值 |        $n,m$        |              特殊限制              |
| :----: | :--: | :-----------------: | :--------------------------------: |
|   1    |  1   |          /          | 保证给出的位置个性永远不会变为 $1$ |
|   2    |  1   |          /          |          保证 $a_{x,y}=1$          |
|   3    |  3   |      $ \le 2$       |                 /                  |
|   4    |  10  |     $ \le 10^2$     |                 /                  |
|   5    |  30  | $ \le 5\times 10^2$ |           /            |
|   6    |  10  |          /          |   保证对于所有的 $a_{i,j} \le 2$   |
|   7    |  10  |          /          |     保证 $x$ 与 $y$ 都等于 $1$     |
|   8    |  35  |          /          |                 /                  |





------------




## 样例 #1

### 输入

```
2 2
2 2
1 2
2 1```

### 输出

```
0```

## 样例 #2

### 输入

```
2 2
2 2 
2 2
1 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
3 3
3 2 3
2 3 2
3 2 3
2 2```

### 输出

```
1```

# AI分析结果



## 算法分类
**数论**

---

## 题解思路与核心难点
### 核心数学推导
1. **gcd的传播特性**  
   每次变换后，$a_{x,y}$的值等于原矩阵中曼哈顿距离 $\leq d$ 的所有点的gcd。例如：
   - 第0天：曼哈顿距离=0的点（自身）
   - 第1天：曼哈顿距离≤1的点（自身+上下左右）
   - 第k天：曼哈顿距离≤k的点

2. **关键结论**  
   答案是最小的 $k$，使得曼哈顿距离≤k的所有点的gcd为1。若所有点的总gcd≠1，则无解。

### 解决难点与优化
- **快速分层计算**：按曼哈顿距离预处理所有点，分层计算gcd
- **时间复杂度优化**：从 $O(nm \log a)$ 到 $O(nm + max\_distance)$，避免重复计算
- **空间优化**：仅需记录每层gcd的累计值

---

## 最优题解评分（≥4星）
1. **wsyhb（5星）**  
   - 思路：预处理曼哈顿距离分层，逐层计算gcd
   - 亮点：时间复杂度最优，代码简洁易读
   ```cpp
   vector<P> pos[max_size]; // 按曼哈顿距离分组
   for(int i=0; i<=max_d; ++i){
       for(auto p : pos[i]) now = gcd(now, a[p.x][p.y]);
       if(now ==1) return i;
   }
   ```

2. **Rubidium_Chloride（4星）**  
   - 思路：同曼哈顿距离分层，使用vector存储每层点
   - 亮点：明确数学证明，代码可读性强

3. **InformationEntropy（4星）**  
   - 思路：BFS扩展时维护全局gcd
   - 亮点：动态展示gcd传播过程，适合教学演示

---

## 关键代码实现
**曼哈顿距离分层法（wsyhb）**
```cpp
// 预处理所有点的曼哈顿距离
for(int i=1;i<=n;++i) for(int j=1;j<=m;++j){
    int d=abs(i-x)+abs(j-y);
    pos[d].push_back({i,j});
    max_d=max(max_d,d);
}

// 逐层计算gcd
long long now=a[x][y];
for(int i=0;i<=max_d;++i){
    for(auto p:pos[i]) now=gcd(now,a[p.first][p.second]);
    if(now==1) return printf("%d",i);
}
```

---

## 同类题目与套路
1. **常见数论套路**  
   - 利用gcd的传递性和结合律
   - 分层/分阶段处理集合属性

2. **推荐题目**  
   - [P1072 Hankson的趣味题](https://www.luogu.com.cn/problem/P1072)（gcd与lcm综合应用）  
   - [P4549 裴蜀定理](https://www.luogu.com.cn/problem/P4549)（集合gcd性质）  
   - [P2651 添加括号](https://www.luogu.com.cn/problem/P2651)（gcd运算顺序优化）

---

## 可视化设计
### 动画方案（复古像素风格）
1. **可视化元素**  
   - **像素网格**：用16色绘制矩阵，目标点高亮为红色
   - **扩散波纹**：用蓝→绿→黄渐变色表示曼哈顿距离层
   - **当前gcd显示**：顶部8位风格数字显示当前累计gcd

2. **交互设计**  
   ```javascript
   // 伪代码：绘制第k层扩展
   function drawLayer(k){
       ctx.fillStyle = '#00FF00'; // 绿色表示当前层
       for(const p of pos[k]){
           drawPixel(p.x, p.y); 
       }
       playSound('blip.wav'); // 每层播放音效
   }
   ```

3. **音效提示**  
   - 正确音：FC风格8和弦上升音
   - 错误音：短促下降音阶

---

## 知识迁移
当遇到以下特征时，可考虑曼哈顿距离分层：
1. 操作具有**区域扩散性**
2. 结果与**集合属性**（如gcd、sum、max）相关
3. 需要求**最小操作次数**使属性满足条件

---

> **启示**：数论问题中，挖掘操作背后的数学性质往往比直接模拟更高效。通过本题的曼哈顿距离与gcd关系，可拓展到其他集合属性问题的分层处理。

---
处理用时：75.25秒
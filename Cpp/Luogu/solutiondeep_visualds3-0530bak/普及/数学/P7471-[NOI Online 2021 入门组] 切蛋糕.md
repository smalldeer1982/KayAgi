# 题目信息

# [NOI Online 2021 入门组] 切蛋糕

## 题目描述

Alice、Bob 和 Cindy 三个好朋友得到了一个圆形蛋糕，他们打算分享这个蛋糕。

三个人的需求量分别为 $a,b,c$，现在请你帮他们切蛋糕，规则如下：

1. 每次切蛋糕可以选择蛋糕的任意一条直径，并沿这条直径切一刀（注意切完后不会立刻将蛋糕分成两部分）。

2. 设你一共切了 $n$ 刀，那么你将得到 $2n$ 个扇形的蛋糕（特别地，切了 $0$ 刀被认为是有一个扇形，即整个圆形蛋糕），将这些蛋糕分配给 Alice，Bob 和 Cindy，要求每个扇形蛋糕只能完整地分给一个人。

3. 三人分到的蛋糕面积比需要为 $a:b:c$（不保证是最简比例，且如果 $a:b:c$ 中某个数为 $0$，表示那个人不吃蛋糕）。

为了完成这个任务，你至少需要切几刀？

## 说明/提示

### 样例 $1$ 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/i3pai9va.png)

### 数据范围与提示
$30\%$ 的数据满足：$a=b=0$。

$60\%$ 的数据满足：$a=0$。

$100\%$ 的数据满足：$1\le T\le 10^4，0\le a,b,c\le 10^8$，保证 $a+b+c>0$。

数据由 [SSerxhs](https://www.luogu.com.cn/user/29826) 提供。

## 样例 #1

### 输入

```
6
0 0 8
0 5 3
9 9 0
6 2 4
1 7 4
5 8 5```

### 输出

```
0
2
1
2
3
2```

# AI分析结果



### 算法分类
无算法分类（纯分类讨论题）

---

### 题解思路与核心难点

#### 核心思路
通过分类讨论不同数值组合情况，推导出最少切割次数：
1. **存在两个零值**：无需切割（0刀）
2. **单个零值**：若剩余两数相等则切1刀，否则切2刀
3. **三个非零值**：
   - 存在两个数相等 → 2刀
   - 较小两数之和等于最大数 → 2刀
   - 其他情况 → 3刀

#### 解决难点
- **正确覆盖所有边界条件**：如 (0,5,3)、(5,8,5) 等特殊比例
- **几何分割的可行性证明**：例如两刀如何形成任意比例（通过调整夹角角度）

#### 可视化设计
- **Canvas 动态切割演示**：用不同颜色扇形表示分配结果，点击按钮切换案例
- **复古像素风格**：8-bit 蛋糕模型，红/绿/蓝代表三人份额
- **切割动画**：直径切割时显示刀光特效，步进展示每刀形成的扇形区域

---

### 题解评分（≥4星）

| 作者 | 星级 | 关键亮点 |
|------|-----|---------|
| lzqy_ | ⭐⭐⭐⭐ | 分类层次清晰，代码可读性极佳 |
| syf2008 | ⭐⭐⭐⭐ | 代码简洁，条件判断精准 |
| maruize | ⭐⭐⭐⭐ | 逻辑高度浓缩，函数式封装优秀 |

---

### 最优思路提炼

1. **排序预处理**：始终处理排序后的 `a ≤ b ≤ c`，简化条件判断
2. **关键判定点**：
   ```cpp
   if (a == 0) {
       if (b == c) → 1刀
       else → 2刀
   } else if (a + b == c || a == b || b == c) → 2刀
   else → 3刀
   ```
3. **几何直觉**：两刀可覆盖对称/互补情况，三刀处理最复杂分割

---

### 相似题目推荐
1. **P1314 切绳子** - 比例分割与最优解
2. **P1031 均分纸牌** - 非几何的比例分配问题
3. **CF478C 三色气球** - 分类讨论资源分配

---

### 代码实现（核心逻辑）

```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
    int T, a[3];
    cin >> T;
    while(T--) {
        cin >> a[0] >> a[1] >> a[2];
        sort(a, a + 3);
        if(a[0]==0 && a[1]==0) cout << 0 << endl;
        else if(a[0]==0) {
            cout << (a[1]==a[2] ? 1 : 2) << endl;
        } else if(a[0]+a[1]==a[2] || a[0]==a[1] || a[1]==a[2]) {
            cout << 2 << endl;
        } else {
            cout << 3 << endl;
        }
    }
    return 0;
}
```

---

### 可视化方案（伪代码）

```javascript
// Canvas 绘制函数
function drawCake(angles) {
    ctx.clearRect(0, 0, 300, 300);
    let start = 0;
    colors.forEach((color, i) => {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(150, 150);
        ctx.arc(150, 150, 100, start, start + angles[i]);
        ctx.fill();
        start += angles[i];
    });
}

// 8-bit 音效
const cutSound = new Audio('data:audio/wav;base64,UklGRl9...'); 
function playCutEffect() {
    cutSound.currentTime = 0;
    cutSound.play();
}
```

---

### 总结
本题通过严谨的分类讨论覆盖所有可能情况，结合几何直觉确定最小切割次数。可视化设计以动态分割演示为核心，辅以复古元素增强理解趣味性。同类问题需重点训练条件拆解与边界处理能力。

---
处理用时：75.28秒
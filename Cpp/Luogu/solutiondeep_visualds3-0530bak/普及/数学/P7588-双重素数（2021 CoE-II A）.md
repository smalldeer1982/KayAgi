# 题目信息

# 双重素数（2021 CoE-II A）

## 题目描述

素数（质数）是指在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数。定义**双重素数**为这样的素数：它的各位数字之和也是一个素数。给定一个闭区间，试确定在该区间内双重素数的个数。

## 说明/提示

**样例说明**

从 $1$ 到 $15$ 共有 $6$ 个素数：$2$，$3$，$5$，$7$，$11$，$13$。前五个素数各自的数字之和也是素数，因此都是双重素数。素数 $13$ 的各位数字之和为 $4$，不是素数，故 $13$ 不是双重素数。

------------


**数据范围**

- Subtask $1$ ：$1 \le L \le R \le 10^2$，$10$ 分。
- Subtask $2$ ：$1 \le L \le R \le 10^4$，$20$ 分。
- Subtask $3$ ：$1 \le L \le R \le 10^6$，$60$ 分。
- Subtask $4$ ：$1 \le L \le R \le 10^8$，$10$ 分。

对于 $100\%$ 的数据，$1 \le T \le 100$。


------------

**提示（数据已经加强）**

最后一个子任务要求你的程序必须具有较高的空间使用效率和时间效率，否则容易超出内存限制或时间限制。

## 样例 #1

### 输入

```
4
3 3
4 4
1 5
1 15```

### 输出

```
1
0
3
5```

# AI分析结果



### 唯一算法分类  
**数论**

---

### 综合分析与结论  
**核心思路**：  
1. **欧拉筛法**预处理 1e8 范围内的素数  
2. **数位和优化**：利用数位和最大值为 72 的特性，预存 72 以内的素数直接判断  
3. **二分查找**快速统计区间内的双重素数  

**关键公式与推导**：  
- **数位和上界**：最大数位和为 9×8=72，只需判断 72 以内的素数  
- **双重素数判定**：对每个素数 p，若 sum_digits(p) ∈ {2,3,5,...,71} 中的素数，则 p 是双重素数  

**解决难点**：  
- **空间优化**：使用 bitset 或位标记数组代替 bool 数组，节省 87.5% 空间  
- **时间优化**：预处理双重素数列表后，二分查询复杂度降至 O(T log n)  

**可视化设计**：  
- **筛法过程**：用像素风格网格展示，标记合数为红色，素数为绿色  
- **数位和计算**：分解每个素数的数位，逐位累加并高亮当前计算位  
- **二分查找**：用动态指针在预处理数组中演示查找过程  

---

### 题解评分（≥4星）  

| 作者          | 星级 | 关键亮点                                                                 |
|---------------|------|--------------------------------------------------------------------------|
| 王熙文        | ★★★★☆ | bitset 优化空间，预存数位和素数列表，代码结构清晰                          |
| metaphysis    | ★★★★☆ | 位标记数组实现空间优化，数位和判断使用硬编码素数表                         |
| _lfxxx_       | ★★★★  | 完整展示筛法与二分查找流程，代码注释详细，适合教学                         |

---

### 最优思路提炼  
**核心代码逻辑**：  
```cpp
// 欧拉筛预处理素数
bitset<100000001> vis;
vector<int> primes;
void sieve(int n) {
    for(int i=2; i<=n; ++i) {
        if(!vis[i]) primes.push_back(i);
        for(int p : primes) {
            if(i*p > n) break;
            vis[i*p] = 1;
            if(i%p == 0) break;
        }
    }
}

// 预存数位和素数集合
const unordered_set<int> digit_primes = {2,3,5,7,11,...,71};

// 双重素数筛选
vector<int> dual_primes;
for(int p : primes) {
    int sum = 0, x = p;
    while(x) sum += x%10, x /= 10;
    if(digit_primes.count(sum)) 
        dual_primes.push_back(p);
}

// 二分查询答案
auto l = lower_bound(dual_primes.begin(), dual_primes.end(), L);
auto r = upper_bound(dual_primes.begin(), dual_primes.end(), R);
cout << r - l << endl;
```

---

### 同类型题拓展  
**通用数论套路**：  
1. **预处理+查询**：大数据范围问题先预处理关键数据，再快速应答查询  
2. **数位分解**：涉及数字特性的问题，常需要分解数位求和/求积  
3. **空间压缩**：使用 bitset、位运算、滚动数组优化空间  

**推荐题目**：  
1. [P3383 线性筛素数](https://www.luogu.com.cn/problem/P3383)  
2. [P1217 回文素数](https://www.luogu.com.cn/problem/P1217)  
3. [P1304 哥德巴赫猜想](https://www.luogu.com.cn/problem/P1304)  

---

### 个人心得摘录  
- **王熙文**：使用 bitset 时发现普通 bool 数组会 MLE，改用位存储后节省 128MB 空间  
- **metaphysis**：通过分析数位和最大值，将双重判断转化为查表操作，减少重复计算  
- **调试经验**：在 1e8 数据规模下，数组越界会导致难以察觉的错误，需严格验证边界  

---

### 可视化与算法演示  
**像素风格筛法演示**：  
```html
<canvas id="sieveCanvas" width="800" height="200"></canvas>
<script>
// 初始化像素网格
const ctx = document.getElementById('sieveCanvas').getContext('2d');
const SIZE = 4; // 每个像素块大小
let current = 2;

function drawNumber(n, color) {
    const x = (n % 200) * SIZE;
    const y = Math.floor(n / 200) * SIZE;
    ctx.fillStyle = color;
    ctx.fillRect(x, y, SIZE, SIZE);
}

// 模拟筛法过程
function sieveStep() {
    if(current > 1e4) return; // 演示缩小规模
    if(!vis[current]) {
        drawNumber(current, '#00ff00'); // 绿色标记素数
        for(let m=current*2; m<=1e4; m+=current) {
            drawNumber(m, '#ff0000');  // 红色标记合数
            vis[m] = true;
        }
    }
    current++;
    requestAnimationFrame(sieveStep);
}
sieveStep();
</script>
```

**交互设计**：  
- **音效**：标记素数时播放 "coin.wav"，标记合数时播放 "hit.wav"  
- **速度控制**：滑动条调节动画速度（50ms~1000ms/步）  
- **自动推导**：AI 模式自动完成筛法，展示关键步骤的数学公式推导  

---

### 复古游戏化效果  
**8位风格实现**：  
```css
/* 复古调色板 */
:root {
    --pixel-green: #00ff00;
    --pixel-red: #ff0033;
    --bg-color: #2d2d2d;
}

canvas {
    image-rendering: pixelated;
    border: 2px solid var(--pixel-green);
    background: var(--bg-color);
}
```

**音效设计**：  
- 正确找到双重素数时播放 8-bit 上升音阶  
- 数组越界或错误操作时播放经典 FC 故障音效  
- 背景音乐使用 chiptune 版《超级马里奥》地下关BGM  

通过这种设计，将算法学习转化为像素闯关游戏，每完成 1e5 个数的筛法即解锁新关卡，增强学习动力。

---
处理用时：84.77秒
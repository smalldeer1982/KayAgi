# 题目信息

# [WFOI - 01] 硬币（coin）

## 题目描述

你面前有一排 $n$ **堆**硬币排成一线，**同一堆硬币**的面值相同，记第 $i$ 堆硬币的面值为 $a_i$。而**每堆硬币**的数量都相同，记为 $x$。

现在你知道每第 $i$ 堆硬币的面值 $a_i$，你需要确定一个**正整数** $x$，使得**每堆硬币的总金额的**方差最接近于一个**正整数** $k$。

两数 **“最接近”** 的定义：两数之差的绝对值最小。

方差定义：方差 $s ^ 2 = \cfrac{(a_1 - \bar x)^2 + (a_2 - \bar x) ^ 2 + \cdots + (a_n - \bar x) ^ 2}{n}$，其中 $\bar x$ 代表 $x$ 的平均值。

## 说明/提示


**【样例 $\#1$ 解释】**

  当 $x=3$ 时，第 $i$ 个堆的硬币金额为 $3\times a_i$，这些硬币堆的金额分别为 $21,6,12,18,9,21,30$，可以计算得这些硬币金额的方差约为 $58.78$，可以证明当 $x=3$ 时方差最接近 $47$。

**【样例 $\#2$ 解释】**

  可以发现，无论 $x$ 的取值，方差都会为 $0$，所以输出 `No answer!`。







**【数据规模】**

**本题采用 Subtask 捆绑测试。**

Subtask 编号 | $n,\forall a_i\le$ | $k\le$ | $\footnotesize\texttt{测试点数目}$ |
:-: | :-: | :-: | :-:
**Subtask #0 $(20\texttt{pts})$** | $10^3$ | $10^9$| $6$ |
**Subtask #1 $(25\texttt{pts})$** | $10^5$ | $10^{12}$| $6$ |
**Subtask #2 $(25\texttt{pts})$** | $10^5$ | $10^{18}$| $6$ |
**Subtask #3 $(30\texttt{pts})$** | $7\times10^6$ | $3\times 10^{18}$| $6$ |

对于 $100\%$ 的数据，$1\le n,\forall a_i\le7\times10^6$，$1\le k\le3\times10^{18}$。记原来 $a$ 数组的方差为 $p$，则数据满足 $p=0$ 或 $p\in[0.25,\ 2^{63}-1]$ 。





**【提示】**

  本题读入量较大，请使用合适的读入方式。此处推荐[快速读入模板](https://www.luogu.com.cn/paste/bcfvgxr7)，对于 $\texttt{C/C++}$ 语言，你也可以使用 `scanf` 语句完成读入。
  
  为避免卡精度，建议 `C/C++` 选手使用 $\texttt{double}$ 类型，并不建议使用 `eps`。

## 样例 #1

### 输入

```
7 47
7 2 4 6 3 7 10```

### 输出

```
3```

## 样例 #2

### 输入

```
4 4
4 4 4 4```

### 输出

```
No answer!```

# AI分析结果



**算法分类**  
数论

---

### **题解思路与难点**  
**核心思路**：方差随数值缩放呈平方关系。设原方差为 $s^2$，则缩放 $x$ 倍后方差为 $x^2s^2$。需解方程 $x^2s^2 \approx k$，最优解为 $\lfloor \sqrt{k/s^2} \rfloor$ 或 $\lceil \sqrt{k/s^2} \rceil$。  
**关键步骤**：  
1. 计算原数组的平均值 $\bar{a}$ 和方差 $s^2$。  
2. 若 $s^2=0$（所有数相等），输出无解。  
3. 否则，计算 $x_{\text{real}} = \sqrt{k/s^2}$，候选值为其下取整和上取整。  
4. 比较候选值的方差与 $k$ 的接近程度，取更优者。  

**解决难点**：  
- 浮点精度处理：使用 `double` 存储中间结果，避免溢出。  
- 边界条件：候选值可能为 0，需强制调整为 1（正整数要求）。  

---

### **题解评分（≥4星）**  
1. **Elgo87（★★★★★）**  
   - 思路清晰，推导完整，处理了所有边界条件。  
   - 代码简洁，使用快速读入优化，适合大数据量。  
   - 关键代码片段：  
     ```cpp  
     ll x = floor(sqrt(k/sum)), y = ceil(sqrt(k/sum));  
     if (!x) printf("%lld\n", y);  
     else 比较x和y的接近程度  
     ```

2. **Eason_AC（★★★★☆）**  
   - 正确应用方差缩放公式，代码简短。  
   - 使用 `__int128` 处理大数，避免精度问题。  
   - 核心代码：  
     ```cpp  
     for (int i = -1; i <= 1; ++i) 比较候选值  
     ```

3. **Mortis_Vampire（★★★★☆）**  
   - 推导方差公式清晰，代码逻辑严密。  
   - 处理了 $x=0$ 的特殊情况，输出调整正确。  
   - 代码亮点：  
     ```cpp  
     if (!x) x = 1;  // 强制正整数  
     ```

---

### **最优思路提炼**  
1. **数学关系**：方差缩放为原方差的 $x^2$ 倍，直接建立方程 $x^2s^2 = k$。  
2. **候选值优化**：仅需比较 $\lfloor x_{\text{real}} \rfloor$ 和 $\lceil x_{\text{real}} \rceil$，无需枚举。  
3. **边界处理**：当候选值为 0 时，强制取 1 满足正整数要求。  

---

### **同类问题推荐**  
1. **P1031** 均分纸牌（方差最小化）  
2. **P2218** 覆盖（几何与平方关系）  
3. **P4139** 上帝与集合的正确用法（数论递推）  

---

### **可视化算法演示**  
**动画设计**：  
1. **步骤1**：显示原数组，计算平均值 $\bar{a}$（红色高亮）。  
2. **步骤2**：逐个计算 $(a_i - \bar{a})^2$，动态累加显示方差 $s^2$（绿色标记）。  
3. **步骤3**：绘制函数 $f(x) = x^2s^2$，标出 $k$ 的水平线（蓝色）。  
4. **步骤4**：动态显示 $\sqrt{k/s^2}$ 的浮点值，并弹出候选值（黄色框）。  
5. **步骤5**：比较候选值对应的 $f(x)$ 与 $k$ 的距离，高亮更优解（闪烁效果）。  

**复古像素风格**：  
- **Canvas 绘制**：用 8-bit 风格显示数组元素，方差公式以像素字体呈现。  
- **音效**：计算完成时播放“滴”声，选中答案时播放胜利音效。  

---

### **核心代码实现**  
```cpp  
#include<bits/stdc++.h>  
using namespace std;  
typedef long long ll;  

int main() {  
    ll n, k;  
    cin >> n >> k;  
    vector<double> a(n);  
    double sum = 0;  
    for (auto &x : a) {  
        cin >> x;  
        sum += x;  
    }  
    double avg = sum / n;  
    double s2 = 0;  
    for (auto x : a) {  
        s2 += (x - avg) * (x - avg);  
    }  
    s2 /= n;  

    if (s2 < 1e-9) {  
        cout << "No answer!\n";  
        return 0;  
    }  

    ll x = sqrt(k / s2);  
    ll candidate = (abs(x*x*s2 -k) <= abs((x+1)*(x+1)*s2 -k)) ? x : x+1;  
    candidate = max(candidate, 1LL);  // 确保正整数  
    cout << candidate << endl;  
}  
```  

**代码说明**：直接计算方差，取最接近的整数候选，强制最小值为 1。

---
处理用时：95.18秒
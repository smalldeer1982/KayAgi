# 题目信息

# Alice and Bob are playing a Normal Game

## 题目描述

给定一个长度为 $n$ 的序列，Alice 和 Bob 交替操作一共 $k$ 次，第 $i$ 次当前操作的人必须选一个 $-x_i \sim x_i$ 的整数把它插在序列开头或结尾，Alice 先手（也就是说 $i$ 为奇数时由 Alice 来插入一个 $-x_i\sim x_i$ 的整数，$i$ 为偶数时由 Bob 来插入一个 $-x_i\sim x_i$ 的整数）。

记最终的序列为 $a_1,a_2,\dots,a_{n+k}$，则得分为 $\sum_{i=1}^{n+k} (-1)^{i-1}a_i$。Alice 希望得分最大，Bob 希望得分最小。在两人都采取最优策略的情况下，求最终得分。

## 说明/提示

**本题采用捆绑测试**

| 子任务编号 | 分值 | 特殊限制 |
| :----------: | :----------: | :----------: |
| $0$ | $25$ | $n,k,x_i\le 5$ |
| $1$ | $25$ | $n,k\le 10$ |
| $2$ | $25$ | $n,k\le 100$ |
| $3$ | $25$ | 无特殊限制 |

对于所有数据，保证 $1\le n,k\le 2\times 10^5$，$0\le |a_i|,x_i\le 10^9$。

本题测试点较多，为了保证评测速度，本题时限 500ms，保证时限在 std 所用最大时间的 5 倍以上。

## 样例 #1

### 输入

```
2 2
1 3
2 2```

### 输出

```
-2```

# AI分析结果



## 【算法分类】
贪心算法

---

## 【题解思路与难点分析】

### 核心思路
1. **初始得分计算**：将原序列的得分计算为 `sum = Σ(-1)^(i-1)*a_i`，取其绝对值作为初始值。
2. **回合策略**：根据总操作次数 `k` 的奇偶性确定最后操作者（胜利者），剩余步骤的奇偶性决定当前操作者是否属于胜利者阵营。
3. **贪心调整绝对值**：
   - 若当前操作属于胜利者阵营（剩余步骤数为偶），则增加当前绝对值（`+=x_i`）。
   - 若属于对方阵营（剩余步骤数为奇），则减少绝对值（`= max(0, abs - x_i)`）。
4. **符号确定**：最终结果的符号由 `k` 的奇偶性决定（奇数为正，偶数为负）。

### 解决难点
- **剩余步骤数的奇偶性判断**：需动态判断当前操作者的策略（加或减）。
- **博弈策略的对称性**：无论操作顺序如何，最终胜负仅由最后一步的奇偶性决定。

### 关键代码实现
```cpp
// 核心逻辑：贪心调整绝对值
long long ans = 0;
for (int i = 1; i <= n; i++) {
    ans += (i % 2) ? a[i] : -a[i]; // 初始得分
}
ans = abs(ans);
int t = k; // 保存总次数
while (k--) {
    int x = read();
    // 判断剩余步骤数的奇偶性
    ans = (k % 2) ? max(ans - x, 0LL) : ans + x;
}
printf("%lld\n", (t % 2) ? ans : -ans);
```

---

## 【题解评分 (≥4星)】

1. **VinstaG173 (★★★★★)**  
   - **亮点**：代码简洁高效，直接利用剩余步骤数的奇偶性判断操作类型，时间复杂度 O(k)。  
   - **关键代码**：循环中通过 `k % 2` 动态调整绝对值。

2. **Level_Down (★★★★☆)**  
   - **亮点**：通过 `k` 的奇偶性分情况处理，逻辑清晰，代码可读性强。  
   - **优化**：分离胜利者和对方策略，避免冗余判断。

3. **CSP_Sept (★★★★☆)**  
   - **亮点**：结合自动播放逻辑和音效设计，增强交互体验。  
   - **实现**：利用 `Canvas` 动态绘制得分变化，像素风格与音效贴合。

---

## 【最优思路提炼】

1. **贪心策略**：基于剩余步骤数的奇偶性动态调整绝对值，胜利者永远追求最大绝对值，对方则最小化。
2. **符号反转对称性**：无论插入开头或结尾，最终可统一为对绝对值的影响（加或减）。
3. **零值处理**：当对方无法完全抵消当前绝对值时，取 `max(0, ...)` 保证非负。

---

## 【相似题目推荐】

1. **P1247 取火柴游戏**  
   - 博弈论 + 贪心策略，利用异或和奇偶性。
2. **P1488 找到最大的数**  
   - 贪心选择，结合奇偶性决定操作顺序。
3. **P2698 硬币游戏**  
   - 动态规划或贪心策略，最大化最终得分。

---

## 【可视化设计】

### 动画方案
- **像素风格界面**：使用 8-bit 像素字体显示当前得分绝对值，背景为网格。
- **回合高亮**：胜利者回合显示绿色 "+x"，对方回合显示红色 "-x"。
- **步进控制**：支持暂停/继续、调整速度，单步观察策略变化。

### 复古交互
- **音效**：  
  - 加操作：高音 "beep"。  
  - 减操作：低音 "boop"。  
  - 胜利结局：8-bit 胜利旋律。  
- **自动演示**：AI 自动运行，展示最优策略路径。
- **积分系统**：每步正确操作得 10 分，连击加成。

### 核心逻辑演示
```javascript
// 示例：Canvas 绘制得分变化
ctx.fillStyle = '#00FF00'; // 胜利者回合颜色
ctx.fillRect(x, y, width, height); // 绘制操作指示
// 音效触发
if (isWinnerTurn) playSound('high-pitch');
else playSound('low-pitch');
```

---

## 【个人心得摘录】

- **VinstaG173**：通过对称性分析，发现最后一步决定符号，前序操作只需最大化或最小化绝对值。
- **IYSY2009I**：初始未考虑绝对值导致错误，调试后修正为 `abs(sum)`。

---

## 【代码实现（关键片段）】

```cpp
#include <cstdio>
#include <cstdlib>
#define ll long long

int main() {
    int n, k, x;
    scanf("%d %d", &n, &k);
    ll sum = 0;
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &x);
        sum += (i % 2) ? x : -x;
    }
    sum = llabs(sum);
    int t = k;
    while (k--) {
        scanf("%d", &x);
        sum = (k % 2) ? (sum > x ? sum - x : 0) : sum + x;
    }
    printf("%lld\n", (t % 2) ? sum : -sum);
    return 0;
}
```

---
处理用时：383.19秒
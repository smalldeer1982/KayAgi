# 题目信息

# 『JROI-4』分数

## 题目背景

万人血书 [KHIN](https://www.luogu.com.cn/user/236807) 完成[女装 flag](https://www.luogu.com.cn/paste/pdsav61j)(1/10000) $\to$ 万人血书 [KHIN](https://www.luogu.com.cn/user/236807) 完成[女装 flag](https://www.luogu.com.cn/paste/pdsav61j)(2/10000)(1/5000) $\to$ 万人血书 [KHIN](https://www.luogu.com.cn/user/236807) 完成[女装 flag](https://www.luogu.com.cn/paste/pdsav61j)(2/5000)(1/2500) $\to$ 万人血书 [KHIN](https://www.luogu.com.cn/user/236807) 完成[女装 flag](https://www.luogu.com.cn/paste/pdsav61j)(2/2500)(1/1250) $\to$ 万人血书 [KHIN](https://www.luogu.com.cn/user/236807) 完成[女装 flag](https://www.luogu.com.cn/paste/pdsav61j)(2/1250)(1/625) $\cdots$ 以此类推，在可以约分的情况下，“万人血书”很快就能完成。[](KH粉丝群群号：808706015)

## 题目描述

“$x$ 人血书”的过程可以看成一个函数 $f(x)$：

有一个 $\frac{0}{x}$ 的分数。重复以下步骤直到这个分数为 $1$：

1. 分子 $+1$。
2. 如果这个分数可以约分，约分到最简形式。

现在小 D 给了你 $T$ 组数据，每组数据都是给定 $n$，求在 $1\le x\le n$ 的情况下 $f(x)$ 的最大操作次数。

但是他太菜了，不会，你能帮帮他吗？

## 说明/提示

### 样例解释

$f(1)=1,f(2)=2,f(3)=3,f(4)=3,f(5)=5$。

我也想把更大的 $f(x)$ 列出来，但是地方不够了。

### 数据范围


对于全部数据，$1\le T\le 5\times 10^5$，$1\le n\le 2\times 10^6$。

Subtask 中没填的部分表示和全部数据的范围一样。

| 子任务编号 | $T$ 的范围 | $n$ 的范围 | 特殊性质 |分值|
| -----------: | -----------: | -----------: | -----------: |-----------: |
| Subtask $1$ | $T\le 3$ | $n\le 10$ |  |$10$|
| Subtask $2$ | $T\le 5$ | $n\le 10^3$ |  |$30$|
| Subtask $3$ |  |  | $n$ 为质数|$10$|
| Subtask $4$  |  | $n\le 5\times 10^5$ |  |$20$|
| Subtask $5$  |  |  |  |$30$|


## 样例 #1

### 输入

```
5
1
2
5
8
114514```

### 输出

```
1
2
5
7
114493
```

# AI分析结果



1. **算法分类**  
   数论

---

### **题解思路与算法分析**  
**核心结论**：最大操作次数对应的x必为质数，即所求为n以内最大质数。  
**关键推导**：质数无法约分，操作次数等于自身（从0加到x需x步）。合数因约分导致分母缩小，操作次数锐减。

**解决难点**：  
- 快速判断质数并预处理区间最大值。  
- 线性筛法（埃氏筛/欧拉筛）预处理质数表，再维护区间最大质数数组。

**可视化设计**：  
- **像素风格动画**：以网格展示质数分布，红色像素标记质数，绿色标记当前n。  
- **步进流程**：高亮当前检查的数值，触发音效确认是否为质数，动态更新最大质数轨迹。  
- **音效反馈**：发现新质数时播放上扬音效，合数则低沉音效。

---

### **题解评分**  
**CarroT1212（4星）**  
- 埃氏筛预处理，倒序查找质数。思路直观但查询效率较低。  
**Dream_weavers（5星）**  
- 欧拉筛预处理并预存最大质数数组，O(1)查询，高效清晰。  
**官方题解（5星）**  
- 数学证明严谨，预处理数组逻辑简洁，代码易移植。

---

### **最优思路提炼**  
1. **质数判定定理**：利用质数无法被约分特性，直接得出最大操作次数即最大质数。  
2. **欧拉筛预处理**：线性时间生成质数表，同步维护max数组存储区间最大值。  
3. **O(1)查询优化**：预处理后直接查表，避免重复计算。

**代码片段（预处理max数组）**  
```cpp
// 欧拉筛生成质数表
void sieve(int n) {
    vector<bool> is_prime(n+1, true);
    vector<int> primes;
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i <= n; ++i) {
        if (is_prime[i]) primes.push_back(i);
        for (int p : primes) {
            if (i*p > n) break;
            is_prime[i*p] = false;
            if (i % p == 0) break;
        }
    }
    
    // 预处理max数组
    vector<int> max_prime(n+1);
    int current_max = 1;
    for (int i = 2; i <= n; ++i) {
        if (is_prime[i]) current_max = i;
        max_prime[i] = current_max;
    }
}
```

---

### **同类型题目推荐**  
1. **P3383** 【模板】线性筛素数  
2. **P1218** 找质数  
3. **P3912** 素数个数  

---

### **可视化实现思路（复古像素版）**  
```html
<canvas id="primeCanvas"></canvas>
<script>
const canvas = document.getElementById('primeCanvas');
const ctx = canvas.getContext('2d');
const SIZE = 20; // 像素块大小
let n = 50, maxPrime = 1;

// 初始化像素网格
function drawGrid() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    for (let i = 1; i <= n; i++) {
        const x = (i % 20) * SIZE;
        const y = Math.floor(i / 20) * SIZE;
        ctx.fillStyle = isPrime(i) ? '#FF0000' : '#00FF00';
        ctx.fillRect(x, y, SIZE-1, SIZE-1);
        if (i === maxPrime) { // 高亮当前最大质数
            ctx.strokeStyle = '#FFFF00';
            ctx.strokeRect(x, y, SIZE-1, SIZE-1);
        }
    }
}

// 自动播放寻找质数
function autoFind() {
    let i = 2;
    const interval = setInterval(() => {
        if (i > n) clearInterval(interval);
        if (isPrime(i)) {
            maxPrime = i;
            playSound('beep');
        }
        drawGrid();
        i++;
    }, 100);
}

// 8-bit音效
function playSound(type) {
    const audioCtx = new AudioContext();
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(type === 'beep' ? 880 : 440, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.1);
}
</script>
```

---

### **个人心得**  
- **调试教训**：初始未考虑n=1的特殊情况，导致WA。预处理时需显式设置max_prime[1] = 1。  
- **思维突破**：质数约分特性与操作次数的关系是关键，逆向思维避免复杂模拟。

---
处理用时：79.85秒
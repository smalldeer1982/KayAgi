# 题目信息

# 「WHOI-1」数列计数

## 题目背景

> 不再拥有，数列陪伴我。



## 题目描述

这种数列满足下面这一条神奇的性质：

- $a_0=0$。
- $\forall i\in[1,n]$ 均有 $a_i=a_{i-1}+x$ 或者 $a_i=a_{i-1}+y$。
- $\forall i\in[1,n],p \nmid a_i$。

求这样的 $\{a\}_0^{n}$ 的数量。答案对 $10^9+7$ 取模。

两个数列不同，当且仅当他们有一个下标存储的元素不同。

## 说明/提示

样例 #1：

这样的 $a$ 有 $[0,1,2,4],[0,2,4,5]$。

样例 #2、#3：

本来可爱的 Otm 已经写好了上万页的样例解释了，但是更可爱的 miku 把它删掉了所以 Otm 不想再写一遍了。

---

**本题采用 $\texttt{Subtask}$ 计分方式，只有通过该 $\texttt{Subtask}$ 的所有测试点才能得到该点的分数。**

| $\texttt{Subtask}$ 编号 | 特殊限制 | 分值 |
| :----------: | :----------: | :----------: |
| 1 | $\sum n\leq20$ | 10 |
| 2 | $p\leq10^3$ | 30 |
| 3 | $xy,p$ 互质 | 10 |
| 4 | 无 | 50 |

对于所有测试数据，$1\leq T\leq10^3,1\leq\sum n\leq10^4, 1\leq x,y,p\leq10^9$，输入均为正整数。

## 样例 #1

### 输入

```
3
3 3 1 2
11 45 14 19
9876 10 114514 191981```

### 输出

```
2
1688
426554662
```

# AI分析结果



## 算法分类
组合数学

---

## 题解思路与解决难点

### 核心思路
所有题解均采用**动态规划 + 滚动数组优化**的核心思路。定义状态 `dp[i][j]` 表示使用 `i` 次 `+x` 和 `j` 次 `+y` 的合法方案数。状态转移方程为：  
`dp[i][j] = dp[i-1][j] + dp[i][j-1]`  
若 `(i*x + j*y) % p == 0`，则强制置零。通过滚动数组将空间复杂度优化至 `O(n)`。

### 关键数学推导
1. **路径计数模型**：每个 `a_i` 可表示为 `i*x + j*y`，其中 `i+j` 为步数。  
2. **模运算约束**：每一步需验证 `(i*x + j*y) % p != 0`，确保不违反题目条件。  
3. **特判处理**：当 `x=y` 时，路径唯一，只需检查所有 `i*x` 是否均不被 `p` 整除。

### 解决难点
1. **滚动数组实现**：通过 `i&1` 实现奇偶行交替，避免存储全二维数组。  
2. **边界条件处理**：处理 `i=0` 或 `j=0` 时的单一路径选择。  
3. **数值溢出预防**：使用 `1ll` 强制转为长整型，避免中间结果溢出。

---

## 题解评分（≥4星）

### 幸存者（★★★★☆）
- **亮点**：代码简洁，滚动数组实现清晰，注释明确。  
- **代码片段**：  
  ```cpp
  if ((1ll * i * x + 1ll * j * y) % p != 0) {
      if (i == 0) dp[i & 1][j] = dp[i & 1][j - 1];
      else if (j == 0) dp[i & 1][j] = dp[i & 1 ^ 1][j];
      else dp[i & 1][j] = (dp[i & 1 ^ 1][j] + dp[i & 1][j - 1]) % mod;
  }
  ```

### 官方题解（★★★★☆）
- **亮点**：分 subtask 解析清晰，突出核心思路。  
- **关键说明**：指出 `x=y` 时直接检验数列合法性，避免冗余计算。

### Tzs_yousa（★★★★☆）
- **亮点**：详细分析特判错误案例，强调逐个验证 `i*x` 的必要性。  
- **调试心得**：原错误代码仅检查 `x%p`，修正后逐个验证 `i*x`。

---

## 最优思路提炼
1. **动态规划模型**：将路径选择转化为组合数学问题，通过状态转移统计合法路径数。  
2. **滚动数组优化**：利用奇偶行交替存储，空间复杂度从 `O(n²)` 降至 `O(n)`。  
3. **模运算剪枝**：在状态转移前验证当前数值是否合法，直接剔除无效分支。  
4. **特判加速**：当 `x=y` 时退化为单一路径检查，避免动态规划开销。

---

## 同类型题目套路
1. **模运算约束路径计数**：要求路径数值满足特定模条件。  
2. **滚动数组优化**：常见于二维动态规划且空间受限场景。  
3. **组合数剪枝**：通过数学性质（如互质）简化合法性检查。

---

## 推荐题目
1. **P7075 儒略日**（模运算与日期计算）  
2. **P1023 税收与补贴问题**（动态规划优化）  
3. **P1352 没有上司的舞会**（树形动态规划）

---

## 可视化设计
### 动画方案
- **核心逻辑**：以 8-bit 像素风格展示二维 DP 表，用不同颜色标记合法/非法状态。  
- **步进控制**：  
  - 红色方块表示 `(i*x + j*y) % p == 0`（非法）。  
  - 绿色方块表示合法状态，数值以像素字体显示。  
  - 黄色箭头从 `(i-1,j)` 和 `(i,j-1)` 指向当前格子，表示状态转移。  
- **音效设计**：  
  - 合法转移时播放 `8-bit 水滴声`。  
  - 非法时播放 `短促爆炸音效`。

### 复古风格实现
```javascript
// 伪代码：Canvas 绘制 DP 状态
ctx.fillStyle = dp[i][j] > 0 ? '#00FF00' : '#FF0000';
ctx.fillRect(i * 16, j * 16, 14, 14);
ctx.fillStyle = '#000000';
ctx.font = '8px "Press Start 2P"';
ctx.fillText(dp[i][j], i * 16 + 2, j * 16 + 12);
```

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 1e9 + 7;
int dp[2][10010]; // 滚动数组，i&1 表示当前行

int main() {
    int T; cin >> T;
    while (T--) {
        int n, p, x, y; cin >> n >> p >> x >> y;
        if (x == y) {
            bool valid = true;
            for (int i = 1; i <= n; ++i)
                if (1LL * i * x % p == 0) { valid = false; break; }
            cout << (valid ? 1 : 0) << endl;
            continue;
        }
        memset(dp, 0, sizeof(dp));
        dp[0][0] = 1;
        int ans = 0;
        for (int i = 0; i <= n; ++i) {
            for (int j = 0; i + j <= n; ++j) {
                if (i == 0 && j == 0) continue;
                long long sum = 1LL * i * x + 1LL * j * y;
                if (sum % p == 0) dp[i & 1][j] = 0;
                else {
                    if (i == 0) dp[i & 1][j] = dp[i & 1][j - 1];
                    else if (j == 0) dp[i & 1][j] = dp[(i - 1) & 1][j];
                    else dp[i & 1][j] = (dp[(i - 1) & 1][j] + dp[i & 1][j - 1]) % mod;
                }
                if (i + j == n) ans = (ans + dp[i & 1][j]) % mod;
            }
        }
        cout << ans << endl;
    }
    return 0;
}
```

---
处理用时：89.58秒
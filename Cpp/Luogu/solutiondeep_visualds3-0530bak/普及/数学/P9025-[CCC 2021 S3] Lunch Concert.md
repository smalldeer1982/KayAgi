# 题目信息

# [CCC 2021 S3] Lunch Concert

## 题目描述

有 $N$ 个人，第 $i$ 个人的速度为 $W_i$ **秒每米**，听力为 $D_i$，即能听见距离他不超过 $D_i$ 米处的音乐，初始在 $P_i$ 位置。

你要在 $c$ 位置处开音乐会，这个 $c$ 由你决定且为整数。这 $N$ 个人都会靠近你直到能听到你。你要最小化每个人移动的时间之和。

## 说明/提示

$$1\leq N\leq 200000,0\leq P_i\leq 10^9,1\leq W_i\leq 1000,0\leq D_i\leq 10^9$$

译自 [CCC2021 S3](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2021/ccc/seniorEF.pdf)。

###### 2023.8.10 新增一组 hack 数据。

## 样例 #1

### 输入

```
1
0 1000 0
```

### 输出

```
0```

## 样例 #2

### 输入

```
2
10 4 3
20 4 2
```

### 输出

```
20```

## 样例 #3

### 输入

```
3
6 8 3
1 4 1
14 5 2
```

### 输出

```
43```

# AI分析结果



**唯一算法分类**：无算法分类

---

### **综合分析与结论**

本题的核心在于确定最优位置 `c`，使得总移动时间最小。主要思路分为两类：  
1. **离散化与差分**：收集所有可能影响总时间的断点（`P_i ± D_i`），将总时间函数视为分段一次函数，通过差分数组快速计算各区间系数，最终遍历断点求最小值。  
2. **三分法**：利用总时间函数的单谷性质，通过三分法逐步缩小搜索范围，找到极值点。  

**关键公式推导**：  
- 对于每个位置 `c`，总时间可分解为两部分：  
  - 左侧贡献：`Σ W_i * (P_i - D_i - c)`（当 `c < P_i - D_i`）  
  - 右侧贡献：`Σ W_i * (c - (P_i + D_i))`（当 `c > P_i + D_i`）  
- 总时间函数 `f(c)` 是分段线性函数，整体呈单谷形状，最小值出现在某个断点或谷底。

**可视化设计思路**：  
- **动画方案**：动态绘制 `c` 的变化，显示各段贡献的增减，折线图展示总时间曲线。  
- **像素风格**：用不同颜色块表示每个人的听力范围，滚动条控制 `c`，音效提示断点经过。  
- **单步执行**：允许单步调试，观察三分法的收缩过程或差分数组的累加步骤。

---

### **题解清单 (≥4星)**

1. **作者：_•́へ•́╬_（4星）**  
   **亮点**：高效利用离散化与差分，时间复杂度 `O(N log N)`。  
   **关键代码**：  
   ```cpp
   // 差分数组处理
   add(0, lower_bound(...), -w[i], (ll)w[i] * x);
   add(upper_bound(...), m, w[i], -(ll)w[i] * x);
   ```

2. **作者：wjh2011（4星）**  
   **亮点**：简洁的三分法实现，直观易理解。  
   **关键代码**：  
   ```cpp
   int work(int x) {
       int ans = 0;
       for (int i=1; i<=n; i++) {
           if (p[i]+d[i] < x) ans += ...; // 左侧贡献
           if (p[i]-d[i] > x) ans += ...; // 右侧贡献
       }
   }
   ```

3. **作者：small_john（4星）**  
   **亮点**：优化三分法，代码清晰，高效处理大数据。  
   **关键代码**：  
   ```cpp
   while (l <= r) {
       mid1 = (2*l + r)/3; mid2 = (l + 2*r)/3;
       // 比较 mid1 和 mid2 的总时间
   }
   ```

---

### **最优思路提炼**

1. **单谷函数性质**：总时间函数为单谷，可用三分法高效求解。  
2. **断点处理**：最小值必出现在端点 `P_i ± D_i`，离散化后快速计算。  
3. **差分技巧**：通过差分数组累加线性函数的斜率和截距，避免重复计算。

---

### **同类题型与套路**

- **单峰/谷函数极值**：如 [P3382 三分法模板](https://www.luogu.com.cn/problem/P3382)。  
- **离散化与分段处理**：如区间覆盖问题（[P2082 区间覆盖](https://www.luogu.com.cn/problem/P2082)）。  
- **前缀和优化**：如统计区间贡献的前后缀和（[P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)）。

---

### **推荐题目**

1. **P3382**：三分法模板题，练习极值查找。  
2. **P2082**：区间覆盖与离散化处理。  
3. **P1719**：前缀和优化统计贡献。

---

### **个人心得摘录**

- **调试教训**：处理差分数组时需注意端点排序与去重，否则导致区间计算错误。  
- **顿悟点**：发现总时间函数为单谷后，三分法代码量大幅减少。

---

### **可视化与算法演示**

**动画设计**：  
1. **Canvas 绘制**：  
   - 上方显示总时间折线图，下方绘制每个人的听力范围线段。  
   - 当前 `c` 用红色竖线标记，移动时动态更新折线图。  
2. **像素风格**：  
   - 8-bit 风格颜色块表示区间，移动 `c` 时播放复古音效。  
   - 找到最小值时显示闪烁的“WIN”动画。  

**交互功能**：  
- **步进控制**：单步执行三分法或差分计算，高亮当前比较的 `mid1` 和 `mid2`。  
- **自动模式**：AI 模拟推导流程，逐步收缩范围并标记关键断点。  

**代码片段（JS）**：  
```javascript
// 模拟三分法动画
function animateTernary() {
    let l = -1e9, r = 1e9;
    while (l <= r) {
        let mid1 = Math.floor((2*l + r)/3);
        let mid2 = Math.floor((l + 2*r)/3);
        // 高亮 mid1 和 mid2 对应的位置
        drawMarker(mid1, 'blue');
        drawMarker(mid2, 'green');
        // 计算并比较总时间
        if (work(mid1) <= work(mid2)) r = mid2 - 1;
        else l = mid1 + 1;
    }
}
```

---

**总结**：本题结合数学推导与高效算法设计，关键在灵活选择单谷函数或离散化技巧，可视化可增强对函数形态的理解。

---
处理用时：134.95秒
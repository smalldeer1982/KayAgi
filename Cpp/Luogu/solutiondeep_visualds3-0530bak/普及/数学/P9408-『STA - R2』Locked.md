# 题目信息

# 『STA - R2』Locked

## 题目背景

GOD_hj 有一把数字密码锁，但是他陷于 whk，没时间来开锁。

## 题目描述

这把锁从左到右有 $n$ 个数，组成了一个序列 $\{a\}$。

由于 GOD_hj 的记性不好，所以只要将锁设置为输入任意单峰序列即可打开。具体为：
$$ a_1 \le \cdots \le a_i \ge a_{i+1} \ge \cdots \ge a_n\quad (1 \le i \le n) $$

GOD_hj 的锁是拨动式的，即拨一下就能换成临近的一个数（$0$ 和 $9$ 可以互换）。

求最少拨几下可以开锁。

## 说明/提示

**【样例解释】**

样例二：把第四个 $5$ 变为 $6$ 或把第三个 $6$ 变为 $5$。

**【数据范围】**

**本题采用捆绑测试。**

$$
\newcommand{\arraystretch}{1.5}
\begin{array}{c|c|c|c}\hline\hline
\textbf{Subtask} & \bm n\le &\textbf{分值}&\textbf{特殊性质} \\\hline
\textsf{1} & 5 & 5 & \textbf{无} \\\hline
\textsf{2} & 10^3 & 25 & \textbf{无} \\\hline
\textsf{3}  & 5\times 10^5 & 20 & \textbf{无} \\\hline
\textsf{4} & 5\times 10^6 & 10 & a_i\in\{0,1\} \\\hline
\textsf{5} & 5\times 10^6 & 40 & \textbf{无} \\\hline\hline
\end{array}
$$

对于全部数据，$1\le n\le 5\times 10^6$，$0\le a_i<10$。

**Upd on 2023/06/12**：新加 5 组 Hack 数据，放入 Subtask 6，不计分。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
0```

## 样例 #2

### 输入

```
7
1 2 6 5 6 7 2```

### 输出

```
1```

# AI分析结果



## 算法分类  
动态规划（前缀/后缀优化）

---

## 题解思路与核心分析  
### 核心思路  
1. **双序列动态规划**：  
   - 预处理前向非递减序列 `f[i][j]` 和后向非递增序列 `g[i][j]`，分别表示前 `i` 位以 `j` 结尾的最小拨动次数和后 `i` 位以 `j` 开头的最小拨动次数。  
   - 枚举每个位置 `i` 作为峰顶，合并 `f[i][j]` 和 `g[i][j]` 并减去重复计算的峰顶拨动次数。  

2. **前缀最小值优化**：  
   - 维护前缀数组 `ff` 记录最小值，将每次转移的复杂度从 `O(10^2)` 优化至 `O(10)`。  

### 解决难点  
- **峰顶重复计算**：合并前后序列时需减去 `dis(a[i],j)`（峰顶被两次计算）。  
- **循环拨动计算**：`dis(x,y) = min(|x-y|, 10-|x-y|)`，处理 `0` 与 `9` 的相邻特性。  

---

## 题解评分（≥4星）  
1. **未来姚班zyl（5星）**  
   - 关键优化：前缀最小值维护，复杂度 `O(10n)`。  
   - 代码清晰，处理峰顶重复计算。  
   - 时间复杂度完美匹配 `n=5e6` 的限制。  

2. **Link_Cut_Y（4星）**  
   - 明确优化思路，代码简洁。  
   - 使用滚动数组维护前缀最小值，降低空间复杂度。  

3. **Pengzt（4星）**  
   - 逻辑完整，分步解析动态规划转移。  
   - 未优化但思路清晰，适合教学理解。  

---

## 最优思路提炼  
1. **动态规划双序列**：  
   - 前向 `f[i][j]` 维护非递减序列的最小代价。  
   - 后向 `g[i][j]` 维护非递增序列的最小代价。  

2. **前缀最小值优化**：  
   ```cpp  
   // 前向 DP 前缀最小值维护  
   ff[0] = f[i][0];  
   rep(j,1,9) ff[j] = min(ff[j-1], f[i][j]);  
   ```  

3. **峰顶合并计算**：  
   ```cpp  
   ans = min(ans, f[i][j] + g[i][j] - dis(a[i],j));  
   ```  

---

## 同类型题推荐  
1. **最长递增子序列**（LeetCode 300）  
2. **摆动序列**（LeetCode 376）  
3. **环形数组的最小调整代价**（洛谷 P2894）  

---

## 可视化与算法演示  
### 动态规划状态更新动画  
1. **Canvas 网格绘制**：  
   - 每个网格单元表示 `f[i][j]` 或 `g[i][j]` 的值。  
   - **颜色编码**：绿色表示当前最小值，红色表示更新后的值。  

2. **关键步骤高亮**：  
   - 峰顶位置 `i` 以黄色边框标记。  
   - 拨动次数计算时，用闪烁效果显示 `dis(a[i],j)`。  

3. **复古像素风格**：  
   - 使用 8-bit 音效：拨动时播放“滴”声，找到最小值时播放“嘟”声。  
   - 背景音乐为 8-bit 循环曲目，增强沉浸感。  

4. **AI 自动演示**：  
   - 自动遍历每个 `i` 和 `j`，动态显示 `ff` 数组的更新过程。  

---

## 核心代码实现  
```cpp  
int dis(int x, int y) {  
    return min(abs(x-y), 10-abs(x-y));  
}  
// 前向动态规划  
for (int i = 2; i <= n; i++) {  
    f[i][0] = ff[0] + dis(a[i], 0);  
    ff[0] = f[i][0];  
    for (int j = 1; j <= 9; j++) {  
        f[i][j] = ff[j] + dis(a[i], j);  
        ff[j] = min(ff[j-1], f[i][j]);  
    }  
}  
// 合并答案  
for (int i = 1; i <= n; i++) {  
    for (int j = 0; j <= 9; j++) {  
        ans = min(ans, f[i][j] + g[i][j] - dis(a[i], j));  
    }  
}  
```  

---

## 个人心得摘录  
- **未来姚班zyl**：  
  > “前缀最小值优化是关键，避免暴力枚举 `k` 的冗余计算。”  
- **Link_Cut_Y**：  
  > “滚动数组节省空间，但需注意维护顺序。”  

---

## 推荐相似洛谷题目  
1. **P2894 环形数组调整**  
2. **P4597 单峰序列构造**  
3. **P3146 动态规划-双序列优化**

---
处理用时：78.85秒
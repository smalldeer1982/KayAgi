# 题目信息

# 「NnOI R1-T2」风屿

## 题目背景

「与风为名，屿之齐鸣。」——风屿

## 题目描述

风屿是一块 $ n $ 行，$ m $ 列的群岛，第 $ i $ 行第 $  j $ 列记为 $ (i,j) $。

风屿的重力系统很奇怪，$ (i,j) $ 的重力系数 $ g_{i,j}=a_i+b_j $。$ a,b $ 是两个已知的长度分别为 $ n,m $ 的数组。

我们定义岛 $ (x,y) $ 和 $ (z,w) $ **相邻**当且仅当 $ |x-z|+|y-w|=1 $，定义 $ (x,y) $ 和 $ (z,w) $ **连通**当且仅当两种情况至少有一种满足：

* $ (x,y),(z,w) $ 相邻，且 $ g_{x,y}=g_{z,w} $。

* 存在另一个岛 $ (u,v) $ 使得 $ (x,y) $ 和 $ (u,v) $ 连通且 $ (u,v) $ 和 $ (z,w) $ 连通，也就是说，连通关系**具有传递性**。

我们定义无序互异的岛集 $ \{(x_i,y_i)\} $ 为**同色连通块**，当且仅当岛集中任意两岛连通。

找到最大的同色连通块，并求出大小和这样的块的个数。

## 说明/提示

### 样例解释

对于样例 $ 1 $：

对于第 $ 1 $ 组测试数据，重力系数依次如下：

```
2 3 4 5
3 4 5 6
3 4 5 6
```

```
2 3 4 5
* # ? .
* # ? .
```

标记符号的为最大的同色连通块，大小为 $ 2 $，共 $ 4 $ 个。

### 数据范围

对于 $ 20\% $ 的数据，$ n,m \le 10^3 $。

对于另 $ 20\% $ 的数据，所有 $ b_i $ 相等。

对于另 $ 20\% $ 的数据，第二问答案一定为 $ 1 $。

对于另 $ 20\% $ 的数据，$ T=1 $，这四档部分分表示的测试点集合互不包含。

对于 $ 100\% $ 的数据，$ 1 \le T \le 5 $，$ 1 \le n,m \le 10^5 $，$ 1 \le a_i,b_i \le 10^9 $。

### 题目来源

| 项目 | 人员 |
|:-:|:-:|
| idea | Kevin0501 |
| std | Kevin0501
| data | EstasTonne |
| check | EstasTonne |
| solution | Kevin0501 |

## 样例 #1

### 输入

```
3
3 4
1 2 2
1 2 3 4
4 5
1 2 2 3
2 3 3 3 4
6 7
1 1 2 2 3 4
1 2 2 2 3 3 3```

### 输出

```
2 4
6 1
6 4```

# AI分析结果



1. **数学分类选择**  
   组合数学

---

### 题解思路、算法要点与解决难点

**核心思路**  
通过矩阵构造式 `g[i][j]=a[i]+b[j]` 发现同色连通块必为矩形。最大矩形的规模由两个独立条件决定：  
- a数组的最长连续相同元素段长度 l₁  
- b数组的最长连续相同元素段长度 l₂  

最终解为 `l₁×l₂`（块大小）和 `c₁×c₂`（块数量，其中 c₁/c₂ 为对应数组最长段出现次数）。

**数学推导**  
设 a 的连续相同段为区间 [x, x+l₁)，b 的为 [y, y+l₂)，则对应的矩形区域 `g[x..x+l₁-1][y..y+l₂-1]` 内所有元素值为定值 `a_x + b_y`。相邻元素间因行列连续性可保证连通性。

**解决难点**  
- 二维连通性转化为一维连续段乘积的思维跳跃  
- 传递性连通条件下矩形结构的严格证明（反证法验证缺角情况不成立）

**算法实现**  
线性扫描两个数组，动态维护：  
- 当前连续段长度 `cur_len`  
- 全局最大长度 `max_len`  
- 最大长度出现次数 `cnt`  

---

### 题解评分（≥4星）

1. **作者：___w**（⭐⭐⭐⭐⭐）  
   - 思路清晰，代码简洁  
   - 双指针法直接统计最长段  
   - 处理循环结束后的剩余段  

2. **作者：船酱魔王**（⭐⭐⭐⭐）  
   - 官方题解，逻辑严谨  
   - 独立函数封装统计逻辑  
   - 数组末尾补0优化边界处理  

3. **作者：wdgm4**（⭐⭐⭐⭐）  
   - 附带连通性数学证明  
   - 分步统计长度和次数  
   - 调试心得具有启发性  

---

### 最优思路/技巧提炼

**关键公式**  
```
最大块大小 = max_len_a × max_len_b  
块数量 = cnt_a × cnt_b  
```

**优化技巧**  
- **双指针单次扫描**：O(n) 时间统计最长连续段  
- **末尾哨兵处理**：在数组末尾添加一个不同元素，避免循环结束后单独处理剩余段  
- **动态更新次数**：当发现更长的段时重置计数器，相等时累加  

---

### 同类型题与算法套路

**通用套路**  
二维矩阵问题中，若元素值可分解为行列独立参数的函数（如 `f(i,j)=a[i]+b[j]`），则最大同色区域往往由行列最长连续段乘积决定。

**推荐题目**  
1. [P2331 最大子矩阵](https://www.luogu.com.cn/problem/P2331)  
2. [P3400 仓鼠窝](https://www.luogu.com.cn/problem/P3400)  
3. [P4147 玉蟾宫](https://www.luogu.com.cn/problem/P4147)  

---

### 可视化与算法演示

**动画设计**  
1. **像素矩阵构建**：用不同颜色表示 `a[i]` 和 `b[j]` 的值，动态绘制 `g[i][j]` 的生成过程。  
2. **最长段高亮**：  
   - 红色边框标记 a 数组的最长连续段  
   - 蓝色边框标记 b 数组的最长连续段  
   - 对应矩形区域用闪烁效果展示连通块  
3. **公式推导面板**：实时显示 `max_len_a` 和 `max_len_b` 的变化，乘积结果用大字幕弹出。

**复古风格实现**  
```javascript
// 伪代码示例：Canvas绘制最长连续段
const ctx = canvas.getContext('2d');
function drawSegment(arr, isA) {
  let curLen = 1, maxLen = 1, cnt = 0;
  for (let i = 1; i <= arr.length; i++) {
    // 计算最长段逻辑...
    ctx.fillStyle = (i % 2) ? '#FF5555' : '#55FF55'; // 8-bit颜色
    ctx.fillRect(x, y, 8, 8); // 像素块绘制
  }
  // 播放音效
  playSound('blip.wav');
}
```

**交互功能**  
- **步进控制**：按空格键逐步执行数组扫描  
- **自动演示**：AI模式模拟最优算法推导路径  
- **音效反馈**：每发现一个更长段时播放升级音效  

---

### 代码实现（核心逻辑）

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

signed main() {
    int T; cin >> T;
    while(T--) {
        int n, m;
        cin >> n >> m;
        
        // 处理a数组
        int max_a = 1, cnt_a = 1, cur_a = 1;
        vector<int> a(n);
        for(int i=0; i<n; i++) {
            cin >> a[i];
            if(i > 0 && a[i] == a[i-1]) {
                if(++cur_a > max_a) max_a = cur_a, cnt_a = 1;
                else if(cur_a == max_a) cnt_a++;
            } else cur_a = 1;
        }
        
        // 处理b数组（同上逻辑）
        // ...
        
        cout << max_a * max_b << ' ' << cnt_a * cnt_b << endl;
    }
    return 0;
}
```

---
处理用时：114.71秒
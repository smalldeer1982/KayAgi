# 题目信息

# 「QFOI R1」摸摸

## 题目描述

小 R 是一个可爱的女孩子，她喜欢被摸头。

但是摸头之前，必须答对她提出的一个问题。

她有一个长度为 $n$ 的数列 $a$，初始时所有元素均为 $0$。另有两个长度为 $n$ 的数列 $t,b$。

她可以进行两种操作：

1. 将 $t$ 与 $t$ 的倒序对应元素相加，得到新的 $t$。
    - 例如，$t=[1,4,2]$ 变为 $t'=[1+2,4+4,2+1]=[3,8,3]$。
2. 将 $a$ 与 $t$ 对应元素相加，得到新的 $a$。
    - 例如，$a=[1,2,3],t=[1,4,2]$ 变为 $a'=[1+1,2+4,3+2]=[2,6,5]$。

是否可能通过若干次以上操作将 $a$ 变为 $b$？

你希望摸她的头 $T$ 次，因此有 $T$ 组数据。

## 说明/提示

**样例解释**

对于第一组数据：

- 初始时：$a=[0,0,0]$，$t=[1,2,2]$，$b=[5,8,7]$。
- 执行操作二：$a=[1,2,2]$，$t=[1,2,2]$，$b=[5,8,7]$。
- 执行操作二：$a=[2,4,4]$，$t=[1,2,2]$，$b=[5,8,7]$。
- 执行操作一：$a=[2,4,4]$，$t=[3,4,3]$，$b=[5,8,7]$。
- 执行操作二：$a=[5,8,7]$，$t=[3,4,3]$，$b=[5,8,7]$。

此时 $a=b$，符合要求。

对于第二组数据，可以证明不存在合法方案。

---

**数据范围**

本题共 $20$ 个测试点，每个测试点 $5$ 分。

记 $\sum n$ 表示每组数据的 $n$ 之和。

对于全部数据，保证 $1\le\sum n\le 2\times 10^3$，$n\ge 1$，$1\le t_i,b_i\le 2\times 10^3$。

- 对于测试点 $1\sim 4$：保证 $n\le 2$。
- 对于测试点 $5\sim 8$：保证所有 $t_i$ 都相等。
- 对于测试点 $9\sim 12$：保证 $b_i=b_{n-i+1}$。
- 对于测试点 $13\sim 16$：保证 $\sum n,t_i,b_i\le 200$。
- 对于测试点 $17\sim 20$：无特殊限制。

---

**Hack 数据**

本题在赛后添加了 Hack 数据，从 $21$ 开始编号。

原有测试点依然计 $5$ 分，Hack 数据计 $0$ 分，但只有通过所有数据才会被判为 Accepted。

为区分原有测试点和 Hack 数据，本题添加了子任务，但子任务的计分方式为“加和”，不会影响正常评测。

## 样例 #1

### 输入

```
2
3
1 2 2
5 8 7
3
1 2 2
2 4 3```

### 输出

```
Yes
No```

# AI分析结果



**唯一算法分类**：数论

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   关键结论：**操作一最多执行一次**。执行一次后，`t` 变为回文序列，后续操作一可转化为多次操作二（等效于倍数叠加）。因此，最终 `a` 可表示为初始 `t` 的线性组合（操作二次数 `x`）与回文 `t'` 的线性组合（操作二次数 `y`）。

2. **数学推导**  
   - 设执行操作一前进行了 `x` 次操作二，之后进行了 `y` 次操作二，则：  
     \[
     b_i = x \cdot t_i + y \cdot (t_i + t_{n-i+1})
     \]
   - 需验证是否存在非负整数 `x, y` 对所有 `i` 成立。

3. **解决难点**  
   - **枚举优化**：直接枚举 `x` 或 `y` 可能导致超时。观察到 `x` 的上界为 `b_i / t_i`，可高效剪枝。  
   - **回文对称性**：操作一后的 `t` 是回文，验证 `y` 的全局一致性是关键。

---

### **最优思路或技巧提炼**

1. **线性组合系数法**  
   将问题转化为求解 `b_i = x*t_i + y*(t_i + t_{n-i+1})` 的整数解。通过枚举 `x` 或 `y` 并验证全局一致性，避免暴力双重循环。

2. **回文对称性剪枝**  
   若 `t` 已为回文，则只需验证 `b_i` 是否均为 `k*t_i`；否则需先处理非对称部分。

3. **逆向减法优化**  
   不断从 `b` 中减去初始 `t` 直到 `b` 成为回文，再验证剩余部分是否满足回文 `t'` 的线性组合。

---

### **题解评分 (≥4星)**

1. **官方题解（rui_er）**  
   - **评分**：★★★★★  
   - **亮点**：清晰枚举操作一前的操作次数，逐层验证剩余部分，时间复杂度 `O(nw)`，代码简洁高效。

2. **MoonCake2011 题解**  
   - **评分**：★★★★☆  
   - **亮点**：通过枚举 `y` 并解方程求 `x`，利用对称性快速验证，逻辑直观。

3. **LCat90 题解**  
   - **评分**：★★★★☆  
   - **亮点**：直接枚举 `x` 并计算 `y`，代码结构清晰，适合快速实现。

---

### **同类型题与算法套路**

1. **常见数论问题**  
   - 线性组合存在性（裴蜀定理扩展）。  
   - 非负整数解的枚举与验证。

2. **类似题目**  
   - **洛谷 P5656**：二元一次方程的非负整数解。  
   - **洛谷 P2118**：比例简化中的线性组合。  
   - **洛谷 P1082**：同余方程求解。

---

### **可视化与算法演示**

**动画设计**：
1. **初始化**：展示初始全零的 `a` 和给定 `t`。  
2. **操作模拟**：  
   - **操作二**：逐步叠加 `t` 到 `a`，高亮对应位置。  
   - **操作一**：用箭头表示 `t` 与其倒序相加，生成回文 `t'`。  
3. **验证过程**：动态显示 `x` 和 `y` 的枚举，用颜色区分合法/非法解。  
4. **结果反馈**：成功时播放上升音效，失败时短促提示。

**复古像素风格**：
- **颜色方案**：8-bit 色调（青、紫、橙）标记 `t`、`a`、`b`。  
- **音效**：叠加操作时播放“哔”声，成功时 8-bit 胜利旋律。

---

### **代码片段（官方题解核心逻辑）**

```cpp
bool ans = false;
while(true) {
    // 检查当前a是否超过b
    bool valid = true;
    rep(i, 1, n) if(a[i] > b[i]) valid = false;
    if(!valid) break;

    // 计算y的可能值并验证
    if((b[1] - a[1]) % s[1] == 0) {
        int steps = (b[1] - a[1]) / s[1];
        bool ok = true;
        rep(i, 1, n) if(b[i] != a[i] + steps * s[i]) ok = false;
        if(ok) { ans = true; break; }
    }

    // 执行一次操作二（叠加t到a）
    rep(i, 1, n) a[i] += t[i];
}
puts(ans ? "Yes" : "No");
```

**核心思想**：通过逐步叠加初始 `t` 到 `a`，并在每一步尝试用回文 `t'` 的线性组合填补剩余差值。

---

### **个人心得摘录**

- **MoonCake2011**：强调对称性验证的重要性，避免冗余计算。  
- **ICU152_lowa**：逆向减法优化，通过回文特性简化问题，但需注意边界条件。  

---

**推荐题目**：  
1. [P5656 二元一次方程的非负解](https://www.luogu.com.cn/problem/P5656)  
2. [P2118 比例简化](https://www.luogu.com.cn/problem/P2118)  
3. [P1082 同余方程](https://www.luogu.com.cn/problem/P1082)

---
处理用时：92.49秒
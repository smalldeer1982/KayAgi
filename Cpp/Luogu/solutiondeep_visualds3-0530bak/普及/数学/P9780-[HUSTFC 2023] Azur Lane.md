# 题目信息

# [HUSTFC 2023] Azur Lane

## 题目描述

你是港区的一位指挥官，你可以通过培养指挥喵来增强舰队的实力，指挥喵由对应的喵箱培育。喵箱有 $k$ 个等级，等级越高稀有度越高。你每天会获得若干个喵箱（至少一个），然后再使用 ''一键放入'' 将这些喵箱放到喵窝里进行培育。''一键放入'' 会优先放入稀有度更高的喵箱（即按照稀有度从高到低排序后依次放入），放入的喵箱会排在已放入喵箱的后面，在**每天结束时**系统会自动扣除与喵窝中喵箱数量相等的钱。最开始时你的喵窝里没有喵箱。

因为你非常懒，所以你会等 $n$ 天后才把喵箱一起打开。在你 $n$ 天后进入喵窝时，你看到了 $m$ 个喵箱，用一个长度为 $m$ 的序列 $a$ 表示喵窝里按放入先后顺序排列的喵箱的等级。但是你已经忘了这 $n$ 天里你每天获得了多少喵箱了，你甚至忘了 $n$ 的值是多少，显然这有许多情况。你想知道，对于满足 $1 \leq n \leq m$ 的所有整数 $n$，在所有情况中，这 $n$ 天总共扣除的钱数至少为多少？

## 说明/提示

样例一解释：

当 $n=1$ 时，无法在一天内获得这 $3$ 个喵箱（第二个喵箱的等级大于第一个喵箱的等级，不符合 ``一键放入'' 从高到低放入的原则），因此输出 $-1$。

当 $n=2$ 时，第一天获得第一个喵箱，此时喵窝内有 $1$ 个喵箱，当天花费为 $1$；第二天获得后两个喵箱，此时喵窝内有 $3$ 个喵箱，当天花费为 $3$。因此总钱数为 $4$。

当 $n=3$ 时，每天依次获得一个喵箱，总钱数为 $1+2+3=6$。

## 样例 #1

### 输入

```
3 3
2 3 1
```

### 输出

```
-1 4 6 ```

## 样例 #2

### 输入

```
8 4
3 2 4 2 1 2 3 2
```

### 输出

```
-1 -1 -1 21 22 25 29 36 ```

# AI分析结果



---

**算法分类**  
贪心

---

**综合分析与结论**  
题目要求将序列分割为若干非递增段，使得每天放入的喵箱数总和的费用最小。各题解的核心思路是：  
1. **倒序合并段**：从后向前遍历，若当前元素不小于后一个元素，则合并到同一段，减少总天数。  
2. **费用计算**：初始费用为等差数列和，每次合并减少当前索引值的贡献。  
3. **贪心证明**：越晚合并的段费用贡献越小，倒序合并确保每次操作最优。  

**可视化设计**：  
- **动画流程**：用像素风格展示数组元素，高亮当前比较的相邻元素。若满足合并条件（a[i]≥a[i+1]），则触发合并动画，显示费用减少值。  
- **音效与UI**：合并时播放清脆音效，背景音乐为8-bit风格，费用数值以像素字体动态更新。  
- **步进控制**：允许单步执行观察合并过程，或自动播放展示算法流程。

---

**题解清单（≥4星）**  
1. **uncle_steve（5星）**  
   - **亮点**：代码简洁，注释明确，直接倒序合并，逻辑清晰。  
   - **核心代码**：  
     ```cpp
     for(int i=m-1;i>=1;i--){ 
         if(s[i]>=s[i+1]){ 
             ans[sum] = ans[sum+1] - i; 
             sum--; 
         } 
     } 
     ```  
2. **Anins（5星）**  
   - **亮点**：变量命名规范，注释详细，适合快速理解贪心策略。  
3. **S_Kuroko（4星）**  
   - **亮点**：代码简洁，变量名清晰，关键步骤直接对应问题描述。

---

**最优思路提炼**  
**关键点**：  
1. **倒序合并**：从后向前遍历数组，合并非递增段，确保较长的段贡献更少费用。  
2. **费用更新公式**：每次合并后，费用减少当前索引值（`f[k] = f[k+1] - i`）。  
3. **边界处理**：初始费用为等差数列和，不可分割的段直接输出-1。

---

**类似算法题**  
1. **LeetCode 1578. Minimum Time to Make Rope Colorful**  
   （贪心处理相邻元素使序列合法）  
2. **洛谷 P1090 [NOIP2004 提高组] 合并果子**  
   （贪心合并策略最小化总代价）  
3. **Codeforces 1176E. Cover it!**  
   （区间分割与贪心选择）

---

**代码实现（核心逻辑）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
long long m, k, a[N], f[N];
int main() {
    cin >> m >> k;
    for (int i = 1; i <= m; i++) cin >> a[i];
    f[m] = (1LL + m) * m / 2; // 初始化n=m的答案
    int cnt = m;
    for (int i = m - 1; i >= 1; i--) {
        if (a[i] >= a[i + 1]) { // 可合并到后一段
            cnt--;
            f[cnt] = f[cnt + 1] - i;
        }
    }
    for (int i = 1; i <= m; i++) 
        cout << (f[i] ? f[i] : -1) << " ";
}
```

---

**可视化与复古游戏设计**  
- **动画元素**：  
  - 数组以像素块形式排列，当前比较的块高亮为黄色。  
  - 合并时触发绿色闪光，费用数值以红色更新。  
- **音效设计**：  
  - 合并成功：短促“叮”声（8-bit音效）。  
  - 费用更新：低音鼓点。  
- **自动模式**：算法自动运行，用户可调节速度或手动单步。

---
处理用时：251.68秒
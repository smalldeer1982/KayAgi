# 题目信息

# “非常男女”计划

## 题目描述

近来，初一年的 `XXX` 小朋友致力于研究班上同学的配对问题（别想太多，仅是舞伴），通过各种推理和实验，他掌握了大量的实战经验。例如，据他观察，身高相近的人似乎比较合得来。

万圣节来临之际，`XXX` 准备在学校策划一次大型的 “非常男女” 配对活动。对于这次活动的参与者，`XXX` 有自己独特的选择方式。他希望能选择男女人数相等且身高都很接近的一些人。这种选择方式实现起来很简单。他让学校的所有人按照身高排成一排，然后从中选出连续的若干个人，使得这些人中男女人数相等。为了使活动更热闹，`XXX` 当然希望他能选出的人越多越好。请编写程序告诉他，他最多可以选出多少人来。


## 样例 #1

### 输入

```
9
0 1 0 0 0 1 1 0 0
```

### 输出

```
6```

# AI分析结果



## 唯一算法分类
前缀和与哈希表优化

---

## 综合分析与结论

### 核心思路
**核心算法**：将男生视为+1，女生视为-1，构建前缀和数组。当两个位置的前缀和相等时，中间区间的男女数量必定相等。通过记录每个差值首次和最后一次出现的位置，计算最大区间长度。

**关键实现**：
1. 构建差分数组 `sum[i] = sum[i-1] + (当前性别值)`
2. 使用偏移量处理负数下标（如+100000）
3. 维护哈希表/数组 `l[]` 和 `r[]` 记录每个差值的最早和最晚位置
4. 遍历所有可能的差值，计算最大区间长度 `r[i]-l[i]`

### 难点对比
| 题解方案           | 解决负下标方式      | 数据结构       | 时间复杂度 | 空间复杂度 |
|--------------------|--------------------|---------------|----------|-----------|
| 桶数组+偏移量      | 加固定偏移量n       | 静态数组       | O(n)     | O(2n)     |
| STL map            | 直接存储原始差值     | 红黑树         | O(nlogn) | O(n)      |
| 暴力枚举区间       | 无                 | 无            | O(n²)    | O(1)      |

### 可视化设计
**动画方案**：
1. 像素网格展示输入序列（蓝色块=男生，粉色块=女生）
2. 动态绘制前缀和曲线在画布上方
3. 用连线标记相同差值的首尾位置（黄色连线）
4. 发现更大区间时高亮该区域（红色边框），播放"升级"音效
5. 右侧面板实时显示当前最大长度

**复古特效**：
- 8位风格控制面板：含「单步执行」「自动播放」像素按钮
- 音效设计：差值匹配时播放FC游戏金币音效，刷新记录时播放马里奥吃蘑菇音效
- Canvas绘制采用16色调色板，网格单元为16x16像素

---

## 题解清单 (≥4星)

1. **AKB48（5星）**
   - 关键亮点：首创差值桶记录法，代码简洁高效
   - 核心代码：
     ```cpp
     int t = sum0 - sum1 + n; // 偏移量处理
     if (!l[t] && t != n) l[t] = i; else r[t] = i;
     ```

2. **小小二逼兽（5星）**
   - 关键亮点：极致空间优化，sum0/sum1实时计算
   - 代码优势：无需构建完整前缀和数组，节省内存

3. **Randyhoads（4星）**
   - 关键亮点：完整注释说明，包含边界处理
   - 调试技巧：初始化 `ton[n][0]=0` 处理初始状态

---

## 核心代码实现

**桶数组法（最优解）**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5+10;
int l[N], r[N], n;

int main() {
    cin >> n;
    int sum = 0, ans = 0;
    memset(l, -1, sizeof l);
    l[n] = 0; // 初始状态偏移量为n
    
    for(int i=1; i<=n; i++){
        int x; cin >> x;
        sum += (x ? 1 : -1);
        int t = sum + n; // 防负数偏移
        
        if(l[t] == -1) l[t] = i;
        else ans = max(ans, i - l[t]);
    }
    cout << ans;
}
```

---

## 同类型题目推荐

1. **P8627 最大子序和**（一维前缀和极值）
2. **P3131 子数组异或和**（前缀异或性质）
3. **P1351 联合权值**（滑动窗口与哈希结合）

---

## 可视化代码片段

```javascript
// Canvas绘制核心逻辑（伪代码）
function drawStep(step) {
  ctx.clearRect(0, 0, W, H);
  
  // 绘制原始序列
  for(let i=0; i<n; i++) {
    ctx.fillStyle = data[i] ? "#3498db" : "#e74c3c";
    fillRect(20+i*16, 100, 14, 14);
  }

  // 绘制前缀和连线
  if(hash[sum]) {
    ctx.beginPath();
    ctx.moveTo(hash[sum]*16+20, 50);
    ctx.lineTo(i*16+20, 50);
    ctx.strokeStyle = "#f1c40f";
    ctx.stroke();
  }

  // 播放音效
  if(newRecord) {
    playSound('powerup');
    newRecord = false;
  }
}
```

---

## 个人心得摘录

> "调试40分钟的教训：前缀和数组必须从0开始初始化，且偏移量要足够大避免越界" —— KellyFrog  
> "逆向枚举长度时，发现答案可能不在中间而在两端" —— Rachel_in  
> "用sum0-sum1代替传统前缀和，节省了一个数组的空间" —— 小小二逼兽

---

## 算法演示地址
（此处可插入基于上述思路实现的在线演示链接，需实际部署后补充）

---
处理用时：65.37秒
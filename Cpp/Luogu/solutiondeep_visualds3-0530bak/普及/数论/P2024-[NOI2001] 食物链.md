# 题目信息

# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# AI分析结果



# 【NOI2001】食物链 题解分析

## 算法分类
**种类并查集**与**带权并查集**

---

## 核心思路与难点对比

### 1. 种类并查集（三倍空间法）
**核心思想**：
- 将每个动物拆分为三个维度：同类（A）、猎物（B）、天敌（C）
- 通过合并三个维度的集合维护环形食物链关系

**关键操作**：
```cpp
// 同类合并逻辑（1 X Y）
fa[find(x)] = find(y);           // A群合并
fa[find(x+n)] = find(y+n);       // B群合并
fa[find(x+2n)] = find(y+2n);     // C群合并

// 捕食合并逻辑（2 X Y）
fa[find(x+n)] = find(y);         // X的猎物是Y的同类
fa[find(y+2n)] = find(x);        // Y的天敌是X的同类
fa[find(x+2n)] = find(y+n);      // X的天敌是Y的猎物
```

**难点**：
- 需确保三种关系同步维护
- 判断逻辑需同时检查三个维度（如判断同类时需排除猎物/天敌关系）

---

### 2. 带权并查集（模3权值法）
**核心思想**：
- 用权值 `d[x]` 表示节点与父节点的关系：  
  `0=同类` | `1=被父吃` | `2=吃父`
- 路径压缩时动态更新权值关系

**关键公式**：
```cpp
// 路径压缩权值更新
d[x] = (d[x] + d[father]) % 3;

// 合并时权值推导（X吃Y）
d[fx] = (d[y] - d[x] + 4) % 3; // 4=1（捕食）+3（防负数）
```

**难点**：
- 权值计算的数学推导需严格符合环形关系
- 合并时需处理不同根节点的相对关系

---

## 题解评分（≥4星）

| 题解作者       | 评分 | 亮点                                                                 |
|----------------|------|----------------------------------------------------------------------|
| Sooke          | ⭐⭐⭐⭐ | 三倍空间法逻辑直观，图解丰富，适合并查集初学者理解                     |
| 天泽龟         | ⭐⭐⭐⭐ | 带权并查集详解数学推导，深入解释权值意义，适合进阶学习                   |
| 檀黎斗·神      | ⭐⭐⭐⭐ | 代码简洁高效，三域合并逻辑清晰，适合快速实现与竞赛场景                   |

---

## 最优技巧提炼

1. **三域合并法**  
   通过三个独立集合维护环形关系，合并时同步处理同类、猎物、天敌三个维度，逻辑直观但需注意空间开销。

2. **模3权值体系**  
   用 `0/1/2` 表示关系，路径压缩时动态更新权值链，空间高效但需严谨的数学推导。

3. **关系传递公式**  
   带权并查集的合并公式 `d[fx] = (d[y] - d[x] + 4) % 3` 实现了环形关系的精确维护。

---

## 同类题目推荐

1. **P1525 关押罪犯**  
   使用种类并查集划分敌对关系，类似三域思想。

2. **P1196 银河英雄传说**  
   带权并查集维护距离，路径压缩时更新距离值。

3. **P1955 程序自动分析**  
   并查集处理等价关系与约束条件，适合练习关系维护。

---

## 可视化设计

### 动画方案（带权并查集演示）
1. **数据结构展示**  
   - 节点以树结构排列，颜色区分权值（绿=0，红=1，蓝=2）
   - 当前操作节点高亮闪烁

2. **关键步骤演示**  
   ```javascript
   // 路径压缩动画
   function animatePathCompression(node) {
     highlight(node);
     while (node.parent != node) {
       showArrow(node, node.parent); // 显示权值传递
       updateWeight(node, (node.d + parent.d) % 3);
       node = parent;
     }
   }

   // 合并动画
   function animateUnion(x, y) {
     let rootX = find(x), rootY = find(y);
     rotateTree(rootY, angleToX); // 旋转子树对齐
     drawWeightLine(rootX, rootY, calculatedWeight); // 显示新权值边
   }
   ```

3. **复古像素风格**  
   - 8-bit 音效：合并时播放 "beep"，路径压缩时连续 "blip"
   - Canvas 绘制树结构，节点用 16x16 像素方块表示

---

## 核心代码片段

### 带权并查集实现
```cpp
int find(int x) {
    if (fa[x] != x) {
        int root = find(fa[x]);
        d[x] = (d[x] + d[fa[x]]) % 3;
        fa[x] = root;
    }
    return fa[x];
}

void unionSet(int x, int y, int relation) {
    int fx = find(x), fy = find(y);
    if (fx == fy) {
        if ((d[x] - d[y] + 3) % 3 != relation) ans++;
        return;
    }
    fa[fx] = fy;
    d[fx] = (d[y] - d[x] + relation + 3) % 3;
}
```

---

## 总结
两种方法各有优劣：**三倍空间法**直观易实现，适合快速解题；**带权并查集**空间高效但需要深入理解权值推导。实际应用中可根据问题规模与实现复杂度灵活选择。

---
处理用时：79.60秒
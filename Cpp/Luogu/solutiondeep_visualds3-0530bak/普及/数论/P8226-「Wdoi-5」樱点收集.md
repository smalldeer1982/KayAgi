# 题目信息

# 「Wdoi-5」樱点收集

## 题目背景

119 季 5 月，明明本应是樱花盛开的春天，幻想乡却依然下着大雪。异变的主谋**西行寺幽幽子**在古书上看到，只要使妖樱西行妖满开便会有什么人复活，便出于兴趣命令妖梦收集幻想乡中的春度，一手策划成了这场异变。在收集春度的过程中散落的能量在西行妖的影响下化为**樱点**，散落在幻想乡各处。

出发解决**春雪异变**的灵梦将前往冥界旅途划分为了若干段，每一段都可以收集到一定的樱点。收集齐一定程度的樱点，就会立即开出樱之结界。开出樱之结界后可以短暂地屏蔽一切攻击，并且获得相应的增益。

但是樱之结界何时开放仅由樱点的收集情况所决定，她不得不对樱点进行「规划」。通过某些途径规避某一段路上樱点的收集，借此使得在将来的某几段路程里，灵梦得以恰好在该段的末尾开放樱之结界。  

但是现实往往不尽人意。也就是说，可能有某些要求无法达成。灵梦希望找出一个方案，使得她可以达成的要求最多。灵梦委托八云紫帮忙决策，于是这个重任就被一条懒紫交给了式神八云蓝。尽管八云蓝擅长计算，但是八云紫睡觉去了没有给她编程，因而现在这个任务就落到了你的手上。

## 题目描述

灵梦当前拥有的樱点可以使用一个**变量** $c$ 存储，初始时为 $0$。当樱点在某个瞬间**恰好**变为了 $k$，灵梦就会展开樱之结界，同时 $c$ 变为 $0$。

现在她把路程**依次**划分为了 $n$ 个关卡，其中第 $i$ 关上，灵梦一共可以获得 $a_i$ 点樱点。这些樱点是均匀分布在这关的路程上的。也就是说，随着这段路程的进行，灵梦的樱点个数会依次增加，每次增加 $1$ 个单位（$c\gets c+1$），恰好在这段路程结束的瞬间会收集到这关中第 $a_i$ 点樱点。

![](https://cdn.luogu.com.cn/upload/image_hosting/3yuiywt0.png)

**【需要注意的是，这只是图示参考，不满足实际的数据限制。】**

在这个例子里，灵梦将路径划分为了四个关卡。这四个关卡的樱点个数分别为 $2,0,3,1$。

灵梦提出了 $m$ 个要求。第 $i$ 个要求 $b_i$ 表示灵梦希望在第 $b_i$ 段路程结束的瞬间，**恰好**展开樱之结界（如果在这段路程的中途展开但是结束的瞬间没有展开，那就不算达成了要求）。

灵梦可以选择在某个关卡开头放 bomb，**跳过**整个关卡的樱点收集。这样的机会**有且仅有**一次（当然，灵梦可以选择不使用 bomb）。

现在需要求出，在最优的选择下，灵梦**最多**可以达成多少个要求。

## 说明/提示

样例 $2$ 见下发的附件 $\textbf{\textit{sukura2.in/sakura2.ans}}$。该样例约束与测试点 $1\sim 8$ 一致。  
样例 $3$ 见下发的附件 $\textbf{\textit{sukura3.in/sakura3.ans}}$。该样例约束与测试点 $9\sim 14$ 一致。  
样例 $4$ 见下发的附件 $\textbf{\textit{sukura4.in/sakura4.ans}}$。该样例约束与测试点 $15\sim 20$ 一致。

#### 样例 1 解释

- 在不使用 bomb 时，灵梦会在第 $2$、$3$ 关开出樱之结界，其中第 $3$ 关在统计序列中，满足要求数为 $1$。
- 在第 $1$ 关使用 bomb，灵梦会在第 $4$ 关开出樱之结界，且第 $4$ 关在统计序列中，满足要求数为 $1$。
- 在第 $2$ 关使用 bomb，灵梦会在第 $4$ 关开出樱之结界，且第 $4$ 关在统计序列中，满足要求数为 $1$。
- 在第 $3$ 关使用 bomb，灵梦会在第 $2$ 关开出樱之结界，且第 $2$ 关不在统计序列中，满足要求数为 $0$。
- 在第 $4$ 关使用 bomb，灵梦会在第 $2$、$3$ 关开出樱之结界，其中第 $3$ 关在序列中，满足要求数为 $1$。

#### 数据范围及约定

本题共有 $20$ 个测试点，每个测试点 $5$ 分。最终分数为所有测试点分数之和。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Task} & \bm{n\le } & \bm{k\le} \cr\hline
1\sim 8 & 200 & 10^3 \cr\hline
9\sim 14 & 2\times 10^3 & 10^5 \cr\hline
15\sim 20 & 3\times 10^5 & 10^6 \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，保证 $1\le m\le n\le 3\times 10^5$，$1\le k\le 10^6$，$1\le a_i\le 10^9$，$1 \le b_i \le n$，$b$ 序列递增。

## 样例 #1

### 输入

```
4 3 2
1 3 4
1 1 2 1```

### 输出

```
1```

# AI分析结果



# 算法分类：前缀和与哈希表（桶）

---

## 题解思路与核心难点

### **核心思路**
1. **前缀和模运算**：计算樱点前缀和并对 `k` 取模，判断是否触发结界。
2. **动态桶统计**：维护两个桶数组，分别记录跳过某关卡前后满足条件的余数出现次数。
3. **枚举跳过位置**：遍历每个关卡作为可能的跳过点，计算前后贡献的最大值。

### **解决难点**
- **跳过后的影响**：跳过第 `i` 关时，后续所有前缀和相当于减少 `a_i`，因此需统计余数等于 `a_i % k` 的位置数。
- **高效维护桶数组**：通过从后往前遍历，动态更新桶数组，避免重复计算。

### **关键变量与数据结构**
- `sum[i]`：前 `i` 关樱点的前缀和模 `k`。
- `left_bucket[i]`：跳过某关卡前，前缀和模 `k` 等于 `i` 的触发次数。
- `right_bucket[i]`：跳过关卡后，前缀和模 `k` 等于 `i` 的触发次数。

---

## 题解评分 (≥4星)

### **WardLee (5星)**
- **亮点**：代码清晰，利用 `nl` 和 `nr` 数组动态维护桶，时间复杂度 `O(n)`。
- **代码片段**：
  ```cpp
  for (int i = n; i >= 1; i--) {
      if (a[i] && st[i]) nl[s[i] % K]--;
      res = max(res, nl[0] + nr[a[i] % K]);
      if (a[i] && st[i]) nr[s[i] % K]++;
  }
  ```

### **minstdfx (5星)**
- **亮点**：反向遍历维护桶，逻辑简洁。
- **代码片段**：
  ```cpp
  for (int i = n; i >= 1; i--) {
      if (p[i]) tmp[sum[i]]++;
      ans = max(ans, c[i-1] + tmp[a[i]]);
  }
  ```

### **lyhqwq (4星)**
- **亮点**：变量命名简明，但缺少动态桶维护的直观性。
- **代码片段**：
  ```cpp
  for (int i = 1; i <= n + 1; i++) {
      if (b[i]) t[sum[i]]--;
      ans = max(ans, tmp + t[a[i] % k]);
      if (sum[i] == 0 && b[i]) tmp++;
  }
  ```

---

## 最优思路提炼

### **核心步骤**
1. **预处理前缀和**：计算每个关卡的樱点前缀和 `sum[i]` 并取模。
2. **初始化桶数组**：记录所有触发位置对应的模值。
3. **反向遍历更新桶**：从后往前枚举跳过关卡，动态更新桶中的余数统计。
4. **计算最大贡献**：对于每个关卡，跳过后的贡献为 `前面的0余数次数 + 后面的a_i余数次数`。

### **优化技巧**
- **反向维护桶**：跳过某关卡后，只需更新当前关卡的贡献，无需重新计算全局。
- **空间压缩**：仅用两个一维数组维护前后桶，空间复杂度 `O(k)`。

---

## 类似题目与推荐
1. **洛谷 P6568**：前缀和与模运算结合的最优子数组问题。
2. **LeetCode 523**：连续子数组和为 `k` 的倍数。
3. **洛谷 P3406**：利用前缀和统计区间贡献。

---

## 可视化算法演示

### **动画设计**
1. **像素风格界面**：每个关卡显示为方块，颜色表示是否触发结界。
2. **桶数组动态显示**：右侧面板展示 `left_bucket` 和 `right_bucket` 的实时变化。
3. **关键操作高亮**：
   - **当前跳过关卡**：红色边框闪烁。
   - **触发位置**：绿色高亮，播放音效提示。

### **交互功能**
- **步进控制**：允许单步执行观察桶更新过程。
- **音效反馈**：触发结界时播放8-bit音效，错误操作时短促提示。

---

## 核心代码实现

```cpp
#include <iostream>
using namespace std;

const int MAXN = 3e5 + 10, MAXK = 1e6 + 10;
int n, m, k, ans, a[MAXN], sum[MAXN], bucket[MAXK];
bool trigger[MAXN];

int main() {
    cin >> n >> m >> k;
    for (int i = 1; i <= m; i++) {
        int x; cin >> x;
        trigger[x] = true;
    }
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        sum[i] = (sum[i - 1] + a[i]) % k;
        if (trigger[i]) bucket[sum[i]]++;
    }
    ans = bucket[0];
    int prefix = 0;
    for (int i = n; i >= 1; i--) {
        if (trigger[i]) bucket[sum[i]]--;
        ans = max(ans, prefix + bucket[a[i] % k]);
        if (trigger[i] && sum[i] == 0) prefix++;
    }
    cout << ans << endl;
    return 0;
}
```

---

**关键逻辑说明**：
- **预处理桶数组**：统计初始触发位置的模值。
- **反向遍历更新**：动态减少当前关卡的贡献，并计算跳过后的最大值。
- **前缀计数**：维护跳过前的合法触发次数。

---
处理用时：75.58秒
# 题目信息

# [蓝桥杯 2017 省 AB] 包子凑数

## 题目描述

小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有 $N$ 种蒸笼，其中第 $i$ 种蒸笼恰好能放 $A_i$ 个包子。每种蒸笼都有非常多笼，可以认为是无限笼。

每当有顾客想买 $X$ 个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有 $X$ 个包子。比如一共有 $3$ 种蒸笼，分别能放 $3$ 、 $4$ 和 $5$ 个包子。当顾客想买 $11$ 个包子时，大叔就会选 $2$ 笼 $3$ 个的再加 $1$ 笼 $5$ 个的（也可能选出 $1$ 笼 $3$ 个的再加 $2$ 笼 $4$ 个的）。

当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有 $3$ 种蒸笼，分别能放 $4$ 、 $5$ 和 $6$ 个包子。而顾客想买 $7$ 个包子时，大叔就凑不出来了。

小明想知道一共有多少种数目是包子大叔凑不出来的。

## 说明/提示

对于样例 $1$，凑不出的数目包括：$1,2,3,6,7,11$。

对于样例 $2$，所有奇数都凑不出来，所以有无限多个。

蓝桥杯 2017 省赛 A 组 H 题。

## 样例 #1

### 输入

```
2  
4  
5  ```

### 输出

```
6```

## 样例 #2

### 输入

```
2  
4  
6   ```

### 输出

```
INF```

# AI分析结果



---

## 算法分类  
**数论 + 动态规划（完全背包）**

---

## 题解思路与解决难点  

### 核心思路  
1. **数论判定**：利用裴蜀定理判断所有数的最大公约数。若 `gcd > 1`，所有非倍数均无法凑出，输出 `INF`；否则进入动态规划阶段。  
2. **动态规划**：采用完全背包思想，标记所有可凑出的数。最终统计未被标记的数的个数。

### 解决难点  
1. **无限解判定**：裴蜀定理的逆向应用，若 `gcd ≠ 1` 则存在无限不可凑数。  
2. **动态规划上界**：合理选择 `MAX_DP` 范围（如 `1e5`），确保覆盖所有可能的不可凑数。  
3. **状态转移优化**：通过逐次扩展标记，避免重复计算（如使用 `|=` 或 `max` 操作）。

### 可视化设计  
- **动态规划标记过程**：用网格表示 `dp` 数组，高亮当前处理的 `a[i]` 及其影响的区间，标记新可凑数。  
- **像素动画**：以 8-bit 风格显示数值被逐步覆盖的过程，每次扩展时播放短促音效。  
- **交互控制**：允许调整动态规划速度，单步观察每个蒸笼对标记的影响。

---

## 题解评分（≥4星）  

### 题解 1：0x282e202e2029（5星）  
- **亮点**：  
  - 详细证明裴蜀定理的应用，逻辑严谨。  
  - 代码简洁，`max` 操作确保状态正确性。  
  - 预处理 `gcd` 提高效率。  
- **代码片段**：  
  ```cpp
  for (int i = 0; i < n; i++) {
      for (int j = a[i]; j < MAX_DP; j++) {
          dp[j] = max(dp[j], dp[j - a[i]]);
      }
  }
  ```

### 题解 4：5k_sync_closer（4星）  
- **亮点**：  
  - 同余最短路思路独特，减少状态数量。  
  - 数学推导清晰，最小数计算巧妙。  
- **难点**：需理解模运算与最短路的关系。  

### 题解 8：AK_heaven（4星）  
- **亮点**：  
  - 使用 `bitset` 优化空间，适合大数据范围。  
  - 预处理 `gcd` 和动态规划结合紧密。  
- **代码片段**：  
  ```cpp
  bitset<maxn+1> S;
  for (int i = 1; i <= n; i++) {
      for (int j = x[i]; j <= 1000; j++) {
          S |= S << x[i];
      }
  }
  ```

---

## 最优思路提炼  
1. **数论先行**：优先用裴蜀定理判断无限解，避免无效计算。  
2. **完全背包标记法**：  
   - 初始化 `dp[0] = 1`，表示 0 个包子可凑。  
   - 对每个蒸笼容量 `a[i]`，更新 `dp[j]` 为可凑或不可凑。  
3. **上界选择**：`MAX_DP` 设为 `1e5` 或 `a_max^2`，确保覆盖所有可能解。  

---

## 类似题目与算法  
- **同余最短路**：P2371 [国家集训队] 墨墨的等式  
- **完全背包**：P1616 疯狂的采药  
- **裴蜀定理**：P4549 【模板】裴蜀定理  

---

## 可视化与复古动画  
1. **动态规划过程**：  
   - **Canvas 网格**：每个格子代表一个数，绿色表示可凑，红色不可凑。  
   - **高亮更新**：处理 `a[i]` 时，黄色标记当前扩展的区间。  
2. **音效设计**：  
   - **标记成功**：8-bit 短音（频率 500Hz）。  
   - **完成扩展**：下滑音效（频率 200Hz→100Hz）。  
3. **交互控制**：  
   - 滑动条调节速度，按钮暂停/继续。  
   - 显示当前处理的 `a[i]` 和已标记数量。  

---

## 核心代码实现  
```cpp
// 动态规划核心代码（题解1）
void solve() {
    int g = a[0];
    for (int i = 1; i < n; i++) 
        g = gcd(g, a[i]);
    if (g != 1) { cout << "INF"; return; }

    dp[0] = 1;
    for (int i = 0; i < n; i++) 
        for (int j = a[i]; j < MAX_DP; j++) 
            dp[j] |= dp[j - a[i]];

    int ans = 0;
    for (int j = 1; j < MAX_DP; j++) 
        ans += !dp[j];
    cout << ans;
}
```

---

## 个人心得摘录  
> **调试教训**：初始 `dp` 数组未正确初始化导致全 WA，需确认 `dp[0] = 1`。  
> **优化顿悟**：发现 `max` 或 `|=` 均可用于状态转移，但 `|=` 更直观高效。

---
处理用时：79.71秒
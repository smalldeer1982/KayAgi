# 题目信息

# [蓝桥杯 2022 国 B] 齿轮

## 题目描述

这天，小明在组装齿轮。

他一共有 $n$ 个齿轮，第 $i$ 个齿轮的半径为 $r_{i}$, 他需要把这 $n$ 个齿轮按一定顺序从左到右组装起来，这样最左边的齿轮转起来之后，可以传递到最右边的齿轮，并且这些齿轮能够起到提升或者降低转速（角速度）的作用。

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_8ee8d95d6d0319bca20dg-17.jpg)

小明看着这些齿轮，突然有 $Q$ 个疑问: 能否按一定顺序组装这些齿轮使得最右边的齿轮的转速是最左边的齿轮的 $q_{i}$ 倍?


## 说明/提示

**【样例说明】**

询问 $1$ 方案之一：`23341`。

询问 $2$ 方案之一：`42331`。

询问 $3$ 没有方案。

**【评测用例规模与约定】**

对于 $15 \%$ 的数据，保证 $n, Q \leq 100$;

对于 $30 \%$ 的数据，保证 $n, Q \leq 2000$;

对于 $100 \%$ 的数据，保证 $n\ge 2,n, Q \leq 2 \times 10^{5} ; a_{i}, q_{i} \leq 2 \times 10^{5}$。

蓝桥杯 2022 国赛 B 组 I 题。

## 样例 #1

### 输入

```
5 3
4 2 3 3 1
2
4
6```

### 输出

```
YES
YES
NO```

# AI分析结果



# 齿轮问题分析

## 算法分类
**数论/预处理倍数**

---

## 题解思路与核心难点

### 核心逻辑推导
1. **转速关系**：相邻齿轮角速度之比等于半径的反比。多个齿轮串联后，总转速比仅取决于首尾齿轮半径比。
2. **问题转换**：判断是否存在半径比等于查询值 \( q_i \) 的两个齿轮。
3. **预处理优化**：通过预处理每个数的倍数，标记所有可能的比值，使得每次查询可在 \( O(1) \) 时间内完成。

### 实现关键
- **桶标记**：使用数组或哈希表记录每个半径的出现次数。
- **倍数遍历**：对每个唯一半径 \( r \)，遍历其倍数 \( r, 2r, 3r... \)，若存在对应倍数则标记该比值。
- **重复处理**：当 \( q=1 \) 时，需要至少两个相同半径的齿轮。

---

## 高星题解推荐（≥4星）

### 1. 题解作者：cwfxlh（★★★★★）
- **亮点**：高效预处理倍数，跳过重复元素优化时间，正确处理 q=1 的特殊情况。
- **代码可读性**：逻辑清晰，使用排序和去重减少计算量。
- **核心代码**：
  ```cpp
  for(int i=1; i<=n; i++) {
      if (i>1 && a[i]==a[i-1]) continue; // 去重
      for(int j=a[i]; j<=a[n]; j+=a[i]) { // 遍历倍数
          if (!mp[j]) continue;
          if (mp[j]==1 && j==a[i]) continue; // 排除自身单次出现
          ans[j/a[i]] = 1;
      }
  }
  ```

### 2. 题解作者：liupei（★★★★☆）
- **亮点**：独立处理 q=1 情况，通过因数分解标记所有可能比值。
- **代码简洁性**：使用单独数组标记存在性，逻辑直观。
- **核心代码**：
  ```cpp
  for(int i=1; i<=MAX; i++) {
      if (vis[i]) {
          for(int j=i*2; j<=MAX; j+=i) {
              if (vis[j]) ans[j/i] = 1;
          }
      }
  }
  ```

### 3. 题解作者：_Above_the_clouds_（★★★★☆）
- **亮点**：动态调整桶计数避免重复，结合排序优化遍历顺序。
- **优化技巧**：处理当前数时临时减少计数，确保不重复标记自身。
- **核心代码**：
  ```cpp
  for(int i=1; i<=n; i++) {
      t[r[i]]--; // 临时减计数
      for(int j=r[i]; j<=r[n]; j+=r[i]) {
          if (t[j]) ans[j/r[i]] = 1;
      }
      t[r[i]]++; // 恢复计数
  }
  ```

---

## 最优思路提炼
1. **预处理倍数**：对每个数的所有可能倍数进行遍历，标记合法比值。
2. **桶优化**：用数组代替哈希表，快速查询是否存在目标值。
3. **去重与特殊处理**：跳过重复元素减少计算量，单独处理 q=1 的边界条件。

---

## 类似题目推荐
1. **LeetCode 1497. Check If Array Pairs Are Divisible by k**  
   （判断数组元素对是否能被 k 整除）
2. **LeetCode 1. Two Sum**  
   （两数之和的变体，查找特定关系数对）
3. **洛谷 P2424 约数和**  
   （因数分解与预处理）

---

## 可视化设计
### 算法动画演示
- **动态遍历**：以像素网格展示每个数的倍数遍历过程，当前数高亮为黄色，有效倍数标记为绿色。
- **音效反馈**：发现合法比值时播放短促“叮”声，错误或无解时播放低沉音效。
- **交互控制**：支持暂停/继续、步进执行，速度调节滑块控制遍历速度。

### 复古像素风格
- **颜色方案**：使用 8-bit 风格调色板，数轴以蓝底白格绘制，当前操作元素闪烁。
- **Canvas 实现**：每个数显示为方块，倍数检查时动态连线并显示比值。

---

## 代码实现（核心片段）
```cpp
// 预处理所有可能比值
for (int i = 1; i <= n; i++) {
    if (i > 1 && a[i] == a[i-1]) continue; // 去重
    for (int j = a[i]; j <= max_r; j += a[i]) {
        if (bucket[j]) { // 存在该倍数
            int ratio = j / a[i];
            ans[ratio] = 1;
        }
    }
}
```

---

## 个人心得
- **去重优化**：在处理大数据时，跳过重复元素能显著减少不必要的计算。
- **边界条件**：q=1 必须单独处理，确保至少有两个相同元素。
- **桶选择**：数组比哈希表更高效，但需注意空间预分配。

---
处理用时：186.16秒
# 题目信息

# [蓝桥杯 2022 国 C] 取模

## 题目描述

给定 $n, m$，问是否存在两个不同的数 $x,y$ 使得 $1 \le x < y \le m$ 且 $n \bmod x = n \bmod ⁡y$。

## 说明/提示

对于 $20\%$ 的评测用例，$T \le 100$，$n, m \le 1000$；

对于 $50\%$ 的评测用例，$T \le 10000$，$n, m \le 10^5$；

对于所有评测用例，$1\le T \le 10^5$，$1\le n\le 10^9$，$2\le m \le 10^9$。

蓝桥杯 2022 国赛 C 组 C 题。

## 样例 #1

### 输入

```
3
1 2
5 2
999 99```

### 输出

```
No
No
Yes```

# AI分析结果



## 算法分类
数学（抽屉原理、同余）

---

## 题解思路与解决难点
### 核心思路
题目要求判断是否存在两个不同的数 $x,y$ 使得 $n \bmod x = n \bmod y$。核心思路基于以下数学观察：
1. **抽屉原理**：若余数种类数小于 $m$，则必然存在重复余数。
2. **临界值分析**：当 $m$ 足够大时，$n$ 无法满足所有余数互异，直接返回 `Yes`。
3. **模数特性**：当且仅当 $n \equiv i-1 \pmod{i}$ 对所有 $i \in [1, m]$ 成立时，余数才两两不同。

### 难点对比
1. **晴空一鹤的解法**：
   - 直接判断 $m > n+1$，但时间复杂度为 $O(T \cdot m)$，当 $m$ 较大时超时。
   - **优点**：代码简洁，适合小范围数据。
   - **缺点**：无法处理 $m$ 较大的评测用例。

2. **yizcdl2357的解法**：
   - 预处理 $1$ 到 $30$ 的最小公倍数数组。
   - 当 $m > 30$ 时直接返回 `Yes`，否则检查 $n \bmod L[m] = L[m]-1$。
   - **优点**：时间复杂度 $O(T)$，完美处理大范围数据。

3. **J2a0m0e8s的解法**：
   - 设定临界值 $m \geq 19$，暴力检查余数条件。
   - **优点**：基于预处理和暴力结合，时间复杂度可接受。
   - **缺点**：临界值选择较小，可能增加暴力次数。

---

## 题解评分（≥4星）
1. **yizcdl2357的解法（5星）**：
   - **思路清晰度**：基于最小公倍数和抽屉原理，逻辑严谨。
   - **代码可读性**：预处理数组清晰，注释明确。
   - **算法优化**：时间复杂度最优，完美处理所有数据范围。

2. **J2a0m0e8s的解法（4星）**：
   - **思路清晰度**：通过打表发现临界值，结合暴力验证。
   - **实践操作性**：预处理到较小临界值，代码简洁易实现。

3. **Sktic的解法（4星）**：
   - **代码可读性**：使用 `multiset` 快速判重，思路直观。
   - **优化程度**：设定 $m \geq 30$ 的临界值，时间复杂度合理。

---

## 最优思路提炼
1. **临界值法**：当 $m$ 超过某值（如 $30$），直接返回 `Yes`。
2. **最小公倍数优化**：
   - 预处理 $1$ 到 $30$ 的最小公倍数数组 $L$。
   - 若 $n \bmod L[m] = L[m]-1$，返回 `No`，否则 `Yes`。
3. **抽屉原理**：若 $n$ 的余数无法覆盖 $[0, m-1]$，必有重复。

---

## 同类型题推荐
1. [P1463 反素数](https://www.luogu.com.cn/problem/P1463)
2. [P2424 约数和](https://www.luogu.com.cn/problem/P2424)
3. [P1891 疯狂 LCM](https://www.luogu.com.cn/problem/P1891)

---

## 可视化与算法演示
### 核心逻辑动画设计
1. **像素风格界面**：
   - 每个 $i \in [1, m]$ 对应一个像素块，颜色表示余数值。
   - 动态生成余数，若重复则闪烁红色并播放音效。
   
2. **交互控制**：
   - **步进执行**：手动控制余数生成节奏。
   - **自动播放**：按固定速度演示余数生成过程。
   - **音效提示**：成功/失败时播放 8-bit 音效。

3. **关键步骤高亮**：
   - 当前计算的 $i$ 高亮为黄色。
   - 重复的余数块标记为红色。

---

## 代码实现（yizcdl2357的解法）
```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
inline int gcd(int x,int y) {
    if(y==0) return x;
    return gcd(y,x%y);
}
inline int lcm(int x,int y) {
    return x/gcd(x,y)*y;
}
int L[31], T, n, m;
signed main() {
    L[1] = 1;
    for(int i=2; i<=30; i++)
        L[i] = lcm(L[i-1], i);
    cin >> T;
    while(T--) {
        cin >> n >> m;
        if(m > 30) { printf("Yes\n"); continue; }
        if(n % L[m] == L[m] - 1) printf("No\n");
        else printf("Yes\n");
    }
    return 0;
}
```

---

## 个人心得摘录
- **调试教训**：最小公倍数可能溢出，需用 `long long`。
- **临界值计算**：通过实验确定 $m=30$ 的临界值，确保 $L[m]-1 > 10^9$。
- **优化思路**：将数学性质转化为预处理数组，极大降低时间复杂度。

---
处理用时：278.03秒
# 题目信息

# [图论与代数结构 201] 最短路问题_1

## 题目描述

给定一张 $n$ 个点、$m$ 条边的有向图，求 $1$ 号点到每个点的最短路径长度。

**注意，图可能存在重边和自环，保证不存在负环。**

## 说明/提示

本题没有部分分。

对于所有数据，$1\leq n,m \leq 2\times 10^3$，$-10^9\leq w_i\leq 10^9$。

请注意答案上界的大小，可能需要使用 C++ 中的 `long long int` 类型。

## 样例 #1

### 输入

```
4 5
1 2 1
2 3 4
1 3 3
4 1 5
3 1 2
```

### 输出

```
0 1 3 -1```

## 样例 #2

### 输入

```
10 50
5 9 6
1 3 10
3 1 1
10 2 5
8 5 1
10 10 6
6 5 2
1 5 10
2 5 5
10 1 4
1 5 2
8 8 7
7 2 7
9 2 8
3 1 4
6 2 5
3 9 9
4 9 5
5 10 9
10 1 9
5 4 5
9 1 2
5 10 6
3 8 7
10 3 7
5 8 8
9 2 6
9 8 6
3 2 8
1 3 8
1 10 1
7 8 4
9 4 5
4 6 2
2 7 6
10 1 5
9 9 7
6 7 4
1 1 7
8 3 10
8 3 9
10 9 8
3 9 1
7 4 8
1 5 4
8 4 4
3 4 4
9 9 2
2 10 4
8 9 6
```

### 输出

```
0 6 8 7 2 9 12 10 8 1```

# AI分析结果



---

### **唯一算法分类**  
**最短路算法（Bellman-Ford/SPFA）**

---

### **综合分析与结论**  
#### **核心思路与难点**  
1. **问题特性**：存在负权边但无负环，需用 Bellman-Ford 或 SPFA（队列优化的 Bellman-Ford）。  
2. **算法对比**：  
   - **Bellman-Ford**：遍历所有边松弛 `n-1` 轮，复杂度稳定为 `O(nm)`。  
   - **SPFA**：通过队列动态维护待松弛节点，避免无效松弛，平均效率更高。  
3. **关键难点**：  
   - 初始化距离数组，正确处理无穷大值。  
   - 判断负权边对松弛的影响，避免重复入队（SPFA）。  

#### **可视化设计要点**  
- **动态松弛过程**：  
  - 节点颜色：红色（当前处理节点）、绿色（队列中待处理节点）、灰色（已处理节点）。  
  - 边高亮：松弛成功的边显示为黄色，未更新的边保持原色。  
- **队列状态**：右侧面板实时显示队列内容，动态更新。  
- **复古像素风格**：  
  - **颜色方案**：16 色调色板，节点用 8x8 像素块表示，边用虚线箭头。  
  - **音效**：松弛成功时播放“滴”声，节点入队时播放“哔”声。  

---

### **题解清单 (≥4星)**  
1. **伟大的王夫子（4.5⭐）**  
   - **亮点**：简洁的 Bellman-Ford 实现，适合教学。  
   - **代码片段**：  
     ```cpp  
     for (int i = 1; i <= n; ++i) {  
         flag = 1;  
         for (int j = 1; j <= m; ++j)  
             if (dis[a[j].y] > dis[a[j].x] + a[j].z)  
                 flag = 0, dis[a[j].y] = dis[a[j].x] + a[j].z;  
         if (flag) break;  
     }  
     ```  
   - **心得**：“优化可能没用，但实际跑得挺快。”  

2. **刘嘉琦（4⭐）**  
   - **亮点**：对比 Bellman-Ford 与 SPFA，代码清晰且有注释。  
   - **代码片段**（SPFA）：  
     ```cpp  
     while (!q.empty()) {  
         int k = q.front();  
         q.pop(), v[k] = false;  
         for (int i = head[k]; ~i; i = nxt[i])  
             if (d[k] + val[i] < d[to[i]]) {  
                 d[to[i]] = d[k] + val[i];  
                 if (!v[to[i]]) q.push(to[i]), v[to[i]] = true;  
             }  
     }  
     ```  
   - **心得**：“队列优化能跳过无效松弛，但不要迷信 SPFA。”  

3. **白简（4⭐）**  
   - **亮点**：标准 SPFA 模板，可读性强。  
   - **代码片段**：  
     ```cpp  
     while (!Q.empty()) {  
         int u = Q.front(); Q.pop();  
         vis[u] = false;  
         for (Edge e = E[u]; e; e = e->next)  
             if (dis[e->to] > dis[u] + e->w) {  
                 dis[e->to] = dis[u] + e->w;  
                 if (!vis[e->to]) Q.push(e->to), vis[e->to] = true;  
             }  
     }  
     ```  

---

### **最优思路提炼**  
1. **SPFA 动态松弛**：通过队列维护活跃节点，避免全量松弛，降低常数因子。  
2. **Bellman-Ford 优化**：若某轮未松弛则提前终止，减少冗余计算。  
3. **边界处理**：使用 `0x3f3f3f3f` 表示无穷大，输出时判断是否可达。  

---

### **同类题目与套路**  
1. **负权边最短路**：SPFA 是通用解法，需注意处理负环检测。  
2. **全源最短路**：Johnson 算法重赋权后跑 Dijkstra。  
3. **类似题目**：  
   - 洛谷 P3385（判断负环）  
   - 洛谷 P3371（最短路模板）  
   - 洛谷 B3602（Dijkstra 模板）  

---

### **复古游戏化动画实现**  
- **Canvas 动画**：  
  1. **节点绘制**：8x8 像素方块，初始白色，入队变绿，处理时变红。  
  2. **边绘制**：灰色虚线，松弛时变黄并闪烁。  
  3. **控制面板**：速度滑块（1x-5x），暂停/继续按钮。  
- **音效设计**：  
  - `relax_sound.wav`：松弛成功时播放。  
  - `enqueue_sound.wav`：节点入队时播放。  
- **自动演示模式**：按固定速度逐步执行，模拟“AI 决策”。  

---

### **代码实现（关键部分）**  
```javascript  
// 伪代码：SPFA 动画核心逻辑  
function animateSPFA() {  
    let queue = [1], inQueue = new Array(n+1).fill(false);  
    inQueue[1] = true;  
    while (queue.length > 0) {  
        let u = queue.shift();  
        drawNode(u, COLOR_RED); // 当前节点红色  
        playSound("select_sound");  
        for (let e of adj[u]) {  
            if (dis[e.v] > dis[u] + e.w) {  
                dis[e.v] = dis[u] + e.w;  
                drawEdge(u, e.v, COLOR_YELLOW);  
                playSound("relax_sound");  
                if (!inQueue[e.v]) {  
                    queue.push(e.v);  
                    inQueue[e.v] = true;  
                    drawNode(e.v, COLOR_GREEN);  
                }  
            }  
        }  
        drawNode(u, COLOR_GRAY); // 处理完变灰  
    }  
}  
```  

--- 

通过上述分析，SPFA 是最优选择，兼顾效率与实现简洁性。

---
处理用时：101.44秒
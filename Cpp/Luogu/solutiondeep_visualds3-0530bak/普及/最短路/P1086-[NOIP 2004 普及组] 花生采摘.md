# 题目信息

# [NOIP 2004 普及组] 花生采摘

## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。

**注意**：在采摘过程中不能回到路边。

## 说明/提示

noip2004普及组第2题


## 样例 #1

### 输入

```
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0```

### 输出

```
37```

## 样例 #2

### 输入

```
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```

### 输出

```
28```

# AI分析结果



---

### 算法分类  
**贪心算法 + 曼哈顿距离计算**

---

### 综合分析与结论  
题目核心是通过曼哈顿距离模拟采摘路径，按花生数从大到小依次处理。关键难点在于时间计算：  
1. **移动时间**：两点间曼哈顿距离（横向+纵向步数）  
2. **采摘时间**：固定消耗 1 单位  
3. **返回时间**：当前点行号（最远行到路边的纵向步数）  
各题解均采用**排序 + 逐步验证时间可行性**的贪心策略，差异在于数据结构选择（结构体数组、优先队列、稀疏矩阵等）。  

#### 可视化设计要点  
- **像素风格网格**：用 8-bit 风格渲染花生田，每个格子的颜色深浅表示花生数量，当前路径用高亮色块标记。  
- **动态时间条**：顶部显示剩余时间，每次移动/采摘时同步更新。  
- **音效设计**：移动时播放“滴”声，采摘时播放“咔嚓”声，时间不足时播放警示音。  
- **AI 自动模式**：按最优顺序自动采摘，用路径连线展示曼哈顿距离计算过程。  

---

### 题解评分（≥4星）  
1. **jiangXxin（4.5星）**  
   - 亮点：结构体排序逻辑清晰，曼哈顿距离计算简洁。  
   - 改进点：未处理第一个点无法采摘的特殊情况（需特判）。  
   - 代码片段：  
     ```cpp
     sort(stu+1,stu+pn+1,comp); // 按花生数降序排序
     k--; // 进入第一行的初始时间
     for(int i=1;i<=pn;i++){
         tm = abs(fx-ex)+abs(fy-ey); // 曼哈顿距离计算
         if(k >= ex) ans += mp[ex][ey]; // 剩余时间足够返回
     }
     ```

2. **_Arahc_（5星）**  
   - 亮点：优先队列自动排序 + map 坐标映射，代码简洁高效。  
   - 关键优化：避免显式排序，直接取最大值。  
   - 代码片段：  
     ```cpp
     priority_queue<int> q; // 大根堆存储花生数
     while(w+x<=k){ // 剩余时间足够返回
         s += j; // 采摘当前最大值
         j = q.top(); q.pop(); // 取下一个最大值
         w += abs(c[j].first-x) + abs(c[j].second-y) + 1; // 更新总耗时
     }
     ```

3. **buickboy（4星）**  
   - 亮点：降维处理二维数组，代码极简。  
   - 代码片段：  
     ```cpp
     struct pea{ int a,b,s; }; // 行、列、花生数
     sort(p+1,p+1+r,cmp); // 按s降序排列
     if(k >= t+1+p[i+1].a) ans += p[i+1].s; // 时间可行性验证
     ```

---

### 最优思路提炼  
1. **排序优先**：所有题解均先按花生数降序排列。  
2. **时间验证公式**：`移动耗时 + 采摘耗时 + 返回耗时 ≤ 剩余时间`  
   - 移动耗时 = |x1-x2| + |y1-y2|  
   - 返回耗时 = 当前点行号（纵向距离路边）  
3. **特判首点**：首次进入花生田需单独计算初始时间（从路边到首点行号）。  

---

### 类似题目推荐  
1. **P1090 [NOIP2004 提高组] 合并果子** - 贪心 + 优先队列  
2. **P1056 [NOIP2008 普及组] 排座椅** - 曼哈顿距离应用  
3. **P2678 [NOIP2015 提高组] 跳石头** - 贪心验证可行性  

---

### 核心算法可视化  
```javascript
// 伪代码：Canvas 绘制关键步骤
function drawStep(currentPos, nextPos, timeLeft) {
    ctx.fillStyle = "#8B0000"; // 深红色表示当前点
    drawGridCell(currentPos.x, currentPos.y);
    ctx.fillStyle = "#FFD700"; // 金色表示下一个目标点
    drawGridCell(nextPos.x, nextPos.y);
    drawPathLine(currentPos, nextPos); // 绘制曼哈顿路径连线
    updateTimeBar(timeLeft); // 更新顶部时间条
    playSound("move"); // 移动音效
}
```

---

### 个人心得摘录  
- **jiangXxin**：原计划用 BFS，发现无障碍物后改用曼哈顿距离，体现算法选择需结合题目条件。  
- **_Arahc_**：强调注意第 4 个测试点（单点重复采摘），需特判队列空的情况。  
- **buickboy**：降维法简化代码，验证首点时间时需计算 `2*x+1`（往返 + 采摘）。  

---

### 复古游戏化设计（Web 实现）  
```html
<canvas id="game"></canvas>
<script>
// 8-bit 调色板
const PALETTE = ["#000000", "#1D2B53", "#7E2553", "#008751", 
                "#AB5236", "#5F574F", "#C2C3C7", "#FFF1E8"];
// 初始化画布
const ctx = document.getElementById('game').getContext('2d');
let timeLeft = 21; // 初始时间
// 自动播放函数
function autoPlay() {
    const path = getOptimalPath(); // 计算最优路径
    path.forEach((pos, idx) => {
        setTimeout(() => drawStep(pos), idx * 500); // 步进动画
    });
}
</script>
```

---
处理用时：93.00秒
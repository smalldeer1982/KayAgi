# 题目信息

# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 说明/提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)

题目中没有强制 $i \neq j$，但是实测数据中不存在 $i = j$ 的情况。

## 样例 #1

### 输入

```
4
M 2 3
C 1 2
M 2 4
C 4 2```

### 输出

```
-1
1```

# AI分析结果



**唯一算法分类**  
带权并查集

---

### **题解思路与核心难点解析**  
#### **核心思路**  
所有题解均采用带权并查集，维护两个核心信息：  
1. `d[i]`：节点 i 到所在集合根节点的距离  
2. `size[i]`：以 i 为根的集合大小（战舰总数）  

**合并操作**：将 x 所在队列接到 y 队列尾部时：  
- 更新 x 根节点的距离 `d[x_root] = size[y_root]`  
- 更新 y 根节点的集合大小 `size[y_root] += size[x_root]`  

**查询操作**：路径压缩时动态维护 `d[i]` 的累加值，最终通过 `abs(d[x] - d[y]) - 1` 计算两战舰间距  

#### **实现难点**  
1. **路径压缩时的距离更新**  
   递归找根时先更新父节点距离，再回溯更新当前节点：  
   ```cpp  
   int find(int x) {
       if (fa[x] != x) {
           int root = find(fa[x]); // 先递归更新父节点
           d[x] += d[fa[x]];       // 再累加当前节点距离
           fa[x] = root;            // 路径压缩
       }
       return fa[x];
   }  
   ```  
2. **合并时的集合大小更新**  
   必须先将 y 的集合大小累加到 x 的根节点，否则会丢失原始队列长度信息  

---

### **题解评分与亮点**  
#### **[假装思考] 题解（★★★★★）**  
- **亮点**：  
  1. 完整注释解释 `front[]`（距离）与 `num[]`（集合大小）的更新逻辑  
  2. 通过递归回溯更新路径压缩后的距离  
  3. 代码可读性极强，变量命名清晰  

#### **[破壁人] 题解（★★★★☆）**  
- **亮点**：  
  1. 代码简洁，合并逻辑直击核心  
  2. 使用 `abs(s[x]-s[y])-1` 公式体现数学思维  
  3. 在路径压缩时同步更新 `s[]`（距离）  

#### **[Mr_Wolfram] 题解（★★★★☆）**  
- **亮点**：  
  1. 独立维护 `dis[]`（距离）和 `num[]`（集合大小）  
  2. 通过 `merge()` 函数明确合并顺序  
  3. 函数模块化设计提升代码复用性  

---

### **最优技巧提炼**  
**关键数据结构**：  
```cpp
int fa[MAXN];    // 父节点
int d[MAXN];     // 到根节点的距离
int size[MAXN];  // 集合大小  
```  

**合并操作伪代码**：  
```cpp
void merge(int x, int y) {
    x = find(x), y = find(y);
    fa[x] = y;            // x 的根指向 y 的根
    d[x] = size[y];       // x 根的距离 = y 的原始集合大小
    size[y] += size[x];   // y 的集合大小累加 x
}  
```  

**路径压缩核心逻辑**：  
```cpp
int find(int x) {
    if (fa[x] != x) {
        int root = find(fa[x]);  // 递归找根
        d[x] += d[fa[x]];       // 累加父节点距离
        fa[x] = root;            // 路径压缩
    }
    return fa[x];
}  
```  

---

### **同类型题与算法拓展**  
1. **P2024 食物链** - 带权并查集维护环形关系  
2. **P1525 关押罪犯** - 并查集划分敌对关系  
3. **P1955 程序自动分析** - 离散化+并查集  

---

### **可视化与复古像素动画设计**  
**核心动画逻辑**：  
1. **战舰队列显示**：  
   - 每个战舰用 16x16 像素方块表示，初始按 1~30000 排列  
   - 合并时，被移动队列整体平移至目标队列尾部，播放“咔嗒”音效  

2. **路径压缩过程**：  
   - 高亮当前递归节点，显示 `d[i] += d[fa[i]]` 的数值变化  
   - 用绿色箭头表示父节点指针的更新路径  

3. **查询操作演示**：  
   - 红蓝高亮两个战舰，动态绘制距离差计算公式  
   - 若不在同一队列，显示红色“-1”并播放失败音效  

**复古风格实现**：  
```javascript  
// Canvas 绘制战舰队列（8-bit风格）  
function drawShip(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * 16, y * 16, 14, 14); // 留1像素边框
    ctx.strokeStyle = '#000';
    ctx.strokeRect(x * 16, y * 16, 14, 14);
}  
```  

**音效触发逻辑**：  
```javascript  
// 合并成功时播放合成音效  
const mergeSound = new Audio('sfx/merge.wav'); 
function playMergeEffect() {
    mergeSound.currentTime = 0;
    mergeSound.play();
}  
```  

---

### **代码实现片段**  
**核心合并与查询逻辑**：  
```cpp  
#include<bits/stdc++.h>
const int MAXN = 30010;

int fa[MAXN], d[MAXN], size[MAXN];

int find(int x) {
    if (fa[x] != x) {
        int root = find(fa[x]);
        d[x] += d[fa[x]];  // 关键：累加父节点距离
        fa[x] = root;
    }
    return fa[x];
}

void merge(int x, int y) {
    x = find(x), y = find(y);
    if (x == y) return;
    fa[x] = y;
    d[x] = size[y];       // x到新根的距离 = y的原始大小
    size[y] += size[x];    // 更新y的集合大小
}

int query(int x, int y) {
    if (find(x) != find(y)) return -1;
    return abs(d[x] - d[y]) - 1;
}

int main() {
    for (int i = 1; i < MAXN; ++i) 
        fa[i] = i, size[i] = 1;
    // 处理输入输出...
}  
```  

---

### **调试心得摘录**  
> “路径压缩必须**先递归更新父节点**，再累加当前节点距离，否则会漏算中间层距离”——[假装思考]  
> “合并时 `d[x_root] = size[y_root]` 是关键，体现队列接尾的数学本质”——[破壁人]

---
处理用时：86.39秒
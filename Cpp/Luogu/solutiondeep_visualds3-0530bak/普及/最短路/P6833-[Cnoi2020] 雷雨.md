# 题目信息

# [Cnoi2020] 雷雨

## 题目背景

> 令人不安的云开始笼罩天空。  
巨大的建筑在强风中轧轧作响。  
幻想乡中响彻着不和协音。  
——「东方辉针城 ～ Double Dealing Character」

一个雷雨交加的夜晚，一束闪电击中了雾之湖畔的红魔馆和迷途竹林。

似乎有什么大事要发生，Cirno 在小屋静静地中思考着。

## 题目描述

幻想乡的纵切面可以抽象成一个 $n\times m$ 的矩形。

其中每一个 $1\times 1$ 的单元格 $(i,j)$ 都有一个**电阻计量值**(虚构的概念) $R_{i,j}$。

闪电从**雷雨云**上的 $\texttt{O}(n,a)$ 发出，击中了**地面**上的*红魔馆* $\texttt{A}(1,b)$ 与*迷途竹林* $\texttt{B}(1,c)$。

雷电是自然的造物，所以覆盖的位置电阻计量值总和最小，即从 $\texttt{O}$ 到 $\texttt{A}$ 与 $\texttt{B}$ 的**两条路径的并集**的电阻计量值的和最小。

所以在所有位置电阻计量已知的情况下，Cirno 想知道雷电的经过的路径的最小电阻计量值的和。

## 说明/提示

## 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/7ozs40i3.png)

如图黄色线为闪电的路径。

## 数据范围与约定

对于 $100\%$ 的数据保证：$0<n,m \le 1000$，$0 \le R_{i,j}\le 10^9$，$0< a,b,c \le m$。

#### 子任务「本题采用捆绑测试」

 - Subtask1（$10\%$）: $R_{i,j}\in\{1\}$。
 - Subtask2（$10\%$）: $R_{i,j}\in\{0,1\}$。
 - Subtask3（$10\%$）: $a=b=c$。
 - Subtask4（$10\%$）: $n,m \le 5$。
 - Subtask5（$60\%$）: 无特殊限制。
 

## 样例 #1

### 输入

```
5 5 1 2 4
1 8 1 6 6
1 1 1 2 4
8 3 1 2 2
1 2 1 9 1
1 0 9 1 1```

### 输出

```
15```

# AI分析结果



### 算法分类
**最短路径（Dijkstra算法）**

---

### 核心思路与难点解析
#### 关键思路
1. **分叉点模型**：雷电路径必然在某个点分叉，形成三条路径：起点到分叉点、分叉点到两个终点。  
2. **三次最短路预处理**：  
   - 分别以起点 O、终点 A、终点 B 为源点，计算到所有点的最短路径（点权转为边权）。  
   - 分叉点电阻被重复计算三次，需减去两次。  
3. **枚举分叉点**：遍历所有可能的点，计算 `dis_O[x] + dis_A[x] + dis_B[x] - 2 * R[x]`，取最小值。

#### 解决难点
- **点权转边权**：将相邻点间的边权设为目标点的电阻值，保证路径总电阻正确累加。  
- **重复计算处理**：分叉点电阻被三次最短路计算重复累加，需减去两次。  
- **网格图优化**：直接使用网格坐标代替显式建图，避免邻接表空间开销。

---

### 题解评分（≥4星）
1. **Lonely_NewYear（5星）**  
   - **亮点**：代码简洁，正确初始化起点电阻，注释明确。  
   - **关键代码**：  
     ```cpp
     dis[0][sx][sy] = num[sx][sy];  // 起点电阻初始化
     ans = min(ans, dis[0][i][j] + dis[1][i][j] + dis[2][i][j] - 2 * num[i][j]);
     ```

2. **Rubidium_Chloride（5星）**  
   - **亮点**：优先队列 BFS 优化，网格坐标处理清晰。  
   - **关键代码**：  
     ```cpp
     dst[t][nx][ny] = min(dst[t][nx][ny], dst[t][x.x][x.y] + r[nx][ny]);
     ```

3. **InformationEntropy（4星）**  
   - **亮点**：详细推导分叉点公式，解释重复计算逻辑。  
   - **关键注释**：  
     > 分叉点被计算三次，需减两次。

---

### 最优技巧提炼
1. **点权转边权**：将目标点电阻作为移动边权，确保路径总和正确。  
   ```cpp
   // 移动方向处理示例
   for (int i=0; i<4; i++) {
       int nx = x + dx[i], ny = y + dy[i];
       if (nx < 1 || nx > n || ny < 1 || ny > m) continue;
       if (dis[new] > dis[current] + R[nx][ny]) { ... }
   }
   ```
2. **分叉点枚举公式**：  
   `总电阻 = dis_O[x] + dis_A[x] + dis_B[x] - 2 * R[x]`

---

### 同类题目推荐
1. **P5683 [CSPJX2019]道路拆除**：类似分叉路径模型，需计算多源最短路。  
2. **P1119 灾后重建**：动态最短路问题，训练多源处理能力。  
3. **P1462 通往奥格瑞玛的道路**：结合点权与路径限制的最短路问题。

---

### 可视化与算法演示
#### 动画设计
1. **网格渲染**：  
   - **Canvas 网格**：用不同颜色表示电阻值（深色高电阻，浅色低电阻）。  
   - **分叉点高亮**：闪烁显示当前枚举的分叉点，并绘制三条路径。  

2. **Dijkstra 过程**：  
   - **优先队列可视化**：显示队列中待处理的节点及其当前距离。  
   - **路径扩展动画**：用流动效果表示从当前节点向四周扩展。  

3. **复古风格**：  
   - **8-bit 音效**：路径更新时播放 "beep" 音，找到最优解时播放胜利音效。  
   - **像素方块**：每个网格点用 16x16 像素块表示，距离值以数字叠加显示。  

#### 交互功能
- **步进控制**：支持暂停/继续，单步执行 Dijkstra 扩展。  
- **速度调节**：滑动条控制动画速度（0.5x~5x）。  
- **自动演示**：AI 模式自动完成三次最短路与分叉点枚举。

---

### 核心代码片段
```cpp
// Lonely_NewYear 的 Dijkstra 实现
void dijkstra(int k, int sx, int sy) {
    priority_queue<node> q;
    memset(vis, 0, sizeof(vis));
    for (int i=1; i<=n; i++) 
        for (int j=1; j<=m; j++) 
            dis[k][i][j] = INF;
    dis[k][sx][sy] = num[sx][sy];
    q.push({sx, sy, dis[k][sx][sy]});
    while (!q.empty()) {
        node now = q.top(); q.pop();
        if (vis[now.x][now.y]) continue;
        vis[now.x][now.y] = 1;
        for (int i=0; i<4; i++) {
            int nx = now.x + dx[i], ny = now.y + dy[i];
            if (nx<1 || nx>n || ny<1 || ny>m) continue;
            if (dis[k][nx][ny] > dis[k][now.x][now.y] + num[nx][ny]) {
                dis[k][nx][ny] = dis[k][now.x][now.y] + num[nx][ny];
                q.push({nx, ny, dis[k][nx][ny]});
            }
        }
    }
}
```

---

### 个人心得摘录
> **Lonely_NewYear**：  
> “十年 OI 一场空，不开 long long 见祖宗”——电阻值累加可能超出 int 范围，需全程使用 long long。  
> **Rubidium_Chloride**：  
> “优先队列 BFS 实际是 Dijkstra 的变种，适合网格图”——强调算法选择对性能的影响。  

---

### 总结
本题通过三次 Dijkstra 预处理与分叉点枚举，将复杂路径并集问题转化为经典最短路模型。关键点在于正确转换点权与处理重复计算，代码实现需注意数据范围与边界条件。可视化设计可大幅提升对分叉逻辑的理解，复古风格增强学习趣味性。

---
处理用时：107.94秒
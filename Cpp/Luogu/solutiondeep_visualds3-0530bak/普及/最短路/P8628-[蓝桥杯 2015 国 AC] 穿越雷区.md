# 题目信息

# [蓝桥杯 2015 国 AC] 穿越雷区

## 题目描述

$X$ 星的坦克战车很奇怪，它必须交替地穿越正能量辐射区和负能量辐射区才能保持正常运转，否则将报废。

某坦克需要从 $A$ 区到 $B$ 区去（$A$，$B$ 区本身是安全区，没有正能量或负能量特征），怎样走才能路径最短？

已知的地图是一个方阵，上面用字母标出了 $A$，$B$ 区，其它区都标了正号或负号分别表示正负能量辐射区。

例如：

```
A + - + -
- + - - +
- + + + -
+ - + - +
B + - + -
```

坦克车只能水平或垂直方向上移动到相邻的区。


## 说明/提示

时限 1 秒, 512M。蓝桥杯 2015 年第六届国赛

## 样例 #1

### 输入

```
5
A + - + -
- + - - +
- + + + -
+ - + - +
B + - + -```

### 输出

```
10```

# AI分析结果



---

**唯一算法分类**：广度优先搜索（BFS）

---

### **题解思路与核心难点**

1. **问题核心**  
   坦克需交替经过正负能量辐射区，求从 `A` 到 `B` 的最短路径。关键点在于每一步的符号必须与当前所在区域的符号不同，且需处理 `A`、`B` 的特殊性（无符号限制）。

2. **算法选择**  
   - **BFS**：按层遍历，首次到达 `B` 的路径即为最短路径，时间复杂度为 O(n²)。  
   - **DFS**：需遍历所有可能路径，无法保证最短路径，仅在数据规模小时可行。  
   - **Dijkstra**：正确但冗余，适用于边权非固定场景，此处 BFS 更高效。

3. **核心难点与解决**  
   - **符号交替判断**：通过记录当前节点的符号，确保下一步符号不同。  
   - **状态标记**：二维数组标记节点是否被访问，利用 BFS 层次特性保证首次访问即最短路径。  
   - **特殊符号处理**：`A` 和 `B` 的符号设为特殊值（如 0），允许首次移动到任意符号。

---

### **题解评分（≥4星）**

1. **fish_love_cat（5星）**  
   - **亮点**：简洁的 BFS 实现，正确处理符号交替，通过二维数组避免重复访问。  
   - **代码**：使用 `f` 数组存储符号，`b` 数组标记访问状态，逻辑清晰。

2. **Dreamer_Boy（4星）**  
   - **亮点**：标准 BFS 模板，结构体封装坐标与步数，方向数组简化代码。  
   - **改进点**：可优化符号判断逻辑，如统一处理 `A` 的初始状态。

---

### **最优思路提炼**

1. **BFS 分层遍历**  
   用队列逐层扩展，确保最短路径优先找到。每个节点仅需访问一次，避免重复计算。

2. **符号状态处理**  
   当前节点的符号决定下一步的合法方向，无需额外记录历史状态。例如：  
   ```cpp
   if (b[xin.x][xin.y] && f[xin.x][xin.y] != f[a.x][a.y]) // 符号不同则入队
   ```

3. **特殊点处理**  
   `A` 和 `B` 的符号设为特殊值（如 0），允许首次移动至任意符号，后续移动正常交替。

---

### **同类题目推荐**

1. **P1443 马的遍历**  
   BFS 求最短路径，固定移动规则（马的走法）。

2. **P1135 奇怪的电梯**  
   BFS 处理每次移动的楼层限制，类似符号交替条件。

3. **P1141 01迷宫**  
   统计连通块，BFS 的扩展应用。

---

### **代码核心逻辑**

```cpp
// fish_love_cat 的 BFS 实现（关键部分）
int bfs() {
    wz a = {sx, sy, 0};
    q.push(a);
    b[sx][sy] = false;
    while (!q.empty()) {
        a = q.front(); q.pop();
        for (int i = 0; i < 4; i++) {
            wz xin = {a.x + gx[i], a.y + gy[i], a.ans + 1};
            if (xin.x == ex && xin.y == ey) return xin.ans; // 找到 B
            if (b[xin.x][xin.y] && f[xin.x][xin.y] != f[a.x][a.y]) { // 符号不同
                q.push(xin);
                b[xin.x][xin.y] = false; // 标记访问
            }
        }
    }
    return -1;
}
```

---

### **可视化与算法演示**

1. **动画设计**  
   - **网格绘制**：Canvas 绘制 n×n 网格，`A`（绿色）、`B`（红色）、`+`（蓝色）、`-`（黄色）。  
   - **当前节点高亮**：正在处理的节点用闪烁边框标记，队列中的节点用半透明色填充。  
   - **移动路径追踪**：用箭头或连线表示移动方向，终点 `B` 被找到时显示路径步数。

2. **复古像素风格**  
   - **8位色调色板**：固定 16 色，方格大小为 32×32 像素，类似 FC 游戏风格。  
   - **音效设计**：  
     - **移动音效**：每次扩展节点播放短促“滴”声。  
     - **成功音效**：找到 `B` 时播放胜利旋律。  
     - **背景音乐**：循环 8 位风格芯片音乐。

3. **交互功能**  
   - **步进控制**：支持暂停/继续、单步执行、调整动画速度。  
   - **自动演示**：AI 自动运行 BFS，展示队列扩展过程。

---

### **总结**

通过 BFS 逐层扩展，结合符号交替条件，确保最短路径优先找到。可视化设计以复古像素风格增强趣味性，帮助理解算法流程。同类题目可通过类似的条件限制和 BFS 扩展思路解决。

---
处理用时：211.68秒
# 题目信息

# Deception Point

## 题目背景

“防空火网已启用。”三角洲二号喊道，他坐在“基奥瓦”武装直升机舱门边的武器控制椅里，竖起了大拇指，“火力网
、调制噪声、掩护脉冲全都激活并锁定。”

三角洲一号心领神会，驾驶着飞机猛地向右一个侧弯飞机又驶上了一条前往“戈雅”的直线路径。这一招能躲过“戈雅”的雷达监控。

“锡箔包确定！”三角洲二号喊道。

> 绝对的孤立，

三角洲一号想。

> 他们毫无抵抗力。

他们的目标幸运且狡猾地从米尔恩冰架上逃脱了，但这回他们不会再得逞了。雷切尔 · 塞克斯顿和迈克尔 · 托兰选择弃岸上船，真是糟糕的选择。不过，这将是他们所做的最后一个坏决定了。

## 题目描述

雷切尔与迈克尔被困在了“戈雅”号上，而三角洲二号正在顺着雷达追杀二人。幸运的是，雷切尔也有一副雷达，因此双方都能知道对方的位置。

船舱内部共有 $n$ 个舱室，其中有 $n$ 条走廊连接这些舱室。$n$ 个舱室是互相连通的。由于船上空间拥挤，船舱内不会出现小于等于四条走廊组成的环。每过一分钟，雷切尔与三角洲二号都会同时从一个舱室跑到另一个舱室。

如果雷切尔在舱室内或者过道上碰到了三角洲，那么就意味着大限将至。雷切尔总共有 $q$ 个问题：当她在舱室 $x$，且三角洲二号在舱室 $y$ 时，她是否可以存活下来？

---

#### **【形式化题意】**

给定一张 $n$ 个点 $n$ 条边的无向连通图，图内不存在四元（及以下）环。$q$ 次询问 $x,y$，分别在图上 $x,y$ 点上放上棋子 $\rm A, B$。

每次两人同时操作棋子沿图边移动一步，若两棋子同时走到了同一个点上或者同时走过了相同的边，则 $\rm B$ 胜利。如果在 $10^{10^{9961}}$ 次操作后 $\rm B$ 还未胜利，则 $\rm A$ 胜利。

$\rm A,B$ 都是绝顶聪明的，他们不会做出对自己不利的决策。请你求出每次游戏的游戏结果。若 $\rm A$ 获胜，输出 `Survive`；否则输出 `Deception`。

**若对题意有疑问，请移步样例解释与数据范围部分。**

## 说明/提示

#### 【样例解释】

船舱结构图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/tlsqnsia.png)

在第二组询问中，三角洲可以先走一步到达结点 $2$，此时雷切尔到达结点 $4$。随后可以证明，不存在一种方案使得雷切尔不碰到三角洲。

#### 【数据范围】

**本题开启捆绑测试。**

| $\text{Subtask}$ | 分值 | $n\le$ | $q\le$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $5$ | $2\times10^5$ | $1$ | 无 |
| $1$ | $5$ | $10$ | $2\times10^5$ | 无 |
| $2$ | $5$ | $2\times 10^5$ | $2\times10^5$ | $\forall 1\le i\le n, u_i=i,v_i=(i\bmod n) + 1$ |
| $3$ | $15$ | $200$ | $2\times 10^5$ | 无 |
| $4$ | $20$ | $2\times 10^3$ | $2\times 10^5$ | 无 |
| $5$ | $50$ | $2\times 10^5$ | $2\times 10^5$ | 无 |

对于 $100\%$ 的数据，$3\le n\le 2\times10^5$，$1\le q\le2\times10^5$，$u_i\neq v_i$，$x_i\neq y_i$。不存在四（及以下）元环。

## 样例 #1

### 输入

```
8 3
2 1
3 1 
4 2 
5 3
6 2
7 5
8 4
5 6
7 8
8 6
3 6```

### 输出

```
Survive
Deception
Survive
```

# AI分析结果



---

**算法分类**  
基环树分析

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   - **基环树特性**：图由一棵树加一条边形成环（环长≥5）  
   - **存活条件**：A（雷切尔）能比B（三角洲）更快到达环上的任意一点  

2. **算法流程**  
   - **找环**：通过DFS/拓扑排序/边双缩点识别基环树的环结构  
   - **预处理**：  
     - 每个点的入环点（首次到达环的位置）  
     - 点到入环点的距离  
     - 环上点之间的最短距离（利用环的对称性）  
   - **查询判断**：比较A到环的距离与B到环的距离+环上绕行距离  

3. **关键数据结构**  
   - `cir[]`标记环上点  
   - `dep[x]`存储点x到环的距离  
   - `f[x]`记录x的入环点  
   - `sw[x]`环上点的顺时针编号，用于快速计算环内距离  

4. **解决难点**  
   - **环的识别**：需避免四元环干扰，DFS回溯法可靠标记环  
   - **环上距离计算**：通过编号差取min值处理双向路径  
   - **高效预处理**：对环上每个点DFS预处理子树信息，时间复杂度O(n)  

---

### **题解评分（≥4星）**

1. **HYdroKomide（4.5星）**  
   - **亮点**：DFS找环逻辑清晰，预处理环距离用编号差优化  
   - **代码**：两次DFS完成所有预处理，查询逻辑简化为一次比较  

2. **Register_int（5星）**  
   - **亮点**：代码极简（仅80行），利用Tarjan割边思想找环  
   - **优化**：环上点编号直接用于距离计算，省去显式环存储  

3. **TernaryTree（4.5星）**  
   - **亮点**：官方题解，深度优先搜索预处理环信息  
   - **教学性**：注释详细，变量命名清晰，便于理解  

---

### **最优思路与技巧提炼**

1. **环识别技巧**  
   ```cpp
   void dfs1(int x, int fa) { // DFS回溯标记环
       if (vis[x]) { fd = x; return; }
       vis[x] = 1;
       for (auto v : g[x]) {
           if (v != fa) dfs1(v, x);
           if (fd) { 
               if (fd == x) fd = 0; 
               cir[x] = 1; // 标记环
               sw[x] = ++cnt; // 环编号
               break;
           }
       }
   }
   ```
   - **关键点**：回溯时标记环节点，`fd`控制标记范围  

2. **子树预处理**  
   ```cpp
   void dfs2(int old, int x, int fa) {
       f[x] = old; // old为入环点
       dep[x] = dep[fa] + 1;
       for (auto v : g[x]) 
           if (!cir[v] && v != fa) 
               dfs2(old, v, x);
   }
   ```
   - **作用**：对每个环节点为根的子树计算深度和入环点  

3. **查询判断公式**  
   ```python
   if (A到环距离) < (B到环距离 + 环上AB入环点最短距离):
       return "Survive"
   else:
       return "Deception"
   ```

---

### **同类型题与算法套路**

1. **通用解法**  
   - **基环树问题三板斧**：找环 → 子树处理 → 环上计算  
   - **类似问题**：  
     - 基环树直径计算  
     - 基环树动态规划（如P2607）  

2. **推荐题目**  
   - [P4381 Island](https://www.luogu.com.cn/problem/P4381)（基环树直径）  
   - [P2607 [ZJOI2008] 骑士](https://www.luogu.com.cn/problem/P2607)（基环树DP）  
   - [CF131D Subway](https://codeforces.com/problemset/problem/131/D)（基环树最短路）

---

### **可视化算法演示设计**

1. **动画流程**  
   - **步骤1**：展示基环树结构，红色高亮环，绿色标记子树  
   - **步骤2**：动态绘制A/B移动路径，比较到环时间  
     - A路径：当前点 → 入环点（蓝色箭头）  
     - B路径：当前点 → 入环点 → 绕环拦截（红色箭头）  
   - **步骤3**：胜负判定时播放音效（胜利：8-bit胜利旋律，失败：低沉音效）  

2. **复古风格实现**  
   ```javascript
   // Canvas绘制基环树
   function drawTree() {
       ctx.fillStyle = "#2C3E50"; // 深蓝背景
       ctx.fillRect(0, 0, canvas.width, canvas.height);
       
       // 绘制环（像素风格）
       ringNodes.forEach((node, idx) => {
           ctx.fillStyle = "#E74C3C"; // 红色环节点
           fillPixel(node.x, node.y, 8); // 8x8像素块
       });
       
       // 绘制当前查询点
       fillPixel(aNode.x, aNode.y, "#3498DB"); // A为蓝色
       fillPixel(bNode.x, bNode.y, "#E67E22"); // B为橙色
   }
   ```

3. **交互设计**  
   - **速度控制**：滑动条调节动画速度（0.5x~3x）  
   - **单步执行**：空格键步进演示关键比较步骤  
   - **音效触发**：使用Web Audio API播放8-bit音效  
     ```javascript
     function playSound(type) {
         const osc = audioCtx.createOscillator();
         osc.type = 'square'; // 方波模拟8-bit音效
         osc.frequency.setValueAtTime(type === 'win' ? 880 : 440, audioCtx.currentTime);
         osc.connect(audioCtx.destination);
         osc.start(); osc.stop(audioCtx.currentTime + 0.2);
     }
     ```

---

**核心代码片段（Register_int版）**  
```cpp
// 找环与预处理
void dfs(int x, int fa) {
    if (vis[x]) { // 发现环
        for (int p = fa; p != x; p = fa[p]) 
            cir[p] = 1, sw[p] = ++cnt;
        cir[x] = 1, sw[x] = ++cnt;
        return;
    }
    vis[x] = 1;
    for (int v : g[x]) 
        if (v != fa) dfs(v, x);
}

// 查询处理
while (q--) {
    int x, y; cin >> x >> y;
    int st = f[x], ed = f[y];
    int len = abs(sw[st] - sw[ed]);
    if (len > cnt/2) len = cnt - len;
    cout << (cir[x] || dep[x] < dep[y] + len ? "Survive" : "Deception");
}
```

---

**总结**  
本题解通过基环树的特性，将问题转化为距离比较问题。核心在于快速预处理环信息与子树深度，使每次查询可在O(1)完成。可视化设计通过像素风格和音效增强理解，适合教学演示。

---
处理用时：94.09秒
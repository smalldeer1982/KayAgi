# 题目信息

# 宋荣子的城堡

## 题目描述

saruka 有一座大大的城堡！城堡里面有 $n$ 个房间，每个房间上面都写着一个数字 $p_i$。有一天，saruka 邀请他的小伙伴 LYL 和 MagHSK 来城堡里玩耍，他们约定，如果某一个人当前站在 $i$ 号房间里，那么下一步他就要去 $p_i$ 号房间，在下一步就要去 $p_{p_i}$ 号房间。

为了增加趣味性，saruka 决定重新书写一下每个房间的 $p_i$，以满足：

- 如果从编号为 $1 \sim k$ 的某个房间走，按照规则走，必须能走回 $1$ 号房间。特别的，如果从 $1$ 号房间开始走，也要走回 $1$ 号房间。（至少走一步，如果 $p_1 = 1$，从 $1$ 走到 $1$ 也算合法）。

- 如果从编号大于 $k$ 的房间开始，按照规则走，一定不能走到 $1$ 号房间。

saruka 想知道，一共有多少书写 $p_i$ 的方案可以满足要求，答案对 $10 ^ 9 + 7$ 取模。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 10 ^ {18},1 \le k \le \min(n,8)$。

## 样例 #1

### 输入

```
5 2```

### 输出

```
54```

## 样例 #2

### 输入

```
7 4```

### 输出

```
1728```

# AI分析结果



## 唯一算法分类
数学（组合数学，凯莱定理）与快速幂

---

## 综合分析与结论
### 核心思路
题目要求将房间分为前k个与后n-k个独立的结构：
- **前k个房间**必须形成以1为根的基环内向树，每个节点都能走到1号房间。根据凯莱定理，k个节点形成有向树的方案数为k^(k-1)。
- **后n-k个房间**需构成独立连通块，方案数为(n−k)^(n−k)。

### 解决难点
1. **凯莱定理的适用性**：前k个房间形成的结构本质是有向树结构，每个节点的出边指向父节点，因此总方案数为k^(k-2) × k（选根）= k^(k-1)。
2. **大数幂运算**：由于n可达1e18，需用快速幂处理指数运算，并对底数预先取模。

### 可视化设计
- **树形结构展示**：用Canvas绘制前k个房间的树状图，根节点1高亮红色，其他节点动态生成指向父节点的箭头。
- **像素风格分割**：将屏幕分为左右两块，左区用8位风格展示前k个房间的树形连接（绿色线条），右区用随机线条展示后n-k个房间的独立连接（蓝色线条）。
- **音效触发**：每次完成一个区域的计算时播放不同音效（前k区用清脆音，后区用低沉音）。

---

## 题解清单（4星及以上）
1. **zzw4257（4星）**  
   - 亮点：直观图解分治思想，明确拆分两个区域的计算。
2. **NaVi_Awson（5星）**  
   - 亮点：详细推导基环内向树与凯莱定理的关系，代码清晰。
3. **Haphyxlos（4星）**  
   - 亮点：简洁的公式推导与代码实现，适合快速理解。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL MOD = 1e9 + 7;

LL qpow(LL a, LL b) {
    LL res = 1;
    a %= MOD;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    LL n, k;
    cin >> n >> k;
    LL part1 = qpow(k, k - 1);
    LL part2 = qpow((n - k) % MOD, n - k);
    cout << (part1 * part2) % MOD;
    return 0;
}
```

---

## 同类型题目推荐
1. **P4981 父子**：凯莱定理直接应用，计算生成树方案。
2. **P2606 排列计数**：组合数学与递推结合的分治问题。
3. **P1365 构造完全图**：分块处理边权方案数。

---

## 个人心得摘录
- **凯莱定理的顿悟**：意识到前k个房间的结构等价于有向树后，问题迎刃而解。
- **模运算陷阱**：处理(n−k)时需先取模，否则快速幂会溢出。

---

## 可视化算法演示（像素风格示例）
```html
<canvas id="demo" width="800" height="400"></canvas>
<script>
const canvas = document.getElementById('demo');
const ctx = canvas.getContext('2d');
// 前k区（绿色树结构）
function drawTree(k) {
    ctx.fillStyle = '#00FF00';
    // 绘制根节点1
    ctx.fillRect(50, 200, 20, 20);
    // 动态生成子节点箭头...
}
// 后n-k区（蓝色随机连接）
function drawGraph(nk) {
    ctx.fillStyle = '#0000FF';
    // 随机生成节点与连线...
}
// 音效触发
function playSound(type) {
    const audio = new Audio(type === 'front' ? 'ping.wav' : 'pong.wav');
    audio.play();
}
// 初始化动画
function animate() {
    ctx.clearRect(0, 0, 800, 400);
    drawTree(2); // 示例k=2
    drawGraph(3); // 示例n-k=3
    requestAnimationFrame(animate);
}
animate();
</script>
```  
- **交互设计**：按空格键切换自动/手动模式，方向键调整动画速度。
- **音效设计**：使用8位音效库，树完成时播放胜利旋律，错误连接时播放警报声。

---
处理用时：81.72秒
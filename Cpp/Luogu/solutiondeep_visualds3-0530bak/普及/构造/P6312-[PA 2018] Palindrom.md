# 题目信息

# [PA 2018] Palindrom

## 题目描述

**译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/)  Runda 3 [Palindrom](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/pal/)**

**请特别注意本题的内存限制。**

给出一个字符串，请你判断其是否为回文串。

回文串是指从左往右读与从右往左读完全相同。

## 说明/提示

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据，保证字符串长度不超过 $2\times 10^7$。

您可以假设在任何测试数据中都有 $n>0$ 或者 $n=0$。

感谢 @[Infinite_Eternity](/user/897776) 提供的测试数据！


## 样例 #1

### 输入

```
5
kajak```

### 输出

```
TAK```

## 样例 #2

### 输入

```
0
kanu```

### 输出

```
NIE```

# AI分析结果



## 算法分类
哈希算法

---

## 题解思路、算法要点与解决难点

### 核心思路
所有题解均采用**在线双哈希**方法，在读取字符时同步计算正序与逆序哈希值，避免存储整个字符串。  
- **关键公式**：  
  - 正序哈希：`hash1 = hash1 * base + ch`（高位在前）  
  - 逆序哈希：`hash2 = hash2 + ch * pow(base, len)`（低位在前）  
- **双模数优化**：离散小波变换°的题解使用两组 `(base, mod)` 降低哈希冲突概率  
- **动态幂计算**：维护 `base` 的当前幂次 `pow(base, len)`，每次乘 `base` 更新  

### 解决难点
1. **空间限制**：无法存储 2e7 长度的字符串，必须逐字符处理  
2. **哈希冲突**：通过双哈希组合（如 `BASE1=13331, MOD1=1e9+7` 和 `BASE2=131, MOD2=1e9+9`）降低误判率  
3. **逆序哈希计算**：通过动态维护 `base^len` 实现逆序的逐位叠加  

---

## 题解评分 (≥4星)

### 1. 离散小波变换°（★★★★★）
- **亮点**：  
  - 双哈希实现，稳健性极高  
  - 代码简洁高效，变量命名清晰  
  - 处理输入时跳过非字母字符，鲁棒性强  
- **代码片段**：  
  ```cpp
  h1 = (1ll * h1 * BASE1 + c) % MOD1;    // 正序哈希
  h2 = (1ll * c * base1 + h2) % MOD1;    // 逆序哈希
  base1 = 1ll * base1 * BASE1 % MOD1;    // 维护 base^len
  ```

### 2. zgy_123（★★★★☆）
- **亮点**：  
  - 单哈希简化实现，适合快速理解  
  - 明确推导哈希公式，适合教学  
- **改进点**：未使用双哈希，理论上有冲突风险  

### 3. Andy_WA（★★★★☆）
- **亮点**：  
  - 详细注释解释哈希计算逻辑  
  - 使用 `unsigned long long` 避免溢出  
- **代码片段**：  
  ```cpp
  Hash1 = (Hash1 * Bace + x) % Mod;      // 正序递推
  Hash2 = (Hash2 + x * power) % Mod;     // 逆序叠加
  power = power * Bace % Mod;            // 维护幂次
  ```

---

## 最优思路与技巧提炼

### 关键技巧
1. **双哈希抗冲突**：两组独立哈希参数交叉验证  
2. **动态幂维护**：避免预计算 `base^len` 的空间开销  
3. **逐字符处理**：无需存储字符串，适应极端内存限制  

### 代码实现核心
```cpp
const int BASE1 = 13331, MOD1 = 1e9 + 7;
const int BASE2 = 131,   MOD2 = 1e9 + 9;
int h1 = 0, h2 = 0, g1 = 0, g2 = 0, b1 = 1, b2 = 1;

while (读取字符 ch) {
    h1 = (h1 * BASE1 + ch) % MOD1;     // 正序哈希1
    h2 = (h2 + ch * b1) % MOD1;       // 逆序哈希1
    b1 = (b1 * BASE1) % MOD1;         // 更新 base1^len

    g1 = (g1 * BASE2 + ch) % MOD2;    // 正序哈希2
    g2 = (g2 + ch * b2) % MOD2;       // 逆序哈希2
    b2 = (b2 * BASE2) % MOD2;         // 更新 base2^len
}
if (h1 == h2 && g1 == g2) return "TAK";
```

---

## 同类型题与算法套路

### 类似问题特征
- **大字符串处理**：如最长回文子串（Manacher算法）、循环节检测  
- **空间敏感场景**：如流式数据统计、滑动窗口哈希  

### 推荐题目
1. **P3370** 【模板】字符串哈希  
2. **P3805** 【模板】Manacher算法  
3. **P1309** 瑞士轮（滚动数组优化）  

---

## 可视化与算法演示

### 动画设计
1. **像素风格界面**：  
   - 字符流以 8-bit 字体从左到右滚动进入屏幕  
   - 正序哈希（绿色）和逆序哈希（红色）进度条实时更新  
2. **关键步骤高亮**：  
   - 当前字符显示为闪烁方块，下方标注 ASCII 值  
   - 哈希公式在屏幕顶部以像素艺术公式呈现，当前计算部分高亮黄色  
3. **音效与反馈**：  
   - 每读入字符播放 "bleep" 音效  
   - 哈希匹配时播放胜利音效（8-bit 小调）  
   - 不匹配时播放低沉错误音  

### 交互功能
- **步进控制**：空格键暂停/继续，左右箭头单步前进/后退  
- **模式切换**：按 'A' 键切换自动播放（速度可调）  
- **双哈希对比**：按 'D' 键分屏显示两组哈希计算过程  

---

## 个人心得摘录
> "最初尝试直接反转字符串导致 MLE，改用哈希后空间骤降。调试中发现单哈希在极端数据下冲突，最终双哈希方案才稳定通过。"  
> —— banned_xiejiayun 的调试教训  

> "`base` 和 `mod` 的选择需要足够大且互质，否则容易碰撞。实践中用质数组合效果最佳。"  
> —— Hulless_barley 的哈希参数经验  

---

## 完整代码（离散小波变换°版）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long u64;
char c; 
int h1, h2, g1, g2, base1 = 1, base2 = 1;
const int BASE1 = 13331, MOD1 = 1e9 + 7;
const int BASE2 = 131,   MOD2 = 1e9 + 9;

int main() {
    while (!isalpha(c = getchar())); // 跳过非字母前缀
    do {
        h1 = (1ll * h1 * BASE1 + c) % MOD1;
        h2 = (1ll * c * base1 + h2) % MOD1;
        base1 = 1ll * base1 * BASE1 % MOD1;

        g1 = (1ll * g1 * BASE2 + c) % MOD2;
        g2 = (1ll * c * base2 + g2) % MOD2;
        base2 = 1ll * base2 * BASE2 % MOD2;
    } while (isalpha(c = getchar()));
    
    puts((h1 == h2 && g1 == g2) ? "TAK" : "NIE");
    return 0;
}
```

---
处理用时：95.18秒
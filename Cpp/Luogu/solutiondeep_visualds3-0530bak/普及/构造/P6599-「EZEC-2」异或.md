# 题目信息

# 「EZEC-2」异或

## 题目描述

有 $T$ 组询问，每次给定两个正整数 $n,l$，   

你需要构造一个长度为 $l$ 的正整数序列 $a$（编号从 $1$ 至 $l$），   

且满足 $\forall i\in[1,l]$，都有 $a_i\in[1,n]$。

求：

$$\sum_{i=1}^l\sum_{j=1}^{i-1}a_i\oplus a_j$$

的最大值。

为了避免答案过大，对于每组询问，只需要输出这个最大值对 $10^9+7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**   
当 $n=2,l=3$，$a$ 取 $\{1,2,1\}$ 的任一排列时可以得到最大值，为 $(1\oplus2)+(1\oplus1)+(2\oplus1)=6$，易证明此时原式有最大值。

---
**【数据规模与约定】**
| 测试点编号 | $T\le$ | $n\le$ | $l\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim5$ | $1$ | $10$ | $5$ |
| $6$ | $5\times 10^5$ | $10^{12}$ | $2$ |
| $7$ | $5\times 10^5$ | $10^{12}$ | $3$ |
| $8\sim10$ | $5\times 10^5$ | $10^{12}$ | $10^5$ |

对于 $100\%$ 的数据，满足 $1\le T\le 5\times10^5$，$1\le n\le 10^{12}$，$2\le l \le 10^5$。


---
**【提示】**

1. 「$\oplus$」是按位异或符号。如果您不知道什么是按位异或，可以参考[这里](https://oi-wiki.org/math/bit/#_1)。
2. 取模是一种运算，$a$ 对 $b$ 取模代表将 $a$ 赋值为 $a$ 除以 $b$ 所得到的余数。  
在 C++ / Python 中的取模符号为 `%`，在 Pascal 中的取模符号为 `mod`。
3. $\sum$ 是求和符号。如果您不知道什么是 $\sum$ 符号，可以参考[这里](https://baike.baidu.com/item/∑/1233796?fr=aladdin)。
4. 请注意数据的读入输出对程序效率造成的影响。

## 样例 #1

### 输入

```
1
2 3
```

### 输出

```
6```

## 样例 #2

### 输入

```
2
114 514
1919 180
```

### 输出

```
8388223
16580700```

# AI分析结果



### 算法分类
**贪心算法**、**位运算**

### 题解思路与核心难点
**核心思路**：  
1. **按位分析贡献**：异或运算的每一位独立，总贡献是各位贡献的和。  
2. **最大化每位的贡献**：对于第k位，若有x个数的该位为1，则贡献为 $x \cdot (l-x) \cdot 2^k$。当x接近 $l/2$ 时，贡献最大。  
3. **构造方法**：取最大的二进制位m（满足 $m \le n$），构造 $\lfloor l/2 \rfloor$ 个m和剩余的数取m-1，保证所有低位贡献最大化。

**难点对比**：  
- **正确性验证**：需确保构造的数值不超过n，且每位贡献计算正确。  
- **高效计算**：直接遍历二进制位或使用位运算找到最大位，避免浮点精度问题。

### 题解评分（≥4星）
1. **李白莘莘学子**（4星）：  
   - **亮点**：清晰推导每位的贡献公式，代码结构简明。  
   - **不足**：循环初始值错误，导致最大二进制位未被处理。  
   - **关键代码**：  
     ```cpp
     long long big=1ll<<40;
     while(big) {
         big>>=1;
         if(n<big) continue;
         ans+=big*mid*(l-mid);
     }
     ```

2. **君のNOIP**（4星）：  
   - **亮点**：预处理幂次和，快速计算总和。  
   - **不足**：依赖浮点计算log2，可能存在精度问题。  
   - **关键代码**：  
     ```cpp
     slg[i] = (1 << (i+1)) - 1;
     ans = slg[(int)log2(n)] * (l/2 * (l - l/2)) % mod;
     ```

3. **一只书虫仔**（5星）：  
   - **亮点**：使用位运算准确找到最大二进制位，代码可靠高效。  
   - **关键代码**：  
     ```cpp
     long long now = (n == 0 ? 0 : 1LL << (63 - __builtin_clzll(n)));
     while(now) {
         ans += now * (l/2) * (l - l/2);
         now >>= 1;
     }
     ```

### 最优思路提炼
1. **贪心构造**：选取最大二进制位m，构造 $\lfloor l/2 \rfloor$ 个m和剩余的数取m-1。  
2. **位运算优化**：通过 `__builtin_clzll` 快速定位最大位，避免浮点误差。  
3. **贡献累加**：遍历所有有效二进制位，累加每位的最大贡献。

### 同类型题与算法套路
- **按位贪心**：如[P2114 [NOI2016] 优秀的拆分](https://www.luogu.com.cn/problem/P2114)。  
- **异或性质**：如[P6102 [EER2] 直接自然溢出啥事没有](https://www.luogu.com.cn/problem/P6102)。  
- **最大贡献构造**：如[CF1553C Penalty](https://codeforces.com/problemset/problem/1553/C)。

### 推荐题目
1. [P2114 起床困难综合症](https://www.luogu.com.cn/problem/P2114)  
2. [P6102 线性代数](https://www.luogu.com.cn/problem/P6102)  
3. [CF1763B Incinerate](https://codeforces.com/problemset/problem/1763/B)

### 个人心得
- **调试关键**：注意最大二进制位的正确计算，避免因初始值错误导致漏算。  
- **构造验证**：通过构造极例（如n为2的幂次）验证代码正确性。

### 可视化算法演示
**动画设计**：  
1. **位遍历动态显示**：  
   - **像素风格**：用方格表示二进制位，高亮当前处理的位（如红色表示当前位贡献）。  
   - **步进控制**：单步展示每位贡献的累加过程，背景播放8-bit音效。  
   - **颜色标记**：绿色表示有效位（贡献计入），灰色表示无效位。  

**示例代码（JS片段）**：  
```javascript
// 伪代码：绘制二进制位贡献
function drawBits(n, l) {
    let m = 1 << Math.floor(Math.log2(n));
    let total = 0;
    while (m > 0) {
        if (m <= n) {
            drawHighlight(m); // 高亮当前位
            total += m * Math.floor(l/2) * (l - Math.floor(l/2));
            playSound('bit'); // 播放音效
        }
        m >>= 1;
    }
    return total % MOD;
}
```

**交互设计**：  
- **速度调节**：滑动条控制动画速度，展示每位贡献的实时计算。  
- **自动演示**：AI自动运行，并显示当前贡献公式（如 $2^k \cdot x \cdot (l-x)$）。

---
处理用时：582.95秒
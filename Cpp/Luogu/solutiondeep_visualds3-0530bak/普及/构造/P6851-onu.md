# 题目信息

# onu

## 题目背景

小 C 和小 D 是好朋友。他们正在尝试一种全新的牌类游戏——onu！

## 题目描述

为了增加一点趣味性，小 C 和小 D 每人买了 $v$ 颗糖用来当作筹码。

onu 的规则是这样的：

游戏共 $m$ 轮，由两人进行，一位先手，一位后手。在这里，我们默认先手的玩家是小 C，而后手的玩家是小 D。

在最开始时，小 C 会得到 $m$ 张牌，每张牌有其对应的花色、点数。而小 D 会得到 $n$ 张牌。

每一轮开始时，小 C 会打出一张牌，放在桌面上展示给小 D 看。

在此之后，小 D 需要跟牌，即打出他手上的一张牌，且该张牌必须满足其花色与小 C 打出的牌相同。若小 D 没有满足条件的牌或者是他**选择弃权（也就是说，可以选择当前回合是否打出牌）**，弃掉小 C 打出的牌后跳过该轮，视为小 D 败。

在小 D 打出满足要求的牌后，进行一次拼点，也即比较小 C 和小 D 打出的牌的点数：如果小 D 出的牌的点数**大于等于**小 C 的牌的点数，则小 D 胜，否则小 D 败。容易知道，这样不会出现平局的情况。

最后，胜的一方会从败的一方拿走 $c$ 颗糖，且双方均需弃掉打出的牌，并会**再从商店买等于自己打出的牌的点数颗糖**。例如小 C 和小 D 打的点数分别是 $3$ 和 $5$，那么小 C 会去购买 $3$ 颗糖，小 D 购买 $5$ 颗。

为了不破坏两人间的友好关系，不出现一方被另一方完全赢光的情况，他们在最开始买糖时，已经约定好了 $v \ge c \times m$。

现在，小 D 通过一些神秘手段，知道了小 C 在这 $m$ 轮中打出的所有牌，他希望在 $m$ 轮游戏进行之后，让自己的糖数尽量多。你可以帮他找到最优的方案吗？

## 说明/提示

#### 「样例 1 解释」

以 $(a, b)$ 来表示一张花色为 $a$，点数为 $b$ 的牌。

一开始，小 D 有 $4$ 颗糖。小 C 会依次打出 $(1, 6), (3, 5), (1, 4)$ 三张牌。

一种最优的方案是：

第一轮，小 C 打出第一张牌 $(1, 6)$，小 D 打出第二张牌 $(1, 2)$，小 D 负，被拿走 $1$ 颗糖，购买 $2$ 颗糖。此时其有 $5$ 颗糖。

第二轮，小 C 打出 $(3, 5)$，小 D 打出 $(3, 5)$，由于点数**大于等于**小 C 的牌，所以小 D 胜，拿到 $1$ 颗糖，购买 $5$ 颗糖。此时其有 $11$ 颗糖。

第三轮，小 C 打出 $(1, 4)$。由于小 D 在第一轮已经打出过第二张牌 $(1, 2)$ 了，所以没有牌能打，输出 $-1$ 并判小 D 负，被拿走 $1$ 颗糖，此时其有 $10$ 颗糖。

#### 「样例 2 解释」

最开始有 $5$ 颗糖。

第一轮时小 C 打出 $(1, 8)$，小 D 选择弃权，败，于是剩下了 $5 - 1 = 4$ 颗糖；

第二轮时小 C 打出 $(1, 4)$，小 D 打出 $(1, 5)$，胜，得到 $5 + 1$ 颗糖，故最终小 D 有 $10$ 颗糖。

----

#### 「Special Judge 说明」

**请认真阅读输出格式**。

每个测试点仅有 $0$ 分和满分的区别。如果你的输出出现了以下情况，将会被判为 $0$ 分：

- 输出格式不符，如没有正确换行，输出了一些奇奇怪怪的字符等。
- 输出的最优糖果数与标准答案不同。
- 打牌的方案不合法，即不能打出已经弃掉的牌，也不能打出花色与小 C 打出的牌不相同的牌。
- 按照你所输出的方案打完牌后，小 D 的剩余糖果数与你第一行所输出的数字不同。

---

#### 「数据范围」

**本题采用捆绑测试**。

- Subtask 1(10 points)：$n, m \le 5$；
- Subtask 2(30 points)：$n, m \le 1000$；
- Subtask 3(20 points)：$c = 0$；
- Subtask 4(20 points)：$a _i = 1$；
- Subtask 5(20 points)：无特殊限制。

所有数据保证 $1 \le n, m, a _i, b _i\le 10 ^5$，$0 \le c \le 10 ^5$，$c \times m \le v \le 10 ^{12}$。

## 样例 #1

### 输入

```
3 3 1 4
3 5
1 2
2 6
1 6
3 5
1 4```

### 输出

```
10
2
1
-1```

## 样例 #2

### 输入

```
1 2 1 5
1 5
1 8
1 4```

### 输出

```
10
-1
1```

# AI分析结果



# 算法分类与题解分析

## 唯一算法分类
贪心算法

---

## 题解思路、算法要点与解决难点

### 核心思路
1. **分组处理**：按花色分组，每个花色独立处理。
2. **排序策略**：将小C和小D的同花色牌按点数排序（小D从大到小，小C从小到大）。
3. **贪心匹配**：
   - **赢的回合**：用当前最大的牌尽可能赢小C最小的可行牌（类似田忌赛马）。
   - **输的回合**：剩余未匹配的小C牌用小D的最小牌应对，减少损失。
4. **输赢收益计算**：
   - 赢：获得 `c + 点数` 的糖。
   - 输但出牌：获得 `点数 - c` 的糖（比弃权多 `点数`）。

### 解决难点
1. **花色分组与排序**：需高效处理不同花色的牌，确保每组独立操作。
2. **双指针匹配**：需维护两个指针分别遍历小C和小D的牌，保证线性时间复杂度。
3. **剩余牌处理**：未匹配的小C牌需用小D的剩余牌覆盖，避免遗漏。

---

## 题解评分（≥4星）

### 1. vectorwyx（★★★★☆）
- **亮点**：代码结构清晰，拆分问题为独立子问题，优先处理赢的情况，剩余牌处理逻辑严谨。
- **核心代码**：
  ```cpp
  sort(sc[i].begin(), sc[i].end(), cmp); // 小C牌排序
  sort(sd[i].begin(), sd[i].end(), cmp); // 小D牌排序
  for (小C的牌) {
      while (小D的牌可赢) { 匹配并计算收益 }
  }
  ```

### 2. yangwenbin（★★★★☆）
- **亮点**：分离赢和输的逻辑，使用 `vis` 数组标记已用牌，易于理解。
- **核心代码**：
  ```cpp
  // 赢的匹配
  if (D牌 >= C牌) { sum += D点数 + c; }
  // 输的匹配
  else { sum += D点数 - c; }
  ```

### 3. hensier（★★★★☆）
- **亮点**：默认全弃权后修正，通过两轮遍历优化收益，处理剩余牌逻辑清晰。
- **核心代码**：
  ```cpp
  ans[tc[i][j].id] = td[i][b].id; // 修正未匹配的牌
  ansv += td[i][b].val - c; // 计算输的收益
  ```

---

## 最优思路或技巧提炼

### 关键技巧
1. **分治贪心**：按花色分组后，每个子问题独立解决，避免全局干扰。
2. **双指针贪心匹配**：
   - 小D的牌降序，小C的牌升序，优先用大牌赢小牌。
   - 剩余小C牌用小D的最小牌应对。
3. **收益修正**：默认全弃权后，通过遍历修正为最优出牌方案。

---

## 类似题目与算法套路

### 同类型题
- **田忌赛马（P1650）**：贪心策略匹配最优对手。
- **任务调度**：优先处理高收益任务，剩余资源分配低收益。

### 推荐题目
1. [P1650 田忌赛马](https://www.luogu.com.cn/problem/P1650)
2. [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)（贪心排序）
3. [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)（分组贪心）

---

## 可视化与算法演示

### 核心逻辑演示
1. **初始化**：
   - 将小C和小D的牌按花色分组，显示为不同颜色的卡片堆。
   - 每组牌按点数排序（小D降序，小C升序）。

2. **匹配过程**：
   - **赢的回合**：高亮小D的大牌与小C的小牌，匹配后标记为绿色。
   - **输的回合**：高亮小D的小牌与小C的大牌，标记为红色。
   - **弃权**：灰色标记未匹配的小C牌。

3. **动态更新**：
   - 实时显示当前糖果数变化（`+c`、`-c`、`+点数`）。
   - 用指针动画展示双指针移动过程。

### 复古像素风格设计
- **颜色方案**：
  - 小D牌：蓝色像素块（赢为亮蓝，输为深蓝）。
  - 小C牌：红色像素块（被赢为暗红，未被处理为亮红）。
- **音效**：
  - 匹配成功：8-bit 上升音调。
  - 匹配失败：短促“哔”声。
- **Canvas 动画**：
  - 卡片堆以网格排列，匹配时飞出动画到结果区。
  - 背景循环播放低音调芯片音乐。

---

## 代码实现（关键片段）

### 贪心匹配核心逻辑
```cpp
for (int color : 所有花色) {
    sort(D[color].begin(), D[color].end(), greater<>()); // 小D降序
    sort(C[color].begin(), C[color].end()); // 小C升序
    int i = 0, j = 0;
    while (i < C[color].size() && j < D[color].size()) {
        if (D[color][j] >= C[color][i]) { // 赢
            ans += D[color][j] + c;
            match(C[color][i], D[color][j]);
            i++; j++;
        } else { // 无法赢，跳过小C的牌
            i++;
        }
    }
    // 处理剩余小C牌
    while (i < C[color].size()) {
        ans -= c; // 弃权
        i++;
    }
}
```

---

## 个人心得摘录
- **调试教训**：初始未按花色分组直接排序，导致不同花色牌错误匹配。
- **优化顿悟**：两轮遍历（先赢后输）比混合处理更清晰，减少边界条件错误。

---

通过以上分析，结合贪心策略和分组处理，可高效解决本题，并通过可视化加深对双指针匹配的理解。

---
处理用时：87.42秒
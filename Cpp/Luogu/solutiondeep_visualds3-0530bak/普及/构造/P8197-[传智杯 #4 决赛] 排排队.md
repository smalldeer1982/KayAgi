# 题目信息

# [传智杯 #4 决赛] 排排队

## 题目描述


cyq 在 tsyz 担任了体育老师，负责排队一事。

在 tsyz 中，每个人都有一个身高 $a_{i}$，并且只有**相邻**的两个人可以交换位置。cyq 带领的队伍有 $n$ 个人,他现在要给大家排队形。

给定一个长度为 $n$ 的序列 $b$，一个队形被认为美观，当且仅当对于所有的 $i = 1, 2, 3, \dots n$，$a_{i} =b_{i}$。cyq 想知道，他能否让大家的队形变得美观，并且交换相邻两个人的次数不超过 $n^2$ 次。这个问题把 $cyq$ 难住了，请你帮他来解决这个问题，如果存在合法的交换方案，输出 `YES`，并给出一组方案；否则，输出 `NO`。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1\leq T \leq 10$，$1\leq n \leq 10^3$，$1\leq a_{i},b_{i}\leq 10^9$，且各个测试点 $n$ 之和不超过 $1000$，即 $\sum n\leq 10^3$。

### 提示
- 请注意大量的输出输出对程序效率造成的影响，不要频繁刷新缓冲区。例如，对于使用 `std::cout` 的 C++ 选手，请使用 `'\n'` 而不是 `std::endl` 来换行；对于 java 选手，请选择高效率的输出方式，如使用 PrintWriter；python 选手可以正常的使用 print 而无需考虑效率问题。
- 请按照输出格式的要求输出您的答案，如果格式不符合要求，返回的评测信息将可能是 TLE、RE、WA、UKE 等任何结果。

### C++ 语言的高效输出样例
```cpp
#include <iostream>
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(0);
  for (int i = 1; i <= 5; ++i) {
    std::cout << i << '\n'; // 注意这里不能使用 std::endl
  }
}
```

### Java 语言的高效输出样例
```java
import java.io.PrintWriter;

public class Main {
  public static void main(String[] args) {
    PrintWriter ot = new PrintWriter(System.out);
    for (int i = 1; i <= 5; ++i) {
      ot.println(i);
    }
    ot.flush(); // 请务必保证在程序结束时运行本条语句，否则在缓冲区的内容无法输出
  }
}

## 样例 #1

### 输入

```
3
4
1 2 2 3
3 2 2 1
3
1 2 3
1 2 4
1
1
1
```

### 输出

```
YES
4 3
2 3
1 2
3 2
3 4
0 0
NO
YES
0 0
```

# AI分析结果



## 算法分类
**构造、选择排序**

---

## 题解思路与难点分析

### 核心逻辑
1. **可行性判断**：若两数组排序后元素不同则无解
2. **构造交换方案**：对每个位置i，找到a中第一个等于b[i]的元素，将其通过相邻交换移动到i的位置

### 解决难点
- **重复元素处理**：选择后出现的元素不会影响后续构造的正确性
- **交换次数控制**：每次移动最多消耗n次交换，总次数满足n²约束

### 关键实现
- 排序后用双重循环定位目标元素
- 使用swap操作同步维护实际数组状态
- 输出交换步骤时注意索引偏移问题

---

## 题解评分（≥4星）

### 一扶苏一（★★★★★）
- **亮点**：使用标准库排序高效判重，代码结构清晰，处理索引从1开始更直观
- **优化**：数组填充方式避免越界，输出格式处理得当

### 沉石鱼惊旋（★★★★☆）
- **亮点**：详细分析冒泡排序次数上限，提供完整数学证明
- **不足**：代码索引从0开始可能增加理解成本

### dingshengyang（★★★★☆）
- **亮点**：注释命名清晰，在交换时同步维护数组状态
- **特色**：用位运算优化判断逻辑，增强代码紧凑性

---

## 最优思路提炼

### 核心技巧
**贪心构造 + 选择排序思想**
1. 按顺序固定每个位置的目标元素
2. 每次从当前位置向后寻找首个匹配元素
3. 通过冒泡式相邻交换完成移动

### 思维突破点
- **元素可交换性**：只要两数组元素构成相同，总能通过有限交换达成目标
- **操作无关性**：后序交换不会破坏已构造好的前缀部分

---

## 同类题目推荐
1. P1177 【模板】快速排序（考察排序基础）
2. P1908 逆序对（相邻交换次数计算）
3. P1966 [NOIP2013 提高组] 火柴排队（类似元素匹配构造）

---

## 可视化设计

### 动画方案
**网格化数组展示**  
1. 初始显示a、b两数组分屏对比
2. 高亮当前处理位置i（蓝色）与目标元素j（红色）
3. 交换时用箭头动画表示元素移动
4. 底部统计实时交换次数

### 交互功能
- **速度调节**：滑块控制交换动画速度（0.5x~5x）
- **单步执行**：按空格键逐次执行交换
- **音效反馈**：元素匹配时播放"ding"，交换时播放"blip"

### 像素风格
- 16色调色板（NES风格）
- 8-bit音效（交换音效、完成音效）
- 过关特效：成功时像素烟花绽放

---

```cpp
// 核心代码片段（一扶苏一题解）
for (int i = 1; i <= n; ++i) if (a[i] != b[i]) {
    for (int j = i; j <= n; ++j) if (a[j] == b[i]) {
        for (int k = j; k > i; --k) {
            std::swap(a[k], a[k - 1]);
            std::cout << k << ' ' << k - 1 << '\n';
        }
        break;
    }
}
```

---

## 调试心得摘录
> "首次实现时未及时swap数组导致后续匹配错误，必须知行合一同步维护数组状态" —— 沉石鱼惊旋  
> "注意测试n=1的边界情况，此时无需任何交换直接输出0 0" —— Eason2009

---

## 扩展思考
当允许非相邻交换时，问题可转化为最小交换次数的环分解问题，但本题约束条件使得贪心策略成为最优解。

---
处理用时：64.84秒
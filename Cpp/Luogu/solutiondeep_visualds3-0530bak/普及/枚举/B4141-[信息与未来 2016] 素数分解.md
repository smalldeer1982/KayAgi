# 题目信息

# [信息与未来 2016] 素数分解

## 题目描述

素数，又称质数，是指除 $1$ 和其自身之外，没有其他约数的正整数。例如，$2,3,5,7,13$ 都是质数，而 $4,9,12,18$ 则不是。

虽然素数不能分解成除 $1$ 和其自身之外整数的乘积，但却可以分解成更多素数的和。你需要编程求出一个正整数最多能分解成多少个互不相同的素数的和。

## 说明/提示

### 样例 $\textbf 1$ 解释
$21=2+3+5+11$。
### 数据范围
$10\le n\le 200$。

**保证有解。**
> 本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
21```

### 输出

```
4```

## 样例 #2

### 输入

```
128```

### 输出

```
9```

# AI分析结果



## 算法分类
DFS + 剪枝

---

## 题解思路与核心难点

### 核心思路
所有题解均采用**DFS + 剪枝**策略：通过遍历素数表，对每个素数选择「取」或「不取」，累加和等于目标值时更新最大个数。关键优化点在于对素数表降序排列，优先选大素数以提前触发剪枝条件 `sum > n`，减少无效递归。

### 算法要点
1. **素数生成**：yedalong 使用埃氏筛法生成素数，时间复杂度更低；lizhixun 逐个判断素数，效率较低。
2. **DFS 剪枝**：两种解法均通过 `if (sum > n) return;` 提前终止无效分支。
3. **降序优化**：yedalong 对素数表降序排列，让大数优先参与累加，更快触发剪枝条件。

### 解决难点
- **组合爆炸问题**：200 以内素数共 46 个，直接暴力枚举组合数量级为 O(2^46)。通过降序排列 + 剪枝，将实际递归次数降至可接受范围。
- **正确性保障**：DFS 保证所有可能的素数组合均被遍历，最终必能找到最优解（题目保证有解）。

---

## 题解评分（≥4星）

### 题解 1：yedalong（4.5星）
- **思路清晰度**：明确筛法生成素数 + 降序排列优化。
- **代码可读性**：简洁的 DFS 结构，使用 `vector` 和排序函数。
- **优化程度**：通过降序排列显著提升剪枝效率。
- **亮点代码**：`sort(prime.begin(),prime.end(),greater<int>())` 和递归剪枝逻辑。

---

## 最优思路提炼

### 关键技巧
1. **素数降序排列**：优先选择大素数，使得累加和更快超过 `n`，减少无效递归。
2. **埃氏筛法**：高效生成素数表（时间复杂度 O(n log log n)）。
3. **DFS 剪枝逻辑**：在递归前判断 `sum + prime[now] <= n`，避免进入无意义分支。

### 思维角度
将**组合优化问题**转化为**有序搜索问题**，通过调整遍历顺序（大数优先）提升剪枝效率。

---

## 同类型题推荐
1. **P1036 [NOIP2002 普及组] 选数**（子集和判断素数）
2. **P1219 [USACO1.5] 八皇后**（DFS 剪枝经典问题）
3. **P2392 kkksc03考前临时抱佛脚**（多阶段组合优化）

---

## 可视化算法演示设计

### 核心逻辑动画
1. **像素网格展示**：用不同颜色方块表示素数，红色表示已选，灰色表示未选。
2. **当前状态显示**：实时显示累加和 `sum`、已选素数个数 `k`。
3. **递归路径高亮**：用连线表示递归树的分支（选/不选），黄色高亮当前操作节点。

### 复古游戏化效果
- **8位像素风格**：素数字符用 16x16 像素块表示，背景音乐为 8-bit 风格循环音轨。
- **音效设计**：
  - 选中素数：播放 "哔" 声效（类似 FC 游戏金币音）。
  - 触发剪枝：播放 "咔嚓" 声效（类似 FC 游戏失败音）。
- **自动演示模式**：AI 自动选择最优路径，用绿色闪烁框标记关键决策点。

### 交互控制
```html
<!-- 伪代码示例：Canvas 绘制素数方块 -->
<canvas id="prime-grid"></canvas>
<div class="control-panel">
  <button onclick="pause()">⏸️</button>
  <input type="range" id="speed" min="1" max="5">
</div>
<script>
// 初始化像素网格
const primes = [199, 197, 193, ..., 2]; // 降序排列的素数
drawGrid(primes); // 绘制初始状态

function dfsStep(now, sum, k) {
  highlight(primes[now]); // 高亮当前素数
  if (sum + primes[now] > n) playSound('clip'); // 触发剪枝音效
  // ...递归逻辑可视化
}
</script>
```

---

## 核心代码实现

### yedalong 的 DFS 函数
```cpp
void dfs(int now, int sum, int k) {
    if (now == prime.size()) { // 递归终止条件
        if (sum == n) ans = max(ans, k);
        return;
    }
    if (sum > n) return; // 剪枝
    dfs(now + 1, sum, k); // 不选当前素数
    dfs(now + 1, sum + prime[now], k + 1); // 选当前素数
}
```

### 素数生成与排序
```cpp
// 埃氏筛法生成素数
for (int i = 2; i <= 200; i++) {
    if (!is_prime[i]) {
        for (int j = 2; j * i <= 200; j++) is_prime[i * j] = 1;
        prime.push_back(i);
    }
}
sort(prime.begin(), prime.end(), greater<int>()); // 降序排列优化
```

---

## 个人心得摘录
> "优先选大的质数，这样剪枝后不合法的情况被排除的时间少很多。"  
> —— 通过调整遍历顺序，将最可能触发剪枝的条件前置，极大优化搜索效率。

---
处理用时：75.25秒
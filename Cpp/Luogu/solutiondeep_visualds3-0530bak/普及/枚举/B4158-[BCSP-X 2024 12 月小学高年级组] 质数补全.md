# 题目信息

# [BCSP-X 2024 12 月小学高年级组] 质数补全

## 题目描述

Alice 在纸条上写了一个质数，第二天再看时发现有些地方污损看不清了。

- 在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数称为质数

请你帮助 Alice 补全这个质数，若有多解输出数值最小的，若无解输出 $-1$。

例如纸条上的数字为 $\tt{1*}$（$\tt{*}$ 代表看不清的地方），那么这个质数有可能为 $11, 13, 17, 19$，其中最小的为 $11$。

## 说明/提示

### 样例 3-6

参考附件中的样例。

### 数据范围

$|s|$ 代表 $s$ 串的长度，对于所有数据，$1 \leq t \leq 10, 1 \leq |s| \leq 7$，$s$ 中仅包含数字或者 $\tt{*}$，并且保证首位不是 $\tt{*}$ 或者 $0$。

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | $\mid s\mid$ | 特殊性质 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $35$ | $\leq 7$ | $s$ 中没有 $\tt{*}$ |  |
| $2$ | $30$ | $\leq 4$ |  |  |
| $3$ | $24$ | $\leq 7$ | $s$ 中至多包含 $1$ 个 $\tt{*}$ | $1$ |
| $4$ | $11$ | $\leq 7$ |  | $1,2,3$ |


## 样例 #1

### 输入

```
10
1*
3**
7**
83*7
2262
6**1
29*7
889*
777*
225*```

### 输出

```
11
307
701
8317
-1
6011
2917
8893
-1
2251```

## 样例 #2

### 输入

```
10
4039***
2***5*5
4099961
25**757
7***0**
1***00*
41811*9
6***0*7
8***1**
6561*59```

### 输出

```
4039019
-1
4099961
2509757
7000003
1000003
4181129
6000047
8000101
6561259```

# AI分析结果



---

**唯一算法分类**：深度优先搜索（DFS）

---

### **综合分析与结论**

#### **题解思路与核心难点**
- **核心思路**：通过DFS枚举所有可能的星号替换情况，生成候选数字，按数值递增顺序检查是否为质数。找到第一个解即为最小值。
- **解决难点**：
  1. **数值顺序生成**：DFS按从左到右顺序替换星号为0-9，保证候选数从小到大。
  2. **剪枝优化**：一旦找到质数，立即终止后续递归。
  3. **边界处理**：首位不为0，字符串末尾添加空格标记结束。
- **关键数据结构**：无特殊结构，仅用字符串处理替换和递归。

#### **可视化设计思路**
- **动画方案**：
  - **像素风格**：用8位网格展示字符串，星号替换时高亮当前位，显示候选数值。
  - **步进控制**：用户可逐帧观察替换过程，自动播放时按数值递增生成候选。
  - **音效提示**：替换时播放按键音，找到解时播放成功音效，无解时失败音效。
- **AI自动演示**：模拟DFS递归路径，优先选择更小的替换值，快速定位解。

---

### **题解清单 (4星)**

#### **题解：_Deer_Peach_（4星）**
- **关键亮点**：
  1. 通过DFS按顺序生成候选，确保找到最小质数。
  2. 末尾添加空格简化终止条件判断。
  3. 剪枝优化提升效率。
- **改进点**：变量命名可读性（如`nu`改为`num`），字符串处理可优化。

---

### **代码实现与核心逻辑**

#### **核心代码片段**
```cpp
void dfs(string x, int id) {
    if (flag) return; // 剪枝
    if (x[id] == ' ') { // 终止条件
        int num = convert(x);
        if (is_prime(num)) {
            cout << num << endl;
            flag = true;
        }
        return;
    }
    if (x[id] == '*') {
        for (int i = 0; i < 10; i++) {
            x[id] = '0' + i;
            dfs(x, id + 1);
        }
    } else {
        dfs(x, id + 1);
    }
}
```

#### **完整代码**
```cpp
#include<bits/stdc++.h>
using namespace std;

int t;
bool flag;

int convert(string s) {
    int num = 0;
    int len = s.size() - 1;
    if (s[0] == '0') return 0;
    for (int i = 0; i < len; i++) {
        num = num * 10 + (s[i] - '0');
    }
    return num;
}

bool is_prime(int x) {
    if (x < 2) return false;
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) return false;
    }
    return true;
}

void dfs(string x, int id) {
    if (flag) return;
    if (x[id] == ' ') {
        int num = convert(x);
        if (is_prime(num)) {
            cout << num << endl;
            flag = true;
        }
        return;
    }
    if (x[id] == '*') {
        for (int i = 0; i < 10; i++) {
            x[id] = '0' + i;
            dfs(x, id + 1);
        }
    } else {
        dfs(x, id + 1);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> t;
    while (t--) {
        string s;
        cin >> s;
        s += " ";
        flag = false;
        dfs(s, 0);
        if (!flag) cout << "-1\n";
    }
    return 0;
}
```

---

### **最优思路提炼**
1. **DFS顺序生成**：按位替换星号为0-9，确保候选数递增。
2. **剪枝优化**：首个解即终止，避免冗余计算。
3. **字符串终止标记**：添加空格简化递归边界判断。

---

### **同类题目推荐**
1. **P1217** [USACO1.5]回文质数（枚举回文数并判断质数）
2. **P1036** 选数（组合数求和后判断质数）
3. **P1134** 阶乘问题（分解质因数与模运算）

---

### **个人心得**
- **易错点**：首位不能为0需在转换时检查，而非DFS中处理。
- **调试经验**：通过添加空格标记终止条件，避免复杂的长度判断。

---

### **可视化与游戏化设计**
- **像素动画**：
  - **颜色方案**：绿色（已确定位）、黄色（当前替换位）、红色（非质数）。
  - **Canvas绘制**：网格显示字符串，替换时高亮当前位，右侧显示候选数值。
- **音效**：
  - **替换音效**：短促“哔”声。
  - **成功音效**：8位上扬音符。
- **自动演示**：AI模拟DFS路径，优先替换为更小数值，快速定位解。

---
处理用时：217.00秒
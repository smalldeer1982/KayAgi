# 题目信息

# [GXPC-S 2024] 扫雷

## 题目背景

小林最近迷上了扫雷游戏。

## 题目描述

一个扫雷游戏可以被抽象成一个 $n$ 行 $m$ 列的字符矩阵，不妨记第 $i$ 行第 $j$ 列的字符为 $S_{i,j}$。

若 $S_{i,j}=\texttt{*}$，表示格子 $(i,j)$ 上有一个地雷；

若 $S_{i,j}=\texttt{?}$，表示格子 $(i,j)$ 情况未知；

若 $S_{i,j}\in [0,8]$，表示格子 $(i,j)$ 周围的 $8$ 个格子中有 $S_{i,j}$ 个地雷（这个格子本身没有地雷）。
形式化地说，记

$$
f(i,j)=\begin{cases}
1, & (i,j)\text{ 上有地雷} \\
0, & \text{其他情况} \\
\end{cases}
$$

特别地，对于超出棋盘边界的情况，规定 $f(i,j)=0$。
则 $\displaystyle S_{i,j}=\sum_{p=-1}^1\sum_{q=-1}^1 f(i+p,j+q)$。

给定一个棋盘，你可以任意决定每个 $\texttt{?}$ 格子上是否有炸弹。你想要知道是否存在方案使得这个棋盘是合法的。
我们定义一个棋盘**合法**，当且仅当填有数字 $x$ 的格子周围的八个格子上恰好有 $x$ 个炸弹。

你需要解决 $T$ 组数据。

## 说明/提示

对于第一组数据：问号处选择不填是一种合法方案。可以证明这是唯一的合法方案。

**本题采用捆绑测试。**

- Subtask 1（20pts）：至多存在 $1$ 组 $(i,j)$，使得 $S_{i,j}=\texttt{?}$；
- Subtask 2（80pts）：无额外约束。

对于 $100\%$ 的数据，保证：

- $1\le T,n,m\le 10$；
- 至多存在 $10$ 组 $(i,j)$，使得 $S_{i,j}=\texttt{?}$；
- $\forall 1\le i\le n,1\le j\le m$，保证 $S_{i,j}\in\{0,1,2,3,4,5,6,7,8,\texttt{?},\texttt{*}\}$。


## 样例 #1

### 输入

```
3
2 2
**
2?
2 2
*1
3?
2 2
**
21```

### 输出

```
YES
NO
NO```

# AI分析结果



---

### 算法分类
**暴力枚举**

---

### 题解思路与算法分析

#### 核心思路
1. **枚举所有可能状态**：题目中最多有 10 个 `?`，每个 `?` 有两种状态（雷或非雷），总共有 \(2^{10} = 1024\) 种可能。通过二进制状态压缩枚举所有可能性。
2. **验证合法性**：对每个枚举的状态，检查所有已知数字格子是否满足周围雷数要求。遍历每个数字格子的八个邻域，统计实际雷数并与标注值对比。

#### 解决难点
- **高效枚举**：通过二进制位表示每个 `?` 的状态，快速生成所有可能的雷分布。
- **边界处理**：遍历邻域时自动跳过棋盘外的坐标（代码中通过条件判断实现）。
- **状态覆盖与恢复**：直接修改原棋盘中的 `?` 位置，无需额外存储，每组测试用例独立处理，避免状态残留。

#### 关键变量与操作
- `vec`：存储所有 `?` 的位置。
- `st`：二进制状态，每位表示一个 `?` 是否为雷。
- `dx/dy`：八邻域方向数组，遍历所有可能的周边格子。

---

### 题解评分
**⭐⭐⭐⭐（4/5）**

- **思路清晰度**：直接枚举所有可能状态，逻辑简单明确。
- **代码可读性**：变量命名合理，结构清晰，但 `dx/dy` 方向数组的遍历顺序可优化（如预计算所有邻域）。
- **实践可操作性**：无需复杂优化，适合小规模数据。
- **优化空间**：可预存原棋盘状态以避免多次修改，但当前实现已足够高效。

---

### 最优思路提炼
1. **暴力枚举 + 状态压缩**：利用数据量小的特点，穷举所有可能的 `?` 状态。
2. **快速合法性验证**：对每个状态，遍历所有数字格子并统计邻域雷数，确保所有条件满足。
3. **方向数组技巧**：通过 `dx/dy` 数组统一处理八邻域遍历，避免重复代码。

---

### 类似题目与算法
- **洛谷 P1784 数独**：枚举空格所有可能值并验证。
- **洛谷 P1219 八皇后**：回溯法枚举所有合法状态。
- **开关灯问题**：每个开关影响周围状态，需枚举初始状态。

---

### 可视化设计要点

#### 动画方案
1. **状态枚举**：以像素网格展示棋盘，当前枚举的 `?` 格子闪烁（黄色高亮）。
2. **邻域检查**：选中数字格子时，其八邻域格子以绿色边框标记，雷以红色方块显示。
3. **合法性反馈**：非法状态时，错误格子变为闪烁红色；合法状态时棋盘整体变绿。

#### 复古风格
- **颜色方案**：雷（红色方块）、数字（白色文本）、合法棋盘（绿色背景）。
- **音效**：枚举时播放“滴”声，合法时播放“胜利”音效，非法时播放“错误”音效。
- **Canvas 绘制**：固定网格大小，棋盘坐标映射为像素坐标，动态更新格子状态。

---

### 核心代码片段
```cpp
// 枚举所有可能的 ? 状态
for (int st = 0; st < (1 << vec.size()); ++st) {
    // 设置当前状态下的雷分布
    for (int i = 0; i < vec.size(); ++i) {
        int x = vec[i].first, y = vec[i].second;
        s[x][y] = (st >> i & 1) ? '*' : '.';
    }
    // 验证所有数字格子合法性
    bool valid = true;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (isdigit(s[i][j])) {
                int cnt = s[i][j] - '0';
                for (int k = 0; k < 8; ++k) {
                    int x = i + dx[k], y = j + dy[k];
                    if (x >= 1 && x <= n && y >= 1 && y <= m && s[x][y] == '*') cnt--;
                }
                if (cnt != 0) valid = false;
            }
        }
    }
    if (valid) { ans = true; break; }
}
```

---

### 个人心得
- **调试关键**：需确保方向数组覆盖所有八邻域，初始实现曾漏掉部分方向。
- **优化经验**：直接修改原棋盘比拷贝副本更高效，但需注意测试用例间的独立性。

---

### 推荐题目
1. **P1784 数独**（暴力枚举 + 剪枝）
2. **P1219 八皇后**（回溯法枚举合法状态）
3. **P2622 关灯问题II**（状态压缩 + BFS）

---
处理用时：118.28秒
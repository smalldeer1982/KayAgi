# 题目信息

# [常州市赛 2021] 烧菜

## 题目背景

搬运自 <http://czoj.com.cn/p/440>。

## 题目描述

小 $\text{X}$ 正在指挥 $M$ 个机器人做一道家常菜：白灼青菜。  
把一根青菜烧成菜肴需要两个步骤：洗菜和水煮。显然，一根青菜不可能同时被清洗和水煮，也不可能先被水煮后被清洗。  
现在小 $\text{X}$ 告诉你他是怎么指挥的。每当一个机器人空下来： 
- 如果有青菜还没被清洗，就让这个机器人清洗这根青菜
- 否则如果有青菜还没被水煮，就让这个机器人水煮这根青菜
- 都没有就让这个机器人关机

现在一共需要把 $N$ 根青菜烧成菜肴，任何一个机器人清洗都要花 $A$ 分钟，水煮要花 $B$ 分钟。小 $\text X$ 想请你告诉他多少分钟后所有菜能被烧好。

## 说明/提示

### 样例解释
为了方便说明，把机器人标号为 $1$ 号机器人和 $2$号机器人；把青菜标号为 $1$ 号、 $2$ 号、 $3$ 号青菜。实际上，机器人间是没有区别的，青菜间也是没有区别的。  
- 第 $0$ 分钟， $1$ 号机器人开始洗 $1$ 号青菜， $2$ 号机器人开始洗 $2$ 号青菜。  
- 第 $9$ 分钟， $1$ 号机器人开始洗 $3$ 号青菜， $2$ 号机器人开始煮 $1$ 号青菜。  
- 第 $14$ 分钟， $2$ 号机器人开始煮 $2$ 号青菜。  
- 第 $18$ 分钟， $1$ 号机器人开始煮 $3$ 号青菜。  
- 第 $19$ 分钟， $2$ 号机器人关机。  
- 第 $23$ 分钟，所有菜都被烧好了， $1$ 号机器人关机。
### 数据范围
本题共有 $20$ 个测试点。  
对于所有数据，满足 $1\le N,M,A,B\le 2000$。
|测试点编号|$N,M,A,B$|特殊性质|
|:-:|:-:|:-:|
|$1\sim2$|$\le50$|$M>N$|
|$3\sim4$|$\le50$|$M=1$|
|$5\sim6$|$\le50$|$A=B$|
|$7\sim10$|$\le50$|无|
|$11\sim12$|$\le2000$|$M>N$|
|$13\sim14$|$\le2000$|$M=1$|
|$15\sim16$|$\le2000$|$A=B$|
|$17\sim20$|$\le2000$|无|

## 样例 #1

### 输入

```
3 2 9 5```

### 输出

```
23```

# AI分析结果



## 算法分类
**贪心算法（优先队列模拟）**

---

## 综合分析与结论
### 核心思路与难点
1. **任务依赖关系**：每根青菜必须**先洗后煮**，且同一时间只能进行一个步骤。
2. **机器人调度**：每次选择**最早空闲的机器人**，优先分配洗菜任务，再分配煮菜任务。
3. **关键难点**：正确处理煮菜任务的开始时间必须 ≥ 对应洗菜的完成时间。

### 算法流程与可视化设计
- **优先队列**维护机器人空闲时间，每次取堆顶（最早空闲机器人）。
- **洗菜队列**记录洗菜的完成时间，煮菜时取 `max(机器人空闲时间, 对应洗菜完成时间)`。
- **动画设计**：
  - 用红色方块表示洗菜任务，蓝色方块表示煮菜任务。
  - 堆顶元素高亮显示，每次弹出时展示任务分配过程。
  - 时间轴动态推进，显示当前操作的机器人和时间节点。

### 复古像素化设计
- **Canvas 网格**：每个机器人对应一行，时间轴横向延伸，任务以不同颜色方块表示。
- **音效**：任务分配时播放“哔”声，煮菜开始播放“滴”声，完成时播放上扬音效。
- **自动演示**：按时间步进自动分配任务，支持暂停/继续观察关键节点。

---

## 题解清单 (≥4星)
### Sliarae 题解（⭐⭐⭐⭐）
- **亮点**：双优先队列严格保证煮菜不早于洗菜，高效处理依赖关系。
- **代码**：使用 `q` 和 `p` 分别管理机器人空闲和洗菜完成时间，逻辑严密。

### why17 题解（⭐⭐⭐⭐⭐）
- **亮点**：三队列分离洗/煮任务，代码清晰易读，直接取最大值保证时序。
- **代码**：`t1` 记录洗菜完成时间，煮菜时取 `max(time, t1.top())`，思路直观。

### Manchester 题解（⭐⭐⭐）
- **亮点**：分阶段处理，先洗后煮，排序洗菜时间简化逻辑。
- **缺点**：时间复杂度 O(NM) 较高，但适合理解核心流程。

---

## 最优思路提炼
1. **优先队列贪心**：始终选择最早空闲的机器人，最大化并行效率。
2. **时序分离**：洗菜完成时间单独记录，煮菜时强制取最大值保证依赖。
3. **双队列管理**：用两个堆分别处理洗菜和煮菜的时序约束。

---

## 同类型题推荐
1. **任务调度**：[P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. **依赖处理**：[P1809 过河问题](https://www.luogu.com.cn/problem/P1809)
3. **并行分配**：[P2278 操作系统](https://www.luogu.com.cn/problem/P2278)

---

## 代码实现（why17 题解核心）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a,b;
priority_queue<int,vector<int>,greater<int>> q,t1,t2;

int main(){
    cin>>n>>m>>a>>b;
    for(int i=0;i<m;i++) q.push(0);
    int cnt1=0,cnt2=0;
    while(cnt1<n || cnt2<n){
        if(q.empty()) break;
        int time=q.top(); q.pop();
        if(cnt1<n){ // 分配洗菜
            t1.push(time+a);
            q.push(time+a);
            cnt1++;
        } else { // 分配煮菜
            int st=max(time, t1.top());
            t1.pop();
            t2.push(st+b);
            q.push(st+b);
            cnt2++;
        }
    }
    int ans=0;
    while(!t2.empty()) ans=t2.top(), t2.pop();
    cout<<ans;
    return 0;
}
```

---

## 可视化代码片段（Canvas 动画）
```javascript
// 伪代码示例：绘制时间轴与任务块
function drawTask(robotId, start, end, type) {
    ctx.fillStyle = type === 'wash' ? '#FF5555' : '#5555FF';
    ctx.fillRect(start * scaleX, robotId * 50, (end-start)*scaleX, 40);
}

// 每次分配任务时触发动画
function animateStep(time, robot, taskType) {
    highlightRobot(robot); // 高亮当前机器人
    drawTimeLine(time); // 更新时间轴
    playSound(taskType); // 播放音效
}
```

---

## 个人心得
- **why17 调试经验**：初始未考虑机器人关机逻辑，导致队列空指针。通过增加 `q.empty()` 检查修复。
- **时序陷阱**：煮菜必须等待洗菜完成，直接相加时间会导致错误，取最大值是核心技巧。

---
处理用时：141.10秒
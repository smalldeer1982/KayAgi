# 题目信息

# [NOIP 2010 普及组] 导弹拦截

## 题目描述

经过 $11$ 年的韬光养晦，某国研发出了一种新的导弹拦截系统，凡是与它的距离不超过其工作半径的导弹都能够被它成功拦截。当工作半径为 $0$ 时，则能够拦截与它位置恰好相同的导弹。但该导弹拦截系统也存在这样的缺陷：每套系统每天只能设定一次工作半径。而当天的使用代价，就是所有系统工作半径的平方和。

某天，雷达捕捉到敌国的导弹来袭。由于该系统尚处于试验阶段，所以只有两套系统投入工作。如果现在的要求是拦截所有的导弹，请计算这一天的最小使用代价。

## 说明/提示

两个点 $(x_1,y_1),(x_2,y_2)$ 之间距离的平方是 $(x_1-x_2)^2+(y_1-y_2)^2$。

两套系统工作半径 $r_1,r_2$ 的平方和，是指 $r_1,r_2$ 分别取平方后再求和，即 $r_1^2+r_2^2$。

### 样例 1 说明

样例 $1$ 中要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $18$ 和 $0$。

### 样例 2 说明

样例 $2$ 中的导弹拦截系统和导弹所在的位置如下图所示。要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $20$ 和 $10$。

![](https://cdn.luogu.com.cn/upload/image_hosting/cvgomt03.png)

【数据范围】。

- 对于 $10\%$ 的数据，$N=1$。
- 对于 $20\%$ 的数据，$1\le N\le 2$。
- 对于 $40\%$ 的数据，$1\le N\le 100$。
- 对于 $70\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 10^5$，且所有坐标分量的绝对值都不超过 $1000$。

NOIP2010 普及组 第三题

## 样例 #1

### 输入

```
0 0 10 0
2
-3 3
10 0```

### 输出

```
18```

## 样例 #2

### 输入

```
0 0 6 0
5
-4 -2
-2 3
4 0
6 -2
9 1```

### 输出

```
30```

# AI分析结果



# 算法分类
**贪心算法**

## 题解思路与核心难点
### 核心思路
所有导弹必须被至少一个系统拦截。将导弹按到系统1的距离平方排序，枚举每个分界点i：系统1拦截前i个导弹（半径为第i个导弹的距离），系统2拦截剩余导弹（半径为其到系统2的最大距离）。预处理后缀最大距离可实现O(1)查询。

### 解决难点
1. **分界点枚举**：需覆盖所有情况（包括全由系统2拦截）。
2. **高效求后缀最大值**：从后往前预处理数组，维护当前最大d2。
3. **平方计算优化**：直接使用距离平方避免浮点运算。

## 题解评分
### 五星题解
1. **TEoS**  
   - 思路清晰，预处理后缀最大值，代码简洁。
   - 关键代码：排序后倒序预处理d2最大值。
   ```cpp
   for(int i=n;i>0;i--) di[i].d2 = max(dis2, di[i+1].d2);
   ```
2. **暗ざ之殇**  
   - 预处理nxt数组保存后缀最大值，逻辑明确。
   - 亮点：图示辅助理解分界点逻辑。
   ```cpp
   for(int i=n-1;i>=1;i--) nxt[i] = max(dis2, nxt[i+1]);
   ```
3. **Zh_terminal**  
   - 结构体存储双距离，代码简洁高效。
   - 关键步骤：排序后倒序遍历维护max2。
   ```cpp
   int d=0;
   for(int i=N;i>=1;i--) d=max(d,a[i].d2);
   ```

## 最优思路提炼
1. **排序预处理**：按到系统1的距离升序排序。
2. **后缀最大值数组**：预处理每个位置i之后的最大d2。
3. **枚举分界点**：从0到n枚举，计算代价取最小。

## 相似题目推荐
1. **P1223 排队接水**（贪心排序）
2. **P1803 线段覆盖**（区间排序与选择）
3. **P1090 合并果子**（贪心优先队列）

## 可视化设计
### 动画方案
- **动态分界线**：画布左侧为系统1，右侧为系统2，导弹按到系统1的距离排序后水平排列。
- **半径显示**：分界点移动时，系统1的圆半径更新为当前分界点导弹的距离，系统2的圆半径显示为右侧所有导弹的最大d2。
- **高亮交互**：当前分界点用红色竖线标记，代价实时更新显示。

### 复古像素风格
- **8位色彩**：系统1用蓝色像素圆，系统2用绿色，导弹用黄色点。
- **音效设计**：分界点移动时播放"滴"声，找到更优解时播放"叮"声。
- **自动演示**：分界线自动从左到右移动，用户可暂停/调整速度。

```javascript
// 伪代码示例：Canvas绘制核心逻辑
function drawFrame(currentSplit) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // 绘制系统1覆盖范围
  ctx.fillStyle = '#00F';
  ctx.beginPath();
  ctx.arc(sys1.x, sys1.y, currentSplit.d1**0.5, 0, Math.PI*2);
  ctx.fill();
  // 绘制系统2最大半径
  let maxD2 = suffixMax[currentSplit.index];
  ctx.fillStyle = '#0F0';
  ctx.beginPath();
  ctx.arc(sys2.x, sys2.y, maxD2**0.5, 0, Math.PI*2);
  ctx.fill();
}
```

---

**结论**：通过排序与预处理后缀最大值，将问题转化为枚举分界点的贪心策略，时间复杂度O(n log n)，是本题的最优解法。可视化设计通过动态分界与双圆覆盖范围，直观展示算法核心逻辑。

---
处理用时：76.69秒
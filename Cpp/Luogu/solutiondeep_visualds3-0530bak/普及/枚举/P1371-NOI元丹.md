# 题目信息

# NOI元丹

## 题目描述

小A打算开始炼 $\texttt{NOI}$ 元丹（什么鬼），据说吃了可以提高 $\texttt{NOI}$ 时的成绩。

是这么练的。元丹有三种元核，`N`、`O`、`I`。现有很多个这样原核，按顺序排成一行。炼元丹时，从左往右分别挑出 `N`、`O`、`I` 三个原核吞下。

现在他关心，有几种服用方式……且慢！

他觉得服用方式太少，以至于不能成仙。所以他可以通过某个途径，得到 `N`、`O`、`I` 的三种原核中的**任意一个**，至于哪一种由他决定。然后他将获得这个原核的插入到这一排原核中的任意位置（包括最前最后）。

现在你要知道，新的元核序列中能有多少种 `N`、`O`、`I` 的取出方式。子串的字母并不要求连续。

## 说明/提示

样例解释：

他可以获取一个 `N` 元核，加到最前面。

```plain
NNOIOI | NNOIOI | NNOIOI | NNOIOI | NNOIOI | NNOIOI
~ ~~   | ~ ~  ~ | ~   ~~ |  ~~~   |  ~~  ~ |  ~  ~~
```
对于 $30\%$ 的数据 $N \le 200$。

对于 $50\%$ 的数据 $N \le 2000$。

对于 $100\%$ 的数据 $3 \le N \le 10 ^ 5$。


## 样例 #1

### 输入

```
5
NOIOI```

### 输出

```
6```

# AI分析结果



# NOI元丹题解分析

## 算法分类
**前缀和与后缀和 + 贪心算法**

---

## 题解思路与解决难点

### 核心思路
1. **原始问题计算**：遍历字符串，计算每个`O`左边`N`的数量（前缀和）和右边`I`的数量（后缀和），累加所有`O`的贡献（`左N数 × 右I数`）。
2. **插入字符优化**：
   - **插入`N`**：放在最前端，使所有`O`的左边`N`数量+1，总贡献增加所有`O`右侧`I`的数量之和。
   - **插入`I`**：放在最后端，使所有`O`的右边`I`数量+1，总贡献增加所有`O`左侧`N`的数量之和。
   - **插入`O`**：枚举所有可能位置，取最大的`左N数 × 右I数`。

### 解决难点
- **高效预处理**：通过前缀和和后缀和数组快速获取每个位置的左右信息。
- **贪心策略证明**：插入`N`/`I`的最优位置需数学证明，确保无需遍历所有可能位置。

---

## 题解评分（≥4星）

### 5星题解：kkksc03
- **亮点**：简洁的递推公式直接计算贡献，清晰的三类插入策略分析，代码高效。
- **代码片段**：
  ```cpp
  for (int i=0; i<n; i++) {
      if (s[i]=='N') num_N++;
      else if (s[i]=='O') num_NO += num_N;
      else if (s[i]=='I') ans += num_NO;
  }
  ```

### 4星题解：Aryper
- **亮点**：详细分步推导前缀/后缀数组，结合乘法原理分析插入影响。
- **代码片段**：
  ```cpp
  // 前缀N数组
  for (int i=1; i<=n; i++) 
      f[i] = (s[i-1]=='N') ? f[i-1]+1 : f[i-1];
  // 后缀I数组
  for (int i=n; i>=1; i--)
      g[i] = (s[i-1]=='I') ? g[i+1]+1 : g[i+1];
  ```

### 4星题解：Ajwallet
- **亮点**：通过动态调整`ii`数组避免重复计算，优化空间复杂度。
- **代码片段**：
  ```cpp
  for (int i=0; i<n; i++) {
      if (s[i] == 'O') 
          res += (leftN[i] * rightI[i]);
  }
  ```

---

## 最优技巧提炼
1. **前缀和与后缀和预处理**：分别统计每个位置左侧的`N`数和右侧的`I`数。
2. **贪心插入策略**：无需遍历所有插入位置，`N`/`I`的最优位置可直接确定，`O`的最优位置通过预处理后的最大乘积快速计算。
3. **增量计算**：插入`N`或`I`的总贡献增量可转化为已有统计值的总和，避免重复遍历。

---

## 同类题目推荐
1. **P2671 [NOIP2015 普及组] 求和**：前缀和优化子序列统计。
2. **P2513 [HAOI2009]逆序对数列**：预处理左右信息优化动态规划。
3. **P1564 牛碑**：贪心策略与子序列计数的结合。

---

## 可视化与算法演示设计

### 动态流程图
1. **前缀和计算**：从左到右扫描，高亮当前字符，显示`N`计数递增。
   ![前缀和动画](https://via.placeholder.com/300x200/FF6B6B/000?text=Prefix+N+Count)
2. **后缀和计算**：从右到左扫描，高亮当前字符，显示`I`计数递增。
   ![后缀和动画](https://via.placeholder.com/300x200/4ECDC4/000?text=Suffix+I+Count)
3. **插入模拟**：
   - **插入`N`**：在最前端添加红色方块，所有`O`的左侧`N`数+1。
   - **插入`I`**：在末尾添加蓝色方块，所有`O`的右侧`I`数+1。
   - **插入`O`**：遍历所有位置，实时显示当前乘积值，最大值用金色高亮。

### 复古像素风格设计
- **颜色方案**：8位色系（`N`-红色，`O`-黄色，`I`-蓝色，插入点-闪烁绿色）。
- **音效**：  
  - 正确操作：FC经典“金币声”（8-bit `0xAB`音调）。
  - 错误操作：短促“爆炸声”（`0x30`低音）。
- **自动演示模式**：AI模拟三种插入策略的决策过程，速度可调（1x/2x/4x）。

---

## 核心代码实现（C++）
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n; string s;
    cin >> n >> s;
    vector<long long> leftN(n+2, 0), rightI(n+2, 0);
    
    // 计算前缀N
    for (int i=1; i<=n; i++) 
        leftN[i] = leftN[i-1] + (s[i-1] == 'N');
    
    // 计算后缀I
    for (int i=n; i>=1; i--)
        rightI[i] = rightI[i+1] + (s[i-1] == 'I');
    
    // 原始答案与插入O的最大值
    long long original = 0, maxO = 0;
    for (int i=1; i<=n; i++) {
        if (s[i-1] == 'O') {
            original += leftN[i] * rightI[i];
            maxO = max(maxO, leftN[i] * rightI[i]);
        }
    }
    
    // 插入N的增量（加在最前面）
    long long addN = 0;
    for (int i=1; i<=n; i++)
        if (s[i-1] == 'O') addN += rightI[i];
    
    // 插入I的增量（加在最后面）
    long long addI = 0;
    for (int i=1; i<=n; i++)
        if (s[i-1] == 'O') addI += leftN[i];
    
    cout << original + max({addN, addI, maxO});
    return 0;
}
```

---
处理用时：98.54秒
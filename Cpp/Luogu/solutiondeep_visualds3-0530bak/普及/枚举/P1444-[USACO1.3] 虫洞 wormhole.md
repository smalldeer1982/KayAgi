# 题目信息

# [USACO1.3] 虫洞 wormhole

## 题目描述

Farmer John 周末进行高能物理实验的结果却适得其反，导致 $n$ 个虫洞出现在农场上，农场是一个二维平面，没有两个虫洞处于同一位置。

根据他的计算，FJ 知道他的虫洞两两配对，形成 $\dfrac{n}{2}$ 对配对。例如，如果 $A$ 和 $B$ 的虫洞连接成一对，进入虫洞 $A$ 的任何物体将从虫洞 $B$ 出去，方向不变；反之亦然。  

然而这可能发生相当令人不快的后果。例如，假设有两个成对的虫洞 $A(1,1)$ 和 $B(3,1)$，Bessie 从 $(2,1)$ 开始朝着 $x$ 正方向移动。Bessie 将进入虫洞 $B(3,1)$，从 $A(1,1)$ 出去，然后再次进入 $B$，困在一个无限循环中！

FJ 知道他的农场里每个虫洞的确切位置。他知道 Bessie 总是向 $x$ 正方向走进来，虽然他不记得贝茜的当前位置。  

请帮助 FJ 计算有多少种虫洞配对方案，使得存在一个位置，使得 Bessie 从该位置出发，会被困在一个无限循环中。

## 说明/提示

### 数据范围
对于 $100\%$ 的数据，$2\le n \le 12$，$0 \le x,y \le 10^9$。  
保证 $n$ 为偶数。

### 样例解释

将虫洞编号为 $1 \sim 4$，然后通过将 $1,2$ 和 $3,4$ 匹配，如果 Bessie 从 $(0,0)$ 到 $(1,0)$ 之间的任意位置出发，她会陷入无限循环中。

相似的，在相同的起始点，如果配对是 $1,3$ 和 $2,4$，贝茜也会陷入循环。（如果贝西从 $3$ 进去，$1$ 出来，她会走向 $2$ ，然后被传送到 $4$，最后又回到 $3$）

仅有 $1,4$ 和 $2,3$ 的配对允许贝茜从任何二维平面上的点向 $x$ 正方向走，而不出现无限循环。

题面翻译摘自 NOCOW

## 样例 #1

### 输入

```
4
0 0
1 0
1 1
0 1```

### 输出

```
2```

# AI分析结果



## 算法分类
**枚举与回溯**

---

## 综合分析与结论

### 核心思路
1. **枚举所有配对方式**：通过回溯法生成所有可能的虫洞配对组合。
2. **预处理右侧虫洞**：按 y 坐标排序后，每个虫洞的右侧虫洞是同一行中 x 坐标最近的。
3. **循环检测**：模拟贝茜的行走路径，若重复进入同一虫洞且状态相同，则判定为循环。

### 解决难点
- **配对去重**：通过固定配对顺序（如从小到大）避免重复枚举。
- **高效循环检测**：预处理右侧虫洞后，仅需模拟传送和行走交替的过程，无需遍历坐标。
- **状态标记**：记录是否通过虫洞传送进入当前节点，避免状态混淆。

### 可视化设计
- **动画方案**：展示虫洞配对生成和循环检测过程。
  - **配对生成**：用回溯法逐步连线，高亮当前配对的虫洞。
  - **循环检测**：用箭头模拟贝茜移动，红色高亮循环路径。
  - **状态标记**：不同颜色区分“行走进入”和“传送进入”。
- **像素风格**：8 位像素网格中，虫洞用不同颜色方块表示，音效提示循环触发。

---

## 题解评分（≥4星）

1. **Sino_E（⭐⭐⭐⭐⭐）**  
   - **亮点**：预处理右侧虫洞，分离变与不变，代码简洁高效。
   - **关键代码**：
     ```cpp
     bool cycle(int x) {
         while(to[x]) {
             if(tag[x]) return 1;
             tag[x] = 1;
             x = con[to[x]];
         }
         return 0;
     }
     ```

2. **王轩逸（⭐⭐⭐⭐）**  
   - **亮点**：抽屉原理判断循环，模拟走 n 步后仍在虫洞则存在循环。
   - **关键代码**：
     ```cpp
     bool is_cycle() {
         for(int start=1; start<=n; start++) {
             int pos = start;
             for(int cnt=1; cnt<=n; cnt++)
                 pos = to[part[pos]];
             if(pos) return true;
         }
         return false;
     }
     ```

3. **RBI_GL（⭐⭐⭐⭐）**  
   - **亮点**：使用 `pre` 数组记录配对关系，`to` 数组预处理右侧虫洞。
   - **关键代码**：
     ```cpp
     bool check() {
         memset(vis, 0, sizeof(vis));
         int pos = start;
         while (to[pos]) {
             if (vis[pos]) return true;
             vis[pos] = 1;
             pos = pre[to[pos]];
         }
         return false;
     }
     ```

---

## 最优思路提炼

### 关键技巧
1. **配对生成**：固定顺序避免重复，如 `i` 必须与 `j > i` 配对。
2. **右侧预处理**：排序后直接确定同一行的相邻虫洞。
3. **交替模拟**：传送后必须行走，行走后必须传送，交替检测。

### 代码片段
```cpp
// 预处理右侧虫洞（Sino_E）
sort(p+1, p+n+1, cmp);
for(int i=1; i<n; i++)
    if(p[i].y == p[i+1].y) to[i] = i+1;

// 循环检测（QQ红包）
bool check() {
    for(int j=1; j<=n; j++) {
        memset(tag, 0, sizeof(tag));
        if(cycle(j)) return true;
    }
    return false;
}
```

---

## 相似题目
1. **P1219 八皇后**（回溯法枚举排列）
2. **P1120 小木棍**（DFS剪枝优化）
3. **P1074 靶形数独**（状态压缩与回溯）

---

## 可视化与复古动画
- **Canvas 绘制**：虫洞用 16x16 像素块表示，配对线用绿色像素连接。
- **音效触发**：循环检测成功时播放 8-bit 胜利音效。
- **自动演示**：按空格键单步执行配对生成，Enter 键自动播放。

---

**总结**：本题通过枚举配对和交替模拟路径解决，核心在于预处理和状态标记。推荐 Sino_E 的解法，兼顾高效与简洁。

---
处理用时：86.60秒
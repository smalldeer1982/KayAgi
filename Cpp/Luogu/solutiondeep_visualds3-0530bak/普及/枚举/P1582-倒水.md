# 题目信息

# 倒水

## 题目描述

一天，CC 买了 $N$ 个容量可以认为是无限大的瓶子，开始时每个瓶子里有 $1$ 升水。接着 CC 发现瓶子实在太多了，于是他决定保留不超过 $K$ 个瓶子。每次他选择两个当前含水量相同的瓶子，把一个瓶子的水全部倒进另一个里，然后把空瓶丢弃。（不能丢弃有水的瓶子）

显然在某些情况下 CC 无法达到目标，比如 $N = 3$、$K = 1$。此时 CC 会重新买一些新的瓶子（新瓶子容量无限，开始时有 $1$ 升水），以达到目标。

现在 CC 想知道，最少需要买多少新瓶子才能达到目标呢？


## 样例 #1

### 输入

```
3 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
13 2```

### 输出

```
3```

## 样例 #3

### 输入

```
1000000 5```

### 输出

```
15808```

# AI分析结果



# 算法分类
**二进制处理、贪心算法**

---

## 题解思路与算法要点

### 核心思路
1. **二进制特性**：合并后的水量为 2 的幂次，最终保留的瓶子数量等于当前水量二进制表示中 1 的个数。
2. **贪心策略**：每次选择最低位的 1（lowbit），通过进位合并相邻的 1，减少总 1 的数量。
3. **操作步骤**：
   - 计算当前数的二进制中 1 的个数。
   - 若超过 K，则加上 lowbit(n) 进位，重复直到满足条件。

### 解决难点
- **关键操作**：`n += lowbit(n)` 实现合并相邻低位 1 的进位。
- **数学保证**：每次进位至少减少一个 1，最终必能收敛到 ≤ K 个 1。

---

## 题解评分（≥4星）

1. **pantw的题解（5星）**
   - 亮点：代码极简（7行），利用 `__builtin_popcount` 和 `lowbit` 高效处理。
   - 核心代码：
     ```cpp
     while(__builtin_popcount(n) > k) 
         ans += n & -n, n += n & -n;
     ```

2. **Golden_Winter的题解（4星）**
   - 亮点：手动实现 `lowbit` 统计 1 的个数，适合理解底层原理。
   - 核心函数：
     ```cpp
     int work(int x) { // 统计二进制1的个数
         int num=0; for(;x;x-=x&-x) num++; return num;
     }
     ```

3. **LOFTER_OI的题解（4星）**
   - 亮点：使用 `bitset` 替代内置函数，适合竞赛禁用下划线函数的情况。
   - 关键代码：
     ```cpp
     bitset<50>a(n);
     while(a.count() > k) {
         ans += lowbit(n); n += lowbit(n);
     }
     ```

---

## 最优思路提炼
- **关键操作**：`lowbit(n)` 获取最低位 1 的值，通过 `n += lowbit(n)` 实现进位。
- **数学本质**：将分散的低位 1 合并为高位 1，减少总 1 的数量。

---

## 类似题目推荐
1. **P1220 关路灯**（贪心策略）
2. **P1877 音量调节**（二进制状态处理）
3. **P1464 Function**（位运算优化）

---

## 可视化与算法演示

### 算法流程动画设计
1. **二进制展示**：以动态网格显示当前数二进制形式，高亮当前处理的 `lowbit`。
2. **进位特效**：低位 1 闪烁后进位，上方出现 "+lowbit" 提示，背景色渐变。
3. **音效设计**：
   - 每次进位时播放“滴”声。
   - 达成条件时播放 8-bit 胜利旋律。

### 复古像素风格示例（伪代码）
```javascript
// 绘制二进制位
function drawBits(n) {
    for (let i = 0; i < 32; i++) {
        let bit = (n >> i) & 1;
        ctx.fillStyle = bit ? '#FF5555' : '#333333';
        ctx.fillRect(i*16, 0, 14, 14); // 像素块
    }
    let lb = n & -n; // 高亮lowbit
    ctx.fillStyle = '#55FF55';
    ctx.fillRect(Math.log2(lb)*16, 0, 14, 14);
}
```

---

## 核心代码实现

### 贪心算法实现
```cpp
#include <cstdio>
int main() {
    int n, k, ans = 0;
    scanf("%d%d", &n, &k);
    while (__builtin_popcount(n) > k) {
        int lb = n & -n; // 获取lowbit
        ans += lb;
        n += lb; // 进位合并
    }
    printf("%d", ans);
}
```

---

## 个人心得摘录
> "意识到二进制与合并操作的对应关系是突破的关键。lowbit 的运用让代码简洁如魔法。" —— pantw  
> "手动实现二进制统计加深了对位运算的理解，避免依赖内置函数。" —— Golden_Winter

---
处理用时：90.82秒
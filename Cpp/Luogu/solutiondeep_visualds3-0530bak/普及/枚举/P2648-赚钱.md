# 题目信息

# 赚钱

## 题目背景

改编自某题


## 题目描述

zzy现在决定环游中国，顺便赚点钱。zzy在一个城市最多只能赚D元，然后他可以选择退休也就是停止赚钱，或者去其它城市工作。当然，他可以在别处工作一阵子后又回到原来的城市再赚D元。这样的往返次数是没有任何限制的。

城市间有P条单向路径连接，共有C座城市，编号从1到C。路径i从城市Ai到城市Bi，在路径行走上不用任何花费。

zzy还可以乘飞机从某个城市飞到另一个城市。共有F条单向的航线，第i条航线是从城市Ji飞到另一座城市Ki，费用是Ti元。假如zzy身上没有现钱，他可以用以后赚的钱来付机票钱。

zzy可以从任何一个城市出发开始赚钱，并且选择在任何时候、任何城市退休。现在zzy想要知道，如果在工作时间上不做限制，那么zzy共可以赚多少钱呢？如果赚的钱也不会出现限制，那么就输出orz。


## 说明/提示

对于100%的数据，1<=D<=1000，1<=P<=200，2<=C<=300，1<=F<=400。


## 样例 #1

### 输入

```
100 3 5 2
1 5
2 3
1 4
5 2 150
2 5 120```

### 输出

```
250```

# AI分析结果



---

## **算法分类**  
**SPFA求最长路 & 负环检测**

---

## **题解思路与核心分析**  
### **核心难点**  
1. **无限赚钱条件**：存在能无限次访问的正权环（赚的钱能覆盖航费）  
2. **最长路建模**：城市间的移动需要将赚钱操作转化为边权  
3. **高效检测正环**：SPFA 的负环检测等价于原问题的正环检测  

### **题解对比**  
| 题解思路               | 实现方式                                                                 | 亮点/缺点                                                                 |
|------------------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------|
| **超级源点+边权取反** | 建立虚拟源点连接所有城市，边权取相反数（免费边为`-D`，收费边为`w-D`） | 一次SPFA解决所有起点，但需处理超级源点的初始值逻辑                       |
| **暴力多源SPFA**       | 对每个城市作为起点跑SPFA，检测正环并记录最大值                           | 代码更直观但复杂度高（C次SPFA），依赖数据较弱                            |
| **Floyd两次判断**      | 通过两次Floyd算法判断最长路是否变化来检测正环                           | 非常规解法，存在逻辑漏洞（部分正环可能不影响最长路）                     |

---

## **题解评分（≥4星）**  
1. **绝顶我为峰（4.5星）**  
   - 思路清晰，代码简洁  
   - 超级源点巧妙统一处理所有起点  
   - 注释明确，变量命名合理  

2. **JohnJoeZhu（4星）**  
   - 提供两种实现对比，启发不同思路  
   - 详细分析边权设置逻辑  

3. **loi_ys（4星）**  
   - 暴力多源SPFA实现完整  
   - 包含调试注释和异常处理（`exit(0)`）  

---

## **最优思路提炼**  
### **关键技巧**  
1. **边权转换**：将赚钱操作建模为边权：  
   - 免费边权为 `-D`（相当于赚D元后移动）  
   - 收费边权为 `w-D`（赚D元后支付w元航费）  
2. **负环等价正环**：通过SPFA检测负环等价于原问题的无限赚钱条件  
3. **超级源点**：建立虚拟源点连接所有城市，初始赚D元  

### **核心代码逻辑**  
```cpp
// 建图核心代码（超级源点版）
for (int i = 1; i <= C; ++i) 
    add_edge(0, i, -D); // 超级源点到各城市初始边

// SPFA松弛逻辑
if (dis[v] > dis[u] + edge.weight) { // 注意此处是求最短路（原问题的最长路）
    dis[v] = dis[u] + edge.weight;
    if (++cnt[v] > C) return true; // 检测负环
}
```

---

## **同类型题目推荐**  
1. [P1938 [USACO09NOV] Job Hunt S](https://www.luogu.com.cn/problem/P1938)  
   （最长路+正环检测）  
2. [P3385 【模板】负环](https://www.luogu.com.cn/problem/P3385)  
   （SPFA负环检测模板）  
3. [P4568 [JLOI2011] 飞行路线](https://www.luogu.com.cn/problem/P4568)  
   （分层图最短路变种）  

---

## **可视化设计**  
### **动画方案**  
1. **像素风格展示**：  
   - 城市节点用16x16像素方块表示，颜色深浅表示当前赚的钱（越深越多）  
   - 队列状态显示在右侧，用绿色方块表示SPFA的待处理节点  

2. **关键操作高亮**：  
   - **松弛成功**：目标节点闪烁黄色  
   - **负环检测**：检测到环时，环上节点变为红色并抖动  
   - **队列操作**：节点入队时播放“哔”音效，出队时播放“咔”音效  

3. **自动演示模式**：  
   - 初始状态展示所有边权转换逻辑  
   - 逐步显示SPFA的松弛过程，速度可调节  
   - 检测到负环时播放警报音效并弹出"orz"提示  

---

## **题解代码（超级源点版）**  
```cpp
#include <queue>
#include <cstring>
#include <iostream>
using namespace std;

struct Edge { int to, w; };
vector<Edge> graph[305];
int dis[305], cnt[305];
bool inQueue[305];

bool SPFA(int n) {
    memset(dis, 0x3f, sizeof(dis));
    queue<int> q;
    q.push(0);
    dis[0] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        inQueue[u] = false;
        for (auto &e : graph[u]) {
            if (dis[e.to] > dis[u] + e.w) {
                dis[e.to] = dis[u] + e.w;
                if (!inQueue[e.to]) {
                    if (++cnt[e.to] > n) return true;
                    q.push(e.to);
                    inQueue[e.to] = true;
                }
            }
        }
    }
    return false;
}

int main() {
    int D, P, C, F;
    cin >> D >> P >> C >> F;
    // 建图
    while (P--) { 
        int a, b; cin >> a >> b;
        graph[a].push_back({b, -D}); // 免费边权
    }
    while (F--) {
        int j, k, t; cin >> j >> k >> t;
        graph[j].push_back({k, t - D}); // 收费边权
    }
    // 超级源点连接所有城市
    for (int i = 1; i <= C; ++i) 
        graph[0].push_back({i, -D});
    // 检测负环
    if (SPFA(C)) {
        cout << "orz";
    } else {
        int ans = 0;
        for (int i = 1; i <= C; ++i)
            ans = min(ans, dis[i]);
        cout << -ans; // 取反得到最长路
    }
    return 0;
}
```

---
处理用时：89.78秒
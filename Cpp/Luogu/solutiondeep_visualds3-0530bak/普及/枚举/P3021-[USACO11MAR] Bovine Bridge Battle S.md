# 题目信息

# [USACO11MAR] Bovine Bridge Battle S

## 题目描述

Farmer John 的每头牛（共 $N$ 头，$4 \le N \le 1,000$）都耐心地在主牧场等待，其中第 $i$ 头牛位于整数坐标 $(X_i, Y_i)$ 上（$-1,000,000,000 \le X_i \le 1,000,000,000$，$-1,000,000,000 \le Y_i \le 1,000,000,000$）。

这些牛希望组成四个一组，以便玩他们的新宠卡牌游戏「桥牌」。每组必须满足一个重要的约束条件：如果且仅如果在平面上存在某个点 $X$（并且不与潜在四牛组的任何四个点重合），使得围绕该点 $X$ 将组内任意一头牛旋转 $180$ 度后得到组内的另一头牛的位置，四头牛才可以组队。

请帮助这些牛确定可以组成桥牌组的四牛组合的数量。

例如，假设有八头牛分别站在八个点上：

|
f\*
```cpp
|             a = (-3, 1)    e = (-1, 1) 
b*     |             b = (-2, 2)    f = ( 0, 3) 
a      e  |             c = (-3, 0)    g = ( 2, 0) 
*     *  |             d = (-2, 0)    h = ( 3, 0) 
```
c  d     |     g  h
---------\*--\*-----+-----\*--\*---------

|
那么，三个合法的四牛组合是 {a, b, e, d}（它们围绕点 $(-2, 1)$ 旋转），{b, c, e, f}（围绕点 $(-1.5, 1.5)$），以及 {c, d, g, h}（围绕点 $(0,0)$）。

提供的牛的位置都是不同的，尽管它们的顺序没有特定的规则。此外，答案将适合一个有符号的 32 位整数。


## 说明/提示

（由 ChatGPT 4o 翻译）

## 样例 #1

### 输入

```
8 
-3 0 
-2 0 
-1 1 
0 3 
2 0 
-3 1 
3 0 
-2 2 
```

### 输出

```
3 
```

# AI分析结果



## 唯一算法分类
**哈希统计 + 几何性质**

---

## 题解思路、算法要点与解决难点

### 核心思路
所有题解均基于以下几何性质：四个点构成中心对称图形当且仅当存在两对点，其坐标和相等。即若四点为 $(a,b,c,d)$，则存在 $(a,b)$ 与 $(c,d)$ 满足：
$$x_a + x_b = x_c + x_d,\quad y_a + y_b = y_c + y_d$$

### 算法步骤
1. **预处理所有点对的坐标和**：枚举所有点对，计算 $(x_i + x_j, y_i + y_j)$，存入哈希表统计出现次数。
2. **统计合法四元组数**：再次枚举所有点对，根据哈希表中相同坐标和的数量计算组合数，最终结果需除以 2（因每对点被重复计算两次）。

### 解决难点
- **浮点数精度问题**：部分题解使用中点坐标（涉及除法）需处理浮点数，而正确解法直接存储坐标和（整数运算避免精度问题）。
- **时间复杂度优化**：基础解法用 `map` 导致 $O(n^2 \log n)$ 时间，优化后改用哈希表或坐标压缩为整数，降为 $O(n^2)$。

---

## 题解评分 (≥4星)

### 4.5星 - feecle6418
- **亮点**：完整推导几何性质，提供多种优化方案（哈希表、坐标压缩），并实测不同实现的时间对比。
- **代码**：使用 `gp_hash_table` 实现高效哈希，代码简洁高效。
- **优化建议**：未贴出手写哈希代码，但整体思路清晰。

### 4星 - __Creeper__
- **亮点**：数学推导简洁，代码注释明确，适合快速理解核心逻辑。
- **不足**：未讨论优化策略，直接使用 `map` 可能在严格时间限制下超时。

### 4星 - 4041nofoundGeoge
- **亮点**：图文结合解释几何性质，代码结构清晰。
- **不足**：缺乏优化讨论，但基础实现正确。

---

## 最优思路或技巧提炼

### 关键优化技巧
1. **坐标和代替中点**：避免浮点数，直接存储两坐标和 $(x_i + x_j, y_i + y_j)$。
2. **哈希表加速**：使用 `unordered_map` 或 `gp_hash_table` 替代 `map`，时间复杂度从 $O(n^2 \log n)$ 降至 $O(n^2)$。
3. **整数压缩键值**：将两坐标和合并为 `long long` 类型，提升哈希性能。

### 核心代码片段
```cpp
// 预处理坐标和出现次数
gp_hash_table<long long, int> cnt;
for (int i = 1; i <= n; ++i)
    for (int j = i + 1; j <= n; ++j) {
        long long key = (x[i] + x[j]) * 1e10 + (y[i] + y[j]);
        cnt[key]++;
    }

// 统计答案
int ans = 0;
for (int i = 1; i <= n; ++i)
    for (int j = i + 1; j <= n; ++j) {
        long long key = (x[i] + x[j]) * 1e10 + (y[i] + y[j]);
        ans += cnt[key] - 1; // 减去自身
    }
cout << ans / 2; // 每四元组被计算两次
```

---

## 同类型题与算法套路

### 通用解法
- **哈希统计数对性质**：类似题目可将数对的某种特征（如和、差、乘积）哈希化统计。
- **几何性质转化**：将几何条件转化为代数关系（如坐标和、距离公式）后统计。

### 推荐题目
1. **P2638 安全系统**（统计满足条件的数对）
2. **P1630 求和**（哈希统计数对和）
3. **CF702C Cellular Network**（几何关系转化）

---

## 个人心得摘录

### feecle6418
- **踩坑**：初始使用 `map` 导致超时，后改用哈希表和坐标压缩优化。
- **顿悟**：意识到两坐标和可直接合并为整数键，大幅提升性能。

### 小恐
- **教训**：浮点数排序效率低下，改为整数运算后通过。

---

## 可视化与算法演示

### 动画设计
1. **初始化界面**：8位像素风格，坐标系背景，所有点显示为彩色像素块。
2. **枚举点对**：高亮当前点对 $(i,j)$，计算坐标和并存入哈希表（显示为右侧表格）。
3. **统计阶段**：再次枚举点对，哈希表中相同键值高亮，累计计数器增加。
4. **结果展示**：最终答案以复古字体弹出，伴随胜利音效。

### 交互功能
- **步进控制**：按空格单步执行点对枚举，观察哈希表更新。
- **速度调节**：滑块控制动画速度（0.5x~5x）。
- **音效**：哈希表插入时播放“哔”声，统计匹配时播放“叮”声。

### 复古效果
- **调色板**：16色 FC 风格，点对用红/蓝，哈希表键值绿色闪烁。
- **背景音乐**：8位芯片音乐循环播放，结束播放《超级玛丽》过关旋律。

---

## 核心算法演示代码（JS 片段）
```javascript
// 伪代码：绘制像素点对与哈希表
function drawPointPair(i, j, ctx) {
    ctx.fillStyle = '#FF0000'; // 红色像素
    ctx.fillRect(x[i], y[i], 2, 2);
    ctx.fillRect(x[j], y[j], 2, 2);
    let key = (x[i]+x[j]) * 1e10 + (y[i]+y[j]);
    updateHashTableVisual(key); // 更新右侧哈希表显示
}

// 音效触发
function playSound(effect) {
    if (effect === 'hit') new Audio('data:audio/wav;base64,UklGRl...').play();
}
```

---
处理用时：87.28秒
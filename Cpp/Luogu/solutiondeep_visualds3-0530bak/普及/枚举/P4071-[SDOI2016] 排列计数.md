# 题目信息

# [SDOI2016] 排列计数

## 题目描述

求有多少种 $1$ 到 $n$ 的排列 $a$，满足序列恰好有 $m$ 个位置 $i$，使得 $a_i = i$。

答案对 $10^9 + 7$ 取模。

## 说明/提示

#### 数据规模与约定

本题共 20 个测试点，各测试点等分，其数据规模如下表。

| 测试点编号 | $T =$  | $n, m \leq$ |  测试点编号  |      $T =$      | $n, m \leq$ |
| :--------: | :----: | :---------: | :----------: | :-------------: | :---------: |
| $1\sim 3$  | $10^3$ |     $8$     | $10 \sim 12$ |     $10^3$      |   $10^3$    |
| $4 \sim 6$ | $10^3$ |    $12$     | $13 \sim 14$ | $5 \times 10^5$ |   $10^3$    |
| $7 \sim 9$ | $10^3$ |    $100$    | $15 \sim 20$ | $5 \times 10^5$ |   $10^6$    |

对于全部的测试点，保证 $1 \leq T \leq 5 \times 10^5$，$1 \leq n \leq 10^6$，$0 \leq m \leq 10^6$。

## 样例 #1

### 输入

```
5
1 0
1 1
5 2
100 50
10000 5000```

### 输出

```
0
1
20
578028887
60695423```

# AI分析结果



## **算法分类**  
组合数学（错排问题 + 组合数）

---

## **题解思路、算法要点与解决难点**  
### **核心思路**  
1. **组合数选择固定位置**：从 \( n \) 个位置中选择 \( m \) 个位置固定，方案数为 \( C(n, m) \)。  
2. **错排剩余位置**：剩余 \( n-m \) 个位置需满足 \( a_i \neq i \，即错排数 \( D_{n-m} \)。  
3. **递推公式**：错排数递推式为 \( D_i = (i-1)(D_{i-1} + D_{i-2}) \)，边界条件 \( D_0 = 1, D_1 = 0 \)。  

### **解决难点**  
1. **高效计算组合数**：预处理阶乘 \( n! \) 和逆元，通过 \( C(n, m) = \frac{n!}{m!(n-m)!} \) 公式 \( O(1) \) 计算。  
2. **错排递推优化**：预处理错排数列 \( D_i \)，避免重复计算。  
3. **模运算下的逆元**：使用费马小定理求逆元，避免除法操作。  

### **关键实现代码**  
```cpp
// 预处理阶乘、逆元、错排数
void prework() {
    fac[0] = 1;
    for (int i = 1; i < MAXN; i++) fac[i] = fac[i-1] * i % mod;
    inv[MAXN-1] = qpow(fac[MAXN-1], mod-2); // 费马小定理求逆元
    for (int i = MAXN-2; i >= 0; i--) inv[i] = inv[i+1] * (i+1) % mod;
    d[0] = 1; d[1] = 0; d[2] = 1;
    for (int i = 3; i < MAXN; i++) 
        d[i] = (i-1) * (d[i-1] + d[i-2]) % mod;
}

// 计算答案
ans = fac[n] * inv[m] % mod * inv[n-m] % mod * d[n-m] % mod;
```

---

## **题解评分（≥4星）**  
1. **冒泡ioa（赞90）**  
   - **亮点**：通过举例推导错排递推式，代码简洁高效。  
   - **评分**：⭐⭐⭐⭐⭐  
2. **Warriors_Cat（赞8）**  
   - **亮点**：代码清晰，预处理优化到位。  
   - **评分**：⭐⭐⭐⭐  
3. **shadowice1984（赞1）**  
   - **亮点**：代码高度优化，预处理阶乘和逆元一步到位。  
   - **评分**：⭐⭐⭐⭐  

---

## **最优思路提炼**  
1. **错排递推公式**：通过递推式 \( D_i = (i-1)(D_{i-1} + D_{i-2}) \) 快速计算。  
2. **组合数预处理**：阶乘和逆元预处理实现 \( O(1) \) 查询。  
3. **边界特判**：处理 \( n=m \)、\( n-m=1 \) 等边界情况直接返回结果。  

---

## **同类型题与算法套路**  
1. **错排问题**：如 [P1595 信封问题](https://www.luogu.com.cn/problem/P1595)。  
2. **组合数取模**：如 [P3807 卢卡斯定理](https://www.luogu.com.cn/problem/P3807)。  
3. **递推优化**：适用于需要预处理递推数列的题目。  

---

## **推荐类似题目**  
1. **P1595**：基础错排问题。  
2. **P3182**：错排变形（部分位置允许固定）。  
3. **P3223**：组合数 + 递推的综合应用。  

---

## **可视化与算法演示**  
### **核心算法动画设计**  
1. **像素风格排列变化**：  
   - 使用 **8位像素风格** 展示排列，固定位置用绿色方块，错排位置用红色闪烁标记。  
   - **Canvas 动态网格**：每个数字初始在网格中，通过交换动画展示错排过程。  
2. **关键步骤高亮**：  
   - **组合数选择**：高亮当前选择的 \( m \) 个固定位置，逐步填充颜色。  
   - **错排递推**：动态显示 \( D_i \) 的计算过程，例如：  
     - 第 \( i \) 个元素尝试放入第 \( k \) 位，触发递推分支。  
3. **音效与交互**：  
   - **音效**：成功计算时播放上升音调，错误操作时播放短促“哔”声。  
   - **控制面板**：支持暂停、单步执行，调整动画速度观察递推细节。  

### **复古游戏化实现**  
```javascript
// 示例：Canvas 绘制排列网格（伪代码）
const canvas = document.getElementById("pixel-canvas");
const ctx = canvas.getContext("2d");
const gridSize = 20; // 每个方块20x20像素

function drawGrid(n) {
    for (let i = 0; i < n; i++) {
        // 绘制初始排列
        ctx.fillStyle = i === correctPos ? "#00FF00" : "#FF0000";
        ctx.fillRect(i * gridSize, 0, gridSize, gridSize);
    }
}

// 音效触发：错排成功时播放
function playSuccessSound() {
    const audio = new Audio("success.wav"); // 8位音效
    audio.play();
}
```

---

## **个人心得摘录**  
1. **调试教训**：  
   - 初始未处理 \( n-m=1 \) 导致 WA，需特别注意边界条件。  
2. **优化技巧**：  
   - 预处理逆元时，反向遍历计算可减少重复求幂次数。  

---

**总结**：本题通过组合数与错排递推的巧妙结合，展示了组合数学在算法中的高效应用。预处理和模运算优化是解题关键，而像素化动画设计可直观呈现算法核心逻辑。

---
处理用时：80.50秒
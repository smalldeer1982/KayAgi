# 题目信息

# [USACO17DEC] My Cow Ate My Homework S

## 题目描述

在你的牛历史课上，你被布置了一份相当长的作业，包含 $N$ 个问题（$3 \leq N \leq 100,000$），每个问题的得分是一个在 0 到 10,000 之间的整数。按照惯例，你的老师计划通过去掉你得分最低的一个问题，然后对剩余问题的得分取平均来给出最终成绩。不幸的是，你的宠物奶牛 Bessie 刚刚吃掉了你前 $K$ 个问题的答案！（$K$ 可能小到 1，也可能大到 $N-2$）。

经过多次解释，你的老师终于相信了你的说法，并同意按照之前的方式对剩余的未被吃掉的部分作业进行评分——即去掉得分最低的问题（或在得分相同的情况下去掉其中一个），然后对剩余问题取平均。

请输出所有能够使你获得最高可能成绩的 $K$ 值，并按升序排列。

## 说明/提示

如果 Bessie 吃掉了前两个问题，那么剩余的得分是 9、2 和 7。去掉最低分并取平均后，最终成绩为 8，这是可能的最高成绩。

## 样例 #1

### 输入

```
5
3 1 9 2 7```

### 输出

```
2```

# AI分析结果



---

**算法分类**  
预处理与后缀处理

---

### **核心思路与难点分析**

1. **问题转化**  
   需要找到所有可能的K，使得剩余区间`[K+1, N]`去掉最小值后的平均值最大。关键在于高效计算每个K对应的区间最小值、总和。

2. **预处理技术**  
   - **后缀最小值数组**：从后向前遍历，记录每个位置到末尾的最小值。  
   - **后缀和数组**：从后向前累加，记录每个位置到末尾的总和。  
   - 通过预处理，每个K的计算复杂度降为O(1)。

3. **难点对比**  
   - **线段树/分块**：时间复杂度O(N log N)或O(N√N)，代码复杂。  
   - **集合维护**：每次插入/删除元素导致O(N log N)复杂度，常数大。  
   - **最优解法**：预处理后缀数组，时间复杂度O(N)，代码简洁高效。

---

### **题解评分 (≥4星)**

1. **作者：_jimmywang_ (⭐⭐⭐⭐⭐)**  
   - **亮点**：预处理后缀最小值和总和，代码简洁，时间复杂度O(N)。  
   - **关键代码**：  
     ```cpp  
     for(int i=n; i>=2; i--) {  
         mn[i] = min(mn[i+1], a[i]);  
         sum[i] = sum[i+1] + a[i];  
     }  
     ```

2. **作者：Siyuan (⭐⭐⭐⭐⭐)**  
   - **亮点**：动态维护最大值和结果数组，避免额外空间，边计算边更新。  
   - **关键代码**：  
     ```cpp  
     for(int i=n-1; i>=2; i--) {  
         mins = min(mins, s[i]);  
         sum += s[i];  
         if (当前平均值 > 历史最大值) 更新结果数组;  
     }  
     ```

3. **作者：TRZ_2007 (⭐⭐⭐⭐)**  
   - **亮点**：前缀和与后缀最小值结合，逻辑清晰，处理浮点数精度。  
   - **关键代码**：  
     ```cpp  
     Min[i] = min(Min[i+1], a[i]);  
     Score = (sum[n] - sum[i] - Min[i+1]) / (n-i-1);  
     ```

---

### **最优思路提炼**

1. **预处理后缀数组**  
   - 倒序遍历数组，计算每个位置到末尾的最小值和总和。  
   - 公式：`avg(K) = (sum[K+1] - min_val) / (N - K - 1)`  

2. **边遍历边更新结果**  
   - 维护当前最大平均值，若发现更大值则清空结果集，若相等则追加。

---

### **相似题目推荐**

1. **滑动窗口最小值**（P1886）  
   - 需维护窗口内的最小值，适合单调队列/栈练习。  
2. **最大子数组和**（P1115）  
   - 预处理前缀和，结合动态规划思想。  
3. **区间和查询**（P3374）  
   - 线段树/前缀和的应用，与预处理思想相关。

---

### **可视化算法演示**

**动画设计**：  
1. **初始化**：数组高亮显示，从右向左逐步填充后缀最小值和总和。  
2. **遍历K值**：滑动K的标记，显示当前区间`[K+1, N]`，红色标记最小值，绿色显示总和。  
3. **计算平均值**：动态公式显示，更新最大值并记录K。  
4. **复古风格**：  
   - **像素网格**：数组元素用8-bit方块表示，颜色区分数值大小。  
   - **音效**：移动时播放“滴”声，找到最大值时播放胜利音效。  
   - **自动模式**：按设定速度逐步展示处理过程。

---

### **核心代码片段**

```cpp
// 预处理后缀最小值和总和
int a[N], mn[N], sum[N];
for (int i = n; i >= 1; i--) {
    mn[i] = (i == n) ? a[i] : min(a[i], mn[i+1]);
    sum[i] = (i == n) ? a[i] : sum[i+1] + a[i];
}

// 计算每个K的得分
vector<int> ans;
double max_avg = 0;
for (int k = 1; k <= n-2; k++) {
    int cnt = n - k - 1;
    double avg = (sum[k+1] - mn[k+1]) * 1.0 / cnt;
    if (avg > max_avg) {
        max_avg = avg;
        ans.clear();
        ans.push_back(k);
    } else if (avg == max_avg) {
        ans.push_back(k);
    }
}
```

---

通过预处理后缀数组，算法在时间和空间上均达到最优，是解决此类区间查询问题的经典范式。

---
处理用时：95.41秒
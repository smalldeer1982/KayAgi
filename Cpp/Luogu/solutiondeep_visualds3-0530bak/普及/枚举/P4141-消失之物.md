# 题目信息

# 消失之物

## 题目描述

ftiasch 有 $n$ 个物品, 体积分别是 $w_1,w_2,\dots,w_n$。由于她的疏忽，第 $i$ 个物品丢失了。   

“要使用剩下的 $n-1$ 物品装满容积为 $x$ 的背包，有几种方法呢？”——这是经典的问题了。  

她把答案记为 $\text{cnt}(i,x)$ ，想要得到所有$i \in [1,n]$, $x \in [1,m]$ 的 $\text{cnt}(i,x)$ 表格。

![](https://cdn.luogu.com.cn/upload/pic/13426.png)


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n,m \le 2000$，且 $1\le v_i\le m$。

【样例解释】  
如果物品 3 丢失的话，只有一种方法装满容量是 2 的背包，即选择物品 1 和物品 2。

---

$\text{upd 2023.8.11}$：新增加五组 Hack 数据。


## 样例 #1

### 输入

```
3 2
1 1 2```

### 输出

```
11
11
21```

# AI分析结果



## 算法分类
动态规划（退背包）

---

## 题解思路与核心分析

### 核心算法流程
1. **完整背包计算**：先通过标准01背包计算所有物品的方案数数组f
2. **退背包处理**：对每个物品i，通过正序遍历体积，逆向消除该物品的贡献
3. **递推公式**：`g[j] = (f[j] - g[j-w_i] + 10) % 10`（处理负数并取模）

### 解决难点
- **时间复杂度**：直接暴力重算n次背包会达到O(n²m)，通过退背包优化到O(nm)
- **空间优化**：仅使用一维数组，通过逆序计算和正序撤销实现空间复用
- **负数处理**：通过+10再取模保证结果为非负

---

## 题解评分（≥4星）

1. **Kelin（★★★★★）**  
   - 思路清晰，代码极简  
   - 使用memcpy+顺推撤销操作直观易懂  
   - 时间复杂度严格O(nm)  
   - 关键代码片段：  
     ```cpp
     memcpy(g,f,sizeof f);
     for(int j=w[i];j<=m;++j)
         g[j] = (g[j] - g[j-w[i]] + 10) % 10;
     ```

2. **Gary818（★★★★☆）**  
   - 数学推导明确，注释详细  
   - 变量命名清晰，逻辑自洽  
   - 递推式`g[j] = f[j]-g[j-w[i]]` 直观体现核心思想  
   - 关键优化：`+10`处理负数取模

3. **7KByte（★★★★☆）**  
   - 从算法正确性角度给出严谨证明  
   - 代码实现简洁，体现撤销操作本质  
   - 时间复杂度分析明确  

---

## 最优思路与技巧

**退背包核心公式**：  
```
g[j] = (总方案数f[j] - 必选i的方案数g[j-w_i]) % mod
```
**实现要点**：
1. **正序撤销**：与原始背包的逆序计算对称
2. **空间复用**：通过临时数组避免修改原数组
3. **模运算优化**：+10后取模保证结果非负

---

## 同类型题拓展
1. **多重背包计数**：通过类似思路处理物品数量限制
2. **带删除操作的动态维护**：实时维护可删集合的背包方案
3. **分组背包容斥**：通过补集思想处理分组限制

---

## 推荐练习题
1. P1776 宝物筛选（多重背包优化）
2. P2014 选课（树形背包）
3. P4095 [HEOI2013] Eden的新背包问题（多重退背包）

---

## 代码实现（Kelin解法）
```cpp
#include <cstring>
#include <iostream>
using namespace std;

const int N = 2010;
int n, m, w[N], f[N], g[N];

int main() {
    cin >> n >> m;
    for(int i=1; i<=n; ++i) cin >> w[i];
    
    f[0] = 1;
    for(int i=1; i<=n; ++i)
        for(int j=m; j>=w[i]; --j)
            f[j] = (f[j] + f[j-w[i]]) % 10;
    
    for(int i=1; i<=n; ++i) {
        memcpy(g, f, sizeof f);
        for(int j=w[i]; j<=m; ++j)
            g[j] = (g[j] - g[j-w[i]] + 10) % 10;
        
        for(int j=1; j<=m; ++j)
            cout << g[j];
        cout << endl;
    }
    return 0;
}
```

---

## 可视化设计（复古像素风格）

### 动画要素：
1. **背包矩阵**：8-bit风格网格展示f数组变化
2. **高亮元素**：
   - 当前处理的物品（闪烁红框）
   - 正在更新的体积j（黄框）
   - 被减去的j-w_i位置（蓝框）
3. **音效设计**：
   - 正向转移：短促"滴"声
   - 逆向撤销：低音"嘟"声
   - 完成计算：8-bit胜利音效

### 交互功能：
- **步进控制**：方向键控制执行速度
- **物品切换**：数字键1~n快速查看不同物品的撤销过程
- **数值追踪**：点击任意体积显示计算路径

---

## 算法演示示例
**初始状态**：
```
f = [1,0,0]
物品1（w=1）处理后：
f = [1,1,0]
```

**撤销物品1的步骤**：
```
g初始拷贝f: [1,1,0]
正序处理j=1~2:
j=1: g[1] -= g[0] → 1-1=0
j=2: g[2] -= g[1] → 0-0=0
最终g = [1,0,0]
```

**像素动画**：  
![退背包动画示例](https://via.placeholder.com/200x150/000000/FFFFFF/?text=退背包动画)  
（红框跟随j移动，蓝框显示j-w_i，数值变化伴随像素特效）

---
处理用时：138.01秒
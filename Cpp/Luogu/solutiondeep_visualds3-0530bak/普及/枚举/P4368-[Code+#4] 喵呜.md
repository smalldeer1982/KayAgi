# 题目信息

# [Code+#4] 喵呜

## 题目描述

在马路边有一排整齐的 $n$ 棵樱花树，每棵树的高度都恰好为 $h$。某天，一只可爱的小猫偶然跑到树上来玩，但是这只小猫有些对樱花过敏，所以她现在想赶快离开这些樱花树。

具体来说，现在小猫位于第 $x$ 棵樱花树上高度为 $y$ 的位置，她可以通过两种跳跃来离开樱花树：

轻轻跳：向左或向右移动 $a$ 棵樱花树的同时，所在高度下降 $b$，即一次轻轻跳可以从起点移动到第 $x+a$ 或 $x-a$ 棵树上高度为 $y-b$ 的位置，注意当小猫所在高度不大于 $b$ 时不可以使用轻轻跳。

使劲跳：向左或向右移动 $a$ 棵樱花树的同时，所在高度上升 $b$，即一次使劲跳可以从起点移动到第 $x+a$ 或 $x-a$ 棵树上高度为 $y+b$ 的位置，注意当小猫所在高度大于 $h-b$ 时不可以使用使劲跳。

为了离开这片樱花树，小猫需要移动到第 $1$ 或第 $n$ 棵树上，高度为 $h$ 或 $1$ 的位置（这样她可以呼吸新鲜空气或者直接走开樱花树）。现在小猫想知道，自己最少需要多少次跳跃才能达成目标。由于她是一只可爱的小猫，所以希望由你来告诉她。


## 说明/提示

| 测试点编号 | $n,h$ 的范围 | 特殊约定 |
| :----------: | :----------: | :----------: |
|$1,2$  | $\le10$ | $b=1$ |
|$3,4$  |  $\le10$| $a=b=1$ |
|$5,6,7,8$  |$\le10$  | 无 |
|$9,10$  | $\le500$ | $b=1$ |
|  $11,12$| $\le500$ | $a=b=1$ |
|$13,14,15$  | $\le500$ | 无 |
|$16,17$  | $\le10^5$ | $h\le10$ |
|$18,19,20$  | $\le10^5$ | 无 |
| $21,22$ | $\le10^{15}$ | $h\le10$ |
| $23,24,25$ | $\le10^{15}$ | 无 |

对于所有数据，保证 $n \geq 2$，$a < n$，$b \leq h$。

Credit: https://www.luogu.org/discuss/show/38908

## 样例 #1

### 输入

```
3
5 5 3 3 2 2
5 7 3 5 2 2
5 7 4 6 1 1```

### 输出

```
1
1
1```

## 样例 #2

### 输入

```
3
5 5 3 3 3 2
5 7 1 4 2 2
5 7 1 2 1 2```

### 输出

```
-1
-1
-1```

## 样例 #3

### 输入

```
4
999999999999 999999999999 454545454545 454545454545 1 1
777777777777 777777777777 343434343434 343434343434 1 1
777777777777 999999999999 343434343434 454545454545 1 1
999999999999 777777777777 454545454545 343434343434 1 1```

### 输出

```
454545454544
343434343433
-1
-1```

# AI分析结果



## 【唯一算法分类】
数学

---

## 【题解思路、算法要点与解决难点】

### **核心思路**
1. **方向步数整除性**：水平（x轴）和垂直（y轴）移动的步数必须分别为 `a` 和 `b` 的倍数。
2. **步数差奇偶性**：两个方向步数差需为偶数，确保在某一方向到达终点后，另一方向可通过“来回跳跃”调整同步到达。

### **关键实现**
1. **计算四个角的步数**：对每个目标角，计算水平和垂直方向的最小步数。
   - 水平方向：左边界 `x-1` 和右边界 `n-x` 是否能被 `a` 整除。
   - 垂直方向：下边界 `y-1` 和上边界 `h-y` 是否能被 `b` 整除。
2. **组合判断**：枚举所有水平和垂直步数的组合（共4种），检查步数差的奇偶性，取满足条件的最小最大值。

### **解决难点**
- **同步调整**：当某一方向提前到达边界时，需通过交替跳跃（如上下或左右反复）保持位置不变，此时步数差必须为偶数。

---

## 【题解评分 (≥4星)】

1. **Rosemary_dream (4星)**  
   - **亮点**：代码简洁，核心逻辑清晰，直接枚举四个方向的步数组合，通过奇偶性判断快速筛选可行解。
   - **代码片段**：
     ```cpp
     if ((~m[0][i]) && (~m[1][j]) && (m[1][j] - m[0][i]) % 2 == 0) {
         ll temp = max(m[1][j], m[0][i]);
         if (ans > temp || !(~ans)) ans = temp;
     }
     ```

2. **3_soon (4星)**  
   - **亮点**：详细注释和数学推导，将问题拆解为水平和垂直方向独立分析，最终合并判断。
   - **代码片段**：
     ```cpp
     For(i,0,1) For(j,0,1) {
         if (p[0][i] != -1 && p[1][j] != -1 && (p[1][j] - p[0][i]) % 2 == 0) {
             LL pp = mmax(p[1][j], p[0][i]);
             if (ans == -1 || ans > pp) ans = pp;
         }
     }
     ```

3. **liangledong (4星)**  
   - **亮点**：通过条件分步判断，清晰解释每个方向的可行性，代码结构易于扩展。
   - **代码片段**：
     ```cpp
     if((x-1)%a==0&&(h-y)%b==0){
         if(((x-1)/a-(h-y)/b)%2==0)ans=min(ans,max((x-1)/a,(h-y)/b));
     }
     ```

---

## 【最优思路或技巧提炼】

1. **分方向独立计算**：水平和垂直方向的步数单独计算，再合并判断。
2. **奇偶性同步**：用步数差是否为偶数判断能否通过调整达到同步。
3. **极值取最小**：所有可行解中取 `max(水平步数, 垂直步数)` 的最小值。

---

## 【同类型题或类似算法套路】

- **数论条件组合**：如判断两个变量的整除性和奇偶性组合。
- **网格跳跃问题**：类似棋盘上的跳跃问题，需同时满足多维度条件。

---

## 【推荐相似题目】

1. **P1219 八皇后**（路径条件判断）
2. **P1032 字变换**（状态转移与步数计算）
3. **P1141 01迷宫**（广度优先搜索中的条件判断）

---

## 【可视化与算法演示】

### **动画设计**
1. **网格绘制**：以樱花树为网格，小猫初始位置高亮为红色，目标角为绿色。
2. **步数计算**：动态显示水平和垂直方向的步数计算过程，颜色标记能否整除。
3. **奇偶性检查**：用闪烁效果标记满足奇偶性条件的步数组合。
4. **路径模拟**：对最优解，显示小猫跳跃路径，每次跳跃后位置更新。

### **复古像素风格**
- **颜色方案**：使用16色调色板，红色小猫、绿色终点、灰色障碍。
- **音效设计**：
  - **跳跃音效**：每次跳跃播放8位“滴”声。
  - **成功音效**：达成目标时播放胜利旋律。
  - **失败音效**：无解时播放低沉音效。

### **交互功能**
- **步进控制**：允许单步执行，观察每一步的整除性和奇偶性判断。
- **自动演示**：AI自动选择最优路径，动态显示计算逻辑。

---

## 【核心代码实现】

```cpp
#include <iostream>
using namespace std;
using ll = long long;

int main() {
    int T; cin >> T;
    while (T--) {
        ll n, h, x, y, a, b;
        cin >> n >> h >> x >> y >> a >> b;
        
        // 计算四个方向的步数
        ll left = (x-1) % a == 0 ? (x-1)/a : -1;
        ll right = (n-x) % a == 0 ? (n-x)/a : -1;
        ll down = (y-1) % b == 0 ? (y-1)/b : -1;
        ll up = (h-y) % b == 0 ? (h-y)/b : -1;
        
        ll ans = -1;
        // 枚举所有组合
        for (int dx : {left, right}) {
            for (int dy : {down, up}) {
                if (dx != -1 && dy != -1 && (dx - dy) % 2 == 0) {
                    ll steps = max(dx, dy);
                    ans = (ans == -1) ? steps : min(ans, steps);
                }
            }
        }
        cout << ans << endl;
    }
    return 0;
}
```

---

## **可视化代码片段（Canvas动画）**

```javascript
// 绘制网格和初始状态
ctx.fillStyle = '#FF0000'; // 小猫红色
ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);

// 高亮目标角
ctx.fillStyle = '#00FF00'; // 终点绿色
targets.forEach(([tx, ty]) => {
    ctx.fillRect(tx * cellSize, ty * cellSize, cellSize, cellSize);
});

// 播放音效
function playSound(effect) {
    const audio = new Audio(`sfx/${effect}.wav`);
    audio.play();
}
```

---
处理用时：85.73秒
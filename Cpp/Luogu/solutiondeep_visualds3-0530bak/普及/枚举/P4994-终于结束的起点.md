# 题目信息

# 终于结束的起点

## 题目背景

> 终于结束的起点  
> 终于写下句点  
> 终于我们告别  
> 终于我们又回到原点  
> ……

一个个 OIer 的竞赛生涯总是从一场 NOIp 开始，大多也在一场 NOIp 中结束，好似一次次轮回在不断上演。  
如果这次 NOIp 是你的起点，那么祝你的 OI 生涯如同夏花般绚烂。  
如果这次 NOIp 是你的终点，那么祝你的 OI 回忆宛若繁星般璀璨。  
也许这是你最后一次在洛谷上打比赛，也许不是。  
不过，无论如何，祝你在一周后的比赛里，好运。

当然，这道题也和轮回有关系。

## 题目描述

广为人知的斐波拉契数列 $\mathrm{fib}(n)$ 是这么计算的

$$
\mathrm{fib}(n)=\begin{cases}
0,& n=0 \\
1,& n=1 \\
\mathrm{fib}(n-1) + \mathrm{fib}(n-2),& n>1
\end{cases}
$$

也就是 $0, 1, 1, 2, 3, 5, 8, 13 \cdots$，每一项都是前两项之和。

小 F 发现，如果把斐波拉契数列的每一项对任意大于 $1$ 的正整数 $M$ 取模的时候，数列都会产生循环。

当然，小 F 很快就明白了，因为 ($\mathrm{fib}(n - 1) \bmod M$) 和 ($\mathrm{fib}(n - 2) \bmod M)$ 最多只有 $M ^ 2$ 种取值，所以在 $M  ^ 2$ 次计算后一定出现过循环。

甚至更一般地，我们可以证明，无论取什么模数 $M$，最终模 $M$ 下的斐波拉契数列都会是 $0, 1, \cdots, 0, 1, \cdots$。

现在，给你一个模数 $M$，请你求出最小的 $n > 0$，使得 $\mathrm{fib}(n) \bmod M = 0, \mathrm{fib}(n + 1) \bmod M = 1$。

## 说明/提示

#### 样例 1 解释

斐波拉契数列为 $0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \cdots$，在对 $2$ 取模后结果为 $0, 1, 1, 0, 1, 1, 0, 1, 1, 0, \cdots$。

我们可以发现，当 $n = 3$ 时，$f(n) \bmod 2= 0, f(n + 1) \bmod 2 = 1$，也就是我们要求的 $n$ 的最小值。

#### 数据范围

对于 $30\%$ 的数据，$M \leq 18$；

对于 $70\%$ 的数据，$M \leq 2018$；

对于 $100\%$ 的数据，$2 \leq M \leq 706150=\verb!0xAC666!$。

#### 提示

如果你还不知道什么是取模 $(\bmod)$，那我也很乐意告诉你，模运算是求整数除法得到的余数，也就是竖式除法最终「除不尽」的部分，也即
$$a \bmod M =k \iff a = bM + k\ (M > 0, 0 \leq k < M)$$
其中 $a, b, k$ 都是非负整数。

如果你使用 `C` / `C++`，你可以使用 `%` 来进行模运算。

如果你使用 `Pascal`，你可以使用 `mod` 来进行模运算。

## 样例 #1

### 输入

```
2```

### 输出

```
3```

## 样例 #2

### 输入

```
6```

### 输出

```
24```

# AI分析结果



**唯一算法分类**: 模运算与循环节（皮萨诺周期）

---

### 算法分析与结论

**核心思路**：  
寻找斐波那契数列模 \( M \) 后首次出现连续两项为 \( (0, 1) \) 的最小 \( n \)。利用皮萨诺周期理论，循环节长度不超过 \( 6M \)，因此暴力枚举是可行方案。

**难点对比**：  
1. **暴力法**：需高效存储中间结果（如记忆化数组或迭代计算）。  
2. **数论分解法**：需质因数分解 \( M \)，并计算每个质因数的皮萨诺周期，涉及二次剩余判断。  
3. **矩阵快速幂/BSGS**：数学推导复杂，代码实现难度高。  

**最优思路**：  
直接暴力模拟，迭代计算斐波那契数列模 \( M \)，直到出现 \( (0, 1) \) 的连续项。时间复杂度 \( O(M) \)，适用于 \( M \leq 7 \times 10^5 \) 的数据范围。

---

### 高星题解清单（≥4星）

1. **CzxingcHen（5星）**  
   - **亮点**：引用皮萨诺周期理论，结合数学证明，解释暴力正确性。  
   - **代码片段**：无需代码，理论分析透彻。  

2. **万弘（4星）**  
   - **亮点**：记忆化递归优化，避免重复计算，代码可读性强。  
   - **代码片段**：  
     ```cpp
     ll f(ll i) {
         if (fp[i]) return fp[i];
         if (i == 1 || i == 2) return fp[i] = 1 % m;
         return fp[i] = (f(i-1) + f(i-2)) % m;
     }
     ```

3. **Catalan1906（4星）**  
   - **亮点**：简洁的迭代实现，利用 `vector` 存储中间结果。  
   - **代码片段**：  
     ```cpp
     std::vector<ll> f;
     f.push_back(0); f.push_back(1);
     for (/*...*/) {
         f.push_back((f[i-2] + f[i-1]) % m);
         if (f.back() == 1 && f[i-1] == 0) break;
     }
     ```

---

### 最优代码实现

**核心逻辑**：迭代计算斐波那契数列模 \( M \)，直接检查连续两项是否满足条件。

```cpp
#include <vector>
#include <cstdio>
typedef long long ll;

int main() {
    ll m;
    scanf("%lld", &m);
    std::vector<ll> fib = {0, 1}; // 初始值 fib[0]=0, fib[1]=1
    for (int i = 2;; i++) {
        ll next = (fib[i-1] + fib[i-2]) % m;
        fib.push_back(next);
        if (fib[i-1] == 0 && fib[i] == 1) {
            printf("%d\n", i-1);
            break;
        }
    }
    return 0;
}
```

---

### 可视化设计

**动画方案**：  
1. **网格绘制**：在 Canvas 上以网格展示斐波那契数列模 \( M \) 的计算过程。  
2. **颜色标记**：  
   - **当前项**：红色高亮。  
   - **目标项（0,1）**：绿色背景。  
3. **步进控制**：允许单步执行或调整速度，观察每一步的模运算结果。  
4. **复古像素风格**：  
   - **UI**：8位像素字体，16色调色板（红、绿、蓝）。  
   - **音效**：每次计算播放“哔”声，找到解时播放胜利音效。  

**交互示例**：  
```javascript
// 伪代码：Canvas 绘制斐波那契模运算
function drawStep(i, fib_i) {
    ctx.fillStyle = "#FF0000"; // 当前项红色
    ctx.fillRect((i % 10) * 30, Math.floor(i/10) * 30, 28, 28);
    ctx.fillText(fib_i, (i % 10)*30 + 10, Math.floor(i/10)*30 + 15);
}
```

---

### 相似题目推荐

1. **P5175 数列**（矩阵快速幂求斐波那契）  
2. **P1306 斐波那契公约数**（GCD 性质与斐波那契）  
3. **P4000 斐波那契数列**（大范围模运算优化）  

---

**个人心得**：  
- **CzxingcHen** 提到通过 OEIS 发现皮萨诺周期，启示数学理论对暴力法的验证。  
- **Misaka19280** 强调“暴力出奇迹”，实测循环节长度远小于理论值。  

通过结合理论分析与暴力实现，此题可在合理时间内解决，无需复杂优化。

---
处理用时：70.69秒
# 题目信息

# 准备战斗，选择你的英雄

## 题目背景

zjf，被 NOIP 普及组初赛戏耍，pj 1= -> 初赛三等，愤恨地离开了 OI，深陷中考的泥潭当中。据说，他颓废是因为玩多了 [OW](https://ow.blizzard.cn/home) 这款游戏。

## 题目描述

目前，游戏共有 $31$ 个英雄，每局可以派 $6$ 个英雄上场。实际能使用的英雄数将会小于 $31$。简单地假设，每位英雄对团队的贡献可以用一个正整数 $v_i$ 表示。团队的总能力等于所有英雄的贡献之和。特别地，对于 $m$ 组特定的英雄，他们一起出现会让团队总能力提高 $x_i$。

**另注：英雄组合可以重复，若重复请多次计数。**

## 说明/提示

#### 样例 1 解释
我们应该选择前 $6$ 名英雄。

---

#### 样例 2 解释
我们应该选择 Pharah、Mercy、Reinhardt、DVA、SOLDIER:76、Anna

---

#### 数据范围
对于 $40\%$ 的数据，$m=0$。  
对于 $100\%$ 的数据，$6\le n \le 30$，$0\le m \le 30$，*$1\le x_i,v_i \le 100$*，英雄名字长度 $\le 10$，字符集包括大小写字母、数字以及冒号（ `:` ）。每个英雄的名字各不相同。


## 样例 #1

### 输入

```
7 0
Sigma 10
Orisa 10
Mei 10
Reaper 10
Moira 10
Lucio 10
Doomfist 1```

### 输出

```
60```

## 样例 #2

### 输入

```
8 2
Pharah 5
Mercy 5
Reinhardt 10
DVA 10
SOLDIER:76 12
Torbjorn 5
Anna 8
Baptiste 10
Pharah Mercy 20
Anna Pharah 5```

### 输出

```
75```

# AI分析结果



---

**唯一算法分类**  
暴力枚举/回溯  

---

**综合分析与结论**  
题目核心为从n个英雄中选6人，使得基础贡献与组合加成之和最大。所有题解均采用暴力枚举思路，通过生成所有C(n,6)组合并计算总贡献。核心难点在于高效处理组合加成和避免重复计算。  

**可视化设计思路**  
1. **组合生成动画**：用DFS或六重循环的逐层展开动画，高亮当前选中英雄的编号（如像素方块）。  
2. **组合加成计算**：用颜色标记所有存在加成的英雄对，累加时显示数值浮动。  
3. **复古风格**：使用16色像素风格，用不同颜色方块表示英雄，选中时播放8-bit音效。  

---

**题解清单 (≥4星)**  
1. **lzqy_ (⭐⭐⭐⭐⭐)**  
   - 清晰DFS框架，通过`a[kk]`记录组合顺序。  
   - 用`together[i][j]`存储组合加成，强调`+=`处理重复边。  
   - 模拟函数`moni()`独立处理总贡献计算，模块化清晰。  

2. **gyh20 (⭐⭐⭐⭐)**  
   - 六重循环暴力枚举，代码极简。  
   - 直接展开所有C(n,6)组合，两两计算组合加成。  
   - 预处理`g[x][y]`累加，避免重复逻辑。  

3. **袁宇轩 (⭐⭐⭐⭐)**  
   - 回溯剪枝优化，利用`a[kk-1]`避免重复组合。  
   - 组合贡献计算时双重循环遍历已选英雄，避免冗余判断。  

---

**最优思路与技巧提炼**  
1. **组合生成优化**：按顺序生成组合（如DFS中`for(int i=a[kk-1]; ...)`），避免重复枚举。  
2. **贡献计算分离**：单独函数处理总贡献，遍历已选英雄的两两组合，累加`g[i][j]`。  
3. **数据结构选择**：用`map`或哈希表快速转换英雄名与编号。  

---

**同类型题推荐**  
1. **P1036 选数**：从n个数中选k个，判断素数组合数。  
2. **P1157 组合的输出**：输出C(n,r)所有组合。  
3. **P2392 kkksc03考前临时抱佛脚**：分组资源分配，类似组合优化。  

---

**个人心得摘录**  
- *chenpengda*：未用`+=`处理组合加成导致70→30分，强调输入处理细节。  
- *sipu6174*：尝试贪心失败后回归暴力，体现算法选择的务实性。  

---

**代码核心实现**  
```cpp
// 选自 gyh20 题解，六重循环暴力枚举
int main() {
    // ... 输入处理
    for(re int a=1;a<=n;++a)
        for(re int b=a+1;b<=n;++b)
            for(re int c=b+1;c<=n;++c)
                for(re int d=c+1;d<=n;++d)
                    for(re int e=d+1;e<=n;++e)
                        for(re int f=e+1;f<=n;++f)
                            ans=max(ans, val[a]+...+g[a][b]+...+g[e][f]);
    printf("%d",ans);
}
```

---

**可视化与复古游戏化设计**  
1. **像素风格界面**：  
   - 英雄用16x16像素方块表示，颜色随机生成。  
   - 选中英雄时方块闪烁，播放“哔”声效。  
2. **动画流程**：  
   - **自动模式**：AI自动展开六重循环，高亮当前循环变量。  
   - **手动步进**：按空格逐步执行，观察组合生成过程。  
3. **音效设计**：  
   - 选中英雄：短促“滴”声。  
   - 找到更优解：上扬“胜利”音效。  
4. **Canvas绘制**：  
   - 网格排列30个英雄，点击触发选中状态。  
   - 组合加成线动态连接，显示加成值。  

![算法演示截图](https://via.placeholder.com/600x400/000/fff?text=Pixel+Style+Algorithm+Viz)  
（示意图：左侧英雄网格，右侧实时显示当前组合及总贡献）

---
处理用时：72.34秒
# 题目信息

# [YsOI2020] 植树

## 题目背景


Ysuperman 响应号召，决定在幼儿园里植树。

## 题目描述

Ysuperman 有一棵 $n$ 个节点的无根树 $T$。如果你不知道树是什么，TA 很乐意告诉你，树是一个没有环的无向联通图。

既然树是无根的，那就没有办法种植。Ysuperman 研究了很久的园艺，发现一个节点如果可以成为根，它必须十分平衡，这意味着以它为根时，与它**直接相连的节点，他们的子树大小都相同**。

你作为幼儿园信息组一把手，Ysuperman 给你一棵树，你能在 $1s$ 内找到所有可能成为根的节点吗？

## 说明/提示

### 样例说明

#### 样例说明 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/gsiug69y.png)

以 $1$ 为根时，与 $1$ 直接相连的点有 $\{2\}$，因为只有一个所以大小全部相同。

以 $2$ 为根时，与 $2$ 直接相连的点有 $\{1\}$，因为只有一个所以大小全部相同。

所以答案为 $1,2$。

#### 样例说明 $2$

![](https://cdn.luogu.com.cn/upload/image_hosting/p7fsretv.png)

以 $1$ 为根时，与 $1$ 直接相连的点有 $\{2\}$，因为只有一个所以大小全部相同。

以 $2$ 为根时，与 $2$ 直接相连的点有 $\{1,3\}$，子树大小分别为 $\{1,2\}$，不相同。

以 $3$ 为根时，与 $3$ 直接相连的点有 $\{2,4\}$，子树大小分别为 $\{2,1\}$，不相同。

以 $4$ 为根时，与 $4$ 直接相连的点有 $\{3\}$，因为只有一个所以大小全部相同。

所以答案为 $1,4$。

----

### 数据范围

**本题采用捆绑测试。**

| $\rm{subtask}$ | $n$ |  分数|
| :-----------: | :-----------: | :----: |
| $1$ | $\le 5000$ | $40$ |
| $2$ | $\le 10^6$ | $60$ |

对于 $100\%$ 的数据，满足 $1 \le n\le 10^6$。

------

### 提示

由于输入输出量较大，你可能需要快速输入/输出。

## 样例 #1

### 输入

```
2
1 2
```

### 输出

```
1 2 ```

## 样例 #2

### 输入

```
4
1 2
2 3
3 4
```

### 输出

```
1 4 
```

## 样例 #3

### 输入

```
9
1 2
1 3
4 1
5 1
1 6
1 9
8 1
1 7
```

### 输出

```
1 2 3 4 5 6 7 8 9 
```

# AI分析结果



## 唯一算法分类  
**树的遍历与子树分析**

---

## 综合分析与结论  
### 核心算法流程  
1. **子树大小计算**：通过一次 DFS 遍历，计算以任意初始根（如 1）为基准的每个节点的子树大小 `sz[x]`。  
2. **相邻子树判定**：对于每个节点 x，遍历其所有直接相连的节点：  
   - 若相连节点是子节点，取其 `sz` 值  
   - 若相连节点是父节点（非根时），取 `n - sz[x]`  
   - 要求所有相邻节点的 `sz` 值相同  

### 可视化设计要点  
**动画方案**：  
- **颜色标记**：  
  - 红色高亮当前遍历节点  
  - 绿色标记已计算子树大小的节点  
  - 黄色框标注重心候选节点  
- **步进控制**：  
  展示 DFS 递归过程，子树大小数值实时更新  
- **像素风格**：  
  树节点用 8 位像素块表示，父子关系用连线连接，子树大小以数字显示在节点旁  

---

## 题解清单 (4星及以上)  
### 1. WanderingTrader (★★★★★)  
**关键亮点**：  
- 在 DFS 中同步判断子树大小一致性  
- 用 `num` 变量记录首个子树大小，简化比较逻辑  
- 处理父方向子树时仅需一行判断  

### 2. Imakf (★★★★)  
**关键亮点**：  
- 提出重心可能为候选的优化思路  
- 提供官方出题人代码参考  

### 3. ____OccDreamer (★★★★)  
**关键亮点**：  
- 详细图解子树变化逻辑  
- 代码中显式处理父节点方向计算  

---

## 最优思路提炼  
### 关键技巧  
```cpp
// 在 DFS 中同步完成判定（伪代码）
void dfs(int x) {
  int num = 0;
  for (子节点 y : x的邻接表) {
    if (y是父节点) continue;
    dfs(y);
    sz[x] += sz[y];
    if (num == 0) num = sz[y];  // 记录首个子树大小
    else if (num != sz[y]) flag = false; // 发现不一致
  }
  sz[x]++; // 包含自身
  // 检查父方向子树
  if (x不是根 && num != n - sz[x]) flag = false;
}
```

### 思维突破点  
- **单向遍历多向判定**：通过一次 DFS 即可完成所有候选节点的判定  
- **父方向子树计算**：利用 `n - sz[x]` 避免重新遍历  

---

## 同类题目推荐  
1. **P1395 会议**（树的重心应用）  
2. **P1352 没有上司的舞会**（树形 DP 基础）  
3. **P2015 二叉苹果树**（子树保留问题）  

---

## 个人心得摘录  
> "处理根节点时要注意特判，父方向的 `n - sz[x]` 在根节点不存在，必须跳过比较" —— WanderingTrader  
> "先画图理解子树变化规律，再转化为数学公式 `sz[fa] = total - sz[x]`" —— ____OccDreamer  

---

## 算法可视化代码片段  
```javascript
// 伪代码：Canvas 绘制树结构
class TreeNode {
  constructor(x, y, size) {
    this.x = x;
    this.y = y;
    this.size = size; // 子树大小
    this.children = [];
  }
  
  draw(ctx) {
    // 绘制 8 位风格节点
    ctx.fillStyle = this.active ? '#FF5555' : '#55AAFF';
    ctx.fillRect(x-15, y-15, 30, 30); 
    // 显示子树大小
    ctx.fillText(this.size, x, y);
  }
}

// 动画更新逻辑
function dfsStep(node, parent) {
  highlight(node); // 红色高亮当前节点
  node.children.forEach(child => {
    if (child != parent) {
      dfsStep(child, node);
      // 显示子树大小累加过程
      animateSize(node, child.size); 
    }
  });
  // 检查父方向子树
  if (parent) checkParentSubtree(node); 
}
```

---

## 复古游戏化设计  
1. **音效设计**：  
   - `blip.wav`：节点激活音  
   - `success.wav`：候选节点确认音  
2. **积分系统**：  
   - 正确识别重心 +100 分  
   - 错误判定 -50 分  
3. **自动演示模式**：  
   - 按 BGM 节奏逐步展开算法流程  
   - 按空格键暂停/继续  

---

通过这种多维度解析，不仅能深入理解本题的算法核心，还能将相似问题的解决模式融会贯通。

---
处理用时：77.96秒
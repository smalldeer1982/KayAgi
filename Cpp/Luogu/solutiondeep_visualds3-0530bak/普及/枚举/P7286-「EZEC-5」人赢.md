# 题目信息

# 「EZEC-5」人赢

## 题目背景

> “我们在 小 Z 面前秀个恩爱吧。”\
>“好的。”

小 Z 发现他身边都是人赢，这使他非常自闭。

小 Z 又看着身边的潇，不禁陷入了沉思……

![](https://cdn.luogu.com.cn/upload/image_hosting/b1ij58kc.png)

## 题目描述

潇有一个数组 $k$，下标为 $1$ 到 $n$ 。

潇定义 $f(x,y)=\begin{cases} \min(k_x,k_y) \times (x + y) &x \ne y \\ k_x\times x&x=y \end{cases}$ 。

潇想知道对于任意的 $1 \le x,y \le n$，$f(x,y)$ 的最大值是多少。但是她不会做，于是就问了善良的 小 Z，然而非常想在妹子面前表现的 小 Z 发现他也不会做，就只能够求助善良的你了。

## 说明/提示

### 数据范围

**本题采用捆绑测试。**

- Subtask 1（20 points）：$1 \le n \le 5000$。

- Subtask 2（10 points）：保证所有 $k_{i}$ 都相等。

- Subtask 3（20 points）：$k_i \le 10^3$。

- Subtask 4（50 points）：无特殊性质。

对于 $100\%$ 的数据，$1 \le n \le 10^6$，$1 \le k_{i} \le 10^9$。

------------

本题加强版：[link](https://www.luogu.com.cn/problem/P7291)。

## 样例 #1

### 输入

```
3
3 2 1```

### 输出

```
6```

## 样例 #2

### 输入

```
5
3 4 5 4 3```

### 输出

```
28```

# AI分析结果



# 算法分析与题解总结

## 算法分类
**排序 + 贪心**

---

## 题解思路与核心难点

### 核心思路
1. **x=y情况**：直接遍历求最大值。
2. **x≠y情况**：需最大化 $\min(k_x,k_y)\times (x+y)$，通过排序和预处理优化枚举过程。

### 题解对比
- **wsyhb的题解**（排序+前缀最大值）：
  - **要点**：将元素按k值降序排序，维护已遍历元素的最大下标。每个元素只需与当前最大下标组合。
  - **难点**：排序后确保每次计算的x是当前最小的k值，利用前缀最大值快速找到最优y。
  - **优化**：时间复杂度O(n log n)，适用于原题数据。

- **囧仙的题解**（单调栈）：
  - **要点**：维护单调递减栈，遍历时弹出比当前k小的元素并计算贡献，保证栈顶始终是最大有效下标。
  - **难点**：动态维护栈结构，确保每次弹出后栈内元素仍满足单调性。
  - **优化**：时间复杂度O(n)，线性处理适用于加强版数据。

- **灵乌路空的题解**（单调栈优化）：
  - **要点**：正序枚举y，维护栈内元素k递减，每次处理时弹出无效元素并更新最大值。
  - **实现**：利用栈结构避免重复比较，保证每个元素入栈出栈一次。

### 解决难点
- **排序法**：通过降序排序确保当前元素k是较小值，结合前缀最大值快速定位最大下标。
- **单调栈法**：动态维护有效元素，避免重复遍历，确保线性时间复杂度。

---

## 题解评分（≥4星）

1. **wsyhb的题解**（★★★★☆）
   - **亮点**：代码简洁，逻辑清晰，适合快速实现。
   - **代码**：排序后单次遍历维护最大值，可读性强。

2. **囧仙的题解**（★★★★★）
   - **亮点**：提供多种解法（排序、基排、单调栈），覆盖不同数据规模。
   - **优化**：线性时间解法适用于极端数据，思路创新。

3. **灵乌路空的题解**（★★★★☆）
   - **亮点**：单调栈实现高效，动画演示思路直观。
   - **心得**：强调栈的动态维护过程，适合深入理解贪心策略。

---

## 最优思路提炼

1. **排序 + 前缀最大值**：
   - **关键步骤**：降序排序后，遍历时维护已处理元素的最大下标。
   - **代码核心**：
     ```cpp
     sort(id+1, id+n+1, cmp); //按k降序排列
     int max_id = 0;
     for (int i=1; i<=n; i++) {
         ans = max(ans, 1LL * k[id[i]] * (id[i] + max_id));
         max_id = max(max_id, id[i]);
     }
     ```

2. **单调栈**：
   - **关键步骤**：维护k递减的栈，弹出无效元素后计算贡献。
   - **代码核心**：
     ```cpp
     stack<int> stk;
     for (int y=1; y<=n; y++) {
         while (!stk.empty() && k[stk.top()] <= k[y]) {
             int x = stk.top(); stk.pop();
             ans = max(ans, k[x] * (x + y));
         }
         if (!stk.empty()) ans = max(ans, k[y] * (stk.top() + y));
         stk.push(y);
     }
     ```

---

## 同类型题推荐

1. **P7291**（本题加强版，需线性解法）
2. **P2559**（柱状图中的最大矩形，单调栈经典应用）
3. **P1901**（发射站，贪心+单调栈）

---

## 可视化与动画设计

### 排序法动画方案
- **步骤**：
  1. **排序过程**：展示元素按k值降序排列的动态过程。
  2. **遍历更新**：高亮当前元素，显示与max_id的乘积计算，更新最大值。
  3. **颜色标记**：当前元素（红色），max_id（蓝色），历史最大值（绿色闪烁）。

- **复古风格**：
  - **像素网格**：每个元素显示为色块，高度表示k值，宽度表示下标。
  - **音效**：元素排序时播放“移动”音效，更新max_id时触发“叮”声。

### 单调栈动画方案
- **步骤**：
  1. **元素入栈**：新元素y入栈前，弹出栈顶k≤k[y]的元素，计算贡献。
  2. **贡献计算**：高亮弹出的x与y，显示(x+y)*min(k_x,k_y)。
  3. **栈状态**：栈内元素以递减高度展示，颜色渐变表示k值大小。

- **游戏化交互**：
  - **自动演示**：AI控制遍历速度，可暂停观察栈变化。
  - **积分系统**：每次正确弹出元素得10分，最大贡献更新时得50分。

---

## 代码片段（排序法）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=1e6+5;
int k[max_n], id[max_n];

int main() {
    int n; scanf("%d", &n);
    for(int i=1; i<=n; ++i) {
        scanf("%d", k+i);
        id[i] = i;
    }
    sort(id+1, id+n+1, [](int x, int y) {
        return k[x] > k[y] || (k[x]==k[y] && x>y);
    });
    long long ans = 0;
    int max_id = 0;
    for(int i=1; i<=n; ++i) {
        ans = max(ans, 1LL * k[id[i]] * (id[i] + max_id));
        max_id = max(max_id, id[i]);
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 总结

**核心思维**：通过排序或单调结构优化枚举过程，将问题转化为高效的单次遍历。两种方法均体现了“预处理+贪心”的经典算法设计思路，适用于不同场景。推荐在普通数据下使用排序法，极端数据采用单调栈实现。

---
处理用时：85.33秒
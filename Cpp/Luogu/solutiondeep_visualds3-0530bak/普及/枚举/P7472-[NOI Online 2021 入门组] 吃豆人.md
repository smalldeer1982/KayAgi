# 题目信息

# [NOI Online 2021 入门组] 吃豆人

## 题目描述

有一个 $n$ 行 $n$ 列的正方形点阵，左上角点坐标为 $(1, 1)$，右下角点坐标为 $(n, n)$。

点阵中每个整点上都有数量不一的豆子，坐标为 $(i, j)$ 的点上有 $a_{i,j}$ 个豆子。

你可以放置吃豆人，可以将点阵中任意的整点作为吃豆人的初始位置，再给定左上、左下、右上、右下之一作为吃豆人的初始方向。

吃豆人会不断沿初始方向行进，吃光遇到的所有豆子，直到碰到点阵的边界，此时：

1. 如果吃豆人处于正方形点阵四个角之一的位置，那么就会停止行动；

2. 否则，吃豆人的行进路线将以这条边界为镜面发生反射，下图展示了一个路径某两次发生反射的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/6tji95nq.png)

现在，你需要放置两个吃豆人，求两个吃豆人最多共能吃到多少个豆子？注意同一个豆子只能被吃一次。


## 说明/提示

### 样例 1 解释

在 $(1, 1)$ 和 $(1, 3)$ 位置放置吃豆人，初始方向分别为右下和左下，即可吃到位于
$(1, 1)$，$(1, 3)$，$(2, 2)$，$(2, 4)$，$(3, 1)$，$(3, 3)$，$(4, 2)$，$(4, 4)$ 位置上的豆子，总个数为 $132$，
达到最大，路径分别如下图绿线和红线所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/1axaad1b.png)

### 数据范围

对于 $30\%$ 的数据，$n\leq 3$。

对于 $60\%$ 的数据：$n\leq 100$。

对于 $100\%$ 的数据：$2\leq n\leq 1000$，$0\leq a_{i,j}\leq 1000$。

数据由 [SSerxhs](https://www.luogu.com.cn/user/29826) 和 [Karry5307](https://www.luogu.com.cn/user/60990) 共同提供。

感谢 [Silence_water](https://www.luogu.com.cn/user/338630) 提供一组 hack 数据。

## 样例 #1

### 输入

```
4
20 1 19 2
3 18 4 17
16 5 15 6
7 14 8 13```

### 输出

```
132```

# AI分析结果



## 算法分类
无特定算法分类（几何模拟、路径处理）

---

## 综合分析与结论

### 核心思路
所有路径均可由第一行的起点出发，通过反射形成矩形或对角线。预处理每条路径的总豆子数，枚举所有路径组合，计算总和并减去重复豆子。

### 关键步骤
1. **路径预处理**：模拟吃豆人移动，计算每条路径的总豆子数。
2. **重复点计算**：根据路径编号的奇偶差，推导交点坐标并去重。
3. **分类讨论**：处理对角线、回路等不同路径组合的交点情况。

### 难点解析
- **路径模拟**：需处理方向反射逻辑，确保正确遍历所有点。
- **重复点推导**：通过数学规律确定交点坐标，避免暴力遍历导致超时。

### 可视化设计
- **动画方案**：以网格展示路径，高亮当前移动点和方向变化。
- **颜色标记**：红色表示当前路径，绿色为另一路径，黄色高亮交点。
- **步进控制**：允许单步执行观察反射逻辑，调整速度查看整体路径。

---

## 题解评分（≥4星）

1. **Mine_King（5星）**  
   - 思路清晰，分类讨论全面，推导严谨。  
   - 代码结构简洁，预处理和重复计算逻辑高效。  
   - 关键亮点：利用奇偶性快速判断交点存在性。

2. **Hanx16Kira（4星）**  
   - 通过前缀和优化预处理，减少计算量。  
   - 代码可读性较高，但重复点处理稍显复杂。  
   - 个人心得：强调画图辅助推导交点坐标。

3. **Poncirus（4星）**  
   - 动态标记路径交点，避免复杂数学推导。  
   - 代码实现巧妙，但空间复杂度略高。  
   - 关键技巧：用`vis`数组记录路径归属，动态统计重复点。

---

## 最优思路与代码实现

### 核心代码（Mine_King题解）
```cpp
int repeat(int x, int y) {
    if ((y - x) % 2) return 0; // 奇差无交点
    if (x == 1 && y == n)       // 对角线交点
        return a[(n+1)/2][(n+1)/2];
    if (x == 1)                 // 对角线与回路
        return a[(y+1)/2][(y+1)/2] + a[n - (y-1)/2][n - (y-1)/2];
    // ... 其他情况类似
}
```

### 实现思想
1. **预处理路径总和**：模拟吃豆人移动，沿方向反射直到回到起点或角落。
2. **枚举路径组合**：计算两路径总和，调用`repeat`函数减去重复豆子。
3. **数学推导交点**：通过路径编号差和对称性确定坐标，直接访问数组取值。

---

## 类似题目推荐
1. **P1219 八皇后** - 路径冲突检测与回溯。
2. **P1443 马的遍历** - 网格移动与方向处理。
3. **P1162 填涂颜色** - 矩阵边界处理与填充。

---

## 个人心得摘录
- **Hanx16Kira**：画图验证交点坐标是关键，避免空想导致推导错误。
- **Poncirus**：动态标记法虽增加空间，但简化了复杂数学推导，调试更直观。

---

## 可视化算法演示

### 动画设计
- **网格绘制**：Canvas绘制n×n网格，豆子用绿色圆点表示。
- **路径高亮**：吃豆人移动时，路径变为蓝色，当前点为红色。
- **方向箭头**：显示当前移动方向，反射时更新箭头方向。
- **交点闪烁**：检测到交点时，黄色闪烁并播放音效。

### 复古像素风格
- **8位调色板**：使用经典FC颜色（红、蓝、黄、绿）。
- **音效设计**：移动时“哔”声，交点上扬音效，错误短促“嘟”声。
- **自动演示**：按路径编号自动切换，展示最优路径组合。

```javascript
// 伪代码示例：路径绘制
function drawPath(startX, color) {
    let dir = 0, x = 1, y = startX;
    while (true) {
        drawPixel(x, y, color); // 绘制路径
        [x, y] = moveNext(x, y, dir); // 移动并处理反射
        if (isCorner(x, y)) break;
    }
}
```

---
处理用时：81.93秒
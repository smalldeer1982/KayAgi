# 题目信息

# [省选联考 2021 B 卷] 数对

## 题目描述

给定 $n$ 个正整数 $a_i$，请你求出有多少个数对 $(i, j)$ 满足 $1 \le i \le n$，$1 \le j \le n$，$i \ne j$ 且 $a_i$ 是 $a_j$ 的倍数。

## 说明/提示

对于 $40 \%$ 的数据，$n \le 1000$。  
对于 $70 \%$ 的数据，$1 \le a_i \le 5 \times {10}^3$。  
对于 $100 \%$ 的数据，$2 \le n \le 2 \times {10}^5$，$1 \le a_i \le 5 \times {10}^5$。

## 样例 #1

### 输入

```
6
16 11 6 1 9 11
```

### 输出

```
7
```

## 样例 #2

### 输入

```
见附件中的 pair/pair2.in。```

### 输出

```
见附件中的 pair/pair2.ans。```

# AI分析结果



---

**唯一算法分类**：数学（调和级数枚举）

---

### **综合分析与结论**

**题目核心**：统计所有数对 $(i,j)$ 满足 $a_i$ 是 $a_j$ 的倍数且 $i \neq j$。  
**核心难点**：  
1. **数据规模**：$n \le 2 \times 10^5$，暴力枚举所有数对 $O(n^2)$ 不可行。  
2. **值域限制**：$a_i \le 5 \times 10^5$，需高效统计倍数关系。  

**最优解法**：调和级数枚举法。  
**算法流程**：  
1. **桶计数**：统计每个数值出现的次数 `cnt[x]`。  
2. **枚举倍数**：对每个数 $x$，枚举其倍数 $k \times x$，累加 `cnt[x] * cnt[k*x]`。  
3. **自身处理**：当 $k=1$ 时，贡献为 `cnt[x] * (cnt[x] - 1)`（排除相同下标）。  

**时间复杂度**：$O(M \log M)$，其中 $M = \max(a_i)$，满足题目数据要求。  
**可视化设计**：  
- **动画方案**：将数值按桶排列，动态高亮当前枚举的数值 $x$ 及其倍数，用不同颜色标记贡献累加过程。  
- **复古风格**：使用 8 位像素风格绘制数值网格，每次枚举时播放短促音效，达成条件时触发过关音效。  

---

### **题解清单 (≥4星)**

| 题解作者       | 评分 | 核心亮点                                                                 |
|----------------|------|--------------------------------------------------------------------------|
| LZH_LOVE_ZRG   | ⭐⭐⭐⭐⭐ | 最简洁的调和级数实现，代码清晰，时间复杂度最优。                         |
| phigy          | ⭐⭐⭐⭐⭐ | 明确区分倍数贡献与自身贡献，代码极简，适合快速理解。                     |
| Hexarhy        | ⭐⭐⭐⭐   | 去重优化减少枚举次数，代码规范，适合学习离散化技巧。                     |

---

### **最优代码实现**

```cpp
#include <iostream>
using namespace std;
const int MAXN = 5e5 + 10;
int cnt[MAXN];

int main() {
    int n, x;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> x;
        cnt[x]++;
    }
    long long ans = 0;
    for (int i = 1; i < MAXN; i++) {
        ans += 1LL * cnt[i] * (cnt[i] - 1);  // 处理自身
        for (int j = 2 * i; j < MAXN; j += i) {
            ans += 1LL * cnt[i] * cnt[j];    // 处理倍数
        }
    }
    cout << ans << endl;
    return 0;
}
```

**核心思想**：  
1. **桶计数**：用 `cnt[x]` 记录数值 $x$ 的出现次数。  
2. **调和级数枚举**：对每个 $x$，遍历其倍数 $2x, 3x, \dots$，累加贡献。  
3. **去重处理**：自身贡献通过 `cnt[x] * (cnt[x] - 1)` 计算，避免 $i=j$ 的情况。

---

### **同类题目推荐**

1. **洛谷 P2926 [USACO08DEC] Patting Heads**  
   **标签**：调和级数、桶计数。  
   **简介**：统计每个数的倍数出现次数，与本题思路高度一致。

2. **洛谷 P2424 约数和**  
   **标签**：因数分解、前缀和。  
   **简介**：利用调和级数预处理所有数的因数贡献。

3. **洛谷 P1403 [AHOI2005] 约数研究**  
   **标签**：数学、调和级数。  
   **简介**：统计每个数的倍数数量，与本题核心思想相似。

---

### **可视化与复古游戏化设计**

**实现要点**：  
1. **像素网格**：用 Canvas 绘制 $5 \times 10^5$ 的数值网格，每个格子表示一个数值。  
2. **动态高亮**：当前枚举的数值 $x$ 显示为绿色，其倍数显示为黄色，贡献累加时触发闪烁效果。  
3. **音效系统**：  
   - **枚举音效**：每次枚举一个数值时播放 `beep` 音效。  
   - **贡献音效**：每次累加贡献时播放 `click` 音效。  
4. **自动演示**：AI 模式自动遍历所有数值，速度可调节（1x/2x/5x）。  

**代码片段（伪代码）**：  
```javascript
// 初始化像素网格
const grid = new PixelGrid(MAXN, 16, 8); // 16x8 像素风格
grid.draw();

// 自动演示逻辑
function autoRun(speed) {
    for (let x = 1; x < MAXN; x++) {
        grid.highlight(x, 'GREEN');
        playSound('beep');
        for (let j = 2 * x; j < MAXN; j += x) {
            grid.highlight(j, 'YELLOW');
            playSound('click');
            await delay(100 / speed);
        }
    }
}
```

---

### **个人心得摘录**

- **LZH_LOVE_ZRG**：  
  > “调和级数复杂度容易被低估，但在值域受限时表现极佳，是此类问题的银弹。”  
- **Hexarhy**：  
  > “去重后减少无效枚举，离散化是优化常数的小技巧。”  
- **phigy**：  
  > “注意 $j=1$ 的特殊情况，避免重复计算需要细致处理。”  

---

**总结**：本题通过调和级数枚举法高效统计倍数关系，是数学与算法结合的经典问题，适合作为调和级数思想的入门训练。

---
处理用时：86.75秒
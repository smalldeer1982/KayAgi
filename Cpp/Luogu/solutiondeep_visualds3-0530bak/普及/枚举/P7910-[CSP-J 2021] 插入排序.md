# 题目信息

# [CSP-J 2021] 插入排序

## 题目描述

插入排序是一种非常常见且简单的排序算法。小 Z 是一名大一的新生，今天 H 老师刚刚在上课的时候讲了插入排序算法。

假设比较两个元素的时间为 $\mathcal O(1)$，则插入排序可以以 $\mathcal O(n^2)$ 的时间复杂度完成长度为 $n$ 的数组的排序。不妨假设这 $n$ 个数字分别存储在 $a_1, a_2, \ldots, a_n$ 之中，则如下伪代码给出了插入排序算法的一种最简单的实现方式：

这下面是 C/C++ 的示范代码：

```cpp
for (int i = 1; i <= n; i++)
	for (int j = i; j >= 2; j--)
		if (a[j] < a[j-1]) {
			int t = a[j-1];
			a[j-1] = a[j];
			a[j] = t;
		}
```

这下面是 Pascal 的示范代码：

```pascal
for i:=1 to n do
	for j:=i downto 2 do
		if a[j]<a[j-1] then
			begin
				t:=a[i];
				a[i]:=a[j];
				a[j]:=t;
			end;
```

为了帮助小 Z 更好的理解插入排序，小 Z 的老师 H 老师留下了这么一道家庭作业：

H 老师给了一个长度为 $n$ 的数组 $a$，数组下标从 $1$ 开始，并且数组中的所有元素均为非负整数。小 Z 需要支持在数组 $a$ 上的 $Q$ 次操作，操作共两种，参数分别如下：

$1~x~v$：这是第一种操作，会将 $a$ 的第 $x$ 个元素，也就是 $a_x$ 的值，修改为 $v$。保证 $1 \le x \le n$，$1 \le v \le 10^9$。**注意这种操作会改变数组的元素，修改得到的数组会被保留，也会影响后续的操作**。

$2~x$：这是第二种操作，假设 H 老师按照**上面的伪代码**对 $a$ 数组进行排序，你需要告诉 H 老师原来 $a$ 的第 $x$ 个元素，也就是 $a_x$，在排序后的新数组所处的位置。保证 $1 \le x \le n$。**注意这种操作不会改变数组的元素，排序后的数组不会被保留，也不会影响后续的操作**。

H 老师不喜欢过多的修改，所以他保证类型 $1$ 的操作次数不超过 $5000$。

小 Z 没有学过计算机竞赛，因此小 Z 并不会做这道题。他找到了你来帮助他解决这个问题。

## 说明/提示

**【样例解释 #1】**

在修改操作之前，假设 H 老师进行了一次插入排序，则原序列的三个元素在排序结束后所处的位置分别是 $3, 2, 1$。

在修改操作之后，假设 H 老师进行了一次插入排序，则原序列的三个元素在排序结束后所处的位置分别是 $3, 1, 2$。

注意虽然此时 $a_2 = a_3$，但是我们**不能将其视为相同的元素**。

**【样例 #2】**

见附件中的 `sort/sort2.in` 与 `sort/sort2.ans`。

该测试点数据范围同测试点 $1 \sim 2$。

**【样例 #3】**

见附件中的 `sort/sort3.in` 与 `sort/sort3.ans`。

该测试点数据范围同测试点 $3 \sim 7$。

**【样例 #4】**

见附件中的 `sort/sort4.in` 与 `sort/sort4.ans`。

该测试点数据范围同测试点 $12 \sim 14$。

**【数据范围】**

对于所有测试数据，满足 $1 \le n \le 8000$，$1 \le Q \le 2 \times {10}^5$，$1 \le x \le n$，$1 \le v,a_i \le 10^9$。

对于所有测试数据，保证在所有 $Q$ 次操作中，至多有 $5000$ 次操作属于类型一。

各测试点的附加限制及分值如下表所示。

| 测试点 | $n \le$ | $Q \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1 \sim 4$ | $10$ | $10$ | 无 |
| $5 \sim 9$ | $300$ | $300$ | 无 |
| $10 \sim 13$ | $1500$ | $1500$ | 无 |
| $14 \sim 16$ | $8000$ | $8000$| 保证所有输入的 $a_i,v$ 互不相同 |
| $17 \sim 19$ | $8000$ | $8000$ | 无 |
| $20 \sim 22$ | $8000$ | $2 \times 10^5$ | 保证所有输入的 $a_i,v$ 互不相同 |
| $23 \sim 25$ | $8000$ | $2 \times 10^5$ | 无 |

## 样例 #1

### 输入

```
3 4
3 2 1
2 3
1 3 2
2 2
2 3
```

### 输出

```
1
1
2
```

# AI分析结果



## 算法分类
插入排序 + 离线维护有序序列

---

## 综合分析与结论

### 核心思路
题目要求在动态修改数组元素后快速查询某个元素在插入排序后的位置。核心难点在于如何高效处理大量查询操作（最多 2e5 次）。通过分析题解，最优策略是维护一个始终有序的数组，每次修改后通过两次冒泡操作调整元素位置，并维护原元素到有序数组位置的映射关系。这样查询时即可 O(1) 获取结果。

### 算法流程与可视化
1. **初始排序**：将数组按插入排序规则排序，生成有序序列。
2. **修改操作**：
   - 找到修改元素在有序数组中的位置。
   - 修改其值后，**向前冒泡**（若新值比前驱小）和**向后冒泡**（若新值比后继大），动态调整位置。
   - 更新原位置到有序数组的映射表。
3. **查询操作**：直接查表输出排名。
   
**可视化设计**：
- **元素高亮**：修改的元素用红色标记，冒泡过程用黄色标记交换路径。
- **动态映射表**：右侧同步显示原下标与有序数组位置的对应关系。
- **像素动画**：以 8-bit 风格展示冒泡过程，元素移动时播放经典「嘟嘟」音效。

---

## 题解清单（≥4星）

1. **Otomachi_Una（⭐⭐⭐⭐⭐）**
   - **亮点**：通过两次冒泡维护有序数组，映射表直接映射原位置到排序位置。
   - **代码可读性**：结构清晰，维护 `t[x]` 数组直接对应查询结果。

2. **山田リョウ（⭐⭐⭐⭐）**
   - **亮点**：平衡树实现动态排名查询，时间复杂度 O(Q log n)。
   - **优化点**：利用离散化和树状数组降低空间复杂度。

3. **SunsetSamsara（⭐⭐⭐⭐）**
   - **亮点**：线段树动态维护值域，通过哈希值解决稳定性问题。
   - **技巧**：将元素值与其下标合并为唯一键值，避免冲突。

---

## 核心代码实现（Otomachi_Una）

```cpp
struct node { int pre, id; } a[MAXN]; // pre: 值, id: 原下标
int t[MAXN]; // t[x] 记录原下标 x 在有序数组中的位置

// 排序规则：值小优先，值相同则原下标小优先
bool cmp(node x, node y) { 
    return x.pre != y.pre ? x.pre < y.pre : x.id < y.id; 
}

// 修改操作核心逻辑
void update(int x, int v) {
    a[t[x]].pre = v; // 找到有序数组中对应的元素修改值
    
    // 向后冒泡调整（新值可能比后继小）
    for (int j = t[x]; j >= 2; j--) {
        if (cmp(a[j], a[j-1])) swap(a[j], a[j-1]);
    }
    
    // 向前冒泡调整（新值可能比前驱大）
    for (int j = t[x]; j <= n-1; j++) {
        if (cmp(a[j+1], a[j])) swap(a[j], a[j+1]);
    }
    
    // 更新映射表
    for (int i = 1; i <= n; i++) t[a[i].id] = i;
}
```

---

## 同类型题与拓展

1. **动态维护排名**：P3380 【模板】二逼平衡树（树套树）
2. **稳定排序与查询**：P1908 逆序对（归并排序 + 离散化）
3. **高效修改与查询**：P3369 【模板】普通平衡树

---

## 可视化与游戏化设计

### 8-bit 像素风格展示
- **Canvas 绘制**：用 32x32 像素块表示数组元素，颜色区分值和原下标。
- **冒泡动画**：元素交换时显示移动轨迹，伴随经典「马里奥跳跃」音效。
- **自动演示模式**：AI 模拟随机修改与查询，展示算法动态调整过程。

### 关键代码片段（伪代码）
```javascript
// 冒泡动画示例（伪代码）
function animateBubble(pos, direction) {
    let elem = document.getElementById(`pos-${pos}`);
    elem.style.backgroundColor = "#FFD700"; // 高亮当前元素
    playSound("bubble"); // 播放冒泡音效
    setTimeout(() => {
        swapElements(pos, pos + direction); // 交换元素位置
        elem.style.backgroundColor = "#FFFFFF"; // 恢复颜色
    }, 300);
}
```

---

## 个人心得
调试时需特别注意稳定排序中**原下标比较**的逻辑，若遗漏会导致相同值元素位置错误。例如，当两个元素值相同时，必须严格按原下标顺序排列，否则查询结果会错位。

---
处理用时：83.27秒
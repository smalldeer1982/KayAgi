# 题目信息

# [蓝桥杯 2020 省 AB2] 子串分值

## 题目描述

对于一个字符串 $S$, 我们定义 $S$ 的分值 $f(S)$ 为 $S$ 中恰好出现一次的字符个数。例如 $f\left({ }^{\prime \prime} \mathrm{aba}{ }^{\prime \prime}\right)=1$，$f\left({ }^{\prime \prime} \mathrm{abc}{ }^{\prime \prime}\right)=3$，$f\left({ }^{\prime \prime} \mathrm{aaa} \mathrm{a}^{\prime \prime}\right)=0$ 。

现在给定一个字符串 $S[0 . . n-1]$（长度为 $n$），请你计算对于所有 $S$ 的非空 子串 $S[i . . j](0 \leq i \leq j<n)$，$f(S[i . . j])$ 的和是多少。


## 说明/提示

对于 $20 \%$ 的评测用例, $1 \leq n \leq 10$;

对于 $40 \%$ 的评测用例, $1 \leq n \leq 100$;

对于 $50 \%$ 的评测用例, $1 \leq n \leq 1000$;

对于 $60 \%$ 的评测用例, $1 \leq n \leq 10000$;

对于所有评测用例, $1 \leq n \leq 100000$。

蓝桥杯 2020 第二轮省赛 A 组 H 题（B 组 H 题）。

## 样例 #1

### 输入

```
ababc```

### 输出

```
21```

# AI分析结果



---

**唯一算法分类**：线性扫描与预处理

---

### 综合分析与结论

#### 核心思路与难点
1. **问题转化**：将子串分值之和转化为每个字符的贡献之和。只有当字符在子串中恰好出现一次时才贡献1分。
2. **关键变量**：对每个字符记录其上一次出现位置 `pre[i]` 和下一次出现位置 `next[i]`，贡献为 `(i - pre[i]) * (next[i] - i)`。
3. **边界处理**：若字符首次出现，`pre[i]` 设为0；若未再出现，`next[i]` 设为n+1。

#### 题解对比
- **共同点**：所有正确题解均基于上述思路，差异在于变量命名和边界处理细节。
- **优化手段**：两次遍历字符串预处理 `pre` 和 `next` 数组，时间复杂度O(n)。

#### 可视化设计
- **动画方案**：用颜色高亮当前字符，动态显示其 `pre` 和 `next` 的位置范围，计算贡献时展示左右端点的选择。
- **复古风格**：像素方块表示字符，音效提示计算步骤，背景音乐循环播放。
- **交互设计**：步进控制、参数调节，自动演示模式展示算法流程。

---

### 题解评分（≥4星）

1. **BEST_CAT（5星）**  
   - **亮点**：代码简洁清晰，变量命名规范，边界处理明确。预处理 `pre` 和 `next` 数组的步骤详细。
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++) pre[i]=idx[s[i]]; // 预处理pre数组
     for(int i=n;i>=1;i--) nx[i]=idx[s[i]]; // 预处理next数组
     ans += (i - pre[i]) * (nx[i] - i);     // 计算贡献
     ```

2. **Luckies（4.5星）**  
   - **亮点**：变量名 `last` 和 `nxt` 更易理解，代码注释详细。
   - **个人心得**：强调“贡献仅限唯一出现的情况”，帮助理解问题转化。

3. **DreamLand_zcb（4星）**  
   - **亮点**：通过样例表格直观展示贡献计算，适合新手理解。
   - **代码细节**：处理特殊情况的注释较详细。

---

### 最优思路与技巧提炼

1. **贡献独立计算**：每个字符的贡献独立，无需考虑其他字符的影响。
2. **预处理优化**：两次遍历记录 `pre` 和 `next` 数组，空间换时间。
3. **乘法原理应用**：左右端点选择范围相乘即为子串数量。

---

### 类似题目推荐
1. **洛谷 P1986**：统计满足条件的子数组数目，需预处理边界。
2. **LeetCode 828**：几乎相同的题目，解法完全相同。
3. **洛谷 P2678**：利用二分和预处理优化，思路类似。

---

### 可视化与游戏化实现

#### 核心逻辑演示
- **Canvas动画**：  
  1. 字符串显示为像素方块，当前字符高亮为蓝色。  
  2. `pre[i]` 和 `next[i]` 标为红色，动态绘制左右端点范围。  
  3. 每次计算贡献时，显示 `(i - pre[i]) * (next[i] - i)` 的数值并累加到总和中。

- **音效与交互**：  
  - **步进音效**：短促“滴”声。  
  - **完成音效**：8-bit胜利音效。  
  - **自动演示**：按字符顺序自动播放，速度可调。

#### 代码片段（关键部分）
```javascript
// 预处理pre数组（伪代码）
let pre = new Array(n).fill(0);
let lastPos = new Map();
for (let i = 0; i < n; i++) {
    pre[i] = lastPos.has(s[i]) ? lastPos.get(s[i]) : -1;
    lastPos.set(s[i], i);
}

// 贡献计算动画
function animateContribution(i) {
    highlightChar(i, 'blue');
    drawRange(pre[i]+1, i, 'left');
    drawRange(i, next[i]-1, 'right');
    playSound('beep');
    total += (i - pre[i]) * (next[i] - i);
    updateScore(total);
}
```

---

### 个人心得摘录
- **BEST_CAT**：  
  > “暴力解法显然超时，必须找到每个字符的独立贡献方式。”  
- **DreamLand_zcb**：  
  > “通过具体样例推导贡献公式，避免抽象思考的困难。”

---

### 推荐实现代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int pre[N], nxt[N], last[26];
string s;

int main() {
    cin >> s;
    int n = s.size();
    memset(last, -1, sizeof last);
    for (int i = 0; i < n; i++) {
        pre[i] = last[s[i] - 'a'];
        last[s[i] - 'a'] = i;
    }
    fill(last, last + 26, n);
    for (int i = n - 1; i >= 0; i--) {
        nxt[i] = last[s[i] - 'a'];
        last[s[i] - 'a'] = i;
    }
    long long ans = 0;
    for (int i = 0; i < n; i++)
        ans += (i - pre[i]) * (nxt[i] - i);
    cout << ans;
    return 0;
}
```

---
处理用时：101.40秒
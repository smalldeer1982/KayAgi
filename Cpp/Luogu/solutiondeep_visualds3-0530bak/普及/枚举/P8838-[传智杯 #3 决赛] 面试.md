# 题目信息

# [传智杯 #3 决赛] 面试

## 题目背景

disangan233 和 disangan333 去面试了，面试官给了一个问题，热心的你能帮帮他们吗？

## 题目描述

现在有 $n$ 个服务器，服务器 $i$ 最多能处理 $a_i$ 大小的数据。

接下来会有 $k$ 条指令 $b_k$，指令 $i$ 表示发送 $b_i$ 的数据，需要你分配一个空闲的服务器。

请你算出一个序列 $p_k$ 表示指令 $i$ 的数据分配给服务器 $p_i$，且 $p_k$ 的字典序最小；如果无法分配，输出 "-1"。

对于所有数据，$n,k\leq 6$，$a_i,b_i \leq 10$。 

## 说明/提示

### 样例解释

第 1 条指令分给服务器 1；  
第 2 条指令分给服务器 3；  
第 3 条指令分给服务器 2；  
第 4 条指令分给服务器 4；  
第 5 条指令分给服务器 6；  
第 6 条指令分给服务器 5。

## 样例 #1

### 输入

```
6 6
1 9 1 9 8 1
1 1 4 5 1 4```

### 输出

```
1 3 2 4 6 5```

# AI分析结果



## 算法分类
**回溯法（深度优先搜索）**

---

## 综合分析与结论

### 核心思路与难点
- **核心逻辑**：每个指令按顺序选择当前可用且编号最小的服务器，通过回溯法找到字典序最小的合法分配序列。
- **关键难点**：
  1. **字典序最小**：必须优先尝试编号小的服务器，才能保证找到的第一个解是字典序最小的。
  2. **状态回溯**：用 `vis` 数组标记已使用的服务器，递归后需撤销标记以尝试其他可能性。
- **解决方案**：DFS 按指令顺序遍历服务器，优先选择编号小的合法服务器，找到第一个解后立即终止搜索。

### 可视化设计思路
- **动画方案**：
  - **网格布局**：用网格展示每个指令（行）和服务器（列），高亮当前尝试的服务器。
  - **颜色标记**：
    - **绿色**：当前指令正在尝试的服务器。
    - **红色**：服务器容量不足或已被占用。
    - **蓝色**：已成功分配的服务器。
  - **回溯效果**：在撤销选择时，清除对应服务器的颜色。
- **步进控制**：允许单步执行观察 DFS 的尝试与回溯过程。

---

## 题解清单 (≥4星)

### 题解1：_H17_ (⭐⭐⭐⭐⭐)
- **亮点**：
  - **高效终止**：找到第一个解后立即终止后续搜索。
  - **代码简洁**：仅需一次 DFS 调用，逻辑清晰。
- **核心代码**：
  ```cpp
  void dfs(int s) {
      if (s == k + 1) {
          if (f) {  // 第一个解即为字典序最小
              for (int i = 1; i <= k; i++) cout << p[i] << " ";
              f = 0;
          }
          return;
      }
      for (int i = 1; i <= n; i++) {
          if (a[i] >= b[s] && !u[i]) {  // 优先选编号小的服务器
              p[s] = i;
              u[i] = 1;
              dfs(s + 1);
              u[i] = 0;
          }
      }
  }
  ```

### 题解2：fengziyi (⭐⭐⭐⭐)
- **亮点**：
  - **即时返回**：通过返回值 `true` 提前终止搜索，避免无效递归。
  - **优化回溯**：不重置 `ans` 数组，因后续递归不影响已找到的解。
- **核心代码**：
  ```cpp
  bool dfs(int i) {
      if (i > k) {
          print_solution();
          return true;  // 立即返回，终止搜索
      }
      for (int j = 1; j <= n; j++) {
          if (a[j] >= b[i] && !vis[j]) {
              vis[j] = 1;
              ans[i] = j;
              if (dfs(i + 1)) return true;  // 递归调用并传递终止信号
              vis[j] = 0;
          }
      }
      return false;
  }
  ```

---

## 最优思路提炼
1. **贪心选择策略**：每次为当前指令选择编号最小的可用服务器。
2. **回溯剪枝**：通过 `vis` 数组避免重复选择，递归后及时撤销状态。
3. **终止优化**：找到第一个合法解后立即终止搜索，避免冗余计算。

---

## 同类型题与算法套路
- **常见题型**：全排列生成、任务分配、字典序最小路径问题。
- **通用解法**：DFS + 回溯 + 贪心选择策略。

---

## 推荐题目
1. **P1706 全排列问题**（回溯法生成全排列）
2. **P1219 [USACO1.5]八皇后 Checker Challenge**（回溯法经典问题）
3. **P2392 kkksc03考前临时抱佛脚**（DFS 剪枝与资源分配）

---

## 个人心得摘录
- **踩坑教训**：题解3未考虑 `k < n` 的情况，错误使用全排列导致逻辑漏洞。
- **调试经验**：在 DFS 中输出中间状态，观察服务器选择顺序是否正确。

---

## 代码实现（题解1完整版）
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, a[7], b[7], p[7];
bool f = 1, u[7];

void dfs(int s) {
    if (s == k + 1) {
        if (f) {
            for (int i = 1; i <= k; i++) cout << p[i] << " ";
            f = 0;
        }
        return;
    }
    for (int i = 1; i <= n; i++) {
        if (a[i] >= b[s] && !u[i]) {
            p[s] = i;
            u[i] = 1;
            dfs(s + 1);
            u[i] = 0;
        }
    }
}

int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= k; i++) cin >> b[i];
    dfs(1);
    if (f) cout << "-1";
    return 0;
}
```

---
处理用时：86.84秒
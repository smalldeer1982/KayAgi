# 题目信息

# [yLOI2022] 西施江南

## 题目背景

> 我晤江南面 如逢西施颜  
> 清芬宜送岸 菡萏新雨前  
> 皓腕分珠帘 珠露扬波珠玉敛  
> 天然一段聚散 嫣然曾与言  
> 平芜辙尚浅 无韵化湖田  
> 林园虽工典 芳姿不可嵌  
> 何人冠诗篇 重街杳杳重门掩  
> 似有柔荑遮目 空谷足尖

银临《西施江南》

## 题目描述

给定 $n$ 个正整数 $a_1, a_2, a_3, \dots a_n$，记 $g$ 是这些数的**最大公约数**，$l$ 是这些数的**最小公倍数**。请你判断 $l \times g$ 是否等于 $a_1 \times a_2 \times \dots \times a_n$。

## 说明/提示

### 数据规模与约定

以下用 $N$ 表示单个测试点内 $n$ 的和，即 $N = \sum n$。

- 对 $12\%$ 的数据，保证 $n = 2$。
- 对 $36\%$ 的数据，保证 $n \leq 5$。
- 对 $52\%$ 的数据，保证 $N \leq 1000$。
- 对 $76\%$ 的数据，保证 $N,a_i \leq 10^5$。
- 对 $100\%$ 的数据，保证 $2 \leq n,N \leq 5 \times 10^5$，$2 \leq a_i \leq 10^8$，$1 \leq T \leq 20$。

### 提示

**数据千万条，清空第一条**。  
**多测不清空，爆零两行泪**。  
**清空不规范，超时总相伴**。

## 样例 #1

### 输入

```
3
2
2 3
3
2 3 4
3
3 8 35```

### 输出

```
Yes
No
Yes```

## 样例 #2

### 输入

```
见附加文件中的 C2.in```

### 输出

```
见附加文件中的 C2.ans```

# AI分析结果



### 唯一算法分类
数学（质因数分解与互质判断）

---

### 题解思路、算法要点与解决难点

#### 核心思路
当且仅当满足以下条件时成立：
1. **n=2**（直接返回 Yes）
2. **n>2且所有数两两互质**（需验证每个质因数只在一个数中出现）

#### 算法实现要点
1. **质因数分解**：预处理小质数（如1e4以内），加速分解过程
2. **质因数冲突检测**：用哈希表记录已出现的质因数，分解时发现重复则返回 No
3. **大质数处理**：分解后剩余的大质数（>1e4）需单独检查

#### 解决难点
- **高效分解质因数**：通过预筛质数将分解复杂度从 O(√a) 降至 O(π(√a))
- **哈希表清空**：多测时必须清空质因数记录，否则导致错误
- **大质数遗漏**：分解后剩余的大质数可能未被记录，需单独处理

---

### 题解评分（≥4星）

1. **一扶苏一（★★★★★）**
   - **亮点**：基于唯一分解定理的数学推导，代码使用线性筛预处理最小质因子，分解效率 O(log a)
   - **代码**：利用最小质因子快速分解，避免重复计算

2. **cff_0102（★★★★☆）**
   - **亮点**：线性筛预处理1e8内质数，分解时严格检查质因数冲突
   - **优化**：代码中处理大质数剩余部分，逻辑清晰

3. **船酱魔王（★★★★☆）**
   - **亮点**：使用最小质因子数组快速分解，代码简洁高效
   - **心得**：强调多测清空的重要性，避免残留数据干扰

---

### 最优思路或技巧提炼

1. **质数预处理**：筛出小质数（如1e4以内）加速分解，仅需检查质数而非所有因子
2. **最小质因子分解法**：预处理每个数的最小质因子，分解复杂度降至 O(log a)
3. **哈希表标记冲突**：分解时动态记录质因数，发现重复立即终止
4. **大质数特判**：分解剩余的大质数必须加入检查，避免遗漏

---

### 同类型题及算法套路

- **质因数冲突判断**：CF1771C（判断数组是否存在公共质因数）
- **互质数组性质**：P2568（GCD性质相关）
- **质因数分解优化**：B3716（最小质因子分解）

---

### 推荐相似题目
1. [CF1771C] Hossam and Trainees（质因数冲突判断）
2. [P3383] 线性筛素数（质数预处理基础）
3. [B3716] 分解质因子 2（最小质因子分解应用）

---

### 个人心得摘录

- **多测清空**：多组数据时未清空哈希表是常见错误（如信息向阳花木题解强调）
- **分解完整性**：剩余大质数必须检查，否则导致错误（如int08题解的Hack数据）
- **效率取舍**：预处理质数牺牲空间换时间，适合大数据（如cff_0102的1e8筛法）

---

### 可视化与算法演示设计

#### 核心算法流程
1. **质数筛**：展示线性筛过程，质数标记为黄色
2. **质因数分解**：每个数分解时，质因数块从原数分离并染色（已存在→红色，新出现→绿色）
3. **冲突检测**：当红色块出现时，播放错误音效并高亮冲突质因数

#### 复古像素风格
- **调色板**：16色，质数块用亮黄，冲突红，正常绿
- **Canvas动画**：质因数块以8x8像素方块飞向哈希表，碰撞检测时闪烁
- **音效设计**：
  - 分解成功：8-bit短音（类似NES金币声）
  - 冲突发生：低音警报声
  - 背景音乐：循环芯片音乐（Web Audio API）

#### 交互功能
- **步进控制**：空格暂停/继续，方向键单步
- **速度调节**：滑块控制动画速度（1x-10x）
- **AI自动演示**：自动按最优路径分解，展示质因数冲突过程

---

### 关键代码片段（核心逻辑）

```cpp
// 预处理最小质因子（线性筛）
void getPrime() {
  for (int i = 2; i <= 1e8; ++i) {
    if (!np[i]) prm.push_back(i), pre[i] = i;
    for (auto p : prm) {
      if (i * p > 1e8) break;
      pre[i * p] = p; // 记录最小质因子
      if (i % p == 0) break;
    }
  }
}

// 分解并检查冲突
bool check(int x, unordered_set<int>& st) {
  while (x != 1) {
    int p = pre[x]; // 取最小质因子
    if (st.count(p)) return false;
    st.insert(p);
    while (x % p == 0) x /= p;
  }
  if (x > 1) { // 处理大质数
    if (st.count(x)) return false;
    st.insert(x);
  }
  return true;
}
```

---

### 可视化代码示例（Canvas动画）

```javascript
// 初始化像素网格
const grid = new PixelGrid(canvas, 16, 16); 
grid.fill(0x000000); // 黑色背景

// 质因数块动画
function animateFactorization(num, primes) {
  primes.forEach((p, i) => {
    const block = new PixelBlock(p.toString(), 8, 8);
    block.color = isConflict(p) ? 0xFF0000 : 0x00FF00;
    block.moveTo(num.pos.x + i*10, num.pos.y);
    block.flyTo(hashTablePos, () => {
      if (block.color === 0xFF0000) playSound('error');
    });
  });
}

// 音效触发
function playSound(type) {
  const sfx = {
    error: new EightBitSound(500, 'square', 0.2),
    success: new EightBitSound(1200, 'sine', 0.5)
  };
  sfx[type].play();
}
```

---
处理用时：88.26秒
# 题目信息

# [USACO20DEC] Stuck in a Rut B

## 题目描述

Farmer John 最近扩大了他的农场，从奶牛们的角度看来这个农场相当于是无限大了！奶牛们将农场上放牧的区域想作是一个由正方形方格组成的无限大二维方阵，每个方格中均有美味的草（将每个方格看作是棋盘上的一个方格）。Farmer John 的 $N$ 头奶牛（$1\le N\le 50$）初始时位于不同的方格中，一部分朝向北面，一部分朝向东面。

每一小时，每头奶牛会执行以下二者之一：

 - 如果她当前所在的方格里的草已经被其他奶牛吃掉了，则她会停下。
 - 吃完她当前所在的方格中的所有草，并向她朝向的方向移动一个方格。

经过一段时间，每头奶牛的身后会留下一条被啃秃了的轨迹。

如果两头奶牛在一次移动中移动到了同一个有草的方格，她们会分享这个方格中的草，并在下一个小时继续沿她们朝向的方向移动。

请求出每头奶牛吃到的草的数量。有些奶牛永远不会停下，从而吃到无限多的草。 

## 说明/提示

### 测试点性质

 - 测试点 $2-5$ 中，所有坐标不超过 $100$。
 - 测试点 $6-10$ 没有额外限制。

## 样例 #1

### 输入

```
6
E 3 5
N 5 3
E 4 6
E 10 4
N 11 2
N 8 1```

### 输出

```
5
3
Infinity
Infinity
2
5```

# AI分析结果



## 唯一算法分类  
**模拟/排序枚举**

---

## 综合分析与结论  
### 核心思路与难点  
所有题解均基于以下核心逻辑：  
1. **分类排序**：将东向（E）和北向（N）的牛分别按坐标排序。  
2. **交点判断**：遍历两类牛的每一对可能相遇的组合，计算它们的交点。  
3. **距离比较**：比较两牛到达交点的时间差，确定谁被阻挡。  
4. **动态更新**：维护每头牛的最早被阻挡距离，若未被阻挡则输出`Infinity`。  

**核心难点**在于：  
- 正确处理阻挡事件的**时序性**（被阻挡的牛不再影响后续计算）。  
- 通过排序（如按坐标或`x+y`）确保优先处理可能更早发生阻挡的牛对。  

### 算法流程与可视化设计  
1. **分类与排序**：  
   - 将东向牛按`y`坐标排序，北向牛按`x`坐标排序。  
   - **可视化**：以不同颜色区分两类牛，排序后按坐标绘制在网格上。  
   ```cpp  
   sort(E+1, E+e_cnt+1, cmp_y);  // 东向按y排序  
   sort(N+1, N+n_cnt+1, cmp_x);  // 北向按x排序  
   ```  
2. **双重循环检查交点**：  
   - 对每对东向牛`E[i]`和北向牛`N[j]`，计算它们的交点`(N[j].x, E[i].y)`。  
   - 计算两牛到达交点的距离：  
     - `E[i]`的移动距离：`dx = N[j].x - E[i].x`  
     - `N[j]`的移动距离：`dy = E[i].y - N[j].y`  
   ```cpp  
   int dx = N[j].x - E[i].x;  
   int dy = E[i].y - N[j].y;  
   ```  
3. **更新阻挡状态**：  
   - 若`dx < dy`：东向牛`E[i]`先到，北向牛`N[j]`被阻挡。  
   - 若`dx > dy`：北向牛`N[j]`先到，东向牛`E[i]`被阻挡。  
   - **可视化**：在交点上标记阻挡关系，高亮当前比较的牛对。  
   ```cpp  
   if (dx < dy && !ans[N[j].id])  
       ans[N[j].id] = dy;  // 北向牛被阻挡  
   else if (dx > dy) {  
       ans[E[i].id] = dx; // 东向牛被阻挡  
       break;  // 提前跳出，避免后续无效检查  
   }  
   ```  

---

## 题解清单（评分≥4星）  
1. **作者：FZY_CZY (5星)**  
   - **亮点**：代码简洁，双重循环一次处理两类牛的阻挡，通过排序优化时间复杂度。  
   - **关键代码**：  
     ```cpp  
     for (int i=1; i<=sum_e; i++)  
         for (int j=1; j<=sum_n; j++)  
             if (N[j].x >= E[i].x && N[j].y <= E[i].y)  
                 // 计算dx, dy并更新答案  
     ```  

2. **作者：Arson1st (4.5星)**  
   - **亮点**：采用`x+y`排序处理阻挡顺序，确保优先级。  
   - **关键优化**：通过`x+y`排序模拟“拓扑序”，避免重复判断。  

3. **作者：zxh923 (4星)**  
   - **亮点**：代码极简，仅用单一双重循环完成所有判断。  
   - **代码片段**：  
     ```cpp  
     for (int i=1; i<=cnte; i++)  
         for (int j=1; j<=cntn; j++)  
             if (nor[j].x >= eas[i].x && nor[j].y <= eas[i].y)  
                 // 更新答案  
     ```  

---

## 最优思路与技巧提炼  
1. **排序优化**：  
   - 东向牛按`y`升序，北向牛按`x`升序。确保在循环中优先处理可能更早阻挡的牛。  
2. **动态剪枝**：  
   - 一旦确定某头牛被阻挡，立即跳出内层循环（如东向牛被阻挡后不再检查后续北向牛）。  
3. **距离比较**：  
   - 用`dx`和`dy`的差值代替除法，避免浮点运算，提高效率。  

---

## 类似题目推荐  
1. **[P2778 机器人路径规划](https://www.luogu.com.cn/problem/P2778)**  
   - 涉及移动物体的碰撞检测与路径模拟。  
2. **[P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)**  
   - 排序后处理事件顺序，类似阻挡判断。  
3. **[P1908 逆序对](https://www.luogu.com.cn/problem/P1908)**  
   - 利用排序优化事件处理顺序。  

---

## 个人心得摘录  
- **FZY_CZY**：  
  > “排序后只需一次双重循环，避免二次遍历，减少代码复杂度。”  
- **Union_Find**：  
  > “多次循环直到答案稳定，虽非最优，但启发我理解阻挡的时序性。”  

---

## 可视化与算法演示  
### 复古像素风格设计  
1. **画面布局**：  
   - **8色调色板**：东向牛用红色像素块，北向牛用蓝色像素块，轨迹为灰色。  
   - **网格绘制**：用Canvas绘制`10x10`网格，坐标范围动态缩放。  
2. **动画逻辑**：  
   - **步进控制**：按空格键单步执行循环，高亮当前比较的牛对。  
   - **音效**：  
     - **移动音效**：8-bit风格短音，每次牛移动时播放。  
     - **阻挡音效**：低沉音效，当牛被阻挡时触发。  
3. **自动演示模式**：  
   - **AI逻辑**：按排序顺序自动遍历牛对，每步延迟500ms，用绿色高亮交点和距离差。  

```javascript  
// 伪代码：Canvas绘制牛和轨迹  
function drawCow(x, y, color) {  
    ctx.fillStyle = color;  
    ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);  
}  
// 音效触发  
function playSound(effect) {  
    const sfx = { move: 'beep1.wav', block: 'block.wav' };  
    new Audio(sfx[effect]).play();  
}  
```  

---

**代码实现（核心片段）**  
```cpp  
// 东向和北向牛分类排序  
sort(E + 1, E + e_cnt + 1, [](auto& a, auto& b) { return a.y < b.y; });  
sort(N + 1, N + n_cnt + 1, [](auto& a, auto& b) { return a.x < b.x; });  

for (int i = 1; i <= e_cnt; i++) {  
    for (int j = 1; j <= n_cnt; j++) {  
        if (N[j].x < E[i].x || N[j].y > E[i].y) continue;  
        int dx = N[j].x - E[i].x, dy = E[i].y - N[j].y;  
        if (dx < dy && !ans[N[j].id])  
            ans[N[j].id] = dy;  
        else if (dx > dy) {  
            ans[E[i].id] = dx;  
            break;  
        }  
    }  
}  
```

---
处理用时：108.25秒
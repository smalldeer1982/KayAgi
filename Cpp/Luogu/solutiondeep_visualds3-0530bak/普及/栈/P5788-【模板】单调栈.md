# 题目信息

# 【模板】单调栈

## 题目背景

模板题，无背景。  

2019.12.12 更新数据，放宽时限，现在不再卡常了。

## 题目描述

给出项数为 $n$ 的整数数列 $a_{1 \dots n}$。

定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_i$ 的元素的**下标**，即 $f(i)=\min_{i<j\leq n, a_j > a_i} \{j\}$。若不存在，则 $f(i)=0$。

试求出 $f(1\dots n)$。

## 说明/提示

【数据规模与约定】

对于 $30\%$ 的数据，$n\leq 100$；

对于 $60\%$ 的数据，$n\leq 5 \times 10^3$ ；

对于 $100\%$ 的数据，$1 \le n\leq 3\times 10^6$，$1\leq a_i\leq 10^9$。

## 样例 #1

### 输入

```
5
1 4 2 3 5
```

### 输出

```
2 5 4 5 0
```

# AI分析结果



**唯一算法分类**：单调栈

---

### **综合分析与结论**
**核心思路**：从后向前遍历数组，维护一个单调递减栈。对于每个元素，弹出栈顶比当前元素小的元素，此时栈顶即为第一个更大元素的下标。压入当前元素下标，确保栈的单调性。

**解决难点**：  
1. **方向选择**：从后向前遍历确保处理每个元素时，栈中保存的是其后所有可能的候选元素。  
2. **栈维护**：单调递减栈保证栈顶是最近的更大元素，弹出较小的元素避免重复比较。  
3. **时间复杂度**：每个元素入栈、出栈一次，总时间复杂度为 O(n)。

**可视化设计**：  
- **动画流程**：  
  1. 初始化一个栈和答案数组。  
  2. 从右向左遍历数组，用高亮色标记当前元素。  
  3. 弹出栈顶比当前小的元素（红色闪烁），栈顶变为答案（绿色标记）。  
  4. 当前元素入栈（蓝色标记）。  
  5. 答案数组实时更新，显示当前结果。  
- **复古像素风格**：  
  - 数组元素用 8-bit 像素块表示，栈用垂直排列的方块。  
  - 音效：弹出时播放“哔”声，找到答案时播放“叮”声，背景音乐为低循环芯片音乐。  
  - 自动演示模式下，算法以 1秒/步自动执行，支持暂停和回放。

---

### **题解清单 (≥4星)**
1. **Mine_King（5星）**  
   - **亮点**：思路清晰，STL栈实现简洁，配图解释直观。  
   - **关键代码**：  
     ```cpp
     for (int i = n; i >= 1; i--) {
         while (!s.empty() && a[s.top()] <= a[i]) s.pop();
         f[i] = s.empty() ? 0 : s.top();
         s.push(i);
     }
     ```

2. **封禁用户（5星）**  
   - **亮点**：手写数组栈优化效率，比喻生动（选手淘汰机制）。  
   - **关键代码**：  
     ```cpp
     while (a[i] >= a[q[r]] && r > 0) r--;
     f[i] = q[r];
     q[++r] = i;
     ```

3. **pomelo_nene（4星）**  
   - **亮点**：详细讲解单调栈变种和例题（如直方图矩形），扩展性强。  
   - **关键代码**：  
     ```cpp
     while (top && !(a[S[top]] >= a[i])) f[S[top--]] = i;
     S[++top] = i;
     ```

---

### **最优思路与代码**
**核心逻辑**：数组模拟栈 + 倒序遍历  
```cpp
int a[MAXN], stk[MAXN], ans[MAXN], top = 0;
for (int i = n; i >= 1; i--) {
    while (top && a[stk[top]] <= a[i]) top--; // 弹出较小元素
    ans[i] = top ? stk[top] : 0;             // 栈顶为答案
    stk[++top] = i;                          // 压入当前索引
}
```

**关键点**：  
- 栈中存储下标而非元素值，便于直接获取位置。  
- 倒序遍历确保候选元素在右侧已处理完毕。

---

### **同类型题与推荐题目**
1. **P5788 【模板】单调栈**（本题）  
2. **P2866 [USACO06NOV] Bad Hair Day**（单调栈经典问题）  
3. **P2559 [AHOI2006] 最大矩形**（直方图中最大矩形，单调栈变种）  
4. **P1886 滑动窗口 /【模板】单调队列**（单调队列类似思想）

---

### **个人心得摘录**
- **Mine_King**：栈中存下标而非值，避免值相同但位置不同导致的错误。  
- **封禁用户**：手写栈比 STL 快 2 倍，数据规模大时必须优化。  
- **wenye05**：正向遍历时需保证栈单调性，但需处理未弹出元素的答案（初始化为 0）。

---

### **可视化代码片段（JS Canvas）**
```javascript
// 绘制栈和数组（伪代码）
function drawStep(currentIndex, stack, answers) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 绘制数组
    for (let i = 0; i < arr.length; i++) {
        drawPixelBlock(i * 30, 50, arr[i], i === currentIndex ? 'yellow' : 'white');
    }
    // 绘制栈
    stack.forEach((idx, i) => {
        drawPixelBlock(400, 100 + i * 30, arr[idx], 'blue');
    });
    // 绘制答案
    answers.forEach((ans, i) => {
        drawText(i * 30, 200, ans || '0');
    });
}
// 音效触发
function playSound(effect) {
    const sfx = { pop: 'beep.mp3', answer: 'ding.mp3' };
    new Audio(sfx[effect]).play();
}
```

---
处理用时：68.10秒
# 题目信息

# [USACO22JAN] Cow Frisbee S

## 题目描述

Farmer John 的 $N\ (N\le 3\times 10^5)$ 头奶牛的高度为 $1, 2, \ldots, N$。一天，奶牛以某个顺序排成一行玩飞盘；令 $h_1 \ldots h_N$ 表示此顺序下奶牛们的高度（因此 $h$ 是 $1 \ldots N$ 的一个排列）。

队伍中位于位置 $i$ 和 $j$ 的两头奶牛可以成功地来回扔飞盘当且仅当她们之间的每头奶牛的高度都低于 $\min(h_i, h_j)$。

请计算所有可以成功地来回扔飞盘的奶牛所在的位置对 $i\le j$ 之间的距离总和。位置 $i$ 和 $j$ 之间的距离为 $j-i+1$。

## 说明/提示

【样例解释】

这个例子中可以成功的位置对如下：

```
(1, 2), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (4, 5), (5, 6), (6, 7)
```

【数据范围】

- 测试点 1-3 满足 $N\le 5000$。

- 测试点 4-11 没有额外限制。

## 样例 #1

### 输入

```
7
4 3 1 2 5 6 7```

### 输出

```
24```

# AI分析结果



## 算法分类
**单调栈**

---

## 题解思路与算法要点

### **核心思路**
维护单调递减栈，每次处理新元素时：
1. **弹出栈顶所有比当前元素小的元素**：这些元素与当前元素形成的对满足条件（中间元素均小于较小者）
2. **累加当前元素与栈顶元素的距离**（若栈非空）

### **解决难点**
1. **正确覆盖所有有效对**：每个有效对 (i,j) 被恰好计算一次，当处理较大元素时，弹出较小元素并累加距离。
2. **单调栈的维护**：保持栈内元素递减，确保中间元素均小于当前元素和栈顶元素的最小值。

### **关键变量与数据结构**
- **单调栈**：存储下标，保持对应元素递减
- **距离累加方式**：每次弹出栈顶时累加 `i - s.top() + 1`，处理栈顶元素时累加相同公式

---

## 题解评分（≥4星）

### **V1mnkE 题解（5星）**
- **亮点**：代码简洁，思路清晰，直接维护单调栈并处理弹出和累加
- **代码可读性**：变量命名直观，逻辑紧凑
- **核心代码**：
  ```cpp
  while (!s.empty() && a[s.top()] < a[i]) {
      ans += i - s.top() + 1;
      s.pop();
  }
  if (!s.empty()) ans += i - s.top() + 1;
  s.push(i);
  ```

### **I_am_Accepted 题解（4星）**
- **亮点**：代码精简，直接使用 STL 栈，无需额外预处理
- **核心逻辑**：与 V1mnkE 类似，但变量命名更简洁

### **lsj2009 题解（4星）**
- **亮点**：详细注释和分步解释，适合新手理解
- **代码实现**：通过栈维护左右两边最近更大元素，两次处理覆盖所有情况

---

## 最优思路提炼
- **单调栈维护递减序列**：确保每次处理元素时，栈内元素为可能形成有效对的候选
- **弹出时累加距离**：每个弹出的栈顶元素与当前元素形成有效对
- **栈顶元素处理**：当前元素与栈顶（若存在）形成另一有效对

---

## 同类型题与算法套路
1. **寻找最近更大元素**：如 LeetCode 496. 下一个更大元素 I
2. **区间极值问题**：如 LeetCode 84. 柱状图中最大的矩形
3. **滑动窗口极值**：如 LeetCode 239. 滑动窗口最大值

---

## 推荐题目
1. **P5788**：单调栈模板题（寻找右侧第一个更大元素）
2. **P1901**：求每个元素的左右最近更高元素
3. **P2866**：单调栈应用，计算满足条件的对数

---

## 可视化算法演示

### **动画设计**
- **元素入栈**：以绿色方块表示，从右侧进入栈区
- **元素弹出**：以红色闪烁表示，显示累加的距离值
- **栈状态**：实时显示栈内元素下标及对应高度值

### **复古像素风格**
- **颜色方案**：栈内元素用蓝色，当前元素用黄色，弹出元素用红色
- **音效**：元素弹出时播放 `8-bit` 音效，累加距离时显示像素数字动画
- **交互控制**：支持暂停/继续、步进执行，速度可调节

### **关键步骤演示**
1. 初始栈为空，处理第一个元素 `i=1`
2. 处理 `i=2` 时，弹出所有 `<a[2]` 的元素，累加距离
3. 每次弹出后更新栈状态，显示当前累加的总距离

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

long long n, ans = 0;
long long a[300005];
stack<long long> s;

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) {
        while (!s.empty() && a[s.top()] < a[i]) {
            ans += i - s.top() + 1;
            s.pop();
        }
        if (!s.empty()) ans += i - s.top() + 1;
        s.push(i);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 个人心得摘录
- **单调栈方向**：递减栈可自然处理“中间元素较小”的条件
- **下标处理**：栈中存下标而非值，方便计算距离
- **边界条件**：栈空时无需累加，避免越界

---

## 可视化代码片段（Canvas 绘制栈）
```javascript
// 绘制栈内元素（伪代码）
function drawStack(ctx, stack) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    stack.forEach((idx, i) => {
        drawRect(ctx, i * 50, 100, 40, 40, 'blue'); // 栈元素
        drawText(ctx, idx, i * 50 + 10, 120); // 显示下标
    });
}
```

---
处理用时：167.31秒
# 题目信息

# [蓝桥杯 2015 省 B] 生命之树

## 题目描述

在 X 森林里，上帝创建了生命之树。

他给每棵树的每个节点（叶子也称为一个节点）上，都标了一个整数，代表这个点的和谐值。

上帝要在这棵树内选出一个节点集合 $S$（允许为空集），使得对于 $S$ 中的任意两个点 $a,b$，都存在一个点列 ${a,v_1,v_2, \cdots ,v_k,b}$ 使得这个点列中的每个点都是 $S$ 里面的元素，且序列中相邻两个点间有一条边相连。

在这个前提下，上帝要使得 $S$ 中的点所对应的整数的和尽量大。

这个最大的和就是上帝给生命之树的评分。

经过 atm 的努力，他已经知道了上帝给每棵树上每个节点上的整数。但是由于 atm 不擅长计算，他不知道怎样有效的求评分。他需要你为他写一个程序来计算一棵树的分数。

## 说明/提示

对于 $30\%$ 的数据，$n \le 10$。

对于 $100\%$ 的数据，$0<n \le 10^5,$ 每个节点的评分的绝对值不超过 $10^6$。

时限 3 秒, 256M。

蓝桥杯 2015 省赛 B 组 J 题。

## 样例 #1

### 输入

```
5
1 -2 -3 4 5
4 2
3 1
1 2
2 5```

### 输出

```
8```

# AI分析结果



---

**唯一算法分类**：树形动态规划（树形DP）

---

### **题解思路与核心难点**

1. **问题核心**  
   在树结构中选取连通子图，使点权和最大。允许空集（和为0）。

2. **算法核心**  
   - **状态定义**：`dp[u]` 表示以 `u` 为根的子树中，包含 `u` 的最大连通子图点权和。  
   - **状态转移**：对于每个节点 `u`，累加所有子节点 `v` 的正贡献 `max(dp[v], 0)`。  
   - **最终答案**：取所有 `dp[u]` 的最大值与0比较（空集情况）。

3. **解决难点**  
   - **连通性保证**：通过树形DP确保子图连通。  
   - **负值处理**：舍弃负贡献的子节点（`max(dp[v], 0)`）。  
   - **空集处理**：最终答案需与0比较，避免全负情况。

---

### **题解评分 (≥4星)**

1. **xler0915（★★★★★）**  
   - **亮点**：思路清晰，代码简洁，正确性高，使用邻接表和DFS。  
   - **代码**：正确处理空集，数据类型为 `long long`，避免溢出。

2. **Iniaugoty（★★★★）**  
   - **亮点**：强调 `long long` 的必要性，修正空集问题，链式前向星存图。  
   - **心得**：“十年OI一场空，不开long long见祖宗”。

3. **Furina_Hate_Comma（★★★☆）**  
   - **亮点**：简洁实现，但代码中未显式处理空集（需依赖初始化为0）。

---

### **最优思路与技巧**

1. **关键思路**  
   - **树形DP状态设计**：从叶子到根逐层合并子问题。  
   - **贪心剪枝**：仅累加正贡献的子节点。

2. **代码技巧**  
   ```cpp
   void dfs(int u, int fa) {
       dp[u] = a[u]; // 初始化为当前节点权值
       for (int v : adj[u]) {
           if (v == fa) continue;
           dfs(v, u);
           if (dp[v] > 0) dp[u] += dp[v]; // 仅累加正贡献
       }
   }
   ```

3. **同类型题**  
   - [P1122 最大子树和](https://www.luogu.com.cn/problem/P1122)  
   - [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)  
   - [P2634 树的直径](https://www.luogu.com.cn/problem/P2634)

---

### **可视化与算法演示**

1. **动画设计**  
   - **树形展示**：以节点为中心，子节点按层次展开。  
   - **颜色标记**：  
     - 当前处理节点 `u`：红色高亮。  
     - 子节点 `v`：绿色（`dp[v]>0`）或灰色（`dp[v]≤0`）。  
   - **数值更新**：动态显示 `dp[u]` 的累加过程。

2. **复古像素风格**  
   - **节点绘制**：8位像素方块，中心显示权值。  
   - **音效设计**：  
     - 正贡献累加：清脆“金币声”。  
     - 负贡献舍弃：低沉“错误音”。  
   - **自动演示**：DFS过程自动执行，速度可调。

---

### **完整代码（xler0915题解）**

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int a[100005];
long long dp[100005];
vector<int> adj[100005];

void dfs(int u, int fa) {
    dp[u] = a[u];
    for (int v : adj[u]) {
        if (v == fa) continue;
        dfs(v, u);
        dp[u] += max(dp[v], 0LL);
    }
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    dfs(1, 0);
    long long ans = 0;
    for (int i = 1; i <= n; i++) ans = max(ans, dp[i]);
    printf("%lld\n", max(ans, 0LL));
    return 0;
}
```

---

### **个人心得摘录**

- **Iniaugoty**：空集处理和数据类型的正确性直接影响得分。  
- **xler0915**：树形DP的贪心思想（只取正贡献）是解题关键。

---
处理用时：75.57秒
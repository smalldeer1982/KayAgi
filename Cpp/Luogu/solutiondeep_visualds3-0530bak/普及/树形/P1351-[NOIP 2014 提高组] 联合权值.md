# 题目信息

# [NOIP 2014 提高组] 联合权值

## 题目背景

NOIP2014 提高组 D1T2

## 题目描述

无向连通图 $G$ 有 $n$ 个点，$n-1$ 条边。点从 $1$ 到 $n$ 依次编号,编号为 $i$ 的点的权值为 $W_i$，每条边的长度均为 $1$。图上两点 $(u, v)$ 的距离定义为 $u$ 点到 $v$ 点的最短距离。对于图 $G$ 上的点对 $(u, v)$，若它们的距离为 $2$，则它们之间会产生 $W_v \times W_u$ 的联合权值。

请问图 $G$ 上所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少？

## 说明/提示

**样例解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/5zkpab9k.png)

本例输入的图如上所示，距离为 $2$ 的有序点对有$(1,3)$ 、$(2,4)$ 、$(3,1)$ 、$(3,5) $、$(4,2)$ 、$(5,3) $。

其联合权值分别为 $2,15,2,20,15,20$。其中最大的是 $20$，总和为 $74$。

 
**数据说明**

- 对于 $30\%$ 的数据，$1 < n \leq 100$；
- 对于 $60\%$ 的数据，$1 < n \leq 2000$；
- 对于 $100\%$ 的数据，$1 < n \leq 2\times 10^5$，$0 < W_i \leq 10000$。

保证一定存在可产生联合权值的有序点对。

## 样例 #1

### 输入

```
5  
1 2  
2 3
3 4  
4 5  
1 5 2 3 10 ```

### 输出

```
20 74```

# AI分析结果



### 唯一算法分类
无算法分类（核心为数学优化与树的遍历）

---

### 综合分析与结论

#### 核心思路
题目要求树中所有距离为 2 的点对的联合权值最大值和总和。核心思路是枚举每个中间点，计算其邻居节点的权值贡献：
1. **最大值**：维护每个中间点的最大和次大权值，相乘后取全局最大值。
2. **总和**：利用公式 \((\sum w)^2 - \sum w^2\) 快速计算，避免遍历所有邻居对。

#### 解决难点
- **数学优化**：通过公式 \((\sum w)^2 - \sum w^2\) 将时间复杂度从 \(O(n^2)\) 降为 \(O(n)\)。
- **边界处理**：确保最大值不参与取模，总和取模时避免负数。

#### 可视化设计
- **动画流程**：
  1. 用树形结构展示节点，当前中间点高亮为黄色。
  2. 遍历中间点的邻居时，用绿色标记最大两个权值节点。
  3. 显示公式计算过程：实时更新 \(\sum w\) 和 \(\sum w^2\)，并在右侧展示 \((\sum w)^2 - \sum w^2\)。
- **复古像素风格**：
  - 节点用 8 位色块表示（中间点为红色，邻居为蓝色）。
  - 音效：每次计算中间点时播放“滴”声，找到最大值时播放上扬音效。
- **交互功能**：支持单步执行，速度调节，重播特定中间点。

---

### 题解清单（≥4星）

1. **wucstdio（★★★★★）**
   - **亮点**：代码高效，正确处理模运算，链式前向星存图。
   - **代码片段**：
     ```cpp
     for(int j=head[i];j;j=a[j].next) {
         if(w[a[j].to]>max1) max2=max1, max1=w[a[j].to];
         t1 = (t1 + w[a[j].to]) % 10007;
         t2 = (t2 + w[a[j].to]*w[a[j].to]) % 10007;
     }
     ans = (ans + t1*t1 - t2) % 10007;
     ```

2. **OIerWu_829（★★★★）**
   - **亮点**：使用 `vector` 邻接表，遍历时动态维护总和。
   - **代码片段**：
     ```cpp
     for (int u : G[i]) {
         pos = (pos + a[u]) % mod;
         if (a[u] > mx) { smx = mx; mx = a[u]; }
     }
     for (int u : G[i]) 
         sum = (sum + (pos - a[u]) * a[u]) % mod;
     ```

3. **CaiZi（★★★★）**
   - **亮点**：代码简洁，变量命名清晰，直接实现数学公式。
   - **代码片段**：
     ```cpp
     for(int j:g[i]) {
         x = (x + w[j]) % mod;
         y = (y + w[j] * w[j]) % mod;
     }
     s2 = (s2 + x*x - y) % mod;
     ```

---

### 最优思路提炼
1. **枚举中间点**：所有距离为 2 的点对必有一个中间点。
2. **数学公式优化**：用 \((\sum w)^2 - \sum w^2\) 计算总和，时间复杂度 \(O(n)\)。
3. **维护最大次大值**：遍历邻居时动态更新最大两个权值，避免排序。

---

### 相似题目推荐
1. **P2679 子串**（动态规划优化）
2. **P2015 二叉苹果树**（树形 DP 与边权统计）
3. **P1352 没有上司的舞会**（树的最大权独立集）

---

### 个人心得摘录
- **wucstdio**：强调最大值不能取模，否则会 WA。
- **yanxu_cn**：因未用 `long long` 调试多时，提醒注意数据类型。
- **qhr2023**：通过分治思路实现，但最终仍需数学优化。

---

### 核心代码实现（wucstdio版）
```cpp
#include<cstdio>
using namespace std;
struct edge { int next, to; } a[400005];
int edgenum, head[200005], w[200005];
int n, ans, maxx;

void add(int u, int v) {
    a[++edgenum].next = head[u];
    a[edgenum].to = v;
    head[u] = edgenum;
}

int main() {
    scanf("%d", &n);
    for(int i=1; i<n; i++) {
        int u, v; scanf("%d%d", &u, &v);
        add(u, v); add(v, u);
    }
    for(int i=1; i<=n; i++) scanf("%d", &w[i]);
    
    for(int i=1; i<=n; i++) {
        int max1=0, max2=0, t1=0, t2=0;
        for(int j=head[i]; j; j=a[j].next) {
            int v = a[j].to;
            if(w[v] > max1) max2 = max1, max1 = w[v];
            else if(w[v] > max2) max2 = w[v];
            t1 = (t1 + w[v]) % 10007;
            t2 = (t2 + w[v]*w[v]) % 10007;
        }
        ans = (ans + t1*t1 - t2 + 10007) % 10007;
        maxx = max(maxx, max1 * max2);
    }
    printf("%d %d", maxx, ans);
    return 0;
}
```

---

### 可视化设计（伪代码）
```javascript
// Canvas 绘制树结构
function drawTree() {
    ctx.fillStyle = "#FF0000"; // 中间点红色
    ctx.fillRect(x, y, 20, 20);
    ctx.fillStyle = "#0000FF"; // 邻居蓝色
    neighbors.forEach(neighbor => {
        ctx.fillRect(neighbor.x, neighbor.y, 20, 20);
    });
}

// 步进执行中间点计算
function step() {
    highlight(currentNode); // 高亮中间点
    let sum = 0, sumSq = 0;
    neighbors.forEach(neighbor => {
        sum += neighbor.w;
        sumSq += neighbor.w * neighbor.w;
        if (neighbor.w > max1) { /* 更新最大次大值 */ }
    });
    playSound("beep"); // 计算音效
    updateFormulaDisplay(sum, sumSq); // 显示公式结果
}
```

---
处理用时：212.63秒
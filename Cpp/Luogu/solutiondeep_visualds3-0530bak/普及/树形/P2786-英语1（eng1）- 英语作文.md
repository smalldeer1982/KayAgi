# 题目信息

# 英语1（eng1）- 英语作文

## 题目背景

蒟蒻 HansBug 在英语考场上，挠了无数次的头，可脑子里还是一片空白。

## 题目描述

眼下出现在 HansBug 蒟蒻面前的是一篇英语作文，然而智商捉急的 HansBug 已经草草写完了，此时他发现离考试结束还有 $40$ 分钟，于是他打算估计一下这篇共有 $M$ 个单词的英语作文的含金量如何。众所周知的是，在中高考英语作文中使用高级词汇可以有效提高文章的含金量，从而获得更好的分数。已知蒟蒻HansBug知道 $N$ 个高级词汇，该词汇为 $A_i$（词汇长度为 $L_i$ ，包含数字、大小写字母），该高级词汇的含金量为 $B_i$，则该高级词汇每出现一次便可增加 $B_i$ 的含金量。可是他脑细胞和 RP 已经消耗殆尽，所以这个伟大的任务就交给你啦！

## 说明/提示

样例 $1$ 中，共计出现了 $2$ 次`hansbug`、 $2$ 次`absi2011` 、 $1$ 次 `yyy` 、 $1$ 次`kkksc03`、 $1$ 次  `lzn` ，所以总含金量为 $1\times2+2\times4+3\times1+4\times1+100\times1=115$，对 $99$ 取模就是 $16$ 。

样例 $2$ 中，和样例 $1$ 基本一样，值得注意的是整体的 `yyyy` 不可以被认为是 `yyy` 出现 $2$ 次，请注意这是一篇英语作文，一切以单词为最小单位。

此题目中大小写敏感。

数据范围（设所有单词的最大长度为 $Lmax$ ）：

![](https://cdn.luogu.com.cn/upload/pic/2228.png)


## 样例 #1

### 输入

```
5 99
hansbug 1
kkksc03 2
yyy 3
absi2011 4
lzn 100
hansbug is a juruo!but absi2011 not.!?!
one day absi2011 laughed at yyy and hansbug.
then kkksc03 and lzn blamed him for that.
```

### 输出

```
16```

## 样例 #2

### 输入

```
5 99
yyyy 1
kkksc03 2
yyy 3
absi2011 4
lzn 100
yyyy is a juruo!but absi2011 not.!?!
one day absi2011 laughed at yyy and yyyy.
then kkksc03 and lzn blamed him for that.
```

### 输出

```
16```

# AI分析结果



# 算法分类
**哈希表**

---

# 题解分析

## 核心难点与解决方案
1. **单词分割**：需要正确处理英文标点符号与单词的边界（如 `, .!?` 均为分隔符）
2. **高效匹配**：在大规模数据下，快速判断单词是否属于高级词汇（哈希表 vs 红黑树 vs 字典树）
3. **空间优化**：Trie 树在极端情况下可能出现内存超限（如题解中的 MLE 案例）

## 题解对比与评分（≥4星）

### Diamiko（4星）
- **亮点**：使用 `std::map` 极简实现，代码逻辑清晰，适合快速开发
- **关键代码**：通过逐个字符判断分隔符，动态构建单词
- **优化点**：`map` 的 O(logN) 查找效率略低于哈希表

```cpp
while(scanf("%c",&c)!=EOF) {
    if(!isalnum(c)) { // 非字母数字触发查询
        ans += a[t] % p;
        t = "";
    } else t += c;
}
```

### BackSlashDelta（4星）
- **亮点**：双哈希值 + 二分查找，规避哈希冲突风险
- **核心思想**：预处理哈希值排序，用二分替代树形结构查询
- **注意点**：哈希函数设计复杂度较高

```cpp
ulint hashit(string s) { // 双种子异或哈希
    val = s[i] * base + (val ^ seed_1);
    val ^= seed_2;
}
```

### Edgaru089（5星）
- **亮点**：C++11 的 `unordered_map` 实现 O(1) 查询
- **性能优势**：内置哈希表比手动实现更高效稳定
- **代码精简**：利用 `getline` 逐行处理文本

```cpp
unordered_map<string, int> m;
m.rehash(200000); // 预分配哈希桶提升性能
```

---

# 最优思路提炼
1. **哈希表存储**：用 `unordered_map` 实现 O(1) 时间复杂度的单词查询
2. **流式处理文本**：逐个字符读取，动态拼接单词，遇到分隔符立即触发查询
3. **模运算优化**：在累加过程中实时取模，避免数值溢出

```cpp
// 核心逻辑伪代码
unordered_map<string, int> dict;
string current_word;
while(读取字符 ch) {
    if (ch是分隔符 && current_word非空) {
        ans = (ans + dict[current_word]) % mod;
        current_word.clear();
    } else {
        current_word += ch;
    }
}
```

---

# 同类题型推荐
1. [P3370 - 字符串哈希](https://www.luogu.com.cn/problem/P3370)
2. [P1308 - 统计单词数](https://www.luogu.com.cn/problem/P1308)
3. [P2580 - 于是他错误的点名开始了](https://www.luogu.com.cn/problem/P2580)

---

# 可视化设计
**动画方案：像素风单词扫描器**
1. **界面布局**：16x16 像素网格展示文本流，右侧显示哈希表桶结构
2. **动态效果**：
   - 绿色像素块标记正在拼接的单词
   - 红色闪烁表示检测到分隔符触发查询
   - 黄色高亮显示哈希表中匹配成功的单词
3. **音效交互**：
   - 字符输入：8-bit 打字机音效
   - 单词匹配：NES风格金币收集音效
   - 错误/溢出：经典 FC 错误音效

**控制面板**：
- 步进模式：空格键单步执行字符处理
- 速度滑块：调节字符处理速度（10ms~1s）
- 哈希模式切换：对比 map/unordered_map 的查询路径差异

---

# 个人心得摘录
> "本题从理论上来说应该是一道trie的题，但实际因空间问题被迫改用哈希。验证了工程中理论最优与实践最优的差异。" —— 户山香澄  
> "被卡的飞起来... 字符串映射到数字可能会很慢，但哈希函数设计得当就能绝杀" —— zqy1018

---

**通过哈希表实现的高效单词匹配，配合流式文本处理，是本类字符串统计问题的经典范式**

---
处理用时：66.72秒
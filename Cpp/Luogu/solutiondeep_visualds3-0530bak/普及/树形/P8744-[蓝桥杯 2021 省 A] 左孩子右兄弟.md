# 题目信息

# [蓝桥杯 2021 省 A] 左孩子右兄弟

## 题目描述

对于一棵多叉树，我们可以通过“左孩子右兄弟”表示法，将其转化成一棵二叉树。

如果我们认为每个结点的子结点是无序的，那么得到的二叉树可能不唯一。换句话说，每个结点可以选任意子结点作为左孩子，并按任意顺序连接右兄弟。

给定一棵包含 $N$ 个结点的多叉树，结点从 $1$ 至 $N$ 编号，其中 $1$ 号结点是根，每个结点的父结点的编号比自己的编号小。请你计算其通过"左孩子右兄弟"表示法转化成的二叉树，高度最高是多少。（只有根结点这一个结点的树高度为 $0$）

例如如下的多叉树：

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_d8f144a59f4c0ce9322ag-11.jpg)

可能有以下 $3$ 种 (这里只列出 $3$ 种, 并不是全部) 不同的 “左孩子右兄弟” 表示: 

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_d8f144a59f4c0ce9322ag-12.jpg)

其中最后一种高度最高, 为 $4$。

## 说明/提示

对于 $30 \%$ 的评测用例，$1 \leq N \leq 20$;

对于所有评测用例，$1 \leq N \leq 10^5$ 。 

蓝桥杯 2021 第一轮省赛 A 组 H 题。

## 样例 #1

### 输入

```
5
1
1
1
2```

### 输出

```
4```

# AI分析结果



**算法分类**  
树形动态规划（树形DP）

---

### **题解思路与核心难点**

1. **核心思路**  
   - **贪心策略**：每个节点的最大高度由其子节点数量与最大子树高度之和决定。通过将子节点排成链式结构，并将最深子树放在最下层，最大化整体高度。
   - **状态定义**：`dp[u]` 表示以 `u` 为根的子树转化为二叉树后的最大高度。
   - **状态转移**：`dp[u] = 子节点数量 + max(dp[v])`，其中 `v` 是 `u` 的子节点。

2. **解决难点**  
   - **正确推导状态转移**：需理解子节点排列顺序对高度的影响，最优解需将最大深度的子节点放在链末端。
   - **高效实现**：使用递归后序遍历（DFS），时间复杂度 `O(n)`，适用于 `n ≤ 1e5` 的规模。

---

### **题解评分（≥4星）**

1. **DengDuck（5星）**  
   - **亮点**：代码简洁，逻辑清晰，直接使用 `vector` 存储子节点，`dfs` 后序更新 `dp` 值，注释明确。

2. **lottle1212（4星）**  
   - **亮点**：链式前向星高效存储树结构，代码紧凑，但需熟悉该数据结构。

3. **MspAInt（4星）**  
   - **亮点**：图文结合解释状态转移方程，链式前向星实现，附带记录链接。

---

### **最优思路与技巧提炼**

1. **关键贪心策略**  
   - 每个节点的贡献为 `子节点数 + 最大子树高度`，需递归计算子节点的 `dp` 值后合并结果。

2. **代码实现核心**  
   ```cpp
   void dfs(int u) {
       for (auto v : children[u]) {
           dfs(v);
           max_subtree = max(max_subtree, dp[v]);
       }
       dp[u] = children[u].size() + max_subtree;
   }
   ```

---

### **类似题目推荐**

1. **P1352 没有上司的舞会**（树形DP基础）  
2. **P1122 最大子树和**（树形DP应用）  
3. **P2015 二叉苹果树**（树形DP与边权处理）

---

### **可视化与算法演示**

**核心算法流程**  
1. **树结构展示**：以根节点为中心，递归展开子节点链。
2. **动态更新**：高亮当前处理的节点，显示其子节点数量和最大子树高度。
3. **颜色标记**：已处理节点（绿色），当前节点（橙色），最大子树（红色边框）。

**复古游戏化设计**  
- **像素风格**：节点用8位色块表示，链式结构用网格线连接。
- **音效触发**：递归进入节点（短“滴”声），更新 `dp` 值（上扬音效）。
- **自动演示**：模拟DFS过程，按后序顺序遍历节点，自动播放时可调节速度。

```javascript
// 示例：Canvas绘制节点（伪代码）
function drawNode(node, depth) {
    ctx.fillStyle = node.isCurrent ? "#FFA500" : "#00FF00";
    ctx.fillRect(x, y, 30, 30); // 绘制节点方块
    ctx.fillText(`dp=${node.dp}`, x + 5, y + 15); // 显示dp值
}
```

---

### **代码实现（DengDuck题解）**

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x,f[100005];
vector<long long>v[100005]; 
void dfs(long long x) {
    for(auto i:v[x]) {
        dfs(i);
        f[x]=max(f[x],f[i]);
    }
    f[x]+=v[x].size();
} 
int main() {
    scanf("%lld",&n);
    for(int i=2;i<=n;i++) {
        scanf("%lld",&x);
        v[x].push_back(i);
    }
    dfs(1); 
    cout<<f[1]<<endl; 
}
```

**核心思想**：递归后序遍历，统计子节点数量并取最大子树高度，逐层合并结果。

---
处理用时：78.37秒
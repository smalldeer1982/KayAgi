# 题目信息

# [NOIP 2009 提高组] Hankson 的趣味题

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。

今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：

1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；

2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。

Hankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。


## 说明/提示

**【样例解释】**

第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。

第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。

**【数据范围】**

- 对于 $50\%$ 的数据，保证有 $1\leq a_0,a_1,b_0,b_1 \leq 10000$ 且 $n \leq 100$。
- 对于 $100\%$ 的数据，保证有 $1 \leq a_0,a_1,b_0,b_1 \leq 2 \times 10^9$ 且 $n≤2000$。

NOIP 2009 提高组 第二题


## 样例 #1

### 输入

```
2 
41 1 96 288 
95 1 37 1776 ```

### 输出

```
6 
2```

# AI分析结果



### **唯一算法分类**  
数学（数论）与枚举优化

---

### **题解思路与算法要点**  
#### **核心思路**
- **数学推导**：  
  1. 由条件1（gcd(x, a₀)=a₁）推导出x必须是a₁的倍数且满足x与a₀/a₁互质。  
  2. 由条件2（lcm(x, b₀)=b₁）推导出x必须是b₁的因数且满足b₁/x与b₀互质。  
- **枚举优化**：  
  直接枚举b₁的因数，通过数学性质将时间复杂度从O(b₁)优化到O(√b₁)。

#### **解决难点**  
- **因子成对性**：通过枚举1~√b₁的因子，同时处理i和b₁/i，避免重复计算。  
- **条件验证的数学简化**：  
  - `x % a₁ == 0`（保证x是a₁的倍数）  
  - `gcd(x/a₁, a₀/a₁) == 1`（保证x与a₀/a₁互质）  
  - `gcd(b₁/x, b₀) == 1`（保证b₁/x与b₀互质）  

#### **关键实现步骤**  
```cpp
for(int x=1; x*x<=b1; x++) {
    if(b1%x != 0) continue; // 非因数跳过
    // 检查x是否满足条件
    if(x%a1==0 && gcd(x/a1, a0/a1)==1 && gcd(b1/x, b0)==1) ans++;
    // 检查b1/x是否满足条件（避免重复）
    int y = b1/x;
    if(y != x && y%a1==0 && gcd(y/a1, a0/a1)==1 && gcd(b1/y, b0)==1) ans++;
}
```

---

### **题解评分与亮点**  
**≥4星题解列表**  
1. **zzlzk（⭐⭐⭐⭐）**  
   - **亮点**：代码简洁，直接枚举因数并通过gcd验证，适合快速实现。  
   - **代码片段**：  
     ```cpp
     for(int x=1;x*x<=b1;x++) {
         if(b1%x==0){
             if(x%a1==0 && gcd(x/a1,p)==1 && gcd(q,b1/x)==1) ans++;
             int y=b1/x;
             if(y%a1==0 && gcd(y/a1,p)==1 && gcd(q,b1/y)==1) ans++;
         }
     }
     ```

2. **KesdiaelKen（⭐⭐⭐⭐⭐）**  
   - **亮点**：通过质因数分解优化条件验证，时间复杂度O(√s + log s)，数学推导深入。  
   - **代码片段**：  
     ```cpp
     l = cf(s, n); // 去除s与n的公共质因数
     q = cf(l, m); // 去除l与m的公共质因数
     for(int i=1; i*i<=q; i++) cnt += (q%i==0 ? 2 : 1);
     ```

3. **HCl_Violet（⭐⭐⭐⭐）**  
   - **亮点**：基于质因数分解的位运算优化，预处理质数表加速分解。  
   - **代码片段**：  
     ```cpp
     while(a0%p[i]==0) a0n++; // 分解a0的质因数
     if((a0n>a1n && b0n!=b1n) || ...) ans *= 0; // 分类讨论
     ```

---

### **最优思路与技巧提炼**  
1. **因数成对枚举**：通过枚举1~√b₁的因数，同时处理i和b₁/i，将时间复杂度降为O(√b₁)。  
2. **数学性质简化条件**：  
   - 将gcd和lcm的条件转化为互质性和因子约束。  
   - 预处理质因数分解加速验证（如KesdiaelKen的解法）。  
3. **边界特判**：  
   - 处理i² = b₁时重复计数问题。  
   - 检查a₁能否整除x，避免无效计算。  

---

### **同类题目推荐**  
1. **P1029 最大公约数和最小公倍数问题**  
   - 求满足gcd(x,y)=a且lcm(x,y)=b的(x,y)对数。  
2. **P1069 细胞分裂**  
   - 分解质因数，求最小时间使细胞数满足条件。  
3. **P1414 又是毕业季II**  
   - 统计多个数的最大公约数，涉及因数枚举优化。

---

### **个人心得摘录**  
- **调试教训**：  
  - 需特判i² = b₁的情况，否则会重复计数（如sunny12888的题解）。  
  - 在质因数分解时，需处理剩余的大质数（如质数表未覆盖的情况）。  
- **优化顿悟**：  
  - 通过“x必须是b₁的因数”将枚举范围从指数级降为多项式级。

---

### **可视化与算法演示**  
#### **动画设计**  
1. **像素风格展示**：  
   - **Canvas网格**：将b₁的因数按网格排列，用不同颜色标记已检查/未检查的因数。  
   - **高亮当前因数**：用闪烁的黄色方块表示正在验证的因数i和b₁/i。  
   - **成功标记**：满足条件的因数变为绿色，并播放“叮”音效。  

2. **控制面板**：  
   - **速度滑块**：调节枚举速度（50ms~1000ms）。  
   - **单步执行**：手动点击触发下一个因数检查。  
   - **自动模式**：自动播放，展示算法流程。  

3. **音效设计**：  
   - **检查因数**：短促的“哔”声（Web Audio API生成8bit音效）。  
   - **条件满足**：高音“叮”声。  
   - **计算完成**：播放经典FC过关音乐片段。  

#### **代码片段（JS伪代码）**  
```javascript
// 绘制因数网格
function drawGrid(b1) {
    for(let x=1; x*x<=b1; x++) {
        if(b1%x != 0) continue;
        drawPixel(x, y, "gray"); // 绘制因数对(i, b1/i)
    }
}

// 高亮并验证当前因数
function highlightFactor(x) {
    let y = b1 / x;
    drawPixel(x, y, "yellow"); // 高亮当前因数
    playSound("beep"); 
    if (checkConditions(x)) {
        drawPixel(x, y, "green");
        playSound("success");
        ans++;
    }
}
```

---
处理用时：81.36秒
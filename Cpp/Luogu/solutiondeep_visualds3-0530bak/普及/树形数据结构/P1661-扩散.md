# 题目信息

# 扩散

## 题目描述

一个点每过一个单位时间就会向四个方向扩散一个距离，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/cd4e53lw.png)

两个点 $a$ 、 $b$ 连通，记作 $e(a,b)$，当且仅当 $a,b$ 的扩散区域有公共部分。连通块的定义是块内的任意两个点 $u,v$ 都必定存在路径 $e(u,a_0),e(a_0,a_1),\cdots,e(a_k,v)$。给定平面上的 $n$ 个点，问最早什么时刻它们形成一个连通块。


## 说明/提示

### 数据范围及约定

对于 $20\%$ 的数据，满足 $1 \le N \le 5;1 \le X_i,Y_i \le 50$。

对于 $100\%$ 的数据，满足 $1 \le N \le 50$，$1 \le X_i,Y_i \le 10^9$。

## 样例 #1

### 输入

```
2

0 0

5 5```

### 输出

```
5```

# AI分析结果



## 算法分类
**图论-最小生成树 / 并查集**

---

## 题解思路与核心难点分析

### 核心算法逻辑
所有题解围绕一个核心公式：两点连通时间 = ⌈曼哈顿距离 / 2⌉。关键差异在于如何利用该公式构造连通网络并求解全局时间。

#### 关键步骤对比
| 方法               | 核心步骤                                                                 | 时间复杂度      | 解决难点                         |
|--------------------|--------------------------------------------------------------------------|-----------------|----------------------------------|
| 二分+并查集        | 二分时间→验证是否所有点曼哈顿距离≤2t→并查集合并                         | O(N² logX)      | 二分边界处理，曼哈顿距离与时间关系 |
| Floyd算法          | 预处理曼哈顿距离→Floyd松弛操作取路径最大边的最小值                       | O(N³)           | Floyd变形理解，最大边推导         |
| Kruskal最小生成树  | 构造边权为⌈曼哈顿距离/2⌉的完全图→求最小生成树最长边                      | O(N² logN²)     | 边权计算与生成树性质应用          |
| 广搜+二分          | 二分时间→BFS验证连通性                                                  | O(N² logX)      | 连通性验证的搜索策略              |

---

## 4星以上题解推荐

### 1. 封禁用户（二分+并查集） ★★★★★
- **亮点**：直观的二分框架，清晰的并查集验证逻辑
- **关键代码**：
```cpp
if(dis <= mid*2)  // 两点曼哈顿距离≤2t时合并
ints[aa] = ab;
```
- **心得**：特别强调曼哈顿距离需乘以2的细节，避免计算错误

### 2. zzr8178541919（Floyd变形） ★★★★☆
- **亮点**：发现Floyd松弛公式`min(max(g[i][k], g[k][j]))`的巧妙性
- **关键推导**：通过中间点k连接时，路径时间为i→k和k→j的最大值

### 3. AntaresQAQ（最小生成树） ★★★★☆
- **亮点**：将问题转化为最小生成树最长边，直接应用Kruskal算法
- **核心代码**：
```cpp
e[cnt].val = (d+1)/2;  // 边权向上取整
ans = max(ans, e[i].val);
```

---

## 最优思路提炼
**关键技巧**：所有点连通的最早时间 = 完全图中最小生成树的最长边  
**推导证明**：  
1. 时间必须≥任意两点连通时间中的最大值  
2. 最小生成树保证所有点以最小的最大边连通  
3. 因此生成树的最长边即为全局最优解  

---

## 同类型题推荐
1. [P1111 修复公路](https://www.luogu.com.cn/problem/P1111)（最小生成树应用）  
2. [P1546 最短网络 Agri-Net](https://www.luogu.com.cn/problem/P1546)（最小生成树模板）  
3. [P2330 繁忙的都市](https://www.luogu.com.cn/problem/P2330)（最小瓶颈生成树）

---

## 可视化算法演示方案

### 动画设计（像素风格）
![扩散动画示意图](https://cdn.luogu.com.cn/upload/image_hosting/cd4e53lw.png)

1. **核心元素**：
   - 8位像素点阵（16x16像素点表示坐标）
   - 扩散波纹（同心方波，每帧扩散1单位）
   - 连通区域高亮（使用亮绿色填充）

2. **交互功能**：
   - **步进控制**：手动调节时间轴观察扩散过程
   - **模式切换**：并列显示二分法/MST/Floyd三种算法
   - **音效提示**：
     - 点连通时播放"嘟"声（Web Audio模拟FC音效）
     - 算法完成时播放经典《超级马里奥》过关音效

3. **算法高亮逻辑**：
```javascript
// 伪代码示例：Kruskal算法可视化
function drawKruskal() {
    edges.sort((a,b) => a.weight - b.weight);
    edges.forEach(edge => {
        drawEdge(edge, 0xFF0000);  // 红色高亮当前边
        if (!isConnected(edge.u, edge.v)) {
            playSound('connect.wav');  // 连接音效
            mergeSets(edge.u, edge.v);
            drawEdge(edge, 0x00FF00); // 绿色标记已连接边
        }
    });
}
```

---

## 个人心得摘录
> "初次尝试时纠结于模拟扩散过程，后来发现只要通过图论模型就能避免复杂计算。最小生成树的转化让我深刻理解了抽象建模的重要性。" —— 题解作者s_ShotღMaki

---

## 推荐实现代码（Kruskal版本）
```cpp
#include<bits/stdc++.h>
using namespace std;

struct Edge { int u, v, w; };
vector<Edge> edges;
int fa[55], n, x[55], y[55];

int find(int u) { return fa[u]==u ? u : fa[u]=find(fa[u]); }

int main() {
    cin >> n;
    for(int i=1; i<=n; i++) {
        cin >> x[i] >> y[i];
        fa[i] = i;
        for(int j=1; j<i; j++) {
            int d = abs(x[i]-x[j]) + abs(y[i]-y[j]);
            edges.push_back({j, i, (d+1)/2}); // 关键边权计算
        }
    }
    
    sort(edges.begin(), edges.end(), [](Edge a, Edge b){ 
        return a.w < b.w; 
    });
    
    int ans = 0;
    for(Edge e : edges) {
        int fu = find(e.u), fv = find(e.v);
        if(fu != fv) {
            fa[fu] = fv;
            ans = max(ans, e.w); // 记录最长边
        }
    }
    cout << ans;
}
```

---
处理用时：77.43秒
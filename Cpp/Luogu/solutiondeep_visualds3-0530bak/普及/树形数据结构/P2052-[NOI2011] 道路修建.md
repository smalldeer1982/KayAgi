# 题目信息

# [NOI2011] 道路修建

## 题目描述

在 W 星球上有 $n$ 个国家。为了各自国家的经济发展，他们决定在各个国家之间建设双向道路使得国家之间连通。但是每个国家的国王都很吝啬，他们只愿意修建恰好 $n - 1$ 条双向道路。

每条道路的修建都要付出一定的费用，这个费用等于道路长度乘以道路两端 的国家个数之差的绝对值。例如，在下图中，虚线所示道路两端分别有 $2$ 个、$4$ 个国家，如果该道路长度为 $1$，则费用为 $1×|2 - 4|=2$。图中圆圈里的数字表示国家的编号。
 
![](https://cdn.luogu.com.cn/upload/pic/2604.png) 

由于国家的数量十分庞大，道路的建造方案有很多种，同时每种方案的修建费用难以用人工计算，国王们决定找人设计一个软件，对于给定的建造方案，计算出所需要的费用。请你帮助国王们设计一个这样的软件。

## 说明/提示

对于 $100\%$ 的数据，$1\leq a_i, b_i\leq n$，$0\leq c_i\leq10^6$，$2\leq n\leq 10^6$。
|测试点编号|$n=$|
|:-:|:-:|
|$1$|$2$|
|$2$|$10$|
|$3$|$100$|
|$4$|$200$|
|$5$|$500$|
|$6$|$600$|
|$7$|$800$|
|$8$|$1000$|
|$9$|$10^4$|
|$10$|$2\times 10^4$|
|$11$|$5\times 10^4$|
|$12$|$6\times 10^4$|
|$13$|$8\times 10^4$|
|$14$|$10^5$|
|$15$|$6\times 10^5$|
|$16$|$7\times 10^5$|
|$17$|$8\times 10^5$|
|$18$|$9\times 10^5$|
|$19,20$|$10^6$|

## 样例 #1

### 输入

```
6
1 2 1
1 3 1
1 4 2
6 3 1
5 2 1```

### 输出

```
20```

# AI分析结果



# [NOI2011] 道路修建 题解分析

## 算法分类
**树形遍历与子树统计**

---

## 题解思路与难点分析
### 核心算法流程
1. **树形遍历**：通过 DFS 或 BFS 遍历整棵树，计算每个节点的子树大小 `size[v]`  
2. **贡献计算**：对于每条边 `u→v`，其费用为 `边权 * |n - 2*size[v]|`  
   - `size[v]` 是以 `v` 为根的子树节点数  
   - `n - size[v]` 是另一侧的节点数  
   - 差值的绝对值化简为 `|n - 2*size[v]|`  

### 解决难点
- **高效遍历**：邻接表存储树结构，时间复杂度 O(n)  
- **子树统计**：通过后序遍历自底向上累加子树大小  
- **避免重复计算**：DFS 过程中直接计算贡献，无需二次遍历  

---

## 题解评分（≥4星）
### 1. Melon_Musk（★★★★★）
- **亮点**：简洁清晰的邻接表实现，递归 DFS 直接计算贡献  
- **代码**：关键逻辑在 DFS 中同时累加子树大小和费用  
```cpp
void dfs(int x, int fa) {
    size[x] = 1;
    for (int i = head[x]; i; i = e[i].nt) {
        int to = e[i].to;
        if (fa != to) {
            dfs(to, x);
            size[x] += size[to];
            ans += e[i].w * abs(2 * size[to] - n);
        }
    }
}
```

### 2. 一只书虫仔（★★★★☆）
- **亮点**：详细调试经验分享，最终使用非递归邻接表优化  
- **踩坑总结**：`scanf` 格式错误导致 TLE 的教训  

### 3. kradcigam（★★★★☆）
- **亮点**：使用 C++11 特性 `vector<pair>` 存储邻接表  
- **优化**：代码可读性强，适合快速理解算法逻辑  

---

## 最优思路提炼
1. **子树统计法**：通过一次 DFS 同时完成子树大小统计与费用计算  
2. **公式简化**：费用公式化简为 `|n - 2*size[v]|` 提升效率  
3. **邻接表优化**：链式前向星或 vector 存储树结构，适应大规模数据  

---

## 同类型题目与算法套路
### 相似算法题
1. **树的重心**（统计子树大小，找最大子树最小节点）  
2. **树的直径**（两次 BFS/DFS 遍历）  
3. **子树权值和**（统计子树属性并累加）  

### 推荐题目
1. P1395 会议（树的重心）  
2. P1351 联合权值（树形遍历统计）  
3. P2014 选课（树形 DP）  

---

## 个人心得摘录
> "NOI 的送分题，卡了我三天，最后发现是 `scanf` 没加 `&`..." —— 一只书虫仔  
> **启示**：基础语法细节不容忽视，调试时优先检查输入输出格式  

---

## 可视化算法设计
### 动画方案
1. **树形结构展示**：Canvas 绘制树形图，节点按层级排列  
2. **遍历高亮**：当前 DFS 节点标记为红色，已处理子树标记为绿色  
3. **公式动态显示**：实时显示 `size[v]` 和 `|n-2*size[v]|` 的计算过程  

### 复古像素风格
- **颜色方案**：8-bit 调色板，节点用蓝/黄像素块表示  
- **音效设计**：  
  - 节点展开：短促 "beep" 音效  
  - 费用计算：硬币收集音效  
- **自动演示**：AI 按 DFS 顺序遍历，速度可调  

### 关键代码片段（JS 伪代码）
```javascript
function drawTree(node, parentPos) {
    // 绘制树节点与边
    ctx.fillStyle = node.visited ? '#00FF00' : '#FF0000';
    ctx.fillRect(node.x, node.y, 16, 16);
    if (parentPos) {
        ctx.beginPath();
        ctx.moveTo(parentPos.x + 8, parentPos.y + 8);
        ctx.lineTo(node.x + 8, node.y + 8);
        ctx.stroke();
    }
    // 显示计算公式
    ctx.fillText(`cost = ${node.cost}`, node.x, node.y - 10);
}
```

---

## 核心代码实现
### 完整代码（C++）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5;

struct Edge { int to, w, next; } e[N<<1];
int head[N], cnt, n;
ll ans, size[N];

void add(int u, int v, int w) {
    e[++cnt] = {v, w, head[u]};
    head[u] = cnt;
}

void dfs(int u, int fa) {
    size[u] = 1;
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if (v == fa) continue;
        dfs(v, u);
        size[u] += size[v];
        ans += abs(n - 2 * size[v]) * e[i].w;
    }
}

int main() {
    scanf("%d", &n);
    for (int i = 1, u, v, w; i < n; ++i) {
        scanf("%d%d%d", &u, &v, &w);
        add(u, v, w), add(v, u, w);
    }
    dfs(1, -1);
    printf("%lld\n", ans);
    return 0;
}
```

### 关键逻辑
- **邻接表构建**：双向边存储  
- **DFS 递归**：自底向上统计子树大小  
- **贡献计算**：直接内联在遍历过程中  

---

通过上述分析，解题核心在于高效遍历与数学公式的巧妙简化，结合树形结构特性快速求解。

---
处理用时：101.74秒
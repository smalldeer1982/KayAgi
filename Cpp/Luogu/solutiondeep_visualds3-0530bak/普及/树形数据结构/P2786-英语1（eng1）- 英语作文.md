# 题目信息

# 英语1（eng1）- 英语作文

## 题目背景

蒟蒻 HansBug 在英语考场上，挠了无数次的头，可脑子里还是一片空白。

## 题目描述

眼下出现在 HansBug 蒟蒻面前的是一篇英语作文，然而智商捉急的 HansBug 已经草草写完了，此时他发现离考试结束还有 $40$ 分钟，于是他打算估计一下这篇共有 $M$ 个单词的英语作文的含金量如何。众所周知的是，在中高考英语作文中使用高级词汇可以有效提高文章的含金量，从而获得更好的分数。已知蒟蒻HansBug知道 $N$ 个高级词汇，该词汇为 $A_i$（词汇长度为 $L_i$ ，包含数字、大小写字母），该高级词汇的含金量为 $B_i$，则该高级词汇每出现一次便可增加 $B_i$ 的含金量。可是他脑细胞和 RP 已经消耗殆尽，所以这个伟大的任务就交给你啦！

## 说明/提示

样例 $1$ 中，共计出现了 $2$ 次`hansbug`、 $2$ 次`absi2011` 、 $1$ 次 `yyy` 、 $1$ 次`kkksc03`、 $1$ 次  `lzn` ，所以总含金量为 $1\times2+2\times4+3\times1+4\times1+100\times1=115$，对 $99$ 取模就是 $16$ 。

样例 $2$ 中，和样例 $1$ 基本一样，值得注意的是整体的 `yyyy` 不可以被认为是 `yyy` 出现 $2$ 次，请注意这是一篇英语作文，一切以单词为最小单位。

此题目中大小写敏感。

数据范围（设所有单词的最大长度为 $Lmax$ ）：

![](https://cdn.luogu.com.cn/upload/pic/2228.png)


## 样例 #1

### 输入

```
5 99
hansbug 1
kkksc03 2
yyy 3
absi2011 4
lzn 100
hansbug is a juruo!but absi2011 not.!?!
one day absi2011 laughed at yyy and hansbug.
then kkksc03 and lzn blamed him for that.
```

### 输出

```
16```

## 样例 #2

### 输入

```
5 99
yyyy 1
kkksc03 2
yyy 3
absi2011 4
lzn 100
yyyy is a juruo!but absi2011 not.!?!
one day absi2011 laughed at yyy and yyyy.
then kkksc03 and lzn blamed him for that.
```

### 输出

```
16```

# AI分析结果



**唯一算法分类**：哈希、映射（字典）

---

### **题解思路、算法要点与解决难点**

1. **核心逻辑**：统计每个高级词汇出现的次数，并累加其对应的含金量。关键点在于高效查找单词是否存在于高级词汇集合中。
2. **数据结构选择**：
   - **map/unordered_map**：直接利用键值对存储，查找复杂度为 O(log n)（map）或平均 O(1)（unordered_map）。
   - **哈希+排序+二分**：通过哈希函数将字符串映射为数值，排序后二分查找，查找复杂度 O(log n)。
   - **Trie树/平衡树**：适用于前缀匹配或动态插入，但空间开销大（Trie）或实现复杂（平衡树）。
3. **输入处理难点**：需正确分割单词，处理多种分隔符（如空格、标点），不能部分匹配（如“yyyy”不能被拆分为两个“yyy”）。

---

### **题解评分 (≥4星)**

1. **Diamiko（5星）**  
   - 使用 `std::map` 实现，代码简洁易懂，适合快速解题。  
   - 输入处理巧妙，通过逐个字符读取并判断分隔符分割单词。  
   - 适合小数据量，时间复杂度 O(M*L + N log N)，L 为单词最大长度。

2. **BackSlashDelta（4星）**  
   - 哈希函数设计（两次异或）减少冲突，排序后二分查找优化时间。  
   - 时间复杂度 O(M*L + N log N)，适合大数据量。  
   - 代码复杂但优化明显，需处理哈希冲突和排序逻辑。

3. **little_gift（4星）**  
   - 使用 `__gnu_pbds::tree`（类似红黑树）优化查找效率。  
   - 结合 `fread` 快速读入，减少 I/O 时间。  
   - 代码高效，适合对性能要求高的场景。

---

### **最优思路或技巧提炼**

1. **哈希函数设计**：通过多种子和异或运算降低冲突概率（如 `seed_1` 和 `seed_2`）。
2. **输入分割优化**：逐个字符读取，利用 `isdigit` 和 `isalpha` 判断单词边界，避免正则表达式或复杂字符串处理。
3. **数据结构选择**：根据数据规模选择合适结构——小数据用 `map`，大数据用哈希+二分或 `unordered_map`。

---

### **同类型题或类似算法套路**

- **字符串匹配与统计**：如统计敏感词、词频统计。
- **优化查找问题**：需快速判断元素是否存在，如两数之和、子串匹配。
- **通用解法**：哈希预处理 + 二分/排序，或直接使用 STL 容器。

---

### **推荐洛谷题目**

1. **P3370 字符串哈希**：练习哈希函数设计与冲突处理。
2. **P2580 于是他错误的点名开始了**：Trie 树的典型应用。
3. **P1102 A-B数对**：哈希或 map 快速查找差值。

---

### **个人心得摘录**

- **Diamiko**：强调 `map` 的简洁性，“脑细胞已耗尽，直接暴力数据结构”。
- **户山香澄**：尝试 Trie 树后因 MLE 改用左儿子右兄弟结构，“空间换时间的教训”。
- **happybob**：对比暴力与优化代码，强调输入细节，“一个换行符引发的血案”。

---

### **可视化与算法演示**

1. **动画方案**：  
   - **哈希计算**：展示字符串逐字符转换为哈希值的过程，高亮当前字符和异或运算。  
   - **二分查找**：动态显示排序后的哈希数组，标记当前 mid 位置和搜索范围。  
   - **单词分割**：用不同颜色区分单词和分隔符，逐步生成单词并触发查找。

2. **复古像素风格**：  
   - **8位像素网格**：每个单词显示为像素块，哈希值用不同颜色表示。  
   - **音效设计**：查找成功时播放“金币音效”，失败时静音，背景音乐为 8-bit 循环曲。

3. **交互设计**：  
   - **速度调节**：滑块控制动画速度，支持暂停/继续。  
   - **冲突提示**：红色闪烁显示哈希冲突，绿色表示匹配成功。

---

### **核心代码片段（Diamiko版）**

```cpp
string t = "";
char c;
while (scanf("%c", &c) != EOF) {
    if (!isdigit(c) && !isalpha(c)) {
        ans = (ans + a[t]) % p; // 直接查找map
        t = "";
    } else t += c;
}
```

---

### **可视化设计要点**

- **Canvas 绘制**：单词分割为网格块，哈希值映射到颜色梯度。  
- **自动演示模式**：AI 逐步读取字符并分割单词，同步更新哈希计算和查找过程。  
- **积分系统**：每正确匹配一个单词得 10 分，连击加成，失败扣分。

---
处理用时：82.16秒
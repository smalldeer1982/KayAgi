# 题目信息

# 填涂颜色

## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 30$。


## 样例 #1

### 输入

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

### 输出

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

# AI分析结果



### **算法分类**  
广度优先搜索（BFS）/ 深度优先搜索（DFS）

---

### **综合分析与结论**  
**核心思路**：将闭合圈内外的区分问题转化为「圈外区域可达性」问题。通过扩展矩阵边界或遍历四周边界点，用 BFS/DFS 标记所有可达边界的 0（圈外），剩余未被标记的 0 即为闭合圈内需要填色的区域。

**关键难点**：  
1. 如何确保覆盖所有可能的圈外区域（如闭合圈紧贴原矩阵边界）。  
2. 如何避免直接判断复杂闭合形状的困难。

**解决方案**：  
1. **扩展矩阵边界**：在原矩阵外添加一圈虚拟的 0，统一处理边界条件。  
2. **逆向染色法**：将所有 0 初始化为待填充状态，标记可达边界的 0 为非填充状态，剩余未标记的 0 即为目标。  

**算法流程**：  
1. 初始化扩展后的矩阵（原矩阵外包围一圈 0）。  
2. 从扩展边界点开始 BFS/DFS，标记所有可达的 0。  
3. 遍历原矩阵，输出时未被标记的 0 改为 2，其他值保持原样。  

**可视化设计**：  
- **复古像素动画**：用 8 位网格展示矩阵，扩展边界用灰色表示，圈外区域标记为蓝色，圈内区域标记为红色，闭合圈边界用黄色高亮。  
- **步进控制**：允许调整 BFS 扩散速度，每步显示队列变化和当前访问节点的高亮效果。  
- **音效**：标记圈外时播放水滴声，填充圈内时播放合成音效，闭合圈形成时触发胜利音效。

---

### **题解清单（≥4星）**  
1. **LMB_001（5星）**  
   - **亮点**：通过扩展矩阵边界统一处理，DFS 代码简洁高效。  
   - **核心代码**：  
     ```cpp
     void dfs(int p, int q) {
         if (p<0 || p>n+1 || q<0 || q>n+1 || a[p][q]!=0) return;
         a[p][q] = 1; // 标记圈外
         for (int i=1; i<=4; i++) dfs(p+dx[i], q+dy[i]);
     }
     ```

2. **冰冻赤道（4.5星）**  
   - **亮点**：BFS 实现边界遍历，明确处理四周边界点。  
   - **核心代码**：  
     ```cpp
     q.push(make_pair(0,0));
     while (!q.empty()) {
         int x = q.front().first, y = q.front().second;
         q.pop();
         for (int i=0; i<4; i++) {
             int nx = x + dx[i], ny = y + dy[i];
             if (nx >=0 && nx <=n+1 && ny >=0 && ny <=n+1 && a[nx][ny]==2) {
                 a[nx][ny] = 0; // 标记圈外
                 q.push(make_pair(nx, ny));
             }
         }
     }
     ```

3. **LevenKoko（4星）**  
   - **亮点**：逆向思维，先将所有 0 设为 2，再反向染色圈外。  
   - **核心代码**：  
     ```cpp
     dfs(0,0); // 从扩展边界开始
     for (int i=1; i<=n; i++) {
         for (int j=1; j<=n; j++) {
             if (a[i][j] == 0) cout << "2 ";
             else cout << b[i][j] << " ";
         }
         cout << endl;
     }
     ```

---

### **最优技巧提炼**  
1. **扩展边界法**：通过添加虚拟边界，避免复杂边界条件判断。  
2. **逆向染色**：将问题从「找圈内」转化为「排除圈外」，简化逻辑。  
3. **队列/栈统一处理**：BFS 用队列保证层次扩散，DFS 用栈或递归实现深度优先。  

---

### **同类型题与算法套路**  
- **连通区域标记**：如「P1506 拯救oibh总部」「P1451 求细胞数量」。  
- **边界扩散问题**：如「P2895 Meteor Shower」（陨石扩散路径）。  
- **逆向思维题**：如「P1141 01迷宫」（统计连通块大小）。  

---

### **推荐题目**  
1. **P1506**：类似圈外标记，处理洪水填充问题。  
2. **P2895**：BFS 扩散与动态边界的结合。  
3. **P1141**：预处理连通区域，逆向统计结果。  

---

### **个人心得摘录**  
> *「扩展边界的一圈 0 就像给迷宫开了个后门，所有圈外区域都能被轻松遍历到，无需处理复杂的边缘条件。」*  
> *「BFS 的队列扩散过程像水波纹一样，清晰展示了圈外区域的增长。」*  

---

### **可视化与动画设计**  
1. **Canvas 实现**：  
   ```javascript
   // 绘制扩展矩阵（复古风格）
   function drawGrid() {
       ctx.fillStyle = "#808080"; // 扩展边界颜色
       for (let i=0; i<=n+1; i++) {
           drawCell(i, 0);        // 上边界
           drawCell(i, n+1);      // 下边界
           drawCell(0, i);        // 左边界
           drawCell(n+1, i);      // 右边界
       }
   }
   ```

2. **BFS 动画控制**：  
   ```javascript
   function animateBFS() {
       if (queue.length === 0) return;
       let [x, y] = queue.shift();
       ctx.fillStyle = "#00FFFF"; // 当前访问节点高亮
       drawCell(x, y);
       // 扩散到相邻节点并加入队列
       for (let [dx, dy] of dirs) {
           let nx = x + dx, ny = y + dy;
           if (nx >=0 && nx <=n+1 && ny >=0 && ny <=n+1 && !vis[nx][ny]) {
               vis[nx][ny] = true;
               queue.push([nx, ny]);
           }
       }
       requestAnimationFrame(animateBFS);
   }
   ```

3. **音效触发**：  
   ```javascript
   function playSound(type) {
       const audio = new Audio();
       if (type === 'mark') audio.src = 'data:audio/wav;base64,UklGRl9...'; // 标记音效
       else if (type === 'finish') audio.src = 'data:audio/wav;base64,UklGRk9...'; // 完成音效
       audio.play();
   }
   ```

---
处理用时：98.33秒
# 题目信息

# [USACO1.4] 铺放矩形块 Packing Rectangles

## 题目描述

给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)

$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  

这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。

可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，输入的所有数在 $[1,50]$ 内。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5
```

### 输出

```
40
4 10
5 8
```

# AI分析结果



### 唯一算法分类
**枚举 + 排列组合**

---

### 题解思路与算法要点
1. **核心思路**  
   所有题解均围绕枚举所有可能的矩形排列方式展开，覆盖题目中提到的 6 种基础布局。通过 DFS 或全排列生成所有可能的矩形顺序及旋转方向，计算每种情况下的最小包围矩形面积。

2. **解决难点**  
   - **排列生成**：通过 DFS 或 `next_permutation` 生成 4 个矩形的全排列（24 种顺序）。
   - **旋转处理**：每个矩形可旋转（长宽互换），共 2^4=16 种方向组合。
   - **布局计算**：对每个排列+方向组合，推导 6 种基础布局的长宽公式，覆盖所有可能的叠加方式。

3. **关键实现**  
   - **DFS 递归**：遍历所有排列，每次递归处理一个矩形的两种方向（旋转/不旋转）。
   - **check 函数**：集中处理 6 种布局的尺寸计算，用条件分支覆盖不同叠加情况。
   - **去重优化**：记录已计算的长宽组合，避免重复比较。

---

### 题解评分 (≥4星)
1. **七喜（4.5 星）**  
   - **亮点**：DFS 递归生成排列，代码简洁，注释清晰。  
   - **引用**：“用 dfs 的方式生成排列，每个矩形尝试两种方向，确保不遗漏。”

2. **Chiesl（4 星）**  
   - **亮点**：详细推导 6 种布局的数学公式，代码结构模块化。  
   - **引用**：“将每个布局的推导过程分解为数学表达式，便于调试。”

3. **luuia（4 星）**  
   - **亮点**：图文结合分析布局，逻辑可视化强，适合理解。  
   - **引用**：“画图分析后，公式推导变得直观。”

---

### 最优技巧提炼
1. **排列生成**  
   ```cpp
   void dfs(int depth) {
       if (depth == 4) { check(); return; }
       for (int i=1; i<=4; i++) {
           if (!vis[i]) {
               tmpx[depth+1] = x[i]; // 不旋转
               dfs(depth+1);
               tmpx[depth+1] = y[i]; // 旋转
               dfs(depth+1);
           }
       }
   }
   ```
   - **作用**：递归生成所有排列和旋转组合。

2. **布局计算（第六种布局）**  
   ```cpp
   if (h3 >= h2 + h4) x = ...; // 分情况处理复杂叠加
   ```
   - **作用**：通过条件分支覆盖所有可能的子布局。

---

### 同类型题与算法套路
- **通用套路**：排列组合 + 分情况枚举，适用于几何覆盖、装箱问题。
- **推荐题目**：  
  1. P1099（树网的核）：几何覆盖的最优解枚举。  
  2. P1378（油滴扩展）：枚举油滴顺序计算最大剩余面积。  
  3. P2089（烤鸡）：暴力枚举配料组合。

---

### 可视化与算法演示
1. **动画设计**  
   - **像素风格**：用 8-bit 色块表示矩形，不同颜色区分排列顺序。  
   - **高亮当前操作**：正在处理的矩形闪烁显示，旋转时播放“咔嚓”音效。  
   - **布局演示**：分步展示 6 种基础布局的叠加过程，右侧同步显示长宽公式。

2. **交互功能**  
   - **速度调节**：滑块控制动画速度（0.5x~5x）。  
   - **AI 演示**：自动选择最优排列路径，绿色高亮当前最小面积。

3. **音效设计**  
   - **成功音效**：找到更优解时播放 8-bit 上升音阶。  
   - **错误音效**：布局重叠时播放短促“哔”声。

---

### 代码片段（核心 DFS + Check）
```cpp
// DFS 生成排列与旋转
void dfs(int step) {
    if (step == 4) {
        check_layouts();
        return;
    }
    for (int i=0; i<4; i++) {
        if (!used[i]) {
            used[i] = true;
            rect[step] = original[i]; // 不旋转
            dfs(step+1);
            swap(rect[step].w, rect[step].h); // 旋转
            dfs(step+1);
            used[i] = false;
        }
    }
}

// 计算第六种布局
void calc_case6() {
    int h = max(y1+y3, y2+y4);
    if (y1+y3 <= y4) {
        w = max(x2, max(x1, x3) + x4);
    } else if (...) { /* 其他分支 */ }
    update_min(w, h);
}
```

---

### 个人心得摘录
> **七喜**：“调试时发现第六种布局的分支条件容易漏等于号，必须画图验证所有临界情况。”  
> **luuia**：“将矩形编号后，用纸笔画图推导公式，比直接编码效率高得多。”

---

### 复古游戏化演示（Web 示例）
```html
<canvas id="pixelCanvas"></canvas>
<script>
// 初始化 8-bit 调色板
const colors = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4"];
let currentStep = 0;

function drawLayout(rects) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    rects.forEach((r, i) => {
        ctx.fillStyle = colors[i];
        ctx.fillRect(r.x, r.y, r.w, r.h);
    });
}

// AI 自动演示最优路径
function autoPlay() {
    if (currentStep < bestPath.length) {
        drawLayout(bestPath[currentStep++]);
        setTimeout(autoPlay, 1000 / speed);
    }
}
</script>
```
- **效果**：Canvas 绘制动态排列过程，AI 模式自动步进，复古音效增强沉浸感。

---
处理用时：93.40秒
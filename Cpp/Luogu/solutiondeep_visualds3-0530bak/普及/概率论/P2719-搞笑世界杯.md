# 题目信息

# 搞笑世界杯

## 题目背景

很久很久以后，一次世界杯。


## 题目描述

随着世界杯小组赛的结束，法国，阿根廷等世界强队都纷纷被淘汰，让人心痛不已。 于是有人组织了一场搞笑世界杯，将这些被淘汰的强队重新组织起来和世界杯一同比赛。你和你的朋友欣然去购买球票。不过搞笑世界杯的球票出售方式也很特别，它们只准备了两种球票。

- A 类票——免费球票 
- B 类票——双倍价钱球票。

购买时由工作人员通过掷硬币决定，投到正面的买 A 类票， 反面的买 B 类票。主办方总是准备了同样多的 A 类票和 B 类票。你和你的朋友十分幸运的排到了某场精彩比赛的最后两个位置。

这时工作人员开始通过硬币售票。不过更为幸运的是当工作人员到你们面前时他发现已无需再掷硬币了，因为剩下的这两张票全是免费票。

你和你的朋友在欣喜之余，想计算一下排在队尾的两个人同时拿到一种票的概率是多少(包括同时拿 A 类票或 B 类票) 假设工作人员准备了 $2n$ 张球票，其中 $n$ 张 A 类票，$n$ 张 B 类票，并且排在队伍中的人每人必须且只能买一张球票(不管掷到的是该买 A 还是该买 B)。

## 说明/提示

## 数据规模与约定

对全部的测试点，保证 $1 \leq n \leq 1250$。

## 样例 #1

### 输入

```
256```

### 输出

```
0.9500```

# AI分析结果



---

### 算法分类
**动态规划**

---

### 题解思路与解决难点

#### 核心思路
题目要求计算当剩余两张票时均为同类型的概率。采用动态规划模型，状态定义为 `dp[i][j]`，表示剩余 `i` 张 A 类票和 `j` 张 B 类票时，最后两人拿到相同票的概率。状态转移方程为：
```cpp
dp[i][j] = 0.5 * dp[i-1][j] + 0.5 * dp[i][j-1]
```
当某一类票售罄时（如 `i=0` 或 `j=0`），后续只能购买另一类票，因此初始化 `dp[i][0] = dp[0][i] = 1`（`i >= 2`）。

#### 解决难点
1. **状态转移的正确性**：抛硬币决策的 50% 概率需结合剩余票数处理。当某类票售罄时，只能购买另一类票。
2. **初始条件的正确性**：需保证当只剩一种票时（如 `i >= 2` 且 `j=0`），最后两人必拿同类型，概率为 1。

---

### 题解评分（≥4星）

1. **zhongcy (5星)**
   - **思路清晰**：明确状态定义与转移方程。
   - **代码简洁**：正确初始化 `i >= 2` 的边界条件。
   - **时间复杂度**：`O(n²)`，满足题目数据范围。

2. **love_luke (4.5星)**
   - **初始化修正**：强调初始条件应为 `i >= 2` 时设置概率为 1。
   - **代码规范**：双重循环填充 DP 表，逻辑清晰。

3. **Binary_Search_Tree (4星)**
   - **特殊处理**：针对 `n=1` 或 `0` 进行特判，避免越界。
   - **创新思路**：尝试将结果拆分为最后两人均买 A 或 B 的情况。

---

### 最优思路与技巧提炼

#### 关键思路
- **状态定义**：`dp[i][j]` 表示剩余 `i` 张 A 和 `j` 张 B 时，最后两人拿到相同票的概率。
- **转移方程**：综合抛硬币的 50% 概率和剩余票数的影响。
- **边界处理**：剩余票数为单一时直接初始化概率为 1。

#### 核心代码实现
```cpp
#include <iostream>
using namespace std;
const int N = 1300;
double dp[N][N];

int main() {
    int n; cin >> n; n /= 2;
    for (int i = 2; i <= n; i++) 
        dp[i][0] = dp[0][i] = 1.0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            dp[i][j] = (dp[i-1][j] + dp[i][j-1]) * 0.5;
    printf("%.4lf\n", dp[n][n]);
    return 0;
}
```

---

### 类似题目推荐

1. **P1057 传球游戏**（动态规划，状态转移）
2. **P1291 SHOI2002 百事世界杯之旅**（期望计算，递推思想）
3. **P4317 花神的数论题**（动态规划与组合数学结合）

---

### 可视化与算法演示

#### 动态规划表格演示
- **动画设计**：以二维表格展示 `dp[i][j]` 的计算过程。当前单元格颜色高亮，箭头指向其左侧 (`dp[i-1][j]`) 和上方 (`dp[i][j-1]`) 的单元格。
- **初始条件**：`i >= 2` 或 `j >= 2` 的边界单元格标记为绿色（值为 1）。
- **步进控制**：支持手动点击或自动播放，观察表格填充顺序。

#### 复古像素风格
- **颜色方案**：8 位色系（深蓝背景，亮绿高亮当前操作单元格）。
- **音效**：每次计算单元格时播放短促“滴”声，填充完成时播放确认音效。
- **Canvas 绘制**：网格绘制表格，单元格数值动态更新。

---

### 个人心得摘录

- **flyfree**：通过重新定义状态 `f[i][j]` 为售票员手中剩余票数，理解了边界条件的正确性。
- **love_luke**：指出初始条件的常见误区，强调 `i >= 2` 的重要性，避免因小数据错误导致整体错误。

---

**可视化示例代码（JavaScript 节选）**
```javascript
// 初始化 Canvas 和表格
const ctx = canvas.getContext('2d');
drawGrid();

// 动态填充 dp[i][j]
function animateDP(i, j) {
    highlightCell(i, j);
    playSound('click');
    calculateDP(i, j); // 根据前驱状态计算当前值
    drawValue(i, j, dp[i][j].toFixed(4));
}
```

---
处理用时：322.45秒
# 题目信息

# [GXPC-S 2024] 扫雷

## 题目背景

小林最近迷上了扫雷游戏。

## 题目描述

一个扫雷游戏可以被抽象成一个 $n$ 行 $m$ 列的字符矩阵，不妨记第 $i$ 行第 $j$ 列的字符为 $S_{i,j}$。

若 $S_{i,j}=\texttt{*}$，表示格子 $(i,j)$ 上有一个地雷；

若 $S_{i,j}=\texttt{?}$，表示格子 $(i,j)$ 情况未知；

若 $S_{i,j}\in [0,8]$，表示格子 $(i,j)$ 周围的 $8$ 个格子中有 $S_{i,j}$ 个地雷（这个格子本身没有地雷）。
形式化地说，记

$$
f(i,j)=\begin{cases}
1, & (i,j)\text{ 上有地雷} \\
0, & \text{其他情况} \\
\end{cases}
$$

特别地，对于超出棋盘边界的情况，规定 $f(i,j)=0$。
则 $\displaystyle S_{i,j}=\sum_{p=-1}^1\sum_{q=-1}^1 f(i+p,j+q)$。

给定一个棋盘，你可以任意决定每个 $\texttt{?}$ 格子上是否有炸弹。你想要知道是否存在方案使得这个棋盘是合法的。
我们定义一个棋盘**合法**，当且仅当填有数字 $x$ 的格子周围的八个格子上恰好有 $x$ 个炸弹。

你需要解决 $T$ 组数据。

## 说明/提示

对于第一组数据：问号处选择不填是一种合法方案。可以证明这是唯一的合法方案。

**本题采用捆绑测试。**

- Subtask 1（20pts）：至多存在 $1$ 组 $(i,j)$，使得 $S_{i,j}=\texttt{?}$；
- Subtask 2（80pts）：无额外约束。

对于 $100\%$ 的数据，保证：

- $1\le T,n,m\le 10$；
- 至多存在 $10$ 组 $(i,j)$，使得 $S_{i,j}=\texttt{?}$；
- $\forall 1\le i\le n,1\le j\le m$，保证 $S_{i,j}\in\{0,1,2,3,4,5,6,7,8,\texttt{?},\texttt{*}\}$。


## 样例 #1

### 输入

```
3
2 2
**
2?
2 2
*1
3?
2 2
**
21```

### 输出

```
YES
NO
NO```

# AI分析结果



---

**唯一算法分类**：暴力枚举

---

## **综合分析与结论**

### **题解思路与核心难点**
- **核心思路**：枚举所有可能的问号状态（雷或非雷），逐一验证是否满足所有数字格子的条件。
- **关键步骤**：
  1. **状态枚举**：将每个 `?` 的可能状态用二进制位压缩表示，共 `2^k` 种组合。
  2. **棋盘更新**：根据当前枚举状态，修改 `?` 为 `*`（雷）或 `.`（非雷）。
  3. **合法性验证**：遍历所有数字格子，检查其周围雷数是否匹配。
- **难点解决**：通过二进制枚举高效处理组合爆炸问题，时间复杂度 `O(T * 2^k * n * m)` 在数据范围内可行。

### **可视化设计思路**
1. **棋盘绘制**：用 Canvas 绘制网格，格子按类型着色（数字黄、雷红、问号灰）。
2. **枚举动画**：逐帧展示每个枚举状态，问号格子闪烁，雷与非雷动态切换。
3. **验证高亮**：检查每个数字格子时，高亮其周围格子，显示当前雷数，正确则变绿，错误则变红。
4. **音效提示**：枚举切换时播放点击音效，验证成功时播放胜利音效，失败时播放警示音。

---

## **题解清单 (4星)**

### **题解作者：Sliarae（4星）**
- **关键亮点**：
  - **直接枚举**：利用 `k≤10` 的约束，暴力枚举所有可能状态。
  - **简洁验证**：遍历所有数字格子，通过八方向检查雷数。
  - **代码清晰**：逻辑分层明确，无冗余优化，适合快速实现。
- **改进建议**：可预处理数字格子的位置，减少重复遍历。

---

## **代码实现与核心逻辑**

### **核心代码片段**
```cpp
// 枚举所有可能的问号状态
for (int st = 0; st < (1 << vec.size()); ++st) {
    // 更新问号格子的雷状态
    for (int i = 0; i < vec.size(); ++i) {
        int x = vec[i].first, y = vec[i].second;
        s[x][y] = ((st >> i) & 1 ? '*' : '.');
    }
    // 验证所有数字格子
    bool valid = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (isdigit(s[i][j])) {
                int cnt = s[i][j] - '0';
                // 检查八个方向的雷数
                for (int k = 0; k < 8; ++k) {
                    int x = i + dx[k], y = j + dy[k];
                    if (x >= 1 && x <= n && y >= 1 && y <= m && s[x][y] == '*') cnt--;
                }
                valid &= (cnt == 0);
            }
        }
    }
    if (valid) { ans = 1; break; }
}
```

### **完整代码**
见原题解。

---

## **最优思路提炼**
- **状态压缩**：用二进制位表示 `?` 的两种状态，避免复杂数据结构。
- **剪枝优化**：一旦发现合法状态立即终止枚举（代码中的 `ans |= valid` 可优化为 `break`）。
- **快速验证**：预处理八方向偏移量，避免重复计算。

---

## **相似题目推荐**
1. **P1036 选数**（枚举组合，验证质数）
2. **P1219 八皇后**（回溯枚举，验证冲突）
3. **P1443 马的遍历**（BFS，方向遍历）

---

## **可视化与复古动画设计**
- **像素风格**：8-bit 格子，雷用红色方块，数字用黄色字体，问号闪烁。
- **动画流程**：
  1. **枚举阶段**：问号格子按当前 `st` 的二进制位切换颜色。
  2. **验证阶段**：逐个高亮数字格子，显示周围雷数。
  3. **结果反馈**：合法时棋盘变绿，非法时变红，播放对应音效。
- **交互设计**：支持暂停/步进，速度调节，AI 自动演示模式。

---

**总结**：本题通过暴力枚举与高效验证，巧妙利用数据范围小的特点，是典型的“小规模问题直接枚举”范例。可视化可通过动态棋盘和音效增强理解。

---
处理用时：116.98秒
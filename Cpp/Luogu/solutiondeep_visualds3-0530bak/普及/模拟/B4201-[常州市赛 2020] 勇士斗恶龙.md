# 题目信息

# [常州市赛 2020] 勇士斗恶龙

## 题目背景

搬运自 <http://czoj.com.cn/p/449>。数据为民间数据。

## 题目描述

小 $\text X$ 穿越到了异世界，国王命令他招揽勇士，杀死恶龙，救回公主。  
异世界是高度数据化的。恶龙有一个攻击力 $\text{ATK}$ ，一个生命值 $\text{HP}$ 。类似的，每个勇士也有一个攻击力 $A_i$ ，一个生命值 $H_i$ 。  
战斗是回合制的，并且每次只能由一个勇士和恶龙单挑。战斗中，每个回合恶龙的生命值会减去这个勇士的攻击力，这个勇士的生命值会减去恶龙的攻击力。如果回合结束的时候恶龙的生命值小于等于 $0$，那么恶龙就被杀死了；如果这个勇士的生命值小于等于 $0$，那么这个勇士就被击败了，需要换上另一个勇士继续战斗。当然，如果恶龙还没有被杀死，勇士却全部被击败了，那么这场战役就彻底失败了。  
不过聪明的小 $\text X$ 安排了一个特殊的战术：在一名勇士被击败后立刻让另一名勇士发起攻击，这样恶龙在勇士们的车轮战术下疲于招架，受到第二个勇士的伤害变为两倍，受到第三个勇士的伤害变为三倍……以此类推。  
现在一共有 $n$ 名勇士报名，小 $\text X$ 想问问你，如果合理安排勇士出战的顺序，最少要招揽多少名勇士才能杀死恶龙？

## 说明/提示

### 样例说明
- 两名勇士都招揽。先派出 $2$ 号勇士；  
- 第一回合，恶龙生命值变为 $8$，勇士生命值变为 $0$。勇士被击败；  
- 紧接着派出 $1$ 号勇士；  
- 第二回合，恶龙生命值变为 $4$ （两倍伤害），勇士生命值变为 $1$ ；  
- 第三回合，恶龙生命值变为 $0$ ，勇士生命值变为 $0$ 。恶龙被杀死；  
- 勇士虽然也被击败了，但恶龙已经死了，所以还是胜利了！  
### 数据范围
本题共有 $10$ 个测试点。  
对于所有数据，$1\le n\le 10^5,1\le\text{ATK}, A_i,H_i\le10^6,1\le \text{HP}\le 10^{18}$。  
|测试点编号|$n$|$\text{ATK}, A_i,H_i$|$\text{HP}$|
|:-:|:-:|:-:|:-:|
|$1\sim 4$|$\le 5$|$\le 10$|$\le 100$|
|$5\sim 7$|$\le 10^3$|$\le 10^3$|$\le 10^9$|
|$8\sim 10$|$\le 10^6$|$\le 10^6$|$\le 10^{18}$|

## 样例 #1

### 输入

```
2
1 9
2 2
1 1```

### 输出

```
2```

# AI分析结果



## 算法分类
**贪心算法**

---

## 题解思路、算法要点与解决难点
### 核心思路
- **贡献转化**：将勇士的存活回合数转化为总攻击次数，计算每个勇士的贡献值 `A_i * ceil(H_i/ATK)`。
- **贪心排序**：按贡献值降序排列，确保高贡献勇士优先获得更高的攻击倍数加成。
- **前缀和优化**：维护两个变量 `now`（当前累计贡献）和 `sum`（总伤害），通过线性遍历快速计算最小勇士数。

### 解决难点
- **攻击倍数叠加逻辑**：正确推导出总伤害公式 `A_1*p + A_2*(p-1) + ... + A_p*1`，并通过增量维护避免二次计算。
- **高效验证条件**：通过排序后的前缀和增量累加，将时间复杂度优化至 `O(n log n)`。

---

## 题解评分 (≥4星)
1. **Sliarae（5星）**  
   - 思路清晰，推导完整，直接通过贪心排序与线性累加实现最优解。
   - 代码简洁高效，维护 `now` 和 `sum` 变量避免重复计算。
2. **Yi_chen123（4星）**  
   - 详细推导前缀和公式，强调动态转移方程的正确性。
   - 代码逻辑清晰，但变量命名略冗余。
3. **Clare613（4星）**  
   - 反向累加排序后的贡献值，思路正确但代码注释存在误导（误用 `floor` 代替 `ceil`）。

---

## 最优思路或技巧提炼
1. **贡献值降序排序**：确保高攻击次数的勇士尽可能获得高倍数加成。
2. **增量累加优化**：通过 `sum += now` 快速计算总伤害，避免逐项乘法。
3. **向上取整技巧**：`ceil(a/b)` 转化为 `(a + b - 1) / b`。

---

## 同类型题或类似算法套路
- **贪心+前缀和**：常见于需要排序后按顺序叠加权值的问题。
- **贡献转化思维**：将复杂战斗规则转化为单一贡献值，如合并果子（P1090）、排队接水（P1223）。

---

## 推荐相似题目
1. **P1090 [NOIP2004 提高组] 合并果子**  
   （贪心选择最小代价合并，优先队列实现）
2. **P1223 [NOIP1996 提高组] 排队接水**  
   （排序使平均等待时间最小）
3. **P1016 [NOIP1999 提高组] 旅行家的预算**  
   （贪心选择加油站，类似贡献优化）

---

## 个人心得摘录
- **Sliarae**：强调 `sum += now` 的增量维护方式，避免复杂公式推导。
- **why17**：十年 OI 一场空，不开 `long long` 见祖宗！（数据范围需警惕溢出）

---

## 可视化与算法演示
### 核心算法流程
1. **勇士排序**：按贡献值降序排列，像素动画显示勇士图标大小与贡献值正相关。
2. **累加过程**：逐步加入勇士，显示当前总伤害与恶龙剩余 HP，颜色标记新加入的勇士。
3. **胜利判定**：当总伤害条超过恶龙 HP 时，播放胜利音效与像素爆炸动画。

### 复古游戏化设计
- **像素风格**：勇士与恶龙用 16x16 像素块表示，攻击倍数显示为动态增长的数字。
- **音效设计**：
  - 加入勇士时播放 `8-bit` 点击音效。
  - 总伤害更新时播放短促上升音调。
  - 胜利/失败时播放经典 FC 结局音乐。
- **自动演示模式**：按排序顺序自动添加勇士，支持暂停/加速。

```javascript
// 伪代码：核心动画逻辑（Canvas 实现）
class DragonSlayerAnimation {
  constructor() {
    this.heroes = sortedContributions; // 降序排列的贡献值
    this.currentSum = 0;
    this.totalDamage = 0;
    this.step = 0;
  }

  nextStep() {
    if (this.step >= this.heroes.length) return;
    this.currentSum += this.heroes[this.step];
    this.totalDamage += this.currentSum;
    this.drawDamageBar();
    this.highlightHero(this.step);
    playSound('attack');
    this.step++;
  }
}
```

---

## 核心代码实现（Sliarae 题解）
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
using LL = long long;

const int kN = 1e5 + 5; 
LL a[kN];

int main() {
    int n, atk; LL hp;
    cin >> n >> atk >> hp;
    for (int i = 1, h; i <= n; ++i) {
        cin >> a[i] >> h;
        a[i] *= (h + atk - 1) / atk; // 计算贡献值
    }
    sort(a + 1, a + n + 1, greater<LL>()); // 降序排序
    LL now = 0, sum = 0;
    for (int i = 1; i <= n; ++i) {
        now += a[i];
        sum += now; // 累加总伤害
        if (sum >= hp) {
            cout << i;
            return 0;
        }
    }
    cout << "Fail";
    return 0;
}
```

---
处理用时：76.95秒
# 题目信息

# [常州市赛 2022] 迷宫探险

## 题目背景

搬运自 <http://czoj.com.cn/p/459>。数据为民间数据。



## 题目描述

完成了俱乐部可人老师布置的命题任务，小 $\text{X}$ 决定和朋友们玩一款探险类游戏放松一下心情。

这个游戏的场景是在一个地下迷宫中，这个迷宫由 $N \times N$ 的网格构成，小 $\text{X}$ 和他的 朋友们每人占据一个格子，他们每人带领一支探险队。每一分钟小 $\text{X}$ 会让他的探险队员从上下左右四个方向前往相邻的格子（只要相邻的格子不是障碍物），同时他的朋友们也会跟小 $\text{X}$ 一样做相同的操作。迷宫中有些格子是空的，而有些格子有自动计分器，最早到达这个格子的队员所属的玩家会得到 $1$ 分，然后这个自动计分器会消失，即之后到达这个格子就不会获得分数，如果有多个玩家的队员同时到达有自动计分器的格子，那么这些玩家都能得到 $1$ 分。

现在小 $\text{X}$ 想知道得分最多的玩家得到了多少分，以及所有玩家一共得到了多少分。你可以认为每位玩家的手下都有足够多的探险队员。

## 说明/提示

### 样例解释
在第一分钟，位于 $(1,1)$ 的玩家派出的探险队员到达 $(1,2)$ 得到 $1$ 分，位于 $(3,3)$ 的玩家派出 的探险队员到达 $(3,2)$ 得到 $1$ 分。在第二分钟，两位玩家派出的探险队员同时到达 $(2,2)$，各得 $1$ 分，之后即使游戏再进行下去也没有意义了，因为他们不可能再得到任何分数。得分最多的玩家得到的分数为 $2$ 分，所有玩家一共得到了 $4$ 分。

### 数据规模与约定

对于所有数据，$1\le N\le 100$，玩家的数量 $≤10$。

| 测试点编号 | $N$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $\le 10$ | 只有一个玩家 |
| $2$ | $\le 10$ | 只有一个得分点 |
| $3\sim 5$ | $\le 10$ | 无 |
| $6\sim 8$ | $\le 50$ | 无 |
| $9\sim 10$ | $\le 100$ | 无 |

## 样例 #1

### 输入

```
3
@$#
#$#
#$@```

### 输出

```
2
4```

# AI分析结果



# 算法分析与题解

## 唯一算法分类
**多源 BFS**

---

## 综合分析与结论

### 核心思路
1. **多源 BFS 洪水填充**：将每个玩家的起点视为独立源点，同时进行层次遍历（每分钟扩散一层）。
2. **时空状态记录**：每个格子维护两个状态：
   - `step`：记录最早到达时间（初始为极大值）。
   - `vis_id`：用位集合记录哪些玩家在该时间到达过。
3. **同步扩展处理**：递归处理每一时间步的队列节点，确保同一时间步的所有玩家扩展操作同步完成。

### 解决难点
- **同时到达判定**：当多个玩家在同一时间步到达同一计分点时，需同时加分。通过`vis_id`的位操作确保每个玩家仅在该时间步首次到达时计分。
- **时空效率优化**：用层次递归代替逐节点遍历，保证时间复杂度为 O(N²K)，N 为地图边长，K 为玩家数。

### 可视化设计要点
- **网格动画**：用 Canvas 绘制迷宫网格，玩家用不同颜色表示。每个扩散步骤动态显示扩散边界，计分点被占领时闪烁高亮。
- **状态面板**：实时显示当前时间步、各玩家得分及总得分。
- **复古音效**：扩散时播放 8-bit 音效，得分时触发短促提示音。
- **步进控制**：支持暂停/继续，单步执行观察每层扩散细节。

---

## 题解清单（5星）

### 题解作者：CJR_Rain
- **亮点**：
  1. 通过结构体 `visited` 精确管理每个格子的时空状态。
  2. 递归式层次 BFS 实现时间步同步处理。
  3. 位集合 `vis_id` 高效处理多玩家并发访问。
- **代码可读性**：结构清晰，注释详实，变量命名合理。
- **优化程度**：时空复杂度最优，无冗余操作。

---

## 核心代码实现

### 洪水填充关键函数
```cpp
void flood(int len, int step) {
    while(len-- != 0) {
        node front = bfs.front();
        bfs.pop();
        for(int i = 0; i < 4; ++i) {
            int nr = front.row + go_row[i], nc = front.col + go_col[i];
            if(nr < 0 || nr >= n || nc < 0 || nc >= n || maze[nr][nc] == '#') continue;
            // 时间判定与玩家去重
            if(vis[nr][nc].step < step || vis[nr][nc].vis_id[front.id]) continue;
            if(maze[nr][nc] == '$') ans[front.id]++;
            vis[nr][nc].step = step;
            vis[nr][nc].vis_id[front.id] = true;
            bfs.push({nr, nc, front.id});
        }
    }
    if(!bfs.empty()) flood(bfs.size(), step + 1);
}
```

### 完整代码
见原题解代码部分。

---

## 同类型题与套路
- **多源 BFS 应用场景**：如多火源蔓延、多起点最短路径等。
- **并发处理技巧**：使用分层队列处理同步事件。
- **状态压缩**：位操作或哈希记录复合状态。

---

## 推荐题目
1. **P1162 填涂颜色**（多源 BFS 基础）
2. **P2895 [USACO08FEB] Meteor Shower S**（时间分层 BFS）
3. **P1443 马的遍历**（单源 BFS 扩展）

---

## 个人心得摘录
- **调试关键**：需验证同一时间步多玩家到达同一格子的加分逻辑，通过打印 `vis_id` 和 `step` 确保正确。
- **优化顿悟**：递归处理层次替代逐节点判断时间，大幅简化代码逻辑。

---

## 可视化示例（伪代码）
```javascript
// Canvas 初始化与网格绘制
function drawGrid() {
    ctx.fillStyle = '#000';
    for(let i=0; i<N; i++) {
        for(let j=0; j<N; j++) {
            if(maze[i][j] === '#') ctx.fillRect(j*20, i*20, 20, 20);
            else if(maze[i][j] === '$') {
                ctx.fillStyle = '#FF0';
                ctx.fillRect(j*20, i*20, 20, 20);
            }
        }
    }
}

// 扩散动画
function animateStep(step) {
    let len = queue.length;
    while(len--) {
        let {x, y, id} = queue.shift();
        // 绘制玩家颜色扩散...
        for(let d of dirs) {
            let nx = x + d[0], ny = y + d[1];
            if(vis[nx][ny].step > step || !vis[nx][ny].vis_id[id]) {
                // 更新状态并加入队列...
            }
        }
    }
    if(queue.length) requestAnimationFrame(() => animateStep(step+1));
}
```

---
处理用时：82.00秒
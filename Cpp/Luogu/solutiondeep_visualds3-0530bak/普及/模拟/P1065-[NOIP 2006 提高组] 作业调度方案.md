# 题目信息

# [NOIP 2006 提高组] 作业调度方案

## 题目描述

我们现在要利用 $m$ 台机器加工 $n$ 个工件，每个工件都有 $m$ 道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。

每个工件的每个工序称为一个操作，我们用记号 `j-k` 表示一个操作，其中 $j$ 为 $1$ 到 $n$ 中的某个数字，为工件号；$k$ 为 $1$ 到 $m$ 中的某个数字，为工序号，例如 `2-4` 表示第 $2$ 个工件第 $4$ 道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。

例如，当 $n=3,m=2$ 时，`1-1,1-2,2-1,3-1,3-2,2-2` 就是一个给定的安排顺序，即先安排第 $1$ 个工件的第 $1$ 个工序，再安排第 $1$ 个工件的第 $2$ 个工序，然后再安排第 $2$ 个工件的第 $1$ 个工序，等等。

一方面，每个操作的安排都要满足以下的两个约束条件。

1. 对同一个工件，每道工序必须在它前面的工序完成后才能开始；

2. 同一时刻每一台机器至多只能加工一个工件。

另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。

由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为 `1 1 2 3 3 2`。

还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。

例如，取 $n=3,m=2$，已知数据如下（机器号/加工时间）：


工件号 |工序 1 | 工序 2
-|-|-
$1$  |  $1/3$  |  $2/2$
$2$  |  $1/2$  |  $2/5$
$3$  |  $2/2$  |  $1/4$

则对于安排顺序 `1 1 2 3 3 2`，下图中的两个实施方案都是正确的。但所需要的总时间分别是 $10$ 与 $12$。

方案 1，用时 $10$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | `3-1` | `3-1` |  无   | `1-2` | `1-2` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

方案 2，用时 $12$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12  |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` |   无   |  无   | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | 无 | 无 |  无   | `1-2` | `1-2` | `3-1` | `3-1` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件 $(1.)(2.)$ 的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件 $(1.)(2.)$ 的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。

显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。


## 说明/提示

NOIP 2006 提高组 第三题


## 样例 #1

### 输入

```
2 3
1 1 2 3 3 2
1 2 
1 2 
2 1
3 2 
2 5 
2 4
```

### 输出

```
10```

# AI分析结果



# [NOIP 2006 提高组] 作业调度方案

## 算法分类
**模拟**

---

## 综合分析与结论
- **核心思路**：按给定顺序模拟每个工序的插入，维护机器占用状态和工件工序完成时间。关键难点在于如何快速找到满足双约束条件的最早插入时间窗口。
- **解决难点**：
  1. **工序顺序约束**：用`last_time[工件]`记录每个工件上一工序结束时间，新工序必须在此时间之后开始。
  2. **机器独占约束**：用二维数组`mac[机器][时间]`标记机器占用状态，通过暴力遍历寻找连续空闲时间段。
- **时间复杂度**：O(M*N*T)，其中 T 为最大时间长度。数据范围小（M,N≤20），暴力可行。

---

## 题解评分（≥4星）
1. **ShawnZhou（5星）**  
   - 思路清晰，详细解释三个核心辅助数组的作用。
   - 代码结构规范，变量命名有明确含义（如`cnt_now_work_step`）。
   - 完整包含数据校验和图示说明。

2. **brealid（4星）**  
   - 代码简洁高效，直接通过累加空闲时间判断窗口。
   - 提供测试数据及图示，但变量名较短（如`mac`）。

3. **qhr2023（4星）**  
   - 代码极度精简（仅 30 行），核心逻辑高度凝练。
   - 使用`use`数组代替时间轴标记，思路与主流解法一致。

---

## 最优思路与技巧提炼
**关键数据结构**：
```cpp
int mac[21][100001];  // 机器时间轴占用标记
int step[21];          // 工件当前工序编号
int last_time[21];    // 工件上一工序结束时间
```

**核心算法流程**：
1. 按顺序处理每个工件工序，递增`step[工件]`。
2. 从`last_time[工件]+1`开始，在目标机器上寻找连续`cost`长度的空闲窗口。
3. 找到后标记机器时间轴，更新`last_time`和总时间`ans`。

**优化技巧**：
- **连续空闲计数**：遇到空闲时累加计数器，遇到占用时重置，避免重复扫描。
- **时间轴压缩**：只需维护最大时间轴长度，无需预分配超大数组。

---

## 同类型题与算法套路
**相似题目套路**：
1. 时间轴模拟类问题（如电梯调度、会议室安排）。
2. 双约束条件下的贪心插入策略（如课程表编排）。

**推荐练习**：
1. P2586 [NOIP2015] 跳石头（时间轴二分）
2. P1968 美元汇率（状态机模拟）
3. P1051 [NOIP2005] 谁拿了最多奖学金（多条件排序）

---

## 可视化设计（复古像素风格）
**动画方案**：
1. **时间轴网格**：用 Canvas 绘制机器时间轴，每个像素块代表 1 时间单位。
   - 空闲块：绿色（#00FF00）
   - 占用块：按工件编号染色（如红、蓝、黄）
2. **高亮扫描过程**：红色边框标记当前检查的时间点，黄色闪烁表示找到的空闲窗口。
3. **音效系统**：
   - 扫描移动：8-bit "哔"声（每次移动播放）
   - 插入成功：NES 过关音效（#include <SFML/Audio>）
4. **自动演示模式**：按 500ms/步自动运行，支持暂停/单步调试。

**交互示例**：
```javascript
// 伪代码：时间轴标记过程
function markTime(machine, start, duration, color) {
  for (let t = start; t < start + duration; t++) {
    ctx.fillStyle = color;
    ctx.fillRect(t * 10, machine * 30, 8, 25);
  }
  playSound('success.wav');
}
```

---

## 核心代码实现（brealid版）
```cpp
#include <stdio.h>
int m, n, list[501], mac[21][100001] = {0}, step[21] = {0}, las_time[21] = {0}, ans = 0;
struct { int id, cost; } a[21][21];

int main() {
    scanf("%d%d", &m, &n);
    for (int i = 1; i <= m * n; i++) scanf("%d", list + i);
    // 读入机器编号和耗时
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            scanf("%d", &a[i][j].id);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            scanf("%d", &a[i][j].cost);
    
    for (int i = 1; i <= m * n; i++) {
        int now = list[i];
        step[now]++;
        int id = a[now][step[now]].id, cost = a[now][step[now]].cost;
        int s = 0;
        // 关键：寻找连续空闲窗口
        for (int j = las_time[now] + 1; ; j++) {
            if (mac[id][j] == 0) s++;
            else s = 0;
            if (s == cost) {
                for (int k = j - cost + 1; k <= j; k++) mac[id][k] = 1;
                if (j > ans) ans = j;
                las_time[now] = j;
                break;
            }
        }
    }
    printf("%d", ans);
    return 0;
}
```

---

## 个人心得摘录
- **翠竹叶飞**："模拟题难在审题，必须逐句理解约束条件。"
- **SimonSu**："变量名要避免混淆，如 ii 和 jj 易错。"
- **Kun_is_Me**："数据范围小直接暴力，无需复杂优化。"

---

**可视化总结**：通过动态展示机器时间轴的填充过程，配合音效和颜色反馈，可直观理解工序插入策略。复古像素风格增强学习趣味性，适合教学演示。

---
处理用时：102.61秒
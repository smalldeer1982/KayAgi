# 题目信息

# [NOIP 2012 提高组] 同余方程

## 题目描述

求关于 $ x$ 的同余方程 $ a x \equiv 1 \pmod {b}$ 的最小正整数解。


## 说明/提示

### 数据规模与约定

- 对于 $40\%$ 的数据，$2 ≤b≤ 1,000$；
- 对于 $60\%$ 的数据，$2 ≤b≤ 50,000,000$；
- 对于 $100\%$ 的数据，$2 ≤a, b≤ 2,000,000,000$。



## 样例 #1

### 输入

```
3 10```

### 输出

```
7```

# AI分析结果



# 算法分类  
**扩展欧几里得算法**

---

# 综合分析与结论  
本题核心是求解模逆元问题，本质是扩展欧几里得算法的应用。通过将同余方程转化为线性不定方程 `ax + by = 1`，利用递归分解参数并回溯求解系数。关键难点在于理解递归变量关系推导与负数解处理，最终通过取模运算得到最小正整数解。

**可视化设计要点**：  
1. 递归树动态展示：用层级式动画展示每次递归调用的参数变化（`a,b→b,a%b`）  
2. 回溯过程高亮：用不同颜色标注当前更新的`x`与`y`变量  
3. 负数修正演示：展示`x = (x%b + b) % b`的运算过程  
4. 像素风格设计：  
   - 用16色像素块表示递归层级（绿色表示当前层，灰色表示完成层）  
   - 音效触发：递归调用时播放"beep1.wav"，回溯时播放"beep2.wav"  
5. 自动演示模式：按F键加速动画，S键单步执行  

---

# 题解清单（≥4星）  
1. **学委（★★★★★）**  
   - 亮点：完整推导exgcd数学原理，注释清晰的代码实现，附带逆元应用场景说明  
   - 核心代码段：  
     ```cpp  
     void exgcd(long long a, long long b) {
         if(b == 0) { x=1; y=7; return; }
         exgcd(b, a%b);
         long long tx = x;
         x = y;
         y = tx - a/b*y; 
     }  
     ```  

2. **_Nova（★★★★☆）**  
   - 亮点：结合裴蜀定理严格证明，变量命名清晰，包含通解分析  
   - 关键注释：  
     ```cpp  
     // 联立方程推导关系式 x1=y2, y1=x2 - a/b*y2  
     ```  

3. **Shir0（★★★★☆）**  
   - 亮点：魔改同余式为标准exgcd形式，代码极简风格  
   - 优化技巧：  
     ```cpp  
     exgcd(b, a%b, y, x); // 交换x,y减少计算步骤  
     y -= a/b * x;  
     ```  

---

# 最优思路与技巧提炼  
1. **核心推导公式**  
   ```
   递归关系：x = y_prev  
           y = x_prev - (a//b)*y_prev  
   终止条件：b=0时返回x=1, y=0  
   ```

2. **负数修正技巧**  
   ```cpp  
   x = (x % b + b) % b; // 将解调整到[0,b)区间  
   ```

3. **递归参数传递优化**  
   通过交换参数顺序 `exgcd(b, a%b, y, x)` 减少中间变量使用

---

# 同类题目推荐  
1. **P5656** 二元一次不定方程（扩展exgcd应用）  
2. **P3811** 模意义乘法逆元（线性求逆元）  
3. **P1516** 青蛙的约会（同余方程建模）

---

# 个人心得摘录  
> "调试时发现`y`初始值不影响结果，但`y=7`的写法提醒了变量在回溯时的覆盖特性" —— 学委  
> "快速幂法在b非质数时失效，exgcd才是通用解法" —— 沙普绿12138  

---

# 核心算法可视化  
**扩展欧几里得递归过程演示**  
```javascript  
// Canvas绘制伪代码  
function drawStep(a, b, x, y, depth) {
    ctx.fillStyle = depthColors[depth%6]; 
    ctx.fillRect(20, 20+30*depth, 200, 25); // 递归层级条
    ctx.fillText(`a=${a} b=${b} → x=${x} y=${y}`, 25, 40+30*depth);
}

// 音效触发
function playSound(type) {
    if(type === 'call') beep(440, 50);  // 高音调递归调用
    if(type === 'return') beep(220, 80);// 低音调回溯
}
```

**复古像素风格CSS片段**  
```css  
.pixel-font {
    font-family: 'Press Start 2P', cursive;
    image-rendering: pixelated;
}
.exgcd-block {
    width: 16px; height: 16px;
    background: #7C3F58; /* 暗紫色像素块 */
    transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
}
```

---

# 完整代码实现  
**扩展欧几里得标准解法**  
```cpp  
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

ll exgcd(ll a, ll b, ll &x, ll &y) {
    if(!b) { x=1; y=0; return a; }
    ll d = exgcd(b, a%b, y, x);
    y -= a/b * x;
    return d;
}

int main() {
    ll a, b, x, y;
    cin >> a >> b;
    exgcd(a, b, x, y);
    x = (x%b + b) % b;
    cout << x;
    return 0;
}
```

---
处理用时：84.90秒
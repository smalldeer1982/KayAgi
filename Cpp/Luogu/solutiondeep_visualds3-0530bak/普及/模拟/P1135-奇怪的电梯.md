# 题目信息

# 奇怪的电梯

## 题目背景

感谢 @[yummy](https://www.luogu.com.cn/user/101694) 提供的一些数据。

## 题目描述

呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \le i \le N$）上有一个数字 $K_i$（$0 \le K_i \le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 200$，$1 \le A, B \le N$，$0 \le K_i \le N$。

本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。

## 样例 #1

### 输入

```
5 1 5
3 3 1 2 5
```

### 输出

```
3
```

# AI分析结果



**唯一算法分类**：广度优先搜索（BFS）

---

### **综合分析与结论**
#### **核心思路与难点**
1. **问题建模**：将楼层视为图节点，每次上下移动视为边权为 1 的边，转化为最短路径问题。
2. **BFS 优势**：由于边权统一为 1，BFS 天然保证首次访问即最短路径，时间复杂度最优（O(n)）。
3. **关键数据结构**：队列 + 标记数组（`vis[]`）避免重复访问。
4. **DFS 剪枝难点**：必须记录每个节点的最小步数（`minn[]`），若当前路径步数 ≥ 记录值则终止搜索。

#### **可视化设计要点**
1. **动画流程**：
   - **队列动态**：用色块展示队列元素，当前处理节点高亮为红色。
   - **楼层扩展**：每次处理节点时，向上/向下扩展的楼层用绿色闪烁提示。
   - **步数标记**：在节点旁显示当前步数，已访问节点标记为灰色。
2. **复古像素风格**：
   - **颜色方案**：8-bit 风格，使用红（当前节点）、绿（扩展节点）、灰（已访问）。
   - **音效触发**：按键声（扩展新节点时）、胜利音效（到达终点）、失败音效（队列空）。
3. **交互功能**：支持暂停/继续、单步执行、速度调节，展示队列状态和楼层变化。

---

### **题解清单（≥4星）**
1. **作者：cff_0102（★★★★☆）**  
   **亮点**：代码简洁，使用标准 BFS 模板，正确处理初始状态（A=B 时返回 0）。  
   **核心代码**：
   ```cpp
   queue<int> q;
   q.push(s);
   vis[s] = 1;
   while (!q.empty()) {
       int x = q.front(); q.pop();
       if (x == e) return t;
       // 扩展上下楼层并标记
   }
   ```
2. **作者：yummy（★★★★★）**  
   **亮点**：深入分析 DFS 剪枝陷阱，提出「四边形链」Hack 数据，给出正确剪枝条件。  
   **关键语句**：  
   > "每进入一次 DFS 函数，必然导致某个 `ans` 减少，总调用次数为 O(n²)。"

3. **作者：_H17（★★★★☆）**  
   **亮点**：全面对比 Dijkstra、SPFA、BFS 实现，适合算法拓展学习。

---

### **最优思路与代码示例**
#### **BFS 核心实现**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, a, b, k[205], vis[205];
int bfs() {
    queue<pair<int, int>> q;
    q.push({a, 0});
    vis[a] = 1;
    while (!q.empty()) {
        auto [x, step] = q.front(); q.pop();
        if (x == b) return step;
        // 向上扩展
        int up = x + k[x];
        if (up <= n && !vis[up]) {
            vis[up] = 1;
            q.push({up, step + 1});
        }
        // 向下扩展
        int down = x - k[x];
        if (down >= 1 && !vis[down]) {
            vis[down] = 1;
            q.push({down, step + 1});
        }
    }
    return -1;
}
```

#### **DFS 剪枝技巧**
```cpp
void dfs(int u, int step) {
    if (step >= minn[u]) return;  // 关键剪枝
    minn[u] = step;
    // 递归扩展上下楼层
}
```

---

### **同类型题目与推荐**
1. **P1443 马的遍历**：BFS 求棋盘最短路径。  
2. **P1162 填涂颜色**：BFS 扩展连通区域。  
3. **P1141 01迷宫**：BFS 预处理连通块。

---

### **可视化代码片段（伪代码）**
```javascript
// Canvas 绘制楼层状态
function drawFloor(floor, color) {
    ctx.fillStyle = color;
    ctx.fillRect(floor * 20, 100, 18, 18);
}

// BFS 单步执行（动画核心）
function nextStep() {
    let current = queue.shift();
    drawFloor(current.x, 'red'); // 高亮当前节点
    // 扩展上下楼层并绘制
    if (checkValid(up)) {
        queue.push(up);
        drawFloor(up, 'green');
    }
}
```

---

### **总结**
本题通过 BFS 实现最优解，DFS 需严格剪枝。可视化设计可结合队列动态和像素风格，强化算法流程理解。

---
处理用时：76.37秒
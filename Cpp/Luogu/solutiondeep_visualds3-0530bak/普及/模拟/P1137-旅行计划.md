# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果



**唯一算法分类**：拓扑排序 + 动态规划

---

### **题解思路、算法要点与解决难点**
1. **核心逻辑**  
   - **拓扑排序**保证节点的处理顺序满足「前驱节点先于后继节点」，确保DP的无后效性。  
   - **动态规划**定义 `dp[i]` 为以节点 `i` 为终点的最长路径长度，状态转移为：`dp[v] = max(dp[v], dp[u] + 1)`，其中 `u` 是 `v` 的前驱节点。

2. **关键实现**  
   - **拓扑排序**：通过入度队列实现，初始入度为0的节点入队，逐步处理并更新邻接节点入度。  
   - **DP更新**：在拓扑序中遍历每个节点 `u`，用 `u` 的 `dp` 值更新其所有邻接节点 `v` 的 `dp` 值。

3. **难点对比**  
   - **正向拓扑**：需显式维护拓扑序，再按序更新DP，代码稍长但性能稳定。  
   - **反向建图+记忆化搜索**：无需显式拓扑排序，但递归可能存在栈溢出风险（实际数据下较少见）。  
   - **拓扑与DP合并**：在拓扑排序过程中直接更新DP，减少代码量但需确保更新顺序正确。

---

### **题解评分（≥4星）**
1. **作者：星星之火（5星）**  
   - **亮点**：详细解释拓扑排序与DP的关系，代码规范，注释清晰。  
   - **关键代码**：显式分离拓扑排序与DP更新，便于理解。  
   ```cpp
   void topsort() { /* 拓扑排序 */ }
   for (int i=1; i<=n; i++) { // 按拓扑序更新DP
       int u = ts[i];
       for (int j=head[u]; j; j=edge[j].next) {
           int v = edge[j].to;
           dp[v] = max(dp[v], dp[u]+1);
       }
   }
   ```

2. **作者：_ZZH（5星）**  
   - **亮点**：代码极简，拓扑排序与DP合并，减少循环次数。  
   - **关键代码**：拓扑过程中直接更新DP值，无额外遍历。  
   ```cpp
   while (!q.empty()) {
       int u = q.front(); q.pop();
       for (邻接节点v) {
           dp[v] = max(dp[v], dp[u]+1);
           if (--in[v] == 0) q.push(v);
       }
   }
   ```

3. **作者：归山_（4星）**  
   - **亮点**：反向建图+记忆化搜索，代码简短但需理解反向逻辑。  
   - **关键代码**：递归式记忆化搜索。  
   ```cpp
   int dfs(int x) {
       if (dp[x] != -1) return dp[x];
       dp[x] = 1;
       for (邻接节点y) {
           dp[x] = max(dp[x], dfs(y)+1);
       }
       return dp[x];
   }
   ```

---

### **最优思路或技巧提炼**
1. **拓扑序DP**：显式拓扑排序后按序更新DP，保证无后效性，适合大规模数据。  
2. **反向建图+记忆化搜索**：无需显式拓扑排序，代码简短，适合节点数较少的情况。  
3. **入度队列合并DP更新**：在拓扑排序过程中直接更新邻接节点，减少代码冗余。

---

### **同类型题或类似算法套路**
1. **DAG最长路径**：拓扑排序后DP，如 [洛谷P4017（最大食物链计数）](https://www.luogu.com.cn/problem/P4017)。  
2. **任务调度**：拓扑排序处理依赖关系，如 [洛谷P1113（杂务）](https://www.luogu.com.cn/problem/P1113)。  
3. **关键路径**：AOE网中的最长路径，需结合拓扑排序与DP。

---

### **推荐洛谷题目**
1. **P4017（最大食物链计数）**：DAG上的路径计数，拓扑排序+DP。  
2. **P1113（杂务）**：拓扑排序求最长路径，任务调度模型。  
3. **P3387（缩点+最长路径）**：强连通分量缩点后转化为DAG问题。

---

### **个人心得摘录**
- **调试教训**：初始未处理多起点（如样例中的城市1），导致部分节点DP值错误。  
- **顿悟点**：拓扑排序的队列处理顺序天然满足DP更新的依赖关系。  
- **代码优化**：合并拓扑与DP更新可减少一次循环，提升代码效率。

---

### **可视化与算法演示**
1. **动画方案**  
   - **拓扑排序过程**：  
     - **节点颜色**：白色（未处理）→ 黄色（入队）→ 绿色（已处理）。  
     - **边高亮**：处理节点时，其出边变为红色，邻接节点入度减1。  
   - **DP更新**：  
     - 当前节点 `u` 显示为蓝色，其邻接节点 `v` 的 `dp` 值更新时闪烁。  
     - 显示 `dp` 值变化：如 `dp[v] = max(原值, dp[u]+1)`。  

2. **复古像素风格**  
   - **Canvas绘制**：节点用16x16像素方块表示，边用直线连接。  
   - **音效设计**：  
     - 节点入队时播放“叮”声，处理完成时播放“咔嚓”声。  
     - DP值更新时播放上升音调。  
   - **自动演示**：按拓扑序逐步处理节点，速度可调节（1x/2x/5x）。  

3. **交互设计**  
   - **控制面板**：暂停/继续、单步执行、重置。  
   - **参数调节**：动态调整动画速度，显示/隐藏DP值和入度。  

---

**代码片段（复古动画核心逻辑）**  
```javascript
// 伪代码：拓扑排序动画
function drawNode(node, state) {
    // 状态：white（未处理）、yellow（队列中）、green（已处理）
    ctx.fillStyle = state === 'processed' ? '#00FF00' : 
                    state === 'queued' ? '#FFFF00' : '#FFFFFF';
    ctx.fillRect(node.x * 32, node.y * 32, 24, 24);
}

function animateTopo() {
    let u = queue.dequeue();
    drawNode(u, 'processing'); // 蓝色高亮当前节点
    playSound('blip');
    for (邻接节点v of u.edges) {
        v.indegree--;
        if (v.indegree === 0) {
            queue.enqueue(v);
            drawNode(v, 'queued');
        }
        drawEdge(u, v, 'red'); // 边变红
        setTimeout(() => updateDP(v), 500);
    }
    drawNode(u, 'processed');
}
```

---
处理用时：93.74秒
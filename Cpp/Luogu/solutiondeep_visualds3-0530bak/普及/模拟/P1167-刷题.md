# 题目信息

# 刷题

## 题目描述

NOIP 临近了，小 A 却发现他已经不会写题了。好在现在离竞赛还有一段时间，小 A 决定从现在开始夜以继日地刷题。也就是说小 A 废寝忘食，一天二十四小时地刷题。

今天的日期（时间）是 yyyy 年 mm 月 dd 日 hh 时 MM 分，考试的时间是 yyyy2 年 mm2 月 dd2 日 hh2 时 MM2 分。这之间的所有时间小 A 都用来刷题了，那么考试之前他最多能刷多少题呢？注意哦，考虑闰年。

时间紧张小 A 只管数量不管质量。当然有的题目容易一些，有的题目难一些。根据小 A 的经验，他能一眼看出写出某一个题目需要的时间，以分钟记。

现在给出洛谷 Online Judge 的题目列表，请你挑出最多的题目使小A能在竞赛前写出来。

我们假设从远古到未来，历法的表示与现在一样。


## 样例 #1

### 输入

```
2
1
1
2007-06-23-11:59
2007-06-23-12:00```

### 输出

```
1```

# AI分析结果



# 算法分类  
**模拟、贪心**

---

# 题解分析与结论  

## 核心思路  
1. **时间计算**：将两个时间点转换为从基准时间（如 0000-01-01 00:00）开始的总分钟数，差值即为可用时间。  
2. **贪心选择**：对题目按时间排序，依次选择最短的题目直至时间耗尽。  

---

## 关键难点与解决方案  
1. **闰年判断**：  
   - **判断规则**：能被4整除但不能被100整除，或能被400整除。  
   - **优化处理**：提前预计算每个月的天数（含闰年修正）。  

2. **时间转换**：  
   - **高效计算**：逐年份累加天数（区分闰年），避免逐天计算导致超时。  
   - **基准点法**：将时间转换为距基准点的总分钟数，直接相减得差值。  

3. **输入处理**：  
   - **统一格式**：使用 `scanf` 直接读取格式化输入，避免字符串分割。  

---

## 最优思路提炼  
1. **基准时间法**：  
   ```cpp  
   long long getStandardTime() {  
       // 累加年份天数（含闰年）  
       // 累加月份天数（动态修正闰年2月）  
       // 转换为总分钟数  
   }  
   timeLeft = endTime - startTime;  
   ```  
2. **贪心排序**：  
   ```cpp  
   sort(a, a + n);  
   for (int i = 0; i < n; i++) {  
       if (timeLeft >= a[i]) {  
           timeLeft -= a[i];  
           ans++;  
       }  
   }  
   ```  

---

## 题解评分（≥4星）  

### 1. 傅思维666（★★★★☆）  
- **亮点**：  
  - 基准时间法实现简洁，逻辑清晰。  
  - 代码结构模块化（年份、月份、日时分逐步处理）。  
- **代码片段**：  
  ```cpp  
  for (int i = start[1]; i < endd[1]; i++) {  
      if (check(i)) time += 366;  
      else time += 365;  
  }  
  // 多退少补处理月份和日  
  ```  

### 2. king_xbz（★★★★☆）  
- **亮点**：  
  - 封装日期计算为独立函数，提高可读性。  
  - 预处理月份天数数组，避免重复计算。  
- **代码片段**：  
  ```cpp  
  void year_to_day() {  
      for (int i = a; i < x; i++)  
          if (run(i)) tot += 366 * 1440;  
  }  
  ```  

### 3. outis_crypt（★★★★★）  
- **亮点**：  
  - 利用 Java `Calendar` 类直接计算时间差，避免手动模拟。  
  - 跨语言思路，提供 API 调用参考。  
- **代码片段**：  
  ```java  
  Calendar a = Calendar.getInstance();  
  a.set(y1, m1-1, d1, h1, min1);  
  long diff = b.getTimeInMillis() - a.getTimeInMillis();  
  ```  

---

# 可视化算法演示  

## 核心流程  
1. **时间转换动画**：  
   - **年份累加**：像素方块逐年增长，闰年用黄色高亮。  
   - **月份处理**：网格显示月份天数，红色标记当前处理月份。  
   - **分钟统计**：进度条显示总分钟数累加过程。  

2. **贪心选择动画**：  
   - **排序过程**：题目时间数组用绿色方块表示，排序后按大小排列。  
   - **时间消耗**：时间条逐渐缩短，选中方块变为灰色并播放“吞噬”音效。  

---

## 复古游戏化设计  
- **像素风格**：  
  - **调色板**：16色（深蓝背景、绿色时间条、红色高亮闰年）。  
  - **音效**：8-bit 音效（时间累加“滴答声”，选中题目“叮咚声”）。  
- **自动演示模式**：  
  - **AI 控制**：自动逐步执行年份累加、月份修正和贪心选择。  
  - **关卡设计**：第一关演示时间计算，第二关演示贪心选择。  

---

# 相似题目推荐  
1. **P1518 [USACO2.4] 两只塔姆沃斯牛**（日期循环模拟）  
2. **P1068 [NOIP2009 普及组] 分数线划定**（排序与贪心）  
3. **P1781 宇宙总统**（大数处理与排序）  

---

# 代码实现（关键逻辑）  
```cpp  
// 计算两个时间的总分钟差  
long long calculateTimeDiff() {  
    long long days = 0;  
    // 处理年份差  
    for (int y = startYear; y < endYear; y++) {  
        days += isLeap(y) ? 366 : 365;  
    }  
    // 处理月份和日  
    days += endDay - startDay;  
    // 转换为分钟  
    return days * 1440 + (endHour - startHour) * 60 + (endMin - startMin);  
}  
```  

---

# 个人心得摘录  
- **傅思维666**：  
  > “多退少补思想是处理日期差的核心，先算整年整月，再修正边界。”  
- **Ousmane_Dembele**：  
  > “WA 多次后发现符号错误，时间差计算必须注意结束时间是否更大。”  

---

通过结构化处理时间和贪心策略，本题的核心在于高效准确的时间转换与排序选择。可视化设计可显著增强对算法流程的理解，尤其在处理复杂日期计算时。

---
处理用时：91.50秒
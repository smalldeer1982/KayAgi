# 题目信息

# 教辅的组成

## 题目背景

滚粗了的 HansBug 在收拾旧语文书，然而他发现了什么奇妙的东西。


## 题目描述

蒟蒻 HansBug 在一本语文书里面发现了一本答案，然而他却明明记得这书应该还包含一份练习题。然而出现在他眼前的书多得数不胜数，其中有书，有答案，有练习册。已知一个完整的书册均应该包含且仅包含一本书、一本练习册和一份答案，然而现在全都乱做了一团。许多书上面的字迹都已经模糊了，然而 HansBug 还是可以大致判断这是一本书还是练习册或答案，并且能够大致知道一本书和答案以及一本书和练习册的对应关系（即仅仅知道某书和某答案、某书和某练习册有可能相对应，除此以外的均不可能对应）。既然如此，HansBug 想知道在这样的情况下，最多可能同时组合成多少个完整的书册。



## 说明/提示

样例说明：

如题，$N_1=5$，$N_2=3$，$N_3=4$，表示书有 $5$ 本、练习册有 $3$ 本、答案有 $4$ 本。

$M_1=5$，表示书和练习册共有 $5$ 个可能的对应关系，分别为：书 $4$ 和练习册 $3$ 、书 $2$ 和练习册 $2$ 、书 $5$ 和练习册 $2$ 、书 $5$ 和练习册 $1$ 以及书 $5$ 和练习册 $3$。

$M_2=5$，表示数和答案共有 $5$ 个可能的对应关系，分别为：书 $1$ 和答案 $3$、书 $3$ 和答案 $1$、书 $2$ 和答案 $2$、书 $3$ 和答案 $3$ 以及书 $4$ 和答案 $3$。

所以，以上情况的话最多可以同时配成两个书册，分别为：书 $2$ 练习册 $2$ 答案 $2$、书 $4$ 练习册 $3$ 答案 $3$。


数据规模：

![](https://cdn.luogu.com.cn/upload/image_hosting/srj2v9um.png)

对于数据点 $1,2,3$，$1\le M_1,M_2\leq 20$。

对于数据点 $4\sim 10$，$1\le M_1,M_2 \leq 20000$。


## 样例 #1

### 输入

```
5 3 4
5
4 3
2 2
5 2
5 1
5 3
5
1 3
3 1
2 2
3 3
4 3
```

### 输出

```
2```

# AI分析结果



---

### **唯一算法分类**  
网络流（拆点最大流）

---

### **综合分析与结论**  
**核心思路**：  
1. **拆点限制流量**：将每本书拆分为入点和出点，中间连容量为1的边，保证每本书仅被使用一次。  
2. **三层网络结构**：  
   - 源点 → 练习册 → 书的入点  
   - 书的出点 → 答案 → 汇点  
3. **Dinic算法优化**：使用当前弧优化加速最大流计算。

**解决难点**：  
- 通过拆点保证书节点的流量限制（核心难点）  
- 正确连接练习册和答案的对应关系  

**可视化设计**：  
1. **像素化动画**：  
   - 用不同颜色表示练习册（绿色）、书入点（黄色）、书出点（橙色）、答案（蓝色）  
   - 高亮增广路径中的边（红色闪烁）  
2. **音效反馈**：  
   - 增广成功时播放8-bit上升音效  
   - 流量耗尽时播放短促“滴”声  
3. **自动演示模式**：展示从源点到汇点的完整增广过程，单步可暂停观察拆点边状态。

---

### **题解清单 (≥4星)**  
1. **Siyuan（★★★★★）**  
   - **亮点**：图解拆点原理，代码结构清晰，变量命名规范  
   - **关键代码**：  
     ```cpp  
     for(int i=1;i<=n1;++i) addedge(id(2,i),id(3,i),1);  
     ```  
     明确拆点连接逻辑  

2. **localhost（★★★★☆）**  
   - **亮点**：注释清晰，强调拆点必要性  
   - **个人心得**：  
     > "注意一定要拆点，因为一本书只能用一次"  

3. **Drinkwater（★★★★☆）**  
   - **亮点**：代码简洁高效，使用反向边优化  
   - **关键逻辑**：  
     ```cpp  
     add(nex+i,nex+nb+i,1); // 拆点连接  
     ```

---

### **最优思路与代码实现**  
**核心代码片段**（Dinic算法核心 + 拆点建图）：  
```cpp  
// 拆点连接  
for(int i=1;i<=n1;i++)  
    addedge(book_in[i], book_out[i], 1);  

// 练习册 -> 书入点  
for(auto &p : practice_edges)  
    addedge(prac_node[p.second], book_in[p.first], 1);  

// 书出点 -> 答案  
for(auto &a : answer_edges)  
    addedge(book_out[a.first], ans_node[a.second], 1);  

// Dinic核心：分层+DFS  
while(bfs()) while((flow=dfs(s,INF))) maxflow += flow;  
```

---

### **同类题目推荐**  
1. **P1402 酒店之王**（三分图匹配）  
2. **P2763 试题库问题**（多条件匹配）  
3. **P3254 圆桌问题**（多重约束流量分配）

---

### **可视化算法演示**  
**动画方案**：  
1. **初始状态**：  
   - 练习册节点脉冲式绿色呼吸效果  
   - 拆点边显示黄色静态边框  

2. **增广过程**：  
   - 当前路径节点高亮为紫色  
   - 增广成功时路径边闪烁金色  

3. **像素风格细节**：  
   - 使用16色调色板（NES风格）  
   - 节点用8x8像素方块表示，边用虚线像素箭头  

**交互控制**：  
- 空格键暂停/继续  
- 方向键调节动画速度  
- F键触发自动演示模式  

---

### **总结**  
本题通过拆点网络流巧妙解决资源重复使用问题，其核心在于将节点流量限制转化为边容量限制。掌握拆点思想可解决90%的同类网络流题目，建议通过可视化工具深刻理解增广路径与流量变化的关系。

---
处理用时：53.25秒
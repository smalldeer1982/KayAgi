# 题目信息

# 血色先锋队

## 题目背景

巫妖王的天灾军团终于卷土重来，血色十字军组织了一支先锋军前往诺森德大陆对抗天灾军团，以及一切沾有亡灵气息的生物。孤立于联盟和部落的血色先锋军很快就遭到了天灾军团的重重包围，现在他们将主力只好聚集了起来，以抵抗天灾军团的围剿。可怕的是，他们之中有人感染上了亡灵瘟疫，如果不设法阻止瘟疫的扩散，很快就会遭到灭顶之灾。大领主阿比迪斯已经开始调查瘟疫的源头。原来是血色先锋军的内部出现了叛徒，这个叛徒已经投靠了天灾军团，想要将整个血色先锋军全部转化为天灾军团！无需惊讶，你就是那个叛徒。在你的行踪败露之前，要尽快完成巫妖王交给你的任务。

## 题目描述

军团是一个 $n$ 行 $m$ 列的矩阵，每个单元是一个血色先锋军的成员。感染瘟疫的人，每过一个小时，就会向四周扩散瘟疫，直到所有人全部感染上瘟疫。你已经掌握了感染源的位置，任务是算出血色先锋军的领主们感染瘟疫的时间，并且将它报告给巫妖王，以便对血色先锋军进行一轮有针对性的围剿。

## 说明/提示

#### 输入输出样例 1 解释

如下图，标记出了所有人感染瘟疫的时间以及感染源和领主的位置。

![](https://cdn.luogu.com.cn/upload/image_hosting/3j3g02cn.png)

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n,m\le500$，$1\le a,b\le10^5$。

## 样例 #1

### 输入

```
5 4 2 3
1 1
5 4
3 3
5 3
2 4
```

### 输出

```
3
1
3```

# AI分析结果



**唯一算法分类**: 多源BFS

---

### **综合分析与结论**
**题目核心**: 计算每个领主被感染的最早时间，即多个感染源同时扩散时的最短曼哈顿距离或BFS层数。  
**解决难点**:  
1. **多起点扩散**：需同时处理多个感染源的扩散，避免重复计算。  
2. **高效性要求**：数据规模大（500×500网格），暴力枚举在极端数据下超时。  
**最优思路**: 多源BFS，时间复杂度为O(nm)，每个点仅访问一次，确保线性效率。  

**可视化设计思路**:  
1. **动画流程**：  
   - **初始状态**：感染源标记为红色，领主标记为蓝色，其他点灰色。  
   - **扩散过程**：每次BFS扩展一层，新感染点颜色渐变（如红→橙→黄）。  
   - **队列可视化**：右侧显示队列中的坐标和当前层数，指针动态更新。  
2. **复古像素风格**：  
   - **8位网格**：每个点用16×16像素方块表示，颜色对应感染时间。  
   - **音效设计**：扩散时播放“滴”声，找到领主时播放“成功”音效。  
3. **交互功能**：支持暂停/继续、调整速度、单步执行。  

---

### **题解清单 (≥4星)**
1. **作者：llzzxx712 (5星)**  
   - **亮点**：完整实现多源BFS，初始感染源入队并标记，逐步扩散更新感染时间，代码清晰易读。  
   - **关键代码**：  
     ```cpp
     queue<node> Q;
     for (感染源入队并标记时间0);
     while (!Q.empty()) {
         node = Q.front(); Q.pop();
         for (四个方向扩展) {
             if (未越界且未感染) {
                 标记时间 = 当前时间 + 1;
                 Q.push(新节点);
             }
         }
     }
     ```

2. **作者：Sakura_Peng (4星)**  
   - **亮点**：使用STL队列简化代码，结构体封装坐标和步数，注释详细。  
   - **个人心得**：强调队列初始化和方向数组的重要性。  

3. **作者：末影地牢 (4星)**  
   - **亮点**：暴力解法通过巧妙优化通过测试，代码极简（仅10行），适合小数据场景。  
   - **核心逻辑**：  
     ```cpp
     for (每个领主) 
         min_distance = min(曼哈顿距离所有感染源);
     ```

---

### **最优思路提炼**
1. **多源BFS核心**：  
   - **队列初始化**：所有感染源同时入队，时间设为0。  
   - **层序扩展**：每次处理一层节点，保证最早感染时间被记录。  
   - **状态标记**：使用二维数组记录是否已访问，避免重复计算。  

2. **暴力优化技巧**：  
   - **曼哈顿距离剪枝**：若当前最小值已为0或1，提前终止内层循环。  

---

### **相似题目推荐**
1. **[P5427 01矩阵](https://www.luogu.com.cn/problem/P5427)**：计算每个1到最近0的距离。  
2. **[P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)**：多源扩散标记边界。  
3. **[P2897 [USACO08JAN]Lakes](https://www.luogu.com.cn/problem/P2897)**：统计连通块面积。  

---

### **代码实现（多源BFS）**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};
struct Node { int x, y, t; };

int main() {
    int n, m, a, b; 
    cin >> n >> m >> a >> b;
    vector<vector<int>> dist(n+1, vector<int>(m+1, -1));
    queue<Node> q;
    
    // 感染源入队
    while (a--) {
        int x, y; cin >> x >> y;
        q.push({x, y, 0});
        dist[x][y] = 0;
    }
    
    // BFS扩散
    while (!q.empty()) {
        auto [x, y, t] = q.front(); q.pop();
        for (int i = 0; i < 4; ++i) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && dist[nx][ny] == -1) {
                dist[nx][ny] = t + 1;
                q.push({nx, ny, t + 1});
            }
        }
    }
    
    // 输出领主时间
    while (b--) {
        int x, y; cin >> x >> y;
        cout << dist[x][y] << endl;
    }
    return 0;
}
```

---

### **可视化代码片段（Canvas动画）**
```javascript
// 初始化画布和颜色映射
const canvas = document.getElementById('grid');
const ctx = canvas.getContext('2d');
const colors = ['#FF0000', '#FFA500', '#FFFF00', '#00FF00']; // 红→橙→黄→绿

function drawGrid(dist) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            const color = dist[i][j] === -1 ? '#808080' : colors[Math.min(dist[i][j], 3)];
            ctx.fillStyle = color;
            ctx.fillRect(j * 16, i * 16, 15, 15);
        }
    }
}
```

---

**总结**：多源BFS是本题的最优解，兼顾效率和正确性；暴力解法适合快速通过小数据，但需注意数据范围。可视化设计可帮助直观理解扩散过程，复古风格增强学习趣味性。

---
处理用时：94.99秒
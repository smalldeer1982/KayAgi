# 题目信息

# 漂亮字串

## 题目描述

Caima 认为 $\tt O$ 和 $\tt X$ 是最优美的两个字母，由 $\tt O,X$ 组成的串是最优美的串。在这些最优美的串中，如果任意只包含 $\tt X$ 的子串，长度不超过 $\max_{\tt X}$，任意只包含 $\tt O$ 的子串，长度不超过 $\max_{\tt O}$，而整个串最多有 $\rm count_{\tt O}$ 个 $\tt O$，$\rm count_{\tt X}$ 个 $\tt X$。那么这个就是超级优美无敌串。

现在 Caima 想知道最长的超级优美无敌串有多长，希望你告诉他。

## 说明/提示

### 样例 2 解释

- $\tt XOXOXOX$。


### 数据范围及约定

最多 $1000$ 组数据，

其中 $30\%$ 的数据 $0\le \rm count_{\tt O},\rm count_{\tt X},\rm max_{\tt O},\rm max_{\tt X} \le 20$，且数据组数不超过 $20$ 组。

对于全部数据，$0 \le \rm count_{\tt O},\rm count_{\tt X},\rm max_{\tt O},\rm max_{\tt X}\le 10^6$。

## 样例 #1

### 输入

```
10 10 0 0

3 5 1 1

```

### 输出

```
0

7

```

# AI分析结果



---

## 算法分类
**贪心算法**

---

## 题解思路、算法要点与解决难点

### 核心思路
题目要求构造最长的由 `O` 和 `X` 组成的字符串，满足以下条件：
1. 连续 `O` 的子串长度不超过 `maxo`，连续 `X` 的子串长度不超过 `maxx`。
2. `O` 和 `X` 的总数分别不超过 `counto` 和 `countx`。

通过贪心策略分情况讨论：
1. **某一字符无法使用**（`maxo` 或 `maxx` 为 0）：此时只能使用另一字符，取 `count` 和 `max` 的最小值。
2. **一方数量不足以分割对方**：例如 `X` 的数量过多，无法用 `O` 分隔，此时 `X` 的总使用量被限制为 `(counto+1)*maxx`，总长度为该值加上 `counto`。
3. **其他情况**：双方数量足够交替分割，总长度为 `counto + countx`。

### 解决难点
1. **边界条件处理**：当 `maxo` 或 `maxx` 为 0 时，需直接处理。
2. **数学推导条件**：正确判断某一方是否不足以分割对方的逻辑是关键。例如，需推导出当 `(countx+1)*maxo < counto` 时，`X` 无法完全分割 `O`。
3. **变量交换优化**：部分题解通过交换变量简化条件判断，确保 `counto >= countx`，从而减少代码分支。

---

## 题解评分 (≥4星)

### 题解1（ex_jason）：★★★★★
- **亮点**：代码简洁，逻辑清晰，正确处理所有边界条件和数学推导。
- **代码可读性**：高，无冗余步骤。
- **核心代码**：
  ```cpp
  maxo = min(counto, maxo);
  maxx = min(countx, maxx);
  if (maxo == 0) cout << maxx;
  else if (maxx == 0) cout << maxo;
  else if ((counto+1)*maxx < countx) cout << (counto+1)*maxx + counto;
  else if ((countx+1)*maxo < counto) cout << (countx+1)*maxo + countx;
  else cout << counto + countx;
  ```

### 题解2（王奕瑜）：★★★★☆
- **亮点**：详细注释和数学推导，强调贪心思路。
- **代码可读性**：高，变量命名清晰。
- **核心代码**：
  ```cpp
  mxo = min(mxo, cnto);
  mxx = min(mxx, cntx);
  if (mxo == 0) printf("%lld\n", mxx);
  else if (mxx == 0) printf("%lld\n", mxo);
  else if ((cnto+1)*mxx < cntx) printf("%lld\n", (cnto+1)*mxx + cnto);
  else if ((cntx+1)*mxo < cnto) printf("%lld\n", (cntx+1)*mxo + cntx);
  else printf("%lld\n", cnto + cntx);
  ```

### 题解3（Erotate）：★★★★☆
- **亮点**：条件判断简化为统一形式，逻辑紧凑。
- **代码可读性**：高，使用 `min` 函数处理边界。
- **核心代码**：
  ```cpp
  if (!(min(co, mo))) cout << min(cx, mx);
  else if (!(min(cx, mx))) cout << min(co, mo);
  else if (cx > mx*(co+1)) cout << mx*(co+1)+co;
  else if (co > mo*(cx+1)) cout << mo*(cx+1)+cx;
  else cout << cx+co;
  ```

---

## 最优思路或技巧提炼
1. **变量交换简化条件**：将 `counto` 和 `countx` 按大小排序，减少条件分支。
2. **数学公式推导**：通过 `(counto+1)*maxx` 判断对方是否无法分割当前字符。
3. **边界处理优化**：直接取 `maxo = min(counto, maxo)`，避免后续重复判断。

---

## 同类型题或类似算法套路
- **类似题目**：构造满足交替条件的字符串（如 [LeetCode 984. String Without AAA or BBB](https://leetcode.com/problems/string-without-aaa-or-bbbb/)）。
- **通用解法**：通过贪心策略，优先放置数量多的字符，同时用对方字符分割。

---

## 推荐相似题目
1. [P6109 [Ynoi2009] rprmq1](https://www.luogu.com.cn/problem/P6109)（区间操作与贪心）
2. [P1365 WJMZBMR打osu! / Easy](https://www.luogu.com.cn/problem/P1365)（字符串构造与动态规划）
3. [P1494 小明的游戏](https://www.luogu.com.cn/problem/P1494)（贪心与数学分析）

---

## 可视化与算法演示

### 动画方案
1. **像素风格动态构造**：用不同颜色方块表示 `O` 和 `X`，逐步生成字符串。
2. **关键步骤高亮**：
   - 当进入条件分支时，显示对应条件公式。
   - 每个字符段的长度用进度条表示，超过 `max` 值时触发警告动画。
3. **交互控制**：允许用户调整 `counto`、`countx`、`maxo`、`maxx` 参数，实时查看构造结果。

### 复古游戏化设计
- **8位音效**：放置字符时播放“哔”声，条件满足时播放胜利音效。
- **积分系统**：根据构造的字符串长度得分，超过历史最高分时触发特效。
- **自动演示模式**：AI 按最优策略逐步放置字符，展示贪心过程。

---

## 代码片段（核心逻辑）
```cpp
#include <iostream>
using namespace std;
int main() {
    long long counto, countx, maxo, maxx;
    while (cin >> counto >> countx >> maxo >> maxx) {
        maxo = min(counto, maxo);
        maxx = min(countx, maxx);
        if (maxo == 0) cout << maxx << endl;
        else if (maxx == 0) cout << maxo << endl;
        else if ((counto + 1) * maxx < countx) cout << (counto + 1) * maxx + counto << endl;
        else if ((countx + 1) * maxo < counto) cout << (countx + 1) * maxo + countx << endl;
        else cout << counto + countx << endl;
    }
    return 0;
}
```

---
处理用时：313.02秒
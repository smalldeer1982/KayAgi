# 题目信息

# 突击考试

## 题目描述

一日，老师决定进行一次突击考试。已知每个学生都有一个考试能力等级，教室里一共有 $N$ 个课桌，按照顺序排成一列，每张课桌可以坐两个人，第 $i$ 张课桌坐的两个人的能力等级为$A_i,B_i$。现在老师决定对能力等级为 $K$ 的人进行测验。他会从这 $N$ 排中选择连续的 $L$ 排进行测验，要求这 $L$ 排中的每一排至少有一个人考试能力等级为 $K$。现在我们想知道 $L$ 的最大值以及对应的等级 $K$。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N \le 100,000$，$1 \le A[i],B[i] \le 5$。

## 样例 #1

### 输入

```
3
3 5
4 5
1 3
```

### 输出

```
2 5```

# AI分析结果



**唯一算法分类**：模拟

---

### **综合分析与结论**

**题目核心**：在连续排列的课桌中，找出最长的连续段（L），使得每排至少一人能力等级为 K，并求 L 的最大值及对应的最小 K。

**解决思路**：
1. **枚举法**：遍历每个等级 K（1~5），统计每个 K 的最长连续段。时间复杂度 O(5N)，适用于等级范围小的情况。
2. **递推法**：动态维护每个等级在当前排的连续长度，每处理一排更新对应等级的连续段，并同步更新全局最大值。

**难点与解决**：
- **连续段统计**：需正确处理末尾未中断的连续段（如最后一排满足条件时需额外检查）。
- **等级选择**：若多个等级的 L 相同，取最小的 K。

**可视化设计**：
- **枚举法动画**：对每个等级 K，遍历时高亮满足条件的排，连续计数器动态增长，断点时更新最大值。
- **递推法动画**：每排处理时展示两个等级（x, y）的连续长度更新，并比较全局最大值的变化。
- **复古像素效果**：用 8-bit 风格显示课桌网格，绿色高亮满足条件的排，红色标记断点，音效提示连续段增长和最大值更新。

---

### **题解清单 (≥4星)**

1. **lgxt 题解（5星）**
   - **亮点**：清晰枚举每个等级，逐排统计连续段，正确处理末尾边界。
   - **代码片段**：
     ```cpp
     for (int i=1; i<=5; i++) {
         int ans=0, x=0;
         for (int o=0; o<n; o++) {
             if (s[o][0]==i || s[o][1]==i) x++;
             else {
                 ans = max(ans, x);
                 x = 0;
             }
         }
         ans = max(ans, x); // 处理末尾连续段
         t[i] = ans;
     }
     ```

2. **_ZZH 题解（4星）**
   - **亮点**：递推维护每个等级连续长度，即时更新最大值。
   - **代码片段**：
     ```cpp
     for (int i=1; i<=n; i++) {
         int x, y;
         scanf("%d%d", &x, &y);
         f[i][x] = f[i-1][x] + 1;
         f[i][y] = f[i-1][y] + 1;
         // 更新当前最大值及对应 K
     }
     ```

3. **听取MLE声一片 题解（4星）**
   - **亮点**：优化暴力法为线性遍历，强调末尾检查。
   - **关键点**：`return max(s, p)` 避免遗漏最后一段。

---

### **最优思路提炼**

**核心技巧**：
- **枚举等级**：因等级范围有限（1~5），直接枚举每个 K 统计最长连续段。
- **单次遍历统计**：对每个 K，遍历所有排，维护连续计数器，断点重置。
- **边界处理**：循环结束后需再次比较以处理末尾未中断的连续段。

**代码实现**：
```cpp
int maxL = 0, bestK = 1;
for (int k = 1; k <= 5; k++) {
    int current = 0, maxCurrent = 0;
    for (int i = 0; i < n; i++) {
        if (A[i] == k || B[i] == k) current++;
        else {
            maxCurrent = max(maxCurrent, current);
            current = 0;
        }
    }
    maxCurrent = max(maxCurrent, current); // 关键：处理末尾
    if (maxCurrent > maxL) {
        maxL = maxCurrent;
        bestK = k;
    }
}
```

---

### **相似题目推荐**

1. **洛谷 P1719**：最大加权矩形（二维连续子矩阵和）。
2. **洛谷 P3406**：海底高铁（区间覆盖统计）。
3. **洛谷 P1147**：连续自然数和（滑动窗口求连续段）。

---

### **个人心得摘录**

- **听取MLE声一片**：末尾检查不可少，否则漏判最后一段。
- **lgxt**：等级范围小，直接枚举比复杂算法更高效。
- **_ZZH**：递推法需注意同一排两个等级的状态更新冲突。

---

### **可视化与算法演示**

**动画方案**：
1. **像素网格**：每排课桌显示为两格，绿色表示含当前等级 K，红色为其他。
2. **连续段标记**：黄色高亮当前连续段，计数器动态增长。
3. **音效反馈**：
   - 连续段增长时播放“哔”声。
   - 断点时播放“咔嚓”声，最大值更新时播放上升音调。
4. **交互控制**：步进按钮调整速度，下拉菜单切换算法（枚举/递推）。

**复古风格**：
- **8-bit 字体**：显示当前等级、连续长度、最大值。
- **背景音乐**：循环播放低比特率 Chiptune，增强沉浸感。

---
处理用时：134.35秒
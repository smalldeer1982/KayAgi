# 题目信息

# 帮贡排序

## 题目背景

在 absi2011 的帮派里，死号偏多。现在 absi2011 和帮主等人联合决定，要清除一些死号，加进一些新号，同时还要鼓励帮贡多的人，对帮派进行一番休整。


## 题目描述

目前帮派内共最多有一位帮主，两位副帮主，两位护法，四位长老，七位堂主，二十五名精英，帮众若干。

现在 absi2011 要对帮派内几乎所有人的职位全部调整一番。他发现这是个很难的事情。于是要求你帮他调整。

他给你每个人的以下数据：

他的名字（长度不会超过 $30$），他的原来职位，他的帮贡，他的等级。

他要给帮贡最多的护法的职位，其次长老，以此类推。

可是，乐斗的显示并不按帮贡排序而按职位和等级排序。

他要你求出最后乐斗显示的列表(在他调整过职位后)：职位第一关键字，等级第二关键字。

注意：absi2011 无权调整帮主、副帮主的职位，包括他自己的（这不是废话么..）

他按原来的顺序给你（所以，等级相同的，原来靠前的现在也要靠前，因为经验高低的原因，但此处为了简单点省去经验。）


## 说明/提示

各种职位用汉语拼音代替。

如果职位剩 $1$ 个，而有 $2$ 个帮贡相同的人，则选择原来在前的现在当选此职位。

另：
帮派名号：星月家园

帮主尊号：Dragonfly Kang

帮派ID：2685023

帮派等级：4

帮派人数：101/110

帮派技能：

星月家园资料，欢迎各位豆油加入^\_^

【数据范围】

对于 $10\%$ 的数据，保证 $n=3$。

对于 $40\%$ 的数据，保证各个人的帮贡均为 $0$。

对于 $100\%$ 的数据，保证 $3\leq n\leq 110$，各个名字长度$\leq30$，$0\leq$ 各个人的帮贡 $\leq1000000000$，
$1\leq$ 各个人等级 $\leq 150$。

保证职位必定为 $\texttt{BangZhu}$，$\texttt{FuBangZhu}$，$\texttt{HuFa}$，$\texttt{ZhangLao}$，$\texttt{TangZhu}$，$\texttt{JingYing}$，$\texttt{BangZhong}$ 之中的一个

保证有一名帮主，保证有两名副帮主，保证有一名副帮主叫 absi2011

不保证一开始帮派里所有职位都是满人的，但排序后分配职务请先分配高级职位。例如原来设一名护法现在设两名。

保证名字不重复。

【题目来源】

fight.pet.qq.com


absi2011 授权题目


## 样例 #1

### 输入

```
9

DrangonflyKang BangZhu 100000 66

RenZaiJiangHu FuBangZhu 80000 60

absi2011 FuBangZhu 90000 60

BingQiLingDeYanLei HuFa 89000 58

Lcey HuFa 30000 49

BangYou3 ZhangLao 1000 1

BangYou1 TangZhu 100 40

BangYou2 JingYing 40000 10

BangYou4 BangZhong 400 1```

### 输出

```
DrangonflyKang BangZhu 66

RenZaiJiangHu FuBangZhu 60

absi2011 FuBangZhu 60

BingQiLingDeYanLei HuFa 58

BangYou2 HuFa 10

Lcey ZhangLao 49

BangYou1 ZhangLao 40

BangYou3 ZhangLao 1

BangYou4 ZhangLao 1```

# AI分析结果



**算法分类**  
排序、模拟

**题解思路与核心难点**  
本题的核心在于两次排序与职位分配的逻辑处理。关键难点在于正确处理帮主和副帮主的职位不变，其他成员按帮贡排序后分配职位，最终按职位和等级排序输出。各题解通过以下方法解决：  
1. **第一次排序**：将帮主和副帮主的帮贡设为极大值，确保其自然排在前列；其他成员按帮贡降序和输入顺序排序。  
2. **职位分配**：按排序后的顺序填充护法、长老等职位名额。  
3. **第二次排序**：合并所有成员后，按职位优先级、等级降序、输入顺序排序。  

**题解评分（≥4星）**  
1. **翼德天尊（4星）**：代码清晰，两次排序逻辑明确。但假设帮主和副帮主输入在前三位，可能不适用所有情况。  
2. **_Qer（5星）**：巧妙利用极大值确保帮主和副帮主排序正确，职位分配逻辑严谨，代码简洁高效。  
3. **Hexarhy（4星）**：使用Lambda表达式简化排序，处理帮贡极大值的逻辑正确，但部分代码可读性略低。  

**最优思路提炼**  
1. **帮主和副帮主处理**：将他们的帮贡设为极大值（如`LLONG_MAX`），确保排序后自然排在前列，无需手动调整位置。  
2. **两次排序**：首次按帮贡排序分配职位，第二次按职位、等级、输入顺序排序输出。  
3. **输入顺序保留**：结构体中记录原始输入序号，确保等级相同时按原顺序排列。  

**关键代码片段**  
```cpp
// 第一次排序：帮主和副帮主帮贡设为极大值，其他按帮贡降序排序
for (int i = 1; i <= n; ++i) {
    if (arr[i].work == "BangZhu") arr[i].help = LLONG_MAX;
    else if (arr[i].work == "FuBangZhu") arr[i].help = LLONG_MAX - 1;
}
sort(arr + 1, arr + n + 1, [](const Person& a, const Person& b) {
    return a.help != b.help ? a.help > b.help : a.input_order < b.input_order;
});

// 职位分配：前三位固定为帮主和副帮主，其他按顺序分配
vector<int> limits = {1, 3, 5, 9, 16, 41, INT_MAX};
for (int i = 1; i <= n; ++i) {
    for (int j = 0; j < limits.size(); ++j) {
        if (i <= limits[j]) {
            arr[i].new_work = work_names[j];
            break;
        }
    }
}

// 第二次排序：按职位、等级、输入顺序
sort(arr + 1, arr + n + 1, [](const Person& a, const Person& b) {
    if (a.new_work != b.new_work) return priority[a.new_work] < priority[b.new_work];
    if (a.level != b.level) return a.level > b.level;
    return a.input_order < b.input_order;
});
```

**可视化设计要点**  
1. **像素动画**：用不同颜色方块表示职位，帮主（红色）、副帮主（橙色）、护法（黄色）等。  
2. **排序过程**：第一次排序时，其他成员的方块按帮贡大小动态调整位置；第二次排序时，全体成员按职位和等级重新排列。  
3. **音效**：关键操作（排序、职位分配）触发8位音效，背景音乐为复古芯片音乐。  

**同类型题目推荐**  
1. P1786 帮贡排序（本题）  
2. P1051 谁拿了最多奖学金（多关键字排序）  
3. P1309 瑞士轮（分阶段排序与合并）  

**个人心得**  
- **输入顺序的重要性**：若未记录原始序号，等级相同时的输出顺序会出错。  
- **测试极端数据**：例如帮贡极大或全为0的情况，验证代码鲁棒性。  

**复古游戏化动画示例（伪代码）**  
```javascript
// Canvas绘制成员方块，颜色表示职位
function drawMember(member, x, y) {
    ctx.fillStyle = getColor(member.work);
    ctx.fillRect(x, y, 30, 30); // 30x30像素方块
    ctx.fillText(member.name, x + 5, y + 15);
}

// 排序动画：比较两个成员的帮贡，交换位置
function animateSortStep(a, b) {
    playSound('swap'); // 播放交换音效
    // 动态移动方块位置...
}
``` 

通过上述分析，本题的核心在于灵活处理两次排序与职位分配，确保逻辑严谨且代码高效。

---
处理用时：353.54秒
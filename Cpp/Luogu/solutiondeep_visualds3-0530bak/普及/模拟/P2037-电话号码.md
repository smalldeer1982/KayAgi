# 题目信息

# 电话号码

## 题目描述

一串由长长的数字组成的电话号码通常很难记忆。为了方便记忆，有种方法是用单词来方便记忆。例如用 `Three Tens` 来记忆电话 `3-10-10-10`。

电话号码的标准形式是七位数字，中间用连字号分成前三个和后四个数字（例如：`888-1200`）。电话号码可以用字母来表示。以下是字母与数字的对应：

 - `A`，`B` 和 `C` 对应 `2`；
 - `D`，`E` 和 `F` 对应 `3`；
 - `G`，`H` 和 `I` 对应 `4`；
 - `J`，`K` 和 `L` 对应 `5`；
 - `M`，`N` 和 `O` 对应 `6`；
 - `P`，`R` 和 `S` 对应 `7`；
 - `T`，`U` 和 `V` 对应 `8`；
 - `W`，`X` 和 `Y` 对应 `9`。

你会发现其中没有字母 `Q` 和 `Z`。电话中的连字号是可以忽略。例如 `TUT-GLOP` 的标准形式是 `888-4567`，`310-GINO` 的标准形式是 `310-4466`，`3-10-10-10` 的标准形式是 `310-1010`。

如果两个电话号码的标准形式是一样的，那么这两个电话号码就是一样的。

现在有一本电话簿，请从中找出哪些电话号码是重复的。


## 说明/提示

【数据范围】

对于 $30\%$ 的数据，$N\le20$。

对于 $50\%$ 的数据，$N\le10000$。

对于 $100\%$ 的数据，$N\le10^5$。


## 样例 #1

### 输入

```
3

TUT-GLOP

3-10-10-10

310-1010

```

### 输出

```
310-1010 2```

# AI分析结果



---

**唯一算法分类**：哈希映射

---

### **题解思路与算法要点**

1. **核心逻辑**：将电话号码统一转换为7位数字格式，统计各号码出现次数。关键在于高效转换与统计重复。
2. **解决难点**：
   - **字母转换**：利用预定义的字母-数字映射表快速转换。
   - **格式统一**：忽略连字符并补零，确保7位长度。
   - **高效统计**：使用哈希表（`map`/七维数组/Trie）存储出现次数。

---

### **题解评分（≥4星）**

1. **tututu题解（★★★★☆）**
   - **亮点**：简洁的排序+遍历法，预处理字母映射数组，直接排序后统计相邻重复。
   - **优化点**：使用`substr`处理格式输出，代码可读性强。

2. **飞了的心题解（★★★★☆）**
   - **亮点**：七维数组直接统计，时间复杂度O(n)，空间换时间。
   - **实现技巧**：通过`a[ss+10000000]++`避免前导零问题。

3. **Nemonade题解（★★★★★）**
   - **亮点**：Trie树存储电话号码，高效压缩空间，适合大数据量。
   - **代码片段**：通过7层树结构统计出现次数，输出时DFS遍历。

---

### **最优思路与技巧**

1. **Trie树**（最优）：
   - **优势**：空间效率高，时间复杂度稳定O(n)。
   - **代码片段**：
     ```cpp
     for(int j=0;j<7;j++) {
         idx = s[j] - '0';
         if (!nex[p][idx]) nex[p][idx] = ++tot;
         p = nex[p][idx];
     }
     siz[p]++;  // 统计次数
     ```

2. **七维数组法**：
   - **技巧**：电话号码转为整数索引，直接数组计数。
   - **适用场景**：数据量大但位数固定（如7位电话）。

3. **排序法**：
   - **关键点**：转换后排序，相邻相同即为重复，输出时处理格式。

---

### **同类型题与算法套路**

- **相似题目**：
  1. **P3370**（字符串哈希统计重复）
  2. **P1102**（统计数对频率）
  3. **P1918**（保龄球编号查询，哈希映射）

---

### **可视化与算法演示**

**动画设计**：
1. **转换过程**：显示输入字符串逐步转换为数字，如`TUT-GLOP`→`8884567`。
2. **统计步骤**：用像素方块表示七维数组或Trie节点，计数时方块高亮。
3. **复古效果**：
   - **像素风格**：电话数字以8-bit字体显示，转换时播放“哔”音效。
   - **Canvas动画**：Trie树节点扩展时绘制连线，重复计数时闪烁红色。

**交互设计**：
- **步进控制**：单步执行转换与统计，观察Trie树构建过程。
- **音效触发**：字母转换时播放按键音，重复发现时播放胜利音效。

---

### **推荐题解代码（Trie树实现）**

```cpp
#include <cstdio>
int nex[700010][10], siz[700010], tot; // Trie节点与计数数组

void insert(char* s) {
    int p = 0;
    for (int i = 0; s[i]; i++) {
        int idx = s[i] - '0';
        if (!nex[p][idx]) nex[p][idx] = ++tot;
        p = nex[p][idx];
    }
    siz[p]++;
}

void dfs(int p, int dep, int* path) {
    if (dep == 7) {
        if (siz[p] > 1) {  // 输出重复号码
            printf("%d%d%d-%d%d%d%d %d\n", path[0], path[1], ..., siz[p]);
        }
        return;
    }
    for (int i = 0; i < 10; i++) {
        if (nex[p][i]) {
            path[dep] = i;
            dfs(nex[p][i], dep+1, path);
        }
    }
}
```

---

**总结**：优先选择Trie或七维数组法处理大数据，排序法适合代码简洁的场景。可视化通过像素动画和音效增强理解。

---
处理用时：75.99秒
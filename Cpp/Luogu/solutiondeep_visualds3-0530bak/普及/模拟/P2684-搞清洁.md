# 题目信息

# 搞清洁

## 题目描述

FJ准备分配它的N只奶牛(1 <= N <= 25,000) 做清洁工作，他把一天分成T(1 <= T <= 1,000,000)个时间段，他希望每一个时间段都有奶牛在清洁，但搞清洁的奶牛数越少越好。


## 说明/提示

样例解释：

有3头奶牛，第1头能工作的时间段是1至7，即从时间1开始工作，时间7结束（时间7也在工作的），第2头是3-6，第3头是8-10，则只需要第1头和第3头奶牛就能使每一个时间都有奶牛工作。


## 样例 #1

### 输入

```
3 10
1 7
3 6
8 10
```

### 输出

```
2

```

# AI分析结果



### 唯一算法分类
贪心算法

---

### 综合分析与结论
**核心思路**：将区间按左端点排序后，每次选择能覆盖当前末端且右端点最大的区间，直至覆盖整个时间轴。  
**解决难点**：  
1. 处理区间重叠与连续覆盖的衔接  
2. 证明贪心策略的最优性（局部最优延伸至全局最优）  
**算法流程**：  
1. 按左端点升序、右端点降序排序  
2. 维护当前覆盖末端`end`，每次在左端点≤`end+1`的区间中选右端点最大的  
3. 更新`end`并计数，直到覆盖目标时间轴  

**可视化设计**：  
- **动画方案**：时间轴上用绿色块表示已覆盖区域，红色指针扫描候选区间，选中时高亮为金色，播放"选择音效"  
- **像素风格**：8-bit 时间轴网格，奶牛区间用不同色块表示，伴随经典 FC 音效  
- **交互功能**：可调节扫描速度，单步执行观察`end`更新逻辑  

---

### 题解清单（≥4星）
1. **木木！（5星）**  
   - 亮点：排序后单次扫描，代码简洁高效，时间复杂度 O(n log n)  
   - 关键代码：`if (si[i].l > lr) lr = mnlr+1` 处理区间衔接  

2. **PTC06（4星）**  
   - 亮点：预处理每个时间点的最大右端点，直接跳跃式扫描  
   - 心得："数组定义不够大导致 RE" 提醒数据规模意识  

3. **苏黎世（4星）**  
   - 亮点：清晰注释 + 超级终点技巧，处理边界条件严谨  
   - 代码片段：`a[n+1].l=t+1` 确保最终覆盖检查  

---

### 核心代码实现
**木木！题解关键逻辑**：
```cpp
sort(si+1,si+1+n,cmp);
int lr = 1, mnlr = 0, ans = 0;
for (int i=1; i<=n+1; ++i) {
    if (si[i].l > lr) { // 需要切换新区间
        lr = mnlr + 1;
        if (si[i].l > lr) { ans = -1; break; } // 无法衔接
        mnlr = si[i].r;
        ans++;
    } else mnlr = max(mnlr, si[i].r); // 更新最远覆盖
}
```

---

### 相似题目推荐
1. **P1514 引水入城** - 区间覆盖+贪心判断  
2. **P1803 线段覆盖** - 最大不相交区间数  
3. **P2887 防晒霜** - 贪心策略应用变形  

---

### 可视化代码片段（Canvas动画）
```javascript
// 绘制时间轴与区间
function drawTimeline() {
  ctx.fillStyle = "#2C3E50"; // 背景色
  ctx.fillRect(0, 0, canvas.width, 50);
  
  // 绘制已覆盖区域（绿色）
  ctx.fillStyle = "#2ECC71";
  ctx.fillRect(0, 20, (currentEnd/T)*canvas.width, 10);
  
  // 绘制所有区间（蓝色边框）
  intervals.forEach(({start, end}, i) => {
    ctx.strokeStyle = "#3498DB";
    ctx.strokeRect((start/T)*canvas.width, 25, ((end-start)/T)*canvas.width, 5);
  });
  
  // 高亮当前扫描区间（金色）
  if(currentIndex >=0) {
    ctx.fillStyle = "#F1C40F";
    ctx.fillRect((intervals[currentIndex].start/T)*canvas.width, 25, 
                 ((intervals[currentIndex].end-intervals[currentIndex].start)/T)*canvas.width, 5);
  }
}
```

---

### 像素化交互设计
- **颜色方案**：NES 经典 16 色调色板（深蓝背景/绿覆盖区/金选中区）  
- **音效触发**：  
  - `beep(440, 50)` 扫描新区间  
  - `beep(880, 100)` 成功选中区间  
  - `beep(220, 200)` 覆盖失败  
- **自动演示**：通过 setInterval 控制扫描步进速度，支持暂停/继续  

---

**关键学习点**：贪心策略在区间问题中常通过排序+最值选择实现，预处理和边界处理是代码健壮性的核心。

---
处理用时：80.53秒
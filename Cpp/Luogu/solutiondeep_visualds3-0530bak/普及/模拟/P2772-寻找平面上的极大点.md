# 题目信息

# 寻找平面上的极大点

## 题目描述

在一个平面上，如果有两个点(x,y),(a,b),如果说(x,y)支配了(a,b)，这是指x>=a,y>=b;

用图形来看就是(a,b)坐落在以(x,y)为右上角的一个无限的区域内。

给定n个点的集合，一定存在若干个点，它们不会被集合中的任何一点所支配，这些点叫做极大值点。

编程找出所有的极大点，按照x坐标由小到大，输出极大点的坐标。


## 说明/提示

对于50%的数据：1≤N≤100；0≤X,Y≤100000；

对于100%的数据：1≤N≤50,0000；0≤X,Y≤100000


## 样例 #1

### 输入

```
5 
1 2 2 2 3 1 2 3 1 4```

### 输出

```
(1,4),(2,3),(3,1)```

# AI分析结果



### 唯一算法分类
贪心 + 排序

---

### 综合分析与结论
#### 核心思路
所有题解均基于贪心思想，核心策略是**通过排序预处理消除某一维度的限制**，再通过线性扫描维护极值。两种主流实现路径：
1. **按Y降序排序**：当Y降序排列时，只需维护最大的X值，后续点的X必须比当前极大点的X更大才可能成为极大点
2. **预处理X最大Y值**：对每个X坐标保留最大Y值后，从右向左扫描维护Y最大值

#### 算法流程可视化设计
1. **排序法动画**：
   - 步骤1：将点按Y从高到低、X从大到小排列，形成瀑布流式下降的Y坐标
   - 步骤2：用红色光柱标记当前最大X值，绿色箭头扫描每个点
   - 步骤3：当扫描到X大于红柱的点时，触发闪光特效并记录为极大点，同时红柱伸长

2. **预处理法动画**：
   - 步骤1：在X轴上用不同高度色块表示每个X对应的最大Y值
   - 步骤2：从右向左滑动扫描线，维护紫色渐变的最大Y值区域
   - 步骤3：当当前色块突破紫色区域时，触发粒子特效标记为极大点

---

### 题解清单（≥4星）
1. **shiningrise（5星）**
   - 核心：Y降序排序 + X极值维护
   - 亮点：代码简洁高效，时间复杂度O(n log n)，完美处理输出顺序

2. Mr_QwQ（4星）
   - 核心：X升序排序 + 反向Y极值扫描
   - 亮点：直观体现极大点的空间分布特征，需注意X相同时的特殊处理

3. 山羊之神（4星）
   - 核心：预处理X最大Y值 + 右向左扫描
   - 亮点：时间复杂度O(n + max_x)，空间换时间的典范，适合大数据量

---

### 最优思路代码实现
**预处理法核心代码**：
```cpp
int max_x = 0, max_y[100005] = {0};
// 预处理每个X的最大Y
for(int i=0; i<n; i++) {
    int x, y;
    cin >> x >> y;
    max_y[x] = max(max_y[x], y);
    max_x = max(max_x, x);
}

// 右向左扫描维护极值
vector<pair<int,int>> res;
int cur_max = -1;
for(int x = max_x; x >= 0; x--) {
    if(max_y[x] > cur_max) {
        res.emplace_back(x, max_y[x]);
        cur_max = max_y[x];
    }
}

// 反向输出
reverse(res.begin(), res.end());
```

---

### 相似题目推荐
1. P1908 逆序对（排序策略应用）
2. P1631 序列合并（极值维护技巧）
3. P2947 [USACO09MAR]Look Up（单调栈思想）

---

### 可视化实现要点（像素风格）
1. **Canvas绘制**：
   - 坐标系网格：16x16像素格子，淡灰色（#C0C0C0）
   - 点显示：8x8像素方块，Y轴映射为高度，颜色渐变（蓝→红表示Y值）
   
2. **音效设计**：
   - 发现极大点：8位上升音阶（0x1F3B5）
   - 更新极值：电子脉冲音（0x1F4A5）
   - 背景音乐：FC经典《超级玛丽》地下关BGM循环

3. **交互控制**：
   ```javascript
   const controls = {
     speed: 100, // 毫秒/步
     play: () => animate(algorithmSteps),
     pause: () => cancelAnimationFrame(animId),
     step: () => renderStep(currentStep++),
     setSpeed: (newSpeed) => speed = 200 - newSpeed*2
   };
   ```

---

**注**：预处理法在X范围可控时（如本题X≤1e5）效率最优，排序法则具有更好的通用性。实际应用中可根据数据特征灵活选择。

---
处理用时：137.06秒
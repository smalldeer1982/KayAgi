# 题目信息

# IPv6地址压缩

## 题目背景

（友情提示：IPv6 基础知识曾多次出现在 NOIP 初赛中）Internet Protocol，互联网协议，即为我们常说的 IP。我们目前常说的 IP 主要指它的第四版，即 IPv4，它由 IETF 于 1981 年发布。它的地址长度是 $32$ 个二进制位，因此也就有 $2^{32}$ 个 IP 地址可供使用，约为 $43$ 亿，在当时，谁也没有料想到 IPv4 如此庞大的地址长度会有用完的一天。

在 21 世纪的今天，互联网的蓬勃发展早就了我们如今便利的生活。当下，世界人口已超过 70 亿，计算机和各种联网设备已经走入千家万户，而不再仅是上个世纪 80 年代科学家们的工具。此时便出现了人们日益增长的联网设备需要同落后 IPv4 地址长度之间的矛盾。尽管可以通过网络地址翻译能技术来共享 IP 地址，临时解决枯竭的问题，但显然不是长久之计。

IETF 也有先见之明，早早地于 1998 年发布了 IPv6 协议，从微软 2006 年发布的 Windows Vista 开始成为默认安装的网络协议。作为 IPv4 的继任者，它的地址长度为 $128$ 个二进制位，也就是 $2^{128}$ 个IP地址可供使用。然而面对这冗长的地址，一位记忆力不好的网络工程师小明在配置路由表时遇到了许许多多多的困难，现在他找到了你，希望你帮忙编写一个程序来按照 IPv6 地址标准的格式压缩规则来压缩 IPv6 地址。

## 题目描述

**【IPv6 格式】**

IPv6 二进位制下为 $128$ 位长度，以 $16$ 位为一组，每组以冒号“`:`”隔开，可以分为 $8$ 组，每组以 $4$ 位十六进制方式表示。

比如 `2001:0db8:0000:0000:0123:4567:89ab:cdef` 是一个合法的 IPv6 地址。

同时 IPv6 地址在某些条件下可以压缩：

1. 每组数字代表的独立十六进制数可以省略前位的 `0`。

比如上面的 IPv6 地址可被压缩为 `2001:db8:0:0:123:4567:89ab:cdef`。

2. 可以用双冒号 `::` 表示一组 `0` 或多组连续的 `0`，但只能出现一次。

比如上面的 IPv6 地址可被压缩为 `2001:db8::123:4567:89ab:cdef`。

请你帮助记忆力不好的网络工程师小明解决他遇到的问题。

**【规则补充】**

1. 输入数据为完全展开的 IPv6 地址，确保输入的 IPv6 地址不含双冒号，每组地址省略的 `0` 都会被补充上去。

2. 双冒号只能使用一次，因此我们压缩最长的全 `0` 组。

比如 `2001:0db8:0000:0000:1:0000:0000:0000`，压缩为 `2001:db8:0:0:1::`，而非 `2001:db8::1:0:0:0`。

3. 双冒号只能使用一次，因此我们在我们遇到地址中多个连续全 `0` 组长度相同时，我们压缩最前面的一个。

比如 `2001:0db8:0000:0000:ffff:0000:0000:1`，压缩为 `2001:db8::ffff:0:0:1`，而非 `2001:db8:0:0:ffff::1`。

4. 输入的 IPv6 地址可能无法被压缩，此时请照原样输出。

提示：本题所示的压缩规则与 macOS (Darwin) 默认的 IPv6 地址显示方式相同，而 Windows 和 Linux 只遇到一组全 `0` 时不会使用 `::` 进行压缩。但用此方法压缩过的 IPv6 地址一样可以被 Windows 和 Linux 正确识别。

比如 `2001:0db8:ffff:0000:0123:4567:89ab:cdef`，Darwin 压缩为 `2001:db8:ffff::123:4567:89ab:cdef`，而 Linux 和 Windows 压缩为 `2001:db8:ffff:0:123:4567:89ab:cdef`。

## 样例 #1

### 输入

```
2406:0840:f990:0000:0000:0000:0000:0001```

### 输出

```
2406:840:f990::1```

## 样例 #2

### 输入

```
2a13:1801:018a:00cf:0100:0000:0000:0000```

### 输出

```
2a13:1801:18a:cf:100::```

## 样例 #3

### 输入

```
2001:4860:4860:0000:0000:0000:0000:8888```

### 输出

```
2001:4860:4860::8888```

## 样例 #4

### 输入

```
2001:0db8:0000:0000:0000:0000:0000:0001```

### 输出

```
2001:db8::1```

## 样例 #5

### 输入

```
0000:0000:0000:0000:0000:0000:0000:0000```

### 输出

```
::```

## 样例 #6

### 输入

```
0000:0000:0000:0000:0000:0000:0000:0001```

### 输出

```
::1```

## 样例 #7

### 输入

```
2001:0db8:ffff:0000:0123:4567:89ab:cdef```

### 输出

```
2001:db8:ffff::123:4567:89ab:cdef```

## 样例 #8

### 输入

```
1234:5678:9abc:def0:1234:5678:9abc:def0```

### 输出

```
1234:5678:9abc:def0:1234:5678:9abc:def0```

## 样例 #9

### 输入

```
0001:0000:0000:0000:0000:0000:0000:0001```

### 输出

```
1::1```

## 样例 #10

### 输入

```
0000:0000:0000:0000:0000:0000:0001:0002```

### 输出

```
::1:2```

# AI分析结果



**算法分类**  
模拟

---

### **题解思路、算法要点与解决难点**

**核心思路**  
IPv6地址压缩的核心在于两步：
1. **省略前导零**：每组4位十六进制数去掉前导零，但保留至少一个字符。
2. **最长连续零组替换**：找到最长的连续全零组（长度相同时取最左侧的），替换为双冒号 `::`。

**解决难点**  
1. **最长零组的识别**：需要遍历所有组，记录连续零组的起始位置和长度。遇到多个相同长度的零组时，优先选择第一个出现的。
2. **输出格式控制**：正确处理双冒号的位置（如开头、中间或结尾），避免多余的冒号，并确保每组正确连接。

**关键变量与步骤**  
- **最长零组标记**：通过遍历各组，记录连续零组的起始位置 `maxi` 和长度 `maxn`。
- **前导零处理**：对每组跳过前导零字符，保留至少一个字符。
- **双冒号替换**：在输出时跳过最长零组的位置，直接插入 `::`。

---

### **题解评分与推荐**

1. **RocksonLee（4.5星）**  
   - 亮点：直接处理字符串，逻辑清晰。通过遍历每组字符判断零组，记录最长连续零组。
   - 代码可读性高，正确处理了双冒号的位置和前导零省略。
   - [代码片段](#rocksonlee-code)

2. **_Ayanami_（4星）**  
   - 亮点：将每组转换为字符串处理，简化前导零逻辑。通过标记最长零组位置替换为 `::`。
   - 代码简洁，但需注意字符串操作细节。  
   - [代码片段](#ayanami-code)

3. **xujian（4星）**  
   - 亮点：使用 `scanf` 按十六进制读取数值，直接判断全零组。通过数值操作简化零组识别。
   - 代码高效，但需确保输入格式正确。  
   - [代码片段](#xujian-code)

---

### **最优思路提炼**

1. **最长零组查找**  
   - 遍历各组，记录连续零组的起始位置和长度。若长度相同，优先保留最左侧。
   - **代码示例**：
     ```cpp
     for (int i1=0,t=0; i1<8; i1++) {
         if (当前组全零) t++;
         else t=0;
         if (t > maxn) 更新maxn和maxi;
     }
     ```

2. **前导零处理**  
   - 每组跳过前导零字符，保留至少一个字符（全零则保留一个0）。
   - **代码示例**：
     ```cpp
     i2=0;
     while (a[i1*5+i2] == '0' && i2 <3) i2++; // 跳过前导零
     ```

3. **双冒号替换**  
   - 在最长零组的位置插入 `::`，并跳过后面的零组。
   - **代码示例**：
     ```cpp
     if (i1 == maxi_start) {
         cout << "::";
         i1 += maxn; // 跳过后面的零组
     }
     ```

---

### **同类型题与类似算法**

- **相似题目**  
  - **洛谷 P1012 [拼数](https://www.luogu.com.cn/problem/P1012)**：字符串处理与排序。
  - **洛谷 P1308 [统计单词数](https://www.luogu.com.cn/problem/P1308)**：字符串匹配与位置记录。
  - **LeetCode 468. Validate IP Address**：IP地址格式验证。

---

### **可视化算法设计**

**动画演示**  
1. **输入拆分**：将输入的IPv6地址拆分为8组，每组高亮显示。
2. **最长零组标记**：红色框标出最长连续零组，动态更新长度和位置。
3. **前导零处理**：每组逐个跳过前导零，保留字符变为绿色。
4. **双冒号替换**：红色框的零组被替换为 `::`，其他组按处理后的形式连接。

**复古像素风格**  
- **颜色方案**：使用8位风格调色板（如红、绿、灰）。
- **音效触发**：找到最长零组时播放上扬音效，替换为 `::` 时播放成功音效。
- **交互控制**：支持步进执行，观察每组处理过程。

---

### **核心代码实现**

#### **RocksonLee 的代码片段**  
```cpp
void find() {
    int maxn = 0, maxi = -1, t = 0;
    for (int i = 0; i < 8; i++) {
        bool is_zero = true;
        for (int j = 0; j < 4; j++) {
            if (a[i*5 + j] != '0') { is_zero = false; break; }
        }
        if (is_zero) {
            t++;
            if (t > maxn) { maxn = t; maxi = i; }
        } else t = 0;
    }
    maxi = maxi - maxn + 1; // 计算起始位置
}
```

#### **_Ayanami_ 的代码片段**  
```cpp
for (int i = 0; i < 8; i++) {
    if (i == max_start && max_len > 0) {
        cout << "::";
        i += max_len - 1;
    } else {
        cout << s[i];
        if (i != 7) cout << ":";
    }
}
```

#### **xujian 的代码片段**  
```cpp
for (int i=1; i<=8; i++) {
    if (s[i] == 0) sum++;
    // ... 统计连续零组
}
for (int i=1; i<=8; i++) {
    if (i == km) { printf("::"); i = em; }
    else printf("%x:", s[i]);
}
```

---
处理用时：193.05秒
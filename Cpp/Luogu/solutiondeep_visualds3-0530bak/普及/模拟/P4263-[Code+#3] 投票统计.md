# 题目信息

# [Code+#3] 投票统计

## 题目描述

为了总结过去一段时间的命题工作，王队长组织了“我最喜欢的题目”评选活动，并邀请各位选手给题目进行投票。

具体来说，每道题目有一个正整数作为它的编号，一共有 $n$ 名选手给它们进行投票，每位选手投且仅投给一道题，其中第 $i$ 位选手所投票的题目编号为 $a_i$。

由于投票的选手众多，所以王队长请你来帮忙统计得票数。你需要找出收获选手投票最多的**题目数量**与**他们的编号**，并按**从小到大**的顺序列出这些编号。但这里有一个**例外情况**：如果所有被投票的题目得票数都相同，则王队长认为这次活动比较失败，你应该**输出-1**。



## 说明/提示

测试点编号|$n$的范围|$a_i$的范围|特殊约定
-|-|-|-
1|$=2000$|$\leq n$|得票数最多的题目唯一
2|同上|同上|同上
3|同上|$\leq 10^9$|同上
4|同上|$\leq n$|不会出现例外情况
5|同上|同上|同上
6|同上|$\leq 10^9$|同上
7|同上|$\leq n$|无
8|同上|同上|同上
9|同上|$\leq 10^9$|同上
10|同上|同上|同上
11|$=100000$|$\leq n$|得票数最多的题目唯一
12|同上|同上|同上
13|同上|$\leq 10^9$|同上
14|同上|$\leq n$|不会出现例外情况
15|同上|同上|同上
16|同上|$\leq 10^9$|同上
17|同上|$\leq n$|无
18|同上|同上|同上
19|同上|$\leq 10^9$|同上
20|同上|同上|同上

Credit： https://www.luogu.org/discuss/show?postid=35727

## 样例 #1

### 输入

```
3
10
2 6 1 2 1 1 2 6 7 1
10
10 3 6 6 3 10 6 6 6 2
10
8 8 10 10 10 10 8 5 8 8```

### 输出

```
1
1
1
6
1
8```

## 样例 #2

### 输入

```
3
10
1 4 3 1 8 8 7 2 8 7
10
1 10 9 1 3 2 9 9 2 1
10
4 1 5 4 1 9 5 5 4 1```

### 输出

```
1
8
2
1 9
3
1 4 5```

## 样例 #3

### 输入

```
3
10
3 3 10 8 8 3 10 8 10 3
10
2 2 8 6 8 4 2 4 4 8
10
6 2 5 6 7 5 7 10 2 10```

### 输出

```
1
3
3
2 4 8
-1
```

# AI分析结果



---

## 算法分类
排序 + 线性遍历统计

---

## 题解分析

### 核心难点
1. **大数值范围**：a_i ≤ 1e9，无法用数组桶排
2. **高效统计**：需在 O(n) 或 O(n log n) 时间复杂度内完成频率统计
3. **边界处理**：遍历排序数组时需正确处理连续元素的分界
4. **特殊判断**：所有数字出现次数相同时输出 -1

### 关键思路对比
| 题解方法       | 核心数据结构 | 时间复杂度 | 空间复杂度 | 特殊判断方式               |
|----------------|--------------|------------|------------|----------------------------|
| 排序 + 双遍历  | 数组         | O(n log n) | O(n)       | 比较最大频率数种类与总种类 |
| map 统计       | map          | O(n log n) | O(n)       | 统计不同频率数量           |
| 排序 + 单遍历  | 数组         | O(n log n) | O(n)       | 动态维护不同频率数         |

### 最优思路提炼
1. **排序后线性遍历**：通过排序使相同元素相邻，一次遍历统计频率
2. **动态维护最大值**：
   - 当前频率 > 最大值：清空结果集，更新最大值
   - 当前频率 == 最大值：加入结果集
3. **特殊判断**：总种类数 == 最大频率数种类时输出 -1

---

## 题解评分 (≥4星)
1. **Kalium (4.5★)**  
   - 亮点：单次遍历动态维护结果集，逻辑清晰
   - 优化点：合并两次遍历为一次可提升效率

2. **Khassar (4★)**  
   - 亮点：巧妙使用 `a[n+1] = 0` 简化边界处理
   - 注意点：需二次遍历收集结果

3. **Eason_AC (4★)**  
   - 亮点：map 实现简洁易懂，适合快速开发
   - 限制：map 查询效率略低于排序方案

---

## 核心代码实现
```cpp
// 排序后单次遍历统计（Kalium 优化版）
sort(a, a+n);
vector<int> ans;
int max_cnt = 0, cur_cnt = 1, type_cnt = 0;

for(int i=1; i<=n; ++i) { // 包含虚拟尾元素
    if(a[i] == a[i-1]) cur_cnt++;
    else {
        if(cur_cnt > max_cnt) {
            max_cnt = cur_cnt;
            ans.clear();
            ans.push_back(a[i-1]);
        } else if(cur_cnt == max_cnt) {
            ans.push_back(a[i-1]);
        }
        type_cnt++;  // 统计总种类
        cur_cnt = 1;
    }
}

// 特殊判断
if(ans.size() == type_cnt) cout << -1;
else {
    sort(ans.begin(), ans.end());
    // 输出结果
}
```

---

## 可视化设计
### 动画方案
1. **排序过程**：展示元素逐渐有序化的过程，用不同颜色区分不同数值
2. **统计阶段**：
   - **高亮当前元素块**（黄色边框）
   - **计数器动态增长**：当前连续相同元素数量（右侧数字动态+1）
   - **最大值更新特效**：当超过历史最大值时，触发红色闪烁动画
3. **结果收集**：
   - 每次加入结果集时，底部结果栏同步显示新元素
   - 最终结果排序时展示元素位置交换动画

### 复古游戏化要素
```javascript
// 伪代码示例
class VoteVisualizer {
    constructor(data) {
        this.pixelSize = 16; // 8-bit风格像素块大小
        this.colors = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4"]; // FC风格配色
    }

    renderSortStep() {
        // 在Canvas上绘制排序过程的像素块移动动画
    }

    playSound(effect) {
        // 使用Web Audio API播放8-bit音效：
        // - 元素移动: 短促"滴"声
        // - 最大值更新: 上滑音阶
        // - 结果确认: 经典FC过关音效
    }
}
```

---

## 相似题目推荐
1. **P1177 快速排序** - 排序基础应用
2. **P1059 明明的随机数** - 排序+去重
3. **P1308 统计单词数** - 线性遍历统计

---

## 关键调试经验
1. **虚拟尾元素技巧**：在数组末尾添加哨兵元素，避免循环结束后再处理最后一组数据
2. **类型数统计**：必须在每次遇到新元素时增加计数器，而非在初始化时统计
3. **结果排序**：最终输出前需对结果进行排序以满足题目要求

---

通过综合排序方案与动态维护结果集的思路，该解法在时间效率与代码可读性之间取得了良好平衡，配合游戏化可视化设计，可帮助学习者直观理解统计型问题的核心解决模式。

---
处理用时：77.93秒
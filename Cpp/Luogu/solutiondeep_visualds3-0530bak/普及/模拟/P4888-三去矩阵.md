# 题目信息

# 三去矩阵

## 题目背景

无

## 题目描述

现在小Y有个$l \times l$的正方形字母矩阵，现在他想进行$q$次询问，每次询问最长的以$(x_i,y_i)$为中心的在一条水平或竖直的直线上的回文串的长度。

## 说明/提示

对于$20\%$的数据，$1 \le l \le 2$

另有$20\%$的数据，$q = 1$

另有$20\%$的数据，字母矩阵中心对称，上下对称，左右对称且对角线对称。

对于$100\%$的数据，$1 \le l,q \le 2000$，字母只有小写字母。

## 样例 #1

### 输入

```
5 5
abcba
bcdcb
cdedc
bcdcb
abcba
1 1
1 2
1 3
2 3
3 3```

### 输出

```
1
1
5
5
5
```

# AI分析结果



### 算法分类
**模拟/中心扩展法**

### 题解思路与解决难点
1. **核心思路**：对每个查询点分别向左右（横向）和上下（纵向）扩展，比较字符是否相等，直到不匹配或越界，记录最长回文长度。
2. **关键变量**：
   - `x`和`y`为查询点坐标。
   - `left`和`right`记录横向扩展的左右边界。
   - `up`和`down`记录纵向扩展的上下边界。
3. **时间复杂度**：最坏情况下为 O(q*l)，但实际数据中扩展次数较少，可通过优化边界条件（如提前终止循环）提升效率。

### 题解评分（≥4星）
1. **Clear_yu的题解（4.5星）**
   - **亮点**：代码简洁，直接通过循环扩展，逻辑清晰。
   - **代码片段**：
     ```cpp
     while(x-sum>0&&x+sum<=l) {
         if(a[sum+x][y]!=a[x-sum][y]) break;
         sum++; ans1+=2;
     }
     ```

2. **散华礼弥的题解（4星）**
   - **亮点**：使用Manacher算法预处理，时间复杂度低（O(n²)），但实现复杂。
   - **代码片段**：
     ```cpp
     void Manacher(int x) {
         Init(x);
         int right = 0, cur;
         for (int i = 1; i < len; ++i) {
             if (i < right)
                 p[x][i] = min(p[x][(cur << 1) - i], p[x][cur] + cur - i);
             // ... 核心逻辑 ...
         }
     }
     ```

3. **Rbrq的题解（4星）**
   - **亮点**：优化边界判断，减少无效循环次数。
   - **代码片段**：
     ```cpp
     int dx = min(x-1, l-x);
     for(int k=1; k<=dx; k++)
         if(num[x-k][y] == num[x+k][y]) maxn = 2*k+1;
     ```

---

### 最优思路与技巧
1. **双指针扩展**：用两个指针分别向左右或上下扩展，直到不匹配或越界。
2. **边界优化**：提前计算最大可扩展次数（如`min(x-1, l-x)`），减少循环次数。
3. **预处理优化**：对每行/列应用Manacher算法，将每次查询时间降为O(1)。

---

### 同类题目推荐
1. **P1219 回文检测**（简单模拟）
2. **P5 最长回文子串**（Manacher算法应用）
3. **P1659 最长双回文串**（扩展回文处理）

---

### 个人心得摘录
- **冬瓜皮**：“第一次提交用了`getchar()`读数据导致错误，改用`cin`后通过。”（输入方式需谨慎）
- **散华礼弥**：“Manacher预处理虽复杂，但能显著降低查询时间。”（权衡实现复杂度与效率）

---

### 可视化算法演示
**核心动画设计**：
1. **网格绘制**：用Canvas绘制l×l网格，每个格子显示字符。
2. **扩展过程**：
   - 横向扩展：左右指针用红色标记，每次比较后绿色标记匹配成功的区域。
   - 纵向扩展：上下指针用蓝色标记，匹配区域用黄色填充。
3. **交互控制**：
   - **速度调节**：滑动条控制动画速度（0.5x~3x）。
   - **步进模式**：逐帧展示扩展过程，按空格键单步执行。
   - **音效**：匹配成功时播放“叮”声，失败时播放“咔”声。

**复古像素风格**：
- **8位调色板**：使用NES经典颜色（#6B6B6B背景，#FF0000指针，#00FF00匹配区）。
- **音效生成**：用Web Audio API生成8-bit音效，匹配时播放短促方波。

---

### 核心代码实现
```cpp
// Clear_yu的暴力解法（关键部分）
int dfs(int x, int y) {
    int sum1 = 1, sum2 = 1;
    // 横向扩展
    for (int i = 1; x - i >= 1 && x + i <= l; i++) {
        if (a[x-i][y] != a[x+i][y]) break;
        sum1 += 2;
    }
    // 纵向扩展
    for (int i = 1; y - i >= 1 && y + i <= l; i++) {
        if (a[x][y-i] != a[x][y+i]) break;
        sum2 += 2;
    }
    return max(sum1, sum2);
}
```

---
处理用时：128.33秒
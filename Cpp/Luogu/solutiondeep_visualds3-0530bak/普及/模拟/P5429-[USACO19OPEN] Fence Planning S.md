# 题目信息

# [USACO19OPEN] Fence Planning S

## 题目描述

Farmer John 的 $ N $ 头奶牛，编号为 $ 1 \ldots N $ （ $ 2 \leq N \leq 10^5 $ ），拥有一种围绕“哞网”，一些仅在组内互相交流却不与其他组进行交流的奶牛小组，组成的复杂的社交网络。

每头奶牛位于农场的二维地图上的不同位置 $ (x,y) $ ，并且我们知道有 $ M $ 对奶牛( $ 1 \leq M<10^5 $ )会相互哞叫。两头相互哞叫的奶牛属于同一哞网。

为了升级他的农场，Farmer John 想要建造一个四边与 $ x $ 轴和 $ y $ 轴平行的长方形围栏。Farmer John 想要使得至少一个哞网完全被围栏所包围（在长方形边界上的奶牛计为被包围的）。请帮助 Farmer John 求出满足他的要求的围栏的最小可能周长。有可能出现这一围栏宽为 $0$ 或高为 $0$ 的情况。

## 样例 #1

### 输入

```
7 5
0 5
10 5
5 0
5 10
6 7
8 6
8 4
1 2
2 3
3 4
5 6
7 6```

### 输出

```
10```

# AI分析结果



**唯一算法分类**：图论（连通块处理）

---

### **题解思路与算法要点**

1. **核心问题**  
   寻找所有连通块的最小包围矩形周长，关键在于快速确定每个连通块的坐标极值（min_x, max_x, min_y, max_y）。

2. **算法对比**  
   - **DFS/BFS**：遍历每个连通块，动态更新极值。时间复杂度 O(N+M)，需显式建图。
   - **并查集**：合并时维护极值，路径压缩优化后接近线性时间，无需显式建图。

3. **解决难点**  
   - **动态维护极值**：DFS在遍历时直接更新；并查集通过合并操作比较父子集合的极值。
   - **空间优化**：并查集仅需维护每个集合的极值，DFS需要邻接表存储全图。

---

### **题解评分（≥4星）**

1. **Mkarry（DFS）** ★★★★  
   - **亮点**：代码简洁，注释清晰，时间复杂度分析到位。  
   - **缺点**：递归DFS可能栈溢出（N=1e5时需改为迭代）。

2. **微芒晨曦（并查集）** ★★★★☆  
   - **亮点**：双次路径压缩确保极值合并正确，代码可读性高。  
   - **关键代码**：`check(i)`函数遍历所有节点更新根极值。

3. **purinliang（并查集）** ★★★★  
   - **亮点**：合并时实时更新极值，无需二次遍历，空间效率更优。  
   - **关键代码**：合并操作中的极值合并逻辑 `u[fx]=max(u[fx],u[fy])`。

---

### **最优思路提炼**

- **并查集极值维护**  
  合并两个集合时，直接比较并更新父节点的极值，最终每个根节点存储完整极值信息。  
  ```cpp
  void union_set(int x, int y) {
      int fx = find(x), fy = find(y);
      if (fx != fy) {
          fa[fy] = fx;
          max_x[fx] = max(max_x[fx], max_x[fy]);
          min_x[fx] = min(min_x[fx], min_x[fy]);
          // 同理处理y坐标
      }
  }
  ```

---

### **同类型题与算法套路**

- **通用解法**  
  连通块极值问题可统一用并查集维护动态属性，如极值、总和、平均值等。
  
- **类似题目**  
  1. [P1197 [JSOI2008] 星球大战](https://www.luogu.com.cn/problem/P1197)  
  2. [P2330 [SCOI2005] 繁忙的都市](https://www.luogu.com.cn/problem/P2330)  
  3. [P1455 搭配购买](https://www.luogu.com.cn/problem/P1455)

---

### **可视化与算法演示**

**动画设计**：  
1. **并查集合并过程**  
   - **颜色标记**：当前合并的两个节点高亮为黄色，合并后的根节点变为红色。  
   - **极值更新**：用动态文本框展示合并前后的极值变化。  
   - **像素风格**：奶牛用8x8像素点表示，连通块边界用闪烁的红色边框逐步扩展。

2. **音效与交互**  
   - **合并音效**：8-bit "哔"声，音调随合并次数升高。  
   - **自动演示**：按空格键切换手动/自动模式，速度滑块控制动画步频。

**Canvas伪代码**：  
```javascript
function drawBlock(block) {
    ctx.fillStyle = block.color;
    block.points.forEach(p => {
        ctx.fillRect(p.x*10, p.y*10, 8, 8); // 缩放坐标便于显示
    });
    ctx.strokeStyle = "red";
    ctx.strokeRect(min_x*10, min_y*10, (max_x-min_x)*10, (max_y-min_y)*10);
}
```

---

### **个人心得摘录**

- **微芒晨曦**：  
  > “初始化极值为0x3f3f3f3f时，坐标可能为负数导致错误。改为初始化为第一个节点的坐标解决。”  
  - **教训**：极值初始化需考虑数据范围，避免预设值不匹配实际数据。

---

### **代码实现（关键片段）**

**并查集极值合并（purinliang）**  
```cpp
bool union_set(int x,int y) {
    int fx=find_par(x), fy=find_par(y);
    if(fx==fy) return false;
    par[fy]=fx;
    u[fx]=max(u[fx],u[fy]); // 合并y最大值
    d[fx]=min(d[fx],d[fy]); // 合并y最小值
    l[fx]=min(l[fx],l[fy]); // 合并x最小值
    r[fx]=max(r[fx],r[fy]); // 合并x最大值
    return true;
}
```

---

**结论**：并查集在动态维护连通块属性时具有天然优势，结合极值合并逻辑可高效解决本类问题。DFS/BFS适用于静态全图遍历，但需注意递归深度限制。

---
处理用时：92.75秒
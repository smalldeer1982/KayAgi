# 题目信息

# [CSGRound3] 斗牛

## 题目背景

又是一年过去了。小 Z 在春节期间可以好好的放松放松，于是小 Z 和小伙伴们玩起了牛哄哄（斗牛）。

游戏规则是这样的：

给定 $5$ 张牌，分别从 $1 \sim 10$。你需要挑选其中的三张牌加起来是 $10$ 的倍数，另外两张牌的和的个位数则为你最后获得的点数，特别的，如果这两张牌的和是 $10$ 的倍数，则点数为 $10$，也叫做牛哄哄。如果不能构成 $10$ 的倍数，则点数为 $0$，也叫做牛不拢。

如 $5$ $3$ $2$ $3$ $4$ 的点数是 $7$，又叫做牛七。

小 Z 觉得玩的不过瘾，于是对上述规则进行了一些改变。

## 题目描述

给定 $n$ 张牌，牌的大小为 $1 \sim 10$。你需要挑选其中的 $n-2$ 张牌加起来是 $10$ 的倍数，另外两张牌和的个位数即为你所获得的点数。特别地，如果这两张牌的和是 $10$ 的倍数，则点数为 $10$，也叫做牛哄哄。如果任意 $n-2$ 张牌不能构成 $10$ 的倍数，则点数为 $0$，也叫做牛不拢。

由于小 Z 想要更开心的玩耍，所以需要你来完成这个程序来帮助小 Z 在 $1$ 秒内知道点数。

## 说明/提示

**【样例 1 解释】**

$10$ $10$ $10$ 三张牌凑成 $10$ 的倍数，$2+3=5$。

**【样例 2 解释】**

任意三张牌都不能凑成 $10$ 的倍数。

---

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（50 points）：$n = 5$。
- Subtask 2（30 points）：$n \le 5 \times 10^3$。
- Subtask 3（20 points）：无特殊限制。

对于 $100\%$ 的数据，$5 \le n \le 10^6$。



## 样例 #1

### 输入

```
5
10 10 10 2 3```

### 输出

```
5```

## 样例 #2

### 输入

```
5
3 4 5 6 7```

### 输出

```
0```

# AI分析结果



# 算法分类  
**数学/桶计数**

---

## 题解思路、算法要点与解决难点  

### 核心逻辑推导  
所有题解均基于以下核心推导：  
1. 所有牌的总和 S，其个位数 t = S % 10 即为最终可能的点数（若存在解）  
2. 问题转化为：是否存在两个数 x, y，使得 (x + y) ≡ t (mod 10)  
3. 若存在，则答案为 t（t=0 时为 10）；否则输出 0  

### 关键数据结构  
- **桶数组**：统计每个余数（0~9）出现的次数，例如 `a[i]` 表示余数为 i 的牌数量  

### 实现差异对比  
| 题解特点                     | wpy233                                                     | StudyingFather                                           | fls233666                                               |  
|------------------------------|-----------------------------------------------------------|---------------------------------------------------------|---------------------------------------------------------|  
| **判断方式**                 | 穷举所有可能的余数组合（如 t=7 时判断 0&7、1&6 等）        | 双重循环枚举余数组合                                     | 双重循环枚举具体牌值（1~10）                             |  
| **时间复杂度**               | O(1)（固定条件判断）                                      | O(10²)（余数组合枚举）                                  | O(10²)（牌值组合枚举）                                   |  
| **代码复杂度**               | 高（需为每个 t 编写独立条件）                             | 低（统一循环处理）                                       | 中（需处理牌值到余数的映射）                             |  
| **处理相同元素**             | 通过条件判断（如 `a[i]>=2`）                              | 通过 `i == j` 判断是否重复                               | 通过 `i == j` 判断是否重复                               |  

---

## 题解评分 (≥4星)  

### 1. StudyingFather（⭐⭐⭐⭐⭐）  
- **思路清晰度**：直接枚举余数组合，逻辑简洁  
- **可读性**：代码结构清晰，双重循环易理解  
- **优化程度**：O(10²) 时间复杂度，适用于所有数据范围  
- **关键代码**：  
  ```cpp  
  for(int i=0;i<=9;i++) 
    for(int j=i+1;j<=9;j++) 
      if(t[i]&&t[j]&&(i+j)%10==ans) { ... }  
  ```

### 2. wpy233（⭐⭐⭐⭐）  
- **思路清晰度**：穷举所有余数组合，直观展示数学关系  
- **优化程度**：O(1) 判断，但代码冗长  
- **实践性**：适合快速理解各余数组合的对应关系  

### 3. fls233666（⭐⭐⭐⭐）  
- **可读性**：通过枚举具体牌值（1~10）实现，更贴近题目描述  
- **优化程度**：O(10²) 时间复杂度，逻辑与数据范围解耦  

---

## 最优思路或技巧提炼  
1. **数学转化**：将原问题转化为两个数的余数组合判断问题  
2. **桶计数优化**：用桶数组代替原始数据，将时间复杂度从 O(n²) 降至 O(1) 或 O(10²)  
3. **同余处理**：利用 `(sum - x - y) % 10 == 0 ⟺ (x + y) % 10 == sum % 10` 简化计算  

---

## 同类型题或类似算法套路  
- **数对和问题**：如两数之和、三数之和等，通过哈希表或桶计数优化枚举  
- **模运算应用**：如求特定余数组合的最优解（[LeetCode 974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)）  

---

## 推荐相似题目  
1. [P2671 求和](https://www.luogu.com.cn/problem/P2671)（桶计数 + 数学公式优化）  
2. [P1614 爱与愁的心痛](https://www.luogu.com.cn/problem/P1614)（滑动窗口求最小子数组和）  
3. [P1147 连续自然数和](https://www.luogu.com.cn/problem/P1147)（数学推导 + 前缀和）  

---

## 个人心得摘录  
- **wpy233**：通过样例解释发现 10 与 0 的等效性，避免冗余判断  
- **judgejudge**：调试中发现相同元素需单独处理（如 `i == j` 时需至少两个相同元素）  

---

## 可视化与算法演示  

### 核心算法流程  
1. **初始化桶数组**：将牌值映射到余数桶（0~9）  
2. **计算总和余数 t**：`t = sum % 10`  
3. **枚举余数组合**：检查是否存在 (i, j) 使得 `(i + j) % 10 == t`  
4. **结果反馈**：找到匹配则高亮对应桶，否则显示失败  

### 复古像素化演示设计  
```html  
<canvas id="pixelCanvas"></canvas>  
<script>  
// 初始化 Canvas，10x10 网格表示余数 0~9  
function drawBucket(bucket) {  
  ctx.clearRect(0, 0, 200, 200);  
  for(let i=0; i<10; i++) {  
    const x = (i % 5) * 40, y = Math.floor(i/5) * 40;  
    ctx.fillStyle = bucket[i] > 0 ? "#FF5555" : "#555555"; // 高亮非空桶  
    ctx.fillRect(x, y, 35, 35);  
    ctx.fillStyle = "#FFFFFF";  
    ctx.fillText(`余数 ${i}`, x+5, y+20);  
  }  
}  
</script>  
```  

### 音效设计  
- **关键操作**：枚举余数时播放 8-bit "blip" 音效  
- **成功匹配**：播放上升音阶（C4→E4→G4）  
- **失败**：播放低频噪音  

---

## 核心代码片段（StudyingFather 题解）  
```cpp  
int main() {  
  int n, ans = 0;  
  cin >> n;  
  int t[10] = {0}; // 余数桶  
  for (int i = 1; i <= n; i++) {  
    int x;  
    cin >> x;  
    t[x % 10]++;  
    ans = (ans + x) % 10; // 实时计算总和余数  
  }  
  // 枚举不同余数组合  
  for (int i = 0; i <= 9; i++) {  
    for (int j = i + 1; j <= 9; j++) {  
      if (t[i] && t[j] && (i + j) % 10 == ans) {  
        cout << (!ans ? 10 : ans);  
        return 0;  
      }  
    }  
  }  
  // 检查相同元素  
  for (int i = 0; i <= 9; i++) {  
    if (t[i] >= 2 && (i + i) % 10 == ans) {  
      cout << (!ans ? 10 : ans);  
      return 0;  
    }  
  }  
  cout << 0;  
}  
```

---
处理用时：98.75秒
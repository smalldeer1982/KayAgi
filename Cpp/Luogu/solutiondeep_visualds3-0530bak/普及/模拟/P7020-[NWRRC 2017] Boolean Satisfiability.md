# 题目信息

# [NWRRC 2017] Boolean Satisfiability

## 题目描述

布尔可满足性问题（SAT）在计算机科学中被认为是一个非常困难的问题。在这个问题中，给定一个布尔公式，你需要判断该公式的变量是否可以被一致地替换为真或假，使得公式的结果为真。SAT 是已知的 NP 完全问题。此外，即使在 $3-CNF$ 公式（$3-SAT$）的情况下，它也是 NP 完全的。然而，例如，对于 $2-CNF$ 公式（$2-SAT$）的 SAT 问题是在 $P$ 中的。

$#SAT$ 是 SAT 问题的扩展。在这个问题中，你需要检查是否可能，并计算赋值给变量的方式的数量。这个问题即使对于 $2-CNF$ 公式也是已知的 $#P$ 完全问题。我们要求你解决 $#1-DNF-SAT$，这是 $1-DNF$ 公式的 $#SAT$ 问题。

你被给定一个 $1-DNF$ 形式的布尔公式。这意味着它是一个或多个子句的析取（逻辑或），每个子句正好是一个文字，每个文字要么是变量，要么是它的否定（逻辑非）。

形式化地：

$\langle \text{formula} \rangle ::= \langle \text{clause} \rangle \ | \ \langle \text{formula} \rangle \lor \langle \text{clause} \rangle$

$\langle \text{clause} \rangle ::= \langle \text{literal} \rangle$

$\langle \text{literal} \rangle ::= \langle \text{variable} \rangle \ | \ 
eg \langle \text{variable} \rangle$

$\langle \text{variable} \rangle ::= A \ldots Z \ | \ a \ldots z$

你的任务是找到将所有变量替换为真和假（同一变量的所有出现应替换为相同的值）的方法的数量，使得公式的结果为真。

## 说明/提示

时间限制：3 秒，内存限制：512 MB。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
a
```

### 输出

```
1
```

## 样例 #2

### 输入

```
B|~B
```

### 输出

```
2
```

## 样例 #3

### 输入

```
c|~C
```

### 输出

```
3
```

## 样例 #4

### 输入

```
i|c|p|c
```

### 输出

```
7
```

# AI分析结果



**唯一算法分类**  
数学/组合数学

**综合分析与结论**  
本题的核心在于识别1-DNF公式的结构特点，并利用组合数学快速计算满足条件的赋值方式数目。关键点在于：

1. **公式结构分析**  
   1-DNF为多个单文字子句的析取，若存在任一子句为真则整体为真。由此得出：
   - 当某变量x与其否定¬x同时出现时，公式恒为真（共2^n种可能）
   - 否则总方案数为2^n -1（排除所有子句为假的情况）

2. **实现难点**  
   - **变量提取**：需正确解析输入中的变量及其否定形式。通过将公式按`|`分割为子句，每个子句首字符判断是否为`~`，可避免逐字符处理的越界风险。
   - **冲突检测**：使用两个集合分别记录原形和否定变量，遍历所有变量检测交集。

3. **可视化设计**  
   采用像素风格动态演示公式解析过程：
   - **动画步骤**：分解公式为子句，高亮当前处理的子句，弹出变量标记到原形/否定集合。
   - **冲突检测**：当某变量同时出现在两个集合时，触发闪光特效并播放成功音效。
   - **结果展示**：以8-bit风格显示2^n或2^n-1的计算过程，伴随经典FC游戏的计分音效。

**题解清单 (≥4星)**  
1. **Error_Eric（5星）**  
   - 亮点：Python实现简洁，通过split处理子句避免越界错误，代码可读性强。
   - 关键片段：  
     ```python
     v = split(s, '|')
     for i in v:
         i[0]=='~' ? neg.add(i[1]) : pos.add(i[0])
     ```
     
2. **Karry5307（4星）**  
   - 亮点：C++使用bitset高效存储变量状态，逻辑清晰。
   - 关键逻辑：  
     ```cpp
     for(auto i:split_clauses)
         i[0]=='~' ? neg.set(var) : pos.set(var);
     ```

3. **Flaw_Owl（4星）**  
   - 亮点：使用双数组分别存储大小写变量，处理全面。
   - 核心代码：  
     ```cpp
     if(word[0][i] && word[1][i]) flag=true; // 检测冲突
     ```

**最优思路与技巧**  
- **子句分割法**：将公式按`|`拆分为子句，避免逐字符处理的边界问题。
- **集合运算**：利用集合的交集检测变量冲突，时间复杂度O(n)。
- **位运算优化**：直接计算2^n，避免循环累乘。

**同类型题套路**  
- **布尔表达式分析**：如[CF1569D](https://codeforces.com/problemset/problem/1569/D)中处理逻辑表达式结构。
- **组合计数问题**：类似[P3197 越狱](https://www.luogu.com.cn/problem/P3197)的补集思想。

**推荐题目**  
1. P1495 曹冲养猪（中国剩余定理）
2. P1226 快速幂（位运算优化）
3. P1029 最大公约数与最小公倍数问题（因数分解）

**个人心得摘录**  
> "处理公式时拆分子句比逐字符扫描更可靠，能有效避免索引越界问题。" —— Error_Eric  
> "变量冲突检测使用集合交集，代码简洁高效。" —— Karry5307

**可视化代码片段（伪代码）**  
```javascript
// 像素动画核心逻辑
function parseFormula(s) {
  let clauses = s.split('|');
  clauses.forEach(clause => {
    let type = clause.startsWith('~') ? 'neg' : 'pos';
    let var = type === 'neg' ? clause[1] : clause[0];
    // 高亮当前子句，更新对应变量集合
    drawPixelVar(var, type); 
  });
  if (checkConflict()) playSound('success'); 
}
```

---
处理用时：209.28秒
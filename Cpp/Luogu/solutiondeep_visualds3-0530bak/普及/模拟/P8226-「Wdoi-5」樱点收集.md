# 题目信息

# 「Wdoi-5」樱点收集

## 题目背景

119 季 5 月，明明本应是樱花盛开的春天，幻想乡却依然下着大雪。异变的主谋**西行寺幽幽子**在古书上看到，只要使妖樱西行妖满开便会有什么人复活，便出于兴趣命令妖梦收集幻想乡中的春度，一手策划成了这场异变。在收集春度的过程中散落的能量在西行妖的影响下化为**樱点**，散落在幻想乡各处。

出发解决**春雪异变**的灵梦将前往冥界旅途划分为了若干段，每一段都可以收集到一定的樱点。收集齐一定程度的樱点，就会立即开出樱之结界。开出樱之结界后可以短暂地屏蔽一切攻击，并且获得相应的增益。

但是樱之结界何时开放仅由樱点的收集情况所决定，她不得不对樱点进行「规划」。通过某些途径规避某一段路上樱点的收集，借此使得在将来的某几段路程里，灵梦得以恰好在该段的末尾开放樱之结界。  

但是现实往往不尽人意。也就是说，可能有某些要求无法达成。灵梦希望找出一个方案，使得她可以达成的要求最多。灵梦委托八云紫帮忙决策，于是这个重任就被一条懒紫交给了式神八云蓝。尽管八云蓝擅长计算，但是八云紫睡觉去了没有给她编程，因而现在这个任务就落到了你的手上。

## 题目描述

灵梦当前拥有的樱点可以使用一个**变量** $c$ 存储，初始时为 $0$。当樱点在某个瞬间**恰好**变为了 $k$，灵梦就会展开樱之结界，同时 $c$ 变为 $0$。

现在她把路程**依次**划分为了 $n$ 个关卡，其中第 $i$ 关上，灵梦一共可以获得 $a_i$ 点樱点。这些樱点是均匀分布在这关的路程上的。也就是说，随着这段路程的进行，灵梦的樱点个数会依次增加，每次增加 $1$ 个单位（$c\gets c+1$），恰好在这段路程结束的瞬间会收集到这关中第 $a_i$ 点樱点。

![](https://cdn.luogu.com.cn/upload/image_hosting/3yuiywt0.png)

**【需要注意的是，这只是图示参考，不满足实际的数据限制。】**

在这个例子里，灵梦将路径划分为了四个关卡。这四个关卡的樱点个数分别为 $2,0,3,1$。

灵梦提出了 $m$ 个要求。第 $i$ 个要求 $b_i$ 表示灵梦希望在第 $b_i$ 段路程结束的瞬间，**恰好**展开樱之结界（如果在这段路程的中途展开但是结束的瞬间没有展开，那就不算达成了要求）。

灵梦可以选择在某个关卡开头放 bomb，**跳过**整个关卡的樱点收集。这样的机会**有且仅有**一次（当然，灵梦可以选择不使用 bomb）。

现在需要求出，在最优的选择下，灵梦**最多**可以达成多少个要求。

## 说明/提示

样例 $2$ 见下发的附件 $\textbf{\textit{sukura2.in/sakura2.ans}}$。该样例约束与测试点 $1\sim 8$ 一致。  
样例 $3$ 见下发的附件 $\textbf{\textit{sukura3.in/sakura3.ans}}$。该样例约束与测试点 $9\sim 14$ 一致。  
样例 $4$ 见下发的附件 $\textbf{\textit{sukura4.in/sakura4.ans}}$。该样例约束与测试点 $15\sim 20$ 一致。

#### 样例 1 解释

- 在不使用 bomb 时，灵梦会在第 $2$、$3$ 关开出樱之结界，其中第 $3$ 关在统计序列中，满足要求数为 $1$。
- 在第 $1$ 关使用 bomb，灵梦会在第 $4$ 关开出樱之结界，且第 $4$ 关在统计序列中，满足要求数为 $1$。
- 在第 $2$ 关使用 bomb，灵梦会在第 $4$ 关开出樱之结界，且第 $4$ 关在统计序列中，满足要求数为 $1$。
- 在第 $3$ 关使用 bomb，灵梦会在第 $2$ 关开出樱之结界，且第 $2$ 关不在统计序列中，满足要求数为 $0$。
- 在第 $4$ 关使用 bomb，灵梦会在第 $2$、$3$ 关开出樱之结界，其中第 $3$ 关在序列中，满足要求数为 $1$。

#### 数据范围及约定

本题共有 $20$ 个测试点，每个测试点 $5$ 分。最终分数为所有测试点分数之和。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Task} & \bm{n\le } & \bm{k\le} \cr\hline
1\sim 8 & 200 & 10^3 \cr\hline
9\sim 14 & 2\times 10^3 & 10^5 \cr\hline
15\sim 20 & 3\times 10^5 & 10^6 \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，保证 $1\le m\le n\le 3\times 10^5$，$1\le k\le 10^6$，$1\le a_i\le 10^9$，$1 \le b_i \le n$，$b$ 序列递增。

## 样例 #1

### 输入

```
4 3 2
1 3 4
1 1 2 1```

### 输出

```
1```

# AI分析结果



---

### **唯一算法分类**  
**前缀和 + 桶计数优化**

---

### **综合分析与结论**  
#### **题目核心思路**  
1. **前缀和模 k**：计算每个关卡结束时樱点总数的模值，统计满足 `sum[b_i] ≡ 0 (mod k)` 的条件数。  
2. **动态维护余数桶**：  
   - **跳过关卡的影响**：若跳过第 `i` 关，其后的前缀和等效于 `sum[j] - a[i] (j > i)`。  
   - **桶优化**：用两个桶数组分别记录跳过关卡前后的余数出现次数，通过动态维护桶来快速计算最大可能解。  

#### **难点与解决方案**  
- **跳过关卡的后缀处理**：需快速统计后缀中满足 `sum[j] ≡ a[i] (mod k)` 的关卡数。  
  - **动态桶维护**：逆序遍历关卡，用桶记录后缀余数，遍历时更新桶和答案。  
- **时间复杂度优化**：通过桶计数将时间复杂度优化至 `O(n)`。  

#### **可视化设计思路**  
1. **动画演示**：  
   - **颜色标记**：用绿色标记当前遍历的关卡，红色表示被跳过的关卡。  
   - **余数桶动态更新**：右侧显示桶数组，每次遍历时高亮当前余数的计数变化。  
   - **步进控制**：允许单步执行，观察桶数组如何随关卡遍历更新。  
2. **复古像素风格**：  
   - **8位色块**：关卡用色块表示，颜色深浅表示余数值（如深蓝=0，浅蓝=1，依此类推）。  
   - **音效触发**：每次更新桶时播放短促音效，找到更优解时播放上扬音调。  

---

### **题解清单 (≥4星)**  
1. **WardLee（★★★★★）**  
   - **亮点**：简洁高效的双桶维护，代码清晰，时间复杂度严格 `O(n)`。  
   - **核心代码段**：  
     ```cpp  
     for(int i = n; i >= 1; i--) {
         if(a[i] && st[i]) nl[s[i] % K] --;
         res = max(res, nl[0] + nr[a[i] % K]);
         if(a[i] && st[i]) nr[s[i] % K] ++;
     }
     ```  
   - **个人心得**：“通过逆序维护桶数组，避免重复计算后缀余数。”  

2. **minstdfx（★★★★☆）**  
   - **亮点**：详细解释动态维护前缀和变化，强调模运算性质。  
   - **核心代码段**：  
     ```cpp  
     for(int i = n; i >= 1; i--) {
         if(p[i]) num[sum[i] % k]--;
         ans = max(ans, t + num[a[i] % k]);
         if(sum[i] % k == 0 && p[i]) t++;
     }
     ```  

3. **lyhqwq（★★★★☆）**  
   - **亮点**：代码极简，仅用单桶逆序维护，适合快速实现。  
   - **核心代码段**：  
     ```cpp  
     for(int i = 1; i <= n+1; i++) {
         if(b[i]) t[sum[i]]--;
         ans = max(ans, tmp + t[a[i] % k]);
         if(sum[i] == 0 && b[i]) tmp++;
     }
     ```  

---

### **最优思路提炼**  
1. **前缀和模 k 的桶映射**：将前缀和转换为余数，统计余数分布。  
2. **逆序动态维护后缀桶**：从后往前遍历关卡，动态更新桶数组，统计后缀中余数为 `a[i] % k` 的关卡数。  
3. **合并前后缀结果**：跳过第 `i` 关的答案为 `前缀合法数 + 后缀余数匹配数`。  

---

### **同类型题推荐**  
1. **P3406 海底高铁**：利用前缀和统计区间覆盖次数。  
2. **P3131 子序列前缀和**：前缀和模 7 的余数统计。  
3. **P3661 餐巾计划问题**：动态维护前后缀状态优化计数。  

---

### **可视化关键代码（JS 伪代码）**  
```javascript  
// 初始化 Canvas 和音效  
const canvas = document.getElementById("canvas");  
const ctx = canvas.getContext("2d");  
const beep = new Audio("beep.wav"); // 短促音效  

function drawStep(i, maxAns) {  
    // 绘制当前关卡（i）为绿色  
    ctx.fillStyle = "#00FF00";  
    ctx.fillRect(i * 10, 0, 10, 10);  

    // 更新桶数组显示  
    buckets.forEach((count, idx) => {  
        ctx.fillStyle = getColor(idx); // 根据余数选择颜色  
        ctx.fillText(count, idx * 30, 50);  
    });  

    // 触发音效  
    beep.play();  
}  
```  

---

### **个人心得摘录**  
- **WardLee**：“逆序维护桶的关键在于，跳过关卡后的后缀余数变化可以看作整体偏移，桶的更新只需一次操作。”  
- **Ginger_he**：“调试时发现边界问题，`n+1` 的处理避免漏掉不跳过关卡的情况。”  

--- 

### **核心算法代码（WardLee 题解）**  
```cpp  
#include <iostream>
#include <cstring>
using namespace std;

typedef long long LL;
const int N = 3e5 + 10, M = 1e6 + 10;
int n, m, K, res;
LL a[N], s[N];
int nl[M], nr[M]; // 前后缀余数桶
bool st[N];       // 标记是否为关键点

int main() {
    scanf("%d%d%lld", &n, &m, &K);
    // 初始化关键点
    for (int i = 1; i <= m; i++) {
        int t; scanf("%d", &t);
        st[t] = true;
    }
    // 计算前缀和并填充左桶
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &a[i]);
        s[i] = s[i - 1] + a[i];
        if (a[i] && st[i]) 
            nl[s[i] % K]++;
    }
    // 逆序遍历，动态维护右桶
    res = nl[0]; // 初始答案为不跳过的解
    for (int i = n; i >= 1; i--) {
        if (a[i] && st[i]) 
            nl[s[i] % K]--;     // 从左桶移除当前点
        res = max(res, nl[0] + nr[a[i] % K]); // 合并前后缀
        if (a[i] && st[i]) 
            nr[s[i] % K]++;     // 加入右桶
    }
    printf("%d\n", res);
    return 0;
}
```

---
处理用时：89.19秒
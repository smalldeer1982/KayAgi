# 题目信息

# [蓝桥杯 2019 省 A] 外卖店优先级

## 题目描述

“饱了么”外卖系统中维护着 $N$ 家外卖店，编号 $1$ ∼ $N$。每家外卖店都有一个优先级，初始时 $(0$ 时刻）优先级都为 $0$。

每经过 $1$ 个时间单位，如果外卖店没有订单，则优先级会减少 $1$，最低减到 $0$；而如果外卖店有订单，则优先级不减反加，每有一单优先级加 $2$。

如果某家外卖店某时刻优先级大于 $5$，则会被系统加入优先缓存中；如果优先级小于等于 $3$，则会被清除出优先缓存。

给定 $T$ 时刻以内的 $M$ 条订单信息，请你计算 $T$ 时刻时有多少外卖店在优先缓存中。

## 说明/提示

**样例解释**

$6$ 时刻时，$1$ 号店优先级降到 $3$，被移除出优先缓存；$2$ 号店优先级升到 $6$，

加入优先缓存。所以是有 $1$ 家店 $(2$ 号）在优先缓存中。

**评测用例规模与约定**

对于 $80\%$ 的评测用例，$1 \le N,M,T \le 10000$。

对于所有评测用例，$1 \le N,M,T \le 10^5$，$1 \le ts \le T$，$1 \le id \le N$。

蓝桥杯 2019 年省赛 A 组 G 题。

## 样例 #1

### 输入

```
2 6 6
1 1
5 2
3 1
6 2
2 1
6 2```

### 输出

```
1```

# AI分析结果



## 算法分类  
**模拟**

---

## 题解思路与解决难点  
### 核心思路  
所有题解均围绕「按时间顺序处理订单」展开，核心步骤为：  
1. **订单排序**：将订单按时间戳排序，便于按时间顺序处理  
2. **时间间隔计算**：对每个店铺，计算相邻订单之间的时间差，处理无订单时的优先级衰减  
3. **状态维护**：在处理每个订单后立即检查是否加入/移出优先缓存  
4. **最终时刻处理**：所有订单处理完毕后，计算从最后一次订单到 T 时刻的优先级衰减  

### 关键难点与解决方案  
1. **时间差计算**  
   - 使用 `last_time` 记录店铺上次订单时间，通过 `当前时间 - last_time - 1` 计算需衰减的优先级  
   - 示例：订单时间序列 [3,5]，则时间差为 5-3-1=1（时间点4）  

2. **同一时刻多订单处理**  
   - 采用双指针法合并同一时刻同一店铺的多个订单  
   - 示例：若某店铺在时刻5有3个订单，合并处理为优先级+6  

3. **缓存状态更新时机**  
   - 必须在计算衰减后、增加新订单优先级前检查是否移出缓存  
   - 示例：某店铺优先级从4衰减到3，先移出缓存后再加订单优先级  

4. **负数优先级处理**  
   - 所有题解均使用 `max(0, priority)` 确保优先级不低于0  

---

## 题解评分（≥4星）  
1. **梅子酒（★★★★★）**  
   - 亮点：时间复杂度优化到 O(M log M + N)，避免逐时刻模拟  
   - 关键代码：通过排序订单后单次遍历更新所有店铺状态  

2. **fish_gugu（★★★★☆）**  
   - 亮点：使用双指针合并同一时刻订单，逻辑清晰  
   - 关键代码：`while(j < m && a[i] == a[j]) j++` 合并订单  

3. **Lele_Programmer（★★★★☆）**  
   - 亮点：模块化设计 `update()` 函数，代码可读性强  
   - 关键代码：`update(id, ts-1)` 分离时间衰减逻辑  

---

## 最优思路与代码实现  
### 核心逻辑（梅子酒题解优化版）  
```cpp
struct order { int ti, id; };
sort(order, order + m); // 按时间排序

for (每个订单) {
    int time_gap = ti - last_time[id] - 1;
    priority[id] = max(0, priority[id] - time_gap);
    if (priority[id] <= 3) 移出缓存;
    priority[id] += 2 * 订单数量;
    if (priority[id] > 5) 加入缓存;
    last_time[id] = ti;
}

// 处理最终时刻到T的时间差
for (每个店铺) {
    priority[id] = max(0, priority[id] - (T - last_time[id]));
    if (priority[id] <= 3) 移出缓存;
}
```

### 完整代码（梅子酒题解核心部分）  
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
struct node { int last, val; } s[N];
struct order { int ti, id; } o[N];
bool vis[N]; // 是否在缓存中

int main() {
    int n, m, T, ans = 0;
    cin >> n >> m >> T;
    for (int i=1; i<=m; i++) cin >> o[i].ti >> o[i].id;
    sort(o+1, o+1+m, [](auto &a, auto &b){ return a.ti < b.ti; });

    for (int i=1; i<=m; i++) {
        auto [ti, id] = o[i];
        int time = max(0, ti - s[id].last - 1);
        s[id].val = max(0, s[id].val - time);
        if (vis[id] && s[id].val <= 3) ans--, vis[id]=0;
        s[id].val += 2;
        if (!vis[id] && s[id].val > 5) ans++, vis[id]=1;
        s[id].last = ti;
    }

    for (int i=1; i<=n; i++) {
        int time = T - s[i].last;
        s[i].val = max(0, s[i].val - time);
        if (vis[i] && s[i].val <= 3) ans--;
    }
    cout << ans;
    return 0;
}
```

---

## 同类型题目  
1. **电梯调度模拟**（如处理不同楼层请求的时间序列）  
2. **事件驱动模拟**（如银行窗口排队问题）  
3. **时序状态维护**（如交通信号灯状态变化）  

---

## 推荐练习题  
1. **P1090 [NOIP2004 提高组] 合并果子**（优先队列模拟）  
2. **P1168 中位数**（动态维护有序序列）  
3. **P2278 [HNOI2003]操作系统**（进程调度模拟）  

---

## 个人心得摘录  
> - **huangzixi071018**：发现必须先在处理订单前检查移出缓存，否则会出现优先级衰减后仍保留在缓存的错误  
> - **ny_Dacong**：调试验证发现同一时刻多个订单必须合并处理，否则时间差计算会出错  
> - **梅子酒**：通过设计 `update()` 函数分离时间衰减逻辑，大幅提升代码可维护性  

---

## 可视化设计  
### 动画方案（复古像素风格）  
1. **界面布局**  
   - 左侧：8-bit 风格时间轴（1~T），当前时刻高亮闪烁  
   - 右侧：店铺列表，显示优先级数值和缓存状态（绿色=在缓存，红色=不在）  

2. **关键操作演示**  
   ```javascript
   // 伪代码示例
   function animateStep(order) {
       highlight(order.ti); // 高亮当前时刻
       let shop = document.getElementById(`shop-${order.id}`);
       shop.style.filter = "brightness(1.5)"; // 高亮目标店铺
       playSound('beep'); // 触发音效

       // 显示优先级变化过程
       let prevPriority = shop.dataset.priority;
       let newPriority = prevPriority - time_gap;
       if (newPriority < 0) newPriority = 0;
       animateNumber(prevPriority, newPriority); // 数字滚动动画

       // 更新缓存状态
       if (newPriority <= 3) shop.classList.remove('cached');
       newPriority += 2 * orderCount;
       if (newPriority > 5) shop.classList.add('cached');
   }
   ```

3. **交互功能**  
   - **速度控制**：滑块调节动画速度（1x~5x）  
   - **单步执行**：按空格键逐步执行每个订单  
   - **音效开关**：8-bit 风格的背景音乐（可选《超级玛丽》风格）  

4. **自动演示模式**  
   - AI 自动按时间顺序处理订单，关键步骤暂停 0.5 秒  
   - 最终展示 T 时刻所有店铺状态时，播放胜利音效  

---

通过该可视化方案，学习者可直观观察时间推进、优先级变化与缓存状态的联动关系，深入理解模拟类问题的核心逻辑。

---
处理用时：98.50秒
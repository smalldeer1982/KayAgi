# 题目信息

# [蓝桥杯 2021 省 AB2] 负载均衡

## 题目描述

有 $n$ 台计算机，第 $i$ 台计算机的运算能力为 $v_{i}$ 。

有一系列的任务被指派到各个计算机上，第 $i$ 个任务在 $a_{i}$ 时刻分配，指定计算机编号为 $b_{i}$, 耗时为 $c_{i}$ 且算力消耗为 $d_{i}$。如果此任务成功分配，将立刻开始运行, 期间持续占用 $b_{i}$ 号计算机 $d_{i}$ 的算力, 持续 $c_{i}$ 秒。

对于每次任务分配，如果计算机剩余的运算能力不足则输出 $-1$，并取消这次分配，否则输出分配完这个任务后这台计算机的剩余运算能力。

## 说明/提示

**【样例说明】**

时刻 $1$，第 $1$ 个任务被分配到第 $1$ 台计算机，耗时为 $5$，这个任务时刻 $6$ 会结束, 占用计算机 $1$ 的算力 $3$。

时刻 $2$，第 $2$ 个任务需要的算力不足，所以分配失败了。

时刻 $3$，第 $1$ 个计算机仍然正在计算第 $1$ 个任务，剩余算力不足 $3$，所以失败。

时刻 $4$，第 $1$ 个计算机仍然正在计算第 $1$ 个任务，但剩余算力足够，分配后剩余算力 $1$。

时刻 $5$，第 $1$ 个计算机仍然正在计算第 $1$，$4$ 个任务，剩余算力不足 $4$，失败。

时刻 $6$，第 $1$ 个计算机仍然正在计算第 $4$ 个任务，剩余算力足够，且恰好用完。

**【评测用例规模与约定】**

对于 $20 \%$ 的评测用例, $n, m \leq 200$。

对于 $40 \%$ 的评测用例, $n, m \leq 2000$。

对于所有评测用例, $1 \leq n, m \leq 2\times 10^5,1 \leq a_{i}, c_{i}, d_{i}, v_{i} \leq 10^{9}, 1 \leq b_{i} \leq n$。 

蓝桥杯 2021 第二轮省赛 A 组 H 题（B 组 I 题）。

## 样例 #1

### 输入

```
2 6
5 5
1 1 5 3
2 2 2 6
3 1 2 3
4 1 6 1
5 1 3 3
6 1 3 4```

### 输出

```
2
-1
-1
1
-1
0```

# AI分析结果



# 算法分类
**优先队列（堆）**

---

## 题解思路与核心难点

### 核心思路
1. **任务回收机制**  
   每个计算机维护一个按结束时间排序的小根堆。处理新任务时，先弹出所有结束时间 ≤ 当前时间的任务，回收其算力。
   
2. **动态算力更新**  
   弹出完成后，判断当前剩余算力是否满足新任务需求。若满足，扣除算力并插入堆；否则输出 `-1`。

### 解决难点
- **高效回收算力**：堆结构保证每次只处理最早完成的任务，时间复杂度均摊为 O(m log m)。
- **多计算机独立处理**：每个计算机单独维护堆，避免全局遍历，降低时间复杂度。

---

## 题解评分（≥4星）

### 题解 1：xwh_hh（5星）
- **亮点**：代码简洁，使用 `pair` 和优先队列实现，逻辑清晰。
- **关键代码**：
  ```cpp
  while (!pq[b].empty() && pq[b].top().first <= a) {
      h[b] += pq[b].top().second;
      pq[b].pop();
  }
  ```

### 题解 2：lupengheyyds（4星）
- **亮点**：详细分析暴力与堆的优化差异，结构体定义清晰。
- **关键代码**：
  ```cpp
  priority_queue<Computer> que[szl];
  que[b].push({a+c, d});
  ```

### 题解 3：gengchenghao（4星）
- **亮点**：代码简洁，直接使用 `struct` 和运算符重载。
- **关键代码**：
  ```cpp
  struct node { int ti, v; };
  priority_queue<node> q[N];
  ```

---

## 最优思路提炼
1. **堆维护任务结束时间**：每个计算机独立的小根堆按结束时间排序。
2. **任务处理流程**：
   - **弹出已结束任务**：回收算力，更新当前可用资源。
   - **判断资源并分配**：扣除算力后插入堆，或直接拒绝。

---

## 同类型题目推荐
1. **P2278 [HNOI2003]操作系统**：进程调度与优先队列应用。
2. **P2085 最小函数值**：堆维护最小值。
3. **P1631 序列合并**：多路归并中的堆优化。

---

## 可视化与算法演示

### 核心算法动画设计
1. **数据结构可视化**：
   - **计算机列表**：横向排列，每个计算机显示当前算力。
   - **任务堆**：每个计算机下方显示小根堆，任务块标注结束时间和算力。
   
2. **操作高亮**：
   - **任务到达**：红色闪烁提示新任务。
   - **算力回收**：绿色动画显示弹出任务并恢复算力。
   - **分配结果**：成功（蓝色）或失败（红色）的提示框。

3. **复古像素风格**：
   - **8位色块**：计算机用像素方块表示，任务堆用堆叠的色块。
   - **音效设计**：
     - **弹出任务**：短促“哔”声。
     - **分配成功**：上扬音效。
     - **分配失败**：低沉音效。

4. **交互控制**：
   - **步进执行**：按空格键逐步执行任务分配。
   - **自动播放**：AI 自动分配任务，速度可调。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef pair<int, int> P;
priority_queue<P, vector<P>, greater<P>> pq[200005];
int v[200005];

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i];
    while (m--) {
        int a, b, c, d;
        cin >> a >> b >> c >> d;
        // 弹出已结束任务
        while (!pq[b].empty() && pq[b].top().first <= a) {
            v[b] += pq[b].top().second;
            pq[b].pop();
        }
        // 判断算力
        if (v[b] < d) cout << "-1\n";
        else {
            v[b] -= d;
            pq[b].push({a + c, d});
            cout << v[b] << "\n";
        }
    }
    return 0;
}
```

---
处理用时：91.97秒
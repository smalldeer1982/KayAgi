# 题目信息

# [DMOI-R1] 柯基棋

## 题目背景

小 A 和小 B 都是爱狗人士，且绝顶聪明，尤其喜爱柯基，于是他们发明了“柯基棋”。

## 题目描述

小 A 和小 B 在一个 $n \times n$ 的棋盘内轮流下棋。小 A 先手，小 B 后手。设当前有一只“柯基”被下在了棋盘的 $(x,y)$ 处，那么棋盘内的 $(x-1,y-1)$，$(x-1,y+1)$，$(x+1,y-1)$，$(x+1,y+1)$ 处都会变为这只“柯基”的地盘，也就不能再放一只“柯基”。当一个人不能再放下一只“柯基”时，他就输了。

可惜，小 C 却不怎么喜欢柯基，所以他很反对小 A 和小 B 玩“柯基”棋，于是他非常喜欢捣乱棋局。当小 A 和小 B 一共下了 $x_i$ 只“柯基”时，小 C 就会以当前 $w \times w$ 棋盘的中心为中心，扩大棋盘为 $(w+2) \times (w+2)$，他一共会捣乱 $q$ 次。

而你的任务是要判断这局棋是小 A 赢还是小 B 赢，如果小 A  赢，输出 `A won`，否则输出 `B won`。

由于他们两个人比较贪玩，所以他们一共会玩 $T$ 局。

**注意**：

1. 当小 A 和小 B 已经将原来的棋盘下到不能再下时，他们会直接跳转到小 C 下一次的捣乱（如果有）。

2. 小 A 和小 B 知道小 C 会捣乱，且会按照自己的最优策略走。

由于数据过大，$x_i$ 由数据随机生成器给出。

## 说明/提示

### 随机数据生成器

每一轮游戏的 $x_i$ 由下方的生成器给出：

```cpp
unsigned long long x[10000005];
unsigned long long xor_shift(unsigned long long &seed){
  return seed^=seed>>12, seed^=seed<<25, seed^=seed>>27, seed*0x2545F4914F6CDD1D;
}
int main(){
  //your code here
  int n,q;
  unsigned long long seed;
  cin>>n>>q>>seed;
  for(int i=1;i<=q;i++){
	x[i]=x[i-1]+((xor_shift(seed)%(unsigned long long)(2*2)+1))*2;
  }
  //your code here
  return 0;
}
```

### 样例解释

对于第一局游戏，$x_i$ 数组如下：`6 8 16 18 22`。

对于第二局游戏，$x_i$ 数组如下：`8 14 16 24 32 36 38 40`。

对于第三局游戏，$x_i$ 数组如下：`4 8 10 16`。

### 数据范围

对于 $20\%$ 的数据，$n,q\leq100$。

对于 $50\%$ 的数据，$n,q\leq10000$。

对于 $100\%$ 的数据，$1 \le T \le 10,2\leq n,q,\sum q \leq 10^7$，$x_i \equiv 0 \pmod 2\ (i\in[1,q]),0 \le seed \le 10^7$。


## 样例 #1

### 输入

```
3
2 5 493
3 8 3219
8 4 1294```

### 输出

```
B won
A won
B won```

# AI分析结果



1. **唯一算法分类**  
   博弈论（对称策略与奇偶性分析）

---

### 综合分析与结论  
**核心思路**：  
本题的胜负仅由初始棋盘边长的奇偶性决定：  
- **奇数边长**：先手（小 A）通过中心对称策略必胜  
- **偶数边长**：后手（小 B）通过轴对称策略必胜  

**解决难点**：  
1. **对称策略的构造**：  
   - 奇数棋盘时，先手下中心点后，每一步镜像对手操作，保证最后一步由自己执行。  
   - 偶数棋盘时，后手镜像先手操作，最终让先手无路可走。  
2. **捣乱操作的无关性**：  
   - 每次棋盘扩展的增量是 2，奇偶性不变，胜负结果保持初始状态。  
   - 生成器保证每一步操作数为偶数，不改变先后手顺序。  

**可视化设计**：  
- **棋盘动态扩展动画**：  
  1. 初始棋盘以像素网格显示，中心点高亮（奇数）或对称轴标红（偶数）。  
  2. 每次下棋后，用不同颜色（红/蓝）标记棋子及其对角占领区域。  
  3. 扩展棋盘时，棋盘外框动态扩展 2 格，颜色渐变提示奇偶性不变。  
- **对称策略演示**：  
  - 奇数棋盘：点击对手落子位置后，自动镜像生成对称落子点。  
  - 偶数棋盘：点击先手落子后，后手位置自动以轴对称方式标出。  

---

### 题解清单 (≥4星)  
1. **Vct14（⭐️⭐️⭐️⭐️⭐️）**  
   - 亮点：详细图解对称策略，明确分析捣乱操作的影响，代码简洁。  
2. **yitian_（⭐️⭐️⭐️⭐️）**  
   - 亮点：直接点明奇偶性决定胜负，代码简洁易懂。  
3. **laijuncheng（⭐️⭐️⭐️⭐️）**  
   - 亮点：分情况讨论对称策略，突出核心结论。  

---

### 最优思路与代码实现  
**关键代码**：  
```cpp
int main() {
    int T; cin >> T;
    while (T--) {
        int n, q, seed;
        cin >> n >> q >> seed;
        cout << (n % 2 ? "A won\n" : "B won\n");
    }
    return 0;
}
```

**核心逻辑**：  
- 直接判断初始边长的奇偶性，无需处理输入数据中的 `q` 和 `seed`。  

---

### 类似题目推荐  
1. **P4136 谁能赢呢？**  
   - 棋盘覆盖问题，奇偶性决定胜负。  
2. **P1290 欧几里德的游戏**  
   - 博弈中通过倍数关系快速判断胜负。  
3. **P3150 取石子游戏**  
   - 奇偶性策略在简单博弈中的应用。  

---

### 个人心得摘录  
- **Vct14**：  
  > "捣乱操作不影响胜负的关键在于奇偶性不变，这一观察是解题的核心突破口。"  
- **GoodLuckCat**：  
  > "将问题类比于圆桌放硬币的对称策略，瞬间打通思路。"  

---

### 可视化与像素化动画方案  
**实现要点**：  
1. **8位像素风格**：  
   - 棋盘网格使用 16 色调色板，中心点用黄色高亮（奇数）或对称轴用红色虚线（偶数）。  
2. **Canvas 动态扩展**：  
   - 每次扩展棋盘时，外框以 2 格为单位向外扩展，伴随像素粒子特效。  
3. **音效设计**：  
   - 落子时播放 8-bit "beep" 音效，胜负时播放胜利/失败旋律。  
4. **自动演示模式**：  
   - 初始棋盘自动展示对称策略，每步操作间隔 1 秒，用箭头标记镜像对称路径。  

**交互设计**：  
- **控制面板**：  
  - 速度滑块调节动画速度（0.5x~3x）。  
  - 按钮切换手动/自动模式，手动模式下可点击落子位置观察对称策略。  
- **积分系统**：  
  - 正确预测胜负结果获得积分，连续正确触发连击奖励音效。  

---

**总结**：通过奇偶性分析快速得出胜负结论，无需复杂计算，是博弈论中对称策略的典型应用。

---
处理用时：72.67秒
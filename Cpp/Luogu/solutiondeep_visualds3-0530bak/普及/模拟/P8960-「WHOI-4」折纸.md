# 题目信息

# 「WHOI-4」折纸

## 题目背景

吉尼斯记录：一张纸（如果接近 $4$ 公里的卫生纸可以算作一张纸）最多可以对折 $13$ 次。小 X 吹牛说打破了这个记录，但是吹太大了。

## 题目描述

小 X 向吉尼斯世界纪录组织申请了这个记录，但是他正好隔离在家，无法证明。他只好允许他们问 $t$ 个问题，确认他确实打破了记录。

他们每个问题可以要求小 X 把一张纸按照一个给定 $01$ 串 $s$ 的规则对折 $n$ 次后展开。对于第 $i$ 次折叠，如果 $s_i=0$，将纸从左到右对折，使左边对齐右边；如果 $s_i=1$，将纸从右到左对折，使右边对齐左边。对折全部是从上方翻。**接下来将会展开，展开后纸片在原位，只是保留了折痕。看看自己是否实现了这一点。**

他们想要知道，从左往右数第 $k$ 个折痕是峰折（向上突起的折痕）还是谷折（向下凹陷的折痕）。如果该询问的答案是峰折，输出 `Up`；否则输出 `Down`。请你帮帮可怜的小 X。

峰折，谷折的图示见样例解释。

## 说明/提示

**样例解释**

样例 #1 解释：

动态地址：[here](https://img-blog.csdnimg.cn/c68f2ba917504417b109eb1606f4a3a5.gif)。不知道为什么洛谷显示不了了。

![](https://cdn.luogu.com.cn/upload/image_hosting/wguzrqz6.png)

由于技术原因，动图帧数略低。

样例 #2 请手动模拟。

**数据范围**

**本题采用捆绑测试。**

- Subtask 1（$20$ pts）：$t=10$，$1\le n\le5$；
- Subtask 2（$80$ pts）：$t=10^5$。

对于 $100\%$ 的数据，有 $1\le t\le 10^5$，$1\le n\le60$，$1\le k<2^n$。

## 样例 #1

### 输入

```
7
3 1
010
3 2
010
3 3
010
3 4
010
3 5
010
3 6
010
3 7
010```

### 输出

```
Down
Up
Up
Down
Down
Down
Up```

## 样例 #2

### 输入

```
7
3 1
011
3 2
011
3 3
011
3 4
011
3 5
011
3 6
011
3 7
011```

### 输出

```
Down
Up
Up
Down
Down
Down
Up
```

## 样例 #3

### 输入

```
2
13 114
1101101111010
13 514
1101101111010```

### 输出

```
Up
Up```

# AI分析结果



---

**唯一算法分类**：数学规律与二进制分解

---

### **题解思路、算法要点与解决难点**

1. **核心思路**：  
   每次折叠将纸张分为两半，折痕方向由折叠顺序和方向决定。通过**二进制分解**或**二分法**确定折痕位置对应的折叠次数及方向，结合奇偶性与状态翻转判断最终方向。

2. **关键步骤**：  
   - **二分法**：将折痕序列视为二叉树，每次折叠决定左/右子树的翻转状态。  
   - **二进制分解**：折痕位置的二进制表示中最高位的 `1` 对应最后一次折叠的层级。  
   - **异或运算**：通过维护状态变量，简化方向翻转的逻辑判断。

3. **解决难点**：  
   - **折叠方向与状态翻转**：不同折叠方向导致折痕方向反转，需动态维护状态。  
   - **高效处理大范围数据**：由于 `n≤60`，需避免暴力模拟，使用 `O(n)` 或 `O(logn)` 算法。

---

### **题解评分（≥4星）**

1. **Moon_Traveller（⭐⭐⭐⭐⭐）**  
   - 思路清晰，通过二叉树模型模拟折叠过程。  
   - 代码简洁，使用二分法动态维护状态变量。  
   - 关键亮点：将折痕序列视为二叉树，每次折叠决定左右子树方向。

2. **escapist404（⭐⭐⭐⭐⭐）**  
   - 异或运算简化方向判断，逻辑紧凑。  
   - 代码高度优化，时间复杂度 `O(n)`。  
   - 关键亮点：通过 `f ^ (k < mid) ^ s[i]` 统一处理所有情况。

3. **zfx_VeXl6（⭐⭐⭐⭐）**  
   - 二分法结合状态翻转，代码易读。  
   - 关键亮点：通过 `s[d]` 直接判断左/右方向是否需要翻转。

---

### **最优思路或技巧提炼**

1. **异或运算统一状态翻转**：  
   - 维护一个状态变量 `f`，表示当前纸面朝向。  
   - 每次折叠时，根据 `k` 的位置和 `s[i]` 的值，通过异或运算动态更新 `f`：  
     ```cpp  
     if (f ^ (k < mid) ^ (s[i] == '1')) f ^= 1;  
     ```

2. **二进制分解定位折叠层级**：  
   - 折痕位置 `k` 的二进制最高位 `1` 对应最后一次折叠的层级。  
   - 通过逐次减去 `2^i` 定位最高位，结合 `s` 的对应位判断方向。

3. **二分法模拟折叠过程**：  
   - 初始区间为 `[0, 2^n]`，每次折叠后舍弃一半区间。  
   - 根据 `k` 的位置和折叠方向更新区间和状态。

---

### **同类型题或类似算法套路**

- **分治与二进制分解**：  
  - 类似问题：快速幂、汉诺塔问题、归并排序逆序对计数。  
- **状态维护与异或优化**：  
  - 类似问题：开关灯问题、动态翻转数组。

---

### **推荐相似题目**

1. **P1496 火柴棒等式**（分治与组合数学）  
2. **P1220 关路灯**（动态维护状态与区间选择）  
3. **P1908 逆序对**（分治与归并排序）

---

### **个人心得摘录**

- **动手模拟**：通过折纸实验观察折痕方向变化规律（如样例解释中的动图）。  
- **二进制思维**：将折痕位置转换为二进制，发现最高位决定最后一次折叠层级。  
- **异或简化条件**：用逻辑运算替代冗长的 `if-else`，提升代码效率和可读性。

---

### **可视化与算法演示**

1. **动画设计**：  
   - **8位像素风格**：  
     - 纸张用网格表示，折痕用不同颜色（谷折红色，峰折绿色）。  
     - 每次折叠时，用动画展示纸张分割和翻折过程。  
   - **Canvas 绘制**：  
     - 动态更新区间 `[l, r]` 和折痕位置 `k`，高亮当前折叠方向（`s[i]`）。  
     - 显示状态变量 `f` 和当前折叠次数 `i`。  

2. **交互设计**：  
   - **步进控制**：支持单步执行，观察每次折叠后的区间变化。  
   - **音效提示**：  
     - 折叠时播放 "beep" 音效，方向 `0` 和 `1` 使用不同音调。  
     - 找到答案时播放胜利音效。  

3. **核心代码片段（JavaScript）**：  
   ```javascript  
   // 伪代码：Canvas 绘制折纸动画  
   function drawFold(l, r, mid, s, f) {  
     ctx.clearRect(0, 0, canvas.width, canvas.height);  
     // 绘制当前区间 [l, r]  
     ctx.fillStyle = f ? "#FF0000" : "#00FF00"; // 状态 f 决定颜色  
     ctx.fillRect(l * scale, 0, (r - l) * scale, canvas.height);  
     // 绘制折痕 mid  
     ctx.strokeStyle = "#0000FF";  
     ctx.beginPath();  
     ctx.moveTo(mid * scale, 0);  
     ctx.lineTo(mid * scale, canvas.height);  
     ctx.stroke();  
   }  
   ```

---

### **代码实现（escapist404 题解）**

```cpp  
#include <bits/stdc++.h>  
using namespace std;  
int main() {  
    ios::sync_with_stdio(0);  
    cin.tie(0);  
    int T; cin >> T;  
    while (T--) {  
        int n; unsigned long long k; string s;  
        cin >> n >> k >> s;  
        unsigned long long l = 0, r = 1ULL << n;  
        bool f = 0; // 0: 正向，1: 反向  
        for (int i = 0; i < n; i++) {  
            unsigned long long mid = (l + r) >> 1;  
            if (k == mid) {  
                cout << (f ? "Up" : "Down") << "\n";  
                break;  
            }  
            if (f ^ (k < mid) ^ (s[i] == '1')) f ^= 1;  
            (k > mid) ? (l = mid) : (r = mid);  
        }  
    }  
    return 0;  
}  
```  

**核心逻辑**：  
- 维护区间 `[l, r]` 和状态 `f`。  
- 每次折叠通过异或运算动态更新状态，舍弃无关区间。

---
处理用时：113.00秒
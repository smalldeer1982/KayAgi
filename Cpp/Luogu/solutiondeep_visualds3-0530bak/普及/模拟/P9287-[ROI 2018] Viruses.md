# 题目信息

# [ROI 2018] Viruses

## 题目背景

译自 [ROI 2018 Day1](https://neerc.ifmo.ru/school/archive/2017-2018.html) T2. [Вирусы](https://neerc.ifmo.ru/school/archive/2017-2018/ru-olymp-roi-2018-day1.pdf) ([Viruses](https://codeforces.com/gym/102147/problem/D))。

## 题目描述

现在有 $n$ 只细胞与 $n$ 个病毒，$i$ 号细胞的初始病毒的序号也为 $i$，每个细胞心中对每位病毒都有一定的易感染度。

细胞之间可以互相攻击，如果细胞甲攻击了细胞乙，且乙「对甲现在的病毒的易感染度」比「对自家病毒的易感染度」高，那么乙就会被甲的病毒感染（成为甲的病毒的细胞）。

细胞们可以任意安排攻击顺序。当且仅当没有细胞可以被任意一名病毒感染时，游戏宣告结束。

如果存在一种攻击顺序，使得病毒 $i$ 最终拥有一只或以上的细胞，那么我们则称病毒 $i$ 为「可行的病毒」。
如果对于任意一种攻击顺序，都使得病毒 $i$ 最终拥有一只或以上的细胞，那么我们则称病毒 $i$ 为「稳定的病毒」。

现在病毒们想知道，有多少个可行的病毒与稳定的病毒。

## 说明/提示

对于所有的数据，$1 \leq n \leq 500$。

| 子任务编号 | $n$ | $p$ |
| :-----------: | :-----------: | :-----------: |
| $1$ | $1 \leq n \leq 5$ | $p = 1$ |
| $2$ | $1 \leq n \leq 500$ | $p = 1$ |
| $3$ | $1 \leq n \leq 5$ | $p = 1,2$ |
| $4$ | $1 \leq n \leq 50$ | $p = 1,2$ |
| $5$ | $1 \leq n \leq 500$ | $p = 1,2$ |

## 样例 #1

### 输入

```
2
1 2
2 1
1```

### 输出

```
2
1 2```

## 样例 #2

### 输入

```
4
3 2 4 1
1 4 2 3
3 1 2 4
1 4 2 3
1```

### 输出

```
1
3```

## 样例 #3

### 输入

```
4
3 2 4 1
1 4 2 3
3 1 2 4
1 4 2 3
2```

### 输出

```
3
1 3 4```

# AI分析结果



## 算法分类
无算法分类

---

## 题解思路、算法要点与解决难点

### 核心思路
1. **稳定病毒**：当且仅当细胞i的初始病毒i在自身优先级最高（即`a[i][1] == i`）。
2. **可行病毒**：存在至少一个细胞j，使得病毒i能在j中存活，且所有比i在j中优先级高的病毒都能被其他病毒淘汰。

### 解决难点
- **可行病毒的条件推导**：需确保所有优先级高于i的病毒存在被其他病毒淘汰的路径。
- **高效验证条件**：通过预处理每个病毒在各细胞的优先级，将问题转化为多次条件判断。

### 关键变量与数据结构
- **a[i][j]**：细胞i认为第j强的病毒编号。
- **b[i][j]**：细胞i对病毒j的排名（预处理逆映射）。
- **st数组**：标记需要被淘汰的病毒。

---

## 题解评分 (≥4星)

1. **2huk（4星）**  
   - 思路清晰，直接推导稳定/可行病毒条件。
   - 代码可读性较好，使用逆映射加速判断。
   - 复杂度O(n³)，但逻辑直观。

2. **Y_QWQ_Y（4星）**  
   - 预处理优先级矩阵，引入`t[i]`优化判断。
   - 代码简洁，利用`min`操作缩小可行域。
   - 时间复杂度O(n³)，但常数较小。

3. **Drifty（4星）**  
   - 桶操作优化，减少无效枚举。
   - 引入`bitset`加速集合运算。
   - 代码风格简洁，逻辑高效。

---

## 最优思路与技巧提炼

### 关键技巧
1. **逆映射预处理**：将`a[i][j]`转换为`b[i][a[i][j]]=j`，快速获取病毒排名。
2. **条件剪枝**：对于可行病毒，只需找到一个细胞j满足：
   - 病毒i在j中的排名优于j的初始病毒。
   - 所有比i在j中优先级高的病毒k，存在至少一个病毒能淘汰k。
3. **暴力枚举优化**：通过嵌套循环和标记数组，将问题分解为多个独立的条件验证。

---

## 类似题目推荐
1. **P3387 缩点**（强连通分量与拓扑排序）
2. **P1262 间谍网络**（依赖关系与最小覆盖）
3. **P2746 Campus Network**（支配树与网络流）

---

## 代码核心逻辑

### 稳定病毒判断（2huk）
```cpp
if (p == 1) {
    for (int i = 1; i <= n; ++i)
        if (a[i][1] == i) res.push_back(i);
}
```

### 可行病毒判断（Drifty优化版）
```cpp
for (int i = 0; i < n; ++i) {
    t[i] = n;
    for (int j = 0; j < n; ++j) {
        int cur = 0;
        for (int k = 0; k < n; ++k)
            if (g[j][k] <= g[j][j]) // 病毒k能感染细胞j
                cur = max(cur, g[i][k]); // 更新最小优先级
        t[i] = min(cur, t[i]);
    }
}
for (int i = 0; i < n; ++i) {
    for (int j = 0; j < n; ++j) {
        if (g[j][i] <= g[j][j] && t[j] >= g[j][i]) {
            ans.push_back(i + 1);
            break;
        }
    }
}
```

---

## 可视化与算法演示

### 动画设计
1. **网格布局**：将n个细胞排列为网格，每个单元格显示当前感染的病毒编号。
2. **颜色标记**：
   - **红色**：当前被攻击的细胞。
   - **绿色**：成功感染的病毒。
   - **灰色**：已被淘汰的病毒。
3. **动态流程**：
   - 按攻击顺序逐步显示病毒传播。
   - 高亮当前操作的细胞对（攻击方与被攻击方）。
   - 淘汰病毒时播放“爆炸”音效，感染成功时播放“升级”音效。

### 复古像素风格
- **8-bit调色板**：使用经典FC游戏的16色模式。
- **Canvas绘制**：每个细胞用8x8像素块表示，病毒编号以ASCII字符显示。
- **音效设计**：
  - 攻击时：短促“哔”声。
  - 感染成功：上升音阶。
  - 游戏结束：经典FC过关音乐片段。

### 交互功能
- **步进控制**：允许暂停/继续，观察每一步的条件判断。
- **自动演示**：AI模拟最优攻击顺序，展示可行病毒的传播路径。

---

## 总结
该题核心在于条件推导与高效验证。稳定病毒的条件直接，可行病毒需通过嵌套枚举和剪枝优化。可视化可通过复古像素动画生动展示病毒传播过程，帮助理解优先级与淘汰机制。

---
处理用时：75.11秒
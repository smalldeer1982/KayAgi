# 题目信息

# [BCSP-X 2024 12 月小学高年级组] 质数补全

## 题目描述

Alice 在纸条上写了一个质数，第二天再看时发现有些地方污损看不清了。

- 在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数称为质数

请你帮助 Alice 补全这个质数，若有多解输出数值最小的，若无解输出 $-1$。

例如纸条上的数字为 $\tt{1*}$（$\tt{*}$ 代表看不清的地方），那么这个质数有可能为 $11, 13, 17, 19$，其中最小的为 $11$。

## 说明/提示

### 样例 3-6

参考附件中的样例。

### 数据范围

$|s|$ 代表 $s$ 串的长度，对于所有数据，$1 \leq t \leq 10, 1 \leq |s| \leq 7$，$s$ 中仅包含数字或者 $\tt{*}$，并且保证首位不是 $\tt{*}$ 或者 $0$。

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | $\mid s\mid$ | 特殊性质 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $35$ | $\leq 7$ | $s$ 中没有 $\tt{*}$ |  |
| $2$ | $30$ | $\leq 4$ |  |  |
| $3$ | $24$ | $\leq 7$ | $s$ 中至多包含 $1$ 个 $\tt{*}$ | $1$ |
| $4$ | $11$ | $\leq 7$ |  | $1,2,3$ |


## 样例 #1

### 输入

```
10
1*
3**
7**
83*7
2262
6**1
29*7
889*
777*
225*```

### 输出

```
11
307
701
8317
-1
6011
2917
8893
-1
2251```

## 样例 #2

### 输入

```
10
4039***
2***5*5
4099961
25**757
7***0**
1***00*
41811*9
6***0*7
8***1**
6561*59```

### 输出

```
4039019
-1
4099961
2509757
7000003
1000003
4181129
6000047
8000101
6561259```

# AI分析结果



**唯一算法分类**：深度优先搜索（DFS）

---

### **综合分析与结论**

**题目核心**：将带星号的字符串补全为最小的质数。  
**解决思路**：通过DFS按位生成所有可能的候选数，按升序枚举替换数字，找到第一个质数即返回。  
**难点**：正确处理星号替换顺序、避免生成前导零、高效判断质数。  
**关键优化**：按位升序枚举替换值，剪枝找到第一个解即终止后续搜索。

---

### **题解清单 (4星)**

1. **DFS生成候选数**（作者：_Deer_Peach_）  
   **亮点**：  
   - 按位递归处理，确保从小到大生成候选数。  
   - 剪枝策略避免冗余搜索。  
   **评分理由**：思路清晰，代码简洁，但字符串拼接和空格处理稍显隐晦。

---

### **代码实现与核心逻辑**

#### **关键代码片段**
```cpp
void dfs(string x, int id) {
    if (flag) return; // 剪枝：已有解
    if (x[id] == ' ') { // 终止条件：处理完所有字符
        int val = num(x);
        if (check(val)) {
            cout << val << endl;
            flag = true;
        }
        return;
    }
    if (x[id] == '*') { // 替换星号为0-9
        for (int i = 0; i < 10; i++) {
            x[id] = '0' + i;
            dfs(x, id + 1);
        }
    } else { // 非星号直接递归下一位
        dfs(x, id + 1);
    }
}
```

#### **完整代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
int t; bool flag;

int num(string s) {
    int nu = 0;
    for (int i = 0; i < s.size() - 1; i++) { // 忽略末尾空格
        if (s[0] == '0') return 0; // 前导零过滤
        nu = nu * 10 + (s[i] - '0');
    }
    return nu;
}

bool check(int x) {
    if (x < 2) return false;
    for (int i = 2; i * i <= x; i++)
        if (x % i == 0) return false;
    return true;
}

void dfs(string x, int id) {
    if (flag) return;
    if (x[id] == ' ') {
        int val = num(x);
        if (check(val)) {
            cout << val << endl;
            flag = true;
        }
        return;
    }
    if (x[id] == '*') {
        for (int i = 0; i < 10; i++) {
            x[id] = '0' + i;
            dfs(x, id + 1);
        }
    } else {
        dfs(x, id + 1);
    }
}

int main() {
    cin >> t;
    while (t--) {
        string s; cin >> s;
        s += " "; // 添加终止符
        flag = false;
        dfs(s, 0);
        if (!flag) cout << "-1\n";
    }
    return 0;
}
```

---

### **可视化与算法演示**

**动画方案**：  
1. **像素风格界面**：  
   - 使用 8-bit 像素字体显示当前生成的字符串，星号位置闪烁提示。  
   - 每次替换数字时，用不同颜色高亮变化位（如绿色表示替换成功，红色表示无效）。  
2. **算法流程演示**：  
   - **DFS路径跟踪**：显示递归栈的深度和当前处理的字符位置。  
   - **质数检查**：展示当前候选数的质因数分解动画，若分解失败则显示质数。  
3. **音效与交互**：  
   - 替换数字时播放“滴”声，找到解时播放胜利音效，无解时播放低音。  
   - 用户可调节动画速度或单步执行观察流程。

**核心逻辑动画步骤**：  
1. 输入字符串显示在像素网格中，星号位置标记为“?”。  
2. 递归处理每位，替换星号为0-9，按顺序生成候选数。  
3. 若候选数首位非零且为质数，高亮显示并终止搜索。

---

### **同类型题目推荐**

1. **P1025 数的划分**（DFS剪枝）  
2. **P1036 选数**（质数判断与组合生成）  
3. **P1217 [USACO1.5]回文质数**（质数与回文数生成）

---

**总结**：本题通过DFS生成所有可能解，结合质数判断与剪枝策略，确保高效找到最小解。核心在于递归顺序和剪枝优化，适用于处理含不确定位的搜索问题。

---
处理用时：166.11秒
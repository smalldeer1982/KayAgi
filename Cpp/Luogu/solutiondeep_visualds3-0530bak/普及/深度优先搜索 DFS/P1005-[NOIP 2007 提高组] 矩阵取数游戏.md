# 题目信息

# [NOIP 2007 提高组] 矩阵取数游戏

## 题目描述

帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：

1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；
2. 每次取走的各个元素只能是该元素所在行的行首或行尾；
3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；
4. 游戏结束总得分为 $m$ 次取数得分之和。

帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。


## 说明/提示

**【数据范围】**

对于 $60\%$ 的数据，满足 $1\le n,m\le 30$，答案不超过 $10^{16}$。  
对于 $100\%$ 的数据，满足 $1\le n,m\le 80$，$0\le a_{i,j}\le1000$。

**【题目来源】**

NOIP 2007 提高第三题。





## 样例 #1

### 输入

```
2 3
1 2 3
3 4 2
```

### 输出

```
82```

# AI分析结果



---

**算法分类**：区间动态规划（区间DP）

---

### **题解思路与核心难点**

1. **核心思路**  
   - **行独立性**：每行的取数操作互不影响，可对每行单独计算最大得分后累加。
   - **区间DP状态设计**：对每行定义 `dp[l][r]` 表示当前剩余区间 `[l, r]` 时的最大得分。
   - **幂次简化**：通过每次转移时乘以2，避免显式计算 `2^i`，将幂次转化为动态累乘。

2. **解决难点**  
   - **状态转移方程**：从取左端点或右端点中选择更优解，并通过 `dp[l+1][r]` 或 `dp[l][r-1]` 的得分乘以2实现幂次累积。
   - **大数处理**：使用 `__int128` 替代高精度运算，简化代码实现。

---

### **题解评分（≥4星）**

1. **zhylj（5星）**  
   - **亮点**：通过 `2 * dp + 2 * a` 的转移公式简化幂次计算，代码简洁高效，使用 `__int128` 避免高精度复杂度。

2. **qhr2023（5星）**  
   - **亮点**：极简代码风格，清晰展示区间DP核心逻辑，`__int128` 处理大数，时间复杂度 `O(nm²)` 完全可行。

3. **MoonCake2011（4星）**  
   - **亮点**：明确状态转移的数学推导，代码结构清晰，但初始化部分略显冗余。

---

### **最优思路提炼**

1. **行独立处理**  
   每行的最大得分独立计算，总得分为各行之和，避免多维状态设计。

2. **区间DP的翻倍策略**  
   每次转移时将子问题得分乘以2，确保后续操作的幂次正确累积。例如：  
   - 取左端点：`dp[l][r] = 2 * dp[l+1][r] + 2 * a[l]`
   - 取右端点：`dp[l][r] = 2 * dp[l][r-1] + 2 * a[r]`

3. **大数处理技巧**  
   使用 `__int128`（需编译器支持）代替高精度运算，显著降低代码复杂度。

---

### **类似算法题目**

1. **石子合并（NOI 1995）**  
   - 区间DP经典问题，合并相邻石子的最小代价。

2. **能量项链（NOIP 2006 提高组）**  
   - 环形区间DP，通过断环为链处理循环合并。

3. **括号序列（Codeforces 5C）**  
   - 最长合法括号子串，利用区间DP或栈结构解决。

---

### **代码核心实现**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 85;
__int128 dp[MAXN][MAXN], ans;

void write(__int128 x) {
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

int main() {
    int n, m; cin >> n >> m;
    while (n--) {
        memset(dp, 0, sizeof(dp));
        int a[MAXN];
        for (int i = 1; i <= m; i++) cin >> a[i];
        for (int len = 1; len <= m; len++) {
            for (int l = 1, r = l + len - 1; r <= m; l++, r++) {
                dp[l][r] = max(2 * dp[l+1][r] + 2 * a[l], 
                               2 * dp[l][r-1] + 2 * a[r]);
            }
        }
        ans += dp[1][m];
    }
    write(ans);
    return 0;
}
```

---

### **可视化设计（复古像素风格）**

1. **动画流程**  
   - **网格绘制**：将矩阵的每行显示为像素块，当前处理行高亮。
   - **区间标记**：用颜色标记 `dp[l][r]` 的当前区间，左侧红色，右侧蓝色。
   - **得分翻倍**：每次转移时显示“×2”动画，伴随8位音效。

2. **交互功能**  
   - **步进控制**：按空格键单步执行转移，观察区间收缩。
   - **自动播放**：AI模式自动遍历所有区间，速度可调。

3. **音效设计**  
   - **取数操作**：播放短促的“哔”声。
   - **得分更新**：高分时播放上升音调，像素块闪烁。

---

**总结**：通过区间DP与翻倍策略简化计算，结合 `__int128` 处理大数，代码简洁高效。复古像素动画可直观展示区间收缩与得分累积过程。

---
处理用时：83.54秒
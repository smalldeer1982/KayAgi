# 题目信息

# [NOIP 2003 提高组] 神经网络

## 题目背景

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。



## 题目描述

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)

神经元（编号为 $i$）


图中，$X_1 \sim X_3$ 是信息输入渠道，$Y_1 \sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)

兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）

$$C_i=\left(\sum\limits_{(j,i) \in E} W_{ji}C_{j}\right)-U_{i}$$

公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。



## 说明/提示

**【题目来源】**

NOIP 2003 提高组第一题

## 样例 #1

### 输入

```
5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
```

### 输出

```
3 1
4 1
5 1
```

# AI分析结果



# [NOIP 2003 提高组] 神经网络 题解分析

## 算法分类
拓扑排序

## 题解核心思路与难点分析

### 核心算法流程
1. **拓扑排序处理层次结构**：利用入度为0的输入层神经元作为起点，按层处理神经元状态
2. **阈值预处理**：非输入层神经元在初始化时直接减去阈值（输入层保持原值）
3. **状态传播机制**：仅当神经元状态>0时才向下一层传递信号
4. **输出层判定**：通过出度数组标记无出边节点为输出层

### 关键难点解决
1. **输入层特殊处理**：初始状态为输入的神经元不参与阈值计算
2. **负值处理优化**：在状态传播前判断是否>0，避免无效计算
3. **输出排序要求**：收集输出层结果后需按编号排序

### 可视化设计思路
1. **像素化神经元**：使用16x16像素块表示神经元，不同颜色区分状态（红色：激活，灰色：平静）
2. **动态信号传递**：用箭头动画展示激活神经元向下一层的信号传递过程
3. **状态值气泡**：在神经元上方实时显示当前C值变化
4. **音效系统**：
   - 激活音：8-bit风格"滴"声（440Hz方波）
   - 传播音：短促"嘟"声（随传播距离改变音调）
   - 完成音：经典FC过关旋律

## 高分题解推荐（≥4星）

### 1. Lucaster_（⭐⭐⭐⭐⭐）
**亮点**：
- 双版本代码（原始版+优化版）
- 详细注释邻接表实现
- 特别说明输入层阈值处理
```cpp
// 核心处理逻辑
while(!q.empty()) {
    int h = q.front(); q.pop();
    for(邻接表遍历) {
        if(c[h] <= 0) continue;
        c[t] += w * c[h];
        if(!vis[t]) q.push(t);
    }
}
```

### 2. zzlzk（⭐⭐⭐⭐）
**亮点**：
- 反向建图实现记忆化搜索
- 公式变形分析清晰
```cpp
int DFS(int p) {
    if(已计算) return c[p];
    for(所有前驱节点) 
        c[p] += w * DFS(前驱);
    return max(0, c[p]-u);
}
```

### 3. ghj1222（⭐⭐⭐⭐）
**亮点**：
- 入度/出度数组双重记录
- 暴力拓扑实现简单易懂
```cpp
for(int tmp=1;tmp<=n;tmp++) // 暴力拓扑
    for(找入度为0节点处理)
```

## 最优技巧提炼
1. **入度队列初始化**：将初始激活的输入层节点直接入队
2. **阈值提前处理**：非输入层节点在读取时即减去U[i]
3. **传播剪枝**：仅当c[h]>0时才进行信号传播
4. **输出层缓存**：遍历时记录出度为0的节点，最后统一处理

## 同类题目推荐
1. P1113 杂务（拓扑排序处理任务依赖）
2. P4017 最大食物链计数（DAG入度/出度综合应用）
3. P1983 车站分级（层级拓扑关系建模）

## 可视化实现方案（伪代码）
```javascript
// Canvas初始化
const ctx = canvas.getContext('2d');
const neurons = [];
class Neuron {
    constructor(x, y, id) {
        this.x = x; this.y = y; 
        this.state = 0; this.active = false;
    }
    
    draw() {
        ctx.fillStyle = this.active ? '#FF5555' : '#AAAAAA';
        ctx.fillRect(x-8, y-8, 16, 16); // 像素风格
        drawTextCenter(`${id}:${state}`, x, y+15);
    }
}

// 动画循环
function animate() {
    if(自动播放 && Date.now() > lastStep+speed) {
        执行下一步拓扑();
        播放音效('step');
    }
    渲染所有神经元();
    requestAnimationFrame(animate);
}
```

## 调试心得摘录
> "测试时发现输入层可能同时是输出层，增加`if(out[i]==0 && c[i]>0)`的双重判断才通过最后两个测试点" —— Lucaster_

> "WA五次才意识到输入层的U[i]应该置零，题目描述存在歧义" —— zzlzk

## 核心算法演示
1. **初始状态**：输入层显示为红色闪烁，其他层灰色
2. **拓扑推进**：当前处理节点高亮黄色边框
3. **信号传播**：蓝色箭头从激活节点指向下一层，伴随数值飘动效果
4. **状态更新**：目标神经元数值实时变化，超过阈值时触发红色脉冲特效

访问[模拟演示](https://example.com/neural-demo)体验交互式动画（注：演示链接为示意地址）

---
处理用时：75.71秒
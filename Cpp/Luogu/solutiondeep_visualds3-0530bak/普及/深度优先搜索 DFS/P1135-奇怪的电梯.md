# 题目信息

# 奇怪的电梯

## 题目背景

感谢 @[yummy](https://www.luogu.com.cn/user/101694) 提供的一些数据。

## 题目描述

呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \le i \le N$）上有一个数字 $K_i$（$0 \le K_i \le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 200$，$1 \le A, B \le N$，$0 \le K_i \le N$。

本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。

## 样例 #1

### 输入

```
5 1 5
3 3 1 2 5
```

### 输出

```
3
```

# AI分析结果



## 唯一算法分类
BFS（广度优先搜索）

---

## 综合分析与结论
### 核心算法流程
1. **初始化队列**：将起始楼层A加入队列，步数设为0，并标记为已访问。
2. **逐层扩展**：循环处理队列中的每个节点，生成上/下两个可达楼层。
3. **合法性检查**：判断新楼层是否在合法范围内且未被访问过。
4. **目标检测**：若到达目标楼层B，立即返回当前步数。
5. **剪枝优化**：通过标记数组避免重复访问，确保每个楼层仅处理一次。

### 可视化设计思路
- **动画方案**：用Canvas绘制楼层网格，当前处理节点高亮为黄色，队列中的节点显示为绿色，已访问节点标记为灰色。
- **队列动态展示**：右侧显示队列内容，动态演示节点入队和出队过程。
- **步进控制**：支持暂停/继续、单步执行，速度可调节。
- **音效提示**：移动时播放“哔”声，找到解时播放胜利音效，队列空时播放失败音效。
- **复古像素风格**：采用8-bit调色板（深蓝背景、亮色元素），电梯移动时显示像素箭头动画。

---

## 题解清单 (≥4星)
1. **cff_0102的BFS实现（5星）**  
   - 亮点：代码简洁，使用标准队列，正确处理初始状态（A=B时直接返回0），通过vis数组剪枝。
2. **wwwidk1234的BFS实现（4星）**  
   - 亮点：手动实现队列结构，通过结构体记录楼层和步数，逻辑清晰。
3. **bigclever的BFS实现（4星）**  
   - 亮点：使用pair存储状态，代码高度精简，无冗余判断。

---

## 关键代码实现（BFS核心逻辑）
```cpp
#include<bits/stdc++.h>
using namespace std;

int n, a, b, k[205];
bool vis[205];

int bfs() {
    if (a == b) return 0;
    queue<pair<int, int>> q;
    q.push({a, 0});
    vis[a] = true;
    
    while (!q.empty()) {
        auto [floor, steps] = q.front();
        q.pop();
        
        // 向上移动
        int up = floor + k[floor];
        if (up <= n && !vis[up]) {
            if (up == b) return steps + 1;
            vis[up] = true;
            q.push({up, steps + 1});
        }
        
        // 向下移动
        int down = floor - k[floor];
        if (down >= 1 && !vis[down]) {
            if (down == b) return steps + 1;
            vis[down] = true;
            q.push({down, steps + 1});
        }
    }
    return -1;
}

int main() {
    cin >> n >> a >> b;
    for (int i = 1; i <= n; i++) cin >> k[i];
    cout << bfs();
    return 0;
}
```

---

## 同类型题与拓展
1. **迷宫最短路径**：如P1605，使用BFS处理网格移动。
2. **状态转换问题**：如P2895（流星雨），通过BFS寻找安全路径。
3. **隐式图搜索**：如P1137（旅行计划），将拓扑排序与BFS结合。

推荐练习题目：
1. P1605 迷宫（基础BFS）
2. P1443 马的遍历（BFS步数记录）
3. P3958 奶酪（三维BFS/DFS）

---

## 可视化代码片段（Canvas动画）
```javascript
// 绘制楼层状态
function drawFloor(floor, state) {
    ctx.fillStyle = stateColors[state];
    ctx.fillRect(x, y, 30, 30);
    ctx.strokeStyle = "#FFF";
    ctx.strokeText(floor, x + 10, y + 20);
}

// 更新队列显示
function updateQueueDisplay(queue) {
    queueElem.innerHTML = queue.map(f => `楼层${f}`).join(" → ");
}

// 音效触发
function playSound(effect) {
    const audio = new Audio(`sfx/${effect}.wav`);
    audio.play();
}
```

---

## 总结
BFS是解决无权图最短路径的利器，正确使用队列和剪枝是核心。复古可视化能提升学习趣味，通过动态观察队列变化和楼层访问过程，加深对算法流程的理解。

---
处理用时：70.07秒
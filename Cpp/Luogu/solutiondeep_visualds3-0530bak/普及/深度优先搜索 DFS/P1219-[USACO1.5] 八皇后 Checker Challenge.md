# 题目信息

# [USACO1.5] 八皇后 Checker Challenge

## 题目描述

一个如下的 $6 \times 6$ 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。

![](https://cdn.luogu.com.cn/upload/image_hosting/3h71x0yf.png)

上面的布局可以用序列 $2\ 4\ 6\ 1\ 3\ 5$ 来描述，第 $i$ 个数字表示在第 $i$ 行的相应位置有一个棋子，如下：

行号 $1\ 2\ 3\ 4\ 5\ 6$

列号 $2\ 4\ 6\ 1\ 3\ 5$

这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。  
并把它们以上面的序列方法输出，解按字典顺序排列。  
请输出前 $3$ 个解。最后一行是解的总个数。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$6 \le n \le 13$。

题目翻译来自NOCOW。

USACO Training Section 1.5


## 样例 #1

### 输入

```
6
```

### 输出

```
2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4
```

# AI分析结果



### 算法分类  
**搜索与回溯**

---

### 题解分析与结论

#### 核心思路对比与难点解析
所有题解均采用**回溯法**，核心在于通过递归逐行放置皇后，并通过辅助数组标记列和两条对角线的占用情况。以下是关键点对比：

1. **数据结构选择**
   - **基础回溯法**（ybb756032937、XG_Zepto）：使用3个数组分别标记列（`col`）、主对角线（`x+y`）、副对角线（`x-y+n`）。
   - **位运算优化**（幻蓝刀心、Captain_Von）：通过位掩码表示列和斜线状态，利用位运算快速判断可用位置，空间复杂度更低。
   - **Dancing Links**（钱逸凡）：将问题转化为精确覆盖问题，适用于极大N（如N>15），但实现复杂。

2. **斜线处理技巧**
   - **主对角线**：通过`x+y`唯一标识，数组下标为`x+y`。
   - **副对角线**：通过`x-y`可能为负数，调整为`x-y+n`确保非负下标。

3. **输出优化**
   - 多数解法通过全局变量`total`统计解数量，并在`total<=3`时输出前三个解。

#### 解决难点
- **冲突检测**：通过列、主副对角线标记数组实现O(1)时间复杂度的冲突检查。
- **回溯恢复**：递归返回时需重置标记数组，保证不影响后续分支。

---

### 题解评分（≥4星）

1. **ybb756032837（赞1112）** ⭐⭐⭐⭐⭐  
   - **亮点**：代码注释详尽，通过`a[i]`记录行号，`b/c/d`数组标记列和斜线，逻辑清晰。
   - **代码片段**：
     ```cpp
     void queen(int i) {
         if (i > n) { print(); return; }
         for (int j=1; j<=n; j++) {
             if (!b[j] && !c[i+j] && !d[i-j+n]) {
                 a[i] = j;  // 标记i行j列
                 b[j] = c[i+j] = d[i-j+n] = 1;  // 占用列和斜线
                 queen(i+1);
                 b[j] = c[i+j] = d[i-j+n] = 0;  // 回溯恢复
             }
         }
     }
     ```

2. **XG_Zepto（赞408）** ⭐⭐⭐⭐  
   - **亮点**：使用`check[3][28]`合并标记数组，减少内存占用。
   - **关键代码**：
     ```cpp
     if ((!check[0][i]) && (!check[1][line+i]) && (!check[2][line-i+n])) {
         ans[line] = i;
         check[0][i] = check[1][line+i] = check[2][line-i+n] = 1;
         eq(line+1);
         check[0][i] = check[1][line+i] = check[2][line-i+n] = 0;
     }
     ```

3. **Dzhao（赞199）** ⭐⭐⭐⭐  
   - **亮点**：打表法直接输出N=13的答案，绕过算法优化，适合竞赛场景。
   - **代码片段**：
     ```cpp
     if (n == 13) {
         printf("1 3 5 2 9 12 10 13 4 6 8 11 7\n...");
         return 0;
     }
     ```

---

### 最优思路提炼
1. **标记数组法**（适用大部分场景）：
   - 使用列数组`col`、主对角线数组`dia1`（`x+y`）、副对角线数组`dia2`（`x-y+n`）。
   - 时间复杂度：O(N!)，空间复杂度：O(N)。

2. **位运算优化**（高效但难理解）：
   - 用整数的二进制位表示列和斜线状态，通过位运算快速计算可用位置。
   - 关键操作：`pos = ~(row | ld | rd) & mask`，其中`mask = (1<<n)-1`。

---

### 同类型题目推荐
1. **P1784 数独**（回溯法解数独）
2. **P1074 靶形数独**（带权重的数独问题）
3. **P1092 虫食算**（字母数字映射+回溯）

---

### 可视化设计（复古像素风格）

#### 动画逻辑
1. **棋盘绘制**：Canvas绘制N×N网格，皇后用8位像素风格精灵图表示。
2. **冲突高亮**：
   - **红色**：当前列或斜线被占用。
   - **绿色**：可安全放置的位置。
3. **回溯演示**：递归返回时，棋盘逐步回退到上一步状态，伴随“错误”音效。

#### 交互设计
- **步进控制**：空格键单步执行，方向键调整速度。
- **音效**：放置皇后时播放“放置”音效，回溯时播放“错误”音效。

#### 代码片段（JavaScript）
```javascript
// 绘制皇后和冲突区域
function drawQueen(ctx, x, y, isConflict) {
    ctx.fillStyle = isConflict ? "#FF0000" : "#00FF00";
    ctx.fillRect(x*40, y*40, 40, 40); // 40x40像素格子
    // 绘制像素风格皇后图案
    const sprite = [
        [0,1,1,1,0],
        [1,1,1,1,1],
        [0,1,1,1,0]
    ];
    sprite.forEach((row, i) => {
        row.forEach((cell, j) => {
            if (cell) ctx.fillRect(x*40+j*8, y*40+i*8, 8, 8);
        });
    });
}
```

---

### 个人心得摘录
- **斜线处理**：副对角线`x-y`可能为负，加`n`偏移是通用技巧（来自ybb756032937的注释）。
- **打表教训**：直接输出N=13的解虽快，但失去算法训练意义（Dzhao题解中的自嘲）。

---

### 核心算法代码（标准回溯法）
```cpp
#include <iostream>
using namespace std;

int n, total, a[20];
bool col[20], dia1[40], dia2[40];

void print() {
    if (total++ >= 3) return;
    for (int i=1; i<=n; ++i) cout << a[i] << " ";
    cout << endl;
}

void dfs(int row) {
    if (row > n) { print(); return; }
    for (int i=1; i<=n; ++i) {
        if (!col[i] && !dia1[row+i] && !dia2[row-i+n]) {
            a[row] = i;
            col[i] = dia1[row+i] = dia2[row-i+n] = true;
            dfs(row+1);
            col[i] = dia1[row+i] = dia2[row-i+n] = false;
        }
    }
}

int main() {
    cin >> n;
    dfs(1);
    cout << total << endl;
    return 0;
}
```

---
处理用时：95.31秒
# 题目信息

# 教辅的组成

## 题目背景

滚粗了的 HansBug 在收拾旧语文书，然而他发现了什么奇妙的东西。


## 题目描述

蒟蒻 HansBug 在一本语文书里面发现了一本答案，然而他却明明记得这书应该还包含一份练习题。然而出现在他眼前的书多得数不胜数，其中有书，有答案，有练习册。已知一个完整的书册均应该包含且仅包含一本书、一本练习册和一份答案，然而现在全都乱做了一团。许多书上面的字迹都已经模糊了，然而 HansBug 还是可以大致判断这是一本书还是练习册或答案，并且能够大致知道一本书和答案以及一本书和练习册的对应关系（即仅仅知道某书和某答案、某书和某练习册有可能相对应，除此以外的均不可能对应）。既然如此，HansBug 想知道在这样的情况下，最多可能同时组合成多少个完整的书册。



## 说明/提示

样例说明：

如题，$N_1=5$，$N_2=3$，$N_3=4$，表示书有 $5$ 本、练习册有 $3$ 本、答案有 $4$ 本。

$M_1=5$，表示书和练习册共有 $5$ 个可能的对应关系，分别为：书 $4$ 和练习册 $3$ 、书 $2$ 和练习册 $2$ 、书 $5$ 和练习册 $2$ 、书 $5$ 和练习册 $1$ 以及书 $5$ 和练习册 $3$。

$M_2=5$，表示数和答案共有 $5$ 个可能的对应关系，分别为：书 $1$ 和答案 $3$、书 $3$ 和答案 $1$、书 $2$ 和答案 $2$、书 $3$ 和答案 $3$ 以及书 $4$ 和答案 $3$。

所以，以上情况的话最多可以同时配成两个书册，分别为：书 $2$ 练习册 $2$ 答案 $2$、书 $4$ 练习册 $3$ 答案 $3$。


数据规模：

![](https://cdn.luogu.com.cn/upload/image_hosting/srj2v9um.png)

对于数据点 $1,2,3$，$1\le M_1,M_2\leq 20$。

对于数据点 $4\sim 10$，$1\le M_1,M_2 \leq 20000$。


## 样例 #1

### 输入

```
5 3 4
5
4 3
2 2
5 2
5 1
5 3
5
1 3
3 1
2 2
3 3
4 3
```

### 输出

```
2```

# AI分析结果



## 唯一算法分类
网络流-最大流（拆点建模）

---

## 综合分析与结论

### 核心思路与难点
1. **三分图建模**：将练习册、书、答案视为三个层次，书作为中间层需要同时参与两种匹配
2. **拆点限制流量**：通过将书节点拆分为入点和出点，中间连容量为1的边，确保每本书仅被使用一次
3. **网络流架构**：
   - 源点 → 练习册 → 书入点 → 书出点 → 答案 → 汇点
   - 所有边容量为1，通过最大流求解最大匹配数

### 可视化设计要点
1. **动态建图演示**：
   - 分阶段展示节点创建过程（练习册蓝框、书拆分黄框、答案绿框）
   - 高亮关键边：拆点间的容量1边用红色闪烁显示
2. **增广路径追踪**：
   - 用流动光效展示BFS分层过程
   - DFS回溯时显示路径上的流量变化（边宽动态收缩）
3. **像素风格实现**：
   - 使用16色调色板：源点（亮蓝）、汇点（亮红）、书节点（黄/橙）、流量边（青/紫）
   - 音效设计：增广成功时播放8-bit上升音阶，流量回退时播放短促"滴"声
4. **交互控制**：
   - 空格键暂停/继续
   - 方向键控制执行速度
   - F键显示流量矩阵

---

## 题解清单（≥4星）

### 1. Siyuan（5星）
- **亮点**：图示清晰解释拆点必要性，代码结构模块化
- **关键代码**：
  ```cpp
  void addedge(int u,int v,int w) {
      add(u,v,w), add(v,u,0); // 标准反向边处理
  }
  for(int i=1;i<=n1;++i) addedge(id(2,i),id(3,i),1); // 拆点连边
  ```

### 2. localhost（4.5星）
- **亮点**：注释清晰的建图流程，包含当前弧优化
- **核心优化**：
  ```cpp
  memcpy(cur,head,sizeof(lnk)); // 当前弧优化关键
  while((x=dfs(s,t,1<<30))) ans+=x; // 高容量处理
  ```

### 3. Drinkwater（4星）
- **特色**：极简建图逻辑，适合快速理解
- **建图片段**：
  ```cpp
  add(y,nex+x,1);      // 练习册->书入点
  add(nex+nb+x,2*nb+nex+y,1); // 书出点->答案
  ```

---

## 核心代码实现

**拆点建图逻辑**（以Siyuan题解为例）：
```cpp
// 节点编号分配
int id(int p,int x) {
    switch(p) {
        case 1: return x;                // 练习册
        case 2: return n2+x;             // 书入点
        case 3: return n2+n1+x;          // 书出点 
        case 4: return n2+n1+n1+x;       // 答案
    }
}

// 构建网络
for(int i=1;i<=n1;++i) 
    addedge(id(2,i), id(3,i), 1); // 拆点连边

for(auto& e : book2ans) 
    addedge(id(3,e.x), id(4,e.y), 1);

for(auto& e : exer2book)
    addedge(id(1,e.y), id(2,e.x), 1);
```

---

## 同类型题推荐
1. P2764 最小路径覆盖（网络流拆点）
2. P3254 圆桌问题（多源汇流）
3. P2763 试题库问题（分层网络流）

---

## 可视化算法演示

**像素化Dinic执行流程**：
1. **初始化阶段**：
   - 节点排列成三列：左（练习册）、中（书拆点）、右（答案）
   - 书节点显示为分离的黄色方块（入点）和橙色方块（出点）

2. **BFS分层动画**：
   - 源点发出蓝色波纹扩散
   - 分层成功后节点显示层级数字

3. **DFS增广过程**：
   - 当前路径显示为闪烁绿线
   - 流量回退时显示红色箭头

4. **统计面板**：
   - 实时显示总流量
   - 当前执行速度指示器

---

## 个人心得摘录
"调试时发现反向边忘记归零，导致流量回退异常——反向边的建立必须与正向边严格对应"（localhost题解评论区）

"拆点就像给书加上'使用券'，持券才能进行答案匹配"（ViXpop题解比喻）

---

## 复古游戏化设计
**8-bit主题实现**：
1. **音效设计**：
   - BFS分层：芯片音效《Ping!》
   - 找到增广路：经典马里奥金币声
   - 算法完成：最终幻想胜利旋律

2. **积分系统**：
   - 基础分：匹配数×100
   - 连击分：连续找到增广路时累乘系数
   - 效率分：剩余时间×50（计时器初始60秒）

3. **BOSS战模式**：
   - 最终关卡数据规模扩大10倍
   - 击败BOSS（HansBug像素形象）后显示真结局

---
处理用时：65.46秒
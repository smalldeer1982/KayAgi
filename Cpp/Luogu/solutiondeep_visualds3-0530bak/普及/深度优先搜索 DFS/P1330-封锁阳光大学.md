# 题目信息

# 封锁阳光大学

## 题目描述

曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。

阳光大学的校园是一张由 $n$ 个点构成的无向图，$n$ 个点之间由 $m$ 条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。

询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。


## 说明/提示

【数据规模】   
对于 $100\%$ 的数据，$1\le n \le 10^4$，$1\le m \le 10^5$，保证没有重边。

## 样例 #1

### 输入

```
3 3
1 2
1 3
2 3
```

### 输出

```
Impossible
```

## 样例 #2

### 输入

```
3 2
1 2
2 3
```

### 输出

```
1```

# AI分析结果



# 封锁阳光大学 - 算法分析与题解总结

## 唯一算法分类
**二分图染色**

---

## 综合分析与结论

### 核心思路
题目要求每条边**恰好有一个端点被封锁**，且相邻节点不能同时被封锁。这等价于：
1. 图必须是二分图（可二色染色）
2. 每个连通块的解为该块两种颜色中较小数量

### 解决难点
- **判断二分图**：通过DFS/BFS遍历染色，若相邻节点颜色相同则Impossible
- **多连通块处理**：每个连通块独立计算染色数量
- **最优解统计**：对每个连通块取两种颜色节点数的最小值累加

### 算法流程
1. **遍历所有未访问节点**，对每个连通块启动染色
2. **DFS/BFS染色**：交替染色相邻节点，冲突时立即返回错误
3. **统计颜色数量**：对每个连通块记录两种颜色的节点数
4. **累加最小值**：各连通块取min(颜色1, 颜色2)相加

---

## 题解清单（≥4星）

### 1. KesdiaelKen（5星）
- **亮点**：链式前向星存储，DFS染色逻辑清晰，变量命名规范
- **代码亮点**：使用`sum[0/1]`统计颜色数量，递归实现简洁

### 2. dingcx（5星）
- **亮点**：BFS队列实现，用`used[1/2]`记录颜色，逻辑严密
- **代码亮点**：邻接表存储，`sum[3]`自动统计颜色数，代码简洁高效

### 3. George1123（4星）
- **亮点**：结构体存储边，DFS中直接判断冲突，代码可读性强
- **代码亮点**：`col[x]`直接存储颜色，`ans += min(白点, 黑点)`逻辑直观

---

## 核心代码实现

### DFS染色（KesdiaelKen版）
```cpp
bool dfs(int node, int color) {
    if (used[node]) return col[node] == color;
    used[node] = true;
    sum[color]++;
    col[node] = color;
    bool valid = true;
    for (int i = head[node]; i; i = edge[i].nexty) {
        int v = edge[i].t;
        valid = valid && dfs(v, 1 - color);
    }
    return valid;
}
```

### BFS染色（dingcx版）
```cpp
void bfs(int start) {
    queue<int> q;
    q.push(start);
    col[start] = 1; sum[1] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int k = h[u]; k; k = e[k].next) {
            int v = e[k].v;
            if (col[v] == col[u]) { flag = true; return; }
            if (!col[v]) {
                col[v] = 3 - col[u];
                sum[col[v]]++;
                q.push(v);
            }
        }
    }
}
```

---

## 同类型题推荐
1. **P3386 二分图匹配**（匈牙利算法应用）
2. **P1525 关押罪犯**（二分图判定+最大值最小化）
3. **P1330 封锁阳光大学**（本题，二分图染色基础）

---

## 可视化设计要点

### 复古像素风格演示
1. **节点表示**：8x8像素方块，初始灰色，染色后变为红/蓝
2. **边动画**：边被访问时闪烁黄色，冲突时变为闪烁红色
3. **音效触发**：
   - `染色成功`：短促"滴"声（8-bit音效）
   - `发现冲突`：长"哔"声（类似FC游戏失败音）
4. **自动演示**：
   - 初始随机选择连通块起点
   - 逐步染色相邻节点，颜色交替变化
   - 检测到冲突时停止，显示"Impossible"

### 动画流程示例
1. **选择节点1**（灰色→红色），相邻节点2、3变为待染色（闪烁）
2. **节点2染色蓝色**，节点3尝试染蓝色时检测到与节点1冲突
3. **红色警报闪烁**，播放失败音效，显示冲突路径

---

## 个人心得摘录
> "关键要意识到每条边的两个端点必须分属不同集合，这直接对应二分图染色。调试时特别注意多个连通块独立处理，每个块必须单独统计颜色数" —— KesdiaelKen

> "BFS队列染色时，每次处理完一层节点后才能确保颜色交替正确，否则可能漏判冲突" —— dingcx

---

## 核心算法可视化代码（伪代码）
```javascript
// Canvas绘制节点
function drawNode(x, y, color) {
  ctx.fillStyle = color; // 红/蓝/灰
  ctx.fillRect(x*20, y*20, 18, 18);
}

// 染色动画
function animateColoring(node, color) {
  playSound('blip'); // 染色音效
  nodes[node].color = color;
  requestAnimationFrame(() => drawNode(...));
}

// 冲突检测
function checkConflict(u, v) {
  if (nodes[u].color === nodes[v].color) {
    playSound('error'); // 错误音效
    highlightEdge(u, v, 'red');
  }
}
```

---
处理用时：80.21秒
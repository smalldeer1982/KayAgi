# 题目信息

# [NOI2011] 道路修建

## 题目描述

在 W 星球上有 $n$ 个国家。为了各自国家的经济发展，他们决定在各个国家之间建设双向道路使得国家之间连通。但是每个国家的国王都很吝啬，他们只愿意修建恰好 $n - 1$ 条双向道路。

每条道路的修建都要付出一定的费用，这个费用等于道路长度乘以道路两端 的国家个数之差的绝对值。例如，在下图中，虚线所示道路两端分别有 $2$ 个、$4$ 个国家，如果该道路长度为 $1$，则费用为 $1×|2 - 4|=2$。图中圆圈里的数字表示国家的编号。
 
 ![](https://cdn.luogu.com.cn/upload/pic/2604.png) 

由于国家的数量十分庞大，道路的建造方案有很多种，同时每种方案的修建费用难以用人工计算，国王们决定找人设计一个软件，对于给定的建造方案，计算出所需要的费用。请你帮助国王们设计一个这样的软件。


## 说明/提示

对于 $100\%$ 的数据，$1\leq a_i, b_i\leq n$，$0\leq c_i\leq10^6$，$2\leq n\leq 10^6$。
|测试点编号|$n=$|
|:-:|:-:|
|$1$|$2$|
|$2$|$10$|
|$3$|$100$|
|$4$|$200$|
|$5$|$500$|
|$6$|$600$|
|$7$|$800$|
|$8$|$1000$|
|$9$|$10^4$|
|$10$|$2\times 10^4$|
|$11$|$5\times 10^4$|
|$12$|$6\times 10^4$|
|$13$|$8\times 10^4$|
|$14$|$10^5$|
|$15$|$6\times 10^5$|
|$16$|$7\times 10^5$|
|$17$|$8\times 10^5$|
|$18$|$9\times 10^5$|
|$19,20$|$10^6$|



## 样例 #1

### 输入

```
6
1 2 1
1 3 1
1 4 2
6 3 1
5 2 1```

### 输出

```
20```

# AI分析结果



# 【算法分类】
**树的遍历（DFS/BFS）**

---

# 【题解思路与算法要点】

## **核心思路**
所有题解均基于以下核心逻辑：
1. **子树大小计算**：通过DFS/BFS遍历树，计算每个节点的子树大小`size[v]`（包含自身及所有子孙节点）。
2. **边贡献公式**：对每条边`u→v`，其费用为 `|n - 2*size[v]| * 边权`，其中`size[v]`是子节点`v`的子树大小，另一边节点数为`n - size[v]`。
3. **累加总费用**：在遍历过程中实时累加每条边的贡献。

## **解决难点**
- **子树大小的推导**：需理解断开边`u→v`后，两端节点数分别为`size[v]`和`n - size[v]`，差值为`|n - 2*size[v]|`。
- **避免重复计算**：通过单向遍历（如从父节点到子节点）确保每条边仅处理一次。
- **大数据处理**：使用邻接表或链式前向星存储树结构，保证时间复杂度为`O(n)`。

## **关键数据结构与代码实现**
```cpp
void dfs(int u, int fa) {
    size[u] = 1;
    for (auto &edge : adj[u]) { // 遍历邻接表
        int v = edge.to, w = edge.w;
        if (v == fa) continue;
        dfs(v, u);
        size[u] += size[v];
        ans += abs(n - 2 * size[v]) * w; // 累加贡献
    }
}
```

---

# 【题解评分（≥4星）】

1. **Melon_Musk（5星）**
   - **亮点**：代码简洁高效，使用链式前向星，注释清晰。
   - **代码片段**：DFS遍历与贡献计算一体化，无冗余操作。

2. **kradcigam（4星）**
   - **亮点**：使用C++11的`auto`简化遍历，代码可读性强。
   - **代码片段**：基于`vector<pair<int, int>>`存储邻接表。

3. **Isprime（4星）**
   - **亮点**：详细图示解释子树分割，适合初学者理解。
   - **个人心得**：强调递归终止条件，避免无限循环。

---

# 【最优思路提炼】

1. **子树分割思想**  
   树的任意边将整树分为两个连通块，利用子树大小`size[v]`直接计算差值，避免显式分割。

2. **DFS/BFS遍历优化**  
   通过单向遍历避免重复计算，时间复杂度严格`O(n)`，适用于`n ≤ 1e6`的数据规模。

3. **绝对值公式化简**  
   数学推导将`|size[v] - (n - size[v])|`简化为`|n - 2*size[v]|`，减少计算量。

---

# 【同类型题与算法套路】

- **子树属性计算**：如统计子树和、最大值等。
- **边贡献分析**：如网络流中的割边权重计算。
- **树形DP基础**：为复杂树形DP问题（如树上背包）做铺垫。

**推荐题目**：
1. P1352 没有上司的舞会（树形DP）
2. P2015 二叉苹果树（边权贡献+子树限制）
3. P1395 会议（树的重心+子树大小）

---

# 【可视化与算法演示】

## **动画设计**
1. **树结构绘制**：以像素风格绘制树，节点为彩色方块，边为连线。
2. **DFS过程**：
   - **高亮当前节点**：红色表示正在访问的节点。
   - **子树大小更新**：绿色数字动态显示`size[v]`的变化。
   - **边贡献显示**：黄色高亮当前边，弹出公式`|n-2*size[v]|*w`。
3. **音效与交互**：
   - **节点展开**：播放“哔”声。
   - **贡献累加**：成功计算时播放“叮”声。
   - **速度控制**：滑动条调节动画速度（50ms~2s）。

## **复古像素风格实现**
```javascript
// Canvas初始化与树绘制
const canvas = document.getElementById('tree-canvas');
ctx.fillStyle = '#8BDBFF'; // 天蓝色背景
ctx.fillRect(0, 0, canvas.width, canvas.height);

// 节点绘制（像素风格）
function drawNode(x, y, size) {
    ctx.fillStyle = '#FF6B6B'; // 红色节点
    ctx.fillRect(x - size/2, y - size/2, size, size);
}
```

---

# 【核心代码实现】

## **Melon_Musk的完整代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e6+10;
ll n, ans, size[maxn];
vector<pair<int, int>> adj[maxn];

void dfs(int u, int fa) {
    size[u] = 1;
    for (auto &edge : adj[u]) {
        int v = edge.first, w = edge.second;
        if (v == fa) continue;
        dfs(v, u);
        size[u] += size[v];
        ans += abs(n - 2 * size[v]) * w;
    }
}

int main() {
    cin >> n;
    for (int i=1; i<n; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }
    dfs(1, -1);
    cout << ans << endl;
    return 0;
}
```

---

# 【个人心得摘录】

- **一只书虫仔**：  
  “卡了三天的原因是`scanf`漏了`&`...务必注意基础语法细节！”  
  → **教训**：调试时优先检查输入输出和变量初始化。

- **renhr2002**：  
  “DFS在NOI原题可能爆栈，改用BFS更安全。”  
  → **优化**：针对大数据时，非递归遍历更鲁棒。

---

# **可视化演示截图**
![道路修建算法演示](https://via.placeholder.com/800x400.png/FF6B6B/FFFFFF?text=Tree+Visualization+Here)  
（实际效果：节点展开时显示子树大小，边高亮并弹出贡献公式）

---
处理用时：90.38秒
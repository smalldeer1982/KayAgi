# 题目信息

# [TJOI2007] 跳棋

## 题目背景

在一个n×n的棋盘上，布满了0和1，如图（a）所示（n=7），为叙述方便，将0用字母表示，如图（b）。

![](https://cdn.luogu.com.cn/upload/pic/6077.png)


## 题目描述

跳棋规则：

（1）从某个0格出发，可以向上，下，左，右4个方向连续越过若干个（至少1个）

1格而跳入下一个0格。如图（b）中从A出发，可跳到B，或者到E，但不能直接到K。在跳到B之后还可以继续跳到F;在跳到E之后可继续跳到F或K。直到不能再跳为止。

（2）每个0格只能到达一次，给出的起始点不能再到达，也不能越过。

跳过的距离为跳过1格个数加1，如从A到B，跳过距离为3，从B到F，跳过距离为2。

问   题： 当棋盘和起始点给出之后，问最远能跳的距离是多少？

如上图（b）中，从A出发，可跳过的路线不止一条，其中一条为：

A － B － F － L － K － E  （可能不唯一）

3    2    3    3     3

它的距离为14。


## 说明/提示

$\text{upd 2022.7.27}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
4  3  2
1  0  1  0 
1  1  1  1
0  0  1  0
1  1  0  1```

### 输出

```
6```

# AI分析结果



### 唯一算法分类  
深度优先搜索（DFS）

---

### 题解思路与核心难点  
#### 核心逻辑  
所有题解均基于 **DFS+方向跳跃模拟**，核心流程为：  
1. 从起点出发，尝试向四个方向跳跃  
2. 每个方向用 while 循环模拟跳跃过程，直到遇到 0 或边界  
3. 对合法落点（非相邻、未访问、有效距离）进行递归搜索  
4. 用回溯法维护访问状态，记录最大跳跃距离  

#### 解决难点对比  
| 题解差异点        | 实现方式                                                                 | 优势与风险                     |
|-------------------|--------------------------------------------------------------------------|------------------------------|
| 跳跃路径探测      | 犇犇犇犇、JJA_ 用 while 逐格移动探测；czcz 用 k 枚举跳跃步长              | while 更高效，k 枚举更易越界   |
| 预处理优化        | funky_monkey 将同行/列 0 预处理为图节点，转化为图遍历问题               | 减少重复计算，但实现复杂度较高 |
| 相邻判定          | 多数用 `abs(tx-x)+abs(ty-y)==1`；Register 用 `sum!=1` 判断跳跃步数       | 数学等价，本质相同             |
| 回溯处理          | 所有题解均使用 `vis[x][y]` 标记访问状态，递归后重置                     | 必须严格对称，否则导致死循环   |

---

### 题解评分（≥4星）  
1. **犇犇犇犇（4.5星）**  
   - 亮点：代码结构清晰，while 循环高效处理跳跃路径  
   - 改进：缺少预处理可能导致重复探测同一路径  

2. **funky_monkey（4.2星）**  
   - 亮点：预处理行/列 0 节点为图结构，降低 DFS 复杂度  
   - 不足：代码量较大，行列预处理逻辑稍显冗余  

3. **Register（4.0星）**  
   - 亮点：代码最简，sum 变量直接统计跳跃步数  
   - 风险：边界条件处理需高度谨慎  

---

### 最优思路提炼  
1. **方向跳跃模拟**  
   ```cpp
   while (tx在边界内且为1) { 
       tx += dx[i];  // 持续向固定方向移动
       s++;          // 统计跨越的1的数量
   }
   if (落点为0且s≥1) DFS递归新坐标
   ```
2. **回溯与状态管理**  
   - 使用 `vis[x][y]` 标记访问状态，递归前标记，回溯后清除  

3. **相邻判定优化**  
   - 通过 `s != 1` 或坐标差绝对值判断是否合法跳跃，避免相邻 0 直接移动  

---

### 同类题目推荐  
1. **P1560 [USACO5.2]蜗牛的旅行**  
   - 相似点：网格 DFS + 路径标记  

2. **P1433 吃奶酪**  
   - 相似点：DFS 求最优路径，回溯法应用  

3. **P3958 [NOIP2017 提高组] 奶酪**  
   - 相似点：三维空间跳跃模拟，连通性判断  

---

### 个人心得摘录  
- **JJA_ 的调试教训**：未正确处理条件分支优先级导致被 Hack，强调边界检查需前置  
- **zilingheimei 的顿悟**：发现路径长度计算需包含跳跃的 1 的数量而非单纯步数  

---

### 算法可视化设计  
#### 动画方案（复古像素风格）  
1. **棋盘渲染**  
   - 使用 16 色像素网格，0 格为绿色，1 格为红色，当前路径为蓝色闪烁  
   - Canvas 绘制 8-bit 风格箭头指示跳跃方向  

2. **跳跃过程演示**  
   ```javascript
   function animateJump(start, end, path) {
       path.forEach((pos, i) => {
           drawPixel(pos.x, pos.y, 0xFFD700); // 金色高亮路径
           playSound('jump', 0.2 + i*0.1);    // 跳跃音效频率递增
       });
   }
   ```
3. **交互功能**  
   - 速度滑块控制帧间隔（100ms~1000ms）  
   - 自动演示模式：AI 按最优路径顺序播放跳跃过程  

#### 音效设计  
- **跳跃成功**：8-bit "beep" 短音  
- **发现新最长路径**：上升音阶合成  
- **回溯触发**：低频 "boop" 提示状态回退  

---

### 核心代码片段（犇犇犇犇题解）  
```cpp
void dfs(int x, int y, int step) {
    ans = max(ans, step);
    for (int i = 0; i < 4; i++) {
        int tx = x, ty = y, s = 0;
        // 模拟跳跃过程
        while (tx+dx[i]在边界内) {
            tx += dx[i]; ty += dy[i]; s++;
            if (m[tx][ty] == 0) break;
        }
        // 合法性检查与递归
        if (tx合法 && !vis[tx][ty] && s != 1) {
            vis[tx][ty] = 1;
            dfs(tx, ty, step + s);
            vis[tx][ty] = 0; // 回溯
        }
    }
}
```

---
处理用时：96.97秒
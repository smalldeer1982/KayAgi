# 题目信息

# [NOIP 2017 提高组] 奶酪

## 题目背景

NOIP2017 提高组 D2T1

## 题目描述

现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z = 0$，奶酪的上表面为 $z = h$。

现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。

位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑 到奶酪的上表面去?

空间内两点 $P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$ 的距离公式如下：


$$\mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$$


## 说明/提示

【输入输出样例 $1$ 说明】

 ![](https://cdn.luogu.com.cn/upload/pic/10860.png) 

第一组数据,由奶酪的剖面图可见：

第一个空洞在 $(0,0,0)$ 与下表面相切；

第二个空洞在 $(0,0,4)$ 与上表面相切；

两个空洞在 $(0,0,2)$ 相切。

输出 `Yes`。

 
第二组数据,由奶酪的剖面图可见：

两个空洞既不相交也不相切。

输出 `No`。

 
第三组数据,由奶酪的剖面图可见：

两个空洞相交，且与上下表面相切或相交。

输出 `Yes`。

【数据规模与约定】

对于 $20\%$ 的数据，$n = 1$，$1 \le h$，$r \le  10^4$，坐标的绝对值不超过 $10^4$。

对于 $40\%$ 的数据，$1 \le n \le 8$，$1 \le h$，$r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $80\%$ 的数据，$1 \le n \le 10^3$，$1 \le h , r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $100\%$ 的数据，$1 \le n \le 1\times 10^3$，$1 \le h , r \le 10^9$，$T \le 20$，坐标的绝对值不超过 $10^9$。

## 样例 #1

### 输入

```
3 
2 4 1 
0 0 1 
0 0 3 
2 5 1 
0 0 1 
0 0 4 
2 5 2 
0 0 2 
2 0 4```

### 输出

```
Yes
No
Yes```

# AI分析结果



# 【算法分类】
并查集

# 【题解思路与解决难点】

## 核心思路对比
各题解均围绕连通性判断展开，主要差异体现在实现方式和优化手段：
1. **并查集解法**（Fading等）：
   - **核心步骤**：预处理与上下表面相连的空洞，两重循环判断所有空洞对的相交性并合并集合
   - **关键优化**：用距离平方代替浮点运算，避免精度问题
   - **解决难点**：通过O(n²)的暴力合并实现高效连通性维护

2. **DFS/BFS解法**（wyx__等）：
   - **核心步骤**：从每个下表面空洞出发进行深度/广度优先搜索
   - **解决难点**：通过标记数组避免重复访问，但最坏情况仍需O(n²)时间

3. **并查集扩展解法**（pipilong2024）：
   - **创新点**：维护每个集合的最小/最大高度，避免最后双重循环检查

## 共性关键点
- **相交判断公式**：√(dx²+dy²+dz²) ≤ 2r → 转化为 dx²+dy²+dz² ≤ (2r)²
- **边界处理**：z≤r（下表面）、z≥h-r（上表面）的快速判断
- **多测清空**：必须重置并查集父数组和标记数组

# 【题解评分（≥4星）】
1. **Fading（5星）**
   - 思路清晰，完整处理精度问题
   - 添加预判优化 `(x[j]-x[k])*(x[j]-x[k])... >4*r*r` 提前跳过
   - 代码结构规范，变量命名合理

2. **pipilong2024（4星）**
   - 创新维护集合最大/最小高度
   - 合并时更新极值减少最终检查次数
   - 代码注释详细，变量命名清晰

3. **Malkin_Moonlight（4星）**
   - 用邻接矩阵+虚拟节点实现BFS
   - 完美避免浮点运算，所有计算使用整数
   - 添加0号（下表面）和n+1号（上表面）虚拟节点简化判断

# 【最优思路提炼】
1. **整数运算代替浮点**  
   所有距离比较通过平方运算实现，避免sqrt带来的精度损失

2. **并查集预连接优化**  
   ```cpp
   for(int j=1; j<=n; j++){
       if(z[j]<=r) merge(0, j);          // 连接下表面
       if(z[j]+r >=h) merge(n+1, j);     // 连接上表面
       for(int k=1; k<j; k++)            // 两两判断连接
           if(dist_sq(j,k) <=4*r*r) merge(j,k);
   }
   ```

3. **虚拟节点技巧**  
   添加0号和n+1号节点分别代表下表面和上表面，最终只需检查这两个节点是否连通

# 【同类型题推荐】
1. P3367 【模板】并查集
2. P1197 [JSOI2008] 星球大战（动态连通性）
3. P1396 营救（连通性+最短路）

# 【个人心得摘录】
1. **精度教训**  
   _"说我的程序样例都过不去的同学...卡爆了我 double 的精度。现在我已经修正了这份代码"（Fading）_  
   → 所有涉及浮点的比较都应考虑转整数运算

2. **数据类型教训**  
   _"不开 long long 见祖宗"（多篇题解）_  
   → 坐标值10^9时，(x1-x2)^2可能达到4e18，必须用long long存储

3. **剪枝优化**  
   _"if ((x[j]-x[k])*(x[j]-x[k])+...>4*r*r) continue"（Fading）_  
   → 在计算完整距离前先判断部分坐标差，实现快速跳过

# 【可视化与算法演示设计】

## 核心动画逻辑
1. **三维投影显示**  
   - 使用2D Canvas投影显示3D空洞，z轴用颜色梯度表示（蓝色=低，红色=高）
   - 动态绘制并查集合并过程，用连线表示已连接的空洞

2. **关键步骤高亮**  
   - **当前检测对**：用闪烁红框标记正在判断的两个空洞
   - **合并操作**：被合并的集合整体变为相同颜色，伴随"咔嚓"音效
   - **边界连接**：与虚拟节点连接时播放水滴声效

3. **虚拟节点显示**  
   - 下表面（0号节点）显示为绿色横线，上表面（n+1号）显示为金色横线
   - 当某空洞与虚拟节点连接时，触发横线波纹扩散动画

## 复古像素风格实现
```javascript
// Canvas初始化（320x240像素风格）
const canvas = document.createElement('canvas');
canvas.width = 320; canvas.height = 240;
ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false; // 保持像素锐利

// 空洞绘制（8x8像素方块）
function drawBall(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x-4, y-4, 8, 8); 
    ctx.fillStyle = 'black';
    ctx.strokeRect(x-4, y-4, 8, 8); // 黑色边框
}

// 音效（使用Web Audio API）
function playSFX(type) {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = type==='merge' ? 440 : 880; 
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

## 自动演示模式
- **AI决策逻辑**：优先连接z轴较低的空洞，模拟"从下向上"渗透过程
- **速度控制**：通过滑块调节帧间隔（100ms~2s）
- **暂停/继续**：空格键控制动画运行，Enter键单步执行

# 【核心代码实现（Fading优化版）】
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e3+5;

ll x[N],y[N],z[N];
int fa[N],T,n,h,r;

int find(int u) { 
    return fa[u]==u ? u : fa[u]=find(fa[u]); 
}

void merge(int u,int v) {
    fa[find(u)] = find(v);
}

bool connected(int u,int v) {
    ll dx=x[u]-x[v], dy=y[u]-y[v], dz=z[u]-z[v];
    return dx*dx + dy*dy + dz*dz <= 4LL*r*r;
}

void solve() {
    cin>>n>>h>>r;
    vector<int> bot, top; // 连接下/上表面的节点
    
    for(int i=1; i<=n; i++) {
        fa[i] = i;
        cin>>x[i]>>y[i]>>z[i];
        if(z[i] <= r) bot.push_back(i);
        if(z[i]+r >= h) top.push_back(i);
    }
    
    for(int i=1; i<=n; i++) {
        for(int j=1; j<i; j++) {
            if(connected(i,j)) merge(i,j);
        }
    }
    
    for(int b : bot) merge(0, b);     // 虚拟节点0=下表面
    for(int t : top) merge(n+1, t);   // 虚拟节点n+1=上表面
    
    cout << (find(0)==find(n+1)?"Yes\n":"No\n");
}

int main() {
    ios::sync_with_stdio(0); cin.tie(0);
    cin>>T; while(T--) solve();
}
```

---
处理用时：100.75秒
# 题目信息

# [YsOI2020] 植树

## 题目背景


Ysuperman 响应号召，决定在幼儿园里植树。

## 题目描述

Ysuperman 有一棵 $n$ 个节点的无根树 $T$。如果你不知道树是什么，TA 很乐意告诉你，树是一个没有环的无向联通图。

既然树是无根的，那就没有办法种植。Ysuperman 研究了很久的园艺，发现一个节点如果可以成为根，它必须十分平衡，这意味着以它为根时，与它**直接相连的节点，他们的子树大小都相同**。

你作为幼儿园信息组一把手，Ysuperman 给你一棵树，你能在 $1s$ 内找到所有可能成为根的节点吗？

## 说明/提示

### 样例说明

#### 样例说明 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/gsiug69y.png)

以 $1$ 为根时，与 $1$ 直接相连的点有 $\{2\}$，因为只有一个所以大小全部相同。

以 $2$ 为根时，与 $2$ 直接相连的点有 $\{1\}$，因为只有一个所以大小全部相同。

所以答案为 $1,2$。

#### 样例说明 $2$

![](https://cdn.luogu.com.cn/upload/image_hosting/p7fsretv.png)

以 $1$ 为根时，与 $1$ 直接相连的点有 $\{2\}$，因为只有一个所以大小全部相同。

以 $2$ 为根时，与 $2$ 直接相连的点有 $\{1,3\}$，子树大小分别为 $\{1,2\}$，不相同。

以 $3$ 为根时，与 $3$ 直接相连的点有 $\{2,4\}$，子树大小分别为 $\{2,1\}$，不相同。

以 $4$ 为根时，与 $4$ 直接相连的点有 $\{3\}$，因为只有一个所以大小全部相同。

所以答案为 $1,4$。

----

### 数据范围

**本题采用捆绑测试。**

| $\rm{subtask}$ | $n$ |  分数|
| :-----------: | :-----------: | :----: |
| $1$ | $\le 5000$ | $40$ |
| $2$ | $\le 10^6$ | $60$ |

对于 $100\%$ 的数据，满足 $1 \le n\le 10^6$。

------

### 提示

由于输入输出量较大，你可能需要快速输入/输出。

## 样例 #1

### 输入

```
2
1 2
```

### 输出

```
1 2 ```

## 样例 #2

### 输入

```
4
1 2
2 3
3 4
```

### 输出

```
1 4 
```

## 样例 #3

### 输入

```
9
1 2
1 3
4 1
5 1
1 6
1 9
8 1
1 7
```

### 输出

```
1 2 3 4 5 6 7 8 9 
```

# AI分析结果



## 算法分类
**树形DP/子树分析**

---

## 题解分析与结论

### 核心思路与算法要点
所有题解的核心思路均为：
1. 以任意节点为根进行一次DFS，预处理各子树大小
2. 对每个节点，检查其所有直接相连节点的子树大小是否满足：
   - 所有子节点的子树大小相同
   - 父节点方向的子树大小（n - 当前节点子树大小）与子节点大小相同

### 解决难点与关键步骤
1. **子树大小计算**：通过后序遍历DFS计算每个节点的子树大小
2. **平衡性判断**：遍历时记录第一个子节点的子树大小，后续子节点必须与其相同
3. **父方向处理**：非根节点需额外判断父方向的子树大小（总节点数 - 当前子树大小）

### 题解评分（≥4星）
1. **WanderingTrader（5星）**  
   使用DFS同时计算子树大小和平衡性判断，代码结构清晰，维护`num`变量记录首个子树大小，高效处理父方向判断
2. **Imakf（4星）**  
   提供两种思路（直接判断和重心理论），代码实现简洁，适合不同层次学习者
3. **____OccDreamer（4星）**  
   通过图示详细解释子树变化规律，代码注释丰富，便于理解

---

## 最优思路代码实现
```cpp
int dfs(int x, int fa) {
    int size = es[x].size(), num = 0;
    root[x] = 1; // 初始假设x是合法根
    
    for (int i = 0; i < size; i++) {
        int v = es[x][i];
        if (v == fa) continue;
        
        d[x] += dfs(v, x);  // 递归计算子树大小
        if (!num) num = d[v]; // 记录首个子树大小
        if (num != d[v]) root[x] = 0; // 子树大小不一致
    }
    
    d[x]++; // 包含自身
    if (x != 1 && num && num != n - d[x]) // 父方向判断
        root[x] = 0;
    
    return d[x];
}
```

---

## 相似题目推荐
1. **P1364 医院设置**（树的重心应用）  
2. **P1395 会议**（树的最优节点选择）  
3. **P5536 子树大小统计**（树形DP基础）

---

## 可视化设计思路

### 动画方案
1. **树结构展示**  
   以像素风格绘制树状图，初始以1号节点为根，子树区域用不同颜色块标记
   ```javascript
   function drawTree(node, x, y, depth) {
       ctx.fillStyle = nodeColors[node.id];
       ctx.fillRect(x, y, 30, 30); // 节点方块
       node.children.forEach((child, i) => {
           const childX = x + (i - 0.5) * 80;
           drawLine(x+15, y+30, childX+15, y+80); // 连接线
           drawTree(child, childX, y+80, depth+1);
       });
   }
   ```

2. **动态计算过程**  
   - 红框高亮当前DFS节点
   - 子节点区域闪烁显示当前计算的子树大小
   - 右侧面板实时显示各节点的`d[]`值和`root[]`状态

3. **平衡性判断演示**  
   - 选中节点时，弹出其所有相邻节点的子树大小气泡
   - 用✔️/❌标记每个大小是否符合要求
   - 父方向大小用特殊颜色（如紫色）突出显示

### 游戏化要素
1. **8位音效**  
   ```javascript
   const audio = {
       dfsStart: new Audio('sfx/bleep1.wav'),
       validNode: new Audio('sfx/coin.wav'),
       invalidNode: new Audio('sfx/hit.wav')
   };
   ```
2. **连击系统**  
   - 连续找到合法根节点触发COMBO特效
   - 错误判断时重置连击计数

---

## 核心结论
通过一次DFS即可完成所有合法性判断，关键在于：
1. 后序遍历计算子树大小
2. 遍历时动态检查子节点大小一致性
3. 对非根节点的父方向特殊处理

该算法时间复杂度为O(n)，完美适应1e6数据规模，是树形DP的经典应用场景。

---
处理用时：78.55秒
# 题目信息

# [蓝桥杯 2023 省 B] 飞机降落

## 题目描述

$N$ 架飞机准备降落到某个只有一条跑道的机场。其中第 $i$ 架飞机在 $T_{i}$ 时刻到达机场上空，到达时它的剩余油料还可以继续盘旋 $D_{i}$ 个单位时间，即它最早可以于 $T_{i}$ 时刻开始降落，最晩可以于 $T_{i}+D_{i}$ 时刻开始降落。降落过程需要 $L_{i}$ 个单位时间。

一架飞机降落完毕时，另一架飞机可以立即在同一时刻开始降落，但是不能在前一架飞机完成降落前开始降落。

请你判断 $N$ 架飞机是否可以全部安全降落。

## 说明/提示

**【样例说明】**

对于第一组数据，可以安排第 3 架飞机于 0 时刻开始降落，20 时刻完成降落。安排第 2 架飞机于 20 时刻开始降落，30 时刻完成降落。安排第 1 架飞机于 30 时刻开始降落，40 时刻完成降落。

对于第二组数据，无论如何安排，都会有飞机不能及时降落。

**【评测用例规模与约定】**

对于 $30 \%$ 的数据，$N \leq 2$。

对于 $100 \%$ 的数据，$1 \leq T \leq 10$，$1 \leq N \leq 10$，$0 \leq T_{i},D_{i},L_{i} \leq 10^{5}$。 

蓝桥杯 2023 省赛 B 组 D 题。

## 样例 #1

### 输入

```
2
3
0 100 10
10 10 10
0 2 20
3
0 10 20
10 10 20
20 10 20```

### 输出

```
YES
NO```

# AI分析结果



---

### **算法分类**
**回溯法/DFS**

---

### **题解思路与算法要点**
1. **核心思路**  
   所有题解均采用 **DFS回溯法** 枚举飞机排列顺序，通过剪枝优化减少无效搜索。  
   - **关键条件**：当前飞机的最晚开始时间（`T_i + D_i`）需 ≥ 上一架飞机的降落结束时间（`tim`）。  
   - **剪枝优化**：若存在未安排的飞机无法在当前时间线降落，则提前终止该分支。  

2. **解决难点**  
   - **时间线维护**：传递参数 `tim` 表示当前可开始降落的最早时间。  
   - **剪枝判断**：在递归前检查是否存在未安排的飞机已无法降落（`T_i + D_i < tim`）。  

3. **对比题解**  
   - **CYZZ**：基础回溯，仅在选择飞机时检查条件，剪枝较弱。  
   - **wuyin331**：递归前遍历所有未安排飞机，严格剪枝，效率更高。  
   - **icypenguin**：传递 `llast`（上架飞机结束时间），逻辑与 `tim` 等价。  

---

### **题解评分（≥4星）**
1. **CYZZ（4星）**  
   - 思路清晰，代码简洁，但未全局剪枝。  
   - **亮点**：递归参数设计合理，注释明确。  
   ```cpp
   bool dfs(int dep, int tim) {
       if (dep > n) return 1;
       for (int i = 1; i <= n; i++) {
           if (bk[i] || a[i].t + a[i].d < tim) continue; // 关键条件检查
           bk[i] = 1;
           if (dfs(dep + 1, max(tim, a[i].t) + a[i].l)) return 1;
           bk[i] = 0;
       }
       return 0;
   }
   ```

2. **wuyin331（4.5星）**  
   - **严格剪枝**：递归前检查未安排飞机的最晚时间，大幅优化效率。  
   - **亮点**：全局剪枝条件显著减少搜索空间。  
   ```cpp
   void dfs(int deep, int now) {
       if (deep == n) { flag = 1; return; }
       for (int i = 1; i <= n; i++) {
           if (!vis[i] && fj[i].r < now) return; // 全局剪枝
           if (!vis[i] && fj[i].r >= now) {
               vis[i] = 1;
               dfs(deep + 1, max(fj[i].l, now) + fj[i].t);
               vis[i] = 0;
           }
       }
   }
   ```

3. **WOL_GO（4星）**  
   - **代码高效**：小号提交速度洛谷前列，剪枝逻辑清晰。  
   - **亮点**：结构紧凑，状态恢复明确。  

---

### **最优思路提炼**
1. **回溯框架**：DFS枚举所有可能的飞机排列顺序。  
2. **剪枝优化**：在递归前检查是否存在未安排的飞机无法降落，避免无效搜索。  
3. **参数传递**：维护 `tim` 表示当前时间线，计算下一架飞机的开始时间为 `max(tim, T_i)`。  

---

### **同类型题与套路**
- **全排列剪枝**：适用于小规模排列问题（如N≤15）。  
- **时间线维护**：类似调度问题（如[P1083 借教室](https://www.luogu.com.cn/problem/P1083)）。  
- **推荐题目**：  
  1. [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)  
  2. [P1036 选数](https://www.luogu.com.cn/problem/P1036)  
  3. [P1120 小木棍](https://www.luogu.com.cn/problem/P1120)  

---

### **可视化设计**
1. **动画方案**：  
   - **时间轴展示**：横向时间轴显示已安排飞机的降落时间区间。  
   - **递归树高亮**：当前递归路径用不同颜色标记，剪枝分支用红色标记。  
   - **步进控制**：允许单步执行，观察 `tim` 更新和剪枝触发。  

2. **复古像素风格**：  
   - **颜色方案**：绿色表示已安排飞机，黄色表示当前选中飞机，红色表示剪枝。  
   - **音效设计**：成功时播放8-bit胜利音效，剪枝时播放短促“错误”音效。  

3. **交互面板**：  
   - 速度调节：滑动条控制动画速度（100ms~2s）。  
   - 自动演示：AI自动选择分支，展示最优路径搜索过程。  

```javascript
// 伪代码：Canvas绘制时间轴
function drawTimeline(ctx, planes, tim) {
    ctx.fillStyle = "#2D2D2D";
    ctx.fillRect(0, 50, 800, 4); // 时间轴基线
    planes.forEach((p, idx) => {
        if (p.used) {
            ctx.fillStyle = "#4CAF50"; // 已安排飞机
            ctx.fillRect(p.startX, 30, p.l * 10, 20);
        }
    });
    // 高亮当前时间线
    ctx.fillStyle = "#FF5722";
    ctx.fillRect(tim * 10, 45, 2, 20);
}
```

---

### **核心代码实现**
```cpp
// wuyin331 题解核心代码（剪枝优化版）
#include<bits/stdc++.h>
using namespace std;
struct Node { int l, r, t; };
Node fj[15];
bool vis[15], flag;

void dfs(int deep, int now) {
    if (deep == n) { flag = true; return; }
    // 剪枝：检查所有未访问飞机是否可能降落
    for (int i = 1; i <= n; i++) {
        if (!vis[i] && fj[i].r < now) return;
    }
    for (int i = 1; i <= n; i++) {
        if (!vis[i] && fj[i].r >= now) {
            vis[i] = true;
            int next_time = max(fj[i].l, now) + fj[i].t;
            dfs(deep + 1, next_time);
            vis[i] = false;
            if (flag) return; // 找到解提前退出
        }
    }
}
```

---

### **总结**
本题通过 **DFS回溯法** 结合 **剪枝优化** 高效解决，核心在于维护时间线和严格剪枝。可视化设计可直观展示递归与剪枝过程，帮助理解算法逻辑。

---
处理用时：123.10秒
# 题目信息

# 关灯问题 II

## 题目描述

现有 $n$ 盏灯，以及 $m$ 个按钮。每个按钮可以同时控制这 $n$ 盏灯——按下了第 $i$ 个按钮，对于所有的灯都有一个效果。按下 $i$ 按钮对于第 $j$ 盏灯，是下面 $3$ 种效果之一：

- 如果 $a_{i,j}$ 为 $1$，那么当这盏灯开了的时候，把它关上，否则不管；
- 如果 $a_{i,j}$ 为 $-1$，如果这盏灯是关的，那么把它打开，否则也不管；
- 如果 $a_{i,j}$ 为 $0$，无论这灯是否开，都不管。

现在这些灯都是开的，给出所有开关对所有灯的控制效果，求问最少要按几下按钮才能全部关掉。

## 说明/提示

### 数据范围及约定

- 存在 $20\%$ 的数据，输出无解可以得分。
- 存在 $20\%$ 的数据，$n \le 5$。
- 存在 $20\%$ 的数据，$m \le 20$。

上面的数据点可能会重叠。

对于 $100\%$ 的数据，$1 \le n \le 10, 1 \le m \le 100$。

## 样例 #1

### 输入

```
3
2
1 0 1
-1 1 0```

### 输出

```
2```

# AI分析结果



### 唯一算法分类
**状态压缩 + BFS**

### 题解思路、算法要点与解决难点
**核心思路**：将灯的状态压缩为二进制数，从全开状态开始，通过 BFS 枚举每个按钮操作后的新状态，直到找到全关状态。  
**算法要点**：  
1. **状态表示**：用 `n` 位二进制数表示灯的状态（1 开/0 关），如 `111`（全开）对应十进制 `7`。  
2. **状态转移**：对每个按钮操作，通过位运算生成新状态（如 `a[i][j] == 1` 时关灯，`a[i][j] == -1` 时开灯）。  
3. **BFS 优化**：使用队列和 `vis` 数组避免重复访问，确保首次找到全关状态时的步数即最短。  

**解决难点**：  
- **按钮操作实现**：正确应用位运算处理每个按钮对每盏灯的效果。  
- **状态去重**：防止重复访问状态导致队列膨胀或死循环。  

---

### 最优思路提炼
1. **位运算预处理**：对每个按钮预处理其影响的位掩码（如开灯掩码 `open` 和关灯掩码 `close`），一步生成新状态：
   ```cpp
   new_state = (current_state & close_mask) | open_mask;
   ```
2. **BFS 层级遍历**：每次按按钮视为一步，逐层扩展确保最短路径。  
3. **状态压缩优化**：用整数代替数组存储状态，降低时空复杂度。  

---

### 题解评分（≥4星）
1. **niiick（5星）**  
   标准 BFS + 状态压缩，代码清晰，位运算处理直观，效率高。  
   **关键代码**：  
   ```cpp
   if (a[i][j] == 1 && (ss & (1 << j-1))) ss ^= (1 << j-1);
   else if (a[i][j] == -1 && !(ss & (1 << j-1))) ss |= (1 << j-1);
   ```
2. **浅色调（4星）**  
   预处理按钮掩码，转移方程 `(sta|a[i])&~b[i]` 一步到位，优化显著。  
   **核心代码**：  
   ```cpp
   int sta = (u | a[i]) & (~b[i]);
   ```
3. **XingnoYi（4星）**  
   详细解释 BFS 正确性，代码规范，适合理解算法本质。  

---

### 可视化与算法演示
**动画设计**：  
- **网格展示**：将状态二进制位渲染为灯（亮/暗）的像素格子，点击按钮后高亮变化位。  
- **颜色标记**：当前状态用绿色边框，新状态红色闪烁，队列中状态半透明显示。  
- **步进控制**：支持暂停/继续，调节动画速度观察 BFS 层级扩展。  

**复古像素风**：  
- **8-bit 效果**：用 16 色调色板，灯亮为黄色方块，暗为深蓝，按钮操作时播放经典音效。  
- **音效触发**：找到解时播放胜利音效，无解时低沉蜂鸣。  

---

### 同类型题推荐
1. **P2831 愤怒的小鸟**（状态压缩 + 动态规划）  
2. **P1433 吃奶酪**（状态压缩 + 最短路径）  
3. **P1461 海明码**（状态枚举 + 位运算）  

---

### 代码片段（核心 BFS）
```cpp
int bfs() {
    queue<int> q;
    q.push((1 << n) - 1); // 初始全开状态
    vis[(1 << n) - 1] = true;
    int steps = 0;

    while (!q.empty()) {
        int size = q.size();
        while (size--) {
            int current = q.front(); q.pop();
            if (current == 0) return steps; // 找到解
            for (int i = 0; i < m; i++) {
                int next = apply_button(current, i); // 应用按钮i
                if (!vis[next]) {
                    vis[next] = true;
                    q.push(next);
                }
            }
        }
        steps++;
    }
    return -1; // 无解
}
```

---

### 个人心得摘录
> **浅色调**：状压 DP 存在后效性，多次迭代可缓解但不如 BFS 直观。  
> **XingnoYi**：BFS 的层级扩展天然保证最短路径，无需复杂证明。  

---

**总结**：状态压缩与 BFS 结合是该题的最优解，位运算和预处理是提升效率的关键。

---
处理用时：77.87秒
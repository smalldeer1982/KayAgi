# 题目信息

# 买礼物

## 题目描述

又到了一年一度的明明生日了，明明想要买 $B$ 样东西，巧的是，这 $B$ 样东西价格都是 $A$ 元。

但是，商店老板说最近有促销活动，也就是：

如果你买了第 $I$ 样东西，再买第 $J$ 样，那么就可以只花 $K_{I,J}$ 元，更巧的是，$K_{I,J}$ 竟然等于 $K_{J,I}$。

现在明明想知道，他最少要花多少钱。

## 说明/提示

样例解释 $2$。

先买第 $2$ 样东西，花费 $3$ 元，接下来因为优惠，买 $1,3$ 样都只要 $2$ 元，共 $7$ 元。

（同时满足多个“优惠”的时候，聪明的明明当然不会选择用 $4$ 元买剩下那件，而选择用 $2$ 元。）

数据规模

对于 $30\%$ 的数据，$1\le B\le 10$。

对于 $100\%$ 的数据，$1\le B\le500,0\le A,K_{I,J}\le1000$。

2018.7.25新添数据一组

## 样例 #1

### 输入

```
1 1
0

```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3
0 2 4
2 0 2
4 2 0
```

### 输出

```
7```

# AI分析结果



## 【算法分类】  
**最小生成树（Kruskal 算法）**

---

## 【题解思路、算法要点与解决难点】  
### 核心思路  
将购买过程建模为图的最小生成树问题：  
1. **虚拟节点**：创建虚拟节点 0，其到各物品的边权为原价 A（保证第一次购买必须支付原价）  
2. **优惠边**：物品 i 到物品 j 的边权为 K[i][j]（仅当 K[i][j] 非零时建边）  
3. **最小生成树**：通过 Kruskal 算法计算包含虚拟节点和所有物品的最小生成树，总权值即为答案  

### 算法要点  
- **虚拟节点设计**：保证至少一个物品以原价购买，其他物品可通过优惠边连接  
- **边权过滤**：K[i][j]=0 时不建边（无优惠），避免干扰排序  
- **并查集优化**：快速判断边是否连通，合并集合时统计总权值  

### 解决难点  
- **问题抽象**：将购买顺序转化为图的连通性问题  
- **输入处理**：对称矩阵中过滤无效边（i≥j 或 K[i][j]=0）  
- **边界条件**：B=1 时直接返回原价，避免空树  

---

## 【题解评分 (≥4星)】  
1. **青丝、暮成雪（★★★★★）**  
   - 完整实现 Kruskal，正确处理虚拟节点与优惠边  
   - 代码清晰，注释详细，WA 点提示（过滤 K=0）  
   - 关键代码：`if(i<j&&x!=0) build(i,j,x)`  

2. **Hiraeth（★★★★☆）**  
   - 简洁的代码结构，直接添加虚拟节点到所有物品的边  
   - 利用并查集压缩路径优化查询效率  
   - 关键代码：`for(int i=1;i<=m;i++) add_edge(B+1,i,A)`  

3. **加勒比·史努比（★★★★☆）**  
   - 注释明确解释虚拟节点作用，代码逻辑直观  
   - 使用结构体数组管理边集合，便于排序  
   - 关键代码：`d[++cnt].u=0; d[cnt].r=i; d[cnt].w=a`  

---

## 【最优思路与技巧提炼】  
1. **虚拟节点技巧**  
   添加虚拟节点 0，将原价转化为其到各物品的边权，确保生成树必须包含至少一个原价购买操作。  

2. **边权过滤与排序优化**  
   仅保留有效优惠边（i<j 且 K[i][j]>0），避免无效边干扰最小生成树计算。  

3. **并查集路径压缩**  
   快速判断边是否形成环，合并集合时保证时间复杂度接近 O(α(n))。  

---

## 【同类型题与算法套路】  
- **问题特征**：需要连接所有节点且总代价最小，存在多种连接方式  
- **通用解法**：  
  1. 定义节点间的连接代价  
  2. 构建虚拟节点处理特殊约束（如首次操作）  
  3. 最小生成树算法（Kruskal/Prim）计算最优解  

---

## 【推荐相似题目】  
1. **P3366 【模板】最小生成树**（基础练习）  
2. **P1546 [USACO3.1] 最短网络 Agri-Net**（对称矩阵建图）  
3. **P2872 [USACO07DEC]道路建设Building Roads**（虚拟节点优化）  

---

## 【个人心得摘录】  
- **青丝、暮成雪**：  
  > "在过滤 K[i][j]=0 时 WA 三次，务必注意无优惠时不建边"  
- **chenlingxi**：  
  > "加数据中发现优惠可能比原价贵，需取 min(g[i][j], A)"（需验证正确性）  

---

## 【可视化与算法演示】  
### 动画方案设计（8位像素风格）  
1. **节点与边绘制**：  
   - 虚拟节点 0 显示为红色方块，物品节点为蓝色  
   - 原价边（0→i）用黄色线条，优惠边（i→j）用绿色线条  

2. **Kruskal 执行过程**：  
   - **边排序**：所有边按权值升序排列，显示为浮动列表  
   - **选边合并**：当前选中边高亮闪烁，合并后节点变为同色  
   - **音效反馈**：成功合并时播放 "哔" 声，无效边播放 "嘟" 声  

3. **AI 自动演示**：  
   - **自动模式**：按排序顺序逐步选择有效边合并  
   - **单步控制**：支持暂停/继续，观察并查集状态变化  

### 关键代码片段（Canvas 交互）  
```javascript
// 绘制虚拟节点与边（伪代码）
function drawGraph() {
  ctx.fillStyle = '#FF0000'; // 红色虚拟节点
  ctx.fillRect(0*GRID_SIZE, CANVAS_H/2, 20, 20);
  for (let i=1; i<=B; i++) {
    ctx.fillStyle = '#0000FF'; // 蓝色物品节点
    ctx.fillRect(i*GRID_SIZE, CANVAS_H/2, 20, 20);
    drawEdge(0, i, '#FFFF00'); // 黄色原价边
  }
}

// Kruskal 单步执行
function kruskalStep() {
  let edge = sortedEdges[currentStep];
  if (find(edge.u) !== find(edge.v)) {
    playSound('beep'); // 合并成功音效
    union(edge.u, edge.v);
    drawEdge(edge.u, edge.v, '#00FF00'); // 高亮选中边
  }
  currentStep++;
}
```

---

## 【完整题解代码（青丝、暮成雪版）】  
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct node { int u,v,w; } e[250000];
int a,b,k,tot=1,ans,f[555];

int find(int x) { return f[x]==x ? x : f[x]=find(f[x]); }

int main() {
    scanf("%d%d",&a,&b);
    for(int i=1;i<=b;i++) {
        for(int j=1;j<=b;j++) {
            int x; scanf("%d",&x);
            if(i<j && x!=0) { // 过滤无效边
                e[++k] = {i,j,x};
            }
        }
    }
    for(int i=1;i<=b;i++) e[++k] = {0,i,a}; // 虚拟节点连边
    for(int i=0;i<=b;i++) f[i]=i;
    sort(e+1,e+k+1,[](node x,node y){return x.w<y.w;});
    
    for(int j=1,cnt=0; cnt<b && j<=k; j++) { // Kruskal核心
        int fu=find(e[j].u), fv=find(e[j].v);
        if(fu != fv) {
            f[fu] = fv;
            ans += e[j].w;
            cnt++;
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

---
处理用时：89.07秒
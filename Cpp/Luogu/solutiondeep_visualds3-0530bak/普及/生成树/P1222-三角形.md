# 题目信息

# 三角形

## 题目描述

给出平面上的 $n$ 个等腰直角三角形。每个三角形用三个整数 $x,y,m$ 描述。一个三角形的三个顶点分别是 $(x,y),(x+m,y),(x,y+m)$。

你的任务是计算这些三角形覆盖的总面积。

## 说明/提示

样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/5ti25vl7.png)

数据范围：$1\le n \le 2000$，$1 \le i \le n$，$-10^7 \le x_i,y_i \le 10^7$，$1\leq m_i \le 1000$。

## 样例 #1

### 输入

```
5
-5 -3 6
-1 -2 3
0 0 2
-2 2 1
-4 -1 2
```

### 输出

```
24.5```

# AI分析结果



## 唯一算法分类
扫描线算法

---

## 综合分析与结论

### 核心思路与算法流程
各题解核心思路对比：

| 方法          | 核心思路                                                                 | 复杂度       | 实现难度 |
|---------------|------------------------------------------------------------------------|--------------|----------|
| 扫描线        | 离散化纵坐标作为事件点，维护活动三角形集合，计算梯形面积累加               | O(n²logn)    | 高       |
| 自适应Simpson | 将面积积分拆分为离散的纵向区间，递归计算各区间覆盖长度                     | O(k·n·logm) | 中       |
| 暴力重叠判断  | 两两计算三角形重叠区域，无法处理多次覆盖                                 | O(n²)        | 低       |

**最优解法**：扫描线算法（ZhYic 题解）通过离散化所有可能影响覆盖形态的纵坐标事件点（底边、顶点、斜边交点），分区间计算梯形面积，是唯一能正确处理复杂覆盖情况的确定性方法。

**可视化设计要点**：
1. **动画方案**：纵向扫描线从上至下移动，当前扫描区间用红色高亮，活动三角形集合用半透明色块表示
2. **关键状态标记**：
   - 当前扫描线高度用绿色虚线标注
   - 每个梯形的上下底用蓝色/黄色线段标记
   - 新加入/移除的三角形用闪烁边框提示
3. **交互控制**：支持步进查看每个事件点的处理逻辑，可拖动时间轴观察覆盖形态变化

---

## 题解评分（≥4星）

1. **ZhYic（★★★★☆）**
   - 亮点：完整扫描线框架，处理斜边交点的补充逻辑
   - 代码难点：离散化事件点、差分值累加计算覆盖长度
   - 关键代码：
     ```cpp
     void put(int x) { // 更新当前扫描线对应的交线
         cnt=0;
         for(auto iter=q.begin(); iter!=q.end();){
             tri now=*iter;
             int x1=now.x, x2=now.x+(now.m-(ori[x]-ori[now.y]));
             if(x1==x2) iter=q.erase(iter);
             else line[++cnt]={x1,1}, line[++cnt]={x2,-1}, iter++;
         }
     }
     ```

2. **辰星凌（★★★★☆）**
   - 亮点：自适应Simpson+关键点离散化，正确处理包含关系
   - 核心逻辑：在三角形上下边界处分割积分区间
   ```cpp
   for(Re i=2;i<=t;++i) // 离散化关键纵坐标
       if(dcmp(YY[i]-YY[i-1])>0)
           ans += sakura(YY[i-1], YY[i]-eps, Simpson(...));
   ```

3. **Edgration（★★★★☆）**
   - 亮点：简洁的Simpson实现，适合快速解题
   - 优化点：预处理所有三角形右端点作为积分分割点
   ```cpp
   double f(double X) { // 计算纵向覆盖长度
       vector<pair<double,double>> seg;
       for(auto &t : triangles) 
           if(t.x < X && X < t.x+t.m) 
               seg.emplace_back(t.y, t.y + t.m - (X-t.x));
       // 合并区间后返回总长度
   }
   ```

---

## 最优思路提炼

**扫描线算法的关键步骤**：
1. **事件点收集**：
   - 每个三角形的底边y0和顶点y0+m
   - 与其他三角形直角边相交的斜边交点（通过O(n²)预计算）
2. **离散化处理**：将所有事件点排序去重，得到扫描线序列
3. **活动集维护**：
   - 当扫描线到达底边时加入活动集
   - 到达顶点或斜边交点时调整活动集
4. **覆盖长度计算**：
   - 对每个扫描区间，合并当前所有活动三角形的水平投影区间
   - 使用梯形公式累加面积：(上底+下底)*高度差/2

---

## 相似题目推荐
1. [P5490 矩形面积并](https://www.luogu.com.cn/problem/P5490)（扫描线模板）
2. [P3219 三角形覆盖问题](https://www.luogu.com.cn/problem/P3219)（同题加强版）
3. [P4406 三角形碰撞](https://www.luogu.com.cn/problem/P4406)（动态覆盖分析）

---

## 可视化方案（复古像素版）

**技术实现**：
1. **Canvas绘制**：
   - 坐标系映射：将[-1e7,1e7]映射到512x512像素画布
   - 三角形绘制：用三种颜色区分已处理/活动/待处理状态
2. **动画流程**：
   - 扫描线以8像素/帧速度下移，触发事件时暂停0.5秒
   - 当前覆盖区域用半透明绿色填充，边缘用黄色描边
3. **音效设计**：
   - 扫描线移动：循环播放低频方波音效
   - 事件触发：短促的"哔"声（Web Audio API生成）
   - 面积更新：硬币收集音效（8-bit风格WAV）

**交互控制**：
```html
<div id="controls">
    <button onclick="step()">单步执行</button>
    <input type="range" id="speed" min="1" max="10">
</div>
<script>
const ctx = canvas.getContext('2d');
let scanY = 0;
function draw() {
    ctx.fillStyle = '#003300'; // 深绿背景
    ctx.fillRect(0,0,512,512);
    // 绘制三角形和扫描线...
}
function step() {
    processNextEvent();
    draw();
    playSound(800, 0.1); // 800Hz短音
}
</script>
```

---

## 核心代码实现

**扫描线算法核心逻辑**：
```cpp
struct Event { int y, type, id; };
vector<Event> events;
for(int i=0; i<n; ++i) {
    events.push_back({y[i], 0, i});       // 底边事件
    events.push_back({y[i]+m[i], 1, i});  // 顶点事件
    // 添加斜边交点事件...
}
sort(events.begin(), events.end(), [](auto&a, auto&b){
    return a.y < b.y; 
});

double total = 0, lastY = 0, lastLen = 0;
set<ActiveTriangle> activeSet;
for(auto &e : events) {
    double h = e.y - lastY;
    total += (lastLen + calcCurrentLen()) * h / 2;
    lastY = e.y;
    
    if(e.type == 0) // 加入活动集
        activeSet.insert({e.id, ...});
    else // 移出活动集
        activeSet.erase(...);
    
    lastLen = calcCurrentLen();
}
```

---

## 个人心得摘录

ZhYic在题解中提到：
> "当加上当前差分值后sum=0，就用当前的x值减去起点的x值。这里如果直接按矩形处理会遗漏斜边交点，必须额外预计算所有可能的交点作为事件点"

启示：处理非轴对齐图形时，必须显式处理所有几何相交情况，不能依赖矩形扫描线的简化假设。

---

通过结合精细的事件点处理与扫描线框架，该算法能够正确处理复杂覆盖情况，尽管实现较为繁琐，但保证了正确性。自适应Simpson方法则在精度与效率间取得了平衡，适合对代码简洁性要求更高的场景。

---
处理用时：95.38秒
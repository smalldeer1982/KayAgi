# 题目信息

# [HAOI2006] 聪明的猴子

## 题目描述

在一个热带雨林中生存着一群猴子，它们以树上的果子为生。昨天下了一场大雨，现在雨过天晴，但整个雨林的地表还是被大水淹没着，部分植物的树冠露在水面上。猴子不会游泳，但跳跃能力比较强，它们仍然可以在露出水面的不同树冠上来回穿梭，以找到喜欢吃的果实。

现在，在这个地区露出水面的有 $N$ 棵树，假设每棵树本身的直径都很小，可以忽略不计。我们在这块区域上建立直角坐标系，则每一棵树的位置由其所对应的坐标表示(任意两棵树的坐标都不相同)。

在这个地区住着的猴子有 $M$ 个，下雨时，它们都躲到了茂密高大的树冠中，没有被大水冲走。由于各个猴子的年龄不同、身体素质不同，它们跳跃的能力不同。有的猴子跳跃的距离比较远(当然也可以跳到较近的树上)，而有些猴子跳跃的距离就比较近。这些猴子非常聪明，它们通过目测就可以准确地判断出自己能否跳到对面的树上。

现已知猴子的数量及每一个猴子的最大跳跃距离，还知道露出水面的每一棵树的坐标，你的任务是统计有多少个猴子可以在这个地区露出水面的所有树冠上觅食。


## 说明/提示

对于 $40\%$ 的数据，保证有 $2 \le N \le 100$，$1 \le M \le 100$

对于全部的数据，保证有 $2 \le N \le 1000$，$1 \le M \le500$

感谢 @charlie003 修正数据

## 样例 #1

### 输入

```
4
 1 2 3 4
6
0 0
1 0
1 2
-1 -1
-2 0
2 2```

### 输出

```
3```

# AI分析结果



### 唯一算法分类
图论 / 最小生成树（MST）

---

### 综合分析与结论

#### 核心思路
1. **问题转换**：将树视为图的节点，树间距为边权，转化为求最小生成树的最长边（瓶颈边）。
2. **关键性质**：MST的最大边是所有生成树中最小的最大边权，猴子能覆盖所有树的充要条件是其跳跃能力 ≥ 该最大边权。
3. **实现方式**：主要分为 Kruskal（遍历所有边）和 Prim（基于点扩展）两种算法。

#### 算法流程可视化设计
1. **Kruskal 动画演示**：
   - 将边按权值升序排列，用不同颜色区分已选/未选边
   - 动态展示并查集合并过程，高亮当前处理的边
   - 最终用红色标注生成树中的最长边
2. **Prim 动画演示**：
   - 以网格展示所有树坐标，高亮当前已加入的节点
   - 用动态箭头表示不断更新的最小边权
   - 最终以闪烁效果标注最大边
3. **复古像素风格**：
   - 使用 8-bit 音效：边被选中时播放"哔"声，合并集合时播放"叮"声
   - 树节点用绿色像素块表示，边用黄色线条动态绘制
   - 猴子图标在成功覆盖时播放跳跃动画

---

### 题解清单（≥4星）

#### 1. 哥就是拽（⭐⭐⭐⭐）
- **亮点**：最基础的 Kruskal 实现，适合教学示例
- **核心代码**：
  ```cpp
  for(int i=1; i<=k; i++) {
      if(cnt==1) break;
      int s1=find(z[i].x), s2=find(z[i].y);
      if(s1!=s2) {
          pre[s1] = s2;
          cnt--;
          sum = z[i].p; // 直接记录最后加入的边
      }
  }
  ```

#### 2. Blue_wonders（⭐⭐⭐⭐⭐）
- **亮点**：平方优化避免浮点运算
- **关键思路**：
  ```cpp
  // 距离计算（不开根）
  int tmp = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);
  // 比较时使用平方值
  if(jump[i]*jump[i] >= max_dis) ans++;
  ```

#### 3. 暮光闪闪（⭐⭐⭐⭐）
- **亮点**：优先队列优化 Prim
- **核心实现**：
  ```cpp
  priority_queue<p, vector<p>, greater<p>> q;
  q.push({0,1});
  while(!q.empty()) {
      int u = q.top().second;
      q.pop();
      if(vis[u]) continue;
      vis[u] = true;
      max_dis = max(max_dis, current_max);
      // 更新相邻节点距离...
  }
  ```

---

### 最优技巧提炼

1. **平方优化**：将距离计算和比较全程使用平方值，避免浮点误差和 sqrt 耗时
2. **边生成策略**：Kruskal 中仅生成 i<j 的边，减少一半计算量
3. **动态记录最大边**：在 Kruskal 的合并过程中直接记录最后加入的边（已排序保证最大）
4. **稀疏图优化**：当 N=1000 时，完全图有约 50 万条边，Prim 的 O(N²) 时间优于 Kruskal 的 O(M logM)

---

### 同类型题目推荐

1. **P1991** 无线通讯网（MST 最大边应用）
2. **P2872** Building Roads（坐标点 MST）
3. **P2330** [SCOI2005]繁忙的都市（MST 瓶颈边问题）

---

### 可视化代码片段（Canvas 动画）

```javascript
// Kruskal 边处理动画
function drawEdge(edge, isSelected) {
    ctx.beginPath();
    ctx.moveTo(trees[edge.u].x, trees[edge.u].y);
    ctx.lineTo(trees[edge.v].x, trees[edge.v].y);
    ctx.strokeStyle = isSelected ? '#FF0000' : '#FFFF00';
    ctx.lineWidth = isSelected ? 3 : 1;
    ctx.stroke();
    
    if(isSelected) playSound('select'); // 触发音效
}

// 像素风格猴子跳跃
function drawMonkeyJump(x, y, progress) {
    const frame = Math.floor(progress * 8) % 4;
    ctx.drawImage(
        spriteSheet,
        frame * 16, 0, 16, 16,
        x - 8, y - 8 - progress*30, 16, 16
    );
}
```

---

### 个人心得摘录

> "第一次 RE 是因为边数组开小了，N=1000 时完全图需要约 50 万容量，随手开到 1e6 才过。血的教训：**MST 题先计算最大边数！**"  
> —— jiangby

> "发现 sqrt 后的精度误差导致 WA，改用平方比较后立刻 AC，浮点数真是隐秘的坑啊"  
> —— kkkk0369

---

### 算法选择建议

- **N ≤ 300**：Kruskal 更易实现
- **N ≥ 500**：优先考虑 Prim（邻接矩阵）或堆优化 Prim
- **坐标范围大**：先计算是否可能形成 MST（如所有点连通）

--- 

通过这种系统化的分析与可视化设计，学习者不仅能掌握 MST 的应用场景，还能深入理解不同算法实现的优化技巧，为处理类似问题提供清晰的解决框架。

---
处理用时：68.14秒
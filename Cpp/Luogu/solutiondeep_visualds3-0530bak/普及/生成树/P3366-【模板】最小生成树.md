# 题目信息

# 【模板】最小生成树

## 题目描述

如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 `orz`。


## 说明/提示

数据规模：

对于 $20\%$ 的数据，$N\le 5$，$M\le 20$。

对于 $40\%$ 的数据，$N\le 50$，$M\le 2500$。

对于 $70\%$ 的数据，$N\le 500$，$M\le 10^4$。

对于 $100\%$ 的数据：$1\le N\le 5000$，$1\le M\le 2\times 10^5$，$1\le Z_i \le 10^4$。


样例解释：

 ![](https://cdn.luogu.com.cn/upload/pic/2259.png) 

所以最小生成树的总边权为 $2+2+3=7$。


## 样例 #1

### 输入

```
4 5
1 2 2
1 3 2
1 4 3
2 3 4
3 4 3```

### 输出

```
7```

# AI分析结果



**唯一算法分类**：最小生成树（Kruskal & Prim 算法）

---

### **综合分析与结论**
#### **核心算法流程**
1. **Kruskal 算法**：  
   - 边权排序 → 并查集判环 → 贪心选择最小边  
   - **可视化关键**：  
     - 高亮当前选择的边，动态显示并查集合并过程  
     - 颜色标记已选边（绿色）、候选边（黄色）、无效边（红色）

2. **Prim 算法**：  
   - 初始化距离数组 → 优先队列选择最小边 → 动态更新邻接点距离  
   - **可视化关键**：  
     - 展示当前已选点集（蓝色），候选边优先队列（渐变色表示权值大小）  
     - 高亮每次新增的边和节点

---

### **题解清单（≥4星）**
1. **题解作者：Nemlit（Kruskal & Prim）**  
   ⭐⭐⭐⭐⭐  
   - 亮点：对比 Kruskal/Prim 适用场景，给出完整代码和复杂度分析  
   - 核心代码：`sort(edges)` + `find(u) != find(v)` 判环逻辑

2. **题解作者：封禁用户（Prim堆优化）**  
   ⭐⭐⭐⭐  
   - 亮点：邻接链表优化实现，`priority_queue` 动态维护候选边  
   - 核心代码：`q.push({dis[v], v})` + 松弛操作更新堆

3. **题解作者：Tweetuzki（Boruvka）**  
   ⭐⭐⭐⭐  
   - 亮点：多路增广思想，适合并行合并场景  
   - 核心代码：`Best[i]` 维护每个连通块的最优边

---

### **最优思路与技巧**
1. **Kruskal 路径压缩优化**：  
   ```cpp
   int find(int x) {
       return (fa[x] == x) ? x : fa[x] = find(fa[x]);
   }
   ```
2. **Prim堆优化动态维护**：  
   ```cpp
   priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
   pq.emplace(0, 1); // 初始节点
   ```

3. **Boruvka合并策略**：  
   ```cpp
   for (每个连通块) {
       Find 当前块到其他块的最小边
       if 不形成环 → 合并并累加权重
   }
   ```

---

### **同类型题推荐**
1. **P2872 [USACO07DEC]道路建设**：最小生成树边权计算  
2. **P1991 无线通讯网**：动态规划与最小生成树结合  
3. **P4047 [JSOI2010]部落划分**：Kruskal 逆向思维求最大间隔

---

### **可视化设计（像素风格演示）**
#### **动画方案**
1. **Canvas 网格**：  
   - 节点显示为 16x16 像素方块，边权用 8-bit 字体标注  
   - **颜色编码**：已选边（绿色）、候选边（黄色）、无效边（红色）

2. **音效设计**：  
   - **选择有效边**：NES 风格「叮」声（Web Audio API）  
   - **合并操作**：合成器短音效（频率与边权正相关）

3. **自动演示模式**：  
   - 按算法步骤逐步高亮操作，支持速度调节（0.5x~4x）  
   - 示例伪代码：  
     ```javascript
     function autoPlay() {
         highlightEdge(currentEdge);
         if (!isCyclic()) {
             playSound('merge');
             mergeSets();
         }
         requestAnimationFrame(autoPlay);
     }
     ```

---

### **核心代码片段（Kruskal 实现）**
```cpp
// 边结构体排序
sort(edges, edges + m, [](Edge a, Edge b){ return a.w < b.w; });

// 并查集判环 + 贪心选择
int kruskal() {
    int ans = 0, cnt = 0;
    for (int i = 0; i < m; i++) {
        int u = find(edges[i].u), v = find(edges[i].v);
        if (u != v) {
            fa[u] = v;
            ans += edges[i].w;
            if (++cnt == n-1) break;
        }
    }
    return (cnt == n-1) ? ans : -1;
}
```

---

**总结**：Kruskal 以其简洁性和易实现性成为首选，Prim 在稠密图中更优。堆优化和路径压缩是提升效率的核心技巧，复古像素动画可直观展示贪心策略的决策过程。

---
处理用时：70.57秒
# 题目信息

# [CCC 2021 S3] Lunch Concert

## 题目描述

有 $N$ 个人，第 $i$ 个人的速度为 $W_i$ **秒每米**，听力为 $D_i$，即能听见距离他不超过 $D_i$ 米处的音乐，初始在 $P_i$ 位置。

你要在 $c$ 位置处开音乐会，这个 $c$ 由你决定且为整数。这 $N$ 个人都会靠近你直到能听到你。你要最小化每个人移动的时间之和。

## 说明/提示

$$1\leq N\leq 200000,0\leq P_i\leq 10^9,1\leq W_i\leq 1000,0\leq D_i\leq 10^9$$

译自 [CCC2021 S3](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2021/ccc/seniorEF.pdf)。

###### 2023.8.10 新增一组 hack 数据。

## 样例 #1

### 输入

```
1
0 1000 0
```

### 输出

```
0```

## 样例 #2

### 输入

```
2
10 4 3
20 4 2
```

### 输出

```
20```

## 样例 #3

### 输入

```
3
6 8 3
1 4 1
14 5 2
```

### 输出

```
43```

# AI分析结果



## 算法分类  
**三分法**（单峰函数求极值）

---

## 题解思路与核心分析

### 题目核心
求整数位置 $c$，使得所有人移动到能听到音乐会的位置的总时间最小。每个人仅在超出听力范围时移动，移动时间为距离差乘以速度 $W_i$。

### 核心难点
1. **大规模数据**：直接枚举所有可能的 $c$ 不可行（$c$ 范围可达 $10^9$）。
2. **函数性质分析**：总时间函数 $f(c)$ 是否具备单谷性质，从而可用三分法快速求极值。
3. **高效计算**：如何在 $O(n)$ 或 $O(n \log n)$ 时间内处理每个候选点 $c$ 的总时间。

### 解决方案
1. **三分法**：基于单谷函数性质，每次缩小搜索范围，时间复杂度 $O(n \log M)$，其中 $M$ 为初始范围。
2. **离散化差分**：收集所有线段端点作为事件点，排序后利用差分数组维护线性函数的斜率和截距，时间复杂度 $O(n \log n)$。

---

## 题解评分 (≥4星)

1. **wjh2011（5星）**  
   - **思路**：利用单谷函数性质，通过三分法快速定位极值点。  
   - **亮点**：代码简洁，复杂度合理，正确性有严格数学证明。  
   - **代码**：清晰的三分框架，直接计算总时间函数值。

2. **_•́へ•́╬_（4星）**  
   - **思路**：离散化线段端点，差分数组维护分段函数参数。  
   - **亮点**：时间复杂度更优，适用于极大范围数据。  
   - **代码**：复杂但高效，需处理离散化与差分细节。

3. **small_john（4星）**  
   - **思路**：三分法实现，代码简洁易读。  
   - **亮点**：直接调用 `min` 函数处理边界，避免冗余计算。

---

## 最优思路提炼

### 关键思路
1. **单谷函数性质**：总时间函数 $f(c)$ 随 $c$ 先减后增，极值唯一。
2. **三分法实现**：  
   - **分治策略**：每次将区间分成三部分，比较中间点的函数值，缩小搜索范围。  
   - **函数计算**：对每个候选点 $c$，遍历所有人计算移动时间总和。
3. **离散化差分**：  
   - **事件点收集**：将每个线段端点作为可能影响总时间的断点。  
   - **差分处理**：维护每个区间的线性函数参数（斜率和截距），快速计算总时间。

### 核心代码实现（三分法）
```cpp
int work(int x) {
    int res = 0;
    for (int i = 1; i <= n; i++) {
        if (x < p[i] - d[i]) 
            res += (p[i] - d[i] - x) * w[i];
        else if (x > p[i] + d[i]) 
            res += (x - p[i] - d[i]) * w[i];
    }
    return res;
}

// 三分主循环
int l = -1e9, r = 1e9;
while (l <= r) {
    int mid1 = (2*l + r)/3, mid2 = (l + 2*r)/3;
    int f1 = work(mid1), f2 = work(mid2);
    ans = min({ans, f1, f2});
    if (f1 <= f2) r = mid2 - 1;
    else l = mid1 + 1;
}
```

---

## 类似题目推荐
1. **P3382 【模板】三分法**：练习单峰函数极值求解。  
2. **P1883 函数**：多峰函数下的极值问题，需结合观察调整。  
3. **P3745 [六省联考 2017] 期末考试**：三分法优化时间分配。

---

## 可视化设计（三分法）

### 动画方案
1. **动态范围标记**：用两根指针 `l` 和 `r` 表示当前搜索区间，颜色标记当前中间点 `mid1` 和 `mid2`。
2. **函数值比较**：高亮 `f(mid1)` 和 `f(mid2)` 的计算过程，展示移动总时间的变化。
3. **区间更新**：根据比较结果，用不同颜色区分区间收缩方向（向左或向右）。

### 复古像素风格
- **颜色方案**：16色调色板，绿色表示当前区间，红色标记极值点。
- **音效**：移动指针时播放“滴”声，找到极值时播放“胜利”音效。
- **Canvas 绘制**：网格显示当前候选点，动态更新函数曲线。

---

## 个人心得摘录
- **wjh2011**：注意整数三分边界处理，最终需额外检查 `l` 和 `r` 处的值。  
- **_•́へ•́╬_**：离散化时需去重，差分数组需处理闭区间端点。  
- **InversionShadow**：验证单谷性质时，可画图观察导数的单调性。

---

## 算法比较
| 方法         | 时间复杂度       | 空间复杂度 | 实现难度 | 适用场景         |
|--------------|------------------|------------|----------|------------------|
| 三分法       | $O(n \log M)$   | $O(n)$     | 易       | 单峰函数快速实现 |
| 离散化差分   | $O(n \log n)$   | $O(n)$     | 难       | 极大范围数据     |
| 模拟退火     | 不稳定           | $O(n)$     | 中       | 非单峰函数       |

---
处理用时：169.32秒
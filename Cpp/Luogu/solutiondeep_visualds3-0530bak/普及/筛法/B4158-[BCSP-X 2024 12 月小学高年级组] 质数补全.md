# 题目信息

# [BCSP-X 2024 12 月小学高年级组] 质数补全

## 题目描述

Alice 在纸条上写了一个质数，第二天再看时发现有些地方污损看不清了。

- 在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数称为质数

请你帮助 Alice 补全这个质数，若有多解输出数值最小的，若无解输出 $-1$。

例如纸条上的数字为 $\tt{1*}$（$\tt{*}$ 代表看不清的地方），那么这个质数有可能为 $11, 13, 17, 19$，其中最小的为 $11$。

## 说明/提示

### 样例 3-6

参考附件中的样例。

### 数据范围

$|s|$ 代表 $s$ 串的长度，对于所有数据，$1 \leq t \leq 10, 1 \leq |s| \leq 7$，$s$ 中仅包含数字或者 $\tt{*}$，并且保证首位不是 $\tt{*}$ 或者 $0$。

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | $\mid s\mid$ | 特殊性质 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $35$ | $\leq 7$ | $s$ 中没有 $\tt{*}$ |  |
| $2$ | $30$ | $\leq 4$ |  |  |
| $3$ | $24$ | $\leq 7$ | $s$ 中至多包含 $1$ 个 $\tt{*}$ | $1$ |
| $4$ | $11$ | $\leq 7$ |  | $1,2,3$ |


## 样例 #1

### 输入

```
10
1*
3**
7**
83*7
2262
6**1
29*7
889*
777*
225*```

### 输出

```
11
307
701
8317
-1
6011
2917
8893
-1
2251```

## 样例 #2

### 输入

```
10
4039***
2***5*5
4099961
25**757
7***0**
1***00*
41811*9
6***0*7
8***1**
6561*59```

### 输出

```
4039019
-1
4099961
2509757
7000003
1000003
4181129
6000047
8000101
6561259```

# AI分析结果



### 唯一算法分类
**搜索算法（DFS）**

---

### 综合分析与结论
**核心思路**：
通过深度优先搜索（DFS）按升序枚举污损位可能的数字组合，生成候选数后立即进行质数判断，找到第一个合法质数即为最小解。核心难点在于高效剪枝与避免无效搜索。

**算法流程**：
1. **预处理污损位**：记录字符串中所有 `*` 的位置。
2. **DFS枚举替换**：
   - 按污损位从左到右的顺序处理，保证高位优先替换。
   - 首位 `*` 只能填 `1-9`（避免前导0），其他位填 `0-9`。
   - 每生成一个完整候选数，立即用试除法判断是否为质数。
3. **剪枝优化**：找到第一个质数后全局标记终止后续搜索。

**可视化设计**：
- **动画方案**：在网格中高亮当前处理的污损位，动态填充数字，绿色标记已确定的质数。
- **步进控制**：支持单步执行观察每位替换过程，回溯时恢复 `*` 状态。
- **复古风格**：使用 8-bit 像素字体，替换数字时播放经典音效，找到解后显示闪烁特效。

---

### 题解清单（≥4星）
1. **题解作者：2789617221guo（4.5星）**
   - **亮点**：清晰的DFS结构，快速剪枝，变量命名规范。
   - **关键代码**：通过 `pos[]` 记录污损位，首位特殊处理。

2. **题解作者：yuhaotian000（4星）**
   - **亮点**：七重循环暴力枚举，适合短字符串，代码直观。
   - **缺点**：循环层数固定，无法灵活处理长度变化。

3. **题解作者：leozhao123（4星）**
   - **亮点**：预处理质数表+二分查找，适用于多次查询场景。
   - **缺点**：内存占用高，预处理时间长。

---

### 核心代码实现
```cpp
// 摘自 2789617221guo 的题解（关键片段）
void dfs(int t, string s) {
    if (flag) return; // 剪枝
    if (t > p) {      // 所有污损位处理完毕
        if (prime(s)) {
            cout << s << endl;
            flag = 1; // 标记已找到解
        }
        return;
    }
    int c = pos[t];   // 当前处理的污损位索引
    if (c == 0) {     // 首位特殊处理
        for (int i = 1; i <= 9; i++) {
            s[c] = i + '0';
            dfs(t + 1, s);
            s[c] = '*'; // 回溯
        }
    } else {
        for (int i = 0; i <= 9; i++) {
            s[c] = i + '0';
            dfs(t + 1, s);
            s[c] = '*'; // 回溯
        }
    }
}
```

---

### 最优思路提炼
1. **升序枚举剪枝**：按数字升序填充污损位，确保第一个找到的质数最小。
2. **首位特判**：首位 `*` 只填 `1-9`，避免无效候选。
3. **即时质数判断**：生成完整候选后立即判断，减少存储开销。

---

### 类似题目推荐
1. **P1217 [USACO1.5] 回文质数**（质数生成+回文判断）
2. **P1036 选数**（组合数+质数判断）
3. **P1029 最大公约数和最小公倍数问题**（质因数分解应用）

---

### 个人心得摘录
- **调试教训**：未回溯字符串导致状态污染（如 `s[c] = '*'` 必须恢复）。
- **思维突破**：按位升序枚举可实现最小解优先，无需全局排序。

---

### 复古像素化动画设计
1. **界面布局**：ASCII字符画显示当前候选数，污损位闪烁提示。
2. **音效设计**：
   - 替换数字：8-bit "beep" 短音。
   - 找到解：经典马里奥过关音效。
3. **自动演示**：按DFS顺序自动填充，速度可调，支持暂停观察质数判断过程。

---
处理用时：89.88秒
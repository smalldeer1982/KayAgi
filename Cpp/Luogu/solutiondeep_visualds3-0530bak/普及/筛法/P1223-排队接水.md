# 题目信息

# 排队接水

## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。


## 说明/提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。


## 样例 #1

### 输入

```
10 
56 12 1 99 1000 234 33 55 99 812```

### 输出

```
3 2 7 8 1 4 9 6 10 5
291.90
```

# AI分析结果



## 算法分类
**贪心算法**

---

## 综合分析与结论
### 核心算法流程
1. **贪心策略**：按接水时间升序排列，时间短者优先接水，使得总等待时间最小。
2. **数学证明**：交换相邻两人顺序时，若前者的时间更短，总等待时间更优（推导见首条题解）。
3. **实现关键**：
   - **数据结构**：需同时记录原始序号和接水时间（结构体、pair、数值合并等）。
   - **排序优化**：快速排序（O(n log n)）优于冒泡（O(n²)）。
   - **总时间计算**：公式 `总时间 = Σ t_i * (n-i)`，其中 `t_i` 为排序后第 i 人的时间。

### 可视化设计要点
- **动画流程**：
  1. 初始显示未排序的接水时间队列，用不同颜色柱子表示时间长短。
  2. 动态排序过程，高亮当前比较/交换的元素。
  3. 接水时，实时显示当前人贡献的等待时间（`t_i * (n-i)`），并累加总时间。
- **复古像素风格**：
  - **颜色方案**：使用 8-bit 色调（如 #FF6666 表示当前操作元素）。
  - **音效**：排序时播放“哔”声，接水时播放“滴答”声，计算完成时播放胜利音效。
- **交互控制**：支持暂停/继续、单步执行，可调节动画速度。

---

## 题解评分（≥4星）
### 1. f112358（5星）
- **亮点**：数值合并技巧（时间*1001 + 序号），避免结构体，代码简洁高效。
- **代码片段**：
  ```cpp
  t[i] = x * 1001 + i;  // 合并时间和序号
  sum += t[j]/1001 * (n-j);  // 分解计算总时间
  ```

### 2. BlueArc（4.5星）
- **亮点**：结构体清晰易读，适合教学，循环计算总时间逻辑明确。
- **代码片段**：
  ```cpp
  struct a { int b, num; };
  sort(a+1, a+n+1, cmp);  // 按时间排序
  time += a[i].b * j;     // 累加总时间
  ```

### 3. Anguei（4星）
- **亮点**：使用 `pair` 简化代码，利用 STL 默认排序规则。
- **代码片段**：
  ```cpp
  std::pair<int, int> a[...];
  sort(a, a+n);  // 默认按 first 排序
  sum += a[i].first * (n-i-1);
  ```

---

## 最优思路提炼
1. **贪心排序**：时间升序排列，数学证明保证最优。
2. **高效数据结构**：结构体、pair 或数值合并，平衡可读性与效率。
3. **时间复杂度**：快速排序 O(n log n) 最优，冒泡排序仅适用于小数据。
4. **公式推导**：总时间 = 各人时间乘以后续人数之和。

---

## 类似算法题目
1. **合并果子（洛谷 P1090）**：每次合并最小两堆，优先队列实现。
2. **线段覆盖（洛谷 P1803）**：按右端点排序，贪心选择不重叠线段。
3. **混合牛奶（洛谷 P1208）**：低价优先购买，贪心策略。

---

## 可视化代码示例（核心逻辑）
```javascript
// 示例：Canvas 绘制排序过程（伪代码）
function drawQueue(times, currentIndex) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let i = 0; i < times.length; i++) {
    const height = times[i] * 5; // 缩放时间值
    ctx.fillStyle = i === currentIndex ? '#FF6666' : '#6666FF';
    ctx.fillRect(i * 30, canvas.height - height, 25, height);
  }
}

// 示例：复古音效
function playSound(effect) {
  const osc = audioCtx.createOscillator();
  osc.frequency.value = effect === 'swap' ? 880 : 440;
  osc.connect(audioCtx.destination);
  osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

---

## 个人心得摘录
- **调试教训**：`float` 精度不足导致 WA，改用 `double`。
- **思维突破**：公式 `总时间 = t_i * (n-i)` 的逆向推导（非累加前缀和）。
- **代码优化**：利用 `pair` 或数值合并减少代码量，提升可维护性。

---
处理用时：75.45秒
# 题目信息

# 素数密度

## 题目背景

UPD:

- 2024.8.12：加入一组 Hack 数据。

## 题目描述

 给定 $L,R$，请计算区间 $[L,R]$ 中素数的个数。

   $1\leq L\leq R < 2^{31}$，$R-L\leq 10^6$。

## 样例 #1

### 输入

```
2 11```

### 输出

```
5```

# AI分析结果



# 算法分类：区间筛法

## 题解思路与核心难点
### 核心算法流程
1. **预处理小质数**：用线性筛法生成 sqrt(R) 范围内的所有质数（约5万个）
2. **区间标记合数**：对每个预处理出的质数 p，在 [L, R] 区间内标记其倍数
3. **统计未标记数**：遍历区间统计未被标记的素数个数

### 解决难点
- **空间优化**：通过偏移量压缩区间到数组（vis[j-L]）
- **边界处理**：
  - L=1 时的特殊处理
  - 避免将质数自身标记为合数（从 max(p*2, ceil(L/p)*p) 开始）
- **时间复杂度**：O(√R log log√R + (R-L) logR)，可处理 R=2^31 的极端情况

---

## 优质题解推荐（≥4星）
### 1. Segmentree（5星）
- **亮点**：
  - 完整处理边界条件（L=1的特殊情况）
  - 使用线性筛预处理质数
  - 代码结构清晰，关键注释到位
- **核心代码**：
```cpp
for(re int i=1;i<=cnt;++i) {
    ll p=prime[i];
    ll start = max(2*p, (l+p-1)/p*p); // 计算起始位置
    for(ll j=start; j<=r; j+=p)
        vis[j-l+1] = 1;
}
```

### 2. Jayun（4星）
- **亮点**：
  - 使用埃氏筛预处理质数
  - 简洁的区间偏移处理
  - 包含调试经验说明（Hack数据修复）
- **优化点**：
```cpp
for(register int i=1; i<=cnt; ++i) {
    for(ll j = max(2ll, (L-1)/prime[i]+1)*prime[i]; j<=R; j+=prime[i])
        ans[j-L] = 1;
}
```

### 3. jins3599（4星）
- **亮点**：
  - 使用位移压缩区间
  - 完整包含质数预处理和区间筛选
  - 代码可读性极佳
- **统计逻辑**：
```cpp
for(int i=0; i<=r-l; ++i)
    if(!ans[i]) tot++;
```

---

## 最优思路提炼
1. **质数定理应用**：任何合数必有一个≤√n的质因子
2. **双重筛法结构**：小范围质数筛 + 大区间标记
3. **空间压缩技巧**：使用相对偏移量 `vis[j-L]` 代替绝对坐标
4. **线性筛优化**：O(n) 时间预处理质数表

---

## 相似题目推荐
1. [P3383【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)
2. [P1217 [USACO1.5] 回文质数](https://www.luogu.com.cn/problem/P1217)
3. [P3912 素数个数](https://www.luogu.com.cn/problem/P3912)

---

## 可视化设计
### 动画方案
```html
<canvas id="sieve-canvas" width="800" height="200"></canvas>
<div class="controls">
    <button onclick="step()">单步</button>
    <input type="range" id="speed" min="10" max="1000">
</div>
<script>
// 初始化参数
let currentPrime = 0;
let marked = new Set();

function draw() {
    // 绘制区间及标记状态
    // 使用不同颜色表示质数/合数/当前操作
}

function step() {
    let p = primes[currentPrime];
    // 高亮当前质数
    // 标记其倍数
    draw();
    currentPrime++;
}
</script>
```

### 视觉要素
1. **像素风格**：16色调色板，素数显示为绿色方块
2. **标记过程**：
   - 当前质数高亮为黄色
   - 新标记的合数闪烁红色
3. **进度显示**：顶部状态栏显示当前处理的质数

### 交互设计
- **步进控制**：单步执行/自动播放切换
- **速度调节**：滑动条控制动画速度（10ms-1s）
- **音效反馈**：
  - 发现质数：清脆的"叮"声
  - 标记合数：短促的"咔"声
  - 完成筛选：8-bit胜利音乐

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN = 1e6+5;

vector<int> primes;
bool is_prime[50005]; // sqrt(2^31)≈46341

void sieve() {
    fill(is_prime, is_prime+50005, true);
    for(int i=2; i<=50000; ++i) {
        if(is_prime[i]) primes.push_back(i);
        for(int p : primes) {
            if(i*p > 50000) break;
            is_prime[i*p] = false;
            if(i%p == 0) break;
        }
    }
}

int main() {
    ll L, R, cnt = 0;
    cin >> L >> R;
    sieve();
    
    vector<bool> mark(R-L+1, false);
    if(L == 1) mark[0] = true;
    
    for(int p : primes) {
        ll start = max(2LL, (L+p-1)/p) * p; // 首个≥L的p倍数
        for(ll j=start; j<=R; j+=p)
            mark[j-L] = true;
    }
    
    for(bool m : mark) 
        if(!m) cnt++;
        
    cout << cnt;
    return 0;
}
```

---
处理用时：95.46秒
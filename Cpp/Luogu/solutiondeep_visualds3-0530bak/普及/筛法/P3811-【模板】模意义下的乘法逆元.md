# 题目信息

# 【模板】模意义下的乘法逆元

## 题目背景

这是一道模板题


## 题目描述

给定 $n,p$ 求 $1\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。

这里 $a$ 模 $p$ 的乘法逆元定义为 $ax\equiv1\pmod p$ 的解。

## 说明/提示

$ 1 \leq n \leq 3 \times 10 ^ 6$，$n < p < 20000528 $。

输入保证 $ p $ 为质数。


## 样例 #1

### 输入

```
10 13```

### 输出

```
1
7
9
10
8
11
2
5
3
4```

# AI分析结果



**唯一算法分类**: 线性递推法

---

### **综合分析与结论**

**核心思路**：  
题目要求线性时间内计算1~n每个数的模p逆元。通过数学推导，得到递推公式：  
`inv[i] = (p - p/i) * inv[p % i] % p`  
利用p为质数的性质，从inv[1]=1开始递推，每个i的逆元由已计算的更小逆元推导而来。

**难点与解决**：  
- **推导递推式**：通过将p拆分为k*i + r，构造同余方程并变形，得到i⁻¹与r⁻¹的关系。  
- **负数处理**：公式中的负号通过`p - (p/i)`转为正数，避免取模错误。  
- **线性复杂度**：O(n)时间满足大规模数据需求，避免O(n log p)的超时风险。

**可视化设计**：  
- **动画方案**：  
  - **Canvas网格**：横向排列1~n的方块，当前i的方块高亮为红色，p%i对应的方块高亮为蓝色。  
  - **步骤显示**：每步展示`i, p/i, p%i`，计算`inv[i]`时显示公式中的运算过程。  
- **复古像素风**：  
  - **8位色板**：使用16色（如深蓝、红、绿），方块边缘像素化。  
  - **音效触发**：每计算完一个inv[i]，播放短促“哔”声；完成时播放胜利音效。  
- **自动演示**：  
  - 速度可调（1x, 2x, 5x），默认按i递增自动更新网格颜色和数值。  

---

### **题解清单 (≥4星)**

1. **zjp_shadow (5星)**  
   - **亮点**：全面覆盖逆元解法，公式推导严谨，代码简洁。  
   - **关键代码**：  
     ```cpp
     inv[1] = 1;
     for(int i=2; i<=n; ++i)
         inv[i] = (p - p/i) * inv[p%i] % p;
     ```

2. **Rising_Date (4星)**  
   - **亮点**：详细注释递推式推导，代码处理负数清晰。  
   - **心**得：强调`(p - p/i)`替代负数取模，确保结果正确性。

3. **一扶苏一 (4星)**  
   - **亮点**：数学证明完整，代码包含阶乘逆元拓展。  
   - **关键句**：“递推的正确性依赖于p%i < i的已计算性质”。

---

### **最优思路提炼**

**核心技巧**：  
- **递推公式**：`i⁻¹ ≡ -⌊p/i⌋ * (p%i)⁻¹ (mod p)` → 转为正数计算。  
- **实现优化**：预计算数组inv[]，避免递归栈开销，直接循环O(n)完成。  

**代码片段**：  
```cpp
inv[1] = 1;
for (int i = 2; i <= n; i++) {
    inv[i] = 1LL * (p - p/i) * inv[p % i] % p;
    printf("%d\n", inv[i]);
}
```

---

### **同类型题推荐**

1. **P5431 【模板】乘法逆元2**  
   - 需结合前缀积和逆元批量处理分数求和。  
2. **P2613 【模板】有理数取余**  
   - 将分数转为逆元计算，验证无解情况。  
3. **P4071 [SDOI2016]排列计数**  
   - 组合数计算依赖阶乘逆元的线性预处理。  

---

### **可视化核心代码 (JavaScript)**

```javascript
// 初始化Canvas
const canvas = document.getElementById('pixelCanvas');
const ctx = canvas.getContext('2d');
const cells = 10; // 显示前10个逆元
let currentStep = 1;

function drawGrid() {
    ctx.fillStyle = '#2c3e50'; // 背景深蓝
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    for (let i = 1; i <= cells; i++) {
        ctx.fillStyle = (i === currentStep) ? '#e74c3c' : '#3498db'; // 当前i红色
        ctx.fillRect((i-1)*30, 50, 25, 25);
        ctx.fillText(`i=${i}`, (i-1)*30, 30);
        ctx.fillText(inv[i], (i-1)*30 + 5, 65);
    }
}

// 自动演示函数
function autoPlay(speed) {
    const timer = setInterval(() => {
        if (currentStep > cells) {
            clearInterval(timer);
            playSuccessSound();
            return;
        }
        calculateInv(currentStep);
        currentStep++;
        drawGrid();
        playStepSound();
    }, 1000 / speed);
}

// 音效模拟
function playStepSound() { /* 使用Web Audio API播放8bit音效 */ }
```

---

**总结**：线性递推法以O(n)时间高效求解逆元，核心在于递推公式的数学推导与实现优化，适合大规模数据处理。

---
处理用时：73.94秒
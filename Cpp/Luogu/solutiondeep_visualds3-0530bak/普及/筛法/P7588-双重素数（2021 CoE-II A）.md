# 题目信息

# 双重素数（2021 CoE-II A）

## 题目描述

素数（质数）是指在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数。定义**双重素数**为这样的素数：它的各位数字之和也是一个素数。给定一个闭区间，试确定在该区间内双重素数的个数。

## 说明/提示

**样例说明**

从 $1$ 到 $15$ 共有 $6$ 个素数：$2$，$3$，$5$，$7$，$11$，$13$。前五个素数各自的数字之和也是素数，因此都是双重素数。素数 $13$ 的各位数字之和为 $4$，不是素数，故 $13$ 不是双重素数。

------------


**数据范围**

- Subtask $1$ ：$1 \le L \le R \le 10^2$，$10$ 分。
- Subtask $2$ ：$1 \le L \le R \le 10^4$，$20$ 分。
- Subtask $3$ ：$1 \le L \le R \le 10^6$，$60$ 分。
- Subtask $4$ ：$1 \le L \le R \le 10^8$，$10$ 分。

对于 $100\%$ 的数据，$1 \le T \le 100$。


------------

**提示（数据已经加强）**

最后一个子任务要求你的程序必须具有较高的空间使用效率和时间效率，否则容易超出内存限制或时间限制。

## 样例 #1

### 输入

```
4
3 3
4 4
1 5
1 15```

### 输出

```
1
0
3
5```

# AI分析结果



## 算法分类
筛法（欧拉筛）、二分查找

---

## 题解思路与解决难点

### 核心思路
1. **欧拉筛预处理**：高效筛出 1e8 以内的所有素数。
2. **双重素数筛选**：对每个素数计算各位数字之和，判断是否为素数。
3. **二分查询优化**：预处理后的双重素数数组有序，利用 `lower_bound` 和 `upper_bound` 快速计算区间内的数量。

### 关键难点与解决
1. **空间优化**：使用 `bitset` 或位数组（如 `unsigned int[]`）代替 `bool` 数组，将空间降至 1/8。
2. **时间优化**：预处理阶段 O(n) 复杂度，查询阶段 O(T log n) 复杂度。
3. **双重素数判断**：数字和最大为 72（9*8），直接预存小素数列表快速判断。

---

## 题解评分（≥4星）

### 王熙文（5星）
- **亮点**：  
  - 使用 `bitset` 节省空间，预处理与查询分离。  
  - 代码结构清晰，二分查找直接计算差值。  
  - 提供位数组优化版本，展示空间优化技巧。

### _lfxxx_（4.5星）
- **亮点**：  
  - 完整解释欧拉筛与 `bitset` 的使用。  
  - 预处理双重素数后直接复用数组，减少额外空间。  
  - 代码简洁，适合教学。

### metaphysis（4星）
- **亮点**：  
  - 手写位数组实现空间极致优化。  
  - 预存小素数列表加速数字和判断。  
  - 二分查找逻辑明确，代码高效。

---

## 最优思路提炼

### 核心步骤
1. **欧拉筛预处理素数**：  
   ```cpp
   void sieve() {
       for (int i=2; i<=n; i++) {
           if (!vis[i]) primes[cnt++] = i;
           for (int j=0; j<cnt && i*primes[j]<=n; j++) {
               vis[i*primes[j]] = true;
               if (i % primes[j] == 0) break;
           }
       }
   }
   ```
2. **筛选双重素数**：  
   ```cpp
   int sum_digits(int x) {
       int sum = 0;
       while (x) sum += x%10, x /= 10;
       return sum;
   }
   // 预存小素数列表
   bool is_small_prime(int x) {
       return x == 2 || x == 3 || ... || x == 73;
   }
   ```
3. **二分查询区间数量**：  
   ```cpp
   int query(int l, int r) {
       int left = lower_bound(dp, dp+k, l) - dp;
       int right = upper_bound(dp, dp+k, r) - dp;
       return right - left;
   }
   ```

---

## 类似题目推荐
1. **P3383**：线性筛素数（模板题）  
2. **P1217**：回文素数（预处理+性质判断）  
3. **P1835**：素数密度（区间筛法）

---

## 个人心得摘录
- **王熙文**：位数组优化 `bitset` 需注意位运算细节，如 `wz >> 5` 替代除法。  
- **DWT8125**：错误尝试在筛法中直接标记双重素数会导致漏筛合数，需严格两阶段处理。  
- **metaphysis**：数字和最大仅 72，预存小素数列表比每次计算更高效。

---

## 算法可视化设计

### 关键动画步骤
1. **筛法过程**：  
   - 用网格表示 1~n 的数，筛合数时标记为红色，素数保持绿色。  
   - 当前处理的素数高亮，其倍数逐渐变红。  
   ![Euler Sieve Animation](https://oi-wiki.org/basic/images/sieve.gif)

2. **双重素数筛选**：  
   - 对每个素数（绿色），计算数字和，若为小素数则标记为金色。  
   - 非双重素数恢复为普通绿色。

3. **二分查询演示**：  
   - 显示查询区间 [L, R]，在双重素数数组中用左右指针滑动定位。

### 复古像素风格实现
- **Canvas 绘制**：  
  - 每个数用 8x8 像素块表示，素数绿色，合数红色，双重素数金色。  
  - 筛法过程中，当前处理的素数块闪烁，其倍数块逐帧变红。  
- **音效设计**：  
  - 筛到一个素数：短促“滴”声。  
  - 找到双重素数：上升音调“叮”。  
  - 查询完成：8-bit 胜利旋律。

---

## 核心代码（王熙文优化版）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e8;
bitset<MAXN+1> is_prime;
vector<int> primes, double_primes;

void sieve() {
    is_prime.set();
    is_prime[0] = is_prime[1] = 0;
    for (int i=2; i<=MAXN; ++i) {
        if (is_prime[i]) primes.push_back(i);
        for (int p : primes) {
            if (i*p > MAXN) break;
            is_prime[i*p] = 0;
            if (i % p == 0) break;
        }
    }
}

bool is_small_prime(int x) {
    return x==2||x==3||x==5||x==7||x==11||x==13||x==17||x==19||x==23;
}

void filter_double_primes() {
    for (int p : primes) {
        int sum = 0, n = p;
        while (n) sum += n%10, n /=10;
        if (is_small_prime(sum)) double_primes.push_back(p);
    }
}

int main() {
    sieve();
    filter_double_primes();
    int T, L, R;
    cin >> T;
    while (T--) {
        cin >> L >> R;
        auto l = lower_bound(double_primes.begin(), double_primes.end(), L);
        auto r = upper_bound(double_primes.begin(), double_primes.end(), R);
        cout << r - l << endl;
    }
    return 0;
}
```

---
处理用时：75.61秒
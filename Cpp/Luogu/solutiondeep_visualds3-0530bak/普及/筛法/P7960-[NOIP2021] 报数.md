# 题目信息

# [NOIP2021] 报数

## 题目描述

报数游戏是一个广为流传的休闲小游戏。参加游戏的每个人要按一定顺序轮流报数，但如果下一个报的数是 $7$ 的倍数，或十进制表示中含有数字 $7$，就必须跳过这个数，否则就输掉了游戏。

在一个风和日丽的下午，刚刚结束 SPC20nn 比赛的小 r 和小 z 闲得无聊玩起了这个报数游戏。但在只有两个人玩的情况下计算起来还是比较容易的，因此他们玩了很久也没分出胜负。此时小 z 灵光一闪，决定把这个游戏加强：任何一个十进制中含有数字 $7$ 的数，它的所有倍数都不能报出来！

形式化地，设 $p(x)$ 表示 $x$ 的十进制表示中是否含有数字 $7$，若含有则 $p(x) = 1$，否则 $p(x) = 0$。则一个正整数 $x$ 不能被报出，当且仅当存在正整数 $y$ 和 $z$ ，使得 $x = yz$ 且 $p(y) = 1$。


例如，如果小 r 报出了 $6$ ，由于 $7$ 不能报，所以小 z 下一个需要报 $8$；如果小 r 报出了 $33$，则由于 $34 = 17 \times 2$，$35 = 7 \times 5$ 都不能报，小 z 下一个需要报出 $36$ ；如果小 r 报出了 $69$，由于 $70 \sim 79$ 的数都含有 $7$，小 z 下一个需要报出 $80$ 才行。

现在小 r 的上一个数报出了 $x$，小 z 想快速算出他下一个数要报多少，不过他很快就发现这个游戏可比原版的游戏难算多了，于是他需要你的帮助。当然，如果小 r 报出的 x 本身是不能报出的，你也要快速反应过来小 r 输了才行。

由于小 r 和小 z 玩了很长时间游戏，你也需要回答小 z 的很多个问题。

## 说明/提示

**【样例解释 #1】**

这一组样例的前 $3$ 次询问在题目描述中已有解释。

对于第 $4$ 次询问，由于 $300 = 75 \times 4$，而 $75$ 中含有 $7$ ，所以小 r 直接输掉了游戏。

**【数据范围】**

对于 $10\%$ 的数据，$T \leq 10$，$x \leq 100$。  
对于 $30\%$ 的数据，$T \leq 100$，$x \leq 1000$。  
对于 $50\%$ 的数据，$T \leq 1000$，$x \leq 10000$。  
对于 $70\%$ 的数据，$T \leq 10000$，$x \leq 2 \times {10}^5$。  
对于 $100\%$ 的数据，$1 \le T \leq 2 \times {10}^5$，$1 \le x \leq {10}^7$。

## 样例 #1

### 输入

```
4
6
33
69
300
```

### 输出

```
8
36
80
-1
```

## 样例 #2

### 输入

```
5
90
99
106
114
169
```

### 输出

```
92
100
109
-1
180
```

## 样例 #3

### 输入

```
见附件中的 number/number3.in```

### 输出

```
见附件中的 number/number3.ans```

## 样例 #4

### 输入

```
见附件中的 number/number4.in```

### 输出

```
见附件中的 number/number4.ans```

# AI分析结果



# [NOIP2021] 报数题解分析

## 唯一算法分类
筛法

---

## 综合分析与结论

### 核心思路
通过筛法预处理所有不能报出的数，并建立合法数序列的映射关系，实现O(1)查询。

### 关键难点
1. **筛法优化**：避免重复标记已被筛除的数
2. **边界处理**：合法数可能超过1e7（如1e7+1）
3. **高效存储**：既要记录合法数，又要建立快速查询关系

### 核心算法流程
1. **预处理阶段**：
```cpp
for (int i = 1; i <= maxN; i++) {
    if (vis[i]) continue;
    if (数位含7) {
        for (int j = i; j <= maxN; j += i) 
            vis[j] = true;
    }
    else 记录合法序列和next映射
}
```

2. **查询阶段**：
```cpp
if (vis[x]) 输出-1;
else 输出next[x]
```

### 可视化设计
- **动画方案**：
  - 将数字网格化为像素方块（1e7按100x100网格分块）
  - 红色闪烁标记含7的基数（如7,17）
  - 黄色波纹扩散标记其倍数
  - 绿色高亮合法数链

- **交互功能**：
  - 步进控制观察筛法扩散过程
  - 输入框模拟查询高亮路径
  - 8-bit音效（标记时"beep"，合法时"ding"）

---

## 题解清单（≥4星）

### 1. 银杉水杉秃杉（5星）
**亮点**：
- 双数组标记（f标记不可报数，nx记录下一个合法数）
- 剪枝逻辑清晰（已标记数直接跳过）
- 时间复杂度严格O(10^7 + T)

**核心代码**：
```cpp
void init() {
    int ls = 0;
    for (int i = 1; i <= N; i++) {
        if (f[i]) continue;
        if (check(i)) {
            for (int j = i; j <= N; j += i) f[j] = 1;
            continue;
        }
        nx[ls] = i; // 链表式存储合法数关系
        ls = i;
    }
}
```

### 2. StudyingFather（4.5星）
**亮点**：
- 合法数列表与索引映射
- vis数组复用节省空间
- 类埃氏筛实现

**核心代码**：
```cpp
void init() {
    for (int i = 1; i <= maxn; i++) {
        if (vis[i] == 0) {
            if (check(i)) {
                vis[i] = ++cnt;
                lis[cnt] = i;
            } else {
                for (int j = 1; i*j <= maxn; j++) 
                    vis[i*j] = -1;
            }
        }
    }
}
```

### 3. 滑_稽（4星）
**亮点**：
- 反推法证明算法正确性
- 建立合法数到数组下标的双向映射
- 预处理时分离标记与存储

**核心代码**：
```cpp
void GetSafeNum() {
    for (int i=1; i<maxN; i++) {
        if (judge(i)) 
            for (int j=1; j*i<maxN; j++) 
                Ill[j*i] = 1;
        if (!Ill[i]) {
            Safenum[tot] = i;
            Numsafe[i] = tot++;
        }
    }
}
```

---

## 同类型题推荐
1. P3383 【模板】线性筛素数（埃氏筛/欧拉筛）
2. P1217 [USACO1.5]回文质数（数字特性+筛法）
3. P1835 素数密度（区间筛法）

---

## 复古游戏化设计

### 像素风格实现
```javascript
// Canvas初始化
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const CELL_SIZE = 8; // 8x8像素方块
const GRID_COLOR = '#2C3E50';

function drawNumber(x, y, state) {
    // 状态色：红(不可报)、绿(合法)、灰(未处理)
    const colors = { 'bad':'#E74C3C', 'good':'#2ECC71', 'default':'#95A5A6' };
    ctx.fillStyle = colors[state];
    ctx.fillRect(x*CELL_SIZE, y*CELL_SIZE, CELL_SIZE-1, CELL_SIZE-1);
}

// 示例：标记7的倍数
for (let i = 7; i <= 100; i += 7) {
    playSound('beep.wav'); // Web Audio API触发音效
    drawNumber(i%100, Math.floor(i/100), 'bad');
    await sleep(100); // 步进延迟
}
```

---

## 关键代码实现

### 银杉水杉秃杉版完整预处理
```cpp
const int N = 1e7 + 100;
int f[N], nx[N];

bool check(int x) {
    while (x) {
        if (x % 10 == 7) return 1;
        x /= 10;
    }
    return 0;
}

void init() {
    int ls = 0;
    for (int i = 1; i <= N - 10; i++) {
        if (f[i]) continue;
        if (check(i)) {
            for (int j = i; j <= N - 10; j += i)
                f[j] = 1;
            continue;
        }
        nx[ls] = i;
        ls = i;
    }
}
```

---

## 个人心得摘录
> "考场上一定要用读入优化，小心被卡" —— 银杉水杉秃杉  
> **教训**：IO优化对大数据量至关重要

> "反向遍历预处理next数组，比二分快10倍" —— Mortis_Vampire  
> **技巧**：逆向思维提升预处理效率

> "筛到1e7+1才能过最后一个点" —— 2020kanade  
> **调试经验**：边界值需实际验证

---

通过筛法的系统应用与高效预处理，该题在O(n)时间复杂度内完美解决，展现了筛法思想的强大威力。游戏化可视化设计则让抽象的算法过程变得直观有趣。

---
处理用时：75.69秒
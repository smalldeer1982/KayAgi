# 题目信息

# 排队接水

## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。


## 说明/提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。


## 样例 #1

### 输入

```
10 
56 12 1 99 1000 234 33 55 99 812```

### 输出

```
3 2 7 8 1 4 9 6 10 5
291.90
```

# AI分析结果



**唯一算法分类**: 贪心算法

---

### 综合分析与结论
**核心算法流程**：
1. **贪心策略**：将接水时间从小到大排序，确保每个位置的时间增量对后续影响最小。
2. **数据结构**：使用结构体/pair 保存时间和原始序号，排序时保持对应关系。
3. **公式推导**：总等待时间 = Σ(t_i × (n-i))，其中 i 为排序后的位置。
4. **精度处理**：用 double 存储总时间，避免整数溢出和精度丢失。

**可视化设计思路**：
- **像素动画**：用不同颜色方块表示不同接水时间（深蓝→浅蓝渐变表示时间递增），方块上标注原始序号。
- **高亮操作**：排序时用黄色边框标记当前比较的两个元素，交换时显示红色闪烁。
- **音效设计**：比较时播放「滴」声，交换时播放「咔哒」声，计算总时间时播放上升音阶。
- **自动演示**：排序过程以 500ms/步自动播放，右侧同步显示总时间公式的累加过程。

---

### 题解清单（评分≥4星）

1. **f112358（5星）**
   - **亮点**：使用数值编码技巧（t×1001 + i）实现无需结构体的稳定排序
   - **优化点**：O(n log n) 时间复杂度，代码量最少
   - **代码片段**：
     ```cpp
     t[i] = x * 1001 + i;  // 编码
     cout << t[j] % 1001;  // 解码
     ```

2. **BlueArc（4.5星）**
   - **亮点**：结构体排序 + 公式 (n-i) 逆向计算
   - **优化点**：避免双重循环，时间复杂度 O(n log n)
   - **代码片段**：
     ```cpp
     time += a[i].b * j;  // j从n-1递减
     ```

3. **Anguei（4星）**
   - **亮点**：使用 pair 和动态内存管理
   - **教学价值**：演示 STL pair 的默认排序特性
   - **代码片段**：
     ```cpp
     pair<int, int>* a = new pair<int, int>[n]; // 动态数组
     ```

---

### 最优思路与技巧提炼
1. **数值编码法**：将序号与时间合并为单值（t×M + i，M > max(n)），排序后取模解码
2. **等待时间公式**：总时间 = t₁×(n-1) + t₂×(n-2) + ... + tₙ₋₁×1
3. **精度陷阱**：使用 double 存储累加结果，避免 float 精度不足
4. **稳定排序**：当时间相同时，按原始序号排序保证结果唯一性

---

### 类似题目推荐
1. **P1090 [NOIP2004 提高组] 合并果子**  
   （贪心策略：每次合并最小两堆）
2. **P1803 凌乱的yyy / 线段覆盖**  
   （区间调度问题，按结束时间排序）
3. **P2240 【深基12.例1】部分背包问题**  
   （性价比贪心，类似按单位价值排序）

---

### 复古像素化动画实现
**核心代码片段（JavaScript）**：
```javascript
// 绘制排序过程（8-bit风格）
function drawQueue(arr) {
  ctx.fillStyle = "#2D142C"; // 深紫背景
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  arr.forEach((val, idx) => {
    const w = 30 + val.time * 5; // 方块宽度与时间正相关
    ctx.fillStyle = `hsl(${240 - val.time * 2}, 70%, 50%)`; // 时间越长色调越暖
    ctx.fillRect(50 + idx * 60, 150, w, 40); // 绘制方块
    ctx.fillStyle = "#E0FFFF"; // 浅青文字
    ctx.fillText(val.num, 70 + idx * 60, 175); // 显示原始序号
  });
}

// 音效触发（Web Audio API）
function playSound(freq) {
  const osc = audioCtx.createOscillator();
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
  osc.connect(audioCtx.destination);
  osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

**交互设计**：
- **方向键**：←→控制动画速度，空格暂停
- **自动模式**：按 A 键启动 AI 自动排序演示
- **音效反馈**：排序完成时播放 8-bit 胜利旋律

---

### 经典题解代码
**f112358 的完整代码**：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
long long int t[1001];

int main() {
    int n, x;
    cin >> n;
    for(int i=1; i<=n; i++) {
        cin >> x;
        t[i] = x * 1001 + i; // 编码
    }
    sort(t+1, t+1+n);
    double sum = 0;
    for(int j=1; j<=n; j++) {
        cout << t[j] % 1001 << " "; // 解码输出序号
        sum += t[j]/1001 * (n-j);    // 计算总时间
    }
    printf("\n%.2lf", sum/n);
    return 0;
}
```

---
处理用时：60.05秒
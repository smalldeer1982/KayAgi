# 题目信息

# 【模板】模意义下的乘法逆元

## 题目背景

这是一道模板题


## 题目描述

给定 $n,p$ 求 $1\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。

这里 $a$ 模 $p$ 的乘法逆元定义为 $ax\equiv1\pmod p$ 的解。

## 说明/提示

$ 1 \leq n \leq 3 \times 10 ^ 6$，$n < p < 20000528 $。

输入保证 $ p $ 为质数。


## 样例 #1

### 输入

```
10 13```

### 输出

```
1
7
9
10
8
11
2
5
3
4```

# AI分析结果



### 唯一算法分类
线性递推求逆元

---

### 题解思路与核心难点

#### 核心思路
1. **线性递推公式**：基于模数分解式 `p = k*i + r`，推导出递推关系 `inv[i] ≡ -k * inv[r] (mod p)`，其中 `k = p/i`，`r = p%i`。通过预处理 `inv[1] = 1`，依次递推求出所有逆元。
2. **时间复杂度**：O(n)，完美处理 3e6 规模的数据。

#### 解决难点
- **公式推导**：需将模方程转化为递推式，确保每一步依赖已计算的逆元。
- **负数处理**：公式中 `-k` 需转为正数，通过 `(p - k) % p` 避免负值。

---

### 题解评分（≥4星）

1. **zjp_shadow（5星）**  
   - 详细推导递推式，代码简洁高效，直接处理大规模数据。
2. **Rising_Date（4星）**  
   - 提供多种方法对比，最终聚焦线性递推，代码清晰。
3. **一扶苏一（4星）**  
   - 从数论基础展开，严谨证明递推式正确性，适合数学背景学习。

---

### 最优思路提炼
**递推公式**：  
```cpp
inv[i] = (p - p/i) * inv[p % i] % p;
```
- **推导核心**：分解 `p = k*i + r` → `inv[i] ≡ -k * inv[r]`。
- **实现关键**：利用 `inv[r]` 已计算的性质，保证 O(n) 复杂度。

---

### 同类型题与算法套路
- **通用场景**：需批量求逆元且模数为质数（如组合数预处理）。
- **类似题目**：  
  1. 洛谷 P5431 【模板】乘法逆元2  
  2. 洛谷 P7044 「MCOI-03」括号

---

### 推荐题目
1. [P5431](https://www.luogu.com.cn/problem/P5431)  
2. [P7044](https://www.luogu.com.cn/problem/P7044)  
3. [P1495](https://www.luogu.com.cn/problem/P1495)（中国剩余定理中的逆元应用）

---

### 个人心得摘录
- **langmouren**：强调递推式中的正数转换，`(p - k)` 避免负数是关键技巧。
- **wurang**：指出除法在模运算中的特殊性，逆元是唯一解决方案。

---

### 可视化算法设计

#### 动画演示方案
1. **网格化数据展示**：  
   - 用像素网格表示 1~n 的逆元数组，初始全灰。
   - 当前计算位置 `i` 高亮为黄色，`p%i` 标记为绿色。

2. **递推公式动态分解**：  
   ```plaintext
   Step 1: p = 13, i = 2 → k = 6, r = 1
   Step 2: inv[2] = (13 - 6) * inv[1] % 13 = 7*1 = 7
   ```
   - 显示 `k = ⌊p/i⌋` 和 `r = p%i` 的计算过程。
   - 用箭头连接 `inv[r]` 到当前 `inv[i]`，红色标注数值传递。

3. **音效与进度**：  
   - 每计算一个逆元触发“8-bit 点击”音效。
   - 完成时播放经典 FC 过关音乐。

#### 复古风格实现
- **调色板**：  
  - 背景：深蓝 (#2C3E50)  
  - 当前元素：亮黄 (#F1C40F)  
  - 已计算元素：青绿 (#2ECC71)
- **Canvas 绘制**：每个逆元显示为 16x16 像素块，数值居中。

---

### 核心代码实现
```cpp
#include<cstdio>
const int maxn=3e6+5;
long long inv[maxn];
int main() {
    int n, p;
    scanf("%d%d", &n, &p);
    inv[1] = 1;
    puts("1");
    for (int i=2; i<=n; ++i) {
        inv[i] = (p - p/i) * inv[p%i] % p;
        printf("%lld\n", inv[i]);
    }
    return 0;
}
```

---
处理用时：60.04秒
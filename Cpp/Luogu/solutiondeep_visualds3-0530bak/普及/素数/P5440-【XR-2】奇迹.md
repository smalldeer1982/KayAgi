# 题目信息

# 【XR-2】奇迹

## 题目背景

> 相信奇迹的人，本身就和奇迹一样了不起。——笛亚 《星游记》

## 题目描述

我们称一个**日期**为一个八位数，第 $1\sim 4$ 位构成年，第 $5\sim 6$ 位构成月，第 $7\sim 8$ 位构成日，不足位数用 $0$ 补足。同时，要求日期所代表的这一天真实存在，且年的范围为 $1\sim 9999$。

出现奇迹的日期都存在相同的特点：由“日”组成的两位数，由“月+日”组成的四位数，由“年+月+日”组成的八位数均为**质数**。但并不是所有存在这样特点的日期都一定会出现奇迹。

现在，你得到了一个可能会出现奇迹的日期，然而不幸的是这个日期却是残缺的，八位中可能有若干位无法确定。你需要知道这个日期有多少种可能，这样你才能做好充足的准备去迎接奇迹的到来。

## 说明/提示

【样例 $1$ 说明】

`53-7-3-7` 的 $6$ 种可能的日期如下：

```plain
53070307
53070317
53170307
53370307
53570317
53770307
```

【数据规模与约定】

一共 $10$ 个测试点，记 $c$ 为八位字符串中 `-` 的个数。

对前 $9$ 个测试点，在第 $i$ 个测试点中保证 $c = i - 1$。

对 $100\%$ 的数据保证 $1 \le T \le 10$。

## 样例 #1

### 输入

```
2
53-7-3-7
20190629
```

### 输出

```
6
0
```

# AI分析结果



---

**唯一算法分类**：预处理+筛选

---

### **综合分析与结论**

**题目核心**：在满足日期合法性前提下，要求日、月日、年月日均为质数。需处理输入中的未知位（'-'），统计所有可能解。

**解决难点**：
1. **质数判断优化**：需多次判断不同位数的质数，预处理质数表或使用快速判断算法（如 Miller-Rabin）。
2. **日期合法性校验**：需处理闰年、月份天数等细节。
3. **大规模枚举优化**：直接暴力枚举所有可能日期会导致超时，需预处理有效日期或剪枝。

**核心算法流程**：
1. **预处理阶段**：生成所有满足条件的日期（年+月+日、月+日、日均为质数），存储为列表。
2. **查询阶段**：对每个输入，遍历预处理列表，检查是否匹配模式（未知位可填任意数字，已知位需严格匹配）。

**可视化设计思路**：
- **像素风格界面**：用 8-bit 风格展示日期生成过程，高亮当前处理的年/月/日。
- **动画步骤**：
  1. 屏幕左侧显示预处理流程，逐个生成候选日期并校验条件（质数用绿色闪烁，非法日期用红色标记）。
  2. 右侧显示输入模式匹配，用黄色框标记当前检查的位，匹配成功时播放音效。
- **交互功能**：支持暂停/继续，调节预处理速度，查看匹配详情。

---

### **题解清单（评分≥4星）**

1. **xht（★★★★★）**
   - **亮点**：预处理所有有效日期，查询时线性匹配，效率极高。
   - **代码结构**：预生成所有可能的月日组合和闰年情况，再生成完整日期并筛质数。
   - **优化点**：避免重复质数判断，时间复杂度 O(预处理) + O(T·N)，N 为有效日期数。

2. **Ciyang（★★★★☆）**
   - **亮点**：DFS 剪枝，按日→月→年顺序逐层判断，及时终止无效路径。
   - **优化点**：线性筛预处理小质数，快速判断大数质数。

3. **whale142857（★★★★）**
   - **亮点**：Miller-Rabin 快速判质，面向数据特判全'-'情况。
   - **优化点**：牺牲理论正确性换取速度，适用于宽松时间限制。

---

### **最优思路提炼**

**核心技巧**：
1. **预处理有效日期**：离线计算所有可能的解，存储后直接匹配输入。
2. **质数判断分层**：优先检查日、再月日、最后年月日，逐层剪枝。
3. **日期合法性快速校验**：预存月份天数表，处理闰年特例。

**代码片段（xht 题解核心逻辑）**：
```cpp
// 预处理所有有效日期
for (int i = 1; i <= 12; i++) // 枚举月份
    for (int j = 1; p[j] <= d[i]; j++) // 枚举可能的日
        if (is_prime(i * 100 + p[j])) // 月日是否为质数
            a[++t] = i * 100 + p[j]; // 存储合法月日

for (int i = 1; i <= 9999; i++) // 枚举年
    for (int j = 1; j <= t; j++) // 遍历合法月日
        if (is_prime(i * 10000 + a[j])) // 年月日是否为质数
            ans[++tot] = i * 10000 + a[j]; // 存储完整日期
```

---

### **相似题目推荐**
1. **P1028 数的计算**（预处理递推）
2. **P1217 回文质数**（质数+回文数预处理）
3. **P1064 金明的预算方案**（组合条件筛选）

---

### **个人心得摘录**
- **xht**：强调正确性优先，明确预处理范围，避免争议年份处理。
- **Ciyang**：调试中发现年份不能为0，加入特判后从10分→AC。
- **whale142857**：面向数据编程，本地跑出全'-'答案后直接打表。

---

### **可视化算法演示**
**像素动画设计**：
1. **预处理阶段**：
   - 屏幕分为上下两部分，上部生成月日组合，下部生成年月日。
   - 每个候选日期用像素方块表示，绿色表示通过质数校验，红色淘汰。
   
2. **匹配阶段**：
   - 输入模式显示为8个格子，未知位用"?"表示。
   - 预处理列表中的日期依次飞入右侧，与输入模式比对，匹配成功时播放8-bit音效。

**交互功能**：
- **速度调节**：滑动条控制预处理速度（1x-10x）。
- **单步执行**：按空格键逐步观察质数判断和日期生成。
- **音效**：成功匹配时播放《超级马里奥》金币音效，失败时播放《塞尔达传说》警告声。

---
处理用时：61.37秒
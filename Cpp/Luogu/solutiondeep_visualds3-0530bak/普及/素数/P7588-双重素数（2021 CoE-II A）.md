# 题目信息

# 双重素数（2021 CoE-II A）

## 题目描述

素数（质数）是指在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数。定义**双重素数**为这样的素数：它的各位数字之和也是一个素数。给定一个闭区间，试确定在该区间内双重素数的个数。

## 说明/提示

**样例说明**

从 $1$ 到 $15$ 共有 $6$ 个素数：$2$，$3$，$5$，$7$，$11$，$13$。前五个素数各自的数字之和也是素数，因此都是双重素数。素数 $13$ 的各位数字之和为 $4$，不是素数，故 $13$ 不是双重素数。

------------


**数据范围**

- Subtask $1$ ：$1 \le L \le R \le 10^2$，$10$ 分。
- Subtask $2$ ：$1 \le L \le R \le 10^4$，$20$ 分。
- Subtask $3$ ：$1 \le L \le R \le 10^6$，$60$ 分。
- Subtask $4$ ：$1 \le L \le R \le 10^8$，$10$ 分。

对于 $100\%$ 的数据，$1 \le T \le 100$。


------------

**提示（数据已经加强）**

最后一个子任务要求你的程序必须具有较高的空间使用效率和时间效率，否则容易超出内存限制或时间限制。

## 样例 #1

### 输入

```
4
3 3
4 4
1 5
1 15```

### 输出

```
1
0
3
5```

# AI分析结果



### 唯一算法分类
**筛法（欧拉筛）与二分查找**

---

### 题解思路、算法要点与解决难点

#### 核心思路
1. **欧拉筛法**：线性时间复杂度筛出所有素数。
2. **空间优化**：使用 `bitset` 或位数组（如 `unsigned int` 数组）标记合数，解决 1e8 数据规模下的内存限制问题。
3. **双重素数筛选**：对每个素数计算各位数字之和，通过预存小素数列表快速判断是否为素数。
4. **二分查找**：预处理后的双重素数数组有序，利用 `lower_bound` 和 `upper_bound` 快速统计区间内的数量。

#### 解决难点
- **空间优化**：传统 `bool` 数组需要约 100MB（1e8 元素），而 `bitset` 或位数组仅需约 12MB。
- **时间效率**：双重素数判断时，通过预存 2~72 之间的素数列表（如 `sushu` 函数直接枚举），避免重复计算。
- **查询优化**：预处理后的双重素数数组有序，单次查询时间复杂度为 O(log n)。

---

### 题解评分（≥4星）

1. **王熙文（4.5星）**
   - **亮点**：使用 `bitset` 优化空间，预处理小素数列表直接判断各位和。
   - **代码可读性**：清晰的结构，分两次筛法处理，二分查找简洁。
   - **优化程度**：高效处理 1e8 数据，空间与时间平衡。

2. **metaphysis（4.5星）**
   - **亮点**：手动位数组优化空间，预存 `magic` 数组快速判断各位和是否为素数。
   - **代码实现**：位操作高效，查询直接通过 `upper_bound` 和 `lower_bound` 差值计算。

3. **DWT8125（4星）**
   - **亮点**：记忆化优化各位和计算，降低重复运算。
   - **实现细节**：通过数组缓存已计算的各位和，提升二次筛法效率。

---

### 最优思路或技巧提炼

1. **欧拉筛法结合位数组**
   - 使用位数组或 `bitset` 标记合数，减少内存占用至 1/8。
   - 线性时间复杂度确保 1e8 数据筛法高效完成。

2. **预存小素数列表**
   - 各位和的范围为 2~72，预处理这些数的素数状态（如 `sushu` 函数直接枚举），避免重复计算。

3. **二分查找查询优化**
   - 预处理后的双重素数数组有序，单次查询时间复杂度 O(log n)。

---

### 同类型题或类似算法套路

1. **素数筛法结合预处理**：如 [P3383 线性筛素数](https://www.luogu.com.cn/problem/P3383)。
2. **数位处理与筛法结合**：如 [P1217 回文质数](https://www.luogu.com.cn/problem/P1217)。
3. **位数组优化空间**：类似大范围标记问题，如 [P1908 逆序对](https://www.luogu.com.cn/problem/P1908) 中的离散化技巧。

---

### 推荐相似知识点题目

1. **P3383**：线性筛模板题，理解筛法基础。
2. **P1217**：结合数位特性与筛法。
3. **P1835**：大范围素数密度问题，需空间优化。

---

### 可视化与算法演示

#### 核心算法流程
1. **欧拉筛过程**：
   - **动画效果**：网格中高亮当前处理的数 `i`，标记其与已筛素数的乘积。
   - **颜色标记**：素数用绿色，合数用红色，当前操作数用黄色闪烁。

2. **双重素数筛选**：
   - **步进演示**：对每个素数计算各位和，高亮其数位分解过程，并检查预存素数列表。
   - **成功标记**：双重素数用蓝色边框突出。

3. **二分查找查询**：
   - **动态区间**：显示 `lower_bound` 和 `upper_bound` 的移动过程，区间结果用紫色覆盖。

#### 复古像素化设计
- **8位风格界面**：素数网格采用 16x16 像素块，背景音乐为 8-bit 风格循环音效。
- **音效触发**：
  - 筛法标记合数时播放短促“滴”声。
  - 找到双重素数时播放“升级”音效。
- **Canvas 动画**：用网格表示 1~100 的数，滑动查看大范围数据，右侧显示当前处理状态。

---

### 核心代码片段

#### 王熙文的双重素数筛选
```cpp
bitset<100000001> b; // 空间优化
int dp[10000010], ans[10000010];

void work() {
    // 欧拉筛
    for (int i=2; i<=1e8; i++) {
        if (!b[i]) dp[++k] = i;
        for (int j=1; j<=k && i*dp[j]<=1e8; j++) {
            b[i*dp[j]] = 1;
            if (i % dp[j] == 0) break;
        }
    }
    // 筛选双重素数
    for (int i=1; i<=k; i++) {
        int sum = 0, t = dp[i];
        while (t) sum += t%10, t /= 10;
        if (sushu(sum)) ans[++cnt] = dp[i]; // sushu预存小素数
    }
}
```

#### metaphysis的位数组实现
```cpp
unsigned int B[(1e8 + 32) >> 5]; // 位数组
inline bool GET(int x) { return B[x >> 5] & (1 << (x & 31)); }

void sieve() {
    for (int i=2; i<=1e8; i++) {
        if (!GET(i)) {
            // 处理素数
            for (int j=1; i*prime[j]<=1e8; j++) {
                SET(i*prime[j]); // 标记合数
                if (i % prime[j] == 0) break;
            }
        }
    }
}
```

---

### 个人心得摘录

- **王熙文**：`bitset` 的空间优势在 1e8 数据下至关重要，直接决定是否 MLE。
- **metaphysis**：手动位数组比 `bitset` 更灵活，但需注意位操作的细节（如 `GET` 和 `SET` 的实现）。
- **DWT8125**：记忆化优化虽增加代码复杂度，但显著减少重复计算，适合多查询场景。

---

### 结论

双重素数问题的核心在于高效筛法、空间优化及快速查询。最优解法结合欧拉筛、位数组和预处理技巧，平衡时间与空间复杂度，适用于大范围数据。

---
处理用时：93.27秒
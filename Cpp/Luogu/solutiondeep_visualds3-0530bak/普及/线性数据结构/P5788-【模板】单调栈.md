# 题目信息

# 【模板】单调栈

## 题目背景

模板题，无背景。  

2019.12.12 更新数据，放宽时限，现在不再卡常了。

## 题目描述

给出项数为 $n$ 的整数数列 $a_{1 \dots n}$。

定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_i$ 的元素的**下标**，即 $f(i)=\min_{i<j\leq n, a_j > a_i} \{j\}$。若不存在，则 $f(i)=0$。

试求出 $f(1\dots n)$。

## 说明/提示

【数据规模与约定】

对于 $30\%$ 的数据，$n\leq 100$；

对于 $60\%$ 的数据，$n\leq 5 \times 10^3$ ；

对于 $100\%$ 的数据，$1 \le n\leq 3\times 10^6$，$1\leq a_i\leq 10^9$。

## 样例 #1

### 输入

```
5
1 4 2 3 5
```

### 输出

```
2 5 4 5 0
```

# AI分析结果



# 算法分类  
**单调栈**

---

## 综合分析与结论  
### 核心思路与难点  
所有题解均采用单调栈算法，核心思想是**维护一个元素值单调递减的栈**。从后往前遍历数组，对于每个元素：  
1. 弹出栈顶所有小于等于当前值的元素（这些元素的答案不可能是当前元素）  
2. 栈顶即为第一个更大的元素（若栈空则答案为0）  
3. 将当前元素下标入栈  

**关键难点**：  
- 遍历方向的选择（从后往前保证后续元素的单调性）  
- 栈中存储下标而非值，便于直接返回结果  
- 时间复杂度严格 O(n) 的证明（每个元素入栈出栈各一次）  

### 可视化设计  
**动画方案**：  
1. Canvas 绘制横向数组，元素用不同颜色方块表示  
2. 右侧动态显示单调栈结构（栈顶在上）  
3. 当前处理元素高亮黄色，弹出元素闪烁红色，新入栈元素绿色  
4. 栈弹出时显示连线动画，标注被弹出元素的答案下标  

**复古游戏化设计**：  
- 像素风格：16色（NES红白机调色板）  
- 音效：弹出时播放8-bit "blip"，找到答案时播放上升音阶  
- 自动模式：按1.5秒/步推进，手动可暂停/单步调试  

---

## 题解清单（≥4星）  
### 1. Mine_King（5星）  
**亮点**：  
- 代码最简洁（仅15行核心逻辑）  
- 使用STL栈结构清晰  
- 三目运算符处理空栈优雅  
```cpp
for(int i=n;i>=1;i--) {
    while(!s.empty()&&a[s.top()]<=a[i]) s.pop();
    f[i] = s.empty() ? 0 : s.top();
    s.push(i);
}
```

### 2. 封禁用户（4星）  
**亮点**：  
- 手写栈提升性能（避免STL开销）  
- 详细模拟过程（集训队比喻生动）  
```cpp
int top=0;
for(int i=1;i<=n;i++) {
    while(top && a[S[top]]<a[i]) 
        f[S[top--]]=i;
    S[++top]=i;
}
```

### 3. pomelo_nene（4星）  
**亮点**：  
- 深入讲解单调栈变种（递增/递减）  
- 拓展例题分析（直方图最大矩形等）  
- 伪代码规范便于理解  

---

## 最优技巧提炼  
### 核心实现思想  
```cpp
// 通用模板（从后往前遍历）
stack<int> s;
for(int i=n; i>=1; i--) {
    while(!s.empty() && a[s.top()] <= a[i]) 
        s.pop();
    ans[i] = s.empty() ? 0 : s.top();
    s.push(i);
}
```

### 关键优化  
- **方向选择**：从后往前遍历保证栈的单调性自然维护  
- **下标存储**：栈存储下标而非值，直接获取答案位置  
- **手写栈**：数组模拟栈提升性能（3e6数据量关键）  

---

## 类似题目推荐  
1. P1901 发射站（单调栈求双向最近更大元素）  
2. P2559 [AHOI2006] 最大矩形（直方图变种）  
3. P2422 良好的感觉（前缀和+单调栈）  

---

## 个人心得摘录  
> "调试时发现必须存储下标而非值，否则无法处理重复元素" —— LCuter  
> "手写栈比STL快0.3s，大数据量必须优化" —— 封禁用户  
> "想象成选手淘汰机制，比自己弱的弹出很直观" —— 大神题解  

---

## 可视化代码片段  
```javascript
// Canvas绘制栈变化（简化版）
function drawStack(ctx, stack, a, currentIdx) {
    ctx.clearRect(0, 0, 400, 200);
    // 绘制当前元素
    ctx.fillStyle = "#FFFF00";
    drawBlock(ctx, currentIdx*30, 50, a[currentIdx]);
    // 绘制栈
    ctx.fillStyle = "#00FF00"; 
    stack.forEach((idx, i) => {
        drawBlock(ctx, 300, 100-i*30, a[idx]);
    });
}
// 8-bit音效触发
function playSFX(type) {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = type === 'pop' ? 440 : 880;
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(0.1);
}
```

---

## 复古游戏化设计  
**颜色方案**：  
- 背景：#6B6B6B（NES灰色）  
- 栈元素：#FF2600（经典红）  
- 当前元素：#FFF000（耀黄）  

**自动演示逻辑**：  
```javascript
let autoTimer = setInterval(() => {
    if(currentIdx > 0) {
        processStep();
        currentIdx--;
    } else clearInterval(autoTimer);
}, 1500);
```

---
处理用时：62.14秒
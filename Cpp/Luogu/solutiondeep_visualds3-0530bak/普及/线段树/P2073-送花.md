# 题目信息

# 送花

## 题目背景

小明准备给小红送一束花，以表达他对小红的爱意。他在花店看中了一些花，准备用它们包成花束。


## 题目描述

这些花都很漂亮，每朵花有一个美丽值 $W$，价格为 $C$。

小明一开始有一个空的花束，他不断地向里面添加花。他有以下几种操作：

- $1\ W\ C$：添加一朵美丽值为 $W$，价格为 $C$ 的花。  
**如果此时花束中已经有了相等价格的花，那么这朵花不能加入花束。**
- $2$：删除当前花束里最贵的一朵花。
- $3$：删除当前花束里最便宜的一朵花。
- $-1$：完成添加与删除，开始包装花束。

**当花束为空时，忽略操作 $2$ 和 $3$。**

请你写一个程序，计算出开始包装花束时，花束中所有花的美丽值的总和，以及小明需要为花束付出的总价格。

## 说明/提示

设操作数为 $m$。

- 对于 $20\%$ 数据，$m \le 100$，$1\le W,C\le 10^3$。
- 对于全部数据，$m \le 10^5$，$1\le W,C\le 10^6$。

## 样例 #1

### 输入

```
1 1 1
1 2 5
2
1 3 3
3
1 5 2
-1
```

### 输出

```
8 5```

# AI分析结果



## 算法分类
**平衡树/有序集合**

---

## 题解思路与核心难点

### 核心逻辑
1. **插入操作**：维护一个有序集合，插入时自动去重并保持有序性  
2. **删除最值**：直接访问集合的首尾元素进行删除  
3. **统计总和**：遍历集合累加属性值

### 解决难点
- **高效维护动态有序集合**：需支持 O(log n) 的插入、删除极值操作  
- **去重逻辑**：插入时若价格已存在则拒绝操作  
- **STL 的迭代器边界处理**：删除最大值时需注意 `--end()` 的正确性

---

## 题解评分 (≥4星)

1. **kikuss 的 set 解法（5星）**  
   - 亮点：仅用 30 行代码实现所有功能，利用 STL 的特性优雅处理去重与极值操作  
   - 代码简洁度：⭐⭐⭐⭐⭐  
   - 时间复杂度：O(m log m)  

2. **XG_Zepto 的双优先队列解法（4星）**  
   - 亮点：用两个堆分别维护最大最小值，标记数组处理延迟删除  
   - 缺点：删除操作最坏 O(m log m)  
   - 代码可读性：⭐⭐⭐⭐  

3. **fyfy 的 vector 解法（4星）**  
   - 亮点：直接维护有序数组，代码极简  
   - 缺点：插入删除均为 O(n)，仅适用于小数据  
   - 适用场景：教学演示或比赛快速编码  

---

## 最优思路提炼

### 核心技巧
```cpp
set<node> v; // 按价格排序的结构体集合
// 插入时自动去重
v.insert((node){w, c}); 
// 删除最大值：取 end() 的前驱
v.erase(--v.end());
// 删除最小值：取 begin()
v.erase(v.begin());
```

### 关键优化点
- **利用 STL 的有序性**：避免手动实现平衡树的复杂性  
- **迭代器边界处理**：通过 `--end()` 正确访问最大元素  
- **结构体排序**：自定义 `operator<` 实现按价格排序

---

## 同类型题与算法套路

### 相似问题特征
- 需要动态维护有序集合  
- 高频插入、删除极值操作  
- 可能涉及去重或统计类查询  

### 推荐题目
1. **P1801 黑匣子**（对顶堆维护动态中位数）  
2. **P3369 【模板】普通平衡树**（标准平衡树操作）  
3. **P3871 [TJOI2010]中位数**（动态维护有序序列中位数）

---

## 代码核心片段

```cpp
struct node {
    int w, c;
    bool operator < (const node &a) const { 
        return c < a.c; // 按价格排序
    }
};

set<node> s;
long long sum_w = 0, sum_c = 0;

// 插入操作
void insert(int w, int c) {
    auto it = s.find(node{0, c});
    if (it != s.end()) return; // 去重
    s.insert(node{w, c});
}

// 删除最大值
void del_max() {
    if (!s.empty()) {
        auto it = --s.end();
        sum_w -= it->w;
        sum_c -= it->c;
        s.erase(it);
    }
}

// 删除最小值
void del_min() {
    if (!s.empty()) {
        auto it = s.begin();
        sum_w -= it->w;
        sum_c -= it->c;
        s.erase(it);
    }
}
```

---

## 可视化设计

### 动画演示要点
1. **插入流程**  
   - 高亮新插入的节点，显示其在有序集合中的正确位置  
   - 颜色标记：新节点用绿色，重复插入时红色闪烁提示  

2. **删除极值**  
   - 删除最大值时高亮集合末尾元素并渐变消失  
   - 删除最小值时高亮头部元素并渐变消失  

3. **数据结构展示**  
   - 用横向排列的方块表示 set 元素，价格从左到右递增  
   - 当前操作位置用箭头或边框高亮  

### 复古像素风格实现
```javascript
// Canvas 绘制示例（伪代码）
function drawSet(ctx) {
    let x = 50, y = 100;
    for (const node of s) {
        drawPixelRect(ctx, x, y, node.c); // 绘制价格方块
        x += 30;
    }
    // 高亮当前操作元素
    if (op === 'insert') {
        drawGlow(lastInsertNode, 'green');
    } else if (op === 'delete_max') {
        drawGlow(lastNode, 'red');
    }
}
```

---

## 总结与扩展
本题的**核心矛盾**在于动态维护有序集合的极值操作。使用 STL 的 set 能最直接地平衡代码复杂度和效率，而双堆方案则展示了另一种利用标记处理的巧妙思路。对于更大规模数据或更复杂操作（如区间查询），平衡树或线段树仍是更优选择。

---
处理用时：86.89秒
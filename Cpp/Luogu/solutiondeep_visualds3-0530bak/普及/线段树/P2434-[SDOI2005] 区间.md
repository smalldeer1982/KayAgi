# 题目信息

# [SDOI2005] 区间

## 题目描述

现给定 $n$ 个闭区间 $[a_i, b_i]$（$1 \le i \le n$）。这些区间的并可以表示为一些不相交的闭区间的并。你的任务就是在这些表示方式中找出包含最少区间的方案。你的输出应该按照区间的升序排列。这里如果说两个区间 $[a, b]$ 和 $[c, d]$ 是按照升序排列的，那么我们有 $a \le b < c \le d$。

请写一个程序：

读入这些区间；

计算满足给定条件的不相交闭区间；

把这些区间按照升序输出。

## 说明/提示

对于 $100 \%$ 的数据，$3 \le n \le 50000$，$1 \le a _ i \leq b _ i \le 1000000$。

## 样例 #1

### 输入

```
5

5 6

1 4

10 10

6 9

8 10

```

### 输出

```
1 4

5 10

```

# AI分析结果



## 算法分类
**贪心算法**

---

## 题解思路与算法分析

### 核心思路
所有题解的核心目标都是合并重叠/相邻的区间，但实现方式各异：
1. **差分法**：通过统计每个点的覆盖次数，识别区间起点（覆盖次数从 0→正）和终点（覆盖次数从正→0）。
2. **贪心排序+合并**：按左端点排序后，维护当前合并区间的右端点，依次合并可连接的区间。
3. **并查集**：将相交区间的父节点合并，最终输出根节点代表的合并区间。
4. **事件记录**：将区间端点视为事件（起点为+1，终点为-1），排序后模拟覆盖过程。

### 解决难点对比
| 方法       | 关键难点                                                                 | 优化/技巧                                                                 |
|------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------|
| 差分法     | 端点处理（如右端点是否+1）                                               | 离散化优化避免遍历整个范围                                               |
| 贪心排序   | 排序后需动态更新右端点                                                   | 排序后单次遍历即可合并，时间复杂度 O(n log n)                            |
| 并查集     | 合并逻辑需更新区间右端点                                                 | 通过路径压缩优化查询效率                                                 |
| 事件记录   | 事件排序时需处理相同位置的事件优先级（起点优先）                         | 按坐标排序，相同坐标时起点事件优先                                       |

---

## 高分题解推荐 (≥4星)
1. **NF_水饺（5星）**  
   - **亮点**：标准贪心实现，代码简洁，逻辑清晰。通过排序后维护动态右端点，完美处理所有合并情况。
   - **代码关键**：排序后单次遍历，`ov = max(ov, a[i].hi)` 动态更新右端点。

2. **蹲在丛中笑（4星）**  
   - **亮点**：差分思路新颖，代码极短。通过统计覆盖次数变化识别区间边界。
   - **注意点**：需处理右端点是否+1，离散化可优化性能。

3. **顾z（4星）**  
   - **亮点**：代码简洁，包含输入优化和区间合并的核心逻辑。
   - **关键代码**：`re = max(re, a[i].r)` 动态维护右端点。

---

## 最优思路提炼
**贪心排序合并法**  
1. **排序区间**：按左端点升序排序，确保处理顺序从左到右。
2. **合并逻辑**：维护当前合并区间的右端点 `R`。遍历时若新区间左端点 ≤ `R`，则更新 `R = max(R, 新区间右端点)`；否则输出当前区间并重置为新区间。
3. **边界处理**：遍历结束后需输出最后一个合并的区间。

```cpp
// 代码片段：贪心合并核心逻辑
sort(a+1, a+n+1, cmp); // 按左端点排序
int L = a[1].l, R = a[1].r;
for (int i=2; i<=n; i++) {
    if (a[i].l > R) { // 无法合并，输出当前区间
        cout << L << " " << R << endl;
        L = a[i].l;
        R = a[i].r;
    } else {
        R = max(R, a[i].r); // 合并右端点
    }
}
cout << L << " " << R << endl; // 输出最后一个区间
```

---

## 类似题目推荐
1. **LeetCode 56. Merge Intervals**（区间合并模板题）
2. **洛谷 P2082 区间覆盖**（求覆盖总长度，需处理离散化）
3. **Codeforces 1000C. Covered Points Count**（差分法统计覆盖点数量）

---

## 可视化与算法演示
### 贪心算法动画设计
1. **动画流程**：
   - **排序阶段**：显示所有区间按左端点排序后的排列。
   - **合并阶段**：高亮当前合并区间（如绿色），逐步向右扩展，遇到不可合并的区间时切换颜色并输出。
   
2. **交互设计**：
   - **步进控制**：允许单步执行，观察每一步合并逻辑。
   - **高亮标记**：当前处理的区间用红色边框标记，合并后的区间用渐变色填充。

3. **复古像素风格**：
   - **Canvas 绘制**：区间显示为横向色块，合并时播放 8-bit 音效。
   - **自动演示**：模拟“贪吃蛇”式移动，合并区间时显示爆炸特效。

```javascript
// 伪代码：Canvas 绘制合并过程
function drawInterval(ctx, L, R, color) {
    ctx.fillStyle = color;
    ctx.fillRect(L * scale, yPos, (R-L) * scale, 20);
}

// 合并动画示例
let currentL = sorted[0].L, currentR = sorted[0].R;
for (let interval of sorted) {
    if (interval.L > currentR) {
        drawResult(currentL, currentR); // 输出区间
        currentL = interval.L;
        currentR = interval.R;
    } else {
        currentR = Math.max(currentR, interval.R);
        playSound('merge'); // 播放合并音效
    }
}
```

---

## 总结
贪心排序合并法是本题的最优解，兼顾时间复杂度和代码简洁性。差分法适合区间范围较小或需要极简代码的场景，而并查集和事件记录则提供了不同的思维角度。理解区间合并的核心逻辑后，可快速解决同类问题。

---
处理用时：69.10秒
# 题目信息

# [USACO17DEC] My Cow Ate My Homework S

## 题目描述

在你的牛历史课上，你被布置了一份相当长的作业，包含 $N$ 个问题（$3 \leq N \leq 100,000$），每个问题的得分是一个在 0 到 10,000 之间的整数。按照惯例，你的老师计划通过去掉你得分最低的一个问题，然后对剩余问题的得分取平均来给出最终成绩。不幸的是，你的宠物奶牛 Bessie 刚刚吃掉了你前 $K$ 个问题的答案！（$K$ 可能小到 1，也可能大到 $N-2$）。

经过多次解释，你的老师终于相信了你的说法，并同意按照之前的方式对剩余的未被吃掉的部分作业进行评分——即去掉得分最低的问题（或在得分相同的情况下去掉其中一个），然后对剩余问题取平均。

请输出所有能够使你获得最高可能成绩的 $K$ 值，并按升序排列。

## 说明/提示

如果 Bessie 吃掉了前两个问题，那么剩余的得分是 9、2 和 7。去掉最低分并取平均后，最终成绩为 8，这是可能的最高成绩。

## 样例 #1

### 输入

```
5
3 1 9 2 7```

### 输出

```
2```

# AI分析结果



## 算法分类
**前缀和与后缀预处理**

---

## 题解思路与核心算法

### 题目核心逻辑
在吃掉前 K 个元素后，计算剩余元素的平均值（去掉最小值）。需找到使该平均值最大的所有 K 值。

### 关键难点与解决思路
1. **高效计算区间最小值**  
   朴素遍历每个 K 的时间复杂度为 O(n²)，无法通过大数据。需预处理后缀最小值数组 `mn[i]`，表示从 i 到结尾的最小值。
2. **快速计算区间和**  
   预处理后缀和数组 `sum[i]`，表示从 i 到结尾的总和。
3. **数学推导**  
   平均值公式为 `(sum[K+1..n] - mn[K+1..n]) / (n-K-1)`，通过预处理可 O(1) 计算。

### 算法流程
1. **预处理后缀数组**  
   ```cpp
   for (int i = n; i >= 1; i--) {
       mn[i] = min(mn[i+1], a[i]);
       sum[i] = sum[i+1] + a[i];
   }
   ```
2. **枚举 K 并计算**  
   ```cpp
   double max_avg = 0;
   for (int K = 1; K <= n-2; K++) {
       int i = K + 1; // 剩余区间的起点
       double avg = (sum[i] - mn[i]) / (n - i);
       if (avg > max_avg) {
           max_avg = avg;
           result.clear();
           result.push_back(K);
       } else if (avg == max_avg) {
           result.push_back(K);
       }
   }
   ```

---

## 高星题解推荐 (≥4星)

1. **作者：_jimmywang_（5星）**  
   - **亮点**：简洁高效的后缀预处理，O(n) 时间与空间，代码逻辑清晰。
   - **关键代码**：单次倒序遍历完成 `mn` 和 `sum` 的预处理。
   - **核心思想**：数学公式拆解为可预处理项，避免重复计算。

2. **作者：Siyuan（4星）**  
   - **亮点**：动态维护最小值和总和，减少预处理数组空间。
   - **关键代码**：倒序枚举时实时更新 `min` 和 `sum`。
   - **适用场景**：对内存敏感的场景。

3. **作者：TRZ_2007（4星）**  
   - **亮点**：前缀和与后缀最小值结合，避免倒序预处理。
   - **关键代码**：使用 `sum[n] - sum[K]` 计算区间和。
   - **优势**：更直观的区间和计算方式。

---

## 最优思路提炼
**预处理后缀数组**是本题最优解法，其核心在于：
1. **后缀最小值**：倒序遍历一次即可得到每个起点的最小值。
2. **后缀和**：同步计算区间和，避免重复累加。
3. **数学拆解**：将问题转化为可预处理项，实现 O(n) 时间复杂度。

---

## 类似题目推荐
1. **P2879 [USACO07JAN] Tallest Cow S**  
   - 区间覆盖问题，利用前缀和思想维护差值。
2. **P1886 滑动窗口 /【模板】单调队列**  
   - 滑动窗口最小值，可用单调队列优化。
3. **P2216 [HAOI2007] 理想的正方形**  
   - 二维区间最值，结合二维单调队列或 ST 表。

---

## 可视化设计
### 动画方案
- **像素风格显示**：用 8-bit 网格表示数组，红色方块标记当前处理的元素。
- **动态高亮**：预处理时，从右向左扫描，绿色表示当前 `mn[i]`，黄色表示 `sum[i]`。
- **音效触发**：每次更新最大值时播放上扬音效，重复值出现时播放低音提示。

### 关键步骤演示
1. **初始化数组**：显示原始数组和两个空白后缀数组。
2. **倒序填充**：逐步填充 `mn` 和 `sum`，显示递推过程。
3. **枚举 K 值**：从左向右移动指针，实时计算并显示当前平均值。
4. **结果标记**：最终有效的 K 值用闪烁边框突出。

### 交互控制
- **步进/暂停**：观察预处理和枚举过程。
- **速度调节**：拖动条控制动画速度。
- **模式切换**：对比暴力法（红色警告框）与优化法（绿色流畅动画）。

---

## 核心代码示例
```cpp
#include <vector>
#include <iostream>
using namespace std;

int main() {
    int n; cin >> n;
    vector<int> a(n+2), mn(n+2, 1e9);
    vector<long long> sum(n+2, 0);
    for (int i = 1; i <= n; i++) cin >> a[i];
    
    // 预处理后缀数组
    for (int i = n; i >= 1; i--) {
        mn[i] = min(mn[i+1], a[i]);
        sum[i] = sum[i+1] + a[i];
    }
    
    double max_avg = 0;
    vector<int> ans;
    for (int K = 1; K <= n-2; K++) {
        int i = K + 1;
        int cnt = n - i;
        if (cnt <= 0) continue;
        double avg = (sum[i] - mn[i]) * 1.0 / cnt;
        if (avg > max_avg + 1e-6) {
            max_avg = avg;
            ans = {K};
        } else if (abs(avg - max_avg) < 1e-6) {
            ans.push_back(K);
        }
    }
    
    for (int k : ans) cout << k << endl;
    return 0;
}
```

---
处理用时：112.87秒
# 题目信息

# [NICA #3] 星空（Easy Version）

## 题目背景

**Easy Version 和 Hard Version 差别在于数据范围。**

## 题目描述

小 R 有一个长度为 $n$ 的序列 $a$，保证序列中的每个数都是 $2$ 的整数次幂。

小 M 有一个数 $x$，她希望重新排列序列 $a$，使得不存在一个 $i\in[1,n)$ 满足 $a_i+a_{i+1}>x$。重排的方式为：选择一个 $1\sim n$ 的排列 $p$，然后令新序列 $a'$ 满足 $a'_i=a_{p_i}$。$a'$ 即为重排后的序列。

现在你想要知道有多少种重排的方式能满足小 M 的要求。两种重排方式不同当且仅当选择的排列 $p$ 不同。答案对 $10^9+7$ 取模。

## 说明/提示

数据保证，$2 \leq n \leq 61$，$1 \leq a_i \leq 2^{60}$，$1\le x< 2^{63}$。**每一个 $a_i$ 都不重复**。

## 样例 #1

### 输入

```
4 20
2 4 8 16```

### 输出

```
12```

# AI分析结果



## 唯一算法分类
**数学（组合数学）**

---

## 综合分析与结论

### 核心思路
题目核心在于利用 **2的幂次性质**：所有非最大值的元素之和一定小于最大值。因此只需关注最大值的位置及其相邻元素的选取。  
**解题步骤**：
1. 找出最大值，并统计满足 `a_i + max ≤ x` 的元素个数 `cnt`
2. 分情况计算贡献：
   - 最大值在首/尾：贡献为 `2 * cnt * (n-2)!`
   - 最大值在中间：贡献为 `(n-2) * cnt * (cnt-1) * (n-3)!`
3. 预处理阶乘模值，最终求和取模

### 难点与解决
- **关键观察**：非最大值的两两和必然小于最大值，仅需考虑最大值相邻元素
- **组合计算**：通过阶乘预处理快速计算全排列数，分情况用乘法原理统计贡献
- **边界处理**：确保 `cnt ≥ 0`，正确处理 `cnt=0` 时的无解情况

### 可视化设计
1. **动画流程**：
   - 高亮最大值元素，用不同颜色标记可与其相邻的 `cnt` 个元素
   - 动态展示最大值在首、尾、中间时的相邻元素选取过程
   - 阶乘部分以“粒子扩散”效果展示全排列的可能性
2. **复古像素风格**：
   - 使用 8-bit 音效（如选中元素时的“哔”声，计算完成时的“胜利”音效）
   - Canvas 绘制网格，最大值用红色方块，合法相邻元素用绿色方块
3. **交互功能**：
   - 步进控制：单步执行最大值位置切换与贡献计算
   - 自动演示：AI 自动遍历所有情况，展示公式推导过程

---

## 题解清单（评分 ≥4星）

### 1. 作者：起名字重要吗（★★★★☆）
- **亮点**：代码最简，直接组合公式计算，无冗余操作
- **核心代码**：
  ```cpp
  for(int i=1; i<=n; fac[i]=(fac[i-1]*i)%mod,i++) 
    if(a[i]!=maxa&&a[i]+maxa<=x) cnt++;
  printf("%lld", (2*cnt*fac[n-2] + (n-2)*cnt*(cnt-1)*fac[n-3]) % mod);
  ```

### 2. 作者：a_little_carrot（★★★★☆）
- **亮点**：代码紧凑，利用阶乘数组预处理，边界处理清晰
- **核心代码**：
  ```cpp
  For(i,1,n) maxn = max(maxn, read(p[i]));
  For(i,1,n) cnt += (p[i]!=maxn) && (p[i]+maxn<=x);
  ans = (2*cnt*f[n-2]) % mod;
  For(i,2,n-1) ans = (ans + cnt*(cnt-1)*f[n-3]) % mod;
  ```

### 3. 作者：wyf1202（★★★★☆）
- **亮点**：分情况循环枚举位置，逻辑清晰易扩展
- **核心代码**：
  ```cpp
  for(int i=1; i<=n; ++i) {
    if(i==1 || i==n) ans = (ans + sum * j[n-2]) % mod;
    else ans = (ans + sum*(sum-1) * j[n-3]) % mod;
  }
  ```

---

## 最优思路与代码实现

### 关键技巧
- **阶乘预处理**：O(n) 预计算所有可能用到的阶乘模值
- **分治组合**：将问题拆分为最大值位置的两类情况，分别计算贡献

### 完整代码（起名字重要吗版）
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, x, a[70], maxa, fac[70] = {1}, cnt, mod = 1e9 + 7;
int main() {
    scanf("%lld%lld", &n, &x);
    for (int i = 1; i <= n; i++) {
        scanf("%lld", &a[i]);
        maxa = max(maxa, a[i]);
    }
    for (int i = 1; i <= n; fac[i] = (fac[i - 1] * i) % mod, i++)
        if (a[i] != maxa && a[i] + maxa <= x) cnt++;
    printf("%lld", (2 * cnt * fac[n - 2] % mod + (n - 2) * cnt * (cnt - 1) * fac[n - 3] % mod) % mod);
    return 0;
}
```

---

## 相似题目推荐
1. **P1246 编码问题**：排列组合中的位置限制
2. **P1287 盒子与球**：分情况讨论元素放置
3. **P4369 组合数问题**：组合数的性质与快速计算

---

## 个人心得摘录
> **Melo_DDD**：  
> “当最大值在中间时需要两个相邻元素满足条件，但最初未考虑 `cnt < 2` 的情况，导致WA。调试后加入 `cnt*(cnt-1)` 才正确处理。”

---

## 可视化算法演示（伪代码示例）

```javascript
// 伪代码：Canvas绘制最大值位置与相邻元素
function draw(maxPos, neighbors) {
    ctx.clearRect(0, 0, width, height);
    // 绘制序列背景
    drawGrid(n, cellSize);
    // 高亮最大值位置
    drawCell(maxPos, 'red');
    // 绘制合法相邻元素
    neighbors.forEach(pos => drawCell(pos, 'green'));
}

// 示例交互
autoPlay(() => {
    let maxPos = 1;
    let cnt = calcValidNeighbors();
    highlight(maxPos, cnt);
    playSound('select');
    // 计算贡献并更新动画...
});
```

---
处理用时：89.98秒
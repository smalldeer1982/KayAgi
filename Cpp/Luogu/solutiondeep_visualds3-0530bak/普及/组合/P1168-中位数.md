# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果



**唯一算法分类**：对顶堆（双堆维护中位数）

---

### **综合分析与结论**

#### **核心思路与算法要点**
1. **对顶堆核心思想**  
   - 维护两个堆：**大根堆**存放较小的一半数，**小根堆**存放较大的一半数  
   - **关键约束**：小根堆大小 ≥ 大根堆大小，且两堆大小差 ≤1  
   - **中位数位置**：奇数项时，中位数为小根堆堆顶（若大小差1）或大根堆堆顶（若相等）

2. **核心难点与解决**  
   - **插入逻辑**：新元素与小根堆堆顶比较，较大则入小根堆，否则入大根堆  
   - **动态平衡**：插入后若两堆大小差超过1，将较大堆顶元素移至另一堆  
   - **时间复杂度**：每次插入和调整操作 O(log n)，总复杂度 O(n log n)  

#### **可视化设计思路**
- **动画演示**：  
  - **堆结构展示**：左侧大根堆（红色方块），右侧小根堆（蓝色方块），堆顶高亮  
  - **插入过程**：新元素根据比较逻辑进入对应堆，触发颜色闪烁（红/蓝）  
  - **平衡调整**：当堆大小差超过1时，移动堆顶元素动画（箭头移动 + 音效）  
  - **中位数标记**：当前中位数用黄色边框标记，动态更新位置  
- **复古像素风格**：  
  - 使用 8-bit 像素字体，堆结构用方块网格表示  
  - 背景音乐：8-bit 风格循环旋律，元素移动时播放 "NES 音效"  
  - **控制面板**：暂停/继续按钮，速度调节滑块（1x~5x）

---

### **题解清单 (≥4星)**

| 题解作者         | 评分 | 关键亮点                                                                 |
|------------------|------|--------------------------------------------------------------------------|
| 肖恩Sean         | ⭐⭐⭐⭐ | 代码简洁，使用 STL 优先队列实现，调整逻辑清晰，适合快速编码               |
| IRipple          | ⭐⭐⭐⭐ | 详细图解调整过程，维护 mid 变量的独特设计，适合理解堆平衡原理             |
| KobeBeanBryantCox| ⭐⭐⭐⭐ | 手写堆实现，完整展示堆操作细节，适合底层原理学习                         |

---

### **最优思路与技巧提炼**

#### **对顶堆核心代码片段**
```cpp
priority_queue<int> max_heap; // 大根堆（左半部分）
priority_queue<int, vector<int>, greater<int>> min_heap; // 小根堆（右半部分）

void insert(int x) {
    if (x > min_heap.top()) min_heap.push(x);
    else max_heap.push(x);
    
    // 平衡堆大小
    while (min_heap.size() > max_heap.size() + 1) {
        max_heap.push(min_heap.top());
        min_heap.pop();
    }
    while (max_heap.size() > min_heap.size()) {
        min_heap.push(max_heap.top());
        max_heap.pop();
    }
}

int get_median() {
    return min_heap.top(); // 右半部分堆顶为中位数
}
```

#### **关键优化点**
- **插入方向优化**：新元素直接与当前中位数比较，减少调整次数  
- **延迟调整策略**：仅在奇数项插入后检查平衡，减少无效操作  
- **STL容器选择**：优先队列自动维护堆性质，避免手动实现堆操作  

---

### **相似题目推荐**
1. **P1801 黑匣子**（对顶堆维护动态第k大）  
2. **P3871 中位数**（完全相同的双堆解法）  
3. **P3382 动态中位数**（扩展版，需处理删除操作）

---

### **可视化代码示例（伪代码）**

```javascript
// Canvas 绘制堆结构
function drawHeap(heap, x, y, isMaxHeap) {
  const blockSize = 30;
  heap.forEach((val, idx) => {
    const posY = y + idx * blockSize;
    ctx.fillStyle = isMaxHeap ? "#FF6666" : "#6699FF";
    ctx.fillRect(x, posY, blockSize, blockSize);
    ctx.fillText(val, x + 5, posY + 20);
  });
}

// 插入动画（伪代码）
async function animateInsert(value) {
  highlightComparison(value); // 高亮比较过程
  await sleep(500);
  moveToHeap(value, targetHeap); // 元素移动到对应堆
  checkBalance(); // 显示平衡调整动画
  updateMedianMarker(); // 更新中位数位置
}
```

---

### **总结**
对顶堆法以 O(n log n) 时间高效解决动态中位数问题，其核心在于通过双堆划分数据区间并动态平衡。STL优先队列大幅简化实现难度，适合竞赛快速编码。通过可视化可直观理解堆结构调整过程，而复古像素风格和音效增强学习趣味性。

---
处理用时：86.39秒
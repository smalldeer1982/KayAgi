# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果



### 唯一算法分类
线段树（双延迟标记）

---

### 题解思路与核心难点
**核心算法流程**：
1. **线段树维护**：每个节点存储`sum`（区间和）、`mul`（乘法标记）、`add`（加法标记）。
2. **延迟标记处理**：
   - **乘法优先级**：乘法操作会影响加法标记，需先处理乘法再处理加法。
   - **标记下传**：在访问子节点前，将父节点的`mul`和`add`标记合并到子节点，并更新子节点的`sum`值。
3. **区间更新**：
   - **乘法更新**：`sum *= k`, `mul *= k`, `add *= k`。
   - **加法更新**：`sum += k * len`, `add += k`。
4. **查询**：递归合并子区间的`sum`值，确保标记已下传。

**难点与解决**：
- **标记顺序**：乘法会影响加法，因此在合并标记时需先乘后加。
- **取模优化**：所有操作需即时取模，避免溢出。

---

### 题解评分（≥4星）
1. **Mingoal（4.5星）**  
   - 简洁高效，直接处理乘加标记顺序，代码可读性强。
2. **GaryZhong（4.2星）**  
   - 结构体指针实现，动态内存管理，清晰展示标记下传逻辑。
3. **YuntianZhao（4.0星）**  
   - 使用`int128`优化取模运算，适合大数场景。

---

### 最优思路/技巧提炼
1. **双标记处理**：
   - **乘加合并公式**：`sum = (sum * mul + add * len) % p`。
   - **下传规则**：子节点`add = add * parent_mul + parent_add`。
2. **初始化与边界处理**：`mul`初始化为1，`add`为0，叶子节点直接赋值。
3. **取模优化**：所有运算后立即取模，避免溢出。

---

### 同类型题推荐
1. **P3373 线段树2**：几乎相同题意，双标记线段树模板。
2. **P3372 区间加法**：单加法标记练习。
3. **P2572 序列操作**：结合更复杂标记处理。

---

### 代码片段（核心逻辑）
```cpp
struct Node {
    ll sum, add, mul;
};

void pushdown(int o, int l, int r) {
    int mid = (l + r) >> 1;
    // 更新左子节点
    tr[ls].sum = (tr[ls].sum * tr[o].mul + tr[o].add * (mid - l + 1)) % p;
    tr[ls].mul = (tr[ls].mul * tr[o].mul) % p;
    tr[ls].add = (tr[ls].add * tr[o].mul + tr[o].add) % p;
    // 更新右子节点
    tr[rs].sum = (tr[rs].sum * tr[o].mul + tr[o].add * (r - mid)) % p;
    tr[rs].mul = (tr[rs].mul * tr[o].mul) % p;
    tr[rs].add = (tr[rs].add * tr[o].mul + tr[o].add) % p;
    // 清空父节点标记
    tr[o].add = 0;
    tr[o].mul = 1;
}

void update_mul(int o, int l, int r, int L, int R, ll k) {
    if (L <= l && r <= R) {
        tr[o].sum = (tr[o].sum * k) % p;
        tr[o].mul = (tr[o].mul * k) % p;
        tr[o].add = (tr[o].add * k) % p;
        return;
    }
    pushdown(o, l, r);
    int mid = (l + r) >> 1;
    if (L <= mid) update_mul(ls, l, mid, L, R, k);
    if (R > mid) update_mul(rs, mid+1, r, L, R, k);
    tr[o].sum = (tr[ls].sum + tr[rs].sum) % p;
}
```

---

### 可视化设计
**动画方案**：
1. **像素风格线段树**：每个节点显示为方块，颜色区分`sum`、`mul`、`add`。
2. **标记下传动画**：
   - **乘法操作**：父节点闪烁红色，子节点渐变为橙色并更新数值。
   - **加法操作**：父节点闪烁蓝色，子节点渐变为绿色。
3. **音效触发**：
   - **标记下传**：8-bit "滴"声。
   - **查询完成**：胜利音效。

**交互功能**：
- **速度调节**：滑动条控制动画速度（0.5x~5x）。
- **自动演示**：展示乘加混合操作时的标记传递过程。

---

### 个人心得
- **调试教训**：忘记取模导致溢出，需在所有运算后立即`% p`。
- **思维突破**：理解乘法标记对加法的影响是解决双标记问题的关键。

---
处理用时：95.99秒
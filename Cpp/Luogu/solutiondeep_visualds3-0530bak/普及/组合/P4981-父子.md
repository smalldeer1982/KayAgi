# 题目信息

# 父子

## 题目背景

上演在各大学男生寝室的日常 $:$

$A :$ “我没带纸，快来厕所救我！”

$B :$ “叫爸爸。”

$A :$ “爸爸！”

$............................................$

$A :$ “我没钱了，能借我点吗。”

$B :$ “叫爸爸。”

$A :$ “爸爸！”

一个月后、

$B :$ “能把钱还给我吗。”

$A :$ “叫爸爸。”

$B :$ “爸爸！”

## 题目描述

对于全国各大大学的男生寝室，总是有各种混乱的父子关系。

那么假设现在我们一个男生寝室有不同的 $n$ 个人，每个人都至多有一个“爸爸”，可以有多个“儿子”，且有且只有一个人没有“爸爸”(毕竟是室长，还是要给点面子，当然了，室长人人当嘛)。

那么现在问题来了，对于一个有 $n$ 个人的寝室，最多可能存在多少种父子关系，当然每个人之间都必须要有直接或间接的父子关系。

## 说明/提示

- 对于 $10\%$ 的数据，保证 $t=0$；

- 另有 $30\%$ 的数据，保证 $n≤5$；

- 对于 $100\%$ 的数据，$t≤10^4$，$1\le n\le10^9$。


## 样例 #1

### 输入

```
1
3
```

### 输出

```
9```

## 样例 #2

### 输入

```
1
323
```

### 输出

```
283888610```

# AI分析结果



**算法分类**  
组合数学（Cayley定理应用）

---

### **题解思路与核心难点**
#### **核心思路**
题目要求计算有根树的数量，通过以下步骤推导：
1. **无根树计数**：根据 Cayley 公式，n 个节点的无根树数目为 $n^{n-2}$。
2. **转换为有根树**：每棵无根树可以任选一个节点作为根，共有 $n$ 种选择，故总数为 $n^{n-1}$。

#### **解决难点**
- **数学模型转换**：将父子关系抽象为有根树结构，避免误用其他组合模型（如卡特兰数）。
- **定理应用**：正确理解 Cayley 公式的适用条件（完全图的生成树计数）及其与 Prufer 编码的等价性。
- **大指数计算**：通过快速幂算法高效计算 $n^{n-1} \bmod 10^9+9$。

---

### **题解评分与亮点**
1. **DPair（★★★★★）**  
   - 详细解析 Prufer 编码的构造与唯一性，结合图文清晰证明 Cayley 公式。
   - 代码简洁，包含快速幂模板。
2. **mulberror（★★★★☆）**  
   - 直接点明 Cayley 公式的应用，代码高效。
   - 提醒常见错误（如误用卡特兰数）。
3. **周道_Althen（★★★★☆）**  
   - 结合矩阵树定理推导 Cayley 公式，提供另一种数学视角。
   - 代码简练，适合快速实现。

---

### **最优思路提炼**
1. **Cayley 公式**：无根树数量为 $n^{n-2}$，通过选根得到 $n^{n-1}$。
2. **快速幂优化**：处理 $n \le 10^9$ 的大指数计算，时间复杂度 $O(\log n)$。
3. **Prufer 编码**：证明关键步骤，展示树与编码的双射关系。

---

### **相似题型推荐**
1. [P4430 小猴打架](https://www.luogu.com.cn/problem/P4430)  
2. [P2606 排列计数](https://www.luogu.com.cn/problem/P2606)  
3. [P1226 快速幂模板](https://www.luogu.com.cn/problem/P1226)

---

### **可视化设计**
#### **动画方案**
- **像素风格演示**：  
  1. **节点与边**：用 8-bit 像素点表示树节点，绿色为根节点，蓝色为叶子。
  2. **Prufer 编码生成**：逐步删除最小叶子节点，动态显示编码序列的构建。
  3. **根节点切换**：高亮不同根的选择，展示 $n$ 种可能性。
- **音效交互**：  
  - 删除叶子时播放「哔」声，编码生成完毕播放上升音阶。
  - 根节点切换时触发「咔嗒」音效。

#### **代码片段（Canvas 绘制）**
```javascript
// 伪代码：绘制节点与边
function drawTree(nodes, edges) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  nodes.forEach((node, i) => {
    drawPixel(node.x, node.y, node.isRoot ? '#00FF00' : '#0000FF');
  });
  edges.forEach(edge => {
    drawLine(edge.from, edge.to, '#FFFFFF');
  });
}
```

---

### **核心代码实现**
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL MOD = 1e9+9;

LL qpow(LL a, LL b) { // 快速幂
    LL res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        LL n; scanf("%lld", &n);
        printf("%lld\n", qpow(n, n-1));
    }
    return 0;
}
```

---

**总结**：通过 Cayley 定理与 Prufer 编码的数学推导，结合快速幂实现高效计算，核心在于理解树结构与组合计数的映射关系。

---
处理用时：73.54秒
# 题目信息

# [yLOI2019] 青原樱

## 题目背景

> 星川之下皆萤火尘埃，  
> 我独行在人潮你天真而待。  
> 相遇若是借丹青着色，  
> 青原上 绯樱如海。

——银临《青原樱》(Cover 人衣大人)

## 题目描述

扶苏是一个非常喜欢边听古风鸽边写数学题的人，因此这道题其实是个五三原题。

扶苏希望重现青原上樱花盛开的景色，于是他准备了很多**互不相同**樱花树幼苗，准备种成一行。

这一行中，一共有 $n$ 个位置可以种下樱花，而扶苏准备了 $m$ 支幼苗。由于樱花盛放时对左右空间需求非常大，所以樱花不能紧挨着种植，也就是任意两支幼苗之间必须至少存在一个不种花的空位置。

按照这种方式种花并不难，但是令扶苏感到好奇的是一共有多少合法的方案让他把这 $m$ 支幼苗都种下去。一个方案是合法的当且仅当他满足上一段中叙述的要求。如果我们将花按照 $1,2,3,\dots,m$ 编号，两种方案不同当且仅当被选择种花的位置不同或从左向右数花的编号序列不同。

为了避免输出过大，答案对一个参数 $p$ 取模。

## 说明/提示

#### 样例输入输出 1 解释
一共有 $2$ 个樱花幼苗， $3$ 个种花的位置，如果给幼苗编号为 $1,~2$，位置编号为 $1,~2,~3$，那么两种方案分别如下：

| 位置 | $1$ | $2$ | $3$ |
| :---: | :---: | :---: | :---: |
| 方案 1 | 幼苗 $1$ | 空 | 幼苗 $2$ |
| 方案 2 | 幼苗 $2$ | 空 | 幼苗 $1$ |

---

#### 数据规模与约定

**本题采用多测试点捆绑测试，共有 6 个子任务**。

| 子任务编号 | $n \leq$ | $m \leq$ | $type=$ | 特殊性质 | 子任务分值 |
| :----------: | :--------: | :----------: | :-------: | :--------: | :-----------: |
| 1 | $1$ | $1$ | $0$ | 特殊性质 1 | $5$ |
| 2 | $20$ | $20$ | $1$ | 特殊性质 1 | $15$ |
| 3 | $400$ | $200$ | $2$ | 无 | $20$ |
| 4 | $2000$ | $2000$ | $3$ | 无 | $20$ |
| 5 | $2000000$ | $1000000$ | $4$| 特殊性质 2 | $20$ | 
| 6 | $2000000$ | $1000000$ | $5$| 无 | $20$ | 

特殊性质 1：保证对应测试点的**实际**方案数(在取模前)不超过 $10^6$

特殊性质 2：保证 $p$ 是一个质数。

对于 $100\%$ 的数据，保证：
- $1 \leq n \leq 2 \times 10^6$。
- $1 \leq m \leq 10^6 $。
- $1 \leq p \leq 10^9$。
- $1 \leq m \leq \lceil\frac{n}{2} \rceil$。

---

#### 提示

- 请使用合适的数据类型来进行运算，避免溢出。
- 参数 $type$ 可以帮助你快速的判断子任务编号。


## 样例 #1

### 输入

```
1 3 2 19260718```

### 输出

```
2```

# AI分析结果



## 算法分类
排列组合（插空法）

---

## 题解思路与解决难点

### 核心思路
1. **插空法建模**：将m棵樱花树视为必须占据的位置，且每两棵树之间至少有一个空位。等价于在n个位置中预留m-1个空位，剩下n-m+1个位置中选择m个位置进行有序排列。
2. **排列数公式**：答案为排列数A(n-m+1, m) = (n-m+1) × (n-m) × ... × (n-2m+2)。

### 难点突破
- **相邻限制转化**：将题目中的"不能相邻"转化为"每棵树后必须预留空位"，通过预留空位将问题转化为无约束排列问题。
- **边界条件处理**：当m=0或n<2m-1时直接判无解（题目保证1≤m≤⌈n/2⌉，故无需处理）。

---

## 题解评分（≥4星）

### 五星题解
1. **yyh_1102（赞256）**
   - 亮点：通过生活化举例（公交车座位、节目排列）详解插空法，并给出排列组合基础教学。
   - 代码：直接计算连续乘积，时间复杂度O(m)。
2. **一扶苏一（赞91）**
   - 亮点：多角度分析（动态规划→组合数学→代数恒等变形），给出子任务分步优化思路。
   - 代码：循环计算连续乘积，兼容大数取模。

### 四星题解
1. **ez_lcw（赞68）**
   - 亮点：代码极简（5行实现核心逻辑），适合快速理解核心公式。
   - 不足：推导过程描述较简略。

---

## 最优思路提炼
**关键技巧**：  
1. **预留空位法**：通过预留m-1个强制空位，将约束问题转化为无约束排列问题。
2. **乘积优化**：直接计算(n-m+1)到(n-2m+2)的连续乘积，避免阶乘溢出。

**思维突破点**：  
将复杂的不相邻约束转化为有序排列问题，通过代数恒等式A(n-m+1, m) = A(n-m+1, m) 直接得到解。

---

## 同类型题与算法套路
**相似算法套路**：  
1. **不相邻排列**：如[CF888D] Almost Identity Permutations（错位排列变形）
2. **间隔放置问题**：如[洛谷P3223] 排队（多重约束下的排列组合）

**推荐练习题目**：  
1. P2290 [HNOI2004] 树的计数（组合数+Purfer序列）
2. P3223 [HNOI2012] 排队（多重排列约束）
3. P1357 花园（环形不相邻排列）

---

## 可视化与算法演示
**动画设计**：  
1. **像素化插空演示**：  
   - **步骤1**：显示n个灰色方块代表初始位置。  
   - **步骤2**：用红色方块标记m个树的位置，自动插入m-1个绿色空位（强制间隔）。  
   - **步骤3**：剩余位置高亮为黄色，动态计算(n-m+1)到(n-2m+2)的乘积过程。  

**交互功能**：  
- **速度控制**：滑动条调节计算步频（0.5x~3x）。  
- **音效反馈**：每计算一个乘数播放8-bit音效，完成时播放胜利音效。  

**复古风格CSS片段**：  
```css
.pixel-font {
  font-family: 'Press Start 2P', cursive;
  color: #8B8BEF;
}
.grid-cell {
  width: 20px;
  height: 20px;
  background: #444;
  border: 1px solid #666;
}
```

---

## 核心代码实现
```cpp
#include <stdio.h>

int main() {
  int type, n, m, p;
  scanf("%d%d%d%d", &type, &n, &m, &p);
  long long ans = 1;
  for (int i = n - m + 1; i >= n - 2 * m + 2; --i) {
    ans = ans * i % p;
  }
  printf("%lld\n", ans);
  return 0;
}
```

**代码要点**：  
- 循环从(n-m+1)递减至(n-2m+2)，共m项相乘。
- 每次乘法后立即取模，防止溢出。

---

## 个人心得摘录
> "排列组合问题常需要将复杂约束转化为已知模型。本题通过预留空位将不相邻问题转化为简单排列，启示我们面对约束时，应优先考虑如何通过数学建模消除约束条件。"  
> —— 摘自题解评论区

---

## 复古游戏化演示（Web实现伪代码）
```javascript
// Canvas绘制核心逻辑
function drawStep(step) {
  ctx.fillStyle = "#333";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // 绘制已计算的位置
  for (let i=0; i<step; i++) {
    ctx.fillStyle = (i%2 === 0) ? "#F00" : "#0F0";
    ctx.fillRect(10 + i*30, 50, 20, 20);
  }
  
  // 播放音效
  beep(440 + step*20, 100);
}
```

---
处理用时：77.07秒
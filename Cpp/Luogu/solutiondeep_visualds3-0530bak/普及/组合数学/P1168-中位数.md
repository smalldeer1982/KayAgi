# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果



# 中位数题解分析

**唯一算法分类**：对顶堆

---

## 综合分析与结论

### 核心思路
1. **对顶堆法**：维护一个大根堆（存储较小的一半元素）和一个小根堆（存储较大的一半元素）。插入元素时根据大小选择堆，确保大根堆顶 ≤ 小根堆顶，并通过调整保持两堆大小差 ≤1。中位数为较大堆的堆顶。
2. **关键难点**：动态维护两堆平衡，保证中位数快速获取。

### 可视化设计
- **动画流程**：
  1. 插入元素时高亮当前元素，根据大小分配到对应堆。
  2. 堆调整时用箭头表示元素移动，突出交换堆顶的过程。
  3. 中位数显示时用不同颜色标识当前堆顶。
- **复古像素风格**：用8位色块表示堆元素，调整时播放经典音效，背景音乐循环。

---

## 题解清单（≥4星）

### 1. 对顶堆法（肖恩Sean） ★★★★★
- **亮点**：逻辑清晰，代码简洁，维护堆平衡高效。
- **核心代码**：
  ```cpp
  priority_queue<int> q1; // 大根堆（较小半）
  priority_queue<int, vector<int>, greater<int>> q2; // 小根堆（较大半）
  while (abs(q1.size() - q2.size()) > 1) {
    if (q1.size() > q2.size()) { q2.push(q1.top()); q1.pop(); }
    else { q1.push(q2.top()); q2.pop(); }
  }
  ```

### 2. 树状数组+二分（ysj1173886760） ★★★★
- **亮点**：离散化处理大值域，树状数组高效查询第k小。
- **关键点**：离散化后维护前缀和，二分确定中位数位置。

### 3. 平衡树（Capella） ★★★★
- **亮点**：直接维护有序结构，支持动态插入和查询。
- **代码片段**：
  ```cpp
  void insert(Node* &o, int x) {
    if (o == null) o = new Node(x);
    else if (x < o->v) insert(o->lc, x);
    else insert(o->rc, x);
    // 旋转维护平衡
  }
  ```

---

## 核心代码实现（对顶堆）

```cpp
#include <queue>
#include <cstdio>
using namespace std;

int main() {
    int n, x;
    scanf("%d", &n);
    priority_queue<int> q1; // 大根堆（较小半）
    priority_queue<int, vector<int>, greater<int>> q2; // 小根堆（较大半）

    scanf("%d", &x);
    q1.push(x);
    printf("%d\n", x);

    for (int i = 3; i <= n; i += 2) {
        int a, b;
        scanf("%d%d", &a, &b);
        // 插入并调整堆
        if (a <= q1.top()) q1.push(a); else q2.push(a);
        if (b <= q1.top()) q1.push(b); else q2.push(b);
        
        // 平衡堆大小
        while (q1.size() > q2.size() + 1) {
            q2.push(q1.top()); q1.pop();
        }
        while (q2.size() > q1.size()) {
            q1.push(q2.top()); q2.pop();
        }
        printf("%d\n", q1.top());
    }
    return 0;
}
```

---

## 同类题目推荐
1. **P1801 黑匣子** - 动态维护第k大
2. **P3871 中位数** - 类似对顶堆解法
3. **P3380 二逼平衡树** - 多操作平衡树应用

---
处理用时：78.70秒
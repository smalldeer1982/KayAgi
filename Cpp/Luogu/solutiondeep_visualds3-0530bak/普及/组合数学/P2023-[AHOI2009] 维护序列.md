# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果



### 算法分类
线段树（双标记处理）

### 题解思路与算法要点
1. **核心逻辑**：线段树维护区间和，处理乘法和加法双标记，确保运算优先级（乘法先于加法）。
2. **标记处理**：
   - **乘法标记**：影响子节点的加法标记和乘法标记。
   - **加法标记**：在乘法标记处理后叠加。
   - **下传顺序**：先处理乘法，再处理加法。
3. **模运算**：所有操作需对结果取模，防止溢出。

### 题解评分（≥4星）
1. **Mingoal（4.5星）**：代码简洁，标记处理清晰，适合模板复用。
2. **zjy111（4.5星）**：详细解释线段树构建和标记下传，适合初学者。
3. **GaryZhong（4星）**：结构明确，使用指针优化空间管理。

### 最优思路与技巧
- **标记下传顺序**：乘法标记先更新子节点的加法标记，再处理加法。
- **分块优化**：分块处理边界，暴力修改零碎区间。
- **初始化技巧**：乘法标记初始化为1，加法为0，避免脏数据。

### 类似题目推荐
1. **P3373**：线段树模板2（双标记）
2. **P1047**：区间覆盖问题
3. **P1253**：区间加减与最值

---

### 核心代码实现
```cpp
struct Node {
    ll sum, add, mul;
    int l, r;
} tr[N << 2];

void pushup(int u) {
    tr[u].sum = (tr[u<<1].sum + tr[u<<1|1].sum) % p;
}

void pushdown(int u) {
    int len = tr[u].r - tr[u].l + 1;
    // 更新左儿子
    tr[u<<1].sum = (tr[u<<1].sum * tr[u].mul + tr[u].add * (len - len/2)) % p;
    tr[u<<1].mul = tr[u<<1].mul * tr[u].mul % p;
    tr[u<<1].add = (tr[u<<1].add * tr[u].mul + tr[u].add) % p;
    // 更新右儿子
    tr[u<<1|1].sum = (tr[u<<1|1].sum * tr[u].mul + tr[u].add * (len/2)) % p;
    tr[u<<1|1].mul = tr[u<<1|1].mul * tr[u].mul % p;
    tr[u<<1|1].add = (tr[u<<1|1].add * tr[u].mul + tr[u].add) % p;
    // 清空父节点标记
    tr[u].add = 0;
    tr[u].mul = 1;
}

void update_add(int u, int l, int r, ll k) {
    if (tr[u].l >= l && tr[u].r <= r) {
        tr[u].sum = (tr[u].sum + k * (tr[u].r - tr[u].l + 1)) % p;
        tr[u].add = (tr[u].add + k) % p;
        return;
    }
    pushdown(u);
    int mid = (tr[u].l + tr[u].r) >> 1;
    if (l <= mid) update_add(u<<1, l, r, k);
    if (r > mid) update_add(u<<1|1, l, r, k);
    pushup(u);
}

void update_mul(int u, int l, int r, ll k) {
    if (tr[u].l >= l && tr[u].r <= r) {
        tr[u].sum = tr[u].sum * k % p;
        tr[u].mul = tr[u].mul * k % p;
        tr[u].add = tr[u].add * k % p;
        return;
    }
    pushdown(u);
    int mid = (tr[u].l + tr[u].r) >> 1;
    if (l <= mid) update_mul(u<<1, l, r, k);
    if (r > mid) update_mul(u<<1|1, l, r, k);
    pushup(u);
}
```

---

### 可视化与算法演示
**动画方案**：
1. **线段树结构**：用网格展示节点区间范围，颜色区分不同操作。
2. **标记下传**：高亮当前节点，显示mul/add变化，子节点颜色渐变。
3. **交互控制**：支持步进执行，速度调节，查看标记传递细节。

**复古游戏化设计**：
- **像素风格**：节点用8位色块表示，乘法红色闪光，加法蓝色波纹。
- **音效触发**：标记下传时播放“滴”声，正确操作后奖励音效。
- **积分系统**：正确完成区间操作获得积分，错误处理扣分。

**Canvas绘制示例**：
```javascript
function drawNode(node, x, y) {
    ctx.fillStyle = node.mul !== 1 ? '#FF6666' : '#66CCFF';
    ctx.fillRect(x, y, 50, 30);
    ctx.fillText(`sum:${node.sum}`, x+5, y+10);
}
```

---

**总结**：正确处理双标记顺序是关键，结合线段树高效处理区间操作，复古动画增强学习趣味性。

---
处理用时：106.48秒
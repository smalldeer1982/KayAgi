# 题目信息

# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# AI分析结果



## 算法分类
带权并查集 / 种类并查集

---

## 综合分析与结论
### 核心算法流程
1. **三倍并查集法**：
   - 将每个动物x拆分为三个虚拟节点：x（同类域）、x+n（捕食域）、x+2n（天敌域）
   - 合并策略：
     - 同类关系：合并x↔y、x+n↔y+n、x+2n↔y+2n
     - 捕食关系：合并x↔y+2n、x+n↔y、x+2n↔y+n
   - 可视化要点：
     - 用三种颜色区分三个虚拟域（同类蓝/捕食红/天敌黄）
     - 合并时动态显示三个域的同步连接
     - 冲突检测时高亮相关域的根节点

2. **带权并查集法**：
   - 维护权值数组r[x]表示x与父节点的关系（0=同类/1=被父吃/2=吃父）
   - 路径压缩时权值更新公式：r[x] = (r[x] + r[father]) % 3
   - 合并时权值计算：r[new_root] = (r[y] - r[x] + relation + 3) % 3
   - 可视化要点：
     - 节点间显示带权箭头（0→绿色/1→红色/2→蓝色）
     - 路径压缩时动态更新权值计算过程

---

## 题解评分（≥4星）
### 1. Sooke（★★★★☆）
- **亮点**：三倍并查集经典实现，逻辑清晰，配图说明环形关系
- **核心代码**：
```cpp
fa[find(x)] = find(y);         // 合并同类域
fa[find(x+n)] = find(y+n);     // 合并捕食域 
fa[find(x+2n)] = find(y+2n);   // 合并天敌域
```

### 2. 檀黎斗·神（★★★★☆）
- **亮点**：最简三倍集实现，50行极简代码，变量命名直观
- **核心代码**：
```cpp
// x吃y的三种关系合并
fa[find(x)] = find(y+2n);     // x同类与y的天敌合并
fa[find(x+n)] = find(y);       // x捕食与y同类合并
```

### 3. 天泽龟（★★★★★）
- **亮点**：带权并查集完整推导，数学公式清晰，给出关系转移表
- **核心代码**：
```cpp
// 路径压缩时的权值更新
r[x] = (r[x] + r[father]) % 3;
```

---

## 最优技巧提炼
### 1. 三倍虚拟域技巧
- 将每个实体节点扩展为三个逻辑域，通过域间合并表达复杂关系
- 同类关系需同步三个域，捕食关系形成环形合并链

### 2. 权值传递公式
- 路径压缩时：r[x] = (r[x] + r[father]) % 3
- 合并时：r[new_root] = (r[y] - r[x] + 1 + 3) % 3（捕食关系）

---

## 同类题目推荐
1. P1525 关押罪犯（种类并查集处理敌对关系）
2. P1196 银河英雄传说（带权并查集维护队列长度）
3. P1955 程序自动分析（离散化+并查集）

---

## 可视化设计
### 像素风格演示方案
```javascript
// Canvas绘制示例
const drawNode = (ctx, x, y, type) => {
  const colors = [[0,255,0], [255,0,0], [0,0,255]]; // 三色表示三域
  ctx.fillStyle = `rgb(${colors[type].join()})`;
  ctx.fillRect(x*30, y*30, 25, 25); // 每个节点30x30像素
};

// 合并动画示例
function animateMerge(from, to) {
  const arrow = createArrow(from, to); // 生成8-bit箭头精灵
  arrow.playMergeSFX(); // 播放FC风格音效
}
```

### 交互功能
- **WASD**控制视角移动
- **空格键**单步执行操作
- **数字键1-3**切换显示不同域
- **BGM**：8-bit版《超级马里奥》地下关音乐循环

---

## 核心代码实现（三倍集法）
```cpp
const int MAXN = 5e4*3 + 10;
int fa[MAXN];

int find(int x) {
  return fa[x] == x ? x : fa[x] = find(fa[x]);
}

void solve() {
  int n, k, ans = 0;
  cin >> n >> k;
  iota(fa, fa+3*n+1, 0); // 初始化三倍数组
  
  while(k--) {
    int op, x, y;
    cin >> op >> x >> y;
    
    if(x > n || y > n) { ans++; continue; }
    
    if(op == 1) { // 同类关系
      if(find(x) == find(y+n) || find(x) == find(y+2*n)) {
        ans++;
      } else {
        // 三域同步合并
        fa[find(x)] = find(y);
        fa[find(x+n)] = find(y+n);
        fa[find(x+2*n)] = find(y+2*n);
      }
    } else { // 捕食关系
      if(x == y || find(x) == find(y) || find(x) == find(y+n)) {
        ans++;
      } else {
        // 形成环形关系链
        fa[find(x)] = find(y+2*n);
        fa[find(x+n)] = find(y);
        fa[find(x+2*n)] = find(y+n);
      }
    }
  }
  cout << ans;
}
```

---
处理用时：86.87秒
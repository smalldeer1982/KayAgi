# 题目信息

# [HNOI2008] 越狱

## 题目描述

监狱有 $n$ 个房间，每个房间关押一个犯人，有 $m$ 种宗教，每个犯人会信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。

答案对 $100,003$ 取模。

## 说明/提示

#### 样例输入输出 1 解释

| 状态编号 | 1 号房间 | 2 号房间 | 3 号房间 |
| :--------: | :--------: | :-------: | :--------: |
| 1 | 信仰 1 | 信仰 1 | 信仰 1 |
| 2 | 信仰 1 | 信仰 1 | 信仰 2 |
| 3 | 信仰 1 | 信仰 2 | 信仰 2 |
| 4 | 信仰 2 | 信仰 1 | 信仰 1 |
| 5 | 信仰 2 | 信仰 2 | 信仰 2 |
| 6 | 信仰 2 | 信仰 2 | 信仰 1 |

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \le m \le 10^8$，$1 \le n \le 10^{12}$。

## 样例 #1

### 输入

```
2 3
```

### 输出

```
6```

# AI分析结果



### 唯一算法分类：快速幂 + 补集思想

---

### 题解思路与核心难点

#### 核心算法流程
1. **补集转换**：总状态数 $m^n$ 减去相邻不重复状态数 $m \cdot (m-1)^{n-1}$
2. **快速幂实现**：递归或迭代方式计算大数幂次取模
3. **负数处理**：相减后结果可能为负，需加模数再取模

#### 解决难点
- **指数爆炸**：通过快速幂将时间复杂度从 $O(n)$ 降为 $O(\log n)$
- **补集推导**：证明非越狱状态数为 $m \cdot (m-1)^{n-1}$ 的数学推导
- **取模优化**：在每一步乘法运算后立即取模防止溢出

---

### 题解评分（≥4星）

1. **蒟蒻初音ミク（★★★★☆）**
   - 亮点：代码最简洁，直接给出核心公式推导
   - 代码可读性：基础快速幂模板，但缺少注释
   - 优化点：递归式快速幂实现

2. **Kisaragi_77（★★★★☆）**
   - 亮点：代码极简（仅15行），完美处理负数情况
   - 核心代码：
     ```cpp
     ans = qpow(m,n) - m*qpow(m-1,n-1)%MOD;
     ans = (ans%MOD + MOD)%MOD; // 负数修正
     ```

3. **Drinkkk（★★★★☆）**
   - 亮点：完整注释体系，包含调试经验总结
   - 代码亮点：
     ```cpp
     ans3 = ans1 - ans2;
     if(ans3 < 0) ans3 += p; // 调试经验：负数修正
     ```

---

### 最优思路与技巧

#### 关键公式
$$ ans = (m^n - m \cdot (m-1)^{n-1}) \mod 100003 $$

#### 实现技巧
1. **快速幂模板化**：封装可复用的快速幂函数
   ```cpp
   ll qpow(ll a, ll b) {
       ll res = 1;
       while(b) {
           if(b & 1) res = res * a % MOD;
           a = a * a % MOD;
           b >>= 1;
       }
       return res;
   }
   ```
2. **负数修正公式**：`(a - b + MOD) % MOD` 保证结果非负

---

### 同类型题拓展

#### 相似算法套路
- **补集思想**：P2675（三角牧场）、P4342（多项式求根）
- **快速幂应用**：P1226（快速幂模板）、P1309（斐波那契矩阵加速）

---

### 推荐练习题
1. **P1226** 【模板】快速幂（直接练习快速幂实现）
2. **P2675** 《数字游戏》（补集思想+排列组合）
3. **P1309** 瑞士轮（快速幂结合矩阵加速）

---

### 可视化与算法演示

#### 动画设计方案
1. **像素风格展示**：
   - 用红色方块表示总状态数 $m^n$ 的计算过程
   - 用蓝色方块展示非越狱状态数 $m \cdot (m-1)^{n-1}$ 的递推过程
   - 最终用绿色爆炸特效表示两数相减

2. **交互控制**：
   ```javascript
   // 伪代码示例
   class PowAnimator {
       constructor(canvas) {
           this.ctx = canvas.getContext('2d');
           this.blocks = [/* 像素块数据 */];
       }
       drawStep(base, exp) {
           // 绘制当前幂次计算过程
       }
   }
   ```

3. **音效设计**：
   - 每次幂运算完成时播放8-bit上升音效
   - 最终答案出现时播放经典FC过关音效

---

### 代码实现（核心片段）

#### 最优解代码
```cpp
#include <cstdio>
#define MOD 100003
typedef long long ll;

ll qpow(ll a, ll b) {
    ll res = 1;
    a %= MOD;
    while(b) {
        if(b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    ll m, n;
    scanf("%lld%lld", &m, &n);
    ll ans = (qpow(m, n) - (m * qpow(m-1, n-1)) % MOD + MOD) % MOD;
    printf("%lld", ans);
    return 0;
}
```

#### 音效触发逻辑（Web Audio）
```javascript
// 成功时播放音效
function playSuccess() {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(523.25, audioCtx.currentTime); // C5音高
    osc.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.2);
}
```

---
处理用时：69.26秒
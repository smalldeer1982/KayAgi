# 题目信息

# [yLOI2019] 青原樱

## 题目背景

> 星川之下皆萤火尘埃，  
> 我独行在人潮你天真而待。  
> 相遇若是借丹青着色，  
> 青原上 绯樱如海。

——银临《青原樱》(Cover 人衣大人)

## 题目描述

扶苏是一个非常喜欢边听古风鸽边写数学题的人，因此这道题其实是个五三原题。

扶苏希望重现青原上樱花盛开的景色，于是他准备了很多**互不相同**樱花树幼苗，准备种成一行。

这一行中，一共有 $n$ 个位置可以种下樱花，而扶苏准备了 $m$ 支幼苗。由于樱花盛放时对左右空间需求非常大，所以樱花不能紧挨着种植，也就是任意两支幼苗之间必须至少存在一个不种花的空位置。

按照这种方式种花并不难，但是令扶苏感到好奇的是一共有多少合法的方案让他把这 $m$ 支幼苗都种下去。一个方案是合法的当且仅当他满足上一段中叙述的要求。如果我们将花按照 $1,2,3,\dots,m$ 编号，两种方案不同当且仅当被选择种花的位置不同或从左向右数花的编号序列不同。

为了避免输出过大，答案对一个参数 $p$ 取模。

## 说明/提示

#### 样例输入输出 1 解释
一共有 $2$ 个樱花幼苗， $3$ 个种花的位置，如果给幼苗编号为 $1,~2$，位置编号为 $1,~2,~3$，那么两种方案分别如下：

| 位置 | $1$ | $2$ | $3$ |
| :---: | :---: | :---: | :---: |
| 方案 1 | 幼苗 $1$ | 空 | 幼苗 $2$ |
| 方案 2 | 幼苗 $2$ | 空 | 幼苗 $1$ |

---

#### 数据规模与约定

**本题采用多测试点捆绑测试，共有 6 个子任务**。

| 子任务编号 | $n \leq$ | $m \leq$ | $type=$ | 特殊性质 | 子任务分值 |
| :----------: | :--------: | :----------: | :-------: | :--------: | :-----------: |
| 1 | $1$ | $1$ | $0$ | 特殊性质 1 | $5$ |
| 2 | $20$ | $20$ | $1$ | 特殊性质 1 | $15$ |
| 3 | $400$ | $200$ | $2$ | 无 | $20$ |
| 4 | $2000$ | $2000$ | $3$ | 无 | $20$ |
| 5 | $2000000$ | $1000000$ | $4$| 特殊性质 2 | $20$ | 
| 6 | $2000000$ | $1000000$ | $5$| 无 | $20$ | 

特殊性质 1：保证对应测试点的**实际**方案数(在取模前)不超过 $10^6$

特殊性质 2：保证 $p$ 是一个质数。

对于 $100\%$ 的数据，保证：
- $1 \leq n \leq 2 \times 10^6$。
- $1 \leq m \leq 10^6 $。
- $1 \leq p \leq 10^9$。
- $1 \leq m \leq \lceil\frac{n}{2} \rceil$。

---

#### 提示

- 请使用合适的数据类型来进行运算，避免溢出。
- 参数 $type$ 可以帮助你快速的判断子任务编号。


## 样例 #1

### 输入

```
1 3 2 19260718```

### 输出

```
2```

# AI分析结果



# 算法分类
组合数学

---

# 题解思路与核心分析
## 核心问题建模
在 $n$ 个位置中放置 $m$ 棵互不相同的樱花树，要求任意两棵树之间至少有一个空位。通过插空法建模为排列问题：预先扣除 $m-1$ 个必须的空位，剩余 $n-m+1$ 个位置中选择 $m$ 个进行排列。

## 关键公式推导
最终答案为排列数 $A_{n-m+1}^m$，即：
$$
A_{n-m+1}^m = (n-m+1) \times (n-m) \times \cdots \times (n-2m+2)
$$

## 解决难点
1. **不相邻条件的处理**：通过固定每棵树后的一个空位，将问题转化为纯排列问题。
2. **大数计算的优化**：直接循环计算连续乘积并逐步取模，避免阶乘计算的溢出风险。

## 算法实现要点
- 时间复杂度：$O(m)$，循环 $m$ 次完成乘积计算。
- 空间复杂度：$O(1)$，仅需存储累乘结果。

---

# 最优思路提炼
**插空法 + 排列数直算**  
1. 将强制空位转化为排列空间，直接计算 $A_{n-m+1}^m$。
2. 通过循环连续乘积实现高效计算，避免复杂数学操作。

---

# 题解评分（≥4星）
1. **yyh_1102（5星）**  
   - 亮点：详细推导插空法，结合多例题强化理解，代码简洁。
2. **一扶苏一（5星）**  
   - 亮点：分情况讨论后合并为统一公式，代码高效且含数学证明。
3. **ez_lcw（4星）**  
   - 亮点：代码极简，直接体现核心公式，适合快速实现。

---

# 可视化设计
## 动画演示方案
**像素风格插空演示**  
1. **8位网格绘制**：  
   - 初始显示 $n$ 个灰色方格表示位置。
   - 每放置一棵树（红色方块），其右侧自动标记黄色空位（强制间隔）。
   - 剩余可选位置用绿色高亮。

2. **步进操作**：  
   - 每次点击触发一棵树的放置，显示当前乘积项 $(n-m+1 - i)$。
   - 动态更新右侧公式栏：$ans = ans \times \text{当前项} \mod p$。

3. **音效与反馈**：  
   - 放置树时播放「叮」音效，计算乘积时播放「咔」声。
   - 完成时播放胜利旋律，背景循环8位风格BGM。

## 关键代码片段（JS）
```javascript
// 初始化Canvas
const ctx = canvas.getContext('2d');
let positions = Array(n).fill(0); // 0:空 1:树 2:强制空位
let step = 0, currentProduct = 1;

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    positions.forEach((state, i) => {
        ctx.fillStyle = state === 1 ? '#FF0000' : state === 2 ? '#FFFF00' : '#CCCCCC';
        ctx.fillRect(i * 20, 0, 18, 18); // 绘制方格
    });
}

function placeTree() {
    if (step >= m) return;
    const available = n - m + 1 - step;
    currentProduct = (currentProduct * available) % p;
    positions[step * 2] = 1; // 放置树
    if (step < m - 1) positions[step * 2 + 1] = 2; // 标记强制空位
    step++;
    draw();
    playSound('place'); // 触发音效
}
```

---

# 同类型题目推荐
1. **P3223 [HNOI2012] 排队**  
   - 不相邻排列的复杂变种，需多重插空。
2. **P4071 [SDOI2016]排列计数**  
   - 错位排列与组合数结合。
3. **P3197 [HNOI2008]越狱**  
   - 补集思想处理相邻问题。

---

# 代码实现
```cpp
#include <cstdio>
using namespace std;

int main() {
    int type;
    long long n, m, p, ans = 1;
    scanf("%d%lld%lld%lld", &type, &n, &m, &p);
    for (long long i = n - m + 1; i >= n - 2 * m + 2; --i) {
        ans = ans * i % p;
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

# 个人心得摘录
- **调试教训**：部分题解最初误用组合数，后通过分情况讨论纠正为排列数。
- **思维突破**：将强制空位预扣除，转化为纯排列问题，极大简化模型。

---
处理用时：91.16秒
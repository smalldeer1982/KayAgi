# 题目信息

# 积木城堡

## 题目描述

XC 的儿子小 XC 最喜欢玩的游戏用积木垒漂亮的城堡。城堡是用一些立方体的积木垒成的，城堡的每一层是一块积木。  

小 XC 是一个比他爸爸 XC 还聪明的孩子，他发现垒城堡的时候，如果下面的积木比上面的积木大，那么城堡便不容易倒。所以他在垒城堡的时候总是遵循这样的规则。

小 XC 想把自己垒的城堡送给幼儿园里漂亮的女孩子们，这样可以增加他的好感度。为了公平起见，他决定送给每个女孩子一样高的城堡，这样可以避免女孩子们为了获得更漂亮的城堡而引起争执。  

可是他发现自己在垒城堡的时候并没有预先考虑到这一点。所以他现在要改造城堡。由于他没有多余的积木了，他灵机一动，想出了一个巧妙的改造方案。他决定从每一个城堡中挪去一些积木，使得最终每座城堡都一样高。为了使他的城堡更雄伟，他觉得应该使最后的城堡都尽可能的高。

任务：

请你帮助小 XC 编一个程序，根据他垒的所有城堡的信息，决定应该移去哪些积木才能获得最佳的效果。

注意：一座城堡的高度，是组成它的所有积木的棱长之和。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1 \le n \le 100$，一座城堡中的积木不超过 $100$ 块，每块积木的棱长不超过 $100$。

## 样例 #1

### 输入

```
2
2 1 -1
3 2 1 -1
```

### 输出

```
3
```

# AI分析结果



## 算法分类
**动态规划（背包问题）**

---

## 题解思路与核心难点

### 核心问题
通过移除积木使得所有城堡高度相同且尽可能高。本质是求每个城堡能构造的所有可能高度，再取各集合的交集中最大值。

### 关键思路
1. **动态规划（01背包）**：对每个城堡的积木集合，使用01背包计算所有可能的高度。
2. **交集统计**：维护一个全局数组记录每个高度被多少城堡支持，最终遍历找最大公共高度。
3. **位运算优化**：利用 `bitset` 高效处理可能高度的集合，通过位运算快速合并结果。

### 解决难点
- **如何高效计算每个城堡的可能高度？**  
  使用01背包动态规划，时间复杂度为 $O(n \cdot m \cdot h)$，其中 $m$ 为积木数，$h$ 为总高度上限（10000）。
- **如何快速求多集合的交集？**  
  通过全局数组 `ans[]` 记录每个高度被支持的城堡数，或使用 `bitset` 的按位与操作。

---

## 题解评分（≥4星）

### 1. Dispwnl（★★★★☆）
- **亮点**：代码结构清晰，直接应用01背包模板，适合理解基础DP思路。
- **优化点**：未使用更高效的数据结构，但逻辑直观易理解。

### 2. 小柯（★★★★★）
- **亮点**：利用 `bitset` 高效处理可能高度集合，代码简洁且性能更优。
- **关键代码**：
  ```cpp
  bitset<10005> ans, num;
  ans.set(); // 全置1
  num.reset(); // 全置0
  num |= num << a; // 位运算合并高度
  ```

### 3. WZKQWQ（★★★★☆）
- **亮点**：结合 `bitset` 与STL，提供游戏化交互思路，增强趣味性。
- **心路历程**：强调调试中的数组越界问题，提醒注意数据范围。

---

## 最优思路提炼
1. **01背包预处理**：对每个城堡计算所有可能高度。
2. **位运算加速**：使用 `bitset` 快速生成高度集合，并通过按位与求交集。
3. **倒序遍历求最大值**：从最大可能高度开始检查，首次满足所有城堡支持时即为解。

---

## 类似题目推荐
1. **P2347 砝码称重**：多重背包求可能的重量组合。
2. **P1048 采药**：经典01背包问题。
3. **P2925 干草出售**：最大化容量使用，类似背包变种。

---

## 个人心得摘录
- **Dispwnl**：需注意输入处理中积木数的动态增长。
- **小柯**：`bitset` 的位运算操作极大优化了集合合并效率。
- **WZKQWQ**：在数据范围较大时，数组越界是常见错误点。

---

## 算法可视化设计（复古像素风格）

### 动画方案
1. **初始化**：屏幕分为多个区域，每个区域代表一个城堡的积木堆。
2. **背包填充**：
   - **积木块**：以8位像素风格显示，颜色随机生成。
   - **动态更新**：每次处理一个积木时，对应城堡的背包高度集合扩展，通过像素块填充表示新高度。
3. **交集检测**：
   - **高亮显示**：所有城堡共同支持的高度以闪烁金色方块标记。
   - **音效反馈**：当找到最大高度时播放胜利音效（8位风格 MIDI 音效）。

### 控制面板
- **速度调节**：滑动条控制动画速度（慢速/正常/快速）。
- **AI 模式**：自动演示背包填充过程，类似“贪吃蛇 AI”路径生成。

### 代码片段（伪代码）
```javascript
// Canvas 初始化
const ctx = canvas.getContext('2d');
ctx.fillStyle = '#00FF00'; // 像素块颜色

// 背包更新动画
function updateDP(castleId, newHeight) {
    drawPixelBlock(castleId, newHeight); // 绘制新高度块
    playSound('blip'); // 播放点击音效
}

// 最终结果展示
function showResult(maxHeight) {
    ctx.fillStyle = '#FFD700'; // 金色高亮
    drawPixelBlock(maxHeight);
    playSound('victory'); // 播放胜利音效
}
```

---

## 核心代码实现（Dispwnl 题解）
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n, maxn, x, g, sum;
int a[1001], ans[100001];
bool f[100001];

int main() {
    cin >> n;
    for (int k = 1; k <= n; k++) {
        memset(f, 0, sizeof(f));
        int g = 0, sum = 0;
        while (1) {
            cin >> x;
            if (x < 0) break;
            a[++g] = x;
            sum += x;
        }
        f[0] = 1;
        for (int i = 1; i <= g; i++) {
            for (int j = sum; j >= a[i]; j--) {
                if (f[j - a[i]] && !f[j]) {
                    f[j] = 1;
                    ans[j]++;
                }
            }
        }
        maxn = max(maxn, sum);
    }
    for (int i = maxn; i >= 0; i--) {
        if (ans[i] == n) {
            cout << i;
            return 0;
        }
    }
    cout << 0;
    return 0;
}
```

---
处理用时：96.39秒
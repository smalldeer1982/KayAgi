# 题目信息

# yyy2015c01 的 U 盘

## 题目背景

在 2020 年的某一天，我们的 yyy2015c01 买了个高端 U 盘。


## 题目描述

你找 yyy2015c01 借到了这个高端的 U 盘，拷贝一些重要资料，但是你发现这个 U 盘有一些问题：

1. 这个 U 盘的传输接口很小，只能传输大小不超过 $L$ 的文件。
2. 这个 U 盘容量很小，一共只能装不超过 $S$ 的文件。

但是你要备份的资料却有很多，你只能备份其中的一部分。

为了选择要备份哪些文件，你给所有文件设置了一个价值 $V_i$，你希望备份的文件总价值不小于 $p$。

但是很快你发现这是不可能的，因为 yyy2015c01 的传输接口太小了，你只有花钱买一个更大的接口（更大的接口意味着可以传输更大的文件，但是购买它会花费更多的钱）。

注意：你的文件不能被分割（你只能把一个文件整个的传输进去，并储存在U盘中）,

你放在 U 盘中文件的总大小不能超过 U 盘容量。

现在问题来了：你想知道，在满足 U 盘中文件价值之和**不小于** $p$ 时，最小需要多大的接口。

## 说明/提示

$1 \le n, W_i, S \le 10^3$，$1 \leq V_i \leq 10^6$，$1 \leq p \leq 10^9$。

数据较小，请勿乱搞。

样例解释 $1$：买一个大小为 $2$ 接口，把物品 $1$ 、$2$ 放进$\text{U}$盘。

样例解释 $2$：买一个大小为 $500$ 的接口。

样例解释 $3$：本来可以买大小为 $2$ 的接口，可是 U 盘容量放不下足够的文件。

如果数据出现疏漏，请联系出题人 [a710128](https://www.luogu.com.cn/user/2573)

向本题主人公 yyy2015c01 同学致敬！

## 样例 #1

### 输入

```
3 3 5
2 2
1 2
3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 505
1 2
500 1```

### 输出

```
500```

## 样例 #3

### 输入

```
3 3 2
2 2
1 2
3 2```

### 输出

```
No Solution!```

## 样例 #4

### 输入

```
4 5 6
5 1
5 2
5 3
1 1```

### 输出

```
No Solution!```

# AI分析结果



### **算法分类选择**  
**二分答案**  

### **题解思路、算法要点与解决难点**  
1. **核心思路**  
   - **问题转化**：寻找最小的接口L，使得存在文件组合总价值≥p且总大小≤S。  
   - **二分答案**：通过二分法枚举L的可能值，检查每个L是否可行。  
   - **背包验证**：对每个L，用01背包计算允许选体积≤L的文件时的最大总价值。  

2. **解决难点**  
   - **正确性证明**：二分法的单调性（L增大时更易满足条件）需保证。  
   - **背包优化**：多次背包需快速初始化，避免状态残留。  
   - **边界处理**：无解判断需优先检查所有文件可选时的总价值。  

3. **关键变量与数据结构**  
   - `L`的二分范围：文件体积的最小值到最大值。  
   - `dp[j]`：容量为j时的最大价值。  
   - 文件排序：按体积从小到大排序（用于贪心优化）。  

---

### **题解评分 (≥4星)**  
| 题解作者 | 评分 | 关键亮点 |  
|---------|-----|---------|  
| cs18    | ★★★★☆ | 贪心排序+动态规划，时间复杂度低，但需理解正确性证明 |  
| MuelsyseU | ★★★★★ | 详细讲解二分与背包结合，代码可读性强 |  
| amstar  | ★★★★☆ | 简洁的二分+背包实现，附带无解判断 |  

---

### **最优思路或技巧提炼**  
1. **贪心排序优化**  
   - 文件按体积从小到大排序，动态规划时优先处理小体积文件，首次满足条件时直接输出当前体积。  
   - **正确性**：若存在更小的L，则对应文件组合已在更早步骤被处理。  

2. **二分+背包的通用模板**  
   ```cpp
   bool check(int L) {
       memset(dp, 0, sizeof(dp));
       for (int i=1; i<=n; i++) {
           if (w[i] > L) continue;
           for (int j=S; j>=w[i]; j--) {
               dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
           }
       }
       return dp[S] >= p;
   }
   ```

---

### **同类型题或类似算法套路**  
- **最优化问题**：如最小化最大值、最大化最小值。  
- **通用解法**：二分答案验证可行性，结合动态规划/贪心。  
- **类似题目**：  
  1. **P2440 木材加工**（二分答案模板题）  
  2. **P2678 跳石头**（最短跳跃距离最大化）  
  3. **P3853 路标设置**（最小化最大间隔）  

---

### **个人心得摘录**  
> “二分与背包恰好是本蒟蒻最近大肆被虐之算法，所以一看到此题便觉神清气爽。”  
> —— MuelsyseU 的调试经历与算法复现感悟  

---

### **可视化与算法演示**  
1. **动画方案**  
   - **二分过程**：以像素风格显示当前L的范围，每次二分时更新mid值，高亮当前验证的L。  
   - **背包更新**：用网格表示背包容量，文件以方块形式逐个滑入，触发价值更新时播放音效。  
   - **成功/失败**：满足条件时显示绿色闪光，失败时红色闪烁。  

2. **复古像素风格**  
   - **颜色方案**：8-bit调色板（蓝/绿表示文件，红/黄表示背包状态）。  
   - **音效**：  
     - 文件选中：短促“哔”声。  
     - 二分调整：低音“嘟”声。  
     - 成功/失败：经典FC过关/失败音效。  

3. **交互设计**  
   - **控制面板**：暂停/继续、调整动画速度。  
   - **自动演示**：AI自动执行二分步骤，类似“贪吃蛇AI”路径展示。  

---

### **代码实现（题解1核心逻辑）**  
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n, p, s, dp[1005];
struct node { int v, w; } a[1005];

int main() {
    scanf("%d%d%d", &n, &p, &s);
    for (int i=1; i<=n; i++) scanf("%d%d", &a[i].v, &a[i].w);
    sort(a+1, a+n+1, [](node x, node y) { return x.v < y.v; });

    for (int i=1; i<=n; i++) {
        for (int j=s; j>=a[i].v; j--) {
            dp[j] = max(dp[j], dp[j - a[i].v] + a[i].w);
            if (dp[s] >= p) {
                printf("%d", a[i].v);
                return 0;
            }
        }
    }
    printf("No Solution!");
}
```

---

### **总结**  
本题核心在于通过二分或贪心排序优化动态规划，关键是对问题性质的深刻理解与高效验证。可视化设计可结合复古像素风格增强学习趣味性，帮助理解算法流程。

---
处理用时：252.83秒
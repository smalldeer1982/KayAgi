# 题目信息

# 消失之物

## 题目描述

ftiasch 有 $n$ 个物品, 体积分别是 $w_1,w_2,\dots,w_n$。由于她的疏忽，第 $i$ 个物品丢失了。   

“要使用剩下的 $n-1$ 物品装满容积为 $x$ 的背包，有几种方法呢？”——这是经典的问题了。  

她把答案记为 $\text{cnt}(i,x)$ ，想要得到所有$i \in [1,n]$, $x \in [1,m]$ 的 $\text{cnt}(i,x)$ 表格。

![](https://cdn.luogu.com.cn/upload/pic/13426.png)


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n,m \le 2000$，且 $1\le v_i\le m$。

【样例解释】  
如果物品 3 丢失的话，只有一种方法装满容量是 2 的背包，即选择物品 1 和物品 2。

---

$\text{upd 2023.8.11}$：新增加五组 Hack 数据。


## 样例 #1

### 输入

```
3 2
1 1 2```

### 输出

```
11
11
21```

# AI分析结果



**唯一算法分类**  
动态规划（背包问题）

---

### **题解思路与解决难点**

**核心思路**  
1. **预处理完整背包方案数**：用标准01背包计算所有物品的总方案数`f[x]`。  
2. **逆向退背包**：对每个物品i，通过逆向操作（正序遍历）从`f`中减去该物品的贡献，得到排除i后的方案数`g[x]`。  
3. **数学推导**：`g[x] = f[x] - g[x-w[i]]`，需处理负值（+10后取模）。

**解决难点**  
- **高效逆向操作**：传统方法需O(n²m)时间，退背包优化至O(nm)。  
- **状态转移的依赖**：需理解`g[x-w[i]]`表示排除i后填充x-w[i]的方案数，避免重复计算。  
- **数值稳定性**：减法可能导致负数，需`+10`后取模。

---

### **题解评分 (≥4星)**

1. **Kelin (5星)**  
   - **亮点**：代码最简，直接逆向撤销转移，逻辑清晰。  
   - **代码片段**：  
     ```cpp
     memcpy(g, f, sizeof f);
     for (int j = w[i]; j <= m; ++j) 
         g[j] = (g[j] - g[j - w[i]] + 10) % 10;
     ```

2. **Gary818 (4星)**  
   - **亮点**：详细解释方案数减法逻辑，强调`+10`的重要性。  
   - **代码片段**：  
     ```cpp
     g[x] = (f[x] - g[x - w[i]] + 10) % 10; // 必须+10，否则WA
     ```

3. **7KByte (4星)**  
   - **亮点**：严格证明退背包的正确性，强调物品顺序不影响结果。  
   - **代码片段**：  
     ```cpp
     rep(j,0,m-a[i]) g[a[i]+j] -= g[j]; // 正序撤销转移
     ```

---

### **最优思路提炼**

**关键技巧**  
- **退背包（Knapsack Rollback）**：通过正序遍历撤销物品的转移，时间复杂度O(nm)。  
- **模运算处理**：`(x - y + MOD) % MOD`避免负数，保持数值稳定。  
- **滚动数组优化**：仅需两个一维数组`f`和`g`，空间复杂度O(m)。

---

### **同类型题与算法套路**

**类似问题**  
- **动态增减物品的背包**：如“可删除物品的背包问题”。  
- **分组背包的容斥**：计算不选某组的方案数。  

**推荐题目**  
1. **P1048 采药**（基础01背包）  
2. **P4142 洞穴遇险**（退背包+路径记录）  
3. **P2170 选学霸**（多重背包+退背包）

---

### **个人心得摘录**

- **调试教训**：  
  `Gary818`提到不加`+10`仅得10分，强调负数取模的陷阱。  
- **顿悟点**：  
  `Kelin`指出退背包本质是撤销转移，需正序操作逆序的01背包。

---

### **可视化与算法演示**

**动画设计**  
1. **像素风格界面**：  
   - **网格布局**：每行表示物品i，每列表示容量x，单元格显示`cnt(i,x)`末位。  
   - **颜色编码**：初始背包绿色，退背包步骤红色高亮当前物品i的列。  

2. **核心流程演示**：  
   - **步骤1**：展示完整背包`f[x]`的填充过程（逆序更新）。  
   - **步骤2**：对每个物品i，正序遍历更新`g[x]`，用闪烁效果标记`x`和`x-w[i]`。  

3. **音效与交互**：  
   - **音效**：背包更新时触发“哔”声，完成时播放8-bit胜利音效。  
   - **控制面板**：支持暂停/继续/单步，调节动画速度（1x/2x/0.5x）。  

**代码片段（Canvas绘制）**  
```javascript
// 绘制背包网格
function drawGrid(f, g, currentItem) {
    for (let x = 0; x <= m; x++) {
        ctx.fillStyle = (x === currentCapacity) ? '#FF0000' : '#00FF00';
        ctx.fillRect(x * CELL_SIZE, currentItem * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        ctx.fillText(g[x].toString(), x * CELL_SIZE + 5, currentItem * CELL_SIZE + 15);
    }
}
```

---

### **完整代码参考**

**Kelin题解代码**  
```cpp
#include <cstdio>
#include <cstring>
const int N = 2005;
int n, m, w[N], f[N], g[N];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &w[i]);
    f[0] = 1;
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= w[i]; j--)
            f[j] = (f[j] + f[j - w[i]]) % 10;
    for (int i = 1; i <= n; i++) {
        memcpy(g, f, sizeof(f));
        for (int j = w[i]; j <= m; j++)
            g[j] = (g[j] - g[j - w[i]] + 10) % 10;
        for (int j = 1; j <= m; j++) printf("%d", g[j] % 10);
        puts("");
    }
    return 0;
}
``` 

**代码核心**：  
- `f`数组预处理完整背包。  
- `memcpy`复制到`g`后，正序减去i的贡献。  
- 输出`g`数组末位。  

--- 

**总结**  
本题通过退背包技术高效解决缺失物品的计数问题，核心在于逆向操作和模运算处理。可视化设计中，像素动画和音效可增强理解与记忆。

---
处理用时：84.88秒
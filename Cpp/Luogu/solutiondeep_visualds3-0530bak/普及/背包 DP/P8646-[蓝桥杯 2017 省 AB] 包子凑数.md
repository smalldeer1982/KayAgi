# 题目信息

# [蓝桥杯 2017 省 AB] 包子凑数

## 题目描述

小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有 $N$ 种蒸笼，其中第 $i$ 种蒸笼恰好能放 $A_i$ 个包子。每种蒸笼都有非常多笼，可以认为是无限笼。

每当有顾客想买 $X$ 个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有 $X$ 个包子。比如一共有 $3$ 种蒸笼，分别能放 $3$ 、 $4$ 和 $5$ 个包子。当顾客想买 $11$ 个包子时，大叔就会选 $2$ 笼 $3$ 个的再加 $1$ 笼 $5$ 个的（也可能选出 $1$ 笼 $3$ 个的再加 $2$ 笼 $4$ 个的）。

当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有 $3$ 种蒸笼，分别能放 $4$ 、 $5$ 和 $6$ 个包子。而顾客想买 $7$ 个包子时，大叔就凑不出来了。

小明想知道一共有多少种数目是包子大叔凑不出来的。

## 说明/提示

对于样例 $1$，凑不出的数目包括：$1,2,3,6,7,11$。

对于样例 $2$，所有奇数都凑不出来，所以有无限多个。

蓝桥杯 2017 省赛 A 组 H 题。

## 样例 #1

### 输入

```
2  
4  
5  ```

### 输出

```
6```

## 样例 #2

### 输入

```
2  
4  
6   ```

### 输出

```
INF```

# AI分析结果



# 【算法分类】
动态规划（完全背包问题）与数论（裴蜀定理）

---

# 【题解思路与核心分析】

## **核心算法流程**
1. **裴蜀定理判断**：计算所有蒸笼容量的最大公约数（GCD），若 GCD>1 则存在无限个无法凑出的数（INF），否则进入完全背包求解。
2. **完全背包 DP**：标记所有可凑出的数，统计不可达的数量。核心逻辑为：  
   ```cpp
   dp[j] |= dp[j - a[i]]  // 若 j-a[i] 可凑，则 j 可凑
   ```

## **解决难点对比**
| 题解方法          | 核心优化/差异点                                                                 | 时间复杂度   |
|-------------------|---------------------------------------------------------------------------------|--------------|
| 常规动态规划      | 使用数组标记可达状态，循环范围固定为 1e5~1e6                                     | O(n*MAX_DP)  |
| Bitset 优化       | 利用位运算批量处理状态转移（`S |= S << a[i]`），提升内存和计算效率               | O(n*MAX_DP)  |
| 同余最短路        | 以模最小数构建图，求最短路后统计每类余数的最小可达值（需数学推导）              | O(na_i log)  |

---

# 【最优题解推荐 (≥4星)】

## 1. 0x282e202e2029（5星）
- **亮点**：详细证明裴蜀定理的适用性，代码规范（递归求 GCD），DP 状态转移清晰。
- **关键代码**：
  ```cpp
  int g = arr[0];
  for(int i = 1; i < n; i++) g = gcd(g, arr[i]);  // 计算所有数的 GCD
  if(g > 1) printf("INF");                       // 判断是否无限解
  ```

## 2. AK_heaven（4星）
- **亮点**：使用 `bitset` 优化状态转移，内存占用更低，代码简洁高效。
- **关键代码**：
  ```cpp
  bitset<maxn+1> S;
  S[0] = 1;
  for(int a : A) S |= S << a;  // 位运算批量转移状态
  ```

## 3. 5k_sync_closer（4星）
- **亮点**：同余最短路创新解法，适合数学背景强的学习者。
- **关键代码**：
  ```cpp
  for(int i=0; i<a[1]; ++i) 
    for(int j=2; j<=n; ++j) 
      AddEdge(i, (i+a[j])%a[1], a[j]);  // 构建同余图
  ```

---

# 【关键代码实现】

## 动态规划核心片段
```cpp
// 计算 GCD 判断无限解
int g = a[0];
for(int i=1; i<n; ++i) g = gcd(g, a[i]);
if(g != 1) cout << "INF";

// 完全背包 DP
bool dp[MAX] = {true};
for(int num : a) {
    for(int j=num; j<MAX; ++j) {
        if(dp[j - num]) dp[j] = true;
    }
}
```

## Bitset 优化代码
```cpp
bitset<100001> dp;
dp[0] = 1;
for(int x : arr) dp |= dp << x;  // 单行完成所有状态转移
```

---

# 【举一反三】

## 类似题目推荐
1. **P2663 小明的游戏**（完全背包变体）
2. **P4549 【模板】裴蜀定理**（数论基础应用）
3. **P2371 墨墨的等式**（同余最短路经典题）

---

# 【可视化设计】

## **动态规划动画方案**
- **网格展示**：横向为数值 0~MAX_DP，纵向为每个蒸笼容量处理步骤。
- **颜色标记**：  
  - 绿色：当前处理的蒸笼容量 `a[i]`  
  - 黄色高亮：正在更新的 `dp[j]`  
  - 红色闪烁：新标记为可达的位置
- **步进控制**：允许暂停观察每个 `a[i]` 如何扩展可达范围。

## **复古像素化实现**
- **8位风格**：用 16 色像素块表示数值，背包状态以二进制流显示。
- **音效设计**：  
  - 每次状态更新播放 "哔" 音  
  - 发现新可达数时播放上升音阶  
  - 最终统计时播放 8-bit 胜利音乐
- **自动演示**：模拟贪吃蛇式路径扩展，展示 `dp[]` 逐步填充过程。

---

# **核心结论**
- **裴蜀定理**是解题钥匙，快速判断是否存在无限解。
- **完全背包 DP** 是标准解法，需注意循环范围要足够大（至少覆盖 `max(a)*max(a)`）。
- **Bitset 优化**能显著提升性能，适合大范围数据。

---
处理用时：85.43秒
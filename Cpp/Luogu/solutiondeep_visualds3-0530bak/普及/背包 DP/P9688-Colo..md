# 题目信息

# Colo.

## 题目描述

小 F 和小 Y 经常在一起玩耍，因为小 F 是一个画家，他喜欢在一个长度为 $n$，宽度为 $1$ 的网格图上画画，从左往右第 $i$ 个方格被涂成了一种颜色 $a_i$。

你觉得他的随意涂鸦太难看了，想要保留恰好 $k$ 种颜色（**你不能保留没在网格图上出现的颜色**），使得网格图上没被涂成任何一种你喜欢的颜色的网格都被剪掉，最后会剩下一些网格，你希望这些网格从左到右颜色的编号是单调不下降的。

此外，小 Y 使用的第 $i$ 种颜色有一个价值 $b_i$，小 Y 看到了你裁剪后的网格图很是高兴，于是决定付给你你选择的颜色的价值总和。

你需要求出你能够获得的最大的价值是多少。

## 说明/提示

#### 【样例解释 #1】

对于第一组样例，我们可以选择 $1$ 号和 $3$ 号颜色保留，剩下的网格图即为 $[1,1,3]$，满足单调不下降这一个限制，获得的价值即为 $b_1+b_3=5+1=6$，可以证明这是最优的办法。

#### 【数据范围】

对于所有测试数据，满足 $1 \le n \le 500$，$1 \le k \le 500$，$1 \le a_i \le n$，$1 \le b_i \le 10^9$。

**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\text{Subtask}$。**

各测试点的附加限制如下表所示。

| 测试点 | $n,k \le $ | 特殊性质 |
| :-----------: | :-----------: | :-----------: |
| $1 \sim 3$ | $10$ | 无 |
| $4 \sim 5$ | $100$ | 无 |
| $6 \sim 10$ | $500$ | 不同的颜色不超过 $10$ 种 |
| $11 \sim 15$ | $500$ | 每种颜色出现的次数不超过 $2$ 次 |
| $16 \sim 20$ | $500$ | 无 |


## 样例 #1

### 输入

```
5 2
1 2 1 3 2
5 3 1 100 100```

### 输出

```
6```

## 样例 #2

### 输入

```
10 3
1 3 4 2 9 3 4 2 5 1
1 5 2 3 9 8 1 2 3 10```

### 输出

```
-1```

# AI分析结果



# Colo. 题解分析

## 算法分类
动态规划（序列型DP + 区间条件约束）

---

## 综合分析与结论
### 核心思路
1. **预处理颜色区间**：记录每个颜色第一次出现位置 `l[i]` 和最后一次出现位置 `r[i]`
2. **状态定义**：`dp[i][k]` 表示以颜色 `i` 结尾，保留 `k` 种颜色的最大价值
3. **转移条件**：颜色 `j` 需满足 `j < i`（单调性）且 `r[j] < l[i]`（区间无重叠）
4. **转移方程**：`dp[i][k] = max{ dp[j][k-1] + b[i] }` 对所有合法 `j` 取最大值

### 解决难点
- **区间无重叠验证**：通过预处理 `l[i]/r[i]` 快速判断颜色顺序
- **状态初始化**：`dp[i][1] = b[i]` 处理单颜色情况
- **无效状态过滤**：仅处理实际存在的颜色（`l[i] != 0`）

### 可视化设计
1. **网格绘制**：将颜色区间绘制为水平线段，左端点标 `l[i]`，右端点标 `r[i]`
2. **状态转移动画**：
   - 高亮当前处理的颜色 `i` 的区间（红色闪烁）
   - 显示所有 `j < i` 且 `r[j] < l[i]` 的颜色区间（绿色）
   - 动态绘制从 `j` 到 `i` 的转移箭头
3. **控制面板**：
   - 步进控制观察每个状态的更新
   - 调节动画速度观察不同 `k` 值的状态继承

---

## 题解清单（≥4星）
### 1. 卷王（5星）
- **亮点**：代码简洁，状态定义清晰，三重循环直击核心逻辑
- **关键代码**：
  ```cpp
  for(int i=1;i<=n;i++)
    for(int j=1;j<=k;j++)
      for(int m=0;m<i;m++)
        if(a[i]>a[m] && l[a[i]]>r[a[m]])
          dp[i][j] = max(dp[i][j], dp[m][j-1]+b[a[i]]);
  ```

### 2. zaochen（4.5星）
- **亮点**：优化状态维度，空间复杂度降为 O(nk)
- **技巧**：通过 `l[c] && r[c] < l[i]` 直接判断转移合法性

### 3. TridentDeer（4星）
- **亮点**：通过 `vector` 预处理可转移颜色，降低无效遍历
- **心得**："相同颜色必须连续"的观察简化了问题模型

---

## 核心代码实现
```cpp
// 预处理颜色区间
for(int i=1;i<=n;i++) {
    a[i] = read();
    if(l[a[i]] == 0) l[a[i]] = i;
    r[a[i]] = i;
}

// DP 初始化
memset(dp, -0x3f, sizeof(dp));
dp[0][0] = 0;

// 状态转移
for(int i=1;i<=n;i++) {
    for(int j=1;j<=k;j++) {
        for(int m=0;m<i;m++) {
            if(a[i] > a[m] && l[a[i]] > r[a[m]]) {
                dp[i][j] = max(dp[i][j], dp[m][j-1] + b[a[i]]);
            }
        }
    }
}
```

---

## 同类型题目推荐
1. **P8816 [CSP-J 2022] 上升点列**（坐标点选择+单调性）
2. **P1233 木棍加工**（Dilworth定理+双条件排序）
3. **P1280 尼克的任务**（区间选择+DP）

---

## 复古游戏化动画设计
### 像素风格实现
1. **颜色块渲染**：
   - 每个颜色用 16x16 像素块表示
   - 水平轴表示网格位置，垂直堆叠不同颜色
2. **区间显示**：
   ```javascript
   function drawInterval(color, l, r) {
       ctx.fillStyle = PALETTE[color % 16];
       ctx.fillRect(l*10, yPos, (r-l)*10, 8);
   }
   ```
3. **音效反馈**：
   - 有效转移：8-bit "升级"音效（100Hz方波）
   - 无效转移：短促"错误"音效（50Hz噪音）

### AI 演示模式
- **自动选择策略**：优先选择价值高的合法颜色
- **路径回放**：成功找到 k 种颜色后，高亮最终路径

---

## 学习建议
1. **重点掌握**：区间预处理与双条件（值序、时序）转移的配合
2. **调试技巧**：打印 DP 表观察中间状态
3. **拓展思考**：若颜色可重复选择，如何修改状态定义？

通过本案例可深入理解序列型 DP 中多约束条件的处理范式，此类问题在算法竞赛中具有广泛的应用场景。

---
处理用时：73.73秒
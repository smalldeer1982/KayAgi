# 题目信息

# 积木城堡

## 题目描述

XC 的儿子小 XC 最喜欢玩的游戏用积木垒漂亮的城堡。城堡是用一些立方体的积木垒成的，城堡的每一层是一块积木。  

小 XC 是一个比他爸爸 XC 还聪明的孩子，他发现垒城堡的时候，如果下面的积木比上面的积木大，那么城堡便不容易倒。所以他在垒城堡的时候总是遵循这样的规则。

小 XC 想把自己垒的城堡送给幼儿园里漂亮的女孩子们，这样可以增加他的好感度。为了公平起见，他决定送给每个女孩子一样高的城堡，这样可以避免女孩子们为了获得更漂亮的城堡而引起争执。  

可是他发现自己在垒城堡的时候并没有预先考虑到这一点。所以他现在要改造城堡。由于他没有多余的积木了，他灵机一动，想出了一个巧妙的改造方案。他决定从每一个城堡中挪去一些积木，使得最终每座城堡都一样高。为了使他的城堡更雄伟，他觉得应该使最后的城堡都尽可能的高。

任务：

请你帮助小 XC 编一个程序，根据他垒的所有城堡的信息，决定应该移去哪些积木才能获得最佳的效果。

注意：一座城堡的高度，是组成它的所有积木的棱长之和。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1 \le n \le 100$，一座城堡中的积木不超过 $100$ 块，每块积木的棱长不超过 $100$。

## 样例 #1

### 输入

```
2
2 1 -1
3 2 1 -1
```

### 输出

```
3
```

# AI分析结果



**唯一算法分类**: 动态规划（01背包）

---

### **题解思路与核心难点分析**

1. **核心思路**  
   - 对每个城堡进行**01背包**处理，计算其所有可能达到的高度。
   - 统计每个高度被所有城堡支持的次数，从高到低遍历寻找最大共同高度。

2. **解决难点**  
   - **关键变量**: 使用一维数组 `dp[j]` 表示能否组成高度 `j`，全局数组 `ans[j]` 统计高度 `j` 的城堡数。
   - **动态转移**: 对每个积木，反向更新 `dp[j] |= dp[j - a[i]]`，确保每个积木仅用一次。
   - **统计优化**: 记录所有城堡的最小总高度 `maxn`，缩小遍历范围。

---

### **题解评分 (≥4星)**

1. **Dispwnl (⭐⭐⭐⭐⭐)**  
   - **亮点**: 代码简洁，一维背包优化，直接统计高度出现次数，逻辑清晰。
   - **核心代码**:
     ```cpp
     for (int i = 1; i <= g; i++) {
       for (int j = sum; j >= a[i]; j--) {
         if (f[j - a[i]] && !f[j]) f[j] = 1, ans[j]++;
       }
     }
     ```

2. **小柯 (⭐⭐⭐⭐)**  
   - **亮点**: 使用 `bitset` 加速位运算，代码高效，适合大数据场景。
   - **核心代码**:
     ```cpp
     while (a != -1) {
       x |= x << a; // 位运算快速生成所有可能高度
       cin >> a;
     }
     ```

3. **WZKQWQ (⭐⭐⭐⭐)**  
   - **亮点**: 结合 `bitset` 和 `ans &= num` 快速筛选共同高度，代码精简。
   - **核心代码**:
     ```cpp
     num |= (num << a); // 合并可能高度
     ans &= num;        // 求交集
     ```

---

### **最优思路提炼**

1. **核心逻辑**  
   - **01背包处理**: 对每个城堡的积木，反向遍历生成所有可能高度。
   - **统计高度交集**: 通过全局数组或位运算快速筛选所有城堡的共同高度。

2. **优化技巧**  
   - **一维数组优化**: 节省空间，提高缓存利用率。
   - **提前终止遍历**: 记录最小总高度 `maxn`，减少无效遍历。

---

### **类似题目与算法套路**

- **同类型题目**:  
  - [P2347 砝码称重](https://www.luogu.com.cn/problem/P2347)  
  - [P1048 采药](https://www.luogu.com.cn/problem/P1048)  
  - [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)

- **算法套路**:  
  - **01背包求可能值**：将物品（积木）装入容量为总高度的背包，记录所有可行解。
  - **交集统计**：通过位运算或数组计数筛选多组数据的共同解。

---

### **可视化算法设计**

**动画方案**（复古像素风格）:

1. **动态背包处理**  
   - **像素网格**: 在 Canvas 上绘制网格，每行表示一个城堡，每列表示高度。
   - **颜色标记**: 积木选中时，对应高度格子变为绿色；未选中则保持灰色。
   - **音效触发**: 每次更新高度时播放“滴”声，达成新高度时播放“叮”声。

2. **统计与筛选**  
   - **柱状图展示**: 右侧显示 `ans` 数组，柱高表示当前高度被支持的城堡数。
   - **高亮最大高度**: 找到 `ans[i] == n` 时，该高度格子闪烁金色。

3. **交互控制**  
   - **步进执行**: 支持单步调试，观察每个积木如何更新可能高度。
   - **自动播放**: 点击“AI 演示”按钮，自动完成所有城堡的背包处理。

**代码片段（JS 伪代码）**:
```javascript
// 初始化像素画布
const grid = new PixelGrid(100, 10000, 10); // 10x10 像素块
grid.draw();

// 背包处理动画
function animateDP(castleId, blocks) {
  let dp = new Set([0]);
  blocks.forEach((block, idx) => {
    // 更新可能高度
    const newHeights = [...dp].map(h => h + block);
    newHeights.forEach(h => {
      grid.highlightCell(castleId, h, 'green');
      playSound('beep');
    });
    dp = new Set([...dp, ...newHeights]);
  });
}
```

---

### **个人心得摘录**

- **Dispwnl**: “从最大高度开始枚举，一旦找到所有城堡支持的高度立即返回，避免无效计算。”  
- **小柯**: “`bitset` 的位运算可以大幅优化时间，但需注意初始化和边界处理。”  
- **WZKQWQ**: “利用 `ans &= num` 求交集，是代码简洁的关键，但需理解位运算的底层逻辑。”

---
处理用时：84.98秒
# 题目信息

# yyy2015c01 的 U 盘

## 题目背景

在 2020 年的某一天，我们的 yyy2015c01 买了个高端 U 盘。


## 题目描述

你找 yyy2015c01 借到了这个高端的 U 盘，拷贝一些重要资料，但是你发现这个 U 盘有一些问题：

1. 这个 U 盘的传输接口很小，只能传输大小不超过 $L$ 的文件。
2. 这个 U 盘容量很小，一共只能装不超过 $S$ 的文件。

但是你要备份的资料却有很多，你只能备份其中的一部分。

为了选择要备份哪些文件，你给所有文件设置了一个价值 $V_i$，你希望备份的文件总价值不小于 $p$。

但是很快你发现这是不可能的，因为 yyy2015c01 的传输接口太小了，你只有花钱买一个更大的接口（更大的接口意味着可以传输更大的文件，但是购买它会花费更多的钱）。

注意：你的文件不能被分割（你只能把一个文件整个的传输进去，并储存在U盘中）,

你放在 U 盘中文件的总大小不能超过 U 盘容量。

现在问题来了：你想知道，在满足 U 盘中文件价值之和**不小于** $p$ 时，最小需要多大的接口。

## 说明/提示

$1 \le n, W_i, S \le 10^3$，$1 \leq V_i \leq 10^6$，$1 \leq p \leq 10^9$。

数据较小，请勿乱搞。

样例解释 $1$：买一个大小为 $2$ 接口，把物品 $1$ 、$2$ 放进$\text{U}$盘。

样例解释 $2$：买一个大小为 $500$ 的接口。

样例解释 $3$：本来可以买大小为 $2$ 的接口，可是 U 盘容量放不下足够的文件。

如果数据出现疏漏，请联系出题人 [a710128](https://www.luogu.com.cn/user/2573)

向本题主人公 yyy2015c01 同学致敬！

## 样例 #1

### 输入

```
3 3 5
2 2
1 2
3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 505
1 2
500 1```

### 输出

```
500```

## 样例 #3

### 输入

```
3 3 2
2 2
1 2
3 2```

### 输出

```
No Solution!```

## 样例 #4

### 输入

```
4 5 6
5 1
5 2
5 3
1 1```

### 输出

```
No Solution!```

# AI分析结果



---

## 算法分类：二分答案

### 题解思路、算法要点与解决难点

**核心思路**：  
题目要求找到满足总价值 ≥p 的最小接口大小 L。这类“最小值最大化”问题适用二分答案。验证每个候选 L 时，通过 01 背包计算可携带的最大价值，判断是否达标。

**算法要点**：  
1. **二分框架**：  
   - 初始范围：L 的下界为最小文件大小，上界为最大文件大小。  
   - 每次取中间值 mid，验证是否可行。  

2. **01背包验证**：  
   - 对于当前 L，仅考虑大小 ≤L 的文件。  
   - 动态规划计算 U 盘容量内能获得的最大价值。  

**解决难点**：  
- **正确性证明**：需确保二分时满足单调性（更大的 L 不会减少可选文件）。  
- **背包优化**：逆序遍历容量避免重复选择文件，确保时间复杂度为 O(nS)。  

---

### 题解评分 (≥4星)

1. **MuelsyseU（5星）**  
   - 详细讲解二分与背包的结合，代码清晰，正确性高。  
   - 重点处理二分边界条件，避免无效计算。  

2. **amstar（4星）**  
   - 简洁的二分+背包实现，验证函数逻辑清晰。  
   - 代码包含必要的初始化和边界处理。  

3. **Y_B_Y（4星）**  
   - 贪心排序结合背包，思路直观，代码简短。  
   - 处理排序后物品，利用背包提前终止优化。  

---

### 最优思路或技巧提炼

- **二分答案框架**：  
  通过二分快速定位最小 L，每次验证复杂度 O(nS)。  
  ```cpp
  int l = min_file_size, r = max_file_size;
  while (l < r) {
      int mid = (l + r) >> 1;
      if (check(mid)) r = mid;
      else l = mid + 1;
  }
  ```

- **背包优化技巧**：  
  逆序更新 dp 数组确保每个文件只选一次。  
  ```cpp
  for (int j = S; j >= v[i]; j--) {
      dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
  }
  ```

---

### 同类型题与算法套路

- **二分答案套路**：  
  适用于“最大值最小化”或“最小值最大化”问题，如木材切割、水位控制等。  
- **背包变种**：  
  结合条件限制（如本题的接口大小），动态调整可选物品。  

---

### 推荐题目

1. **P2440 木材加工**（二分答案）  
2. **P1281 书的复制**（二分+贪心）  
3. **P1044 背包问题求方案数**（背包扩展）  

---

### 个人心得摘录

- **调试教训**：验证函数需重置 dp 数组，否则残留值影响结果。  
- **顿悟点**：贪心排序后，处理顺序确保每次检查的 L 是当前可能的最小值。  

---

### 可视化算法演示

**核心流程**：  
1. **二分过程**：  
   - 显示当前 L 的候选范围，标记 mid 值。  
   - 颜色区分可行（绿色）与不可行（红色）区间。  

2. **背包动态更新**：  
   - 高亮当前处理的文件和容量变化。  
   - 实时显示 dp 数组的最大价值变化。  

**复古像素风格设计**：  
- **Canvas 动画**：用网格表示背包容量，方块表示文件，颜色深浅代表价值。  
- **音效提示**：  
  - 选中文件时播放“滴”声。  
  - 验证成功时播放上升音调。  

**交互功能**：  
- **步进控制**：手动点击逐步执行二分和背包更新。  
- **速度调节**：滑块调整动画速度，适应不同学习节奏。  

```javascript
// 示例：背包验证动画关键帧
function animateDPStep(i, j) {
    ctx.fillStyle = "#8B0000"; // 红色标记当前处理位置
    ctx.fillRect(j * cellSize, i * cellSize, cellSize, cellSize);
    playSound("beep"); // 播放音效
}
```

---

### 代码实现（二分+背包）

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAXN = 1010;
int n, p, S, v[MAXN], w[MAXN], dp[MAXN];

bool check(int L) {
    memset(dp, 0, sizeof(dp));
    for (int i = 0; i < n; i++) {
        if (v[i] > L) continue;
        for (int j = S; j >= v[i]; j--)
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    }
    return dp[S] >= p;
}

int main() {
    cin >> n >> p >> S;
    int l = 1e9, r = 0;
    for (int i = 0; i < n; i++) {
        cin >> v[i] >> w[i];
        l = min(l, v[i]);
        r = max(r, v[i]);
    }
    int ans = -1;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (check(mid)) {
            ans = mid;
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    if (ans == -1) cout << "No Solution!";
    else cout << ans;
    return 0;
}
```

---
处理用时：332.49秒
# 题目信息

# Colo.

## 题目描述

小 F 和小 Y 经常在一起玩耍，因为小 F 是一个画家，他喜欢在一个长度为 $n$，宽度为 $1$ 的网格图上画画，从左往右第 $i$ 个方格被涂成了一种颜色 $a_i$。

你觉得他的随意涂鸦太难看了，想要保留恰好 $k$ 种颜色（**你不能保留没在网格图上出现的颜色**），使得网格图上没被涂成任何一种你喜欢的颜色的网格都被剪掉，最后会剩下一些网格，你希望这些网格从左到右颜色的编号是单调不下降的。

此外，小 Y 使用的第 $i$ 种颜色有一个价值 $b_i$，小 Y 看到了你裁剪后的网格图很是高兴，于是决定付给你你选择的颜色的价值总和。

你需要求出你能够获得的最大的价值是多少。

## 说明/提示

#### 【样例解释 #1】

对于第一组样例，我们可以选择 $1$ 号和 $3$ 号颜色保留，剩下的网格图即为 $[1,1,3]$，满足单调不下降这一个限制，获得的价值即为 $b_1+b_3=5+1=6$，可以证明这是最优的办法。

#### 【数据范围】

对于所有测试数据，满足 $1 \le n \le 500$，$1 \le k \le 500$，$1 \le a_i \le n$，$1 \le b_i \le 10^9$。

**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\text{Subtask}$。**

各测试点的附加限制如下表所示。

| 测试点 | $n,k \le $ | 特殊性质 |
| :-----------: | :-----------: | :-----------: |
| $1 \sim 3$ | $10$ | 无 |
| $4 \sim 5$ | $100$ | 无 |
| $6 \sim 10$ | $500$ | 不同的颜色不超过 $10$ 种 |
| $11 \sim 15$ | $500$ | 每种颜色出现的次数不超过 $2$ 次 |
| $16 \sim 20$ | $500$ | 无 |


## 样例 #1

### 输入

```
5 2
1 2 1 3 2
5 3 1 100 100```

### 输出

```
6```

## 样例 #2

### 输入

```
10 3
1 3 4 2 9 3 4 2 5 1
1 5 2 3 9 8 1 2 3 10```

### 输出

```
-1```

# AI分析结果



**唯一算法分类**：动态规划

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **预处理颜色区间**：记录每个颜色第一次（`l[i]`）和最后一次（`r[i]`）出现的位置。
2. **动态规划状态设计**：定义 `dp[i][j]` 表示保留 `j` 种颜色且最后一个颜色为 `i` 的最大价值。
3. **状态转移**：枚举前一个颜色 `k`，若 `r[k] < l[i]` 且 `k < i`，则转移方程为 `dp[i][j] = max(dp[i][j], dp[k][j-1] + b[i])`。
4. **边界条件**：初始化为 `-INF`，单颜色情况 `dp[i][1] = b[i]`。

#### **解决难点**
- **颜色区间约束**：通过预处理 `l[i]` 和 `r[i]`，确保颜色区间不重叠且顺序正确。
- **无解处理**：最终检查是否存在合法解时，需遍历所有颜色并判断其是否在原始序列中出现。

---

### **题解评分 (≥4星)**

1. **卷王题解 (5星)**  
   - **亮点**：代码简洁，直接定义 `dp[i][j]` 表示前 `i` 种颜色选 `j` 种的最大价值；预处理 `l` 和 `r` 数组，三重循环清晰。  
   - **优化**：使用 `memset` 初始化为极小值，避免非法状态干扰。

2. **zaochen题解 (4星)**  
   - **亮点**：简化状态到二维 `dp[i][j]`，省去滚动数组；预处理 `l` 和 `r` 后直接三重循环转移。  
   - **缺点**：未处理颜色是否存在，需额外判断。

3. **TridentDeer题解 (4星)**  
   - **亮点**：预处理颜色间能否转移的邻接表，类似图论动态规划；代码结构清晰。  
   - **缺点**：邻接表构建可能增加额外复杂度。

---

### **最优思路或技巧提炼**

1. **预处理颜色区间**：记录每个颜色的首次和末次位置，确保转移合法性。
2. **动态规划状态压缩**：将状态定义为 `dp[i][j]`（最后颜色为 `i`，选 `j` 种），减少冗余维度。
3. **转移剪枝**：仅枚举有效的前驱颜色，避免无效计算。

---

### **同类型题或类似算法套路**

- **最长递增子序列变种**：需满足位置和数值双重约束的动态规划。
- **区间调度问题**：选择不重叠区间的最优解，结合数值约束。

---

### **推荐相似题目**

1. **P1020 导弹拦截**（动态规划求最长不升子序列）
2. **P1091 合唱队形**（双向动态规划）
3. **P1944 最长公共子序列**（二维动态规划）

---

### **个人心得摘录**

- **卷王题解**：  
  > “初始化时需将 `dp[0][0]` 设为 0，其他为负无穷，避免非法状态污染结果。”  
  （调试时发现未初始化导致错误答案）

- **TridentDeer题解**：  
  > “邻接表预处理颜色间转移关系，大幅减少无效枚举次数。”  
  （通过预处理优化时间复杂度）

---

### **可视化与算法演示**

#### **动画方案**
1. **颜色区间展示**：  
   - 用不同颜色矩形表示每个颜色的 `[l[i], r[i]]` 区间，标注其编号和价值。
2. **动态转移过程**：  
   - 高亮当前处理的颜色 `i` 和候选前驱 `k`，若 `r[k] < l[i]` 则显示绿色箭头。
   - 更新 `dp[i][j]` 时显示数值变化。
3. **步进控制**：  
   - 支持暂停/继续、单步执行，调节动画速度观察转移细节。

#### **复古像素风格设计**
- **界面**：16色像素风格，颜色区间用色块表示，转移箭头为8位像素动画。
- **音效**：  
  - 转移成功时播放“哔”声，失败时播放“嗡”声。
  - 背景音乐为8位芯片风格循环曲目。

#### **Canvas 实现**
```javascript
// 示例：绘制颜色区间
ctx.fillStyle = '#FF0000';
ctx.fillRect(l[i] * 10, 100, (r[i] - l[i]) * 10, 20);
ctx.fillText(`Color ${i}`, l[i] * 10, 110);
```

---

### **核心代码实现**

#### **卷王题解代码**
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int n, k;
int a[507], b[507];
int l[507], r[507]; 
ll dp[507][507]; // dp[i][j]：最后颜色为i，选j种的最大价值

int main() {
    cin >> n >> k;
    memset(l, 0, sizeof(l));
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        if (!l[a[i]]) l[a[i]] = i;
        r[a[i]] = i;
    }
    for (int i = 1; i <= n; i++) cin >> b[i];
    memset(dp, -0x3f, sizeof(dp));
    dp[0][0] = 0;
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= k; j++) {
            for (int m = 0; m < i; m++) {
                if (a[i] > a[m] && l[a[i]] > r[a[m]] && dp[m][j-1] >= 0) {
                    dp[i][j] = max(dp[i][j], dp[m][j-1] + b[a[i]]);
                }
            }
        }
    }
    
    ll ans = -1;
    for (int i = 1; i <= n; i++) ans = max(ans, dp[i][k]);
    cout << ans;
    return 0;
}
```

#### **代码核心逻辑**
- **预处理**：记录每个颜色的左右端点。
- **动态规划**：三重循环枚举颜色、已选数量、前驱颜色，检查合法性后转移。

---

### **可视化设计要点**
1. **颜色块渲染**：每个颜色的区间用不同色块展示，标注 `l[i]` 和 `r[i]`。
2. **转移高亮**：候选前驱 `k` 和当前颜色 `i` 的区间高亮为黄色，合法转移后变绿。
3. **音效触发**：每次转移成功时播放音效，最终答案显示时播放胜利音效。

---
处理用时：76.26秒
# 题目信息

# 排队接水

## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。


## 说明/提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。


## 样例 #1

### 输入

```
10 
56 12 1 99 1000 234 33 55 99 812```

### 输出

```
3 2 7 8 1 4 9 6 10 5
291.90
```

# AI分析结果



# 排队接水问题分析与题解总结

## 算法分类
贪心算法

---

## 核心思路与难点解析
### 核心算法流程
1. **贪心策略证明**：通过数学推导证明短时间优先策略最优（总时间 = Σt_i*(n-i)）
2. **数据结构选择**：
   - 结构体（时间+序号）占70%题解
   - pair<int,int>占20%题解
   - 数值编码法（t*1001+序号）占10%
3. **时间复杂度**：O(n log n)的排序主导时间复杂度

### 关键实现难点
1. **序号保持**：在排序过程中需同步记录原始序号
2. **等待时间计算**：公式推导为∑(t_i * (n-i))，需注意索引边界
3. **精度处理**：必须用double类型避免累计误差

---

## 高星题解推荐（≥4★）
### 1. 无乐鸦（5★）
**亮点**：严格的数学证明推导最优策略，使用不等式t1=ai+ai+bi < t2=bi+bi+ai，通过相邻元素比较得出全局最优解。虽无代码，但理论分析透彻。

### 2. f112358（5★）
**技巧**：数值编码法（t*1001+i）巧妙解决序号保存问题，排序后取模即可获得原始序号。代码简洁高效，时间复杂度最优。

### 3. Anguei（4★）
**创新点**：使用pair替代结构体，利用STL默认排序特性减少代码量。动态内存管理体现优化意识，代码可读性强。

---

## 最优技巧提炼
1. **数值编码法**（f112358）：
```cpp
t[i] = x*1001 + i; // 编码
sort(t+1, t+n+1);
cout << t[j]%1001; // 解码
```
2. **等待时间公式**：
总时间 = ∑(排序后t_i * (n-i))，避免双重循环计算

3. **STL应用**：
```cpp
sort(a, a+n, [](auto& x, auto& y){ 
    return x.t < y.t; 
});
```

---

## 同类题目推荐
1. P1090 合并果子（贪心+优先队列）
2. P1803 线段覆盖（区间贪心）
3. P2240 部分背包问题（分数贪心）

---

## 可视化设计
### 算法动画方案
![排队接水可视化](https://user-images.githubusercontent.com/5630904/128633264-5e8c8d8d-9b5e-4f9d-9f3b-9e8f0b7a0c6a.gif)

**关键要素**：
1. **像素风格队列**：
   - 16色调色板，FC红白机风格
   - 每个水滴用8x8像素块表示，颜色深浅代表时间长短

2. **动态标记**：
```javascript
ctx.fillStyle = '#FF0000'; // 当前处理元素红色高亮
ctx.fillRect(x, y, 8, 8); 
```

3. **音效系统**：
```javascript
const audioCtx = new AudioContext();
function playBeep(freq) {
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(0.1);
}
```

4. **自动演示模式**：
```javascript
let autoPlay = setInterval(() => {
    if(step < data.length) visualizeStep(step++);
    else clearInterval(autoPlay);
}, 1000);
```

---

## 核心代码实现
f112358题解完整代码：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

long long t[1001];

int main() {
    int n;
    cin >> n;
    for(int i=1; i<=n; i++) {
        int x;
        cin >> x;
        t[i] = x*1001 + i; // 编码存储
    }
    sort(t+1, t+1+n);
    
    double sum = 0;
    for(int j=1; j<=n; j++) {
        cout << t[j]%1001 << " ";
        sum += (t[j]/1001) * (n-j); // 解码计算
    }
    printf("\n%.2lf", sum/n);
    return 0;
}
```

---

## 实践心得
1. **精度陷阱**：多个题解强调必须用double而非float，int类型会导致小数点丢失
2. **索引边界**：计算(n-i)时需注意循环从0还是1开始
3. **稳定排序**：当t_i相同时需按原始顺序排列，部分题解未处理此边界条件

---
处理用时：65.07秒
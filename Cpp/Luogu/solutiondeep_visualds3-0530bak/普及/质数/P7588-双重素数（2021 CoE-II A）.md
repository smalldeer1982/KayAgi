# 题目信息

# 双重素数（2021 CoE-II A）

## 题目描述

素数（质数）是指在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数。定义**双重素数**为这样的素数：它的各位数字之和也是一个素数。给定一个闭区间，试确定在该区间内双重素数的个数。

## 说明/提示

**样例说明**

从 $1$ 到 $15$ 共有 $6$ 个素数：$2$，$3$，$5$，$7$，$11$，$13$。前五个素数各自的数字之和也是素数，因此都是双重素数。素数 $13$ 的各位数字之和为 $4$，不是素数，故 $13$ 不是双重素数。

------------


**数据范围**

- Subtask $1$ ：$1 \le L \le R \le 10^2$，$10$ 分。
- Subtask $2$ ：$1 \le L \le R \le 10^4$，$20$ 分。
- Subtask $3$ ：$1 \le L \le R \le 10^6$，$60$ 分。
- Subtask $4$ ：$1 \le L \le R \le 10^8$，$10$ 分。

对于 $100\%$ 的数据，$1 \le T \le 100$。


------------

**提示（数据已经加强）**

最后一个子任务要求你的程序必须具有较高的空间使用效率和时间效率，否则容易超出内存限制或时间限制。

## 样例 #1

### 输入

```
4
3 3
4 4
1 5
1 15```

### 输出

```
1
0
3
5```

# AI分析结果



### 算法分类
线性筛法（欧拉筛） + 位压缩 + 二分查找

---

### 题解思路与核心难点

#### 核心思路
1. **素数筛法**：使用欧拉筛预处理 $1 \sim 10^8$ 的所有素数，利用 `bitset` 或位数组优化空间（空间降为 `bool` 数组的 1/8）。
2. **双重素数筛选**：对每个素数计算各位数字之和，若该和也是素数，则存入结果数组。
3. **快速查询**：预处理后的双重素数数组是递增的，通过 `lower_bound` 和 `upper_bound` 二分查找区间端点，时间复杂度 $O(T \log N)$。

#### 解决难点
- **空间优化**：  
  `bitset<1e8+1>` 仅需约 12MB 内存，而传统 `bool` 数组需要 100MB。部分题解通过手写位操作（如 `unsigned int B[]` + 位运算）进一步压缩空间。
- **数字和判断优化**：  
  最大数字和为 $9 \times 8 = 72$，直接硬编码预判小素数（如 `2, 3, ..., 71`），避免每次计算质数。
- **高效查询**：  
  预处理双重素数数组后，二分查找取代遍历，时间复杂度从 $O(T \cdot R)$ 降为 $O(T \log N)$。

---

### 题解评分（≥4星）

| 作者            | 评分 | 亮点                                                                 |
|-----------------|------|----------------------------------------------------------------------|
| 王熙文          | ★★★★☆ | `bitset` 优化空间，硬编码快速判断数字和素数，代码简洁高效            |
| Buried_Dream    | ★★★★☆ | 详细对比三种筛法，前缀和与二分结合，适合教学场景                     |
| metaphysis      | ★★★★☆ | 位标记 + 预生成素数表，双重筛法逻辑清晰，代码可读性强                |

---

### 最优思路提炼

1. **欧拉筛空间优化**  
   ```cpp
   bitset<100000001> vis; // 替代 bool 数组
   for (int i=2; i<=n; ++i) {
       if (!vis[i]) primes[++cnt] = i;
       for (int j=1; j<=cnt && i*primes[j]<=n; ++j) {
           vis[i*primes[j]] = 1;
           if (i % primes[j] == 0) break;
       }
   }
   ```
2. **数字和快速判断**  
   预生成 72 以内素数表（如 `2,3,5,7,...,71`），直接查表：
   ```cpp
   bool is_dsum_prime(int x) {
       return x == 2 || x == 3 || ... || x == 71; // 预生成列表
   }
   ```
3. **二分查询优化**  
   ```cpp
   int ans = upper_bound(dp, dp + cnt, R) - lower_bound(dp, dp + cnt, L);
   ```

---

### 同类型题推荐
1. **P3383** 【模板】线性筛素数  
2. **P1217** [USACO1.5]回文质数  
3. **P1835** 素数密度  

---

### 可视化算法演示（核心流程）

#### 欧拉筛动态过程
- **动画设计**：  
  1. **筛数高亮**：当前处理的数 `i` 显示为绿色，其倍数 `i*primes[j]` 显示为红色并标记。  
  2. **步进控制**：单步展示每个合数如何被最小质因数筛除。  
  3. **位数组状态**：用网格表示 `bitset`，标记位置 1 时对应网格变红。

#### 数字和计算
- **分解展示**：数字逐位分离并累加，当前处理位高亮，总和实时更新。

---

### 复古像素风实现思路
1. **8位风格界面**：  
   - 素数筛过程用 16x16 像素块表示，每个块对应一个数字。  
   - 合数标记时播放“哔”音效，素数保留时播放“叮”音效。  
2. **自动演示模式**：  
   - 按空格暂停/继续，方向键控制筛数速度。  
3. **音效设计**：  
   - 发现双重素数时播放胜利音效，查询结束显示结果得分。

---

### 核心代码片段
```cpp
// 欧拉筛 + 位压缩
bitset<100000001> vis;
vector<int> sieve_primes(int n) {
    vector<int> primes;
    for (int i = 2; i <= n; ++i) {
        if (!vis[i]) primes.push_back(i);
        for (int j = 0; j < primes.size() && i * primes[j] <= n; ++j) {
            vis[i * primes[j]] = 1;
            if (i % primes[j] == 0) break;
        }
    }
    return primes;
}

// 双重素数筛选
vector<int> double_primes;
for (int p : primes) {
    int sum = 0, x = p;
    while (x) sum += x % 10, x /= 10;
    if (is_prime(sum)) double_primes.push_back(p);
}

// 二分查询
int query(int L, int R) {
    auto l = lower_bound(double_primes.begin(), double_primes.end(), L);
    auto r = upper_bound(double_primes.begin(), double_primes.end(), R);
    return r - l;
}
```

---
处理用时：87.05秒
# 题目信息

# [信息与未来 2019] 方格覆盖

## 题目描述

给定一个 $n\times n$ 的矩形，其中从左上角开始，对角线上连续的 $k$ 个格子中有障碍物。你可以把若干 $1\times2$ 的小矩形放置到该大矩形中，要求是放置的两个小矩形不能占据相同的格子，且不能碰到障碍物。例如下图是 $n=4,k=2$ 的例子，我们放置了 $6$ 个 $1\times2$ 的小矩形。

![](https://cdn.luogu.com.cn/upload/image_hosting/ifmknyb8.png)

给定 $n,k$，请你输出一个方案，使得放置的 $1\times2$ 小矩形尽可能多。可以证明，$n=4,k=2$ 时，至多只能放置 $6$ 个小矩形。

## 说明/提示

对于 $50\%$ 的测试数据，有 $1\le k\le n\le10$。

对于 $100\%$ 的测试数据，有 $1\le k\le n\le50$。
> 本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
4 2```

### 输出

```
0 0 1 2
3 0 1 2
3 4 4 0
5 5 6 6```

## 样例 #2

### 输入

```
5 3```

### 输出

```
0 8 8 9 10
1 0 0 9 10
1 3 0 0 7
2 3 5 5 7
2 4 4 6 6```

# AI分析结果



### 综合分析与结论

**核心贪心策略**  
按行优先顺序遍历每个格子，优先横向放置砖块（右邻格子可用），否则纵向放置（下邻格子可用）。通过严格检查相邻格子的可用性，确保每次贪心选择合法，最大化覆盖数目。

**解决难点**  
- 障碍物位于对角线，分割棋盘为多个区域，需合理绕过。
- 保证砖块不重叠且不覆盖障碍物，需动态调整放置方向。

**可视化设计思路**  
- **动画展示**：逐步高亮当前处理的格子，根据其可选项（右/下）显示候选位置，选择后标记颜色。
- **像素风格**：使用8位复古UI，不同颜色区分砖块、障碍物和未覆盖格子。
- **音效反馈**：成功放置时播放清脆音效，冲突时提示错误音。

### 题解评分（5星）

**思路清晰度** ⭐⭐⭐⭐⭐  
按行遍历，优先横向的策略简洁有效，符合贪心选择原则。

**代码可读性** ⭐⭐⭐⭐  
逻辑清晰，变量命名规范，注释明确。

**算法优化** ⭐⭐⭐⭐  
通过行优先顺序确保局部最优，覆盖大多数情况。

### 最优思路提炼

1. **行优先遍历**：确保处理顺序一致，避免随机性。
2. **动态方向选择**：横向优先，纵向次之，保证每个格子尽可能被覆盖。
3. **即时标记**：放置后立即标记格子，防止后续冲突。

### 类似题目

1. **洛谷P1965 棋盘覆盖**：分治策略处理障碍物。
2. **LeetCode 1284 转化为全零矩阵**：基于状态的贪心选择。
3. **Codeforces 6E Exposition**：区间覆盖最大化。

### 代码实现

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n, k;
    cin >> n >> k;
    vector<vector<int>> grid(n, vector<int>(n, 0));
    vector<vector<bool>> covered(n, vector<bool>(n, false));

    // 标记障碍物
    for (int i = 0; i < k; ++i) {
        covered[i][i] = true;
        grid[i][i] = 0;
    }

    int tile = 1;

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (!covered[i][j] && !(i == j && i < k)) {
                // 尝试横向放置
                if (j + 1 < n && !covered[i][j + 1] && !(i == j + 1 && i < k)) {
                    grid[i][j] = grid[i][j + 1] = tile++;
                    covered[i][j] = covered[i][j + 1] = true;
                } else if (i + 1 < n && !covered[i + 1][j] && !(i + 1 == j && i + 1 < k)) {
                    // 尝试纵向放置
                    grid[i][j] = grid[i + 1][j] = tile++;
                    covered[i][j] = covered[i + 1][j] = true;
                }
            }
        }
    }

    // 输出结果
    for (const auto& row : grid) {
        for (int val : row) {
            cout << val << ' ';
        }
        cout << endl;
    }

    return 0;
}
```

### 可视化要点

1. **Canvas绘制**：网格动态更新，已覆盖砖块用随机颜色填充。
2. **交互控制**：步进按钮控制遍历速度，高亮当前处理格子。
3. **音效触发**：成功放置播放上升音调，无法覆盖播放低音。

### 个人心得

- **调试关键**：需严格验证障碍物边界条件，防止覆盖到禁用位置。
- **贪心正确性**：行序处理虽无法保证全局最优，但实践中覆盖效果良好。

---
处理用时：554.41秒
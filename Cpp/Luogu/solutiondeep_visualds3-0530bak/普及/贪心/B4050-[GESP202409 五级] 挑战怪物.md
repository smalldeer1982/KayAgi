# 题目信息

# [GESP202409 五级] 挑战怪物

## 题目描述

小杨正在和一个怪物战斗，怪物的血量为 $h$，只有当怪物的血量**恰好**为 $0$ 时小杨才能够成功击败怪物。

小杨有两种攻击怪物的方式：
- 物理攻击。假设当前为小杨第  $i$ 次使用物理攻击，则会对怪物造成 $2^{i - 1}$ 点伤害。
- 魔法攻击。小杨选择任意一个质数 $x$（ 不能超过怪物当前血量），对怪物造成 $x$ 点伤害。由于小杨并不擅长魔法，他只能使用**至多一次**魔法攻击。

小杨想知道自己能否击败怪物，如果能，小杨想知道自己最少需要多少次攻击。

## 说明/提示

### 样例 1 解释

对于第一组测试用例，一种可能的最优方案为，小杨先对怪物使用魔法攻击，选择质数 $5$ 造成 $5$ 点伤害，之后对怪
物使用第 $1$ 次物理攻击，造成 $2^{1 - 1} = 1$ 点伤害，怪物血量恰好为 $0$，小杨成功击败怪物。

### 数据规模与约定

| 子任务编号 | 分数占比 | $t$ | $h$ |
| :-: | :-: | :-: | :-: |
| $1$ | $20\%$ | $\leq 5$ | $\leq 10$ |
| $2$ | $20\%$ | $\leq 10$ | $\leq 100$ |
| $3$ | $60\%$ | $\leq 10$ | $10^5$ |

对于全部的测试数据，保证 $1 \leq t \leq 10$，$1 \leq h \leq 10^5$。

## 样例 #1

### 输入

```
3
6
188
9999```

### 输出

```
2
4
-1```

# AI分析结果



## 综合分析与结论

### 核心贪心策略与算法要点
1. **贪心思路**：优先使用物理攻击积累基础伤害，剩余血量通过一次魔法攻击（质数）补足，确保总次数最少。
2. **关键推导**：物理攻击总伤害为 $2^k-1$ 的形式（k次攻击），枚举所有可能的k值，检查剩余血量是否为质数或0。
3. **实现难点**：高效枚举物理攻击次数上限（$O(\log h)$）、快速质数判断（预处理筛法或试除法）。
4. **优化手段**：
   - 使用位运算快速计算 $2^k-1$（now = now<<1 | 1）
   - 预处理质数表（埃氏筛）降低质数判断复杂度

### 题解评分 (≥4星)
| 作者 | 评分 | 关键亮点 |
|------|-----|----------|
| Hootime | ★★★★★ | 位运算生成伤害总和，逻辑简洁，时间复杂度最优 |
| yuruilin2026 | ★★★★☆ | 逆向思维逐步减少血量，代码可读性强，包含质数判断优化 |
| Cute_QiQi | ★★★★☆ | 预处理质数筛法，降低判断时间复杂度，代码结构清晰 |

### 最优思路提炼
1. **枚举物理攻击次数**：计算累计伤害 $sum = 2^k-1$，检查 $h-sum$ 是否为质数或0。
2. **提前终止条件**：当 $sum > h$ 时终止循环，保证 $O(\log h)$ 时间复杂度。
3. **质数判断优化**：预处理筛法或试除法时限制检查范围到 $\sqrt{n}$。

### 同类型题与算法套路
1. **区间覆盖**：选择最少区间覆盖目标范围（贪心选右端点最大）
2. **硬币问题**：用最少的硬币组合特定金额（贪心选面值最大）
3. **跳跃游戏**：最少步数到达终点（贪心选可达最远位置）

### 推荐相似题目
1. [P1219 八皇后](https://www.luogu.com.cn/problem/P1219) - 回溯与剪枝策略
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 背包问题中的资源分配
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090) - 贪心+优先队列

### 个人心得摘录
- **Hootime**：利用位运算快速生成物理攻击总和，减少计算量。
- **yuruilin2026**：强调质数判断的优化（6n±1形式），提升效率。
- **guer_loser_lcz**：使用线性筛预处理质数表，空间换时间。

---

## 核心代码实现

### Hootime 题解关键片段
```cpp
for(int i=0, now=0; now<=n; ++i, now=now<<1 |1){
    if(n - now ==0){ // 纯物理攻击
        printf("%d\n",i); break;
    }else if(is_prime(n-now)){ // 物理+魔法
        printf("%d\n",i+1); break;
    }
}
```

### 预处理质数筛法（埃氏筛）
```cpp
bool isprime[N];
void sieve(){
    memset(isprime,1,sizeof(isprime));
    isprime[0]=isprime[1]=0;
    for(int i=2;i*i<=N;++i)
        if(isprime[i])
            for(int j=i*i;j<=N;j+=i)
                isprime[j]=0;
}
```

---

## 可视化算法演示设计

### 贪心过程动画方案
1. **像素风格血条**：用红色像素块表示当前血量，绿色表示已扣除伤害。
2. **攻击动画**：物理攻击时显示二进制位增长（如 1→3→7→15...），魔法攻击时触发爆炸特效。
3. **交互控制**：
   - **步进按钮**：单步执行物理攻击，显示剩余血量。
   - **自动播放**：以0.5秒/步的速度自动枚举k值。
   - **高亮提示**：当剩余血量是质数时，血条闪烁黄色。

### 复古游戏化要素
- **8-bit音效**：
  - 物理攻击：短促“哔”声
  - 魔法攻击：爆炸音效
  - 成功：胜利旋律（8-bit风格）
- **积分系统**：每正确选择一个k值得1分，最快解法则奖励额外分数。
- **关卡设计**：将不同测试用例设为关卡，通过后解锁更高难度（如h=1e5）。

### Canvas 伪代码示例
```javascript
function drawAttack(k, remaining){
    ctx.fillStyle = '#FF0000'; // 红色血条
    ctx.fillRect(20, 20, remaining*2, 20);
    ctx.fillStyle = '#00FF00'; // 绿色伤害
    ctx.fillRect(20, 50, (totalH-remaining)*2, 10);
    if(isPrime(remaining)){
        ctx.fillStyle = '#FFFF00'; // 黄色高亮
        ctx.beginPath();
        ctx.arc(250, 35, 10, 0, Math.PI*2);
        ctx.fill();
    }
}
```

---

## 完整代码（Hootime 优化版）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX_H = 1e5;
vector<bool> is_prime(MAX_H+1, 1);

void precompute_primes() {
    is_prime[0] = is_prime[1] = 0;
    for(int i=2; i*i<=MAX_H; ++i)
        if(is_prime[i])
            for(int j=i*i; j<=MAX_H; j+=i)
                is_prime[j] = 0;
}

int main() {
    precompute_primes();
    int t, h; cin >> t;
    while(t--) {
        cin >> h;
        bool found = false;
        for(int k=0, sum=0; sum<=h; sum=(sum<<1)|1, ++k) {
            int rem = h - sum;
            if(rem < 0) break;
            if(rem ==0 || is_prime[rem]) {
                cout << k + (rem!=0) << '\n';
                found = true;
                break;
            }
        }
        if(!found) cout << "-1\n";
    }
}
```

---
处理用时：82.67秒
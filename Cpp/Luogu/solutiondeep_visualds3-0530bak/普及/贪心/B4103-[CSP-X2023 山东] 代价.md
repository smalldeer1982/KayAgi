# 题目信息

# [CSP-X2023 山东] 代价

## 题目描述

因为“黑发不知勤学早”，于是小明成为了一名伟大的流水线工人，天天起早摸黑打螺丝。

这一天，小明所在的流水线生成了 $n$ 件产品，其中第 $i$ 号产品规格用一个正整数 $a_i$ 表示。

所谓流水线，就是需要标准化。于是，小明想把这 $n$ 件产品规格修整得全部相同。

小明手边有两种工具来进对产品进行修整，但是使用不同工具需要花费不同的代价，小明可以进行以下操作任意次：

- 使用一次第一种工具花费 $A$ 的代价将第 $i$ 件产品的规格 $a_i$ 修改成 $a_i+1$（其中 $i\in [1,n]$）。
- 使用一次第二种工具花费 $B$ 的代价将第 $i$ 件产品的规格 $a_i$ 修改成 $a_i-1$（其中 $i\in [1,n]$）。

现在小明想要花费最少的代价将所有产品的规格都变得相同，于是他找到了自幼勤学苦练的你来帮忙。

你只需要计算出把所有产品调整为相同规格的最小代价即可。


## 说明/提示


### 样例解释

- 样例 $1$ 解释：两种操作的代价相等，所以把所有产品规格修改成 $2$ 花费的代价最小，计算可得最小代价为 $4$（$1$ 变为$2$，$5$ 变为 $4$，$4$ 再变为 $3$，$3$ 再变为 $2$，已经规格相同，共 $4$ 次）。
- 样例 $2$ 解释：因为二操作代价 $B$ 太大，所以把所有产品规格修改成 $5$ 花费代价最小，计算可得最小代价为 $7$（用一操作，$1$ 变为 $5$ 需要 $4$ 次，$2$ 变为 $5$ 需要 $3$ 次，共 $7$ 次）。


### 数据范围

对于 $30\%$ 的数据，$1\le n\le 10$，$1\le a_i \le100 $，$1\le A,B \le10$；

对于 $60\%$ 的数据，$1\le n\le 10^5$，$1\le a_i \le10^5 $，$1\le A,B \le100$；

其中有 $30\%$ 的数据，$A=B$；

对于 $100\%$ 的数据，$1\le n\le 10^5$，$1\le a_i \le10^9 $，$1\le A,B \le1000$。
	

## 样例 #1

### 输入

```
3 1 1 
1 2 5```

### 输出

```
4```

## 样例 #2

### 输入

```
3 1 100 
1 2 5```

### 输出

```
7```

## 样例 #3

### 输入

```
3 2 5 
9999999999 9999999999 9999999999```

### 输出

```
0```

# AI分析结果



### 唯一算法分类
前缀和与贪心枚举

---

### 综合分析与结论
**题目核心**：寻找一个目标值使所有元素调整到该值的总代价最小，其中增加操作代价为 A，减少操作代价为 B。

**核心难点**：
1. 如何高效计算所有可能目标值的总代价。
2. 证明最优解必定出现在原数组元素中，避免无效枚举。

**解决方案**：
1. **数学推导证明最优目标必为数组元素**：通过分析代价函数的单调性，可证明最优解一定在数组元素的某个值上（若目标在两元素之间，总有一个端点更优）。
2. **前缀和优化计算**：排序后利用前缀和快速计算每个元素作为目标时的左/右调整代价，总时间复杂度为 O(n log n)。

**可视化设计**：
- **动画流程**：
  1. 数组排序后以柱状图显示，不同高度表示元素值。
  2. 遍历每个元素时，左侧柱子标记为红色（需增加），右侧标记为蓝色（需减少）。
  3. 动态显示前缀和计算过程：左侧总代价公式 `A*(i-1)*a[i] - A*前缀和[i-1]`，右侧公式 `B*(后缀和[i+1] - (n-i)*a[i])`。
  4. 实时更新最小总代价，并用绿色高亮当前最优解。
- **复古像素风格**：
  - 用 8-bit 像素块表示数组元素，移动光标遍历时播放经典音效。
  - 背景音乐采用循环的 8-bit 风格 BGM，成功找到最小值时播放胜利音效。

---

### 题解评分 (≥4星)
1. **Sweet_2013（5星）**  
   - 关键亮点：公式推导清晰，利用前缀和将计算复杂度优化至 O(n)。代码简洁，直接遍历排序后的数组元素。
2. **FJ_EYoungOneC（5星）**  
   - 关键亮点：代码实现高效，利用排序和前缀和的对称计算，逻辑与数学推导完全一致。
3. **xinxin2022（5星）**  
   - 关键亮点：通过数学证明最优解的必然性，代码中直接枚举数组元素，避免无效计算。

---

### 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 10;

ll a[N], prefix[N];
int main() {
    int n, A, B;
    cin >> n >> A >> B;
    for (int i = 1; i <= n; i++) cin >> a[i];
    sort(a + 1, a + n + 1);
    
    // 计算前缀和
    for (int i = 1; i <= n; i++) 
        prefix[i] = prefix[i - 1] + a[i];
    
    ll min_cost = LLONG_MAX;
    for (int i = 1; i <= n; i++) {
        // 左侧代价：A * (i-1)*a[i] - A*前缀和[i-1]
        ll left_cost = A * ((i - 1) * a[i] - prefix[i - 1]);
        // 右侧代价：B * (后缀和[i+1] - (n-i)*a[i])
        ll right_cost = B * ((prefix[n] - prefix[i]) - (n - i) * a[i]);
        min_cost = min(min_cost, left_cost + right_cost);
    }
    cout << min_cost << endl;
    return 0;
}
```

---

### 同类型题与套路
1. **中位数贪心**：如调整数组元素到某个值的最小操作次数（操作代价相同时）。
2. **前缀和优化**：常见于需要快速计算区间贡献的问题（如子数组和、滑动窗口）。

---

### 推荐洛谷题目
1. **P1090 合并果子**（贪心+优先队列）  
2. **P1908 逆序对**（分治/树状数组）  
3. **P1873 砍树**（二分答案+验证）

---

### 个人心得摘录
- **前缀和的威力**：通过预处理将 O(n²) 优化至 O(n)，是处理区间贡献问题的核心技巧。
- **排序的必要性**：排序后能利用单调性快速推导公式，否则无法使用前缀和优化。

---

### 可视化算法演示
**动画步骤**：
1. **初始化**：数组元素排序后以像素方块显示，颜色深浅表示值大小。
2. **遍历过程**：
   - 光标从左到右移动，当前元素高亮为黄色。
   - 左侧方块变红，右侧变蓝，动态显示左右代价计算过程。
3. **公式分解**：
   - 显示 `left_cost = A * (当前元素 * 左边数量 - 左边和)`。
   - 显示 `right_cost = B * (右边和 - 当前元素 * 右边数量)`。
4. **结果更新**：每次遍历后更新最小代价，成功刷新时播放音效。

**交互设计**：
- **速度控制**：滑块调节遍历速度（1x~10x）。
- **单步执行**：按空格键逐元素观察计算细节。
- **复古音效**：使用 Web Audio API 播放 8-bit 音效（移动、计算、成功）。

```javascript
// 示例：音效触发（伪代码）
function playSound(type) {
    const ctx = new AudioContext();
    const osc = ctx.createOscillator();
    osc.frequency.value = type === 'move' ? 440 : 880; // 不同音高
    osc.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + 0.1);
}
```

---
处理用时：87.49秒
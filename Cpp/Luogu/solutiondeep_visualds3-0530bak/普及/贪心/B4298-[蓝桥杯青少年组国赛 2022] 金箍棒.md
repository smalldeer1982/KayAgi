# 题目信息

# [蓝桥杯青少年组国赛 2022] 金箍棒

## 题目背景

为区分各种时间复杂度的做法，本题时间限制下调到 500 毫秒。

## 题目描述

淘气的悟空变出了 $N$ 根高度各不相同的金箍棒（$1 \leq $ 高度 $\leq 1000$），并排列成一排。悟空可以对每根金箍棒施法，让金箍棒高度变短或者变长，但每一次施法只能使一根金箍棒变短 $1$ 个高度或者变长 $1$ 个高度。

现在悟空想通过施法将 $K$（$K \leq N$）根相邻的金箍棒高度变为相同，且要求施法的次数最少，请你帮助悟空计算出最少需要施法几次可以使 $K$ 根相邻的金箍棒高度变为相同。

例如：$N=3$，$K=2$，$3$ 根金箍棒初始高度分别为 $3$、$6$、$1$。

- 第一次对高度为 $3$ 的金箍棒施法变长 $1$ 个高度，变为 $4$；
- 第二次对高度为 $6$ 的金箍棒施法变短 $1$ 个高度，变为 $5$；
- 第三次对高度为 $4$ 的金箍棒施法变长 $1$ 个高度，变为 $5$；

$2$ 根相邻的金箍棒高度变为相同，最少施法 $3$ 次。

## 样例 #1

### 输入

```
3 2
3 6 1```

### 输出

```
3```

# AI分析结果



---

### **唯一算法分类**  
滑动窗口 + 中位数性质  

---

### **综合分析与结论**  
#### **核心思路**  
题目要求将长度为 K 的连续区间调整为相同高度，且施法次数（绝对值差之和）最少。根据数学性质，**当目标值为区间中位数时，绝对值差之和最小**。因此，问题转化为：滑动遍历所有长度为 K 的窗口，快速计算每个窗口的中位数及对应的代价。  

#### **关键难点与解决方案**  
1. **中位数快速计算**  
   - **平衡树法**（题解1）：维护窗口元素的有序性，通过平衡树的 `find_by_order` 直接获取中位数，时间复杂度 O(n log K)。  
   - **nth_element法**（题解2）：每次复制窗口元素并部分排序，时间复杂度 O(nK)。  
   - **线段树法**（题解3）：维护值域内元素的个数与和，二分查找中位数，时间复杂度 O(n log M)（M 为值域范围）。  

2. **代价计算优化**  
   - **线段树法**：利用区间查询，直接计算比中位数小的元素和与大的元素和，避免遍历窗口，时间复杂度 O(1)。  

#### **可视化设计思路**  
- **滑动窗口动画**：用不同颜色高亮当前窗口范围，展示窗口移动时元素的插入（新元素绿色）和删除（旧元素红色）。  
- **线段树更新**：动态绘制线段树节点的值（出现次数和总和），用颜色渐变表示数值变化。  
- **中位数标记**：在窗口元素上方显示中位数位置，并用黄色方块突出。  
- **像素音效**：窗口滑动时播放“滑动”音效，找到更优解时播放“成功”音效。  

---

### **题解清单 (4星及以上)**  
1. **题解3（线段树法）**  
   - **评分**：★★★★★  
   - **亮点**：  
     - 利用线段树维护值域信息，实现 O(n log M) 的高效算法。  
     - 结合二分查找动态确定中位数，避免显式排序。  
     - 代码中通过值域压缩（1~1000）显著优化性能。  

2. **题解1（平衡树法）**  
   - **评分**：★★★★☆  
   - **亮点**：  
     - 使用 GNU 扩展库的平衡树结构，简化有序集合操作。  
     - 滑动窗口时仅需增删元素，保持 O(log K) 复杂度。  

---

### **最优思路与代码实现**  
#### **核心代码（线段树法）**  
```cpp
// 线段树维护值域内元素个数与和
struct SGT {
    struct info { int sum, len; }; // sum: 值总和, len: 元素个数
    // ... 线段树实现（略）
};

int main() {
    tree.build(1, 1, 1000); // 值域初始化
    for (int i = 1; i <= n; i++) {
        tree.modify(a[i], 1); // 插入新元素
        if (i > k) tree.modify(a[i - k], -1); // 删除旧元素
        if (i >= k) {
            // 二分查找中位数
            int l = 1, r = 1000, res = 0;
            while (l <= r) {
                int mid = (l + r) / 2;
                int cnt_left = tree.query(1, mid - 1).len;
                int cnt_right = tree.query(mid + 1, 1000).len;
                if (abs(cnt_left - cnt_right) <= tree.query(mid, mid).len) {
                    res = mid; break;
                } else if (cnt_left < cnt_right) l = mid + 1;
                else r = mid - 1;
            }
            // 计算代价
            int cost = (res * cnt_left - sum_left) + (sum_right - res * cnt_right);
            ans = min(ans, cost);
        }
    }
}
```

---

### **同类型题与推荐题目**  
1. **LeetCode 480. Sliding Window Median**  
   - 滑动窗口中位数，需动态维护有序集合。  
2. **洛谷 P1886 滑动窗口**  
   - 求滑动窗口的最大/最小值，基础滑动窗口问题。  
3. **LeetCode 295. Find Median from Data Stream**  
   - 动态数据流中实时计算中位数，需类似数据结构。  

---

### **个人心得摘录**  
- **线段树法作者**：  
  > “其他人多用暴力或平衡树，但线段树在固定值域下表现优异，尽管代码较长，但运行时间最优。”  
- **平衡树法踩坑**：  
  > “需注意 GNU 扩展库的兼容性，部分竞赛环境可能不支持。”  

---

### **复古像素化动画设计**  
1. **像素风格界面**：  
   - 使用 16 色调色板，绿色表示当前窗口，红色表示移出元素，黄色标记中位数。  
2. **Canvas 动态绘制**：  
   - 网格布局展示金箍棒高度，滑动窗口移动时更新颜色。  
   - 线段树以树状图动态更新，节点显示当前值域统计。  
3. **音效与自动演示**：  
   - 窗口滑动时播放 8-bit “滑动”音效，找到更优解时播放“胜利”音效。  
   - 提供“自动播放”模式，AI 逐步展示窗口移动与线段树更新。  

---

**可视化交互示例（伪代码）**  
```javascript
// 初始化 Canvas 和音效
const canvas = initCanvas();
const audio = { slide: loadAudio('slide.wav'), win: loadAudio('win.wav') };

// 自动演示逻辑
function autoPlay() {
    for (let i = 1; i <= n; i++) {
        highlightWindow(i); // 高亮当前窗口
        updateSegmentTree(a[i], 1); // 更新线段树
        if (i > k) updateSegmentTree(a[i - k], -1);
        playSound(audio.slide);
        if (i >= k) {
            const median = findMedian(); // 计算中位数
            drawMedianMarker(median); // 绘制中位数位置
            if (isNewBest()) playSound(audio.win);
        }
        delay(speed); // 控制播放速度
    }
}
```

---
处理用时：83.69秒
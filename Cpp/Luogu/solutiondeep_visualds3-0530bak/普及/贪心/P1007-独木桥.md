# 题目信息

# 独木桥

## 题目背景

战争已经进入到紧要时间。你是运输小队长，正在率领运输部队向前线运送物资。运输任务像做题一样的无聊。你希望找些刺激，于是命令你的士兵们到前方的一座独木桥上欣赏风景，而你留在桥下欣赏士兵们。士兵们十分愤怒，因为这座独木桥十分狭窄，只能容纳 $1$ 个人通过。假如有 $2$ 个人相向而行在桥上相遇，那么他们 $2$ 个人将无法绕过对方，只能有 $1$ 个人回头下桥，让另一个人先通过。但是，可以有多个人同时呆在同一个位置。

## 题目描述

突然，你收到从指挥部发来的信息，敌军的轰炸机正朝着你所在的独木桥飞来！为了安全，你的部队必须撤下独木桥。独木桥的长度为 $L$，士兵们只能呆在坐标为整数的地方。所有士兵的速度都为 $1$，但一个士兵某一时刻来到了坐标为 $0$ 或 $L+1$ 的位置，他就离开了独木桥。

每个士兵都有一个初始面对的方向，他们会以匀速朝着这个方向行走，中途不会自己改变方向。但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。

由于先前的愤怒，你已不能控制你的士兵。甚至，你连每个士兵初始面对的方向都不知道。因此，你想要知道你的部队最少需要多少时间就可能全部撤离独木桥。另外，总部也在安排阻拦敌人的进攻，因此你还需要知道你的部队最多需要多少时间才能全部撤离独木桥。

## 说明/提示

对于 $100\%$ 的数据，满足初始时，没有两个士兵同在一个坐标，$1\le  L\le5\times 10^3$，$0\le N\le5\times10^3$，且数据保证 $N\le L$。

## 样例 #1

### 输入

```
4
2
1 3
```

### 输出

```
2 4```

# AI分析结果



### 综合分析与结论

#### 核心算法思路
1. **贪心策略**：将士兵相遇转身视为"灵魂交换"，等效为两人直接穿过对方继续前进。此时每个士兵的撤离时间只与其初始位置到两端的距离有关。
2. **最短时间**：所有士兵选择离自己更近的端点撤离，取所有最短撤离时间的最大值（木桶效应）
3. **最长时间**：所有士兵选择离自己更远的端点撤离，取所有最长撤离时间的最大值

#### 解决难点
- **相遇转化**：通过等价转换消除相遇带来的复杂状态变化
- **极值推导**：发现最短时间需要取最小值的最大值，最长时间需要取最大值的最大值
- **特殊处理**：N=0时直接输出0，避免空指针异常

#### 可视化设计思路
- **像素动画**：用8-bit风格绘制独木桥，士兵以不同颜色方块表示
- **高亮策略**：当前计算的士兵会闪烁，其路径端点用箭头动态指示
- **音效反馈**：
  - 正确选择时播放8-bit上升音效（NES风格）
  - 遇到极值更新时播放金币收集音效
- **自动演示**：AI按位置排序后逐个处理士兵，动态展示min/max计算过程

---

### 题解评分（≥4星）

1. **GXuLuogu（5星）**
   - 亮点：最早提出排序优化，通过数学推导给出极简实现
   - 代码片段：
     ```cpp
     sort(a+1,a+N+1);
     max_time = max(L+1-a[1], a[N]);
     ```

2. **Untitled（4星）**
   - 亮点：独创"万人长巷"比喻，双循环独立计算min/max
   - 核心代码：
     ```cpp
     ans = max(min(l+1-a,a), ans); // 最短
     sna = max(max(l+1-a,a), sna); // 最长
     ```

3. **封禁用户（4星）**
   - 亮点：首创"蚂蚁过桥"类比，提供Pascal实现拓展思路
   - 关键注释：
     ```pascal
     { 最大值的最大值，最小值的最大值 }
     ```

---

### 最优代码实现

#### 核心贪心逻辑
```cpp
int min_time = 0, max_time = 0;
for (int x : soldiers) {
    int left = x, right = L + 1 - x;
    min_time = max(min_time, min(left, right));
    max_time = max(max_time, max(left, right));
}
```

#### 完整代码（GXuLuogu优化版）
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int L, N;
    cin >> L >> N;
    
    if (N == 0) {
        cout << "0 0";
        return 0;
    }

    int a[N];
    for (int i=0; i<N; i++) cin >> a[i];
    
    sort(a, a+N); // 关键排序
    
    int min_time = 0, max_time = 0;
    for (int x : a) {
        min_time = max(min_time, min(x, L+1-x));
    }
    max_time = max(L+1 - a[0], a[N-1]); // 首尾极值
    
    cout << min_time << " " << max_time;
}
```

---

### 同类型题目推荐
1. **P1090 [NOIP2004 提高组] 合并果子**  
   （贪心选择最小代价，优先队列应用）
2. **P1223 排队接水**  
   （时间调度问题，短任务优先策略）
3. **P1803 凌乱的yyy / 线段覆盖**  
   （区间贪心，右端点排序）

---

### 个人心得摘录
- **Ciyang**："当看到【普及-】标签时，觉得不对劲，一定有玄机！"
- **渣旺子**："调试时发现奇偶中点不影响结果，直接取整即可"
- **Adis_FireDevil**："老师说是蓝题，结果代码就10行！"

---

### 可视化方案设计
```html
<div id="bridge" style="position:relative; height:60px; background:#333">
  <!-- 士兵动态生成 -->
</div>

<script>
// 8-bit风格绘制
function drawSoldier(x, color) {
  const soldier = document.createElement('div');
  soldier.style = `position:absolute; left:${x}px; 
                   width:15px; height:15px; background:${color}`;
  return soldier;
}

// 音效模拟
function playSound(type) {
  const ctx = new AudioContext();
  const osc = ctx.createOscillator();
  osc.frequency.value = type === 'correct' ? 880 : 440;
  osc.connect(ctx.destination);
  osc.start(); osc.stop(ctx.currentTime + 0.1);
}
</script>
```

---

### 关键学习点
1. **等效转换**：复杂交互转化为独立决策
2. **极值思维**：最短时间由"最近中的最远"决定
3. **排序优化**：对端点值排序可简化极值计算

通过将物理碰撞转化为逻辑穿透，该问题展示了贪心算法在状态简化中的强大威力。核心在于发现看似复杂交互背后的数学本质。

---
处理用时：58.20秒
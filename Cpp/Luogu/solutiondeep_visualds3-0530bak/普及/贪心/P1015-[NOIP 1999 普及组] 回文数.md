# 题目信息

# [NOIP 1999 普及组] 回文数

## 题目描述

若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。

例如：给定一个十进制数 $56$，将 $56$ 加 $65$（即把 $56$ 从右向左读），得到 $121$ 是一个回文数。

又如：对于十进制数 $87$：

STEP1：$87+78=165$  
STEP2：$165+561=726$  
STEP3：$726+627=1353$   
STEP4：$1353+3531=4884$  

在这里的一步是指进行了一次 $N$ 进制的加法，上例最少用了 $4$ 步得到回文数 $4884$。

写一个程序，给定一个 $N$（$2 \le N \le 10$ 或 $N=16$）进制数 $M$（$100$ 位之内），求最少经过几步可以得到回文数。如果在 $30$ 步以内（包含 $30$ 步）不可能得到回文数，则输出 `Impossible!`。

## 样例 #1

### 输入

```
10
87
```

### 输出

```
STEP=4
```

# AI分析结果



### 综合分析与结论

**核心思路与难点**  
本题核心为高精度模拟 N 进制加法，重点在于：
1. **高精度处理**：使用数组存储大数，处理进位逻辑（非贪心，但需要模拟策略）
2. **进制转换**：正确处理 16 进制的字符与数值转换（A-F 对应 10-15）
3. **回文判断**：高效判断数组/字符串是否为回文
4. **步数控制**：30 步内无解时输出 "Impossible!"

**关键算法要点**  
- **模块化设计**：拆分回文判断、反转、加法操作为独立函数
- **进位处理**：每次加法后统一处理进位（区别于逐位处理）
- **反转优化**：直接操作数组下标反转，避免字符串转换开销
- **字符映射**：统一将字母映射为数值进行运算，输出时还原

---

### 高分题解清单（≥4★）

| 题解作者 | 评分 | 核心亮点 |
|---------|------|----------|
| Haishu   | ★★★★☆ | 模块化设计，数组反向存储，清晰的进位逻辑 |
| Strong_Jelly | ★★★★☆ | 分离高精加/反转/判断函数，代码结构清晰 |
| hwa130    | ★★★★☆ | 利用 STL reverse 简化操作，字符处理高效 |

---

### 最优技巧提炼

1. **数值与字符统一映射**  
```cpp
// 字符转数值（处理16进制）
if(c >= 'A') num = c - 'A' + 10;  
else num = c - '0';

// 数值转字符（输出时）
const char hex[] = "0123456789ABCDEF";
result.push_back(hex[digit]);
```

2. **数组反向存储优化加法**  
```cpp
// 原数存为a[0]~a[n]，反转数直接取a[n]~a[0]
for(int i=0; i<len; i++) rev[i] = a[len-1-i];
```

3. **进位统一处理**  
```cpp
int carry = 0;
for(int i=0; i<max_len; i++){
    sum[i] += a[i] + b[i] + carry;
    carry = sum[i] / base;
    sum[i] %= base;
}
if(carry) sum[max_len++] = carry;
```

---

### 同类型题目推荐

1. **P1017 进制转换**（负进制转换）
2. **P1255 数楼梯**（高精度+递推）
3. **P1601 A+B Problem**（基础高精度加法）

---

### 个人心得摘录

> **Haishu**：  
> "早期用 long long 水过是错误示范，必须用高精度才能保证正确性。模块化设计大幅降低思维复杂度。"  
>   
> **Strong_Jelly**：  
> "反转数组时直接下标操作，比字符串反转更高效。注意16进制字母转换的边界条件。"  
>   
> **Clairad**：  
> "调试时发现未处理最高位进位，导致WA三个点。必须验证进位后的数组长度！"

---

### 算法可视化设计（像素风格演示）

**动画设计要点**：
1. **初始化界面**  
- 8-bit 风格显示初始数字，每位用不同颜色方块表示（0-9：蓝，A-F：红）
- 侧边栏显示当前步数/进制

2. **反转步骤**  
- 原数组方块向左飞出，反向排列后飞回，伴随 "嗖" 音效

3. **加法过程**  
- 每位数字上下对位，显示加法过程（如 7+8=15）
- 进位时上方出现 "+1" 提示，伴随清脆 "叮" 声

4. **回文检测**  
- 红绿箭头从两端向中间扫描，匹配成功时方块闪烁绿色

**代码片段（JS Canvas）**：
```javascript
// 绘制数字方块
function drawDigit(ctx, x, y, num, isHex) {
  ctx.fillStyle = isHex ? '#FF4444' : '#44AAFF';
  ctx.fillRect(x*30, y*50, 25, 40);
  ctx.fillStyle = '#000';
  ctx.font = '20px "Press Start 2P"';
  ctx.fillText(num.toString(16).toUpperCase(), x*30+5, y*50+28);
}

// 进位动画
function animateCarry(pos) {
  let y = pos * 50;
  let targetY = (pos+1)*50;
  // 使用CSS transition实现向上移动效果
  carryElem.style.transform = `translateY(${targetY}px)`;
  playSound('beep'); // 播放8-bit音效
}
```

---

### 完整代码参考（Haishu 题解核心）

```cpp
#include <cstdio>
#include <cstring>
const int S=303;
int n, a[S], l;
char c[S], d[S];

bool is_palindrome() {
    for(int i=0; i<l; i++)
        if(c[i] != c[l-1-i]) return false;
    return true;
}

void add() {
    for(int i=0; i<l; i++) d[l-i-1] = c[i]; // 反转存储
    l += 2; // 预扩展长度
    for(int i=0; i<l; i++) {
        c[i] += d[i];
        if(c[i] >= n) { // 处理进位
            c[i+1]++;
            c[i] -= n;
        }
    }
    while(l > 0 && !c[l-1]) l--; // 去除前导零
}

int main() {
    scanf("%d%s", &n, c);
    l = strlen(c);
    // 字符转数值
    for(int i=0; i<l; i++) {
        if(c[i] >= 'A') c[i] = c[i] - 'A' + 10;
        else c[i] -= '0';
    }
    
    int step = 0;
    while(!is_palindrome() && step <= 30) {
        step++;
        add();
    }
    step <= 30 ? printf("STEP=%d\n", step) : puts("Impossible!");
    return 0;
}
```

---

**可视化体验建议**：  
访问 [JSFiddle 示例](https://jsfiddle.net/) 粘贴上述 JS 代码，配合 [8-bit 音效生成器](https://www.sfxiaoyun.com/tools/8-bit-music-generator) 生成背景音乐，可体验完整复古交互效果。

---
处理用时：79.82秒
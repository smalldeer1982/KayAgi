# 题目信息

# [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。


## 说明/提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
389 207 155 300 299 170 158 65```

### 输出

```
6
2
```

# AI分析结果



### 综合分析与结论

#### 核心算法要点
1. **第一问（最长不上升子序列）**：  
   - 贪心策略：维护数组 `f[]`，其中 `f[i]` 表示长度为 `i` 的不上升子序列的最小末尾值。  
   - 二分优化：对每个新元素 `a[i]`，找到第一个小于 `a[i]` 的位置并替换，保证数组单调性。  
   - 时间复杂度：`O(n log n)`。

2. **第二问（最少系统数）**：  
   - Dilworth 定理：最少系统数等于最长上升子序列长度。  
   - 贪心策略：维护数组 `g[]`，每次选择可拦截当前导弹的最低系统（二分查找），更新系统高度。  
   - 时间复杂度：`O(n log n)`。

#### 解决难点
- **定理理解**：将问题转化为 Dilworth 定理的链划分问题，需理解偏序集和反链概念。  
- **贪心正确性**：证明替换策略不会破坏单调性，且能保证全局最优。  
- **二分边界处理**：正确处理 `upper_bound` 和 `lower_bound` 的边界条件。

#### 可视化设计思路
- **贪心过程动画**：动态展示导弹逐个处理，维护 `f[]` 和 `g[]` 数组的更新过程，高亮当前操作元素。  
- **像素风格交互**：用 8-bit 像素方块表示导弹高度，颜色区分不同系统，音效提示替换/新增操作。  
- **自动演示模式**：模拟贪心选择过程，单步执行时可观察二分查找的中间状态。

---

### 题解评分（≥4星）

| 题解作者          | 评分 | 关键亮点                                                                 |
|-------------------|------|--------------------------------------------------------------------------|
| 离散小波变换°     | ⭐⭐⭐⭐ | 理论推导清晰，代码简洁，明确解释贪心策略与二分优化的结合                 |
| Tofu              | ⭐⭐⭐⭐ | 深入讲解 Dilworth 定理，从偏序集角度提供严谨数学证明                     |
| STA_Morlin        | ⭐⭐⭐⭐ | 结合定理与贪心实现，代码可读性强，附调试日志和优化思路                   |

---

### 最优思路与代码实现

#### 核心贪心逻辑（C++ 片段）
```cpp
// 第一问：最长不上升子序列
int t = 0;
memset(F, 0, sizeof(F)), F[0] = INF;
for (int i = 1; i <= n; ++i) {
    int l = 0, r = t + 1;
    while (r - l > 1) { // 二分找到第一个 < a[i] 的位置
        int m = l + (r - l) / 2;
        F[m] >= a[i] ? l = m : r = m;
    }
    int x = l + 1;
    if (x > t) t = x;
    F[x] = a[i]; // 维护单调性
}

// 第二问：最长上升子序列（Dilworth 定理）
t = 0;
memset(F, 0, sizeof(F)), F[0] = 0;
for (int i = 1; i <= n; ++i) {
    int l = 0, r = t + 1;
    while (r - l > 1) { // 二分找到第一个 >= a[i] 的位置
        int m = l + (r - l) / 2;
        F[m] < a[i] ? l = m : r = m;
    }
    int x = l + 1;
    if (x > t) t = x;
    F[x] = a[i]; // 维护单调性
}
```

---

### 同类型题目与算法套路

1. **最长递增子序列**（LeetCode 300）  
2. **区间覆盖问题**（用最少区间覆盖目标区间）  
3. **任务调度**（如用最少机器处理任务，每个机器不能时间重叠）

---

### 洛谷推荐题目
1. **P1091 合唱队形**（双向 LIS 问题）  
2. **P2216 理想的正方形**（二维滑动窗口与最值优化）  
3. **P2234 营业额统计**（平衡树维护动态序列）

---

### 可视化与游戏化设计

#### 复古像素风格演示
- **Canvas 绘制**：导弹以像素方块从右向左飞行，系统高度用不同颜色条表示。  
- **音效设计**：  
  - `命中系统`：8-bit 短促“哔”声  
  - `新建系统`：低音“咚”声  
  - **背景音乐**：循环芯片音乐（如《俄罗斯方块》风格）  
- **交互控制**：  
  - `空格`：暂停/继续  
  - `→`：加速演示  
  - `←`：减速/回退一步  

#### 算法演示示例
```javascript
// 伪代码：贪心选择可视化
function simulateGreedy(missiles) {
    let systems = [];
    for (let m of missiles) {
        let pos = binarySearch(systems, m);
        if (pos !== -1) {
            systems[pos] = m; // 更新系统高度
            playSound('hit');
        } else {
            systems.push(m); // 新增系统
            playSound('new');
        }
        drawSystems(systems); // 像素渲染
    }
}
```

---

### 总结
通过贪心策略与二分优化的结合，导弹拦截问题在 `O(n log n)` 复杂度内高效解决。Dilworth 定理的应用是核心难点，需结合数学理论与代码实践。可视化设计通过复古像素风格和音效交互，可显著提升算法理解深度。

---
处理用时：66.24秒
# 题目信息

# [NOIP 2003 提高组] 传染病控制

## 题目背景

本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

---

近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。


## 题目描述

研究表明，这种传染病的传播具有两种很特殊的性质；

第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。


第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。


这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。


你的程序要针对给定的树，找出合适的切断顺序。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 300$。

**【题目来源】**

NOIP 2003 提高组第四题

## 样例 #1

### 输入

```
7 6
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
```

# AI分析结果



---

### 综合分析与结论

**核心思路与难点**  
本题实质是树形结构上的最优策略选择问题，需在每层传播时切断一条边，最小化感染人数。由于题目特性（无多项式解法，数据较弱），主流解法为暴力搜索+剪枝，而非严格贪心。

**关键难点与解决方案**  
1. **分层处理**：将树按深度分层，每层选择切断一个子树  
2. **子树标记与回溯**：递归时标记被切断的子树，回溯时恢复状态  
3. **剪枝优化**：维护当前最优解，及时终止无效分支  

**贪心策略的局限性**  
- 典型错误思路：每层切断最大子树，可能错过更优组合  
- 反例构造：链状结构+局部密集子树时贪心失效  
- 正确解法需遍历所有可能的切断组合  

---

### 题解清单（≥4星）

1. **RikoHere（5星）**  
   **亮点**：  
   - 分层预处理（BFS求深度+DFS构建父子关系）  
   - 优先队列处理层间依赖  
   - 模块化标记/回溯函数  
   **代码片段**：  
   ```cpp
   void dfs(int cen, int tot) {
       maxx = max(maxx, tot);
       for (每个当前层节点) {
           if (!被标记) {
               int num = clean(子树); // 标记切断
               dfs(cen+1, tot+num);  // 递归下一层
               reclean(子树);        // 回溯
           }
       }
   }
   ```

2. **基础不牢（4.5星）**  
   **亮点**：  
   - 结构体存储父子关系，直观易维护  
   - 预处理每层节点与子树大小  
   - 快速判断父节点是否被切断优化  
   **个人心得**：  
   > "注意链状结构需提前更新答案，否则最后一层无法到达"

3. **欧鹰（4星）**  
   **亮点**：  
   - 简洁的暴力搜索实现  
   - 直接按层枚举+子树大小累加  
   **代码片段**：  
   ```cpp
   void dfs1(int deep) { 
       for (该层每个节点) {
           dfs2(切断节点); // 标记子树
           ans += 子树大小;
           dfs1(deep+1);   // 递归
           ans -= 子树大小;
           dfs3(回溯); 
       }
   }
   ```

---

### 最优思路与技巧提炼

1. **分层预处理**  
   - BFS/DFS计算节点深度，按层存储  
   - 预处理每节点子树大小：`size[u] = 1 + ∑size[child]`

2. **状态标记与回溯**  
   - 切断时递归标记子树所有节点  
   - 回溯时逆操作恢复状态  

3. **剪枝策略**  
   - 维护全局最优解，当前累计值超过时提前返回  
   - 同层无有效节点时立即更新答案  

---

### 可视化设计（复古像素风格）

**动画方案**：  
1. **树形结构展示**  
   - 8位像素风格绘制树状图，根节点在顶部  
   - 不同颜色区分层数（如绿→黄→红表示深度增加）

2. **贪心/搜索过程演示**  
   - 当前层节点闪烁提示（白色边框）  
   - 切断操作：选中节点后，子树变为灰色，播放“咔嚓”音效  
   - 感染扩散：红色波纹动画模拟传播过程  

**交互功能**：  
- **速度控制**：滑块调节动画速度（0.5x~3x）  
- **模式切换**：手动选择切断节点 / 自动演示最优解  
- **音效反馈**：  
  - 正确切断：8-bit上升音阶  
  - 错误选择：低沉警示音  

**代码片段（Canvas绘制树）**：  
```javascript
// 绘制树节点
function drawNode(x, y, depth) {
  ctx.fillStyle = depthColors[depth];
  ctx.fillRect(x-8, y-8, 16, 16); // 像素方块
  if (selectedNode === id) { // 选中状态
    ctx.strokeStyle = '#FFFFFF';
    ctx.strokeRect(x-10, y-10, 20, 20);
  }
}
```

---

### 同类型题目推荐

1. **P2015 二叉苹果树**（树形DP，保留边权最大）  
2. **P1273 有线电视网**（树形分组DP，叶子收益约束）  
3. **P3942 将军令**（贪心覆盖，最小节点控制全局）

---

### 核心代码实现

**分层DFS核心逻辑**  
```cpp
vector<int> layer[MAXN]; // 按层存储节点
int size[MAXN];          // 子树大小

void dfs(int u, int d) { // 预处理size和层
    layer[d].push_back(u);
    size[u] = 1;
    for (int v : children[u]) {
        dfs(v, d+1);
        size[u] += size[v];
    }
}

int ans = INF;
void cut(int depth, int saved) {
    if (depth > max_layer) {
        ans = min(ans, n - saved);
        return;
    }
    for (int u : layer[depth]) {
        if (被父节点阻断) continue;
        int cnt = count_subtree(u); // 切断u的子树
        cut(depth + 1, saved + cnt);
        restore_subtree(u);        // 回溯
    }
}
```

---
处理用时：69.74秒
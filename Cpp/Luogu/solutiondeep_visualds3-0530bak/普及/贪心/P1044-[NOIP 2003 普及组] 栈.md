# 题目信息

# [NOIP 2003 普及组] 栈

## 题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)

宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)

（原始状态如上图所示）

你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。

## 说明/提示

**【题目来源】**

NOIP 2003 普及组第三题

## 样例 #1

### 输入

```
3
```

### 输出

```
5
```

# AI分析结果



### 综合分析与结论

#### 核心算法与解题思路
本题本质是计算卡特兰数，所有题解均围绕卡特兰数的不同计算方式展开。核心算法要点如下：

1. **卡特兰数递推公式**  
   - 基本递推式：$h(n) = \sum_{i=0}^{n-1} h(i) \cdot h(n-i-1)$  
   - 优化递推式：$h(n) = h(n-1) \cdot \frac{4n-2}{n+1}$  
   - 组合数公式：$h(n) = \frac{C_{2n}^n}{n+1} = C_{2n}^n - C_{2n}^{n-1}$

2. **解决难点**  
   - 避免组合数计算时的数值溢出  
   - 递推与记忆化搜索的时间复杂度优化  
   - 不同公式的适用场景（如取模需求）

#### 最优思路提炼
1. **组合数公式直接计算**  
   - 使用公式 $h(n) = \frac{C_{2n}^n}{n+1}$，通过分解质因数避免阶乘溢出  
   - 或利用递推式 $h(n) = h(n-1) \cdot \frac{4n-2}{n+1}$ 实现O(n)时间复杂度

2. **记忆化搜索优化**  
   - 二维数组记录已计算的中间结果，避免递归重复计算

---

### 题解清单（评分≥4星）

1. **xiejinhao（五星）**  
   **亮点**：提供4种解法（记忆化搜索、递推、组合数、高精度），代码清晰，覆盖全面  
   **核心代码**：
   ```cpp
   // 递推公式实现
   for(int i=2; i<=n; i++)
       h[i] = h[i-1]*(4*i-2)/(i+1);
   ```

2. **inexistent（四星）**  
   **亮点**：数学推导清晰，解释卡特兰数与出栈序列的关系，代码简洁  
   **核心代码**：
   ```cpp
   for(int j=0; j<i; j++)
       h[i] += h[j] * h[i-j-1];
   ```

3. **Nepenthe（四星）**  
   **亮点**：对比不同卡特兰公式的优缺点，选择最优公式实现  
   **核心代码**：
   ```cpp
   printf("%lld", c[2*n][n] - c[2*n][n-1]);
   ```

---

### 同类型题目与算法套路

#### 常见卡特兰数应用场景
1. **括号生成**：n对括号的合法排列数  
2. **二叉搜索树结构**：n个节点能构成的BST数量  
3. **凸多边形三角划分**：n边凸多边形划分方案数

#### 推荐题目
1. **P22 括号生成**  
2. **P96 不同的二叉搜索树**  
3. **P1775 凸多边形划分**  

---

### 可视化与算法演示（复古像素风格）

#### 动画设计方案
1. **像素化栈操作**  
   - 用8-bit风格方块表示栈和待入队列  
   - 绿色箭头表示入栈，红色箭头表示出栈

2. **交互功能**  
   - **步进控制**：空格键单步执行  
   - **自动演示**：Enter键自动播放（速度可调）  
   - **音效**：  
     - 入栈：短促"哔"声  
     - 出栈：低音"咚"声  
     - 完成：经典FC过关音效

3. **Canvas实现核心逻辑**  
   ```javascript
   function drawStack(ctx, stack) {
       stack.forEach((val, idx) => {
           ctx.fillStyle = '#FF5555'; // 红色方块
           ctx.fillRect(100, 300 - idx*30, 50, 25);
           ctx.fillText(val, 115, 315 - idx*30);
       });
   }
   ```

#### 算法演示流程
1. 初始化待入队列 [1,2,3]
2. 展示当前栈状态（空）
3. 高亮下一步可选操作（入栈/出栈）
4. 递归生成所有合法操作路径

---

### 个人心得摘录

1. **调试陷阱**  
   - 组合数公式直接计算时需注意整数除法顺序，否则会导致精度丢失  
   ```cpp
   // 错误写法：h = C(2n,n)/(n+1)
   // 正确写法：先乘后除分解质因数
   ```

2. **优化技巧**  
   - 递推公式比递归更高效，尤其n较大时  
   - 二维DP数组可优化为一维滚动数组

---

### 代码实现（组合数公式）

```cpp
#include <iostream>
using namespace std;

long long catalan(int n) {
    long long res = 1;
    for (int i = 1; i <= n; ++i) {
        res = res * (4*i - 2) / (i + 1);
    }
    return res;
}

int main() {
    int n;
    cin >> n;
    cout << catalan(n);
    return 0;
}
```

---
处理用时：54.11秒
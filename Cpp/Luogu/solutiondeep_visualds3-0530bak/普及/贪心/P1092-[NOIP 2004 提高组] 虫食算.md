# 题目信息

# [NOIP 2004 提高组] 虫食算

## 题目描述

所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的数字。来看一个简单的例子：

$$\begin{aligned}
 \verb!43#9865#045! \\
+\qquad \verb!8468#6633! \\[-1em]\underline{\kern{8em}} \\
 \verb!44445509678! \\
\end{aligned}$$

其中 `#` 号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是 $5$ 和 $3$，第二行的数字是 $5$。

现在，我们对问题做两个限制：

首先，我们只考虑加法的虫食算。这里的加法是 $n$ 进制加法，算式中三个数都有 $n$ 位，允许有前导的 $0$。

其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是 $n$ 进制的，我们就取英文字母表的前 $n$ 个大写字母来表示这个算式中的 $0$ 到 $n - 1$ 这 $n$ 个不同的数字：但是这 $n$ 个字母并不一定顺序地代表 $0$ 到 $n-1$。输入数据保证 $n$ 个字母分别至少出现一次。

$$\begin{aligned}
 \verb!BADC! \\
+\quad \verb!CBDA! \\[-1em]\underline{\kern{4em}} \\
 \verb!DCCC! \\
\end{aligned}$$

上面的算式是一个4进制的算式。很显然，我们只要让 $\verb!ABCD!$ 分别代表 $0123$，便可以让这个式子成立了。你的任务是，对于给定的 $n$ 进制加法算式，求出 $n$ 个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 10$；
- 对于 $50\%$ 的数据，保证 $n \le 15$；
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 26$。

## 样例 #1

### 输入

```
5
ABCED
BDACE
EBBAA
```

### 输出

```
1 0 3 4 2
```

# AI分析结果



---

## **题解思路与算法要点**

### **核心思路**
所有题解均围绕 **DFS + 剪枝** 展开，核心在于从右到左逐列处理，优先处理低位并验证进位，通过高效剪枝减少搜索空间。

#### **关键难点与突破**
1. **搜索顺序优化**  
   - **难点**：传统全排列搜索复杂度为 O(n!)，无法处理 n=26。  
   - **突破**：按列处理（从右到左），优先确定低位字母，利用进位约束高位选择。

2. **剪枝策略**  
   - **进位剪枝**：最高位无进位（否则结果位数不符）。  
   - **合法性剪枝**：每列必须满足 `(a + b) % n == c` 或 `(a + b + 1) % n == c`。  
   - **预处理字母顺序**：按出现频次从低位到高位排序字母，减少无效尝试。

3. **进位传递**  
   - 每列处理时动态计算进位并传递到下一列，确保每一步的合法性。

---

## **最优解法提炼**

### **DFS + 按列剪枝（4.5星）**
- **思路**：从右到左逐列处理，优先处理低位，动态验证进位合法性。  
- **代码要点**：
  ```cpp
  void dfs(int col, int row, int carry) {
      if (col == 0) { 检查最终进位并输出解; }
      for (尝试当前字母的数值) {
          if (当前列非法) continue;
          更新进位并递归下一列;
          回溯;
      }
  }
  ```

### **预处理字母顺序（4星）**
- **优化点**：按字母在低位出现的顺序优先赋值，减少高位冲突。  
- **实现**：从右到左遍历三行，记录首次出现的字母顺序。

---

## **可视化算法分析**

### **动画演示设计**
- **复古像素风格**：8-bit 风格显示竖式，当前处理列高亮为黄色。
- **关键步骤**：
  1. **逐列处理**：从右至左依次处理每列，显示当前尝试的字母数值。
  2. **进位标记**：红色箭头表示进位传递，绿色表示合法。
  3. **剪枝触发**：非法列闪烁红色，回溯时显示灰色。

### **交互功能**
- **步进控制**：支持暂停/继续，调整搜索速度。
- **音效反馈**：合法选择（清脆音效），剪枝（警示音），成功（胜利旋律）。

---

## **推荐题目**
1. **P1082 同余方程**（扩展欧几里得，方程求解）  
2. **P1379 八数码难题**（搜索剪枝）  
3. **P2324 骑士精神**（IDA* 启发式搜索）

---

## **代码片段（DFS核心逻辑）**

```cpp
void dfs(int col, int row, int carry) {
    if (col < 0) {
        if (carry == 0) 输出解;
        return;
    }
    // 剪枝：检查当前列合法性
    if (check_invalid(col)) return;
    
    char ch = s[row][col];
    if (assigned[ch]) {
        // 递归处理下一行或列
        if (row < 2) dfs(col, row+1, carry);
        else {
            int sum = num[s1[col]] + num[s2[col]] + carry;
            if (sum % n != num[s3[col]]) return;
            dfs(col-1, 0, sum / n);
        }
    } else {
        for (int i = n-1; i >= 0; --i) {
            if (used[i]) continue;
            num[ch] = i; used[i] = true;
            // 递归逻辑同上
            ...
            used[i] = false; num[ch] = -1;
        }
    }
}
```

---

## **题解对比与评分**

| 题解作者 | 评分 | 核心亮点 |
|---------|------|----------|
| zzlzk   | ⭐⭐⭐⭐✨ | 剪枝策略清晰，代码高效 |
| yww     | ⭐⭐⭐⭐ | 按列处理进位传递直观 |
| Mihari  | ⭐⭐⭐⭐ | 详细变量预处理与剪枝 |

---

## **总结**
虫食算需结合数学约束与搜索剪枝，最优解法通过按列处理与动态进位验证极大优化搜索效率。可视化设计可直观展示剪枝过程，增强理解。

---
处理用时：60.48秒
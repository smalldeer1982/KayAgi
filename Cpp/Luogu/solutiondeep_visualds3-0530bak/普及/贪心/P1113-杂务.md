# 题目信息

# 杂务

## 题目描述

John 的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。

当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务 $1$。

John 有需要完成的 $n$ 个杂务的清单，并且这份清单是有一定顺序的，杂务 $k\ (k>1)$ 的准备工作只可能在杂务 $1$ 至 $k-1$ 中。

写一个程序依次读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定 John 的农场有足够多的工人来同时完成任意多项任务。


## 样例 #1

### 输入

```
7
1 5 0
2 2 1 0
3 3 2 0
4 6 1 0
5 1 2 4 0
6 8 2 4 0
7 4 3 5 6 0
```

### 输出

```
23
```

# AI分析结果



### 综合分析与结论

#### **核心思路与贪心策略**
本题本质是**关键路径问题**，但由于题目限定「杂务k的前驱只能是1~k-1」，可利用输入顺序特性进行贪心优化。核心贪心策略如下：
- **贪心选择依据**：每个任务的最早开始时间等于其所有前驱任务完成时间的最大值
- **动态维护**：按任务编号顺序处理，直接取前驱最大值，无需显式拓扑排序
- **时间复杂度**：O(n)，每个任务仅需遍历其前驱列表

#### **难点与解决**
- **关键点**：发现前驱的严格顺序性，将问题简化为线性递推
- **核心优化**：省去建图、拓扑排序等步骤，直接利用输入顺序处理

---

### 题解清单（≥4星）

1. **Nishikino_Curtis（⭐⭐⭐⭐⭐）**  
   **亮点**：代码极简（仅20行），利用输入顺序特性，实时维护最大值。核心代码：
   ```cpp
   while(scanf("%d",&t)&&t) tmp=max(ans[t],tmp);
   ans[i]=tmp+l; // l为当前任务耗时
   ```
   **实践性**：无需复杂数据结构，适合竞赛快速实现

2. **SW_Wind（⭐⭐⭐⭐⭐）**  
   **亮点**：输入时直接处理前驱，无需存储图结构。核心逻辑：
   ```cpp
   while(scanf("%d",&y) && y)
       f[k]=max(f[k],f[y]);
   f[k] += tim[k];
   ```
   **思维角度**：发现前驱顺序特性，将问题转化为线性DP

3. **Keith_2006（⭐⭐⭐⭐）**  
   **亮点**：详细讲解拓扑排序的两种实现（DFS/BFS），提供通用DAG解法。核心公式：
   ```math
   f_i = \max\{pre_i\} + a_i
   ```
   **拓展性**：适用于无输入顺序限制的通用DAG场景

---

### 贪心策略可视化设计

#### **像素风格动画演示**
- **Canvas 布局**：任务按编号横向排列，高度表示完成时间
- **颜色编码**：已处理任务为绿色，当前任务黄色，前驱最大值红色
- **音效触发**：选择前驱时播放「滴」声，更新完成值时播放「叮」声

#### **关键帧示例**
1. 初始状态：任务1为绿色，完成时间=5（样例输入）
2. 处理任务2：高亮前驱1（红），更新完成时间5+2=7
3. 处理任务7：高亮前驱3/5/6（红），取最大值19+4=23

#### **交互功能**
- **步进控制**：空格键单步执行
- **速度调节**：滑动条控制动画速度（0.5x~3x）
- **自动演示**：AI模式自动播放，配8-bit背景音乐

---

### 核心代码实现
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int f[10005], max_ans;

int main() {
    int n, k, t, x;
    scanf("%d", &n);
    for (int i=1; i<=n; ++i) {
        scanf("%d%d%d", &k, &t, &x);
        int pre_max = 0;
        while (x) {
            pre_max = max(pre_max, f[x]);
            scanf("%d", &x);
        }
        f[k] = pre_max + t;
        max_ans = max(max_ans, f[k]);
    }
    printf("%d", max_ans);
    return 0;
}
```

---

### 相似题目推荐
1. **P2014 [CTSC1997]选课** - 树形DP中的依赖选择
2. **P2742 [USACO5.1]圈奶牛Fencing the Cows** - 贪心处理凸包极角排序
3. **P2947 [USACO09MAR]向右看齐Look Up** - 单调栈维护右侧最大值

---

### 个人心得摘录
> "我是仗着代码短才来发的" —— Nishikino_Curtis  
> **启示**：竞赛中应优先寻找题目特性，避免过度设计

> "为什么这个代码可以实现拓扑排序？因为前驱必然先被处理" —— Keith_2006  
> **调试经验**：理解输入顺序特性是优化关键

---

### 算法比较与拓展
- **通用场景**：拓扑排序（如P4017食物链计数）
- **特殊场景**：本题的贪心解法可视为拓扑排序的**特例优化**
- **思维迁移**：当问题元素具有顺序依赖时，可尝试类似线性递推优化

---
处理用时：63.52秒
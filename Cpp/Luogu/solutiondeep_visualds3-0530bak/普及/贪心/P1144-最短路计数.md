# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果



### 综合分析与结论

#### 核心思路与难点解析
本题核心是在无权图中统计从起点到各点的最短路数量。所有题解均围绕 **BFS/SPFA/Dijkstra** 的变形展开，核心难点在于 **动态维护最短路数量**。关键策略：
1. **分层处理**：利用无权图边权为1的特性，BFS天然分层，每层对应相同距离的节点。
2. **计数累加原则**：若节点`v`的最短路通过`u`到达，则`ans[v] += ans[u]`。
3. **避免重复计数**：通过判断距离是否严格递减或相等来正确累加。

#### 贪心策略与可视化设计
- **贪心选择**：在BFS中优先处理距离最近的节点（队列特性），确保每个节点被首次访问时即得到最短路径。
- **可视化方案**：
  - **复古像素风格**：将节点布局为网格，用不同颜色区分已访问/未访问节点，当前处理节点高亮显示。
  - **动画演示**：队列动态变化，每次出队节点扩展时显示其邻居，绿色箭头表示有效计数累加，红色表示无效路径。
  - **音效触发**：节点入队时播放“滴”声，计数更新时用上扬音效，错误路径用低沉音效。

---

### 题解清单（评分≥4星）

1. **岸芷汀兰（4.5星）**
   - **亮点**：纯BFS实现，清晰解释分层计数逻辑，处理重边和自环。
   - **代码**：使用邻接表存储，维护距离和计数数组，代码简洁高效。
   - **个人心得**：强调“第一次访问即最短路径”，避免复杂队列操作。

2. **King丨帝御威（4星）**
   - **亮点**：堆优化Dijkstra实现，强调稳定性，避免SPFA被卡。
   - **核心代码**：优先队列处理节点，动态更新计数，适合带权图扩展。

3. **XIE_BR（4星）**
   - **亮点**：两阶段处理（SPFA+记忆化搜索），避免重复计数问题。
   - **技巧**：先求最短路再构建最短路图，确保计数正确性。

---

### 最优思路与代码实现

#### 核心逻辑（BFS分层计数）
```cpp
void bfs() {
    queue<int> q;
    q.push(1);
    dis[1] = 0;
    ans[1] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : adj[u]) {
            if (!vis[v]) { // 首次访问，最短路径
                dis[v] = dis[u] + 1;
                ans[v] = ans[u];
                vis[v] = true;
                q.push(v);
            } else if (dis[v] == dis[u] + 1) { // 相同距离，累加计数
                ans[v] = (ans[v] + ans[u]) % MOD;
            }
        }
    }
}
```

#### 完整代码（岸芷汀兰题解精简）
```cpp
#include <vector>
#include <queue>
using namespace std;

const int MOD = 100003;
vector<int> adj[1000005];
int dis[1000005], ans[1000005];
bool vis[1000005];

void bfs() {
    queue<int> q;
    q.push(1);
    dis[1] = 0; ans[1] = 1; vis[1] = true;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : adj[u]) {
            if (!vis[v]) {
                vis[v] = true;
                dis[v] = dis[u] + 1;
                ans[v] = ans[u];
                q.push(v);
            } else if (dis[v] == dis[u] + 1) {
                ans[v] = (ans[v] + ans[u]) % MOD;
            }
        }
    }
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    while (m--) {
        int u, v;
        scanf("%d%d", &u, &v);
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    bfs();
    for (int i = 1; i <= n; ++i)
        printf("%d\n", ans[i]);
}
```

---

### 同类题目推荐
1. **P1608 路径统计** - 带权图最短路计数
2. **P2865 [USACO06NOV]Roadblocks** - 次短路计数
3. **P1144 最短路计数（本题）** - 无权图最短路计数

---

### 可视化设计要点
1. **Canvas网格渲染**：节点按网格排列，当前处理节点用闪烁效果。
2. **音效触发规则**：
   - `节点入队`：短促“滴”声
   - `计数更新`：清脆“叮”声
   - `无效路径`：低沉“嗡”声
3. **自动演示模式**：按BFS顺序自动播放，可调节速度（0.5x~2x）。
4. **交互面板**：暂停/继续按钮，步进控制，显示当前队列状态和计数数组。

通过复古像素风格和游戏化交互，将算法学习转化为沉浸式体验，强化对BFS分层和计数累加机制的理解。

---
处理用时：60.31秒
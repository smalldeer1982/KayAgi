# 题目信息

# 刷题

## 题目描述

NOIP 临近了，小 A 却发现他已经不会写题了。好在现在离竞赛还有一段时间，小 A 决定从现在开始夜以继日地刷题。也就是说小 A 废寝忘食，一天二十四小时地刷题。

今天的日期（时间）是 yyyy 年 mm 月 dd 日 hh 时 MM 分，考试的时间是 yyyy2 年 mm2 月 dd2 日 hh2 时 MM2 分。这之间的所有时间小 A 都用来刷题了，那么考试之前他最多能刷多少题呢？注意哦，考虑闰年。

时间紧张小 A 只管数量不管质量。当然有的题目容易一些，有的题目难一些。根据小 A 的经验，他能一眼看出写出某一个题目需要的时间，以分钟记。

现在给出洛谷 Online Judge 的题目列表，请你挑出最多的题目使小A能在竞赛前写出来。

我们假设从远古到未来，历法的表示与现在一样。


## 样例 #1

### 输入

```
2
1
1
2007-06-23-11:59
2007-06-23-12:00```

### 输出

```
1```

# AI分析结果



### 综合分析与结论

#### 核心算法要点
1. **贪心策略**：将题目按时间升序排列，优先完成耗时短的题目。正确性证明：交换任意两个题目顺序不会得到更优解。
2. **时间计算**：通过基准日法（如0000年1月1日）或分段累加法计算两个时间点的分钟差，需正确处理闰年和月份天数差异。
3. **难点突破**：时间计算的边界处理（如闰年2月、跨年跨月时的天数调整）是核心挑战，多退少补法（先加整年再调整月日）是常用技巧。

#### 可视化设计思路
1. **贪心过程动画**：以像素风格展示排序后的题目数组，每次选择最小元素时高亮该方块，剩余时间条动态减少，伴随8-bit音效。
2. **时间计算演示**：用日历翻页动画展示年份累加过程，闰年用特殊颜色标记，月份切换时显示天数调整逻辑。
3. **交互设计**：支持暂停/继续/单步执行，在时间计算步骤可查看当前累计天数、剩余调整量等中间状态。

---

### 题解清单（评分≥4星）

#### 1. 傅思维666（4.5星）
- **亮点**：多退少补法处理时间差，代码结构清晰，注释完整
- **关键代码**：
```cpp
for(int i=start[1];i<endd[1];i++) // 处理整年
    time += check(i) ? 366 : 365;
for(int i=1;i<start[2];i++)      // 调整起始年多余月份
    time -= check(start[1]) ? m2[i] : m1[i];
```

#### 2. king_xbz（4.2星）
- **亮点**：模块化设计时间计算函数，可复用性强
- **心得摘录**："处理月份天数时发现原题解存在隐藏bug，当跨年计算时未重置月份数组，导致WA多次"

#### 3. outis_crypt（4.0星）
- **亮点**：利用Java Calendar类简化时间计算，提供跨语言思路
- **代码片段**：
```java
Calendar a = Calendar.getInstance();
a.set(y1, m1-1, d1, h1, m1);
long diff = (b.getTimeInMillis()-a.getTimeInMillis())/1000/60;
```

---

### 最优思路与代码实现

#### 核心贪心逻辑
```cpp
sort(a, a+n);
int cnt = 0;
for(int i=0; i<n; ++i){
    if(total_time >= a[i]){
        total_time -= a[i];
        cnt++;
    }else break;
}
cout << cnt;
```

#### 完整时间计算（基准日法）
```cpp
bool is_leap(int y){
    return (y%400==0) || (y%4==0 && y%100!=0);
}

long long calc_days(int y, int m, int d){
    long long days = d;
    for(int i=1; i<m; ++i){
        if(i==2) days += is_leap(y) ? 29 : 28;
        else days += month_days[i];
    }
    for(int i=0; i<y; ++i)
        days += is_leap(i) ? 366 : 365;
    return days;
}

long long total_min = (end_days - start_days)*1440 
                     + (end_h*60 + end_m) 
                     - (start_h*60 + start_m);
```

---

### 同类题目推荐
1. **P1014 [NOIP1999 普及组] Cantor表** - 日期序列化问题
2. **P1223 排队接水** - 经典贪心+时间计算
3. **P1059 [NOIP2006 普及组] 明明的随机数** - 排序+去重

---

### 可视化方案（复古像素版）

#### 动画设计
```html
<canvas id="pixel-canvas"></canvas>
<script>
const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEEAD'];
let problems = [30,15,45,20]; // 排序后的题目
let timeLeft = 100; // 剩余时间

function drawBlock(ctx, x, y, val, color){
    ctx.fillStyle = color;
    ctx.fillRect(x*50, y*50, 40, 40);
    ctx.fillStyle = '#000';
    ctx.font = '12px retro';
    ctx.fillText(val, x*50+5, y*50+25);
}

function animateGreedy(){
    if(problems.length === 0) return;
    let curr = problems.shift();
    if(timeLeft >= curr){
        timeLeft -= curr;
        playSound('pick'); // 播放拾取音效
    }
    renderCanvas();
    setTimeout(animateGreedy, 1000);
}
</script>
```

#### 音效设计
- **pick.wav**：650Hz方波，持续0.1s（选择题目）
- **error.wav**：200Hz锯齿波，持续0.3s（时间不足）
- **bgm.mod**：8-bit风格背景音乐循环

---

### 总结与扩展
本题解展示了日期计算与贪心算法的经典结合。在时间处理中，建议采用基准日法减少边界条件判断。贪心策略的普适性使其适用于各类"最大化数量"问题，关键要证明局部最优能导向全局最优。可视化设计通过复古元素增强学习趣味性，核心在于将抽象的时间流逝转化为直观的像素动画。

---
处理用时：64.54秒
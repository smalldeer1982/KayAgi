# 题目信息

# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 说明/提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)

题目中没有强制 $i \neq j$，但是实测数据中不存在 $i = j$ 的情况。

## 样例 #1

### 输入

```
4
M 2 3
C 1 2
M 2 4
C 4 2```

### 输出

```
-1
1```

# AI分析结果



### 算法分类
**带权并查集**

---

### 题解思路与核心难点
**核心思路**  
采用带权并查集，维护每个节点到根节点的距离（`d[]`）和集合大小（`size[]`）。  
- **合并操作**：将集合A的根节点父指针指向集合B的根节点，并更新A根节点的距离为B的集合大小，同时更新B的集合大小。  
- **查询操作**：路径压缩时动态维护`d[]`，最终通过距离差计算中间战舰数。  

**解决难点**  
1. **路径压缩时的权值更新**：在`find()`递归过程中，回溯时累加父节点的距离到当前节点，实现动态更新。  
2. **合并时的权值计算**：合并两个集合时，被合并集合根的`d`值等于目标集合的`size`，确保后续查询的正确性。  

---

### 最优题解评分（≥4星）
1. **假装思考（5星）**  
   - 清晰解释`front[]`和`num[]`的维护逻辑，路径压缩时动态更新距离。  
   - 代码简洁高效，适合作为模板。  
2. **Mr_Wolfram（4.5星）**  
   - 使用`dis[]`和`num[]`实现带权并查集，代码结构清晰，注释详细。  
   - 突出路径压缩的回溯更新机制。  
3. **Drinkkk（4星）**  
   - 提供离线思路，通过预处理最终状态计算顺序号，思路新颖但效率略低。  

---

### 核心算法代码实现
```cpp
#include <iostream>
#include <cmath>
using namespace std;

const int MAXN = 30010;
int fa[MAXN], d[MAXN], size[MAXN];

int find(int x) {
    if (fa[x] != x) {
        int root = find(fa[x]);
        d[x] += d[fa[x]]; // 路径压缩时累加父节点距离
        fa[x] = root;
    }
    return fa[x];
}

void merge(int x, int y) {
    int fx = find(x), fy = find(y);
    if (fx != fy) {
        fa[fx] = fy;
        d[fx] = size[fy]; // 合并后fx到fy的距离为fy的原大小
        size[fy] += size[fx]; // 更新集合大小
    }
}

int query(int x, int y) {
    int fx = find(x), fy = find(y);
    return (fx == fy) ? abs(d[x] - d[y]) - 1 : -1;
}

int main() {
    int T;
    cin >> T;
    for (int i = 1; i < MAXN; ++i) fa[i] = i, size[i] = 1;
    while (T--) {
        char op;
        int x, y;
        cin >> op >> x >> y;
        if (op == 'M') merge(x, y);
        else cout << query(x, y) << endl;
    }
    return 0;
}
```

---

### 可视化设计要点
**算法动画方案**  
1. **合并操作**：  
   - 高亮被合并集合的根节点，显示其`d`值更新为另一集合的`size`。  
   - 用箭头动态连接两个队列，展示队列首尾相接。  
2. **路径压缩**：  
   - 以不同颜色标记当前处理的节点，显示其父节点跳跃到根的过程。  
   - 实时更新`d`值，展示累加效果。  
3. **查询操作**：  
   - 显示两节点到根的路径，计算距离差并高亮中间战舰区域。  

**复古像素风格**  
- **颜色方案**：根节点用绿色，普通节点用蓝色，路径压缩中的节点用闪烁红色。  
- **音效**：合并时播放“连接”音效，路径压缩时播放“滴答”声，查询成功时触发胜利音效。  

---

### 同类题目推荐
1. **P1551 亲戚**（基础并查集）  
2. **P2024 食物链**（带权并查集，维护环形关系）  
3. **P1525 关押罪犯**（并查集应用，最大边权最小化）  

---

### 总结
带权并查集通过维护额外信息（距离、集合大小）解决了传统并查集无法处理的动态关系问题。核心在于路径压缩时的权值累加和合并时的权值初始化，理解这两个过程即可快速掌握此类问题。

---
处理用时：66.62秒
# 题目信息

# [USACO1.4] 母亲的牛奶 Mother's Milk

## 题目描述

农民约翰有三个容量分别是 $a,b,c$ 升的桶。  

最初，$a,b$ 桶都是空的，而 $c$ 桶是装满牛奶的。有时，农民把牛奶从一个桶倒到另一个桶中，直到被灌桶装满或原桶空了。  

当然每一次灌注都是完全的。由于节约，牛奶不会有丢失。

写一个程序去帮助农民找出当 $a$ 桶是空的时候，$c$ 桶中牛奶所剩量的所有可能性。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le a,b,c \le 20$。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
8 9 10
```

### 输出

```
1 2 8 9 10
```

## 样例 #2

### 输入

```
2 5 10```

### 输出

```
5 6 7 8 9 10```

# AI分析结果



# 【算法分类】  
DFS/BFS（深度优先搜索/广度优先搜索）

---

## 【题解思路、算法要点与解决难点】  
**核心思路**：通过遍历所有可能的倒牛奶操作，记录当A桶为空时C桶的剩余量。  
**算法要点**：  
1. **状态表示**：用(a, b, c)表示三个桶的当前牛奶量，初始状态为(0, 0, C)。  
2. **状态判重**：使用三维数组`vis[a][b][c]`避免重复访问同一状态。  
3. **倒牛奶操作**：遍历6种可能的倒法（A→B、A→C、B→A、B→C、C→A、C→B），每次倒牛奶时计算实际转移量（被倒桶剩余容量与原桶当前量的最小值）。  
4. **结果记录**：当A桶为空时，记录C桶的当前值到结果集中。  

**解决难点**：  
- **状态空间爆炸控制**：通过三维数组判重，将时间复杂度控制在O(A_max × B_max × C_max)。  
- **倒牛奶逻辑**：正确处理两种倒法（倒满目标桶或倒空原桶）的边界条件，例如：  
  ```cpp
  int rec = min(bkt[j] - a[j], a[i]); // 实际转移量计算
  ```

---

## 【题解评分 (≥4星)】  
1. **远航之曲（DFS，4.5星）**  
   - 亮点：使用`memcpy`高效复制状态数组，递归逻辑清晰，通过双重循环遍历所有倒法。  
   - 代码片段：  
     ```cpp
     for (int i = 0; i < 3; ++i) {
         for (int j = 0; j < 3; ++j) {
             if (j == i) continue;
             int rec = min(bkt[j] - a[j], a[i]);
             int b[3]; memcpy(b, a, sizeof(int)*3);
             b[i] -= rec, b[j] += rec;
             dfs(b);
         }
     }
     ```

2. **Kewth（DFS，4星）**  
   - 亮点：直接硬编码处理6种倒法，使用三元运算符简化倒牛奶逻辑。  
   - 代码片段：  
     ```cpp
     y+z>b?milk(x,b,y+z-b):milk(x,y+z,0); // B倒C的逻辑
     ```

3. **info___tion（BFS，4星）**  
   - 亮点：队列实现BFS，通过编码法（i/3和i%3）枚举倒法方向。  
   - 代码片段：  
     ```cpp
     for (int i=0; i<9; i++) {
         int sn=i/3, tn=i%3; // sn: 倒出桶, tn: 倒入桶
     }
     ```

---

## 【最优思路或技巧提炼】  
1. **状态压缩**：用三维数组判重，将状态空间限制在20×20×20内。  
2. **倒牛奶公式**：转移量计算`min(目标桶剩余容量, 原桶当前量)`。  
3. **结果去重**：使用布尔数组记录C桶的可能值，避免重复输出。  

---

## 【同类型题与算法套路】  
**通用解法**：  
- **状态转移问题**：如八数码问题（状态用字符串表示）、倒水问题（多容器状态）。  
- **优化套路**：优先用BFS求最短操作步数，用DFS+剪枝减少内存消耗。  

---

## 【推荐相似题目】  
1. **P1135 奇怪的电梯**（BFS求最短路径）  
2. **P1443 马的遍历**（BFS网格遍历）  
3. **P1746 离开中山路**（BFS状态扩展）

---

## 【个人心得摘录】  
1. **远航之曲**：  
   > "发现没有c++的题解，果断来一发" —— 反映社区贡献意识。  
2. **Mr_HaoZzZz**：  
   > "注：由于在文章中已经详细阐述，所以不再提供注释！" —— 强调代码自解释性。  
3. **yangyiming**：  
   > "哪怕不是大佬也一定看得懂" —— 重视代码可读性。

---

## 【可视化与算法演示】  
### 核心算法动画设计  
1. **状态立方体**：  
   - 用20×20×20的立方体网格表示所有可能状态，初始点亮(0,0,C)为绿色。  
   - 每次DFS/BFS扩展时，当前状态变为黄色，已访问状态变为灰色。  

2. **倒牛奶过程**：  
   - **高亮变化桶**：倒出桶红色闪烁，倒入桶蓝色填充动画。  
   - **数值更新**：用浮动文字显示转移量（如"A→B: 5L"）。  

3. **结果标记**：  
   - 当A=0时，C值在右侧列表中以绿色渐入效果显示。  

### 复古像素风格实现  
```javascript
// Canvas绘制示例（伪代码）
const canvas = document.getElementById("pixel-canvas");
ctx.fillStyle = "#8B8B8B"; // 灰色表示已访问状态
ctx.fillRect(a*10, b*10, 10, 10); // 每个状态用10x10像素表示

// 音效触发
function playSound(effect) {
    if (effect === "pour") new Audio("sfx/pour.wav").play();
    if (effect === "success") new Audio("sfx/success.wav").play();
}
```

---

## 【核心代码实现】  
远航之曲的DFS实现（完整代码）：  
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
const int MAX = 22;
bool milk[MAX] = {0};
bool vis[MAX][MAX][MAX] = {0};
static int bkt[3];

void dfs(int a[]) {
    if (vis[a[0]][a[1]][a[2]]) return;
    vis[a[0]][a[1]][a[2]] = true;
    if (a[0] == 0) milk[a[2]] = true;
    
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            if (j == i) continue;
            if (a[j] < bkt[j] && a[i] > 0) {
                int rec = std::min(bkt[j] - a[j], a[i]);
                int b[3]; memcpy(b, a, sizeof(int)*3);
                b[i] -= rec, b[j] += rec;
                dfs(b);
            }
        }
    }
}

int main() {
    scanf("%d %d %d", &bkt[0], &bkt[1], &bkt[2]);
    int a[3] = {0,0,bkt[2]};
    dfs(a);
    for (int i = 0; i < bkt[2]; ++i) 
        if (milk[i]) printf("%d ", i);
    printf("%d\n", bkt[2]);
    return 0;
}
```

---
处理用时：78.59秒
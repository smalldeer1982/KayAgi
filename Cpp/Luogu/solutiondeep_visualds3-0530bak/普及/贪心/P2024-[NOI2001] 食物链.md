# 题目信息

# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# AI分析结果



### 综合分析与结论

#### 算法核心与难点
本题目需通过并查集维护环形食物链关系，核心难点在于如何表达三类动物的复杂关系。主要解法分为两类：

1. **扩展域并查集（三倍数组法）**  
   - 每个动物分为三个域：同类域、猎物域、天敌域  
   - 合并时需同步处理三个域的集合关系  
   - 直观表达环形食物链，但需要处理三倍数据量  

2. **带权并查集（模运算法）**  
   - 通过权值0（同类）、1（捕食）、2（被食）表示关系  
   - 路径压缩时维护权值的模运算关系  
   - 数学推导要求高，但空间效率更优  

#### 贪心策略与可视化设计
- **贪心选择**：每次合并操作时立即验证关系正确性，通过提前判断冲突实现"局部最优"  
- **可视化思路**：  
  - 用三色标记同类域（绿）、猎物域（红）、天敌域（蓝）  
  - 动画展示合并操作时三个域的同步变化，高亮当前操作的域  
  - 步进演示路径压缩时权值的传递过程  
  - 冲突判断时显示冲突链路的颜色闪烁  

### 题解评分（≥4★）

1. **Sooke（5★）**  
   - 亮点：图文并茂解释三倍数组原理，附完整代码与测试案例  
   - 心得："种类并查集并非具体种类，而是关系维护"  
   
2. 檀黎斗（4★）  
   - 亮点：代码极简（仅50行），逻辑清晰，三域合并高效  
   - 代码片段：  
     ```cpp
     // 同类合并
     unity(x,y); unity(x+n,y+n); unity(x+2n,y+2n);
     // 捕食合并
     unity(x+n,y); unity(x+2n,y+n); unity(x,y+2n);
     ```

3. 天泽龟（4★）  
   - 亮点：带权并查集数学推导完整，权值传递公式严谨  
   - 关键公式：`re[f1] = (re[b] - re[a] + 3) % 3`  

### 最优思路提炼

**三倍数组法核心逻辑**：
```python
当x与y是同类时：
    若x的猎物域与y的同类域连通 → 假话
    否则合并三个域：
        x的同类域 ↔ y的同类域
        x的猎物域 ↔ y的猎物域
        x的天敌域 ↔ y的天敌域

当x吃y时：
    若x与y同类或y吃x → 假话
    否则建立环形关系：
        x的猎物域 ↔ y的同类域
        y的天敌域 ↔ x的同类域
        x的天敌域 ↔ y的猎物域
```

### 同类型题目推荐

1. **P1525 关押罪犯**（二分图+并查集）  
2. **P1196 银河英雄传说**（带权并查集距离维护）  
3. **P1455 搭配购买**（并查集+背包DP）

### 可视化设计（复古像素版）

```javascript
// Canvas绘制示例
const drawNode = (x, y, color) => {
  ctx.fillStyle = color; // 绿/红/蓝三色
  ctx.fillRect(x*30, y*30, 25, 25); // 像素方块
  ctx.strokeStyle = '#000'; // 黑色边框
  ctx.strokeRect(x*30, y*30, 25, 25);
};

// 合并动画
function animateMerge(domainA, domainB) {
  domainA.forEach((pos, i) => {
    gsap.to(pos, {x: domainB[i].x, y: domainB[i].y, duration: 1});
  });
  playSound('merge.wav'); // 8-bit音效
}
```

### 核心代码实现

**三倍数组法关键片段**：
```cpp
void unite(int x, int y, int type) {
    if(type == 1) { // 同类
        fa[find(x)] = find(y);
        fa[find(x+n)] = find(y+n);
        fa[find(x+2n)] = find(y+2n);
    } else { // 捕食
        fa[find(x+n)] = find(y);
        fa[find(y+2n)] = find(x);
        fa[find(x+2n)] = find(y+n);
    }
}

bool check(int x, int y, int type) {
    if(type == 1) 
        return find(x) == find(y+n) || find(x) == find(y+2n);
    else 
        return find(x) == find(y) || find(y) == find(x+n);
}
```

**带权并查集路径压缩**：
```cpp
int find(int x) {
    if (f[x] != x) {
        int root = find(f[x]);
        d[x] = (d[x] + d[f[x]]) % 3;
        f[x] = root;
    }
    return f[x];
}
```

### 扩展思考

当遇到**动态食物链**（关系随时间变化）时，可引入**可持久化并查集**。对于**N个类别**的环形关系，推广为**N倍数组法**，每个节点维护N种可能状态。

---
处理用时：63.18秒
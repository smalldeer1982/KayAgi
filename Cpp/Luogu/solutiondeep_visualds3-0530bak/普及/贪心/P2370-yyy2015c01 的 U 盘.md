# 题目信息

# yyy2015c01 的 U 盘

## 题目背景

在 2020 年的某一天，我们的 yyy2015c01 买了个高端 U 盘。


## 题目描述

你找 yyy2015c01 借到了这个高端的 U 盘，拷贝一些重要资料，但是你发现这个 U 盘有一些问题：

1. 这个 U 盘的传输接口很小，只能传输大小不超过 $L$ 的文件。
2. 这个 U 盘容量很小，一共只能装不超过 $S$ 的文件。

但是你要备份的资料却有很多，你只能备份其中的一部分。

为了选择要备份哪些文件，你给所有文件设置了一个价值 $V_i$，你希望备份的文件总价值不小于 $p$。

但是很快你发现这是不可能的，因为 yyy2015c01 的传输接口太小了，你只有花钱买一个更大的接口（更大的接口意味着可以传输更大的文件，但是购买它会花费更多的钱）。

注意：你的文件不能被分割（你只能把一个文件整个的传输进去，并储存在U盘中）,

你放在 U 盘中文件的总大小不能超过 U 盘容量。

现在问题来了：你想知道，在满足 U 盘中文件价值之和**不小于** $p$ 时，最小需要多大的接口。

## 说明/提示

$1 \le n, W_i, S \le 10^3$，$1 \leq V_i \leq 10^6$，$1 \leq p \leq 10^9$。

数据较小，请勿乱搞。

样例解释 $1$：买一个大小为 $2$ 接口，把物品 $1$ 、$2$ 放进$\text{U}$盘。

样例解释 $2$：买一个大小为 $500$ 的接口。

样例解释 $3$：本来可以买大小为 $2$ 的接口，可是 U 盘容量放不下足够的文件。

如果数据出现疏漏，请联系出题人 [a710128](https://www.luogu.com.cn/user/2573)

向本题主人公 yyy2015c01 同学致敬！

## 样例 #1

### 输入

```
3 3 5
2 2
1 2
3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 505
1 2
500 1```

### 输出

```
500```

## 样例 #3

### 输入

```
3 3 2
2 2
1 2
3 2```

### 输出

```
No Solution!```

## 样例 #4

### 输入

```
4 5 6
5 1
5 2
5 3
1 1```

### 输出

```
No Solution!```

# AI分析结果



### 综合分析与结论

#### 题目核心
在满足总价值 ≥ p 且总大小 ≤ S 的条件下，求允许传输的文件最大尺寸 L 的最小值。本质是带双约束（总容量、单文件尺寸）的背包问题，需结合参数最小化求解。

#### 算法要点对比
1. **贪心+背包（cs18）**  
   - **核心思路**：按文件大小升序排序，逐个处理文件并做 01 背包。每次处理时允许所有 ≤ 当前文件大小的文件，一旦总价值 ≥ p 立即返回当前文件大小作为 L。  
   - **正确性保证**：排序后处理顺序由小到大，确保若存在更小的可行 L，必在更早的迭代中被检测到。  
   - **优势**：时间复杂度低（可能提前终止），代码简洁。  
   - **难点**：需严格证明贪心策略的正确性（依赖排序后状态的包含关系）。

2. **二分+背包（MuelsyseU）**  
   - **核心思路**：二分可能的 L 范围（文件最小到最大尺寸），每次验证 mid 是否可行（允许 ≤ mid 的文件，求最大价值是否 ≥ p）。  
   - **正确性保证**：二分单调性（L 越大可选文件越多，总价值非递减）。  
   - **优势**：逻辑直观，适用性广。  
   - **难点**：需处理多次背包计算的初始化及验证效率。

#### 最优思路提炼
- **贪心+背包**在本题数据条件下更优，因其利用排序后状态的包含性，实现快速剪枝。  
- **正确性关键**：若存在可行解 L'，则所有 ≥ L' 的 L 均可行。排序后处理顺序确保首次满足条件的 L 必为最小。

#### 可视化设计
- **贪心过程动画**：  
  1. 文件按大小升序排列，从左到右依次高亮当前处理的文件（标记为黄色）。  
  2. 背包容量条（水平条形图）动态更新，显示当前允许的文件组合下的最大价值。  
  3. 当总价值达标时，当前文件尺寸闪烁（红色→绿色），输出 L 值。  
- **交互功能**：  
  - 步进控制观察每次背包更新。  
  - 对比二分法过程（右侧面板展示二分区间缩小及验证结果）。

---

### 题解评分（≥4星）

1. **cs18（5星）**  
   - **亮点**：高效贪心策略，代码简洁（20行内解决），提前终止优化。  
   - **代码可读性**：结构清晰，关键注释到位。  
   - **个人心得**：无详细正确性证明，但通过排序策略隐含正确性。

2. **MuelsyseU（5星）**  
   - **亮点**：详细讲解二分与背包结合，包含正确性证明及调试技巧。  
   - **代码可读性**：模块化设计（分离 dp 与二分逻辑），注释详尽。  
   - **优化提示**：初始化 low-1 避免边界错误。

3. **固执（4星）**  
   - **亮点**：简洁的贪心实现，附带反例测试说明。  
   - **代码可读性**：直接嵌入贪心与背包，适合快速理解。  
   - **不足**：缺少正确性论证。

---

### 关键代码实现

#### 贪心+背包（cs18）
```cpp
sort(a+1, a+n+1, cmp); // 按文件大小升序排序
for(int i=1; i<=n; i++) {
    for(int j=s; j>=a[i].v; j--) {
        dp[j] = max(dp[j], dp[j - a[i].v] + a[i].w);
        if(dp[s] >= p) { // 满足条件立即终止
            printf("%d", a[i].v);
            return 0;
        }
    }
}
```

#### 二分+背包（MuelsyseU）
```cpp
bool check(int mid) {
    memset(f, 0, sizeof(f));
    for(int i=1; i<=n; i++) {
        if(a[i] > mid) continue;
        for(int j=s; j>=a[i]; j--)
            f[j] = max(f[j], f[j - a[i]] + b[i]);
    }
    return f[s] >= m;
}
int main() {
    int ans = find(low-1, high); // 二分边界调整
}
```

---

### 相似题目推荐
1. **P2440 木材加工**（二分答案基础）  
2. **P1280 尼克的任务**（贪心+动态规划）  
3. **P2370 yyy2015c01的U盘**（同题，巩固练习）

---

### 可视化代码片段（贪心动画）

```javascript
// 伪代码：Canvas绘制贪心过程
function drawFiles(sortedFiles) {
    sortedFiles.forEach((file, index) => {
        ctx.fillStyle = index === currentIndex ? 'yellow' : 'gray';
        ctx.fillRect(x, y, file.size * scale, 20);
        ctx.fillText(`v=${file.value}`, x, y + 15);
    });
}

function updateKnapsack(currentL) {
    let dp = new Array(S + 1).fill(0);
    for (let file of files.filter(f => f.size <= currentL)) {
        for (let j = S; j >= file.size; j--) {
            dp[j] = Math.max(dp[j], dp[j - file.size] + file.value);
            if (dp[S] >= p) {
                highlightL(file.size); // 高亮当前L为绿色
                return;
            }
        }
    }
}
```

---

### 总结
本题解通过对比贪心与二分策略，提炼出贪心的高效实现及二分的普适性。可视化设计强化了贪心策略的逐步验证过程，适合教学演示与交互学习。

---
处理用时：178.50秒
# 题目信息

# [NOIP 2015 提高组] 跳石头

## 题目背景

NOIP2015 Day2T1

## 题目描述

一年一度的“跳石头”比赛又要开始了！

这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。

为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。

## 说明/提示

### 输入输出样例 1 说明

将与起点距离为 $2$ 和 $14$ 的两个岩石移走后，最短的跳跃距离为 $4$（从与起点距离 $17$ 的岩石跳到距离 $21$ 的岩石，或者从距离 $21$ 的岩石跳到终点）。

### 数据规模与约定

对于 $20\%$的数据，$0 \le M \le N \le 10$。    
对于 $50\%$ 的数据，$0 \le M \le N \le 100$。  
对于 $100\%$ 的数据，$0 \le M \le N \le 50000,1 \le L 
 \le 10^9$。


## 样例 #1

### 输入

```
25 5 2 
2
11
14
17 
21```

### 输出

```
4```

# AI分析结果



---

## **综合分析与结论**

### **题解思路与核心难点**
本题需在给定移走最多M块岩石的限制下，最大化跳跃的最短距离。所有题解均采用**二分答案+贪心验证**的核心思路：
- **二分范围**：最短跳跃距离的可能范围为`[1, L]`。
- **贪心验证**：对于每个猜测值`mid`，模拟跳跃过程，统计需移走的岩石数。若岩石数≤M，则`mid`可行，尝试更大的值；否则缩小范围。

**难点与解决**：
1. **确定二分可行性**：通过分析问题满足单调性（若x可行则≤x均可行），确认二分适用。
2. **正确实现验证函数**：贪心策略为保留当前岩石，仅当距离不足时移走下一块，确保最优选择。
3. **边界处理**：终点需显式加入岩石数组，避免漏判最后一步到终点的距离。

---

### **题解评分 (≥4星)**
1. **ShawnZhou (5星)**  
   - 思路清晰，详细解释二分原理与验证函数设计。  
   - 代码可读性强，变量命名规范，处理终点正确。  
   - 示例输入输出说明完整，适合教学参考。

2. **GZXUEXUE (4.5星)**  
   - 代码简洁，直接给出二分框架与验证函数。  
   - 注释明确，适合快速理解算法核心。  
   - 缺少详细思路解释，但实现正确。

3. **UNDERTALE_RS (4星)**  
   - 代码结构清晰，二分与验证函数分离。  
   - 总结中强调“最小最大”类问题通用解法，适合举一反三。  
   - 验证函数未显式处理终点，但通过循环至`n+1`间接解决。

---

### **最优思路与技巧提炼**
1. **二分答案框架**：
   ```cpp
   int l=1, r=L, ans=0;
   while(l<=r){
       int mid=(l+r)/2;
       if(check(mid)) ans=mid, l=mid+1;
       else r=mid-1;
   }
   ```
2. **贪心验证函数**：
   - 初始化`last=0`（起点），遍历岩石数组。
   - 若当前岩石与上一保留岩石距离`<mid`，移走当前岩石（计数+1）；否则更新`last`。
   ```cpp
   bool check(int mid){
       int cnt=0, last=0;
       for(int i=1; i<=n+1; i++){
           if(a[i]-last < mid) cnt++;
           else last = a[i];
       }
       return cnt <= m;
   }
   ```
3. **终点处理**：显式将终点加入数组末尾（`a[n+1]=L`），确保最后一步跳跃被计算。

---

### **同类型题目与算法套路**
- **常见题型**：最小值最大化、最大值最小化问题（如分割数组、资源分配）。
- **算法套路**：
  1. **二分答案**确定可能的最优解范围。
  2. **贪心/模拟验证**判断解是否可行。
- **类似题目**：
  1. [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182)  
  2. [P2440 木材加工](https://www.luogu.com.cn/problem/P2440)  
  3. [P3743 kotori的设备](https://www.luogu.com.cn/problem/P3743)

---

### **可视化与算法演示**
#### **贪心过程动画设计**
1. **像素风格界面**：
   - **岩石**：绿色方块，起点/终点用红色标记。
   - **跳跃距离**：黄色线条显示当前`mid`值，岩石间距以数字标注。
   - **移走岩石**：被移走的岩石变为灰色并播放“碎裂”音效。

2. **动态演示步骤**：
   - **Step 1**：显示当前二分范围`[l, r]`与猜测值`mid`。
   - **Step 2**：遍历岩石，高亮当前检查的岩石对。
   - **Step 3**：若距离不足，移走岩石并计数；否则保留并跳跃。
   - **Step 4**：更新二分范围，循环直至`l>r`。

3. **交互功能**：
   - **速度控制**：滑动条调节动画速度（0.5x~3x）。
   - **单步执行**：逐步观察二分与验证过程。
   - **音效提示**：成功跳跃（清脆音效）、移走岩石（碎裂声）、二分更新（电子音）。

#### **复古游戏化实现**
```javascript
// 示例代码：Canvas绘制岩石与跳跃线
function drawRock(x, isRemoved) {
    ctx.fillStyle = isRemoved ? "#808080" : "#00FF00";
    ctx.fillRect(x * scale, 100, 20, 20);
}

function drawJumpLine(start, end, isValid) {
    ctx.strokeStyle = isValid ? "#FFFF00" : "#FF0000";
    ctx.beginPath();
    ctx.moveTo(start*scale +10, 120);
    ctx.lineTo(end*scale +10, 120);
    ctx.stroke();
}
```

---

### **核心代码实现**
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int MAXN = 50005;
int L, N, M, a[MAXN];

bool check(int mid) {
    int cnt = 0, last = 0;
    for (int i = 1; i <= N + 1; i++) {
        if (a[i] - last < mid) cnt++;
        else last = a[i];
    }
    return cnt <= M;
}

int main() {
    cin >> L >> N >> M;
    for (int i = 1; i <= N; i++) cin >> a[i];
    a[N+1] = L; // 终点加入数组
    sort(a+1, a+N+1);

    int l = 1, r = L, ans = 0;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (check(mid)) {
            ans = mid;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

### **个人心得摘录**
- **边界陷阱**：未将终点加入数组会导致最后一个跳跃未被验证（多题解强调`a[n+1]=L`）。
- **二分模板选择**：`mid`计算与循环条件影响终止情况，需严格测试（如`l<=r`与`l<r`差异）。
- **贪心正确性**：移走下一块而非当前岩石，确保后续判断基于最新保留位置。

---
处理用时：89.94秒
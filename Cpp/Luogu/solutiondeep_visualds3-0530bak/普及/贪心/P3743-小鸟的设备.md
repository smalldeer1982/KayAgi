# 题目信息

# 小鸟的设备

## 题目背景

小鸟有 $n$ 个可同时使用的设备。


## 题目描述

第 $i$ 个设备每秒消耗 $a_i$ 个单位能量。能量的使用是连续的，也就是说能量不是某时刻突然消耗的，而是匀速消耗。也就是说，对于任意实数，在 $k$ 秒内消耗的能量均为 $k\times a_i$ 单位。在开始的时候第 $i$ 个设备里存储着 $b_i$ 个单位能量。

同时小鸟又有一个可以给任意一个设备充电的充电宝，每秒可以给接通的设备充能 $p$ 个单位，充能也是连续的，不再赘述。你可以在任意时间给任意一个设备充能，从一个设备切换到另一个设备的时间忽略不计。

小鸟想把这些设备一起使用，直到其中有设备能量降为  $0$。所以小鸟想知道，在充电器的作用下，她最多能将这些设备一起使用多久。

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq p\leq 100000$，$1\leq a_i,b_i\leq100000$。


## 样例 #1

### 输入

```
2 1
2 2
2 1000
```

### 输出

```
2.0000000000```

## 样例 #2

### 输入

```
1 100
1 1```

### 输出

```
-1 ```

## 样例 #3

### 输入

```
3 5
4 3
5 2
6 1```

### 输出

```
0.5000000000 ```

# AI分析结果



### 综合分析与结论

#### 核心算法思路
1. **二分答案**是主流解法，通过二分时间 t，验证总充电需求是否可满足。时间复杂度 O(n log(1e10))，精度控制是关键。
2. **贪心策略**尝试通过排序合并设备，但实现复杂且正确性需要严格证明，适用性有限。

#### 贪心选择策略分析（Ja50nY0un9 题解）
- **核心思路**：每次优先给当前可用时间最短的设备充电，合并设备能量需求，直到无法继续充电。
- **正确性证明**：数学推导表明优先充电时间短的设备不会劣于其他策略，通过合并设备等效处理全局最优问题。
- **实现难点**：需维护优先队列或排序结构，动态合并设备状态。

#### 解决难点对比
| 方法       | 核心难点                          | 解决方式                               | 实现复杂度 |
|------------|-----------------------------------|----------------------------------------|------------|
| 二分答案   | 精度控制与验证函数正确性          | 设定合理精度阈值，分界点计算总充电需求 | 低         |
| 贪心       | 贪心策略的正确性证明与合并逻辑    | 数学推导设备合并等效性                | 高         |

---

### 题解评分（≥4星）

1. **qq1010903229（五星）**
   - 思路清晰，代码简洁，边界处理完善
   - 关键代码段：
     ```cpp
     int check(double ans) {
         double sum = 0;
         for (设备遍历) {
             if (需要充电) sum += 所需充电量;
         }
         return sum <= 充电宝总能量;
     }
     ```

2. **Ja50nY0un9_as_AgNO3（四星）**
   - 创新贪心思路，但代码可读性较弱
   - 关键排序逻辑：
     ```cpp
     sort(设备按 b[i]/a[i] 升序);
     ```

3. **一架飞机（四星）**
   - 标准二分实现，注释详细，适合教学
   - 核心二分循环：
     ```cpp
     while (r - l > 1e-6) {
         mid = (l + r) / 2;
         if (check(mid)) l = mid;
         else r = mid;
     }
     ```

---

### 最优思路提炼

1. **二分答案**
   - **核心公式**：总充电需求 Σ(max(0, a_i*t - b_i)) ≤ p*t
   - **精度控制**：设定 1e-6 级别阈值，循环次数约 50 次即可保证精度
   - **特判处理**：Σa_i ≤ p 时直接输出 -1

2. **贪心优化**
   - **排序策略**：按初始可用时间 (b_i/a_i) 升序排列
   - **合并逻辑**：将多设备等效为一个大设备，统一计算充电需求

---

### 同类型题与算法套路

1. **二分答案应用场景**
   - 最大化最小值/最小化最大值问题（如：跳石头、砍树问题）
   - 连续值验证问题（如：本题充电时间验证）

2. **贪心典型问题**
   - 区间调度（选择最多不重叠区间）
   - 霍夫曼编码（最小带权路径和）
   - 加油站问题（环形加油最少次数）

---

### 推荐相似题目
1. **P1182 数列分段 Section II**（二分最小段和）
2. **P1083 借教室**（二分+差分验证）
3. **P1230 智力大冲浪**（贪心+时间窗口调度）

---

### 可视化与算法演示设计

#### 二分答案动画方案
1. **颜色标记**：
   - 红色：当前二分区间 [l, r]
   - 绿色：已验证可行的时间 t
   - 黄色：正在验证的 mid 值

2. **步进控制**：
   - 单步显示 mid 计算和 check 过程
   - 动态更新设备充电需求柱状图，标红超出部分

3. **复古像素风格**：
   - 设备用不同颜色方块表示，高度对应 a_i 和 b_i
   - 充电宝能量条随二分过程动态增减

#### 贪心策略演示
1. **合并动画**：
   - 设备按 b_i/a_i 升序排列，逐个合并
   - 显示合并后的等效 a 和 b 值

2. **音效设计**：
   - 正确合并：8-bit 上升音效
   - 充电不足：短促警报声

---

### 关键代码片段（二分答案）

```cpp
bool check(double t) {
    double need = 0;
    for (int i = 1; i <= n; i++) {
        if (a[i] * t > b[i])
            need += a[i] * t - b[i];
    }
    return need <= p * t;
}

double l = 0, r = 1e10;
while (r - l > 1e-6) {
    double mid = (l + r) / 2;
    check(mid) ? l = mid : r = mid;
}
printf("%.10lf", l);
```

---

### 总结
本题以二分答案为主流解法，贪心策略存在理论价值但实现复杂。推荐优先掌握二分法，理解其精度控制与验证函数设计，适用于大多数最优化问题场景。

---
处理用时：68.02秒
# 题目信息

# [USACO18FEB] Rest Stops S

## 题目描述

Farmer John 和他的私人教练 Bessie 正在攀登温哥华山。为了他们的目的（以及你的目的），这座山可以表示为一条长度为 $L$ 米的长直步道（$1 \leq L \leq 10^6$）。Farmer John 将以每米 $r_F$ 秒的恒定速度徒步（$1 \leq r_F \leq 10^6$）。由于他正在锻炼耐力，他不会在途中休息。

然而，Bessie 被允许在休息站休息，她可能会在那里找到一些美味的草。当然，她不能随便停下来！步道上有 $N$ 个休息站（$1 \leq N \leq 10^5$）；第 $i$ 个休息站距离步道起点 $x_i$ 米（$0 < x_i < L$），并且有一个美味值 $c_i$（$1 \leq c_i \leq 10^6$）。如果 Bessie 在第 $i$ 个休息站休息 $t$ 秒，她会获得 $c_i \cdot t$ 的美味单位。

当不在休息站时，Bessie 将以每米 $r_B$ 秒的固定速度徒步（$1 \leq r_B \leq 10^6$）。由于 Bessie 年轻且健康，$r_B$ 严格小于 $r_F$。

Bessie 希望最大化她摄入的美味草量。但她担心 Farmer John；她认为如果在徒步的任何时刻她在步道上落后于 Farmer John，他可能会失去继续前进的动力！

请帮助 Bessie 找到在确保 Farmer John 完成徒步的情况下，她能获得的最大总美味单位。

## 说明/提示

在这个例子中，Bessie 最优的策略是在 $x=7$ 的休息站休息 $7$ 秒（获得 $14$ 个美味单位），然后在 $x=8$ 的休息站再休息 $1$ 秒（获得 $1$ 个美味单位，总共 $15$ 个美味单位）。

## 样例 #1

### 输入

```
10 2 4 3
7 2
8 1```

### 输出

```
15```

# AI分析结果



---

### **综合分析与结论**

**题目思路**：  
Bessie需在确保不落后于Farmer John的前提下，在休息站停留以获得最大美味值。核心贪心策略是：每次选择当前剩余区间内**美味值最高且位置最远**的休息站，停留尽可能长时间，确保覆盖该点到下一个更优点的区间。

**贪心策略关键**：  
1. **按美味值降序处理**，优先选择高价值点。  
2. **位置递增约束**：确保每个新选点的位置严格大于之前所选点，以覆盖更长区间。  
3. **停留时间计算**：每个点的贡献为位置差 × 速度差 × 美味值，总和即最大收益。

**难点与解决**：  
- **贪心选择正确性**：需证明每次选择局部最优可导致全局最优。  
- **高效实现**：需在O(n log n)或O(n)时间完成，避免暴力枚举。

**可视化设计**：  
- **动画方案**：展示每个休息站被选中时的覆盖区间，高亮当前最优点，动态显示停留时间计算。  
- **复古像素风**：用色块表示休息站，颜色深浅对应美味值，移动小人表示Bessie和Farmer John。  
- **交互功能**：步进控制、速度调节，音效提示选中高价值点。

---

### **题解清单 (≥4星)**

1. **木木！的题解 (5星)**  
   - **亮点**：使用单调队列维护递减美味值，线性时间复杂度，代码简洁高效。  
   - **适用场景**：输入数据已按位置排序（否则需预排序，时间复杂度O(n log n)）。

2. **Lolierl的题解 (4星)**  
   - **亮点**：预处理后缀最大值数组，严格线性时间，适合L较小的情况。  
   - **适用场景**：L在可接受范围内（如≤1e6）。

3. **t14Zack的题解 (4星)**  
   - **亮点**：按美味值排序后处理位置递增点，思路直观，代码可读性强。  
   - **适用场景**：通用情况，实现简单。

---

### **最优思路与代码实现**

**核心贪心逻辑**：  
1. **排序**：按美味值降序排列，相同美味值时按位置降序。  
2. **筛选位置递增点**：遍历排序后的点，仅处理位置大于已选点的点。  
3. **计算贡献**：累加每个有效点的位置差 × 速度差 × 美味值。

**代码片段 (t14Zack)**：  
```cpp
sort(a+1, a+n+1, [](const node &a, const node &b) {
    return a.c > b.c || (a.c == b.c && a.x > b.x);
});
long long ans = 0, last_x = 0;
for (int i = 1; i <= n; i++) {
    if (a[i].x > last_x) {
        ans += (a[i].x - last_x) * (f - b) * a[i].c;
        last_x = a[i].x;
    }
}
```

**完整代码 (木木！)**：  
```cpp
#include <cstdio>
using namespace std;

int q[100005]; // 单调队列
int xi[100005], ci[100005];

int main() {
    int l, n, f, b;
    scanf("%d%d%d%d", &l, &n, &f, &b);
    for (int i = 1; i <= n; i++) scanf("%d%d", xi+i, ci+i);
    
    // 维护单调递减队列（按ci）
    int head = 0;
    for (int i = 1; i <= n; i++) {
        while (head && ci[i] >= ci[q[head]]) head--;
        q[++head] = i;
    }
    
    long long ans = 0, last = 0;
    for (int i = 1; i <= head; i++) {
        ans += (xi[q[i]] - last) * (f - b) * ci[q[i]];
        last = xi[q[i]];
    }
    printf("%lld", ans);
}
```

---

### **同类型题与拓展**

**通用贪心套路**：  
- **区间覆盖问题**：选择覆盖未覆盖区域中收益最大的区间。  
- **调度问题**：按结束时间或收益排序，选择不冲突的最优解。  

**推荐题目**：  
1. [P1230 智力大冲浪](https://www.luogu.com.cn/problem/P1230)  
2. [P1094 纪念品分组](https://www.luogu.com.cn/problem/P1094)  
3. [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)  

---

### **个人心得摘录**

- **调试教训**：必须开`long long`，三个int相乘可能溢出（多位题解作者强调）。  
- **顿悟点**：贪心无需严格证明每一步最优，但需保证后续选择不影响已选最优解。  

---

### **可视化与交互设计**

**动画方案**：  
1. **Canvas绘制**：横向表示步道，休息站用色块标记，颜色深浅表示美味值。  
2. **贪心过程**：高亮当前最大美味值点，覆盖其右侧区域至下一个更大点。  
3. **时间线对比**：显示Bessie和Farmer John的移动进度，动态计算停留时间。

**复古像素风设计**：  
- **颜色方案**：休息站用绿→红渐变表示美味值，路径为灰色网格。  
- **音效**：选中点时播放8-bit音效，背景音乐循环芯片风格曲目。  

**AI自动演示**：  
- 自动步进选择最优点，展示区间覆盖和贡献计算，支持暂停/继续。

---
处理用时：376.80秒
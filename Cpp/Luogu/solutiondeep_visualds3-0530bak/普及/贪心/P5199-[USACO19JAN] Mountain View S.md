# 题目信息

# [USACO19JAN] Mountain View S

## 题目背景

USACO 2019 年一月月赛银组第三题

## 题目描述

从农场里奶牛 Bessie 的牧草地向远端眺望，可以看到巍峨壮丽的山脉绵延在地平线上。山脉里由 $N$ 座山峰（$1≤N≤10^5$）。如果我们把 Bessie 的视野想象成 $xy$ 平面，那么每座山峰都是一个底边在 $x$ 轴上的三角形。山峰的两腰均与底边成 $45$ 度角，所以山峰的峰顶是一个直角。于是山峰 $i$ 可以由它的峰顶坐标 $(x_i,y_i)$ 精确描述。没有两座山峰有完全相同的峰顶坐标。

Bessie 尝试数清所有的山峰，然而由于它们几乎是相同的颜色，所以如果一座山峰的峰顶在另一座山峰的三角形区域的边界上或是内部，她就无法看清。

请求出 Bessie 能够看见的不同的山峰的峰顶的数量，也就是山峰的数量。

## 说明/提示

在这个例子中，Bessie 能够看见第一座和最后一座山峰。第二座山峰被第一座山峰掩盖了。

## 样例 #1

### 输入

```
3
4 6
7 2
2 5```

### 输出

```
2```

# AI分析结果



### 综合分析与结论

**题目核心**：将每个山峰的覆盖范围转化为左右端点区间，通过贪心策略统计不被其他区间包含的区间数量。正确性基于排序后的遍历中维护最大右端点，确保每个新出现的右端点更大的区间对应可见的山峰。

**算法要点**：
1. **转换问题**：每个山峰的覆盖范围为 `[x_i - y_i, x_i + y_i]`。
2. **排序策略**：按左端点升序排序，左端点相同则按右端点降序排列。
3. **贪心遍历**：维护当前最大右端点，若当前区间右端点更大，则计数并更新最大值。

**难点与解决**：
- **正确性推导**：排序确保后续区间左端点更大，只需比较右端点是否超过当前最大值，避免被前面的区间覆盖。
- **时间复杂度**：排序 `O(n log n)`，遍历 `O(n)`，适用于 `1e5` 的数据量。

### 题解清单（评分≥4星）

1. **Alex_Wei（5星）**  
   **亮点**：代码简洁高效，思路清晰，正确性推导详细。通过排序与维护右端点最大值实现贪心策略。  
   **核心代码**：
   ```cpp
   sort(m + 1, m + n + 1, cmp); // 按左端点升序、右端点降序排序
   for (int i = 1; i <= n; i++) {
       if (m[i].r > max_r) {
           count++;
           max_r = m[i].r;
       }
   }
   ```

2. **Rbu_nas（4星）**  
   **亮点**：代码结构清晰，离散化处理确保数据范围可控，与Alex思路一致。  
   **核心思想**：将区间端点离散化后排序，通过树状数组优化覆盖判断。

3. **一只书虫仔（4星）**  
   **亮点**：问题转换明确，贪心策略与Alex一致，代码简洁易读。  
   **关键点**：将问题转化为区间覆盖问题，排序后遍历统计。

### 最优思路提炼

**贪心策略**：
1. **排序**：按左端点升序，右端点降序排列。确保在处理每个区间时，左端点已尽可能小，且同一左端点下右端点最大的优先处理。
2. **遍历维护**：维护当前最大右端点 `max_r`。若当前区间的右端点 `> max_r`，则可见，更新 `max_r`。

**正确性保障**：
- 排序后，后续区间的左端点不小于当前区间，若其右端点更大，则不会被前面的区间覆盖。
- 同一左端点的区间，右端点大的优先处理，避免被后续更小的右端点覆盖。

### 同类型题推荐

1. **P1803 线段覆盖**：经典区间调度问题，贪心选择最早结束的线段。
2. **P2240 部分背包问题**：按单位价值贪心选择物品。
3. **P1223 排队接水**：贪心安排最小等待时间。

### 个人心得摘录

- **调试教训**：需注意排序规则的正确性，尤其是同一左端点时的右端点处理。
- **思维突破**：将几何问题转化为区间覆盖，极大简化了判断逻辑。

### 可视化与算法演示设计

**贪心过程动画方案**：
1. **像素风格界面**：用不同颜色方块表示每个区间，当前处理区间高亮为红色，最大右端点区间标记为蓝色。
2. **步进控制**：支持暂停/继续、单步执行，速度可调。
3. **音效反馈**：
   - 计数增加时播放“上升音效”。
   - 更新 `max_r` 时播放“确认音效”。
4. **动态比较**：可对比不同排序策略（如仅按左端点排序）的错误结果。

**复古游戏化设计**：
- **8位音效**：使用芯片音乐风格音效增强沉浸感。
- **积分系统**：每正确识别一个可见山峰得10分，连击加倍。

---

### 代码实现（Alex_Wei解法）

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Node { int l, r; };
Node m[100100];
int n, max_r, count;

bool cmp(Node a, Node b) {
    return a.l < b.l || (a.l == b.l && a.r > b.r);
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int x, y; cin >> x >> y;
        m[i].l = x - y;
        m[i].r = x + y;
    }
    sort(m + 1, m + n + 1, cmp);
    for (int i = 1; i <= n; i++) {
        if (m[i].r > max_r) {
            count++;
            max_r = m[i].r;
        }
    }
    cout << count;
    return 0;
}
```

**核心思想**：通过排序确保遍历顺序，贪心维护最大右端点，统计可见山峰数。时间复杂度 `O(n log n)`。

---
处理用时：121.34秒
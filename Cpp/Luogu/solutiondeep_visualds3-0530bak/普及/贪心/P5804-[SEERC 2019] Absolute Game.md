# 题目信息

# [SEERC 2019] Absolute Game

## 题目描述

Alice 和 Bob 在玩一个游戏。Alice 有一个包含 $n$ 个整数的数列 $a$，Bob 有一个包含 $n$ 个整数的数列 $b$。每一回合中，玩家需要从他的数列中删去一个数字。玩家轮流进行回合，Alice 先手。

当两个数列中都只剩下一个数字的时候，游戏结束。令 Alice 的数列剩下的数字为 $x$，Bob 的数列剩下的数字为 $y$。Alice 想要最大化 $x$ 与 $y$ 之差的绝对值，而 Bob 想最小化这个值。两个玩家都以最优策略游戏。

请算出游戏结束时的结果。

## 说明/提示

第一个样例中，$x=14, y=10$，因此两个数之差为 $4$。

第二个样例中，两个数列都只剩下一个数字了，因此 $x=14, y=42$。

## 样例 #1

### 输入

```
4
2 14 7 14
5 10 9 22```

### 输出

```
4```

## 样例 #2

### 输入

```
1
14
42```

### 输出

```
28```

# AI分析结果



# 唯一算法分类  
**博弈论（极大极小问题）**

---

## 题解思路、算法要点与解决难点  

### 核心思路  
- **问题本质**：Alice 和 Bob 的博弈可简化为 Alice 选择一个数 $a_i$，Bob 必须选择使得 $|a_i - b_j|$ 最小的 $b_j$。Alice 的目标是在这些最小差值中选择最大值。  
- **关键证明**：无论 Alice 如何删除其他数，Bob 总能保留与 $a_i$ 最接近的 $b_j$，最终结果等价于枚举每个 $a_i$ 的最小可能差值，取最大值。  

### 算法实现  
1. **暴力枚举**：对每个 $a_i$，遍历所有 $b_j$ 计算差值，时间复杂度 $O(n^2)$。  
2. **二分优化**：先对 $b$ 排序，对每个 $a_i$ 用二分查找最近元素，时间复杂度 $O(n \log n)$。  

### 解决难点  
- **博弈策略推导**：需理解双方最优策略的相互作用，转化为数学上的极大极小问题。  
- **高效实现**：排序后二分可显著优化时间，需正确处理边界条件（如查找位置越界）。  

---

## 题解评分（≥4星）  

1. **Miraik（5星）**  
   - **亮点**：通过排序和二分优化到 $O(n \log n)$，代码简洁高效，附带构造性证明。  
   - **代码**：清晰处理边界条件（`j <= n` 和 `j > 1`）。  

2. **pomelo_nene（4星）**  
   - **亮点**：详细解释策略正确性，提供暴力实现和外部证明链接。  
   - **心得**：提到“最小值一一对应”和“非一一对应”两种情况的处理。  

3. **Tjaweiof（4星）**  
   - **亮点**：直接暴力枚举，代码极简，适合小数据量。  
   - **心得**：明确“暴力枚举最后的两个数”的可行性。  

---

## 最优思路或技巧提炼  

1. **极大极小模型**：Alice 最大化最小值，Bob 最小化当前差值，转化为 `max(min)` 问题。  
2. **预处理优化**：对 $b$ 数组排序后，利用二分查找快速定位最近元素。  
3. **边界处理**：检查二分结果的前后元素，避免越界并确保最小差值。  

---

## 同类型题与算法套路  

- **类似问题**：博弈论中的“取石子游戏”、棋盘游戏中的最优策略选择。  
- **通用解法**：将双方交替决策转化为静态的极大极小模型，预处理优化计算。  

---

## 推荐题目  
1. **P1288** 取数游戏：双方交替取数，求最优策略下的最大值差。  
2. **P1488** 括号序列：博弈中的最优括号匹配。  
3. **P2123** 皇后游戏：贪心策略与极大极小结合。  

---

## 个人心得摘录  
- **Miraik**：通过构造性证明，将动态删数过程简化为静态选择问题。  
- **Sirkey**：强调“先手优势”，从 Alice 视角选择最差中的最优。  

---

## 可视化与算法演示  

### 核心流程  
1. **初始化**：展示数组 $a$ 和 $b$，用不同颜色区分。  
2. **枚举 $a_i$**：高亮当前 $a_i$，在 $b$ 中标记最近元素，计算差值。  
3. **更新结果**：动态显示当前最大值，最终突出最大差值。  

### 复古像素风格设计  
- **颜色方案**：  
  - Alice 数组：蓝色像素块  
  - Bob 数组：红色像素块  
  - 当前选中元素：黄色边框  
  - 最小差值连线：绿色线条  
- **音效**：  
  - 选中元素时播放“滴”声  
  - 找到最大值时播放胜利音效  
- **Canvas 动画**：网格布局展示数组，动态绘制连线和数值。  

### 交互设计  
- **步进控制**：手动点击切换 $a_i$，自动播放间隔可调。  
- **AI 演示**：自动遍历所有 $a_i$，展示最优选择过程。  

---

## 核心代码实现  

### 二分优化（Miraik）  
```cpp
sort(a+1, a+n+1); sort(b+1, b+n+1);
for(int i=1; i<=n; i++){
    int j = lower_bound(b+1, b+n+1, a[i]) - b;
    int c = inf;
    if(j <= n) c = min(c, b[j] - a[i]);
    if(j > 1) c = min(c, a[i] - b[j-1]);
    ans = max(ans, c);
}
```

### 暴力枚举（Tjaweiof）  
```cpp
for(int i=1; i<=n; i++){
    int tmp = 2147483647;
    for(int j=1; j<=n; j++) 
        tmp = min(tmp, abs(a[i]-b[j]));
    ans = max(ans, tmp);
}
```

---

**可视化代码片段（JS）**  
```javascript
// 绘制数组和连线（Canvas）
function draw() {
    ctx.clearRect(0, 0, width, height);
    // 绘制 a 数组（蓝色）
    aArray.forEach((val, idx) => { /* ... */ });
    // 绘制 b 数组（红色）
    bArray.forEach((val, idx) => { /* ... */ });
    // 高亮当前 a[i] 和最近的 b[j]
    ctx.strokeStyle = 'yellow';
    ctx.strokeRect(aX, aY, BLOCK_SIZE, BLOCK_SIZE);
    // 绘制绿色连线
    ctx.beginPath();
    ctx.moveTo(aX + BLOCK_SIZE/2, aY + BLOCK_SIZE);
    ctx.lineTo(bX + BLOCK_SIZE/2, bY);
    ctx.strokeStyle = 'green';
    ctx.stroke();
}
```

---
处理用时：89.23秒
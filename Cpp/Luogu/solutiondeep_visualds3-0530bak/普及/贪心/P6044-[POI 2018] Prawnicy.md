# 题目信息

# [POI 2018] Prawnicy

## 题目背景

**题目译自 [POI XXV - I etap](https://sio2.mimuw.edu.pl/c/oi25-1/dashboard/) 「[Prawnicy](https://sio2.mimuw.edu.pl/c/oi25-1/p/pra/)」**

## 题目描述

“Bajtazar 父子”律师事务所刚刚收到一位非常重要的客户的订单。案件严重、紧急，需要与律师事务所的律师举行会议。每个律师都有一段固定的空闲时间可以参加会议。你应该选择这样的 $k$ 位律师，以便召开会议的时间（即他们都空闲的时间）尽可能长。

[简要题意](https://www.luogu.com.cn/problem/U252799)

## 说明/提示

#### 样例解释

三位律师会议可能的最大时长是 $4$。编号为 $1$、$2$ 和 $4$ 的律师可以参加，持续时间从 $4$ 到 $8$。另一个同样好的方案是让编号为 $2$、$4$ 和 $5$ 的律师参加，持续时间从 $5$ 到 $9$。

![](https://cdn.luogu.com.cn/upload/image_hosting/187yuqy1.png)

#### 附加样例

参见 `pra/pra*.in` 和 `pra/pra*.out`：

- 附加样例 $1$：$1$ 组数据，$n=7$，$k=3$，且选择律师的方案有两种。

- 附加样例 $2$：$1$ 组数据，$n=k=1000$，$a_i=i$，$b_i=10^6+i$；

- 附加样例 $3$：$1$ 组数据，$n=1000$，$k=1$，$a_i=2i-1$，$b_i=2i$；

#### 数据范围与提示

测试集分为以下子任务。每个子任务的测试由一个或多个单独的测试组组成。

| Subtask # | 额外限制                         | 分值  |
|:---------:|:----------------------------:|:---:|
| $1$         | $n\le 20$       | $20$  |
| $2$         | $n\le 300$，$a_i,b_i\le 300$      | $15$  |
| $3$         | $n\le 5000$       | $15$  |
| $4$         | $n\le 10^6$，$k\in \{1,n\}$       | $15$  |
| $5$         | $n\le 10^6$       | $35$  |

如果你的程序在第一行输出了正确的时长，但其余的输出是错误的，那么你将获得 $40\%$ 的分数。

## 样例 #1

### 输入

```
6 3
3 8
4 12
2 6
1 10
5 9
11 12
```

### 输出

```
4
1 2 4
```

# AI分析结果



### 综合分析与结论

#### 核心贪心思路与难点
1. **贪心策略**：将线段按左端点升序排序，遍历时维护一个大小为 k 的小根堆存储右端点。堆顶为当前 k 个线段的最小右端点，交集长度为 `堆顶 - 当前左端点`。动态更新最大值。
2. **正确性证明**：排序后左端点单调递增，每次堆维护的是当前最小的右端点，确保交集尽可能长。
3. **难点**：如何高效维护右端点集合，并在遍历过程中快速判断最优解。优先队列的 O(n log k) 复杂度是关键优化点。

#### 可视化设计思路
- **动画演示**：展示线段排序过程，堆的动态调整（弹出/压入），当前交集区间高亮。
- **颜色标记**：当前处理线段用红色，堆内线段用绿色，历史最优解用蓝色边框。
- **复古风格**：8-bit 像素化线段，堆操作时播放经典音效（压入：短促“滴”，弹出：低沉“嘟”），背景音乐循环 8-bit 风格旋律。
- **步进控制**：用户可单步执行，观察堆大小变化与最优解更新逻辑。

---

### 题解清单 (≥4星)

1. **longlinyu7（5星）**
   - 亮点：代码简洁，注释清晰，维护最大交集的同时记录左右端点，最后线性扫描输出结果。
   - 关键代码片段：
     ```cpp
     sort(a+1,a+1+n,cmp);
     for(int i=1;i<=n;i++){
         r.push(a[i].y);
         if(r.size()>k) r.pop();
         if(r.size()==k && r.top()-a[i].x>tim){
             tim=r.top()-a[i].x;
             head=a[i].x; tail=r.top();
         }
     }
     ```

2. **Je_son（4星）**
   - 亮点：详细图解说明，强调左端点排序的必然性，代码结构规范。
   - 个人心得：“线段的右端点是最大交集的关键限制因素”直观展示了贪心核心。

3. **JackMerryYoung（4星）**
   - 亮点：引入“尺取法”对比，强调贪心与堆维护的结合，代码变量命名清晰。
   - 关键优化：结构体排序时优先处理右端点较大的线段，减少无效比较。

---

### 最优思路提炼

#### 核心步骤
1. **排序**：所有线段按左端点升序（相同则右端点升序）。
2. **堆维护**：小根堆存储右端点，保持堆大小为 k。
3. **动态更新**：每次堆满时计算 `堆顶 - 当前左端点`，记录最大值及对应区间。
4. **结果筛选**：二次遍历选择包含最优区间的线段。

#### 关键技巧
- **堆的筛选机制**：通过弹出较小右端点，确保剩余线段右端点尽可能大。
- **线性复杂度**：排序 O(n log n) + 堆操作 O(n log k)，整体 O(n log n)。

---

### 同类型题与算法套路

#### 通用贪心策略
- **区间选择**：通过排序+堆维护极值，如「最大重叠区间」「最小会议室数」。
- **离线处理**：对事件按时间排序后贪心决策。

#### 推荐题目
1. **P1803 线段覆盖**：选择不重叠的最大线段数。
2. **P1230 智力大冲浪**：贪心+堆处理时间冲突。
3. **P4059 找爸爸」：动态规划与贪心结合的区间处理。

---

### 代码核心实现

#### 结构体排序与堆维护
```cpp
struct node{ int x,y,num; }a[N];
bool cmp(node a,node b){ return a.x==b.x?a.y<b.y:a.x<b.x; }

priority_queue<int,vector<int>,greater<int>> q;

sort(a+1, a+1+n, cmp);
for(int i=1; i<=n; i++){
    q.push(a[i].y);
    if(q.size()>k) q.pop();
    if(q.size()==k && q.top()-a[i].x > ans){
        ans = q.top() - a[i].x;
        l = a[i].x; r = q.top();
    }
}
```

#### 结果输出逻辑
```cpp
for(int i=1; i<=n && k; i++){
    if(a[i].x<=l && a[i].y>=r){
        cout<<a[i].num<<" ";
        k--;
    }
}
```

---

### 复古游戏化动画设计

#### Canvas 绘制
- **线段表示**：每个线段为横向像素条，左端点 x 坐标映射为横轴位置，长度与区间长度成正比。
- **堆可视化**：右侧显示小根堆结构，节点为右端点值，动态调整时播放音效。

#### 音效触发
- **压入堆**：`1UP` 音效（NES 风格）。
- **弹出堆**：`coin` 音效（马里奥金币声）。
- **更新最优解**：`power-up` 音效（强化道具声）。

#### 关卡设计
- **教学关**：3 线段 k=2，手动操作堆。
- **挑战关**：随机生成线段，自动演示贪心过程，用户预测结果得分。

---

### 个人心得摘录

- **zhangliyuan111**：特判交集为0时输出任意k个线段，避免遗漏边界条件。
- **KohaD_SEGA**：结构体排序优先处理右端点较大者，减少无效弹出操作。
- **调试教训**：未记录线段原始编号导致输出错误，需在排序前保存编号。

---

通过上述分析与实现，该问题的贪心策略得以高效解决，结合可视化与游戏化设计可显著提升学习体验。

---
处理用时：63.84秒
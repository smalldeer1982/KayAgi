# 题目信息

# [NOI Online #2 入门组] 未了

## 题目描述

由于触犯天神，Sisyphus 将要接受惩罚。

宙斯命 Sisyphus 推一块巨石上长度为 $L$ 的山坡。Sisyphus 匀速向上推的速度为每年 $v$ 的长度（由于是匀速，故经过 $\frac{1}{2}$ 年将能向上推 $\frac{v}{2}$ 的长度）。然而，宙斯并不希望 Sisyphus 太快到达山顶。宙斯可以施展 $n$ 个魔法，若宙斯施展第 $i$ 个魔法 $(1\leq i \leq n)$，则当 Sisyphus 第一次到达位置  $a_i$ 时，他将会同巨石一起滚落下山底，并从头推起。（滚落的时间忽略不计，即可看作第一次到达位置 $a_i$ 后 Sisyphus 立即从山底重新出发）

例如宙斯施用了 $a_i=3$ 和 $a_i=5$ 的两个魔法。Sisyphus 的速度 $v=1$ ，山坡的长度 $L = 6$，则他推石上山过程如下：

- 用 $3$ 年走到位置 $3$。

- 受 $a_i=3$ 的魔法影响，回到了山底出发。

- 再用 $3$ 年走到位置 $3$，然而因为是第二次到达，$a_i=3$ 的魔法不起作用。

- 用 $2$ 年走到位置 $5$。

- 受 $a_i=5$ 的魔法影响，回到了山底出发。

- 用 $6$ 年从山底走到了山顶。花费的总时间为 $14$ 年。

现在，宙斯有 $q$ 个询问。对于第 $i$ 个询问 $t_i$，宙斯想知道，他最少需要施展多少个魔法才能使 Sisyphus 到达山顶所用的年数大于 $t_i$

## 说明/提示

1. 不使用任何魔法，Sisyphus 需要 $2$ 年走上山顶。
2. 使用魔法 $2$ ，Sisyphus 需要 $\frac{11}{3}$ 年走上山顶。（用时 $\frac{5}{3}$ 年走到魔法 $2$ 的位置并滚落下山，再用时 $\frac{6}{3}=2$ 年走到山顶）
3. 使用魔法 $1,2$ ，Sisyphus 需要 $\frac{14}{3}$ 年走上山顶。
4. 宙斯不能使 Sisyphus 用大于 $5$ 年的时间走上山顶。

对于测试点 $1\sim 8:n=1$。

对于测试点 $9\sim 12:n=2$。

对于测试点 $13\sim 17:n,q\le 1000$。

对于所有测试点：$1 \leq n,q \leq 2 \times 10^5$，$1\leq v\leq L\leq 10^{9}$，$1\leq a_i < L$，$1 \leq t_i\leq 10^9$。

数据保证 $a_i$ 两两不同。

## 样例 #1

### 输入

```
3 6 3
3 5 1
4
1
3
4
5
```

### 输出

```
0
1
2
-1
```

# AI分析结果



### 综合分析与结论

**核心思路**：将魔法按触发位置从大到小排序，计算前缀和表示使用前i个魔法增加的总路程。通过二分查找确定最少使用魔法次数，使得总路程 > t_i * v - L。

**贪心策略**：优先选择距离山顶更远的魔法（触发位置更大），每个魔法贡献的无效路程最大，符合贪心最优子结构性质。

**难点解决**：
1. 正确推导总路程公式 `L + sum(selected_a) > t_i * v`
2. 避免浮点精度问题：将时间比较转化为整数路程比较
3. 处理边界条件（无魔法可用时输出-1）

**可视化设计**：
- **动画方案**：展示排序后的魔法柱状图，前缀和逐步累加。二分查找时高亮中间点，对比目标值。
- **复古像素风格**：用8-bit色块表示魔法值，触发时显示滚落动画，背景播放FC风格BGM。
- **交互设计**：允许拖动时间轴查看不同t_i对应的二分过程，音效提示查找成功/失败。

---

### 题解清单（评分≥4星）

1. **chen_zhe（★★★★★）**  
   - 关键亮点：STL upper_bound简洁高效，前缀和预处理清晰，整数运算避免精度问题。
   - 代码片段：
     ```cpp
     sort(a+1,a+n+1,cmp);
     for(int i=1;i<=n;i++) s[i] = s[i-1] + a[i];
     ans = upper_bound(s+1, s+n+1, t*v - L) - s;
     ```

2. **云浅知处（★★★★☆）**  
   - 关键亮点：强调路程转化思路，详细注释帮助理解，处理了浮点比较的特殊情况。
   - 核心代码：
     ```cpp
     for(int i=1;i<=n;i++) s[i] = (s[i-1] + a[i]);
     if(s[n] + L > t*v) cout << upper_bound(...);
     ```

3. **Mine_King（★★★★☆）**  
   - 关键亮点：手动二分实现，前缀和从0开始处理边界，变量命名直观。
   - 代码亮点：
     ```cpp
     while(l<r){
         if(s[mid] > t*v) r=mid; 
         else l=mid+1;
     }
     ```

---

### 核心代码实现

**整数运算版（避免浮点）**：
```cpp
sort(a, a+n, greater<int>());
long long prefix[n+1] = {L};
for(int i=0; i<n; i++) 
    prefix[i+1] = prefix[i] + a[i];

int query(long long t) {
    long long target = t * v;
    if(prefix[0] > target) return 0;
    if(prefix[n] <= target) return -1;
    return upper_bound(prefix, prefix+n+1, target) - prefix;
}
```

---

### 同类型题目推荐
1. **P1090 [NOIP2004 提高组] 合并果子** - 贪心+优先队列  
2. **P1223 [贪心] 排队接水** - 排序使平均等待时间最小  
3. **P1803 [线段覆盖问题]** - 选择最多不重叠区间

---

### 可视化代码片段（Canvas动画）

```javascript
// 绘制排序后的魔法柱状图
function drawBars(a) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    a.forEach((val, i) => {
        ctx.fillStyle = i <= currentK ? '#FF5555' : '#8888FF';
        ctx.fillRect(i*30, 200 - val/5, 25, val/5);
    });
}

// 二分查找动画
function animateBinarySearch(target) {
    let L=0, R=n, mid;
    while(L <= R) {
        mid = Math.floor((L+R)/2);
        highlightBar(mid); // 高亮当前检查的柱子
        if(prefix[mid] > target) R = mid-1;
        else L = mid+1;
        await sleep(1000);
    }
    return L;
}
```

---

### 个人心得摘录

> "考试时被n=2e5吓到，突然意识到O(nq)必超时，灵光一闪想到前缀和+二分，那一刻仿佛听到系统提示音『贪心技能+1』" —— pengyule

**启示**：面对大数据量时，先分析暴力解法复杂度，再寻找数学性质（如单调性）进行优化。

---

### 复古游戏化设计

1. **像素风格**：魔法值用不同高度砖块表示，山顶为8-bit城堡图案。
2. **音效设计**：
   - 选择魔法时：FC风格“金币声”
   - 二分命中：经典马里奥跳跃音
   - 查找失败：魂斗罗死亡音效
3. **自动演示模式**：AI控制左右移动选择魔法，进度条显示总路程增长过程。

**交互示例**：  
![](https://fakeurl.com/8bit-demo.gif)  
（伪代码示例：贪心策略逐步点亮魔法柱，目标线动态调整）

---
处理用时：68.27秒
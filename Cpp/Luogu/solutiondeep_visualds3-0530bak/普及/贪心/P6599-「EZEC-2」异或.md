# 题目信息

# 「EZEC-2」异或

## 题目描述

有 $T$ 组询问，每次给定两个正整数 $n,l$，   

你需要构造一个长度为 $l$ 的正整数序列 $a$（编号从 $1$ 至 $l$），   

且满足 $\forall i\in[1,l]$，都有 $a_i\in[1,n]$。

求：

$$\sum_{i=1}^l\sum_{j=1}^{i-1}a_i\oplus a_j$$

的最大值。

为了避免答案过大，对于每组询问，只需要输出这个最大值对 $10^9+7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**   
当 $n=2,l=3$，$a$ 取 $\{1,2,1\}$ 的任一排列时可以得到最大值，为 $(1\oplus2)+(1\oplus1)+(2\oplus1)=6$，易证明此时原式有最大值。

---
**【数据规模与约定】**
| 测试点编号 | $T\le$ | $n\le$ | $l\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim5$ | $1$ | $10$ | $5$ |
| $6$ | $5\times 10^5$ | $10^{12}$ | $2$ |
| $7$ | $5\times 10^5$ | $10^{12}$ | $3$ |
| $8\sim10$ | $5\times 10^5$ | $10^{12}$ | $10^5$ |

对于 $100\%$ 的数据，满足 $1\le T\le 5\times10^5$，$1\le n\le 10^{12}$，$2\le l \le 10^5$。


---
**【提示】**

1. 「$\oplus$」是按位异或符号。如果您不知道什么是按位异或，可以参考[这里](https://oi-wiki.org/math/bit/#_1)。
2. 取模是一种运算，$a$ 对 $b$ 取模代表将 $a$ 赋值为 $a$ 除以 $b$ 所得到的余数。  
在 C++ / Python 中的取模符号为 `%`，在 Pascal 中的取模符号为 `mod`。
3. $\sum$ 是求和符号。如果您不知道什么是 $\sum$ 符号，可以参考[这里](https://baike.baidu.com/item/∑/1233796?fr=aladdin)。
4. 请注意数据的读入输出对程序效率造成的影响。

## 样例 #1

### 输入

```
1
2 3
```

### 输出

```
6```

## 样例 #2

### 输入

```
2
114 514
1919 180
```

### 输出

```
8388223
16580700```

# AI分析结果



### 综合分析与结论

**题目核心**：构造长度为 $l$ 的序列，使所有两两异或和最大。  
**核心贪心策略**：按二进制位独立处理，每位尽可能使 1 和 0 的数量接近 $\frac{l}{2}$，从而最大化该位贡献。  
**难点**：验证贪心策略的正确性，处理大数范围下的位运算与快速求和。

---

### 题解评分（≥4星）

1. **dead_X（5星）**  
   - **亮点**：完整数学推导，构造性证明，代码简洁高效。  
   - **关键点**：通过按位分析，验证每位贡献最大化条件，并构造具体数值组合（最高位与次高位交替）。

2. **李白莘莘学子（4.5星）**  
   - **亮点**：详细分步解析，数学证明与代码结合，适合新手理解。  
   - **代码**：逐位遍历并累加贡献，特判处理清晰。

3. **do_while_true（4星）**  
   - **亮点**：二次函数极值推导，反证法验证最优性。  
   - **优化**：通过位运算快速计算最高位权值。

---

### 最优思路提炼

1. **按位独立分析**  
   - 异或运算的每一位贡献独立，总和为各二进制位贡献之和。  
   - **贡献公式**：$2^k \times x \times (l - x)$，其中 $x$ 为 1 的数量。

2. **最大化每位的贡献**  
   - 当 $x = \lfloor \frac{l}{2} \rfloor$ 时，$x \times (l - x)$ 最大。  
   - **构造方法**：高位取 $2^p$，剩余位取 $2^p - 1$，保证数值合法且每位 1/0 数量平衡。

3. **快速求和技巧**  
   - 总贡献为 $(2^{\lfloor \log_2 n \rfloor + 1} - 1) \times \lfloor \frac{l}{2} \rfloor \times (l - \lfloor \frac{l}{2} \rfloor)$。  
   - **特判**：$n=1$ 时所有异或结果为 0。

---

### 同类型题目与算法套路

- **通用贪心场景**：位运算最大化、区间调度、最小生成树（Kruskal）。  
- **相似题目**：  
  - [P2114 起床困难综合症](https://www.luogu.com.cn/problem/P2114)（位运算贪心）  
  - [P6102 谔运算](https://www.luogu.com.cn/problem/P6102)（异或和最大化）  
  - [P2217 分割矩阵](https://www.luogu.com.cn/problem/P2217)（分治与贪心）

---

### 推荐代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 1e9 + 7;

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        ll n, l; scanf("%lld%lld", &n, &l);
        if (n == 1) { printf("0\n"); continue; }
        ll t = l / 2;
        ll ans = t * (l - t) % MOD;
        ll sum = 0, bit = (1LL << 40);
        while (bit) {
            bit >>= 1;
            if (n >= bit) sum = (sum + bit) % MOD;
        }
        printf("%lld\n", ans * sum % MOD);
    }
    return 0;
}
```

**核心逻辑**：  
1. 计算每位的最大贡献总和 `sum`（即 $2^{\lfloor \log_2 n \rfloor + 1} - 1$）。  
2. 计算 $\lfloor \frac{l}{2} \rfloor \times (l - \lfloor \frac{l}{2} \rfloor)$。  
3. 结果取模相乘。

---

### 可视化与游戏化设计

1. **贪心过程动画**  
   - **像素风格**：用 8-bit 像素块表示二进制位，绿色为 1，红色为 0。  
   - **动态调整**：滑动条控制 $l$，实时显示每位 1/0 数量平衡过程。  
   - **音效**：每次平衡成功播放上升音效，总贡献更新时播放胜利音效。

2. **AI 自动演示**  
   - **自动遍历**：从最高位到最低位，自动填充 1/0 数量到 $\frac{l}{2}$。  
   - **积分系统**：每正确平衡一位得 10 分，错误扣 5 分。

3. **Canvas 交互示例**  
   ```javascript
   // 伪代码：绘制二进制位贡献
   function drawBit(bit, x, total) {
       ctx.fillStyle = (x >= l/2) ? '#00ff00' : '#ff0000';
       ctx.fillRect(bit * 20, 0, 15, x * 10);
       ctx.fillText(`2^${bit}贡献: ${x*(l-x)}`, bit*20, 20);
   }
   ```

---

### 个人心得摘录

- **Surge_of_Force**：通过暴力打表发现规律，验证了贪心策略的有效性。  
- **hanzhongtlx**：强调“猜结论”后对拍验证，适合竞赛快速解题。  
- **调试教训**：多位题解提到 `n=1` 的特判易漏，需优先处理。

---
处理用时：78.29秒
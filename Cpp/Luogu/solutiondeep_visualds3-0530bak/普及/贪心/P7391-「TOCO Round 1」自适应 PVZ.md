# 题目信息

# 「TOCO Round 1」自适应 PVZ

## 题目背景

爆切今天的毒瘤三维计算几何后，$\color{black}\texttt{Q}\color{red}\texttt{wQcOrZ}$ 打开了某个有趣的 exe 文件。

## 题目描述

可怜的 $\color{black}\texttt Q\color{red}\texttt{wQcOrZ}$ 在草坪上遇到了 $n$ 只僵尸，第 $i$ 只僵尸在 $l_i$ 时刻出现，会在 $r_i$ 时刻走进房子。

$\color{black}\texttt Q\color{red}\texttt{wQcOrZ}$ 手头有 $m$ 个豌豆射手。若一个豌豆射手在 $l_i$ 至 $r_i$ 时刻（不包括两个端点）持续攻击 $i$ 僵尸则可以杀死 $i$ 僵尸，但在攻击过程中不能攻击另外两只僵尸且攻击的僵尸不能更换。

现在 $\color{black}\texttt Q\color{red}\texttt{wQcOrZ}$ 想知道在合理的安排下，最少有几只僵尸会进入他的房子。

## 说明/提示

对于 $30\%$ 的数据，$n,m\leq 6$。  
对于 $60\%$ 的数据，$n,m\leq 10^3$。  
对于另外 $20\%$ 的数据，$m\geq n$。  
对于 $100\%$ 的数据，$1\leq n,m\leq 2\times 10^5$，$1\leq l_i<r_i\leq 10^9$。

## 样例 #1

### 输入

```
2 1
1 2
3 4```

### 输出

```
0```

## 样例 #2

### 输入

```
3 2
1 3
1 3
2 4```

### 输出

```
1```

## 样例 #3

### 输入

```
2 1
1 3
3 5```

### 输出

```
0```

# AI分析结果



### 题解思路与算法要点

#### 核心贪心策略
1. **排序策略**：按僵尸的右端点 $r_i$ 从小到大排序，确保优先处理结束时间早的僵尸，为后续腾出更多时间。
2. **数据结构选择**：使用 `multiset` 维护豌豆射手的可用时间（上次攻击结束时间），通过二分查找快速定位可用射手。
3. **贪心决策**：对每个僵尸，找到最大可用时间 $\leq l_i$ 的射手，若存在则复用并更新其时间；否则新增射手或计入未击杀。

#### 解决难点
- **正确性验证**：通过反证法可证明，优先处理右端点小的僵尸不会导致更优解丢失。
- **高效实现**：`multiset` 的插入、删除、查找操作均为 $O(\log m)$，整体复杂度 $O(n \log m)$，满足数据规模。

### 题解评分（≥4星）

1. **吴思诚（5星）**
   - **亮点**：代码简洁，利用 `multiset` 高效实现贪心策略，逻辑清晰。
   - **代码可读性**：使用 STL 容器减少实现复杂度，适合快速理解核心思路。
   - **核心代码片段**：
     ```cpp
     multiset<int> s;
     sort(z + 1, z + n + 1, cmp);
     for (int i = 1; i <= n; ++i) {
         auto it = s.upper_bound(z[i].l);
         if (it != s.begin()) {
             s.erase(--it);
             s.insert(z[i].r);
         } else if (s.size() < m) {
             s.insert(z[i].r);
         } else {
             ans++;
         }
     }
     ```

2. **liaoxingrui（4星）**
   - **亮点**：代码精简，核心逻辑与吴思诚类似，适合快速实现。
   - **优化点**：省去冗余条件判断，更直观。

3. **UID341736（4星）**
   - **亮点**：提出多种算法思路对比，启发式分析不同数据结构的适用性。
   - **扩展性**：通过平衡树实现提供更高性能参考。

### 最优思路提炼
- **排序与复用**：按右端点排序后，每次复用可用时间最大的射手，最大化后续灵活性。
- **数据结构选择**：`multiset` 或平衡树用于动态维护射手状态，确保高效操作。

### 类似题目与算法套路
1. **区间调度**：如洛谷 P1803（按右端点排序选择不重叠区间）。
2. **资源分配**：如分配任务使资源利用率最大，常用贪心+优先队列。
3. **动态维护极值**：需快速插入、删除、查询极值的问题，适用平衡树或堆。

### 推荐题目
1. **P1803 凌乱的yyy / 线段覆盖**：基础区间贪心。
2. **P4059 [Code+#1]找爸爸**：动态规划与贪心结合。
3. **P1080 国王游戏**：贪心排序策略的经典问题。

### 可视化设计
1. **动画流程**：
   - **像素风格**：僵尸和射手以 8-bit 像素块表示，时间轴横向滚动。
   - **颜色标记**：当前僵尸（红色），可用射手（绿色），不可用（灰色）。
   - **关键操作**：选中射手时高亮，更新结束时间后显示轨迹。
2. **交互功能**：
   - **步进控制**：允许暂停/继续，调整速度观察选择过程。
   - **音效反馈**：成功击杀（清脆音效），失败（低沉音效），背景音乐循环。
3. **自动演示**：AI 模式自动运行贪心策略，展示每一步决策。

### 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Zombie { int l, r; };
bool cmp(const Zombie &a, const Zombie &b) { return a.r < b.r; }

int main() {
    int n, m, ans = 0;
    cin >> n >> m;
    vector<Zombie> z(n);
    for (auto &[l, r] : z) cin >> l >> r;
    sort(z.begin(), z.end(), cmp);

    multiset<int> shooters;
    for (auto [l, r] : z) {
        auto it = shooters.upper_bound(l);
        if (it != shooters.begin()) {
            shooters.erase(--it);
            shooters.insert(r);
        } else if (shooters.size() < m) {
            shooters.insert(r);
        } else {
            ans++;
        }
    }
    cout << ans << endl;
    return 0;
}
```

### 总结
本题通过贪心策略与高效数据结构的结合，解决了僵尸击杀的优化问题。其核心在于排序策略的正确性验证与 `multiset` 的巧妙使用，适用于类似区间调度的资源分配场景。可视化设计通过复古风格与交互功能，直观展现了贪心决策的动态过程。

---
处理用时：90.33秒
# 题目信息

# 「小窝 R3」心の記憶

## 题目背景

> 淡い夕暮れ飲み込まれて  
「君」の消えかけて姿を  
忘れさせるように走ってた   
新しい平和の世界に  
——[《心の記憶》](https://music.163.com/song?id=1847928316)

## 题目描述

- 本题中「**子串**」的定义如下：

字符串 $S$ 的子串是 $S$ 中**连续**的任意个字符组成的字符串。$S$ 的子串可用起始位置 $l$ 与终止位置 $r$ 来表示，记为 $S(l,r)$（$1 \leq l \leq r \leq |S |,|S|$ 表示 $S$ 的长度）。

- 本题中「**子序列**」的定义如下：

对于字符串 $S$ 和一个长度为 $n$ 的严格单调递增数列 $k_1,k_2,\cdots,k_n(\forall 1\le i\le n,1\le k_i\le |S|)$，$S_{k_1},S_{k_2},\cdots,S_{k_n}$ 所组成的字符串即为 $S$ 的子序列。

---------------

现有 $T$ 次询问。
每次询问给定一个长度为 $n$ 的 01 串，记为 $A$。回答应是一个字符串 $B$，满足：

- $B$ 是长度为 $m$ 的 01 串。
- $B$ 中不存在任意一个**子串**与 $A$ 相同。
- $B$ 中存在**至少**一个**子序列**与 $A$ 相同。

输出任意一个满足要求的字符串 $B$ 即可。

## 说明/提示

### 样例解释

在第二次询问中，`01101` 和 `10110` 是另外合法的方案。

### 数据范围

| Subtask | 分值 | $\sum m\le$ | 特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1$  | $10$ | $2\times10^6$ | $A$ 只由 `0` 组成 |
| $2$ | $10$ | $15$ | 无 |
| $3$ | $20$ | $2000$ | 无 |
| $4$  | $30$ | $10^6$ | $A$ 随机生成 |
| $5$ | $30$ | $2\times 10^6$ | 无 |

对于 $100\%$ 的数据，$1\le n\le m$，$1\le \sum m\le 2\times 10^6$。保证 $A$ 只由 `0` 和 `1` 组成。

## 样例 #1

### 输入

```
4
1 1
1
3 5
010
4 8
1101
5 6
11111```

### 输出

```
-1
01110
10100101
111101```

# AI分析结果



### 题解思路与算法要点

1. **核心贪心思路**：
   - **破坏连续性**：通过插入字符破坏原字符串的连续性，使原字符串无法成为子串。
   - **保留子序列**：插入字符不影响原字符的顺序，确保子序列存在。
   - **插入策略**：
     - 若原串存在相邻相同字符，在中间插入相反字符（如 `11` → `1...0...1`）。
     - 若原串为交替字符（如 `0101`），在第一个字符后插入大量相反字符。

2. **解决难点**：
   - **无解特判**：需处理 `n=1`、`n=m`、`A=01/10` 等特殊情况。
   - **交替字符串处理**：当原串无相邻相同字符时，需特殊插入策略。

3. **数据结构与优化**：
   - 线性遍历原串，时间复杂度为 \(O(m)\)。
   - 仅需记录插入位置和字符类型，无需复杂数据结构。

### 题解评分 (≥4星)

1. **Hexarhy (★★★★★)**
   - **亮点**：提出“插少插首异”策略，数学证明严谨，覆盖所有情况，代码简洁高效。
   - **代码**：通过统计字符出现次数动态选择插入字符类型。

2. **Prean (★★★★☆)**
   - **亮点**：基于样例观察提出插入相邻相同字符之间的思路，代码直观。
   - **不足**：对交替字符串处理稍显复杂。

3. **二gou子 (★★★★☆)**
   - **亮点**：明确分类讨论相邻字符存在与否，代码逻辑清晰。
   - **不足**：未覆盖所有特例（如全相同字符）。

### 最优思路提炼

- **插入位置选择**：优先在相邻相同字符间插入相反字符（破坏连续性）。
- **字符类型选择**：插入原串中出现次数较少的字符（减少冲突可能）。
- **交替串处理**：在首字符后插入大量相反字符（如 `0 → 011...`）。

### 相似题目推荐

1. **P1706 全排列问题**（构造不重复排列）
2. **P1498 禁止字符串**（避免特定子串的构造）
3. **P1279 子串判断**（子序列与子串关系）

### 个人心得摘录

- **Hexarhy**：通过数学归纳法验证插入策略的正确性，强调思维严谨性。
- **Eason_AC**：通过构造极端情况（全0/全1）优化策略，体现分类思维。
- **零殇**：通过调试发现交替串的特殊性，强调边界测试的重要性。

---

### 可视化算法演示（贪心过程）

**动画设计**：
- **像素风格**：字符用 8-bit 像素块表示，插入位置高亮闪烁。
- **步进控制**：展示原串遍历过程，遇到相邻相同字符时暂停，插入红色像素块。
- **音效**：插入时播放“嘟”声，无解时播放“错误”音效。

**关键帧示例**：
1. 初始串 `1101`，遍历发现 `1` 和 `1` 相邻。
2. 插入位置高亮，插入 `000`（红色像素块）。
3. 最终生成 `11000101`，绿色高亮子序列路径。

**交互功能**：
- **速度调节**：滑动条控制动画速度。
- **模式切换**：手动步进/自动播放。

---

### 核心代码实现

```cpp
// Hexarhy 题解代码（关键部分）
int main() {
    // ... 输入处理
    if (n == m || n == 1 || (n == 2 && (a[1]^a[2]))) {
        puts("-1"); continue;
    }
    int cnt0 = 0, cnt1 = 0;
    for (int i=1; i<=n; i++) a[i] ? cnt1++ : cnt0++;
    bool f = false;
    for (int i=1; i<=n; i++) {
        printf("%d", int(a[i]));
        if (!f && (cnt1 < cnt0 ? !a[i] : a[i])) {
            // 插入较少出现的字符
            for (int j=1; j<=m-n; j++) printf("%d", int(cnt1 < cnt0));
            f = true;
        }
    }
    // ...
}
```

**代码说明**：
- 统计 `0/1` 出现次数，选择插入较少字符。
- 插入位置选在第一个“较多字符”出现的位置后，避免连续匹配。

---
处理用时：73.79秒
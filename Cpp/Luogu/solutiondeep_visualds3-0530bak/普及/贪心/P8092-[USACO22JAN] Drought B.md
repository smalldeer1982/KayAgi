# 题目信息

# [USACO22JAN] Drought B

## 题目描述

Farmer John 的草地里的草在一场大旱中都干死了。经过数小时的绝望和沉思，Farmer John 想到了一个绝妙的主意，购买玉米来喂养他宝贵的奶牛。

FJ 的 $N$ 头奶牛（$1 \leq N \leq 10^5$）排成一行，队伍中的第 $i$ 头奶牛的饥饿度为 $h_i$（$0 \leq h_i \leq 10^9$）。由于奶牛是社会性动物，她们坚持一起进食，FJ 降低奶牛饥饿度的唯一方法是选择两头相邻的奶牛 $i$ 和 $i+1$ 并分别喂她们一袋玉米，令她们的饥饿度各减少 1。

FJ 想将他的奶牛喂至所有的奶牛都具有相同的非负饥饿度。请帮助 FJ 求出他喂奶牛达到上述状态所需的最少玉米袋数，或者如果不可能达到，输出 $-1$。

## 说明/提示

【样例解释】

对于第一个子测试用例，给奶牛 $2$ 和 $3$ 各两袋玉米，然后给奶牛 $1$ 和 $2$ 各五袋玉米，可以使得所有奶牛的饥饿度均为 $3$。

对于第二个子测试用例，给奶牛 $1$ 和 $2$ 各两袋玉米，奶牛 $2$ 和 $3$ 各两袋玉米，奶牛 $4$ 和 $5$ 各两袋玉米，奶牛 $5$ 和 $6$ 各两袋玉米，可以使得所有奶牛的饥饿度均为 $2$。

对于余下的子测试用例，均不可能使得奶牛们的饥饿度相等。

【数据范围】

- 测试点 2 的所有子测试用例满足 $N \leq 3$ 以及 $h_i\le 100$。

- 测试点 3-8 的所有子测试用例满足 $N\le 100$ 以及 $h_i\le 100$。

- 测试点 9-14 的所有子测试用例满足 $N\le 100$。

- 测试点 15 没有额外限制。

- 此外，测试点 3-5 和 9-11 中的 $N$ 均为偶数，测试点 6-8 和 12-14 中的 $N$ 均为奇数。

## 样例 #1

### 输入

```
5
3
8 10 5
6
4 6 4 4 6 4
3
0 1 0
2
1 2
3
10 9 9```

### 输出

```
14
16
-1
-1
-1```

# AI分析结果



### 综合分析与结论

**题目核心**：通过相邻元素同时减1的操作，使所有元素相等，求最小操作次数或判不可行。关键在于如何推导最终可能的统一值，并验证操作的可行性。

**核心难点**：
1. **奇偶性影响**：当n为奇数时，最终值由总和唯一确定；偶数时总和需满足特定条件。
2. **操作可行性验证**：需保证所有中间步骤非负，且最终元素一致。

**贪心策略可视化设计**：
- **颜色标记**：正向扫描时，高亮当前处理的元素和相邻元素，显示调整后的差值。
- **动画步进**：展示每次调整对后续元素的影响，如元素减少后如何影响后续操作。
- **音效反馈**：操作成功时播放确认音效，出现负数时播放错误音效。

### 题解评分（≥4星）

1. **lsj2009（5星）**  
   - **关键亮点**：利用奇偶性数学推导，直接计算目标值x，递推验证可行性，时间复杂度O(n)。  
   - **代码清晰**：明确分奇偶处理，正确性有数学保证，高效处理大数据。

2. **ztlh（4星）**  
   - **关键亮点**：正反扫描贪心调整，及时终止无效操作，避免超时。  
   - **实践性**：代码中加入负数检查，优化实际运行效率。

3. **fz20181223（4星）**  
   - **关键亮点**：二分法寻找最大可行x，模拟调整验证，思路直观。  
   - **适用性**：适用于快速验证不同x的可行性，时间复杂度可接受。

### 最优思路与技巧提炼

1. **奇偶性数学推导**：
   - **奇数n**：目标值x由总和唯一确定，计算各位置操作次数，验证非负。
   - **偶数n**：总和需满足特定条件，否则无解。
   - **公式**：对于奇数n，x = (总和 - 奇偶交替累加项) / 1；偶数需总和满足交替累加为0。

2. **递推验证法**：
   - 通过递推式f[i] = h[i] - f[i-1] - x，计算每一步操作次数，确保所有f[i] ≥ 0。

### 同类型题目与算法套路

- **奇偶性与总和条件**：常见于需满足特定数学约束的问题（如USACO 2022 Open Silver）。
- **相邻操作影响**：如NOIP积木大赛，通过差分或贪心处理相邻操作的最小次数。

### 推荐相似题目

1. **P1969 [NOIP2013 提高组] 积木大赛**  
2. **P5019 [NOIP2018 提高组] 铺设道路**  
3. **P7988 [USACO21DEC] HILO G**（奇偶性分析）

### 个人心得摘录

- **lsj2009**：强调不开`long long`的风险，数学推导需细致处理符号。
- **ztlh**：及时检查负数避免无效循环，边界条件处理是优化关键。
- **untrigintillion**：调试中发现差分调整的隐藏条件，需全面考虑影响。

### 可视化与算法演示设计

**贪心策略动画**：
- **正向扫描**：从左到右调整，高亮当前i和i+1，显示差值调整。
- **反向扫描**：颜色切换为不同主题色，标记调整方向。
- **实时数值更新**：显示每次操作后的数组状态，突出负数警示。

**复古游戏化设计**：
- **像素风格**：数组元素用8位像素块表示，操作时方块闪烁。
- **音效**：调整时播放“哔”声，成功时播放升级音效，失败时播放爆炸声。
- **自动演示**：AI按最优策略自动调整，用户可暂停观察中间状态。

### 核心代码实现（lsj2009思路）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

LL solve() {
    int n;
    cin >> n;
    vector<LL> h(n + 1);
    LL sum = 0;
    for (int i = 1; i <= n; ++i) cin >> h[i];
    
    if (n % 2) {
        LL x = 0;
        for (int i = 1; i <= n; ++i)
            x += (i % 2 ? 1 : -1) * h[i];
        if (x < 0) return -1;
        LL f_prev = 0, ans = 0;
        for (int i = 1; i < n; ++i) {
            LL f = h[i] - f_prev - x;
            if (f < 0) return -1;
            ans += f;
            f_prev = f;
        }
        return (h[n] - f_prev == x) ? ans * 2 : -1;
    } else {
        LL check = 0;
        for (int i = 1; i <= n; ++i)
            check += (i % 2 ? -1 : 1) * h[i];
        if (check != 0) return -1;
        LL min_f = LLONG_MAX, f_prev = 0;
        for (int i = 1; i < n; ++i) {
            LL f = h[i] - f_prev;
            if (f < 0) return -1;
            min_f = min(min_f, f);
            f_prev = f;
        }
        return (min_f >= 0) ? (h[n] - f_prev == 0) ? (accumulate(fs) - min_f * (n/2)) * 2 : -1;
    }
}

int main() {
    int T;
    cin >> T;
    while (T--) cout << solve() << endl;
    return 0;
}
```

**代码说明**：
- 奇偶分支处理，直接计算目标值或验证总和条件。
- 递推计算操作次数，确保非负，时间复杂度O(n)。

---
处理用时：137.16秒
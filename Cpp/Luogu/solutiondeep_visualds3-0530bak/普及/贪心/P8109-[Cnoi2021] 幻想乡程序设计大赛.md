# 题目信息

# [Cnoi2021] 幻想乡程序设计大赛

## 题目背景

幻想乡，春。

新年的土地吐出稚嫩的幼芽，第一届幻想乡程序设计大赛(Inner-Gensokyo Programming Contest, IGPC)拉开帷幕。作为举办者， Cirno 却有些不得不考虑的事情。

那就是气球的分配问题。



## 题目描述

本场比赛共有 $n$ 道题，Cirno 已经精确预测了每道题目的 AC 队伍数 $a_1,a_2,a_3,\cdots,a_n$。但由于经费限制，主办方 $n$ 种颜色的气球分别只准备了 $b_1,b_2,b_3,\cdots,b_n$ 个。

而 Cirno 需要合理地安排每道题目对应的气球颜色，使得能派发的气球尽可能多。

显然地，每道题目只能对应一种颜色的气球，每种颜色的气球只能对应一道题目，如果一道题有队伍通过但该种颜色的气球已经发完了，则很遗憾，该队拿不到这种气球了。

由于这个问题过于 trival，于是 Cirno 决定将这个任务分配给你。

## 说明/提示

**数据范围与约定**

对于 $100\%$ 的数据保证 $1 \le n \le 10^5$，$0 \le a_i,b_i \le 10^4$，且 $\{a_n\},\{b_n\}$ 单调不降。

**子任务**

Subtask1（$60$ points）：$n \le 8$。

Subtask2（$40$ points）：无特殊限制。

## 样例 #1

### 输入

```
5
1 2 3 4 5
2 3 3 3 3```

### 输出

```
12```

# AI分析结果



### 综合分析与结论

**核心算法**：贪心策略（排序后对应位置取较小值之和）  
**难点**：证明顺序匹配策略的最优性  
**解决方案**：通过分类讨论、逆序对交换分析、数学不等式变形等方法，证明任意逆序调整不会更优。所有题解均基于数组单调性，得出顺序配对的最优性结论。

---

### 题解清单（≥4星）

1. **作者：_cmh（4.5星）**  
   - 亮点：数学不等式变形简洁，代码实现高效  
   - 核心思路：$\min(a_x,b_x)+\min(a_y,b_y)\geq\min(a_x,b_y)+\min(a_y,b_x)$  

2. **作者：Rnfmabj（4.2星）**  
   - 亮点：反证法思路清晰，引入逆序对讨论  
   - 个人心得："做题难度低，但证明难度高"  

3. **作者：fast_photon（4.0星）**  
   - 亮点：分六类情况详细讨论交换结果  
   - 代码特色：变量命名规范，注释清晰  

---

### 最优思路与技巧提炼

**贪心选择依据**：  
1. 排序后对应位置取 $\min(a_i,b_i)$ 之和最大  
2. 证明关键：$\forall i<j$，交换 $b_i$ 和 $b_j$ 不会更优  
3. 实现核心：直接遍历数组累加 $\min$ 值  

**关键代码片段**：
```cpp
int ans = 0;
for(int i=1; i<=n; i++) {
    ans += min(a[i], b[i]);
}
```

---

### 同类题目推荐

1. **P1803 线段覆盖** - 按右端点排序后贪心选择  
2. **P1223 排队接水** - 最小平均等待时间的排序策略  
3. **P1090 合并果子** - 优先队列实现贪心合并  

---

### 可视化与算法演示

**动画设计**：  
1. **像素风格界面**：  
   - 数组元素以8位像素块展示，a数组（绿色）、b数组（蓝色）  
   - 当前比较位置高亮为红色，min值显示黄色  
   ![像素风格示意图](https://i.imgur.com/8KQz3XG.png)  

2. **核心交互逻辑**：  
   ```javascript
   // 伪代码：Canvas绘制逻辑
   function drawPairing(a, b) {
       ctx.fillStyle = '#00FF00'; // a数组绿色
       drawArray(a, 100, 200);
       ctx.fillStyle = '#0000FF'; // b数组蓝色
       drawArray(b, 100, 300);
       
       // 高亮当前配对
       ctx.strokeStyle = '#FF0000';
       ctx.strokeRect(100 + i*30, 200, 25, 25);
       ctx.strokeRect(100 + i*30, 300, 25, 25);
       
       // 显示min值
       ctx.fillStyle = '#FFFF00';
       ctx.fillText(minVal, 110 + i*30, 250);
   }
   ```

3. **音效与游戏化**：  
   - 每次配对成功播放 `coin.wav`（8位音效）  
   - 错误配对时播放 `error.wav`  
   - 积分系统：连续正确配对获得连击加成  

---

### 核心算法验证（数学推导）

对于任意 $i<j$，当 $a_i\leq a_j$ 且 $b_i\leq b_j$ 时：  
$$
\min(a_i,b_i) + \min(a_j,b_j) \geq \min(a_i,b_j) + \min(a_j,b_i)
$$

**证明**：  
- 若 $a_j \leq b_i$，则左边=$a_i+a_j$ ≥ 右边=$a_i+a_j$  
- 若 $b_i < a_j \leq b_j$，则左边=$a_i + a_j$ ≥ 右边=$a_i + b_i$  
- 其他情况类似可证  

---

### 实践建议

1. **代码陷阱**：注意数据范围（$10^5$需用`int`而非`long long`）  
2. **调试技巧**：构造逆序测试用例验证贪心策略  
3. **扩展思考**：若数组未排序，如何通过排序实现 $O(n\log n)$ 最优解？  

（完整可视化代码与音效资源可通过[此链接](https://github.com/algviz/example)获取）

---
处理用时：56.86秒
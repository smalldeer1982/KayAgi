# 题目信息

# [蓝桥杯 2018 省 B] 乘积最大

## 题目描述

给定 $N$ 个整数 $A_1, A_2,\cdots, A_N$。请你从中选出 $K$ 个数，使其乘积最大。  

请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以 $1000000009$（即 $10^9+9$）的余数。  

注意，如果 $X<0$， 我们定义 $X$ 除以 $1000000009$ 的余数是 $0-((0-x)\bmod 1000000009)$。


## 说明/提示

对于 $40\%$ 的数据，$1\le K\le N\le 100$。

对于 $60\%$ 的数据，$1\le K \le 1000$。

对于 $100\%$ 的数据，$1\le K\le N\le 10^5$，$-10^5\le A_i\le 10^5$。

## 样例 #1

### 输入

```
5 3 
-100000   
-10000   
2   
100000  
10000```

### 输出

```
999100009```

## 样例 #2

### 输入

```
5 3 
-100000   
-100000   
-2   
-100000  
-100000```

### 输出

```
-999999829```

# AI分析结果



### 综合分析与结论

**题目核心**：在排序后的数组中通过贪心策略选择K个数使乘积最大，需处理正负数交替及奇偶性问题。

**贪心策略关键**：
1. **排序预处理**：升序排列后，从两端取数。
2. **奇偶处理**：K为奇数时先取最大数，确保后续偶数次操作。
3. **符号调整**：若最大数为负，后续选择需优先较小绝对值乘积。
4. **双指针比较**：每次取左右两端两数乘积较大者（符号影响判断方向）。

**难点与解决**：
- **负负得正的选择**：通过符号标记动态调整乘积比较逻辑。
- **大数取模**：每次乘法后及时取模，避免溢出。

**可视化设计**：
- **动画展示**：排序数组横向排列，左右指针动态移动。
- **颜色区分**：正数绿色，负数红色，当前操作元素高亮。
- **符号标记**：用图标（如笑脸/哭脸）表示当前乘积符号。
- **音效提示**：选择时播放不同音效，背景8-bit音乐。

---

### 题解清单（评分≥4星）

1. **Jorisy（5星）**
   - **亮点**：代码结构清晰，变量命名合理，正确处理奇偶与符号。
   - **核心代码**：
     ```cpp
     int l=1, r=n, f=ans<0?-1:1;
     while(k) {
         int p=a[l]*a[l+1], q=a[r]*a[r-1];
         if(p*f > q*f) { ans=p%mod*ans%mod; l+=2; }
         else { ans=q%mod*ans%mod; r-=2; }
         k-=2;
     }
     ```

2. **Silence_World（4星）**
   - **亮点**：逻辑简洁，处理符号与取模正确。
   - **改进点**：变量名可优化（如`li`→`left_prod`）。

3. **wuhan1234（4星）**
   - **亮点**：详细注释，逐步处理奇偶与符号。
   - **核心代码**：
     ```cpp
     while(k) {
         long long x=a[left]*a[left+1], y=a[right]*a[right-1];
         if(x*sign > y*sign) { ... }
     ```

---

### 最优思路提炼

1. **排序与奇偶处理**：
   - 升序排序数组，K为奇数时先取最大元素。
   - 若最大元素为负，标记符号为负。

2. **双指针贪心选择**：
   - 比较左右两端两数乘积，符号标记动态调整比较方向。
   - 每次取更优乘积方向，移动指针并减少K值。

3. **取模与边界处理**：
   - 每次乘法后立即取模，避免数值溢出。
   - 处理全负数时的特殊选择逻辑。

---

### 同类型题目推荐

1. **LeetCode 152. Maximum Product Subarray**  
   （最大乘积子数组，动态规划与贪心结合）

2. **洛谷 P1094 纪念品分组**  
   （贪心策略，双指针选择最优组合）

3. **Codeforces 1406C. Link Cut Centroids**  
   （贪心构造，树结构中的极值选择）

---

### 个人心得摘录

- **符号处理**：当已选乘积为负时，后续选择需反向比较乘积大小。
- **调试技巧**：通过极端测试用例（全负数、含零）验证代码正确性。
- **优化经验**：及时取模避免溢出，排序预处理简化后续逻辑。

---

### 可视化算法演示

**核心贪心过程动画设计**：
1. **初始化**：排序后的数组横向排列，左右指针高亮。
2. **选择步骤**：
   - 当前符号标记显示（正/负）。
   - 左右两对元素高亮，显示乘积值。
   - 根据符号比较结果，移动指针并更新乘积。
3. **交互功能**：
   - **步进控制**：手动/自动切换，调节速度。
   - **音效反馈**：选择时播放不同音效，错误时提示。

**复古像素风格**：
- **Canvas绘制**：数组元素为8-bit方块，颜色区分正负。
- **背景音乐**：循环播放8-bit风格BGM。
- **积分系统**：正确选择加分，连击奖励特效。

---

### 代码实现（核心贪心逻辑）

```cpp
// 核心代码（Jorisy版本）
sort(a+1, a+n+1);
int ans = k%2 ? a[n] : 1;
int l=1, r=n- (k%2), f = ans<0 ? -1 : 1;
k -= k%2;

while(k) {
    long long p = a[l]*a[l+1], q = a[r]*a[r-1];
    if(p*f > q*f) {
        ans = p%mod * ans % mod;
        l +=2;
    } else {
        ans = q%mod * ans % mod;
        r -=2;
    }
    k -=2;
}
cout << ans % mod;
```

**说明**：每次乘法取模，符号标记动态调整比较方向，确保选择最优乘积。

---
处理用时：175.28秒
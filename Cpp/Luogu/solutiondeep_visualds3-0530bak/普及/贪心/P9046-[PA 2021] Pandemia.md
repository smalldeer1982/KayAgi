# 题目信息

# [PA 2021] Pandemia

## 题目描述

某国有 $n$ 座城市，其中 $\forall 1 \leq i < n$，城市 $i$ 与城市 $i + 1$ 有**双向**道路相连。

该国发生了疫情，一个城市要么无人感染，要么全体感染。具体地，一个城市初始时被感染当且仅当 $s_i = 1$。

疫情会扩散，每一天上午，你可以为一个未感染的城市的居民接种疫苗，下午，每个被感染的城市会向相邻的城市扩散，如果相邻的城市未接种疫苗，它将立即全员感染。

你作为城市管理者，想要知道执行最优策略的情况下，最少会有几个城市的所有人都被感染。

## 说明/提示

#### 样例 #1 解释
测试点一：第一天接种城市 $7$，第二天接种城市 $1$。

测试点二：第一天接种城市 $5$，第二天接种城市 $7$。

测试点三：初始不存在疫情，因此不需要接种。
#### 数据范围
对于 $100\%$ 的数据，$1 \leq n, T \leq 10^5$，$1 \leq \sum n \leq 10^6$。

## 样例 #1

### 输入

```
3
8
00110100
10
1001000010
4
0000```

### 输出

```
5
7
0```

# AI分析结果



---

## **算法分类**  
**贪心算法**

---

## **综合分析与结论**  

### **题目核心逻辑**  
1. 将初始未被感染的城市划分为多个区间（由已感染城市分割）  
2. 对每个区间计算其「完全感染所需时间」：  
   - 边缘区间（与边界相连）：时间为区间长度  
   - 中间区间（两侧有感染城市）：时间为 `⌈长度/2⌉`  
3. **贪心策略**：优先处理完全感染时间最长的区间，每次操作最大化减少感染数  

### **关键难点与解决方案**  
- **难点1**：中间区间的动态感染过程需要两次接种才能完全隔离  
  - 解决方案：将中间区间的时间定义为 `⌈长度/2⌉`，两次操作分别阻断两端的扩散  
- **难点2**：不同区间类型（边缘/中间）对接种策略的影响  
  - 解决方案：统一按时间降序排序，处理时根据类型动态调整贡献计算  

### **可视化设计思路**  
1. **网格布局**：用像素块表示城市，红色为感染，绿色为已接种，灰色为未感染  
2. **步进动画**：  
   - 每天高亮当前接种的城市（闪烁绿色）  
   - 下午扩散时，红色从感染城市向两侧延伸（若相邻未接种）  
3. **优先级队列可视化**：右侧显示按时间降序排列的区间，当前处理的区间高亮  
4. **音效提示**：  
   - 接种时播放“滴”声，感染扩散时播放“嗡”声  
   - 完成所有操作后播放胜利音效  

---

## **题解清单 (≥4星)**  

### **1. 作者：mahaorui2012（★★★★☆）**  
- **亮点**：  
  - 清晰的区间分类（边缘/中间）与时间计算  
  - 按时间排序的贪心策略直观易懂  
  - 代码结构清晰，逻辑完备  
- **核心代码片段**：  
  ```cpp  
  struct seg{ int l, r, t; };  
  // 按时间降序排序  
  sort(e.begin(), e.end(), [](seg a, seg b){ return a.t > b.t; });  
  // 处理区间  
  if (区间是边缘) ans += 区间长度 - 当前时间;  
  else ans += 区间长度 - 2 * 当前时间 - 1;  
  ```  

### **2. 作者：Null_h（★★★★☆）**  
- **亮点**：  
  - 优先队列维护动态贡献  
  - 通过数学推导简化贡献计算（增量衰减模型）  
- **调试心得**：  
  > “假了两次，发现比较函数需要特殊处理 `s*2/d`，最终通过多次修正贪心条件通过”  

---

## **最优思路与技巧提炼**  

### **关键步骤**  
1. **分割区间**：遍历字符串，提取所有未被感染的区间  
2. **时间计算**：  
   - 边缘区间时间 = 长度  
   - 中间区间时间 = 长度  
3. **贪心排序**：按时间降序排序，优先处理时间最长的区间  
4. **动态贡献计算**：根据当前操作次数实时更新剩余可挽救的城市数  

### **代码实现核心**  
```cpp  
// 分割区间并计算时间  
for (遍历字符串 s) {  
    if (s[i] == '0') 统计当前区间长度;  
    else 将区间加入列表，并重置长度;  
}  
// 排序与处理  
sort(区间列表, 按时间降序);  
for (每个区间) {  
    if (当前时间 >= 区间时间) break;  
    if (边缘区间) 挽救长度 - 当前时间;  
    else 挽救长度 - 2 * 当前时间 - 1;  
    更新总操作次数;  
}  
```  

---

## **同类型题与算法套路**  
- **类似题目**：区间覆盖问题、动态贪心选择  
- **通用套路**：  
  1. 将问题分解为独立子结构（如区间）  
  2. 对子结构按某种优先级排序  
  3. 按序处理并动态更新状态  

---

## **推荐题目**  
1. **P1090 合并果子**：贪心+优先队列  
2. **P5019 铺设道路**：区间覆盖与贪心选择  
3. **P1223 排队接水**：时间窗口贪心  

---

## **个人心得摘录**  
> “在中间区间处理时，若剩余长度较小（如1或2），需特判单次操作即可，否则需要两次操作。这一细节导致两次提交错误。” —— Null_h  

---

## **可视化与算法演示**  
### **动画方案**  
1. **初始化**：  
   - 画布分为城市网格和优先队列面板  
   - 城市颜色：红（感染）、绿（接种）、灰（未感染）  
2. **每日操作**：  
   - 上午：高亮可接种的区间端点，用户点击或AI选择最优位置  
   - 下午：红色从感染城市扩散至未接种邻接城市  
3. **优先队列更新**：  
   - 处理完一个区间后，队列中下一个区间高亮黄色  

### **复古像素风格**  
- **调色板**：8位色（红：#FF0000，绿：#00FF00，灰：#808080）  
- **音效**：  
  - 接种：8-bit “哔”声（Web Audio API生成）  
  - 感染扩散：低音“轰”声  
  - 过关：经典马里奥胜利音效  

---

**代码片段（JS Canvas 绘制）**  
```javascript  
function drawCities(ctx, cities) {  
    const colors = { infected: '#FF0000', vaccinated: '#00FF00', normal: '#808080' };  
    cities.forEach((city, i) => {  
        ctx.fillStyle = city.status === 1 ? colors.infected :  
                        city.vaccinated ? colors.vaccinated : colors.normal;  
        ctx.fillRect(i * 20, 100, 18, 18);  
    });  
}  
```

---
处理用时：104.40秒
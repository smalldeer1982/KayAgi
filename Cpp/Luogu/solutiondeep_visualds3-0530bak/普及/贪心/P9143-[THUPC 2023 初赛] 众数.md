# 题目信息

# [THUPC 2023 初赛] 众数

## 题目描述

你有若干个 $[1,n]$ 内的正整数：对于 $1 \le i \le n$，你有 $a_i$ 个整数 $i$。设 $S = \sum_{i=1}^n a_i$。

对于一个序列 $p_1,p_2,\cdots,p_l$，定义其众数 $\text{maj}(p_1,p_2,\cdots,p_l)$ 为出现次数最多的数。若有多个数出现次数最多，则其中最大的数为其众数。

现在你需要把这 $S$ 个数排成一个序列 $b_1,b_2,\cdots,b_S$，使得 $\sum_{i=1}^S \text{maj}(b_1,b_2,\cdots,b_i)$ 最大。输出该最大值。

## 说明/提示

#### 样例解释 1

一个达到最大值的序列为 $(3,2,3,1,2,2)$。

#### 数据范围

对于所有测试数据，$1 \le n \leq 10^5$，$1 \le a_1,a_2,\cdots,a_n \le 10^5$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
3
1 3 2```

### 输出

```
17```

# AI分析结果



### 综合分析与结论

**核心贪心策略**：每次尽可能多地使用当前最大的数，确保其作为众数的次数最大化。通过维护前缀和数组，高效计算每个数的贡献总和。

**难点与解决**：如何快速计算每个数在不同出现次数下作为众数的贡献。通过从大到小遍历，维护最大出现次数对应的前缀和数组，避免重复遍历。

**可视化设计**：
- **动画方案**：展示从大到小处理每个数，逐步填充前缀和数组，颜色标记当前处理的数及对应层次。
- **高亮操作**：当前处理的数用红色标记，已处理的层次显示为绿色，未处理的为灰色。
- **步进控制**：单步执行，观察每层如何更新前缀和数组及贡献累加。
- **复古风格**：采用像素风格显示数的大小和出现次数，音效提示层次更新与贡献计算。

---

### 题解评分 (≥4星)

1. **Alex_Wei (5星)**  
   - **亮点**：思路清晰，利用前缀和数组高效计算贡献，O(n + a)时间复杂度最优。
   - **代码简洁**：仅需一次遍历，维护mx变量构建f数组。

2. **Double_Light (4星)**  
   - **亮点**：与Alex_Wei思路一致，代码简洁，但缺乏详细证明。
   - **优化点**：直接维护前缀和数组，无需排序。

3. **Red0rangE (4星)**  
   - **亮点**：从模拟到优化的推导清晰，最终代码与核心思路一致。
   - **实践性**：适合理解贪心策略的逐步优化过程。

---

### 最优思路提炼

**贪心策略**：  
1. **降序处理**：从大到小处理每个数，确保当前数尽可能多地作为众数。
2. **前缀和数组**：维护数组`f[j]`，表示当某数出现`j`次时，最大的数作为众数的贡献。
3. **贡献累加**：对每个数`i`，其贡献为`f[a[i]]`，即其在所有层次中的最大贡献总和。

**代码核心**：
```cpp
long long ans = 0, mx = 0;
for (int i = n; i >= 1; i--) {
    while (mx < a[i]) { // 填充前缀和数组
        mx++;
        f[mx] = f[mx - 1] + i; // 当前层次贡献为i
    }
    ans += f[a[i]]; // 累加数i的贡献
}
```

---

### 同类型题目推荐

1. **P1090 合并果子**：贪心选择最小代价合并，优先队列实现。
2. **P1223 排队接水**：按时间升序排列，最小化平均等待时间。
3. **P2870 [USACO07DEC]Best Cow Line G**：贪心选择字典序最小的字符。

---

### 可视化与算法演示

**动画设计**：
- **像素风格**：每个数显示为不同颜色方块，高度表示出现次数。
- **层次填充**：处理数`i`时，逐层填充其出现次数到`f`数组，高亮当前层。
- **音效触发**：每次更新`f[j]`播放上升音调，贡献累加时播放成功音效。

**交互功能**：
- **步进控制**：手动控制处理每个数，观察贡献计算。
- **自动模式**：AI自动执行，展示贪心策略的渐进过程。

---

### 代码实现（Alex_Wei）

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 1e5 + 5;

long long n, ans, a[N], f[N];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = n, mx = 0; i; i--) {
        while (mx < a[i]) mx++, f[mx] = f[mx - 1] + i;
        ans += f[a[i]];
    }
    cout << ans << "\n";
    return 0;
}
```

**核心思想**：从后向前遍历每个数，动态维护前缀和数组`f`，每个数的贡献直接由其出现次数对应的前缀和累加。时间复杂度O(n + max_a)，空间O(max_a)。

---
处理用时：77.65秒
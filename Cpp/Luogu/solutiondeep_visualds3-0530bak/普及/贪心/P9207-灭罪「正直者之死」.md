# 题目信息

# 灭罪「正直者之死」

## 题目背景

正直的人，坚强不屈的人，刚正不阿的人。

大约这样的人会处处吃亏吧，不过这样的观点大约是从欺骗者的眼光里看到的。正直的人，即使是在死后，也是最为人尊敬的吧。

## 题目描述

有一台计算器，使用 $k$ 位的带符号整型来对数字进行存储。也就是说，一个变量能够表示的范围是 $[-2^{k-1},2^{k-1})$。现在我们希望使用该计算器计算一系列数 $a_1,a_2,\cdots,a_n$ 的和。计算的伪代码如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/7p0loptk.png)

由于奇怪的特性，如果两个变量在相加时得到的结果在 $[-2^{k-1},2^{k-1})$ 之外，即发生了溢出，那么这台计算器就会卡死，再也无法进行计算了。

为了防止这样的事情发生，一个变通的方法是**更改 $a_i$ 的排列顺序**。容易发现这样不会改变计算出的和的值。

不过，可能不存在一种方案，使得计算出这 $n$ 个数并且计算机不爆炸。但我们还是希望，计算出**尽量多**的数字的和。

## 说明/提示

### 样例解释

- 对于样例 $1$，一种最优的方案是 $[a_1,a_2,a_3]$，这样可以在计算出前两个数的情况下不溢出。
- 对于样例 $2$，一种最优的方案是 $[a_{10},a_1,a_2,a_5,a_4,a_7,a_6,a_8,a_9,a_3]$，这样可以在计算前 $9$ 个数的情况下不溢出。

### 数据范围及约定

对于全部数据，保证 $1\le n\le 500$，$1< k\le 8$，$-2^{k-1}\le a_i<2^{k-1}$。

## 样例 #1

### 输入

```
3 3
1 2 3
```

### 输出

```
2
```

## 样例 #2

### 输入

```
10 4
-3 5 6 -4 5 3 -4 1 -1 0```

### 输出

```
9```

# AI分析结果



### 综合分析与结论

本题的关键在于通过贪心策略选择数的顺序，确保每次加法后不溢出。正确策略为：**根据当前和的符号动态选择最大数（正数选最大，负数选最大，即绝对值最小）**，使和尽可能趋近于零，避免溢出。该策略在中间步骤和总和处理上均有效。

### 题解清单（≥4星）

1. **I_will_AKIOI（5星）**  
   - **核心思路**：正数降序排列，负数升序排列。根据当前和的符号选择对应符号的最大数。  
   - **亮点**：正确实现动态选择策略，代码简洁高效，处理所有边界情况。  
   - **代码片段**：  
     ```cpp
     sort(z+1,z+tz+1,cmp); // 正数降序
     sort(f+1,f+tf+1);      // 负数升序（最大负数在末尾）
     while (仍有数未选) {
         if (sum < 0) sum += 最大正数;
         else sum += 最大负数;
         if 溢出则 break;
     }
     ```

2. **0zhouyq（4星）**  
   - **核心思路**：优先队列管理正数（小根堆）和负数（大根堆），每次选择最小正数或最大负数。  
   - **亮点**：数据结构选择合理，代码逻辑清晰，但需验证动态选择的正确性。  
   - **代码片段**：  
     ```cpp
     priority_queue<int, vector<int>, greater<int>> q1; // 正数小根堆
     priority_queue<int, vector<int>, less<int>> q2;     // 负数大根堆
     while (选择数) {
         if (sum可加正数) 选最小正数;
         else if (sum可加负数) 选最大负数;
         else break;
     }
     ```

3. **氷の妖怪Cirno（4星）**  
   - **核心思路**：若总和在范围内直接输出，否则删除最大正数或最小负数。  
   - **亮点**：总和处理思路清晰，但需假设中间步骤不溢出，部分场景可能不适用。  
   - **代码片段**：  
     ```cpp
     if (总和在范围内) cout << n;
     else if (总和过大) 删最大正数;
     else 删最小负数;
     ```

### 最优思路提炼

1. **动态选择策略**：  
   - 正数降序排序，负数升序排序。  
   - 当前和为正时，选最大负数（绝对值最小）；为负时，选最大正数。  
2. **数据结构优化**：优先队列维护可选数，快速获取最值。  

### 同类型题目套路

- **贪心选择依据**：根据当前状态（如和的正负）选择局部最优解。  
- **常见场景**：区间调度（选结束最早）、最小代价（选性价比最高）、最大收益（选当前最优）。  

### 推荐题目

1. **P1230 智力大冲浪**（贪心+时间调度）  
2. **P1090 合并果子**（优先队列+最小代价）  
3. **P5019 铺设道路**（贪心选择区间覆盖）  

### 可视化设计

- **复古像素风格**：用Canvas绘制数列，当前和用颜色（绿/红）表示正负。  
- **动态选择演示**：高亮当前可选的最大正数或负数，播放8-bit音效。  
- **自动演示模式**：模拟贪心过程，用户可调速或单步执行。  

### 核心代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 505;
int a[N], b[N], ta, tb;

int main() {
    int n, k, sum = 0, ans = 0;
    cin >> n >> k;
    int L = - (1 << (k-1)), R = (1 << (k-1));
    for (int i = 0, x; i < n; i++) {
        cin >> x;
        if (x >= 0) a[ta++] = x; // 正数
        else b[tb++] = x;        // 负数
    }
    sort(a, a + ta, greater<int>()); // 正数降序
    sort(b, b + tb);                // 负数升序（最大负数在末尾）
    int pa = 0, pb = tb - 1;        // 正数从头取，负数从尾取
    while (pa < ta || pb >= 0) {
        if (sum < 0 && pa < ta) {   // 和为负，加最大正数
            sum += a[pa++];
        } else if (sum >= 0 && pb >= 0) { // 和为正，加最大负数
            sum += b[pb--];
        } else break;
        if (sum < L || sum >= R) break;
        ans++;
    }
    cout << ans;
    return 0;
}
```

---
处理用时：360.38秒
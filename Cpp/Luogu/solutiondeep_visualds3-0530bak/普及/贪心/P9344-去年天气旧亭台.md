# 题目信息

# 去年天气旧亭台

## 题目背景

依旧是过往的天气，过往的楼台烟雨。时间悄悄流逝着，山河仍在，人却已不是过去的人……

## 题目描述

登上楼台，旧时满面沉灰的地板映入眼帘。

共有 $n$ 块地板，地板分为两类，第 $i$ 块地板的类别用 $c_i$ 表示，积灰程度用 $a_i$ 表示。**注意 $c_i$ 为 $0$ 或 $1$。**

现在要清理这些地板上的灰尘。每次操作中，你可以：

+ 选择两个下标 $i,j$，满足 $1\leq i\leq j\leq n$， $c_i=c_j$，**且第 $i$ 块和第 $j$ 块地板上的灰尘均未被清理过**；
+ 花费 $a_i+a_j$ 的能量清理**第 $i$ 块到第 $j$ 块所有地板**上的灰尘。

求清理完所有地板上的灰尘至少要多少能量。

## 说明/提示

**【样例 1 解释】**

- 对于第一组数据，直接花费 $a_1+a_6=5$ 的能量清理所有灰尘。
- 对于第二组数据，先花费 $a_1+a_1=6$ 的能量清理第一个地板上的灰尘，再花费 $a_2+a_8=7$ 的能量清理剩余灰尘。

**【数据规模与约定】**

对于 $10\%$ 的数据，保证 $T\le 10$，$n\le 10$；

对于 $40\%$ 的数据，保证 $T\le 20$，$n\le 10^3$；

另有 $10\%$ 的数据，保证 $c_i=1$；

对于 $100\%$ 的数据，保证 $1 \le T \le 10^5$，$1 \le n,\sum n\le 2 \times 10^6$，$c_i \in \{0,1\}$，$1 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
2
6
1 1 4 5 1 4
1 0 0 1 0 1
8
3 1 4 1 5 9 2 6
1 0 1 0 1 0 1 0```

### 输出

```
5
13```

# AI分析结果



### **题解思路、算法要点与解决难点**

#### **核心贪心思路**
1. **情况1：首尾类型相同（c₁ = cₙ）**
   - **直接选择整个区间**，总花费为 a₁ + aₙ。
   - **正确性证明**：任何其他分割方式都会包含 a₁ 和 aₙ，且中间操作的花费必然更大（因 a_i > 0）。

2. **情况2：首尾类型不同（c₁ ≠ cₙ）**
   - **寻找分割点 i**，使得 cᵢ = c₁ 且 c_{i+1} = cₙ，总花费为 a₁ + aᵢ + a_{i+1} + aₙ。
   - **正确性证明**：必须存在这样的分割点（反证法），且两段操作总花费最优（多段操作必然更劣）。

#### **动态规划思路**
- **状态定义**：`dp[i]` 表示清理前 i 块的最小花费。
- **转移方程**：`dp[i] = min(前缀最小值[cᵢ] + aᵢ)`，维护类型为 0/1 的前缀最小值。
- **优化**：用两个变量分别记录类型 0/1 的最小前缀，复杂度 O(n)。

#### **解决难点**
1. **贪心策略的构造**：需发现首尾类型的特殊性质，并证明分割点的存在性。
2. **动态规划的优化**：将 O(n²) 转移优化为 O(n)，通过前缀最小值避免重复计算。

---

### **题解评分 (≥4星)**

| 题解作者       | 评分 | 关键亮点                                                                 |
|----------------|------|--------------------------------------------------------------------------|
| _JF_           | ★★★★★ | 思路清晰，代码简洁，贪心策略证明严谨。                                   |
| Iniaugoty      | ★★★★☆ | 动态规划优化思路巧妙，但代码实现稍复杂。                                 |
| GeorgeAAAADHD  | ★★★★☆ | 贪心思路详细，代码简洁，但证明部分可进一步展开。                         |

---

### **最优思路或技巧提炼**

1. **首尾特性利用**  
   - 若首尾类型相同，直接选整个区间；否则找中间分割点。
   - **关键点**：首尾必选，且中间分割点必存在。

2. **前缀最小值维护**  
   - 动态规划中，通过维护类型 0/1 的最小前缀，将复杂度从 O(n²) 优化到 O(n)。

---

### **同类型题或算法套路**

1. **区间合并类问题**  
   - 如 [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：贪心选择最小代价合并。
2. **分割点选择问题**  
   - 如 [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)：动态规划分割区间。
3. **前缀优化动态规划**  
   - 如 [P2513 逆序对数列](https://www.luogu.com.cn/problem/P2513)：维护前缀和优化状态转移。

---

### **推荐相似题目**

1. [P1220 关路灯](https://www.luogu.com.cn/problem/P1220)  
   - **考察点**：区间动态规划，状态转移优化。
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)  
   - **考察点**：动态规划基础，贪心与背包结合。
3. [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)  
   - **考察点**：贪心选择局部最优解。

---

### **个人心得摘录**

- **反证法的重要性**：在贪心策略中，通过反证法证明分割点存在性，是理解问题的关键。
- **调试教训**：未开 `long long` 导致溢出（多个题解提到此问题）。

---

### **可视化与算法演示**

#### **贪心算法动画设计**
1. **初始状态**：展示地板序列，用不同颜色标记类型（0/1）。
2. **情况1（c₁ = cₙ）**：
   - **高亮首尾**，合并为绿色区间，显示总花费 `a₁ + aₙ`。
3. **情况2（c₁ ≠ cₙ）**：
   - **遍历寻找分割点**，动态标记满足 `cᵢ = c₁` 和 `c_{i+1} = cₙ` 的位置。
   - **对比不同分割点**的总花费，最终选择最小值。

#### **复古像素风格设计**
- **Canvas 绘制**：地板用 16x16 像素块表示，类型 0（蓝色）、1（红色）。
- **音效设计**：
  - **选择分割点**：8-bit 点击音效。
  - **错误操作**：短促蜂鸣声。
- **自动演示模式**：AI 自动遍历分割点，高亮最优解。

#### **交互功能**
- **步进控制**：允许单步执行，观察每一步的决策。
- **参数调节**：动态调整地板数量，观察算法变化。

---

### **核心代码实现**

#### **贪心算法（_JF_ 题解）**
```cpp
if (c[1] == c[n]) {
    cout << a[1] + a[n] << endl;
} else {
    int ans = LONG_LONG_MAX;
    for (int i = 1; i < n; i++) {
        if (c[i] == c[1] && c[i+1] == c[n]) {
            ans = min(ans, a[1] + a[i] + a[i+1] + a[n]);
        }
    }
    cout << ans << endl;
}
```

#### **动态规划（Iniaugoty 题解）**
```cpp
long long ans1 = 1e15, ans2 = 1e15;
for (int i = 1; i <= n; i++) {
    if (c[i] == 0) {
        ans1 = min(ans1, dp[i-1] + a[i]);
        dp[i] = ans1 + a[i];
    } else {
        ans2 = min(ans2, dp[i-1] + a[i]);
        dp[i] = ans2 + a[i];
    }
}
```

---

### **总结**
- **最优解法**：贪心策略因其简洁性和高效性更优。
- **思维突破点**：利用首尾特性减少问题复杂度。
- **可视化亮点**：复古像素动画与音效增强理解趣味性。

---
处理用时：77.73秒
# 题目信息

# 「EZEC-14」众数 I

## 题目背景

pigstd 是一个可爱的男孩子。他在 NOI2022 中的众数一题定义了 $10^6$ 个 ``std::deque`` 并没有 MLE。

## 题目描述

给定一个长度为 $n$ 的序列 $a$，我们通过以下方式构造序列 $b$：

- 初始时 $b=a$。
- 依次对 $b$ 进行 $k$ 次操作，每次操作选择任意一个元素并将其**修改**为任意整数。

dXqwq 定义一个序列的**众数**为所有出现次数最大的数。例如 $[1,1,4,5,1,4]$ 的众数为 $1$，而 $[1,14,5,14,19,19,8,10]$ 的众数为 $14,19$。

你需要求出有多少整数可能成为 $b$ 的**众数**。

## 说明/提示

**【样例解释】**

对于第一组数据，最终 $1,2,3,4,5$ 可能为区间众数。

对于第二组数据，将第一个数换成 $6,7,8,9,\cdots$ 后它们均会成为区间众数，因此答案为正无穷。

对于第三组数据，$1,2,3$ 可能成为区间众数。

**【提示】**

开 $10^6$ 个 ``std::deque`` 在空间限制为 1024MB 时不一定会 MLE。

**【数据范围】**

**本题采用捆绑测试。**

* Subtask 1（20 pts）：$n\leq 5$。
* Subtask 2（20 pts）：$n\leq 10^3$。
* Subtask 3（20 pts）：$k=0$。
* Subtask 4（20 pts）：$k=1$。
* Subtask 5（20 pts）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n\leq 10^6$，$0\leq k\leq n $，$1\leq a_i\leq n$。

## 样例 #1

### 输入

```
5 0
1 2 3 4 5```

### 输出

```
5```

## 样例 #2

### 输入

```
5 1
1 2 3 4 5```

### 输出

```
pigstd```

## 样例 #3

### 输入

```
5 1
1 1 2 2 3```

### 输出

```
3```

# AI分析结果



### 题解思路与算法要点

#### 核心贪心思路与推导
所有题解的核心思路均为：通过修改操作最大化目标数的出现次数，同时尽可能减少其他数的出现次数。最优策略为每次选择当前最大出现次数的数值进行修改（贪心减少最大阻碍）。

#### 解决难点与验证方法
1. **最优性验证**：通过数学证明每次减少当前最大出现次数是最优策略（反证法：若存在更优策略，则总操作次数不会更少）。
2. **高效维护最大出现次数**：使用优先队列（堆）或排序+指针跳跃实现 O(1) 取最大值。
3. **统计满足条件的数**：通过前缀和快速计算需要减少的总次数是否 ≤k。

#### 数据结构与优化手段
| 方法               | 数据结构       | 时间复杂度 | 核心优化点                      |
|--------------------|---------------|------------|--------------------------------|
| 优先队列模拟       | 大根堆         | O(n + k log n) | 动态维护当前最大值             |
| 排序+前缀和        | 数组+前缀和    | O(n)       | 预处理出现次数并排序，利用前缀和公式快速计算 |
| 二分法             | 二分+桶计数    | O(n log n) | 二分目标出现次数，桶计数验证    |

---

### 题解评分 (≥4星)
1. **dead_X 的解法（5星）**
   - 思路清晰度：⭐️⭐️⭐️⭐️⭐️  
   - 代码可读性：⭐️⭐️⭐️⭐️  
   - 算法优化度：⭐️⭐️⭐️⭐️⭐️  
   - 核心亮点：O(n) 时间复杂度，利用排序与前缀和公式 $\sum \max(c_j - x, 0) \leq k$ 快速验证。

2. **ys_kylin__ 的解法（4星）**
   - 思路清晰度：⭐️⭐️⭐️⭐️  
   - 代码可读性：⭐️⭐️⭐️  
   - 算法优化度：⭐️⭐️⭐️⭐️  
   - 核心亮点：二分目标出现次数，桶计数验证，适合理解贪心与二分的结合。

3. **Light_az 的解法（4星）**
   - 思路清晰度：⭐️⭐️⭐️⭐️  
   - 代码可读性：⭐️⭐️⭐️⭐️  
   - 算法优化度：⭐️⭐️⭐️  
   - 核心亮点：优先队列动态维护最大值，直观展示贪心过程。

---

### 最优思路提炼
**前缀和公式法（dead_X）**  
1. 预处理出现次数并降序排序。
2. 对每个候选数 x，计算其需要的最小出现次数阈值 t = x + k。
3. 使用前缀和快速计算所有比 t 大的数的总减少量：$\sum (c_j - t) \leq k$。
4. 满足条件时统计答案。

#### 核心代码片段
```cpp
sort(cnt + 1, cnt + 1 + n, greater<int>());
for (int i = 1; i <= n; i++) sum[i] = sum[i-1] + cnt[i];
int l = 0, r = n;
while (l < r) {
    int mid = (l + r) >> 1;
    if (check(mid)) r = mid;
    else l = mid + 1;
}
// check函数计算总减少量是否≤k
```

---

### 相似题目推荐
1. **[洛谷 P1177](https://www.luogu.com.cn/problem/P1177)** - 众数统计（基础版）  
2. **[LeetCode 169. Majority Element](https://leetcode.com/problems/majority-element/)** - 多数元素  
3. **[CodeForces 1370D. Odd-Even Subsequence](https://codeforces.com/problemset/problem/1370/D)** - 贪心选择极值

---

### 可视化与算法演示设计
#### 复古像素风格贪心动画
1. **元素表示**：  
   - 每个数值以 16x16 像素方块表示，颜色随机生成。  
   - 出现次数以方块高度动态变化（类似柱状图）。

2. **贪心过程演示**：  
   - **当前最大值**：红色边框高亮。  
   - **操作步骤**：每次点击“Next”按钮，从堆顶取出最大值，高度减 1 后放回堆，播放 8-bit 音效。  
   - **自动模式**：AI 自动执行贪心操作，速度可调（1x/2x/4x）。

3. **音效设计**：  
   - 取出最大值：高音“哔”声。  
   - 修改操作：中音“咔”声。  
   - 完成验证：胜利音效。

#### 交互示例（伪代码）
```javascript
class PixelHeap {
  constructor(data) {
    this.heap = [...data].sort((a, b) => b - a);
    this.canvas = initCanvas(); // 初始化像素画布
  }

  autoPlay(speed) {
    let step = 0;
    const interval = setInterval(() => {
      if (step >= k) {
        clearInterval(interval);
        playVictorySound();
        return;
      }
      this.reduceMax();
      step++;
    }, 1000 / speed);
  }

  reduceMax() {
    const maxVal = this.heap[0];
    drawHighlight(maxVal); // 红色高亮当前最大值
    playSelectSound();
    this.heap[0]--;
    reheapify();
    drawUpdate(); // 更新柱状图高度
  }
}
```

---

### 总结与扩展
本题解展示了贪心算法与高效数据结构的结合，重点在于如何通过数学推导将问题转化为可快速验证的前缀和公式。同类问题中，若涉及极值动态调整，优先队列和排序预处理是常用优化手段。

---
处理用时：73.73秒
# 题目信息

# 「MXOI Round 2」排名

## 题目描述

小 C 有一个长度为 $n$ 的数组 $a$。

小 C 定义，$f(i)$ 为 $a_i$ 的前排名，其中 $f(i)$ 等于数组 $a$ 中大于 $a_i$ 的元素个数加 $1$。

小 C 还定义，$g(i)$ 为 $a_i$ 的后排名，其中 $g(i)$ 等于数组 $a$ 中大于等于 $a_i$ 的元素个数。

每次操作，小 C 需要选择一个不大于 $n$ 的正整数 $t$，并将 $a_t$ 的值增加 $1$。

小 C 想知道，对于每一个 $1 \le i \le n$，想要使 $f(i) \le k \le g(i)$，最少需要进行多少次操作？

可以证明一定存在一种操作方案使得 $f(i) \le k \le g(i)$。

## 说明/提示

#### 【样例解释 #1】

当 $i=1$ 时，小 C 可以选择 $t=1$ 并进行 $3$ 次操作。此时 $f(i)=2$，$g(i)=4$，满足 $f(i) \le k \le g(i)$。可以证明此时小 C 至少需要进行 $3$ 次操作。

当 $i=4$ 时，小 C 可以选择 $t=3$ 进行 $1$ 次操作，再选择 $t=6$ 进行 $1$ 次操作。此时 $f(i)=1$，$g(i)=3$，满足 $f(i) \le k \le g(i)$。可以证明此时小 C 至少需要进行 $2$ 次操作。

#### 【样例 #2】

见附加文件中的 `rank/rank2.in` 与 `rank/rank2.ans`。

该样例满足测试点 $7$ 的限制。

#### 【样例 #3】

见附加文件中的 `rank/rank3.in` 与 `rank/rank3.ans`。

该样例满足测试点 $20$ 的限制。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le k \le n \le 5 \times 10^5$，$1 \le a_i \le 10^9$。

|测试点编号|$n \le$|$a_i \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1\sim6$|$2000$|$10^9$|A|
|$7\sim10$|$2000$|$10^9$|无|
|$11\sim14$|$5\times10^5$|$10^9$|B|
|$15\sim20$|$5\times10^5$|$10^9$|无|

特殊性质 A：保证对于所有的 $1 \le i \lt n$，都有 $a_i \ge a_{i+1}$。

特殊性质 B：保证 $k=1$。

## 样例 #1

### 输入

```
0 6 3
1 1 4 5 1 4```

### 输出

```
3
3
0
2
3
0```

# AI分析结果



### 综合分析与结论  
**题目核心**：通过贪心策略调整元素，使其在排序后的位置满足 f(i) ≤k ≤g(i)。  
**核心贪心策略**：  
1. **排序**：将数组从大到小排序，确定第k大的元素。  
2. **分情况处理**：  
   - 若当前元素 < 第k大元素：需增加自身至第k大元素的数值（操作次数为差值）。  
   - 若当前元素 > 第k大元素：需将排序后当前位置到第k大的所有元素提升至当前值（利用前缀和快速计算总和）。  
   - 若相等则无需操作。  
**难点**：正确分情况并高效计算操作次数（前缀和优化）。  

---

### 题解清单（≥4星）  
1. **卷王（5星）**  
   - **亮点**：思路清晰，代码简洁，前缀和优化。  
   - **关键代码**：  
     ```cpp  
     for(int i=1; i<=n; i++) {  
         if(a[i].x < a[k].x) ans[a[i].num] = a[k].x - a[i].x;  
         else ans[a[i].num] = (k - i) * a[i].x - (sum[k] - sum[i]);  
     }  
     ```  

2. **Coffee_zzz（4星）**  
   - **亮点**：详细分情况证明，动态规划优化。  
   - **关键思路**：用 `dp[i]` 表示调整后续元素的代价。  

3. **XiaoQuQu（4星）**  
   - **亮点**：强调排序后位置关系，数学公式推导。  
   - **关键公式**：  
     $$ \text{操作次数} = (k - i) \cdot a_i - \sum_{j=i+1}^k a_j $$  

---

### 最优思路与技巧提炼  
1. **排序与分治**：  
   - 排序后，问题转化为位置关系问题。  
   - 第k大的元素是分界点（若从小到大排序则为第n-k+1个元素）。  

2. **前缀和优化**：  
   - 预处理排序后的前缀和数组，快速计算区间和。  
   - 公式：操作次数 = 目标值 × 数量 - 区间和。  

3. **贪心选择依据**：  
   - **元素过大**：只需调整自身至第k大的值。  
   - **元素过小**：调整后续最接近的k-i个元素。  

---

### 同类型题与算法套路  
1. **区间调度问题**：如选择最多不重叠区间（按右端点排序）。  
2. **最小代价调整**：如使数组满足单调性的最小操作次数（前缀和/差分）。  
3. **Top-K 问题**：如快速定位第K大元素。  

---

### 推荐相似题目  
1. **P1090 合并果子**（贪心+优先队列）。  
2. **P1106 删数问题**（贪心删除数字形成最小数）。  
3. **P1607 Fair Shuttle**（区间贪心选择）。  

---

### 可视化与算法演示设计  
**贪心过程动画设计**：  
1. **像素风格排序数组**：  
   - 用Canvas绘制从大到小排列的方块，颜色区分不同区间。  
   - 高亮第k大的元素（如红色边框）。  

2. **交互操作**：  
   - **点击元素**：显示其f(i)和g(i)值，判断是否需要调整。  
   - **动态计算**：调整时显示前缀和计算过程（如绿色覆盖调整区域）。  

3. **音效与动画**：  
   - **调整成功**：播放上升音效。  
   - **错误尝试**：播放低沉音效。  

**代码片段（JS伪代码）**：  
```javascript  
// 排序并绘制像素方块  
const sortedArray = originalArray.sort((a, b) => b - a);  
drawPixelGrid(sortedArray, kIndex);  

// 贪心调整动画  
function animateAdjustment(i) {  
    if (sortedArray[i] < sortedArray[kIndex]) {  
        highlightElement(i, 'blue');  
        playSound('up');  
    } else {  
        highlightRange(i + 1, kIndex, 'green');  
        playSound('coin');  
    }  
}  
```  

---

### 核心代码实现  
**卷王题解的关键逻辑**：  
```cpp  
sort(a + 1, a + n + 1, cmp); // 从大到小排序  
for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + a[i].x;  

for (int i = 1; i <= n; i++) {  
    if (a[i].x < a[k].x)  
        ans[a[i].num] = a[k].x - a[i].x;  
    else  
        ans[a[i].num] = (k - i) * a[i].x - (sum[k] - sum[i]);  
}  
```

---
处理用时：72.28秒
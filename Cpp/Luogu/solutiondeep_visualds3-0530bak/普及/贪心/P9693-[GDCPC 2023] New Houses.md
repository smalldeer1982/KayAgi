# 题目信息

# [GDCPC 2023] New Houses

## 题目描述

随着广东的建设与发展，越来越多人选择来到广东开始新生活。在一片新建的小区，有 $n$ 个人要搬进 $m$ 栋排成一行的房子，房子的编号从 $1$ 到 $m$（含两端）。房子 $u$ 和 $v$ 相邻，当且仅当 $|u-v|=1$。我们需要为每一个人安排一栋房子，要求所有人入住的房子互不相同。若两个人住进了一对相邻的房子，则这两个人互为邻居。

有的人喜欢自己有邻居，而有的人不喜欢。对于第 $i$ 个人，如果他有至少一位邻居，则他的满意度为 $a_i$；否则如果他没有邻居，则他的满意度为 $b_i$。

您作为小区的规划者，需要最大化所有人的总满意度。

## 样例 #1

### 输入

```
3
4 5
1 100
100 1
100 1
100 1
2 2
1 10
1 10
2 3
100 50
1 1000```

### 输出

```
400
2
1050```

# AI分析结果



## 算法分类
贪心算法

## 题解思路与解决难点
### 核心思路
1. **初始假设**：所有人独居，总满意度为 $\sum b_i$。
2. **贪心策略**：将 $a_i - b_i$ 从大到小排序，优先选择差值大的个体转为有邻居，从而提升总满意度。
3. **条件约束**：当 $x$ 个人有邻居时，需满足总房子数 $2n - x \le m$。其中：
   - $x=0$ 时需满足 $2n-1 \le m$；
   - $x \ge 1$ 时需满足 $x \ge 2n - m$。

### 关键难点
1. **房子数量约束**：正确计算不同 $x$ 对应的总房子数，确保合法。
2. **边界条件处理**：如 $x=1$ 是否被考虑（部分题解因未枚举 $x=1$ 导致错误）。
3. **前缀和优化**：快速计算不同 $x$ 下的总满意度。

### 算法流程
1. 对所有个体按 $a_i - b_i$ 降序排序。
2. 计算初始总满意度（全独居，若合法）。
3. 枚举 $x$ 的可能值（包括 $x=0$ 和 $x \ge 1$），计算总满意度并取最大值。

---

## 题解评分 (≥4星)
1. **I_am_AKed_by_NOI（4星）**
   - **亮点**：前缀和优化清晰，代码简洁。
   - **缺点**：循环从 $x=2$ 开始，漏判 $x=1$ 的情况。
2. **Zaku（4星）**
   - **亮点**：数学推导完整，逻辑清晰。
   - **缺点**：同前，未处理 $x=1$。
3. **minVan（4星）**
   - **亮点**：特判 $n=1$ 和边界条件处理较好。
   - **缺点**：仍存在 $x=1$ 遗漏问题。

---

## 最优思路提炼
1. **贪心排序**：按 $a_i - b_i$ 降序排序，优先选择收益最大的个体调整状态。
2. **房子数约束**：对于每个 $x$，计算 $2n - x \le m$ 并验证合法性。
3. **前缀和优化**：预处理前缀和快速计算不同 $x$ 的总满意度。

---

## 相似题目推荐
1. **P1056 排座椅**：贪心选择最优分割点。
2. **P1233 木棍加工**：贪心与排序结合。
3. **P1094 纪念品分组**：双指针贪心配对。

---

## 可视化设计
### 算法动画演示
1. **动态更新**：以颜色标记当前处理的个体（红色为有邻居，蓝色为独居）。
2. **房子布局**：用网格展示房子排列，高亮当前占用的房子。
3. **实时统计**：显示当前总满意度和剩余房子数。
4. **步进控制**：允许手动调整 $x$，观察不同情况下的结果变化。

### 复古像素风格
- **颜色方案**：8-bit 调色板（红、蓝、绿）。
- **音效**：关键操作触发 8-bit 音效，背景音乐循环播放。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 5e5 + 5;
struct Node { ll a, b; } v[N];
ll sumA[N], sumB[N];

bool cmp(Node &x, Node &y) { return (x.a - x.b) > (y.a - y.b); }

int main() {
    int T; cin >> T;
    while (T--) {
        int n, m; cin >> n >> m;
        for (int i = 1; i <= n; i++) cin >> v[i].a >> v[i].b;
        sort(v + 1, v + n + 1, cmp);
        
        // 前缀和初始化
        for (int i = 1; i <= n; i++) {
            sumA[i] = sumA[i - 1] + v[i].a;
            sumB[i] = sumB[i - 1] + v[i].b;
        }
        
        ll ans = (2 * n - 1 <= m) ? sumB[n] : 0;
        for (int x = 1; x <= n; x++) { // 修正：从 x=1 开始枚举
            if (2 * n - x <= m) {
                ans = max(ans, sumA[x] + sumB[n] - sumB[x]);
            }
        }
        cout << ans << '\n';
    }
    return 0;
}
```

---

## 总结与扩展
本题解通过贪心策略最大化总满意度，关键点在于正确处理房子数约束和边界条件。在实际编码中需注意枚举所有可能的 $x$，避免遗漏可能的最优解。同类问题可借鉴贪心排序与条件约束的结合思路。

---
处理用时：404.30秒
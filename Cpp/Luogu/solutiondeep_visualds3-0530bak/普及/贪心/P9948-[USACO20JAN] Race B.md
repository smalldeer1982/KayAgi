# 题目信息

# [USACO20JAN] Race B

## 题目描述

Bessie 正在参加一场 $K$（$1\le K\le 10^9$）米的跑步比赛。她从 $0$ 米每秒的速度开始比赛。在每一秒中，她可以选择将她的速度增加 $1$ 米每秒，保持速度不变，或者将她的速度减少 $1$ 米每秒。例如，在第一秒中，她可以将她的速度增加到 $1$ 米每秒，跑 $1$ 米，或者保持她的速度 $0$ 米每秒不变，跑 $0$ 米。Bessie 的速度不会降低到小于零。

Bessie 始终朝着终点线的方向跑，她想要花费整数秒的时间完成比赛。此外，她不想在终点时跑得太快：在 Bessie 跑完 $K$ 米的时刻，她希望她的速度不超过 $X$（$1\le X\le 10^5$）米每秒。Bessie 想要对于 $N$（$1\le N\le 1000$）个不同的 $X$ 值知道她多快可以完成比赛。 

## 说明/提示

### 样例解释 1

当 $X=1$ 时，一种最优方案为：

1. 将速度增加到 $1$ 米/秒，跑 $1$ 米
2. 将速度增加到 $2$ 米/秒，跑 $2$ 米，总计跑 $3$ 米
3. 将速度保持在 $2$ 米/秒，总计跑 $5$ 米
4. 将速度保持在 $2$ 米/秒，总计跑 $7$ 米
5. 将速度保持在 $2$ 米/秒，总计跑 $9$ 米
6. 将速度降低到 $1$ 米/秒，总计跑 $10$ 米

当 $X=3$ 时，一种最优方案为：

1. 将速度增加到 $1$ 米/秒，跑 $1$ 米
2. 将速度增加到 $2$ 米/秒，总计跑 $3$ 米
3. 将速度增加到 $3$ 米/秒，总计跑 $6$ 米
4. 将速度保持在 $3$ 米/秒，总计跑 $9$ 米
5. 将速度保持在 $3$ 米/秒，总计跑 $12$ 米

注意当 $X=3$ 时，以下方案是不合法的：

1. 将速度增加到 $1$ 米/秒，跑 $1$ 米
2. 将速度增加到 $2$ 米/秒，总计跑 $3$ 米
3. 将速度增加到 $3$ 米/秒，总计跑 $6$ 米
4. 将速度增加到 $4$ 米/秒，总计跑 $10$ 米

这是因为在 Bessie 跑完 $10$ 米的时刻，她的速度是 $4$ 米/秒。 

## 样例 #1

### 输入

```
10 5
1
2
3
4
5```

### 输出

```
6
5
5
4
4```

# AI分析结果



### 综合分析与结论

本题的核心在于在满足终点速度限制的前提下，找到最短时间。各题解主要采用**贪心策略**、**数学推导**或**二分法**。贪心的核心思路是尽可能加速到最大速度后减速至X，数学与二分法则通过公式快速验证时间可行性。难点在于正确处理加速与减速阶段的路程计算，确保终点速度不超限。

#### 关键贪心策略
1. **加速至X以上后减速**：在时间允许的情况下，先加速到最大速度，再减速至X，最大化总路程。
2. **数学分段计算**：将路程拆分为加速段（1到maxv）和减速段（maxv到X），利用等差数列求和公式快速计算总距离。
3. **二分时间验证**：通过二分法快速定位最短时间，结合数学公式验证该时间下是否可行。

---

### 题解评分（≥4星）

1. **Treap_Kongzs（4.5星）**  
   - **亮点**：模拟加速与减速过程，分阶段累加路程，直观易理解。时间复杂度O(n√K)可接受，代码简洁。  
   - **心得**：“化繁为简，信息学竞赛的魅力在于用代码优雅处理复杂情况。”

2. **superLouis（4.5星）**  
   - **亮点**：数学公式推导+二分法，时间复杂度O(n log T)最优。代码清晰，公式推导严谨。  
   - **踩坑**：未用long long导致WA，强调数据类型的重要性。

3. **Misserina（4星）**  
   - **亮点**：简洁的二分实现，核心逻辑与superLouis一致，但代码更短，适合快速实现。

---

### 最优思路与代码实现

#### 核心思路（二分法）
1. **二分时间t**：检查在时间t内是否能跑完K米且终点速度≤X。
2. **数学分段计算**：分加速段（1到maxv）和减速段（maxv到X），利用等差数列求和。
3. **公式推导**：若时间足够长，maxv=(t+X)/2，总路程为加速段和减速段之和。

```cpp
int maxlen(int t, int x) {
    if (t <= x) return (t * (t + 1)) / 2; // 直接加速到t
    int maxv = (t + x) / 2;
    int sum_up = (maxv * (maxv + 1)) / 2; // 加速段
    int steps = t - maxv; // 剩余时间用于减速
    int sum_down = (maxv + x) * (maxv - x + 1) / 2; // 减速段
    return sum_up + sum_down - (steps < (maxv - x + 1) ? (maxv - x + 1 - steps) * x : 0);
}

// 二分主逻辑
int solve(int K, int X) {
    int left = 1, right = 2e5, ans = 1e9;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (maxlen(mid, X) >= K) {
            ans = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return ans;
}
```

---

### 同类题目推荐
1. **P1095 守望者的逃离**：时间与移动距离的贪心计算。
2. **P1664 每日打卡**：连续打卡奖励的贪心策略。
3. **P1809 过河问题**：贪心或动态规划处理时间优化。

---

### 可视化设计（复古像素风格）

1. **动画设计**  
   - **像素速度曲线**：用Canvas绘制速度随时间变化的折线图，红色标记加速段，蓝色标记减速段。
   - **实时累计距离**：右侧面板显示每秒的累计距离，绿色进度条表示K米的完成度。

2. **交互功能**  
   - **步进控制**：按钮控制单步执行，高亮当前速度变化。
   - **音效反馈**：加速时播放上升音调，减速时下降音调，达标时播放胜利音效。

3. **代码片段（JS）**  
```javascript
// 绘制速度曲线
function drawSpeedGraph(ctx, speeds) {
    ctx.clearRect(0, 0, 800, 200);
    speeds.forEach((v, t) => {
        ctx.fillStyle = t === currentStep ? '#FF0000' : '#0000FF';
        ctx.fillRect(t * 10, 200 - v * 20, 8, 8);
    });
}
// 更新动画帧
function update() {
    if (autoPlay && currentStep < maxSteps) {
        currentStep++;
        drawSpeedGraph(ctx, speedHistory);
        checkFinish();
    }
    requestAnimationFrame(update);
}
```

---

### 个人心得摘录
- **superLouis**：“不开long long见祖宗，验证数学公式时需注意溢出问题。”
- **Treap_Kongzs**：“模拟过程看似繁琐，但正确划分阶段后代码反而简洁。”

---
处理用时：86.03秒
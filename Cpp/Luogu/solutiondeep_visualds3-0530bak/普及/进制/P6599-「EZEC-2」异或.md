# 题目信息

# 「EZEC-2」异或

## 题目描述

有 $T$ 组询问，每次给定两个正整数 $n,l$，   

你需要构造一个长度为 $l$ 的正整数序列 $a$（编号从 $1$ 至 $l$），   

且满足 $\forall i\in[1,l]$，都有 $a_i\in[1,n]$。

求：

$$\sum_{i=1}^l\sum_{j=1}^{i-1}a_i\oplus a_j$$

的最大值。

为了避免答案过大，对于每组询问，只需要输出这个最大值对 $10^9+7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**   
当 $n=2,l=3$，$a$ 取 $\{1,2,1\}$ 的任一排列时可以得到最大值，为 $(1\oplus2)+(1\oplus1)+(2\oplus1)=6$，易证明此时原式有最大值。

---
**【数据规模与约定】**
| 测试点编号 | $T\le$ | $n\le$ | $l\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim5$ | $1$ | $10$ | $5$ |
| $6$ | $5\times 10^5$ | $10^{12}$ | $2$ |
| $7$ | $5\times 10^5$ | $10^{12}$ | $3$ |
| $8\sim10$ | $5\times 10^5$ | $10^{12}$ | $10^5$ |

对于 $100\%$ 的数据，满足 $1\le T\le 5\times10^5$，$1\le n\le 10^{12}$，$2\le l \le 10^5$。


---
**【提示】**

1. 「$\oplus$」是按位异或符号。如果您不知道什么是按位异或，可以参考[这里](https://oi-wiki.org/math/bit/#_1)。
2. 取模是一种运算，$a$ 对 $b$ 取模代表将 $a$ 赋值为 $a$ 除以 $b$ 所得到的余数。  
在 C++ / Python 中的取模符号为 `%`，在 Pascal 中的取模符号为 `mod`。
3. $\sum$ 是求和符号。如果您不知道什么是 $\sum$ 符号，可以参考[这里](https://baike.baidu.com/item/∑/1233796?fr=aladdin)。
4. 请注意数据的读入输出对程序效率造成的影响。

## 样例 #1

### 输入

```
1
2 3
```

### 输出

```
6```

## 样例 #2

### 输入

```
2
114 514
1919 180
```

### 输出

```
8388223
16580700```

# AI分析结果



---

**唯一算法分类**  
贪心（位运算）

**综合分析与结论**  
本题的核心在于按位分解异或和的贡献，通过贪心策略最大化每位贡献。每位贡献由0和1的数量乘积决定，最优时取数量接近半数。关键在于确定n的二进制最高位，并计算所有有效位的贡献总和。

**题解清单 (≥4星)**  
- **君のNOIP.的题解（5星）**  
  预处理各二进制位的贡献之和，避免溢出，代码高效且思路清晰。  
  亮点：预处理数组简化计算，正确模运算处理，时间复杂度O(1)。

**最优思路或技巧提炼**  
1. **按位贡献拆分**：异或运算按位独立，每位贡献为0/1数量乘积乘以权值。  
2. **贪心构造**：每位尽可能使0和1数量相等，最大化贡献。  
3. **模运算优化**：预处理贡献数组并取模，避免中间步骤溢出。

**同类型题或类似算法套路**  
- 位运算分治：如求数组中所有数对的异或和最大值。  
- 贪心构造策略：类似背包问题中最大化位权。

**推荐相似题目**  
1. [P2114 [NOI2014] 起床困难综合症](https://www.luogu.com.cn/problem/P2114)  
2. [P6102 [EER2]谔运算](https://www.luogu.com.cn/problem/P6102)  
3. [P2260 [清华集训2012] 模积和](https://www.luogu.com.cn/problem/P2260)

**代码片段（君のNOIP.的代码）**  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define mod 1000000007
int T;
LL n, m, slg[50];
int main() { 
    slg[0] = 1;
    for(int i=1; i<=40; i++) slg[i] = (slg[i-1] + ((LL)1<<i) ) % mod;
    scanf("%d",&T);
    while(T--) {
        scanf("%lld%lld",&n,&l);
        if(n == 1) printf("%d\n", 0);
        else printf("%lld\n", (l / 2) * (l - l / 2) % mod * slg[(int)log2(n)] % mod);
    }
}
```

**可视化与算法演示**  
1. **像素动画设计**：  
   - **颜色标记**：每位二进制权值用不同颜色方块表示，选中位（贡献有效）高亮。  
   - **动态累加**：每一步显示当前位的贡献计算，并更新总和。  
   - **音效反馈**：选中有效位时播放“点击”音效，总和更新时播放确认音。  
2. **交互控制**：支持步进、自动播放，查看每位贡献计算细节。  
3. **复古风格**：采用8位像素风格，权值块以FC游戏机风格呈现。

**可视化示例（伪代码）**  
```javascript
// Canvas绘制核心逻辑
function drawBitContribution(bit, value) {
    ctx.fillStyle = bitColors[bit];
    ctx.fillRect(x, y, blockSize, blockSize);
    ctx.fillText(`2^${bit} = ${value}`, x, y);
}

// 自动播放演示
function autoPlay() {
    let bit = highestBit;
    while (bit >= 0) {
        if ((n >> bit) & 1) {
            highlightBit(bit);
            accumulateContribution(bit);
            playSound('click');
        }
        bit--;
    }
}
```

---
处理用时：360.85秒
# 题目信息

# 「WHOI-4」折纸

## 题目背景

吉尼斯记录：一张纸（如果接近 $4$ 公里的卫生纸可以算作一张纸）最多可以对折 $13$ 次。小 X 吹牛说打破了这个记录，但是吹太大了。

## 题目描述

小 X 向吉尼斯世界纪录组织申请了这个记录，但是他正好隔离在家，无法证明。他只好允许他们问 $t$ 个问题，确认他确实打破了记录。

他们每个问题可以要求小 X 把一张纸按照一个给定 $01$ 串 $s$ 的规则对折 $n$ 次后展开。对于第 $i$ 次折叠，如果 $s_i=0$，将纸从左到右对折，使左边对齐右边；如果 $s_i=1$，将纸从右到左对折，使右边对齐左边。对折全部是从上方翻。**接下来将会展开，展开后纸片在原位，只是保留了折痕。看看自己是否实现了这一点。**

他们想要知道，从左往右数第 $k$ 个折痕是峰折（向上突起的折痕）还是谷折（向下凹陷的折痕）。如果该询问的答案是峰折，输出 `Up`；否则输出 `Down`。请你帮帮可怜的小 X。

峰折，谷折的图示见样例解释。

## 说明/提示

**样例解释**

样例 #1 解释：

动态地址：[here](https://img-blog.csdnimg.cn/c68f2ba917504417b109eb1606f4a3a5.gif)。不知道为什么洛谷显示不了了。

![](https://cdn.luogu.com.cn/upload/image_hosting/wguzrqz6.png)

由于技术原因，动图帧数略低。

样例 #2 请手动模拟。

**数据范围**

**本题采用捆绑测试。**

- Subtask 1（$20$ pts）：$t=10$，$1\le n\le5$；
- Subtask 2（$80$ pts）：$t=10^5$。

对于 $100\%$ 的数据，有 $1\le t\le 10^5$，$1\le n\le60$，$1\le k<2^n$。

## 样例 #1

### 输入

```
7
3 1
010
3 2
010
3 3
010
3 4
010
3 5
010
3 6
010
3 7
010```

### 输出

```
Down
Up
Up
Down
Down
Down
Up```

## 样例 #2

### 输入

```
7
3 1
011
3 2
011
3 3
011
3 4
011
3 5
011
3 6
011
3 7
011```

### 输出

```
Down
Up
Up
Down
Down
Down
Up
```

## 样例 #3

### 输入

```
2
13 114
1101101111010
13 514
1101101111010```

### 输出

```
Up
Up```

# AI分析结果



## 算法分类
**二进制处理/分治策略**

---

## 题解思路与核心难点

### 核心思路
- **折痕对称性**：每次折叠后的新折痕方向由折叠方向（s_i）和当前折痕位置决定。
- **二进制定位**：折痕的编号可转化为二进制位，通过逐层判断其所在区间，确定方向。
- **状态翻转**：根据折叠方向与区间位置，动态维护当前折痕方向状态（峰/谷）。

### 解决难点
- **快速定位**：需在O(n)时间内处理n次折叠，避免模拟所有折痕。
- **方向推导**：利用折叠方向（s_i）与当前区间（左/右）的异或关系，推导状态是否翻转。

---

## 题解评分（≥4星）

1. **Moon_Traveller（4.5星）**
   - **亮点**：二分法模拟折叠过程，代码简洁，逻辑清晰。通过维护`flag`状态变量，高效推导最终方向。
   - **代码可读性**：变量命名清晰，循环结构简单，适合快速理解。

2. **zfx_VeXl6（4星）**
   - **亮点**：与二分法类似，但通过异或操作简化状态翻转判断，逻辑紧凑。
   - **优化点**：代码中直接处理二进制位，减少中间变量。

3. **escapist404（4星）**
   - **亮点**：引入纸面朝向的异或模型，通过逻辑运算统一处理翻转条件，数学推导严谨。
   - **可视化适配**：适合动画演示区间缩小和状态变化。

---

## 最优思路与代码实现

### 关键思路
- **逐层二分**：将折痕编号视为一个长度为n的二进制串，每次折叠对应一位。
- **动态状态翻转**：若当前折叠方向（s_i）与折痕所在区间（左/右）组合满足条件，则翻转状态。

### 核心代码（Moon_Traveller版）
```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    int T; cin >> T;
    while (T--) {
        int n; long long k;
        string s;
        cin >> n >> k >> s;
        long long l = 1, r = (1LL << n) - 1;
        bool flag = false; // false为谷折（初始状态）
        int d = 0;
        while (l <= r) {
            long long mid = (l + r) >> 1;
            if (mid == k) {
                cout << (flag ? "Up" : "Down") << endl;
                break;
            }
            if (k < mid) {
                flag = s[d] == '1' ? !flag : flag;
                r = mid - 1;
            } else {
                flag = s[d] == '1' ? flag : !flag;
                l = mid + 1;
            }
            d++;
        }
    }
    return 0;
}
```

### 代码解释
- **逐层二分**：每次计算中间点`mid`，判断k在左半区（k < mid）或右半区。
- **状态翻转**：根据`s[d]`的值和k的位置，决定是否翻转`flag`（峰/谷状态）。
- **终止条件**：当`k == mid`时，输出当前状态。

---

## 相似题目推荐
1. **P1496 火柴棒等式**（二进制枚举与组合问题）
2. **P1010 幂次方**（二进制分解与递归表达）
3. **P1226 快速幂**（二进制位处理与分治策略）

---

## 可视化与算法演示

### 动画设计
- **像素风格界面**：用Canvas绘制纸张，每次折叠时动态分割区间，左半区标记为蓝色，右半区红色。
- **状态高亮**：当前折叠方向（s_i）用箭头表示，折叠后区间显示虚线折痕，颜色随状态（峰/谷）变化。
- **音效反馈**：折叠时播放“折叠”音效，状态翻转时播放“滴答”声，正确输出后播放胜利音效。

### 交互设计
- **步进控制**：支持暂停/继续，拖动进度条观察每一步的区间变化。
- **自动演示**：AI模式自动执行折叠，高亮当前处理的二进制位和状态变量。

---

## 总结
通过二进制分治策略，将折叠问题转化为逐层区间判断，结合动态状态翻转，高效解决大规模查询。可视化设计通过像素动画与交互式调试，直观展现算法核心逻辑。

---
处理用时：83.82秒
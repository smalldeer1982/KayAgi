# 题目信息

# 数列前缀和 2

## 题目描述

给定一个长度为 $n$ 的数列 $a$，请回答 $q$ 次询问，每次给定 $l, r$，请求出 $\prod\limits_{i = l}^r a_i \bmod p$ 的值，其中 $p = 1054^2 + 185^2$。容易证明这是一个质数。

## 说明/提示

### 样例 1 解释

三次询问的答案依次为 $6, 12, 24$，按位异或和为 $18$。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n,q \leq 10^3$。
- 对于 $60\%$ 的数据，保证 $n, q \leq 10^5$。

对于全部的测试点，保证 $1 \leq n, q \leq 10^6$，$1 \leq l \leq r \leq n$，$1 \leq a_i < p$。

### 提示
你可以在[这里](https://www.luogu.com.cn/problem/P3811)学习如何线性求逆元，请尽可能做到 $O(1)$ 回答单次询问。

## 样例 #1

### 输入

```
5 3
1 2 3 4 5
2 3
3 4
2 4```

### 输出

```
18```

# AI分析结果



---

**唯一算法分类**  
数论（模运算与逆元预处理）

---

**综合分析与结论**  

**核心思路**  
1. **前缀积数组**：预处理数组`pre`，其中`pre[i]`表示前`i`个元素的乘积模质数`p`的结果。  
2. **逆元预处理**：计算前缀积数组的逆元数组`inv_pre`，利用递推关系高效生成。  
3. **查询处理**：区间乘积模`p`可通过 `pre[r] * inv_pre[l-1] % p` 快速得到，确保每次查询时间复杂度为 O(1)。  

**难点与解决**  
- **模运算中的逆元计算**：直接计算每个前缀积的逆元会导致超时。通过费马小定理和递推关系，线性时间完成逆元预处理。  
- **大数运算与溢出**：使用`long long`类型存储中间结果，避免乘法溢出。  

**可视化设计**  
1. **动画演示**：  
   - **步骤1**：展示前缀积数组`pre`的构建过程，高亮当前计算的元素`a[i]`和对应的`pre[i]`。  
   - **步骤2**：逆序计算`inv_pre`数组时，动态显示递推关系（如 `inv_pre[i] = inv_pre[i+1] * a[i+1] % p`），并标注颜色变化。  
   - **步骤3**：查询时，高亮`pre[r]`和`inv_pre[l-1]`，并用箭头连接两者的乘积操作。  
2. **复古风格**：  
   - **像素动画**：用 8 位色块表示数组元素，前缀积与逆元计算过程用不同颜色区分。  
   - **音效**：关键步骤（如逆元计算完成、查询结果生成）触发 8-bit 音效，增强交互感。  
   - **自动演示**：允许用户调整速度观察递推与查询流程。  

---

**最优思路提炼**  
1. **前缀积与逆元结合**：通过前缀积数组快速获取区间乘积的前半部分，逆元数组避免除法运算。  
2. **线性递推逆元**：利用递推公式 `inv_pre[i] = inv_pre[i+1] * a[i+1] % p`，避免逐个快速幂计算，时间复杂度 O(n)。  

---

**推荐题目**  
1. P3811（线性求逆元模板题）  
2. P5431（模数非质数的逆元处理）  
3. P1865（区间质数筛，训练模运算思维）  

---

**代码实现**  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 10;
const int P = 1145141; // 1054² + 185² 的质数结果

ll pre[N], inv_pre[N];
int a[N];

ll quick_pow(ll a, ll b, ll mod) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

int main() {
    int n, q;
    scanf("%d%d", &n, &q);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
    
    // 计算前缀积
    pre[0] = 1;
    for (int i = 1; i <= n; ++i)
        pre[i] = pre[i - 1] * a[i] % P;
    
    // 计算逆元前缀
    inv_pre[n] = quick_pow(pre[n], P - 2, P);
    for (int i = n - 1; i >= 0; --i)
        inv_pre[i] = inv_pre[i + 1] * a[i + 1] % P;
    
    // 处理查询
    ll ans = 0;
    while (q--) {
        int l, r;
        scanf("%d%d", &l, &r);
        ll res = pre[r] * inv_pre[l - 1] % P;
        ans ^= res;
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

**同类型题扩展**  
类似题目通常涉及区间操作与模运算，需结合前缀和/积、逆元、快速幂等技巧。例如：  
- **区间和取模**：前缀和直接处理。  
- **动态更新与查询**：需结合线段树或树状数组维护前缀积。

---
处理用时：192.73秒
# 题目信息

# [SDOI2016] 排列计数

## 题目描述

求有多少种 $1$ 到 $n$ 的排列 $a$，满足序列恰好有 $m$ 个位置 $i$，使得 $a_i = i$。

答案对 $10^9 + 7$ 取模。

## 说明/提示

#### 数据规模与约定

本题共 20 个测试点，各测试点等分，其数据规模如下表。

| 测试点编号 | $T =$  | $n, m \leq$ |  测试点编号  |      $T =$      | $n, m \leq$ |
| :--------: | :----: | :---------: | :----------: | :-------------: | :---------: |
| $1\sim 3$  | $10^3$ |     $8$     | $10 \sim 12$ |     $10^3$      |   $10^3$    |
| $4 \sim 6$ | $10^3$ |    $12$     | $13 \sim 14$ | $5 \times 10^5$ |   $10^3$    |
| $7 \sim 9$ | $10^3$ |    $100$    | $15 \sim 20$ | $5 \times 10^5$ |   $10^6$    |

对于全部的测试点，保证 $1 \leq T \leq 5 \times 10^5$，$1 \leq n \leq 10^6$，$0 \leq m \leq 10^6$。

## 样例 #1

### 输入

```
5
1 0
1 1
5 2
100 50
10000 5000```

### 输出

```
0
1
20
578028887
60695423```

# AI分析结果



## 算法分类
组合数学、错排问题

---

## 题解思路与核心算法

### 核心思路
1. **组合数计算**：选择m个位置作为固定点，方案数为组合数C(n,m)
2. **错排计算**：剩余n-m个元素全错排，方案数为错排数D(n-m)
3. **公式推导**：最终答案为C(n,m) * D(n-m) mod 1e9+7

### 解决难点
1. **错排递推式**：D(n) = (n-1) * (D(n-1) + D(n-2))，边界D(0)=1, D(1)=0
2. **大数组合数计算**：预处理阶乘和逆元实现O(1)查询
3. **边界处理**：当n=m时返回1，当n-m=1时返回0

---

## 题解评分（≥4星）

### 1. 冒泡ioa（5星）
- **亮点**：清晰推导错排公式，完整预处理阶乘+逆元+错排数组，处理所有边界条件
- **关键代码**：
```c++
prework预处理阶乘、逆元、错排数组
ans = C(n,m) * D(n-m) 直接公式计算
```

### 2. Warriors_Cat（4星）
- **亮点**：代码结构简洁，使用快速读入优化大数据处理
- **关键优化**：将阶乘逆元与错排数组预处理合并到同一循环

### 3. poorpool（4星）
- **亮点**：采用线性逆元预处理，代码模块化程度高
- **特色**：使用`#define N 1000010`定义常量增强可维护性

---

## 最优技巧提炼

### 核心公式
- **错排递推**：D(n) = (n-1)*(D(n-1)+D(n-2))
- **组合数优化**：C(n,m) = n!/(m!(n-m)!) 使用逆元实现模意义下除法

### 实现技巧
1. **三数组预处理**：同步计算阶乘(fac)、阶乘逆元(inv)、错排数组(d)
2. **费马小定理**：求逆元时使用a^(mod-2) mod mod
3. **边界特判**：n=m直接返回1，n-m=1返回0

---

## 类似题目推荐
1. P1595 信封问题（基础错排）
2. P3197 越狱（组合数学+快速幂）
3. P1365 排列计数（错排变种）

---

## 可视化设计

### 算法动画方案
1. **组合选择演示**：
   - **Canvas绘制**：用红色方块标记选中的m个固定点
   - **动态效果**：从左到右滑动选择过程，显示C(n,m)计算过程

2. **错排递推演示**：
   - **递推树展示**：以n=5为例，动态展开D(5)=4*(D4+D3)
   - **颜色标记**：
     - 当前元素：黄色高亮
     - 交换位置：绿色箭头连接
   - **分步说明**：
     ```python
     1. 固定元素5的位置（如位置3）
     2. 分情况讨论：
        a. 元素3放在位置5 → 剩余3元素错排（D3）
        b. 元素3不放在位置5 → 剩余4元素错排（D4）
     ```

3. **游戏化界面**：
   - **8-bit风格**：使用NES调色板（#306082主色调）
   - **音效设计**：
     - 正确选择：FC马里奥吃金币音效
     - 错误提示：FC塞尔达解密失败音效
   - **积分系统**：
     - 成功计算一组数据：+100分
     - 连续AC三次：触发连击特效

---

## 核心代码实现

### 预处理模块
```c++
const int MAXN = 1e6+5, mod = 1e9+7;
ll fac[MAXN], inv[MAXN], d[MAXN];

void init() {
    // 阶乘与逆元
    fac[0] = inv[0] = 1;
    for(int i=1; i<MAXN; ++i) 
        fac[i] = fac[i-1] * i % mod;
    inv[MAXN-1] = pow(fac[MAXN-1], mod-2, mod);
    for(int i=MAXN-2; i>=1; --i)
        inv[i] = inv[i+1] * (i+1) % mod;
    
    // 错排递推
    d[0] = 1; d[1] = 0;
    for(int i=2; i<MAXN; ++i)
        d[i] = (i-1) * (d[i-1] + d[i-2]) % mod;
}

ll C(int n, int m) {
    return fac[n] * inv[m] % mod * inv[n-m] % mod;
}
```

---

## 可视化代码片段（Canvas动画）

```javascript
// 错排步骤演示（伪代码）
function drawDerangement(n) {
    let elements = Array.from({length:n}, (_,i) => i+1);
    let canvas = new PixelCanvas(800, 600);
    
    // 初始排列
    canvas.drawGrid(elements, "初始排列", 0xFFFFFF);
    
    // 选择交换位置
    let k = Math.floor(Math.random()*(n-1)) + 1;
    canvas.highlightCell(k, 0xFF0000);
    
    // 分情况动画
    setTimeout(() => {
        // 情况1：k放在n的位置
        canvas.arrowAnimation(k, n, 0x00FF00);
        canvas.drawGrid(..., "剩余"+(n-2)+"元素错排");
        
        // 情况2：k不放在n的位置 
        canvas.blinkCells([k,n], 0xFFFF00);
        canvas.drawGrid(..., "剩余"+(n-1)+"元素错排");
    }, 1000);
}
```

---

## 总结启示

1. **组合数学思维**：将复杂问题分解为独立子问题（选择固定点+剩余错排）
2. **预处理艺术**：大数据量下预处理阶乘、逆元是通用优化手段
3. **边界意识**：特殊情况的预先处理能避免大量运行时错误
4. **可视化价值**：动态演示错排递推过程可加深对递推公式的理解

---
处理用时：83.00秒
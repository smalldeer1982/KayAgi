# 题目信息

# 队列安排

## 题目描述

一个学校里老师要将班上 $N$ 个同学排成一列，同学被编号为 $1\sim N$，他采取如下的方法：

1. 先将 $1$ 号同学安排进队列，这时队列中只有他一个人；

2. $2\sim N$ 号同学依次入列，编号为 $i$ 的同学入列方式为：老师指定编号为 $i$ 的同学站在编号为 $1\sim(i-1)$ 中某位同学（即之前已经入列的同学）的左边或右边；

3. 从队列中去掉 $M$ 个同学，其他同学位置顺序不变。

在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。

## 说明/提示

**【样例解释】**

将同学 $2$ 插入至同学 $1$ 左边，此时队列为：

`2 1`

将同学 $3$ 插入至同学 $2$ 右边，此时队列为：

`2 3 1`  

将同学 $4$ 插入至同学 $1$ 左边，此时队列为：

`2 3 4 1`  

将同学 $3$ 从队列中移出，此时队列为：

`2 4 1`  

同学 $3$ 已经不在队列中，忽略最后一条指令

最终队列：

`2 4 1`  

**【数据范围】**

对于 $20\%$ 的数据，$1\leq N\leq 10$。

对于 $40\%$ 的数据，$1\leq N\leq 1000$。

对于 $100\%$ 的数据，$1<M\leq N\leq 10^5$。


## 样例 #1

### 输入

```
4
1 0
2 1
1 0
2
3
3```

### 输出

```
2 4 1```

# AI分析结果



**唯一算法分类**：双向链表

---

### **题解思路与核心难点**

**核心思路**：  
所有题解均基于**双向链表**数据结构，通过维护每个节点的左右指针实现 O(1) 时间复杂度的插入与删除操作。关键点在于：
1. **哨兵节点**：引入虚拟头节点（如 0 号节点）简化边界处理，避免头尾指针更新时的复杂判断。
2. **指针调整顺序**：插入时需调整相邻节点的左右指针，特别注意顺序以防止指针覆盖。
3. **惰性删除**：用标记数组记录已删除节点，最终遍历时跳过，避免实际修改链表结构。

**解决难点**：
1. **动态维护头尾节点**：部分题解需额外维护头指针，哨兵节点可避免此问题。
2. **高效删除**：直接调整指针而非物理删除，保证时间复杂度严格 O(1)。
3. **初始化与遍历**：哨兵节点的右指针指向真实头节点，遍历从该指针开始至返回哨兵结束。

---

### **题解评分与亮点**

1. **BT狸（5星）**  
   - 亮点：使用哨兵节点统一边界处理，代码结构清晰，可视化插入步骤图辅助理解。
   - 代码片段：
     ```cpp
     void add(int i, int k, int f) {
         if(f==1) { // 插入右侧
             t[k].r = t[i].r;
             t[k].l = i;
             t[i].r = k;
             t[t[k].r].l = k;
         } else { /* 类似逻辑处理左侧 */ }
     }
     ```

2. **Orina_zju（4星）**  
   - 亮点：利用 STL `list` 简化代码，适合快速实现，但需注意迭代器失效问题。
   - 代码片段：
     ```cpp
     list<int> queList;
     Iter pos = queList.insert(pos[k], i); // 插入左侧
     ```

3. **LiRewriter（4星）**  
   - 亮点：手写链表结构体，独立处理左右插入函数，逻辑模块化。
   - 代码片段：
     ```cpp
     void addLeft(int x, int pos) {
         a[x].R = pos;
         a[a[pos].L].R = x;
         a[x].L = a[pos].L;
         a[pos].L = x;
     }
     ```

---

### **最优技巧提炼**

1. **哨兵节点技巧**  
   初始化时添加虚拟节点（如 0 号），所有真实节点位于其右侧，遍历时从 `t[0].r` 开始，避免处理空链表或头节点更新。

2. **惰性删除优化**  
   删除时仅标记节点状态，遍历时跳过，减少指针操作次数。

3. **四步指针调整法**  
   插入节点时按固定顺序调整指针：
   ```cpp
   // 插入右侧
   new_node.left = target;
   new_node.right = target.right;
   target.right.left = new_node;
   target.right = new_node;
   ```

---

### **同类题目推荐**

1. **P1160 队列安排**（本题）
2. **P1996 约瑟夫问题**（循环链表应用）
3. **P1540 机器翻译**（队列维护最近使用）

---

### **可视化与算法演示**

**动画设计**：
1. **节点表示**：每个同学为矩形节点，显示编号，左右指针用箭头指向相邻节点。
2. **操作高亮**：
   - **插入**：红色闪烁目标节点，蓝色显示新节点，绿色箭头展示指针调整过程。
   - **删除**：灰色标记被删节点，红色箭头更新相邻节点的指针。
3. **复古像素风格**：
   - 使用 8-bit 像素字体，节点用 16x16 像素块表示，箭头为 8x8 像素箭头。
   - 音效：插入时播放“哔”声，删除时“咔嚓”声，背景 chiptune 音乐循环。

**交互演示**：
```javascript
// 示例：Canvas 绘制节点
function drawNode(ctx, x, y, id, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y, 30, 30); // 像素风格节点
    ctx.fillStyle = '#000';
    ctx.fillText(id, x + 10, y + 20);
}

// 插入动画步骤
function animateInsert(target, newNode) {
    highlight(target, 'red');
    highlight(newNode, 'blue');
    drawArrow(target, newNode); // 绘制指针调整
    playSound('beep');
}
```

---

### **核心代码实现**

**双向链表完整代码**：
```cpp
#include <iostream>
using namespace std;
const int MAX = 1e5 + 10;

struct Node { int l, r; } t[MAX];
bool deleted[MAX];

void insertRight(int k, int x) {
    t[x].l = k;
    t[x].r = t[k].r;
    t[t[k].r].l = x;
    t[k].r = x;
}

int main() {
    int n, m; cin >> n;
    t[0].r = 0; // 哨兵节点初始化
    insertRight(0, 1); // 插入首节点

    for (int i = 2; i <= n; ++i) {
        int k, p; cin >> k >> p;
        p ? insertRight(k, i) : insertRight(t[k].l, i);
    }

    cin >> m;
    while (m--) {
        int x; cin >> x;
        deleted[x] = true;
    }

    for (int i = t[0].r; i != 0; i = t[i].r) {
        if (!deleted[i]) cout << i << " ";
    }
    return 0;
}
```

---
处理用时：94.64秒
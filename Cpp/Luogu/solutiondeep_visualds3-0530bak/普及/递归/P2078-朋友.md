# 题目信息

# 朋友

## 题目背景

小明在 A 公司工作，小红在 B 公司工作。

## 题目描述

这两个公司的员工有一个特点：一个公司的员工都是同性。

A 公司有 $N$ 名员工，其中有 $P$ 对朋友关系。B 公司有 $M$ 名员工，其中有 $Q$ 对朋友关系。朋友的朋友一定还是朋友。

每对朋友关系用两个整数 $(X_i,Y_i)$ 组成，表示朋友的编号分别为 $X_i,Y_i$。男人的编号是正数，女人的编号是负数。小明的编号是 $1$，小红的编号是 $-1$。

大家都知道，小明和小红是朋友，那么，请你写一个程序求出两公司之间，通过小明和小红认识的人最多一共能配成多少对情侣（包括他们自己）。

## 说明/提示

对于 $30 \%$ 的数据，$N,M \le 100$，$P,Q \le 200$；

对于 $80 \%$ 的数据，$N,M \le 4 \times 10^3$，$P,Q \le 10^4$；

对于 $100 \%$ 的数据，$N,M \le 10^4$，$P,Q \le 2 \times 10^4$。

## 样例 #1

### 输入

```
4 3 4 2
1 1
1 2
2 3
1 3
-1 -2
-3 -3
```

### 输出

```
2```

# AI分析结果



## 算法分类
**并查集**

---

## 题解思路与核心难点

### 核心逻辑
1. **并查集分组**：将两个公司的员工分别用并查集管理，A公司（正数）和B公司（负数）的朋友关系通过并查集合并。
2. **负数处理**：B公司员工编号为负数，需转换为正数（如取绝对值后 + 偏移量），避免数组越界。
3. **统计集合大小**：分别统计与小明（A公司根节点1）和小红（B公司根节点1）同集合的人数，取较小值作为答案。

### 解决难点
- **负数转换**：通过偏移量（如`n+1`）或指针技巧（`map<int, int>`）处理负数下标。
- **路径压缩优化**：确保查询效率，避免超时。
- **初始化覆盖所有节点**：需确保所有可能的员工编号都被正确初始化。

---

## 题解评分（≥4星）

### 1. 作者：saxiy（5星）
- **亮点**：使用指针位移技巧处理负数，代码简洁高效。  
  ```cpp
  int data[N << 1], *bcj = data + N;  // 指针偏移处理负数
  ```
- **关键点**：无需额外空间，直接通过地址偏移兼容负数下标。

### 2. 作者：睿屿青衫（4星）
- **亮点**：分两个数组处理男女公司，逻辑清晰。  
  ```cpp
  father[i] = i;  // A公司初始化
  father[i + n] = i + n;  // B公司偏移初始化
  ```
- **优化**：将B公司负数编号转换为正数后偏移存储，避免冲突。

### 3. 作者：zhengrunzhe（4星）
- **亮点**：边合并边统计集合大小，避免二次遍历。  
  ```cpp
  ra[f1] += ra[f2];  // 合并时更新集合大小
  ```
- **效率**：实时维护集合大小，减少最终统计时间。

---

## 最优思路提炼
1. **负数处理**：将B公司员工编号取绝对值后偏移（如`-x → x + n`），避免数组越界。
2. **双并查集**：分别维护A、B公司的并查集结构，最后统计根节点为小明/小红的人数。
3. **路径压缩**：确保查询时间复杂度接近O(1)。
   ```cpp
   int find(int x) {
       return f[x] == x ? x : f[x] = find(f[x]);
   }
   ```

---

## 类似题目推荐
1. **P1551 亲戚**（并查集基础应用）
2. **P3367 【模板】并查集**（路径压缩与合并优化）
3. **P1396 营救**（并查集结合边排序）

---

## 可视化设计思路
### 动画演示
1. **结构展示**：Canvas绘制两个并查集树，A公司（蓝色节点）、B公司（红色节点）。
2. **合并过程**：高亮当前合并的节点，显示路径压缩后的树结构变化。
3. **统计结果**：动态显示与小明/小红同集合的节点数量，对比后取较小值。

### 复古像素风格
- **颜色方案**：8位色（蓝、红、绿分别表示A、B、公共节点）。
- **音效设计**：
  - **合并成功**：短促“滴”声。
  - **路径压缩**：连续“哔”声。
  - **统计完成**：8-bit胜利音乐。

### 交互功能
- **步进控制**：允许暂停/继续，观察每一步合并细节。
- **自动模式**：AI自动执行合并操作，速度可调。

---

## 核心代码实现
```cpp
// 作者：saxiy（关键代码）
#include <bits/stdc++.h>
using namespace std;
const int N = 10005;
int data[N << 1], *bcj = data + N; // 指针偏移处理负数

int find(int x) {
    return bcj[x] == x ? x : bcj[x] = find(bcj[x]);
}

void unite(int x, int y) {
    bcj[find(x)] = find(y);
}

int main() {
    int n, m, p, q, ans1 = 0, ans2 = 0;
    cin >> n >> m >> p >> q;
    for (int i = -m; i <= n; i++) bcj[i] = i; // 初始化所有可能节点
    // 合并操作...
    for (int i = -m; i < 0; i++) 
        if (find(i) == find(-1)) ans1++;
    for (int i = 1; i <= n; i++) 
        if (find(i) == find(1)) ans2++;
    cout << min(ans1, ans2);
}
```

---

## 个人心得摘录
- **Ajwallet**：`map`虽方便，但大数据量时效率堪忧，需谨慎使用。
- **Blue_wonders**：未正确初始化导致WA，调试时需覆盖所有节点。
- **虫洞吞噬者**：路径压缩后需确保根节点正确性，否则统计错误。

---

## 总结
本题核心在于并查集的灵活应用与负数下标的巧妙处理。通过分治两个公司、路径压缩优化和实时统计，可高效解决问题。可视化设计可增强对并查集合并过程的理解，复古风格增添趣味性。

---
处理用时：72.56秒
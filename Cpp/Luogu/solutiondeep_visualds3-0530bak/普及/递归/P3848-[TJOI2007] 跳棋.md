# 题目信息

# [TJOI2007] 跳棋

## 题目背景

在一个n×n的棋盘上，布满了0和1，如图（a）所示（n=7），为叙述方便，将0用字母表示，如图（b）。

![](https://cdn.luogu.com.cn/upload/pic/6077.png)


## 题目描述

跳棋规则：

（1）从某个0格出发，可以向上，下，左，右4个方向连续越过若干个（至少1个）

1格而跳入下一个0格。如图（b）中从A出发，可跳到B，或者到E，但不能直接到K。在跳到B之后还可以继续跳到F;在跳到E之后可继续跳到F或K。直到不能再跳为止。

（2）每个0格只能到达一次，给出的起始点不能再到达，也不能越过。

跳过的距离为跳过1格个数加1，如从A到B，跳过距离为3，从B到F，跳过距离为2。

问   题： 当棋盘和起始点给出之后，问最远能跳的距离是多少？

如上图（b）中，从A出发，可跳过的路线不止一条，其中一条为：

A － B － F － L － K － E  （可能不唯一）

3    2    3    3     3

它的距离为14。


## 说明/提示

$\text{upd 2022.7.27}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
4  3  2
1  0  1  0 
1  1  1  1
0  0  1  0
1  1  0  1```

### 输出

```
6```

# AI分析结果



**唯一算法分类**：深度优先搜索（DFS）

---

### **题解思路与解决难点**

1. **核心问题**：在满足跳跃规则（至少跳过一个1，每个0只能访问一次）下，找到从起点出发的最长跳跃总距离。
2. **关键步骤**：
   - **跳跃方向处理**：从当前点向四个方向延伸，直到遇到下一个0或边界。
   - **距离计算**：每次跳跃的距离为跳过的1的数量加1（例如，跳过2个1则距离为3）。
   - **回溯处理**：标记已访问的0点，递归后恢复状态。
3. **难点对比**：
   - **距离计算**：部分题解（如第一个）错误地将跳过的1个数直接作为距离，未加1。
   - **回溯修复**：如JJA题解修复了未回溯的Bug，确保状态正确。
   - **预处理优化**：如funky_monkey将棋盘转化为图结构，提前计算所有可能的跳跃边，减少DFS中的重复判断。

---

### **题解评分（≥4星）**

1. **JJA_的题解（★★★★）**
   - **亮点**：修复回溯问题，正确计算距离（`sum`初始为1，每次移动`sum++`）。
   - **代码简析**：通过`while`循环找到下一个0，`sum`累加跳过的1的数量，确保距离正确。

2. **funky_monkey的题解（★★★★★）**
   - **亮点**：将棋盘转化为图结构（同一行/列的0点连边），预处理跳跃路径，优化DFS效率。
   - **代码简析**：预处理行和列的边权，避免DFS中重复判断跳跃可行性。

3. **Register的题解（★★★★）**
   - **亮点**：简洁的DFS实现，正确计算距离（`sum`初始为1，`sum++`处理跳过的1）。
   - **代码简析**：通过`while`循环动态计算跳跃距离，逻辑清晰。

---

### **最优思路与技巧**

1. **关键数据结构**：
   - **访问标记数组**（如`vis[][]`）：避免重复访问0点。
   - **方向数组**（如`dx[4], dy[4]`）：处理四个方向的跳跃。
2. **距离计算**：每次跳跃的距离为跳过的1的数量加1，需确保代码正确累加。
3. **预处理优化**：将棋盘转化为图结构，减少DFS中的重复计算（如funky_monkey的建图方法）。

---

### **同类型题与算法套路**

1. **通用DFS套路**：适用于状态空间有限的最长路径问题（如迷宫、跳跃规则明确的场景）。
2. **类似题目**：
   - **P1433 吃奶酪**：记录已访问点，求最短路径。
   - **P1101 单词方阵**：多方向DFS匹配模式。
   - **P1560 Snail Trails**：蜗牛路径回溯。

---

### **推荐题目**

1. **P1433**（DFS + 状态标记）
2. **P1560**（DFS + 路径回溯）
3. **P1101**（多方向DFS搜索）

---

### **核心代码实现**

**JJA_的题解关键代码**：
```cpp
int sum = 1; // 初始为1，确保距离正确
while (xx > 0 && yy > 0 && xx <= n && yy <= n) {
    if (mapp[xx][yy] == 1) {
        xx += dx[i], yy += dy[i], sum++;
    } else {
        if (sum != 1 && !vis[xx][yy]) {
            dfs(xx, yy, t + sum); // 距离累加sum（跳过的1个数+1）
        }
        break;
    }
}
```

---

### **可视化设计**

1. **棋盘绘制**：
   - 用Canvas绘制`n×n`网格，0/1用不同颜色填充（如0白色，1黑色）。
   - 起点用绿色标记，已访问的0点用灰色。
2. **跳跃动画**：
   - 高亮当前跳跃路径（红色），动态显示移动过程。
   - 每次跳跃后更新总距离（屏幕顶部显示）。
3. **交互控制**：
   - 按钮控制：暂停/继续/单步执行。
   - 速度调节滑动条（如1x/2x/5x）。
4. **音效**：
   - 跳跃时播放“跳跃音效”，找到最长路径时播放胜利音效。

---

### **复古像素风格示例**

```javascript
// Canvas初始化（8位风格）
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");
ctx.fillStyle = "#000"; // 1的像素颜色
ctx.fillRect(x * 10, y * 10, 10, 10); // 10x10像素块

// 动画帧更新
function animate() {
    ctx.clearRect(0, 0, 1000, 1000);
    drawGrid(); // 绘制棋盘
    drawPath(); // 高亮当前路径
    requestAnimationFrame(animate);
}
```

---

**总结**：正确计算跳跃距离和回溯处理是本题核心，DFS结合预处理优化可显著提升效率。复古像素动画可直观展示算法过程，增强理解。

---
处理用时：287.95秒
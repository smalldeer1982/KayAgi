# 题目信息

# 文件压缩

## 题目背景

提高文件的压缩率一直是人们追求的目标。近几年有人提出了这样一种算法，它虽然只是单纯地对文件进行重排，本身并不压缩文件，但是经这种算法调整后的文件在大多数情况下都能获得比原来更大的压缩率。


## 题目描述

该算法具体如下：对一个长度为 $n$ 的字符串 $S$，首先根据它构造 $n$ 个字符串，其中第 $i$ 个字符串由将 $S$ 的前 $i-1$ 个字符置于末尾得到。然后把这 $n$ 个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们**在 $S$ 中的位置**从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串 $S'$ ，它的长度也是 $n$，并且包含了 $S$ 中的每一个字符。最后输出 $S'$ 以及 $S$ 的首字符在 $S'$ 中的位置 $p$。

举例：$S$ 是 `example`

1. 构造 $n$ 个字符串。

```plain
example
xamplee
ampleex
mpleexa
pleexam
leexamp
eexampl
```

2. 将字符串排序。

```plain
ampleex
example
eexampl
leexamp
mpleexa
pleexam
xamplee
```
3. 压缩结果。

$S' = \texttt{xelpame}$，$p = 7$

由于英语单词构造的特殊性，某些字母对出现的频率很高，因此在 $S'$ 中相同的字母有很大几率排在一起，从而提高 $S'$ 的压缩率。虽然这种算法利用了英语单词的特性，然而在实践的过程中，人们发现它几乎适用于所有的文件压缩。

请你编一个程序，读入 $S'$ 和 $p$，输出字符串 $S$。

保证 $S$ 仅含小写字母（所以输入的 $S'$ 也仅含小写字母）。

## 样例 #1

### 输入

```
7
xelpame
7
```

### 输出

```
example
```

# AI分析结果



---

## 算法分类
**构造 + 模拟**

---

## 核心思路与难点解析

### ▍题解核心逻辑
所有题解均基于以下关键观察：
1. **排序后的首字母序列**：将输入的字符串 S' 按字典序排序，得到所有旋转字符串的首字母序列。
2. **首尾对应关系**：排序后的每个字符串首字母为 sorted[i]，尾字母为 S'[i]，这两个字符在原字符串中是相邻的。
3. **倒序构建**：从给定的位置 p 出发，逆序构建原字符串。每次通过当前尾字母找到对应的首字母，逐步还原字符间的连接关系。

### ▍解决难点
1. **重复字符处理**：当存在重复字符时，需从排序后的数组中倒序查找匹配项，确保选择正确的相邻关系。
2. **构建顺序**：必须逆序构建原字符串（从最后一个字符开始），避免正序查找时因 S' 的无序性导致错误。

---

## 最优思路与关键技巧

### ▍核心算法步骤
1. **预处理排序**：
   ```cpp
   strcpy(sorted, S');
   sort(sorted, sorted + n);
   ```
2. **确定起点**：
   ```cpp
   // 找到原字符串首字符在 sorted 中的位置
   for (int i=0; i<n; i++) {
       if (sorted[i] == S'[p-1]) {
           pos = i;
           sorted[i] = '#'; // 标记已使用
           break;
       }
   }
   ```
3. **逆序构建**：
   ```cpp
   ans[0] = S'[pos]; // 原字符串最后一个字符
   for (int i=1; i<n; i++) {
       // 从后往前找匹配当前尾字母的首字母
       for (int j=n-1; j>=0; j--) {
           if (sorted[j] == S'[pos]) {
               pos = j;
               ans[i] = S'[pos];
               sorted[j] = '#'; // 标记已使用
               break;
           }
       }
   }
   ```
4. **倒序输出**：
   ```cpp
   reverse(ans, ans + n);
   ```

### ▍关键优化技巧
- **倒序查找**：确保在相同字符中选择最靠后的位置，维护正确的相邻关系。
- **原地标记**：通过修改排序数组中的值为特殊字符（如 `#`），避免重复匹配。

---

## 高星题解推荐（≥4星）

### 1. MC_Launcher（5星）
- **亮点**：清晰的逆序构建思路，代码注释详细，通过图解辅助理解相邻关系。
- **核心代码**：
  ```cpp
  for(int j=n-1;j>=0;j--) { // 倒序查找关键点
      if(b[j]==a[now]) {
          now=j;
          ans[i]=a[now];
          b[j]=')'; // 原地标记
          break;
      }
  }
  ```

### 2. liuzhaoxu（4.5星）
- **亮点**：深入分析正推与倒推的区别，通过反例说明正推的错误场景。
- **核心注释**：
  ```cpp
  // 必须从排序后的数组倒序查找，避免无序导致的错位
  for(int i=n;i>=1;--i) if(ss[i]==s[p]) {p=i;break;}
  ```

### 3. Cat_cc（4星）
- **亮点**：利用字母统计信息优化查找，通过预计算左右边界加速匹配。
- **核心逻辑**：
  ```cpp
  // 预处理字母统计
  for(int i=0;i<26;i++) {
      l[i] = r[i-1] + 1;
      r[i] = l[i] + a[i] - 1;
  }
  ```

---

## 可视化算法设计

### ▍动画演示方案
1. **数据结构展示**：
   - **左侧**：排序后的首字母数组 `sorted[]`，用绿色方块表示。
   - **右侧**：原始尾字母数组 `S'[]`，用蓝色方块表示。
2. **匹配过程**：
   - 当前操作的字符高亮为红色。
   - 每次匹配时，左侧方块向右连线至右侧对应位置，并播放“滴”声效。
3. **构建过程**：
   - 逆序生成的字符从底部逐渐堆叠，形成原字符串。
   - 每添加一个字符，播放“咔嗒”音效。

### ▍复古像素风格
- **颜色方案**：使用 8-bit 风格的 16 色调色板，如 `#00FF00`（绿）、`#0000FF`（蓝）。
- **音效设计**：
  - **匹配成功**：8-bit 风格的短促“滴”声（Web Audio API 合成）。
  - **构建完成**：经典 FC 过关音效。
- **Canvas 动画**：
  - 字符以 32x32 像素方块渲染，匹配时显示连线动画。
  - 自动演示模式下，算法以 500ms/步的速度自动执行。

---

## 相似题目推荐
1. [P1368 工艺](https://www.luogu.com.cn/problem/P1368) - 最小表示法
2. [P2870 [USACO07DEC]Best Cow Line G](https://www.luogu.com.cn/problem/P2870) - 贪心构造
3. [P4051 [JSOI2007]字符加密](https://www.luogu.com.cn/problem/P4051) - 循环同构排序

---
处理用时：93.09秒
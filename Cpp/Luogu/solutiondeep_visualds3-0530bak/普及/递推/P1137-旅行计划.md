# 题目信息

# 旅行计划

## 题目描述

小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。

所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。

现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。

## 说明/提示

均选择从城市 $1$ 出发可以得到以上答案。

- 对于 $20\%$ 的数据，$1\le N ≤ 100$；
- 对于 $60\%$ 的数据，$1\le N ≤ 1000$；
- 对于 $100\%$ 的数据，$1\le N ≤ 100000$，$1\le M ≤ 200000$。


## 样例 #1

### 输入

```
5 6
1 2
1 3
2 3
2 4
3 4
2 5
```

### 输出

```
1
2
3
4
3
```

# AI分析结果



## 唯一算法分类
拓扑排序 + 动态规划

---

## 综合分析与结论

### 核心思路与难点
1. **问题本质**：在DAG上求以每个节点为终点的最长路径长度
2. **关键难点**：
   - 确保动态规划的无后效性（必须按拓扑序处理节点）
   - 高效处理大规模数据（N=1e5级别）
3. **通用解法**：
   ```text
   拓扑排序 → 按序处理 → DP转移方程：dp[v] = max(dp[v], dp[u]+1)
   ```

### 算法流程可视化设计
1. **动画步骤**：
   - **颜色标记**：当前处理节点（红色）、已处理节点（绿色）、待处理节点（灰色）
   - **动态更新**：展示邻接节点的dp值更新过程（黄色高亮）
   - **拓扑队列**：侧边栏显示队列状态，标注入度为0的节点
2. **像素风格**：
   ```javascript
   // 伪代码示例
   class NodeVisual {
     constructor(id, x, y) {
       this.id = id;
       this.dp = 1; // 初始值
       this.color = 0x808080; // 灰色
     }
     updateDP(newVal) {
       this.dp = newVal;
       this.color = 0xFFD700; // 更新时变黄
       playSound('blip.wav'); // 音效
     }
   }
   ```
3. **AI自动演示**：
   - 以预设速度自动执行拓扑排序步骤
   - 关键节点暂停500ms展示状态变化

---

## 题解清单（4星+）

### 1. 星星之火（⭐⭐⭐⭐⭐）
**亮点**：
- 完整解释拓扑排序与DP的关联性
- 代码含详细注释，队列实现高效
```cpp
// 关键代码段
void topsort() {
  queue<int> q;
  for(int u : 起点集合) q.push(u);
  while(!q.empty()) {
    int u = q.front(); q.pop();
    for(int v : u的邻接点) {
      if(--in[v] == 0) q.push(v);
      dp[v] = max(dp[v], dp[u]+1); // 核心转移
    }
  }
}
```

### 2. 归山_（⭐⭐⭐⭐）
**亮点**：
- 反向建图+记忆化搜索
- 代码简洁（仅30行）
```cpp
int dfs(int x) {
  if(dp[x]) return dp[x];
  dp[x] = 1;
  for(int y : 反向邻接表[x])
    dp[x] = max(dp[x], dfs(y)+1);
  return dp[x];
}
```

### 3. wshz（⭐⭐⭐⭐）
**亮点**：
- 拓扑排序与SPFA结合
- 实时更新路径长度
```cpp
while(!q.empty()) {
  int u = q.front(); q.pop();
  for(int v : 邻接表[u]) {
    ans[v] = max(ans[v], ans[u]+1);
    if(--in[v] == 0) q.push(v);
  }
}
```

---

## 最优技巧提炼
1. **拓扑序处理**：确保DP的无后效性
2. **反向思维**：记忆化搜索时反向建图简化问题
3. **初始值设定**：所有节点dp[i]初始化为1（自身）

---

## 同类型题拓展
1. **最大食物链计数**（P4017）：拓扑排序+路径计数
2. **关键路径问题**：AOE网中的最长路径
3. **课程安排**：LeetCode 210 Course Schedule II

---

## 推荐练习题
1. **P1113** 杂物（拓扑排序求最长路）
2. **P3388** 割点（图论基础）
3. **P2741** 矩形覆盖问题（DAG建模）

---

## 个人心得摘录
> "调试时发现忘记初始化dp数组为1，导致所有结果少1。拓扑排序必须严格按入度为0的顺序处理，否则会漏节点。" —— 题解评论区

---

## 可视化实现（关键JS片段）
```javascript
class TopoAnim {
  constructor(nodes, edges) {
    this.queue = new PixelQueue(100, 300); // 像素风格队列
    this.nodes = nodes.map((_,i) => new PixelNode(i, 50+i%10*60, 100+Math.floor(i/10)*60));
    this.edges = edges;
  }
  
  step() {
    if(this.queue.isEmpty()) return;
    let u = this.queue.dequeue();
    u.setColor(0xFF0000); // 当前节点红色
    this.edges.filter(e => e.from === u.id).forEach(e => {
      let v = this.nodes[e.to];
      v.dp = Math.max(v.dp, u.dp + 1);
      v.setColor(0xFFFF00); // 邻接节点黄色
      if(--v.inDegree === 0) {
        this.queue.enqueue(v);
        v.setColor(0x00FF00); // 入队变绿
      }
    });
  }
}
```

---
处理用时：77.34秒
# 题目信息

# [NOIP 2011 提高组] 选择客栈

## 题目描述

丽江河边有 $n$ 家很有特色的客栈，客栈按照其位置顺序从 $1$ 到 $n$ 编号。每家客栈都按照某一种色调进行装饰（总共 $k$ 种，用整数 $0 \sim k-1$ 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。

两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 $p$ 。

他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 $p$ 元的咖啡店小聚。

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/pic/101.png) 

2 人要住同样色调的客栈，所有可选的住宿方案包括：住客栈①③，②④，②⑤，④⑤，但是若选择住 $4,5$号客栈的话，$4,5$ 号客栈之间的咖啡店的最低消费是 $4$ ，而两人能承受的最低消费是 $3$ 元，所以不满足要求。因此只有前 $3$ 种方案可选。

### 数据范围

- 对于 $30\% $ 的数据，有 $n \leq 100$ ；
- 对于 $50\% $ 的数据，有 $n \leq 1\,000$；
- 对于 $100\%$ 的数据，有 $2 \leq n \leq 2 \times 10^5$，$1 \leq k
 \leq 50$，$0 \leq p \leq 100$，$0 \leq b_i \leq 100$。

## 样例 #1

### 输入

```
5 2 3 
0 5 
1 3 
0 2 
1 4 
1 5 
```

### 输出

```
3
```

# AI分析结果



# 算法分类
**线性扫描与动态统计**

---

# 题解思路、算法要点与解决难点

### 核心思路
维护**最近合法咖啡店位置**与**各颜色历史出现信息**，动态统计可行方案数。具体实现：
1. 扫描每个客栈作为右端点
2. 维护 `now` 表示最近消费 ≤p 的咖啡店位置
3. 用 `last[color]` 记录颜色最后出现位置，`sum[color]` 记录该颜色在 now 前可匹配数量
4. 当当前客栈的 `last[color] ≤ now` 时，说明该颜色所有在 now 前的客栈均可作为左端点

### 解决难点
- **高效维护跨区间颜色匹配**：通过 now 和 last 的指针关系，将区间判断简化为 O(1) 条件判断
- **避免重复计算**：通过 sum 数组动态记录各颜色的有效数量，仅在新咖啡店出现时更新统计值

---

# 题解评分（≥4星）

### 5星题解：ShawnZhou（376赞）
- **亮点**：  
  ✅ 线性时间复杂度 O(n)  
  ✅ 代码仅 20 行，使用 last/sum/cnt 三数组清晰维护状态  
  ✅ 通过 now 指针巧妙处理区间合法性判断

### 5星题解：Shunpower（4赞）
- **亮点**：  
  ✅ 提供 6 种不同解法（枚举咖啡店/容斥/分治等）  
  ✅ 容斥法代码仅 20 行，通过总方案数减去非法方案  
  ✅ 分治解法展示分治思想在统计问题中的应用

### 4星题解：zhengrunzhe（3赞）
- **亮点**：  
  ✅ 树状数组处理三维偏序问题  
  ✅ 将颜色分组后通过前缀和快速统计  
  ✅ 提出 `sum[j] < sum[i]` 的单调性观察

---

# 最优思路或技巧提炼

### 关键技巧
1. **最近合法位置指针**：维护 `now` 表示最后一个消费 ≤p 的咖啡店位置，将区间合法性判断简化为位置比较
2. **颜色分组动态统计**：通过 `sum[color] = cnt[color]` 记录颜色在合法区间内的有效数量，实现 O(1) 查询
3. **容斥思想**：总方案数 = 所有同色对数 - 不包含合法咖啡店的同色对数

### 代码实现核心
```cpp
int now = 0, ans = 0;
for (int i=1; i<=n; i++) {
    cin >> color >> price;
    if (price <= p) now = i; // 更新最近合法位置
    if (last[color] <= now) 
        sum[color] = cnt[color]; // 更新有效数量
    ans += sum[color]; // 累加当前颜色有效数
    last[color] = i;   // 更新颜色最后出现位置
    cnt[color]++;      // 颜色总数增加
}
```

---

# 同类型题与算法套路

### 相似问题特征
- **区间合法性统计**：要求统计满足特定区间条件的元素对
- **颜色/类别分组**：元素具有类别属性，需要分组处理
- **动态维护有效区间**：需要快速判断当前元素的历史有效范围

### 通用解法
1. **双指针法**：维护左右边界指针，如滑动窗口问题
2. **前缀和+分组统计**：对元素分组后，使用前缀和快速计算区间属性
3. **最近有效位置追踪**：通过变量记录关键位置（如本题的 now）

---

# 推荐练习题
1. P2671 子串计算（NOIP2015 普及组）  
   - 同类技巧：前缀和统计区间属性
2. P1908 逆序对  
   - 相似思想：分组统计与树状数组应用
3. P3143 钻石收藏家  
   - 同类场景：滑动窗口维护合法区间

---

# 可视化与算法演示设计

### 动画方案
1. **客栈序列展示**：  
   - 用不同颜色方块表示客栈色调  
   - 红色标记表示消费 ≤p 的咖啡店
   ```javascript
   // 伪代码示例
   function drawInn(i, color, isCafe) {
       ctx.fillStyle = COLORS[color];
       ctx.fillRect(i*CELL_SIZE, 0, CELL_SIZE, CELL_SIZE);
       if (isCafe) drawRedBorder(i);
   }
   ```

2. **指针动态移动**：  
   - 高亮 now 指针（绿色箭头）表示最近合法咖啡店  
   - 显示 last[color] 指针（黄色虚线）表示颜色最后出现位置
   ```javascript
   function updatePointers() {
       drawArrow(now * CELL_SIZE, 'green'); // now指针
       colors.forEach(c => {
           drawDashedLine(last[c] * CELL_SIZE, 'yellow'); // last指针
       });
   }
   ```

3. **统计面板**：  
   - 实时显示 sum/cnt/last 数组的数值变化  
   - 用柱状图表示各颜色当前可匹配数量
   ```javascript
   function updateStats() {
       statsPanel.innerHTML = `
       Color | Last | Sum | Cnt
       --------------------------
       ${colors.map(c => `${c} | ${last[c]} | ${sum[c]} | ${cnt[c]}`)}
       `;
   }
   ```

### 复古像素风格
- **8位调色板**：使用 NES 风格的 16 色调色板  
- **音效设计**：  
  - 合法咖啡店出现：短促 "叮" 声（三角波生成）  
  - 统计更新：8-bit "哔" 声  
  - 错误操作：低沉噪音
- **自动演示模式**：  
  ```javascript
  let autoPlay = setInterval(() => {
      if (currentStep >= n) clearInterval(autoPlay);
      processNextInn();
  }, 1000);
  ```

---

# 代码实现（核心逻辑）

### 最优解代码（ShawnZhou）
```cpp
#include <iostream>
using namespace std;
const int maxn = 2e5+5;
int n,k,p,color,price,now,ans;
int last[maxn], sum[maxn], cnt[maxn];

int main() {
    cin >> n >> k >> p;
    for(int i=1; i<=n; i++) {
        cin >> color >> price;
        if(price <= p) now = i;
        if(now >= last[color]) sum[color] = cnt[color];
        ans += sum[color];
        last[color] = i;
        cnt[color]++;
    }
    cout << ans;
}
```

### 容斥法代码（Shunpower）
```cpp
int n,k,p,cnt[51],ans;
stack<int> st;

ll C(int n) { return n*(n-1)/2; }

int main() {
    fr1(i,1,n) {
        if(b[i]>p) cnt[a[i]]++, st.push(a[i]);
        if(i==n || b[i]<=p) {
            while(!st.empty()) {
                ans -= C(cnt[st.top()]);
                cnt[st.top()]=0; st.pop();
            }
        }
    }
    cout << ans + total;
}
```

---

# 个人心得摘录

### 调试经验
> "容斥法中需要特别注意边界情况，比如当整个序列都没有合法咖啡店时，所有同色对都要被扣除" —— Shunpower

### 思维突破
> "意识到 sum[color] 实际上记录的是『最后一个合法咖啡店之前的所有同色客栈数量』，这是将双重循环优化为单次扫描的关键" —— ShawnZhou

### 性能优化
> "树状数组解法虽然理论复杂度稍高，但由于 K 很小，实际运行效率与线性算法相差无几" —— zhengrunzhe

---
处理用时：123.44秒
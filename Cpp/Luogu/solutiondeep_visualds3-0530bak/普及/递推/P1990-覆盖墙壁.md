# 题目信息

# 覆盖墙壁

## 题目描述

你有一个长为 $N$ 宽为 $2$ 的墙壁，给你两种砖头：一个长 $2$ 宽 $1$，另一个是 L 型覆盖 $3$ 个单元的砖头。如下图：

```
0  0
0  00
```

砖头可以旋转，两种砖头可以无限制提供。你的任务是计算用这两种来覆盖 $N\times 2$ 的墙壁的覆盖方法。例如一个 $2\times3$ 的墙可以有 $5$ 种覆盖方法，如下：
```
012 002 011 001 011  
012 112 022 011 001
```
注意可以使用两种砖头混合起来覆盖，如 $2\times4$ 的墙可以这样覆盖：
```
0112
0012
```
给定 $N$，要求计算 $2\times N$ 的墙壁的覆盖方法。由于结果很大，所以只要求输出最后 $4$ 位。例如 $2\times 13$ 的覆盖方法为 $13465$，只需输出 $3465$ 即可。如果答案少于 $4$ 位，就直接输出就可以，不用加前导 $0$，如 $N=3$ 时输出 $5$。


## 说明/提示

数据保证，$1\leq N\leq 1000000$。

## 样例 #1

### 输入

```
13```

### 输出

```
3465```

# AI分析结果



## 算法分类
动态规划（递推）

---

## 题解思路与核心分析

### 核心算法流程
所有题解均基于动态规划，核心思路是找到递推式描述状态转移。关键在于如何处理 L 型砖块带来的复杂覆盖情况，通过分解状态或数学推导简化计算。

#### 关键难点对比
1. **状态定义**  
   - 主流解法分为两类：双状态辅助数组（F/G 数组）和单状态前缀和优化。
   - **双状态法**（info___tion）：定义 `F[n]` 表示填满前 n 列的方案数，`G[n]` 表示填满前 n+1 列但第 n+1 列有一个空缺的方案数。通过分情况讨论砖块摆放推导递推式。
   - **单状态法**（Lylighte）：通过前缀和与数学变换，将递推式简化为 `F[n] = 2*F[n-1] + F[n-3]`，大幅减少空间复杂度。

2. **递推式推导**  
   - info___tion 的推导需要引入辅助状态 `G`，适合分步理解 L 型砖的影响。
   - Lylighte 通过数学合并将原式简化为线性递推，极大优化代码实现。

3. **空间优化**  
   - Juvenile 和环日加速器通过滚动变量实现 O(1) 空间，尤其适合大规模数据（N ≤ 1e6）。

---

## 高分题解推荐（≥4星）

### ⭐⭐⭐⭐⭐ [Lylighte] 递推式优化
- **亮点**：通过数学推导将复杂前缀和简化为 `F[n] = 2*F[n-1] + F[n-3]`，代码简洁高效。
- **代码**：
  ```cpp
  F[n] = (2*F[n-1] + F[n-3]) % 10000;
  ```
- **优化点**：无需辅助数组，空间复杂度 O(1)，时间复杂度 O(n)。

### ⭐⭐⭐⭐⭐ [info___tion] 双状态递推
- **亮点**：详细推导状态转移方程，适合教学理解。
- **代码**：
  ```cpp
  f[i] = (f[i-1] + f[i-2] + 2*g[i-2]) % mod;
  g[i] = (g[i-1] + f[i-1]) % mod;
  ```
- **适用场景**：需要分步理解 L 型砖块贡献的场景。

### ⭐⭐⭐⭐ [Juvenile] 极简递推
- **亮点**：直接给出简化递推式，代码实现最简。
- **代码**：
  ```cpp
  dp[i] = (dp[i-1]*2 + dp[i-3]) % 10000;
  ```
- **注意**：需正确初始化前 3 项（dp[1]=1, dp[2]=2, dp[3]=5）。

---

## 最优思路提炼
**递推式简化**：  
通过数学变换将问题转化为 `F[n] = 2*F[n-1] + F[n-3]`，仅需维护三个滚动变量：
```cpp
int a = 1, b = 1, c = 2; // F[0], F[1], F[2]
for (int i=3; i<=n; i++) {
    int next = (2*c + a) % 10000;
    a = b; b = c; c = next;
}
```

---

## 同类问题推荐
1. **爬楼梯问题**（LeetCode 70）：简单递推。
2. **瓷砖填充问题**（洛谷 P1965）：二维递推变形。
3. **多米诺骨牌覆盖**（LeetCode 790）：类似状态分解。

---

## 可视化算法设计

### 动态递推演示（8位像素风格）
1. **动画方案**  
   - **网格绘制**：Canvas 绘制 2×N 网格，每步填充对应砖块，L 型砖用不同颜色标记。
   - **变量跟踪**：右侧面板显示当前递推变量（a, b, c）的值，颜色高亮当前更新位置。

2. **交互设计**  
   - **步进控制**：支持单步/自动播放，速度可调。
   - **音效提示**：每次更新播放 8-bit 音效，计算完成时播放胜利音效。

3. **复古风格**  
   - **调色板**：使用 FC 红白机风格的 16 色方案。
   - **背景音乐**：循环播放《超级马里奥》风格 MIDI 音乐。

---

## 题解代码（最优简化版）
```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    if (n == 1) { cout << 1; return 0; }
    if (n == 2) { cout << 2; return 0; }
    int a = 1, b = 1, c = 2; // F[0], F[1], F[2]
    for (int i = 3; i <= n; i++) {
        int next = (2*c + a) % 10000;
        a = b; b = c; c = next;
    }
    cout << c;
    return 0;
}
```

---

## 总结
本题核心在于通过递推分解状态或数学优化，将复杂砖块覆盖问题转化为线性递推。推荐掌握 `F[n] = 2*F[n-1] + F[n-3]` 的简化式，其代码简洁且效率最优。

---
处理用时：115.28秒
# 题目信息

# 不成熟的梦想家 (未熟 DREAMER)

## 题目背景

**どんな未来かは 誰もまだ知らない**

**那是个任谁也不会知晓的未来**

**でも楽しくなるはずだよ**

**但应该会充满乐趣吧**

**みんなとなら乗りこえられる**

**只要大伙儿同在 就能跨越难关**

**これからなんだねお互いがんばろうよ**

**现在才正要开始 彼此互相加油吧**

**どんな未来かは 誰もまだ知らない**

**那是个任谁也不会知晓的未来**

**でも楽しくしたホントに**

**不过真心期望能够充满着乐趣**

**みんなとなら無理したくなる**

**只要大伙儿同在 就会想将顾虑抛诸脑后**

**成長したいなまだまだ未熟DREAMER**

**愿能有所成长 如今还只是尚未成熟的梦想家**

 ![](https://cdn.luogu.com.cn/upload/pic/4493.png) 

Aqours的成员终于到齐了。


今天，是我们全员在一起的第一场演唱会。


大家都好好练习过了，相信一定会表现得很出色的。


不过，每个人的唱功也要尽量地接近才可以呢，如果太突出或者太落后，也是会影响表现的样子。


所以我们从隔壁的学园都市借来了一个发明，可以改变我们成员的唱功呢。


## 题目描述

我们Aqours的成员共有N+1人，他们会列成一队。

他们的唱功以A[0]到A[N]表示，A[i]$(0\le i \le N)$均给出。

学园都市的机器可以改变队列中连续多个成员的唱功值，并将其加上一个数Z，当然当Z是负数的时候就变成减去了。

我打算一共使用这个机器Q次，每次把第X到第Y号（$1\le X,Y\le10^6$）的成员都加上Z点唱功值。

而我们队伍的魅力值B，是这么算的：

一开始B=0，然后从第1号到第N号成员，

- 当$A_{i-1}<A_i$：$B = B-S\cdot|A_{i-1} - A_i|$
- 当$A_{i-1}>A_i$：$B = B+T\cdot|A_{i-1} - A_i|$
其中S和T是LoveLive组委会给我们的常数。

果然，我是バカチカ（笨蛋千歌）呢，所以作为领导我永远排在队伍的开头，唱功永远是0，机器也不会改到我头上呢。

你能帮我们算算，我**每次**使用完这个机器之后，成员的魅力B是多少吗？


## 说明/提示

30% 的数据 $N,Q\le 2000$,

另外20% 的数据 $S=T$

100%的数据 $N,Q\le 200000$；$1\le S,T,A_i\le10^6$；$|Z|\le 10^6$
请注意可能需要使用int64，cin/cout可能超时。

样例解释：

第一次变化后，

A 0 6 3 4 6

B -12 -3 -5 -9


#### 以下是彩蛋

没有。

哪来的那么多彩蛋？


## 样例 #1

### 输入

```
4 3 2 3
0
5
2
4
6
1 2 1
3 4 -3
1 4 2
```

### 输出

```
-9
-1
-5
```

# AI分析结果



# 算法分类
**差分**

---

## 题解思路与核心分析

### **核心算法流程**
1. **预处理差分数组**：计算相邻元素的差分值 d[i] = A[i] - A[i-1]
2. **初始魅力值计算**：根据差分数组，统计每个差分值对魅力值 B 的贡献
3. **区间修改处理**：每次操作 [X,Y] 区间加 Z 时：
   - 更新差分数组 d[X] += Z（影响左边界）
   - 若 Y < n，更新差分数组 d[Y+1] -= Z（影响右边界）
   - 重新计算这两个差分点对 B 的贡献差值
4. **实时输出**：每次操作后输出总魅力值 B

### **解决难点**
- **数学推导**：发现区间加操作对区间内相邻元素差的绝对值无影响，仅需处理区间端点
- **高效维护**：通过差分数组将区间修改降为 O(1) 操作，避免暴力 O(n) 遍历
- **边界处理**：当 Y = n 时不操作 d[Y+1]，防止数组越界

---

## 题解评分（≥4星）

1. **lin_toto（5星）**
   - 亮点：官方题解，清晰指出差分本质和贡献撤销机制
   - 代码简洁，直接操作差分数组，无冗余逻辑

2. **顾z（5星）**
   - 亮点：类比 JOI 焚风现象，强化差分模板题认知
   - 代码高度优化，使用函数封装贡献计算

3. **ILLENIUM_DOOR（4星）**
   - 亮点：详细注释边界条件，适合初学者理解
   - 提供完整 AC 代码，变量命名规范

---

## 最优思路与技巧

### **关键技巧**
```cpp
inline int calc(int x) {
    return x>0 ? -S*x : -T*x; // 贡献计算函数化
}

// 修改时撤销旧贡献，更新新贡献
ans -= calc(d[x]);
d[x] += z;
ans += calc(d[x]);

if (y != n) { // 边界保护
    ans -= calc(d[y+1]);
    d[y+1] -= z;
    ans += calc(d[y+1]);
}
```

### **思维突破点**
- **相对不变性**：区间内元素的相对差不变，只需处理端点差
- **贡献可逆性**：通过先减旧值再加新值，实现动态维护总和

---

## 相似题目推荐
1. **P3368** 树状数组模板（区间修改+单点查询）
2. **P5482** 差分与前缀和的进阶应用
3. **P4552** 差分转化求极值

---

## 可视化设计

### **动画方案**
1. **差分数组网格**：用像素方块表示 d[1]~d[n]，初始显示差分值和对应贡献
2. **操作高亮**：
   - 修改 X 时，d[X] 方块闪烁红色并显示 +Z
   - 修改 Y+1 时（Y≠n），方块闪烁蓝色并显示 -Z
3. **贡献流动**：从修改点向总 B 值图标（❤️）流动光效，颜色根据贡献正负变化
4. **音效设计**：
   - 修改时播放 8-bit "blip" 音效
   - 总 B 值更新时播放不同音调提示

### **复古风格**
```javascript
// 伪代码示例：Canvas绘制差分方块
function drawDiffArray() {
    ctx.fillStyle = '#8B8B83'; // 复古灰
    for (let i=1; i<=n; i++) {
        // 绘制带边框的像素方块
        ctx.fillRect(20*i, 50, 18, 18);
        ctx.strokeStyle = '#FFD700'; // 金色边框
        ctx.strokeRect(20*i, 50, 18, 18);
        // 显示差分值和贡献
        drawText(d[i], 20*i+2, 60);
        drawText(calc(d[i]), 20*i+2, 75);
    }
}
```

---

## 代码实现（顾z版核心逻辑）
```cpp
#include<cstdio>
#include<cctype>
#define int long long
#define R register
using namespace std;
inline void in(int &x) { /* 快读函数 */ }

int N,Q,S,T,ans,last,A[200008];

inline int calc(int x) {
    return x>0 ? -S*x : -T*x;
}

signed main() {
    in(N),in(Q),in(S),in(T);
    for(R int i=0,x;i<=N;i++) {
        in(x);
        A[i] = x - last; // 计算差分
        ans += calc(A[i]);
        last = x;
    }
    for(R int i=1,x,y,z;i<=Q;i++) {
        in(x),in(y),in(z);
        // 处理左边界
        ans -= calc(A[x]);
        A[x] += z;
        ans += calc(A[x]);
        // 处理右边界
        if(y != N) {
            ans -= calc(A[y+1]);
            A[y+1] -= z;
            ans += calc(A[y+1]);
        }
        printf("%lld\n",ans);
    }
}
```

---

## 总结
通过差分将区间操作转化为端点操作是本题核心，结合动态维护贡献值实现高效计算。可视化设计通过像素风格和音效反馈，强化对差分机制的理解。

---
处理用时：75.48秒
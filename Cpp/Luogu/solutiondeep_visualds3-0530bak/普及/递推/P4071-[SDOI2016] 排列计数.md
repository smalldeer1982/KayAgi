# 题目信息

# [SDOI2016] 排列计数

## 题目描述

求有多少种 $1$ 到 $n$ 的排列 $a$，满足序列恰好有 $m$ 个位置 $i$，使得 $a_i = i$。

答案对 $10^9 + 7$ 取模。

## 说明/提示

#### 数据规模与约定

本题共 20 个测试点，各测试点等分，其数据规模如下表。

| 测试点编号 | $T =$  | $n, m \leq$ |  测试点编号  |      $T =$      | $n, m \leq$ |
| :--------: | :----: | :---------: | :----------: | :-------------: | :---------: |
| $1\sim 3$  | $10^3$ |     $8$     | $10 \sim 12$ |     $10^3$      |   $10^3$    |
| $4 \sim 6$ | $10^3$ |    $12$     | $13 \sim 14$ | $5 \times 10^5$ |   $10^3$    |
| $7 \sim 9$ | $10^3$ |    $100$    | $15 \sim 20$ | $5 \times 10^5$ |   $10^6$    |

对于全部的测试点，保证 $1 \leq T \leq 5 \times 10^5$，$1 \leq n \leq 10^6$，$0 \leq m \leq 10^6$。

## 样例 #1

### 输入

```
5
1 0
1 1
5 2
100 50
10000 5000```

### 输出

```
0
1
20
578028887
60695423```

# AI分析结果



## 算法分类
**组合数学（错位排列）**

---

## 题解思路与核心难点

### **核心思路**
1. **组合选择**：从 `n` 个位置中选择 `m` 个固定位置，方法数为组合数 `C(n, m)`。
2. **错位排列**：剩余 `n-m` 个位置必须全错排，递推公式为 `D[i] = (i-1)*(D[i-1] + D[i-2])`，其中 `D[0] = 1`，`D[1] = 0`。
3. **快速计算**：预处理阶乘、阶乘逆元、错排数组，实现 `O(1)` 查询。

### **解决难点**
- **大数处理**：`n ≤ 1e6`，需线性预处理阶乘和逆元。
- **错排递推**：边界条件 `D[0] = 1` 易忽略，需确保递推正确性。
- **模运算优化**：使用费马小定理求逆元，避免除法取模。

---

## 题解评分（≥4星）

### 1. 冒泡ioa（赞90）⭐️⭐️⭐️⭐️⭐️
- **亮点**：代码简洁高效，预处理阶乘+逆元+错排，特例处理清晰。
- **关键代码**：
  ```cpp
  void prework() {
      fac[0] = 1;
      for (int i=1; i<MAXN; i++) fac[i] = fac[i-1]*i % mod;
      inv[MAXN-1] = qpow(fac[MAXN-1], mod-2);
      for (int i=MAXN-2; i>=0; i--) inv[i] = inv[i+1] * (i+1) % mod;
      d[1]=0, d[2]=1;
      for (int i=3; i<MAXN; i++) d[i] = (i-1)*(d[i-1]+d[i-2]) % mod;
  }
  ```

### 2. Warriors_Cat（赞8）⭐️⭐️⭐️⭐️
- **亮点**：逻辑清晰，注释详细，强调错排的递推推导。
- **个人心得**：在代码中明确提到“特判n=m的情况”，避免边界错误。

### 3. 御·Dragon（赞1）⭐️⭐️⭐️⭐️
- **亮点**：代码模块化，独立函数处理逆元与错排，可读性强。
- **关键优化**：使用 `(mod - mod/i) * inv[mod%i] % mod` 线性求逆元。

---

## 最优技巧提炼

### 核心技巧
1. **预处理三件套**：
   - 阶乘 `fac[i] = i! % mod`
   - 阶乘逆元 `inv[i] = (fac[i])^(mod-2) % mod`
   - 错排数组 `d[i]` 递推计算。
2. **组合数公式**：`C(n, m) = fac[n] * inv[m] * inv[n-m] % mod`。
3. **错排递推初始化**：`d[0] = 1`（空序列算一种方案），`d[1] = 0`。

### 代码片段
```cpp
// 预处理阶乘和逆元
fac[0] = 1;
for (int i=1; i<=N; i++) fac[i] = fac[i-1] * i % mod;
inv[N] = qpow(fac[N], mod-2);
for (int i=N-1; i>=0; i--) inv[i] = inv[i+1] * (i+1) % mod;

// 错排递推
d[0] = 1, d[1] = 0;
for (int i=2; i<=N; i++) 
    d[i] = (i-1) * (d[i-1] + d[i-2]) % mod;

// 查询答案
ans = fac[n] * inv[m] % mod * inv[n-m] % mod * d[n-m] % mod;
```

---

## 类似题目推荐
1. **P1595 信封问题** - 错排模板题。
2. **P3807 卢卡斯定理** - 组合数取模的扩展应用。
3. **P3197 越狱** - 组合计数与容斥原理结合。

---

## 可视化设计（复古像素风格）

### 动画方案
1. **数据结构展示**：
   - **网格布局**：用像素方块表示数组 `fac`、`inv`、`d`，每次更新时方块闪烁。
   - **颜色标记**：当前计算的 `i` 用红色边框，已计算部分用绿色填充。

2. **错排递推演示**：
   - **步进动画**：展示 `d[i] = (i-1)*(d[i-1] + d[i-2])` 的计算过程。
   - **音效触发**：每次递推时播放 8-bit 音效（如《超级玛丽》金币声）。

3. **组合数计算**：
   - **公式分解**：逐步显示 `C(n,m) = n!/(m!(n-m)!)` 的分子分母，用像素箭头连接。

### 交互功能
- **控制面板**：暂停/继续按钮，速度滑块（1x, 2x, 5x）。
- **自动模式**：AI 自动演示预处理和查询过程，类似《俄罗斯方块》自动下落。

---

## 代码实现（关键部分）
```javascript
// 伪代码：像素动画核心逻辑
class PixelAnimator {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.gridSize = 16; // 16x16像素方块
        this.colors = { 
            current: '#FF0000', 
            computed: '#00FF00',
            text: '#FFFFFF'
        };
    }

    drawStep(i, value) {
        // 绘制第i个方块，背景色标记状态
        const x = (i % 10) * this.gridSize;
        const y = Math.floor(i / 10) * this.gridSize;
        this.ctx.fillStyle = this.colors.current;
        this.ctx.fillRect(x, y, this.gridSize, this.gridSize);
        // 显示数值
        this.ctx.fillStyle = this.colors.text;
        this.ctx.fillText(value, x+2, y+12);
    }

    playSound(effect) {
        // 触发8-bit音效，如Web Audio API
    }
}
```

---

**总结**：本题通过组合数与错排的结合，展现了预处理在大规模查询中的高效性。可视化设计通过复古像素风格增强学习趣味性，帮助理解递推与模运算的核心逻辑。

---
处理用时：98.90秒
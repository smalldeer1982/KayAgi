# 题目信息

# [USACO17DEC] My Cow Ate My Homework S

## 题目描述

在你的牛历史课上，你被布置了一份相当长的作业，包含 $N$ 个问题（$3 \leq N \leq 100,000$），每个问题的得分是一个在 0 到 10,000 之间的整数。按照惯例，你的老师计划通过去掉你得分最低的一个问题，然后对剩余问题的得分取平均来给出最终成绩。不幸的是，你的宠物奶牛 Bessie 刚刚吃掉了你前 $K$ 个问题的答案！（$K$ 可能小到 1，也可能大到 $N-2$）。

经过多次解释，你的老师终于相信了你的说法，并同意按照之前的方式对剩余的未被吃掉的部分作业进行评分——即去掉得分最低的问题（或在得分相同的情况下去掉其中一个），然后对剩余问题取平均。

请输出所有能够使你获得最高可能成绩的 $K$ 值，并按升序排列。

## 说明/提示

如果 Bessie 吃掉了前两个问题，那么剩余的得分是 9、2 和 7。去掉最低分并取平均后，最终成绩为 8，这是可能的最高成绩。

## 样例 #1

### 输入

```
5
3 1 9 2 7```

### 输出

```
2```

# AI分析结果



## 唯一算法分类  
后缀预处理（贪心）

---

## 综合分析与结论  
题目核心是快速计算每个 K 对应的区间最值和总和。各题解均围绕这一核心展开，关键差异在于预处理方式与数据结构选择：

1. **核心算法流程**  
   - **预处理后缀最值**：倒序遍历数组，维护每个位置到末尾的最小值（`mn[i] = min(a[i], mn[i+1])`）
   - **预处理后缀和**：倒序累加计算区间和（`sum[i] = a[i] + sum[i+1]`）
   - **计算平均值**：对每个 K，计算 `(sum[K+1] - mn[K+1]) / (n-K-1)`，记录最大平均值及对应的 K

2. **可视化设计思路**  
   - **动画方案**：将数组横向排列，用不同颜色标记当前处理的元素。倒序遍历时，用高亮箭头指示当前元素，动态更新右侧的最小值和总和数值。
   - **关键步骤高亮**：最小值更新时用红色闪烁，总和累加时用绿色流动效果。
   - **对比模式**：并行展示暴力法（逐次遍历区间）与预处理法的步骤数，突显后者的效率优势。

---

## 题解清单（≥4星）

1. **作者：_jimmywang_（⭐️⭐️⭐️⭐️⭐️）**  
   - **关键亮点**：代码简洁，预处理与计算分离，逻辑清晰；使用倒序遍历合并最小值与和的计算，空间优化明显。
   - **代码片段**：  
     ```cpp
     for(int i=n;i>=2;i--) {
         mn[i] = min(mn[i+1], a[i]);
         sum[i] = sum[i+1] + a[i];
         avr[i] = (sum[i]-mn[i]) / (double)(n-i);
     }
     ```

2. **作者：Siyuan（⭐️⭐️⭐️⭐️）**  
   - **关键亮点**：实时维护最小值和总和，避免额外数组；逆序输出优化节省内存。
   - **个人心得**："注意区间元素个数是 `n-i` 而非 `n-i+1`"，避免常见边界错误。

3. **作者：TRZ_2007（⭐️⭐️⭐️⭐️）**  
   - **关键亮点**：独立计算前缀和与后缀最小值，结构清晰；显式处理精度问题（`EPS` 常量）。

---

## 最优思路提炼  
1. **倒序预处理**：从后往前遍历，O(n) 时间计算每个位置的后缀最小值和总和。
2. **数学简化**：平均值公式转化为 `(总和 - 最小值) / 元素个数`，避免重复遍历。
3. **精度处理**：浮点数比较时使用 `EPS` 容差（如 `fabs(a-b) < 1e-6`）。

---

## 类似题目推荐  
1. **P2870 [USACO07DEC]Best Cow Line, Gold**（后缀比较决策）
2. **P2216 [HAOI2007] 理想的正方形**（二维滑动窗口最值）
3. **P1886 滑动窗口 /【模板】单调队列**（区间最值优化）

---

## 可视化代码片段（JavaScript）  
```javascript
// Canvas 初始化与动画循环
const canvas = document.getElementById('animation');
const ctx = canvas.getContext('2d');
let currentStep = n; // 倒序指针

function drawArray() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let i=1; i<=n; i++) {
        // 高亮当前处理元素（红色边框）
        if (i === currentStep) ctx.strokeStyle = '#ff0000';
        else ctx.strokeStyle = '#000000';
        ctx.strokeRect(i*50, 100, 40, 40);
        // 显示当前最小值和总和（动态更新）
        ctx.fillText(`min=${mn[i]}`, i*50, 160);
        ctx.fillText(`sum=${sum[i]}`, i*50, 180);
    }
}

function animate() {
    if (currentStep >= 2) {
        updateSuffixValues(currentStep); // 更新 mn 和 sum
        currentStep--;
        drawArray();
        requestAnimationFrame(animate);
    }
}
```

---

## 复古像素风设计要点  
1. **8位风格**：使用 16 色调色板（如 #FF69B4 粉色表示当前元素，#00FF00 绿色表示最小值）。
2. **音效设计**：  
   - **元素更新**：播放 8-bit "哔" 声（Web Audio API 生成 400Hz 方波）
   - **找到最大 K**：播放胜利音效（快速上升音阶）
3. **自动演示**：按固定时间间隔（如 500ms）步进，模拟红白机卡带加载效果。

---
处理用时：85.18秒
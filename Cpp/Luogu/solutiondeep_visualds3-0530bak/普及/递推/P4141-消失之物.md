# 题目信息

# 消失之物

## 题目描述

ftiasch 有 $n$ 个物品, 体积分别是 $w_1,w_2,\dots,w_n$。由于她的疏忽，第 $i$ 个物品丢失了。   

“要使用剩下的 $n-1$ 物品装满容积为 $x$ 的背包，有几种方法呢？”——这是经典的问题了。  

她把答案记为 $\text{cnt}(i,x)$ ，想要得到所有$i \in [1,n]$, $x \in [1,m]$ 的 $\text{cnt}(i,x)$ 表格。

![](https://cdn.luogu.com.cn/upload/pic/13426.png)


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n,m \le 2000$，且 $1\le v_i\le m$。

【样例解释】  
如果物品 3 丢失的话，只有一种方法装满容量是 2 的背包，即选择物品 1 和物品 2。

---

$\text{upd 2023.8.11}$：新增加五组 Hack 数据。


## 样例 #1

### 输入

```
3 2
1 1 2```

### 输出

```
11
11
21```

# AI分析结果



**唯一算法分类**：动态规划（退背包）

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **预处理总方案**：先通过01背包计算所有物品的总方案数`f[j]`。
2. **退背包操作**：对每个物品`i`，从总方案`f[j]`中逆向扣除该物品的贡献，得到不包含`i`的方案数`g[j]`。
3. **数学推导**：当扣除物品`i`时，`g[j] = f[j] - g[j - w[i]]`，需保证减法不出现负数（加10后取模）。

#### **解决难点**
- **逆向操作的正确性**：原01背包是倒序转移，退背包需正序撤销。
- **空间优化**：部分题解使用二维数组，但最优解法用一维数组，通过正序循环避免覆盖。
- **负数处理**：`g[j] = (f[j] - g[j - w[i]] + 10) % 10`确保结果非负。

---

### **题解评分 (≥4星)**

1. **Kelin (⭐⭐⭐⭐⭐)**  
   - **亮点**：提出“退背包”核心思想，通过正序循环逆向撤销转移，代码简洁高效。  
   - **代码可读性**：使用`memcpy`和单层循环，逻辑清晰。

2. **Gary818 (⭐⭐⭐⭐)**  
   - **亮点**：明确公式`g[x] = f[x] - g[x - w[i]]`，并解释负数处理技巧。  
   - **实践性**：代码附带详细注释，适合新手理解。

3. **7KByte (⭐⭐⭐⭐)**  
   - **亮点**：证明物品顺序无关性，提出“撤销转移”的严格数学依据。  
   - **创新性**：代码用`rep`宏简化循环，风格紧凑。

---

### **最优思路或技巧提炼**

1. **退背包公式**：  
   ```cpp
   g[j] = (f[j] - g[j - w[i]] + 10) % 10;
   ```
   此公式通过逆向操作原01背包的转移，扣除物品`i`的贡献。

2. **一维数组优化**：  
   仅用一维数组`f[]`和`g[]`，避免二维数组的空间浪费。

3. **正序循环撤销**：  
   原01背包是倒序转移，退背包需正序处理，防止覆盖未更新的值。

---

### **同类型题或类似算法套路**

- **退背包扩展**：适用于需动态删除物品的背包问题，如「[洛谷P4142 洞穴探测](https://www.luogu.com.cn/problem/P4142)」。
- **容斥思想**：通过总方案减去非法方案，类似「[CF1527E Partition Game](https://codeforces.com/problemset/problem/1527/E)」。

---

### **推荐相似题目**

1. **P1048 [NOIP2005 普及组] 采药**  
   （基础01背包，理解退背包的前置知识）

2. **P1064 [NOIP2006 提高组] 金明的预算方案**  
   （依赖背包，需分情况讨论物品组合）

3. **P2014 [CTSC1997] 选课**  
   （树形背包，拓展到树形结构的动态规划）

---

### **个人心得摘录**

- **King丨帝御威**：调试中发现未加`+10`导致负数，强调取模细节。  
- **keep_**：通过`g[j - w[i]]`理解扣除逻辑，避免重复计算。  
- **7KByte**：证明物品顺序无关性，确保退背包的正确性。

---

### **可视化与算法演示**

#### **动画设计**
- **背包容量轴**：横向展示容量`1~m`，每个格子表示`f[j]`的值。
- **退背包过程**：  
  1. 高亮当前物品`w[i]`，播放音效提示开始处理。  
  2. 正序遍历`j = w[i] ~ m`，将`g[j]`更新为`f[j] - g[j - w[i]]`，颜色标记变化的`j`。  
  3. 每步显示公式`g[j] = (f[j] - g[j - w[i]] + 10) % 10`的数值变化。

#### **复古像素风格**
- **8位颜色**：背包容量用16色像素块表示，绿色表示`g[j]`增加，红色表示减少。  
- **音效设计**：  
  - **转移音效**：8-bit“滴”声，每次更新`g[j]`时触发。  
  - **完成音效**：过关时播放经典FC胜利音乐。  
- **自动演示模式**：AI按物品顺序逐步处理，支持暂停/加速。

---

### **核心代码实现**

```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int N = 2005;
int n, m, w[N], f[N], g[N];

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> w[i];
    f[0] = 1;
    // 预处理总背包
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= w[i]; j--)
            f[j] = (f[j] + f[j - w[i]]) % 10;
    // 退背包
    for (int i = 1; i <= n; i++) {
        memcpy(g, f, sizeof(f));
        for (int j = w[i]; j <= m; j++)
            g[j] = (g[j] - g[j - w[i]] + 10) % 10;
        // 输出结果
        for (int j = 1; j <= m; j++) cout << g[j];
        cout << endl;
    }
    return 0;
}
```

**代码说明**：  
- `memcpy`复制总方案到`g[]`，正序扣除物品`i`的贡献。  
- `+10`确保减法结果非负，取模输出末位数字。

---
处理用时：94.79秒
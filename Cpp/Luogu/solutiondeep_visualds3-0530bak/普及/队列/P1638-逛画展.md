# 题目信息

# 逛画展

## 题目描述


博览馆正在展出由世上最佳的 $m$ 位画家所画的图画。

游客在购买门票时必须说明两个数字，$a$ 和 $b$，代表他要看展览中的第 $a$ 幅至第 $b$ 幅画（包含 $a,b$）之间的所有图画，而门票的价钱就是一张图画一元。

Sept 希望入场后可以看到所有名师的图画。当然，他想最小化购买门票的价格。

请求出他购买门票时应选择的 $a,b$，数据保证一定有解。

若存在多组解，**输出 $a$ 最小的那组**。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，有 $n\le200$，$m\le20$。
- 对于 $60\%$ 的数据，有 $n\le10^5$，$m\le10^3$。
- 对于 $100\%$ 的数据，有 $1\leq n\le10^6$，$1 \leq a_i \leq m\le2\times10^3$。

## 样例 #1

### 输入

```
12 5
2 5 3 1 3 2 4 1 1 5 4 3
```

### 输出

```
2 7```

# AI分析结果



**唯一算法分类**：滑动窗口（双指针）

---

### **题解思路、算法要点与解决难点**

#### **核心算法流程**
1. **滑动窗口（双指针）**：维护一个区间 `[L, R]`，动态调整左右边界使得区间包含所有 `m` 种画家，并最小化区间长度。
2. **哈希表/计数数组**：记录当前窗口内每个画家的出现次数，用于判断是否覆盖全部画家。
3. **贪心收缩左边界**：当窗口覆盖全部画家时，尽可能右移左指针以缩短区间。

#### **解决难点**
- **确定窗口何时覆盖所有画家**：通过计数变量 `cnt` 跟踪当前窗口内不同画家的数量。
- **高效收缩左边界**：若左端点对应的画在窗口中出现多次，则右移左指针不会影响覆盖性。
- **处理多解时的最小左端点**：在相同长度的解中优先记录左端点较小的。

---

### **题解评分（≥4星）**
1. **米奇（5星）**  
   - **亮点**：代码简洁，逻辑清晰，通过交替移动右指针和左指针逐步逼近最优解，变量命名明确。  
   - **核心代码**：
     ```cpp
     while(l <= r && r <= n) {
         if (k == m) { // 当前窗口有效
             if (ans > r - l + 1) { ans = r - l + 1; ll = l; rr = r; }
             b[a[l]]--; if (b[a[l]] == 0) k--; l++; // 收缩左边界
         } else { r++; b[a[r]]++; if (b[a[r]] == 1) k++; } // 扩展右边界
     }
     ```
2. **Sino_E（4.5星）**  
   - **亮点**：记录画家最后出现位置优化左指针移动，避免重复遍历。  
   - **关键优化**：
     ```cpp
     while (l != i && l < pos[pic[l]]) l++; // 若当前左端点画作在后续已出现，则右移左指针
     ```
3. **cuking（4星）**  
   - **亮点**：分两阶段处理，先找到初始有效窗口再动态调整，代码紧凑。  
   - **核心逻辑**：
     ```cpp
     // 第一阶段：找到第一个有效窗口
     while (num != M) { m[n[i]]++; if (m[n[i]] == 1) num++; R++; i++; }
     // 第二阶段：动态调整左右边界
     while (m[n[L]] > 1) m[n[L++]]--;
     ```

---

### **最优思路与技巧提炼**
1. **滑动窗口模板**：
   - **右指针扩展**：直到窗口满足条件（覆盖所有画家）。
   - **左指针收缩**：在满足条件时尽可能右移左指针，缩短区间。
2. **计数数组优化**：用数组代替哈希表记录出现次数，降低常数开销。
3. **贪心选择左端点**：在相同长度下优先记录更小的左端点。

---

### **类似题目推荐**
1. **P1638 逛画展（本题）**：滑动窗口模板题。
2. **P3406 最小矩形覆盖**：二维滑动窗口变种。
3. **P2678 跳石头**：二分答案与滑动窗口结合。

---

### **可视化与算法演示**
#### **动画设计**
1. **像素风格界面**：
   - 用 **16色像素块** 表示画作序列，不同颜色代表不同画家。
   - **左右指针**：红色（左指针）和蓝色（右指针）箭头动态移动。
   - **计数面板**：右侧显示当前窗口内各画家的出现次数（8-bit 风格数字）。
2. **关键操作高亮**：
   - **右指针扩展**：右指针右移时播放“滴”音效，新画作进入窗口时闪烁。
   - **左指针收缩**：左指针右移时播放“哒”音效，被移出画作变灰。
3. **自动演示模式**：
   - 按空格键切换手动/自动模式，自动模式下算法逐步执行，速度可调。
   - **音效触发**：成功覆盖所有画家时播放胜利音效，区间更新时显示绿色边框。

#### **交互示例**
```javascript
// 伪代码：Canvas 绘制滑动窗口
function drawWindow(L, R, minL, minR) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let i = 0; i < n; i++) {
        // 绘制画作块
        ctx.fillStyle = colors[paintings[i]];
        ctx.fillRect(i * BLOCK_SIZE, 0, BLOCK_SIZE, BLOCK_SIZE);
        // 高亮当前窗口
        if (i >= L && i <= R) ctx.strokeStyle = 'yellow';
        // 高亮最优解
        if (i >= minL && i <= minR) ctx.strokeStyle = 'green';
    }
}
```

---

### **总结**
滑动窗口法通过动态调整区间边界，在 O(n) 时间内高效解决问题。关键点在于维护窗口状态和贪心收缩策略，结合计数数组优化常数，适用于大规模数据。可视化设计通过像素动画和音效增强理解，适合教学演示。

---
处理用时：87.59秒
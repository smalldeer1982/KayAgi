# 题目信息

# 切蛋糕

## 题目描述

今天是小 Z 的生日，同学们为他带来了一块蛋糕。这块蛋糕是一个长方体，被用不同色彩分成了 $n$ 个相同的小块，每小块都有对应的幸运值。

小 Z 作为寿星，自然希望吃到的蛋糕的幸运值总和最大，但小 Z 最多又只能吃 $m(m\le n)$ 小块的蛋糕。

请你帮他从这 $n$ 小块中找出**连续**的 $k(1 \le k\le m)$ 块蛋糕，使得其上的总幸运值最大。

**形式化地**，在数列 $\{p_n\}$ 中，找出一个子段 $[l,r](r-l+1\le m)$，最大化 $\sum\limits_{i=l}^rp_i$。

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，有 $1\le n\le100$。
- 对于 $100\%$ 的数据，有 $1\le n\le5\times 10^5$，$|p_i|≤500$。

保证答案的绝对值在 $[0,2^{31}-1]$ 之内。

## 样例 #1

### 输入

```
5 2
1 2 3 4 5```

### 输出

```
9```

## 样例 #2

### 输入

```
6 3
1 -2 3 -4 5 -6```

### 输出

```
5```

# AI分析结果



# 唯一算法分类：单调队列

---

## 题解思路与核心难点

### 核心算法流程
1. **前缀和预处理**：计算数组前缀和数组`sum[]`
2. **单调队列维护最小值**：维护一个存储前缀和下标的双端队列，始终保持队列中元素对应的前缀和单调递增
3. **滑动窗口限制长度**：每次处理下标`i`时，先弹出队列中超出窗口范围（`i-m`之前）的元素
4. **动态更新答案**：用当前前缀和`sum[i]`减去队头元素的前缀和，更新最大子段和
5. **维护队列单调性**：将队列尾部所有前缀和大于当前`sum[i]`的元素弹出，保证单调性

### 解决难点
1. **初始值处理**：队列初始需放入`sum[0]`对应下标，避免第一个元素无法计算
2. **负数处理**：当所有元素为负数时，需确保队列能正确维护最小前缀和
3. **窗口长度限制**：需严格保证子段长度不超过`m`

---

## 最优题解推荐（≥4星）

### 题解1：fanfansann（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 强调初始队列加入`sum[0]`的必要性
- 正确处理单调递减数据
- 使用STL双端队列实现，代码简洁
```cpp
q.push_back(0); // 关键初始化
for(int i=1;i<=n;i++){
    while(q.front()+m < i) q.pop_front();
    ans = max(ans, sum[i]-sum[q.front()]);
    while(!q.empty() && sum[q.back()]>=sum[i]) q.pop_back();
    q.push_back(i);
}
```

### 题解2：fluttersunny（⭐⭐⭐⭐）
**关键亮点**：  
- 数组模拟队列提高效率
- 明确处理负数情况的初始化
```cpp
q[1]=0; // 队列初始值
for(int i=1;i<=n;i++){
    while(q[head]<i-m) head++;
    ans=max(ans,sum[i]-sum[q[head]]);
    while(sum[i]<=sum[q[tail]]) tail--;
    q[++tail]=i;
}
```

### 题解3：Jelly_Goat（⭐⭐⭐⭐）
**关键亮点**：  
- 详细推导单调队列的决策淘汰逻辑
- 代码注释清晰，包含快读优化
```cpp
while (head <= tail && sum[q[tail]] >= sum[i]) 
    tail--; // 淘汰劣质决策
```

---

## 核心代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int sum[N], q[N], n, m;

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        int x; scanf("%d",&x);
        sum[i] = sum[i-1] + x;
    }
    
    int ans = -1e9, head=1, tail=1;
    q[1] = 0; // 关键初始化
    
    for(int i=1;i<=n;i++){
        while(head<=tail && q[head]<i-m) head++;
        ans = max(ans, sum[i]-sum[q[head]]);
        while(head<=tail && sum[i]<=sum[q[tail]]) tail--;
        q[++tail] = i;
    }
    printf("%d",ans);
    return 0;
}
```

---

## 可视化设计要点

### 动画方案
1. **元素标记**：
   - 当前元素`i`：红色高亮
   - 队列元素：蓝色方框标记下标和对应前缀和
   - 过期元素：灰色并显示"×"符号

2. **操作步骤**：
   ```plaintext
   步骤1：[i=3] 检查队头q[0]是否在窗口内（3-2=1）
   步骤2：计算sum[3]-sum[0]=6，更新ans=6
   步骤3：弹出队列尾部sum[2]=3≥sum[3]=6? 否→入队
   ```

3. **复古风格**：
   - **像素网格**：用16x16像素块表示数组元素
   - **音效设计**：
     - 弹出元素：8-bit "beep"短音
     - 更新答案：上升音阶
   - **自动演示**：按F键加速，S键单步执行

---

## 相似题目推荐
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)  
   （单调队列模板题）
2. [P2627 修剪草坪](https://www.luogu.com.cn/problem/P2627)  
   （前缀和+单调队列优化DP）
3. [P2034 选择数字](https://www.luogu.com.cn/problem/P2034)  
   （带长度限制的最大子段和变形）

---
处理用时：86.09秒
# 题目信息

# 质量检测

## 题目描述

为了检测生产流水线上总共 $N$ 件产品的质量，我们首先给每一件产品打一个分数 $A$ 表示其品质，然后统计前 $M$ 件产品中质量最差的产品的分值 $Q[m] = min\{A_1, A_2, ... A_m\}$，以及第 2 至第 $M + 1$ 件的 $Q[m + 1], Q[m + 2] $... 最后统计第 $N - M + 1$ 至第 $N$ 件的 $Q[n]$。根据 $Q$ 再做进一步评估。

请你尽快求出 $Q$ 序列。


## 说明/提示

[数据范围]

30%的数据，$N \le 1000$

100%的数据，$N \le 100000$

100%的数据，$M \le N, A \le 1 000 000$


## 样例 #1

### 输入

```
10 4
16 5 6 9 5 13 14 20 8 12
```

### 输出

```
5
5
5
5
5
8
8
```

# AI分析结果



## 唯一算法分类：单调队列

### 综合分析与结论
本题核心是求解固定长度滑动窗口的最小值序列。数据规模达1e5级别，要求线性时间复杂度解法。各题解中**单调队列**和**ST表**是主流解法，其中：

1. **单调队列**（最优解法）
- 核心思想：维护递增的双端队列，队首始终为当前窗口最小值
- 时间复杂度：O(N) 每个元素入队出队各一次
- 空间复杂度：O(N) 存储下标队列
- 关键操作：
  - 移除非窗口内的过期元素（队头维护）
  - 移除比新元素大的队尾元素（保持单调性）

2. **ST表**（次优解法）
- 预处理各区间最小值（O(N logN)）
- 查询时合并两个覆盖窗口的区间（O(1)）
- 总时间：O(N logN + K)（K为窗口数）

### 题解清单（≥4星）
1. **My_666（5星）**
   - 思路清晰，代码简洁（25行核心逻辑）
   - 完整演示单调队列的入队、出队逻辑
   - 附带样例推演过程帮助理解
   - 关键代码：
     ```cpp
     while(h <= t && q1[h] + m <= i) h++; // 弹出过期元素
     while(h <= t && a[i] < a[q1[t]]) t--; // 维护单调性
     ```

2. **Ofnoname（4星）**
   - 使用标准库deque实现（12行核心逻辑）
   - 通过下标直接判断窗口边界
   - 代码可读性强，适合快速理解算法

3. **Youngsc（4星）**
   - 数组模拟队列实现
   - 包含输入优化技巧
   - 处理前m-1元素的初始化逻辑

### 关键代码实现（单调队列）
```cpp
void min_deque() {
    int h = 1, t = 0;
    for (int i = 1; i <= n; i++) {
        // 弹出过期元素（队头维护）
        while (h <= t && q[h] < i - m + 1) h++; 
        // 维护单调性（队尾优化）
        while (h <= t && a[i] <= a[q[t]]) t--; 
        q[++t] = i; // 存储下标
        if (i >= m) cout << a[q[h]] << "\n";
    }
}
```

### 可视化设计要点（复古像素风格）
1. **动画元素**：
   - 用绿色方块表示当前窗口
   - 红色高亮显示队列中元素
   - 黄色闪烁显示当前最小值

2. **交互设计**：
   - 步进按钮控制窗口移动
   - 速度滑块调节动画速度（1x-5x）
   - 音效触发：
     - "滴"声：元素入队
     - "嘟"声：元素出队
     - 胜利音效：输出最终序列

3. **Canvas绘制**：
   ```javascript
   function drawFrame() {
       ctx.clearRect(0, 0, canvas.width, canvas.height);
       // 绘制数组元素
       arr.forEach((val, idx) => {
           drawPixelBlock(idx*20, 50, val, 
               (idx >= winLeft && idx <= winRight) ? "#00FF00" : "#666");
       });
       // 绘制队列元素
       queue.forEach((idx, i) => {
           drawPixelBlock(i*20, 100, arr[idx], "#FF0000");
       });
   }
   ```

### 同类型题目推荐
1. P1886 滑动窗口（模板题）
2. P1440 求m区间内的最小值（逆向窗口）
3. P2032 扫描（二维扩展）

### 个人心得摘录
"调试时发现队列存储下标比存储值更方便处理窗口边界。曾经忘记处理前m-1元素的初始化，导致WA了3次才找到问题。"——Youngsc题解

### 算法比较可视化
| 方法        | 预处理时间 | 查询时间 | 空间   | 适用场景           |
|------------|------------|----------|--------|------------------|
| 单调队列    | O(1)       | O(N)     | O(N)   | 固定窗口最值     |
| ST表       | O(N logN)  | O(1)     | O(N logN) | 任意区间查询    |
| 线段树     | O(N)       | O(logN) | O(4N)  | 动态数据+区间查询 | 

（注：表格颜色采用复古16色调色板，使用#00FF00、#FF00FF等经典FC配色）

---
处理用时：90.79秒
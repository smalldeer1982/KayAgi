# 题目信息

# [USACO12JAN] Video Game G

## 题目描述

Bessie 在玩一款游戏，该游戏只有三个技能键 `A`，`B`，`C` 可用，但这些键可用形成 $n$ 种特定的组合技。第 $i$ 个组合技用一个字符串 $s_i$ 表示。

Bessie 会输入一个长度为 $k$ 的字符串 $t$，而一个组合技每在 $t$ 中出现一次，Bessie 就会获得一分。$s_i$ 在 $t$ 中出现一次指的是 $s_i$ 是 $t$ 从某个位置起的连续子串。如果 $s_i$ 从 $t$ 的多个位置起都是连续子串，那么算作 $s_i$ 出现了多次。

若 Bessie 输入了恰好 $k$ 个字符，则她最多能获得多少分？

## 说明/提示

#### 样例 1 解释

Bessie 如果输入 `ABACBCB`，则 `ABA` 出现了一次，`ABACB` 出现了一次，`CB` 出现了两次，共得到 $4$ 分。可以证明这是最优的输入。

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq n \leq 20$，$1 \leq k \leq 10^3$。
- $1 \leq |s_i| \leq 15$。其中 $|s_i|$ 表示字符串 $s_i$ 的长度。
- $s$ 中只含大写字母 `A`，`B`，`C`。

## 样例 #1

### 输入

```
3 7 
ABA 
CB 
ABACB 
```

### 输出

```
4 
```

# AI分析结果



## 唯一算法分类
AC自动机 + 动态规划

---

## 综合分析与结论

### 核心思路
题目要求构造长度为k的字符串，使其包含最多的组合技。通过AC自动机处理多模式串匹配，结合动态规划记录状态转移：

1. **AC自动机构建**  
   将所有组合技插入Trie树，构建fail指针链。预处理每个节点的总得分（包含其fail链上所有模式串的得分）。
   
2. **动态规划状态设计**  
   定义`dp[i][j]`表示输入i个字符后处于AC自动机节点j时的最大得分。状态转移时，枚举添加A/B/C字符后的新节点，并累加新节点的总得分。

3. **预处理优化**  
   在构建fail指针时，将每个节点的得分`val`累加其fail链上的所有得分，使转移时直接取`val`即可，无需重复跳转fail链。

### 解决难点
- **多模式串匹配**：通过AC自动机高效处理多个字符串的匹配问题。
- **得分累加**：fail链上的得分预处理使得每次状态转移的得分计算复杂度降为O(1)。
- **状态压缩**：利用AC自动机的节点作为状态，避免状态数爆炸（原状态设计可能达3^15种）。

### 可视化设计
- **动画流程**：  
  1. Canvas绘制Trie树，不同颜色表示当前活跃节点。  
  2. 动态展示字符输入时节点跳转（红色高亮当前节点）。  
  3. 显示DP表格更新过程，绿色渐变表示得分增长。  
- **复古风格**：  
  使用8位像素风格渲染Trie树，每次转移时播放NES风格音效（如得分时播放“金币声”，转移时播放“跳跃声”）。  
- **交互控制**：  
  支持暂停/步进，可调节动画速度，右侧面板实时显示当前得分和剩余字符数。

---

## 题解清单（≥4星）

1. **yybyyb（★★★★★）**  
   - **亮点**：代码简洁，fail指针预处理得分，DP状态转移清晰。  
   - **关键代码**：`t[u].p += t[t[u].fail].p`预处理总得分，转移时直接累加。

2. **lgswdn_SA（★★★★☆）**  
   - **亮点**：详细注释，预处理val值，代码可读性强。  
   - **心得**：在构建fail指针时同步计算`val`，避免重复跳转。

3. **试试事实上吗（★★★★☆）**  
   - **亮点**：状态初始化明确，代码结构规范。  
   - **关键优化**：将`is[u] += is[fail[u]]`提前计算，加速DP。

---

## 核心代码实现

### AC自动机构建与预处理
```cpp
struct Node {
    int ch[3], fail, val; // val为总得分
} trie[MAXN];
int tot = 1;

void insert(string s) {
    int u = 1;
    for (char c : s) {
        int idx = c - 'A';
        if (!trie[u].ch[idx]) 
            trie[u].ch[idx] = ++tot;
        u = trie[u].ch[idx];
    }
    trie[u].val++;
}

void build_fail() {
    queue<int> q;
    for (int i = 0; i < 3; ++i) {
        if (trie[1].ch[i]) {
            trie[trie[1].ch[i]].fail = 1;
            q.push(trie[1].ch[i]);
        } else {
            trie[1].ch[i] = 1; // 根节点的空转移指向自身
        }
    }
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = 0; i < 3; ++i) {
            int v = trie[u].ch[i];
            if (v) {
                trie[v].fail = trie[trie[u].fail].ch[i];
                trie[v].val += trie[trie[v].fail].val; // 预处理总得分
                q.push(v);
            } else {
                trie[u].ch[i] = trie[trie[u].fail].ch[i];
            }
        }
    }
}
```

### 动态规划转移
```cpp
int dp[1005][MAXN]; // dp[k][node]

memset(dp, -0x3f, sizeof(dp));
dp[0][1] = 0; // 初始状态

for (int i = 1; i <= k; ++i) {
    for (int u = 1; u <= tot; ++u) {
        if (dp[i-1][u] < 0) continue;
        for (int c = 0; c < 3; ++c) {
            int v = trie[u].ch[c];
            dp[i][v] = max(dp[i][v], dp[i-1][u] + trie[v].val);
        }
    }
}

int ans = 0;
for (int u = 1; u <= tot; ++u)
    ans = max(ans, dp[k][u]);
```

---

## 相似题目推荐
1. **P5231 [JSOI2012]玄武密码**  
   - 在AC自动机上处理模式串的最长匹配前缀。

2. **P2414 [NOI2011] 阿狸的打字机**  
   - 结合AC自动机和树状数组，处理多模式串的查询。

3. **P3966 [TJOI2013]单词**  
   - 统计各模式串在文本中的出现次数，AC自动机的经典应用。

---
处理用时：73.59秒
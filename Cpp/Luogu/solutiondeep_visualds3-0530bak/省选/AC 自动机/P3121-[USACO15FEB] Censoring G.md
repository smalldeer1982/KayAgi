# 题目信息

# [USACO15FEB] Censoring G

## 题目描述

FJ 把杂志上所有的文章摘抄了下来并把它变成了一个长度不超过 $10^5$ 的字符串 $s$。他有一个包含 $n$ 个单词的列表，列表里的 $n$ 个单词记为 $t_1 \cdots t_n$。他希望从 $s$ 中删除这些单词。

FJ 每次在 $s$ 中找到最早出现的列表中的单词（最早出现指该单词的开始位置最小），然后从 $s$ 中删除这个单词。他重复这个操作直到 $s$ 中没有列表里的单词为止。注意删除一个单词后可能会导致 $s$ 中出现另一个列表中的单词。

FJ 注意到列表中的单词不会出现一个单词是另一个单词子串的情况，这意味着每个列表中的单词在 $s$ 中出现的开始位置是互不相同的。

请帮助 FJ 完成这些操作并输出最后的 $s$。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq |s|, \sum\limits_{i = 1}^n |t_i|, n \leq 10^5$。
- 字符串均只含小写字母。
- 操作结束后 $s$ 不会被删成空串。
- 对于所有的 $i \neq j$，$t_i$ 不是 $t_j$ 的子串。

其中对于一个字符串 $x$，约定 $|x|$ 表示 $x$ 的长度。

---

#### 提示

操作过程中 $s$ 有可能某一个前缀子串被完全删除，请格外注意这一点。


## 样例 #1

### 输入

```
begintheescapexecutionatthebreakofdawn 
2 
escape 
execution 
```

### 输出

```
beginthatthebreakofdawn 
```

# AI分析结果



---

**唯一算法分类**：AC自动机（Trie图）结合栈

---

### **题解思路与核心难点**

1. **核心思路**：  
   - **双栈维护**：一个栈保存字符（结果），另一个栈保存当前在AC自动机中的节点位置。匹配到模式串时弹出对应长度的元素，恢复栈顶状态继续匹配。  
   - **AC自动机优化**：构建Trie图（优化后的AC自动机），使得状态转移无需回溯，时间复杂度严格O(n)。  

2. **解决难点**：  
   - **动态回溯**：删除子串后需快速恢复之前的匹配状态（通过栈顶记录的节点位置）。  
   - **高效多模式匹配**：AC自动机在单次扫描中同时匹配所有模式串，避免重复遍历。  

---

### **题解评分（≥4星）**

1. **Treeloveswater (5星)**  
   - **亮点**：双栈设计清晰，代码简洁，核心逻辑仅20行；Trie图优化提升效率。  
   - **代码片段**：  
     ```cpp
     void solve(char *s) {
         int now=0, len=strlen(s), top=0;
         for (int i=0; i<len; i++) {
             now = trie[now][s[i]-'a'];
             sign[++top] = now; // 记录节点
             heap[top] = i;     // 记录字符位置
             if (isend[now]) {  // 匹配成功
                 top -= isend[now]; // 弹出栈顶
                 now = top ? sign[top] : 0; // 恢复状态
             }
         }
     }
     ```

2. **KokiNiwa (4星)**  
   - **亮点**：用链表模拟删除操作，通过`pre`和`per`数组维护前后关系；记录每个位置的节点状态。  
   - **关键代码**：  
     ```cpp
     if (bo[u]) { // 匹配成功
         int pr = i;
         for (int k=1; k<=f[u]; k++) pr = per[pr];
         pre[pr] = pre[i]; // 链表删除操作
         per[pre[i]] = pr;
     }
     ```

3. **Adove (4星)**  
   - **亮点**：代码极简，仅70行；通过`dep`数组记录节点深度，直接计算弹出长度。  
   - **核心逻辑**：  
     ```cpp
     if (end[x]) { // 匹配到模式串
         top -= dep[x]; // 直接弹出
         x = pos[top];  // 恢复状态
     }
     ```

---

### **最优思路提炼**

- **栈+AC自动机**：核心在于用栈保存匹配路径，删除时直接回溯。  
- **Trie图优化**：预处理失败指针时直接修改转移边，避免运行时跳转。  
- **哈希优化技巧**：按模式串长度分组，减少无效匹配次数（见huangjinxiu题解）。  

---

### **同类型题与算法套路**

- **通用解法**：需动态维护匹配状态的字符串处理问题（如多次替换、删除）。  
- **类似题目**：  
  1. **P4824 [USACO15FEB]Censoring (Silver)**：单模式串删除（KMP+栈）。  
  2. **P5410 扩展KMP**：需预处理所有后缀的匹配情况。  
  3. **P2444 [POI2010]病毒**：AC自动机找环路。  

---

### **可视化设计**

1. **动画方案**：  
   - **栈变化**：左侧显示字符栈，右侧显示节点栈。压入字符时高亮当前节点，匹配成功时红色闪烁被删除部分。  
   - **Trie图遍历**：下方展示Trie图，当前节点用绿色标记，失败指针用虚线连接。  

2. **复古像素风格**：  
   - **8位风格栈**：字符栈用像素方块表示，删除时播放“爆炸”音效（8-bit音效库）。  
   - **自动演示模式**：按空格暂停/继续，方向键控制单步执行。  

3. **交互示例**（伪代码）：  
   ```javascript
   class Visualizer {
     constructor() {
       this.stack = new PixelStack(0x00FF00); // 绿色方块
       this.trie = new TrieGraph(0xFF0000);    // 红色节点
     }
     step() {
       const char = s[i++];
       this.stack.push(char); // 方块动画
       this.trie.moveToNextNode(char);
       if (matched) {
         this.stack.popN(len); // 爆炸动画
         playSound('explosion.wav');
       }
     }
   }
   ```

---

### **核心代码实现（Treeloveswater法1）**

```cpp
void solve(char *s) {
    int now = 0, top = 0;
    for (int i = 0; s[i]; i++) {
        now = trie[now][s[i] - 'a']; // Trie图转移
        sign[++top] = now;           // 记录节点
        heap[top] = i;               // 记录原串位置
        if (isend[now]) {            // 匹配成功
            top -= isend[now];       // 弹出栈顶
            now = top ? sign[top] : 0; // 恢复状态
        }
    }
    // 输出栈中剩余字符
    for (int i = 1; i <= top; i++) 
        putchar(s[heap[i]]);
}
```

---

**总结**：AC自动机+栈是本题的最优解，兼顾效率与代码简洁性。哈希方法在特定优化下可作替代，但AC自动机更适用于通用场景。可视化设计可增强对动态回溯过程的理解。

---
处理用时：69.60秒
# 题目信息

# [SDOI2014] 数数

## 题目描述

我们称一个正整数 $x$ 是幸运数，当且仅当它的十进制表示中不包含数字串集合 $s$ 中任意一个元素作为其子串。例如当 $s = \{22, 333, 0233\}$ 时，$233$ 是幸运数，$2333$、$20233$、$3223$ 不是幸运数。给定 $n$ 和 $s$，计算不大于 $n$ 的幸运数个数。

答案对 $10^9 + 7$ 取模。

## 说明/提示

#### 样例 1 解释

除了 $3, 13, 2, 12, 20, 14$ 以外，不大于 $20$ 的整数都是幸运数字。

#### 数据规模与约定

对于全部的测试点，保证：

$1 \leq n < 10^{1201}$，$1 \leq m \leq 100$，$1 \leq \sum_{i = 1}^m |s_i| \leq 1500$，$\min_{i = 1}^m |s_i| \geq 1$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。$n$ 没有前导 $0$，但是 $s_i$ 可能有前导 $0$。

## 样例 #1

### 输入

```
20
3
2
3
14```

### 输出

```
14```

# AI分析结果



### 算法分类
**AC自动机 + 数位DP**

---

### 综合分析与结论
**核心思路**：  
1. **AC自动机构建**：将所有禁止串插入Trie树，建立fail指针并标记危险节点（包含任意禁止子串的节点）
2. **数位DP设计**：处理数位限制时，通过状态表示（是否紧贴上界、是否有前导零）约束转移过程
3. **危险节点剪枝**：在DP过程中遇到危险节点时停止转移，避免生成包含禁止子串的数

**核心难点**：  
- **前导零处理**：允许中间位出现0，但整个数不能以0开头（需特殊标记前导零状态）
- **紧贴上界处理**：高位选择等于原数时，后续位的选择范围受限（需分情况讨论）
- **危险节点标记**：需在fail树上下放标记，确保通过fail指针能继承祖先的危险状态

**可视化设计思路**：  
1. **AC自动机展示**：  
   - 树形结构动态绘制，危险节点用红色高亮  
   - 当前选择的数位路径用黄色箭头跟踪转移过程  
2. **数位DP状态跟踪**：  
   - 每个数位选择后更新状态栏（剩余位数/是否紧贴/前导零）  
   - 动态显示当前AC自动机节点和危险状态检测结果  
3. **复古像素风格**：  
   - 使用16色NES调色板（深蓝背景/浅灰节点/红黄警示色）  
   - 每个数位选择时播放8位音效（不同音高对应不同数字）  
   - 发现危险路径时触发短促警报音并闪烁节点  

---

### 题解评分（≥4星）
1. **George1123（4.5⭐）**  
   - **亮点**：三维状态清晰区分限制状态，滚动数组优化空间  
   - **代码**：通过位运算实现滚动数组，前导零处理逻辑严谨  
2. **JK_LOVER（4.2⭐）**  
   - **亮点**：记忆化搜索实现简洁，状态参数完备  
   - **心得**："AC自动机上end标记需要沿fail树传播"的调试经验  
3. **wcyQwQ（4.0⭐）**  
   - **亮点**：代码结构清晰易读，前导零与危险检测分离处理  
   - **技巧**：使用`!val[ch[j][c]]`快速判断安全路径  

---

### 核心代码实现
**AC自动机构建**（危险标记传播）：
```cpp
void build_fail() {
    queue<int> q;
    for(int i=0; i<10; i++) 
        if(ch[0][i]) q.push(ch[0][i]);
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int i=0; i<10; i++) {
            int v = ch[u][i];
            if(v) {
                fail[v] = ch[fail[u]][i];
                danger[v] |= danger[fail[v]]; // 危险标记传播
                q.push(v);
            } else {
                ch[u][i] = ch[fail[u]][i];
            }
        }
    }
}
```

**数位DP核心转移**：
```cpp
int dfs(int pos, int node, bool limit, bool lead) {
    if(danger[node]) return 0;
    if(pos == n) return !lead; // 排除全零情况
    if(!limit && !lead && dp[pos][node] != -1) 
        return dp[pos][node];
    
    int res = 0, up = limit ? num[pos] : 9;
    for(int d=0; d<=up; d++) {
        bool new_lead = lead && (d==0);
        int next_node = new_lead ? 0 : ch[node][d];
        bool new_limit = limit && (d == up);
        
        res = (res + dfs(pos+1, next_node, new_limit, new_lead)) % MOD;
    }
    
    if(!limit && !lead) 
        dp[pos][node] = res;
    return res;
}
```

---

### 相似题目推荐
1. **P4052 [JSOI2007]文本生成器**  
   （AC自动机+计数DP，求至少包含一个模式串的方案数）
2. **P2292 [HNOI2004] L语言**  
   （AC自动机变形，处理最长可匹配前缀）
3. **P2414 [NOI2011] 阿狸的打字机**  
   （AC自动机与fail树综合应用）

---

### 可视化算法演示
**动画流程**：  
1. **初始化阶段**：  
   - 左侧显示AC自动机结构，危险节点闪烁红光  
   - 右侧数位面板显示目标数`n`的各个数位  
2. **数位选择阶段**：  
   - 用户点击数字按钮或使用方向键选择  
   - 实时显示当前路径在AC自动机上的移动轨迹  
3. **危险检测阶段**：  
   - 当路径进入危险节点时触发警报，当前数位变为红色  
   - 自动回退到上一个安全状态并禁用危险数字  
4. **完成提示**：  
   - 成功构造安全数时播放胜利音效，显示最终路径  
   - 失败时显示首个触发的禁止模式串  

**交互设计**：  
- **速度调节**：滑块控制动画速度（0.5x~4x）  
- **单步模式**：空格键单步执行，显示状态转移细节  
- **危险追踪**：右键点击节点查看其fail链上的危险传播路径  

---

### 核心优化技巧
**滚动数组优化**：  
```cpp
for(int i=2; i<=nlen; i++) {
    memset(f[i&1], 0, sizeof(f[i&1])); // 滚动清空
    for(int j=1; j<=9; j++) // 处理新前导零
        if(!danger[ch[1][j]]) 
            f[i&1][ch[1][j]][0] = 1;
    
    for(int u=1; u<=cnt; u++) {
        if(danger[u]) continue;
        for(int d=0; d<=9; d++) {
            int v = ch[u][d];
            if(!danger[v]) {
                f[i&1][v][0] = (f[i&1][v][0] + f[(i-1)&1][u][0]) % MOD;
            }
        }
    }
}
```

---

**通过将AC自动机与数位DP结合，配合状态压缩和危险标记传播，可在O(L·M)复杂度下高效解决此类禁止子串计数问题，其中L为目标数长度，M为AC自动机节点数**

---
处理用时：80.87秒
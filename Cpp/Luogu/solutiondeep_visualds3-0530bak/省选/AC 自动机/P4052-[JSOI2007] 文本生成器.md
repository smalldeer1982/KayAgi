# 题目信息

# [JSOI2007] 文本生成器

## 题目描述

JSOI 交给队员 ZYX 一个任务，编制一个称之为“文本生成器”的电脑软件：该软件的使用者是一些低幼人群，他们现在使用的是 GW 文本生成器 v6 版。

该软件可以随机生成一些文章——总是生成一篇长度固定且完全随机的文章。 也就是说，生成的文章中每个字符都是完全随机的。如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章 $s$ 包含单词 $t$，当且仅当单词 $t$ 是文章 $s$ 的子串）。但是，即使按照这样的标准，使用者现在使用的 GW 文本生成器 v6 版所生成的文章也是几乎完全不可读的。ZYX 需要指出 GW 文本生成器 v6 生成的所有文本中，可读文本的数量，以便能够成功获得 v7 更新版。你能帮助他吗？

答案对 $10^4 + 7$ 取模。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq n \leq 60$，$1 \leq m \leq 100$。
- $1 \leq |s_i| \leq 100$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。
- $s_i$ 中只含大写英文字母。

## 样例 #1

### 输入

```
2 2
A
B
```

### 输出

```
100```

# AI分析结果



# 算法分类
**AC自动机 + 动态规划**

---

## 题解思路与核心难点分析

### 核心算法流程
1. **容斥原理**：总方案数 $26^m$ 减去不包含任何模式串的方案数。
2. **AC自动机构建**：将所有模式串插入Trie树，构建fail指针并标记危险节点（包含模式串或其后缀为模式串的节点）。
3. **动态规划**：定义状态 $f[i][j]$ 表示长度为 $i$ 的字符串在AC自动机上走到节点 $j$ 的合法方案数，转移时避开危险节点。

### 解决难点
1. **危险节点标记**：通过fail指针传递标记，确保若节点 $u$ 的fail链上有危险节点，则 $u$ 也是危险节点。
2. **高效状态转移**：预处理每个节点的合法转移路径，避免每次转移时遍历fail链。

---

## 题解评分（≥4星）

### 1. Refun（4.5星）
- **亮点**：首次提出fail链标记传递的预处理方法，大幅优化合法性判断。
- **关键代码**：
  ```cpp
  void build() {
    // ... 
    war[ch[u][i]] |= war[fail[ch[u][i]]]; // 危险标记传递
  }
  ```

### 2. AThousandSuns（4.5星）
- **亮点**：详细解释AC自动机与DP的结合逻辑，强调合法性预处理的重要性。
- **核心代码**：
  ```cpp
  for (int j = 0; j <= cnt; j++)
    if (!t.mk[t.ch[j][c]]) // 直接判断合法性
      dp[i+1][t.ch[j][c]] += dp[i][j];
  ```

### 3. George1123（4星）
- **亮点**：提供完整的AC自动机模板代码，适合新手理解整体框架。
- **关键步骤**：
  ```cpp
  void build() {
    // 构建fail指针时同步更新end标记
    mk[ch[x][c]] |= mk[fa[ch[x][c]]];
  }
  ```

---

## 最优思路提炼

### 核心技巧
1. **fail链标记传递**：在构建AC自动机时，通过 `war[u] |= war[fail[u]]` 预处理所有危险节点。
2. **动态规划优化**：合法转移路径预处理，避免每次转移时重复检查fail链。

---

## 同类型题目推荐
1. [P3311 数数](https://www.luogu.com.cn/problem/P3311)（AC自动机 + 数位DP）
2. [P2414 阿狸的打字机](https://www.luogu.com.cn/problem/P2414)（AC自动机 + 树状数组）
3. [P2444 病毒](https://www.luogu.com.cn/problem/P2444)（AC自动机找安全循环路径）

---

## 可视化设计要点

### 动画演示
1. **AC自动机构建**：
   - **颜色标记**：红色节点为危险节点，绿色为安全节点。
   - **步进控制**：展示插入模式串、构建fail指针、标记传递的过程。
   
2. **动态规划转移**：
   - **高亮路径**：当前处理的节点用黄色闪烁，合法转移边用蓝色标记。
   - **实时更新**：显示 `f[i][j]` 的数值变化。

### 复古像素风格
- **Canvas绘制**：用16x16像素网格表示Trie节点，红色方块表示危险节点。
- **音效设计**：
  - **合法转移**：播放短促的“滴”声。
  - **危险节点**：播放低沉的“哔”声。

---

## 代码实现（核心逻辑）

```cpp
// AC自动机构建
void build() {
    queue<int> q;
    for (int i = 0; i < 26; ++i)
        if (trie[0][i]) q.push(trie[0][i]);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = 0; i < 26; ++i) {
            int &v = trie[u][i];
            if (v) {
                fail[v] = trie[fail[u]][i];
                danger[v] |= danger[fail[v]]; // 关键标记传递
                q.push(v);
            } else v = trie[fail[u]][i];
        }
    }
}

// 动态规划转移
int dp[105][6005] = {1}; // dp[0][0] = 1
for (int i = 0; i < m; ++i) {
    for (int j = 0; j <= cnt; ++j) {
        if (!dp[i][j] || danger[j]) continue;
        for (int c = 0; c < 26; ++c) {
            int k = trie[j][c];
            if (!danger[k]) 
                dp[i+1][k] = (dp[i+1][k] + dp[i][j]) % MOD;
        }
    }
}
```

---
处理用时：68.87秒
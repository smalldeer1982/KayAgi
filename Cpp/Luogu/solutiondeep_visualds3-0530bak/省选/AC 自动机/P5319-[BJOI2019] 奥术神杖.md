# 题目信息

# [BJOI2019] 奥术神杖

## 题目描述

Bezorath 大陆抵抗地灾军团入侵的战争进入了僵持的阶段，世世代代生活在 Bezorath 这片大陆的精灵们开始寻找远古时代诸神遗留的神器，试图借助神器的神秘力量帮助她们战胜地灾军团。

在付出了惨痛的代价后，精灵们从步步凶险的远古战场取回了一件保存尚完好的神杖。但在经历过那场所有史书都视为禁忌的“诸神黄昏之战”后，神杖上镶嵌的奥术宝石已经残缺，神力也几乎消耗殆尽。精灵高层在至高会议中决定以举国之力收集残存至今的奥术宝石，并重金悬赏天下能工巧匠修复这件神杖。

你作为神术一脉第五百零一位传人，接受了这个艰巨而神圣的使命。
神杖上从左到右镶嵌了 $n$ 颗奥术宝石，奥术宝石一共有 $10$ 种，用数字 "`0123456789`" 表示。有些位置的宝石已经残缺，用 "`.`" 表示，你需要用完好的奥术宝石填补每一处残缺的部分（每种奥术宝石个数不限，且不能够更换未残缺的宝石）。古老的魔法书上记载了 $m$ 种咒语 $(S_i,V_i)$ ，其中 $S_i$ 是一个非空数字串，$V_i$ 是这种组合能够激发的神力。

神杖的初始神力值 $Magic = 1$，每当神杖中出现了连续一段宝石与 $S_i$ 相等时，神力值 $Magic$ 就会乘以 $V_i$。但神杖如果包含了太多咒语就不再纯净导致神力降低：设 $c$ 为神杖包含的咒语个数（若咒语类别相同但出现位置不同视为多次），神杖最终的神力值为 $ \sqrt[c]{Magic}$。（若 $c = 0$ 则神杖最终神力值为 $1$ ）

例如有两种咒语 $(01,3)$ 、$(10,4)$ ，那么神杖 “`0101`” 的神力值为 $\sqrt[3]{ 3 \times 4 \times 3}$

你需要使修复好的神杖的最终的神力值最大，输出任何一个解即可。

## 说明/提示

样例 1 ：法杖最终神力值为 $2$ 。

样例 2 ：法杖最终神力值为 $\sqrt[3]{2 \times 3 \times 4}$

设 $s = \sum_{i=1}^{m} |S_i|$ ，即所有咒语的串长之和。
![](https://cdn.luogu.com.cn/upload/pic/57052.png)

## 样例 #1

### 输入

```
4 3
....
1 2
2 2
3 1```

### 输出

```
2019```

## 样例 #2

### 输入

```
5 4
..0..
0 2
00 2
01 4
10 3```

### 输出

```
11012```

## 样例 #3

### 输入

```
18 6
...2.1.0.1..1.0..1
011 6
111 4
010 12
121 7
101 5
10 3```

### 输出

```
121211203112120121```

# AI分析结果



**算法分类**  
AC自动机 + 动态规划 + 0/1分数规划

---

### **题解思路与算法要点**

#### **核心思路**
1. **几何平均转对数**  
   将几何平均数公式 $\sqrt[c]{\prod V_i}$ 取自然对数，转化为算术平均 $\frac{1}{c}\sum \ln V_i$，问题转化为最大化该值。

2. **0/1分数规划**  
   二分答案 $mid$，验证是否存在方案满足 $\sum (\ln V_i - mid) > 0$。通过调整权值为 $(\ln V_i - mid)$，转化为判断最大权值和是否为正。

3. **AC自动机预处理**  
   构建所有咒语的AC自动机，预处理每个节点的累积权值（包括fail链传递的权值），用于动态规划中的快速状态转移。

4. **动态规划**  
   设 $dp[i][j]$ 表示处理到母串第 $i$ 个字符时，位于AC自动机节点 $j$ 的最大权值和。状态转移分两种：
   - 当前字符固定：直接转移到对应子节点。
   - 当前字符为通配符：遍历所有可能的数字（0-9）转移。

#### **解决难点**
- **高效匹配多模式串**：通过AC自动机将模式串匹配复杂度优化至线性。
- **权值动态调整**：每次二分时调整节点权值为 $\ln V_i - mid$，避免重复建图。
- **路径回溯**：记录每个状态的前驱节点和选择字符，用于构造最终解。

---

### **题解评分 (≥4星)**

| 作者 | 评分 | 亮点 |
|------|------|------|
| 小粉兔 | ⭐⭐⭐⭐ | 代码简洁，路径记录清晰，预处理fail链权值 |
| 81179332_ | ⭐⭐⭐⭐ | 结构清晰，转移逻辑明确，适合快速理解 |
| Oxide | ⭐⭐⭐⭐ | 详细推导过程，对0/1分数规划解释透彻 |

---

### **最优思路与技巧提炼**

1. **对数转换与二分策略**  
   - 关键公式：$\ln \text{Ans} = \frac{1}{c}\sum \ln V_i$  
   - 二分验证条件：$\sum (\ln V_i - mid) > 0$

2. **AC自动机权值传递**  
   ```cpp
   void BuildAC() {
       // 构建fail指针并传递权值
       for (int i=2; i<=r; ++i) {
           sum[que[i]] += sum[fail[que[i]]];
           val[que[i]] += val[fail[que[i]]];
       }
   }
   ```

3. **动态规划状态转移**  
   ```cpp
   for (int i=0; i<N; ++i) {
       for (int j=0; j<=cnt; ++j) {
           if (当前字符为通配符) {
               for (int k=0; k<10; ++k) {
                   int next_node = ch[j][k];
                   dp[i+1][next_node] = max(dp[i+1][next_node], dp[i][j] + val[next_node]);
               }
           } else {
               int k = 固定字符;
               int next_node = ch[j][k];
               dp[i+1][next_node] = max(...);
           }
       }
   }
   ```

---

### **同类型题与算法套路**

- **AC自动机+动态规划**：适用于多模式串匹配与计数问题（如统计单词出现次数）。
- **0/1分数规划**：常见于平均值最大化问题（如最优比率生成树）。

---

### **推荐相似题目**

1. [P3796 【模板】AC自动机（加强版）](https://www.luogu.com.cn/problem/P3796)  
2. [P3193 [HNOI2008]GT考试](https://www.luogu.com.cn/problem/P3193)  
3. [P3287 [SCOI2014]方伯伯的玉米田](https://www.luogu.com.cn/problem/P3287)  

---

### **可视化与算法演示**

**动画方案设计**：
1. **AC自动机构建**  
   - 展示Trie树的构建过程，高亮当前插入的字符路径。
   - 用红色箭头动态绘制fail指针的跳转。

2. **动态规划过程**  
   - 母串每个位置以网格形式展示，AC自动机节点横向排列。
   - 当前处理的字符位置高亮为黄色。
   - 状态转移时，用绿色线条标记有效转移路径，权值和实时更新。

3. **二分验证**  
   - 可视化权值调整（$\ln V_i - mid$），用柱状图对比不同mid对应的最大权值和。

**复古像素风格示例**（伪代码）：
```javascript
// Canvas绘制示例（简略）
ctx.fillStyle = '#8B00FF'; // 紫色背景
ctx.fillRect(0, 0, canvas.width, canvas.height);
// 绘制AC节点
nodes.forEach(node => {
    ctx.fillStyle = node.active ? '#FFD700' : '#FFF'; // 金色高亮激活节点
    ctx.fillRect(node.x, node.y, 16, 16);
});
```

---

### **代码实现（核心片段）**

```cpp
#include <cstdio>
#include <cmath>
#include <queue>
using namespace std;
const int MN = 1505;
int n, m, ch[MN][10], fail[MN], cnt;
double sum[MN], val[MN], dp[MN][MN];
char T[MN], ans[MN];

void insert(char *s, double v) {
    int u = 0;
    for (; *s; ++s) {
        int c = *s - '0';
        if (!ch[u][c]) ch[u][c] = ++cnt;
        u = ch[u][c];
    }
    sum[u]++;
    val[u] += v;
}

void buildAC() {
    queue<int> q;
    for (int i=0; i<10; ++i) 
        if (ch[0][i]) q.push(ch[0][i]);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i=0; i<10; ++i) {
            int &v = ch[u][i];
            if (v) fail[v] = ch[fail[u]][i], q.push(v);
            else v = ch[fail[u]][i];
        }
        sum[u] += sum[fail[u]];
        val[u] += val[fail[u]];
    }
}

bool check(double mid) {
    // 调整权值并DP
    for (int i=0; i<=cnt; ++i) val[i] -= mid * sum[i];
    // ... DP逻辑 ...
    return max_val > 0;
}

int main() {
    // 初始化与二分
    double l = 0, r = log(1e9);
    while (r - l > 1e-6) {
        double mid = (l + r) / 2;
        if (check(mid)) l = mid;
        else r = mid;
    }
    // 输出构造的字符串
    puts(ans);
}
```

---
处理用时：83.70秒
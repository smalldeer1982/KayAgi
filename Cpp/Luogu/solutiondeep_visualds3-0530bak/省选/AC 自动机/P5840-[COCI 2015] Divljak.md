# 题目信息

# [COCI 2015] Divljak

## 题目描述

Alice 有 $n$ 个字符串 ${S}_1, {S}_2, \ldots, {S}_n$，Bob 有一个字符串集合 ${T}$，一开始集合是空的。

接下来会发生 $q$ 个操作，操作有两种形式：

1. `1 P`：Bob 往自己的集合里添加了一个字符串 ${P}$。
2. `2 x`：Alice 询问 Bob，集合 ${T}$ 中有多少个字符串包含串 ${S}_x$（我们称串 ${A}$ 包含串 ${B}$，当且仅当 ${B}$ 是 ${A}$ 的子串）。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq n,q \leq 10^5$，字符串由小写字母构成，$S$ 和 $P$ 的总长分别 $\le 2 \times 10^6$。


## 样例 #1

### 输入

```
3
a
bc
abc
5
1 abca
2 1
1 bca
2 2
2 3
```

### 输出

```
1
2
1
```

# AI分析结果



# 唯一算法分类  
AC自动机、fail树、树上差分  

---

# 题解思路与核心难点  

**核心思路**：  
1. **AC自动机构建**：对Alice的n个字符串构建AC自动机，建立fail指针关系  
2. **fail树构建**：将fail指针反向构建成树形结构（fail树）  
3. **路径并处理**：对于每个新添加的字符串P，在AC自动机上匹配得到所有经过的节点，这些节点在fail树上的路径并集即为所有包含的S_x  
4. **树上差分优化**：通过按dfs序排序后，利用LCA进行差分标记，将路径加转化为单点加  
5. **子树和查询**：使用树状数组维护dfs序上的区间和  

**解决难点**：  
1. **路径并的高效处理**：通过排序+差分避免暴力合并路径  
2. **动态维护子树和**：利用树状数组在dfs序上快速查询  
3. **LCA的快速计算**：通过树链剖分或倍增法快速求LCA  

---

# 题解评分（≥4星）  

1. **Calculatelove（★★★★★）**  
   - 清晰展示fail树构建与差分过程  
   - 代码结构清晰，使用树状数组高效维护  
   - 时间复杂度分析准确（O(L log L)）  

2. **tzc_wk（★★★★☆）**  
   - 完整推导AC自动机与fail树的关系  
   - 使用树链剖分维护LCA计算  
   - 代码注释详细，变量命名规范  

3. **Infiltrator（★★★★）**  
   - 详细解释fail树与子串包含关系  
   - 采用树状数组+dfs序的经典实现  
   - 包含调试经验分享（_end变量问题）  

---

# 最优思路提炼  

**关键技巧**：  
1. **Fail树的链并处理**：  
   - 将字符串P的匹配路径按dfs序排序  
   - 相邻节点的LCA处打标记消除重复计数  

2. **树状数组妙用**：  
   ```c++
   // 树状数组维护dfs序区间和
   void add(int x, int val) {
       for(; x <= cT; x += x&-x) c[x] += val;
   }
   int query(int x) {
       int res = 0;
       for(; x; x -= x&-x) res += c[x];
       return res;
   }
   ```

3. **路径差分公式**：  
   - 对排序后的节点序列[p1,p2,...,pn]  
   - 操作：Σ add(pi) - Σ add(lca(pi,pi+1))  

---

# 同类题目推荐  

1. **P5357 【模板】AC自动机（二次加强版）**  
   - 统计模式串在文本中的出现次数  

2. **P3966 [TJOI2013]单词**  
   - 统计多个模式串在长文本中的出现次数  

3. **P2414 [NOI2011] 阿狸的打字机**  
   - 结合fail树与树状数组处理多模式匹配  

---

# 可视化设计  

**核心动画流程**：  
1. **AC自动机构建阶段**：  
   - 用绿色方块表示新建节点，红色箭头表示fail指针  
   - 逐步显示每个字符的插入过程  

2. **字符串匹配阶段**：  
   - 蓝色高亮当前匹配路径  
   - 在fail树上用黄色标记经过的节点链  

3. **差分标记过程**：  
   - 排序后的节点序列显示为横向排列的圆点  
   - 相邻节点间显示LCA节点并用红色叉号标记减操作  

**复古像素风格实现**：  
```javascript
// 伪代码示例
class ACNode {
    constructor(x, y) {
        this.x = x;    // 像素坐标
        this.y = y;
        this.color = 0x00FF00; // 默认绿色
    }
    
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x-8, this.y-8, 16, 16); // 16x16像素方块
    }
}

// 播放匹配音效
function playMatchSound() {
    const osc = new OscillatorNode(audioCtx, {
        type: 'square',
        frequency: 440 + Math.random()*100
    });
    osc.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.1);
}
```

---

# 个人心得摘录  

1. **皎月半洒花**：  
   > "排序后按dfs序处理是关键，否则可能出现子树未被标记的情况。调试时反复验证了dfs序的正确性"  

2. **QwQ蒟蒻wjr**：  
   > "在差分时忘记处理最后一个节点的LCA，导致结果多加了1，通过小数据测试发现错误"  

3. **cryozwq**：  
   > "线段树合并的空间优化是难点，通过重复利用废弃节点节省了40%的内存"  

---

# 核心代码片段  

**树上差分关键实现**：  
```c++
void solve1() { // 处理新插入字符串
    int u=0, tp=0;
    for(int i=1; i<=len; i++) {
        u = tr[u][s[i]-'a'];
        seq[++tp] = u;
    }
    sort(seq+1, seq+tp+1, cmp); // 按dfs序排序
    tp = unique(seq+1, seq+tp+1) - seq -1;
    
    for(int i=1; i<=tp; i++) 
        add(dfn[seq[i]], 1);    // 正标记
    for(int i=1; i<tp; i++)
        add(dfn[lca(seq[i],seq[i+1])], -1); // 差分消除重复
}
```

**子树和查询**：  
```c++
case 2: { // 查询操作
    scanf("%d", &x);
    int p = End[x];
    printf("%d\n", query(edt[p]) - query(bgn[p]-1));
}
```

---

通过结合AC自动机与树形结构的特性，配合巧妙的差分技巧，该算法在O(L log L)时间复杂度内高效解决了大规模动态子串包含统计问题。可视化设计中融入游戏化元素，使抽象的算法过程更直观易懂。

---
处理用时：76.34秒
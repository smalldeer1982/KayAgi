# 题目信息

# [ZJOI2018] 胖

## 题目背景

Cedyks 是九条可怜的好朋友（可能这场比赛公开以后就不是了），也是这题的主人公。

## 题目描述

Cedyks 是一个富有的男孩子。他住在著名的 The Place（宫殿）中。

Cedyks 是一个努力的男孩子。他每天都做着不一样的题来锻炼他的 The Salt（灵魂）。

这天，他打算在他的宫殿外围修筑一道城墙，城墙上有 $n$ 座瞭望塔。你可以把城墙看做一条线段，瞭望塔是线段上的 $n$ 个点，其中 $1$ 和 $n$ 分别为城墙的两个端点。其中第 $i$ 座瞭望塔和第 $i + 1$ 座瞭望塔的距离为 $w_i$，他们之间的道路是双向的。

城墙很快就修建好了，现在 Cedyks 开始计划修筑他的宫殿到城墙的道路。因为这题的题目名称，Cedyks 打算用他的宫殿到每一个瞭望塔的最短道路之和来衡量一个修建计划。

现在 Cedyks 手上有 $m$ 个设计方案，第 $k$ 个设计方案会在宫殿和瞭望塔之间修建 $T_k$ 条双向道路，第 $i$ 条道路连接着瞭望塔 $a_i$，长度为 $l_i$。

计算到每一个瞭望塔的最短路之和是一个繁重的工程，本来 Cedyks 想用广为流传的 SPFA 算法来求解，但是因为他的 butter（缓冲区）实在是太小了，他只能转而用原始的贝尔福特曼算法来计算，算法的流程大概如下：

1. 定义宫殿是 $0$ 号点，第 $i$ 个瞭望塔是 $i$ 号点，双向边 $(u_i, v_i, l_i)$ 为一条连接 $u_i$ 和 $v_i$ 的双向道路。令 $d$ 为距离数组，最开始 $d_0 = 0, d_i = 10^{18}(i ∈ [1, n])$。
2. 令辅助数组 $c = d$。依次对于每一条边 $(u_i, v_i,w_i)$ 进行增广，$c_{u_i} = \min(c_{u_i} , d_{v_i} + w_i)$，$c_{v_i} = \min(c_{v_i} , d_{u_i} + w_i)$。
3. 令 $t$ 为 $c$ 和 $d$ 中不一样的位置个数，即令 $S = \{i|c_i≠d_i\}$，则 $t = |S|$。若 $t = 0$，说明 $d$ 就是最终的最短路，算法结束。否则令 $d = c$，回到第二步。

因为需要计算的设计方案实在是太多了，所以 Cedyks 雇佣了一些人来帮他进行计算。为了避免这些人用捏造出来的数据偷懒，他定义一个设计方案的校验值为在这个方案上运行贝尔福特曼算法每一次进入第三步 $t$ 的和。他会让好几个雇佣来的人计算同样的设计方案，并比对每一个人给出的校验值。

你是 Cedyks 雇佣来的苦力之一，聪明的你发现在这个情形下计算最短路的长度的和是一件非常简单的事情。但是寄人篱下不得不低头，你不得不再计算出每一个方案的校验值来交差。

## 说明/提示

### 样例解释

对于第一个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,10^{18},2,10^{18},10^{18},10^{18}] \rightarrow$ $[0,4,2,5,10^{18},10^{18}] \rightarrow [0,4,2,5,6,10^{18}] \rightarrow [0,4,2,5,6,10]$。

因此校验值为 $1+2+1+1=5$。

对于第二个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,1,10^{18},10^{18},10,10^{18}] \rightarrow$ $[0,1,3,11,10,14] \rightarrow [0,1,3,6,10,14] \rightarrow [0,1,3,6,7,14] \rightarrow [0,1,3,6,7,11]$。

因此校验值为 $2+3+1+1+1=8$。

对于第三个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,1,10^{18},1,10^{18},1] \rightarrow [0,1,3,1,2,1]$。

因此校验值为 $3+1+1=5$。

对于第四个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,10,100,10^{18},10^{18},1] \rightarrow$ $[0,10,12,103,5,1] \rightarrow [0,10,12,6,5,1] \rightarrow [0,10,9,5,1]$。

因此校验值为 $3+3+1+1=8$。

对于第五个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,1,1,1,1,1]$

因此校验值为 $5$。

### 数据范围

测试点|$n$|$m$|$K$|其他约定
-|-|-|-|-
1,2|$\le 1000$|$\le 1000$|$\le 100$|无
3,4|$\le 2 \times 10^5$|$\le 2 \times 10^5$|$\le 100$|无
5,6|$\le 2 \times 10^5$|$\le 2 \times 10^5$|$\le 2 \times 10^5$|$1 \le w_i,l_i \le 50$
7,8,9,10|$\le 2 \times 10^5$|$\le 2 \times 10^5$|$\le 2 \times 10^5$|无


对于 $100\%$ 的数据，保证每个设计方案 $a_i$ 两两不同且 $1\le a_i\le n$。  
对于 $100\%$ 的数据，保证 $1\le w_i,l_i\le 10^9,1\le\sum K\le 2\times 10^5$。

感谢 @Xeonacid 提供题面

## 样例 #1

### 输入

```
5 5
2 3 1 4
1 2 2
2 1 1 4 10
3 1 1 3 1 5 1
3 1 10 2 100 5 1
5 1 1 2 1 3 1 4 1 5 1```

### 输出

```
5
8
5
8
5```

# AI分析结果



## 算法分类
二分答案、ST表、区间查询

---

## 题解思路与解决难点

### 核心思路
每个新增的边（0号点与瞭望塔a_i之间的道路）会更新一段连续区间。通过二分确定每个边的更新区间左右端点，利用ST表预处理区间极值快速判断是否存在更优路径。

### 关键步骤
1. **预处理前缀和**：计算各瞭望塔到起点的距离dis[i]（城墙的累积长度）
2. **离散化处理**：将新增边的端点按位置排序，便于建立ST表
3. **二分左右端点**：
   - **左端点**：检查左侧是否存在更优路径（l_i - dis[a_i] + dis[x]）
   - **右端点**：检查右侧是否存在更优路径（l_i + dis[a_i] - dis[x]）
4. **区间极值查询**：用两个ST表分别维护 `l_i - dis[a_i]` 和 `l_i + dis[a_i]` 的区间最小值
5. **去重处理**：相同距离时优先处理编号较小的端点

### 难点解析
- **连续区间证明**：基于Bellman-Ford的松弛特性，新增边的影响范围是连续的
- **极值查询优化**：ST表将区间查询复杂度从O(n)降为O(1)，支持快速二分判断
- **边界条件处理**：如相同距离时的端点优先级、离散化后的区间映射

---

## 题解评分（≥4星）

1. **Ameyax（⭐⭐⭐⭐⭐）**
   - 亮点：离散化处理ST表，手写二分优化常数，完整处理边界条件
2. **Labelray（⭐⭐⭐⭐）**
   - 亮点：分左右判断函数模块化，ST表初始化逻辑清晰
3. **james1BadCreeper（⭐⭐⭐⭐）**
   - 亮点：代码简洁，使用标准库函数实现快速离散化

---

## 最优思路提炼

### 关键技巧
- **二分+ST表**：通过二分确定区间边界，ST表加速极值查询
- **双维度预处理**：维护 `l_i - dis[a_i]` 和 `l_i + dis[a_i`] 两个方向的最优值
- **离散化映射**：将端点位置映射到排序后的索引，减少ST表空间

### 代码片段（Labelray核心逻辑）
```cpp
bool check1(int p, int x) { // 左端点判断
    ll qwq1 = ST::query1(2*x-p+1, x) + dis[x];
    ll qwq2 = ST::query2(x, p-1) - dis[x];
    return qwq1 > now && qwq2 > now; 
}

int solve1(int p) { // 二分左端点
    int l=1, r=p, ans=p;
    while(l <= r) {
        int mid = (l+r)>>1;
        if(check1(p, mid)) r=mid-1, ans=mid;
        else l=mid+1;
    }
    return ans;
}
```

---

## 相似题目推荐
1. **P1083 借教室**（二分+前缀和）
2. **P2216 理想的正方形**（二维RMQ）
3. **P1904 天际线**（区间覆盖极值）

---

## 可视化设计

### 动画方案
1. **像素风格渲染**：用16色像素块表示瞭望塔，红色表示当前处理的新增边
2. **动态区间扩展**：绿色波纹动画展示二分过程中检查的区间范围
3. **极值对比高亮**：当检测到更优路径时，对应端点闪烁黄色

### 交互功能
- **步进控制**：空格键单步执行二分过程
- **音效反馈**：播放8-bit音效标记关键事件（如找到端点、发现更优路径）

### 复古效果
```javascript
// 伪代码：像素动画核心逻辑
function drawStep(mid, L, R) {
    ctx.fillStyle = "#FF0000"; // 红色表示当前mid
    ctx.fillRect(mid*10, 0, 10, 10); 
    
    ctx.strokeStyle = "#00FF00"; // 绿色表示检查区间
    ctx.strokeRect((2*mid-R)*10, 0, (R-mid)*20, 10);
}
```

---

## 总结
通过二分确定每个新增边的连续影响区间，结合ST表高效查询极值，将O(nm)复杂度优化至O(n log²n)，是处理一维松弛问题的经典模式。可视化可重点展示区间扩展与极值对比过程，帮助理解核心优化思想。

---
处理用时：93.09秒
# 题目信息

# 「ACOI2020」惊吓路径

## 题目背景

![T6](https://s2.ax1x.com/2020/01/12/lopZpq.png)

3 年 E 班的同学们赢得了去南方的冲绳小岛的机会，在渚打败了鹰冈之后，他们受杀老师的邀请参加“试胆大会”。

试胆大会在一个黑漆漆的洞窟里面进行。赤羽 業（Akabane Karma）现在和奧田 愛美站在洞窟的门口。突然，業想到了一个事情。。。

## 题目描述

杀老师告诉过他们，洞窟可以近似地看成 $n$ 个点的外向树，因为地形原因，所以一个点到另一个点的边是有方向的，且边的方向都是同向的。这棵树的树根为入度为 $0$ 的点。每个点都有一个惊吓值，给出每个点的惊吓值 $a_i$。

杀老师告诉他们，这个洞穴有很多惊吓路径。如果两个节点 $u,v$ 构成的路径是一条惊吓路径的话，满足以下条件：

- $v$ 一定在 $u$ 的子树中。

- $u, v$ 这条路径上的所有的点的惊吓值的或值 $\geq k$。

走过一条惊吓路径就会收到杀老师的惊喜大礼。杀老师已经提前准备好了惊喜大礼，但是業当然已经知道杀老师有一些下流的意图，更别说惊喜大礼的数量可能不够！杀老师已经承诺有多少条惊吓路径就有多少个惊喜大礼。業已经通过一些神奇的途径知道了杀老师准备的惊喜大礼的个数，现在他想知道有多少条惊吓路径，也就是杀老师最少需要准备惊喜大礼的个数。如果不够，他就会揭穿杀老师的意图。现在業当然想赚，好好捉弄一下杀老师。所以他~~作弊~~提前得到了杀老师的地图，想问这个图里面有多少条惊吓路径？

## 说明/提示

#### 样例解释 #1

![](https://cdn.luogu.com.cn/upload/image_hosting/lqu4ejku.png)

只有两条路径满足条件：

1. $3\to 1\to 2$，这条路径的所有点的惊吓值的或值是 $6\operatorname{or}5\operatorname{or}9=15$。

2. $1 \to 2$，这条路径的所有点的惊吓值的或值是 $5\operatorname{or}9=13$。

------------
#### 数据范围 
**本题采用捆绑测试**。

- Subtask 1（10 points）：$n \leq 5 \times 10^3$，$k \leq 10^5$。    
- Subtask 2（30 points）：对于任意一条边，$v=u+1$，$n \leq 10^6$，$k,a_i \leq 10^9$。     
- Subtask 3（20 points）：$n \leq 10^5$，$k,a_i \leq 10^9$。    
- Subtask 4（40 points）：$n \leq 5 \times 10^5$，$k,a_i \leq 10^9$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$，$1 \leq k,a_i \leq 10^9$。

------------
#### 提示
**第四个子任务中的测试点空间 256MB，其余子任务中的测试点空间 128MB。**

## 样例 #1

### 输入

```
5 10
5 9 6 4 2
3 1
3 4
1 2
1 5
```

### 输出

```
2```

## 样例 #2

### 输入

```
7 5
6 7 4 5 7 8 9
1 2
2 3
2 4
1 5
5 6
5 7
```

### 输出

```
16```

## 样例 #3

### 输入

```
8 5
4 3 2 5 6 7 6 2
1 2
1 5
2 3
2 4
5 6
5 7
6 8
```

### 输出

```
16```

# AI分析结果



---

## 算法分类  
**树上倍增**

---

## 综合分析与结论  

### 题目核心  
在树结构中找到所有满足路径或值 ≥k 的 (u, v) 对，其中 v 在 u 的子树中。利用或运算的单调性（路径延伸时或值非减），通过预处理加速查询。

---

### 题解思路与难点对比  
**核心算法流程**：  
1. **倍增预处理**  
   - 预处理每个节点向上 2^j 级的祖先和对应路径或值。  
   - 对每个节点 v，从低到高尝试跳跃，找到最深满足条件的 u。  

2. **空间优化**  
   - **栈维护链**：在 DFS 过程中用栈记录当前路径，实时计算或值，避免存储完整倍增数组。  
   - **链的特殊处理**：对退化为链的树，采用双指针+位计数技巧，实现线性空间。  

3. **数据结构替代**  
   - 使用 Splay 树维护链上区间或值查询，优化二分查找效率。

**解决难点**：  
- **空间限制**：通过动态维护栈或链式处理避免存储 O(n log n) 的倍增数组。  
- **时间复杂度**：利用或运算的单调性，将路径查找优化至 O(n log n) 或 O(n)。  

---

### 最优思路提炼  
1. **倍增法核心**  
   - **预处理** `f[i][j]`（祖先）和 `orsum[i][j]`（路径或值）。  
   - **跳跃逻辑**：从高到低尝试跳跃，累计或值直到 ≥k。  

2. **链的双指针优化**  
   - 维护当前区间或值，右指针扩展时更新或值，左指针收缩时撤销贡献。  

3. **栈动态维护**  
   - 在 DFS 过程中用栈保存当前路径，实时更新或值数组，避免存储完整倍增表。

---

### 题解评分 (≥4星)  

1. **zhengrunzhe 题解（5星）**  
   - **亮点**：分情况处理普通树和链，结合倍增与 Splay 树，空间优化巧妙。  
   - **代码实现**：通过条件判断切换算法，链处理部分使用 Splay 树加速查询。  

2. **LanrTabe 题解（5星）**  
   - **亮点**：栈维护路径，实时计算或值，空间复杂度 O(n)，非递归 DFS 避免爆栈。  
   - **代码片段**：  
     ```cpp  
     void Calc(int x) {  
         s[++Top] = x;  
         for (int i=1; 1<<i <= Top; ++i)  
             f[i][Top] = f[i-1][Top] | f[i-1][Top - (1<<(i-1))];  
         // 倍增计算当前路径或值  
     }  
     ```  

3. **漠寒 题解（4星）**  
   - **亮点**：二分+倍增组合，ST 表预处理链上区间或值。  
   - **适用场景**：链结构下时间复杂度 O(n log n)。  

---

### 代码核心实现  

**zhengrunzhe 的倍增跳跃逻辑**：  
```cpp  
inline const int jump(int p) {  
    int sum = val[p];  
    if (sum >= k) return p;  
    for (int i=logn; ~i; i--)  
        if (anc[p][i] && (sum | orsum[p][i]) < k)  
            sum |= orsum[p][i], p = anc[p][i];  
    return anc[p][0];  
}  
```  

**LanrTabe 的栈维护路径**：  
```cpp  
void Calc(int x) {  
    s[++Top] = x;  
    f[0][Top] = c[x];  
    for (int i=1; (1<<i) <= Top; ++i)  
        f[i][Top] = f[i-1][Top] | f[i-1][Top - (1<<(i-1))];  
    // 计算贡献时直接从栈中取区间或值  
}  
```  

---

### 可视化设计  

**动画方案**：  
1. **树上倍增跳跃**  
   - **高亮节点**：当前节点 `v` 和跳跃路径上的祖先。  
   - **颜色标记**：红色表示当前或值 <k，绿色表示 ≥k。  
   - **步进控制**：单步展示跳跃过程，显示每次跳跃后的或值。  

2. **链双指针移动**  
   - **网格绘制**：链节点水平排列，左右指针标记区间。  
   - **动态或值**：显示当前区间或值的二进制位变化（如 LED 灯式点亮）。  

**复古像素风格**：  
- **颜色方案**：8位色（红、绿、蓝、黄）表示不同或值状态。  
- **音效**：跳跃时播放「跳跃音效」，找到合法区间时播放「胜利音效」。  

---

### 类似题目推荐  
1. [P3384 树链剖分](https://www.luogu.com.cn/problem/P3384)  
2. [P2420 异或路径](https://www.luogu.com.cn/problem/P2420)  
3. [P4513 小白逛公园（区间或值维护）](https://www.luogu.com.cn/problem/P4513)  

---

### 个人心得摘录  
- **调试教训**：链结构下直接倍增会 MLE，需特判处理（zhengrunzhe）。  
- **顿悟点**：或运算的单调性使得双指针法可行（漠寒）。  

--- 

**可视化交互示例**（伪代码）：  
```javascript  
// 链双指针动画（Canvas 绘制）  
function drawChain() {  
    ctx.fillStyle = "#8B00FF"; // 紫色背景  
    ctx.fillRect(0, 0, canvas.width, canvas.height);  
    for (let i = l; i <= r; i++) {  
        ctx.fillStyle = (i >= currentL && i <= currentR) ? "#FFD700" : "#696969";  
        ctx.fillRect(i * 30, 150, 20, 20); // 节点方块  
    }  
}  
```

---
处理用时：86.08秒
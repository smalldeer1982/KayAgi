# 题目信息

# [NOIP 2009 普及组] 分数线划定

## 题目描述

世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，A 市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的 $150\%$ 划定，即如果计划录取 $m$ 名志愿者，则面试分数线为排名第 $m \times 150\%$（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。

现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。

## 说明/提示

【样例说明】

$m \times 150\% = 3 \times150\% = 4.5$，向下取整后为 $4$。保证 $4$ 个人进入面试的分数线为 $88$，但因为 $88$ 有重分，所以所有成绩大于等于 $88$ 的选手都可以进入面试，故最终有 $5$ 个人进入面试。

NOIP 2009 普及组 第二题


## 样例 #1

### 输入

```
6 3 
1000 90 
3239 88 
2390 95 
7231 84 
1005 95 
1001 88```

### 输出

```
88 5 
1005 95 
2390 95 
1000 90 
1001 88 
3239 88 ```

# AI分析结果



### 算法分类选择
无算法分类

---

### 题解思路、算法要点与解决难点
#### 核心思路
所有题解均采用**排序+模拟**的核心逻辑：
1. 按成绩降序、报名号升序双重规则排序
2. 计算分数线为第⌊m×150%⌋名选手的成绩
3. 统计所有成绩≥分数线的选手数量
4. 按排序结果输出录取名单

#### 解决难点对比
| 题解方案               | 关键处理方式                                                                 | 优势与风险                                                                 |
|------------------------|----------------------------------------------------------------------------|----------------------------------------------------------------------------|
| 结构体排序法           | 直接存储报名号与分数，通过自定义比较函数排序                                | 逻辑直观，但部分题解在统计同分时存在边界错误（如反向遍历导致漏统计）       |
| 下标数组法             | 通过额外数组记录原下标，排序时比较对应元素                                  | 避免结构体使用，但可读性降低                                               |
| Splay树实现            | 用平衡树维护分数与报名号集合                                               | 理论复杂度相同但实现复杂，属于炫技型解法                                   |
| 同分累加法             | 先计算基准线，再遍历累加所有同分人数                                        | 正确解决同分边界问题，但需注意遍历方向与终止条件                           |

#### 可视化算法分析
![排序过程可视化](https://via.placeholder.com/800x400.png?text=Sorting+Visualization)
1. **排序阶段**：展示元素按成绩降序排列，同分时按报名号升序排列的动画
2. **分数线划定**：高亮第⌊m×150%⌋个元素，标注其分数值
3. **同分统计**：从左向右扫描，用不同颜色区分达标与未达标元素
4. **输出阶段**：按排序顺序逐个弹出录取者信息

---

### 题解评分（≥4星）
#### 1. Eason_lyx（5星）
- **亮点**：简洁的while循环统计达标人数，完美处理同分边界
- **代码片段**：
```cpp
sc = a[(int)(m*1.5)].s;
while(a[cnt+1].s >= sc) cnt++; // 动态统计达标人数
```

#### 2. WsW_（4.5星）
- **亮点**：使用pair容器简化排序逻辑，线性扫描统计达标者
- **优化点**：变量命名可更语义化（如用score代替f）

#### 3. ryf2011（4星）
- **亮点**：显式处理同分累加逻辑，代码注释清晰
- **注意点**：需确保同分累加方向正确（从基准线向后扫描）

---

### 最优思路/技巧提炼
1. **双键排序**：优先按成绩降序，次按报名号升序
2. **动态统计**：计算分数线后，通过正向遍历直接统计达标人数
3. **向下取整技巧**：利用整型运算自动截断特性（m*3/2 等效于m×150%向下取整）
4. **结构体封装**：将报名号与成绩绑定，保证排序后数据一致性

---

### 同类型题与算法套路
1. **排序+边界处理**：常见于排名类问题（如奖学金评定、竞赛排名）
2. **双键排序模式**：需要主次排序键的场景（如按成绩排序后按交卷时间排序）
3. **比例计算问题**：涉及百分比取整的统计类题目

---

### 推荐练习题
1. P1051 [NOIP2005 普及组] 谁拿了最多奖学金（排序+多条件计算）
2. P1781 宇宙总统（大数排序+字符串处理）
3. P1062 数列（排序与数学结合）

---

### 个人心得摘录
> "注意测试用例中的同分情况，不能简单按比例截断，必须扫描完所有同分选手" —— ryf2011
> 
> "结构体比较函数要同时处理两种排序条件，避免遗漏任何一个比较分支" —— WsW_

---

### 复古游戏化动画设计
```javascript
// 伪代码示例
class RetroVisualizer {
  constructor(scores) {
    this.pixels = new PixelCanvas('#canvas', 800, 600);
    this.scores = scores;
    this.currentStep = 0;
  }

  renderSorting() {
    this.pixels.drawBarChart(scores, { 
      colorScheme: '8bit', 
      highlight: currentComparePair 
    });
    playSound('blip', 800 + currentScore*10);
  }

  showCutoffLine() {
    this.pixels.drawLine(cutoffIndex, 'FF0000', 3);
    playSound('powerUp');
  }
}

// 交互控制示例
document.getElementById('step').addEventListener('click', () => {
  visualizer.nextStep();
});
```

#### 像素风格要素
1. **调色板**：采用NES经典8色方案（黑、白、红、蓝、绿、黄、紫、青）
2. **音效**：
   - 元素移动：8-bit "blip" 音效
   - 确定分数线：经典马里奥吃金币音效
   - 错误操作：红白机爆炸音效
3. **动画效果**：排序过程用气泡排序式逐帧动画，分数线划定后像素火花特效

---

### 核心代码实现
```cpp
// 最优解代码（Eason_lyx）
#include<bits/stdc++.h>
using namespace std;
struct M{ int k,s; }a[5005];
bool cmp(M a,M b){
    return a.s!=b.s ? a.s>b.s : a.k<b.k;
}

int main(){
    int n,m,sc,cnt=0;
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i].k>>a[i].s;
    sort(a+1,a+n+1,cmp);
    
    sc = a[int(m*1.5)].s;
    while(a[cnt+1].s>=sc) cnt++; // 动态统计达标人数
    
    cout<<sc<<" "<<cnt<<endl;
    for(int i=1;i<=cnt;i++)
        cout<<a[i].k<<" "<<a[i].s<<endl;
    return 0;
}
```

---
处理用时：112.08秒
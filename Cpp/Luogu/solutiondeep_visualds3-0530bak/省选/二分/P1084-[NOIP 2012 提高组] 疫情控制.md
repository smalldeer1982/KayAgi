# 题目信息

# [NOIP 2012 提高组] 疫情控制

## 题目描述

H 国有 $n $ 个城市，这 $n$ 个城市用 $ n-1 $ 条双向道路相互连通构成一棵树，$1 $ 号城市是首都，也是树中的根节点。

H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。

现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。

请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。


## 说明/提示

【输入输出样例说明】

第一支军队在 $2$ 号点设立检查点，第二支军队从 $2$ 号点移动到$ 3$ 号点设立检查点，所需时间为 $3$ 个小时。

 
【数据范围】

保证军队不会驻扎在首都。

- 对于 $20\%$ 的数据，$2 \le n\le 10$；
- 对于 $40\%$ 的数据，$2 \le n\le 50$，$0<w <10^5$；
- 对于 $60\%$ 的数据，$2 \le n\le 1000$，$0<w <10^6$；
- 对于 $80\%$ 的数据，$2 \le n\le 10^4$；
- 对于 $100\%$ 的数据，$2\le m\le n≤5\times 10^4$，$0<w <10^9$。


NOIP 2012 提高组 第二天 第三题


## 样例 #1

### 输入

```
4 
1 2 1 
1 3 2 
3 4 3 
2 
2 2```

### 输出

```
3```

# AI分析结果



# [NOIP 2012 提高组] 疫情控制

## 算法分类
二分答案

---

## 题解思路与核心分析

### 整体思路
所有题解均采用二分答案框架，结合树上倍增预处理、贪心策略完成判定。核心步骤为：
1. **二分时间**：确定可能的时间范围（0 到所有边权和）
2. **树上倍增**：预处理每个节点的祖先与距离，快速计算军队可达的最远位置
3. **贪心匹配**：优先处理能到达根节点的军队，剩余资源匹配未覆盖的子树

### 二分过程详解
- **搜索区间**：初始区间为 [0, 所有边权和]，最终收敛到最小可行时间
- **mid 计算**：每次取区间中点 `mid = (left + right) >> 1`
- **判定条件**：通过 `check(mid)` 判断 mid 是否可行
- **区间收缩**：若可行则右边界左移（`right = mid - 1`），否则左边界右移（`left = mid + 1`）

### 解决难点对比
| 难点              | TEoS 题解解决方式                     | litble 题解解决方式                  |
|-------------------|-------------------------------------|-------------------------------------|
| 子树覆盖判定       | DFS 遍历标记已覆盖节点               | 递归检查子树是否需要驻军             |
| 闲置军队匹配       | 双指针贪心匹配剩余时间与子树距离      | 优先处理自身子树需求，剩余资源排序分配|
| 时间最优性证明     | 通过反证法说明贪心策略最优性         | 直接通过排序性质证明最优匹配          |

---

## 最优思路提炼
1. **倍增预处理**：用 `f[i][j]` 记录节点 i 的 2^j 级祖先，`dist[i][j]` 记录对应距离，实现 O(logn) 的跳跃计算
2. **双向贪心**：
   - **上提策略**：军队尽可能向上跳跃至根节点或临界点
   - **匹配策略**：将可调配军队按剩余时间降序排列，未覆盖子树按距离降序排列，双指针匹配
3. **关键剪枝**：对无法返回原子树的军队优先处理自身需求

---

## 核心代码实现
```cpp
bool check(ll lim) {
    memset(sta, 0, sizeof(sta));
    vector<pair<ll, int>> h; // 可调配军队
    vector<ll> ned;          // 需覆盖子树
    
    // 上提军队并分类
    for (int i = 1; i <= m; ++i) {
        int x = army[i];
        ll cnt = 0;
        for (int j = 16; j >= 0; --j)
            if (f[x][j] > 1 && cnt + dist[x][j] <= lim)
                cnt += dist[x][j], x = f[x][j];
        
        if (f[x][0] == 1 && cnt + dist[x][0] <= lim)
            h.emplace_back(lim - cnt - dist[x][0], x);
        else 
            sta[x] = true;
    }

    // 标记已覆盖节点
    function<bool(int)> dfs = [&](int u) {
        if (sta[u]) return true;
        bool is_leaf = true;
        for (int v : tree[u]) {
            if (v == fa[u]) continue;
            is_leaf = false;
            if (!dfs(v)) return false;
        }
        return !is_leaf;
    };

    // 收集未覆盖子树
    for (int v : tree[1]) 
        if (!dfs(v)) 
            ned.push_back(dist[v][0]);

    // 贪心匹配
    sort(h.begin(), h.end(), greater<>());
    sort(ned.begin(), ned.end(), greater<>());
    int i = 0, j = 0;
    while (i < h.size() && j < ned.size()) {
        if (h[i].first >= ned[j]) ++i, ++j;
        else ++i;
    }
    return j == ned.size();
}
```

---

## 同类型题目推荐
1. P1314 聪明的质监员（二分+前缀和）
2. P1948 电话线（二分+最短路判定）
3. P2218 覆盖问题（二分+几何覆盖判定）

---

## 可视化设计说明
**动画演示二分过程**：
1. **区间可视化**：使用横向进度条表示 [left, right] 区间，动态展示 mid 位置
2. **军队移动模拟**：树形结构显示军队跳跃路径，颜色区分：
   - 红色：无法到达根节点
   - 绿色：到达根节点后可调配
3. **覆盖状态更新**：子树节点按覆盖状态闪烁（绿色已覆盖/红色未覆盖）

**复古像素风格实现**：
```javascript
// Canvas 绘制示例
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');

function drawBinaryState(left, right, mid, result) {
    ctx.fillStyle = '#000'; // 黑色背景
    ctx.fillRect(0, 0, 400, 40);
    
    // 绘制区间条
    ctx.fillStyle = '#0f0'; // 绿色区间
    ctx.fillRect(10, 15, 380, 10);
    
    // 绘制 mid 标记
    ctx.fillStyle = result ? '#f00' : '#ff0'; // 成功红色/失败黄色
    const midX = 10 + (mid - left) / (right - left) * 380;
    ctx.fillRect(midX - 2, 10, 4, 20);
    
    // 8-bit 字体显示数值
    ctx.fillStyle = '#fff';
    ctx.font = '12px "Press Start 2P"';
    ctx.fillText(`L:${left} R:${right} MID:${mid}`, 20, 35);
}
```

---

## 关键技巧总结
1. **倍增跳跃优化**：将 O(n) 的跳跃优化至 O(logn)
2. **延迟标记处理**：对必须驻守的子树优先处理，避免重复计算
3. **排序降维**：通过排序将二维匹配问题转化为一维双指针问题
4. **边界处理**：通过 `left <= right` 循环保证收敛，最终答案取收敛后的 left

---

## 个人调试心得
1. **倍增表错误**：曾因未正确初始化 `f[0][x]` 导致跳跃计算错误
2. **贪心顺序**：最初按升序匹配导致大资源浪费，改为降序后通过
3. **叶节点误判**：未考虑单节点子树导致覆盖判定错误，增加 `is_leaf` 标志修复

---

## 学习价值
本题综合运用二分答案、树上操作、贪心策略三大算法模块，是训练复杂问题分解能力的经典案例。其核心思想可拓展至：
- 网络流中的资源分配问题
- 分布式系统中的任务调度
- 实时系统中的最坏情况时间分析

---
处理用时：81.13秒
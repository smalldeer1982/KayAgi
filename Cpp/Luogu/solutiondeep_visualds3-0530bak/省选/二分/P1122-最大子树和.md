# 题目信息

# 最大子树和

## 题目描述

小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：

一株奇怪的花卉，上面共连有 $N$ 朵花，共有 $N-1$ 条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。

老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。

## 说明/提示

### 数据范围及约定

- 对于 $60\%$ 的数据，有 $1\le N\le 1000$；
- 对于 $100\%$ 的数据，有 $1\le N\le 16000$。

## 样例 #1

### 输入

```
7
-1 -1 -1 1 1 1 0
1 4
2 5
3 6
4 7
5 7
6 7
```

### 输出

```
3```

# AI分析结果



# 【算法分类】  
无算法分类（核心为树形DP）

---

## 题解思路、算法要点与解决难点  
### 核心思路  
所有题解均围绕**树形DP**展开，关键点在于定义状态 `f[u]` 表示以 `u` 为根的子树的最大权值和。通过递归遍历树结构，判断子树的贡献是否为正，从而决定是否保留子树。  

### 解决难点  
1. **状态转移**：每个节点的决策依赖子节点的贡献，需递归后回溯处理。  
2. **负权处理**：若子树贡献为负，需剪枝（即不累加），避免降低总和。  
3. **树结构遍历**：需避免循环访问父节点，通过DFS或链式前向星实现。  

---

## 题解评分（≥4星）  
### 1. Mutsumi_0114（5星）  
- **亮点**：思路清晰，代码简洁，直接通过DFS递归计算每个节点的最大贡献。  
- **关键代码**：  
  ```cpp
  void dfs(int u, int fa) {
    f[u] = a[u];
    for (int v : E[u]) {
      if (v != fa) {
        dfs(v, u);
        if (f[v] > 0) f[u] += f[v];
      }
    }
  }
  ```  

### 2. FCBM71（4星）  
- **亮点**：引入 `fn` 数组优化传递过程，但复杂度与单状态法一致，代码稍复杂。  
- **关键代码**：  
  ```cpp
  void dfs(int x, int fa) {
    for (int son : E[x]) {
      if (son != fa) {
        dfs(son, x);
        if (fy[son] > 0) fy[x] += fy[son];
        tomax(fn[x], max(fn[son], fy[son]));
      }
    }
  }
  ```  

### 3. wyqwq（4星）  
- **亮点**：代码简洁，明确注释，突出树形DP核心逻辑。  
- **关键代码**：  
  ```cpp
  void dfs(int u, int fa) {
    f[u] = a[u];
    for (int v : tree[u]) {
      if (v != fa) {
        dfs(v, fa);
        if (f[v] > 0) f[u] += f[v];
      }
    }
  }
  ```  

---

## 最优思路提炼  
- **状态定义**：`f[u]` 表示以 `u` 为根的子树的最大权值和（必须包含 `u`）。  
- **转移方程**：`f[u] = a[u] + Σ max(f[v], 0)`，其中 `v` 是 `u` 的子节点。  
- **剪枝策略**：仅累加正贡献的子树，负贡献直接舍弃。  
- **最终答案**：遍历所有节点的 `f` 值取最大。  

---

## 同类型题与算法套路  
1. **树形DP通用解法**：递归遍历树结构，后序遍历更新父节点状态。  
2. **类似题目**：  
   - 洛谷 P1352（没有上司的舞会）  
   - 洛谷 P2015（二叉苹果树）  
   - 洛谷 P1273（有线电视网）  

---

## 推荐洛谷题目  
1. **P1352**：树形DP基础题，需处理相邻节点不可共存。  
2. **P2015**：树形DP结合背包问题，需保留特定边数。  
3. **P1273**：树形DP与资源分配结合，求最大收益。  

---

## 可视化与算法演示  
### 树形DP动态演示  
1. **树结构绘制**：以根节点为起点，递归展开子树，高亮当前计算的节点。  
2. **贡献标记**：  
   - 绿色：子节点贡献为正，保留并累加。  
   - 红色：子节点贡献为负，剪枝不累加。  
3. **数值更新**：实时显示每个节点的 `f` 值，回溯时更新父节点状态。  
4. **交互设计**：  
   - **步进控制**：手动触发DFS步骤，观察递归与回溯过程。  
   - **高亮路径**：用不同颜色标注当前处理的分支。  

### 复古像素风格（示例）  
- **颜色方案**：8位色调，绿色（#00FF00）表保留，红色（#FF0000）表剪枝。  
- **Canvas动画**：节点以像素方块表示，权值显示在方块中央，连线动态更新颜色。  
- **音效设计**：  
  - 正贡献时播放“收集金币”音效（8位风格）。  
  - 负贡献时播放“失败”音效。  

---

## 个人心得摘录  
- **Mutsumi_0114**：强调“任何连通分量都可视为以某点为根的树”，避免纠结根的选择。  
- **StoneXie**：初始暴力尝试以每个节点为根，发现超时，最终优化为单次DFS遍历所有节点。  
- **lavd**：错误使用二维数组导致MLE，提醒注意数据规模与内存限制。  

--- 

## 核心代码实现  
```cpp
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 16005;
vector<int> tree[MAXN];
int f[MAXN], a[MAXN], ans = -0x7fffffff;

void dfs(int u, int fa) {
    f[u] = a[u];
    for (int v : tree[u]) {
        if (v != fa) {
            dfs(v, u);
            if (f[v] > 0) f[u] += f[v];
        }
    }
    ans = max(ans, f[u]);
}

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        tree[u].push_back(v);
        tree[v].push_back(u);
    }
    dfs(1, 0);
    printf("%d", ans);
    return 0;
}
```

---
处理用时：81.40秒
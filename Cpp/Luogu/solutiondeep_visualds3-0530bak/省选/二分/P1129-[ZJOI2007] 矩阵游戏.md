# 题目信息

# [ZJOI2007] 矩阵游戏

## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。


## 样例 #1

### 输入

```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0
```

### 输出

```
No
Yes
```

# AI分析结果



# 算法分类  
**无算法分类**  

# 综合分析与结论  
本题核心是**二分图最大匹配**问题。通过将行与列视为二分图的两个集合，黑色格子作为边，求最大匹配是否等于矩阵维度 n。  
**核心难点**在于将行列交换操作转化为二分图模型：交换行/列本质是调整节点顺序，不影响匹配结构。通过构造初始图的二分模型，只需验证最大匹配是否为完全匹配。  

**可视化设计要点**：  
1. **像素风格演示**：用 8-bit 风格绘制行节点（左侧）、列节点（右侧），黑色格子用绿色像素块表示连线  
2. **匹配动画**：显示匈牙利算法的 DFS 过程，用黄色高亮当前搜索路径，红色标记已匹配边  
3. **音效设计**：  
   - 匹配成功时播放「金币音效」（上扬音调）  
   - 搜索路径回溯时播放「失败音效」（短促低音）  
4. **自动演示模式**：按步骤展示增广路径查找过程，用网格坐标模拟二分图节点布局  

---

# 题解清单（≥4星）  
## 1. 作者：俾斯麦（⭐⭐⭐⭐⭐）  
**亮点**：  
- 同时给出匈牙利与 Dinic 两种实现方案  
- 代码注释详细，包含多组数据清空优化  
- 完整讲解问题转化过程，附示意图辅助理解  

**核心代码片段**（匈牙利算法）：  
```cpp
bool dfs(int x) {
    for(int i=head[x]; i; i=next[i])
        if(!vis[y = to[i]]) {
            vis[y] = 1;
            if(!match[y] || dfs(match[y])) {
                match[y] = x; return true;
            }
        }
    return false;
}
```

## 2. 作者：cmwqf（⭐⭐⭐⭐）  
**亮点**：  
- 手绘示意图直观展示行列交换对匹配的影响  
- 代码简洁高效，使用邻接矩阵实现匈牙利算法  
- 强调「交换不影响最大匹配」的核心性质  

**核心思想**：  
> 将原始行号与目标列号建立匹配，交换操作只是调整节点顺序，不影响匹配存在性  

---

# 最优思路提炼  
**关键技巧**：  
1. **问题转化**：将每个黑色格子视为行与列的潜在匹配关系  
2. **模型构建**：构造二分图时，左侧为行号，右侧为列号，边表示可交换到主对角线  
3. **匹配验证**：若最大匹配数等于 n，则存在合法交换方案  

**思维突破点**：  
- 主对角线要求等价于每行必须找到一个唯一对应的列  
- 行/列交换操作等价于调整节点顺序，不影响匹配存在性  

---

# 同类题目推荐  
1. [P3386 二分图最大匹配](https://www.luogu.com.cn/problem/P3386)  
2. [P1963 变换序列](https://www.luogu.com.cn/problem/P1963)  
3. [P2756 飞行员配对方案问题](https://www.luogu.com.cn/problem/P2756)  

---

# 可视化演示方案（伪代码实现）  
```javascript  
// 像素风格初始化  
const canvas = document.createElement('canvas');
canvas.width = 640; 
canvas.height = 480;
const ctx = canvas.getContext('2d');

// 初始化行/列节点坐标  
const nodes = {
    left:  [{x:100, y:50}, {x:100, y:150}, ...],  // 行节点
    right: [{x:500, y:50}, {x:500, y:150}, ...]   // 列节点
};

// 动画主循环  
function animateMatch() {
    // 绘制 8-bit 风格节点
    ctx.fillStyle = '#00FF00'; // 绿色像素块
    nodes.left.forEach(n => drawPixelBlock(n.x, n.y)); 
    
    // 当前搜索路径高亮
    if(currentPath) {
        ctx.strokeStyle = '#FFFF00';
        drawPath(currentPath); 
    }
    
    // 播放音效
    if(matchFound) playSound('coin.wav');
}
```

---
处理用时：59.89秒
# 题目信息

# 酒店之王

## 题目描述

XX 酒店的老板想成为酒店之王，本着这种希望，第一步要将酒店变得人性化。由于很多来住店的旅客有自己喜好的房间色调、阳光等，也有自己所爱的菜，但是该酒店只有 $p$ 间房间，一天只有固定的 $q$ 道不同的菜，每个房间只能住一位客人，每道菜也只能给一位客人食用。

有一天来了 $n$ 个客人，每个客人说出了自己喜欢哪些房间，喜欢哪道菜。但是很不幸，可能做不到让所有顾客满意（满意的条件是住进喜欢的房间且吃到喜欢的菜）。

要怎么分配，能使最多顾客满意呢？

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n,p,q \leq 100$。

## 样例 #1

### 输入

```
2 2 2
1 0
1 0
1 1
1 1
```

### 输出

```
1```

# AI分析结果



## 【唯一算法分类】
网络流最大流（拆点技巧）

---

## **综合分析与结论**

### **核心思路与难点**
- **问题建模**：将客人同时匹配房间与菜的问题转化为网络流中的最大流问题。
- **关键难点**：确保每位客人仅匹配一次房间和一道菜。直接建图会导致同一客人被多次使用，需通过拆点限制流量。
- **解决方案**：
  - **拆点法**：将每个客人拆为入点（接收房间）和出点（连接菜），入点与出点间连容量为1的边，限制仅一次匹配。
  - **分层建图**：源点→房间→客人入点→客人出点→菜→汇点，所有边容量为1，确保资源唯一性。

### **可视化设计思路**
1. **动态流量演示**：动画展示路径查找（如BFS层序遍历），增广路径上的边高亮显示流量增减。
2. **拆点标识**：客人节点分为左右两部分，中间用红色边连接（容量1），选中时显示流量消耗。
3. **像素风格**：房间、客人、菜分别用不同色块，增广路径用闪烁线条，成功匹配时播放8-bit音效。
4. **交互控制**：允许调整算法（Dinic/EK）、单步执行观察流量变化，展示残余网络。

---

## **最优思路提炼**
1. **拆点技巧**：每个客人拆为两个节点，中间连容量1的边，严格限制仅一次匹配。
2. **分层建图结构**：
   ```
   源点 → 房间（边容量1）
   房间 → 客人入点（根据喜好连接）
   客人入点 → 客人出点（边容量1）
   客人出点 → 菜（根据喜好连接）
   菜 → 汇点（边容量1）
   ```
3. **Dinic算法优化**：BFS分层+DFS多路增广，时间复杂度更优，适合多次查询。

---

## **核心代码实现（Dinic算法）**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=0x3f3f3f3f, N=405, M=20010;

struct Edge {int to, next, cap;};
int head[N], tot=1, s, t, level[N], cur[N];
Edge e[M];

void add(int u, int v, int c) {
    e[++tot] = {v, head[u], c}; head[u] = tot;
    e[++tot] = {u, head[v], 0}; head[v] = tot; // 反向边
}

bool bfs() { // 分层
    memset(level, -1, sizeof level);
    queue<int> q; q.push(s); level[s]=0;
    while(!q.empty()) {
        int u=q.front(); q.pop();
        for(int i=head[u]; i; i=e[i].next) {
            int v=e[i].to;
            if(level[v]==-1 && e[i].cap>0) {
                level[v]=level[u]+1;
                if(v==t) return true;
                q.push(v);
            }
        }
    }
    return false;
}

int dfs(int u, int flow) { // 多路增广
    if(u==t) return flow;
    int ret=0;
    for(int &i=cur[u]; i; i=e[i].next) {
        int v=e[i].to;
        if(level[v]==level[u]+1 && e[i].cap>0) {
            int c=dfs(v, min(flow-ret, e[i].cap));
            if(c>0) {
                e[i].cap -= c;
                e[i^1].cap += c;
                ret += c;
                if(ret==flow) break;
            }
        }
    }
    return ret;
}

int dinic() {
    int max_flow=0;
    while(bfs()) {
        memcpy(cur, head, sizeof cur);
        max_flow += dfs(s, INF);
    }
    return max_flow;
}

int main() {
    int n,p,q; 
    cin>>n>>p>>q;
    s=0, t=2*n+p+q+1;
    
    // 源点连接房间（1~p）
    for(int i=1; i<=p; i++) add(s, i, 1); 
    // 菜连接汇点（p+2n+1~p+2n+q）
    for(int i=1; i<=q; i++) add(p+2*n+i, t, 1);
    
    // 客人拆点：入点p+1~p+n，出点p+n+1~p+2n
    for(int i=1; i<=n; i++) add(p+i, p+n+i, 1);
    
    // 房间→客人入点
    for(int i=1; i<=n; i++) 
        for(int j=1; j<=p; j++) {
            int x; cin>>x;
            if(x) add(j, p+i, 1);
        }
    // 客人出点→菜
    for(int i=1; i<=n; i++)
        for(int j=1; j<=q; j++) {
            int x; cin>>x;
            if(x) add(p+n+i, p+2*n+j, 1);
        }
    
    cout<<dinic();
    return 0;
}
```

---

## **相似题目推荐**
1. **P1231 教辅的组成**  
   同样需拆点处理三种资源匹配，网络流建模方法类似。
2. **P2763 试题库问题**  
   资源分配问题，可转化为多条件匹配。
3. **P3254 圆桌问题**  
   二分图多重匹配，需处理容量限制。

---
处理用时：69.17秒
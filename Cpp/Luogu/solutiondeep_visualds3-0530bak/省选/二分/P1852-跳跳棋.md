# 题目信息

# 跳跳棋

## 题目描述

跳跳棋是在一条数轴上进行的。棋子只能摆在整点上。每个点不能摆超过一个棋子。

![](https://cdn.luogu.com.cn/upload/image_hosting/hyfzn745.png)

我们用跳跳棋来做一个简单的游戏：棋盘上有 $3$ 颗棋子，分别在 $a,b,c$ 这三个位置。我们要通过最少的跳动把他们的位置移动成 $x,y,z$。（棋子是没有区别的）

跳动的规则很简单，任意选一颗棋子，对一颗中轴棋子跳动。跳动后两颗棋子距离不变。一次只允许跳过 $1$ 颗棋子。

写一个程序，首先判断是否可以完成任务。如果可以，输出最少需要的跳动次数。

## 说明/提示

### 数据范围及约定

- $20\%$ 输入整数的绝对值均不超过 $10$；
- $40\%$ 输入整数的绝对值均不超过 $10000$；
- $100\%$ 绝对值不超过 $10^9$。

## 样例 #1

### 输入

```
1 2 3
0 3 5```

### 输出

```
YES
2```

# AI分析结果



**算法分类**  
二分

---

### **题解思路与算法要点**  
1. **建模为二叉树**：将每个状态视为树节点，中间距离相等的状态为根。两个状态的相互转化等价于树上路径。
2. **LCA与路径计算**：通过调整两个状态到同一深度，二分查找它们的最近公共祖先（LCA），总步数为深度差+2倍LCA距离。
3. **快速跳跃优化**：使用类似辗转相除的方法计算连续跳跃次数，避免逐次模拟，时间复杂度优化至O(logV)。
4. **二分核心逻辑**：
   - **搜索区间**：初始为[0, min(dep1, dep2)]
   - **条件判断**：检查mid步跳跃后两状态是否相同
   - **区间收缩**：若相同则收缩右边界，否则收缩左边界

---

### **题解评分 (≥4星)**  
1. **LlLlCc (5星)**  
   - 清晰讲解二叉树建模与LCA的关系  
   - 代码实现高效，包含快速跳跃优化  
   - 附详细状态转移公式和图示  

2. **ButterflyDew (4.5星)**  
   - 提出"加速跳跃"的GCD式实现  
   - 代码模块化设计，可读性强  
   - 包含博客链接扩展分析  

3. **Cgod (4星)**  
   - 详细注释核心跳跃逻辑  
   - 实现压缩路径的跳跃计数器  
   - 包含调试经验分享  

---

### **关键技巧提炼**  
1. **状态归一化处理**：始终排序三坐标保证x<y<z  
   ```cpp
   void adjust(){sort(a, a+3);}
   ```
2. **快速跳跃算法**：
   ```cpp
   int jump(int &x, int &y, int &z, int k) {
       while(k > 0) {
           int d1 = y-x, d2 = z-y;
           if(d1 == d2) break;
           if(d1 > d2) {
               int cnt = min(k, (d1-1)/d2);
               x += cnt*d2; 
               y += cnt*d2;
               k -= cnt;
           } else {
               int cnt = min(k, (d2-1)/d1);
               z -= cnt*d1;
               y -= cnt*d1; 
               k -= cnt;
           }
       }
       return k;
   }
   ```
3. **二分判定函数**：
   ```cpp
   bool check(int mid) {
       State s1 = jump(orig_state, mid);
       State s2 = jump(target_state, mid);
       return s1 == s2;
   }
   ```

---

### **同类型题目推荐**  
1. P1439 【模板】最长公共子序列（二分优化）  
2. P1083 借教室（二分答案）  
3. P4344 脑力震荡（状态跳跃树）

---

### **可视化设计**  
**像素化二分演示**：  
1. **Canvas布局**：显示两个状态的深度调整过程  
   - 左侧竖条：初始状态跳跃动画，红蓝像素块表示跳跃步数  
   - 右侧竖条：目标状态同步跳跃  
2. **音效触发**：  
   ```javascript
   function playJumpSound() {
       const osc = audioCtx.createOscillator();
       osc.frequency.value = 440 + Math.random()*880;
       osc.connect(audioCtx.destination);
       osc.start(); osc.stop(0.05);
   }
   ```
3. **AI自动模式**：  
   ```javascript
   function autoPlay() {
       let L=0, R=MAX_DEPTH;
       while(L <= R) {
           let mid = (L+R)>>1;
           drawMidPointer(mid);
           if(check(mid)) R=mid-1;
           else L=mid+1;
           await sleep(500);
       }
   }
   ```

---

### **核心代码实现**  
完整二分逻辑片段：
```cpp
int main() {
    // 初始化状态并调整深度
    if(dep1 > dep2) {
        jump(a_state, dep1-dep2);
        depth_diff = dep1-dep2;
    }
    
    // 二分查找LCA距离
    int L=0, R=min(dep1,dep2);
    while(L <= R) {
        int mid = (L+R)/2;
        State s1 = jump(a_state, mid);
        State s2 = jump(b_state, mid);
        if(s1 == s2) {
            ans = mid;
            R = mid-1;
        } else {
            L = mid+1;
        }
    }
    
    cout << "YES\n" << depth_diff + 2*ans;
}
```

---

**结论**：通过二叉树建模与二分优化，将看似复杂的跳跃问题转化为高效的LCA求解，体现了算法设计中模型抽象的重要性。

---
处理用时：60.78秒
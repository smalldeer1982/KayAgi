# 题目信息

# [IOI 2017] The Big Prize

## 题目背景

这里是洛谷。如果有疑问，可以发帖求助。

如果你习惯于写函数式交互，以下内容可能对你有帮助：

```cpp
vector<int>ask(int i)
{
	printf("? %d\n",i);fflush(stdout);
	vector<int>ret(2);
	scanf("%d%d",&ret[0],&ret[1]);
	return ret;
}
int find_best(int n)
{
	//
}
main()
{
	int n;scanf("%d",&n);
	printf("! %d\n",find_best(n));
}
```

无论如何，你都不应引入额外的头文件。

## 题目描述

“大奖”是一个家喻户晓的 TV 游戏节目。这次你很幸运地进入到最后一轮。已知编号从 $0$ 到 $n-1$ 的 $n$ 个盒子从左到右排成一行，你就站在这排盒子的前面。每个盒子里面放有一个奖品，必须打开盒子才能看到是什么奖品。已知有 $v\leq5$ 种不同类型的奖品。这 $v$ 种类型按照奖品价值的降序从 $1$ 到 $v$ 排列。

类型 $1$ 的奖品是一块钻石，价值最高。所有盒子加起来刚好只有一块钻石。类型 $v$ 的奖品是一块棒棒糖，价值最低。为使得游戏更加激动人心，相对便宜的奖品数量远比价值昂贵的奖品数量要多。更具体一点，对于满足 $2\leq t \leq v$ 的所有 $t$，我们有： 如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。

你的目标是赢得那块钻石。在游戏结束时，你必须打开一个盒子并收取盒子内的奖品。在选择要打开的盒子之前，你可以向节目主持人 Rambod 提一些问题。在每一个问题中，你选择就某个 $i$ 号盒子进行提问。Rambod 将给你一个包含两个整数的数组 $a$ 作为回答。这两个整数的意义如下：

- 在 $i$ 号盒子左面的盒子中，刚好有 $a[0]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。
- 在 $i$ 号盒子右面的盒子中，刚好有 $a[1]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。

例如，假设 $n=8$，在你的问题中，你选择就 $i=2$ 号盒子进行提问。Rambod 的回答是 $a=[1,2]$。这个回答的意义是：

- $0$ 号盒子和 $1$ 号盒子中恰好有一个盒子中的奖品比 $i$ 号盒子中的奖品更贵。
- 在 $3,4,\cdots,7$ 号盒子中恰好有 $2$ 个盒子中的奖品比 $2$ 号盒子中的奖品更贵。

你的任务就是通过问少量的问题找出包含钻石的盒子。

## 说明/提示

### 样例解释

```plain
8
3 2 3 1 3 3 2 3
```

![](https://cdn.luogu.com.cn/upload/pic/6728.png)

上图阐释了这个例子。图中上半部分给出了每个盒子中奖品的类型。图中的下半部分阐释了询问 `? 2`。

### 限制

- $3\leq n \leq200000$.
- 每个盒子中奖品的类型介于 $1$ 和 $v$ 之间（含）。
- 类型 $1$ 的奖品恰有一个。
- 对于所有 $2\leq t \leq v$，如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。


### 子任务与评分

1.  （$20$ 分）恰好有 $1$ 个钻石和 $n-1$ 个棒棒糖 （所以，$v=2$）。你可以询问最多 $10000$ 次。
2.  （$80$ 分）没有附加限制。


在子任务 2 中你可以获得部分分。令 $q$ 是在这个子任务的所有测试数据上发起询问的最大次数，那么你在这个子任务上的得分将按照下表计算：

![](https://cdn.luogu.com.cn/upload/pic/6729.png)

## 样例 #1

### 输入

```
8

0 3

0 1

1 2

0 0

2 1

2 1

1 0

3 0```

### 输出

```

? 0

? 1

? 2

? 3

? 4

? 5

? 6

? 7

! 3```

# AI分析结果



### 唯一算法分类
二分

---

### 综合分析与结论

#### 核心思路
题目要求通过最少询问找到唯一一个钻石盒（类型1）。关键观察点：
1. **钻石的判别条件**：当询问结果 `a[i][0]` 和 `a[i][1]` 均为 0 时，即为钻石所在盒。
2. **类型数量条件**：低价值类型数量远多于高价值类型，这使得高价值类型分布稀疏，可利用分治策略快速剪枝。
3. **分治剪枝**：若区间两端点询问结果相同，则中间无需处理；否则递归分治，最终定位钻石。

#### 二分过程可视化设计
- **区间划分**：将整个数组划分为多个块（如每 511 个一块），优先查询块端点。
- **颜色标记**：
  - 红色高亮当前处理区间端点（L, R）。
  - 绿色标记已确认的无效区间（端点相同）。
  - 黄色闪烁表示正在进行分治的中间点（mid）。
- **收缩逻辑**：若 `a[L] != a[R]`，则继续分割区间；否则跳过该块。
- **动画效果**：每次分治时动态绘制区间收缩过程，用像素方块表示当前搜索范围。

#### 复古游戏化设计
- **像素风格**：用 8 位色块表示数组区间，灰色表示未处理块，绿色表示剪枝块，红色表示活跃分治区间。
- **音效**：
  - 分治时播放“滴”声。
  - 找到钻石时播放胜利旋律（8-bit 风格）。
- **自动演示**：模拟 AI 分治流程，自动遍历块并递归处理。

---

### 题解清单（≥4星）

#### 1. phigy 的题解（★★★★☆）
- **亮点**：分块 + 随机化 + 分治剪枝，有效减少查询次数。
- **关键代码**：通过 `solve` 函数递归处理区间，块端点相同则跳过。
- **优化点**：随机打乱块处理顺序，降低最坏情况概率。

#### 2. Aiopr_2378 的题解（★★★★☆）
- **亮点**：利用类型相同点的差值剪枝，减少无效查询。
- **关键代码**：维护集合 `s` 跟踪已查询点，动态判断区间有效性。
- **思维角度**：通过相邻点类型一致性快速排除大段区间。

---

### 最优思路与技巧提炼
1. **分治剪枝**：递归处理区间时，优先比较端点，相同则剪枝。
2. **块处理优化**：将数组分块，优先处理端点，利用类型分布特性减少深度递归。
3. **随机化策略**：随机打乱块处理顺序，避免最坏情况下的高查询次数。
4. **类型和判断**：通过 `a[i][0] + a[i][1]` 快速过滤低价值类型区域。

---

### 同类型题与算法套路
- **类似题目**：在稀疏分布的有序数据中快速定位目标，如「寻找峰值」「山脉数组」。
- **通用套路**：
  - **分治剪枝**：利用数据分布特性，优先处理端点或中间点。
  - **块划分**：分块预处理，减少递归深度。
  - **随机化优化**：避免最坏情况，平衡平均复杂度。

---

### 推荐题目
1. **P2678 跳石头**（二分答案 + 贪心验证）
2. **P1024 一元三次方程求解**（二分法求根）
3. **P3382 三分法**（三分查找极值）

---

### 个人心得摘录
- **调试教训**：需正确处理边界条件，如区间长度为 1 时直接返回。
- **顿悟点**：当端点类型相同时，中间无需处理，极大减少查询次数。

---

### 核心代码实现（phigy 解法）
```cpp
void solve(int L, int R) {
    ask(L); ask(R);
    if (R - L == 1) return;
    if (a[L] == a[R]) return;
    int mid = (L + R) >> 1;
    solve(L, mid);
    solve(mid, R);
}
```

---

### 可视化代码片段（伪代码）
```javascript
// 绘制分治过程（Canvas）
function drawInterval(L, R, mid) {
    ctx.fillStyle = '#FF0000'; // 红色标记端点
    ctx.fillRect(L * cellWidth, 0, cellWidth, cellHeight);
    ctx.fillRect(R * cellWidth, 0, cellWidth, cellHeight);
    ctx.fillStyle = '#FFFF00'; // 黄色标记 mid
    ctx.fillRect(mid * cellWidth, 0, cellWidth, cellHeight);
}

// 分治递归逻辑
function autoSolve(L, R) {
    if (L >= R) return;
    const mid = Math.floor((L + R) / 2);
    playSound('beep'); // 触发音效
    drawInterval(L, R, mid);
    setTimeout(() => {
        if (a[L] != a[R]) {
            autoSolve(L, mid);
            autoSolve(mid, R);
        } else {
            ctx.fillStyle = '#00FF00'; // 绿色标记剪枝区间
            ctx.fillRect(L * cellWidth, 0, (R - L) * cellWidth, cellHeight);
        }
    }, animationDelay);
}
```

---
处理用时：131.43秒
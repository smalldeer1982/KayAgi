# 题目信息

# [JLOI2008] 将军

## 题目描述

刘先生最近在学习国际象棋，使用一个叫 jloi-08 的游戏软件。在这个游戏里，不但可以和电脑普通地对弈，还可以学习著名的棋局，还有针对初学者的规则指导等丰富功能。但是…大小却要 1.4G T\_T。

言归正传，在这个软件里，为了让玩家更好地理解和运用各个棋子，有很多趣味的游戏，比如以下就是一个：

给出一个棋盘和一些棋子，让你把这些棋子摆放在棋盘上，使得两两不互相攻击。你的得分由你摆放上去的棋子的个数与种类有关。

这个游戏很复杂，刘先生老是玩不到高分。于是电脑便降低了难度，替刘先生摆上了一些棋子，最后只给你任意多个 bishop（教主）。

现在刘先生便要考一考你，在电脑给出的这张棋盘上，最多能放几个 bishop。

国际象棋中一共有 6 种棋子：

- king（国王）；
- queen（皇后）；
- bishop（教主）；
- knight（骑士）；
- rook（车）；
- pawn（步兵）。

各棋子的攻击范围如下：

- queen 可以攻击与它在同一行，同一列，同一条对角线的棋子；
- knight 的攻击范围如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/2669.png)

- rook 攻击水平和垂直两条线上的所有格子；
- pawn 攻击前方两条斜线方向各一格(“前方”指 $x$ 递增的方向，$x$ 行 $y$ 列）；
- king 攻击周围 8 个方向各 1 格；
- bishop 攻击两条对角线上的所有格子。

除 knight 以外，所有棋子的攻击范围均会被别的棋子所阻挡。

可惜的是这个软件也不是顶优秀，给出的棋盘上的棋子可能互相会攻击，不过你不用理会这些，你只要保证你摆放的 bishop 不与它们以及不互相攻击就可以了。

## 说明/提示

```plain
BBN
...
...
```

```plain
BBN
...
B..
```

虽然看上去下面的方法比上面的优秀，但是 N 被第三行的 B 攻击了。也就是说，你需要避免的有 2 种情况： 你摆放的 bishop 之间的互相攻击以及你摆放的 bishop 与预先摆放好的棋子之间的互相攻击；但不用考虑预先摆放好的棋子之间的互相攻击。


## 样例 #1

### 输入

```
3 3
..N
...
...
```

### 输出

```
2```

# AI分析结果



### 算法分类
**无算法分类**

---

### 题解思路与核心要点

#### **核心思路**
所有题解的核心思想是将棋盘旋转45°，将主教的斜线攻击转化为行/列攻击，构建二分图模型求最大匹配。具体流程如下：
1. **预处理攻击范围**：标记所有被原有棋子攻击的格子，确保新主教不与之冲突。
2. **坐标转换**：将原坐标 $(i,j)$ 转换为旋转后的坐标 $(i+j-1, j+n-i)$ 或类似形式，使得对角线变为行/列。
3. **二分图建模**：将旋转后的行作为左部节点，列作为右部节点，可放置主教的位置作为边。
4. **最大匹配**：使用匈牙利算法求二分图最大匹配，结果即为最多可放置的主教数。

#### **解决难点**
- **攻击范围预处理**：需处理不同棋子的攻击规则（如车、皇后等会阻挡攻击线）。
- **坐标转换**：需正确计算旋转后的坐标，避免转换错误导致建图错误。
- **二分图建模**：确保每个可放置的格子唯一对应一条边，避免重复或遗漏。

---

### 题解评分（≥4星）

1. **GNAQ（4星）**  
   - **亮点**：代码结构清晰，预处理函数（`GoK`、`GoQ`等）模块化，注释明确。  
   - **不足**：未详细解释坐标转换逻辑。

2. **caizehua（5星）**  
   - **亮点**：详细说明旋转后的坐标转换公式，预处理部分分步解析，代码可读性高。  
   - **心得**：强调输入时需一次性读取棋盘数据，避免逐字符读取导致错误。

3. **lly66666（4星）**  
   - **亮点**：代码简洁，预处理部分通过函数分离不同棋子逻辑。  
   - **不足**：缺乏对建图过程的详细注释。

---

### 最优思路与技巧提炼

1. **旋转棋盘建模**  
   - 将原棋盘坐标 $(i,j)$ 转换为旋转后的 $(i+j-1, j+n-i)$，使对角线攻击变为行/列攻击。
   - **代码片段**：  
     ```cpp
     // 坐标转换示例（caizehua题解）
     struct node { int xx, yy; };
     a[i][j].xx = i + j - 1;  // 旋转后的行
     a[i][j].yy = j + n - i;  // 旋转后的列
     ```

2. **匈牙利算法优化**  
   - 使用链式前向星建图，避免邻接矩阵的空间浪费。
   - **代码片段**：  
     ```cpp
     void add(int x, int y) {
         to[++id] = y;
         ne[id] = head[x];
         head[x] = id;
     }
     ```

3. **攻击范围预处理**  
   - 分棋子类型处理攻击逻辑，注意阻挡效应（如车、皇后攻击线被其他棋子阻挡）。
   - **代码片段**（处理车的攻击范围）：  
     ```cpp
     void Rook(int x, int y) {
         for (int i = x-1; i >= 1; i--) {
             if (mapx[i][y] != '.') break;
             av[i][y] = true;
         }
         // 处理其他方向...
     }
     ```

---

### 类似题目推荐
1. **[P2825 [HEOI2016/TJOI2016] 游戏](https://www.luogu.com.cn/problem/P2825)**  
   - **相似点**：棋盘覆盖问题，行列匹配建模。
2. **[P6062 [USACO05JAN] Muddy Fields G](https://www.luogu.com.cn/problem/P6062)**  
   - **相似点**：预处理行列连通块，二分图最小覆盖。
3. **[P10945 [TJOI2013] 攻击装置](https://www.luogu.com.cn/problem/P10945)**  
   - **相似点**：棋盘攻击范围建模，最大独立集问题。

---

### 可视化与算法演示设计

#### **核心逻辑演示**
1. **棋盘旋转动画**：  
   - 使用CSS3旋转动画将原棋盘顺时针旋转45°，展示对角线变为行/列的过程。
2. **二分图动态构建**：  
   - 可放置的格子高亮为绿色，边连接旋转后的行/列节点，匈牙利算法匹配时实时显示增广路径。
3. **攻击范围标记**：  
   - 被原有棋子攻击的格子标记为红色，不可放置区域标记为灰色。

#### **复古像素风格实现**
- **颜色方案**：  
  - 可用16色调色板，如绿色（#00FF00）表示可放置格子，红色（#FF0000）表示攻击范围。
- **音效设计**：  
  - 主教放置时播放8位“放置音效”，匹配成功时播放胜利音效。
- **Canvas动画**：  
  ```javascript
  // 伪代码：绘制旋转后的棋盘网格
  ctx.fillStyle = '#00FF00'; // 可放置格子
  ctx.fillRect(rotatedX * 30, rotatedY * 30, 28, 28);
  ```

---

### 个人心得摘录
- **caizehua**：  
  > “输入棋盘时必须一次性读取整个矩阵，逐字符读取可能因换行符导致错误。”  
  **总结**：数据读取细节影响全局，需特别注意。
  
- **GNAQ**：  
  > “Dinic跑不过但匈牙利可以，可能是稀疏图特性。”  
  **总结**：算法选择需结合具体图结构。

---

### 代码实现（匈牙利算法核心）
```cpp
bool dfs(int u, int src) {
    for (int prex = ptr[u]; prex; prex = edge[prex].pre) {
        int v = edge[prex].to;
        if (vis[v] != src) {
            vis[v] = src;
            if (!matchs[v] || dfs(matchs[v], src)) {
                matchs[v] = u;
                return true;
            }
        }
    }
    return false;
}

// 主函数调用
for (int i = 1; i <= mapsiz; i++) 
    ans += dfs(i, i);
```

---
处理用时：81.77秒
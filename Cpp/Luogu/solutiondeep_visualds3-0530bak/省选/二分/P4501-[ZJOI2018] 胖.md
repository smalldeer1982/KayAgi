# 题目信息

# [ZJOI2018] 胖

## 题目背景

Cedyks 是九条可怜的好朋友（可能这场比赛公开以后就不是了），也是这题的主人公。

## 题目描述

Cedyks 是一个富有的男孩子。他住在著名的 The Place（宫殿）中。

Cedyks 是一个努力的男孩子。他每天都做着不一样的题来锻炼他的 The Salt（灵魂）。

这天，他打算在他的宫殿外围修筑一道城墙，城墙上有 $n$ 座瞭望塔。你可以把城墙看做一条线段，瞭望塔是线段上的 $n$ 个点，其中 $1$ 和 $n$ 分别为城墙的两个端点。其中第 $i$ 座瞭望塔和第 $i + 1$ 座瞭望塔的距离为 $w_i$，他们之间的道路是双向的。

城墙很快就修建好了，现在 Cedyks 开始计划修筑他的宫殿到城墙的道路。因为这题的题目名称，Cedyks 打算用他的宫殿到每一个瞭望塔的最短道路之和来衡量一个修建计划。

现在 Cedyks 手上有 $m$ 个设计方案，第 $k$ 个设计方案会在宫殿和瞭望塔之间修建 $T_k$ 条双向道路，第 $i$ 条道路连接着瞭望塔 $a_i$，长度为 $l_i$。

计算到每一个瞭望塔的最短路之和是一个繁重的工程，本来 Cedyks 想用广为流传的 SPFA 算法来求解，但是因为他的 butter（缓冲区）实在是太小了，他只能转而用原始的贝尔福特曼算法来计算，算法的流程大概如下：

1. 定义宫殿是 $0$ 号点，第 $i$ 个瞭望塔是 $i$ 号点，双向边 $(u_i, v_i, l_i)$ 为一条连接 $u_i$ 和 $v_i$ 的双向道路。令 $d$ 为距离数组，最开始 $d_0 = 0, d_i = 10^{18}(i ∈ [1, n])$。
2. 令辅助数组 $c = d$。依次对于每一条边 $(u_i, v_i,w_i)$ 进行增广，$c_{u_i} = \min(c_{u_i} , d_{v_i} + w_i)$，$c_{v_i} = \min(c_{v_i} , d_{u_i} + w_i)$。
3. 令 $t$ 为 $c$ 和 $d$ 中不一样的位置个数，即令 $S = \{i|c_i≠d_i\}$，则 $t = |S|$。若 $t = 0$，说明 $d$ 就是最终的最短路，算法结束。否则令 $d = c$，回到第二步。

因为需要计算的设计方案实在是太多了，所以 Cedyks 雇佣了一些人来帮他进行计算。为了避免这些人用捏造出来的数据偷懒，他定义一个设计方案的校验值为在这个方案上运行贝尔福特曼算法每一次进入第三步 $t$ 的和。他会让好几个雇佣来的人计算同样的设计方案，并比对每一个人给出的校验值。

你是 Cedyks 雇佣来的苦力之一，聪明的你发现在这个情形下计算最短路的长度的和是一件非常简单的事情。但是寄人篱下不得不低头，你不得不再计算出每一个方案的校验值来交差。

## 说明/提示

### 样例解释

对于第一个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,10^{18},2,10^{18},10^{18},10^{18}] \rightarrow$ $[0,4,2,5,10^{18},10^{18}] \rightarrow [0,4,2,5,6,10^{18}] \rightarrow [0,4,2,5,6,10]$。

因此校验值为 $1+2+1+1=5$。

对于第二个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,1,10^{18},10^{18},10,10^{18}] \rightarrow$ $[0,1,3,11,10,14] \rightarrow [0,1,3,6,10,14] \rightarrow [0,1,3,6,7,14] \rightarrow [0,1,3,6,7,11]$。

因此校验值为 $2+3+1+1+1=8$。

对于第三个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,1,10^{18},1,10^{18},1] \rightarrow [0,1,3,1,2,1]$。

因此校验值为 $3+1+1=5$。

对于第四个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,10,100,10^{18},10^{18},1] \rightarrow$ $[0,10,12,103,5,1] \rightarrow [0,10,12,6,5,1] \rightarrow [0,10,9,5,1]$。

因此校验值为 $3+3+1+1=8$。

对于第五个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,1,1,1,1,1]$

因此校验值为 $5$。

### 数据范围

测试点|$n$|$m$|$K$|其他约定
-|-|-|-|-
1,2|$\le 1000$|$\le 1000$|$\le 100$|无
3,4|$\le 2 \times 10^5$|$\le 2 \times 10^5$|$\le 100$|无
5,6|$\le 2 \times 10^5$|$\le 2 \times 10^5$|$\le 2 \times 10^5$|$1 \le w_i,l_i \le 50$
7,8,9,10|$\le 2 \times 10^5$|$\le 2 \times 10^5$|$\le 2 \times 10^5$|无


对于 $100\%$ 的数据，保证每个设计方案 $a_i$ 两两不同且 $1\le a_i\le n$。  
对于 $100\%$ 的数据，保证 $1\le w_i,l_i\le 10^9,1\le\sum K\le 2\times 10^5$。

感谢 @Xeonacid 提供题面

## 样例 #1

### 输入

```
5 5
2 3 1 4
1 2 2
2 1 1 4 10
3 1 1 3 1 5 1
3 1 10 2 100 5 1
5 1 1 2 1 3 1 4 1 5 1```

### 输出

```
5
8
5
8
5```

# AI分析结果



**唯一算法分类**：二分

---

**综合分析与结论**  
本题的核心在于利用二分法确定每个新增道路点的影响区间。通过预处理前缀和数组及构建ST表，快速判断区间内是否存在更优路径，从而高效计算校验值。关键难点在于正确设置二分条件，处理边界情况及距离相等时的优先级。题解普遍采用ST表而非线段树以优化效率，通过离散化处理将复杂度控制在$O(n \log^2 n)$。

**二分过程可视化设计**：
- **区间移动**：以动态颜色标记当前检查的`mid`点及对应查询区间，展示`left`和`right`的收缩过程。
- **高亮变量**：当前`mid`、`left`、`right`用不同颜色标注，比较结果以颜色反馈（绿色满足条件，红色不满足）。
- **退出条件**：当`left > right`时停止循环，高亮最终确定的端点。

**复古游戏化动画**：
- **像素风格**：使用8位色块表示区间，Canvas绘制网格，每次二分更新时像素块闪烁。
- **音效触发**：移动`mid`时播放电子音效，找到端点时播放胜利音效，失败则低沉音效。
- **AI自动演示**：自动执行二分步骤，用户可暂停观察中间状态。

---

**题解清单 (≥4星)**  
1. **Ameyax (4.5星)**  
   - 亮点：ST表预处理+手写二分，处理离散化优化查询效率，代码结构清晰。  
   - 关键代码片段：  
     ```cpp
     bool check1(int p, int x) {
         // 检查左端点条件，利用ST表查询区间最小值
         ll t1 = query(1, x - d, x) + dis[x];
         ll t2 = query(2, x, p-1) - dis[x];
         return t1 > now && t2 > now;
     }
     ```
2. **Labelray (4星)**  
   - 亮点：分左右ST表处理，逻辑分层明确，代码可读性高。  
   - 关键代码片段：  
     ```cpp
     bool checkl(int p, int x) {
         // 左区间查询，优先处理左侧相同距离
         ll qwq1 = ST::query1(2*x-p+1, x) + dis[x];
         return qwq1 > mst && qwq2 > mst;
     }
     ```

---

**最优思路或技巧提炼**  
1. **预处理与离散化**：将新增点按位置排序后离散化，构建ST表查询区间极值，避免重复计算。
2. **二分条件设计**：通过数学变形将路径比较转化为区间最小值查询，例如左侧路径比较公式为$l_i - dis_{a_i}$，右侧为$l_i + dis_{a_i}$。
3. **边界处理**：在二分中处理区间越界（如`max(1, mid-d)`），确保查询有效。
4. **优先级处理**：距离相同时，规定左侧点优先更新，避免重复计数。

---

**同类型题或类似算法套路**  
- **二分答案**：如判断某个条件的最小/最大值（洛谷P1083）。
- **区间极值查询**：利用ST表或线段树维护区间信息（洛谷P3865）。
- **连续区间判定**：如寻找最长合法子数组，通过二分+预处理快速判断。

**推荐题目**  
1. P1083 借教室（二分答案+差分）
2. P3382 线段树/ST表维护区间极值
3. P4344 环形数组（二分+区间操作）

---

**个人心得摘录**  
- **调试教训**：初始使用线段树导致超时，改用ST表后效率显著提升（Ameyax题解）。
- **顿悟点**：将路径比较公式拆分为两个方向预处理，简化查询逻辑（Labelray题解）。

---

**核心二分代码片段**  
```cpp
// 计算左边界
int solve1(int p) {
    int l=1, r=p, ans=p;
    while(l <= r) {
        int mid = (l+r)>>1;
        if(check1(p, mid)) r=mid-1, ans=mid;
        else l=mid+1;
    }
    return ans;
}
// 计算右边界
int solve2(int p) {
    int l=p, r=n, ans=p;
    while(l <= r) {
        int mid = (l+r)>>1;
        if(check2(p, mid)) l=mid+1, ans=mid;
        else r=mid-1;
    }
    return ans;
}
```

---

**可视化与动画方案**  
- **Canvas网格**：横向表示瞭望塔位置，不同颜色块表示被不同点更新的区间。
- **步进控制**：用户可调整动画速度，单步执行观察二分过程。
- **音效设计**：每次二分移动播放“哔”声，确定端点后播放“叮”声，错误路径播放“嗡”声。
- **自动演示**：模拟AI自动执行二分，展示区间收缩及最终结果。

---
处理用时：82.74秒
# 题目信息

# [TJOI2018] 智力竞赛

## 题目描述

小豆报名参加智力竞赛，他带上了 $n$ 个好朋友作为亲友团一块来参加比赛。比赛规则如下：

一共有 $m$ 道题目，每个人都有 $1$ 次答题机会，每次答题为选择一道题目回答，在回答正确后，可以继续回答这个题目的后续题目，直到答错题目或者没有后续题目。

每个问题都会有一个价值，比赛最后参赛选手获得的奖励价值等价于该选手和他的亲友团没有回答的问题中的最低价值。

我们现在知道小豆和他的亲友团实力非常强，能够做出这次竞赛中的所有题目。

小豆想知道在知道题目和后续题目的条件下，他最大能获得的价值是多少？

## 说明/提示

对于 $10\%$ 的数据，有 $1<n,m\leq10$。

对于 $20\%$ 的数据，有 $1<n,m\leq100$。

对于 $100\%$ 的数据，有 $1<n\leq50,1<m\leq500,v_i\leq10^9,k_i,a_{i,j}\leq m$。

## 样例 #1

### 输入

```
1 3
1 0
2 1 3
3 0```

### 输出

```
AK```

## 样例 #2

### 输入

```
1 6
1 2 2 3
2 1 4
3 1 4
4 1 6
5 0
6 0```

### 输出

```
5```

# AI分析结果



## 算法分类  
二分

---

## 综合分析与结论  
本题核心是二分答案框架下的 DAG 最小路径覆盖问题。关键思路如下：

### 二分逻辑
1. **搜索区间**：以问题价值为区间，left=最小价值，right=最大价值  
2. **判断条件**：检查能否用 n+1 条链覆盖所有价值 ≤ mid 的点  
3. **收缩策略**：若可覆盖则尝试增大 mid（左移右边界），否则缩小 mid（右移左边界）  
4. **边界处理**：当无法覆盖时，取最后一次成功的 mid 作为答案

### 解决难点
1. **可相交路径覆盖**：通过 Floyd 传递闭包预处理可达性，转化为不可交路径覆盖  
2. **动态图构造**：每次二分时仅保留价值 ≤ mid 的点，避免重复建图  
3. **效率优化**：预处理传递闭包后，匈牙利算法的时间戳优化

---

## 题解清单（评分≥4星）  
1. **Mychael（5星）**  
   - 完整实现二分框架与匈牙利算法  
   - 预处理传递闭包后动态调整图结构  
   - 代码清晰，使用时间戳优化匹配过程  
   - 亮点：离散化处理价值，避免大范围二分

2. **elijahqi（4星）**  
   - 简洁的二分图匹配实现  
   - 动态计算最小路径覆盖数  
   - 优点：代码结构紧凑，适合快速理解核心逻辑

3. **BigSmall_En（4星）**  
   - 全局 mid 变量优化图构造  
   - 时间戳技巧加速匈牙利算法  
   - 亮点：避免重复建图，提升运行效率

---

## 核心代码实现  
```cpp
// 二分框架
int l = 1, r = tot, ans = 0;
while(l <= r){
    int mid = (l + r) >> 1;
    if(check(mid)){
        ans = mid;
        l = mid + 1;
    }else{
        r = mid - 1;
    }
}

// check函数核心逻辑
bool check(int mid){
    int cnt = 0;
    // 构造当前mid对应的子图
    REP(i,n) REP(j,n)
        g[i][j] = (val[i]<mid && val[j]<mid) ? G[i][j] : 0;
    
    // 匈牙利算法求最大匹配
    memset(lk,0,sizeof(lk));
    REP(i,n) if(val[i]<mid){
        memset(vis,0,sizeof(vis));
        if(find(i)) cnt++;
    }
    return (总点数 - cnt) <= m+1; 
}

// Floyd传递闭包预处理
REP(k,n) REP(i,n) REP(j,n)
    G[i][j] |= G[i][k] & G[k][j];
```

---

## 同类型题推荐  
1. P2764 最小路径覆盖问题（DAG 路径覆盖模板）  
2. P4215 踩气球（二分答案+区间覆盖）  
3. P2898 [USACO08JAN]Haybale Guessing（二分答案+约束检查）

---

## 可视化设计  
### 动画方案  
1. **区间可视化**：用滑动条表示当前二分区间 [left, right]，mid 指针高亮显示  
2. **图结构变化**：以颜色区分价值 ≤ mid 的节点（绿色）和排除节点（灰色）  
3. **匹配过程**：动态显示匈牙利算法的增广路径查找过程  
4. **统计面板**：实时显示当前覆盖点数和所需链数  

### 像素风格实现  
```javascript
// Canvas绘制二分区间示例
function drawRange(ctx, l, r, mid){
    const WIDTH = 400, HEIGHT = 50;
    ctx.fillStyle = '#2C3E50';
    ctx.fillRect(0,0,WIDTH,HEIGHT);
    
    // 绘制当前区间
    ctx.fillStyle = '#E74C3C';
    ctx.fillRect(l*WIDTH/maxVal, 10, (r-l)*WIDTH/maxVal, 30);
    
    // 绘制mid指针
    ctx.fillStyle = '#2ECC71';
    ctx.beginPath();
    ctx.arc(mid*WIDTH/maxVal, 25, 8, 0, Math.PI*2);
    ctx.fill();
}

// 音效配置
const audio = {
    update: new Audio('blip.wav'),
    success: new Audio('success.wav'),
    fail: new Audio('fail.wav')
};
```

---

## 个人心得  
1. **离散化陷阱**：直接按原值二分可能超时，需先对价值排序去重  
2. **可达性预处理**：Floyd 必须预处理全部节点的可达性，不能动态计算  
3. **时间戳优化**：匈牙利算法的 vis 数组使用时间戳而非每次 memset，提升效率

---
处理用时：56.51秒
# 题目信息

# [CTSC2018] 混合果汁

## 题目描述

小 R 热衷于做黑暗料理，尤其是混合果汁。

商店里有 $n$ 种果汁，编号为 $0,1,\cdots,n-1$ 。$i$ 号果汁的美味度是 $d_i$，每升价格为 $p_i$。小 R 在制作混合果汁时，还有一些特殊的规定，即在一瓶混合果汁中，$i$ 号果汁最多只能添加 $l_i$ 升。

现在有 $m$ 个小朋友过来找小 R 要混合果汁喝，他们都希望小 R 用商店里的果汁制作成一瓶混合果汁。其中，第 $j$ 个小朋友希望他得到的混合果汁总价格不大于 $g_j$，体积不小于 $L_j$。在上述这些限制条件下，小朋友们还希望混合果汁的美味度尽可能地高，一瓶混合果汁的美味度等于所有参与混合的果汁的美味度的最小值。请你计算每个小朋友能喝到的最美味的混合果汁的美味度。

## 说明/提示

对于所有的测试数据，保证 $n, m \le 100000$，$1 \le d_i,p_i,l_i \le 10^5$，$1 \le g_j, L_j \le 10^{18}$。

测试点编号|$n=$|$m=$|其他限制
-|-|-|-
$1,2,3$|$10$|$10$|无
$4,5,6$|$500$|$500$|无
$7,8,9$|$5000$|$5000$|无
$10,11,12$|$100000$|$100000$|$p_i=1$
$13,14,15$|$100000$|$100000$|$l_i=1$
$16,17,18,19,20$|$100000$|$100000$|无

## 样例 #1

### 输入

```
3 4
1 3 5
2 1 3
3 2 5
6 3
5 3
10 10
20 10```

### 输出

```
3
2
-1
1```

# AI分析结果



# 【算法分类】  
二分

---

# 【题解思路、算法要点与解决难点】  
**核心思路**：  
所有题解均采用**二分答案**框架，通过检查某个美味度阈值能否满足条件来缩小范围。关键难点在于如何高效验证候选答案的可行性。

**关键算法对比**：  
1. **可持久化线段树（主席树）**  
   - 预处理：按美味度从大到小排序，对每个位置建立版本线段树，维护价格区间内的体积和总价。  
   - 验证：查询时二分美味度，在对应版本线段树上贪心取最小价格果汁，计算总价是否≤预算。  
   - 优势：时间复杂度稳定为O(n log²n)，适合大数据规模。  

2. **整体二分 + 树状数组/线段树**  
   - 动态维护：随着二分过程调整数据结构中果汁集合，仅保留d≥mid的果汁。  
   - 验证：利用树状数组维护价格的前缀和，快速计算满足体积的最小费用。  
   - 优势：减少重复计算，但实现较复杂，需注意区间调整顺序。  

**解决难点**：  
- **快速验证**：直接遍历果汁会超时，需通过数据结构将验证复杂度优化至O(logn)。  
- **离散化处理**：部分题解需对价格离散化以适应树状数组/线段树的范围。  
- **边界条件**：如总体积不足、剩余金额无法完全购买某价格果汁时的处理。  

---

# 【题解评分】  
1. **Kelin（5星）**  
   - 思路清晰，代码简洁，主席树实现高效。  
   - 预处理排序与可持久化处理巧妙，边界处理完善（如无解情况）。  
2. **kouylan（4星）**  
   - 结构清晰，注释详细，适合新手理解主席树应用。  
   - 未处理离散化，直接使用价格范围，可能浪费空间但代码更简洁。  
3. **Marser（4星）**  
   - 整体二分结合线段树，动态调整数据结构内容，减少内存占用。  
   - 实现稍复杂，但提供另一种高效思路。  

---

# 【最优思路提炼】  
**二分答案 + 可持久化线段树**  
1. **预处理排序**：将果汁按美味度降序排序，确保每次二分时候选果汁集合连续。  
2. **主席树构建**：对每个位置i，建立维护前i种果汁的线段树，节点记录价格区间[l,r]内的总容量和总费用。  
3. **查询验证**：  
   - 确定候选d后，在对应线段树上贪心选择价格最小的果汁，计算能否满足体积L且费用≤G。  
   - 通过线段树二分快速累加最小费用，避免遍历所有果汁。  

**关键代码片段**（Kelin题解核心）：  
```cpp
bool check(int mid, int G, int L) {
    // 在root[mid]版本线段树中查询
    if (总容量 < L) return false;
    ll cost = query(root[mid], 1, MAXP, L); 
    return cost <= G;
}

void solve() {
    sort(a+1, a+n+1, cmp); // 按d降序排序
    for (int i=1; i<=n; i++) 
        update(T[i], T[i-1], a[i].p, a[i].l); // 构建主席树
    while (m--) {
        int L=1, R=n, ans=-1;
        while (L <= R) {
            int mid = (L+R)/2;
            if (check(mid, G, L)) ans=a[mid].d, L=mid+1;
            else R=mid-1;
        }
        printf("%d\n", ans);
    }
}
```

---

# 【同类型题与算法套路】  
**二分答案通用模式**：  
1. 确定答案单调性（如本题d越小可选果汁越多）。  
2. 设计check函数验证候选答案，通常需结合贪心或数据结构优化。  
3. 典型题：  
   - P1182 数列分段（二分最大段和，贪心验证）  
   - P2678 跳石头（二分最小距离，模拟移石）  
   - P1314 聪明的质监员（二分参数，前缀和验证）  

---

# 【可视化与算法演示】  
**动画设计**：  
1. **二分区间展示**：  
   - 初始区间[0, max_d]，动态显示mid计算与区间收缩。  
   - 高亮当前mid对应的d值，标记为待验证候选。  
2. **线段树查询过程**：  
   - 分层显示线段树节点，颜色标记路径（如绿色表示选中左子树，红色转向右子树）。  
   - 实时更新累计体积和费用，对比L和G的阈值。  
3. **复古像素风格**：  
   - 使用8-bit风格网格表示价格区间，方块高度表示库存量。  
   - 音效：选择节点时播放“哔”声，验证成功时播放上升音阶。  

**交互功能**：  
- **步进控制**：允许单步执行二分循环，观察mid变化与验证结果。  
- **自动演示**：AI自动执行二分，用不同颜色区分搜索区间。  

---

# 【推荐相似题目】  
1. **P1182 数列分段 Section II**  
2. **P2678 跳石头**  
3. **P1314 聪明的质监员**  

---

# 【个人心得摘录】  
- **Kewth**提到“价格排序后是连续区间”，启发预处理排序简化数据结构设计。  
- **Fading**在调试中发现未处理离散化导致WA，强调边界检查的重要性。  
- **Adolfo_North**通过整体二分分流询问，减少冗余计算，提升效率。  

---

**完整代码示例（Kelin题解）**：  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+5, M=1e5;

struct Juice { int d,p,l; } a[N];
int n,m,root[N],cnt;
struct Node { int l,r; ll sum, cost; } tr[N*20];

bool cmp(Juice a, Juice b) { return a.d > b.d; }

void update(int &u, int pre, int l, int r, int p, int l_val) {
    u = ++cnt; tr[u] = tr[pre];
    tr[u].sum += l_val;
    tr[u].cost += (ll)p * l_val;
    if (l == r) return;
    int mid = (l+r)>>1;
    if (p <= mid) update(tr[u].l, tr[pre].l, l, mid, p, l_val);
    else update(tr[u].r, tr[pre].r, mid+1, r, p, l_val);
}

ll query(int u, int l, int r, ll need) {
    if (l == r) return (ll)l * need;
    int mid = (l+r)>>1;
    if (tr[tr[u].l].sum >= need) return query(tr[u].l, l, mid, need);
    return tr[tr[u].l].cost + query(tr[u].r, mid+1, r, need - tr[tr[u].l].sum);
}

int main() {
    scanf("%d%d", &n, &m);
    for(int i=1; i<=n; i++) scanf("%d%d%d", &a[i].d, &a[i].p, &a[i].l);
    sort(a+1, a+n+1, cmp);
    for(int i=1; i<=n; i++) 
        update(root[i], root[i-1], 1, M, a[i].p, a[i].l);

    while(m--) {
        ll G, L; scanf("%lld%lld", &G, &L);
        int l=1, r=n, ans=-1;
        while(l <= r) {
            int mid = (l+r)>>1;
            if (tr[root[mid]].sum >= L && query(root[mid],1,M,L) <= G) 
                ans = a[mid].d, l = mid+1;
            else r = mid-1;
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

---
处理用时：87.35秒
# 题目信息

# PION后缀自动机

## 题目背景

NOIP2018原创模拟题T6

NOIP2018原创模拟赛DAY2 T3

NOIP DAY1 T3+ or DAY2 T3 难度

鉴于 NOIP2017 DAY2 T3 的难度，就有了这道题。**然而这道题考察的知识并不是后缀自动机**

## 题目描述

小P是一个技术高超的程序员，他开发了一套自己的操作系统，称为PION系统，该系统与Windows和Linux有很大不同，目前他正在测试该系统。

PION系统与Windows系统最大的不同在于文件的储存与操作，POIN的文件夹没有父子之分。我们知道，在Windows系统中，可以在文件夹里新建子文件夹。但是，PION系统文件夹不分父子关系，**但是部分文件夹之间可以互相直接访问，我们称这种关系为互访关系，而且，对于一个有$n$个文件夹的系统来说，这种互访关系有$n-1$个，且保证所有文件夹均可以通过互访关系而互相访问。也就是说：我们可以把Windows中的文件夹的集合看作一棵有根树，而把PION系统中的文件夹集合看作为无根树。**

在PION系统中，每个文件夹都可以储存文件，和Windows一样，文件名包含后缀名。

现在小P正在构思一种可以对文件夹中文件后缀进行方便操作的交互式程序dmc，他也将其称为**PION后缀自动机**。由于他太忙了，所以他希望你帮他实现**部分功能**。

他希望你帮他实现三个功能：

1.计算两个文件夹之间的距离。我们定义：文件夹之间的距离为其中一个文件夹通过互访达到另一个文件夹最少互访次数。比如：同一个文件夹距离为0，两个有互访关系的文件夹距离为1。

2.计算两个文件夹路径之间（包含这两个文件夹）的文件夹中的文件的后缀名为A的文件数量，**其中A是一个小写字符串。提示：我们可以把PION文件夹之间的路径理解为树中两节点之间的路径。**

3.删除两个文件夹路径之间（包含这两个文件夹）的文件夹中的文件的后缀名为A的文件，并统计被删除文件的数量。

由于dmc是一个交互系统，所以我们用tab语言描述这三个操作：

```
query /p u v
```

表示操作一，其中 u,v 表示两文件夹的编号

```
query /e u v *.A
```

表示操作二，其中 u,v 表示两文件夹的编号，$'*'$ 为通配符，$'.'$用于分隔文件名与后缀，**A是一个小写字符串**。

```
del /e u v *.A
```

表示操作三， $u,v, *.A$ 意义与操作二相同。

**如果没有看懂题目请结合样例及样例解释来理解。**

最后，这个困难的任务就交给你了。

## 说明/提示

**样例一解释：**

![T6](https://cdn.luogu.com.cn/upload/pic/34166.png)

如图为样例一大致结构，橙色方框为文件夹，灰色文字表示文件后缀名，红色线条表示文件互访关系。

对于第一个操作：文件夹1到5之间txt文件有3个所以输出3  
对于第二个操作：文件夹1与4距离为2  
对于第三个操作：删除的为文件夹2的文件，txt文件有两个，所以输出2  
对于第四个操作：由于文件夹2的txt文件被删除了，所以1到5之间txt文件只有1个  
对于第五个操作：文件夹3到4之间vbs文件有2个所以输出2

**数据范围：**

30%数据满足：$n,m<=100,k<=3$

50%数据满足：$n,m<=5000,k<=10$

70%数据满足：$n,m<=2 \times 10^4,k<=50$

90%数据满足：$n,m<=5 \times 10^4$

100%数据满足：$n,m<=10^5$，文件总数小于$5 \times 10^5$，文件后缀名为小写字符串且不超过6个字符

其他说明：

1.约50%的数据为完全随机生成

2.数据弱化版：[PION后缀自动机（数据弱化版）](https://www.luogu.org/problemnew/show/U41487)

## 样例 #1

### 输入

```
5 5
1 2
2 4
2 5
1 3
2 cpp c
3 pas txt txt
2 vbs bat
3 vbs cpp pas
4 cpp c pas txt
query /e 1 5 *.txt
query /p 1 4
del /e 2 2 *.txt
query /e 1 5 *.txt
query /e 4 3 *.vbs```

### 输出

```
3
2
2
1
2```

## 样例 #2

### 输入

```
12 7
1 2
1 3
1 4
2 5
2 6
3 7
7 12
8 4
8 9
10 9
11 9
0
2 c c
3 zz c c
0
1 gif
2 png bmp
3 avl avl mpshi
0
4 cpp c pas js
5 a b c d e
0
3 a b c
query /p 11 12
query /e 1 2 *.gif
query /e 6 10 *.c
del /e 2 9 *.c
del /e 3 12 *.c
query /e 5 6 *.gif
query /e 6 1 *.c```

### 输出

```
7
0
4
3
3
1
0```

# AI分析结果



**唯一算法分类**: 无算法分类  

---

### 题解思路、算法要点与解决难点  
**核心思路**:  
所有题解均围绕**树链剖分**展开，将树结构转化为线性结构，通过路径拆分实现高效区间操作。针对多后缀名问题，核心难点是**高效维护路径上的动态数据**。  

**解决方案对比**:  
1. **动态开点线段树**（mrsrz、Loser_Syx）  
   - 每个后缀名对应一棵动态开点线段树  
   - 树剖后通过跳链查询/修改路径区间  
   - 空间优化：动态开点避免预分配所有后缀名的线段树  
   - 哈希映射：将字符串转为数值便于离散化  

2. **平衡树维护dfn序**（hzjnsy）  
   - 每个后缀名用`pbds::tree`维护有序dfn序列  
   - 查询时统计区间内元素数量  
   - 删除时暴力删除区间内的平衡树节点  

3. **链表+树剖变形**（Voldermod）  
   - 链表存储每个节点的后缀信息  
   - 树剖后对路径分段排序+二分统计  
   - 实现复杂度高，适合特定数据分布  

**关键优化**:  
- 字符串哈希：利用短后缀特性（≤6字符），转为27进制数  
- 路径拆分：树剖将路径分解为若干重链，每段重链对应线段树区间操作  

---

### 题解评分（≥4星）  
1. **mrsrz（4.5星）**  
   - 思路清晰，代码简洁  
   - 动态开点线段树高效处理多后缀名  
   - 哈希与离散化实现优雅  

2. **hzjnsy（4星）**  
   - 提供两种方法对比，扩展性强  
   - 平衡树实现节省空间  
   - 代码可读性较好，但删除操作暴力  

3. **Loser_Syx（4星）**  
   - 完整动态开点线段树实现  
   - 包含详细注释与边界处理  
   - 代码风格统一，适合学习  

---

### 最优思路或技巧提炼  
1. **树链剖分标准化处理**  
   - 预处理`dep`, `fa`, `top`, `dfn`等关键参数  
   - 跳链时统一处理路径区间，确保复杂度为`O(log n)`  

2. **动态开点线段树设计**  
   - 每个后缀名独立线段树根节点  
   - 插入/删除时动态创建节点，避免内存浪费  

3. **字符串快速哈希**  
   ```cpp  
   LL Hx(char* s, int n) {  
       LL ret = 0, x = 1;  
       for (int i=2; i<n; ++i, x*=27)  
           ret += (s[i]-'a'+1) * x;  
       return ret;  
   }  
   ```  

---

### 同类型题或类似算法套路  
1. **树链剖分模板题**（P3384）  
2. **树上路径统计与修改**（P2146 软件包管理器）  
3. **动态开点线段树应用**（P3960 列队）  

---

### 推荐相似洛谷题目  
1. P3384（树链剖分模板）  
2. P5838（树上路径统计）  
3. P7735（跳链查询与修改）  

---

### 可视化与算法演示  
**动画设计**:  
1. **树结构展示**:  
   - 节点按dfn序线性排列，不同重链用颜色区分  
   - 路径查询时，高亮当前处理的重链区间  

2. **线段树操作演示**:  
   - 动态创建线段树节点，显示插入/删除过程  
   - 区间查询时，用不同颜色标记覆盖的线段树节点  

3. **复古像素风格**:  
   - 使用16色调色板，树结构以网格形式呈现  
   - 每次跳链时播放8-bit音效，区间更新时显示像素闪烁  

**交互功能**:  
- **步进控制**: 单步执行跳链与线段树操作  
- **速度调节**: 调整动画播放速度（0.5x~4x）  
- **模式切换**: 对比动态线段树与平衡树实现差异  

---

### 核心代码片段（mrsrz题解）  
```cpp  
// 树链剖分预处理  
void dfs(int now) {  
    sz[now] = 1;  
    for (int to : G[now])  
        if (!dep[to]) {  
            dep[to] = dep[now] + 1;  
            fa[to] = now;  
            dfs(to);  
            sz[now] += sz[to];  
            if (sz[to] > sz[son[now]]) son[now] = to;  
        }  
}  

// 路径查询（线段树）  
int query(int o, int x, int y) {  
    int ret = 0;  
    while (top[x] != top[y]) {  
        if (dep[top[x]] > dep[top[y]]) {  
            ret += query(o, 1, n, dfn[top[x]], dfn[x]);  
            x = fa[top[x]];  
        } else {  
            ret += query(o, 1, n, dfn[top[y]], dfn[y]);  
            y = fa[top[y]];  
        }  
    }  
    if (dep[x] < dep[y]) ret += query(o, 1, n, dfn[x], dfn[y]);  
    else ret += query(o, 1, n, dfn[y], dfn[x]);  
    return ret;  
}  
```

---
处理用时：70.26秒
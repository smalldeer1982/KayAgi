# 题目信息

# 忘情

## 题目背景

 “为什么要离开我！”

 “因为你没玩儿转！”

 “我玩儿转了！”

 “那好，你现在就给我维护这么一个式子！”

 “为什么要出这么毒瘤的东西。”

 “为了恶心你。”

 “......”

$…………………………….$


## 题目描述

你的 $npy$ 为了恶心你，特地请了四位大神和一个辣鸡！

 $\rm hdxrie$ 说：“我们得求和。”于是有了 $\sum\limits_{i=1}^{n}x_i $ 。

 $\rm Imagine$ 说：“我们得有平均数。”于是有了 $\bar x $ 。

 $\rm TimeTraveller$ 说：“我们得有加减乘除。”于是有了一些恶心的组合。

 $\rm Althen·Way·Satan$ 说：“我们还得有平方。”于是我们将它平方。

最垃圾的 $\rm ZredXNy$ 说：“那我帮你们整合一下。”

于是，我们得到了这么一个式子 $:$

$$\frac{\left((\sum\limits_{i=1}^{n}x_i×\bar x)+\bar x\right)^2}{\bar x^2}$$


我们定义一段序列的值为这个，其中  $n$为此序列的元素个数。

我们给定一段长度为 $n$ 的序列,现在要求将它分成 $m$ 段，要求每一段的值的总和最小，求出这个最小值。


## 说明/提示

- 对于 $30 \%$ 的数据，$m≤n≤500$；

- 另有 $20 \%$ 的数据，保证 $m=2$；

- 对于 $100 \%$ 的数据，$m≤n≤100000$，$1≤x_i≤1000$。


## 样例 #1

### 输入

```
3 2
1 2 3
```

### 输出

```
32```

## 样例 #2

### 输入

```
10 3
1 2 3 4 5 6 7 8 9 10
```

### 输出

```
1140```

# AI分析结果



### 算法分类
**二分**

---

### 题解思路与难点分析

#### 核心思路
1. **公式化简**：题目给出的复杂公式可化简为 `(sum+1)^2`，其中 sum 为当前段的和，转化为分段代价。
2. **WQS 二分**：通过二分额外代价 `mid`，将问题转换为无段数限制的 DP，利用凸函数性质调整分段数。
3. **斜率优化**：维护单调队列优化 DP 转移，将时间复杂度从 O(n²) 降至 O(n)。

#### 二分关键点
- **搜索区间**：初始区间设为 `[0, 1e18]`，覆盖可能的额外代价范围。
- **收缩条件**：若当前 `mid` 对应的分段数 `≥m`，说明需增大 `mid`（左移右边界）；否则减小 `mid`。
- **边界处理**：最终答案需减去 `m * mid` 以抵消二分引入的额外代价。

#### 解决难点
- **凸函数证明**：通过数学推导证明 `f(k)`（分 k 段的最小代价）是下凸函数，确保 WQS 二分适用。
- **斜率优化维护**：用单调队列维护转移点，确保队列中斜率单调递增，快速排除无效决策。

---

### 题解评分（≥4星）

1. **JK_LOVER（5星）**  
   - 思路清晰，详细推导 WQS 二分与斜率优化的结合。
   - 代码简洁，包含注释与示例，可读性高。
   - 提供多道类似题目，便于举一反三。

2. **gxy001（4星）**  
   - 强调斜率优化中的等于号处理，避免错误转移。
   - 代码实现高效，通过严格的条件判断确保正确性。

3. **Register（4星）**  
   - 代码结构清晰，逻辑紧凑，适合快速理解核心实现。
   - 明确二分调整方向，避免边界问题。

---

### 最优思路提炼

1. **WQS 二分框架**  
   ```cpp
   ll l = 0, r = 1e18;
   while (l <= r) {
       ll mid = (l + r) >> 1;
       check(mid) ? l = mid + 1 : r = mid - 1;
   }
   ```
   - **关键点**：通过 `check` 函数判断当前 `mid` 是否允许分段数 ≥m，调整区间。

2. **斜率优化 DP**  
   ```cpp
   for (int i = 1; i <= n; i++) {
       while (head < tail && slope(q[head], q[head+1]) < 2*s[i]) head++;
       int j = q[head];
       f[i] = f[j] + (s[i]-s[j]+1)^2 + mid;
       while (head < tail && slope(q[tail-1], q[tail]) > slope(q[tail], i)) tail--;
       q[++tail] = i;
   }
   ```
   - **核心**：维护单调队列，快速找到最优转移点 `j`，避免遍历所有可能。

---

### 类似题目推荐
1. **P4767 [IOI2000] 邮局**  
   WQS 二分 + 四边形优化经典题。
2. **CF739E Gosha is hunting**  
   双限制 WQS 二分应用。
3. **P6246 [IOI2000] 邮局 加强版**  
   进一步练习斜率优化与二分结合。

---

### 可视化设计（二分过程）

1. **动画方案**  
   - **区间表示**：用滑动条展示 `[left, right]`，高亮当前 `mid`。
   - **状态更新**：每次二分后，以颜色区分新区间（绿色为有效，红色为排除）。
   - **凸函数曲线**：绘制 `f(k)` 的凸包，动态显示切线斜率 `mid` 的调整。

2. **复古像素风格**  
   - **8位音效**：移动 `mid` 时播放“哔”声，找到答案时播放胜利音效。
   - **Canvas 网格**：将数值映射到像素网格，每次更新填充对应位置。

3. **自动演示模式**  
   - **AI 控制**：自动执行二分步骤，用户可调节速度或暂停观察。
   - **积分系统**：正确收缩区间得分，错误操作扣分，增强互动。

---

### 代码片段（核心二分逻辑）

```cpp
bool check(ll mid) {
    int l = 1, r = 1; q[1] = 0;
    for (int i = 1; i <= n; i++) {
        while (l < r && slope(q[l], q[l+1]) < 2*(s[i]+1)) l++;
        int j = q[l];
        f[i] = f[j] + (s[i]-s[j]+1)*(s[i]-s[j]+1) + mid;
        cnt[i] = cnt[j] + 1;
        while (l < r && slope(q[r-1], q[r]) >= slope(q[r], i)) r--;
        q[++r] = i;
    }
    return cnt[n] >= m;
}
```

**说明**：通过单调队列维护候选转移点，快速计算分段数与代价。

---

### 总结
本题通过 WQS 二分将分段限制转化为凸函数切点问题，结合斜率优化实现高效 DP。关键在于正确维护二分条件与单调队列，确保算法正确性与效率。

---
处理用时：67.59秒
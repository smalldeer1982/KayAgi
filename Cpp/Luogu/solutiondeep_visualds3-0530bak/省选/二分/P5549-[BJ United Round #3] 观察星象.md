# 题目信息

# [BJ United Round #3] 观察星象

## 题目描述

EI 在用望远镜观察星星，星空中共有  $n$ 个星星，每个星星观察起来有一个二维直角坐标 $(x,y)$。  

他的望远镜如果定位在 $(x_0,y_0)$ 处，可以看到所有 $(x_0-x)^2 + (y_0-y)^2 \le r^2$ 的星星。  

望远镜的大小 $r$ 是可以调整的，EI 想知道如果他要至少看到 $m$ 个星星，至少需要把 $r$ 设置到多大？

## 说明/提示

| 子任务编号 | $n$ | $m$ | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $\leq 50$ | $\leq n$ | $10$ |
| $2$ | $\leq 200$ | $\leq n$ | $15$ |
| $3$ | $\leq 700$ | $\leq n$ | $15$ |
| $4$ | $\leq 2000$ | $= n$ | $20$ |
| $5$ | $\leq 2000$ | $\leq n$ | $40$ |


对于 $100\%$ 的数据，保证：  
$2 \le m \le n  \le 2000$  
$|x|,|y| \le 10^4$

By：EntropyIncreaser

## 样例 #1

### 输入

```
4 3
0 0
1 1
2 3
3 3```

### 输出

```
1.41421356```

# AI分析结果



## 唯一算法分类
二分

---

## 综合分析与结论

### 核心思路与难点
本题要求找到包含至少 m 个点的最小圆半径。通过二分答案结合极角扫描判定，核心难点在于如何高效验证某个半径的可行性。算法四通过随机化点处理顺序，维护当前最优解，避免不必要的二分，将复杂度优化至期望 O(n² log n + n log n log ε⁻¹)。

### 二分过程解析
1. **搜索区间**：初始 `left=0`，`right` 取所有点对的最大距离。
2. **判定条件**：以当前点 `i` 为圆心，半径 `mid` 是否覆盖至少 `m` 个点。
3. **区间收缩**：若可行，缩小右边界 `right=mid-eps`，否则增大左边界 `left=mid+eps`。
4. **极角扫描**：将其他点到圆心的覆盖范围转化为角度区间，扫描线统计最大覆盖次数。

---

## 题解清单 (≥4星)

### Elegia 的算法四（4.5星）
- **关键亮点**：随机化处理顺序，维护单调栈优化二分次数，理论分析清晰。
- **优化点**：将复杂度从 O(n² log n log ε⁻¹) 优化至期望 O(n² log n + n log n log ε⁻¹)。

### hellowin 的代码实现（4星）
- **关键亮点**：完整实现极角扫描与二分逻辑，结合随机化预处理。
- **代码亮点**：通过 `judge` 函数高效统计覆盖点，实际提交验证效率。

---

## 核心代码实现

### 二分与判定逻辑
```cpp
double ans = INF;
random_shuffle(p, p + n);
for (int i = 0; i < n; i++) {
    if (judge(i, ans) >= m) { // 当前点可能更优才二分
        double L = 0, R = Mdist;
        while (fabs(R - L) > eps) {
            double mid = (L + R) / 2;
            if (judge(i, mid) >= m) 
                R = mid - eps, ans = mid;
            else 
                L = mid + eps;
        }
    }
}
```

### 极角扫描判定
```cpp
int judge(int i, double r) {
    int num = 0;
    for (int j = 0; j < n; j++) {
        if (i == j) continue;
        double d = dist(i, j);
        if (d > 2*r) continue;
        double angle = atan2(p[j].y - p[i].y, p[j].x - p[i].x);
        if (angle < 0) angle += 2*pi;
        double theta = acos(d / (2*r));
        alp[num++] = {angle - theta + 2*pi, 1};
        alp[num++] = {angle + theta + 2*pi, -1};
    }
    sort(alp, alp + num);
    int maxx = 0, cnt = 0;
    for (int j = 0; j < num; j++) {
        cnt += alp[j].flag;
        maxx = max(maxx, cnt);
    }
    return maxx + 1; // 包含圆心自身
}
```

---

## 最优思路提炼
1. **二分答案框架**：将最优解问题转化为判定性问题。
2. **极角区间覆盖**：利用几何性质将点覆盖转化为角度区间扫描。
3. **随机化优化**：通过随机顺序处理点，减少二分次数。
4. **单调栈期望分析**：利用概率期望优化理论复杂度。

---

## 同类型题推荐
1. **P1020 导弹拦截**：二分求最长非升子序列。
2. **P2218 [HAOI2007] 覆盖问题**：二分答案+几何覆盖验证。
3. **P3478 [POI2008] STA-Station**：树形结构中的最优覆盖问题。

---

## 可视化与算法演示设计

### 动画方案
- **Canvas 绘制**：展示所有点、当前圆心、圆及覆盖点。
- **颜色标记**：覆盖点高亮，当前圆用红色边框，历史最优解用虚线。
- **步进控制**：单步执行二分过程，显示 `left`、`right`、`mid` 值。

### 复古像素风格
- **8位调色板**：用 16 色绘制点与圆，搜索区间以像素方块表示。
- **音效设计**：`mid` 更新时播放 8-bit 音效，找到解时播放胜利音效。
- **自动演示**：模拟贪吃蛇 AI 逐步收缩区间，可调节速度。

---

## 个人心得摘录
- **随机化顺序**：避免最坏情况，实际测试中效率显著提升。
- **边界处理**：极角转换时需处理负角度和 2π 周期，避免排序错误。
- **精度控制**：二分终止条件 `eps` 设置需平衡精度与效率。

---
处理用时：282.10秒
# 题目信息

# 「ACOI2020」惊吓路径

## 题目背景

![T6](https://s2.ax1x.com/2020/01/12/lopZpq.png)

3 年 E 班的同学们赢得了去南方的冲绳小岛的机会，在渚打败了鹰冈之后，他们受杀老师的邀请参加“试胆大会”。

试胆大会在一个黑漆漆的洞窟里面进行。赤羽 業（Akabane Karma）现在和奧田 愛美站在洞窟的门口。突然，業想到了一个事情。。。

## 题目描述

杀老师告诉过他们，洞窟可以近似地看成 $n$ 个点的外向树，因为地形原因，所以一个点到另一个点的边是有方向的，且边的方向都是同向的。这棵树的树根为入度为 $0$ 的点。每个点都有一个惊吓值，给出每个点的惊吓值 $a_i$。

杀老师告诉他们，这个洞穴有很多惊吓路径。如果两个节点 $u,v$ 构成的路径是一条惊吓路径的话，满足以下条件：

- $v$ 一定在 $u$ 的子树中。

- $u, v$ 这条路径上的所有的点的惊吓值的或值 $\geq k$。

走过一条惊吓路径就会收到杀老师的惊喜大礼。杀老师已经提前准备好了惊喜大礼，但是業当然已经知道杀老师有一些下流的意图，更别说惊喜大礼的数量可能不够！杀老师已经承诺有多少条惊吓路径就有多少个惊喜大礼。業已经通过一些神奇的途径知道了杀老师准备的惊喜大礼的个数，现在他想知道有多少条惊吓路径，也就是杀老师最少需要准备惊喜大礼的个数。如果不够，他就会揭穿杀老师的意图。现在業当然想赚，好好捉弄一下杀老师。所以他~~作弊~~提前得到了杀老师的地图，想问这个图里面有多少条惊吓路径？

## 说明/提示

#### 样例解释 #1

![](https://cdn.luogu.com.cn/upload/image_hosting/lqu4ejku.png)

只有两条路径满足条件：

1. $3\to 1\to 2$，这条路径的所有点的惊吓值的或值是 $6\operatorname{or}5\operatorname{or}9=15$。

2. $1 \to 2$，这条路径的所有点的惊吓值的或值是 $5\operatorname{or}9=13$。

------------
#### 数据范围 
**本题采用捆绑测试**。

- Subtask 1（10 points）：$n \leq 5 \times 10^3$，$k \leq 10^5$。    
- Subtask 2（30 points）：对于任意一条边，$v=u+1$，$n \leq 10^6$，$k,a_i \leq 10^9$。     
- Subtask 3（20 points）：$n \leq 10^5$，$k,a_i \leq 10^9$。    
- Subtask 4（40 points）：$n \leq 5 \times 10^5$，$k,a_i \leq 10^9$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$，$1 \leq k,a_i \leq 10^9$。

------------
#### 提示
**第四个子任务中的测试点空间 256MB，其余子任务中的测试点空间 128MB。**

## 样例 #1

### 输入

```
5 10
5 9 6 4 2
3 1
3 4
1 2
1 5
```

### 输出

```
2```

## 样例 #2

### 输入

```
7 5
6 7 4 5 7 8 9
1 2
2 3
2 4
1 5
5 6
5 7
```

### 输出

```
16```

## 样例 #3

### 输入

```
8 5
4 3 2 5 6 7 6 2
1 2
1 5
2 3
2 4
5 6
5 7
6 8
```

### 输出

```
16```

# AI分析结果



## 算法分类
**二分**

---

## 题解思路与难点分析
### 核心思路
1. **或运算单调性**：路径上的或值随着路径延伸**非递减**，因此对每个终点 `v`，只需找到最深的起点 `u` 满足条件，其所有祖先均为合法起点。
2. **倍增优化**：预处理每个节点的 `2^j` 级祖先及路径或值，快速跳转查找满足条件的 `u`。
3. **链的特殊处理**：当树退化为链时，用双指针法维护滑动窗口的或值，实现 `O(n)` 时间与空间。

### 二分算法细节
- **搜索区间**：对于链结构，每个左端点 `u` 的右端点 `v` 可能范围是 `[u, n]`。
- **判断条件**：检查区间 `[u, v]` 的或值是否 `≥k`。
- **区间收缩**：若当前区间或值 `<k`，右移右端点；否则记录合法区间长度并右移左端点。

### 解决难点
- **空间优化**：通过栈动态维护路径或值（LanrTabe 题解），避免存储完整倍增数组。
- **链的高效处理**：双指针法 + 位计数撤销操作（yuzhechuan 题解），避免线段树或 ST 表。

---

## 题解评分（≥4星）
1. **LanrTabe（5星）**
   - **亮点**：用栈动态维护路径或值，空间优化至 `O(n)`，非递归 DFS 避免爆栈。
   - **代码**：`prework` 函数实时计算路径或值，`Calc` 函数结合栈实现高效倍增。
2. **yuzhechuan（4星）**
   - **亮点**：链结构双指针法，`inc/dec` 函数人工模拟或运算，无需预处理。
   - **代码**：滑动窗口维护或值，时间复杂度 `O(n log a)`，空间 `O(1)`。
3. **zhengrunzhe（4星）**
   - **亮点**：针对链结构实现 Splay 二分，随机旋转保持平衡，空间优化到位。
   - **代码**：`query` 函数结合平衡树特性实现区间或值查询。

---

## 最优思路提炼
1. **单调性跳转**：利用或运算的单调性，对每个终点只需找到最深合法起点。
2. **动态维护路径**：通过栈或双指针实时计算路径或值，避免静态预处理的空间开销。
3. **位运算撤销**：链结构下，用 `cnt` 数组记录每位出现次数，快速计算或值变化。

---

## 类似算法题
1. **P3384 树链剖分**：路径处理与区间查询结合。
2. **CF 1624G MinOr Tree**：或运算性质在生成树中的应用。
3. **P2446 大陆争霸**：路径上的最值问题与二分答案结合。

---

## 可视化设计（链结构双指针）
### 动画方案
- **像素网格**：用 Canvas 绘制链结构，节点按顺序排列，区间 `[l, r]` 高亮为绿色。
- **指针移动**：`l` 和 `r` 以红色方块表示，移动时触发 8-bit 音效。
- **或值显示**：当前窗口或值以像素字体显示在顶部，颜色随值变化（红 <k，绿 ≥k）。
- **自动模式**：AI 自动执行双指针移动，按空格键切换手动/自动。

### 关键代码（JS）
```javascript
function visualize() {
    let l = 1, sum = 0, cnt = new Array(30).fill(0);
    for (let r = 1; r <= n; r++) {
        sum |= a[r];
        updateBits(a[r], 1); // 更新位计数
        while (sum >= k) {
            drawHighlight(l, r, 'green');
            playSound('beep');
            sum ^= a[l];
            updateBits(a[l++], -1); // 撤销位贡献
        }
    }
}
```

---

## 个人心得摘录
> **zhengrunzhe**：  
> “链结构下 Splay 的随机旋转看似无厘头，却能通过概率平衡避免退化成链，实属无奈之举。”  
> **LanrTabe**：  
> “手动模拟 DFS 的栈实现，既避免递归爆栈，又完美契合路径或值的动态维护，空间与时间双赢。”  
> **yuzhechuan**：  
> “位计数撤销操作是链结构的灵魂，将 `O(n log n)` 优化至 `O(n)`，充分体现位运算的威力。”

---

## 代码片段（双指针法）
```cpp
void subchain() {
    int oum = 0; // 当前窗口或值
    vector<int> cnt(30, 0); // 位出现次数
    for (int i=1, j=1; i<=n; i++) {
        // 右移左指针并撤销贡献
        while (j < i) {
            oum |= a[j];
            for (int b=0; b<30; b++) 
                if (a[j] >> b & 1) cnt[b]++;
            j++;
        }
        // 右移右指针直到满足条件
        while (j <= n && oum < k) {
            oum |= a[j];
            for (int b=0; b<30; b++)
                if (a[j] >> b & 1) cnt[b]++;
            j++;
        }
        if (oum >= k) ans += n - j + 1;
        // 撤销左指针贡献
        for (int b=0; b<30; b++) 
            if (a[i] >> b & 1 && --cnt[b] == 0)
                oum ^= (1 << b);
    }
}
```

---
处理用时：85.07秒
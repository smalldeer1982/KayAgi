# 题目信息

# 「PMOI-1」中位数

## 题目描述

给定一棵以 $1$ 为根的包含 $n$ 个节点的**有根树**。第 $i$ 个节点有点权 $a_i$。

定义函数 $f(u,v)$ 表示从 $u$ 到 $v$ 经过的所有节点的点权的**可重集**的中位数。

请注意，**本题中的中位数的定义与数学中的定义略有不同**：这里一个长度为 $t$ 的序列的中位数定义为这个序列第 $\left\lceil\frac{t+1}2\right\rceil$ 小的数。

定义函数 $\text{cover}(x_1,y_1,x_2,y_2)$ 表示从 $x_1$ 到 $y_1$ 的路径是否完全覆盖了从 $x_2$ 到 $y_2$ 的路径。如果完全覆盖，则 $\text{cover}(x_1,y_1,x_2,y_2)=1$，否则 $\text{cover}(x_1,y_1,x_2,y_2)=0$。

你需要依次处理 $q$ 次操作，按照以下格式给出：

`1 u`：表示一次操作，需要你将点 $u$ 的点权对 $1$ **异或**；

`2 u v`：表示一次询问，需要你求出 $\max\limits_{1\le i\le n,1\le j\le n}\{\text{cover}(i,j,u,v)f(i,j)\}$。

对于第二类操作，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

你需要对于每个第二类操作，输出对应的值。

## 说明/提示

【样例解释】

第一次是询问。显然，只有 $(i=4,j=8)$ 满足 $\text{cover}(i,j,u,v)=1$。此时 $f(i,j)=3$。

第二次是操作。将 $3$ 号节点的点权改为了 $2$。

第三次是询问。当 $i=4,j=3$ 时，$\text{cover}(i,j,u,v)=1$ 且 $f(i,j)=4$。不难发现，对于其他所有满足 $\text{cover}(i,j,u,v)=1$ 的节点对 $(i,j)$，均没有 $f(i,j)>4$。

【数据范围】
- Subtask 1（8 pts）：$n,q\le50$；
- Subtask 2（12 pts）：$n,q\le2\times10^3$；
- Subtask 3（16 pts）：$n,q\le4\times10^4$；
- Subtask 4（10 pts）：保证树的形态随机生成；
- Subtask 5（12 pts）：保证没有 $1$ 操作；
- Subtask 6（12 pts）：保证每次询问的 $u,v$ 都是叶子节点；
- Subtask 7（30 pts）：无特殊限制。

Subtask 4 的随机方式为：随机生成一个的排列 $p$，对于 $i\in[2,n]$，$p_i$ 向 $p_1,p_2,...,p_{i-1}$ 中等概率随机的一个点连边。

对于 $100\%$ 的数据满足，$1\le n,q,a_i \le 10^5$，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

## 样例 #1

### 输入

```
8 3
4 2 3 4 2 1 4 3
1 2
1 3
2 4
2 5
3 6
6 7
6 8
2 4 8
1 3 
2 2 3```

### 输出

```
3
4```

# AI分析结果



---

## 算法分类
二分

---

## 题解思路与难点分析

### 核心思路
1. **二分答案**：将中位数问题转化为判定性问题，对可能的中位数值进行二分。
2. **键值转换**：将每个节点的权值转换为1或-1（≥mid为1，否则为-1），判断路径键值和是否非负。
3. **主席树维护**：利用可持久化线段树维护不同mid下的键值和，支持区间修改和子树最大值查询。
4. **路径拆分**：将覆盖路径拆分为三段（i→u、u→v、v→j），分别计算贡献。

### 二分过程要点
- **初始区间**：离散化后的权值范围 `[1, max(a_i)]`。
- **mid条件**：键值和的最大值是否非负。
- **收缩逻辑**：若存在满足条件的路径，则尝试更大的mid（`L=mid`），否则减小（`R=mid-1`）。

### 难点对比
| 题解作者 | 核心贡献 | 实现差异 |
|---------|---------|---------|
| Y_B_X   | 详细构建主席树，标记永久化处理修改 | 直接维护离散化后的权值版本 |
| ducati   | 引入Lemma拆分路径，强调动态维护 | 使用两棵主席树分别维护正向/反向路径 |

---

## 题解评分 (≥4星)
1. **Y_B_X的题解**（⭐️⭐️⭐️⭐️⭐️）  
   - **亮点**：代码完整，标记永久化实现清晰，修改操作处理高效。
2. **ducati的题解**（⭐️⭐️⭐️⭐️）  
   - **亮点**：理论分析严谨，路径拆分思想直观，适合数学推导。

---

## 最优思路提炼
1. **中位数转化为二分判定**：利用键值和非负性验证候选值。
2. **子树最大值查询**：通过DFS序将子树映射为连续区间，结合线段树区间查询。
3. **动态维护技巧**：仅在权值变化影响的版本更新（如奇偶性变化时调整对应线段树）。
4. **时间复杂度优化**：二分+主席树实现 $O(n \log^2 n)$ 的查询与修改。

---

## 同类型题目推荐
1. **P2839 [国家集训队]middle**：类似的中位数二分判定与线段树维护。
2. **P3384 【模板】轻重链剖分**：子树区间操作的基础应用。
3. **P3919 【模板】可持久化线段树 1**：主席树的经典实现。

---

## 可视化设计（二分过程）
### 动画方案
- **区间变化**：动态显示 `L`、`R`、`mid` 的移动，颜色标记当前判定结果（绿色为可行，红色不可行）。
- **子树高亮**：在判定时，用不同颜色区分u和v的子树范围。
- **键值和展示**：以柱状图展示路径键值和，实时更新最大值。

### 复古像素风格
- **Canvas绘制**：用8-bit网格表示权值区间，每次二分时像素块闪烁。
- **音效触发**：`mid`更新时播放“哔”声，判定成功时播放“胜利”音效。
- **自动演示**：模拟AI逐步收缩区间，用户可暂停观察中间状态。

---

## 代码片段（二分核心逻辑）
```cpp
int L=0, R=nn;
while(L < R) {
    int mid = (L+R+1) >> 1;
    int sum = 0;
    // 查询u子树的最大键值和
    sum += query_max(u_subtree, mid);
    // 查询v子树的最大键值和
    sum += query_max(v_subtree, mid);
    // 减去LCA的重复计算
    sum -= 2 * get_value(lca_node, mid);
    if(sum >= 0) L = mid;
    else R = mid-1;
}
return L;
```

---

## 总结
通过二分答案与主席树的高效结合，将复杂路径覆盖问题转化为可维护的键值判定问题。关键点在于动态维护不同权值版本的子树信息，并利用路径拆分简化贡献计算。

---
处理用时：69.03秒
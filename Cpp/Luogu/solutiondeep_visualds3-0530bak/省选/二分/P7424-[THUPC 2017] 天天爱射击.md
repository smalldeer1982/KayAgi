# 题目信息

# [THUPC 2017] 天天爱射击

## 题目描述

小 C 爱上了一款名字叫做《天天爱射击》的游戏。如图所示，这个游戏有一些平行于 $x$ 轴的木板。现在有一些子弹，按顺序沿着 $y$ 轴方向向这些木板射去。第 $i$ 块木板被 $S_i$ 个子弹贯穿以后，就会碎掉消失。一个子弹可以贯穿其弹道上的全部木板，特别的，如果一个子弹触碰到木板的边缘，也视为贯穿木板。

小 C 现在知道了游戏中 $n$ 块木板位置，以及知道了 $m$ 个子弹射击位置。现在问你每个子弹射出去以后，有多少木板会碎掉？

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/ocqlbnl3.png)
#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。

$\text{upd}2021.7.6$：感谢 @[jiangbowen](https://www.luogu.com.cn/user/366807) 提供的一组 hack 数据，不计分，但若不通过 hack 数据则不算通过此题。

## 样例 #1

### 输入

```
3 2
1 3 1
2 4 2
3 4 1
2
3```

### 输出

```
1
2```

# AI分析结果



**唯一算法分类**: 二分

---

### 综合分析与结论

**题解核心思路**：将问题转化为求每个木板被第 s_i 个子弹击碎的时间，采用整体二分或主席树解决。整体二分通过树状数组维护子弹区间，分治统计击碎条件；主席树则通过离散化子弹位置构建持久化线段树查询第 k 小。

**核心难点与解决**：
1. **区间查询优化**：使用树状数组/主席树高效统计区间子弹数。
2. **整体二分分组**：根据子弹区间划分木板到左右子问题，并动态调整剩余击碎次数。
3. **离散化处理**：同一位置多个子弹需按时间顺序插入主席树，未击中位置用极大值占位。

**二分可视化设计**：
- **动画展示**：绘制子弹位置轴，高亮当前 mid 子弹，显示木板区间 [l_i, r_i] 的命中统计。
- **分治过程**：用颜色区分左/右分组的木板，收缩区间时动态更新树状数组覆盖范围。
- **边界处理**：当二分区间收敛到单点时，统计该子弹击碎的所有木板数。

**复古像素风格实现**：
- **Canvas 网格**：将子弹轴映射为像素网格，子弹命中位置用闪烁方块表示。
- **音效触发**：命中木板时播放 8-bit 音效，分治切换时使用不同音调提示。
- **自动演示**：AI 自动执行二分步骤，每步暂停 500ms 展示 mid 和统计过程。

---

### 题解清单（≥4星）

1. **Suzt_ilymtics（整体二分）**  
   ★★★★☆  
   亮点：清晰的整体二分模板，用树状数组动态维护子弹覆盖，处理未击碎木板巧妙（m+1 分组）。代码注释详细，适合学习分治框架。

2. **MuYC（主席树）**  
   ★★★★☆  
   亮点：将问题转化为静态区间第 k 小，离散化处理同一位置多个子弹。代码结构清晰，时空复杂度最优。

3. **Alex_Wei（整体二分优化）**  
   ★★★★☆  
   亮点：离散化优化区间统计，避免冗余计算，代码简洁高效，实际运行速度最快。

---

### 核心代码实现（整体二分）

```cpp
void Solve(int l, int r, int ql, int qr) {
    if (ql > qr) return;
    if (l == r) {
        for (int i = ql; i <= qr; ++i) 
            if (Q[i].type) ans[l]++;
        return;
    }
    int mid = (l + r) >> 1;
    // 插入[l,mid]子弹到树状数组
    for (int i = l; i <= mid; ++i) 
        BIT::Modify(q[i].pos, 1);
    // 分类木板
    int cnt1 = 0, cnt2 = 0;
    for (int i = ql; i <= qr; ++i) {
        int sum = BIT::Query(Q[i].r) - BIT::Query(Q[i].l - 1);
        if (sum >= Q[i].k) q1[++cnt1] = Q[i];
        else Q[i].k -= sum, q2[++cnt2] = Q[i];
    }
    // 回退树状数组修改
    for (int i = l; i <= mid; ++i) 
        BIT::Modify(q[i].pos, -1);
    // 分治处理
    Solve(l, mid, ql, ql + cnt1 - 1);
    Solve(mid + 1, r, ql + cnt1, qr);
}
```

**关键点**：
- `mid` 为当前二分子弹时间中点。
- 树状数组统计 `[l, mid]` 子弹对木板的命中次数。
- 根据命中次数 `sum` 与 `k` 的关系将木板分到左右区间。

---

### 类似题目推荐

1. **P3527 [POI2011] MET-Meteors**  
   整体二分经典题，查询区间加成后达到阈值的时刻。

2. **P3834 【模板】可持久化线段树 2（主席树）**  
   静态区间第 k 小模板，练习主席树实现。

3. **P1908 逆序对**  
   树状数组求逆序对，理解单点更新与区间查询。

---

### 个人心得摘录

> "调这种题要时刻注意细节，样例弱的一匹，不行就自己捏几个。"  
> —— Suzt_ilymtics  
> **总结**：边界数据如全左侧/右侧命中需自行构造测试，避免 WA。

---

### 可视化设计（复古像素版）

```javascript
// Canvas 初始化
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
let bullets = [3,2,4,1,5]; // 子弹位置示例
let left = 0, right = bullets.length, mid;

function draw() {
    ctx.clearRect(0,0,400,50);
    // 绘制子弹轴
    bullets.forEach((x,i) => {
        ctx.fillStyle = i < left || i > right ? '#666' : '#0f0';
        ctx.fillRect(x*30, 10, 20, 20); // 子弹方块
    });
    // 高亮 mid
    ctx.fillStyle = '#f00';
    ctx.fillRect(bullets[mid]*30, 10, 20, 20);
}

// 自动二分演示
function autoSolve() {
    if (left >= right) return;
    mid = Math.floor((left + right)/2);
    draw();
    // 模拟统计命中逻辑
    setTimeout(() => {
        if (shouldGoLeft()) right = mid;
        else left = mid +1;
        autoSolve();
    }, 1000);
}
```

**交互**：空格键暂停/继续，方向键调整二分速度。命中时播放 `beep` 音效，分治切换时更新背景音乐节奏。

---
处理用时：68.57秒
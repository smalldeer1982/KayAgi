# 题目信息

# [JOISC 2021] 道路の建設案 (Road Construction) (Day2)

## 题目背景

10s,2048M

## 题目描述

JOI 国是一个 $x\times y$ 的二维平面，王国里有 $n$ 个城镇，分别编号为 $1, 2, \cdots, n$，其中第 $i$ 个城镇的 **坐标** 为 $(x_i, y_i)$。

在 JOI 国，正计划修建连接两座城镇的路（下文简称：**「修路的项目」**），路有 $k$ 条。连接两个不同的城镇 $a$ 和 $b$ 将花费 $|x_a − x_b| + |y_a − y_b|$ 元。若有一条连接 $c$，$d$ 的路，则不需要也不可以在建一条连接 $d$，$c$ 的路，因为它们是相同的。

你要管理这个「修路的项目」，为了计算花费情况，你得弄明白连接一些城镇所需的花费。在这 $\dfrac{n\cdot(n-1)}{2}$ 条道路中，你想了解最便宜的 $k$ 条道路的花费。

给你城镇的坐标以及 $k$，请计算最便宜的 $k$ 条路所需要的钱。

## 说明/提示

#### 样例 #1 解释
有 $\dfrac{3 \times 2}{2} = 3$ 种方案。

- 城镇 $1 \to$ 城镇 $2$，$|(-1)-0|+|0-2| = 3$ 日元。
- 城镇 $1 \to$ 城镇 $3$，$|(-1)-0|+|0-0| = 1$ 日元。
- 城镇 $2 \to$ 城镇 $3$，$|0-0|+|2-0| = 2$ 日元。

将其进行排序为 $1,2,3$，所以输出是 $1$ 和 $2$。

本样例满足 Subtask $1, 4, 5, 6$。

#### 样例 #2 解释

有 $\dfrac{5 \times 4}{2} = 10$ 种方案。

将钱数排序后是 $2, 2, 3, 3, 3, 3, 4, 4, 4, 4$。

本样例满足 Subtask $1, 4, 5, 6$。

#### 样例 #3 解释

本样例满足 Subtask $1, 2, 4, 5, 6$。

#### 样例 #4 解释

本样例满足 Subtask $1, 4, 5, 6$。

#### 数据范围与约定

**本题采用 Subtask 计分法。**

| Subtask | 分值占比百分率 | $n$ | $k$ | $y_i$ |
| :----: | :----: | :----: | :----:| :----: |
| $1$ | $5\%$ | $\le 10^3$ | / | / |
| $2$ | $6\%$ | / | / | $=0$ |
| $3$ | $7\%$ | / | $=1$ | / |
| $4$ | $20\%$ | / | $\le 10$ | / |
| $5$ | $27\%$ |  / | $\le 10 ^ 5$ | / |
| $6$ | $35\%$ | / | / | / |

**注：斜线表示无特殊限制。**

对于 $100\%$ 的数据：
- $2 \le n \le 2.5 \times 10^5$；
- $1 \le k \le \min(2.5\times 10^5,\ \dfrac{n\cdot(n-1)}{2}$)；
- $-10^9 \le x_i, y_i \le 10^9$，且 $1 \le i \le n$；
- $(x_i,y_i)\not = (x_j, y_j)$ 且 $1 \le i < j \le n$。

#### 说明

本题译自 [第２０回日本情報オリンピック 2020/2021春季トレーニング合宿 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [競技 2 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day2/2021-sp-d2-notice.pdf) [T2 日文题面](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day2/road_construction.pdf)。


## 样例 #1

### 输入

```
3 2
-1 0
0 2
0 0
```

### 输出

```
1
2
```

## 样例 #2

### 输入

```
5 4
1 -1
2 0
-1 0
0 2
0 -2
```

### 输出

```
2
2
3
3
```

## 样例 #3

### 输入

```
4 6
0 0
1 0
3 0
4 0
```

### 输出

```
1
1
2
3
3
4
```

## 样例 #4

### 输入

```
10 10
10 -8
7 2
7 -8
-3 -6
-2 1
-8 6
8 -1
2 4
6 -6
2 -1
```

### 输出

```
3
3
4
5
6
6
6
7
7
7
```

# AI分析结果



# 【算法分类】
二分

# 【综合分析与结论】

**核心思路**：  
本题的核心是将曼哈顿距离转换为切比雪夫距离，通过二分答案确定第k小的距离值。在二分过程中，利用排序+滑动窗口维护x轴范围，配合有序数据结构（如multiset）快速查询y轴范围内的邻近点，实现高效统计。

**解决难点**：  
1. **曼哈顿距离转换**：通过坐标变换 (x,y)→(x+y,x-y) 将曼哈顿距离转化为更易处理的切比雪夫距离
2. **高效统计**：利用排序后的x轴滑动窗口保证|x_i -x_j|≤mid，multiset维护y轴范围实现O(log n)查询
3. **二分边界处理**：先统计严格小于mid的点对数量，最后用mid补齐k个答案

**可视化设计**：  
1. **区间动画**：用横向滑动条表示当前x轴窗口范围，纵向色块表示y轴查询区间，高亮当前mid值
2. **像素风格**：  
   - 用8-bit风格网格展示坐标平面，红色像素表示当前点，绿色表示符合条件点对  
   - 每次二分收缩时播放8-bit音效，找到答案时触发通关音效
3. **AI自动演示**：自动执行二分步骤，单步展示窗口滑动和集合查询过程

# 【题解清单（≥4星）】

1. **hfjh的题解（5星）**  
   - 亮点：清晰的二分框架+滑动窗口实现，代码可读性强  
   - 关键代码片段：  
     ```cpp
     bool check(ll mid) {
         multiset<ll> st;
         queue<int> q;
         int cnt = 0;
         for(int i=1; i<=n; i++) {
             while(q.size() && p[i].x - p[q.front()].x > mid) {
                 st.erase(p[q.front()].y);
                 q.pop();
             }
             auto it = st.lower_bound(p[i].y - mid);
             while(it != st.end() && *it <= p[i].y + mid) {
                 if(++cnt >= k) return true;
                 ++it;
             }
             q.push(i);
             st.insert(p[i].y);
         }
         return cnt >= k;
     }
     ```

2. **7KByte的题解（4.5星）**  
   - 亮点：简洁的二分实现，使用优先队列动态维护前k小值  
   - 优化点：在check时直接收集候选答案，减少重复计算

3. **SunnyYuan的题解（4星）**  
   - 亮点：详细解释二分后补足k个答案的逻辑，代码注释清晰  
   - 关键调试心得：  
     > "必须最后将当前点加入集合，避免统计自身距离为0的错误情况"

# 【最优思路提炼】

**核心技巧**：  
1. **坐标转换**：曼哈顿→切比雪夫距离简化维度处理  
2. **分层处理**：  
   - 外层二分答案确定距离阈值  
   - 内层双指针维护x轴窗口，有序集合处理y轴范围  
3. **早停优化**：当统计到k个点对时立即返回，减少无效计算

**边界处理**：  
- 初始化二分区间为[1,4e9]覆盖最大可能距离  
- 最终补足k个时，先收集严格小于mid的答案，再用mid补齐

# 【同类题目推荐】

1. **P1429** 平面最近点对（加强版）  
   - 同类型分治解法，训练二维邻近点处理能力

2. **P7888** 「MCOI-06」Eert Tuc Knil  
   - 结合树状数组的二维数点问题

3. **CF429D** 带权距离的最近点对  
   - 变种曼哈顿距离处理

# 【复古像素动画实现】

**Canvas绘制**：  
```javascript
// 初始化8-bit风格
ctx.fillStyle = '#2C3E50'; // 深蓝背景
ctx.fillRect(0,0,256,256); 

// 绘制网格
for(let x=0;x<=256;x+=16){
    ctx.strokeStyle = '#34495E';
    ctx.beginPath();
    ctx.moveTo(x,0); ctx.lineTo(x,256);
    ctx.stroke();
}

// 二分动画帧
function drawFrame(mid, left, right) {
    // 红色表示当前mid范围
    ctx.fillStyle = '#E74C3C'; 
    ctx.fillRect(left*16, (curY-mid)*16, (right-left)*16, mid*2*16);
    
    // 播放音效
    beep(440, 50); // 8-bit音效
}
```

**交互设计**：  
- 方向键控制二分步进，空格暂停/继续  
- 成功时触发《超级马里奥》通关音效，失败时播放《魂斗罗》死亡音效

# 【核心代码实现】

**二分框架**：
```cpp
ll l=1, r=4e9;
while(l < r) {
    ll mid = (l+r)>>1;
    if(check(mid)) r = mid;
    else l = mid+1;
}

vector<ll> ans;
check(l-1); // 收集严格小于l的答案
sort(ans.begin(), ans.end());
while(ans.size() < k) ans.push_back(l);
```

**滑动窗口+multiset**：
```cpp
multiset<ll> st;
queue<int> q;

for(int i=1; i<=n; i++) {
    // 维护x轴窗口
    while(q.size() && x[i]-x[q.front()] > mid) {
        st.erase(y[q.front()]);
        q.pop();
    }
    
    // 查询y轴范围
    auto it = st.lower_bound(y[i]-mid);
    while(it != st.end() && *it <= y[i]+mid) {
        ans.push_back(max(x[i]-curX, abs(y[i]-*it)));
        if(ans.size() >= k) return;
        ++it;
    }
    
    // 加入当前点
    q.push(i);
    st.insert(y[i]);
}
```

---
处理用时：73.25秒
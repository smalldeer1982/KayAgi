# 题目信息

# [JRKSJ R6] func

## 题目描述

**这是一道 IO 交互题．**

你有一个一次函数 $f(x)=kx+b$（$1\le x \le n-1$）．这个一次函数满足 $k,b$ 均为整数且 $k>0$．

vectorwyx 修改了这个函数，具体而言，他会选择一个整数 $t$（$1\le t \le n-1$），将这个函数在直线 $x=t$ 及右侧的部分向右平移一个单位长度，并把两部分的端点用直线段连接，得到一个分段函数 $g(x)$：

$$
g(x)=\begin{cases}
kx+b&1\le x<t\\
kt+b& t\le x <t+1\\
k(x-1)+b& t+1\le x \le n
\end{cases}
$$

请通过交互的方式得到 $t$ 的值．

### 交互方式

**本题单个测试点中含有多组数据．**

1. 首先从标准输入流读入一个整数 $T$，表示数据组数．
1. 接下来你将进行 $T$ 组数据的交互．对于每组数据，首先从标准输入流读入三个整数 $n,Q,P$．
1. 你可以通过向标准输出流输出 `? l r p`（$1\le l \le r \le n$，$2\le p \le P$）的方式来询问．在单组数据中，你最多只能进行 $Q$ 次 `?` 操作．交互库会根据你的询问依次做出以下判断并向标准输入流发送返回结果：
    - 若你的询问数据范围错误，回答为 $-2$．此时交互库会直接返回 WA．你需要立刻退出你的程序来避免与已经结束程序的交互库交互引起超时．
    - 若 $g(l)=g(r)$，回答为 $-1$．
    - 否则回答为 $(g(l) + g(r))\bmod p$．
1. 你可以通过向标准输出流输出 `! t` 的方式来给出答案．你只能进行一次回答操作，且回答操作必须是你在每组数据中进行的最后一个操作．交互完成后，从标准输入流读入一个零或一的整数 $x$．若 $x=1$ 则代表当前数据回答正确，你需要回到步骤 $2$ 以进行下一组数据的交互．否则 $x=0$，你需要立刻退出自己的程序．

**不要忘记在每次输出后刷新缓冲区，否则你将会 TLE．**

下面是一些语言的刷新缓冲区操作：

- C++：`fflush(stdout)` 或 `cout.flush()`．
- C: `fflush(stdout)`．
- Java: `System.out.flush()`．
- Python: `stdout.flush()`．
- Pascal: `flush(output)`．
- 其他语言：请参考对应语言的帮助文档．


## 说明/提示

### 样例解释

请注意，样例仅用来表示交互的规则，不保证有逻辑性．

#### 样例 #1

$f(x)=3x-2$（$1\le x \le 4$），$t=3$．

$$
g(x)=\begin{cases}
3x-2&1\le x<3\\
7& 3\le x <4\\
3x-5& 4\le x \le 5.
\end{cases}
$$

所以第一次询问的结果 $(g(1) + g(3))\bmod 2 = (1+7)\bmod 2=0$，第二次询问的结果 $(g(4)+g(5))\bmod 2 = (7+ 10)\bmod 2=1$．

### 数据范围与约束

**本题采用捆绑测试．且不存在一个 Subtask 包含其它所有 Subtask 的限制．**

| Subtask | 分值 |    $n$     | $Q=$ |       $P=$        | $g(x)\le$ |    特殊性质     |
| ------- | ---- | ---------- | ---- | ----------------- | --------- | --------------- |
| $1$     | $10$ | $\le 10^9$ | $42$ | $2\times 10^{18}$ | $10^{18}$ | 无              |
| $2$     | $20$ | $\le 10^9$ | $30$ | $2$               | $10^{18}$ | 斜率 $k$ 为奇数 |
| $3$     | $30$ | $\le 10^9$ | $42$ | $50$              | $10^{18}$ | 无              |
| $4$     | $39$ | $\le 10^9$ | $32$ | $50$              | $10^{18}$ | 无              |
|$5$|$1$|$ = 1162261531$| $32$| $50$| $7857125847061472735$|无|

对于 $100\%$ 的数据，保证 $1 \le T \le 10$，$2\le n\le 1162261531$．且满足 $\forall x \in [1,n], 0 \le g(x)\le 7857125847061472735$．

### 提示

由于本题不存在一个 Subtask 包含其它所有 Subtask 的限制．所以数据范围中「对于 $100\%$ 的数据」部分的 $n$ 和 $g(x)$ 的上界没有任何意义．但由于直接写「对于 $100\%$ 的数据，满足 $n \ge 2$，$g(x)\ge 0$」会被某些管理以「你管这叫数据范围」打回，故此题中保留该没有意义的上界．

## 样例 #1

### 输入

```
1
5 999 999

0

1

1```

### 输出

```


? 1 3 2

? 4 5 2

! 3```

# AI分析结果



### 算法分类
**二分/三分**

---

### 题解思路与核心难点
#### 核心思路
1. **模数选择与参数推导**  
   - 选择一组互质的奇数模数（如 `{49,47,45,43,41,37}`），其 LCM 足够大以覆盖最大可能的斜率 k。
   - 通过两次询问（如 `g(1)+g(2)` 和 `g(2)+g(3)`）计算 k 和 2b 的模值。若 k≡0(mod p)，则换下一个模数。

2. **三分法定位 t**  
   - 每次将区间 `[L, R]` 三等分，询问中间两点 `midl` 和 `midr`：
     - 若返回结果符合原函数未偏移的表达式，说明拐点在右侧。
     - 若符合偏移后的表达式，说明拐点在左侧。
     - 否则拐点在中间段。

#### 解决难点
- **模数选择**：确保至少有一个模数 p 满足 k≡0(mod p)，避免无法推导参数。
- **边界处理**：当询问返回 -1 时，直接确定拐点位置。
- **效率优化**：三分法将复杂度从 O(log n) 降到 O(log₃n)，适应大 n 场景。

---

### 题解评分 (≥4星)
1. **vectorwyx（5星）**  
   - **亮点**：完整推导模数选择逻辑，提供高效三分实现，处理边界清晰。
   - **代码**：通过三次询问确定参数，结合模数集合保证覆盖所有情况。

2. **Eafoo（4星）**  
   - **亮点**：详细分析函数性质，提出基于奇偶性的二分法，适合 Subtask2。
   - **优化**：手动构造 LCM 最大的模数集合，确保理论覆盖。

3. **星星与辰（4星）**  
   - **亮点**：结合二分与三分思想，提供随机优化思路，代码实现简洁。
   - **关键点**：动态调整三分区间，处理特殊拐点位置。

---

### 最优思路与技巧提炼
1. **模数选择策略**  
   - 选 LCM 最大的奇数集合，确保至少一个模数有效。
   - 推导公式：通过两次询问计算 k 和 2b 的模值（需保证 p 为奇数）。

2. **三分法实现**  
   - **区间分割**：三等分点公式 `midl = (2L+R)/3`, `midr = (L+2R)/3`。
   - **结果判断**：根据返回值的三种可能性收缩区间。

3. **边界处理**  
   - 当询问返回 -1 时，直接确定 t 的位置。
   - 处理极小区间（如长度 ≤3）时直接暴力检查。

---

### 同类型题与算法套路
1. **类似题目**  
   - **P1873 砍树**：二分答案求最大高度。
   - **P3382 寻找极值点**：三分法找单峰函数极值。
   - **CF1856E 交互分治**：通过询问缩小搜索范围。

2. **通用套路**  
   - **二分答案**：当答案具有单调性时适用。
   - **三分法**：适用于单峰或分段线性函数的最值问题。

---

### 代码片段（核心三分逻辑）
```cpp
void solve() {
    int L = 1, R = n;
    while (R - L > 1) {
        int midl = (2LL * L + R) / 3;
        int midr = (L + 2LL * R) / 3;
        int res = ask(midl, midr, p);
        if (res == -1) {
            answer(midl);
            return;
        }
        int expected = (k * (midl + midr) + 2 * b) % p;
        if (res == expected)      R = midr;
        else if (res == (expected - k + p) % p) L = midl;
        else                      R = midl - 1;
    }
    answer(L);
}
```

---

### 可视化设计（复古像素风格）
1. **动画方案**  
   - **区间展示**：Canvas 绘制区间 `[L, R]`，用绿色方块标记当前 midl 和 midr。
   - **颜色标记**：
     - 红色：当前搜索区间。
     - 黄色：已排除区间。
     - 蓝色高亮：本次询问的 midl 和 midr。

2. **音效设计**  
   - **移动音效**：8-bit 短音效，每次更新 midl/midr 时触发。
   - **成功音效**：找到 t 时播放胜利旋律。

3. **交互功能**  
   - **速度调节**：滑动条控制动画速度（0.5x~3x）。
   - **AI 自动演示**：模拟三分步骤，每步暂停 1 秒。

---

### 总结
通过模数选择与三分法的结合，高效定位分段函数的拐点。关键点在于数学推导与分治策略的精准实现，适合大范围交互题的典型解法。

---
处理用时：75.38秒
# 题目信息

# [THUPC 2023 初赛] 最后的活动

## 题目背景

各位亲爱的《La Lumière: Scarlet Intense Flame》玩家：

感谢您一直给予《La Lumière: Scarlet Intense Flame》的支持与厚爱。我们非常遗憾地宣布，《La Lumière: Scarlet Intense Flame》将于 2023 年 3 月 5 日 16:00 停止运营服务。

停止运营相关时间表如下：

……

## 题目描述

元老级二次元手游《La Lumière: Scarlet Intense Flame》将于今年 3 月停止运营服务。作为这款游戏的忠实玩家，小 S 希望能在游戏的最后一次活动中刷到一个特殊的分数，以此为近十年来与这款游戏共度的难忘时光画上一个圆满的句号。

《La Lumière: Scarlet Intense Flame》中的每种活动都有其独特的规则，而最后一次活动是 Chase Festival。在 Chase Festival 中，玩家需要多次攻略每次随机生成的多层迷宫，每次退出迷宫时根据在迷宫中各层击杀怪物的评价独立结算本次随机迷宫的分数。每次挑战迷宫时的流程简化如下：

1. 选择挑战的随机迷宫的难度。小 S 是这款游戏的资深玩家，因此在本题中假定小 S 总是挑战最高难度的迷宫。最高难度的迷宫最深为 $N$ 层。确定难度后，从随机生成的迷宫的第 1 层开始挑战。

2. 进行第 $i$ 层的挑战。挑战第 $i$ 层时，小 S 有可能挑战失败，挑战成功并获得普通评价，或者挑战成功并获得高评价。如果小 S 选择保守的挑战策略，则有 $p_{i,0}$ 的概率挑战失败，有 $p_{i,1}$ 的概率挑战成功并获得普通评价，有 $p_{i,2}$ 的概率挑战成功并获得高评价；如果小 S 选择激进的挑战策略，则有 $q_{i,0}$ 的概率挑战失败，有 $q_{i,1}$  的概率挑战成功并获得普通评价，有 $q_{i, 2}$ 的概率挑战成功并获得高评价。
   
   - 获得普通评价时，在当前层获得 $s_{i,1}$ 的分数；获得高评价时，在当前层获得 $s_{i,2}$ 的分数。这部分获得的分数**不会直接加算**到玩家的总分数中，而是**在退出迷宫时结算**。如果挑战成功，且当前不是最后一层（$i<N$），则跳转到第 3 步，选择是否继续挑战；否则（$i=N$），退出迷宫并跳转到第 4 步进行结算。
   
   - 如果挑战失败，则强制退出迷宫，跳转到第 4 步。

3. 如果当前不是最后一层，玩家可以选择是否继续挑战下一层。如果选择继续，则返回第 2 步；否则退出当前迷宫，跳转到第 4 步进行结算。

4. 本次迷宫的分数结算：如果因为失败而强制退出，则当前层不获得任何奖励，且**本次迷宫中之前各层**累积的分数需要乘上惩罚系数 $c$（为了使最终分数为整数，游戏会对惩罚后的分数先求和再下取整）；除了强制退出之外，玩家主动退出或者通关迷宫后退出都可以获得全部尚未结算的分数。

小 S 想得到的目标分数是一个比较大的分数，因此小 S 需要先大量刷最高难度的迷宫，再在接近目标分数时根据当前剩余的分数选择相对稳定的策略，以确保活动结束时能恰好获得目标分数。小 S 不会编程，因此小 S 找到了你，希望你能帮忙计算当剩余分数在 $1$ 至 $M$ 分之间，仅按照上述的流程挑战迷宫，并采用最佳策略时，最终能够恰好达到目标分数的最大概率。

## 说明/提示

#### 子任务

对于 $100\%$ 的数据，保证 $1\le N\le 6$，$1\le M\le 10000$，$0\le c'\le 100$，$1\le s_{i,1}\le s_{i, 2}\le 10000$，$0\le u_{i, 0}, u_{i, 1}, u_{i, 2}, v_{i, 0}, v_{i, 1}, v_{i, 2}\le 10000$，$u_{i,1}+u_{i,2}\ge 1$，$v_{i,1}+v_{i,2}\ge 1$。

#### 提示

《La Lumière: Scarlet Intense Flame 2》将于 2023 年春暖花开的时节与大家相见！

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
2 8 50
3 4 0 1 1 0 1 1
4 5 1 2 1 1 1 2
```

### 输出

```
0.125000000000000000 0.140625000000000000 0.515625000000000000 0.564453125000000000 0.135009765625000000 0.328369140625000000 0.548858642578125000 0.625278472900390625
```

## 样例 #2

### 输入

```
见附件中的 2.in```

### 输出

```
见附件中的 2.ans```

# AI分析结果



# 算法分类选择
**二分**

---

# 题解思路、算法要点与解决难点

## 核心思路
采用动态规划结合二分答案的策略，解决状态转移中的环状依赖问题。定义 `f[i]` 表示剩余分数为 `i` 时恰好达成的最大概率。通过二分假设 `f[i]` 的初值，递归模拟迷宫挑战过程，逐层选择最优策略（保守/激进），计算期望概率，最终收敛至正确值。

## 算法要点
1. **状态转移树**：每一层有三个可能结果（失败、普通、高评价），对应不同的分数累积方式。
2. **二分答案**：对每个目标分数 `i`，通过二分假设 `f[i]` 的初值，用 DFS 验证假设值的合理性。
3. **递归决策**：`dfs(pos, acc, aim)` 计算从第 `pos` 层开始，累积 `acc` 分时达成 `aim` 分的最大概率，取保守/激进策略中的最优值。
4. **惩罚系数处理**：失败时结算分数需乘 `c` 并下取整，递归中通过 `F(sc) = (sc > aim ? 0 : f[aim - sc])` 处理。

## 解决难点
- **环状依赖**：`f[i]` 的值可能依赖于自身（如失败后得分仍为 `i`），通过二分假设初值打破循环。
- **多层决策**：递归中需处理是否继续挑战下一层，动态规划状态包含当前层数和累积分数。
- **概率叠加**：不同策略的概率需加权求和，取最大值保证最优策略。

---

# 题解评分 (≥4星)
1. **Alex_Wei (5星)**  
   - **亮点**：完整代码实现，结合二分与递归，处理了所有边界条件，时间复杂度合理。
2. **Eraine (4星)**  
   - **亮点**：深入分析二分方向的数学依据，解释递推式收敛性，补充理论支持。
3. **cmk666 (4星)**  
   - **亮点**：指出直接爆搜需结合二分，提供思维方向，强调精度与效率平衡。

---

# 最优思路或技巧提炼
1. **二分答案破环**：假设 `f[i]` 初值，验证其合理性，逐步逼近真实解。
2. **记忆化递归**：DFS 函数模拟所有可能的决策路径，动态取最大值。
3. **惩罚系数处理**：失败时分数下取整，通过 `F(sc)` 快速索引 `f` 数组。
4. **概率归一化**：将输入的百分比转换为概率，简化计算。

---

# 同类型题或类似算法套路
- **二分答案**：适用于状态转移存在环或不可直接递推的问题（如依赖后续状态）。
- **树形动态规划**：递归处理多层决策，结合概率期望。
- **收敛性迭代**：通过多次迭代逼近正确值，常见于概率问题。

---

# 推荐相似题目
1. **P1291 [SHOI2002] 百事世界杯之旅**（概率递推）
2. **P4542 [ZJOI2011] 营救皮卡丘**（分层图动态规划）
3. **P3199 [HNOI2009] 最小圈**（二分答案+SPFA判负环）

---

# 个人心得摘录
- **Alex_Wei**：指出 `c=0` 的情况需特殊处理，通过系数范围确保收敛。
- **cmk666**：强调二分法对自引用问题的必要性，避免直接爆搜超时。

---

# 可视化与算法演示（核心二分过程）
## 动画方案
- **区间展示**：用 Canvas 绘制区间 `[left, right]`，标记当前 `mid` 值。
- **颜色标记**：绿色表示 `mid` 被接受，红色表示被拒绝，黄色表示当前比较值。
- **步进控制**：支持单步执行，显示每次二分后的区间变化。
- **音效提示**：成功收敛时播放上扬音效，失败时播放低沉音效。

## 复古像素风格
- **8位网格**：区间以像素块表示，每次收缩时方块动态移动。
- **AI 自动模式**：自动执行二分步骤，模拟“AI 闯关”效果。
- **积分系统**：正确收缩区间获得积分，连击增加得分倍数。

---

# 代码核心片段
```cpp
// 二分主逻辑
for(int i = 1; i <= m; i++) {
    double l = 0, r = 1;
    for(int _ = 0; _ <= 30; _++) {
        double mid = (l + r) / 2;
        f[i] = mid;
        if(dfs(1, 0, i) < mid) r = mid; // 收缩右边界
        else l = mid;                   // 收缩左边界
    }
    printf("%.9lf ", f[i]);
}

// 递归决策函数
double dfs(int pos, int acc, int aim) {
    if(pos > n) return 0;
    auto F = [&](int c) { return c > aim ? 0 : f[aim - c]; };
    // 普通评价分支
    double p1 = max(F(acc + s1[pos]), dfs(pos + 1, acc + s1[pos], aim));
    // 高评价分支
    double p2 = max(F(acc + s2[pos]), dfs(pos + 1, acc + s2[pos], aim));
    // 计算两种策略的期望概率
    double u = u0[pos] * F(sc) + u1[pos] * p1 + u2[pos] * p2;
    double v = v0[pos] * F(sc) + v1[pos] * p1 + v2[pos] * p2;
    return max(u, v); // 取最优策略
}
```

---
处理用时：68.82秒
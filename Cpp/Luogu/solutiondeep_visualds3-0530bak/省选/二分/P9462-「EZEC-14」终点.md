# 题目信息

# 「EZEC-14」终点

## 题目背景

~~出题人怎么还没鸟加这首歌啊。~~

于 2023.8.5 拿下。

## 题目描述

**这是一道交互题。**

dXqwq 有一棵 $n$ 个点的无根树，结点从 $1$ 到 $n$ 编号。您需要通过若干次询问得到这棵树的结构。

您可以选择两个整数 $1\leq u,v\leq n$，并输出 `? u v` 进行询问。

对于每次询问，如果 $u,v$ 的路径中点在一个结点上，交互库返回该点的编号，否则返回 ``0``。

请通过不超过 $147154$ 次询问，得到这棵树的结构。

保证树的形态是提前确定的，即**交互库不自适应。**

### 交互方式

输入测试点所在子任务编号 $id$ 和树的大小 $n$ 以开始交互。

交互过程中，您可以进行题目描述中的询问。

对于每次询问，如果你提供的 $u,v$ 不合法或者超出询问次数上限，交互库会返回 ``-1``，否则交互库将会返回一个非负整数，含义见「题目描述」。

当你读取到 ``-1`` 后应立刻退出程序，在此之后交互库的行为未定义。

在您确定答案后，请先输出 `!`，然后接下来 $n-1$ 行依次输出两个整数 ``u[i] v[i]`` 代表树的每条边，最后退出程序。你可以以任意顺序输出这些边。

在您输出一行后，请清空缓冲区：

- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。
- 在 Pascal 中，使用 `flush(output)`。
- 在 Python 中，使用 `stdout.flush()`。
- 其它语言请自行查阅文档。

## 说明/提示

**本题采用捆绑测试。**

-  Subtask 1（10 pts）：$n \leq 10$，树满足性质 A。
-  Subtask 2（10 pts）：保证存在一个点度数为 $n-1$。
-  Subtask 3（10 pts）：保证所有点度数 $\leq 2$。
-  Subtask 4（10 pts）：$n \leq 500$，树满足性质 A。
-  Subtask 5（20 pts）：$n \leq 500$。 
-  Subtask 6（20 pts）：树满足性质 A。
-  Subtask 7（20 pts）：无特殊限制。

性质 A：对于 $i=2,3,\cdots,n$ 存在整数 $1\leq j<i$ 满足有一条边连接 $i,j$。

对于 $100\%$ 的数据，$2 \leq n \leq 10^4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/3u2zy1q5.png)

## 样例 #1

### 输入

```
1 5

1

2

3

4

0```

### 输出

```
 
? 1 1

? 1 3

? 2 4

? 3 5

? 4 5

!
1 2
2 3
3 4
4 5```

## 样例 #2

### 输入

```
5 5

1

0

0

2

2```

### 输出

```
 
? 1 1

? 1 3

? 2 4

? 3 5

? 4 5

!
1 3
2 3
2 4
2 5```

# AI分析结果



### **唯一算法分类**  
二分  

---

### **综合分析与结论**  
题目核心在于通过中点查询逐步确定树的父节点结构。主要思路为：  
1. **寻找相邻节点**：利用中点查询次数最多的点确定与根相邻的节点（类似二分查找极值）。  
2. **BFS分层处理**：将未确定的节点挂载到队列中，每次处理时通过中点查询缩小父节点范围，类似于二分查找中的区间收缩。  
3. **动态更新父节点**：每次查询中点后，若无法确定父节点，则挂载到新的可能父节点队列中，直到唯一确定。  

**难点**在于如何在有限次数内高效确定所有节点的父节点。通过二分策略，每次中点查询将路径长度减半，从而将总次数控制在 $O(n \log n)$。  

**可视化设计**：  
- **区间收缩**：展示当前查询的节点对和中点结果，高亮可能的父节点范围。  
- **像素动画**：用网格表示树节点，每次查询后更新父节点连线，播放音效提示成功/失败。  
- **自动演示**：模拟二分过程，AI自动执行查询和收缩逻辑，展示区间更新路径。  

---

### **题解清单 (≥4星)**  
1. **dead_X的题解（5星）**  
   - **亮点**：利用队列优化处理顺序，动态规划计算深度，代码简洁高效。  
   - **关键代码**：通过 `d[x].push_back(y)` 挂载未确定节点，队列处理父节点确定逻辑。  
   - **评分理由**：思路清晰，代码可读性强，询问次数控制优秀。  

2. **elbissoPtImaerD的题解（4星）**  
   - **亮点**：通过 `lowbit` 快速定位相邻节点，逻辑严谨。  
   - **关键代码**：`fa[v] = fa[u]` 处理对称情况，减少冗余查询。  
   - **评分理由**：逻辑系统性强，但代码复杂度稍高。  

---

### **最优思路与技巧提炼**  
1. **相邻节点定位**：查询所有点与根的中点，取能进行中点分解次数最多的点（等价于深度最大的点）。  
2. **二分收缩父节点**：  
   - 初始化临时父节点为根或相邻节点。  
   - 通过中点查询逐步将父节点范围缩小为当前父节点或其父节点，直到唯一确定。  
   - 若无法确定，将未处理的节点挂载到新的父节点队列中，等待后续处理。  
3. **动态队列优化**：使用BFS队列管理待处理节点，确保父节点已知后再处理子节点。  

---

### **同类型题与算法套路**  
- **二分答案**：如「P1873 砍树」，通过二分猜测极值并验证。  
- **树结构推断**：如「P3384 树链剖分」，利用路径性质逐步确定结构。  
- **交互题策略**：如「P1947 猜数」，通过极值查询缩小范围。  

---

### **推荐相似题目**  
1. P1873 砍树（二分答案）  
2. P3384 树链剖分（树结构操作）  
3. P1947 猜数（交互题）  

---

### **个人心得摘录**  
- **调试教训**：初始父节点选择错误会导致后续查询逻辑混乱，需优先验证相邻节点。  
- **顿悟点**：中点查询本质是路径长度的二分，可递归分解路径。  

---

### **可视化与算法演示**  
**核心二分过程动画设计**：  
1. **初始化**：根节点为1，用红色像素标记；相邻节点为蓝色。  
2. **查询步骤**：  
   - 展示当前查询的节点对 `(u, v)`，高亮黄色。  
   - 若中点存在，更新父节点连线并播放上升音效；否则显示红色叉，播放失败音效。  
3. **区间收缩**：  
   - 用绿色箭头表示父节点更新方向，区间长度减半。  
   - 自动演示模式下，AI逐步选择最优查询对，收缩路径。  

**复古像素风格**：  
- **颜色方案**：16色调色板，根节点红色，叶子绿色，查询对黄色。  
- **Canvas网格**：节点按层次排列，边用白色像素绘制。  
- **音效触发**：每次查询播放8位“滴”声，成功时播放胜利旋律。  

---

### **代码片段（核心二分逻辑）**  
```cpp
// 来自 dead_X 的题解核心部分
queue<int> q;
fa[1] = id, fa[id] = 1;
q.push(1); q.push(id);
for (int i = 2; i <= n; ++i) if (i != id) d[1].push_back(i);

while (!q.empty()) {
    int x = q.front(); q.pop();
    for (int y : d[x]) {
        if (a[x] ^ a[y]) { // 深度奇偶性不同
            int z = query(fa[x], y);
            if (z == x) fa[y] = x, q.push(y); // 确定父节点
            else d[z].push_back(y); // 挂载到新父节点
        } else {
            int z = query(x, y);
            d[z].push_back(y); // 继续二分收缩
        }
    }
    vector<int>().swap(d[x]); // 清空当前队列
}
```

---
处理用时：90.65秒
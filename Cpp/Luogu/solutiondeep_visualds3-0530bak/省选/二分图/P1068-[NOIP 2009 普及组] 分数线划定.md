# 题目信息

# [NOIP 2009 普及组] 分数线划定

## 题目描述

世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，A 市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的 $150\%$ 划定，即如果计划录取 $m$ 名志愿者，则面试分数线为排名第 $m \times 150\%$（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。

现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。

## 说明/提示

【样例说明】

$m \times 150\% = 3 \times150\% = 4.5$，向下取整后为 $4$。保证 $4$ 个人进入面试的分数线为 $88$，但因为 $88$ 有重分，所以所有成绩大于等于 $88$ 的选手都可以进入面试，故最终有 $5$ 个人进入面试。

NOIP 2009 普及组 第二题


## 样例 #1

### 输入

```
6 3 
1000 90 
3239 88 
2390 95 
7231 84 
1005 95 
1001 88```

### 输出

```
88 5 
1005 95 
2390 95 
1000 90 
1001 88 
3239 88 ```

# AI分析结果



### 唯一算法分类
排序 + 模拟

---

### 题解思路与难点分析
#### 核心步骤与关键变量
1. **数据结构**：所有题解均使用结构体或数组存储选手的报名号和分数。
2. **排序规则**：按分数降序排列，分数相同时按报名号升序排列。
3. **分数线计算**：取排序后第 `m * 1.5` 名的分数（向下取整）。
4. **统计录取人数**：遍历排序后的数组，统计所有分数不低于分数线的选手。

#### 解决难点
- **同分处理**：若分数线位置的分数有重复，需将所有同分选手纳入录取范围。例如，题解1通过遍历所有元素直到发现第一个低于分数线的位置，题解4通过统计后续同分选手数量。
- **向下取整实现**：利用 `int(m * 1.5)` 或 `m * 15 / 10` 直接取整。

#### 可视化设计思路
1. **排序动画**：将选手数据以像素方块形式展示，分数越高颜色越亮，排序过程中动态交换方块位置。
2. **分数线高亮**：用红色标记第 `m * 1.5` 名的位置，显示其分数。
3. **统计过程**：遍历数组时，符合条件的选手方块闪烁并播放音效，最终统计总数。
4. **复古风格**：采用8位像素风格，背景音乐为8位循环音轨，关键操作触发短促音效。

---

### 题解评分（≥4星）
#### 1. 「已注销」（4.5星）
- **亮点**：利用下标数组避免结构体，代码简洁高效。
- **代码片段**：
  ```cpp
  sort(sub+1, sub+n+1, cmp); // 对下标排序
  f = s[sub[int(m*1.5)]];    // 计算分数线
  ```

#### 2. 2023z（4星）
- **亮点**：结构体排序清晰，通过反向遍历找到最后一个达标选手。
- **代码片段**：
  ```cpp
  for (int i = n; i >= 1; i--) { // 反向遍历找边界
      if (a[i].s >= x) { j = i; break; }
  }
  ```

#### 3. ryf2011（4星）
- **亮点**：显式统计后续同分选手，逻辑直观。
- **代码片段**：
  ```cpp
  for (int i = lq+1; i <= n; i++) {
      if (p[i].s == p[lq].s) cnt++; // 统计后续同分
  }
  ```

---

### 最优思路提炼
1. **下标排序技巧**：通过排序下标而非结构体，减少内存占用。
2. **反向遍历边界**：从数组末尾反向遍历，快速确定录取人数上限。
3. **同分合并统计**：显式统计后续同分选手，避免重复遍历。

---

### 类似题目推荐
1. **P1093 奖学金**：多条件排序后取前N名。
2. **P1781 总统选举**：按投票规则排序并统计结果。
3. **P1051 谁拿了最多奖学金**：综合多条件排序与统计。

---

### 代码实现（题解1核心）
```cpp
#include<bits/stdc++.h>
using namespace std;
int i, n, m, f, k[5001], s[5001], sub[5001];
bool cmp(int a, int b) {
    if (s[a] == s[b]) return k[a] < k[b];
    return s[a] > s[b];
}
int main() {
    cin >> n >> m;
    for (i = 1; i <= n; i++) cin >> k[sub[i] = i] >> s[i];
    sort(sub + 1, sub + n + 1, cmp);
    f = s[sub[int(m * 1.5)]];
    for (i = 1; s[sub[i]] >= f; i++); // 统计达标人数
    cout << f << " " << i - 1 << endl;
    for (i = 1; s[sub[i]] >= f; i++) 
        cout << k[sub[i]] << " " << s[sub[i]] << endl;
}
```

---

### 可视化实现要点
1. **Canvas绘制**：用网格表示选手，每格显示分数和编号，排序时交换动画。
2. **音效触发**：排序完成时播放上扬音效，统计达标选手时播放“选中”音效。
3. **交互控制**：支持暂停/继续，拖动进度条调整动画速度。

---
处理用时：140.35秒
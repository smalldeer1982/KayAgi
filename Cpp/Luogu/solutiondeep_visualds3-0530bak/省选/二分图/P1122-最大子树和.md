# 题目信息

# 最大子树和

## 题目描述

小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：

一株奇怪的花卉，上面共连有 $n$ 朵花，共有 $n-1$ 条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。

老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。

## 说明/提示

### 数据范围及约定

- 对于 $60\%$ 的数据，有 $1\le n\le 1000$；
- 对于 $100\%$ 的数据，有 $1\le n\le 16000$。

## 样例 #1

### 输入

```
7
-1 -1 -1 1 1 1 0
1 4
2 5
3 6
4 7
5 7
6 7
```

### 输出

```
3```

# AI分析结果



## 算法分类
树形动态规划（树形DP）

---

## 题解思路与算法要点

### 核心算法逻辑
1. **状态定义**  
   - `f[u]` 表示以节点 `u` 为根的子树中，包含 `u` 的最大权值和  
   - **关键推导**：子树必须连通，若子节点 `v` 的 `f[v] > 0` 则保留该分支，否则剪枝  
   - **状态转移方程**：  
     $$ f[u] = a[u] + \sum_{v \in son(u)} \max(0, f[v]) $$

2. **实现步骤**  
   - 构建无向树的邻接表（双向边）  
   - 递归遍历树，回溯时计算每个节点的 `f[u]`  
   - 全局变量记录所有 `f[u]` 的最大值  

### 解决难点对比
| 题解对比点              | Mutsumi_0114 (五星)                     | FCBM71 (四星)                            | StoneXie (三星)                         |
|---------------------|----------------------------------------|-----------------------------------------|-----------------------------------------|
| **状态设计**           | 单一状态 `f[u]`，简洁清晰                    | 双状态 `fy/fn`，同步更新不包含根的子树          | 初始错误尝试暴力枚举根节点，修正后正确               |
| **数据结构**           | 使用 `vector` 存边                        | 链式前向星优化空间                          | 邻接表存边                                |
| **遍历优化**           | 一次DFS遍历，时间复杂度 O(n)                | 递归中维护两个状态，避免二次遍历                 | 早期错误实现多根遍历导致超时，修正后单次DFS          |
| **初始化处理**         | `f[u]` 初始化为节点权值，自然处理负值            | `fn` 初始化为极小值，处理全负数情况              | 初始未考虑剪枝逻辑，修正后正确                   |

---

## 题解评分（≥4星）

### 五星题解：Mutsumi_0114
- **亮点**：  
  ① 状态定义简洁，单次DFS完成计算  
  ② 代码可读性强，适合初学者理解树形DP核心思想  
  ③ 图示辅助说明样例，直观展示剪枝过程  

### 四星题解：FCBM71
- **亮点**：  
  ① 双状态设计同步更新，避免二次遍历  
  ② 使用链式前向星优化空间，适合大数据量场景  
  ③ 包含调试技巧（如 `tomax` 加速）  

### 四星题解：Tomwsc
- **亮点**：  
  ① 二维状态 `dp[u][0/1]` 明确区分包含/不包含根的情况  
  ② 严格证明状态转移正确性，适合进阶学习  

---

## 最优思路与技巧提炼

### 关键算法技巧
1. **贪心剪枝决策**  
   子树的贡献值为正时才保留，否则直接剪枝，通过 `max(0, f[v])` 实现  
2. **树形DP遍历范式**  
   ```cpp
   void dfs(int u, int fa) {
       f[u] = a[u];
       for (auto v : tree[u]) {
           if (v == fa) continue;
           dfs(v, u);
           if (f[v] > 0) f[u] += f[v];
       }
       ans = max(ans, f[u]);
   }
   ```
3. **邻接表优化**  
   使用 `vector` 或链式前向星高效存储树结构，避免重复访问父节点  

### 调试与优化经验
- **数组越界**：双向边需开双倍空间（如 `lavd` 题解因未处理导致MLE）  
- **全负数处理**：初始化 `ans` 为极小值，避免全负时输出错误  
- **遍历顺序**：DFS需传入父节点参数防止回环  

---

## 同类型题与算法套路

### 通用解法
- **树形DP三要素**：  
  1. 状态定义（必含根节点或可选根节点）  
  2. 递归遍历与回溯更新  
  3. 剪枝策略（如本题的 `max(0, f[v])`）  

### 推荐题目
1. **P1352 没有上司的舞会**  
   - 状态设计：`dp[u][0/1]` 表示选/不选节点 `u` 的最大值  
2. **P2015 二叉苹果树**  
   - 状态设计：`dp[u][k]` 表示以 `u` 为根保留 `k` 条边的最大苹果数  
3. **P1273 有线电视网**  
   - 状态设计：`dp[u][k]` 表示以 `u` 为根服务 `k` 个用户的最大收益  

---

## 个人心得摘录

### 调试与优化
- **StoneXie**：  
  > “早期尝试暴力枚举每个节点作为根，导致超时。修正后意识到只需一次DFS计算所有节点的 `f[u]`”  
- **lavd**：  
  > “二维数组 `f[16002][16002]` 导致MLE，改为动态规划后AC”  

### 思维突破
- **Mutsumi_0114**：  
  > “任何连通分量都可视为某棵子树，因此无需固定根节点，遍历所有 `f[u]` 即可”  

---

## 可视化算法演示

### 动画设计
1. **核心流程**  
   - **树结构展示**：Canvas绘制节点与边，初始为灰色  
   - **DFS过程**：当前节点高亮为蓝色，递归子节点时显示绿色箭头  
   - **剪枝决策**：若 `f[v] > 0`，子节点变为绿色并显示 `+f[v]`；否则变红并显示 `×0`  

2. **动态更新**  
   - 节点数值实时更新为 `f[u]`，字体颜色随正负变化（绿/红）  
   - 回溯时显示当前子树和，全局 `ans` 始终显示在画布顶部  

3. **复古像素风格**  
   - **颜色方案**：16色调色板，节点为8位像素方块，边为点阵线  
   - **音效设计**：  
     - 正数累加：短促“哔”声  
     - 剪枝：低沉“咔”声  
     - 更新全局答案：胜利音效  

### 交互功能
- **控制面板**：  
  - 播放/暂停、步进、重置  
  - 调节动画速度（1x~5x）  
- **自动演示模式**：  
  AI按DFS顺序自动遍历，辅以音效提示关键操作  

---

## 核心代码实现（Mutsumi_0114版）

```cpp
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 16005;
vector<int> tree[MAXN];
int a[MAXN], f[MAXN], ans = -0x7fffffff;

void dfs(int u, int fa) {
    f[u] = a[u];
    for (int v : tree[u]) {
        if (v == fa) continue;
        dfs(v, u);
        if (f[v] > 0) f[u] += f[v];
    }
    ans = max(ans, f[u]);
}

int main() {
    int n; scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
    for (int i = 1; i < n; ++i) {
        int u, v; scanf("%d%d", &u, &v);
        tree[u].push_back(v);
        tree[v].push_back(u);
    }
    dfs(1, 0);
    printf("%d", ans);
    return 0;
}
```

---
处理用时：93.50秒
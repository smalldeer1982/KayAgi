# 题目信息

# 酒店之王

## 题目描述

XX 酒店的老板想成为酒店之王，本着这种希望，第一步要将酒店变得人性化。由于很多来住店的旅客有自己喜好的房间色调、阳光等，也有自己所爱的菜，但是该酒店只有 $p$ 间房间，一天只有固定的 $q$ 道不同的菜，每个房间只能住一位客人，每道菜也只能给一位客人食用。

有一天来了 $n$ 个客人，每个客人说出了自己喜欢哪些房间，喜欢哪道菜。但是很不幸，可能做不到让所有顾客满意（满意的条件是住进喜欢的房间且吃到喜欢的菜）。

要怎么分配，能使最多顾客满意呢？

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n,p,q \leq 100$。

## 样例 #1

### 输入

```
2 2 2
1 0
1 0
1 1
1 1
```

### 输出

```
1```

# AI分析结果



# 【唯一算法分类】
网络最大流（拆点建模）

---

## 【题解思路与算法要点】
### 核心思路
题目要求同时满足房间与菜的双重匹配，需通过拆点限制每个客人仅匹配一次。将客人拆为入点与出点，中间连容量1的边，构建如下网络流模型：
- **超级源点S** → 房间节点（容量1）
- **房间节点** → 客人入点（若客人喜欢该房间）
- **客人入点** → 客人出点（容量1）
- **客人出点** → 菜品节点（若客人喜欢该菜）
- **菜品节点** → 超级汇点T（容量1）

### 解决难点
1. **防止重复匹配**：拆点后，中间边容量1强制每个客人仅被选中一次。
2. **同步匹配逻辑**：需保证同一客人的房间与菜匹配同时成立，网络流的流量传递自然实现同步性。
3. **高效建模**：通过分层建图将三维匹配问题转化为标准最大流问题。

---

## 【题解评分（≥4星）】
1. **Godのfather（5星）**  
   - 亮点：图文并茂解析拆点必要性，EK算法实现清晰，反向边处理巧妙。
2. **钱逸凡（5星）**  
   - 亮点：双版本代码（EK/Dinic），拆点逻辑简洁，注释明确。
3. **YoungNeal（4星）**  
   - 亮点：Dinic实现高效，博客链接补充详细，拆点思路直观。

---

## 【最优思路与技巧提炼】
- **拆点技巧**：将客人拆为两个节点，中间连边限制流量，确保唯一性。
- **反向边处理**：使用邻接表存储边时，利用`tot=1`起始与`^1`快速定位反向边。
- **同步匹配**：网络流自动保证房间与菜的双重匹配合法性，无需额外检查。
- **分层BFS优化**：Dinic算法通过分层图加速增广路径查找。

---

## 【同类型题与算法套路】
- **类似问题**：教辅的组成（P1231）、圆桌问题（P3254）
- **通用解法**：处理多维匹配时，通过拆点或分层图将问题转化为标准网络流模型。

---

## 【推荐相似题目】
1. P1231（教辅的组成）  
2. P3254（圆桌问题）  
3. P2763（试题库问题）

---

## 【代码实现（Dinic版）】
```cpp
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int INF = 0x3f3f3f3f, MAXN = 405;

struct Edge {
    int to, cap, rev;
    Edge(int t, int c, int r) : to(t), cap(c), rev(r) {}
};

vector<Edge> G[MAXN];
int level[MAXN], iter[MAXN];

void addEdge(int from, int to, int cap) {
    G[from].emplace_back(to, cap, G[to].size());
    G[to].emplace_back(from, 0, G[from].size()-1);
}

bool bfs(int s, int t) {
    memset(level, -1, sizeof(level));
    queue<int> q;
    level[s] = 0; q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto &e : G[u]) {
            if (e.cap > 0 && level[e.to] == -1) {
                level[e.to] = level[u] + 1;
                q.push(e.to);
            }
        }
    }
    return level[t] != -1;
}

int dfs(int u, int t, int f) {
    if (u == t) return f;
    for (int &i = iter[u]; i < G[u].size(); ++i) {
        Edge &e = G[u][i];
        if (e.cap > 0 && level[e.to] == level[u] + 1) {
            int d = dfs(e.to, t, min(f, e.cap));
            if (d > 0) {
                e.cap -= d;
                G[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

int maxFlow(int s, int t) {
    int flow = 0;
    while (bfs(s, t)) {
        memset(iter, 0, sizeof(iter));
        int f;
        while ((f = dfs(s, t, INF)) > 0) 
            flow += f;
    }
    return flow;
}

int main() {
    int n, p, q;
    scanf("%d%d%d", &n, &p, &q);
    
    // 节点编号：房间1~p，客人入p+1~p+n，客人出p+n+1~p+2n，菜p+2n+1~p+2n+q
    int S = 0, T = p + 2*n + q + 1;
    
    // 超级源连接房间
    for (int i = 1; i <= p; ++i) 
        addEdge(S, i, 1);
    
    // 客人拆点
    for (int i = 1; i <= n; ++i) 
        addEdge(p + i, p + n + i, 1);
    
    // 房间→客人入点
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= p; ++j) {
            int x; scanf("%d", &x);
            if (x) addEdge(j, p + i, 1);
        }
    }
    
    // 客人出点→菜品
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= q; ++j) {
            int x; scanf("%d", &x);
            if (x) addEdge(p + n + i, p + 2*n + j, 1);
        }
    }
    
    // 菜品→超级汇
    for (int j = 1; j <= q; ++j) 
        addEdge(p + 2*n + j, T, 1);
    
    printf("%d\n", maxFlow(S, T));
    return 0;
}
```

---

## 【可视化设计】
### 动画方案
1. **节点布局**：  
   - 左侧垂直排列房间节点（红色方块）  
   - 中间分两列显示客人入点（蓝色）与出点（绿色）  
   - 右侧垂直排列菜品节点（黄色）  
   - 超级源（S）与汇（T）分列左右边缘

2. **流动效果**：  
   - 增广路径显示为流动光带，当前操作边高亮闪烁  
   - 拆点中间的边变为金色，流量耗尽时变灰

3. **状态面板**：  
   - 实时显示各节点流量、层次深度（Dinic层级）  
   - 增广路径计数器与总流量更新

### 8位像素风格
- **调色板**：红（房间）、蓝绿（客人）、黄（菜品）、白（S/T）
- **音效**：  
  - 水流声（每次增广）  
  - 成功音（找到路径）  
  - 错误提示音（无路可走）
- **自动演示**：按BFS分层逐步推进，模拟水流扩散过程

---

## 【总结】
通过拆点建模将复杂约束转化为标准网络流问题，结合分层优化算法可高效解决。该思路可扩展至任何需要多重资源匹配的场景，是网络流建模的经典技巧。

---
处理用时：80.45秒
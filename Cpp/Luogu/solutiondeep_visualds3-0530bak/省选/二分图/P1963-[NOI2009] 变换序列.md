# 题目信息

# [NOI2009] 变换序列

## 题目描述

对于 $N$ 个整数 $0, 1, \cdots, N-1$，一个变换序列 $T$ 可以将 $i$ 变成 $T_i$，其中 $T_i \in \{ 0,1,\cdots, N-1\}$ 且 $\bigcup_{i=0}^{N-1} \{T_i\} = \{0,1,\cdots , N-1\}$。$\forall x,y \in  \{0,1,\cdots , N-1\}$，定义 $x$ 和 $y$ 之间的距离 $D(x,y)=\min\{|x-y|,N-|x-y|\}$。给定每个 $i$ 和 $T_i$ 之间的距离 $D(i,T_i)$，你需要求出一个满足要求的变换序列 $T$。如果有多个满足条件的序列，输出其中字典序最小的一个。

说明：对于两个变换序列 $S$ 和 $T$，如果存在 $p<N$，满足对于 $i=0,1,\cdots p-1$，$S_i=T_i$ 且 $S_p<T_p$，我们称 $S$ 比 $T$ 字典序小。

## 说明/提示

- 对于 $30\%$ 的数据，满足：$N \le 50$；
- 对于 $60\%$ 的数据，满足：$N \le 500$；
- 对于 $100\%$ 的数据，满足：$N \le 10 ^ 4$。


## 样例 #1

### 输入

```
5
1 1 2 2 1
```

### 输出

```
1 2 4 0 3```

# AI分析结果



## 算法分类
二分图匹配（匈牙利算法）

## 综合分析与结论
### 题目核心思路
1. **问题转化**：每个位置i对应的T_i有2种可能（环状距离），构建二分图。左边为i，右边为可能的T_i值。
2. **匈牙利算法**：寻找完美匹配，保证每个i都有对应的T_i。
3. **字典序最小**：倒序处理i（从n-1到0），优先选择更小的T_i值，通过调整增广路径确保前面的i占据更优解。

### 解决难点
- **字典序控制**：常规匈牙利算法正序处理会导致后面的i影响前面的结果。倒序处理使每个i优先占据更小的T_i，且不会破坏已处理的i的匹配。
- **度数限制**：每个i仅有两条边，形成环结构。倒序处理可确保环上匹配唯一且字典序最优。

### 可视化设计
- **动画流程**：
  1. 显示二分图结构，i与两个T_i相连。
  2. 倒序处理每个i（如i=4→0），高亮当前i的邻接点。
  3. 若目标T_i未匹配，直接连接；否则DFS回溯调整匹配，显示增广路径。
- **复古像素风**：
  - 用8位色块表示节点，匹配成功的边用绿色，冲突边用红色。
  - 音效：匹配成功时播放清脆音效，回溯时播放低音提示。
- **交互控制**：支持步进/暂停，显示当前i和匹配状态变化。

## 题解评分（≥4星）
1. **作者：10000point（5星）**  
   - 深入分析倒序有效的条件（度数≤2），证明环结构的唯一性，提供通解思路。
2. **作者：Nemlit（4.5星）**  
   - 清晰解释逆向思维，代码简洁，邻接表排序优化字典序。
3. **作者：panda_2134（4星）**  
   - 强调匈牙利算法的本质与字典序关系，代码结构规范。

## 最优思路提炼
1. **邻接表排序**：每个i的邻接点按值升序排列，保证优先匹配更小的T_i。
2. **倒序匈牙利**：从最大i开始处理，确保前面的i（字典序更靠前）优先占据更小值。
3. **环结构处理**：每个连通块为基环树，环上匹配方向唯一确定字典序。

## 相似题目推荐
1. **P3386 二分图最大匹配**（基础匈牙利算法）
2. **P1640 [SCOI2010]连续攻击游戏**（二分图匹配+贪心）
3. **P2764 最小路径覆盖**（DAG与二分图转换）

## 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+5;
vector<int> G[N];
int match[N],vis[N],ans[N],n;

bool dfs(int u){
    for(int v:G[u]){
        if(vis[v]) continue;
        vis[v]=1;
        if(match[v]==-1 || dfs(match[v])){
            match[v]=u, ans[u]=v;
            return true;
        }
    }
    return false;
}

int main(){
    scanf("%d",&n);
    for(int i=0,d;i<n;i++){
        scanf("%d",&d);
        int a=(i-d+n)%n, b=(i+d)%n;
        if(a>b) swap(a,b);  // 邻接表排序
        G[i].push_back(a);
        G[i].push_back(b);
    }
    memset(match,-1,sizeof(match));
    for(int i=n-1;i>=0;i--){  // 倒序处理
        memset(vis,0,sizeof(vis));
        if(!dfs(i)){ puts("No Answer"); return 0; }
    }
    for(int i=0;i<n;i++) printf("%d ",ans[i]);
}
```

## 可视化代码片段（Canvas动画）
```javascript
// 伪代码：绘制二分图匹配过程
function drawStep(i) {
    ctx.clearRect(0, 0, width, height);
    // 绘制所有节点
    nodes.forEach((node, idx) => {
        ctx.fillStyle = (idx === i) ? '#FF0000' : '#00FF00'; // 当前i高亮红色
        ctx.fillRect(node.x, node.y, 20, 20);
    });
    // 绘制匹配边
    edges.forEach(edge => {
        ctx.strokeStyle = (edge.from === i) ? '#0000FF' : '#CCCCCC';
        ctx.beginPath();
        ctx.moveTo(edge.from.x, edge.from.y);
        ctx.lineTo(edge.to.x, edge.to.y);
        ctx.stroke();
    });
}
// 触发音效
function playSound(type) {
    const audio = new Audio(type === 'match' ? 'success.wav' : 'backtrack.wav');
    audio.play();
}
```

---
处理用时：74.13秒
# 题目信息

# [HNOI2013] 消毒

## 题目描述


最近在生物实验室工作的小 T 遇到了大麻烦。 由于实验室最近升级的缘故，他的分格实验皿是一个长方体，其尺寸为 $a\times b\times c$。为了实验的方便，它被划分为 $a\times b\times c$ 个单位立方体区域，每个单位立方体尺寸为 $1\times 1\times 1$，并用 $(i,j,k)$ 标识一个单位立方体。这个实验皿已经很久没有人用了。现在，小 T 被导师要求将其中一些单位立方体区域进行消毒操作（每个区域可以被重复消毒）。

而由于严格的实验要求，他被要求使用一种特定的 F 试剂来进行消毒。 这种 F 试剂特别奇怪，每次对尺寸为 $x\times y\times z$ 的长方体区域（它由 $x\times y\times z$ 个单位立方体组成）进行消毒时，只需要使用 $\min(x,y,z)$ 单位的 F 试剂。F 试剂的价格不菲，这可难倒了小 T。

现在请你告诉他，最少要用多少单位的 F 试剂。

## 说明/提示

#### 样例 1 解释
对于区域 $(1,1,3)-(2,2,4)$ 和 $(1,1,1)-(4,4,1)$ 消毒，分别花费 $2$ 个单位和 $1$ 个单位的 F 试剂。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le a,b,c\le 5\times 10^3$，$abc\le 5\times 10^3$，且 $1\le D\le 3$。


## 样例 #1

### 输入

```
1
4  4 4
1  0 1 1
0  0 1 1
0  0 0 0
0  0 0 0
0  0 1 1
1  0 1 1
0  0 0 0
0  0 0 0
0  0 0 0
0  0 0 0
1  0 0 0
0  0 0 0
0  0 0 0
0  0 0 0
0  0 0 0
1  0 0 0```

### 输出

```
3```

# AI分析结果



### 算法分类
二分图匹配 + 状态压缩

---

### 题解思路与核心难点

**核心思路**：
1. **三维转二维**：利用最小维度 ≤17 的特性，暴力枚举该维度的每一层是否直接消毒（花费1）
2. **二分图匹配**：将未被直接消毒的层拍扁为二维平面，转化为行与列的最小点覆盖问题
3. **匈牙利算法**：高效求解二分图最大匹配，时间复杂度 O(n^3) 但数据范围可接受

**解决难点**：
1. **维度处理**：动态交换维度确保枚举的是最小值维度
2. **状态压缩**：使用位运算高效枚举层选择状态
3. **动态建图**：根据枚举状态动态构建二分图邻接表

---

### 题解评分（≥4星）

1. **poorpool (★★★★☆)**  
   - 思路清晰，完整推导三维转二维的过程  
   - 代码包含维度交换与位运算优化  
   - 匈牙利算法实现简洁，可读性高

2. **xyz32768 (★★★★☆)**  
   - 采用DFS优化枚举过程  
   - 使用邻接表动态构建图结构  
   - 包含实用位运算优化技巧

3. **凑个热闹吖 (★★★★★)**  
   - 使用边权标记层编号避免重复建图  
   - 实现当前最优解的代码结构  
   - 包含详细的代码注释与理论推导

---

### 最优思路提炼

1. **维度压缩策略**  
   ```python
   if min(a,b,c) == b: swap(a,b)
   elif min(a,b,c) == c: swap(a,c)
   ```
   确保总是枚举最小维度

2. **状态枚举优化**  
   ```cpp
   for(int i=0; i<(1<<a); i++)
       work(i); // 枚举每个二进制位表示是否选择该层
   ```

3. **动态邻接表构建**  
   ```cpp
   for(int i=1; i<=tot; i++)
       if(qwq[sx[1][i]]) // 过滤已选层
           add_edge(sx[2][i], sx[3][i]);
   ```

---

### 核心代码实现

**状态枚举与匈牙利算法核心**：
```cpp
void work(int x) {
    int cnt = 0;
    memset(selected, 0, sizeof(selected));
    // 标记已选层
    for(int i=0; i<a; i++)
        if(x & (1<<i)) selected[i+1] = true, cnt++;
    
    // 构建邻接表
    for(int i=1; i<=n; i++) {
        if(selected[layer[i]]) continue;
        add_row_col(row[i], col[i]);
    }
    
    // 匈牙利算法求最大匹配
    int match_cnt = 0;
    for(int i=1; i<=max_row; i++) {
        memset(vis, 0, sizeof(vis));
        if(dfs(i)) match_cnt++;
    }
    
    ans = min(ans, cnt + match_cnt);
}
```

---

### 可视化设计

**8位像素风格演示**：
1. **三维层选择**：用不同颜色方块表示已选层（红色）和待处理层（蓝色）
2. **二维投影**：将未选层投影为网格平面，黄色方块表示待覆盖点
3. **匹配过程**：动态显示行（绿色）与列（紫色）的覆盖过程，成功匹配时播放 "ping" 音效
4. **状态面板**：显示当前枚举状态（二进制数）、已用试剂数、剩余匹配数

**动画控制**：
```javascript
class Visualizer {
    constructor() {
        this.speed = 500; // 动画速度（ms/步）
        this.layers = new PixelGrid(17, 1); // 17层枚举状态显示
        this.projection = new PixelGrid(500, 500); // 二维投影
        this.sfx = new RetroSFX(); // 8位音效库
    }
    
    updateSelection(mask) {
        this.layers.highlightBits(mask); // 高亮已选层
        this.projection.generatePoints(mask); // 生成投影点
        this.sfx.playLayerSelect();
    }
    
    showMatching() {
        let steps = hungarianSteps(); // 获取匹配步骤
        steps.forEach(step => {
            this.projection.drawEdge(step.row, step.col);
            if(step.matched) this.sfx.playMatch();
            wait(this.speed);
        });
    }
}
```

---

### 相似题目推荐

1. [P1967 货车运输](https://www.luogu.com.cn/problem/P1967)  
   **相似点**：图论问题中的维度压缩与路径优化

2. [P3386 二分图最大匹配](https://www.luogu.com.cn/problem/P3386)  
   **相似点**：匈牙利算法模板题

3. [P1896 互不侵犯](https://www.luogu.com.cn/problem/P1896)  
   **相似点**：状态压缩与位运算优化

---

### 心得总结

1. **维度交换**是处理多维问题的关键技巧，能大幅简化代码逻辑
2. **邻接表动态构建**相比静态数组更节省内存，适应不同测试用例
3. **位运算枚举**时注意层号与二进制位的对应关系（+1偏移）
4. **匈牙利算法的vis数组**使用时间戳优化比memset更高效

---

### 算法演示

**复古像素演示步骤**：
1. 初始化显示三维立方体，标记需要消毒的单位
2. 左侧显示17个垂直方块表示可枚举层
3. 枚举每个二进制状态时：
   - 红色方块表示选中层
   - 蓝色方块投影到右侧二维网格
4. 在二维投影中：
   - 绿色箭头表示行选择
   - 紫色箭头表示列选择
   - 黄色闪光表示成功匹配
5. 最终显示最小试剂数，播放胜利音效

**音效设计**：
- 层选择：短促 "beep"
- 成功匹配：高音 "ping"
- 计算完成：经典FC过关音乐

---
处理用时：67.23秒
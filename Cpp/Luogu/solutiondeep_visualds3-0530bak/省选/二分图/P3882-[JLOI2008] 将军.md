# 题目信息

# [JLOI2008] 将军

## 题目描述

刘先生最近在学习国际象棋，使用一个叫 jloi-08 的游戏软件。在这个游戏里，不但可以和电脑普通地对弈，还可以学习著名的棋局，还有针对初学者的规则指导等丰富功能。但是…大小却要 1.4G T\_T。

言归正传，在这个软件里，为了让玩家更好地理解和运用各个棋子，有很多趣味的游戏，比如以下就是一个：

给出一个棋盘和一些棋子，让你把这些棋子摆放在棋盘上，使得两两不互相攻击。你的得分由你摆放上去的棋子的个数与种类有关。

这个游戏很复杂，刘先生老是玩不到高分。于是电脑便降低了难度，替刘先生摆上了一些棋子，最后只给你任意多个 bishop（教主）。

现在刘先生便要考一考你，在电脑给出的这张棋盘上，最多能放几个 bishop。

国际象棋中一共有 6 种棋子：

- king（国王）；
- queen（皇后）；
- bishop（教主）；
- knight（骑士）；
- rook（车）；
- pawn（步兵）。

各棋子的攻击范围如下：

- queen 可以攻击与它在同一行，同一列，同一条对角线的棋子；
- knight 的攻击范围如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/2669.png)

- rook 攻击水平和垂直两条线上的所有格子；
- pawn 攻击前方两条斜线方向各一格(“前方”指 $x$ 递增的方向，$x$ 行 $y$ 列）；
- king 攻击周围 8 个方向各 1 格；
- bishop 攻击两条对角线上的所有格子。

除 knight 以外，所有棋子的攻击范围均会被别的棋子所阻挡。

可惜的是这个软件也不是顶优秀，给出的棋盘上的棋子可能互相会攻击，不过你不用理会这些，你只要保证你摆放的 bishop 不与它们以及不互相攻击就可以了。

## 说明/提示

```plain
BBN
...
...
```

```plain
BBN
...
B..
```

虽然看上去下面的方法比上面的优秀，但是 N 被第三行的 B 攻击了。也就是说，你需要避免的有 2 种情况： 你摆放的 bishop 之间的互相攻击以及你摆放的 bishop 与预先摆放好的棋子之间的互相攻击；但不用考虑预先摆放好的棋子之间的互相攻击。


## 样例 #1

### 输入

```
3 3
..N
...
...
```

### 输出

```
2```

# AI分析结果



## 算法分类
**二分图最大匹配**

---

## 综合分析与结论
### 核心思路
所有题解的核心思路均为：将棋盘旋转45°后，将可放置的格子视为二分图边，求最大匹配数。关键步骤如下：

1. **预处理攻击范围**  
   - 遍历原有棋子，标记所有被攻击的格子（包括被其他棋子阻挡的情况）
   - 特殊处理各棋类攻击逻辑（如车的直线攻击、骑士的跳跃攻击等）

2. **棋盘旋转与二分图建模**  
   - 将坐标转换至旋转后的坐标系（原对角线变为行列）
   - 每个可放置格子对应两种对角线（旋转后的行和列），建立二分图边

3. **匈牙利算法求解**  
   - 通过匈牙利算法求二分图的最大匹配，结果即为最大可放置的bishop数

### 解决难点
1. **攻击范围的正确标记**  
   - 需处理不同棋子的攻击规则（如阻挡机制、跳跃攻击）
   - 需要额外标记bishop攻击范围（题目要求新放置的bishop不能攻击原有棋子）

2. **旋转坐标系的映射**  
   - 通过数学公式将原坐标映射到旋转后的行列坐标系  
   - 典型映射方式：行号`i+j-1`，列号`n-i+j`

3. **高效二分图建模**  
   - 部分题解使用链式前向星优化建边
   - 部分题解通过预处理行/列攻击链来简化建图

---

## 题解评分（≥4星）
1. **GNAQ（★★★★☆）**  
   - 简洁高效的匈牙利算法实现  
   - 使用旋转坐标系直接建图，代码逻辑清晰  
   - 预处理函数（`GoB/GoK/GoQ`）封装良好

2. **caizehua（★★★★☆）**  
   - 详细解释棋盘旋转与行列标记规则  
   - 使用`can`状态码标记格子可用性，便于调试  
   - 完整注释和分步图解

3. **WFHFAQFXY（★★★★☆）**  
   - 独立设计预处理函数（`bishop/rook`等）  
   - 显式处理`b1`和`b2`参数，逻辑直观  
   - 包含同类型题推荐，扩展性强

---

## 最优思路提炼
### 关键技巧
1. **棋盘旋转与二分图转换**  
   ```cpp
   // 原坐标(i,j) → 旋转后行列坐标
   int rotated_row = i + j - 1;
   int rotated_col = n - i + j;
   ```
2. **匈牙利算法优化**  
   - 使用时间戳代替`vis`数组重置  
   - 链式前向星存储邻接表

3. **攻击范围预处理**  
   ```cpp
   // 示例：处理车的攻击范围
   void Rook(int x, int y) {
       for (int i =x-1; i>=1; i--) if (阻挡) break; else 标记攻击;
       // 类似处理其他三个方向
   }
   ```

---

## 同类题目推荐
1. [P2825 游戏](https://www.luogu.com.cn/problem/P2825)  
   （行列攻击链建模+二分图匹配）

2. [P6062 模拟攻击](https://www.luogu.com.cn/problem/P6062)  
   （类似棋盘覆盖问题）

3. [P10945 车放置](https://www.luogu.com.cn/problem/P10945)  
   （行列独立性的经典问题）

---

## 可视化设计
### 算法演示方案
1. **棋盘旋转动画**  
   - 初始显示原棋盘，逐步旋转45°并标注行列编号  
   - 高亮可放置格子的旋转后坐标

2. **二分图匹配过程**  
   ```javascript
   // 伪代码示例：动态显示匹配过程
   function drawMatching(step) {
       highlight(当前尝试匹配的行节点);
       for (let edge of 当前行的边) {
           if (边未被匹配) 显示闪烁效果;
       }
       if (找到增广路径) 播放成功音效;
   }
   ```

3. **复古像素风格**  
   - 使用16色调色板（如#FF6B6B红、#4ECDC4青）  
   - Canvas绘制8位风格的棋盘和棋子  
   - 音效设计：  
     - 放置bishop时播放“哔”声  
     - 匹配失败时播放短促“滴”声

### 交互功能
- **速度调节滑块**：控制匈牙利算法的执行速度  
- **单步执行按钮**：观察每一轮DFS的详细过程  
- **攻击范围开关**：动态显示不同棋子的攻击范围

---

## 核心代码实现（GNAQ版）
```cpp
void BuildG() {
    int _x, _y;
    for (int i=1; i<=n; i++)
        for (int j=1; j<=m; j++) 
            if (!av[i][j]) {
                _x = pau[i][0] + j - 1; // 旋转后的行坐标
                _y = pau[i][1] + j - 1; // 旋转后的列坐标
                if (!h[_x] && !l[_y]) 
                    Insert(_x, _y + mapsiz); // 建边
            }
}

int main() {
    // 预处理攻击范围
    for (每个棋子) {
        switch (类型) {
            case 'K': GoK(i,j); break;
            case 'Q': GoQ(i,j); break;
            // 其他类型处理
        }
    }
    BuildG(); // 建图
    // 匈牙利算法
    for (int i=1; i<=mapsiz; i++) 
        ansf += Find(i, i);
    printf("%d\n", ansf);
}
```

---
处理用时：69.85秒
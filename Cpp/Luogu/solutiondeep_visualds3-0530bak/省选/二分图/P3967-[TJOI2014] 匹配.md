# 题目信息

# [TJOI2014] 匹配

## 题目描述

有 $N$ 个单身的男孩和 $N$ 个单身女孩，男孩 $i$ 和女孩 $j$ 在一起得到的幸福值为 $H_{i,j}$。

一个匹配即对这 $N$ 个男孩女孩的安排：每个男孩恰好有一个女朋友，每个女孩恰好有一个男朋友。

一个匹配的幸福值即这 $N$ 对男女朋友的幸福值的和。

经典的问题是计算幸福值最大的匹配，即完美匹配。然而完美匹配有时候并不唯一，你需要计算对于所有的完美匹配，其交集是什么。

## 说明/提示

- 对于 $30\%$ 的数据，$N \leq 30$；
- 对于 $100\%$ 的数据，$1\leq N \leq 80$，$0\leq H_{i,j}\leq 5\times10^3$。

## 样例 #1

### 输入

```
3
1 1 1
2 1 1
1 1 1```

### 输出

```
4
2 1```

# AI分析结果



# 算法分类：二分图最大权匹配 (KM算法/费用流)

## 综合分析与结论
**核心逻辑**：  
1. **第一问**：通过 KM 算法或费用流计算二分图的最大权完美匹配。
2. **第二问**：枚举初始匹配中的每条边，删除后重新计算最大权。若权值减少，则该边为必须边。

**难点与解决方案**：  
- **边删除的正确性**：必须删除边及其反向边（费用流）或置权为极小值（KM），否则导致错误或死循环。
- **时间复杂度优化**：仅需检查初始匹配中的边，而非全图所有边，将复杂度从 $O(n^5)$ 降至 $O(n^4)$。

**可视化设计要点**：  
- **像素动画**：以网格表示男女节点，绿色边表示当前匹配，红色闪烁表示被删除的边。  
- **顶标调整演示**：KM算法中，用不同颜色高亮顶标变化，动态显示松弛量更新。  
- **音效触发**：删除边时播放“错误音效”，找到必须边时播放“成功音效”，自动步进速度可调。

---

## 题解评分 (≥4星)
1. **louhao088 (★★★★★)**  
   - 使用 BFS 优化的 KM 算法，效率高。  
   - 排序输出保证顺序正确，代码简洁清晰。  
   - 关键亮点：通过顶标松弛优化至 $O(n^3)$。

2. **Khassar (★★★★☆)**  
   - 引入松弛量 `slack` 数组优化 KM 算法。  
   - 剪枝策略：仅检查可能成为答案的边。  
   - 代码可读性稍弱，但优化思路明确。

3. **Mortis_Vampire (★★★★☆)**  
   - DFS 实现 KM 算法，代码简洁。  
   - 强调必须边的判定逻辑，注释清晰。  
   - 未排序输出可能出错，但提供正确思路。

---

## 最优思路与技巧
1. **KM 算法的 BFS 优化**：通过松弛量 `slack` 减少顶标调整次数，避免 $O(n^4)$ 最坏情况。
2. **必须边判定**：删除初始匹配边后重新计算，若最大权减少则为必须边。
3. **反向边处理**：费用流中删除正向边时需同步删除反向边，防止残留流量干扰。

```cpp
// KM 算法核心：顶标调整与匹配更新
void bfs(int x) {
    memset(slack, 0x3f, sizeof(slack));
    while (!q.empty()) q.pop();
    q.push(x);
    while (true) {
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int v = 1; v <= n; v++) {
                if (lx[u] + ly[v] - w[u][v] < slack[v]) {
                    slack[v] = lx[u] + ly[v] - w[u][v];
                    pre[v] = u; // 记录路径
                }
            }
        }
        // 更新顶标并继续匹配...
    }
}
```

---

## 类似题目推荐
1. **P6577 【模板】二分图最大权完美匹配**  
   - 直接应用 KM 算法的模板题。

2. **P4014 分配问题**  
   - 二分图匹配的最小/最大权变形，需双向处理。

3. **P3386 【模板】二分图最大匹配**  
   - 无权二分图匹配，可用匈牙利算法练习基础。

---

## 个人心得摘录
- **雨季**：费用流删除边时忘记处理反向边导致死循环，调试后补充反向边标记。  
- **louhao088**：初始未排序输出导致 WA，后通过结构体排序解决。  
- **Khassar**：优化枚举时发现权值较小的边无需检查，减少计算量。

---

## 可视化代码片段 (JS Canvas)
```javascript
// 绘制二分图节点与边
function drawGraph() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 绘制男生节点（蓝色）
    boys.forEach((pos, i) => {
        ctx.fillStyle = currentBoy === i ? '#FFA500' : '#0000FF';
        ctx.fillRect(pos.x - 5, pos.y - 5, 10, 10);
    });
    // 绘制女生节点（红色）
    girls.forEach((pos, i) => {
        ctx.fillStyle = currentGirl === i ? '#FFA500' : '#FF0000';
        ctx.fillRect(pos.x - 5, pos.y - 5, 10, 10);
    });
    // 绘制匹配边（绿色高亮）
    matchedEdges.forEach(edge => {
        ctx.strokeStyle = '#00FF00';
        ctx.beginPath();
        ctx.moveTo(edge.from.x, edge.from.y);
        ctx.lineTo(edge.to.x, edge.to.y);
        ctx.stroke();
    });
}
// 音效触发：删除边时播放
function playDeleteSound() {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(440, audioCtx.currentTime);
    osc.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.1);
}
```

---
处理用时：56.35秒
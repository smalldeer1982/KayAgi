# 题目信息

# [JSOI2009] 游戏

## 题目描述

小 AA 和小 YY 得到了《喜羊羊和灰太狼》的电影票，都很想去观看，但是电影票只有一张，于是他们用智力游戏决定胜负，赢得游戏的人可以获得电影票。

在 $N \times M$ 的迷宫中有一个棋子，小 AA 首先任意选择棋子放置的位置。然后，小 YY 和小 AA 轮流将棋子移动到相邻的格子里。游戏的规则规定，在一次游戏中，同一个格子不能进入两次，且不能将棋子移动到某些格子中去。当玩家无法继续移动棋子时，游戏结束，最后一个移动棋子的玩家赢得了游戏。

例如下图所示的迷宫，迷宫中 `.` 表示棋子可以经过的格子，而 `#` 表示棋子不可以经过的格子：

```cpp
                                 .##
                                 ...
                                 #.# 
```                                 
若小 AA 将棋子放置在 $(1,1)$，则小 AA 则无论如何都无法赢得游戏。

而若小 AA 将棋子放置在 $(3,2)$ 或 $(2,3)$，则小 AA 能够赢得游戏。例如，小 AA 将棋子放置在 $(3,2)$，小 YY 只能将它移动到 $(2,2)$，此时小 AA 再将棋子移动到 $(2,3)$，就赢得了游戏。

小 AA 和小 YY 都是绝顶聪明的小朋友，且从不失误。小 AA 到底能不能赢得这场游戏，从而得到珍贵的电影票呢？

## 说明/提示

- 对 $30\%$ 的数据，有 $n,m \leq 5$；
- 对 $100\%$ 的数据，有 $1 \leq n,m \leq 100$。


## 样例 #1

### 输入

```
3 3
.##
...
#.#```

### 输出

```
WIN
2 3
3 2```

# AI分析结果



---

## 算法分类
**二分图博弈**

---

## 题解思路与算法分析

### 核心思路
1. **棋盘黑白染色**：将棋盘按国际象棋棋盘式黑白染色，构建二分图（黑格为左部，白格为右部）
2. **最大匹配判定**：计算二分图的最大匹配
3. **必胜点判断**：若存在不在任何最大匹配中的点（非必须点），先手选择该点必胜
4. **DFS标记扩展**：从所有未被匹配的点出发，通过DFS标记所有可能成为非必须点的位置

### 解决难点
1. **二分图构建**：正确处理障碍物（#号格不参与连边）
2. **非必须点判定**：通过反向增广路径搜索，找出所有可被替换的匹配点
3. **双向匹配处理**：在匈牙利算法中需要同时处理左部点和右部点的匹配关系

---

## 题解评分（≥4星）

### 1. SunsetGlow95（★★★★☆）
**核心亮点**：
- 使用匈牙利算法实现清晰
- 通过DFS反向追踪匹配链实现非必须点标记
- 代码结构模块化（建图、匹配、标记分离）

### 2. jpwang（★★★★☆）
**核心亮点**：
- 采用Dinic网络流求最大匹配
- 通过残量网络快速定位非必须点
- 引入当前弧优化提升性能

### 3. CaoXian（★★★★☆）
**核心亮点**：
- 独创性提出双向DFS标记方法
- 代码中明确区分左右部点的处理逻辑
- 使用显式匹配表（match数组）便于调试

---

## 最优技巧提炼

### 关键数据结构
```cpp
vector<int> g[N]; // 邻接表存储二分图
int match[N];     // 匹配关系表
bool vis[N];      // DFS访问标记
```

### 核心算法片段
```cpp
// 匈牙利算法求匹配
bool dfs(int u) {
    for(int v : g[u]) {
        if(!vis[v]) {
            vis[v] = true;
            if(!match[v] || dfs(match[v])) {
                match[v] = u;
                match[u] = v;
                return true;
            }
        }
    }
    return false;
}

// 标记非必须点
void mark_unmatch(int u) {
    vis[u] = true;
    for(int v : g[u]) {
        if(match[v] && !vis[match[v]]) {
            mark_unmatch(match[v]);
        }
    }
}
```

---

## 同类型题目推荐
1. **P4136 谁能赢呢？**（基础棋盘博弈）
2. **P1971 兔兔与蛋蛋游戏**（进阶棋盘博弈）
3. **P4056 星际竞速**（带权二分图博弈）

---

## 可视化设计

### 动画流程
1. **棋盘初始化**  
   ![棋盘染色演示](https://cdn.luogu.com.cn/upload/image_hosting/lzc6358l.png)  
   - 黑白交替染色，障碍物显示为红色
   - 相邻可通行格子间显示蓝色连接线

2. **匹配过程展示**  
   ![匹配过程](https://cdn.luogu.com.cn/upload/image_hosting/ts6mmiuw.png)  
   - 当前匹配边显示为金色闪烁线条
   - 已匹配点显示为绿色，未匹配点显示为红色

3. **非必须点标记**  
   ![DFS标记](https://cdn.luogu.com.cn/upload/image_hosting/mi6rlpy6.png)  
   - DFS搜索路径显示为紫色波纹扩散
   - 新标记的非必须点显示为金色闪烁

### 复古风格实现
```javascript
// 音效设计
const audio = {
    match: new Audio('data:audio/wav;base64,UklGRl...'), // 匹配成功音效
    unmatch: new Audio('data:audio/wav;base64,UklGRl...'), // 未匹配音效
    win: new Audio('data:audio/wav;base64,UklGRl...') // 胜利音效
};

// 像素棋盘绘制
function drawPixelGrid(ctx) {
    for(let i=0; i<n; i++) {
        for(let j=0; j<m; j++) {
            const color = (i+j)%2 ? '#303030' : '#E0E0E0'; // 黑白棋盘
            ctx.fillStyle = color;
            ctx.fillRect(j*32, i*32, 32, 32);
        }
    }
}
```

---

## 实现要点
1. **动态匹配可视化**：在DFS过程中实时高亮当前处理的节点和边
2. **回溯路径显示**：使用半透明颜色绘制已探索的路径
3. **音效触发机制**：在匹配成功、发现非必须点等关键操作时触发8-bit音效

---

## 个人心得摘录
> "调试时发现障碍物处理容易出错，后来采用独立id映射表解决。关键点在于理解非必须点的双向可替换性，这需要反复画图验证匹配链的变化。" —— jpwang题解摘录

> "使用Dinic时残量网络的方向容易混淆，最终通过显式区分左右部点解决。网络流的强大之处在于能快速处理复杂匹配关系。" —— hejianxing题解摘录

---

通过这种结构化的分析，学习者可以快速掌握二分图博弈的核心思想，并通过可视化加深对算法流程的理解。不同实现方式的对比也为优化代码提供了参考思路。

---
处理用时：63.99秒
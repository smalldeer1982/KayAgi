# 题目信息

# 王者之剑

## 题目描述

![https://cdn.luogu.com.cn/upload/pic/17920.png](https://cdn.luogu.com.cn/upload/pic/17920.png)  

这是在阿尔托利亚·潘德拉贡成为英灵前的事情，她正要去拔出石中剑成为亚瑟王，在这之前她要去收集一些宝石。

宝石排列在一个 $n \times m$ 的网格中，每个网格中有一块价值为 $v_{i,j}$ 的宝石，阿尔托利亚·潘德拉贡可以选择自己的起点。

开始时刻为 $0$ 秒。以下操作，每秒按顺序执行。

1. 在第 $i$ 秒开始的时候，阿尔托利亚·潘德拉贡在方格 $(x,y)$ 上，她可以拿走 $(x, y)$ 中的宝石。
2. 在偶数秒，阿尔托利亚·潘德拉贡周围四格的宝石会消失。
3. 若阿尔托利亚·潘德拉贡第 $i$ 秒开始时在方格 $(x,y)$ 上，则在第 $i+1$ 秒可以立即移动到 $(x+1,y),(x,y+1),(x-1,y)$ 或 $(x, y- 1)$ 上，也可以停留在（$x,y)$ 上。


求阿尔托利亚·潘德拉贡最多可以获得多少价值的宝石

## 说明/提示

姚金宇的原创题。

## 样例 #1

### 输入

```
2 2
1 2
2 1```

### 输出

```
4```

# AI分析结果



---

## 算法分类
二分图最大权独立集（网络流模型）

---

## 综合分析与结论

### 核心思路与难点
1. **建模核心**：将网格黑白染色，转化为二分图的最大权独立集问题。相邻点无法同时选取，对应独立集性质。
2. **网络流转换**：
   - 源点连黑点，容量为点权；白点连汇点，容量为点权
   - 相邻点之间连无限容量边，确保不被同时选中
3. **正确性证明难点**：
   - 证明任意合法路径对应独立集
   - 构造独立集对应的合法移动方案（如RemiliaScar1et的S型路径构造）
4. **实现关键**：
   - 高效的Dinic算法（当前弧优化）
   - 坐标映射与边权处理

### 可视化设计
1. **动画流程**：
   - **步骤1**：展示黑白染色过程，将网格交替标记为黑/白像素块
   - **步骤2**：动态绘制源点（红色）连黑点，汇点（蓝色）连白点，相邻点间黄色连线
   - **步骤3**：用流动画演示增广路径（如绿色高亮边），流量更新时闪烁对应边
2. **复古特效**：
   - 8位音效：增广路径发现（↑音调）、流量更新（↓音调）、算法完成（胜利旋律）
   - 像素风格流量数值显示在边旁
3. **交互功能**：
   - 速度滑块控制算法执行速度
   - 暂停/继续按钮观察当前状态
   - 切换显示残量网络/层次网络

---

## 高星题解（≥4★）

### 1. RemiliaScar1et（5★）
- **亮点**：严谨的独立集与方案构造证明，带当前弧优化的Dinic实现
- **代码片段**：
```cpp
// 坐标映射与建图
if((i+j)&1) {
    add(S, index_(i,j),x); // 黑点连源点
    for(int k=0;k<4;k++)   // 四方向无限边
        add(index_(i,j),index_(xx,yy),INF);
} else {
    add(index_(i,j),T,x);  // 白点连汇点
}
```

### 2. VenusM1nT（4.5★）
- **亮点**：明确双倍经验提示（P2774），清晰变量命名
- **调试心得**：
  > "原题代码复制后WA，发现DFS中误用flow-used导致逻辑错误，修正后AC"

### 3. Lagerent（4★）
- **亮点**：前置知识完整，包含独立集与覆盖集的数学证明
- **可视化提示**：推荐用不同颜色区分层次网络中的层级

---

## 关键代码实现

### Dinic核心（带当前弧优化）
```cpp
bool bfs() {
    memset(dep, -1, sizeof dep);
    queue<int> q; q.push(s);
    dep[s] = 0; cur[s] = head[s];
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int i=head[u]; ~i; i=nt[i]) {
            int v=to[i];
            if(dep[v]==-1 && f[i]>0) {
                dep[v] = dep[u]+1;
                cur[v] = head[v];
                if(v==t) return true;
                q.push(v);
            }
        }
    }
    return false;
}

int dfs(int u, int limit) {
    if(u == t) return limit;
    int flow = 0;
    for(int i=cur[u]; ~i && flow<limit; i=nt[i]) {
        cur[u] = i;  // 当前弧优化
        int v = to[i];
        if(dep[v]==dep[u]+1 && f[i]>0) {
            int tmp = dfs(v, min(f[i], limit-flow));
            if(!tmp) dep[v] = -1;
            f[i] -= tmp; f[i^1] += tmp;
            flow += tmp;
        }
    }
    return flow;
}
```

---

## 相似题目推荐
1. **P2774 方格取数问题** - 双倍经验，完全一致模型
2. **P3355 骑士共存问题** - 二分图最大独立集变形
3. **P2762 太空飞行计划问题** - 最大权闭合图应用

---

## 个人心得摘录
- **VenusM1nT**："复制代码时变量名错误导致调试2小时，务必逐行理解再复用"
- **灼眼的夏娜**："将变量命名为Saber相关角色后，debug过程充满动力与乐趣"
- **ker_xyxyxyx_xxs**："首次忽略坐标越界判断导致RE，加入xx>=1后AC"

---

## 复古可视化方案（伪代码）

```javascript
// 像素网格初始化
const grid = new PixelGrid(640, 480, 16); // 16x16像素块
grid.fillChecker(n, m, 0xFFAADD, 0xDDA0FF); // 棋盘染色

// 网络流动画
class FlowAnimator {
  constructor() {
    this.speed = 1; 
    this.currentEdge = null;
    this.sound = new EightBitSFX();
  }

  highlightEdge(edge, color) {
    grid.drawArrow(edge.from, edge.to, color);
    this.sound.play('blip');
  }

  async runDinic() {
    while(bfs()) {
      this.highlightLevels(dep); // 用不同颜色显示层次
      while(let flow = dfs(S, INF)) {
        this.highlightAugPath(flow); // 绿色高亮增广路径
        await delay(500/this.speed);
      }
    }
    this.sound.play('victory');
  }
}
```

---
处理用时：73.51秒
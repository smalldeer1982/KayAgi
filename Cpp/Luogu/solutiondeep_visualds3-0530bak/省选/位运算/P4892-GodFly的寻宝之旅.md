# 题目信息

# GodFly的寻宝之旅

## 题目背景

“蒹葭苍苍，白露为霜。所谓伊人，在水一方…”

怀着$a$ $burning$ $desire$，$GodFly$开启了他追寻学妹之路。

## 题目描述

我们把校园抽象成一个具有$n$个点的无向连通图，其中的$n$个结点分别编号为$1,2,3,...,n$。把$GodFly$经过的结点表示为一个路径集合$A=\left\{a_1,a_2,a_3,...,a_m\right\}$，表示他依次经过了编号为$a_1$、$a_2$、…、$a_m$的结点，由于集合的元素具有互异性，这意味着$GodFly$无法重复经过同一个结点。

$GodFly$现在要从第$1$个结点走到第$n$个结点，然而他的腿疾对他造成了许多不便。定义$GodFly$经过了$m$个结点，当前在点$a_m$，且路径集合$A=\left\{a_1,a_2,a_3...,a_{m-1}\right\}$（加入新结点$a_m$前）时，他的总体力耗费为$w_m=(w_{m-1}+a_m*sum(A))$%$2$，其中$w_{m-1}$表示上一个路径集合的体力耗费；且对于集合$A$，$sum(A)=a_1+a_2+...+a_{m-1}$。

对于$w=0$的情况，我们称$GodFly$处于“滑基态”，否则对于$w=1$的情况，我们称$GodFly$处于“对偶态”。现在$GodFly$想要知道，他走到$n$结点后处于滑基态或对偶态的方案数，由于这个数可能很大，你只需要输出它对$19260817$取膜（模）的结果；注意两个方案是不同的，当且仅当它们有至少一条经过的边不同，而非路径集合不同。

**注意：T3压缩包内第一个数据有误，以题面的样例为准。**

## 说明/提示

**【数据范围】**

对于$30$%的数据，$n<=10$，$k<=45$，无重边及自环；

对于$60$%的数据，$n<=15$，$k<=300$；

对于$80$%的数据，$n<=15$，$k<=100000$；

对于$100$%的数据，$n<=18$，$k<=100000$；

样例数据在**data.zip\fantasy\**中。

**【样例说明】**

![](https://cdn.luogu.com.cn/upload/pic/30986.png)

如图，初始时在$1$结点，路径集合为$\left\{1\right\}$，费用为$0$；

若从$1$走到$2$结点再走到$3$结点，到$2$结点时，费用为$(0+2*sum(\left\{1\right\}))$%$2=2*1$%$2=0$，并把$2$加入路径集合，则此时路径集合为$\left\{1,2\right\}$；到$3$结点时，因上一次费用为0，费用为$(0+3*sum(\left\{1,2\right\}))$%$2=3*(1+2)$%$2=1$；

若从$1$结点直接走到$3$结点，则费用为$(0+3*sum(\left\{1\right\}))$%$2=3*1$%$2=1$。

故最终走到$3$结点时费用为$1$的方案数为$2$。

**【提示】**

本题时限$3s$，且可以开启$O_2$优化，不必过分担心卡常数，但请确保算法足够优美。

## 样例 #1

### 输入

```
3 3
1 2
2 3
1 3
1```

### 输出

```
2```

# AI分析结果



## 算法分类选择
**状压DP**

## 题解思路与难点分析
### 核心思路
题目要求统计从节点1到n的所有路径中，最终体力耗费为指定状态的方案数。由于路径集合的**顺序不影响w值**，只需记录已访问节点的集合。利用状压DP，状态包含当前节点和已访问集合，通过预处理计算每个状态的sum和w值，避免维护额外维度。

### 解决难点
1. **状态简化**：发现路径集合的顺序无关性，将三维DP（节点、集合、w值）简化为二维（节点、集合）。
2. **高效转移**：预处理每个状态的sum值，直接通过集合计算w，避免重复计算。
3. **边权处理**：记录每对节点的边数，转移时累乘方案数。

## 题解评分（≥4星）
1. **Fellyhosn（5星）**  
   - 利用路径集合顺序无关性，极大优化状态数。  
   - 代码简洁，直接通过位运算和预处理实现高效转移。
2. **JimmyF（4星）**  
   - 正确实现三维DP，预处理sum加速计算。  
   - 思路清晰但未发现关键性质，状态数较高。
3. **wind_seeker（4星）**  
   - 未发现性质但完整实现三维DP，代码结构清晰。  
   - 提供状态转移的详细推导，适合理解题意。

## 最优思路提炼
- **关键观察**：路径集合确定后，w值与访问顺序无关，仅需记录集合和当前节点。
- **状态压缩**：用二进制位表示访问集合，状态数为`n * 2^n`。
- **预处理sum**：每个状态的sum可预先计算，避免动态维护。
- **转移优化**：枚举前驱节点和边权，直接累加方案数。

## 同类型题推荐
1. [P3959 宝藏](https://www.luogu.com.cn/problem/P3959)  
   （状压DP处理最小生成树变种）
2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)  
   （TSP问题，状压记录已访问点）
3. [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)  
   （经典TSP，状态压缩优化）

## 可视化与算法演示
### 动画设计
- **网格展示**：将节点排列为网格，已访问节点高亮为绿色，当前节点为红色。
- **状态转移**：显示当前状态（二进制）和对应的sum、w值，用箭头表示边转移。
- **复古像素风**：使用8位色调色板（如绿色表示已访问，红色表示当前节点）。

### 交互功能
- **步进控制**：单步执行状态转移，观察每个状态的sum和w计算。
- **自动演示**：AI自动选择下一个状态，展示最优路径的生成过程。
- **音效提示**：播放“滴答”声表示状态更新，成功到达n节点时播放胜利音效。

## 核心代码片段（Fellyhosn题解）
```cpp
int main() {
    // 初始化边权
    for (int i=1; i<=m; i++) {
        int x,y; scanf("%d%d",&x,&y);
        a[x][y]++, a[y][x]++;
    }
    // 初始化DP：节点1，状态{1}
    f[1][1] = 1;
    // 枚举所有状态
    for (int i=1; i<(1<<n); i++) {
        for (int j=1; j<=n; j++) {
            if (!(i & (1<<(j-1)))) continue;
            // 枚举前驱节点k
            for (int k=1; k<=n; k++) {
                if (k == j || !a[j][k]) continue;
                if (!(i & (1<<(k-1)))) continue;
                f[j][i] = (f[j][i] + a[j][k] * f[k][i ^ (1<<(j-1))]) % mod;
            }
        }
    }
    // 统计答案
    for (int i=0; i<(1<<n); i++) {
        if ((i & 1) && (i & (1<<(n-1))) && pd(i)) {
            ans = (ans + f[n][i]) % mod;
        }
    }
}
```

## 总结
本题通过状压DP和关键观察，将复杂的状态转移简化为高效计算。可视化设计通过复古像素风格和交互式步进，直观展示状态变化与路径生成，适合教学与算法理解。

---
处理用时：60.04秒
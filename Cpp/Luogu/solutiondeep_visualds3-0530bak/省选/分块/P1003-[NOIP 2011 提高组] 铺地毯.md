# 题目信息

# [NOIP 2011 提高组] 铺地毯

## 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


## 说明/提示

【样例解释 1】

如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)

【数据范围】

对于 $30\%$ 的数据，有 $n \le 2$。  
对于 $50\%$ 的数据，$0 \le a, b, g, k \le 100$。  
对于 $100\%$ 的数据，有 $0 \le n \le 10^4$, $0 \le a, b, g, k \le {10}^5$。   

noip2011 提高组 day1 第 $1$ 题。

## 样例 #1

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
2 2
```

### 输出

```
3
```

## 样例 #2

### 输入

```
3
1 0 2 3
0 2 3 3
2 1 3 3
4 5```

### 输出

```
-1```

# AI分析结果



## 唯一算法分类
枚举

---

## 综合分析与结论
**核心思路**：遍历所有地毯，判断目标点是否在范围内。由于后铺的地毯覆盖先铺的，逆序检查可提前终止搜索。  
**解决难点**：避免存储整个二维坐标空间（空间复杂度 O(1) → O(n)），改用逐个判断（时间复杂度 O(n)）。  
**算法流程**：  
1. 存储每块地毯的坐标范围  
2. 逆序检查每块地毯是否覆盖目标点  
3. 找到第一个满足条件的地毯即可终止  

**可视化设计**：  
- **动画方案**：在 Canvas 中以网格展示地毯覆盖区域，目标点高亮为红色。逆序遍历时，当前检查的地毯边框闪烁黄色，若覆盖则变绿并停止。  
- **像素风格**：使用 8-bit 颜色块表示地毯，音效在检测到覆盖时播放胜利音效。  
- **交互控制**：支持暂停/步进，速度调节观察检测过程。

---

## 题解清单 (≥4星)
1. **kuaiCreator（5星）**  
   - 关键亮点：逆序提前终止，代码简洁高效  
   - 代码片段：  
     ```cpp
     for(int i = n; i >= 1; i--) {
         if(x >= a[i] && x <= a[i]+g[i] && y >= b[i] && y <= b[i]+k[i]) {
             ans = i;
             break;
         }
     }
     ```

2. **Vct14（4星）**  
   - 关键亮点：结构体存储，代码可读性强  
   - 代码片段：  
     ```cpp
     if(x <= l[i].c && x >= l[i].a && y <= l[i].d && y >= l[i].b) {
         cout << i;
         return 0;
     }
     ```

3. **Jayfeather2012（4星）**  
   - 关键亮点：从后往前遍历，立即返回结果  
   - 代码片段：  
     ```cpp
     for(int i=n;i>=1;i--) {
         if(/*条件判断*/) {
             cout<<i;
             return 0;
         }
     }
     ```

---

## 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4+5;
int a[N], b[N], g[N], k[N], n, x, y, ans = -1;
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) 
        cin >> a[i] >> b[i] >> g[i] >> k[i];
    cin >> x >> y;
    for (int i = n; i >= 1; i--) {
        if (x >= a[i] && x <= a[i]+g[i] && y >= b[i] && y <= b[i]+k[i]) {
            ans = i;
            break;
        }
    }
    cout << ans;
    return 0;
}
```

---

## 同类型题与算法套路
**相似算法套路**：  
- **覆盖检测**：判断点/区域是否在多个图形内  
- **逆序处理**：后效性优先问题（如最后操作生效）  

**推荐题目**：  
1. P1505 [NOI2004] 郁闷的出纳员（区间覆盖统计）  
2. P2280 [HNOI2003] 激光炸弹（二维前缀和+覆盖）  
3. P1058 立体图（二维坐标映射）  

---

## 个人心得摘录
> **智子**：  
> “开二维数组直接 MLE，改用参数遍历后 AC。”  
> **启示**：注意数据规模，优先时间换空间。  

> **kuaiCreator**：  
> “逆序遍历找到即停，比正序更高效。”  
> **启示**：处理覆盖问题时，逆序可优化平均时间复杂度。  

---

## 可视化与复古游戏化方案
**核心动画逻辑**：  
1. 初始化时绘制所有地毯为不同颜色的矩形块  
2. 目标点用闪烁红点标注  
3. 逆序检测时，当前地毯边框变黄  
4. 命中时播放 8-bit 音效，地毯变绿  

**复古要素**：  
- **调色板**：16 色 FC 风格（草地绿、砖块棕）  
- **音效**：  
  - 检测中：短促“滴”声  
  - 命中：高音“胜利”旋律  
- **Canvas 绘制**：用 `fillRect` 绘制地毯，`arc` 画点  

**交互功能**：  
- 速度滑块控制检测频率  
- 空格键暂停/继续  

**代码片段（JS）**：  
```javascript
function drawCarpet(i, color) {
    ctx.fillStyle = color;
    ctx.fillRect(a[i], b[i], g[i], k[i]);
}
// 检测循环
let i = n;
const checkInterval = setInterval(() => {
    if (isCovered(i)) {
        playSuccessSound();
        drawCarpet(i, '#00FF00'); // 命中变绿
        clearInterval(checkInterval);
    } else {
        drawCarpet(i, '#FFFF00'); // 当前检测变黄
        i--;
    }
}, speed);
```

---
处理用时：80.59秒
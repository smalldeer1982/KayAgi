# 题目信息

# [APIO2015] 雅加达的摩天楼

## 题目描述

印尼首都雅加达市有 $N$ 座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为 $0$ 到 $N − 1$。除了这 $N$ 座摩天楼外，雅加达市没有其他摩天楼。

有 $M$ 只叫做 “doge” 的神秘生物在雅加达市居住，它们的编号依次是 $0$ 到 $M − 1$。编号为 $i$ 的 doge 最初居住于编号为 $B_i$ 的摩天楼。每只 doge 都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为 $i$ 的 doge 的跳跃能力为 $P_i$ （$P_i > 0$）。

在一次跳跃中，位于摩天楼 $b$ 而跳跃能力为 $p$ 的 doge 可以跳跃到编号为 $b - p$ （如果 $0 \leq b - p < N$）或 $b + p$ （如果 $0 \leq b + p < N$）的摩天楼。

编号为 $0$ 的 doge 是所有 doge 的首领，它有一条紧急的消息要尽快传送给编号为 $1$ 的 doge。任何一个收到消息的 doge 有以下两个选择:

- 跳跃到其他摩天楼上；
- 将消息传递给它当前所在的摩天楼上的其他 doge。

请帮助 doge 们计算将消息从 $0$ 号 doge 传递到 $1$ 号 doge 所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到 $1$ 号 doge。


## 说明/提示

【样例解释】

下面是一种步数为 $5$ 的解决方案：

$0$ 号 doge 跳跃到 $2$ 号摩天楼，再跳跃到 $4$ 号摩天楼（$2$ 步）。

$0$ 号 doge 将消息传递给 $2$ 号 doge。

$2$ 号 doge 跳跃到 $3$ 号摩天楼,接着跳跃到 $2$ 号摩天楼，再跳跃到 $1$ 号摩天楼（$3$ 步）。

$2$ 号 doge 将消息传递给 $1$ 号 doge。

【数据范围】

所有数据都保证 $0 \leq B_i < N$。

子任务 1 （10 分）$1 \leq N \leq 10$

$1 \leq P_i \leq 10$

$2 \leq M \leq 3$


子任务 2 （12 分）$1 \leq N \leq 100$

$1 \leq P_i \leq 100$

$2 \leq M \leq 2000$


子任务 3 （14 分）$1 \leq N \leq 2000$

$1 \leq P i ≤ 2000$

$2 \leq M \leq 2000$


子任务 4 （21 分）$1 \leq N \leq 2000$

$1 \leq P_i \leq 2000$

$2 \leq M \leq 30000$


子任务 5 （43 分）$1 \leq N \leq 30000$

$1 \leq P_i \leq 30000$

$2 \leq M \leq 30000$


## 样例 #1

### 输入

```
5 3
0 2
1 1
4 1```

### 输出

```
5```

# AI分析结果



## 算法分类
分块优化 BFS

---

## 题解思路与核心难点

### 核心思路
将跳跃能力分为大（>√n）和小（≤√n）两类处理：
1. **小跳跃能力**：通过分层状态建模，每个状态（位置，跳跃步长）对应一个节点
2. **大跳跃能力**：直接暴力连边，利用其跳跃次数少的特性控制状态数

### 解决难点
1. **状态爆炸**：通过分块将状态数压缩到 O(n√n)
2. **消息传递优化**：到达新位置时自动继承该位置所有 doge 的跳跃能力，实现零步数状态切换
3. **判重效率**：使用 bitset 或二维数组代替哈希表加速访问检查

---

## 题解评分（≥4星）

1. **浮尘ii（5星）**
   - 实现简洁，直接 BFS 无需显式建图
   - 利用 bitset 高效判重
   - 时间复杂度最优 O(n√n)

2. **TopCarry（4星）**
   - 显式分块建图，结构清晰
   - 数学推导分块阈值 k=√(n/3)
   - 完整 SPFA 实现

3. **GoldenPotato137（4星）**
   - 分层图可视化解释生动
   - 分块阈值取 100 的实践经验
   - 包含调试时间输出便于优化

---

## 最优思路提炼

### 关键技巧
1. **状态压缩**：用（位置，跳跃步长）二元组表示状态
2. **分时处理**：
   ```python
   if p ≤ √n:
       使用分层状态扩展
   else:
       暴力连有限跳跃边
   ```
3. **零成本切换**：到达新位置时自动加载该点所有 doge 的跳跃能力

### 代码片段（浮尘ii）
```cpp
void insert(int i, int p, int step) {
    if (!Vis[i]) { // 首次到达该位置
        Vis[i] = true;
        for (auto x : Doge[i]) // 加载该位置所有 doge 能力
            if (!vis[i].test(x))
                vis[i].set(x), Q.emplace(i, x, step);
    }
    if (!vis[i].test(p)) // 正常跳跃扩展
        vis[i].set(p), Q.emplace(i, p, step);
}
```

---

## 同类型题目
1. **CF 1063B Labyrinth**（分层状态 BFS）
2. **Luogu P1948 电话线**（分块最短路）
3. **ARC084B 最短路問題**（状态压缩 BFS）

---

## 可视化设计

### 动画演示
1. **网格视图**：x 轴为楼号，y 轴为跳跃步长分层
   - 小步长层：显示连续跳跃路径
   - 大步长层：显示离散跳跃点
2. **状态标记**：
   - 红色：当前处理状态
   - 绿色：已访问状态
   - 黄色：待扩展队列

### 复古特效
```javascript
// 8-bit 音效触发示例
function playJumpSound() {
    const osc = audioContext.createOscillator();
    osc.frequency.setValueAtTime(500 + Math.random()*200, audioContext.currentTime);
    osc.connect(audioContext.destination);
    osc.start(); osc.stop(audioContext.currentTime + 0.1);
}
```

---

## 个人心得摘录
> "当 p 较小时，分层图会产生大量重复边，用分块将建图复杂度数学优化到最低是关键" —— StudyingFather

---

## 算法演示代码（核心逻辑）
```javascript
class SkyscraperVisualizer {
    constructor() {
        this.layers = new Map(); // 分层状态
        this.queue = new Deque(); // 双端队列
    }

    addState(x, p, step) {
        const layer = p <= this.blockSize ? p : 0;
        if (!this.layers.has(layer)) 
            this.layers.set(layer, new Set());
        
        const key = `${x}-${p}`;
        if (!this.layers.get(layer).has(key)) {
            this.layers.get(layer).add(key);
            this.queue.push({x, p, step});
            drawPixel(x, layer, COLORS.PENDING); // 8-bit 像素绘制
        }
    }
}
```

---
处理用时：99.23秒
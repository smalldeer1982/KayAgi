# 题目信息

# [SDOI2017] 相关分析

## 题目描述

Frank 对天文学非常感兴趣，他经常用望远镜看星星，同时记录下它们的信息，比如亮度、颜色等等，进而估算出星星的距离，半径等等。

Frank 不仅喜欢观测，还喜欢分析观测到的数据。他经常分析两个参数之间（比如亮度和半径）是否存在某种关系。

现在 Frank 要分析参数 $X$ 与 $Y$ 之间的关系。他有 $n$ 组观测数据，第 $i$ 组观测数据记录了 $x_i$ 和 $y_i$。他需要一下几种操作。

###  $\verb!1 L R!$

用直线拟合第 $L$ 组到第 $R$ 组观测数据。用 $\overline{x}$ 表示这些观测数据中 $x$ 的平均数，用 $\overline{y}$ 表示这些观测数据中 $y$ 的平均数，即
 
$$\begin{aligned}\overline{x}&={1 \over R-L+1} \sum _{i=L} ^R x_i \\\overline{y}&={1 \over R-L+1} \sum _{i=L} ^R y_i\end{aligned}$$

如果直线方程是 $y=ax+b$，那么 $a$ 应当这样计算：

$$a={\displaystyle\sum_{i=L} ^R (x_i-\overline{x})(y_i-\overline{y}) \over \displaystyle\sum _{i=L} ^R (x_i -\overline{x})^2}$$

 
你需要帮助 Frank 计算 $a$。

 
###  $\verb!2 L R S T!$

Frank 发现测量数据第 $L$ 组到第 $R$ 组数据有误差，对每个 $i$ 满足 $L \leq i \leq R$，$x_i$ 需要加上 $S$，$y_i$ 需要加上 $T$。
 
###  $\verb!3 L R S T!$

Frank 发现第 $L$ 组到第 $R$ 组数据需要修改，对于每个 $i$ 满足 $L \leq i \leq R$，$x_i$ 需要修改为 $(S+i)$，$y_i$ 需要修改为 $(T+i)$。


## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据 $1 \leq n,m \leq 1000$；
- 另有 $20\%$ 的数据，没有 $3$ 操作，且 $2$ 操作中 $S=0$；
- 另有 $30\%$ 的数据，没有 $3$ 操作。

对于 $100\%$ 的数据，$1 \leq n,m \leq 10^5$，$0 \leq |S|,|T| \leq 10^5$，$0 \leq |x_i|,|y_i| \leq 10^5$。

保证 $1$ 操作不会出现分母为 $0$ 的情况。


## 样例 #1

### 输入

```
3 5
1 2 3
1 2 3
1 1 3
2 2 3 -3 2
1 1 2
3 1 2 2 1
1 1 3
```

### 输出

```
1.0000000000
-1.5000000000
-0.6153846154
```

# AI分析结果



### 唯一算法分类  
**线段树（复杂标记维护）**

---

### 综合分析与结论  
#### 核心算法流程
1. **公式推导**：通过展开回归系数公式，确定需维护四个核心值：  
   - Σx, Σy, Σxy, Σx²  
2. **线段树设计**：  
   - 节点存储四个统计值及两种懒标记（加法标记、覆盖标记）  
   - 覆盖标记优先于加法标记，下传时需先执行覆盖再处理加法  
3. **标记下传逻辑**：  
   - **操作2（加法）**：根据公式更新统计值（如 Σxy += SΣy + TΣx + ST*len）  
   - **操作3（覆盖）**：重置为初始值（i+S, i+T）后叠加加法操作  
4. **数学公式预计算**：利用平方和公式 Σi² = n(n+1)(2n+1)/6 快速计算覆盖后的统计值  

#### 可视化设计思路
- **线段树节点动态更新**：以网格形式展示每个节点的四个统计值，用不同颜色高亮当前更新的值  
- **标记传播动画**：  
  - 覆盖标记触发时，节点变为蓝色闪烁，统计值重置为公式计算结果  
  - 加法标记触发时，节点变为黄色渐变，展示增量计算过程  
- **音效提示**：  
  - 覆盖操作播放"重置"音效（8-bit风格短促音）  
  - 加法操作播放"波纹"音效  
- **自动演示模式**：模拟随机操作序列，展示标记下传与统计值更新流程  

---

### 题解清单 (≥4星)
1. **liangbowen（★★★★★）**  
   - 亮点：公式推导完整，代码结构清晰，重载运算符简化节点合并  
   - 关键代码：  
     ```cpp
     struct Node { db x, y, xx, xy, s, t; bool cov; };
     Node operator +(Node a, Node b) { /*合并四个统计值*/ }
     void lazy(int l, int r, int pos, db S, db T) { /*更新加法标记*/ }
     ```

2. **Capella（★★★★☆）**  
   - 亮点：独立推导公式，处理标记顺序时显式清空加法标记  
   - 关键注释：  
     ```cpp
     // 覆盖操作清空add标记：tree[ls].add = tree[rs].add = 0
     ```

3. **Rainybunny（★★★★☆）**  
   - 亮点：使用分块处理，公式推导与线段树解完全分离  
   - 创新点：分块内预计算平方和加速覆盖操作  

---

### 最优思路与技巧提炼
1. **公式降维**：  
   ```python
   # 原式 => (Σxy - ΣxΣy/n) / (Σx² - (Σx)²/n)
   ```
2. **标记优先级设计**：  
   ```cpp
   void pushdown() {
     if (覆盖标记存在) 先执行覆盖重置;
     if (加法标记存在) 再处理加法;
   }
   ```
3. **平方和快速计算**：  
   ```cpp
   db sqsum(int l, int r) { 
     return r*(r+1)*(2*r+1)/6 - (l-1)*l*(2*l-1)/6;
   }
   ```

---

### 类似题目推荐
1. **P3373 线段树2**（区间乘加混合操作）  
2. **P4243 等差数列**（区间等差数列维护）  
3. **P1471 方差**（维护平方和与线性和的动态计算）  

---

### 个人心得摘录
> "被覆盖操作和加法操作的标记顺序坑了3小时...必须清空子节点的加法标记，否则会重复计算增量" ——xyz32768  
> "分块解法虽然理论复杂度稍高，但实际运行比线段树快20%，因为覆盖操作的平方和预计算节省了大量时间" ——N2MENT  

---

### 核心代码实现（liangbowen版）
```cpp
struct Node {
    db x, y, xx, xy, s, t; // Σx, Σy, Σx², Σxy, 加法标记
    bool cov; // 覆盖标记
    Node() { x=y=xx=xy=s=t=cov=0; }
};
void pushdown(int l, int r, int pos) {
    if (tr[pos].cov) { // 优先处理覆盖
        rebuild(l, mid, ls); rebuild(mid+1, r, rs);
        tr[pos].cov = false;
    }
    // 再处理加法
    lazy(l, mid, ls, tr[pos].s, tr[pos].t);
    lazy(mid+1, r, rs, tr[pos].s, tr[pos].t);
    tr[pos].s = tr[pos].t = 0;
}
void update_cover(int L, int R, int l, int r, int pos, db S, db T) {
    if (L <= l && r <= R) {
        rebuild(l, r, pos); // 重置为i+S, i+T
        lazy(l, r, pos, S, T); // 叠加后续加法
        return;
    }
    pushdown(l, r, pos);
    // 递归更新子树...
}
```

---

### 复古像素化演示设计
1. **Canvas布局**：  
   - 线段树以金字塔结构展示，每个节点显示四个统计值的8-bit风格数字  
   - 当前活跃节点用闪烁边框标记（红框=覆盖操作，黄框=加法操作）  
2. **音效触发**：  
   ```javascript
   function playSFX(type) {
     const sfx = {
       cover: [520, 0.2, , , , 0.2], // 覆盖操作：低音脉冲
       add: [1200, 0.1, , , 0.3]     // 加法操作：高音滴答
     };
     synth.triggerAttackRelease(sfx[type]);
   }
   ```
3. **自动演示模式**：  
   ```javascript
   let autoSteps = [
     {type: 'cover', L:1, R:3, S:2, T:1},
     {type: 'add', L:2, R:4, S:-1, T:3},
     {type: 'query', L:1, R:5}
   ];
   // 按步骤执行并高亮对应节点
   ```

---
处理用时：91.04秒
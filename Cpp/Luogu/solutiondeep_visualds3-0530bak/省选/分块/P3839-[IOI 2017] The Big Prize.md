# 题目信息

# [IOI 2017] The Big Prize

## 题目背景

这里是洛谷。如果有疑问，可以发帖求助。

如果你习惯于写函数式交互，以下内容可能对你有帮助：

```cpp
vector<int>ask(int i)
{
	printf("? %d\n",i);fflush(stdout);
	vector<int>ret(2);
	scanf("%d%d",&ret[0],&ret[1]);
	return ret;
}
int find_best(int n)
{
	//
}
main()
{
	int n;scanf("%d",&n);
	printf("! %d\n",find_best(n));
}
```

无论如何，你都不应引入额外的头文件。

## 题目描述

“大奖”是一个家喻户晓的 TV 游戏节目。这次你很幸运地进入到最后一轮。已知编号从 $0$ 到 $n-1$ 的 $n$ 个盒子从左到右排成一行，你就站在这排盒子的前面。每个盒子里面放有一个奖品，必须打开盒子才能看到是什么奖品。已知有 $v\leq5$ 种不同类型的奖品。这 $v$ 种类型按照奖品价值的降序从 $1$ 到 $v$ 排列。

类型 $1$ 的奖品是一块钻石，价值最高。所有盒子加起来刚好只有一块钻石。类型 $v$ 的奖品是一块棒棒糖，价值最低。为使得游戏更加激动人心，相对便宜的奖品数量远比价值昂贵的奖品数量要多。更具体一点，对于满足 $2\leq t \leq v$ 的所有 $t$，我们有： 如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。

你的目标是赢得那块钻石。在游戏结束时，你必须打开一个盒子并收取盒子内的奖品。在选择要打开的盒子之前，你可以向节目主持人 Rambod 提一些问题。在每一个问题中，你选择就某个 $i$ 号盒子进行提问。Rambod 将给你一个包含两个整数的数组 $a$ 作为回答。这两个整数的意义如下：

- 在 $i$ 号盒子左面的盒子中，刚好有 $a[0]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。
- 在 $i$ 号盒子右面的盒子中，刚好有 $a[1]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。

例如，假设 $n=8$，在你的问题中，你选择就 $i=2$ 号盒子进行提问。Rambod 的回答是 $a=[1,2]$。这个回答的意义是：

- $0$ 号盒子和 $1$ 号盒子中恰好有一个盒子中的奖品比 $i$ 号盒子中的奖品更贵。
- 在 $3,4,\cdots,7$ 号盒子中恰好有 $2$ 个盒子中的奖品比 $2$ 号盒子中的奖品更贵。

你的任务就是通过问少量的问题找出包含钻石的盒子。

## 说明/提示

### 样例解释

```plain
8
3 2 3 1 3 3 2 3
```

![](https://cdn.luogu.com.cn/upload/pic/6728.png)

上图阐释了这个例子。图中上半部分给出了每个盒子中奖品的类型。图中的下半部分阐释了询问 `? 2`。

### 限制

- $3\leq n \leq200000$.
- 每个盒子中奖品的类型介于 $1$ 和 $v$ 之间（含）。
- 类型 $1$ 的奖品恰有一个。
- 对于所有 $2\leq t \leq v$，如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。


### 子任务与评分

1.  （$20$ 分）恰好有 $1$ 个钻石和 $n-1$ 个棒棒糖 （所以，$v=2$）。你可以询问最多 $10000$ 次。
2.  （$80$ 分）没有附加限制。


在子任务 2 中你可以获得部分分。令 $q$ 是在这个子任务的所有测试数据上发起询问的最大次数，那么你在这个子任务上的得分将按照下表计算：

![](https://cdn.luogu.com.cn/upload/pic/6729.png)

## 样例 #1

### 输入

```
8

0 3

0 1

1 2

0 0

2 1

2 1

1 0

3 0```

### 输出

```

? 0

? 1

? 2

? 3

? 4

? 5

? 6

? 7

! 3```

# AI分析结果



**唯一算法分类**：分治与剪枝

---

### **综合分析与结论**

题目核心在于通过最少查询找到唯一钻石的位置。利用分治策略结合剪枝条件，高效排除不可能区域，最终定位钻石。

**核心算法流程**：
1. **分块处理**：将整个数组分块，每个块处理端点，记录最大值。
2. **随机化顺序**：随机处理块，避免最坏情况。
3. **分治剪枝**：对每个块进行分治，若块端点值相同则剪枝，否则递归处理子区间。
4. **终止条件**：发现某点的左右高价值盒子数为0（x+y=0），直接返回。

**可视化设计思路**：
- **分块展示**：用不同颜色区分块，动态标记当前处理块。
- **分治过程**：高亮当前处理的区间端点，递归时分裂为左右子区间。
- **剪枝提示**：当端点值相同时，该区间变为灰色，表示剪枝。
- **像素风格动画**：每个盒子显示为小方块，查询时闪烁，成功时钻石位置爆炸特效。
- **音效触发**：分治步进时播放“滴”声，剪枝时低沉音效，找到钻石时胜利音效。

---

### **题解清单 (4星以上)**

1. **phigy的题解（4星）**
   - **亮点**：分块随机化减少最坏情况，分治剪枝优化查询次数。
   - **核心代码**：分块后递归处理区间，剪枝相同端点。
   ```cpp
   void solve(int L,int R) {
       ask(L); ask(R);
       if(R-L==1) return;
       if(a[L]==a[R]) return;
       int mid=(L+R)>>1;
       solve(L,mid); solve(mid,R);
   }
   ```

2. **Aiopr_2378的题解（4星）**
   - **亮点**：通过比较区间端点值剪枝，动态维护已查询点集合。
   - **核心代码**：分治中检查段内是否包含更优值。
   ```cpp
   if(val[l]==val[r]&&a[l][0]==a[r][0]) return;
   ```

---

### **最优思路提炼**

- **分块+随机化**：将数组分块后随机处理，降低最坏复杂度。
- **剪枝条件**：若区间端点响应相同，则中间无需处理。
- **分治策略**：递归缩小范围，优先处理可能包含目标的子区间。

**同类问题应用**：
- **寻找极值点**：如寻找数组中的唯一峰值。
- **交互式剪枝**：需最少查询次数的场景，如猜数游戏优化。

---

### **相似题目推荐**

1. **P3382 【模板】三分法**（分治寻找极值）
2. P1908 逆序对（分治统计）
3. P1177 【模板】快速排序（分治思想）

---

### **可视化实现要点**

- **Canvas绘制**：盒子以网格展示，当前处理块高亮为黄色。
- **分治动画**：递归时分裂区间为左右绿色/红色区域。
- **音效设计**：分治步进触发“滴”声，剪枝时“咔嚓”声，找到钻石时8-bit胜利音乐。
- **自动演示**：按分治顺序自动播放，可调节速度观察剪枝过程。

**代码片段（JS伪代码）**：
```javascript
function drawStep(L, R) {
    ctx.fillStyle = '#FFD700'; // 高亮当前区间
    ctx.fillRect(L * cellSize, 0, (R-L)*cellSize, height);
    playSound('beep'); // 触发音效
}
```

---
处理用时：128.57秒
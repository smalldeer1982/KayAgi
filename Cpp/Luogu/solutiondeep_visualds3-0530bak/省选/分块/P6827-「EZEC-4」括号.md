# 题目信息

# 「EZEC-4」括号

## 题目背景

> 离景似是昨日，转眼却已经年$\newline$ 往事依旧，物是全非



## 题目描述

给一个由小括号组成的序列和 $n$ 个括号串，要你在序列中匹配允许不连续的子串。

母序列的每个括号最多被匹配一次。

一种可能的不连续子串匹配方式为 ```)()(``` 中匹配 ``` ))(``` 。

每个括号串有一个值 $v$，代表对这个串每匹配一个括号得到的价值。

每个括号串均可以多次匹配，可以随时停止匹配，但是不能在未匹配完一个括号串的情况下开始匹配其他括号串。

注意如果你跳过了母序列的某几个括号去匹配后面的，那么你将不能返回前面继续进行匹配。

求匹配能得到的最大值。

## 说明/提示

【温馨提示】

**为了卡掉错解开大了数据范围，请注意常数因子对程序产生的影响。**

【数据范围】

**本题使用捆绑测试。**

对于 $100\%$ 的数据， $1 \le n \le 500, 1 \le len(k) \le 10^4, 1 \le len(a) \le 300,0 \le v \le 10^3$。

| Subtask | $ n \le$ | $ len(k) \le$ | $ len(a) \le$ |   时间 | 分值|特殊性质 |
| :----------: | :----------: | :----------: | :----------: |:----------: | :----------: |:----------: |
| $1$ | $10$ | $7$| $7$ | $1\text s$ |$5$|保证最优解每个 a 最多只用一次 |
| $2$ | $10$ | $50$| $8$| $1\text s$|$5$|数据随机，若 AC subtask3 则不计入总分|
| $3$ | $10$ | $1000$| $8$| $1\text s$|$10$|保证最优解每个 a 最多只用一次|
| $4$ | $100$ | $10^4$ | $8$ | $1\text s$ |$15$| 无 |
| $5$ | $500$ | $10^4$ | $8$ | $1\text s$ |$10$| 无 |
| $6$ | $500$ | $10^4$ | $300$| $2.2\text s$ |$60$| 无|

【样例 $1$ 解释】

最佳方案为先匹配 ```(()``` ，后匹配 ```()()()``` （ 注意最多只能匹配到 ```()()``` ），答案为 $4\times3 + 5 \times 4 = 32$。

一种可行的匹配方法为方括号括起来的部分 ```(【(()()】)(【()】``` 。

而若先匹配 ```(()``` ，再匹配 ```()``` ，最后匹配 ```(()``` 的价值为 $4\times 3 + 2\times 2 + 4\times 3 = 28$，并非最佳方案。

注意我们不能先匹配 ```(()``` ，再匹配 ```()()()``` 中一个括号，最后匹配 ```(()``` ，因为我们可以随时停止匹配，但不能在未匹配完某个串的情况下开始匹配另一个串。

【样例 $2$ 解释】

最佳方案先匹配 ```())```，再匹配 ```()))``` 最后匹配 ```())``` （ 注意最多只能匹配到 ```()``` ）, 答案为 $9\times 3 + 7 \times 4 + 9 \times 2 = 73$。

## 样例 #1

### 输入

```
3 
((()())(()
(() 4
() 2
()()() 5```

### 输出

```
32```

## 样例 #2

### 输入

```
3
())()))()
()) 9
()() 8
())) 7```

### 输出

```
73```

# AI分析结果



**算法分类**  
动态规划、预处理与状态压缩

---

**题解思路与算法要点**  
1. **核心观察**：优先匹配结束位置最小的括号串，以尽早释放后续匹配机会。  
2. **预处理**：利用`nxt[0/1][i]`数组记录母序列中每个位置之后下一个`(`或`)`的位置，加速匹配过程。  
3. **状态压缩**：将括号串分块处理（如块长L=5），预处理每个块的可能状态（二进制表示括号类型），将长串匹配转化为块的跳跃。  
4. **动态规划**：`dp[i]`表示母序列前i个位置的最大价值。遍历每个位置，尝试匹配所有括号串的分块组合，更新后续状态。

**解决难点**  
- **高效跳跃匹配**：通过预处理`nxt`数组，快速找到下一个所需括号的位置，避免逐字符匹配的低效操作。  
- **分块优化**：将长括号串分割为小块，预处理每个块的跳跃路径，将复杂度从O(na)优化至O(n√a)。  

---

**题解评分**  
1. **pocafup的题解（★★★★☆）**  
   - **亮点**：结合分块与状压预处理，处理长串匹配；提供多种数据范围的解法对比。  
   - **优化**：块长调整平衡时空复杂度，代码实现高效跳跃逻辑。  

---

**最优思路提炼**  
- **预处理跳跃点**：倒序构建`nxt`数组，快速定位后续括号。  
- **分块状压**：将长串拆分为固定长度块，预处理每块的状态转移路径。  
- **动态规划转移**：枚举所有可能的块组合，利用预处理结果快速计算最大价值。  

---

**同类型题与算法套路**  
- **序列匹配优化**：如子序列自动机（如[CF1922E](https://codeforces.com/problemset/problem/1922/E)）。  
- **分块与状压结合**：适用于需要处理长序列匹配的高维状态问题（如[LeetCode 139](https://leetcode.com/problems/word-break/)）。  

---

**推荐题目**  
1. P1944 - 最长括号匹配（预处理+DP）  
2. CF633C - Spy Syndrome 2（Trie+DP）  
3. LeetCode 32 - 最长有效括号（栈+DP）  

---

**个人心得摘录**  
- **调试教训**：块长需根据数据范围调整（如L=5~8），过大会增加预处理开销，过小无法有效降低复杂度。  
- **优化顿悟**：分块处理不仅减少状态数，还允许部分匹配提前终止，避免无效计算。  

---

**可视化设计思路**  
1. **动画方案**：  
   - **母序列高亮**：用不同颜色标记已匹配和未匹配的括号。  
   - **块跳跃演示**：以闪烁效果显示当前块的匹配路径（如红色箭头指向`nxt`位置）。  
   - **DP状态更新**：在母序列下方动态显示`dp[i]`的值变化，绿色表示价值增加。  
2. **复古像素风格**：  
   - **8位色块**：母序列用蓝/绿像素表示括号类型，块匹配路径用黄色像素流动。  
   - **音效触发**：匹配成功时播放“金币音效”，块跳跃时播放“跳跃音效”。  
3. **交互控制**：  
   - **步进/暂停**：允许观察每个块的匹配细节。  
   - **块长调节**：滑动条动态调整L值，实时对比不同块长的效率差异。  

---

**核心代码实现**  
预处理`nxt`数组与分块匹配逻辑：  
```cpp
// 预处理每个位置的下一个括号位置
for (int i = k; i > 0; i--) {
    nxt[0][i] = (s[i-1] == '(') ? i : nxt[0][i+1];
    nxt[1][i] = (s[i-1] == ')') ? i : nxt[1][i+1];
}

// 分块预处理
for (int i = 1; i <= n; i++) {
    num[i] = (a[i].length() / L);
    for (int l = 1; l <= num[i]; l++)
        cor[i][l] = get(i, L*(l-1), L*l - 1); // 计算块的二进制状态
}

// 动态规划转移
for (int i = 1; i <= k; i++) {
    for (int j = 1; j <= n; j++) {
        Solve(i, j); // 尝试匹配第j个括号串的分块
    }
}
```

完整代码参考原题解，核心逻辑为分块预处理与跳跃式DP转移。

---
处理用时：65.54秒
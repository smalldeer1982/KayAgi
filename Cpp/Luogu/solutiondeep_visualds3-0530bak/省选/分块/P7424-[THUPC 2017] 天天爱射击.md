# 题目信息

# [THUPC 2017] 天天爱射击

## 题目描述

小 C 爱上了一款名字叫做《天天爱射击》的游戏。如图所示，这个游戏有一些平行于 $x$ 轴的木板。现在有一些子弹，按顺序沿着 $y$ 轴方向向这些木板射去。第 $i$ 块木板被 $S_i$ 个子弹贯穿以后，就会碎掉消失。一个子弹可以贯穿其弹道上的全部木板，特别的，如果一个子弹触碰到木板的边缘，也视为贯穿木板。

小 C 现在知道了游戏中 $n$ 块木板位置，以及知道了 $m$ 个子弹射击位置。现在问你每个子弹射出去以后，有多少木板会碎掉？

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/ocqlbnl3.png)
#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。

$\text{upd}2021.7.6$：感谢 @[jiangbowen](https://www.luogu.com.cn/user/366807) 提供的一组 hack 数据，不计分，但若不通过 hack 数据则不算通过此题。

## 样例 #1

### 输入

```
3 2
1 3 1
2 4 2
3 4 1
2
3```

### 输出

```
1
2```

# AI分析结果



## 唯一算法分类
整体二分 / 主席树

---

## 综合分析与结论

### 算法核心思想
1. **整体二分**：将子弹视为时间轴，对木板进行离线处理。通过二分每个木板被击碎的时间点，利用树状数组统计区间子弹命中次数，递归分治处理未击碎的木板。
2. **主席树**：将子弹位置离散化后，构建可持久化线段树维护每个坐标点的时间序列。对于每个木板，通过区间第k小查询确定击碎它的子弹编号。

### 关键难点与解决方案
| 难点 | 整体二分解法 | 主席树解法 |
|------|-------------|-----------|
| 区间命中统计 | 树状数组维护子弹位置，递归时动态更新 | 预先构建子弹时间序列的持久化结构 |
| 离散化处理 | 无需离散化，直接处理原始坐标 | 对子弹位置进行离散化，处理多子弹同点情况 |
| 未击碎木板处理 | 初始二分区间包含m+1虚拟子弹 | 离散化时加入INF值标识未击碎情况 |

---

## 题解清单 (≥4星)

### 1. Suzt_ilymtics（整体二分，5星）
**亮点**：  
- 清晰的整体二分框架设计，递归边界处理得当  
- 使用树状数组高效维护子弹覆盖范围  
- 通过m+1虚拟子弹处理未击碎木板  

**核心代码片段**：
```cpp
void Solve(int l, int r, int ql, int qr) {
    if (ql > qr) return;
    if (l == r) { /* 统计答案 */ }
    // 动态更新树状数组并分组
    for (i = ql; i <= qr; ++i) {
        sum = BIT::Query(q[i].r) - BIT::Query(q[i].l-1);
        if (sum >= q[i].k) 分到左组 
        else 分到右组并扣除已统计次数
    }
    // 递归处理
    Solve(l, mid, 左组);
    Solve(mid+1, r, 右组);
}
```

### 2. MuYC（主席树，5星）
**亮点**：  
- 将问题转化为经典区间第k小问题  
- 通过vector处理多子弹同点情况  
- 离散化时加入INF值确保正确性  

**核心代码片段**：
```cpp
for (int i=1; i<=2e5; i++) {
    if (a[i].size() == 0) a[i].push_back(m+1); // 处理空点
    // 构建主席树版本
    for (int j=0; j<a[i].size(); j++)
        root[i] = insert(root[i], 1, m, a[i][j]);
}
// 查询区间第k小
int kth = query(root[l[i]-1], root[r[i]], s[i]);
```

### 3. Alex_Wei（整体二分优化，4星）
**亮点**：  
- 引入离散化优化树状数组空间  
- 通过动态离散化降低递归层空间消耗  
- 代码简洁高效，常数优化明显  

---

## 最优思路提炼
1. **整体二分的分治策略**  
   - 将子弹按时间分治，树状数组维护当前子弹区间的覆盖情况  
   - 递归时保留未完全击碎的木板，扣除已统计的命中次数  
   - 通过m+1虚拟子弹处理边界条件  

2. **主席树的离散化技巧**  
   - 对子弹位置离散化，建立坐标到时间的映射  
   - 通过vector存储同一坐标的多个子弹时间  
   - 使用INF标识未击碎状态，避免特殊判断  

---

## 同类型题目推荐
1. P3527 [POI2011]MET-Meteors（整体二分经典题）
2. P3834 【模板】可持久化线段树 2（主席树模板）
3. P4602 [CTSC2018]混合果汁（二分答案+主席树）

---

## 可视化算法演示设计

### 整体二分动画方案
1. **像素风格界面**  
   - 上方区域显示子弹序列（按时间排列），下方显示木板区间  
   - 当前处理的二分区间用黄色高亮，已处理子弹用灰色标记  
   - 木板颜色随剩余耐久度渐变（绿→红）

2. **关键操作演示**  
   - **子弹命中**：子弹图标飞向x轴位置，命中时播放8bit音效  
   - **树状数组更新**：对应坐标的树状数组节点闪烁+1  
   - **木板分组**：被当前子弹区间击碎的木板向左滑动，未击碎的向右滑动  

3. **控制面板功能**  
   - 速度调节滑块（1x-10x）  
   - 单步执行按钮（Step）  
   - 递归层级可视化（显示当前二分深度）

### 主席树动画方案
1. **版本树可视化**  
   - 左侧显示离散化后的坐标轴，右侧显示版本树结构  
   - 新建版本时显示与前一版本的差异路径（绿色连线）  

2. **区间查询演示**  
   - 查询时高亮[l,r]区间对应的根节点版本  
   - 递归查询路径用红色标记，统计左右子树大小差值  
   - 找到第k小时播放胜利音效，对应子弹爆炸特效

---

## 代码实现要点（整体二分）
```cpp
// 树状数组维护子弹覆盖
void update(int x) { for(;x<=MAXN;x+=x&-x) c[x]++; }
int query(int x) { /* 返回前缀和 */ }

// 递归分治
void solve(int l, int r, vector<Board> boards) {
    if (l == r) {
        for (auto b : boards) ans[l] += b.s == 0;
        return;
    }
    int mid = (l+r)/2;
    // 添加[l,mid]区间子弹
    for (int i=l; i<=mid; i++) update(bullet[i].pos);
    
    vector<Board> left, right;
    for (auto b : boards) {
        int cnt = query(b.r) - query(b.l-1);
        if (cnt >= b.s) left.push_back(b);
        else right.push_back({b.l, b.r, b.s - cnt});
    }
    
    // 移除子弹
    for (int i=l; i<=mid; i++) update(bullet[i].pos, -1);
    
    solve(l, mid, left);
    solve(mid+1, r, right);
}
```

---

## 个人心得摘录
> "调这种题要时刻注意细节，样例弱的一匹，不行就自己捏几个。"  
> —— Suzt_ilymtics（调试经验）  

> "注意要处理木板可能从未被击碎的情况，通过m+1虚拟子弹统一处理"  
> —— JeffZhao（边界处理）  

> "离散化时对空坐标插入INF值，避免后续查询出错"  
> —— MuYC（离散化技巧） 

---

## 复古像素化实现（伪代码）
```javascript
// Canvas绘制子弹序列
function drawBullets() {
    ctx.fillStyle = "#FF0000";
    bullets.forEach((b, idx) => {
        if (idx >= currentL && idx <= currentR) 
            ctx.fillRect(b.x*10, 50, 8, 8); // 当前区间红色方块
    });
}

// 木板破碎动画
function breakBoard(board) {
    anime({
        targets: board,
        scale: 0,
        duration: 500,
        easing: 'easeOutElastic',
        complete: () => playSound('explode.wav')
    });
}
```

---
处理用时：107.76秒
# 题目信息

# [ZJOI2022] 众数

## 题目描述

九条可怜是一个有超能力的女孩子，但她的超能力只能作用于一些奇怪的事情上。

有一天，可怜得到了一个序列 $a_1, a_2, \ldots, a_n$，她可以对这个序列使用一次超能力: 选择一个区
间 $[l, r]$（$1 \le l \le r \le n$）和一个整数 $k \in [-{10}^9, {10}^9]$，将区间内的所有数 $a_l, a_{l + 1}, \ldots, a_r$ 加上 $k$。

九条可怜很喜欢长得比较一致的序列，因此她希望最终的序列众数的出现次数尽可能多。给出序列 $a$，你需要输出最终序列的众数出现次数的最大值，并输出这个众数的所有可能取值。注意对于一个序列，众数的取值可能不止一个。

## 说明/提示

对于所有测试点：$1 \le T \le 20$，$2 \le n \le 2 \times {10}^5$，$1 \le a_i \le {10}^9$，保证 $\sum n \le 5 \times {10}^5$，且 $a_i$ 不全相等。

每个测试点的具体限制见下表：

| 测试点编号 | $\sum n \le$ | $n \le$ | 特殊限制 |
|:-:|:-:|:-:|:-:|
| $1 \sim 4$ | $3000$ | $300$ | 无 |
| $5 \sim 8$ | $5 \times {10}^5$ | $2 \times {10}^5$ | $a_i$ 只有 $5$ 种取值 |
| $9 \sim 10$ | $2 \times {10}^5$ | $50000$ | 无 |
| $11 \sim 20$ | $5 \times {10}^5$ | $2 \times {10}^5$ | 无 |

## 样例 #1

### 输入

```
4
5
1 2 3 2 1
5
1 1 3 1 1
6
2 4 2 4 8 8
5
1 2 3 4 5
```

### 输出

```
4
1
5
1
4
2
4
8
2
1
2
3
4
5
```

## 样例 #2

### 输入

```
见附件中的 mode/mode_ex2.in```

### 输出

```
见附件中的 mode/mode_ex2.ans```

# AI分析结果



### **算法分类**
根号分治

---

### **综合分析与结论**

#### **核心思路**
- **根号分治**：将数按出现次数分为大块（>√n）和小块（≤√n），分别处理。
- **大块处理**：暴力枚举大块作为内外众数，通过前缀和优化计算贡献。
- **小块处理**：扫描线维护每个左端点的众数出现次数，利用单调性优化更新。

#### **解决难点**
1. **大块贡献计算**：通过预处理前缀和，快速计算区间内外的贡献差。
2. **小块动态维护**：利用 `S` 数组记录左端点的众数出现次数，结合颜色出现位置进行跳跃更新。
3. **复杂度平衡**：大块处理复杂度 O(n√n)，小块处理复杂度 O(n√n)，整体 O(n√n)。

#### **可视化设计思路**
- **动画流程**：
  1. **大块处理**：高亮所有大块出现位置，动态显示前缀和计算过程。
  2. **小块扫描**：用滑动窗口表示当前右端点，逐步更新 `S` 数组并标记跳跃点。
  3. **众数更新**：当找到更优解时，触发高亮和音效。
- **颜色标记**：
  - 红色：当前处理的大块或扫描线右端点。
  - 绿色：有效更新的 `S` 数组区间。
  - 蓝色：最终确定的众数出现位置。

---

### **题解清单（≥4星）**

1. **JoshAlMan（5星）**  
   - **亮点**：清晰的根号分治框架，通过前缀和与扫描线结合，代码结构模块化。
2. **Alex_wei（5星）**  
   - **亮点**：引入双指针维护预处理数组，优化众数查询效率，代码可读性极佳。
3. **dead_X（4星）**  
   - **亮点**：简化了众数更新逻辑，通过预处理极值提升性能，但部分边界处理稍显复杂。

---

### **最优思路提炼**

#### **关键步骤**
1. **大块贡献计算**  
   - 预处理大块的前缀和数组 `s[]`。
   - 对每个其他颜色 `y`，遍历其出现位置，计算最大子段和贡献。
   ```cpp
   void wk1(int x, int y) {
       int v = -1e9, ret = 0;
       for (int A = 0; A < (int)c[y].size(); A++) {
           chkMax(v, -A + s[c[y][A] - 1]);
           chkMax(ret, v + A + 1 + s[n] - s[c[y][A]]);
       }
       chkMax(w[x], ret);
   }
   ```
2. **小块动态维护**  
   - 右端点扫描时更新 `S[]`，利用单调性跳跃式更新：
   ```cpp
   void upd(int x, int y) {
       while (x && S[x] < y) S[x--] = y;
   }
   ```

---

### **同类型题推荐**
1. **CF103D Time to Raid Cowavans**（根号分治+预处理）
2. **P4137 Rmq Problem**（莫队/分块处理众数）
3. **P5355 [Ynoi2017] 由乃打扑克**（分块与阈值设计）

---

### **个人心得摘录**
> "根号分治的关键在于平衡预处理和实时计算的复杂度，大块暴力时要充分利用其数量少的特性，小块则要设计高效的批量更新策略。" —— JoshAlMan

---

### **可视化与算法演示**

#### **核心算法流程**
```javascript
// 伪代码：根号分治可视化
function visualize() {
    // 初始化颜色分类
    const bigBlocks = getBigBlocks(√n);
    bigBlocks.forEach(block => {
        highlight(block, 'red'); // 高亮大块
        calcPrefixSum(block);     // 显示前缀和计算动画
        findMaxSubarray(block);   // 动态显示最大子段和
    });

    // 小块扫描过程
    let r = 1;
    while (r <= n) {
        if (isSmallBlock(a[r])) {
            updateSArray(r);      // 显示S数组更新跳跃
            highlight(r, 'green');// 当前右端点
            checkContributions(r);
        }
        r++;
    }
}
```

#### **复古像素风格实现**
```javascript
// Canvas绘制示例
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
const colors = ['#000', '#f00', '#0f0', '#00f']; // 黑、红、绿、蓝

function drawBlock(pos, colorIdx) {
    ctx.fillStyle = colors[colorIdx];
    ctx.fillRect(pos * 10, 0, 10, 10); // 每个块占10x10像素
}

// 音效触发
function playSound(effect) {
    const sfx = {
        update: new Audio('data:audio/wav;base64,UklGRl9...'), 
        solved: new Audio('data:audio/wav;base64,UklGRho...')
    };
    sfx[effect].play();
}
```

---

### **完整代码参考**
```cpp
// 核心代码（JoshAlMan 题解关键部分）
void big() {
    for (int i = 1; i <= len; i++) {
        if ((int)c[i].size() > B) {
            memset(s, 0, sizeof(s));
            for (int v : c[i]) s[v] = 1;
            partial_sum(s + 1, s + n + 1, s + 1);
            for (int j = 1; j <= len; j++)
                if (i != j) wk1(i, j);
            for (int j = 1; j <= len; j++)
                if ((int)c[j].size() <= B) wk2(i, j);
        }
    }
}

void small() {
    memset(S, 0, sizeof(S));
    for (int i = 1; i <= n; i++) {
        if ((int)c[a[i]].size() <= B) {
            int val = (int)c[a[i]].size() - loc[i] + S[1];
            for (int j = loc[i] - 1; j >= 0; j--) {
                int p = c[a[i]][j];
                val = max(val, j + 1 + (int)c[a[i]].size() - loc[i] + S[p + 1]);
            }
            w[a[i]] = max(w[a[i]], val);
            for (int j = loc[i]; j >= 0; j--)
                upd(c[a[i]][j], loc[i] - j + 1);
        }
    }
}
```

---
处理用时：92.55秒
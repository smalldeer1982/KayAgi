# 题目信息

# 『STA - R2』机场修建

## 题目背景

智利在修机场。  

## 题目描述

有 $n$ 个城市排成一列，最开始是互不连通的。  
每个城市初始都没有人口。  
会出现以下操作 / 查询共 $m$ 个：  

1. `1 x y` 开通城市 $x$ 和城市 $y$ 之间的双向航班。  
2. `2 l r a` 城市 $[l, r]$ 的人口数都 $+a$。  
3. `3 x` **如果**所有能够到达城市 $x$ 的人都来到城市 $x$，城市 $x$ 有多少人。  

## 说明/提示

**本题捆绑测试。**  
- Easy（5pts）：$1 \le n, m \le 2 \times 10^5$，且不存在操作 $1$。  
- Normal（10pts）：$1 \le n, m \le 1000$。  
- Hard（20pts）：$1 \le n, m \le 10^5$，且操作 $3$ 之后不存在操作 $2$。  
- Lunatic（30pts）：$1 \le n, m \le 5 \times 10^4$。 
- Overdrive（35pts）：$1 \le n, m \le 2 \times 10^5$。  

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^5$，$0 \le a \le 10^9$。保证答案在 64 位有符号整形表示的范围内。

![](https://cdn.luogu.com.cn/upload/image_hosting/dgqoqa8d.png)  
出于某些原因，给了较多的部分分。  

## 样例 #1

### 输入

```
5 5
1 2 4
2 3 5 2
3 2
1 2 5
3 2```

### 输出

```
2
4```

# AI分析结果



### 唯一算法分类
分块 + 并查集

---

### 综合分析与结论

#### 核心算法流程
1. **分块处理**：将城市编号分块（块长 $\sqrt{n}$），每个块维护整块加法标记
2. **并查集优化**：用并查集维护连通性，每个连通块维护：
   - 散块贡献 `sum[u]`：直接累加到每个节点的值
   - 整块统计 `sm[u]`：存储该连通块在各个块中的点数
3. **区间加处理**：
   - 散点：直接修改所在连通块的 `sum` 值
   - 整块：维护块级加法标记 `tg[]`
4. **合并操作**：合并两个连通块时，合并其散块贡献和整块统计数组
5. **查询操作**：计算 `sum[u] + ∑(sm[u][i] * tg[i])` 的线性组合

#### 可视化设计要点
- **分块结构展示**：用不同颜色区分整块和散块，动态显示块标记 `tg[]` 的变化
- **连通块合并动画**：以粒子效果展示两个连通块的整块统计数组合并过程
- **查询数值流动**：用光柱效果连接当前连通块的 `sum` 值与各个块的 `tg[]` 标记
- **复古像素风格**：城市编号用 8x8 像素方块表示，连通块合并时产生经典 FC 音效

---

### 题解评分（≥4星）

#### 1. honglan0301（5星）
**亮点**：
- 动态数组优化空间至 $O(n)$
- 代码仅 40 行，实现极简分块合并
- 关键变量 `sm[u]` 用 `vector<pair>` 存储非零块

#### 2. Pengzt（4星）
**亮点**：
- 散块/整块分离处理逻辑清晰
- 使用 `vector` 归并合并块统计信息
- 代码含详细注释，易理解核心流程

#### 3. lht1217（4星）
**亮点**：
- 块长参数化（B=600）方便调整
- 链表维护小连通块的点集合
- 合并时根据大小动态切换处理策略

---

### 最优思路与技巧提炼

#### 关键优化技巧
```cpp
// 动态维护整块统计（honglan0301 解法核心）
for(auto i:sm[u]) ns[i.fi]+=i.se; // 合并临时数组
sm[v].clear(); 
for(int i=1;i<=k[n];i++) if(ns[i]) sm[v].pb(i,ns[i]);
```

#### 思维突破点
- **分块贡献分离**：将区间加拆解为散点直接加、整块标记加
- **延迟计算**：查询时才计算 `∑(块内点数 * 块标记)`，避免实时维护
- **空间压缩**：仅记录非零块的统计信息，节省 $O(n\sqrt{n})$ 空间

---

### 类似题目推荐
1. **P4119 [Ynoi2018] 未来日记**  
   （分块 + 并查集维护区间第 k 大）
2. **P3203 [HNOI2010]弹飞绵羊**  
   （分块维护跳跃路径）
3. **P4219 [BJOI2014]大融合**  
   （并查集维护动态连通性统计）

---

### 核心代码实现（以 honglan0301 解法为例）
```cpp
// 合并操作核心代码
void merge(int u, int v) {
    if (u == v) return;
    if (sz[u] > sz[v]) swap(u, v);
    for (int i : num[u]) bh[i] = v; // 更新所属连通块
    vector<pair<int, int>> tmp;
    // 合并整块统计（图示关键步骤）
    for (auto p : sm[u]) ns[p.first] += p.second;
    for (auto p : sm[v]) ns[p.first] += p.second;
    for (int i = 1; i <= k[n]; i++)
        if (ns[i]) tmp.emplace_back(i, ns[i]);
    sm[v] = tmp; // 更新后的整块统计
    sum[v] += sum[u]; // 合并散块贡献
}
```

---

### 复古像素风格可视化设计
**颜色方案**：
- 城市节点：16 色调色板，按块编号着色
- 连通块：同色系渐变色表示合并过程
- 标记传播：波纹扩散动画显示 `tg[]` 更新

**音效设计**：
- 合并成功：FC 风格 8-bit "ping" 音
- 区间加：根据块数播放不同音高
- 查询完成：马里奥吃金币音效

**自动演示模式**：
```javascript
// 伪代码示例
class Demo {
  constructor() {
    this.blocks = initPixelBlocks(n); // 初始化像素方块
    this.playSound('bgm'); // 开始播放循环背景音乐
  }
  
  animateMerge(u, v) {
    uBlocks = this.getBlocks(u); // 获取 u 的像素块
    vBlocks = this.getBlocks(v);
    this.highlight(uBlocks, 'red'); // 高亮要合并的块
    this.playSound('merge_start');
    // 粒子动画合并过程...
    this.updateBlockStats(u, v); // 更新统计显示
  }
}
```

---
处理用时：73.47秒
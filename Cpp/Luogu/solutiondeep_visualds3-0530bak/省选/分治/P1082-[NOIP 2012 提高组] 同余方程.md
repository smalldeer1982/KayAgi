# 题目信息

# [NOIP 2012 提高组] 同余方程

## 题目描述

求关于 $ x$ 的同余方程 $ a x \equiv 1 \pmod {b}$ 的最小正整数解。


## 说明/提示

### 数据规模与约定

- 对于 $40\%$ 的数据，$2 ≤b≤ 1,000$；
- 对于 $60\%$ 的数据，$2 ≤b≤ 50,000,000$；
- 对于 $100\%$ 的数据，$2 ≤a, b≤ 2,000,000,000$。



## 样例 #1

### 输入

```
3 10```

### 输出

```
7```

# AI分析结果



## 1. 算法分类  
扩展欧几里得算法

---

## 2. 核心思路与解决难点  
### 关键步骤与变量  
1. **问题转化**：将同余方程转化为线性方程 `ax + by = 1`，要求 `gcd(a, b) = 1`  
2. **扩展欧几里得算法**：递归求解 `ax + by = gcd(a, b)`，递归边界 `b=0` 时返回 `x=1, y=0`  
3. **解的调整**：通过 `(x % b + b) % b` 得到最小正整数解  

### 核心难点  
1. **递归过程理解**：从 `gcd(a, b)` 到 `gcd(b, a%b)` 的递归推导  
2. **解的传递**：递归回溯时 `x, y` 的更新公式 `x = y_prev, y = x_prev - (a//b)*y_prev`  
3. **负数处理**：通过模运算将可能的负数解转为最小正整数  

---

## 3. 题解评分（≥4星）  

### 学委（5星）  
- **亮点**：完整推导扩展欧几里得算法的递归过程，代码清晰，处理负数解简洁  
- **代码片段**：  
  ```cpp
  exgcd(b, a % b);
  long long tx = x; x = y; y = tx - a / b * y; 
  x = (x % b + b) % b; // 关键调整
  ```

### 陈曦（4星）  
- **亮点**：对比暴力/快速幂/扩展欧几里得三种方法，突出扩展欧几里得的优势  
- **代码片段**：  
  ```cpp
  exgcd(a, b, x, y); // 直接调用扩展欧几里得
  printf("%d", (x + b) % b);
  ```

### _Nova（4星）  
- **亮点**：结合裴蜀定理详细分析解的数学性质，给出通解推导过程  
- **代码片段**：  
  ```cpp
  exgcd(b, a%b, x, y); // 递归参数交换
  y -= a / b * x; // 回溯更新y
  ```

---

## 4. 最优思路与技巧  
**关键技巧**：  
1. **递归交换参数**：`exgcd(b, a%b, y, x)` 简化计算  
2. **直接模运算调整**：`x = (x % b + b) % b` 避免循环加减  
3. **全局变量传递解**：利用全局变量 `x, y` 简化递归参数传递  

---

## 5. 同类型题拓展  
**通用解法**：  
1. 线性同余方程 `ax ≡ c (mod b)` → 扩展欧几里得求 `ax + by = c`  
2. 逆元问题 → `a^(p-2) % p`（费马小定理，仅限质数）或扩展欧几里得  

**推荐题目**：  
1. [P1516] 青蛙的约会（扩展欧几里得应用）  
2. [P3811] 乘法逆元（多种逆元解法）  
3. [P5656] 二元一次不定方程（扩展欧几里得通解）  

---

## 6. 可视化与动画设计  
### 算法流程动画  
**核心逻辑**：  
1. **递归树可视化**：  
   - 绘制递归调用树，高亮当前处理的 `(a, b)` 对  
   - 颜色标记：绿色（活跃节点）、灰色（已处理节点）  
2. **变量更新动态**：  
   - 在回溯阶段用箭头标注 `x` 和 `y` 的更新路径  
   - 显示公式 `x_new = y_prev, y_new = x_prev - (a//b)*y_prev`  

**复古像素风格**：  
- **颜色方案**：16色调色板，绿色（当前操作）、红色（边界条件）  
- **音效设计**：  
  - 递归调用：8-bit "blip" 音效  
  - 解调整完成：胜利音效（上升音阶）  
- **Canvas 交互**：  
  - 步进按钮控制递归深度  
  - 自动播放模式展示完整算法流程  

---

## 7. 代码实现（关键部分）  
```cpp
void exgcd(int a, int b, int &x, int &y) {
    if (b == 0) { x = 1; y = 0; return; }
    exgcd(b, a % b, y, x); // 递归交换x,y
    y -= a / b * x;        // 回溯更新y
}

int main() {
    int a, b, x, y;
    cin >> a >> b;
    exgcd(a, b, x, y);
    cout << (x % b + b) % b; // 最小正解调整
}
```

---

## 8. 个人调试心得  
**学委题解中的调试点**：  
- 递归边界 `y = 7` 仍能通过测试，说明 `y` 的取值不影响最终 `x` 的调整  
- 验证发现 `exgcd` 的中间变量 `tx` 必须暂存 `x` 的旧值  

**沙普绿12138的局限**：  
- 计算欧拉函数 `φ(b)` 需分解质因数，时间复杂度 `O(√b)`，对大质数 `b` 效率低于扩展欧几里得  

---

## 9. 总结  
扩展欧几里得算法通过递归和参数交换，高效求解线性同余方程。关键点在于递归边界的处理和回溯时的变量更新，最终通过模运算得到最小正解。结合递归动画和复古像素风格的可视化，能直观展示算法核心逻辑。

---
处理用时：66.33秒
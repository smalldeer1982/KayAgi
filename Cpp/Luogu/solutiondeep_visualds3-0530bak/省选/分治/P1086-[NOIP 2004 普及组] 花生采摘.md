# 题目信息

# [NOIP 2004 普及组] 花生采摘

## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。

**注意**：在采摘过程中不能回到路边。

## 说明/提示

noip2004普及组第2题


## 样例 #1

### 输入

```
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0```

### 输出

```
37```

## 样例 #2

### 输入

```
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```

### 输出

```
28```

# AI分析结果



## 算法分类
**模拟**

---

## 题解思路与核心难点分析

### 核心思路
所有题解均遵循以下核心流程：
1. **数据预处理**：提取有花生的坐标并存储为结构体（含坐标和花生数）
2. **排序**：按花生数从大到小排序，确保按题目要求的采摘顺序
3. **模拟采摘**：
   - 起点为路边（行号为0的特殊坐标）
   - 每次计算到下一个点的曼哈顿距离
   - 判断总时间是否足够（移动时间+采摘时间+返回时间）

### 关键难点与解决方案
1. **时间计算精度**：
   - 必须同时计算移动时间（曼哈顿距离）和采摘时间（固定+1）
   - 返回时间只与当前点的行号有关（回到第一行需要 `当前行数` 单位时间）
   - **解决**：每次循环先扣除移动与采摘时间，再判断剩余时间是否 ≥ 当前行数

2. **初始状态的特殊处理**：
   - 第一次从路边跳入田间（行号为0到第一棵花生行号）
   - **解决**：单独处理第一棵花生的时间消耗，如 jiangXxin 的 `k -= b[1][1] + 1`

3. **边界条件**：
   - 花生数为0的测试点（直接输出0）
   - 仅有一株花生时的特判（MC_long_live 的 `if (k>=(b[1][1]*2+1))`）
   - **解决**：在排序后立即检查最大花生是否可采摘

---

## 题解评分 ≥4星

### 1. jiangXxin（4.5星）
- **亮点**：代码结构清晰，注释完整，曼哈顿距离计算准确
- **关键代码**：
  ```cpp
  sort(stu+1,stu+pn+1,comp); // 按花生数排序
  k--; // 进入田间耗时
  if(k >= ex) ans += mp[ex][ey]; // 判断返回时间是否足够
  ```

### 2. _Arahc_（4星）
- **创新点**：使用 `priority_queue + map` 实现动态排序
- **关键优化**：自动跳过0值，通过堆维护最大值，代码量减少30%
- **注意点**：需处理 `map` 中相同花生数的冲突（题目保证无重复）

### 3. lby_commandBlock（4星）
- **优势**：代码极简（仅33行），降维处理二维数组
- **核心逻辑**：
  ```cpp
  k -= (abs(a[i].x - x_prev) + abs(a[i].y - y_prev) + 1);
  if (k >= a[i].x) ans += a[i].val; // 剩余时间足够返回
  ```

---

## 最优思路提炼
1. **曼哈顿距离代替BFS**：由于无障碍物，两点间最短距离为 `|x1-x2| + |y1-y2|`
2. **降维存储**：用结构体数组或优先队列存储非零花生点，减少无效遍历
3. **时间扣除顺序**：先扣除移动与采摘时间，再判断剩余时间是否足够返回

---

## 类似题目推荐
1. **P1042 乒乓球**：模拟比赛得分过程，处理多种状态切换
2. **P1056 排座椅**：贪心选择最优分割线，需排序和模拟
3. **P1518 两只老虎**：网格移动模拟，方向与时间管理

---

## 可视化设计
### 核心算法演示（Canvas实现）
1. **网格绘制**：棕色背景表示土地，绿色方块表示花生植株，颜色深浅表示数量
2. **移动路径**：红色高亮线显示当前移动路径，黄色标记已采摘点
3. **状态面板**：
   - 剩余时间：`Time: 21 → 17 → ...`
   - 已采花生：`Peanuts: 15 → 37 → ...`

### 复古像素风格（8-bit）
- **颜色方案**：16色调色板，用深绿（#1d6b53）表示植株，亮黄（#f8d700）表示当前点
- **音效设计**：
  - 移动时播放 "bleep" 音效（8-bit 短音）
  - 采摘成功时播放 "coin" 音效（高频率方波）

### 交互功能
- **步进控制**：空格键单步执行，Enter键自动播放（速度可调）
- **路径回放**：按 R 键重放当前采摘过程，显示时间消耗变化

---

## 核心代码片段
```cpp
// 降维存储与排序（jiangXxin 题解核心）
struct dire { int x,y,sum; } stu[N*N];
sort(stu+1, stu+pn+1, [](dire a, dire b){ return a.sum > b.sum; });

// 时间扣除逻辑（MC_long_live 题解）
k -= (abs(prev_x - curr_x) + abs(prev_y - curr_y) + 1);
if (k >= curr_x) ans += curr_sum;
else break;

// 优先队列动态维护（_Arahc_ 题解）
priority_queue<int> q;
q.push(a[i][j]);
auto [x,y] = map[q.top()]; q.pop();
```

---

## 个人心得摘录
- **调试教训**：初始位置应设为 `(0, y)` 而非 `(1, y)`，否则会少算进入田间的时间（_Arahc_）
- **优化顿悟**：无需遍历全图，只需处理非零节点，复杂度从 O(n²) 降至 O(k)（MC_long_live）

---

通过上述分析与实现，可在保证时间复杂度 O(n log n) 的前提下，准确模拟采摘过程，适用于洛谷等OJ平台的大数据量测试。

---
处理用时：74.07秒
# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果



## 唯一算法分类
广度优先搜索（BFS）

---

## 综合分析与结论
### 核心算法流程
1. **分层遍历**：利用BFS按层扩展，保证每个节点的首次访问即得到最短路径长度  
2. **路径计数**：维护`ans[]`数组，当节点首次被访问时继承父节点路径数，多次访问时累加相同深度的父节点路径数  
3. **状态标记**：使用`vis[]`标记已访问节点，`dis[]`记录最短距离，`ans[]`动态更新路径计数  

### 可视化设计要点
- **网格绘制**：将节点布局为网格，边用线条表示  
- **颜色编码**：
  - 红色：当前处理节点
  - 绿色：已确定最短路径的节点  
  - 黄色：队列中待处理的节点  
- **动态计数显示**：在节点旁实时显示`ans[]`数值的变动过程  
- **音效触发**：发现新节点时播放"滴"声，累加计数时播放"咔嗒"声  

---

## 题解清单 (4+星)
### 1. 岸芷汀兰（5星）
- **亮点**：明确指出BFS的适用性，代码中`vector`存储邻接表，通过`dis+1 == d[cur]`判断同层路径  
- **核心代码**：
```cpp
if(!vis[cur]) {
    q.push(make(cur, dis + 1)); 
    ans[cur] = ans[x];  // 首次访问继承父节点路径数
} else if(dis + 1 == d[cur]) {
    ans[cur] += ans[x]; // 同层路径累加
}
```

### 2. 圣堂之地（4星）
- **亮点**：使用链式前向星存储图结构，通过`dis[y] > dis[x]+1`判断路径更新  
- **调试心得**：特别处理自环情况`if(x == y) continue`防止无效计算  

### 3. King丨帝御威（4星）
- **优化点**：采用堆优化Dijkstra实现，通过优先队列保证处理顺序  
- **关键技巧**：使用`pair<int,int>`存储节点和距离，实现自动排序  

---

## 最优思路与技巧
### 分层递推策略
- **分层遍历**：BFS保证节点按距离从小到大处理  
- **路径继承规则**：
  - `dis[y] > dis[x]+1` → 重置路径数为父节点值  
  - `dis[y] == dis[x]+1` → 累加父节点路径数  
- **MOD取模**：每次更新路径数后立即取模防止溢出  

### 邻接表优化
```cpp
vector<int> linker[maxn]; // 存储邻接关系
for(int i=0;i<linker[u].size();i++) // 遍历邻接节点
```

---

## 同类题目推荐
1. P1608 路径统计（带权图最短路计数）  
2. P2296 寻找道路（BFS+条件过滤）  
3. P3393 逃离僵尸岛（分层BFS应用）  

---

## 可视化实现示例（伪代码）
```javascript
class BFSSimulation {
  constructor(nodes, edges) {
    this.grid = new PixelGrid(800, 600); // 8-bit风格画布
    this.queue = new Queue();
    this.playSound('start.wav'); // 开始音效
  }

  step() {
    let curr = this.queue.dequeue();
    this.highlightNode(curr, 0xFF0000); // 红色高亮当前节点
    curr.edges.forEach(neighbor => {
      if(neighbor.dis > curr.dis + 1) {
        this.updateDis(neighbor, curr.dis + 1); 
        this.setAns(neighbor, curr.ans); // 播放重置音效
      } else if(neighbor.dis == curr.dis + 1) {
        this.addAns(neighbor, curr.ans); // 播放累加音效
      }
    });
  }
}
```

---

## 关键代码实现
### BFS核心逻辑
```cpp
void bfs() {
    queue<int> q;
    q.push(1);
    dis[1] = 0; ans[1] = 1;
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int v : adj[u]) {
            if(!vis[v]) { // 首次访问
                dis[v] = dis[u] + 1;
                ans[v] = ans[u];
                q.push(v);
                vis[v] = true;
            } else if(dis[v] == dis[u] + 1) { // 同层累加
                ans[v] = (ans[v] + ans[u]) % MOD;
            }
        }
    }
}
```

---
处理用时：60.31秒
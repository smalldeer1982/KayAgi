# 题目信息

# 打保龄球

## 题目描述

打保龄球是用一个滚球去打击十个站立的柱，将柱击倒。一局分十轮，每轮可滚球一次或多次，以击倒的柱数为依据计分。一局得分为十轮得分之和，而每轮的得分不仅与本轮滚球情况有关，还可能与后续一两轮的滚球情况有关。即某轮某次滚球击倒的柱数不仅要计入本轮得分，还可能会计入前一两轮得分。具体的滚球击柱规则和计分方法如下：

1. 若某一轮的第一次滚球就击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加两次滚球，不妨称其为第十一轮和第十二轮，并不是所有的情况都需要滚第十一轮和第十二轮球）。该轮得分为本次击倒柱数 $10$ 与以后两次滚球所击倒柱数之和。

2. 若某一轮的第一次滚球未击倒十个柱，则可对剩下未倒的柱再滚球一次。如果这两次滚球击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加一次滚球），该轮得分为这两次共击倒柱数 $10$ 与以后一次滚球所击倒柱数之和。

3. 若某一轮两次滚球未击倒全部十个柱，则本轮不再继续滚球，该轮得分为这两次滚球击倒的柱数之和。   

总之，若―轮中一次滚球或两次滚球击倒十个柱，则本轮得分是本轮首次滚球开始的连续三次滚球击倒柱数之和（其中有一次或两次不是本轮滚球）。若一轮内二次滚球击倒柱数不足十个，则本轮得分即为这两次击倒柱数之和。下面以实例说明如下(字符 `/` 表示击倒当前球道上的全部的柱)：

| 轮 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| 击球情况  |  /  |  /  |  /  |  72 |  9/ |  81  | 8/  |  / |   9/  |  /  |  8/ |
| 各轮得分 |  30  | 27  | 19 |  9   |18   | 9  | 20  | 20 |  20 |  20|
|累计总分 |  30  | 57  |76 |  85|  103 |  112 | 132  |152 | 172 | 192|

现在请你编写一个保龄球实时计分程序，用来计算和显示某轮结束后的得分情况。若某轮的得分暂时无法算出，则**不显示**该轮得分（不输出）。


## 样例 #1

### 输入

```
/ / / 72 9/ 81 8/ / 9/ / 8/```

### 输出

```
30 27 19 9 18 9 20 20 20 20 
30 57 76 85 103 112 132 152 172 192```

# AI分析结果



## 算法分类
**模拟**

---

## 题解思路与核心难点

### 核心逻辑
1. **输入解析**：将输入字符串转换为击球记录数组，处理特殊符号`/`（全中）和数字（击倒数）。
2. **轮次追踪**：识别每次击球对应的轮次，处理第十轮后续两次击球的特殊情况。
3. **得分计算**：
   - **全中（Strike）**：当前轮得分 = 10 + 后续两次击球得分
   - **补中（Spare）**：当前轮得分 = 10 + 下一次击球得分
   - **普通情况**：直接累加两次击球得分
4. **得分依赖检查**：若后续击球未完成导致无法计算当前轮得分，则不显示该轮结果。

### 解决难点
- **轮次边界判断**：第十轮全中/补中需要额外击球，但不需要单独增加轮次编号。
- **依赖检查优化**：通过预存所有击球记录，判断后续击球是否存在，避免数组越界。
- **状态标记**：用辅助数组标记每轮是否完成击球，动态计算可显示的轮次。

---

## 题解评分（≥4星）

### 袁宇轩（4.5星）
- **亮点**：用`st`指针标记每轮起始位置，通过三次滚球模拟处理全中/补中依赖，代码简短高效。
- **关键代码**：
  ```cpp
  for (int j=st; j<=st+2; j++) { // 模拟三次滚球
    if (j>n) { sum[i]=-1; break; } // 边界检查
    if (rest==0) rest=10, flag=0; // 重置剩余瓶数
    if (j==st+2 && flag) break;  // 普通情况提前终止
    // 分数计算逻辑...
  }
  ```

### Shadow_T（4星）
- **亮点**：通过结构体数组存储每轮两次击球数据，清晰分离状态标记与分数计算。
- **调试心得**：处理`p1166[i][1]==10`时发现`st[i+1][1]`未初始化导致错误，增加`-1`标记。

### 天南星魔芋（4星）
- **亮点**：使用`map`和`Time`数组记录每轮得分影响范围，动态更新前轮分数。
- **关键技巧**：将`/`转换为实际击倒数（如`10 - 前次击球数`），避免后续计算混淆。

---

## 最优思路提炼

### 关键数据结构
```cpp
int strike[12];      // 每轮击球记录（0-9为常规轮，10-11为额外轮）
bool valid[12][3];  // 标记击球是否存在（轮号，击球次数）
```

### 核心步骤
1. **预处理输入**：
   ```cpp
   for (char c : input) {
     if (c == '/') strike[cur] = 10 - strike[cur-1];
     else strike[cur] = c - '0';
     valid[cur] = true;
     // 更新轮次指针cur...
   }
   ```
2. **动态计算得分**：
   ```cpp
   for (int round=0; round<10; ++round) {
     if (is_strike(round)) {
       if (!valid[round+1] || !valid[round+2]) break; // 无法计算
       score = 10 + strike[round+1] + strike[round+2];
     } else if (is_spare(round)) {
       if (!valid[round+2]) break; // 无法计算
       score = 10 + strike[round+2];
     } else {
       score = strike[round] + strike[round+1];
     }
     total += score;
   }
   ```

---

## 类似题目推荐
1. **P1042 乒乓球** - 模拟比赛得分规则
2. **P1563 玩具谜题** - 环形结构的状态模拟
3. **P1067 多项式输出** - 复杂格式条件的处理

---

## 可视化设计

### 动画方案
![保龄球计分动画示意图](https://i.postimg.cc/8CJ3Tb3Z/bowling-anim.gif)
1. **轮次高亮**：当前处理轮次显示为绿色，依赖的后续击球显示为黄色。
2. **分数追踪**：右侧面板实时显示每轮得分和累计总分，无法计算的轮次标记为灰色。
3. **复古像素风**：
   - **颜色方案**：16色调色板，绿色（#00FF00）表示当前轮，红色（#FF0000）表示错误。
   - **音效**：击球时播放8-bit音效，得分时播放上升音调，错误时短促"哔"声。

### 交互功能
- **步进控制**：空格键单步执行，方向键调整执行速度。
- **自动演示**：AI模式自动遍历所有击球记录，用不同颜色标记依赖关系。

---

## 核心代码（袁宇轩题解关键逻辑）
```cpp
int st = 1; // 当前轮起始击球位置
for (int i=1; i<=10; i++) {
    int rest = 10, flag = 1; // 剩余瓶数，是否全中
    for (int j=st; j<=st+2; j++) {
        if (j > n) { sum[i] = -1; break; }
        if (rest == 0) { rest = 10; flag = 0; } // 重置
        if (j == st+2 && flag) break; // 普通情况终止
        // 计算击球得分...
    }
    if (sum[i] == -1) break;
    if (a[st] == '/') st++; // 全中则下一位置
    else st += 2; // 普通情况跳两次
}
```

---

通过分轮次动态追踪击球位置，结合后续依赖检查，该方案在代码简洁性与正确性间取得平衡，是解决此类模拟问题的经典范式。

---
处理用时：79.49秒
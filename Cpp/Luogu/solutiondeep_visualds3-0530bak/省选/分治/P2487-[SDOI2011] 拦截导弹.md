# 题目信息

# [SDOI2011] 拦截导弹

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度、并且能够拦截任意速度的导弹，但是以后每一发炮弹都不能高于前一发的高度，其拦截的导弹的飞行速度也不能大于前一发。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

在不能拦截所有的导弹的情况下，我们当然要选择使国家损失最小、也就是拦截导弹的数量最多的方案。但是拦截导弹数量的最多的方案有可能有多个，如果有多个最优方案，那么我们会随机选取一个作为最终的拦截导弹行动蓝图。

我方间谍已经获取了所有敌军导弹的高度和速度，你的任务是计算出在执行上述决策时，每枚导弹被拦截掉的概率。


## 说明/提示



保证总方案数不超过 C++ 中 double 类型的存储范围。

### 数据范围及约定

- 均匀分布着约 $30\%$ 的数据，所有 $v_i$ 均相等；
- 均匀分布着约 $50\%$ 的数据，满足 $1\le h_i,v_i\le 1000$。
- 对于 $30\%$ 的数据，满足 $1\le n\le 1000$；
- 对于 $100\%$ 的数据，$1\le n\le 5\times 10^4$，$1\le h_i,v_i\le 10^9$。

### 评分标准

对于每个测试点，若输出的第一行与标准输出相同，则得到该测试点 $40\%$ 的分数，若输出文件的第二行的每个数与标准输出的误差均不大于 $10^{-4}$，则得到该测试点 $60\%$ 的分数，两项相加作为该测试点总得分。

## 样例 #1

### 输入

```
4
3 30
4 40
6 60
3 30
```

### 输出

```
2
0.33333 0.33333 0.33333 1.00000
```

# AI分析结果



## 算法分类
CDQ分治优化动态规划

---

## 题解思路与核心难点

### 核心算法流程
1. **三维偏序转换**：题目中导弹按时间顺序给出，天然满足时间维度的顺序，转化为二维偏序问题（高度、速度）。
2. **两次CDQ分治**：
   - **正序处理**：计算以每个导弹结尾的最长不上升子序列长度 `f1` 及方案数 `g1`。
   - **逆序处理**：将导弹序列反转后计算以每个导弹开头的最长不上升子序列长度 `f2` 及方案数 `g2`。
3. **树状数组维护**：在CDQ分治过程中，用树状数组维护第三维（速度）的最大值及对应的方案数，优化动态规划转移。
4. **离散化处理**：对高度和速度进行离散化，减少树状数组的空间需求。

### 解决难点
- **动态规划优化**：通过CDQ分治将二维偏序问题分解，避免O(n²)复杂度。
- **方案数统计**：树状数组需同时维护最大值和对应的方案数，避免溢出使用`double`存储。
- **概率计算**：若导弹出现在最长序列中，概率为 `(g1[i] * g2[i]) / total`。

---

## 题解评分（≥4星）

### 1. shadowice1984（5星）
- **亮点**：代码简洁高效，逻辑清晰，利用`double`处理方案数，避免溢出问题。
- **关键代码**：
  ```cpp
  struct Tree_arry{ /* 树状数组维护最大值及方案数 */ };
  void CDQ(int l,int r,int op){ /* 分治处理左右区间 */ }
  ```

### 2. hsfzLZH1（4.5星）
- **亮点**：详细注释与调试经验分享，适合理解算法细节。
- **关键代码**：
  ```cpp
  void CDQ1(int l, int r, int opt){ 
    /* 分治递归与树状数组更新 */
  }
  ```

### 3. lkytxdy（4星）
- **亮点**：代码短小精悍，递归结构清晰，适合快速实现。
- **关键代码**：
  ```cpp
  void CDQ(int l,int r,int op){
    /* 归并排序与树状数组查询 */
  }
  ```

---

## 最优思路与技巧

### 关键思路
- **分治与树状数组结合**：CDQ分治处理二维偏序，树状数组维护第三维的极值。
- **正反两次处理**：计算每个导弹作为起点和终点的最长序列，结合乘法原理统计概率。
- **离散化优化**：将高度和速度映射到小范围，降低树状数组空间复杂度。

### 实现技巧
1. **树状数组双维护**：同时记录最大值和方案数，更新时判断是否替换或累加。
2. **递归顺序控制**：先处理左区间，再更新右区间，最后递归右区间，确保状态正确性。
3. **逆序处理技巧**：将序列反转并取反高度、速度，复用同一套代码处理反向问题。

---

## 同类题型与推荐题目
1. **P1020 [NOIP1999 提高组] 导弹拦截**  
   （一维最长不上升子序列，基础模板）
2. **P4093 [HEOI2016/TJOI2016] 序列**  
   （二维偏序动态规划，CDQ分治应用）
3. **P3810 【模板】三维偏序（陌上花开）**  
   （标准三维偏序问题，CDQ分治练习）

---

## 代码片段（核心逻辑）

### CDQ分治与树状数组更新
```cpp
struct BIT {
    int max_val[N];
    double cnt[N];
    void update(int x, int val, double c) {
        for (; x <= n; x += x & -x) {
            if (val > max_val[x]) {
                max_val[x] = val;
                cnt[x] = c;
            } else if (val == max_val[x]) {
                cnt[x] += c;
            }
        }
    }
    pair<int, double> query(int x) {
        int res_val = 0;
        double res_cnt = 0;
        for (; x; x -= x & -x) {
            if (max_val[x] > res_val) {
                res_val = max_val[x];
                res_cnt = cnt[x];
            } else if (max_val[x] == res_val) {
                res_cnt += cnt[x];
            }
        }
        return {res_val, res_cnt};
    }
} bit;

void CDQ(int l, int r, int opt) {
    if (l == r) return;
    int mid = (l + r) >> 1;
    CDQ(l, mid, opt);
    sort(a + l, a + mid + 1, cmp_h);
    sort(a + mid + 1, a + r + 1, cmp_h);
    int j = l;
    for (int i = mid + 1; i <= r; ++i) {
        while (j <= mid && a[j].h >= a[i].h) {
            bit.update(a[j].v, f1[a[j].id], g1[a[j].id]);
            j++;
        }
        auto [val, cnt] = bit.query(a[i].v);
        if (val + 1 > f1[a[i].id]) {
            f1[a[i].id] = val + 1;
            g1[a[i].id] = cnt;
        } else if (val + 1 == f1[a[i].id]) {
            g1[a[i].id] += cnt;
        }
    }
    // 清空树状数组，递归右区间
    CDQ(mid + 1, r, opt);
}
```

---

## 可视化设计

### 算法动画演示
1. **分治过程**：  
   - **颜色区分**：左区间标为蓝色，右区间标为红色，当前处理区间高亮黄色。
   - **树状数组更新**：显示插入节点的位置（绿色闪光）和查询路径（橙色高亮）。
2. **像素风格**：  
   - **导弹轨迹**：用8-bit像素块表示导弹，高度和速度映射到屏幕坐标。
   - **CDQ分割线**：动态绘制分割线，展示分治区间缩小过程。
3. **音效设计**：  
   - **插入音效**：树状数组更新时播放“滴”声。
   - **查询完成**：播放短促上扬音调表示转移成功。

### 交互功能
- **步进控制**：支持暂停/继续，调整动画速度（0.5x~2x）。
- **自动演示**：AI模式逐步展示分治和树状数组操作，类似贪吃蛇自动寻路。

---

## 个人调试心得
1. **离散化错误**：初始未对速度去重，导致树状数组越界。  
   （*教训：离散化前务必排序并去重*）
2. **方案数溢出**：未用`double`存储，导致大数计算错误。  
   （*改用`double`后问题解决*）
3. **递归顺序错误**：未按中序遍历（左→更新→右），导致右区间状态未完全更新。  
   （*调整递归顺序后AC*）

---

## 总结
通过CDQ分治将三维偏序降维，结合树状数组高效维护动态规划状态，是解决高维LIS类问题的通用方法。注意离散化和方案数溢出的细节处理，代码结构清晰性和递归顺序是关键。

---
处理用时：99.36秒
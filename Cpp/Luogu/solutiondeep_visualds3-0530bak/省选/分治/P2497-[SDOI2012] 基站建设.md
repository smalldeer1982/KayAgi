# 题目信息

# [SDOI2012] 基站建设

## 题目描述

up 主家终于买电脑了，但是接下来有各种问题要处理。首要解决的问题就是网络问题。他要从移动公司开始，通过一些基站来传递网络到他家。

为了简化问题，我们假设移动公司，所有的基站、up 主家位于同一条直线上，他们都位于这一条直线上的某一点 $x$，这些点**可能**会重合。每个基站发射和接收的范围都是一个切于地面的圆，发射的半径 $r$ 是固定的，接收半径 $r'$ 是可调的的。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/nh8yxjx5.png)

一个基站 $i$ 如果想从另一个基站 $j$ 接收到信号（当且仅当 $x_j<x_i$），必须满足 $i$ 的接收范围与 $j$ 的发射范围**相切**，且需要付 $\sqrt{r'_i}$ 的额外费用。启动每一个点 $i$ 都需要费用 $v_i$。

up 主家如果能接收到某个基站的信号，只需要这个点的发射范围与 up 主家所在的竖线相切或相交即可，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5t4v8687.png)

当然费用越少就越好咯，于是 up 主想要请你帮他的忙。

## 说明/提示

对于 $100\%$ 的数据 $n\le5\times 10^5$，$x_i,m \le 10^{12}$，$v_i \le 10000$

## 样例 #1

### 输入

```
10 33
5 4 660
10 2 2040
11 6 3207
14 5 2006
18 3 6130
19 9 3363
22 1 1265
25 8 2836
27 10 7961
29 7 9075```

### 输出

```
3501.000```

# AI分析结果



## 算法分类
**动态规划 + 斜率优化 + 李超线段树**

---

## 核心思路与难点分析

### 核心思路
1. **动态规划建模**  
   设 `dp[i]` 表示从移动公司（基站1）传递到基站 `i` 的最小费用。状态转移方程为：
   $$
   dp[i] = \min_{j < i} \left( dp[j] + \frac{x_i - x_j}{2\sqrt{r_j}} \right) + v_i
   $$
   其中 $\frac{x_i - x_j}{2\sqrt{r_j}}$ 是调整接收半径的代价。

2. **斜率优化转换**  
   将方程改写为线性形式：
   $$
   dp[i] - v_i = \frac{1}{2\sqrt{r_j}} x_i + \left( dp[j] - \frac{x_j}{2\sqrt{r_j}} \right)
   $$
   这相当于在平面上插入直线 $y = kx + b$，其中：
   - $k = \frac{1}{2\sqrt{r_j}}$（斜率）
   - $b = dp[j] - \frac{x_j}{2\sqrt{r_j}}$（截距）
   
3. **李超线段树优化**  
   使用李超线段树维护动态插入的直线，并查询在 `x_i` 处的最小截距，从而快速计算 `dp[i]`。

### 解决难点
- **非单调性处理**：由于 `k` 和 `x_i` 均无单调性，无法直接用单调队列维护凸包。李超线段树通过离散化 `x_i` 并动态维护最优直线集合，解决了这一难点。
- **高效查询**：每次插入和查询的时间复杂度为 $O(\log n)$，整体复杂度 $O(n \log n)$，适用于 $n \leq 5 \times 10^5$ 的数据规模。

---

## 题解评分（≥4星）

### 1. TKXZ133（⭐⭐⭐⭐⭐）
- **亮点**：推导清晰，代码简洁，离散化处理 `x_i` 后直接使用静态李超线段树。
- **代码片段**：
  ```cpp
  struct ST { // 李超线段树
      int a[N<<2];
      void add(int p, int l, int r, int id) {
          if (l == r) { if (Less(id, a[p], l)) a[p] = id; return; }
          if (Less(id, a[p], mid)) swap(a[p], id);
          if (Less(id, a[p], l)) add(p<<1, l, mid, id);
          if (Less(id, a[p], r)) add(p<<1|1, mid+1, r, id);
      }
      double query(int p, int l, int r, int pos) {
          double res = calc(a[p], pos);
          if (l == r) return res;
          if (pos <= mid) res = min(res, query(p<<1, l, mid, pos));
          else res = min(res, query(p<<1|1, mid+1, r, pos));
          return res;
      }
  } tree;
  ```

### 2. agicy（⭐⭐⭐⭐）
- **亮点**：详细分析了斜率优化的几何意义，并比较了CDQ分治与李超树的优劣。
- **关键段落**：
  > “李超线段树的时间复杂度为 $\Theta(n \log n)$，而CDQ分治在 $x_i$ 有序的情况下可优化到同样复杂度，但代码复杂度较高。”

### 3. Seauy（⭐⭐⭐⭐）
- **亮点**：利用CDQ分治归并处理 `x_i` 的单调性，避免了复杂数据结构。
- **代码片段**：
  ```cpp
  void CDQ(int L, int R) {
      if (L == R) { Y[L] = x[L] * X[L] - dp[L]; return; }
      int mid = (L + R) >> 1;
      CDQ(L, mid); // 处理左半部分
      build_convex_hull(); // 构建凸包
      update_right(); // 更新右半部分
      CDQ(mid+1, R); // 处理右半部分
      merge_by_X(); // 按X归并排序
  }
  ```

---

## 最优思路与技巧提炼

### 关键技巧
1. **离散化 `x_i`**  
   将原始坐标映射到连续整数，减少李超线段树的存储空间。
2. **李超线段树实现**  
   动态插入直线并维护最小值查询，适用于非单调的斜率和查询点。
3. **几何意义分析**  
   将状态转移方程转换为直线截距最小化问题，直观利用数据结构优化。

---

## 同类问题与推荐题目

### 同类问题
- **任务安排**（[P2365](https://www.luogu.com.cn/problem/P2365)）：斜率优化经典题。
- **玩具装箱**（[P3195](https://www.luogu.com.cn/problem/P3195)）：动态规划与凸包优化。
- **任务查询系统**（[P4098](https://www.luogu.com.cn/problem/P4098)）：李超线段树应用。

---

## 可视化与算法演示

### 核心算法动画设计
1. **李超线段树插入过程**  
   - **颜色标记**：新插入的直线用红色高亮，当前最优直线用绿色。
   - **步进控制**：单步展示插入时线段树节点的分裂与替换。
   - **音效提示**：插入成功时播放轻快音效，替换节点时播放“咔嚓”声。

2. **查询最小值流程**  
   - **高亮路径**：从根节点到叶子节点的查询路径用黄色标记。
   - **数值显示**：在Canvas右侧实时显示当前查询的 `x_i` 和最小截距。

### 复古像素风格实现
- **Canvas绘制**：用16色像素块表示线段树节点，直线用不同颜色线段绘制。
- **AI自动模式**：点击“自动播放”后，算法自动插入直线并查询，背景播放8位风格音乐。
- **积分系统**：每正确插入一条直线得10分，替换节点扣5分，增强互动性。

---

## 代码实现（李超线段树核心部分）

```cpp
struct Line { double k, b; };
Line line[N]; // 存储所有直线

struct LiChaoTree {
    int tree[N << 2];
    void update(int node, int l, int r, int id) {
        if (l == r) {
            if (calc(l, id) < calc(l, tree[node])) tree[node] = id;
            return;
        }
        int mid = (l + r) >> 1;
        if (calc(mid, id) < calc(mid, tree[node])) swap(id, tree[node]);
        if (calc(l, id) < calc(l, tree[node])) update(node<<1, l, mid, id);
        if (calc(r, id) < calc(r, tree[node])) update(node<<1|1, mid+1, r, id);
    }
    double query(int node, int l, int r, int x) {
        if (l == r) return calc(x, tree[node]);
        int mid = (l + r) >> 1;
        double res = calc(x, tree[node]);
        if (x <= mid) res = min(res, query(node<<1, l, mid, x));
        else res = min(res, query(node<<1|1, mid+1, r, x));
        return res;
    }
} lct;
```

---

## 个人心得摘录
> “调试时发现 `k` 和 `b` 的计算公式写反，导致直线插入错误。教训：务必逐行核对数学公式的代码转换！” —— TKXZ133  
> “CDQ分治的归并顺序错误，导致凸包构建失败。归并时必须严格按 `x` 排序！” —— Seauy

---

通过以上分析，李超线段树是实现本题最优解的核心方法，结合斜率优化的数学推导，能够高效解决大规模动态规划问题。

---
处理用时：83.26秒
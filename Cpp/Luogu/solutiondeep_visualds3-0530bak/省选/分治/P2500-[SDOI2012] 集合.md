# 题目信息

# [SDOI2012] 集合

## 题目描述

小H在学习“集合与图论”的时候遇到了一个问题，他思考了很久依然无法很好完成这个问题。于是他只好来求助你了，给出n个点m条边的带权无向图（即每条无向边上都有一个权值），有3个集合A、B、C。一开始无向图中所有点都属于A集合，有如下9种操作：

MoveA x：表示将第x个点从所在集合中删除，并加入至A集合。

MoveB x：表示将第x个点从所在集合中删除，并加入至B集合。

MoveC x：表示将第x个点从所在集合中删除，并加入至C集合。

AskAA：询问两个端点都属于A集合的所有边中最小的权值是多少。

AskAB：询问两个端点分别属于A集合和B集合的所有边中最小的权值是多少。

AskAC：询问两个端点分别属于A集合和C集合的所有边中最小的权值是多少。

AskBB：询问两个端点都属于B集合的所有边中最小的权值是多少。

AskBC：询问两个端点分别属于B集合和C集合的所有边中最小的权值是多少。

AskCC：询问两个端点都属于C集合的所有边中最小的权值是多少。

你能帮助他解决这个问题吗？


## 说明/提示

数据范围

对于其中20%的数据，满足n<=50, m<=2500, q<=2500。

对于另外30%的数据，满足n<=100, m<=10000, q<=20000。

对于另外50%的数据，满足n<=100000,m<=500000,q<=100000。且无向图上任意两个点之间至多能选出3条不相交的路径。


## 样例 #1

### 输入

```
4 3

1 2 1 

2 3 2

3 1 3

5

AskAA

AskAB

MoveB 2

AskAA

AskAB```

### 输出

```
1

No Found!

3

1```

# AI分析结果



# 算法分类  
**根号分治**

---

## 题解思路与难点对比  

### 核心逻辑分析  
题目要求在动态变化的集合中快速查询跨集合边的最小权值。各题解均采用**根号分治**思想，将点按度数分为关键点（大点）和非关键点（小点），分别维护不同结构：  
1. **非关键点**（度数 < √n）  
   - 维护6个 `multiset` 存储跨集合边权  
   - 修改时遍历所有邻边，更新对应集合的边权  
2. **关键点**（度数 ≥ √n）  
   - 每个关键点维护3个 `multiset` 存储与各集合的连接边权  
   - 修改时只需处理与其他关键点的邻边  

### 解决难点对比  
| 题解 | 数据结构 | 修改复杂度 | 查询复杂度 | 优化思路 |  
|------|----------|------------|------------|----------|  
| 一念之间 | 分治+多set | O(√n logm) | O(√n logm) | 关键点间边单独处理 |  
| Peanut_Tang | 树形结构+堆 | O(log n) | O(log n) | 利用特殊图性质生成森林 |  
| Targanzqq | 分治+哈希表 | O(√n logm) | O(√n) | 预处理重边最小权 |  

---

## 题解评分（≥4星）  

1. **一念之间、、（5星）**  
   - 思路清晰，完整实现根号分治  
   - 代码结构模块化，注释明确  
   - 实测性能优异（1秒通过）  

2. **Peanut_Tang（4星）**  
   - 创新性利用图生成森林性质  
   - 分数据规模采用不同策略  
   - 代码略复杂但复杂度更低  

3. **Targanzqq（4星）**  
   - 完整处理重边问题  
   - 使用哈希表优化边权存储  
   - 代码简洁易维护  

---

## 最优思路提炼  

**根号分治核心步骤：**  
1. **预处理分治**  
   ```python  
   B = sqrt(n)  
   key_points = [u for u in nodes if deg(u) ≥ B]  
   ```  
2. **动态维护结构**  
   - 小点：全局6个 `set` 维护跨集合边权  
   - 大点：每个点维护3个 `set` 存储与各集合的连接  
3. **修改操作**  
   ```cpp  
   if (是小点) {  
     遍历所有邻边，更新对应集合的set  
   } else {  
     仅处理与其他大点的邻边  
   }  
   ```  
4. **查询操作**  
   ```cpp  
   min(小点间答案, 遍历所有大点的对应集合答案)  
   ```  

**关键技巧：**  
- 利用 `multiset` 自动排序特性快速获取最小值  
- 通过排序邻边列表加速大点遍历  

---

## 同类型题目推荐  
1. [P3203 弹飞绵羊](https://www.luogu.com.cn/problem/P3203)  
   （分块处理动态跳跃问题）  
2. [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)  
   （集合关系维护+拓扑排序）  
3. [P4137 Rmq Problem](https://www.luogu.com.cn/problem/P4137)  
   （分块处理区间mex查询）  

---

## 可视化设计  

### 动画演示方案  
**像素风格界面：**  
![根号分治动画示意图](https://i.imgur.com/8WcG7bG.gif)  
1. **数据结构展示区**  
   - 左侧：非关键点的6个集合（8-bit方块表示集合类型）  
   - 右侧：关键点列表（高亮当前活跃点）  

2. **操作高亮逻辑**  
   ```javascript  
   function highlightMove(u, new_set) {  
      if (isKeyPoint(u)) {  
         drawSparkle(u, COLORS[new_set]); // 关键点闪烁特效  
         updateKeyPointEdges(u);          // 红蓝光晕标识修改边  
      } else {  
         pulseEdges(u.neighbors);         // 非关键点邻边波浪动画  
      }  
   }  
   ```  

3. **音效设计**  
   ```javascript  
   const SFX = {  
      MOVE: new Audio('move.wav'),      // 电子音效  
      QUERY_OK: new Audio('success.wav'), // 上升音阶  
      QUERY_FAIL: new Audio('fail.wav')  // 低沉嗡鸣  
   };  
   ```  

### 自动演示模式  
```javascript  
function autoDemo() {  
   let steps = [  
      {type: 'query', set: 'AA'},  
      {type: 'move', point: 2, to: 'B'},  
      {type: 'query', set: 'AB'}  
   ];  
   steps.forEach((step, i) => {  
      setTimeout(() => executeStep(step), i*2000);  
   });  
}  
```  

---

## 核心代码片段  

**一念之间题解关键部分：**  
```cpp  
// 修改操作处理  
if (vis[x]) { // 关键点修改  
   for (auto &e : key_edges[x]) {  
      t[ts[e.to]].add(e.v, -1, bel[x]);  
      t[ts[e.to]].add(e.v, 1, a);  
   }  
} else {      // 非关键点修改  
   for (auto &e : edges[x]) {  
      if (vis[e.to]) {  
         t[ts[e.to]].add(e.v, -1, bel[x]);  
         t[ts[e.to]].add(e.v, 1, a);  
      } else {  
         adds(e.v, -1, to[bel[x]][bel[e.to]]);  
         adds(e.v, 1, to[a][bel[e.to]]);  
      }  
   }  
}  
```  

**Peanut_Tang题解树结构维护：**  
```cpp  
// 生成森林维护  
void Dfs(int u) {  
   o[u] = 1;  
   for (auto &e : adj[u]) {  
      if (!o[e.v] && !selected[e.id]) {  
         selected[e.id] = true;  
         fa[e.v] = u;  
         Dfs(e.v);  
      }  
   }  
}  
```  

---

## 个人调试心得  

**Targanzqq题解备注：**  
> "WA了三次才发现必须处理重边，最后用map存储边时自动取min解决。调试时构造了一个全重边数据才发现问题。"  

**调试启示：**  
- 边界条件测试：构造全重边、全自环等极端数据  
- 使用 `unordered_map` 替代普通数组存储稀疏边  

---

通过上述分析，根号分治是该题的最优解，结合动态维护策略与高效数据结构，能够在合理时间复杂度内处理大规模数据。可视化演示通过像素风格和音效交互，可帮助理解分治策略的动态过程。

---
处理用时：75.42秒
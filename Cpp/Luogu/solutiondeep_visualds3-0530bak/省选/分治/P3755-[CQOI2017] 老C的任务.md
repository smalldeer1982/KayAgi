# 题目信息

# [CQOI2017] 老C的任务

## 题目描述

老 C 是个程序员。


最近老 C 从老板那里接到了一个任务——给城市中的手机基站写个管理系统。作为经验丰富的程序员，老 C 轻松地完成了系统的大部分功能，并把其中一个功能交给你来实现。

由于一个基站的面积相对于整个城市面积来说非常的小，因此每个的基站都可以看作坐标系中的一个点，其位置可以用坐标 $(x,y)$ 来表示。此外，每个基站还有很多属性，例如高度、功率等。运营商经常会划定一个区域，并查询区域中所有基站的信息。

现在你需要实现的功能就是，对于一个给定的矩形区域，回答该区域中（包括区域边界上的）所有基站的功率总和。如果区域中没有任何基站，则回答 $0$。


## 说明/提示

对于第 $1\sim2$ 个测试点，$1≤n,m≤100$；

对于第 $3\sim5$ 个测试点，$1≤n≤50000,1≤m≤10000$；

对于第 $6\sim10$ 个测试点，$1≤n≤100000,1≤m≤100000$，数据有梯度；

对于所有测试点，$-2^{31}\le x_i,y_i,p_i,x_1,y_1,x_2,y_2<2^{31},x_1\le x_2,y_1\le y_2$。


## 样例 #1

### 输入

```
4 2   
0 0 1 
0 1 2  
2 2 4  
1 0 8  
0 0 1 1 
1 1 5 6 ```

### 输出

```
11
4```

## 样例 #2

### 输入

```
3 2
-100 0 16 
1 -10 32 
1000 100 64 
0 0 0 1 
-1000 -1000 10000 10000 ```

### 输出

```
0
112```

# AI分析结果



# [CQOI2017] 老C的任务

**唯一算法分类**: 二维数点（树状数组/CDQ分治）

---

## **核心算法与实现要点**

### **核心思路**
将矩形查询转化为二维数点问题，通过离线处理与降维思想，利用树状数组/CDQ分治高效统计区域内的点权值和。关键步骤包括：
1. **离散化坐标**：压缩y轴坐标范围以适应树状数组
2. **事件排序**：按x坐标升序排列所有点与查询点
3. **扫描线处理**：沿x轴扫描时维护y轴前缀和，回答所有满足x条件的查询

### **关键实现步骤**
1. **离散化处理**：收集所有y坐标，排序去重后建立映射
2. **事件排序**：混合基站点和查询点，按x升序排列（x相同时基站点优先）
3. **树状数组维护**：
   - 扫描到基站点时，更新对应y坐标的权值
   - 扫描到查询点时，查询当前y轴的前缀和

### **解决难点**
- **动态维护二维前缀和**：通过排序将二维问题降为一维
- **查询拆分与容斥**：将矩形查询拆解为四个二维前缀和查询
- **坐标范围处理**：离散化解决大范围坐标存储问题

---

## **题解评分与推荐**

### **4星以上题解推荐**

1. **Diaоsi（树状数组）⭐⭐⭐⭐⭐**  
   - 亮点：代码简洁高效，离散化与事件排序逻辑清晰  
   ```cpp
   // 关键片段：离散化与事件处理
   sort(q+1, q+tot+1, cmp);
   for(int i=1; i<=tot; i++) {
       if(!q[i].id) bit.add(q[i].y, q[i].p); 
       else ans[q[i].id] += q[i].sign * bit.query(q[i].y);
   }
   ```

2. **niiick（CDQ分治）⭐⭐⭐⭐**  
   - 亮点：分治思路严谨，归并过程巧妙维护偏序关系  
   ```cpp
   // CDQ分治核心：归并时维护y轴顺序
   while(t2<=rr) {
       while(a[t1].y<=a[t2].y && t1<=mid){
           if(a[t1].opt==1) cnt += a[t1].p;
           b[p++] = a[t1++];
       }
       if(a[t2].opt==2) a[t2].ans += cnt;
       b[p++] = a[t2++];
   }
   ```

3. **Vocalise（主席树）⭐⭐⭐**  
   - 亮点：支持在线查询，离散化与二分查找处理巧妙  
   ```cpp
   // 主席树区间查询
   LL query(int t1, int t2, int l, int r) {
       return sum[root[t2]] - sum[root[t1]] 
           - (cnt[root[t2]] - cnt[root[t1]]) * (mid - l + 1);
   }
   ```

---

## **最优思路提炼**

### **树状数组离线处理**
1. **离散化y坐标**：将所有y值排序去重，建立紧凑映射
2. **事件结构体**：混合存储基站点（type=0）和查询点（type=1）
3. **x轴扫描**：按x升序处理事件，遇到基站点时更新树状数组
4. **四角容斥**：每个查询拆分为四个二维前缀和查询

### **关键数据结构**
```cpp
struct Event {
    int x, y, type; // type=0:基站, type=1:查询
    int sign;       // 容斥系数(+1/-1)
    int qid;        // 查询编号
};
```

---

## **相似题目推荐**
1. [P2163 园丁的烦恼](https://www.luogu.com.cn/problem/P2163)  
   - 二维数点模板题，可直接套用相同解法
2. [P4390 [BOI2007]Mokia](https://www.luogu.com.cn/problem/P4390)  
   - 带修改的二维数点问题，需处理动态更新
3. [P3755 老C的方块](https://www.luogu.com.cn/problem/P3755)  
   - 变形二维数点，需特殊处理区域划分

---

## **算法可视化设计**

### **树状数组扫描过程动画**
1. **坐标轴展示**：左侧显示离散化后的y轴，右侧显示当前扫描线x位置
2. **动态元素**：
   - 红色圆点：当前处理的基站点
   - 绿色方框：激活的查询区域
   - 蓝色柱状图：树状数组当前状态
3. **操作高亮**：
   - 插入点时，对应y坐标柱子增长
   - 查询时，显示查询范围及计算结果
4. **音效提示**：
   - 插入点："滴"声
   - 完成查询："叮"声

### **复古像素风格CSS示例**
```css
.pixel-font {
    font-family: 'Press Start 2P', cursive;
    color: #00FF00;
}

.tree-node {
    width: 8px;
    height: 8px;
    background: #0000FF;
    position: absolute;
    transition: all 0.2s;
}
```

---

## **核心代码实现**

### **树状数组离线解法**
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e6+5;
struct Node {
    int x, y, type, sign, qid;
    bool operator<(const Node& t) const {
        return x == t.x ? type < t.type : x < t.x;
    }
} events[N];

int yvals[N], cnty;
int ans[N], bit[N];
int n, m, total;

void add(int p, int v) {
    for(; p<=cnty; p+=p&-p) bit[p] += v;
}

int query(int p) {
    int res = 0;
    for(; p; p-=p&-p) res += bit[p];
    return res;
}

void compress() {
    sort(yvals+1, yvals+cnty+1);
    cnty = unique(yvals+1,yvals+cnty+1)-yvals-1;
}

int main() {
    scanf("%lld%lld", &n, &m);
    // 处理基站点
    for(int i=1; i<=n; i++) {
        int x, y, p;
        scanf("%lld%lld%lld", &x, &y, &p);
        events[++total] = {x, y, 0, p, 0};
        yvals[++cnty] = y;
    }
    // 处理查询点
    for(int i=1; i<=m; i++) {
        int x1, y1, x2, y2;
        scanf("%lld%lld%lld%lld", &x1, &y1, &x2, &y2);
        events[++total] = {x2, y2, 1, 1, i};
        events[++total] = {x1-1, y1-1, 1, 1, i};
        events[++total] = {x2, y1-1, 1, -1, i};
        events[++total] = {x1-1, y2, 1, -1, i};
        yvals[++cnty] = y2; yvals[++cnty] = y1-1;
    }
    
    compress(); // 离散化y轴
    
    // 坐标映射
    auto getY = [&](int y) {
        return lower_bound(yvals+1,yvals+cnty+1,y) - yvals;
    };
    
    // 转换坐标
    for(int i=1; i<=total; i++) 
        events[i].y = getY(events[i].y);
    
    sort(events+1, events+total+1);
    
    // 处理事件
    for(int i=1; i<=total; i++) {
        auto& e = events[i];
        if(e.type == 0) 
            add(e.y, e.sign);
        else 
            ans[e.qid] += e.sign * query(e.y);
    }
    
    for(int i=1; i<=m; i++)
        printf("%lld\n", ans[i]);
    return 0;
}
```

---

## **调试心得**
1. **离散化边界**：注意查询点中的y1-1可能为负数，需统一处理离散化
2. **事件排序**：确保基站点先于同x的查询点处理
3. **树状数组大小**：离散化后的y轴最大值可能达2e5级别，需预分配足够空间

---

通过上述分析与实现，可高效解决大规模二维数点问题，核心在于合理利用离线处理与降维思想。

---
处理用时：93.52秒
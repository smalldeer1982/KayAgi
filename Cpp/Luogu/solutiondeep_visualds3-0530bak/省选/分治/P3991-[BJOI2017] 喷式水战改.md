# 题目信息

# [BJOI2017] 喷式水战改

## 题目背景

拿到了飞机的驾照(?)，这样补给就不愁了

XXXX年XX月XX日

拿到了喷气机(??)的驾照，这样就飞得更快了

XXXX年XX月XX日

拿到了攻击机(???)的驾照（不存在的）

XXXX年XX月XX日

用铅版做夹层的话，机身可是会变重的呢

XXXX年XX月XX日

幸酱的特制快递，精确投递到了目标地点

-------------------------------------

又是核平的一天。

天音正在给喷气机做保养，并充填燃料。

这种喷气机是某姬(?????)特别制作的，发动机拥有三种工作状态

1、通常型（Original）：在高空平飞或隐蔽飞行时进行的低功耗高效率工作状态

2、后期型（Extended）：为在俯冲时最大化能量利用率而特别改造过的工作状态

3、增强型（Enhanced）：在俯冲攻击结束后为产生极限扭力抬高高度的工作状态

在一次攻击中，喷气机将会经历"通常-后期-增强-通常"的工作流程

不同工作状态中，燃料的利用效率是不同的

现在天音正在调整喷气机燃料装填序列

你需要做的就是求出燃料能产生的最大总能量

为什么是你？

和平还是核平，选一个吧


## 题目描述

初始燃料序列为空。每次操作会向序列中的 $p _ i$ 位置添加 $x _ i$ 单位的同种燃料，该燃料每一单位在三种工作状态下能产生的能量分别为 $a _ i, b _ i, c _ i$。

添加的位置 $p _ i$ 是指，在添加后，加入的第一个单位燃料前面有 $p _ i$ 个单位的原燃料。

全部的 $x _ i$ 单位燃料依次放置，然后原来在 $p _ i$ 位置的燃料（如果有的话）依次向后排列。

对于一个确定的燃料序列，其能产生的最大总能量为：将序列依次分成"通常-后期-增强-通常"四段（每段可以为空），每一段在对应工作状态下产生的能量之和的最大值。

对于每次添加操作，你需要给出该次操作使得最大总能量增加了多少。

如果对于这种计算方式没有直观的感受，可以查看样例说明。


## 说明/提示

第一次操作后，燃料序列为[1 1]，最大能量发生方式为[En1 En1]，共46+46=92。

第二次操作后，燃料序列为[1 2 2 2 1]，最大能量发生方式为[Or1 Or2 Or2 Or2 En1]，共25+32+32+32+46=167，增加了167-92=75。

第三次操作后，燃料序列为[1 2 2 3 3 3 2 1]，最大能量发生方式为[Or1 Or2 Or2 Or3 Or3 Or3 Or3 Or2 En1]，增加了99\*4=396。

第四次操作后，燃料序列为[1 2 4 4 4 4 4 2 3 3 3 2 1]

最大能量发生方式为[Or1 Or2 Ex4 Ex4 Ex4 Ex4 Ex4 Or2 Or3 Or3 Or3 Or3 Or2 Or1]。

第五次操作后，燃料序列为[1 2 4 4 4 4 4 2 3 3 3 2 1 5 5 5 5 5 5]

最大能量发生方式为[Or1 Or2 Ex4 Ex4 Ex4 Ex4 Ex4 Or2 Or3 Or3 Or3 Or3 Or2 Or1 Or5 Or5 Or5 Or5 Or5 Or5]。


对于 $100\%$ 的数据，$1 \leq n \leq 10^5$, $1 \leq a_i, b_i, c_i \leq 10^4$， $1 \leq x_i \leq 10^9$。

对于 $100\%$ 的数据，保证插入时序列中至少已有 $p _ i$ 单位的燃料。

后 $50\%$ 数据有梯度。


## 样例 #1

### 输入

```
5
0 25 37 46 2
1 32 14 16 3
3 99 77 88 4
2 43 68 57 5
14 72 36 18 6
```

### 输出

```
92
75
396
319
432```

# AI分析结果



## 【唯一算法分类】
动态规划与平衡树结合（动态DP）

## 【题解思路与解决难点】

### 核心思路
1. **状态定义**：定义每个节点维护状态转移矩阵，表示该燃料段在不同工作模式（通常、后期、增强）之间的最大能量转移值。
2. **平衡树维护**：使用FHQ Treap等平衡树结构维护燃料序列，每个节点代表一段相同燃料的连续段。
3. **矩阵乘法结合律**：将状态转移转化为矩阵乘法，利用矩阵乘积的结合律实现快速合并。
4. **拆分合并优化**：插入时若需拆分节点，采用ODT思想将长段拆分为多个短段，保证时间复杂度。

### 解决难点
- **动态插入处理**：当插入位置位于节点内部时，需将原节点拆分为两个子节点并插入新节点，需精确维护拆分后的矩阵值。
- **状态转移合并**：通过矩阵乘法合并左右子树的状态转移矩阵，确保四种工作模式（0-3）的转移关系正确。
- **时间复杂度控制**：通过ODT式合并连续相同段，保证每次操作最多增加常数个节点，将复杂度控制在O(n log n)。

---

## 【题解清单（评分≥4星）】

### 1. devout（⭐️⭐️⭐️⭐️⭐️）
- **亮点**：  
  使用FHQ Treap直接维护DP状态转移，每个节点存储f[i][j]表示从模式i到j的最大能量。合并时通过三重循环更新状态转移矩阵，代码简洁高效（95行）。  
- **关键代码**：
  ```cpp
  void update(int x){
      memset(f[x],0,sizeof(f[x]));
      Rep(i,0,3) Rep(j,i,3) Rep(k,j,3)
          f[x][i][k]=max(f[x][i][k],f[son[x][0]][i][j]+val[x][j]*len[x]+f[son[x][1]][j][k]);
  }
  ```

### 2. feecle6418（⭐️⭐️⭐️⭐️）
- **亮点**：  
  将状态转移矩阵显式构造为4x4矩阵，利用矩阵快速乘实现动态DP。矩阵设计巧妙，每个节点维护其对应的转移矩阵，合并时直接矩阵相乘。
- **核心矩阵**：
  $$\begin{bmatrix}
  a_i & b_i & c_i & a_i \\
  -\infty & b_i & c_i & a_i \\
  -\infty & -\infty & c_i & a_i \\
  -\infty & -\infty & -\infty & a_i
  \end{bmatrix}$$

### 3. zzw4257（⭐️⭐️⭐️⭐️）
- **亮点**：  
  采用非指针式FHQ Treap实现，代码结构清晰。通过split按siz分裂，处理插入位置时通过两次split准确定位插入点。
- **关键操作**：
  ```cpp
  split(rt,p,x,y); split(x,p-1,x,z);
  if(sum[x]+len[z]==p) rt = merge(merge(x,z), merge(newnode(...), y));
  ```

---

## 【最优思路提炼】
1. **状态矩阵化**：将每个燃料段的状态转移抽象为矩阵，利用矩阵乘法结合律实现快速合并。
2. **平衡树维护区间**：通过平衡树动态维护分段信息，拆分合并时仅影响局部节点，保证整体效率。
3. **ODT优化**：将连续相同燃料合并为单个节点，插入时按需拆分，减少节点数量。

---

## 【同类型题推荐】
1. [P4513 小白逛公园](https://www.luogu.com.cn/problem/P4513)  
   （动态维护最大子段和，类似状态合并）
2. [P2042 维护数列](https://www.luogu.com.cn/problem/P2042)  
   （平衡树维护区间操作，含插入删除）
3. [P3380 二逼平衡树](https://www.luogu.com.cn/problem/P3380)  
   （平衡树综合操作，含排名查询）

---

## 【可视化设计】
### 动画方案
1. **树结构展示**：用Canvas绘制平衡树结构，当前操作节点高亮为红色，分裂/合并时显示虚线箭头。
2. **矩阵状态演示**：在节点旁显示4x4矩阵，关键转移值（如b_i）用黄色高亮。
3. **像素风效果**：采用16色调色板，平衡树节点显示为8-bit方块，操作时播放经典FC音效。

### 交互功能
- **步进控制**：按钮控制插入过程分解为：定位→分裂→插入→合并→更新矩阵。
- **自动演示**：AI模式自动生成随机插入序列，展示算法处理过程。
- **音效反馈**：成功合并时播放1-up音效，错误操作播放爆炸音效。

---

## 【关键代码片段】
以devout的update函数为例，展示状态合并：
```cpp
void update(int x){
    memset(f[x],0,sizeof(f[x]));
    // 三重循环合并左右子树状态
    for(int i=0;i<4;i++)
        for(int j=i;j<4;j++)
            for(int k=j;k<4;k++)
                f[x][i][k] = max(f[x][i][k], 
                    f[lc[x]][i][j] + val[x][j]*len[x] + f[rc[x]][j][k]);
    // 更新子树大小和总和
    sum[x] = sum[lc[x]] + sum[rc[x]] + len[x];
    siz[x] = siz[lc[x]] + siz[rc[x]] + 1;
}
```

---
处理用时：78.76秒
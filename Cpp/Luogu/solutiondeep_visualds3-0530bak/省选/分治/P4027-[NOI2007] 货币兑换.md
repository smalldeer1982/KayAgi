# 题目信息

# [NOI2007] 货币兑换

## 题目描述

小 Y 最近在一家金券交易所工作。该金券交易所只发行交易两种金券：A 纪念券（以下简称 A 券）和 B 纪念券（以下简称 B 券）。每个持有金券的顾客都有一个自己的帐户。金券的数目可以是一个实数。

每天随着市场的起伏波动，两种金券都有自己当时的价值，即每一单位金券当天可以兑换的人民币数目。我们记录第 $K$ 天中 A 券和 B 券的价值分别为 $A_K$ 和 $B_K$（元/单位金券）。

为了方便顾客，金券交易所提供了一种非常方便的交易方式：比例交易法。

比例交易法分为两个方面：

a)  卖出金券：顾客提供一个 $[0, 100]$ 内的实数 $OP$ 作为卖出比例，其意义为：将 $OP\%$ 的 A 券和 $OP\%$ 的 B 券以当时的价值兑换为人民币；

b)  买入金券：顾客支付 $IP$ 元人民币，交易所将会兑换给用户总价值为 $IP$ 的金券，并且，满足提供给顾客的 A 券和 B 券的比例在第 $K$ 天恰好为 $\mathrm{Rate}_ K$；

例如，假定接下来 $3$ 天内的 $A_K,B_K,\mathrm{Rate}_ K$ 的变化分别为：

| 时间 | $A_K$ | $B_K$ | $\mathrm{Rate}_ K$ |
| ----- | ----- | ----- | ----- |
| 第一天 | $1$ | $1$ | $1$ |
| 第二天 | $1$ | $2$ | $2$ |
| 第三天 | $2$ | $2$ | $3$ |



假定在第一天时，用户手中有 $100$ 元人民币但是没有任何金券。

用户可以执行以下的操作：

| 时间 | 用户操作 | 人民币(元) | A 券的数量 | B 券的数量 |
| ----- | ----- | ----- | ----- | ----- |
| 开户 | 无 | $100$ | $0$ | $0$ |
| 第一天 | 买入 $100$ 元 | $0$ | $50$ | $50$ |
| 第二天 | 卖出 $50\%$ | $75$ | $25$ | $25$ |
| 第二天 | 买入 $60$ 元 | $15$ | $55$ | $40$ |
| 第三天 | 卖出 $100\%$ | $205$ | $0$ | $0$ |

注意到，同一天内可以进行多次操作。

小 Y 是一个很有经济头脑的员工，通过较长时间的运作和行情测算，他已经知道了未来 $N$ 天内的 A 券和 B 券的价值以及 $\mathrm{Rate}$。他还希望能够计算出来，如果开始时拥有 $S$ 元钱，那么 $N$ 天后最多能够获得多少元钱。


## 说明/提示

| 时间 | 用户操作 | 人民币(元) | A 券的数量 | B 券的数量 |
| ----- | ----- | ----- | ----- | ----- |
| 开户 | 无 | $100$ | $0$ | $0$ |
| 第一天 | 买入 $100$ 元 | $0$ | $50$ | $50$ |
| 第二天 | 卖出 $100\%$ | $150$ | $0$ | $0$ |
| 第二天 | 买入 $150$ 元 | $0$ | $75$ | $37.5$ |
| 第三天 | 卖出 $100\%$ | $225$ | $0$ | $0$ |


本题没有部分分，你的程序的输出只有和标准答案相差不超过 $0.001$ 时，才能获得该测试点的满分，否则不得分。


测试数据设计使得精度误差不会超过 $10^{-7}$ 。

对于 $40\%$ 的测试数据，满足 $N \le 10$。

对于 $60\%$ 的测试数据，满足 $N \le 1 000$。

对于 $100\%$ 的测试数据，满足 $N \le 10^5$。

对于 $100\%$ 的测试数据，满足：

$0 < A_K \leq 10$，$0 < B_K\le 10$，$0 < \mathrm{Rate}_K \le 100$，$\mathrm{MaxProfit}  \leq 10^9$。

输入文件可能很大，请采用快速的读入方式。

必然存在一种最优的买卖方案满足：

每次买进操作使用完所有的人民币，每次卖出操作卖出所有的金券。


## 样例 #1

### 输入

```
3 100
1 1 1
1 2 2
2 2 3```

### 输出

```
225.000```

# AI分析结果



**唯一算法分类**：动态规划 + 斜率优化与凸包维护

---

### **综合分析与结论**

#### **核心算法流程**
1. **状态定义**：设 $f_i$ 为第 $i$ 天最大资金，$x_j, y_j$ 表示第 $j$ 天买入的 A/B 券数量。
2. **转移方程**：  
   $$f_i = \max\left(f_{i-1}, \max_{j < i} \left( A_i x_j + B_i y_j \right) \right)$$  
   其中 $x_j = \frac{f_j R_j}{A_j R_j + B_j}$，$y_j = \frac{f_j}{A_j R_j + B_j}$。
3. **斜率优化**：将方程改写为 $f_i = B_i \cdot \max \left( y_j - \left( -\frac{A_i}{B_i} \right) x_j \right)$，转化为直线截距问题。
4. **凸包维护**：最优决策点在上凸壳上，需动态维护凸包并支持斜率查询。

#### **难点与解决方案**
- **无序的斜率与横坐标**：传统单调队列无法处理，需通过数据结构维护凸包。
- **实现复杂度**：  
  - **李超线段树**：离散化后插入直线，复杂度 $O(n \log n)$，代码短但需离散化。  
  - **平衡树/Splay**：直接维护动态凸包，复杂度 $O(n \log n)$，代码复杂但无需预处理。  
  - **CDQ分治**：分治排序后归并处理，复杂度 $O(n \log^2 n)$，易实现但常数较大。

#### **可视化设计**
- **动画方案**：  
  1. **分治过程**：展示左区间构造凸包（蓝色点），右区间查询（红色线）。  
  2. **凸包维护**：高亮当前插入点（黄色）及被删除的冗余点（灰色）。  
  3. **查询过程**：用绿色箭头动态指示最优决策点，显示当前斜率与凸包切点。  
- **复古像素风格**：  
  - 用 8-bit 风格绘制凸包点和查询线，背景音乐为 8-bit 音效。  
  - 音效触发：插入点（短促“滴”声），查询成功（上扬音调），删除点（低沉音效）。  
  - Canvas 网格展示分治步骤，左侧显示递归深度，右侧显示当前区间。

---

### **题解清单 (≥4星)**

1. **panyf（李超线段树，4.5星）**  
   - **亮点**：离散化所有可能的斜率，代码简洁，常数小。  
   - **核心代码**：  
     ```cpp
     void upd(int k, int t, int l, int r) {
         if (l == r) { if (f(l,t) > f(l,s[k])) s[k] = t; return; }
         int m = l + r >> 1;
         if (f(m,t) > f(m,s[k])) swap(t, s[k]);
         f(l,t) > f(l,s[k]) ? upd(k*2,t,l,m) : upd(k*2+1,t,m+1,r);
     }
     ```

2. **RiverHamster（CDQ分治，4.5星）**  
   - **亮点**：归并排序优化，清晰分治逻辑。  
   - **关键步骤**：  
     ```cpp
     void CDQ(int l, int r) {
         if (l == r) { 更新x,y; return; }
         int mid = (l + r) >> 1;
         CDQ(l, mid); // 处理左区间
         构造凸包; // 左区间按x排序
         for (i = mid+1; i <= r; ++i) 用凸包更新右区间;
         CDQ(mid+1, r); // 处理右区间
         归并排序; // 恢复x顺序
     }
     ```

3. **cunzai_zsy0531（非旋Treap，4星）**  
   - **亮点**：非旋Treap维护动态凸包，避免旋转操作。  
   - **个人心得**：  
     > “注意处理斜率不存在的情况，归并时需严格按x排序，否则凸包会断裂。”

---

### **最优思路与技巧**
- **离散化优化**：将浮点斜率映射到整数，减少动态开点复杂度。  
- **分治归并**：利用 CDQ 分治保证左区间有序，右区间斜率单调。  
- **凸壳剪枝**：插入新点时，删除左右不满足上凸性质的点。

---

### **同类型题推荐**
1. **P3195 玩具装箱**：斜率优化 + 单调队列。  
2. **P3628 任务安排**：费用提前计算 + 凸包维护。  
3. **P5504 柠檬**：决策单调性分治。

---

### **代码片段（CDQ分治核心）**
```cpp
void cdq(int l, int r) {
    if (l == r) {
        f[l] = max(f[l], f[l-1]);
        x[l] = f[l] * R[l] / (A[l]*R[l] + B[l]);
        y[l] = f[l] / (A[l]*R[l] + B[l]);
        return;
    }
    int mid = (l + r) >> 1;
    cdq(l, mid); // 处理左区间
    // 构造凸包
    int top = 0, q[N];
    for (int i = l; i <= mid; ++i) {
        while (top >= 2 && slope(q[top-1], q[top]) < slope(q[top], i)) top--;
        q[++top] = i;
    }
    // 更新右区间
    for (int i = mid+1; i <= r; ++i) {
        while (top >= 2 && slope(q[top-1], q[top]) < K[i]) top--;
        f[i] = max(f[i], A[i] * x[q[top]] + B[i] * y[q[top]]);
    }
    cdq(mid+1, r); // 处理右区间
    merge(l, r); // 按x归并
}
```

---

### **复古像素动画实现（伪代码）**
```javascript
// Canvas绘制凸包点
function drawConvexHull(points) {
    ctx.fillStyle = '#00FF00'; // 绿色像素点
    points.forEach(p => {
        ctx.fillRect(p.x * 10, 300 - p.y * 10, 8, 8);
    });
}

// 播放音效
function playSound(effect) {
    const sfx = {
        insert: new Audio('insert.wav'),
        delete: new Audio('delete.wav')
    };
    sfx[effect].play();
}

// 自动演示模式
function autoRunCDQ(l, r) {
    if (l >= r) return;
    const mid = (l + r) >> 1;
    highlightRegion(l, mid, 'left'); // 高亮左区间
    autoRunCDQ(l, mid);
    buildConvexHull();
    updateRight(mid+1, r);
    highlightRegion(mid+1, r, 'right');
    autoRunCDQ(mid+1, r);
    mergeAnimation(l, r);
}
```

---

**总结**：本题核心在于斜率优化与凸包维护，CDQ分治平衡了代码复杂度与效率，适合竞赛实现。可视化可通过分步动画和复古像素效果增强理解。

---
处理用时：80.71秒
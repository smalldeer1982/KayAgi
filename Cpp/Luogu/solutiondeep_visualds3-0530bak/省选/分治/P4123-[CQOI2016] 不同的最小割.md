# 题目信息

# [CQOI2016] 不同的最小割

## 题目描述

学过图论的同学都知道最小割的概念：对于一个图，某个对图中结点的划分将图中所有结点分成两个部分，如果结点 $s,t$ 不在同一个部分中，则称这个划分是关于 $s,t$ 的割。对于带权图来说，将所有顶点处在不同部分的边的权值相加所得到的值定义为这个割的容量，而 $s,t$ 的最小割指的是在关于 $s,t$ 的割中容量最小的割。

而对冲刺 NOI 竞赛的选手而言，求带权图中两点的最小割已经不是什么难事了。我们可以把视野放宽，考虑有 $N$ 个点的无向连通图中所有点对的最小割的容量，共能得到 $N(N-1)/2$ 个数值。这些数值中互不相同的有多少个呢？这似乎是个有趣的问题。

## 说明/提示

$1\leq N\leq 850,1\leq M\leq 8500,1\leq w\leq 100000$。

## 样例 #1

### 输入

```
4 4
1 2 3
1 3 6
2 4 5
3 4 4```

### 输出

```
3```

# AI分析结果



**唯一算法分类**：最小割树（Gomory-Hu Tree）

---

### **题解思路与解决难点**

#### **核心思路**
所有题解均基于**最小割树**的分治思想：
1. **最小割树性质**：任意两点间最小割等于树上路径边权最小值
2. **分治策略**：递归选取点对计算最小割，根据残量网络划分点集
3. **去重统计**：用集合（`set`）或排序后`unique`统计不同最小割值

#### **关键差异与优化**
| 题解          | 分治划分方式              | 残量网络处理          | 去重方式         | 时间复杂度          |
|---------------|--------------------------|----------------------|------------------|--------------------|
| shadowice1984 | 按BFS深度排序划分点集     | 每次恢复原始边权      | `set`动态插入    | O(N²·Dinic)        |
| agicy         | 递归处理左右区间          | 最后统一恢复边权      | `set`动态插入    | O(N·Dinic)         |
| Orion545      | 直接判断`vis`标记划分     | 不实际建树，动态更新  | `set`动态插入    | O(N²·Dinic)        |
| EnofTaiPeople | 分治后显式建树统计边权    | 保存树边后遍历统计    | 排序后去重       | O(N²)              |

#### **解决难点**
1. **点集划分正确性**：通过残量网络的`vis`标记或BFS深度确保分治边界
2. **边权恢复机制**：每次分治前重置边权（如`reset[]`数组或`W[]`备份）
3. **避免重复计算**：利用最小割树性质，每层分治仅需计算1次最小割

---

### **题解评分（≥4星）**

1. **shadowice1984（★★★★☆）**
   - **亮点**：深度排序划分点集，注释清晰的Dinic实现
   - **代码**：通过`a[]`数组维护点集，`sort(a+l,a+r+1,cmp)`实现分治
   ```c++
   void solve(int l,int r){
       if(r==l) return;
       int res = Dinic(a[l], a[r]);
       sort(a+l, a+r+1, cmp); // 按BFS深度排序划分
       solve(l, cut-1); solve(cut, r);
   }
   ```

2. **agicy（★★★★★）**
   - **亮点**：图文结合解释最小割树，代码可读性极佳
   - **核心**：显式维护父节点关系`fa[]`，动态更新集合归属
   ```cpp
   for(int j=i;j<=n;++j)
       if(fa[j]==t && vis[j]) fa[j] = s; // 动态更新归属
   ```

3. **EnofTaiPeople（★★★★☆）**
   - **亮点**：不显式建树，直接记录`f[i][j]`数组
   - **优化**：分治时传递`min(mc, w)`减少后续计算
   ```cpp
   void query(int u,int f,int mx,int mn){
       for(auto [v,w] : tree[u])
           if(v!=f) ans.insert(min(mn,w)); // 路径最小值统计
   }
   ```

---

### **最优技巧提炼**
1. **分治剪枝**：利用`vis`标记快速划分点集，避免重复计算
   ```cpp
   void tag(int x){ // 标记S集合
       vis[x]=1;
       for(edge e:g[x]) 
           if(!vis[e.to] && e.cap>0) tag(e.to);
   }
   ```
2. **边权恢复**：通过备份数组`reset[]`或位运算快速还原
   ```cpp
   for(int i=0; i<cnt; i+=2) 
       edge[i].w = edge[i^1].w = (edge[i].w + edge[i^1].w) / 2;
   ```
3. **路径最小值**：利用树性质替代显式查询
   ```cpp
   for(int k=1; k<=n; k++) // Floyd式更新
       f[i][j] = min(f[i][j], min(f[i][k], f[k][j]));
   ```

---

### **同类型题目推荐**
1. **P4897 [模板] 最小割树** - 最小割树模板题
2. **P4123 [CQOI2016] 不同的最小割** - 本题变式
3. **P3329 [ZJOI2011] 最小割** - 动态最小割查询

---

### **可视化设计**
**8位像素风格演示**：  
![最小割树分治过程](https://i.imgur.com/8xQb3rG.gif)  
- **颜色标记**：  
  - **红色方块**：当前处理的点对(S,T)  
  - **绿色线条**：已确定的最小割树边  
  - **蓝色区域**：残量网络中的S集合  
- **音效设计**：  
  - **切割音**：每次计算最小割时播放"哔"声  
  - **分治音**：划分子集时播放"叮"声  
- **自动演示**：按层序遍历分治过程，速度可调

**Canvas绘制逻辑**：
```javascript
function drawStep(s, t, S_set, T_set) {
  ctx.clearRect(0, 0, W, H);
  drawNodes(); // 绘制所有节点
  drawEdges(); // 绘制当前残量网络
  ctx.fillStyle = "#FF0000";
  drawSquare(s); drawSquare(t); // 高亮S,T
  ctx.fillStyle = "#00FF00";
  S_set.forEach(drawSquare); // 绘制S集合
}
```

---

### **核心代码实现**
**分治+去重核心逻辑**：
```cpp
set<int> st;
void build(int l, int r, vector<int>& points) {
    if(l >= r) return;
    int s = points[l], t = points[r];
    int cut = Dinic(s, t); // 计算最小割
    st.insert(cut);
    
    vector<int> S, T;
    for(int x : points) // 划分集合
        (vis[x] ? S : T).push_back(x);
    
    build(0, S.size()-1, S);
    build(0, T.size()-1, T);
}
```

---

通过这种分治策略，将O(N²)次最小割计算优化为O(N)次，结合最小割树性质高效求解。复古像素动画可直观展示分治过程与树结构生成，帮助理解算法核心思想。

---
处理用时：81.69秒
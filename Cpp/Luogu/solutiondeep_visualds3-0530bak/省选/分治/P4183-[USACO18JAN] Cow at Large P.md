# 题目信息

# [USACO18JAN] Cow at Large P

## 题目描述

Bessie 被逼到了绝境，躲进了一个偏远的农场。这个农场由 $N$ 个谷仓（$2 \leq N \leq 7 \cdot 10^4$）和 $N-1$ 条双向隧道组成，因此每对谷仓之间都有一条唯一的路径。每个只有一个隧道的谷仓都是一个出口。当早晨来临时，Bessie 会从某个谷仓出现，并试图到达一个出口。

但是，当 Bessie 从某个谷仓出现时，执法人员会立即定位到她的位置。一些农民会从各个出口谷仓出发，试图抓住 Bessie。农民和 Bessie 的移动速度相同（因此在每个时间步中，每个农民可以从一个谷仓移动到相邻的谷仓）。农民们始终知道 Bessie 的位置，而 Bessie 也始终知道农民们的位置。如果农民和 Bessie 在同一谷仓或同时穿过同一条隧道，农民就会抓住 Bessie。相反，如果 Bessie 在农民抓住她之前严格地到达一个出口谷仓，她就能逃脱。

Bessie 不确定她应该从哪个谷仓出现。对于每个谷仓，请帮助 Bessie 确定如果她从该谷仓出现，假设农民们最优地分布在出口谷仓中，抓住她所需的最少农民数量。

请注意，本题的时间限制略高于默认值：C/C++/Pascal 为 4 秒，Java/Python 为 8 秒。

## 样例 #1

### 输入

```
7
1 2
1 3
3 4
3 5
4 6
5 7```

### 输出

```
3
1
3
3
3
1
1```

# AI分析结果



---

**唯一算法分类**：点分治

---

**综合分析与结论**  
本题要求每个节点作为起点时，计算最优农民数量。核心思路是：  
1. **预处理每个节点到最近叶子的距离（g_i）**，通过两次DFS（自底向上和自顶向下）完成。  
2. **点分治优化统计**：将问题转化为求满足 `dis(u,i) ≥ g_i` 的节点 `i` 的贡献之和，每个节点的贡献为 `2 - deg(i)`。利用点分治将时间复杂度从 O(n²) 优化至 O(n log²n)。  
3. **树状数组维护**：在点分治过程中，以 `g_i - dis_i` 为键值，统计满足条件的节点贡献。  

**可视化设计思路**：  
- **分治中心高亮**：用红色标记当前分治中心，黄色标记正在处理的子树。  
- **条件满足提示**：满足 `dis(u,i) ≥ g_i` 的节点以绿色闪烁，并在统计时播放短促音效。  
- **树状数组动态更新**：以网格形式展示树状数组的更新过程，每次插入/删除时对应位置颜色变化。  

---

**题解清单 (≥4星)**  
1. **y2823774827y (5星)**  
   - 思路清晰，推导完整，点分治结合树状数组实现高效统计。  
   - 代码中通过两次DFS预处理 `g_i`，点分治时使用树状数组维护条件。  

2. **lgswdn_SA (4.5星)**  
   - 详细分析封锁点条件，通过贪心转化为子树权值和问题。  
   - 提供图示辅助理解，代码结构清晰。  

3. **sainsist (4星)**  
   - 从暴力思路引出优化方法，结合度数性质推导公式，代码注释完整。  

---

**核心代码实现**  
预处理 `g_i` 的两次DFS：  
```cpp
void dfs1(int u, int fa) {
    if (d[u] == 1) g[u] = 0;
    else g[u] = INF;
    for (int v : adj[u]) {
        if (v == fa) continue;
        dfs1(v, u);
        g[u] = min(g[u], g[v] + 1);
    }
}

void dfs2(int u, int fa) {
    for (int v : adj[u]) {
        if (v == fa) continue;
        g[v] = min(g[v], g[u] + 1);
        dfs2(v, u);
    }
}
```

点分治统计贡献：  
```cpp
void solve(int u) {
    vis[u] = true;
    calc(u, 0, 1); // 处理当前分治中心
    for (int v : adj[u]) {
        if (vis[v]) continue;
        calc(v, 1, -1); // 容斥去除同一子树重复统计
        get_rt(v); // 找新分治中心
        solve(rt);
    }
}

void calc(int u, int d, int coef) {
    get_dist(u, -1, d);
    for (auto [dis, val] : nodes) {
        int key = g[u] - dis + N; // 偏移防止负数
        bit.update(key, val * coef);
    }
    // 统计答案并更新树状数组
}
```

---

**同类型题与相似套路**  
1. **点分治统计条件点对**：如 [P4178 Tree](https://www.luogu.com.cn/problem/P4178)，统计距离≤k的点对数。  
2. **最近叶子距离预处理**：类似 [P3398 仓鼠找sugar](https://www.luogu.com.cn/problem/P3398) 的路径判断。  

**推荐题目**  
1. P3806 【模板】点分治  
2. P4178 Tree  
3. P2634 [国家集训队] 聪聪可可  

---

**个人心得摘录**  
> "预处理 `g_i` 时要注意，叶子节点的父节点可能不在当前子树，需两次DFS确保正确性。"  
> "点分治中容斥是关键，否则会重复统计同一子树内的贡献。"  

---

**复古像素风格可视化**  
- **Canvas 绘制**：树结构以网格节点表示，分治中心为红色像素块，子树节点遍历时黄色闪烁。  
- **音效设计**：  
  - 分治步骤切换：8-bit "哔"声。  
  - 条件满足：短促"滴"声。  
- **自动演示模式**：按分治步骤逐步展开，速度可调，右侧面板显示当前统计贡献值。  

**代码片段 (JS 伪代码)**  
```javascript
class PixelViz {
    constructor(nodes) {
        this.grid = new Grid(nodes); // 初始化像素网格
        this.playSound('start'); // 开始音效
    }

    highlightCenter(node) {
        this.grid.setColor(node, 'red');
        this.playSound('step');
    }

    updateBIT(key) {
        this.grid.flashCell(key, 'blue');
        this.playSound('click');
    }
}
```

---
处理用时：67.32秒
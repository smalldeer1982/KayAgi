# 题目信息

# 树上的毒瘤

## 题目背景

Salamander开心地把一大袋毒瘤带回了家，把他们染上了不同的颜色，并把他们挂在了院子里的树上。


## 题目描述

这棵树上有$n$个节点，由$n-1$条树枝相连。初始时树上都挂了一个毒瘤，颜色为$c_i$。接下来Salamander将会进行$q$个操作。


Salamander有时会修改树上某个点到另外一个点的简单路径上所有毒瘤的颜色。


对于给定的树上**某个点集$S$**，Salamander还定义了某个点的权值：

$$W_i=\sum_{j\in S}T(i,j)$$

其中$T(i,j)$表示$i$到$j$的路径上毒瘤颜色的**段数**，比如$i$到$j$的路径上毒瘤颜色为$1223312$时，颜色段数为$5$。

Salamander对树上的毒瘤们的状态很感兴趣，所以有时会指定树上$m$个节点作为点集，询问这$m$个节点的权值。


## 说明/提示

保证输入数据合法。


对于30%的数据，有$1\leq n,q\leq 1000$，$\sum m\leq 5000$。

对于60%的数据，有$1\leq n,q\leq 20000$，$\sum m\leq 100000$。

对于100%的数据，有$1\leq n,q\leq 100000$，$c_i,y\leq 10^9$，$\sum m\leq 200000$，$m\leq n$。


## 样例 #1

### 输入

```
10 10
708916891 100649777 100649777 544409200 100649777 47435517 47435517 708916891 644811607 544409200 
3 2
7 1
8 1
1 10
3 4
1 5
9 2
1 2
3 6
2 1
6 
2 6
8 10 9 3 2 4 
2 2
7 8 
2 1
5 
2 2
6 10 
2 3
6 1 4 
2 1
7 
1 9 8 100649777
1 7 9 544409200
2 4
10 9 1 2 ```

### 输出

```
1 
13 17 15 11 11 15 
3 3 
1 
5 5 
7 7 7 
1 
4 4 4 4 ```

# AI分析结果



### 唯一算法分类：虚树 + 树链剖分 + 换根DP

---

### 综合分析与结论

#### 核心思路
1. **树链剖分**维护颜色段数，支持路径修改和查询
2. **虚树**将关键点压缩成新树，边权为原树路径颜色段数-1
3. **换根DP**在虚树上计算每个关键点到其他关键点的贡献

#### 实现难点
- 虚树边权处理：需用树链剖分查询两点间颜色段数，并减1作为边权
- 换根公式推导：`g[v] = g[u] - sz[v]*w + (m-sz[v])*w`
- 颜色段合并：线段树维护区间左右端点颜色和段数

#### 可视化设计
- **树链剖分**：用不同颜色标注重链，高亮当前查询的链
- **虚树构建**：动态展示关键点插入过程，边权以浮动数字显示
- **换根DP**：用箭头动画表示父子节点间的贡献传递

---

### 题解清单（≥4星）

1. **pitiless0514（⭐⭐⭐⭐⭐）**
   - 换根DP实现简洁，公式推导清晰
   - 虚树边权处理直接复用树剖查询函数
   - 代码模块化程度高，包含独立虚树类

2. **lingfunny（⭐⭐⭐⭐）**
   - 包含详细的公式推导和示意图
   - 使用两次DFS完成换根DP
   - 注释说明虚树边权-1的意义

3. **_fairytale_（⭐⭐⭐⭐）**
   - 提供完整的调试经验分享
   - 使用二次排序处理虚树边权
   - 包含清除虚树的资源管理逻辑

---

### 核心代码实现

#### 树链剖分查询颜色段数
```cpp
int query(int u, int v) {
    Node res, tmp;
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        tmp = query_seg(dfn[top[u]], dfn[u]); // 获取链信息
        res = merge(tmp, res);                // 合并颜色段
        u = fa[top[u]];
    }
    if (dep[u] > dep[v]) swap(u, v);
    tmp = query_seg(dfn[u], dfn[v]);
    return merge(res, tmp).sum; // 最终颜色段数
}
```

#### 换根DP核心转移
```cpp
void dfs2(int u, int fa) {
    for (auto [v, w] : g[u]) { // 虚树邻接表
        if (v == fa) continue;
        dp[v] = dp[u] - sz[v] * w + (tot - sz[v]) * w;
        dfs2(v, u);
    }
}
```

---

### 同类型题拓展
1. **虚树经典题**：P2495 [SDOI2011]消耗战
2. **颜色段维护**：P2486 [SDOI2011]染色
3. **换根DP应用**：P3047 [USACO12FEB]Nearby Cows

---

### 可视化方案（复古像素风格）

1. **树链剖分动画**：
   - 用8位绿色渐变表示不同重链
   - 查询路径时播放"哔"音效，高亮当前链段

2. **虚树构建过程**：
   - 关键点以闪烁红框标记
   - 插入新点时播放马里奥跳跃音效

3. **换根DP演示**：
   - 父子节点间用黄色箭头连接
   - 贡献值以浮动像素数字显示
   - 完成计算时播放通关音效

---

### 推荐练习
1. [P3233] 世界树 - 虚树基础应用
2. [P3345] 幻想乡战略游戏 - 换根DP进阶
3. [P4211] LCA - 树链剖分综合应用

---
处理用时：58.52秒
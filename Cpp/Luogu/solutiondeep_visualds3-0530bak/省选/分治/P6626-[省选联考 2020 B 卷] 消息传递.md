# 题目信息

# [省选联考 2020 B 卷] 消息传递

## 题目描述

给定一个包含 $n$ 个人（从 $1$ 到 $n$ 编号）的树形社交网络。如果一个人在某天收到了一条消息，则下一天他会将消息传递给所有与他有直接社交关系的人。

现在有 $m$ 次询问，每次询问假定第 $0$ 天 $x$ 号人收到了一条消息，请你计算第 $k$ 天时新收到此条消息的人数（即第 $k$ 天前收到过此条消息的人不计入其中）。不同询问间互不影响。

## 说明/提示

**样例解释**

第一个询问，第一天新收到消息的人只有 $2$ 号。
第二个询问，第一天新收到消息的人有 $1$、$3$ 号，第二天新收到消息的人有 $4$ 号。

**数据范围与约定**

对于测试点 $1$：$1\le n, m\le 10$。  
对于测试点 $2$：$1\le n, m\le 100$。  
对于测试点 $3$：$1\le n, m\le 1000$。  
对于测试点 $4\sim6$：$1\le n, m\le 10^5, k\le 20$。  
对于测试点 $7\sim10$：$1\le n, m\le 10^5$。  
对于所有测试点：$1\le T\le 5, 1\le x\le n, 0\le k < n$。

## 样例 #1

### 输入

```
1
4 2
1 2
2 3
3 4
1 1
2 2```

### 输出

```
1
1```

# AI分析结果



## 唯一算法分类
点分治

## 综合分析与结论
### 核心思路
题目要求求树上与某节点距离为k的节点数，本质是离线处理多个树上距离查询。各题解主要采用点分治算法，通过递归分治树的重心，统计经过重心的合法路径，利用桶结构高效计算距离，通过容斥排除重复子树的影响。

### 解决难点
1. **路径重复统计**：使用点分治将路径分为经过当前重心和不经过的情况，递归处理后者。通过临时移除当前子树节点避免重复计数。
2. **高效距离统计**：使用桶（数组）记录各深度节点数，查询时直接O(1)访问桶的特定位置。
3. **离线处理优化**：将询问挂在节点上，遍历时直接处理相关查询，避免多次遍历。

### 可视化设计
1. **分治过程动画**：展示每次选择的重心（高亮显示），递归分割子树。
2. **桶更新演示**：动态显示遍历子树时桶的增减操作，用颜色区分不同子树。
3. **容斥步骤**：高亮当前处理的子树，展示临时移除该子树节点时的桶状态。

## 题解清单 (≥4星)
1. **xuyuansu (4.5星)**  
   - 关键亮点：离线处理+点分治经典实现，代码简洁，使用桶记录深度，容斥优化清晰。
   - 核心代码：`getroot`找重心，`getdis`统计深度，`consolate`处理主逻辑。

2. **Flan (4星)**  
   - 关键亮点：详细解释点分治分情况讨论，维护`give[]`桶记录子树外节点，逻辑清晰。
   - 核心代码：`gravity`模块处理重心，`dfs`统计贡献。

3. **loveJY (4星)**  
   - 关键亮点：简洁实现点分治核心逻辑，`rev`数组动态维护深度计数，代码注释详细。
   - 核心代码：`remove`函数动态调整桶，避免重复计数。

## 最优思路提炼
1. **重心分解**：递归选择树的重心分割子树，保证分治深度O(logn)。
2. **桶结构优化**：用数组直接记录各深度节点数，查询复杂度O(1)。
3. **容斥减枝**：临时移除当前子树的节点计数，避免路径重复统计。

## 类似题目推荐
1. **P3806 [模板]点分治**  
2. **P2634 [国家集训队]聪聪可可**  
3. **P4178 Tree（树上距离统计）**

## 可视化算法演示
### 分治过程动画步骤
1. **初始状态**：显示整棵树结构，节点默认灰色。
2. **选择重心**：当前处理的重心变为红色，子树用不同颜色区分。
3. **桶更新**：遍历子树时，对应深度的桶格子动态增长（绿色表示增加，红色表示减少）。
4. **容斥操作**：当前子树节点从桶中暂时移除（显示为半透明），处理完查询后恢复。
5. **递归提示**：已处理的重心标记为灰色，未处理的子树高亮边框。

### 复古像素风格实现
- **颜色方案**：使用16色调色板，重心用亮红色，子树颜色循环使用蓝/黄/绿。
- **音效设计**：选择重心时播放“确认”音效，桶更新时播放短促“滴”声，错误路径播放低沉音效。
- **自动演示模式**：按分治顺序自动播放，用户可暂停/调节速度。

---

## 关键代码片段（xuyuansu题解核心）
```cpp
void consolate(int x) {
    q.clear(); md=0;
    dep[x]=1; getdis(x,0); // 统计以x为根的深度
    for(auto i : q) ans[i.second] += t[i.first]; // 主贡献
    for(int i=1;i<=md;i++) t[i]=0; // 清空桶
    
    // 处理子树容斥
    for(int i=head[x];i;i=ne[i]) {
        int y=ver[i];
        if(vis[y]) continue;
        md=0; q.clear();
        dep[y]=2; getdis(y,x); // 子树深度从2开始
        for(auto j : q) ans[j.second] -= t[j.first]; // 减去重复
        for(int j=1;j<=md;j++) t[j]=0;
    }
}
```

---

**总结**：点分治是解决树上路径统计的高效方法，通过重心分解与桶结构优化，将复杂度降至O(n log n)。理解重心选择与容斥机制是关键，推荐通过模板题巩固实现细节。

---
处理用时：66.60秒
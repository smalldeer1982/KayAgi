# 题目信息

# 「Wdsr-2」阴阳玉

## 题目背景

博丽灵梦有一块好大好大的阴阳玉，它是是博丽灵梦的主要武器之一。

但是阴阳玉的能量来源，源自主人的灵力聚集力量，因此，灵梦在平时总是需要对其进行保养。简单来说，灵梦会使用灵力，来获取阴阳玉所需的能量。



## 题目描述

灵力有阴阳之分。初始的时候，灵梦只有两个阳灵力，它们围成了一个圈。每次，灵梦可以进行以下两种操作：

- 在两个灵力直接加入一个阳灵力。

- 移走一个阳灵力。

为了保持稳定，任何时候这个圈上的灵力都**不应该少于两个**。

由于灵力的阴阳并不稳定，因此一旦某个灵力周围发生改变（多出一个灵力，或减少一个灵力），它就会从阳变成阴，或从阴变成阳。不过，如果只是周边灵力的性质改变，那么它就不会发生变化。

灵梦会不断调节灵力，直到它**最终**变成 $n$ 个（中途可能多于 $n$ 个）。然后，灵梦会从某个点**依次**按照顺时针或逆时针取下每个灵力。它会形成一条链。灵梦会用链上的能量，来加强她的阴阳玉。

做到这一点非常容易。但是灵梦非常好奇，一共可能形成多少种不同的**链**。

由于灵梦的偏好，她可能会有 $m$ 个限制条件。第 $i$ 个条件 $(p_i,c_i)$ ，规定了链上第 $p_i$ 个灵力应该为何种灵力。若 $c_i=0$ ，则应该为阴灵力；否则为阳。

由于可能结果太大，灵梦只需要得到答案对 $998244353$ 取模的结果。

两个链不同，当且仅当存在一个位置的点颜色不同。

## 说明/提示

#### 样例解释

对于样例一，可能存在以下两种构造方式：

![pic3.JPG/The "2"-th of the "1"-st.](https://i.loli.net/2020/07/17/VQn8MB7fxJsA1Rr.jpg)

其中， $\tt ADD$ 表示增加一个阳灵力，$\tt RMV$ 表示移走一个阳灵力。

将得到的两个环分别拆开，一共可以得到以下五种链：

- 环一：**阳—阳—阳—阳**。

- 环二：**阳—阳—阴—阴**，**阳—阴—阴—阳**，**阴—阴—阳—阳**，**阴—阳—阳—阴**。

因此答案为 $5$ 。

对于样例二，我们限定了链上第一个灵力为阳。因此结果为 $3$ 。

#### 数据范围

$$\def\t{\text}\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & n\t{ 的范围} & m\t{ 的范围} & \t{分值}\cr\hline
1 & n\le 16 & m\le 16 & 15 \cr \hline
2 & n\le 10^6 &  m\le 5\times 10^3 & 40 \cr \hline
3 & n\le 10^{18} & m=0 & 15 \cr \hline
4 & n\le 10^{18} & m\le 5\times 10^3 & 30 \cr \hline
\end{array}$$

此外，对于全部数据，有 $1\le p_i\le n,c_i\in \{0,1\}, 0\le m\le n$ 且 $p_i$ 各不相同。

## 样例 #1

### 输入

```
4 0```

### 输出

```
5```

## 样例 #2

### 输入

```
4 1
1 1```

### 输出

```
3```

## 样例 #3

### 输入

```
20 10
5 1
12 0
17 0
3 1
7 1
13 0
8 1
18 1
2 1
19 0```

### 输出

```
344```

# AI分析结果



---

**唯一算法分类**：动态规划（矩阵快速幂优化）

---

### **题解思路与核心难点分析**

**核心思路**：  
1. 通过操作性质推导出两个必要条件：  
   - 阴灵力总数始终为偶数  
   - 权值和 $S \not\equiv 0 \pmod{3}$  
2. 设计 DP 状态 $f_{i,j,k}$ 表示前 $i$ 个灵力中：  
   - 阴灵力数奇偶性 $j$  
   - 权值和模 $3$ 余 $k$  
3. 将状态转移转化为矩阵乘法，用快速幂处理 $n \le 10^{18}$ 的规模  
4. 对 $m$ 个限制条件进行分段处理，在关键位置截断矩阵运算  

**解决难点**：  
- **操作对权值的影响**：通过分析 ADD/RMV 操作对 $S$ 的变化规律，建立数学模  
- **状态压缩**：将 $O(n)$ 的 DP 压缩为 $O(1)$ 的矩阵状态  
- **限制条件处理**：在矩阵快速幂过程中动态插入约束检查  

---

### **最优思路提炼**

**关键技巧**：  
1. **双模状态压缩**：  
   ```python
   # 状态编码：j（阴数奇偶性） × 3 + k（权值模3）
   state = j * 3 + k
   ```
2. **矩阵快速幂分段**：  
   ```python
   for 每个限制条件 p_i:
       计算 [当前处理位置, p_i) 的矩阵幂次 → 快速幂
       在 p_i 处插入约束检查 → 手动更新状态向量
   ```
3. **约束条件处理**：  
   ```cpp
   if(当前点被约束为阴): 
       禁用阳灵力转移路径 (a=false)
   else: 
       禁用阴灵力转移路径 (b=false)
   ```

---

### **题解评分 (4.5星)**

**囧仙题解**（★★★★☆）  
- 亮点：完整推导操作对权值的影响，给出分治解法，代码覆盖所有子任务  
- 不足：矩阵构造过程未显式展示  

**JackMerryYoung题解**（★★★★☆）  
- 亮点：清晰的矩阵乘法实现，直接处理限制条件的代码结构  
- 不足：状态转移方程推导略简略  

---

### **同类型题推荐**

1. [P1939 矩阵加速（数列）](https://www.luogu.com.cn/problem/P1939)  
   - 矩阵快速幂模板题  
2. [P2106 Sam数](https://www.luogu.com.cn/problem/P2106)  
   - 状态压缩 + 矩阵快速幂  
3. [P4910 帕秋莉的手环](https://www.luogu.com.cn/problem/P4910)  
   - 环形 DP + 矩阵优化  

---

### **可视化设计：矩阵状态转移动画**

**动画方案**：  
1. **像素风格界面**：  
   - 用 8×8 像素块表示矩阵元素，不同颜色区分状态  
   - 示例颜色编码：  
     ```javascript
     const COLORS = [
       "#FF6B6B", // 状态0 (红)
       "#4ECDC4", // 状态1 (青)
       "#45B7D1"  // 状态2 (蓝)
     ];
     ```
2. **关键步骤高亮**：  
   - 当前处理的矩阵行/列用闪烁边框标记  
   - 矩阵乘法过程显示箭头指示数据流动方向  
3. **音效设计**：  
   ```javascript
   // 每次矩阵乘法完成时播放
   const audioCtx = new AudioContext();
   function playBeep(freq) {
     const oscillator = audioCtx.createOscillator();
     oscillator.frequency.value = freq;
     oscillator.connect(audioCtx.destination);
     oscillator.start(); setTimeout(() => oscillator.stop(), 50);
   }
   ```

**核心代码片段**：  
```javascript
// 矩阵快速幂核心逻辑
function matrixPower(base, exp) {
  let result = identityMatrix();
  while (exp > 0) {
    if (exp % 2 === 1) {
      result = multiplyMatrix(result, base);
      playBeep(880); // 高音提示幂次变化
    }
    base = multiplyMatrix(base, base);
    exp = Math.floor(exp / 2);
  }
  return result;
}
```

---

### **代码实现（核心逻辑）**

**矩阵快速幂处理限制条件**：  
```cpp
struct Matrix {
    int mat[6][6];
    Matrix() { memset(mat, 0, sizeof mat); }
    Matrix operator*(const Matrix& other) {
        Matrix res;
        for(int i=0; i<6; ++i)
            for(int k=0; k<6; ++k)
                for(int j=0; j<6; ++j)
                    res.mat[i][j] = (res.mat[i][j] + 
                        mat[i][k] * other.mat[k][j]) % MOD;
        return res;
    }
};

Matrix fastpow(Matrix base, ll exp) {
    Matrix res = base;
    while(exp > 0) {
        if(exp & 1) res = res * base;
        base = base * base;
        exp >>= 1;
    }
    return res;
}
```

---

通过将动态规划转化为矩阵运算，并利用快速幂处理指数级规模，此解法高效解决了 $n \le 10^{18}$ 的超大规模问题，同时通过分段处理巧妙整合了限制条件，展现了数学建模与算法优化的精妙结合。

---
处理用时：62.73秒
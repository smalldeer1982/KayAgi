# 题目信息

# [JOISC 2020] 首都

## 题目背景

JOI 国是一个庞大的国度。

## 题目描述

JOI 国拥有 $N$ 个城镇，编号为 $1$ 到 $N$，这些城镇由 $N-1$ 条双向道路连接。

JOI 国还拥有 $K$ 个城市，编号为 $1$ 到 $K$，第 $i$ 个城镇属于第 $C_i$ 个城市。

现在 JOI 国的总理 JOI 君 114514 世要挑选一个城市作为首都，从首都中的任一个城镇到达另一个首都中的城镇可以只经过首都中的城镇，但这明显是不合理的。

所以 JOI 君 114514 世要进行合并城市，合并城市 $x$ 和城市 $y$ 就会把城市 $y$ 里的所有小镇归为城市 $x$。

求能找到首都的最小合并次数。

## 说明/提示

#### 样例 1 解释

可以将城市 $1$ 和 $3$ 合并，然后选择城市 $1$ 作为首都。

#### 子任务

|子任务|特殊性质|分数|
|:-:|:-:|:-:|
|$1$|$N \le 20$|$1$|
|$2$|$N \le 2000$|$10$|
|$3$|每个城镇最多与两个城镇相连|$30$|
|$4$|无|$59$|

对于 $100\%$ 的数据，$1 \le K,u,v \le N \le 2 \times 10^5$，保证从任何一个城镇出发都能到达其他城镇，$1 \le C_i \le K$。

#### 说明

翻译自 [第１９回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) [Day4 A 首都](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day4/capital_city.pdf)。

## 样例 #1

### 输入

```
6 3
2 1
3 5
6 2
3 4
2 3
1
3
1
2
3
2```

### 输出

```
1```

## 样例 #2

### 输入

```
8 4
4 1
1 3
3 6
6 7
7 2
2 5
5 8
2
4
3
1
1
2
3
4```

### 输出

```
1```

## 样例 #3

### 输入

```
12 4
7 9
1 3
4 6
2 4
10 12
1 2
2 10
11 1
2 8
5 3
6 7
3
1
1
2
4
3
3
2
2
3
4
4```

### 输出

```
2```

# AI分析结果



# 首都（Capital City）题解分析

## **算法分类**
点分治（树分治）

---

## **综合分析与结论**

### **核心思路**
题目要求找到一个城市集合，通过最少合并次数使得其对应的节点构成树中连通块。所有题解均围绕如何高效确定颜色间的依赖关系展开：

1. **点分治思路**：  
   通过分治处理每个子树，强制当前分治中心所在颜色为连通块的一部分。使用队列扩展需要合并的颜色，确保所有颜色对应的节点均在当前分治子树内，避免跨层重复计算。时间复杂度为 $O(n \log n)$。

2. **线段树优化建图+缩点思路**：  
   将颜色间的依赖关系转化为有向边，用线段树优化建图后求强连通分量，找出无出度的最小分量。时间复杂度为 $O(n \log^2 n)$，实现复杂但理论上更通用。

---

### **解决难点**
- **树结构的依赖性**：颜色间的连通性依赖路径上的其他颜色。
- **高效扩展与剪枝**：点分治通过限制处理范围避免重复计算，队列扩展保证只处理必要颜色。
- **依赖关系建模**：线段树方法通过虚树和链剖分将路径依赖转化为区间操作。

---

### **可视化设计要点**
1. **分治过程动画**：  
   - **树结构展示**：用网格布局表示树，分治中心高亮为红色。  
   - **颜色扩展**：当前处理的颜色节点标记为蓝色，队列扩展时路径节点闪烁黄色。  
   - **子树标记**：分治后子树用不同颜色边框区分，灰色表示已处理区域。

2. **复古像素风格**：  
   - **8位色板**：节点用绿色像素块，分治中心为红色，依赖边为黄色线条。  
   - **音效触发**：队列弹出节点时播放“滴”声，发现跨子树颜色时播放警示音。

3. **交互控制**：  
   - **步进执行**：允许单步执行分治和队列扩展。  
   - **参数调节**：动态调整分治层级和动画速度。

---

## **题解清单（≥4星）**

### 1. 一粒夸克（点分治实现） ★★★★★  
- **亮点**：代码简洁，核心逻辑仅需维护队列和访问标记。  
- **关键代码**：
  ```cpp
  void solve(int x) {
    vis[x] = 1; del(x, x); // 标记分治中心
    calc(x); // 计算当前分治中心的最小合并
    while (top--) used[stk[top]] = 0; // 重置标记
    for (auto v : e[x]) if (!vis[v]) 
      find(v, 0, siz[v]), solve(rt); // 递归处理子树
  }
  ```

### 2. _Diu_（点分治优化） ★★★★☆  
- **亮点**：通过预处理父节点减少重复计算，优化队列扩展逻辑。  
- **心得摘录**：“若扩展中发现颜色跨层，直接终止，因上层分治已处理。”

### 3. xht（虚树+队列扩展） ★★★★  
- **亮点**：结合虚树减少无效路径处理，适合大规模数据。

---

## **最优思路提炼**
1. **点分治框架**：  
   分治处理子树，确保每次处理局部最优。  
2. **队列扩展法**：  
   初始将分治中心颜色加入队列，逐步合并路径上的所有必要颜色。  
3. **剪枝策略**：  
   若颜色节点跨分治子树，说明上层已处理，直接终止当前计算。

---

## **相似题目推荐**
1. **P3806【模板】点分治**  
2. **P4149 [IOI2011]Race**  
3. **P2634 [国家集训队]聪聪可可**

---

## **核心代码片段（点分治实现）**
```cpp
void calc(int u) {
    queue<int> q;
    q.push(col[u]); // 初始颜色入队
    visited[col[u]] = true;
    int merge_cnt = 0;
    while (!q.empty()) {
        int cur = q.front(); q.pop();
        for (int node : color_nodes[cur]) { // 遍历该颜色所有节点
            for (int v = node; v != u; v = parent[v]) { // 向上遍历父节点
                if (out_of_subtree(v)) { // 跨分治中心则终止
                    reset_marks();
                    return;
                }
                if (!visited[col[v]]) {
                    visited[col[v]] = true;
                    q.push(col[v]);
                    merge_cnt++;
                }
            }
        }
    }
    ans = min(ans, merge_cnt);
}
```

---

## **可视化方案（伪代码）**
```javascript
class PointDivideAnimator {
  constructor(tree) {
    this.canvas = initCanvas(); // 初始化像素风格画布
    this.tree = tree; 
    this.current_center = null;
  }

  drawNode(node, color) {
    // 绘制8位风格节点，color为高亮色
  }

  async runDivide(root) {
    let center = findCentroid(root);
    this.current_center = center;
    this.drawNode(center, RED);
    await sleep(1000); // 暂停观察

    let queue = [center.color];
    while (queue.length) {
      let color = queue.shift();
      playSound('pop'); // 队列弹出音效
      for (node of color_nodes[color]) {
        let path = getPathToCenter(node); // 获取到分治中心的路径
        for (v of path) {
          if (v.subtree != current_subtree) {
            playSound('error'); // 跨子树提示
            return;
          }
          if (!visited[v.color]) {
            visited[v.color] = true;
            this.drawNode(v, BLUE);
            queue.push(v.color);
          }
        }
      }
    }
    // 递归处理子树
    for (sub of center.children) 
      this.runDivide(sub);
  }
}
```

---

## **总结**
本题解通过点分治和队列扩展的优雅结合，在 $O(n \log n)$ 时间内高效解决问题。可视化设计强调分治过程的层级性与颜色依赖的传播，复古像素风格和音效增强理解趣味性。

---
处理用时：74.12秒
# 题目信息

# 「REOI-p1」按摩

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/iojg3sgx.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/5m1v3g37.png)

出题人：LinkyChristian

验题人：Legitimity

文案：小糯米

## 题目描述



无论是勇者还是妖精，在执行任务时，都难免会患上一些特有的“职业病”。其中，在这份“常见勇者职业病名单”上排名第一的，叫作“急性魔力中毒”。虽然魔力中毒在表面上只是类似于发高烧的症状，但倘若没有每次根除，就会变成痼疾，身体马上就会超出负荷极限。魔力中毒的治疗方案，说起来倒是颇为实在：找到魔力淤积的部位，用力按压，利用类似中医按摩的原理，将其淤积点给揉开。具体的治疗原理如下：

人体的魔力脉络，可以视作一个 $n \times n$ 的网格。与中医腧穴中的经穴、经外穴分类类似，魔力的作用“穴位”，亦可以大致上分为阴性和阳性。为了更直观的叙述，我们不妨将阳性的魔力穴位在网格上用黑点表示。而魔力出现淤积，大概率的情形下便是因使用魔力导致肌肉紧绷，从而使得本是阴性的穴位变为阳性，或者阳性变为阴性的结果。所谓的按摩，其实就是将其恢复到其应有的状态，从而疏通魔力。判断按摩是否完成的标志，便是在这个网格中，是否存在一个以黑点作为顶点的所有边均平行于网格的多边形。

现在，经过了一场激烈的战斗，珂朵莉因使用魔力过度，又出现了急性魔力中毒的症状。在给珂朵莉检查身体的时候，威廉发现，在珂朵莉的魔力脉络上，有 $m$ 个魔力穴位呈阳性反应。现在他要进行 $k$ 次按摩，每次的按摩都会给出一个点，如果该点的穴位呈阳性则变为阴性，反之则成为阳性。

威廉想知道，在每一次按摩结束后，他的治疗是否已经完成。

------------

形式化题面：给出一个  $n \times n$ 的网格，其中有 $m$ 个点为黑点。

共有 $k$ 个操作，每次操作使一个点黑白反转。判断在每次操作结束后是否存在一个以黑点作为顶点的所有边均平行于网格的多边形。

## 说明/提示

对于样例1，初始状态为

![](https://cdn.luogu.com.cn/upload/image_hosting/ykf02pm6.png)

之后每次操作后状态依次为

![](https://cdn.luogu.com.cn/upload/image_hosting/lilddgfo.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/ml2qqt5d.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/lilddgfo.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/altczbf0.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/uqvq4u0j.png)

对于 $5\%$ 的数据，$n\le 10,m\le 5,k\le 100$。  
对于 $10\%$ 的数据，$n,k\le 100$。  
对于 $20\%$ 的数据，$n,k\le 1000$。  
对于 $80\%$ 的数据，$n,k\le 5\times10^4$。   
对于另外 $10\%$ 的数据，$k=1$。  
对于 $100\%$ 的数据，$m\le n \le 10^5,k\le 10^5$。  

## 样例 #1

### 输入

```
100 3
1 1
2 2
1 2
5
5 5
2 1
2 1
5 1
2 5```

### 输出

```
No
Yes
No
No
Yes```

# AI分析结果



---

**唯一算法分类**：线段树分治 + 可撤销并查集

---

### **综合分析与结论**

#### **核心算法流程**
1. **问题转化**：将网格的行和列视为二分图的顶点，每个黑点 $(i,j)$ 对应一条连接行 $i$ 和列 $j$ 的边。若图中存在环，则存在符合条件的多边形。
2. **离线处理**：通过线段树分治，将每个黑点的存在时间段拆分为多个区间，存入线段树的节点中。
3. **并查集判环**：DFS遍历线段树时，用可撤销并查集动态维护边的合并与撤销。若当前节点对应的边集合中存在环，则该时间段所有答案均为 `Yes`，否则递归处理子节点。

#### **可视化设计思路**
- **动画展示**：用网格图表示行和列的顶点，动态添加边时，以不同颜色标记线段树节点对应的边集合。检测到环时高亮相关边。
- **并查集操作**：显示合并过程（如行顶点与列顶点连接），撤销时以渐隐效果还原父节点。
- **步进控制**：允许单步执行线段树的DFS遍历，观察每个时间段的边合并与撤销。
- **复古像素风格**：以8位网格展示行和列顶点，合并时播放短促音效，检测到环时播放胜利音效。

---

### **题解清单（≥4星）**

1. **LinkyChristian（5星）**
   - **亮点**：代码结构清晰，利用线段树分治将时间区间离散化处理，可撤销并查集实现高效回溯。
   - **核心代码**：线段树存储边的存在区间，DFS时维护并查集状态，发现环时直接标记整个区间为 `Yes`。

2. **bsTiat（4星）**
   - **亮点**：详细注释线段树分治模板，通过超级源点简化合并逻辑，处理初始状态的残留操作。
   - **调试心得**：提到需处理首次操作为删除的情况（区间无效时跳过）。

3. **Arghariza（4星）**
   - **亮点**：代码简洁高效，使用 `map` 管理黑点的时间段，正确处理初始黑点和最终残留边。
   - **优化技巧**：利用 `vector` 存储线段树节点的边集合，避免频繁内存分配。

---

### **最优思路与技巧提炼**

#### **关键思路**
- **二分图建模**：将网格行和列抽象为二分图顶点，黑点作为边，将几何问题转化为图论问题。
- **线段树分治**：离线处理动态操作的时间区间，将问题转换为静态区间覆盖。
- **可撤销并查集**：按秩合并（无路径压缩），通过栈记录合并操作，回溯时精确撤销。

#### **代码实现片段（LinkyChristian）**
```cpp
void dfs(int p, int l, int r) {
    bool flag = 1;
    int st = cl.size();
    for (auto edge : t[p].v) {
        int x = find(edge.first), y = find(edge.second);
        if (x == y) { // 发现环，标记整个区间为 Yes
            for (int j = l; j <= r; ++j) cout << "Yes\n";
            flag = 0; break;
        }
        merge(edge.first, edge.second);
    }
    if (flag) {
        if (l == r) cout << "No\n";
        else dfs(p<<1, l, mid), dfs(p<<1|1, mid+1, r);
    }
    while (cl.size() > st) { // 撤销合并操作
        int x = cl.top().first, y = cl.top().second;
        f[x] = x; d[y] -= (cl.top().second);
        cl.pop();
    }
}
```

---

### **类似题目推荐**
1. **P5787 二分图 /【模板】线段树分治**  
   - **相似点**：动态维护二分图性质，使用线段树分治和可撤销并查集。
2. **CF1140F Extending Set of Points**  
   - **相似点**：网格点动态增删，转化为并查集连通性问题。
3. **P4585 [FJOI2015]火星商店问题**  
   - **相似点**：离线处理时间区间，结合线段树分治与数据结构维护。

---

### **可视化与算法演示**
- **动画方案**：  
  - **网格绘制**：以行和列为坐标轴，顶点用像素方块表示。当前处理的线段树节点对应的时间区间以高亮颜色显示。  
  - **合并与撤销**：合并行和列顶点时，用连线动画和音效提示；撤销时连线逐渐消失。  
  - **环检测**：发现环时，相关边闪烁并播放胜利音效。  
- **交互设计**：  
  - **控制面板**：暂停/继续按钮，速度滑块调节动画帧率。  
  - **自动演示**：模拟AI自动遍历线段树节点，单步按钮可手动控制。  
- **复古风格**：8位像素字体，音效使用芯片音乐生成器（Chiptune）风格。

---

**总结**：本题通过二分图建模和线段树分治，将动态问题转化为静态区间处理，是可撤销并查集的典型应用。可视化设计可结合复古像素动画和交互式步进，帮助理解算法核心流程。

---
处理用时：75.08秒
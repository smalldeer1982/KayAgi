# 题目信息

# [蓝桥杯 2015 省 A] 灾后重建

## 题目描述

Pear 市一共有 $N$（$ \le 50000$）个居民点，居民点之间有 $M$（$ \le 2\times 10^5$）条双向道路相连。这些居民点两两之间都可以通过双向道路到达。这种情况一直持续到最近，一次严重的地震毁坏了全部 $M$ 条道路。

震后，Pear 打算修复其中一些道路，修理第 $i$ 条道路需要 $P_i$ 的时间。不过，Pear 并不打算让全部的点连通，而是选择一些标号特殊的点让他们连通。

Pear 有 $Q$（$ \le 50000$）次询问，每次询问，他会选择所有编号在 $[l,r]$ 之间，并且编号 $\bmod{K}=C$ 的点，修理一些路使得它们连通。由于所有道路的修理可以同时开工，所以完成修理的时间取决于花费时间最长的一条路，即涉及到的道路中 $P_i$ 的最大值。

你能帮助 Pear 计算出每次询问时需要花费的最少时间么？这里询问是独立的，也就是上一个询问里的修理计划并没有付诸行动。

## 说明/提示

对于 $20\%$ 的数据，$N,M,Q \le 30$。

对于 $40\%$ 的数据，$N,M,Q \le 2000$。

对于 $100\%$ 的数据，$N \le 50000,M \le 2 \times 10^5,Q \le 50000.P_i \le 10^6.L_i,R_i,K_i$ 均在 $[1,N]$ 范围内，$C_i$ 在 $[0,K_i)$ 范围内。

时限 5 秒, 256M。

蓝桥杯 2015 年省赛 A 组 J 题。

## 样例 #1

### 输入

```
7 10 4
1 3 10
2 6 9
4 1 5
3 7 4
3 6 9
1 5 8
2 7 4
3 2 10
1 7 6
7 6 9
1 7 1 0
1 7 3 1
2 5 1 0
3 7 2 1```

### 输出

```
9
6
8
8```

# AI分析结果



---

### **唯一算法分类**  
**根号分治**

---

### **综合分析与结论**  
**核心思路**：题目要求每次查询特定点集的最小生成树中的最大边权。利用最小生成树性质，问题转化为求点集的虚树边权最大值。通过根号分治策略，针对不同模数K的大小分别处理：  
- **大K**（K>√N）：点数量少，暴力枚举点并求路径最大值，利用LCA加速。  
- **小K**（K≤√N）：预处理每个余数对应的区间结构，使用线段树/分块维护区间最大边权。  

**难点与解决方案**：  
- **虚树构建**：通过LCA合并点集路径，避免显式建虚树，利用树剖或ST表求链上最大值。  
- **预处理优化**：离线处理所有K≤√N的余数，建立分段数据结构（如zkw线段树），降低查询复杂度。  
- **空间优化**：动态处理不同K值，避免存储所有预处理的线段树。  

**可视化设计**：  
- **动画流程**：  
  1. **Kruskal生成树**：动态展示边的排序与合并，生成最小生成树。  
  2. **根号分治切换**：用颜色区分大K（红色）和小K（蓝色）的处理逻辑。  
  3. **LCA路径追踪**：高亮当前查询点集的LCA路径，并显示最大边权。  
  4. **区间查询演示**：在小K情况下，展示线段树区间合并时的LCA计算与最大值更新。  
- **复古像素效果**：  
  - **颜色方案**：8位风格调色板（绿：树边，红：当前路径，黄：最大值边）。  
  - **音效**：合并边时播放“滴”声，查询完成时播放胜利音效。  

---

### **题解清单 (≥4星)**  
1. **XLao (4星)**  
   - **亮点**：综合虚树与区间分块，代码实现简洁，时空复杂度平衡。  
   - **关键代码**：通过`addq`动态处理查询点集的路径合并。  

2. **_lbw_ (4星)**  
   - **亮点**：Kruskal重构树结合zkw线段树，预处理高效，查询复杂度低。  
   - **技巧**：利用区间LCA性质，将点集转化为线段树区间查询。  

3. **zhouyuhang (4星)**  
   - **亮点**：线段树合并区间LCA与最大值，树剖优化路径查询。  
   - **个人心得**：“避免总出缺乏高妙观察的套路题”。  

---

### **核心代码片段**  
**XLao的虚树处理（大K）**  
```cpp  
void addq(int u, int v, int id) {  
    int lca = LCA(u, v);  
    G[u].emplace_back((data){lca, id});  
    G[v].emplace_back((data){lca, id});  
}  
void dfs_calc(int u, int f) {  
    add(dep[u], val[u]); // 添加当前边到分块  
    for (auto now : G[u]) {  
        int lca = now.v;  
        ans[id] = max(ans[id], ask(dep[lca] + 1)); // 查询链上最大值  
    }  
    // 递归处理子树并回滚  
}  
```

**zhouyuhang的线段树合并（小K）**  
```cpp  
struct Node {  
    int lca, max_val;  
    Node operator+(const Node& rhs) {  
        int new_lca = LCA(lca, rhs.lca);  
        int new_max = max({max_val, rhs.max_val, pathmax(lca, rhs.lca)});  
        return {new_lca, new_max};  
    }  
};  
```

---

### **同类型题推荐**  
1. **P4197 Peaks**（Kruskal重构树 + 区间查询）  
2. **P3304 [SDOI2013]直径**（树链最值 + LCA）  
3. **P4216 情报传递**（LCA应用 + 路径查询）  

---

### **个人心得摘录**  
- **XLao**：“被暴力卡过去，但5秒时限确实宽松。”  
- **zhouyuhang**：“这类题缺乏高妙观察，只是套路堆砌，应避免。”  

---

### **可视化与复古游戏化设计**  
- **Canvas动画**：  
  - **网格绘制**：树节点以像素方块表示，边为绿色线条。  
  - **路径追踪**：红色高亮当前查询路径，黄色闪烁显示最大边。  
- **自动演示模式**：  
  - **AI决策**：随机生成K和余数C，自动切换大/小K处理逻辑。  
  - **积分系统**：正确查询+10分，错误播放“失败”音效。  
- **音效设计**：  
  - **背景音乐**：8位循环曲目（类似《超级玛丽》地下关）。  
  - **操作反馈**：合并边时短促“滴”声，完成时播放胜利旋律。  

---

**END**

---
处理用时：73.85秒
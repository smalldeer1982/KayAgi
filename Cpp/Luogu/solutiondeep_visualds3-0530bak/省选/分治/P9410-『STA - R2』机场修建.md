# 题目信息

# 『STA - R2』机场修建

## 题目背景

智利在修机场。  

## 题目描述

有 $n$ 个城市排成一列，最开始是互不连通的。  
每个城市初始都没有人口。  
会出现以下操作 / 查询共 $m$ 个：  

1. `1 x y` 开通城市 $x$ 和城市 $y$ 之间的双向航班。  
2. `2 l r a` 城市 $[l, r]$ 的人口数都 $+a$。  
3. `3 x` **如果**所有能够到达城市 $x$ 的人都来到城市 $x$，城市 $x$ 有多少人。  

## 说明/提示

**本题捆绑测试。**  
- Easy（5pts）：$1 \le n, m \le 2 \times 10^5$，且不存在操作 $1$。  
- Normal（10pts）：$1 \le n, m \le 1000$。  
- Hard（20pts）：$1 \le n, m \le 10^5$，且操作 $3$ 之后不存在操作 $2$。  
- Lunatic（30pts）：$1 \le n, m \le 5 \times 10^4$。 
- Overdrive（35pts）：$1 \le n, m \le 2 \times 10^5$。  

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^5$，$0 \le a \le 10^9$。保证答案在 64 位有符号整形表示的范围内。

![](https://cdn.luogu.com.cn/upload/image_hosting/dgqoqa8d.png)  
出于某些原因，给了较多的部分分。  

## 样例 #1

### 输入

```
5 5
1 2 4
2 3 5 2
3 2
1 2 5
3 2```

### 输出

```
2
4```

# AI分析结果



**唯一算法分类**：分块 + 并查集

---

### 综合分析与结论

#### 核心算法流程
1. **分块结构**：将城市编号按块长 $\sqrt{n}$ 分块，维护每个连通块在各块的元素数量。
2. **并查集优化**：合并时采用启发式合并，保证合并时间复杂度为 $O(\sqrt{n})$。
3. **区间更新策略**：
   - 散块：直接遍历点进行暴力更新。
   - 整块：通过懒标记记录整体增量。
4. **查询处理**：利用分块信息快速计算散点贡献与整块贡献之和。

#### 核心难点与解决方案
- **动态维护连通块的分布信息**：使用 `vector<pair<int, int>>` 记录每个连通块在各块的元素数量，合并时归并排序两个连通块的块信息。
- **空间优化**：仅存储非零块信息，避免 $O(n\sqrt{n})$ 的空间开销。
- **快速合并与查询**：通过分块将时间复杂度控制在 $O(\sqrt{n})$ 级别。

#### 可视化设计思路
- **动画方案**：
  - **分块展示**：用网格表示分块结构，不同颜色区分各连通块。
  - **合并过程**：高亮待合并的两个连通块，动态显示块信息的归并过程。
  - **区间更新**：用闪烁效果标记散块，用颜色渐变表示整块懒标记的增量。
- **复古像素风格**：
  - **颜色方案**：使用 8 位红绿色调，红色表示活跃操作（如合并），绿色表示懒标记。
  - **音效触发**：合并时播放短促电子音，更新时根据操作类型播放不同音效。

---

### 题解清单（≥4星）

1. **honglan0301（★★★★★）**
   - **亮点**：空间优化到 $O(n)$，动态数组处理非零块信息，代码简洁。
   - **关键代码**：
     ```cpp
     vector<pair<int, int>> sm[200005]; // 块信息
     for (auto i : sm[u]) ns[i.fi] += i.se; // 合并块统计
     ```

2. **Leasier（★★★★☆）**
   - **亮点**：归并排序块信息，避免重复计算，时间复杂度稳定。
   - **关键代码**：
     ```cpp
     vector<pair<int, int>> temp;
     while (i < sizex || j < sizey) // 归并块信息
     ```

3. **lht1217（★★★★☆）**
   - **亮点**：分块与并查集结合，维护块内元素数量矩阵，适合教学演示。
   - **关键代码**：
     ```cpp
     int sz[N][M]; // 块内元素数量矩阵
     ans += sz[fa_x][i] * tag[i]; // 计算整块贡献
     ```

---

### 最优思路与技巧提炼

1. **分块与并查集结合**：通过分块降低区间操作复杂度，通过并查集维护动态连通性。
2. **动态归并块信息**：合并连通块时归并其块分布信息，避免重复遍历所有元素。
3. **懒标记优化整块更新**：对整块使用懒标记，散块直接暴力更新，平衡时间复杂度。

---

### 类似题目推荐

1. **P2147 [SDOI2008] 洞穴勘测**（动态连通性 + 分块）
2. **P3203 [HNOI2010] 弹飞绵羊**（分块处理跳跃操作）
3. **P5356 [Ynoi2017] 由乃打扑克**（分块维护区间信息 + 复杂查询）

---

### 可视化代码片段（分块合并动画）

```javascript
// Canvas 绘制分块合并动画
function drawMerge(block1, block2) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 绘制原始块
    drawBlocks(block1, "#FF0000"); // 红色表示待合并块1
    drawBlocks(block2, "#00FF00"); // 绿色表示待合并块2
    // 归并动画
    setTimeout(() => {
        let merged = mergeBlocks(block1, block2);
        drawBlocks(merged, "#0000FF"); // 蓝色表示合并后块
        playSound("merge_sound.wav"); // 合并音效
    }, 1000);
}
```

---

### 个人心得摘录

> "合并时采用启发式归并，避免大规模数据移动，是降低时间复杂度的关键。" —— honglan0301  
> "分块后整块处理必须用懒标记，否则无法通过时间限制。" —— lht1217

---
处理用时：59.95秒
# 题目信息

# [SDOI2017] 相关分析

## 题目描述

Frank 对天文学非常感兴趣，他经常用望远镜看星星，同时记录下它们的信息，比如亮度、颜色等等，进而估算出星星的距离，半径等等。

Frank 不仅喜欢观测，还喜欢分析观测到的数据。他经常分析两个参数之间（比如亮度和半径）是否存在某种关系。

现在 Frank 要分析参数 $X$ 与 $Y$ 之间的关系。他有 $n$ 组观测数据，第 $i$ 组观测数据记录了 $x_i$ 和 $y_i$。他需要一下几种操作。

###  $\verb!1 L R!$

用直线拟合第 $L$ 组到第 $R$ 组观测数据。用 $\overline{x}$ 表示这些观测数据中 $x$ 的平均数，用 $\overline{y}$ 表示这些观测数据中 $y$ 的平均数，即
 
$$\begin{aligned}\overline{x}&={1 \over R-L+1} \sum _{i=L} ^R x_i \\\overline{y}&={1 \over R-L+1} \sum _{i=L} ^R y_i\end{aligned}$$

如果直线方程是 $y=ax+b$，那么 $a$ 应当这样计算：

$$a={\displaystyle\sum_{i=L} ^R (x_i-\overline{x})(y_i-\overline{y}) \over \displaystyle\sum _{i=L} ^R (x_i -\overline{x})^2}$$

 
你需要帮助 Frank 计算 $a$。

 
###  $\verb!2 L R S T!$

Frank 发现测量数据第 $L$ 组到第 $R$ 组数据有误差，对每个 $i$ 满足 $L \leq i \leq R$，$x_i$ 需要加上 $S$，$y_i$ 需要加上 $T$。
 
###  $\verb!3 L R S T!$

Frank 发现第 $L$ 组到第 $R$ 组数据需要修改，对于每个 $i$ 满足 $L \leq i \leq R$，$x_i$ 需要修改为 $(S+i)$，$y_i$ 需要修改为 $(T+i)$。


## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据 $1 \leq n,m \leq 1000$；
- 另有 $20\%$ 的数据，没有 $3$ 操作，且 $2$ 操作中 $S=0$；
- 另有 $30\%$ 的数据，没有 $3$ 操作。

对于 $100\%$ 的数据，$1 \leq n,m \leq 10^5$，$0 \leq |S|,|T| \leq 10^5$，$0 \leq |x_i|,|y_i| \leq 10^5$。

保证 $1$ 操作不会出现分母为 $0$ 的情况。


## 样例 #1

### 输入

```
3 5
1 2 3
1 2 3
1 1 3
2 2 3 -3 2
1 1 2
3 1 2 2 1
1 1 3
```

### 输出

```
1.0000000000
-1.5000000000
-0.6153846154
```

# AI分析结果



### **唯一算法分类**: 线段树

---

### **综合分析与结论**

**核心思路**：  
通过公式推导将原问题转化为维护四个统计量（Σx, Σy, Σxy, Σx²），使用线段树处理区间修改和查询。  
**关键难点**：  
1. **数学推导**：将线性回归系数公式转化为可维护的统计量组合  
2. **懒标记设计**：同时处理区间加和区间覆盖两种操作，需保证标记传递顺序（覆盖优先于加法）  
3. **精度控制**：用双精度浮点数避免大整数溢出  

**可视化设计**：  
1. **动画方案**：  
   - **颜色标记**：红色高亮覆盖操作节点，蓝色高亮加法操作节点  
   - **步进控制**：展示线段树节点的统计量更新过程（如 Σx 的增量计算）  
   - **音效提示**：覆盖操作触发低音“咚”，加法操作触发高音“滴”  
2. **复古像素风格**：用 16 色像素网格表示线段树结构，每个节点显示四个统计量的数值变化  

---

### **题解清单 (≥4星)**

| 题解作者   | 评分 | 关键亮点                                                                 |
|------------|------|--------------------------------------------------------------------------|
| liangbowen | ★★★★★ | 公式推导清晰，代码结构简洁，重载运算符优化合并操作                       |
| Capella    | ★★★★☆ | 详细注释数学公式，分步处理覆盖和加法标记                                 |
| Rainybunny | ★★★★☆ | 分块实现提供替代思路，适合线段树不熟悉的读者                             |

---

### **最优思路与技巧**

**核心实现思想**：  
1. **公式简化**：  
   $$ a = \frac{\sum xy - \frac{(\sum x)(\sum y)}{n}}{\sum x^2 - \frac{(\sum x)^2}{n}} $$  
2. **线段树节点设计**：  
   ```cpp
   struct Node {
       double x, y, xx, xy; // Σx, Σy, Σx², Σxy
       double add_s, add_t; // 加法标记
       bool cov;            // 覆盖标记
   };
   ```
3. **覆盖操作处理**：  
   利用等差数列和平方和公式快速计算区间初始值：
   ```cpp
   void rebuild(int l, int r, int pos) {
       tr[pos].cov = true;
       tr[pos].x = tr[pos].y = (l + r) * (r - l + 1) / 2; // 等差数列和
       tr[pos].xx = tr[pos].xy = sqsum(r) - sqsum(l-1);    // 平方和公式
   }
   ```

---

### **同类型题与推荐**

1. **相似套路题**：  
   - **P3372** 线段树区间加/求和  
   - **P3373** 线段树加乘混合标记  
   - **P4145** 区间开方与求和  

2. **推荐题目**：  
   - P2572 [SCOI2010] 序列操作  
   - P1471 方差  
   - P2486 [SDOI2011] 染色  

---

### **代码片段与可视化**

**核心代码**（liangbowen 的线段树更新）：
```cpp
void lazy(int l, int r, int pos, db S, db T) {
    tr[pos].s += S, tr[pos].t += T;
    tr[pos].xy += T * tr[pos].x + S * tr[pos].y + S * T * (r - l + 1);
    tr[pos].xx += 2 * S * tr[pos].x + S * S * (r - l + 1);
    tr[pos].x += S * (r - l + 1), tr[pos].y += T * (r - l + 1);
}
```

**可视化 JS 伪代码**：
```javascript
// 像素风格线段树绘制
function drawNode(node, x, y) {
    ctx.fillStyle = node.cov ? '#FF8888' : '#8888FF'; // 红/蓝表示操作类型
    ctx.fillRect(x, y, 80, 40);
    ctx.fillText(`Σx=${node.x}`, x+5, y+15); // 显示关键统计量
}
```

---

### **个人心得摘录**

> "调试时发现覆盖标记未清空加法标记，导致后续计算错误。线段树的标记传递顺序必须严格遵循覆盖优先于加法，这是本题最易出错的关键点。"  
> —— liangbowen 调试日志

---

### **可视化算法演示**

**步骤说明**：  
1. **初始化**：构建线段树，每个叶子节点显示初始 (x_i, y_i)  
2. **操作2（加S/T）**：  
   - 高亮受影响区间，显示 Σx += S*len 等公式推导  
   - 播放连续“滴”声表示加法  
3. **操作3（覆盖）**：  
   - 红色闪烁节点，显示 Σx 被重置为等差数列  
   - 播放“咚”声表示覆盖  
4. **查询操作**：  
   - 黄色高亮查询区间，动态绘制分子/分母计算过程  

**交互设计**：  
- **速度滑块**：控制动画步进速度（0.5x~5x）  
- **模式切换**：在“分块”和“线段树”实现间对比效率差异

---
处理用时：73.04秒
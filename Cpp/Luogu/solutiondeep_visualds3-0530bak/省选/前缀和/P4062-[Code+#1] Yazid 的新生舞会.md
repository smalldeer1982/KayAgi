# 题目信息

# [Code+#1] Yazid 的新生舞会

## 题目背景

这道题是没有舞伴的 Yazid 用新生舞会的时间出的。


## 题目描述

Yazid 有一个长度为 $n$ 的序列 $A$，下标从 $1$ 至 $n$。显然地，这个序列共有 $\frac{n\left( n+1\right)}{2}$ 个子区间。

对于任意一个子区间 $[l,r]$，如果该子区间内的众数在该子区间的出现次数严格大于 $\frac{r-l+1}{2}$（即该子区间长度的一半），那么 Yazid 就说这个子区间是“新生舞会的”。

所谓众数，即为该子区间内出现次数最多的数。特别地，如果出现次数最多的数有多个，我们规定值最小的数为众数。

现在，Yazid 想知道，共有多少个子区间是“新生舞会的”。


## 说明/提示

**【样例解释 #1】**

“新生舞会的”子区间有 $[1,1],[1,2],[1,3],[2,2],[2,4],[3,3],[3,4],[3,5],[4,4],[5,5]$ 共 $10$ 个。

 ![](https://cdn.luogu.com.cn/upload/pic/12825.png) 

对于所有数据，保证 $0\leq A_i\leq n-1$。

对于 $type=0$ 的数据，没有任何特殊约定。

对于 $type=1$ 的数据，保证 $A_i\in \{ 0, 1 \}$。

对于 $type=2$ 的数据，保证序列 $A$ 的众数在整个序列中的出现次数不超过 $15$。

对于 $type=3$ 的数据，保证 $A_i\leq 7$。

来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/郑林楷 命题/王聿中 验题/郑林楷

Git Repo：https://git.thusaac.org/publish/CodePlus201711

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
5 0
1 1 2 2 3```

### 输出

```
10```

# AI分析结果



**【唯一算法分类】**  
**分治与枚举众数结合，利用等差数列性质优化前缀和统计**

---

### **题解思路与核心难点**

1. **核心思路**  
   - **枚举众数**：对每个可能的值单独处理其作为绝对众数的贡献。  
   - **转化为前缀和顺序对**：将问题转化为求满足 `2S_r - r > 2S_l - l` 的区间数，其中 `S_i` 为前 `i` 项中当前众数的出现次数。  
   - **等差数列优化**：非当前众数的位置形成连续的递减等差数列，批量处理这些段以降低时间复杂度。  
   - **三阶前缀和维护**：通过树状数组或线段树维护前缀和的变化，快速计算区间贡献。

2. **算法要点**  
   - **偏移量处理**：前缀和可能为负数，需整体加上偏移量（如 `n+1`）转为正数。  
   - **连续段贡献计算**：对每个等差数列段，计算其对二阶前缀和的贡献。  
   - **数据结构优化**：用树状数组维护三阶前缀和（系数分离法）或线段树处理区间加等差数列。

3. **解决难点**  
   - **复杂度控制**：通过等差数列批量处理，将复杂度从 `O(n^2 log n)` 降至 `O(n log n)`。  
   - **负数下标处理**：通过偏移量统一映射到正数区间，避免特殊判断。

---

### **题解评分与亮点**  
**★★★★★ [OMG_wc]**  
- **思路清晰**：详细推导前缀和转化与等差数列贡献。  
- **代码简洁**：树状数组维护三阶前缀和，代码仅 50 行。  
- **可视化友好**：前缀和变化与等差数列可直观展示。  

**★★★★☆ [Alex_Wei]**  
- **线性复杂度**：通过指针移动优化，复杂度严格 `O(n)`。  
- **差分技巧**：利用差分数组维护三阶前缀和，减少内存占用。  

**★★★★☆ [shadowice1984]**  
- **分治策略**：递归处理左右区间，统计跨中点贡献。  
- **极简实现**：代码不足 100 行，适合学习分治思想。  

---

### **最优思路提炼**  
1. **核心公式推导**  
   将条件 `众数出现次数 > 区间长度/2` 转化为 `2S_r - r > 2S_l - l`，其中 `S_i` 为前缀和。  
   **数学推导**：  
   - 若区间 `[l, r]` 的众数为 `x`，则 `S_r - S_{l-1} > (r-l+1)/2`。  
   - 两边乘 2 并移项得 `2S_r - r > 2S_{l-1} - (l-1)`。  
   - 令 `P_i = 2S_i - i`，问题转化为求顺序对 `P_r > P_l`。  

2. **等差数列优化**  
   - 非众数位置形成连续递减段（公差为 -1），批量处理贡献。  
   - **贡献计算**：对等差数列段 `[a, b]`，总贡献为 `∑_{i=a}^{b} ∑_{j=1}^{i-1} cnt[j]`，转化为二阶前缀和之差。  

3. **树状数组维护三阶前缀和**  
   - 维护三个数组：`c1`（一阶）、`c2`（i·c1）、`c3`（i²·c1）。  
   - 查询公式：`sum = (c1·(x+2)(x+1) - c2·(2x+3) + c3)/2`。  

---

### **同类型题推荐**  
1. [P3524 选举](https://www.luogu.com.cn/problem/P3524)：绝对众数判定与统计。  
2. [P2397 众数](https://www.luogu.com.cn/problem/P2397)：区间众数查询。  
3. [P3567 不重复数字](https://www.luogu.com.cn/problem/P3567)：哈希优化众数统计。  

---

### **可视化方案设计**  
**动画演示树状数组维护三阶前缀和**  
1. **颜色标记**  
   - **红色**：当前处理的等差数列段。  
   - **绿色**：树状数组更新区域。  
   - **蓝色**：前缀和查询区间。  

2. **关键步骤动画**  
   - **步骤 1**：枚举众数 `x`，标记其位置为红色方块。  
   - **步骤 2**：非 `x` 位置形成递减等差数列（显示为向下箭头）。  
   - **步骤 3**：树状数组更新（绿色高亮更新区间）。  
   - **步骤 4**：查询贡献时显示二阶前缀和范围（蓝色覆盖区域）。  

**复古像素风格示例**  
```javascript
// 伪代码：Canvas 绘制前缀和变化
const canvas = document.getElementById("pixel-canvas");
const ctx = canvas.getContext("2d");
const colors = ["#000", "#F00", "#0F0", "#00F"]; // 黑、红、绿、蓝

function drawPrefixSum(prefixArray) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  prefixArray.forEach((val, idx) => {
    ctx.fillStyle = colors[val % 4]; // 按模4着色
    ctx.fillRect(idx * 10, 100 - val * 2, 8, 8); // 绘制像素方块
  });
}
```

---

### **核心代码实现（OMG_wc 树状数组版）**  
```cpp
typedef long long LL;
const int N = 500005;
LL c1[N*2], c2[N*2], c3[N*2];

void add(int x, LL d, int n) {
  for(; x<=n; x+=x&-x) {
    c1[x] += d;
    c2[x] += d * x;
    c3[x] += d * x * x;
  }
}

LL sum(int x) {
  LL res = 0;
  for(; x>0; x-=x&-x) 
    res += c1[x]*(x+2)*(x+1) - c2[x]*(2*x+3) + c3[x];
  return res / 2;
}

// 主逻辑：处理每个数的贡献
for(int w=0; w<n; w++) {
  vector<int>& pos = vec[w]; // vec存储所有w的位置
  pos.push_back(n+1); // 边界处理
  int last = 0;
  for(int j=0; j<pos.size(); j++) {
    int y = 2*j - last + wc, x = 2*j - (pos[j]-1) + wc;
    ans += sum(y-1) - (x>=3 ? sum(x-2) : 0);
    add(x, 1, 2*n+1); 
    add(y+1, -1, 2*n+1);
    last = pos[j];
  }
  // 反向操作清空树状数组
}
```

---

### **总结与学习建议**  
1. **优先掌握树状数组法**：代码简洁，适合快速实现。  
2. **深入理解三阶前缀和**：通过系数分离降低计算复杂度。  
3. **调试技巧**：用小数据验证等差数列段的贡献计算。

---
处理用时：92.53秒
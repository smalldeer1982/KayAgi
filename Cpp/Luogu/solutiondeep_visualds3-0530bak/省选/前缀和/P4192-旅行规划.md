# 题目信息

# 旅行规划

## 题目描述

OIVillage 是一个风景秀美的乡村，为了更好的利用当地的旅游资源，吸引游客，推动经济发展，xkszltl 决定修建了一条铁路将当地 $n$ 个最著名的景点连接起来，让游客可以通过火车从铁路起点（1 号景点）出发，依次游览每个景区。为了更好的评价这条铁路，xkszltl 为每一个景区都赋予了一个美观度，而一条旅行路径的价值就是它所经过的景区的美观度之和。不过，随着天气与季节的变化，某些景点的美观度也会发生变化。

xkszltl 希望为每位旅客提供最佳的旅行指导，但是由于游客的时间有限，不一定能游览全部景区，然而他们也不希望旅途过于短暂，所以每个游客都希望能在某一个区间内的车站结束旅程，而 xkszltl 的任务就是为他们选择一个终点使得旅行线路的价值最大。可是当地的景点与前来观光的旅客实在是太多了，xkszltl 无法及时完成任务，于是找到了准备虐杀 NOI2011 的你，希望你能帮助他完成这个艰巨的任务。


## 说明/提示

$n,m \leq 100000$。

## 样例 #1

### 输入

```
5
1 8 -8 3 -7
3
1 1 5
0 1 3 6
1 2 4```

### 输出

```
9
22```

# AI分析结果



---

### 唯一算法分类
分块 + 凸包优化

---

### 综合分析与结论
#### 核心思路
1. **分块处理**：将序列分为 $\sqrt{n}$ 大小的块，每个块维护等差数列标记（首项 $beg$ 和公差 $d$）。
2. **凸包维护最大值**：每个块维护前缀和的凸包结构，查询时在凸包上二分求最大截距。
3. **整块与散块分离**：整块修改直接调整标记，散块暴力重构并重建凸包。

#### 解决难点
- **区间加等差数列**：转化为首项和公差的调整，整块 $O(1)$ 修改，散块暴力重构。
- **快速查询区间最大值**：通过凸包维护一次函数极值，利用斜率单调性二分。

#### 可视化设计
- **分块展示**：用不同颜色区分块边界，高亮当前操作的块（整块蓝色，散块红色）。
- **凸包动态变化**：在 Canvas 上绘制凸包点及当前查询的二分过程，步进展示点的筛选。
- **像素风格**：用 8-bit 风格网格显示块结构，修改时播放“方块填充”音效，查询成功时触发上扬音效。

---

### 题解评分（≥4星）
1. **hzoi_liuchang（5星）**  
   - 思路清晰，完整推导分块与凸包结合的数学原理。
   - 代码实现高效，凸包二分逻辑简洁。
   - 关键代码片段：
     ```cpp
     void build(rg int id) { // 重构块并维护凸包
         for(rg int i=l[id];i<=r[id];i++) sum[i] += 1LL*d[id]*(i-l[id]+1);
         std::sort(sta+1,sta+tp+1);
         while(tail>1 && xl(que[tail],sta[i])>=xl(que[tail-1],que[tail])) tail--;
     }
     ```
2. **win114514（5星）**  
   - 最优解实现，分块+凸包二分极致优化。
   - 代码简洁高效，关键函数 `Getval` 直接计算截距：
     ```cpp
     long long Getval(int p, long long k) { return h[p].x * k + h[p].y; }
     ```
3. **AbioAg（4星）**  
   - 从树状数组维护前缀和的独特角度切入，结合分块。
   - 强调标记不下放的优雅实现。

---

### 最优思路/技巧提炼
1. **分块维护等差数列**：整块通过 $beg$ 和 $d$ 标记快速更新，散块暴力重构。
2. **凸包极值查询**：将前缀和转化为一次函数，维护上凸壳，二分求最大截距。
3. **暴力与标记分离**：散块操作后必须重构凸包，保证后续查询正确性。

---

### 同类型题与算法套路
1. **区间加 & 区间最值**：如 P4680 [Ynoi2018] 末日时在做什么。
2. **分块 + 凸包优化**：适用于区间操作转化为一次函数的场景。
3. **斜率优化动态维护**：如任务安排类问题。

---

### 推荐相似题目
1. **P4680 [Ynoi2018] 末日时在做什么？**  
   （分块维护区间加等差数列与凸包查询）
2. **P4192 旅行规划**  
   （同类型题目，区间加、区间最大前缀和）
3. **P3515 [POI2011] Lightning Conductor**  
   （分块与决策单调性结合）

---

### 个人心得摘录
- **hzoi_liuchang**：  
  *“等差数列加等差数列仍是等差数列，利用这一性质避免复杂标记下放。”*  
- **Thosaka_Forest**：  
  *“调试时发现未及时重构凸包导致查询错误，重构时机是关键。”*

---

### 代码核心片段
#### 分块与凸包构建（hzoi_liuchang）
```cpp
void build(rg int id) {
    if(d[id]) { // 清除旧标记
        for(rg int i=l[id];i<=r[id];i++) sum[i] += 1LL*d[id]*(i-l[id]+1);
        d[id] = 0;
    }
    std::sort(sta+1, sta+tp+1); // 按坐标排序
    for(rg int i=1; i<=tp; i++) { // 维护凸包
        while(tail>1 && xl(que[tail],sta[i])>=xl(que[tail-1],que[tail])) tail--;
        que[++tail] = sta[i];
    }
}
```

#### 凸包二分查询（win114514）
```cpp
long long ask(int l, int r) {
    int nowp = 1;
    for(int i=l; i<=r; i++) {
        while(nowp < Ptot && Getval(nowp+1, kt[i]) > Getval(nowp, kt[i])) 
            nowp++;
        ans = max(ans, Getval(nowp, kt[i]) + bt[i]);
    }
    return ans;
}
```

---

### 可视化实现（JavaScript 伪代码）
```javascript
// Canvas 初始化与分块绘制
const drawBlock = (ctx, blockId, color) => {
    ctx.fillStyle = color;
    ctx.fillRect(L[blockId]*10, 0, (R[blockId]-L[blockId]+1)*10, 50);
};

// 凸包动态二分演示
function animateConvexHull(queryK) {
    let left = 0, right = convexHull.length - 1;
    while (left < right) {
        let mid = Math.floor((left + right) / 2);
        if (calcSlope(mid, mid+1) >= queryK) right = mid;
        else left = mid + 1;
    }
    highlightPoint(convexHull[left]); // 高亮最优解点
}

// 8-bit 音效触发
function playSound(effect) {
    const audioCtx = new AudioContext();
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(effect === 'success' ? 880 : 440, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
}
```

---

**可视化交互示例**：  
- **自动模式**：按块顺序演示区间加操作，凸包点动态插入。  
- **手动步进**：点击“下一步”触发凸包二分查询，伴随音效。  
- **复古调色板**：使用 FC 红白机经典8色调色板（#FF0000、#00FF00 等）。

---
处理用时：89.50秒
# 题目信息

# 于神之怒加强版

## 题目描述

给定 $n,m,k$，计算

$$\sum_{i=1}^n \sum_{j=1}^m \gcd(i,j)^k$$

对 $10^9 + 7$ 取模的结果。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq T \leq 2 \times 10^3$，$1 \leq n, m, k \leq 5 \times 10^6$。

## 样例 #1

### 输入

```
1 2
3 3```

### 输出

```
20```

# AI分析结果



### 算法分类
**莫比乌斯反演 + 积性函数筛法**

---

### 题解思路与核心难点
**核心思路**：  
1. 通过莫比乌斯反演将原式转化为 $\sum_{T=1}^n \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor \cdot g(T)$，其中 $g(T) = \sum_{d|T} d^k \mu(\frac{T}{d})$  
2. 利用积性函数性质，设计线性筛算法预处理 $g(T)$ 的前缀和  
3. 对每个查询进行数论分块优化  

**解决难点**：  
1. **积性函数推导**：证明 $g(T)$ 是积性函数，并推导质数幂次项的表达式  
2. **线性筛实现**：处理质数幂次项的递推关系（$g(p^{n}) = p^{k} \cdot g(p^{n-1})$）  
3. **分块优化**：将双重求和转化为单层分块，时间复杂度优化至 $O(\sqrt{n})$  

---

### 题解评分（≥4星）

1. **滑大稽（⭐⭐⭐⭐⭐）**  
   - 亮点：完整推导积性函数性质，给出两种筛法证明，代码带详细注释  
   - 个人心得：强调质数幂次项的特殊处理，提供调试视角  

2. **Wolfycz（⭐⭐⭐⭐）**  
   - 亮点：代码精简高效，直接给出质数幂次项的推导公式  
   - 关键代码：`f[p] = (pow(p, k) - 1) % MOD`  

3. **ecnerwaIa（⭐⭐⭐⭐）**  
   - 亮点：用 `low[x]` 标记最小质因子幂次，优化筛法逻辑  
   - 关键代码：`low[i * prime[j]] = low[i] * prime[j]`  

---

### 最优思路提炼

1. **积性函数构造**  
   - $g(n) = \sum_{d|n} d^k \mu(\frac{n}{d})$ 的积性性质  
   - 对质数 $p$，$g(p) = p^k - 1$；对质数幂 $p^c$，$g(p^c) = p^{k} \cdot g(p^{c-1})$  

2. **线性筛优化**  
   - 当 `i % prime[j] == 0` 时，直接递推：`g[i*prime[j]] = g[i] * prime[j]^k`  
   - 否则按积性性质拆分：`g[i*prime[j]] = g[i] * g[prime[j]]`  

3. **数论分块技巧**  
   - 预处理前缀和后，单次查询时间复杂度 $O(\sqrt{n})$  

---

### 核心代码实现
```cpp
const int N = 5e6 + 5, MOD = 1e9 + 7;
int f[N], prime[N], cnt;
bool vis[N];

void sieve(int k) {
    f[1] = 1;
    for (int i = 2; i < N; ++i) {
        if (!vis[i]) {
            prime[++cnt] = i;
            f[i] = (power(i, k) - 1 + MOD) % MOD;
        }
        for (int j = 1; j <= cnt && i*prime[j] < N; ++j) {
            vis[i*prime[j]] = true;
            if (i % prime[j] == 0) {
                f[i*prime[j]] = 1LL * f[i] * power(prime[j], k) % MOD;
                break;
            }
            f[i*prime[j]] = 1LL * f[i] * f[prime[j]] % MOD;
        }
    }
    // 前缀和预处理
    for (int i = 1; i < N; ++i) 
        f[i] = (f[i-1] + f[i]) % MOD;
}
```

---

### 同类题目推荐
1. **P2522 [HAOI2011] Problem B**（莫比乌斯反演 + 二维前缀和）  
2. **P3327 [SDOI2015] 约数个数和**（积性函数性质应用）  
3. **P2257 YY的GCD**（类似筛法优化）

---

### 可视化设计思路
**动画方案**：  
1. **质数筛过程**：  
   - 高亮当前处理的数字，红色标记质数  
   - 显示质数幂次项的递推过程（如 $p^2 → p^3$）  

2. **数论分块演示**：  
   - 用不同颜色块表示 $\lfloor \frac{n}{T} \rfloor$ 的区间划分  
   - 动态显示区间端点 $l, r$ 的移动过程  

**复古像素风格**：  
- 使用 16 色调色板（如 #FF69B4 标记质数）  
- 8-bit 音效：  
  - 质数发现时播放 "叮" 声  
  - 分块区间切换时播放 "哔" 声  

---

通过以上分析，可以高效解决该题并掌握同类问题的核心技巧。

---
处理用时：68.12秒
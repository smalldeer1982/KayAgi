# 题目信息

# [SBCOI2020] 归家之路

## 题目背景

时光流逝，岁月无痕。  
小镇的夜空中，缀满了无数宝石一般的闪烁星辰。  
依旧是那片星空，依旧是那个小镇。  
......  
“好久不见啊。”  
“不知不觉，竟然已经过去了那么久了...”  
“但是，这座小镇还是曾经的那个小镇啊。”  
“只不过，我们都不再是过去的自己了呢。”  
“你还记得吗，我们曾经一起在这里看雪，一起玩游戏...”   
“可是游戏结局明明一开始就已经决定了...真是太坏了...”    
“嘿嘿，说起来你还从来没赢我过呢......”  
“我还记得，你以前说过，每当世界上有一份思念，便会化成一片雪花在这里飘落...”  
“嗯，我只要看着冬天的雪便能想起你了。我知道，这一定是你的思念吧...”    
“我也看到了，如同雪花般飘落的记忆......”  

天空中，点点滴滴的光芒融合在一起，清澈而宁静。眼前的风景是那么熟悉又陌生。  
![](https://cdn.luogu.com.cn/upload/image_hosting/ic5htl18.png)

“我们再待一会儿如何，就像以前一样......”  
“和你，和小镇，和星空......”

## 题目描述

天空中一共有 $2^n$ 颗星，依次编号为 $0,1,...,2^n-1$。每颗星都有一个亮度值。初始时第 $i$ 颗星的亮度值为 $a_i$。  

对于两个正整数 $a,b$ 我们定义一种布尔类型运算 $a\otimes b$ 。如果在 $a$ 的**二进制**表示中，满足每一个 $a$ 是 $1$ 的位，$b$ 的对应位也是 $1$，那么  $a\otimes b$ 为 `True` , 否则 $a\otimes b$ 为 `False`。  
若两数在二进制表示下的位数不同，则将两数 **右对齐** 后在左侧补0。例如两个数是 $1$ 和 $11$ （二进制），$1$ 会变成 $01$。

对于这些星的亮度值有两种操作：

第一种：$1$ $a$ $b$ $k$。对于所有的满足 $a\otimes c$ 值为 `True` 以及 $c\otimes b$ 值为 `True` 的 $c$，将第 $c$ 颗星的亮度值加上 $k$。

第二种：$2$ $a$ $b$。若第 $c$ 颗星的编号 $c$ 满足 $a\otimes c$ 值为 `True` 以及 $c\otimes b$ 值为 `True`。求出所有第 $c$ 颗星的亮度总和，答案对 $2^{32}$ 取模。  


## 说明/提示

**【样例解释】**

第一次是询问，$0$ 的二进制表示为 $000$， $7$ 的二进制表示为 $111$ 。此时，所有数都满足，即求的是所有数之和，为 $36$。

第二次是修改，$1$ 的二进制表示为 $001$，$5$ 的二进制表示为 $101$，发现 $c=1,5$ 满足，二进制表示分别为 $001$，$101$所以 $a_1,a_5$ 的值从 $2,6$ 变为 $3,7$。

第三次是询问，$1$ 的二进制表示为 $001$，$7$ 的二进制表示为 $111$，发现 $c=1,3,5,7$ 满足，二进制表示分别为 $001$，$011$，$101$，$111$。求的是 $a_1,a_3,a_5,a_7$ 的和 $3+4+7+8=22$。

**【数据范围】**

**本题捆绑测试，共有 $4$ 个子任务**。 

$Subtask 1(1\%)$：答案为样例。

$Subtask 2(9\%)$：$n \le 12,m \le 2\times 10^3$。

$Subtask 3(15\%)$：所有 $2$ 操作都在 $1$ 操作之后。

$Subtask 4(75\%)$：没有任何额外限制。

对于 $100\%$ 的数据，$1 \le n \le 16,1 \le m \le 2\times 10^5, 0 \le a,b \le 2^n-1,0 \le a_i,k \le 2^{32}-1$。

**【温馨提示】**

对 $2^{32}$ 取模，可以直接用无符号 `32` 位整形的数据类型进行运算。在 `c++` 中就是 `unsigned int`。

~~也就是【直接自然溢出啥事没有】。~~

## 样例 #1

### 输入

```
3 3
1 2 3 4 5 6 7 8
2 0 7
1 1 5 1
2 1 7```

### 输出

```
36
22```

# AI分析结果



**唯一算法分类**: 高维前缀和 + 分块

---

### 综合分析与结论
#### 核心算法流程
1. **子集问题转化**：将操作转化为对二进制位集合的覆盖问题，利用高维前缀和快速计算子集和
2. **分块策略**：每处理约√(n*2ⁿ)次操作后，执行一次高维前缀和重构，平衡实时操作与批量处理
3. **递归拆分**：根据二进制位数选择暴力枚举或高维前缀和，通过 `f(x,y)=f(x-p,y)-f(x-p,y-p)` 递归式拆分问题
4. **位运算优化**：利用 `a&-a` 快速取最低有效位，通过异或运算计算可自由变化的二进制位集合

#### 可视化设计要点
- **像素风格动画**：
  - 使用16色调色板，用不同颜色区分：
    - 已处理块（蓝色）
    - 当前块修改操作（黄色闪烁）
    - 高维前缀和传播过程（绿色波纹扩散效果）
  - 每个二进制位用像素方格表示，1为亮色，0为暗色
- **音效设计**：
  - 块更新时播放8-bit "升级"音效
  - 递归拆分时播放短促电子音（音调随递归深度递增）
  - 错误操作触发复古游戏"失败"音效
- **自动演示模式**：
  - 左侧展示当前处理的二进制位模式
  - 右侧显示分块计数器和高维前缀和传播动画
  - 按空格键切换自动/手动模式

---

### 题解清单 (≥4星)
1. **command_block（★★★★★）**
   - 亮点：完整实现分块策略，利用双高维数组分别处理当前块和全局数据
   - 关键代码：
     ```cpp
     void update(){ // 分块重构核心
       for(int i=0;i<n;i++)
         for(int j=(1<<n)-1;j>=0;j--)
           if(j&(1<<i)) curr[j^(1<<i)] += curr[j];
     }
     ```

2. **犇犇犇犇（★★★★☆）**
   - 亮点：详细注释递归拆分过程，使用count数组优化二进制位数计算
   - 关键代码：
     ```cpp
     uint query(int x,int y){
       if(bitcnt[x^y] <= n/2) return brute_force();
       return query(x^lb,y) - query(x^lb,y^lb);
     }
     ```

3. **duyi（★★★★☆）**
   - 亮点：采用模板元编程实现FWT变换，代码模块化程度高
   - 关键代码：
     ```cpp
     template<typename T>
     void fwt_or(T* a,int n,T flag){ // 高维前缀和实现
       for(int i=1;i<n;i<<=1)
         for(int j=0;j<n;j+=(i<<1))
           for(int k=0;k<i;++k)
             a[j+k+i] += a[j+k]*flag;
     }
     ```

---

### 同类型题目推荐
1. [P5495] 子集和问题（高维前缀和经典应用）
2. [P2114] 位运算挑战（二进制位操作优化）
3. [P6789] 超立方体行走（高维空间动态规划）

---

### 可视化代码片段（Web）
```javascript
// 像素动画核心逻辑
class FWTViz {
  constructor(canvas) {
    this.ctx = canvas.getContext('2d');
    this.colors = ['#000','#00F','#0F0','#FF0','#F0F']; // 复古配色
    this.blocks = new Array(16).fill().map(() => 
      new Array(16).fill(0));
  }

  drawBlock(x, y, state) {
    this.ctx.fillStyle = this.colors[state];
    this.ctx.fillRect(x*10, y*10, 9, 9);
  }

  animateFWT() {
    for(let i=0; i<16; i++) { // 高维前缀和传播动画
      for(let j=0; j<65536; j++) {
        if(j & (1<<i)) {
          this.drawBlock(i, j>>i, 2); // 绿色波纹
          playSound('blip', 800 + i*100);
        }
      }
    }
  }
}
```

---

### 核心实现代码（C++）
```cpp
// 分块处理核心逻辑
const int B = 2000;
uint a[1<<16], sum[1<<16], temp[1<<16];
vector<Modify> block;

void process_block() {
  // 高维前缀和重构
  for(int i=0; i<n; i++)
    for(int j=0; j<(1<<n); j++)
      if(j & (1<<i))
        temp[j] += temp[j^(1<<i)];
  
  memcpy(sum, a, sizeof(a));
  for(int i=0; i<n; i++)
    for(int j=0; j<(1<<n); j++)
      if(j & (1<<i))
        sum[j] += sum[j^(1<<i)];
}

void query(int x, int y) {
  uint res = 0;
  // 处理当前块内的修改
  for(auto& m : block) {
    int overlap = (m.x|x) & (m.y&y);
    if(overlap == (m.x|x)) 
      res += m.k * (1 << __builtin_popcount((m.x|x)^(m.y&y)));
  }
  // 处理历史块
  if(__builtin_popcount(y^x) <= n/2) {
    int mask = y^x;
    for(int s=mask; ;s=(s-1)&mask){
      res += a[x|s];
      if(s==0) break;
    }
  } else {
    res += recursive_query(x, y);
  }
  return res;
}
```

---

通过这种分块策略与高维前缀和的结合，在保证时间复杂度 O(q√(n2ⁿ)) 的同时，极大优化了大规模数据下的实时响应能力。复古像素动画的加入，则让抽象的位运算过程变得直观可视，是算法学习与工程实践结合的典范。

---
处理用时：74.89秒
# 题目信息

# 「EZEC-2」甜梦

## 题目背景



> 昨是今非望无尽，生死相隔两茫茫。    
解愁肠，度思量，人间如梦，倚笑乘风凉。

## 题目描述

有 $n$ 个梦境场景，编号 $\in [1,n]$ 且互不相同。PF 有精神分裂症，他在同一时间会处于两个梦境。**这两个梦境所在的场景编号差别的绝对值不能大于 $l$**。场景之间有 $m$ 种**单向**关系，其中第 $i$ 个关系连接场景 $u_i$ 和 $v_i$。不存在不可能到达的场景。

每个场景都有一个快乐值，其中第 $j$ 个场景的快乐值为 $a_j$，在梦境**第一次**经过时增加。

一开始两个梦境均在场景 $1$，当两个梦境都移动到场景 $n$ 时，PF会醒来。

如果某次移动时，PF 目前梦境所在的两个场景 $A,B$ 都与某个场景 $C$ **直接相连**，那么 PF 可以**同时移动** 两个梦境到达场景 $C$ 。否则，PF **一次只能移动一个梦境**。

请你编一个程序，来计算醒来时可能得到的最大快乐值。

## 说明/提示

[大样例](https://www.luogu.com.cn/paste/ar8yuqg6)

**【样例解释 #1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/a3bbsu8i.png?x-oss-process=image/resize,m_lfit,h_340,w_500)

下文用 $A,B$ 表示目前正在进行的梦境：

移动梦境 $A \space 1 \to 3$，移动梦境 $B \space 1 \to 4$，移动梦境 $A \space 3 \to 5$，之后同时移动梦境 $A \space B$ 到达场景 $7$，快乐值总和为 $5+10+10 = 25$。

**注意**：如果想移动某一梦境到场景 $6$，那么另一梦境的编号必须大于等于 $4$。然而到 $6$ 的线路只有 $1\to 6$，而同时拥有场景 $1$ 和场景 $4$ 不满足中间相隔场景 $\le l$，故唯一通过场景 $6$ 的方案为将两个梦境同时移动到场景 $6$，而这么做能得到的快乐值为 $20$。

---

**【数据范围与约定】**
| 测试点编号 | $ n \le$ | $ m \le$ | $ l \le$ | $ a_i \le$| 时间 | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |:----------: | :----------: |:----------: |
| $1,2$ | $10$ | $15$| $5$ | $50$ | $1\text s$ |无 |
| $3\sim 4$ | $16$ | $40$ | $8$ | $5 \times 10^3$ |$1\text s$ |无 |
| $5\sim 6$ | $16$ | $120$ | $8$ | $5 \times 10^3$ |$1\text s$ |无 |
| $7 \sim 10$ | $100$| $10^3$|$10$ | $10^4$|$1 \text s$ |无|
| $11$ | $100$| $10^3$|$10$ | $10^4$|$1\text s$ |场景是一棵树|
| $12 \sim 14$ | $10^3$| $10^4$|$10$ | $10^4$|$1\text s$ |无|
| $15,16$ | $5\times10^3$| $3\times10^4$|$10$ | $10^4$|$1\text s$ |无|
| $17,18$ | $5\times10^3$| $3\times10^4$|$11$ | $10^4$|$2\text s$ |无|
| $19,20$ | $5\times10^3$| $3\times10^4$|$12$ | $10^4$|$3\text s$ |无|

对于 $100\%$ 的数据，$1\le u<v \le n$, $1 \le n \le 5\times 10^3$, $1 \le m \le 3\times 10^4$, $1 \le a_i \le 10^4$, $1 \le l \le 12$。

**输入保证每个场景都能从起点到达，并且都能连到终点。**

**输入不保证没有重边。**

**输入不对 $u,v$ 的编号差做任何保证。**

------------

**【移动范例】**

假设 $l=2$ 且关系存在，下面的格式表示 $A \space B$ $\to$ $A' \space B'$ 一次移动：

* $1 \space 3 \to 5\space 3$ (√)
* $1 \space 3 \to 1\space 4$ (×)
* $1 \space 3 \to 8\space 8$ (√)
* $1 \space 3 \to 6\space 8$ (×)

## 样例 #1

### 输入

```
7 9 2
0 4 5 10 10 20 0
1 2
1 3
1 4
1 6
2 5
3 5
4 7
5 7
6 7```

### 输出

```
25```

# AI分析结果



---

## 算法分类：状态压缩动态规划

---

### 题解思路与核心难点

#### 核心思路
1. **状态设计**：  
   定义 `dp[u][s]` 表示当前较小点为 `u`，状态 `s` 记录 `[u, u+l]` 范围内已访问的点（二进制位1表示已访问）。  
   **较大点 v = u + highbit(s)**，其中 `highbit(s)` 是 `s` 最高位的位置，确保无后效性（DAG不可逆）。

2. **转移方式**：  
   - **同时移动**：若 `u` 和 `v` 均可达 `w`，转移至 `dp[w][1]`，并累加 `a_w`。  
   - **移动较大点**：遍历 `v` 的邻接点 `w`，若 `w-u ≤ l`，更新状态 `s | (1<<(w-u))`。  
   - **移动较小点**：分两种情况：  
     - `w > v`：较小点变为 `v`，状态右移 `v-u` 位后添加 `w-v` 的标记。  
     - `w < v`：较小点变为 `w`，状态右移 `w-u` 位并重置最低位。

3. **快乐值处理**：  
   根据状态 `s` 判断 `w` 是否首次访问，若对应位未标记则累加 `a_w`。

#### 难点突破
- **状态压缩的合理性**：  
  由于 `l ≤ 12`，`s` 的二进制位只需覆盖 `u` 后最多12个点，确保时间和空间可行。
- **转移的正确性**：  
  需处理三种转移的逻辑，尤其是移动较小点时可能导致状态切换（如 `u` 变为 `v` 或 `w`）。
- **预处理优化**：  
  提前计算 `highbit(s)` 加速转移，避免每次遍历二进制位。

---

### 题解评分（≥4星）

1. **奇米（⭐⭐⭐⭐⭐）**  
   - **亮点**：完整的状态转移公式与代码对应，预处理 `highbit` 优化。  
   - **代码**：清晰分三种转移情况，利用 `highbit` 快速计算较大点。

2. **syksykCCC（⭐⭐⭐⭐）**  
   - **亮点**：详细注释与分情况讨论，适合理解转移逻辑。  
   - **代码**：预处理 `highbit`，转移逻辑与注释一一对应。

3. **yizhiming（⭐⭐⭐⭐）**  
   - **亮点**：结合DAG特性简化状态，强调不可逆性对转移的影响。  
   - **代码**：通过 `st += 2` 确保 `u` 已被访问，减少无效状态。

---

### 最优技巧提炼

1. **高位状态压缩**：  
   利用 `highbit(s)` 快速确定较大点 `v`，避免维护双坐标。
2. **滚动数组优化**：  
   针对 `n` 较大但 `l` 较小的特性，滚动存储最近 `l+1` 个点的状态。
3. **预处理加速**：  
   提前计算所有可能 `s` 的 `highbit`，时间复杂度从 `O(l)` 降为 `O(1)`。

---

### 类似题目推荐

1. **P2831 愤怒的小鸟**  
   - **相似点**：状态压缩DP，预处理转移条件。

2. **P3959 宝藏**  
   - **相似点**：状态表示与层次遍历结合，压缩连通状态。

3. **P2704 炮兵阵地**  
   - **相似点**：二进制状态压缩，处理相邻行约束。

---

### 核心代码实现

```cpp
// 预处理 highbit
for (int S=0; S<(1<<(l+1)); S++) {
    for (int j=l+1; j>=0; j--) {
        if ((S>>j)&1) { High[S] = j; break; }
    }
}

// 转移逻辑（以奇米代码为例）
for (int u=1; u<=n; u++) {
    for (int S=0; S<(1<<(l+1)); S++) {
        if (!(S&1) || dp[u][S]==-1) continue;
        int v = u + High[S];
        // 同时移动
        for (int w : G[v]) {
            if (G[u].count(w)) 
                dp[w][1] = max(dp[w][1], dp[u][S] + a[w]);
        }
        // 移动较大点v
        for (int w : G[v]) {
            if (w-u > l) continue;
            int nxt = S | (1<<(w-u));
            dp[u][nxt] = max(dp[u][nxt], dp[u][S] + a[w]);
        }
        // 移动较小点u
        for (int w : G[u]) {
            if (abs(w-v) > l) continue;
            if (w > v) {
                int shift = v - u;
                int nxt = (S >> shift) | (1 << (w - v));
                dp[v][nxt] = max(dp[v][nxt], dp[u][S] + (S>>(w-u)&1 ? 0 : a[w]));
            } else {
                int shift = w - u;
                int nxt = (S >> shift) | 1;
                dp[w][nxt] = max(dp[w][nxt], dp[u][S] + (S>>shift&1 ? 0 : a[w]));
            }
        }
    }
}
```

---

### 可视化设计（复古像素风格）

1. **动画逻辑**：  
   - **网格绘制**：每个节点以像素块表示，颜色区分访问状态（红色：当前点，绿色：已访问）。  
   - **状态更新**：移动时高亮变化的二进制位，播放“滴”音效。  
   - **自动模式**：按BFS顺序展示转移，速度可调（快/中/慢）。  

2. **交互功能**：  
   - **步进控制**：按钮控制单步执行或连续播放。  
   - **音效触发**：成功转移时播放上升音调，失败时低沉音效。  

3. **Canvas示例**：  
   ```javascript
   function drawState(u, s) {
       ctx.clearRect(0, 0, width, height);
       // 绘制u的像素块（红色）
       ctx.fillStyle = '#FF0000';
       ctx.fillRect(u * 20 % width, 0, 18, 18);
       // 绘制s的二进制位（绿色）
       for (let i=0; i<=l; i++) {
           if (s & (1<<i)) {
               ctx.fillStyle = '#00FF00';
               ctx.fillRect((u+i)*20 % width, 30, 18, 18);
           }
       }
   }
   ```

---

**总结**：本题通过状态压缩与高位预处理，高效处理双点移动约束，核心在于合理设计状态转移逻辑，确保每个操作的时间复杂度可控。

---
处理用时：82.67秒
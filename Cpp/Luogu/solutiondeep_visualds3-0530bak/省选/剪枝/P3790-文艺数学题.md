# 题目信息

# 文艺数学题

## 题目背景

小Y在AK曼哈顿OI，CTSC和APIO之后，开始研究数学题。


## 题目描述

小Y有一张N个点，M条边的无向图（**可能有重边、自环**），每条边都有一个权值w。


你需要计算：所有**生成树的边权的最大公约数**之和，具体操作见样例。


由于答案可能很大，需要**对1000000007取模**。


## 说明/提示

### 样例1的解释



 ![](https://cdn.luogu.com.cn/upload/pic/13639.png) 

显然，这张图有8个不同的生成树。


用$(x,y,z)$表示x,y,z的最大公约数，则答案


$=(12,6,8)+(6,8,9)+(8,9,12)+(9,12,6)+(9,4,6)+(12,4,8)+(12,4,9)+(6,4,8)$


$=2+1+1+3+1+4+1+2$


$=15$

### 数据范围


对于20%的数据，$N\le 10, M\le 20$；

对于另外10%的数据，$N\le 12, M\le 24$；

对于另外20%的数据，$N\le 60, M\le 3000$，且满足$u_i+1=v_i$；

对于另外20%的数据，$N\le 40, M\le 1000, W\le 1000$；

对于另外15%的数据，$N\le 50, M\le 2000$；

对于所有100%的数据，$N\le 60, M\le 3000, W\le 1000000$；



## 样例 #1

### 输入

```
4 5  
1 2 12  
1 3 9  
2 4 6  
3 4 8  
1 4 4  ```

### 输出

```
15```

# AI分析结果



## 算法分类

**数论 + 图论（矩阵树定理）**

---

## 题解思路与算法要点

### 核心思路
题目要求所有生成树的边权最大公约数之和。直接枚举所有生成树不可行，因此需借助数论与图论结合的方法：
1. **数学转换**：利用欧拉函数性质，将问题转化为求每个可能的公约数d的贡献。
2. **矩阵树定理**：计算边权为d倍数的子图的生成树数量。
3. **剪枝优化**：仅处理有效因子，避免无效计算。

### 解决难点
1. **数学推导**：通过莫比乌斯反演或欧拉函数将原问题转化为可计算的子问题。
2. **高效枚举因子**：避免枚举所有可能的d，仅处理边数足够的因子。
3. **矩阵快速计算**：通过高斯消元优化行列式计算，适应大规模图。

### 关键步骤
1. **预处理欧拉函数**：线性筛法计算phi值。
2. **因子统计**：统计每个d的候选边数量，跳过边数不足的d。
3. **基尔霍夫矩阵**：对每个有效d构建矩阵，计算行列式得到生成树数目。
4. **结果累加**：将每个d的贡献（F(d)*phi(d)）累加至答案。

---

## 题解评分与亮点

### 题解1（will7101）★★★★★
- **亮点**：完整推导数学转换过程，明确分治步骤与复杂度分析，提供不同数据范围的针对性优化。
- **核心代码**：未提供具体实现，但思路清晰指导性强。

### 题解2（Prean）★★★★☆
- **亮点**：代码简洁高效，实现phi筛法与矩阵树结合，通过剪枝优化枚举过程。
- **可改进点**：代码注释较少，部分逻辑需结合推导理解。

---

## 最优思路提炼

1. **数学转换**：利用欧拉函数将gcd求和转换为因子贡献累加。
2. **因子剪枝**：仅处理边数≥N-1的因子，减少无效计算。
3. **矩阵树定理**：快速计算生成树数量，时间复杂度O(N³)。
4. **线性筛法**：预处理欧拉函数，优化数论计算。

---

## 类似算法题目

1. **P6624 [省选联考 2020 A 卷] 作业题**（矩阵树定理结合数论）
2. **P6178 【模板】Matrix-Tree 定理**（基尔霍夫矩阵基础）
3. **P2522 [HAOI2011]Problem b**（莫比乌斯反演应用）

---

## 代码核心实现

### 预处理phi与筛法
```cpp
for(i=2;i<=mx;++i){
    if(!pos[i]) pos[pri[++top]=i]=top, phi[i]=i-1;
    for(j=1;j<=pos[i] && (x=i*pri[j])<=mx;++j){
        pos[x]=j;
        phi[x] = phi[i]*(pri[j] - (j != pos[i]));
    }
}
```

### 矩阵树计算（高斯消元）
```cpp
inline ui Gauss(){
    ui ans=1;
    for(ui i=1; i<n; ++i){
        if(!G[i][i]) // 行交换处理...
        ui inv = pow(G[i][i], mod-2);
        ans = ans * G[i][i] % mod;
        // 高斯消元主循环...
    }
    return ans;
}
```

---

## 可视化设计

### 动画方案
1. **因子枚举**：以像素网格展示不同d值的候选边，红色高亮有效因子。
2. **矩阵构建**：动态绘制基尔霍夫矩阵，绿色表示新增边的影响。
3. **高斯消元**：分步展示行交换与消元操作，黄色标记当前处理行。
4. **结果更新**：每次计算后，累加器数值变化，配以上扬音效。

### 复古像素风格
- **颜色方案**：16色调色板，深蓝背景，亮色元素区分矩阵与边。
- **音效**：8-bit音效标记步骤完成（如消元成功、因子有效）。
- **自动演示**：按d从小到大自动执行，可暂停观察矩阵状态。

---

## 个人心得

在代码调试中，需特别注意：
1. **矩阵行列式计算**：行列式取模前处理负值。
2. **因子枚举边界**：需包含d=1的情况，否则答案缺失。
3. **筛法初始化**：phi[1]需手动设为1，避免逻辑错误。

---
处理用时：172.55秒
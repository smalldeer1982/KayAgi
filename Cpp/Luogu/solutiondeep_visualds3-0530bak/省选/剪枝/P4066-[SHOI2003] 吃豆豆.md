# 题目信息

# [SHOI2003] 吃豆豆

## 题目描述

两个 PACMAN 吃豆豆。一开始的时候，PACMAN 都在坐标原点的左下方，豆豆都在右上方。PACMAN 走到豆豆处就会吃掉它。  
PACMAN 行走的路线很奇怪，只能向右走或者向上走，他们行走的路线可以有交点但不能互相穿过。  
请你帮这两个 PACMAN 计算一下，他们俩加起来最多能吃掉多少豆豆。


## 说明/提示

对于 $100\%$ 的数据，$N \leq 2000$。

## 样例 #1

### 输入

```
8 
8 1 
1 5
5 7 
2 2 
7 8 
4 6 
3 3 
6 4```

### 输出

```
7```

# AI分析结果



**唯一算法分类**：贪心

---

### **题解思路、算法要点与解决难点**

**核心思路**：  
将问题转化为求两条不相交的最长不下降子序列（LIS），通过贪心维护两个单调栈，动态更新以最大化总长度。

**算法要点**：  
1. **排序预处理**：按坐标排序，确保处理顺序符合移动方向（只能向右或向上）。  
2. **维护两个栈**：分别代表两个PACMAN的路径末尾高度。新元素优先插入第一个栈，无法插入时尝试替换并转移旧元素到第二个栈。  
3. **二分优化**：通过二分查找快速确定插入位置，保证栈的单调性，时间复杂度为O(n log n)。

**解决难点**：  
- **路径不交叉的处理**：通过交换相交路径的后半段消除交叉，确保贪心策略的有效性。  
- **维护双栈的最优性**：当第一个栈的元素被替换时，需将其转移到第二个栈中，保证两个栈的总长度最大。

---

### **题解评分（≥4星）**

1. **yinianxingkong（5星）**  
   - 思路清晰，代码简洁（仅20行），利用双栈维护LIS，时间复杂度O(n log n)。  
   - 关键亮点：通过替换和转移策略，将问题转化为经典贪心模型的变种。

2. **lingfunny（5星）**  
   - 实现直观，维护两个数组模拟双LIS，通过二分动态更新。  
   - 关键亮点：代码可读性高，直接体现贪心思想，适合快速理解。

3. **IkunTeddy（4星）**  
   - 使用类似的双LIS思路，代码结构清晰，但变量命名稍显复杂。  
   - 亮点：详细注释和分步解释，适合初学者逐步理解。

---

### **最优思路与技巧提炼**

**关键技巧**：  
- **双栈维护**：优先插入第一个栈，无法插入时替换并转移旧元素至第二个栈，最大化总长度。  
- **二分优化**：通过`upper_bound`快速定位插入位置，保证栈的单调性。  
- **坐标排序**：预处理确保处理顺序符合移动规则，简化后续操作。

**代码片段**：  
```cpp
// yinianxingkong 的代码核心部分
sort(ps+1, ps+n+1);  // 按坐标排序
for(int i=1; i<=n; i++) {
    if (可插入第一个栈) 直接插入;
    else {
        替换第一个栈中的元素;
        将替换下来的元素尝试插入第二个栈;
    }
}
```

---

### **同类型题与推荐题目**

**同类型题**：  
- **P1006 传纸条**：求两条不相交路径的最大和。  
- **P2045 方格取数加强版**：k条路径的最大和，扩展版问题。  

**推荐题目**：  
1. P1006（传纸条）  
2. P2045（方格取数加强版）  
3. P2577（ZJOI2005午餐，贪心+动态规划）

---

### **个人心得摘录**

- **wjyyy**：调试费用流时发现连边过多导致MLE/TLE，最终通过剪枝优化边数。  
- **lingfunny**：意识到路径交叉可转换为不交叉，直接忽略交叉条件简化问题。  
- **Pentiment**：通过观察发现贪心策略，避免复杂网络流建模。

---

### **可视化与算法演示**

**复古像素动画设计**：  
1. **坐标网格**：以8位像素风格绘制坐标系，豆豆用彩色方块表示。  
2. **双栈动态更新**：左侧显示两个栈的当前高度，右侧显示PACMAN移动路径。  
3. **高亮操作**：  
   - **插入新豆**：黄色闪烁，显示插入位置。  
   - **替换元素**：红色标记被替换元素，绿色显示转移至第二个栈。  
4. **音效**：  
   - 插入成功：清脆“滴”声。  
   - 替换操作：短促“咔嚓”声。  
5. **自动演示**：按排序顺序逐步处理豆豆，可暂停/步进观察栈的变化。

**Canvas实现核心逻辑**：  
```javascript
// 伪代码：插入新豆到栈
function insertBean(y) {
    if (y >= stack1.top()) {
        stack1.push(y);
        playSound('success');
    } else {
        const pos = binarySearch(stack1, y);
        const replaced = stack1[pos];
        stack1[pos] = y;
        if (replaced >= stack2.top()) {
            stack2.push(replaced);
            playSound('transfer');
        }
        // ... 其他情况处理
    }
    drawStacks(); // 更新Canvas绘制
}
```

---

### **总结**

本题通过贪心策略巧妙转化为双LIS问题，代码简洁高效，时间复杂度优化至O(n log n)。相较于网络流方法，贪心更易实现且性能更优，是此类问题的经典解法。

---
处理用时：67.33秒
# 题目信息

# 最优性剪枝

## 题目背景

Nauuo 是一名出题人。

众所周知，某些出题人非常懒，导致[随便爆搜](https://www.luogu.com.cn/discuss/show/185420)加上一个[最优性剪枝](https://www.luogu.com.cn/discuss/show/184641)就能通过。Nauuo 决定把这些 naive 的暴力都卡掉。

## 题目描述

Nauuo 决定卡一个暴力搜索程序，为此她构建了一组数据。为了简化题目，你将得到这组数据产生的搜索树 $T$。$T$ 中包含 $n$ 个节点，依次编号为 $1 \sim n$，其中 $1$ 号点是 $T$ 的根节点。一个节点的深度是它到 $1$ 号点的简单路径上的节点个数。

这个程序的伪代码如下

```cpp
answer := inf

procedure dfs(node,depth)
	if (node is leaf) 
		answer := min(answer,depth)
		return
	if (depth < answer)
		for i in children of node
			dfs(i,depth+1)

dfs(1,1)
```

其中，`:=` 表示赋值运算。

翻译成人话就是说，这个暴力搜索程序将**深度优先**地遍历这棵搜索树，当访问到一个叶节点时，这个程序将用这个叶节点的深度更新答案。

同时，这个程序有一个最优性剪枝，也就是说，当这个程序访问到任意一个深度等于答案的节点时，它将不会再访问这个节点的子节点。

然而，可怜的 Nauuo 并不知道这个程序在某个节点时访问自己子节点的顺序，因此她认为每个节点访问子节点的顺序都是在所有可能的情况中等概率随机的，显然，一共有 $\prod d_i!$ 种情况，其中 $d_i$ 表示 $i$ 号节点的子节点数量。

现在她想知道这个程序访问到的节点数量的期望，以确定这个程序会不会被自己的数据卡掉。

为了避免浮点误差，答案对 $998244353$ 取模。保证答案能被表示为最简分数 $\frac{p}{q}$，你只需要输出一个 $x (0\leq x < 998244353)$ 使得 $qx \equiv p \pmod {998244353}$。

## 说明/提示

#### 样例解释

第一组样例的真实答案为 $\frac{7}{2}$。

一共只有两种情况，如果 $1$ 号节点先遍历 $3$ 号节点，则程序将访问到搜索树中所有节点。如果 $1$ 号节点先遍历 $2$ 号节点，则 $4$ 号节点不会被访问到。

第二组样例中，每个非叶节点的子节点都是唯一的，因此只有一种可能的情况，所有节点都必然被访问到。

第三组样例的真实答案为 $\frac{94}{9}$。

---

#### 数据范围

**「本题采用捆绑测试」**

对于所有测试点，保证 $1 \leq n \leq 3\times 10^5$，$1 \leq p_i < i$。

$\text{Subtask 1 (11 pts)}$ $n \leq 9$。

$\text{Subtask 2 (18 pts)}$ $n \leq 100$。

$\text{Subtask 3 (19 pts)}$ $n\leq 10^3$。

$\text{Subtask 4 (4 pts)}$ $p_i = i-1$。

$\text{Subtask 5 (8 pts)}$ $p_i =\lfloor \frac{i}{2} \rfloor$。

$\text{Subtask 6 (40 pts)}$ 无特殊限制。

---

#### 提示

如果你不知道怎么对分数取模，可以参考[这里](https://www.luogu.com.cn/problem/P3811)。



## 样例 #1

### 输入

```
4
1 1 3```

### 输出

```
499122180```

## 样例 #2

### 输入

```
3
1 2```

### 输出

```
3```

## 样例 #3

### 输入

```
13
1 1 1 3 5 4 2 3 7 4 4 6```

### 输出

```
776412285```

# AI分析结果



## 唯一算法分类
树状数组优化期望计算

---

## 题解思路与算法要点
### 核心思路
利用期望线性性，将总期望拆分为每个节点被访问的概率之和。对于节点x，其被访问的条件是：在其到根的路径上，每个祖先y的所有子节点中，val（子树最小叶子深度）小于x深度的子节点必须排列在x所在分支之后。每个祖先y的贡献为1/(k+1)（k为符合条件的子节点数），总概率为路径上所有贡献的乘积。

### 关键步骤
1. **预处理val值**：后序遍历计算每个节点的val（子树最小叶子深度）。
2. **子节点排序**：每个节点的子节点按val从小到大排序。
3. **树状数组维护**：动态维护区间乘法因子，递归处理时更新对应区间。

### 解决难点
- **高效计算路径乘积**：通过树状数组将每个父节点的贡献转化为区间乘法操作，避免暴力遍历祖先。
- **动态区间维护**：对排序后的子节点，在val区间上应用乘法因子，利用树状数组高效处理。

---

## 题解评分（≥4星）
### Zory的题解（5星）
- **亮点**：树状数组实现区间乘法差分，递归回溯维护状态，代码清晰。
- **代码关键**：预处理val后，通过排序和树状数组动态维护贡献。

---

## 最优思路提炼
1. **期望拆分**：将总期望转化为单个节点概率求和。
2. **路径贡献乘积**：每个节点的概率为路径上祖先贡献的乘积。
3. **区间乘法优化**：利用树状数组高效维护各深度区间的贡献因子。

---

## 同类型题与套路
- **期望线性性**：常见于概率期望问题，如[NOIP2016]换教室。
- **树状数组区间维护**：类似问题如区间加法/乘法查询，如洛谷P3373线段树模板。
- **树DFS优化**：如统计子树信息，常见于树形DP问题。

---

## 推荐题目
1. P6835 [CSP-S2020] 函数调用（树形结构操作）
2. P4211 [LNOI2014] LCA（树路径统计）
3. P6157 礼物（树状数组维护贡献）

---

## 可视化与算法演示
### 动画设计
1. **树结构展示**：以根节点为起点，递归展开子树，高亮当前处理的分支。
2. **树状数组操作**：动态显示区间乘法的更新范围，颜色区分不同val区间。
3. **概率计算**：节点访问时显示当前概率累加过程。

### 复古像素风格
- **颜色编码**：绿色表示当前处理节点，红色为已更新区间，黄色为查询位置。
- **音效触发**：递归进入时播放"滴"声，区间更新时"哔"声，答案累加时上扬音效。

---

## 核心代码实现
```cpp
namespace BIT {
    const int N = 3e5 + 10, MOD = 998244353;
    ll bit[N];
    void init() { fill(bit, bit + N, 1); }
    int lowbit(int x) { return x & -x; }
    void mul(int x, ll c) {
        for (; x < N; x += lowbit(x)) bit[x] = bit[x] * c % MOD;
    }
    void update(int l, int r, ll c) { // [l, r) *= c
        mul(l, c); mul(r, (ll)invm(c, MOD) % MOD);
    }
    ll query(int x) {
        ll res = 1;
        for (; x > 0; x -= lowbit(x)) res = res * bit[x] % MOD;
        return res;
    }
}

vector<int> son[N];
int dep[N], val[N];

void dfs_val(int u) {
    if (son[u].empty()) val[u] = dep[u];
    else {
        val[u] = INF;
        for (int v : son[u]) {
            dep[v] = dep[u] + 1;
            dfs_val(v);
            val[u] = min(val[u], val[v]);
        }
    }
}

ll ans = 0;
void dfs(int u) {
    ans = (ans + BIT::query(dep[u] - 1)) % MOD;
    if (son[u].empty()) return;
    
    sort(son[u].begin(), son[u].end(), [](int a, int b) {
        return val[a] < val[b];
    });
    
    vector<int> vals = {0}; // 1-based
    for (int v : son[u]) vals.push_back(val[v]);
    vals.push_back(INF);
    
    for (int i = 2; i < vals.size() - 1; ++i) {
        BIT::update(vals[i], vals[i+1], invm(i, MOD));
    }
    
    for (int i = 0; i < son[u].size(); ++i) {
        int v = son[u][i];
        if (i > 0) BIT::update(vals[i], vals[i+1], i * invm(i+1, MOD) % MOD);
        dfs(v);
        if (i < son[u].size() - 1) BIT::update(vals[i+1], vals[i+2], (i+1) * invm(i+2, MOD) % MOD);
    }
    
    // 回溯恢复
    for (int i = 2; i < vals.size() - 1; ++i) {
        BIT::update(vals[i], vals[i+1], i);
    }
}

int main() {
    // 输入树结构并构建son数组
    BIT::init();
    dep[1] = 1;
    dfs_val(1);
    dfs(1);
    cout << ans;
}
```

---
处理用时：175.39秒
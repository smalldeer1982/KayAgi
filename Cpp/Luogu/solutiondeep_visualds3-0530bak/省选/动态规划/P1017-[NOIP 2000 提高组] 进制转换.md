# 题目信息

# [NOIP 2000 提高组] 进制转换

## 题目背景

NOIP2000 提高组 T1

## 题目描述

我们可以用这样的方式来表示一个十进制数：将每个阿拉伯数字乘以一个以该数字所处位置为指数，以 $10$ 为底数的幂之和的形式。例如 $123$ 可表示为 $1 \times 10^2+2\times 10^1+3\times 10^0$ 这样的形式。

与之相似的，对二进制数来说，也可表示成每个二进制数码乘以一个以该数字所处位置为指数，以 $2$ 为底数的幂之和的形式。  

一般说来，任何一个正整数 $R$ 或一个负整数 $-R$ 都可以被选来作为一个数制系统的基数。如果是以 $R$ 或 $-R$ 为基数，则需要用到的数码为 $0,1,\dots,R-1$。  

例如当 $R=7$ 时,所需用到的数码是 $0,1,2,3,4,5,6$，这与其是 $R$ 或 $-R$ 无关。如果作为基数的数绝对值超过 $10$，则为了表示这些数码，通常使用英文字母来表示那些大于 $9$ 的数码。例如对 $16$ 进制数来说,用 $A$ 表示 $10$，用 $B$ 表示 $11$，用 $C$ 表示 $12$，以此类推。

在负进制数中是用 $-R $ 作为基数，例如 $-15$（十进制）相当于 $(110001)_{-2}$（$-2$进制），并且它可以被表示为 $2$ 的幂级数的和数：

$$(110001)_{-2}=1\times (-2)^5+1\times (-2)^4+0\times (-2)^3+0\times (-2)^2+0\times (-2)^1 +1\times (-2)^0$$

设计一个程序，读入一个十进制数和一个负进制数的基数，并将此十进制数转换为此负进制下的数。


## 说明/提示

**数据范围**

对于 $100\%$ 的数据，$-20 \le R \le -2$，$|n| \le 37336$。




## 样例 #1

### 输入

```
30000 -2```

### 输出

```
30000=11011010101110000(base-2)```

## 样例 #2

### 输入

```
-20000 -2```

### 输出

```
-20000=1111011000100000(base-2)```

## 样例 #3

### 输入

```
28800 -16```

### 输出

```
28800=19180(base-16)```

## 样例 #4

### 输入

```
-25000 -16```

### 输出

```
-25000=7FB8(base-16)```

# AI分析结果



# 题目中文翻译

## [NOIP 2000 提高组] 进制转换

### 题目背景

NOIP2000 提高组 T1

### 题目描述

我们可以用这样的方式表示十进制数：将每个数字乘以以其位置为指数的 10 的幂之和。例如 $123$ 可表示为 $1 \times 10^2+2\times 10^1+3\times 10^0$。

类似地，二进制数可表示为数码乘以 2 的幂之和。任何正整数或负整数都可作为基数。当基数绝对值超过 10 时，使用字母表示大于 9 的数码（如 16 进制用 A 表示 10）。

在负进制中，使用 $-R$ 作为基数。例如 $-15$（十进制）对应 $(110001)_{-2}$，其展开式为：
$$1\times (-2)^5+1\times (-2)^4+0\times (-2)^3+0\times (-2)^2+0\times (-2)^1 +1\times (-2)^0$$

要求设计程序将十进制数转换为指定负进制数。

### 输入输出样例（见原题）

---

## 算法分类选择
**无算法分类**

---

## 题解思路与解决难点

### 核心算法原理
所有题解均基于**数学除余调整法**，其核心公式为：
```
被除数 = 商 × 除数 + 余数 → 余数 = 被除数 - 商 × 除数
```
当余数为负数时，通过调整使余数转正：
1. 余数调整为 `余数 - 基数`（此时余数变为正）
2. 商调整为 `商 + 1` 以保持等式成立

### 关键难点对比
| 题解作者         | 调整策略                                                                 | 实现方式       |
|------------------|--------------------------------------------------------------------------|----------------|
| 老卡手机         | 余数<0时 `余数 -= 基数`，`商 += 1`                                       | 递归输出余数   |
| judgejudge       | 将余数转换为正数后倒序输出                                               | 循环存储字符   |
| ikunTLE          | 用DFS递归处理余数调整                                                    | 先递归后输出   |

---

## 题解评分 (≥4星)

### 1. 老卡手机（5★）
- **亮点**：递归实现余数倒序输出，代码简洁，包含余数转字符的优化
- **代码示例**：
```cpp
void zhuan(int n,int r) {
    if(n==0) return;
    int m = n % r;
    if(m < 0) m -= r, n += r; // 余数调整
    zhuan(n/r, r);
    printf("%c", m >=10 ? 'A'+m-10 : m+'0');
}
```

### 2. judgejudge（4★）
- **亮点**：详细推导余数调整的数学原理，使用循环存储余数字符
- **核心代码**：
```cpp
while(n != 0){
    int j = n % m;
    n /= m;
    if(j < 0) j -= m, n--;
}
```

### 3. ikunTLE（4★）
- **亮点**：DFS实现余数调整，代码可读性强
- **核心代码**：
```cpp
void dfs(int x) {
    if(!x) return;
    int r = x % b;
    if(r < 0) r -= b, x += b; // 调整余数和商
    dfs(x / b);
    putchar(r <10 ? r+'0' : r-10+'A');
}
```

---

## 最优思路提炼
1. **余数调整公式**：当余数 <0 时：
   ```
   新余数 = 原余数 - 基数
   新商 = 原商 + 1
   ```
2. **倒序输出**：通过递归或反向遍历实现进制位的正确顺序
3. **字符转换**：用查表法处理大于9的数码（如 `s = "0123456789ABCDEF"`）

---

## 同类型题推荐
1. [P1143 进制转换](https://www.luogu.com.cn/problem/P1143)（正负进制通用）
2. [P1066 2^k进制数](https://www.luogu.com.cn/problem/P1066)（高精度进制处理）
3. [P1013 进制位](https://www.luogu.com.cn/problem/P1013)（进制谜题推理）

---

## 个人心得摘录
- **Dancepted**："暴力枚举所有可能的进制数，意外AC" → 小数据范围的特殊解法
- **Temp113**："余数调整的本质是保持数学等式的平衡"
- **judgejudge**："余数调整相当于跳到前一个区间，保证数码在合法范围内"

---

## 可视化与算法演示

### 动态调整过程演示（以-15转-2进制为例）
```plaintext
步骤 | 当前值 | 余数 | 调整后余数 | 新商
-----|--------|------|------------|-----
1   | -15    | -1   | 1          | 7
2   | 7      | 1    | 1          | -3
3   | -3     | -1   | 1          | 1
4   | 1      | 1    | 1          | -0
```

### 像素风格动画设计
1. **颜色方案**：
   - 红色：当前操作的余数
   - 绿色：已调整的余数
   - 黄色：商的变化过程
2. **音效设计**：
   - 调整余数时播放 "哔" 声
   - 完成转换时播放 8-bit 胜利音效
3. **Canvas 展示**：
   ```javascript
   function drawStep(value, remainder, adjusted) {
       ctx.fillStyle = adjusted ? "#00FF00" : "#FF0000";
       ctx.fillRect(step * 50, 0, 40, 40); // 绘制余数方块
       ctx.fillText(`商: ${newValue}`, step * 50, 60);
   }
   ```

---

## 代码实现（核心逻辑）
```cpp
#include <iostream>
using namespace std;

string convert(int n, int base) {
    if (n == 0) return "0";
    string res;
    while (n) {
        int rem = n % base;
        n /= base;
        if (rem < 0) {
            rem -= base;
            n++;
        }
        res = char(rem < 10 ? rem + '0' : rem - 10 + 'A') + res;
    }
    return res;
}

int main() {
    int n, r;
    cin >> n >> r;
    cout << n << "=" << convert(n, r) << "(base" << r << ")";
    return 0;
}
```

---
处理用时：75.47秒
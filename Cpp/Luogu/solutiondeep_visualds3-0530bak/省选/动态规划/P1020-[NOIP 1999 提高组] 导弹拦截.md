# 题目信息

# [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。


## 说明/提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
389 207 155 300 299 170 158 65```

### 输出

```
6
2
```

# AI分析结果



0. **题目翻译**  

---

## [NOIP 1999 提高组] 导弹拦截

### 题目描述

某国为防御敌国导弹袭击，开发了一套导弹拦截系统。该系统第一发炮弹能达到任意高度，但后续每发炮弹不能高于前一发。现雷达捕捉到多个导弹依次飞来的高度，要求计算：

1. 单套系统最多能拦截多少导弹？
2. 拦截所有导弹最少需要多少套系统？

### 输入格式

输入导弹依次飞来的高度。

### 输出格式

输出两行：  
第一行为单系统最多拦截数  
第二行为最少系统数  

### 说明/提示

- 前 50% 数据（NOIP 原数据），导弹数 ≤1e4，可用 O(n²) 算法  
- 后 50% 数据，导弹数 ≤1e5，需用 O(n log n) 算法  
- 所有数据导弹高度 ≤5e4  

---

### 样例输入
```
389 207 155 300 299 170 158 65
```

### 样例输出
```
6
2
```

---

1. **唯一算法分类**  
**线性DP**

---

2. **综合分析与结论**  

**核心思路**  
- **第一问**：求最长不上升子序列（LNDS）  
- **第二问**：根据 Dilworth 定理，转化为求最长上升子序列（LIS）  

**状态转移与优化**  
- **LNDS**：维护单调递减数组，每次用二分查找插入位置  
- **LIS**：维护单调递增数组，二分查找插入位置  
- **关键方程**：  
  - LNDS：`f[i] = max{ f[j]+1 | h[j]≥h[i], j<i }`  
  - LIS：`g[i] = max{ g[j]+1 | h[j]<h[i], j<i }`  

**可视化设计要点**  
- **动画方案**：以网格展示 DP 数组，当前处理元素高亮为红色，插入位置用绿色箭头标记  
- **复古像素风格**：  
  - 8位色块表示数组元素，LNDS 用蓝色渐变，LIS 用橙色渐变  
  - 音效：插入时播放「滴」声，系统新增时播放「哔」声  
- **自动演示**：按步长自动推进，可调节速度或单步执行  

---

3. **题解清单 (≥4星)**  

**1. 离散小波变换°（5星）**  
- 亮点：完整证明 Dilworth 定理，双二分代码简洁  
- 核心代码：  
  ```cpp
  // 最长不升子序列
  upper_bound(F, F+t+1, H[i], greater<int>());
  // 最长上升子序列
  lower_bound(F, F+t+1, H[i]);
  ```

**2. Tofu（4.5星）**  
- 亮点：从偏序集角度解析，绘制哈斯图辅助理解  
- 关键结论：导弹拦截问题等价于偏序集的最小链覆盖  

**3. STA_Morlin（4星）**  
- 亮点：代码可读性极佳，Dilworth 定理简化解题  
- 关键代码：  
  ```cpp
  *upper_bound(..., greater<int>()) = a[i]; // LNDS
  *lower_bound(...) = a[i];                 // LIS
  ```

---

4. **最优思路提炼**  

**关键技巧**  
- **贪心维护单调数组**：通过二分查找快速定位插入位置  
- **Dilworth 定理转换**：将复杂问题转化为经典 LIS  
- **逆向思维**：第二问的答案等价于正向求 LIS  

**代码实现核心**  
```cpp
// 维护最长不升子序列
int len = 0;
for (int x : a) {
    if (x <= f[len]) f[++len] = x;
    else *upper_bound(f+1, f+len+1, x, greater<int>()) = x;
}

// 维护最长上升子序列
int cnt = 0;
for (int x : a) {
    if (x > g[cnt]) g[++cnt] = x;
    else *lower_bound(g+1, g+cnt+1, x) = x;
}
```

---

5. **同类型题推荐**  
- **P1091 合唱队形**：双向 LIS 结合  
- **P1439 最长公共子序列**：序列映射转 LIS  
- **P2782 友好城市**：二维偏序转 LIS  

---

6. **可视化与算法演示**  

**Canvas 动态演示**  
```javascript
// 伪代码：绘制 LNDS 维护过程
function drawStep(arr, pos, val) {
    ctx.fillStyle = "#8B0000";     // 深红底色
    ctx.fillRect(pos*50, 0, 50, 50); 
    ctx.fillStyle = "#00FF00";      // 绿色文字
    ctx.fillText(val, pos*50+10, 30);
    playSound("beep.mp3");          // 触发音效
}
```

**复古风格参数**  
- 颜色：16 色调色板（NES 风格）  
- 网格：50x50 像素块，间距 2px  
- 音效：ChipTone 库生成 8 位音效  

---

**总结**：通过维护单调数组和二分优化，将 O(n²) 问题降为 O(n log n)，同时 Dilworth 定理提供了理论支撑，是线性 DP 与贪心结合的经典范例。

---
处理用时：69.84秒
# 题目信息

# [NOIP 2006 普及组] 明明的随机数

## 题目描述

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 $N$ 个 $1$ 到 $1000$ 之间的随机整数 $(N\leq100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。


## 说明/提示

NOIP 2006 普及组 第一题


## 样例 #1

### 输入

```
10
20 40 32 67 40 20 89 300 400 15
```

### 输出

```
8
15 20 32 40 67 89 300 400
```

# AI分析结果



# 题目重写

## [NOIP 2006 普及组] 明明的随机数

### 题目描述

明明想在学校中请一些同学一起做一项问卷调查。为了实验的客观性，他先用计算机生成了 $N$ 个 $1$ 到 $1000$ 之间的随机整数 $(N\leq100)$。对于其中重复的数字，只保留一个，把其余相同的数去掉。不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。

### 说明/提示

NOIP 2006 普及组 第一题

### 样例 #1

#### 输入
```
10
20 40 32 67 40 20 89 300 400 15
```

#### 输出
```
8
15 20 32 40 67 89 300 400
```

---

# 算法分类
无算法分类

---

# 题解综合分析

## 核心思路与解决难点
### 关键共性分析
所有题解均围绕"去重+排序"双重需求展开，主要呈现三种范式：
1. **桶标记法**（12篇）：利用值域受限特性，通过数组下标直接标记存在性
2. **排序后相邻去重**（8篇）：先排序再利用有序性判断相邻元素
3. **STL容器法**（5篇）：利用set自动排序去重或unique处理已排序序列

### 算法要点对比
| 方法                | 时间复杂度   | 空间复杂度   | 实现难度 | 适用场景          |
|---------------------|-------------|-------------|----------|-----------------|
| 桶标记法            | O(n)        | O(k) k=1001 | ★☆☆       | 值域小且密集     |
| 排序+相邻去重       | O(nlogn)    | O(n)        | ★★☆       | 通用场景         |
| STL set             | O(nlogn)    | O(n)        | ★☆☆       | 快速实现需求     |
| STL unique          | O(nlogn)    | O(n)        | ★★☆       | 已排序序列处理   |

### 核心难点突破
1. **空间效率与时间效率的权衡**：桶标记法以O(1000)空间换取O(n)时间复杂度，在n≤100时极具优势
2. **去重与排序的耦合关系**：通过先排序后去重，将双重操作简化为线性扫描（时间复杂度主要消耗在排序阶段）
3. **STL的抽象代价**：unique需要配合sort使用，set自动排序但迭代输出需要额外处理

---

# 题解评分（≥4★）

## 1. qr小盆友（4.5★）
**关键亮点**：
- 桶排序图示化讲解直观易懂
- 使用bool数组优化空间
- 同步统计有效个数避免二次遍历
**代码亮点**：
```cpp
for(int i=1;i<=1000;i++) 
    if(book[i]==1) cout<<i<<" ";
```

## 2. mcturtle（4.2★）
**STL典范**：
- 利用set自动去重排序特性
- 迭代器遍历输出规范
- 复杂度标注清晰
**核心代码**：
```cpp
set<int> s;
while(n--){ cin>>x; s.insert(x); }
cout<<s.size()<<endl;
for(auto it=s.begin();it!=s.end();it++) 
    cout<<*it<<" ";
```

## 3. Kaidora（4.0★）
**语言特性示范**：
- 展示Ruby极简实现
- 链式调用体现语言特性
- 注释说明关键方法
**代码示范**：
```ruby
arr = gets.split.map(&:to_i)
arr.uniq!.sort!
puts arr.size
puts arr.join(' ')
```

---

# 最优技巧提炼

## 桶标记法的三要素
1. **值域预判**：需确认最大数值范围（本题1000）
2. **存在性标记**：用数组下标直接记录数字存在状态
3. **有序遍历**：利用数组下标天然有序性输出结果

## STL应用范式
```cpp
// 万能模板
vector<int> v;
sort(v.begin(), v.end());
auto last = unique(v.begin(), v.end());
v.erase(last, v.end());
```

## 相邻去重模板
```cpp
sort(a, a+n);
int k = 0;
for(int i=0; i<n; i++)
    if(i==0 || a[i]!=a[i-1])
        b[k++] = a[i];
```

---

# 同类型题目推荐
1. P1075 质因数分解（数值处理）
2. P1051 谁拿了最多奖学金（数据清洗）
3. P1093 奖学金（复合排序）

---

# 可视化设计

## 桶标记法动画方案
```javascript
// 伪代码示例
class BucketAnimation {
  constructor(data) {
    this.buckets = new Array(1001).fill(false);
    this.numbers = data;
    this.current = 0;
  }

  step() {
    if(this.current >= this.numbers.length) return;
    let num = this.numbers[this.current++];
    this.buckets[num] = true; 
    // 触发像素动画：对应桶格子变亮+音效
  }

  render() {
    // 使用Canvas绘制0-1000的桶阵列
    // 激活的桶显示为绿色像素块
  }
}
```

## 复古特效要素
1. **8-bit音效**：
   - 数字入桶：NES风格"水滴"声（44.1kHz/8bit单声道）
   - 完成标记：FC游戏获得道具音
2. **像素动画**：
   - 桶阵列使用16x16像素格子
   - 数值标记时产生波纹扩散特效
3. **自动演示模式**：
   - 按0.5秒/步的节奏自动填充
   - 支持空格键暂停/继续

---

# 经典实现代码

## 桶标记法（空间优化版）
```cpp
#include <iostream>
using namespace std;

int main() {
    bool exist[1001] = {false};
    int n, x, cnt=0;
    cin >> n;
    for(int i=0; i<n; i++) {
        cin >> x;
        if(!exist[x]) cnt++;
        exist[x] = true;
    }
    cout << cnt << endl;
    for(int i=1; i<=1000; i++)
        if(exist[i]) cout << i << " ";
    return 0;
}
```

## STL终极精简版
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    set<int> s;
    int n; cin >> n;
    while(n--) { int x; cin >> x; s.insert(x); }
    cout << s.size() << endl;
    for(auto x : s) cout << x << " ";
}
```

---

# 总结启示
1. **值域分析先行**：当数值范围较小时，桶排序往往是最优解
2. **语言特性活用**：不同语言的标准库特性能极大简化问题（如Ruby的uniq!）
3. **空间换时间权衡**：在内存充裕时，用O(k)空间换取O(n)时间复杂度是经典策略

---
处理用时：82.64秒
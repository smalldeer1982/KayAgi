# 题目信息

# [NOIP 2006 提高组] 作业调度方案

## 题目描述

我们现在要利用 $m$ 台机器加工 $n$ 个工件，每个工件都有 $m$ 道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。

每个工件的每个工序称为一个操作，我们用记号 `j-k` 表示一个操作，其中 $j$ 为 $1$ 到 $n$ 中的某个数字，为工件号；$k$ 为 $1$ 到 $m$ 中的某个数字，为工序号，例如 `2-4` 表示第 $2$ 个工件第 $4$ 道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。

例如，当 $n=3,m=2$ 时，`1-1,1-2,2-1,3-1,3-2,2-2` 就是一个给定的安排顺序，即先安排第 $1$ 个工件的第 $1$ 个工序，再安排第 $1$ 个工件的第 $2$ 个工序，然后再安排第 $2$ 个工件的第 $1$ 个工序，等等。

一方面，每个操作的安排都要满足以下的两个约束条件。

1. 对同一个工件，每道工序必须在它前面的工序完成后才能开始；

2. 同一时刻每一台机器至多只能加工一个工件。

另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。

由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为 `1 1 2 3 3 2`。

还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。

例如，取 $n=3,m=2$，已知数据如下（机器号/加工时间）：


工件号 |工序 1 | 工序 2
-|-|-
$1$  |  $1/3$  |  $2/2$
$2$  |  $1/2$  |  $2/5$
$3$  |  $2/2$  |  $1/4$

则对于安排顺序 `1 1 2 3 3 2`，下图中的两个实施方案都是正确的。但所需要的总时间分别是 $10$ 与 $12$。

方案 1，用时 $10$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | `3-1` | `3-1` |  无   | `1-2` | `1-2` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

方案 2，用时 $12$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12  |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` |   无   |  无   | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | 无 | 无 |  无   | `1-2` | `1-2` | `3-1` | `3-1` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件 $(1.)(2.)$ 的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件 $(1.)(2.)$ 的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。

显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。


## 说明/提示

NOIP 2006 提高组 第三题


## 样例 #1

### 输入

```
2 3
1 1 2 3 3 2
1 2 
1 2 
2 1
3 2 
2 5 
2 4
```

### 输出

```
10```

# AI分析结果



---

# 题目重写

## [NOIP 2006 提高组] 作业调度方案

### 题目描述

利用 $m$ 台机器加工 $n$ 个工件，每个工件有 $m$ 道工序，每道工序在指定机器上完成。给定操作安排顺序，需满足以下约束：

1. **工序顺序约束**：同一工件的后续工序必须在前序工序完成后开始。
2. **机器独占约束**：同一时刻每台机器只能加工一个工件。
3. **空档插入规则**：优先插入最靠前的可行空档。

求完成所有操作的最小总时间。

### 输入格式

- 第一行：两个整数 $m$（机器数）、$n$（工件数）。
- 第二行：$m \times n$ 个整数，表示操作安排顺序。
- 接下来 $n$ 行：每行 $m$ 个整数，表示每个工件的各工序对应机器号。
- 最后 $n$ 行：每行 $m$ 个整数，表示每个工件的各工序加工时间。

### 输出格式

- 一个整数，表示最小总时间。

---

# 算法分类

**无算法分类**（核心为模拟题）

---

# 题解分析与结论

### 核心思路与难点

1. **模拟流程**  
   按给定顺序逐个处理每个工件的工序，维护以下状态：
   - 每个工件的当前工序步骤。
   - 每个工件的最后完成时间。
   - 每台机器的占用时间线。

2. **关键步骤**  
   - **寻找空档**：从工件的上一个工序完成时间后开始，在目标机器的时间线上扫描连续空闲时间段。
   - **标记占用**：找到足够长的空档后，将时间点标记为已占用，并更新工件和总时间。

3. **难点解决**  
   - **时间复杂度**：暴力扫描时间线在数据规模小（$n,m \leq 20$）时可接受。
   - **正确性保证**：严格按照空档插入规则，确保每次选择最靠前的可行位置。

### 状态转移与可视化设计

- **可视化目标**：展示每台机器的时间线及工序插入过程。
- **颜色标记**：已占用时间块用红色表示，当前扫描的空档用绿色高亮。
- **动画设计**：逐步显示每个工序的插入位置，并动态更新总时间线。

---

# 题解评分（≥4星）

### 1. brealid（★★★★☆）
- **亮点**：代码简洁高效，直接通过数组模拟时间线，利用连续计数判断空档。
- **代码片段**：
  ```cpp
  for (int j = las_time[now] + 1; ; j++) {
      if (mac[id][j] == 0) s++;
      else s = 0;
      if (s == cost) {
          for (int k = j - cost + 1; k <= j; k++) mac[id][k] = 1;
          las_time[now] = j;
          break;
      }
  }
  ```

### 2. ShawnZhou（★★★★★）
- **亮点**：使用独立函数 `check_in_line` 判断空档，逻辑清晰易读。
- **代码片段**：
  ```cpp
  bool check_in_line(int begin, int end, int machine) {
      for (int t = begin; t <= end; t++)
          if (timeline[machine][t]) return false;
      return true;
  }
  ```

### 3. ClV_Csy（★★★★☆）
- **亮点**：变量命名明确（如 `last_time`），结构体清晰，适合教学。
- **代码片段**：
  ```cpp
  struct node { int id, time; };
  int last_time[21] = {0}; // 工件最后完成时间
  bool mac[21][100001] = {0}; // 机器时间线
  ```

---

# 最优思路提炼

### 核心技巧
- **时间线模拟**：用布尔数组表示每台机器的时间点占用状态。
- **连续空档扫描**：从工件的上一个完成时间开始，暴力寻找连续可用时间段。
- **实时更新**：每次插入操作后，立即更新工件的最后时间和机器占用状态。

### 代码实现
```cpp
int m, n, list[500];
struct { int machine, time; } step_info[21][21];
int last_time[21] = {0}, current_step[21] = {0};
bool machine_timeline[21][100000] = {0};

int main() {
    // 读入数据
    for (int i = 1; i <= m * n; i++) {
        int cur_work = list[i];
        current_step[cur_work]++;
        int m_id = step_info[cur_work][current_step[cur_work]].machine;
        int m_time = step_info[cur_work][current_step[cur_work]].time;

        // 扫描空档
        int cnt = 0, start;
        for (int t = last_time[cur_work] + 1; ; t++) {
            if (!machine_timeline[m_id][t]) cnt++;
            else cnt = 0;
            if (cnt == m_time) {
                start = t - m_time + 1;
                break;
            }
        }

        // 标记占用
        for (int t = start; t <= start + m_time - 1; t++)
            machine_timeline[m_id][t] = true;
        last_time[cur_work] = start + m_time - 1;
    }
    // 输出最大时间
    return *max_element(last_time, last_time + n + 1);
}
```

---

# 同类型题目推荐

1. **P1080 国王游戏**  
   - 排序与贪心结合，处理最优排列问题。

2. **P1541 乌龟棋**  
   - 状态转移与资源分配的动态规划。

3. **P1231 教辅的组成**  
   - 多重资源匹配的模拟与优化。

---

# 可视化设计

### 复古像素风格
- **颜色方案**：16色调色板，机器时间线用网格表示，已占用块为红色，当前扫描块为绿色。
- **Canvas 动画**：每步插入操作后更新对应机器的网格颜色，音效提示成功插入。
- **AI 自动演示**：自动按顺序处理工序，展示空档扫描过程，速度可调节。

### 交互功能
- **步进控制**：支持暂停/继续/单步执行。
- **音效设计**：
  - 插入成功：8-bit 上升音效。
  - 扫描过程：低音节奏提示。

---

# 代码片段（JS 可视化核心）

```javascript
// Canvas 初始化
const canvas = document.getElementById("timeline");
const ctx = canvas.getContext("2d");
const colors = { free: "#00FF00", busy: "#FF0000", scanning: "#0000FF" };

// 绘制机器时间线
function drawMachine(machineId, timeline) {
    for (let t = 0; t < maxTime; t++) {
        ctx.fillStyle = timeline[t] ? colors.busy : colors.free;
        ctx.fillRect(t * 10, machineId * 20, 10, 18);
    }
}

// 插入动画
function animateInsert(machineId, start, duration) {
    for (let i = 0; i < duration; i++) {
        setTimeout(() => {
            ctx.fillStyle = colors.scanning;
            ctx.fillRect((start + i) * 10, machineId * 20, 10, 18);
        }, i * 100);
    }
}
```

---
处理用时：98.81秒
# 题目信息

# [NOIP 2009 普及组] 分数线划定

## 题目描述

世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，A 市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的 $150\%$ 划定，即如果计划录取 $m$ 名志愿者，则面试分数线为排名第 $m \times 150\%$（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。

现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。

## 说明/提示

【样例说明】

$m \times 150\% = 3 \times150\% = 4.5$，向下取整后为 $4$。保证 $4$ 个人进入面试的分数线为 $88$，但因为 $88$ 有重分，所以所有成绩大于等于 $88$ 的选手都可以进入面试，故最终有 $5$ 个人进入面试。

NOIP 2009 普及组 第二题


## 样例 #1

### 输入

```
6 3 
1000 90 
3239 88 
2390 95 
7231 84 
1005 95 
1001 88```

### 输出

```
88 5 
1005 95 
2390 95 
1000 90 
1001 88 
3239 88 ```

# AI分析结果



# 中文题目重写

## [NOIP 2009 普及组] 分数线划定

### 题目描述

A 市正在进行世博会志愿者的选拔工作。所有报名选手需先参加笔试，笔试成绩达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的 150% 划定：若计划录取 $m$ 名志愿者，则面试分数线为排名第 $\lfloor m \times 150\% \rfloor$（向下取整）名选手的成绩。所有成绩不低于该分数线的选手均可进入面试。

现需要编写程序实现以下功能：  
1. 计算面试分数线  
2. 输出所有进入面试选手的报名号与笔试成绩（按成绩降序排列，成绩相同则报名号升序排列）

### 输入格式

第一行两个整数 $n$（报名人数）和 $m$（计划录取人数）  
接下来 $n$ 行每行两个整数，分别表示选手的报名号和笔试成绩

### 输出格式

第一行两个整数，分别表示分数线和实际录取人数  
后续若干行按成绩降序输出各录取选手信息（成绩相同则按报名号升序）

### 样例说明

当 $m=3$ 时，$\lfloor 3 \times 150\% \rfloor=4$。样例中第4名成绩为88分，但存在多名选手同分，最终实际录取5人。

---

## 唯一算法分类
**无算法分类**

---

## 综合分析与结论

### 核心思路与难点
1. **排序规则**  
   - 主排序键：成绩降序  
   - 次排序键：报名号升序
2. **分数线确定**  
   - 计算基准位置：$pos = \lfloor m \times 1.5 \rfloor$  
   - 处理同分情况：基准位置之后所有同分选手均需录取
3. **复杂度控制**  
   - 采用 $O(n \log n)$ 的排序算法即可应对 $n \leq 5000$ 的数据规模

### 可视化设计要点
#### 复古像素风格动画
| 组件              | 设计方案                                                                 |
|-------------------|--------------------------------------------------------------------------|
| **颜色方案**      | 16色模式：橙色（高亮当前操作）、蓝色（已排序区域）、灰色（未排序区域）   |
| **Canvas网格**    | 每个选手表示为 32x32 像素方块，显示报名号后4位与成绩                    |
| **音效系统**      | 8-bit音效：排序交换时播放"哔"声，确定分数线时播放上升音阶                |
| **自动演示模式**  | 分阶段执行：排序动画→红线标记基准位置→黄框标出同分区域→绿色标记录取名单 |

#### 关键动画步骤
1. **排序过程**  
   - 冒泡式可视化：相邻元素比较时高亮对比，交换时产生位移动画
2. **分数线划定**  
   - 红色闪烁线标记第 $\lfloor m \times 1.5 \rfloor$ 位
3. **同分处理**  
   - 黄色脉冲光效标记所有同分选手

---

## 题解清单 (4星及以上)

### 1. [已注销] 题解（4.3★）
**关键亮点**  
- 使用下标数组避免结构体，节省内存  
- 通过 `sub[int(m*1.5)]` 直接获取基准分数  
- 单次遍历统计录取人数

**核心代码**
```cpp
sort(sub+1,sub+n+1,cmp); //对下标排序
f = s[sub[int(m*1.5)]];  //计算分数线
for(i=1; s[sub[i]]>=f; i++); //统计录取人数
```

### 2. [Eason_lyx] 题解（4.1★）
**关键亮点**  
- 结构体排序逻辑清晰  
- 使用 `while(a[cnt+1].s>=sc) cnt++` 简洁统计人数  
- 完整注释版与无注释版双版本

**调试心得**  
> "最初忘记处理同分情况，通过添加while循环遍历解决"

### 3. [zhengrunzhe] 题解（4.0★）
**创新点**  
- 使用Splay树维护分数序列  
- 利用平衡树特性快速定位分数线  
- 通过中序遍历输出结果

**实现难点**  
- Splay树的旋转操作与size维护  
- 同分选手存储在set中自动排序

---

## 核心代码实现

### 结构体排序标准解法
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Applicant {
    int id, score;
} a[5005];

bool cmp(Applicant x, Applicant y) {
    return (x.score != y.score) ? 
        (x.score > y.score) : 
        (x.id < y.id);
}

int main() {
    int n, m;
    cin >> n >> m;
    for(int i=1; i<=n; i++) 
        cin >> a[i].id >> a[i].score;
    
    sort(a+1, a+n+1, cmp);
    
    int cutoff_pos = m * 3 / 2;
    int cutoff_score = a[cutoff_pos].score;
    int actual_count = cutoff_pos;
    
    while(actual_count < n && a[actual_count+1].score == cutoff_score)
        actual_count++;
    
    cout << cutoff_score << " " << actual_count << endl;
    for(int i=1; i<=actual_count; i++)
        cout << a[i].id << " " << a[i].score << endl;
    return 0;
}
```

---

## 相似题目推荐

1. **P1093 奖学金**  
   （同类排序规则：总分→语文→学号）
2. **P1781 总统选举**  
   （多条件排序+阈值确定）
3. **P2676 超级书架**  
   （排序+累加达到阈值）

---

## 可视化代码片段（Canvas动画）

```javascript
// 绘制选手方块
function drawApplicant(ctx, app, x, y, isHighlight) {
    ctx.fillStyle = isHighlight ? "#FFA500" : "#6495ED";
    ctx.fillRect(x, y, 32, 32);
    ctx.fillStyle = "#FFF";
    ctx.fillText(app.id.toString().slice(-4), x+2, y+12);
    ctx.fillText(app.score, x+10, y+28);
}

// 排序动画帧
function animateSortStep() {
    if(sorting) {
        // 冒泡排序单步可视化
        let current = sortingStep++;
        ctx.clearRect(0,0,canvas.width,canvas.height);
        // 绘制当前比较元素...
        requestAnimationFrame(animateSortStep);
    }
}
```

---

## 个人心得摘录

> "最初认为分数线就是严格第m*1.5名的成绩，直到测试用例出现同分情况才意识到需要向后遍历检查。这提醒我们边界条件验证的重要性。"  
> —— 摘自题解评论区

> "使用结构体比分开维护两个数组更易读，虽然会略微增加内存占用，但在算法竞赛中可维护性更重要。"  
> —— 某题解作者调试体会

---
处理用时：86.07秒
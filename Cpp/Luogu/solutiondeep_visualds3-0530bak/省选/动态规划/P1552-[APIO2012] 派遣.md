# 题目信息

# [APIO2012] 派遣

## 题目背景

在一个忍者的帮派里，一些忍者们被选中派遣给顾客，然后依据自己的工作获取报偿。


## 题目描述

在这个帮派里，有一名忍者被称之为 Master。除了 Master 以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。

现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，你就不需要支付管理者的薪水。

   
你的目标是在预算内使顾客的满意度最大。这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。

   
写一个程序，给定每一个忍者 $i$ 的上级 $B_i$，薪水 $C_i$，领导力 $L_i$，以及支付给忍者们的薪水总预算 $M$，输出在预算内满足上述要求时顾客满意度的最大值。


## 说明/提示

$1 \le N \le 10^5$，$1 \le M \le 10^9$，$0 \le B_i \lt i$，$1 \le C_i \le M$，$1 \le L_i \le 10^9$。

对于 $30\%$ 的数据，$N \le 3000$。


## 样例 #1

### 输入

```
5 4
0 3 3
1 3 5
2 2 2
1 2 4
2 3 1
```

### 输出

```
6
```

# AI分析结果



0. **题目翻译**

# [APIO2012] 派遣

## 题目背景

在一个忍者的帮派里，一些忍者们被选中派遣给顾客，然后依据自己的工作获取报偿。

## 题目描述

在这个帮派里，有一名忍者被称之为 Master。除了 Master 以外，每名忍者都有且仅有一个上级。为保密，所有工作指令必须由上级发送给直接下属，不允许其他方式传递。

你需要选择一名忍者作为管理者，并在其子树中选择若干忍者（可包含管理者自己），使得这些忍者的薪水总和不超过预算 M。满意度定义为所选忍者数量乘以管理者的领导力。求最大可能的满意度。

## 输入格式

第一行两个整数 N 和 M  
随后 N 行，每行三个整数 B_i（上级）、C_i（薪水）、L_i（领导力）

## 数据范围

1 ≤ N ≤ 1e5，1 ≤ M ≤ 1e9，0 ≤ B_i < i

---

1. **唯一算法分类**  
无算法分类

---

2. **综合分析与结论**  
**核心思路**：树形结构+可并堆（左偏树）  
- **关键操作**：每个节点维护大根堆，合并子树堆时弹出高薪忍者直至总薪水≤M  
- **可视化设计**：  
  1. 树形结构展示，高亮当前处理节点  
  2. 堆合并过程用动态颜色流动表示  
  3. 弹出元素时用爆炸粒子特效  
  4. 满意度数值实时更新显示  
**复古像素风格**：  
- 8-bit 忍者像素图标表示节点  
- 16色调色板（包含经典FC绿/红/蓝）  
- 音效设计：  
  - 堆合并时播放"叮"声  
  - 弹出元素时播放"咔嚓"声  
  - 刷新最大值时播放升级音效  

---

3. **题解清单 (≥4星)**  
**KingBenQi（5星）**  
- 左偏树实现简洁，O(n logn) 时间复杂度  
- 关键代码段：  
  ```cpp
  root[fa] = Merge(root[i], root[fa]); // 合并子树堆
  while(sum[fa] > m) root[fa] = Merge(ls[root[fa]], rs[root[fa]]); // 弹堆顶
  ```  
**枫林晚（4.5星）**  
- 博客详细说明堆维护过程  
- 完整注释版代码适合新手  
**amazingOZR（4星）**  
- 最短代码实现（仅50行）  
- 结构体封装左偏树核心操作  

---

4. **关键代码实现**  
**左偏树合并核心逻辑**  
```cpp
struct Node { int ls, rs, val, dis; };
int merge(int x, int y) {
    if(!x || !y) return x+y;
    if(val[x] < val[y]) swap(x,y);
    rs[x] = merge(rs[x], y);
    if(dis[ls[x]] < dis[rs[x]]) swap(ls[x], rs[x]);
    dis[x] = dis[rs[x]] + 1;
    return x;
}
void dfs(int u) {
    heap[u].push(c[u]); sum[u] = c[u];
    for(auto v : tree[u]) {
        dfs(v);
        heap[u].join(heap[v]); // 合并子堆
        sum[u] += sum[v];
    }
    while(sum[u] > m) {        // 弹出高价忍者
        sum[u] -= heap[u].top();
        heap[u].pop();
    }
    ans = max(ans, L[u] * heap[u].size());
}
```

---

5. **相似题目推荐**  
1. P1484 种树（堆优化贪心）  
2. P3620 [APIO/CTSC2007]数据备份（堆+双向链表）  
3. P1090 合并果子（哈夫曼树+优先队列）

---

6. **可视化伪代码（Canvas）**  
```javascript
// 8-bit像素风格绘制
ctx.fillStyle = "#00FF00"; // FC经典绿色
drawTree(rootNode, x, y) {
    drawPixelArtNinja(x, y); // 绘制忍者像素图
    for(child in children) {
        drawLine(x,y, child.x,child.y); 
        drawTree(child, child.x, child.y);
    }
}

// 堆合并动画
function animateMerge(heapA, heapB) {
    playSound("merge.wav"); // 8-bit合成音效
    let particles = createParticles(heapA.position);
    particles.moveTo(heapB.position); // 粒子流向动画
}
```

---
处理用时：68.96秒
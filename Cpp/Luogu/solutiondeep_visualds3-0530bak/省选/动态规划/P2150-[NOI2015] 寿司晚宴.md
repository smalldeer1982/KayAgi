# 题目信息

# [NOI2015] 寿司晚宴

## 题目描述

为了庆祝 NOI 的成功开幕，主办方为大家准备了一场寿司晚宴。小 G 和小 W 作为参加 NOI 的选手，也被邀请参加了寿司晚宴。

在晚宴上，主办方为大家提供了 $n−1$ 种不同的寿司，编号 $1,2,3,\ldots,n-1$，其中第 $i$ 种寿司的美味度为 $i+1$。（即寿司的美味度为从 $2$ 到 $n$）

现在小 G 和小 W 希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小 G 品尝的寿司种类中存在一种美味度为 $x$ 的寿司，小 W 品尝的寿司中存在一种美味度为 $y$ 的寿司，而 $x$ 与 $y$ 不互质。

现在小 G 和小 W 希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数 $p$ 取模）。注意一个人可以不吃任何寿司。


## 说明/提示

【数据范围】


 ![](https://cdn.luogu.com.cn/upload/pic/1506.png) 


**勘误：$0 < p \le 10^9 $**

## 样例 #1

### 输入

```
3 10000```

### 输出

```
9```

## 样例 #2

### 输入

```
4 10000```

### 输出

```
21```

## 样例 #3

### 输入

```
100 100000000```

### 输出

```
3107203```

# AI分析结果



### 0. 题目翻译
#### [NOI2015] 寿司晚宴

**题目描述**  
为了庆祝 NOI 的成功开幕，主办方为大家准备了一场寿司晚宴。小 G 和小 W 作为参加 NOI 的选手，被邀请参加晚宴。  

晚宴上提供了 $n-1$ 种不同的寿司，编号为 $1,2,\ldots,n-1$，其中第 $i$ 种寿司的美味度为 $i+1$（即寿司的美味度从 $2$ 到 $n$）。  

小 G 和小 W 希望各自选择一些寿司品尝。方案被称为"不和谐"当且仅当：小 G 选的寿司中存在美味度为 $x$ 的寿司，小 W 选的寿司中存在美味度为 $y$ 的寿司，且 $x$ 与 $y$ 不互质。  

求所有和谐方案的总数（包含两人都不选的情况），结果对给定的正整数 $p$ 取模。

**输入格式**  
输入包含两个整数 $n$ 和 $p$。  
**输出格式**  
输出和谐方案数对 $p$ 取模的结果。  
**数据范围**  
$2 \leq n \leq 500$，$0 < p \leq 10^9$  
**样例**  
输入：3 10000 → 输出：9  
输入：4 10000 → 输出：21  

---

### 1. 算法分类：**线性DP（状态压缩+分组处理）**

---

### 2. 题解核心思路与难点

#### **核心思路**
- **质因数分离**：每个数最多含有一个 $> \sqrt{500}$ 的大质因数，其余为小质因数（共8个）。
- **状态压缩**：将小质因数集合压缩为8位二进制数（$2^8=256$ 种状态）。
- **分组处理**：将数按大质因数分组，每组内只能全分配给某一方或不选。
- **动态规划**：使用三维状态数组 `dp[s1][s2]` 表示双方选择的小质因数集合为 `s1` 和 `s2` 的方案数，通过滚动数组优化空间。

#### **关键状态转移**
1. **初始状态**：`dp[0][0] = 1`（双方均不选任何数）。
2. **分组转移**：
   - **f1数组**：当前大质数分配给小G的方案。
   - **f2数组**：当前大质数分配给小W的方案。
   - 每次处理一个质数分组时，先复制当前全局状态到 `f1` 和 `f2`。
3. **合并操作**：`dp = f1 + f2 - dp`，减去重复计算的空选情况。

#### **难点突破**
- **大质因数冲突处理**：通过排序确保同一大质因数的数连续处理。
- **状态压缩优化**：仅对8个小质因数进行状态压缩，降低复杂度至 $O(n \cdot 3^8)$。
- **滚动数组**：通过倒序更新避免状态覆盖问题。

---

### 3. 题解评分（≥4星）

| 题解作者 | 评分 | 亮点 |
|---------|------|-----|
| Orion545 | ⭐⭐⭐⭐ | 状态分组处理清晰，代码注释详细 |
| ethan_zhou | ⭐⭐⭐⭐ | 时间复杂度优化到 $O(n \cdot 3^8)$ |
| 翼德天尊 | ⭐⭐⭐⭐ | 分组背包思路解释透彻，代码结构简洁 |

---

### 4. 最优思路提炼
- **质因数分离策略**：将质因数分为大小两类，分别处理。
- **分组滚动更新**：按大质因数分组后，通过 `f1` 和 `f2` 独立处理每组可能性。
- **状态压缩技巧**：仅压缩8个小质因数，极大减少状态数。
- **合并去重公式**：`dp = f1 + f2 - dp` 避免空选重复计数。

---

### 5. 同类型题目
- **质因数状态压缩**：P2706 巧克力、P2151 HH去散步
- **分组处理DP**：P4161 游戏  

---

### 6. 代码实现（核心片段）
```cpp
int n, mod, dp[256][256], f1[256][256], f2[256][256];
struct Node { int s, big; } a[505];

void solve() {
    sort(a+2, a+n+1, [](Node x, Node y){ return x.big < y.big; });
    dp[0][0] = 1;
    for (int i = 2; i <= n; i++) {
        if (a[i].big != a[i-1].big) { // 新分组初始化
            memcpy(f1, dp, sizeof(f1));
            memcpy(f2, dp, sizeof(f2));
        }
        for (int j = 255; j >= 0; j--) { // 倒序更新防止覆盖
            for (int k = 255; k >= 0; k--) {
                if ((j & a[i].s) == 0) 
                    f2[j][k | a[i].s] = (f2[j][k | a[i].s] + f2[j][k]) % mod;
                if ((k & a[i].s) == 0)
                    f1[j | a[i].s][k] = (f1[j | a[i].s][k] + f1[j][k]) % mod;
            }
        }
        if (a[i].big != a[i+1].big) { // 合并分组结果
            for (int j = 0; j < 256; j++)
                for (int k = 0; k < 256; k++)
                    dp[j][k] = (f1[j][k] + f2[j][k] - dp[j][k] + mod) % mod;
        }
    }
}
```

---

### 7. 可视化设计
#### **动态规划矩阵展示**
- **网格渲染**：在Canvas中绘制256x256网格，每个单元格表示 `dp[s1][s2]`。
- **颜色编码**：
  - **红色**：当前处理的大质数分组影响区域。
  - **绿色**：`f1`数组更新过程。
  - **蓝色**：`f2`数组更新过程。
- **音效触发**：
  - **转移音效**：8-bit风格“滴”声，每次状态更新时播放。
  - **合并音效**：合成器音效，标志分组处理完成。

#### **交互功能**
- **步进控制**：支持单步执行观察每个质数分组处理。
- **自动演示**：AI模式自动播放，速度可调（1x/2x/5x）。
- **状态追踪**：鼠标悬停显示当前 `s1` 和 `s2` 的质因数集合。

---

### 8. 复古像素风格实现
```javascript
// Canvas初始化
const canvas = document.getElementById('dp-grid');
const ctx = canvas.getContext('2d');
const CELL_SIZE = 8; // 8x8像素单元格

function drawGrid() {
    for (let s1 = 0; s1 < 256; s1++) {
        for (let s2 = 0; s2 < 256; s2++) {
            ctx.fillStyle = dp[s1][s2] > 0 ? '#00FF00' : '#000000';
            ctx.fillRect(s1 * CELL_SIZE, s2 * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
    }
}
// 音效示例（Web Audio API）
function playBeep() {
    const osc = new OscillatorNode(ctx, { frequency: 800 });
    osc.connect(ctx.destination);
    osc.start(); osc.stop(ctx.currentTime + 0.1);
}
```

---
处理用时：98.29秒
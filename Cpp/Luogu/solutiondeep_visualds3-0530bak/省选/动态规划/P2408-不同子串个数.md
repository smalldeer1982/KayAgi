# 题目信息

# 不同子串个数

## 题目背景

因为 NOI 被虐傻了，蒟蒻的 YJQ 准备来学习一下字符串，于是它碰到了这样一道题：


## 题目描述

给你一个长为 $n$ 的字符串，求不同的子串的个数。

我们定义两个子串不同，当且仅当有这两个子串长度不一样或者长度一样且有任意一位不一样。

子串的定义：原字符串中连续的一段字符组成的字符串。


## 说明/提示

### 提示

请使用64位整数来进行输出。

### 数据规模与约定
- 对于 $30\%$ 的数据，保证 $n\le 1000$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，字符串中只有小写英文字母。


## 样例 #1

### 输入

```
5
aabaa```

### 输出

```
11```

## 样例 #2

### 输入

```
3
aba```

### 输出

```
5```

# AI分析结果



0. **题目翻译**  

---

# 不同子串个数

## 题目背景

蒟蒻的 YJQ 在 NOI 竞赛中惨败后，决定重新学习字符串知识，遇到了如下题目：

## 题目描述

给定一个长度为 $n$ 的字符串，求其所有不同子串的数量。两个子串被视为不同当且仅当它们的长度不同，或长度相同但至少存在一个不同的字符。

**子串定义**：原字符串中连续的一段字符组成的字符串。

## 说明/提示

- 输出时需使用 64 位整数
- 数据规模：
  - 30% 数据：$n \leq 1000$
  - 100% 数据：$1 \leq n \leq 10^5$，仅含小写字母

## 样例 #1

### 输入
```
5
aabaa
```

### 输出
```
11
```

## 样例 #2

### 输入
```
3
aba
```

### 输出
```
5
```

---

1. **唯一算法分类**  
   无算法分类（核心解法涉及后缀数组 SA/后缀自动机 SAM）

---

2. **综合分析与结论**  

### 核心思路与难点解析
所有题解围绕两种核心数据结构展开：

#### 后缀数组（SA）解法
**核心公式**：
$$ \text{总子串数} = \frac{n(n+1)}{2} - \sum height[i] $$
- **关键操作**：通过排序后缀，计算相邻后缀的最长公共前缀（Height 数组）
- **可视化设计**：
  - 动态绘制后缀排序过程，高亮相邻后缀的 LCP 计算
  - 用矩阵展示每个后缀的贡献值（长度 - height[i]）
  - 颜色标注：红色标记重复部分，绿色标记有效贡献

#### 后缀自动机（SAM）解法
**核心公式**：
$$ \text{新增子串数} = \text{maxlen}(u) - \text{maxlen}(link(u)) $$
- **关键操作**：构建 SAM 时动态累加增量
- **可视化设计**：
  - 动态生成 SAM 状态转移图
  - 用粒子动画表示字符插入时的状态分裂
  - 实时显示路径计数器的累加过程

#### 复古像素化实现要点
```javascript
// Canvas 绘制示例（SAM 状态转移）
ctx.fillStyle = "#8BDBFF"; // 水蓝色状态节点
ctx.fillRect(x*32, y*32, 28, 28); 
// 音效触发：状态分裂时播放 8-bit 音效
if(state.split) playSound("split.wav");
```

---

3. **题解清单 (≥4星)**  

| 题解作者       | 星级 | 核心亮点                                                                 |
|----------------|------|--------------------------------------------------------------------------|
| Rorschachindark| ★★★★★| SAM 动态维护增量，时间复杂度最优（O(n)），代码量最小（20行核心逻辑）     |
| Leap_Frog      | ★★★★☆| 双解法对比，SA 解法数学推导清晰，SAM 代码含拓扑排序 DP                   |
| Oracle         | ★★★★ | SA 解法代码完整，包含基数排序优化，height 计算过程注释详细              |

---

4. **最优思路与代码实现**  

**Rorschachindark 的动态维护 SAM 解法**  
```cpp
void Insert(int c) {
    // ... SAM 构建过程
    ans += len[q] - len[fa[q]]; // 动态累加增量
}

// 完整代码片段（核心逻辑）
int lst = 1, cnt = 1;
long long ans = 0;
for (int i = 1; i <= n; ++i) {
    int c = s[i] - 'a';
    int p = lst, np = lst = ++cnt;
    len[np] = len[p] + 1;
    while (p && !ch[p][c]) ch[p][c] = np, p = fa[p];
    if (!p) fa[np] = 1;
    else {
        int q = ch[p][c];
        if (len[q] == len[p] + 1) fa[np] = q;
        else {
            int nq = ++cnt;
            len[nq] = len[p] + 1;
            fa[nq] = fa[q], fa[q] = fa[np] = nq;
            memcpy(ch[nq], ch[q], sizeof(ch[q]));
            while (p && ch[p][c] == q) ch[p][c] = nq, p = fa[p];
        }
    }
    ans += len[np] - len[fa[np]]; // 核心增量计算
}
```

---

5. **相似题目推荐**  
1. [P3804 【模板】后缀自动机](https://www.luogu.com.cn/problem/P3804)  
2. [P2178 [NOI2015] 品酒大会](https://www.luogu.com.cn/problem/P2178)  
3. [P4248 [AHOI2013] 差异](https://www.luogu.com.cn/problem/P4248)

---

6. **可视化与复古游戏化设计**  

**动态 SAM 构建演示**  
- **像素动画**：每个状态用 16x16 像素块表示，转移边用箭头连接  
- **音效设计**：
  - 状态分裂：短促 "beep" 音（频率 800Hz）
  - 新状态创建：水滴声效
- **自动演示模式**：按空格键切换手动/自动插入字符

```javascript
// 自动演示逻辑示例
let autoMode = setInterval(() => {
    if (currentChar < n) insertChar(s[currentChar++]);
    else clearInterval(autoMode);
}, 500);
```

---

7. **总结**  
后缀自动机的动态维护法在时间和空间复杂度上均为最优解，适合处理百万级字符串问题。后缀数组解法更易理解数学本质，适合教学场景。两种方法都体现了「子串即路径」的核心思想，是处理字符串问题的通用范式。

---
处理用时：79.75秒
# 题目信息

# [SDOI2011] 拦截导弹

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度、并且能够拦截任意速度的导弹，但是以后每一发炮弹都不能高于前一发的高度，其拦截的导弹的飞行速度也不能大于前一发。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

在不能拦截所有的导弹的情况下，我们当然要选择使国家损失最小、也就是拦截导弹的数量最多的方案。但是拦截导弹数量的最多的方案有可能有多个，如果有多个最优方案，那么我们会随机选取一个作为最终的拦截导弹行动蓝图。

我方间谍已经获取了所有敌军导弹的高度和速度，你的任务是计算出在执行上述决策时，每枚导弹被拦截掉的概率。


## 说明/提示



保证总方案数不超过 C++ 中 double 类型的存储范围。

### 数据范围及约定

- 均匀分布着约 $30\%$ 的数据，所有 $v_i$ 均相等；
- 均匀分布着约 $50\%$ 的数据，满足 $1\le h_i,v_i\le 1000$。
- 对于 $30\%$ 的数据，满足 $1\le n\le 1000$；
- 对于 $100\%$ 的数据，$1\le n\le 5\times 10^4$，$1\le h_i,v_i\le 10^9$。

### 评分标准

对于每个测试点，若输出的第一行与标准输出相同，则得到该测试点 $40\%$ 的分数，若输出文件的第二行的每个数与标准输出的误差均不大于 $10^{-4}$，则得到该测试点 $60\%$ 的分数，两项相加作为该测试点总得分。

## 样例 #1

### 输入

```
4
3 30
4 40
6 60
3 30
```

### 输出

```
2
0.33333 0.33333 0.33333 1.00000
```

# AI分析结果



0. **题目翻译**

# [SDOI2011] 拦截导弹

## 题目描述

某国开发了一种导弹拦截系统，其第一发炮弹可拦截任意高度和速度的导弹，但后续炮弹必须满足高度和速度均不超过前一发。现给定所有来袭导弹的高度和速度序列，要求：

1. 计算最多能拦截的导弹数量
2. 对于每枚导弹，计算其在所有最优拦截方案中的被拦截概率

## 输入输出格式

输入包含导弹数量n及每枚导弹的高度和速度。输出第一行为最大拦截数，第二行为各导弹被拦截概率。

## 数据范围
- 30%数据：所有导弹速度相同
- 50%数据：高度和速度≤1000
- 100%数据：n≤5×10^4，高度和速度≤1e9

---

1. **唯一算法分类**  
无算法分类（三维偏序问题，CDQ分治优化DP）

---

2. **综合分析与结论**

**核心思路**：  
- **状态定义**：`f1[i]`表示以i结尾的最长不上升子序列长度，`g1[i]`为对应方案数；`f2[i]`和`g2[i]`表示以i开头的情况
- **状态转移**：通过CDQ分治处理三维偏序（时间、高度、速度），用树状数组维护最大值及方案数  
- **关键方程**：
  ```math
  f1[i] = max\{f1[j]+1\} \quad (j<i,\ h_j≥h_i,\ v_j≥v_i)
  g1[i] = sum\{g1[j]\} \quad (当f1[j]+1 == f1[i])
  ```

**可视化设计**：
- **CDQ分治过程**：将区间划分为左右两部分，用Canvas绘制分治树结构，当前处理区间高亮显示
- **树状数组更新**：用颜色标记被更新的节点，当查询高度和速度满足条件的区域时，显示动态扩展的覆盖范围
- **像素动画**：采用16色复古调色板，导弹序列以不同高度像素块排列，拦截路径用闪烁线条连接

---

3. **题解清单（4星以上）**

**1. hsfzLZH1（赞60）**  
- **亮点**：完整的三维偏序处理流程，树状数组清空优化，离散化实现
- **代码**：双CDQ分治处理正反向序列，离散化v值  
- **评分**：⭐⭐⭐⭐⭐

**2. shadowice1984（赞34）**  
- **亮点**：强调double存储方案数的重要性，代码简洁高效  
- **技巧**：通过反转序列复用CDQ逻辑，减少代码冗余  
- **评分**：⭐⭐⭐⭐⭐

**3. juju527（赞18）**  
- **亮点**：详细解释CDQ递归顺序对DP的影响，树状数组维护方案数的实现  
- **关键代码**：重载运算符处理最大值合并  
- **评分**：⭐⭐⭐⭐

---

4. **关键代码实现**

**CDQ分治核心片段**：
```cpp
void CDQ(int l, int r) {
    if(l == r) return;
    int mid = (l+r)/2;
    CDQ(l, mid); // 先处理左半区
    sort(a+l, a+mid+1, cmph); // 按高度排序左半区
    sort(a+mid+1, a+r+1, cmph); // 排序右半区
    
    // 双指针处理左右区间
    for(int i=l,j=mid+1; j<=r; j++){
        while(i<=mid && a[i].h >= a[j].h) {
            update_tree(a[i].v, f1[i], g1[i]); // 树状数组插入
            i++;
        }
        auto [max_f, sum_g] = query_tree(a[j].v);
        if(max_f+1 > f1[j]) {
            f1[j] = max_f+1;
            g1[j] = sum_g;
        } else if(max_f+1 == f1[j]) {
            g1[j] += sum_g;
        }
    }
    CDQ(mid+1, r); // 处理右半区
}
```

---

5. **同类题目推荐**
1. P1020 导弹拦截（二维LIS基础）
2. P3157 动态逆序对（三维偏序应用）
3. P3769 三维偏序（CDQ分治模板题）

---

**可视化示例（复古风格）**  
![CDQ分治动画示意图](https://i.imgur.com/8zK9WXy.gif)  
- **像素块颜色**：绿色表示已处理区间，红色表示当前操作节点
- **音效设计**：树状数组更新时播放8-bit电子音，找到更大值时触发上升音效

---
处理用时：72.64秒
# 题目信息

# [HNOI2015] 亚瑟王

## 题目描述

小 K 不慎被 LL 邪教洗脑了，洗脑程度深到他甚至想要从亚瑟王邪教中脱坑。他决定，在脱坑之前，最后再来打一盘亚瑟王。既然是最后一战，就一定要打得漂亮。众所周知，亚瑟王是一个看脸的游戏，技能的发动都是看概率的。

作为一个非洲人，同时作为一个前 OIer，小 K 自然是希望最大化造成伤害的期望值。但他已经多年没写过代码，连 Spaly都敲不对了，因此，希望你能帮帮小 K，让他感受一下当欧洲人是怎样的体验。

本题中我们将考虑游戏的一个简化版模型。 玩家有一套卡牌，共 $n$ 张。游戏时，玩家将 $n$ 张卡牌排列成某种顺序，排列后将卡牌按从前往后依次编号为 $1 -  n$。本题中，顺序已经确定，即为输入的顺序。每张卡牌都有一个技能。第 $i$ 张卡牌的技能发动概率为 $p_i$，如果成功发动，则会对敌方造成 $d_i$ 点伤害。也只有通过发动技能，卡牌才能对敌方造成伤害。基于现实因素以及小 K 非洲血统的考虑，$p_i$ 不会为 $0$，也不会为 $1$，即 $0 < p_i < 1$。 一局游戏一共有 $r$ 轮。在每一轮中，系统将从第一张卡牌开始，按照顺序依次考虑每张卡牌。在一轮中，对于依次考虑的每一张卡牌：

1. 如果这张卡牌在这一局游戏中已经发动过技能，则

1.1. 如果这张卡牌不是最后一张，则跳过之（考虑下一张卡牌）； 否则（是最后一张），结束这一轮游戏。

2. 否则（这张卡牌在这一局游戏中没有发动过技能），设这张卡牌为第 $i$ 张

2.1. 将其以 $p_i$ 的概率发动技能。

2.2. 如果技能发动，则对敌方造成 $d_i$ 点伤害，并结束这一轮。

2.3. 如果这张卡牌已经是最后一张（即 $i$ 等于 $n$），则结束这一轮；否则，考虑下一张卡牌。

请帮助小 K 求出这一套卡牌在一局游戏中能造成的伤害的期望值。


## 说明/提示

一共有 $13$ 种可能的情况：

1.  第一轮中，第 $1$ 张卡牌发动技能；第二轮中，第 $2$ 张卡牌发动技能；

概率为 $0.15$，伤害为 $5$。

2.  第一轮中，第 $1$ 张卡牌发动技能；第二轮中，第 $3$ 张卡牌发动技能；

概率为 $0.315$，伤害为 $3$。

3.  第一轮中，第 $1$ 张卡牌发动技能；第二轮不发动技能；

概率为 $0.035$，伤害为 $2$。

4.  第一轮中，第 $2$ 张卡牌发动技能；第二轮中，第 $1$ 张卡牌发动技能；

概率为 $0.075$，伤害为 $5$。

5.  第一轮中，第 $2$ 张卡牌发动技能；第二轮中，第 $3$ 张卡牌发动技能；

概率为 $0.0675$，伤害为 $4$。

6.  第一轮中，第 $2$ 张卡牌发动技能；第二轮不发动技能；

概率为 $0.0075$，伤害为 $3$。

7.  第一轮中，第 $3$ 张卡牌发动技能；第二轮中，第 $1$ 张卡牌发动技能；

概率为 $0.1575$，伤害为 $3$。

8.  第一轮中，第 $3$ 张卡牌发动技能；第二轮中，第 $2$ 张卡牌发动技能；

概率为 $0.04725$，伤害为 $4$。

9.  第一轮中，第 $3$ 张卡牌发动技能；第二轮不发动技能；

概率为 $0.11025$，伤害为 $1$。

10.  第一轮不发动技能；第二轮中，第 $1$ 张卡牌发动技能；

概率为 $0.0175$，伤害为 $2$。

11.  第一轮不发动技能；第二轮中，第 $2$ 张卡牌发动技能；

概率为 $0.00525$，伤害为 $3$。

12.  第一轮不发动技能；第二轮中，第 $3$ 张卡牌发动技能；

概率为 $0.011025$，伤害为 $1$。

13.  第一轮不发动技能；第二轮亦不发动技能；

概率为 $0.001225$，伤害为 $0$。

造成伤害的期望值为概率与对应伤害乘积之和，为 $3.266025$。


对于所有测试数据， $1 \leq T \leq 444， 1 \leq n \leq 220， 0 \leq r \leq 132， 0 < p_i < 1， 0 \leq d_i \leq 1000$。

除非备注中有特殊说明，数据中 $p_i$ 与 $d_i$ 均为随机生成。

请注意可能存在的实数精度问题，并采取适当措施。

本题使用 `special_judge`。

## 样例 #1

### 输入

```
1
3 2
0.5000 2
0.3000 3
0.9000 1```

### 输出

```
3.2660250000```

# AI分析结果



0. **题目翻译**

---

## [HNOI2015] 亚瑟王

### 题目描述

小 K 不慎被 LL 邪教洗脑，决定在脱坑前进行最后一战。游戏中的技能发动具有概率性，现需要计算一套卡牌在 r 轮游戏中造成的期望伤害。

玩家拥有 n 张卡牌，按输入顺序排列。每张卡牌 i 有发动概率 p_i（0 < p_i < 1）和伤害 d_i。每轮游戏从第一张卡牌开始依次检查：

1. 若卡牌已发动过则跳过
2. 若未发动过：
   - 以 p_i 概率发动并造成 d_i 伤害，结束本轮
   - 未发动则继续检查下一张卡牌

每张卡牌每局只能发动一次，求总伤害期望。

### 输入输出样例
（样例内容与原文一致，此处略）

---

1. **唯一算法分类**  
   **线性DP**

2. **综合分析与结论**  

#### ▍核心难点与解决思路
- **难点一**：技能发动后立即结束当前轮次，导致各轮之间存在强耦合关系
- **解决思路**：将 r 轮视为 r 次独立机会，通过概率期望的线性性质分解问题，计算每张卡牌在剩余机会中被选中的概率
- **关键方程**：
  ```math
  f[i][j] = f[i-1][j] × (1-p_i)^{r-j} + f[i-1][j-1] × (1-(1-p_i)^{r-j+1})
  ```
  表示前 i 张卡消耗 j 次机会的概率

#### ▍可视化设计要点
- **动画方案**：
  - 以网格形式展示 DP 矩阵 f[i][j]
  - 当前处理的卡牌 i 用黄色高亮边框
  - 转移箭头从 f[i-1][j] 和 f[i-1][j-1] 指向 f[i][j]
  - 概率数值以渐变颜色表示（深蓝→浅蓝表示低→高概率）
- **复古游戏化**：
  - 8-bit 音效：状态更新时播放 "blip" 音效，发动技能时播放 "explosion" 音效
  - 像素风格伤害数字：卡牌发动时弹出 8-bit 风格的伤害数值
  - 自动演示模式：AI 逐步展示从 f[0][0] 到 f[n][r] 的填充过程

---

3. **题解清单 (≥4星)**

| 作者          | 评分 | 核心亮点                                                                 |
|---------------|------|--------------------------------------------------------------------------|
| __stdcall     | ⭐⭐⭐⭐⭐ | 状态转移方程推导完整，预处理 (1-p_i) 的幂优化时间复杂度，代码可读性极佳 |
| Udumbara      | ⭐⭐⭐⭐  | 逆向 DP 设计新颖，提供与传统思路对比的独特视角                          |
| Morning_Glory | ⭐⭐⭐⭐  | 精简的状态定义与转移实现，代码量最少且包含详细注释                      |

---

4. **最优思路与代码实现**

#### ▍关键代码片段（__stdcall 实现）
```cpp
double p[N], d[N], f[N][R], pw[N][R];
// 预处理幂次优化
for (int i = 1; i <= n; ++i) {
    pw[i][0] = 1;
    for (int j = 1; j <= r; ++j)
        pw[i][j] = pw[i][j-1] * (1 - p[i]);
}

// 核心 DP 转移
for (int i = 1; i <= n; ++i) {
    for (int j = 0; j <= min(i, r); ++j) {
        if (j) f[i][j] += f[i-1][j-1] * (1 - pw[i][r-j+1]);
        if (i != j) f[i][j] += f[i-1][j] * pw[i][r-j];
    }
}

// 计算每张卡牌发动概率
for (int i = 1; i <= n; ++i) 
    for (int j = 0; j <= min(i-1, r); ++j)
        g[i] += f[i-1][j] * (1 - pw[i][r-j]);
```

---

5. **同类型拓展题目**

1. **P1850 换教室**  
   通过概率期望 DP 处理多个决策节点的最优选择

2. **P2473 奖励关**  
   状态压缩与期望计算的结合应用

3. **P4548 歌唱王国**  
   概率期望与生成函数的进阶结合

---

6. **可视化演示代码（精简像素版）**

```javascript
// Canvas 初始化
const canvas = document.getElementById('dp-grid');
const ctx = canvas.getContext('2d');
const CELL_SIZE = 40, GRID_COLOR = '#2c3e50';

// DP 动画核心逻辑
function drawDPStep(i, j) {
    // 绘制当前单元格渐变色
    const grad = ctx.createLinearGradient(...);
    grad.addColorStop(0, '#3498db'); 
    grad.addColorStop(1, '#2980b9');
    ctx.fillStyle = grad;
    ctx.fillRect(j*CELL_SIZE, i*CELL_SIZE, CELL_SIZE, CELL_SIZE);

    // 绘制转移箭头
    ctx.beginPath();
    ctx.moveTo((j-1)*CELL_SIZE+30, (i-1)*CELL_SIZE+30); 
    ctx.lineTo(j*CELL_SIZE+10, i*CELL_SIZE+10);
    ctx.strokeStyle = '#e74c3c';
    ctx.stroke();

    // 播放 8-bit 音效
    playSound('blip', 0.2);
}
```

---

7. **结语**  
本题展现了概率期望与线性 DP 的精妙结合，通过将轮次转化为独立机会的分配问题，成功化解了时序耦合的难点。其核心思想可推广至各类存在"机会消耗"机制的期望计算场景。

---
处理用时：72.61秒
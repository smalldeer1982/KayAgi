# 题目信息

# [HNOI2015] 落忆枫音

## 题目背景

「恒逸，你相信灵魂的存在吗？」 郭恒逸和姚枫茜漫步在枫音乡的街道上。望着漫天飞舞的红枫，枫茜突然问出这样一个问题。

「相信吧。不然我们是什么，一团肉吗？要不是有灵魂......我们也不可能再见到你姐姐吧。」 恒逸给出了一个略微无厘头的回答。枫茜听后笑了笑。 「那你仔细观察过枫叶吗？」 说罢，枫茜伸手，接住了一片飘落的枫叶。

「其实每一片枫叶都是有灵魂的。你看，枫叶上不是有这么多脉络吗？我听说，枫叶上有一些特殊的位置，就和人的穴位一样。脉络都是连接在这些穴位之间的。枫树的灵魂流过每片枫叶的根部，沿着这些脉络，慢慢漫进穴位，沁入整片枫叶。也是因为这个原因，脉络才都是单向的，灵魂可不能倒着溜回来呢。」 恒逸似懂非懂地点了点头。枫茜接着说了下去。

「正是因为有了灵魂，每片枫叶才会与众不同。也正是因为有了灵魂，每片枫叶也都神似其源本的枫树，就连脉络也形成了一棵树的样子。但如果仔细看的话，会发现，在脉络树之外，还存在其它的非常细的脉络。虽然这些脉络并不在树上，但他们的方向也同样顺着灵魂流淌的方向，绝不会出现可能使灵魂倒流的回路。」  恒逸好像突然想到了什么。 「那这些脉络岂不是可以取代已有的脉络，出现在脉络树上？」 枫茜闭上了眼睛。

「是啊，就是这样。脉络树并不是唯一的。只要有一些微小的偏差，脉络树就可能差之万里，哪怕是在这同一片枫叶上。就像我们的故事，结局也不是唯一的。只要改变一个小小的选项，故事流程可能就会被彻底扭转。」

「真是深奥啊......」 恒逸盯着这片红枫，若有所思地说。枫茜继续说道。

「还不止如此呢。所有的脉络都不会永恒存在，也不会永恒消失。不管是脉络树上的脉络，还是之外的细小脉络，都是如此。存在的脉络可能断开消失，消失的脉络也可能再次连接。万物皆处在永恒的变化之中，人与人之间的羁绊也是。或许有一天，我们与大家的羁绊也会如同脉络一样，被无情地斩断。或许我们也终将成为”枫音乡的过客“。或许这一切都会是必然，是枫树的灵魂所决定的......」

枫茜的眼角泛起了几滴晶莹剔透的泪珠。恒逸看着这样的枫茜，将她抱入怀中。

「别这样想，枫茜。就算脉络断开，也有可能还会有新的脉络树，也还会与枫树的根相连。这样的话，我们的羁绊仍然存在，只是稍微绕了一些远路而已。无论如何，我都不会离开你的。因为你是我穷尽一生所寻找的，我的真恋啊！」

两人的目光对上了。枫茜幸福地笑了，把头埋进了恒逸的怀抱。从远方山上的枫林中，传来了枫的声音。

## 题目描述

不妨假设枫叶上有 $n$ 个穴位，穴位的编号为 $1\sim n$。有若干条有向的脉络连接着这些穴位。

穴位和脉络组成一个有向无环图——称之为**脉络图**（例如图 $1$），穴位的编号使得穴位 $1$ 没有从其他穴位连向它的脉络，即穴位 $1$ 只有连出去的脉络；由上面的故事可知，这个有向无环图存在一个树形子图，它是以穴位 $1$ 为根的包含全部 $n$ 个穴位的一棵树——称之为**脉络树**（例如图 $2$ 和图 $3$ 给出的树都是图 $1$ 给出的脉络图的子图）。

值得注意的是，脉络图中的脉络树方案可能有多种可能性，例如图 $2$ 和图 $3$ 就是图 $1$ 给出的脉络图的两个脉络树方案。

 ![](https://cdn.luogu.com.cn/upload/pic/11330.png) 

脉络树的形式化定义为：以穴位 $r$ 为根的脉络树由枫叶上全部 $n$ 个穴位以及 $(n-1)$ 条脉络组成，脉络树里没有环，亦不存在从一个穴位连向自身的脉络，且对于枫叶上的每个穴位 $s$，都存在一条唯一的包含于脉络树内的脉络路径，使得从穴位 $r$ 出发沿着这条路径可以到达穴位  $s$。 

现在向脉络图添加一条与已有脉络不同的脉络（**注意：连接 $2$ 个穴位但方向不同的脉络是不同的脉络**，例如从穴位 $3$ 到 $4$ 的脉络与从 $4$ 到 $3$ 的脉络是不同的脉络，因此，图 $1$ 中不能添加从 $3$ 到 $4$ 的脉络，但可添加从 $4$ 到 $3$ 的脉络）。这条新脉络**可以是从一个穴位连向自身的**（例如，图 1 中可添加从 $4$ 到 $4$ 的脉络）。

原脉络图添加这条新脉络后得到的新脉络图可能会出现脉络构成的环。 请你求出添加了这一条脉络之后的新脉络图的以穴位 $1$ 为根的脉络树方案数。

由于方案可能有太多太多，请输出方案数对 $(10^9+7)$ 取模后得到的结果。

## 说明/提示

对于所有测试数据，保证：

- $1 \leq n \leq 100000$；
- $n - 1 \leq m \leq \min(200000, n(n -1)/2)$；
- $1 \leq x, y, u_i, v_i \leq n$。

Fixed by Starrykiller.

## 样例 #1

### 输入

```
4 4 4 3
1 2
1 3
2 4
3 2```

### 输出

```
3```

# AI分析结果



# [HNOI2015] 落忆枫音

## 题目描述

### 题目背景
（保持原故事背景，描述枫叶穴位与脉络图的设定，强调脉络树的唯一性变化与新增边的影响）

### 题目描述
给定包含 $n$ 个穴位和 $m$ 条有向脉络的DAG图，保证存在以穴位1为根的脉络树。现添加一条新脉络（允许自环），求新图中以1为根的脉络树方案数，结果对 $10^9+7$ 取模。

**输入格式**  
第一行四个整数 $n,m,x,y$，表示穴位数、原脉络数、新增边的起点和终点。  
接下来 $m$ 行每行两个整数描述原脉络。

**输出格式**  
一个整数表示答案。

**数据范围**  
$1 \leq n \leq 10^5$, $n-1 \leq m \leq 2 \times 10^5$

## 算法分类：线性DP

---

## 综合分析与结论

### 核心思路
1. **基础方案计算**  
   DAG的树形图方案数为各点入度乘积：$\prod_{i=2}^n in_i$

2. **环的影响处理**  
   新增边可能形成环，需用容斥原理减去非法方案。设新增边为 $(s,t)$，非法方案数通过DP计算从 $t$ 到 $s$ 的路径贡献。

3. **状态转移方程**  
   定义 $g[x]$ 表示从 $t$ 到 $x$ 的路径贡献值：  
   $$g(x) = \frac{1}{in_x} \sum_{(y→x) \in E} g(y)$$  
   初始条件 $g(t) = \frac{\prod in_i}{in_t}$

4. **最终答案**  
   $ans = \prod in_i - g(s)$

### 解决难点
- **逆元处理**：利用费马小定理进行模意义下的除法运算
- **拓扑序处理**：DAG的拓扑排序保证DP计算的正确性
- **记忆化优化**：对递归式DFS进行记忆化剪枝

---

## 四星题解精选（评分标准：思路清晰/代码简洁/优化显著）

### 1. litble（★★★★★）
**亮点**  
- 简洁的DFS记忆化实现
- 同步计算入度乘积与逆元
- 完整处理自环和根节点特判

**核心代码**  
```cpp
void dfs(int x) {
    if(vis[x]) return;
    vis[x] = 1;
    if(x==yy) {g[x]=1LL*dsum*ksm(du[x],mod-2)%mod; return;}
    for(int i=h[x];i;i=ne[i])
        dfs(to[i]), g[x] = (g[x]+g[to[i]])%mod;
    g[x] = 1LL*g[x]*ksm(du[x],mod-2)%mod;
}
```

### 2. HRLYB（★★★★☆）
**亮点**  
- 反向建图优化拓扑排序
- 详细数学公式推导
- 完整特判处理

**关键推导**  
$$\text{非法方案} = \sum_{\text{环路径P}} \frac{\prod in_i}{\prod_{v∈P} in_v}$$

### 3. leozhang（★★★★☆）
**亮点**  
- 显式拓扑排序实现
- 独立计算逆元数组
- 清晰的模块划分

**拓扑处理**  
```cpp
while(!q.empty()) {
    int u = q.front(); q.pop();
    dp[u] = dp[u] * inv[rinr[u]] % mod;
    for(int i=head[u];i!=-1;i=edge[i].next) {
        int v = edge[i].to;
        dp[v] = (dp[v] + dp[u]) % mod;
        if(--inr[v] == 0) q.push(v);
    }
}
```

---

## 最优技巧提炼

### 关键思路
- **乘积容斥法**：将合法方案分解为全集减非法集的经典容斥
- **路径贡献DP**：通过逆向建图/拓扑排序实现高效路径计算
- **逆元预处理**：批量计算逆元提升效率，避免重复计算

### 实现技巧
- **记忆化DFS**：适用于稀疏图的递归式处理
- **拓扑排序队列**：适用于稠密图的迭代解法
- **同步计算技巧**：在遍历时同步计算入度乘积与修改量

---

## 同类题目推荐
1. P3387 【模板】缩点（DAG性质应用）
2. P2146 [NOI2015] 软件包管理器（树形结构修改）
3. P4213 【模板】线性基（异或空间计数）

---

## 可视化设计（像素风格DP演示）

### 动画要素
1. **节点矩阵**：以16x16像素块表示每个节点，颜色深浅表示入度值
2. **路径高亮**：使用黄色光晕特效显示当前处理的DP路径
3. **数值气泡**：在节点上方显示实时计算的g值

### 交互设计
```javascript
// 伪代码示例
class DAGVisualizer {
    constructor(nodes) {
        this.canvas = document.createElement('canvas');
        this.nodes = nodes.map(n => new PixelNode(n));
    }
    
    drawFrame() {
        nodes.forEach(node => {
            drawPixel(node.x, node.y, getColor(node.in_degree));
            drawTextBubble(node.g_value); 
        });
        highlightPath(currentDPPath);
    }
    
    playSFX(type) {
        // 8-bit音效：转移成功/错误/完成
        const sfx = new ChipSFX(); 
        if(type === 'update') sfx.play(800, 0.2);
        if(type === 'error') sfx.play(200, 0.5);
    }
}
```

### 游戏化要素
- **连击计分**：连续正确转移获得2倍积分
- **成就系统**：完成拓扑序处理解锁"拓扑大师"成就
- **自动演示模式**：AI按照记忆化顺序自动遍历节点

---

## 核心代码实现

### 逆元预处理
```cpp
void init_inv() {
    inv[1] = 1;
    for(int i=2; i<=n; ++i) 
        inv[i] = (mod - mod/i) * inv[mod%i] % mod;
}
```

### 拓扑排序解法
```cpp
void topological_dp() {
    queue<int> q;
    for(int i=1; i<=n; ++i)
        if(!in_degree[i]) q.push(i);
        
    g[t] = total_product * inv[t] % mod;
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int v : reverse_graph[u]) {
            g[v] = (g[v] + g[u]) % mod;
            if(--in_degree[v] == 0) {
                g[v] = g[v] * inv[v] % mod;
                q.push(v);
            }
        }
    }
}
```

---

通过将数学推导与高效算法相结合，该问题展现了动态规划在图论计数问题中的典型应用模式。其核心思想可推广至各类需要排除非法方案的组合计数场景。

---
处理用时：88.24秒
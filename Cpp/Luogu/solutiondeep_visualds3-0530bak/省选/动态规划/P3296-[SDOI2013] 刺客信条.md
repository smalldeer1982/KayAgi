# 题目信息

# [SDOI2013] 刺客信条

## 题目描述

故事发生在1486 年的意大利，Ezio 原本只是一个文艺复兴时期的贵族，后来因为家族成员受到圣殿骑士的杀害，决心成为一名刺客。最终，凭借着他的努力和出众的天赋，成为了杰出的刺客大师，他不仅是个身手敏捷的武林高手，飞檐走壁擅长各种暗杀术。刺客组织在他的带领下，为被剥削的平民声张正义，赶跑了原本统治意大利的圣殿骑士首领-教皇亚历山大六世。在他的一生中，经历了无数次惊心动魄、扣人心弦的探险和刺杀。


曾经有一次，为了寻找Altair 留下的线索和装备，Ezio 在佛罗伦萨中的刺客墓穴进行探索。这个刺客墓穴中有许多密室，且任何两个密室之间只存在一条唯一的路径。这些密室里都有一个刺客标记，他可以启动或者关闭该刺客标记。为了打开储存着线索和装备的储藏室，Ezio 必须操作刺客标记来揭开古老的封印。要想解开这个封印，他需要通过改变某些刺客标记的启动情况，使得所有刺客标记与封印密码“看起来一样”。


在这里，“看起来一样”的定义是：存在一种“标记”密室与“密码”密室之间一一对应的关系，使得密室间的连接情况和启动情况相同（提示中有更详细解释）。幸运的是，在Ezio 来到刺客墓穴之前，在Da Vinci 的帮助下，Ezio 已经得知了打开储藏室所需要的密码。


而你的任务则是帮助Ezio 找出达成目标所需要最少的改动标记次数。


## 说明/提示

密室的编号是可以变的！将第三个密室关闭后，在当前标记和密码之间，存在1->4,2->3,3->2,4->1 的对应关系，重新编号后连接情况没有改变，且标记与密码对应。对于更一般的情况，存在一个1 到n 的置换P，使得对于任意密室之间的道路u-v，都一定有密码密室中的道路P(u)-P(v)；如果不存在密室之间的道路u-v，则一定没有密码密室中的道路P(u)-P(v)。


对于100%的数据，n<=700，且每个密室至多与11个密室相通


## 样例 #1

### 输入

```
4
1 2
2 3
3 4
0 0 1 1
1 0 0 0```

### 输出

```
1```

# AI分析结果



0. **题目翻译**

# [SDOI2013] 刺客信条

## 题目描述

故事发生在1486年的意大利，艾吉奥原本是文艺复兴时期的贵族，因家族成员被圣殿骑士杀害而成为刺客大师。在探索刺客墓穴时，他需要操作密室标记使得所有标记与密码"看起来相同"。

**题目要求**：给定n个密室构成的树结构（每个密室有0/1标记），通过改变标记使当前树与目标树同构，求最小修改次数。

## 输入输出样例

输入：
```
4
1 2
2 3
3 4
0 0 1 1
1 0 0 0
```
输出：
```
1
```

---

1. **唯一算法分类**  
树形动态规划（树形DP）

---

2. **综合分析与结论**

### 核心思路
1. **重心处理**：将无根树转化为以重心为根的有根树（双重心时构造虚根）
2. **树哈希**：通过哈希值判断子树同构
3. **动态规划**：定义`f[x][y]`表示x子树与y子树同构的最小代价
4. **二分图匹配**：用KM算法/费用流处理子树匹配问题

### 关键难点与解决方案
| 难点 | 解决方案 |
|-----|---------|
| 树同构判定 | 深度优先哈希（排序子节点哈希值后组合） |
| 子树匹配优化 | KM算法解决带权二分图匹配问题 |
| 状态转移方程 | `f[x][y] = KM匹配子节点代价 + (a[x] != b[y])` |

### 可视化设计
**动态规划矩阵动画**：
- 8-bit像素风格展示树结构，每个节点用不同颜色方块表示
- 当前处理的`f[x][y]`单元格高亮闪烁（红色边框）
- 子节点匹配时显示KM算法的边权矩阵（蓝色表示可行匹配，绿色表示最优解）
- 音效提示：哈希计算时播放"哔"声，状态更新时播放"叮"声，最优解发现时播放胜利音效

**交互功能**：
- 步进控制：空格键单步执行DP过程
- 速度调节：方向键控制动画速度
- 自动演示模式：AI自动完成所有状态转移

---

3. **题解清单 (≥4星)**

### ① xyz32768（★★★★☆）
- **亮点**：完整实现重心处理+哈希+KM算法，代码结构清晰
- **核心代码**：
```cpp
void calcHash(int u, int fu) {
    has[u] = 14221; 
    // 递归计算子树哈希值并排序
    sort(orz + 1, orz + tot + 1);
    // 组合哈希值...
}
int DP() {
    // KM算法求解最小匹配
    km.solve() + (st[u] != ed[v]);
}
```

### ② Corycle（★★★★☆）
- **亮点**：详细注释+图示解释匹配过程
- **个人心得**："KM算法求最小权需将边权取反"

### ③ liugh_（★★★★☆）
- **亮点**：采用费用流替代KM算法，增加动态换根优化
- **核心优化**：`xorshift`哈希增强抗冲突能力

---

4. **核心代码实现**

### 树哈希计算
```cpp
void calcHash(int u) {
    vector<ll> child_hash;
    for (auto v : G[u]) 
        if (v != fa[u]) {
            calcHash(v);
            child_hash.push_back(hash[v]);
        }
    sort(child_hash.begin(), child_hash.end());
    hash[u] = 2019;
    for (auto h : child_hash)
        hash[u] = (hash[u] * 5579 + h) % 152383;
}
```

### KM算法核心
```cpp
int KM(vector<pair<int, int>>& edges) {
    // 初始化顶标
    for (int i=1; i<=n; i++) 
        wx[i] = *max_element(dis[i]+1, dis[i]+n+1);
    
    while (匈牙利寻找增广路失败) {
        // 更新顶标
        for (int j=1; j<=n; j++)
            if (!vy[j]) minn = min(minn, sla[j]);
        // 调整顶标值...
    }
    return 总匹配权值;
}
```

---

5. **相似题目推荐**
1. P5043 【模板】树同构
2. P4320 道路相遇（树哈希应用）
3. P1273 有线电视网（树形DP+费用匹配）

---

6. **可视化示例代码（JS伪代码）**
```javascript
class DPDemo {
    constructor(canvas) {
        this.grid = new PixelGrid(canvas, 800, 600); 
        this.treeView = new TreeRenderer(this.grid);
    }

    renderStep(u, v) {
        this.treeView.highlightNode(u, 'red');
        this.treeView.highlightNode(v, 'blue');
        this.grid.drawMatrix(f, (i,j) => { // 绘制DP矩阵
            return i==u && j==v ? 'gold' : 'white';
        });
        playSound('step');
    }
}
```

---
处理用时：68.08秒
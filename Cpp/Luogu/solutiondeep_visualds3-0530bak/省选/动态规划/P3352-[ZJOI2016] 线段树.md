# 题目信息

# [ZJOI2016] 线段树

## 题目描述

小 Yuuka 遇到了一个题目：有一个序列 $a_1,a_2,\ldots,a_n$，$q$ 次操作。每次操作把一个区间内的数改成区间内的最大值，问最后每个数是多少。小 Yuuka 很快地就使用了线段树解决了这个问题。

于是充满智慧的小 Yuuka 想，如果操作是随机的，即在这 $q$ 次操作中每次等概率随机地选择一个区间 $[l,r]$（$1 \leq l \leq r \leq n$），然后将这个区间内的数改成区间内最大值（注意这样的区间共有 $\frac{n(n+1)}{2}$ 个），最后每个数的期望大小是多少呢？

小 Yuuka 非常热爱随机，所以她给出的输入序列也是随机的（随机方式见数据规模和约定）。

对于每个数，输出它的期望乘 $\left(\frac{n(n+1)}{2} \right)^q$ 再对 $10^9+7$ 取模的值。


## 说明/提示

对于所有的测试数据，保证序列中数的大小不超过 $10^9$，并且每个数是 $0$ 到 $10^9$ 之间的随机整数。

|测试点编号|$n$|$q$|
|:-:|:-:|:-:|
|1|$\leq 5$|$\leq 5$|
|2|$\leq 8$|$\leq 400$|
|3|$\leq 12$|$\leq 400$|
|4|$\leq 30$|$\leq 400$|
|5|$\leq 50$|$\leq 400$|
|6|$\leq 100$|$\leq 400$|
|7|$\leq 100$|$\leq 400$|
|8|$\leq 400$|$\leq 400$|
|9|$\leq 400$|$\leq 400$|
|10|$\leq 400$|$\leq 400$|


## 样例 #1

### 输入

```
5 5
1 5 2 3 4
```

### 输出

```
3152671 3796875 3692207 3623487 3515626
```

# AI分析结果



0. **题目翻译**  
# [ZJOI2016] 线段树

## 题目描述

小 Yuuka 遇到了一个题目：有一个序列 $a_1,a_2,\ldots,a_n$，进行 $q$ 次操作。每次操作随机选择一个区间 $[l,r]$，将该区间内的数改为区间最大值。要求计算最终每个数的期望值乘以所有可能操作数的模 $10^9+7$ 结果。

## 输入格式

第一行两个整数 $n,q$，第二行给出初始序列。数据保证序列随机生成，每个数在 $[0,10^9]$ 范围内。

## 输出格式

输出 $n$ 个整数，表示每个位置的答案模 $10^9+7$ 的值。

---

1. **唯一算法分类**  
线性DP

---

2. **综合分析与结论**  
**核心思路**：  
将最终每个位置的值转化为多个阈值条件的期望叠加，通过动态规划维护区间状态。关键设计三维状态 $dp_{轮数,l,r}$ 表示当前轮次下，区间 $[l,r]$ 的贡献值（已乘权值差），利用前缀和优化转移。

**状态转移方程**：  
$$
dp_{i,l,r} = dp_{i-1,l,r} \times g(l,r) + \sum_{j<l} dp_{i-1,j,r} \times (j-1) + \sum_{j>r} dp_{i-1,l,j} \times (n-j)
$$  
其中 $g(l,r)$ 表示不影响当前区间的操作数。

**解决难点**：  
- 将无限值域问题转化为离散阈值叠加  
- 通过合并权值差将四维状态压缩至三维  
- 前缀和数组优化区间求和复杂度

**可视化设计要点**：  
- 使用二维网格表示区间 $[l,r]$ 的 DP 值，颜色渐变表示数值大小  
- 步进展示每个轮次的状态更新，高亮当前被更新的区间  
- 复古像素风格：  
  - 16色调色板（深蓝→浅蓝表示数值递增）  
  - 每次转移时触发8-bit音效（不同操作类型对应不同音高）  
  - Canvas绘制动态网格，自动演示模式下以0.5秒/步的速度推进

---

3. **题解清单 (≥4星)**  
① **i207M（5星）**  
- 创新性地合并权值差贡献，将四维DP优化为三维  
- 使用滚动数组和前缀和数组大幅优化空间和时间  
- 代码结构清晰，关键注释完整  

② **Kubic（4.5星）**  
- 巧妙转化为01序列问题，揭示问题本质特征  
- 通过极长连续段分析简化状态转移逻辑  
- 离散化处理结合整体DP实现复杂度突破  

④ **Sol1（4星）**  
- 独创性地使用二维前缀和矩阵加速区间求和  
- 提出将多次DP合并为单次DP的核心思想  
- 实现时采用位运算优化状态切换  

---

4. **最优思路与代码实现**  
**核心代码片段**（i207M题解）：
```cpp
// 初始化关键状态
for(ri l=1; l<=n; ++l) {
    int mx=a[l];
    for(ri r=l; r<=n; ++r) {
        ckmax(mx,a[r]);
        if(mx<min(a[l-1],a[r+1]))
            dp[cur][l][r] = (mx - min(a[l-1],a[r+1]))%md;
        g[l][r] = C2(l-1) + C2(r-l+1) + C2(n-r);
    }
}

// 滚动数组转移
swap(cur,pre);
for(ri l=1; l<=n; ++l)
    for(ri r=l; r<=n; ++r)
        dp[cur][l][r] = add(
            mul(dp[pre][l][r],g[l][r]),
            sdp[pre][l-1][r], 
            tdp[pre][l][r+1]
        );
```

**实现思想**：  
- 预处理每个区间的初始贡献值（最大值与边界值的差）  
- 使用前缀和数组sdp维护左扩展贡献，tdp维护右扩展贡献  
- 通过滚动数组将空间复杂度优化至O(n²)

---

5. **相似题目推荐**  
- P5569 [SDOI2008] 线段树  
- P4218 带修改区间最值操作  
- P1972 动态最大子段和

---

6. **可视化伪代码（Canvas+Web Audio）**  
```javascript
// 初始化像素网格
const grid = new PixelGrid(n, n, {
    cellSize: 20,
    colors: ['#1a1c2c', '#7dc383' /*...16色*/]
});

// 音效触发器
function playSound(type) {
    const freq = type === 'transfer' ? 440 : 220;
    osc = audioCtx.createOscillator();
    osc.frequency.value = freq;
    osc.start(); osc.stop(0.05);
}

// DP动画驱动
function animateStep(step) {
    grid.highlightCells(l, r, {color: '#ff0000'}); // 当前更新区间
    for(let l=1; l<=n; ++l) {
        for(let r=l; r<=n; ++r) {
            const newVal = computeNewValue(step, l, r);
            grid.updateCell(l, r, getColor(newVal));
            playSound('transfer');
        }
    }
    grid.drawBorder(step % 2 === 0 ? 'left' : 'right'); // 区分滚动数组状态
}
```

---

7. **总结与提升**  
**关键突破点**：将看似需要枚举每个权值的四维DP，通过贡献叠加转化为三维DP。这一思路在带有随机操作的最值覆盖问题中具有普适性。  

**举一反三**：当遇到"操作后最值保留"类问题时，可尝试：  
1. 离散化权值并转化为阈值问题  
2. 设计区间状态表示最后保留的极值区间  
3. 使用前缀和/滚动数组优化高维状态  

**调试心得**（摘录自题解）：  
_"发现直接计算每个值的方案会TLE，将权值差提前乘入DP状态后，复杂度神奇地从O(n³q)降为O(n²q)"_ —— i207M

---
处理用时：89.57秒
# 题目信息

# SAC#1 - 萌数

## 题目背景

本题由世界上最蒟蒻的 SOL 提供。

寂月城网站是完美信息教室的官网。地址：<http://191.101.11.174/mgzd>。


## 题目描述

蒟蒻 SOL 居然觉得数很萌！

好在在他眼里，并不是所有数都是萌的。只有满足“存在长度至少为 $2$ 的回文子串”的数是萌的——也就是说，$101$ 是萌的，因为 $101$ 本身就是一个回文数；$110$ 是萌的，因为包含回文子串 $11$；但是 $102$ 不是萌的，$1201$ 也不是萌的。

现在 SOL 想知道从 $l$ 到 $r$ 的所有整数中有多少个萌数。

由于答案可能很大，所以只需要输出答案对 $1000000007$（$10^9+7$）的余数。

## 说明/提示

记 $n$ 为 $r$ 在 $10$ 进制下的位数。

对于 $10\%$ 的数据，$n \le 3$。

对于 $30\%$ 的数据，$n \le 6$。

对于 $60\%$ 的数据，$n \le 9$。

对于全部的数据，$n \le 1000$，$l < r$。


------------

2024/2/4 添加一组 hack 数据。

## 样例 #1

### 输入

```
1 100```

### 输出

```
10```

## 样例 #2

### 输入

```
100 1000```

### 输出

```
253```

# AI分析结果



---

### 题目重写

# SAC#1 - 萌数

## 题目背景

本题由世界上最蒟蒻的 SOL 提供。

寂月城网站是完美信息教室的官网。地址：<http://191.10111.174/mgzd>。

## 题目描述

蒟蒻 SOL 认为数很萌！但只有满足"存在长度≥2的回文子串"的数是萌数。例如：
- 101 是萌数（本身是回文）
- 110 是萌数（包含11）
- 102 不是萌数
- 1201 不是萌数

请计算区间 [l,r] 中萌数的数量，答案模 1e9+7。

## 数据范围
- 对于 100% 数据，n ≤ 1000（r 的位数）

---

### 唯一算法分类
**线性DP（数位动态规划）**

---

### 综合分析与结论

#### 核心思路
采用数位DP的正难则反策略，计算非萌数数量后取补集。关键点在于判断是否存在相邻两位相同（aa型）或隔一位相同（aba型）的回文子串。

#### 状态转移方程设计
典型状态设计：`dp[pos][pre1][pre2][exist]`，其中：
- `pos`：当前处理位
- `pre1`：前一位数字
- `pre2`：前两位数字
- `exist`：是否已存在回文子串

状态转移时，若当前位数字与 `pre1` 或 `pre2` 相同则触发回文标记。

#### 可视化设计思路
1. **网格动画**：将数位DP过程绘制为纵向数位网格，用不同颜色标注当前处理位、前两位数字。
2. **回文检测高亮**：当当前位与前两位中的任意一位相等时，触发红色闪烁动画。
3. **状态追踪面板**：实时显示当前状态四元组和转移路径。

#### 复古像素化实现
- **8-bit 风格**：使用16色复古调色板（如 #6B8CFF 表示活跃位，#FF6B6B 表示回文触发）
- **音效设计**：
  - 滴答声：每次数位切换
  - 铜管音效：发现回文子串
  - 电子音效：完成最终计算
- **自动演示模式**：AI自动选择数字路径，展示典型用例（如110→触发11检测）

---

### 题解清单（≥4星）

#### 1. George1123（★★★★☆）
**亮点**：
- 引入前导零标记 `lead` 精确处理前缀零
- 状态压缩：`pre2=10` 表示无效位，避免数组越界
- 完整处理了奇偶回文检测

#### 2. AlanSP（★★★★☆）
**亮点**：
- 递推式预处理非萌数，大幅优化时间复杂度
- 创新性使用三维状态 `f[i][j][k]` 表示i位数最后两位为j,k的非萌数
- 高精度减1处理优雅

#### 3. ChenJr（★★★★☆）
**亮点**：
- 五维状态设计包含可用性标记
- 代码结构清晰，模块化程度高
- 详细注释关键转移逻辑

---

### 最优思路提炼

#### 关键技巧
```cpp
// 状态转移核心逻辑
if((current == pre1 && pre1_valid) || 
   (current == pre2 && pre2_valid)){
    exist = true;
}
```

#### 实现片段
```cpp
// George1123 题解核心代码
lng Dfs(int w,int d,int ld,bool free,bool hw){
    if(!w) return hw;
    if(free&&~f[w][d][ld][hw]) return f[w][d][ld][hw];
    int up=free?9:nl[w];
    lng res=0;
    for(int i=0;i<=up;i++)
        (res+=Dfs(w-1,i,d,free||i<up,hw||i==d||i==ld))%=mod;
    if(free) f[w][d][ld][hw]=res;
    return res;
}
```

---

### 同类型题目推荐
1. **P2657 [SCOI2009] windy数**（数位DP基础）
2. **P4127 [AHOI2009] 同类分布**（数位DP+模数处理）
3. **P3281 [SCOI2013]数数**（多维度数位处理）

---

### 个人心得摘录
> "调试时发现前导零标记传递错误，导致将000121误判为萌数。最终通过添加 `lead` 标记和 `valid` 状态解决。" —— George1123

> "预处理非萌数时，三维数组的第一维应该表示位数而非当前位置，这个认知错误导致WA了3次" —— AlanSP

---

### 可视化设计实现

#### HTML/JS 核心片段
```html
<canvas id="dpCanvas" width="800" height="600"></canvas>
<script>
class DigitViz {
    constructor() {
        this.colors = ["#2E3440","#3B4252","#434C5E","#4C566A", // 深色系
                      "#D8DEE9","#E5E9F0","#ECEFF4","#8FBCBB"];
        this.ctx = document.getElementById('dpCanvas').getContext('2d');
    }
    
    drawDigit(pos, num, hl=false) {
        // 绘制8-bit风格数字方块
        this.ctx.fillStyle = hl ? "#BF616A" : this.colors[4];
        this.ctx.fillRect(pos*50, 0, 45, 45);
        // 绘制数字...
    }
    
    animateTransfer(pos, pre1, pre2) {
        // 显示状态转移箭头动画
    }
}
</script>
```

#### 音效触发器
```javascript
function playSound(type) {
    const sfx = {
        digit: new Audio('data:audio/wav;base64,UklGRl9...'), 
        palindrome: new Audio('data:audio/wav;base64,UklGRk9...')
    };
    sfx[type].play();
}
```

---

### 经典题解代码（George1123版）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long lng;
const int mod=1e9+7;
char L[1010],R[1010];
int nl[1010];
lng f[1010][11][11][2]; // 状态记忆数组

lng Dfs(int w,int d,int ld,bool free,bool hw){
    if(!w) return hw;
    if(free&&~f[w][d][ld][hw]) return f[w][d][ld][hw];
    int up=free?9:nl[w];
    lng res=0;
    for(int i=0;i<=up;i++)
        (res+=Dfs(w-1,i,d,free||i<up,hw||i==d||i==ld))%=mod;
    if(free) f[w][d][ld][hw]=res;
    return res;
}

lng DP(char* n,lng a){
    int p=strlen(n+1);
    for(int i=1;i<=p;i++) nl[i]=n[p+1-i]-'0';
    nl[1]+=a;
    // 高精度减1处理...
    memset(f,-1,sizeof f);
    lng res=0;
    // 处理不同位数的情况
    return res;
}

int main(){
    scanf("%s %s",L+1,R+1);
    printf("%lld\n",(DP(R,0)-DP(L,-1)+mod)%mod);
    return 0;
}
```

---
处理用时：87.38秒
# 题目信息

# [BJOI2017] 喷式水战改

## 题目背景

拿到了飞机的驾照(?)，这样补给就不愁了

XXXX年XX月XX日

拿到了喷气机(??)的驾照，这样就飞得更快了

XXXX年XX月XX日

拿到了攻击机(???)的驾照（不存在的）

XXXX年XX月XX日

用铅版做夹层的话，机身可是会变重的呢

XXXX年XX月XX日

幸酱的特制快递，精确投递到了目标地点

-------------------------------------

又是核平的一天。

天音正在给喷气机做保养，并充填燃料。

这种喷气机是某姬(?????)特别制作的，发动机拥有三种工作状态

1、通常型（Original）：在高空平飞或隐蔽飞行时进行的低功耗高效率工作状态

2、后期型（Extended）：为在俯冲时最大化能量利用率而特别改造过的工作状态

3、增强型（Enhanced）：在俯冲攻击结束后为产生极限扭力抬高高度的工作状态

在一次攻击中，喷气机将会经历"通常-后期-增强-通常"的工作流程

不同工作状态中，燃料的利用效率是不同的

现在天音正在调整喷气机燃料装填序列

你需要做的就是求出燃料能产生的最大总能量

为什么是你？

和平还是核平，选一个吧


## 题目描述

初始燃料序列为空。每次操作会向序列中的 $p _ i$ 位置添加 $x _ i$ 单位的同种燃料，该燃料每一单位在三种工作状态下能产生的能量分别为 $a _ i, b _ i, c _ i$。

添加的位置 $p _ i$ 是指，在添加后，加入的第一个单位燃料前面有 $p _ i$ 个单位的原燃料。

全部的 $x _ i$ 单位燃料依次放置，然后原来在 $p _ i$ 位置的燃料（如果有的话）依次向后排列。

对于一个确定的燃料序列，其能产生的最大总能量为：将序列依次分成"通常-后期-增强-通常"四段（每段可以为空），每一段在对应工作状态下产生的能量之和的最大值。

对于每次添加操作，你需要给出该次操作使得最大总能量增加了多少。

如果对于这种计算方式没有直观的感受，可以查看样例说明。


## 说明/提示

第一次操作后，燃料序列为[1 1]，最大能量发生方式为[En1 En1]，共46+46=92。

第二次操作后，燃料序列为[1 2 2 2 1]，最大能量发生方式为[Or1 Or2 Or2 Or2 En1]，共25+32+32+32+46=167，增加了167-92=75。

第三次操作后，燃料序列为[1 2 2 3 3 3 2 1]，最大能量发生方式为[Or1 Or2 Or2 Or3 Or3 Or3 Or3 Or2 En1]，增加了99\*4=396。

第四次操作后，燃料序列为[1 2 4 4 4 4 4 2 3 3 3 2 1]

最大能量发生方式为[Or1 Or2 Ex4 Ex4 Ex4 Ex4 Ex4 Or2 Or3 Or3 Or3 Or3 Or2 Or1]。

第五次操作后，燃料序列为[1 2 4 4 4 4 4 2 3 3 3 2 1 5 5 5 5 5 5]

最大能量发生方式为[Or1 Or2 Ex4 Ex4 Ex4 Ex4 Ex4 Or2 Or3 Or3 Or3 Or3 Or2 Or1 Or5 Or5 Or5 Or5 Or5 Or5]。


对于 $100\%$ 的数据，$1 \leq n \leq 10^5$, $1 \leq a_i, b_i, c_i \leq 10^4$， $1 \leq x_i \leq 10^9$。

对于 $100\%$ 的数据，保证插入时序列中至少已有 $p _ i$ 单位的燃料。

后 $50\%$ 数据有梯度。


## 样例 #1

### 输入

```
5
0 25 37 46 2
1 32 14 16 3
3 99 77 88 4
2 43 68 57 5
14 72 36 18 6
```

### 输出

```
92
75
396
319
432```

# AI分析结果



0. **题目翻译**  
# [BJOI2017] 喷式水战改

## 题目背景

获得了飞行驾照（？），补给无忧  
XXXX年XX月XX日  

获得了喷气机（？？）驾照，速度更快  
XXXX年XX月XX日  

获得了攻击机（？？？）驾照（不存在）  
XXXX年XX月XX日  

铅板夹层会让机身变重  
XXXX年XX月XX日  

特制快递精准投递到目标点  

---

又是核平的一天。  
天音正在给喷气机做保养并充填燃料。这种喷气机有三种工作模式：  
1. 通常型（Original）：高空平飞或隐蔽飞行时的低功耗模式  
2. 后期型（Extended）：俯冲时最大化能量利用率的改造模式  
3. 增强型（Enhanced）：俯冲后产生极限扭力的抬升模式  

攻击流程为"通常-后期-增强-通常"。不同模式下燃料效率不同。需要计算每次插入燃料后的最大总能量增量。

## 题目描述

初始燃料序列为空。每次操作在位置$p_i$插入$x_i$单位燃料，每个单位的三种模式能量为$a_i,b_i,c_i$。插入后原位置后的燃料后移。每次操作需输出当前序列能产生的最大总能量与上次的差值。

---

1. **算法分类**  
线性DP + 平衡树维护动态DP状态

---

2. **综合分析与结论**  
**核心思路**：  
- 将连续相同参数的燃料视为块，用平衡树维护块序列  
- 每个块维护状态转移矩阵：$dp_{i,j}$表示该块燃料从模式$i$开始到模式$j$结束的最大能量  
- 插入时动态拆分合并块，通过平衡树的合并操作更新全局DP状态  

**解决难点**：  
- **动态维护状态**：每次插入可能分割已有块，需重新计算分割后的状态转移矩阵  
- **高效合并**：利用平衡树的合并特性，结合矩阵乘法的结合律快速更新全局状态  

**可视化设计**：  
- **像素风格网格**：用Canvas绘制平衡树节点，每个节点显示其DP矩阵的四个状态  
- **高亮转移路径**：当合并两个节点时，用不同颜色标记矩阵乘法中的$max$操作路径  
- **音效反馈**：状态更新时播放8bit音效，矩阵合并成功时播放上升音阶  

---

3. **题解清单（≥4星）**  
- **devout（★★★★☆）**  
  亮点：ODT式块合并 + 显式状态转移方程，代码简洁（95行）  
  关键代码：  
  ```cpp
  void update(int x){
    memset(f[x],0,sizeof(f[x]));
    Rep(i,0,3) Rep(j,i,3) Rep(k,j,3)
      f[x][i][k] = max(f[x][i][k], f[lc][i][j]+val[x][j]*len[x]+f[rc][j][k]);
  }
  ```
  
- **feecle6418（★★★★☆）**  
  亮点：矩阵乘法形式化动态DP，数学表达清晰  
  转移矩阵：  
  $$\begin{bmatrix}
  a & b & c & a \\
  -\infty & b & c & a \\
  -\infty & -\infty & c & a \\
  -\infty & -\infty & -\infty & a 
  \end{bmatrix}$$
  
- **dengyaotriangle（★★★★★）**  
  亮点：自定义矩阵运算符实现状态合并，代码高度抽象化  
  核心逻辑：
  ```cpp
  matrix operator*(const matrix &a)const{
    matrix res;
    for(int i=0;i<4;i++) for(int j=i;j<4;j++)
      for(int k=i;k<=j;k++) // 关键三重循环
        res.v[i][j] = max(res.v[i][j], v[i][k]+a.v[k][j]);
    return res;
  }
  ```

---

4. **最优思路提炼**  
**关键技巧**：  
- **状态压缩**：将四阶段转移编码为4x4矩阵，利用矩阵乘法实现状态合并  
- **块式存储**：将连续相同燃料合并为块，使时间复杂度与操作次数而非燃料量相关  
- **平衡树分裂策略**：按逻辑长度而非物理节点数分裂，保证动态DP的正确性  

**思维突破点**：  
- 发现四阶段转移的偏序性质（i ≤ j ≤ k），将$O(n)$DP转化为$O(1)$块合并  
- 将燃料插入视为矩阵插入，利用平衡树维护矩阵序列的积  

---

5. **同类型题推荐**  
1. P5491 【模板】动态DP（强化动态DP理解）  
2. P6139 【模板】文艺平衡树（平衡树操作练习）  
3. P4719 【模板】动态树分治（动态维护树形DP）

---

6. **可视化方案**  
**Canvas动画设计**：  
1. **网格绘制**：每个块显示为4x4网格，单元格颜色深浅表示能量值大小  
2. **合并动画**：当两个块合并时，显示矩阵乘法过程，用流动光效表示max操作  
3. **历史轨迹**：保留前三次操作的矩阵状态，用半透明方式叠加显示  

**音效设计**：  
- 块分裂：短促"滴"声  
- 矩阵合并：连续上升音阶  
- 错误操作：低沉嗡鸣声  

**游戏化要素**：  
- 连击积分：连续正确操作获得combo奖励  
- 能量槽：用像素风格进度条显示当前最大能量值  
- 成就系统：首次使用三种不同分裂策略时解锁成就图标  

---

```javascript
// 示例：矩阵合并动画核心逻辑
class DPVisualizer {
  constructor(canvas) {
    this.ctx = canvas.getContext('2d');
    this.nodes = []; // 平衡树节点数据
  }

  drawMatrix(node, x, y) {
    for(let i=0; i<4; i++) {
      for(let j=i; j<4; j++) {
        const val = node.matrix[i][j];
        const color = `hsl(${240 - val%100}, 70%, 60%)`; // 色相映射能量值
        this.ctx.fillStyle = color;
        this.ctx.fillRect(x + j*30, y + i*30, 28, 28);
      }
    }
  }

  animateMerge(node1, node2) {
    let t = 0;
    const animate = () => {
      t += 0.1;
      // 绘制合并过程的插值动画
      this.drawMatrix(node1, 50 + t*50, 100);
      this.drawMatrix(node2, 250 - t*50, 100);
      if(t < 1) requestAnimationFrame(animate);
      else this.drawResult(mergeMatrices(node1, node2));
    };
    animate();
  }
}
```

---
处理用时：105.07秒
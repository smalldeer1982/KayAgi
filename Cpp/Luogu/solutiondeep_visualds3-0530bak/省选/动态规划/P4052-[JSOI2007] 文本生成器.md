# 题目信息

# [JSOI2007] 文本生成器

## 题目描述

JSOI 交给队员 ZYX 一个任务，编制一个称之为“文本生成器”的电脑软件：该软件的使用者是一些低幼人群，他们现在使用的是 GW 文本生成器 v6 版。

该软件可以随机生成一些文章——总是生成一篇长度固定且完全随机的文章。 也就是说，生成的文章中每个字符都是完全随机的。如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章 $s$ 包含单词 $t$，当且仅当单词 $t$ 是文章 $s$ 的子串）。但是，即使按照这样的标准，使用者现在使用的 GW 文本生成器 v6 版所生成的文章也是几乎完全不可读的。ZYX 需要指出 GW 文本生成器 v6 生成的所有文本中，可读文本的数量，以便能够成功获得 v7 更新版。你能帮助他吗？

答案对 $10^4 + 7$ 取模。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq n \leq 60$，$1 \leq m \leq 100$。
- $1 \leq |s_i| \leq 100$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。
- $s_i$ 中只含大写英文字母。

## 样例 #1

### 输入

```
2 2
A
B
```

### 输出

```
100```

# AI分析结果



# 题目重写

# [JSOI2007] 文本生成器

## 题目描述

JSOI 交给队员 ZYX 一个任务，编制一个称为"文本生成器"的电脑软件：该软件的使用者是一些低幼人群，他们现在使用的是 GW 文本生成器 v6 版。

该软件可以随机生成一些文章——总是生成一篇长度固定且完全随机的文章。也就是说，生成的文章中每个字符都是完全随机的。如果一篇文章中至少包含使用者们了解的一个单词，那么我们称这篇文章是可读的（我们称文章 s 包含单词 t，当且仅当单词 t 是文章 s 的子串）。即使按照这样的标准，使用者现在使用的 GW 文本生成器 v6 版生成的文章也几乎完全不可读。ZYX 需要计算 GW 文本生成器 v6 生成的所有文本中可读文本的数量，以便能够成功获得 v7 更新版。你能帮助他吗？

答案对 10^4 + 7 取模。

## 输入格式

第一行包含两个正整数 n 和 m，表示已知的单词数量和生成文本长度。

接下来 n 行，每行一个仅由大写字母组成的字符串。

## 输出格式

一个整数，表示可读文本的数量。

## 样例 #1

### 输入
```
2 2
A
B
```

### 输出
```
100
```

## 数据范围
- 1 ≤ n ≤ 60
- 1 ≤ m ≤ 100
- 每个单词长度 ≤ 100

# 算法分类
线性DP

# 综合分析与结论

## 核心思路
1. **容斥原理**：总方案数 26^m 减去不包含任何已知单词的方案数
2. **AC自动机构建**：建立所有单词的 trie 树并处理 fail 指针
3. **危险节点标记**：通过 fail 链传播标记，确保若某节点的任意 fail 链前驱是单词结尾则标记为危险节点
4. **动态规划**：
   - 状态定义：dp[i][j] 表示长度为 i 且处于 AC 自动机节点 j 时的合法路径数
   - 转移方程：dp[i+1][child] += dp[i][j] (当 child 不是危险节点时)
5. **最终计算**：Σdp[m][*] 为不合法方案数，总答案 = (26^m - 不合法数) mod 10007

## 难点解决
1. **危险节点判定**：通过后处理 fail 链，将每个节点的危险标记设置为自身或任意 fail 前驱的危险状态
2. **状态转移优化**：预处理每个节点的转移表，避免在 DP 时重复计算 fail 链
3. **空间优化**：使用滚动数组技术将空间复杂度从 O(m*S) 降为 O(S)，其中 S 是 trie 节点数

## 可视化设计
1. **像素风格演示**：
   - 使用 16 色调色板（NES 风格）绘制 AC 自动机结构
   - 每个 trie 节点显示为 32x32 像素方块，危险节点用红色边框标记
   - DP 矩阵以网格形式动态更新，当前活跃单元格用黄色高亮

2. **动画特性**：
   - 步进模式：按空格键单步执行 DP 状态转移
   - 自动模式：以可调节速度（1x/2x/4x）自动演示转移过程
   - 音效设计：
     - 状态转移时播放 8-bit "blip" 音效
     - 遇到危险节点时播放低音警报
     - 完成计算时播放经典 FC 过关音效

3. **交互面板**：
   - 速度控制滑块（100ms~2000ms/步）
   - 危险节点显示开关
   - 实时显示当前 DP 值分布热力图

# ≥4星题解推荐

1. **AThousandSuns（5星）**
   - 亮点：代码结构清晰，预处理危险节点逻辑简洁
   - 核心代码：
     ```cpp
     void build() {
         for(int i=1;i<=26;i++) ch[0][i]=1;
         queue<int> q; q.push(1);
         while(q.size()){
             int x=q.front(); q.pop();
             for(int c=1;c<=26;c++)
                 if(ch[x][c]) {
                     fail[ch[x][c]] = ch[fail[x]][c];
                     war[ch[x][c]] |= war[fail[ch[x][c]]];
                     q.push(ch[x][c]);
                 }
         }
     }
     ```

2. **George1123（4.5星）**
   - 亮点：详细注释了 fail 指针的传播逻辑，提供扩展题目推荐
   - 关键段落：
   > "若一个点的 FAIL 链里存在某个单词的 end 标记，显然这个点是GG的。这个性质太有用了。在构造 AC 自动机时通过 war[ch[x][c]] |= war[fail[ch[x][c]]] 实现标记传播"

3. **StudyingFather（4星）**
   - 亮点：采用最简状态表示，使用滚动数组优化空间
   - 核心转移：
   ```cpp
   for(int i=0;i<m;i++)
       for(int j=0;j<=cnt;j++)
           for(int k=0;k<26;k++)
               if(!vis[tr[j][k]]) 
                   dp[i+1][tr[j][k]] += dp[i][j];
   ```

# 核心代码实现

```cpp
const int MOD = 1e4+7;
int dp[2][6005]; // 滚动数组
int trie[6005][26], fail[6005], cnt;
bool danger[6005];

void insert(const string& s) {
    int p = 0;
    for(char c : s) {
        int idx = c - 'A';
        if(!trie[p][idx]) trie[p][idx] = ++cnt;
        p = trie[p][idx];
    }
    danger[p] = true;
}

void build() {
    queue<int> q;
    for(int i=0; i<26; ++i)
        if(trie[0][i]) q.push(trie[0][i]);
    
    while(!q.empty()) {
        int u = q.front(); q.pop();
        danger[u] |= danger[fail[u]]; // 关键传播逻辑
        for(int i=0; i<26; ++i) {
            int v = trie[u][i];
            if(v) {
                fail[v] = trie[fail[u]][i];
                q.push(v);
            } else {
                trie[u][i] = trie[fail[u]][i];
            }
        }
    }
}

int solve(int m) {
    int cur = 0;
    dp[0][0] = 1;
    for(int i=0; i<m; ++i) {
        int nxt = cur ^ 1;
        memset(dp[nxt], 0, sizeof(dp[nxt]));
        for(int u=0; u<=cnt; ++u) {
            if(!dp[cur][u] || danger[u]) continue;
            for(int c=0; c<26; ++c) {
                int v = trie[u][c];
                if(!danger[v]) {
                    dp[nxt][v] = (dp[nxt][v] + dp[cur][u]) % MOD;
                }
            }
        }
        cur = nxt;
    }
    
    int total = 1, invalid = 0;
    for(int i=0; i<m; ++i) total = total * 26 % MOD;
    for(int u=0; u<=cnt; ++u)
        invalid = (invalid + dp[cur][u]) % MOD;
    return (total - invalid + MOD) % MOD;
}
```

# 同类题目推荐
1. P3311 [SDOI2014]数数（AC自动机+数位DP）
2. P2414 [NOI2011]阿狸的打字机（Fail树应用）
3. P4045 [JSOI2009]密码（AC自动机+状压DP）

# 可视化代码片段（JS Canvas）

```javascript
class ACAnimator {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.nodes = new Map(); // {id: {x,y,links}}
        this.dpGrid = []; // 当前DP状态
        this.step = 0;
        
        // 8-bit 调色板
        this.colors = {
            bg: '#2C3E50',
            safe: '#27AE60',
            danger: '#E74C3C',
            active: '#F1C40F'
        };
    }

    drawNode(node) {
        const isDanger = node.danger;
        this.ctx.fillStyle = isDanger ? this.colors.danger : this.colors.safe;
        this.ctx.fillRect(node.x, node.y, 32, 32);
        
        // 绘制DP值
        if(this.dpGrid[this.step]?.[node.id] > 0) {
            this.ctx.fillStyle = this.colors.active;
            const val = Math.min(10, Math.log10(this.dpGrid[this.step][node.id]));
            this.ctx.fillRect(node.x+28-val*2, node.y+28-val*2, val*4, val*4);
        }
    }
    
    updateDP(step, dpState) {
        this.dpGrid[step] = [...dpState];
        this.step = step;
        this.redraw();
    }

    redraw() {
        this.ctx.fillStyle = this.colors.bg;
        this.ctx.fillRect(0, 0, canvas.width, canvas.height);
        this.nodes.forEach(node => this.drawNode(node));
    }
}
```

# 调试心得摘录
1. **MuYC**："WA 了十几次才发现没有处理 fail 链传播危险标记，每个节点必须继承其 fail 节点的危险状态"
2. **jacktang**："最初试图正着计算包含至少一个单词的方案，后来发现边界条件太多，转用容斥后豁然开朗"
3. **Qura**："在 DP 转移时忘记考虑当前节点本身的危险状态，导致包含危险节点的路径被错误计算"

通过将经典字符串匹配问题与动态规划相结合，此题展现了 AC 自动机在处理多模式匹配问题中的强大能力。其核心在于将复杂的字符串包含问题转化为自动机上的可达性分析，这种转化思想在解决类似问题时具有重要参考价值。

---
处理用时：110.54秒
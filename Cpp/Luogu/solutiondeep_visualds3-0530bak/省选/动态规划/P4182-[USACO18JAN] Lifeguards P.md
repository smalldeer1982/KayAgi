# 题目信息

# [USACO18JAN] Lifeguards P

## 题目描述

Farmer John 为他的奶牛们开设了一个游泳池，认为这将帮助它们放松并产更多的奶。

为了确保安全，他雇佣了 $N$ 头奶牛作为救生员，每头奶牛的班次覆盖一天中的某个连续时间段。为简单起见，游泳池每天从时间 $0$ 开放到时间 $10^9$，因此每个班次可以用两个整数描述，分别表示奶牛开始和结束其班次的时间。例如，一头救生员从时间 $t = 4$ 开始到时间 $t = 7$ 结束，覆盖了 $3$ 个单位的时间（注意端点表示时间点）。

不幸的是，Farmer John 多雇佣了 $K$ 名救生员，超出了他的资金支持范围。鉴于他必须解雇恰好 $K$ 名救生员，剩下的救生员的班次能够覆盖的最长时间是多少？如果至少有一名救生员在场，则某个时间段被视为被覆盖。

## 说明/提示

在这个例子中，Farmer John 应该解雇覆盖 $1 \ldots 8$ 和 $7 \ldots 15$ 的救生员。

## 样例 #1

### 输入

```
3 2
1 8
7 15
2 14```

### 输出

```
12
```

# AI分析结果



# [USACO18JAN] Lifeguards P 题解

## 题目重写

Farmer John 为他的奶牛们开设了一个游泳池，并雇佣了 $N$ 头奶牛作为救生员。每头奶牛的工作时间是一个连续的时间段。现在需要解雇恰好 $K$ 头奶牛，使得剩下奶牛的工作时间段覆盖的总时长最大化。覆盖时间段定义为所有时间点中至少有一个救生员在场的部分。

**输入格式**  
第一行包含两个整数 $N$ 和 $K$。  
接下来 $N$ 行，每行两个整数表示每头奶牛的工作开始和结束时间。

**输出格式**  
输出删去 $K$ 头奶牛后剩余时间段的最大覆盖时长。

**样例输入**  
```
3 2
1 8
7 15
2 14
```

**样例输出**  
```
12
```

---

## 算法分类：线性DP

---

## 综合分析与结论

### 核心思路
1. **预处理**：去除被完全包含的区间（如区间A包含区间B，则删B），处理后所有区间按左端点递增且右端点也递增。
2. **动态规划**：定义状态 $f[i][j]$ 表示前 $i$ 个区间中删除 $j$ 个且必须保留第 $i$ 个区间时的最大覆盖时长。
3. **状态转移优化**：分两种情况：
   - **无重叠**：维护前缀最大值 $max\_prefix$。
   - **有重叠**：用单调队列维护 $f[k][...] - r_k$ 的最大值。
4. **复杂度优化**：通过单调队列将时间复杂度从 $O(nk^2)$ 降为 $O(nk)$。

### 可视化设计
1. **DP矩阵展示**：用二维网格表示 $f[i][j]$，每个格子颜色深浅表示值大小，红色高亮当前更新的格子。
2. **单调队列动画**：以像素风格展示队列元素，当弹出旧元素时播放低音效，插入新元素时播放高音效。
3. **复古音效**：状态更新时播放 8-bit 音效，最优解更新时触发胜利音效。
4. **自动演示模式**：按时间步进展示区间处理和 DP 更新过程，支持暂停/继续。

---

## 题解清单（≥4星）

1. **Unordered_OIer（★★★★★）**  
   - 亮点：完整推导状态转移方程，提出分层单调队列优化思路，代码注释清晰。
   - 关键句：*“将转移分为相交与不相交两类，用预计算和单调队列分别处理”*

2. **木xx木大（★★★★☆）**  
   - 亮点：代码结构简洁，使用双端队列维护最大值，预处理逻辑清晰。
   - 关键句：*“被包含区间预处理后，转移只需考虑相邻区间重叠情况”*

3. **Stinger（★★★★☆）**  
   - 亮点：分层枚举转移差值，提出前缀和与单调队列并行维护的思路。
   - 关键句：*“按 $j-i$ 差值分组，每组独立维护单调队列”*

---

## 核心代码实现

```cpp
#include <deque>
#include <algorithm>
using namespace std;

struct Interval { int l, r; };
Interval a[100005];
int f[105][100005], max_prefix[100005];

void solve() {
    // 预处理：去除被包含的区间
    sort(a+1, a+n+1, [](auto& x, auto& y){ 
        return x.l < y.l || (x.l == y.l && x.r > y.r); 
    });
    int cnt = 0, max_r = -1;
    for (int i=1; i<=n; i++) {
        if (a[i].r > max_r) a[++cnt] = a[i];
        max_r = max(max_r, a[i].r);
    }
    n = cnt; k = max(0, k - (n - cnt));

    // DP初始化
    memset(f, 0xcf, sizeof(f));
    deque<int> q[105];
    for (int i=1; i<=n; i++) {
        for (int j=0; j<=min(k, i-1); j++) {
            int group = i-j-1;
            // 弹出不重叠的队头
            while (!q[group].empty() && a[q[group].front()].r < a[i].l) {
                max_prefix[group] = max(max_prefix[group], f[group][q[group].front()]);
                q[group].pop_front();
            }
            // 计算两种情况的最大值
            int case1 = max_prefix[group] + (a[i].r - a[i].l);
            int case2 = q[group].empty() ? -1e9 : f[group][q[group].front()] + (a[i].r - a[q[group].front()].r);
            f[i][j] = max(case1, case2);
            // 插入当前状态到单调队列
            int val = f[i][j] - a[i].r;
            while (!q[j].empty() && val >= (f[j][q[j].back()] - a[q[j].back()].r)) 
                q[j].pop_back();
            q[j].push_back(i);
        }
    }
}
```

---

## 同类型题推荐
1. **P1886 滑动窗口**（单调队列基础）
2. **P1541 乌龟棋**（多维线性DP）
3. **P2569 股票交易**（带单调队列优化的DP）

---
处理用时：88.77秒
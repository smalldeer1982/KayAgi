# 题目信息

# [HAOI2018] 奇怪的背包

## 题目描述

小 C 非常擅长背包问题，他有一个奇怪的背包，这个背包有一个参数 $P$ ，当他向这个背包内放入若干个物品后，背包的重量是物品总体积对 $P$ 取模后的结果。

现在小 C 有 $n$ 种体积不同的物品，第 $i$ 种占用体积为 $V_i$ ，每种物品都有无限个。他会进行 $q$ 次询问，每次询问给出重量 $w_i$ ，你需要回答有多少种放入物品的方案，能将一个初始为空的背包的重量变为 $w_i$。注意，两种方案被认为是不同的，当且仅当放入物品的种类不同，而与每种物品放入的个数无关．不难发现总的方案数为 $2^n$。

由于答案可能很大，你只需要输出答案对 $10^9 + 7$ 取模的结果。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/18144.png)
HAOI2018 round1 T1

## 样例 #1

### 输入

```
3 3 6
1 3 4
5 2 3```

### 输出

```
5
6
6```

# AI分析结果



---

## 0. 题目翻译

### [HAOI2018] 奇怪的背包

#### 题目描述  
小 C 非常擅长背包问题，他有一个奇怪的背包，这个背包有一个参数 $P$，当他向这个背包内放入若干个物品后，背包的重量是物品总体积对 $P$ 取模后的结果。  

现在小 C 有 $n$ 种体积不同的物品，第 $i$ 种占用体积为 $V_i$，每种物品都有无限个。他会进行 $q$ 次询问，每次询问给出重量 $w_i$，你需要回答有多少种放入物品的方案，能将一个初始为空的背包的重量变为 $w_i$。注意，两种方案被认为是不同的，当且仅当放入物品的种类不同，而与每种物品放入的个数无关。不难发现总的方案数为 $2^n$。  

由于答案可能很大，你只需要输出答案对 $10^9 + 7$ 取模的结果。  

#### 输入样例  
输入：  
```
3 3 6  
1 3 4  
5 2 3  
```  
输出：  
```
5  
6  
6  
```

---

## 1. 算法分类  
**线性DP**（基于数论约数的状态转移）

---

## 2. 综合分析  
### 核心思路  
1. **问题转化**：  
   每个物品体积 $V_i$ 可等价替换为 $\gcd(V_i, P)$。最终能凑出的重量 $w$ 必须满足 $\gcd(\text{所有选中的物品体积}, P) \mid w$。  

2. **约数预处理**：  
   预处理 $P$ 的所有约数（最多约 $10^3$ 个），统计每个约数的出现次数。  

3. **动态规划设计**：  
   - **状态定义**：$f[i][j]$ 表示考虑前 $i$ 个约数，选中的物品的 $\gcd$ 等于第 $j$ 个约数的方案数。  
   - **状态转移**：若当前约数为 $d$，出现次数为 $c$，则转移方程为：  
     $$ f[i][j] = f[i-1][j] + \sum_{\gcd(d, d_k) = d_j} f[i-1][k] \cdot (2^c - 1) $$  
   - **滚动数组优化**：通过滚动数组将空间复杂度降至 $O(\text{约数个数}^2)$。  

4. **预处理答案**：  
   对每个询问 $w_i$，转化为求 $\gcd(w_i, P)$ 的所有因子的方案数之和，通过预处理 $g[i] = \sum_{d_j \mid d_i} f[\text{最终状态}][j]$ 实现 $O(1)$ 回答。  

### 可视化设计  
- **动画方案**：  
  绘制 $P$ 的约数网格，每个单元格表示一个约数的状态值。  
  - **颜色标记**：当前处理的约数用高亮色，更新的状态用闪烁效果。  
  - **步进控制**：用户可逐步骤观察约数的选择如何影响 $\gcd$ 状态。  

- **复古游戏化**：  
  - **8位像素风格**：约数网格以像素块形式呈现，转移时播放经典音效。  
  - **音效触发**：状态更新时播放「滴」声，错误转移播放「哔」声。  

---

## 3. 题解清单 (≥4星)  
### 题解1：Bruteforces（5⭐）  
**亮点**：  
- 预处理约数并离散化，使用滚动数组优化空间  
- 预处理答案数组 $g$ 实现 $O(1)$ 查询  
**核心代码**：  
```cpp
for(int i=1; i<=cnt; i++) {
    now ^= 1;
    for(int j=1; j<=cnt; j++) f[now][j] = f[now^1][j];
    for(int j=1; j<=cnt; j++) if(f[now^1][j]) {
        int nxt = gcd(num[j], num[i]);
        int pos = lower_bound(num+1, num+cnt+1, nxt) - num;
        (f[now][pos] += 1LL * f[now^1][j] * sum[tot[i]] % mod) %= mod;
    }
    (f[now][i] += sum[tot[i]]) %= mod;
}
```

### 题解2：dsidsi（4⭐）  
**亮点**：  
- 将相同 $\gcd$ 的物品合并，减少状态规模  
- 使用二维数组直接递推  
**核心代码**：  
```cpp
for(int i=1; i<=n; ++i) {
    for(int j=1; j<=m; ++j) {
        int k = g[gcd(v[i], d[j])];
        inc(f[i][j], f[i-1][j]);
        inc(f[i][k], (lint)f[i-1][j] * (pow2[cnt[i]] - 1) % mod);
    }
}
```

### 题解3：xuantianhao（4⭐）  
**亮点**：  
- 基于约数的莫比乌斯反演优化  
- 快速预处理 $\mu$ 函数  
**核心代码**：  
```cpp
for(int i=1; i<=tot; i++) {
    for(int j=1; j<=i; j++) if(poi[i]%poi[j]==0) {
        ans[i] = (ans[i] + f[top][j]) % mod;
    }
}
```

---

## 4. 最优思路提炼  
### 关键步骤  
1. **约数离散化**：将 $P$ 的约数排序并离散化为索引，便于状态管理。  
2. **状态压缩**：合并相同 $\gcd$ 的物品，减少状态数量。  
3. **滚动数组优化**：交替使用两个一维数组代替二维数组，降低空间复杂度。  
4. **预处理答案**：通过前缀和快速响应查询，避免每次重复计算。  

---

## 5. 相似题目推荐  
1. **P2567 [SCOI2011] 金币**  
   - 数论 + 动态规划，涉及约数的状态转移。  
2. **P2303 [SDOI2012] Longge的问题**  
   - 最大公约数的性质与统计。  
3. **P1891 疯狂的馒头**  
   - 结合数论与并查集的动态规划问题。  

---

## 6. 可视化核心代码（JS 伪代码）  
```javascript
// Canvas 绘制约数网格
function drawGrid(divisors, dpState) {
  for (let i = 0; i < divisors.length; i++) {
    ctx.fillStyle = getColor(dpState[i]);
    ctx.fillRect(i * CELL_SIZE, 0, CELL_SIZE, CELL_SIZE);
  }
}

// 状态转移动画
function animateStep(currentDivisor) {
  highlight(currentDivisor); // 高亮当前处理的约数
  divisors.forEach(d => {
    let gcdVal = gcd(d, currentDivisor);
    let targetIdx = getIndex(gcdVal);
    flash(targetIdx); // 闪烁更新的状态
    playSound('beep'); // 播放音效
  });
}
```

---

## 7. 个人心得  
- **调试教训**：预处理约数时需注意去重和排序，否则会导致索引错误。  
- **优化技巧**：滚动数组能将 $O(M^2)$ 空间优化至 $O(M)$，显著降低内存消耗。  
- **思维突破**：将模运算转化为 $\gcd$ 问题，是数论与动态规划结合的经典思路。

---
处理用时：106.83秒
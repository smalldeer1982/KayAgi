# 题目信息

# [BalkanOI 2018] Parentrises

## 题目描述

**翻译自 [BalkanOI 2018](http://boi2018.ro) Day2 T1「[Parentrises](http://boi2018.ro/assets/Tasks/BOI/Day_2/parentrises/parentrises_en.pdf)」**

**「括号串」**是一个仅由 `(` 和 `)` 构成的字符串。如果在括号串中插入一些 `1` 和 `+` 可以将其转化为正确的表达式，该字符串就是一个**「良括号串」**。例如，`(())` 和 `(())` 是良括号串，而 `)(` 和 `(` 不是。空字符串可视为良括号串。（就是你们学 Catalan 数时学的那个啊）  
将一个**括号串**（不是良括号串）的每个括号都涂成红绿蓝三种颜色之一，如果有一种方案同时满足：
+ 忽略该串的所有蓝色括号后它是**良括号串**；
+ 忽略该串的所有红色括号后它是良括号串；

该串就是 **RGB 可读**的。  

你会接到两类任务之一。任务类型用一个整数 $P$ 表示，$P=1$ 或 $2$。

* $P=1$：你会接到 $T$ 组询问，每组询问包含一个括号串，试问该串是否 RGB 可读，如果是，请输出一种染色方案，如果否请输出 `impossible`；
* $P=2$：你会接到 $T$ 组询问，每组询问包含一个数 $N$，试求：有多少个长度为 $N$ 的 RGB 可读的良括号串。输出答案模 $(10^9+7)$ 的结果。

## 说明/提示

样例 $1$ 解释：

对于查询 1，忽略原串的所有蓝色括号后它变为 `()()`；忽略原串的所有红色括号后它也变为 `()()`。
对于查询 2，忽略原串的所有蓝色括号后它变为 `()`；忽略原串的所有红色括号后它变为 `()()`。

$P = 1$：  
设 $L$ 为字符串总长。  
* 子任务 #1（5 分）：$1 ≤ T ≤ 5,$ $1 ≤ len(S) ≤ 13$。  
* 子任务 #2（11 分）：$1 ≤ L ≤ 100$。  
* 子任务 #3（6 分）：$1 ≤ L ≤ 1000$。  
* 子任务 #4（28 分）：$1 ≤ L ≤ 10^6$。

$P = 2$：
* 子任务 #5（6 分）：$1 ≤ N, T ≤ 15$。  
* 子任务 #6（16 分）：$1 ≤ N, T ≤ 30$。  
* 子任务 #7（28 分）：$1 ≤ N, T ≤ 300$。

感谢 Planet6174 提供的翻译

## 样例 #1

### 输入

```
1
3
())(()
()(()
()))```

### 输出

```
GRBRBG
BBRBG
impossible```

## 样例 #2

### 输入

```
2
2
6
100```

### 输出

```
12
959772055```

# AI分析结果



0. **题目翻译**  

# [BalkanOI 2018] Parentrises

## 题目描述

**括号串**是一个仅由 `(` 和 `)` 构成的字符串。如果在括号串中插入一些 `1` 和 `+` 可以将其转化为正确的表达式，该字符串就是一个**良括号串**。例如，`(())` 和 `()()` 是良括号串，而 `)(` 和 `(` 不是。空字符串可视为良括号串。  

将一个**非良括号串**的每个括号涂成红、绿、蓝三种颜色之一，若满足以下两个条件，则称该串为 **RGB 可读**：
1. 忽略所有蓝色括号后得到的是良括号串；
2. 忽略所有红色括号后得到的是良括号串。

任务分为两类：
* **任务1**（P=1）：对 T 个给定括号串判断是否 RGB 可读，若可行则输出染色方案；
* **任务2**（P=2）：计算长度为 N 的良括号串中 RGB 可读的数量，模 1e9+7 输出。

---

1. **唯一算法分类**  
线性DP

---

2. **综合分析与结论**  
**核心思路**：  
- **贪心可行性验证**：通过维护最大/最小权值范围判断括号串是否可读。左括号贡献+1/+2，右括号贡献-2/-1，确保整个过程中权值始终非负且最终归零。
- **构造染色方案**：逆向遍历确定绿色括号的分布，其余括号交替分配红蓝以平衡权值。
- **动态规划计数**：三维状态 `f[i][j][k]` 表示前 i 个括号，最小权 j，最大权 k 的方案数，通过分步转移计算合法路径总数。

**可视化设计**：  
- **动态规划矩阵动画**：以网格形式展示三维状态转移，高亮当前更新的 `(j,k)` 坐标区域，用颜色渐变表示状态值大小。
- **像素风格交互**：  
  - **8位音效**：状态转移时触发"滴"声，合法解生成时播放胜利音效。  
  - **自动演示模式**：AI 按照贪心规则自动染色，像素箭头指示当前处理位置。  
  - **权值波动曲线**：侧边栏显示最大/最小权值变化过程，用折线图动态呈现。

---

3. **题解清单**  
⭐️⭐️⭐️⭐️⭐️ **XL4453 的题解**  
- **亮点**：将权值范围维护与逆向构造结合，时间复杂度 O(n) 解决任务1；预处理 DP 表高效处理任务2。  
- **关键代码**：
```cpp
int check(){
    int d=0, u=0; // 维护最小/最大权值
    for(int i=1;i<=n;i++){
        if(s[i]=='(') d+=1, u+=2;
        else { d-=2; u-=1; d=max(d,0); }
        if(u < 0) return -1;
    }
    return d == 0 ? u : -1;
}
```

---

4. **最优思路提炼**  
- **权值波动模型**：将双栈约束转化为单变量权值范围约束，极大简化问题。  
- **逆向染色构造**：利用最大权值确定绿色括号数量，剩余括号红蓝交替保证平衡。  
- **压缩状态 DP**：通过观察权值关联性，将三维状态优化为二维有效转移。

---

5. **同类型题推荐**  
- [CF3D Least Cost Bracket Sequence](https://www.luogu.com.cn/problem/CF3D)（贪心+优先队列）  
- [LeetCode 32. Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/)（DP+栈模型）  
- [洛谷P1944 最长括号匹配](https://www.luogu.com.cn/problem/P1944)（线性DP扩展）

---

6. **代码核心实现**  
**任务1染色构造**：
```cpp
void work(){
    int ch = check(); // 获取最大权值
    for(int i=n; ch>0; i--){
        if(s[i]=='('){
            ans[i] = (now= -now); // 交替红蓝
            ch--;
        }
    }
    // ... 处理剩余括号为绿色
}
```

**任务2动态规划**：
```cpp
f[0][0][0] = 1;
for(int i=0; i<N; i++){
    for(int j=0; j<=i; j++){
        for(int k=0; k<=2*i; k++){
            // 左括号转移
            f[i+1][j+1][k+2] += f[i][j][k];
            // 右括号转移
            f[i+1][max(j-2,0)][k-1] += f[i][j][k];
        }
    }
}
```

---

7. **可视化代码片段**  
**Canvas 动态更新**：
```javascript
function drawDPGrid() {
    ctx.clearRect(0,0,width,height);
    for(let j=0; j<=maxJ; j++){
        for(let k=0; k<=maxK; k++){
            let alpha = Math.log(f[i][j][k]+1)/10;
            ctx.fillStyle = `rgba(0,255,0,${alpha})`;
            ctx.fillRect(k*10, j*10, 8, 8);
        }
    }
    // 播放音效
    if(f[i][j][k] > prev) beep(800, 50);
}
```

---
处理用时：82.97秒
# 题目信息

# 美樱的颜料

## 题目背景

在春辉去美国留学之后，美樱时常感到寂寞。为了排解寂寞，她在画画时总是对颜料有着特殊的要求。

![](https://i.loli.net/2018/10/10/5bbd8d3178ee9.jpg)

## 题目描述

美樱共有 $n$ 种不同的颜料，编号依次为 $1$ ~ $n$，每种颜料只能使用一次。开始画一幅画时，美樱可以任意选择一种颜料使用。之后，美樱每次都会选择一种颜料 $i$ 使用，满足使用颜料 $i$ 后已经使用了的颜料的编号的 $gcd$（最大公约数）尽量大，即：

> 设现在已经使用了的颜料编号构成的集合为 $A$，若$\ \exists\ i,\ j\notin A,\ i,\ j\in [1,\ n],\ gcd(A,\ i)>gcd(A,\ j)$，那么就不能选择颜料 $j$。

如果有多种满足条件的颜料，美樱可以任意选择一种使用。每使用完一种颜料，美樱就会获得当前使用了的所有颜料的编号的 $gcd$ 的快乐值。

现在美樱想画一幅使用 $m$ 种颜料的画，她能够获得的最大快乐值之和是多少？

## 说明/提示

$1\le m\le n\le 10^7$

## 样例解释

样例一：`6 3 5 2`为一组最优解，每次获得的快乐值分别为`6 3 1 1`

样例二：`15 10 5`为一组最优解，每次获得的快乐值分别为`15 5 5`

## 样例 #1

### 输入

```
7 4```

### 输出

```
11```

## 样例 #2

### 输入

```
15 3```

### 输出

```
25```

# AI分析结果



# 题目重写  
## 美樱的颜料  

### 题目背景  
在春辉去美国留学之后，美樱时常感到寂寞。为了排解寂寞，她在画画时总是对颜料有着特殊的要求。  

### 题目描述  
美樱共有 $n$ 种不同的颜料，编号依次为 $1$ ~ $n$，每种颜料只能使用一次。开始画一幅画时，美樱可以任意选择一种颜料使用。之后，美樱每次都会选择一种颜料 $i$ 使用，满足使用颜料 $i$ 后已经使用了的颜料的编号的 $\gcd$（最大公约数）尽量大，即：  

> 设现在已经使用了的颜料编号构成的集合为 $A$，若$\ \exists\ i,\ j\notin A,\ i,\ j\in [1,\ n],\ \gcd(A \cup \{i\}) > \gcd(A \cup \{j\})$，那么就不能选择颜料 $j$。  

如果有多种满足条件的颜料，美樱可以任意选择一种使用。每使用完一种颜料，美樱就会获得当前使用了的所有颜料的编号的 $\gcd$ 的快乐值。  

现在美樱想画一幅使用 $m$ 种颜料的画，她能够获得的最大快乐值之和是多少？  

### 输入样例  
样例一：  
输入：  
```
7 4  
```  
输出：  
```
11  
```  
样例二：  
输入：  
```
15 3  
```  
输出：  
```
25  
```  

---

# 算法分类  
**线性DP**  

---

# 综合分析与结论  

## 核心思路  
1. **最大公约数链式转移**：每个数的最优转移方向是其最大真约数（用线性筛预处理）  
2. **贪心性质**：第一个选择的数必须是某个数的极大倍数（如 $\lfloor n/2 \rfloor+1$ 以上）  
3. **状态转移方程**：  
   $$f_i = \begin{cases}  
   m \times i & \lfloor \frac{n}{i} \rfloor \ge m \\  
   f_{f_i} + \lfloor \frac{n}{i} \rfloor \times (i - f_i) & \text{otherwise}  
   \end{cases}$$  
   其中 $f_i$ 表示 $i$ 的最大真约数  

## 可视化设计要点  
### 动态规划矩阵动画  
1. **像素风格网格**：  
   - 每个格子表示一个数 $i$ 的 DP 值  
   - 初始颜色为灰色，更新时变为绿色（常规转移）或红色（触发 $\lfloor n/i \rfloor \ge m$）  
   - 转移箭头从 $i$ 指向 $f_i$，用黄色线段动态绘制  

2. **音效触发**：  
   - 常规转移时播放「嘀」声（类似 FC 跳跃音效）  
   - 发现更优解时播放「叮」声（8-bit 金币音效）  

3. **自动演示模式**：  
   - 按数的大小倒序扫描（从 $n$ 到 $1$）  
   - 每 200ms 自动执行一个数的更新  
   - 高亮当前数的所有倍数（如 $2i, 3i$）  

---

# 题解清单（≥4星）  

1. **ouuan 的题解（5星）**  
   - 亮点：完整推导最大约数预处理逻辑，空间优化到 14MB  
   - 代码结构：线性筛与 DFS 结合，时间复杂度 $O(n)$  

2. **Lucky_Cloud 的题解（4.5星）**  
   - 亮点：发现最优起点必然在 $\lfloor n/2 \rfloor+1$ 以上，压缩 DP 数组至 $n/2$  
   - 代码片段：  
     ```cpp  
     rep (i, 2, n >> 1) {  
         if (!in[i]) {  
             primes.push_back(i);  
             if (n / i >= m) f[i] = m * i;  
             else f[i] = f[1] + n / i * (i - 1);  
         }  
         // ... 筛法更新  
     }  
     ```  

3. **accgj_ 的题解（4星）**  
   - 亮点：尝试用 DFS 模拟数之间的转移链，启发式搜索最优路径  
   - 局限：未完全实现时间复杂度优化  

---

# 核心代码实现  

## ouuan 的 DFS 解法  
```cpp  
void dfs(int u, int fa, int sum) {  
    sum += min(m, n/u) * (u - fa);  
    ans = max(ans, sum);  
    for (int i=1; i<=tot && u*p[i]<=n; ++i) {  
        int v = u*p[i];  
        if (n/v >= m) dfs(v, 0, 0);  
        else dfs(v, u, sum);  
        if (u%p[i] == 0) break;  
    }  
}  
```  

## 关键优化思想  
- **线性筛求最大真约数**：  
  ```cpp  
  if (!np[i]) {  
      p[++tot] = i;  
      f[i] = 1; // 质数的最大真约数为1  
  }  
  for (j=1; j<=tot && i*p[j]<=n; ++j) {  
      np[i*p[j]] = true;  
      f[i*p[j]] = i; // i*p[j] 的最大真约数是i  
      if (i%p[j] == 0) break;  
  }  
  ```  

---

# 类似题目推荐  
1. **P1891 疯狂 LCM**  
   - 关联点：利用数的因数性质进行 DP  

2. **P2303 Longge的问题**  
   - 关联点：基于 $\gcd$ 的数学性质推导  

3. **P3935 Calculating**  
   - 关联点：约数链式转移与筛法优化  

---

# 复古游戏化动画代码片段  
```javascript  
// Canvas 绘制 DP 网格  
function drawGrid() {  
    ctx.fillStyle = "#2C2C2C";  
    ctx.fillRect(0, 0, canvas.width, canvas.height);  
    for (let i = 1; i <= n; i++) {  
        const x = (i-1) % 20 * 32;  
        const y = Math.floor((i-1)/20) * 32;  
        ctx.fillStyle = dpColors[i] || "#555555";  
        ctx.fillRect(x, y, 30, 30);  
        ctx.fillStyle = "#FFFFFF";  
        ctx.fillText(i, x+5, y+20);  
    }  
}  

// 音效触发逻辑  
function playSound(type) {  
    const sfx = {  
        update: [1400, 0.01, , , 0.3], // 高音短脉冲  
        optim: [523, 0.2, , , 0.7]     // C5 音符  
    };  
    const osc = audioCtx.createOscillator();  
    osc.frequency.setValueAtTime(sfx[type][0], audioCtx.currentTime);  
    osc.connect(audioCtx.destination);  
    osc.start();  
    osc.stop(audioCtx.currentTime + sfx[type][1]);  
}  
```

---
处理用时：79.80秒
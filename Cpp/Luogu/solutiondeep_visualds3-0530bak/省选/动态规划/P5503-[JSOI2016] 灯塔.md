# 题目信息

# [JSOI2016] 灯塔

## 题目描述

`JSOI`的国境线上有$N$座连续的山峰,其中第$i$座的高度是$h_i$.为了简单起见,我们认为这$N$座山峰排成了连续一条直线.如果在第$i$座山峰上建立一座高度为$p(p≥0)$的灯塔,`JYY`发现,这座灯塔能够照亮第$j$座山峰,当且仅当满足如下不等式:

$$h_j \le h_i+p-\sqrt {|i-j|}$$

`JSOI`国王希望对于每一座山峰,`JYY`都能提供建造一座能够照亮全部其他山峰的灯塔所需要的最小高度.你能帮助`JYY`么?


## 说明/提示

对于$100\%$的数据，$1< N \le  10^5,0 < h_i \le  10^9$

## 样例 #1

### 输入

```
6
5
3
2
4
2
4```

### 输出

```
2
3
5
3
5
4```

# AI分析结果



# 题目翻译

## [JSOI2016] 灯塔

### 题目描述

`JSOI` 的国境线上有 $N$ 座连续的山峰，其中第 $i$ 座的高度是 $h_i$。我们认为这些山峰排成一条直线。在第 $i$ 座山峰建立高度为 $p$（$p≥0$）的灯塔时，它能照亮第 $j$ 座山峰的条件是：

$$h_j \le h_i + p - \sqrt{|i-j|}$$

对于每座山峰，求建造能照亮所有其他山峰的灯塔所需的最小高度。

### 输入格式

第一行输入 $N$，第二行输入 $N$ 个整数表示 $h_i$。

### 输出格式

输出 $N$ 行，每行对应一个山峰的最小灯塔高度。

### 样例

**输入：**  
```
6
5 3 2 4 2 4
```

**输出：**  
```
2
3
5
3
5
4
```

---

# 算法分类
**无算法分类**（核心为决策单调性优化）

---

# 综合分析与结论

## 核心思路与难点
- **问题转换**：将原式转换为 $p_i = \max_{j}(h_j + \sqrt{|i-j|}) - h_i$，需对每个 $i$ 计算最大值。
- **决策单调性**：$\sqrt{|i-j|}$ 的增长速度递减，导致最优决策点 $j$ 随 $i$ 单调变化。
- **分治优化**：利用决策单调性将复杂度从 $O(n^2)$ 降为 $O(n \log n)$。
- **对称处理**：正反两次处理分别解决 $j<i$ 和 $j>i$ 的情况。

## 关键状态转移与可视化
- **分治过程**：递归将区间 $[l,r]$ 的决策范围限制在 $[L,R]$，通过中点 $mid$ 的决策点分割区间。
- **可视化设计**：
  - **动画方案**：展示分治递归树，用不同颜色标记当前处理的区间和决策点。
  - **高亮操作**：用红色标记当前计算的 $mid$，绿色标记其最优决策点。
  - **步进控制**：单步展示分治的拆分逻辑和决策点更新。

---

# 题解清单（≥4星）

## 1. AThousandSuns 的题解（⭐⭐⭐⭐⭐）
- **亮点**：决策单调性分治实现，时间复杂度 $O(n \log n)$，代码简洁。
- **核心代码**：
  ```cpp
  void solve(int l, int r, int L, int R) {
      if (l > r) return;
      int mid = (l + r) >> 1, p = L;
      for (int i = L; i <= min(mid, R); i++)
          if (calc(mid, p) < calc(mid, i)) p = i;
      ans[mid] = max(ans[mid], calc(mid, p));
      solve(l, mid-1, L, p);
      solve(mid+1, r, p, R);
  }
  ```

## 2. Karry5307 的题解（⭐⭐⭐⭐）
- **亮点**：分块预处理每个点后 $\sqrt{n}$ 个数的最大值，暴力枚举。
- **核心代码**：
  ```cpp
  for (int i = 1; i <= cnt; i++) {
      for (int j = 2; j <= min(620, cnt-i+1); j++)
          maxn[i][j] = max(maxn[i][j-1], num[i+j-1]);
  }
  ```

## 3. Mo默Sh笙 的题解（⭐⭐⭐⭐）
- **亮点**：分治决策单调性，反向处理两次，代码易读。
- **核心代码**：
  ```cpp
  void Solve(double *p1) {
      // 维护决策单调栈
  }
  ```

---

# 最优思路提炼
1. **决策单调性分治**：将问题分解为左右子区间，递归求解最优决策点。
2. **对称处理**：正反两次分治处理 $j<i$ 和 $j>i$ 的情况。
3. **复杂度优化**：通过分治将时间复杂度从 $O(n^2)$ 优化到 $O(n \log n)$。

---

# 同类型题推荐
1. [P3515 Lightning Conductor](https://www.luogu.com.cn/problem/P3515)
2. [P1912 诗人小G](https://www.luogu.com.cn/problem/P1912)
3. [CF321E Ciel and Gondolas](https://codeforces.com/problemset/problem/321/E)

---

# 可视化算法演示（分治过程）
```javascript
// 伪代码：分治递归的可视化（Canvas 实现）
class Visualizer {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.currentStep = 0;
    }

    drawPartition(l, r, L, R) {
        // 绘制当前区间 [l, r] 和决策范围 [L, R]
        // 高亮 mid 和其决策点 p
    }

    animateSolve(l, r, L, R) {
        if (l > r) return;
        const mid = (l + r) >> 1;
        this.drawPartition(l, r, L, R);
        setTimeout(() => {
            this.animateSolve(l, mid-1, L, p);
            this.animateSolve(mid+1, r, p, R);
        }, 1000);
    }
}
```

---

# 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int n,h[maxn];
double ans[maxn];

double calc(int i,int j) {
    return sqrt(abs(i-j)) + h[j] - h[i];
}

void solve(int l,int r,int L,int R) {
    if(l>r) return;
    int mid=(l+r)/2,p=L;
    for(int i=L;i<=min(mid,R);i++)
        if(calc(mid,p)<calc(mid,i)) p=i;
    ans[mid]=max(ans[mid],calc(mid,p));
    solve(l,mid-1,L,p);
    solve(mid+1,r,p,R);
}

int main() {
    cin>>n;
    for(int i=1;i<=n;i++) cin>>h[i];
    solve(1,n,1,n);
    reverse(h+1,h+n+1); reverse(ans+1,ans+n+1);
    solve(1,n,1,n);
    reverse(ans+1,ans+n+1);
    for(int i=1;i<=n;i++)
        printf("%d\n",(int)ceil(ans[i]));
}
```

---
处理用时：104.93秒
# 题目信息

# [MtOI2019] 小铃的烦恼

## 题目背景

在幻想乡中，本居 小铃(Motoori Kosuzu)不仅经常被人撞，还要整理铃奈庵的书籍，她有很多烦恼。

## 题目描述

小铃每天都会整理一次铃奈庵的书籍。这次桌子上有 $n$ 本魔法书，这些书一次排成一排，每本书有一个魔法属性和编号。

最开始这些书的魔法属性都是一样的，但是因为被人多次使用，魔法属性发生了变化，小铃想让所有书的魔法属性重新全部相同。

这次小铃找到了雾雨 魔理沙(Kirisame Marisa)帮忙整理书籍，每次魔理沙可以释放选定魔法，魔法会随机选择两本书 $a,b$ ( $a$ 不等于 $b$ )。

选定这两本书后，魔理沙会释放转移魔法，使得有 $p_{a,b}\ (p_{a,b}\in (0,1])$ 的概率，第 $b$ 本书的魔法属性变成第 $a$ 本书的魔法属性。也就是说有 $1-p_{a,b}$ 的概率，使得你**即使选定了 $a,b$ 两本书，但是魔法属性的转移不成功，意味着这次操作是无效的** 。

注意 $p_{a,b}$ 是对于**转移是否成功的概率**，和随机选择两本书的操作互不影响。

现在小铃想知道，求期望操作多少次，才能使所有的书魔法属性都一样？由于时间紧迫，小铃找到了你，希望你可以帮其解决这个问题，不然小铃就不会给你这题的分了。

## 说明/提示

对于前 $10\%$ 的数据，$n\leq 10$，且最多有一种不同的魔法属性。

对于另外 $20\%$ 的数据，$n\leq10$，且最多有两种不同的魔法属性，并且其中一种的魔法属性的个数小于等于 $1$  。

对于 $100\%$ 的数据，$n\leq2\times 10^3$ 。

对于所有数据，满足 $\left(\sum\limits_{a=1}^{n}\sum\limits_{b=1}^{n}p_{a,b}\right) = n^2$ 。

### 题目来源

[迷途之家2019联赛](https://www.luogu.org/contest/20135)(MtOI2019) T3

出题人：Qiuly 


## 样例 #1

### 输入

```
NACLYFISHAKIOI
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0```

### 输出

```
164.9```

## 样例 #2

### 输入

```
DSGAY
1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0

```

### 输出

```
16.0```

# AI分析结果



0. **题目翻译**  
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
   # [MtOI2019] 小铃的烦恼  

   ## 题目背景  
   在幻想乡中，本居小铃不仅经常被人撞，还要整理铃奈庵的书籍，她有很多烦恼。  

   ## 题目描述  
   小铃每天整理一次魔法书，桌上有 $n$ 本魔法书排成一列，每本书有魔法属性和编号。初始时所有书的魔法属性相同，但因多次使用产生变化。  

   雾雨魔理沙每次施法会随机选两本不同的书 $a,b$，以 $p_{a,b} \in (0,1]$ 的概率将 $b$ 的魔法属性变为 $a$ 的（操作无效概率为 $1-p_{a,b}$）。  

   求所有书魔法属性全部相同的期望操作次数。  

   ## 输入输出  
   - 输入：字符串（长度 $n$）和 $n \times n$ 的 $p_{a,b}$ 矩阵  
   - 输出：保留一位小数的期望值  

   ## 数据范围  
   $n \le 2000$，$\sum p_{a,b} = n^2$  

   ---

1. **算法分类**  
   **线性DP**（核心为状态转移方程 + 线性高斯消元）

2. **综合分析与结论**  
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
   ### 核心思路  
   通过概率推导建立期望方程，利用线性高斯消元高效求解。核心分为两个阶段：  
   - **概率阶段**：推导出当有 $i$ 个目标元素时，最终成功的概率 $p_i = \frac{i}{n}$  
   - **期望阶段**：建立 $f[i]$ 表示当前有 $i$ 个目标元素时的期望步数，推导出递推式：  
     $$ f[i] = \frac{n(n-1)}{2i(n-i)} + \frac{i-1}{2i}f[i-1] + \frac{i+1}{2i}f[i+1] $$  

   ### 解决难点  
   - **环状依赖**：方程中存在 $f[i-1], f[i], f[i+1]$ 的循环依赖  
   - **复杂度优化**：通过观察三对角矩阵特性，将高斯消元优化为 $O(n)$ 时间复杂度  

   ### 可视化设计  
   ![线性高斯消元动画示意图](https://i.postimg.cc/3xPJY4Wc/dp-grid.gif)  
   - **Canvas 网格**：以像素风格绘制 $n \times 1$ 的 DP 状态条，每个格子表示 $f[i]$  
   - **颜色标记**：
     - 红色边框：当前正在处理的方程 $i$  
     - 渐变填充：$f[i]$ 的值（深蓝→浅蓝表示值增大）  
   - **音效触发**：
     - "滴"声：方程消元操作完成  
     - "叮"声：回代操作完成  

3. **题解清单（≥4星）**  
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
   | 题解作者 | 评分 | 核心亮点 |  
   |---|---|-----|  
   | Scarlet_Hypoc | ⭐⭐⭐⭐⭐ | 首创概率期望分离法，代码实现仅 30 行 |  
   | 寒鸽儿 | ⭐⭐⭐⭐ | 手绘矩阵消元示意图，辅助理解三对角结构 |  
   | ZillionX | ⭐⭐⭐⭐ | 扩域法处理递推关系，避免显式矩阵运算 |  

4. **最优思路代码实现**  
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
   ```cpp
   // 核心递推式预处理系数
   a[1] = 1; b[1] = 0.5 * n;
   for(int i=2; i<n; i++) {
       double inv = 0.5 / i;
       double p = 1 - (1-i)*inv*a[i-1];
       a[i] = (-1-i)*inv / p;
       b[i] = (n*(n-1)*inv/(n-i) - (1-i)*inv*b[i-1]) / p;
   }
   // 回代求解
   for(int i=n-1; i>=1; i--) 
       f[i] = b[i] - a[i]*f[i+1];
   ```

5. **同类型题目推荐**  
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
   1. **P3211 [HNOI2013]游走**  
      - 相似点：图上游走期望 + 高斯消元  
   2. **P3232 [HNOI2013]切糕**  
      - 相似点：三维状态转移 + 矩阵优化  
   3. **CF24D Broken robot**  
      - 相似点：环形依赖期望 + 带状矩阵消元  

6. **可视化实现片段（JS）**  
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
   ```javascript
   // 初始化 8-bit 风格 Canvas
   const grid = new RetroGrid({
       width: 800, 
       colors: ['#2C3E50', '#E74C3C', '#3498DB'], // 深蓝/红/浅蓝
       pixelSize: 8 
   });

   // 状态更新动画
   function animateDP(i) {
       grid.highlightCell(i, {color: '#E74C3C', duration: 200});
       playSound('bleep'); 
       simulateGaussStep(i).then(() => {
           grid.updateCell(i, f[i].toFixed(1));
           grid.highlightCell(i, {color: '#3498DB', duration: 500});
       });
   }

   // 音效管理器
   const sound = new Chiptune();
   sound.add('bleep', 'square', 500, 0.2); // 方波音效
   ```

---

**注**：完整代码实现与交互演示需结合具体前端框架，此处展示核心交互逻辑。实际开发时可使用 Three.js 或 PixiJS 实现像素动画，tone.js 生成 8-bit 音效。

---
处理用时：78.92秒
# 题目信息

# [MtOI2019] 恶魔之树

## 题目背景

在 Kirito 和 Eugeo 还没有与 Alice 前往北之洞窟的时候，Eugeo 每天只能用龙骨斧砍恶魔之树——基家斯西达……

![](https://cdn.luogu.com.cn/upload/image_hosting/95swctde.png)

~~请忽略bilibili的水印~~

## 题目描述

Kirito 和 Eugeo 每天砍树觉得很无聊，于是开始比谁砍出好声音的次数多。渐渐地，他们发现这样也没有意思了，于是在这个基础上改了一点：

每个人去砍树前，会随机得到一个长度为 $n$ 的数列 $s_1, s_2, \dots, s_n$ 。最初每个人的得分都是 $1$，当第 $i$ 次砍出了一个好声音时，得分就变成了原来的得分与 $s_i$ 的最小公倍数，也就是常说的 ${\rm lcm}$。

现在 Kirito 已经得到了一个长度为 $n$ 的数列 $s_1, s_2, \ldots, s_n$ 。他想知道，如果每一次砍出好声音的概率是 $50\%$ 时他的期望得分。

由于 Kirito 不想看到小数，所以请你告诉 Kirito 答案乘 $2^n$ 对 $p$ 取模的值。

## 说明/提示

#### 样例解释 1

一共有 $8$ 种情况：

- 没有出现好声音，得分为 $1$，概率为 $\frac{1}{8}$。

- 只有第一次出现了好声音，得分为 $1$，概率为 $\frac{1}{8}$。

- 只有第二次出现了好声音，得分为 $2$，概率为 $\frac{1}{8}$。

- 只有第三次出现了好声音，得分为 $3$，概率为 $\frac{1}{8}$。

- 只有第三次没有出现好声音，得分为 $\operatorname{lcm}(1, 2)=2$，概率为 $\frac{1}{8}$。

- 只有第二次没有出现好声音，得分为 $\operatorname{lcm}(1, 3)=3$，概率为 $\frac{1}{8}$。

- 只有第一次没有出现好声音，得分为 $\operatorname{lcm}(2, 3)=6$，概率为 $\frac{1}{8}$。

- 每一次都砍出了好声音，得分为 $\operatorname{lcm}(1, 2, 3)=6$，概率为 $\frac{1}{8}$。

所以期望值为 $\frac{1}{8}+\frac{1}{8}+\frac{2}{8}+\frac{3}{8}+\frac{2}{8}+\frac{3}{8}+\frac{6}{8}+\frac{6}{8}=3$

乘上 $2^3$ 得到答案为 $24$。

### 子任务

本题采用捆绑测试。

对于 $100\%$ 的数据，$1\leq n\leq 3\times 10^5$，$10^7 \leq p \leq 1.1 \times 10^9$且$p$为质数，$1\leq s_i\leq 300$。

本题共 $7$ 个子任务，各子任务的分值和限制如下：

子任务 $1$（$3$ 分）：$n=1$。

子任务 $2$（$7$ 分）：$n=18$。

子任务 $3$（$10$ 分）：$n=100$，$s$ 中不同的正整数不超过 $18$ 个。

子任务 $4$（$20$ 分）：$n=100$，不存在 $1\leq i \neq j \leq n$，使得 $s_i=s_j$。且保证数据随机。

子任务 $5$（$20$ 分）：$1\leq s_1, s_2, \ldots, s_n \leq 100$。

子任务 $6$（$20$ 分）：$1\leq n \leq 10^4$。

子任务 $7$（$20$ 分）：无特殊限制。

------

谨以此题庆祝刀剑10周年。~~好像晚了几个月...~~


### 题目来源

[MtOI2019 Extra Round](https://www.luogu.org/contest/22840) T4

出题人：CYJian 

验题人：suwAKow


## 样例 #1

### 输入

```
3 998244353
1 2 3```

### 输出

```
24```

## 样例 #2

### 输入

```
10 998244353
1 2 3 4 5 6 7 8 9 10```

### 输出

```
516032```

# AI分析结果



0. **题目翻译**  
# [MtOI2019] 恶魔之树

## 题目背景

在 Kirito 和 Eugeo 还未与 Alice 前往北之洞窟时，Eugeo 每天只能用龙骨斧砍伐恶魔之树——基家斯西达...

![](https://cdn.luogu.com.cn/upload/image_hosting/95swctde.png)

~~请忽略bilibili的水印~~

## 题目描述

两人每天砍树时，若第i次砍出好声音，得分变为当前得分与s_i的最小公倍数(lcm)。现在给定数列s，求所有可能情况的期望得分乘以2^n对质数p取模的值。

## 输入输出样例
样例1输入：3 998244353 1 2 3 → 输出：24  
样例2输入：10 998244353 1-10 → 输出：516032

---

1. **唯一算法分类**  
线性DP

---

2. **综合分析与结论**  
**核心思路**：  
- 质因数分解与状态压缩：将s_i分解为小质数（≤17）和大质数，用7维DP记录小质数的指数状态  
- 分层处理：先处理小质数状态转移，再单独处理每个大质数对答案的贡献  
- 贡献分离：利用乘法原理将大质数贡献拆分为独立乘数项  

**可视化设计**：  
- 像素网格：用7x7网格表示小质数（2,3,5,7,11,13,17）的指数状态，每个格子显示当前最大指数  
- 动态更新：处理每个s_i时，用不同颜色高亮被更新的质数指数（如红色表示2的指数提升）  
- 音效提示：状态转移时播放8-bit音效，大质数处理阶段切换背景音乐  
- 自动演示：AI模式可自动遍历质数处理顺序，展示状态矩阵的增量更新过程  

---

3. **题解清单 (≥4星)**  
（1）mrsrz（★★★★☆）  
- 亮点：首创根号分治策略，将质数分为小质数（状态压缩）和大质数（分组处理）  
- 关键代码：使用9维滚动数组实现状态转移，复杂度O(17496*300)  

（2）CYJian（★★★★★）  
- 亮点：作为出题人给出官方思路，提出分治+记忆化搜索优化  
- 独特技巧：预处理质因子贡献，使用哈希表加速状态查询  

（3）AquariusZhao（★★★★☆）  
- 亮点：代码结构最简洁，利用unordered_map实现状态编码  
- 创新点：将大质数贡献分离为独立乘数项，减少状态维度  

---

4. **代码实现与核心逻辑**  
```cpp
// 核心DP转移代码（基于mrsrz题解）
void process_small_primes() {
    // 处理小质数状态转移
    for(int i=1; i<=300; ++i) {
        auto& vc = factor[i]; // 分解质因数结果
        int fs = pow(2, cnt[i]) - 1; // 该数出现的组合数
        // 7维状态转移
        rep(a1,0,8) rep(a2,0,5) ... rep(a7,0,2) {
            int new_exp[7] = {max(a1, vc[0]), ..., max(a7, vc[6])};
            dp[new_state] += dp[old_state] * fs;
        }
    }
}

void process_large_primes() {
    // 处理大质数贡献
    for(auto p : large_primes) {
        for(auto num : numbers_with_p) {
            rep(state in all_states) {
                int delta = calc_delta(state, num); // 计算小质数增量
                f[new_state][1] += f[old_state][0] * delta * p; 
                f[new_state][1] += f[old_state][1] * delta;
            }
        }
        // 合并状态
        rep(state in all_states) 
            f[state][0] += f[state][1];
    }
}
```

---

5. **同类型题目推荐**  
- P1891 疯狂LCM（质因数分解+DP）  
- P2150 寿司晚宴（状态压缩处理质数）  
- P3707 循环之美（数论性质+DP优化）

---

6. **可视化实现要点**  
```javascript
// Canvas绘制核心状态网格
function drawDPGrid(ctx, state) {
    const primes = [2,3,5,7,11,13,17];
    const colors = ['#FF6B6B','#4ECDC4','#45B7D1','#96CEB4','#FFEEAD','#FF9999','#D4A5A5'];
    
    ctx.clearRect(0, 0, 400, 100);
    for(let i=0; i<7; i++) {
        ctx.fillStyle = colors[i];
        ctx.fillRect(i*50 + 10, 10, 40, 40);
        ctx.fillStyle = '#000';
        ctx.font = '20px retro';
        ctx.fillText(state[i], i*50 + 25, 35);
    }
}

// 音效触发逻辑
function playSound(type) {
    const sfx = {
        update: new Audio('data:audio/wav;base64,UklGRl9...'), 
        big_prime: new Audio('data:audio/wav;base64,UklGRk9...')
    };
    sfx[type].currentTime = 0;
    sfx[type].play();
}
```

---

7. **个人心得摘录**  
> "调试时发现大质数处理必须按质数大小排序，否则会重复计算贡献。这个坑让我花了3小时查数据生成器才找到" —— AquariusZhao  
> "突然意识到可以独立处理每个大质数，就像背包问题中的分组处理，这个顿悟让代码量减少了一半" —— GreenDay  

---

8. **扩展思考**  
当s_i范围扩大到1e5时，可通过以下优化应对：  
1. 质数筛预处理每个数的最大质因子  
2. 离散化质数指数状态，使用哈希表存储有效状态  
3. 采用莫比乌斯反演将lcm求和转化为gcd计算

---
处理用时：80.93秒
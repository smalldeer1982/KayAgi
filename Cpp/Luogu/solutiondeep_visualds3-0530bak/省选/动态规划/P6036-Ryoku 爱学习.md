# 题目信息

# Ryoku 爱学习

## 题目背景

Ryoku 继承了 Riri 在学习方面的天赋，所以她非常热爱学习。但是，不管再怎么热爱学习，Ryoku 也会疲倦的。

## 题目描述

Ryoku 在第 $i$ 时刻会了解到有一个新知识 $i$，这个新知识的实际价值为 $w_i$，由于 Ryoku 爱学习，所以她不会选择不学习知识，但她只有 $p_i$ 的概率能成功掌握这个知识。

然而如果 Ryoku 同时掌握了太多知识，由于 Ryoku 内心的疲倦等因素，Ryoku 感受到的对知识的喜爱程度会改变，我们用一个数值 $R$ 来描述**喜爱程度**的大小。具体而言，设 $R=f(l,r)$ 代表 Ryoku **连续掌握**时刻 $l$ 至时刻 $r$ 的知识时对这些知识的喜爱程度的总和，有参数 $a, b$（$0 < a, b<1$），则有：

$$ f(l,r)=a^{b(r-l)}  \sum_{i=l}^r w_i$$

Ryoku 想要知道她期望能**掌握的每一段连续时刻的知识**的喜爱程度之和是多少（需要注意的是，这里所说的连续时刻的知识不能被一段更长的所包含）。你能帮帮她吗？


## 说明/提示

**【样例 1 说明】**

掌握知识 $1$、知识 $2$、知识 $3$ 时，每一段连续掌握知识的喜爱程度之和为 $\left(\dfrac 12\right)^{\frac12\times 2}(2+3+3)=4$。

掌握知识 $1$、知识 $2$ 时，每一段连续掌握知识的喜爱程度之和为 $\left(\dfrac 12\right)^{\frac12\times 1}(2+3)=\dfrac {5\sqrt2}2\approx 3.536$。

掌握知识 $1$、知识 $3$ 时，每一段连续掌握知识的喜爱程度之和为 $\left(\dfrac 12\right)^{\frac12\times 0}\times 2 +\left(\dfrac 12\right)^{\frac12\times 0}\times 3  = 5$。

掌握知识 $2$、知识 $3$ 时，每一段连续掌握知识的喜爱程度之和为 $\left(\dfrac 12\right)^{\frac12\times 1}(3+3)=3\sqrt 2\approx 4.243$。

只掌握知识 $1$ 时，每一段连续掌握知识的喜爱程度之和为 $\left(\dfrac 12\right)^{\frac12\times 0}\times 2  = 2$。

只掌握知识 $2$ 时，每一段连续掌握知识的喜爱程度之和为 $\left(\dfrac 12\right)^{\frac12\times 0}\times 3  = 3$。

只掌握宝物 $3$ 时，每一段连续掌握知识的喜爱程度之和为 $\left(\dfrac 12\right)^{\frac12\times 0}\times 3  = 3$。

什么都不掌握时，每一段连续掌握知识的喜爱程度之和为 $0$。

以上 $8$ 种情况出现的概率均为 $\dfrac 18$，所以答案约为：

$$(4+3.536+5+4.243+2+3+3+0)\times \dfrac 18\approx3.0973$$

---

**【数据规模与约定】**

对于 $20\%$ 的数据，$n \le 18$。  
对于另外 $15\%$ 的数据，$w_i = 1$。  
对于 $55\%$ 的数据，$n \le 10^3$。  
对于另外 $15\%$ 的数据，$w_i = 1$。  
对于另外 $15\%$ 的数据，$b_i \le 0.2$。  

此外，对于 $100\%$ 的数据，$0<n\le10^5$，$0<a,b,p_i<1$，$0<w_i\le10^3$。保证输入数据的精度不超过 $10^{-2}$。

**本题使用 Special Judge，如果某个测试点中你的答案与标准答案相差小于等于 $10^{-3}$，你就可以通过该测试点。**


## 样例 #1

### 输入

```
3 0.5 0.5
2 3 3
0.5 0.5 0.5
```

### 输出

```
3.097```

## 样例 #2

### 输入

```
6 0.8 0.2
1 1 4 5 1 4
0.9 0.6 0.7 0.7 0.6 0.8
```

### 输出

```
10.521```

# AI分析结果



0. **题目翻译**

# Ryoku 爱学习

## 题目背景

Ryoku 继承了 Riri 在学习方面的天赋，因此她非常热爱学习。但是，不管再怎么热爱学习，Ryoku 也会疲倦的。

## 题目描述

Ryoku 在第 $i$ 时刻会了解到一个新知识 $i$，这个新知识的实际价值为 $w_i$，由于 Ryoku 爱学习，所以她不会选择不学习知识，但她只有 $p_i$ 的概率能成功掌握这个知识。

然而如果 Ryoku 同时掌握了太多知识，由于疲倦等因素，Ryoku 感受到的对知识的喜爱程度会改变，用数值 $R$ 描述**喜爱程度**的大小。具体而言，设 $R=f(l,r)$ 代表 Ryoku **连续掌握**时刻 $l$ 至时刻 $r$ 的知识时对这些知识的喜爱程度总和，有参数 $a, b$（$0 < a, b<1$），则有：

$$ f(l,r)=a^{b(r-l)}  \sum_{i=l}^r w_i$$

Ryoku 想知道她期望能**掌握的每一段连续时刻的知识**的喜爱程度之和是多少（连续时刻的知识不能被更长的包含）。请帮她计算。

---

1. **算法分类**  
**线性DP**

---

2. **综合分析与结论**

### 核心思路
通过线性DP维护两个关键状态：
- **t[i]**：以 i 结尾的连续区间贡献的系数
- **f[i]**：包含 i 的连续区间总贡献

状态转移方程：
```
t[i] = a^b * p[i] * t[i-1] + p[i] * (1-p[i-1])
f[i] = a^b * p[i] * f[i-1] + w[i] * t[i]
ans = Σ (1-p[i+1])*f[i]
```

### 关键难点
- **连续区间的独立性**：需要将连续掌握概率分解为左右边界概率乘积
- **指数衰减因子**：a^b 的幂次处理转化为线性递推
- **状态转移设计**：通过拆分连续区间的扩展过程，将 O(n²) 复杂度降为 O(n)

### 可视化设计
**动态规划矩阵动画：**
- 用双行网格展示 t[] 和 f[] 数组的更新过程
- 当前计算的单元格高亮为黄色，前序单元格标记为淡蓝色
- 指数衰减因子 a^b 用渐变色箭头表示转移方向
- 每一步播放 8-bit 电子音效，更新成功时触发"滴"声

**复古像素风格：**
- 采用 FC 红白机配色的 16 色调色板
- 状态值用 8x8 像素块显示，数值映射为颜色亮度
- 背景循环播放《超级马里奥》风格 MIDI 音乐

---

3. **题解清单 (4星及以上)**

### [z7z_Eta] ⭐⭐⭐⭐⭐
- **亮点**：最简洁的状态定义，数学推导清晰
- **代码**：仅用两个递推变量，空间O(1)
- **优化**：将 a^b 预计算减少重复调用

### [hhoppitree] ⭐⭐⭐⭐
- **亮点**：滚动数组优化空间至O(1)
- **技巧**：输入优化提升效率，避免浮点陷阱

### [JohnVictor] ⭐⭐⭐⭐
- **亮点**：拆分贡献为左右部分，双状态并行递推
- **心得**：调试时发现边界处理的重要性

---

4. **核心代码实现**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
double p[maxn],a_b,f,t,ans;

int main(){
    int n; scanf("%d%lf%lf",&n,&a_b,&a_b);
    a_b = pow(a_b, a_b); // 预计算a^b
    
    vector<int> w(n+1);
    for(int i=1;i<=n;i++) scanf("%d",&w[i]);
    
    double p_prev=0, p_curr, p_next;
    scanf("%lf",&p_curr);
    
    for(int i=1;i<=n;i++){
        if(i<n) scanf("%lf",&p_next);
        else p_next=0;
        
        t = a_b * p_curr * t + p_curr * (1-p_prev);
        f = a_b * p_curr * f + t * w[i];
        ans += (1-p_next) * f;
        
        p_prev = p_curr;
        p_curr = p_next;
    }
    printf("%.3lf",ans);
    return 0;
}
```

---

5. **相似题目推荐**
- **P1654 OSU!**：期望型线性DP，分段贡献计算
- **P1365 WJMZBMR打osu!**：连续区间期望计算
- **P6046 期望硬币**：概率与期望的复合问题

---

6. **可视化代码片段（Canvas 动画）**

```javascript
// 初始化像素网格
const grid = new PixelGrid(800, 200, 16); 

function animateDP() {
    let t = 0, f = 0;
    grid.highlightCell(0, 0, 'blue'); // t 初始位置
    grid.highlightCell(1, 0, 'green');// f 初始位置

    for(let i=1; i<=n; i++) {
        // 更新t值动画
        grid.drawArrow(i-1, 0, i, 0, 'yellow');
        t = a_b * p[i] * t + p[i] * (1-p[i-1]);
        grid.updateCell(i, 0, t.toFixed(2));

        // 更新f值动画
        grid.drawArrow(i-1, 1, i, 1, 'cyan'); 
        f = a_b * p[i] * f + t * w[i];
        grid.updateCell(i, 1, f.toFixed(2));

        // 播放8-bit音效
        playSound('blip', 500 + i*20);
        await sleep(300); // 步进延迟
    }
}
```

---

7. **个人心得摘录**
> "调试时发现浮点精度问题，改用 long double 后通过。关键点在于理解连续区间的独立性，将指数衰减转化为递推式中的乘积因子。" —— JohnVictor  
> "最初想用二维DP，后来发现状态可以压缩。滚动数组优化后内存占用减少80%" —— hhoppitree

---
处理用时：80.68秒
# 题目信息

# [NOI Online #1 入门组] 魔法

## 题目描述

C 国由 $n$ 座城市与 $m$ 条有向道路组成，城市与道路都从 $1$ 开始编号，经过 $i$ 号道路需要 $t_i$ 的费用。

现在你要从 $1$ 号城市出发去 $n$ 号城市，你可以施展最多 $k$ 次魔法，使得通过下一条道路时，需要的费用变为原来的相反数，即费用从 $t_i$ 变为 $-t_i$。请你算一算，你至少要花费多少费用才能完成这次旅程。

注意：使用魔法只是改变一次的花费，而不改变一条道路自身的 $t_i$；最终的费用可以为负，并且一个城市可以经过多次（包括 $n$ 号城市）。 

## 说明/提示

#### 输入输出样例 1 解释

依次经过 $1$ 号道路、$2$ 号道路、$3$ 号道路，并在经过 $1,2$ 号道路前使用魔法。 

#### 输入输出样例 2 解释

依次经过 $1$ 号道路、$2$ 号道路、$1$ 号道路，并在两次经过 $1$ 号道路前都使用魔法。 

#### 数据规模与约定

本题共 $20$ 个测试点，各测试点信息见下表。

| 测试点编号 | $n \leq$ | $m \leq$ | $k \leq$ | 无环 |
| :----------: | :--------: | :---------: | :--------: | :----: |
| $1 \sim 2$ | $5$ | $20$ | $0$ | 不保证 |
| $3 \sim 4$ | $10$ | $20$ | $50$ | 不保证 |
| $5 \sim 6$ | $10$ | $20$ | $0$| 不保证 |
| $7 \sim 8$ | $20$ | $200$ | $50$ | 是 |
| $9 \sim 10$ | $20$ | $200$ | $0$ | 不保证 |
| $11 \sim 12$ | $100$ | $200$ | $50$ | 是 |
| $13 \sim 14$ | $100$ | $200$ | $50$ | 不保证 |
| $15 \sim 18$ | $100$ | $2500$ | $1000$ | 不保证 |
| $19 \sim 20$ | $100$ | $2500$ | $10^6$ | 不保证 |

对于【无环】一栏为“是”的测试点，保证给出的图是一张有向无环图，否则不对图的形态做任何保证。

对于全部的测试点，保证：
- $1 \leq n \leq 100$，$1 \leq m \leq 2500$，$0 \leq k \leq 10^6$。
- $1 \leq u_i, v_i \leq n$，$1 \leq t_i \leq 10^9$。
- 给出的图无重边和自环，且至少存在一条能从 $1$ 到达 $n$ 的路径。

**民间数据使用 [CYaRon](https://github.com/luogu-dev/cyaron) 在 5 分钟内生成。如果发现数据有问题，请在讨论版发帖或私信 @[StudyingFather](/user/22030)**

## 样例 #1

### 输入

```
4 3 2
1 2 5
2 3 4
3 4 1
```

### 输出

```
-8```

## 样例 #2

### 输入

```
2 2 2
1 2 10
2 1 1
```

### 输出

```
-19```

# AI分析结果



# 中文题目翻译

## [NOI Online #1 入门组] 魔法

### 题目描述

C 国由 $n$ 座城市与 $m$ 条有向道路组成，城市与道路都从 $1$ 开始编号，经过 $i$ 号道路需要 $t_i$ 的费用。

现在你要从 $1$ 号城市出发去 $n$ 号城市，你可以施展最多 $k$ 次魔法，使得通过下一条道路时，需要的费用变为原来的相反数，即费用从 $t_i$ 变为 $-t_i$。请你算一算，你至少要花费多少费用才能完成这次旅程。

注意：使用魔法只是改变一次的花费，而不改变一条道路自身的 $t_i$；最终的费用可以为负，并且一个城市可以经过多次（包括 $n$ 号城市）。

### 输入输出样例

#### 样例 #1
输入：
```
4 3 2
1 2 5
2 3 4
3 4 1
```
输出：
```
-8
```

#### 样例 #2
输入：
```
2 2 2
1 2 10
2 1 1
```
输出：
```
-19
```

### 数据规模与约定
各测试点数据规模详见原题表格，其中 $1 \leq n \leq 100$，$1 \leq m \leq 2500$，$0 \leq k \leq 10^6$。

---

# 唯一算法分类：线性DP

# 综合分析与结论

## 核心思路解析
1. **Floyd预处理**：首先计算不使用魔法时的任意两点间最短路径
2. **状态转移矩阵构建**：定义广义矩阵乘法，将状态转移转化为矩阵运算（加法变取min，乘法变加法）
3. **快速幂优化**：通过矩阵快速幂在 $O(n^3 \log k)$ 时间内处理大范围的k值

## 可视化设计思路
**动画方案**：
1. 使用双矩阵对比展示
   - 左侧矩阵显示原始最短路径
   - 右侧矩阵显示施加魔法后的状态转移
2. 颜色编码：
   - 红色高亮当前更新的单元格
   - 绿色箭头表示中转点的选择路径
3. 步进控制：
   - 单步执行展示矩阵乘法中每个元素的更新过程
   - 快速切换显示不同魔法次数的状态

**复古像素风格**：
1. 8位机风格的网格界面
2. 每个单元格用16x16像素块表示
3. 音效设计：
   - "滴"声表示状态转移
   - 上升音调表示找到更优解
   - 背景播放FC风格BGM

# 题解清单（≥4星）

## 1. gaozitao1（★★★★★）
**亮点**：
- 完整呈现从暴力到正解的演进过程
- 详细推导矩阵乘法的状态转移方程
- 包含各分数段的实现代码

## 2. StudyingFather（★★★★☆）
**亮点**：
- 使用分层图思想解释状态转移
- 代码结构简洁，注释清晰
- 通过结构体实现矩阵运算

## 3. gznpp（★★★★）
**亮点**：
- 提出时间复杂度优化至 $O(nm)$ 的关键技巧
- 矩阵初始化方法极具启发性
- 代码包含详细中文注释

# 核心代码实现

## 矩阵快速幂核心代码
```cpp
struct Matrix {
    long long m[N][N];
    Matrix operator*(const Matrix &b) const {
        Matrix res;
        memset(res.m, 0x3f, sizeof res.m);
        for(int k=1; k<=n; ++k)
        for(int i=1; i<=n; ++i)
        for(int j=1; j<=n; ++j)
            res.m[i][j] = min(res.m[i][j], m[i][k] + b.m[k][j]);
        return res;
    }
};

Matrix qpow(Matrix base, int k) {
    Matrix res = base; // 初始化为原始最短路径
    while(k) {
        if(k & 1) res = res * base;
        base = base * base;
        k >>= 1;
    }
    return res;
}
```

## Floyd预处理代码
```cpp
// 初始化邻接矩阵
for(int i=1; i<=n; ++i)
    for(int j=1; j<=n; ++j)
        if(i != j) d[i][j] = INF;

// 标准Floyd算法
for(int k=1; k<=n; ++k)
for(int i=1; i<=n; ++i)
for(int j=1; j<=n; ++j)
    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
```

# 同类型题目推荐
1. P1938 道路重建（矩阵快速幂应用）
2. P2886 牛继电器（状态转移优化）
3. P2113 看球泡面（带限制的最短路）

# 可视化关键实现

## Canvas绘制逻辑
```javascript
function drawMatrix(ctx, matrix) {
    const CELL_SIZE = 30;
    for(let i=0; i<matrix.length; i++) {
        for(let j=0; j<matrix[i].length; j++) {
            ctx.fillStyle = getColorByValue(matrix[i][j]);
            ctx.fillRect(j*CELL_SIZE, i*CELL_SIZE, CELL_SIZE, CELL_SIZE);
            ctx.strokeStyle = '#000';
            ctx.strokeRect(j*CELL_SIZE, i*CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
    }
}
```

## 音效触发逻辑
```javascript
function playSound(type) {
    const sounds = {
        update: new Audio('data:audio/wav;base64,UklGRl9...'), // 短促滴声
        optimal: new Audio('data:audio/wav;base64,UklGRk9...') // 上升音调
    };
    sounds[type].play();
}
```

# 总结与提升
本题的突破点在于将看似复杂的状态转移转化为可快速计算的矩阵运算，这种将图论问题转化为代数运算的思路在竞赛中具有广泛应用。掌握广义矩阵乘法的证明方法（尤其是结合律的证明）是深入理解此类问题的关键。

---
处理用时：81.41秒
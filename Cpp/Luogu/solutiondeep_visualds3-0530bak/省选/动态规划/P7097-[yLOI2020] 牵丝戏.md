# 题目信息

# [yLOI2020] 牵丝戏

## 题目背景

> 风雪依稀秋白发尾， 灯火葳蕤，揉皱你眼眉。  
> 假如你舍一滴泪，假如老去我能陪。  
> 烟波里成灰，也去得完美。 

——银临 & Aki阿杰《牵丝戏》

## 题目描述

扶苏和扶咕咕最近在玩一款叫做「ddt」的游戏，因为玩「ddt」时一直在循环《牵丝戏》，所以想到牵丝戏就想到了这个游戏。

为了简化问题，我们认为这是一款一对一回合制游戏。双方玩家各有一个属性，被称为 delay 值，简称 $d$ 值。$d$ 值会根据回合中玩家使用的道具类型和数量来进行相应的增加。我们定义玩家 $x$ 的回合为玩家 $x$ 从发动攻击到结束的整个过程。**在玩家 $x$ 的回合中，只有玩家 $x$ 可以使用道具和发动攻击，并且玩家 $x$ 一定会发动攻击**。当一个玩家的回合结束以后，下一回合将是两个玩家中 $d$ 值**较小**的玩家的回合。当两个玩家的 $d$ 值相同时，因为扶苏氪金很多，下一回合一定是**扶苏的回合**。

这款游戏共有 $m$ 种道具，第 $i$ 种道具会将本回合的伤害增加**不计算其他道具的原始伤害**的 $\frac{k_i}{10^5}$ 倍，同时会增加 $p_i$ 点 $d$ 值。每回合**每种道具只能使用一次，本回合的道具不会对下回合产生伤害增益效果**。同时，每回合结束以后，发动攻击的玩家一定会增加 $w$ 点 $d$ 值。

而使用道具是受到双方 $d$ 值差限制的。具体的，任何回合所使用的道具应该满足本回合结束以后双方 $d$ 值（包括发动攻击的玩家一定增加的 $w$ 点 $d$ 值）之差的绝对值**不超过** $100$。一个显然的事实是，只要保证了 $w \le 100$，玩家就一定存在一种选择道具的方法（包括不选择），来满足这个限制。

例如，在扶咕咕的回合中，若她的原始伤害 $t=10^5$，初始时 $d$ 值 $d_0=3$，规定 $w=2$，她使用了两个道具，$k_1=114$，$k_2=514$，$p_1=19$，$p_2=81$，那么本回合她造成的伤害为 

$$t + t \times k_1 + t \times k_2 = 10^5 + 114 + 514 =  100628$$

她回合结束后的 $d$ 值为

$$d_0 + w + p_1 + p_2 = 3 + 2 + 19 + 81 = 105$$

而假如下回合还是她的回合，并且她没有使用道具，那么她下回合造成的伤害为 

$$t =  100000$$

她下回合结束后的 $d$ 值为 

$$105 + w = 105 + 2 = 107$$

现在扶苏和扶咕咕正在对战。给定游戏的道具列表，和他们的原始伤害、 $d$ 值。游戏一共会进行 $n$ 回合，不妨认为无论造成多大的伤害，双方都不会死亡。请你最大化「扶苏对扶咕咕造成的伤害 - 扶咕咕对扶苏造成的伤害」这个差的值。

当然，扶咕咕也会尽可能最大化「她对扶苏造成伤害 - 扶苏对她造成伤害」的值。不妨认为扶苏是 yLOI 世界中最聪明的男孩子，扶咕咕是 yLOI 世界中最聪明的女孩子，也就是**他们都会选择最优的策略来使用道具而不会出错**，题目所求即为在这种情况下伤害差的最大值。

## 说明/提示

### 样例 1 解释

- 第一回合开始前，扶苏 $d$ 值为 $2$，扶咕咕 $d$ 值为 $3$，第一回合由扶苏出手。扶苏不使用道具，伤害为 $100000$，$d$ 值增加 $1$，总伤害差为 $100000$。
- 第一回合结束后，双方 $d$ 值均为 $3$，第二回合由扶苏出手。扶苏使用第一个道具，伤害为 $100050$，$d$ 值增加 $21$，总伤害差为 $200050$。
- 第二回合结束后，扶苏 $d$ 值为 $24$，扶咕咕 $d$ 值为 $3$，第三回合由扶咕咕出手。扶咕咕使用 $1$ 、 $2$ 两个道具，伤害为 $200102$，$d$ 值增加 $121$，总伤害差为 $-52$。这回合结束后，双方 $d$ 值差恰好为 $100$，符合要求。

### 数据规模与约定


**本题采用多测试点捆绑测试**。

- 子任务 $1$（$5$ 分）：保证 $n=0$。
- 子任务 $2$（$10$ 分）：保证 $m=0$。
- 子任务 $3$（$15$ 分）：保证 $n,m \le 5$。
- 子任务 $4$（$20$ 分）：保证 $n \le 3$。
- 子任务 $5$（$20$ 分）：保证 $m \le 10$。
- 子任务 $6$（$30$ 分）：无特殊约定。

对于全部的测试点，保证 $0 \le n \le 10^3$，$0 \le m \le 10^5$，$1 \le p_i,w \le 100$，$1 \le x_a,x_b,k_a,d_a,d_b \le 10^9$，$x_a$ 与 $x_b$ 是 $10^5$ 的倍数，$1 \le |d_a-d_b| \le 100$。

### 提示

共有 4 个样例文件，请见附加文件中的 opera.zip。  
对于样例 2，满足 $m = 0$。  
对于样例 3，满足 $n \leq 3$。

## 样例 #1

### 输入

```
0
3 2 1
50 1
20 100
100000 200000 2 3```

### 输出

```
-52```

# AI分析结果



## 题目重写
# [yLOI2020] 牵丝戏

### 题目背景

> 风雪依稀秋白发尾，灯火葳蕤，揉皱你眼眉。  
> 假如你舍一滴泪，假如老去我能陪。  
> 烟波里成灰，也去得完美。

——银临 & Aki阿杰《牵丝戏》

### 题目描述

扶苏和扶咕咕在玩回合制游戏「ddt」，双方拥有 delay 值（d 值）。每回合由 d 值较小的一方行动（相同时扶苏先动），行动方必定发动攻击，并可通过道具提升伤害。道具使用规则：
1. 每个道具每回合只能使用一次
2. 本回合结束后双方 d 值差绝对值 ≤ 100（保证 w ≤ 100）
3. 攻击后自动增加 w 点 d 值

道具效果：
- 第 i 种道具使伤害增加原始伤害的 k_i/1e5 倍
- 使用后增加 p_i 点 d 值

给定初始 d 值、原始伤害（均为 1e5 的倍数）和 n 回合游戏，求扶苏与扶咕咕的伤害差最大值（双方均采取最优策略）。

### 输入格式
输入包含道具参数、初始值等，详见原题。

### 输出格式
输出最终伤害差。

### 样例
样例输入及解释见原题。

---

## 算法分类
**线性DP + 0-1背包**

---

## 综合分析与结论

### 核心思路
1. **背包预处理**：将道具选择建模为 0-1 背包问题，预处理出各 delay 增量对应的最大伤害增益
2. **博弈DP**：通过二维状态表示回合数与 d 值差，交替使用 max/min 策略模拟双方最优决策

### 解决难点
1. **状态设计**：`dp[i][j]` 表示第 i 回合开始时 d 值差为 j 的最大伤害差
2. **转移方程**：
   - 扶苏回合：`dp[i][j] = max(dp[i+1][j + w + k] + 增益)`
   - 扶咕咕回合：`dp[i][j] = min(dp[i+1][j - w - k] - 增益)`
3. **背包优化**：预处理 f 数组存储每个 delay 增量的最大增益，时间复杂度 O(m*200)

### 可视化设计
1. **像素化 DP 矩阵**：用 Canvas 绘制 200x200 网格，每个单元格表示特定回合的 d 值差状态
2. **动画效果**：
   - 红色箭头表示扶苏回合的 max 转移
   - 蓝色箭头表示扶咕咕回合的 min 转移
   - 当前激活的单元格用黄色边框高亮
3. **音效系统**：
   - 成功转移时播放 8-bit 上升音效
   - 边界条件触发时播放警示音

---

## 题解清单 (4.5星)

### 一扶苏一（4.5星）
**亮点**：
1. 双 DP 结构清晰分离背包与博弈
2. 差值偏移处理巧妙（+100 转非负下标）
3. 时间复杂度 O(m*200 + n*200²) 高效

### 烟灬（4星）
**亮点**：
1. 详细注释帮助理解博弈逻辑
2. 显式处理 100 分界点增强可读性
3. 初始化设置规范，避免溢出

---

## 核心代码实现

### 背包预处理
```cpp
std::fill(f, f + maxt, -INF);
f[w] = 100000; // 基础增益
for (int i = 1; i <= m; ++i) 
  for (int j = 200; j >= p[i]; --j)
    f[j] = max(f[j], f[j - p[i]] + k[i]);
```

### 博弈DP转移
```cpp
for (int i = n; i >= 1; --i) {
  for (int j = 0; j <= 200; ++j) {
    if (j <= 100) { // 扶苏回合
      dp[i][j] = -INF;
      for (int k = 0; k <= 200 - j - w; ++k)
        dp[i][j] = max(dp[i][j], dp[i+1][j + w + k] + f[k] * xa);
    } else { // 扶咕咕回合
      dp[i][j] = INF;
      for (int k = 0; k <= j - w; ++k)
        dp[i][j] = min(dp[i][j], dp[i+1][j - w - k] - f[k] * xb);
    }
  }
}
```

---

## 同类题目推荐
1. P2585（三色二叉树） - 树形DP与最优策略
2. P1434（滑雪） - 记忆化搜索与状态转移
3. P1880（石子合并） - 环形区间DP

---

## 可视化方案

### 动画设计
```javascript
class DPViz {
  constructor() {
    this.grid = new PixelGrid(200, 200); // 像素网格
    this.currentRound = n;
    this.sound = new EightBitSound();
  }

  renderFrame() {
    for (let j = 0; j <= 200; j++) {
      const cell = this.grid.getCell(this.currentRound, j);
      if (j <= 100) cell.setBorder('red'); // 扶苏回合
      else cell.setBorder('blue'); // 扶咕咕回合
      
      cell.setValue(dp[currentRound][j]);
      if (isUpdating) cell.flash(); // 更新时闪烁
    }
    this.sound.playStateChange();
  }
}
```

---

## 关键技巧
1. **偏移量技巧**：将差值 j ∈ [-100,100] 映射到 [0,200] 避免负数下标
2. **逆向DP**：从最后一回合倒推，确保所有转移可达
3. **伤害预缩放**：将初始伤害除以 1e5 避免浮点运算

---

## 个人心得
> "初始状态设置需要特别注意偏移量，调试时通过打印中间状态发现差值为负数时未做偏移导致数组越位。博弈DP的关键在于理解双方策略的对称性，max和min的交替使用完美体现了零和博弈的特性。" —— 摘自题解调试笔记

---
处理用时：88.33秒
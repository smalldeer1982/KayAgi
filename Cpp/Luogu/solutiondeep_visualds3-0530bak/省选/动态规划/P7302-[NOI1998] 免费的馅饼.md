# 题目信息

# [NOI1998] 免费的馅饼

## 题目描述

SERKOI 最新推出了一种叫做“免费馅饼”的游戏：游戏在一个舞台上进行。舞台的宽度为 $w$ 格（从左到右依次用 $1$ 到 $w$ 编号），游戏者占一格。开始时游戏者可以站在舞台的任意位置，手里拿着一个托盘。下图为天幕的高度为 $4$ 格时某一个时刻游戏者接馅饼的情景。

![](https://cdn.luogu.com.cn/upload/image_hosting/1gcg9awi.png)

游戏开始后，从舞台天幕顶端的格子中不断出现馅饼并垂直下落。游戏者左右移动去接馅饼。游戏者每秒可以向左或向右移动一格或两格，也可以站在原地不动。

当馅饼在某一时刻恰好到达游戏者所在的格子中，游戏者就收集到了这块馅饼。当馅饼落在一个游戏者不在的格子里时该馅饼就消失。

写一个程序，帮助我们的游戏者收集馅饼，使得所收集馅饼的分数之和最大。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq w \leq 10^8$，$1 \leq n \leq 10^5$，$1\leq t_i \leq 10^8$，$1\leq p_i \leq w$，$1\leq v_i \leq 1000$。

## 样例 #1

### 输入

```
3 4
1 2 3
5 2 3
6 3 4
1 1 5
 ```

### 输出

```
12```

# AI分析结果



0. **题目翻译**

---

### [NOI1998] 免费的馅饼

#### 题目描述

SERKOI 最新推出了一种叫做“免费馅饼”的游戏：游戏在一个舞台上进行。舞台的宽度为 $w$ 格（从左到右依次用 $1$ 到 $w$ 编号），游戏者占一格。开始时游戏者可以站在舞台的任意位置，手里拿着一个托盘。下图为天幕的高度为 $4$ 格时某一个时刻游戏者接馅饼的情景。

![](https://cdn.luogu.com.cn/upload/image_hosting/1gcg9awi.png)

游戏开始后，从舞台天幕顶端的格子中不断出现馅饼并垂直下落。游戏者左右移动去接馅饼。游戏者每秒可以向左或向右移动一格或两格，也可以站在原地不动。

当馅饼在某一时刻恰好到达游戏者所在的格子中，游戏者就收集到了这块馅饼。当馅饼落在一个游戏者不在的格子里时该馅饼就消失。

写一个程序，帮助我们的游戏者收集馅饼，使得所收集馅饼的分数之和最大。

#### 输入格式

第一行是用空格隔开的两个正整数 $w$ 和 $n$。  
接下来 $n$ 行，每一行给出了一块馅饼的信息。由三个正整数组成，分别表示了每个馅饼落到舞台上的时刻 $t_i$，掉到舞台上的格子的编号 $p_i$，以及分值 $v_i$。

#### 输出格式

一个数，表示游戏者获得的最大总得分。

#### 样例输入 #1

```
3 4
1 2 3
5 2 3
6 3 4
1 1 5
```

#### 样例输出 #1

```
12
```

---

### 1. 唯一算法分类
**线性DP**

---

### 2. 综合分析与结论

#### 核心思路与难点解析
**核心难点**：将移动约束条件转化为二维偏序问题，并通过排序和树状数组优化动态规划。

**算法步骤**：
1. **状态定义**：$f[i]$ 表示接到第 $i$ 个馅饼时的最大得分。
2. **转移条件**：$|p_i-p_j| \leq 2(t_i-t_j)$，拆解为两个不等式：
   - $2t_i - p_i \geq 2t_j - p_j$（处理左移）
   - $2t_i + p_i \geq 2t_j + p_j$（处理右移）
3. **优化手段**：
   - 按 $2t_i-p_i$ 排序，固定一维偏序
   - 离散化 $2t_i+p_i$，用树状数组维护最大值

**可视化设计**：
- **动态显示排序过程**：按 $2t-p$ 降序排列馅饼，红色高亮当前处理的馅饼
- **树状数组更新动画**：绿色标记当前更新的节点，黄色显示查询路径
- **像素化风格**：用 8-bit 色块表示 DP 状态值，转移时播放经典 FC 音效

---

### 3. 题解清单（≥4星）

1. **xiezheyuan（★★★★☆）**  
   - **亮点**：树状数组优化思路清晰，离散化处理巧妙
   - **关键代码**：
     ```cpp
     sort(a+1,a+n+1,cmp); // 按2t-p排序
     for(int i=1;i<=n;i++) {
         f[i] = query(a[i].x) + a[i].v;
         update(a[i].x, f[i]);
     }
     ```

2. **SSL_TJH_蒟蒻（★★★★☆）**  
   - **亮点**：二维偏序解释透彻，变量命名规范
   - **心得**："将坐标系旋转后转化为LIS问题，但需注意浮点误差"

3. **Jayun（★★★★☆）**  
   - **亮点**：代码简洁，离散化与树状数组操作高度封装
   - **核心逻辑**：
     ```cpp
     sort(pie+1, pie+1+m); // 按2t+p排序
     for(int i=1;i<=m;i++) 
         dp[i] = ask(a[i].y) + pie[i].v;
     ```

---

### 4. 核心代码实现

**树状数组优化DP实现**：
```cpp
struct Node { int t, p, v, x; };
vector<Node> a;
vector<int> lsh;

// 离散化处理
void init() {
    sort(a.begin(), a.end(), [](auto& a, auto& b) {
        return (2*a.t - a.p) > (2*b.t - b.p);
    });
    for(auto& x : a) lsh.push_back(2*x.t + x.p);
    sort(lsh.begin(), lsh.end());
    lsh.erase(unique(lsh.begin(), lsh.end()), lsh.end());
}

// 树状数组查询最大值
int query(int x) {
    int res = 0;
    for(; x; x -= x&-x) res = max(res, tr[x]);
    return res;
}

// 动态规划主循环
for(int i=1; i<=n; i++) {
    int pos = lower_bound(lsh.begin(), lsh.end(), 2*a[i].t+a[i].p) - lsh.begin() + 1;
    int val = query(pos) + a[i].v;
    for(; pos <= lsh.size(); pos += pos&-pos) 
        tr[pos] = max(tr[pos], val);
}
```

---

### 5. 同类型题与推荐

1. **P1020 导弹拦截**（最长不升子序列，树状数组优化）
2. **P2782 友好城市**（二维偏序转LIS）
3. **P1970 花匠**（波动序列，树状数组维护极值）

---

### 6. 可视化设计要点

**像素风格实现**：
```javascript
// Canvas初始化
const canvas = document.getElementById('dp-canvas');
const ctx = canvas.getContext('2d');
ctx.fillStyle = '#8B8B83'; // 灰色背景
ctx.fillRect(0, 0, 800, 600);

// 树状数组动画
function drawTree(pos, val) {
    ctx.fillStyle = '#FFD700'; // 金色高亮更新节点
    ctx.fillRect(pos*30, 500-val*5, 25, 25);
    playSound('coin.wav'); // 金币音效
}

// 自动演示模式
let autoPlay = setInterval(() => {
    stepDP(); // 单步执行DP
}, 1000);
```

**音效设计**：
- 状态转移：8-bit "blip" 音效
- 更新最大值：经典 FC 金币音
- 错误操作：短促爆破音

---

### 7. 个人心得摘录

> "**xiezheyuan**：贪心看似能水50分，但无法处理跨多步的最优路径，必须用DP"  
> **SSL_TJH_蒟蒻**：二维偏序条件要同时满足，排序后另一维用数据结构维护是关键  
> **Jayun**：离散化时注意去重，否则树状数组会越界

---

### 8. 扩展思考

**思维突破点**：将移动速度约束转化为几何约束，在坐标系中画出可行区域后，发现可以转化为二维偏序问题。类似思路可用于其他运动约束类题目（如跳跃、滑行等）。

**算法扩展**：当移动速度变为每秒 $k$ 格时，约束条件变为 $|p_i-p_j| \leq k(t_i-t_j)$，此时需重新推导坐标变换公式，但整体思路保持不变。

---
处理用时：86.80秒
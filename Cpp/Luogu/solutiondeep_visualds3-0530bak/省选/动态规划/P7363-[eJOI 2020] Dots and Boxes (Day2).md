# 题目信息

# [eJOI 2020] Dots and Boxes (Day2)

## 题目背景

小 T 和小 A 在玩一种点格游戏。

## 题目描述

首先，小 T 拿出了一张拥有 $(N+1) \times (M+1)$ 个格点的方格纸（这些格子从上到下，从左到右可以编号为第 $1 \sim N+1$ 行第 $1 \sim M+1$ 列的格点），每个格点向上下左右的那个格点（如果那个方向有格点的话）连边，不难发现，会形成一个 $N \times M$ 的方格矩阵。但是小 T 拿出的是没有连边的格点方格纸，小 T 和小 A 的目标就是在格点之间连线。

游戏规则是这样的，每一轮玩家可以在两个格点之间连线，如果连完线能连好一个格子，那么这个格子就属于这个玩家了。然后玩家可以继续连线，直到连完线不能获得格子为止，就换到下一个玩家。当所有玩家都不能连线时，游戏结束。

比如下面这张图即为当 $N=2,M=3$ 时两位玩家可能的连线结果：

![](https://cdn.luogu.com.cn/upload/image_hosting/sngf2kqv.png)

其中虚线为这一轮玩家连的线。

小 A 和小 T 已经玩了许久了，你发现他们现在的方格纸满足每一个格子周围的四条边都有 **$0$ 条或 $2$ 条未被连线**，比如下面这张图就满足要求，上面这张图除了第一幅图也都满足要求：

![](https://cdn.luogu.com.cn/upload/image_hosting/gzoveutp.png)

并且刚好轮到小 A 了。

定义小 A 和小 T 的分数 $S_A,S_T$ 为玩家从现在开始得到的分数，那么整个游戏的分数即为 $S_A-S_T$，小 A 要让整个游戏的分数变得越大越好，小 T 则反之，他们都会按照他们的目标做最优策略。

你要求出他们做最优策略下得到的分数。

## 说明/提示

#### 样例 1 解释

下图为其中一种连线方式，红色为小 A 的操作，蓝色为小 T 的操作：

![](https://cdn.luogu.com.cn/upload/image_hosting/cu0mah7j.png)

#### 样例 2 解释

这个样例为题目描述中的第二个图片。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（20 pts）：给出的输入只包含一个连通块。
- Subtask 2（20 pts）：$N \times M \le 12$。
- Subtask 3（20 pts）：给出的输入只包含两个连通块。
- Subtask 4（20 pts）：$N,M \le 7$。
- Subtask 5（20 pts）：无特殊限制。

对于 $100\%$ 的数据，$3 \le N, M \le 20$，**每一个格子周围的四条边都有 $0$ 条或 $2$ 条未被连线**。

其中一个连通块定义为已连上的边与方格纸的边缘围起来的块，比如说下面这个图有 $5$ 个连通块：

![](https://cdn.luogu.com.cn/upload/image_hosting/6g0pk8w2.png)

注意已被玩家占有的方格不属于任意一个连通块。

#### 说明

翻译自 [eJOI 2020 Day2 C Dots and Boxes](https://ejoi2020.ge/static/assets/Day2/Problems/Game.pdf)。

## 样例 #1

### 输入

```
3 3
000
111
011
110
1010
1000
1001```

### 输出

```
-5```

## 样例 #2

### 输入

```
5 5
00100
10100
11010
00100
01000
11100
011111
001011
101011
110111
100111```

### 输出

```
6```

# AI分析结果



0. **题目重写**  
```markdown
# [eJOI 2020] 点格棋（第二天）

## 题目背景

小 T 和小 A 正在玩一种点格棋游戏。

## 题目描述

初始时，小 T 拿出一张包含 $(N+1) \times (M+1)$ 个格点的方格纸（格点按行从上到下编号为 $1 \sim N+1$，列从左到右编号为 $1 \sim M+1$）。玩家轮流在两个相邻格点间连线，当某玩家连线后形成闭合的 $1 \times 1$ 方格时，该方格归其所有，且该玩家继续操作直到无法形成新方格。当前局面满足每个未完成方格的剩余未连边数为 $0$ 或 $2$，轮到小 A 先手。请计算两人均采取最优策略时的最终得分差 $S_A - S_T$。

## 输入格式

输入包含 $(2N+1)$ 行：
- 前 $N+1$ 行描述水平边的连接状态（0 表示未连，1 表示已连）
- 后 $N$ 行描述垂直边的连接状态

## 输出格式

输出最终得分差。

## 样例 #1

### 输入
```
3 3
000
111
011
110
1010
1000
1001
```

### 输出
```
-5
```

## 数据范围
- $3 \le N, M \le 20$
- 每个未完成方格的剩余未连边数为 0 或 2
```

1. **唯一算法分类**  
线性DP

---

### 综合分析与结论

#### 核心算法与难点
1. **连通块分析**  
   每个连通块是链（开放区域）或环（闭合区域），通过DFS识别并记录其格子数  
   - **链的权值**：格子数  
   - **环的权值**：格子数  
   
2. **动态规划策略**  
   - **状态设计**：`dp[i][j]` 表示处理前i大的链和前j大的环时的最大得分差  
   - **关键转移**：  
     ```python
     # 处理链的情况
     if 链大小≥3: 
         dp[i][j] = max(全拿策略得分, 放弃2格策略得分)
     else:
         dp[i][j] = 全拿策略得分
     # 处理环的情况同理，但放弃4格
     ```
   - **排序优化**：将链和环分别降序排序，确保先处理较小连通块以限制对手收益

#### 可视化设计要点
- **Canvas网格**：二维网格展示DP状态矩阵，每个单元格显示当前链/环处理状态  
- **高亮策略**：用不同颜色标记全拿（红色）和放弃策略（蓝色）的转移路径  
- **音效触发**：状态更新时播放短音效，最优解出现时播放胜利音效  
- **复古像素风格**：  
  - 使用16色调色板，DP格子以8-bit方块呈现  
  - 背景音乐循环播放FC风格BGM  

---

### 题解清单 (4星及以上)

1. **Danno0v0（⭐⭐⭐⭐⭐）**  
   - **亮点**：清晰的状态转移方程注释，分离链/环处理逻辑，降序排序优化  
   - **代码片段**：  
     ```cpp
     if(i){
         if(size_chain[i]>=3) 
             dp[i][j]=-max(size_chain[i]+dp[i-1][j], size_chain[i]-4-dp[i-1][j]);
         else 
             dp[i][j]=-size_chain[i]-dp[i-1][j];
     }
     ```

2. **Kubic（⭐⭐⭐⭐）**  
   - **亮点**：简洁的DFS实现，分离链/环的排序逻辑  
   - **核心代码**：  
     ```cpp
     sort(st[0]+1, st[0]+st[0][0]+1); // 链降序
     sort(st[1]+1, st[1]+st[1][0]+1); // 环降序
     ```

3. **dengyaotriangle（⭐⭐⭐⭐）**  
   - **亮点**：优雅的状态转移设计，注释解释放弃策略的数学意义  
   - **代码片段**：  
     ```cpp
     int nw = max(r[j] + dp[i][j-1], r[j] -4 - (4 + dp[i][j-1]));
     dp[i][j] = max(dp[i][j], -nw);
     ```

---

### 关键代码实现

#### Danno0v0 的 DP 核心逻辑
```cpp
for(int i=0;i<=num1;i++){
    for(int j=0;j<=num2;j++){
        dp[i][j] = -0x7ffffff;
        if(i){
            if(size_chain[i]>=3) 
                dp[i][j] = -max(size_chain[i] + dp[i-1][j], 
                              size_chain[i]-4 - dp[i-1][j]);
            else 
                dp[i][j] = -size_chain[i] - dp[i-1][j];
        }
        if(j){
            dp[i][j] = max(dp[i][j], 
                          -max(size_loop[j] + dp[i][j-1], 
                             size_loop[j]-8 - dp[i][j-1]));
        }
    }
}
```

#### 可视化JS片段（Canvas绘制DP状态）
```javascript
function drawDPGrid() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(let i=0; i<=maxChain; i++){
        for(let j=0; j<=maxLoop; j++){
            ctx.fillStyle = getColor(dp[i][j]); // 根据值选择颜色
            ctx.fillRect(i*30, j*30, 28, 28);
            ctx.fillText(dp[i][j], i*30+5, j*30+15);
        }
    }
}
```

---

### 同类型题目推荐
1. **LeetCode 913. Cat and Mouse** - 博弈论+DP  
2. **洛谷 P2734 [USACO3.3]游戏** - 棋盘博弈最优策略  
3. **Codeforces 786A - Berzerk** - 循环状态博弈DP

---
处理用时：79.58秒
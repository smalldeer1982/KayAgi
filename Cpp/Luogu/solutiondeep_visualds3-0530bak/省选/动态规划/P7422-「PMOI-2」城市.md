# 题目信息

# 「PMOI-2」城市

## 题目描述

P 国有 $N$ 座城市和 $M$ 条无向道路，其中 $1$ 号城市是首都，且任意两座城市都能通过道路互相到达。

现在 P 国要在首都召开 ION。为了建设比赛场地，每个城市都要向首都提供原材料，其中第 $i$ 座城市可以提供类型为 $c_i$ 的原材料。每座城市都会有货车从该城市出发，**沿简单路径**前往首都。如果从城市 $A$ 出发的货车必须经过城市 $B$ ，那么我们称城市 $B$ 在城市 $A$ 到首都的必经之路上。如果对于城市 $A,B,C$，从 $B$ 到 $A$ 的**任意简单路径**与 $C$ 到 $A$ 的**任意简单路径**没有公共边，那么我们称城市 $B$ 和城市 $C$ 关于城市 $A$ 互不影响。

记 $f(A,k)$ 为满足下列所有条件的 $k$ 元集合 $\{B_1,B_2,\cdots B_k\}$ 的个数：

1. 对于任意 $1\leq i \leq k$ 满足 $A\neq B_i$，**城市 $A$ 在城市 $B_i$ 到首都的必经之路上**且城市 $B_i$ 供应的材料与城市 $A$ **不同**。

2. 对于任意 $1\leq i < j \leq k$ 满足 **$B_i$ 与 $B_j$ 关于 $A$ 互不影响**，且 $B_i$ 和 $B_j$ 供应的原材料**相同**。

定义举办 ION 的吸引力为$\sum_{i=1}^N\sum_{k=1}^Kf(i,k)$，其中 $K$ 是给定的常数。

现在，你作为 P 国的首脑，你想要知道这次 ION 的吸引力。

**由于答案可能很大，所以请将答案对 $998244353$ 取模**。

## 说明/提示

【样例解释】

样例中 P 国的地图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/vte597p4.png)

下表中，第 $i$ 行第 $j$ 列表示 $f(i,j)$。

| $4$ | $0$ | $0$ | $0$ |
| -----------: | -----------: | -----------: | -----------:
| $4$ | $0$ | $0$ | $0$ |
| $2$ | $1$ | $0$ | $0$ |
| $1$ | $0$ | $0$ | $0$ |

所以吸引力为 $4+4+2+1+1=12$。

【数据范围】

**本题采用捆绑测试**。

- Subtask1（10pts）：$N,K \le 8$；
- Subtask2（10pts）：$K=1$；
- Subtask3（15pts）：$K=2$；
- Subtask4（15pts）：保证图的形态为一棵树；
- Subtask5（15pts）：$N \le 2000$；
- Subtask6（15pts）：$N \le 4\times 10^4$；
- Subtask7（20pts）：无特殊限制。

对于 $100\%$ 的数据满足，$1\leq N\leq 5\times 10^5$， $1\leq M \leq \min(10^6,\frac{N\times(N-1)}{2})$，$1 \le K \le 20$，$1 \le c_i \le 10^9$。

**温馨提示**：输入量较大，请使用较快的读入方式。


## 样例 #1

### 输入

```
7 7 2
1 2 3 3 1 1 2
1 2
2 3
2 4
3 4
3 5
3 6
4 7```

### 输出

```
12```

# AI分析结果



0. **题目翻译**

# 「PMOI-2」城市

## 题目描述

P 国有 $N$ 座城市和 $M$ 条无向道路，其中 $1$ 号城市是首都，且任意两座城市都能通过道路互相到达。

现在 P 国要在首都召开 ION。每个城市都要向首都提供原材料，其中第 $i$ 座城市可以提供类型为 $c_i$ 的原材料。货车从各城市沿简单路径前往首都。若城市 $B$ 在城市 $A$ 到首都的必经之路上，则称 $B$ 是 $A$ 的必经点。若两城市 $B,C$ 在到达 $A$ 的路径上没有公共边，则称 $B,C$ 关于 $A$ 互不影响。

定义 $f(A,k)$ 为满足以下条件的 $k$ 元集合数量：
1. 集合中每个城市 $B_i$ 的必经点包含 $A$ 且 $c_{B_i} \neq c_A$
2. 任意两个不同元素 $B_i,B_j$ 关于 $A$ 互不影响且 $c_{B_i}=c_{B_j}$

求所有城市在 $1 \le k \le K$ 时的吸引力总和，答案对 $998244353$ 取模。

## 输入格式
第一行三个整数 $N,M,K$  
第二行 $N$ 个整数表示 $c_i$  
接下来 $M$ 行每行两个整数表示道路

---

1. **唯一算法分类**  
多重背包（颜色分组与子树合并具有多重物品特征）

---

2. **综合分析与结论**

**核心思路**：  
利用圆方树将必经点关系转化为树形结构，通过线段树合并维护各子树颜色分布，运用背包DP统计满足条件的集合数。主要解决以下难点：

1. **必经点判定**：通过广义圆方树将原图转化为树结构，必经点对应祖先关系
2. **互不影响判定**：同一颜色节点需分布在不同的子树分支中
3. **高效统计**：对每个节点维护颜色分布，合并子树时使用类似多重背包的转移方式

**关键状态转移**：  
定义 $f_c[i]$ 表示颜色 $c$ 选择 $i$ 个节点的方案数，转移方程为：
```math
f_c[i] = \sum_{j=0}^{i} f_{c}^{(u)}[j] \times f_{c}^{(v)}[i-j]
```
其中 $u,v$ 为合并的两个子树，通过线段树合并实现高效维护

**可视化设计**：  
采用复古像素风格展示圆方树结构：
1. 圆点显示为蓝色方块，方点显示为灰色方块
2. 颜色分布用不同色块在节点右侧显示
3. 合并子树时播放"滴"声效，更新DP数组时对应单元格闪烁红光
4. 自动演示模式下，树节点按DFS序逐个展开合并过程

---

3. **题解清单**

⭐️⭐️⭐️⭐️⭐️ 关怀他人（线段树合并+动态规划）  
亮点：创造性结合圆方树与线段树合并，通过标记系统处理首次合并的特殊情况

⭐️⭐️⭐️⭐️ Su_Zipei（虚树+动态规划）  
亮点：通过虚树优化颜色枚举，减少无效计算

⭐️⭐️⭐️⭐️ LYinMX（DSU on tree）  
亮点：轻量级启发式合并，空间复杂度优化

---

4. **核心代码实现**

```cpp
// 线段树合并核心逻辑
int merge(int x,int y,int l,int r,int c){
    if(!x||!y) return x|y;
    if(l==r){
        if(l==c) { sum[x]+=sum[y]; return x; }
        if(!tag[x]){ // 首次合并初始化DP
            dp[l][0]=1; 
            dp[l][1]=(sum[x]+sum[y])%MOD;
            dp[l][2]=1LL*sum[x]*sum[y]%MOD;
            tag[x]=1;
        }else{ // 后续合并更新DP
            for(int i=K;i>=1;i--)
                dp[l][i]=(dp[l][i]+1LL*dp[l][i-1]*sum[y])%MOD;
        }
        sum[x]+=sum[y];
        return x;
    }
    int mid=(l+r)>>1;
    pushdown(x); pushdown(y);
    ls[x]=merge(ls[x],ls[y],l,mid,c);
    rs[x]=merge(rs[x],rs[y],mid+1,r,c);
    sum[x]=sum[ls[x]]+sum[rs[x]];
    return x;
}
```

---

5. **同类题目推荐**
1. P3384 【模板】树链剖分（树形结构处理）
2. P1600 天天爱跑步（树上路径统计）
3. P5494 【模板】线段树合并

---

6. **可视化关键代码**

```javascript
// 像素动画核心逻辑
class DPViz {
  constructor(canvas) {
    this.gridSize = 20;
    this.colors = ['#000','#f00','#0f0','#00f','#ff0'];
  }

  drawDPGrid(node, dpArr) {
    ctx.fillStyle = this.colors[0];
    ctx.fillRect(node.x, node.y, 100, 100);
    
    dpArr.forEach((val, i) => {
      const y = node.y + i*this.gridSize;
      ctx.fillStyle = val > 0 ? this.colors[1] : this.colors[4];
      ctx.fillRect(node.x, y, this.gridSize, this.gridSize);
      ctx.fillStyle = '#fff';
      ctx.fillText(val, node.x+2, y+12);
    });
  }

  playMergeSound() {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(800, audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + 0.1);
    osc.connect(audioCtx.destination);
    osc.start();
  }
}
```

---

7. **个人心得摘录**

"线段树合并时首次合并的特殊处理是关键——通过tag标记区分首次和后续合并，保证了DP初始值的正确性。调试时发现未清空tmp数组导致状态残留，最终通过归零操作解决。" —— 关怀他人

---

8. **算法演示截图**

（示意图）  
![圆方树结构](https://i.imgur.com/5XrGJk2.png)  
- 红色数字表示当前处理的节点
- 绿色方框显示颜色分布
- 右侧DP数组实时更新数值

---

9. **交互控制面板**

```html
<div class="control-panel">
  <button onclick="togglePlay()">▶️/⏸️</button>
  <input type="range" id="speed" min="1" max="10" value="5">
  <button onclick="step()">⏭️单步</button>
  <select id="algo">
    <option>线段树合并</option>
    <option>虚树优化</option>
  </select>
</div>
```

---
处理用时：88.66秒
# 题目信息

# [Cnoi2021] 绀珠传说

## 题目背景

Cirno 编写了一款新的游戏「绀珠传说 ~ Tales of Cyansis Pearl」。


游戏示例（样例 #1）:

![](https://cdn.luogu.com.cn/upload/image_hosting/pxvo35po.png)

## 题目描述

游戏规则如下:

初始有一个 $n\times n$ 的网格，每个格子内有一颗绀珠。

绀珠共有 $n$ 种颜色，每种颜色的恰有 $n$ 颗，**均匀随机**地分布在 $n\times n$ 的网格中。

每次玩家可以在网格的底端一行选取若干个连续相同颜色的绀珠并将其消除。

消除后，上层绀珠会受重力影响下落。

玩家重复上述操作直至绀珠全部被消除。游戏结束。

现在，Cirno 给定你游戏绀珠传说的一个**均匀随机**的初始局面，求完成游戏的最小步数。

## 说明/提示

对于 $100\%$ 的数据保证 $1 \le n \le 1000$。保证数据**随机生成**。

## 样例 #1

### 输入

```
3
1 1 2
2 3 1
3 2 3```

### 输出

```
5```

## 样例 #2

### 输入

```
5
2 1 4 4 2
2 5 5 1 3
4 1 3 5 1
3 2 5 3 5
1 4 4 2 3```

### 输出

```
15```

# AI分析结果



# 题目翻译  
## [Cnoi2021] 绀珠传说  

### 题目背景  
Cirno 编写了一款新游戏「绀珠传说 ~ Tales of Cyansis Pearl」。  

游戏示例（样例 #1）:  
![](https://cdn.luogu.com.cn/upload/image_hosting/pxvo35po.png)  

### 题目描述  
游戏规则如下：  
初始有一个 $n \times n$ 的网格，每个格子内有一颗绀珠。  
绀珠共有 $n$ 种颜色，每种颜色恰有 $n$ 颗，**均匀随机**地分布在网格中。  

每次玩家可以在网格底端一行选取若干个连续相同颜色的绀珠并将其消除。  
消除后，上层绀珠会受重力影响下落。  
玩家重复上述操作直至绀珠全部被消除，游戏结束。  

现在，给定一个**均匀随机**的初始局面，求完成游戏的最小步数。  

### 输入格式  
第一行输入 $n$，随后 $n$ 行每行 $n$ 个整数表示网格颜色。  

### 输出格式  
输出最小步数。  

### 样例 #1  
**输入**  
```  
3  
1 1 2  
2 3 1  
3 2 3  
```  
**输出**  
```  
5```  

### 数据范围  
$1 \le n \le 1000$，保证数据**随机生成**。  

---

# 算法分类  
**线性DP**  

---

# 综合分析与结论  
## 核心思路  
所有题解均基于以下关键结论：  
**最小操作步数 = $n^2 - \sum_{i=1}^{n-1} \text{LCS}(col_i, col_{i+1})$**  
其中 $\text{LCS}(col_i, col_{i+1})$ 表示相邻两列的最长公共子序列长度。  

## 解决难点  
1. **LCS 的优化计算**  
   - 朴素 LCS 的 $O(n^2)$ 复杂度无法处理 $n=1000$  
   - **数据随机性**：每个颜色在各列的出现次数为 $O(1)$，将问题转换为最长递增子序列（LIS）  
   - 具体实现：  
     - 对相邻两列的相同颜色位置建立映射  
     - 将第二列颜色按顺序展开为位置序列  
     - 用树状数组维护 LIS  

2. **树状数组优化**  
   - 对每个颜色在第一列的位置建立倒序映射  
   - 遍历第二列时，动态维护前缀最大值  

## 可视化设计  
### 动态规划过程演示  
1. **网格展示**  
   - 用 Canvas 绘制两列绀珠，左侧为第一列，右侧为第二列  
   - 相同颜色绀珠间用连线表示可匹配的 LCS 元素  

2. **树状数组操作**  
   - 显示树状数组的二进制结构（高度为 $\log n$ 的树形）  
   - 每次插入新元素时，用红色高亮更新的节点  
   - 当前最大 LIS 长度用动态数字显示  

3. **复古像素风格**  
   - 使用 8-bit 风格的 16 色调色板（如 #FF0000 红、#00FF00 绿）  
   - 绀珠用 16x16 像素方块表示，下落时添加 CRT 扫描线效果  

### 音效设计  
- **匹配成功**：8-bit 风格"哔"声（频率 440Hz，持续 0.1s）  
- **树状数组更新**：短促"滴"声（频率 880Hz，持续 0.05s）  
- **最大长度更新**：上升音阶（C4→E4→G4）  

---

# 题解清单 (4星及以上)  
1. **dead_X 的题解（★★★★☆）**  
   - **亮点**：  
     - 最早提出 LCS→LIS 的转换思路  
     - 代码简洁，利用 `vector` 快速建立颜色映射  
     - 时间复杂度 $O(n^2 \log n)$ 最优  
   - **代码片段**：  
     ```cpp  
     for(int j=1; j<=n; ++j)  
         for(int k:v[i][a[i+1][j]])  
             z.push_back(make_pair(k, find(k-1)));  
     ```  

2. **Tzs_yousa 的题解（★★★★☆）**  
   - **亮点**：  
     - 详细解释"边不相交"的几何意义  
     - 引入偏序关系图解，辅助理解 LIS 的物理意义  
   - **调试心得**：  
     > "最初将行列写反导致 WA，最终通过绘制网格坐标验证映射关系"  

3. **minstdfx 的题解（★★★★☆）**  
   - **亮点**：  
     - 从随机数据的数学期望角度证明复杂度  
     - 提出"颜色出现次数为 $O(1)$"的关键观察  
   - **核心代码**：  
     ```cpp  
     for(auto id:vc) {  
         int v=query(id-1)+1;  
         ans=max(ans,v), update(id,v);  
     }  
     ```  

---

# 代码实现  
## 关键逻辑（dead_X 版）  
```cpp  
vector<int> v[1003][1003]; // v[列号][颜色] = 行位置列表  
for(int i=1; i<n; ++i) {  
    memset(tree, 0, sizeof(tree));  
    int q=0;  
    for(int j=1; j<=n; ++j) {  
        vector<pair<int,int>> z;  
        for(int k : v[i][a[i+1][j]])   
            z.emplace_back(k, find(k-1));  
        for(auto [pos, val] : z) {  
            q = max(q, val+1);  
            add(pos, val+1);  
        }  
    }  
    ans -= q;  
}  
```  

---

# 相似题目推荐  
1. **P1439 最长公共子序列**（LCS→LIS 转换）  
2. **P1776 宝物筛选**（多重背包+单调队列优化）  
3. **P5490 扫描线**（二维偏序问题）  

---

# 可视化代码片段（Canvas 动画）  
```javascript  
class LCSVisualizer {  
    constructor(canvas) {  
        this.ctx = canvas.getContext('2d');  
        this.tree = new Array(n+1).fill(0);  
        // 8-bit 调色板  
        this.colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'];  
    }  

    drawColumn(col, x) {  
        for(let i=0; i<n; i++) {  
            const y = 50 + i*20;  
            this.ctx.fillStyle = this.colors[col[i]-1];  
            this.ctx.fillRect(x, y, 16, 16);  
        }  
    }  

    updateTree(pos, value) {  
        // 树状数组更新动画  
        let idx = pos;  
        while(idx <= n) {  
            this.highlightNode(idx);  
            this.tree[idx] = Math.max(this.tree[idx], value);  
            idx += idx & -idx;  
        }  
    }  
}  
```  

--- 

# 核心思想总结  
1. **降维打击**：将二维网格问题分解为相邻列的线性问题  
2. **随机性利用**：通过颜色分布的稀疏性降低计算复杂度  
3. **数据结构优化**：用树状数组将 LIS 的 $O(n^2)$ 优化为 $O(n \log n)$  

> "数据随机时，不要被暴力算法的理论复杂度吓倒，往往存在隐藏的优化机会" —— minstdfx

---
处理用时：100.50秒
# 题目信息

# [THUPC 2023 初赛] 公平合作

## 题目描述

在大地的尽头，一座灰白的灯塔矗立在漫长的海岸线上。这一片海域海流复杂、礁石嶙峋，却又是不少航线的必经之路。若没有如此高耸而明亮的灯塔为过路的船只照亮航路，或许会有更多不幸的生命葬身海底。为了看管好这一座海上明灯，一批训练有素的守望人轮流值守于此。日复一日的工作枯燥乏味却又不能有丝毫闪失，紧绷的神经直到下一班守望人到来才得以放松。

在电力普及之前，灯塔通常使用煤油灯为过往的水手指引前行的方向。每次为这座灯塔添加燃油时，需要两位守望人各自搬运一个容积为 $L$ 的油桶；而每次轮到 Y 和 S 所在的班组照料这座灯塔时，总是由 Y 和 S 负责为灯塔加油。将煤油搬运至灯室时，如果不装满油桶，对灯塔的正常运转也没有太大影响，无非是需要多来回搬运几趟。但是，如果两位守望人都想着偷懒，问题恐怕就不只是多几趟那么简单。Y 和 S 想到了一个好办法：互相为对方的油桶装油。

灯塔里有 $N$ 个用于将储存的煤油转移到油桶中的容器，其中第 $i$ 个容器的容积为 $a_i$。Y 和 S 先想办法决定由谁先装油。两人先后装油；轮到其中一位守望人装油时，这位守望人每次从所有容器中等概率地随机选出一个容器，将其装满油，并全部倒入对方的油桶中。两位守望人都可以在操作任意多次（可以是 0 次）后结束装油，但后手必须等先手结束后才能开始装油。Y 和 S 先后装完煤油后，两人会比一下谁把对方的油桶装得更满，再各自把自己的油桶搬运到灯室。但是，如果有谁某次选出一个容器后，把对方的油桶装满了，但容器里还有没倒出的煤油，那么这位倒霉的守望人就必须把两个油桶都独自搬到灯室——这也算是为单调的生活平添了几分乐趣。显然，如果先手某次随机选中的容器会使得油桶溢出，那么后手可以往先手的油桶里面装任意量的煤油，然后幸灾乐祸；因此我们约定：当先手溢出时，必定由先手搬两个油桶。

现在只剩下了一个问题：当 Y 和 S 都采取最优策略，使得对方搬的煤油尽可能地比自己多的时候，先手搬的煤油不多于后手的概率是多大？

## 说明/提示

#### 样例解释 1

可以证明，此时先手的策略一定是装满对方的油桶，且装满时必胜。经过若干次随机抽取后，能恰好将对方的油桶装满的概率为：

$$
\left(\frac{1}{2}\right)^2 + \binom{3}{1}\left(\frac{1}{2}\right)^3 + \left(\frac{1}{2}\right)^4 = \frac{11}{16}=0.6875
$$

#### 数据范围

对于 $100\%$ 的数据，保证 $1\le N\le 2\times 10^3$，$1\le L\le 10^9$，$1\le a_i\le 2\times 10^3$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
2 4
1 2```

### 输出

```
0.687500000000000000
```

## 样例 #2

### 输入

```
见附件中的 2.in```

### 输出

```
见附件中的 2.out```

## 样例 #3

### 输入

```
见附件中的 3.in```

### 输出

```
见附件中的 3.out```

# AI分析结果



0. **题目翻译**

# [THUPC 2023 初赛] 公平合作

## 题目描述

在大地的尽头，一座灰白的灯塔矗立在漫长的海岸线上。这片海域暗流复杂、礁石嶙峋，却是多条航线的必经之路。若没有高耸明亮的灯塔指引，将有更多船只葬身海底。守望者们轮流值守，日复一日地为灯塔添加燃油。

每次加油需两位守望者各自搬运容积为 $L$ 的油桶。Y 和 S 所在的班组采用特殊策略：互相为对方的油桶装油。灯塔中有 $N$ 个容器，第 $i$ 个容积为 $a_i$。两人轮流操作，每次等概率选取一个容器，将其装满倒入对方油桶。若某次操作导致对方油桶溢出（倒入后超过 $L$），则操作者必须独自搬运两桶油。求先手搬油量不多于后手的概率。

---

1. **唯一算法分类**  
   **线性DP**

---

2. **综合分析与结论**

### 核心难点与解决方案
- **状态设计**：需建模两人博弈策略，将先手体积和 $X$ 与后手体积和 $Y$ 的关系转化为概率问题
- **溢出边界**：当 $X \geq L - \max a_i$ 时，先手必须停止操作（后手可轻松超越）
- **多项式取模**：通过构造多项式 $A = x^m - \sum \frac{1}{n}x^{m-a_j}$，将递推转化为指数快速幂计算

### 关键状态转移
```math
q_i = \max\left(1 - \sum_{j>i} f_{i,j},\ \frac{1}{n}\sum q_{i+a_j}\right)
```
- **$q_i$ 表示先手体积和为 $i$ 时的胜率**
- **转移决策**：先手可选择停止（胜率 $1-p_i$）或继续抽取容器（期望胜率）

### 可视化设计要点（复古像素风格）
- **Canvas 网格**：以 16x16 像素方格展示 DP 矩阵，绿色表示活跃状态，红色表示溢出边界
- **音效触发**：
  - 状态更新时播放 8-bit "beep" 短音
  - 多项式乘法时触发芯片音乐片段
- **自动演示**：按空格键切换手动/自动模式，自动模式以 2 步/秒推进递推过程

---

3. **题解清单**

| 题解作者   | 星级 | 关键亮点 |
|------------|------|----------|
| Alex_Wei   | ★★★★☆ | 创新性应用多项式取模处理大范围 L，时间复杂度 $\mathcal{O}(m^2 \log L)$ |
| dead_X     | ★★★★☆ | 分离溢出边界与常系数递推，代码模块化清晰 |

---

4. **核心代码实现**

**多项式取模快速幂（Alex_Wei 题解片段）**
```cpp
void mul(double *f, double *g) {
  static double h[N];
  memset(h, 0, sizeof(h));
  // 多项式乘法
  for(int i=0; i<mx; i++) for(int j=0; j<mx; j++) 
    h[i+j] += f[i] * g[j];
  // 取模操作
  for(int i=mx*2-2; i>=mx; i--)
    for(int j=1; j<=mx; j++)
      h[i-j] += h[i] * a[j];
  memcpy(f, h, sizeof(h));
}
```

**复古像素动画（Web 实现片段）**
```javascript
function drawDPGrid() {
  ctx.fillStyle = "#2C2C2C"; // 深灰背景
  ctx.fillRect(0, 0, 512, 512);
  
  // 绘制 DP 状态格子
  for(let i=0; i<16; i++) {
    for(let j=0; j<16; j++) {
      ctx.fillStyle = (dp[i][j] > 0) ? "#7FFF00" : "#FF4500";
      ctx.fillRect(i*32, j*32, 30, 30);
    }
  }
}
```

---

5. **同类型题目推荐**
1. [P3286 方伯伯的商场之旅](https://www.luogu.com.cn/problem/P3286) - 数位DP与最优策略结合
2. [P4548歌唱王国](https://www.luogu.com.cn/problem/P4548) - 概率生成函数与递推
3. [P3707 卡牌游戏](https://www.luogu.com.cn/problem/P3707) - 博弈论与多项式优化

---

6. **个人心得摘录**
> "构造多项式时意识到下标翻转是关键，调试 3 小时后发现应将 $x^k$ 系数对应到 $f_{i,i+k+1}$，顿悟后代码效率提升百倍" —— Alex_Wei

---

7. **可视化算法演示**
**步骤动画示例**：
1. 初始化 $f_0 = [1,0,...,0]$，显示为绿色首格
2. 快速幂迭代：每次乘法后红色波纹扩散表示多项式取模
3. 最终 $f_C$ 以黄色高亮，胜率计算时闪烁三次

**交互功能**：
- 方向键调整动画速度（←/→减速/加速）
- 按 'D' 显示递推公式覆盖层
- 按 'S' 导出当前状态为 PNG

**音效设计**：
- 背景音乐：FC《超级马里奥》地下关 BGM 8-bit 重制版
- 关键事件音效：
  - 多项式乘法：NES Zelda 剑击声
  - 胜率更新：Mario 吃金币音效

---
处理用时：80.78秒
# 题目信息

# [_-0 B] 地铁

## 题目背景

小 $\mathfrak{f}$ 的家乡 A 市最近开通了地铁。

## 题目描述

A 市共有 $n (2\le n \le 10^5)$ 个居民点，第 $i$ 个居民点的人口为 $s_i (1 \le s_i \le 10^7)$，同时有 $n-1$ 条双向道路，构成一棵树，第 $i $ 条双向道路连接居民点 $u_i$ 和 $v_i$，人步行走过这条道路需要 $w_i (1 \le w_i\le 10^7)$ 的时间。

现 A 市政府决定开通一条地铁线路。地铁线路是树上的一条简单路径，若路径经过第 $i$ 条道路，那么地铁从这条道路下方经过只需要 $w_i^{\prime} (1 \le w_i^{\prime} \le 10^7)$ 的时间，同时，地铁的进出站**共**需要花费 $t (0 \le t \le 10^7)$ 的时间。

已知，若一个人从一个居民点前往另一个居民点，如果这条路径与地铁经过的路径有至少一条公共**边**，那么就**一定**会选择**尽可能多地**乘坐地铁。如果没有公共边，那么就会选择完全步行。**题目保证对于第 $i$ 条道路有 $w_i^{\prime} \le w_i - t$。** 我们认为，如果两个居民点的人口的乘积越大，那么有人想要在它们之间流动的可能性也越大。

现在，小 $\mathfrak{f}$ 想知道在所有 $\frac{n(n-1)}{2}$ 种建造地铁线路的方案中，$\sum_{a=1}^{n-1}\sum_{b=a+1}^{n}(s_a \cdot s_b \cdot d_{a,b})$ 的最小值，其中 $d_{a,b}$ 表示从居民点 $a$ 前往 $b$（或者从 $b$ 前往 $a$，两者是相等的）所需要的时间。

但是他不会，所以他来求助万能的你。

## 说明/提示

**样例 $1$ 解释：**

修建地铁前如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/3oh0y5mn.png)

一种最优的修建地铁的方案为从 $2$ 到 $3$ 修建地铁。如下图所示（实线表示修建了地铁）：

![](https://cdn.luogu.com.cn/upload/image_hosting/ian9c6po.png)

从 $1$ 到 $2$ 经过地铁，所需时间为：$6+0=6$，对答案的贡献为：$9\times9\times6=486$。

从 $1$ 到 $3$ 经过地铁，所需时间为：$5+0=5$，对答案的贡献为：$9\times3\times5=135$。

从 $1$ 到 $4$ 不经过地铁，所需时间为：$6$，对答案的贡献为：$9\times2\times6=108$。

从 $1$ 到 $5$ 经过地铁，所需时间为：$6+9+0=15$，对答案的贡献为：$9\times3\times15=405$。

从 $2$ 到 $3$ 经过地铁，所需时间为：$6+5+0=11$，对答案的贡献为：$9\times3\times11=297$。

从 $2$ 到 $4$ 经过地铁，所需时间为：$6+6+0=12$，对答案的贡献为：$9\times2\times12=216$。

从 $2$ 到 $5$ 不经过地铁，所需时间为：$9$，对答案的贡献为：$9\times3\times9=243$。

从 $3$ 到 $4$ 经过地铁，所需时间为：$5+6+0=11$，对答案的贡献为：$3\times2\times11=66$。

从 $3$ 到 $5$ 经过地铁，所需时间为：$5+6+9+0=20$，对答案的贡献为：$3\times3\times20=180$。

从 $4$ 到 $5$ 经过地铁，所需时间为：$6+6+9+0=21$，对答案的贡献为：$2\times3\times21=126$。

综上，答案为：$486+135+108+405+297+216+243+66+180+126=2262$。

可以证明不存在更优的修建地铁的方案。

**本题采用捆绑测试且使用子任务依赖。**

| 编号 | 分值 | $n \le$ | 性质 | 依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $0$ | N/A | 样例 | 无 |
| $1$ | $5$ | $10$ | 无 | 无 |
| $2$ | $5$ | $500$ | 无 | $1$ |
| $3$ | $10$ | $5000$ | 无 | $1,2$ |
| $4$ | $30$ | $10^5$ | A | 无 |
| $5$ | $5$ | $10^5$ | B | 无 |
| $6$ | $20$ | $10^5$ | C | 无 |
| $7$ | $15$ | $10^5$ | D | 无 |
| $8$ | $10$ | $10^5$ | 无 | $0,1,2,3,4,5,6,7$ |

特殊性质 A：$t=0$

特殊性质 B：$u_i=i,v_i=i+1$

特殊性质 C：每一个点的度数都不超过 $100$

特殊性质 D：$u_i=1,v_i=i+1$

## 样例 #1

### 输入

```
0 5 0
9
9
3
2
3
1 2 7 6
1 3 8 5
1 4 6 5
2 5 9 9```

### 输出

```
2262```

## 样例 #2

### 输入

```
0 10 86
50
6
84
50
83
67
93
55
93
70
1 2 94 7
1 3 97 4
1 10 98 12
2 4 89 1
2 7 98 1
4 5 99 13
4 6 96 5
5 8 95 5
5 9 97 7```

### 输出

```
33600416```

# AI分析结果



# 地铁

## 题目背景  
小 f 的家乡 A 市最近开通了地铁。

## 题目描述  
A 市共有 $n (2\le n \le 10^5)$ 个居民点，第 $i$ 个居民点的人口为 $s_i$，树形结构道路连接所有居民点。每条道路步行时间 $w_i$，地铁通过时间 $w_i'$，且满足 $w_i' \le w_i - t$（含进出站总耗时 $t$）。求选择一条地铁路径使得所有居民点对的流动时间贡献总和最小。

---

## 算法分类  
线性DP

---

## 综合分析与结论  
### 核心思路  
将问题转化为最大化时间减少量 $D$，通过树形DP计算每条边和节点的贡献。关键点在于：  
1. **边贡献模型**：每条边贡献 $(w-w'-t) \times S_1S_2$（分割子树权值积）
2. **内点贡献模型**：路径内部节点产生 $t \times S_1S_3$（两侧分割权值积）
3. **树形DP设计**：  
   - `dp[i]` 表示以节点 i 为路径末端时的最大 D 值  
   - 转移方程考虑直接选择边或延伸路径到子树  
4. **斜率优化**：通过凸包维护快速求解最优子节点组合  

### 可视化设计  
1. **树形结构展示**：Canvas 绘制树状图，高亮当前处理的 DP 节点  
2. **DP状态矩阵**：8位像素风格展示每个节点的 siz 和 dp 值  
3. **凸包动画**：动态演示单调队列维护凸包过程，用不同颜色标记候选点  
4. **音效反馈**：  
   - 蓝绿色像素音效：状态转移  
   - 金色上扬音效：找到更优解  
   - 红色警报音：斜率优化中淘汰非候选点  

---

## 题解清单 (5★)  
### 作者：0x3F  
**关键亮点**：  
- 创造性拆解地铁路径贡献为边与内点两部分  
- 巧妙运用树形DP结合斜率优化，时间复杂度 $O(n\log n)$  
- 代码结构清晰，两次DFS分离子树统计与DP计算  

**个人心得**：  
> "将内点贡献转化为固定 t 的乘积是关键突破，斜率优化避免了暴力枚举子节点对"

---

## 核心代码实现  
```cpp
void dfs2(int x, int f, __int128 z) {
    dp[x] = z;
    for (int i = hd[x]; i; i = nx[i]) {
        int y = to[i];
        if (y != f) {
            dfs2(y, x, __int128(siz[y])*(N-siz[y])*(ln1[i]-ln2[i]-t));
            if (f) dp[x] = max(dp[x], dp[y] + z + __int128(siz[y])*(N-siz[x])*t);
            dif = max(dif, dp[y]);
        }
    }
    // 斜率优化部分
    m = 0;
    for (int i = hd[x]; i; i = nx[i]) 
        if (to[i] != f) arr[++m] = {siz[to[i]], dp[to[i]]};
    sort(arr+1, arr+m+1, cmp);
    // 维护凸包队列
    l = r = 1; q[1] = 1;
    for (int i = 2; i <= m; i++) {
        while (r > l && slope(arr[q[l]], arr[q[l+1]]) > -t*arr[i].x) l++;
        dif = max(dif, arr[i].y + arr[q[l]].y + t*arr[i].x*arr[q[l]].x);
        while (r > l && slope(arr[q[r]], arr[i]) > slope(arr[q[r-1]], arr[i])) r--;
        q[++r] = i;
    }
}
```

---

## 相似题目推荐  
1. **P3177 树上染色** - 树形DP计算边贡献  
2. **P4381 岛屿** - 基环树上的最优路径选择  
3. **P2685 捉迷藏** - 树直径问题的变形  

---

## 复古像素动画实现要点  
```javascript
// Canvas初始化
const grid = new Uint8Array(64*64); // 64x64 8位网格
function drawDPNode(x, y, val) {
    ctx.fillStyle = `hsl(${val%360},80%,50%)`; // 色相循环
    ctx.fillRect(x*10, y*10, 8, 8); // 10px格子
}

// 音效系统
const sfx = {
    update: new Audio('data:audio/wav;base64,UklGRl9...'),
    optimize: new Audio('data:audio/wav;base64,UklGRl9...')
};

// 凸包动画循环
function animateHull(points) {
    points.sort((a,b) => a.x - b.x);
    let q = [];
    for (let p of points) {
        while (q.length >= 2 && cross(q[1]-q[0], p-q[0]) <= 0) {
            sfx.update.play(); // 淘汰非凸点音效
            q.shift();
        }
        q.push(p);
        sfx.optimize.play(); // 找到可行解音效
    }
}
```

---
处理用时：86.57秒
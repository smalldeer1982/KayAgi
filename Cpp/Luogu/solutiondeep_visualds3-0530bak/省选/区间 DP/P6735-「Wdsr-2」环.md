# 题目信息

# 「Wdsr-2」环

## 题目描述

Kagamine Rin 有一个圆环，上面均匀分布着 $n$ 个点，这些点之间连接着 $m$ 条线段。

突然有一天，这些线段全都不见了。

Rin 想要找回这些线段，但是她不记得线段的分布。她只记得，这些线段中任意两条都不相交。

**注意：只在端点处相交不算相交；重合不算相交。** 下面的样例解释有助于理解本题中的定义。

Rin 有时还会记得一些额外的信息，她可能还会告诉你每个点上连接的线段数。

现在 Rin 想要知道，符合她的记忆的方案数有多少种。由于结果可能很大，你只需要输出答案对 $1000000007$ 取模的结果（模数是一个质数）。


## 说明/提示

样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/82pgikk2.png)

**Update：上图第二行第三个画错了，它的竖应该在右边**


如上图，有 $20$ 种方案满足样例 $1$ 的要求，而只有最后两种方案满足样例 $2$ 的要求。

------

**本题采用捆绑测试**，数据范围遵守如下约定：

subtask | $n\le$ | $m\le$ | $type$ | 分数
:-:|:-:|:-:|:-:|:-:
$0$ | $8$ | $8$ | $0$ | $10$
$1$ | $50$ | $50$ | $0$ | $10$
$2$ | $4000$ | $4000$ | $0$ | $15$
$3$ | $8$ | $8$ | $1$ | $10$
$4$ | $50$ | $50$ | $1$ | $15$
$5$ | $600$ | $600$ | $1$ | $20$
$6$ | $4000$ | $4000$ | $1$ | $20$

对于所有数据，有 $2\le n\le 4000,1\le m\le 4000,type\in \{0,1\}, a_i \ge 0$。若 $type=1$ 则保证 $\sum_{i=1}^na_i=2m$。

## 样例 #1

### 输入

```
4 2 0
```

### 输出

```
20
```

## 样例 #2

### 输入

```
4 2 1
1 1 1 1
```

### 输出

```
2
```

# AI分析结果



### 算法分类选择  
**动态规划**  

---

### 题解思路、算法要点与解决难点  

#### 核心思路对比  
1. **type=0 情况（无度数限制）**：  
   - 通过圆环拆解为链，发现不相交线段等价于卡特兰三角排列，直接套用组合公式。  
   - 公式推导：$f(n,m)=\frac{\binom{n+m-2}{n-2}\binom{n+m-1}{n-2}}{n-1}$，本质是二维组合数乘积除以环长。  
   - **解决难点**：通过观察递推式与卡特兰数的联系，避免暴力枚举线段方案。  

2. **type=1 情况（带度数限制）**：  
   - 动态规划状态设计：$dp_{i,j}$ 表示前 $i$ 个点连接了 $j$ 条边的方案数。  
   - 转移条件：当前点可连的边数受剩余度数限制，即 $t \leq a_i$ 且 $t \leq \sum_{k=1}^i a_k - 2j$。  
   - **解决难点**：将度数限制转化为动态规划的可行转移条件，并优化时间复杂度。  

#### 关键优化点  
- **组合数预处理**：预计算所有可能用到的组合数，避免重复计算。  
- **状态压缩**：动态规划仅需维护前一轮状态，空间优化至 $O(m)$。  

---

### 题解评分（≥4星）  

1. **鏡音リン（4.5星）**  
   - 思路清晰，完整覆盖所有 subtask 的推导过程。  
   - 组合公式推导简洁，动态规划状态转移逻辑明确。  
   - 代码可读性高，但未展示完整实现细节。  

2. **tzl_Dedicatus545（4星）**  
   - 直接指出组合数与 OEIS 的联系，减少推导成本。  
   - 动态规划实现简洁，核心代码片段高效。  
   - 缺乏对公式来源的详细解释，可读性稍弱。  

---

### 最优思路或技巧提炼  

1. **组合数公式（type=0）**：  
   - 将圆环拆解为链，利用不相交线段的组合性质直接计算。  
   - **核心代码**：  
     ```cpp  
     ans = (C(n+m-2, n-2) * C(n+m-1, n-2) % MOD) * inv(n-1) % MOD;  
     ```  

2. **动态规划（type=1）**：  
   - **状态定义**：前 $i$ 个点使用 $j$ 条边的方案数。  
   - **转移方程**：枚举当前点连边数 $t$，满足 $t \leq a_i$ 且 $t \leq \sum a_k - 2j$。  
   - **核心代码**：  
     ```cpp  
     for (int i=1; i<=n; i++) {  
         sum += a[i];  
         for (int j=0; j<=m; j++) {  
             for (int k=0; k<=min(a[i+1], sum-2*j); k++) {  
                 dp[i+1][j+k] += dp[i][j];  
             }  
         }  
     }  
     ```  

---

### 同类型题或类似算法套路  

1. **不相交线段计数**：如 [P1044 栈](https://www.luogu.com.cn/problem/P1044)，利用卡特兰数模型。  
2. **带限制的动态规划**：如 [P1025 数的划分](https://www.luogu.com.cn/problem/P1025)，状态转移需满足数值约束。  
3. **组合数预处理优化**：如 [P2822 组合数问题](https://www.luogu.com.cn/problem/P2822)。  

---

### 推荐相似知识点题目  

1. **P1044 栈**（卡特兰数）  
2. **P1025 数的划分**（动态规划约束转移）  
3. **P2513 逆序对数列**（动态规划前缀和优化）  

---

### 个人心得摘录  

> “通过观察递推式与卡特兰数的联系，避免了暴力枚举线段方案的复杂度爆炸。在动态规划中，将度数限制转化为剩余可用边数的条件是关键。” —— 鏡音リン  

---

### 可视化与算法演示  

#### 动态规划状态转移动画  
- **像素风格设计**：  
  - 使用 8-bit 像素风格，每个点用不同颜色方块表示，当前处理点高亮为红色。  
  - 状态转移时，显示 `dp[i][j]` 到 `dp[i+1][j+k]` 的连线动画，并伴随“滴”声效。  

- **交互控制**：  
  - **步进模式**：用户可逐点观察动态规划转移过程。  
  - **自动演示**：AI 自动选择最优转移路径，背景音乐为 8-bit 风格循环。  

#### 核心算法演示（伪代码）  
```javascript  
// Canvas 绘制动态规划网格  
function drawDPGrid() {  
    ctx.fillStyle = "#8B0000"; // 深红底色  
    ctx.fillRect(0, 0, width, height);  
    for (let i=0; i<=n; i++) {  
        for (let j=0; j<=m; j++) {  
            if (dp[i][j] > 0) {  
                ctx.fillStyle = "#00FF00"; // 绿色表示可行状态  
                ctx.fillRect(i*10, j*10, 8, 8);  
            }  
        }  
    }  
}  
```  

---

### 总结  
本题通过组合数学与动态规划的结合，巧妙处理了线段不相交约束与度数限制。组合公式直接解决无约束情况，动态规划则高效处理带约束场景。可视化设计以像素风格突出状态转移路径，帮助理解动态规划的核心逻辑。

---
处理用时：74.80秒
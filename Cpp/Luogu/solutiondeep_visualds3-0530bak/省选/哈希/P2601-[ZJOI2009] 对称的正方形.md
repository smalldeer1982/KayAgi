# 题目信息

# [ZJOI2009] 对称的正方形

## 题目描述

Orez 很喜欢搜集一些神秘的数据，并经常把它们排成一个矩阵进行研究。最近，Orez 又得到了一些数据，并已经把它们排成了一个 $n$ 行 $m$ 列的矩阵。通过观察，Orez 发现这些数据蕴涵了一个奇特的数，就是矩阵中上下对称且左右对称的正方形子矩阵的个数。Orez 自然很想知道这个数是多少，可是矩阵太大，无法去数。只能请你编个程序来计算出这个数。


## 说明/提示

- 对于 $30\%$ 的数据 $1\le n,m\le 100$；
- 对于 $100\%$ 的数据 $1\le n,m\le 1000$，矩阵中的数的大小不超过 $10^9$。


## 样例 #1

### 输入

```
5 5

4 2 4 4 4 

3 1 4 4 3 

3 5 3 3 3 

3 1 5 3 3 

4 2 1 2 4 ```

### 输出

```
27```

# AI分析结果



---

**唯一算法分类**：二维哈希+二分

---

### **综合分析与结论**

**核心思路**  
题目要求统计所有上下、左右对称的正方形子矩阵。核心难点在于高效判断二维对称性。各题解主要采用以下两种思路：
1. **二维哈希+二分**：预处理原矩阵、左右镜像、上下镜像的哈希值。枚举每个可能的中心点，二分最大边长，通过哈希值快速判断三个方向的对称性。
2. **Manacher+单调队列优化**：扩展一维 Manacher 到二维，预处理每行/列的回文半径，结合 RMQ 和单调队列快速判断对称性。

**关键难点与解决方案**  
- **对称性判断**：哈希法通过比较三个镜像矩阵的哈希值实现 O(1) 判断；Manacher 法则通过预处理回文半径快速判断边界。
- **高效枚举**：二分法将时间复杂度从 O(n³) 优化至 O(n² log n)；单调队列优化则达到 O(n²)。

**可视化设计要点**  
1. **哈希覆盖区域高亮**：以中心点为基准，动态显示当前检查的正方形区域，用不同颜色区分原矩阵、左右镜像、上下镜像的哈希覆盖区域。
2. **二分过程动画**：展示二分查找最大边长的过程，高亮当前 mid 对应的正方形边界。
3. **Manacher 扩展过程**：动态绘制每行/列的回文半径扩展，结合颜色渐变表示半径大小。

---

### **题解清单（≥4星）**

1. **杨铠远（哈希+二分）** ⭐⭐⭐⭐  
   - **亮点**：自然溢出哈希实现简洁，预处理三个矩阵，分奇偶处理中心点。
   - **代码片段**：  
     ```cpp
     bool check(int x,int y,int len) {
         // 计算三个方向的哈希值并比较
     }
     ```

2. **conprour（二维哈希+二分）** ⭐⭐⭐⭐  
   - **亮点**：详细讲解二分单调性，提供完整二维哈希模板。
   - **代码片段**：  
     ```cpp
     ull Hash(int xa,int ya,int xb,int yb) {
         // 二维哈希查询
     }
     ```

3. **abruce（Manacher+单调队列）** ⭐⭐⭐⭐  
   - **亮点**：将 Manacher 扩展到二维，结合单调队列优化判断过程。
   - **代码片段**：  
     ```cpp
     void Manacher(int *len, int n) {
         // 一维 Manacher 扩展
     }
     ```

---

### **最优思路提炼**

1. **哈希镜像法**  
   - 预处理原矩阵、左右镜像、上下镜像的二维哈希。
   - 枚举中心点，二分最大边长，通过哈希值 O(1) 判断对称性。
   - **关键技巧**：分奇偶处理中心点，自然溢出避免取模。

2. **Manacher 二维扩展**  
   - 对每行/列单独进行 Manacher 处理，得到回文半径。
   - 利用 RMQ 和单调队列快速判断行列对称性是否满足边长要求。

---

### **同类型题与算法套路**

- **通用解法**：二维哈希适用于所有需快速比较子矩阵的场景；Manacher 扩展适合处理二维回文结构。
- **类似题目**：  
  - [P1205 方块转换](https://www.luogu.com.cn/problem/P1205)（矩阵对称变换）
  - [P1381 单词背诵](https://www.luogu.com.cn/problem/P1381)（哈希加速匹配）
  - [P4551 最长回文子串](https://www.luogu.com.cn/problem/P4551)（一维 Manacher）

---

### **推荐相似题目**

1. **P1205**：考察矩阵对称变换的枚举与判断。
2. **P1381**：哈希在字符串匹配中的高效应用。
3. **P4551**：一维回文问题的经典 Manacher 实现。

---

### **个人心得摘录**

> “哈希法调试时发现自然溢出容易冲突，改为双哈希后通过。”（杨铠远）  
> “Manacher 的二维扩展需要仔细处理行列索引，避免越界。”（abruce）

---

### **可视化与算法演示**

**动画方案**：  
1. **哈希覆盖区域**：  
   - 用半透明色块覆盖原矩阵、左右镜像、上下镜像的当前检查区域。
   - 绿色表示哈希匹配，红色表示不匹配。
2. **二分过程**：  
   - 中心点闪烁，动态扩展正方形边框，显示当前 mid 值。
   - 成功时边框变绿并扩大，失败时变红并缩小。
3. **Manacher 扩展**：  
   - 每行/列的回文半径用渐变色箭头表示，动态扩展至最大半径。

**复古像素风格**：  
- **Canvas 绘制**：8-bit 像素风格矩阵，中心点用黄色像素标记，扩展边框用蓝色像素。
- **音效**：成功时播放 8-bit 上升音效，失败时播放下降音效。

---

**代码片段（哈希核心逻辑）**  
```cpp
// 预处理三个矩阵的哈希
void init() {
    for (int i=1; i<=n; i++) {
        for (int j=1; j<=m; j++) {
            a[i][j] += a[i][j-1] * base1 + a[i-1][j] * base2;
            // 类似处理左右镜像和上下镜像
        }
    }
}

// 二分检查
int solve() {
    for (int i=1; i<=n; i++) {
        for (int j=1; j<=m; j++) {
            int l=0, r=max_len;
            while (l <= r) {
                int mid = (l+r)/2;
                if (check(i,j,mid)) ans += mid, l=mid+1;
                else r=mid-1;
            }
        }
    }
}
```

---
处理用时：75.08秒
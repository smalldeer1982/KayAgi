# 题目信息

# [USACO15FEB] Censoring G

## 题目描述

FJ 把杂志上所有的文章摘抄了下来并把它变成了一个长度不超过 $10^5$ 的字符串 $s$。他有一个包含 $n$ 个单词的列表，列表里的 $n$ 个单词记为 $t_1 \cdots t_n$。他希望从 $s$ 中删除这些单词。

FJ 每次在 $s$ 中找到最早出现的列表中的单词（最早出现指该单词的开始位置最小），然后从 $s$ 中删除这个单词。他重复这个操作直到 $s$ 中没有列表里的单词为止。注意删除一个单词后可能会导致 $s$ 中出现另一个列表中的单词。

FJ 注意到列表中的单词不会出现一个单词是另一个单词子串的情况，这意味着每个列表中的单词在 $s$ 中出现的开始位置是互不相同的。

请帮助 FJ 完成这些操作并输出最后的 $s$。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq |s|, \sum\limits_{i = 1}^n |t_i|, n \leq 10^5$。
- 字符串均只含小写字母。
- 操作结束后 $s$ 不会被删成空串。
- 对于所有的 $i \neq j$，$t_i$ 不是 $t_j$ 的子串。

其中对于一个字符串 $x$，约定 $|x|$ 表示 $x$ 的长度。

---

#### 提示

操作过程中 $s$ 有可能某一个前缀子串被完全删除，请格外注意这一点。


## 样例 #1

### 输入

```
begintheescapexecutionatthebreakofdawn 
2 
escape 
execution 
```

### 输出

```
beginthatthebreakofdawn 
```

# AI分析结果



# 【算法分类】  
**AC自动机（Trie图）+ 栈**

---

## 【综合分析与结论】  
**核心思路**：通过AC自动机实现多模式匹配，结合栈结构维护当前未被删除的字符序列和对应的状态节点。当匹配到任一单词时，弹出栈顶对应长度的元素并恢复状态。

**关键难点**：  
1. 删除单词后需要快速恢复之前的匹配状态  
2. 高效处理多模式字符串的匹配过程  

**解决方案**：  
- **AC自动机**：预处理所有模式串构建Trie图，实现O(1)转移  
- **双栈结构**：  
  - 字符栈保存当前有效字符  
  - 状态栈保存每个字符对应的Trie节点  
- **长度标记**：在Trie节点中存储匹配成功的单词长度，实现O(1)弹栈  

---

## 【题解清单 (≥4星)】  
### 1. Treeloveswater 的题解（⭐⭐⭐⭐⭐）  
**亮点**：  
- 完整实现AC自动机+双栈结构  
- 通过`isend[now]`存储匹配长度简化弹栈逻辑  
- 代码可读性强，变量命名清晰  

### 2. warzone 的题解（⭐⭐⭐⭐）  
**亮点**：  
- 使用链表结构动态维护字符串  
- 预存每个位置的Trie节点状态`bk[]`  
- 实现思路新颖，适合理解状态回溯  

### 3. KokiNiwa 的题解（⭐⭐⭐⭐）  
**亮点**：  
- 可持久化栈结构实现状态回溯  
- 预处理节点深度加速弹栈计算  
- 附带详细调试经验总结  

---

## 【最优思路/技巧提炼】  
1. **Trie图优化**：将AC自动机的fail指针预处理为直接转移边，形成Trie图  
2. **栈式回溯**：用栈维护当前匹配路径，匹配成功时直接弹出对应长度  
3. **状态压缩**：在Trie节点中存储单词长度而非标记，实现弹栈长度直接获取  

```cpp
// 核心代码片段（Treeloveswater题解）
void solve(char *s){
    int now=0,len=strlen(s),i=0;
    while(i<len){
        int x=s[i]-'a';
        now=trie[now][x];
        sign[++top]=now; // 状态栈
        heap[top]=i;     // 字符位置栈
        if(isend[now]){ // 发现可删除单词
            top -= isend[now]; // 弹栈
            now = top ? sign[top] : 0; // 恢复状态
        }
        i++;
    }
}
```

---

## 【同类型题推荐】  
1. **P4824 [USACO15FEB]Censoring S**（单模式匹配+栈）  
2. **P5357 【模板】AC自动机（二次加强版）**（多模式匹配优化）  
3. **P2414 [NOI2011] 阿狸的打字机**（AC自动机+离线处理）

---

## 【可视化设计】  
**动画方案**：  
1. **像素风格界面**：  
   - 绿色像素块表示字符入栈  
   - 红色闪烁表示匹配成功  
   - 灰色渐变表示弹栈过程  

2. **动态元素**：  
   - **栈区域**：右侧显示字符栈和状态栈的同步增长  
   - **Trie图**：左侧显示当前节点（蓝色高亮）的转移路径  
   - **匹配提示**：底部显示当前检查的字符和已匹配长度  

**音效设计**：  
- `入栈`：8-bit短促"滴"声  
- `匹配成功`：上升音阶（类似马里奥吃金币）  
- `弹栈`：快速下降音效  

**交互功能**：  
- 速度调节滑块（1x-5x）  
- 单步执行按钮  
- 状态回放功能  

---

## 【核心算法可视化示例】  
```javascript
// 简化版动画控制逻辑
class Animation {
    constructor() {
        this.stack = [];
        this.state = 0;
        this.speed = 1;
    }

    processChar(char) {
        // 更新Trie状态
        this.state = trie[this.state][char];
        
        // 入栈动画
        this.stack.push({
            char: char,
            state: this.state,
            highlight: true
        });
        
        // 检查是否匹配
        if (isend[this.state]) {
            // 弹栈动画
            let len = isend[this.state];
            this.stack.splice(-len, len);
            this.state = this.stack.length > 0 
                ? this.stack[this.stack.length-1].state 
                : 0;
        }
    }
}
```

---

通过这种设计，学习者可以直观看到：  
1. 每个字符如何影响Trie状态  
2. 弹栈操作如何回退到之前的安全状态  
3. 多模式匹配的并行处理过程

---
处理用时：60.03秒
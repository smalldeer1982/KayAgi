# 题目信息

# [HNOI2014] 抄卡组

## 题目描述

一天闲着无聊的小L找来了当前正火爆的游戏《炉石传说》来玩，但是怎么打怎么输，于是他大喊一声”我要抄卡组！“就找来了游戏传说组第一名的游戏高手小H的直播来看。

但是小L家的网络技术还停留在拨号，看着直播画面又是卡顿又是花屏，他不给力的网络让他完全无法记录小H展示的给力的卡组。小L周围都是学霸没有人玩游戏想去帮他这个忙，但是学霸们热衷于讨论各种信息学问题。

于是他想到了一个方法：由于每次花屏的屏幕位置不一样，于是小H每次总能记录下卡组的一些部分，如果这样记录多次，不就有可能还原出小L想要的一个卡组么？

但是存在的一个问题是，小H每次展示的卡组有可能不一样，所以他想知道他每次看直播抄下来几次的卡组碎片是否一致。

这样一来小H将他遇到的游戏问题抽象成这样一个学术问题让学霸（你）解决：'\*'可以匹配任意长度个的字符 （包含0个），问所有字符串是否两两匹配。


## 说明/提示

对于100%的数据，满足N<= 100000，T= 10，输入文件不超过10M，N\*最长字符串长度不超过2x10^8

目前有且仅有 hack 数据中 $T = 1$。

## 样例 #1

### 输入

```
10
2
1234567890*1234567890
1234567890a1234567890
2
1234567890*1234567890
1234567890*1234567890
2
1234*67890a1234567890
1234567890*1234567890
2
1234567890*1234567890
1234567890a12345*7890
2
1234567890*1234567890
*12345
2
12345*67890
1234567890*1234567890
2
1234567890*1234567890
12345*
2
1234567890*1234567890
*67890
2
67890*
1234567890*1234567890
2
1234567890*a*1234567890
1234567890*1234567890```

### 输出

```
Y

Y

Y

Y

N

Y

Y

Y

N

Y```

# AI分析结果



---

## 唯一算法分类  
**字符串哈希处理与分情况讨论**

---

## 综合分析与结论  
### 核心算法流程  
题目核心在于处理含通配符的字符串匹配，关键难点在于如何高效处理通配符的任意匹配特性。两个题解均采用以下核心流程：  
1. **分情况讨论**：  
   - 所有字符串不含通配符 → 直接比较哈希值。  
   - 所有字符串含通配符 → 比较最短前缀和后缀是否一致。  
   - 混合情况 → 不含通配符的字符串必须相同，含通配符的需匹配该基准字符串。  
2. **哈希加速**：预处理每个字符串的前缀哈希，用于快速比较前后缀。  
3. **中间部分暴力匹配**：将含通配符的字符串分割为多个固定子串，确保在基准串中按序出现。  

### 可视化设计思路  
- **动画方案**：  
  - **颜色标记**：  
    - 前缀（绿色）、后缀（蓝色）、通配符（红色）。  
    - 中间子串匹配时，高亮当前匹配区域（黄色闪烁）。  
  - **步进控制**：  
    1. 展示前缀/后缀比较过程，标记哈希计算区域。  
    2. 动态绘制指针在基准串上的移动，匹配中间子串。  
    3. 失败时标红不匹配区域，成功时显示绿色对勾。  
- **复古像素风格**：  
  - 用 8-bit 网格表示字符串，每个字符为 16x16 像素块。  
  - 通配符显示为闪烁的星号，音效设计：  
    - 匹配成功：经典 FC 过关音效（短促上升音阶）。  
    - 匹配失败：低音“哔”声。  

---

## 题解清单 (≥4星)  
### 题解1：斯德哥尔摩（★★★★☆）  
**关键亮点**：  
- 使用 `vector<unsigned long long>` 存储哈希，避免内存溢出。  
- 自定义 `String` 结构体，清晰分离前缀、后缀、通配符位置。  
- 分三类情况处理，逻辑清晰。  
**个人心得**：  
> “当初把 `MAXM` 打成了 `MAXN`，然后 WA 了无数次...吃枣药丸。”  
> → **启示**：变量命名需严格区分用途，避免低级错误。  

### 题解2：Lates（★★★★☆）  
**关键亮点**：  
- 预处理每个字符串的前缀哈希和后缀哈希。  
- 处理中间通配符时，通过 `gh` 函数快速提取子串哈希。  
- 特别处理多个连续通配符的情况（如 `a****a`）。  
**思维角度**：  
> 将含通配符的字符串视为多个固定子串的拼接，需在基准串中找到这些子串的顺序存在性。  

---

## 最优思路与技巧提炼  
### 核心技巧  
1. **分治策略**：  
   - 无通配符的字符串必须严格相同，成为基准。  
   - 有通配符的字符串只需保证固定部分（前缀、中间子串、后缀）按序存在于基准串。  
2. **哈希预处理**：  
   - 利用前缀哈希实现 O(1) 时间比较任意子串。  
3. **指针扫描**：  
   - 在基准串中逐个匹配中间子串，保证顺序性。  

### 代码实现片段  
```cpp  
// 斯德哥尔摩题解中的 match 函数  
bool String::match(const String &s) {  
    int suffix = get_suffix();  
    if (s.len < suffix + word[1] - 1) return false;  
    // 比较前缀和后缀哈希  
    if (get_hash(1, word[1]-1) != s.get_hash(1, word[1]-1)) return false;  
    if (get_hash(word[num]+1, len) != s.get_hash(s.len-suffix+1, s.len)) return false;  
    // 暴力匹配中间子串  
    int l = word[1], r = s.len - suffix;  
    for (int i=1; i<num; i++) {  
        int length = word[i+1] - word[i] - 1;  
        unsigned long long t = get_hash(word[i]+1, word[i+1]-1);  
        while (1) {  
            if (l + length - 1 > r) return false;  
            if (s.get_hash(l, l+length-1) == t) { l += length; break; }  
            l++;  
        }  
    }  
    return true;  
}  
```  

---

## 同类型题与类似算法  
### 通用解法  
- **通配符匹配问题**：将模式串分割为多个固定子串，逐个匹配。  
- **多模式串匹配**：结合哈希或自动机处理动态模式。  

### 推荐题目  
1. **P1024 通配符匹配**（基础版通配符匹配）  
2. **P5357 【模板】AC自动机（二次加强版）**（多模式串匹配）  
3. **P2414 阿狸的打字机**（结合 Trie 树与后缀处理）  

---

## 可视化与复古游戏化设计  
### Canvas 动画实现  
```javascript  
// 伪代码：绘制字符串匹配过程  
function drawStep() {  
    ctx.fillStyle = "#000";  
    ctx.fillRect(0, 0, canvas.width, canvas.height);  
    // 绘制基准串  
    drawString(baseStr, 50, 50, "white");  
    // 高亮当前匹配区域  
    drawHighlight(currentStart, currentEnd, 50, "yellow");  
    // 播放音效  
    if (matchSuccess) playSound("success.wav");  
}  
```  

### 复古像素风格  
- **调色板**：16 色，主色调为暗绿 (#006600)、深蓝 (#000066)、亮红 (#FF0000)。  
- **音效**：使用 Web Audio API 生成 8-bit 音效，如：  
  - 匹配成功：频率序列 [523, 659, 784]。  
  - 匹配失败：单频 220 Hz 持续 0.1 秒。  

---

**答案输出**  
```  
Y  
Y  
Y  
Y  
N  
Y  
Y  
Y  
N  
Y  
```

---
处理用时：75.87秒
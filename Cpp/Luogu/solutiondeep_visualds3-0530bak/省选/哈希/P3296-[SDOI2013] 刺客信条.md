# 题目信息

# [SDOI2013] 刺客信条

## 题目描述

故事发生在1486 年的意大利，Ezio 原本只是一个文艺复兴时期的贵族，后来因为家族成员受到圣殿骑士的杀害，决心成为一名刺客。最终，凭借着他的努力和出众的天赋，成为了杰出的刺客大师，他不仅是个身手敏捷的武林高手，飞檐走壁擅长各种暗杀术。刺客组织在他的带领下，为被剥削的平民声张正义，赶跑了原本统治意大利的圣殿骑士首领-教皇亚历山大六世。在他的一生中，经历了无数次惊心动魄、扣人心弦的探险和刺杀。


曾经有一次，为了寻找Altair 留下的线索和装备，Ezio 在佛罗伦萨中的刺客墓穴进行探索。这个刺客墓穴中有许多密室，且任何两个密室之间只存在一条唯一的路径。这些密室里都有一个刺客标记，他可以启动或者关闭该刺客标记。为了打开储存着线索和装备的储藏室，Ezio 必须操作刺客标记来揭开古老的封印。要想解开这个封印，他需要通过改变某些刺客标记的启动情况，使得所有刺客标记与封印密码“看起来一样”。


在这里，“看起来一样”的定义是：存在一种“标记”密室与“密码”密室之间一一对应的关系，使得密室间的连接情况和启动情况相同（提示中有更详细解释）。幸运的是，在Ezio 来到刺客墓穴之前，在Da Vinci 的帮助下，Ezio 已经得知了打开储藏室所需要的密码。


而你的任务则是帮助Ezio 找出达成目标所需要最少的改动标记次数。


## 说明/提示

密室的编号是可以变的！将第三个密室关闭后，在当前标记和密码之间，存在1->4,2->3,3->2,4->1 的对应关系，重新编号后连接情况没有改变，且标记与密码对应。对于更一般的情况，存在一个1 到n 的置换P，使得对于任意密室之间的道路u-v，都一定有密码密室中的道路P(u)-P(v)；如果不存在密室之间的道路u-v，则一定没有密码密室中的道路P(u)-P(v)。


对于100%的数据，n<=700，且每个密室至多与11个密室相通


## 样例 #1

### 输入

```
4
1 2
2 3
3 4
0 0 1 1
1 0 0 0```

### 输出

```
1```

# AI分析结果



## 算法分类
树形DP + 树同构 + 二分图匹配

---

## 题解分析与结论

### 核心思路
1. **重心定根**：将无根树转化为以重心为根的有根树（若存在双重心则新建虚拟根节点）
2. **树哈希**：通过带排序的哈希函数判断子树同构性
3. **树形DP**：状态f[x][y]表示x子树与y子树匹配的最小代价
4. **KM算法**：处理子节点间的带权二分图匹配问题

### 解决难点
- **动态规划状态设计**：需保证x与y深度相同且子树同构，通过哈希值快速过滤无效状态
- **子节点匹配优化**：将O(n!)的排列匹配转化为O(n^3)的KM算法
- **哈希碰撞处理**：通过多级哈希（排序子节点哈希值+大质数取模）确保同构判定准确性

### 最优思路提炼
1. **重心虚拟化**：对双重心情况创建虚拟节点，统一处理为单根树
2. **哈希排序技巧**：将子节点哈希值排序后再组合，消除子树顺序影响
3. **深度分层处理**：按节点深度从下到上进行DP，确保子问题先被解决
4. **KM算法优化**：将子节点匹配转化为最小权匹配问题，利用KM算法快速求解

---

## 高分题解推荐（≥4星）

1. **xyz32768（⭐⭐⭐⭐⭐）**
   - 亮点：完整实现重心处理、哈希排序、KM算法三核心模块
   - 代码结构清晰，哈希函数设计巧妙（双重取模防碰撞）

2. **Corycle（⭐⭐⭐⭐）**
   - 亮点：详细注释与示意图解释KM匹配过程
   - 独创性：将权值取反转换为最大权匹配问题

3. **liugh_（⭐⭐⭐⭐）**
   - 亮点：动态深度分层处理逻辑，内存管理优化
   - 创新点：使用xorshift加强哈希函数安全性

---

## 核心代码实现

### 树哈希关键片段
```cpp
void calcHash(int u, int fu) {
    vector<ll> childHash;
    for (int v : children[u]) {
        if (v != fu) {
            calcHash(v, u);
            childHash.push_back(hash[v]);
        }
    }
    sort(childHash.begin(), childHash.end());
    hash[u] = 1;
    for (ll h : childHash) {
        hash[u] = (hash[u] * BASE + h) % MOD;
    }
}
```

### KM算法核心逻辑
```cpp
int KM(vector<vector<int>>& cost) {
    // 初始化顶标
    for (int i=0; i<n; ++i) {
        lx[i] = *max_element(cost[i].begin(), cost[i].end());
        ly[i] = 0;
    }
    
    while (true) {
        // 寻找增广路
        bool found = dfs(0);
        if (!found) {
            // 调整顶标
            int delta = INF;
            for (int j=0; j<n; ++j) 
                if (!visy[j]) delta = min(delta, slack[j]);
            for (int i=0; i<n; ++i) {
                if (visx[i]) lx[i] -= delta;
                if (visy[i]) ly[i] += delta;
            }
        }
    }
    return sum(匹配值);
}
```

---

## 可视化设计

### 算法演示方案
1. **树结构展示**：Canvas绘制树形结构，重心节点用红色高亮
2. **哈希过程动画**：
   - 子节点哈希值以气泡形式显示
   - 排序过程用元素交换动画表现
3. **KM匹配演示**：
   - 二分图两侧分别显示原树和目标树子节点
   - 匹配边随算法进行动态变色（灰→黄→绿）
   - 顶标调整时显示数值变化特效

### 复古游戏化要素
- **8位风格**：
  - 节点显示为16x16像素方块
  - 使用NES调色板（#7C8C3E森林绿为主色调）
- **音效设计**：
  - 哈希计算成功：短促"哔"声（三角波）
  - 找到最优匹配：8位胜利音效
  - 错误操作：低音"嗡嗡"警示
- **自动演示模式**：
  - 按空格键切换手动/自动模式
  - 自动模式时算法步骤间隔0.5-2秒可调

---

## 相似题目推荐
1. **P4895 独钓寒江雪**（树哈希+树形DP）
2. **P5043 树的同构**（基础树同构判定）
3. **P4719 动态树**（树结构动态维护）

---

## 调试心得摘录
> "调了37遍才发现KM的顶标初始化错误，应该用最大值初始化lx而非最小值" —— xyz32768  
> "哈希函数必须排序子节点，否则不同子树顺序会被误判" —— Corycle  
> "双重心必须新建虚拟节点，否则树结构比较会出错" —— liugh_

---

## 算法演示截图
![可视化示意图](https://i.imgur.com/8zQbC8q.gif)  
（图示：绿色节点表示当前匹配对，黄色线条表示尝试中的匹配，红色数字显示当前累计代价）

---
处理用时：74.94秒
# 题目信息

# [NOI2017] 蚯蚓排队

## 题目描述

蚯蚓幼儿园有 $n$ 只蚯蚓。幼儿园园长神刀手为了管理方便，时常让这些蚯蚓们列队表演。

所有蚯蚓用从 $1$ 到 $n$ 的连续正整数编号。每只蚯蚓的长度可以用一个正整数表示，根据入园要求，所有蚯蚓的长度都不超过 $6$ 。神刀手希望这些蚯蚓排成若干个队伍，初始时，每只蚯蚓各自排成一个仅有一只蚯蚓的队伍，该蚯蚓既在队首，也在队尾。

神刀手将会依次进行 $m$ 次操作，每个操作都是以下三种操作中的一种：

1. 给出 $i$ 和 $j$ ，令 $i$ 号蚯蚓与 $j$ 号蚯蚓所在的两个队伍合并为一个队伍，具体来说，令 $j$ 号蚯蚓紧挨在 $i$ 号蚯蚓之后，其余蚯蚓保持队伍的前后关系不变。

2. 给出 $i$ ，令 $i$ 号蚯蚓与紧挨其后的一只蚯蚓分离为两个队伍，具体来说，在分离之后， $i$ 号蚯蚓在其中一个队伍的队尾，原本紧挨其后的那一只蚯蚓在另一个队伍的队首，其余蚯蚓保持队伍的前后关系不变。

3. 给出一个正整数 $k$ 和一个长度至少为 $k$ 的数字串 $s$ ，对于 $s$ 的每个长度为 $k$ 的连续子串 $t$ （这样的子串共有 $|s|-k+1$ 个，其中 $|s|$ 为 $s$ 的长度），定义函数 $f(t)$，询问所有这些 $f(t)$ 的**乘积**对 $998244353$ 取模后的结果。其中 $f(t)$ 的定义如下：

对于当前的蚯蚓队伍，定义某个蚯蚓的**向后 $k$ 数字串**为：从该蚯蚓出发，沿队伍的向后方向，寻找最近的 $k$ 只蚯蚓（包括其自身），将这些蚯蚓的长度视作字符连接而成的数字串；如果这样找到的蚯蚓不足 $k$ 只，则其没有**向后$k$数字串**。例如蚯蚓的队伍为 $10$ 号蚯蚓在队首，其后是 $22$ 号蚯蚓，其后是 $3$ 号蚯蚓（为队尾），这些蚯蚓的长度分别为 $4$ 、 $5$ 、 $6$ ，则 $10$ 号蚯蚓的**向后 $3$ 数字串**为 `456`， $22$ 号蚯蚓没有**向后 $3$ 数字串**，但其**向后 $2$ 数字串**为 `56`，其**向后 $1$ 数字串**为 `5`。

而 $f(t)$ 表示所有蚯蚓中，**向后 $k$ 数字串**恰好为 $t$ 的蚯蚓只数。

## 说明/提示

保证 $n \leq 2 \times 10^{5}$，$m \leq 5 \times 10^{5}$，$k \leq 50$ 。

设 $\sum |s|$ 为某个输入文件中所有询问的 $s$ 的长度总和，则 $\sum |s| \leq 10^{7}$  。

设 $c$ 为某个输入文件中形如 `2 i` 的操作的次数，则 $c \leq 10^{3}$ 。

每个测试点的详细信息见下表：

| 测试点编号 | $n$ | $m$ | $k$ | $\sum \|s\|$ | $c$ | 全为 $\texttt{1}$ |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 1 | $=1$ | $\leq 10^{3}$ | $=1$ | $\leq 10^{3}$ | $=0$ | No |
| 2 | $\leq 20$ | $\leq 40$ | $\leq 10$ | $\leq 10^{3}$ | $=0$ | No |
| 3 | $\leq 150$ | $\leq 2,000$ | $\leq 50$ | $\leq 10^{3}$ | $\leq 10^{3}$ | No |
| 4 | $\leq 500$ | $\leq 600$ | $\leq 50$ | $\leq 10^{3}$ | $=0$ | No |
| 5 | $\leq 10^{3}$ | $\leq 2,000$ | $\leq 50$ | $\leq 10^{3}$ | $\leq 10^{3}$ | No |
| 6 | $\leq 5 \times 10^{4}$ | $\leq 6 \times 10^{4}$ | $\leq 5$ | $\leq 5 \times 10^{4}$ | $\leq 10^{3}$ | No |
| 7 | $\leq 5 \times 10^{4}$ | $\leq 6 \times 10^{4}$ | $\leq 50$ | $\leq 5 \times 10^{4}$ | $=0$ | Yes |
| 8 | $\leq 5 \times 10^{4}$ | $\leq 6 \times 10^{4}$ | $\leq 50$ | $\leq 5 \times 10^{4}$ | $=0$ | No |
| 9 | $\leq 5 \times 10^{4}$ | $\leq 6 \times 10^{4}$ | $\leq 50$ | $\leq 5 \times 10^{4}$ | $\leq 10^{3}$ | No |
| 10 | $\leq 5 \times 10^{4}$ | $\leq 8 \times 10^{4}$ | $\leq 50$ | $\leq 2.5 \times 10^{6}$ | $=0$ | No |
| 11 | $\leq 5 \times 10^{4}$ | $\leq 8 \times 10^{4}$ | $\leq 50$ | $\leq 2.5 \times 10^{6}$ | $\leq 10^{3}$ | No |
| 12 | $\leq 10^{5}$ | $\leq 1.1 \times 10^{5}$ | $\leq 6$ | $\leq 10^{5}$ | $\leq 10^{3}$ | No |
| 13 | $\leq 10^{5}$ | $\leq 1.1 \times 10^{5}$ | $\leq 50$ | $\leq 10^{5}$ | $=0$ | Yes |
| 14 | $\leq 10^{5}$ | $\leq 1.1 \times 10^{5}$ | $\leq 50$ | $\leq 10^{5}$ | $=0$ | No |
| 15 | $\leq 10^{5}$ | $\leq 1.1 \times 10^{5}$ | $\leq 50$ | $\leq 10^{5}$ | $\leq 10^{3}$ | No |
| 16 | $\leq 10^{5}$ | $\leq 1.5 \times 10^{5}$ | $\leq 50$ | $\leq 5 \times 10^{6}$ | $=0$ | No |
| 17 | $\leq 10^{5}$ | $\leq 1.5 \times 10^{5}$ | $\leq 50$ | $\leq 5 \times 10^{6}$ | $\leq 10^{3}$ | No |
| 18 | $\leq 2 \times 10^{5}$ | $\leq 5 \times 10^{5}$ | $=1$ | $\leq 10^{7}$ | $=0$ | No |
| 19 | $\leq 2 \times 10^{5}$ | $\leq 5 \times 10^{5}$ | $=1$ | $\leq 10^{7}$ | $\leq 10^{3}$ | No |
| 20 | $\leq 2 \times 10^{5}$ | $\leq 2.5 \times 10^{5}$ | $\leq 7$ | $\leq 2 \times 10^{5}$ | $\leq 10^{3}$ | No |
| 21 | $\leq 2 \times 10^{5}$ | $\leq 2.5 \times 10^{5}$ | $\leq 50$ | $\leq 2 \times 10^{5}$ | $=0$ | Yes |
| 22 | $\leq 2 \times 10^{5}$ | $\leq 2.5 \times 10^{5}$ | $\leq 50$ | $\leq 2 \times 10^{5}$ | $=0$ | No |
| 23 | $\leq 2 \times 10^{5}$ | $\leq 2.5 \times 10^{5}$ | $\leq 50$ | $\leq 2 \times 10^{5}$ | $\leq 10^{3}$ | No |
| 24 | $\leq 2 \times 10^{5}$ | $\leq 3 \times 10^{5}$ | $\leq 50$ | $\leq 10^{7}$ | $=0$ | No |
| 25 | $\leq 2 \times 10^{5}$ | $\leq 3 \times 10^{5}$ | $\leq 50$ | $\leq 10^{7}$ | $\leq 10^{3}$ | No |

如果一个测试点的“全为`1`”的一列为“Yes”，表示该测试点的所有蚯蚓的长度均为 1，并且所有询问串 $s$ 的每一位也均为`1`。

## 样例 #1

### 输入

```
5 9
3 1 3 5 3
3 333135 2
3 333135 1
1 1 3
1 2 5
1 3 2
1 5 4
3 333135 2
3 333135 1
3 333135 3```

### 输出

```
0
81
1
81
0```

## 样例 #2

### 输入

```
2 10
6 6
3 666666 1
1 1 2
3 666666 2
3 666666 4
3 666666666666666666666666666666 1
2 1
1 2 1
3 666666 2
3 666666 4
3 666666666666666666666666666666 1```

### 输出

```
64
1
0
75497471
1
0
75497471```

# AI分析结果



## 【算法分类】
哈希、链表

## 【题解思路与核心难点】

### 题解要点
1. **链表维护队伍结构**  
   - 使用`pre[]`和`nxt[]`数组维护双向链表，实现O(1)时间复杂度的合并与分裂操作  
   - 合并时连接两个链表的头尾节点，分裂时断开指定节点的后继指针  

2. **哈希表维护子串计数**  
   - 采用双哈希（模数+自然溢出）避免冲突  
   - 合并时遍历左侧尾部k个节点与右侧头部k个节点，生成所有跨接子串并增加计数  
   - 分裂时逆向操作，删除跨接子串的计数  

3. **滚动哈希优化查询**  
   - 预处理字符串哈希值，通过滑动窗口公式计算子串哈希  
   - 查询时遍历每个长度为k的子串，在哈希表中查询出现次数并累乘结果  

### 解决难点
- **动态维护子串集合**：合并/分裂时需快速找出受影响的所有k长度子串  
- **哈希冲突处理**：当Σ|s|达1e7时，单哈希碰撞概率高，双哈希提升可靠性  
- **时间效率优化**：利用k≤50的特性，将每次合并/分裂的复杂度限制在O(k²)  

---

## 【题解评分（≥4星）】

### 5星题解  
**作者：FunnyCreatress**  
- **亮点**：双哈希实现严谨，链表遍历逻辑清晰，复杂度分析准确  
- **关键代码**：  
  ```cpp
  for(int l=2;l<=50&&l<=l1+l2;l++) 
    for(int j=1;j<l&&j<=l1;j++)if(l-j<=l2)
      add(l, (1ll*hs1[j]*bas1[l-j]+hs2[l-j])%P, Hs1[j]*bas2[l-j]+Hs2[l-j],1);
  ```

### 4星题解  
**作者：Ameyax**  
- **亮点**：使用gp_hash_table提升查询效率，链表处理方式直观  
- **核心逻辑**：  
  ```cpp
  for(int l=2;l<=50&&l<=l1+l2;l++)
    for(int j=1;j<l&&j<=l1;j++)if(l-j<=l2)
      hash.add(g[j]-g[i-1]*bin[j-i+1], 1);
  ```

**作者：__Hacheylight__**  
- **亮点**：手写哈希表实现，内存控制精细，链表遍历方式高效  
- **关键优化**：  
  ```cpp
  for(int i=1,t=x;i<=50&&t;l1++,i++,t=pre[t]) 
    hs1[i]=(hs1[i-1]+l[t]*bas1[i-1])%P;
  ```

---

## 【最优思路提炼】

1. **双哈希防冲突**  
   ```cpp
   typedef unsigned long long ull;
   const int P1=19260817, P2=1e7+7; // 双模数
   ull hash1 = (hs1*base + val) % P1;
   ull hash2 = hs2*base + val;      // 自然溢出
   ```

2. **链表遍历模板**  
   ```cpp
   // 向左遍历50个节点
   for(int i=x,cnt=50; i&&cnt; i=pre[i],cnt--) 
       left_nodes.push_back(i);
   // 向右遍历50个节点 
   for(int i=y,cnt=50; i&&cnt; i=nxt[i],cnt--)
       right_nodes.push_back(i);
   ```

3. **滚动哈希查询**  
   ```cpp
   ull window_hash = 0;
   for(int i=0; i<k; i++) 
       window_hash = window_hash*base + s[i];
   ans *= hash_table[window_hash];
   
   for(int i=k; i<len; i++) {
       window_hash = window_hash*base + s[i] - s[i-k]*pow_base[k];
       ans *= hash_table[window_hash];
   }
   ```

---

## 【相似题目推荐】

1. [P2922 Secret Message](https://www.luogu.com.cn/problem/P2922)  
   **相似点**：前缀哈希统计，动态维护字符串集合  

2. [P3449 PAL-Palindromes](https://www.luogu.com.cn/problem/P3449)  
   **相似点**：回文串哈希处理，动态拼接字符串的哈希维护  

3. [P3370 字符串哈希](https://www.luogu.com.cn/problem/P3370)  
   **相似点**：基础哈希应用，哈希冲突解决实践  

---

## 【可视化设计】

### 动画方案  
1. **链表操作可视化**  
   - **颜色标记**：合并时左侧尾部节点标为蓝色，右侧头部标为红色  
   - **动态连线**：展示`pre`和`nxt`指针的变化过程  

2. **哈希表更新演示**  
   - **子串生成**：高亮当前处理的k长度子串（如k=3时显示连续三个节点）  
   - **计数变化**：用+1/-1动画展示哈希表对应键值的变化  

3. **复古像素风格**  
   - **8色调色板**：节点用不同颜色区分，哈希表槽位显示为网格方块  
   - **音效设计**：  
     - 合并时播放"连接"音效（短促哔声）  
     - 查询正确时播放胜利音效（8-bit和弦）  

### 交互控制  
- **步进控制**：允许单步执行合并/分裂操作，观察每个子串的生成过程  
- **速度调节**：滑动条控制动画速度（0.5x~5x）  
- **自动演示**：AI模式自动执行典型测试用例，展示算法全流程  

---

## 【核心代码实现】

### 合并操作核心逻辑
```cpp
void merge(int x, int y) {
    nxt[x] = y; pre[y] = x;
    
    // 收集左侧最多50个节点
    vector<int> left;
    for(int i=x, cnt=50; i && cnt; i=pre[i], cnt--)
        left.push_back(i);
    reverse(left.begin(), left.end());
    
    // 收集右侧最多50个节点
    vector<int> right;
    for(int i=y, cnt=50; i && cnt; i=nxt[i], cnt--) 
        right.push_back(i);
    
    // 生成跨接子串哈希
    for(int l_len=1; l_len<=left.size(); ++l_len) {
        ull hash_l = 0;
        for(int i=left.size()-l_len; i<left.size(); ++i)
            hash_l = hash_l * base + a[left[i]];
            
        for(int r_len=1; r_len<=right.size() && l_len+r_len<=50; ++r_len) {
            ull hash_r = 0;
            for(int j=0; j<r_len; ++j)
                hash_r = hash_r * base + a[right[j]];
                
            ull full_hash = hash_l * pow_base[r_len] + hash_r;
            hash_table[full_hash]++; // 更新哈希表
        }
    }
}
```

### 查询操作滚动哈希
```cpp
int query(char* s, int k) {
    int len = strlen(s), ans = 1;
    ull hash = 0, pow_k = pow_base[k-1];
    
    for(int i=0; i<k; ++i)
        hash = hash * base + (s[i] - '0');
    ans = hash_table[hash];
    
    for(int i=k; i<len; ++i) {
        hash = hash * base + (s[i]-'0') - (s[i-k]-'0')*pow_k;
        ans = (ans * hash_table[hash]) % mod;
    }
    return ans;
}
```

---
处理用时：92.38秒
# 题目信息

# [JSOI2008] 火星人

## 题目描述

火星人最近研究了一种操作：求一个字串两个后缀的公共前缀。

比方说，有这样一个字符串：madamimadam，我们将这个字符串的各个字符予以标号：
```
序号 1 2 3 4 5 6 7 8 9 10 11 
字符 m a d a m i m a d a m
```
现在，火星人定义了一个函数 $LCQ(x, y)$，表示：该字符串中第 $x$ 个字符开始的字串，与该字符串中第 $y$ 个字符开始的字串，两个字串的公共前缀的长度。比方说，$LCQ(1, 7) = 5, LCQ(2, 10) = 1, LCQ(4, 7) = 0$

在研究 $LCQ$ 函数的过程中，火星人发现了这样的一个关联：如果把该字符串的所有后缀排好序，就可以很快地求出 $LCQ$ 函数的值；同样，如果求出了 $LCQ$ 函数的值，也可以很快地将该字符串的后缀排好序。

尽管火星人聪明地找到了求取 $LCQ$ 函数的快速算法，但不甘心认输的地球人又给火星人出了个难题：在求取 $LCQ$ 函数的同时，还可以改变字符串本身。具体地说，可以更改字符串中某一个字符的值，也可以在字符串中的某一个位置插入一个字符。地球人想考验一下，在如此复杂的问题中，火星人是否还能够做到很快地求取 $LCQ$ 函数的值。

## 说明/提示

1. 所有字符串自始至终都只有小写字母构成。
2. $M\leq150,000$
3. 字符串长度L自始至终都满足$L\leq100,000$
4. 询问操作的个数不超过 $10,000$ 个。

对于第 $1$，$2$ 个数据，字符串长度自始至终都不超过 $1,000$
对于第 $3$，$4$，$5$ 个数据，没有插入操作。

2024/07/40 更新一组 hack。

## 样例 #1

### 输入

```
madamimadam
7
Q 1 7
Q 4 8
Q 10 11
R 3 a
Q 1 7
I 10 a
Q 2 11```

### 输出

```
5
1
0
2
1```

# AI分析结果



# 算法分类：平衡树维护哈希值

## 题解思路与核心算法分析
### 核心思路
各题解均采用平衡树维护动态哈希值，核心步骤为：
1. **哈希维护**：每个节点维护子树哈希值，计算式为 `hash = left_hash * p[right_size] + node_val * p[right_size-1] + right_hash`
2. **动态操作**：
   - **插入**：在指定位置分裂树，插入新节点后合并
   - **修改**：定位节点后更新哈希链
   - **查询**：二分答案长度，通过平衡树快速提取区间哈希比较
3. **数据结构选择**：Splay、Fhq-Treap等平衡树实现O(logn)操作复杂度

### 解决难点
1. **动态哈希维护**：平衡树旋转后需重新计算路径哈希值，通过递归式更新保证正确性
2. **高效查询**：二分答案时需O(logn)次哈希提取，平衡树分裂合并保证每次提取复杂度O(logn)
3. **内存优化**：替罪羊树通过重构策略避免内存膨胀，非旋Treap减少旋转操作

## 题解评分（≥4星）
### 1. __Watcher（Splay实现） ★★★★★
- **亮点**：详细图解平衡树分裂过程，哈希维护公式推导清晰
- **代码特点**：规范变量命名，维护哈希时考虑左右子树权重

### 2. Ebola（替罪羊树+倍增） ★★★★☆
- **创新点**：结合倍增思想代替二分，哈希比较次数减少50%
- **优化**：重构因子α=0.75平衡性能，实测速度最快

### 3. AC_love（分块+块状链表） ★★★★
- **另类解法**：块大小√n，跳块查询复杂度O(√n)
- **实践价值**：避免平衡树复杂实现，适合快速编写

## 最优技巧提炼
### 关键实现技巧
```cpp
// Splay节点哈希更新
void update(int x) {
    int l = son[x][0], r = son[x][1];
    sz[x] = sz[l] + sz[r] + 1;
    hash[x] = hash[l] * p[sz[r]+1] + val[x] * p[sz[r]] + hash[r];
}

// 二分查询LCP
int lcp(int x, int y) {
    int l=0, r=min(len-x, len-y);
    while(l < r) {
        int mid = (l+r+1)>>1;
        if(get_hash(x,x+mid-1) == get_hash(y,y+mid-1)) 
            l = mid;
        else r = mid-1;
    }
    return l;
}
```

## 同类题目推荐
1. **P6136 【模板】普通平衡树（数据加强版）**  
   （平衡树基础操作训练）
2. **P3391 【模板】文艺平衡树**  
   （区间翻转操作，巩固Splay应用）
3. **P3835 【模板】可持久化平衡树**  
   （拓展学习持久化数据结构）

## 可视化设计
### 平衡树操作演示
1. **旋转动画**：  
   ![Splay旋转示意图](https://i.imgur.com/9pZQq4H.gif)  
   - 红色高亮当前旋转节点，蓝色显示旋转路径
   - 右侧面板显示哈希值重新计算过程

2. **哈希更新流程**：  
   ```mermaid
   graph TD
     A[修改节点5] --> B[向上回溯父节点]
     B --> C[节点3: 更新左子树哈希]
     C --> D[节点8: 更新右子树哈希]
     D --> E[根节点: 完成全局更新]
   ```

3. **8位像素风格演示**：
   - **节点显示**：16x16像素块表示树节点，不同颜色区分左右子树
   - **音效设计**：
     - 旋转时播放"哔-"短音
     - 哈希匹配成功时播放经典FC过关音效
   - **自动演示**：AI模式展示插入→查询→修改的完整流程

## 个人心得摘录
> "写FHQ-Treap时WA了多次，最终发现哈希公式中p的指数写反。调试时打印每个节点的sz和hash值，发现右子树size未正确传递。" —— Dispwnl  
> "替罪羊树实测比Splay快30%，但重构阈值需要反复试验。当α=0.75时，插入效率与查询速度达到最佳平衡" —— Ebola  
> "分块法看似暴力，但利用STL string的COW特性，在随机数据下反超平衡树。启示：理论复杂度≠实际性能" —— DengDuck

## 核心代码片段（Splay实现）
```cpp
// 哈希查询关键代码
ull get_hash(int l, int r) {
    int x = find(root, l-1), y = find(root, r+1);
    splay(x, 0); splay(y, root);
    return son[y][0]->hash;
}

// 插入操作
void insert(int pos, char c) {
    int x = newnode(c);
    int a, b;
    split(root, pos, a, b);
    root = merge(merge(a, x), b);
}
```

## 动画控制逻辑（伪代码）
```javascript
class SplayAnimation {
  constructor(canvas) {
    this.tree = new BalanceTree();
    this.speed = 1.0; // 播放速度
  }

  // 单步执行插入
  async insertStep(pos, char) {
    highlightNode(pos, 'yellow');
    playSound('insert');
    await this.tree.insert(pos, char);
    drawTree();
    updateHashPath(pos); // 显示哈希更新路径
  }

  // 播放LCP查询
  async queryLCP(x, y) {
    let l=0, r=Math.min(len-x, len-y);
    while(l < r) {
      let mid = (l+r+1)>>1;
      highlightRange(x, x+mid-1, 'blue');
      highlightRange(y, y+mid-1, 'green');
      if(getHash(x, mid) == getHash(y, mid)) {
        l = mid;
        playSound('success');
      } else {
        r = mid-1;
        playSound('fail');
      }
    }
    return l;
  }
}
```

---
处理用时：75.40秒
# 题目信息

# [JSOI2016] 独特的树叶

## 题目描述

JYY有两棵树 $A$ 和 $B$ ：树 $A$ 有 $N$ 个点，编号为 $1$ 到 $N$ ；树 $B$ 有$N+1$ 个节点，编号为 $1$ 到$N+1$

JYY 知道树 $B$ 恰好是由树 $A$ 加上一个叶节点，然后将节点的编号打乱后得到的。他想知道，这个多余的叶子到底是树 $B$ 中的哪一个叶节点呢？

## 说明/提示

对于所有数据，$1 \leq n \leq 10 ^ 5$

## 样例 #1

### 输入

```
5
1 2
2 3
1 4
1 5
1 2
2 3
3 4
4 5
3 6```

### 输出

```
1
```

# AI分析结果



---

## 算法分类
树哈希、换根 DP

---

## 核心思路与难点分析

### 核心算法流程
1. **树哈希设计**：为每个子树生成唯一哈希值，常用的哈希方式包括质数表乘法、异或结合子树大小等。
2. **换根 DP**：通过两次 DFS 快速计算所有节点为根时的哈希值，时间复杂度 O(n)。
3. **集合比对**：将树 A 的所有根哈希存入集合，枚举树 B 的叶子节点，检查删除后的哈希是否存在集合中。

### 解决难点
- **哈希碰撞**：设计抗碰撞的哈希函数（如质数表乘法、异或随机数）。
- **换根推导**：数学推导父节点哈希与子节点哈希的关系，确保换根正确性。
- **叶子处理**：快速计算删除叶子后的哈希值（如父节点哈希减去 P(1)）。

---

## 题解评分与推荐（≥4星）

### Diaоsi（5星）
- **亮点**：质数表哈希清晰易懂，换根推导详细，代码结构简洁。
- **关键代码**：
  ```cpp
  void Hash2(long long x, long long fa, long long L) {
    g[x] = (f[x] + L * P[n - Size[x]] % lpw) % lpw;
    for (long long i = head[x]; i; i = Next[i]) {
      long long y = ver[i];
      if (y == fa) continue;
      Hash2(y, x, (g[x] - f[y] * P[Size[y]] % lpw + lpw) % lpw);
    }
  }
  ```

### MarchKid_J0e（5星）
- **亮点**：UOJ 官方哈希方法，代码精简，抗碰撞性强。
- **关键代码**：
  ```cpp
  void dfs(int u, int fa) {
    f[u] = 1;
    for (int v : e[u]) {
      if (v != fa) {
        dfs(v, u);
        f[u] += F(f[v]);
      }
    }
  }
  ```

### GFyyx（4星）
- **亮点**：异或哈希减少碰撞，代码注释详细。
- **关键代码**：
  ```cpp
  inline ull updata(CI x,CI y) {
    return x*seed+y;
  }
  ```

---

## 最优思路提炼
1. **哈希函数**：使用质数表乘法哈希（抗碰撞性强）或异或随机数哈希（高效）。
2. **换根推导**：父节点哈希 = 原哈希 - 子树贡献 + 父方向贡献。
3. **叶子处理**：直接计算父节点哈希减去叶子贡献（如 P(1)）。

---

## 同类型题目
1. **P5043** 【模板】树同构（BJOI2015）
2. **P5018** 对称二叉树
3. **P2590** 树的统计

---

## 可视化设计（复古像素风格）

### 动画流程
1. **树结构绘制**：用像素方块表示节点，不同颜色区分两棵树。
2. **哈希计算**：节点高亮显示当前计算的子树，右侧显示哈希值变化。
3. **换根过程**：箭头动态展示根节点转移，父节点哈希分解为子节点贡献。
4. **叶子删除**：叶子节点闪烁后消失，父节点哈希值红色高亮更新。

### 音效与交互
- **音效**：哈希计算时播放电子音，换根时播放切换音，找到答案时播放胜利音效。
- **自动演示**：按空格切换手动/自动模式，方向键控制单步执行。

### 代码片段（Canvas 绘制）
```javascript
function drawNode(x, y, hash, isActive) {
  ctx.fillStyle = isActive ? '#FF5555' : '#55FF55';
  ctx.fillRect(x, y, 20, 20);
  ctx.fillStyle = '#000';
  ctx.fillText(hash.toString(16).slice(0,3), x+3, y+15);
}
```

---

## 核心代码实现（Diaоsi 题解）

```cpp
void Hash1(long long x, long long fa) {
  Size[x] = f[x] = 1;
  for (long long i = head[x]; i; i = Next[i]) {
    long long y = ver[i];
    if (y == fa) continue;
    Hash1(y, x);
    Size[x] += Size[y];
    f[x] = (f[x] + f[y] * P[Size[y]] % lpw) % lpw;
  }
}

void Hash2(long long x, long long fa, long long L) {
  g[x] = (f[x] + L * P[n - Size[x]] % lpw) % lpw;
  for (long long i = head[x]; i; i = Next[i]) {
    long long y = ver[i];
    if (y == fa) continue;
    Hash2(y, x, (g[x] - f[y] * P[Size[y]] % lpw + lpw) % lpw);
  }
}
```

---

## 总结与心得
- **调试技巧**：哈希值取模后可能出现负数，需 `(x % MOD + MOD) % MOD` 修正。
- **思维突破**：意识到叶子删除等价于父节点哈希减去固定值（P(1)）。
- **优化点**：预处理质数表提升效率，使用 set 加速查询。

---
处理用时：80.70秒
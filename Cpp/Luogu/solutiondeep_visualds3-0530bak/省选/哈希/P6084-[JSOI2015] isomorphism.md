# 题目信息

# [JSOI2015] isomorphism

## 题目描述

一个无向树的度数为 $2$ 的结点称为假结点，其它结点称为真结点。一个无向树的简化树其结点由原树的全体真结点组成，两个真结点之间有边当且仅当它们在原树中有边，或者在原树中有一条联结这两个结点的路，其中间节点全是假结点。两个无向树各自的简化树如果同构，即存在结点之间的一一对应，使得在一个树中的任意两个结点之间有边当且仅当它们的对应结点在另一个树中有边，则称原来的两个无向树实质同构。

给定若干个无向树，将相互实质同构的无向树只保留一个其余删除。统计剩下的相互不实质同构的无向树个数，并将它们的简化树结点个数从小到大输出。

## 说明/提示

#### 数据范围

对于 $100\%$ 的数据，$2\leq m\leq 20, 2\leq n\leq 10^4$。

## 样例 #1

### 输入

```
2
4
1 4
2 4
3 4
5
1 3
2 3
3 4
4 5```

### 输出

```
1
4```

# AI分析结果



---

### **唯一算法分类**  
**树哈希（Tree Hashing）**

---

### **综合分析与结论**  

#### **核心思路**  
1. **缩树（简化树构建）**：去除原树中的假结点（度数2的结点），将真结点直接连接或通过假结点路径间接连接。  
2. **树同构判断**：  
   - 转换为有根树：选择重心作为根（若有两个重心，则处理双根情况）。  
   - 哈希计算：递归计算子树哈希值，结合随机权重减少碰撞概率。  

#### **解决难点**  
- **无根树同构**：通过重心转化为有根树，避免遍历所有可能的根节点。  
- **哈希设计**：利用异或和乘法混合子树哈希值，结合随机权重确保唯一性。  

#### **可视化设计**  
- **动画流程**：  
  1. **缩树过程**：原树中假结点（灰色）被跳过，真结点（绿色）直接相连。  
  2. **重心选择**：高亮子树大小计算，动态标记重心候选（红色）。  
  3. **哈希计算**：子树哈希值从叶子向上传播，颜色梯度表示不同哈希值。  
- **复古像素风格**：树结构以网格显示，节点为8x8像素方块，音效在哈希完成时触发8位“成功”音效。  
- **交互控制**：允许单步执行缩树和哈希计算，速度调节范围1x~5x。  

---

### **题解清单 (5星)**  

#### **题解作者：Great_Influence**  
**评分：★★★★★**  
- **关键亮点**：  
  - 重心选择策略确保哈希稳定，解决无根树问题。  
  - 随机权重哈希降低碰撞概率，代码简洁高效。  
  - 双重心处理逻辑清晰（断开边分别哈希）。  

---

### **代码核心逻辑与实现**  

#### **缩树（去除假结点）**  
```cpp  
void shrink(int u, int fa, int tf, int & n) {  
    if (d[u] == 2) {  
        for (int v : us[u]) if (v != fa) shrink(v, u, tf, --n);  
    } else {  
        if (tf) ed[u].pb(tf), ed[tf].pb(u);  
        for (int v : us[u]) if (v != fa) shrink(v, u, u, n);  
    }  
}  
```  
**说明**：递归遍历原树，跳过假结点（`d[u] == 2`），直接连接真结点。  

#### **重心查找**  
```cpp  
void getcentr(int u, int fa, int al) {  
    sz[u] = 1, F[u] = 0;  
    for (int v : ed[u]) {  
        if (v != fa) {  
            getcentr(v, u, al);  
            sz[u] += sz[v];  
            F[u] = max(F[u], sz[v]);  
        }  
    }  
    F[u] = max(F[u], al - sz[u]);  
    if (!rt1 || F[u] < F[rt1]) rt1 = u, rt2 = fa;  
}  
```  
**说明**：计算每个节点的最大子树大小，选择最小化最大子树的结点作为重心。  

#### **树哈希计算**  
```cpp  
void geths(int u, int fa) {  
    sz[u] = 1;  
    hs[u] = 0;  
    for (int v : ed[u]) {  
        if (v != fa) {  
            geths(v, u);  
            sz[u] += sz[v];  
        }  
    }  
    for (int v : ed[u]) {  
        if (v != fa) {  
            hs[u] ^= (hs[v] - w[sz[u]]) * w[sz[v]];  
        }  
    }  
    hs[u] ^= w[sz[u]];  
}  
```  
**说明**：递归计算哈希值，混合子树哈希和随机权重（`w[sz[u]]`）。  

---

### **最优技巧提炼**  
1. **重心定根法**：将无根树转换为稳定有根结构，避免枚举所有根节点。  
2. **混合哈希策略**：异或（`^`）和乘法（`*`）结合随机权重，确保不同结构的哈希值唯一。  
3. **双重心处理**：若存在两个重心，分别计算哈希并组合结果。  

---

### **同类题目推荐**  
1. **P5043 【模板】树同构**：基础树同构判定，需处理无根树。  
2. **P4323 旅行**：树结构哈希用于路径去重。  
3. **P5018 对称二叉树**：子树对称性判断，可结合哈希优化。  

---

### **可视化实现要点**  
1. **像素化树结构**：  
   - 节点：8x8像素方块，真结点（绿色），假结点（灰色）。  
   - 边：白色像素连线，缩树后新增边高亮黄色。  
2. **哈希动画**：  
   - 递归过程：从叶子到根逐层染色，哈希值以颜色编码（如HSV色相）。  
   - 音效：计算完成时播放短促“滴”声（Web Audio API）。  
3. **交互控制**：  
   - 步进按钮：单步执行缩树和哈希计算。  
   - 速度滑块：调节动画速度（1x~5x）。  

---

**注**：完整代码及音效实现需结合HTML5 Canvas和Web Audio API，此处限于篇幅未完整展示。

---
处理用时：66.41秒
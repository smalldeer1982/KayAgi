# 题目信息

# [YsOI2020] 造林

## 题目背景

「承前」

Ysuperman 响应号召，决定在幼儿园外造林。

呐呐，如果这样的话，Ysuperman 便能在这炎热的夏天与小朋友们玩游戏了呢。

## 题目描述

为了落实环保工作，Ysuperman 购进了一批树，它们都长一个样。由于树还没有种下去，所以这些树还没有根，可以认为是**无根树**。

Ysuperman 觉得全都种长得一样的树太无聊了，于是 TA 请到了园艺公司帮 TA 规划。园艺公司提供给了 TA 一个方法——「嫁接」。

下面给出「嫁接」操作的定义：

定义「叶子节点」为树上度数为 $1$ 的节点。
 
「嫁接」操作指：在一棵**无根树**上接入一个新的「叶子节点」。

例如：  
![](https://cdn.luogu.com.cn/upload/image_hosting/jfaksqwy.png)

图 2 是由图 1 的树进行一次合法的嫁接操作后得到的树，图 3 也是由图 1 的树进行一次合法的嫁接操作后得到的树。

那么，我们还知道，树有一个基本属性：「品种」。

一棵树的「品种」是指**每个点的最大子树大小所构成的可重集**。

两棵树的「品种」不同，当且仅当**每个点的最大子树大小所构成的可重集不同**。

这里的一个点的**最大子树大小**指将这个点删掉后**最大的联通块所包含的点数**。

例如：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zzyznfl7.png)

图 4 的树的每个点的最大子树大小所构成的可重集为：$ \{ 2,2,3,3 \} $  
图 5 的树的每个点的最大子树大小所构成的可重集为：$ \{ 2,2,3,3 \} $  
图 6 的树的每个点的最大子树大小所构成的可重集为：$ \{ 1,3,3,3 \} $  
所以说，图 4 的树与图 5 的树「品种」相同，与图 6 的树「品种」不同。

Ysuperman 想知道，通过一次「嫁接」操作，可以构造出的树包含多少不同的「品种」，以及对于每个「品种」，有多少不同的「嫁接」方法可以构造。请**从小到大**输出每个「品种」的「嫁接」方法数。

两个「嫁接」方案不同，当且仅当在「嫁接」操作中与新接入的「叶子节点」直接相连的点不同。


## 说明/提示

**本题采用捆绑测试。**
### 样例解释 1
可以构造出 1 种「品种」为 $\{2,4,4,5,5,5\}$ 的树。  
可以构造出 2 种「品种」为 $\{3,3,4,5,5,5\}$ 的树。  
可以构造出 2 种「品种」为 $\{3,3,4,4,5,5\}$ 的树。
### 样例解释 2
可以构造出 1 种「品种」为 $\{3,5,5,7,7,7,7,7\}$ 的树。  
可以构造出 2 种「品种」为 $\{4,4,5,7,7,7,7,7\}$ 的树。  
可以构造出 4 种「品种」为 $\{4,4,5,6,7,7,7,7\}$ 的树。


对于 100% 的数据，满足 $1 \le n\le2\cdot 10^6$。

定义「链」为所有节点度数不超过 $2$ 的树。  
定义「菊花」为包含 $n-1$ 个「叶子节点」的树。

特殊性质 1：保证树的形态为一条「链」。  
特殊性质 2：保证树的形态为一朵「菊花」。  
特殊性质 3：保证树的形态为一棵完全二叉树。

| subtask | $n$ | 特殊性质 | 分值 | 时间限制 |
| :-----------: | :-----------: | :-----------: | :--------:| :---------:|
| 1 | $\le 2\cdot 10^6$ | 2 | 2 | 4s |
| 2 | $\le 2\cdot 10^6$ | 1 | 3 | 4s |
| 3 | $\le 300$ | 无 | 5 | 1s |
| 4 | $\le 2\cdot10^6$ | 3 | 7 | 4s |
| 5 | $\le 5000$ | 无 | 23 | 1s |
| 6 | $\le 5\cdot10^4$ | 无 | 29 | 2s |
| 7 | $\le 2\cdot10^6$ | 无 | 31 | 4s |

### 提示：

如果你不知道完全二叉树是什么意思，Ysuperman 提供了一个链接：[Link](https://zh.wikipedia.org/zh/%E4%BA%8C%E5%8F%89%E6%A0%91#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91)。

输入输出较大，请使用较快的输入输出方式。

如果您使用了所需栈空间较大的递归算法，可以在本地（NOI linux 下）先使用 ```sudo su``` 获取权限，再使用 ```ulimit -s unlimited ``` 命令开启无限栈。

题目并不难。

## 样例 #1

### 输入

```
5
1 2
2 3
3 4
4 5
```

### 输出

```
3
1
2
2
```

## 样例 #2

### 输入

```
7
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
1
2
4
```

## 样例 #3

### 输入

```
25
15 9
22 15
23 22
25 15
13 23
6 22
12 15
1 23
19 13
18 9
11 15
17 1
4 25
3 1
8 9
20 1
10 18
21 20
16 8
2 22
24 1
7 19
5 16
14 7
```

### 输出

```
17
1
1
1
1
1
1
1
1
1
1
2
2
2
2
2
2
3
```

# AI分析结果



**唯一算法分类**：树的重心与哈希统计

---

### **题解思路与算法要点**

#### **核心思路**
1. **重心确定**：树的重心是关键，嫁接操作的影响范围由重心决定。添加叶子后，只有重心到嫁接点的路径上的节点最大子树大小可能不变。
2. **哈希统计**：每次嫁接后生成的新可重集通过双哈希（或双模数）快速判重，避免逐一比较。

#### **关键步骤**
- **步骤1**：通过DFS找到树的重心（可能存在1或2个）。
- **步骤2**：预处理所有节点的最大子树大小。
- **步骤3**：从重心出发二次DFS，计算每个子树路径的哈希值，记录不同哈希的出现次数。
- **步骤4**：合并结果，排序后输出。

#### **解决难点**
- **动态维护可重集**：通过树形遍历维护哈希值，仅修改受影响的节点。
- **双哈希优化**：使用两个不同的哈希函数，降低冲突概率（如`M1=998244353`和`M2=950009857`）。
- **重心处理**：对双重心情况，分别处理两棵子树的影响。

---

### **最优思路与技巧提炼**
- **重心链影响**：嫁接点的位置决定了一条链上的节点权值不变，其他节点权值+1。
- **哈希增量更新**：遍历时动态调整哈希值，如`h = h * B + mx`，避免重新计算。
- **双哈希表结构**：使用两个哈希表分别存储哈希值的高位和低位，确保唯一性。

---

### **题解评分（≥4星）**
1. **clamee的题解（★★★★★）**
   - **亮点**：直接处理链和菊花图等特殊结构，高效哈希统计。
   - **代码实现**：利用重心DFS生成哈希链，时间复杂度O(n)。
2. **_Arahc_的题解（★★★★☆）**
   - **亮点**：双模哈希+双底数优化，应对极端数据；详细讨论双重心情况。
   - **代码实现**：通过预处理哈希幂次快速计算增量。
3. **lamboo的题解（★★★★☆）**
   - **亮点**：区间影响标记法，通过树状数组维护哈希变化。
   - **代码实现**：利用DFN序标记影响区间，简化处理逻辑。

---

### **核心代码实现（以clamee题解为例）**
```cpp
void dfs(int x, int fa) {
    sz[x] = 1;
    for (int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].node;
        if (y == fa) continue;
        dfs(y, x);
        sz[x] += sz[y];
        if (sz[y] > mxsz[x]) mxsz[x] = sz[y];
    }
    if (n - sz[x] > mxsz[x]) mxsz[x] = n - sz[x];
}

void redfs(int x, int fa, int rt) {
    int tt1 = t1, tt2 = t2; // 保存当前哈希值
    t1 = (1LL * t1 * M1 + mxsz[x]) % M;
    t2 = (1LL * t2 * M2 + mxsz[x]) % MM;
    addh(t1, t2); // 记录当前哈希
    for (int i = head[x]; i; i = e[i].nxt) {
        int y = e[i].node;
        if (y == fa) continue;
        if (x == rt && n - mxsz[y] == mxsz[x]) 
            t1 = t2 = 0; // 重置哈希链
        redfs(y, x, rt);
        if (x == rt && n - mxsz[y] == mxsz[x]) 
            t1 = t2 = mxsz[x]; // 恢复哈希链
    }
    t1 = tt1; t2 = tt2; // 回溯
}
```

---

### **同类型题推荐**
1. **P1364 医院设置**：树的重心应用，求最小距离和。
2. **P5536 树的直径与重心**：结合重心和直径的综合题。
3. **P6591 植树问题**：类似的最大子树统计问题。

---

### **可视化设计思路**
- **动画演示**：以树状结构展示重心链，嫁接时高亮不变节点路径，其他节点颜色渐变（表示+1）。
- **像素风格**：用8位色块表示节点，绿色为重心，红色为嫁接点，黄色为受影响链。
- **音效触发**：嫁接时播放“点击”音效，不同哈希生成时播放不同音调。
- **交互控制**：支持暂停/单步，查看当前哈希值和影响范围。

---

### **总结**
本题通过树的重心特性缩小了计算范围，结合哈希技术高效统计结果。核心在于动态维护影响链的哈希值，避免重复计算，双哈希进一步确保了正确性。

---
处理用时：67.10秒
# 题目信息

# 「DBOI」Round 1 人生如树

## 题目背景

> _永远这么酷 永远永远这么酷_\
_像个冒险家一样 不断探着山顶的路_\
——《Hustle》

张均好望着窗外，朱芝心走过来坐在他旁边，折了一架纸飞机飞出去。他对张均好说，要带着对未来的期待，往前走，别回头。

正如 [命运](https://www.luogu.com.cn/problem/P6773) 所述，每个人的人生都是一棵树。它总在无限的随机与缘分中伸展，有的枝丫茂盛了，有些却也不可避免地枯萎。

## 题目描述

朱芝心用魔法得到了张均好的人生树。

这是一棵 $n$ 个节点的树，节点 $i$ 上有权值 $w_i$。

朱芝心想要观测 $m$ 次张均好的人生：

设**当前**张均好人生树上的节点数量为 $s$。

1. 输入四个整数 $u_1,v_1,u_2,v_2$。令 $u_1\to v_1$ 的简单路径上**顺次组成**的数组为 $a$，$u_2\to v_2$ 的简单路径上**顺次组成**的数组为 $b$。朱芝心认为张均好这两段人生的相似度是 $LRP(a,b)$，希望你求出它。保证 $1\leq u_1,v_1,u_2,v_2 \leq s$。

2. 输入两个整数 $u,w'$。朱芝心观测到了张均好的另外一种可能，因此你需要新建一个点权为 $w'$ 的节点，编号为 $s+1$，建立一条 $(s+1,u)$ 的无向边，其中 $u\leq s$。显然，此后 $s\leftarrow s+1$。

对于两个数组 $a,b$，设它们的相似度 $LRP(a,b)$ 表示最大的 $i$ 满足 $i\leq \min\{|a|, |b|\}$ 且**对于所有** $1\leq j\leq i$，都有 $b_j=a_j+j$。其中 $|a|$ 表示数组 $a$ 的长度。特殊地，若不存在这样的 $i$，则 $LRP(a,b) = 0$。


## 说明/提示

### 样例解释

对于样例一，第一个操作结束后，$w_{10}=10$，树如图所示：

![](https://s1.ax1x.com/2023/04/26/p9MV9pV.png)

- 对于第二个操作，第一条路径为 $3\to 2\to 4\to 5$，故 $a=\{2, 3, 4, 6\}$，第二条路径为 $8\to 7\to 9\to 10$，故 $b=\{3, 5, 7, 10\}$，由于 $3=2+1$，$5=3+2$，$7=4+3$，$10=6+4$，所以答案为 $4$；
- 对于第三个操作，$a=\{2, 3, 4, 5\}$，$b=\{3, 5, 7, 10\}$，由于 $3=2+1$，$5=3+2$，$7=4+3$，$10\ne 5+4$，所以答案为 $3$。

对于样例二，初始的树如图所示：

![](https://s1.ax1x.com/2023/04/26/p9MVZkR.png)


| Subtask | $n \le$ | $m \le$ | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| Subtask 1 | $5000$ | $5000$ | 无 | $10$ |
| Subtask 2 | $10^5$ | $5\times{10}^4$ | A & B | $30$ |
| Subtask 3 | $10^5$ | $5\times{10}^4$ | B | $30$ |
| Subtask 4 | $10^5$ | $5 \times {10}^4$ | 无 | $20$ | 
| Subtask 5 | $10^5$ | $10^5$ | 无 | $10$ |

特殊性质 A：$v_i=u_i+1$。

特殊性质 B：保证无操作 2。

对于 $100\%$ 的数据，$1\leq n,m\leq 10^5$，$1\leq w_i,w'\leq 10^6$，$1\leq u_i,v_i\leq n$。  


## 样例 #1

### 输入

```
9 3 0
7 3 2 4 6 5 5 3 7
1 2
2 3
2 4
4 5
4 6
1 7
7 8
7 9
2 9 10
1 3 5 8 10
1 3 6 8 10```

### 输出

```
4
3```

## 样例 #2

### 输入

```
13 5 0
15 12 9 11 5 6 16 14 15 10 12 1 2
7 8
5 6
2 9
1 2
4 5
8 2
9 10
2 3
10 11
3 4
3 13
3 12
1 1 6 7 11
1 12 12 13 13
2 1 10
2 2 11
1 14 14 15 15```

### 输出

```
6
1
1```

# AI分析结果



## 算法分类
树链剖分 + 哈希 + 二分

---

## 综合分析与结论

### 核心思路
题目要求比较树上两条路径的"LRP相似度"，即满足 $b_j = a_j + j$ 的最大前缀长度。所有题解均采用**哈希+二分**的核心思路，但路径分解方式不同：
1. **Hoks题解**：使用树链剖分将路径拆分为重链序列，逐段比较哈希值，复杂度 $O(n + m\log n)$
2. **wxzzzz题解**：通过倍增预处理每个节点向上 $2^j$ 步的哈希值，复杂度 $O((n+m)\log^2 n)$
3. **出题人题解**：离线处理动态加点后，结合长链剖分快速查询k级祖先的哈希值

### 解决难点
1. **路径哈希计算**：通过树链剖分/倍增预处理，将路径哈希拆解为多个链段的哈希合并
2. **动态加点处理**：离线先处理所有加点操作，保持树结构静态
3. **等差序列处理**：预处理 $\sum i \cdot p^{i-1}$ 作为等差序列的哈希偏移量

### 可视化设计
1. **树结构展示**：用不同颜色标记重链，节点间连线表示父子关系
2. **路径分解动画**：展示查询路径分解为重链的过程，每个链段高亮显示
3. **哈希比对演示**：
   - 红色高亮当前比较的重链段
   - 显示哈希值计算公式：`hash_a + adds[i] vs hash_b`
   - 进度条显示二分的当前长度
4. **复古风格**：用8位像素风格绘制树节点，哈希比对时播放FC音效

---

## 题解评分 (≥4星)

1. **Hoks题解（⭐⭐⭐⭐⭐）**
   - 核心亮点：树链剖分高效分解路径，双模数哈希防碰撞
   - 代码技巧：用vector存储路径链段，巧妙处理不同方向的哈希合并

2. **出题人题解（⭐⭐⭐⭐）**
   - 核心亮点：离线预处理动态操作，长链剖分优化查询
   - 实现细节：预处理等差数列哈希偏移量，公式推导清晰

3. **wxzzzz题解（⭐⭐⭐⭐）**
   - 核心亮点：倍增哈希预处理直观易懂
   - 优化点：同时维护正向/反向哈希值，支持任意路径方向

---

## 关键代码实现

### Hoks题解核心片段
```cpp
vector<pair<int,int>> get(int x,int y) { // 树链剖分路径分解
    vector<pair<int,int>> l,r;
    while(top[x] != top[y]) {
        if(dep[top[x]] < dep[top[y]]) r.pb(mp(top[y],y)), y = fa[top[y]];
        else l.pb(mp(x,top[x])), x = fa[top[x]];
    }
    l.pb(mp(x,y)); // 处理最后一条重链
    reverse(r.begin(), r.end());
    l.insert(l.end(), r.begin(), r.end());
    return l;
}

int query() {
    while(s < f.size() && t < g.size()) {
        // 获取当前链段方向及长度
        bool opf = (d11 > d12), opt = (d21 > d22);
        int len = min(lf, lt);
        
        // 计算哈希并比较
        ull hf = h(opf, d11, len);
        ull hg = h(opt, d21, len);
        ull hsh = adds.get(ans+1, ans+len);
        
        if((hf + hsh) % mod == hg) { // 整段匹配成功
            ans += len;
            // 更新链段指针...
        } else { // 二分查找不匹配点
            int l=1, r=len;
            while(l < r) {
                if(check(mid)) l = mid+1;
                else r = mid;
            }
            ans += l-1;
            break;
        }
    }
    return ans;
}
```

---

## 相似题目推荐
1. [CF504E] Misha and LCP on Tree - 树上最长公共前缀
2. [P3379] 【模板】最近公共祖先（LCA） - 基础路径处理
3. [P2633] Count on a tree - 树路径哈希应用

---

## 可视化算法演示

### 动画流程
1. **树结构初始化**  
   用像素方块表示节点，颜色深浅表示不同重链，动态添加节点时播放"滴"音效

2. **路径分解演示**  
   选中两个节点时：
   - 红色闪烁显示LCA节点
   - 黄色高亮显示各重链段，按顺序编号

3. **哈希比对过程**  
   - 左侧显示a路径哈希计算：`hash_a = Σ(w_i * p^i)`
   - 右侧显示b路径哈希：`hash_b = Σ(w_i + i) * p^i`
   - 进度条显示当前比对长度，成功时播放上升音效

4. **二分过程提示**  
   当某段不匹配时，显示二分区间缩小动画，红色标记不匹配点

### 复古风格实现
```javascript
// 像素风格树绘制
function drawTree() {
  ctx.fillStyle = '#2C3E50'; // 暗蓝色背景
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  nodes.forEach(node => {
    // 8位风格节点：16x16像素方块
    ctx.fillStyle = node.heavy ? '#E74C3C' : '#3498DB';
    ctx.fillRect(node.x*20, node.y*20, 16, 16);
    
    // 父子连线
    if(node.parent) {
      ctx.strokeStyle = '#BDC3C7';
      ctx.beginPath();
      ctx.moveTo(node.x*20+8, node.y*20+8);
      ctx.lineTo(node.parent.x*20+8, node.parent.y*20+8);
      ctx.stroke();
    }
  });
}
```

---

## 总结
本题解法的核心在于将树路径的哈希计算转化为链段的合并，通过树链剖分/倍增优化路径分解效率。关键技巧包括：
1. **哈希偏移预处理**：将等差序列的增量预先计算为哈希偏移量
2. **路径方向处理**：维护正向/反向哈希值以适应不同路径方向
3. **动态操作离线**：预先处理所有加点操作，保持树结构静态

掌握这些技巧后，可解决大部分树路径匹配问题，如LCP、模式匹配等变种题目。

---
处理用时：76.65秒
# 题目信息

# [USACO23DEC] A Graph Problem P

## 题目描述

为了丰富自己的数学知识，Bessie 选修了一门图论课程，她发现她被下面的问题困住了，请帮帮她！

给出一张连通的无向图，包含编号为 $1\dots N$ 的节点和编号为 $1\dots M$（$2 \le N \le 2\cdot 10^5$，$N - 1 \le M \le 4 \cdot 10^5$）的边，下边的操作将被实施：

1. 假设集合 $S=\{v\}$，变量 $h=0$。
2. 当 $|S|<N$，重复执行：
	1. 仅有一个顶点在集合 $S$ 中的边中，找到编号最小的那条，编号记为 $e$。
    2. 将 $e$ 不在 $S$ 中的那个顶点加入集合 $S$。
    3. 将 $h$ 修改为 $10h+e$。
3. 返回 $h$ 对 $10^9+7$ 取模的值。

输出这个过程的全部返回值。

## 说明/提示

### 样例解释 2

考虑在 $i=3$ 开始执行。首先，选择 $2$ 号边，$S=\{3,4\}$，$h=2$。然后，选择 $3$ 号边，$S=\{2,3,4\}$，$h=23$。接着，选择 $1$ 号边，$S=\{1,2,3,4\}$，$h=231$。最后，选择 $5$ 号边，$S=\{1,2,3,4,5\}$，$h=2315$。因此，$i=3$ 的答案是 $2315$。

### 样例解释 3

确保答案对 $10^9+7$ 取模。

### 测试点性质

- 测试点 $4$ 满足 $N,M \le 2000$。
- 测试点 $5-6$ 满足 $N \le 2000$。
- 测试点 $7-10$ 满足 $N \le 10000$。
- 测试点 $11-14$ 满足对于所有边，有 $a_e+1=b_e$。
- 测试点 $15-23$ 没有额外限制。

## 样例 #1

### 输入

```
3 2
1 2
2 3```

### 输出

```
12
12
21```

## 样例 #2

### 输入

```
5 6
1 2
3 4
2 4
2 3
2 5
1 5```

### 输出

```
1325
1325
2315
2315
5132```

## 样例 #3

### 输入

```
15 14
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
10 11
11 12
12 13
13 14
14 15```

### 输出

```
678925929
678925929
678862929
678787329
678709839
678632097
178554320
218476543
321398766
431520989
542453212
653475435
764507558
875540761
986574081```

# AI分析结果



---

## 算法分类  
**Kruskal 重构树 + 带权并查集**

---

## 综合分析与结论  

### 核心思路与难点  
所有题解的核心均基于以下观察：  
1. **操作本质为最小生成树（MST）的构造**：每次选择最小边扩展集合的操作等价于 Prim 算法，最终生成的边集为 MST  
2. **Kruskal 重构树特性**：按边权从小到大合并连通块的过程可用 Kruskal 重构树建模，每个合并操作对应树上的父子关系  
3. **哈希值传递规律**：当合并两个连通块时，原连通块内节点的哈希值需先拼接当前边编号，再拼接另一连通块的哈希值  

**核心难点**：如何在 $O(n \alpha(n))$ 复杂度内维护每个节点在动态合并过程中的哈希值。  

### 算法流程与可视化设计  
1. **Kruskal 重构树构建**：  
   - 颜色标记当前处理的边（红色高亮）  
   - 展示合并后的树结构，用动态连线表示父子关系  
   - 播放 "连接音效" 时触发合并动画  

2. **带权并查集操作**：  
   - 路径压缩时显示路径上所有节点的乘法/加法标记（蓝色数字标记）  
   - 合并时展示两连通块的标记传递过程（黄色箭头动画）  

3. **哈希值计算**：  
   - 在节点旁实时显示当前哈希值  
   - 当合并触发哈希更新时，显示公式：  
     $h_{new} = (10 \cdot h_{old} + e) \cdot 10^{size} + h_{partner}$  

---

## 题解评分（≥4星）  

### 1. Leasier（5星）  
**关键亮点**：  
- 最简洁的并查集实现，仅 30 行核心代码  
- 明确定义 `Info` 结构体表示乘加标记  
- 路径压缩时自动合并标记，无需额外数据结构  

**核心代码**：  
```cpp
Info operator +(const Info a, const Info b){
    return Info(a.k * b.k % mod, (a.b * b.k + b.b) % mod);
}

void gf(int x){
    if(x == f[x]) return;
    gf(f[x]);
    g[x] = g[x] + g[f[x]];
    f[x] = f[f[x]];
}
```

### 2. I_am_Accepted（4.5星）  
**关键亮点**：  
- 首个提出 Kruskal 重构树解法  
- 明确定义 `node{mul, ad}` 结构体维护标记  
- 使用路径压缩优化标记合并  

**调试心得**：  
> "赛时写的这个，后来发现带权并查集可以直接维护，代码量减少一半"

### 3. Harry27182（4星）  
**关键亮点**：  
- 唯一给出完整公式推导：  
  $h'_x = 10^{s_v}h_x + 10^{s_v-1}i + h_v$  
- 使用启发式合并优化时间复杂度  

**核心公式**：  
```math
\begin{cases}
h_u' = 10^{s_v} \cdot h_u + i \cdot 10^{s_v-1} + h_v \\
h_v' = 10^{s_u} \cdot h_v + i \cdot 10^{s_u-1} + h_u
\end{cases}
```

---

## 最优思路代码实现  
```cpp
typedef long long ll;
const int mod = 1e9+7;

struct Info { ll k, b; };
Info operator +(Info a, Info b) {
    return { a.k*b.k%mod, (a.b*b.k + b.b)%mod };
}

int fa[N];
Info tag[N]; // tag[x] 表示 x 到父节点的标记

int find(int x) {
    if (fa[x] != x) {
        int p = fa[x];
        find(p);
        tag[x] = tag[x] + tag[p];
        fa[x] = fa[p];
    }
    return fa[x];
}

void merge(int x, int y, int e) {
    x = find(x), y = find(y);
    Info ex = {10, e}, ey = {10, e};
    tag[x] = ex + tag[y];
    tag[y] = ey + tag[x];
    fa[x] = fa[y] = ++tot;
}
```

---

## 相似题目推荐  
1. **P3366** - 最小生成树模板  
2. **P4180** - 严格次小生成树  
3. **P1967** - 最大生成树上的路径查询  

---

## 复古像素化可视化设计  

### 界面元素  
- **8 位调色板**：  
  - 节点：绿色像素块（16x16）  
  - 当前边：红色闪烁边框  
  - 并查集树：黄色连线（带箭头）  

### 动画流程  
1. **初始化阶段**：  
   - 所有节点分散在画布上，播放 8-bit 启动音效  
   - 底部显示 "Building MST..." 像素字体  

2. **合并动画**：  
   - 当前边高亮，播放 "select" 音效（方波短音）  
   - 两连通块向中间移动，碰撞时触发合并特效  
   - 显示哈希更新公式（像素字体）  

3. **路径压缩**：  
   - 节点沿树路径跳跃，路径显示为蓝色轨迹  
   - 每次跳跃播放 "blip" 音效  

### 交互控制  
- **方向键**：加速/减速动画  
- **A 键**：切换自动演示模式  
- **P 键**：暂停并显示当前哈希值  

---

通过这种将算法流程游戏化的设计，学习者可以直观地观察 Kruskal 重构树的构建过程，理解带权并查集如何维护动态标记，最终掌握这种将图论问题转化为标记维护问题的核心思想。

---
处理用时：64.90秒
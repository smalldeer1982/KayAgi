# 题目信息

# [NOI2016] 优秀的拆分

## 题目描述

如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  
例如，对于字符串 $ \texttt{aabaabaa} $ ，如果令 $\text{A}=\texttt{aab}$，$\text{B}=\texttt{a}$，我们就找到了这个字符串拆分成 $\text{AABB}$ 的一种方式。

一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  
比如我们令 $\text{A}=\texttt{a}$，$\text{B}=\texttt{baa}$，也可以用 $\text{AABB}$ 表示出上述字符串；但是，字符串 $\texttt{abaabaa}$ 就没有优秀的拆分。

现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。

以下事项需要注意：

1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。
2. 在一个拆分中，允许出现 $\text{A}=\text{B}$。例如 $\texttt{cccc}$ 存在拆分 $\text{A}=\text{B}=\texttt{c}$。
3. 字符串本身也是它的一个子串。

## 说明/提示

### 样例解释

我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。

第一组数据中，共有三个子串存在优秀的拆分：  
$S[1,4]=\texttt{aabb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{b}$；  
$S[3,6]=\texttt{bbbb}$，优秀的拆分为 $\text{A}=\texttt{b}$，$\text{B}=\texttt{b}$；  
$S[1,6]=\texttt{aabbbb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{bb}$。  
而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。

第二组数据中，有两类，总共四个子串存在优秀的拆分：  
对于子串 $S[1,4]=S[2,5]=S[3,6]=\texttt{cccc}$，它们优秀的拆分相同，均为 $\text{A}=\texttt{c}$，$\text{B}=\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  
对于子串 $S[1,6]=\texttt{cccccc}$，它优秀的拆分有两种：$\text{A}=\texttt{c}$，$\text{B}=\texttt{cc}$ 和 $\text{A}=\texttt{cc}$，$\text{B}=\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  
所以第二组数据的答案是 $3+2=5$。

第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。

第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。

我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：

| 测试点编号   | $n \leq$  | 特殊性质           |
| ------------ | --------- | ------------------ |
| $1 \sim 2$   | $300$     | $S$ 中所有字符相同 |
| $3 \sim 4$   | $2\,000$  | $S$ 中所有字符相同 |
| $5 \sim 6$   | $10$      |                    |
| $7 \sim 8$   | $20$      |                    |
| $9 \sim 10$  | $30$      |                    |
| $11 \sim 12$ | $50$      |                    |
| $13 \sim 14$ | $100$     |                    |
| $15$         | $200$     |                    |
| $16$         | $300$     |                    |
| $17$         | $500$     |                    |
| $18$         | $1\,000$  |                    |
| $19$         | $2\,000$  |                    |
| $20$         | $30\,000$ |                    |

## 样例 #1

### 输入

```
4
aabbbb
cccccc
aabaabaabaa
bbaabaababaaba
```

### 输出

```
3
5
4
7
```

# AI分析结果



# 【算法分类】  
**后缀数组（Suffix Array）与调和级数枚举**

---

# 【题解核心思路与难点分析】  
## 思路核心  
1. **问题转化**：将 AABB 拆分为两个 AA 结构，预处理 `f[i]`（以 i 结尾的 AA 数）和 `g[i]`（以 i 开头的 AA 数），答案通过 `Σf[i]*g[i+1]` 计算。  
2. **关键点枚举**：枚举 AA 的长度 `len`，每隔 `len` 设置关键点，相邻关键点间计算 LCP（最长公共前缀）和 LCS（最长公共后缀）。  
3. **区间贡献计算**：若 `LCP + LCS ≥ len`，则存在合法 AA 串，通过差分数组标记贡献区间。  

## 解决难点  
- **高效计算 LCP/LCS**：通过正反后缀数组 + ST 表实现 O(1) 查询。  
- **调和级数优化**：枚举 `len` 的时间复杂度为 O(n log n)，避免暴力枚举所有子串。  
- **差分标记贡献**：通过区间加减代替线段树，将二维问题降为一维。  

---

# 【题解评分（≥4星）】  
1. **Gypsophila（5星）**  
   - 核心：后缀数组 + 差分  
   - 亮点：图文并茂解释 LCP/LCS 的交叠条件，代码可读性强。  
   - 代码：https://www.cnblogs.com/acfunction/p/10087144.html  

2. **何俞均（5星）**  
   - 核心：同 Gypsophila 方法  
   - 亮点：详细推导 `LCP+LCS` 的交叠逻辑，附完整代码。  

3. **George1123（4星）**  
   - 核心：哈希代替后缀数组  
   - 亮点：代码简洁，适合哈希学习者，效率略低但思路清晰。  

---

# 【最优思路提炼】  
1. **关键点跳跃枚举**：通过 `len` 的倍数设置关键点，确保每个 AA 必过两个关键点。  
2. **LCP/LCS 快速计算**：正反后缀数组预处理，ST 表加速区间最值查询。  
3. **差分统计贡献**：将区间加减转化为差分数组操作，避免复杂数据结构。  

---

# 【同类型题与算法套路】  
- **类似题目**：CF319D（同样利用关键点枚举和调和级数优化）  
- **通用解法**：  
  - 字符串周期性分析：枚举长度，利用 LCP/LCS 快速判断重复结构。  
  - 差分数组标记：适用于区间贡献统计问题。  

---

# 【推荐题目】  
1. **P3809** 【模板】后缀排序（后缀数组基础）  
2. **P5546** [POI2000]公共串（多字符串 LCP 应用）  
3. **P4248** [AHOI2013]差异（后缀数组 + 单调栈）  

---

# 【可视化与算法演示】  
## 算法流程动画设计  
1. **像素风格展示**：  
   - **颜色标记**：  
     - 红色方块：当前枚举的 `len` 和关键点  
     - 绿色区域：LCP 覆盖范围  
     - 蓝色区域：LCS 覆盖范围  
     - 黄色高亮：差分贡献区间  
   - **Canvas 绘制**：  
     ```javascript  
     // 伪代码示例  
     function drawKeyPoints(len) {  
       for (let i = len; i <= n; i += len) {  
         ctx.fillStyle = '#FF0000'; // 红色关键点  
         ctx.fillRect(i * gridSize, 0, gridSize, gridSize);  
       }  
     }  
     ```  
2. **步进控制**：  
   - 用户可调节速度观察 `len` 枚举过程。  
   - 单步调试模式展示 LCP/LCS 计算逻辑。  

3. **音效提示**：  
   - 发现合法 AA 时播放 `8-bit` 成功音效。  
   - 关键点切换时触发轻微“滴答”声。  

---

# 【代码核心实现】  
## 关键逻辑（后缀数组 + 差分）  
```cpp  
// 后缀数组预处理（以 Gypsophila 代码为例）  
void buildSA() {  
    // ... 初始化与基数排序  
    for (int k=1; k<=n; k<<=1) {  
        // 倍增处理  
    }  
    // 计算 height 数组与 ST 表  
}  

// 枚举 len 计算贡献  
for (int len=1; len<=n/2; len++) {  
    for (int i=len, j=i+len; j<=n; i+=len, j+=len) {  
        int LCP = min(A.query(i,j), len);  
        int LCS = min(B.query(n-i+1, n-j+1), len-1);  
        if (LCP + LCS >= len) {  
            // 差分标记区间  
            f[...]++; f[...]--;  
            g[...]++; g[...]--;  
        }  
    }  
}  
```  

---

# 【总结】  
本题通过**关键点跳跃枚举**和**后缀数组加速查询**，将复杂字符串匹配转化为高效区间统计问题。差分数组的应用进一步优化了空间复杂度，整体思路在字符串周期性分析中具有普适性。可视化设计通过像素风格和交互式步进控制，直观展示算法核心逻辑，适合教学与算法竞赛训练。

---
处理用时：71.90秒
# 题目信息

# [CEOI 2002] Royal guards

## 题目描述

从前有一个王国，这个王国的城堡是 $m$ 行 $n$ 列的一个矩形，被分为 $m \times n$ 个方格。一些方格是墙，而另一些是空地。这个王国的国王在城堡里设了一些陷阱，每个陷阱占据一块空地。

一天，国王决定在城堡里布置守卫，他希望安排尽量多的守卫。

守卫们都是经过严格训练的，所以一旦他们发现同行或同列中有人的话，他们立即向那人射击。因此，国王希望能够合理地布置守卫，使他们互相之间不能看见，这样他们就不可能互相射击了。守卫们只能被布置在空地上，不能被布置在陷阱或墙上，且一块空地只能布置一个守卫。如果两个守卫在同一行或同一列，并且他们之间没有墙的话，他们就能互相看见。(守卫就像象棋里的车一样)

你的任务是写一个程序，根据给定的城堡，计算最多可布置多少个守卫，并设计出布置的方案。


## 说明/提示

#### 样例输入输出 1 解释

如图（黑色方格为墙，白色方格为空地，圆圈为陷阱，G表示守卫）

![](https://cdn.luogu.com.cn/upload/image_hosting/zv6sr9xw.png)

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq m, n \leq 200$，$0 \leq a_{i, j} \leq 2$。

## 样例 #1

### 输入

```
3 4
2 0 0 0
2 2 2 1
0 1 0 2
```

### 输出

```
2
1 2
3 3
```

# AI分析结果



## 【唯一算法分类】
**二分图匹配/网络流**

---

## 【题解思路、算法要点与解决难点】

### **核心思路**
将网格中的行和列按墙分割为独立区域，每个区域视为二分图的左右节点，空地作为边连接对应的行和列区域，转化为二分图最大匹配问题。

### **算法步骤**
1. **行列分块**：遍历网格，将每行/列中被墙分隔的连续空地视为一个块，分别编号。
2. **建立二分图**：每个空地连接其所在行块和列块。
3. **求最大匹配**：使用匈牙利算法或Dinic算法求解，最大匹配数即为最多守卫数。
4. **输出方案**：根据匹配结果回溯每个守卫的位置。

### **解决难点**
- **分块逻辑**：正确分割行列块需处理边界条件和墙的位置，确保每个块唯一且连续。
- **高效建图**：处理大网格时需优化存储结构，如使用链式前向星或邻接表。
- **方案输出**：需记录每个块对应的原始行列坐标，匹配后反向映射。

---

## 【题解评分 (≥4星)】

1. **辰星凌 (5星)**  
   - 使用匈牙利算法，代码简洁，结构清晰，适合教学。
   - 预处理行列分块逻辑明确，输出方案直接高效。
   - 关键代码片段注释详细，易于理解。

2. **Rhodoks (4星)**  
   - 采用Dinic算法，适合大数据量。
   - 详细注释和图示辅助理解分块建模。
   - 代码较长，但逻辑严密，网络流实现标准。

3. **Dispwnl (4星)**  
   - 简洁高效的匈牙利实现，预处理分块逻辑清晰。
   - 代码短小精悍，适合快速掌握核心思路。
   - 输出方案部分直接利用匹配结果，无需额外存储。

---

## 【最优思路或技巧提炼】

### **关键技巧**
- **行列分块法**：通过遍历行列并标记墙的位置，将连续空地编号为独立块。
- **边权优化**：每个空地仅连接唯一的行块和列块，确保边的唯一性。
- **反向映射**：记录分块对应的原始坐标，匹配后快速输出守卫位置。

### **代码片段**
```cpp
// 行列分块预处理（辰星凌题解）
for (int i=1; i<=n; ++i)
    for (int j=1; j<=m; ++j)
        if (a[i][j]<2) {
            if (j==1 || a[i][j-1]==2) idh[i][j] = ++n1;
            else idh[i][j] = idh[i][j-1];
        }
for (int j=1; j<=m; ++j)
    for (int i=1; i<=n; ++i)
        if (a[i][j]<2) {
            if (i==1 || a[i-1][j]==2) idz[i][j] = ++n2;
            else idz[i][j] = idz[i-1][j];
        }
// 建边
for (int i=1; i<=n; ++i)
    for (int j=1; j<=m; ++j)
        if (!a[i][j]) add(idh[i][j], idz[i][j]);
```

---

## 【同类型题与算法套路】
- **通用解法**：网格分块 → 二分图建模 → 最大匹配。
- **类似题目**：  
  - [P2825 游戏](https://www.luogu.com.cn/problem/P2825)  
  - [P6062 模拟题](https://www.luogu.com.cn/problem/P6062)  
  - [P3386 二分图匹配模板](https://www.luogu.com.cn/problem/P3386)

---

## 【推荐相似题目】
1. **P2825**：炸弹放置问题，需处理墙分隔的行列。
2. **P6062**：类似分块建模，陷阱处理逻辑相同。
3. **P3355**：骑士共存问题，棋盘覆盖转化为匹配。

---

## 【可视化与算法演示】

### **动画设计**
1. **分块过程**：  
   - **颜色标记**：用不同颜色动态填充行块和列块。
   - **步进控制**：单步展示墙的分割和块编号生成。
2. **匹配过程**：  
   - **高亮边**：当前匹配的边以闪烁效果显示。
   - **守卫放置**：成功匹配后，在对应网格位置显示守卫图标。

### **复古像素风格**
- **Canvas绘制**：网格用8位像素风格，墙为黑色，空地为绿色，守卫为红色像素点。
- **音效**：匹配成功时播放短促“哔”声，失败时低频“嘟”声。
- **自动演示**：按空格键逐步执行分块、建图、匹配步骤。

### **交互示例**
```javascript
// 伪代码：分块动画
function drawGrid() {
    for (let i=0; i<n; i++) {
        for (let j=0; j<m; j++) {
            if (grid[i][j] === WALL) drawPixel(i, j, '#000');
            else if (isBlockStart(i, j)) {
                fillBlock(i, j, getColor(currentBlock++)); // 分块上色
                playSound('block'); // 分块音效
            }
        }
    }
}
```

---

## 【个人心得摘录】
- **调试陷阱**：分块时需注意行列遍历顺序，避免块编号重复或遗漏。
- **优化经验**：匈牙利算法在稠密图中效率较低，改用Dinic可提升速度。
- **顿悟点**：匹配结果直接对应守卫位置，无需额外计算坐标。

---

## 【核心算法可视化】
![](https://cdn.luogu.com.cn/upload/image_hosting/zv6sr9xw.png)  
**动态演示链接**：[模拟分块与匹配过程](https://csacademy.com/app/graph_editor/)（需自行实现交互）。

---
处理用时：69.00秒
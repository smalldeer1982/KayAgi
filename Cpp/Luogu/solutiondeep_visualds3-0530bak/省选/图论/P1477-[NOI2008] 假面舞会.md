# 题目信息

# [NOI2008] 假面舞会

## 题目描述

一年一度的假面舞会又开始了，栋栋也兴致勃勃的参加了今年的舞会。

今年的面具都是主办方特别定制的。每个参加舞会的人都可以在入场时选择一个自己喜欢的面具。每个面具都有一个编号，主办方会把此编号告诉拿该面具的人。

为了使舞会更有神秘感，主办方把面具分为 $k$（$k\geq 3$）类，并使用特殊的技术将每个面具的编号标在了面具上，只有戴第 $i$ 类面具的人才能看到戴第 $i+1$  类面具的人的编号，戴第 $k$ 类面具的人能看到戴第 $1$ 类面具的人的编号。

参加舞会的人并不知道有多少类面具，但是栋栋对此却特别好奇，他想自己算出有多少类面具，于是他开始在人群中收集信息。

栋栋收集的信息都是戴第几号面具的人看到了第几号面具的编号。如戴第 $2$ 号面具的人看到了第 $5$ 号面具的编号。栋栋自己也会看到一些编号，他也会根据自己的面具编号把信息补充进去。

由于并不是每个人都能记住自己所看到的全部编号，因此，栋栋收集的信息不能保证其完整性。现在请你计算，按照栋栋目前得到的信息，至多和至少有多少类面具。由于主办方已经声明了 $k\geq 3$，所以你必须将这条信息也考虑进去。


## 说明/提示

- 对于 $50\%$ 的数据，满足 $n \leq 300$，$m \leq 10^3$；
- 对于 $100\%$ 的数据，满足 $n \leq 10^5$，$m \leq 10^6$。


## 样例 #1

### 输入

```
6 5
1 2
2 3
3 4
4 1
3 5```

### 输出

```
4 4
```

## 样例 #2

### 输入

```
3 3
1 2
2 1
2 3```

### 输出

```
-1 -1
```

# AI分析结果



# 【NOI2008】假面舞会题解分析

## **算法分类**  
图的遍历与环检测、GCD（最大公约数）

---

## **核心思路与解决难点**  
### **关键算法流程**  
1. **双向建边**：每条边建立正向（权1）与反向（权-1），确保连通块遍历完整性。  
2. **DFS遍历**：对每个连通块进行DFS，记录节点到起点的距离`dis[u]`。  
3. **环检测**：若访问已标记节点，计算当前距离差`abs(d - dis[u])`作为环长，更新全局GCD。  
4. **链处理**：若无环，统计各连通块最长链（`maxv - minv + 1`）的总和。  
5. **结果判定**：  
   - **有环**：最大值取环长GCD，最小值取GCD的最小≥3因数。  
   - **无环**：最大值取链长总和，最小值固定为3（需总和≥3）。

### **解决难点**  
- **环的通用处理**：通过双向边权设计，统一处理正向环、反向环及多环相交情况。  
- **GCD合并**：所有环长的GCD确保所有约束同时满足。  
- **链长计算**：通过记录连通块内节点最大/最小距离差统计链长。

---

## **题解评分 (≥4星)**  
1. **StudyingFather（5星）**  
   - 思路清晰，代码简洁，完整覆盖环与链的逻辑。  
   - 关键点：双向边权设计，环长GCD合并。  
   - 亮点：通过反边权处理链差，确保无遗漏情况。

2. **water_tomato（4.5星）**  
   - 详细证明反边权正确性，数学推导严谨。  
   - 代码中明确分离环与链处理逻辑，注释清晰。

3. **sodak（4星）**  
   - 代码结构清晰，快速区分环与链场景。  
   - 实用技巧：标记反边防止重复遍历。

---

## **最优思路/技巧提炼**  
1. **双向边权设计**：正反边权（1/-1）确保遍历所有可能路径，统一处理环与链。  
2. **动态更新GCD**：DFS中实时计算环长GCD，避免存储所有环长。  
3. **链长统计优化**：利用`maxv - minv +1`快速计算连通块最长链。  
4. **最小因数剪枝**：从3开始枚举GCD因数，首个符合条件的即为最小值。

---

## **相似题目推荐**  
1. **P2661 信息传递**（基环树求最小环）  
2. **P3385 负环**（Bellman-Ford检测负权环）  
3. **P3196 寻找图的环**（通用环检测与统计）

---

## **个人心得摘录**  
- **调试教训**：双向边需成对标记（如`flag[i] = flag[i^1] = true`），否则可能重复计数。  
- **思维突破**：链差计算本质为路径差约束，与环约束统一为GCD问题。  
- **优化技巧**：无环时直接统计链长，避免冗余计算。

---

## **可视化与算法演示**  
### **动画设计**  
1. **节点与边绘制**：  
   - 节点以像素方块表示，初始为灰色，访问后变绿，环检测时变红。  
   - 边权以箭头颜色区分（绿色为+1，蓝色为-1）。  

2. **DFS过程演示**：  
   - 当前访问节点高亮黄色，边动态绘制。  
   - 检测到环时，播放“叮”音效，环路径闪烁显示。  

3. **GCD计算展示**：  
   - 环长以浮动文字显示，实时更新全局GCD数值。  
   - 结果面板动态展示最大/最小值推导过程。

### **复古游戏化效果**  
- **8位音效**：  
  - 访问节点：短促“哔”声。  
  - 发现环：上扬“成功”音效。  
  - 错误结果：低沉“失败”声效。  
- **积分系统**：每正确处理一个连通块得10分，最终根据得分解锁成就（如“环大师”“链专家”）。

---

## **核心代码实现**  
```cpp
// 关键DFS函数（StudyingFather题解）
void dfs(int u, int d) {
    if (dis[u]) {
        ans = gcd(ans, abs(d - dis[u])); // 环长计算
        return;
    }
    dis[u] = d;
    vis[u] = 1;
    maxv = max(maxv, dis[u]);
    minv = min(minv, dis[u]);
    for (auto i : e[u]) dfs(i.v, d + i.w); // 递归遍历
}

// 结果判定逻辑
if (ans) { // 有环
    if (ans < 3) puts("-1 -1");
    else {
        for (int i = 3; i <= ans; i++)
            if (ans % i == 0) { // 找最小因数
                printf("%d %d\n", ans, i);
                break;
            }
    }
} else { // 无环
    if (res < 3) puts("-1 -1");
    else printf("%d 3\n", res);
}
```

---

**总结**：本题通过双向边权设计与DFS遍历，将复杂环链问题转化为GCD计算，是图论与数论结合的经典案例。

---
处理用时：61.32秒
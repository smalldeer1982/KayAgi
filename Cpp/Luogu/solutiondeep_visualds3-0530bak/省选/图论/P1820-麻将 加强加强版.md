# 题目信息

# 麻将 加强加强版

## 题目背景

此题为 [P4050](/problem/P4050) 与 [P6454](/problem/P6454) 的加强版。

小 A 喜欢打麻将。

## 题目描述

小 A 找到了一副奇怪的麻将牌：只有一种 $1,2,\cdots,n$ 的数牌，且每种牌都有**无穷多张**。

定义「雀头」为两张一样的牌（如 $2,2$，$7,7$），「刻子」为三张一样的牌（如 $1,1,1$，$4,4,4$），「顺子」为三张序数相邻的牌（如 $1,2,3$，$9,10,11$，注意 $1$ 与 $n$ 不相邻）。「顺子」与「刻子」统称「面子」。

假如你能把你的手牌分为若干组「面子」（**可以相同**）以及一组「雀头」，那么你就可以「和牌」。

假如某副手牌加上某张牌后可以「和牌」，则称这副手牌「听」这张牌。

现在小 A 随意摸了 $k$ 张牌，他想知道他「听」哪些牌。

## 说明/提示

#### 【样例解释】

- 样例一解释：两种情况，`11/234` 与 `123/44`。
- 样例二解释：此牌型为「纯正九莲宝灯」，可以「听」所有数牌。

#### 【数据范围】

**本题采用捆绑测试。**

- Subtask 1（10 pts）：$1\leq k\leq 16$。
- Subtask 2（10 pts）：$1\leq k\leq 400$。
- Subtask 3（30 pts）：$1\leq k\leq 10^3$。
- Subtask 4（30 pts）：$1\leq k\leq 3\times10^4$。
- Subtask 5（20 pts）：无特殊限制。

对于所有数据，$1\leq a_i\leq n\leq k\leq 2\times10^5$。

## 样例 #1

### 输入

```
4 4
1 2 3 4```

### 输出

```
1 4```

## 样例 #2

### 输入

```
9 13
1 1 1 2 3 4 5 6 7 8 9 9 9```

### 输出

```
1 2 3 4 5 6 7 8 9```

## 样例 #3

### 输入

```
2 2
1 2```

### 输出

```
QAQ```

# AI分析结果



### 算法分类
**枚举与动态规划**

### 题解思路与核心难点

#### 题目核心
判断在添加一张牌后，是否能组成一个雀头和若干面子。关键在于高效判断每个可能的添加牌是否满足条件。

#### 核心难点
1. **数据规模大**：n 和 k 达到 2×10^5，需线性或近似线性算法。
2. **面子组合判断**：需要快速验证扣除雀头后剩余牌是否能分解为顺子和刻子。

#### 解决思路
1. **预处理条件**：检查总牌数是否合法（k+1-2 ≡0 mod3）。
2. **枚举候选雀头**：对于每个可能添加的牌x，枚举可能的雀头i（包括x本身和原数组中出现次数≥2的牌）。
3. **动态规划验证**：使用动态规划状态转移判断剩余牌是否能分解为顺子和刻子。

### 最优思路提炼
1. **动态规划状态设计**：`dp[i][a][b]` 表示处理到第i张牌，前序需要补a个顺子，当前可生成b个顺子。
2. **贪心结合DP**：优先处理顺子需求，再处理刻子，确保剩余牌数合法。
3. **剪枝优化**：仅处理可能成为雀头的候选，减少无效枚举。

### 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 2e5 + 5;

int cnt[MAXN], tmp[MAXN], n, k;
vector<int> ans;

bool check() {
    for (int i = 1; i <= n; ++i) tmp[i] = cnt[i];
    for (int i = 1; i <= n-2; ++i) {
        int d = min(min(tmp[i], tmp[i+1]), tmp[i+2]);
        if (d < 0) return false;
        tmp[i] -= d; tmp[i+1] -= d; tmp[i+2] -= d;
    }
    for (int i = 1; i <= n; ++i) 
        if (tmp[i] %3 !=0) return false;
    return true;
}

int main() {
    cin >> n >> k;
    for (int i = 0, x; i < k; ++i) {
        cin >> x; cnt[x]++;
    }
    if ((k+1-2) %3 !=0) { cout << "QAQ"; return 0; }
    for (int x = 1; x <= n; ++x) {
        cnt[x]++;
        bool valid = false;
        for (int i = 1; i <= n; ++i) {
            if (cnt[i] >=2) {
                cnt[i] -=2;
                if (check()) { valid = true; cnt[i] +=2; break; }
                cnt[i] +=2;
            }
        }
        if (valid) ans.push_back(x);
        cnt[x]--;
    }
    if (ans.empty()) cout << "QAQ";
    else for (int v : ans) cout << v << " ";
    return 0;
}
```

### 可视化设计思路
1. **动态规划状态跟踪**：用颜色高亮当前处理的牌i，显示剩余数目和顺子需求。
2. **像素动画**：每个牌用色块表示，扣除顺子或刻子时，对应色块数量减少，辅以音效。
3. **步骤演示**：允许单步执行，观察每一步如何处理顺子和刻子。

### 结论
本题需结合枚举候选雀头与动态规划验证，通过预处理和剪枝优化时间复杂度。核心在于快速判断剩余牌的组合合法性，适用于麻将类组合问题的通用解法。

---
处理用时：480.22秒
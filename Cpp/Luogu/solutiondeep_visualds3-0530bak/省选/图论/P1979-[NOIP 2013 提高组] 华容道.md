# 题目信息

# [NOIP 2013 提高组] 华容道

## 题目背景

NOIP2013 提高组 D2T3

## 题目描述

`小 B` 最近迷上了华容道，可是他总是要花很长的时间才能完成一次。于是，他想到用编程来完成华容道：给定一种局面， 华容道是否根本就无法完成，如果能完成， 最少需要多少时间。

`小 B` 玩的华容道与经典的华容道游戏略有不同，游戏规则是这样的：

1.   在一个 $n \times m$ 棋盘上有 $ n \times m$ 个格子，其中有且只有一个格子是空白的，其余 $ n \times m-1$ 个格子上每个格子上有一个棋子，每个棋子的大小都是 $1 \times 1$ 的；
2.  有些棋子是固定的，有些棋子则是可以移动的；
3.  任何与空白的格子相邻（有公共的边）的格子上的棋子都可以移动到空白格子上。   

游戏的目的是把某个指定位置可以活动的棋子移动到目标位置。

给定一个棋盘，游戏可以玩 $q$ 次，当然，每次棋盘上固定的格子是不会变的， 但是棋盘上空白的格子的初始位置、 指定的可移动的棋子的初始位置和目标位置却可能不同。第 $i$ 次玩的时候， 空白的格子在第 $EX_i$ 行第 $EY_i$ 列，指定的可移动棋子的初始位置为第 $SX_i$ 行第 $SY_i$列，目标位置为第 $TX_i$ 行第 $TY_i$ 列。

假设 `小 B` 每秒钟能进行一次移动棋子的操作，而其他操作的时间都可以忽略不计。请你告诉 `小 B` 每一次游戏所需要的最少时间，或者告诉他不可能完成游戏。


## 说明/提示

**输入输出样例说明**

棋盘上划叉的格子是固定的，红色格子是目标位置，圆圈表示棋子，其中绿色圆圈表示目标棋子。

1.   第一次游戏，空白格子的初始位置是 $(3,2)$（图中空白所示），游戏的目标是将初始位置在 $(1, 2)$ 上的棋子（图中绿色圆圈所代表的棋子）移动到目标位置 $(2, 2)$（图中红色的格子）上。

移动过程如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/n0q385tw.png)

2.  第二次游戏，空白格子的初始位置是 $(1, 2)$（图中空白所示），游戏的目标是将初始位置在 $(2, 2)$ 上的棋子（图中绿色圆圈所示）移动到目标位置  $(3, 2)$ 上。

![](https://cdn.luogu.com.cn/upload/image_hosting/aq9apos0.png)

要将指定块移入目标位置，必须先将空白块移入目标位置，空白块要移动到目标位置，必然是从位置 $(2,2)$ 上与当前图中目标位置上的棋子交换位置，之后能与空白块交换位置的只有当前图中目标位置上的那个棋子，因此目标棋子永远无法走到它的目标位置， 游戏无法完成。

**数据范围**

对于 $ 30\%$ 的数据，$1 ≤ n, m ≤ 10,q = 1$；

对于 $60\%$ 的数据，$1 ≤ n, m ≤ 30,q ≤ 10$；

对于 $100\%$ 的数据，$1 ≤ n, m ≤ 30,q ≤ 500$。


## 样例 #1

### 输入

```
3 4 2
0 1 1 1
0 1 1 0
0 1 0 0
3 2 1 2 2 2
1 2 2 2 3 2```

### 输出

```
2
-1```

# AI分析结果



## 算法分类
最短路算法（BFS预处理+SPFA）

## 题解分析与结论

### 核心思路对比
1. **暴力BFS**（叶ID、Noah2022）
   - 直接维护(空白格坐标, 指定棋子坐标)作为状态
   - 难点：状态空间达30^4=810,000，需通过卡常优化（指针队列、寄存器变量等）
   - 评分：★★★☆（仅适用于小数据，无法保证通过全数据）

2. **预处理状态图+最短路**（Starlight_Glimmer、Erutsiom、hkr04）
   - 关键状态：(指定棋子坐标, 空白格方位)
   - 预处理：
     - 空白格绕棋子转动的代价（BFS计算不经过棋子的移动步数）
     - 棋子与空白格交换的代价（固定为1步）
   - 将状态视为图节点，边权为转移代价
   - 每次查询时计算初始空白格到棋子四周的最短路径，再SPFA求最短路
   - 评分：★★★★★（时间复杂度O(4nm + qknm)，稳定通过全数据）

### 解决难点
- **状态爆炸**：通过限定空白格必须在棋子四周，将状态数从O(n²m²)降到O(4nm)
- **多次查询效率**：预处理所有可能的转移边，查询时只需跑一次SPFA

### 最优思路提炼
**状态定义**：用三元组(x,y,dir)表示指定棋子在(x,y)，空白格位于棋子的dir方向（0-上,1-下,2-左,3-右）

**关键步骤**：
1. 预处理每个(x,y,dir)到相邻方向的转移代价（BFS计算空白格绕行步数）
2. 建立状态图：相邻方向间连边，边权为绕行步数；交换棋子与空白格连边，边权1
3. 对每次查询：
   - BFS计算空白格初始位置到棋子四周的最短距离
   - 将这四个距离作为SPFA的初始值，跑最短路求到目标位置四周的最小值

## 可视化算法设计

### 动画演示方案
1. **棋盘绘制**：用Canvas绘制30x30网格，固定块用深灰色，空白格用白色，目标棋子用绿色，其他可移动块用浅灰色
2. **状态转移演示**：
   - 当前状态高亮：红色边框标记指定棋子，箭头表示空白格方位
   - 边权显示：当鼠标悬停时显示两个状态间的转移代价（绕行步数或交换步）
3. **SPFA过程可视化**：
   - 队列元素用黄色标记，已访问节点渐变为蓝色
   - 实时显示dis数组数值，当前最小路径用闪烁绿线标记

### 复古像素风格实现
```javascript
// Canvas初始化（8-bit风格）
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false; // 保持像素锐利

// 颜色调色板（FC风格）
const PALETTE = [
  '#000000', '#FFFFFF', '#FF0000', '#00FF00',
  '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'
];

// 绘制棋盘格
function drawGrid(x, y, colorIdx) {
  ctx.fillStyle = PALETTE[colorIdx];
  ctx.fillRect(x*10, y*10, 10, 10); // 10px per grid
}

// 播放音效（8-bit音）
function playSound(type) {
  const audioCtx = new AudioContext();
  const oscillator = audioCtx.createOscillator();
  oscillator.type = 'square';
  oscillator.frequency.setValueAtTime(
    type === 'move' ? 523.25 : 659.25, audioCtx.currentTime
  );
  oscillator.connect(audioCtx.destination);
  oscillator.start();
  oscillator.stop(audioCtx.currentTime + 0.1);
}
```

## 相似题目推荐
1. P1379 八数码难题（状态压缩+BFS）
2. P2324 [SCOI2005]骑士精神（A*+状态搜索）
3. P2483 【模板】k短路（A*/最短路变形）

## 核心代码片段
```cpp
// 预处理状态转移边
void bfs(int x, int y, int dir) {
  int blank_x = x + dx[dir];
  int blank_y = y + dy[dir];
  // BFS计算空白格绕(x,y)到其他方向的步数
  for(int ndir=0; ndir<4; ++ndir) {
    if(ndir == dir) continue;
    int tx = x + dx[ndir], ty = y + dy[ndir];
    int steps = calcSteps(blank_x, blank_y, tx, ty, x, y);
    if(steps != INF) {
      addEdge(id(x,y,dir), id(x,y,ndir), steps);
    }
  }
}

// SPFA查询
int query(int ex, int ey, int sx, int sy, int tx, int ty) {
  memset(dis, 0x3f, sizeof dis);
  queue<int> q;
  // 初始状态：空白格到棋子四周
  for(int dir=0; dir<4; ++dir) {
    int bx = sx + dx[dir], by = sy + dy[dir];
    int d = bfs(ex, ey, bx, by, sx, sy); // 初始移动步
    if(d < INF) {
      dis[id(sx,sy,dir)] = d;
      q.push(id(sx,sy,dir));
    }
  }
  // SPFA核心
  while(!q.empty()) {
    int u = q.front(); q.pop();
    for(Edge e : G[u]) {
      if(dis[e.v] > dis[u] + e.w) {
        dis[e.v] = dis[u] + e.w;
        if(!inq[e.v]) q.push(e.v), inq[e.v] = true;
      }
    }
  }
  // 取目标位置四周最小值
  int res = INF;
  for(int dir=0; dir<4; ++dir)
    res = min(res, dis[id(tx,ty,dir)]);
  return res == INF ? -1 : res;
}
```

## 总结
本题核心在于通过**状态抽象**将棋盘问题转化为图论问题。通过预处理建立状态转移图，使得每次查询的时间复杂度从O(n²m²)降至O(knm)。可视化时应重点表现状态节点间的转移关系和最短路算法的动态松弛过程，结合8-bit风格增强学习趣味性。

---
处理用时：77.72秒
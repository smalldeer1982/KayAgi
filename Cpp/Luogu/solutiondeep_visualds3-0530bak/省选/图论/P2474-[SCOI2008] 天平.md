# 题目信息

# [SCOI2008] 天平

## 题目描述

你有 $n$ 个砝码，均为 $1$ 克，$2$ 克或者 $3$ 克。你并不清楚每个砝码的重量，但你知道其中一些砝码重量的大小关系。你把其中两个砝码 A 和 B 放在天平的左边，需要另外选出两个砝码放在天平的右边。问：有多少种选法使得天平的左边重($c_1$)、一样重($c_2$)、右边重($c_3$)？（只有结果保证唯一确定的选法才统计在内）


## 说明/提示

$4\le n\le 50$。


## 样例 #1

### 输入

```
6 2 5

?+????

-?+???

?-????

????+?

???-?+

????-?```

### 输出

```
1 4 1```

## 样例 #2

### 输入

```
14 8 4

?+???++?????++

-??=?=???????=

??????????=???

?=??+?==??????

???-???-???-??

-=????????????

-??=???=?-+???

???=+?=???????

??????????????

??????+???????

??=???-????-??

????+?????+???

-?????????????

-=????????????```

### 输出

```
18 12 11```

# AI分析结果



## 算法分类
差分约束系统 + Floyd算法

## 综合分析与结论
本题通过差分约束系统建立砝码间重量差值范围，使用Floyd算法递推所有砝码对的差值上下界，最终通过枚举比较确定天平状态的唯一性。核心难点在于建立正确的差分约束模型，并通过条件判断确保结果唯一。

### 核心算法流程
1. **初始化差值范围**：根据输入符号设置每个砝码对的maxd（最大差值）和mind（最小差值）
2. **Floyd递推更新**：通过三重循环递推所有砝码对的差值范围
3. **枚举判断条件**：遍历所有可能的右边砝码对，通过差值范围比较确定天平状态

### 可视化设计思路
**动画方案**：
1. 初始阶段：以网格显示所有砝码对的maxd/mind初始值，不同颜色区分不同关系符号
2. Floyd阶段：动态展示k循环时maxd/mind的更新过程，用高亮色标记当前更新的i,j节点
3. 判断阶段：高亮当前枚举的右边砝码对，用不同颜色标注满足的条件类型（如红色表示左倾）

**复古像素风格**：
- 使用16色调色板，砝码用8-bit像素方块表示，差值范围以复古字体显示
- 音效：更新成功时播放“哔”声，条件满足时播放不同音调

## 题解推荐（≥4星）

1. **liangbowen（5星）**  
   - 思路清晰，注释详尽  
   - 代码结构模块化（输入、Floyd、输出分离）  
   - 核心逻辑：通过`mx[i][j]`和`mn[i][j]`的差分约束递推

2. **Holmes（4.5星）**  
   - 代码简洁，条件判断逻辑优化  
   - 独特亮点：将三种情况判断整合到同一循环中

3. **A_Sunny_Day（4星）**  
   - 数学推导详细，解释差分约束与最短路的关系  
   - 代码包含等值判断的优化条件表达式

## 核心代码实现

```cpp
// Floyd递推部分
for(int k=1; k<=n; k++)
    for(int i=1; i<=n; i++)
        for(int j=1; j<=n; j++) {
            maxd[i][j] = min(maxd[i][j], maxd[i][k] + maxd[k][j]);
            mind[i][j] = max(mind[i][j], mind[i][k] + mind[k][j]);
        }

// 统计答案部分
int lcnt=0, ecnt=0, rcnt=0;
for(int i=1; i<=n; i++) {
    if(i==A || i==B) continue;
    for(int j=1; j<i; j++) {
        if(j==A || j==B) continue;
        // 左边重
        if(mind[A][i]>maxd[j][B] || mind[A][j]>maxd[i][B]) lcnt++;
        // 相等
        if((mind[A][i]==maxd[A][i] && mind[j][B]==maxd[j][B] && mind[A][i]==mind[j][B]) || 
           (mind[B][i]==maxd[B][i] && mind[j][A]==maxd[j][A] && mind[B][i]==mind[j][A])) ecnt++;
        // 右边重
        if(maxd[A][i]<mind[j][B] || maxd[A][j]<mind[i][B]) rcnt++;
    }
}
```

## 相似题目推荐
1. P1993 小K的农场（差分约束基础）
2. P3275 [SCOI2011]糖果（进阶差分约束）
3. P1260 工程规划（差分约束应用）

---

**可视化演示片段（伪代码）**
```javascript
// Canvas绘制砝码关系网格
function drawGrid() {
    ctx.fillStyle = '#2D2D2D'; // 复古深灰背景
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 绘制砝码节点
    for(let i=0; i<n; i++) {
        drawPixelBlock(x, y, currentColor);
        // 高亮当前更新的i,j节点
        if(i == currentI && j == currentJ) {
            ctx.fillStyle = '#FF5555'; // 复古红色
            drawFlashingBorder(x, y);
        }
    }
    
    // 播放音效
    if(stepSound) playSound('blip.wav');
}
```

**学习建议**  
通过本题目深入理解差分约束系统与图论算法的结合应用，注意掌握如何将不等式关系转化为图的最短/最长路径问题。在实现时务必注意Floyd更新方向和条件判断的边界情况。

---
处理用时：68.71秒
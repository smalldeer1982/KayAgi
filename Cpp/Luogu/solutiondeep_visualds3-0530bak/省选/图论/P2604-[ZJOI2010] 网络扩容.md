# 题目信息

# [ZJOI2010] 网络扩容

## 题目描述

给定一张有向图，每条边都有一个容量 $c$ 和一个扩容费用 $w$。这里扩容费用是指将容量扩大 $1$ 所需的费用。求： 

1. 在不扩容的情况下，$1$ 到 $n$ 的最大流；

2. 将 $1$ 到 $n$ 的最大流增加 $k$ 所需的最小扩容费用。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\le 100$。
- 对于 $100\%$ 的数据，保证 $1\le n\le 10^3$，$1\le m\le 5\times 10^3$，$1\le k\le 10$，$1 \leq u, v \leq n$，$1\le c,w\le 100$。

## 样例 #1

### 输入

```
5 8 2
1 2 5 8
2 5 9 9
5 1 6 2
5 1 1 8
1 2 8 7
2 5 4 9
1 2 1 1
1 4 2 1```

### 输出

```
13 19
```

# AI分析结果



**唯一算法分类**：费用流（最小费用最大流）

---

### **题解思路与核心难点**

1. **问题拆解**  
   - **第一问**：标准最大流问题，Dinic 或普通费用流求解。
   - **第二问**：在残量网络上扩展边，通过费用流计算扩容的最小费用。

2. **关键实现逻辑**  
   - **残量网络复用**：第一问结束后保留残量网络，避免重新建图。
   - **扩容边添加**：每条原边新增一条容量无限、费用为扩容费用的边。
   - **流量限制**：通过超级源点（0→1）或新汇点（n→n+1）限制扩容量为 K。

3. **解决难点**  
   - **残量网络正确性**：确保残留的流量被优先使用（费用为0），新增流量通过扩容边计算费用。
   - **代码优化**：避免重复建图，直接在原图基础上增加边。

---

### **题解评分与推荐**

1. **bztMinamoto（⭐⭐⭐⭐⭐）**  
   - **亮点**：直接复用残量网络，两次调用费用流，代码简洁高效。  
   - **代码片段**：  
     ```cpp
     // 第一次跑费用流求最大流
     dinic();  
     // 添加扩容边和超级源点
     for(int i=1;i<=m;++i) add(u,v,inf,e);
     add(s,1,k,0);  
     dinic();  
     ```

2. **Orion545（⭐⭐⭐⭐）**  
   - **亮点**：新建汇点确保流量严格为 F+K，思路清晰但代码稍冗长。  
   - **关键代码**：  
     ```cpp
     add(n,n+1,0,maxflow+K); // 限制总流量
     zkw(1,n+1); // 费用流求解
     ```

3. **mohei0（⭐⭐⭐）**  
   - **思路**：逐次增广 K 次，每次仅扩容 1 单位。  
   - **缺点**：复杂度较高（K=10 时勉强可用），但适合理解原理。  

---

### **最优思路提炼**

1. **残量网络复用**  
   - 第一问结束后，残量网络中的反向边表示剩余容量，直接用于第二问的免费流量。

2. **动态添加扩容边**  
   ```python
   for each original edge (u, v, c, w):
       add_edge(u, v, INF, w)  # 扩容边，费用为w
   ```

3. **超级源点限制扩容量**  
   ```python
   add_edge(SuperSource, 1, K, 0)  # 限制扩容总量为 K
   ```

---

### **同类型题与推荐题目**

1. **P4015 运输问题**  
   - 同时涉及最大流和费用分配，需分两次计算最小/最大费用流。

2. **P2770 航空路线问题**  
   - 最大流与路径费用结合，需处理节点容量限制。

3. **P3358 最长k可重区间集**  
   - 费用流建模典型题，通过离散化和边设计限制覆盖次数。

---

### **可视化与算法演示**

**核心动画设计**：  
1. **网络图展示**：  
   - 节点用圆形表示，边用箭头标注容量和费用。  
   - **初始状态**：原边为蓝色，扩容边为红色虚线。  
2. **费用流增广**：  
   - 每次 SPFA 找到的最短路径高亮为黄色，流量增加时边宽动态变化。  
   - **费用累计**：右侧面板实时显示总费用，音效提示每次费用更新。  
3. **复古像素风格**：  
   - 节点用 16x16 像素块，边用 8-bit 风格箭头。  
   - **背景音乐**：芯片音乐循环播放，增广成功时触发“升级”音效。  

**交互功能**：  
- **步进控制**：允许逐步执行 SPFA 和增广过程。  
- **残量网络切换**：按钮切换显示原图或扩容后的网络。  

---

### **代码实现（关键部分）**

```cpp
// 第一问：Dinic 求最大流
int maxflow = Dinic(S, T);

// 第二问：添加扩容边和超级源点
for (Edge& e : original_edges) {
    AddEdge(e.u, e.v, INF, e.cost); // 扩容边费用为w
}
AddEdge(SuperS, S, K, 0); // 超级源点限制扩容量
int mincost = MCMF(SuperS, T); // 最小费用流
```

---

### **总结**

本题通过复用残量网络和动态添加扩容边，将两问统一为两次费用流调用，既节省代码量又提高效率。可视化时应重点展示残量网络的动态变化和扩容路径的选择，帮助理解费用流的核心逻辑。

---
处理用时：61.25秒
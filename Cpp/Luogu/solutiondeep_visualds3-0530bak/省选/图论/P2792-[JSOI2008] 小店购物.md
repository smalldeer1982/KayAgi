# 题目信息

# [JSOI2008] 小店购物

## 题目背景

JSOI集训队的队员发现，在他们经常活动的集训地，有一个小店因为其丰富的经营优惠方案深受附近居民的青睐，生意红火。


## 题目描述

小店的优惠方案十分简单有趣：

一次消费过程中，如您在本店购买了精制油的话，您购买香皂时就可以享受 $2.00$ 元 / 块的优惠价；如果您在本店购买了香皂的话，您购买可乐时就可以享受 $1.50$ 元 / 听的优惠价……诸如此类的优惠方案可概括为：如果您在本店购买了商品 $A$ 的话，您就可以以 $P$ 元 / 件的优惠价格购买商品 $B$（购买的数量不限）。

有趣的是，你需要购买同样一些商品，由于不同的买卖顺序，老板可能会叫你付不同数量的钱。比如你需要一块香皂（原价 $2.50$ 元）、一瓶精制油（原价 $10.00$ 元）、一听可乐（原价 $1.80$ 元），如果你按照可乐、精制油、香皂这样的顺序购买的话，老板会问你要 $13.80$ 元；而如果你按照精制油、香皂、可乐这样的顺序购买的话，您只需付 $13.50$ 元。

该处居民发现 JSOI 集训队的队员均擅长电脑程序设计，于是他们请集训队的队员编写一个程序：在告诉你该小店商品的原价，所有优惠方案及所需的商品后，计算至少需要花多少钱（不允许购买任何不必要的商品，即使这样做可能使花的钱更少）。

## 说明/提示

数据范围见输入格式


## 样例 #1

### 输入

```
4
10.00 1
1.80 1
3.00 0
2.50 2
2
1 4 2.00
4 2 1.50```

### 输出

```
15.50```

# AI分析结果



# **算法分类**  
朱刘算法/最小树形图

---

# **题解思路与算法要点**  
## **核心逻辑推导**  
1. **问题转化为有向图**：  
   - 每个商品对应图中的节点，优惠方案对应有向边（边权为优惠价）。  
   - 添加**超级源点**，向每个商品连边（边权为原价），表示首次购买该商品的最优路径起点。  
2. **拆点优化**：  
   - 若某商品需要购买多次（如需要买 $k$ 件），将商品拆分为两个点：  
     - 点 $A$：表示购买第一件（可能受优惠影响）  
     - 点 $B$：表示购买剩余 $k-1$ 件（以最低价格购买，无需依赖其他商品）  
3. **朱刘算法核心流程**：  
   - 贪心选择每个节点的最小入边  
   - 检测环并缩点，更新边权（减去环内入边权值）  
   - 重复直到无环，得到最小树形图  

## **解决难点**  
- **优惠与购买顺序的依赖关系**：通过构建有向边实现优惠的传递性（如购买 $A$ 后 $B$ 可享优惠）。  
- **多次购买的最优处理**：拆点后，第一件商品的价格可能受优惠影响，剩余商品直接使用最低价。  
- **环的检测与缩点**：朱刘算法通过动态缩环解决优惠路径的循环依赖问题。

---

# **题解评分（≥4星）**  
1. **D_14134（4.5星）**  
   - **亮点**：直接应用朱刘算法，代码简洁，通过预处理优惠边和原价边。  
   - **关键代码**：  
     ```cpp  
     for (int i=2;i<=n;++i) ans += (need[i]-1)*cost[i];  
     mst(); // 调用朱刘算法  
     ```  
2. **chihik（5星）**  
   - **亮点**：拆点法精确处理多次购买，通过构建不同边类型（首次购买与剩余购买）实现最优解。  
   - **关键代码**：  
     ```cpp  
     if (num[v] > 0) Add_Edge(rt, id[v][0], c);  
     if (num[v] > 1) Add_Edge(rt, id[v][1], c * (num[v]-1));  
     ```  
3. **ww3113306（4.5星）**  
   - **亮点**：详细注释与错误标记，动态维护入边权值，通过栈辅助环检测。  
   - **关键代码**：  
     ```cpp  
     while(vis[nw] == -1) vis[nw] = i, nw = pre[nw];  
     if (nw == i && !id[nw]) { ... } // 检测环  
     ```

---

# **最优思路提炼**  
1. **超级源点与拆点**  
   - 超级源点连接所有商品的原价边，表示初始购买路径。  
   - 拆点分离首次购买与剩余购买，避免优惠依赖的循环问题。  
2. **动态权值调整**  
   - 缩环时更新边权（减去环内最小入边），保证后续贪心选择的正确性。  
3. **预处理最低价格**  
   - 对每个商品的多次购买部分直接累加最低价，减少算法复杂度。

---

# **同类型题与算法套路**  
- **通用解法**：依赖关系中的最优路径问题均可转化为最小树形图（如网络设计、任务调度）。  
- **类似题目**：  
  - [P4716] 最小树形图（模板题）  
  - [P4234] 最小差值生成树（需处理边权动态变化）  
  - [CF125E] 有向图最优路径（需结合流量限制）  

---

# **推荐相似题目**  
1. **P4716** - 最小树形图模板题  
2. **P4234** - 最小生成树变种（需处理动态边权）  
3. **CF125E** - 有向图流量优化问题  

---

# **可视化与算法演示**  
## **动画设计**  
1. **核心流程可视化**：  
   - **步骤1**：显示初始图（超级源点、商品节点、优惠边与原价边）。  
   - **步骤2**：高亮当前处理的节点，标记其最小入边（颜色：绿色）。  
   - **步骤3**：检测到环时，将环内节点标记为红色，缩点后生成新节点（颜色：紫色）。  
   - **步骤4**：更新边权时，用闪烁效果提示权值变化。  
2. **复古像素风格**：  
   - **颜色方案**：  
     - 超级源点：金色  
     - 普通节点：蓝色  
     - 优惠边：橙色（原价边为白色）  
     - 环内节点：红色  
     - 缩点后节点：紫色  
   - **音效触发**：  
     - 选择最小入边：8-bit "beep" 音效  
     - 检测到环：短促警报音  
     - 缩点完成：上扬音调  

## **交互设计**  
- **控制面板**：支持暂停/继续、单步执行、调节动画速度。  
- **自动演示模式**：模拟贪吃蛇 AI，逐步展示朱刘算法的环检测与缩点过程。  

---

# **个人心得摘录**  
> **chihik 的调试经验**：  
> “拆点时需注意不要创建不必要的点，例如购买数量为 0 的商品直接跳过。”  
> **ww3113306 的优化反思**：  
> “初始代码未正确处理多次购买的权值累加，导致结果偏大，后通过拆分点解决。”  

---

# **核心代码片段（chihik 题解）**  
```cpp  
// 构建超级源点与拆点  
for (int i = 1; i <= n; i++) {  
    if (num[i] > 0)  
        Add_Edge(rt, id[i][0], c);  // 首次购买  
    if (num[i] > 1)  
        Add_Edge(rt, id[i][1], c * (num[i]-1));  // 剩余购买  
}  
// 处理优惠边  
Add_Edge(id[u][0], id[v][0], p);  // 首次购买后的优惠  
Add_Edge(id[u][0], id[v][1], p * (num[v]-1));  
```  

---

# **总结**  
本题通过构建有向图并应用朱刘算法，解决了优惠依赖下的最优购买顺序问题。拆点法与超级源点的设计是核心优化，可视化方案通过动态缩环与权值调整，直观展示了算法流程。

---
处理用时：69.17秒
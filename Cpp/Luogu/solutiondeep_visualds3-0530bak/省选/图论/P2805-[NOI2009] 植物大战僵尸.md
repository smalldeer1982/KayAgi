# 题目信息

# [NOI2009] 植物大战僵尸

## 题目背景

Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和 Zombies（僵尸）是游戏的主角，其中 Plants 防守，而 Zombies 进攻。该款游戏包含多种不同的挑战系列，比如 Protect Your Brain、Bowling 等等。其中最为经典的，莫过于玩家通过控制 Plants 来防守 Zombies 的进攻，或者相反地由玩家通过控制 Zombies 对 Plants 发起进攻。



## 题目描述

现在，我们将要考虑的问题是游戏中 Zombies 对 Plants 的进攻，请注意，本题中规则与实际游戏**有所不同**。游戏中有两种角色，Plants 和 Zombies，每个 Plant 有一个攻击位置集合，它可以对这些位置进行保护；而 Zombie 进攻植物的方式是走到植物所在的位置上并将其吃掉。

游戏的地图可以抽象为一个 $N$ 行 $M$ 列的矩阵，行从上到下用 $0$ 到 $N–1$ 编号，列从左到右用 $0$ 到 $M–1$ 编号；在地图的每个位置上都放有一个 $Plant$，为简单起见，我们把位于第 $r$ 行第 $c$ 列的植物记为 $P_{r, c}$。

Plants 分很多种，有「攻击类」「防守类」和「经济类」等等。为了简单的描述每个 Plant，定义 $\operatorname{Score}$ 和 $\operatorname{Attack}$ 如下：

* $\operatorname{Score}(P_{r, c})$ — Zombie 击溃植物 $P_{r, c}$ 可获得的能源。   
若 $\operatorname{Score}(P_{r, c})$ 为非负整数，则表示击溃植物 $P_{r, c}$ 可获得能源 $\operatorname{Score}(P_{r, c})$，若为负数表示击溃 $P_{r, c}$ 需要付出能源 $-\operatorname{Score}(P_{r, c})$。

* $\operatorname{Attack}(P_{r, c})$ — 植物 $P_{r, c}$ 能够对 Zombie 进行攻击的位置集合。

Zombies 必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies 攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此 Zombies 的进攻总是从地图的右侧开始。也就是说，对于第 $r$ 行的进攻，Zombies 必须首先攻击 $P_{r, M-1}$；若需要对 $P_{r, c}$（$0 \le c < m - 1$）攻击，必须将 $P_{r,M-1}, P_{r, M-2} \cdots P_{r, c+1}$ 先击溃，并移动到位置 $(r, c)$ 才可进行攻击。

在本题的设定中，Plants 的攻击力是无穷大的，一旦 Zombie 进入某个 Plant 的攻击位置，该 Zombie 会被瞬间消灭，而该 Zombie 没有时间进行任何攻击操作。因此，即便 Zombie 进入了一个 Plant 所在的位置，但该位置属于其他植物的攻击位置集合，则 Zombie 会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant 的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。

Zombies 的目标是对 Plants 的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套 Zombies 的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。

## 说明/提示

#### 数据规模与约定
- 对于 $20\%$ 的数据，保证 $ N, M \le 5$。
- 对于 $40\%$ 的数据，保证 $ N, M \le 10$。
- 对于 $100\%$ 的数据，保证 $1 \le N \le 20$，$1 \le M \le 30$，$-10^4 ≤ \operatorname{Score} \le 10^4$。

#### 说明
题面由 @syksykCCC 修改。

## 样例 #1

### 输入

```
3 2
10 0
20 0
-10 0
-5 1 0 0
100 1 2 1
100 0```

### 输出

```
25```

# AI分析结果



---

## 唯一算法分类
**最大权闭合子图 + 拓扑排序**

---

## 综合分析与结论
### 核心思路与难点
1. **依赖关系建模**：每个植物被右侧植物保护（必须从左到右攻击）和被其他植物保护，构建有向边形成依赖关系图
2. **环处理**：通过拓扑排序识别无法被攻击的环状结构（如互相保护的植物），这些节点需被排除
3. **网络流建模**：正权点连源点（得分），负权点连汇点（消耗），保护关系连INF边，求最小割实现最大权闭合子图

### 可视化设计要点
- **拓扑去环动画**：用红色高亮无法到达的节点，绿色显示可攻击节点，用像素化箭头展示边被删除过程
- **网络流动画**：用蓝色流动效果显示正权边的流量，红色显示负权边的反向流量，INF边用金色高亮
- **复古音效**：节点被拓扑移除时播放"哔"声，流量切割时播放"咔嚓"声，找到最优解时播放8-bit胜利音效
- **交互控制**：支持切换视图（依赖图/网络流图），可调节动画速度观察拓扑排序和dinic分层过程

---

## 题解清单（≥4星）
1. **longlongzhu123（⭐⭐⭐⭐⭐）**
   - 亮点：详细推导最大权闭合子图理论，完整代码实现拓扑与dinic，POINT宏处理坐标映射
   - 核心代码：
     ```cpp
     void toposort() { // 拓扑排除环结构
         queue<int> Q;
         for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) 
             if(!in[POINT(i,j)]) Q.push(POINT(i,j)),vis[...]=1;
         while(!Q.empty()){...}
     }
     ```

2. **Freddie（⭐⭐⭐⭐）**
   - 亮点：清晰拆解问题为拓扑+转置图，图示化网络建模过程
   - 关键步骤：反向边拓扑后转置建图，sum统计正权和，dinic求最小割

3. **BJpers2（⭐⭐⭐⭐）**
   - 亮点：拓扑与网络流合并处理，id函数封装坐标转换
   - 创新点：直接在建图阶段处理拓扑，代码精简

---

## 核心算法流程
1. **拓扑去环**
```python
def remove_cycles():
    build_dependency_graph()
    q = deque(零入度节点)
    while q:
        u = q.popleft()
        for v in u的保护节点:
            v.in_degree -= 1
            if v.in_degree == 0:
                q.append(v)
                标记v为可达
```

2. **网络流建模**
```cpp
void build_network() {
    for 每个可达节点u:
        if score[u] > 0: 
            add_edge(S, u, score[u])
            sum += score[u]
        else: 
            add_edge(u, T, -score[u])
        for u保护的节点v: 
            add_edge(v, u, INF) // 必须保护关系
}
```

---

## 同类型题目推荐
1. P2762 太空飞行计划问题（最大权闭合子图模板）
2. P4174 [NOI2006]最大获利（网络流建模相似）
3. P3410 拍照（闭合图变式）

---

## 可视化示例（伪代码）
```javascript
// Canvas绘制拓扑过程
function drawTopology() {
    ctx.fillStyle = '#8B0000'; // 复古红
    环状节点.forEach(v => drawPixelNode(v.x, v.y)); 
    
    ctx.fillStyle = '#00FF7F'; // 荧光绿
    可达节点.forEach(v => {
        drawArrow(v.x, v.y, v保护节点坐标);
        if (v.in_degree == 0) sparkleEffect(v); // 入场特效
    });
    
    // 播放拓扑移除音效
    if (frame % 10 == 0) playSound('blip.wav'); 
}
```

---

## 个人心得摘录
> "调试时发现若不处理反向边，dinic会死循环。后来用`POINT宏`打印坐标才找到环未正确处理的问题" —— longlongzhu123

> "将每行右侧强制连边后，突然AC了样例，才理解必须从左到右攻击的隐含条件" —— 某匿名题解

---

## 扩展思考
当M较大时（如M=100），可优化节点编号为`r*M + c`代替二维存储。对于密集保护关系，采用邻接表而非矩阵存储边可大幅降低内存消耗。

---
处理用时：58.66秒
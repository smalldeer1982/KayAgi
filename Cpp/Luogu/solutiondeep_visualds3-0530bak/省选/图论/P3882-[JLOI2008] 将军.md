# 题目信息

# [JLOI2008] 将军

## 题目描述

刘先生最近在学习国际象棋，使用一个叫 jloi-08 的游戏软件。在这个游戏里，不但可以和电脑普通地对弈，还可以学习著名的棋局，还有针对初学者的规则指导等丰富功能。但是…大小却要 1.4G T\_T。

言归正传，在这个软件里，为了让玩家更好地理解和运用各个棋子，有很多趣味的游戏，比如以下就是一个：

给出一个棋盘和一些棋子，让你把这些棋子摆放在棋盘上，使得两两不互相攻击。你的得分由你摆放上去的棋子的个数与种类有关。

这个游戏很复杂，刘先生老是玩不到高分。于是电脑便降低了难度，替刘先生摆上了一些棋子，最后只给你任意多个 bishop（教主）。

现在刘先生便要考一考你，在电脑给出的这张棋盘上，最多能放几个 bishop。

国际象棋中一共有 6 种棋子：

- king（国王）；
- queen（皇后）；
- bishop（教主）；
- knight（骑士）；
- rook（车）；
- pawn（步兵）。

各棋子的攻击范围如下：

- queen 可以攻击与它在同一行，同一列，同一条对角线的棋子；
- knight 的攻击范围如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/2669.png)

- rook 攻击水平和垂直两条线上的所有格子；
- pawn 攻击前方两条斜线方向各一格(“前方”指 $x$ 递增的方向，$x$ 行 $y$ 列）；
- king 攻击周围 8 个方向各 1 格；
- bishop 攻击两条对角线上的所有格子。

除 knight 以外，所有棋子的攻击范围均会被别的棋子所阻挡。

可惜的是这个软件也不是顶优秀，给出的棋盘上的棋子可能互相会攻击，不过你不用理会这些，你只要保证你摆放的 bishop 不与它们以及不互相攻击就可以了。

## 说明/提示

```plain
BBN
...
...
```

```plain
BBN
...
B..
```

虽然看上去下面的方法比上面的优秀，但是 N 被第三行的 B 攻击了。也就是说，你需要避免的有 2 种情况： 你摆放的 bishop 之间的互相攻击以及你摆放的 bishop 与预先摆放好的棋子之间的互相攻击；但不用考虑预先摆放好的棋子之间的互相攻击。


## 样例 #1

### 输入

```
3 3
..N
...
...
```

### 输出

```
2```

# AI分析结果



## 唯一算法分类
**二分图最大匹配**

---

## 综合分析与结论

### 核心思路
1. **棋盘旋转与二分图建模**：将棋盘顺时针旋转45°，使bishop的对角线攻击转化为水平/垂直攻击，形成二分图的两个顶点集合（行和列）。
2. **预处理攻击范围**：标记所有不可放置bishop的格子（被原有棋子攻击或阻挡）。
3. **匈牙利算法求最大匹配**：将可放置的位置视为二分图的边，求最大匹配即为最多可放置的bishop数量。

### 解决难点
- **旋转坐标转换**：需正确计算旋转后的行列编号，例如原坐标`(i,j)`转45°后映射为`(i+j-1, j+n-i)`。
- **复杂攻击范围处理**：需模拟所有原有棋子的攻击路径（如queen的十字+斜线，pawn的前方斜线等），并考虑阻挡。

### 可视化设计
1. **棋盘旋转动画**：展示原棋盘旋转45°后行列编号的变化。
2. **攻击范围高亮**：用不同颜色标记各棋子的攻击路径（如红色表示不可放置区）。
3. **匈牙利算法演示**：动态显示增广路径的搜索过程，匹配边用绿色标记，未匹配边用灰色。
4. **复古像素风格**：棋盘用8位色块表示，音效提示匹配成功/失败。

---

## 题解清单（评分≥4星）

### 1. GNAQ（★★★★☆）
- **亮点**：详细处理每种棋子的攻击方式，旋转坐标转换清晰，匈牙利算法实现简洁。
- **代码片段**：
  ```cpp
  void GoB(int _x, int _y) { // 处理原有bishop
      av[_x][_y] = true;
      int i = pau[_x][0] + _y - 1, j = pau[_x][1] + _y - 1;
      h[i] = true; l[j] = true; // 标记旋转后的行列
  }
  ```

### 2. caizehua（★★★★☆）
- **亮点**：链式前向星建图，预处理逻辑完整，注释清晰。
- **个人心得**：输入处理需一次性读取整个棋盘，避免WA。

### 3. lly66666（★★★★☆）
- **亮点**：代码简洁，统一处理旋转后的行列划分，适合快速理解核心逻辑。
- **关键代码**：
  ```cpp
  for (int i=1; i<=n; i++)
      for (int j=1; j<=m; j++)
          if (!flag[i][j]) 
              g[j-i+n].push_back(i+j+m+n-1); // 旋转后的行列编号
  ```

---

## 核心代码实现

### 预处理攻击范围（以Queen为例）
```cpp
void Queen(int x, int y) {
    Rook(x, y); // 处理十字攻击
    Bishop(x, y); // 处理斜线攻击
}

void Rook(int x, int y) {
    for (int dir : {0,1,2,3}) { // 上下左右四个方向
        int dx = x, dy = y;
        while (true) {
            dx += dirx[dir], dy += diry[dir];
            if (!in_map(dx, dy) || map[dx][dy] != '.') break;
            used[dx][dy] = 1; // 标记不可放置
        }
    }
}
```

### 二分图匹配（匈牙利算法）
```cpp
bool dfs(int u, int tag) {
    for (int v : graph[u]) {
        if (vis[v] == tag) continue;
        vis[v] = tag;
        if (!match[v] || dfs(match[v], tag)) {
            match[v] = u;
            return true;
        }
    }
    return false;
}

int max_matching() {
    int ans = 0;
    for (int i=1; i<=max_row; i++)
        if (dfs(i, i)) ans++;
    return ans;
}
```

---

## 类似题目推荐
1. **P2825 [HEOI2016/TJOI2016]游戏**：行列匹配处理棋盘障碍。
2. **P6062 [USACO05JAN] Muddy Fields G**：二分图建模覆盖问题。
3. **P3355 骑士共存问题**：棋盘攻击范围转化为图匹配。

---

## 可视化与复古动画设计
1. **Canvas绘制旋转棋盘**：  
   - 原棋盘用网格显示，旋转后行列用不同颜色区分。
   - 可放置的格子闪烁提示，匹配过程动态连线。
2. **8位音效**：  
   - 匹配成功：清脆的“叮”声（440Hz）。
   - 匹配失败：低沉的“嘟”声（220Hz）。
3. **自动演示模式**：  
   - 按空格暂停/继续，方向键控制速度。
   - 攻击路径逐步展开，匈牙利算法的搜索路径高亮。

```html
<!-- 示例：Canvas动画初始化 -->
<canvas id="board" width="800" height="600"></canvas>
<script>
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
// 绘制旋转后的棋盘网格
function drawRotatedGrid() {
    for (let i=0; i<n+m-1; i++) {
        for (let j=0; j<n+m-1; j++) {
            if (isValidCell(i, j)) {
                ctx.fillStyle = '#8BDB81'; // 可放置格子
                ctx.fillRect(i*30, j*30, 28, 28);
            }
        }
    }
}
</script>
```

---
处理用时：63.41秒
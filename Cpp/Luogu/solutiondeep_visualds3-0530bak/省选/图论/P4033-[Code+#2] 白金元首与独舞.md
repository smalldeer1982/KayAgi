# 题目信息

# [Code+#2] 白金元首与独舞

## 题目背景

```cpp
到河北省 见斯大林 / 在月光下 你的背影 / 让我们一起跳舞吧
```
うそだよ~ 河北省怎么可能有 Stalin。


可是…… 可是如果 Stalin 把自己当作炸弹扔到地堡花园里来了呢？


怀揣着这份小小的希望，元首 Adolf 独自走进了花园。终有一天会重逢的吧，Stalin。或许是在此处，或许是在遥远的彼方。


无论如何，在此之前，好好装点一番花园，编排一段优美的舞步吧！


## 题目描述

元首把花园分为 $n$ 行 $m$ 列的网格。每个格子中都可以放置一个标识，指向上、下、左、右四个方向中的任意一个。元首位于一个格子时，会按照其中标识所指的方向进入周围的格子，或者走出花园（即目的格子不在网格之内）。举个例子 —— 对于下面的放置方式，元首从第 $3$ 行第 $2$ 列的格子开始，会沿着以红色标出的路径走出花园；从第 $2$ 行第 22 列的格子开始，则会在以蓝色标出的环路内不断地行走。

 ![](https://cdn.luogu.com.cn/upload/pic/12659.png) 

元首已经设计好了大部分格子的标识。元首用字符 L、R、U、D 分别表示指向左、右、上、下四个方向的标识，用字符 . 表示未决定的格子。现在，元首希望将每个 . 替换为 L、R、U、D 中任意一种，使得从花园中的任意一个格子出发，按照上述规则行走，都可以最终走出花园。


你需要编写程序帮助元首计算替换的不同方案数。两个方案不同当且仅当存在一个格子，使得两个方案中该格子内的标识不同。当然，由于答案可能很大，只需给出方案数除以 $10^9 + 7$所得的余数即可。


## 说明/提示

**样例解释**

第 $1$ 组数据中，将惟一的 . 替换成 R、U 或 D 均满足要求。


第 $2$ 组数据中，将左上方和右下方的两个 . 分别替换成 LR、LU、LD、UR、UU、UD、DR 或 DD 均满足要求。


第 $3$ 组数据中，没有待决定的格子，原本的安排会使得元首陷入无尽的环路，故答案为 $0$。该组数据与**题目描述**中的例子相同。


第 $4$ 组数据中，也没有待决定的格子，但原本的安排已经满足要求，故答案为 $1$。


令 $k$ 表示标记未确定（即包含 “.”）的格子总数。


对于所有数据，有 $1 \leq T \leq 10$，$1 \leq n, m \leq 200$，$0 \leq k \leq \min(nm, 300)$。

 ![](https://cdn.luogu.com.cn/upload/pic/12660.png) 

“... wie Stalin!”


题面与史实无关。


来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/吕时清 命题/吕时清 验题/王聿中，杨景钦

Git Repo：https://git.thusaac.org/publish/CodePlus201712

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
5
3 9
LLRRUDUUU
LLR.UDUUU
LLRRUDUUU
4 4
LLRR
L.LL
RR.R
LLRR
4 3
LRD
LUL
DLU
RDL
1 2
LR
2 2
..
..```

### 输出

```
3
8
0
1
192```

# AI分析结果



## 唯一算法分类
矩阵树定理

---

## 题解思路与算法分析
### 核心思路
将网格图转化为有向图，合法方案对应以虚点（外部）为根的内向树形图。使用矩阵树定理计算生成树数量，并通过预处理未确定点的可达点来优化复杂度。

### 解决难点
1. **图的压缩**：发现未定向点之外的路径可压缩处理，只需处理未定向点间的连接关系。
2. **基尔霍夫矩阵构建**：每个未定向点向四个方向连边时，找到第一个关键点（其他未定向点或虚点），建立缩略图。
3. **环的处理**：预先DFS判断固定方向部分是否已形成环。

### 算法流程
1. **预处理每个点的可达点**：记忆化DFS确定每个点移动后的首个关键点。
2. **构建缩略图**：仅保留未定向点与虚点的边。
3. **矩阵树定理应用**：求基尔霍夫矩阵行列式得到生成树数量。

---

## 题解评分（≥4星）
### shadowice1984（★★★★☆）
- **亮点**：完整记忆化预处理逻辑，详细注释高斯消元实现。
- **代码优化**：通过`tr`数组缓存可达点计算结果，避免重复搜索。

### Rainybunny（★★★★☆）
- **亮点**：代码结构清晰，独立处理环检测与可达点预处理。
- **可读性**：使用更简洁的DFS判环逻辑，变量命名明确。

---

## 最优思路提炼
1. **缩点优化**：仅保留未定向点与虚点，将O(nm)规模压缩至O(k)。
2. **记忆化DFS**：预处理时缓存每个点的最终可达点，避免重复计算。
3. **矩阵构建技巧**：入度矩阵 - 邻接矩阵，删除虚点对应行列。

---

## 同类型题目
- **P4208** [JSOI2008]最小生成树计数（矩阵树定理基础应用）
- **P3317** [SDOI2014]重建（带权矩阵树定理）
- **P5296** [北京省选集训2019]生成树计数（多项式矩阵树定理）

---

## 可视化设计
### 动画流程
1. **网格绘制**：8位像素风格渲染网格，未定向点高亮显示。
2. **路径追踪**：点击未定向点时，展示四个方向的移动路径，用不同颜色箭头表示最终连接的关键点。
3. **矩阵构建演示**：在右侧Canvas动态绘制基尔霍夫矩阵，高亮当前处理的未定向点对应行列。

### 复古效果
- **音效设计**：
  - 路径确认时播放短促"哔"声（Web Audio合成方波）
  - 发现环时播放低沉"嗡"声
  - 计算完成时播放经典FC过关音效
- **像素动画**：使用16色调色板，网格移动效果类似《塞尔达传说》地牢移动动画。

---

## 代码片段（关键逻辑）
```cpp
// 记忆化搜索可达点（shadowice1984）
int dfs(int px, int py) {
    if (越界) return 虚点编号;
    if (tr[px][py]已计算) return tr[px][py];
    switch(当前点方向) {
        case 'L': tr[px][py] = dfs(左邻点); break;
        // 类似处理其他方向
    }
    return tr[px][py];
}

// 构建基尔霍夫矩阵（Rainybunny）
void add(int s, int t) {
    K[s][s]++;  // 入度增加
    K[s][t]--;  // 邻接边减少
}
```

---

## 个人心得
- **调试经验**：初始未处理虚点导致行列式错误，添加`ctt++`后修正。
- **优化启示**：预处理可达点将复杂度从O(n^3m^3)降至O(k^3)，实现质的飞跃。

---

通过将复杂网格问题抽象为图论模型，并巧妙应用矩阵树定理，此题展现了算法优化中"问题转化"与"规模压缩"的核心思想。

---
处理用时：54.06秒
# 题目信息

# [Code+#1] 大吉大利，晚上吃鸡！

## 题目背景

最近《绝地求生：大逃杀》风靡全球，皮皮和毛毛也迷上了这款游戏，他们经常组队玩这款游戏。

在游戏中，皮皮和毛毛最喜欢做的事情就是堵桥，每每有一个好时机都能收到不少的快递。

当然，有些时候并不能堵桥，皮皮和毛毛会选择在其他的必经之路上蹲点。

K博士作为一个老年人，外加有心脏病，自然是不能玩这款游戏的，但是这并不能妨碍他对这款游戏进行一些理论分析，比如最近他就对皮皮和毛毛的战术很感兴趣。


## 题目描述

游戏的地图可以抽象为一张 $n$ 个点 $m$ 条无向边的图，节点编号为 $1$ 到 $n$ ，每条边具有一个正整数的长度。

**假定大魔王都会从 $S$ 点出发到达 $T$ 点（ $S$ 和 $T$ 已知），并且只会走最短路，**皮皮和毛毛会在 $A$ 点和 $B$ 点埋伏大魔王。

为了保证一定能埋伏到大魔王，同时又想留大魔王一条生路，皮皮和毛毛约定 $A$ 点和 $B$ 点必须满足：

- 大魔王所有可能路径中，必定会经过 $A$ 点和 $B$ 点中的任意一点

- 大魔王所有可能路径中，不存在一条路径同时经过 $A$ 点和 $B$ 点

K博士想知道，满足上面两个条件的 $A,B$ 点对有多少个，交换 $A,B$ 的顺序算相同的方案。


## 说明/提示

### 样例1解释

合法的方案为$<2,3>,<2,4>,<4,3>,<4,5>,<6,3>,<6,5>$ 。

 ![](https://cdn.luogu.com.cn/upload/pic/12824.png) 

来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/陈宇 命题/陈宇 验题/邢健开

Git Repo：https://git.thusaac.org/publish/CodePlus201711

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
7 7 1 7
1 2 2
2 4 2
4 6 2
6 7 2
1 3 2
3 5 4
5 7 2```

### 输出

```
6```

## 样例 #2

### 输入

```
5 5 1 4
1 2 1
1 3 1
2 4 1
3 4 1
4 5 1```

### 输出

```
3```

## 样例 #3

### 输入

```
6 7 1 4
1 2 1
1 3 1
2 4 1
3 4 1
4 5 1
1 6 2
6 4 2```

### 输出

```
5```

# AI分析结果



## 算法分类
**最短路 + 拓扑排序 + 计数分析**

---

## 综合分析与结论

### 核心算法流程
1. **最短路与路径计数**  
   - 正反两次 Dijkstra 计算每个点到 S/T 的最短距离（`dis[0][i]`/`dis[1][i]`）和路径数量（`f[0][i]`/`f[1][i]`）
   - 路径数量公式：`F(i) = f[0][i] * f[1][i] mod MOD`
2. **拓扑排序确定区间**  
   - 任选一条最短路 P，对非路径点 i 计算其在 P 上的有效区间 `[L(i), R(i)]`
   - 通过拓扑排序递推：`L(i) = max{L(k)} + 1`，`R(i) = min{R(k)} - 1`
3. **滑动窗口统计答案**  
   - 用 map 维护窗口内各 `F(i)` 的频率
   - 遍历最短路 P 上的点时，动态添加/删除对应区间的非路径点，统计满足 `F(A)+F(B)=F(T)` 的点对

### 可视化设计思路
- **Dijkstra 过程**：高亮当前扩展节点及其邻接边，动态更新距离值和路径数
- **拓扑排序递推**：用颜色标记不同点的 L/R 区间变化，展示区间收缩过程
- **滑动窗口统计**：用动态热力图展示 map 中各值的出现频率，突出当前查询的 `F(T)-F(p_j)`

### 复古像素风实现
- **Canvas 网格**：用 8x8 像素块表示节点，最短路 P 用黄色标记，非路径点用蓝色
- **音效设计**：
  - 节点扩展时播放类似《超级马里奥》金币音效
  - 找到合法点对时触发《塞尔达传说》成功音效
- **自动演示**：AI 按拓扑序逐步展开节点区间，自动调整滑动窗口并统计结果

---

## 题解评分 (≥4星)

### 1. wsyhb（★★★★★）
- **亮点**：严谨的数学证明、拓扑排序优化、通过 Hack 数据
- **关键代码**：
  ```cpp
  // 拓扑排序递推 L/R
  if (check(op, x, y, Len[i])) {
      op ? r[y] = min(r[x], r[y]) : l[y] = max(l[x], l[y]);
  }
  // 滑动窗口统计
  for (auto it : id_l[i]) ++cnt[F[it]];
  ans += cnt[get_dif(F[T], F[p[i]])];
  ```

### 2. JoaoFelix（★★★★）
- **亮点**：bitset 优化点对关系、哈希处理路径数
- **核心思想**：
  ```cpp
  bitset<N> can, now, Ans[N]; // 用 bitset 记录点对关系
  for (i in 非路径点) Ans[i] |= imp; // 处理覆盖关系
  ```

---

## 最优思路提炼

### 关键技巧
1. **路径覆盖与互斥的等价条件**  
   - 将点对条件转化为：`F(A)+F(B)=总路径数` 且 `A/B 无法共存于同一条路径`
2. **最短路 DAG 的拓扑性质**  
   - 所有最短路形成 DAG，支持递推 L/R 区间
3. **滑动窗口动态统计**  
   - 按最短路顺序维护哈希表，避免重复计算

---

## 同类题目推荐
1. **P1144 最短路计数**（基础路径计数）
2. **P1608 路径统计**（带权路径计数）
3. **P3238 寻路游戏**（最短路覆盖与互斥）

---

## 个人心得摘录
> "巨佬们的题解都好难懂... 通过拓扑排序递推区间是本题最关键的一步，需结合 DAG 的性质严谨证明。" —— wsyhb  
> "造数据时发现，若不对路径数取模，会被特殊构造的指数级数据 Hack。" —— JoaoFelix

---

## 代码核心片段
```cpp
// 拓扑排序递推 L[i] 和 R[i]
void TopSort(int op) {
    for (遍历边) if (该边在最短路上) 更新入度;
    while (拓扑队列非空) {
        int x = que.front();
        for (邻接点 y) {
            op ? r[y] = min(r[x], r[y]) : l[y] = max(l[x], l[y]);
            if (--d[y] == 0) que.push(y);
        }
    }
}

// 滑动窗口统计答案
map<int, int> cnt;
for (遍历最短路上的点 p_j) {
    for (i in 进入区间左端点的点) cnt[F[i]]++;
    ans += cnt[F[T] - F[p_j]];
    for (i in 离开区间右端点的点) cnt[F[i]]--;
}
```

---

## 可视化交互设计
```javascript
// 伪代码：Canvas 绘制最短路与区间
function drawPath() {
    ctx.fillStyle = "#FFFF00"; // 黄色表示最短路
    for (let p of pathP) drawPixel(p.x, p.y);
    
    ctx.fillStyle = "#0000FF"; // 蓝色表示有效区间
    for (let i of activeNodes) {
        let [L, R] = getInterval(i);
        drawRect(L, R, i.color);
    }
}

// 音效触发
function playSound(type) {
    if (type === "expand") 
        new Audio("coin.wav").play(); // 扩展节点音效
    else if (type === "match")
        new Audio("success.wav").play(); // 找到匹配对
}
```

---
处理用时：70.83秒
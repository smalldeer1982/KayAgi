# 题目信息

# [WC2016] 挑战NPC

## 题目描述

小 N 最近在研究 NP 完全问题，小 O 看小 N 研究得热火朝天，便给他出了一道这样的题目：

有 $n$ 个球，用整数 $1$ 到 $n$ 编号。还有 $m$ 个筐子，用整数 $1$ 到 $m$ 编号。每个筐子最多能装 $3$ 个球。

每个球只能放进特定的筐子中。 具体有 $e$ 个条件，第 $i$ 个条件用两个整数
$v_i$ 和 $u_i$ 描述，表示编号为 $v_i$ 的球可以放进编号为 $u_i$ 的筐子中。

每个球都必须放进一个筐子中。如果一个筐子内有不超过 $1$ 个球，那么我们称这样的筐子为半空的。

求半空的筐子最多有多少个，以及在最优方案中， 每个球分别放在哪个筐子中。

小 N 看到题目后瞬间没了思路，站在旁边看热闹的小 I 嘿嘿一笑：“水题！”
然后三言两语道出了一个多项式算法。

小 N 瞬间就惊呆了，三秒钟后他回过神来一拍桌子：“不对！这个问题显然是 NP 完全问题，你算法肯定有错！”

小 I 浅笑：“所以，等我领图灵奖吧！”

小 O 只会出题不会做题，所以找到了你——请你对这个问题进行探究，并写一个程序解决此题。

## 说明/提示

对于所有数据， $T \leq 5, 1 \leq n \leq 3m$。 保证 $1 \leq v_i \leq n, 1 \leq u_i \leq m$，且不会出现重复的条件。

保证至少有一种合法方案，使得每个球都放进了筐子，且每个筐子内球的个
数不超过 $3$。

各测试点满足以下约定：
![](https://cdn.luogu.com.cn/upload/image_hosting/wi7sdxbz.png)

## 样例 #1

### 输入

```
1
4 3 6
1 1
2 1
2 2
3 2
3 3
4 3```

### 输出

```
2
1 2 3 3```

# AI分析结果



**唯一算法分类**：一般图最大匹配（带花树算法）

---

### **综合分析与结论**

#### **核心思路与解决难点**
1. **建图技巧**：将每个筐拆分为3个点并互相连边，形成三角形结构。当筐内球数为0/1时，三角形内部会产生匹配边，使得最终匹配数能正确反映半空筐的数量。
2. **匹配推导**：最大匹配数减n即为答案。因为每个球必须匹配，总匹配数中包含n个球的匹配，剩余匹配反映筐的状态（每个筐贡献匹配数-球数）。
3. **算法选择**：必须使用带花树算法处理奇环（由筐拆点形成的三角形导致），普通二分图匹配无法解决。

#### **可视化设计思路**
1. **动画方案**：
   - **筐拆点**：用3个相邻像素块表示筐的三个拆点，初始颜色为灰色。
   - **匹配过程**：球节点（红色）与筐拆点（蓝色）连线表示匹配，筐拆点间连线（黄色）表示内部匹配。
   - **增广路径**：高亮当前搜索路径，绿色表示已匹配边，橙色表示待调整边。
   - **奇环处理**：当检测到奇环时，用紫色闪烁标记花的核心节点。
2. **复古风格**：
   - 8位像素调色板：球（#FF0000）、筐拆点（#00FFFF）、匹配边（#00FF00）、内部边（#FFFF00）。
   - **音效设计**：匹配成功（短促"哔"声）、奇环收缩（低音"咚"声）、算法完成（经典FC过关音效）。
   - **自动演示**：模拟贪吃蛇AI式移动，自动展示增广路径搜索和花收缩过程。

---

### **题解清单（≥4星）**

| 作者       | 星级 | 关键亮点                                                                 |
|------------|------|--------------------------------------------------------------------------|
| zac2010    | ★★★★☆ | 详细数学证明，建图逻辑清晰，代码结构分层明确                              |
| 玫葵之蝶   | ★★★★  | 代码简洁高效，带花树实现完整，变量命名规范                                |
| Crossing   | ★★★★  | 分步骤图解算法流程，注释详细，适合教学场景                                |

**个人心得摘录**：
> "在调试时发现筐拆点的编号计算错误导致WA，建议用`n + (i-1)*3 +1/2/3`形式避免模运算歧义" —— 玫葵之蝶  
> "优先匹配球节点确保所有球被放置，这是AC的关键" —— ubsan

---

### **核心代码实现**

#### **建图与带花树核心逻辑**
```cpp
// 筐拆点互连
for(int i=1; i<=m; i++){
    int base = n + (i-1)*3;
    add_edge(base+1, base+2);
    add_edge(base+2, base+3);
    add_edge(base+1, base+3);
}

// 球与筐拆点连边
while(e--){
    int v,u; 
    scanf("%d%d",&v,&u);
    int base = n + (u-1)*3;
    add_edge(v, base+1);
    add_edge(v, base+2);
    add_edge(v, base+3);
}

// 带花树关键收缩逻辑
void blossom(int x, int y, int lca){
    while(find(x) != lca){
        pre[x] = y;
        if(vis[match[x]] == 2){
            vis[match[x]] = 1;
            q.push(match[x]);
        }
        if(fa[x] == x) fa[x] = lca;
        if(fa[match[x]] == match[x]) fa[match[x]] = lca;
        y = match[x];
        x = pre[y];
    }
}
```

---

### **相似题目推荐**
1. **UOJ79** - 一般图最大匹配（模板题）
2. **P3383** - 二分图匹配（对比建图差异）
3. **CF1089B** - 特殊建图匹配问题

---

### **可视化实现要点**
```javascript
// Canvas绘制筐拆点示例
function drawBasket(ctx, x, y, state){
    const colors = ['#888','#0FF','#F0F'];
    ctx.fillStyle = colors[state];
    ctx.fillRect(x, y, 30, 30); // 30x30像素块
    ctx.strokeStyle = '#000';
    ctx.strokeRect(x, y, 30, 30);
}

// 音效触发逻辑
function playSound(type){
    const sfx = {
        match: new Audio('data:audio/wav;base64,UklGRl9...'),
        blossom: new Audio('data:audio/wav;base64,UklGRk9...')
    };
    sfx[type].play();
}
```

---

**总结**：本题核心在于通过创造性建图将筐状态转化为一般图匹配问题，带花树算法的高效实现是关键。可视化应突出拆点逻辑和花收缩过程，复古风格增强学习趣味性。

---
处理用时：50.39秒
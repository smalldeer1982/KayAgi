# 题目信息

# [HNOI2009] 积木游戏

## 题目描述

丹丹是一位狂热的俄罗斯方块爱好者，但在把积分刷爆之后她终于开始感到厌倦了。于是她着手思考这样一个俄罗斯方块的简化版游戏：在初始状态地面上是空的。假设所有的积木都是长方形，且积木不能旋转或翻转。丹丹在每个时刻会选择一个位置将一块积木落下，当积木在落下的过程中碰到地面或另一块积木时，它会停留在地面上或那块积木上。落到另—块积木上意味着：上面的积木的下边界与下面的积木的上边界至少有一条线段重合(―个点不算)，如图 1 所示。

![图1](https://cdn.luogu.com.cn/upload/pic/22107.png)

在俄罗斯方块中，如果某个时刻积木之间形成了一个洞，那么看上去就很不优美。于是丹丹想知道，每落下一块积木之后，会形成几个新的洞。一个洞是指由积木的边界或地面组成的一块面积大于 $0$ 的封闭的区域，如图 2（a）和图 2（b）所示。

要注意的是：当出现图 3 所示的情况时，因为积木 1 和积木 2 紧紧地挨在一起，所以当积木 3 落下的时候，不会形成新的洞。

现在丹丹告诉你她依次落下的积木的髙度 $H_i$ 以及落下的位置的左右边界 $L_i$ 与 $R_i$，$1 \leq i \leq n$，而她想知道毎次积木落下时会形成几个新的洞？

![图23](https://cdn.luogu.com.cn/upload/pic/22108.png)

## 说明/提示

**【数据范围】**

输入数据保证 $0 \leq L_i < R_i \leq 100000, H_i \leq 1000$。

$30\%$ 的数据保证 $n \leq 100$。

$100\%$ 的数据保证$n \leq 100000$。

**【样例说明】**

样例执行后的结果如图 4 所示，其中依次落下的积木按顺序编号为从 $1$ 到 $6$ 的一个整数。

![图4](https://cdn.luogu.com.cn/upload/pic/22110.png)

## 样例 #1

### 输入

```
6
1 3 2
4 7 2
2 5 1
3 6 1
8 11 2
6 8 3```

### 输出

```
0
0
1
0
0
2```

# AI分析结果



---

### **唯一算法分类**  
线段树/扫描线

---

### **综合分析与结论**  
**题目核心**：动态维护积木下落后的地形，快速计算每次新增的封闭洞数。  
**核心难点**：如何高效检测新积木与已有结构的相互作用形成封闭区域。  

**核心算法流程**：  
1. **线段树维护地形高度**：每块积木下落时，查询其覆盖区间的当前最大高度作为底部。  
2. **动态维护邻接关系**：通过几何相交判断积木间的上下/左右邻接关系，构建图结构。  
3. **洞的统计规则**：  
   - 洞必须由至少三条邻接边构成闭合区域（如三角形、四边形）。  
   - 同一洞的闭合边界中，最后落下的积木负责计数。  

**可视化设计思路**：  
- **地形绘制**：Canvas 绘制二维坐标系，积木以不同颜色方块表示，当前积木高亮。  
- **线段树动画**：右侧面板显示线段树结构，实时高亮被查询/更新的区间节点。  
- **洞检测特效**：检测到新洞时，用闪烁红色边框标记闭合区域，统计数字浮动显示。  
- **复古像素风**：使用 8-bit 风格调色板（棕黄地块、蓝绿积木、红白线段树节点）。

---

### **题解清单 (≥4星)**  
1. **ix35 题解（5星）**  
   - **亮点**：分五类情况讨论洞的轮廓，结合线段树（区间最值）与 set（半洞维护），实现 O(n log n) 复杂度。  
   - **关键代码**：  
     ```cpp  
     // 线段树查询区间最大值  
     int Q = SGT::query( R[i].l + 1, R[i].r );  
     // set维护半洞结构  
     set<pair<int, int>> semi_holes[x];  
     ```  
2. **bzy 题解（4星）**  
   - **亮点**：构建积木邻接图，通过消除三角形避免重复计数，思路独特但代码较复杂。  
   - **个人心得**：提到“大浪淘沙下璀璨事物的淡忘”，体现对题目历史背景的思考。  

---

### **最优思路提炼**  
**关键技巧**：  
1. **分型讨论**：将洞的轮廓拆解为下边、侧边组合，降低问题维度。  
2. **半洞维护**：用 set 记录未闭合的纵区间，快速匹配新积木的侧边闭合条件。  
3. **延迟计数**：仅在新积木成为闭合边时统计，避免重复计算。  

---

### **同类型题推荐**  
1. **P1904 天际线**（扫描线求轮廓）  
2. **P5490 矩形面积并**（线段树+离散化）  
3. **P3740 接水果**（动态区间覆盖统计）  

---

### **可视化与算法演示**  
**动画方案**：  
1. **积木下落**：像素方块从顶部下落，底部阴影显示预测落点高度。  
2. **线段树更新**：右侧线段树节点逐层高亮，显示区间最大值更新过程。  
3. **洞闭合检测**：检测到闭合时播放“叮”音效，红色边框闪烁三次。  

**复古交互设计**：  
- **音效**：下落（8-bit 低频）、闭合（中频和弦）、错误（短促杂音）。  
- **关卡模式**：每 10 块积木为一关，积分基于洞的数量与响应速度。  

---

### **代码实现片段**  
ix35 题解核心逻辑：  
```cpp  
// 线段树查询区间最大值  
int Q = SGT::query( R[i].l + 1, R[i].r );  
R[i].b = Q; R[i].t = R[i].h + Q;  
SGT::modify( R[i].l + 1, R[i].r, R[i].t );  

// set维护半洞  
set<pair<int, int>> semi_holes;  
auto it = semi_holes.lower_bound({R[i].b, 0});  
if (it != semi_holes.end() && it->first <= R[i].t) {  
    ans[i] += it->second;  
    semi_holes.erase(it);  
}  
```  

---

**可视化 JS 片段**（伪代码）：  
```javascript  
// 绘制积木与线段树  
function draw() {  
  ctx.fillStyle = '#8B4513'; // 地面颜色  
  ctx.fillRect(0, groundY, canvas.width, 2);  
  blocks.forEach(block => {  
    ctx.fillStyle = block.color;  
    ctx.fillRect(block.l, block.t, block.r - block.l, block.h);  
  });  
  // 高亮当前操作线段树节点  
  highlightSGTNode(currentNode, '#FF0000');  
}  
```

---
处理用时：68.15秒
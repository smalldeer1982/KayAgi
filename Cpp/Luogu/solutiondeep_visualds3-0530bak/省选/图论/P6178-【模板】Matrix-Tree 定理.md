# 题目信息

# 【模板】Matrix-Tree 定理

## 题目描述

给定一张 $n$ 个结点 $m$ 条边的带权图（可能为无向图，可能为有向图）。

定义其一个生成树 $T$ 的权值为 $T$ 中所有边权的乘积。

求其所有不同生成树的权值之和，对 $10^9+7$ 取模。

---

注意：

1. 本题中，有向图的生成树指的是 **以 $1$ 为根的外向树**；

2. 两棵生成树 $T_1,T_2$ 不同，当且仅当存在存在一条边 $e$，满足 $e\in T_1,\ \ e\notin T_2$。

## 说明/提示

【样例 $1$ 解释】

样例 $1$ 中的无向图如左图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/pxtx9z5a.png)

右图为其一个权值为 $3\times 1\times 2\times 3=18$ 的生成树的例子。

---

【样例 $2$ 解释】

样例 $2$ 中的有向图如左图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/4276yln3.png)

右图为其一个权值为 $1\times 1\times 1\times 2=2$ 的生成树（以 $1$ 为根的外向树）的例子。

---

【数据范围】

对于 $100\%$ 的数据：$1\leq n\leq 300,\ \ 1\leq m\leq 10^5,\ \ t\in \{0,1\},\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^9$。

对于测试点 $1,2,3,4,5,6$，$t=0$；对于测试点 $7,8,9,10,11$，$t=1$。

图中 **可能** 存在重边和自环，重边算作多条边。

## 样例 #1

### 输入

```
5 8 0
2 3 1
1 2 3
4 5 1
4 2 2
3 5 2
3 4 3
3 4 1
3 3 5
```

### 输出

```
144
```

## 样例 #2

### 输入

```
5 9 1
1 2 3
3 2 1
1 3 1
2 4 2
3 5 1
4 3 4
3 5 1
5 4 1
4 4 6
```

### 输出

```
72
```

# AI分析结果



## 【算法分类】
图论-矩阵树定理

---

## 【综合分析与结论】
**核心思路**  
所有题解均基于矩阵树定理，通过构造基尔霍夫矩阵求行列式。无向图使用度数矩阵D-邻接矩阵A，有向图根据根节点选择构造出/入度矩阵。通过高斯消元求行列式，注意模逆元和符号处理。

**难点对比**  
1. **矩阵构造**：有向图需区分入度/出度矩阵，无向图需对称处理边权。  
2. **行列式计算**：模运算下的高斯消元需转为乘逆元，交换行需处理符号。  
3. **符号维护**：消元过程中行列式符号随行交换次数变化。  

**可视化设计**  
- **动画流程**：  
  1. 展示矩阵构建过程（度数、邻接矩阵元素变化）。  
  2. 高斯消元时高亮主元行，逐步消除下方元素。  
  3. 最终对角线乘积以不同颜色标记，行列式结果弹出。  
- **复古像素风格**：  
  - 矩阵元素以8-bit格子展示，消元过程用闪烁边框表示当前操作行。  
  - 音效：行交换时播放“哔”声，消元完成时播放胜利音效。  

---

## 【题解清单 (≥4星)】
1. **command_block (5星)**  
   - 代码简洁，处理无向/有向图逻辑清晰，符号维护高效。  
   - 使用`swap`直接交换指针优化性能。  
2. **Achtoria (5星)**  
   - 理论推导严谨，行列式性质与矩阵树证明详尽。  
   - 高斯消元代码带符号跟踪，适合教学。  
3. **Leianha (4星)**  
   - 代码简短易读，适合快速实现，但缺乏详细注释。  

---

## 【核心代码实现】
```cpp
#include <cstdio>
#include <algorithm>
#define ll long long
#define mod 1000000007
#define Maxn 305
using namespace std;

ll powM(ll a, int t = mod - 2) {
    ll ans = 1;
    while (t) {
        if (t & 1) ans = ans * a % mod;
        a = a * a % mod; t >>= 1;
    } return ans;
}

int n, m, op;
ll *a[Maxn], _a[Maxn][Maxn]; // 指针数组优化矩阵访问

ll det() {
    ll ans = 1;
    bool tr = 0;
    for (int j = 1; j < n; j++) {
        // 寻找主元
        for (int i = j; i < n; i++)
            if (a[i][j]) {
                if (i != j) {
                    swap(a[i], a[j]); // 交换行指针
                    tr = !tr; // 符号翻转
                } break;
            }
        if (a[j][j] == 0) return 0;
        ans = ans * a[j][j] % mod;
        ll inv = powM(a[j][j]); // 计算逆元
        // 归一化当前行
        for (int k = j; k < n; k++)
            a[j][k] = a[j][k] * inv % mod;
        // 消元下方行
        for (int i = j + 1; i < n; i++) {
            ll t = mod - a[i][j];
            for (int k = j; k < n; k++)
                a[i][k] = (a[i][k] + t * a[j][k]) % mod;
        }
    }
    return tr ? (mod - ans) % mod : ans;
}

int main() {
    scanf("%d%d%d", &n, &m, &op);
    for (int i = 1; i <= n; i++) a[i] = _a[i];
    while (m--) {
        int u, v, w; 
        scanf("%d%d%d", &u, &v, &w);
        // 调整根节点位置到末尾
        if (u == 1) u = n; else if (u != n) u--;
        if (v == 1) v = n; else if (v != n) v--;
        if (op == 1) { // 有向图处理
            a[u][v] = (a[u][v] - w) % mod;
            a[v][v] = (a[v][v] + w) % mod;
        } else { // 无向图处理
            a[u][v] = (a[u][v] - w) % mod;
            a[v][v] = (a[v][v] + w) % mod;
            a[v][u] = (a[v][u] - w) % mod;
            a[u][u] = (a[u][u] + w) % mod;
        }
    }
    n--; // 删除根节点对应行列
    printf("%lld", det());
    return 0;
}
```

**关键点解释**  
- **指针优化**：使用`a[i]`指向二维数组行，交换行只需交换指针，效率高。  
- **符号维护**：`tr`变量跟踪行交换次数的奇偶性，决定最终符号。  
- **模逆元**：将除法转换为乘逆元，适应模数非质数情况。  

---

## 【拓展题目】
1. [P4208 JSOI2008 最小生成树计数](https://www.luogu.com.cn/problem/P4208)  
   - 结合矩阵树定理与最小生成树性质。  
2. [P3317 SDOI2014 重建](https://www.luogu.com.cn/problem/P3317)  
   - 处理带概率的生成树权值和。  
3. [P4455 CQOI2018 社交网络](https://www.luogu.com.cn/problem/P4455)  
   - 有向图内向树计数练习。  

---

## **个人心得摘录**
- **调试技巧**：构造小样例验证符号处理，如2x2矩阵手动计算行列式。  
- **模运算陷阱**：负数需加模数再取模，避免溢出。  
- **指针优势**：交换行时代价低，但需注意初始指向正确。  

---

## **可视化设计**
**像素风格演示**：  
1. **矩阵构建**：  
   - 左侧展示原图，右侧8x8网格动态填充度数/邻接矩阵。  
   - 边权累加时对应格子数值闪烁。  
2. **高斯消元**：  
   - 当前主元行用红色边框标记，消元行用蓝色标记。  
   - 每次行交换时播放“咔嚓”音效，消元步骤有“滴答”声。  
3. **结果展示**：  
   - 最终行列式结果以金色数字弹出，伴随经典FC过关音效。  

**AI自动模式**：  
- 点击“Auto”按钮后，算法自动执行，每步间隔1秒，适合观察流程。

---
处理用时：78.90秒
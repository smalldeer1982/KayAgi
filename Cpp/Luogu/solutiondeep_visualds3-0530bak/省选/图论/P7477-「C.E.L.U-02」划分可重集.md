# 题目信息

# 「C.E.L.U-02」划分可重集

## 题目描述

给你一个长度为 $n$ 的数列 $v$，请你将其划分成两个可重集 $a$ 和 $b$。你将从左至右开始划分，每个数必须至少被划分进一个可重集中。  
一个数 $v_i$ 可以被划分进 $a$ 当且仅当 $j<i \ and\ v_j\le v_i-k$ 的 $v_j$ 都没有被划分进当前的 $a$。一个数 $v_i$ 可以被划分进 $b$ 当且仅当 $j<i\ and\ v_j\ge v_i+k$ 的 $v_j$ 都没有被划分进当前的 $b$。  
同时给出了 $m$ 组关系，每组关系代表 $u$ 和 $v$ 不能划分进同一个可重集里。求能使划分成功的最小的 $k$。如果不存在合法划分，请输出 `-1`。

## 说明/提示

### 样例解释

**样例解释一**

以下是一组合法的划分：  
|6|2|8|5|7|3|
|:---:|:---:|:---:|:---:|:---:|:---:|
|a|b|b|a|b|a|

**样例解释二**

以下是一组合法的划分：  
|1|3|4|3|8|2|3|4|5|6|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|b|b|a|b|a|b|a|a|a|b|

### 数据范围 
|数据编号|$n$|$m$|
|:---:|:---:|:---:|
|$1\sim2$|$\le10^3$|$0$|
|$3\sim4$|$\le10^3$|$\le10^3$|
|$5\sim6$|$\le2\times10^4$|$0$|
|$7\sim10$|$\le2\times10^4$|$\le2\times10^4$|

对于 $100\%$ 的数据，$n,m\le2\times10^4,v_i\le10^9$，保证 $u<v\le n$，没有一对相同的 $u,v$。

## 样例 #1

### 输入

```
6 0
6 2 8 5 7 3```

### 输出

```
2```

## 样例 #2

### 输入

```
10 3
1 3 4 3 8 2 3 4 5 6
2 3
6 7
1 9
```

### 输出

```
5```

# AI分析结果



### **唯一算法分类**  
**二分答案 + 2-SAT + 分治优化建图**

---

### **题解思路、算法要点与解决难点**  
**核心逻辑**  
1. **二分答案**：答案 `k` 具有单调性，若 `k` 可行则更小的 `k` 可能不可行，反之亦然  
2. **2-SAT 模型**：每个元素 `i` 对应两个布尔变量 `a[i]` 和 `b[i]`，表示是否划分到集合 `a` 或 `b`  
3. **条件约束**：  
   - 若 `v_j ≤ v_i - k` 且 `j < i`，则 `j ∈ a ⟹ i ∉ a`  
   - 若 `v_j ≥ v_i + k` 且 `j < i`，则 `j ∈ b ⟹ i ∉ b`  
4. **优化建图**：通过分治（CDQ）将偏序关系转化为区间连边，将边数从 `O(n²)` 降至 `O(n log n)`  

**解决难点**  
- **暴力连边不可行**：直接连边会导致 `O(n²)` 复杂度，无法处理 `n ≤ 2e4`  
- **分治优化**：在归并排序过程中，右区间元素对左区间的前缀/后缀形成约束，通过虚点链式连边减少边数  

---

### **题解评分 (≥4星)**  
1. **Jr_Zlw（5星）**  
   - **亮点**：清晰的分治建图策略，利用归并排序处理偏序关系，代码简洁  
   - **关键代码**：  
     ```cpp  
     void cdq(int l, int r) {  
         // 分治过程中处理左右区间的虚点链式连边  
         // 右区间元素通过双指针找到左区间的前缀/后缀  
     }  
     ```  
2. **KingPowers（5星）**  
   - **亮点**：类似分治思路，代码实现更易读，详细注释解释了虚点作用  
   - **关键代码**：  
     ```cpp  
     void solve(int l, int r, int k) {  
         // 建立前缀/后缀虚点链，处理右区间对左区间的约束  
     }  
     ```  
3. **abruce（4星）**  
   - **亮点**：提出主席树/树状数组优化建图，但实现复杂度较高  
   - **关键代码**：  
     ```cpp  
     void add(int x, int y, int pd) {  
         // 树状数组动态维护历史版本，优化连边  
     }  
     ```  

---

### **最优思路或技巧提炼**  
1. **分治优化建图**：  
   - 将元素按 `v_i` 归并排序，分治处理左右区间  
   - 右区间元素对左区间的前缀/后缀形成约束，通过虚点链式连边  
2. **虚点链设计**：  
   - 创建前缀虚点链 `pre[i]` 表示区间 `[l, i]` 的约束  
   - 创建后缀虚点链 `suf[i]` 表示区间 `[i, r]` 的约束  
3. **双指针技巧**：  
   - 在归并后的有序序列中，用双指针快速找到约束区间边界  

---

### **同类型题或类似算法套路**  
1. **2-SAT + 偏序优化**：如 [ARC165F] Make Adjacent  
2. **分治处理偏序**：如 [CF1322D] Reality Show  
3. **动态维护历史版本**：如 [NOI2021] 庆典  

---

### **推荐相似题目**  
1. **P4782 【模板】2-SAT 问题**  
2. **P3834 【模板】可持久化线段树（主席树）**  
3. **CF1442D Sum**  

---

### **个人心得摘录**  
- **Jr_Zlw**：  
  > “调了一周多才明白虚点链的连边方向，必须保证链式传递的逻辑一致性。”  
- **KingPowers**：  
  > “归并排序时要注意 `v_i` 相等的情况，否则双指针会漏掉边界条件。”  

---

### **可视化与算法演示**  
**核心动画设计**  
1. **分治过程可视化**：  
   - **颜色标记**：左区间（蓝色）、右区间（红色）、虚点链（黄色）  
   - **动态连边**：展示右区间元素如何连接到左区间的虚点链  
2. **2-SAT 缩点过程**：  
   - **步进控制**：单步执行 Tarjan 算法，高亮当前访问的节点和边  
   - **强连通分量染色**：不同颜色表示不同 SCC  

**复古游戏化设计**  
1. **8位像素风格**：  
   - 分治区间用 8x8 像素块表示，左区间为蓝色方块，右区间为红色方块  
   - 虚点链用闪烁的黄色像素点动态生成  
2. **音效设计**：  
   - **连边成功**：8-bit 短促“哔”声  
   - **分治完成**：经典 FC 过关音效  
   - **无解**：低沉失败音效  

---

### **核心代码实现（分治优化版）**  
```cpp  
// 分治建图核心代码（KingPowers 题解）  
void solve(int l, int r, int k) {  
    if (l == r) return;  
    int mid = (l + r) >> 1;  
    solve(l, mid, k); solve(mid + 1, r, k);  
    // 建立前缀虚点链 pre[i]  
    for (int i = l; i <= mid; ++i) {  
        pre[i][0] = ++tot; pre[i][1] = ++tot;  
        add_edge(pre[i][0], a[i].id + n); // 若 [l,i] 全选 b，则 i 必须选 b  
        add_edge(a[i].id, pre[i][1]);     // 若 i 选 a，则 [l,i] 不全选 b  
    }  
    // 建立后缀虚点链 suf[i]  
    for (int i = l; i <= mid; ++i) {  
        suf[i][0] = ++tot; suf[i][1] = ++tot;  
        add_edge(suf[i][0], a[i].id);     // 若 [i,mid] 全选 a，则 i 必须选 a  
        add_edge(a[i].id + n, suf[i][1]); // 若 i 选 b，则 [i,mid] 不全选 a  
    }  
    // 处理右区间对左区间的约束  
    int j = l - 1;  
    for (int i = mid + 1; i <= r; ++i) {  
        while (j < mid && a[j + 1].w <= a[i].w - k) ++j;  
        if (j >= l) {  
            add_edge(a[i].id, pre[j][0]);    // i 选 a → [l,j] 全选 b  
            add_edge(pre[j][1], a[i].id + n);// [l,j] 不全选 b → i 选 b  
        }  
    }  
    // 归并排序  
    merge(a + l, a + mid + 1, a + mid + 1, a + r + 1, tmp);  
}  
```

---
处理用时：83.14秒
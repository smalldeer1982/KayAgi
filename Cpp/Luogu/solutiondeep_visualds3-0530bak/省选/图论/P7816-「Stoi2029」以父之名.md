# 题目信息

# 「Stoi2029」以父之名

## 题目背景

> 以父之名判决  
> 那感觉没有适合字汇  
> 就像边笑边掉泪  
> 凝视着完全的黑  
> 阻挡悲剧蔓延的悲剧会让我沉醉  
> ——《[以父之名](https://www.bilibili.com/video/BV1fx411N7bU?p=36)》

## 题目描述

地狱里有 $n$ 个罪人在等待判决，编号为 $1$ 至 $n$。罪人们之间有 $m$ 条罪的联系，编号为 $1$ 至 $m$，每条联系 的值为 $1$ 或 $2$ 且恰好连接两个罪人。

称一个罪人的自负度为他和其他所有罪人之间联系的值之和。两个罪人之间可能不止有一条联系，此时这些联系的值都应该被计算。由于这些罪人承受了太多的罪恶，他们变得不和谐。具体地，每个罪人的自负度都是奇数。

现在，神明将要对他们进行判决。判决的具体方式为：将每条联系都进行定向，使得这条联系所连接的两个罪人中的一个受到惩罚，另一个受到救赎，它们的值均为这条联系的值。

由于神明秉承父的仁慈，希望罪人们更加均等地接受惩罚和救赎，于是他规定判决后每个罪人所受到的惩罚和救赎值总和之差的绝对值必须恰好为 $1$。

由于神明工作繁忙，因此他以父之名要求你为他找到一种判决的方法。由于父的指示不会有错，所以一定存在一种这样的方法。

---

#### 题意简述

给定一个 $n$ 个点 $m$ 条边的无向图，边权均为 $1$ 或 $2$。保证每个点所相连的边权值之和均为奇数。你需要将这些边定向，使每个点的入边权值和与出边权值和之差的绝对值恰为 $1$。保证有解。输出任意一种方案。

## 说明/提示

#### 样例解释

定向后的图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/uhz96nbm.png)

更多样例详见题目附件 `trial_sample.zip`。

------

#### 数据范围

**本题采用捆绑测试。**

- 特殊性质 A：边权均为 $1$，且任意两点之间只存在一条简单路径，且没有重边。
- 特殊性质 B：同一个点至多只有一条边权为 $1$ 和一条边权为 $2$ 的边相连。

| Subtask | 分值 | $1\le n \le$ | $1\le m \le$ | 特殊性质 | 
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $7$ | $10$ | $15$ | 无 | 
| $2$ |  $20$ |$10^3$ | $3\times10^3$ | 无 |
| $3$ |  $20$ |$3 \times 10^5$ | $3 \times 10^5$ | A |
| $4$ | $20$ |$3 \times 10^5$ | $3 \times 10^5$ | B | 
| $5$ |  $33$ |$10^6$ | $3 \times 10^6$ | 无 |

对于 $100\%$ 的数据，$1 \le u_i,v_i \le n \le 10^6$，$1 \le m \le 3 \times 10^6$，$w_i \in \{1,2\}$。

在题目附件 `trial_sample.zip` 中：

- `trial_sample1.in` 即为样例 #1。
- `trial_sample2.in` 满足特殊性质 A。
- `trial_sample3.in` 满足特殊性质 B。
- `trial_sample4.in` 不满足特殊性质。

另外该目录下还有 `checker.exe`。

------

#### 提示

**本题输入输出量较大，请使用较快的输入输出方式。**

本题提供 [Special Judge 源码](https://www.luogu.com.cn/paste/7albhubs)和 `checker.exe`，供选手调试。Windows 下使用方法为:  
命令行在目标文件夹输入指令：
```
checker.exe data.in data.out data.out
```
其中 `data.in` 是输入数据文件，`data.out` 是程序运行结果文件。观察评判结果即可。

- `Perfect answer.` 表示答案正确。
-  `Wrong answer on node x, and the difference is d.` 表示答案错误，其中节点 $x$ 的入边权值和与出边权值和之差的绝对值为 $d$ 而不为 $1$。
- `Invalid answer.` 表示输出的字符串长度不正确或输出非法字符。

请务必保证**输出格式正确**，否则 Special Judge 可能会返回 Unknown Error 等不可预估的结果。

## 样例 #1

### 输入

```
4 5
1 2 1
1 3 2
2 3 1
2 4 1
4 1 2
```

### 输出

```
00100
```

# AI分析结果



## 【算法分类】
欧拉回路

---

## 【题解思路与难点分析】

### 核心思路
通过建立虚点构造欧拉回路，在遍历时优先选择与入边权值相同的出边，利用欧拉回路特性保证每个点入出边权差绝对值为1。

**解决难点：**
1. **度数奇偶性处理**：每个点初始边权之和为奇数，通过虚边（权1）将奇度数点转为偶度数，确保欧拉回路存在。
2. **权值匹配策略**：遍历时优先选择与入边同权的出边，确保最终差值正确。
3. **高效实现**：使用链式前向星存储图，动态更新当前弧避免重复遍历。

### 关键步骤
1. **虚边建立**：对度数为奇数的点与虚点n+1连边，权为1。
2. **欧拉回路构造**：DFS遍历时优先匹配相同权值的边，保证抵消效果。
3. **方向标记**：在递归时动态标记边的方向（0/1）。

---

## 【题解评分 (≥4星)】

1. **Konnyaku_LXZ（5星）**  
   - **亮点**：虚点+欧拉回路的简洁实现，完整注释与当前弧优化。
   - **代码**：链式前向星处理双向边，优先权值匹配逻辑清晰。

2. **_fairytale_（4星）**  
   - **亮点**：代码简洁，分离权值1/2的边处理，使用vector存储图。
   - **缺点**：未显式处理虚边，依赖系统栈可能存在风险。

3. **DengDuck（4星）**  
   - **亮点**：详细注释与自底向上分析，包含欧拉回路正确性证明。
   - **技巧**：用队列处理合并边的方向传递。

---

## 【最优思路提炼】

### 核心技巧
- **虚点构造**：通过添加虚边将图转为欧拉图，保证回路存在。
- **权值优先遍历**：DFS时优先选择相同权值的边，确保权差逐步累积为1。
- **链式前向星优化**：使用`now`数组记录当前弧，避免重复访问。

### 关键代码逻辑
```cpp
void dfs(int u, int pre){
    while(now[u][pre] && e[now[u][pre]].ans != -1) 
        now[u][pre] = nxt[now[u][pre]]; // 优先选同权边
    if(!now[u][pre]){
        pre = 3 - pre; // 切换权值
        while(now[u][pre] && e[now[u][pre]].ans != -1) 
            now[u][pre] = nxt[now[u][pre]];
    }
    if(!now[u][pre]) return;
    int t = now[u][pre];
    e[t].ans = 0; e[t^1].ans = 1; // 标记方向
    dfs(e[t].to, pre); // 递归处理
}
```

---

## 【同类型题推荐】
1. **CF723E** - 构造欧拉回路处理度数问题。
2. **P2731** - 欧拉回路基础题，练习回路构造。
3. **LOJ 一本通 4.3 例1** - 树边定向为欧拉路径。

---

## 【可视化设计】

### 动画方案
1. **像素风格渲染**：  
   - **节点**：8位风格圆点，实点（红/蓝），虚点（灰）。
   - **边**：权1（绿色箭头），权2（黄色箭头），虚边（半透明）。

2. **关键步骤高亮**：  
   - **当前边**：闪烁黄色边框。
   - **路径回溯**：已访问边渐变为灰色，虚边访问后隐藏。

3. **交互控制**：  
   - **速度调节**：滑块控制DFS递归速度（0.5x~5x）。
   - **单步执行**：空格键逐边查看方向标记过程。

### 音效设计
- **边定向**：8位“哔”声（不同音调区分权1/2）。
- **虚边处理**：低音提示，标记后播放成功音效。

---

## 【核心代码实现】
完整代码见Konnyaku_LXZ题解，核心DFS逻辑：
```cpp
void dfs(int u, int pre){
    // 动态更新当前弧，优先匹配同权边
    while(now[u][pre] && e[now[u][pre]].ans != -1) 
        now[u][pre] = nxt[now[u][pre]];
    if(!now[u][pre]){
        pre = 3 - pre; // 权值切换
        while(now[u][pre] && e[now[u][pre]].ans != -1)
            now[u][pre] = nxt[now[u][pre]];
    }
    if(!now[u][pre]) return;
    int t = now[u][pre];
    e[t].ans = 0; e[t^1].ans = 1; // 标记方向
    dfs(e[t].to, e[t].val); // 递归处理出边
}
```

---

## 【总结】
通过虚点构造欧拉图，结合权值优先遍历策略，将复杂边定向问题转化为经典回路构造。此方法高效且易于实现，适用于大规模数据，是图论中巧用欧拉性质的典范。

---
处理用时：62.87秒
# 题目信息

# [CCO 2021] Travelling Merchant

## 题目描述

一个国家有 $n$ 个城市和 $m$ 条单向道路，一个旅行商在这些城市之间旅行。

第 $i$ 条道路从城市 $a_i$ 到城市 $b_i$，只有当他的资产不少于 $r_i$ 元才可以走这条道路，走过这条道路之后他的资产会增加 $p_i$ 元。

他希望自己可以永远不停的游走下去，于是他想知道从任意一个城市出发至少需要多少元初始资产。

## 说明/提示

#### 样例 #1 解释
以第 $2$ 座城市为例：从第 $2$ 座城市出发，初始资产 $3$ 元，则可以在第 $2, 1, 3$ 三座城市无限绕圈。
#### 数据范围
对于 $\frac{2}{7}$ 的数据，$2 \leq n, m \leq 2 \times 10^3$；

对于另 $\frac{15}{49}$ 的数据，$p_i = 0$；

对于 $100\%$ 的数据，$2 \leq n, m \leq 2 \times 10^5$，$1 \leq a_i, b_i \leq n$，$a_i \neq b_i$，$0 \leq r_i, p_i \leq 10^9$，**保证没有自环但可能有重边**。
#### 题目来源
[CCO2021](https://cemc.math.uwaterloo.ca/contests/computing/2021/index.html) D2T1

## 样例 #1

### 输入

```
5 5
3 1 4 0
2 1 3 0
1 3 1 1
3 2 3 1
4 2 0 2```

### 输出

```
2 3 3 1 -1```

# AI分析结果



**唯一算法分类**：贪心 + 拓扑排序

---

### **题解思路、算法要点与解决难点**
#### **核心思路**
所有题解均采用**贪心结合拓扑排序**的思路：
1. **拓扑删除不可达环的点**：出度为0的点无法形成环，直接标记为-1并删除。
2. **按边权降序处理**：将边按 `r_i` 从大到小排序，每次处理当前最大 `r` 的边，更新起点答案。
3. **反图拓扑更新**：用反图（边的起点视为终点）进行拓扑排序，动态删除边并更新相连节点的答案。

#### **关键步骤**
1. **初始化**：所有点初始答案为无穷大，删除出度为0的点。
2. **贪心处理边**：
   - 当前最大的边 `u→v` 确定 `u` 的答案上限为 `r`。
   - 删除此边后，若 `u` 出度为0则入队。
3. **拓扑更新答案**：
   - 从队列取出已确定的点 `v`，在反图中用 `ans[v]` 更新所有前驱节点 `u` 的答案：`ans[u] = min(ans[u], max(r, ans[v] - p))`。
   - 删除相关边，若前驱出度减至0则入队。

#### **解决难点**
- **环的处理**：通过贪心选择最大 `r` 边，确保环内答案的正确性。
- **动态更新顺序**：结合拓扑排序处理出度为0的节点，避免循环依赖。

---

### **题解评分 (≥4星)**
1. **bsTiat (5星)**
   - **亮点**：代码简洁，注释详细，通过链式前向星高效处理反图边。
   - **关键代码**：按边排序后分两步处理队列和边，确保拓扑与贪心正确结合。

2. **uniqueharry (5星)**
   - **亮点**：状态转移方程清晰，反图建边逻辑明确，代码可读性强。
   - **关键代码**：通过 `vis` 数组标记已删除边，避免重复处理。

3. **翼德天尊 (4星)**
   - **亮点**：详细解释贪心原理，代码中 `ans` 更新逻辑直观。
   - **关键代码**：使用优先队列处理边排序，动态维护出度。

---

### **最优思路或技巧提炼**
1. **贪心降序处理边**：选择当前最大 `r` 边，确保初始答案上限。
2. **反图拓扑更新**：将原图边反向建图，用队列动态处理已确定的节点。
3. **动态删除边与出度**：通过 `vis` 数组标记删除边，维护出度数组触发拓扑更新。

---

### **同类型题或类似算法套路**
- **套路**：贪心处理极值边/点 + 拓扑排序动态维护。
- **相似题目**：
  1. **LeetCode 210. Course Schedule II**（拓扑排序处理依赖）
  2. **洛谷 P3387 【模板】缩点**（处理环与动态更新）
  3. **Codeforces 1137C. Museums Tour**（贪心结合拓扑处理时间窗口）

---

### **推荐洛谷题目**
1. **P3387 【模板】缩点**（强连通分量与动态规划）
2. **P2741 [USACO4.4] 重叠的图像Frame Up**（拓扑排序与贪心）
3. **P4017 最大食物链计数**（拓扑排序与动态更新）

---

### **可视化与算法演示**
#### **动画设计**
1. **初始状态**：展示所有节点和边，边按 `r_i` 颜色渐变（红色高亮最大 `r`）。
2. **删除出度为0节点**：灰色标记并移除，播放“失败”音效。
3. **处理当前最大边**：
   - 高亮边 `u→v`，更新 `u` 的答案为 `r`，删除该边。
   - 若 `u` 出度变为0，入队并触发拓扑更新。
4. **反图拓扑更新**：
   - 队列弹出节点 `v`，遍历反图中的边 `u→v`，更新 `ans[u]`。
   - 删除边后出度减1，若为0则入队，播放“成功”音效。

#### **复古像素风格**
- **颜色方案**：节点为8位色块（绿：未处理，红：当前处理，灰：已删除）。
- **音效**：边处理时播放“哔”声，队列更新时播放“滴”声。
- **Canvas交互**：点击单步执行，观察队列和 `ans` 数组变化。

---

### **核心代码实现**
```cpp
// 边结构体排序（降序）
struct Edge { int u, v, r, p; };
vector<Edge> edges;
sort(edges.begin(), edges.end(), [](Edge a, Edge b) {
    return a.r > b.r;
});

// 反图拓扑更新
queue<int> q;
vector<int> out(n+1, 0), ans(n+1, INF);
vector<vector<pair<int, int>>> graph(n+1); // 反图：graph[v] = {u, r, p}

for (auto &e : edges) {
    graph[e.v].emplace_back(e.u, e.p);
    out[e.u]++;
}

// 处理出度为0的节点
for (int i = 1; i <= n; ++i)
    if (out[i] == 0) q.push(i);

// 按边降序处理
for (auto &e : edges) {
    while (!q.empty()) {
        int v = q.front(); q.pop();
        for (auto [u, p] : graph[v]) {
            if (--out[u] == 0) q.push(u);
            ans[u] = min(ans[u], max(e.r, ans[v] - p));
        }
    }
    if (out[e.u] > 0) {
        ans[e.u] = min(ans[e.u], e.r);
        if (--out[e.u] == 0) q.push(e.u);
    }
}
```

---

### **个人心得摘录**
- **bsTiat**：初始尝试直接DFS回溯会超时，贪心+拓扑是正解。
- **翼德天尊**：最大 `r` 边处理是关键，确保后续更新不会遗漏更优解。
- **7KByte**：逆向思维和归纳法破解环问题，删边顺序决定正确性。

---
处理用时：67.94秒
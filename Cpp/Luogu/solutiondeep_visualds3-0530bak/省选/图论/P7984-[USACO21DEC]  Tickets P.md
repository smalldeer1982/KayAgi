# 题目信息

# [USACO21DEC]  Tickets P

## 题目描述

Bessie 正在参加远足旅行！她当前正在旅行的路线由编号为 $1\ldots N$（$1\le N\le 10^5$）的 $N$ 个检查点组成。

有 $K$（$1\le K\le 10^5$）张票可供购买。第 $i$ 张票可以在检查站 $c_i$（$1\le c_i\le N$）以 $p_i$（$1\le p_i\le 10^9$）的价格购得，并且可以用其进入所有检查站 $[a_i,b_i]$（$1\le a_i\le b_i\le N$）。在进入任何检查站之前，Bessie 必须已购买一张允许其进入该检查站的票。一旦 Bessie 可以前往某一检查站，她就可以在未来的任何时候回到该检查站。

对于每一个 $i\in [1,N]$，如果 Bessie 最初只能进入检查点 $i$，输出使得可以进入检查点 $1$ 和 $N$ 所需的最低总价。如果无法这样做，输出 $-1$。


## 说明/提示

【样例解释】

如果 Bessie 从检查点 $i=4$ 开始，那么一种购得进入检查点 $1$ 和 $N$ 的方法如下：

在检查点 $4$ 购买第一张票，使 Bessie 可以进入检查点 $2$ 和 $3$。

在检查点 $2$ 购买第三张票，使 Bessie 可以进入检查点 $7$。

回到检查点 $4$ 购买第二张票，使 Bessie 可以进入检查点 $5$ 和 $6$。

在检查点 $6$ 购买第四张票，使 Bessie 可以进入检查点 $1$。

【数据范围】

- 测试点 1-7 满足 $N,K\le 1000$。
- 测试点 8-19 没有额外限制。


## 样例 #1

### 输入

```
7 6
4 1 2 3
4 10 5 6
2 100 7 7
6 1000 1 1
5 10000 1 4
6 100000 5 6```

### 输出

```
-1
-1
-1
1111
10100
110100
-1```

# AI分析结果



# 【算法分类】
**最短路 + 线段树优化建图**

---

# 【题解思路与解决难点】

## 核心思路
1. **虚拟节点建模**：将每张票视为虚拟节点，构建两类边：
   - 检查点 → 票节点（边权为票价）
   - 票节点 → 覆盖区间的所有检查点（边权为0）
   
2. **三次最短路计算**：
   - **Step1**：以检查点1为起点跑反图最短路（获取到1的最短路径）
   - **Step2**：以检查点n为起点跑反图最短路（获取到n的最短路径）
   - **Step3**：将每个节点初始值设为两次最短路之和，再跑一遍全局最短路（消除重复路径的影响）

3. **线段树优化建图**：
   - 通过线段树将区间连边复杂度从O(n)优化至O(logn)
   - 每个线段树节点代表区间覆盖关系，票节点连接到线段树区间节点

## 解决难点对比
| 方法 | 时间复杂度 | 核心优化点 | 实现难度 |
|------|------------|------------|----------|
| 线段树暴力连边 | O(NKlogN) | 直接建立虚拟节点与线段树区间的边 | 中等 |
| Benq势能分析 | O(NlogN) | 通过维护区间右端点最大值，每个票仅入队一次 | 高 |
| 三次最短路 | O(Nlog²N) | 通过线段树建图后三次Dijkstra松弛 | 中等 |

---

# 【题解评分 (≥4星)】

1. **ETHANK的题解（4.5星）**
   - 亮点：完整的三次最短路流程，清晰的线段树建图代码
   - 代码可读性：结构清晰，注释详细
   - 调试心得："发现两条最短路可能重复计算，需第三次松弛"

2. **Benq的题解（5星）**
   - 亮点：O(NlogN)最优复杂度，利用势能线段树维护区间
   - 优化技巧：对门票按左端点排序，动态维护最大右端点

3. **vectorwyx的题解（4星）**
   - 亮点：简洁的线段树建反图实现
   - 关键代码：`update`函数通过线段树区间连接虚拟节点

---

# 【最优思路提炼】

## 关键技巧
1. **虚拟节点与线段树联用**：  
   ```python
   # 伪代码示例
   for 每张票i:
       创建虚拟节点v_i
       检查点c_i → v_i连边（边权p_i）
       用线段树将v_i连接到区间[a_i,b_i]
   ```

2. **三次松弛消除重复**：  
   ```python
   dis_combine[i] = dis_1[i] + dis_n[i]  # 初始值
   for 所有边u→v:
       dis_combine[v] = min(dis_combine[v], dis_combine[u] + w)
   ```

3. **势能线段树优化**：  
   - 按门票左端点排序
   - 线段树维护区间右端点最大值
   - 每个区间最多被访问一次（势能分析）

---

# 【同类型题与算法套路】

## 通用解法
- **区间连边最短路** → 线段树优化建图
- **多起点最短路合并** → 虚拟超级源点

## 推荐题目
1. [CF786B Legacy](https://www.luogu.com.cn/problem/CF786B)  
   （线段树优化建图模板题）

2. [P6348 [PA2011] Journeys](https://www.luogu.com.cn/problem/P6348)  
   （双向区间连边+并查集优化）

3. [P5025 [SNOI2017] 炸弹](https://www.luogu.com.cn/problem/P5025)  
   （区间引爆问题转化为图论）

---

# 【可视化与算法演示】

## 动画设计方案
1. **数据结构展示**：
   - **左侧**：原检查点（像素方块，编号1~n）
   - **中部**：线段树结构（树状排列，节点显示区间范围）
   - **右侧**：虚拟票节点（不同颜色代表不同票价）

2. **关键步骤高亮**：
   - **红色闪烁**：当前Dijkstra处理的节点
   - **绿色流动**：边松弛过程（票→区间流动特效）
   - **黄色标记**：已确定最短路的节点

3. **复古像素特效**：
   - 8-bit音效设计：
     - `滴`：节点加入优先队列
     - `嘟~`：成功松弛边
     - `铛!`：找到最终答案
   - 像素粒子效果：最短路更新时迸发星点特效

## 交互控制
```javascript
// 伪代码示例
class DijkstraViz {
  constructor() {
    this.speed = 1.0    // 动画速度
    this.stepMode = false // 步进模式
  }
  
  nextStep() { /* 执行单步 */ }
  toggleAuto() { /* 切换自动/手动模式 */ }
  adjustSpeed(v) { /* 调整播放速度 */ }
}
```

---

# 【核心代码片段】

## Benq势能线段树实现
```cpp
struct SegTree {
    vector<int> mx; // 维护区间右端点最大值
    void remove(vector<int> &v, int x) {
        if 当前区间最大值 < x: return
        if 到达叶子节点: 将票加入待处理列表
        递归处理左右子树
    }
};

void dijkstra(vector<ll> &dis) {
    SegTree seg(tickets);
    while (!pq.empty()) {
        int u = pq.top().second;
        通过seg.remove找到所有覆盖u的票
        for 每张票t:
            if 可以松弛: 更新dis并加入队列
    }
}
```

## 三次最短路核心
```cpp
// ETHANK题解的关键部分
void solve() {
    // Step1: 1为起点的最短路
    build_reverse_graph();
    dijkstra(dis1, 1);
    
    // Step2: n为起点的最短路 
    dijkstra(disn, n);
    
    // Step3: 合并结果并松弛
    for(int i=1; i<=n; i++)
        ans[i] = dis1[i] + disn[i];
    dijkstra_final(ans);
}
```

---

# 【像素风格CSS示例】
```css
/* 8-bit风格节点 */
.node {
    width: 32px;
    height: 32px;
    border: 2px solid #4A752C; /* 复古绿边框 */
    image-rendering: pixelated;
    background: url('textures/block.png'); /* 像素纹理 */
}

.ticket-node {
    background-color: #FF6B6B; /* 红色调 */
    animation: pulse 1s infinite; /* 呼吸效果 */
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}
```

---
处理用时：75.24秒
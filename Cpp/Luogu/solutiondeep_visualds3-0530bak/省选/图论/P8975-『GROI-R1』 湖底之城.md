# 题目信息

# 『GROI-R1』 湖底之城

## 题目背景

那年你我仍是无瑕的少年

在夜晚安逸的后院无所顾忌地笑谈人生

——怀念这样毫无猜忌的时光

## 题目描述

悦，玲和荧三个人在湖底之城闲游。湖底之城的道路错综复杂，形成了一棵有 $n$ 个节点的树。

她们三人的手上都有一个计数器，初始都为 $0$。她们每走到一个点的时候，**悦和荧**手上的计数器会自动加上刚刚经过的**这条边的边权**，同时**玲**的计数器会恰好**增加 $1$**。同时，她们整个过程中**没有经过某个点超过一次**。

由于她们的计数器不能存储很大的值，所以，当**玲**的计数器上的值是「湖之数」$p$ 的**倍数**时，**悦可以**将她的计数器上的值减去**荧**的计数器上的值，接下来，**玲和荧**的计数器都会立刻**归零**。

玘现在不知道她们闲游的起点和终点，所以天生计算能力很好的玘对于每一对起点和终点，计算出了悦手上计数器在终点时可能出现的最小值。玘把这个值记作 $f(u,v)$，意思是她们从点 $u$ 走到了点 $v$。可是，玘认为，没有红色彼岸花的寒，一定是算不出来这些答案的。所以，他让寒做一道更简单的题。玘给寒一个长度为 $m$ 的序列 $s$，让寒对于每一个点为 $u$ 时计算 $\min\limits_{i=1}^m\{f(s_i,u)\}$。

**形式化题面**

给定一个 $n$ 个点的树 $(V,E)$ 和一个正整数 $p$，每一条边有一个整数边权 $w_i$。

我们定义 $f(s,v)$ 表示为对 $u,a,b,c$ 进行若干次**拓展**后可以得到的当 $u=v$ 时的 $a$ 的最小值，其中最开始 $u\gets s$ 同时 $a,b,c\gets0$。

**拓展**的定义为依次进行如下操作：

- 选择任意一条边 $(u',v,w)\in E$ 满足 $u=u'$，令 $u\gets v,a\gets a+w,b\gets b+1,c\gets c+w$；

- 如果 $p\mid b$，你****可以****令 $a\gets a-c,b\gets 0,c\gets0$。

特别地，对于每一次**拓展**，你**不能**取一个之前取过的点。

给定序列 $\{s_m\}$，对于每个点 $u$ 求 $\min\limits_{i=1}^m\{f(s_i,u)\}$。



## 说明/提示

**样例解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/xo9b4yyn.png)

 - 如果她们从 $1$ 号点出发，首先有 $f(1,1)=0$。走到点 $2,3,4$ 时悦的计数器上的值分别为 $-2,1,2$，所以 $f(1,2)=-2,f(1,3)=1,f(1,4)=2$。她们走到点 $5,6$ 时，悦的计数器上的值分别为 $-5,8$。由于这时玲的计数器上的值等于 $2$，是 $p$ 的倍数，所以悦**可以**选择让她手上的计数器的值减去荧的计数器的值，不难得出 $f(1,5)=-5,f(1,6)=0$。
 
- 如果她们从 $5$ 号点出发，同理可得 $f(5,5)=0,f(5,2)=-3,f(5,6)=0,f(5,1)=-5,f(5,4)=-3,f(5,3)=-4$。

综上的 $\{ans_n\}=\{-5,-3,-4,-3,-5,0\}$。计算可得 $\text{xor}_{i=1}^n |ans_i|=4$。

**数据范围**

**本题采用捆绑测试。**

| 子任务编号 | 数据范围 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $\text{Subtask1}$ | $m\le n\le100$，$p\le20$ |  | $10$ |
| $\text{Subtask2}$ | $m\le n\le10^3$，$p\le100$ |  | $15$ |
| $\text{Subtask3}$ | $n\le10^5$，$p\le100$，$m=1$ |  | $10$ |
| $\text{Subtask4}$ | $m\le n\le10^5$，$p=1$ |  | $20$ |
| $\text{Subtask5}$ | $m\le n\le10^5$，$p\le100$ | 有 | $10$ |
| $\text{Subtask6}$ | $m\le n\le10^5$，$p\le100$ |  | $35$ |

特殊性质：保证树退化成一条链。

对于 $100\%$ 的数据 $1\le m\le n\le10^5$，$1\le p\le100$，$-10^4\le w\le10^4$，$1\le u,v,s_i\le n$。

## 样例 #1

### 输入

```
6 2 2
1 2 -2
1 3 1
1 4 2
2 5 -3
2 6 10
1 5
```

### 输出

```
4```

# AI分析结果



## 算法分类
动态规划（树形DP）

---

## 题解思路与解决难点
### 核心思路
1. **状态定义**：`f[u][j]` 表示从任一起点到节点 `u`，且当前路径长度（玲的步数）模 `p` 余 `j` 时的最小悦计数器值。
2. **转移方程**：
   - 对每条边 `(u, v, w)`，计算新余数 `j_new = (j+1) % p`。
   - 若 `j_new ≠ 0`，则 `f[v][j_new] = min(f[v][j_new], f[u][j] + w)`。
   - 若 `j_new = 0`，则允许执行减法操作，此时 `f[v][0] = min(f[v][0], f[u][j] + w, 0)`。
3. **初始化**：所有起点的 `f[s_i][0]` 初始化为0，其余状态初始为无穷大。
4. **结果提取**：对每个节点 `v`，取所有余数状态的最小值，再在所有起点中取最小。

### 解决难点
- **状态压缩**：通过模 `p` 的余数将无限步数压缩为有限状态。
- **减法操作处理**：在余数为0时，通过比较 `f[u][j]+w` 和0，隐式处理减法操作的最优选择。
- **树遍历顺序**：采用 BFS 确保状态按正确顺序更新，避免重复计算。

---

## 最优思路提炼
1. **模数状态动态规划**：利用余数将路径长度离散化，状态数从指数级降为线性。
2. **贪心决策嵌入**：在余数为0时，直接比较是否执行减法操作更优，无需记录历史路径。
3. **多源初始化**：将多个起点统一初始化，通过一次遍历处理所有起点到各节点的最优解。

---

## 同类型题与算法套路
- **类似题目**：树上的路径最优化问题，结合周期性决策（如每隔k步执行特定操作）。
- **通用解法**：状态设计时考虑周期模数，动态规划转移时嵌入贪心决策。

---

## 推荐题目
1. P1354 树上最短路径（动态规划+状态压缩）
2. P2015 二叉苹果树（树形DP，状态转移类似）
3. P3177 树上染色（复杂树形DP，分状态维护）

---

## 可视化设计
### 动画方案
1. **树形结构展示**：以节点和边绘制树，边权动态显示。
2. **状态颜色编码**：不同余数状态用不同颜色，余数0标红。
3. **转移高亮**：处理边 `u→v` 时，高亮该边，显示当前余数 `j` 和计算后的 `j_new`。
4. **数值更新动效**：节点 `v` 的状态值变化时，以弹出动画显示新旧值比较。
5. **减法操作提示**：当余数为0时，显示“0”选项的对比过程。

### 复古像素风格
- **8位颜色**：使用16色调色板，节点为像素方块，边为单色线段。
- **音效设计**：
  - 转移时播放“嘀”声。
  - 余数0触发减法时播放“叮”声。
  - 发现更优解时播放上扬音效。
- **自动演示**：按 BFS 顺序自动播放，支持暂停/步进。

---

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10, P = 105, INF = 0x3f3f3f3f;
vector<pair<int, int>> g[N];
int f[N][P], ans[N];
int n, m, p;

void bfs(const vector<int>& starts) {
    queue<pair<int, int>> q;
    memset(f, 0x3f, sizeof f);
    for (int s : starts) {
        f[s][0] = 0;
        q.emplace(s, 0);
    }
    
    while (!q.empty()) {
        auto [u, j] = q.front(); q.pop();
        for (auto [v, w] : g[u]) {
            int nj = (j + 1) % p;
            int nval = f[u][j] + w;
            if (nj == 0) nval = min(nval, 0);
            if (nval < f[v][nj]) {
                f[v][nj] = nval;
                q.emplace(v, nj);
            }
        }
    }
}

int main() {
    scanf("%d%d%d", &n, &m, &p);
    for (int i = 1; i < n; i++) {
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);
        g[u].emplace_back(v, w);
        g[v].emplace_back(u, w);
    }
    
    vector<int> s(m);
    for (int& x : s) scanf("%d", &x);
    
    bfs(s);
    
    memset(ans, 0x3f, sizeof ans);
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < p; j++) {
            ans[i] = min(ans[i], f[i][j]);
        }
    }
    
    int res = 0;
    for (int i = 1; i <= n; i++) 
        res ^= abs(ans[i]);
    printf("%d\n", res);
    
    return 0;
}
```

---

## 关键代码解释
1. **BFS初始化**：将所有起点的余数0状态设为0，并入队处理。
2. **状态转移**：遍历邻接边，计算新余数和候选值，余数为0时与0比较。
3. **结果收集**：对每个节点，遍历所有余数状态取最小值。
4. **异或计算**：将所有节点的答案取绝对值异或，输出最终结果。

---
处理用时：360.49秒
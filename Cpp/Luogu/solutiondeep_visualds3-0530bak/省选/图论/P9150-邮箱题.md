# 题目信息

# 邮箱题

## 题目背景

邮箱，一种历史悠久的接信箱子。西方的邮箱以红色为主，东方的邮箱以绿色为主。

## 题目描述

有一张 $n$ 个点和 $m$ 条边构成的**有向**图。每个点内都有一把另一个点的钥匙，$i$ 号点内有 $k_i$ 号点的钥匙。你能进入一个点当且仅当你有该点的钥匙。保证 $k_i$ 构成排列。

只要进入了一个点，就获得了这个点内有的钥匙。一旦获得钥匙就不会被消耗。

现在你拿到了 $i$ 号点的钥匙并到了 $i$ 号点。你需要对每个 $i$ 求出：

1. 有多少点能被你到达。
2. 有多少点能被你到达并返回起点 $i$。

**请注意：给出的边均是有向边！**

## 说明/提示

**【样例解释】**

以下是第一组数据的解释：（图中括号内的内容为点上的钥匙编号）

![](https://cdn.luogu.com.cn/upload/image_hosting/hrserkw2.png)

1. $1$ 能到达的结点集合为 $\{1,2,3,4\}$，$1$ 能到达且能返回 $1$ 的结点集合为 $\{1,2,3,4\}$；
2. $2$ 能到达的结点集合为 $\{2,3\}$，$2$ 能到达且能返回 $2$ 的结点集合为 $\{2\}$；
3. $3$ 能到达的结点集合为 $\{3\}$，$3$ 能到达且能返回 $3$ 的结点集合为 $\{3\}$；
4. $4$ 能到达的结点集合为 $\{4\}$，$4$ 能到达且能返回 $4$ 的结点集合为 $\{4\}$。

这是一个合法的遍历过程：从 $1$ 开始，初始钥匙为 $2$，到达结点 $2$ 并获得钥匙 $3$，到达结点 $3$ 并获得钥匙 $4$，回到结点 $1$，到达结点 $4$ 并获得钥匙 $1$，到达结点 $3$，回到结点 $1$。

**【数据范围】**

对于 $100\%$ 的数据，满足 $n \ge 3$，$m\ge 0$，$\sum n\le 1.5\times{10}^6$，$\sum m\le 3\times{10}^6$，$1 \le T\le 2\times{10}^4$，$1 \le x, y \le n$，保证图中不含重边或自环。

**本题采用捆绑测试且开启子任务依赖！**

|子任务|对 $n$ 的约束|对 $m$ 的约束|分值|依赖|
|-|-|-|-|-|
|1|$n\le 6$|$m\le 12$|$20$|\ |
|2|$\sum n^3\le {10}^7$|$\sum m^3\le 2\times {10}^7$|$25$|\ |
|3|$\sum n^2\le {10}^8$|$\sum m^2\le {10}^8$|$25$|子任务 1、2|
|4|||$30$|子任务 1、2、3|

## 样例 #1

### 输入

```
3
4 5
2 3 4 1
1 2
2 3
3 1
1 4
4 3
5 6
2 3 4 5 1
1 2
2 3
3 4
4 5
5 2
4 1
3 2
2 3 1
1 2
1 3
```

### 输出

```
4 4
2 1
1 1
1 1
5 5
5 5
3 1
2 1
1 1
2 1
1 1
1 1
```

# AI分析结果



## 算法分类  
**图论 & 强连通分量（SCC）**

---

## 题解思路与解决难点  
### 核心思路  
1. **钥匙环处理**：钥匙构成排列，拆解为若干环。将环复制为双倍长度的链，倒序处理每个点。  
2. **动态维护结构**：  
   - **可达链**：维护从当前点出发能到达的最远连续区间。  
   - **强连通分量**：用并查集维护合并后的连通块。  
3. **合并条件**：判断链合并的可能性需找到最近的返祖边（指向链内祖先的边），若该边在强连通分量内则可合并。  

### 关键步骤  
1. **断环为链**：将每个环复制两次，转化为链结构。  
2. **倒序处理**：从链尾向前处理每个点，利用已处理的后续信息。  
3. **并查集优化**：  
   - `cy` 维护强连通分量的合并。  
   - `ch` 维护可达链的合并。  
4. **返祖边预处理**：记录每个点的最大前驱位置，快速判断合并条件。  

### 解决难点  
- **高效合并链结构**：通过倒序处理与并查集，避免重复遍历。  
- **返祖边的快速查询**：预处理每个点的最大前驱，结合并查集动态维护强连通性。  

---

## 题解评分（≥4星）  
1. **Alex_Wei（5星）**  
   - **亮点**：双并查集设计，断环成链倒序处理，时间复杂度严格线性。  
   - **代码结构**：清晰利用环复制与预处理返祖边。  
2. **syzf2222（4星）**  
   - **亮点**：启发式合并思路，均摊分析复杂度，直观解释链结构合并。  
3. **lizhous（4星）**  
   - **亮点**：置换环处理，强连通分量递推，简洁的结论式分析。  

---

## 最优思路提炼  
1. **断环为链**：将环复制为双倍链，避免循环处理边界。  
2. **倒序动态维护**：从后向前处理，利用已计算的后缀信息快速合并。  
3. **双并查集优化**：分别维护强连通分量与可达链，确保合并条件的高效判定。  

---

## 类似题目  
1. **P3387（缩点）**：强连通分量缩点后处理。  
2. **P2741（置换环）**：置换环上的动态规划。  
3. **P2863（SCC计数）**：强连通分量基础应用。  

---

## 代码核心逻辑  
```cpp
// 并查集结构
struct dsu {
    int fa[N];
    int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
    void merge(int a, int b) { fa[find(b)] = find(a); }
} cy, ch; // cy维护SCC，ch维护链

void solve() {
    // 预处理每个点的返祖边最大前驱
    for (int j = c * 2; j; j--) {
        for (int it : e[id]) {
            if (!in[it]) continue;
            it = in[it]; // 转换为链上位置
            // 更新pre[j]为最大前驱
            pre[j] = max(pre[j], it);
        }
        // 合并强连通分量
        while (cy.find(j) < val[ch.find(j)]) 
            cy.merge(cy.find(j) + 1, cy.find(j));
        // 合并可达链
        if (pre[j + 1] >= j) 
            ch.merge(j + 1, j);
    }
    // 计算答案
    a1[id] = min(c, ch.find(j) - j + 1);
    a2[id] = min(c, cy.find(j) - j + 1);
}
```

---

## 可视化设计  
### 动画方案  
1. **环拆分与链复制**：  
   - 显示原始环，复制为双倍链，高亮当前处理点。  
2. **返祖边检测**：  
   - 红色箭头标记返祖边，动态显示最大前驱位置更新。  
3. **并查集合并**：  
   - 合并时用绿色闪烁效果，显示合并后的连通块范围。  

### 复古像素风格  
- **颜色方案**：强连通分量用16色块区分，返祖边用8位红色像素箭头。  
- **音效**：合并时播放“哔”声，处理完毕播放胜利音效。  
- **自动演示**：按环顺序自动播放合并过程，支持暂停/步进。  

---

## 个人心得  
Alex_Wei在调试中发现，必须严格倒序处理链上的每个点，否则无法正确维护前驱信息。通过将环复制为双倍链，巧妙解决了环的循环依赖问题，这一设计是代码通过大规模数据的关键。

---
处理用时：60.77秒
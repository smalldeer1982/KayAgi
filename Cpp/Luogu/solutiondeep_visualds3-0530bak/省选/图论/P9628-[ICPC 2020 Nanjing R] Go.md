# 题目信息

# [ICPC 2020 Nanjing R] Go

## 题目描述

**围棋**是一种对抗性游戏，目的是用自己的石头比对手的石头包围更大的棋盘总面积。游戏的核心理念是**自由**，即一个开放点，或者更确切地说，是棋盘上垂直线和水平线的交叉点，上面没有石头，与群体接壤。

一个白色或黑色的石头，如果它至少有一个直接正交相邻的自由（上、下、左或右），或者必须与一块有生命的相同颜色的石头在同一个连接组中，那么它是有生命的，被称为**活着**。我们说，如果两块颜色相同的石头正交相邻，它们就直接相连。如果存在一系列石头 $s_1,s_2,…,s_k$ ，对于所有 $1\leq i<k$ ， $s_{i-1}$ 和 $s_i$ 颜色相同且正交相邻，则相同颜色的两块石头 $s_1$ 和 $s_k$ 属于同一连通组。

例如，在下图的左侧，两块白色的石头都没有活着，因为它们被周围的黑色石头捕获了；而在右边的部分，最右边的白色石头也没有生命，即使最左边的黑色石头也没有。

![Go](https://cdn.luogu.com.cn/upload/image_hosting/zjm3icu0.png)

给定一个有 $n$ 条垂直线和 $n$ 条水平线的棋盘，其中可能有一些石头躺在上面，请计算黑色石头捕获的白色石头的数量（也就是说，计算没有生命的白色石头数量）。上述例子的结果分别为 $2$ 和 $1$ 。

然而，我们亲爱的朋友 Kotori 认为这个问题让我们聪明的参赛者解决太简单了，所以她想让你独立翻转每块石头的颜色（也就是说，把黑色的石头变成白色的石头，反之亦然$^1$），并在每次翻转后找到相应的答案。

独立翻转的意思是，在翻转石头的颜色之前，其他石头应该变回原来的颜色。还要注意，这个问题中的数据不是来自真实世界，这意味着棋盘的大小不一定是 $19×19$ ，黑白石头的数量可以是任意整数。

$^1$反之亦然：在这里，它可以用 ```把白色的石头变成黑色的石头``` 来代替。这是现代英语中非常常见的短语，尤其是在学术写作中，所以请记住。

## 说明/提示

对于第二个测试样例，按照 $(1,2),(2,1),(2,2),(2,3),(3,1),(3,2)$ 的顺序翻转石头后，死亡的白色石头数量分别为 $1,0,1,2,0,0$ 。

对于第三个测试样例，棋盘上的所有石头，无论是黑色还是白色，都不是活着的。

## 样例 #1

### 输入

```
3
2
.o
..
3
.x.
xoo
ox.
2
oo
oo```

### 输出

```
0
870527216
485539347```

# AI分析结果



## 唯一算法分类
图论-连通性分析、Tarjan算法

## 综合分析与结论

### 核心思路
1. **初始处理**：将白棋视为图的节点，相邻白棋连边。计算每个连通块的大小及是否含有活棋子（至少一个棋子邻接空点）。
2. **颜色翻转处理**：
   - **白→黑**：判断该点是否为割点。若是，则分裂连通块并检查各子块存活状态；若非，检查原连通块是否仅靠此点存活。
   - **黑→白**：合并相邻白棋连通块，并判断新块是否有活点。
3. **高效更新**：通过预处理连通块与割点信息，每次翻转仅处理局部受影响区域，避免全局重算。

### 难点对比
- **割点处理**：需用Tarjan算法快速判断割点，并计算分裂后的子块存活状态。代码实现中通过DFS树与low/dfn值分析割点影响。
- **动态合并/分裂**：黑→白时需合并多个连通块，处理重复边；白→黑时需分裂，计算各子块贡献。

### 可视化设计
- **像素棋盘**：用Canvas绘制n×n网格，白棋（○）、黑棋（●）、空点（·）。存活连通块高亮为绿色，死亡为红色。
- **动态分裂/合并**：点击棋子翻转颜色时，显示连通块分裂/合并动画。割点处闪烁提示，分裂子块以不同颜色区分。
- **音效与步进**：翻转时播放8-bit音效，空格键步进执行。自动模式下，算法过程如“贪吃蛇AI”自动演示连通性变化。

## 题解清单 (4星以上)
1. **C1942huangjiaxu (4.5星)**
   - **亮点**：完整实现割点处理与动态贡献计算，代码逻辑严密。
   - **优化**：通过Tarjan预处理连通块信息，确保每次翻转操作O(1)时间更新局部。
   - **难点**：DFS树与low/dfn的维护，割点分裂时的递归贡献计算。

## 关键代码片段
```cpp
// Tarjan算法处理割点
void tarjan(int x) {
    dfn[x] = low[x] = ++dfn[0];
    co[x] = tot; cl[x] = ch[x]; sz[x] = 1;
    for (auto v : e[x]) {
        if (!dfn[v]) {
            g[x].push_back(v);
            tarjan(v);
            low[x] = min(low[x], low[v]);
            if (low[v] >= dfn[x]) cut[x] = true;
            cl[x] += cl[v]; sz[x] += sz[v];
        } else low[x] = min(low[x], dfn[v]);
    }
}

// 计算翻转贡献
int rev(int i, int j) {
    if (s[i][j] == 'o') return va[id[i][j]];
    int res = 0, Rs = 1, Rc = lf(i,j);
    set<int> S;
    for (int k = 0; k < 4; ++k) {
        int x = i + dx[k], y = j + dy[k];
        if (onb(x,y) && s[x][y] == 'o') S.insert(co[id[x][y]]);
    }
    for (auto v : S) {
        if (!Cl[v]) res -= Sz[v];
        Rs += Sz[v]; Rc += Cl[v];
    }
    if (!Rc) res += Rs;
    return res;
}
```

## 可视化实现要点
1. **Canvas绘制**：每个棋格为20×20像素，状态颜色映射（白:#FFF, 黑:#000, 存活块:#0F0）。
2. **割点提示**：割点周围显示黄色边框，分裂子块用不同色块扩散动画。
3. **音效触发**：翻转时播放短促“哔”声，死亡块变红时播放低沉音效。
4. **自动演示**：循环翻转每个棋子，展示算法逐步更新过程，控制面板调节速度（1x, 2x, 5x）。

## 相似题目推荐
1. **P3388 割点**：Tarjan算法模板题。
2. **P1656 炸铁路**：边双连通分量与桥的应用。
3. **P1144 最短路计数**：网格图连通性处理。

---
处理用时：81.46秒
# 题目信息

# [JLOI2015] 城池攻占

## 题目描述

小铭铭最近获得了一副新的桌游，游戏中需要用 $m$ 个骑士攻占 $n$ 个城池。

这 $n$ 个城池用 $1$ 到 $n$ 的整数表示。除 $1$ 号城池外，城池 $i$ 会受到另一座城池 $f_i$ 的管辖，其中 $f_i<i$。也就是说，所有城池构成了一棵有根树。 

这 $m$ 个骑士用 $1$ 到 $m$ 的整数表示，其中第 $i$ 个骑士的初始战斗力为 $s_i$，第一个攻击的城池为 $c_i$。

每个城池有一个防御值 $h_i$，如果一个骑士的战斗力大于等于城池的生命值，那么骑士就可以占领这座城池；否则占领失败，骑士将在这座城池牺牲。占领一个城池以后，骑士的战斗力将发生变化，然后继续攻击管辖这座城池的城池，直到占领 $1$ 号城池，或牺牲为止。

除 $1$ 号城池外，每个城池 $i$ 会给出一个战斗力变化参数 $(a_i,v_i)$。若 $a_i=0$，攻占城池 $i$ 以后骑士战斗力会增加 $v_i$；若 $a_i=1$，攻占城池 $i$ 以后，战斗力会乘以 $v_i$。

注意每个骑士是单独计算的。也就是说一个骑士攻击一座城池，不管结果如何，均不会影响其他骑士攻击这座城池的结果。

现在的问题是，对于每个城池，输出有多少个骑士在这里牺牲；对于每个骑士，输出他攻占的城池数量。

## 说明/提示

对于 $100\%$ 的数据，$1\le n,m\le 3\times 10^5$，$
-10^{18}\le h_i,v_i,s_i\le 10^{18}$，$1\le f_i<i,1\le c_i\le n,a_i\in\{0,1\}$，保证 $a_i=1$ 时，$v_i>0$，保证任何时候骑士战斗力值的绝对值不超过 $10^{18}$。


## 样例 #1

### 输入

```
5 5
50 20 10 10 30
1 1 2
2 0 5
2 0 -10
1 0 10
20 2
10 3
40 4
20 4
35 5```

### 输出

```
2
2
0
0
0
1
1
3
1
1```

# AI分析结果



**唯一算法分类**：左偏树（可并堆） + 标记下传

---

### **题解思路与核心难点**

#### **算法要点**
1. **左偏树合并**：每个城池维护一个左偏树（小根堆），存储当前城池的骑士战斗力，合并子树堆时从下到上处理。
2. **标记下传**：通过 `mul` 和 `add` 懒标记批量处理战斗力变化（乘法和加法），避免逐个修改骑士值。
3. **深度统计**：骑士死亡时，通过出发节点和死亡节点的深度差计算攻占城池数。

#### **解决难点**
- **合并顺序**：从叶子节点向根节点合并，确保父节点的堆包含所有子节点的存活骑士。
- **标记优先级**：乘法标记会影响后续加法标记，需先处理乘法再处理加法（`s = s * mul + add`）。
- **空堆处理**：合并时需判断堆是否为空，避免无效操作。

---

### **题解评分（≥4星）**
1. **George1123（5星）**  
   - **亮点**：完整注释、详细错误点提示、初始化与标记下传处理严谨。
   - **代码**：左偏树合并与标记逻辑清晰，特判根节点和空堆。
   - **关键代码**：
     ```cpp
     void pushdown(int x) {
         if (ls[x]) cov(ls[x], tim[x], add[x]);
         if (rs[x]) cov(rs[x], tim[x], add[x]);
         add[x] = 0, tim[x] = 1;
     }
     ```
2. **Soulist（4.5星）**  
   - **亮点**：代码简洁，使用左偏树+DFS合并子树堆，快速处理标记。
   - **核心逻辑**：在DFS中合并子树堆后直接处理死亡骑士。
3. **樱洛CHANGE（4星）**  
   - **亮点**：配对堆替代左偏树，启发式合并优化时间复杂度。
   - **关键点**：通过调整堆的合并顺序减少标记下传次数。

---

### **最优思路提炼**
1. **堆合并与标记批处理**  
   - **左偏树**：高效合并堆结构，适合动态维护最小值。
   - **懒标记**：将乘法和加法操作延迟到堆合并或弹出时处理。
2. **深度差计算攻占数**  
   - 骑士死亡时，`攻占数 = 出发深度 - 死亡深度`，避免动态跟踪路径。

---

### **相似题目推荐**
1. **[P3377 左偏树（模板）](https://www.luogu.com.cn/problem/P3377)**  
   - 左偏树基础操作，练习合并与删除。
2. **[P3373 线段树2](https://www.luogu.com.cn/problem/P3373)**  
   - 懒标记处理乘加混合操作。
3. **[P1090 合并果子](https://www.luogu.com.cn/problem/P1090)**  
   - 堆结构动态合并的简化版。

---

### **可视化设计（核心算法）**
#### **动画演示**
1. **树结构绘制**：以根节点1为中心，子节点按层级分布，城池防御值标注在节点旁。
2. **左偏树操作**：  
   - **合并**：高亮当前合并的两个堆，箭头表示合并方向。
   - **标记下传**：用红色闪烁显示当前节点的 `mul` 和 `add`，传递到子节点时颜色渐变。
3. **死亡判定**：堆顶值 `< h[i]` 时，弹出骑士并显示死亡标记，城池计数器+1。

#### **复古像素风格**
- **颜色方案**：8-bit 色调（深绿堆节点、橙色标记、红色死亡提示）。
- **音效**：合并时播放“叮”，弹出时播放“咔嚓”，标记下传时短暂“滴答”。

---

### **代码片段（关键逻辑）**
```cpp
// 左偏树合并与标记处理（George1123题解核心）
int merge(int x, int y) {
    if (!x || !y) return x + y;
    pushdown(x), pushdown(y);
    if (s[x] > s[y]) swap(x, y);
    rs[x] = merge(rs[x], y);
    if (dep[ls[x]] < dep[rs[x]]) swap(ls[x], rs[x]);
    dep[x] = dep[rs[x]] + 1;
    return x;
}

// 处理城池i的堆
for (int i = n; i >= 1; i--) {
    while (rt[i] && s[rt[i]] < h[i]) {
        die[rt[i]] = i; // 记录死亡节点
        rt[i] = merge(ls[rt[i]], rs[rt[i]]);
    }
    if (a[i]) cov(rt[i], v[i], 0); // 乘法标记
    else cov(rt[i], 1, v[i]);      // 加法标记
    rt[fa[i]] = merge(rt[fa[i]], rt[i]); // 合并到父节点
}
```

---

### **总结**
本题通过左偏树高效合并堆结构，结合懒标记处理动态修改，是树形结构与堆操作的经典结合。关键点在于标记的优先级处理和合并顺序，避免复杂度的爆炸。可视化设计中，堆合并与标记下传的动态演示能直观展现算法核心逻辑。

---
处理用时：83.48秒
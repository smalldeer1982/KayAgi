# 题目信息

# [CQOI2016] 伪光滑数

## 题目描述

若一个大于 $1$ 的整数 $M$ 的质因数分解有 $k$ 项，其最大的质因子为 $a_k$ ，并且满足 $a_{k}^{k} \le N$，$a_k < 128$，我们就称整数 $M$ 为 $N$ - 伪光滑数。

现在给出 $N$，求所有整数中，第 $K$ 大的 $N$ - 伪光滑数。

### 题意澄清

设 $M = 36 = 2^2 \times 3^2$，则其对应的 $k = 4$，也就是说，对 $M$ 运用唯一分解定理，$M = \prod_{i=1}^n{p_i^{c_i}}$，$k = \sum_{i=1}^n{c_i}$。

第 $K$ 大为字面意思，是真的从大到小第 $K$ 个。

modified by expect2004 2020-11-25，这或许是他退役前对洛谷公共题库的最后一次贡献

## 说明/提示

对于 $30\%$ 的数据，$N \le 10^6$；  
对于 $100\%$ 的数据，$2 \le N \le 10^{18},1 \le K \le 800000$。保证至少有 $K$ 个满足要求的数。

## 样例 #1

### 输入

```
12345 20```

### 输出

```
9167```

# AI分析结果



1. **算法分类**  
   优先队列（堆）

2. **题解思路与解决难点**  
   **核心思路**：利用最大质因子必定在替换过程中保持单调性的性质，通过优先队列维护候选数，每次取出最大值后生成更小的候选数。  
   **关键步骤**：  
   - 初始将所有质数的高次幂（满足a_k^k ≤ N）加入堆  
   - 每次取出堆顶元素后，将其中一个最大质因子替换为更小的质因子  
   **解决难点**：  
   - 确保不重复生成相同数值（通过限制替换时只能选择更小的质因子）  
   - 维护候选数的合法性（保证替换后的a_k^k仍 ≤ N）  

3. **题解评分 (≥4星)**  
   - [ycyaw题解] ★★★★★：堆思路清晰，代码简洁，可读性强  
   - [龙翔凤翥题解] ★★★★☆：四元组设计巧妙，但变量名可优化  
   - [Yyxxxxx题解] ★★★★☆：替换逻辑直观，加入队列条件说明详细  

4. **最优思路提炼**  
   **关键技巧**：  
   - **替换降维**：将多维问题（质因子组合）转化为单链替换（每次只能替换为更小质因子）  
   - **合法性传递**：通过维护最大质因子和总幂次保证后续生成的数始终合法  
   ```cpp
   // 核心替换逻辑（ycyaw题解片段）
   if(now.mi>1)
       for(int i=1;i<=now.lim;i++)
           q.push({now.val/now.p*pr[i], now.p, now.mi-1, i});
   ```

5. **同类题目推荐**  
   - P2048 [NOI2010] 超级钢琴（堆维护多路归并）  
   - P1792 [国家集训队] 种树（带限制的堆优化）  
   - P1631 序列合并（双堆维护有序序列）  

6. **可视化设计**  
   **像素化堆操作动画**：  
   - **颜色标记**：  
     - 红色方块：当前取出的最大值  
     - 绿色箭头：展示替换质因子过程（如127→113→...→2）  
     - 黄色边框：高亮合法性质因子替换路径  
   - **动画流程**：  
     1. 初始画面显示多个质数塔（如2^5=32, 3^4=81等）  
     2. 每次弹出堆顶时播放"叮"音效，数值显示为像素数字  
     3. 替换操作时显示旧质数分裂成更小质数的粒子效果  

7. **复古游戏化实现**  
   ```javascript
   // 伪代码示例：8-bit风格堆操作
   class PixelHeap {
     constructor() {
       this.heap = [];
       this.palette = ["#FF0000","#00FF00","#FFFF00"]; // 红绿黄
     }

     drawNode(val, x, y, color) {
       drawRect(x, y, 32, 32, color); // 32x32像素块
       drawText(val, x+4, y+8, "#000000"); // 黑色8位数字
     }

     animatePop() {
       playSound("pop.wav"); // 8-bit音效
       const node = this.heap.pop();
       this.drawNode(node.val, 160, 50, this.palette[0]);
       // ...生成替换节点的动画
     }
   }
   ```

8. **个人心得摘录**  
   - "发现堆解法中替换时必须限制只能使用更小的质因子，否则会产生重复值" —— Yyxxxxx调试记录  
   - "可持久化左偏树在极端数据下更优，但实现复杂度与常数使其在K≤1e6时不占优势" —— Salieri题解反思  

---

**完整题解代码示例（ycyaw版）**  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int pr[]={2,3,5,7,11,...,127}; // 31个质数

struct Node {
    ll val;
    int p_idx, cnt, last_idx;
    bool operator<(const Node& t) const {
        return val < t.val;
    }
};

priority_queue<Node> q;

int main() {
    ll N; int K;
    cin >> N >> K;
    
    // 初始化：各质数的高次幂
    for(int i=0; i<31; i++) {
        ll cur = pr[i];
        for(int j=1; cur<=N; j++, cur*=pr[i])
            q.push({cur, i, j, i-1});
    }

    while(K--) {
        auto t = q.top(); q.pop();
        if(K == 0) cout << t.val;
        
        if(t.cnt > 1) // 替换一个质因子
            for(int i=0; i<=t.last_idx; i++)
                q.push({t.val/pr[t.p_idx]*pr[i], 
                       t.p_idx, t.cnt-1, i});
    }
    return 0;
}
```

---
处理用时：85.18秒
# 题目信息

# 断罪者

## 题目背景

**重阳节**的地狱……

四季映姬·亚玛萨那度（以下简称四季大人）是地狱的最高裁判长，她平时负责给死者定罪，判断让死者去地狱还是天界，或者别的什么地方。

四季大人当然可以轻松地给死者断罪，但是死者太多了，四季大人需要你帮她断罪，以便腾出时间让她对别人进行说教。

## 题目描述

人们的罪恶值$E$由人们**生前所做过的事**和他的**死亡方式**来决定。他们做过的**坏事**都会有一个罪恶值，这些坏事有可能会并入同一个集合，一个集合的罪恶值为该集合中罪恶值最大的坏事的罪恶值，而他们一生做过的事会**互相影响**，我们将他们生前做过的事分为4种，而最后的罪恶值$E$由其中**所有集合的罪恶值的和**决定。

1. 做坏事——有罪恶值，单独为一集合。  
2. 做好事——将一件坏事的罪恶值清零。
3. 忏悔——将指定集合中，最大罪恶值的事罪恶值减少。
4. 认清自己——将两个坏事集合合并。

而死亡方式可分为 *自然死亡* 、*事故死亡* 和 *自杀* 。

1. 自然死亡，没什么影响。
2. 事故死亡，可以免除最大罪恶的坏事集合。
3. 自杀，最大的坏事集合罪恶值翻倍。


## 说明/提示

### 样例 1 解释

一开始有五件坏事，罪恶值分别为 $1.2.3.4.5$，做好事之后，罪恶值分别为 $1.2.0.4.5$，认清自我后，只剩下四个集合，罪恶值分别是 $1.4.0.5$，由于是自然死亡，所以最后的罪恶值 $E=1+4+5=10 \le K \&\& E!=0$，因此输出 $Heaven$

### 样例 2 解释

对于样例2的第一组输入如下图，黑色椭圆代表一个集合，红色为罪恶值，下面为点的编号，由于是事故死亡，可以免去标号5的最大值，故罪恶值为$E=4+5$  
![](https://cdn.luogu.com.cn/upload/pic/72405.png)

### 说明

所有数据均在长整型范围内，对于所有数据，均有$m\le n$,$1\le K$，保证输入不存在负数。  
由于读入数据可能会很大，建议使用较快的读入。

> 约定 ① 对于合并两个集合的操作，至少有一个集合只有一件坏事；
> 约定 ② 这群人不会做好事。

| 测试点编号 |    T    |      n       |  时限  | 约定 |
|:-:|:-:|:-:|:-:|:-:|
|		  1   | $\le10$ |   $\le100$   | $1s$ | ①② |
|		  2   | $\le10$ |   $\le300$   | $1s$ | ①  |
|		  3   | $\le10$ |   $\le500$   | $1s$ |    |
|		  4   | $\le20$ |  $\le1000$   | $1s$ | ①② |
|		  5   | $\le20$ |  $\le3000$   | $1s$ | ①  |
|		  6   | $\le20$ |  $\le7000$   | $1s$ |    |
|		  7   | $\le30$ |  $\le10000$  | $1s$ | ①② |
|		  8   | $\le30$ |  $\le30000$  | $1s$ | ①  |
|		  9   | $\le30$ |  $\le50000$  | $1s$ |    |
|		 10   | $\le30$ |  $\le70000$  | $1s$ | ①② |
|		 11   | $\le10$ | $\le100000$  | $1s$ | ①  |
|		 12   | $\le10$ | $\le150000$  | $1s$ |    |
|		 13   | $\le10$ | $\le200000$  | $1s$ | ①② |
|		 14   | $\le10$ | $\le500000$  | $1s$ | ①  |
|		 15   | $\le10$ | $\le1000000$ | $2s$ |    |
|		 16   | $\le10$ | $\le1000000$ | $2s$ | ①② |
|		 17   | $\le10$ | $\le1000000$ | $2s$ | ①  |
|		 18   | $\le10$ | $\le2000000$ | $2s$ |    |
|		 19   | $\le10$ | $\le2000000$ | $2s$ |    |
|		 20   | $\le10$ | $\le2000000$ | $2s$ |    |
|		 21   | $1$ | $\le2000000$ | $2s$ |  路径压缩  |



## 样例 #1

### 输入

```
1 1 10
5 2
1 2 3 4 5
2 3
4 2 4```

### 输出

```
Heaven 10```

## 样例 #2

### 输入

```
2 2 8
5 4
4 8 7 5 6
4 2 4
2 2
4 2 3
3 3 2
3 2
5 1 2
2 2
3 3 2```

### 输出

```
Hell 9
Gensokyo 0```

## 样例 #3

### 输入

```
2 1 15
5 4
1 2 3 4 5
4 2 3
3 2 100
4 1 4
4 4 1
5 4
1 2 3 4 5
3 2 15
4 2 3
4 1 4
4 3 4```

### 输出

```
Heaven 11
Heaven 9```

# AI分析结果



**算法分类**  
左偏树（可并堆）

---

### **题解思路与算法要点**  
#### **核心逻辑**  
1. **数据结构选择**：  
   - **左偏树**维护每个集合的最大罪恶值（大根堆性质）。  
   - **并查集**（路径压缩）快速定位集合根节点。  
2. **关键操作实现**：  
   - **清零操作**：拆分子树→置零→合并子树。  
   - **减少最大值**：修改根节点值→合并子树→重新插入堆。  
   - **集合合并**：左偏树合并后更新并查集父节点。  
3. **相同值处理**：罪恶值相等时，优先选择编号小的作为根。  

#### **解决难点**  
- **任意节点删除**：需将目标节点的左右子树合并后重新合并到原堆中。  
- **路径压缩同步**：并查集的父节点必须始终指向左偏树的根节点，避免查找错误。  

---

### **题解评分 (≥4星)**  
1. **随情英（5星）**  
   - **亮点**：代码结构清晰，路径压缩与左偏树合并逻辑严谨，注释明确。  
   - **关键代码**：  
     ```cpp  
     int merge(int x,int y){  
         if(!x||!y)return x+y;  
         if(val[x]<val[y]||val[x]==val[y]&&x>y)swap(x,y);  
         r[x]=merge(r[x],y);  
         if(dis[l[x]]<dis[r[x]])swap(l[x],r[x]);  
         fa[l[x]]=fa[r[x]]=fa[x]=x;  
         dis[x]=dis[r[x]]+1;  
         return x;  
     }  
     ```  
2. **望月Asta（4.5星）**  
   - **亮点**：封装结点结构体，显式处理清零逻辑，代码可读性强。  
   - **调试心得**：强调初始化的重要性（多测清空数组）。  
3. **SAMSHAWCRAFT（4星）**  
   - **亮点**：详细解释 `dist` 维护逻辑，提供删除任意节点的动画式步骤。  

---

### **最优思路提炼**  
1. **左偏树+并查集联动**：并查集定位堆根，左偏树维护堆结构。  
2. **非根节点修改**：拆分子树→修改→合并重组，保证堆性质。  
3. **路径压缩优化**：确保并查集父节点始终指向当前堆根。  

---

### **相似题目推荐**  
1. **P3377**（左偏树模板题）  
2. **P1552**（可并堆+贪心）  
3. **P2713**（并查集+集合统计）  

---

### **可视化与算法演示**  
#### **动画方案**  
1. **左偏树结构展示**：  
   - 根节点标记为金色，被操作节点（如清零）标记为红色。  
   - 合并时，子树逐步吸附到新根节点下方，颜色渐变。  
2. **关键操作高亮**：  
   - **清零操作**：目标节点变红→子节点分离→合并动画。  
   - **减少最大值**：根节点闪烁→值减少→子树重组。  
3. **复古像素风格**：  
   - **颜色方案**：8位色（金#FFD700、红#FF0000、绿#00FF00）。  
   - **音效**：合并成功时播放短促「滴」声，清零时播放「咔嚓」声。  
   - **Canvas 绘制**：网格布局，节点用像素方块表示，父子连线动态生成。  

#### **交互设计**  
- **步进控制**：按空格键逐步执行操作，显示当前步骤说明。  
- **自动演示**：AI模式自动遍历所有操作，速度可调（1x/2x/5x）。  

---

### **核心代码实现**  
```cpp  
// 左偏树合并（随情英题解片段）  
int merge(int x, int y) {  
    if (!x || !y) return x + y;  
    if (val[x] < val[y] || (val[x] == val[y] && x > y)) swap(x, y);  
    r[x] = merge(r[x], y);  
    if (dis[l[x]] < dis[r[x]]) swap(l[x], r[x]);  
    fa[l[x]] = fa[r[x]] = fa[x] = x;  
    dis[x] = dis[r[x]] + 1;  
    return x;  
}  
```  

---

### **总结**  
本题通过左偏树与并查集的高效联动，解决了动态集合合并与极值维护问题。可视化设计应聚焦操作节点的动态分离与重组，结合复古像素风格增强理解趣味性。

---
处理用时：81.77秒
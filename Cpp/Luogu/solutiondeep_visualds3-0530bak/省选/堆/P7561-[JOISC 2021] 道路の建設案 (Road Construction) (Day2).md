# 题目信息

# [JOISC 2021] 道路の建設案 (Road Construction) (Day2)

## 题目背景

10s,2048M

## 题目描述

JOI 国是一个 $x\times y$ 的二维平面，王国里有 $n$ 个城镇，分别编号为 $1, 2, \cdots, n$，其中第 $i$ 个城镇的 **坐标** 为 $(x_i, y_i)$。

在 JOI 国，正计划修建连接两座城镇的路（下文简称：**「修路的项目」**），路有 $k$ 条。连接两个不同的城镇 $a$ 和 $b$ 将花费 $|x_a − x_b| + |y_a − y_b|$ 元。若有一条连接 $c$，$d$ 的路，则不需要也不可以在建一条连接 $d$，$c$ 的路，因为它们是相同的。

你要管理这个「修路的项目」，为了计算花费情况，你得弄明白连接一些城镇所需的花费。在这 $\dfrac{n\cdot(n-1)}{2}$ 条道路中，你想了解最便宜的 $k$ 条道路的花费。

给你城镇的坐标以及 $k$，请计算最便宜的 $k$ 条路所需要的钱。

## 说明/提示

#### 样例 #1 解释
有 $\dfrac{3 \times 2}{2} = 3$ 种方案。

- 城镇 $1 \to$ 城镇 $2$，$|(-1)-0|+|0-2| = 3$ 日元。
- 城镇 $1 \to$ 城镇 $3$，$|(-1)-0|+|0-0| = 1$ 日元。
- 城镇 $2 \to$ 城镇 $3$，$|0-0|+|2-0| = 2$ 日元。

将其进行排序为 $1,2,3$，所以输出是 $1$ 和 $2$。

本样例满足 Subtask $1, 4, 5, 6$。

#### 样例 #2 解释

有 $\dfrac{5 \times 4}{2} = 10$ 种方案。

将钱数排序后是 $2, 2, 3, 3, 3, 3, 4, 4, 4, 4$。

本样例满足 Subtask $1, 4, 5, 6$。

#### 样例 #3 解释

本样例满足 Subtask $1, 2, 4, 5, 6$。

#### 样例 #4 解释

本样例满足 Subtask $1, 4, 5, 6$。

#### 数据范围与约定

**本题采用 Subtask 计分法。**

| Subtask | 分值占比百分率 | $n$ | $k$ | $y_i$ |
| :----: | :----: | :----: | :----:| :----: |
| $1$ | $5\%$ | $\le 10^3$ | / | / |
| $2$ | $6\%$ | / | / | $=0$ |
| $3$ | $7\%$ | / | $=1$ | / |
| $4$ | $20\%$ | / | $\le 10$ | / |
| $5$ | $27\%$ |  / | $\le 10 ^ 5$ | / |
| $6$ | $35\%$ | / | / | / |

**注：斜线表示无特殊限制。**

对于 $100\%$ 的数据：
- $2 \le n \le 2.5 \times 10^5$；
- $1 \le k \le \min(2.5\times 10^5,\ \dfrac{n\cdot(n-1)}{2}$)；
- $-10^9 \le x_i, y_i \le 10^9$，且 $1 \le i \le n$；
- $(x_i,y_i)\not = (x_j, y_j)$ 且 $1 \le i < j \le n$。

#### 说明

本题译自 [第２０回日本情報オリンピック 2020/2021春季トレーニング合宿 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [競技 2 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day2/2021-sp-d2-notice.pdf) [T2 日文题面](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day2/road_construction.pdf)。


## 样例 #1

### 输入

```
3 2
-1 0
0 2
0 0
```

### 输出

```
1
2
```

## 样例 #2

### 输入

```
5 4
1 -1
2 0
-1 0
0 2
0 -2
```

### 输出

```
2
2
3
3
```

## 样例 #3

### 输入

```
4 6
0 0
1 0
3 0
4 0
```

### 输出

```
1
1
2
3
3
4
```

## 样例 #4

### 输入

```
10 10
10 -8
7 2
7 -8
-3 -6
-2 1
-8 6
8 -1
2 4
6 -6
2 -1
```

### 输出

```
3
3
4
5
6
6
6
7
7
7
```

# AI分析结果



## 算法分类
二分答案、平面扫描

---

## 题解思路与核心要点

### 核心思路
所有题解均基于 **曼哈顿距离转切比雪夫距离** 的优化，将问题转化为二维平面上的范围查询。通过 **二分答案** 确定第k小的距离，结合 **双指针+有序数据结构** 统计满足条件的点对数。具体步骤：
1. **坐标转换**：将曼哈顿距离转换为切比雪夫距离（`(x,y)→(x+y,x-y)`）；
2. **二分答案**：确定阈值d，判断距离≤d的点对数是否≥k；
3. **双指针维护x范围**：按x排序后，滑动窗口维护当前点的x在`[x_i-d, x_i]`；
4. **有序集合查询y范围**：用`multiset`维护窗口内点的y坐标，查询`[y_i-d, y_i+d]`内的点数。

### 解决难点
- **高效统计点对**：直接枚举点对复杂度O(n²)，通过双指针和有序集合将单次统计优化至O(n log n)；
- **去重与边界处理**：需排除自身点对，且需处理坐标相同的情况；
- **内存与常数优化**：部分题解通过离散化、主席树等进一步优化空间。

---

## 题解评分（≥4星）

### 1. hfjh（★★★★☆）
- **亮点**：思路清晰，代码简洁，双指针+`multiset`实现直观；
- **核心代码**：
  ```cpp
  multiset<Node>s;
  for(int i=1; i<=n; ++i) {
      while(q.size() && p[i].x - p[q.front()].x > mid) {
          s.erase(s.find({p[q.front()].y, q.front()}));
          q.pop();
      }
      auto it = s.lower_bound({p[i].y - mid, 0});
      while(it != s.end() && it->y <= p[i].y + mid) {
          ans[++cnt] = max(abs(it->y - p[i].y), p[i].x - it->x);
          if(cnt >= k) return true;
          ++it;
      }
      q.push(i);
      s.insert({p[i].y, i});
  }
  ```

### 2. 7KByte（★★★★☆）
- **亮点**：代码规范，变量命名明确，注释辅助理解；
- **优化点**：提前终止统计，减少无效计算。

### 3. _LHF_（★★★☆☆）
- **亮点**：理论复杂度O(n log a)，但常数较大；
- **不足**：分块实现复杂，代码可读性较低。

---

## 最优思路与技巧
1. **坐标转换**：曼哈顿→切比雪夫简化距离计算；
2. **滑动窗口+有序集合**：双指针维护x范围，`multiset`维护y范围；
3. **二分剪枝**：统计过程中若点数≥k立即返回，减少无效计算；
4. **离散化优化**：部分题解使用离散化+主席树处理大规模数据。

---

## 同类题目推荐
1. [P1429 平面最近点对（加强版）](https://www.luogu.com.cn/problem/P1429)
2. [P7883 平面最近点对（分治）](https://www.luogu.com.cn/problem/P7883)
3. [P2093 [国家集训队] JZPFAR](https://www.luogu.com.cn/problem/P2093)

---

## 可视化与算法演示

### 动画设计
1. **坐标转换展示**：
   - 初始点以曼哈顿坐标系显示，点击按钮后动态转换为切比雪夫坐标系。
2. **二分过程**：
   - 显示当前二分区间`[l, r]`，用红色高亮`mid`值；
   - 成功缩小区间时播放上升音效，失败时播放下降音效。
3. **滑动窗口操作**：
   - 用绿色框表示当前窗口的x范围`[x_i-d, x_i]`；
   - 红色箭头表示双指针移动，旧点移出窗口时变灰。
4. **集合查询**：
   - `multiset`以平衡树形式显示，查询`[y_i-d, y_i+d]`时高亮相关节点；
   - 找到有效点对时，两点间显示黄色连线并计数+1。

### 复古像素风格
- **Canvas绘制**：
  - 点坐标映射到16x16像素网格，用不同颜色区分已扫描/未扫描点；
  - 滑动窗口用8位风格绿色边框，移动时有“滋滋”音效。
- **音效设计**：
  - 背景音乐：FC风格的循环旋律；
  - 有效点对计数时播放短促“叮”声，达到k时播放胜利音效。

---

## 核心代码实现（hfjh题解）
```cpp
bool check(ll d) {
    multiset<Node> s;
    queue<int> q;
    int cnt = 0;
    for (int i = 1; i <= n; ++i) {
        // 维护x范围
        while (!q.empty() && p[i].x - p[q.front()].x > d) {
            s.erase(s.find({p[q.front()].y, q.front()}));
            q.pop();
        }
        // 查询y范围
        auto it = s.lower_bound({p[i].y - d, 0});
        while (it != s.end() && it->y <= p[i].y + d) {
            ans[++cnt] = max(abs(it->y - p[i].y), p[i].x - it->x);
            if (cnt >= k) return true;
            ++it;
        }
        q.push(i);
        s.insert({p[i].y, i});
    }
    return false;
}
```

---

## 个人心得摘录
- **hzoi_Shadow**：K-D树理论复杂度高，但数据较弱可通过，需注意常数优化；
- **lsj2009**：主席树实现时需同时递归两版本树，减少常数；
- **Daniel13265**：优先队列维护前k小需处理重复计数，仅保留奇数位结果。

---
处理用时：96.64秒
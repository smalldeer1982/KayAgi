# 题目信息

# [YsOI2022] 道路修建

## 题目背景

Ysuperman 正在给他幼儿园里的小朋友们准备一场模板测试，下面是一道模板题，他希望你可以帮他验一下题目。

## 题目描述

某地新建了 $n$ 座城市，拟定建造 $m$ 条**单向**道路，其中第 $i$ 条道路起点为 $u_i$，终点为 $v_i$，建造费用为正整数 $w_i$。

然而在道路开始修建之前突发紧急情况，需要马上选择这些道路中的一些来修建使得所有城市的人都可以走到某 $k$ 座城市中（也就是说，所有城市的人都可以走到这 $k$ 座城市中的**至少一座**城市中），你想要知道，如果这 $k$ 座城市是等概率随机在 $n$ 座城市中的选定的，那么期望的最小修建费用是多少。

为了避免分数输入输出，你只需要输出答案对 $998244353$ 取模的结果。

## 说明/提示

#### 样例 1 解释

总共有三种选定集合城市的方案：

1. 选定集合在城市 $1$，那么选择建造 $2\to 1,3\to 1$ 两条道路花费最少，为 $2+4=6$。

2. 选定集合在城市 $2$，那么选择建造 $1\to 2,3\to 1$ 两条道路花费最少，为 $1+4=5$。

3. 选定集合在城市 $3$，那么选择建造 $1\to 2,2\to 3$ 两条道路花费最少，为 $1+3=4$。

所以期望最小花费为 $(6+5+4)/3=5$。

#### 样例 2 解释

有 $6$ 种选择集合城市的方法：

1. 选城市 $1,2$，最小花费 $9$。

2. 选城市 $1,3$，最小花费 $6$。

3. 选城市 $1,4$，最小花费 $7$。

4. 选城市 $2,3$，最小花费 $5$。

5. 选城市 $2,4$，最小花费 $6$。

6. 选城市 $3,4$，最小花费 $3$。

所以期望最小花费为 $(9+6+7+5+6+3)\div 6=6$。

#### 样例 3 解释

这里太小写不下，只配个图算了：

![](https://cdn.luogu.com.cn/upload/image_hosting/cdnuoook.png)

#### 样例 4 解释

当集合城市选在 $1,2,3$ 时，城市 $4$ 无论如何都无法达到 $1,2,3$ 中的任意一个，所以答案为 $-1$。

#### 数据范围

对于 $10\%$ 的数据，满足 $n\le 15$，$m\le 30$。

对于 $30\%$ 的数据，满足 $n\le 20$，$m\le 50$。

另有 $5\%$ 的数据，满足所有 $w_i$ 相等。

另有 $5\%$ 的数据，满足 $k=n$。

另有 $5\%$ 的数据，满足 $k=n-1$。

另有 $10\%$ 的数据，满足 $m=n$。

另有 $20\%$ 的数据，满足 $k=1$。

对于 $100\%$ 的数据，满足 $2\le n\le 10^5$，$1\le m\le 2\times 10^5$，$1\le k\le n$，$1\le u_i,v_i\le n$，$0\le w_i\le 998244352$。

## 样例 #1

### 输入

```
3 4 1
1 2 1
2 1 2
2 3 3
3 1 4```

### 输出

```
5```

## 样例 #2

### 输入

```
4 6 2
1 2 1
1 3 3
2 3 2
3 4 5
4 1 4
4 2 6```

### 输出

```
6```

## 样例 #3

### 输入

```
8 16 3
5 6 7
7 2 10
4 6 4
5 7 5
8 4 12
1 3 8
2 3 6
4 1 8
1 7 2
8 3 1
2 5 3
6 4 11
7 3 14
3 8 9
8 1 13
6 7 16```

### 输出

```
160432162```

## 样例 #4

### 输入

```
4 1 3
2 4 1```

### 输出

```
-1```

# AI分析结果



---

**唯一算法分类**：朱刘算法变种与基环树分解

---

### **综合分析与结论**

#### **核心思路**
问题本质是**动态维护最小树形图结构**，结合**基环树缩点**处理环形依赖，并通过**组合数学**计算每条边的期望贡献。关键在于：

1. **最小出边基环树**：每个点保留最小出边形成基环树森林，若环上有选中节点则无需调整，否则需缩环并调整出边权值。
2. **动态缩点与边权偏移**：类似朱刘算法，对未覆盖的环进行缩点，合并出边并打标记记录边权偏移量。
3. **贡献概率计算**：利用组合数公式计算每条边在期望中的出现概率，通过逆元处理避免浮点误差。

#### **难点解析**
- **缩点与边权维护**：合并环内节点需高效管理出边集合，带懒标记的可并堆（如左偏树）支持整体边权调整。
- **无解判断**：若某缩点后的连通块大小与k之和超过n，则存在无法覆盖的情况。

#### **可视化设计**
- **基环树动态收缩**：用不同颜色标记基环树节点，缩点时显示环合并动画，边权数值实时更新。
- **可并堆操作**：以树状结构展示每个点的出边堆，合并时动态展开堆结构，突出最小边选择。
- **贡献计算面板**：实时显示当前边的选中概率与累计贡献，结合8-bit音效提示关键操作。

---

### **题解清单 (≥4星)**

#### **1kri 题解（4.5星）**
- **亮点**：基环树分析清晰，启发式合并优化时间复杂度。
- **关键代码**：并查集维护缩点，`set`合并边集，整体边权偏移。

#### **tobie 题解（5星）**
- **亮点**：朱刘算法改造精准，可并堆+懒标记实现高效边权调整，组合数学拆解贡献。
- **核心代码**：左偏树管理出边，缩点时合并堆并调整边权，贡献系数动态计算。

---

### **最优思路提炼**

1. **最小树形图动态调整**  
   每个点维护最小出边，缩环时继承环外边的边权差值，避免重复计算。

2. **可并堆与懒标记**  
   使用左偏树合并出边集合，`tag`数组记录边权偏移量，快速响应缩点后的整体调整。

3. **组合数逆元预计算**  
   预处理阶乘逆元，快速求取组合数概率，公式为：  
   \[
   \text{贡献} = \frac{\binom{n - |S_u|}{k}}{\binom{n}{k}} \times w
   \]

---

### **同类型题推荐**
1. **P4716**：最小树形图模板（朱刘算法）
2. **P6139**：基环树动态维护
3. **CF875D**：缩点+组合数学期望

---

### **代码核心实现**

```cpp
// 可并堆定义与合并
int Merge(int u, int v) {
    if (!u || !v) return u + v;
    pushdown(u), pushdown(v);
    if (val[u] > val[v]) swap(u, v);
    son[u][1] = Merge(son[u][1], v);
    if (dep[son[u][0]] < dep[son[u][1]]) swap(son[u][0], son[u][1]);
    return pushup(u), u;
}

// 动态缩点与贡献计算
for (int u = 1; u <= n; u++) {
    while (siz[rt[u]]) {
        int v = val[rt[u]].second;
        if (gettp(u) == gettp(v)) { pop(rt[u]); continue; }
        // 计算组合数贡献
        ans += C(n - siz1[gettp(u)], K) * val[rt[u]].first;
        // 缩点合并堆
        if (getfa(u) == getfa(v)) {
            int uu = gettp(v), d = val[rt[u]].first;
            pop(rt[u]); Add(rt[u], -d);
            // 合并环内堆并调整边权
            while (uu != u) {
                Add(rt[uu], -len[uu]);
                rt[u] = Merge(rt[u], rt[uu]);
                uu = gettp(nxt[uu]);
            }
            // 更新并查集
            while (uu != u) {
                siz1[u] += siz1[uu];
                bcj[uu] = tp[uu] = u;
                uu = gettp(nxt[uu]);
            }
        } else {
            // 更新父节点
            nxt[u] = gettp(v); len[u] = val[rt[u]].first;
            bcj[u] = v; break;
        }
    }
}
```

---

### **可视化与游戏化设计**

- **复古像素动画**：  
  - **基环树**：用8-bit色块表示节点，环收缩时播放像素爆炸特效。  
  - **边权显示**：动态数字滚动显示当前边权，调整时数值闪烁提示。  
  - **音效设计**：选中最小边时播放“哔”声，缩点时触发低音鼓点。

- **交互式演示**：  
  - **步进控制**：空格键逐帧执行缩点与堆合并。  
  - **自动模式**：AI自动选择最小边，速度可调（1x~5x）。  
  - **贡献面板**：右侧面板实时更新各边贡献值，高亮当前操作影响。

---

### **个人心得**
调试时需注意**懒标记下传顺序**，未及时`pushdown`会导致堆内元素错误。缩点后`gettp`需路径压缩，否则时间复杂度退化为线性。组合数计算时注意取模前转换为正数。

---
处理用时：98.25秒
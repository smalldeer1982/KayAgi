# 题目信息

# [HAOI2017] 供给侧改革

## 题目描述

你调查了某个产业近来 $n$ 个时期的供求关系平衡情况，每个时期的情况都用 $0$ 或 $1$ 中的一个数字来表示。于是这就是—个长度为 $n$ 的 $\texttt{01}$ 字符串 $S$。为了更好的了解这一些数据，你需要解决一些询问，我们令 $\text{data}(L,R)$ 表示：在字符串 $S$ 中，起始位置在 $[L,R]$ 之间的这些后缀之中，具有最长公共前缀的两个后缀的最长公共前缀的长度。

对于每一个询问 $L,R$，求：

$$ans = \sum_{L \leqslant i < R} \text{data}(i,R)$$

数据范围保证，串 $S$ 中的每一位都是在 $0$ 和 $1$ 之间随机产生的。

## 说明/提示

【数据规模与约定】

|数据点|$n$ 的规模|$Q$ 的规模|
|:-:|:-:|:-:|
|$1,2$|$\leqslant 20$|$\leqslant 20$|
|$3,4$|$\leqslant 100$|$\leqslant 100$|
|$5,6$|$\leqslant 5 \times 10^3$|$\leqslant 5 \times 10^3$|
|$7,8,9,10$|$\leqslant 10^5$|$\leqslant 10^5$|



对于所有的数据保证：$n \leqslant 10^5$，$Q \leqslant 10^5$，$1 \leqslant L < R \leqslant n$，$\texttt{01}$ 串随机生成。

## 样例 #1

### 输入

```
6 3
010110
2 5
1 6
1 2```

### 输出

```
4
6
0```

# AI分析结果



## 【唯一算法分类】
**Trie树+离线扫描线**

---

## 【题解思路与解决难点】

### **核心思路**
- **关键假设**：随机数据下，最长公共前缀（LCP）长度不超过40（概率上极小可能出现更长的LCP）。
- **核心算法**：对每个后缀的前40位建立Trie树，维护每个节点的最后一次出现位置。离线处理查询，按右端点排序后逐个插入后缀，统计贡献。
- **贡献计算**：对每个可能的LCP长度，统计其在查询区间内的出现次数。

### **解决难点对比**
1. **维护最近出现位置**：
   - **Pine的Trie**：插入后缀时，动态更新Trie节点的最后访问位置，并维护一个数组`o[i]`表示长度为i的LCP的最后出现位置。
   - **Farkas_W的预处理**：预处理`last`数组，记录每个位置i的前缀最大值，将贡献分段统计。
2. **高效处理贡献**：
   - **线段树优化**：`kernel_panic`的题解用线段树维护区间覆盖，二分更新位置，实现O(40n log n)复杂度。
   - **贪心分段统计**：多数题解通过维护单调递减的贡献区间，直接遍历长度统计贡献。

---

## 【题解评分 (≥4星)】

1. **Pine的Trie树解法（⭐⭐⭐⭐⭐）**
   - **亮点**：代码简洁，直接维护贡献数组，离线扫描线清晰。
   - **代码片段**：
     ```cpp
     void insert(R int x) {
         R int p = 0;
         for(int i=0; x+i<=n&&i+1<=40; ++i) {
             R int w = ch[x+i] - '0';
             if(!son[p][w]) son[p][w] = ++cnt;
             else {
                 o[i+1] = Max(o[i+1], fina[son[p][w]]);
                 fina[son[p][w]] = x;
             }
             p = son[p][w];
         }
     }
     ```
2. **Farkas_W的预处理+分段统计（⭐⭐⭐⭐⭐）**
   - **亮点**：预处理前缀最大值，利用单调性快速分段计算答案。
   - **代码片段**：
     ```cpp
     for(re i=47;i&&l<=r;i--)
     if(last[r][i]>=l){
         ans+=(last[r][i]-l+1)*i;
         l=last[r][i]+1;
     }
     ```
3. **FreeTimeLove的Trie+线段树（⭐⭐⭐⭐）**
   - **亮点**：线段树维护区间覆盖，逻辑严密，适合理解扫描线思想。
   - **代码片段**：
     ```cpp
     void upd(int l, int r, int d, int p = 1) {
         if(st[p].l == l && st[p].r == r) return t[p].upd(d);
         pushdown(p);
         if(r <= mid) upd(l, r, d, lch);
         else upd(l, mid, d, lch), upd(mid+1, r, d, rch);
         pushup(p);
     }
     ```

---

## 【最优思路提炼】
1. **随机性假设**：将LCP长度限制为40，大幅降低时间复杂度。
2. **Trie维护最近位置**：插入后缀时记录每个节点的最后出现位置，快速计算LCP。
3. **离线扫描线**：按右端点排序查询，逐个插入后缀，动态维护贡献。
4. **贡献分段统计**：对每个可能的LCP长度，贪心计算其在区间内的覆盖次数。

---

## 【类似题目推荐】
1. **P3808 【模板】AC自动机（简单版）**
   - **相似点**：利用Trie树处理多模式匹配。
2. **P4551 最长异或路径**
   - **相似点**：Trie树维护二进制位，贪心求最大值。
3. **P3966 [TJOI2013] 单词**
   - **相似点**：AC自动机结合扫描线统计贡献。

---

## 【可视化与算法演示】
### **核心动画设计**
1. **Trie插入过程**：
   - **像素风格**：每个Trie节点显示为8位机风格的方块，插入时路径高亮为黄色。
   - **音效**：插入节点时播放“哔”声，更新最后位置时播放“叮”声。
2. **贡献统计**：
   - **动态高亮**：对每个LCP长度，用不同颜色块标记其在查询区间内的覆盖范围。
   - **步进控制**：支持暂停/继续观察每个后缀插入后的贡献变化。
3. **复古UI**：
   - **Canvas网格**：Trie树节点布局为树状网格，当前操作节点闪烁红光。
   - **背景音乐**：8位芯片风格BGM循环播放。

### **交互示例**
```javascript
// 伪代码：Canvas绘制Trie插入
function drawTrie(node, depth) {
    ctx.fillStyle = node === current ? "#FF0000" : "#00FF00";
    ctx.fillRect(x, y, 20, 20); // 绘制节点
    if (node.lastPos > 0) {
        ctx.fillText(node.lastPos, x + 5, y + 15); // 显示最后位置
    }
}
```

---

## **代码核心实现**
```cpp
// Pine的Trie插入与贡献统计
void insert(int x) {
    int p = 0;
    for (int i=0; x+i<=n && i<40; ++i) {
        int w = s[x+i] - '0';
        if (!son[p][w]) son[p][w] = ++cnt;
        else {
            o[i+1] = max(o[i+1], last_pos[son[p][w]]);
            last_pos[son[p][w]] = x;
        }
        p = son[p][w];
    }
}

// 处理查询
for (int i=1; i<=Q; ++i) {
    while (T <= Q && q[T].r == i) {
        LL ans = 0;
        for (int len=40; len>=1; --len) {
            if (o[len] >= q[T].l) {
                ans += len * (o[len] - max(q[T].l-1, o[len+1]));
            }
        }
        ++T;
    }
    insert(i);
}
```

---
处理用时：74.88秒
# 题目信息

# [十二省联考 2019] 异或粽子

## 题目描述

小粽是一个喜欢吃粽子的好孩子。今天她在家里自己做起了粽子。

小粽面前有 $n$ 种互不相同的粽子馅儿，小粽将它们摆放为了一排，并从左至右编号为 $1$ 到 $n$。第 $i$ 种馅儿具有一个非负整数的属性值 $a_i$。每种馅儿的数量都足够多，即小粽不会因为缺少原料而做不出想要的粽子。小粽准备用这些馅儿来做出 $k$ 个粽子。

小粽的做法是：选两个整数数 $l$,  $r$，满足 $1 \leqslant l \leqslant r \leqslant n$，将编号在 $[l, r]$ 范围内的所有馅儿混合做成一个粽子，所得的粽子的美味度为这些粽子馅儿的属性值的**异或和**。（异或就是我们常说的 xor 运算，即 C/C++ 中的 `ˆ` 运算符或 Pascal 中的 `xor` 运算符）

小粽想品尝不同口味的粽子，因此它不希望用同样的馅儿的集合做出一个以上的
粽子。

小粽希望她做出的所有粽子的美味度之和最大。请你帮她求出这个值吧！

## 说明/提示

| 测试点 | $n$ | $k$ |
| :---------- | :---------- | :---------- |
| $1$, $2$, $3$, $4$, $5$, $6$, $7$, $8$ | $\leqslant 10^3$ | $\leqslant 10^3$ |
| $9$, $10$, $11$, $12$ | $\leqslant 5 \times 10^5$ | $\leqslant 10^3$ |
| $13$, $14$, $15$, $16$ | $\leqslant 10^3$ | $\leqslant 2 \times 10^5$ |
| $17$, $18$, $19$, $20$ | $\leqslant 5 \times 10^5$ | $\leqslant 2 \times 10^5$ |

## 样例 #1

### 输入

```
3 2
1 2 3```

### 输出

```
6```

# AI分析结果



**唯一算法分类**：可持久化Trie + 堆

---

### **题解思路与核心难点**

**问题转换**  
将原数组转为前缀异或和数组`sum[]`，问题转化为求所有`sum[i]^sum[j]`（i<j）的前k大值之和。

**核心算法**  
1. **可持久化Trie树**：  
   - 维护历史版本的前缀异或和，每个版本对应一个右端点  
   - 每个节点记录子树大小，支持快速查询第k大异或值  
2. **大根堆优化**：  
   - 初始时每个右端点插入其最大异或值  
   - 每次取出堆顶后，将对应右端点的次大值重新入堆  
3. **对称处理**：  
   - 将k扩大为2k，最终结果除以2，解决对称对重复计算问题  

**解决难点**  
- 动态维护不同右端点对应的候选左端点集合  
- 高效查询每个右端点对应的第k大异或值  

---

### **题解评分（≥4星）**

1. **qwaszx（5星）**  
   - 创新性提出将k翻倍处理对称对  
   - 代码简洁，仅用常规Trie实现  
   - 关键代码段：  
     ```cpp
     for(int i=0;i<=n;i++)q.push((Node){i,1,query(s[i],1)});
     while(k--)取出堆顶并插入次大值
     ```

2. **hsfzLZH1（4星）**  
   - 详细推导数学转换过程  
   - 提供两种解法：常规堆解法与O(n log²a)解法  
   - 核心代码段：  
     ```cpp
     query函数通过size判断走左右子树
     ```

3. **Owen_codeisking（4星）**  
   - 类似超级钢琴的框架清晰  
   - 可持久化Trie与堆结合实现  
   - 核心代码段：  
     ```cpp
     q.push(State(1,i,i))初始化最大区间
     ```

---

### **最优思路与技巧提炼**

**关键技巧**  
1. **前缀异或转换**：将区间问题转换为两数异或问题  
2. **堆维护候选集**：每次弹出最大值后维护次大候选  
3. **Trie子树标记**：通过size字段实现快速kth查询  

**代码实现要点**  
```cpp
// 可持久化Trie插入（维护size）
void insert(int& now,int pre,ll val,int bit=31){
    now=++tot; tree[now]=tree[pre];
    tree[now].size++; // 核心size维护
    if(bit<0) return;
    int d=(val>>bit)&1;
    insert(tree[now].ch[d],tree[pre].ch[d],val,bit-1);
}

// 查询第k大异或值
ll query(int now,ll x,int k){
    ll res=0;
    for(int bit=31;bit>=0;bit--){
        int d=(x>>bit)&1;
        if(size[tree[now].ch[!d]] >=k){ // 通过size判断路径
            res |= 1ll<<bit;
            now=tree[now].ch[!d];
        }else{
            k -= size[tree[now].ch[!d]];
            now=tree[now].ch[d];
        }
    }
    return res;
}
```

---

### **相似题目推荐**

1. **P2048 [NOI2010] 超级钢琴**  
   - 同类堆维护候选集思想

2. **P4735 最大异或和**  
   - 可持久化Trie经典应用

3. **P1631 序列合并**  
   - 多路归并思想类似堆维护过程

---

### **可视化设计思路**

**动画演示方案**  
1. **Trie树生长动画**：  
   - 每次插入新前缀和时，展示新节点创建路径  
   - 用绿色高亮当前插入路径，蓝色保留历史版本  

2. **堆操作可视化**：  
   - 展示堆中元素结构，用红色标记当前取出的最大值  
   - 每次弹出后显示对应右端点的次大值查询过程  

3. **异或值对比**：  
   - 对每个sum[j]展示其与历史sum[i]的二进制位对比  
   - 用闪烁效果强调产生最高位1的位置  

**复古像素风格实现**  
```javascript
// 示例：8位风格Trie节点绘制
function drawTrieNode(x,y,active){
    ctx.fillStyle = active ? '#FF5555' : '#5555FF';
    ctx.fillRect(x*32, y*32, 28, 28); // 32x32像素节点
    if(bit>=0){ // 绘制位标记
        ctx.fillStyle = '#FFFFFF';
        ctx.fillText(bit, x*32+12, y*32+20);
    }
}
```

---

### **代码实现（核心部分）**

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=5e5+5,M=N*33;

struct Trie{
    int ch[M][2],sz[M],rt[N],cnt;
    void insert(int pre,int &now,ll x){
        now=++cnt;
        int u=now;
        for(int i=31;i>=0;i--){
            int d=(x>>i)&1;
            ch[u][d]=++cnt;
            ch[u][!d]=ch[pre][!d];
            sz[u]=sz[pre]+1;
            pre=ch[pre][d];
            u=ch[u][d];
        }
        sz[u]=sz[pre]+1;
    }
    ll query(int l,int r,ll x,int k){
        ll res=0;
        for(int i=31;i>=0;i--){
            int d=(x>>i)&1;
            if(sz[ch[r][!d]]-sz[ch[l][!d]] >=k){
                res |= 1ll<<i;
                l=ch[l][!d], r=ch[r][!d];
            }else{
                k -= sz[ch[r][!d]]-sz[ch[l][!d]];
                l=ch[l][d], r=ch[r][d];
            }
        }
        return res;
    }
}T;

priority_queue<tuple<ll,int,int>> q;
ll sum[N],ans;

int main(){
    int n,k; scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++){
        scanf("%lld",sum+i);
        sum[i] ^= sum[i-1];
        T.insert(T.rt[i-1],T.rt[i],sum[i-1]);
        ll val = T.query(T.rt[0],T.rt[i],sum[i],1);
        q.emplace(val,i,1);
    }
    while(k--){
        auto [v,rk,r] = q.top(); q.pop();
        ans += v;
        if(rk < r){
            ll nv = T.query(T.rt[0],T.rt[r],sum[r],rk+1);
            q.emplace(nv,rk+1,r);
        }
    }
    printf("%lld\n",ans);
}
```

---
处理用时：86.93秒
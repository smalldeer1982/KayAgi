# 题目信息

# [北大集训 2021] 经典游戏

## 题目背景

CTT2021 D4T2

## 题目描述

某天，`C` 和 `K` 觉得很无聊，于是决定玩一个经典小游戏：

在一棵有 $n$ 个结点的有根树上，标号为 $i$ 的节点上有 $a_i$ 个棋子。游戏时玩家轮流操作，每次可以将任意一个节点 $u$ 上的一个棋子放置到任意一个点 $v \in U(u)$上，其中 $U(u)=subtree\{u\}\setminus\{u\}$ ，表示 $u$ 的子树内（不包含 $u$ 本身）的点组成的集合。不能进行操作者失败。

而 `C` 和 `K` 作为 `P**` 和 `T**` 的在读学生，这种一眼就能找出必胜策略的游戏实在是索然无味，于是两人觉得，每个人给自己一个特殊能力可能会比较有趣：

`C` 在开始游戏之前，**可以选择**将当前树的树根 $R$ 换到与 $R$ 相邻的任意一个点 $R^{\prime}$ 上。定义两个点相邻当且仅当这两个点有边直接相连。

`K` 在开始游戏之前，**必须选择**树上的一个节点，在上面加上一颗棋子。

`C` 和 `K` 决定玩 $m$ 局游戏。每局游戏的流程如下：

1. 游戏开始前，`C` 和 `K` 会商量好，先在标号为 $x$ 的节点上放上一个棋子，然后将树根设为 $y$。
2. 之后 `C` 可以选择是否发动特殊能力，`C` 决策完之后 `K` 可以选择是否发动特殊能力。
3. 特殊能力的决策结束后，会在这棵树上进行一局 `C` 先手、`K` 后手的游戏。游戏完成后会将树上棋子的状态**还原到流程 `1` 结束后的状态**。

`C` 觉得这个游戏可以出成一个简单题，于是他决定考考你：`C` 在每局游戏的第二步的时候，有多少种决策方式使得不管 `K` 如何进行特殊能力的操作，开始游戏时都存在**必胜策略**？两种决策方式不同，**当且仅当**两种决策**更换的树根** $R^{\prime}$ **不同**，或者**两者中仅有一个没有发动特殊能力**。


## 说明/提示

| 子任务分数 | $1\le n,m\le$ | $\max\{a_1,a_2,\dots,a_n\}\le$ |              特殊性质              |
| :--------: | :-----------: | :----------------------------: | :--------------------------------: |
|    $16$    |      $5$      |              $1$               |                 无                 |
|    $15$    |     $300$     |              $1$               |                 无                 |
|    $14$    |    $5000$     |             $10^9$             |                 无                 |
|    $13$    |   $100000$    |             $10^9$             |        保证给出的树是一条链        |
|    $12$    |   $100000$    |             $10^9$             | 保证给出的树存在一个点度数为 $n-1$ |
|    $11$    |   $100000$    |             $10^9$             |   保证 $m$ 次游戏初始给定根一致    |
|    $10$    |   $500000$    |             $10^9$             |                 无                 |
|    $9$     |   $1000000$   |             $10^9$             |                 无                 |




## 样例 #1

### 输入

```
0
5 2
1 2
1 3
2 4
2 5
1 0 1 0 1
2 2
4 4```

### 输出

```
2
1
```

## 样例 #2

### 输入

```
0
10 10
6 3
7 4
8 2
2 1
9 1
1 3
3 4
4 5
5 10
0 0 1 1 1 0 1 1 0 0 
8 3
2 3
7 10
7 3
6 7
8 5
9 8
2 10
5 4
3 9
```

### 输出

```
1
1
0
1
1
1
0
0
2
1
```

# AI分析结果



### 唯一算法分类
博弈论 + 树形动态规划 + 数据结构

---

### 综合分析与结论
**核心思路**：  
各题解均基于博弈论中的 SG 函数分析，将问题转化为以下两个核心条件：  
1. **SG 值计算**：每个节点 SG 值为其子树内的最大深度  
2. **胜负判定**：异或和 $S > \max SG$  

**解决难点**：  
1. **动态换根**：通过树形 DP 预处理每个节点为根时的 SG 值  
2. **区间异或维护**：利用树状数组处理子树异或操作  
3. **邻域查询优化**：使用 Trie 树批量处理轻儿子的异或比较  

**可视化设计**：  
- **树结构动画**：  
  - 高亮当前根节点 $y$ 及其相邻节点  
  - 用不同颜色标记重儿子（红色）和轻儿子（蓝色）  
  - 动态显示换根时 SG 值的变化路径  
- **异或值更新**：  
  - 展示树状数组的区间异或操作（如黄色高亮修改区间）  
  - 同步显示 Trie 树中插入/删除值的路径  

---

### 题解清单 (4星及以上)
1. **Licykoc（5星）**  
   - **亮点**：  
     - 长链剖分优化轻/重子树处理  
     - 树状数组 + Trie 树高效维护区间异或  
     - 代码结构清晰，预处理与查询分离  

2. **Alex_Wei（4星）**  
   - **亮点**：  
     - 字典树处理异或比较  
     - 轻儿子信息批量维护  
     - 代码短小精悍  

3. **CarroT1212（4星）**  
   - **亮点**：  
     - 详细分解博弈与数据结构步骤  
     - 树状数组全局异或标记优化  

---

### 核心代码实现（Licykoc 题解关键部分）
```cpp
// 树状数组维护区间异或
class fenwick {
private:
  int n;
  std::vector<T> tr;
public:
  void add(int l, int r, int x) {
    add(l, x); add(r + 1, x);
  }
  T qry(int x) { /* 单点查询 */ }
};

// Trie 树处理异或比较
class trie {
public:
  void insert(int i, int x) { /* 插入值 */ }
  int query(int i, int v, int x) { /* 查询大于 x 的数量 */ }
};

// 关键修改操作
void flip(int u) {
  if (to[u] == par[u]) { // 处理父节点方向
    subtree_modify(u, max[u], sec[u]);
  } else { // 处理重儿子方向
    subtree_modify(to[u], sec[u], max[u]);
  }
}
```

---

### 同类型题与扩展
1. **P3177 [HAOI2015] 树上染色**  
   - 相似点：树形 DP + 路径贡献计算  

2. **P2585 [ZJOI2006] 三色二叉树**  
   - 相似点：树形结构博弈分析  

3. **P4643 [国家集训队] 阿狸和桃子的游戏**  
   - 相似点：博弈论中的 SG 函数应用  

---

### 可视化与复古游戏化设计
**像素风格演示**：  
1. **树结构展示**：  
   - 用 8 位色块表示节点，根节点闪烁黄色  
   - 换根时显示红色箭头动画  

2. **异或操作动画**：  
   - 修改节点时播放 "beep" 音效  
   - 异或路径用绿色像素轨迹显示  

3. **自动演示模式**：  
   - 按 BGM 节奏自动换根和修改  
   - 积分系统：连续正确判定获得连击分  

**核心 JS 伪代码**：  
```javascript
class PixelTree {
  constructor() {
    this.canvas = document.createElement('canvas');
    this.nodes = {}; // 存储节点像素坐标
  }
  
  highlightNode(node, color) {
    // 用 8x8 像素块高亮节点
  }
  
  animateXor(path) {
    // 沿路径播放绿色像素动画
  }
}
```

---

**总结**：本题解综合博弈论分析与高效数据结构，通过长链剖分将复杂度优化至 $O(n \log n)$，其核心在于将树结构特性与异或操作巧妙结合。可视化设计可重点呈现换根时的动态影响与异或路径。

---
处理用时：62.90秒
# 题目信息

# [NOIP 2009 提高组] 潜伏者

## 题目描述

R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：

1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母 $\texttt{A}\sim\texttt{Z}$ 构成（无空格等其他字符）；
2. S 国对于每个字母规定了对应的密字。加密的过程就是将原信息中的所有字母替换为其对应的密字；
3. 每个字母只对应一个唯一的密字，不同的字母对应不同的密字。密字可以和原字母相同。

例如，若规定 $\tt A$ 的密字为 $\tt A$，$\tt B$ 的密字为 $\tt C$（其他字母及密字略），则原信息 $\tt ABA$ 被加密为 $\tt ACA$。

现在，小 C 通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小 C 希望能通过这条信息，破译 S 国的军用密码。小 C 的破译过程是这样的：扫描原信息，对于原信息中的字母 $x$（代表任一大写字母），找到其在加密信息中的对应大写字母 $y$，并认为在密码里 $y$ 是 $x$ 的密字。如此进行下去直到停止于如下的某个状态：

1. 所有信息扫描完毕，$\texttt{A}\sim\texttt{Z}$ 所有 $26$ 个字母在原信息中均出现过并获得了相应的密字；
2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现；
3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。

例：

如某条信息 $\tt XYZ$ 被翻译为 $\tt ABA$ 就违反了“不同字母对应不同密字”的规则。

在小 C 忙得头昏脑涨之际，R 国司令部又发来电报，要求他翻译另外一条从 S 国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。


## 说明/提示

【输入输出样例一说明】

原信息中的字母 $\tt A$ 和 $\tt B$ 对应相同的密字，输出 $\tt Failed$。

【输入输出样例二说明】

字母 $\tt Z$ 在原信息中没有出现，输出 $\tt Failed$。

NOIP2009 提高组第一题

## 样例 #1

### 输入

```
AA 
AB 
EOWIE

```

### 输出

```
Failed
```

## 样例 #2

### 输入

```
QWERTYUIOPLKJHGFDSAZXCVBN 
ABCDEFGHIJKLMNOPQRSTUVWXY 
DSLIEWO
```

### 输出

```
Failed 
```

## 样例 #3

### 输入

```
MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP
YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL
FLSO ```

### 输出

```
NOIP```

# AI分析结果



## 算法分类
模拟

---

## 题解分析与结论

### 核心算法流程
1. **建立双向映射**：维护密文到原文、原文到密文的双向映射关系，确保一一对应
2. **冲突检测**：遍历输入字符串时，若发现同一密文对应不同原文，或同一原文被不同密文映射则报错
3. **覆盖检测**：最终验证是否覆盖全部26个字母
4. **翻译输出**：按建立的有效映射转换目标字符串

### 解决难点对比
| 题解方案               | 关键数据结构               | 冲突检测方式                     | 覆盖检测方式               |
|------------------------|----------------------------|----------------------------------|----------------------------|
| 双向数组（zm/mz）      | 两个int[27]数组            | 同时检查两个方向的映射          | 遍历数组检查零值           |
| 双向map（mp/mq）       | 两个map<char,char>         | 插入前检查已有映射              | 维护计数器递减             |
| 单向map+vis集合        | map<char,char>+vis数组     | 仅检查密文到原文的单向映射      | 遍历vis数组检查全部为true  |
| set集合判重            | set记录已使用的原文        | 通过set.contains判重           | 检查map.size()是否26       |

### 可视化设计思路
**动画方案**：
1. 展示三行输入字符串的字符对应关系
2. 用双色箭头表示密文→原文、原文→密文的双向绑定
3. 冲突时红色闪烁提示矛盾字符对
4. 覆盖检测阶段用进度条显示已覆盖字母数
5. 最终翻译时逐个字符高亮转换过程

**复古像素风格**：
- 用16x16像素方块表示每个字母
- 成功映射显示绿色边框，冲突显示红色边框
- 背景音乐使用8-bit风格的循环旋律
- 关键操作音效：映射成功（清脆"滴"声），冲突（低沉"嘟"声）

---

## 高星题解推荐 (4★+)

### 1. CYJian（5★）
**亮点**：
- 双向map确保一一对应
- 提前判断长度不足的边界情况
- 代码结构清晰，注释明确

### 2. lianghuahua（4★）
**亮点**：
- set集合防止原文重复使用
- 明确的三个阶段处理流程
- 变量命名清晰易读

### 3. ShiYuXuan1234（4★）
**亮点**：
- 使用数组实现高效映射
- 注释详细说明检测逻辑
- 提前处理长度不足情况

---

## 最优代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

map<char, char> cipher_map; // 密文→原文
set<char> used_plain;       // 已使用的原文

int main() {
    string encrypted, original, target;
    cin >> encrypted >> original >> target;
    
    // 建立映射
    for (int i = 0; i < encrypted.size(); ++i) {
        char c = encrypted[i], p = original[i];
        // 冲突检测
        if ((cipher_map.count(c) && cipher_map[c] != p) || 
            (used_plain.count(p) && cipher_map[c] != p)) {
            cout << "Failed";
            return 0;
        }
        cipher_map[c] = p;
        used_plain.insert(p);
    }
    
    // 覆盖检测
    if (cipher_map.size() != 26 || used_plain.size() != 26) {
        cout << "Failed";
        return 0;
    }
    
    // 翻译输出
    for (char c : target) cout << cipher_map[c];
}
```

---

## 相似题目推荐
1. P1914 小书童——凯撒密码（字符移位加密）
2. P1598 垂直柱状图（字符频率统计）
3. P1308 统计单词数（字符串模式匹配）

---

## 可视化代码片段（Canvas动画）

```javascript
// 映射关系绘制
function drawMapping(canvasCtx, encrypted, original) {
    encrypted.split('').forEach((c, i) => {
        const x1 = 50 + (c.charCodeAt(0)-65)*10;
        const y1 = 100;
        const x2 = 50 + (original[i].charCodeAt(0)-65)*10;
        const y2 = 150;
        
        // 绘制箭头
        canvasCtx.beginPath();
        canvasCtx.moveTo(x1, y1);
        canvasCtx.lineTo(x2, y2);
        canvasCtx.strokeStyle = conflict ? 'red' : '#0f0';
        canvasCtx.stroke();
    });
}
```

---

## 关键思路总结
**核心技巧**：
1. 双向绑定检测：同时维护密文→原文、原文→密文的关系
2. 即时冲突检查：在建立映射时实时验证，避免后续遍历
3. 集合快速判重：使用set/hash结构实现O(1)复杂度检测

**易错点**：
- 未处理相同密文不同原文的情况
- 忽略原文到密文的逆向冲突检测
- 未验证是否覆盖全部26个字母

---
处理用时：63.51秒
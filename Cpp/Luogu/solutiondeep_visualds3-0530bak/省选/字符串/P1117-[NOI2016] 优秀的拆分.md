# 题目信息

# [NOI2016] 优秀的拆分

## 题目描述

如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  
例如，对于字符串 $ \texttt{aabaabaa} $ ，如果令 $\text{A}=\texttt{aab}$，$\text{B}=\texttt{a}$，我们就找到了这个字符串拆分成 $\text{AABB}$ 的一种方式。

一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  
比如我们令 $\text{A}=\texttt{a}$，$\text{B}=\texttt{baa}$，也可以用 $\text{AABB}$ 表示出上述字符串；但是，字符串 $\texttt{abaabaa}$ 就没有优秀的拆分。

现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。

以下事项需要注意：

1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。
2. 在一个拆分中，允许出现 $\text{A}=\text{B}$。例如 $\texttt{cccc}$ 存在拆分 $\text{A}=\text{B}=\texttt{c}$。
3. 字符串本身也是它的一个子串。

## 说明/提示

### 样例解释

我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。

第一组数据中，共有三个子串存在优秀的拆分：  
$S[1,4]=\texttt{aabb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{b}$；  
$S[3,6]=\texttt{bbbb}$，优秀的拆分为 $\text{A}=\texttt{b}$，$\text{B}=\texttt{b}$；  
$S[1,6]=\texttt{aabbbb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{bb}$。  
而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。

第二组数据中，有两类，总共四个子串存在优秀的拆分：  
对于子串 $S[1,4]=S[2,5]=S[3,6]=\texttt{cccc}$，它们优秀的拆分相同，均为 $\text{A}=\texttt{c}$，$\text{B}=\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  
对于子串 $S[1,6]=\texttt{cccccc}$，它优秀的拆分有两种：$\text{A}=\texttt{c}$，$\text{B}=\texttt{cc}$ 和 $\text{A}=\texttt{cc}$，$\text{B}=\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  
所以第二组数据的答案是 $3+2=5$。

第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。

第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。

我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：

| 测试点编号   | $n \leq$  | 特殊性质           |
| ------------ | --------- | ------------------ |
| $1 \sim 2$   | $300$     | $S$ 中所有字符相同 |
| $3 \sim 4$   | $2\,000$  | $S$ 中所有字符相同 |
| $5 \sim 6$   | $10$      |                    |
| $7 \sim 8$   | $20$      |                    |
| $9 \sim 10$  | $30$      |                    |
| $11 \sim 12$ | $50$      |                    |
| $13 \sim 14$ | $100$     |                    |
| $15$         | $200$     |                    |
| $16$         | $300$     |                    |
| $17$         | $500$     |                    |
| $18$         | $1\,000$  |                    |
| $19$         | $2\,000$  |                    |
| $20$         | $30\,000$ |                    |

## 样例 #1

### 输入

```
4
aabbbb
cccccc
aabaabaabaa
bbaabaababaaba
```

### 输出

```
3
5
4
7
```

# AI分析结果



**唯一算法分类**: 后缀数组 + 调和级数枚举

---

### **题解思路与核心分析**

#### **核心思路**
1. **问题转化**：将AABB拆分为两个AA结构，分别统计以每个位置结尾和开头的AA型子串数量`a[]`和`b[]`，最终答案为$\sum a[i] \cdot b[i+1]$。
2. **关键点枚举**：枚举AA的长度`len`，每隔`len`设置关键点。每个AA结构必定跨越两个相邻关键点。
3. **LCP与LCS计算**：通过预处理正反后缀数组的ST表，快速计算相邻关键点的最长公共前缀（LCP）和最长公共后缀（LCS）。
4. **差分数组优化**：利用差分记录区间贡献，避免暴力更新，时间复杂度降至$O(n \log n)$。

#### **解决难点**
- **高效查询LCP/LCS**：通过后缀数组的ST表实现$O(1)$查询。
- **区间贡献统计**：当`LCP + LCS ≥ len`时，确定合法区间并通过差分数组批量更新`a`和`b`。

---

### **最优思路提炼**
1. **后缀数组预处理**：构建正反两个后缀数组的ST表，支持快速查询任意两点的LCP和LCS。
2. **调和级数枚举**：枚举长度`len`，总复杂度为$O(n \log n)$。
3. **差分标记贡献**：将区间加减操作转化为差分数组的前缀和，降低时间复杂度。

---

### **代码核心实现**
```cpp
struct SA {
    char s[MAXN];
    int sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][LOG];
    // 构建后缀数组及ST表
    void build() { /* 基数排序等实现 */ }
    int query(int x, int y) {
        x = rk[x], y = rk[y];
        if (x > y) swap(x, y);
        x++;
        int k = log2(y - x + 1);
        return min(st[x][k], st[y - (1<<k) + 1][k]);
    }
} A, B; // 正反SA

int main() {
    // 预处理正反SA
    A.build(s); reverse(s); B.build(s);

    for (int len = 1; len <= n/2; ++len) {
        for (int i = len, j = i + len; j <= n; i += len, j += len) {
            int lcp = min(A.query(i, j), len);
            int lcs = min(B.query(n - i + 1, n - j + 1), len - 1);
            if (lcp + lcs < len) continue;

            // 差分更新a和b数组
            int l = j - lcs, r = j + lcp - 1;
            a[l]++; a[r + 1]--;
            l = i - lcs; r = i + lcp - len;
            b[l]++; b[r + 1]--;
        }
    }
    // 前缀和计算最终a和b
    for (int i = 1; i <= n; ++i) a[i] += a[i-1], b[i] += b[i-1];
    ll ans = 0;
    for (int i = 1; i < n; ++i) ans += a[i] * b[i+1];
    cout << ans << endl;
}
```

---

### **可视化设计**
1. **动画展示**：以像素风格展示关键点对`(i, i+len)`，动态绘制LCP（绿色）和LCS（蓝色）覆盖区域。
2. **颜色标记**：
   - 当前关键点对：红色高亮。
   - LCP/LCS重叠区：黄色填充，表示合法AA区间。
3. **差分更新过程**：以滑动条展示差分数组的区间加减，并通过颜色渐变显示前缀和结果。
4. **音效反馈**：执行关键操作时触发8-bit音效，如LCP查询成功时播放上升音调。

---

### **相似题目推荐**
1. **P3809 【模板】后缀排序** - 后缀数组基础应用。
2. **P3763 [TJOI2017]DNA** - 利用LCP进行字符串匹配。
3. **P2852 [USACO06DEC]Milk Patterns** - 后缀数组求重复子串。

---

### **总结与心得**
- **预处理重要性**：后缀数组预处理极大优化了LCP/LCS查询效率。
- **差分技巧**：将区间操作转化为差分，避免暴力更新，显著降低复杂度。
- **调试经验**：注意处理边界条件，如`len`的取值范围和反向字符串的处理。

---
处理用时：70.43秒
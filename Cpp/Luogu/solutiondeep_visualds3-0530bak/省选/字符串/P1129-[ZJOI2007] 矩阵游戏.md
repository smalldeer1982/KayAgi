# 题目信息

# [ZJOI2007] 矩阵游戏

## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。


## 样例 #1

### 输入

```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0
```

### 输出

```
No
Yes
```

# AI分析结果



# 题解分析与可视化设计

## 算法分类
**二分图匹配**

---

## 核心思路与难点分析
### 问题转化
将矩阵的 **行视为左部节点**，**列视为右部节点**，每个黑格子 `(i,j)` 建立行i到列j的边。通过交换行列操作等价于调整匹配关系，最终目标是找到n个互不冲突的匹配对（主对角线上每个点对应一个行-列匹配）。

### 算法要点
1. **匈牙利算法**：遍历每行寻找增广路，时间复杂度 O(n^3)
2. **Dinic网络流**：构建虚拟源汇点，边容量为1，最大流等于n时存在解
3. **关键证明**：交换行列操作不会改变最大匹配数，只需判断初始状态是否存在完美匹配

### 解决难点
- **思维跳跃**：如何将矩阵行列交换转化为图论模型
- **代码实现**：匈牙利算法中 `vis[]` 数组的时间戳优化（避免多次memset）
- **特殊处理**：多组数据时需重置链式前向星的 `head[]` 和 `tot` 指针

---

## 高星题解推荐 (≥4★)
### 1. Night_Aurora（★★★★★）
**亮点**：  
- 用图论语言严谨证明交换操作不影响最大匹配  
- 给出网络流建图思路与理论依据  
- 代码实现中采用前向星+时间戳优化

### 2. 俾斯麦（★★★★☆）
**亮点**：  
- 同时给出匈牙利与Dinic两种解法  
- 详细注释网络流代码，适合初学者  
- 使用 `clear()` 函数代替 memset 优化速度

### 3. cmwqf（★★★★☆）  
**亮点**：  
- 手绘二分图示意图直观展示匹配原理  
- 代码简洁，用邻接矩阵代替前向星  
- 强调初始化 `match[]` 的重要性

---

## 最优思路提炼
### 关键技巧
1. **时间戳优化**：用全局变量 `tim` 代替 `vis[]` 数组的多次memset
   ```cpp
   int vis[N], tim; // 每次DFS前 tim++
   if(vis[v] != tim) vis[v] = tim;
   ```
2. **链式前向星重置**：通过 `tot=1` 与 `head[]` 覆盖式初始化避免memset
3. **行列对称性**：只需构建左部（行）到右部（列）的单向边，匈牙利算法单向遍历

---

## 同类题目推荐
1. [P3386 二分图最大匹配](https://www.luogu.com.cn/problem/P3386)  
   **模板题**：匈牙利/Dinic直接应用
2. [P1963 变换序列](https://www.luogu.com.cn/problem/P1963)  
   **思维拓展**：字典序最小匹配
3. [P2764 最小路径覆盖问题](https://www.luogu.com.cn/problem/P2764)  
   **网络流应用**：Dinic求最小路径覆盖

---

## 可视化设计（像素风格演示）

### 算法流程动画
```javascript
// 伪代码示例：Canvas绘制关键步骤
class BipartiteAnimation {
  constructor(canvas) {
    this.ctx = canvas.getContext('2d');
    this.nodes = { left: [...], right: [...] }; // 行列节点坐标
    this.edges = [ {from:1, to:2}, ... ];        // 初始边集合
    this.matches = new Map();                   // 当前匹配关系
  }

  drawStep(u) {
    // 高亮当前行节点u为红色
    drawNode(u, '#FF4444');
    
    // 遍历邻接边：蓝色表示尝试边，绿色表示已匹配边
    this.edges.filter(e => e.from == u).forEach(e => {
      if (this.matches.get(e.to) === u) {
        drawEdge(e, '#44FF44', 3); // 绿色已匹配
      } else {
        drawEdge(e, '#4444FF', 2); // 蓝色尝试
      }
    });
    
    // 播放音效：尝试时短促"滴"，匹配成功时上扬音
    playSound(e.matched ? 'success' : 'try');
  }
}
```

### 交互设计
1. **像素风格**：  
   - 使用 16 色调色板，节点用 8x8 像素方块表示  
   - 边用虚线连接，匹配边加粗显示
2. **音效设计**：  
   - **尝试边**：8-bit 短音 `0x50` 频率  
   - **匹配成功**：三连音 `0x100 → 0x200 → 0x300`  
   - **失败提示**：长低音 `0x80` 持续 300ms
3. **AI自动演示**：  
   - 按匈牙利算法顺序自动遍历行节点  
   - 按空格键暂停/继续，方向键调整速度
4. **关卡积分**：  
   - 每正确匹配一行得 100 分  
   - 连续无回溯完成多行触发 2x 连击奖励

---

## 核心代码片段（匈牙利算法）
```cpp
int match[N], vis[N], ts;
bool dfs(int u) {
    for(int v : G[u]) {
        if(vis[v] == ts) continue;
        vis[v] = ts;
        if(!match[v] || dfs(match[v])) {
            match[v] = u;
            return true;
        }
    }
    return false;
}

bool check() {
    memset(match, 0, sizeof match);
    for(int i=1; i<=n; ++i) {
        ++ts; // 时间戳优化替代memset
        if(!dfs(i)) return false;
    }
    return true;
}
```

---

## 心得分录
- **lemir3**：  
  > 数组大小计算错误导致多次WA，开大数组后解决。初始化务必彻底！
- **Azuree**：  
  > 发现只需考虑行交换或列交换之一，极大简化问题理解。
- **大头冲锋车丶**：  
  > 行列交换本质是调整节点编号，二分图形态不变的理论突破点。

---
处理用时：76.56秒
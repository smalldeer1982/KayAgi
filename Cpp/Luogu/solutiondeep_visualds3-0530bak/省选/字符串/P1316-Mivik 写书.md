# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果



**唯一算法分类**：容斥原理

---

### **题解思路、算法要点与解决难点**

**核心思路**：
1. **问题转化**：计算所有可能字符串的复杂度总和，除以总情况数 $m^n$。
2. **容斥原理**：枚举每个子串的出现位置集合 $S$，通过容斥统计每个位置集合的贡献。
3. **并查集优化**：合并必须相同的字符位置，统计自由选择的块数，计算方案数 $m^{\text{块数}}$。
4. **时间复杂度**：$O(n^2 2^n)$，利用位运算和路径压缩优化实际运行效率。

**解决难点**：
- **重复子串的容斥**：通过枚举位置集合 $S$ 的奇偶性，避免重复计算子串贡献。
- **字符约束合并**：用并查集高效处理多个子串位置重叠时的字符一致性约束。

---

### **题解清单 (≥4星)**

1. **Huasushis (★★★★☆)**  
   - **亮点**：详细解释容斥思路，代码注释清晰，适合新手理解。
   - **核心代码**：枚举子串长度和出现位置，用并查集统计连通块数，容斥计算贡献。

2. **7KByte (★★★★☆)**  
   - **亮点**：代码简洁高效，利用位运算预计算优化，实际运行速度快。
   - **核心代码**：预处理掩码和并查集操作，快速合并字符约束。

3. **rainygame (★★★★☆)**  
   - **亮点**：实现逻辑清晰，结合位运算和并查集，适合快速实现。
   - **核心代码**：枚举子串位置集合，动态维护连通块并计算贡献。

---

### **最优思路或技巧提炼**

1. **容斥与位运算结合**  
   - 枚举子串出现的位置集合 $S$，通过 `__builtin_parity` 判断奇偶性，实现容斥的正负贡献。

2. **并查集合并字符约束**  
   - 对每个位置集合，合并必须相同的字符下标，统计连通块数 $K$，贡献为 $m^K$。

3. **期望的线性分解**  
   - 将总期望拆分为每个子串长度的独立贡献，逐项累加。

---

### **可视化与算法演示**

**动画设计**：
1. **像素化网格**：  
   - 用 Canvas 绘制 $n \times n$ 网格，每个格子表示字符位置，颜色标记连通块。
   - **高亮当前子串位置**：红色边框表示当前枚举的子串位置集合 $S$。
   - **连通块合并动画**：蓝色线条动态连接合并的字符位置。

2. **音效与交互**：  
   - **音效**：每次合并触发“哔”声，容斥贡献计算时播放“叮”声。
   - **自动演示**：按子串长度从小到大自动枚举，用户可暂停/调整速度。

3. **复古风格**：  
   - **8位调色板**：使用红、蓝、绿三色，背景为灰色网格。
   - **积分系统**：每正确合并一个连通块得 10 分，错误合并扣 5 分。

**核心代码片段（JS）**：
```javascript
// 并查集合并与动画
function merge(a, b) {
    const rootA = find(a);
    const rootB = find(b);
    if (rootA !== rootB) {
        fa[rootB] = rootA;
        playSound('merge'); // 播放合并音效
        drawConnection(a, b); // 绘制连接线
    }
}
```

---

### **同类型题或类似算法套路**

1. **容斥与组合计数**：如 [洛谷 P1450](https://www.luogu.com.cn/problem/P1450)，通过容斥处理硬币组合问题。
2. **并查集优化约束**：如 [洛谷 P1196](https://www.luogu.com.cn/problem/P1196)，合并集合处理复杂关系。
3. **期望线性性分解**：如 [洛谷 P4317](https://www.luogu.com.cn/problem/P4317)，逐位统计贡献。

---

### **个人心得摘录**

- **Huasushis**：  
  > “调试时发现并查集未正确合并，导致贡献计算错误。最终通过可视化每个连通块解决。”

- **7KByte**：  
  > “预处理掩码大幅优化速度，避免了重复计算位操作。”

---

### **推荐相似题目**

1. **P1491 集合位置**（容斥与组合计数）
2. **P2523 随机数生成器**（期望与容斥结合）
3. **P4929 字符串计数**（并查集与字符约束合并）

---

**总结**：本题通过容斥原理和并查集高效处理了子串重复贡献的问题，结合像素化动画和音效交互，可直观展示算法核心流程。

---
处理用时：70.49秒
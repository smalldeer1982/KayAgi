# 题目信息

# 不同子串个数

## 题目背景

因为 NOI 被虐傻了，蒟蒻的 YJQ 准备来学习一下字符串，于是它碰到了这样一道题：


## 题目描述

给你一个长为 $n$ 的字符串，求不同的子串的个数。

我们定义两个子串不同，当且仅当有这两个子串长度不一样或者长度一样且有任意一位不一样。

子串的定义：原字符串中连续的一段字符组成的字符串。


## 说明/提示

### 提示

请使用64位整数来进行输出。

### 数据规模与约定
- 对于 $30\%$ 的数据，保证 $n\le 1000$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，字符串中只有小写英文字母。


## 样例 #1

### 输入

```
5
aabaa```

### 输出

```
11```

## 样例 #2

### 输入

```
3
aba```

### 输出

```
5```

# AI分析结果



**唯一算法分类**: 后缀自动机（SAM）与后缀数组（SA）

---

### **综合分析与结论**

#### **核心算法思路**
1. **后缀数组（SA）**  
   核心思想：所有子串为所有后缀的前缀集合，总子串数为 $\frac{n(n+1)}{2}$。通过计算相邻后缀的最长公共前缀（LAP）即 `height` 数组，总重复子串数为 $\sum \text{height}[i]$，最终答案为总子串数减去重复部分。  
   **关键步骤**：基数排序求 `sa` 数组，线性求 `height` 数组。

2. **后缀自动机（SAM）**  
   核心思想：每个状态表示一组长度连续的子串，新增节点时动态累加贡献（`maxlen[u] - maxlen[fa[u]]`）。  
   **关键步骤**：构建 SAM 时维护节点分裂逻辑，直接累加每个新节点的贡献。

#### **解决难点对比**
- **SA**：需正确处理基数排序的优化实现和 `height` 数组的线性求解（利用 `h[i] ≥ h[i-1]-1` 性质）。  
- **SAM**：理解节点分裂的规则和父节点贡献的传递，动态维护答案的数学推导。

#### **可视化设计思路**
- **SA**：动画展示后缀排序过程，高亮 `sa` 数组元素，动态显示 `height` 数组的生成及对答案的贡献。  
- **SAM**：像素风格动画展示节点扩展过程，每次插入字符时新节点（绿色方块）与父节点（蓝色方块）的链接，累加贡献时显示数值变化。  
- **音效与交互**：节点创建时播放“叮”声，贡献累加时播放金币音效，步进控制支持手动插入字符或自动播放。

---

### **题解清单 (≥4星)**

1. **Rorschachindark 的 SAM 解法（★★★★★）**  
   - **亮点**：动态维护答案，无需拓扑排序或 DP，时间复杂度最优。  
   - **代码片段**：  
     ```cpp
     void Insert(int c) {
         // ... 分裂节点逻辑
         ans += len[q] - len[fa[q]]; // 直接累加贡献
     }
     ```

2. **Leap_Frog 的 SA 解法（★★★★☆）**  
   - **亮点**：代码紧凑，公式推导清晰，正难则反思想。  
   - **代码片段**：  
     ```cpp
     long long solve() {
         long long ans = 1ll * n * (n+1) / 2;
         for(int i=1; i<=n; ++i) ans -= h[rk[i]];
         return ans;
     }
     ```

3. **Oracle 的 SA 解法（★★★★☆）**  
   - **亮点**：逐项累加每个后缀的贡献，代码可读性高。  
   - **代码片段**：  
     ```cpp
     ll solve(int n) {
         ll ans = 0;
         for(int i=1; i<=n; i++) ans += n+1 - sa[i] - height[i];
         return ans;
     }
     ```

---

### **最优思路提炼**

#### **后缀自动机动态维护法**
- **核心技巧**：插入新字符时，直接计算新节点与父节点的长度差作为贡献。  
- **代码实现**：  
  ```cpp
  inline void Insert(int c) {
      int p = lst, np = lst = ++cnt;
      len[np] = len[p] + 1;
      // ... 分裂节点逻辑
      ans += len[np] - len[fa[np]]; // 核心贡献计算
  }
  ```

#### **后缀数组 Height 求和法**
- **核心公式**：  
  $$ \text{Ans} = \frac{n(n+1)}{2} - \sum_{i=1}^{n} \text{height}[i] $$

---

### **同类题目推荐**
1. **P3804 【模板】后缀自动机**  
   - **考察点**：SAM 的基本应用，统计子串出现次数。
2. **P3763 [TJOI2017] DNA**  
   - **考察点**：SA 求 LCP，处理近似匹配问题。
3. **P3975 弦论**  
   - **考察点**：SAM 扩展应用，求字典序第 k 小子串。

---

### **个人心得摘录**
- **调试教训**（珅肐）：计算 `height` 数组时需注意 `rk[i]` 的边界，否则会导致越界访问。  
- **优化技巧**（Rorschachindark）：动态维护答案避免后处理，减少代码复杂度和常数。

---

### **可视化与算法演示**

#### **SAM 动态维护动画设计**
- **像素风格**：  
  - 节点用 8x8 像素方块表示，颜色区分不同状态（绿色为新节点，蓝色为父节点）。  
  - 插入字符时，Canvas 绘制新边和节点，播放“像素音效”。  
- **交互控制**：  
  - **步进按钮**：逐字符插入，显示当前贡献值。  
  - **自动播放**：以固定速度展示 SAM 构建全过程。  

#### **关键 JavaScript 片段**
```javascript
// 伪代码：插入字符动画
function animateSAMInsert(c) {
    let newNode = createNode(c); // 创建新节点
    highlight(newNode, 'green'); // 高亮新节点
    playSound('ding'); // 播放音效
    let parent = findParentNode(newNode);
    drawEdge(parent, newNode); // 绘制边
    updateAnswerDisplay(newNode.contribution); // 更新答案
}
```

---

### **代码实现（SAM 动态维护法）**

```cpp
#include <bits/stdc++.h>
using namespace std;
struct Node { int len, fa, ch[26]; };
Node node[200005];
int lst = 1, cnt = 1;
long long ans;

void insert(int c) {
    int p = lst, np = lst = ++cnt;
    node[np].len = node[p].len + 1;
    for(; p && !node[p].ch[c]; p = node[p].fa) 
        node[p].ch[c] = np;
    if(!p) node[np].fa = 1;
    else {
        int q = node[p].ch[c];
        if(node[q].len == node[p].len + 1) node[np].fa = q;
        else {
            int nq = ++cnt;
            node[nq] = node[q];
            node[nq].len = node[p].len + 1;
            node[q].fa = node[np].fa = nq;
            for(; p && node[p].ch[c] == q; p = node[p].fa)
                node[p].ch[c] = nq;
        }
    }
    ans += node[np].len - node[node[np].fa].len; // 核心贡献计算
}

int main() {
    int n; string s;
    cin >> n >> s;
    for(char c : s) insert(c - 'a');
    cout << ans << endl;
    return 0;
}
```

---
处理用时：94.55秒
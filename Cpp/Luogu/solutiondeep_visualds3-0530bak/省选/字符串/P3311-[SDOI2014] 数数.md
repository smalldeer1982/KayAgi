# 题目信息

# [SDOI2014] 数数

## 题目描述

我们称一个正整数 $x$ 是幸运数，当且仅当它的十进制表示中不包含数字串集合 $s$ 中任意一个元素作为其子串。例如当 $s = \{22, 333, 0233\}$ 时，$233$ 是幸运数，$2333$、$20233$、$3223$ 不是幸运数。给定 $n$ 和 $s$，计算不大于 $n$ 的幸运数个数。

答案对 $10^9 + 7$ 取模。

## 说明/提示

#### 样例 1 解释

除了 $3, 13, 2, 12, 20, 14$ 以外，不大于 $20$ 的整数都是幸运数字。

#### 数据规模与约定

对于全部的测试点，保证：

$1 \leq n < 10^{1201}$，$1 \leq m \leq 100$，$1 \leq \sum_{i = 1}^m |s_i| \leq 1500$，$\min_{i = 1}^m |s_i| \geq 1$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。$n$ 没有前导 $0$，但是 $s_i$ 可能有前导 $0$。

## 样例 #1

### 输入

```
20
3
2
3
14```

### 输出

```
14```

# AI分析结果



### 算法分类
**AC自动机 + 数位动态规划**

---

### 题解思路与核心难点
**核心思路**：将禁止子串构建为AC自动机，通过数位DP在自动机上动态转移，确保每一步不触达危险节点（包含任意禁止子串的节点）。

**算法要点**：
1. **AC自动机构建**：插入所有禁止子串，构建fail指针并标记危险节点（节点自身或通过fail链能触达子串结尾的节点）。
2. **数位DP设计**：状态包含当前位数、AC自动机节点、是否受n的限制、是否有前导零。
3. **滚动数组优化**：用位运算滚动减少空间消耗（如 `f[i&1]`）。

**解决难点**：
- **前导零处理**：首位不能为0，但后续位可以包含0。需在状态中区分是否处于前导零阶段。
- **危险节点剪枝**：转移时跳过所有危险节点，避免生成非法数字。
- **数位限制处理**：分「严格小于n」和「等于n」两种情况进行转移。

---

### 题解评分（≥4星）
1. **George1123（⭐⭐⭐⭐⭐）**  
   滚动数组优化，状态定义清晰，AC自动机与数位DP结合紧密，代码结构简洁高效。

2. **JK_LOVER（⭐⭐⭐⭐）**  
   记忆化搜索实现数位DP，处理前导零逻辑巧妙，可读性强但空间消耗较高。

3. **Ebola（⭐⭐⭐⭐）**  
   状态压缩为二维数组，转移方程简洁，未处理前导零但通过初始化避免非法转移。

---

### 最优思路与技巧提炼
**关键优化点**：
1. **Fail链标记**：预处理时通过`fail`链将危险标记下放，避免每次转移时回溯检查。
2. **滚动数组**：仅保留当前位和上一位的DP状态，空间复杂度从`O(LEN*CNT)`降为`O(CNT)`。
3. **分层转移**：将数位DP拆分为「位数不足n」和「位数等于n」两部分，分别处理。

**代码片段（George1123的核心转移逻辑）**：
```cpp
for(int j=1;j<=cnt;j++){
    if(mk[j]) continue;
    if(f[(i-1)&1][j][0])
        for(int c=0;c<=9;c++)
            if(!mk[ch[j][c]])
                (f[i&1][ch[j][c]][0] += f[(i-1)&1][j][0]) %= mod;
    if(f[(i-1)&1][j][1])
        for(int c=0;c<=w[i]-'0';c++)
            if(!mk[ch[j][c]])
                (f[i&1][ch[j][c]][c==w[i]-'0'] += f[(i-1)&1][j][1]) %= mod;
}
```

---

### 同类题目推荐
1. **P4052 [JSOI2007]文本生成器**  
   AC自动机与DP结合，统计包含至少一个模式串的文本数。
2. **P2414 [NOI2011] 阿狸的打字机**  
   AC自动机与树状数组结合，处理多模式串匹配问题。
3. **P2292 [HNOI2004] L语言**  
   动态规划结合AC自动机，判断最长可理解前缀。

---

### 可视化与算法演示
**动画设计**：
1. **AC自动机构建**：  
   - 动态展示Trie树插入过程，红色高亮危险节点。
   - 逐步绘制fail指针（蓝色箭头），并标记危险传播路径。

2. **数位DP转移**：  
   - 网格视图：行表示数位，列表示AC自动机节点，颜色深浅表示DP值大小。
   - 当前操作高亮：黄色框标记正在处理的`(位,节点)`，绿色箭头表示合法转移。

**复古像素风格**：
- **8位音效**：转移时播放短促电子音，危险节点触发低沉警告音。
- **Canvas动画**：用16x16像素块表示自动机节点，数位滚动时显示二进制数字流。

**交互控制**：
- 步进按钮：单步执行数位DP转移，观察状态变化。
- 危险节点开关：隐藏/显示危险节点，直观对比剪枝效果。

---

### 个人心得摘录
> **George1123**调试时因未清空滚动数组导致WA，强调「滚动数组必须每次清空当前层」；  
> **JK_LOVER**通过记忆化搜索避免复杂边界判断，但指出Hack数据需特殊处理前导零；  
> **Ebola**在初始化时直接过滤首位0，简化后续逻辑。

---

### 核心代码实现
完整代码参考George1123的实现，核心函数如下：
```cpp
void dp() {
    // 初始化第一位
    for(int i=1;i<=w[1]-'0';i++)
        if(!mk[ch[1][i]]) (f[1][ch[1][i]][i==w[1]-'0'] += 1) %= mod;
    
    // 滚动数组处理后续位
    for(int i=2;i<=m;i++){
        memset(f[i&1],0,sizeof f[i&1]);
        // 处理前导零
        for(int j=1;j<=9;j++)
            if(!mk[ch[1][j]]) (f[i&1][ch[1][j]][0] += 1) %= mod;
        
        // 状态转移
        for(int j=1;j<=cnt;j++){
            if(mk[j]) continue;
            // 不受限转移
            if(f[(i-1)&1][j][0]) for(int c=0;c<=9;c++)
                if(!mk[ch[j][c]]) (f[i&1][ch[j][c]][0] += f[(i-1)&1][j][0]) %= mod;
            // 受限转移
            if(f[(i-1)&1][j][1]) for(int c=0;c<=w[i]-'0';c++)
                if(!mk[ch[j][c]]) (f[i&1][ch[j][c]][c==w[i]-'0'] += f[(i-1)&1][j][1]) %= mod;
        }
    }
    // 统计答案
    for(int i=1;i<=cnt;i++)
        if(!mk[i]) ans = (ans + f[m&1][i][0] + f[m&1][i][1]) % mod;
}
```

---
处理用时：72.84秒
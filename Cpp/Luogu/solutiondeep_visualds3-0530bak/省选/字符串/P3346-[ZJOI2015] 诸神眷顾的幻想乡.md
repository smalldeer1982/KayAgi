# 题目信息

# [ZJOI2015] 诸神眷顾的幻想乡

## 题目描述

幽香是全幻想乡里最受人欢迎的萌妹子，这天，是幽香的 $2600$ 岁生日，无数幽香的粉丝到了幽香家门前的太阳花田上来为幽香庆祝生日。

粉丝们非常热情，自发组织表演了一系列节目给幽香看。幽香当然也非常高兴啦。

这时幽香发现了一件非常有趣的事情，太阳花田有 $n$ 块空地。

在过去，幽香为了方便，在这 $n$ 块空地之间修建了 $n-1$ 条边将它们连通起来。

也就是说，这 $n$ 块空地形成了一个树的结构。

有 $n$ 个粉丝来到了太阳花田上。

为了表达对幽香生日的祝贺，他们选择了 $c$ 种颜色的衣服，每种颜色恰好可以用一个 $0$ 到 $c-1$ 之间的整数来表示。

并且每个人都站在一个空地上，每个空地上也只有一个人。

这样，整个太阳花田就花花绿绿了。幽香看到了，感觉也非常开心。

粉丝们策划的一个节目是这样的，选中两个粉丝 $A$ 和 $B$（$A$ 和 $B$ 可以相同），然后A所在的空地到B所在的空地的路径上的粉丝依次跳起来（包括端点）。

这样幽香就能看到一个长度为 $A$ 到 $B$ 之间路径上的所有粉丝的数目（包括 $A$ 和 $B$）的颜色序列。

一开始大家打算让任意两个粉丝（注意：$A,B$ 和 $B,A$ 是不同的，他们形成的序列刚好相反）都来一次。

但是有人指出这样可能会出现一些一模一样的颜色序列，会导致审美疲劳。

于是他们想问，在这个树上，一共有多少可能的不同的颜色序列幽香可以看到呢？

由于太阳花田的结构比较特殊，只与一个空地相邻的空地数量不超过 $20$ 个。

## 说明/提示

#### 数据规模与约定

- 对于 $15\%$ 的数据，$n\le2\times 10^3$。
- 另有 $5\%$ 的数据，所有空地都至多与两个空地相邻。
- 另有 $5\%$ 的数据，除一块空地与三个空地相邻外，其他空地都分别至多与两个空地相邻。
- 另有 $5\%$ 的数据，除某两块空地与三个空地相邻外，其他空地都分别至多与两个空地相邻。
- 对于 $100\%$ 的数据，$1\le n\le10^5$，$1\le c\le10$，$1 \leq u, v \leq n$。

## 样例 #1

### 输入

```
7 3
0 2 1 2 1 0 0
1 2
3 4
3 5
4 6
5 7
2 5```

### 输出

```
30```

# AI分析结果



# 算法分类  
**广义后缀自动机（GSAM）**

---

## 题解思路与核心难点  

### 核心思路  
**将树转换为多棵以叶子为根的Trie树，合并后构建广义SAM统计不同子串数**  
1. **路径拉直**：任意路径均可在某个叶子为根的树中被拉直为从上到下的路径  
2. **枚举叶子**：最多20个叶子，分别以每个叶子为根遍历整棵树  
3. **构建SAM**：动态插入或通过Trie树构建广义SAM，统计所有子串数量  

### 解决难点  
- **拐弯路径处理**：通过枚举叶子转化为单向路径  
- **重复子串合并**：广义SAM自动去重多棵Trie中的相同子串  
- **空间优化**：在线插入避免显式构建Trie，减少内存消耗  

---

## 最优题解（≥4星）  

### 辰星凌题解（⭐⭐⭐⭐⭐）  
- **亮点**：显式构建Trie树，离线BFS插入SAM，代码可读性极强  
- **关键代码**：  
  ```cpp
  void dfs(Re x,Re fa,Re fap){
      Re xp=T1.insert(fap,co[x]); // 插入Trie节点
      for(Re i=head[x],to;i;i=a[i].next)
          if((to=a[i].to)!=fa)dfs(to,x,xp);
  }
  ```

### kczno1题解（⭐⭐⭐⭐⭐）  
- **亮点**：在线动态插入SAM，无需构建Trie，空间效率更高  
- **关键代码**：  
  ```cpp
  void travel(int x,int from,int p){
      p=sam.ins(col[x],p); // 动态插入SAM
      for(int i=t[x];i;i=l[i].next)
          if((y=l[i].to)!=from)travel(y,x,p);
  }
  ```

### zcysky题解（⭐⭐⭐⭐）  
- **亮点**：明确指出广义SAM的重复插入问题，提供正确判断逻辑  
- **关键代码**：  
  ```cpp
  if(ch[last][c]){
      int q=ch[last][c]; // 判断节点是否存在
      if(len[p]+1==len[q])last=q; // 复用已有节点
  }
  ```

---

## 可视化算法演示  

### 动画设计  
1. **树遍历阶段**：  
   - 以不同颜色叶子为根，生成辐射状路径动画（红色高亮当前根）  
   - 路径节点以绿色渐变填充，展示遍历顺序  

2. **SAM构建阶段**：  
   - 展示状态转移图，新增节点时黄色闪烁  
   - 边权显示字符，节点显示`maxlen`和`link`指针  

3. **复古像素风格**：  
   - 使用16色调色板（深绿树节点、亮蓝SAM状态）  
   - 音效：插入节点时播放8-bit“滴”声，完成时播放胜利音效  

### 交互控制  
- **速度调节**：滑动条控制遍历和SAM构建速度（1x~10x）  
- **单步调试**：空格暂停/继续，方向键单步执行  
- **AI演示模式**：自动切换叶子根，展示完整流程  

---

## 同类型题目推荐  
1. [P3975] 弦论 - 后缀自动机统计第k小子串  
2. [P4081] Standing Out from the Herd - 多字符串本质不同子串  
3. [P5341] 甲苯先生和大中锋的字符串 - 广义SAM应用  

---

## 核心代码实现  

### 在线插入SAM（kczno1版）  
```cpp
struct SAM{
    int tot=1,link[N],len[N],tr[N][10];
    int ins(int c,int p){
        int q=tr[p][c];
        if(q && len[q]==len[p]+1) return q; // 判断是否复用
        int np=++tot; len[np]=len[p]+1;
        while(p && !tr[p][c]) tr[p][c]=np, p=link[p];
        if(!p) link[np]=1;
        else{ /* 分裂节点逻辑 */ }
        return np;
    }
};
```

---

## 结论  
**核心算法流程**：  
1. 枚举每个叶子节点作为根  
2. DFS遍历整棵树，动态插入字符到SAM  
3. 最终统计SAM中∑(len[i]-len[link[i]])  

**时间复杂度**：O(20n)，空间复杂度O(n*20*10)  
**关键优化**：在线插入避免显式Trie，复用已有SAM节点

---
处理用时：61.81秒
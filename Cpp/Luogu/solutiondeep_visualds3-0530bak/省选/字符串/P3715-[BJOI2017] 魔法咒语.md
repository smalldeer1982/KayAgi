# 题目信息

# [BJOI2017] 魔法咒语

## 题目描述

Chandra 是一个魔法天才。

从一岁时接受火之教会洗礼之后，Chandra 就显示出对火元素无与伦比的亲和力，轻而易举地学会种种晦涩难解的法术。这也多亏 Chandra 有着常人难以企及的语言天赋，让她能轻松流利地说出咒语中那些极其拗口的魔法词汇。

直到十四岁，开始学习威力强大的禁咒法术时，Chandra 才遇到了障碍。

根据火之魔法规则，禁咒的构成单位是 $N$ 个基本词汇。施法时只要凝聚精神力，说出一段用这些词语组成的长度恰好等于 $L$ 的语言，就能释放威力超乎想象的火法术。过去的魔法师们总结了几种表达起来最连贯的组合方式，方便施法者以最快语速完成法术。

但具有魔法和语言双重天才的 Chandra 不满足于这几种流传下来的禁咒，因为她可以毫无困难地说出普通人几乎不可能表达的禁咒语句。然而，在实际施法时，Chandra 发现有些自创禁咒念出后不但没有预期效果，反而会使自己的精神力迅速枯竭，十分难受。

这个问题令 Chandra 万分不解。她大量阅读典籍，到处走访魔法学者，并且不顾精神折磨一次又一次尝试新咒语，希望找出问题的答案。

很多年过去了，在一次远古遗迹探险中，Chandra 意外闯进了火之神艾利克斯的不知名神殿。根据岩土特征分析，神殿应该有上万年的历史，这是极其罕见的。Chandra 小心翼翼地四处探索，沿着魔力流动来到一间密室。她看见密室中央悬浮着一本书籍。在魔法保护下书籍状况完好。精通上古语言的 Chandra 读过此书，终于解开了多年的困惑。


禁咒法术之所以威力强大，是因为咒语借用了火之神艾利克斯的神力。这本书里记载了艾利克斯生平忌讳的 $M$ 个词语，比如情敌的名字、讨厌的植物等等。使用禁咒法术时，如果语言中含有任何忌讳词语，就会触怒神力而失效，施法者也一并遭受惩罚。

例如，若 `banana` 是唯一的忌讳词语，`an`、`ban`、`analysis` 是基本词汇，禁咒长度须是 $11$，则 `bananalysis` 是无效法术，`analysisban`、`anbanbanban` 是两个有效法术。注意：一个基本词汇在禁咒法术中可以出现零次、一次或多次；只要组成方式不同就认为是不同的禁咒法术，即使书写形式相同。

谜题破解，Chandra 心情大好。她决定计算一共有多少种有效的禁咒法术。

由于答案可能很大，你只需要输出答案模 $10 ^ 9 + 7$ 的结果。


## 说明/提示

【样例解释 1】

有效的禁咒法术共有 $14$ 种：`boom/bang/oo`，`oo/oo/oo/oo/oo`，`oo/oo/ooh/ooh`，`oo/ooh/oo/ooh`，`oo/ooh/ooh/oo`，`ooh/oo/oo/ooh`，`ooh/oo/ooh/oo`，`
ooh/ooh/boom`，`ooh/ooh/oo/oo`，`ooh/ooh/bang`，`ooh/bang/ooh`，`bang/oo/oo/oo`，`bang/ooh/ooh`，`bang/bang/oo`。

【样例解释 2】

有效的禁咒法术有 `a/ab`，`ab/a`，`aba` 共三种。注意，`ab/a` 和 `aba` 算成两种不同的禁咒法术。

【数据规模与约定】

本题一共有 $10$ 个测试点。

下表是每个测试点的数据规模和约定：

 ![](https://cdn.luogu.com.cn/upload/pic/5191.png) 

对于 $100\%$ 的数据，$1 \le N, M \le 50，1 \le L \le 10^8$，基本词汇的长度之和不超过 $100$，忌讳词语的长度之和不超过 $100$。保证基本词汇不重复，忌讳词语不重复。


## 样例 #1

### 输入

```
4 2 10
boom
oo
ooh
bang
ob
mo```

### 输出

```
14```

## 样例 #2

### 输入

```
3 1 3
a
ab
aba
aaa```

### 输出

```
3```

## 样例 #3

### 输入

```
3 1 14
ban
an
analysis
banana```

### 输出

```
15```

# AI分析结果



# 算法分类  
**动态规划 + AC自动机 + 矩阵快速幂**

---

## 题解思路与核心难点

### 核心思路
1. **AC自动机构建禁忌词汇**：将禁忌词汇构建为AC自动机，标记所有非法状态（包含禁忌词或其前缀）。
2. **动态规划设计**：`dp[i][j]`表示长度为`i`，在AC自动机状态`j`时的合法方案数。
3. **矩阵快速幂优化**：当`L`极大时，利用基本词汇长度不超过2的特性，将状态转移转化为矩阵乘法。

### 解决难点
- **禁忌词汇的高效匹配**：通过AC自动机快速判断拼接过程中是否触发禁忌词。
- **大范围L的处理**：对基本词汇长度为1/2的情况，构造包含两个时间步状态的转移矩阵，用快速幂加速计算。

---

## 题解评分与推荐（≥4星）

### 1. shadowice1984（⭐⭐⭐⭐⭐）  
- **亮点**：  
  - 详细推导矩阵构造过程，明确分块矩阵的物理意义（左上角为长度1转移，右上为长度2转移）。  
  - 代码中双重检查禁忌词标记（`ed[p] |= ed[failp]`），避免漏判。  
- **代码实现**：矩阵分块清晰，预处理`tran`数组优化转移。

### 2. Hoks（⭐⭐⭐⭐）  
- **亮点**：  
  - 将AC自动机状态压缩为有效结点，减少矩阵维度。  
  - 矩阵快速幂部分代码简洁，利用结构体封装运算。  
- **心得**：强调预处理`match`函数的重要性，避免重复计算。

### 3. arrow_king（⭐⭐⭐⭐）  
- **亮点**：  
  - 采用二维状态矩阵（`dp[i][j]`与`dp[i-1][j]`），通过`vec`向量合并状态。  
  - 可视化说明矩阵分块设计（类似斐波那契数列）。  
- **心得**：调试中发现`fail`树标记传递错误，修正后AC。

---

## 最优思路提炼

### 关键步骤
1. **AC自动机预处理**：构建禁忌词Trie图，标记所有非法节点（包含禁忌词或其前缀）。
2. **转移矩阵构造**：  
   - 若基本词汇长度为1，转移矩阵块`A12`记录状态转移。  
   - 若长度为2，转移矩阵块`A22`记录跨步转移。  
   - 左下角单位矩阵保留前一步状态。
   ```cpp
   // 矩阵结构示例（tot为有效状态数）
   Matrix G = {
     {A11, A12},  // A11全0，A12为长度1转移
     {I,   A22}   // I为单位矩阵，A22为长度2转移
   };
   ```
3. **快速幂计算**：初始向量`[dp0, dp1]`与矩阵`G^L`相乘，提取结果。

---

## 同类型题目推荐
1. **[BZOJ1009] GT考试**：KMP+矩阵快速幂，类似禁忌词匹配的计数问题。  
2. **[CF696D] Legen...**：AC自动机+矩阵优化，带权值的字符串计数。  
3. **[SPOJ GEN] Text Generator**：生成不包含禁忌词的随机文本计数。

---

## 可视化设计（复古像素风格）

### 动画演示
1. **AC自动机构建**：  
   - **像素网格**：每个节点用16x16像素方块表示，红色标记非法状态。  
   - **指针移动**：绿色方块沿Trie边移动，构建`fail`指针时显示红色连线。  
2. **矩阵快速幂**：  
   - **矩阵块高亮**：左上块（长度1转移）用蓝色，右上块（长度2）用绿色。  
   - **步进演示**：按空格键单步执行矩阵乘法，显示当前计算的行列位置。

### 音效与交互
- **音效**：  
  - 转移成功：8-bit“金币声”（0xAB合成音）。  
  - 触发禁忌词：短促“错误”音（方波降调）。  
- **自动模式**：点击“AI Run”后，算法自动播放，伴随芯片音乐背景。

---

## 核心代码片段

### AC自动机构建与转移预处理
```cpp
void build_ac() {
    queue<int> q;
    for (int c=0; c<26; c++) 
        if (trie[0][c]) q.push(trie[0][c]);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int c=0; c<26; c++) {
            int v = trie[u][c];
            if (v) {
                fail[v] = trie[fail[u]][c];
                ed[v] |= ed[fail[v]]; // 标记传递
                q.push(v);
            } else trie[u][c] = trie[fail[u]][c];
        }
    }
}
```

### 矩阵快速幂核心
```cpp
Matrix matrix_pow(Matrix a, int k) {
    Matrix res = Matrix::identity();
    while (k > 0) {
        if (k & 1) res = res * a;
        a = a * a;
        k >>= 1;
    }
    return res;
}

// 初始向量：[0时刻状态, 1时刻状态]
vector<int> dp = {1, 0, ..., 0}; 
Matrix trans = construct_transfer_matrix();
Matrix result = matrix_pow(trans, L);
int ans = sum(result[0][valid_states]);
```

---

## 总结
通过AC自动机处理禁忌词匹配，结合动态规划与矩阵快速幂，有效解决了大范围L的计数问题。核心在于状态转移的矩阵化与分块优化，适合作为AC自动机与DP结合的典型例题。

---
处理用时：70.72秒
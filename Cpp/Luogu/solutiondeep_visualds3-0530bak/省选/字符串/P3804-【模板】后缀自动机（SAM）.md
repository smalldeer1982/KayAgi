# 题目信息

# 【模板】后缀自动机（SAM）

## 题目描述

给定一个只包含小写字母的字符串 $S$。

请你求出 $S$ 的所有出现次数不为 $1$ 的子串的出现次数乘上该子串长度的最大值。


## 说明/提示

对于 $10 \%$ 的数据，$\lvert S \rvert \le 1000$。  
对于 $100\% $的数据，$1 \le \lvert S \rvert \le {10}^6$。

- 2023.7.30：添加一组 hack 数据。

## 样例 #1

### 输入

```
abab```

### 输出

```
4```

# AI分析结果



### 算法分类
后缀自动机 (Suffix Automaton, SAM)

---

### 题解思路与核心难点
1. **核心思路**  
   利用后缀自动机的性质，通过构建SAM将字符串的所有子串压缩为线性规模的节点。每个节点对应一个endpos等价类，记录最长子串长度`len`和出现次数`size`。通过parent树的后序遍历累加子树`size`，最终遍历所有节点计算`len * size`的最大值。

2. **算法要点**  
   - **SAM构造**：动态插入字符，维护转移边和parent链接。
   - **出现次数统计**：前缀节点初始标记`size=1`，通过DFS累加子树`size`。
   - **最大值计算**：遍历所有节点，筛选`size>1`的节点计算`len * size`。

3. **解决难点**  
   - **分裂节点处理**：当新插入字符导致endpos集合分裂时，需复制节点并调整转移边和parent链接。
   - **高效统计出现次数**：利用parent树的树形结构，通过一次DFS完成统计。

---

### 题解评分（≥4星）
1. **Hatsune_Miku (5星)**  
   - **亮点**：理论推导完整，结合图示详细解释SAM构造过程，适合初学者理解。
   - **代码实现**：结构体清晰，注释详细，便于移植。

2. **KesdiaelKen (4星)**  
   - **亮点**：用通俗语言讲解SAM的parent树性质，强调出现次数的统计逻辑。
   - **实现细节**：通过DFS遍历parent树，代码简洁高效。

3. **shadowice1984 (4星)**  
   - **亮点**：代码实现高度优化，结构体紧凑，适合竞赛快速编写。
   - **优化点**：利用递归DFS统计子树大小，逻辑清晰。

---

### 最优思路与技巧
1. **关键技巧**  
   - **动态维护SAM**：每次插入字符时，通过跳转parent链处理转移边和分裂节点。
   - **parent树统计**：利用树形结构累加出现次数，避免显式存储endpos集合。

2. **代码片段**  
   ```cpp
   void insert(int x) {
       int u = ++idcnt, p = lst, v = s[x] - 'a';
       a[u].len = a[lst].len + 1;
       while (p && !a[p].ch[v]) a[p].ch[v] = u, p = a[p].fa;
       if (!p) a[u].fa = 1;
       else {
           int q = a[p].ch[v];
           if (a[q].len == a[p].len + 1) a[u].fa = q;
           else {
               int nq = ++idcnt;
               a[nq] = a[q], a[nq].len = a[p].len + 1;
               a[q].fa = a[u].fa = nq;
               while (p && a[p].ch[v] == q) a[p].ch[v] = nq, p = a[p].fa;
           }
       }
       size[u] = 1; // 标记前缀节点
       lst = u;
   }
   ```

---

### 同类题目推荐
1. [P3975 [TJOI2015] 弦论](https://www.luogu.com.cn/problem/P3975)  
   （统计第k小子串，需结合SAM与动态规划）

2. [P4070 [SDOI2016] 生成魔咒](https://www.luogu.com.cn/problem/P4070)  
   （动态维护不同子串数量，SAM应用）

3. [SP1811 LCS - Longest Common Substring](https://www.luogu.com.cn/problem/SP1811)  
   （求两字符串最长公共子串，SAM经典应用）

---

### 可视化与算法演示
**动画设计**：
1. **像素风格界面**：  
   - **颜色方案**：8位色（绿：正常节点，红：分裂节点，蓝：parent边）。
   - **Canvas网格**：节点用方块表示，边用箭头连接，字符标注在边上。

2. **关键步骤高亮**：
   - **插入字符**：显示新节点`u`生成，parent链跳转（黄色闪烁）。
   - **分裂节点**：复制`q`为`nq`，调整转移边时红色高亮。
   - **DFS统计**：遍历parent树时，当前节点绿色填充，子树渐变色扩散。

3. **音效交互**：
   - **节点创建**：短促“哔”声（Web Audio API生成方波）。
   - **分裂发生**：低音“咚”声提示复杂度变化。
   - **统计完成**：8-bit胜利音效。

**控制面板**：
```html
<button onclick="togglePause()">⏯</button>
<input type="range" id="speed" min="1" max="10" value="5">
<div id="counter">Size: 0</div>
<canvas id="samCanvas"></canvas>
```

---

### 核心代码实现
```cpp
struct Node {
    int len, fa;
    map<char, int> ch;
} sam[N];
int lst = 1, cnt = 1, size[N];

void insert(char c) {
    int p = lst, np = lst = ++cnt;
    sam[np].len = sam[p].len + 1;
    size[np] = 1;
    for (; p && !sam[p].ch[c]; p = sam[p].fa)
        sam[p].ch[c] = np;
    if (!p) sam[np].fa = 1;
    else {
        int q = sam[p].ch[c];
        if (sam[q].len == sam[p].len + 1)
            sam[np].fa = q;
        else {
            int nq = ++cnt;
            sam[nq] = sam[q], sam[nq].len = sam[p].len + 1;
            sam[q].fa = sam[np].fa = nq;
            for (; p && sam[p].ch[c] == q; p = sam[p].fa)
                sam[p].ch[c] = nq;
        }
    }
}

long long ans = 0;
vector<int> g[N];
void dfs(int u) {
    for (int v : g[u]) {
        dfs(v);
        size[u] += size[v];
    }
    if (size[u] > 1)
        ans = max(ans, 1LL * size[u] * sam[u].len);
}

int main() {
    string s; cin >> s;
    for (char c : s) insert(c);
    for (int i = 2; i <= cnt; i++)
        g[sam[i].fa].push_back(i);
    dfs(1);
    cout << ans << endl;
}
```

---

### 个人心得
- **调试陷阱**：分裂节点时需确保复制所有转移边，否则漏边导致DFS统计错误。
- **优化经验**：使用`map`存储转移边虽灵活，但改为`array`可提速（需固定字符集）。
- **思维突破**：parent树的本质是endpos包含关系的层级结构，理解此点后统计逻辑豁然开朗。

---
处理用时：83.84秒
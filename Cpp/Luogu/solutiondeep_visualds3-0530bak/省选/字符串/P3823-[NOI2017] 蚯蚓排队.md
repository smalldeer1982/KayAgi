# 题目信息

# [NOI2017] 蚯蚓排队

## 题目描述

蚯蚓幼儿园有 $n$ 只蚯蚓。幼儿园园长神刀手为了管理方便，时常让这些蚯蚓们列队表演。

所有蚯蚓用从 $1$ 到 $n$ 的连续正整数编号。每只蚯蚓的长度可以用一个正整数表示，根据入园要求，所有蚯蚓的长度都不超过 $6$ 。神刀手希望这些蚯蚓排成若干个队伍，初始时，每只蚯蚓各自排成一个仅有一只蚯蚓的队伍，该蚯蚓既在队首，也在队尾。

神刀手将会依次进行 $m$ 次操作，每个操作都是以下三种操作中的一种：

1. 给出 $i$ 和 $j$ ，令 $i$ 号蚯蚓与 $j$ 号蚯蚓所在的两个队伍合并为一个队伍，具体来说，令 $j$ 号蚯蚓紧挨在 $i$ 号蚯蚓之后，其余蚯蚓保持队伍的前后关系不变。

2. 给出 $i$ ，令 $i$ 号蚯蚓与紧挨其后的一只蚯蚓分离为两个队伍，具体来说，在分离之后， $i$ 号蚯蚓在其中一个队伍的队尾，原本紧挨其后的那一只蚯蚓在另一个队伍的队首，其余蚯蚓保持队伍的前后关系不变。

3. 给出一个正整数 $k$ 和一个长度至少为 $k$ 的数字串 $s$ ，对于 $s$ 的每个长度为 $k$ 的连续子串 $t$ （这样的子串共有 $|s|-k+1$ 个，其中 $|s|$ 为 $s$ 的长度），定义函数 $f(t)$，询问所有这些 $f(t)$ 的**乘积**对 $998244353$ 取模后的结果。其中 $f(t)$ 的定义如下：

对于当前的蚯蚓队伍，定义某个蚯蚓的**向后 $k$ 数字串**为：从该蚯蚓出发，沿队伍的向后方向，寻找最近的 $k$ 只蚯蚓（包括其自身），将这些蚯蚓的长度视作字符连接而成的数字串；如果这样找到的蚯蚓不足 $k$ 只，则其没有**向后$k$数字串**。例如蚯蚓的队伍为 $10$ 号蚯蚓在队首，其后是 $22$ 号蚯蚓，其后是 $3$ 号蚯蚓（为队尾），这些蚯蚓的长度分别为 $4$ 、 $5$ 、 $6$ ，则 $10$ 号蚯蚓的**向后 $3$ 数字串**为 `456`， $22$ 号蚯蚓没有**向后 $3$ 数字串**，但其**向后 $2$ 数字串**为 `56`，其**向后 $1$ 数字串**为 `5`。

而 $f(t)$ 表示所有蚯蚓中，**向后 $k$ 数字串**恰好为 $t$ 的蚯蚓只数。

## 说明/提示

保证 $n \leq 2 \times 10^{5}$，$m \leq 5 \times 10^{5}$，$k \leq 50$ 。

设 $\sum |s|$ 为某个输入文件中所有询问的 $s$ 的长度总和，则 $\sum |s| \leq 10^{7}$  。

设 $c$ 为某个输入文件中形如 `2 i` 的操作的次数，则 $c \leq 10^{3}$ 。

每个测试点的详细信息见下表：

| 测试点编号 | $n$ | $m$ | $k$ | $\sum \|s\|$ | $c$ | 全为 $\texttt{1}$ |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 1 | $=1$ | $\leq 10^{3}$ | $=1$ | $\leq 10^{3}$ | $=0$ | No |
| 2 | $\leq 20$ | $\leq 40$ | $\leq 10$ | $\leq 10^{3}$ | $=0$ | No |
| 3 | $\leq 150$ | $\leq 2,000$ | $\leq 50$ | $\leq 10^{3}$ | $\leq 10^{3}$ | No |
| 4 | $\leq 500$ | $\leq 600$ | $\leq 50$ | $\leq 10^{3}$ | $=0$ | No |
| 5 | $\leq 10^{3}$ | $\leq 2,000$ | $\leq 50$ | $\leq 10^{3}$ | $\leq 10^{3}$ | No |
| 6 | $\leq 5 \times 10^{4}$ | $\leq 6 \times 10^{4}$ | $\leq 5$ | $\leq 5 \times 10^{4}$ | $\leq 10^{3}$ | No |
| 7 | $\leq 5 \times 10^{4}$ | $\leq 6 \times 10^{4}$ | $\leq 50$ | $\leq 5 \times 10^{4}$ | $=0$ | Yes |
| 8 | $\leq 5 \times 10^{4}$ | $\leq 6 \times 10^{4}$ | $\leq 50$ | $\leq 5 \times 10^{4}$ | $=0$ | No |
| 9 | $\leq 5 \times 10^{4}$ | $\leq 6 \times 10^{4}$ | $\leq 50$ | $\leq 5 \times 10^{4}$ | $\leq 10^{3}$ | No |
| 10 | $\leq 5 \times 10^{4}$ | $\leq 8 \times 10^{4}$ | $\leq 50$ | $\leq 2.5 \times 10^{6}$ | $=0$ | No |
| 11 | $\leq 5 \times 10^{4}$ | $\leq 8 \times 10^{4}$ | $\leq 50$ | $\leq 2.5 \times 10^{6}$ | $\leq 10^{3}$ | No |
| 12 | $\leq 10^{5}$ | $\leq 1.1 \times 10^{5}$ | $\leq 6$ | $\leq 10^{5}$ | $\leq 10^{3}$ | No |
| 13 | $\leq 10^{5}$ | $\leq 1.1 \times 10^{5}$ | $\leq 50$ | $\leq 10^{5}$ | $=0$ | Yes |
| 14 | $\leq 10^{5}$ | $\leq 1.1 \times 10^{5}$ | $\leq 50$ | $\leq 10^{5}$ | $=0$ | No |
| 15 | $\leq 10^{5}$ | $\leq 1.1 \times 10^{5}$ | $\leq 50$ | $\leq 10^{5}$ | $\leq 10^{3}$ | No |
| 16 | $\leq 10^{5}$ | $\leq 1.5 \times 10^{5}$ | $\leq 50$ | $\leq 5 \times 10^{6}$ | $=0$ | No |
| 17 | $\leq 10^{5}$ | $\leq 1.5 \times 10^{5}$ | $\leq 50$ | $\leq 5 \times 10^{6}$ | $\leq 10^{3}$ | No |
| 18 | $\leq 2 \times 10^{5}$ | $\leq 5 \times 10^{5}$ | $=1$ | $\leq 10^{7}$ | $=0$ | No |
| 19 | $\leq 2 \times 10^{5}$ | $\leq 5 \times 10^{5}$ | $=1$ | $\leq 10^{7}$ | $\leq 10^{3}$ | No |
| 20 | $\leq 2 \times 10^{5}$ | $\leq 2.5 \times 10^{5}$ | $\leq 7$ | $\leq 2 \times 10^{5}$ | $\leq 10^{3}$ | No |
| 21 | $\leq 2 \times 10^{5}$ | $\leq 2.5 \times 10^{5}$ | $\leq 50$ | $\leq 2 \times 10^{5}$ | $=0$ | Yes |
| 22 | $\leq 2 \times 10^{5}$ | $\leq 2.5 \times 10^{5}$ | $\leq 50$ | $\leq 2 \times 10^{5}$ | $=0$ | No |
| 23 | $\leq 2 \times 10^{5}$ | $\leq 2.5 \times 10^{5}$ | $\leq 50$ | $\leq 2 \times 10^{5}$ | $\leq 10^{3}$ | No |
| 24 | $\leq 2 \times 10^{5}$ | $\leq 3 \times 10^{5}$ | $\leq 50$ | $\leq 10^{7}$ | $=0$ | No |
| 25 | $\leq 2 \times 10^{5}$ | $\leq 3 \times 10^{5}$ | $\leq 50$ | $\leq 10^{7}$ | $\leq 10^{3}$ | No |

如果一个测试点的“全为`1`”的一列为“Yes”，表示该测试点的所有蚯蚓的长度均为 1，并且所有询问串 $s$ 的每一位也均为`1`。

## 样例 #1

### 输入

```
5 9
3 1 3 5 3
3 333135 2
3 333135 1
1 1 3
1 2 5
1 3 2
1 5 4
3 333135 2
3 333135 1
3 333135 3```

### 输出

```
0
81
1
81
0```

## 样例 #2

### 输入

```
2 10
6 6
3 666666 1
1 1 2
3 666666 2
3 666666 4
3 666666666666666666666666666666 1
2 1
1 2 1
3 666666 2
3 666666 4
3 666666666666666666666666666666 1```

### 输出

```
64
1
0
75497471
1
0
75497471```

# AI分析结果



**唯一算法分类**：哈希

---

### **综合分析与结论**

#### **核心思路与难点**
1. **哈希与链表结合**：利用链表维护蚯蚓队伍的合并与分裂操作，每次操作仅需处理前后最多 $k$ 个节点，避免全局遍历。
2. **哈希表维护子串**：对每个可能的子串计算哈希值，使用哈希表统计出现次数。合并时新增跨链表的子串哈希值，分裂时删除。
3. **滚动哈希优化查询**：对输入的字符串 $s$，通过滚动哈希快速计算每个长度为 $k$ 的子串哈希值，并查询哈希表。

#### **算法流程可视化设计**
1. **链表操作动画**：
   - **合并**：高亮前链表末尾的 $k-1$ 个节点和后链表开头的 $k$ 个节点，生成跨链表的子串哈希值（用红色方块表示新增哈希键）。
   - **分裂**：用蓝色高亮断开点，删除跨链表的子串哈希值（用蓝色方块表示删除哈希键）。
2. **哈希表动态更新**：在动画中实时显示哈希表内每个键的计数变化，突出当前操作影响的哈希键。
3. **复古像素风格**：链表节点显示为8位像素方块，哈希表用网格表示，合并时播放“连接音效”，分裂时播放“断开音效”。

---

### **题解清单 (≥4星)**

1. **FunnyCreatress（⭐️⭐️⭐️⭐️⭐️）**
   - **亮点**：代码简洁，使用双哈希（模数哈希+自然溢出）减少冲突；通过预处理前后链表的哈希前缀，高效生成跨链表的子串。
   - **关键代码**：
     ```cpp
     for (int j=1,t=x; j<=50 && t; j++,t=pre[t]) 
         hs1[j] = (hs1[j-1] + l[t] * bas1[j-1]) % P;
     for (int j=1,t=y; j<=50 && t; j++,t=nxt[t]) 
         hs2[j] = (hs2[j-1] * 13 + l[t]) % P;
     ```

2. **Ameyax（⭐️⭐️⭐️⭐️）**
   - **亮点**：哈希表手写实现，避免STL性能问题；合并时直接遍历链表生成哈希值。
   - **关键代码**：
     ```cpp
     for (int i=1; i<=R; i++) g[i] = g[i-1] * p + f[i];
     for (int i=L; i<MAX_K; i++) 
         for (int j=MAX_K; j <= min(R, i+49); j++)
             hash.add(g[j] - g[i-1] * bin[j-i+1], 1);
     ```

3. **luobotianle（⭐️⭐️⭐️⭐️）**
   - **亮点**：使用 `gp_hash_table` 替代 `unordered_map` 解决TLE问题；代码结构清晰。
   - **关键代码**：
     ```cpp
     gp_hash_table<ull,ull> cnt;
     for (int i=k; i<=len; i++) {
         ans = ans * cnt[get_hash(i-k+1,i)] % mod;
     }
     ```

---

### **最优思路或技巧提炼**

1. **哈希分段预处理**：对合并/分裂点两侧的链表段预处理哈希前缀，快速生成跨链表子串的哈希值。
2. **双哈希防冲突**：结合模数哈希和自然溢出哈希，降低碰撞概率。
3. **滚动哈希优化**：在查询时通过滑动窗口计算子串哈希，避免重复计算。

---

### **同类型题或类似算法套路**

- **滑动窗口哈希**：如 [LeetCode 76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)。
- **链表操作与哈希结合**：如 [P1993 小K的农场](https://www.luogu.com.cn/problem/P1993)（维护动态关系）。
- **子串统计问题**：如 [P3370 字符串哈希](https://www.luogu.com.cn/problem/P3370)。

---

### **推荐题目**
1. **P3370**：练习哈希基础。
2. **P1993**：链表与动态维护。
3. **P2922 [USACO08DEC]Secret Message**：哈希与字典树结合。

---

### **个人心得摘录**
- **调试教训**：哈希表需手写或使用高效库（如 `gp_hash_table`），避免STL性能问题。
- **优化顿悟**：合并时仅处理前后各 $k$ 个节点，复杂度从 $O(nk^2)$ 降至 $O(k^2)$。

---

### **可视化与算法演示**

#### **核心算法动画**
1. **链表合并**：
   - **步骤**：前链表末尾（红色）与后链表开头（绿色）连接，生成跨链表的子串。
   - **动画**：红色节点与绿色节点间画箭头，显示生成的新哈希键（黄色方块）。
2. **哈希查询**：
   - **步骤**：输入字符串滚动哈希，每个子串哈希值在哈希表中高亮显示计数。
   - **动画**：字符串下方显示滑动窗口，当前哈希键在哈希表中闪烁。

#### **复古游戏化设计**
- **像素风格**：链表节点为8x8像素块，哈希表显示为16x16网格。
- **音效**：
  - **合并**：8-bit“连接”音效（短促高音）。
  - **分裂**：8-bit“断开”音效（低音）。
  - **查询成功**：胜利音效（上扬旋律）。

#### **代码片段（Canvas动画）**
```javascript
// 绘制链表节点（伪代码）
function drawNode(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y, 8, 8);
}

// 合并动画示例
function animateMerge(node1, node2) {
    playSound('merge_sound');
    drawNode(node1.x, node1.y, '#FF0000'); // 红色高亮前节点
    drawNode(node2.x, node2.y, '#00FF00'); // 绿色高亮后节点
    // 生成黄色哈希键动画...
}
```

---
处理用时：79.76秒
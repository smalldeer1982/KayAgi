# 题目信息

# [SDOI2016] 生成魔咒

## 题目描述

魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $1,2$ 拼凑起来形成一个魔咒串 $[1,2]$。

一个魔咒串 $S$ 的非空字串被称为魔咒串 $S$ 的生成魔咒。

例如 $S=[1,2,1]$ 时，它的生成魔咒有 $[1],[2],[1,2],[2,1],[1,2,1]$ 五种。$S=[1,1,1]$ 时，它的生成魔咒有 $[1],[1,1],[1,1,1]$ 三种，最初 S 为空串。  

共进行 $n$ 次操作，每次操作是在 $S$ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $S$ 共有多少种生成魔咒。


## 说明/提示

#### 数据规模与约定   
对于 $10\%$ 的数据，保证 $1 \le n \le 10$；  
对于 $30\%$ 的数据，保证 $1 \le n \le 100$；  
对于 $60\%$ 的数据，保证 $1 \le n \le 10^3$；   
对于 $100\%$ 的数据，保证 $1 \le n \le 10^5$，$1 \leq x_i \leq 10^9$。


## 样例 #1

### 输入

```
7
1 2 3 3 3 1 2```

### 输出

```
1
3
6
9
12
17
22```

# AI分析结果



# 【SDOI2016】生成魔咒 - 题解分析

## 算法分类
**后缀自动机 (SAM)**

---

## 题解思路与难点分析

### 核心思路
1. **增量计算贡献**  
   每次插入字符时，SAM新增节点 `np`，其贡献为 `len(np) - len(link(np))`，总答案累加此值。  
   - **关键推导**：SAM中每个状态代表一个等价类，其子串数量为 `maxlen - minlen +1`，其中 `minlen = maxlen(link(np)) +1`

2. **处理大字符集**  
   使用 `std::map` 存储转移边，避免离散化处理，支持动态插入新字符。

### 解决难点
- **动态维护本质子串数**：通过SAM的**在线构造**特性，每次插入字符后仅需处理新状态及其父节点。
- **大字符集处理**：利用`map`实现动态转移边，时间复杂度仍保持O(n log Σ)。

---

## 高星题解推荐 (≥4★)
1. **作者：skylee（5★）**  
   - **亮点**：代码极简，直接调用SAM模板，核心逻辑仅15行。
   - **代码片段**：
     ```cpp
     void extend(int c) {
         int p = last, np = ++cnt;
         len[np] = len[p] + 1;
         while (p && !ch[p].count(c)) ch[p][c] = np, p = link[p];
         if (!p) link[np] = 1;
         else {
             int q = ch[p][c];
             if (len[q] == len[p] + 1) link[np] = q;
             else { /* 分裂处理 */ }
         }
         ans += len[np] - len[link[np]];
         last = np;
     }
     ```

2. **作者：GoPoux4（4.5★）**  
   - **亮点**：完整注释，解释SAM状态贡献计算逻辑。
   - **心得**：强调`len[np]-len[link(np)]`的数学意义，帮助理解增量原理。

3. **作者：xht（4★）**  
   - **方法**：逆置字符串+后缀数组+set维护前驱后继。
   - **技巧**：逆序处理将后缀转化为前缀，通过ST表查询区间最小值更新贡献。

---

## 最优思路提炼
**后缀自动机增量构造法**
1. **构造过程**：每次插入字符生成新状态`np`，处理其父链接`link(np)`。
2. **贡献计算**：新增子串数为`len(np) - len(link(np))`，直接累加到总答案。
3. **大字符集处理**：使用`map`动态存储转移边，避免预处理离散化。

---

## 类似题目推荐
1. **[P3804 【模板】后缀自动机](https://www.luogu.com.cn/problem/P3804)**  
   **重点**：SAM基础构造与子串计数
2. **[P2408 不同子串个数](https://www.luogu.com.cn/problem/P2408)**  
   **重点**：静态字符串的本质不同子串统计
3. **[P3975 [TJOI2015]弦论](https://www.luogu.com.cn/problem/P3975)**  
   **重点**：SAM扩展应用，求第k小子串

---

## 可视化与算法演示
### 核心动画设计
**像素风格SAM构造演示**  
1. **状态节点**：用不同颜色方块表示状态，大小随`len`值变化。
2. **转移边**：箭头表示字符转移，点击节点展示其`map`存储的转移表。
3. **贡献高亮**：新增`np`时显示`len(np)-len(link(np))`的计算过程。

**交互功能**  
- **步进控制**：单步执行字符插入，观察状态分裂过程。
- **音效提示**：新增状态时播放清脆音效，分裂时触发双重音调。

### 复古风格实现
```javascript
// Canvas绘制示例（伪代码）
class StateNode {
  constructor(len, link) {
    this.x = randomPos(); 
    this.color = 8-bit色彩[len % 16];
    this.edges = new Map(); // 转移边
  }
}

function drawSAM() {
  ctx.fillStyle = '#2D2D2D'; // 复古深灰背景
  states.forEach(state => {
    drawPixelRect(state.x, state.y, state.color);
    state.edges.forEach((target, c) => {
      drawArrow(state, target, c);
    });
  });
}
```

---

## 关键代码片段（SAM核心）
```cpp
struct SAM {
    int len[N], link[N];
    map<int, int> ch[N];
    ll ans = 0;
    int last = 1, cnt = 1;

    void extend(int c) {
        int p = last, np = ++cnt;
        len[np] = len[p] + 1;
        while (p && !ch[p].count(c)) {
            ch[p][c] = np;
            p = link[p];
        }
        if (!p) link[np] = 1;
        else {
            int q = ch[p][c];
            if (len[q] == len[p] + 1) link[np] = q;
            else { // 分裂nq
                int nq = ++cnt;
                len[nq] = len[p] + 1;
                ch[nq] = ch[q];
                link[nq] = link[q];
                link[q] = link[np] = nq;
                while (ch[p][c] == q) ch[p][c] = nq, p = link[p];
            }
        }
        ans += len[np] - len[link[np]];
        last = np;
    }
};
```

---
处理用时：68.63秒
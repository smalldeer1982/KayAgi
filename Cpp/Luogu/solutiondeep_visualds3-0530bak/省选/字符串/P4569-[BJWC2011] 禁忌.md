# 题目信息

# [BJWC2011] 禁忌

## 题目描述

Magic Land上的人们总是提起那个传说：他们的祖先John在那个东方岛屿帮助Koishi与其姐姐Satori最终战平。而后，Koishi恢复了读心的能力……

如今，在John已经成为传说的时代，再次造访那座岛屿的人们却发现Koishi遇到了新麻烦。

这次她遇到了Flandre Scarlet——她拥有可以使用禁忌魔法而不会受到伤害的能力。

为了说明什么是禁忌魔法及其伤害，引入以下概念：

1. 字母集$A$上的每个非空字符串对应了一个魔法。其中$A$是包含了前alphabet个小写字母的集合。
2. 有一个集合$T$，包含了$N$个字母集$A$上的字符串。$T$中的每一串称为一个禁忌串（Taboo string）
3. 一个魔法，或等价地，其对应的串$s$因为包含禁忌而对使用者造成的伤害按以下方式确定：把$s$分割成若干段，考虑其中是禁忌串的段的数目，不同的分割可能会有不同的数目，其最大值就是这个伤害。

由于拥有了读心的能力，Koishi总是随机地使用Flandre Scarlet的魔法，可以确定的是，她的魔法正好对应字母集$A$上所有长度为$len$的串。

但是，Flandre Scarlet所使用的一些魔法是带有禁忌的，由于其自身特性，她可以使用禁忌魔法而不受到伤害，而Koishi就不同了。可怜的Koishi每一次使用对方的魔法都面临着受到禁忌伤害的威胁。

你现在需要计算的是如果Koishi使用对方的每一个魔法的概率是均等的，那么每一次随机使用魔法所受到的禁忌伤害的期望值是多少。

## 说明/提示

【样例1解释】
一共有$2^4 = 16$种不同的魔法。

需要注意的是“aabb”的禁忌伤害是1而不是2。

### 数据范围

有不少于40%的数据中：$N = 1$。  
100%的数据中$N ≤ 5$，$len ≤10^9$，$1 ≤ alphabet ≤ 26$。  
数据保证每个串$T_i$的长度不超过$15$，并且不是空串。  
数据保证每个$T_i$均仅含有前$alphabet$个小写字母。  
数据保证集合$T$中没有相同的元素，即对任意不同的$i$和$j$，有$T_i \neq T_j$。

## 样例 #1

### 输入

```
2 4 2
aa
abb```

### 输出

```
0.75
```

# AI分析结果



# 【算法分类】
AC自动机 + 矩阵快速幂优化动态规划

---

# 【题解思路与解决难点】

## 核心思路
1. **AC自动机构建**：将所有禁忌串构建成Trie树，通过fail指针处理后缀关系，标记所有能通过后缀匹配禁忌串的节点为终止节点。
2. **动态规划建模**：定义状态为当前匹配位置在AC自动机上的节点，通过字符转移计算伤害期望。
3. **矩阵快速幂优化**：将状态转移方程转化为矩阵乘法形式，利用快速幂高效处理大长度转移。

## 解决难点
- **贪心分割策略**：每次匹配到禁忌串（包括后缀匹配）时立即分割，回到根节点并累加伤害。
- **终止节点处理**：通过`bo[u] |= bo[fail[u]]`确保每个节点能检测到所有可能的后缀禁忌串。
- **矩阵维度设计**：新增虚拟节点用于累计期望值，将伤害统计融入矩阵乘法。

---

# 【题解评分 ≥4星】

### 1. lzx2005（★★★★★）
- **亮点**：完整注释，矩阵构造清晰，处理了fail指针的后缀影响，使用long double保证精度。
- **核心代码**：
  ```cpp
  // 构建转移矩阵时处理禁忌节点
  if(bo[ch[i][k]]) {
      a.mapp[i][1] += 1.0/al;
      a.mapp[i][tot+1] += 1.0/al;
  } else a.mapp[i][ch[i][k]] += 1.0/al;
  ```

### 2. Alex_Wei（★★★★☆）
- **亮点**：代码简洁，虚拟节点设计巧妙，矩阵快速幂部分优化到位。
- **代码片段**：
  ```cpp
  // 状态转移矩阵构建
  if(ed[v]) mat[i][0] += P, mat[i][sz+1] += P;
  else mat[i][v] += P;
  ```

### 3. jijidawang（★★★★☆）
- **亮点**：矩阵维度压缩至AC自动机节点数+1，代码精简，注释明确。
- **关键步骤**：
  ```cpp
  // 快速幂处理len次转移
  D ^= len; ans[0][0] = 1; D *= ans;
  ```

---

# 【最优思路提炼】
1. **AC自动机与后缀处理**：通过fail指针传递终止标记，确保贪心分割正确性。
2. **矩阵维度扩展**：新增虚拟节点累计期望，实现线性代数形式的动态规划。
3. **快速幂加速**：将O(n)长度的转移压缩至O(log n)次矩阵乘法。

---

# 【同类题型推荐】
1. **P3193 [HNOI2008]GT考试**（AC自动机+矩阵快速幂）
2. **P4052 [JSOI2007]文本生成器**（AC自动机+动态规划）
3. **P5337 [TJOI2019]甲苯先生的字符串**（矩阵快速幂优化字符串转移）

---

# 【个人心得摘录】
> "在构建AC自动机时，必须通过`bo[u] |= bo[fail[u]]`标记所有可能的后缀禁忌节点，否则会漏掉部分分割机会，这是贪心策略能正确的关键。" —— lzx2005

---

# 【可视化与算法演示】

## 动画设计
- **AC自动机结构**：以像素风格网格展示Trie树节点，红色标注终止节点。
- **状态转移过程**：用箭头表示字符转移，绿色高亮当前活跃节点，黄色标记回到根节点的重置操作。
- **矩阵乘法可视化**：用矩阵块表示概率转移，动态展示快速幂的倍增过程。

## 复古像素化实现
- **8位调色板**：根节点用蓝色，终止节点红色，虚拟节点紫色。
- **音效设计**：
  - **转移音效**：短促"哔"声（Web Audio API生成方波）
  - **伤害累计**：金币收集音效（8-bit风格）
- **自动演示模式**：按空格键逐步执行转移，长按加速播放。

```javascript
// 伪代码示例：Canvas绘制AC自动机节点
function drawNode(x, y, isEnd) {
  ctx.fillStyle = isEnd ? '#FF0000' : '#00FF00';
  ctx.fillRect(x*40, y*40, 32, 32);
  if (isEnd) ctx.fillText("★", x*40+12, y*40+20);
}
```

---

# 【核心代码实现】
以lzx2005的代码为例，关键部分：

```cpp
void bfs() { // 构建AC自动机
    for(int i=0; i<26; i++) ch[0][i]=1;
    queue<int> q; q.push(1);
    while(!q.empty()) {
        int u=q.front(); q.pop();
        bo[u] |= bo[net[u]]; // 关键：继承fail指针的终止标记
        for(int i=0; i<26; i++) {
            int v=net[u];
            while(!ch[v][i]) v=net[v];
            if(ch[u][i]) {
                net[ch[u][i]] = ch[v][i];
                q.push(ch[u][i]);
            } else ch[u][i]=ch[v][i];
        }
    }
}

void pre(matrix &a) { // 构造转移矩阵
    for(int u=1; u<=tot; u++) {
        for(int c=0; c<al; c++) {
            int v=ch[u][c];
            if(bo[v]) { // 禁忌节点：回根+统计
                a.mapp[u][1] += 1.0/al;
                a.mapp[u][tot+1] += 1.0/al;
            } else {
                a.mapp[u][v] += 1.0/al;
            }
        }
    }
    a.mapp[tot+1][tot+1] = 1.0; // 虚拟节点自环
}
```

---
处理用时：97.34秒
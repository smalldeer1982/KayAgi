# 题目信息

# PION后缀自动机

## 题目背景

NOIP2018原创模拟题T6

NOIP2018原创模拟赛DAY2 T3

NOIP DAY1 T3+ or DAY2 T3 难度

鉴于 NOIP2017 DAY2 T3 的难度，就有了这道题。**然而这道题考察的知识并不是后缀自动机**

## 题目描述

小P是一个技术高超的程序员，他开发了一套自己的操作系统，称为PION系统，该系统与Windows和Linux有很大不同，目前他正在测试该系统。

PION系统与Windows系统最大的不同在于文件的储存与操作，POIN的文件夹没有父子之分。我们知道，在Windows系统中，可以在文件夹里新建子文件夹。但是，PION系统文件夹不分父子关系，**但是部分文件夹之间可以互相直接访问，我们称这种关系为互访关系，而且，对于一个有$n$个文件夹的系统来说，这种互访关系有$n-1$个，且保证所有文件夹均可以通过互访关系而互相访问。也就是说：我们可以把Windows中的文件夹的集合看作一棵有根树，而把PION系统中的文件夹集合看作为无根树。**

在PION系统中，每个文件夹都可以储存文件，和Windows一样，文件名包含后缀名。

现在小P正在构思一种可以对文件夹中文件后缀进行方便操作的交互式程序dmc，他也将其称为**PION后缀自动机**。由于他太忙了，所以他希望你帮他实现**部分功能**。

他希望你帮他实现三个功能：

1.计算两个文件夹之间的距离。我们定义：文件夹之间的距离为其中一个文件夹通过互访达到另一个文件夹最少互访次数。比如：同一个文件夹距离为0，两个有互访关系的文件夹距离为1。

2.计算两个文件夹路径之间（包含这两个文件夹）的文件夹中的文件的后缀名为A的文件数量，**其中A是一个小写字符串。提示：我们可以把PION文件夹之间的路径理解为树中两节点之间的路径。**

3.删除两个文件夹路径之间（包含这两个文件夹）的文件夹中的文件的后缀名为A的文件，并统计被删除文件的数量。

由于dmc是一个交互系统，所以我们用tab语言描述这三个操作：

```
query /p u v
```

表示操作一，其中 u,v 表示两文件夹的编号

```
query /e u v *.A
```

表示操作二，其中 u,v 表示两文件夹的编号，$'*'$ 为通配符，$'.'$用于分隔文件名与后缀，**A是一个小写字符串**。

```
del /e u v *.A
```

表示操作三， $u,v, *.A$ 意义与操作二相同。

**如果没有看懂题目请结合样例及样例解释来理解。**

最后，这个困难的任务就交给你了。

## 说明/提示

**样例一解释：**

![T6](https://cdn.luogu.com.cn/upload/pic/34166.png)

如图为样例一大致结构，橙色方框为文件夹，灰色文字表示文件后缀名，红色线条表示文件互访关系。

对于第一个操作：文件夹1到5之间txt文件有3个所以输出3  
对于第二个操作：文件夹1与4距离为2  
对于第三个操作：删除的为文件夹2的文件，txt文件有两个，所以输出2  
对于第四个操作：由于文件夹2的txt文件被删除了，所以1到5之间txt文件只有1个  
对于第五个操作：文件夹3到4之间vbs文件有2个所以输出2

**数据范围：**

30%数据满足：$n,m<=100,k<=3$

50%数据满足：$n,m<=5000,k<=10$

70%数据满足：$n,m<=2 \times 10^4,k<=50$

90%数据满足：$n,m<=5 \times 10^4$

100%数据满足：$n,m<=10^5$，文件总数小于$5 \times 10^5$，文件后缀名为小写字符串且不超过6个字符

其他说明：

1.约50%的数据为完全随机生成

2.数据弱化版：[PION后缀自动机（数据弱化版）](https://www.luogu.org/problemnew/show/U41487)

## 样例 #1

### 输入

```
5 5
1 2
2 4
2 5
1 3
2 cpp c
3 pas txt txt
2 vbs bat
3 vbs cpp pas
4 cpp c pas txt
query /e 1 5 *.txt
query /p 1 4
del /e 2 2 *.txt
query /e 1 5 *.txt
query /e 4 3 *.vbs```

### 输出

```
3
2
2
1
2```

## 样例 #2

### 输入

```
12 7
1 2
1 3
1 4
2 5
2 6
3 7
7 12
8 4
8 9
10 9
11 9
0
2 c c
3 zz c c
0
1 gif
2 png bmp
3 avl avl mpshi
0
4 cpp c pas js
5 a b c d e
0
3 a b c
query /p 11 12
query /e 1 2 *.gif
query /e 6 10 *.c
del /e 2 9 *.c
del /e 3 12 *.c
query /e 5 6 *.gif
query /e 6 1 *.c```

### 输出

```
7
0
4
3
3
1
0```

# AI分析结果



## 算法分类
**树链剖分 + 动态开点线段树**

---

## 综合分析与结论

### 核心思路
1. **树链剖分预处理**：通过两次DFS划分重链，将树转化为线性结构，便于路径分解。
2. **动态开点线段树**：为每个文件后缀名动态创建线段树，避免预先分配所有可能后缀的空间。
3. **哈希映射**：将文件后缀名映射为唯一数值（如27进制哈希），解决字符串匹配问题。
4. **路径操作**：对路径上的每条重链分别进行线段树的区间查询或删除操作。

### 解决难点
- **多后缀处理**：通过动态开点线段树按需分配内存，避免空间爆炸。
- **路径分解**：利用树链剖分将任意路径分解为若干重链，将树上操作转化为区间操作。
- **高效字符串处理**：将字符串哈希为数值，避免频繁字符串比较。

### 可视化设计
1. **树结构绘制**：以像素风格绘制树形结构，用不同颜色区分重链。
2. **路径高亮**：当执行查询/删除操作时，将当前处理的重链标记为闪烁状态。
3. **线段树动态展示**：在屏幕右侧显示当前后缀对应的线段树结构，节点大小表示存储的文件数量。
4. **音效反馈**：
   - **路径分解**时播放短促电子音
   - **线段树更新**时触发“滴答”音效
   - **操作完成**时播放8-bit风格胜利音效

---

## 题解清单 (评分≥4星)

### 1. mrsrz (⭐⭐⭐⭐⭐)
- **亮点**：清晰的动态开点实现，高效哈希处理，完整处理LCA边界情况。
- **代码片段**：
  ```cpp
  void add(int&o,int l,int r,const int&pos){
    if(!o)o=++tot;
    ++d[o];
    if(l<r){
      const int mid=l+r>>1;
      if(pos<=mid)add(ls[o],l,mid,pos);else add(rs[o],mid+1,r,pos);
    }
  }
  ```

### 2. hzjnsy (⭐⭐⭐⭐)
- **亮点**：创新使用平衡树维护dfn序，空间效率更优。
- **关键技巧**：`__gnu_pbds::tree`实现有序集合的快速范围查询。

### 3. Milthm (⭐⭐⭐⭐)
- **亮点**：代码结构简洁，`unordered_map`实现直观的字符串映射。
- **注意点**：需处理哈希冲突可能性。

---

## 最优思路提炼

1. **哈希压缩**：将6字符内的小写字符串映射为`long long`型数值。
   ```cpp
   inline LL Hx(char*s,int n){
       LL ret=0,x=1;
       for(int i=2;i<n;++i,x*=27)
       ret+=(s[i]-'a'+1)*x;
       return ret;
   }
   ```
   
2. **路径分解模板**：
   ```cpp
   while(top[x]!=top[y]){
       if(dep[top[x]]>dep[top[y]]) swap(x,y);
       // 处理重链[top[y], y]
       y = fa[top[y]];
   }
   ```

3. **动态开点优化**：线段树节点按需创建，初始时只分配根节点。

---

## 类似题目推荐

1. **P3384** 【模板】树链剖分 - 基础树剖练习
2. **P5838** 旅行商问题 - 路径统计变形
3. **P1505** [国家集训队]旅游 - 路径修改/查询综合

---

## 关键代码实现

```cpp
// 树剖路径查询核心逻辑
int query(int o,int x,int y){
    int ret=0;
    while(top[x]!=top[y]){
        if(dep[top[x]]>dep[top[y]])
            ret += query(o,1,n,dfn[top[x]],dfn[x]), x=fa[top[x]];
        else
            ret += query(o,1,n,dfn[top[y]],dfn[y]), y=fa[top[y]];
    }
    if(dep[x]>dep[y]) swap(x,y);
    return ret + query(o,1,n,dfn[x],dfn[y]);
}
```

---

## 可视化示例 (伪代码)

```javascript
class PixelTree {
    constructor() {
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.nodeSize = 20;
    }

    drawNode(x, y, color) {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(x, y, this.nodeSize, this.nodeSize);
    }

    highlightPath(u, v) {
        // 实现路径闪烁动画
        let path = this.getPath(u, v);
        path.forEach(node => {
            this.drawNode(node.x, node.y, '#FF0000');
            setTimeout(() => this.drawNode(node.x, node.y, '#00FF00'), 200);
        });
    }
}
```

---

## 总结

本题综合运用树剖分解路径与动态数据结构，其核心在于**将复杂路径操作转化为线性区间操作**。通过哈希压缩字符串维度、动态分配存储资源，在时空效率间取得平衡。相似问题中，树剖+定制数据结构的组合具有普适性，值得深入掌握。

---
处理用时：71.78秒
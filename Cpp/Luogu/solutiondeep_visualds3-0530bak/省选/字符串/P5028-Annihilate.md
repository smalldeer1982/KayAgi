# 题目信息

# Annihilate

## 题目背景

前情提要：小正方形与黑暗之主展开了大战，最后小正方形击败了黑暗之主，成功从黑暗之主的手上夺下最后一个三角。

三角旋转着，净化着，正当三角即将净化完成时，黑暗之主突然到来，阻断了三角形的净化，吸收了三角的能量。

可是，因为三角的能量太过巨大，导致黑暗之主发生了变异，现在的黑暗之主一次次复制，最终成为了一条蜈蚣……

现在，小正方形还能阻止黑暗之主毁灭世界吗？

## 题目描述

黑暗之主的蜈蚣几乎可以毁灭一切，因此小正方形陷入了苦战……

小正方形现在需要减弱黑暗之主的攻击。

一个黑暗之主的攻击可以用一个仅有小写字母的字符串表示。

现在黑暗之主向小正方形发动了若干攻击，对于两个攻击，小正方形能选出它们最长的公共**子串**，并把这一段消除。

现在小正方形想要知道，对于**任意两个**黑暗之主的攻击，它们的最长公共子串长度是多少，你能帮帮它吗？

## 说明/提示

对于 $30\%$ 的数据，$n <= 5$，每个字符串长度 $<= 500$

对于 $100\%$ 的数据，$2 <= n <= 50$，字符串长度之和 $ <= 1000000$

**注意：本题内存限制仅为 64 MB,请尽量使用内存运用优秀的方法。**

另外，对于占 60 Pts 的测试点，您每通过一个点即可获得 10 Pts

对于剩下的测试点，您只有全部通过才能获得 40 Pts.

**对于所有数据点，不保证数据为随机生成。**

## 样例 #1

### 输入

```
3
abb
bcc
aba```

### 输出

```
1 2
1 1
2 1```

# AI分析结果



## 算法分类
**后缀数组（Suffix Array）**

---

## 综合分析与结论
### 题目核心思路
1. **字符串拼接**：将所有字符串用唯一分隔符拼接，构建统一后缀数组。
2. **维护最小 height**：遍历后缀数组时，动态维护每个字符串对应的最小 `height` 值，避免使用 `ST` 表等高内存结构。
3. **两两更新答案**：通过当前后缀所属字符串与历史最小 `height` 值，更新所有字符串对的最长公共子串长度。

### 核心难点与解决方案
- **内存限制**：直接 `ST` 表存储区间最小值会导致内存超限。通过动态维护每个字符串的当前最小 `height` 值（`O(n)` 空间），避免存储全局区间信息。
- **分隔符处理**：使用唯一字符（如递增 ASCII 码）作为分隔符，避免不同字符串的后缀在计算 `height` 时产生干扰。
- **时间复杂度优化**：利用后缀数组的排序性质，保证每个字符串的 `height` 最小值只需与相邻后缀比较更新，时间复杂度为 `O(nm)`。

---

## 题解评分（≥4星）
### 1. Tx_Lcy（⭐⭐⭐⭐⭐）
- **亮点**：详细解释分隔符处理与动态维护 `minx` 数组的逻辑，代码结构清晰，注释明确。
- **关键代码**：
  ```cpp
  for (int i=2;i<=m;++i){
      for (int j=1;j<=n;++j) minx[j]=min(minx[j],height[i]);
      minx[frm[sa[i-1]]]=height[i];
      int now=frm[sa[i]];
      for (int j=1;j<=n;++j) ans[now][j]=ans[j][now]=max(ans[now][j],minx[j]);
  }
  ```

### 2. chenly8128（⭐⭐⭐⭐）
- **亮点**：贪心思想维护 `ne` 数组，代码简洁高效，内存占用低。
- **关键逻辑**：
  ```cpp
  for (int j = 1;j <= n;j++) {
      ne[j] = min(ne[j],SA::height[i]);
      if (be != j) ans[be][j] = max(ans[be][j], ne[j]);
  }
  ```

### 3. AThousandSuns（⭐⭐⭐⭐）
- **亮点**：通过 `minh` 数组动态重置最小值，代码简洁且空间高效。
- **关键代码**：
  ```cpp
  for (int j=1;j<=n;j++) minh[j] = min(minh[j], height[i]);
  if (id[sa[i]]) minh[id[sa[i]]] = INF;
  ```

---

## 最优思路提炼
### 关键技巧
1. **后缀数组构建**：将所有字符串拼接后构建后缀数组，得到 `sa` 和 `height` 数组。
2. **动态维护最小值**：对每个后缀位置，维护每个字符串的最小 `height`，保证当前处理的字符串对的最小值仅依赖历史相邻值。
3. **分隔符唯一化**：使用递增 ASCII 字符作为分隔符，避免不同字符串的后缀产生错误 `lcp`。

### 代码实现核心
```cpp
// 拼接字符串并记录所属编号
string ss = "";
for (int i=1; i<=n; i++) {
    string s; cin >> s;
    for (char c : s) ss += c, frm[ss.size()] = i;
    ss += char(i + 26); // 唯一分隔符
}

// 遍历后缀数组，维护最小 height
vector<int> minx(n+1, INF);
for (int i=2; i<=total_len; i++) {
    for (int j=1; j<=n; j++) 
        minx[j] = min(minx[j], height[i]);
    minx[bel[sa[i-1]]] = height[i]; // 重置当前字符串的 minx
    int now = bel[sa[i]];
    for (int j=1; j<=n; j++) 
        ans[now][j] = max(ans[now][j], minx[j]);
}
```

---

## 同类型题与算法套路
### 通用解法
- **多字符串公共子串**：拼接后构建后缀数组，通过 `height` 数组动态维护区间最小值。
- **动态维护极值**：利用相邻后缀的 `height` 性质，避免全局存储区间信息。

### 推荐题目
1. **P3809** 【模板】后缀排序
2. **P4248** [AHOI2013]差异（后缀数组求两两后缀的 `lcp` 和）
3. **SPOJ LCS** Longest Common Substring（两字符串最长公共子串）

---

## 可视化与算法演示
### 动画设计
1. **像素风格展示**：
   - **颜色标记**：不同字符串后缀用不同颜色块表示，当前处理的 `height` 位置高亮。
   - **动态更新**：显示 `minx` 数组的数值变化，用颜色渐变表示值的大小。
2. **关键步骤演示**：
   - **后缀排序过程**：展示如何通过倍增法排序后缀。
   - **height 计算**：动态显示 `k` 指针的扩展过程。
3. **交互控制**：
   - **步进执行**：允许用户单步执行，观察每个 `height` 如何影响答案。
   - **速度调节**：滑动条控制动画播放速度。

### 复古游戏化实现
- **8位音效**：
  - 每次更新 `minx` 时播放短促“滴”声。
  - 找到新的最长公共子串时播放上扬音效。
- **Canvas 绘制**：
  - 用网格表示后缀数组，每个格子显示后缀编号和 `height` 值。
  - 当前处理的格子边框闪烁，历史最小值区域颜色加深。
- **积分系统**：
  - 每正确处理一个 `height` 获得 10 分。
  - 连续正确处理多个 `height` 触发连击奖励。

---

## 个人心得摘录
> "注意分隔符必须唯一，否则不同字符串的后缀可能在计算 `lcp` 时错误地包含分隔符，导致结果偏大。调试时需验证每个后缀的所属字符串编号是否正确。" —— Tx_Lcy

> "维护 `minx` 数组时，每次遇到新字符串的后缀要重置其最小值，因为后续 `height` 只与更近的后缀相关。" —— AThousandSuns

---

## 代码片段（核心逻辑）
### 动态维护 minx 数组
```cpp
int minx[55] = {INF}; // 初始化为极大值
for (int i = 2; i <= total_len; i++) {
    int current_str = bel[sa[i]]; // 当前后缀所属字符串
    for (int j = 1; j <= n; j++) {
        minx[j] = min(minx[j], height[i]); // 更新所有字符串的 minx
        ans[current_str][j] = max(ans[current_str][j], minx[j]);
        ans[j][current_str] = ans[current_str][j]; // 对称更新
    }
    minx[current_str] = INF; // 重置当前字符串的 minx
}
```

### 拼接字符串与记录所属
```cpp
string ss = "@"; // 起始占位符
vector<int> bel; // 记录每个位置所属字符串
for (int i = 1; i <= n; i++) {
    string s; cin >> s;
    for (char c : s) {
        ss += c;
        bel.push_back(i);
    }
    ss += (char)('z' + i); // 唯一分隔符
    bel.push_back(0); // 分隔符不属于任何字符串
}
```

---
处理用时：92.86秒
# 题目信息

# 秩序魔咒

## 题目描述

现代魔法师小L和小K正在研究魔咒。

“你知道如何使用魔咒吗？”

“当然知道，这是一个现代魔法师最基本的修养。”

“那你对魔咒的发展史了解多少？”

“课上讲的我还记得一点。那是在很久很久之前了。当时，世界上还没有人会使用魔咒，而混沌魔法成为了魔法界当时的主流魔法。这是一种邪恶的法术，不需要技巧，不需要规则，内心越黑暗，力量越强。于是，邪恶的魔法师们自相残杀，弄得天昏地暗，血流成河。其中，以自称‘混沌恶魔’的魔法师为首的魔法师集团通过极其肮脏的手段控制了几乎整个魔法界，让那些向往秩序与和平的魔法师难以生存。就在这个时候，世界救星的救星出现了。名为莱赫穆拉和肯埋多卡的两名魔法师勇敢地站了出来，仅凭两个人的力量就与混沌恶魔集团展开了决战，可终究寡不敌众，被逼到了绝境。就在混沌恶魔的最后一击打中他们的身体时，莱赫穆拉和肯埋多卡利用这一击的巨大魔力，将两人余下的全部魔法与意志升格成了概念，创造了秩序魔咒体系，扭转了世界理论，使得混沌魔法被永远封印。而混沌恶魔也在这强烈的扭曲中灰飞烟灭。从此，魔法界由混沌纪元进入了秩序纪元，人们遵循莱赫穆拉和肯埋多卡这两位圣人的遗志，在秩序魔咒体系下使用魔咒，直到现在。”

“原来是这样。我们如今需要遵循一系列原则来使用魔咒，是这个原因啊。”

“是啊，这正是两位圣人为维持现在这个世界不退回混沌纪元而做的努力。话说，你是上个星期才刚刚上了第一堂魔法课，你还记得使用魔咒的几个原则吗？”

“我想想。第一，必须出现在秩序序列中。当时二位圣人留下来的体系，经过后代魔法师不懈的努力，被翻译成了名为秩序序列的存在。为了方便现代魔法师使用，**秩序序列只由英文小写字母组成**。由于体系的力量过于强大而不能仅仅限制在一个序列中，**魔法师们分别将两位圣人的遗志转移到了两个秩序序列里**。魔咒必须受到秩序序列的限制。**具体来说，是必须出现在秩序序列里（是秩序序列的子串）**。由于二位圣人的遗志不可分割，**魔咒必须同时出现在两个秩序序列里**。第二，为了让魔咒稳定而精确，秩序体系规定了魔咒的形态。**具体来说，魔咒的第一个字符需要与魔咒的倒数第一个字符相同，魔咒的第二个字符需要与魔咒的倒数第二个字符相同，以此类推**。这样就可以使魔咒对称而有秩序了。还有的话，让我看看……”

“别看了别看了，最重要的就是这些了。还有，你说不定还不知道，魔咒越长，力量越强大。”

“是这样的吗？难怪那天老师演示的魔咒魔力比我的大那么多。”

“是的是的。你是不是已经发现了，魔咒的力量是有最高限制的？”

“啊，好像没错。但老师那天说，最强魔咒的使用者还没出现？”

“对。使用者自身必须要有与魔咒同样程度的能力，才可能顺利地使用这个魔咒。我们这些初学者，不知道何年何月才能达到这个程度呢……”

“唉……不如，我们来数一数力量最强的魔咒的长度，和它们有多少个吧。”

“嗯，反正没事可做，我们就来干一干这种力所能及的事吧。”

于是，小L和小K就开始数最强魔咒的长度和个数。可过了不一会儿，它们就坚持不住了，因为秩序序列实在太长太长了。

现在，你作为一个资深魔法师，有必要告诉他们这种基本的常识。你当然已经知道两个秩序序列的形态，请你帮小L和小K算出最强魔咒的长度和个数。

## 说明/提示

**样例解释**

样例1：符合规定的魔咒有$a,b,aa,aaa,aba,bab$，其中最强的有$aaa,aba,bab$，长度为$3$，共$3$个。

样例2：符合规定的魔咒有$a,b,aa,aaa,aaaa,bb,baab,aba,aabaa,c$，其中最强的有$aabaa$，长度为$5$，共$1$个。

**数据范围**

由于某些原因，本题需要使用$Subtask$。为取得一个$Subtask$的得分，你需要通过此$Subtask$中的所有数据点。
|  | 分值 | $n,m$取值范围 | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $Subtask1$ | $0$ | $1\le n,m\le260817$ | 是样例 |
| $Subtask2$ | $5$ | $1\le n,m\le260817$ | 两个秩序序列由同一字符组成 |
| $Subtask3$ | $5$ | $1\le n,m\le10$ | 无 |
| $Subtask4$ | $10$ | $1\le n,m\le300$ | 无 |
| $Subtask5$ | $10$ | $1\le n,m\le2000$ | 无 |
| $Subtask6$ | $30$ | $1\le n,m\le260817$ | 两个秩序序列相同 |
| $Subtask7$ | $40$ | $1\le n,m\le260817$ | 无 |

显然，相同的魔咒数量只计一次。保证至少存在一个长度不小于$1$的符合规定的魔咒。

注意时限为$3s$。

## 样例 #1

### 输入

```
6 7
aaabab
ababaaa```

### 输出

```
3 3```

## 样例 #2

### 输入

```
10 10
bbaabaaaac
bbaabaaaac```

### 输出

```
5 1```

# AI分析结果



# 秩序魔咒题解分析

## 唯一算法分类
**回文自动机（PAM）**

---

## 题解思路、算法要点与解决难点

### 核心思路
1. **回文自动机构建**：为两个字符串分别构建回文自动机（PAM），每个节点代表唯一回文子串。
2. **同步遍历**：DFS/BFS遍历两棵PAM的转移边，寻找公共节点（即同时存在于两个PAM中的回文串）。
3. **统计结果**：在遍历过程中记录最大长度及对应数量。

### 关键实现细节
- **PAM结构**：每个节点保存`len`（回文长度）、`fail`（最长回文后缀指针）、`ch`（转移边）。
- **插入逻辑**：通过`getfail`函数快速定位匹配位置，动态扩展节点。
- **同步遍历**：从奇根（len=-1）和偶根（len=0）同时出发，仅走相同转移边保证公共性。

### 解决难点
- **公共回文判定**：通过PAM的树形结构保证每个节点唯一对应一个回文串，避免重复计算。
- **高效性**：PAM的构建和遍历均为线性复杂度（$O(n)$）。

---

## 题解评分（≥4星）

### mrsrz（★★★★★）
- **亮点**：代码简洁，双PAM同步DFS，时间复杂度最优。
- **关键代码**：
  ```cpp
  void dfs(int nl, int nr) {
    if (mx < p1.len[nl]) mx = p1.len[nl], tot = 1;
    else if (mx == p1.len[nl]) ++tot;
    for (int i = 0; i < 26; ++i)
      if (p1.ch[nl][i] && p2.ch[nr][i]) dfs(p1.ch[nl][i], p2.ch[nr][i]);
  }
  ```

### creation_hy（★★★★☆）
- **亮点**：提供调试数据示例，强调节点编号可能不同的陷阱。
- **关键代码**：
  ```cpp
  dfs(0, 0), dfs(1, 1); // 必须遍历奇偶根
  ```

### 2018LZY（★★★★☆）
- **亮点**：使用BFS替代DFS，避免递归栈溢出风险。
- **关键代码**：
  ```cpp
  q[1] = mk(0, 0); q[2] = mk(1, 1); // 队列初始化奇偶根
  ```

---

## 最优思路或技巧提炼
1. **双PAM同步遍历**：通过DFS/BFS同时遍历两个自动机的转移边，确保找到所有公共回文。
2. **奇偶根处理**：必须从奇根（len=-1）和偶根（len=0）同时开始遍历，覆盖所有可能回文长度。
3. **动态统计最大值**：在遍历过程中实时更新最大长度和数量，避免二次扫描。

---

## 同类型题与算法套路
- **通用解法**：回文自动机适用于所有需要统计本质不同回文子串的场景。
- **类似题目**：
  - **最长双回文串**（P4555）：利用PAM的前后缀关系。
  - **公共回文子串计数**（SP1811）：SAM与PAM结合。

---

## 推荐相似题目
1. **P4555**（最长双回文串）
2. **P1435**（回文字符串编辑）
3. **SP1811**（最长公共子串）

---

## 个人心得摘录
> "回文自动机中节点编号并不对应相同回文，必须用两个指针分别跟踪两个PAM的节点" —— creation_hy

---

## 可视化与算法演示
### 核心算法动画设计
1. **PAM构建过程**：
   - **颜色标记**：新节点用绿色高亮，fail指针用红色箭头。
   - **步进控制**：逐字符插入，展示`getfail`的跳转过程。
2. **同步遍历过程**：
   - **双树对比**：并排显示两个PAM，当前对比的节点用黄色边框标记。
   - **路径回溯**：用蓝色线条连接已访问的公共节点。

### 复古像素风格实现
```javascript
// Canvas绘制PAM节点（伪代码）
function drawNode(x, y, len, isActive) {
  ctx.fillStyle = isActive ? '#FFD700' : '#2E8B57'; // 金色激活态，绿色默认
  ctx.fillRect(x, y, 32, 32);
  ctx.fillStyle = '#000';
  ctx.fillText(len, x + 8, y + 20);
}

// 音效触发
function playSound(effect) {
  const sfx = {
    found: new Audio('data:audio/wav;base64,UklGRl9...'), // 发现公共节点
    step: new Audio('data:audio/wav;base64,UklGRk9...')  // 单步执行
  };
  sfx[effect].play();
}
```

### 交互设计
- **自动模式**：按空格键启动/暂停自动遍历，速度可调。
- **单步调试**：方向键控制遍历步进，Enter键切换PAM构建/同步遍历阶段。

---

## 核心代码实现（mrsrz题解）
```cpp
#include<cstdio>
const int N=3e5+5;
char s[N],ss[N];
int mx=0,tot=0,n,m;
struct pam{
    int len[N],fail[N],ch[N][26],tot,lst,num[N];
    char s[N];
    void init(char*ss){
        tot=lst=1;
        len[1]=-1,len[0]=0,fail[0]=1;
        for(int i=1;ss[i];++i)s[i]=ss[i];
    }
    int insert(char cr,int ed){
        int c=cr-'a';
        int p=lst;
        while(s[ed]!=s[ed-len[p]-1]) p=fail[p];
        if(!ch[p][c]){
            int np=++tot;
            len[np]=len[p]+2;
            int q=fail[p];
            while(s[ed]!=s[ed-len[q]-1]) q=fail[q];
            fail[np]=ch[q][c];
            num[np]=num[fail[np]]+1;
            ch[p][c]=np;
        }
        lst=ch[p][c];
        return num[lst];
    }
}p1,p2;
void dfs(int nl,int nr){
    if(mx<p1.len[nl])mx=p1.len[nl],tot=1;
    else if(mx==p1.len[nl])++tot;
    for(int i=0;i<26;++i)
    if(p1.ch[nl][i]&&p2.ch[nr][i])dfs(p1.ch[nl][i],p2.ch[nr][i]);
}
int main(){
    scanf("%d%d",&n,&m);
    scanf("%s%s",s+1,ss+1);
    p1.init(s),p2.init(ss);
    for(int i=1;s[i];++i) p1.insert(s[i],i);
    for(int i=1;ss[i];++i) p2.insert(ss[i],i);
    dfs(0,0); dfs(1,1);
    printf("%d %d\n",mx,tot);
    return 0;
}
```

---
处理用时：80.16秒
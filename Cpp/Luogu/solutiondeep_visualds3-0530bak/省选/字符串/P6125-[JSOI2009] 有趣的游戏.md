# 题目信息

# [JSOI2009] 有趣的游戏

## 题目描述

小阳阳发明了一个有趣的游戏：有 $n$ 个玩家，每个玩家都有一个长度为 $l$ 的字母序列，任何两个玩家的字母序列不同。共有 $m$ 种不同的字母，所有的字母序列都由这 $m$ 种字母构成。为了方便，我们取大写字母的前 $m$ 个字母。   
例如 $m=3,l=4,\texttt{ABAA}$ 和 $\texttt{CBCA}$ 是两个合法的字母序列。       
现在由小阳阳来操控一台神奇的机器，每个时刻机器会随机产生一个字母，其中第 $i$ 种字母随机出来的概率为 $\dfrac{p_i}{q_i}$ ，显然 $\sum \limits_{k=1}^m \dfrac{p_i}{q_i}=1$。  
这样 $T$ 个时刻后机器会产生一个长度为 $T$ 的字母序列。  
如果某个时刻某个玩家发现自己的字母序列在机器产生的字母序列中出现了，“出现”的定义是玩家的字母序列是机器产生的字母序列中连续的一段，那么我们称这个玩家获胜，游戏结束。       
现在小阳阳感兴趣的一个问题是，每个玩家分别有多大的概率能获得这场游戏的胜利呢？  

## 说明/提示

$1 \leq n,l,m \leq 10$，$0 \leq p_i \leq q_i \leq 10$ 且 $\gcd(p,q) = 1$。

## 样例 #1

### 输入

```
3 2 2
1 2
1 2
AB
BA
AA```

### 输出

```
0.25
0.50
0.25```

## 样例 #2

### 输入

```
3 4 2
1 2
1 2
AABA
ABAA
BAAA```

### 输出

```
0.31
0.33
0.37```

# AI分析结果



## 唯一算法分类
AC自动机、高斯消元、概率期望

---

## 综合分析与结论
### 核心思路
1. **AC自动机构建状态转移图**：将所有玩家的字符串插入AC自动机并构建fail指针，形成状态转移网络。
2. **期望次数转化为概率**：将每个节点的期望访问次数视为概率，终止节点的期望次数即对应玩家的获胜概率。
3. **方程组建立**：
   - 非终止节点方程：$f_x = \sum (转移概率 \times 前驱节点的期望次数)$
   - 根节点额外加1（初始状态）
4. **高斯消元**：解线性方程组得到各节点的期望次数。

### 算法流程
1. **AC自动机构建**：插入所有模式串，构建转移边和fail指针。
2. **转移概率建模**：非终止节点按字符概率转移到下一状态。
3. **方程矩阵构建**：每个节点对应一个方程，矩阵系数由转移概率决定。
4. **高斯消元求解**：解出各节点期望次数，终止节点结果即为答案。

### 可视化设计要点
- **状态节点网格**：用像素方块表示AC自动机节点，颜色区分终止/非终止状态。
- **转移动画**：箭头动态显示转移过程，颜色深浅表示概率大小。
- **高斯消元演示**：
  - 用网格表示系数矩阵，当前操作行高亮。
  - 行交换时两行闪烁，归一化时主元放大显示。
  - 消元过程用颜色渐变表示数值变化。
- **音效触发**：
  - 状态转移时播放8-bit音效，音调随概率高低变化。
  - 消元完成时播放胜利音效。

---

## 题解清单 (≥4星)
1. **zzw4257（5星）**
   - 关键思路：将终止节点期望次数等价为概率，统一处理所有玩家。
   - 亮点：方程推导清晰，代码结构简洁，处理了概率分母为零的边界条件。

2. **cyffff（4星）**
   - 关键思路：显式构建AC自动机的转移边，矩阵构造直观。
   - 亮点：详细注释转移概率计算，代码可读性强。

3. **tommy0221（4星）**
   - 关键思路：使用生成函数方法避免显式AC自动机，数学推导巧妙。
   - 亮点：时间复杂度更低（$O(n^3)$），但需要处理更多边界条件。

---

## 最优思路与代码实现
### 核心代码（zzw4257 思路）
```cpp
struct AC_AutoMaton {
    int fail[N], cnt;
    struct Node { int ch[10]; bool endp; } a[N];
    void insert(char *s, int x) {
        int cur = 0;
        for (int i=1; s[i]; i++) {
            int c = s[i]-'A';
            if (!a[cur].ch[c]) a[cur].ch[c] = ++cnt;
            cur = a[cur].ch[c];
        }
        a[cur].endp = true;
    }
    void build() {
        queue<int> q;
        for (int i=0; i<m; i++)
            if (a[0].ch[i]) q.push(a[0].ch[i]);
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int i=0; i<m; i++) {
                int &v = a[u].ch[i];
                if (v) fail[v] = a[fail[u]].ch[i], q.push(v);
                else v = a[fail[u]].ch[i];
            }
        }
        // 构建转移概率矩阵
        for (int i=0; i<=cnt; i++) {
            if (a[i].endp) continue;
            for (int c=0; c<m; c++) {
                int j = a[i].ch[c];
                e[j].push_back({i, p[c]});
            }
        }
    }
} AC;

void buildEquations() {
    for (int i=0; i<=cnt; i++) {
        A[i][i] = -1;
        if (i == 0) A[i][cnt+1] = -1; // 根节点+1
        for (auto [j, w] : e[i]) 
            A[i][j] += w;
    }
}
```

### 关键技巧
1. **AC自动机优化转移**：利用fail指针压缩无效状态转移。
2. **期望次数转化**：终止节点的期望次数即概率，避免多次消元。
3. **矩阵压缩存储**：仅存储非零元素减少计算量。

---

## 相似题目推荐
1. **P4052 [JSOI2007]文本生成器**  
   核心：AC自动机+DP统计非法路径

2. **P3706 [SDOI2017]硬币游戏**  
   核心：生成函数+高斯消元解概率

3. **P3232 [HNOI2013]游走**  
   核心：图论+高斯消元求期望

---

## 个人心得摘录
> "调试时发现概率分母可能为零，设置极小值0.000001后通过。这启示在浮点运算中，对极端情况要主动防御。" —— zzw4257

> "生成函数方法虽然数学推导复杂，但能避免显式构建AC自动机，对稀疏状态更高效。" —— tommy0221

---

## 可视化算法演示
### 动画设计
1. **AC自动机构建阶段**：
   - 节点以绿色像素块生成，fail指针用红色箭头连接。
   - 插入字符串时字符逐个显示，转移边动态绘制。

2. **概率转移演示**：
   - 当前活跃节点黄色高亮，转移概率用流动光点表示。
   - 终止节点显示为红色，触发时爆炸特效+音效。

3. **高斯消元过程**：
   - 系数矩阵以网格显示，当前主元旋转强调。
   - 消元步骤用扫描线效果，数值变化伴随滴答音效。

### 交互控制
- **WASD移动视角**，缩放查看矩阵细节。
- 空格键暂停/继续，方向键单步执行。
- 按F切换自动演示模式，速度可调节。

---

通过上述设计，学习者可以直观理解状态转移与方程构建的对应关系，深入掌握概率期望与自动机的结合应用。

---
处理用时：202.81秒
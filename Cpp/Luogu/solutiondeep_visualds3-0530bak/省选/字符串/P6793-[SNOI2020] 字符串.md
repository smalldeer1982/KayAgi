# 题目信息

# [SNOI2020] 字符串

## 题目描述

有两个长度为 $n$ 的由小写字母组成的字符串 $a,b$，取出他们所有长为 $k$ 的子串（各有 $n-k+1$ 个），这些子串分别组成集合 $A,B$。现在要修改 $A$ 中的串，使得 $A$ 和 $B$ 完全相同。可以任意次选择修改 $A$ 中一个串的一段后缀，花费为这段后缀的长度。总花费为每次修改花费之和，求总花费的最小值。

## 说明/提示

#### 样例说明

对于样例 $1$，所有子串为：$A = \{aab,aba,baa\}, B = \{aba, bab, aba\}$。可以看出有一对 $aba$ 是相同的，另外要把 $aab$ 改成 $aba$（花费 $2$），$baa$ 改成 $bab$（花费 $1$），总花费为 $3$。

#### 数据规模与约定

对于所有数据，$1\le k\le n\le 1.5\times 10^5$。

- 对于 $10\%$ 的数据，$n \le 11$；
- 对于另外 $20\%$ 的数据，$n \le 200$；
- 对于另外 $20\%$ 的数据，$n \le 2000$；
- 对于另外 $10\%$ 的数据，字符串的每一位在小写字母中均匀随机；
- 对于余下 $40\%$ 的数据，无特殊限制。

## 样例 #1

### 输入

```
5 3
aabaa
ababa```

### 输出

```
3```

# AI分析结果



## 算法分类
后缀自动机 (SAM)

## 综合分析与结论
题目要求最小化修改A中子串的总花费，等价于最大化所有匹配对的LCP总和。各题解核心思路为贪心匹配最长LCP，通过不同数据结构实现：

1. **后缀数组法**：拼接字符串求height数组，按LCP降序合并集合统计贡献。
2. **后缀自动机法**：反转字符串建SAM，在parent树上自底向上合并A/B子串数量。
3. **分治法**：转化为序列问题，递归处理最小权值分割点。

**最优思路**：利用SAM的parent树结构，自然按LCP长度降序处理子串匹配，每个节点维护A/B子串数目，自底向上累加贡献。时间复杂度O(n)，空间复杂度O(n)。

**可视化设计**：
1. **动画流程**：展示SAM节点树，颜色标记当前处理节点（红色高亮），数值显示A/B数量。
2. **操作演示**：合并时显示贡献计算过程（如min(3A,5B)*LCP=2），动态更新总贡献值。
3. **像素风格**：用8-bit网格展示SAM节点，合并时播放"哔"声效，成功匹配时播放金币音效。

---

## 题解评分（≥4星）
1. **pomelo_nene的SAM解法（5星）**  
   代码简洁，直接利用SAM性质处理反转字符串，parent树自底向上合并，思路清晰。

2. **zyp123456的SAM实现（4星）**  
   在线构建广义SAM，代码规范，树形DP统计贡献，可读性较好。

3. **Fuyuki的SAM优化（4星）**  
   简化合并过程，直接维护差值，实现高效，代码略紧凑但逻辑明确。

---

## 核心代码实现（SAM法）
```cpp
struct SAM {
    int tot=1, las=1;
    struct Node { int len, fa, ch[26], cnt[2]; } tr[N];
    void extend(int c, int type) {
        int p=las, np=las=++tot;
        tr[np].len = tr[p].len + 1;
        tr[np].cnt[type] = 1; // 标记A/B子串
        for(; p && !tr[p].ch[c]; p=tr[p].fa) 
            tr[p].ch[c] = np;
        if(!p) tr[np].fa = 1;
        else {
            int q = tr[p].ch[c];
            if(tr[q].len == tr[p].len+1) tr[np].fa = q;
            else {
                // ...克隆节点处理
            }
        }
    }
} sam;

// 自底向上合并贡献
for(int i=cnt; i; i--) {
    int u = A[i]; // 按长度排序的节点
    int f = sam.tr[u].fa;
    int match = min(sam.tr[u].cnt[0], sam.tr[u].cnt[1]);
    ans += match * min(sam.tr[u].len, k);
    sam.tr[f].cnt[0] += sam.tr[u].cnt[0] - match;
    sam.tr[f].cnt[1] += sam.tr[u].cnt[1] - match;
}
```

---

## 同类型题目
1. **P2178 [NOI2015] 品酒大会**  
   同用后缀数组按height合并，处理LCP相关问题。

2. **P3804 【模板】后缀自动机**  
   练习SAM基本操作与parent树性质。

3. **P4248 [AHOI2013]差异**  
   利用后缀数组或SAM求LCP相关统计。

---

## 可视化方案（SAM版）
**Canvas动画**：
1. **节点树绘制**：每个节点显示`(len, A, B)`，颜色渐变（浅蓝→深蓝）表示len递增。
2. **合并过程**：红色边框标记当前节点，绿色箭头指向父节点，合并时显示数值变化。
3. **音效触发**：合并时播放"嘟"声，贡献计算时播放金币声。

**复古像素效果**：
```javascript
// 绘制节点（8-bit风格）
function drawNode(x, y, node) {
    ctx.fillStyle = '#8BDBFF'; // 浅蓝方块
    ctx.fillRect(x, y, 32, 32);
    ctx.fillStyle = '#000'; // 黑色文字
    ctx.fillText(`L:${node.len}`, x+2, y+10);
    ctx.fillText(`A:${node.A}`, x+2, y+20);
    ctx.fillText(`B:${node.B}`, x+2, y+30);
}
```

---

## 个人心得
调试时需注意反转字符串后，子串的起始位置是否满足`i+k-1 <=n`。SAM合并时，父节点的len应严格小于子节点，确保自底向上的处理顺序。

---
处理用时：85.84秒
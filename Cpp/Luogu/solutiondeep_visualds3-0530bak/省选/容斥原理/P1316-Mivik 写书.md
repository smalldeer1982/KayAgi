# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果



---

## 唯一算法分类
**容斥原理**

---

## 综合分析与结论
### 核心问题
计算长度为 $n$ 的随机字符串中所有本质不同非空子串的期望数量。关键难点在于避免重复计算本质相同的子串。

### 核心算法流程
1. **枚举子串长度** $x$，从 $1$ 到 $n$。
2. **枚举所有可能的出现位置集合** $S$（二进制表示子串起始位置）。
3. **用并查集处理字符约束**：若子串在多个位置出现，则这些位置对应的字符必须相同。
4. **容斥计算贡献**：出现奇数次的位置集合加贡献，偶数次减贡献，最终统计连通块数量计算方案数。

### 可视化设计要点
1. **动画方案**：
   - **网格展示**：将字符串每个字符绘制为像素方块，动态高亮当前处理的子串位置。
   - **并查集合并**：用颜色连线表示字符必须相同的约束，合并时播放像素音效。
   - **贡献计算**：右侧面板实时更新当前子串长度的总贡献和容斥系数。
2. **复古风格**：
   - **8位调色板**：使用红、蓝、绿三色表示不同状态（未覆盖/已覆盖/合并块）。
   - **音效触发**：每次枚举位置集合时播放“点击”音效，合并连通块时播放“连接”音效。
3. **交互功能**：
   - **步进控制**：可单步观察每个子串长度的处理流程。
   - **自动演示**：按 $n=1→20$ 顺序自动播放，速度可调。

---

## 题解清单（≥4星）
### 1. Huasushis 题解（⭐⭐⭐⭐⭐）
- **亮点**：代码简洁，通过位运算直接枚举位置集合，并查集处理约束的逻辑清晰。
- **关键代码**：
  ```cpp
  for (int j = 0; j < x; ++j) fa[j] = j;
  c = (c << 1) | ((i >> j) & 1); // 位运算跟踪覆盖位置
  if (c) fa[getfa(__builtin_ctz(c))] = ... // 并查集合并
  ```

### 2. 7KByte 题解（⭐⭐⭐⭐）
- **亮点**：优化位运算逻辑，使用预计算 `mt[]` 加速低位操作。
- **关键优化**：
  ```cpp
  int o = (1 << x) - 1; // 掩码优化
  c = (c << 1) | (1 & (i >> j)), c &= o; // 快速截断
  ```

### 3. Reunite 题解（⭐⭐⭐⭐）
- **亮点**：独立推导容斥框架，变量命名清晰易读。
- **心得摘录**：“直接做会有重复，容斥系数通过 `__builtin_parity` 快速判断奇偶性。”

---

## 最优思路提炼
### 关键技巧
1. **位运算枚举**：用二进制数表示子串出现位置集合，快速遍历所有可能性。
2. **并查集动态维护**：处理重叠子串的字符一致性约束，统计自由变量数量。
3. **容斥系数优化**：利用 `__builtin_parity` 快速计算集合大小的奇偶性。

### 代码实现要点
```cpp
// 枚举子串长度 x 和位置集合 i
for (int x=1; x<=n; ++x) {
    int w = (1<<(n-x+1)) - 1;
    for (int i=1; i<w; ++i) {
        // 初始化并查集
        for (int j=0; j<x; ++j) fa[j] = j;
        int c = 0, free = 0;
        // 遍历每个字符位置
        for (int pos=0; pos<n; ++pos) {
            c = (c<<1) | (i>>pos & 1); // 更新覆盖状态
            if (c) { // 处理约束
                int root = __builtin_ctz(c);
                for (int k=c^(1<<root); k; k^=k&-k)
                    fa[getfa(__builtin_ctz(k))] = getfa(root);
            } else free++; // 统计自由字符
        }
        // 计算连通块数
        for (int j=0; j<x; ++j) 
            if (fa[j] == j) free++;
        // 容斥累加贡献
        ans += (__builtin_parity(i) ? 1 : -1) * qpow(m, free);
    }
}
```

---

## 类似题目推荐
1. **P3773 [CTSC2017]吉夫特**（容斥+位运算）
2. **P4491 [HAOI2018]染色**（生成函数+容斥）
3. **P3349 [ZJOI2016]小星星**（容斥+树形DP）

---

## 可视化演示代码（节选）
```javascript
// Canvas 绘制并查集合并过程
function drawUnionFind(ctx, faArray) {
    ctx.clearRect(0, 0, 400, 50);
    for (let i=0; i<faArray.length; i++) {
        ctx.fillStyle = COLORS[faArray[i]];
        ctx.fillRect(20*i, 0, 18, 18); // 绘制字符块
    }
    // 播放合并音效
    playSound('merge', 0.2);
}
```

---

## 总结
通过容斥原理和位运算的高效结合，能在 $O(n^22^n)$ 时间内解决小规模下的期望计算问题。关键是通过并查集动态维护字符约束，将复杂问题转化为连通块计数，充分体现了组合数学与算法优化的精妙结合。

---
处理用时：75.02秒
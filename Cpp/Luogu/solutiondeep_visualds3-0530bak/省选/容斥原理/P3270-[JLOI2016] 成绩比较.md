# 题目信息

# [JLOI2016] 成绩比较

## 题目描述

G 系共有 $N$ 位同学，$M$ 门必修课。这 $N$ 位同学的编号为 $0$ 到 $N-1$ 的整数，其中 B 神的编号为 $0$ 号。这 $M$ 门必修课编号为 $0$ 到 $M-1$ 的整数。一位同学在必修课上可以获得的分数是 $1$ 到 $U_i$ 中的一个整数。

如果在每门课上 A 获得的成绩均小于等于 B 获得的成绩，则称 A 被 B 碾压。在 B 神的说法中，G 系共有 $K$ 位同学被他碾压（不包括他自己），而其他 $N-K-1$ 位同学则没有被他碾压。D 神查到了 B 神每门必修课的排名。

这里的排名是指：如果 B 神某门课的排名为 $R$，则表示有且仅有 $R-1$ 位同学这门课的分数大于 B 神的分数，有且仅有 $N-R$ 位同学这门课的分数小于等于 B 神（不包括他自己）。

我们需要求出全系所有同学每门必修课得分的情况数，使其既能满足 B 神的说法，也能符合 D 神查到的排名。这里两种情况不同当且仅当有任意一位同学在任意一门课上获得的分数不同。

你不需要像 D 神那么厉害，你只需要计算出情况数模 $10^9+7$ 的余数就可以了。

## 说明/提示

$1\leq N\leq 100$，$1\leq M\leq 100$，$1\leq U_i\leq 10^9$，$1\leq R_i\leq N$。

## 样例 #1

### 输入

```
3 2 1
2 2
1 2```

### 输出

```
10```

# AI分析结果



# 题解分析：成绩比较（[JLOI2016]）

## 唯一算法分类
组合数学（容斥原理 + 多项式展开）

---

## 综合分析与结论

### 核心思路
题目要求计算满足排名约束和碾压关系的分数分配方案数。所有题解均采用以下核心步骤：
1. **选出被碾压者**：用组合数确定被碾压的 k 人集合
2. **处理剩余同学的关系**：通过容斥原理确保其余同学至少有一个科目超过 B 神
3. **计算分数分配方案**：对每门课程枚举 B 神的分数，利用多项式展开和插值处理大范围的 U_i

### 关键难点与解决方案
| 难点 | 解决方案 |
|------|----------|
| 恰好 k 人被碾压的约束 | 二项式反演/容斥原理转换「至少」和「恰好」的计数 |
| 分数分配中的 U_i 过大 | 自然数幂和用拉格朗日插值或斯特林数预处理 |
| 多课程独立性的处理 | 将每门课程的贡献拆分为独立的乘积项 |

---

## 题解清单（≥4星）

### 1. Redpojoe 的题解（★★★★☆）
**亮点**：
- 将问题拆分为三个独立模块，逻辑清晰
- 使用容斥处理「至少」到「恰好」的转换
- 预处理组合数和幂次优化时间

**核心代码片段**：
```cpp
int Calc() {
    int tot = n - k - 1;
    long long Ans = 0;
    for(int i = 0; i < tot; i++) {
        long long th = F(tot - i) * C[tot][i];
        Ans += (i & 1 ? -th : th);
    }
    return (Ans % mod + mod) % mod;
}
```

### 2. K8He 的题解（★★★★☆）
**亮点**：
- 显式应用二项式反演公式
- 分离自然数幂和的计算模块
- 代码结构模块化，便于调试

**反演公式**：
$$
f(k) = \sum_{i=k}^n (-1)^{i-k} \binom{i}{k} g(i)
$$

### 3. D2T1 的题解（★★★★☆）
**亮点**：
- 动态规划状态转移处理多课程贡献
- 预处理斯特林数和组合数加速计算
- 代码实现简洁高效

**状态转移方程**：
$$
dp_{i,j} = \sum_{p=j}^{n+j-a_i} dp_{i-1,p} \cdot \binom{p}{j} \cdot \binom{n-p}{a_i-j}
$$

---

## 最优思路提炼

### 关键技巧
1. **容斥转换**：将「恰好 k」转化为「至少 i」的容斥和
2. **插值优化**：对 $\sum x^k$ 用拉格朗日插值处理大范围 U_i
3. **独立拆分**：将多课程问题分解为独立乘积项

### 实现示例（拉格朗日插值）
```cpp
ll lagrange(ll x, int k) {
    ll ans = 0;
    for(int i=1; i<=k+2; ++i) {
        ll s1 = 1, s2 = 1;
        for(int j=1; j<=k+2; ++j) {
            if(i != j) {
                s1 = s1 * (x - j) % mod;
                s2 = s2 * (i - j) % mod;
            }
        }
        ans = (ans + y[i] * s1 % mod * inv(s2)) % mod;
    }
    return ans;
}
```

---

## 相似题目推荐
1. [P3773 计数](https://www.luogu.com.cn/problem/P3773) - 组合数+生成函数
2. [P4091 求和](https://www.luogu.com.cn/problem/P4091) - 自然数幂和+二项式定理
3. [P4921 情侣？给我烧了！](https://www.luogu.com.cn/problem/P4921) - 容斥原理+错排问题

---

## 可视化设计

### 动画方案
1. **容斥过程演示**：
   - 用不同颜色方块表示「被碾压集合」
   - 红色闪烁显示被排除的重复计数项
   - 逐步叠加/扣除容斥项的值

2. **插值计算流程**：
   - 在坐标系中动态绘制插值点 $(x_i, y_i)$
   - 高亮当前插值基函数的计算区域
   - 用渐变色带展示插值多项式的构建过程

### 复古像素风格实现
```javascript
// Canvas 初始化
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// 绘制 8-bit 风格网格
function drawGrid() {
    ctx.fillStyle = '#2D2D2D';
    for(let x=0; x<canvas.width; x+=8) {
        for(let y=0; y<canvas.height; y+=8) {
            if((x+y)/8 % 2) ctx.fillRect(x, y, 8, 8);
        }
    }
}

// 播放音效
function playSFX(type) {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = type === 'success' ? 880 : 440;
    osc.connect(audioCtx.destination);
    osc.start().stop(audioCtx.currentTime + 0.1);
}
```

---

## 个人心得摘录
> 「调试时发现组合数的边界条件极易出错，特别是当 R_i > n-k 时的非法情况，需要增加特判。建议在计算前先检查所有 R_i 的合法性。」—— Redpojoe

> 「拉格朗日插值的预处理部分最初忘记处理负数的逆元，导致出现诡异错误。模运算中负数必须转换为正数后再求逆！」—— K8He

---

通过这种系统化的分析，可以深入理解组合数学在复杂计数问题中的应用，并为类似问题提供通用的解决框架。

---
处理用时：75.32秒
# 题目信息

# [FJOI2017] 矩阵填数

## 题目描述

给定一个 $h \times w$ 的矩阵，矩阵的行编号从上到下依次为 $1 \sim h$，列编号从左到右依次 $1 \sim w$。

在这个矩阵中你需要在每个格子中填入 $1 \sim m$ 中的某个数。

给这个矩阵填数的时候有一些限制，给定 $n$ 个该矩阵的子矩阵，以及该子矩阵的最大值 $v$，要求你所填的方案满足该子矩阵的最大值为 $v$。

现在，你的任务是求出有多少种填数的方案满足 $n$ 个限制。

两种方案是不一样的当且仅当两个方案至少存在一个格子上有不同的数。由于答案可能很大，你只需要输出答案对 $10 ^ 9 + 7$ 取模后的结果。

## 说明/提示

对于 $20\%$ 的数据，$n \le 2$。

另有 $20\%$ 的数据，$1 \le h, w \le 50$。

对于 $100\%$ 的数据，$T \le 5$，$1 \le h, w, m \le 10 ^ 4$，$1 \le n \le 10$，$1 \le v \le m$。

## 样例 #1

### 输入

```
2
3 3 2 2
1 1 2 2 2
2 2 3 3 1
4 4 4 4
1 1 2 3 3
2 3 4 4 2
2 1 4 3 2
1 2 3 4 4```

### 输出

```
28
76475```

# AI分析结果



**唯一算法分类**：容斥原理与离散化结合的状态压缩动态规划

---

### **题解思路与算法要点**

#### **核心思路**
各题解均围绕**容斥原理**与**离散化**展开，核心步骤为：
1. **离散化**坐标，将大矩阵分割为小矩形块，每个块受特定子矩阵限制。
2. **状态压缩**枚举限制条件是否满足（即子矩阵最大值是否达到v）。
3. **容斥计算**：总方案数减去不满足条件的方案数，处理多个限制的交集。

#### **解决难点**
1. **区域划分**：通过离散化坐标将矩阵切割为独立块，每个块受不同限制影响。
2. **值域约束**：对每个块计算其可能的最大值（取覆盖该块的所有限制中最小的v）。
3. **动态规划合并**：使用状压DP合并各块的影响，处理多个限制条件的组合。

#### **关键变量与操作**
- **离散化数组**：存储切割后的坐标边界（如`lx[]`, `ly[]`）。
- **块属性**：每个块的面积、最大值限制、对应的限制集合（如`block[i].val`）。
- **DP状态**：`dp[i][s]`表示前i个块满足状态s的方案数，s的二进制位表示各限制是否被满足。

---

### **题解评分（≥4星）**

1. **shadowice1984（★★★★☆）**  
   - **亮点**：容斥思路清晰，通过值域分层计算，优化至O(3^n)。  
   - **代码**：预处理区域面积，使用快速幂优化计算。

2. **Itst（★★★★★）**  
   - **亮点**：结合离散化与状压DP，复杂度O(2^n n³)，代码结构清晰。  
   - **关键代码**：离散化坐标后枚举子集，快速幂计算贡献。

3. **pantw（★★★★☆）**  
   - **亮点**：状压DP实现简洁，通过离散化降低复杂度。  
   - **代码**：使用`dp[i][j]`转移，预处理每个块的限制集合。

---

### **最优思路提炼**
1. **离散化切割**：将大矩阵切割为独立块，每个块受唯一最小值限制。
2. **容斥与状压结合**：枚举每个限制是否被满足，通过容斥合并方案数。
3. **快速幂优化**：对每个块的面积贡献使用快速幂计算，避免重复运算。

---

### **同类题目推荐**
1. **P2150 [NOI2015] 寿司晚宴**（状压DP与质因数分解）
2. **P3226 [HNOI2012] 集合选数**（状态压缩与矩阵约束）
3. **P2595 [ZJOI2009] 多米诺骨牌**（离散化与容斥）

---

### **可视化设计**
**动画方案**：  
1. **像素风格网格**：用Canvas绘制离散化后的网格，不同颜色表示不同值域块。  
2. **高亮当前块**：处理某一块时，其边界闪烁，显示当前限制集合。  
3. **状态转移展示**：右侧面板显示二进制状态变化，对应块贡献的方案数动态累加。  

**复古音效**：  
- **操作音效**：块处理时播放8-bit点击声，状态更新时播放短促音效。  
- **过关提示**：所有块处理完成后播放胜利音效，背景音乐循环轻快旋律。

**交互功能**：  
- **步进控制**：支持暂停/继续，调整动画速度观察状态转移。  
- **自动演示**：AI模式自动执行，标记关键步骤（如离散化切割、状态合并）。

---

### **核心代码片段（Itst题解）**
```cpp
// 离散化坐标并计算每个块的贡献
sort(X, X + cntx); sort(Y, Y + cnty);
for (int i = 1; i <= n; i++) {
    xl[i] = lower_bound(X, X + cntx, xa[i]) - X;
    xr[i] = lower_bound(X, X + cntx, xb[i] + 1) - X;
    // 类似处理y坐标...
}

// 枚举子集并计算方案数
for (int s = 0; s < (1 << n); s++) {
    for (int i = 1; i < cntx; i++)
        for (int j = 1; j < cnty; j++) {
            int maxv = m;
            for (int k = 1; k <= n; k++)
                if (覆盖当前块) maxv = min(maxv, v[k] - (s & (1<<k)));
            ans += pow(maxv, area) * parity(s);
        }
}
```

---

### **总结**
通过离散化与状态压缩，将复杂约束拆分为独立块，结合容斥原理高效合并方案数。关键优化在于减少重复计算并利用快速幂加速，适用于n较小的约束问题。

---
处理用时：94.91秒
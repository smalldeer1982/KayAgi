# 题目信息

# [Ynoi Easy Round 2016] 谁的梦

## 题目背景

6.373 

世界是独立于我的意志的。 

6.374 

就算我们所期望的全部的事情都发生了 

这果然也只能说是命运的恩惠吧。 

要问为什么，那是因为意志和世界之间 

能够保证这件事的逻辑性的关联并不存在 

Ludwig Josef Johann Wittgenstein [逻辑哲学论] 

自从双胞胎的哥哥过世起，已经过了多久了呢… 

从那时起，我一直保存着那个布偶。 

在那以后的我只是个影子…而这个布偶才是我… 

这样也并没有什么不好。 

我觉得只要现在的我消失掉就行了… 

那两个人却救了这样的我。 

一个是由歧姐… 

她又来到了我的身边… 

带着皆守哥…回到了我们的身边… 

水上由岐姐姐…温柔的姐姐 

曾经非常喜欢皆守哥的人……

![](https://cdn.luogu.com.cn/upload/pic/21195.png)

回去的路上…

平时不会经过的坡道…

在登上那个坡道的途中…

我看到了夜晚的太阳。

明明就在附近，却一直不知道的巨大的向日葵。

夜露使它的绒毛泛出了白光。

碧蓝的月光和黄色的向日葵…

就好像太阳和月亮的立场反过来一样…

原本是那么耀眼的的太阳在地上，只能在其背后下发光的月亮在天上…

黄色的向日葵被染成了碧蓝色。

那副样子虽然很美丽…

努力绽放的向日葵，看起来反而是柔弱的存在。

在夜里向天空伸展的向日葵…

我在车内一直追寻着它的身影…

被夜晚的月光映照着的太阳。

被染成碧蓝色的太阳…

它的身影…我一直追寻着……

![](https://cdn.luogu.com.cn/upload/pic/21196.png)

被月光照亮的天台上…

一个人影…

明明只是一个人影…却好像…在和什么东西对峙着一样…

皆守哥…

月下的立像，一个人影。

胸口在风中闪烁。

放在胸前的手里的是…那时的小刀。

和七年前同样的姿势。

唯一不同的是，那里的人影只有一个。

那把小刀，好像是被他自己刺入体内。

![](https://cdn.luogu.com.cn/upload/pic/21197.png)

是诅咒…

这是理所当然的事…

那并不是什么精神病…

那是诅咒…

下在幸存的我们身上的…诅咒…

说不定，不仅仅是卓司哥…连由岐姐也在诅咒我们…

所以变成这种结果…

哥哥刺向了自己的胸口…

破坏了我的半身…

然后…还要把很多人送回到天空…

回归天空的日子。

交还灵魂的日子。

那一天，卓司哥对我做的事情。

杀了由岐姐的…那个行为…

他想要再一次实行…

这次…和很多人一起…

![](https://cdn.luogu.com.cn/upload/pic/21198.png)

不是…

那是…我啊…

是那个…坡道的事情啊…

两个人一起看到向日葵的…那个坡道…

…我说要爬上那个坡道…要去寻找爸爸的灵魂…

我想，如果到了那个坡道的前方，就能取回爸爸的灵魂…爸爸就会复生的…

如果越过向日葵之路…向着向日葵所朝向的天空延伸的…那个大大的坡道的话…
大概，就会有爸爸的灵魂…

爸爸的故乡的…大大的坡道…

![](https://cdn.luogu.com.cn/upload/pic/21199.png)

哥哥的身体浮在空中…

我无言地跳了出去。

啊啊…是这样啊…

由岐姐也是这种心情啊…

并没有什么道理可言…

只是因为喜欢的人向着天空跳下去了…

我想要抓住那个身体…

我——

## 题目描述

您正在打 galgame，突然断电了，于是您跑去物管处问，结果发现是由于一个光头踢了变压器一脚导致的，可能还要修很久，于是您决定想一个之前见过的数据结构题：

定义一个序列的权值为不同数字的个数，例如 $[1,2,3,3]$  权值为 $3$。

现在有 $n$ 个序列，我们在每个序列里面选一个连续非空子串，拼接起来，求所有选法得到的序列的权值之和。

如果一个序列能通过多种方法被选择出来，那么计算多次。

本题带修改操作，格式请参考输入格式。

由于结果可能过大，请输出答案 $\bmod 19260817$ 的结果。

## 说明/提示

Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477( partially uploaded )

$1 \leq n,m,len_i \leq 10^5$，序列中的元素均为 $32$ 位整型数，$\sum len_i \leq 10^5$。

共 $50$ 组数据。

## 样例 #1

### 输入

```
2 5
6 6
1 3 1 1 3 2 
2 3 3 2 1 1 
1 1 1
1 1 2
1 1 2
1 1 1
1 1 1```

### 输出

```
1158
1158
1168
1168
1158
1158```

# AI分析结果



## 唯一算法分类  
**容斥原理与数据结构维护**

---

## 综合分析与结论  
**核心思路**：通过补集转化，计算总方案数减去不包含某颜色的方案数。每个颜色的不包含方案数通过维护其在各序列中的出现位置（set结构），动态计算相邻位置间的合法子串数。

**核心难点**：  
1. 修改操作需快速定位相邻元素，动态调整段长贡献  
2. 多序列贡献的乘积可能为0，需特殊处理避免除零错误  

**解决方案**：  
- 用set维护颜色出现位置，插入/删除时计算前驱后继  
- 维护每个颜色的总贡献积，单独记录0的个数（zero标记）  

**可视化设计**：  
- **像素化序列展示**：用不同颜色块表示各序列元素，高亮修改位置  
- **段长动态分割**：插入新位置时，用闪烁动画展示原段分裂为两个新段  
- **音效触发**：成功插入时播放「哔」音效，除零时播放警示音  
- **自动演示模式**：模拟随机修改操作，展示颜色分布变化与贡献值实时计算  

---

## 题解清单（≥4星）  
### 1. 诗乃（★★★★☆）  
**亮点**：  
- 引入-1和len作为哨兵节点，避免边界判断  
- 维护_all和zero数组处理乘积为0的特殊情况  
- 通过map<Z, int>实现二维离散化  

**核心代码片段**：  
```cpp
void modify(int p, int _n, int c, int tp) {
    // 更新颜色c在第p个序列的贡献值
    bool tmp = __0[p];
    S = (S - all[c]) % mod;  // 先减去旧贡献
    if(!tmp) _all[c] = _all[c]*inv(_ans[p])%mod; // 非零时调整乘积
    // 更新当前序列的贡献值_ans[p]
    if(!tp) _ans[p] = (_ans[p] - G(_n)) % mod; 
    else _ans[p] = (_ans[p] + G(_n)) % mod;
    // 处理零标记
    if(_ans[p] && tmp) __0[p] = 0, --_0[c];
    all[c] = all[c] * _ans[p] % mod;
    S = (S + all[c]) % mod;  // 加上新贡献
}
```

### 2. Jμdge（★★★★☆）  
**亮点**：  
- 使用pair<int,int>映射序列位置与颜色  
- 通过qr函数实现类似树状数组的快速查询  
- 维护cnt_zero避免零值干扰  

**核心思路**：  
```cpp
struct node{ int val, cnt; }; // val为实际值，cnt记录零因子个数
void insert(int col,int x){
    // 计算前驱后继位置
    int pre = *--s[col].lower_bound(x);
    int suf = *s[col].upper_bound(x);
    // 更新贡献值
    ans -= (s - (zero[col]?0:mul[col]));
    mul[col] = mul[col] * INV(old) % mod * new_val % mod;
    ans += (s - (zero[col]?0:mul[col]));
}
```

### 3. xiezheyuan（★★★★☆）  
**亮点**：  
- 预处理逆元加速除法运算  
- 使用vector<set<int>>存储每个序列的颜色位置  
- 通过离散化减少空间占用  

**关键步骤**：  
```cpp
int subs(int x){ return x*(x+1)/2 % mod; } // 预计算段长贡献
void update(int x, int y, int z){
    erase旧颜色贡献 → 计算新旧相邻段 → insert新颜色贡献
}
```

---

## 同类型题推荐  
1. **P1972 [SDOI2009] HH的项链**  
   （区间颜色数统计，树状数组维护）  
2. **P4113 [HEOI2012] 采花**  
   （区间出现次数≥2的颜色数，离线+树状数组）  
3. **P1908 逆序对**  
   （动态维护序列，分治思想与数据结构结合）  

---

## 复古游戏化动画设计  
**实现要点**：  
1. **像素风格渲染**：  
   - 使用16色调色板（NES风格）  
   - 每个序列显示为横向色块，不同颜色用不同像素图案  
   ```javascript
   function drawBlock(ctx, x, y, color){
       ctx.fillStyle = NES_PALETTE[color % 8];
       ctx.fillRect(x*16, y*16, 14, 14); // 带1像素边框
   }
   ```

2. **动态分割演示**：  
   - 修改位置闪烁3次（红→白→原色）  
   - 原段显示为绿色边框，分裂后的段显示黄色边框  

3. **音效系统**：  
   ```javascript
   const SFX = {
       insert: new Audio('data:audio/wav;base64,UklGRl9...'), 
       error: new Audio('data:audio/wav;base64,UklGRhY...')
   };
   function playInsert(){ SFX.insert.currentTime=0; SFX.insert.play(); }
   ```

4. **自动演示模式**：  
   - 随机选择修改位置，0.5秒/步自动运行  
   - 底部状态栏显示当前总贡献值和颜色数  

---

## 关键代码实现（诗乃题解核心）  
**数据结构初始化**：  
```cpp
// 插入哨兵节点
for(int i=1;i<=n;i++){
    for(auto x : colors){
        s[id[{i,x}]].insert(-1);
        s[id[{i,x}]].insert(len[i]);
    }
}
```

**修改操作核心逻辑**：  
```cpp
void del(int p, int t){
    int c = a[p][t], u = id[(Z){p,c}];
    auto it = s[u].find(t);
    auto l = prev(it), r = next(it);
    // 计算旧段贡献
    int old_len = *r - *l -1;
    modify(u, old_len, c, 1); // 减去原段
    // 计算新分裂的两段
    modify(u, t-*l-1, c, 0);
    modify(u, *r-t-1, c, 0);
    s[u].erase(it);
}
```

**贡献值更新公式**：  
```
总贡献 = Σ (总方案数 - ∏ 不包含c的方案数)
不包含方案数 = Π (每个序列分割后的段长贡献和)
```

---

通过结合容斥原理与高效数据结构维护，该方案在O(n log n)时间复杂度内解决了动态颜色贡献统计问题。复古像素动画与音效交互可显著提升算法理解度。

---
处理用时：108.45秒
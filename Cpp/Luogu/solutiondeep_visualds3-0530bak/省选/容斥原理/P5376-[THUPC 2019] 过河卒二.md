# 题目信息

# [THUPC 2019] 过河卒二

## 题目描述

> 首先我们回忆一下经典难题过河卒问题：
>
> 棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向上、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点，因此称之为「马拦过河卒」。
>
> 棋盘用坐标表示，$A$ 点 $(1,1)$ 、$B$ 点 $(N,M)$ ，同样马的位置坐标是需要给出的。
>
> 现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。
>
> **请注意，上述背景内容与本题无关！**

Kiana 喜欢玩象棋，尤其是喜欢用象棋玩过河卒的游戏。在传统的过河卒问题中，Kiana 需要控制一个卒从起点走到终点，在路中避开一个对方的马的攻击，然后假装不会算并询问你从起点到终点的路径总数。

在今天的过河卒二游戏中，Kiana 还是控制一个卒在一个 $N\times M$ 的棋盘上移动，初始时卒位于左下方坐标为 $(1,1)$ 位置，但为了增加难度，Kiana 对游戏规则做出了一些修改。传统的过河卒每步只能向上或向右移动 $1$ 格，Kiana 规定自己的过河卒二还可以在一步中向右上方移动 $1$ 格，即如果当前卒位于坐标 $(x,y)$ 处，则下一步可以走到 $(x+1,y)$ 、$(x,y+1)$ 或 $(x+1,y+1)$ 中的任意一格里面去，同时 Kiana 认为，如果两种移动方案在某一步时卒移动的方向（右、上或右上）不同，则两种方案就是不同的，例如从 $(1,1)$ 先走到 $(1,2)$ 再走到 $(2,2)$ 、从 $(1,1)$ 先走到 $(2,1)$ 再走到 $(2,2)$ 和从 $(1,1)$ 直接走到 $(2,2)$ 是三种不同的移动方案。

其次，过河卒二的终点不再是一个特定的位置，Kiana 规定卒可以从棋盘的上方或右方走出棋盘，此时就视为游戏成功。注意在走出棋盘时仍然有方向选择的不同，例如若过河卒位于 $(1,M)$ 处，则下一步它可以向右或者向右上用两种方式走出棋盘，若过河卒位于 $(N,M)$ 处，则下一步它可以向上、向右或者向右上用三种方式走出棋盘，以不同的方式走出棋盘仍然被算作是不同的移动方案。

此外，对方马的攻击范围不再是有规律的几个位置，而是 Kiana 规定好的 $K$ 个特定坐标，并要求过河卒在移动的过程中不能走到这 $K$ 个坐标的任何一个上，在除这些坐标以外的位置上过河卒都可以按规则自由移动。

现在 Kiana 想知道，过河卒二有多少种不同的移动方案可以走出棋盘，这个答案可能非常大，她只想知道方案数对 $59393$ 取模后的结果。由于她不会算，所以希望由你来告诉她。



## 说明/提示

### 样例解释

用 $\uparrow$ 表示过河卒向上移动了一格，用 $\rightarrow$ 表示过河卒向右移动了一格，用 $\nearrow$ 表示过河卒向右上移动了一格，由此可以简化样例解释的表述。

$24$ 种移动方案如下：

$(\uparrow\uparrow\uparrow)$、$(\uparrow\uparrow\nearrow)$、$(\uparrow\uparrow\rightarrow\uparrow)$、$(\uparrow\uparrow\rightarrow\nearrow)$、

$(\uparrow\uparrow\rightarrow\rightarrow\uparrow)$、$(\uparrow\uparrow\rightarrow\rightarrow\nearrow)$、$(\uparrow\uparrow\rightarrow\rightarrow\rightarrow)$、$(\uparrow\nearrow\uparrow)$、

$(\uparrow\nearrow\nearrow)$、$(\uparrow\nearrow\rightarrow\uparrow)$、$(\uparrow\nearrow\rightarrow\nearrow)$、$(\uparrow\nearrow\rightarrow\rightarrow)$、

$(\rightarrow\rightarrow\rightarrow)$、$(\rightarrow\rightarrow\nearrow)$、$(\rightarrow\rightarrow\uparrow\rightarrow)$、$(\rightarrow\rightarrow\uparrow\nearrow)$、

$(\rightarrow\rightarrow\uparrow\uparrow\rightarrow)$、$(\rightarrow\rightarrow\uparrow\uparrow\nearrow)$、$(\rightarrow\rightarrow\uparrow\uparrow\uparrow)$、$(\rightarrow\nearrow\rightarrow)$、

$(\rightarrow\nearrow\nearrow)$、$(\rightarrow\nearrow\uparrow\rightarrow)$、$(\rightarrow\nearrow\uparrow\nearrow)$、$(\rightarrow\nearrow\uparrow\uparrow)$。

### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。

## 样例 #1

### 输入

```
3 3 1
2 2```

### 输出

```
24```

# AI分析结果



**唯一算法分类**：组合数学 + 容斥原理

---

### **题解思路与核心难点**
#### **核心思路**
1. **问题转化**：将“走出棋盘”转化为走到虚拟点 $(n+1, m+1)$，避免边界处理。
2. **路径计算**：允许右、上、右上三种移动，组合数公式为 $\sum_{i=0}^{\min(a,b)} \binom{a+b-i}{i} \binom{a+b-2i}{a-i}$，其中 $a,b$ 为坐标差。
3. **障碍处理**：使用容斥原理，预处理所有障碍点之间的路径数，通过符号反转计算不合法路径的贡献。

#### **解决难点**
- **组合数计算**：模数 $59393$ 是质数且较小，使用 Lucas 定理分治计算大数组合数。
- **障碍排序与容斥**：按坐标排序障碍点，确保路径单调性，通过状态压缩枚举障碍子集，计算其路径贡献。

---

### **题解评分（≥4星）**
1. **huayucaiji（5星）**  
   - 思路清晰，容斥预处理障碍间路径，代码结构简洁。  
   - 使用 Lucas 定理高效处理大数组合数。  
   - 关键代码片段：  
     ```cpp
     int fff(int n,int m) {
         int ret=0,ub=min(n,m);
         for(int i=0;i<=ub;i++)
             ret += lucas(n+m-i,i) * lucas(n+m-2*i,n-i);
         return ret % MOD;
     }
     ```

2. **Eznibuil（5星）**  
   - 动态规划避免状态压缩，时间复杂度更优（$O(k^2m)$）。  
   - 预处理阶乘逆元，优化组合数计算。  
   - 关键公式：  
     $$dp_i = w(x_i,y_i) - \sum_{j<i} dp_j \cdot w(x_i-x_j, y_i-y_j)$$

3. **wwt100127（4星）**  
   - 容斥实现直观，代码可读性强。  
   - 排序障碍点后枚举子集，利用符号位简化容斥系数计算。  

---

### **最优思路与技巧**
- **虚拟终点**：将棋盘扩展至 $(n+1, m+1)$，统一路径终点。
- **组合数分治**：Lucas 定理处理大数组合数模运算，仅需单层分解（因 $59393^2 > 2e9$）。
- **容斥剪枝**：排序障碍后，仅需处理坐标单调递增的子集，减少无效计算。

---

### **同类题目推荐**
1. **P1352 没有上司的舞会**（容斥与树形 DP）  
2. **P2602 数字计数**（组合数分段统计）  
3. **P3223 排队**（容斥处理限制条件）

---

### **可视化设计**
#### **算法演示（Canvas动画）**
1. **网格绘制**：棋盘以像素风格绘制，卒子为 8x8 像素方块，障碍点用红色高亮。
2. **路径展示**：用户点击“单步”时，卒子按当前路径方向移动，右上方向播放斜移动画。
3. **容斥效果**：选中障碍子集时，路径线颜色变化（绿色为加，红色为减），音效提示符号翻转。
4. **复古音效**：  
   - 移动时播放“哔”声，碰撞障碍时播放低音“嘟”。  
   - 成功计算后播放 8-bit 胜利旋律。

#### **代码片段（动画控制）**
```javascript
// 模拟卒子移动路径
function animatePath(steps, index) {
    if (index >= steps.length) return;
    let [dx, dy] = steps[index];
    // 更新卒子位置，Canvas 重绘
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGrid();
    ctx.fillStyle = '#00FF00';
    ctx.fillRect(x * cellSize, y * cellSize, 8, 8);
    setTimeout(() => animatePath(steps, index+1), 200);
}
```

---

### **核心代码实现**
```cpp
// 计算两点间路径数（huayucaiji 题解核心）
int fff(int n, int m) {
    int ret = 0, ub = min(n, m);
    for (int i=0; i<=ub; i++) {
        ret = (ret + lucas(n+m-i, i) * lucas(n+m-2*i, n-i)) % MOD;
    }
    return ret;
}

// 容斥计算总方案数
int main() {
    // 预处理阶乘和逆元...
    for (int i=0; i<(1<<k+1); i++) {
        ans = (ans + calc(i)) % MOD; // calc处理符号和路径乘积
    }
    cout << ans << endl;
}
```

---

### **总结**
通过组合数分治和容斥剪枝，将复杂路径问题转化为可计算的子问题，结合虚拟终点简化边界，是此类问题的通用解法。复古动画设计则增强了学习过程的趣味性。

---
处理用时：86.43秒
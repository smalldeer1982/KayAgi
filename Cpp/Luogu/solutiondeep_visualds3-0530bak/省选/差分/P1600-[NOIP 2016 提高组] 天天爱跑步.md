# 题目信息

# [NOIP 2016 提高组] 天天爱跑步

## 题目背景

NOIP2016 提高组 D1T2

## 题目描述

小 C 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。

这个游戏的地图可以看作一棵包含 $n$ 个结点和 $n-1$ 条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从 $1$ 到 $n$ 的连续正整数。

现在有 $m$ 个玩家，第 $i$ 个玩家的起点为 $s_i$，终点为 $t_i$。每天打卡任务开始时，所有玩家在第 $0$ 秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的）

小 C 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 $j$ 的观察员会选择在第 $w_j$ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 $w_j$ 秒也正好到达了结点 $j$。小 C 想知道每个观察员会观察到多少人?

注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一 段时间后再被观察员观察到。 即对于把结点 $j$ 作为终点的玩家：若他在第 $w_j$ 秒前到达终点，则在结点 $j$ 的观察员不能观察到该玩家；若他正好在第 $w_j$ 秒到达终点，则在结点 $j$ 的观察员可以观察到这个玩家。


## 说明/提示

**样例 1 说明**

对于 $1$ 号点，$w_i=0$，故只有起点为 $1$ 号点的玩家才会被观察到，所以玩家 $1$ 和玩家 $2$ 被观察到，共有 $2$ 人被观察到。

对于 $2$ 号点，没有玩家在第 $2$ 秒时在此结点，共 $0$ 人被观察到。

对于 $3$ 号点，没有玩家在第 $5$ 秒时在此结点，共 $0$ 人被观察到。

对于 $4$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。

对于 $5$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。

对于 $6$ 号点，玩家 $3$ 被观察到，共 $1$ 人被观察到。

**子任务**

每个测试点的数据规模及特点如下表所示。 

提示：数据范围的个位上的数字可以帮助判断是哪一种数据类型。

| 测试点编号 | $n=$ | $m=$ | 约定 |
| :--------: | :----: | :----: | :----: |
|     $1\sim 2$      |  $991$   |  $991$   | 所有人的起点等于自己的终点，即 $\forall i,\ s_i=t_i$  |
|     $3\sim 4$      |  $992$   |  $992$   | 所有 $w_j=0$  |
|     $5$      |  $993$   |  $993$   | 无  |
|     $6\sim 8$      |  $99994$   |  $99994$   | $\forall i\in[1,n-1]$，$i$ 与 $i+1$ 有边。即树退化成 $1,2,\dots,n$ 按顺序连接的链  |
|     $9\sim 12$      |  $99995$   |  $99995$   | 所有 $s_i=1$  |
|     $13\sim 16$      |  $99996$   |  $99996$   | 所有 $t_i=1$  |
|     $17\sim 19$      |  $99997$   |  $99997$   | 无  |
|     $20$      |  $299998$   |  $299998$   | 无  |



**提示**

（提示：由于原提示年代久远，不一定能完全反映现在的情况，现在已经对该提示做出了一定的修改，提示的原文可以在[该剪贴板](https://www.luogu.com.cn/paste/3fneb8m6)查看）

在最终评测时，调用栈占用的空间大小不会有单独的限制，但在我们的工作环境中默认会有 $1 \text{MiB}$ 的限制。 这可能会引起**函数调用层数较多时，程序发生栈溢出崩溃**，程序中**较深层数的递归**往往会导致这个问题。如果你的程序需要用到较大的栈空间，请务必注意该问题。

我们可以使用一些方法修改调用栈的大小限制。

- Linux

我们可以在终端中输入下列命令：`ulimit -s 1048576`。此命令的意义是，将调用栈的大小限制修改为 $1048576\text{KiB}=1 \text{GiB}$。

例如，对于如下程序 `sample.cpp`：

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[1000005];
void dfs(int a){
	if(a == 0){
		f[a] = 0;
		return;
	}
	dfs(a - 1);
	f[a] = f[a - 1] + 1;
}
int main(){
	dfs(1000000);
	return 0;
}
```

将上述源代码用命令 `g++ sample.cpp -o sample` 编译为可执行文件 `sample` 后，使用 `./sample` 执行程序。

如果在没有使用命令 `ulimit -s 1048576` 的情况下运行该程序，`sample` 会因为栈溢出而崩溃；如果使用了上述命令后运行该程序，该程序则不会崩溃。

特别地，当你打开多个终端时，它们并不会共享该命令，你需要分别对它们运行该命令。

请注意，调用栈占用的空间会计入总空间占用中，和程序其他部分占用的内存共同受到内存限制。

- Windows

如果你使用 Windows 下的 Dev-C++，请选择 `工具-编译选项` 并在如下区域填入以下命令 `-Wl,--stack=1073741824`，填入后注意确认“编译时加入以下命令的”的框是**已勾选**状态。

此处 `1073741824` 的单位是 $\text{B/Bytes}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/z6mbzfqo.png)  ![](https://cdn.luogu.com.cn/upload/image_hosting/zvrzkyq5.png)

## 样例 #1

### 输入

```
6 3
2 3
1 2 
1 4 
4 5 
4 6 
0 2 5 1 2 3 
1 5 
1 3 
2 6 ```

### 输出

```
2 0 0 1 1 1 ```

## 样例 #2

### 输入

```
5 3 
1 2 
2 3 
2 4 
1 5 
0 1 0 3 0 
3 1 
1 4
5 5 ```

### 输出

```
1 2 1 0 1 ```

# AI分析结果



---

## 算法分类
LCA+树上差分+桶计数

---

## 综合分析与结论

### 核心算法流程
1. **路径拆分**：将每个玩家的路径拆分为上行（s→LCA）和下行（LCA→t）两部分
2. **条件推导**：
   - 上行路径：满足 dep[s] = dep[u] + w[u] → 用桶1统计 dep[s]
   - 下行路径：满足 dep[s]-2*dep[LCA] = w[u]-dep[u] → 用桶2统计 dep[s]-2*dep[LCA]
3. **树上差分**：
   - 上行路径：在s处+1，在LCA处-1
   - 下行路径：在t处+1，在LCA的父节点处-1
4. **DFS统计**：
   - 维护全局桶1和桶2
   - 递归时先记录当前值，处理子树后计算差值作为答案

### 可视化设计
- **动画方案**：  
  ![树上差分示意图](https://img-blog.csdnimg.cn/20201114213718618.gif)  
  1. 用不同颜色标注上行（蓝色）和下行（红色）路径
  2. 实时显示桶1和桶2的数值变化
  3. DFS时高亮当前节点，用粒子效果表示贡献传递
- **复古风格**：
  - 8位像素树结构，节点显示为16x16像素方块
  - 音效：玩家路径生成时播放“叮”，桶更新时播放“哔”
  - Canvas绘制桶数值变化曲线，用不同颜色区分上下行统计

---

## 题解清单（≥4星）

### 1. greenlcat（5星）
**亮点**：
- 详细推导公式并给出完整代码
- 使用链式前向星存储差分标记
- 处理LCA重复计算的边界条件

**核心代码**：
```cpp
void dfs2(int x) {
    int t1 = b1[w[x]+dep[x]], t2 = b2[w[x]-dep[x]+SIZE];
    for(int i=h[x]; i; i=E[i].next) {
        int y = E[i].to;
        if(y == fa[x][0]) continue;
        dfs2(y);
    }
    b1[dep[x]] += js[x]; // 上行贡献
    for(int i=h1[x]; i; i=e1[i].next) // 下行贡献
        b2[dist[e1[i].to]-dep[t[e1[i].to]]+SIZE]++;
    ans[x] += b1[w[x]+dep[x]] - t1 + b2[w[x]-dep[x]+SIZE] - t2;
}
```

### 2. 一扶苏一（4星）
**亮点**：
- 分测试点给出部分分解法
- 使用vector存储差分标记
- 对链式结构单独优化

**核心思路**：
```cpp
void lian() {
    // 处理链状结构的特殊解法
    for(int i=1; i<=m; ++i) {
        if(MU[i].t >= MU[i].s) ++rt[MU[i].s];
        else ++lft[MU[i].s];
    }
    std::sort(MU+1, MU+1+m);
    // 使用双指针维护当前时间窗口
}
```

### 3. Engulf（4星）
**亮点**：
- 线段树合并实现复杂统计
- 处理负数下标问题
- 完整注释代码结构

**差分处理**：
```cpp
void modify(int &p, int l, int r, int x, int v) {
    if(!p) p = ++idx;
    if(l == r) { sum[p] += v; return; }
    int mid = (l+r)>>1;
    x <= mid ? modify(ls[p], l, mid, x, v)
             : modify(rs[p], mid+1, r, x, v);
    up(p);
}
```

---

## 相似题目推荐
1. **P3258 [JLOI2014]松鼠的新家**  
   （树上差分经典题）
2. **P4556 [Vani有约会]雨天的尾巴**  
   （线段树合并+树上差分）
3. **P3398 仓鼠找sugar**  
   （LCA与路径相交判断）

---

## 个人心得摘录
> "在计算LCA处贡献时，如果w[LCA] = dep[s]-dep[LCA]，会同时被上行和下行统计，需要手动减1。这个边界条件调试了整整3小时才找到" —— greenlcat

> "将路径拆分为上下行后，发现可以用两个独立桶统计，这是解题的关键突破口。不要试图用统一公式处理所有情况" —— 一扶苏一

---

## 可视化实现（节选）
```javascript
// Canvas绘制树结构
function drawTree() {
  ctx.fillStyle = "#2c3e50";
  nodes.forEach(node => {
    ctx.fillRect(node.x*50, node.y*50, 16, 16); 
  });
}

// 更新桶显示
function updateBuckets() {
  ctx.fillStyle = "#3498db";
  ctx.fillText(`上行桶: ${bucket1.join(' ')}`, 10, 300);
  ctx.fillStyle = "#e74c3c"; 
  ctx.fillText(`下行桶: ${bucket2.join(' ')}`, 10, 320);
}

// 音效触发
function playSound(type) {
  const sfx = {
    add: new Audio('data:audio/wav;base64,UklGRl...'), 
    remove: new Audio('data:audio/wav;base64,UklGRl...')
  };
  sfx[type].play();
}
```

---
处理用时：76.83秒
# 题目信息

# [Cnoi2019] 雪松果树

## 题目背景

幻想乡，冬。

一年一度，生长在高山上的雪松果树又结果了。

Cirno 不知从哪弄到了 $1,2,3\cdots9$ 颗雪松果,然后很开心的吃掉了其中 $6$ 颗，最后还剩最后 $1$ 颗。

Cirn o因为以后吃不到雪松果而感到忧愁,于是决定种在美丽的雾之湖畔。

第一天,发芽。

第二天,雪松果树长成了一颗参天大树, 上面长满了雪松果。

Cirno 在雪松果成熟之前早有一些问题想知道，但现在她忙于收集雪松果，就把问题丢给了你。

## 题目描述

雪松果树是一个以 $1$ 为根有着 $N$ 个节点的树。

除此之外, Cirno还有 $Q$ 个询问，每个询问是一个二元组 $(u,k)$ ,表示询问 $u$ 节点的 $k$-cousin 有多少个。

我们定义:

> 节点 $u$ 的 $1$-father 为 路径 $(1, u)$ （不含 u）上距 u 最近的节点
>
> 节点 $u$ 的 $k$-father 为 节点 「$u$ 的 $(k-1)$-father」 的 1-father
>
> 节点 $u$ 的 $k$-son 为所有 $k$-father 为 $u$ 的节点
>
> 节点 $u$ 的 $k$-cousin 为 节点「 $u$ 的 $k$-father」的 $k$-son (不包含 $u$ 本身)

## 说明/提示

数据范围：

对于0%-10%的数据 $N,Q \le 100$

对于10%-20%的数据 $N \le 100,Q \le 10^6$

对于 20%-30% 的数据 $N \le 10^5,Q \le100$

对于 30%-35% 的数据 $N \le 10^4,Q \le 5000$

对于 35%-50% 的数据 $N \le 10^5,Q \le 10^5$

对于 50%-70% 的数据 保证树随机

对于 70%-100% 的数据 $N,Q \le 10^6$

另外存在一组记 $20$ 分的 hack 数据。

## 样例 #1

### 输入

```
5 2
1 2 1 4
2 1
3 2```

### 输出

```
1 1```

# AI分析结果



## 唯一算法分类
**树上离线处理 + 深度桶统计**

---

## 综合分析与结论
### 核心算法流程
1. **k级祖先求解**：通过DFS栈记录当前路径，离线查询时直接取栈中对应位置的祖先节点
2. **深度桶统计**：维护全局计数器数组，在DFS过程中：
   - 进入子树前记录当前深度计数
   - 遍历子树后再次查询计数，差值即为子树中该深度的节点数
3. **差分思想**：利用DFS序将子树查询转化为区间查询，通过前缀和思想离线处理

### 关键可视化设计
1. **树结构展示**：使用Canvas绘制树形结构，当前访问节点高亮为红色，祖先链标记为橙色
2. **深度桶动画**：右侧面板展示桶数组，当访问节点时对应深度数值跳动增长
3. **栈轨迹演示**：底部显示DFS栈的实时状态，用像素方块表示栈内元素，查询时高亮对应位置
4. **8-bit音效**：
   - 节点访问时播放短促的"哔"声（Web Audio生成方波）
   - 完成子树统计时播放上升音调
   - 错误查询（如k过大）时播放低沉警示音

---

## 题解清单（≥4星）

### 1. Autre的题解（5星）
**核心亮点**：
- O(n)时间复杂度的最优解法
- 双DFS过程分别处理祖先查询与深度统计
- 仅使用基础数组和vector，空间效率极高
```cpp
void ganc(int u) {
    stk[++top] = u;
    for(auto[i,k] : q[u]) 
        if(top > k) h[stk[top-k]].emplace_back(i, dep[u]+k);
    for(int v : g[u]) ganc(v);
    top--;
}

void gans(int u) {
    for(auto[i,k] : h[u]) ans[i] -= ct[k]; // 记录进入前的计数
    ct[dep[u]]++;
    for(int v : g[u]) gans(v);
    for(auto[i,k] : h[u]) ans[i] += ct[k]; // 差值即为子树内数量
}
```

### 2. feecle6418的题解（4星）
**核心亮点**：
- 长链剖分优化空间复杂度
- 指针分配内存实现动态规划
```cpp
f[u] = id; id += len[u]; // 动态分配长链内存
for(int v : son[u]) {
    f[v] = f[u] + 1; // 子节点共享父节点内存空间
    dfs(v);
    f[u][k] += f[v][k-1]; // 合并子链信息
}
```

### 3. 夜猫子驱蚊器的题解（4星）
**核心亮点**：
- 利用DFS序二分查找实现在线查询
- 按深度预分配vector空间避免内存浪费
```cpp
vector<int> depth_bucket[MAXN];
void preprocess() {
    for(int u=1; u<=n; u++)
        depth_bucket[dep[u]].push_back(dfn[u]);
    for(int d=1; d<=max_dep; d++)
        sort(depth_bucket[d].begin(), depth_bucket[d].end());
}

int query(int d, int L, int R) {
    auto &vec = depth_bucket[d];
    return upper_bound(vec.begin(), vec.end(), R) 
         - lower_bound(vec.begin(), vec.end(), L);
}
```

---

## 同类型题推荐
1. **P1600 [NOIP2016] 天天爱跑步**（树上路径统计）
2. **P4211 [LNOI2014] LCA**（离线处理深度相关查询）
3. **P6623 [省选联考2020] 树**（异或与深度统计结合）

---

## 个人心得摘录
> "调试时发现vector的capacity远大于size导致MLE，改用链表结构后空间骤降。学习到指针式内存分配的精妙，通过预先计算每个节点的询问数，精准分配内存块" —— 皎月半洒花

> "意识到深度桶的差分性质后，整个问题从O(nlogn)优化到O(n)，如同顿悟般畅快。调试时用颜色标记不同深度的节点分布，验证了算法的正确性" —— Autre

---

## 可视化实现要点（伪代码）
```javascript
// Canvas绘制树结构
function drawTree(node, x, y) {
    ctx.fillStyle = node == current ? '#FF4444' : '#44AAFF';
    drawCircle(x, y, 15); 
    node.children.forEach((child, i) => {
        let cx = x + (i - 0.5)*80;
        drawLine(x, y, cx, y+80);
        drawTree(child, cx, y+80);
    });
}

// 深度桶动画
function updateBucket(depth) {
    bucket[depth]++;
    anime({
        targets: `#bucket-${depth}`,
        scale: [1, 1.2, 1],
        duration: 200
    });
}

// 8-bit音效生成
function playSound(freq) {
    let osc = audioCtx.createOscillator();
    osc.type = 'square';
    osc.frequency.value = freq;
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(0.05);
}
```

---

## 核心算法代码（完整实现）
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6+5;
vector<int> g[N], h[N];
int stk[N], top, dep[N], ans[N], ct[N];

void dfs1(int u) {
    stk[++top] = u;
    for(auto [i,k] : q[u]) // 伪代码，实际用结构体存储询问
        if(top > k) h[stk[top-k]].emplace_back(i, dep[u]+k);
    for(int v : g[u]) dfs1(v);
    top--;
}

void dfs2(int u) {
    for(auto [i,k] : h[u]) ans[i] -= ct[k];
    ct[dep[u]]++;
    for(int v : g[u]) dfs2(v);
    for(auto [i,k] : h[u]) ans[i] += ct[k];
}

int main() {
    // 建树及处理输入
    dfs1(1); 
    memset(ct, 0, sizeof ct);
    dfs2(1);
    // 输出答案ans[1..m]
}
```

---
处理用时：72.69秒
# 题目信息

# [AHOI2021初中组] 地铁

## 题目背景

AHOI2021 初中组 T4

**你可以选择跳过背景部分。**

小可可发现自己所学算法在生活中其实无大用，感觉十分沮丧。小雪见状还是嘀咕了几句“应该还是有用的吧”。

“不过没用又怎么样呢？算法只不过是一块名牌大学的敲门砖罢了。”

“你这话我就不同意了。跳蚤国王曾经和我说过，以后科研或者工作中我们还会和信息学竞赛中的某些东西重逢，虽然可能不会再有信息学竞赛这么难。

“除开功利的因素之外，搞信息学竞赛还是能享受到很多思考的乐趣的。”

“你说的也对。每次我在考场上不会做质疑这题是不是有问题的时候，考后看题解总是懊恼又快乐——这么自然的思路我怎么想不到呢！”

一颗理论计算机科学家的种子悄悄萌芽。

沙尘暴突然神奇般的散去了。实在坐不下去的两人决定出门坐地铁瞎逛，随性下车。即使没有刻意为之，小雪在地铁上却想出了一个有意思的问题，你能解决吗？

## 题目描述

B 市的地铁历史悠久，小雪和小可可乘坐的 X 号线是环形路线，上面分布着 $n$ 个车站，**相邻两个车站之间的铁路长度为正整数**。现在小雪进行了一些观察，得到了 $m$ 条信息，第 $i$ 条信息是如下形式之一：

1. 环上顺时针由 $S_i$ 到 $T_i$ 的一段距离不小于一个给定的值 $L_i$（$S_i$ 和 $T_i$ 是两个车站）；
2. 环上顺时针由 $S_i$ 到 $T_i$ 的一段距离不大于一个给定的值 $L_i$。

小雪想要你计算最后 X 线地铁的总长度有多少种不同的合法取值。

## 说明/提示

【样例 1 解释】

定义数组 $d[1..4]$，其中 $d[i]$ 表示 $i$ 号车站顺时针到 $i+1$ 号车站的铁路长度。

1. $d=[1,2,2,2]$，总长度为 $7$；
2. $d=[1,2,2,3]$，总长度为 $8$；
3. $d=[1,2,2,4]$，总长度为 $9$；
4. $d=[1,2,3,4]$，总长度为 $10$。

可以证明，不存在其他的可能长度，于是答案为 $4$。

【样例 2 解释】

$3$ 号车站顺时针到 $1$ 号车站的铁路长度可以为任意正整数。

【数据范围与提示】

- 对于 $30\%$ 的数据，保证 $n,m \le 9$，$L_i \le 5$；
- 对于另外 $15\%$ 的数据，保证 $T_i$ 是 $S_i$ 顺时针方向后第一个车站；
- 对于另外 $20\%$ 的数据，保证 $T_i$ 是 $S_i$ 顺时针方向后第二个车站；
- 对于另外 $25\%$ 的数据，保证 $n,m \le 50$；
- 对于 $100\%$ 的数据，保证 $3 \le n \le 500$，$1 \le m \le 500$，$1 \le L_i \le 10^9$。

## 样例 #1

### 输入

```
4 6
1 1 3 3
2 2 4 5
1 2 4 4
1 3 1 4
2 4 2 5
1 4 2 3```

### 输出

```
4```

## 样例 #2

### 输入

```
3 2
2 1 2 1
2 2 3 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
见附加文件的 subway3.in。 ```

### 输出

```
见附加文件的 subway3.ans。```

# AI分析结果



# [AHOI2021初中组] 地铁 题解分析

## 算法分类
**差分约束系统 + 二分答案**

---

## 题解思路与解决难点

### 核心思路
1. **差分约束建模**：  
   - 设 $d_i$ 为 1 号车站到 i 号车站的顺时针距离，环长 $C$ 为总长度。  
   - 将题目约束转化为差分不等式：  
     - 类型1（不小于 $L$）：若 $S<T$，则 $d_S \le d_T - L$；若 $S \ge T$，则 $d_S \le d_T + C - L$。  
     - 类型2（不大于 $L$）：若 $S<T$，则 $d_T \le d_S + L$；若 $S \ge T$，则 $d_T \le d_S + L - C$。  
   - 相邻车站约束：$d_{i+1} \ge d_i + 1$，即 $d_i \le d_{i+1} - 1$。

2. **环长 $C$ 的二分**：  
   - 二分 $C$ 的上下界，每次代入 $C$ 的值构建差分约束图，检测负环。  
   - 若存在负环，根据其系数 $k$（与 $C$ 相关的边权和）调整二分方向：  
     - $k>0$ → 增大 $C$ 的上界  
     - $k<0$ → 减小 $C$ 的上界  
     - $k=0$ → 无解  

3. **负环检测**：  
   - 使用 Bellman-Ford 或 SPFA 遍历边集，判断是否存在负环。  
   - 通过回溯路径找到负环中的关键边，计算其系数 $k$。

---

## 题解评分（≥4星）

### 1. syksykCCC（★★★★☆）
- **亮点**：清晰推导差分约束模型，详细说明二分策略与负环处理。  
- **代码**：使用 Bellman-Ford 判负环，逻辑简洁，变量命名规范。  
- **优化**：通过回溯路径快速定位负环的系数 $k$。

### 2. meyi（★★★★★）
- **亮点**：官方题解，代码实现与理论严格对应，注释完整。  
- **关键点**：将 $C$ 作为全局变量处理，二分逻辑高效。  
- **可读性**：代码结构清晰，适合作为标准模板。

### 3. Pengzt（★★★★☆）
- **亮点**：使用 SPFA 实现，解释负环检测的细节（入队次数与回溯）。  
- **心得**：强调 SPFA 中入队次数超过 $n$ 不一定在环上，需回溯验证。

---

## 核心代码实现

### 边的添加与负环检测（syksykCCC 代码片段）
```cpp
void add(int a, int b, int c, int d) {
    u[++e] = b; v[e] = a; k[e] = c; b[e] = d;
}

int solve(ll mid) {
    for (int i = 1; i <= n; ++i) d[i] = bigINF;
    d[1] = 0;
    // Bellman-Ford 遍历边
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= e; ++j)
            if (d[v[j]] > d[u[j]] + k[j] * mid + b[j]) {
                d[v[j]] = d[u[j]] + k[j] * mid + b[j];
                pre[v[j]] = j;
            }
    // 检测负环并计算系数 k
    for (int j = 1; j <= e; ++j)
        if (d[v[j]] > d[u[j]] + k[j] * mid + b[j]) {
            int x = u[j];
            for (int i = 0; i < n; ++i) x = u[pre[x]];
            int coef = k[pre[x]];
            for (int y = u[pre[x]]; y != x; y = u[pre[y]]) coef += k[pre[y]];
            return coef > 0 ? 1 : -1;
        }
    return 0;
}
```

---

## 可视化与动画设计

### 核心流程动画
1. **差分约束图构建**：  
   - 显示每个车站节点和约束边（颜色区分类型1/2），边权随 $C$ 动态更新。  
   - **高亮**当前处理的边，并标注其表达式（如 $d_2 \le d_1 + C - L$）。

2. **二分过程**：  
   - 展示当前二分区间 $[L, R]$，标记中点 $mid$ 和检测结果（✅合法/❌负环）。  
   - 负环检测时，用红色高亮环路径，显示系数 $k$ 和调整方向。

3. **复古像素风格**：  
   - **节点**：8-bit 风格车站图标，编号显示在像素方块中。  
   - **边**：箭头表示方向，权值以像素字体浮动显示。  
   - **音效**：  
     - 正确检测：8-bit 成功音效（↑音调）。  
     - 发现负环：短促警示音（↓音调）。

### 交互设计
- **控制面板**：滑动条调节二分速度，按钮单步执行。  
- **自动演示**：AI 自动完成二分过程，用户可暂停观察细节。

---

## 相似题目推荐
1. [P1993] 小 K 的农场（基础差分约束）  
2. [P4926] 倍杀测量者（二分答案 + 差分约束）  
3. [P3275] 糖果（复杂约束与环处理）

---

## 个人心得摘录
> **调试教训**（Pengzt）：SPFA 中入队次数超限不一定在环上，需通过回溯确定环的实际位置，否则会误判。  
> **优化技巧**（meyi）：将 $C$ 的系数分离存储，避免重复计算，提升二分效率。

---
处理用时：72.77秒
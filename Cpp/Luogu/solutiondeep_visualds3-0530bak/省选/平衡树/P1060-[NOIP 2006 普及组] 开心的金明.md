# 题目信息

# [NOIP 2006 普及组] 开心的金明

## 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $N$ 元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 $N$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1-5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过 $N$ 元（可以等于 $N$ 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第$j$件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,…,j_k$，则所求的总和为：

$$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2} …+v_{j_k} \times w_{j_k}$$

请你帮助金明设计一个满足要求的购物单。

## 说明/提示

NOIP 2006 普及组 第二题


## 样例 #1

### 输入

```
1000 5
800 2
400 5
300 5
400 3
200 2
```

### 输出

```
3900```

# AI分析结果



# 算法分类  
**动态规划 - 01背包**

---

## 题解思路与核心难点  
### 核心逻辑推导  
题目转化为背包问题：  
- **背包容量**：总预算 N  
- **物品重量**：物品价格 v  
- **物品价值**：v * w（价格与重要度乘积）  

动态规划状态转移方程：  
```math  
dp[j] = max(dp[j], dp[j - v[i]] + v[i] * w[i])  
```  
**关键实现细节**：  
1. **一维数组倒序遍历**：避免重复选择同一物品  
2. **输入预处理**：将价值提前计算为 v*w  
3. **空间优化**：仅用一维数组代替二维数组  

### 解决难点  
- **问题转换**：理解价格与重要度的乘积作为价值  
- **循环顺序**：逆向遍历金额确保物品只选一次  
- **边界处理**：j >= v[i] 时才进行转移  

---

## 题解评分（≥4星）  
1. **oier1459078309（5星）**  
   - 亮点：代码简洁高效，完整展示一维优化模板  
   - 优化：给出常数优化版本（sumw 剪枝）  

2. **qhr2023（4星）**  
   - 亮点：代码极简，注释清晰  
   - 改进：可补充变量命名说明  

3. **phigy（4星）**  
   - 亮点：对比 DP 与 DFS 解法，适合教学  
   - 心得：指出 DFS 耗时点与 O2 优化效果  

---

## 最优思路提炼  
**核心代码片段**  
```cpp  
for (int i=1; i<=n; i++) {  
    for (int j=N; j>=v[i]; j--) {  
        dp[j] = max(dp[j], dp[j-v[i]] + v[i]*w[i]);  
    }  
}  
```  
**关键技巧**：  
1. **滚动数组降维**：空间复杂度从 O(nm) → O(m)  
2. **价值预计算**：输入时直接存储 v*w 减少重复运算  
3. **剪枝优化**：动态调整循环下界（sumw 累计）  

---

## 同类型题推荐  
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)（01背包模板）  
2. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)（依赖背包）  
3. [P1049 装箱问题](https://www.luogu.com.cn/problem/P1049)（体积即价值变种）  

---

## 可视化方案设计  
### 动画演示（像素风格）  
**界面元素**：  
- 背包网格：横向坐标表示金额（0~N），纵向表示物品  
- 物品图标：8位像素风格，显示价格和闪烁的价值  

**动态效果**：  
1. **高亮当前物品**：紫色边框闪烁  
2. **金额填充**：绿色进度条表示 j 的遍历过程  
3. **DP更新特效**：更新 dp[j] 时显示黄色光晕  

**音效设计**：  
- 选择物品：NES 风格 "哔" 声  
- 更新最大值：8位上扬音阶  
- 错误操作：短促 "嘟" 声  

### 自动演示逻辑  
```javascript  
// 伪代码示例  
function autoPlay() {  
  for (let i=0; i<items.length; i++) {  
    highlightItem(i);  
    for (let j=N; j >= items[i].v; j--) {  
      moveCursor(j);  
      if (updateDP(j)) playSuccessSound();  
      delay(200);  
    }  
  }  
}  
```  

---

## 个人心得摘录  
> "DFS 在 m=25 时接近时间极限，开 O2 后速度提升 3.7 倍，说明剪枝的重要性" —— phigy  
> "一维数组必须倒序遍历，正序会变成完全背包，这是初学者的常见误区" —— kind_Ygg  

---

## 完整代码（最优解）  
```cpp  
#include <iostream>  
using namespace std;  

int dp[30005], n, m;  

int main() {  
    cin >> m >> n;  
    for(int i=1; i<=n; i++) {  
        int v, w;  
        cin >> v >> w;  
        w *= v;  
        for(int j=m; j>=v; j--)  
            dp[j] = max(dp[j], dp[j-v]+w);  
    }  
    cout << dp[m];  
    return 0;  
}  
```

---
处理用时：60.98秒
# 题目信息

# 填涂颜色

## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 30$。


## 样例 #1

### 输入

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

### 输出

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

# AI分析结果



### 算法分类
**广度优先搜索（BFS）/ 深度优先搜索（DFS）**

---

### 综合分析与结论
**核心思路**：  
通过扩展矩阵边界或从边界出发，标记所有可到达的「外部0」，未被标记的0即为闭合圈内的0，需改为2。  
**解决难点**：  
- 闭合圈形状任意，直接判断内部0困难  
- 外部0可能分散在多个区域，需统一标记  
**算法流程**：  
1. **扩展边界**：在原始矩阵外加一圈0，形成虚拟边界  
2. **标记外部0**：从虚拟边界出发，用BFS/DFS遍历所有可到达的0并标记  
3. **输出结果**：未被标记的0改为2，其他恢复原值  

**可视化设计**：  
- **动画方案**：  
  - 初始矩阵显示为灰白网格（0为白色，1为黑色）  
  - BFS搜索时，外部0逐步变为绿色（扩散效果）  
  - 最终内部0自动变为红色（2）  
- **高亮操作**：  
  - 当前处理的单元格用黄色边框闪烁  
  - 队列中的待处理节点显示为蓝色半透明  
- **交互功能**：  
  - 步进控制：支持暂停/继续/单步执行  
  - 速度调节：拖动滑块调整动画速度  

---

### 题解清单（评分≥4星）
1. **LMB_001（5星）**  
   **亮点**：DFS从虚拟边界(0,0)出发，染色外部0，逻辑简洁  
   **代码片段**：  
   ```cpp
   void dfs(int p, int q) {
       if (越界或已访问) return;
       a[p][q] = 1; // 标记外部0
       for (四个方向) dfs(p+dx[i], q+dy[i]);
   }
   ```

2. **冰冻赤道（4.5星）**  
   **亮点**：BFS遍历四周边界点，显式处理行列边界  
   **代码片段**：  
   ```cpp
   for (i=1; i<=n; i++) { // 遍历上下边界
       if (a[1][i] != 1) bfs(1, i);
       if (a[n][i] != 1) bfs(n, i);
   }
   ```

3. **zhy137037（4星）**  
   **亮点**：对比BFS与栈实现DFS，深入解析搜索原理  
   **核心思想**：用栈模拟递归DFS，统一搜索框架  

---

### 最优思路提炼
**关键技巧**：  
1. **虚拟边界法**：扩展矩阵为(n+2)×(n+2)，避免处理复杂边界条件  
2. **逆向标记**：从外向内标记可到达的0，剩余即为闭合区域  
3. **染色同步**：在搜索过程中直接修改原数组，减少额外空间  

**代码实现**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[35][35], n;

void bfs(int x, int y) {
    queue<pair<int, int>> q;
    q.push({x, y});
    a[x][y] = 3; // 标记外部0为3
    while (!q.empty()) {
        auto [x, y] = q.front(); q.pop();
        for (int dx : {-1, 0, 1}) for (int dy : {-1, 0, 1}) 
            if (abs(dx)+abs(dy)==1) { // 四方向
                int nx = x+dx, ny = y+dy;
                if (nx>=0 && nx<=n+1 && ny>=0 && ny<=n+1 && a[nx][ny]==0) {
                    a[nx][ny] = 3;
                    q.push({nx, ny});
                }
            }
    }
}

int main() {
    cin >> n;
    // 扩展边界
    for (int i=1; i<=n; ++i)
        for (int j=1; j<=n; ++j)
            cin >> a[i][j];
    bfs(0, 0); // 从虚拟边界开始
    // 输出：3转0，0转2
    for (int i=1; i<=n; ++i) {
        for (int j=1; j<=n; ++j)
            cout << (a[i][j]==3 ? 0 : a[i][j] ? 1 : 2) << " ";
        cout << "\n";
    }
}
```

---

### 相似题目推荐
1. **P1506 拯救oibh总部**（同样需要标记闭合区域）  
2. **P1141 01迷宫**（连通块标记的变体）  
3. **P2296 寻找道路**（逆向搜索思想的应用）  

---

### 可视化方案（复古像素版）
**实现要点**：  
1. **8位风格**：  
   - 使用16色调色板：外部0=浅绿(#7FFFD4)，内部0=红色(#FF4040)，1=黑色  
   - 单元格渲染为16×16像素块，带1像素黑色边框  
2. **动画流程**：  
   - 初始化时播放FC开机音效  
   - BFS每扩散一步，播放「哔」声效  
   - 找到最终解时播放《超级马里奥》过关音效  
3. **自动演示AI**：  
   ```javascript
   function autoRun() {
       if (queue.length) {
           let [x, y] = queue.shift();
           drawPixel(x, y); // 更新当前单元格
           requestAnimationFrame(autoRun);
       }
   }
   ```  
4. **积分系统**：  
   - 正确标记一个外部0得10分  
   - 连续无错误标记触发2倍积分  
   - 最终剩余内部0数量转换为附加分  

---

通过上述分析与实现，可清晰理解闭合圈问题的核心解决思路，并通过可视化工具加深对搜索算法的理解。

---
处理用时：86.84秒
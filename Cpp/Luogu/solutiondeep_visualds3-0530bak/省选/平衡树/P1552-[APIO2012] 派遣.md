# 题目信息

# [APIO2012] 派遣

## 题目背景

在一个忍者的帮派里，一些忍者们被选中派遣给顾客，然后依据自己的工作获取报偿。


## 题目描述

在这个帮派里，有一名忍者被称之为 Master。除了 Master 以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。

现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，你就不需要支付管理者的薪水。

   
你的目标是在预算内使顾客的满意度最大。这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。

   
写一个程序，给定每一个忍者 $i$ 的上级 $B_i$，薪水 $C_i$，领导力 $L_i$，以及支付给忍者们的薪水总预算 $M$，输出在预算内满足上述要求时顾客满意度的最大值。


## 说明/提示

$1 \le N \le 10^5$，$1 \le M \le 10^9$，$0 \le B_i \lt i$，$1 \le C_i \le M$，$1 \le L_i \le 10^9$。

对于 $30\%$ 的数据，$N \le 3000$。


## 样例 #1

### 输入

```
5 4
0 3 3
1 3 5
2 2 2
1 2 4
2 3 1
```

### 输出

```
6
```

# AI分析结果



### 算法分类
左偏树（可并堆）

---

### 题解思路与难点分析
**核心逻辑**：对于每个节点，维护其子树中的薪水大根堆，合并子树堆后弹出最大值直到满足预算，用领导力 × 堆大小更新答案。

**算法要点**：
1. **可并堆的合并**：叶子节点自底向上合并到父节点堆中
2. **贪心调整**：合并后若总薪水超过预算，持续弹出堆顶最大值
3. **领导力计算**：每个节点的贡献为 `领导力 × 当前堆大小`

**解决难点**：
1. 快速合并子树数据 → 左偏树 O(1) 合并
2. 动态调整满足预算 → 大根堆 + 总和维护
3. 避免重复计算 → 自底向上的合并顺序

---

### 题解评分（≥4星）
1. **KingBenQi（★★★★☆）**  
   左偏树标准解法，代码清晰，合并逻辑与弹出操作完整，但未处理堆为空时的边界条件。

2. **枫林晚（★★★★☆）**  
   类似思路但更注重父子堆合并细节，明确堆入口为 `rt[y]`，注释明确。

3. **amazingOZR（★★★★☆）**  
   最简短的左偏树实现，外置 sum/size 变量维护，代码可读性强。

---

### 最优思路提炼
**关键技巧**：
1. **逆向合并**：从叶子节点向上合并，保证父节点能访问完整子树
2. **大根堆优化**：优先弹出高薪节点，快速逼近预算约束
3. **外置变量维护**：在堆外独立维护 sum 和 size，避免堆结构膨胀

**思维突破点**：  
将子树选择问题转化为动态维护前 k 小值问题，利用树形结构特性实现高效合并。

---

### 相似题目推荐
1. **P3377【模板】左偏树**（可并堆基础）
2. **P1090 合并果子**（堆的贪心应用）
3. **P4556 雨天的尾巴**（线段树合并与树形结构）

---

### 可视化与算法演示设计
**核心动画逻辑**：
```python
# 伪代码演示自底向上的合并过程
for node in reversed(dfs_order):
    merge_child_heaps(node)
    while sum > M:
        pop_max(node)
    highlight(node.leader * heap_size)
```

**可视化要素**：
1. **树形结构绘制**：用连线表示父子关系，节点大小反映堆大小
2. **堆合并特效**：子堆以粒子动画形式飞向父节点
3. **数值面板**：实时显示当前节点的 sum/size/领导力
4. **高亮机制**：被弹出的最大值显示为红色闪烁，新合并的堆显示为绿色脉冲

**复古像素风格**：
- **调色板**：16色 FC 风格（深绿堆背景，亮黄高亮）
- **音效**：合并时播放 8-bit "blip"，弹出时播放 "explosion" 音效
- **自动演示**：按 DFS 序自动播放，支持暂停/单步调试

---

### 关键代码片段
**左偏树核心操作**：
```cpp
int merge(int x, int y) {
    if (!x || !y) return x + y;
    if (val[x] < val[y]) swap(x, y); // 大根堆维护
    rs[x] = merge(rs[x], y);
    if (dis[ls[x]] < dis[rs[x]]) swap(ls[x], rs[x]);
    dis[x] = dis[rs[x]] + 1;
    return x;
}

void dfs(int u) {
    for (auto v : children[u]) {
        dfs(v);
        heap[u] = merge(heap[u], heap[v]);
        sum[u] += sum[v]; size[u] += size[v];
    }
    while (sum[u] > M) {
        sum[u] -= val[heap[u]]; 
        heap[u] = merge(ls[heap[u]], rs[heap[u]]);
        size[u]--;
    }
    ans = max(ans, L[u] * size[u]);
}
```

---

### 结论
左偏树解法以 O(n log n) 时间高效处理子树合并与动态调整问题，逆向合并与贪心删除机制是该题的核心突破点。通过外置变量维护堆属性和大根堆结构，实现了代码简洁与性能的平衡。

---
处理用时：62.12秒
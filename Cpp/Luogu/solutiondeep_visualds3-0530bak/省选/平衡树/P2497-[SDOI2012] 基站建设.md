# 题目信息

# [SDOI2012] 基站建设

## 题目描述

up 主家终于买电脑了，但是接下来有各种问题要处理。首要解决的问题就是网络问题。他要从移动公司开始，通过一些基站来传递网络到他家。

为了简化问题，我们假设移动公司，所有的基站、up 主家位于同一条直线上，他们都位于这一条直线上的某一点 $x$，这些点**可能**会重合。每个基站发射和接收的范围都是一个切于地面的圆，发射的半径 $r$ 是固定的，接收半径 $r'$ 是可调的的。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/nh8yxjx5.png)

一个基站 $i$ 如果想从另一个基站 $j$ 接收到信号（当且仅当 $x_j<x_i$），必须满足 $i$ 的接收范围与 $j$ 的发射范围**相切**，且需要付 $\sqrt{r'_i}$ 的额外费用。启动每一个点 $i$ 都需要费用 $v_i$。

up 主家如果能接收到某个基站的信号，只需要这个点的发射范围与 up 主家所在的竖线相切或相交即可，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5t4v8687.png)

当然费用越少就越好咯，于是 up 主想要请你帮他的忙。

## 说明/提示

对于 $100\%$ 的数据 $n\le5\times 10^5$，$x_i,m \le 10^{12}$，$v_i \le 10000$

## 样例 #1

### 输入

```
10 33
5 4 660
10 2 2040
11 6 3207
14 5 2006
18 3 6130
19 9 3363
22 1 1265
25 8 2836
27 10 7961
29 7 9075```

### 输出

```
3501.000```

# AI分析结果



### 唯一算法分类
**斜率优化动态规划（李超线段树实现）**

---

### 综合分析与结论
本题核心是动态规划结合几何推导与高效优化。通过几何分析推导出基站间的费用公式，转化为斜率优化问题，最终通过李超线段树维护直线最小值实现 O(n log n) 复杂度。

**核心难点与解决思路：**
1. **几何推导**：通过勾股定理推导接收半径与基站坐标的关系，得到费用公式。
2. **状态转移方程**：设计动态规划方程 \( f_i = \min(f_j + \frac{x_i - x_j}{2\sqrt{r_j}} + v_i) \)。
3. **斜率优化转化**：将方程转化为直线形式 \( y = kx + b \)，其中 \( k \) 与 \( j \) 相关，\( x \) 为 \( x_i \)。
4. **李超线段树**：离散化后维护直线集合，支持快速插入和最小值查询。

**可视化设计思路：**
- **动画流程**：以像素网格表示线段树节点，插入新直线时高亮对应的离散化区间，查询时显示当前 \( x_i \) 的扫描线。
- **颜色标记**：当前处理的基站（红色）、插入的直线（蓝色）、最优决策点（绿色）。
- **复古风格**：8-bit 音效在插入/查询时触发，背景循环芯片音乐，线段树节点以方块表示，直线参数显示为像素文字。

---

### 题解清单（4星及以上）
1. **TKXZ133（5星）**
   - **亮点**：完整推导公式，李超线段树实现简洁，离散化处理巧妙。
   - **代码**：预处理离散化坐标，查询时直接取最小值，逻辑清晰。

2. **xuzz（4星）**
   - **亮点**：使用离散化李超线段树，避免动态开点，代码更紧凑。
   - **心得**：强调预处理避免重复计算根号。

3. **Seauy（4星）**
   - **亮点**：CDQ分治维护凸包，利用 \( x_i \) 单调性优化查询步骤。
   - **技巧**：归并排序减少复杂度，预处理斜率避免重复计算。

---

### 核心代码实现（TKXZ133题解）
```cpp
struct Line { double k, b; };
struct ST { // 李超线段树节点
    int a[N<<2];
    void add(int p, int l, int r, int id) {
        if (l == r) { if (calc(id,l) < calc(a[p],l)) a[p] = id; return; }
        // ... 递归插入直线
    }
    double query(int p, int l, int r, int pos) {
        // ... 递归查询最小值
    }
} tree;

int main() {
    // 离散化处理
    sort(bx+1, bx+n+1);
    int tot = unique(bx+1, bx+n+1) - bx - 1;
    for (int i=1; i<=n; i++) 
        x[i] = lower_bound(bx+1, bx+tot+1, x[i]) - bx;
    
    line[1] = {1/(2*sqrt(r[1])), f[1] - x[1]/(2*sqrt(r[1]))};
    tree.add(1, 1, n, 1);
    
    for (int i=2; i<=n; i++) {
        f[i] = tree.query(1, 1, n, x[i]) + v[i];
        line[i] = {1/(2*sqrt(r[i])), f[i] - x[i]/(2*sqrt(r[i]))};
        tree.add(1, 1, n, i);
    }
}
```

---

### 相似题目推荐
1. **P3195 [HNOI2008]玩具装箱**（斜率优化经典题）
2. **P3628 [APIO2010]特别行动队**（凸包维护与斜率优化）
3. **P4027 [NOI2007]货币兑换**（动态凸包与决策单调性）

---

### 可视化与复古游戏化设计
**像素化李超线段树演示：**
1. **Canvas 绘制**：线段树节点显示为方格，每个节点存储当前最优直线ID，点击节点显示直线方程。
2. **音效触发**：
   - **插入直线**：短促“滴”声（8-bit 音效）。
   - **查询命中**：高音“叮”声。
3. **自动演示模式**：按基站顺序自动插入直线并查询，速度可调，显示当前最小费用。

**示例伪代码（JS Canvas片段）：**
```javascript
function drawNode(x, y, lineId) {
    ctx.fillStyle = '#8B8B83'; // 灰色背景
    ctx.fillRect(x*50, y*50, 48, 48);
    ctx.fillStyle = '#00FF00'; // 绿色文字
    ctx.fillText(`L${lineId}`, x*50 +5, y*50 +20);
}
```

---

### 个人心得摘录
- **调试教训**：离散化前未去重导致线段树越界（题解xuzz强调预处理）。
- **优化技巧**：预处理平方根值，避免重复计算（题解TKXZ133关键优化点）。

---

**总结**：本题通过几何推导与斜率优化的结合，展示了动态规划问题的高效处理方法。李超线段树与CDQ分治各具优势，实现时需注意离散化与预处理细节。可视化设计可增强对算法流程的理解，复古风格增添学习趣味。

---
处理用时：65.12秒
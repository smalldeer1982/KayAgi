# 题目信息

# [SCOI2014] 方伯伯的OJ

## 题目描述

方伯伯正在做他的 OJ。现在他在处理 OJ 上的用户排名问题。OJ 上注册了 $n$ 个用户，编号为 $1\sim n$，一开始他们按照编号排名。

方伯伯会按照心情对这些用户做以下四种操作，修改用户的排名和编号：

1. 操作格式为 $1\ \ x\ \ y$，意味着将编号为 $x$ 的用户编号改为 $y$，而排名不变，执行完该操作后需要输出该用户在队列中的位置，数据保证 $x$ 必然出现在队列中，同时，$y$ 是一个当前不在排名中的编号。
2. 操作格式为 $2\ \ x$，意味着将编号为 $x$ 的用户的排名提升到第一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。
3. 操作格式为 $3\ \ x$，意味着将编号为 $x$ 的用户的排名降到最后一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。
4. 操作格式为 $4\ \ k$，意味着查询当前排名为 $k$ 的用户编号，执行完该操作后需要输出当前操作用户的编号。

但同时为了防止别人监听自己的工作，方伯伯对他的操作进行了加密，即将四种操作的格式分别改为了：

- $1\ \ x+a\ \ y+a$；
- $2\ \ x+a$；
- $3\ \ x+a$；
- $4\ \ k+a$；
- 其中 $a$ 为上一次操作得到的输出，一开始 $a=0$。

例如：上一次操作得到的输出是 $5$，这一次操作的输入为：$1\ \ 13\ \ 15$ 因为这个输入是经过加密后的，所以你应该处理的操作是 $1\ \ 8\ \ 10$。

现在你截获了方伯伯的所有操作，希望你能给出结果。

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 10^8$，$1 \le m \le 10^5$。

输入保证对于所有的操作 $1,2,3$，$x$ 必然已经出现在队列中，同时对于所有操作 $1$，$1 \le y \le 2\times 10^8$，并且 $y$ 没有出现在队列中。

对于所有操作 $4$，保证 $1 \le k \le n$。

## 样例 #1

### 输入

```
10 10
1 2 11
3 13
2 5
3 7
2 8
2 10
2 11
3 14
2 18
4 9```

### 输出

```
2
2
2
4
3
5
5
7
8
11```

# AI分析结果



**唯一算法分类**：动态开点线段树/平衡树（区间合并与分裂）

---

### **综合分析与结论**
题目要求动态维护10^8量级的用户排名系统，核心难点在于：
1. 无法直接存储所有用户节点，需通过**区间合并**表示连续未修改的用户
2. 支持分裂操作：当用户被修改时将其所在区间拆分为三个子区间
3. 高效处理排名查询和位置调整

**核心算法流程**：
1. **动态开点数据结构**：使用平衡树（Splay/FHQ Treap）或线段树动态创建节点，初始仅存储整个1~n的区间
2. **区间分裂**：当操作涉及位置x时，找到其所属区间节点，将其拆分为`[l,x-1]`、`x`、`x+1,r`三个节点
3. **映射管理**：通过`map`记录每个编号对应的区间节点，快速定位需要操作的位置
4. **排名计算**：平衡树维护子树size，查询时通过左子树size确定排名偏移量

---

### **题解清单（≥4星）**
1. **Ameyax（Splay实现）** ⭐⭐⭐⭐  
   亮点：双平衡树分别管理排名和编号，通过`split`函数实现优雅的区间分裂，内存优化显著  
   调试心得：通过`splay`操作保证复杂度，通过`map.lower_bound`快速定位区间节点

2. **AubRain（动态开点线段树）** ⭐⭐⭐⭐  
   亮点：权值线段树+预留空间处理头尾操作，代码简洁（仅70行）  
   技巧：`len(l,r)=max(0,min(r,n)-max(l,1)+1)`实现自动区间有效性判断

3. **Froggy（动态开点Splay）** ⭐⭐⭐⭐  
   亮点：直接修改节点连接方式实现快速头尾插入，通过`split`函数演示标准化的区间分裂流程  
   代码特色：`change()`函数通过旋转操作直接重构树结构，避免多次删除/插入

---

### **最优思路与代码实现**
**核心代码片段（Splay分裂操作）**：
```cpp
void split(int x, int id){
    if(x->l == x->r) return;
    if(id == x->l){ // 左边界分裂
        auto left = new Node(x->l, x->l);
        x->l++;
        connect(left, x->left_child);
    } else if(id == x->r){ // 右边界分裂
        auto right = new Node(x->r, x->r);
        x->r--;
        connect(right, x->right_child);
    } else { // 中间分裂
        auto mid = new Node(id, id);
        auto left = new Node(x->l, id-1);
        auto right = new Node(id+1, x->r);
        connect(left, mid->left);
        connect(right, mid->right);
        replace(x, mid); // 替换原节点
    }
    update_sizes();
}
```

---

### **同类型题与推荐题目**
1. **P3960 [NOIP2017]列队**  
   同类动态区间分裂问题，需维护矩阵状队列

2. **P2596 [ZJOI2006]书架**  
   平衡树维护书籍顺序，支持插入/删除操作

3. **P3380 【模板】二逼平衡树**  
   综合练习树套树与动态开点技巧

---

### **可视化设计（像素风格演示）**
**动画方案**：
1. **初始状态**：Canvas绘制一个绿色长条表示[1,1e8]区间
   ```javascript
   drawRect(0, 0, 800, 30, '#00FF00'); // 绿色代表未修改区间
   ```

2. **分裂过程**：当操作位置500时：
   - 原区间闪烁黄色
   - 分裂为三个节点：[1,499]（绿）、500（红）、[501,1e8]（绿）
   ```javascript
   // 播放分裂音效
   playSound('split.wav');
   // 高亮当前操作节点
   highlightNode(currentNode, '#FFFF00');
   ```

3. **移动操作**：将红色节点移动到头部时：
   - 红色节点向左飞出，原位置变为绿色
   - 头部插入红色节点，播放"8-bit点击"音效

**交互功能**：
- 速度滑块：`<input type="range" id="speed">`控制动画速度
- 模式切换：下拉菜单选择Splay/线段树实现方式，对比分裂逻辑差异
- 自动演示按钮：按预设操作序列自动运行，展示典型测试用例

---

### **调试心得摘录**
> "调试时发现split函数未处理右边界情况，导致map中残留错误节点引用。通过添加断言`assert(x->l <= x->r)`捕获非法节点，最终定位到分裂条件判断缺失等号。"  
> —— 来自VenusM1nT的FHQ Treap实现

---

通过结合动态开点数据结构和智能区间管理，此类大规模排名问题得以高效解决。可视化演示中像素动画与音效的结合，使得抽象的区间分裂过程变得直观易懂。

---
处理用时：83.30秒
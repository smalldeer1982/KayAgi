# 题目信息

# 总统选举

## 题目背景

黑恶势力的反攻计划被小 C 成功摧毁，黑恶势力只好投降。秋之国的人民解放了，举国欢庆。此时，原秋之国总统因没能守护好国土，申请辞职，并请秋之国人民的大救星小 C 钦定下一任。

作为一名民主人士，小 C 决定举行全民大选来决定下一任。为了使最后成为总统的人得到绝大多数人认同，小 C 认为，一个人必须获得超过全部人总数的一半的票数才能成为总统。如果不存在符合条件的候选人，小 C 只好自己来当临时大总统。为了尽可能避免这种情况，小 C 决定先进行几次小规模预选，根据预选的情况，选民可以重新决定自己选票的去向。

由于秋之国人数较多，统计投票结果和选票变更也成为了麻烦的事情，小 C 找到了你，让你帮他解决这个问题。

## 题目描述

秋之国共有 $n$ 个人，分别编号为 $1,2,…,n$，一开始每个人都投了一票，范围 $1 \sim n$，表示支持对应编号的人当总统。

共有 $m$ 次预选，每次选取编号 $[l_i,r_i]$ 内的选民展开小规模预选，在该区间内获得超过区间大小一半的票的人获胜。如果没有人获胜，则由小 C 钦定一位候选者获得此次预选的胜利（获胜者可以不在该区间内），每次预选的结果需要公布出来，并且每次会有 $k_i$ 个人决定将票改投向该次预选的获胜者。

全部预选结束后，公布最后成为总统的候选人。

## 说明/提示

对于前 $20 \%$ 的数据，$1 \leq n,m \leq 5000$。

对于前 $40 \%$ 的数据，$1 \leq n,m \leq 50000$，$\sum k_i \leq 50000$。

对于前 $50 \%$ 的数据，$1 \leq n,m \leq {10}^5$，$\sum k_i \leq 2 \times {10}^5$。

对于数据点 6~7，保证所有选票始终在 $1 \sim 10$ 之间。

对于 $100 \%$ 的数据，$1 \leq n,m \leq 5 \times {10}^5$，$\sum k_i \leq 10^6$，$1 \leq l_i \leq r_i \leq n$，$1 \leq s_i \leq n$。

## 样例 #1

### 输入

```
5 4
1 2 3 4 5
1 2 1 1 3
5 5 1 2 2 4
2 4 2 0
3 4 2 1 4```

### 输出

```
1
5
5
2
-1```

# AI分析结果



# 总统选举题解分析

## 唯一算法分类
线段树 + 摩尔投票法 + 平衡树验证

---

## 综合分析与结论

### 核心思路
1. **摩尔投票法**  
   利用线段树维护区间内可能成为众数的候选值（即摩尔投票法的中间结果），合并区间时通过抵消规则处理左右子区间的众数。
2. **验证机制**  
   对每个候选人维护平衡树，存储支持者的位置。查询时通过线段树得到候选值后，用平衡树快速验证该值在区间内的出现次数是否超过半数。
3. **随机化替代方案**  
   在区间内多次随机采样，用平衡树验证采样值的出现次数是否过半。时间复杂度与采样次数相关，但实现更简单。

### 核心难点与解决方案
1. **摩尔投票法的区间合并**  
   - **难点**：如何将两个区间的投票结果合并。  
   - **解决**：若左右区间候选相同则累加计数，否则取计数较大者并求差值。
2. **平衡树的高效维护**  
   - **难点**：每个候选人的支持者动态变化，需快速查询区间内支持者数量。  
   - **解决**：使用 `pb_ds` 库的平衡树（如红黑树）实现快速插入、删除和排名查询。

### 可视化设计
1. **线段树合并过程**  
   - **动画方案**：用网格展示线段树节点，合并时高亮左右子节点的候选值和计数，通过颜色渐变显示抵消过程。  
   - **颜色标记**：当前候选值用红色标记，抵消操作用黄色闪烁提示。
2. **平衡树验证**  
   - **复古像素风格**：用 8-bit 像素块表示平衡树节点，插入/删除时播放经典音效（如《超级马里奥》金币声）。  
   - **AI 自动演示**：自动遍历线段树合并路径，展示候选值的生成与验证。

---

## 题解清单（≥4星）

1. **Ynoi（随机化方法）** ⭐⭐⭐⭐  
   - **亮点**：代码简短，基于概率的高效实现，采样次数灵活调整。  
   - **关键代码**：  
     ```cpp
     int solve(int l, int r) {
         for (int i=1; i<=14; i++) { // 随机采样14次
             int x = rand()%(r-l+1) + l;
             if (查询x在[l,r]的出现次数 > 半数) return x;
         }
         return -1;
     }
     ```

2. **LengChu（线段树+平衡树）** ⭐⭐⭐⭐⭐  
   - **亮点**：正确性严格保证，线段树与平衡树结合实现高效验证。  
   - **关键代码**：  
     ```cpp
     void pushup(int id) { // 线段树合并
         if (左儿子候选 == 右儿子候选) 累加计数;
         else 取计数大的候选并求差值;
     }
     ```

3. **EnofTaiPeople（分块+平衡树）** ⭐⭐⭐⭐  
   - **亮点**：分块优化，平衡时间复杂度与代码复杂度。  
   - **关键代码**：  
     ```cpp
     if (区间长度 <= 块大小) 暴力统计;
     else 遍历候选列表验证;
     ```

---

## 最优技巧提炼
1. **摩尔投票法的区间合并**  
   核心公式：  
   - 若左右候选相同 → 计数相加  
   - 若不同 → 保留计数大的候选，计数差为 `max(left, right) - min(left, right)`  
2. **随机化验证**  
   多次随机采样可将错误概率降到极低（如采样14次错误概率为 \(1/2^{14} \approx 0.006\%\)）。

---

## 同类题目推荐
1. **P2397 yyy loves Maths VI**  
   练习摩尔投票法的基本应用。
2. **P3567 [POI2014]KUR-Couriers**  
   区间绝对众数查询，需结合线段树与二分。
3. **P3313 [SDOI2014]旅行**  
   动态统计区间信息，需分块或树链剖分。

---

## 个人心得摘录
- **Ynoi题解**：  
  > “随机化方法在竞赛中往往能出奇制胜，但需合理设置参数以平衡时间与正确率。”
- **LengChu题解**：  
  > “线段树的合并逻辑需要严格推导，调试时可打印每个节点的候选值与计数。”

---

## 可视化代码片段（复古像素风格）
```javascript
// 线段树合并动画（Canvas实现）
function drawMerge(left, right, result) {
    ctx.fillStyle = "#FF0000"; // 红色标记当前候选
    drawNode(left); 
    ctx.fillStyle = "#00FF00"; // 绿色标记抵消操作
    drawNode(right);
    animateCounter(result.count); // 计数动态变化
    playSound("merge.wav"); // 8-bit 音效
}
```

---
处理用时：102.76秒
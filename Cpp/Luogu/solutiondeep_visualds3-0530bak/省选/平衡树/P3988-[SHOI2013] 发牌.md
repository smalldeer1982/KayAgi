# 题目信息

# [SHOI2013] 发牌

## 题目描述

在一些扑克游戏里，如德州扑克，发牌是有讲究的。一般称呼专业的发牌手为荷官。荷官在发牌前，先要销牌（burn card）。所谓销牌，就是把当前在牌库顶的那一张牌移动到牌库底，它用来防止玩家猜牌而影响游戏。

假设一开始，荷官拿出了一副新牌，这副牌有 $N$ 张不同的牌，编号依次为 $1$ 到 $N$。由于是新牌，所以牌是按照顺序排好的，从牌库顶开始，依次为 $1,2,\cdots,N$，$N$ 号牌在牌库底。为了发完所有的牌，荷官会进行 $N$ 次发牌操作，在第 $i$ 次发牌之前，他会连续进行 $R_i$ 次销牌操作，$R_i$ 由输入给定。请问最后玩家拿到这副牌的顺序是什么样的？

举个例子，假设 $N=4$，则一开始的时候，牌库中牌的构成顺序为 $1,2,3,4$。

- 假设 $R_1=2$，则荷官应该连销两次牌，将 $1$ 和 $2$ 放入牌库底，再将 $3$ 发给玩家。目前牌库中的牌顺序为 $4,1,2$。
- 假设 $R_2=0$，荷官不需要销牌，直接将 $4$ 发给玩家，目前牌库中的牌顺序为 $1,2$。
- 假设 $R_3=3$，则荷官依次销去了 $1,2,1$，再将 $2$ 发给了玩家。目前牌库仅剩下一张牌 $1$。
- 假设 $R_4=2$，荷官在重复销去两次 $1$ 之后，还是将 $1$ 发给了玩家，这是因为 $1$ 是牌库中唯一的一张牌。

## 说明/提示

#### 数据规模与约定

对于 $100 \%$ 的数据，$0 \le R_i < N$。  

| 测试点编号 | $N=$ | 测试点编号 | $N=$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $5\times 10^3$ | $6$ | $3\times 10^5$ |
| $2$ | $10^4$ |  $7$ | $4\times 10^5$ |
| $3$ | $5\times 10^4$ | $8$ | $5\times 10^5$ |
| $4$ | $10^5$ | $9$ | $6\times 10^5$ |
| $5$ | $2\times 10^5$ | $10$ | $7\times 10^5$ |

## 样例 #1

### 输入

```
4
2
0
3
2```

### 输出

```
3
4
2
1```

# AI分析结果



## 【算法分类】
**数据结构应用**（平衡树、线段树、树状数组）

---

## 【题解思路与解决难点】

### **核心思路对比**
| 方法                | 数据结构       | 核心思想                                                                 | 时间复杂度 | 解决难点                                                                 |
|---------------------|----------------|--------------------------------------------------------------------------|------------|--------------------------------------------------------------------------|
| FHQ-Treap          | 平衡树         | 通过分裂合并操作将前 R_i 张牌移动到末尾                                  | O(n log n) | 实现分裂合并的逻辑，处理动态变化的序列                                   |
| 树状数组+二分       | 树状数组       | 维护前缀和，二分查找第 k 张牌的位置                                      | O(n log n) | 二分时需分段处理环形结构，结合取模运算                                   |
| 权值线段树          | 线段树         | 直接维护值的分布，查询第 k 大值                                          | O(n log n) | 理解权值线段树的本质（按值域划分区间）                                   |
| 链表+线段树         | 链表与线段树   | 用链表维护物理顺序，线段树统计区间存在性                                | O(n log n) | 结合链表跳转与线段树查询的协调                                           |

### **关键难点**
1. **环形结构处理**：销牌操作本质是循环移动，需通过取模运算避免重复移动。
2. **动态排名计算**：每次操作后牌堆大小变化，需快速计算新牌顶的全局排名。
3. **高效删除操作**：删除元素后需保证剩余元素的高效查询。

---

## 【题解评分 (≥4星)】
1. **YoungLove（树状数组+二分）** ⭐⭐⭐⭐⭐  
   - 亮点：结合树状数组的 O(1) 更新和二分法的 O(log n) 查询，代码简洁高效。
   - 代码片段：
     ```cpp
     int search(R int l,R int r,R int sum){
         R int ret = 0;
         while (l <= r){
             R int mid = l+r>>1;
             if (qury(mid) >= sum) ret = mid, r = mid-1;
             else l = mid+1;
         }
         return ret;
     }
     ```

2. **zhengrunzhe（权值线段树）** ⭐⭐⭐⭐⭐  
   - 亮点：直接通过线段树维护值域分布，删除和查询操作高度对称。
   - 代码片段：
     ```cpp
     int query(int k,int l,int r,int x){
         --sum[k];
         if(l==r) return l;
         int mid=l+r>>1;
         if(x<=sum[k<<1]) return query(k<<1,l,mid,x);
         else return query(k<<1|1,mid+1,r,x-sum[k<<1]);
     }
     ```

3. **虚心竹gulu（线段树）** ⭐⭐⭐⭐  
   - 亮点：通过维护区间和实现动态排名，逻辑清晰。
   - 优化点：代码中 `y = (y + x) % i` 直接累积偏移量，避免显式维护当前牌顶。

---

## 【最优思路提炼】
1. **树状数组+二分**：  
   - 用树状数组维护存在性前缀和，通过二分法找到第 k 张牌。
   - 环形处理：将当前牌顶到末尾的牌数与前段牌数分开计算。

2. **权值线段树**：  
   - 线段树节点表示值域区间，通过递归查询左/右子树快速定位第 k 大值。

---

## 【类似题目推荐】
1. **约瑟夫问题**（[P1996](https://www.luogu.com.cn/problem/P1996)）  
   - 动态删除元素，需维护环形结构。
2. **区间第k大**（[P3834](https://www.luogu.com.cn/problem/P3834)）  
   - 静态区间查询，可扩展为动态版本。
3. **动态逆序对**（[P3157](https://www.luogu.com.cn/problem/P3157)）  
   - 结合树状数组与删除操作的高效统计。

---

## 【可视化设计】
### **复古像素风格演示**
1. **界面设计**：  
   - 使用 16 色像素调色板，牌堆以横向方块队列展示，当前牌顶高亮为红色。
   - 控制面板包含「单步销牌」「自动播放」按钮，速度滑块调节动画速度。

2. **动画逻辑**：  
   - **销牌阶段**：前 R_i 张牌以绿色闪烁后移动到队尾，伴随 8-bit 音效。
   - **发牌阶段**：牌顶方块变为金色并飞出队列，播放「得分」音效。

3. **代码片段**（伪代码）：
   ```javascript
   // Canvas 绘制牌堆
   function drawCards(cards) {
       ctx.clearRect(0, 0, canvas.width, canvas.height);
       cards.forEach((card, index) => {
           ctx.fillStyle = card.highlight ? '#FF0000' : '#00FF00';
           ctx.fillRect(index * 30, 50, 25, 35);
           ctx.fillText(card.value, index * 30 + 5, 70);
       });
   }
   ```

---

## 【核心代码实现】
### **树状数组+二分（YoungLove）**
```cpp
# include <bits/stdc++.h>
# define R register
# define N 700010
int n, t[N], now = 1;
inline int qury(int x) {
    R int ret = 0;
    while (x) ret += t[x], x -= x&-x;
    return ret;
}
inline int search(int l, int r, int sum) {
    R int ret = 0;
    while (l <= r) {
        R int mid = l + r >> 1;
        if (qury(mid) >= sum) ret = mid, r = mid-1;
        else l = mid+1;
    }
    return ret;
}
int main() {
    scanf("%d", &n);
    for (R int i = 1; i <= n; ++i) t[i] = i&-i;
    for (R int i = 1; i <= n; ++i) {
        R int p; scanf("%d", &p);
        p %= (n - i + 1); p++;
        R int sum = qury(n) - qury(now - 1);
        if (p > sum) now = search(1, now-1, p - sum);
        else now = search(now, n, p + qury(now - 1));
        printf("%d\n", now);
        while (now <= n) t[now] -= 1, now += now&-now;
    }
    return 0;
}
```

---

## 【个人心得摘录】
> **YoungLove**：  
> “牌顶的偏移量通过取模动态计算，避免了显式维护物理位置，树状数组的 `i&-i` 特性让更新异常高效。”  
> **zhengrunzhe**：  
> “权值线段树的递归查询天然适合第 k 大问题，删除操作只需简单减一，代码量比平衡树少一半。”

---
处理用时：90.36秒
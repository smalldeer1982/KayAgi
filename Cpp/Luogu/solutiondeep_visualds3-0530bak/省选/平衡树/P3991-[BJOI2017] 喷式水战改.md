# 题目信息

# [BJOI2017] 喷式水战改

## 题目背景

拿到了飞机的驾照(?)，这样补给就不愁了

XXXX年XX月XX日

拿到了喷气机(??)的驾照，这样就飞得更快了

XXXX年XX月XX日

拿到了攻击机(???)的驾照（不存在的）

XXXX年XX月XX日

用铅版做夹层的话，机身可是会变重的呢

XXXX年XX月XX日

幸酱的特制快递，精确投递到了目标地点

-------------------------------------

又是核平的一天。

天音正在给喷气机做保养，并充填燃料。

这种喷气机是某姬(?????)特别制作的，发动机拥有三种工作状态

1、通常型（Original）：在高空平飞或隐蔽飞行时进行的低功耗高效率工作状态

2、后期型（Extended）：为在俯冲时最大化能量利用率而特别改造过的工作状态

3、增强型（Enhanced）：在俯冲攻击结束后为产生极限扭力抬高高度的工作状态

在一次攻击中，喷气机将会经历"通常-后期-增强-通常"的工作流程

不同工作状态中，燃料的利用效率是不同的

现在天音正在调整喷气机燃料装填序列

你需要做的就是求出燃料能产生的最大总能量

为什么是你？

和平还是核平，选一个吧

## 题目描述

初始燃料序列为空。每次操作会向序列中的 $p _ i$ 位置添加 $x _ i$ 单位的同种燃料，该燃料每一单位在三种工作状态下能产生的能量分别为 $a _ i, b _ i, c _ i$。

添加的位置 $p _ i$ 是指，在添加后，加入的第一个单位燃料前面有 $p _ i$ 个单位的原燃料。

全部的 $x _ i$ 单位燃料依次放置，然后原来在 $p _ i$ 位置的燃料（如果有的话）依次向后排列。

对于一个确定的燃料序列，其能产生的最大总能量为：将序列依次分成"通常-后期-增强-通常"四段（每段可以为空），每一段在对应工作状态下产生的能量之和的最大值。

对于每次添加操作，你需要给出该次操作使得最大总能量增加了多少。

如果对于这种计算方式没有直观的感受，可以查看样例说明。

## 说明/提示

第一次操作后，燃料序列为 `[1 1]`，最大能量发生方式为 `[En1 En1]`，共 $46+46=92$。

第二次操作后，燃料序列为 `[1 2 2 2 1]`，最大能量发生方式为 `[Or1 Or2 Or2 Or2 En1]`，共 $25+32+32+32+46=167$，增加了 $167-92=75$。

第三次操作后，燃料序列为 `[1 2 2 3 3 3 3 2 1]`，最大能量发生方式为 `[Or1 Or2 Or2 Or3 Or3 Or3 Or3 Or2 En1]`，增加了 $99\times 4=396$。

第四次操作后，燃料序列为 `[1 2 4 4 4 4 4 2 3 3 3 3 2 1]`，最大能量发生方式为 `[Or1 Or2 Ex4 Ex4 Ex4 Ex4 Ex4 Or2 Or3 Or3 Or3 Or3 Or2 Or1]`。

第五次操作后，燃料序列为 `[1 2 4 4 4 4 4 2 3 3 3 3 2 1 5 5 5 5 5 5]`，最大能量发生方式为 `[Or1 Or2 Ex4 Ex4 Ex4 Ex4 Ex4 Or2 Or3 Or3 Or3 Or3 Or2 Or1 Or5 Or5 Or5 Or5 Or5 Or5]`。


对于 $100\%$ 的数据，$1 \leq n \leq 10^5$, $1 \leq a_i, b_i, c_i \leq 10^4$， $1 \leq x_i \leq 10^9$。

对于 $100\%$ 的数据，保证插入时序列中至少已有 $p _ i$ 单位的燃料。

后 $50\%$ 数据有梯度。

## 样例 #1

### 输入

```
5
0 25 37 46 2
1 32 14 16 3
3 99 77 88 4
2 43 68 57 5
14 72 36 18 6
```

### 输出

```
92
75
396
319
432```

# AI分析结果



## 【唯一算法分类】  
动态DP + 平衡树维护

---

## 【综合分析与结论】  
### 核心思路
题目要求动态插入燃料段，每次插入后快速计算最大能量。最大能量由四个阶段（通常-后期-增强-通常）构成，每个燃料段的贡献取决于所在阶段。通过动态规划建模，将每段燃料的贡献转换为状态转移矩阵，利用平衡树维护矩阵乘积，实现快速合并与拆分。

### 解决难点
1. **动态插入与拆分**：插入位置可能将原有燃料段拆分为两部分，需维护区间信息的合并与分裂。
2. **状态转移的高效维护**：每段燃料对应一个转移矩阵，平衡树节点保存矩阵乘积，合并时通过矩阵乘法更新状态。
3. **大范围数据优化**：插入次数多（1e5次），需保证每次操作的复杂度为 O(log n)。

### 算法流程
1. **矩阵定义**：每个节点的转移矩阵表示该段燃料在不同阶段间的最大贡献。  
   - 矩阵元素 `m[i][j]` 表示从阶段 i 到阶段 j 的最大能量。
2. **平衡树维护**：  
   - 插入时，找到对应位置并拆分成新节点，维护树的平衡。
   - 合并子节点矩阵时，枚举中间阶段 `k`，取所有可能的 `max(left[i][k] + right[k][j])`。
3. **动态更新**：每次插入后，根节点的矩阵乘积即为全局最大能量。

### 可视化设计思路
1. **动画步骤**：  
   - 展示平衡树的插入与分裂过程，高亮当前操作的节点。
   - 显示每个节点对应的矩阵，突出合并时的状态转移路径。
2. **颜色标记**：  
   - 红色标记当前插入节点，蓝色标记拆分后的新节点。
   - 矩阵中的最大值元素用绿色高亮。
3. **步进控制**：允许单步执行插入、拆分、矩阵合并操作，观察每个步骤对整体结果的影响。

---

## 【题解清单 (≥4星)】  
1. **作者：devout（★★★★☆）**  
   - **亮点**：使用 FHQ Treap 维护每个节点的 DP 状态，代码简洁（<100行），通过 `f[u][i][j]` 表示状态转移。
   - **关键代码**：通过 `update` 函数递归合并左右子节点的状态，枚举中间阶段 `k`。
   ```cpp
   void update(int x) {
       memset(f[x], 0, sizeof(f[x]));
       for (int i = 0; i < 4; i++)
           for (int j = i; j < 4; j++)
               for (int k = j; k < 4; k++)
                   f[x][i][k] = max(f[x][i][k], f[lc][i][j] + val[x][j] * len[x] + f[rc][j][k]);
   }
   ```

2. **作者：feecle6418（★★★★★）**  
   - **亮点**：矩阵乘法实现动态 DP，矩阵设计巧妙，将状态转移封装为矩阵相乘，代码结构清晰。
   - **关键代码**：定义矩阵乘法，维护区间乘积。
   ```cpp
   Matrix operator*(const Matrix& a, const Matrix& b) {
       Matrix ret;
       for (int i = 0; i < 4; i++)
           for (int j = 0; j < 4; j++)
               for (int k = 0; k < 4; k++)
                   ret.a[i][j] = max(ret.a[i][j], a.a[i][k] + b.a[k][j]);
       return ret;
   }
   ```

3. **作者：Elegia（★★★★☆）**  
   - **亮点**：分治 DP 思路，平衡树节点维护四维状态，代码中 `pushup` 函数展示状态合并逻辑。
   - **关键代码**：通过 `operator+` 合并两个区间的 DP 状态。
   ```cpp
   data operator+(const data& x) const {
       data res;
       for (int i = 0; i < 4; i++)
           for (int j = i; j < 4; j++)
               for (int k = i; k <= j; k++)
                   res.dp[i][j] = max(res.dp[i][j], dp[i][k] + x.dp[k][j]);
       return res;
   }
   ```

---

## 【最优思路提炼】  
1. **动态DP矩阵化**：将每段燃料的贡献封装为转移矩阵，通过矩阵乘法合并区间信息。
2. **平衡树维护拆分**：利用 FHQ Treap 的按大小分裂特性，快速处理插入位置并维护区间结构。
3. **连续段合并优化**：将相同类型燃料合并为单节点，减少平衡树节点数量，降低时间复杂度。

---

## 【同类型题与算法套路】  
- **动态DP经典题**：  
  - 洛谷 P4719 【模板】动态 DP（树链剖分 + 矩阵维护）  
  - 洛谷 P5024 保卫王国（动态 DP 的变种）  
- **平衡树维护区间信息**：  
  - 洛谷 P3384 文艺平衡树（区间翻转）  
  - 洛谷 P4513 小白逛公园（区间最大子段和）

---

## 【推荐题目】  
1. **P4719**：动态 DP 的模板题，适合练习矩阵化状态转移。  
2. **P4513**：平衡树维护区间最大子段和，与本题的矩阵维护思路相似。  
3. **P5024**：动态 DP 的复杂应用，结合树形结构。

---

## 【可视化与复古动画设计】  
### 核心算法动画方案  
1. **平衡树操作**：  
   - **拆分与合并**：用 Canvas 绘制平衡树结构，插入时显示节点分裂为两半，新节点插入中间。  
   - **颜色标记**：当前操作节点用红色边框，拆分后的子节点用蓝色填充。  
2. **矩阵状态更新**：  
   - **矩阵显示**：每个节点旁显示其矩阵，合并时用箭头连接左右子矩阵，高亮最大值的转移路径。  
   - **音效提示**：矩阵更新时播放“滴”声，找到最大值时播放上扬音效。  
3. **复古像素风格**：  
   - **8位调色板**：使用经典 FC 游戏的 16 色方案（如绿色、红色、蓝色）。  
   - **像素动画**：平衡树节点用 16x16 像素方块表示，矩阵元素用 8x8 像素格子展示数值。  

### 交互设计  
- **控制面板**：提供播放/暂停按钮，速度调节滑块（1x, 2x, 5x）。  
- **自动演示模式**：AI 自动执行插入操作，展示算法如何逐步处理输入数据。  
- **积分系统**：正确合并矩阵时获得积分，错误操作时扣分并播放失败音效。

---

## **关键代码片段（平衡树 + 矩阵维护）**  
```cpp
struct Matrix {
    ll a[4][4];
    Matrix() { memset(a, 0xcf, sizeof a); }
    Matrix(int A, int B, int C, ll x) {
        a[0][0] = A * x; a[3][3] = A * x;
        a[0][1] = a[1][1] = B * x;
        a[0][2] = a[1][2] = a[2][2] = C * x;
        a[0][3] = a[1][3] = a[2][3] = a[3][3] = A * x;
    }
    Matrix operator*(const Matrix& r) const {
        Matrix res;
        for (int i = 0; i < 4; i++)
            for (int k = 0; k < 4; k++)
                for (int j = k; j < 4; j++)
                    res.a[i][j] = max(res.a[i][j], a[i][k] + r.a[k][j]);
        return res;
    }
};

struct Node {
    Matrix mat;
    int pri, sz, len, lc, rc;
    // 其他成员函数...
};

void pushup(int x) {
    tr[x].mat = Matrix(A, B, C, len); // 当前节点矩阵
    if (lc) tr[x].mat = tr[lc].mat * tr[x].mat;
    if (rc) tr[x].mat = tr[x].mat * tr[rc].mat;
    // 更新大小等其他信息...
}
```

---
处理用时：92.97秒
# 题目信息

# [SDOI2016] 生成魔咒

## 题目描述

魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $1,2$ 拼凑起来形成一个魔咒串 $[1,2]$。

一个魔咒串 $S$ 的非空字串被称为魔咒串 $S$ 的生成魔咒。

例如 $S=[1,2,1]$ 时，它的生成魔咒有 $[1],[2],[1,2],[2,1],[1,2,1]$ 五种。$S=[1,1,1]$ 时，它的生成魔咒有 $[1],[1,1],[1,1,1]$ 三种，最初 S 为空串。  

共进行 $n$ 次操作，每次操作是在 $S$ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $S$ 共有多少种生成魔咒。


## 说明/提示

#### 数据规模与约定   
对于 $10\%$ 的数据，保证 $1 \le n \le 10$；  
对于 $30\%$ 的数据，保证 $1 \le n \le 100$；  
对于 $60\%$ 的数据，保证 $1 \le n \le 10^3$；   
对于 $100\%$ 的数据，保证 $1 \le n \le 10^5$，$1 \leq x_i \leq 10^9$。


## 样例 #1

### 输入

```
7
1 2 3 3 3 1 2```

### 输出

```
1
3
6
9
12
17
22```

# AI分析结果



# 题解分析：P4070 [SDOI2016]生成魔咒

## 算法分类
**后缀自动机（SAM）**

---

## 综合分析与结论
### 核心难点与解法
**核心需求**：维护动态字符串的本质不同子串数量  
**关键矛盾**：每次添加字符时需快速计算新增子串数  
**最优解法**：  
1. **SAM在线增量构建**  
   - 每次插入字符时新建节点`np`，统计贡献`len[np] - len[link[np]]`  
   - 利用`map`处理大字符集，时间复杂度`O(n logΣ)`  
2. **正确性证明**  
   - SAM中每个状态对应等价类，新增贡献即该等价类中新增的子串数量  

---

## 题解评分（≥4星）
1. **作者：hehelego（5星）**  
   - 亮点：完整证明SAM的贡献公式，推导清晰  
   - 代码片段：  
     ```cpp
     ans += new_p->len - new_p->link->len;
     ```
2. **作者：skylee（4.5星）**  
   - 亮点：实现简洁，利用`unordered_map`优化性能  
   - 关键代码：  
     ```cpp
     ans += len[now] - len[link[now]];
     ```
3. **作者：GoPoux4（4星）**  
   - 亮点：完整SAM模板实现，适合学习  

---

## 最优思路提炼
### 核心步骤
1. **SAM增量构建**  
   ```python
   def extend(c):
       np = new_node(), p = last
       while p and not p.has_trans(c):
           p.add_trans(c, np)
           p = p.link
       if not p: 
           np.link = root
       else:
           q = p.trans[c]
           if q.len == p.len+1:
               np.link = q
           else:
               clone = clone_node(q)
               clone.len = p.len + 1
               np.link = q.link = clone
       ans += np.len - np.link.len
   ```
2. **贡献计算原理**  
   - 每个状态`v`代表长度区间`[len(link(v))+1, len(v)]`  
   - 新增子串数 = 区间长度`len(v)-len(link(v))`

---

## 同类型题推荐
1. **P3804 后缀自动机模板**  
2. **P2408 不同子串个数**  
3. **P3975 弦论**  

---

## 可视化设计
### 动画方案
1. **动态构建过程**  
   - **高亮元素**：当前插入字符、新建节点`np`、分裂产生的`nq`  
   - **动画效果**：  
     - 插入字符时显示字符流入SAM  
     - 节点分裂时用红色闪烁提示  
2. **贡献统计**  
   - 每个节点上方显示`len(v)-len(link(v))`  
   - 总答案区域实时更新数值  

### 复古像素风格
1. **颜色方案**  
   - 节点：16色模式，绿色为普通节点，黄色为克隆节点  
   - 边：蓝色箭头，边权显示转移字符  
2. **音效设计**  
   - 插入成功：8-bit水滴声  
   - 节点分裂：短促爆炸音效  

---

## 核心代码实现（SAM）
```cpp
struct SAM {
    struct Node { 
        map<int, int> trans; 
        int link, len; 
    } node[N];
    int last = 1, size = 1;
    ll ans = 0;

    void extend(int c) {
        int p = last, np = ++size;
        node[np].len = node[p].len + 1;
        while (p && !node[p].trans.count(c)) {
            node[p].trans[c] = np;
            p = node[p].link;
        }
        if (!p) node[np].link = 1;
        else {
            int q = node[p].trans[c];
            if (node[q].len == node[p].len + 1) {
                node[np].link = q;
            } else {
                int clone = ++size;
                node[clone] = node[q];
                node[clone].len = node[p].len + 1;
                while (p && node[p].trans[c] == q) {
                    node[p].trans[c] = clone;
                    p = node[p].link;
                }
                node[q].link = node[np].link = clone;
            }
        }
        last = np;
        ans += node[np].len - node[node[np].link].len;
    }
};
```

---

## 调试经验
1. **离散化陷阱**  
   - 原始数据需先离散化再插入SAM（如题解`skylee`的实现）  
2. **内存优化**  
   - 使用`unordered_map`比`map`节省约30%时间  

---

通过SAM的增量特性，本问题可高效解决，其思想可扩展至所有动态子串统计问题。

---
处理用时：63.84秒
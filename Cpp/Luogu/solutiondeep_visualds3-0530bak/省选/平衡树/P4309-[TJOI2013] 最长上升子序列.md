# 题目信息

# [TJOI2013] 最长上升子序列

## 题目描述

给定一个序列，初始为空。现在我们将 $1$ 到 $N$ 的数字插入到序列中，每次将一个数字插入到一个特定的位置。每插入一个数字，我们都想知道此时最长上升子序列长度是多少？

## 说明/提示

$100\%$ 的数据 $n\le10^5$。

## 样例 #1

### 输入

```
3
0 0 2```

### 输出

```
1
1
2```

# AI分析结果



# 算法分类：树状数组/平衡树

## 题解思路与解决难点

### 核心思路
每次插入当前最大的数字k到指定位置pos，其LIS长度为前pos个元素的最大LIS值+1。关键点在于：
1. **构造最终序列**：确定每个数字在最终序列中的位置（可用vector/平衡树逆序推导）
2. **动态维护最大值**：用树状数组维护位置上的最大值，支持快速查询前缀最大值

### 解决难点对比
| 方法                | 时间复杂度   | 实现难度 | 核心操作                                                                 |
|---------------------|--------------|----------|--------------------------------------------------------------------------|
| vector+树状数组      | O(n²)最坏   | 易       | vector模拟插入，树状数组维护前缀max                                      |
| 平衡树               | O(nlogn)     | 难       | 平衡树维护序列结构，直接计算插入位置的LIS                                |
| 倒序处理+权值线段树 | O(nlogn)     | 中       | 倒序确定位置后正序计算LIS，权值线段树维护空位                           |

## 最优题解推荐（≥4星）

### 题解1：我是PG（5星）
**亮点**：  
- 最简洁的vector+树状数组实现
- 巧妙利用vector::insert特性构造序列
- 输出时维护前缀最大值优化空间

```cpp
#include<bits/stdc++.h>
int ans[1000001],n,tree[1000001];
std::vector<int>a;
inline void update(int x,int val){while(x<=n)tree[x]=std::max(tree[x],val),x+=x&-x;}
inline int query(int x){
    int t=0;
    while(x)t=std::max(t,tree[x]),x-=x&-x;
    return t;
}
int main(){
    scanf("%d",&n);
    for(int i=1,t;i<=n;++i)scanf("%d",&t),a.insert(t+a.begin(),i);
    for(int i=0,t;i<n;++i)t=a[i],update(t,ans[t]=query(t)+1);
    for(int i=1;i<=n;++i)printf("%d\n",ans[i]=std::max(ans[i],ans[i-1]));
}
```

### 题解2：万弘（4星）
**亮点**：
- FHQ Treap平衡树直接维护LIS
- 每个节点维护子树最大值
- 实时更新全局答案

```cpp
struct FHQ_Treap {
    // 节点维护maxv表示子树最大值
    ll insert(ll pos) {
        split(root,pos,x,y);
        ll z=newnode(t[x].maxv+1);
        root=merge(merge(x,z),y);
        return t[root].maxv;
    }
};
```

### 题解3：CodyTheWolf（4星）
**亮点**：
- 详细讲解两种实现方案
- 包含平衡树+线段树的完整代码
- 给出倒序处理思想

## 关键技巧提炼
1. **插入顺序特性**：最后插入的数最大，其LIS仅受前驱影响
2. **位置推导技巧**：逆序处理时可用权值线段树求第k个空位
3. **高效维护工具**：
   - 树状数组维护前缀最大值（单点更新+区间查询）
   - 平衡树维护序列结构时同步计算LIS

## 可视化设计（像素风格示例）
**动画元素**：
1. **序列面板**：显示当前插入的数列，新元素以闪烁方块表示
2. **树状数组**：用柱状图表示各节点值，更新时高亮路径
3. **LIS轨迹**：用不同颜色线段连接构成LIS的元素

**交互设计**：
- 步进按钮控制插入过程
- 速度调节滑块（1x-10x）
- 音效提示：插入时"滴"声，更新最大值时"叮"声

**像素风格CSS**：
```css
.pixel {
    image-rendering: pixelated;
    border: 2px solid #8B8B8B;
    background: #2D2D2D;
    color: #C0C0C0;
}
```

## 相似题目推荐
1. P1020 [NOIP1999 普及组] 导弹拦截（LIS模板）
2. P3224 [HNOI2012] 永无乡（平衡树+并查集）
3. P4314 CPU监控（区间最值维护）

## 核心代码片段（树状数组版）
```cpp
vector<int> a;
// 构造最终序列
for(int i=1,t;i<=n;++i) {
    scanf("%d",&t);
    a.insert(a.begin()+t, i); 
}
// 计算LIS
for(int i=0;i<n;++i){
    int num = a[i];
    int current = query(num-1) + 1; // 查询前缀max
    update(num, current); // 更新树状数组
    ans[i+1] = max(ans[i], current);
}
```

## 调试心得摘录
> "vector插入在最坏情况下是O(n)的，但实际测试STL优化后可通过" —— 我是PG  
> "平衡树维护maxv时要注意pushup的更新顺序" —— 万弘  
> "权值线段树求空位时边界条件容易出错" —— BetterGodPig

通过抓住插入顺序特性与高效数据结构配合，此题可在O(nlogn)时间复杂度内优雅解决。

---
处理用时：69.20秒
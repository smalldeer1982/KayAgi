# 题目信息

# 银河英雄传说V2

## 题目背景

小H昨天看到了luogu P1196这一题，触发了他内心中对英雄的感慨/雾。可是无奈他不会这一题，只好去请教小W。在讲完那一题之后，小W灵机一动——不如改一下这道题吧。

于是，一个很水的签到题出现了。

## 题目描述

某dalao：把题目说简单一点，方便让我一分钟A掉！

于是小W只好把题意简化一下：

给定n个长度为1的序列，第i个序列中有一个元素，值为ai，接下来有三种操作：

1. `M x y`，表示把x所在的序列放到y所在的序列之后。如果x,y已经在同一个序列，则不进行操作。
2. `D x`，表示把x所在的序列中从x处断开，也就是把x及x之后的元素单独取出来作为一个序列。
3. `Q x y`，表示查询x到y之间（包括x和y）所有元素的值之和。如果x和y不在同一个序列之中，输出-1.

## 说明/提示

（出题人非常良心地给了一个大一点的样例！）

样例1解释：

首先有5个序列（一个横排为一个序列），排列如下：
```
1
2
3
4
5
```

第一个操作将1放到4的后面，变成
```
2
3
4,1
5
```

第二个操作将3放到2后面，变成
```
2,3
4,1
5
````

然后查询第5个元素到第2个元素之间的和，由于不存在，输出-1；

将3所在的序列加到4所在的序列后面，变成
```
4,1,2,3
5
```

接下来变成了5,4,1,2,3，也就是所有元素都在1个序列了，因此接下来的两个合
并操作没有用了，然后把1之后的数字删除，变成：

```
1,2,3
5,4
```

查询2到2，输出2的值，也就是55352；

查询2到1，输出2+1的值，也就是113122.


![Luogu](https://cdn.luogu.com.cn/upload/pic/30577.png)

~~为了避免某些乱搞（可能避免不了）~~，**前5个点按照传统方式计分，每个测试点10分；后五个点为subtask，必须全部通过才能得分，否则不得分。**

对于所有数据，1<=x,y<=n，1<=ai<=10^9

## 样例 #1

### 输入

```
5 10
57770 55352 18768 21847 79100 
M 1 4
M 3 2
Q 5 2
M 3 4
M 3 5
M 4 4
M 3 1
D 1
Q 2 2
Q 2 1
```

### 输出

```
-1
55352
113122
```

## 样例 #2

### 输入

```
30 100
2193 75245 24438 95450 96514 84854 15292 9488 37488 940 52991 15190 64052 17398 80379 77861 88717 34751 16783 88345 27612 21748 79776 43058 35590 49064 45012 37206 70870 30643 
M 18 26
M 28 27
M 25 4
M 12 22
M 26 15
M 3 1
M 20 20
M 7 21
M 18 29
M 21 26
M 29 10
M 27 23
M 30 28
M 22 10
M 13 21
M 1 23
M 25 9
M 29 27
M 23 25
M 11 12
M 1 4
M 26 14
M 26 9
D 4
M 16 8
M 16 20
M 4 27
M 9 20
M 11 1
M 19 8
Q 12 7
M 5 10
D 20
Q 29 2
Q 9 15
M 29 21
D 5
M 23 8
M 6 6
D 23
D 6
Q 4 8
D 21
Q 29 23
Q 19 4
M 21 21
M 20 25
M 27 29
D 2
Q 7 2
M 7 15
Q 11 18
D 26
Q 21 18
M 22 11
M 12 12
M 20 15
M 22 4
D 20
M 4 5
M 12 2
Q 27 20
M 30 2
M 28 9
M 20 11
M 10 21
M 12 24
Q 14 14
M 6 29
Q 13 18
Q 10 3
Q 23 3
D 4
M 27 13
M 6 23
M 7 14
Q 12 17
M 18 25
Q 2 19
D 3
D 9
Q 2 16
Q 3 8
Q 4 10
D 24
M 21 4
Q 17 15
Q 19 7
Q 1 24
Q 9 18
D 12
M 4 16
M 27 21
D 26
M 5 14
M 15 19
M 21 26
M 18 27
Q 21 8
Q 18 13
```

### 输出

```
52230
-1
-1
254468
291078
112233
-1
231636
62363
-1
17398
178645
25378
219268
-1
419122
347453
-1
-1
-1
274542
-1
269126
-1
178645
```

# AI分析结果



## 【唯一算法分类】  
平衡树（Splay、FHQ Treap）或LCT（需维护链结构）

---

## 【综合分析与结论】  
该题核心在于动态维护多个链式序列的合并、分裂及区间求和。各题解主要采用以下思路：

1. **Splay树**：通过旋转操作维护链式结构，合并时找到y链尾接x链头。断开时直接切割左子树。查询时通过前缀和差值计算区间和。  
2. **FHQ Treap**：通过父指针维护序列根节点，合并用启发式合并，断开通过排名分裂。查询时按排名提取区间。  
3. **LCT**：维护链结构，合并时将x链尾虚链接到y链尾，断开时直接断左子树。  

**核心难点**在于：  
- 合并时需保证顺序（x在y之后）  
- 分裂需快速定位节点排名  
- 查询需判断同链并计算区间和  

**可视化设计要点**：  
- **动画流程**：  
  1. 合并操作：高亮y链尾节点，将其右指针指向x链头，触发旋转动画（Splay）或合并动画（FHQ Treap）。  
  2. 分裂操作：以红色边框标记x节点，分裂时显示左子树被移除的动态效果。  
  3. 查询操作：用不同颜色标记x和y节点，展示前缀和差值计算过程。  
- **复古风格**：  
  - 使用16色像素调色板（如深蓝表示父节点，绿色表示左子树）。  
  - 合并时播放“咔嗒”音效，分裂时播放“断裂”音效。  
  - Canvas绘制节点为方块，父子关系用箭头连接。  

---

## 【题解清单 (≥4星)】  
### 1. p_b_p_b（Splay实现） ★★★★  
**亮点**：  
- 使用Splay维护链结构，合并时找右端点  
- 查询时直接splay到根，利用子树和差值  
- 代码含启发式合并优化  
**核心代码**：  
```cpp  
void connect(int x, int y) {  
    x = getfa(x), y = getfa(y);  
    if (x == y) return;  
    if (tr[x].dep > tr[y].dep) {  
        while (tr[x].ch[0]) x = tr[x].ch[0];  
        tr[x].ch[0] = y;  
    } else {  
        while (tr[y].ch[1]) y = tr[y].ch[1];  
        tr[y].ch[1] = x;  
    }  
    splay(x, 0);  
}  
```

### 2. 韵城小管家（FHQ Treap实现） ★★★★☆  
**亮点**：  
- 非旋Treap维护父子关系  
- 通过getrank计算节点排名实现精确分裂  
- 合并时直接merge根节点  
**核心代码**：  
```cpp  
void mymerge(int a, int b) {  
    a = get(a), b = get(b);  
    if (a != b) merge(b, a);  
}  
int getrnk(int x) {  
    int cnt = tree[ls(x)].siz + 1;  
    while (tree[x].fa) {  
        if (tree[tree[x].fa].r == x)  
            cnt += tree[ls(tree[x].fa)].siz + 1;  
        x = tree[x].fa;  
    }  
    return cnt;  
}  
```

### 3. Prean（Splay简化版） ★★★★  
**亮点**：  
- 单旋Splay实现简洁  
- 查询时直接比较前缀和  
- 合并时找最右节点高效  
**核心代码**：  
```cpp  
void merge(int x, int y) {  
    while (ch[x][1]) x = ch[x][1];  
    ch[x][1] = y, fa[y] = x;  
    splay(y, 0);  
}  
```

---

## 【最优思路提炼】  
**关键技巧**：  
1. **父指针维护根节点**：通过不断跳父指针找到当前序列的根，避免显式存储根数组。  
2. **启发式合并**：在Splay中根据子树深度选择合并方向，保证均摊复杂度。  
3. **排名分裂**（FHQ Treap）：通过计算节点在中序遍历的排名实现O(logn)分裂。  
4. **前缀和差值**：查询时利用splay后的左子树和快速计算区间和。  

---

## 【同类型题推荐】  
1. **P3224 [HNOI2012]永无乡**  
   - 平衡树合并 + 第k大查询  
2. **P2042 [NOI2005]维护数列**  
   - 区间翻转、插入删除等复杂操作  
3. **P3850 [TJOI2007]书架**  
   - 序列插入、删除及排名查询  

---

## 【可视化与算法演示】  
**动画设计**：  
1. **合并过程**：  
   - 显示y链尾（蓝色）向右延伸箭头连接x链头（绿色）  
   - 播放链条拼接音效（金属碰撞声）  
2. **分裂过程**：  
   - 红色闪烁标记分裂点x，左子树渐隐消失  
   - 触发断裂音效（玻璃破碎声）  
3. **查询过程**：  
   - 黄色高亮x到y路径，显示前缀和差值计算式  
   - 正确时播放上升音阶，错误时播放低沉音效  

**复古风格实现**：  
```javascript  
// 像素节点绘制  
function drawNode(x, y, val, color) {  
    ctx.fillStyle = color;  
    ctx.fillRect(x*32, y*32, 30, 30);  
    ctx.fillStyle = '#FFF';  
    ctx.fillText(val, x*32+4, y*32+20);  
}  
// 合并动画  
function animateMerge(x, y) {  
    let fx = findRoot(x), fy = findRoot(y);  
    drawChain(fx, 0x00FF00); // 绿色绘制x链  
    drawChain(fy, 0x0000FF); // 蓝色绘制y链  
    playSound('merge.wav');  
}  
```

---

## 【个人心得摘录】  
> 来自p_b_p_b的调试经历：  
> “比赛时Splay常数过大被卡，赛后发现维护多余的dep变量导致性能下降，删除后通过。”  
> **教训**：平衡树实现需极致优化，避免冗余数据维护。  

> 来自qwaszx的顿悟：  
> “突然意识到LCT的虚边在此题完全无用，直接实链操作即可简化代码。”  
> **启示**：理解问题本质能大幅简化实现。  

---

## 【代码实现片段】  
**FHQ Treap合并与分裂**：  
```cpp  
// 按排名分裂  
void split(int now, int k, int &x, int &y) {  
    if (!now) x = y = 0;  
    else {  
        pushdown(now);  
        if (k <= siz[lc[now]]) {  
            split(lc[now], k, x, lc[now]);  
            y = now;  
        } else {  
            split(rc[now], k - siz[lc[now]] - 1, rc[now], y);  
            x = now;  
        }  
        pushup(now);  
    }  
}  
// 合并两个Treap  
int merge(int x, int y) {  
    if (!x || !y) return x | y;  
    if (rnd[x] < rnd[y]) {  
        rc[x] = merge(rc[x], y);  
        return pushup(x), x;  
    } else {  
        lc[y] = merge(x, lc[y]);  
        return pushup(y), y;  
    }  
}  
```

---
处理用时：94.49秒
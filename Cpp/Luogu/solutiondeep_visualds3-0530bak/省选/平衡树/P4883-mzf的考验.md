# 题目信息

# mzf的考验

## 题目背景

$mzf$立志要成为一个豪杰，当然，他也是一个$OIer$。
他希望自己除了会$OI$之外还会各种东西，比如心理学、吉他、把妹等等。
为了让自己有更大的魅力，他不驼背，不熬夜，整天锻炼，双目炯炯有神，是我们机房最不像$OIer$的人。
然而，在与我们格格不入若干天并且将《易经》研究透彻之后，承受不住我们对他另类的言论，他爆发了。
机房在那一刹那仿佛天塌地陷，世界末日。

## 题目描述

八卦有乾、坤、震、巽、坎、离、艮、兑；
两两组合，一上一下，形成了六十四卦，每卦六爻，一共三百八十四爻。
爻分阴阳，阳爻性属阳刚，阴爻性属阴柔。天下之大，无奇不有。千奇百怪，皆出此处。
$mzf$研究透彻了易经之后，画出了$n$个奇怪的图案。他说那是他改进出来的更强大的卜卦体系。
每一个图案有二十行，每一行要么是阴爻$(0)$，要么是阳爻$(1)$，作为一个$OIer$，我们可以将卦象看成一个个二进制串；
他将$n$个图案画在了符纸上，然后进行$m$次操作：

操作1：翻转区间$[l,r]$的图案，比如$(3,1,2,5)$变成$(5,2,1,3)$；

操作2：$mzf$画地为卦，将$[l,r]$之间的卦象都异或上新画的那个卦象；

操作3：$mzf$会询问机房里的其他人$[l,r]$之间卦象代表的二进制数权值和。

如果不能正确回答每个操作$3$，那么机房风水格局将会改变，我们都将...！

由于$mzf$疯狂之下将我们都捆♂绑♂了起来，所以只能求求你来帮我们解决这个问题。

## 说明/提示

对于 $20\%$ 的数据，$n\le1000$，$m\le 1000$。

对于另外 $20\%$ 的数据，不存在操作 $1$。

对于另外 $20\%$ 的数据，保证 $n$ 为 $2$ 的次幂，且在操作 $1$ 中，保证 $l=i\times(2^j)+1$，$r=(i+1)\times(2^j)$，其中 $i,j$ 为任意值。

对于 $100\%$ 的数据，$n\le 10^5$，$m\le 5\times 10^4$，$1\le l\le r\le n$，$0\le d<2^{20}$。

## 样例 #1

### 输入

```
8 9
4 6 2 1 7 9 10 2
1 1 4
3 1 6
2 4 5 2
3 1 6
2 1 5 8
3 1 6
2 5 7 10
3 4 7
3 1 8
```

### 输出

```
29
29
69
24
59```

# AI分析结果



**唯一算法分类**：平衡树（FHQ Treap/Splay）与位运算拆位

---

### **综合分析与结论**
**核心难点**：在支持区间翻转、异或、求和操作时，需高效维护动态区间信息。异或操作对二进制位的影响需拆位处理，翻转需维护子树结构。

**核心算法流程**：
1. **数据结构选择**：平衡树（FHQ Treap/Splay）处理区间操作，节点记录每个二进制位的出现次数。
2. **异或处理**：对异或值按位拆分，若某位为1，则子树对应位计数变为 `size - cnt`。
3. **翻转处理**：通过交换子树实现，维护翻转标记。
4. **维护区间和**：利用各二进制位的计数计算总和 `sum = Σ(2^i * cnt[i])`。

**可视化设计**：
- **动画步骤**：以像素风格展示平衡树的 `split/merge`，异或时高亮变化的二进制位，翻转时左右子树交换动画。
- **颜色标记**：当前操作节点用红色边框，异或影响的位用闪烁黄色，翻转区域用蓝色箭头表示。
- **音效**：异或操作时播放“哔”声，翻转时“咔嚓”声，计算求和时播放上扬音调。
- **复古风格**：使用8位色调色板，节点用方格表示，二进制位用像素点（0为空心，1为实心）。

---

### **题解清单 (≥4星)**
1. **VenusM1nT（5星）**  
   - **亮点**：FHQ Treap实现清晰，拆位处理异或，维护sum和num数组，代码结构规范。  
   - **核心代码**：`Mxr`函数处理异或时按位翻转计数，`pushup`高效更新子树信息。

2. **Arghariza（4星）**  
   - **优化**：单棵树维护所有位，减少重复存储，通过`sum`和`cnt`数组动态计算异或后的值，降低常数。  
   - **关键代码**：`pushxor`函数统一处理异或标记，避免拆位维护多棵树。

3. **周道_Althen（4星）**  
   - **实现**：完整FHQ Treap框架，`Xor`函数显式处理二进制位，标记下传逻辑清晰，适合教学。  
   - **个人心得**：强调异或拆位的必要性，通过`num`数组优化求和计算。

---

### **最优思路/技巧提炼**
1. **位运算拆位**：将异或拆解到每个二进制位独立维护，通过 `cnt[i]` 统计子树中第i位为1的数量。
2. **标记下传优化**：异或标记统一处理，避免多次拆分；翻转标记交换子树，保持平衡树结构。
3. **动态求和计算**：利用二进制位计数快速计算区间和，避免每次查询遍历所有元素。

---

### **同类型题推荐**
1. **CF242E**：区间异或、区间求和（线段树拆位）
2. **P3391**：文艺平衡树（区间翻转）
3. **P2572**：序列操作（区间覆盖、翻转、求和）

---

### **核心代码片段（VenusM1nT）**
```cpp
void Mxr(int rt, int v) {
    tag[rt] ^= v; val[rt] ^= v; sum[rt] = 0;
    for (int i = 0; i <= K; i++) fg[i] = (v >> i) & 1;
    for (int i = 0; i <= K; i++) {
        if (fg[i]) num[rt][i] = siz[rt] - num[rt][i];
        sum[rt] += (1ll << i) * num[rt][i];
    }
}
void pushup(int rt) {
    siz[rt] = siz[ch[rt][0]] + siz[ch[rt][1]] + 1;
    sum[rt] = sum[ch[rt][0]] + sum[ch[rt][1]] + val[rt];
    for (int i = 0; i <= K; i++)
        num[rt][i] = num[ch[rt][0]][i] + num[ch[rt][1]][i] + ((val[rt] >> i) & 1);
}
```
**说明**：`Mxr`处理异或标记，按位翻转计数；`pushup`更新子树大小和位计数。

---

### **可视化实现思路**
1. **Canvas绘制**：节点用方格表示，内部20个小点表示二进制位（0/1）。
2. **动画流程**：
   - **异或操作**：遍历受影响的位，实心点与空心点互换，伴随黄色高亮。
   - **翻转操作**：左右子树位置交换动画，蓝色箭头指示方向。
3. **音效触发**：调用`Mxr`时播放位翻转音效，`merge/split`时播放节点移动音效。
4. **自动演示**：按操作顺序逐步执行，速度可调，支持暂停观察当前状态。

---
处理用时：64.46秒
# 题目信息

# 【模板】可持久化文艺平衡树

## 题目背景

这是一道模板题。

## 题目描述

您需要写一种数据结构，来维护一个序列，其中需要提供以下操作（**对于各个以往的历史版本**）：

1. 在第 $p$ 个数后插入数 $x$。
2. 删除第 $p$ 个数。
3. 翻转区间 $[l,r]$，例如原序列是 $\{5,4,3,2,1\}$，翻转区间 $[2,4]$ 后，结果是 $\{5,2,3,4,1\}$。
4. 查询区间 $[l,r]$ 中所有数的和。

**和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本（操作 $4$ 即保持原版本无变化），新版本即编号为此次操作的序号。**

**本题强制在线。**

## 说明/提示

**强制在线：以下针对 $p_i, x_i, l_i, r_i$ 的限制均是按位异或 $lastans$ 后的限制。**

- 对于 $6$ 个测试点，$n \le 5000$。
- 对于另外 $6$ 个测试点，$v_i = i - 1$。
- 欢迎用户加强数据，可联系管理员或出题人。

对于 $100\%$ 的数据，$1 \le n \le 2 \times {10}^5$，$|x_i| < {10}^6$。

假设基于的历史版本的序列长度为 $len \ge 1$，有：  
若 $\mathrm{opt}_i=1$，则 $0 \le p_i \le len$。  
若 $\mathrm{opt}_i=2$，则 $1 \le p_i \le len$。  
若 $\mathrm{opt}_i=3$，则 $1 \le l_i \le r_i \le len$。  
若 $\mathrm{opt}_i=4$，则 $1 \le l_i \le r_i \le len$。

假设基于的历史版本的序列长度为 $0$，有：  
$\mathrm{opt}_i=1$，$p_i=0$。

## 样例 #1

### 输入

```
10
0 1 0 1
1 1 1 2
2 4 1 2
3 1 2 0
4 4 2 1
5 3 5 7
6 4 5 6
4 1 7 1
8 3 4 6
9 4 4 1```

### 输出

```
3
4
5
10```

# AI分析结果



**算法分类**：可持久化平衡树（FHQ Treap）

---

### **题解核心思路与难点对比**

1. **核心思路**  
   所有题解均基于 **FHQ Treap** 实现可持久化，通过路径复制保证历史版本不变。关键操作：
   - **分裂（Split）**：复制经过的节点，维护新旧版本树结构
   - **合并（Merge）**：直接合并已复制的子树，无需额外复制
   - **翻转标记**：下传时复制子节点并交换左右子树

2. **解决难点**  
   - **节点复制策略**：仅在 Split 和标记下传时复制节点（如 `KevinYu` 的 `copy_node`）
   - **懒标记处理**：翻转时仅标记当前节点，下传时复制子节点（`push_down` 中复制）
   - **空间优化**：复用删除节点（`Ireliaღ` 的垃圾回收机制）

3. **对比差异**  
   - **mrsrz**：维护正/反两个 Treap，避免下传标记时的复制开销
   - **EnofTeiPeople**：使用 WBLT（Weight Balanced Leafy Tree）优化合并效率

---

### **高星题解推荐（≥4星）**

1. **KevinYu（5星）**  
   - 亮点：详细讲解 FHQ Treap 基础操作，代码结构清晰，注释完整
   - 关键代码：`split` 时动态复制节点，`merge` 直接使用已有子树

2. **mrsrz（4.5星）**  
   - 亮点：双 Treap 处理翻转，避免标记下传的复制开销
   - 关键代码：维护正反序列，互换对应区间

3. **EnofTeiPeople（4星）**  
   - 亮点：WBLT 实现，优化合并效率
   - 关键代码：按子树大小比例合并，减少递归深度

---

### **最优技巧提炼**

1. **路径复制**  
   ```cpp
   void split(int p, int k, int &x, int &y) {
       if (!p) { x=y=0; return; }
       push_down(p);
       if (左子树大小 < k) {
           x = copy_node(p); // 复制当前节点
           split(右子树, k - 左子树大小 -1, x->右, y);
       } else { ... }
   }
   ```
   - **复制时机**：仅在 Split 路径上的节点，Merge 不复制

2. **懒标记优化**  
   ```cpp
   void push_down(int p) {
       if (t[p].tag) {
           swap(lson, rson);
           if (lson) lson = copy_node(lson); // 仅复制被访问的子节点
           if (rson) rson = copy_node(rson);
       }
   }
   ```

---

### **同类型题目推荐**

1. [P3919 【模板】可持久化线段树](https://www.luogu.com.cn/problem/P3919)  
2. [P3835 【模板】可持久化平衡树](https://www.luogu.com.cn/problem/P3835)  
3. [P3391 【模板】文艺平衡树](https://www.luogu.com.cn/problem/P3391)

---

### **可视化设计**

**动画方案**：  
1. **节点复制高亮**：分裂时，复制的节点显示为绿色，原节点灰色  
2. **翻转过程**：交换子树时，子树整体平移并变色（红→蓝）  
3. **懒标记传播**：标记下传时，子节点闪烁黄色提示复制  

**复古游戏化**：  
- **8-bit 音效**：复制节点时播放“滴”声，合并时“嘟”声  
- **像素风格**：Treap 节点显示为方块，子树大小用不同颜色深度表示  
- **自动演示**：按操作步骤逐步显示 Split/Merge，支持暂停/加速  

---

### **代码片段（KevinYu 题解核心）**

```cpp
void split(int p, int k, int &x, int &y) {
    if (!p) { x=y=0; return; }
    push_down(p);
    if (t[ls(p)].size < k) {
        x = copy_node(p); // 关键复制点
        split(rs(x), k - t[ls(p)].size -1, rs(x), y);
        push_up(x);
    } else { ... }
}

int merge(int x, int y) {
    if (!x || !y) return x|y;
    if (pri[x] < pri[y]) {
        push_down(x);
        rs(x) = merge(rs(x), y);
        push_up(x); return x;
    } else { ... }
}
```

---

**总结**：可持久化平衡树通过路径复制和懒标记优化，在保证历史版本不变的前提下高效处理动态操作。FHQ Treap 的非旋转特性使其成为实现可持久化的理想选择，核心在于精准控制节点复制的时机与范围。

---
处理用时：75.49秒
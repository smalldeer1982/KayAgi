# 题目信息

# SubString

## 题目描述

给定一个字符串 `init`，要求支持两个操作：

- 在当前字符串的后面插入一个字符串。

- 询问字符串 $s$ 在当前字符串中出现了几次。(作为连续子串)

强制在线。

## 说明/提示

$|\mathrm{init}| \leq 6 \times 10^5$，$Q \leq 6\times 10^5$，询问总长度 $\leq 3 \times 10^6$。

保证字符串中只会出现 `A` 和 `B`。

为防止评测过慢，对于测试点 $2,3,5,6,8,11$ 时限为 3s，其余为 1s。

原题：BZOJ 2555

## 样例 #1

### 输入

```
2
A
QUERY B
ADD BBABBBBAAB```

### 输出

```
0```

# AI分析结果



# **算法分类**  
动态后缀自动机（SAM）与 Link-Cut Tree（LCT）结合

---

## **题解思路与核心难点对比**

### **核心思路**
1. **SAM 维护子串结构**  
   所有题解均使用 SAM 构建子串状态机，每个节点对应一系列子串的等价类。
2. **LCT 动态维护 Parent 树**  
   SAM 的 Parent 树用于表示后缀链接关系，动态插入时需要支持树的断边和连边操作，LCT 高效实现这一过程。
3. **子树和动态更新**  
   子串出现次数对应 SAM 节点在 Parent 树中的子树和，LCT 通过链加或虚子树维护实现动态求和。

### **解决难点**
1. **强制在线与动态插入**  
   传统 SAM 的 Parent 树是静态的，但动态插入字符会导致树结构变化。LCT 支持动态调整树结构，同时维护子树和。
2. **路径标记与虚子树处理**  
   - **皎月半洒花**：通过 `access` 和 `splay` 将新建节点路径转化为链，直接在链头打标记实现路径加。  
   - **一扶苏一**：维护虚子树和（`si`）和 Splay 子树和（`sr`），通过 `access(u)` 提取虚子树信息，直接计算总和。
3. **节点分裂时的信息继承**  
   SAM 分裂节点时需要复制权值（如 `vl(nq) = vl(q)`），并调整 LCT 的链接关系，保证分裂后的子树和正确。

---

## **题解评分（≥4星）**
1. **皎月半洒花（5星）**  
   - **亮点**：通过路径压缩简化链加操作，利用 LCT 的 `splay` 特性直接维护路径和。  
   - **代码优化**：避免冗余的 `makeroot`，提升常数效率。
2. **一扶苏一（5星）**  
   - **亮点**：通过虚子树和与 Splay 子树和的分离，实现直观的子树和查询。  
   - **理论清晰**：详细推导 LCT 维护子树和的数学关系。
3. **asuldb（4星）**  
   - **简洁性**：代码结构清晰，直接通过 `splay` 后读取节点权值，简化逻辑。  
   - **调试经验**：注释中提到调试过程，体现实践价值。

---

## **最优思路与技巧提炼**
1. **LCT 路径标记法**  
   - **核心操作**：插入新字符时，将新节点到根的路径转化为链，直接打标记实现子树和更新。  
   - **实现步骤**：  
     ```cpp
     void Ins(int x) {
         int np = ++size; // 新建 SAM 节点
         link(np, parent); // LCT 链接到父节点
         merge(1, np); // 将路径转化为链
         vl(np)++; tg(np)++; // 路径加标记
     }
     ```
2. **虚子树和分离法**  
   - **核心公式**：`ss = si + sr + sz`（虚子树和 + Splay 子树和 + 自身权值）。  
   - **查询实现**：  
     ```cpp
     int Query(int u) {
         access(u); splay(u); // 提取虚子树
         return u->si + u->sz; // 虚子树和 + 自身权值
     }
     ```

---

## **同类型题与算法套路**
- **通用模式**：动态维护树结构上的子树和或路径和。  
- **类似题目**：  
  1. [P3975 动态 SAM 模板题](https://www.luogu.com.cn/problem/P3975)  
  2. [P4219 动态树分治](https://www.luogu.com.cn/problem/P4219)  
  3. [P5354 强制在线的子树查询](https://www.luogu.com.cn/problem/P5354)

---

## **可视化与算法演示**
### **核心流程**
1. **SAM 插入字符**  
   - **动画效果**：字符逐个插入，SAM 节点动态扩展，Parent 树链接关系变化。  
   - **高亮元素**：新建节点 `np`、分裂产生的 `nq`，红色标记变化路径。
2. **LCT 维护 Parent 树**  
   - **交互操作**：点击节点展示其 Splay 子树结构，虚线表示虚边。  
   - **路径加演示**：插入时从 `np` 到根路径变为蓝色，标记逐步下放。
3. **查询子串出现次数**  
   - **追踪过程**：输入查询串时，绿色箭头沿 SAM 转移边移动，终点节点高亮显示当前权值。

### **复古像素化风格**
- **颜色方案**：8-bit 色调（#FF0000 红、#00FF00 绿、#0000FF 蓝）。  
- **Canvas 绘制**：  
  ```javascript
  function drawNode(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x*20, y*20, 18, 18); // 像素方块表示节点
  }
  ```
- **音效设计**：  
  - **插入成功**：短促“哔”声（Web Audio 生成方波）。  
  - **查询结果**：根据结果播放不同音调（成功：高音；失败：低音）。

---

## **代码核心片段**
### **皎月半洒花的 LCT 实现**
```cpp
// LCT 路径加与查询
void Ins(int x) {
    int np = ++size, p = last;
    len[np] = len[p] + 1;
    while (p && !trans[p][x]) 
        trans[p][x] = np, p = fal[p];
    if (!p) {
        link(np, 1); 
        merge(1, np); // 路径转化为链
        vl(np)++; tg(np)++; // 链加
    }
    // ... 处理分裂逻辑
}

// 查询时获取权值
int Query(char *s) {
    int rt = 1;
    for (int i=0; s[i]; i++) 
        rt = trans[rt][s[i]-'A'];
    splay(rt); 
    return vl(rt); // 直接读取节点权值
}
```

---

## **个人心得摘录**
- **调试教训**（asuldb）：SAM 分裂节点时未正确继承权值，导致答案错误。需特别注意复制节点时的权值初始化。  
- **优化技巧**（皎月半洒花）：避免不必要的 `makeroot` 可显著提升常数效率，尤其是在高频插入场景。

---
处理用时：84.54秒
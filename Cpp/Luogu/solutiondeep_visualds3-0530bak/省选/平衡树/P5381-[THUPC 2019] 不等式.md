# 题目信息

# [THUPC 2019] 不等式

## 题目描述

> 时光回到 2017 年 6 月 7 日。午后，阳光正好。
>
> 现在的你，在考场中笔耕不辍。在刷刷声中，你填写着交给从前和未来的自己的答卷。
> 
> 像无数次训练过的那样，你直接跳到了这张数学试卷的最后一道大题，二选一的题目直接选择了后者。快速地掠过了题目描述，紧缩的眉头渐渐放松。
> 
> 「稳了。」
>
> 你一刻也不敢停留，又向你的梦想靠近了一小步。

已知两个 $n$ 维实向量 $\vec{a}=(a_1,a_2,\dots,a_n),\vec{b}=(b_1,b_2,\dots,b_n)$，定义 $n$ 个定义域为 $\mathbb{R}$ 函数 $f_1,f_2,\dots,f_n$：

$$f_k(x)=\sum_{i=1}^{k} \lvert a_ix+b_i\rvert \quad (k=1,2,\dots,n)$$

现在，对于每个 $k=1,2,\dots,n$，试求 $f_k$ 在 $\mathbb{R}$ 上的最小值。可以证明最小值一定存在。

## 说明/提示

### 样例解释

$f_1(x)=\lvert x+1\rvert$，显然在 $x=-1$ 处取到最小值 $0$；

$f_2(x)=\lvert x+1\rvert +\lvert x+2\rvert$，可以证明其在 $[-2,-1]$ 中任意位置取到最小值 $1$。

##### 后记

后来，全国三卷的考生们又回想起了被参数方程支配的恐惧。

##### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。

## 样例 #1

### 输入

```
2
1 1
1 2```

### 输出

```
0.00000
1.00000```

# AI分析结果



## 唯一算法分类  
**中位数维护与加权求和**

---

## 综合分析与结论  
### 核心思路
所有题解均基于以下数学原理：  
$$\sum |a_ix+b_i| \xrightarrow{变形} \sum |a_i|\cdot|x+\frac{b_i}{a_i}|$$  
将每个项视为数轴上的点，问题转化为**动态维护带权中位数**并计算其到所有点的带权距离和。

### 算法流程与可视化设计  
**核心流程**：  
1. **预处理**：将每个 $(a_i,b_i)$ 转化为点 $x_i=-\frac{b_i}{a_i}$ 并赋予权重 $w_i=|a_i|$  
2. **动态维护**：维护一个有序集合，支持插入新点并快速查询中位数位置  
3. **求和计算**：在中位数分割点两侧分别计算加权距离和  

**可视化要点**：  
- **像素风格数轴**：用 16 色像素块表示离散化后的点，权重以颜色深度表示  
- **中位线高亮**：每次插入后，用闪烁红线标记当前中位线位置  
- **动态累加器**：右侧显示当前总权重、左侧总和、右侧总和等关键变量  
- **音效触发**：插入点（8-bit 点击音）、中位线移动（滑声音效）、计算结果（成功音）  

---

## 题解清单 (≥4星)  
### 1. hehezhou (5星)  
**亮点**：  
- 无旋 Treap 直接维护带权点集  
- 代码中 `split_key` 与 `split_rank` 实现优雅  
- 实时维护左侧总和与右侧总和  

**核心代码**：  
```cpp
split_key(rt, add, x, y); // 按值分裂
rt = merge(merge(x, newnode(add, a[i])), y); // 插入新点
split_rank(rt, (t[rt].size + 1)/2, x, y); // 找中位数
```

### 2. TheLostWeak (4星)  
**亮点**：  
- 离散化预处理避免浮点精度问题  
- 线段树维护离散化后的区间统计量  
- 交叉相乘比较分数大小避免除法误差  

**关键公式**：  
$$ans = e\cdot sumL - sumL_{val} + sumR_{val} - e\cdot sumR$$  
其中 $e$ 为中位数值，$sumL/sumR$ 为左右侧权重和  

### 3. wosile (4星)  
**亮点**：  
- 树状数组实现简洁高效  
- 离散化与二分查找结合  
- 维护两个树状数组分别处理权重和加权值  

---

## 最优思路提炼  
### 核心技巧  
1. **权重离散化**：将 $\frac{b_i}{a_i}$ 离散化为整数坐标，避免浮点运算  
2. **双堆技巧**：维护大小堆动态跟踪中位数（未在题解出现但可拓展）  
3. **前缀和差分**：利用线段树/树状数组快速计算区间和  

### 思维突破点  
- **绝对值的几何意义** -> 中位数最优性  
- **权重等效**：将 $|a_i|$ 个点视为 $a_i$ 个相同点  

---

## 相似题目推荐  
1. **P1168** 中位数（静态中位数维护）  
2. **CF1005E2** 带权中位数扩展  
3. **P3478** 绝对值最小和（树形结构版）  

---

## 个人心得摘录  
> "写平衡树时，`split_rank` 的参数容易漏掉左侧子树大小，调试了 2 小时才找到这个边界问题" —— hehezhou  
> "离散化时交叉相乘比较分数，比直接除法的精度高一个数量级" —— TheLostWeak  

---

## 可视化与复古动画设计  
### Canvas 动画方案  
```javascript
class MedianViz {
  constructor(canvas) {
    this.ctx = canvas.getContext('2d');
    this.points = []; // {x: 离散化坐标, w: 权重}
    this.medianLine = null;
    
    // 8-bit 调色板
    this.colors = ['#000', '#F00', '#0F0', '#00F', '#FF0', '#F0F', '#0FF', '#FFF'];
  }

  draw() {
    this.ctx.clearRect(0, 0, 800, 200);
    // 绘制数轴
    this.points.forEach(p => {
      const x = p.x * 10 + 100; // 离散化坐标转像素
      const hue = Math.min(7, Math.log2(p.w)); // 权重对应颜色
      this.ctx.fillStyle = this.colors[hue];
      this.ctx.fillRect(x, 100, 5, 5); // 5x5 像素块
    });
    
    // 绘制中位线
    if(this.medianLine) {
      this.ctx.fillStyle = '#F00';
      this.ctx.fillRect(this.medianLine*10+100, 80, 3, 40); // 红色竖线
    }
  }

  addPoint(x, w) {
    playSound('insert'); // 8-bit 插入音效
    this.points.push({x, w});
    this.points.sort((a,b) => a.x - b.x);
    this.updateMedian();
    this.draw();
  }

  updateMedian() {
    let total = this.points.reduce((s, p) => s + p.w, 0);
    let half = total / 2, sum = 0;
    for(let p of this.points) {
      sum += p.w;
      if(sum >= half) {
        this.medianLine = p.x;
        playSound('median'); // 中位线移动音效
        break;
      }
    }
  }
}
```

### 音效设计  
- `insert.wav`: 1kHz 方波，持续时间 50ms  
- `median.wav`: 上升滑音（500Hz→1kHz），标记中位线移动  
- `calc.wav`: 成功音（C大调和弦 8-bit 版）  

---

## 关键代码片段  
### 线段树核心维护  
```cpp
struct SMT {
  ll sz[N<<2];   // 节点权重和
  double sum[N<<2]; // 节点加权值

  void update(int p, int l, int r, int x, int w, double v) {
    if(l == r) {
      sz[p] += w;
      sum[p] += v * w;
      return;
    }
    int mid = (l + r) >> 1;
    if(x <= mid) update(p<<1, l, mid, x, w, v);
    else update(p<<1|1, mid+1, r, x, w, v);
    sz[p] = sz[p<<1] + sz[p<<1|1];
    sum[p] = sum[p<<1] + sum[p<<1|1];
  }

  int kth(int p, int l, int r, int k) {
    if(l == r) return l;
    int mid = (l + r) >> 1;
    if(sz[p<<1] >= k) return kth(p<<1, l, mid, k);
    return kth(p<<1|1, mid+1, r, k - sz[p<<1]);
  }
};
```

---

通过将数学洞察与高效数据结构结合，此类问题可在 $O(n\log n)$ 时间内解决。可视化设计应着重体现权重累加与中位数跳变过程，帮助理解动态维护的本质。

---
处理用时：92.75秒
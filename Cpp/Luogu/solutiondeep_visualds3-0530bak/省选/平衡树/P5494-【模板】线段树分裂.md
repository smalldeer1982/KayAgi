# 题目信息

# 【模板】线段树分裂

## 题目描述

给出一个可重集 $a$（编号为 $1$），它支持以下操作：

`0 p x y`：将可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值移动到一个新的可重集中（新可重集编号为从 $2$ 开始的正整数，是上一次产生的新可重集的编号+1）。

`1 p t`：将可重集 $t$ 中的数放入可重集 $p$，且清空可重集 $t$（数据保证在此后的操作中不会出现可重集 $t$）。

`2 p x q`：在 $p$ 这个可重集中加入 $x$ 个数字 $q$。

`3 p x y`：查询可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值的个数。

`4 p k`：查询在 $p$ 这个可重集中第 $k$ 小的数，不存在时输出 `-1`。

## 说明/提示

对于 $30\%$ 的数据，$1\leq n \leq {10}^3$，$1 \le m \le {10}^3$；  
对于 $100\%$ 的数据，$1 \le n \le 2 \times {10}^5$，$1 \le x, y, q \le m \le 2 \times {10}^5$。保证数据合法。

不开 `long long` 见祖宗！！

---

题面 by @[Limit](https://www.luogu.com.cn/user/86625)

std by @[Limit](https://www.luogu.com.cn/user/86625)（线段树分裂）

验题 by @[Froggy](https://www.luogu.com.cn/user/100285)（平衡树，不过合并的复杂度假掉了，倒数第二个测试点就是 hack 数据）

数据 by @[Froggy](https://www.luogu.com.cn/user/100285)

## 样例 #1

### 输入

```
5 12
0 0 0 0 0
2 1 1 1
2 1 1 2
2 1 1 3
3 1 1 3
4 1 2
2 1 1 4
2 1 1 5
0 1 2 4
2 2 1 4
3 2 2 4
1 1 2
4 1 3```

### 输出

```
3
2
4
3
```

# AI分析结果



### **算法分类**  
线段树分裂与合并（动态开点权值线段树）

---

### **综合分析与结论**  
**核心思路**：利用动态开点权值线段树维护可重集，通过分裂操作提取特定区间元素，合并操作整合两集合，辅以单点修改、区间查询及第k小查询。  
**难点**：  
1. **分裂逻辑**：按区间值域分割线段树，需递归处理左右子树并调整节点归属。  
2. **内存管理**：动态开点需配合节点回收，避免内存溢出。  
**解决方案**：  
- **分裂**：仿照FHQ Treap的分裂方式，根据左子树大小判断分裂方向。  
- **合并**：递归合并子树，回收无用节点。  
**可视化设计**：  
- **动画**：以网格色块表示线段树节点，分裂时高亮分割区间，合并时合并色块。  
- **复古风格**：8位像素色块，音效提示分裂/合并操作，自动演示模式展示递归流程。

---

### **题解清单（评分≥4星）**  
1. **ix35（5星）**  
   - **亮点**：详细推导时间复杂度，清晰的分裂/合并代码实现，垃圾回收机制。  
   - **代码**：动态开点+节点池复用，逻辑严谨。  

2. **cyffff（4.5星）**  
   - **亮点**：结构清晰，应用场景举例（如排序问题），代码简洁易读。  
   - **技巧**：分裂函数处理三种情况，类似FHQ Treap。  

3. **Limit（4星）**  
   - **亮点**：空间回收优化显著，析构函数自动释放内存。  
   - **代码**：通过构造函数/析构函数管理树结构，适合C++特性。  

---

### **最优思路与代码实现**  
**关键逻辑**：动态开点线段树的分裂与合并，节点回收机制。  
**代码片段**（ix35实现核心部分）：  
```cpp
// 线段树分裂
void split(int x, int &y, ll k) {
    if (!x) return;
    y = newnode();
    ll v = val[ch[x][0]];
    if (k > v) split(ch[x][1], ch[y][1], k - v);
    else swap(ch[x][1], ch[y][1]);
    if (k < v) split(ch[x][0], ch[y][0], k);
    val[y] = val[x] - k;
    val[x] = k;
}

// 线段树合并
int merge(int x, int y) {
    if (!x || !y) return x + y;
    val[x] += val[y];
    ch[x][0] = merge(ch[x][0], ch[y][0]);
    ch[x][1] = merge(ch[x][1], ch[y][1]);
    del(y);
    return x;
}
```

---

### **同类型题推荐**  
1. **P4556 [Vani有约会]雨天的尾巴**（线段树合并经典题）  
2. **P2824 [HEOI2016/TJOI2016]排序**（线段树分裂维护有序区间）  
3. **P3960 [NOIP2017 提高组] 列队**（动态开点+区间操作）  

---

### **可视化设计要点**  
1. **像素风格**：  
   - 使用16色调色板，线段树节点显示为色块，区间范围标注在色块下方。  
   - 分裂时被分割区间闪烁红色，合并时节点渐变为绿色。  

2. **动画交互**：  
   - **步进控制**：空格暂停/继续，方向键单步前进/回退。  
   - **音效**：分裂时播放「切割」音效，合并时播放「融合」音效。  

3. **自动演示**：  
   - 递归过程以慢速展开，当前处理节点高亮黄色，子树递归时颜色渐变。  

---

**总结**：线段树分裂合并是高效处理动态集合操作的核心技术，结合动态开点与内存回收可应对大规模数据。理解递归分割逻辑与节点管理机制是关键。

---
处理用时：68.75秒
# 题目信息

# [P5350] 序列 (加强版)

## 题目背景

本题为 [P5350](https://www.luogu.org/problem/P5350) 的加强版。  
本题很良心，不卡空间！  


## 题目描述

有一个序列 $a_n$ 和 $q$ 次操作。

- `1 l r` 求区间 $[l,r]$ 的和  
- `2 l r k` 区间 $[l,r]$ 赋值为 $k$  
- `3 l r k` 区间 $[l,r]$ 加上 $k$  
- `4 l1 r1 l1 r2` 将区间 $[l_1,r_1]$ 复制到 $[l_2,r_2]$ 处  
- `5 l1 r1 l2 r2` 将区间 $[l_1,r_1]$ 与 $[l_2,r_2]$ 交换  
- `6 l r` 翻转区间 $[l,r]$

最后还要输出整个序列，所有输出都要对 $10^9+7$ 取模。

为了卡掉某些乱搞做法，**本题强制在线**。  

每次操作中，除了输入第一个数，其它所有数都需要异或 $\text{last}$ 才是实际的操作。  
$\text{last}$ 为上一次 $1$ 操作的答案 $\pmod{10^9 +7}$，定义初始 $\text{last} = 0$。  


## 说明/提示

【数据范围】   
$1\le n,q \le 3\times 10^5$  
$0\le a_i,k \le 10^9$   
对于 $4,5$ 操作，保证 $r_1-l_1 = r_2-l_2$ 且 $[l_1,r_1] \cap [l_2,r_2] = \varnothing$

**不保证数据随机** 且 **没有梯度**   
想交 ODT 的就算了吧！

## 样例 #1

### 输入

```
10 10
7 1 3 2 2 4 0 1 2 2 
4 10 10 3 3
3 4 10 5
6 6 7
6 9 10
1 10 10
5 14 13 1 0
2 15 13 7
5 3 3 2 2
5 5 3 15 13
3 4 14 7```

### 输出

```
7
7 0 0 0 7 7 7 1 2 7```

# AI分析结果



**唯一算法分类**  
可持久化平衡树（FHQ Treap）  

---

### **题解思路、算法要点与解决难点**  
**核心思路**：通过可持久化平衡树（FHQ Treap）维护序列，实现高效的区间操作。  
1. **可持久化**：每次修改操作（如复制、赋值、翻转等）时克隆节点，保留旧版本数据，避免冲突。  
2. **引用计数**（优化空间）：部分题解通过引用计数管理节点，减少不必要的克隆和空间浪费。  
3. **定期重构**：当节点数量超过阈值时，将树展开为数组重新构建，控制内存使用。  

**解决难点**：  
- **复制操作**：可持久化允许直接克隆子树插入目标位置，无需遍历复制。  
- **强制在线处理**：操作参数需异或上一次查询结果，需在输入时动态调整。  
- **标记下传与克隆顺序**：在`pushdown`时先克隆子节点再下传标记，避免共享节点被错误修改。  

---

### **题解评分 (≥4星)**  
1. **Star_Cried（5星）**  
   - 使用可持久化FHQ Treap，完整实现所有操作。  
   - 定期重构优化空间，代码清晰且有详细注释。  
   - 关键技巧：`clone`函数统一处理节点克隆，`pushdown`顺序严谨。  
   - **个人心得**：调试中注意区间端点顺序，重构时需重新`pushdown`。  

2. **Pulsating_Dust（4.5星）**  
   - 引用计数减少克隆次数，空间复杂度优化至线性。  
   - 代码简洁，`check`函数实现写时复制（Copy-on-Write）。  
   - **亮点**：`Kill`函数递归释放引用计数为0的节点。  

3. **Leap_Frog（4星）**  
   - 可持久化ODT的魔改版，尝试用平衡树模拟ODT。  
   - 代码实现定期重构，但未完全解决空间问题。  
   - **缺点**：注释较少，可读性略低。  

---

### **最优思路或技巧提炼**  
1. **可持久化+引用计数**：  
   - 克隆节点时检查引用计数，仅当引用>1时复制，减少内存占用。  
   - 定期重构防止空间爆炸，阈值设为`3.6e6`节点（参考题解）。  
2. **标记下传顺序**：  
   ```cpp  
   inline void pushdown(int &rt) {  
       check(rt); // 先克隆再下传标记  
       if (~tr[rt].set) { ... }  
   }  
   ```  
3. **强制在线处理**：  
   ```cpp  
   l ^= last; r ^= last; // 输入参数异或last  
   ```  

---

### **同类型题或类似算法套路**  
- **区间操作+可持久化**：P5055（可持久化文艺平衡树）、P3835（可持久化并查集）。  
- **引用计数优化**：P5278（区间K大数，内存敏感场景）。  

---

### **推荐相似题目**  
1. **P5055** 【模板】可持久化文艺平衡树  
2. **P5586** 序列（本题原题）  
3. **P3835** 可持久化并查集  

---

### **个人心得摘录**  
- **Star_Cried**：重构时需遍历整树`pushdown`，否则未下传的标记会导致重建错误。  
- **Leap_Frog**：调试中发现`split`后未正确处理引用计数，导致节点被意外释放。  

---

### **可视化与算法演示**  
**动画方案**：  
1. **节点克隆**：用绿色高亮新克隆节点，红色标记原节点。  
2. **平衡树分裂/合并**：  
   - **分裂**：黄色指针从根向下移动，按子树大小切分。  
   - **合并**：蓝色箭头连接左右子树，随机优先级决定父子关系。  
3. **引用计数显示**：每个节点标注引用计数，数值变化时闪烁提示。  

**复古游戏化设计**：  
- **像素风格**：  
  - 节点用8x8像素块表示，左右子树箭头为16色像素。  
  - 背景音乐：8-bit风格循环音轨，节点克隆时播放“哔”声。  
- **AI自动演示**：  
  ```javascript  
  function autoPlay() {  
    while (step < maxStep) {  
      visualizeSplit();  
      setTimeout(() => {}, 500); // 步进延迟  
    }  
  }  
  ```  

---

### **核心代码实现（Star_Cried题解）**  
**关键函数：复制操作**  
```cpp  
inline void copy() {  
    int l1=read(), r1=read(), l2=read(), r2=read();  
    // 处理区间顺序  
    if (r1 > r2) swap(l1, l2), swap(r1, r2);  
    // 分裂出目标区间和被复制区间  
    split(rt, r2, d, e); split(d, l2-1, c, d);  
    split(c, r1, b, c); split(b, l1-1, a, b);  
    // 克隆并合并  
    rt = merge(a, merge(b, merge(c, merge(b, e))));  
}  
```  

**定期重构**：  
```cpp  
if (S.tot > 3600000) {  
    n = 0;  
    S.push(S.rt); // 展开为数组  
    S.rt = S.build(); // 重新构建平衡树  
}  
```  

**完整代码参考原题解**（已省略）。

---
处理用时：73.39秒
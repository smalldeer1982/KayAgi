# 题目信息

# 查找 Search

## 题目背景

>   也许，同学间最好的结局就是朋友吧。

$\mu ry$ 是一个可爱的女孩子。

在她所住的小区里有排成一排的 $n$ 个垃圾桶，从左至右第 $i$ 个垃圾桶里都装着编号为 $a_i$ 的垃圾。

$\mu ry$ 不喜欢无序，于是就想把社区里编号和为 $w$ 的垃圾都清在一起。

但是调皮的 $\text{LeverImmy}$ 可能会把某个垃圾桶里的垃圾偷换成另一种。

生气的 $\mu ry$ 想考考 $\text{LeverImmy}$ 一个区间 $[l, r]$ 内是否存在编号和为 $w$ 的垃圾。

但 $\text{LeverImmy}$ 也不会解决这个问题，于是他找到了聪明的你。


## 题目描述

给定 $n$ 个垃圾桶，你需要维护一个数据结构，支持以下操作：

-   `1 pos val` 表示将 第 $pos$ 个垃圾桶里的垃圾的编号换成 $val$；

-   `2 l r` 询问在 $[l\oplus cnt, r\oplus cnt]$ 内是否存在垃圾编号和为 $w$ 的 **两个** 垃圾桶。

其中 $\oplus$ 表示异或运算，$cnt$ 表示在 **此次询问之前**，答案为 `Yes` 的个数。

对于每个操作 2，若存在请输出 `Yes`，不存在请输出 `No`。

值得注意的是，对于所有询问， $w$ 为 **同一个数**。


## 说明/提示

本题采用 **捆绑测试**，开启 **O2优化**。

$\text{Subtask 1 (7 pts)}:$ 保证 $1 \le n, m, w \le 2\cdot10^3$，**时限 $1\text{s}$**；

$\text{Subtask 2 (20 pts)}:$ 保证 $1 \le n, m, w \le 1\cdot10^5$，$opt = 2$，**时限 $2\text{s}$**；

$\text{Subtask 3 (30 pts)}:$ 保证 $1 \le n, m, w \le 1\cdot10^5$，**时限 $2\text{s}$**；

$\text{Subtask 4 (43 pts)}:$ 没有特殊限制，**时限 $4\text{s}$**；

对于所有数据， $1 \le n, m, w \le 5\cdot10^5$，$0 \le a_i \le w$。

数据保证对于每个操作，$1 \le pos \le n$，$0 \le val \le w$，$1 \le l \le r \le n$。

由于输入输出量较大，建议使用更快的输入输出方式。

---

#### 输入 #1 解释

第一次操作，询问区间 $[1, 4]$ 中是否有两个数加起来为 $6$，显然有$a_1 + a_4 = 6$，因此输出 `Yes`；

第二次操作，修改 $a_4$ 为 $1$，则序列变为 $[1, 3, 2, 1, 5, 6]$；

第三次操作，询问区间 $[1, 4]$ 中是否有 **两个** 数加起来为 $6$，无，因此输出 `No`。

第四次操作，询问区间 $[2, 6]$ 中是否有两个数加起来为 $6$，显然有 $a_4 + a_5 = 6$，因此输出 `Yes`。


## 样例 #1

### 输入

```
6 4 6
1 3 2 5 5 6
2 1 4
1 4 1
2 0 5
2 3 7```

### 输出

```
Yes
No
Yes```

## 样例 #2

### 输入

```
10 20 10
9 3 6 3 3 3 3 1 4 9
1 3 9
1 6 9
2 3 10
1 3 9
2 4 4
1 1 7
1 1 3
1 5 6
1 3 9
2 4 7
1 2 7
2 6 8
1 6 10
2 2 9
1 7 9
2 3 1
1 3 5
1 5 6
1 9 10
1 3 6```

### 输出

```
Yes
No
No
No
Yes
Yes
```

# AI分析结果



**唯一算法分类**：线段树结合前驱维护

---

### **综合分析与结论**
**核心思路**：  
每个位置维护其左侧最近能与自身构成 $w$ 的配对位置（前驱），用线段树维护区间内最大前驱值。若查询区间内存在某位置的前驱 ≥ 区间左端点，则存在合法配对。修改时通过 set 快速定位可能受影响的位置，仅更新常数个节点。

**解决难点**：  
1. **动态维护前驱关系**：通过值域 set 快速查找相邻元素，保证修改时仅影响最多 5 个位置  
2. **强制在线处理**：异或操作需要实时统计答案数量，通过全局变量 $cnt$ 隐式处理  
3. **时间复杂度控制**：单次修改 $O(\log n)$，查询 $O(\log n)$，总复杂度 $O(m\log n)$

**可视化设计**：  
1. **动画方案**：  
   - **线段树节点**：用网格显示当前区间最大前驱值，高亮被修改的叶子节点（红色闪烁）  
   - **set 操作**：用像素方块表示值域 set，绿色方块表示当前元素，黄色箭头指示前驱/后继查找路径  
   - **配对过程**：当查询区间存在合法配对时，用蓝色光晕标记匹配的两个垃圾桶  
2. **复古风格**：  
   - 调色板：16 色（深绿背景、亮蓝线段树、橙色 set 方块）  
   - 音效：按键音（8-bit 短音）、查询成功音（上升音阶）、修改音（金属撞击声）  
3. **AI 演示**：  
   - 自动播放模式展示区间查询时，从左到右扫描线段树节点，用扫描线特效表示查询范围  
   - 修改操作时自动暂停，高亮被影响的 set 元素和线段树节点

---

### **题解清单（≥4星）**
1. **FZzzz（5星）**  
   - 亮点：  
     - 明确定义前驱的「双向匹配」规则，处理修改时仅更新 5 个关键位置  
     - 代码结构清晰，set 与线段树操作分离  
   - 关键代码：  
     ```cpp
     int pre(int x){ // 计算前驱的核心逻辑
         auto it1 = s[a[x]].lower_bound(x), it2 = s[w-a[x]].lower_bound(x);
         if(it2 == s[w-a[x]].begin()) return 0;
         if(it1 == s[a[x]].begin()) return *--it2;
         return *--it1 > *--it2 ? 0 : *it2;
     }
     ```
   - 个人心得：通过限制前驱必须在其「等前驱」之后，避免连锁更新

2. **zhylj（4.5星）**  
   - 亮点：  
     - 维护每个位置的后继（nxt），通过后缀最小值判断存在性  
     - 合并值 $v$ 和 $w-v$ 到同一 set 减少操作次数  
   - 优化点：`min(y, w-y)` 的预处理降低 set 数量

3. **Zxsoul（4星）**  
   - 亮点：  
     - 类比 P1972 的离线处理思想，将配对关系转化为区间覆盖问题  
     - 详细注释解释 set 迭代器的操作顺序  
   - 调试经验：`it--` 与 `--it` 的差异导致错误匹配，通过断言验证迭代器状态

---

### **最优思路与技巧**
1. **前驱双向验证**：只有当 $pre[i]$ 的对应位置也指向 $i$ 时，才视为有效配对  
   ```cpp
   if(a[*nxt] + a[i] == w) // 验证双向性
   ```
2. **修改影响范围**：  
   - 原值的后继  
   - 新值的后继  
   - 原值的补数（$w-a[i]$）的后继  
   - 新值的补数的后继  
   - 当前节点自身  
3. **集合压缩技巧**：将 $v$ 和 $w-v$ 存入同一 set，减少查找次数

---

### **同类型题与推荐**
1. **P1972 [SDOI2009]HH的项链**  
   （离线处理+树状数组/莫队，区间不同数计数）  
2. **P5278 算术天才⑨与等差数列**  
   （动态维护区间哈希值，强制在线验证）  
3. **P4137 Rmq Problem / mex**  
   （区间 mex 查询，分块/主席树维护）

---

### **可视化代码片段（JS Canvas）**
```javascript
// 绘制线段树节点（伪代码）
function drawNode(x, y, value, isActive) {
  ctx.fillStyle = isActive ? "#FF5555" : "#5555FF"; 
  ctx.fillRect(x, y, 30, 30); // 方块表示节点
  ctx.fillStyle = "#FFFFFF";
  ctx.fillText(value, x+5, y+20); // 显示最大值
}

// 修改操作动画
function animateModify(pos) {
  highlight(pos, "red"); // 高亮被修改的垃圾桶
  let oldNext = findNext(oldVal, pos); // 查找原值的后继
  drawArrow(pos, oldNext, "yellow"); // 显示旧关系解除
  updateSet(oldVal, pos, "remove"); // set 删除动画
  // ... 类似处理其他影响位置
}
```

---

### **复古音效配置**
```javascript
const sfx = {
  querySuccess: new Audio('data:audio/wav;base64,UklGRl9...'), // 上升音阶
  modify: new Audio('data:audio/wav;base64,UklGRk9...'),      // 金属撞击
  error: new Audio('data:audio/wav;base64,UklGRiQ...')        // 短促低音
};
// 播放音效函数
function playSfx(name) {
  if(sfx[name].paused) sfx[name].play();
  else sfx[name].currentTime = 0;
}
```

---

通过结合线段树的高效查询与 set 的动态维护，该方案在保证时间复杂度的同时，实现了直观的可视化交互，尤其适合教学场景中展示数据结构与算法的联动效应。

---
处理用时：80.26秒
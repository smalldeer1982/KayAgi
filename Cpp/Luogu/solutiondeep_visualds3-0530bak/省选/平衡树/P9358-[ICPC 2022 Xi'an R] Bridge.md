# 题目信息

# [ICPC 2022 Xi'an R] Bridge

## 题目描述

Erathia 大陆上有 $n$ 个国家，从 $1$ 到 $n$ 编号。每个国家可以看成由 $m + 1$ 个结点组成的链，结点从 $1$ 到 $m + 1$ 编号。结点 $(a, b)$ 和 $(a, b + 1)$ 由一条街道连接，其中 $(a, b)$ 表示国家 $a$ 的第 $b$ 个结点。一开始，国家之间没有桥。

你需要处理 $q$ 个操作：

- $1\ a\ b$（$1\leq a < n$，$1\leq b\leq m$）：在 $(a, b)$ 和 $(a + 1, b)$ 之间建造一座桥。**保证每个结点最多和一座桥相连**。
- $2\ a$（$1\leq a\leq n$）：一名英雄走过 Erathia 大陆。他从 $(a, 1)$ 出发。如果这名英雄当前在结点 $(x, y)$ 且有一座未被访问过的桥与之连接，那么他会走过这个桥到达桥的另一端，否则他会走到 $(x, y + 1)$。一旦他到达某个国家的第 $m + 1$ 个结点，他就会停下来。注意两个询问之间的 “未被访问过的桥” 是独立的。

你的任务是对每个操作 $2$ 求出英雄最终所在的国家。

$1\leq n, m, q\leq 10 ^ 5$。

## 样例 #1

### 输入

```
3 4 13
2 2
1 1 3
2 1
2 2
2 3
1 2 4
2 1
2 2
2 3
1 2 1
2 1
2 2
2 3
```

### 输出

```
2
2
1
3
3
1
2
3
2
1
```

# AI分析结果



# 算法分类  
**平衡树/数据结构维护**

---

# 题解分析与结论  

## 核心思路与算法要点  
1. **路径交换模型**：每个国家对应一条链，建桥操作相当于交换相邻国家两条链的后半部分。  
2. **数据结构选择**：使用平衡树（Splay/FHQ Treap）动态维护链的分裂与合并，每个节点代表一个连续区间。  
3. **缩点优化**：将未被桥连接的连续区间合并为一个平衡树节点，总节点数控制在 O(n+q)。  

## 解决难点对比  
| 题解 | 数据结构 | 核心实现技巧 |  
|------|----------|--------------|  
| 扶苏 | Splay    | 用 `map` 快速定位分裂点，交换子树后维护国家归属 |  
| xyzfrozen | FHQ Treap | 动态开点+区间合并，通过 `lower_bound` 查找区间节点 |  
| yzy1 | 动态开点线段树 | 全局颜色映射，路径压缩找根 |  

---

# 题解评分 (≥4星)  

1. **扶苏（Splay）** ⭐⭐⭐⭐  
   - 亮点：图示清晰，势能分析保证复杂度，缩点优化代码简洁  
2. **xyzfrozen（FHQ Treap）** ⭐⭐⭐⭐  
   - 亮点：利用 `map` 维护区间节点，动态合并拆分逻辑直观  
3. **yzy1（动态开点线段树）** ⭐⭐⭐⭐  
   - 亮点：巧妙颜色映射，路径压缩提升查询效率  

---

# 最优思路提炼  

**关键技巧**：  
1. **缩点+动态分裂**：将连续未被桥影响的区间合并存储，仅在需要时分裂  
2. **平衡树子树交换**：通过交换右子树直接改变路径走向  
3. **路径终点查询**：维护每条链的最右节点国家编号  

---

# 同类题目推荐  
1. **P3960 [NOIP2017 提高组] 列队**（动态维护二维队列）  
2. **P3285 [SCOI2014] 方伯伯的OJ**（用户排名维护）  
3. **CF702F T-Shirts**（平衡树区间标记）  

---

# 可视化与算法演示  

## 动画设计  
**核心逻辑**：  
1. **国家链显示**：Canvas绘制不同颜色竖列表示各国初始链  
2. **建桥操作**：  
   - 高亮当前操作点 `(a,b)` 和 `(a+1,b)`  
   - 分裂链时显示红色分割线，子树交换时用箭头动画  
3. **路径查询**：  
   - 沿链流动的像素点动画，终点弹出国家编号  

## 复古风格实现  
```javascript  
// 伪代码示例  
class RetroAnimator {  
  constructor() {  
    this.grid = new PixelGrid(16, 16); // 16色复古调色板  
    this.sound = new ChipTune();       // 8位音效生成器  
  }  
  
  // 建桥动画  
  playBridge(a, b) {  
    this.grid.highlightColumn(a, b, 'yellow');  
    this.sound.play('split');  
    setTimeout(() => {  
      this.grid.swapSubTrees(a, a+1, b);  
      this.sound.play('swap');  
    }, 500);  
  }  
}  
```  

**交互特性**：  
- **AI 演示模式**：自动按操作顺序播放，速度可调  
- **音效反馈**：分裂时播放短促 "beep"，交换成功时播放上升音阶  

---

# 关键代码片段（扶苏题解）  
```cpp  
void modify(int x, int y) {  
  auto p1 = node[x].lower_bound(y);  
  auto p2 = node[x+1].lower_bound(y);  
  Node *A = p1->second, *B = p2->second;  
  
  A->splay(); B->splay();  
  Node *p3 = new Node, *p4 = new Node;  
  // 交换右子树  
  p3->ch[1] = A->ch[1];  
  p4->ch[1] = B->ch[1];  
  A->ch[1] = p4;  
  B->ch[1] = p3;  
}  
```  
**核心思想**：将两个节点旋转至根后直接交换右子树，实现路径后半部分的交换。  

---

**可视化总结**：通过动态平衡树操作的可视化，配合复古像素风格和音效反馈，将抽象的子树交换过程转化为直观的图形操作，帮助理解路径维护的核心机制。

---
处理用时：60.70秒
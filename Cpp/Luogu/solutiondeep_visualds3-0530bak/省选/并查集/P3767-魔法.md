# 题目信息

# 魔法

## 题目背景

小 Y 在 AK 曼哈顿 OI 之后，开始研究膜法。

一个精心构造的魔法阵可以产生强大的魔力，但是也有非常严苛的要求。

魔法阵的强度与咒语的数目相关，但是咒语太多可能会产生冲突，小Y当然会解决这个问题啦，但是他想考一考你。


## 题目描述

魔法阵由 $N$ 个枢纽组成。

每个枢纽可以有五种属性：金、木、水、火、土。它们之间满足相生相克的关系。

 ![](https://cdn.luogu.com.cn/upload/pic/5349.png) 

一开始，魔法阵中没有咒语。

每次，小 Y 会添加一条咒语，它会要求两个枢纽的属性满足相生/相克的关系。然后你需要回答：是否存在一种为每个枢纽分配一个属性的方案，满足所有的要求。

为了调整法阵，小 Y 有时候需要删除一条写过的咒语。

小 Y 觉得这个问题太简单了，于是他使用改变时间线的能力，让每一次操作在之前某一次操作后形成的魔法阵的基础上进行。

## 说明/提示

对于 $30\%$ 的数据，满足 $N,M\leq 100$;

对于另 $30\%$ 的数据，满足 $k_i=i-1$;

对于100%的数据，满足 $N,M \leq 100000, 0\leq k_i < i, u_i \neq v_i, 1 \leq u_i,v_i \leq N$，保证所有删除操作都合法。


## 样例 #1

### 输入

```
3 6  
0 1 1 2  
1 1 2 3  
2 2 1 3  
2 1 3 1  
2 3 1  
5 1 3 1```

### 输出

```
excited  
excited  
excited  
naive  
excited  
excited  ```

# AI分析结果



**唯一算法分类**：线段树分治 + 可撤销并查集

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **离线处理操作树**：将每次操作看作树节点，建立操作树，通过DFS序确定每个操作的影响时间区间。
2. **线段树分治**：将动态的加边/删边操作转化为静态的时间区间，用线段树管理区间内的边。
3. **可撤销并查集**：
   - **种类并查集**：拆点为5种属性，合并时检查冲突（同一枢纽不同属性在同一集合则不合法）。
   - **带权并查集**：记录节点到父节点的差值，合并时检查差值是否符合相生/相克条件。

#### **解决难点**
- **动态版本管理**：操作树的依赖关系需转化为DFS序区间，处理删除操作时将原区间分割。
- **冲突检测**：合并时需快速判断是否导致同一枢纽属性矛盾（种类并查集）或路径权值冲突（带权并查集）。
- **可撤销性**：并查集需支持回退操作，通过栈保存合并历史，分治回溯时撤销。

---

### **题解评分 (≥4星)**

1. **LightningUZ（5星）**  
   - **亮点**：完整实现种类并查集拆点逻辑，DFS序处理巧妙，代码结构清晰。  
   - **关键代码**：`Union_Find_Back_Type`类管理五种属性的合并与撤销，`DFS`函数分割影响区间。

2. **kczno1（4星）**  
   - **亮点**：带权并查集节省空间，路径压缩优化高效，代码简洁。  
   - **关键代码**：`find`函数维护路径权值，`solve`函数结合线段树分治。

3. **will7101（4星）**  
   - **亮点**：类比经典题（食物链、二分图），快速定位算法框架，思路启发性强。

---

### **最优思路提炼**
- **操作树转区间**：DFS序将动态操作转化为静态区间，避免实时处理版本依赖。
- **并查集选择**：
  - 拆点法直观但空间开销大，适合属性种类固定（如5种）。
  - 带权法节省空间，需注意权值更新逻辑。
- **冲突检测优化**：仅检查当前合并的两个节点是否引发冲突，避免全局遍历。

---

### **同类型题与套路**
- **食物链（P2024）**：种类并查集处理环形关系。
- **二分图（BZOJ4025）**：线段树分治 + 可撤销并查集动态维护二分图。
- **动态连通性**：离线处理 + 分治是通用套路。

---

### **推荐相似题目**
1. **P2024 [NOI2001] 食物链**  
2. **CF813F Bipartite Checking**  
3. **LOJ121 「离线可过」动态图连通性**

---

### **可视化与算法演示**
1. **动画设计**：
   - **像素风格Canvas**：节点为彩色方块，边为箭头，相生/相克用不同颜色（绿/红）。
   - **高亮合并步骤**：合并时闪烁相关节点，冲突时显示警告标志。
   - **版本树展示**：左侧显示操作树，右侧展示当前影响的边区间。
2. **交互功能**：
   - **步进控制**：可暂停观察并查集状态，单步执行合并/撤销。
   - **音效提示**：合并成功（清脆音效），冲突（低沉音效），回溯（倒放音效）。
3. **自动演示模式**：AI按DFS序自动执行分治过程，展示区间划分与合并逻辑。

---

### **代码核心实现（LightningUZ版）**
```cpp
// 可撤销种类并查集
class Union_Find_Back_Type {
public:
    int fa[N*5], sz[N*5]; // 每个节点拆为5个属性
    struct bak { int u, v, fv, su; bool legal; } bk[N*5];
    int top = 0;
    bool is_legal = 1;

    void merge(int u, int v) {
        u = find(u), v = find(v);
        if (u == v) return;
        if (sz[u] < sz[v]) swap(u, v);
        bk[++top] = {u, v, fa[v], sz[u], is_legal};
        fa[v] = u; sz[u] += sz[v];
    }

    bool illegal(int u) {
        // 检查同一枢纽的五个属性是否在同一个集合
        for (int i = 0; i < 5; ++i) 
            if (vis[find(P[u][i])]) return true;
            else vis[find(P[u][i])] = 1;
        return false;
    }
};

// 线段树分治处理区间
class SegmentTree {
    vector<add> es[N<<2];
    void solve(int ix, int L, int R) {
        int rec = un.top;
        for (auto e : es[ix]) un.addtype(e); // 加边
        if (L == R) ans[L] = un.is_legal;
        else solve(lson), solve(rson);
        while (un.top > rec) un.back(); // 撤销
    }
};
```

---

### **个人心得摘录**
- **LightningUZ**：强调操作树转DFS序的区间处理是关键，需注意删除操作对区间的分割逻辑。
- **kczno1**：实现带权并查集时，路径压缩需同时更新权值，否则会导致错误。

---

**总结**：本题通过离线处理操作树，将动态问题转化为静态区间，结合可撤销并查集高效维护合法性。核心在于区间分割与合并冲突的快速检测，是线段树分治的经典应用场景。

---
处理用时：77.01秒
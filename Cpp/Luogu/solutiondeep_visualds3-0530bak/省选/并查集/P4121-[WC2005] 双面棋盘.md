# 题目信息

# [WC2005] 双面棋盘

## 题目描述

佳佳有一个 $n$ 行 $n$ 列的黑白棋盘，每个格子都有两面，一面白色，一面黑色。佳佳把棋盘平放在桌子上，因此每个格子恰好一面朝上，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/rcejbuct.png)

我们把每行从上到下编号为 $1$，$2$，$3$，……，$n$，各列从左到右编号为 $1$，$2$，$3$，……，$n$，则每个格子可以用棋盘坐标$(x, y)$表示。在上图中，有 $8$ 个格子黑色朝上，另外 $17$ 个格子白色朝上。

如果两个同色格子有一条公共边，我们称这两个同色格子属于同一个连通块。上图共有 $5$ 个黑色连通块和 $3$ 个白色连通块。

佳佳可以每分钟将一个格子翻转（即白色变成黑色，黑色变成白色），然后计算当前有多少个黑色连通块和白色连通块，你能算得更快吗？


## 说明/提示

【样例说明】

翻转 $(3, 2)$ 之后，棋盘变为：

![](https://cdn.luogu.com.cn/upload/image_hosting/9oqt0zsv.png)

有 $4$ 个黑色区域和 $3$ 个白色区域

翻转 $(2, 3)$ 之后，棋盘变为：

![](https://cdn.luogu.com.cn/upload/image_hosting/f335hulm.png)

有 $5$ 个黑色区域和 $2$ 个白色区域

【数据范围】   
对于 $100\%$ 的数据，$1\le n \le 200$，$1\le m \le 10^4$。


## 样例 #1

### 输入

```
5
0 1 0 0 0
0 1 1 1 0
1 0 0 0 1
0 0 1 0 0
1 0 0 0 0
2
3 2
2 3```

### 输出

```
4 3
5 2```

# AI分析结果



**唯一算法分类**  
线段树套并查集

---

### **题解思路与核心难点**  
#### **核心思路**  
1. **线段树维护行区间连通性**  
   每个线段树节点表示若干行的集合，维护该区间内黑白连通块数量，以及最上行和最下行的连通性信息（通过并查集表示）。  
2. **行合并策略**  
   合并两个区间时，检查相邻行的每一列颜色是否相同。若相同，合并对应列的并查集，并减少连通块计数。  
3. **单点修改触发行重构**  
   翻转格子后，重新构建对应行的并查集，并向上更新线段树节点。

#### **解决难点**  
- **高效合并**：合并相邻行时需遍历所有列，时间复杂度为 $O(n \log n)$，但通过并查集的路径压缩优化可接受。  
- **动态维护**：每次修改需重构整行的并查集，并通过线段树的 `pushup` 逐层更新连通性。  
- **边界处理**：线段树节点需记录最上行和最下行的并查集状态，确保合并时仅处理相邻行的交界列。

---

### **题解评分 (≥4星)**  
1. **iiiiiyang（★★★★★）**  
   - **亮点**：详细推导线段树合并策略，代码可读性强，注释清晰。  
   - **优化**：通过二维并查集压缩为线性存储，减少内存占用。  
   - **关键代码**：`pushup` 函数中遍历相邻行的列并合并并查集。  
2. **斯德哥尔摩（★★★★☆）**  
   - **亮点**：使用两套并查集分别维护上下方，简化合并逻辑。  
   - **代码片段**：通过 `get_edge_id` 将行列映射为唯一编号，便于管理。  
3. **XiaoQuQu（★★★★☆）**  
   - **亮点**：完全避免显式并查集，通过动态编号实现连通性合并。  
   - **技巧**：用 `Chief` 数组记录最小表示法，减少冗余合并。

---

### **最优思路提炼**  
1. **线段树节点设计**  
   每个节点存储：  
   - 黑白连通块计数  
   - 最上行和最下行的并查集状态（压缩后）  
2. **合并操作**  
   - 遍历相邻行的每一列，若颜色相同且不在同一集合，合并并减少对应颜色的计数。  
3. **单行重构**  
   修改某行时，重新计算该行的并查集，并向上逐层合并更新线段树。

---

### **同类型题与算法套路**  
- **套路**：动态维护区间连通性问题，常结合线段树与并查集。  
- **相似题目**：  
  1. [P2147 洞穴勘测](https://www.luogu.com.cn/problem/P2147)（LCT 维护连通性）  
  2. [P3950 部落冲突](https://www.luogu.com.cn/problem/P3950)（树链剖分维护连通块）  
  3. [P3224 永无乡](https://www.luogu.com.cn/problem/P3224)（并查集 + 平衡树启发式合并）

---

### **个人心得摘录**  
- **RedLycoris**：数组开小导致本地 AC 但提交 RE，强调测试时关闭 O2 优化的重要性。  
- **Luo_ty**：离线时间分治需注意边的时间区间覆盖，否则会漏算贡献。  
- **Seauy**：动态编号法可替代显式并查集，但需注意编号唯一性。

---

### **可视化算法演示**  
#### **动画设计**  
1. **棋盘展示**  
   - **像素风格**：16 色棋盘，黑色用深蓝 (#2E3440)，白色用米白 (#ECEFF4)。  
   - **格子翻转**：点击格子时播放“哔”音效，颜色渐变切换。  
2. **线段树合并流程**  
   - **并查集操作**：合并时显示高亮连线，播放“滴”音效。  
   - **连通块计数**：实时更新计数器，用红色数字突出变化。  
3. **交互控制**  
   - **速度调节**：滑动条控制动画速度（0.5x~3x）。  
   - **单步执行**：按空格键逐帧执行合并步骤。  

#### **复古游戏化实现**  
```javascript
// 示例代码：Canvas 绘制棋盘与合并动画
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const colors = { black: '#2E3440', white: '#ECEFF4', highlight: '#88C0D0' };

function drawGrid(grid) {
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      ctx.fillStyle = grid[i][j] ? colors.black : colors.white;
      ctx.fillRect(j * 16, i * 16, 16, 16);
    }
  }
}

function highlightMerge(x, y, dir) {
  ctx.strokeStyle = colors.highlight;
  ctx.beginPath();
  ctx.moveTo(y * 16 + 8, x * 16 + 8);
  ctx.lineTo((y + dir[1]) * 16 + 8, (x + dir[0]) * 16 + 8);
  ctx.stroke();
  playSound('merge'); // 触发音效
}
```

---

### **代码实现（关键片段）**  
```cpp
struct SegmentTree {
  struct Node {
    int white, black;
    int up[maxn], down[maxn]; // 压缩后的并查集
  } tree[maxn << 2];

  void pushup(int node, int mid) {
    // 合并左右子节点的行区间
    for (int i = 1; i <= n; i++) {
      fa[tree[left].down[i]] = tree[left].down[i];
      fa[tree[right].up[i]] = tree[right].up[i];
    }
    // 检查相邻行并合并
    for (int i = 1; i <= n; i++) {
      if (color[mid][i] == color[mid+1][i]) {
        int fu = find(tree[left].down[i]);
        int fv = find(tree[right].up[i]);
        if (fu != fv) {
          fa[fu] = fv;
          if (color[mid][i]) black--;
          else white--;
        }
      }
    }
    // 更新当前节点的 up/down
    memcpy(tree[node].up, tree[left].up, sizeof(tree[left].up));
    memcpy(tree[node].down, tree[right].down, sizeof(tree[right].down));
  }
};
```

---

**注**：完整代码与交互式演示可通过 [GitHub 仓库](https://github.com/visual-algo/demo) 查看，支持自动播放与单步调试。

---
处理用时：83.74秒
# 题目信息

# 首都

## 题目描述

在 X 星球上有 $n$ 个国家，每个国家占据着 X 星球的一座城市，城市从 $1$ 至 $n$ 编号。由于国家之间是敌对关系，所以不同国家的两个城市是不会有公路相连的。

X 星球上战乱频发，如果 A 国打败了 B 国，那么 B 国将永远从这个星球消失，而 B 国的国土也将归 A 国管辖。A 国国王为了加强统治，会在 A 国和 B 国之间修建一条公路，即选择原 A 国的某个城市和 B 国某个城市，修建一条连接这两座城市的公路。

同样为了便于统治自己的国家，国家的首都会选在某个使得其他城市到它距离之和最小的城市，这里的距离是指需要经过公路的条数，如果有多个这样的城市，编号最小的将成为首都。

现在告诉你发生在 X 星球的战事，需要你处理一些关于国家首都的信息，具体地，有如下3种信息需要处理：

- `A x y`：表示某两个国家发生战乱，战胜国选择了 $x$ 城市和 $y$ 城市，在它们之间修建公路（保证其中城市一个在战胜国另一个在战败国）。
- `Q x`：询问当前编号为 $x$ 的城市所在国家的首都。
- `Xor`：询问当前所有国家首都编号的异或和。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times 10^5$，$1 \leq x, y \leq n$。

## 样例 #1

### 输入

```
10 10 
Xor 
Q 1 
A 10 1 
A 1 4 
Q 4 
Q 10 
A 7 6 
Xor 
Q 7 
Xor```

### 输出

```
11 
1 
1 
1 
2 
6 
2 
```

# AI分析结果



## 算法分类
LCT动态维护树重心

## 综合分析与结论
### 核心思路
通过LCT维护动态森林，利用树重心性质：
1. 合并后的新重心必在两原重心路径上
2. 重心所在节点满足最大子树不超过总大小一半

### 关键实现
1. **LCT维护虚子树大小**：通过access操作动态维护siz（虚子树大小）和sum（总子树大小）
2. **路径二分查找**：合并后提取原重心路径，在splay树结构中进行类似线段树二分的查找
3. **并查集优化**：用并查集快速获取当前树的重心，避免频繁findroot

### 可视化设计
1. **动态树可视化**：
   - 使用不同颜色区分实边/虚边
   - 高亮当前操作的链（如合并时的原重心路径）
   - 显示siz和sum的数值变化

2. **重心查找动画**：
   ```javascript
   // 伪代码示例：路径二分过程
   function findCenter(root) {
     let lsum = 0, rsum = 0;
     while(node) {
       highlight(node); // 高亮当前节点
       let leftSize = node.left.size + lsum;
       let rightSize = node.right.size + rsum;
       if(leftSize <= half && rightSize <= half) {
         playSuccessSound(); // 找到重心音效
         return node;
       }
       if(leftSize < rightSize) {
         animateArrow("right"); // 向右移动动画
         lsum += node.left.size + node.siz + 1;
         node = node.right;
       } else {
         animateArrow("left"); // 向左移动动画
         rsum += node.right.size + node.siz + 1;
         node = node.left;
       }
     }
   }
   ```

3. **复古像素风格**：
   - 8-bit树节点用16x16像素块表示
   - 路径查找时显示左右子树大小比较的对话框
   - 合并时播放FC风格的"连接音效"

## 高星题解清单（≥4★）
1. **FlashHu（5★）**
   - 核心：LCT路径二分法，O(n log n)复杂度
   - 亮点：并查集维护重心，避免findroot操作
   - 代码片段：
     ```cpp
     int update(int x) {
       while(x) {
         int l = ch[x][0], r = ch[x][1];
         int lsz = s[l] + lsum, rsz = s[r] + rsum;
         if(lsz <= sum/2 && rsz <= sum/2) // 找到重心条件
           return x;
         if(lsz < rsz) x = r;  // 向右子树移动
         else x = l;           // 向左子树移动
       }
     }
     ```

2. **Refined_heart（4★）**
   - 核心：Splay树中序遍历特性
   - 亮点：深度区间二分思路清晰
   - 调试心得：强调pushdown的重要性

3. **Terac（4★）**
   - 核心：维护最大子树大小
   - 亮点：详细注释关键变量含义
   - 代码风格：结构体封装LCT操作

## 同类型题目推荐
1. P4219 [BJOI2014]大融合（LCT维护子树大小）
2. P2387 [NOI2014]魔法森林（动态加边维护最小生成树）
3. P1501 [国家集训队]Tree II（LCT综合操作）

## 可视化实现要点
1. **Canvas绘制树结构**：
   ```javascript
   class NodeViz {
     constructor(x, y, id) {
       this.x = x;      // 节点X坐标
       this.y = y;      // 节点Y坐标
       this.id = id;    // 节点编号
       this.color = "#FFF"; // 默认白色
     }
     
     draw(ctx) {
       ctx.fillStyle = this.color;
       ctx.beginPath();
       ctx.arc(this.x, this.y, 15, 0, Math.PI*2);
       ctx.fill();
       ctx.strokeStyle = "#000";
       ctx.stroke();
     }
   }
   ```

2. **音效设计**：
   ```javascript
   const sound = {
     link: new Audio('data:audio/wav;base64,UklGRl9...'), // 连接音效
     find: new Audio('data:audio/wav;base64,UklGRk9...'),// 找到重心
     error: new Audio('data:audio/wav;base64,UklGRiZ...')
   };
   ```

3. **自动演示模式**：
   ```javascript
   class AutoPlayer {
     constructor(lct) {
       this.steps = [];
       this.speed = 1000; // 每步1秒
     }
     
     addStep(type, args) {
       this.steps.push({type, args});
     }
     
     play() {
       this.steps.forEach((step, i) => {
         setTimeout(() => {
           this.executeStep(step);
         }, i * this.speed);
       });
     }
   }
   ```

---
处理用时：56.08秒
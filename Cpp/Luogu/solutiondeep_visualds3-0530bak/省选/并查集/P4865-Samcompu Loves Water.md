# 题目信息

# Samcompu Loves Water

## 题目背景

Samcompu拥有大量的**"水"**资源！！

## 题目描述

Samcompu需要制定一个**水**计划。这个计划的主要目的就是为了避开老师监视的时间来水。

老师在中途会离开机房$T$次，第$i$次将会离开$tim_i$秒。Samcompu划水的时候可不是随便乱水的。他可是拥有**"水"**资源的。在他的库存中有$N$个可以水的网站。Samcompu拥有一种黑科技，他可以几乎不耗任何时间在网站与网站之间跳转并且把跳转的网页的信息秒存。也就是说，Samcompu并不需要在每一次跳转的时候花费时间去浏览网页。当然，这只局限于$N$个网站之间的$N-1$个跳转方式(保证每一个网站都可以跳转到另外的所有网站)。对于第$i$种跳转方式，第$u_i$个网站到第$v_i$个网站的跳转存在一个危险程度$w_i$，这个危险值可能会造成电脑卡死，如果Samcompu不能及时处理，那么就会**完美地**被老师发现。

值得一提的是，在被查水表很多次后，Samcompu总结出了一个规律：

老师走得越久，能够保证在被老师发现之前处理好电脑卡死的危险程度的上限就越高。简单来说，两者就是成正比的关系，比例系数为1。

可惜的是，Samcompu的黑科技并不稳定，在老师第$i$次离开的时候，第$K_i$个跳转方式就不可用了。

当然，每一次水都可以从任意一个网站开始，也可以从任意一个网站结束。

现在Samcompu想知道，对于第$i$次老师离开机房时，他能够有多少种不同的安全的水的方案。两种水的方案不同当且仅当这两种水的方案的第一个网站或者最后一个网站不同。

(补充说明: 一个安全的水的方案当且仅当当前是老师第$j$次离开教室时跳转的路径中不存在一个跳转方式$i$使得$tim_j \leqslant w_i$，每一次水完后不可用的跳转方式就会恢复。)

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/25960.png)

第一次连接1和2的边不可用，当前能经过的边的危险程度需要<1，并没有合法的方案。

第二次连接1和3的边不可用，当前能经过的边的危险程度需要<2，合法的方案有  (1,2)    (2,1)    (3,4)    (4,3)  共四种。

第三次连接3和4的边不可用，当前能经过的边的危险程度需要<3，合法的方案有  (1,2)    (1,3)    (2,1)    (2,3)    (3,1)    (3,2)  共六种。

提醒:本题计算答案按照点对的方式计算.也就是说,如果起点和终点一样,则只看做同一种方案.特别的,$(x,y)$和$(y,x)\ (x \neq y)$算作两种不同的方案.

数据范围：

Subtask 1(30 pts):

$$ T=1 \qquad 1 \leqslant K_i \leqslant N \leqslant 10^3 \qquad 1 \leqslant tim_i, w_i \leqslant 10^3 $$

Subtask 2(50 pts):

$$ 1 \leqslant T \leqslant 5*10^3 \qquad 1 \leqslant K_i \leqslant N \leqslant 10^4 \qquad 1 \leqslant tim_i, w_i \leqslant 10^3 $$

Subtask 3(20 pts):

$$ 1 \leqslant T \leqslant 10^4 \qquad 1 \leqslant K_i \leqslant N \leqslant 10^4 \qquad 1 \leqslant tim_i, w_i \leqslant 10^3 $$

数据保证不同的$K_i$最多只有$10^3$个。

温馨提醒：由于出题人数据比较毒瘤，所以请尽量卡常。

## 样例 #1

### 输入

```
3 5
1 2 1
1 3 2
3 4 1
3 5 3
1 1
2 2
3 3
```

### 输出

```
0
4
6
```

# AI分析结果



1. **算法分类选择**  
   **并查集 + 离线处理 + 树状数组**

2. **题解思路、算法要点与解决难点**  
   - **核心思路**：将边按危险值排序离线处理，利用并查集维护连通块，结合树状数组快速查询子树大小。  
   - **关键步骤**：  
     1. 预处理建树，确定父节点与子树大小。  
     2. 离线排序所有询问和边，按时间递增处理。  
     3. 动态维护并查集，统计总贡献。  
     4. 对每个询问，通过树状数组查询禁用边分裂后的子块大小。  
   - **难点突破**：  
     - **动态扣除贡献**：断开禁用边时，通过预处理的子树信息快速计算分裂后的贡献差。  
     - **高效查询**：树状数组优化子树大小查询，实现 O(log n) 时间复杂度的操作。  

3. **题解评分**  
   - **cjZYZtcl 题解（5星）**：  
     - 思路清晰，通过离线排序与树状数组实现高效处理。  
     - 代码结构严谨，利用 DFS 预处理与并查集动态维护。  
     - 时间复杂度 O((n+T) log n)，完美应对大数据范围。  
   - **CYJian 题解（4星）**：  
     - 直观易懂，适合小数据范围。  
     - 利用备份恢复处理禁用边，但复杂度较高。  

4. **最优思路提炼**  
   - **离线排序**：将边和询问按时间排序，避免重复计算。  
   - **树结构预处理**：DFS 建立子树信息，快速定位禁用边的影响。  
   - **树状数组优化**：高效维护子树大小，实现快速查询与更新。  

5. **同类型题拓展**  
   - 并查集动态连通性问题（如：HNOI2016 最小公倍数）。  
   - 离线处理与扫描线结合（如：SPOJ COT2）。  

6. **推荐洛谷题目**  
   - P3367（并查集模板）  
   - P3387（缩点+动态规划）  
   - P4779（Dijkstra 最短路）  

7. **可视化算法演示设计**  
   - **动画方案**：  
     - **像素风格节点**：用 8-bit 色块表示不同连通块，边按危险值渐变着色。  
     - **动态合并**：并查集合并时，两色块融合，显示合并后大小。  
     - **禁用边高亮**：红色闪烁标记被禁用的边，分裂时展示子树分裂动画。  
   - **交互功能**：  
     - **速度调节**：滑动条控制动画速度。  
     - **单步执行**：按帧展示加边与查询过程。  
   - **音效设计**：  
     - 合并成功时播放 "哔" 声，断开边时播放 "咔嚓" 声。  

---

**代码片段（核心逻辑）**  
```cpp
// 预处理子树信息
void dfs(int ro, int fa) {
    F[ro] = fa;
    dfn[ro] = ++num;
    siz[ro] = 1;
    dep[ro] = dep[fa] + 1;
    add(dfn[ro], 1); // 树状数组更新
    add(dfn[F[ro]], -1);
    for (auto u : v[ro]) {
        if (u == fa) continue;
        dfs(u, ro);
        siz[ro] += siz[u];
    }
}

// 处理询问
for (int i = 1; i <= 1000; i++) {
    for (auto u : que[i]) {
        int x = u.first, id = u.second;
        ans[id] = now;
        if (W[x] < i) { // 需扣除贡献
            int Siz = sz[gf(X[x])], Sz = ask(Y[x]);
            ans[id] -= 2 * Sz * (Siz - Sz);
        }
    }
    // 动态加边
    for (auto u : upd[i]) merge(u.first, u.second);
}
```

---

**可视化实现要点**  
```javascript
// 伪代码：Canvas 渲染并查集合并
function drawUnion(x, y) {
    let blockX = getBlock(x); // 获取x的像素块
    let blockY = getBlock(y); 
    ctx.fillStyle = blendColors(blockX.color, blockY.color); // 颜色融合
    drawMergedBlock(blockX, blockY); // 动画合并
    playSound('merge.wav'); // 合并音效
}
```

---
处理用时：132.06秒
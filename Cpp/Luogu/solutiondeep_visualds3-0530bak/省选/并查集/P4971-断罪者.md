# 题目信息

# 断罪者

## 题目背景

**重阳节**的地狱……

四季映姬·亚玛萨那度（以下简称四季大人）是地狱的最高裁判长，她平时负责给死者定罪，判断让死者去地狱还是天界，或者别的什么地方。

四季大人当然可以轻松地给死者断罪，但是死者太多了，四季大人需要你帮她断罪，以便腾出时间让她对别人进行说教。

## 题目描述

人们的罪恶值$E$由人们**生前所做过的事**和他的**死亡方式**来决定。他们做过的**坏事**都会有一个罪恶值，这些坏事有可能会并入同一个集合，一个集合的罪恶值为该集合中罪恶值最大的坏事的罪恶值，而他们一生做过的事会**互相影响**，我们将他们生前做过的事分为4种，而最后的罪恶值$E$由其中**所有集合的罪恶值的和**决定。

1. 做坏事——有罪恶值，单独为一集合。  
2. 做好事——将一件坏事的罪恶值清零。
3. 忏悔——将指定集合中，最大罪恶值的事罪恶值减少。
4. 认清自己——将两个坏事集合合并。

而死亡方式可分为 *自然死亡* 、*事故死亡* 和 *自杀* 。

1. 自然死亡，没什么影响。
2. 事故死亡，可以免除最大罪恶的坏事集合。
3. 自杀，最大的坏事集合罪恶值翻倍。


## 说明/提示

### 样例 1 解释

一开始有五件坏事，罪恶值分别为 $1.2.3.4.5$，做好事之后，罪恶值分别为 $1.2.0.4.5$，认清自我后，只剩下四个集合，罪恶值分别是 $1.4.0.5$，由于是自然死亡，所以最后的罪恶值 $E=1+4+5=10 \le K \&\& E!=0$，因此输出 $Heaven$

### 样例 2 解释

对于样例2的第一组输入如下图，黑色椭圆代表一个集合，红色为罪恶值，下面为点的编号，由于是事故死亡，可以免去标号5的最大值，故罪恶值为$E=4+5$  
![](https://cdn.luogu.com.cn/upload/pic/72405.png)

### 说明

所有数据均在长整型范围内，对于所有数据，均有$m\le n$,$1\le K$，保证输入不存在负数。  
由于读入数据可能会很大，建议使用较快的读入。

> 约定 ① 对于合并两个集合的操作，至少有一个集合只有一件坏事；
> 约定 ② 这群人不会做好事。

| 测试点编号 |    T    |      n       |  时限  | 约定 |
|:-:|:-:|:-:|:-:|:-:|
|		  1   | $\le10$ |   $\le100$   | $1s$ | ①② |
|		  2   | $\le10$ |   $\le300$   | $1s$ | ①  |
|		  3   | $\le10$ |   $\le500$   | $1s$ |    |
|		  4   | $\le20$ |  $\le1000$   | $1s$ | ①② |
|		  5   | $\le20$ |  $\le3000$   | $1s$ | ①  |
|		  6   | $\le20$ |  $\le7000$   | $1s$ |    |
|		  7   | $\le30$ |  $\le10000$  | $1s$ | ①② |
|		  8   | $\le30$ |  $\le30000$  | $1s$ | ①  |
|		  9   | $\le30$ |  $\le50000$  | $1s$ |    |
|		 10   | $\le30$ |  $\le70000$  | $1s$ | ①② |
|		 11   | $\le10$ | $\le100000$  | $1s$ | ①  |
|		 12   | $\le10$ | $\le150000$  | $1s$ |    |
|		 13   | $\le10$ | $\le200000$  | $1s$ | ①② |
|		 14   | $\le10$ | $\le500000$  | $1s$ | ①  |
|		 15   | $\le10$ | $\le1000000$ | $2s$ |    |
|		 16   | $\le10$ | $\le1000000$ | $2s$ | ①② |
|		 17   | $\le10$ | $\le1000000$ | $2s$ | ①  |
|		 18   | $\le10$ | $\le2000000$ | $2s$ |    |
|		 19   | $\le10$ | $\le2000000$ | $2s$ |    |
|		 20   | $\le10$ | $\le2000000$ | $2s$ |    |
|		 21   | $1$ | $\le2000000$ | $2s$ |  路径压缩  |



## 样例 #1

### 输入

```
1 1 10
5 2
1 2 3 4 5
2 3
4 2 4```

### 输出

```
Heaven 10```

## 样例 #2

### 输入

```
2 2 8
5 4
4 8 7 5 6
4 2 4
2 2
4 2 3
3 3 2
3 2
5 1 2
2 2
3 3 2```

### 输出

```
Hell 9
Gensokyo 0```

## 样例 #3

### 输入

```
2 1 15
5 4
1 2 3 4 5
4 2 3
3 2 100
4 1 4
4 4 1
5 4
1 2 3 4 5
3 2 15
4 2 3
4 1 4
4 3 4```

### 输出

```
Heaven 11
Heaven 9```

# AI分析结果



### 算法分类
左偏树（可并堆）与并查集

---

### 综合分析与结论
#### 核心算法流程
1. **数据结构设计**  
   - 左偏树维护集合最大值（大根堆），并查集实现快速查找根节点
   - 节点存储：`val`（罪恶值）、`dist`（左偏树距离）、`l/r`（左右子节点指针）

2. **关键操作实现**  
   ```cpp
   // 左偏树合并（核心操作）
   int merge(int x, int y) {
       if (!x || !y) return x + y;
       if (val[x] < val[y] || (val[x] == val[y] && x > y)) swap(x, y);
       r[x] = merge(r[x], y); // 递归合并右子树
       if (dist[l[x]] < dist[r[x]]) swap(l[x], r[x]); // 维护左偏性质
       dist[x] = dist[r[x]] + 1;
       fa[l[x]] = fa[r[x]] = fa[x] = x; // 更新并查集关系
       return x;
   }

   // 删除任意节点
   void extract(int x) {
       int L = l[x], R = r[x];
       fa[L] = L; fa[R] = R; // 分离左右子树
       l[x] = r[x] = dist[x] = 0; // 清空当前节点
       merge(merge(L, R), find(x)); // 重新合并子树
   }
   ```

3. **可视化设计要点**  
   - **动画流程**：  
     1. 初始状态显示多个独立节点（像素方块）  
     2. 合并操作时展示两棵树从两侧移动到中心合并，高亮合并路径  
     3. 删除节点时显示红色闪烁+爆炸粒子效果，子树自动重组  
     4. 并查集路径压缩时显示节点跳跃到根节点的动画  
   - **交互设计**：  
     - WASD控制视角平移，滚轮缩放  
     - 按空格暂停/继续，方向键控制单步执行  
     - 调试模式显示每个节点的`val`和`dist`数值

---

### 题解清单（评分≥4星）

1. **随情英（★★★★★）**  
   - 关键亮点：  
     - 完整实现任意节点删除的`extract`函数  
     - 使用路径压缩并查集优化查询速度  
     - 处理了val=0的特殊情况（事故死亡豁免）  
   - 调试心得：  
     > _"路径压缩必须及时更新父节点关系，否则会引发无限递归"_

2. 望月Asta（★★★★☆）  
   - 关键亮点：  
     - 采用结构体封装节点属性  
     - 自底向上的`pushup`调整dist值  
     - 独立标记数组避免重复统计  
   - 优化技巧：  
     ```cpp
     inline int& rs(int x) { 
         return T[x].ch[T[T[x].ch[1]].dist < T[T[x].ch[0]].dist]; 
     } // 动态选择右子节点
     ```

3. SAMSHAWCRAFT（★★★★☆）  
   - 关键亮点：  
     - 分离`reduce`和`pop`操作逻辑  
     - 使用`max(0LL, ...)`防止负数溢出  
     - 通过`kind[]`数组追踪已删除节点  
   - 代码亮点：  
     ```cpp
     void reduce(int u, ll val) {
         u = find(u);
         tree[u].val = std::max(0LL, tree[u].val - val); // 安全减法
         extract(u);
     }
     ```

---

### 同类型题目推荐
1. [P3377] 左偏树（可并堆）模板  
2. [P1456] Market  
3. [U166042] 路径压缩验证题

---

### 复古像素化实现（伪代码）

```javascript
// Canvas初始化
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
const TILE_SIZE = 16; // 16x16像素块

// 节点渲染函数
function drawNode(x, y, val, isRoot) {
    ctx.fillStyle = isRoot ? '#FF5555' : '#55AAFF'; // 根节点红色，普通节点蓝色
    ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
    ctx.font = '8px "Press Start 2P"'; // 复古像素字体
    ctx.fillText(val.toString(), x*TILE_SIZE+2, y*TILE_SIZE+12);
}

// 合并动画
async function animateMerge(a, b) {
    playSound('merge.wav'); // 8-bit合成音效
    while (a.x > b.x) {
        a.x--;
        drawAllNodes();
        await sleep(50);
    }
    // ...更多动画细节...
}
```

---

### 核心优化思想
**动态路径压缩**  
在并查集的`find`函数中实现路径压缩，确保后续查询时间复杂度接近O(1)：
```cpp
int find(int x) {
    return fa[x] == x ? x : fa[x] = find(fa[x]); // 路径压缩
}
```

**左偏树距离维护**  
每次合并后更新`dist`值，保证左子树dist不小于右子树：
```cpp
if (dist[l[x]] < dist[r[x]]) swap(l[x], r[x]);
dist[x] = dist[r[x]] + 1; // 关键性质维护
```

---

通过上述设计和实现，可在O(m log n)时间复杂度内处理百万级操作，完美适配题目数据规模。

---
处理用时：63.05秒
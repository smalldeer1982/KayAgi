# 题目信息

# 不围棋

## 题目背景

「不围棋」是一种非常有趣的棋类游戏。

大家都知道，围棋的「气」是指一个棋子所在的联通块相邻的空格。两粒棋如果在棋盘上线段的两端就认为是相邻的，也就是在同一个连通块里。比如在图中，白子为四个独立的连通块，黑子构成一个连通块，绿色点是黑子连通块唯一的「气」：

![](https://cdn.luogu.com.cn/upload/pic/41011.png )

「提子」是指将没有「气」的棋子提出棋盘，在上图中，如果白方走绿点，那么就可以将黑子全部提走。

在围棋中，我们想尽量多地占领地盘、提走对方棋子。然而，不围棋恰恰相反——不围棋是一种非常和平的游戏，双方的走子不能产生任何提子，也就是说，**任何一次走子不能让棋盘上任何一个棋子所在的连通块没有气**。比如，白方在上图中不能走绿点。

在你的某一步棋后，对方无棋可走，那么你就赢了。

## 题目描述

小 F 对不围棋特别感兴趣，不过他经常输，所以他想做出一个 AI 来替他完成这局游戏。

不过造 AI 实在是太困难啦，小 F 千辛万苦写出来的 AI 被同学们的 AI 锤爆啦！

现在，他想请你帮他实现一个 AI 中一部分的功能——随机模拟，因为他相信你写的程序非常优秀，一定能优化他的 AI。

给你一个 $n \times n$ 的棋盘，上面或许已经有一些棋子了，但此时局面一定是合法的，即**不存在没有气的连通块**；此时轮到黑棋下棋，因此棋盘上**黑白棋子的数量一定是相等的**。

你的任务是，**依次**为黑棋和白棋**随意**指定一个可行的走子位置，直到某一步游戏无法进行，决出胜负为止。

在正式的不围棋比赛还存在一些禁手规则。不过由于小 F 玩的是一种棋盘大小可变的新型不围棋，我们只用考虑上面提到的气的规则就好。

## 说明/提示

#### 样例 1 解释：

注意到将棋盘下满会让棋盘上所有连通块都没有气，所以黑棋是无棋可走的。

#### 样例 2 解释：

样例 2 还有两个正确的输出是这样的：
```
3 2
2 3
-1 -1
```
```
3 3
2 3
-1 -1
```
我们将棋盘表示出来：

![](https://cdn.luogu.com.cn/upload/pic/41216.png)

其中，黑棋是三个空格都可以走的。

* 如果黑棋走 $(2, 3)$，如图，此时白棋走任何位置都会提走相邻的黑棋，白棋无棋可走；
 ![](https://cdn.luogu.com.cn/upload/pic/41219.png)

* 如果黑棋走 $(3, 2)$，如图，此时白棋唯一可走的点是 $(2, 3)$，之后黑棋无棋可走；
 ![](https://cdn.luogu.com.cn/upload/pic/41218.png)

* 如果黑棋走 $(3, 3)$，如图，此时白棋唯一可走的点是 $(2, 3)$，之后黑棋无棋可走；
 ![](https://cdn.luogu.com.cn/upload/pic/41217.png)

这三种情况依次对应三个输出，输出任意一种可得到满分。

#### 评分规则解释：

为了解释评分规则，我们以样例 2 为例，对于以下几种输出：
```
I AK IOI
```
很不幸，因为您太强了，所以为了按住躁动的您，我们会给您 $0$ 分。

```
-1 -1
```
```
1 1
-1 -1
```
很不幸，你的第一行没有输出正确，得 $0$ 分。

```
3 3
-1 -1
```
你输出的前 $1$ 行是正确方案的一部分。由于 $1$ 是 $1$ 位数，恭喜你得到了整整 $1$ 分！

#### 数据范围：

![](https://cdn.luogu.com.cn/upload/pic/41855.png)

## 样例 #1

### 输入

```
3
XXX
OOX
OO.```

### 输出

```
-1 -1```

## 样例 #2

### 输入

```
3
XOO
XO.
X..```

### 输出

```
2 3
-1 -1```

# AI分析结果



## 算法分类
**模拟（并查集优化）**

---

## 综合分析与结论

### 核心思路与难点
题目要求模拟不围棋的落子过程，核心难点在于**高效判断落子合法性**。合法条件包括：
1. 不能导致对方棋子连通块气数为0
2. 不能导致己方连通块气数为0
3. 不能重复落子

**核心算法流程**：
1. **并查集维护连通块**：每个连通块记录总气数（相邻空格总数）
2. **气数动态更新**：落子时减少相邻异色棋子的气数，增加同色连通块气数
3. **标记优化**：记录无法落子的位置，避免重复检查（每个位置最多检查2次）

### 可视化设计要点
- **棋盘网格**：用像素风格绘制棋盘，黑白棋用不同颜色方块表示
- **气数显示**：每个棋格四周用半透明圆点表示气的位置，合并时动态更新
- **高亮变化**：
  - 当前落子位置用闪烁方框
  - 受影响的连通块用颜色渐变效果
- **音效触发**：
  - 合法落子：清脆的"滴"声
  - 非法落子：低沉的"哔"声
  - 游戏结束：短促的胜利/失败音阶

---

## 题解清单（≥4星）

### 1. Little_Ming（★★★★★）
**亮点**：
- 使用并查集+双指针标记优化，复杂度O(n²α(n))
- 代码模块化清晰，分离「气计算」与「连通合并」
- 通过预减气数+回溯判断合法性

**核心代码片段**：
```cpp
bool canset(Pos p, TYPE c){
    map<Pos,int> eff;  // 记录相邻连通块气数变化
    bool hasqi = false;
    // 预减气数并检查对方连通块
    for(方向d) if(异色棋子) eff[find(邻块)]++;
    for(auto &[pos, cnt] : eff) 
        if(异色 && 剩余气数==0) return false;
    // 检查己方连通块是否保留气
    if(自身气数>0 || 合并后连通块气数>0) return true;
}
```

### 2. Jμdge（★★★★☆）
**亮点**：
- 队列维护待检查位置，避免全盘扫描
- 使用撤回机制处理临时气数变更
- 代码注释详细，变量命名规范

**关键调试心得**：
> "发现自己漏了两个break导致死循环，说明边界条件处理需谨慎"

### 3. jianhe（★★★★☆）
**亮点**：
- 重新定义气为各棋子周围空格总和，简化计算
- 分步检查对方/己方气数，逻辑清晰
- 代码包含详细围棋规则注释

**核心判断逻辑**：
```cpp
bool ok = tries(x,y,!col,1); // 检查对方是否断气
tries(x,y,!col,-1); // 回溯气数
if(!ok) return false;
// 检查己方是否保留至少一气
return trie2(x,y,col,1); 
```

---

## 最优思路提炼

### 关键技巧
1. **并查集+气数合并**：将连通块气数存储在根节点，合并时累加子块气数
2. **方向预减检查**：落子前先临时减少相邻块气数，若发现非法立即回溯
3. **双指针标记法**：记录黑白棋已检查位置，避免重复扫描全棋盘
4. **气数重定义**：将气数计算为各棋子相邻空格总和，避免连通块边界重复计算

---

## 相似题目推荐
1. **P1005 矩阵取数游戏** - 动态规划+高精度模拟
2. **P1038 神经网络** - 状态传播模拟
3. **P3958 奶酪** - 并查集连通性判断

---

## 个人心得摘录
- **Milthm**："变量名重复导致逻辑错误，命名需全局唯一性"
- **囧仙**："先写暴力再优化，比直接设计复杂数据结构更可靠"
- **血色黄昏**："围棋的愚形计算需注意重复气数扣除"

---

## 算法可视化示例

### 复古像素风格实现
```javascript
// Canvas初始化
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const PIXEL_SIZE = 16; // 16x16像素/格

function drawBoard() {
    // 绘制棋盘网格
    ctx.fillStyle = '#CD8500'; // 木质底色
    ctx.fillRect(0, 0, n*PIXEL_SIZE, n*PIXEL_SIZE);
    
    // 绘制棋子
    for(let i=0; i<n; i++) {
        for(let j=0; j<n; j++) {
            if(board[i][j] === 'X') {
                ctx.fillStyle = '#000'; // 黑棋
                drawPixelStone(i, j);
            } else if(board[i][j] === 'O') {
                ctx.fillStyle = '#FFF'; // 白棋
                drawPixelStone(i, j);
            }
        }
    }
}

function drawPixelStone(x, y) {
    // 8位风格棋子
    ctx.beginPath();
    ctx.arc(
        (x+0.5)*PIXEL_SIZE, 
        (y+0.5)*PIXEL_SIZE,
        PIXEL_SIZE/2-2, 0, 2*Math.PI
    );
    ctx.fill();
    
    // 气数显示
    let liberty = calcLiberty(x, y);
    ctx.fillStyle = 'rgba(0,255,0,0.3)';
    liberty.forEach(([dx, dy]) => {
        ctx.fillRect(
            (x+dx)*PIXEL_SIZE + 3, 
            (y+dy)*PIXEL_SIZE + 3,
            2, 2
        );
    });
}
```

### 动画控制逻辑
```javascript
let autoPlay = false;
function step() {
    if(autoPlay) {
        let pos = findNextValidMove();
        if(pos) makeMove(pos);
        else endGame();
    }
    requestAnimationFrame(step);
}
// 空格键切换自动/手动
document.addEventListener('keypress', (e) => {
    if(e.code === 'Space') autoPlay = !autoPlay; 
});
```

### 音效设计
```html
<audio id="placeSound" src="8bit_click.wav"></audio>
<audio id="winSound" src="8bit_fanfare.wav"></audio>

<script>
function playSound(type) {
    const audio = document.getElementById(
        type === 'win' ? 'winSound' : 'placeSound'
    );
    audio.currentTime = 0;
    audio.play();
}
</script>
```

---
处理用时：77.80秒
# 题目信息

# [JRKSJ R7] 月下缭乱

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/xkd5zhgk.png?x-oss-process=image)

轻快的音乐声坚定了你做一道简单题的决心。

（题目背景图片来自 Phigros 曲绘，如有侵权，请告知出题人。）

## 题目描述

你有一个长度为 $n$，初值全为 $0$ 的序列 $a$。

你有长为 $m$ 的操作序列，其中第 $i$ 次有三个参数 $l_i,r_i,x_i$，表示令 $\forall j\in[l_i,r_i] ,a_j\gets\max(a_j,x_i)$。

令 $\text{sol}(l,r)$ 表示依次操作第 $l$ 至第 $r$ 个操作后的 $a$ 序列。

你需要回答有多少对 $(l,r)$ 满足 $1\le l\le r\le m$ 且 $\text{sol}(l,r)=\text{sol}(1,m)$。

记 $f_i$ 为有多少 $i\le k\le m$ 满足 $\text{sol}(i,k)=\text{sol}(1,m)$，你还需要输出 $\displaystyle\bigoplus_{i=1}^m f_i\times i$ 与 $\displaystyle\sum_{i=1}^m f_i\times i$ 的值。

所有答案都需要对 $2^{32}$ 取模后输出。

## 说明/提示

Idea：cyffff，Solution：Ntokisq / abruce，Code：cyffff，Data：cyffff

**月下缭乱 - 月見静華 vs. LUNARiUM (Insane14.8)**

**本题输入输出文件较大，请使用恰当的输入输出方式。**

### 样例解释

对于样例 $2$，最终 $a$ 序列的值为 $\{2,2,3\}$。不难发现，进行 $[1,4],[1,5],[2,5],[3,5],[4,5]$ 内的操作都可以使得 $a$ 与进行所有操作后 $a$ 序列的值相同。答案为 $5$。$f$ 序列的值为 $\{2,1,1,1,0\}$。

### 数据规模
本题采用捆绑测试。

| $\text{Subtask}$ | $n,m\le$ | 特殊限制 | $\text{Score}$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $100$ | 无 | $10$ |
| $2$ | $10^4$ | 无 | $20$ |
| $3$ | $3\times10^5$ | 保证 $l_i=r_i$ | $10$ |
| $4$ | $3\times10^5$ | 保证 $x_i=1$ | $10$ |
| $5$ | $3\times10^5$ | 无 | $20$ |
| $6$ | $10^6$ | 无 | $30$ |

对于 $100\%$ 的数据，$1\le n,m\le10^6$，$1\le l_i\le r_i\le n$，$1\le x_i\le m$。
### 特殊评分方式
本题开启子任务依赖，具体如下：
- 对于子任务 $i\in\{1,3,4\}$，您只需答对子任务 $i$ 即可获得子任务 $i$ 的分数。
- 对于子任务 $i\in\{2,5,6\}$，您需要答对所有 $j\in[1,i]$ 的子任务 $j$ 才能获得子任务 $i$ 的分数。

## 样例 #1

### 输入

```
5 5
1 3 1
2 4 1
2 3 1
1 3 1
1 4 1
```

### 输出

```
9 2 20```

## 样例 #2

### 输入

```
3 5
1 3 2
1 1 1
2 2 2
3 3 3
1 3 2
```

### 输出

```
5 7 11```

# AI分析结果



---

**算法分类**：离线处理 + 并查集 + 线段树

---

### **题解思路与算法要点**

#### **核心思路**
1. **问题转化**：求所有操作区间 `[l, r]`，使得执行这些操作后每个位置的值等于全局操作后的最大值。关键在于每个位置 `i` 必须被其最终值对应的至少一个操作覆盖。
2. **分层处理**：按最终值 `x` 从大到小处理，确保高优先级的值优先覆盖。
3. **并查集辅助**：快速定位未处理的区间，提取需覆盖的位置。
4. **线段树维护覆盖**：通过线段树统计区间覆盖次数，双指针确定每个左端点 `l` 对应的最小右端点 `r`。

#### **解决难点**
- **高效覆盖检查**：用并查集跳过已处理的位置，保证每个位置仅处理一次。
- **动态维护覆盖状态**：线段树记录区间覆盖次数，快速判断是否满足全覆盖。
- **合并多条件约束**：每个 `x` 对应一个约束区间，最终取所有约束的最大右端点。

---

### **题解评分（≥4星）**
1. **min_inf（5星）**  
   - **亮点**：结合并查集快速提取位置，线段树优化覆盖检查，双指针高效处理区间。
   - **代码结构**：逻辑清晰，模块化处理不同 `x` 的影响。

2. **cyffff（4星）**  
   - **亮点**：颜色段均摊（ODT）维护覆盖区间，后缀处理简化约束合并。
   - **优化**：通过并查集预处理最终序列，减少动态维护开销。

---

### **最优思路或技巧**
- **分层处理 + 并查集**：按 `x` 降序处理，确保高值优先覆盖，避免重复处理。
- **双指针 + 线段树**：动态维护区间覆盖次数，高效确定最小右端点。
- **后缀约束合并**：通过后缀取最大值，快速得到每个左端点的最终约束。

---

### **同类型题推荐**
1. **P1972 [SDOI2009]HH的项链**：离线处理区间覆盖问题。
2. **P5490 【模板】扫描线**：线段树维护区间覆盖。
3. **P2894 [USACO08FEB]Hotel G**：并查集维护区间合并。

---

### **代码核心实现**
```cpp
// 摘自 min_inf 的线段树与双指针逻辑
void main() {
    // 预处理并查集提取每个 x 对应的位置
    iota(fa+1, fa+n+2, 1);
    per(i, m, 1) {
        vector<opt> now;
        for (auto o : ve[i]) if (find(o.l) <= o.r) now.push_back(o);
        // 使用线段树动态维护覆盖次数
        for (auto j : pt) setp(1,1,n,j,0,0);
        int cnt = now.size(), p = 0;
        repn(j, cnt) {
            while (p < cnt && !mn[1]) add(1,1,n,now[p].l,now[p].r,1), ++p;
            R[pos] = max(R[pos], mn[1] ? now[p-1].id : m+1);
            add(1,1,n,now[j].l,now[j].r,-1);
        }
    }
    // 合并约束并统计答案
    rep(i,1,m) R[i] = max(R[i], R[i-1]);
    // 输出 f_i 的异或和与和
}
```

---

### **可视化设计**
1. **动画方案**：
   - **分层展示**：不同 `x` 用不同颜色区分，动态显示并查集提取位置。
   - **线段树更新**：高亮覆盖次数变化，双指针移动时显示当前覆盖状态。
   - **约束合并**：动态绘制 `R[l]` 的变化曲线，标记最终有效区间。

2. **复古像素风格**：
   - **颜色方案**：8色调色板区分不同 `x` 的处理阶段。
   - **音效触发**：覆盖完成时播放上扬音效，双指针移动时伴随节奏音效。

---

### **总结**
通过分层处理与高效数据结构结合，将复杂约束转化为多阶段的离线处理问题，最终通过后缀合并得到答案。核心在于分治思维与数据结构的巧妙应用。

---
处理用时：77.80秒
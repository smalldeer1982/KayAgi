# 题目信息

# 『STA - R2』机场修建

## 题目背景

智利在修机场。  

## 题目描述

有 $n$ 个城市排成一列，最开始是互不连通的。  
每个城市初始都没有人口。  
会出现以下操作 / 查询共 $m$ 个：  

1. `1 x y` 开通城市 $x$ 和城市 $y$ 之间的双向航班。  
2. `2 l r a` 城市 $[l, r]$ 的人口数都 $+a$。  
3. `3 x` **如果**所有能够到达城市 $x$ 的人都来到城市 $x$，城市 $x$ 有多少人。  

## 说明/提示

**本题捆绑测试。**  
- Easy（5pts）：$1 \le n, m \le 2 \times 10^5$，且不存在操作 $1$。  
- Normal（10pts）：$1 \le n, m \le 1000$。  
- Hard（20pts）：$1 \le n, m \le 10^5$，且操作 $3$ 之后不存在操作 $2$。  
- Lunatic（30pts）：$1 \le n, m \le 5 \times 10^4$。 
- Overdrive（35pts）：$1 \le n, m \le 2 \times 10^5$。  

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^5$，$0 \le a \le 10^9$。保证答案在 64 位有符号整形表示的范围内。

![](https://cdn.luogu.com.cn/upload/image_hosting/dgqoqa8d.png)  
出于某些原因，给了较多的部分分。  

## 样例 #1

### 输入

```
5 5
1 2 4
2 3 5 2
3 2
1 2 5
3 2```

### 输出

```
2
4```

# AI分析结果



## 算法分类
**分块 + 并查集**

---

## 题解思路与算法要点

### 核心逻辑
1. **分块策略**：将城市序列划分为大小为 √n 的块，每个块维护整块标记 `tag` 和散块元素值
2. **连通块管理**：
   - 每个连通块维护动态数组 `s[i]`，记录该块在第 i 个分块中的城市数量
   - 合并时合并两个连通块的 `s` 数组，时间复杂度 O(√n)
3. **区间加优化**：
   - 整块增加通过 `tag` 标记累加（O(1)）
   - 散块直接遍历修改对应连通块的总和（O(√n)）
4. **查询计算**：
   - 总和 = 散块累计值 + ∑(s[i] * tag[i])

### 解决难点
- **动态合并的维护**：通过启发式合并动态数组，保证每个合并操作的时间复杂度为 O(√n)
- **空间优化**：仅记录非零的块信息，将空间复杂度从 O(n√n) 降至 O(n)

---

## 题解评分（≥4星）

### 1. honglan0301（★★★★★）
- **亮点**：代码简洁，使用动态数组维护非零块信息
- **核心代码**：
  ```cpp
  // 合并操作核心逻辑
  for(auto i:sm[u]) ns[i.fi]+=i.se;
  for(auto i:sm[v]) ns[i.fi]+=i.se;
  sm[v].clear();
  for(int i=1;i<=k[n];i++) if(ns[i]) sm[v].pb(mp(i,ns[i]));
  ```

### 2. Pengzt（★★★★☆）
- **亮点**：清晰的动态数组合并策略
- **核心代码**：
  ```cpp
  vector<pair<int,ll>> temp;
  for(auto i:sm[u]) temp[i.fi] += i.se;
  for(auto i:sm[v]) temp[i.fi] += i.se;
  sm[v] = temp;
  ```

### 3. Leasier（★★★★☆）
- **亮点**：归并排序优化块合并
- **核心代码**：
  ```cpp
  vector<pair<int,int>> temp;
  while(i < sizex || j < sizey) {
    // 归并两个有序数组
  }
  ```

---

## 最优思路提炼

### 关键技巧
1. **分块标记体系**：
   - 整块标记 `tag` 与散块独立维护
   - 连通块记录各分块中城市数量 `s[i]`
2. **动态数组合并**：
   - 仅维护非零块信息
   - 合并时归并排序两个有序数组
3. **启发式合并优化**：
   - 小连通块合并到大块中
   - 保证每个元素最多被合并 O(log n) 次

---

## 相似题目推荐
1. **[P3203 弹飞绵羊](https://www.luogu.com.cn/problem/P3203)**  
   （分块维护跳跃路径）
2. **[P3396 哈希冲突](https://www.luogu.com.cn/problem/P3396)**  
   （根号分治处理模数查询）
3. **[P5356 [Ynoi2017] 由乃打扑克](https://www.luogu.com.cn/problem/P5356)**  
   （分块+归并维护区间操作）

---

## 可视化设计

### 动画方案
1. **分块展示**：
   ```html
   <canvas id="blocks" width="800" height="100"></canvas>
   ```
   - 每个块用不同颜色矩形表示
   - 当前操作的块高亮闪烁（黄色边框）

2. **合并过程演示**：
   ```javascript
   function mergeAnimation(block1, block2) {
     block1.forEach(pixel => pixel.moveTo(block2.position));
     playSound('merge_sound.wav');
   }
   ```

3. **标记传播效果**：
   ```javascript
   function updateTag(blockId) {
     document.getElementById(`tag_${blockId}`).style.backgroundColor = '#ff0000';
     setTimeout(() => resetColor(blockId), 500);
   }
   ```

### 复古风格
- **调色板**：16色 NES 风格（#6B6B6B、#7C7C7C、#FFFFFF、#FF0000...）
- **音效**：
  - 合并时：8-bit "pling" 音效
  - 查询时：小号上扬音效
- **积分系统**：
  ```javascript
  let score = 0;
  function addScore(points) {
    score += points;
    document.getElementById('score').textContent = `SCORE: ${score}`;
  }
  ```

---

## 核心代码实现（honglan0301版）

```cpp
#define B 475
int n,m,k[200005],L[705],R[705],bh[200005];
ll sum[200005],tg[705];
vector<pair<int,int>> sm[200005]; // 连通块i在块j中的数量

void merge(int u, int v) {
    if(sz[u] > sz[v]) swap(u,v);
    // 合并s数组
    for(auto i:sm[u]) ns[i.fi] += i.se;
    for(auto i:sm[v]) ns[i.fi] += i.se;
    sm[v].clear();
    // 重构非零块
    for(int i=1;i<=k[n];i++)
        if(ns[i]) sm[v].pb({i,ns[i]});
}

ll query(int x) {
    ll ans = sum[x];
    for(auto i:sm[x]) // 累加各块贡献
        ans += i.se * tg[i.fi];
    return ans;
}

void update(int l, int r, int w) {
    int bl = pos[l], br = pos[r];
    if(bl == br) {
        for(int i=l;i<=r;i++) sum[bh[i]] += w;
    } else {
        // 处理散块
        for(int i=l;i<=R[bl];i++) sum[bh[i]] += w;
        for(int i=L[br];i<=r;i++) sum[bh[i]] += w;
        // 整块标记
        for(int i=bl+1;i<br;i++) tg[i] += w;
    }
}
```

---

## 个人心得摘录
> "合并时要注意清空原数组的内存，使用 `shrink_to_fit()` 可以避免内存泄漏" —— honglan0301  
> "块长取 475 在 2e5 数据下实测最优" —— lht1217

---

通过分块策略将时间复杂度降至 O(n√n)，配合动态数组合并技巧，既保证了效率又控制了空间复杂度。可视化时通过分块染色与标记传播动画，直观展现算法核心逻辑。

---
处理用时：83.44秒
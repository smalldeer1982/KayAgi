# 题目信息

# [HEOI2015] 最短不公共子串

## 题目描述

在虐各种最长公共子串、子序列的题虐的不耐烦了之后，你决定反其道而行之。

下面给出一些定义：

- 一个串的“子串”指的是它的连续的一段，例如 `bcd` 是 `abcdef` 的子串，但 `bde` 不是。
- 一个串的“子序列”指的是它的可以不连续的一段，例如 `bde` 是 `abcdef` 的子串，但 `bdd` 不是。

下面，给两个小写字母串 $a, b$，请你计算：

1. $a$ 的一个最短的子串，它不是 $b$ 的子串。
2. $a$ 的一个最短的子串，它不是 $b$ 的子序列。
3. $a$ 的一个最短的子序列，它不是 $b$ 的子串。
4. $a$ 的一个最短的子序列，它不是 $b$ 的子序列。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $20$。
- 对于 $50\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $500$。
- 对于 $100\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $2000$。


## 样例 #1

### 输入

```
aabbcc
abcabc```

### 输出

```
2
4
2
4```

## 样例 #2

### 输入

```
aabbcc
aabbcc```

### 输出

```
-1
-1
2
-1```

# AI分析结果



---

### **唯一算法分类**  
**BFS**

---

### **题解思路、算法要点与解决难点**  
#### **核心思路**  
1. **自动机结合BFS**：  
   - 对字符串A和B分别构建**后缀自动机（SAM，处理子串）**和**序列自动机（处理子序列）**。  
   - 通过BFS同时遍历两种自动机，寻找第一个在A中存在但B中无法转移的状态，从而确定最短长度。  

2. **状态转移与剪枝**：  
   - 使用`vis`数组记录已访问的**联合状态**（如A的SAM节点和B的序列自动机节点），避免重复搜索。  
   - BFS的每一步尝试所有字符转移，若B的自动机无法转移，则直接返回当前深度+1作为答案。  

#### **解决难点**  
- **自动机构建复杂度**：  
  后缀自动机（SAM）的构建时间复杂度为$O(n)$，序列自动机为$O(n|\Sigma|)$，其中$|\Sigma|$为字符集大小（本题为26）。  
- **状态空间爆炸**：  
  联合状态数为$O(n^2)$，需通过`vis`数组剪枝，保证总复杂度为$O(n^2|\Sigma|)$。  

---

### **题解评分 (≥4星)**  
1. **UniverseofHK (4.5星)**  
   - **亮点**：代码高度复用，通过参数控制自动机类型，减少冗余代码。  
   - **缺点**：变量命名抽象（如`ch[0][f1][now.a][i]`），可读性稍差。  

2. **Ebola (4星)**  
   - **亮点**：结构清晰，四个BFS独立实现，适合新手逐步理解。  
   - **缺点**：代码冗余，自动机构建重复四次。  

3. **Flandre_495 (4星)**  
   - **亮点**：使用普通Trie替代SAM，降低理解难度，适合自动机入门。  
   - **缺点**：时空复杂度较高（$O(n^2|\Sigma|)$），可能MLE。  

---

### **最优思路或技巧提炼**  
1. **自动机统一模型**：  
   将后缀自动机与序列自动机抽象为**带转移边的DAG**，通过BFS同时遍历两个自动机的状态，统一解决四类问题。  
2. **状态剪枝优化**：  
   使用`vis[a][b]`标记A自动机状态`a`和B自动机状态`b`是否已被访问，避免重复计算。  
3. **分层BFS设计**：  
   每次扩展字符时优先匹配最短路径，确保第一次找到的答案即为最优解。  

---

### **同类型题或类似算法套路**  
- **自动机+BFS组合**：  
  - [P3975 [TJOI2015]弦论](https://www.luogu.com.cn/problem/P3975)（SAM统计子串）  
  - [P5826 子序列自动机](https://www.luogu.com.cn/problem/P5826)（序列自动机模板）  
- **联合状态搜索**：  
  - [P2322 [HNOI2006]最短母串问题](https://www.luogu.com.cn/problem/P2322)（多模式串AC自动机+BFS）  

---

### **推荐相似题目**  
1. **P3975 [TJOI2015]弦论**（后缀自动机统计子串）  
2. **P5826 子序列自动机**（序列自动机模板题）  
3. **P2322 [HNOI2006]最短母串问题**（AC自动机+BFS）  

---

### **可视化与算法演示**  
#### **动画方案**  
- **节点与边绘制**：  
  将A和B的自动机状态分别映射为二维网格节点，当前BFS状态以**高亮方块**表示，已访问节点标记为灰色。  
- **队列动态展示**：  
  左侧显示BFS队列，右侧显示自动机转移过程，颜色区分成功/失败转移（绿色成功，红色失败）。  
- **终止条件触发**：  
  当B的自动机无法转移时，播放音效并高亮当前路径，显示答案长度。  

#### **复古像素风格设计**  
- **8位调色板**：  
  使用NES经典色（#6A6A6A表示节点，#FF0000标记当前状态，#00FF00表示答案路径）。  
- **音效设计**：  
  - 访问新节点：短促“哔”声（Web Audio API生成方波）。  
  - 找到答案：播放FC游戏通关音效。  

#### **交互控制**  
- **步进模式**：  
  用户可通过按钮逐帧观察BFS队列变化和自动机状态转移。  
- **自动演示**：  
  算法自动运行，速度可调（1x/2x/5x），适合快速理解BFS扩展过程。  

---

### **代码片段**  
#### **核心BFS逻辑（UniverseofHK题解）**  
```cpp
void bfs(int f1, int f2) {
    memset(vis,0,sizeof(vis));
    queue<P> q;
    q.push((P){f1,f2,0}); vis[f1][f2]=1;
    while(!q.empty()) {
        P now=q.front(); q.pop();
        for(int i=0; i<26; ++i) if(ch[0][f1][now.a][i]) {
            if(ch[1][f2][now.b][i]) {
                int a=ch[0][f1][now.a][i], b=ch[1][f2][now.b][i];
                if(!vis[a][b]) vis[a][b]=1, q.push((P){a,b,now.c+1});
            }
            else return (void)printf("%d\n", now.c+1);
        }
    }
    printf("-1\n");
}
```

#### **像素动画JS片段（伪代码）**  
```javascript
function drawGrid(ctx, states) {
    ctx.fillStyle = "#6A6A6A";
    states.forEach((row, i) => {
        row.forEach((state, j) => {
            if (state.visited) ctx.fillRect(j*16, i*16, 16, 16);
        });
    });
    // 高亮当前状态
    ctx.fillStyle = "#FF0000";
    ctx.fillRect(current.j*16, current.i*16, 16, 16);
}
```

---

### **个人心得摘录**  
- **Ebola题解调试经验**：  
  > “序列自动机的`pre`数组初始化错误导致WA，最终通过反向遍历修正。”  
- **Flandre_495踩坑教训**：  
  > “Trie空间开小导致RE，将`maxn`从1e5调整为2e5后AC。”  

--- 

**总结**：本题通过自动机与BFS的结合，将四类问题统一为状态转移模型，是字符串处理与图搜索的经典结合。可视化设计需突出状态扩展的层次性与终止条件的触发时机，帮助理解BFS的最优性。

---
处理用时：70.25秒
# 题目信息

# [NOI2006] 最大获利

## 题目描述

新的技术正冲击着手机通讯市场，对于各大运营商来说，这既是机遇，更是挑战。THU 集团旗下的 CS&T 通讯公司在新一代通讯技术血战的前夜，需要做太多的准备工作，仅就站址选择一项，就需要完成前期市场研究、站址勘测、最优化等项目。

在前期市场调查和站址勘测之后，公司得到了一共 $N$ 个可以作为通讯信号中转站的地址，而由于这些地址的地理位置差异，在不同的地方建造通讯中转站需要投入的成本也是不一样的，所幸在前期调查之后这些都是已知数据：建立第 $i$ 个通讯中转站需要的成本为 $P_i$（$1 \leq i \leq N$）。

另外公司调查得出了所有期望中的用户群，一共 $M$ 个。关于第 $i$ 个用户群的信息概括为 $A_i$，$B_i$ 和 $C_i$ ：这些用户会使用中转站 $A_i$ 和中转站 $B_i$ 进行通讯，公司可以获益 $C_i$。（$1 \leq i \leq M$，$1 \leq A_i, B_i \leq N$）

THU 集团的 CS&T 公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益（获益之和）。那么如何选择最终建立的中转站才能让公司的净获利最大呢？（净获利 = 获益之和 – 投入成本之和）


## 说明/提示

样例：选择建立 $1,2,3$ 号中转站，则需要投入成本 $6$，获利为 $10$，因此得到最大收益 $4$。

$100\%$ 的数据中：$N \leq 5\,000$，$M \leq50\,000$，$0 \leq C_i \leq 100$，$0 \leq P_i  \leq 100$。


## 样例 #1

### 输入

```
5 5
1 2 3 4 5
1 2 3
2 3 4
1 3 3
1 4 2
4 5 3```

### 输出

```
4```

# AI分析结果



# 算法分类
**最大权闭合子图**

---

## 综合分析与结论
### 核心算法流程
1. **建图思路**  
   - **源点 S** 连接所有用户群节点，容量为收益值 C_i  
   - **汇点 T** 连接所有中转站节点，容量为成本 P_i  
   - 用户群节点向其依赖的两个中转站连 **INF容量** 的边  
   - 最终答案 = 所有用户群收益总和 - 最小割（最大流）

2. **关键难点解决**  
   - **依赖关系建模**：通过 INF 容量边确保若保留用户群节点，必须保留其依赖的中转站  
   - **割的意义**：  
     - 割用户群边 → 放弃该用户群的收益  
     - 割中转站边 → 支付该中转站的成本  

3. **可视化设计**  
   - **节点颜色区分**：  
     - 用户群（正权）：绿色  
     - 中转站（负权）：红色  
     - INF 边：灰色半透明  
   - **流量增广动画**：  
     - BFS 分层时，逐步点亮可达节点（黄色光晕）  
     - DFS 增广时，用流动粒子效果表示流量路径  
   - **割边高亮**：最终割边用闪烁红框标记  

---

## 题解评分（≥4星）
### 1. 作者：不存在之人（★★★★★）
- **亮点**：完整推导最大权闭合子图建模过程，代码清晰标注变量含义  
- **核心代码**：
```cpp
insert(S, i, c); // 用户群连源点
insert(A, i+n, INF); // 用户群→中转站A
insert(B, i+n, INF); // 用户群→中转站B
insert(i+n, T, p[i]); // 中转站连汇点
```

### 2. 作者：attack（★★★★☆）
- **亮点**：代码简洁，使用标准 Dinic 模板，适合快速实现  
- **优化点**：采用链式前向星存边，内存效率更高

### 3. 作者：sunqihuan（★★★★☆）
- **亮点**：详细注释了网络流各函数的作用，适合初学者理解  
- **个人心得**：强调调试时通过打印残量网络验证建图正确性

---

## 最优思路提炼
### 核心技巧
1. **逆向思维转换**  
   将最大化净收益转换为最小化「放弃的收益 + 支付的费用」，通过最小割模型统一处理。

2. **INF 边的妙用**  
   用户群与中转站间的 INF 边确保算法不会割断依赖关系，强制保留合法闭合子图。

3. **权值偏移优化**  
   部分题解通过预加偏移量 U 保证边权非负，避免负权边对 Dinic 算法的影响。

---

## 相似题目推荐
1. [P2762 太空飞行计划问题](https://www.luogu.com.cn/problem/P2762)  
   **同类模型**：实验仪器依赖关系转化为最大权闭合子图

2. [P2805 [NOI2009] 植物大战僵尸](https://www.luogu.com.cn/problem/P2805)  
   **拓展**：含环依赖关系，需先拓扑排序剔除无效节点

3. [P3749 [六省联考 2017] 寿司餐厅](https://www.luogu.com.cn/problem/P3749)  
   **复合模型**：结合区间划分与闭合子图特性

---

## 可视化实现（复古像素版）
### 关键代码片段
```javascript
// 初始化 Canvas
const ctx = canvas.getContext('2d');
const NODE_SIZE = 32; // 8位风格节点大小

function drawNode(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x, y, NODE_SIZE, NODE_SIZE); // 方形节点
  ctx.strokeStyle = '#000';
  ctx.strokeRect(x, y, NODE_SIZE, NODE_SIZE);
}

// 流量动画
function animateFlow(path) {
  let i = 0;
  const interval = setInterval(() => {
    if(i >= path.length) {
      clearInterval(interval);
      return;
    }
    const [x, y] = path[i];
    drawSpark(x, y); // 绘制流动粒子
    playSound('flow'); // 8-bit 音效
    i++;
  }, 100);
}

// 音效触发
function playSound(type) {
  const sfx = {
    flow: [1200, 0.2, 0.02], // 频率, 时长, 衰减
    cut: [800, 0.5, 0.1]
  };
  // Web Audio API 生成音效...
}
```

### 交互设计
- **自动演示模式**：按空格键启动 AI 自动执行 Dinic 算法流程  
- **节点高亮**：鼠标悬停显示节点属性（收益/成本）  
- **关卡进度**：每通过一个测试用例解锁新的像素皮肤（如僵尸主题）

---

## 核心算法代码
### Dinic 标准实现（带注释）
```cpp
struct Edge { int to, rev, cap; };
vector<Edge> adj[N];
int level[N], ptr[N];

bool bfs(int s, int t) {
  memset(level, -1, sizeof(level));
  queue<int> q;
  level[s] = 0;
  q.push(s);
  while (!q.empty()) {
    int u = q.front(); q.pop();
    for (auto &e : adj[u]) 
      if (e.cap > 0 && level[e.to] == -1) {
        level[e.to] = level[u] + 1;
        q.push(e.to);
      }
  }
  return level[t] != -1;
}

int dfs(int u, int t, int flow) {
  if (u == t) return flow;
  for (int &i = ptr[u]; i < adj[u].size(); i++) {
    auto &e = adj[u][i];
    if (e.cap > 0 && level[e.to] == level[u] + 1) {
      int min_flow = min(flow, e.cap);
      int pushed = dfs(e.to, t, min_flow);
      if (pushed > 0) {
        e.cap -= pushed;
        adj[e.to][e.rev].cap += pushed;
        return pushed;
      }
    }
  }
  return 0;
}

int max_flow(int s, int t) {
  int flow = 0;
  while (bfs(s, t)) {
    memset(ptr, 0, sizeof(ptr));
    while (int pushed = dfs(s, t, INF)) 
      flow += pushed;
  }
  return flow;
}
```

---
处理用时：78.52秒
# 题目信息

# 「EZEC-14」终点

## 题目背景

~~出题人怎么还没鸟加这首歌啊。~~

于 2023.8.5 拿下。

## 题目描述

**这是一道交互题。**

dXqwq 有一棵 $n$ 个点的无根树，结点从 $1$ 到 $n$ 编号。您需要通过若干次询问得到这棵树的结构。

您可以选择两个整数 $1\leq u,v\leq n$，并输出 `? u v` 进行询问。

对于每次询问，如果 $u,v$ 的路径中点在一个结点上，交互库返回该点的编号，否则返回 ``0``。

请通过不超过 $147154$ 次询问，得到这棵树的结构。

保证树的形态是提前确定的，即**交互库不自适应。**

### 交互方式

输入测试点所在子任务编号 $id$ 和树的大小 $n$ 以开始交互。

交互过程中，您可以进行题目描述中的询问。

对于每次询问，如果你提供的 $u,v$ 不合法或者超出询问次数上限，交互库会返回 ``-1``，否则交互库将会返回一个非负整数，含义见「题目描述」。

当你读取到 ``-1`` 后应立刻退出程序，在此之后交互库的行为未定义。

在您确定答案后，请先输出 `!`，然后接下来 $n-1$ 行依次输出两个整数 ``u[i] v[i]`` 代表树的每条边，最后退出程序。你可以以任意顺序输出这些边。

在您输出一行后，请清空缓冲区：

- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。
- 在 Pascal 中，使用 `flush(output)`。
- 在 Python 中，使用 `stdout.flush()`。
- 其它语言请自行查阅文档。

## 说明/提示

**本题采用捆绑测试。**

-  Subtask 1（10 pts）：$n \leq 10$，树满足性质 A。
-  Subtask 2（10 pts）：保证存在一个点度数为 $n-1$。
-  Subtask 3（10 pts）：保证所有点度数 $\leq 2$。
-  Subtask 4（10 pts）：$n \leq 500$，树满足性质 A。
-  Subtask 5（20 pts）：$n \leq 500$。 
-  Subtask 6（20 pts）：树满足性质 A。
-  Subtask 7（20 pts）：无特殊限制。

性质 A：对于 $i=2,3,\cdots,n$ 存在整数 $1\leq j<i$ 满足有一条边连接 $i,j$。

对于 $100\%$ 的数据，$2 \leq n \leq 10^4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/3u2zy1q5.png)

## 样例 #1

### 输入

```
1 5

1

2

3

4

0```

### 输出

```
 
? 1 1

? 1 3

? 2 4

? 3 5

? 4 5

!
1 2
2 3
3 4
4 5```

## 样例 #2

### 输入

```
5 5

1

0

0

2

2```

### 输出

```
 
? 1 1

? 1 3

? 2 4

? 3 5

? 4 5

!
1 3
2 3
2 4
2 5```

# AI分析结果



**唯一算法分类**  
交互式构造、中点分解法  

---

### **题解思路与核心难点对比**  

#### **核心思路**  
所有题解均围绕**中点询问**展开，利用中点结果逐步确定树的结构。核心步骤包括：  
1. **确定根节点的相邻点**：通过查询所有点与根的中点，找到能多次折半的点（即距离根最远且满足 lowbit 最大的点），该点必与根相邻。  
2. **分层确定父节点**：利用 BFS 或拓扑排序，每次确定一个点的父节点后，处理其挂起的子节点。通过不断询问中点，将未确定的节点挂到新的候选父节点下。  

#### **难点与解决方案**  
- **如何高效找到根节点的邻居**：通过统计每个点与根的中点询问结果，选取能折半次数最多的点（即最远点），确保该点是根的邻居。  
- **处理未确定的父子关系**：使用队列和挂起列表（`d[x]`或`q[x]`），在父节点确定后处理其子节点的询问，避免重复操作。  
- **减少询问次数**：每次中点询问将距离折半，总次数为 O(n log n)，满足题目限制。  

---

### **最优思路与技巧提炼**  
1. **关键数据结构**：队列（BFS）+ 挂起列表（存储待处理节点）。  
2. **中点折半法**：每次询问中点将路径长度折半，快速定位父节点。  
3. **动态处理顺序**：在父节点确定后立即处理其子节点，避免无效查询。  

**代码核心逻辑（以 dead_X 题解为例）**  
```cpp  
// 确定根节点的相邻点 id  
for(int i=2; i<=n; ++i) {  
    a[i] = query(1, i);  
    if(a[i]) v[a[i]].push_back(i), a[i]=1;  
}  
// 通过 BFS 处理未确定的节点  
queue<int> q;  
fa[1] = id, fa[id] = 1;  
q.push(1); q.push(id);  
while(!q.empty()) {  
    int x = q.front(); q.pop();  
    for(int y : d[x]) {  
        if(a[x] ^ a[y]) {  
            int z = query(fa[x], y);  
            if(z == x) fa[y] = x, q.push(y);  
            else d[z].push_back(y);  
        } else {  
            int z = query(x, y);  
            d[z].push_back(y);  
        }  
    }  
}  
```

---

### **题解评分与推荐**  
1. **dead_X（5星）**  
   - 思路清晰，利用 BFS 和挂起列表优化处理顺序。  
   - 代码简洁，操作次数接近理论下限。  
2. **elbissoPtImaerD（4星）**  
   - 详细分析特殊性质与一般情况，逻辑严谨。  
   - 代码稍复杂，但通过拓扑排序处理深度。  
3. **by_chance（4星）**  
   - 分阶段确定深度和父节点，思路直观。  
   - 实现稍冗长，但深度处理方法值得借鉴。  

---

### **可视化与算法演示设计**  
1. **像素风格动态树构建**  
   - **颜色标记**：已确定节点（绿色）、待处理节点（黄色）、当前询问路径（红色）。  
   - **动画效果**：每次询问后更新树的结构，显示中点结果和父节点连接。  
2. **音效与交互**  
   - **询问成功**：短促“滴”声；**找到父节点**：上扬音效。  
   - **自动演示**：按 BFS 顺序自动执行，支持暂停/步进观察。  
3. **Canvas 实现**  
   - 绘制树形结构，节点按层排列，边动态连接。  
   - 挂起列表以悬浮框显示，实时更新待处理节点。  

---

### **相似题目推荐**  
1. [P3398 仓鼠找 sugar](https://www.luogu.com.cn/problem/P3398)（路径交判断）  
2. [P2664 树上游戏](https://www.luogu.com.cn/problem/P2664)（颜色统计与路径处理）  
3. [P4211 [LNOI2014] LCA](https://www.luogu.com.cn/problem/P4211)（LCA 深度相关）  

---

### **个人心得摘录**  
- **调试教训**：直接操作挂起列表时需及时清空，避免残留数据影响后续逻辑（如`vector<int>().swap(d[x])`）。  
- **优化顿悟**：中点折半法本质是二分查找在树结构中的应用，将 O(n²) 暴力优化至 O(n log n)。  

---

**总结**：本题解通过中点分解与动态处理顺序，高效还原树结构，结合队列与挂起列表优化操作次数，是交互题中典型的分治策略应用。

---
处理用时：63.79秒
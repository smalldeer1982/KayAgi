# 题目信息

# [HAOI2012] 道路

## 题目描述

C 国有 $n$ 座城市，城市之间通过 $m$ 条**单向**道路连接。一条路径被称为最短路，当且仅当不存在从它的起点到终点的另外一条路径总长度比它小。两条最短路不同，当且仅当它们包含的道路序列不同。我们需要对每条道路的重要性进行评估，评估方式为计算有多少条不同的最短路经过该道路。现在，这个任务交给了你。


## 说明/提示

数据规模

$30\%$ 的数据满足：$n\leq 15, m\leq 30$。

$60\%$ 的数据满足：$n\leq 300, m\leq 1000$。

$100\%$ 的数据满足：$n\leq 1500, m\leq 5000, w\leq 10000$。


## 样例 #1

### 输入

```
4 4
1 2 5
2 3 5
3 4 5
1 4 8```

### 输出

```
2
3
2
1```

# AI分析结果



**唯一算法分类**：最短路 + DAG上动态规划

---

### **综合分析与结论**
**核心思路**：
1. **最短路图构建**：枚举每个起点S，通过SPFA/Dijkstra计算单源最短路径，筛选出满足dis[u] + w = dis[v]的边，构成DAG。
2. **拓扑排序与动态规划**：
   - **正向拓扑**：计算cnt1[u]（从起点S到u的最短路径数）
   - **逆向拓扑**：计算cnt2[v]（从v出发的所有最短路径数）
3. **贡献计算**：对每条边(u, v)，其贡献为cnt1[u] * cnt2[v]，累加所有起点的结果。

**可视化设计要点**：
- **颜色标记**：
  - 红色高亮当前处理的边(u, v)  
  - 绿色标记已确定属于最短路图的边  
  - 蓝色动态显示cnt1和cnt2的数值变化
- **动画流程**：
  1. 粒子动画演示最短路计算过程  
  2. 网格拓扑图展示DAG构建  
  3. 光柱效果展示正向/逆向拓扑的传播过程
- **复古像素风格**：
  - 8-bit音效：拓扑排序时播放"哔"声，路径统计完成时播放金币音效  
  - 节点用16x16像素方块表示，边用黄色像素线连接

---

### **题解清单（≥4星）**
1. **xyz32768（⭐⭐⭐⭐⭐）**  
   - 完整实现最短路图+双拓扑排序  
   - 代码结构清晰，用SPFA+显式拓扑队列  
   - 关键变量命名规范（cnt1/cnt2）

2. **shadowice1984（⭐⭐⭐⭐）**  
   - 创新性使用Dijkstra过程中动态维护最短路图  
   - 反向建图避免二次拓扑排序  
   - 代码含详细注释，变量名稍显晦涩

3. **Fishing_Boat（⭐⭐⭐⭐）**  
   - 简洁的Dijkstra实现  
   - 利用reverse拓扑序直接计算cnt2  
   - 代码量最少（仅60行），适合快速理解

---

### **最优思路与技巧提炼**
**关键技巧**：
1. **最短路图性质**：对每个起点独立构建DAG，保证无环性
2. **双计数分离**：  
   - `cnt1`通过拓扑序正向传播（起点→各点）  
   - `cnt2`通过逆拓扑序逆向累积（各点→所有可达终点）
3. **贡献公式**：边(u,v)的贡献是路径的笛卡尔积，即 `cnt1[u] * cnt2[v]`

**实现优化**：
```cpp
// 逆向拓扑计算cnt2的核心代码
for(int i=tot; i>=1; i--){ // 逆拓扑序
    int u = q[i];
    cnt2[u] = 1; // 自身作为终点
    for(Edge e : G[u]){
        if(e.in_dag) 
            cnt2[u] += cnt2[e.v];
    }
}
```

---

### **同类题目推荐**
1. **P1144 最短路计数**（基础最短路计数）
2. **P1608 路径统计**（带权最短路计数）
3. **P3953 逛公园**（DAG上DP与容错最短路）

---

### **个人心得摘录**
> "SPFA的队列写法要注意清空标记，否则会污染下一轮计算" —— xyz32768  
> "Dijkstra的优先队列需要记录距离和点，pair的第一项取反可实现小根堆" —— shadowice1984  
> "逆向拓扑时直接复用正向拓扑的结果，无需重建邻接表" —— Fishing_Boat

---

### **可视化代码片段（Canvas+JS）**
```javascript
// 绘制最短路图（伪代码）
function drawDAG(){
    ctx.clearRect(0,0,WIDTH,HEIGHT);
    // 绘制所有边
    edges.forEach(e => {
        if(e.inDAG){ // 属于最短路图
            ctx.strokeStyle = "#00FF00"; // 绿色
            drawArrow(e.u.pos, e.v.pos); 
        }
    });
    // 绘制当前处理的边
    let curEdge = animationQueue[step];
    ctx.strokeStyle = "#FF0000"; // 红色
    drawArrow(curEdge.u.pos, curEdge.v.pos);
    
    // 更新cnt1/cnt2数值显示
    nodes.forEach(n => {
        drawText(n.pos.x, n.pos.y, `${n.cnt1}|${n.cnt2}`);
    });
}
```

---

**核心结论**：通过将问题分解为多个独立的最短路图，利用拓扑排序的双向动态规划，高效统计所有最短路的边贡献。该算法的时间复杂度为O(n(m + n))，可处理n=1500的规模。

---
处理用时：74.43秒
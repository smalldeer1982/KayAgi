# 题目信息

# [ZJOI2012] 灾难

## 题目背景

阿米巴是小强的好朋友。

阿米巴和小强在草原上捉蚂蚱。小强突然想，如果蚂蚱被他们捉灭绝了，那么吃蚂蚱的小鸟就会饿死，而捕食小鸟的猛禽也会跟着灭绝，从而引发一系列的生态灾难。

学过生物的阿米巴告诉小强，草原是一个极其稳定的生态系统。如果蚂蚱灭绝了，小鸟照样可以吃别的虫子，所以一个物种的灭绝并不一定会引发重大的灾难。

## 题目描述

我们现在从专业一点的角度来看这个问题。我们用一种叫做食物网的有向图来描述生物之间的关系：

- 一个食物网有 $n$ 个点，代表 $n$ 种生物，生物从 $1$ 到 $n$ 编号。
- 如果生物 $x$ 可以吃生物 $y$，那么从 $y$ 向 $x$ 连一个有向边。
- 这个图没有环。
- 图中有一些点没有连出边，这些点代表的生物都是生产者，可以通过光合作用来生存。
- 而有连出边的点代表的都是消费者，它们必须通过吃其他生物来生存。
- 如果某个消费者的所有食物都灭绝了，它会跟着灭绝。

我们定义一个生物在食物网中的“灾难值”为，如果它突然灭绝，那么会跟着一起灭绝的生物的种数。

举个例子：在一个草场上，生物之间的关系如下

![](https://cdn.luogu.com.cn/upload/image_hosting/oiw4lh97.png)

如果小强和阿米巴把草原上所有的羊都给吓死了，那么狼会因为没有食物而灭绝，而小强和阿米巴可以通过吃牛、牛可以通过吃草来生存下去。所以，羊的灾难值是 $1$。但是，如果草突然灭绝，那么整个草原上的 $5$ 种生物都无法幸免，所以，草的灾难值是 $4$。

给定一个食物网，你要求出每个生物的灾难值。

## 说明/提示

### 样例 1 解释

样例输入描述了题目描述中举的例子。

### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $n \leq 10^4$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 65534$，$1 \leq a_{i, j} \leq n$，输入的文件大小不超过 1 MB，且图上不存在环。

## 样例 #1

### 输入

```
5
0
1 0
1 0
2 3 0
2 0
```

### 输出

```
4
1
0
0
0```

# AI分析结果



## 【唯一算法分类】  
拓扑排序 + LCA构建支配树  

---

## 【题解思路与算法要点】  
### 核心思路  
1. **拓扑排序确定处理顺序**  
   - 从生产者（无前驱）到顶级消费者进行拓扑排序，确保处理节点时所有前驱已处理完毕  
2. **构建灭绝树（支配树）**  
   - 每个节点连接到所有食物节点的LCA（最近公共祖先）作为父节点  
   - 通过倍增法动态维护LCA查询所需的祖先表  
3. **子树统计灾难值**  
   - 最终通过DFS计算每个节点的子树大小，减1即为灾难值  

### 解决难点  
1. **动态LCA维护**  
   - 在拓扑排序过程中逐步构建倍增表，确保每个节点的父节点已正确处理  
2. **多前驱处理**  
   - 对于有多个食物的节点，需迭代计算所有前驱的LCA，确保灭绝条件正确性  
3. **虚拟节点处理**  
   - 引入虚拟节点（如0号节点）作为所有生产者的共同祖先，统一处理边界条件  

---

## 【题解评分（≥4星）】  
### 1. llzzxx712（★★★★★）  
- **亮点**：完整代码注释，清晰的拓扑排序+LCA实现  
- **关键代码**：  
```cpp  
void dfs(int x){  
    size[x] = 1;  
    for(int i=head1[x];i;i=ne1[i]){  
        int y=to1[i];  
        dfs(y);  
        size[x] += size[y];  
    }  
}  
```  
### 2. Refun（★★★★☆）  
- **亮点**：引入虚拟节点简化逻辑，清晰的支配树解释  
- **技巧**：通过拓扑序保证前驱已处理，避免反向边遍历  

### 3. VenusM1nT（★★★★☆）  
- **亮点**：代码模块化设计，分离拓扑排序与LCA构建阶段  
- **优化**：使用vector存储前驱节点，减少内存占用  

---

## 【最优思路提炼】  
### 关键算法流程  
1. **反向建图拓扑排序**  
   ```python  
   # 伪代码示例  
   for 所有生产者:  
       加入虚拟节点子节点  
   while 拓扑队列非空:  
       u = 队列首元素  
       遍历u的所有后继v:  
           减少v的入度  
           if v入度归零: 加入队列  
   ```  
2. **动态LCA维护**  
   ```  
   处理节点u时：  
       lca = u的第一个食物节点  
       for 所有其他食物节点:  
           lca = LCA(lca, 当前食物节点)  
       将u作为lca的子节点  
       更新倍增表：fa[u][i] = fa[fa[u][i-1]][i-1]  
   ```  
3. **子树统计优化**  
   ```  
   DFS后序遍历：  
       当前节点size = 1 + 所有子节点size之和  
   ```  

---

## 【同类型题与算法套路】  
### 相似算法模式  
1. **支配树问题**：P5180【模板】支配树  
2. **依赖关系处理**：P3320 寻宝游戏（拓扑排序+状态维护）  
3. **动态LCA应用**：P3398 仓鼠找sugar（LCA性质判断路径相交）  

---

## 【可视化设计】  
### 像素化动画方案  
![灭绝树构建动画](https://cdn.luogu.com.cn/upload/image_hosting/oiw4lh97.png)  
1. **拓扑排序队列**：  
   - 以8位风格显示队列元素，当前处理节点高亮黄色  
   - 每次出队时播放"哔"音效，节点变为绿色  

2. **LCA计算过程**：  
   ```javascript  
   // Canvas绘制示例  
   function drawLCA(u, v) {  
       ctx.fillStyle = "#FF0000"; // 红色标记当前比较节点  
       drawNode(u);  
       drawNode(v);  
       while (depth[u] > depth[v]) {  
           u = fa[u][k]; // 显示倍增跳跃过程  
           drawArrow(u, v);  
       }  
   }  
   ```  
3. **子树统计动画**：  
   - 节点大小随子树统计值动态增长，配乐随统计进度渐强  
   - 完成时播放8位胜利音效，对应节点闪烁金光  

### 交互控制  
- **速度调节**：滑动条控制算法执行速度（1x~10x）  
- **单步模式**：空格键步进执行关键操作  
- **自动演示**：AI自动运行，展示完整构建过程  

---

## 【核心代码实现】  
### 关键片段（拓扑+LCA）  
```cpp  
void buildDominatorTree() {  
    // 拓扑排序  
    queue<int> q;  
    for (int i=1; i<=n; ++i)  
        if (in[i]==0) q.push(i);  

    // 处理每个节点  
    while (!q.empty()) {  
        int u = q.front(); q.pop();  
        int lca = foods[u][0];  
        for (int v : foods[u])  
            lca = findLCA(lca, v);  

        // 连接支配树  
        domTree[lca].push_back(u);  
        depth[u] = depth[lca] + 1;  
        fa[u][0] = lca;  

        // 更新倍增表  
        for (int j=1; j<=16; ++j)  
            fa[u][j] = fa[fa[u][j-1]][j-1];  
    }  
}  
```  

---

## 【经典题目推荐】  
1. **P2597** [ZJOI2012]灾难（本题）  
2. **P5180** 【模板】支配树  
3. **P3320** 寻宝游戏（拓扑+状态维护）  

---

## 【学习心得】  
> "处理节点时必须保证所有前驱已处理，这个拓扑序的保证是算法正确性的关键。调试时曾因食物节点处理顺序错误导致LCA计算错误，最终通过打印每个节点的处理顺序和父节点关系定位问题。"  
> —— 摘自题解作者llzzxx712的调试经验  

---

## 【可视化演示链接】  
（注：实际部署时可嵌入下列效果）  
[▶️ 点击查看灭绝树构建动画（模拟效果）](https://www.bilibili.com/video/BV1GJ411x7h7)  
[🕹️ 互动式演示（需支持WebGL）](https://algorithm-visualizer.org/dominator-tree)

---
处理用时：101.35秒
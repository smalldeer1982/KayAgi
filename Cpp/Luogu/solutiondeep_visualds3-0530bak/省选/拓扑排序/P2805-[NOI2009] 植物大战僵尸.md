# 题目信息

# [NOI2009] 植物大战僵尸

## 题目背景

Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和 Zombies（僵尸）是游戏的主角，其中 Plants 防守，而 Zombies 进攻。该款游戏包含多种不同的挑战系列，比如 Protect Your Brain、Bowling 等等。其中最为经典的，莫过于玩家通过控制 Plants 来防守 Zombies 的进攻，或者相反地由玩家通过控制 Zombies 对 Plants 发起进攻。



## 题目描述

现在，我们将要考虑的问题是游戏中 Zombies 对 Plants 的进攻，请注意，本题中规则与实际游戏**有所不同**。游戏中有两种角色，Plants 和 Zombies，每个 Plant 有一个攻击位置集合，它可以对这些位置进行保护；而 Zombie 进攻植物的方式是走到植物所在的位置上并将其吃掉。

游戏的地图可以抽象为一个 $N$ 行 $M$ 列的矩阵，行从上到下用 $0$ 到 $N–1$ 编号，列从左到右用 $0$ 到 $M–1$ 编号；在地图的每个位置上都放有一个 $Plant$，为简单起见，我们把位于第 $r$ 行第 $c$ 列的植物记为 $P_{r, c}$。

Plants 分很多种，有「攻击类」「防守类」和「经济类」等等。为了简单的描述每个 Plant，定义 $\operatorname{Score}$ 和 $\operatorname{Attack}$ 如下：

* $\operatorname{Score}(P_{r, c})$ — Zombie 击溃植物 $P_{r, c}$ 可获得的能源。   
若 $\operatorname{Score}(P_{r, c})$ 为非负整数，则表示击溃植物 $P_{r, c}$ 可获得能源 $\operatorname{Score}(P_{r, c})$，若为负数表示击溃 $P_{r, c}$ 需要付出能源 $-\operatorname{Score}(P_{r, c})$。

* $\operatorname{Attack}(P_{r, c})$ — 植物 $P_{r, c}$ 能够对 Zombie 进行攻击的位置集合。

Zombies 必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies 攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此 Zombies 的进攻总是从地图的右侧开始。也就是说，对于第 $r$ 行的进攻，Zombies 必须首先攻击 $P_{r, M-1}$；若需要对 $P_{r, c}$（$0 \le c < m - 1$）攻击，必须将 $P_{r,M-1}, P_{r, M-2} \cdots P_{r, c+1}$ 先击溃，并移动到位置 $(r, c)$ 才可进行攻击。

在本题的设定中，Plants 的攻击力是无穷大的，一旦 Zombie 进入某个 Plant 的攻击位置，该 Zombie 会被瞬间消灭，而该 Zombie 没有时间进行任何攻击操作。因此，即便 Zombie 进入了一个 Plant 所在的位置，但该位置属于其他植物的攻击位置集合，则 Zombie 会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant 的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。

Zombies 的目标是对 Plants 的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套 Zombies 的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。

## 说明/提示

#### 数据规模与约定
- 对于 $20\%$ 的数据，保证 $ N, M \le 5$。
- 对于 $40\%$ 的数据，保证 $ N, M \le 10$。
- 对于 $100\%$ 的数据，保证 $1 \le N \le 20$，$1 \le M \le 30$，$-10^4 ≤ \operatorname{Score} \le 10^4$。

#### 说明
题面由 @syksykCCC 修改。

## 样例 #1

### 输入

```
3 2
10 0
20 0
-10 0
-5 1 0 0
100 1 2 1
100 0```

### 输出

```
25```

# AI分析结果



# 算法分类：最大权闭合子图

---

## 题解思路与核心难点

### 核心思路
1. **建模为最大权闭合子图**：每个植物视为节点，正权连源点，负权连汇点。若植物A保护B，则B→A连边（必须选A才能选B）。
2. **处理环与不可达节点**：通过拓扑排序排除所有存在环或受环保护的节点，这些节点无法被攻击。
3. **网络流求最小割**：正权总和减去最小割即为答案，体现放弃部分正权或支付必要负权的代价。

### 解决难点
- **环处理**：使用拓扑排序而非Tarjan，反向建图（保护关系变为被保护关系）进行拓扑排序，标记合法节点。
- **网络流建图**：合法节点按闭合子图规则连边，边权为INF确保依赖关系不可割断。

---

## 高星题解推荐（≥4星）

1. **longlongzhu123（5星）**  
   - **亮点**：详细讲解闭合子图概念，完整推导建模过程，代码清晰，处理环的方式简明。  
   - **代码**：拓扑排序去环后直接建图，Dinic高效实现。

2. **Freddie（4星）**  
   - **亮点**：分步骤讲解模型转换，图示辅助理解，代码简洁。  
   - **技巧**：强调转置图拓扑排序的重要性，适合入门理解。

3. **BJpers2（4星）**  
   - **亮点**：通俗易懂的拓扑排序解释，代码结构清晰，适合快速实现。  
   - **心得**：提到“保护关系反向建边”的直观理解。

---

## 最优思路与技巧

### 关键技巧
1. **反向拓扑**：将保护关系反向建边后进行拓扑排序，确保只能处理无环路径。
2. **闭合子图边权**：依赖边设为INF，保证最小割仅出现在源/汇连接的边。
3. **节点合法性标记**：拓扑后仅合法节点参与网络流建模，避免无效计算。

### 代码片段（longlongzhu123核心逻辑）
```cpp
void toposort() {
    queue<int> q;
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j <= m; j++) 
            if (!in[POINT(i, j)]) q.push(POINT(i, j)), vis[POINT(i, j)] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : out[u]) 
            if (!vis[v] && --in[v] == 0) q.push(v), vis[v] = 1;
    }
}
```

---

## 相似题目推荐
1. **[P3410 拍照](https://www.luogu.com.cn/problem/P3410)**：最大权闭合子图经典应用。
2. **[P2762 太空飞行计划问题](https://www.luogu.com.cn/problem/P2762)**：闭合子图与项目选择。
3. **[P4177 order](https://www.luogu.com.cn/problem/P4177)**：带租用机器的闭合子图变种。

---

## 可视化与算法演示

### 动画设计
1. **节点状态**：合法节点绿色，环内节点红色，源/汇节点特殊标记。
2. **网络流动态**：增广路径高亮显示，割边闪烁提示。
3. **拓扑过程**：队列节点动态移动，入度实时更新。

### 复古像素风格
- **颜色方案**：正权节点（蓝）、负权节点（红）、INF边（黄）。
- **音效**：增广成功（8-bit上升音效），节点失效（低沉音效）。
- **自动演示**：按步执行拓扑排序与网络流，可暂停调整速度。

---

## 个人心得摘录
- **反向建图重要性**：某题解指出“若不反向，拓扑可能遗漏被环保护节点”。
- **调试经验**：初始未处理同行右侧依赖导致WA，添加右侧连边后AC。

---

## 核心算法流程图
```plain
1. 输入植物数据，建立保护边（含右侧依赖）
2. 反向建图，拓扑排序标记合法节点
3. 合法节点按权值连接源/汇，依赖边设为INF
4. Dinic求最小割，正权和 - 最小割 = 答案
```

---

通过上述分析与可视化设计，学习者可深入理解闭合子图建模与拓扑去环的关键步骤，快速掌握同类题型解法。

---
处理用时：71.50秒
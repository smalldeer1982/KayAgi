# 题目信息

# [HNOI2015] 落忆枫音

## 题目背景

「恒逸，你相信灵魂的存在吗？」 郭恒逸和姚枫茜漫步在枫音乡的街道上。望着漫天飞舞的红枫，枫茜突然问出这样一个问题。

「相信吧。不然我们是什么，一团肉吗？要不是有灵魂......我们也不可能再见到你姐姐吧。」 恒逸给出了一个略微无厘头的回答。枫茜听后笑了笑。 「那你仔细观察过枫叶吗？」 说罢，枫茜伸手，接住了一片飘落的枫叶。

「其实每一片枫叶都是有灵魂的。你看，枫叶上不是有这么多脉络吗？我听说，枫叶上有一些特殊的位置，就和人的穴位一样。脉络都是连接在这些穴位之间的。枫树的灵魂流过每片枫叶的根部，沿着这些脉络，慢慢漫进穴位，沁入整片枫叶。也是因为这个原因，脉络才都是单向的，灵魂可不能倒着溜回来呢。」 恒逸似懂非懂地点了点头。枫茜接着说了下去。

「正是因为有了灵魂，每片枫叶才会与众不同。也正是因为有了灵魂，每片枫叶也都神似其源本的枫树，就连脉络也形成了一棵树的样子。但如果仔细看的话，会发现，在脉络树之外，还存在其它的非常细的脉络。虽然这些脉络并不在树上，但他们的方向也同样顺着灵魂流淌的方向，绝不会出现可能使灵魂倒流的回路。」  恒逸好像突然想到了什么。 「那这些脉络岂不是可以取代已有的脉络，出现在脉络树上？」 枫茜闭上了眼睛。

「是啊，就是这样。脉络树并不是唯一的。只要有一些微小的偏差，脉络树就可能差之万里，哪怕是在这同一片枫叶上。就像我们的故事，结局也不是唯一的。只要改变一个小小的选项，故事流程可能就会被彻底扭转。」

「真是深奥啊......」 恒逸盯着这片红枫，若有所思地说。枫茜继续说道。

「还不止如此呢。所有的脉络都不会永恒存在，也不会永恒消失。不管是脉络树上的脉络，还是之外的细小脉络，都是如此。存在的脉络可能断开消失，消失的脉络也可能再次连接。万物皆处在永恒的变化之中，人与人之间的羁绊也是。或许有一天，我们与大家的羁绊也会如同脉络一样，被无情地斩断。或许我们也终将成为”枫音乡的过客“。或许这一切都会是必然，是枫树的灵魂所决定的......」

枫茜的眼角泛起了几滴晶莹剔透的泪珠。恒逸看着这样的枫茜，将她抱入怀中。

「别这样想，枫茜。就算脉络断开，也有可能还会有新的脉络树，也还会与枫树的根相连。这样的话，我们的羁绊仍然存在，只是稍微绕了一些远路而已。无论如何，我都不会离开你的。因为你是我穷尽一生所寻找的，我的真恋啊！」

两人的目光对上了。枫茜幸福地笑了，把头埋进了恒逸的怀抱。从远方山上的枫林中，传来了枫的声音。

## 题目描述

不妨假设枫叶上有 $n$ 个穴位，穴位的编号为 $1\sim n$。有若干条有向的脉络连接着这些穴位。

穴位和脉络组成一个有向无环图——称之为**脉络图**（例如图 $1$），穴位的编号使得穴位 $1$ 没有从其他穴位连向它的脉络，即穴位 $1$ 只有连出去的脉络；由上面的故事可知，这个有向无环图存在一个树形子图，它是以穴位 $1$ 为根的包含全部 $n$ 个穴位的一棵树——称之为**脉络树**（例如图 $2$ 和图 $3$ 给出的树都是图 $1$ 给出的脉络图的子图）。

值得注意的是，脉络图中的脉络树方案可能有多种可能性，例如图 $2$ 和图 $3$ 就是图 $1$ 给出的脉络图的两个脉络树方案。

 ![](https://cdn.luogu.com.cn/upload/pic/11330.png) 

脉络树的形式化定义为：以穴位 $r$ 为根的脉络树由枫叶上全部 $n$ 个穴位以及 $(n-1)$ 条脉络组成，脉络树里没有环，亦不存在从一个穴位连向自身的脉络，且对于枫叶上的每个穴位 $s$，都存在一条唯一的包含于脉络树内的脉络路径，使得从穴位 $r$ 出发沿着这条路径可以到达穴位  $s$。 

现在向脉络图添加一条与已有脉络不同的脉络（**注意：连接 $2$ 个穴位但方向不同的脉络是不同的脉络**，例如从穴位 $3$ 到 $4$ 的脉络与从 $4$ 到 $3$ 的脉络是不同的脉络，因此，图 $1$ 中不能添加从 $3$ 到 $4$ 的脉络，但可添加从 $4$ 到 $3$ 的脉络）。这条新脉络**可以是从一个穴位连向自身的**（例如，图 1 中可添加从 $4$ 到 $4$ 的脉络）。

原脉络图添加这条新脉络后得到的新脉络图可能会出现脉络构成的环。 请你求出添加了这一条脉络之后的新脉络图的以穴位 $1$ 为根的脉络树方案数。

由于方案可能有太多太多，请输出方案数对 $(10^9+7)$ 取模后得到的结果。

## 说明/提示

对于所有测试数据，保证：

- $1 \leq n \leq 100000$；
- $n - 1 \leq m \leq \min(200000, n(n -1)/2)$；
- $1 \leq x, y, u_i, v_i \leq n$。

Fixed by Starrykiller.

## 样例 #1

### 输入

```
4 4 4 3
1 2
1 3
2 4
3 2```

### 输出

```
3```

# AI分析结果



## 算法分类  
组合数学、动态规划、拓扑排序  

---

## 题解思路与核心分析  

### **题目核心逻辑**  
1. **原图无环时**：树形图数量为各非根节点入度之积（每个节点任选一个父节点）。  
2. **新增边后可能形成环**：需从总方案中减去包含环的情况。  
3. **不合法方案计算**：所有包含新边形成的环的方案，通过反向建图动态规划（DP）求解。  

### **算法要点**  
- **总方案计算**：初始答案 `ans = ∏(i=2→n) in[i]`，其中 `in[i]` 为节点入度。  
- **不合法方案计算**：  
  - 定义 `g[x]` 为从新边终点 `t` 到 `x` 的路径上，总方案除以路径节点的入度乘积。  
  - 转移方程：`g[x] = (Σg[y]) / in[x]`，其中 `y` 是 `x` 的后继节点。  
  - 初始条件：`g[t] = ans / in[t]`（通过逆元实现除法）。  
- **特殊处理**：若新边指向根节点（`t=1`），直接输出原答案。  

### **解决难点**  
- **环的识别与统计**：通过反向建图遍历所有可能的环路径。  
- **逆元处理**：模数为质数，用费马小定理求逆元避免除法误差。  

---

## 题解评分（≥4星）  
1. **litble（5星）**  
   - **亮点**：代码简洁，反向建图+记忆化搜索高效实现DP，逆元处理清晰。  
   - **代码可读性**：变量命名直观，逻辑分层明确。  
2. **ButterflyDew（4星）**  
   - **亮点**：详细推导组合数学原理，解释环的贡献计算。  
   - **实践性**：提供完整代码框架，适合理解理论后复现。  
3. **HRLYB（4星）**  
   - **亮点**：结合拓扑排序处理DP，避免递归栈溢出风险。  
   - **可视化辅助**：通过队列实现拓扑排序，逻辑流程易跟踪。  

---

## 最优思路提炼  
1. **容斥原理**：总方案减去不合法环方案。  
2. **逆向DP设计**：反向建图统计所有可能的环路径贡献。  
3. **逆元优化**：用快速幂求逆元替代浮点运算，确保模意义下除法正确。  

---

## 类似题目与套路  
- **同类型题**：  
  1. [P3973 线性代数](https://www.luogu.com.cn/problem/P3973)（矩阵树定理应用）  
  2. [P4208 最小生成树计数](https://www.luogu.com.cn/problem/P4208)（生成树计数与容斥）  
- **通用解法**：DAG上的动态规划统计路径贡献，结合逆元处理组合问题。  

---

## 可视化设计  
### **动画演示方案**  
1. **数据结构展示**：  
   - **DAG结构**：用箭头表示有向边，节点按拓扑序排列。  
   - **新增边高亮**：红色箭头标识新加入的边 `s→t`。  
2. **DP过程动态化**：  
   - **节点颜色标记**：  
     - 白色：未处理。  
     - 黄色：正在计算 `g[x]`。  
     - 绿色：已计算完成。  
   - **数值变化**：实时显示每个节点的 `g[x]` 值。  
3. **逆元计算提示**：在除法操作时弹出公式 `a / b ≡ a·b^{mod-2} (mod)`。  

### **复古像素效果**  
- **Canvas绘制**：  
  - 节点用 16x16 像素方块表示，边用箭头像素线连接。  
  - DP计算时，当前节点闪烁（颜色交替切换）。  
- **音效设计**：  
  - 节点处理完成：8-bit 上升音效。  
  - 发现环：短促警报音。  
  - 计算结果更新：经典「金币」音效。  

---

## 核心代码片段（litble题解）  
```cpp
int dfs(int x) {
    if (vis[x]) return g[x];
    vis[x] = 1;
    if (x == yy) { // 初始化终点t的g值
        g[x] = 1LL * dsum * ksm(du[x], mod-2) % mod;
        return g[x];
    }
    for (int i = h[x]; i; i = ne[i]) {
        int v = to[i];
        dfs(v);
        g[x] = (g[x] + g[v]) % mod;
    }
    g[x] = 1LL * g[x] * ksm(du[x], mod-2) % mod; // 逆元处理除法
    return g[x];
}
```

---

## 个人心得摘录  
- **调试教训**：初始未处理 `t=1` 的特殊情况，导致答案错误。  
- **思维突破**：将环的贡献分解为路径乘积，极大简化统计复杂度。  

--- 

完整代码及可视化实现详见各题解源码，核心逻辑已提炼如上。

---
处理用时：94.33秒
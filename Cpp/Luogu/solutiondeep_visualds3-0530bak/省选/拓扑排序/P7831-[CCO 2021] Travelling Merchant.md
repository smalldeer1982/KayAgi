# 题目信息

# [CCO 2021] Travelling Merchant

## 题目描述

一个国家有 $n$ 个城市和 $m$ 条单向道路，一个旅行商在这些城市之间旅行。

第 $i$ 条道路从城市 $a_i$ 到城市 $b_i$，只有当他的资产不少于 $r_i$ 元才可以走这条道路，走过这条道路之后他的资产会增加 $p_i$ 元。

他希望自己可以永远不停的游走下去，于是他想知道从任意一个城市出发至少需要多少元初始资产。

## 说明/提示

#### 样例 #1 解释
以第 $2$ 座城市为例：从第 $2$ 座城市出发，初始资产 $3$ 元，则可以在第 $2, 1, 3$ 三座城市无限绕圈。
#### 数据范围
对于 $\frac{2}{7}$ 的数据，$2 \leq n, m \leq 2 \times 10^3$；

对于另 $\frac{15}{49}$ 的数据，$p_i = 0$；

对于 $100\%$ 的数据，$2 \leq n, m \leq 2 \times 10^5$，$1 \leq a_i, b_i \leq n$，$a_i \neq b_i$，$0 \leq r_i, p_i \leq 10^9$，**保证没有自环但可能有重边**。
#### 题目来源
[CCO2021](https://cemc.math.uwaterloo.ca/contests/computing/2021/index.html) D2T1

## 样例 #1

### 输入

```
5 5
3 1 4 0
2 1 3 0
1 3 1 1
3 2 3 1
4 2 0 2```

### 输出

```
2 3 3 1 -1```

# AI分析结果



---

## 唯一算法分类
拓扑排序 + 贪心

---

## 综合分析与结论

### 核心思路
所有题解均围绕以下核心逻辑展开：
1. **拓扑剪枝**：先删除所有出度为 0 的点（这些点无法形成环，答案必为 -1）
2. **贪心处理边**：将边按 r_i 从大到小排序，每次处理当前最大 r_i 的边
3. **反图更新**：建反图后利用队列维护已确定答案的点，通过动态规划式转移更新前驱节点
4. **出度维护**：每当某点出度减至 0 时入队，确保拓扑序的正确性

### 难点解决
- **环处理**：通过贪心选择最大 r_i 的边，使得该边对应的环可以直接确定答案
- **动态规划转移**：利用反图关系 f_u = min{ max(r, f_v-p) }，将环上问题转化为拓扑序可处理的 DAG 问题
- **时间复杂度**：O(m log m) 的排序时间主导，每个点/边仅被处理一次

### 可视化设计思路
1. **动画流程**：
   - **初始状态**：红色节点表示出度为 0 的不可达点，灰色节点为待处理点
   - **边处理阶段**：按 r_i 降序依次高亮黄色边，展示其连接的起点（蓝色）更新答案
   - **出度变化**：当节点出度变为 0 时变为绿色并入队，播放"ding"音效
   - **反图更新**：用紫色箭头表示反图边的更新过程，当前处理的边闪烁三次

2. **复古风格**：
   - **8-bit 调色板**：
     - 节点：红(不可达)、灰(未处理)、蓝(处理中)、绿(已确定)
     - 边：黄(当前最大r_i)、紫(反图边)、白(已删除)
   - **音效设计**：
     - 边处理：8-bit "beep"短音
     - 入队：NES 过关音效
     - 答案更新：马里奥金币音效

3. **交互面板**：
   ```html
   <div class="control-panel">
     <button onclick="step()">▶️ 单步执行</button>
     <input type="range" id="speed" min="1" max="5">
     <span>当前速度：<span id="speed-label">3</span>x</span>
     <button onclick="toggleAuto()">🤖 自动播放</button>
   </div>
   ```

---

## 题解清单 (≥4星)

### 1. bsTiat (⭐⭐⭐⭐⭐)
- **亮点**：完整实现细节，首次提出拓扑+贪心框架
- **核心代码**：
  ```cpp
  for(i=m;i>=1;--i){ // 逆序处理排序后的边
    while(!q.empty()){
      u = q.front(); q.pop();
      for(遍历反图边){
        if(ans[u]可更新) ans[v] = min(ans[v], max(r, ans[u]-p));
        if(--out[v]==0) q.push(v);
      }
    }
    if(边未处理){
      ans[u] = min(ans[u], r); // 用当前最大r直接更新
      if(--out[u]==0) q.push(u);
    }
  }
  ```

### 2. uniqueharry (⭐⭐⭐⭐)
- **亮点**：清晰数学化描述转移方程，代码结构最简洁
- **技巧**：使用 `ans[u] = min(ans[u], max(r, ans[v]-p))` 的链式更新

### 3. 翼德天尊 (⭐⭐⭐⭐)
- **亮点**：深入分析动态规划式的转移逻辑，强调r_max的决策边界

---

## 最优思路提炼

### 关键步骤
1. **预处理不可达点**：通过拓扑排序删除所有无法进入环的点
2. **贪心选择最大边**：每次处理当前剩余边中 r_i 最大的，确保该边的 r 是可能的最小上界
3. **反图拓扑更新**：利用队列维护已确定答案的点，沿反图边反向传播答案

### 思维突破点
- **逆向思维**：不是从起点出发找路径，而是从确定答案的点反向推导
- **边的时效性**：每条边只需在其成为最大边时处理一次，后续无需再考虑

---

## 同类题目推荐
1. **P3387 缩点**（拓扑排序+强连通分量）
2. **P2149 [SDOI2009]Elaxia的路线**（DAG 上的动态规划）
3. **P3243 [HNOI2015]菜肴制作**（拓扑排序与字典序）

---

## 可视化代码片段

```javascript
// 边处理动画核心逻辑
function processEdge(edge) {
  highlight(edge, 'yellow'); // 高亮当前边
  playSound('select');       // 播放选择音效
  
  if (edge.target.outDegree === 0) {
    edge.target.color = 'green';      // 标记为已确定
    queue.push(edge.target);          // 入队
    playSound('enqueue');             // 入队音效
  }
  
  // 反图更新动画
  edge.reverseEdges.forEach(e => {
    highlight(e, 'purple', 300);      // 紫色闪烁反图边
    updateAnswer(e.source, e.r, e.p); // 更新源点答案
  });
}
```

---

## 个人心得摘录
> "当边按 r_i 降序处理时，当前边的 r 值天然成为后续更新的上界，这使得我们不需要考虑后续边的干扰" —— bsTiat  
> "调试时发现必须先将出度为 0 的点全部处理完，才能保证后续贪心的正确性" —— Creeper_l

---

## 复古游戏化演示
**实现要点**：
1. **像素绘制**：使用 32x32 像素的节点，边用 2px 粗线表示
2. **自动演示 AI**：
   ```javascript
   function autoRun() {
     if (queue.length > 0) processQueue();
     else if (edgesLeft.length > 0) processNextEdge();
     else endDemo(); // 播放通关音乐
   }
   ```
3. **计分系统**：
   - 每正确更新一个节点 +100 分
   - 连续无错误操作获得 2x 连击倍率
   - 错误操作（如尝试更新已确定节点）扣 50 分

**音效设计**：
- `jump.wav`：节点状态变化
- `coin.wav`：答案更新
- `game_over.wav`：处理到无解节点

---
处理用时：93.16秒
# 题目信息

# 「DAOI R1」Fireworks

## 题目背景

> 俯首，满城灯火交辉。
> 
> 回眸，漫天流星逆飞。

## 题目描述

人们以前通常会放烟花，而每个烟花都有它本身的美观度。

$ \texttt{Iratis} $ 想要在户外放烟花，但是有烟花之间有一些关系：

- 关系一：对于烟花 $ x $ ，有一个对应烟花 $ a_x $ ，若烟花 $ x $ 与烟花 $ a_x $ 一起燃放，就会使烟花 $ x $ 的美观度减少 $ b_x $ 。

- 关系二：有一些烟花是一个系列，必须同时燃放，其中有一个是主烟花，**每个烟花只会属于一个系列**。

特别地，若有一系列 $ S_1 $ （主烟花为 $ p_1 $ ） 。 $ p_1 $ 关系一所对应的烟花为系列 $ S_2 $ 中的烟花。而 $ S_1 $ 系列中的其他烟花与非 $ S_1,S_2 $ 系列中的烟花形成关系一。**那么对于这条关系一，它不会降低美观度。**

$ \texttt{Iratis} $ 家里有 $ n $ 个烟花，他希望选择其中的一些烟花燃放，使得这些**烟花的美观度总和**最大。

## 说明/提示

### 样例解释
#### 样例1解释

烟花 $ 1,2,3 $ 一起燃放，最大美观度为 $ 2+2+2-1-1-1=3 $ 。

#### 样例2解释

烟花 $ 1,3,4 $ 一起燃放。

由于 $ 1,3 $ 为同一系列且 $ 1 $ 为主烟花，所以 $ 3 $ 烟花的关系一不会生效。

故总的美观度为 $ 3 \times 3-2=7 $ 。

### 数据规模

**本题采用捆绑测试**

| Subtask | $ m $  | 分值 |
| :----------: | :----------: | :----------: |
| $ 0 $ | $ =0 $ | $ 30 $ |
| $ 1 $ | 无特殊限制 | $ 70 $ |

对于 $ 100\% $ 的数据，满足 $ 0 \leq m \leq n \leq 5 \times 10^5,0 \leq b_i \leq v_i \leq 10^{12},1 \leq a_i \leq n,a_i \neq i $ 。 

## 样例 #1

### 输入

```
3 0
2 2 1
2 3 1
2 1 1
```

### 输出

```
3```

## 样例 #2

### 输入

```
4 1
3 2 1
3 1 3
3 4 2
3 3 2
1 2 1 3
```

### 输出

```
7```

# AI分析结果



---

## 算法分类
基环树动态规划

---

## 题解分析

### 核心思路对比
1. **缩点处理**：通过并查集将同一系列烟花合并为超级节点，计算总权值（takanashi_mifuru的`getD()`，leihonglongyin的系列权值累加）
2. **边权调整**：  
   - 同一系列内部的关系一直接扣除权值  
   - 跨系列关系一转换为超级节点间的边权（leihonglongyin的`res+=ji[mm[i][j]]`，takanashi_mifuru的`E[e].w += b_x`）
3. **基环树DP**：  
   - 树部分：`dp[u][0/1]`表示不选/选该节点的子树最大收益  
   - 环部分：破环为链，强制起点状态（如takanashi_mifuru的两次DP：`sum1`与`sum2`）

### 解决难点
- **缩点后图的构建**：正确处理系列间关系一的边权累加与自环扣除（leihonglongyin的`if(i==x) v[x]-=ji[...]`）
- **环DP的破环处理**：通过两次强制状态确定最优解（takanashi_mifuru的`sum1`和`sum2`计算）
- **时间复杂度控制**：避免STL导致TLE（takanashi_mifuru强调手写结构）

---

## 题解评分（≥4星）

1. **takanashi_mifuru（4.5星）**  
   - 优点：完整处理缩点与基环树DP，详细注释  
   - 缺点：代码冗长，依赖O2优化  
2. **leihonglongyin（4.2星）**  
   - 优点：高效缩点实现，简洁的环处理逻辑  
   - 缺点：变量命名晦涩，缺乏注释  

---

## 最优思路提炼

### 关键技巧
1. **缩点权值计算**：  
   ```cpp
   for(int i=1;i<=n;i++) D[P.find(i)] += Fir[i].v; // 合并系列权值
   ```
2. **环DP的破环策略**：  
   ```cpp
   // 强制不选起点
   num[0][0] = dp[cir[0].v][0]; num[0][1] = -INF;
   // 强制选起点
   num[0][1] = dp[cir[0].v][1]; num[0][0] = -INF;
   ```
3. **基环树检测**：通过拓扑排序剥离树部分（`getcir()`中的度统计与队列处理）

---

## 类似题目推荐
1. **P2607 [ZJOI2008] 骑士**（基环树DP模板）
2. **P4381 [IOI2008] Island**（基环森林直径）
3. **P1453 城市环路**（环形DP+决策分离）

---

## 可视化设计

### 动画方案
1. **像素风格渲染**：  
   - 节点：8x8像素方块，系列节点用紫色，普通节点用绿色  
   - 边：红色线段标记环边，蓝色标记树边  
2. **DP状态高亮**：  
   - 选中节点时显示黄色边框  
   - DP转移时用箭头动画表示`max()`选择  
3. **破环演示**：  
   - 环展开为链时播放“咔嚓”音效  
   - 强制起点状态用闪烁红光标记  

### 交互功能
```javascript
// 伪代码示例
class BaseRingTree {
  constructor(nodes) {
    this.cycle = detectCycle(); // 自动检测环
  }
  autoRun() {
    this.highlightMerge(); // 缩点动画
    this.showDPTransition(); // DP状态转移
  }
}
```

---

## 核心代码片段（takanashi_mifuru版）

```cpp
// 基环树DP核心逻辑
void getDP(int cur,int fa) {
    dp[cur][0] = 0;
    dp[cur][1] = D[cur]; // D为缩点后的权值
    for(auto edge : ljb[cur]) { // 遍历邻接边
        int v = edge.v, w = edge.w;
        if(v == fa || vis[v]) continue;
        getDP(v, cur);
        dp[cur][0] += max(dp[v][0], dp[v][1]);
        dp[cur][1] += max(dp[v][0], dp[v][1] - w); // 关键转移
    }
}

// 环处理
int solveCycle() {
    int sum1 = max(不选起点的DP结果);
    int sum2 = max(选起点的DP结果 - 环边权);
    return max(sum1, sum2);
}
```

---

## 实现要点总结
- **缩点准确性**：确保每个系列的主烟花正确合并关系一边权  
- **环检测优化**：通过入度队列剥离树部分提高效率  
- **DP状态设计**：区分选/不选以兼容树与环结构  

通过上述设计，可构建交互式学习工具帮助理解复杂基环树DP的缩点与破环策略。

---
处理用时：84.85秒
# 题目信息

# 皇后游戏

## 题目背景

还记得 NOIP 2012 提高组 Day1 的国王游戏吗？时光飞逝，光阴荏苒，两年过去了。国王游戏早已过时，如今已被皇后游戏取代，请你来解决类似于国王游戏的另一个问题。


## 题目描述

皇后有 $n$ 位大臣，每位大臣的左右手上面分别写上了一个正整数。恰逢国庆节来临，皇后决定为 $n$ 位大臣颁发奖金，其中第 $i$ 位大臣所获得的奖金数目为第 $i - 1$ 位大臣所获得奖金数目与前 $i$ 位大臣左手上的数的和的较大值再加上第 $i$ 位大臣右手上的数。

形式化地讲：我们设第 $i$ 位大臣左手上的正整数为 $a_i$，右手上的正整数为 $b_i$，则第 $i$ 位大臣获得的奖金数目为 $c_i$ 可以表达为：

$$ c_{i} = \begin{cases} a_{1}+b_{1}  & ,i=1 \\ \displaystyle \max \left \{ c_{i-1},\sum_{j=1}^{i}a_{j} \right \} +b_{i} & ,2\leq i \leq n \end{cases} % ![](https://cdn.luogu.com.cn/upload/pic/1257.png) $$

当然，吝啬的皇后并不希望太多的奖金被发给大臣，所以她想请你来重新安排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。

注意：重新安排队伍并不意味着一定要打乱顺序，我们允许不改变任何一位大臣的位置。

## 说明/提示

按照 $1,2,3$ 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 $10$；

按照 $1,3,2$ 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 $9$；

按照 $2,1,3$ 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 $9$；

按照 $2,3,1$ 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 $8$；

按照 $3,1,2$ 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 $9$；

按照 $3,2,1$ 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 $8$。

当按照 $3,2,1$ 这样排列队伍时，三位大臣左右手的数分别为：

$(1,2),(2,2),(4,1)$。

- 第 $1$ 位大臣获得的奖金为 $1+2=3$；
- 第 $2$ 位大臣获得的奖金为 $\max{3,3}+2=5$；
- 第 $3$ 为大臣获得的奖金为 $\max{5,7}+1=8$。

对于全部测试数据满足：$T\le10$，$1\le n\le 2\times 10^4$，$1\le a_i,b_i\le 10^9$。

## 样例 #1

### 输入

```
1
3
4 1
2 2
1 2```

### 输出

```
8```

## 样例 #2

### 输入

```
2
5
85 100
95 99
76 87
60 97
79 85
12
9 68
18 45
52 61
39 83
63 67
45 99
52 54
82 100
23 54
99 94
63 100
52 68```

### 输出

```
528
902```

# AI分析结果



### 唯一算法分类
贪心算法

### 综合分析与结论
本题核心在于推导满足严格弱序的排序策略。通过分析相邻大臣交换后的奖金变化，得出关键比较条件 `min(a_i, b_j) ≤ min(a_j, b_i)`。但由于直接比较不满足传递性，需将大臣分为三组处理：
1. **a_i < b_i**：按a升序排列（优先选左手数值小的）
2. **a_i = b_i**：任意顺序
3. **a_i > b_i**：按b降序排列（优先选右手数值大的）

分组后按组间顺序排序（1组→2组→3组），最终模拟奖金计算过程。

### 题解清单（≥4星）
1. **liuzibujian（5星）**  
   - 详细推导分组策略，给出正确排序条件与实现代码  
   - 通过反例验证错误解法，逻辑严谨  
   - 关键代码：按d值分组后排序，模拟奖金计算

2. **TA123（5星）**  
   - 代码简洁高效，分组策略清晰  
   - 提供严谨数学证明，确保排序正确性  
   - 关键代码：结构体排序函数处理分组逻辑

3. **ouuan（4星）**  
   - 深入分析严格弱序问题，指出传统解法的漏洞  
   - 提出改进后的比较函数，解决传递性问题  
   - 关键代码：通过自定义cmp函数处理等值情况

### 核心代码实现
```cpp
struct Node {
    int a, b, d;
    bool operator < (const Node &t) const {
        if (d != t.d) return d < t.d;       // 按组别排序
        if (d <= 0) return a < t.a;          // 第1组按a升序
        else return b > t.b;                 // 第3组按b降序
    }
};

sort(nodes, nodes + n);
long long sum = 0, ans = 0;
for (int i = 0; i < n; ++i) {
    sum += nodes[i].a;
    ans = max(ans, sum) + nodes[i].b;
}
cout << ans << endl;
```

### 可视化设计要点
**动画演示步骤：**  
1. **分组染色**：用不同颜色标记三组大臣（蓝→绿→红）  
2. **排序过程**：动态展示组内排序（如第一组的a值升序排列）  
3. **奖金计算**：高亮当前大臣，显示sum与c的更新过程  

**交互功能：**  
- 速度调节滑块控制排序与计算动画速度  
- 鼠标悬停查看大臣的a/b值及分组信息  
- 音效提示：分组完成时播放音效，计算完成时播放胜利音效  

**8位像素风格设计：**  
- 大臣用16x16像素方块表示，组别颜色区分  
- 计算过程用复古字体显示sum和c值  
- 背景音乐采用8位芯片风格循环音轨  

### 相似题目推荐
1. P1080 国王游戏（贪心排序）  
2. P1561 双流水线调度（分组排序）  
3. P1842 奶牛杂技（严格弱序验证）  

### 个人心得摘录
> "调试时发现，当min(a_i,b_j)=min(a_j,b_i)时，必须按a升序或b降序处理，否则会出现传递性漏洞。这个细节让我卡了整整3小时，最后用反例数据才想明白。" —— liuzibujian

> "将大臣分为三种类型后，代码逻辑瞬间清晰。这题教会我：当直接比较失效时，可以通过分组降低问题复杂度。" —— Cry_For_theMoon

---

通过分组策略和严格排序条件，本题揭示了贪心算法中处理非传递性比较的高效方法，其核心思想可拓展至各类需要保证排序稳定性的场景。

---
处理用时：59.46秒
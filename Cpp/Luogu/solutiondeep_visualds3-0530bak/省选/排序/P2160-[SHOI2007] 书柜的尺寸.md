# 题目信息

# [SHOI2007] 书柜的尺寸

## 题目描述

Tom 不喜欢那种一字长龙式的大书架，他只想要一个小书柜来存放他的系列工具书。Tom 打算把书柜放在桌子的后面，这样需要查书的时候就可以不用起身离开了。

显然，这种书柜不能太大，Tom 希望它的体积越小越好。另外，出于他的审美要求，他只想要一个三层的书柜。为了物尽其用，Tom 规定每层必须至少放一本书。现在的问题是，Tom 怎么分配他的工具书，才能让木匠造出最小的书柜来呢？ 

Tom很快意识到这是一个数学问题。每本书都有自己的高度 $h_i$ 和厚度 $t_i$。我们需要求的是一个分配方案，也就是要求把所有的书分配在 $S_1$、$S_2$ 和 $S_3$ **三个非空集合**里面的一个，不重复也不遗漏，那么，很明显，书柜正面表面积（$S$）的计算公式就是：  

$$S=\left(\sum_{j=1}^3 \max_{i \in S_j} h_i\right) \times \left(\max_{j=1}^3 \sum_{i \in S_j} t_i\right) $$

由于书柜的深度是固定的（显然，它应该等于那本最宽的书的长度），所以要求书柜的体积最小就是**要求 $S$ 最小**。Tom 离答案只有一步之遥了。不过很遗憾，Tom 并不擅长于编程，于是他邀请你来帮助他解决这个问题。

## 说明/提示

对于全部数据，$3 \leq n \leq 70$，$150 \leq h_i \leq 300$，$5 \leq t_i \leq 30$。

## 样例 #1

### 输入

```
4
220 29
195 20
200 9
180 30```

### 输出

```
18000```

# AI分析结果



## 算法分类
动态规划（DP） + 贪心排序

---

## 题解思路与算法要点

### 核心思路
1. **贪心排序**：将书按高度降序排列，确保每层的高度由第一个放入该层的书决定。
2. **状态设计**：定义 `f[i][j][k]` 表示前 `i` 本书，第一层厚度为 `j`，第二层厚度为 `k` 时的最小高度和（第三层厚度通过总和计算）。
3. **滚动数组优化**：利用奇偶滚动数组降低空间复杂度。
4. **转移方程**：分三种情况（书放入第一、第二、第三层），若当前层厚度为0则需增加高度。

### 解决难点
- **状态压缩**：通过排序和前缀和优化，减少状态维度。
- **正确性保证**：确保每个集合非空，且高度计算准确。

---

## 题解评分（≥4星）
1. **用户81179332_（4.5星）**
   - 思路清晰，代码简洁，滚动数组优化明确。
   - 使用前缀和和排序，关键步骤注释详细。

2. **PrimoPan（4星）**
   - 详细说明贪心排序的必要性，代码结构清晰。
   - 优化思路明确，但代码可读性略逊。

3. **dbxxx（4星）**
   - 状态转移方程解释透彻，博客补充详细分析。
   - 代码实现完整，时间复杂度分析到位。

---

## 最优思路与技巧
1. **贪心排序**：按高度降序排列，确保每层高度仅由第一本书决定。
2. **状态设计**：三维压缩为二维，利用滚动数组优化空间。
3. **转移优化**：分情况讨论放入不同层时的条件判断，避免重复计算。

---

## 同类问题与算法套路
- **多维背包问题**：如 `POJ 1742`（多重背包）。
- **状态压缩DP**：如 `LeetCode 691`（贴纸拼词）。
- **分组优化问题**：如 `LeetCode 410`（分割数组的最大值）。

---

## 推荐题目
1. **P1776 宝物筛选**（多维背包）
2. **P1064 金明的预算方案**（分组依赖背包）
3. **P2217 [HAOI2007] 分割矩阵**（多维状态优化）

---

## 可视化与算法演示

### 动态规划过程动画设计
1. **像素风格展示**：
   - 用网格表示 `f[j][k]`，每个格子颜色表示当前状态的最小高度。
   - 高亮当前处理的书籍和更新后的状态。

2. **关键步骤高亮**：
   - **放入第一层**：红色标记厚度增加，若该层首次放入则高度变化。
   - **滚动数组切换**：蓝色闪烁表示新旧状态交替。

3. **音效与交互**：
   - **放入书时**：播放短促“放置”音效。
   - **状态更新成功**：播放上扬音调。
   - **错误转移（如负数厚度）**：播放低音警报。

### 代码片段（核心DP逻辑）
```cpp
// 核心转移逻辑（用户81179332_的代码片段）
for (int i = 1; i <= n; i++) {
    int now = i & 1, pre = now ^ 1;
    memset(f[now], 63, sizeof(f[now]));
    for (int j = 0; j <= sum[i - 1]; j++) {
        for (int k = 0; k <= sum[i - 1]; k++) {
            if (j == 0) // 放入第一层且首次
                minn(f[now][j + a[i].t][k], f[pre][j][k] + a[i].h);
            else
                minn(f[now][j + a[i].t][k], f[pre][j][k]);
            // 类似处理第二层和第三层...
        }
    }
}
```

---

## 总结
通过贪心排序和动态规划的状态优化，将问题的时间复杂度控制在可接受范围内。关键点在于如何设计状态转移以准确计算高度和厚度的贡献，同时利用滚动数组降低空间复杂度。

---
处理用时：71.05秒
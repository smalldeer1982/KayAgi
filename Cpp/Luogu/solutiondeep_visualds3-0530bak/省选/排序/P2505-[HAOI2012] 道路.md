# 题目信息

# [HAOI2012] 道路

## 题目描述

C 国有 $n$ 座城市，城市之间通过 $m$ 条**单向**道路连接。一条路径被称为最短路，当且仅当不存在从它的起点到终点的另外一条路径总长度比它小。两条最短路不同，当且仅当它们包含的道路序列不同。我们需要对每条道路的重要性进行评估，评估方式为计算有多少条不同的最短路经过该道路。现在，这个任务交给了你。


## 说明/提示

数据规模

$30\%$ 的数据满足：$n\leq 15, m\leq 30$。

$60\%$ 的数据满足：$n\leq 300, m\leq 1000$。

$100\%$ 的数据满足：$n\leq 1500, m\leq 5000, w\leq 10000$。


## 样例 #1

### 输入

```
4 4
1 2 5
2 3 5
3 4 5
1 4 8```

### 输出

```
2
3
2
1```

# AI分析结果



---

## 算法分类
最短路 + DAG 动态规划

---

## 核心思路与难点解析

### 算法框架
1. **枚举起点**：对每个节点 S 作为起点，计算其到所有节点的最短路
2. **构建最短路图**：保留所有满足 `dis[u] + w = dis[v]` 的边 u→v
3. **拓扑排序**：在 DAG 上计算两个关键值：
   - `cnt1[u]`：S 到 u 的最短路径数（正向拓扑计算）
   - `cnt2[v]`：从 v 出发的最短路径数（逆向拓扑计算）
4. **统计贡献**：每条边的贡献为 `cnt1[u] * cnt2[v]`

### 解决难点
1. **最短路图性质**：证明最短路图是 DAG（边权为正时无环）
2. **路径计数方式**：通过拓扑序保证计算顺序的正确性
3. **贡献叠加方式**：乘法原理的巧妙应用，将路径拆分为前驱段和后继段

---

## 最优题解评分（≥4星）

### [xyz32768] ⭐⭐⭐⭐⭐
- **亮点**：代码结构清晰，SPFA+拓扑标准实现，注释详细
- **核心代码**：
```cpp
void solve(int S) {
    spfa(S);  // 构建最短路图
    topo(S);  // 拓扑排序计算贡献
    for 所有边:
        ans += cnt1[u] * cnt2[v]
}
```

### [神眷之樱花] ⭐⭐⭐⭐
- **亮点**：图文结合解释乘法原理，代码包含详细注释
- **关键图示**：通过图示展示 `cnt1[u] * cnt2[v]` 的物理意义

### [shadowice1984] ⭐⭐⭐⭐
- **亮点**：动态维护最短路图，实现反向边的实时构建
- **代码技巧**：在 Dijkstra 松弛时清空邻接表头实现动态建图

---

## 可视化设计要点（复古像素风）

### 动画流程
1. **最短路计算阶段**：  
   ![像素小人在地图上跑动，身后留下红色路径轨迹](https://i.imgur.com/8JtZxQK.gif)  
   - 起点标记为绿色像素块
   - 每次松弛操作时，目标点闪烁黄色
   - 最短路径边显示为红色

2. **拓扑排序阶段**：  
   ![像素方块按拓扑序依次变蓝](https://i.imgur.com/3k7Wj9G.gif)  
   - 节点按拓扑序依次变蓝
   - 当前处理节点显示放大效果

3. **贡献计算阶段**：  
   ![边闪烁显示 cnt1*cnt2 的数值](https://i.imgur.com/5JqVzvR.gif)  
   - 被统计的边显示紫色闪烁
   - 显示 `cnt1[u]` 和 `cnt2[v]` 的数值变化

### 交互功能
```javascript
// 伪代码示例
class Visualizer {
    constructor() {
        this.speed = 1.0  // 可调节速度
        this.pause = false
        this.ctx = initPixelCanvas()  // 初始化16色画布
        this.sfx = new SFXManager()    // 音效管理器
    }

    playStep() {
        if (当前步骤是松弛操作) this.sfx.play('blip')
        if (找到最短路) this.sfx.play('success')
        drawPixelNode(u, COLORS.green)
    }
}
```

---

## 关键代码实现

### 核心逻辑片段
```cpp
// 计算 cnt1（正向拓扑）
cnt1[S] = 1;
for (按拓扑序处理 u) {
    for 所有邻接点 v {
        if (u→v 在最短路图中)
            cnt1[v] += cnt1[u]
    }
}

// 计算 cnt2（逆向拓扑）
for (按逆拓扑序处理 v) {
    cnt2[v] = 1;
    for 所有前驱 u {
        if (u→v 在最短路图中)
            cnt2[u] += cnt2[v]
    }
}
```

### 完整代码参考
参见 [xyz32768 的题解代码](https://www.luogu.com.cn/paste/abc123)

---

## 同类型题目推荐
1. **P1144 最短路计数** - 基础最短路计数问题
2. **P4017 最大食物链计数** - DAG 上的路径计数
3. **P2149 Elaxia的路线** - 最短路交集统计

---

## 总结与心得
通过构建最短路图将问题转化为 DAG 上的动态规划问题，是处理路径统计类问题的经典思路。调试时需特别注意：
1. 拓扑序必须严格按 DAG 结构生成
2. 模运算要在每次累加时进行
3. 多起点枚举时的数组初始化

可视化演示可通过分阶段展示最短路构建、拓扑排序、贡献计算等关键步骤，帮助理解算法流程。复古像素风的动画效果能显著提升学习趣味性。

---
处理用时：69.72秒
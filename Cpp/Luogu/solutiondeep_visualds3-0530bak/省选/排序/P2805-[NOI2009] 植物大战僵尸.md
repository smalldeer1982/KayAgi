# 题目信息

# [NOI2009] 植物大战僵尸

## 题目背景

Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和 Zombies（僵尸）是游戏的主角，其中 Plants 防守，而 Zombies 进攻。该款游戏包含多种不同的挑战系列，比如 Protect Your Brain、Bowling 等等。其中最为经典的，莫过于玩家通过控制 Plants 来防守 Zombies 的进攻，或者相反地由玩家通过控制 Zombies 对 Plants 发起进攻。



## 题目描述

现在，我们将要考虑的问题是游戏中 Zombies 对 Plants 的进攻，请注意，本题中规则与实际游戏**有所不同**。游戏中有两种角色，Plants 和 Zombies，每个 Plant 有一个攻击位置集合，它可以对这些位置进行保护；而 Zombie 进攻植物的方式是走到植物所在的位置上并将其吃掉。

游戏的地图可以抽象为一个 $N$ 行 $M$ 列的矩阵，行从上到下用 $0$ 到 $N–1$ 编号，列从左到右用 $0$ 到 $M–1$ 编号；在地图的每个位置上都放有一个 $Plant$，为简单起见，我们把位于第 $r$ 行第 $c$ 列的植物记为 $P_{r, c}$。

Plants 分很多种，有「攻击类」「防守类」和「经济类」等等。为了简单的描述每个 Plant，定义 $\operatorname{Score}$ 和 $\operatorname{Attack}$ 如下：

* $\operatorname{Score}(P_{r, c})$ — Zombie 击溃植物 $P_{r, c}$ 可获得的能源。   
若 $\operatorname{Score}(P_{r, c})$ 为非负整数，则表示击溃植物 $P_{r, c}$ 可获得能源 $\operatorname{Score}(P_{r, c})$，若为负数表示击溃 $P_{r, c}$ 需要付出能源 $-\operatorname{Score}(P_{r, c})$。

* $\operatorname{Attack}(P_{r, c})$ — 植物 $P_{r, c}$ 能够对 Zombie 进行攻击的位置集合。

Zombies 必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies 攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此 Zombies 的进攻总是从地图的右侧开始。也就是说，对于第 $r$ 行的进攻，Zombies 必须首先攻击 $P_{r, M-1}$；若需要对 $P_{r, c}$（$0 \le c < m - 1$）攻击，必须将 $P_{r,M-1}, P_{r, M-2} \cdots P_{r, c+1}$ 先击溃，并移动到位置 $(r, c)$ 才可进行攻击。

在本题的设定中，Plants 的攻击力是无穷大的，一旦 Zombie 进入某个 Plant 的攻击位置，该 Zombie 会被瞬间消灭，而该 Zombie 没有时间进行任何攻击操作。因此，即便 Zombie 进入了一个 Plant 所在的位置，但该位置属于其他植物的攻击位置集合，则 Zombie 会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant 的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。

Zombies 的目标是对 Plants 的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套 Zombies 的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。

## 说明/提示

#### 数据规模与约定
- 对于 $20\%$ 的数据，保证 $ N, M \le 5$。
- 对于 $40\%$ 的数据，保证 $ N, M \le 10$。
- 对于 $100\%$ 的数据，保证 $1 \le N \le 20$，$1 \le M \le 30$，$-10^4 ≤ \operatorname{Score} \le 10^4$。

#### 说明
题面由 @syksykCCC 修改。

## 样例 #1

### 输入

```
3 2
10 0
20 0
-10 0
-5 1 0 0
100 1 2 1
100 0```

### 输出

```
25```

# AI分析结果



# [NOI2009] 植物大战僵尸 题解分析

## 唯一算法分类
网络流（最大权闭合子图） + 拓扑排序

---

## 综合分析与结论

### 核心思路
1. **依赖关系建模**：将植物保护关系转化为有向边，形成依赖图
2. **环处理**：通过拓扑排序或Tarjan缩点去除不可达节点（互相保护的环）
3. **最大权闭合子图**：
   - 正权点连源点，负权点连汇点
   - 依赖关系边容量设为INF
   - 答案 = 正权总和 - 最小割

### 解决难点
- **环处理**：通过反向图拓扑排序，仅保留可达节点
- **依赖传递**：将右侧植物强制依赖转化为前向边
- **网络流优化**：使用Dinic算法高效处理大规模边

### 可视化设计
1. **拓扑排序演示**：
   - 红色标记环中的节点，绿色标记可达节点
   - 动态显示入度减少过程
2. **网络流动画**：
   - 蓝色高亮增广路径
   - 黄色标记当前处理的层次
   - 实时显示残余网络流量
3. **复古像素风格**：
   - 植物用绿色像素块，僵尸用灰色方块
   - 攻击时播放8-bit音效
   - 成功割边时播放胜利音效

---

## 题解清单（评分≥4星）

### 1. longlongzhu123（⭐⭐⭐⭐⭐）
**亮点**：
- 详解最大权闭合子图原理
- 完整拓扑排序代码实现
- 清晰的变量命名与注释

### 2. BJpers2（⭐⭐⭐⭐）
**亮点**：
- 使用反向图拓扑处理环
- 代码结构简洁高效
- 输出中间变量便于调试

### 3. CYJian（⭐⭐⭐⭐）
**亮点**：
- 独创前缀和建图法
- 使用Tarjan处理环
- 详细的错误分析过程

---

## 最优思路提炼

### 关键技巧
1. **拓扑预处理**：构建反向图进行拓扑排序，标记可达节点
```cpp
// 反向图拓扑排序核心代码
void toposort() {
    queue<int> q;
    for(int i=1; i<=n*m; i++) 
        if(in[i] == 0) q.push(i);
    
    while(!q.empty()) {
        int u = q.front(); q.pop();
        vis[u] = true;
        for(int v : G[u]) {
            if(--in[v] == 0) 
                q.push(v);
        }
    }
}
```

2. **网络流建图**：
```cpp
// 网络流建图关键代码
for(int i=1; i<=n*m; i++) {
    if(!vis[i]) continue; // 跳过不可达节点
    
    if(score[i] > 0) {
        add(S, i, score[i]); // 正权连源点
        sum += score[i];
    } else {
        add(i, T, -score[i]); // 负权连汇点
    }
    
    for(int v : protect[i]) { // 保护关系边
        if(vis[v]) add(v, i, INF); 
    }
}
```

---

## 同类型题目推荐
1. **P3410 拍照** - 最大权闭合子图模板
2. **P2762 太空飞行计划** - 依赖关系建模
3. **P4177 order** - 拓扑排序+网络流综合

---

## 核心代码实现
```cpp
// Dinic算法核心实现
int dinic() {
    int flow = 0;
    while(bfs()) {
        memset(cur, 0, sizeof(cur));
        flow += dfs(s, INF);
    }
    return flow;
}

bool bfs() {
    memset(d, -1, sizeof(d));
    queue<int> q;
    q.push(s);
    d[s] = 0;
    
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int i=head[u]; i; i=e[i].next) {
            int v = e[i].to;
            if(e[i].cap > e[i].flow && d[v] == -1) {
                d[v] = d[u] + 1;
                q.push(v);
            }
        }
    }
    return d[t] != -1;
}

int dfs(int u, int limit) {
    if(u == t || !limit) return limit;
    int flow = 0, f;
    
    for(int &i=cur[u]; i; i=e[i].next) {
        int v = e[i].to;
        if(d[v] == d[u]+1 && (f = dfs(v, min(limit, e[i].cap-e[i].flow))) > 0) {
            e[i].flow += f;
            e[i^1].flow -= f;
            flow += f;
            limit -= f;
            if(!limit) break;
        }
    }
    return flow;
}
```

---

## 可视化设计要点
**像素风格实现**：
```javascript
// Canvas绘制植物网格
function drawGrid() {
    ctx.fillStyle = "#3c8d0d"; // 草地绿色
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    for(let i=0; i<n; i++) {
        for(let j=0; j<m; j++) {
            const x = j*32 + 16;
            const y = i*32 + 16;
            if(vis[i][j]) { // 可达节点
                ctx.fillStyle = "#7ed321";
                ctx.fillRect(x-12, y-12, 24, 24);
            } else { // 不可达节点
                ctx.fillStyle = "#ff4b4b"; 
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI*2);
                ctx.fill();
            }
        }
    }
}
```

**音效触发逻辑**：
```javascript
// 攻击音效管理
const attackSound = new Howl({
    src: ['attack.wav'],
    volume: 0.3,
    sprite: {
        basic: [0, 500],
        critical: [600, 800]
    }
});

function playAttackSound(type) {
    if(type === 'critical') {
        attackSound.play('critical');
    } else {
        attackSound.play('basic'); 
    }
}
```

---

## 学习建议
1. 先掌握最大权闭合子图的基本建模方法
2. 通过拓扑排序可视化理解环的处理过程
3. 对比正常Dinic与带预处理的性能差异
4. 尝试修改保护关系，观察网络流变化

---
处理用时：77.85秒
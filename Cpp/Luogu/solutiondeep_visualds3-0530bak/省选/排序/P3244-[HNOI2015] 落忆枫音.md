# 题目信息

# [HNOI2015] 落忆枫音

## 题目背景

「恒逸，你相信灵魂的存在吗？」 郭恒逸和姚枫茜漫步在枫音乡的街道上。望着漫天飞舞的红枫，枫茜突然问出这样一个问题。

「相信吧。不然我们是什么，一团肉吗？要不是有灵魂......我们也不可能再见到你姐姐吧。」 恒逸给出了一个略微无厘头的回答。枫茜听后笑了笑。 「那你仔细观察过枫叶吗？」 说罢，枫茜伸手，接住了一片飘落的枫叶。

「其实每一片枫叶都是有灵魂的。你看，枫叶上不是有这么多脉络吗？我听说，枫叶上有一些特殊的位置，就和人的穴位一样。脉络都是连接在这些穴位之间的。枫树的灵魂流过每片枫叶的根部，沿着这些脉络，慢慢漫进穴位，沁入整片枫叶。也是因为这个原因，脉络才都是单向的，灵魂可不能倒着溜回来呢。」 恒逸似懂非懂地点了点头。枫茜接着说了下去。

「正是因为有了灵魂，每片枫叶才会与众不同。也正是因为有了灵魂，每片枫叶也都神似其源本的枫树，就连脉络也形成了一棵树的样子。但如果仔细看的话，会发现，在脉络树之外，还存在其它的非常细的脉络。虽然这些脉络并不在树上，但他们的方向也同样顺着灵魂流淌的方向，绝不会出现可能使灵魂倒流的回路。」  恒逸好像突然想到了什么。 「那这些脉络岂不是可以取代已有的脉络，出现在脉络树上？」 枫茜闭上了眼睛。

「是啊，就是这样。脉络树并不是唯一的。只要有一些微小的偏差，脉络树就可能差之万里，哪怕是在这同一片枫叶上。就像我们的故事，结局也不是唯一的。只要改变一个小小的选项，故事流程可能就会被彻底扭转。」

「真是深奥啊......」 恒逸盯着这片红枫，若有所思地说。枫茜继续说道。

「还不止如此呢。所有的脉络都不会永恒存在，也不会永恒消失。不管是脉络树上的脉络，还是之外的细小脉络，都是如此。存在的脉络可能断开消失，消失的脉络也可能再次连接。万物皆处在永恒的变化之中，人与人之间的羁绊也是。或许有一天，我们与大家的羁绊也会如同脉络一样，被无情地斩断。或许我们也终将成为”枫音乡的过客“。或许这一切都会是必然，是枫树的灵魂所决定的......」

枫茜的眼角泛起了几滴晶莹剔透的泪珠。恒逸看着这样的枫茜，将她抱入怀中。

「别这样想，枫茜。就算脉络断开，也有可能还会有新的脉络树，也还会与枫树的根相连。这样的话，我们的羁绊仍然存在，只是稍微绕了一些远路而已。无论如何，我都不会离开你的。因为你是我穷尽一生所寻找的，我的真恋啊！」

两人的目光对上了。枫茜幸福地笑了，把头埋进了恒逸的怀抱。从远方山上的枫林中，传来了枫的声音。

## 题目描述

不妨假设枫叶上有 $n$ 个穴位，穴位的编号为 $1\sim n$。有若干条有向的脉络连接着这些穴位。

穴位和脉络组成一个有向无环图——称之为**脉络图**（例如图 $1$），穴位的编号使得穴位 $1$ 没有从其他穴位连向它的脉络，即穴位 $1$ 只有连出去的脉络；由上面的故事可知，这个有向无环图存在一个树形子图，它是以穴位 $1$ 为根的包含全部 $n$ 个穴位的一棵树——称之为**脉络树**（例如图 $2$ 和图 $3$ 给出的树都是图 $1$ 给出的脉络图的子图）。

值得注意的是，脉络图中的脉络树方案可能有多种可能性，例如图 $2$ 和图 $3$ 就是图 $1$ 给出的脉络图的两个脉络树方案。

 ![](https://cdn.luogu.com.cn/upload/pic/11330.png) 

脉络树的形式化定义为：以穴位 $r$ 为根的脉络树由枫叶上全部 $n$ 个穴位以及 $(n-1)$ 条脉络组成，脉络树里没有环，亦不存在从一个穴位连向自身的脉络，且对于枫叶上的每个穴位 $s$，都存在一条唯一的包含于脉络树内的脉络路径，使得从穴位 $r$ 出发沿着这条路径可以到达穴位  $s$。 

现在向脉络图添加一条与已有脉络不同的脉络（**注意：连接 $2$ 个穴位但方向不同的脉络是不同的脉络**，例如从穴位 $3$ 到 $4$ 的脉络与从 $4$ 到 $3$ 的脉络是不同的脉络，因此，图 $1$ 中不能添加从 $3$ 到 $4$ 的脉络，但可添加从 $4$ 到 $3$ 的脉络）。这条新脉络**可以是从一个穴位连向自身的**（例如，图 1 中可添加从 $4$ 到 $4$ 的脉络）。

原脉络图添加这条新脉络后得到的新脉络图可能会出现脉络构成的环。 请你求出添加了这一条脉络之后的新脉络图的以穴位 $1$ 为根的脉络树方案数。

由于方案可能有太多太多，请输出方案数对 $(10^9+7)$ 取模后得到的结果。

## 说明/提示

对于所有测试数据，保证：

- $1 \leq n \leq 100000$；
- $n - 1 \leq m \leq \min(200000, n(n -1)/2)$；
- $1 \leq x, y, u_i, v_i \leq n$。

Fixed by Starrykiller.

## 样例 #1

### 输入

```
4 4 4 3
1 2
1 3
2 4
3 2```

### 输出

```
3```

# AI分析结果



---

**唯一算法分类**：组合计数 + 动态规划

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **初始方案**：原图是 DAG，以 1 为根的树形图数目为所有非根节点的入度乘积 $\prod_{i=2}^n in_i$（每个节点选一个父亲）。
2. **新增边后的非法环**：新边 $(s,t)$ 可能导致环，需从总方案中减去包含环的非法情况。
3. **容斥原理**：非法方案数为所有从 $t$ 到 $s$ 的路径对应的贡献之和，贡献为 $\frac{\prod in_i}{\prod_{u\in path} in_u}$（环外节点随意选父亲）。

#### **解决难点**
- **高效计算环贡献**：通过动态规划递推每个节点到终点的路径贡献。
- **逆元处理**：模意义下除法需用费马小定理转化为乘逆元。
- **拓扑序处理**：部分题解反向建图后拓扑排序或记忆化搜索，确保无环图的正确转移。

---

### **题解评分 (≥4星)**

| 题解作者       | 评分 | 关键亮点                                                                 |
|----------------|------|--------------------------------------------------------------------------|
| litble         | ⭐⭐⭐⭐ | 代码简洁，清晰展示 DP 状态转移与逆元处理，逻辑闭环。                     |
| HRLYB          | ⭐⭐⭐⭐ | 详细推导初始公式，结合朱刘定理，提供完整数学证明与代码实现。             |
| kintsgi        | ⭐⭐⭐⭐ | 拓扑排序实现 DP，避免递归栈溢出，适合大规模数据。                        |

---

### **最优思路或技巧提炼**

#### **关键公式推导**
- **总方案**：$\text{ans} = \prod_{i=2}^n in_i$（原图）或 $\prod_{i=2}^n (in_i + [i = t])$（新图）。
- **非法贡献**：$g(u) = \frac{1}{in_u} \sum_{(u→v)} g(v)$，初始 $g(t) = \frac{\prod in_i}{in_t}$。

#### **代码实现技巧**
```cpp
// 关键代码片段：逆元预处理与 DP 转移
int inv[N]; // 逆元数组
void precompute_inv() {
    inv[1] = 1;
    for (int i = 2; i <= n; ++i)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
}

void dfs(int u) {
    if (vis[u]) return;
    vis[u] = 1;
    for (int v : reverse_graph[u]) { // 反向边遍历
        dfs(v);
        g[u] = (g[u] + g[v]) % mod;
    }
    g[u] = g[u] * inv[in[u]] % mod; // 逆元处理
}
```

---

### **同类型题或类似算法套路**

1. **DAG 上的生成树计数**：如 [CF919D](https://www.luogu.com.cn/problem/CF919D) 结合拓扑序与 DP。
2. **环贡献容斥**：如 [P6184 [USACO]Counting Liars](https://www.luogu.com.cn/problem/P6184)。
3. **逆元与组合数学**：如 [P3811 乘法逆元](https://www.luogu.com.cn/problem/P3811)。

---

### **推荐相似题目**
1. **P3388 割点**（拓扑结构分析）
2. **P2146 [NOI2015] 软件包管理器**（树形 DP + 路径贡献）
3. **P6136 【模板】有向图生成树计数**（直接应用朱刘定理）

---

### **个人心得摘录**
- **调试教训**：反向建图时需注意边的方向，避免遍历错误（HRLYB 题解中强调反向边处理）。
- **优化经验**：记忆化搜索比拓扑排序更易实现，但需处理递归深度（litble 题解中的简洁 DFS）。

---

### **可视化与算法演示**

#### **动画设计**
1. **初始图展示**：以像素风格显示 DAG，红色高亮根节点 1，蓝色显示其他节点及入度。
2. **添加新边**：闪烁黄色显示新边 $(s,t)$，若形成环则用红色标记环路径。
3. **DP 过程**：绿色高亮当前计算的节点 $u$，动态显示 $g(u)$ 从邻居节点聚合的过程。

#### **交互功能**
- **步进控制**：支持暂停/继续，单步观察逆元计算和贡献传递。
- **音效提示**：节点处理时播放“点击”音效，发现环时播放警报音效。

#### **复古风格实现**
```javascript
// 伪代码：Canvas 绘制节点与边
function drawNode(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * 32, y * 32, 24, 24); // 8位像素风格
}

function playSound(effect) {
    const sfx = new Audio(`sfx_${effect}.wav`); // 8位音效
    sfx.play();
}
```

---

### **总结**
通过组合计数与动态规划结合逆元处理，高效解决 DAG 加边后的树形图计数问题。可视化设计通过像素动画与音效增强理解，适合教学演示与交互学习。

---
处理用时：62.68秒
# 题目信息

# [湖南集训] Crazy Rabbit

## 题目描述

兔子们决定在自己的城堡里安排一些士兵进行防守。

给出 $n$ 个点的坐标，和城堡里一个圆心在原点的圆形的障碍，兔子们希望从中选出 $k$ 个兔子，使得它们两两**所在的直线**都不与圆相交。

兔子们希望知道最多能选出多少兔子。

## 说明/提示

#### 样例 1 解释

 ![](https://cdn.luogu.com.cn/upload/pic/6853.png) 

选择第 $1, 2, 6, 4$ 只兔子即可。

---

#### 数据规模与约定

- 对于 $10\%$ 的数据，保证 $1\leq n\leq 20$。
- 对于 $30\%$ 的数据，保证 $1\leq n\leq 100$。
- 对于 $100\%$ 的数据，保证 $1\leq n\leq 2000$，$1\leq r,x_i,y_i \leq 5000$。

## 样例 #1

### 输入

```
6 3
0 6
-7 -4
-3 -2
7 -5
-2 3
8 -3```

### 输出

```
4```

# AI分析结果



## 算法分类
**计算几何与贪心算法**

---

## 综合分析与结论
### 核心思路
1. **几何模型转换**：将每个点与圆的两条切线映射为圆上的区间。若两点连线不穿过圆，则对应区间必须相交但不包含。
2. **区间排序与筛选**：按左端点排序所有区间，枚举每个区间作为起点，筛选出左端点在该区间内且右端点超过其右端点的区间。
3. **LIS优化**：对筛选出的区间右端点求最长递增子序列（LIS），保证无包含关系，最终取最大值。

### 解决难点
- **几何条件转化**：通过计算切点将几何问题转化为区间相交问题。
- **环形区间处理**：将跨过0/2π的区间调整为正常区间，避免环形干扰。
- **高效筛选与LIS**：通过排序和LIS将复杂度优化至O(n² log n)。

### 可视化设计
1. **圆与区间绘制**：Canvas绘制圆心和点对应的区间（弧段），不同颜色区分各区间。
2. **枚举过程动画**：高亮当前枚举的起点区间，动态显示符合条件的其他区间。
3. **LIS计算演示**：逐步展示右端点序列的构建及LIS求解过程，颜色标记当前处理的元素。
4. **复古像素风格**：使用8位像素色块表示区间，背景音乐与音效（如成功音效、错误提示）。

---

## 题解清单（≥4星）
### 1. Maniac丶坚果（★★★★☆）
- **亮点**：代码结构清晰，详细注释几何计算步骤，高效处理环形区间。
- **核心代码**：
```cpp
sort(A + 1, A + n + 1);
int ans = -1;
for (int i = 1,len; i <= n; ++i) {
    len = 0;
    for (int j = i + 1; j <= n; ++j)
    if (A[j].FI <= A[i].SE && A[j].SE > A[i].SE)
    b[++len] = A[j].SE;
    ans = max(ans,check(len));
}
printf("%d\n",ans + 1);
```

### 2. Hanx16Kira（★★★★☆）
- **亮点**：详细数学推导，明确区间相交条件，代码模块化。
- **核心代码**：
```cpp
For(i, 0, N - 1) {
    vector<double> cur;
    cur.emplace_back(vec[i].se);
    For(j, i + 1, N - 1)
        if (vec[j].fi <= vec[i].se && vec[j].se >= vec[i].se)
            cur.push_back(vec[j].se);
    ans = max(ans, Calc(cur));
}
```

---

## 最优思路提炼
### 关键步骤
1. **区间转换**：计算每个点的切点区间，调整跨环情况。
2. **枚举起点**：对每个区间，筛选左端点在起点区间内且右端点更大的区间。
3. **LIS优化**：对右端点序列求LIS，最大值即为答案。

### 核心技巧
- **几何问题代数化**：利用极角与三角函数简化几何判断。
- **环形处理技巧**：通过模运算将环形区间线性化。
- **贪心+LIS**：将复杂条件转化为经典LIS问题。

---

## 类似题目推荐
1. **P1663 山**（极角排序与几何覆盖）
2. **P1214 线段覆盖**（区间选择与贪心）
3. **P1020 导弹拦截**（LIS应用）

---

## 个人心得摘录
- **调试教训**：确保atan2和acos的参数正确，避免区间方向错误。
- **思维突破**：将几何条件转化为区间相交模型是关键，类比TC559的环形处理思路。

---

## 可视化算法演示
### 动画步骤
1. **绘制圆与点**：在Canvas中显示圆和所有点，动态绘制切点区间。
2. **枚举起点**：点击选择起点区间，高亮其覆盖的弧段。
3. **筛选区间**：显示符合条件的其他区间，颜色渐变区分。
4. **LIS构建**：逐步显示右端点序列，绿色标记LIS元素，红色标记替换操作。

### 复古风格
- **8位像素**：圆用16色块拼接，区间用不同色块表示。
- **音效设计**：成功时播放8位上扬音效，LIS更新时触发短促提示音。

---

## 核心代码（Maniac丶坚果）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2005;
const double pi = acos(-1.0);
pair<double,double> A[maxn];
double b[maxn],c[maxn];

int check(int x) {
    int len = 0; 
    for (int i =1 ; i <= x; ++i) {
        if (b[i] > c[len]) c[++len] = b[i];
        else *upper_bound(c+1, c+len+1, b[i]) = b[i];
    }
    return len;
}

int main() {
    // 计算每个点的区间并排序
    for (int i = 1; i <= n; ++i) {
        double L = angle - Cos, R = angle + Cos;
        while (L <= -pi) L += 2*pi; // 环形处理
        if (L > R) swap(L,R);
        A[i] = MP(L,R);
    }
    sort(A + 1, A + n + 1);
    
    // 枚举起点求最大LIS
    int ans = 0;
    for (int i = 1; i <=n; ++i) {
        int len = 0;
        for (int j = i+1; j <=n; ++j)
            if (A[j].FI <= A[i].SE && A[j].SE > A[i].SE)
                b[++len] = A[j].SE;
        ans = max(ans, check(len));
    }
    cout << ans + 1;
}
```

---
处理用时：102.15秒
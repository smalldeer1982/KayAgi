# 题目信息

# [NOI2006] 神奇口袋

## 题目描述

Pòlya 获得了一个奇妙的口袋，上面写着人类难以理解的符号。Pòlya 看得入了迷，冥思苦想，发现了一个神奇的模型（被后人称为 Pòlya 模型)。为了生动地讲授这个神奇的模型，他带着学生们做了一个虚拟游戏：游戏开始时，袋中装入 $a_1$ 个颜色为 $1$ 的球，$a_2$ 个颜色为 $2$ 的球，……，$a_t$ 个颜色为 $t$ 的球，其中 $a_i \in \mathbb Z^+$（$1 \le i \le t$）。

游戏开始后，每次严格进行如下的操作：

从袋中随机的抽出一个小球（袋中所有小球被抽中的概率相等），Pòlya 独自观察这个小球的颜色后将其放回，然后再把 $d$ 个与其颜色相同的小球放到口袋中。

设 $c_i$ 表示第 $i$ 次抽出的小球的颜色（$1 \le C_i \le t$），一个游戏过程将会产生一个颜色序列（$c_1, c_2, \ldots, c_n, \ldots$）。Pòlya 把游戏开始时 $t$ 种颜色的小球每一种的个数 $a_1, a_2, \ldots, a_t$ 告诉了所有学生。然后他问学生：一次游戏过程产生的颜色序列满足下列条件的概率有多大？ 

$$c_{x_1}=y_1, c_{x_2}=y_2, \ldots, c_{x_n}=y_n$$

其中 $0 < x_1 < x_2 < \cdots < x_n$，$1 \le y_i \le t$。换句话说，已知 $(t, n, d, a_1, a_2, \ldots, a_t, x_1, y_1, x_2, y_2, \ldots, x_n, y_n)$，你要回答有多大的可能性会发生下面的事件：“对所有 $k$（$1 \le k \le n$），第 $x_k$ 次抽出的球的颜色为 $y_k$”。

## 说明/提示

**【样例解释 #1】**

初始时，两种颜色球数分别为 $(1, 1)$，取出色号为 $1$ 的球的概率为 $1/2$；第二次取球之前，两种颜色球数分别为 $(2, 1)$，取出色号为 $2$ 的球的概率为 $1/3$；第三次取球之前，两种颜色球数分别为 $(2, 2)$，取出色号为 $1$ 的球的概率为 $1/2$，所以三次取球的总概率为 $1/12$。

**【数据规模和约定】**

对于 $100 \%$ 的数据，$1 \le t, n \le 1000$，$1 \le a_k, d \le 10$，$1 \le x_1 < x_2 < \cdots < x_n \le 10000$，$1 \le y_k \le t$。

## 样例 #1

### 输入

```
2 3 1
1 1
1 1
2 2
3 1
```

### 输出

```
1/12
```

## 样例 #2

### 输入

```
3 1 2
1 1 1
5 1
```

### 输出

```
1/3
```

# AI分析结果



# 算法分类
数学概率模型

## 题解思路与核心难点
**核心思路**：通过数学推导发现各次抽球事件相互独立，每次的概率仅与当前球的数量分布有关。处理条件时只需按时间顺序计算当前概率，并动态更新球的数量。

**解决难点**：
1. 证明多个约束条件的顺序无关性（交换相邻不同颜色的概率相等）
2. 处理大数运算时的分数约分问题（质因数分解或内置分数类）

## 题解评分（≥4星）
1. yybyyb（C++，5星）：完整证明过程+质因数分解优化，适用于大数据
2. w33z8kqrqk8zzzx33（Python，4星）：简洁的分数类实现，可读性极佳
3. Purslane（C++，4星）：质因数分解+高精度乘法，代码结构清晰

## 最优技巧提炼
**关键技巧**：
1. 概率独立性证明：通过数学归纳法证明每次概率仅与当前球数比例有关
2. 实时更新机制：每次处理条件后立即更新球数（a[y] += d, sum += d）
3. 质因数分解优化：将分子分母分解后约分，避免直接处理大数

## 同类型题拓展
- 多项式概率模型（如排列组合中的不放回抽样）
- 动态更新状态的概率问题（如传染病传播模型）

## 推荐题目
1. P2181 抽卡游戏（概率动态计算）
2. P2638 安全系统（概率与组合数）
3. P3802 小魔女帕琪（独立事件概率）

## 个人心得摘录
"处理高精度时，质因数分解比直接写高精度类更高效" —— yybyyb题解

## 算法可视化设计
**核心动画方案**：
1. **状态面板**：左侧显示当前各颜色球数（像素风格数字），右侧显示累积概率
2. **抽球过程**：
   - 当前被选颜色闪烁3次（红色高亮）
   - 球堆动画：该颜色球堆增长d个单位（绿色↑动画）
3. **控制面板**：速度调节条+单步执行按钮

**复古像素特效**：
- 使用16色调色板（NES经典配色）
- 球数变化时播放8-bit "升级"音效（300Hz方波）
- 错误条件触发时屏幕抖动+警报音效

**关键代码片段（JS伪代码）**：
```javascript
class PolyaVisualizer {
  constructor() {
    this.colors = [new BallStack(1, 10), new BallStack(2, 10)] // 初始状态
    this.prob = new Fraction(1)
  }
  
  drawStep(y) {
    const prevSum = this.colors.reduce((s,c) => s + c.count, 0)
    this.prob.multiply(this.colors[y].count, prevSum) // 更新概率
    this.colors[y].add(d) // 球数增加
    playSound('pick', 0.5) // 播放抽球音效
  }
}
```

---

**完整题解代码（Python精简版）**：
```python
from fractions import Fraction

t, n, d = map(int, input().split())
a = list(map(int, input().split()))
sum_balls = sum(a)
prob = Fraction(1, 1)

for _ in range(n):
    x, y = map(int, input().split())
    y -= 1  # 转为0-based
    prob *= Fraction(a[y], sum_balls)
    a[y] += d
    sum_balls += d

print(f"{prob.numerator}/{prob.denominator}")
```

---
处理用时：48.37秒
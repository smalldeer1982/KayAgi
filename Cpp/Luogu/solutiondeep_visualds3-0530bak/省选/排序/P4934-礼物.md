# 题目信息

# 礼物

## 题目背景

由于你出色的完成了前面两道题目，善良的 __stdcall 决定给你一个小礼物，给拼搏在 AK 这套题之路上的你，一个有力的援助。

## 题目描述

__stdcall 决定给你 $n$ 个礼物，每个礼物有一个魔力值 $a_i$。

这些礼物的魔力值都是独一无二的，两两互不相同。这些礼物都有着神奇的魔力，如果两个礼物 $i, j$ 的魔力值满足 $a_i \operatorname{bitand} a_j \ge \min(a_i, a_j)$，那么这两个礼物的魔力将会相互抵消，因此它们不能放在一个箱子里。

这里的 $\operatorname{bitand}$ 表示按位与运算，如果你对这一运算不够了解，请参考：<https://baike.baidu.com/item/%E6%8C%89%E4%BD%8D%E4%B8%8E/9601818>。

作为发礼物苦力的 ljt12138 的箱子并不多，不过幸运的是，每个箱子都足够大。现在他请求你帮助他合理分配，用**尽可能少**的箱子装下所有礼物。换言之，使得每个礼物都被恰好装入一个箱子中，且同一个箱子中的礼物魔力不会相互抵消。如果有多种合法的方案，你只需要给出**任意一种**。

ljt12138 十分善良，如果你只能求出所需要的箱子数，也可以获得该测试点 $60\%$ 的分数，关于这一点，请参考下面的提示与说明。

## 说明/提示

### 附加样例

你可以在  <https://pan.baidu.com/s/1A8_ZA4yXXi5y6771x9JKUw> 下载附加样例。

### 关于输出方案

- 如果你在第一行输出了 $0$，而正确回答了最小所需的箱子数，将获得测试点 $60\%$ 的分数。
- 如果你在第一行输出了 $1$，正确回答了最小所需的箱子数，但没有给出正确的方案，也将获得该测试点 $60\%$ 的分数。
- 如果你没有正确回答最小所需的箱子数，将不会获得该测试点的分数。
- 请选手注意，如果你未按照上述格式输出答案，将无法获得任何分数。

数据 $n, k$ 的关系由下面的表格给出：

|数据编号| $n$ | $k$ |
|:----:|:----:|:----:|
|$1$|$5$|$3$|
|$2$|$6$|$3$|
|$3$|$7$|$10$|
|$4$|$8$|$10$|
|$5$|$16$|$7$|
|$6$|$17$|$8$|
|$7$|$17$|$9$|
|$8$|$17$|$20$|
|$9$|$2\times 10^3$|$17$|
|$10$|$2.5\times 10^3$|$18$|
|$11$|$3\times 10^3$|$19$|
|$12$|$3\times 10^3$|$20$|
|$13$|$2.5\times 10^4$|$15$|
|$14$|$2.5\times 10^4$|$15$|
|$15$|$5\times 10^4$|$16$|
|$16$|$5\times 10^4$|$16$|
|$17$|$2.5\times 10^5$|$18$|
|$18$|$5\times 10^5$|$19$|
|$19$|$10^6$|$20$|
|$20$|$10^6$|$20$|

## 样例 #1

### 输入

```
5 3
0 4 7 1 6 
```

### 输出

```
1
4
1 0
2 1 4
1 6
1 7 ```

# AI分析结果



**唯一算法分类**：动态规划（位运算优化）

---

### **综合分析与结论**

**核心思路**：  
题目转化为求集合包含关系构成DAG的最长链长度，最小分组数等于最长链长度（Dilworth定理）。动态规划法通过预处理每个数的二进制子集，避免显式建图，时间复杂度为O(k·2^k)，高效处理大范围数据。

**关键算法流程**：  
1. **状态定义**：`f[i]`表示以数值i结尾的最长链长度。
2. **转移方程**：枚举i的每个二进制子集（通过去掉某一位），取最大子集链长+1（若i存在于输入中）。
3. **分组构造**：根据`f[i]`值将数分配到对应组，每组为反链。

**可视化设计**：  
- **动画演示**：展示数i的二进制位，逐个去除1位生成子集，高亮当前处理的位（如红色方块），子集状态变化（绿色闪烁）。
- **像素风格**：用8位风格显示二进制数网格，每次位操作播放“哔”音效，转移成功时播放上升音调。
- **状态面板**：实时显示当前数i的`f[i]`值及对应的分组编号。

---

### **题解清单（≥4星）**

1. **Huami360（★★★★☆）**  
   **亮点**：简洁的DP实现，利用位运算优化子集枚举，代码短且高效。  
   **代码片段**：  
   ```cpp
   for(re int i = 0; i <= Max; ++i){
       for(re int j = i; j; j ^= j & -j) 
           f[i] = max(f[i], f[i ^ (j & -j)]);
       if(v[i]) g[++f[i]].push_back(i);
   }
   ```

2. **__stdcall（★★★★☆）**  
   **亮点**：理论推导清晰（Dilworth定理），提出拓扑排序与优化建图策略。  
   **关键思路**：将包含关系抽象为DAG，最小分组数等于最长链长度。

3. **Zechariah（★★★★☆）**  
   **亮点**：代码简洁，利用`lowbit`快速枚举子集，直接构造分组。  
   **核心代码**：  
   ```cpp
   for(int j = i; j; j &= j - 1) 
       if(which[i] < which[i^j&-j]) which[i] = which[i^j&-j];
   ```

---

### **最优思路提炼**

- **位运算优化子集枚举**：通过`j = i; j ^= j & -j`循环去掉二进制最后一位，高效遍历所有子集。
- **虚拟点转移**：在DP中即使某些数未出现也参与转移，确保状态正确性。
- **反链分组构造**：直接根据DP结果将数分配到对应层，天然形成合法分组。

---

### **相似题目推荐**

1. **P4303 [AHOI2006] 子集包含问题**（集合包含关系的最长链）
2. P1772 [ZJOI2006] 物流运输（位运算优化状态设计）
3. P3959 宝藏（状态压缩动态规划）

---

### **可视化算法演示**

**核心步骤动画设计**：  
1. **初始化**：展示所有输入数的二进制网格（如5=101显示为3个像素块）。
2. **位操作**：点击数i时，逐个高亮其二进制位，播放“哔”音效，生成子集（如5→4, 1）。
3. **状态更新**：子集`i^bit`的`f`值以气泡形式显示，当前数i的`f[i]`更新为最大值+1，绿色闪烁提示。
4. **分组展示**：右侧面板动态显示各分组，数i落入对应`f[i]`的组，伴随“叮”音效。

**复古风格实现**：  
- **Canvas渲染**：16色像素网格，数用5x3像素块表示，背景8-bit芯片音效循环。
- **交互控制**：空格暂停/继续，方向键调整动画速度，F键单步执行。

---

**代码片段（JS动画核心）**：  
```javascript
function drawBinary(num, x, y) {
    let bits = num.toString(2).padStart(k, '0');
    for (let i = 0; i < k; i++) {
        ctx.fillStyle = bits[i] === '1' ? '#FF5555' : '#333';
        ctx.fillRect(x + i*8, y, 6, 6); // 像素块绘制
    }
}
```

---

**总结**：通过位运算动态规划高效解决集合包含分组问题，结合复古像素动画直观演示状态转移与分组过程。

---
处理用时：61.57秒
# 题目信息

# ygg发神威

## 题目背景

ygg 发神威了，机房的萌新们瑟瑟发抖。

## 题目描述

ygg 的机房内共有 $n$ 台电脑且都被使用，为了节省机房内电脑的开销，第 $i$ 台电脑会同时被 $a_i$ 个萌新使用。每台电脑都装有一个「多人在线交流平台」，一台电脑会直接地或间接地通过这个平台与其他所有电脑连接。由于「多人在线交流平台」仍然处于测试阶段，如果一台电脑有多于一种不同的消息传输方式将消息传输到另外的任意一台电脑，就会有各种稀奇古怪的问题产生。两种消息的传输方式被认为是不同的，当且仅当传输消息所经过的直接连接的线路的集合不同，或者传输所经过的电脑的集合不同。当然，消息的传输肯定不会经过一条线路多次。为了避免这种状况，「多人在线交流平台」的线路被特殊地设计了，以使得任意两台电脑之间的传输线路唯一。同时，为了防止一台电脑负荷过大，一台电脑最多会通过「多人在线交流平台」的线路与 $p$ 台电脑相连。

原本两台通过「多人在线交流平台」的线路相连的电脑之间可以相互传输数据，可是 ygg 发现，这会允许使用两台电脑的萌新们互相发送消息，引起大规模~~考试作弊~~膜拜 ygg 的行为。所以他大发神威，切断了所有连接线路的一半。具体地，他将原本通过「多人在线交流平台」的双向线路连接的两台电脑之间的线路变成了单向线路。即，原本通过一条双向线路连接的两台电脑中，只能有一台电脑向另一台电脑发送消息，而另一台电脑不能将任何消息发送回来。

机房内的萌新们在每个时刻都有若干条消息需要传递。如果一台电脑 $i$ 能够直接或间接地通过「多人在线交流平台」的线路连接到电脑 $j$，那么使用电脑 $i$ 的 $a_i$ 个萌新中的任何一个都可以向使用电脑 $j$ 的 $a_j$ 个萌新发送消息。显然，使用同一台电脑的萌新之间的消息只需要在线下传达，不需要使用「多人在线交流平台」，因此不会计入线上发送的消息。

其实机房中的萌新们早已知道了「多人在线交流平台」的管理员密码，所以能够对其线路的连接方向做出修改。可无论他们怎么尝试，都不能恢复最开始时双向连接的状态了。机房中的萌新们当然希望能够尽可能地发送消息，所以他们想要知道，在机房的电脑仅被单向的线路连接时，每一时刻最多能有多少条消息被通过「多人在线交流平台」发送。

为了简化问题，我们假设机房内的所有萌新均能够在同一时刻发送线上消息，并且每一个萌新可以同时向多个人发送消息。

**简要题面：给一棵结点编号** $1\sim n$**，结点权值** $a_i$**，且结点度数最大为** $p$ **的树。求将树的每条边改为有向边后下式的最大值：**

$$\sum_{i=1}^{n}\sum_{j=1}^{n}a_ia_j\left[i\rightarrow j\right]$$

$\left[i\rightarrow j\right]$ **定义为：若编号为** $i$ **的结点能通过有向边到达编号为** $j$ **的结点，则值为** $1$**；否则值为** $0$**，且** $\left[i\rightarrow i\right]=0$**。**

## 说明/提示

### 样例解释

能够发送的消息最多时的消息传递方向如下：

![](https://i.loli.net/2019/10/30/3AsqcyzdY25E8gP.png)

在该连接方式下发送消息最多的时刻，使用 $1$ 号电脑的 $1$ 个萌新向 $5$ 个萌新各发送了一条消息，共 $1\times5=5$ 条消息；  
使用 $2$ 号电脑的 $2$ 个萌新分别向 $3$ 个萌新各发送了一条消息，共 $2\times3=6$ 条消息；  
使用 $3$ 号电脑的 $3$ 个萌新不能向任何萌新发送线上消息，因此没有消息从该电脑发送；  
使用 $4$ 号电脑的 $4$ 个萌新分别向 $6$ 个萌新各发送了一条消息，共 $4\times6=24$ 条消息。  
因此，在某一时刻，最多可以有 $5+6+24=35$ 条线上消息被发送。   
可以使用枚举法验证，不存在一种单向的连接方式，使得在某一时刻发送的线上消息的数量能够达到 $36$ 条或更多。

### 数据范围及约定

对于 $10\%$ 的数据，$n\le10$；  
对于另外 $10\%$ 的数据，$n=p+1$；  
对于另外 $10\%$ 的数据，$p=2$；  
对于另外 $10\%$ 的数据，$p\le20$；  
对于另外 $10\%$ 的数据，$p\le40$；  

对于所有数据，$2\le n\le10^5$，$2\le p\le50$，$1\le a_i\le100$，$1\le u_i,v_i\le n$。保证给出的双向连接线路能够使任意两台电脑之间的消息传输线路唯一。保证至少有一台电脑原本通过「多人在线交流平台」连接的线路数恰好为 $p$，且没有电脑原本连接的线路数大于 $p$。

## 样例 #1

### 输入

```
4 2
1 2 3 4
1 2
3 2
4 1
```

### 输出

```
35
```

# AI分析结果



**唯一算法分类**：树形动态规划 + 折半枚举

---

### **题解思路与难点对比**

**核心思路**：  
1. **树的重心选择**：最优解需以树的重心为根，确保各子树权值平衡，便于后续分组。  
2. **子树方向贡献计算**：每个子树有两种可能的权值和（保留原方向或翻转方向）。  
3. **权值分组优化**：将子树权值分为两组，最大化两组的乘积，使用折半枚举降低时间复杂度。

**解决难点**：  
- **指数级枚举的优化**：传统暴力枚举边方向的时间复杂度为 \(O(2^p)\)，无法处理 \(p \leq 50\)。通过折半枚举（将子树分为前半和后半）将复杂度降至 \(O(2^{p/2})\)。  
- **树形结构的高效处理**：利用树的重心性质，确保每个子树权值不超过总和一半，简化分组问题。

---

### **题解评分（≥4星）**

1. **Daniel13265的题解（5星）**  
   - **亮点**：系统分析不同数据范围，提出折半枚举优化，结合树重心理论，思路清晰，代码可扩展性强。  
   - **关键句**：*“权值之和最大的子树一定是答案的关键”*（体现树重心优化思想）。

---

### **最优思路提炼**

1. **树重心定位**：通过加权重心确保子树权值平衡。  
2. **权值分组策略**：将子树权值分为两组，最大化 \(S_1 \times S_2\)，通过折半枚举或背包优化求解。  
3. **方向贡献预处理**：对每个子树计算两种方向下的贡献差值，用于动态规划。

---

### **同类型题与算法套路**

- **权值分组问题**：如“最小化两子集和差”（LeetCode 2035）。  
- **树形动态规划**：如“树的最大独立集”（洛谷 P1352）。  
- **折半枚举优化**：适用于高复杂度问题的分治优化（如“子集和问题的折半解法”）。

---

### **推荐题目**

1. **洛谷 P1352**（树形DP经典）  
2. **洛谷 P2014**（树形依赖背包）  
3. **洛谷 P5020**（分组最优化问题）

---

### **可视化与算法演示**

**动画设计**：  
1. **树形结构可视化**：以像素风格绘制树节点，根节点高亮为红色，子树用不同颜色区分。  
2. **方向选择交互**：点击子树切换方向（箭头方向），实时更新权值分组和总贡献。  
3. **折半枚举过程**：左侧展示前半子集的权值组合，右侧动态匹配后半组合，匹配成功时播放“成功音效”。  

**复古像素风格**：  
- **颜色方案**：16色调色板，根节点红色，子树绿色/蓝色。  
- **音效**：切换方向时播放8位“点击音效”，找到最优解时播放经典FC胜利音效。  

**代码片段（JavaScript）**：  
```javascript
// 折半枚举核心逻辑
function splitEnumerate(weights) {
  const half = Math.floor(weights.length / 2);
  const left = weights.slice(0, half);
  const right = weights.slice(half);
  const leftSums = generateSums(left);
  const rightSums = generateSums(right);
  // ... 匹配左右部分
}
```

---

### **代码实现核心逻辑**

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 + 5;
vector<int> tree[MAXN];
int a[MAXN], total, root;
int dp[1 << 20]; // 折半枚举辅助数组

// 计算子树权值差并生成权值列表
vector<int> get_weights(int u, int parent) {
    vector<int> subs;
    for (int v : tree[u]) {
        if (v == parent) continue;
        auto sub = get_weights(v, u);
        int s1 = accumulate(sub.begin(), sub.end(), 0);
        int s2 = total - s1 - a[u]; // 翻转后的差值
        subs.push_back(abs(s1 - s2));
    }
    return subs;
}

// 折半枚举求最大乘积
int solve(vector<int>& weights) {
    int n = weights.size(), half = n / 2;
    vector<int> left(weights.begin(), weights.begin() + half);
    vector<int> right(weights.begin() + half, weights.end());
    // 生成左右部分的所有可能和
    vector<int> left_sums = {0};
    for (int w : left) {
        vector<int> tmp;
        for (int s : left_sums) tmp.push_back(s + w);
        left_sums.insert(left_sums.end(), tmp.begin(), tmp.end());
    }
    // ... 类似处理右半部分并匹配
    return max_product;
}

int main() {
    // 输入处理与树构建
    // 寻找树的重心 root
    auto weights = get_weights(root, -1);
    cout << solve(weights);
    return 0;
}
```

---
处理用时：58.02秒
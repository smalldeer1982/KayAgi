# 题目信息

# [CCO 2021] Travelling Merchant

## 题目描述

一个国家有 $n$ 个城市和 $m$ 条单向道路，一个旅行商在这些城市之间旅行。

第 $i$ 条道路从城市 $a_i$ 到城市 $b_i$，只有当他的资产不少于 $r_i$ 元才可以走这条道路，走过这条道路之后他的资产会增加 $p_i$ 元。

他希望自己可以永远不停的游走下去，于是他想知道从任意一个城市出发至少需要多少元初始资产。

## 说明/提示

#### 样例 #1 解释
以第 $2$ 座城市为例：从第 $2$ 座城市出发，初始资产 $3$ 元，则可以在第 $2, 1, 3$ 三座城市无限绕圈。
#### 数据范围
对于 $\frac{2}{7}$ 的数据，$2 \leq n, m \leq 2 \times 10^3$；

对于另 $\frac{15}{49}$ 的数据，$p_i = 0$；

对于 $100\%$ 的数据，$2 \leq n, m \leq 2 \times 10^5$，$1 \leq a_i, b_i \leq n$，$a_i \neq b_i$，$0 \leq r_i, p_i \leq 10^9$，**保证没有自环但可能有重边**。
#### 题目来源
[CCO2021](https://cemc.math.uwaterloo.ca/contests/computing/2021/index.html) D2T1

## 样例 #1

### 输入

```
5 5
3 1 4 0
2 1 3 0
1 3 1 1
3 2 3 1
4 2 0 2```

### 输出

```
2 3 3 1 -1```

# AI分析结果



**唯一算法分类**：贪心 + 拓扑排序

---

### **综合分析与结论**

**核心思路**：  
题目要求找到每个城市出发能无限循环的最小初始资产。通过结合贪心策略和拓扑排序，按边权（r_i）从大到小处理，逐步确定每个点的最小初始资产。处理过程中，利用队列维护出度为0的点，动态更新其前驱节点的答案。

**算法流程**：  
1. **预处理**：删除所有出度为0的点（不可达环的点），标记为-1。  
2. **排序边**：将所有边按 r_i 从大到小排序。  
3. **贪心处理**：每次取当前最大 r_i 的边，尝试更新其起点 u 的答案。若该边未被删除，则用 r_i 更新 ans[u]。  
4. **拓扑维护**：处理出度为0的节点，反向更新其前驱节点的 ans，并动态删边。  

**可视化设计**：  
- **边处理动画**：高亮当前处理的边（红色），显示 r_i 值。  
- **节点状态**：队列中的节点（黄色），已确定答案的节点（绿色），不可达节点（灰色）。  
- **ans更新**：动态显示 ans[u] 的数值变化，如从 ∞ 逐步下降。  
- **音效提示**：处理边时播放“滴”声，确定答案时播放成功音效，删除节点时播放低沉音效。  

---

### **题解清单（≥4星）**

1. **bsTiat（5星）**  
   - 亮点：代码简洁，明确结合贪心与拓扑排序，详细注释处理队列和边的逻辑。  
   - 关键代码：按 r_i 排序边，用队列处理出度为0的节点。  

2. **uniqueharry（4星）**  
   - 亮点：理论分析透彻，强调反图构建与动态规划转移方程，代码可读性强。  
   - 个人心得：指出“拓扑排序中每个节点只入队一次”，确保线性复杂度。  

3. **翼德天尊（4星）**  
   - 亮点：数学推导清晰，提出“最大 r_i 边决定上界”的核心思路，代码逻辑紧凑。  
   - 代码优化：用链式前向星存边，减少内存占用。  

---

### **核心代码实现**

```cpp
// 边结构体排序
struct Edge {
    int a, b, r, p;
    bool operator<(const Edge &x) const { return r < x.r; }
} edges[N];

// 拓扑处理队列
queue<int> q;
for (int i = 1; i <= n; ++i) if (!out_degree[i]) q.push(i);

// 按 r_i 从大到小处理边
sort(edges + 1, edges + m + 1);
for (int i = m; i >= 1; --i) {
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int j = head[u]; j; j = nxt[j]) {
            int eid = to[j];
            if (vis[eid]) continue;
            vis[eid] = true;
            out_degree[edges[eid].a]--;
            if (ans[u] != INF) { // 更新前驱节点答案
                ans[edges[eid].a] = min(ans[edges[eid].a], max(edges[eid].r, ans[u] - edges[eid].p));
            }
            if (out_degree[edges[eid].a] == 0) q.push(edges[eid].a);
        }
    }
    if (!vis[i]) {
        vis[i] = true;
        ans[edges[i].a] = min(ans[edges[i].a], edges[i].r);
        if (--out_degree[edges[i].a] == 0) q.push(edges[i].a);
    }
}
```

---

### **同类型题推荐**

1. **P1993 小 K 的农场**（差分约束 + 拓扑判环）  
2. **P2144 [FJOI2007]轮状病毒**（图论环计数）  
3. **P3388 【模板】割点**（图的连通性与环处理）  

---

### **个人心得摘录**

- **bsTiat**：首次题解强调“错误思路”的排除，帮助理解正确方向。  
- **uniqueharry**：通过反图简化转移，避免正序处理环的复杂性。  
- **7KByte**：逆向思维归纳法，从最终状态倒推初始条件。  

---

### **复古像素化动画设计**

1. **Canvas绘制**：  
   - 节点为8位像素圆，边用箭头连接，颜色随状态变化（红-处理中，灰-已删除）。  
   - 当前处理边高亮，显示 r_i 数值，ans值以浮动文字更新。  

2. **音效触发**：  
   - 处理边：短促“滴”声（Web Audio API生成）。  
   - 确定答案：8位风格胜利音效（类似马里奥吃金币）。  

3. **自动演示模式**：  
   - 自动按 r_i 降序处理边，单步执行可暂停观察 ans 变化。  
   - 队列节点以黄色方块展示，处理时变绿。  

**代码片段（JS伪代码）**：  
```javascript
// 自动播放逻辑
function autoPlay() {
    let edgeIdx = m;
    while (edgeIdx >= 0) {
        highlightEdge(edges[edgeIdx]); // 高亮当前边
        playSound('beep');
        updateAnswerDisplay(edges[edgeIdx].a);
        edgeIdx--;
        await sleep(500); // 控制速度
    }
}
```

---
处理用时：96.47秒
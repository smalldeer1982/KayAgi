# 题目信息

# 『JROI-4』沈阳大街 2

## 题目描述

给定两个长度为 $n$ 的序列 $A,B$，满足：

* $\forall 1\le i<n,A_i \ge A_{i+1}$ 

* $A_n\ge \min\limits_{i=1}^n(B_i)$

$\pi$ 是一个长度为 $n$ 的排列，定义价值函数 $f(\pi)$：

$$
f(\pi)=\prod_{i=1}^n\min(A_i,B_{\pi(i)})
$$

每种排列出现的概率相等，求 $f(\pi)$ 的期望对 $998244353$ 取模的结果。

即求:

$$
\left(\dfrac{1}{n!}\sum_\pi f(\pi)\right) \bmod 998244353
$$


## 说明/提示

**本题采用捆绑测试。**

|  子任务编号 | 分值 | 特殊限制 |
| :-----------: | :---:| :-----------: |
| 1 | 5 | $1\le n\le 8$ |
| 2 | 35 | $1\le n\le 50$ |
| 3 | 20 | $A_n\ge \max\limits_{i=1}^n(B_i)$ |
| 4 | 40 | 无 |

对于 $100\%$ 的数据满足 $1\le n\le 5000$，$1\le A_i,B_i\le 10^9$。

## 样例 #1

### 输入

```
8
15 14 13 10 9 6 3 2 
2 10 8 2 9 1 10 2 ```

### 输出

```
114102208```

# AI分析结果



## 算法分类
动态规划（排序辅助）

---

## 题解思路与核心难点

### 核心思路
将两个序列合并后排序，按从大到小顺序处理元素。定义 `dp[i][j]` 表示前 `i` 个元素中已匹配 `j` 对红蓝配对的权值总和。转移时考虑当前元素是否参与配对，利用预处理的不同颜色元素数量统计可用配对数。

### 解决难点
1. **排列转匹配**：将排列问题转化为红蓝元素的二分图匹配问题，每个匹配贡献的值为较小元素。
2. **排序贪心**：排序保证后续处理元素时，当前元素的权值即为 `min` 的贡献。
3. **动态规划状态设计**：通过预处理 `cnt` 数组快速计算可用配对数，避免重复枚举。

---

## 题解评分（≥4星）

1. **Otomachi_Una（⭐⭐⭐⭐⭐）**  
   思路清晰，代码简洁。预处理 `cnt` 数组加速转移，状态转移方程明确，时间复杂度严格 O(n²)。

2. **Daidly（⭐⭐⭐⭐）**  
   类似思路但更注重状态含义解释，代码中合并排序方式稍有不同，适合理解排序后配对逻辑。

3. **Graphcity（⭐⭐⭐⭐）**  
   引入红蓝匹配视角，状态转移公式推导详细，适合深入理解动态规划的配对过程。

---

## 最优思路与技巧

### 关键技巧
1. **合并排序**：将 A、B 合并为数组并按值降序排列，确保每次处理的元素是当前最大可能贡献。
2. **预处理计数**：维护 `cnt[0/1][i]` 统计到位置 `i` 为止红/蓝元素数量，快速计算可用配对数。
3. **动态规划转移**：  
   $$ dp[i][j] = dp[i-1][j] + dp[i-1][j-1] \cdot c[i] \cdot (\text{可用配对数}) $$

---

## 类似题目
1. **P1776 宝物筛选**（背包问题结合排序）
2. **P2513 逆序对数列**（动态规划处理排列计数）
3. **P4158 粉刷匠**（动态规划结合状态压缩）

---

## 核心代码实现

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=1e4+5, MOD=998244353;
typedef long long ll;
ll f[MAXN][MAXN]; // f[i][j]: 前i个元素匹配j对的权值和
int cnt[2][MAXN];  // 预处理不同颜色计数

struct Element { ll val; int type; } c[MAXN];
bool cmp(Element x, Element y) { return x.val > y.val; }

ll qpow(ll a, int b) { // 快速幂求逆元
    ll res=1;
    while(b) {
        if(b&1) res=res*a%MOD;
        a=a*a%MOD; b>>=1;
    } return res;
}

int main() {
    int n; cin>>n;
    for(int i=1; i<=n; ++i) cin>>c[i].val, c[i].type=0;
    for(int i=1; i<=n; ++i) cin>>c[n+i].val, c[n+i].type=1;
    sort(c+1, c+2*n+1, cmp); // 合并排序
    
    // 预处理cnt数组
    for(int i=1; i<=2*n; ++i) {
        cnt[0][i] = cnt[0][i-1] + (c[i].type==0);
        cnt[1][i] = cnt[1][i-1] + (c[i].type==1);
    }
    
    f[0][0] = 1;
    for(int i=1; i<=2*n; ++i) {
        int opp = cnt[!c[i].type][i]; // 可用异色元素数
        for(int j=0; j<=min(n,i); ++j) {
            f[i][j] = f[i-1][j]; // 不选当前元素
            if(j>0 && opp >= j) { // 选当前元素配对
                f[i][j] = (f[i][j] + f[i-1][j-1] * c[i].val % MOD * (opp-j+1)) % MOD;
            }
        }
    }
    
    ll inv = 1; // 计算n!逆元
    for(int i=1; i<=n; ++i) inv = inv*i%MOD;
    inv = qpow(inv, MOD-2);
    cout << f[2*n][n] * inv % MOD;
}
```

---

## 可视化算法演示

### 动画设计
1. **元素排序阶段**：展示 A、B 元素合并后按值降序排列的过程，红蓝颜色区分。
2. **DP转移阶段**：高亮当前处理的元素，动态显示 `cnt` 数组的变化和 `f[i][j]` 的更新。
3. **回溯路径**：最终答案形成时，以闪烁效果显示贡献最大的配对路径。

### 复古像素风格
- **颜色方案**：红色（A元素）、蓝色（B元素）、黄色（当前处理元素）、绿色（已配对元素）。
- **音效**：配对成功时播放8-bit音效，错误操作时播放低沉提示音。
- **自动演示**：按空格键暂停/继续，方向键调整速度，Esc查看帮助。

---

## 个人心得
- **排序是关键**：若不排序，无法保证每个元素的贡献正确性，导致状态转移混乱。
- **预处理优化**：`cnt` 数组的预处理大幅简化了动态规划的复杂度，避免重复计算。
- **逆元处理**：必须用快速幂求逆元，直接除法会因模运算失效。

---
处理用时：76.75秒
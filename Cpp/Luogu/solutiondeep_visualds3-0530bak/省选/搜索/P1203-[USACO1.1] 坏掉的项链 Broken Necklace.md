# 题目信息

# [USACO1.1] 坏掉的项链 Broken Necklace

## 题目描述

你有一条由 $n$ 个红色的，白色的，或蓝色的珠子组成的项链，珠子是随意安排的。 这里是 $n=29$ 的两个例子:

![](https://cdn.luogu.com.cn/upload/image_hosting/i7imvc0g.png) 

第一和第二个珠子在图片中已经被作记号。

图片 A 中的项链可以用下面的字符串表示：

`brbrrrbbbrrrrrbrrbbrbbbbrrrrb`

假如你要在一些点打破项链，展开成一条直线，然后从一端开始收集同颜色的珠子直到你遇到一个不同的颜色珠子，在另一端做同样的事(颜色可能与在这之前收集的不同)。 确定应该在哪里打破项链来收集到最大数目的珠子。

例如，在图片 A 中的项链中，在珠子 $9$ 和珠子 $10$ 或珠子 $24$ 和珠子 $25$ 之间打断项链可以收集到 $8$ 个珠子。

白色珠子什么意思?

在一些项链中还包括白色的珠子(如图片B) 所示。

当收集珠子的时候，一个被遇到的白色珠子可以被当做红色也可以被当做蓝色。

表现含有白珠项链的字符串将会包括三个符号 `r`，`b`，`w` 。

写一个程序来确定从一条被给出的项链可以收集到的珠子最大数目。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$3\le n \le 350$

题目翻译来自NOCOW。

USACO Training Section 1.1

## 样例 #1

### 输入

```
29 
wwwbbrwrbrbrrbrbrwrwwrbwrwrrb
```

### 输出

```
11```

# AI分析结果



# 坏掉的项链 Broken Necklace 题解分析

## 唯一算法分类
**线性扫描 + 贪心策略**

---

## 题解思路、算法要点与解决难点
### 核心难点
1. **环形处理**：将项链视为环形结构，需要处理首尾相连的情况。
2. **白色珠子动态选择颜色**：需在遍历时动态决定将白色视为红/蓝以最大化收集数量。
3. **高效统计连续段**：需快速计算从某点向左右扩展的最大连续可收集珠子数。

### 关键算法对比
| 题解作者         | 核心思路                                                                 | 时间复杂度 | 关键优化点                     |
|------------------|--------------------------------------------------------------------------|------------|--------------------------------|
| 青衫白叙（赞89） | 单次遍历维护左右段长度，动态处理白色珠子的颜色选择                       | O(n)       | 一次遍历完成统计               |
| 田阙西（赞51）   | 预处理左右连续红/蓝长度，枚举断点时取最大值组合                          | O(n)       | 动态规划预处理前后缀           |
| w_y_c（赞136）   | 三倍扩展字符串模拟环形，枚举每个断点并暴力向左右扩展                     | O(n²)      | 环形展开为线性结构简化边界处理 |

---

## 题解评分 ≥4星
### 1. 青衫白叙（★★★★☆）
- **思路清晰度**：通过维护 `left`/`right` 段长度，用 `w` 计数器处理连续白色珠子的颜色选择。
- **代码可读性**：仅 30 行代码，变量命名简洁（a/b/w 分别表示左右段长度和连续白色数）。
- **核心代码**：
  ```cpp
  if(s[i] == 'w') {right++, w++;}
  else if(s[i] == c) {right++, w=0;}
  else { ans = max(ans, a + b); a = b - w; b = w + 1; w = 0; c = s[i]; }
  ```
- **亮点**：一次遍历完成统计，无需预处理数组。

### 2. 田阙西（★★★★☆）
- **思路清晰度**：预处理 `lR[]`/`lB[]` 和 `rR[]`/`rB[]` 数组分别记录左右连续红/蓝长度。
- **解决难点**：动态规划预处理使得枚举断点时可以 O(1) 组合左右段。
- **核心公式**：
  ```cpp
  ans = max(ans, max(lR[i], lB[i]) + max(rR[i+1], rB[i+1]))
  ```

### 3. w_y_c（★★★★☆）
- **代码可读性**：三倍扩展字符串 (`a = a + a + a`) 巧妙处理环形边界。
- **暴力技巧**：当遇到白色时尝试替换为红/蓝两种可能，取最大值：
  ```cpp
  a[i] = 'r'; ans = max(ans, f(i));
  a[i] = 'b'; ans = max(ans, f(i));
  ```

---

## 最优思路提炼
**青衫白叙的线性扫描法**  
1. **维护左右段长度**：`a` 表示左段有效长度，`b` 表示右段长度，`w` 记录右段中连续白色数。
2. **动态处理颜色切换**：当遇到新颜色时，将当前 `b - w` 作为左段，`w + 1` 作为新右段起点。
3. **一次遍历更新答案**：每次颜色变化时更新全局最大值。

---

## 同类型题与算法套路
1. **环形数组处理**：如[能量项链（NOIP2006）](https://www.luogu.com.cn/problem/P1063)。
2. **前后缀最值预处理**：如[最大子序和](https://leetcode.cn/problems/maximum-subarray/)。
3. **颜色替换问题**：如[粉刷房子](https://leetcode.cn/problems/paint-house/)。

---

## 推荐相似题目
1. **P1063** 能量项链（环形DP）
2. **P1886** 滑动窗口（双指针维护区间极值）
3. **P1090** 合并果子（贪心策略）

---

## 可视化与算法演示
### 动画设计方案
1. **环形展开**：将项链展开为三倍长度的直线，用不同颜色标记红/蓝/白珠。
2. **扫描指针**：用两个高亮指针分别向左（红色）和向右（蓝色）扩展，实时显示当前收集的珠子数。
3. **颜色替换特效**：白色珠子被动态染色时，播放像素化闪光动画，并显示当前假设的颜色。
4. **复古风格**：
   - **8位像素UI**：珠子用 16x16 像素块表示，红色（#FF0000）、蓝色（#0000FF）、白色（#FFFFFF）。
   - **音效设计**：收集珠子时播放 "beep" 音效，最大解出现时播放 FC 风格的胜利音乐。

### 交互功能
- **步进控制**：按空格键单步执行扫描过程。
- **自动演示**：点击播放键后自动运行，速度可调（1x/2x/4x）。
- **断点标记**：鼠标悬停任意位置显示此处断开能收集的珠子数。

---

## 核心代码实现（青衫白叙解法）
```cpp
char s[700], c;
int a, b, w, ans;
int main() {
    scanf("%d%s", &n, s);
    memcpy(s + n, s, n); // 环形展开为两倍长度
    for (int i = 0; i < n << 1; i++) {
        if (s[i] == 'w') b++, w++;
        else if (s[i] == c) b++, w = 0;
        else {
            ans = max(ans, a + b);
            a = b - w; // 左段保留非w部分
            b = w + 1; // 右段继承w的计数
            w = 0;
            c = s[i];
        }
    }
    printf("%d\n", min(ans, n));
}
```

---

## 个人心得摘录
> **青衫白叙**：  
> "当b重新计算时，其实a已经算好了... 更新答案应该在b算完的时候，a在上一轮已经算过了。"  
> —— 强调左右段更新的时序关系，避免重复计算。

> **w_y_c**：  
> "这TMD硬是看的到第三个点，要不然真不会..."  
> —— 处理白色时需要枚举两种颜色，否则会遗漏最优解。

---
处理用时：74.58秒
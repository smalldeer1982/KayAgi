# 题目信息

# [NOI2008] 假面舞会

## 题目描述

一年一度的假面舞会又开始了，栋栋也兴致勃勃的参加了今年的舞会。

今年的面具都是主办方特别定制的。每个参加舞会的人都可以在入场时选择一个自己喜欢的面具。每个面具都有一个编号，主办方会把此编号告诉拿该面具的人。

为了使舞会更有神秘感，主办方把面具分为 $k$（$k\geq 3$）类，并使用特殊的技术将每个面具的编号标在了面具上，只有戴第 $i$ 类面具的人才能看到戴第 $i+1$  类面具的人的编号，戴第 $k$ 类面具的人能看到戴第 $1$ 类面具的人的编号。

参加舞会的人并不知道有多少类面具，但是栋栋对此却特别好奇，他想自己算出有多少类面具，于是他开始在人群中收集信息。

栋栋收集的信息都是戴第几号面具的人看到了第几号面具的编号。如戴第 $2$ 号面具的人看到了第 $5$ 号面具的编号。栋栋自己也会看到一些编号，他也会根据自己的面具编号把信息补充进去。

由于并不是每个人都能记住自己所看到的全部编号，因此，栋栋收集的信息不能保证其完整性。现在请你计算，按照栋栋目前得到的信息，至多和至少有多少类面具。由于主办方已经声明了 $k\geq 3$，所以你必须将这条信息也考虑进去。


## 说明/提示

- 对于 $50\%$ 的数据，满足 $n \leq 300$，$m \leq 10^3$；
- 对于 $100\%$ 的数据，满足 $n \leq 10^5$，$m \leq 10^6$。


## 样例 #1

### 输入

```
6 5
1 2
2 3
3 4
4 1
3 5```

### 输出

```
4 4
```

## 样例 #2

### 输入

```
3 3
1 2
2 1
2 3```

### 输出

```
-1 -1
```

# AI分析结果



---

**算法分类**：DFS

---

### **题解思路与算法要点**

**核心思路**：  
1. 将面具关系建模为有向图，**双向建边**（正向边权1，反向边权-1），确保能遍历所有可能的环和链。  
2. **DFS遍历**每个连通块，记录节点距离差计算环长，最终取所有环长的最大公约数（GCD）作为最大可能k值。  
3. 无环时，统计各连通块最长链之和。  

**解决难点**：  
- **相交环处理**：通过反向边权巧妙捕捉不同路径长度差，转化为环长差问题。  
- **数学证明**：确保所有相交环和链的约束条件均能被GCD正确表达（如 `gcd(a, a+b-c) = gcd(a, |b-c|)`）。  

---

### **题解评分 (≥4星)**

1. **StudyingFather (⭐⭐⭐⭐⭐)**  
   - **亮点**：首次提出双向建边策略，数学严谨性高，代码简洁。  
   - **代码**：使用邻接表与DFS递归实现，逻辑清晰。  

2. **water_tomato (⭐⭐⭐⭐)**  
   - **亮点**：详细数学证明相交环的正确性，附示意图辅助理解。  
   - **心得**：“建反向边权为-1是处理链差的核心技巧”。  

3. **Xing_ke (⭐⭐⭐)**  
   - **亮点**：代码注释详细，特别处理了边标记防止重复遍历。  

---

### **最优思路提炼**

1. **双向边权设计**  
   - 正向边权1表示`i→i+1`，反向边权-1表示`i+1→i`，确保能逆向遍历所有路径。  
   - **代码片段**：  
     ```cpp
     add_edge(u, v, 1);  // 正向边
     add_edge(v, u, -1); // 反向边
     ```

2. **环长计算与GCD合并**  
   - DFS时记录节点距离，二次访问时计算环长差并更新全局GCD。  
   - **代码片段**：  
     ```cpp
     if (vis[v]) 
         ans = gcd(ans, abs(dis[u] + w - dis[v]));
     ```

3. **无环最长链统计**  
   - 各连通块内记录最大/最小距离差，累加得总链长。  
   - **代码片段**：  
     ```cpp
     res += maxv - minv + 1; // 连通块最长链长度
     ```

---

### **同类型题推荐**

1. **P2668 斗地主**（搜索策略与状态转移）  
2. **P1141 01迷宫**（连通块统计与BFS）  
3. **P3388 割点**（图的遍历与环检测）  

---

### **可视化与游戏化设计**

**动画方案**：  
1. **节点状态标记**  
   - **待访问**：灰色  
   - **已访问**：绿色  
   - **当前节点**：闪烁红色  

2. **DFS遍历过程**  
   - 递归展开时逐步染色，检测到环时高亮环路径并显示环长。  

3. **复古像素风格**  
   - **8位调色板**：使用NES经典绿/红/蓝配色。  
   - **音效**：  
     - 访问节点：短促“哔”声  
     - 发现环：8-bit胜利音效  

**交互演示**：  
```javascript
// 伪代码示例：Canvas绘制节点
function drawNode(x, y, state) {
    ctx.fillStyle = stateColors[state];
    ctx.fillRect(x*30, y*30, 25, 25); // 像素方块
}
```

---

**核心代码实现**  
```cpp
void dfs(int u, int d) {
    if (dis[u]) {
        ans = gcd(ans, abs(d - dis[u])); // 更新环长GCD
        return;
    }
    dis[u] = d; vis[u] = 1;
    maxv = max(maxv, d); // 更新最大距离
    minv = min(minv, d); // 更新最小距离
    for (auto edge : e[u]) 
        dfs(edge.v, d + edge.w); // 递归遍历
}
```

---

**总结**：通过双向边权设计将复杂环问题转化为数学约束，DFS遍历高效捕捉所有可能路径差，结合GCD实现全局最优解。

---
处理用时：60.18秒
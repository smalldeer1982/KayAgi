# 题目信息

# 埃及分数

## 题目描述

**来源：BIO 1997 Round 1 [Question 3](http://www.olympiad.org.uk/papers/1997/bio/bio97r1q3.html)**

在古埃及，人们使用单位分数的和（形如 $\dfrac{1}{a}$ 的，$a$ 是自然数）表示一切有理数。如：$\dfrac{2}{3} = \dfrac{1}{2} + \dfrac{1}{6}$，但不允许 $\dfrac{2}{3} = \dfrac{1}{3} + \dfrac{1}{3}$，因为加数中有相同的。对于一个分数 $\dfrac{a}{b}$，表示方法有很多种，但是哪种最好呢？首先，加数少的比加数多的好，其次，加数个数相同的，最小的分数越大越好。如：
$$
\begin{aligned}
\frac{19}{45} &= \frac{1}{3} + \frac{1}{12} + \frac{1}{180}\\
\frac{19}{45} &= \frac{1}{3} + \frac{1}{15} + \frac{1}{45}\\
\frac{19}{45} &= \frac{1}{3} + \frac{1}{18} + \frac{1}{30}\\
\frac{19}{45} &= \frac{1}{4} + \frac{1}{6} + \frac{1}{180}\\
\frac{19}{45} &= \frac{1}{5} + \frac{1}{6} + \frac{1}{18}\\
\end{aligned}
$$
最好的是最后一种，因为 $\dfrac{1}{18}$ 比 $\dfrac{1}{180}, \dfrac{1}{45}, \dfrac{1}{30}$ 都大。  
注意，可能有多个最优解。如：
$$
\begin{aligned}
\frac{59}{211} &= \frac{1}{4} + \frac{1}{36} + \frac{1}{633} + \frac{1}{3798}\\
\frac{59}{211} &= \frac{1}{6} + \frac{1}{9} + \frac{1}{633} + \frac{1}{3798}\\
\end{aligned}
$$
由于方法一与方法二中，最小的分数相同，因此二者均是最优解。

给出 $a,b$，编程计算最好的表达方式。保证最优解满足：最小的分数 $\ge \cfrac{1}{10^7}$。 


## 说明/提示

$1 \lt a \lt b \lt 1000$

## 样例 #1

### 输入

```
19 45```

### 输出

```
5 6 18```

# AI分析结果



**算法分类**  
其他搜索（迭代加深搜索）

---

### **题解思路与解决难点**

**核心思路**  
采用迭代加深搜索（IDDFS）结合多重剪枝策略：  
1. **双重迭代加深**：外层控制分数个数，内层控制分母上限（从1e3到1e7每次乘10）
2. **数学优化**：在倒数第二层时，通过解二次方程直接求解最后两个分母
3. **剪枝优化**：上下界剪枝、剩余分数可行性剪枝、分母递增约束

**解决难点**  
1. **搜索空间爆炸**：通过迭代加深和上下界剪枝将搜索范围压缩至合理区间
2. **最优解判定**：在相同层数时，通过维护最小分母确保解的最优性
3. **大数处理**：使用__int128处理可能超过long long范围的分数运算

---

### **题解评分（≥4星）**

1. **王熙文（★★★★★）**  
   - 双重迭代加深+方程求解优化
   - 使用__int128处理大数
   - 通过hack数据验证鲁棒性

2. **Mights（★★★★☆）**  
   - 完整数学推导剪枝条件
   - 详细说明二次方程求解过程
   - 代码可读性较强

3. **CNS_5t0_0r2（★★★★☆）**  
   - 分层剪枝策略清晰
   - 包含特殊数据hack处理
   - 模块化代码结构

---

### **最优思路提炼**

1. **数学优化**：当剩余两个分数时，建立二次方程直接求解，时间复杂度从O(n²)降为O(√n)
```cpp
for(int k=4*b/a/a+1; k<=min(2*S/a,S*S/b); k++){
    int delta = a*a*k*k-4*b*k;
    if(完全平方数判定){
        x = (a*k-sqrt(delta))/2;
        y = (a*k+sqrt(delta))/2;
    }
}
```

2. **双重迭代加深**：同时控制分母最大值和分数个数
```cpp
for(int cnt=1;;cnt++){
    for(int ax=1e3; ax<=1e7; ax*=10){
        dfs(1,a,b,cnt,ax);
        if(找到解) 输出;
    }
}
```

3. **剪枝公式**：通过分数剩余量计算分母上下界
```cpp
int l = max(prev+1, (b+a-1)/a); // 下界
int r = min((cnt-step+1)*b/a, ax); // 上界
```

---

### **同类型题推荐**

1. **P1379 八数码难题**（BFS+哈希判重）
2. **P2324 骑士精神**（IDA*启发式搜索）
3. **P4799 世界冰球锦标赛**（折半搜索+双指针）

---

### **可视化设计**

**动画演示**  
1. **树状展开**：以当前分母为节点，红色标记当前路径，绿色标记最优解路径
2. **剪枝提示**：灰色区域显示被剪枝的分母范围
3. **方程求解**：在倒数第二层时弹出方程求解窗口，动态展示解方程过程

**复古风格**  
```javascript
// 伪代码示例
const pixelStyle = {
    node: '#8B00FF',   // 紫色节点框
    path: '#00FF7F',   // 青绿色路径
    prune: '#696969'    // 深灰剪枝区
};
// 音效配置
const sfx = {
    expand: new Audio('blip.wav'),
    solution: new Audio('victory.wav')
};
```

---

### **核心代码实现**

王熙文题解的关键片段：
```cpp
void dfs(int now,int a,int b) {
    if(now==cnt-1) { // 倒数第二层特殊处理
        int tmp = min(ax*2/a, ax*ax/b);
        for(int k=4*b/a/a+1; k<=tmp; k++){
            int delta = a*a*k*k-4*b*k;
            int sqr = sqrt(delta);
            if(sqr*sqr==delta && (a*k-sqr)%2==0){
                ch[cnt-1] = (a*k-sqr)/2;
                ch[cnt] = (a*k+sqr)/2;
                // 更新最优解
            }
        }
        return;
    }
    // 常规搜索逻辑
    int l = max(ch[now-1]+1, max((b+a-1)/a, b*ax/(a*ax-(cnt-now)*b)));
    int r = min(ax, (cnt-now+1)*b/a);
    for(int i=l; i<=r; i++){
        // 分数约分与递归
    }
}
```

---

### **个人心得摘录**

> "调试中发现分母递增约束的边界条件容易出错，通过打印中间变量的分母范围，最终锁定了一个分母下界计算错误。数学优化部分需要反复验证Δ的完全平方性，用牛顿迭代法辅助验证后发现原题数据存在多个k值满足条件，必须取最小分母。" —— 王熙文题解节选

---

通过综合运用迭代加深、数学优化和多重剪枝，该方案在时间复杂度和空间效率间取得平衡，成功解决埃及分数这一经典难题。

---
处理用时：78.22秒
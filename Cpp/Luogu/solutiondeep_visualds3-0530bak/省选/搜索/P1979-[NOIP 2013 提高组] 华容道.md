# 题目信息

# [NOIP 2013 提高组] 华容道

## 题目背景

NOIP2013 提高组 D2T3

## 题目描述

`小 B` 最近迷上了华容道，可是他总是要花很长的时间才能完成一次。于是，他想到用编程来完成华容道：给定一种局面， 华容道是否根本就无法完成，如果能完成， 最少需要多少时间。

`小 B` 玩的华容道与经典的华容道游戏略有不同，游戏规则是这样的：

1.   在一个 $n \times m$ 棋盘上有 $ n \times m$ 个格子，其中有且只有一个格子是空白的，其余 $ n \times m-1$ 个格子上每个格子上有一个棋子，每个棋子的大小都是 $1 \times 1$ 的；
2.  有些棋子是固定的，有些棋子则是可以移动的；
3.  任何与空白的格子相邻（有公共的边）的格子上的棋子都可以移动到空白格子上。   

游戏的目的是把某个指定位置可以活动的棋子移动到目标位置。

给定一个棋盘，游戏可以玩 $q$ 次，当然，每次棋盘上固定的格子是不会变的， 但是棋盘上空白的格子的初始位置、 指定的可移动的棋子的初始位置和目标位置却可能不同。第 $i$ 次玩的时候， 空白的格子在第 $EX_i$ 行第 $EY_i$ 列，指定的可移动棋子的初始位置为第 $SX_i$ 行第 $SY_i$列，目标位置为第 $TX_i$ 行第 $TY_i$ 列。

假设 `小 B` 每秒钟能进行一次移动棋子的操作，而其他操作的时间都可以忽略不计。请你告诉 `小 B` 每一次游戏所需要的最少时间，或者告诉他不可能完成游戏。


## 说明/提示

**输入输出样例说明**

棋盘上划叉的格子是固定的，红色格子是目标位置，圆圈表示棋子，其中绿色圆圈表示目标棋子。

1.   第一次游戏，空白格子的初始位置是 $(3,2)$（图中空白所示），游戏的目标是将初始位置在 $(1, 2)$ 上的棋子（图中绿色圆圈所代表的棋子）移动到目标位置 $(2, 2)$（图中红色的格子）上。

移动过程如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/n0q385tw.png)

2.  第二次游戏，空白格子的初始位置是 $(1, 2)$（图中空白所示），游戏的目标是将初始位置在 $(2, 2)$ 上的棋子（图中绿色圆圈所示）移动到目标位置  $(3, 2)$ 上。

![](https://cdn.luogu.com.cn/upload/image_hosting/aq9apos0.png)

要将指定块移入目标位置，必须先将空白块移入目标位置，空白块要移动到目标位置，必然是从位置 $(2,2)$ 上与当前图中目标位置上的棋子交换位置，之后能与空白块交换位置的只有当前图中目标位置上的那个棋子，因此目标棋子永远无法走到它的目标位置， 游戏无法完成。

**数据范围**

对于 $ 30\%$ 的数据，$1 ≤ n, m ≤ 10,q = 1$；

对于 $60\%$ 的数据，$1 ≤ n, m ≤ 30,q ≤ 10$；

对于 $100\%$ 的数据，$1 ≤ n, m ≤ 30,q ≤ 500$。


## 样例 #1

### 输入

```
3 4 2
0 1 1 1
0 1 1 0
0 1 0 0
3 2 1 2 2 2
1 2 2 2 3 2```

### 输出

```
2
-1```

# AI分析结果



### 算法分类选择  
**BFS + 图论建模**

---

### 题解思路、算法要点与解决难点  
**核心思路**：  
1. **状态建模**：将「棋子位置 + 空白格方向」编码为三维状态 `(x,y,dir)`，大幅压缩状态空间（从四维降至三维）。
2. **预处理转移边**：通过 BFS 计算空白格绕棋子移动的代价，构建状态转移图。
3. **最短路求解**：将初始空白格移动到棋子周围作为起点，用 SPFA/Dijkstra 求解终点状态的最短路径。

**解决难点**：  
- **状态爆炸**：传统四维状态 `(ex,ey,sx,sy)` 无法应对大数据，三维状态建模将复杂度降至可接受范围。
- **动态边权计算**：通过 BFS 预处理空白格绕棋子移动的步数，避免在线计算的高耗时。
- **高效判重**：利用哈希或压缩编码快速判断状态是否已访问。

---

### 题解评分 (≥4星)  
1. **Starlight_Glimmer (★★★★☆)**  
   - **亮点**：完整状态建模 + SPFA 实现，预处理转移边逻辑清晰，代码可读性高。
   - **核心代码**：  
     ```cpp
     // 预处理空白格绕棋子移动的边权
     int bfs(int dx,int dy,int sx,int sy,int tx,int ty){
         // ... BFS计算不经过棋子的最短路径
     }
     ```

2. **Erutsiom (★★★★☆)**  
   - **亮点**：详细注释 + 状态编号优化，通过 `getnum` 函数将状态压缩为一维整数，便于存储。
   - **核心代码**：  
     ```cpp
     int getnum(int ax,int ay,int t){
         return ((ax-1)*m+ay)*4-(4-t); // 状态压缩
     }
     ```

3. **hkr04 (★★★★☆)**  
   - **亮点**：方向对立优化（`i^2` 快速取反方向），减少冗余计算。
   - **核心代码**：  
     ```cpp
     add(f[x][y][i], f[x+dx[i]][y+dy[i]][i^2], 1); // 交换棋子与空白格
     ```

---

### 最优思路或技巧提炼  
1. **状态压缩**：将三维状态编码为整数，利用数组快速判重。
2. **方向对立优化**：`dir ^ 1` 快速获取相反方向，避免冗余方向判断。
3. **分层BFS**：先预处理空白格移动代价，再构建图模型，分离动态与静态计算。

---

### 同类型题与算法套路  
- **通用解法**：状态空间建模 → 预处理转移代价 → 最短路求解。
- **相似题目**：  
  1. **P1379 八数码难题**（BFS + 状态哈希）  
  2. **P1120 小木棍**（DFS剪枝 + 状态回溯）  
  3. **P1514 引水入城**（BFS + 贪心覆盖）

---

### 可视化与算法演示  
**动画设计**：  
1. **网格绘制**：Canvas 绘制 30x30 棋盘，固定格用深灰色，棋子与空白格用动态色块。
2. **状态扩展**：  
   - **当前状态**：红色高亮棋子 + 蓝色标记空白格方向。  
   - **队列操作**：绿色边框表示待访问节点，灰色边框表示已访问节点。  
   - **路径回溯**：成功时用黄色线条标出最短路径。  

**复古像素风格**：  
- **调色板**：16 色 FC 风格，棋子用绿色像素块，空白格用白色闪烁效果。  
- **音效**：移动时播放 8-bit 音效，成功时触发经典《超级玛丽》过关音效。  

**交互控制**：  
- **步进模式**：空格键单步执行，Enter 键自动播放（速度可调）。  
- **调试面板**：实时显示队列大小、已访问状态数、当前步数。

---

### 核心代码实现  
**预处理空白格移动代价**：  
```cpp
int bfs(int cx, int cy, int sx, int sy, int ex, int ey) {
    // 计算空白格绕过棋子的最短路径
    memset(vis, 0, sizeof(vis));
    queue<pair<int, int>> q;
    q.push({sx, sy});
    vis[sx][sy] = true;
    while (!q.empty()) {
        auto [x, y] = q.front(); q.pop();
        if (x == ex && y == ey) return dis[x][y];
        for (int dir = 0; dir < 4; dir++) {
            int nx = x + dx[dir], ny = y + dy[dir];
            if (nx == cx && ny == cy) continue; // 绕过棋子
            if (vis[nx][ny] || !map[nx][ny]) continue;
            vis[nx][ny] = true;
            q.push({nx, ny});
        }
    }
    return INF;
}
```

**SPFA 实现最短路**：  
```cpp
void spfa(int sx, int sy) {
    memset(dis, 0x3f, sizeof(dis));
    queue<int> q;
    // 初始化起点周围的四个方向状态
    for (int dir = 0; dir < 4; dir++) {
        int nx = sx + dx[dir], ny = sy + dy[dir];
        if (!map[nx][ny]) continue;
        int cost = bfs(sx, sy, ex, ey, nx, ny); // 初始空白格移动代价
        int state = encode(sx, sy, dir);
        dis[state] = cost;
        q.push(state);
    }
    // SPFA 核心
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto [v, w] : graph[u]) {
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                q.push(v);
            }
        }
    }
}
```

---

### 推荐题目  
1. **P1379** - 八数码难题（经典 BFS 状态哈希）  
2. **P1120** - 小木棍（DFS剪枝与状态回溯）  
3. **P1514** - 引水入城（BFS 覆盖分析与贪心结合）

---
处理用时：83.45秒
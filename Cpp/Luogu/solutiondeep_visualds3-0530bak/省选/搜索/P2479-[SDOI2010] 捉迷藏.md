# 题目信息

# [SDOI2010] 捉迷藏

## 题目背景

iPig 在大肥猪学校刚上完了无聊的猪文课，天资聪慧的 iPig 被这门对他来说无比简单的课弄得非常寂寞，为了消除寂寞感，他决定和他的好朋友 giPi（鸡皮）玩一个更加寂寞的游戏——捉迷藏。但是，他们觉得，玩普通的捉迷藏没什么意思，还是不够寂寞，于是，他们决定玩寂寞无比的螃蟹版捉迷藏。


## 题目描述

螃蟹版捉迷藏，顾名思义，就是说他们在玩游戏的时候只能沿水平或垂直方向走。

一番寂寞的剪刀石头布后，他们决定 iPig 去捉 giPi。由于他们都很熟悉大肥猪学校的地形了，所以 giPi 只会躲在大肥猪学校内 $N$ 个隐秘地点之一，显然 iPig 也只会在那 $N$ 个地点内找 giPi。

游戏一开始，他们从这 $N$ 个隐秘地点之中选定一个地点，iPig 保持不动，然后 giPi 用 $30$ 秒的时间逃离现场（显然，giPi 不会呆在原地）。然后 iPig 会随机地去找 giPi，直到找到为止。

由于 iPig 很懒，所以他总是走最短的路径，而且，他选择起始点不是随便选的，他想找一个地点，使得该地点到（除了这个地点以外的）最远的地点和最近的地点的距离差最小。iPig现在想知道这个距离差最小是多少。

由于 iPig 现在手上没有电脑，所以不能编程解决这个如此简单的问题，所以他马上打了个电话，要求你帮他解决这个问题。iPig 告诉了你大肥猪学校的 $N$ 个隐秘地点的坐标，请你编程求出 iPig 的问题。

## 说明/提示

$30\%$ 的数据中，$2\le N\le 10^3$；

$100\%$ 的数据中，$2\le N\le 10^5$，$0\le X_i,Y_i\le 10^9$。

数据保证点不重合。

## 样例 #1

### 输入

```
4
0 0
1 0
0 1
1 1
```

### 输出

```
1```

# AI分析结果



# 题解分析与总结

## 算法分类
**其他搜索**：本题核心在于高效搜索每个点的曼哈顿距离最值，主要采用空间划分（如 KD-Tree）或数学转化优化，而非传统 BFS/DFS。

---

## 题解思路与难点
### 核心思路
1. **曼哈顿距离拆解**  
   曼哈顿距离 $|x_i - x_j| + |y_i - y_j|$ 可拆解为四种形式（如 $(x_i + y_i) - (x_j + y_j)$ 等），通过预处理四个方向的极值（最大/最小），快速计算每个点的最远距离。
   
2. **最近距离优化**  
   利用排序后邻近点枚举（如前后 500 点）或二维偏序结构（线段树/树状数组），避免暴力枚举。

3. **数据结构加速**  
   - **KD-Tree**：构建空间索引树，剪枝搜索最邻近和最远点。
   - **线段树/树状数组**：离散化坐标后维护区间极值，处理不同方向的贡献。

### 解决难点
- **最远距离的高效计算**：通过数学转化，将问题转化为四个方向的极值查询，时间复杂度降至 $O(1)$。
- **最近距离的剪枝**：KD-Tree 的估价函数剪枝或邻近点局部枚举，避免全量计算。
- **坐标离散化与排序**：处理曼哈顿距离拆解后的偏序关系，减少冗余计算。

---

## 题解评分（≥4星）
1. **Wilderness_（5星）**  
   - **亮点**：数学转化预处理极值，邻近点枚举平衡效率与代码复杂度。  
   - **代码**：思路清晰，无需复杂数据结构，实践性强。  
   - **心得**：“发扬人类智慧”体现对问题本质的洞察。

2. **Orina_zju（4星）**  
   - **亮点**：结合数学转化（最远）与 KD-Tree（最近），性能与封装兼顾。  
   - **代码**：结构清晰，但未优化 KD-Tree 的常数。

3. **ModestCoder_（4星）**  
   - **亮点**：树状数组维护二维偏序，四遍 CDQ 分治覆盖所有方向。  
   - **代码**：离散化与树状数组操作紧凑，但需处理多次排序。

---

## 最优思路提炼
**数学转化 + 邻近枚举**：  
1. 预处理四个方向的极值（如 $x+y$、$x−y$ 等），计算最远距离 $O(1)$。  
2. 对每个点，仅枚举排序后前后若干邻近点（如 500 个）计算最近距离，时间复杂度 $O(n)$。

---

## 类似题目推荐
1. **P6247**：最近最远点对（KD-Tree 模板题）。  
2. **P2479**：二维偏序与曼哈顿距离极值。  
3. **CF1093E**：矩形区域查询（二维数据结构应用）。

---

## 可视化设计
### 复古像素风格演示
1. **节点绘制**：  
   - 使用 8 位色块表示点，不同颜色区分已访问/待访问节点。  
   - **Canvas 网格**：坐标离散化后映射到像素网格，动态高亮当前处理点。

2. **动画与音效**：  
   - **搜索过程**：自动播放模式下，KD-Tree 节点按层级展开，伴随“滴”声标记访问。  
   - **极值更新**：极值点闪烁 + 上扬音效，直观展示数学转化效果。

3. **交互控制**：  
   - **速度调节**：滑动条控制动画速度（如 1x/2x/5x）。  
   - **模式切换**：手动步进查看拆解公式，或自动演示完整流程。

```javascript
// 示例代码：Canvas 绘制点与极值
const canvas = document.getElementById('grid');
const ctx = canvas.getContext('2d');
const points = [...]; // 预处理点坐标

function drawPoint(x, y, color = '#FF0000') {
    ctx.fillStyle = color;
    ctx.fillRect(x * 10, y * 10, 8, 8); // 8x8 像素块
}

// 绘制极值方向
points.forEach(p => {
    const dir = calculateDirection(p); // 计算所属方向
    drawPoint(p.x, p.y, ['#FF0000', '#00FF00', '#0000FF', '#FFFF00'][dir]);
});
```

---

## 核心代码片段
### 数学转化法（Wilderness_）
```cpp
int main() {
    // 预处理四个方向极值
    for (int i = 1; i <= n; i++) {
        T[0] = min(T[0], x + y);
        T[1] = min(T[1], x - y);
        T[2] = min(T[2], -x + y);
        T[3] = min(T[3], -x - y);
    }

    // 计算每个点的最远距离
    for (int i = 1; i <= n; i++) {
        int max_d = max({
            (x + y) - T[0],
            (x - y) - T[1],
            (-x + y) - T[2],
            (-x - y) - T[3]
        });
    }

    // 邻近点枚举最近距离
    sort(points.begin(), points.end());
    for (int i = 0; i < n; i++) {
        int min_d = INF;
        for (int j = max(0, i - 500); j < min(n, i + 500); j++) {
            if (i == j) continue;
            min_d = min(min_d, abs(x - px) + abs(y - py));
        }
        ans = min(ans, max_d - min_d);
    }
}
```

---

## 总结
本题通过曼哈顿距离的数学性质与高效数据结构，将暴力 $O(n^2)$ 优化至 $O(n \log n)$ 或 $O(n)$。最优解法结合数学转化与局部搜索，兼具思维深度与代码简洁性，适合举一反三。

---
处理用时：85.84秒
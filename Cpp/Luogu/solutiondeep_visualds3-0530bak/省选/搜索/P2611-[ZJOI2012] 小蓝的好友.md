# 题目信息

# [ZJOI2012] 小蓝的好友

## 题目背景

终于到达了这次选拔赛的最后一题，想必你已经厌倦了小蓝和小白的故事。

为了回馈各位比赛选手，此题的主角是贯穿这次比赛的关键人物——小蓝的好友。

在帮小蓝确定了旅游路线后，小蓝的好友也不会浪费这个难得的暑假。

与小蓝不同，小蓝的好友并不想将时间花在旅游上，而是盯上了最近发行的即时战略游戏——SangoCraft。

但在前往通关之路的道路上，一个小游戏挡住了小蓝的好友的步伐。

## 题目描述


“国家的战争其本质是抢夺资源的战争”是整款游戏的核心理念，这个小游戏也不例外。

简单来说，用户需要在一块 $R\times C$ 的长方形土地上选出一块子矩形。

而系统随机生成了 $N$ 个资源点，第 $i$ 个资源点的坐标为 $(x_i,y_i)$。

位于用户所选的长方形土地上的资源点越多，给予用户的奖励也越多。

悲剧的是，小蓝的好友虽然拥有着极其优秀的能力，但同时也有着极差的 RP，小蓝的好友所选的区域总是没有一个资源点。

终于有一天，小蓝的好友决定投诉这款游戏的制造厂商，为了搜集证据，小蓝的好友想算出至少包含一个资源点的区域的数量。

具体的说，你需要计算有多少个四元组 $(LB,DB,RB,UB)$ 满足 $1\le LB\le RB\le R,1\le DB\le UB\le C$ ，且存在一个 $i$ 使得 $LB\le x_i\le RB,DB\le y_i\le UB$ 均成立。

作为小蓝的好友，这自然是你分内之事。

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，$N\le 50$。
- 对于 $40\%$ 的数据，$N\le 2\times 10^3$。
- 对于 $100\%$ 的数据，$1\le R,C\le 4\times 10^4$，$1\le N\le 10^5$，题目保证资源点的位置两两不同，且位置为随机生成。

## 样例 #1

### 输入

```
5 5 4
1 2
2 3
3 5
4 1
```

### 输出

```
139```

# AI分析结果



## 算法分类
其他搜索

---

## 综合分析与结论

### 核心思路与算法要点
1. **补集转换**：计算总矩形数（$\frac{R(R+1)}{2} \times \frac{C(C+1)}{2}$）减去不含资源点的矩形数。
2. **扫描线技术**：从上往下逐行扫描，维护每列最近的上方资源点高度 $h_i$。
3. **笛卡尔树维护**：以列为键值，以 $h_i$ 为堆值构建大根堆，每个节点贡献为 $(左子树大小+1) \times (右子树大小+1) \times h_i$。
4. **动态数据结构**：使用 FHQ-Treap 支持动态插入/修改操作，利用数据随机性保证时间复杂度为 $O(n \log C)$。

### 解决难点
- **高效维护区间最大值**：通过笛卡尔树的性质，每个节点代表其子树区间的最大值。
- **动态修改与统计**：FHQ-Treap 支持分裂合并操作，在修改列高度后快速维护贡献值。

---

## 题解清单（≥4星）

1. **feecle6418 的 FHQ-Treap 实现（5星）**
   - 代码仅 60 行，核心逻辑清晰
   - 利用 FHQ-Treap 动态维护笛卡尔树
   - 贡献值计算通过 pushup 函数高效实现

2. **ButterflyDew 的笛卡尔树解法（4星）**
   - 详细图解资源点对矩形的影响
   - 提出「每个节点贡献为左右区间组合数」的直观理解
   - 代码实现简洁，维护子树大小和贡献值

3. **wjyyy 的补集转换思路（4星）**
   - 深入分析补集转换的数学原理
   - 结合单调栈与笛卡尔树的思想
   - 包含调试经验与复杂度分析

---

## 最优思路代码实现

### FHQ-Treap 核心代码
```cpp
struct FHQ {
    int root = 1, tot;
    int val[N], ls[N], rs[N], siz[N];
    ll w[N];
    int newnode(int x) {
        siz[++ tot] = 1, w[tot] = val[tot] = x;
        return tot;
    } 
    void pushup(int x) {
        siz[x] = siz[ls[x]] + siz[rs[x]] + 1;
        w[x] = w[ls[x]] + w[rs[x]] 
             + 1ll * val[x] * (siz[ls[x]] + 1) * (siz[rs[x]] + 1);
    }
    int merge(int x, int y) {
        if (!x || !y) return x | y;
        if (val[x] > val[y]) {
            rs[x] = merge(rs[x], y); pushup(x); return x;
        } else {
            ls[y] = merge(x, ls[y]); pushup(y); return y;
        }
    }
    void split(int x, int k, int &l, int &r) { /*...*/ }
};
```

---

## 可视化设计（复古像素风格）

### 动画方案
1. **网格绘制**：Canvas 绘制 $R \times C$ 网格，资源点用红色像素块标记。
2. **扫描线效果**：黄色横线从上至下移动，当前处理行高亮显示。
3. **笛卡尔树可视化**：右侧区域实时显示 Treap 结构，节点显示 $(h_i, 贡献值)$。
4. **音效触发**：
   - `哔~`：扫描线移动到新行
   - `叮~`：Treap 节点更新
   - `锵~`：累计贡献值刷新

### 交互功能
- **步进控制**：空格键单步执行扫描过程
- **自动播放**：Enter 键启动/暂停自动扫描
- **数据面板**：显示当前行号、累计贡献值、Treap 节点数

---

## 相似题目推荐
1. [P4147 玉蟾宫](https://www.luogu.com.cn/problem/P4147)  
   （最大子矩形问题，单调栈经典应用）
2. [P1972 [SDOI2009] HH的项链](https://www.luogu.com.cn/problem/P1972)  
   （区间计数问题，扫描线+树状数组）
3. [P1901 发射站](https://www.luogu.com.cn/problem/P1901)  
   （笛卡尔树典型应用，区间最大值影响）

---
处理用时：70.03秒
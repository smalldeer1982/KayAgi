# 题目信息

# 白金莲花池

## 题目背景

为了让奶牛们娱乐和锻炼，农夫约翰建造了一个美丽的池塘。这个长方形的池子被分成了 $M$ 行 $N$ 列个方格（$1≤M,N≤30$）。一些格子是坚固得令人惊讶的莲花，还有一些格子是岩石，其余的只是美丽、纯净、湛蓝还可能掩藏着宝藏的水。

贝西正在练习芭蕾舞，她站在一朵莲花上，想跳到另一朵莲花上去，她只能从一朵莲花跳到另一朵莲花上，既不能跳到水里，也不能跳到岩石上。

贝西的舞步很像象棋中的马步：每次总是先横向移动一格，再纵向移动两格，或先纵向移动两格，再横向移动一格。最多时，贝西会有八个移动方向可供选择。

约翰一直在观看贝西的芭蕾练习，发现她有时候不能跳到终点，因为中间缺了一些荷叶。于是他想要添加几朵莲花来帮助贝西完成任务，当然莲花不能种在岩石上。


## 题目描述

但是！约翰在种植莲花的时候发现了一件很有趣的事，有些格子是不能直接种植莲花的，原因是……实不相瞒，无法直接种植莲花的格子的泥土中大部分都是货真价实的铂金，正是它们妨碍了莲花的正常生长！而恰好约翰刚刚学到了铂金的开采方法，也有相关的开采工具，而且他还发现开采铂金后的格子就可以正常地种植莲花，不必担心泥土缺失的问题。（由于贝西迫切地想练习，所以约翰不会开采不打算种莲花的铂金格子）

开采铂金很累，就像是种植莲花一样累，它们都会消耗掉约翰 $1$ 点体力（也就是说想把铂金格子变成莲花格子需要 $2$ 点体力），约翰最初有 $P$ 点体力来种植莲花或开采铂金。

请帮助约翰计算至少需要消耗多少体力才能帮助贝西完成任务，这个数字记作 $S$，以及有多少种消耗这些体力的方法能帮助贝西完成任务，这个数字记作 $W_S$；铂金当然是越多越好，请计算在消耗 $S$ 点体力帮助贝西完成任务的同时最多能开采多少铂金，这个数字记作 $G$，以及消耗 $S$ 点体力开采 $G$ 块铂金帮助贝西完成任务的方法数，这个数字记作 $W_G$。

若在 $P$ 点体力内无法帮助到贝西，那么只输出 `-1`。

若在 $S$ 点体力内无法开采铂金，那么第二行只输出 `-1`。

## 说明/提示

约翰可以用开采到的铂金小赚一笔，但如果用多余的体力开采铂金而不往上种莲花的话贝西会很生气！


## 样例 #1

### 输入

```
4 5 6
0 0 0 1 0 0
2 0 0 2 0 0
0 0 5 0 0 0
3 0 0 0 4 0
0 0 2 0 0 0```

### 输出

```
2 2
1 1```

## 样例 #2

### 输入

```
3 3 2
3 5
4 2
0 1```

### 输出

```
-1```

# AI分析结果



---

### **算法分类**
**其他搜索**

---

### **综合分析与结论**
**核心思路**  
题目转化为带权图的最短路径问题。预处理每个莲花节点通过DFS扩展所有可能的跳跃路径，建立邻接表（边权由目标节点类型决定）。随后使用Dijkstra算法求最短路径，同时维护路径数目、铂金数量及方案数。

**难点与解决**  
1. **预处理跳跃路径**：DFS遍历所有可能跳跃路径，将中间莲花视为可跳转的节点，直到遇到水/铂金/岩石。  
2. **状态维护**：Dijkstra中需同时记录最短距离、路径数、最大铂金数及对应方案数，需分层处理松弛条件。  
3. **边权设计**：水节点边权为1（需种莲花），铂金节点边权为2（需开采+种植），岩石不可达。

**可视化设计**  
- **预处理阶段**：以像素网格展示DFS跳跃路径，高亮当前节点，递归过程以颜色标记访问顺序。  
- **Dijkstra阶段**：动画显示优先队列的节点出队顺序，颜色区分已访问/待访问节点，边权以箭头标注。  
- **复古风格**：8位像素风，不同格子类型用颜色区分（水：蓝色，铂金：金色，莲花：绿色，岩石：灰色）。  
- **音效提示**：访问新节点时播放“点击”音效，找到路径时播放胜利音效。

---

### **题解清单（4星）**
1. **作者：251Sec（4星）**  
   - **关键亮点**：  
     - 预处理DFS构建邻接表，准确处理跳跃逻辑。  
     - Dijkstra中高效维护多状态（路径数、铂金数）。  
   - **个人心得**：  
     > “昨天为什么闲的没事在那里敲A*” — 暗示预处理DFS的简洁性优于其他复杂算法。

---

### **代码核心实现**
```cpp
// 预处理DFS：构建邻接表
void dfs(int x, int y, int rx, int ry) {
    vis[pid(x, y)] = true;
    int dx[] = {2, 2, -2, -2, 1, 1, -1, -1};
    int dy[] = {1, -1, 1, -1, 2, -2, 2, -2};
    for (int i = 0; i < 8; i++) {
        int nx = x + dx[i], ny = y + dy[i];
        if (nx < 1 || nx > m || ny < 1 || ny > n) continue;
        int type = mp[pid(nx, ny)];
        if (type == 0) { // 水节点，边权1
            if (!mkd[pid(nx, ny)]) Insert(pid(rx, ry), pid(nx, ny), 1);
            mkd[pid(nx, ny)] = true;
        } else if (type == 5) { // 铂金节点，边权2
            if (!mkd[pid(nx, ny)]) Insert(pid(rx, ry), pid(nx, ny), 2);
            mkd[pid(nx, ny)] = true;
        } else if (type == 1) { // 莲花，递归搜索
            if (!vis[pid(nx, ny)]) dfs(nx, ny, rx, ry);
        }
    }
}

// Dijkstra维护多状态
void Dijkstra() {
    priority_queue<ND> q;
    q.push({pid(sx, sy), 0});
    d[pid(sx, sy)] = 0;
    f[pid(sx, sy)] = 1;
    g[pid(sx, sy)] = 1;
    while (!q.empty()) {
        int u = q.top().num; q.pop();
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].to, w = e[i].w;
            if (d[v] > d[u] + w) { // 发现更短路径
                d[v] = d[u] + w;
                f[v] = f[u];
                pt[v] = pt[u] + (w == 2);
                g[v] = g[u];
                q.push({v, d[v]});
            } else if (d[v] == d[u] + w) { // 路径长度相同
                f[v] += f[u];
                if (pt[v] < pt[u] + (w == 2)) { // 铂金更多则更新
                    pt[v] = pt[u] + (w == 2);
                    g[v] = g[u];
                } else if (pt[v] == pt[u] + (w == 2)) {
                    g[v] += g[u];
                }
            }
        }
    }
}
```

---

### **同类型题与推荐**
- **P1606（白银莲花池）**：简化版，无需处理铂金和多重状态。  
- **P1144（最短路计数）**：最短路径方案数统计。  
- **P3953（逛公园）**：带状态扩展的最短路径问题。

---

### **可视化与游戏化设计**
1. **预处理DFS动画**：  
   - 网格中高亮当前DFS起点，递归展开时用渐变色标记跳跃路径。  
   - 边建立时播放“连接”音效。  
2. **Dijkstra过程**：  
   - 优先队列动态显示，当前节点出队时闪烁，更新相邻节点颜色。  
3. **复古风格**：  
   - Canvas绘制8位网格，音效使用Chip音乐库生成。  
   - 自动演示模式可切换手动/自动，速度可调。  
4. **积分系统**：  
   - 正确找到最短路径得100分，每开采一块铂金加50分，失败扣分。

---
处理用时：180.94秒
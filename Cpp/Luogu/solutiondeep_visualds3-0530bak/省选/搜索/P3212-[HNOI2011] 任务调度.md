# 题目信息

# [HNOI2011] 任务调度

## 题目描述


有 $n$ 个任务和两台机器 A 与 B。每个任务都需要既在机器 A 上执行，又在机器 B 上执行，

第 $i$ 个任务需要在机器 A 上执行时间 $a_i$，且需要在机器 B 上执行时间 $b_i$。最终的目标是所有任务在 A 和 B 上都执行完，且希望执行完所有任务的总时间尽量少。当然问题没有这么简单，有些任务对于先在机器 A 上执行还是先在机器 B 上执行有一定的限制。据此可将所有任务分为三类：

1. 任务必须先在机器 A 上执行完然后再在机器 B 上执行。
2. 任务必须先在机器 B 上执行完然后再在机器 A 上执行。
3. 任务没有限制，既可先在机器 A 上执行，也可先在机器 B 上执行。

现在给定每个任务的类别和需要在机器 A 和机器 B 上分别执行的时间，问使所有任务都能按规定完成所需要的最少总时间是多少。

## 说明/提示

#### 样例 1 解释

一种最优任务调度方案为：

机器 A 上执行的各任务依次安排如下：

任务 $1\ (0\to 5)$，任务 $2\ (5\to 11)$, 任务 $3\ (11\to 13)$；

机器 B 上执行的各任务依次安排如下：

任务 $3\ (0 \to 6)$, 任务 $1\ (6 \to 13)$, 任务 $2\ (13 \to14)$，

这样，所有任务都执行完所需要的总时间为 $14$。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n\le 20$，$1\le a_i\le 10^3$，$1\le t_i\le 3$，并保证 $t_i=3$ 的 $i$ 不超过 $10$ 个。

## 样例 #1

### 输入

```
3
3 5 7
1 6 1 
2 2 6
```

### 输出

```
14```

# AI分析结果



## 算法分类选择  
**其他搜索**  

---

## 综合分析与结论  

### 题解思路与核心难点  
题目要求通过任务调度最小化总时间，核心在于处理类型3任务的执行顺序和两类机器的协调。各题解核心思路与难点如下：  

1. **随机化贪心**  
   - **思路**：枚举类型3任务的执行顺序（先A或B），对每个枚举情况，用贪心策略（如 Johnson 规则）排序任务序列，再通过随机交换相邻任务优化顺序。  
   - **难点**：贪心策略的正确性验证与随机化次数的平衡（避免局部最优且时间可控）。  

2. **状态压缩 DP**  
   - **思路**：将任务分为两个集合（A先执行/B先执行），通过动态规划维护每个集合的最小等待时间，最终合并结果。  
   - **难点**：状态设计需兼顾两机器的相互等待时间，转移方程需精确计算空闲间隙。  

3. **模拟退火**  
   - **思路**：在贪心初始解基础上，通过概率性接受次优解跳出局部最优。  
   - **难点**：温度衰减参数与邻域操作的调整，需多次实验验证参数稳定性。  

### 可视化设计思路  
- **节点表示**：将任务视为节点，用两种颜色区分 A/B 机器的执行顺序。  
- **贪心动画**：展示 Johnson 规则排序过程（如按 `b[i]` 降序排列 A 类任务）。  
- **随机交换**：以高亮显示被交换的任务对，并实时更新总时间对比。  
- **进度条**：展示枚举类型3任务的进度（如 1024 种组合中的当前状态）。  

---

## 题解清单 (≥4星)  

1. **Ameyax 的随机化贪心（5星）**  
   - **亮点**：通过 DFS 枚举类型3任务的所有可能，结合贪心排序与随机交换，代码简洁高效。  
   - **关键代码**：  
     ```cpp  
     void solve() {  
         sort(que_a, que_a + top_a, cmp_a);  // Johnson 规则排序  
         sort(que_b, que_b + top_b, cmp_b);  
         // 随机交换优化  
         for (int cas = 1; cas <= 2000; cas++) {  
             swap(que_a[rand_idx], ...);  
             if (tmp < re) re = tmp;  // 接受更优解  
         }  
     }  
     ```  

2. **a326820068122c 的状态压缩 DP（4星）**  
   - **亮点**：通过 `dpa` 和 `dpb` 状态压缩计算等待时间，理论正确性高。  
   - **关键代码**：  
     ```cpp  
     dpa[i] = min(dpa[i], a[y] + max(dpa[x] - b[y], 0));  
     dpb[i] = min(dpb[i], b[y] + max(dpb[x] - a[y], 0));  
     ```  

3. **No_wonder 的模拟退火（4星）**  
   - **亮点**：结合退火算法优化贪心初始解，参数设置参考性强。  
   - **关键代码**：  
     ```cpp  
     if (temp <= tmp || rand()%10000 > T) tmp = temp;  // 退火接受条件  
     T *= 0.995;  // 温度衰减  
     ```  

---

## 最优思路与技巧提炼  

1. **枚举类型3任务**  
   - **核心**：类型3任务最多 10 个，总共有 2^10=1024 种可能的执行顺序，可暴力枚举。  

2. **贪心排序策略**  
   - **Johnson 规则**：对 A 类任务按 `b[i]` 降序排列，B 类任务按 `a[i]` 降序排列，最小化空闲时间。  

3. **随机化局部优化**  
   - **邻域操作**：随机交换两个任务的位置，若时间更优则保留，否则回退。  

---

## 同类型题与算法套路  

- **流水作业调度问题**：如 [P1248 加工生产调度](https://www.luogu.com.cn/problem/P1248)，需应用 Johnson 规则。  
- **状态压缩优化**：适用于小规模集合枚举，如 [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)。  

---

## 推荐洛谷题目  
1. [P1248 加工生产调度](https://www.luogu.com.cn/problem/P1248)  
2. [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)  
3. [P2324 [SCOI2005] 骑士精神](https://www.luogu.com.cn/problem/P2324)  

---

## 个人心得摘录  
- **Ameyax**：*“枚举类型3任务顺序后，贪心+随机交换 2000 次足够覆盖大部分情况。”*  
- **a326820068122c**：*“状态转移需同时维护两机器的等待时间，避免单视角优化。”*  
- **hgckythgcfhk**：*“正确统计时间需避免机器空闲未被计算，需双向模拟取最大值。”*  

---

## 可视化与算法演示  

### 动画方案设计  
- **网格图**：每个任务显示为方块，A/B 机器分列左右，箭头表示执行顺序。  
- **执行模拟**：动态展示任务在两机器间的流动，高亮当前处理的任务。  
- **时间轴**：显示两机器的累计时间，实时更新最大值。  

### 复古像素风格  
- **颜色方案**：A 类任务用绿色像素块，B 类用红色，类型3用闪烁黄块。  
- **音效**：任务切换时播放 8-bit “滴”声，找到最优解时播放胜利音效。  

```javascript  
// 伪代码示例：Canvas 绘制任务队列  
function drawQueue(ctx, queue, isA) {  
    queue.forEach((task, idx) => {  
        ctx.fillStyle = isA ? "#00FF00" : "#FF0000";  
        ctx.fillRect(x, y + idx * 20, 50, 15);  // 像素化任务块  
    });  
}  
```  

--- 

通过以上分析与可视化设计，可系统理解任务调度的核心逻辑与优化策略。

---
处理用时：134.32秒
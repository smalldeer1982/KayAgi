# 题目信息

# [HNOI2016] 矿区

## 题目描述

平面上的矿区划分成了若干个开发区域。

简单地说，你可以将矿区看成一张连通的平面图，平面图划分为了若干平面块，每个平面块即为一个开发区域，平面块之间的边界必定由若干整点(坐标值为整数的点)和连接这些整点的线段组成。每个开发区域的矿量与该开发区域的面积有关：具体而言，面积为 $ s $ 的开发区域的矿量为 $ s^2 $。

现在有 $ m $ 个开采计划。每个开采计划都指定了一个由若干开发区域组成的多边形，一个开采计划的优先度被规定为矿量的总和÷开发区域的面积和；例如，若某开采计划指定两个开发区域，面积分别为 $ a $ 和 $ b $，则优先度为 $ (a^2+b^2)/(a+b) $。由于平面图是按照划分开发区域边界的点和边给出的，因此每个开采计划也只说明了其指定多边形的边界，并未详细指明是哪些开发区域（但很明显，只要给出了多边形的边界就可以求出是些开发区域）。

你的任务是求出每个开采计划的优先度。为了避免精度问题，你的答案必须按照分数的格式输出，即求出分子和分母，且必须是最简形式（分子和分母都为整数，而且都消除了最大公约数；例如，若矿量总和是 $ 1.5 $，面积和是 $ 2 $，那么分子应为 $ 3 $，分母应为 $ 4 $；又如，若矿量和是 $ 2 $，面积和是 $ 4 $，那么分子应为 
 $ 1 $，分母应为 $ 2 $）。

由于某些原因，你必须依次对每个开采计划求解（即下一个开采计划会按一定格式加密，加密的方式与上一个开采计划的答案有关）。具体的加密方式见输入格式。

## 说明/提示

### 样例解释

输入文件给出的 $9$ 个点和 $14$ 条边描述的平面图如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/cg70enmo.png)

第一个开采计划，输入的第 $1$ 个值为 $3$，所以该开采计划对应的多边形有 $(3+0)\bmod 8+1=4$ 个点，将接下的 $4$ 个数 $3,0,4,7$，分别代入 $(z_i+0)\bmod n+1$ 得到 $4$ 个点的编号为 $4,1,5,8$。计算出第一个开采计划的分子为 $1$，分母为 $1$。

类似地，可计算出余下开采计划的多边形的点数和点的编号：第二个开采计划对应的多边形有 $3$ 个点，编号分别为 $5,6,8$。第三个开采计划对应的多边形有 $6$ 个点，编号分别为 $1,2,6,5,8,4$。第四个开采计划对应的多边形有 $5$ 个点，编号分别为 $1,2,6,8,4$。第五个开采计划对应的多边形有 $6$ 个点，编号分别为 $1,5,6,8,7,4$。

### 数据范围及约定


对于 $ 100 \% $ 的数据，$ n, k \leq 2 \times 10^5, \  m \leq 3n-6, \  |x_i|, |y_i| \leq 3×10^4$。

所有开采计划的 $ d $ 之和不超过 $2 \times 10^6$。保证任何开采计划都包含至少一个开发区域，且这些开发区域构成一个连通块。

保证所有开发区域的矿量和不超过 $ 2^{63}-1 $。

保证平面图中没有多余的点和边。

保证数据合法。由于输入数据量较大，建议使用读入优化。




## 样例 #1

### 输入

```
9 14 5
0 0
1 0
2 0
0 1
1 1
2 1
0 2
1 2
2 2
1 2
2 3
5 6
7 8
8 9
1 4
4 7
5 8
3 6
6 9
4 8
1 5
2 6
6 8
3 3 0 4 7 1 3 4 6 4 8 0 4 3 6 2 3 8 0 4 6 2 5 0 4 5 7 6 3```

### 输出

```
1 1 
1 2 
1 1 
9 10 
3 4```

# AI分析结果



## 唯一算法分类：DFS

## 综合分析与结论

### 核心思路与难点
**核心思路**：将平面图转换为对偶图，通过 DFS 生成树维护子树面积和，利用树边方向动态计算多边形包含的面。

**解决难点**：
1. **平面图转对偶图**：通过极角排序与边遍历划分面，识别无界域（根节点）。
2. **生成树构建**：DFS 遍历对偶图，记录子树面积和与面积平方和。
3. **动态查询处理**：通过树边的父子关系进行容斥，快速计算多边形内的矿量与面积。

### 搜索过程可视化设计
1. **节点扩展**：以根节点（无界域）为起点，DFS 遍历时动态展示子树扩展方向。
2. **颜色标记**：
   - **红色**：当前访问的节点（面）。
   - **绿色**：已加入生成树的边。
   - **蓝色**：待处理的非树边。
3. **步进控制**：单步执行 DFS，显示子树和的累加过程。查询阶段高亮触发的树边，动态更新分子分母。

**复古像素风格设计**：
- **Canvas 网格**：每个面对应为像素块，面积大小映射为块的颜色深浅。
- **音效**：访问新节点时播放“哔”声，触发树边加减时播放“咔嗒”声。
- **自动演示**：AI 模式模拟 DFS 与查询步骤，按空格键暂停/继续。

## 题解清单（评分≥4星）

### 1. 作者：litble（★★★★★）
- **亮点**：详细解释平面图转对偶图的极角排序方法，代码清晰利用 STL 排序与遍历。
- **关键代码**：
  ```cpp
  void build() {
    for(RI i=1;i<=n;++i) sort(h[i].begin(),h[i].end());
    for(RI i=2;i<=tot;++i) {
        int v=e[i].v;
        vector<edge>::iterator kl=lower_bound(h[v].begin(),h[v].end(),e[i^1]);
        if(kl==h[v].begin()) kl=h[v].end();
        --kl,nxt[i]=(*kl).id;
    }
    // ... 后续处理面与生成树
  }
  ```

### 2. 作者：_Sein（★★★★）
- **亮点**：图解生成树容斥原理，强调叉积符号处理无界域。
- **心得摘录**：“面积负值标识无穷面，生成树的方向判断是容斥关键。”

### 3. 作者：Mars_Dingdang（★★★★）
- **亮点**：代码中显式处理分数化简与加密输入，结构清晰。
- **核心代码**：
  ```cpp
  if(f[pos[j]] == pos[j ^ 1]) ans1 += ss[pos[j]], ans2 += s[pos[j]];
  else ans1 -= ss[pos[j ^ 1]], ans2 -= s[pos[j ^ 1]];
  ```

## 最优技巧提炼
1. **极角排序找面**：将每个点的边按极角排序，逆时针遍历闭合区域。
2. **子树和容斥**：通过树边父子关系，加减子树和快速计算多边形内的贡献。
3. **分数处理**：分子分母全程保持整数，避免浮点误差。

## 同类型题推荐
1. **P3244 森林**（生成树动态维护）
2. **P3388 割点**（图的结构分析）
3. **P2056 捉迷藏**（平面图与对偶图应用）

## 核心代码片段
```cpp
// 极角排序与面划分
void build() {
    for(int i=1;i<=n;++i) sort(g[i].begin(), g[i].end());
    for(int i=2;i<=tot;++i) {
        int v = e[i].v;
        auto it = lower_bound(g[v].begin(), g[v].end(), e[i^1]);
        if(it == g[v].begin()) it = g[v].end();
        --it;
        nxt[i] = it->id;
    }
    // ... 面遍历与对偶图构建
}

// DFS生成树与子树和计算
void dfs(int u, int fa) {
    vis[u] = 1;
    for(auto &e : tr[u]) {
        int v = e.v;
        if(vis[v]) continue;
        istr[e.id] = 1;
        dfs(v, u);
        s[u] += s[v];
        ss[u] += ss[v];
    }
}
```

## 可视化实现方案（伪代码）
```javascript
// Canvas绘制面与生成树
function drawFace(face, color) {
    ctx.fillStyle = color;
    ctx.fillRect(face.x * 10, face.y * 10, 10, 10);
}

// DFS动画
function animateDFS(node) {
    drawFace(node, 'red');
    playSound('beep');
    setTimeout(() => {
        for (let child of tree[node]) {
            if (!visited[child]) {
                drawEdge(node, child, 'green');
                animateDFS(child);
            }
        }
    }, 500);
}
```

## 个人心得
“在实现极角排序时，需注意反向边的查找可能位于 vector 末尾，需特殊处理。此外，子树和的累加必须全程保持整数，避免因浮点导致精度问题。” —— litble 题解调试经验

---
处理用时：73.96秒
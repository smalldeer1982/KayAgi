# 题目信息

# [JLOI2014] 天天酷跑

## 题目描述

在游戏天天酷跑中，最爽的应该是超级奖励模式了吧，没有一切障碍，可以尽情的吃金币，现在请你控制游戏角色来获得尽可能多的分数。游戏界面离散为一个长度为 $1 \sim n$，高度为 $1 \sim m$（初始点为 $(0,1)$）的矩阵图。每个格子上都有收益 $(-1 \sim 1000)$，$-1$ 表示该点不能通过。游戏角色从起点一路奔跑向终点，中途可以跳跃来获得更高的分数，在空中还能进行连跳。

游戏开始前你可以设定跳跃的高度，以及能连跳的次数，初始跳跃高度为 $1$，连跳数为 $1$（最多为 $5$），升级跳跃高度和连跳都需要一定的花费。跳跃高度设定完后游戏角色每次跳跃高度都将固定，连跳必须在下落过程中可以使用。所有操作都将在整点上完成，需要保证设定完的跳跃高度及连跳数，无法跳出游戏高度上限。

![](https://cdn.luogu.com.cn/upload/pic/17609.png) 

从 $(1,1)$ 点用一次跳跃，一次经过 $(2,2),(3,3),(4,2),(5,1)$。

以下是连跳数为 $2$ 连跳，跳跃高度为 $2$ 的跳跃方案：

![](https://cdn.luogu.com.cn/upload/pic/17610.png)

从 $(1,1)$ 起跳，依次经过 $(2,2),(3,3),(4,2)$ 再使用连跳，经过 $(5,3),(6,4),(7,3),(8,2),(9,1)$。

![](https://cdn.luogu.com.cn/upload/pic/17611.png)

## 说明/提示

对于 $20 \%$ 的数据，满足 $m=2$，$1 \le n \le 10 ^ 5$。

对于另外 $80 \%$ 的数据，$1 \le n \le 10000$，$2 < m \le 20$，其中有 $20\%$ 的数据保证 $2 < n \le 10$，$1 \le m \le 10$。

## 样例 #1

### 输入

```
7 4 6 10
9 4 7 7 4 3 2
18 8 9 4 15 12 4
19 2 4 7 10 18 12
8 1 13 14 16 0 14```

### 输出

```
67 1 2```

# AI分析结果



## 【算法分类】
其他搜索（记忆化搜索/DFS）

## 【题解思路与解决难点】

### 核心思路
所有题解均采用**记忆化搜索/DP**处理状态转移，核心状态定义为 `f[x][y][k]`，表示在坐标 `(x,y)` 且剩余 `k` 次连跳机会时的最大收益。状态转移分两种方向：
1. **常规移动**：在地面（y=1）时向右移动，空中（y>1）时向右下方移动。
2. **跳跃**：消耗连跳次数，检查跳跃路径上的所有格子是否有障碍，累加收益后转移到跳跃终点。

### 难点对比
1. **枚举条件**：  
   - **错误解法**：部分题解（如 thmyl、DengDuck）的枚举条件为 `h*num < m`，未正确计算最高点。  
   - **正确条件**：应保证跳跃轨迹的最高点 `1 + h*(num+1)` ≤ m，即 `h*(num+1) <= m-1`。  
   - **示例**：若 `h=2, num=2, m=5`，错误条件会允许该组合（2*2=4 <5），但实际最高点为 `1+2*(2+1)=7`，超过 m，故应排除。

2. **跳跃路径验证**：  
   每次跳跃需遍历路径上的所有格子，检查是否存在障碍（-1）。部分题解（如 LJXlalala）用循环检查，若路径中存在障碍则跳过该跳跃。

3. **状态转移优化**：  
   - Flying2018 的 DP 解法使用前缀和优化跳跃收益累加。  
   - 地面重置连跳次数：当 `y=1` 时，剩余连跳次数重置为最大值（如 DengDuck 代码中的 `K=C`）。

### 结论
正确解法需满足：
1. **枚举条件**：`h*(num+1) <= m-1`。
2. **状态转移**：正确处理跳跃路径障碍检查、地面重置连跳次数。
3. **最优选择**：计算收益时扣除跳跃高度和连跳次数的费用。

---

## 【题解清单（≥4星）】
1. **DengDuck（5星）**  
   - **亮点**：正确分析枚举条件，指出原题解中“无法跳出”的深层条件。  
   - **代码**：明确处理地面状态重置连跳次数，枚举条件虽有小误，但思路清晰。

2. **Flying2018（4星）**  
   - **亮点**：DP 解法用前缀和优化跳跃收益累加，逻辑严谨。  
   - **不足**：枚举条件未修正，影响部分数据正确性。

3. **LJXlalala（4星）**  
   - **亮点**：简洁的记忆化搜索实现，明确处理跳跃路径障碍检查。  
   - **不足**：枚举条件未修正。

---

## 【最优思路/技巧提炼】
1. **枚举条件修正**：确保 `h*(num+1) <= m-1`。
2. **状态设计**：三维状态 `(x, y, k)` 表示位置和剩余连跳次数。
3. **跳跃验证**：遍历路径检查障碍，累加收益。
4. **地面重置**：当 `y=1` 时重置剩余连跳次数。

---

## 【同类型题与算法套路】
- **迷宫类搜索**：需处理移动路径中的障碍，如洛谷 P1141。
- **跳跃模拟**：需计算跳跃轨迹，如 LeetCode 45. 跳跃游戏 II。
- **状态转移优化**：使用前缀和加速收益累加。

---

## 【推荐题目】
1. 洛谷 P1141（迷宫 BFS）  
2. 洛谷 P1095（跳跃游戏）  
3. LeetCode 980（不同路径 III，状态压缩 DFS）

---

## 【个人心得摘录】
- **DengDuck**：  
  “机房多人被硬控于条件理解，必须保证跳跃参数设定后无法跳出任何情况。”
- **年华天地**：  
  “原题解条件错误导致某些用例无法覆盖，需仔细推导跳跃轨迹。”

---

## 【可视化设计】
### 搜索过程动画
- **节点表示**：网格中每个格子为节点，颜色标记当前状态（红：当前访问，绿：待访问，灰：已访问）。  
- **跳跃路径**：高亮显示跳跃轨迹，若存在障碍则路径变红。  
- **状态面板**：显示当前 `(x, y, k)` 和累计收益。

### 复古像素风格
- **网格绘制**：Canvas 实现 8-bit 像素网格，格子按收益值填充不同颜色（金币：黄色，障碍：黑色）。  
- **音效**：  
  - 访问节点：短促“哔”声。  
  - 找到最优解：经典 FC 通关音效。  
- **AI 自动演示**：按最优路径自动播放，支持暂停/步进。

---

## 【代码片段】
```cpp
// 正确枚举条件示例（修正后）
for (int num = 1; num <= 5; num++) {
    for (int h = 1; h * (num + 1) <= m - 1; h++) {
        // 计算该组合的收益
    }
}

// 记忆化搜索核心逻辑（DengDuck 修改版）
int Dfs(int X, int Y, int K) {
    if (X > n) return 0;
    if (A[X][Y] == -1) return -Inf;
    int &Ans = F[X][Y][K];
    if (Ans != -1) return Ans;
    Ans = -Inf;
    if (Y == 1) K = C; // 地面重置连跳次数
    if (K > 0 && Y + H <= m) {
        int Flag = 1, Sum = 0;
        for (int i = 1; i < H; i++) {
            if (A[X + i][Y + i] == -1) Flag = 0;
            Sum += A[X + i][Y + i];
        }
        if (Flag) Ans = Sum + Dfs(X + H, Y + H, K - 1);
    }
    Ans = max(Ans, Dfs(X + 1, Y - (Y != 1), K)) + A[X][Y];
    return Ans;
}
```

---
处理用时：280.06秒
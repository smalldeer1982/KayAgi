# 题目信息

# Coloring

## 题目描述

$\text{Snakes}$正在玩游戏，他在一张画有$n*m$个格子的白纸上给方格染色。然而，杂乱无章的染色并不有趣，所以他想出了一个奇怪的问题：


在$n*m$的方格中用$c$种不同的颜色尝试将所有方格染色，不同的颜色用$1..c$间的整数表示。染色需要满足以下条件：


+ 每个方格只能且必须染一种颜色。

+ 第$i$种颜色最多可以且必须染$p_i$个格子，保证满足$\sum_{i=1}^cp_i=n*m$。

+ 将每个格子上下左右与其颜色相同的格子视为位于同一个联通块内，并定义不同联通块之间的方格边的条数为$q$。可参考样例说明。


现在，$\text{Snakes}$想知道，如果给出$n,m,c$以及$p_1..p_c$，你能够构造出的符合条件且$q$尽量小的染色方案。


## 说明/提示

```plain
   |   |   
 2 | 3 | 1 
   +   +---
 2 | 3   3 
   |       
```

对于样例，有$q=4$，其中三条竖边，一条横边。


#### 约定


本题为 Special Judge。


对于每个测试点，将会设置阈值$w$，并保证存在构造使得$q\leq w$。


对于程序输出的答案，我们将会以以下方式计算得分：


$$\begin{matrix}q&score&q&score\\\\ q \leq w&10&1.75w < q \leq 2w&5\\\\ w < q \leq 1.1w&9&2w < q \leq 2.3w&4\\\\ 1.1w < q \leq 1.25w&8&2.3w < q \leq 2.6w&3\\\\ 1.25w < q \leq 1.5w&7&2.6w < q \leq 3w&2\\\\ 1.5w < q \leq 1.75w&6&3w < q \leq 3.5w&1\end{matrix}$$


若$q > 3.5w$，将以 `Wrong Answer` 处理。


比赛时显示的得分即为最后得分。


#### 数据规模


对于$10\%$的数据，有$1\leq n,m\leq 3$，$c\leq 3$。


对于$30\%$的数据，有$1\leq n,m\leq 8$，$c\leq 6$。


对于$50\%$的数据，有$1\leq n,m\leq 15$，$c\leq 25$。


对于$100\%$的数据，有$1\leq n,m\leq 20$，$c\leq 50$，$p_i\leq 20$。


## 样例 #1

### 输入

```
2 3 3
1 2 3```

### 输出

```
2 3 1
2 3 3```

# AI分析结果



# 算法分类：其他搜索（模拟退火）

## 算法分析与题解对比

### 核心思路与解决难点
所有题解均采用**模拟退火算法**，核心步骤包含：
1. **初始解构造**：按行/列顺序填充颜色块，保证满足颜色数量约束
2. **邻域变换**：随机交换两个不同颜色的格子
3. **能量计算**：定义目标函数q值为不同颜色相邻边数
4. **退火策略**：根据exp(-Δq/T)概率接受劣解，逐步降温

**关键优化点对比**：
- **q值增量计算**：优秀题解（如ddwqwq）仅计算交换点周边4*2=8条边的变化，复杂度O(1)；而暴力重算的题解（如3493441984zz）复杂度O(nm)
- **参数调整**：初始温度1e5~1e8，降温速率0.9999~0.99999，通过卡时控制总迭代次数
- **多次退火**：部分题解进行3-5次完整退火过程，配合不同随机种子

### 可视化设计思路（复古像素版）
1. **网格展示**：用16色像素块表示不同颜色，相邻不同色块绘制红色边界线
2. **交换动画**：选中格子时显示闪烁框，交换过程用补间动画平移像素块
3. **q值变化**：右侧面板实时显示当前q值，用折线图记录历史最优值
4. **音效系统**：
   - 交换成功时播放8-bit "ping"声
   - 发现更优解时播放上升音阶
   - 降温阶段添加环境白噪声（随温度降低减弱）

## 高星题解推荐（≥4星）

### 1. ddwqwq（⭐⭐⭐⭐⭐）
- **亮点**：封装map类管理状态，增量计算q值变化
- **核心代码**：
```cpp
void swap(int i, int j, int x, int y) {
    // 仅计算交换点周边变化，O(1)更新q值
    int o_q = 计算原边数; 
    std::swap(a[i][j], a[x][y]);
    int q2 = 计算新边数;
    q = q + q2 - o_q;
}
```

### 2. xzyxzy（⭐⭐⭐⭐）
- **亮点**：随机初始化+多组退火，解决局部最优问题
- **核心参数**：T=1e8, delta=0.99999, 5次退火

### 3. 破忆（⭐⭐⭐⭐）
- **亮点**：映射为线性序列处理，swap优化计算
- **关键代码**：
```cpp
int calc(int id){
    return (上下左右不同边数)*2; // 避免重复计算
}
```

## 算法核心实现
```cpp
// 模拟退火主循环
void SA() {
    double T = 1e5; // 初始温度
    int cur_q = calc(); // 初始能量值
    while(T > 1e-5) {
        // 随机选择两个不同色块
        int x1=rand()%n, y1=rand()%m;
        int x2=rand()%n, y2=rand()%m;
        if(color[x1][y1] == color[x2][y2]) continue;

        // 计算q值变化
        int delta = get_delta(x1,y1,x2,y2); 
        
        if(delta < 0 || exp(-delta/T) > rand()/RAND_MAX) {
            swap(color[x1][y1], color[x2][y2]);
            cur_q += delta;
        }
        T *= 0.9999; // 降温
    }
}
```

## 相似题目推荐
1. **P1337 [JSOI2004]平衡点** - 经典模拟退火应用
2. **P2503 [HAOI2006]均分数据** - 分组优化问题
3. **P3878 [TJOI2010]分金币** - 交换策略最优化

## 调试心得摘录
- "小号交了90遍才过"（3493441984zz）：强调参数调整的重要性
- "now贡献算成负数"（xzyxzy）：警示边界检查的必要性
- "卡时0.9*CLOCKS_PER_SEC"（破忆）：时间分配的优化技巧

---

**可视化演示片段（JS伪代码）**
```javascript
// 像素风格渲染
function drawGrid() {
    ctx.fillStyle = "#2D2D2D"; // 深灰背景
    ctx.fillRect(0,0,w,h);
    
    for(let i=0; i<n; i++) {
        for(let j=0; j<m; j++) {
            // 16色复古调色板
            ctx.fillStyle = COLORS[grid[i][j] % 16]; 
            ctx.fillRect(j*16, i*16, 15, 15);
            
            // 绘制差异边
            if(i>0 && grid[i][j]!=grid[i-1][j]) 
                drawRedLine(j*16, i*16, 'top');
        }
    }
}
```

---
处理用时：69.03秒
# 题目信息

# 我永远喜欢珂朵莉~

## 题目背景

http://sukasuka-anime.com/

戒不掉的珂毒

出不动的分块

 ![](https://cdn.luogu.com.cn/upload/pic/11191.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/11192.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/11193.png) 

哦对了有没有想买BD的珂学家啊？支持一下墨鱼吧~

或者有没有人想来手办众筹啊？


## 题目描述

给珂朵莉一个长为 $n$ 的非负数序列 $a$，支持以下两个操作：

- $\verb!1 l r x!$：把区间 $[l,r]$ 中所有 $x$ 的倍数除以 $x$。
- $\verb!2 l r!$：查询区间 $[l,r]$ 内元素的和。

珂朵莉很可爱，所以你要帮珂朵莉写这个题。


## 说明/提示

### 数据范围及约定

$1 \le n , m \le 10^5$，$0 \le a_i \le 5\times 10^5$，$1 \le x \le 5\times 10^5$。


## 样例 #1

### 输入

```
5 3
1 2 3 4 5
2 1 5
1 1 5 2
2 1 5```

### 输出

```
15
12```

# AI分析结果



## 算法分类
其他搜索（因子预处理的特殊遍历策略）

---

## 题解思路与核心难点

### 核心思路
所有题解均围绕**有限次除法性质**展开：
1. **次数有限性**：每个数最多被除log次，总操作次数O(n log a)
2. **因子预处理**：为每个数x预存其所有因子对应的下标集合
3. **高效结构维护**：
   - **平衡树**：按值域维护因子下标，支持快速区间分割
   - **Vector+二分**：利用有序性二分定位区间，反向删除避免失效元素
4. **和查询优化**：BIT/线段树维护动态区间和

### 解决难点对比
| 方法                | 数据结构         | 核心优化点                                                                 |
|---------------------|------------------|---------------------------------------------------------------------------|
| 平衡树              | FHQ Treap        | O(1)分裂合并区间，遍历子树时动态删除失效节点                               |
| Vector反向删除      | vector+二分      | 利用lower_bound快速定位区间，反向遍历删除避免索引错位                      |
| 并查集跳跃删除      | 并查集           | 预处理每个因子链，通过父指针跳过已删除元素                                 |

---

## 题解评分与亮点

### 4星及以上题解
1. **JRzyh（树状数组+vector，★★★★☆）**
   - 亮点：代码简洁，利用STL lower_bound快速定位区间，反向删除解决vector失效问题
   - 代码：
     ```cpp
     for(vit it=l2; it!=r2; it++) {
         if(a[*it]%x!=0) continue;
         add(*it, -(a[*it]-a[*it]/x));
         a[*it] /= x;
         if(a[*it]%x !=0) t.push_back(it); //记录需删除的迭代器
     }
     for(int i=t.size()-1; i>=0; i--) ys[x].erase(t[i]); //反向删除
     ```

2. **hsfzLZH1（平衡树+树状数组，★★★★★）**
   - 亮点：严格的O(n√a)预处理，笛卡尔树式建树优化空间，遍历时动态维护平衡树结构
   - 核心代码：
     ```cpp
     void dfs(int x, int v) {
         if(!x) return;
         if(a[val[x]]%v ==0) {
             modify(val[x], -a[val[x]] + a[val[x]]/v);
             a[val[x]] /= v;
         }
         if(a[val[x]]%v !=0) q[++len] = val[x]; //记录需保留的节点
         dfs(lc[x],v); dfs(rc[x],v);
     }
     rt[x] = merge(build(1,len,q), merge(l,r)); //重构子树
     ```

3. **zx2003（离线+并查集，★★★★☆）**
   - 亮点：离线处理操作序列，用并查集跳过无效元素，空间优化显著
   - 关键步骤：
     ```cpp
     int pos = lower_bound(fa[x].begin(), fa[x].end(), l);
     while(pos <= r) {
         if(a[pos]%x ==0) update_and_divide();
         fa[x][pos] = find(pos+1); //并查集跳跃
     }
     ```

---

## 可视化算法演示

### BFS式因子遍历动画方案
1. **节点状态标记**：
   - 绿色：当前处理的区间节点
   - 红色：被删除的失效节点
   - 黄色：待处理的候选节点

2. **动画流程**：
   ```mermaid
   sequenceDiagram
    participant 用户输入[l,r,x]
    participant 平衡树 as x的因子平衡树
    participant BIT as 树状数组
    用户输入->>平衡树: 分裂出[l,r]区间子树
    平衡树->>遍历线程: 中序遍历节点
    遍历线程->>BIT: 提交除法操作差值
    loop 节点有效性检查
        遍历线程->>节点: 若a[i]/x仍为x倍数?
        节点-->>平衡树: 是：保留/否：标记为红色
    end
    BIT-->>用户: 返回更新后的区间和
   ```

3. **复古像素化实现**：
   - **Canvas绘制**：每个节点表示为16x16像素块，右侧标注当前值
   - **音效**：除法操作时播放8-bit "blip"音效，删除时播放短促爆破音
   - **自动演示**：按操作顺序自动高亮处理区间，展示平衡树分裂过程

---

## 相似题目推荐
1. **P5610 [Ynoi2013] 大学** - 本题的加强版，需进一步优化常数
2. **P5494 【模板】线段树分裂** - 练习分裂合并数据结构
3. **P3203 [HNOI2010]弹飞绵羊** - 分块跳跃的类似思想

---

## 核心代码实现（平衡树+树状数组）
```cpp
vector<int> factor[500005];
FHQTreap trees[500005]; //每个因子对应一棵Treap

void preprocess() {
    for(int i=1; i<=n; i++) {
        for(int j=1; j*j<=a[i]; j++) {
            if(a[i]%j) continue;
            factor[j].push_back(i);
            if(j*j != a[i]) 
                factor[a[i]/j].push_back(i);
        }
    }
    for(int x=2; x<=5e5; x++) 
        trees[x].build(factor[x]);
}

void divide(int l, int r, int x) {
    auto& t = trees[x];
    int L = t.lower_bound(l);
    int R = t.upper_bound(r);
    auto subtree = t.split(L, R); //分裂出操作区间
    for(int i : subtree) {
        if(a[i]%x ==0) {
            bit.update(i, a[i]/x - a[i]);
            a[i] /= x;
        }
        if(a[i]%x !=0) t.erase(i); //动态维护
    }
}
```

---

通过上述分析，可清晰看出各解法在因子预处理与动态维护上的创新，为处理高复杂度区间操作提供了多种优化思路。

---
处理用时：82.70秒
# 题目信息

# [Code+#2] 白金元首与独舞

## 题目背景

```cpp
到河北省 见斯大林 / 在月光下 你的背影 / 让我们一起跳舞吧
```
うそだよ~ 河北省怎么可能有 Stalin。


可是…… 可是如果 Stalin 把自己当作炸弹扔到地堡花园里来了呢？


怀揣着这份小小的希望，元首 Adolf 独自走进了花园。终有一天会重逢的吧，Stalin。或许是在此处，或许是在遥远的彼方。


无论如何，在此之前，好好装点一番花园，编排一段优美的舞步吧！


## 题目描述

元首把花园分为 $n$ 行 $m$ 列的网格。每个格子中都可以放置一个标识，指向上、下、左、右四个方向中的任意一个。元首位于一个格子时，会按照其中标识所指的方向进入周围的格子，或者走出花园（即目的格子不在网格之内）。举个例子 —— 对于下面的放置方式，元首从第 $3$ 行第 $2$ 列的格子开始，会沿着以红色标出的路径走出花园；从第 $2$ 行第 22 列的格子开始，则会在以蓝色标出的环路内不断地行走。

 ![](https://cdn.luogu.com.cn/upload/pic/12659.png) 

元首已经设计好了大部分格子的标识。元首用字符 L、R、U、D 分别表示指向左、右、上、下四个方向的标识，用字符 . 表示未决定的格子。现在，元首希望将每个 . 替换为 L、R、U、D 中任意一种，使得从花园中的任意一个格子出发，按照上述规则行走，都可以最终走出花园。


你需要编写程序帮助元首计算替换的不同方案数。两个方案不同当且仅当存在一个格子，使得两个方案中该格子内的标识不同。当然，由于答案可能很大，只需给出方案数除以 $10^9 + 7$所得的余数即可。


## 说明/提示

**样例解释**

第 $1$ 组数据中，将惟一的 . 替换成 R、U 或 D 均满足要求。


第 $2$ 组数据中，将左上方和右下方的两个 . 分别替换成 LR、LU、LD、UR、UU、UD、DR 或 DD 均满足要求。


第 $3$ 组数据中，没有待决定的格子，原本的安排会使得元首陷入无尽的环路，故答案为 $0$。该组数据与**题目描述**中的例子相同。


第 $4$ 组数据中，也没有待决定的格子，但原本的安排已经满足要求，故答案为 $1$。


令 $k$ 表示标记未确定（即包含 “.”）的格子总数。


对于所有数据，有 $1 \leq T \leq 10$，$1 \leq n, m \leq 200$，$0 \leq k \leq \min(nm, 300)$。

 ![](https://cdn.luogu.com.cn/upload/pic/12660.png) 

“... wie Stalin!”


题面与史实无关。


来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/吕时清 命题/吕时清 验题/王聿中，杨景钦

Git Repo：https://git.thusaac.org/publish/CodePlus201712

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
5
3 9
LLRRUDUUU
LLR.UDUUU
LLRRUDUUU
4 4
LLRR
L.LL
RR.R
LLRR
4 3
LRD
LUL
DLU
RDL
1 2
LR
2 2
..
..```

### 输出

```
3
8
0
1
192```

# AI分析结果



### 算法分类
**其他搜索**

---

### 题解思路与难点分析

#### 核心思路
1. **问题转化**：将网格中的每个点视为图中的节点，方向为有向边。最终合法方案需构成以“外部虚点”为根的**内向树**（所有边指向根）。
2. **缩点优化**：仅保留未确定方向（`.`）的点与虚点，预处理每个点在不同方向下的首个未确定点或虚点，将问题规模从 $O(nm)$ 降至 $O(k)$。
3. **矩阵树定理**：通过基尔霍夫矩阵（入度矩阵-邻接矩阵）求有向图生成树数目，时间复杂度 $O(k^3)$。

#### 解决难点
- **循环检测**：DFS 检查已确定方向的点是否形成环，存在环则直接输出 0。
- **路径压缩**：记忆化搜索预处理每个点的最终连接点，避免重复计算。
- **基尔霍夫矩阵构建**：仅处理未确定点间的边，大幅减少矩阵规模。

---

### 题解评分（≥4星）

1. **shadowice1984（5星）**  
   - 思路清晰，详细解释了缩点与矩阵树定理的结合。
   - 代码实现完整，包含循环检测与记忆化预处理。
   - 复杂度优化明确，适合大规模数据。

2. **Rainybunny（4星）**  
   - 代码简洁，高效实现缩点与矩阵树定理。
   - 预处理逻辑与矩阵构建部分更易理解。
   - 缺少详细注释，但对关键步骤（如 `findUnknown`）实现巧妙。

---

### 最优思路与技巧
1. **缩点技巧**：通过预处理将每个未确定点的移动路径压缩到首个关键点，避免处理全图。
2. **记忆化搜索**：加速路径查询，确保预处理时间复杂度为 $O(nm)$。
3. **基尔霍夫矩阵简化**：仅保留未确定点间的边，矩阵规模从 $4 \times 10^4$ 降至 $300$。

---

### 类似题目
1. **P4208 [JSOI2008]最小生成树计数**（生成树计数）
2. **P3389 【模板】高斯消元法**（矩阵运算优化）
3. **P2144 [FJOI2007]轮状病毒**（基尔霍夫矩阵应用）

---

### 代码核心片段
```cpp
// 记忆化搜索：查找点 (px, py) 的最终连接点
int dfs(int px, int py) {
    if (px <1 || px>n || py<1 || py>m) return ctt; // 虚点
    if (tr[px][py] != 0) return tr[px][py]; // 已处理
    switch(mde[px][py]) {
        case 'L': tr[px][py] = dfs(px+dx[0], py+dy[0]); break;
        // 类似处理 R, U, D
    }
    return tr[px][py];
}

// 构建基尔霍夫矩阵
for (int i=1; i<=n; i++)
    for (int j=1; j<=m; j++)
        if (mde[i][j] == '.')
            for (int k=0; k<4; k++)
                add(tr[i][j], dfs(i+dx[k], j+dy[k]));

// 高斯消元求行列式
ll det() { /* ... */ }
```

---

### 可视化与算法演示

#### 动画设计
1. **网格绘制**：以 8-bit 像素风格显示网格，已确定点用方向箭头，未确定点用闪烁方块。
2. **路径追踪**：点击未确定点后，展示其四个方向的移动路径，最终指向虚点或其他未确定点。
3. **矩阵动态更新**：右侧同步显示基尔霍夫矩阵，高亮当前操作的行列，颜色标记非零元素。
4. **音效提示**：
   - **路径发现**：短促“哔”声。
   - **生成树完成**：8-bit 胜利音效。

#### 交互功能
- **步进控制**：逐帧展示高斯消元过程，用户可调整速度。
- **自动演示**：AI 模式自动选择未确定点并展示缩点流程。
- **复古风格**：使用 16 色调色板，节点用 16x16 像素块，背景循环播放芯片音乐。

---

### 个人心得
- **缩点是关键**：直接处理全图矩阵不可行，必须通过预处理减少规模。
- **方向处理细节**：未确定点的四个方向需独立处理，确保生成树包含所有可能路径。
- **行列式符号**：高斯消元时需跟踪行交换次数，避免结果符号错误。

---
处理用时：70.63秒
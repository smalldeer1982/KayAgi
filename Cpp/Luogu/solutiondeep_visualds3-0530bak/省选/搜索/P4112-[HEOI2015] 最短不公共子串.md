# 题目信息

# [HEOI2015] 最短不公共子串

## 题目描述

在虐各种最长公共子串、子序列的题虐的不耐烦了之后，你决定反其道而行之。

下面给出一些定义：

- 一个串的“子串”指的是它的连续的一段，例如 `bcd` 是 `abcdef` 的子串，但 `bde` 不是。
- 一个串的“子序列”指的是它的可以不连续的一段，例如 `bde` 是 `abcdef` 的子串，但 `bdd` 不是。

下面，给两个小写字母串 $a, b$，请你计算：

1. $a$ 的一个最短的子串，它不是 $b$ 的子串。
2. $a$ 的一个最短的子串，它不是 $b$ 的子序列。
3. $a$ 的一个最短的子序列，它不是 $b$ 的子串。
4. $a$ 的一个最短的子序列，它不是 $b$ 的子序列。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $20$。
- 对于 $50\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $500$。
- 对于 $100\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $2000$。


## 样例 #1

### 输入

```
aabbcc
abcabc```

### 输出

```
2
4
2
4```

## 样例 #2

### 输入

```
aabbcc
aabbcc```

### 输出

```
-1
-1
2
-1```

# AI分析结果



**唯一算法分类**: BFS

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
题目要求找到四种最短不公共子结构，需结合**自动机**与**BFS**：
- **自动机**：利用后缀自动机（SAM）处理子串，序列自动机处理子序列。
- **BFS**：同时遍历两个自动机状态，寻找第一个失配的转移路径长度。

#### **算法要点**
1. **自动机构建**：
   - **后缀自动机**：构建复杂度 O(n)，用于快速判断子串存在性。
   - **序列自动机**：构建复杂度 O(n·Σ)，用于快速判断子序列存在性。
2. **BFS设计**：
   - **状态定义**：记录两个自动机的当前状态（如节点编号）。
   - **转移规则**：对每个字符尝试转移，若在A中存在但B中不存在，则找到答案。
   - **剪枝优化**：使用`vis`数组避免重复状态访问，时间复杂度 O(n²·Σ)。

#### **解决难点**
- **自动机正确性**：确保后缀自动机正确表示所有子串，序列自动机覆盖所有子序列。
- **BFS效率**：通过`vis`数组避免重复状态访问，确保每个状态仅入队一次。

---

### **题解评分 (≥4星)**

1. **UniverseofHK (5星)**  
   - **亮点**：代码高度统一，四个问题共用一个BFS框架；自动机与BFS结合巧妙，复杂度严格 O(n·Σ)。  
   - **代码示例**：
     ```cpp
     void bfs(int f1, int f2) {
         memset(vis, 0, sizeof(vis));
         queue<P> q;
         q.push({f1, f2, 0}); vis[f1][f2] = 1;
         while (!q.empty()) {
             P now = q.front(); q.pop();
             for (int i=0; i<26; ++i) if (ch[0][f1][now.a][i]) {
                 if (ch[1][f2][now.b][i]) {
                     int a = ch[0][f1][now.a][i], b = ch[1][f2][now.b][i];
                     if (!vis[a][b]) vis[a][b] = 1, q.push({a, b, now.c+1});
                 } else return (void)printf("%d\n", now.c+1);
             }
         }
         printf("-1\n");
     }
     ```

2. **Ebola (4.5星)**  
   - **亮点**：独立处理四个问题，代码结构清晰；SAM与序列自动机分离，便于理解。  
   - **关键代码**：
     ```cpp
     int BFS1() {
         queue<THIRD> q;
         q.push(THIRD(1,1,0)); vis[1][1] = 1;
         while (!q.empty()) {
             int ra = q.front().a, rb = q.front().b, st = q.front().step;
             for (int i=0; i<26; ++i) {
                 int va=SA.ch[ra][i], vb=SB.ch[rb][i];
                 if (va && vb) {
                     if (vis[va][vb] == 1) continue;
                     q.push(THIRD(va,vb,st+1)); vis[va][vb] = 1;
                 }
                 if (va && !vb) return st+1;
             }
             q.pop();
         }
         return -1;
     }
     ```

3. **lhm_ (4星)**  
   - **亮点**：使用后缀自动机与序列自动机结合BFS，状态转移逻辑简洁。  
   - **代码片段**：
     ```cpp
     int query() {
         memset(vis, 0, sizeof(vis));
         queue<node> q;
         q.push({A.root, B.root, 0}); vis[A.root][B.root] = true;
         while (!q.empty()) {
             node now = q.front(); q.pop();
             for (int i=1; i<=26; ++i) {
                 int a = A.ch[now.a][i], b = B.ch[now.b][i];
                 if (vis[a][b]) continue;
                 if (a && !b) return now.len + 1;
                 vis[a][b] = true;
                 q.push({a, b, now.len + 1});
             }
         }
         return -1;
     }
     ```

---

### **最优思路或技巧提炼**

1. **状态压缩**：将自动机节点编号作为状态，避免字符串重复匹配。
2. **双队列同步转移**：BFS中同时维护两个自动机的当前状态，确保路径最短。
3. **自动机复用**：对A和B分别构建两种自动机，解决四个问题仅需四次BFS。

---

### **同类型题推荐**

1. **P3975 [TJOI2015]弦论**  
   - **相似点**：后缀自动机应用，统计子串出现次数。
2. **P5826 子序列自动机模板题**  
   - **相似点**：序列自动机基础应用。
3. **P2414 阿狸的打字机**  
   - **相似点**：自动机与BFS结合，处理多模式匹配。

---

### **个人心得摘录**

- **UniverseofHK**提到：“BFS状态记录二维状态，虽然路径不同但后续转移相同，因此只需记录是否访问过。”  
  → **启示**：状态抽象是优化搜索的关键。
- **Flandre_495**强调：“序列自动机的构造必须保证每个字符尽可能靠前，否则可能导致错误的最短路径。”  
  → **踩坑点**：自动机构建顺序影响正确性。

---

### **可视化与算法演示**

#### **动画方案设计**
1. **节点绘制**：  
   - 使用Canvas绘制网格，每个节点表示自动机状态对 (A_state, B_state)。
   - **颜色标记**：绿色为已访问，红色为当前节点，灰色为未访问。

2. **BFS过程**：  
   - **初始状态**：队列中压入 (A_root, B_root)。
   - **步进动画**：每次从队列取出节点，尝试所有字符转移，若B无法转移则高亮显示答案。
   - **音效触发**：找到答案时播放胜利音效，队列空时播放失败音效。

3. **复古像素风格**：  
   - **调色板**：使用8位风格颜色（如#00FF00表示活跃节点）。
   - **音效设计**：转移时播放“哔”声，答案发现时播放“叮咚”声。

#### **交互功能**
- **步进控制**：支持暂停/继续、单步执行。
- **速度调节**：滑动条控制动画速度（100ms~2s）。
- **自动演示**：AI自动运行BFS，展示扩展过程。

#### **代码片段（Canvas示例）**
```javascript
// 绘制节点
function drawNode(x, y, state) {
    ctx.fillStyle = state === 'active' ? '#FF0000' : '#00FF00';
    ctx.fillRect(x * 30, y * 30, 25, 25);
}

// BFS单步执行
function bfsStep() {
    if (queue.length === 0) {
        playSound('fail'); return;
    }
    const {a, b, len} = queue.shift();
    for (const c of 'abcdef') {
        const nextA = automataA[a].trans[c];
        const nextB = automataB[b].trans[c];
        if (nextA && !nextB) {
            playSound('win');
            highlightAnswer(len + 1);
            return;
        }
        if (nextA && nextB && !vis[nextA][nextB]) {
            vis[nextA][nextB] = true;
            queue.push({a: nextA, b: nextB, len: len + 1});
        }
    }
    drawGrid();
}
```

---

### **总结**
通过自动机与BFS的结合，高效解决多模式子结构匹配问题。关键点在于状态管理和剪枝优化，确保算法在O(n²·Σ)复杂度内完成。可视化设计通过复古像素动画与交互式步进，直观展示搜索过程。

---
处理用时：87.17秒
# 题目信息

# [NOI2006] 最大获利

## 题目描述

新的技术正冲击着手机通讯市场，对于各大运营商来说，这既是机遇，更是挑战。THU 集团旗下的 CS&T 通讯公司在新一代通讯技术血战的前夜，需要做太多的准备工作，仅就站址选择一项，就需要完成前期市场研究、站址勘测、最优化等项目。

在前期市场调查和站址勘测之后，公司得到了一共 $N$ 个可以作为通讯信号中转站的地址，而由于这些地址的地理位置差异，在不同的地方建造通讯中转站需要投入的成本也是不一样的，所幸在前期调查之后这些都是已知数据：建立第 $i$ 个通讯中转站需要的成本为 $P_i$（$1 \leq i \leq N$）。

另外公司调查得出了所有期望中的用户群，一共 $M$ 个。关于第 $i$ 个用户群的信息概括为 $A_i$，$B_i$ 和 $C_i$ ：这些用户会使用中转站 $A_i$ 和中转站 $B_i$ 进行通讯，公司可以获益 $C_i$。（$1 \leq i \leq M$，$1 \leq A_i, B_i \leq N$）

THU 集团的 CS&T 公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益（获益之和）。那么如何选择最终建立的中转站才能让公司的净获利最大呢？（净获利 = 获益之和 – 投入成本之和）


## 说明/提示

样例：选择建立 $1,2,3$ 号中转站，则需要投入成本 $6$，获利为 $10$，因此得到最大收益 $4$。

$100\%$ 的数据中：$N \leq 5\,000$，$M \leq50\,000$，$0 \leq C_i \leq 100$，$0 \leq P_i  \leq 100$。


## 样例 #1

### 输入

```
5 5
1 2 3 4 5
1 2 3
2 3 4
1 3 3
1 4 2
4 5 3```

### 输出

```
4```

# AI分析结果



### 算法分类选择  
**其他搜索**（基于网络流最小割模型，属于图论中的流算法应用）

---

### 题解思路与解决难点  
**核心思路**：将问题转化为最大权闭合子图模型，通过构造网络流图，计算最小割得到最优解。  
**算法要点**：  
1. **最大权闭合子图**：用户群（正权点）依赖中转站（负权点），构成闭合关系。  
2. **网络流建图**：  
   - 源点连用户群，容量为收益。  
   - 用户群连中转站，容量为无穷大（强制依赖关系）。  
   - 中转站连汇点，容量为成本。  
3. **最小割与答案**：最小割对应需要放弃的收益或必须支付的费用，总收益减去最小割即为最大净获利。  

**解决难点**：  
- 正确建模用户群与中转站的依赖关系（无穷大边确保不割断依赖链）。  
- 理解最小割的意义：割掉用户边（放弃收益）或中转站边（支付成本）。  

---

### 题解评分 (≥4星)  
1. **作者：attack（4.5星）**  
   - 直接点明最大权闭合子图模型，代码简洁。  
   - 用Dinic算法高效处理大规模数据。  
   - 代码注释清晰，变量命名规范。  

2. **作者：sunqihuan（4星）**  
   - 详细推导闭合子图与最小割的关系。  
   - 提供样例图的网络流构建示例，便于理解。  

3. **作者：Filberte（4星）**  
   - 结合经典问题（太空飞行计划）对比，强化模型理解。  
   - 代码结构清晰，包含完整Dinic实现。  

---

### 最优思路与技巧提炼  
**关键技巧**：  
- **闭合子图建模**：用户群作为正权点，中转站作为负权点，依赖关系通过无穷大边强制绑定。  
- **最小割计算**：用Dinic算法求最大流，总收益减最大流即答案。  
- **代码优化**：链式前向星存图，分层BFS加速增广。  

**代码片段（Dinic核心逻辑）**：  
```cpp
bool bfs() {
    memset(dep, -1, sizeof(dep));
    queue<int> q;
    q.push(s); dep[s] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            if (e[i].w && dep[v] == -1) {
                dep[v] = dep[u] + 1;
                q.push(v);
                if (v == t) return true;
            }
        }
    }
    return false;
}

int dfs(int u, int flow) {
    if (u == t) return flow;
    int res = 0;
    for (int &i = cur[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (e[i].w && dep[v] == dep[u] + 1) {
            int f = dfs(v, min(flow, e[i].w));
            e[i].w -= f; e[i^1].w += f;
            res += f; flow -= f;
            if (!flow) break;
        }
    }
    return res;
}
```

---

### 同类型题与算法套路  
**类似问题**：  
- 项目选择问题（依赖资源与收益）。  
- 依赖任务调度（需完成前置任务）。  

**通用解法**：  
1. **建模为闭合子图**：正权点为收益项，负权点为成本项。  
2. **网络流求最小割**：源点连正权点，汇点连负权点，依赖边无穷大。  

---

### 推荐相似题目  
1. **P2762 太空飞行计划问题**（最大权闭合子图模板题）。  
2. **P2774 方格取数问题**（二分图最小割模型）。  
3. **P3355 骑士共存问题**（棋盘覆盖与网络流结合）。  

---

### 可视化与算法演示  
**动画设计**：  
1. **节点与边展示**：  
   - 用户群节点（绿色），中转站节点（红色），源汇点（蓝/黄）。  
   - 依赖边用高亮箭头表示，容量为无穷大。  
2. **割的交互演示**：  
   - 点击割断用户边（红色闪烁），显示放弃收益。  
   - 点击割断中转站边（黄色闪烁），显示支付成本。  
3. **实时计算净收益**：动态更新总收益与当前割的损失。  

**复古像素风格**：  
- 8位像素节点，边用点阵箭头连接。  
- 音效：割边时播放“哔”声，计算完成时播放胜利音效。  

---

### 个人心得摘录  
- **调试经验**：初始化时漏掉反向边容量导致WA，需注意对称加边。  
- **思维误区**：曾误将中转站连源点，后通过样例反推正确方向。  

---

### 完整代码（Dinic实现）  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF = 0x3f3f3f3f, N = 55005, M = 400005;

struct Edge { int to, next, w; } e[M];
int head[N], cur[N], dep[N], cnt = 1;
int n, m, s, t, sum;

void add(int u, int v, int w) {
    e[++cnt] = {v, head[u], w}; head[u] = cnt;
    e[++cnt] = {u, head[v], 0}; head[v] = cnt;
}

bool bfs() {
    memset(dep, 0, sizeof(dep));
    queue<int> q; q.push(s); dep[s] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].to;
            if (e[i].w && !dep[v]) {
                dep[v] = dep[u] + 1;
                q.push(v);
                if (v == t) return true;
            }
        }
    }
    return false;
}

int dfs(int u, int flow) {
    if (u == t) return flow;
    int res = 0;
    for (int &i = cur[u]; i; i = e[i].next) {
        int v = e[i].to;
        if (e[i].w && dep[v] == dep[u] + 1) {
            int f = dfs(v, min(flow, e[i].w));
            e[i].w -= f; e[i^1].w += f;
            res += f; flow -= f;
            if (!flow) break;
        }
    }
    return res;
}

int dinic() {
    int res = 0;
    while (bfs()) {
        memcpy(cur, head, sizeof(head));
        res += dfs(s, INF);
    }
    return res;
}

int main() {
    scanf("%d%d", &n, &m);
    s = 0, t = n + m + 1;
    for (int i = 1, p; i <= n; i++) {
        scanf("%d", &p);
        add(i, t, p);
    }
    for (int i = 1, a, b, c; i <= m; i++) {
        scanf("%d%d%d", &a, &b, &c);
        sum += c;
        add(s, i + n, c);
        add(i + n, a, INF);
        add(i + n, b, INF);
    }
    printf("%d\n", sum - dinic());
    return 0;
}
```

---
处理用时：101.59秒
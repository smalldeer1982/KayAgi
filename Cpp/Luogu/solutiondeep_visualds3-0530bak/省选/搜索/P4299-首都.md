# 题目信息

# 首都

## 题目描述

在 X 星球上有 $n$ 个国家，每个国家占据着 X 星球的一座城市，城市从 $1$ 至 $n$ 编号。由于国家之间是敌对关系，所以不同国家的两个城市是不会有公路相连的。

X 星球上战乱频发，如果 A 国打败了 B 国，那么 B 国将永远从这个星球消失，而 B 国的国土也将归 A 国管辖。A 国国王为了加强统治，会在 A 国和 B 国之间修建一条公路，即选择原 A 国的某个城市和 B 国某个城市，修建一条连接这两座城市的公路。

同样为了便于统治自己的国家，国家的首都会选在某个使得其他城市到它距离之和最小的城市，这里的距离是指需要经过公路的条数，如果有多个这样的城市，编号最小的将成为首都。

现在告诉你发生在 X 星球的战事，需要你处理一些关于国家首都的信息，具体地，有如下3种信息需要处理：

- `A x y`：表示某两个国家发生战乱，战胜国选择了 $x$ 城市和 $y$ 城市，在它们之间修建公路（保证其中城市一个在战胜国另一个在战败国）。
- `Q x`：询问当前编号为 $x$ 的城市所在国家的首都。
- `Xor`：询问当前所有国家首都编号的异或和。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times 10^5$，$1 \leq x, y \leq n$。

## 样例 #1

### 输入

```
10 10 
Xor 
Q 1 
A 10 1 
A 1 4 
Q 4 
Q 10 
A 7 6 
Xor 
Q 7 
Xor```

### 输出

```
11 
1 
1 
1 
2 
6 
2 
```

# AI分析结果



# 首都问题题解分析

## 算法分类：其他搜索（动态树维护）

---

### 题解思路与核心算法

**核心问题**：动态维护森林中每棵树的重心，支持合并与查询操作。

**核心算法**：Link-Cut Tree (LCT) 结合重心的性质，利用并查集快速定位重心。

---

### 关键要点与难点对比

#### **FlashHu题解（⭐️⭐️⭐️⭐️⭐️）**
- **要点**：
  1. **重心路径性质**：合并后的新重心必在原两棵树的重心路径上。
  2. **LCT维护子树信息**：通过`access`和`splay`操作提取路径，二分查找新重心。
  3. **时间复杂度**：均摊 $O(n \log n)$，利用LCT的路径操作和并查集优化。
- **难点**：
  - LCT中虚子树大小的动态维护（`siz`和`sum`的计算）。
  - 路径上二分查找时需处理奇偶性及编号最小约束。

#### **jerry3128题解（⭐️⭐️⭐️⭐️）**
- **要点**：
  1. **虚儿子维护**：用平衡树优化最大虚子树查询。
  2. **递归搜索策略**：沿实链二分后递归检查虚子树。
- **难点**：
  - 虚儿子维护需特殊数据结构（如multiset），实现复杂度高。

#### **Refined_heart题解（⭐️⭐️⭐️⭐️）**
- **要点**：
  1. **Splay中序遍历特性**：利用深度顺序进行二分查找。
  2. **动态维护子树大小**：`pushup`和`pushdown`保证数据一致性。
- **难点**：
  - 正确计算路径两侧的子树大小（`lsum`和`rsum`的动态更新）。

#### **其他题解共性**
- **启发式合并**：将小树合并到大树，每次调整重心，复杂度 $O(n \log^2 n)$。
- **并查集加速**：快速查询当前树的重心。

---

### 最优思路提炼

1. **重心路径性质**：合并后的重心必在原重心路径上，直接提取路径进行搜索。
2. **LCT子树维护**：维护虚子树大小（`siz`）和实子树大小（`sum`），确保动态计算正确。
3. **路径二分策略**：
   ```cpp
   int update(int x) {
       int lsum = 0, rsum = 0, sum = s[x] >> 1;
       while (x) {
           pushdown(x);
           int nowl = s[lc] + lsum, nowr = s[rc] + rsum;
           if (nowl <= sum && nowr <= sum) return x; // 找到重心
           if (nowl < nowr) lsum += s[lc] + siz[x] + 1, x = rc;
           else rsum += s[rc] + siz[x] + 1, x = lc;
       }
   }
   ```
4. **并查集优化**：合并后更新重心，异或和动态维护。

---

### 可视化与算法演示

#### **LCT路径提取与二分查找**
- **动画设计**：
  1. **合并操作**：展示两棵树通过LCT的`link`操作连接，路径被提取为Splay树。
  2. **重心搜索**：高亮路径上的节点，动态显示`lsum`和`rsum`的计算，逐步逼近重心。
  3. **Splay调整**：演示节点旋转和子树大小更新。

#### **复古游戏化效果**
- **像素风格**：用8-bit网格表示树结构，节点显示编号，边用像素线条连接。
- **音效设计**：
  - **合并成功**：播放短促“升级”音效。
  - **找到重心**：触发“胜利”音效，节点闪烁。
- **自动演示模式**：AI自动执行合并与查询，展示重心变化轨迹。

---

### 相似题目推荐
1. **P4219 [BJOI2014]大融合**：动态维护子树大小。
2. **P2387 [NOI2014]魔法森林**：LCT维护动态边。
3. **P1501 [国家集训队]Tree II**：LCT综合操作练习。

---

### 个人心得摘录
- **FlashHu**：强调重心路径性质是优化复杂度的关键，避免逐点检查。
- **Refined_heart**：调试中发现未及时`pushdown`导致计算错误，提醒注意LCT操作的顺序。
- **mzgwty**：尝试离线重链剖分失败，最终回归LCT的动态维护。

---

### 核心代码片段（FlashHu版）
```cpp
int update(R x) {
    R l, r, sum = s[x] >> 1, lsum = 0, rsum = 0;
    while (x) {
        pushdown(x);
        R nowl = s[l=lc] + lsum, nowr = s[r=rc] + rsum;
        if (nowl <= sum && nowr <= sum) return x; // 找到重心
        if (nowl < nowr) lsum += s[l] + si[x] + 1, x = r;
        else rsum += s[r] + si[x] + 1, x = l;
    }
}
```

---

### 结论
**最优解法**：利用LCT提取路径并二分查找，结合并查集维护重心，时间复杂度 $O(n \log n)$。  
**实现关键**：正确维护虚子树大小与路径操作，确保二分策略高效准确。

---
处理用时：69.61秒
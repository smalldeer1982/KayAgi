# 题目信息

# [CQOI2016] 伪光滑数

## 题目描述

若一个大于 $1$ 的整数 $M$ 的质因数分解有 $k$ 项，其最大的质因子为 $a_k$ ，并且满足 $a_{k}^{k} \le N$，$a_k < 128$，我们就称整数 $M$ 为 $N$ - 伪光滑数。

现在给出 $N$，求所有整数中，第 $K$ 大的 $N$ - 伪光滑数。

### 题意澄清

设 $M = 36 = 2^2 \times 3^2$，则其对应的 $k = 4$，也就是说，对 $M$ 运用唯一分解定理，$M = \prod_{i=1}^n{p_i^{c_i}}$，$k = \sum_{i=1}^n{c_i}$。

第 $K$ 大为字面意思，是真的从大到小第 $K$ 个。

modified by expect2004 2020-11-25，这或许是他退役前对洛谷公共题库的最后一次贡献

## 说明/提示

对于 $30\%$ 的数据，$N \le 10^6$；  
对于 $100\%$ 的数据，$2 \le N \le 10^{18},1 \le K \le 800000$。保证至少有 $K$ 个满足要求的数。

## 样例 #1

### 输入

```
12345 20```

### 输出

```
9167```

# AI分析结果



# 伪光滑数题解分析

## 算法分类
**其他搜索**（基于优先队列的贪心生成策略）

---

## 题解思路与核心难点
### 核心思路
所有题解均围绕如何高效生成并维护候选的伪光滑数。核心难点在于：
1. **避免重复生成**：需保证每次生成的候选数唯一
2. **高效获取第K大数**：需快速访问当前最大候选并生成次优解

### 解决方案对比
| 方法               | 数据结构          | 核心策略                                                                 | 时间复杂度       |
|--------------------|-------------------|--------------------------------------------------------------------------|------------------|
| 优先队列（堆）     | 大根堆            | 每次替换最大质因子为更小的质因子                                         | O(K log P)       |
| 可持久化左偏树     | 可持久化堆        | 动态合并不同质因子组合的集合                                             | O(K log K)       |
| 状态指针法         | 优先队列 + 状态机 | 将候选数扩展拆分为横向（同质因子）和纵向（不同质因子）移动               | O(K log K)       |

---

## 题解评分（≥4星）
1. **ycyaw（5星）**
   - **亮点**：代码简洁直观，通过质因子替换策略保证无重复解
   - **代码片段**：
     ```cpp
     for(int i=1;i<=31;i++){ // 初始化所有质数的幂次
         int now=pr[i];
         for(int j=1;now<=n;j++,now=now*pr[i])
             q.push((node){now,pr[i],j,i-1});
     }
     while(k--){ // 每次替换一个质因子
         node now=q.top(); q.pop();
         if(now.mi>1) // 生成新候选
             for(int i=1;i<=now.lim;i++)
                 q.push((node){now.val/now.p*pr[i],now.p,now.mi-1,i});
     }
     ```

2. **konyakest（4星）**
   - **亮点**：状态指针法减少无效计算，实现高效扩展
   - **关键代码**：
     ```cpp
     q.push({tp,tot,...,j}); // 初始状态
     while(k--){
         DATA d=q.top();
         // 横向扩展（同质因子）
         if(d.n < d.k) q.push({...d.val/prs[d.m]*prs[d.m+1]});
         // 纵向扩展（不同质因子）
         if(d.m != d.p) q.push({...d.val/prs[d.p]*prs[d.p+1]});
     }
     ```

3. **Yyxxxxx（4星）**
   - **亮点**：清晰的替换策略描述与实现
   - **核心注释**：
     ```cpp
     // 将maxP替换为更小的质因子
     Val = Val / maxP * P
     ```

---

## 最优技巧提炼
**质因子替换法**：  
1. **初始化**：将所有质数p的幂次p^k ≤ N加入堆  
2. **动态维护**：每次取出堆顶后，将其最大质因子替换为更小的质因子，保持k值不变  
3. **去重保证**：仅允许替换后的质因子不大于原质因子，确保解空间单调递减

---

## 同类型题推荐
1. **P2048 [NOI2010] 超级钢琴** - 类似堆维护区间最大值
2. **P1792 [国家集训队]种树** - 贪心选择+堆优化
3. **P3960 列队** - 动态集合维护与高效查询

---

## 可视化设计（复古像素版）
### 动画逻辑
1. **初始化阶段**：  
   - 屏幕左侧显示质数列表（如2,3,5...127）  
   - 右侧网格展示每个质数的幂次（如3^1=3, 3^2=9...），选中项高亮为红色  
   - 8-bit音效：每添加一个质数播放「嘟」声

2. **堆操作阶段**：  
   - 堆结构以二叉树形式展示在屏幕中央，节点显示当前数值  
   - 每次弹出堆顶时，节点爆炸特效（像素碎片飞散）  
   - 新节点加入堆时，绿色闪光特效，伴随「咔嗒」音效

3. **替换过程**：  
   - 显示当前数值的质因子分解（如127^3 → 替换为127^2 * 113^1）  
   - 替换箭头动画：旧质因子→新质因子，使用黄色箭头连接

### 交互功能
- **步进控制**：方向键←→控制动画速度，空格暂停  
- **调试面板**：按D显示当前堆大小、已处理K值  
- **自动演示**：按A启动AI自动运行，搜索路径以蓝线高亮

---

## 核心代码实现（堆解法）
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
const int PRIMES[] = {2,3,5,...,127}; // 31 primes

struct Node {
    ll val;
    int max_p_idx, cnt, last_allowed;
    bool operator<(const Node& o) const { return val < o.val; }
};

priority_queue<Node> q;

ll find_kth(ll N, int K) {
    for(int i=0; i<31; i++){
        ll p = PRIMES[i], cur = p;
        for(int e=1; cur<=N; e++, cur*=p)
            q.push({cur, i, e, i-1});
    }
    while(K--){
        auto [v,p_idx,cnt,last] = q.top(); q.pop();
        if(K == 0) return v;
        if(cnt > 1) // 替换一个质因子
            for(int i=0; i<=last; i++)
                q.push({v/PRIMES[p_idx]*PRIMES[i], p_idx, cnt-1, i});
    }
    return -1;
}
```

---

## 个人心得分亭
**ycyaw调试经验**：  
> “初始时误将质因子替换范围设为全部质数，导致生成重复解。后来限制替换质因子不大于当前值，问题迎刃而解。”

**konyakest优化技巧**：  
> “将状态扩展拆分为横向（同质因子）和纵向（跨质因子），使复杂度从O(P^2)降为O(P)”

---

## 总结
本题通过优先队列维护候选数，结合质因子替换策略，在O(K log P)时间内高效求解。可视化设计可通过复古像素动画直观展示堆操作与质因子替换过程，辅以音效增强学习体验。

---
处理用时：84.80秒
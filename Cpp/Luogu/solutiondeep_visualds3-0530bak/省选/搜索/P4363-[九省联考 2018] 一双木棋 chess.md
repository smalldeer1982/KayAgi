# 题目信息

# [九省联考 2018] 一双木棋 chess

## 题目描述

菲菲和牛牛在一块 $n$ 行 $m$ 列的棋盘上下棋，菲菲执黑棋先手，牛牛执白棋后手。

棋局开始时，棋盘上没有任何棋子，两人轮流在格子上落子，直到填满棋盘时结束。  

落子的规则是：一个格子可以落子当且仅当这个格子内没有棋子且这个格子的左侧及上方的所有格子内都有棋子。

棋盘的每个格子上，都写有两个非负整数，从上到下第 $i$ 行中从左到右第 $j$ 列的格子上的两个整数记作 $a_{i,j}$ 和 $b_{i,j}$。

在游戏结束后，菲菲和牛牛会分别计算自己的得分：菲菲的得分是所有有黑棋的格子上的 $a_{i,j}$ 之和，牛牛的得分是所有有白棋的格子上的 $b_{i,j}$ 的和。

菲菲和牛牛都希望，自己的得分减去对方的得分得到的结果最大。现在他们想知道，在给定的棋盘上，如果双方都采用最优策略且知道对方会采用最优策略，那么，最终的结果如何？


## 说明/提示

### 样例 1 说明

![](https://cdn.luogu.com.cn/upload/pic/16877.png)

棋盘如图所示，双方都采用最优策略时，棋局如下：

- 菲菲下在第 $1$ 行第 $1$ 列（这是第一步时唯一可以落子的格子）。
- 牛牛下在第 $1$ 行第 $2$ 列。
- 菲菲下在第 $2$ 行第 $1$ 列。
- 牛牛下在第 $1$ 行第 $3$ 列。
- 菲菲下在第 $2$ 行第 $2$ 列。
- 牛牛下在第 $2$ 行第 $3$ 列（这是这一步时唯一可以落子的格子）。
- 填满棋盘，游戏结束。

盘面如下：

![](https://cdn.luogu.com.cn/upload/pic/16878.png)

菲菲的得分为 $2 + 9 + 1 = 12$，牛牛的得分为 $7 + 2 + 1 = 10$。

### 数据规模与约定

各测试点信息如下表。

![](https://cdn.luogu.com.cn/upload/pic/16879.png)

- 对于编号为奇数的测试点，保证 $b_{i, j} = 0$。
- 对于全部的测试点，保证 $1 \leq n, m \leq 10$，$0 \leq a_{i, j}, b_{i, j} \leq 10^5$。


## 样例 #1

### 输入

```
2 3
2 7 3
9 1 2
3 7 2
2 3 1
```

### 输出

```
2```

# AI分析结果



## 算法分类
**其他搜索（轮廓线DP与记忆化搜索）**

---

## 综合分析与结论
### 核心思路与难点
本题属于博弈论中的对抗搜索问题，核心难点在于：
1. **棋盘状态的压缩表示**：合法棋局必须形成阶梯状轮廓线，需用二进制或行棋子数等高效方式编码。
2. **博弈策略的Min-Max决策**：先手最大化得分差，后手最小化得分差，需结合状态表示交替决策。
3. **状态转移与剪枝**：需高效枚举所有可能的落子位置，并通过记忆化避免重复计算。

### 可视化设计思路
1. **轮廓线动态展示**：用Canvas绘制当前棋盘轮廓线（如01串或行棋子数），高亮可移动的拐点。
2. **状态转移动画**：点击拐点时，动态展示轮廓线变化（如10→01），并标出对应落子的得分增量。
3. **对抗决策提示**：用红/蓝区分当前玩家（Max/Min），在状态转移时显示取最大值或最小值的过程。
4. **复古像素风格**：用8位像素风格绘制棋盘节点，音效提示状态转移（如得分增长用上扬音效，决策切换用不同音调）。

---

## 题解清单（≥4星）
1. **Anoxiacxy（5星）**
   - **亮点**：轮廓线DP的极简实现，状态用01串表示，记忆化搜索代码仅30行。
   - **关键代码**：
     ```cpp
     int dfs(int sta, bool who, int n, int m) {
         if (~f[sta]) return f[sta];
         f[sta] = who ? -oo : oo;
         int x = n, y = 0;
         for (int i = 0; i < n + m - 1; i++) {
             if (sta >> i & 1) x--; else y++;
             if ((sta >> i & 3) != 1) continue;
             int nxt = sta ^ (3 << i);
             if (who) f[sta] = max(f[sta], dfs(nxt, who^1, n, m) + a[x][y]);
             else f[sta] = min(f[sta], dfs(nxt, who^1, n, m) - b[x][y]);
         }
         return f[sta];
     }
     ```

2. **cmd2001（4.5星）**
   - **亮点**：暴力枚举每行棋子数，用map记忆化，代码直观易实现。
   - **核心思想**：状态编码为每行棋子数（单调不增），哈希后DFS搜索。

3. **yzhang（4星）**
   - **亮点**：详细解释轮廓线编码原理，提供完整状态转移分析。

---

## 关键代码实现
```cpp
// 轮廓线DP核心代码（Anoxiacxy题解）
int dfs(int sta, bool who, int n, int m) {
    if (~f[sta]) return f[sta];
    f[sta] = who ? -oo : oo;
    int x = n, y = 0;
    for (int i = 0; i < n + m - 1; i++) {
        if (sta >> i & 1) x--; else y++;
        if ((sta >> i & 3) != 1) continue; // 找到可转移的10位置
        int nxt = sta ^ (3 << i); // 10→01
        if (who) // 当前玩家为后手（牛牛）
            f[sta] = max(f[sta], dfs(nxt, who^1, n, m) + a[x][y]);
        else 
            f[sta] = min(f[sta], dfs(nxt, who^1, n, m) - b[x][y]);
    }
    return f[sta];
}
```

---

## 类似题目推荐
1. **P2596 [ZJOI2006]书架**（平衡树维护序列状态）
2. **P1979 华容道**（BFS状态压缩与剪枝）
3. **P4161 [SCOI2005]骑士精神**（IDA*搜索与状态评估）

---

## 可视化实现（JavaScript伪代码）
```javascript
// 8位像素风格轮廓线动画
class ChessVisualizer {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.palette = ['#000', '#F00', '#0F0', '#00F']; // 复古配色
    }

    drawContour(contour) {
        this.ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < contour.length; i++) {
            const bit = (contour >> i) & 1;
            const x = i * 16, y = bit ? 0 : 16;
            this.ctx.fillStyle = bit ? this.palette[1] : this.palette[2];
            this.ctx.fillRect(x, y, 16, 16);
        }
    }

    playSound(effect) {
        const freq = effect === 'move' ? 440 : 880;
        const osc = audioCtx.createOscillator();
        osc.frequency.value = freq;
        osc.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.1);
    }
}
```

---

## 个人心得
- **轮廓线编码的顿悟**：通过观察合法棋局必须形成阶梯状，意识到可用二进制位或行棋子数压缩状态。
- **调试教训**：初始未正确处理边界轮廓线（如第一行全满），导致状态转移错误，通过绘制中间状态逐步验证。

---
处理用时：77.58秒
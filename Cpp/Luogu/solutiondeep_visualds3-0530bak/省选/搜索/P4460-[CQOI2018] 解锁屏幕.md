# 题目信息

# [CQOI2018] 解锁屏幕

## 题目背景

使用过 Android 手机的同学一定对手势解锁屏幕不陌生。 Android 的解锁屏幕由 $3 \times 3$ 个点组成，手指在屏幕上画一条线，将其中一些点连接起来，即可构成一个解锁图案。如下面三个例子所示：

![](https://cdn.luogu.com.cn/upload/pic/17556.png)
![](https://cdn.luogu.com.cn/upload/pic/17557.png)
![](https://cdn.luogu.com.cn/upload/pic/17558.png)

## 题目描述

画线时还需要遵循一些规则：
1. 连接的点数不能少于 $4$ 个。也就是说只连接两个点或者三个点会提示错误。
2. 两个点之间的联线不能弯曲。
3. 每个点只能“使用”一次，不可重复。这里的“使用”是指手指划过一个点，该点变绿。
4. 两个点之间的连线不能“跨过”另一个点，除非那个点之前已经被“使用”过。

对于最后一条规则，参见下图的解释。左边两幅图违反了该规则；而右边两幅图（分别为 $ 2 \rightarrow 4 \rightarrow 1 \rightarrow 3 \rightarrow 6$ 和 $ 6 \rightarrow 5 \rightarrow 4 \rightarrow 1 \rightarrow 9 \rightarrow 2$ ）则没有违反规则，因为在“跨过”点时，点已经被使用过了。

![](https://cdn.luogu.com.cn/upload/pic/17566.png)

现在工程师希望改进解锁屏幕，增减点的数目，并移动点的位置，不再是一个九宫格形状，但保持上述画线规则不变。

请计算新的解锁屏幕上，一共有多少满足规则的画线方案。

## 说明/提示

#### 样例解释 1

设 $4$ 个点编号为 $1$ 到 $4$ ，方案有 $1 \rightarrow 2 \rightarrow 3 \rightarrow 4$ ， $2 \rightarrow 1 \rightarrow 3 \rightarrow 4$ ，  $3 \rightarrow 2 \rightarrow 1 \rightarrow 4$ ，  $2 \rightarrow 3 \rightarrow 1 \rightarrow 4$ 以及它们的镜像。

### 数据范围

- 对于 $30\%$ 的数据，$1 \le n \le 10$。
- 对于 $100\%$ 的数据，$-1000 \le x_i ,y_i \le 1000$，$ 1 \le n < 20$。各点坐标不相同。

## 样例 #1

### 输入

```
4
0 0
1 1
2 2
3 3```

### 输出

```
8```

## 样例 #2

### 输入

```
4
0 0
0 1
0 2
1 0```

### 输出

```
18```

# AI分析结果



# 【算法分类】
**其他搜索**（基于状态压缩的动态规划）

---

# **题解思路、算法要点与解决难点**

## **核心思路**
1. **状态压缩DP**：使用二进制掩码表示已访问的点集合，`dp[i][j]`表示状态`i`且最后一个点为`j`的方案数。
2. **预处理中间点**：对于任意两点`i`和`j`，预处理其连线上所有中间点的集合，保存为位掩码。
3. **状态转移**：枚举下一个点`k`，若`i`到`k`的连线上的所有中间点已被访问，则转移`dp[i | (1<<k)][k] += dp[i][j]`。

## **解决难点**
- **跨点判断**：通过预处理每个点对的中间点集合，用位运算快速判断是否满足条件。
- **状态优化**：将状态和最后一个点结合，避免重复计算，保证时间复杂度为`O(n^2 * 2^n)`。

---

# **题解评分 (≥4星)**

1. **孙子隆 (⭐⭐⭐⭐)**  
   - **亮点**：预处理中间点集合，位运算优化判断逻辑，代码简洁高效。  
   - **关键代码**：预处理`nd[i][j]`存储中间点，转移时快速检查掩码。

2. **StudyingFather (⭐⭐⭐⭐)**  
   - **亮点**：使用`__builtin_popcount`快速统计点数，排序预处理优化共线判断。  
   - **关键代码**：通过斜率计算预处理中间点集合，状态转移逻辑清晰。

3. **Bruteforces (⭐⭐⭐⭐)**  
   - **亮点**：BFS队列实现状态转移，避免无效状态遍历，代码高效。  
   - **关键代码**：用队列管理状态，动态剪枝，预处理共线点判断。

---

# **最优思路或技巧提炼**

1. **预处理中间点集合**  
   - 对每对点`(i,j)`，预处理所有中间点`k`，保存为位掩码`g[i][j]`。
   - **判断条件**：三点共线且在两点之间（坐标范围检查）。

2. **位运算优化**  
   - 检查中间点是否被访问：`(g[i][j] & state) == g[i][j]`。
   - 快速统计状态中点的数量：`__builtin_popcount(state)`。

3. **状态压缩DP设计**  
   - 状态定义：`dp[state][last]`表示当前状态和最后访问点。
   - 动态转移：枚举下一个点，检查中间点是否全部被访问。

---

# **同类型题或类似算法套路**

1. **状态压缩DP**  
   - **P2831 愤怒的小鸟**：预处理抛物线覆盖的点，状压DP统计最小点击。
   - **P1433 吃奶酪**：路径问题，状态压缩记录访问过的点。

2. **BFS优化状态转移**  
   - **P1171 售货员的难题**：旅行商问题，状态压缩+BFS剪枝。

---

# **推荐洛谷题目**

1. **P2831**：状压DP预处理抛物线。
2. **P1433**：状态压缩路径问题。
3. **P1171**：旅行商问题经典题目。

---

# **可视化与算法演示**

## **动画方案设计**
1. **像素化网格**：将点绘制为8位像素方块，路径用线条连接。
2. **状态转移展示**：高亮当前状态掩码和最后一个点，显示可转移的下一个点。
3. **中间点检查**：用颜色标记中间点是否已被访问，红色为未访问，绿色为已访问。
4. **音效提示**：访问新节点时播放“滴”声，成功转移时播放上扬音效。

## **复古游戏化交互**
- **Canvas绘制**：使用16色调色板，点阵风格显示点和路径。
- **自动演示模式**：AI自动执行状态转移，按步展示搜索过程。
- **控制面板**：暂停/继续按钮，速度调节滑块。

---

# **核心代码片段**

```cpp
// 预处理中间点集合
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        if (i == j) continue;
        for (int k = 0; k < n; k++) {
            if (k == i || k == j) continue;
            if (共线且在中间) {
                nd[i][j] |= (1 << k);
            }
        }
    }
}

// 状态压缩DP转移
for (int state = 0; state < (1 << n); state++) {
    for (int last = 0; last < n; last++) {
        if (!(state & (1 << last))) continue;
        for (int next = 0; next < n; next++) {
            if (state & (1 << next)) continue;
            if ((nd[last][next] & state) == nd[last][next]) {
                dp[state | (1 << next)][next] += dp[state][last];
                dp[state | (1 << next)][next] %= MOD;
            }
        }
    }
}
```

---

# **总结**

本题通过状压DP和预处理中间点集合，高效解决跨点判断问题。关键点在于位运算优化和状态转移设计。推荐类似题目加深对状态压缩和路径规划的理解。

---
处理用时：85.61秒
# 题目信息

# [BalticOI 2018] 多角恋

## 题目描述

**题目译自 [BalticOI 2018](https://boi2018.progolymp.se/tasks/) Day1「[Love Polygon](https://boi18-day1-open.kattis.com/problems/boi18.polygon)」**

给一张 $N$ 个点的有向图，每个点的出度为 $1$。每次可以花费 $1$ 的代价修改图上的一条边的终点，也就是改变从一个点出发所到达的点。求最少需要花费多少代价，才能使这张图形成若干个两两不相交的二元环，并且图上的所有点都在某一个环里。

## 说明/提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/1ojydan1.png)

唯一的最优解如上图所示，图的上半部分为原图，底色为粉色的三个点为需要修改的边的起点；图的下半部分表示修改后的情况。

#### 样例 2 解释

存在多组最优解。其中一种是分别改变一条以 ``a``、``b`` 和 ``d`` 为起点的边，使他们分别连接到 ``b``、``a`` 和 `c`。

#### 样例 3 解释

图中有 $3$ 个点，无论如何修改边的终点，总会有一个人不在环里。


| 子任务 | 分值 | 数据范围 | 附加限制 |
|:----------:|:-------:|:-------------:|:-------------:|
|$1$|$21$|$2\leqslant N\leqslant 20$|.|
|$2$|$25$|$2\leqslant N\leqslant 100\, 000$|每个点都有一条入边（可能有自环）|
|$3$|$29$|$2\leqslant N\leqslant 100\, 000$|不存在两个点或更多个点构成的环|
|$4$|$25$|$2\leqslant N\leqslant 100\, 000$|.|



## 样例 #1

### 输入

```
8
leonard emmy
ada emmy
isaac leonard
emmy pierre
pierre bernhard
bernhard emmy
sofia karl
karl sofia```

### 输出

```
3
```

## 样例 #2

### 输入

```
4
a c
b c
c d
d d```

### 输出

```
3
```

## 样例 #3

### 输入

```
3
rocky scarlet
scarlet patrick
patrick rocky```

### 输出

```
-1
```

# AI分析结果



# 算法分析与题解总结

## 算法分类
**BFS**（基于拓扑排序处理树结构，结合环的数学计算）

---

## 题解思路与解决难点

### 核心思路
1. **预处理二元环**：直接标记已经形成两两互指的节点对，无需修改。
2. **拓扑排序处理树结构**：通过队列（BFS）处理入度为0的节点，修改其指向以形成配对。
3. **环的奇偶性处理**：剩余环的大小决定修改次数，奇环需额外调整。

### 解决难点
- **基环树分解**：将图分解为树和环，分别处理。
- **贪心策略的正确性**：拓扑排序保证树部分的最优解，环的奇偶性处理保证全局最优。
- **复杂度控制**：拓扑排序和环处理的线性时间复杂度（O(N)）。

---

## 题解评分（≥4星）

### 1. cc123321（⭐⭐⭐⭐⭐）
- **亮点**：代码清晰，预处理二元环与拓扑排序分离，环处理逻辑简洁。
- **关键代码**：
  ```cpp
  while(q.size()) { // BFS处理入度为0节点
      int now = q.front(); q.pop();
      ans++;
      if(!use[to[now]]) {
          use[to[now]] = 1;
          --deg[to[to[now]]];
          if(!deg[to[to[now]]] && !use[to[to[now]]]) 
              q.push(to[to[now]]);
      }
  }
  ```

### 2. Endt（⭐⭐⭐⭐）
- **亮点**：贪心策略明确，环处理直接数学计算，代码简短。
- **关键代码**：
  ```cpp
  for(int i=1;i<=n;++i) ans3+=(dfs(i)+1)/2; // 环的贡献计算
  ```

### 3. ynxynx（⭐⭐⭐⭐）
- **亮点**：详细注释，强调特判和队列初始化。
- **个人心得**：预处理已存在环和队列初始化的细节处理。

---

## 最优思路提炼

### 关键技巧
1. **二元环预处理**：直接跳过已匹配节点，减少后续计算量。
2. **队列维护拓扑序**：动态处理入度为0的节点，保证贪心正确性。
3. **环的奇偶性计算**：环长偶则直接取半，奇则额外加1。

### 代码片段
```cpp
// 预处理二元环
for(int i=1; i<=n; i++) {
    if(i == nex[nex[i]] && !use[i] && !use[nex[i]]) 
        use[i] = use[nex[i]] = 1;
}

// BFS处理入度为0的节点
queue<int> q;
for(int i=1; i<=n; i++) {
    if(!deg[i] && !use[i]) q.push(i);
}
while(!q.empty()) {
    int u = q.front(); q.pop();
    ans++;
    if(!use[nex[u]]) {
        use[nex[u]] = 1;
        deg[nex[nex[u]]]--;
        if(deg[nex[nex[u]]] == 0 && !use[nex[nex[u]]])
            q.push(nex[nex[u]]);
    }
}
```

---

## 类似题目推荐
1. **P2661 信息传递**（基环树找最小环）
2. **P3385 负环判断**（BFS/DFS应用）
3. **P1144 最短路计数**（BFS处理分层图）

---

## 可视化设计

### 动画演示方案
1. **拓扑排序阶段**：
   - **颜色标记**：绿色（已处理）、红色（队列中）、灰色（未处理）。
   - **队列操作**：动态展示节点入队、出队，修改指向后更新入度。
2. **环处理阶段**：
   - **环高亮**：黄色标记环的路径，逐步计算环长。
   - **奇偶提示**：弹出文字提示环长奇偶性及对应修改次数。

### 复古像素风格
- **Canvas 绘制**：节点为8位像素方块，边用箭头表示。
- **音效设计**：
  - 节点入队：短促“滴”声。
  - 环处理完成：经典FC过关音效。
- **自动演示**：按空格键逐步执行，Esc键重置。

---

## 总结
本题通过BFS处理树结构，结合环的数学计算，展现了基环树问题的典型解法。预处理与拓扑排序的配合是关键，可视化设计可帮助理解队列操作和环的动态处理。

---
处理用时：58.80秒
# 题目信息

# 【模板】最小割树（Gomory-Hu Tree）

## 题目背景

模板题。做本题之前请确保你会 Dinic 或 ISAP。如果你乱搞过了我请你抽烟。

根据惯例，网络流题不允许卡 Dinic/ISAP，但可以卡 EK，本题数据严格遵循上述条约。

## 题目描述

给定一个 $n$ 个点 $m$ 条边的无向连通图，多次询问两点之间的最小割。

两点间的最小割是这样定义的：原图的每条边有一个割断它的代价，你需要用最小的代价使得这两个点不连通。

## 说明/提示

$1\le n\leq 500,\quad 0\le m\leq 1500,\quad 0\le Q\leq 10^5,\quad 0\leq w\leq 10^4,\quad u\neq v$

## 样例 #1

### 输入

```
4 5
1 2 2
2 3 2
4 2 3
4 3 1
1 3 1
3
1 4
2 4
2 3```

### 输出

```
3
4
4```

# AI分析结果



**唯一算法分类**  
其他搜索（分治+网络流）

---

**综合分析与结论**  
本题的核心是构造 Gomory-Hu 树（最小割树），其算法流程如下：  
1. **分治策略**：每次选取当前点集中任意两点，计算最小割（最大流），将图分割为两个集合  
2. **树边构建**：在最小割树中添加一条权值为当前最小割的边连接这两点  
3. **递归处理**：对分割后的两个子集递归执行上述过程  

**关键难点**：  
- 每次分割需在原始全图上计算最大流，不能仅处理子图  
- 需维护点的归属集合，确保分治正确性  
- 查询时需快速获取树上两点路径的最小边权  

**解决思路**：  
- 使用 Dinic/ISAP 算法高效处理多次最大流  
- 分治时根据残量网络的连通性划分集合  
- 预处理树上路径最小值（BFS/DFS/倍增）  

---

**题解清单 (≥4星)**  
1. **_LHF_ (5星)**  
   - 思路清晰，分治流程详细  
   - 代码完整，包含 BFS 查询路径最小值  
2. **mydcwfy (4.5星)**  
   - 预处理所有点对答案，省去查询时间  
   - 代码简洁，分治与答案更新逻辑明确  
3. **Ebola (4星)**  
   - 实现树上倍增查询，理论最优复杂度  
   - 包含完整数学证明，增强理解  

---

**最优思路与代码片段**  
**核心分治逻辑**（以 _LHF_ 题解为例）：
```cpp
void build(int l, int r) {
    if(l >= r) return;
    int u = v[l], v = v[l+1];
    int cut = dinic(u, v); // 计算最小割
    add_tree_edge(u, v, cut); // 树中连边
    // 划分集合
    vector<int> set1, set2;
    for(int i=l; i<=r; ++i) 
        (dis[v[i]] ? set1 : set2).push_back(v[i]);
    // 递归处理子集
    build(l, l+set1.size()-1);
    build(l+set1.size(), r);
}
```

**倍增查询逻辑**（Ebola 题解）：
```cpp
int query(int x, int y) {
    int res = INF;
    if(dep[x] < dep[y]) swap(x, y);
    // 上提x至y同层
    for(int i=20; i>=0; --i) 
        if(dep[fa[x][i]] >= dep[y]) 
            res = min(res, mn[x][i]), x = fa[x][i];
    if(x == y) return res;
    // 同步上提找LCA
    for(int i=20; i>=0; --i)
        if(fa[x][i] != fa[y][i]) {
            res = min({res, mn[x][i], mn[y][i]});
            x = fa[x][i], y = fa[y][i];
        }
    return min({res, mn[x][0], mn[y][0]});
}
```

---

**同类型题与算法套路**  
1. **分治+网络流**：类似最大流问题中通过分割简化计算  
2. **树上路径极值**：如 LCA 问题中的倍增维护最小值  
3. **离线预处理**：通过预处理所有可能查询降低时间复杂度  

---

**推荐题目**  
1. [P4123 [CQOI2016] 不同的最小割](https://www.luogu.com.cn/problem/P4123)  
2. [P3329 [ZJOI2011] 最小割](https://www.luogu.com.cn/problem/P3329)  
3. [CF343E Pumping Stations](https://www.luogu.com.cn/problem/CF343E)  

---

**可视化与算法演示设计**  
**分治过程动画**：  
1. **节点染色**：初始所有节点为白色，选中分治的 `u` 和 `v` 时标记为红/蓝色  
2. **流计算演示**：以粒子效果模拟网络流，割边闪烁显示  
3. **集合划分**：被分到 `u` 集合的节点渐变为红色，`v` 集合渐变为蓝色  
4. **树边生长**：在独立图层绘制树结构，新边以生长动画连接两点  

**查询路径展示**：  
- 输入 `u` 和 `v` 后，路径边依次高亮为金色  
- 当前最小边权以脉冲特效强调  

**复古像素风格**：  
- 节点显示为 16x16 像素方块，边为单色线段  
- 音效设计：  
  - 分治步骤：8-bit "哔"声  
  - 找到最小割：NES 风格爆炸音  
  - 查询成功：经典马里奥金币音  

---

**调试心得摘录**  
> "_LHF_：调试时发现边权恢复逻辑错误，导致后续流计算错误。修正后退流操作后 AC"  
> "Eznibuil：缩点操作中未正确处理虚拟节点，通过打印中间划分状态定位问题"  

---

**总结**  
最小割树通过分治策略将图问题转化为树结构，结合网络流与树上查询技巧，将高复杂度的多次查询优化为高效预处理。其核心在于理解分治划分与树结构的等价性，以及熟练应用最大流算法。

---
处理用时：77.56秒
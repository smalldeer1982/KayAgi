# 题目信息

# [IOI 2018] werewolf 狼人

## 题目背景

本题为交互题，但在此请提交**完整程序**。

## 题目描述

在日本的茨城县内共有 $N$ 个城市和 $M$ 条道路。这些城市是根据人口数量的升序排列的，依次编号为 $0$ 到 $N - 1$。每条道路连接两个不同的城市，并且可以双向通行。由这些道路，你能从任意一个城市到另外任意一个城市。

你计划了 $Q$ 个行程，这些行程分别编号为 $0$ 至 $Q - 1$。第 $i(0 \leq i \leq Q - 1)$ 个行程是从城市 $S_i$ 到城市 $E_i$。

你是一个狼人。你有两种形态：**人形**和**狼形**。在每个行程开始的时候，你是人形。在每个行程结束的时候，你必须是狼形。在行程中，你必须要变身（从人形变成狼形）恰好一次，而且只能在某个城市内（包括可能是在 $S_i$ 或 $E_i$ 内）变身。

狼人的生活并不容易。当你是人形时，你必须避开人少的城市，而当你是狼形时，你必须避开人多的城市。对于每一次行程 $i(0 \leq i \leq Q - 1)$，都有两个阈值 $L_i$ 和 $R_i(0 \leq L_i \leq R_i \leq N - 1)$，用以表示哪些城市必须要避开。准确地说，当你是人形时，你必须避开城市 $0, 1, \ldots , L_i - 1$ ；而当你是狼形时，则必须避开城市 $R_i + 1, R_i + 2, \ldots , N - 1$。这就是说，在行程 $i$ 中，你必须在城市 $L_i, L_i + 1, \ldots , R_i$ 中的其中一个城市内变身。

你的任务是，对每一次行程，判定是否有可能在满足上述限制的前提下，由城市 $S_i$ 走到城市 $E_i$。你的路线可以有任意长度。

## 说明/提示

**限制条件**

- $2 \leq N \leq 200, 000$
- $N - 1 \leq M \leq 400, 000$
- $1 \leq Q \leq 200, 000$
- 对于每个 $0 \leq j \leq M - 1$
    - $0 \leq X_j \leq N - 1$
    - $0 \leq Y_j \leq N - 1$
    - $X_j \neq Y_j$
- 你可以通过道路由任意一个城市去另外任意一个城市。
- 每一对城市最多只由一条道路直接连起来。换言之，对于所有 $0 \leq j < k \leq M - 1$，都有 $(X_j, Y_j) \neq (X_k, Y_k)$ 和 $(Y_j, X_j) \neq (X_k, Y_k)$
- 对于每个 $0 \leq i \leq Q - 1$
    - $0 \leq L_i \leq S_i \leq N - 1$
    - $0 \leq E_i \leq R_i \leq N - 1$
    - $S_i \neq E_i$
    - $L_i \leq R_i$

**子任务**

- 1.（7 分）$N \leq 100$，$M \leq 200$，$Q \leq 100$。
- 2.（8 分）$N \leq 3, 000$，$M \leq 6, 000$，$Q \leq 3, 000$。
- 3.（34 分）$M = N - 1$ 且每个城市最多与两条路相连（所有城市是以一条直线的形式连起来）。
- 4.（51 分）没有附加限制。

## 样例 #1

### 输入

```
6 6 3
5 1
1 2
1 3
3 4
3 0
5 2
4 2 1 2
4 2 2 2
5 4 3 4
```

### 输出

```
1
0
0
```

## 样例 #2

### 输入

```
10 9 10
6 7
1 5
8 0
2 9
9 4
2 7
8 5
6 0
3 4
4 9 0 9
8 1 8 9
1 8 1 8
8 3 5 5
8 9 3 9
0 1 0 2
9 0 6 6
1 7 1 8
9 4 5 6
9 5 0 9
```

### 输出

```
1
1
1
0
1
1
0
1
0
1
```

# AI分析结果



### 唯一算法分类：其他搜索（Kruskal 重构树 + 二维数点）

---

### 题解思路与核心难点

**核心思路**  
将路径限制转化为两棵 Kruskal 重构树的子树交集问题。通过构建最大/最小生成树重构树，利用倍增快速定位子树范围，再通过主席树实现二维数点查询子树交集。

**算法要点**  
1. **重构树构建**  
   - **人形态树**：边权为 min(u,v)，构建最大生成树重构树，子树表示从 S 出发只走 ≥L 的点可达区域。  
   - **狼形态树**：边权为 max(u,v)，构建最小生成树重构树，子树表示从 E 出发只走 ≤R 的点可达区域。  
2. **倍增定位子树**  
   在两棵重构树中分别通过倍增找到满足条件的最高祖先节点，其子树即为合法点集。  
3. **二维数点查询**  
   将点的两棵树的 DFS 序映射为坐标，用主席树查询矩形区域内是否存在点。

**解决难点**  
- **高效处理路径限制**：通过重构树将连通性查询转化为子树范围查询。  
- **快速交集判定**：利用 DFS 序的连续性和主席树的前缀和特性，将二维区间查询优化至 O(log n)。

---

### 关键代码实现（Kruskal 重构树部分）

```cpp
// 构建最大生成树重构树（人形态）
void kruskal_A() {
    sort(edges, edges + m, [](Edge a, Edge b) {
        return min(a.u, a.v) > min(b.u, b.v); // 按min降序
    });
    init_dsu(2 * n);
    int cnt = n;
    for (auto e : edges) {
        int u = find(e.u), v = find(e.v);
        if (u == v) continue;
        int node = ++cnt;
        val[node] = min(e.u, e.v);
        add_edge(node, u);
        add_edge(node, v);
        merge(u, node);
        merge(v, node);
    }
}

// 构建最小生成树重构树（狼形态）
void kruskal_B() {
    sort(edges, edges + m, [](Edge a, Edge b) {
        return max(a.u, a.v) < max(b.u, b.v); // 按max升序
    });
    init_dsu(2 * n);
    int cnt = n;
    for (auto e : edges) {
        int u = find(e.u), v = find(e.v);
        if (u == v) continue;
        int node = ++cnt;
        val[node] = max(e.u, e.v);
        add_edge(node, u);
        add_edge(node, v);
        merge(u, node);
        merge(v, node);
    }
}
```

---

### 可视化与算法演示

**搜索过程动画设计**  
1. **节点扩展**：以像素网格展示重构树结构，当前访问节点高亮为红色，待访问子节点为绿色。  
2. **DFS序生成**：动态绘制 DFS 进入和回溯过程，用不同颜色区分两棵树的遍历顺序。  
3. **交集查询**：在二维平面展示两个 DFS 序区间，用矩形框选区域，命中点闪烁提示。

**复古游戏化效果**  
- **像素风格**：16 色调色板，节点用 8×8 像素方块表示，边用单色线段连接。  
- **音效设计**：访问节点时播放短促“哔”声，命中交集时播放胜利音效。  
- **自动演示**：按 BFS 顺序自动扩展节点，速度可调，支持暂停观察当前状态。

---

### 相似题目推荐

1. **[P4197 Peaks](https://www.luogu.com.cn/problem/P4197)**  
   Kruskal 重构树结合主席树查询区间第 k 大。  
2. **[CF1416D Graph and Queries](https://www.luogu.com.cn/problem/CF1416D)**  
   反向操作+重构树处理动态连通性。  
3. **[P4768 [NOI2018] 归程](https://www.luogu.com.cn/problem/P4768)**  
   重构树处理海拔限制的最短路问题。

---

### 总结

本题通过 Kruskal 重构树将复杂路径限制转化为子树查询，结合主席树实现高效二维数点。核心在于理解重构树的性质与倍增技巧，以及如何将看似无关联的路径限制转化为可计算的区间交集问题。

---
处理用时：103.79秒
# 题目信息

# 最优性剪枝

## 题目背景

Nauuo 是一名出题人。

众所周知，某些出题人非常懒，导致[随便爆搜](https://www.luogu.com.cn/discuss/show/185420)加上一个[最优性剪枝](https://www.luogu.com.cn/discuss/show/184641)就能通过。Nauuo 决定把这些 naive 的暴力都卡掉。

## 题目描述

Nauuo 决定卡一个暴力搜索程序，为此她构建了一组数据。为了简化题目，你将得到这组数据产生的搜索树 $T$。$T$ 中包含 $n$ 个节点，依次编号为 $1 \sim n$，其中 $1$ 号点是 $T$ 的根节点。一个节点的深度是它到 $1$ 号点的简单路径上的节点个数。

这个程序的伪代码如下

```cpp
answer := inf

procedure dfs(node,depth)
	if (node is leaf) 
		answer := min(answer,depth)
		return
	if (depth < answer)
		for i in children of node
			dfs(i,depth+1)

dfs(1,1)
```

其中，`:=` 表示赋值运算。

翻译成人话就是说，这个暴力搜索程序将**深度优先**地遍历这棵搜索树，当访问到一个叶节点时，这个程序将用这个叶节点的深度更新答案。

同时，这个程序有一个最优性剪枝，也就是说，当这个程序访问到任意一个深度等于答案的节点时，它将不会再访问这个节点的子节点。

然而，可怜的 Nauuo 并不知道这个程序在某个节点时访问自己子节点的顺序，因此她认为每个节点访问子节点的顺序都是在所有可能的情况中等概率随机的，显然，一共有 $\prod d_i!$ 种情况，其中 $d_i$ 表示 $i$ 号节点的子节点数量。

现在她想知道这个程序访问到的节点数量的期望，以确定这个程序会不会被自己的数据卡掉。

为了避免浮点误差，答案对 $998244353$ 取模。保证答案能被表示为最简分数 $\frac{p}{q}$，你只需要输出一个 $x (0\leq x < 998244353)$ 使得 $qx \equiv p \pmod {998244353}$。

## 说明/提示

#### 样例解释

第一组样例的真实答案为 $\frac{7}{2}$。

一共只有两种情况，如果 $1$ 号节点先遍历 $3$ 号节点，则程序将访问到搜索树中所有节点。如果 $1$ 号节点先遍历 $2$ 号节点，则 $4$ 号节点不会被访问到。

第二组样例中，每个非叶节点的子节点都是唯一的，因此只有一种可能的情况，所有节点都必然被访问到。

第三组样例的真实答案为 $\frac{94}{9}$。

---

#### 数据范围

**「本题采用捆绑测试」**

对于所有测试点，保证 $1 \leq n \leq 3\times 10^5$，$1 \leq p_i < i$。

$\text{Subtask 1 (11 pts)}$ $n \leq 9$。

$\text{Subtask 2 (18 pts)}$ $n \leq 100$。

$\text{Subtask 3 (19 pts)}$ $n\leq 10^3$。

$\text{Subtask 4 (4 pts)}$ $p_i = i-1$。

$\text{Subtask 5 (8 pts)}$ $p_i =\lfloor \frac{i}{2} \rfloor$。

$\text{Subtask 6 (40 pts)}$ 无特殊限制。

---

#### 提示

如果你不知道怎么对分数取模，可以参考[这里](https://www.luogu.com.cn/problem/P3811)。



## 样例 #1

### 输入

```
4
1 1 3```

### 输出

```
499122180```

## 样例 #2

### 输入

```
3
1 2```

### 输出

```
3```

## 样例 #3

### 输入

```
13
1 1 1 3 5 4 2 3 7 4 4 6```

### 输出

```
776412285```

# AI分析结果



**算法分类选择**  
DFS（涉及DFS遍历顺序的概率计算及最优性剪枝）

---

**题解思路、算法要点与解决难点**  
- **核心思路**：利用期望线性性，将总期望拆解为每个节点被访问概率之和。节点被访问的条件是其路径上所有祖先的子节点中，优先访问不会导致更优解的分支。
- **算法要点**：
  1. **预处理子树最小深度（val）**：通过后序遍历计算每个节点的val，表示其子树中叶子的最小深度。
  2. **子节点排序**：对每个节点的子节点按val升序排列，便于快速统计符合剪枝条件的子节点数。
  3. **概率贡献计算**：每个节点x的概率是其所有祖先处贡献的乘积。每个祖先y的贡献为1/(k+1)，其中k为y的其他子节点中val小于x深度的数量。
- **解决难点**：  
  - **暴力法的问题**：直接遍历所有祖先和子节点复杂度高（O(nh)），无法处理3e5的数据。  
  - **树状数组优化**：通过区间乘法维护概率因子，将问题转化为动态维护区间乘积，实现O(n log n)的复杂度。  
  - **路径贡献拆分**：递归处理子树时，通过树状数组动态调整区间乘法因子，确保每个节点的贡献正确累积。

---

**题解评分 (≥4星)**  
1. **Zory的题解（⭐⭐⭐⭐⭐）**  
   - 思路清晰，代码简洁，树状数组优化巧妙。  
   - 利用区间乘法和差分思想高效维护概率，实现O(n log n)复杂度。  
   - 代码结构清晰，预处理、排序、树状数组操作分离明确。  
2. **Owen的题解（⭐⭐⭐⭐）**  
   - 提出线段树维护路径贡献，思路可行但实现复杂度较高。  
   - 结合倍增和线段树优化，适合对树链操作熟悉的开发者。  
   - 未提供完整代码，实践可操作性稍弱。  

---

**最优思路或技巧提炼**  
1. **期望拆分与线性性**：将总期望拆解为每个节点的概率求和，简化问题。  
2. **子树最小值预处理**：后序遍历计算val，快速判断子树是否有更优解。  
3. **树状数组维护动态乘积**：通过区间乘法和差分，高效维护路径贡献，避免重复计算。  
4. **子节点排序与二分优化**：排序后快速统计符合剪枝条件的子节点数，降低时间复杂度。  

---

**同类型题或类似算法套路**  
- **树形动态规划**：预处理子树信息并结合动态规划。  
- **路径贡献拆分**：在树链问题中，将路径贡献分解为各节点的独立贡献。  
- **概率与期望计算**：利用线性性将复杂期望拆解为独立事件概率之和。  

---

**推荐相似题目**  
1. P4211 [LNOI2014] LCA（树链剖分与差分）  
2. P3830 [SHOI2012] 随机树（期望计算与动态规划）  
3. P1352 没有上司的舞会（树形DP与决策概率）  

---

**可视化与算法演示**  
- **动画设计**：  
  1. **树结构展示**：以像素风格绘制树形结构，根节点在顶端，子节点向下分支。  
  2. **DFS遍历模拟**：高亮当前访问节点，标记已访问节点为绿色，剪枝节点为红色。  
  3. **概率计算提示**：在路径经过的祖先节点旁显示当前贡献因子（如1/(k+1)）。  
- **交互功能**：  
  1. **步进控制**：允许用户单步执行DFS，观察每个节点的访问与剪枝。  
  2. **音效触发**：访问新节点时播放清脆音效，剪枝时播放低沉音效。  
  3. **自动演示模式**：AI自动运行DFS，展示不同子节点顺序对访问路径的影响。  
- **复古风格**：采用8位像素风格，背景音乐循环播放FC经典音效，增强沉浸感。  

---

**代码核心实现（Zory的树状数组解法）**  
```cpp
namespace BIT {
    ll bit[N]; // 树状数组维护乘积
    void clear() { fo(i, 1, N-1) bit[i] = 1; }
    int lowbit(int x) { return x & -x; }
    void mul(int x, ll c) { while(x < N) bit[x] = bit[x] * c % MOD, x += lowbit(x); }
    void MUL(int l, int r, ll c) { mul(l, c); mul(r, invm(c)); } // 区间[l, r)乘c
    ll ask(int x) { ll ret = 1; while(x >= 1) ret = ret * bit[x] % MOD, x -= lowbit(x); return ret; }
};

void solve(int x) {
    add(ans, BIT::ask(dep[x]-1)); // 查询当前深度前缀乘积
    int m = sz(son[x]);
    fo(i, 2, m) BIT::MUL(V(i), V(i+1), invm(i)); // 调整区间乘法因子
    fo(i, 1, m) {
        int y = son[x][i-1];
        solve(y); // 递归处理子树
        if (i < m) BIT::MUL(V(i), V(i+1), i * invm(i+1) % MOD); // 恢复区间因子
    }
    // 恢复其他区间调整
}
```

---

**总结**  
本题通过预处理子树最小值、排序子节点，并结合树状数组优化动态路径贡献计算，高效解决了带剪枝的DFS期望问题。核心在于将复杂概率拆解为路径上独立事件的乘积，并通过数据结构优化降低复杂度。

---
处理用时：183.90秒
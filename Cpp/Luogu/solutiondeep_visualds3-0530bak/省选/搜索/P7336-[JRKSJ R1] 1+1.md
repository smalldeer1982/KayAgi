# 题目信息

# [JRKSJ R1] 1+1

## 题目描述

### 玩法简介

「1+1」 是一款双人对抗游戏。两名玩家各自拥有两个数，每次一名玩家可以用自己的一个数加上对方的一个数，如果大于 $9$ 则取个位。双方轮流执行此步骤。如，下面记录了游戏的几个回合，玩家双方分别为 `a` 和 `b`：

在下面的局面解释中，第一个局面标 `*` 的是先手。

```
a:1 1*（初始局面）
b:1 2

a:1 3（1+2）
b:1 2

a:1 3
b:1 5（2+3）

a:6 3（1+5）
b:1 5
```
---

### 特殊局面

我们把下面的情况称为「攻击」：

```
3 3
5 3
6 1
9 1
```
这些攻击的「攻击度」为 $1$ ，除了 `9 1`。`9 1` 的攻击度为 $2$ 。

下面的情况称为「防御」：

```
5 1
5 5
```
这些防御的「防御度」为 $1$ ，除了 `5 5`。`5 5`的 防御度为 $2$ 。

当然，所有的攻击或防御不分两个数的顺序，如 `5 1` 和 `1 5` 都视作防御，而
 `9 1` 和 `1 9` 也都视为攻击，而攻击/防御度不变。

如果玩家 `a` 持有防御，而玩家 `b` 在下一步走成了攻击，如下面的情况：

```
a:1 5
b:1 1*

a:1 5
b:6 1
```
那么此时 `a` 持有防御度为 $1$ 的 `1 5`， `b` 持有攻击度为 $1$ 的 `6 1`，此时应该将 `a` 持有的数变成 `1 1` 而 `b` 的此次攻击无效。

也就是说，如果 `a` 的攻击的攻击度与 `b` 的防御的防御度相等，则将 `b` 的两个数变为 `1 1` 而 `a` 的此次攻击视作无效。

我们认为不属于上面的攻击/防御的攻击/防御度为 $0$ （如 `3 4` 等。）

特别的，如果遇到下面这种情况：

```
a:5 5
b:1 1*

a:5 5
b:1 6
```
`a` 的防御度为 $2$ 而 b 的攻击度为 $1$ 。此时应该把 `a` 变成 `5 1` 而 `b` 的此次攻击作废。



------------


### 胜利条件

如果一方走完一步后，他的攻击度严格大于另一方的防御度，则这一方获胜。此时不应该做任何改动，即使要把另一方变成 `1 1` 或 `5 1`。

下面给出了一个例子：

```
a:1 1
b:6 3*

a:1 1
b:6 4

a:1 5
b:6 4

a:1 5
b:6 9

a:1 1
b:6 9

a:1 1
b:6 0

a:1 7
b:6 0

a:1 7
b:6 1

（ b 胜）
```
为了消除歧义，下面再给出一些例子：

```
a:5 5
b:1 4*

a:1 1
b:1 9

a:1 0（ 1+9=10 ，个位为 0 ）
b:1 9

a:1 0
b:1 9（注意这里， b 用 1 （或 9 ）加了 a 的 0 ，这样也算一次新的攻击）

（ b 胜）
```

```
a:1 1*
b:1 4

a:1 5
b:1 4

a:1 5（因为是最后一步，无须变成“1 1”）
b:1 9（这里 b 的“1 9”直接碾压了 a 的“1 5”）

（ b 胜）
```

现在，你被要求写一个程序，作为先手通过交互的方式和 mcyl35 的程序玩这个游戏。

## 说明/提示

#### 数据规模与约定

对于测试点 $1$，保证玩家可以一步获胜。

对于测试点 $2$，保证 mcyl35 的程序随机走步。

对于其他测试点，无特殊约定。

对于 $100\%$ 的数据，$0\le p_0,p_1,c_0,c_1\le 9$。

#### 评分标准

* 有不合法的输出（如输出中含有除了 $0,1$ 之外的数），得 $0$ 分。

* 获胜或走了 $100$ 步及以上本测试点可以获得满分。

* 否则获得 $\lfloor \dfrac {st} {20} \rfloor$ 分，$st$ 表示走的步数，一步表示 mcyl35 走一步。

#### 提示

当交互库没有返回数时，说明结果已经被判定了。

#### 样例解释

```
pl:1 1*
cp:1 2

pl:2 1
cp:1 2

pl:2 1
cp:1 3

pl:5 1
cp:1 3

pl:5 1
cp:1 8

pl:6 1(胜)
cp:1 8
```

## 样例 #1

### 输入

```
1 1 1 2 0
1 1
1 0```

### 输出

```
0 0
0 1
0 0```

# AI分析结果



---

**算法分类**：DFS

---

### **题解思路与核心难点**

1. **核心规则处理**  
   - 攻击/防御状态判断（需排序数值后判定）  
   - 特殊状态覆盖规则（如攻击与防御数值相等时重置对方）  
   - 胜利条件优先级高于状态重置  

2. **DFS搜索与状态预处理**  
   - **critnos**：通过预计算生成必胜必败态表（`dp[10][10][10][10]`），16层深度搜索+记忆化，实战中直接查表决策。  
   - **cmll02**：实时DFS结合必败态剪枝，生成必败态表加速搜索，设置深度上限避免无限递归。  

3. **解决难点对比**  
   - **状态爆炸**：通过排序数值（如 `3 5` 与 `5 3` 视为同一状态）压缩状态空间。  
   - **胜负判断剪枝**：在DFS中优先检查是否直接获胜，避免无效递归。  
   - **记忆化优化**：`dp2`数组记录中间结果，避免重复计算。  

---

### **题解评分与亮点**

1. **critnos（⭐⭐⭐⭐⭐）**  
   - **亮点**：预处理必胜必败表，实现O(1)查询，代码高效。  
   - **代码技巧**：四维数组存储状态胜负，打表程序生成数据。  
   - **优化点**：对称状态合并处理，减少存储空间。  

2. **cmll02（⭐⭐⭐⭐）**  
   - **亮点**：必败态表+深度剪枝，平衡实时计算与效率。  
   - **调试心得**：通过长时间对拍发现状态处理错误，强调正确性验证。  

---

### **最优思路提炼**

- **关键技巧**：博弈状态预处理 + 对称压缩  
  - 将玩家双方的数值对视为四维状态，通过DFS遍历所有可能操作。  
  - 预处理时对每个状态标记必胜/必败，实战中直接查表决策。  
- **实现要点**：  
  ```cpp
  // 生成必胜必败表的核心逻辑（critnos）
  void init() {
    memset(dp2,-1,sizeof(dp2));
    for (所有状态a, b) {
      dp[a][b] = dfs(a, b, 0);
    }
  }
  ```

---

### **同类型题与算法套路**

- **类似问题**：博弈树搜索（如Nim游戏、Alpha-Beta剪枝）  
- **通用解法**：  
  1. **状态表示**：压缩对称状态，避免重复计算。  
  2. **胜负剪枝**：优先判断直接胜利条件。  
  3. **记忆化搜索**：存储中间结果加速查询。  

---

### **推荐题目**

1. **P2583 三色棋**（博弈DFS）  
2. **P1514 取石子游戏**（Nim变种+状态分析）  
3. **P2123 骑士共存问题**（棋盘博弈+剪枝）  

---

### **可视化与游戏化设计**

- **像素风格状态网格**：  
  - 10x10网格表示玩家数值，颜色标记必胜（绿）/必败（红）/平局（灰）。  
  - **动画步骤**：  
    1. 当前状态高亮，展示可选操作（箭头指向加数方向）。  
    2. 选择后显示新状态，触发攻击/防御音效（8-bit音效库）。  
    3. 自动模式演示DFS路径，回溯时显示红色轨迹。  

- **交互功能**：  
  ```javascript
  // 伪代码：Canvas绘制状态网格
  function drawState(a, b) {
    ctx.fillStyle = getColor(dp[a][b]);
    ctx.fillRect(a0*20, a1*20, 20, 20); // 玩家A状态
    ctx.fillRect(b0*20+200, b1*20, 20, 20); // 玩家B状态
  }
  ```

---

### **代码片段（critnos打表核心）**

```cpp
// 生成必胜表的DFS（部分）
int dfs(int c, int a[2], int b[2], int f) {
    if (c == max_depth) return 0; // 深度限制
    if (已记忆化) return dp2[...];
    
    for (所有操作i,j) {
        计算新状态ca, cb;
        if (新状态直接胜利) return 必胜;
        递归搜索下一层;
    }
    更新记忆化结果;
}
```

---

**总结**：通过预计算与记忆化优化，将复杂博弈问题转化为高效查表，结合DFS与状态压缩是此类问题的核心解法。

---
处理用时：80.84秒
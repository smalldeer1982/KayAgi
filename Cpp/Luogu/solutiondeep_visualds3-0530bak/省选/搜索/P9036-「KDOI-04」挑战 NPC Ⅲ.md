# 题目信息

# 「KDOI-04」挑战 NPC Ⅲ

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/zn5t5x28.png)

## 题目描述

小 S 有一个伟大的梦想：证明 $\text{P}=\text{NP}$。

有一天，他得知一般图最大独立集是 NPC 问题后，决定解决他。

当然小 S 太菜了，解决不了，于是求助于你：

> 给出一个含有 $n$ 个顶点，$m$ 条边的无向图 $G$，求 $G$ 中大小恰好为 $n-k$ 的独立集的数量。由于答案可能很大，请将其对 $998~244~353$ 取模。

小 S 不喜欢多测，因为他在 NOIp 中因为多测挂分，所以本题包含多组测试数据。

## 说明/提示

**【样例解释】**

对于第 $1,2$ 组测试数据，图是完全图，容易发现，完全图的最大独立集为 $1$，并且每一个顶点都单独构成一个独立集。因此第 $1$ 组测试数据的答案为 $0$，第 $2$ 组测试数据的答案为 $4$。

对于第 $3$ 组测试数据，该组数据中给出的无向图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/abt8ho3b.png)

其中，所有大小为 $3$ 的独立集为：

+ $\{2,4,8\}$；
+ $\{2,3,7\}$；
+ $\{3,4,6\}$；
+ $\{2,4,6\}$；
+ $\{1,4,6\}$；
+ $\{2,3,6\}$；
+ $\{1,4,5\}$；
+ $\{2,3,4\}$。

**【数据范围】**

**本题采用捆绑测试。**

![数据范围](https://cdn.luogu.com.cn/upload/image_hosting/p3jwdqp3.png)

对于 $100\%$ 的数据，保证 $1\leq n\leq10^5$，$0\le m\le 10^5$，$0\leq k\leq \min(n-1,18)$，$1\leq T\leq 10^{4}$，$\sum n,\sum m\leq10^6$。

并且对于每个测试点保证：

设 $K=\max k$，即该测试点中所有 $k$ 的最大值，

+ 若 $K\ge 17$，则 $T=1$；
+ 若 $K\ge 15$，则 $T\le 3$；
+ 若 $K\ge 10$，则 $T\le 5$；
+ 若 $K\ge 5$，则 $T\le 300$。


## 样例 #1

### 输入

```
3
4 6 1
1 2
1 3
1 4
2 3
2 4
3 4
4 6 3
1 2
1 3
1 4
2 3
2 4
3 4
8 13 5
1 2
7 8
1 3 
2 5
3 8
6 8
4 7
5 6
5 7
5 8
6 7
1 8
3 5```

### 输出

```
0
4
8```

# AI分析结果



## 【算法分类】  
**DFS**  

---

## **综合分析与结论**  
### **题目核心思路**  
题目要求求解大小恰为 `n-k` 的独立集数量，等价于求大小恰为 `k` 的点覆盖集。由于 `k` 较小（最大 18），各题解均采用**DFS + 剪枝**策略，核心步骤分为：  
1. **预处理必选点**：度数超过 `k` 的点必选（否则其邻点需全选，导致总点数超过 `k`）。  
2. **剩余图处理**：预处理后，剩余图边数不超过 `k²`，否则无解。  
3. **DFS枚举覆盖方案**：每次选一条未覆盖的边，枚举其两端点的覆盖状态（选左/右/全选），剪枝避免重复状态。  
4. **组合数计算**：当所有边覆盖后，剩余点中选未确定的点，通过组合数计算贡献。  

### **解决难点**  
- **状态去重**：不同分支可能覆盖同一节点，需通过标记（如 `ban` 数组）确保状态唯一。  
- **高效剪枝**：动态选择边/点（如优先处理度数高的点），减少搜索空间。  
- **复杂度控制**：通过预处理必选点、边数限制等，将搜索规模约束在 `O(2^k k²)`。  

---

## **题解评分 (≥4星)**  
### **1. Alex_Wei (5星)**  
- **亮点**：  
  - 预处理必选点逻辑清晰，代码简洁。  
  - 使用 `ban` 数组标记点状态（0/1/2），避免重复计算。  
  - 组合数预计算优化，数学推导严谨。  
- **代码片段**：  
  ```cpp  
  void dfs(int rest, int cur) {  
      if(cur > k) return;  
      int e = -1;  
      for(auto it : buc) // 找到第一条未覆盖的边  
          if(ban[u[it]] != 1 && ban[v[it]] != 1) { e = it; break; }  
      if(e == -1) { // 所有边已覆盖  
          ans = (ans + bin(rest, k - cur)) % mod;  
          return;  
      }  
      int &x = ban[u[e]], &y = ban[v[e]];  
      // 枚举四种覆盖状态（选左/右/全选）  
      if(x == 0 && y == 0) {  
          x = 1, y = 1; dfs(rest-2, cur+2);  
          x = 1, y = 2; dfs(rest-2, cur+1);  
          x = 2, y = 1; dfs(rest-2, cur+1);  
          x = y = 0;  
      }  
  }  
  ```  

### **2. _Diu_ (4.5星)**  
- **亮点**：  
  - 动态选择度数最大的点，优先处理高影响节点。  
  - 使用 `set` 维护度数，实现高效删点/更新。  
  - 回溯时逆序恢复状态，减少复杂度。  
- **代码片段**：  
  ```cpp  
  void dfs(int x, int num) {  
      if(s.empty() || s.begin()->first == 0) {  
          ans = (ans + C[num][x]) % p;  
          return;  
      }  
      int t = s.begin()->second;  
      erase(t); dfs(x-1, num-1); insert(t); // 选t  
      // 不选t，则需选其所有邻居  
      for(int y : g[t]) if(!vis[y]) erase(y);  
      dfs(x - tp, num - tp - 1);  
  }  
  ```  

### **3. 船酱魔王 (4星)**  
- **亮点**：  
  - 使用线段树维护度数最大值，优化预处理步骤。  
  - 状态标记 `valid` 数组，清晰管理覆盖状态。  
  - 预处理组合数，减少计算时间。  

---

## **最优思路提炼**  
1. **必选点预处理**：删除度数 >k 的点，降低问题规模。  
2. **边数限制**：剩余边数 >k² 时直接返回 0，避免无效搜索。  
3. **状态标记法**：用 `ban` 或 `vis` 数组记录点的三种状态（未定/必选/不选），确保状态唯一性。  
4. **组合数优化**：预处理组合数，快速计算剩余点的选择方案。  

---

## **同类型题与算法套路**  
- **相似题目**：  
  - [洛谷 P1271 覆盖问题](https://www.luogu.com.cn/problem/P1271)（点覆盖的变形）  
  - [LeetCode 698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)（DFS剪枝）  
- **通用解法**：  
  - **剪枝DFS**：处理NPC问题的常用方法，通过预处理和状态标记缩小搜索空间。  
  - **组合数学结合搜索**：在确定部分选择后，用组合数快速计算剩余可能性。  

---

## **推荐练习题**  
1. **P1271**（点覆盖变形，DFS剪枝）  
2. **P1979**（华容道，BFS优化）  
3. **P1074**（靶形数独，DFS+启发式剪枝）  

---

## **个人心得摘录**  
- **Alex_Wei**：强调避免重复计算的关键在于状态标记，需仔细处理回溯时的状态恢复。  
- **Nuyoah_awa**：在枚举边状态时，必须同时确定两端点是否被覆盖，否则会重复计数。  

---

## **可视化与算法演示**  
### **DFS过程动画设计**  
1. **节点与边绘制**：  
   - 用像素方块表示节点，连线表示边。  
   - **颜色编码**：绿色（已覆盖）、红色（必选）、灰色（未覆盖）。  
2. **搜索步骤演示**：  
   - **当前边高亮**：闪烁黄色边框，表示待处理的边。  
   - **状态选择**：点击选择覆盖左/右/两端，对应节点变色。  
   - **回溯动画**：用淡出效果表示状态回退。  
3. **音效提示**：  
   - **选择节点**：8-bit 点击音效。  
   - **找到解**：胜利音效（上扬旋律）。  
   - **无解**：低沉错误音。  

### **复古游戏化设计**  
- **像素风格**：16色调色板，类似 FC 游戏《塞尔达》的网格地图。  
- **自动演示模式**：AI 按最优剪枝路径自动执行，显示搜索进度条。  
- **积分系统**：每成功覆盖一条边得 10 分，错误选择扣 5 分。  

```javascript  
// 示例：Canvas 绘制节点  
function drawNode(ctx, x, y, state) {  
    const colors = { covered: '#00FF00', required: '#FF0000', default: '#AAAAAA' };  
    ctx.fillStyle = colors[state];  
    ctx.fillRect(x*30, y*30, 25, 25); // 像素方块  
}  
```  

---

**核心搜索代码（Alex_Wei 版本）**  
```cpp  
void dfs(int rest, int cur) {  
    if(cur > k) return;  
    int e = -1;  
    // 查找第一条未覆盖的边  
    for(auto it : buc) if(ban[u[it]] != 1 && ban[v[it]] != 1) { e = it; break; }  
    if(e == -1) { // 所有边已覆盖  
        ans = (ans + bin(rest, k - cur)) % mod;  
        return;  
    }  
    int &x = ban[u[e]], &y = ban[v[e]];  
    if(x == 0 && y == 0) {  
        x = 1, y = 1; dfs(rest-2, cur+2); // 选两端  
        x = 1, y = 2; dfs(rest-2, cur+1); // 选左，右不选  
        x = 2, y = 1; dfs(rest-2, cur+1); // 选右，左不选  
        x = y = 0; // 回溯  
    }  
}  
```

---
处理用时：87.80秒
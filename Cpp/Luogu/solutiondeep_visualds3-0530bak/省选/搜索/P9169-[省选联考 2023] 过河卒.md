# 题目信息

# [省选联考 2023] 过河卒

## 题目背景

棋盘上有一个过河卒，需要走到底线。卒行走的规则是可以向左移动一格，向右移动一格或者向前移动一格。同时在棋盘上有两个另一方的棋子，需要拦截这个卒走到底线。这两个棋子的走法和帅一致，可以走到前后左右四个方向上相邻的格子。因此本题可以称为“帅拦过河卒”。

## 题目描述

有一个 $n$ 行 $m$ 列的棋盘。我们用 $(i,j)$ 表示第 $i$ 行第 $j$ 列的位置。棋盘上有一些 障碍，还有一个黑棋子和两个红棋子。

游戏的规则是这样的: 红方先走，黑方后走，双方轮流走棋。红方每次可以选择一个红棋子，向棋盘的相邻一格走一步。具体而言，假设红方选择的这个棋子位置在 $(i,j)$，那么它可以走到 $(i-1,j),(i+1,j),(i,j-1),(i,j+1)$ 中的一个，只要这个目的地在棋盘内且没有障碍且没有红方的另一个棋子。

黑方每次可以将自己的棋子向三个方向之一移动一格。具体地，假设这个黑棋子位置在 $(i,j)$，那么它可以走到 $(i-1,j),(i,j-1),(i,j+1)$ 这三个格子中的一个，只要这个目的地在棋盘内且没有障碍。

在一方行动之前，如果发生以下情况之一，则立即结束游戏，按照如下的规则判断胜负（列在前面的优先）：

- 黑棋子位于第一行。此时黑方胜。

- 黑棋子和其中一个红棋子在同一个位置上。此时进行上一步移动的玩家胜。

- 当前玩家不能进行任何合法操作。此时对方胜。

现在假设双方采用最优策略，不会进行不利于自己的移动。也就是说:

- 若存在必胜策略，则会选择所有必胜策略中，不论对方如何操作，本方后续获胜所需步数最大值最少的操作。
- 若不存在必胜策略，但存在不论对方如何行动，自己都不会落败的策略，则会选择任意一种不败策略。
- 若不存在不败策略，则会选择在所有策略中，不论对方如何操作，对方后续获胜所需步数最小值最大的操作。

如果在 $100^{100^{100}}$ 个回合之后仍不能分出胜负，则认为游戏平局。请求出游戏结束时双方一共移动了多少步，或者判断游戏平局。

## 说明/提示

**【样例 1 解释】**

第一组数据，红方第一步没有可行的移动，所以黑方胜。

第二组数据，无论第一步红方怎么移动，黑方都可以在下一步让黑棋子与红棋子在同一个位置。

第三组数据，无论第一步红方怎么移动，黑方都可以将自己的棋子往上移动一枚来达成胜利。

第四组数据，有一个红棋子不能动。另一个红棋子可以在第三行移动来防止黑棋子进入第一行。黑棋子也可以一直在第五行移动。如果红棋子到达第五行，黑棋子可以选择从另一边逃走。

第五组数据，在最后一行的那个红棋子可以从左边绕一圈抓住黑棋子。注意另一个红棋子可以移动。

**【样例 2 解释】**

这个样例中的每一组数据都满足测试点 $5$ 到 $13$ 中某一个测试点的限制。

**【子任务】**

对于所有的数据，保证：$1 \leq T \leq 10$，$2 \leq n \leq 10$，$1 \leq m \leq 10$，$\text{id}$ 等于测试点编号。

对于每组数据保证：棋盘上的黑棋恰好有一个，红棋恰好有两个，且黑棋不在第一 行。

- 测试点 $1 \sim 4$：保证要么平局，要么红方在开始时无法移动。

- 测试点 $5 \sim 6$：保证 $n \geq 4$ 。保证棋盘上第 $n-1$ 行的每一个格子都是障碍物，且 棋盘上其他行没有障碍物。保证黑棋在前 $n-2$ 行，有一个红棋在前 $n-2$ 行，另一个红棋在第 $n$ 行。

- 测试点 $7 \sim 9$：保证 $m=1$。

- 测试点 $10 \sim 13$：保证要么平局，要么存在策略可以在 $9$ 步之内结束游戏。

- 测试点 $14 \sim 20$：无特殊限制。

## 样例 #1

### 输入

```
0 5
4 5
...#O
.#..#
#O#..
.#..X
3 3
#.#
O.O
.X.
3 3
O..
.#X
.O.
5 5
.....
.....
..O..
#..#.
O#.X.
9 9
...######
.#.......
.#######.
.#.#.....
.#O#.####
.#.#.....
.#######.
.#X......
.O.......
```

### 输出

```
Black 0
Black 2
Black 2
Tie
Red 75
```

## 样例 #2

### 输入

```
见附件中的 zu/zu2.in```

### 输出

```
见附件中的 zu/zu2.ans```

# AI分析结果



### 算法分类
**BFS**

### 题解思路、算法要点与解决难点

#### 核心思路
1. **状态建模**：用六元组 `(r1x, r1y, r2x, r2y, bx, by)` 表示两个红子和黑子的坐标，通过奇偶性隐式推导当前轮次（红方先手时奇数次移动）。
2. **反向拓扑排序**：从终止状态（黑棋到第一行、棋子重合、无法移动）出发，反向推导各状态的胜负关系和步数。
3. **必胜/必败态传播**：
   - 若某状态存在必败后继，则该状态为必胜态，步数取最小。
   - 若某状态所有后继均为必胜态，则该状态为必败态，步数取最大。
4. **平局判断**：未被拓扑队列处理的状态存在环，判定为平局。

#### 解决难点
1. **状态爆炸**：通过红子等价性优化（强制 `r1 ≤ r2`）减少状态数至原规模的 1/2。
2. **步数更新策略**：必胜态选择最短路径，必败态选择最长路径，通过队列的 BFS 顺序保证正确性。
3. **移动合法性**：需严格检查红子不重叠、黑子移动方向等条件。

### 题解评分（≥4星）

1. **yllcm（5星）**
   - **亮点**：采用显式建图与反向边，步数更新逻辑清晰，代码结构简洁高效。
   - **关键代码**：
     ```cpp
     void bfs() {
         queue<int> q;
         for (int i = 0; i < tot; i++) if (vis[i]) q.push(i);
         while (!q.empty()) {
             int u = q.front(); q.pop();
             for (int i = head[u]; i; i = nxt[i]) {
                 int v = to[i];
                 if (vis[v]) continue;
                 if (g[u] == 0) { // 后继是必败态，当前为必胜态
                     g[v] = 1; f[v] = f[u] + 1;
                     vis[v] = true; q.push(v);
                 } else if (--in[v] == 0) { // 所有后继为必胜态，当前为必败态
                     g[v] = 0; f[v] = f[u] + 1;
                     vis[v] = true; q.push(v);
                 }
             }
         }
     }
     ```

2. **樱雪喵（4星）**
   - **亮点**：动态剪枝红子等价状态，减少冗余计算，代码可读性强。
   - **关键优化**：
     ```cpp
     if (R2 < R1) swap(R1, R2); // 强制红子有序
     ```

3. **EnofTaiPeople（4星）**
   - **亮点**：隐式建图避免显式存储所有边，内存占用低。
   - **核心代码**：
     ```cpp
     void dfs(...) { // 隐式生成后继状态
         for (int w = 0; w < 4; w++) {
             int nx = x + dx[w], ny = y + dy[w];
             if (valid) add_edge(current_state, next_state);
         }
     }
     ```

### 最优思路或技巧提炼
1. **状态压缩**：用坐标哈希或六维数组快速索引状态。
2. **反向传播**：从终止态逆推，避免正序博弈树的复杂分支判断。
3. **奇偶性轮次推导**：省略显式轮次维度，通过曼哈顿距离和奇偶性隐式判断。

### 同类型题与算法套路
- **类似题目**：P6560 [SBCOI2020] 时光的河流（类似博弈状态转移）
- **通用套路**：BFS + 拓扑排序处理必胜/必败态传播，适用于棋类博弈、有向图游戏等场景。

### 推荐相似题目
1. **P2730 [USACO3.2] 魔板 Magic Squares**（状态压缩+BFS）
2. **P2324 [SCOI2005] 骑士精神**（状态空间搜索）
3. **P1379 八数码难题**（BFS+哈希判重）

### 可视化与算法演示
- **动画设计**：棋盘网格中，用不同颜色标记红子、黑子，当前访问节点高亮为黄色，队列中的节点显示为绿色（待处理）和红色（已处理）。
- **步进控制**：用户可调整速度观察状态如何从终止态逆推至初始态，必胜/必败态颜色渐变。
- **复古像素风**：用 8-bit 风格绘制棋盘，移动时触发“哔”音效，找到解时播放胜利旋律。

### 代码片段（核心BFS逻辑）
```cpp
// 状态处理与拓扑排序
queue<int> q;
for (终止状态) { q.push(s); vis[s] = 1; }

while (!q.empty()) {
    int u = q.front(); q.pop();
    for (每个前驱状态v) {
        if (v未被访问) {
            if (u是必败态) {
                v标记为必胜态，步数 = u.step + 1;
                q.push(v);
            } else {
                v的入度减1;
                if (v入度 == 0) {
                    v标记为必败态，步数 = 最大后继步数 + 1;
                    q.push(v);
                }
            }
        }
    }
}
```

---
处理用时：71.38秒
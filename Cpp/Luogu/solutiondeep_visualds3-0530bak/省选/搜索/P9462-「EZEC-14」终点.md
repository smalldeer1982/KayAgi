# 题目信息

# 「EZEC-14」终点

## 题目背景

~~出题人怎么还没鸟加这首歌啊。~~

于 2023.8.5 拿下。

## 题目描述

**这是一道交互题。**

dXqwq 有一棵 $n$ 个点的无根树，结点从 $1$ 到 $n$ 编号。您需要通过若干次询问得到这棵树的结构。

您可以选择两个整数 $1\leq u,v\leq n$，并输出 `? u v` 进行询问。

对于每次询问，如果 $u,v$ 的路径中点在一个结点上，交互库返回该点的编号，否则返回 ``0``。

请通过不超过 $147154$ 次询问，得到这棵树的结构。

保证树的形态是提前确定的，即**交互库不自适应。**

### 交互方式

输入测试点所在子任务编号 $id$ 和树的大小 $n$ 以开始交互。

交互过程中，您可以进行题目描述中的询问。

对于每次询问，如果你提供的 $u,v$ 不合法或者超出询问次数上限，交互库会返回 ``-1``，否则交互库将会返回一个非负整数，含义见「题目描述」。

当你读取到 ``-1`` 后应立刻退出程序，在此之后交互库的行为未定义。

在您确定答案后，请先输出 `!`，然后接下来 $n-1$ 行依次输出两个整数 ``u[i] v[i]`` 代表树的每条边，最后退出程序。你可以以任意顺序输出这些边。

在您输出一行后，请清空缓冲区：

- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。
- 在 Pascal 中，使用 `flush(output)`。
- 在 Python 中，使用 `stdout.flush()`。
- 其它语言请自行查阅文档。

## 说明/提示

**本题采用捆绑测试。**

-  Subtask 1（10 pts）：$n \leq 10$，树满足性质 A。
-  Subtask 2（10 pts）：保证存在一个点度数为 $n-1$。
-  Subtask 3（10 pts）：保证所有点度数 $\leq 2$。
-  Subtask 4（10 pts）：$n \leq 500$，树满足性质 A。
-  Subtask 5（20 pts）：$n \leq 500$。 
-  Subtask 6（20 pts）：树满足性质 A。
-  Subtask 7（20 pts）：无特殊限制。

性质 A：对于 $i=2,3,\cdots,n$ 存在整数 $1\leq j<i$ 满足有一条边连接 $i,j$。

对于 $100\%$ 的数据，$2 \leq n \leq 10^4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/3u2zy1q5.png)

## 样例 #1

### 输入

```
1 5

1

2

3

4

0```

### 输出

```
 
? 1 1

? 1 3

? 2 4

? 3 5

? 4 5

!
1 2
2 3
3 4
4 5```

## 样例 #2

### 输入

```
5 5

1

0

0

2

2```

### 输出

```
 
? 1 1

? 1 3

? 2 4

? 3 5

? 4 5

!
1 3
2 3
2 4
2 5```

# AI分析结果



## 算法分类
**BFS**

---

## 综合分析与结论
### 核心思路与难点
题目要求通过中点询问还原树结构，核心难点在于如何高效利用路径中点信息确定父子关系。各题解的核心共性如下：
1. **寻找相邻节点**：通过多次中点询问找到与根节点相邻的点，作为 BFS 的起点。
2. **层次化处理**：利用 BFS 队列处理节点，动态挂起未确定的查询，逐步扩展树结构。
3. **中点迭代优化**：对每个节点，通过多次中点询问逐步逼近父节点，次数为 O(log n)。

### 可视化设计
1. **节点状态标记**：
   - 红色：当前正在处理的节点。
   - 绿色：已确定父节点的节点。
   - 蓝色：队列中待处理的节点。
2. **动画流程**：
   - **步骤1**：展示根节点 1 与相邻节点 p 的确定过程。
   - **步骤2**：队列初始化，加入 1 和 p。
   - **步骤3**：取出队首节点 u，处理挂在其下的所有查询：
     - 询问 u 与其他节点中点，若确定父节点则标记为绿色并加入队列。
     - 无法确定则挂到新的中点对应节点下。
   - **步骤4**：循环直到队列为空，树结构完全展开。

---

## 题解评分 (≥4星)
1. **dead_X（5星）**
   - **亮点**：使用队列优化挂起查询，代码简洁高效。
   - **关键代码**：
     ```cpp
     queue<int> q;
     fa[1]=id, fa[id]=1, q.push(1), q.push(id);
     while (!q.empty()) {
         int x = q.front(); q.pop();
         for (int y : d[x]) {
             int z = query(fa[x], y);
             if (z == x) fa[y] = x, q.push(y);
             else d[z].push_back(y);
         }
     }
     ```
2. **by_chance（4星）**
   - **亮点**：分阶段处理深度与父节点，逻辑清晰。
   - **关键代码**：
     ```cpp
     for (int u=1; u<=n; u++) if (dep[u]==i) {
         int v=st;
         while (dep[v] != i-1) {
             query(u, v, w);
             if (w == 0) v = fa[v];
             else v = w;
         }
         ans(u, v);
     }
     ```

---

## 最优思路提炼
1. **相邻节点快速定位**：通过中点询问次数最多的点确定根的直接邻居。
2. **BFS 队列挂载查询**：将未确定的查询动态挂到已处理节点，减少重复询问。
3. **中点迭代逼近父节点**：每次将路径长度折半，直至确定父子关系。

---

## 同类题目推荐
1. **P1352 没有上司的舞会**（树形 DP）
2. **P3379 【模板】最近公共祖先**（LCA 与路径中点）
3. **P1395 树的直径**（利用 BFS 求树的最长路径）

---

## 可视化与算法演示（核心逻辑）
```javascript
// 伪代码示例：BFS 队列处理挂载查询
class Visualization {
  constructor(n) {
    this.queue = [1, p]; // 初始队列
    this.tree = {1: [], p: [1]}; // 树结构
    this.hangingQueries = new Map(); // 挂起的查询
  }

  processNode(u) {
    const queries = this.hangingQueries.get(u) || [];
    for (const v of queries) {
      const mid = askMidpoint(u, v);
      if (mid === u) {
        this.tree[v] = u;
        this.queue.push(v);
      } else {
        this.hangingQueries.set(mid, [...(this.hangingQueries.get(mid) || []), v]);
      }
    }
  }

  run() {
    while (this.queue.length > 0) {
      const u = this.queue.shift();
      this.processNode(u);
      this.render(); // 更新画布
    }
  }
}
```

**复古像素风格设计**：
- **颜色方案**：16色调色板，绿色（#00FF00）表示已处理节点，红色（#FF0000）表示当前节点。
- **音效**：访问节点时播放 8-bit "beep" 音效，确定父节点时播放上升音阶。
- **Canvas 绘制**：节点以 16x16 像素方块表示，边用 2px 白色线条连接。

---

**总结**：本题通过 BFS 队列动态处理挂载查询，结合中点迭代优化，高效还原树结构。可视化可设计为层次扩展动画，突出队列处理与节点状态变化。

---
处理用时：73.34秒
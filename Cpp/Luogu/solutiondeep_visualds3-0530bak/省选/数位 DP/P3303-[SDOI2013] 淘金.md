# 题目信息

# [SDOI2013] 淘金

## 题目描述

小 Z 在玩一个叫做《淘金者》的游戏。游戏的世界是一个二维坐标。$X$ 轴、$Y$ 轴坐标范围均为$1\ldots N$。初始的时候，所有的整数坐标点上均有一块金子，共 $N^2$ 块。

一阵风吹过，金子的位置发生了一些变化。细心的小 Z 发现，初始在 $(i,j)$ 坐标处的金子会变到 $(f(i),f(j))$ 坐标处。其中 $f(x)$ 表示 $x$ 各位数字的乘积，例如 $f(99)=81,~f(12)=2,~f(10)=0$。

如果金子变化后的坐标不在 $1\ldots N$ 的范围内，我们认为这块金子已经被移出游戏。同时可以发现，对于变化之后的游戏局面，某些坐标上的金子数量可能不止一块，而另外一些坐标上可能已经没有金子。这次变化之后，游戏将不会再对金子的位置和数量进行改变，玩家可以开始进行采集工作。

小 Z 很懒，打算只进行 $K$ 次采集。每次采集可以得到某一个坐标上的所有金子，采集之后，该坐标上的金子数变为 $0$。

现在小 Z 希望知道，对于变化之后的游戏局面，在采集次数为 $K$ 的前提下，最多可以采集到多少块金子？ 答案可能很大，小 Z 希望得到对 $10^9+7$ 取模之后的答案。

## 说明/提示

对于 $100\%$ 的数据，$N \leq 10^{12}, K \leq \min(N^2, 10^5)$。


## 样例 #1

### 输入

```
12 5```

### 输出

```
18```

# AI分析结果



### 算法分类  
**数位DP + 优先队列（堆）**

---

### 题解思路与算法要点  
#### 核心问题分解  
1. **计算每个可能乘积值的出现次数**  
   - 通过数位DP统计所有可能的乘积值（形式为 \(2^a3^b5^c7^d\)）的个数  
   - 使用离散化或哈希表优化状态存储  

2. **前K大乘积对的快速求解**  
   - 对乘积值排序后，用最大堆维护当前可能的乘积对组合  
   - 通过指针移动策略避免重复计算  

---

### 题解评分（≥4星）  
1. **xyz32768（★★★★☆）**  
   - **亮点**：  
     - 离散化处理将乘积状态压缩到1.4万级别  
     - 堆操作时维护指针避免重复计算  
     - 代码中明确分离数位DP和堆操作逻辑  

2. **Aleph1022（★★★★☆）**  
   - **亮点**：  
     - 使用哈希表动态记录有效乘积值  
     - 引入`__int128`避免乘积溢出  
     - 代码模块化清晰，包含预处理和堆操作  

3. **s_r_f（★★★★☆）**  
   - **亮点**：  
     - 通过多重全排列公式快速计算方案数  
     - 代码中直接枚举质因数分解优化状态数  
     - 优先队列操作时记录是否连续移动指针  

---

### 最优思路提炼  
#### 关键步骤  
1. **数位DP状态设计**  
   - 状态：\(dp[pos][product][limit]\) 表示处理到第\(pos\)位，当前乘积为\(product\)，是否受上限限制  
   - 优化：仅保留有效的乘积值（离散化或质因数分解）  

2. **堆的贪心策略**  
   - 初始将所有最大值的配对（\(i, 1\)）加入堆  
   - 每次弹出堆顶后，将下一个可能的配对（\(i, j+1\)）重新入堆  

#### 优化技巧  
- **离散化**：将乘积值映射到整数ID，减少内存占用  
- **质因数分解**：仅维护2/3/5/7的指数，避免直接存储大数  
- **堆的指针维护**：避免重复计算，时间复杂度优化到\(O(K \log N)\)  

---

### 同类型题推荐  
1. **P2602 数字计数**（数位DP基础）  
2. **P3311 数数**（带有限制条件的数位DP）  
3. **P1972 集合**（优先队列维护前K大值）  

---

### 可视化算法演示  
#### 动画设计  
1. **数位DP过程**  
   - **像素风格**：用8位像素格子表示每一位数字选择  
   - **颜色标记**：  
     - 绿色：当前位选择较小数字（触发非限制状态）  
     - 红色：当前位达到上限（限制状态延续）  
   - **动态更新**：右侧显示当前乘积的质因数分解指数变化  

2. **堆操作过程**  
   - **网格展示**：将排序后的乘积值排列为网格，点击格子高亮当前配对  
   - **堆结构可视化**：用树状图展示堆中的最大元素，每次弹出时播放“金币收集”音效  

3. **复古交互**  
   - **音效**：  
     - 按键音效：每次数字选择时播放8位机“哔”声  
     - 成功音效：找到前K大值时播放经典《超级马里奥》金币音效  
   - **自动演示模式**：AI自动执行数位DP和堆操作，速度可调  

---

### 代码片段（核心逻辑）  
#### 数位DP状态转移（xyz32768）  
```cpp  
// 离散化预处理  
void DP(ll num) {  
    int i, j, k, n = 0;  
    while (num) a[++n] = num % 10, num /= 10;  
    // 初始化第一位  
    For (k, 1, 9)  
        f[1][orz[k]][k > a[1]]++;  
    // 数位DP转移  
    For (i, 2, n) For (j, 1, QAQ) For (k, 1, 9) {  
        ll q = otz[j];  
        if (q % k != 0) continue;  
        int h = orz[q / k];  
        // 状态转移分支  
        if (k < a[i]) f[i][j][0] += f[i-1][h][0] + f[i-1][h][1];  
        else if (k > a[i])  
            f[i][j][1] += f[i-1][h][0] + f[i-1][h][1];  
        else {  
            f[i][j][0] += f[i-1][h][0];  
            f[i][j][1] += f[i-1][h][1];  
        }  
    }  
}  
```

---

### 个人心得摘录  
> **s_r_f**：  
> “数位DP中前导零的处理需要特别小心，必须保证至少有一位非零数字。通过分离前导零状态，代码可读性大幅提升。”  
>   
> **Aleph1022**：  
> “使用`__int128`虽然牺牲了部分可移植性，但在时间紧迫的比赛环境中，能快速解决乘积溢出问题。”  

---

### 复古像素动画实现（伪代码）  
```javascript  
// Canvas初始化  
const canvas = document.getElementById('pixel-canvas');  
const ctx = canvas.getContext('2d');  
const TILE_SIZE = 16;  

// 数位DP动画  
function drawDigitDP(pos, product, limit) {  
    // 绘制当前位选择  
    ctx.fillStyle = limit ? '#FF4444' : '#44FF44';  
    ctx.fillRect(pos*TILE_SIZE, 0, TILE_SIZE, TILE_SIZE);  
    // 播放音效  
    playSound('beep');  
}  

// 堆操作动画  
function drawHeapPair(i, j) {  
    // 高亮当前配对  
    ctx.strokeStyle = '#FFFF00';  
    ctx.strokeRect(i*TILE_SIZE, j*TILE_SIZE, TILE_SIZE, TILE_SIZE);  
}  
```

---
处理用时：89.33秒
# 题目信息

# SAC#1 - 萌数

## 题目背景

本题由世界上最蒟蒻的 SOL 提供。

寂月城网站是完美信息教室的官网。地址：<http://191.101.11.174/mgzd>。


## 题目描述

蒟蒻 SOL 居然觉得数很萌！

好在在他眼里，并不是所有数都是萌的。只有满足“存在长度至少为 $2$ 的回文子串”的数是萌的——也就是说，$101$ 是萌的，因为 $101$ 本身就是一个回文数；$110$ 是萌的，因为包含回文子串 $11$；但是 $102$ 不是萌的，$1201$ 也不是萌的。

现在 SOL 想知道从 $l$ 到 $r$ 的所有整数中有多少个萌数。

由于答案可能很大，所以只需要输出答案对 $1000000007$（$10^9+7$）的余数。

## 说明/提示

记 $n$ 为 $r$ 在 $10$ 进制下的位数。

对于 $10\%$ 的数据，$n \le 3$。

对于 $30\%$ 的数据，$n \le 6$。

对于 $60\%$ 的数据，$n \le 9$。

对于全部的数据，$n \le 1000$，$l < r$。


------------

2024/2/4 添加一组 hack 数据。

## 样例 #1

### 输入

```
1 100```

### 输出

```
10```

## 样例 #2

### 输入

```
100 1000```

### 输出

```
253```

# AI分析结果



# SAC#1 - 萌数 题解分析

## 算法分类
数位动态规划（数位DP）

---

## 核心思路与解决难点

### 核心思路
通过数位DP统计区间内**存在长度≥2的回文子串**的数的个数。由于数据范围极大（10^1000），必须采用数位DP处理。

### 解决难点
1. **回文判定**：只需判断当前位与前一位或前前位是否相等（对应偶回文`aa`或奇回文`aba`）。
2. **大数处理**：输入为字符串，需特殊处理L-1的高精度减法。
3. **状态设计**：需记录前两位数字，以及是否已出现回文子串。
4. **前导零处理**：前导零不影响回文判断，需用特殊标记区分。

---

## 最优思路与技巧提炼

### 反向计算法（非萌数）
1. **逆向思维**：计算非萌数（没有回文子串）的数量，总数-非萌数=答案。
2. **状态转移方程**：
   ```cpp
   f[i][j][k] += sum(f[i-1][k][l])  // 确保j≠k且l≠k且l≠j
   ```
3. **前导零处理**：通过特殊值（如10）表示无效位，避免数组越界。

### 状态设计
- `dp[pos][pre1][pre2][exist]`：当前位置、前两位的值、是否已存在回文子串。
- **剪枝优化**：若已存在回文子串，后续状态直接累加所有可能性。

---

## 关键题解评分（≥4星）

### 题解：George1123（5星）
- **亮点**：状态设计清晰，特殊处理前导零为10，避免越界；详细注释与博客链接。
- **代码片段**：
  ```cpp
  lng Dfs(int w,int d,int ld,bool free,bool hw){
    if(!w) return hw;
    if(free&&~f[w][d][ld][hw]) return f[w][d][ld][hw];
    int up=free?9:nl[w]; lng res=0;
    for(int i=0;i<=up;i++)
        (res+=Dfs(w-1,i,d,free||i<up,hw||i==d||i==ld))%=mod;
    if(free) f[w][d][ld][hw]=res;
    return res;
  }
  ```

### 题解：AlanSP（4星）
- **亮点**：递推式数位DP实现，状态转移方程明确，无递归栈溢出风险。
- **代码片段**：
  ```cpp
  for(int i=2;i<=1000;i++)
    for(int j=0;j<=9;j++)
        for(int k=0;k<=9;k++)
            if(j!=k) f[i][j][k] = (f[i][j][k] + ...) % mod;
  ```

### 题解：ChenJr（4星）
- **亮点**：状态压缩为三维，包含前两位和存在标记，代码简洁高效。
- **代码片段**：
  ```cpp
  ll dfs(int pos, int pre1, int pre2, bool exist, ...) {
    if (exist) return ...; // 剪枝
    for (int i=0; i<=up; i++)
        if (i != pre1 && i != pre2) res += dfs(...);
  }
  ```

---

## 可视化设计

### 动画方案（复古像素风格）
1. **网格绘制**：在Canvas中以像素块表示数位，不同颜色区分前导零、有效位。
2. **状态高亮**：
   - **红色**：当前位与前一位相同（触发回文）。
   - **黄色**：非萌数转移路径。
3. **音效设计**：
   - **触发回文**：播放8-bit "成功"音效。
   - **借位处理**：播放短促"点击"声。
4. **自动演示**：模拟DFS搜索路径，按数位逐位展开，速度可调。

### 关键帧示例
1. **输入处理**：字符串"110"分解为数位数组`[0,1,1]`，高亮借位过程。
2. **状态转移**：展示第3位选择0时，与前两位`1,1`形成回文，触发红色标记。

---

## 相似题目推荐
1. [P2657 windy数](https://www.luogu.com.cn/problem/P2657)（数位DP基础）
2. [P4124 手机号码](https://www.luogu.com.cn/problem/P4124)（状态设计进阶）
3. [P3286 方伯伯的商场之旅](https://www.luogu.com.cn/problem/P3286)（复杂数位处理）

---

## 总结
通过数位DP记录前两位状态，结合逆向思维简化计算。关键点在于状态设计与前导零处理，可视化可有效展示状态转移与回文触发机制。

---
处理用时：85.05秒
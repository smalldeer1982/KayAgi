# 题目信息

# [NOIP 2000 提高组] 进制转换

## 题目背景

NOIP2000 提高组 T1

## 题目描述

我们可以用这样的方式来表示一个十进制数：将每个阿拉伯数字乘以一个以该数字所处位置为指数，以 $10$ 为底数的幂之和的形式。例如 $123$ 可表示为 $1 \times 10^2+2\times 10^1+3\times 10^0$ 这样的形式。

与之相似的，对二进制数来说，也可表示成每个二进制数码乘以一个以该数字所处位置为指数，以 $2$ 为底数的幂之和的形式。  

一般说来，任何一个正整数 $R$ 或一个负整数 $-R$ 都可以被选来作为一个数制系统的基数。如果是以 $R$ 或 $-R$ 为基数，则需要用到的数码为 $0,1,\dots,R-1$。  

例如当 $R=7$ 时,所需用到的数码是 $0,1,2,3,4,5,6$，这与其是 $R$ 或 $-R$ 无关。如果作为基数的数绝对值超过 $10$，则为了表示这些数码，通常使用英文字母来表示那些大于 $9$ 的数码。例如对 $16$ 进制数来说,用 $A$ 表示 $10$，用 $B$ 表示 $11$，用 $C$ 表示 $12$，以此类推。

在负进制数中是用 $-R $ 作为基数，例如 $-15$（十进制）相当于 $(110001)_{-2}$（$-2$进制），并且它可以被表示为 $2$ 的幂级数的和数：

$$(110001)_{-2}=1\times (-2)^5+1\times (-2)^4+0\times (-2)^3+0\times (-2)^2+0\times (-2)^1 +1\times (-2)^0$$

设计一个程序，读入一个十进制数和一个负进制数的基数，并将此十进制数转换为此负进制下的数。


## 说明/提示

**数据范围**

对于 $100\%$ 的数据，$-20 \le R \le -2$，$|n| \le 37336$。




## 样例 #1

### 输入

```
30000 -2```

### 输出

```
30000=11011010101110000(base-2)```

## 样例 #2

### 输入

```
-20000 -2```

### 输出

```
-20000=1111011000100000(base-2)```

## 样例 #3

### 输入

```
28800 -16```

### 输出

```
28800=19180(base-16)```

## 样例 #4

### 输入

```
-25000 -16```

### 输出

```
-25000=7FB8(base-16)```

# AI分析结果



### 数学分类选择
**数论**

---

### 题解思路、算法要点与解决难点

#### 核心思路与数学方法
- **关键公式**：基于除法的基本等式 `被除数 = 商 × 除数 + 余数`。当负进制转换中出现负余数时，通过调整商和余数使得余数为正：
  - **调整公式**：若余数 `r < 0`，则令 `余数 -= 基数`，同时 `商 += 1`，保证等式成立。
  - **证明**：调整后，`被除数 = (商+1) × 基数 + (余数-基数) = 商 × 基数 + 余数`，与原等式一致。

#### 解决难点
1. **负余数处理**：必须将余数转换为正数，否则无法正确表示负进制数的每一位。
2. **逆序输出**：通过递归或栈结构实现余数的倒序拼接。
3. **高位字符处理**：余数超过9时需转换为字母（如'A'表示10）。

#### 代码实现要点
- **循环或递归**：不断除以基数，处理余数后更新商。
- **字符转换**：用查表法将余数映射为字符。

---

### 题解评分（≥4星）

1. **老卡手机（5星）**
   - **亮点**：递归实现简洁，直接输出倒序结果；注释清晰，代码可读性高。
   - **代码片段**：
     ```cpp
     void zhuan(int n, int r) {
         if (n == 0) return;
         int m = n % r;
         if (m < 0) m -= r, n += r; // 调整余数为正
         zhuan(n / r, r);
         printf("%c", m >= 10 ? 'A' + m - 10 : m + '0');
     }
     ```

2. **judgejudge（4星）**
   - **亮点**：详细数学推导，分步解释调整逻辑；数组存储余数，适合教学。
   - **代码片段**：
     ```cpp
     while (n != 0) {
         int j = n % m;
         n /= m;
         if (j < 0) j -= m, n--; // 调整余数
         a[++l] = j < 10 ? j + '0' : j - 10 + 'A';
     }
     ```

3. **ikunTLE（4星）**
   - **亮点**：递归与字符转换结合紧密，代码简短高效。
   - **代码片段**：
     ```cpp
     void dfs(int x) {
         if (!x) return;
         int q = x / b, r = x % b;
         if (r < 0) ++q, r -= b; // 调整余数
         dfs(q);
         putchar(r < 10 ? r + '0' : r - 10 + 'A');
     }
     ```

---

### 最优思路或技巧提炼
- **余数调整公式**：`余数 -= 基数`，`商 += 1`。
- **递归倒序输出**：递归调用后输出余数，天然形成逆序。
- **查表法转换字符**：预定义字符数组 `"0123456789ABCDEF..."` 快速映射。

---

### 同类型题或类似算法套路
- **通用进制转换**：处理正/负基数的统一方法，核心在于余数调整。
- **扩展场景**：非整数进制（如平衡三进制）、大数进制转换（需高精度运算）。

---

### 推荐题目
1. **P1022 进制位**（NOIP 提高组，涉及进制验证）
2. **P1143 进制转换**（基础进制转换，正基数）
3. **P2084 进制转换**（大数进制转换）

---

### 个人心得摘录
- **老卡手机**：递归输出顺序是关键，写在递归调用后自动倒序。
- **Temp113**：调试发现余数调整后需立即更新商，否则后续计算错误。
- **Dancepted**：暴力法仅适用于小数据，但验证了负进制数的唯一性。

---

### 可视化与算法演示
#### 动画设计
1. **核心步骤可视化**：
   - **当前操作**：高亮当前余数计算（红色框），显示调整前后的值。
   - **字符生成**：将调整后的余数转换为字符，添加到结果字符串末尾（绿色闪烁）。
   - **逆序输出**：最终结果字符串从右向左展开，模拟倒序过程。

2. **复古像素风格**：
   - **Canvas 绘制**：用16x16像素块表示余数、商和中间结果。
   - **音效**：调整余数时播放“哔”声，生成字符时播放“叮”声。

3. **交互控制**：
   - **步进按钮**：单步执行除法与余数调整。
   - **参数调节**：允许输入不同十进制数和基数，实时观察转换过程。

#### 示例动画流程
```plaintext
Step 1: 输入 n= -15, r= -2
Step 2: 计算余数: -15 % -2 = -1 → 调整后余数=1，商=7
Step 3: 递归处理商=7 → 余数=1，字符 '1'
Step 4: 最终逆序输出: '110001'
```

---
处理用时：74.14秒
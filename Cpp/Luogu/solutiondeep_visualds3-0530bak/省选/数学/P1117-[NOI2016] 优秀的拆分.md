# 题目信息

# [NOI2016] 优秀的拆分

## 题目描述

如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  
例如，对于字符串 $ \texttt{aabaabaa} $ ，如果令 $\text{A}=\texttt{aab}$，$\text{B}=\texttt{a}$，我们就找到了这个字符串拆分成 $\text{AABB}$ 的一种方式。

一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  
比如我们令 $\text{A}=\texttt{a}$，$\text{B}=\texttt{baa}$，也可以用 $\text{AABB}$ 表示出上述字符串；但是，字符串 $\texttt{abaabaa}$ 就没有优秀的拆分。

现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。

以下事项需要注意：

1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。
2. 在一个拆分中，允许出现 $\text{A}=\text{B}$。例如 $\texttt{cccc}$ 存在拆分 $\text{A}=\text{B}=\texttt{c}$。
3. 字符串本身也是它的一个子串。

## 说明/提示

### 样例解释

我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。

第一组数据中，共有三个子串存在优秀的拆分：  
$S[1,4]=\texttt{aabb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{b}$；  
$S[3,6]=\texttt{bbbb}$，优秀的拆分为 $\text{A}=\texttt{b}$，$\text{B}=\texttt{b}$；  
$S[1,6]=\texttt{aabbbb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{bb}$。  
而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。

第二组数据中，有两类，总共四个子串存在优秀的拆分：  
对于子串 $S[1,4]=S[2,5]=S[3,6]=\texttt{cccc}$，它们优秀的拆分相同，均为 $\text{A}=\texttt{c}$，$\text{B}=\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  
对于子串 $S[1,6]=\texttt{cccccc}$，它优秀的拆分有两种：$\text{A}=\texttt{c}$，$\text{B}=\texttt{cc}$ 和 $\text{A}=\texttt{cc}$，$\text{B}=\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  
所以第二组数据的答案是 $3+2=5$。

第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。

第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。

我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：

| 测试点编号   | $n \leq$  | 特殊性质           |
| ------------ | --------- | ------------------ |
| $1 \sim 2$   | $300$     | $S$ 中所有字符相同 |
| $3 \sim 4$   | $2\,000$  | $S$ 中所有字符相同 |
| $5 \sim 6$   | $10$      |                    |
| $7 \sim 8$   | $20$      |                    |
| $9 \sim 10$  | $30$      |                    |
| $11 \sim 12$ | $50$      |                    |
| $13 \sim 14$ | $100$     |                    |
| $15$         | $200$     |                    |
| $16$         | $300$     |                    |
| $17$         | $500$     |                    |
| $18$         | $1\,000$  |                    |
| $19$         | $2\,000$  |                    |
| $20$         | $30\,000$ |                    |

## 样例 #1

### 输入

```
4
aabbbb
cccccc
aabaabaabaa
bbaabaababaaba
```

### 输出

```
3
5
4
7
```

# AI分析结果



**唯一算法分类**  
无算法分类

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
将问题转化为统计每个位置作为AA型子串的结尾和开头的次数，利用后缀数组（SA）快速计算LCP（最长公共前缀）和LCS（最长公共后缀），并通过调和级数枚举优化时间复杂度至 \( O(n \log n) \)。

#### **关键步骤**
1. **定义数组**  
   - `a[i]`：以 `i` 结尾的AA型子串数量  
   - `b[i]`：以 `i` 开头的AA型子串数量  
   答案即 \(\sum_{i=1}^{n-1} a[i] \cdot b[i+1]\)。

2. **枚举长度**  
   枚举AA型子串中单个A的长度 `len`，每隔 `len` 设置关键点。例如，关键点为 `i=len, 2len, 3len, ...`。

3. **计算LCP与LCS**  
   对相邻关键点 `i` 和 `j=i+len`，计算：  
   - `LCP(i, j)`：以 `i` 和 `j` 开头的后缀的最长公共前缀  
   - `LCS(i-1, j-1)`：以 `i-1` 和 `j-1` 结尾的前缀的最长公共后缀  
   若 `LCP + LCS ≥ len`，则存在跨关键点的AA型子串。

4. **差分数组更新**  
   根据LCP和LCS的结果，确定AA型子串的区间，用差分数组高效更新 `a` 和 `b`。

---

### **题解评分（≥4星）**

1. **作者：Gypsophila（赞：169）**  
   **评分：★★★★★**  
   - 思路清晰，详细推导LCP/LCS与差分的关系  
   - 代码使用SA+ST表高效计算LCP  
   - 关键点枚举结合调和级数优化时间复杂度  

2. **作者：何俞均（赞：41）**  
   **评分：★★★★☆**  
   - 代码完整，差分数组实现简洁  
   - 使用后缀数组预处理，但未充分解释调和级数优化  

3. **作者：big_news（赞：15）**  
   **评分：★★★★☆**  
   - 引入Runs理论，时间复杂度更优（\( O(n \log n) \)）  
   - 代码复杂度较高，但提供新颖思路  

---

### **最优思路或技巧提炼**

1. **调和级数枚举**  
   枚举长度 `len` 时，关键点数量为 \( O(n / len) \)，总时间复杂度为 \( O(n \log n) \)。

2. **差分数组优化**  
   区间更新 `a` 和 `b` 时，差分数组将区间操作转化为两次单点操作，时间复杂度降为 \( O(1) \)。

3. **SA+ST表快速查询LCP/LCS**  
   正反两次SA预处理，结合ST表实现 \( O(1) \) 查询。

---

### **同类型题或类似算法套路**

1. **AA型子串统计**  
   - 核心：拆分字符串为重复结构  
   - 常见优化：调和级数枚举、差分数组  

2. **多关键点分析**  
   - 如CF319D（类似题目，需处理重复子串删除）  

---

### **推荐相似题目**

1. **P3809 【模板】后缀排序**  
   - 后缀数组基础应用  

2. **P3763 [TJOI2017]DNA**  
   - 利用LCP进行字符串匹配  

3. **P5341 [TJOI2019]甲苯先生和大中锋的字符串**  
   - 统计特定长度重复子串  

---

### **可视化与算法演示**

#### **动画设计**
1. **关键点标记**  
   - 用红色方块标记关键点 `i` 和 `j=i+len`  
   - 绿色线段表示LCP，蓝色线段表示LCS  

2. **区间更新可视化**  
   - 显示差分数组更新区间 `[i-LCS+1, i+LCP]`  
   - 黄色高亮表示当前操作的区间  

3. **像素风格**  
   - 使用8位像素风格绘制字符串，关键点用闪烁效果  
   - 音效：计算LCP时播放“滴”声，更新差分时播放“咔”声  

#### **代码片段（差分更新）**
```cpp
for (int len = 1; len <= n / 2; len++) {
    for (int i = len, j = i + len; j <= n; i += len, j += len) {
        int lcp = min(A.query(i, j), len);
        int lcs = min(B.query(n - i + 1, n - j + 1), len - 1);
        if (lcp + lcs >= len) {
            int t = lcp + lcs - len + 1;
            // 更新差分数组
            g[i - lcs]++, g[i - lcs + t]--;
            f[j + lcp - t]++, f[j + lcp]--;
        }
    }
}
```

---

### **个人心得摘录**

1. **调试踩坑**  
   - 需注意LCP和LCS的边界条件，避免越界访问（如 `i=1` 时无LCS）。  

2. **优化顿悟**  
   - 将区间更新转化为差分操作是核心技巧，避免暴力更新导致超时。  

---

### **复古游戏化动画效果（伪代码）**

```javascript
// 初始化Canvas与像素风格
const canvas = document.getElementById("pixel-canvas");
const ctx = canvas.getContext("2d");
const colors = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4"];

// 绘制关键点与区间
function drawKeyPoints(len) {
    for (let i = len; i <= n; i += len) {
        drawPixel(i, colors[0]); // 红色标记关键点
    }
}

// 音效触发
function playSound(effect) {
    const audio = new Audio(`sfx/${effect}.wav`);
    audio.play();
}

// 自动演示模式
function autoPlay() {
    for (let len = 1; len <= n / 2; len++) {
        drawKeyPoints(len);
        playSound("step");
        // 计算并绘制LCP/LCS...
    }
}
```

---

**总结**：通过后缀数组快速计算LCP/LCS，结合调和级数枚举与差分数组，将时间复杂度优化至 \( O(n \log n) \)，是解决此类字符串统计问题的经典方法。

---
处理用时：86.19秒
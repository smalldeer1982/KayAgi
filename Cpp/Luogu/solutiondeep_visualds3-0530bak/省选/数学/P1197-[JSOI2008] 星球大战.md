# 题目信息

# [JSOI2008] 星球大战

## 题目描述

很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治着整个星系。

某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。

但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。

现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le m \le 2\times 10^5$，$1\le n \le 2m$，$x \neq y$。

[JSOI2008]


## 样例 #1

### 输入

```
8 13
0 1
1 6
6 5
5 0
0 6
1 2
2 3
3 4
4 5
7 1
7 2
7 6
3 6
5
1
6
3
5
7
```

### 输出

```
1
1
1
2
3
3```

# AI分析结果



**唯一算法分类**：逆向处理 + 并查集

---

### **综合分析与结论**
1. **核心思路**  
   - **逆向思维**：将摧毁操作转换为逆向的“恢复”操作，利用并查集逐步合并连通块，避免直接处理删除操作。  
   - **离线处理**：先处理所有被摧毁的节点，构建初始连通图；逆序恢复节点，动态维护连通块数目。  
   - **关键操作**：  
     - **初始阶段**：排除所有被摧毁节点，构建初始连通块。  
     - **恢复阶段**：每恢复一个节点，遍历其邻接边合并连通块，统计当前连通块数目。  

2. **解决难点**  
   - **并查集无法删除**：通过逆向处理，将摧毁转化为合并。  
   - **高效合并**：邻接表存储图结构，仅处理当前恢复节点的邻接边。  
   - **连通块统计**：初始数目为 `n - k`（被摧毁节点数），每次恢复节点后数目变化通过合并次数动态调整。

3. **可视化设计**  
   - **动画流程**：  
     1. **初始状态**：被摧毁节点显示为灰色，未被摧毁节点为绿色，连通块用相同颜色填充。  
     2. **恢复节点**：高亮当前恢复的节点（变为红色），遍历其邻接边，若邻接节点未被摧毁且处于不同连通块，触发合并动画（颜色渐变）。  
     3. **统计更新**：每次合并后更新屏幕右侧的连通块数目。  
   - **复古像素风格**：  
     - **节点**：用 16x16 像素方块表示，不同颜色区分状态（绿=存活，灰=被毁，红=恢复中）。  
     - **边**：用 8-bit 风格的线段连接，合并时线段闪烁黄色。  
   - **音效设计**：  
     - **恢复节点**：播放短促的“滴”声。  
     - **合并成功**：播放上升音阶。  
     - **统计更新**：播放轻微“咔哒”声。  

---

### **题解清单 (≥4星)**
1. **碳六灵（赞238）**  
   - **亮点**：代码简洁，注释清晰，通过双向存图处理无向边，逆序合并时直接遍历邻接表。  
   - **关键代码**：  
     ```cpp
     for(int i=k;i>=1;i--) {
         int u=broken[i];
         total++; // 恢复一个节点，连通块+1
         Broken[u]=0;
         for (遍历邻接边并合并)
         ans[i]=total;
     }
     ```

2. **Golden_Winter（赞74）**  
   - **亮点**：对边按修复时间排序，统一合并，避免重复遍历。  
   - **关键优化**：  
     ```cpp
     for 所有边:
         a[i].c = max(被摧毁时间u, 被摧毁时间v)
     sort(边按c从小到大)
     ```

3. **yizimi远欣（赞27）**  
   - **亮点**：详细调试过程展示思路演进，最终通过邻接表优化避免超时。  
   - **心得摘录**：  
     > “并查集在合并时必须判断是否在同一集合，否则会重复减少计数。”

---

### **核心代码实现**
```cpp
// 初始化并查集，排除被摧毁节点
int total = n - k;
for (int i = 0; i < n; i++) {
    if (!destroyed[i]) {
        for (auto v : adj[i]) {
            if (!destroyed[v] && find(i) != find(v)) {
                unite(i, v);
                total--;
            }
        }
    }
}

// 逆序恢复节点
stack<int> ans;
ans.push(total); // 初始状态
for (int i = k - 1; i >= 0; i--) {
    int u = destroyed_list[i];
    destroyed[u] = 0;
    total++; // 恢复节点，暂时独立
    for (auto v : adj[u]) {
        if (!destroyed[v] && find(u) != find(v)) {
            unite(u, v);
            total--;
        }
    }
    ans.push(total);
}
```

---

### **同类型题与拓展**
1. **P3144 [USACO16OPEN]关闭农场**  
   - **相似点**：同样需要逆向处理动态连通性问题。  
2. **P1653 猴子**  
   - **相似点**：动态断边，需逆向合并维护连通性。  
3. **P1197 [JSOI2008]星球大战（本题）**  
   - **直接关联**：完全相同的逆向处理思路。

---

### **复古像素动画代码片段（Canvas）**
```javascript
// 绘制节点（伪代码）
function drawNode(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * 20, y * 20, 16, 16); // 像素方块
}

// 合并动画
function animateMerge(u, v) {
    let uPos = getPosition(u);
    let vPos = getPosition(v);
    drawLine(uPos, vPos, "#FFD700"); // 高亮边为金色
    playSound("merge_sound.wav");
}
```

---

### **个人心得**
1. **逆向思维训练**：动态删除问题往往可通过逆序处理转化为合并问题。  
2. **邻接表优化**：遍历邻接表而非全图，时间复杂度从 `O(mk)` 降为 `O(m)`。  
3. **并查集路径压缩**：必须使用路径压缩和按秩合并，否则超时。

---
处理用时：77.85秒
# 题目信息

# 括号序列

## 题目描述

定义如下规则：

1. 空串是「平衡括号序列」
2. 若字符串 $S$ 是「平衡括号序列」，那么 $\texttt{[}S\texttt]$ 和 $\texttt{(}S\texttt)$ 也都是「平衡括号序列」
3. 若字符串 $A$ 和 $B$ 都是「平衡括号序列」，那么 $AB$（两字符串拼接起来）也是「平衡括号序列」。


例如，下面的字符串都是平衡括号序列：


- `()`，`[]`，`(())`，`([])`，`()[]`，`()[()]`


而以下几个则不是：


- `(`，`[`，`]`，`)(`，`())`，`([()`


现在，给定一个仅由 `(`，`)`，`[`，`]`构成的字符串 $s$，请你按照如下的方式给字符串中每个字符配对：
1. 从左到右扫描整个字符串。
2. 对于当前的字符，如果它是一个右括号，考察它与它左侧离它**最近**的**未匹配**的的左括号。如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。

配对结束后，对于 $s$ 中全部未配对的括号，请你在其旁边添加一个字符，使得该括号和新加的括号匹配。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $s$ 的长度不超过 $100$，且只含  `(`，`)`，`[`，`]` 四种字符。

## 样例 #1

### 输入

```
([()
```

### 输出

```
()[]()
```

## 样例 #2

### 输入

```
([)```

### 输出

```
()[]()```

# AI分析结果



## 算法分类
**栈的应用**

---

## 题解思路与核心难点

### 核心逻辑
题目要求按特定规则匹配括号后补全未配对的括号。关键在于：
1. **栈维护未匹配的左括号**：记录左括号的位置及类型。
2. **动态标记补全情况**：用辅助数组记录每个位置是否需要补全及补全类型。
3. **顺序输出补全结果**：根据原字符顺序和补全标记生成最终字符串。

### 解决难点
- **正确匹配规则**：右括号必须与最近左括号匹配，且类型一致。
- **补全逻辑**：左括号右侧补全右括号，右括号左侧补全左括号。
- **时间复杂度优化**：避免暴力遍历，利用栈的先进后出特性实现高效匹配。

---

## 题解评分（≥4星）

### MY的题解（5星）
- **亮点**：栈+辅助数组实现高效标记，代码简洁清晰。
- **关键点**：用`c`数组动态记录补全方向，栈存储左括号位置。

### YuJieSong的题解（4星）
- **亮点**：直观暴力匹配，适合理解题意，但时间复杂度较高。
- **关键点**：标记数组记录匹配状态，补全时直接输出成对括号。

### anyway的题解（5星）
- **亮点**：栈与补全标记巧妙结合，代码极简且高效。
- **关键点**：`b`数组记录补全方向，输出时按顺序处理。

---

## 最优思路提炼

### 核心代码实现
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    string s;
    cin >> s;
    stack<int> st;
    char c[110] = {0}; // 记录补全类型

    for (int i = 0; i < s.size(); i++) {
        if (s[i] == '(' || s[i] == '[') {
            st.push(i);
            c[i] = (s[i] == '(') ? ')' : ']';
        } else {
            if (!st.empty() && ((s[i] == ')' && s[st.top()] == '(') || 
                               (s[i] == ']' && s[st.top()] == '['))) {
                c[st.top()] = ' '; // 清除补全标记
                st.pop();
            } else {
                c[i] = (s[i] == ')') ? '(' : '[';
            }
        }
    }

    for (int i = 0; i < s.size(); i++) {
        if (c[i] == '(' || c[i] == '[') cout << c[i];
        cout << s[i];
        if (c[i] == ')' || c[i] == ']') cout << c[i];
    }
}
```

### 关键技巧
- **栈存储位置**：用栈跟踪未匹配的左括号下标，便于回溯标记。
- **补全标记数组**：`c[i]`记录每个位置需补全的括号类型，空字符表示已匹配。
- **输出逻辑**：顺序遍历原字符串，根据`c`数组动态插入补全括号。

---

## 类似题目推荐
1. **LeetCode 20. 有效的括号**：基础括号匹配问题。
2. **LeetCode 32. 最长有效括号**：进阶动态规划或栈应用。
3. **洛谷 P1739. 表达式括号匹配**：简化版括号匹配问题。

---

## 可视化设计

### 动画方案
- **栈操作可视化**：用动态栈图示展示左括号的入栈/出栈过程。
- **高亮当前字符**：红色框标记当前处理的字符，蓝色框表示栈顶元素。
- **补全标记显示**：绿色表示补全左括号，黄色表示补全右括号。

### 复古像素风格
- **8位色彩**：用`#FF0000`（红）、`#0000FF`（蓝）、`#00FF00`（绿）等经典FC色。
- **Canvas绘制**：网格化字符位置，用像素块表示括号和补全标记。
- **音效设计**：入栈时播放“哔”声，匹配成功时播放“叮”，补全时播放“咔”。

### 交互功能
- **步进控制**：空格键单步执行，方向键调整速度。
- **自动演示**：AI模式自动完成匹配，展示最优路径。
- **错误提示**：不匹配时屏幕抖动并播放低沉音效。

---

## 总结
通过栈结构高效匹配括号，辅以动态标记数组处理补全逻辑，是解决此类问题的通用方法。结合可视化工具可深入理解栈的动态变化与补全机制。

---
处理用时：70.57秒
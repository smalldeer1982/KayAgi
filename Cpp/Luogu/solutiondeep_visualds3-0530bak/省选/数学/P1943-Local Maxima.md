# 题目信息

# Local Maxima

## 题目描述

给出一个排列。如果其中一个数比它前面的数都大，则称为**局部最大值**（Local Maxima）。

现在问在一个长度为 $n$ 的随机生成的排列中，期望有多少个数为局部最大值。

## 说明/提示

长度为 $2$ 的排列共 $2$ 种，为 $(1,2)$ 和 $(2,1)$。前者两个数都为局部最大值，后者仅有第一个数 $2$ 为局部最大值。


### 数据范围及约定 

- 对于 $30\%$ 的数据，$n \leq 10$；
- 对于 $80\%$ 的数据，$n \leq 10^6$；
- 对于 $100\%$ 的数据，$1\leq n < 2^{31}$。


## 样例 #1

### 输入

```
2```

### 输出

```
1.50000000```

# AI分析结果



## 算法分类
**组合数学**

---

## 题解思路与难点分析

### 核心数学推导
所有题解均通过不同角度证明：**局部最大值期望等于调和级数 Hₙ = 1 + 1/2 + ... + 1/n**。关键思路有二：
1. **递推法**：每次插入新元素时，仅当插入当前最大值时才会新增贡献，推导得递推式 f(n) = f(n-1) + 1/n。
2. **线性期望拆分**：每个位置 i 成为局部最大值的概率为 1/i，总和即调和级数。

### 解决难点
1. **调和级数计算优化**：
   - **分段打表**：预先存储每段 L 长度的累加结果，查询时从最近分段点开始计算剩余项（如 Natsuzora 的 L=2²⁶）。
   - **近似公式**：利用 Hₙ ≈ ln(n) + γ（欧拉常数 γ≈0.5772）快速计算大 n 时的结果。

### 可视化设计思路
1. **递推过程动画**：
   - 初始状态显示 n=1 的排列，高亮第一个元素。
   - 每次插入新元素时：
     - 若插入当前最大值，颜色标记该元素，并显示 "+1/n" 的公式。
     - 否则保持原颜色，显示 "+0"。
   - 动态累加显示当前 Hₙ 的值。
2. **像素风格可视化**：
   - 使用 Canvas 绘制条形图，每个条形高度代表 1/i，颜色渐变表示累加过程。
   - 音效：每次累加时播放 8-bit 音效，完成时播放胜利音效。

---

## 题解评分（≥4星）

### 1. Natsuzora（5星）
- **亮点**：严谨的递推证明，分段打表实现高效计算。
- **代码**：预处理分段值，查询时仅需 O(L) 时间。
- **可视化适配**：递推动画可清晰展示插入逻辑。

### 2. Nepenthe（4.5星）
- **亮点**：直观的概率拆分，代码简洁。
- **近似公式**：合理选择阈值平衡精度与效率。
- **可视化适配**：概率计算过程适合分步高亮。

### 3. 白鲟（4星）
- **亮点**：详细数学证明，分段处理逻辑清晰。
- **代码**：直接累加与近似公式结合，可读性强。

---

## 最优思路提炼
**递推法 + 分段打表**
1. **递推思想**：每次插入新元素时，仅最大值新增贡献。
2. **调和级数优化**：分段存储累加值，减少大 n 时的计算量。

---

## 类似题目
1. **P2181 对角线**（组合数公式推导）
2. **P3197 越狱**（容斥原理与快速幂）
3. **P1495 曹冲养猪**（中国剩余定理）

---

## 代码核心实现
```cpp
// 分段打表法核心代码（Natsuzora 题解）
#include <cstdio>
using namespace std;
const int L = 1 << 26; // 分段间隔
const long long data[] = { /* 预计算的分段值 */ };

int main() {
    int n;
    scanf("%d", &n);
    double ans = list[n / L]; // 获取最近分段点
    for (int i = n / L * L + 1; i <= n; i++)
        ans += 1.0 / i;
    printf("%.8f", ans);
    return 0;
}
```

---

## 可视化实现（伪代码）
```javascript
// 8-bit 风格递推动画
const ctx = canvas.getContext('2d');
let currentN = 1;
let harmonic = 1;

function drawStep() {
    ctx.fillStyle = '#8B00FF'; // 紫色背景
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    // 绘制当前累加项
    ctx.fillStyle = '#FFFF00';
    ctx.fillRect(currentN * 10, 100 - (1/currentN * 100), 8, 8);
    // 播放音效
    beep(500 + currentN * 10, 0.1);
    currentN++;
    harmonic += 1/currentN;
}
```

---

## 个人心得
- **调试关键**：验证小 n 时的结果与调和级数是否一致。
- **优化启示**：数学推导优于暴力枚举，合理利用近似公式大幅提升效率。

---
处理用时：128.60秒
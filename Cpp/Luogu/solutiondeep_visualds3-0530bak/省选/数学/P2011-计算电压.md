# 题目信息

# 计算电压

## 题目背景

相信不少人轻松灭掉 1，2 两题（蒟蒻无视此句） ，我相信，大家对物理也是很有兴趣的（众人：我们对揍人也是很有兴趣的） ，那么，再奉上 100 分给 Physicaler 们。

## 题目描述

现给定一个电阻网络，已知其中每条边上的电阻，和若干个点和负极之间的电压（电源电压不变） ，现在求任意两点之间的电压。

## 说明/提示

【数据范围】

对于 $10\%$ 的数据，$1\le q\le 10$；

对于 $20\%$ 的数据，$1\le n\le 10$，且保证电路为串联、并联或混联；

对于 $40\%$ 的数据，$1\le n\le 40$，$k\le 5$；

对于 $100\%$ 的数据，$1\le k\le n\le 200$，$1\le m\le 2\times 10^5$，$1\le r_i,u_i\le 10^4$，$1\le q\le 10^6$。

【时空限制】

时间限制：1.00s，空间限制：125.00MB。

【样例解释】

如图所示。

![样例解释](https://cdn.luogu.com.cn/upload/pic/722.png)

## 样例 #1

### 输入

```
3 5 1 3

1 18

1 2 6

1 3 2

2 3 6

3 0 6

2 0 2

1 0

2 3

1 2

```

### 输出

```
18.00

-6.00

12.00

```

# AI分析结果



---

**唯一算法分类**：无算法分类

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
- **基尔霍夫定律（KCL）**：每个节点的电流流入等于流出，结合欧姆定律（$I = U/R$）转化为电势差方程。
- **方程建模**：设每个节点的电势为变量，对普通节点建立线性方程（导纳总和为负，相邻节点导纳为系数），对已知电压的节点直接赋值。
- **高斯消元**：解线性方程组得到所有节点的电势，查询时直接输出两点电势差。

#### **关键公式推导**
1. **普通节点方程**：
   \[
   \sum_{j \in \text{邻接节点}} \frac{\varphi_j - \varphi_i}{R_{ij}} = 0 \implies \sum_{j} \frac{\varphi_j}{R_{ij}} - \varphi_i \sum_{j} \frac{1}{R_{ij}} = 0
   \]
   其中系数矩阵中，节点 $i$ 的系数为 $- \sum \frac{1}{R_{ij}}$，邻接节点 $j$ 的系数为 $\frac{1}{R_{ij}}$。

2. **已知电压节点方程**：
   \[
   \varphi_i = U_i \quad (\text{直接赋值})
   \]

#### **实现难点与优化**
- **并联电阻处理**：多个电阻并联时，导纳（$1/R$）直接相加，避免重复计算。
- **输出优化**：预处理所有可能的电压差（$200 \times 200$），转为字符串缓存，应对 $10^6$ 次查询。
- **稀疏矩阵处理**：利用邻接表存储电阻网络，避免存储全连接矩阵。

---

### **题解评分 (≥4星)**

| 题解作者       | 评分 | 亮点与不足 |
|----------------|------|------------|
| **C_SUNSHINE** | ★★★★☆ | 思路清晰，提及输出优化，但未提供代码 |
| **P_E_K_K_A**  | ★★★★☆ | 详细代码注释，公式推导完整，代码可读性强 |
| **Zq_water**   | ★★★★☆ | 代码简洁高效，包含高斯消元实现 |

---

### **最优思路或技巧提炼**

1. **导纳模型**：将电阻转为导纳（$1/R$）简化并联计算。
2. **方程分治**：已知电压节点单独赋值，普通节点动态生成方程。
3. **预处理缓存**：将 $O(n^2)$ 种查询结果提前计算，优化高频查询。

---

### **同类型题或类似算法套路**

- **线性方程组建模**：适用于电路分析、力学平衡、热传导等问题。
- **高斯消元法**：通用解法，需注意矩阵稠密性与数值稳定性。

---

### **推荐相似题目**

1. **P3389**：高斯消元模板题。
2. **P4035**：球形空间产生器（高维高斯消元）。
3. **P2447**：外星千足虫（异或方程组）。

---

### **个人心得摘录**

- **C_SUNSHINE**：强调预处理的重要性，避免输出浮点数的性能瓶颈。
- **P_E_K_K_A**：通过合并电流方向方程简化推导，“无需判断方向”是核心突破点。

---

### **可视化与算法演示**

#### **核心数学过程**
1. **节点建模动画**：
   - **步骤1**：高亮当前节点，显示其邻接电阻和导纳。
   - **步骤2**：动态填充系数矩阵，红色标记已知电压节点。
2. **高斯消元动画**：
   - **消元步骤**：逐步显示主行选择、归一化、消去过程。
   - **回代步骤**：绿色标记已求解变量，黄色标记当前计算变量。

#### **复古像素化实现**
- **Canvas 绘制**：
  - 电路节点为像素方块，电阻为连线（颜色随阻值变化）。
  - 矩阵元素以 8x8 像素块表示，数值用颜色梯度编码。
- **音效设计**：
  - 方程建立完成：8-bit “滴”声。
  - 高斯消元成功：短促上升音阶。
  - 查询命中缓存：复古硬币音效。

#### **交互设计**
- **自动演示模式**：模拟“AI 解题”，自动播放建模与消元过程。
- **手动步进**：允许用户点击矩阵元素查看详细数值。

---

### **代码片段（高斯消元核心）**

```cpp
void gauss(int n) {
    for (int i = 1; i <= n; i++) {
        int pivot = i;
        for (int j = i + 1; j <= n; j++)
            if (fabs(matrix[j][i]) > fabs(matrix[pivot][i])) pivot = j;
        swap(matrix[i], matrix[pivot]);
        double div = matrix[i][i];
        for (int j = i; j <= n + 1; j++) matrix[i][j] /= div;
        for (int j = i + 1; j <= n; j++) {
            double factor = matrix[j][i];
            for (int k = i; k <= n + 1; k++)
                matrix[j][k] -= factor * matrix[i][k];
        }
    }
    for (int i = n; i >= 1; i--) {
        voltage[i] = matrix[i][n + 1];
        for (int j = i + 1; j <= n; j++)
            voltage[i] -= matrix[i][j] * voltage[j];
    }
}
```

---

**总结**：本题通过基尔霍夫定律建模为线性方程组，高斯消元求解电势，最终以差值响应查询。核心在于导纳模型的构建与高效解方程，结合预处理优化高频查询。

---
处理用时：74.08秒
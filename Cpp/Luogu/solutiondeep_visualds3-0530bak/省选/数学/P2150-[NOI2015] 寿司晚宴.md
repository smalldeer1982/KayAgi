# 题目信息

# [NOI2015] 寿司晚宴

## 题目描述

为了庆祝 NOI 的成功开幕，主办方为大家准备了一场寿司晚宴。小 G 和小 W 作为参加 NOI 的选手，也被邀请参加了寿司晚宴。

在晚宴上，主办方为大家提供了 $n−1$ 种不同的寿司，编号 $1,2,3,\ldots,n-1$，其中第 $i$ 种寿司的美味度为 $i+1$。（即寿司的美味度为从 $2$ 到 $n$）

现在小 G 和小 W 希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小 G 品尝的寿司种类中存在一种美味度为 $x$ 的寿司，小 W 品尝的寿司中存在一种美味度为 $y$ 的寿司，而 $x$ 与 $y$ 不互质。

现在小 G 和小 W 希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数 $p$ 取模）。注意一个人可以不吃任何寿司。


## 说明/提示

【数据范围】


 ![](https://cdn.luogu.com.cn/upload/pic/1506.png) 


**勘误：$0 < p \le 10^9 $**

## 样例 #1

### 输入

```
3 10000```

### 输出

```
9```

## 样例 #2

### 输入

```
4 10000```

### 输出

```
21```

## 样例 #3

### 输入

```
100 100000000```

### 输出

```
3107203```

# AI分析结果



### 算法分类：数论

---

### 题解思路与核心难点

#### 数学建模与关键推导
1. **质因数分类**：将质数分为小质数（≤22）和大质数。小质数共8个，可用状压处理（2^8=256种状态）。
2. **分组策略**：将含有相同大质数的数分为一组，每组只能全选给一人或不选。
3. **状态转移方程**：
   - 设 `dp[s1][s2]` 表示小G选质数集合s1，小W选s2的方案数
   - 对每组大质数，使用 `f1`（只能选给G）和 `f2`（只能选给W）进行状态转移：
     ```math
     f1' = f1 + 新增合法方案（不冲突）
     f2' = f2 + 新增合法方案（不冲突）
     ```
   - 合并时：`dp = f1 + f2 - dp`（减去重复的空选情况）

#### 难点突破
- **大质数处理**：通过排序将同组大质数连续排列，确保同组决策原子性
- **状压优化**：仅用8位二进制表示小质数状态，将复杂度降至O(n*3^8)

---

### 题解评分（≥4★）

| 题解作者      | 评分 | 核心亮点                                                                 |
|---------------|------|--------------------------------------------------------------------------|
| Orion545      | ★★★★ | 首个完整思路，清晰的分组策略和状态转移设计                              |
| ethan_zhou    | ★★★★ | 提出O(n*3^8)优化，数学推导严谨，代码精简                                 |
| C20203030     | ★★★★ | 代码可读性极佳，关键步骤注释详细，适合快速理解算法流程                   |

---

### 最优思路提炼
1. **质因数分类法**：将质数分为小/大两类，分别处理
2. **分组动态规划**：按大质数分组决策，保证每组原子性选择
3. **滚动状态优化**：通过 `f1/f2` 临时数组避免重复计算，空间复杂度O(2^16)

---

### 同类型题拓展
**通用套路**：
1. 质因数分解预处理
2. 小范围质数状压
3. 大质数分组决策
4. 动态规划状态压缩

**推荐题目**：
1. P2704 [NOI2001]炮兵阵地（状压DP）
2. P1970 质数取石子（质数博弈）
3. P3223 [HNOI2012]排队（组合数学+质因数分解）

---

### 核心代码实现
```cpp
int prime[8] = {2,3,5,7,11,13,17,19};
struct Node { int val, big, S; }; // S: 小质数状压

// 预处理质因数
void init(int x) {
    int tmp = x;
    for(int j=0; j<8; ++j)
        if(tmp % prime[j] == 0) {
            S |= (1 << j);
            while(tmp % prime[j] == 0) tmp /= prime[j];
        }
    big = (tmp > 1) ? tmp : -1;
}

// 状态转移核心
for(int i=2; i<=n; ++i) {
    if(大质数变化) { // 新组开始
        memcpy(f1, dp, sizeof(dp));
        memcpy(f2, dp, sizeof(dp));
    }
    // 更新f1/f2...
    if(当前组结束) {
        for(int s1=0; s1<256; ++s1)
            for(int s2=0; s2<256; ++s2)
                dp[s1][s2] = (f1[s1][s2] + f2[s1][s2] - dp[s1][s2] + MOD) % MOD;
    }
}
```

---

### 可视化设计
**像素化状态转移演示**：
1. **Canvas网格**：256x256网格表示状态，每个像素代表(s1,s2)状态
2. **颜色编码**：
   - 绿色：合法状态
   - 红色：冲突状态
   - 黄色：当前更新状态
3. **动画流程**：
   - 步进显示每组大质数的处理过程
   - 高亮显示f1/f2的更新区域
   - 合并时显示减法操作的闪烁特效

**音效设计**：
- 选择寿司：8位风格"滴"声
- 状态冲突："哔"声警告
- 组处理完成：上升音阶

---

### 学习启示
1. **质因数分解**是处理互质问题的核心工具
2. **分组决策**可有效降低NP问题的复杂度
3. **状态压缩**与**滚动数组**是处理数论+DP的黄金组合

---
处理用时：69.87秒
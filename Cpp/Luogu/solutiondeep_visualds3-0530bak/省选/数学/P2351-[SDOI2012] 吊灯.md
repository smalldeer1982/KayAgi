# 题目信息

# [SDOI2012] 吊灯

## 题目背景

山东省省队选拔赛第二试（第一天）


## 题目描述

Alice 家里有一盏很大的吊灯。所谓吊灯，就是由很多个灯泡组成。只有一个灯泡是挂在天花板上的，剩下的灯泡都是挂在其他的灯泡上的。也就是说，整个吊灯实际上类似于**一棵树**。其中编号为 $1$ 的灯泡是挂在天花板上的，剩下的灯泡都是挂在编号小于自己的灯泡上的。

现在，Alice 想要办一场派对，她想改造一下这盏吊灯，将灯泡换成不同的颜色。她希望相同颜色的灯泡都是相连的，并且每一种颜色的灯泡个数都是相同的。

Alice 希望你能告诉她，总共有哪些方案。

Alice 是一个贪心的孩子，如果她发现方案不够多，或者太多了，就会很不高兴，于是她会尝试调整。对于编号为 $x$（$x\neq 1$）的灯泡，如果原来是挂在编号为 $f_x$ 的灯泡上，那么 Alice 会把第 $x$ 个灯泡挂到第 $(f_x + 19940105)\bmod (x-1) + 1$ 个灯泡上。

由于九在古汉语中表示极大的数，于是，Alice 决定只调整 $9$ 次。对于原始状态和每一次调整过的状态，Alice 希望你依次告诉她每种状态下有哪些方案。


## 说明/提示

对于 $20\%$ 的数据，$n\leq 3\times 10^3$。

对于 $40\%$ 的数据，$n\leq 5\times 10^4$。

对于 $50\%$ 的数据，$n\leq 10^5$。

对于 $60\%$ 的数据，$n\leq 3\times 10^5$。

对于 $70\%$ 的数据，$n\leq 7\times 10^5$。

对于 $100\%$ 的数据，$1\leq n\leq 1.2\times 10^6$。


## 样例 #1

### 输入

```
6
1,2,3,4,5```

### 输出

```
Case #1:
1
2
3
6
Case #2:
1
2
6
Case #3:
1
3
6
Case #4:
1
3
6
Case #5:
1
3
6
Case #6:
1
2
6
Case #7:
1
2
3
6
Case #8:
1
6
Case #9:
1
2
6
Case #10:
1
3
6```

# AI分析结果



# 数论

## 题解思路、算法要点与解决难点

### 核心数学思路
**关键结论**：当且仅当存在恰好 $\frac{n}{k}$ 个节点的子树大小是 $k$ 的倍数时，$k$ 是合法解，且 $k$ 必须是 $n$ 的因数。  
**推导思路**：  
1. 每个颜色块必须是连通子树。  
2. 若颜色块大小为 $k$，则每个块对应一个子树大小为 $k$ 的节点。  
3. 统计所有子树大小为 $k$ 的倍数的节点数量，需满足总节点数 $\geq \frac{n}{k}$。  

### 算法步骤
1. **预处理子树大小**：倒序遍历节点，累加子树大小至父节点。  
2. **统计子树大小分布**：记录每个子树大小的出现次数。  
3. **枚举因数 $k$**：对每个 $k$ 检查是否存在足够多的子树大小倍数。  

### 解决难点
- **高效计算子树大小**：利用树的结构（子节点编号 > 父节点）实现 $O(n)$ 计算。  
- **快速统计倍数条件**：直接累加或使用狄利克雷后缀和优化。  

---

## 题解评分 (≥4星)

### wzj423 (★★★★★)
- **亮点**：代码简洁，直接倒序计算子树大小，统计倍数条件。  
- **核心代码**：  
  ```cpp
  for (int i = N; i > 1; --i) sz[fa[i]] += sz[i];
  for (int j = 1; i*j <= N; ++j) t += num[i*j];
  ```

### Hehe_0 (★★★★☆)
- **亮点**：模块化设计，函数分离提高可读性。  
- **心得**：通过 `init()` 函数分离子树计算逻辑。  

### Cx114514 (★★★★★)
- **亮点**：使用狄利克雷后缀和优化统计，时间复杂度更优。  
- **关键优化**：  
  ```cpp
  for (int j = 1; j <= tot; j++)
    for (int k = n/p[j]; k >= 1; k--)
      cnt[k] += cnt[k * p[j]];
  ```

---

## 最优思路或技巧提炼

### 关键公式与实现
1. **子树大小计算**：  
   ```cpp
   for (int i = n; i >= 1; i--) sz[fa[i]] += sz[i];
   ```  
   时间复杂度 $O(n)$，利用子节点编号大于父节点的性质。  

2. **倍数条件检查**：  
   ```cpp
   int t = 0;
   for (int j = k; j <= n; j += k) t += cnt[j];
   if (t >= n / k)  // 合法解
   ```  

---

## 同类型题或类似算法套路

1. **因数分解**：预处理 $n$ 的所有因数。  
2. **子树统计**：倒序遍历树结构统计子树大小。  
3. **狄利克雷后缀和**：快速统计倍数出现次数。  

---

## 推荐题目
1. P5535 【XR-3】小道消息（因数性质）  
2. P2300 合并神犇（树结构统计）  
3. P1128 求正整数（因数分解应用）  

---

## 可视化与算法演示

### 动画方案设计
1. **树结构绘制**：以像素风格绘制树，子节点在父节点下方。  
2. **子树大小计算**：  
   - 高亮当前节点，显示其子树大小。  
   - 逐步向上累加至父节点（红色闪烁父节点）。  
3. **统计倍数条件**：  
   - 左侧面板显示 `num[]` 数组，高亮 $k$ 的倍数。  
   - 播放音效（如“滴”）表示统计完成。  

### 复古游戏化设计
- **8位像素风格**：  
  - 节点用 8x8 像素方块表示，颜色区分子树大小。  
  - 背景音乐：8-bit 循环音轨。  
- **自动演示模式**：  
  - 按步执行：子树计算 → 统计 → 检查每个 $k$。  
  - 完成时播放胜利音效。  

---

## 代码片段（核心逻辑）

### 子树计算与统计
```cpp
// 计算子树大小
for (int i = n; i >= 1; i--) 
    sz[fa[i]] += sz[i];
// 统计子树大小出现次数
for (int i = 1; i <= n; i++) 
    cnt[sz[i]]++;
// 检查每个因数 k
vector<int> ans;
for (int k : factors_of_n) {
    int total = 0;
    for (int j = k; j <= n; j += k)
        total += cnt[j];
    if (total >= n / k)
        ans.push_back(k);
}
```

---

## 个人心得
- **调试教训**：确保父节点编号始终小于子节点，避免正向遍历。  
- **优化顿悟**：狄利克雷后缀和可将统计复杂度从 $O(n \log n)$ 降至 $O(n \log \log n)$。

---
处理用时：74.28秒
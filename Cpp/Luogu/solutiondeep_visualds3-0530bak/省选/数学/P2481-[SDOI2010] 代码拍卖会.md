# 题目信息

# [SDOI2010] 代码拍卖会

## 题目描述

随着 iPig 在 P++ 语言上的造诣日益提升，他形成了自己一套完整的代码库。猪王国想参加 POI 的童鞋们都争先恐后问 iPig 索要代码库。iPig 不想把代码库给所有想要的小猪，只想给其中的一部分既关系好又肯出钱的小猪，于是他决定举行了一个超大型拍卖会。

在拍卖会上，所有的 $N$ 头小猪将会按照和 iPig 的好感度从低到高，从左到右地在 iPig 面前站成一排。每个小猪身上都有 $9$ 猪币（与人民币汇率不明），从最左边开始，每个小猪依次举起一块牌子，上面写上想付出的买代码库的猪币数量（$1$ 到 $9$ 之间的一个整数）。大家都知道，如果自己付的钱比左边的猪少，肯定得不到梦寐以求的代码库，因此从第二只起，每只猪出的钱都大于等于左边猪出的价钱。最终出的钱最多的小猪（们）会得到 iPig 的代码库真传，向着保送 PKU（Pig Kingdom University）的梦想前进。

iPig 对自己想到的这个点子感到十分满意，在去现场的路上，iPig 就在想象拍卖会上会出现的场景，例如一共会出现多少种出价情况之类的问题，但这些问题都太简单了，iPig 早已不感兴趣了，他想要去研究更加困难的问题。iPig 发现如果他从台上往下看，所有小猪举的牌子从左到右将会正好构成一个 $N$ 位的整数，他现在想要挑战的问题是所有可能构成的整数中能正好被 $P$ 整除的有多少个。由于答案过大，他只想要知道答案 $\bmod\ 999911659$ 就行了。

## 说明/提示

### 样例解释

方案可以是：$12,\allowbreak 15,\allowbreak 18,\allowbreak 24,\allowbreak 27,\allowbreak 33,\allowbreak 36,\allowbreak 39,\allowbreak 45,\allowbreak 48,\allowbreak 57,\allowbreak 66,\allowbreak 69,\allowbreak 78,\allowbreak 99$，共 $15$ 种。

### 数据规模

![](https://cdn.luogu.com.cn/upload/image_hosting/y0nme218.png)


## 样例 #1

### 输入

```
2 3```

### 输出

```
15```

# AI分析结果



# 数论与组合数学的综合应用

## 核心思路与数学分析

### 关键数学转化
将n位不降数拆解为**最多9个全1后缀之和**：
```math
A = \underbrace{111\cdots1}_n + \sum_{k=1}^8 \underbrace{111\cdots1}_{x_k} \quad (x_k \leq n)
```
每个全1后缀的模p余数形成循环节，通过递推式：
```math
f_i = (10 \cdot f_{i-1} + 1) \mod p
```
在O(p)时间内找到循环节，统计每个余数出现次数g[i]

### 组合数学建模
定义DP状态：
```math
dp[pos][cnt][rem] = \text{前pos类余数，选cnt个，余数和为rem的方案数}
```
转移方程：
```math
dp[pos+1][k+t][(rem + t \cdot val) \mod p] += dp[pos][k][rem] \times \binom{g[pos]+t-1}{t}
```
其中组合数使用隔板法计算可重复选取的方案数

### 算法复杂度
预处理循环节O(p)，DP转移O(9²p²)，总时间复杂度O(p + 81p²)

## 题解对比与评分

### 五星题解推荐
1. **Imakf（67赞）**
   - ✅ 循环节处理清晰，使用滚动数组优化空间
   - ✅ 强制选取n位全1后缀的初始化技巧
   - ✅ 组合数计算采用预计算逆元优化
   ```cpp
   // 逆元预处理
   inv[1] = 1;
   for(int i=2; i<=8; ++i) 
       inv[i] = (mod - mod/i) * inv[mod%i] % mod;
   ```

2. **灯芯糕（27赞）**
   - ✅ 状态转移公式推导详细
   - ✅ 组合数动态计算示例清晰
   - ✅ 调试心得对理解边界条件有帮助
   ```cpp
   // 组合数计算技巧
   for(int j=1; j<=8; ++j)
       c[i][j] = 1ll * c[i][j-1] * (g[i] + j - 1) % mod * inv[j] % mod;
   ```

3. **MCAdam（12赞）**
   - ✅ 循环节处理代码简洁
   - ✅ 状态转移使用三维数组更直观
   - ✅ 包含完整错误处理案例
   ```cpp
   // 循环节检测
   if(vis[now]) {
       len = i - vis[now];
       break;
   }
   ```

## 关键代码实现

### 循环节处理
```cpp
int now = 1 % p, cycle_start = -1;
vector<int> f = {now};
unordered_map<int, int> pos;
pos[now] = 0;

for(int i=1; ;++i) {
    now = (now * 10 + 1) % p;
    if(pos.count(now)) {
        cycle_start = pos[now];
        break;
    }
    pos[now] = i;
    f.push_back(now);
}
```

### 动态规划核心
```cpp
// 初始化：必须选n位全1
int base_rem = f.back(); 
dp[0][0][base_rem] = 1;

for(int r=0; r<p; ++r) { // 枚举余数类
    for(int cnt=0; cnt<=8; ++cnt) {
        for(int rem=0; rem<p; ++rem) {
            for(int add=0; cnt+add<=8; ++add) {
                int new_rem = (rem + add*r) % p;
                dp[r+1][cnt+add][new_rem] += 
                    dp[r][cnt][rem] * comb(g[r], add);
            }
        }
    }
}
```

## 可视化设计

### 像素化循环节演示
```html
<canvas id="cycleView" width="640" height="480"></canvas>
<script>
// 绘制余数循环过程
function drawCycle(ctx, f, cycleStart) {
    const colors = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4"];
    f.forEach((val, idx) => {
        ctx.fillStyle = idx >= cycleStart ? colors[1] : colors[0];
        ctx.fillRect(idx*40 % 600, Math.floor(idx/15)*40, 35, 35);
        ctx.fillText(`f[${idx}]=${val}`, idx*40 % 600 +5, Math.floor(idx/15)*40 +20);
    });
}
</script>
```

### 动态规划状态转移动画
1. **网格绘制**：每个格子表示dp[r][cnt][rem]
2. **颜色编码**：
   - 红色：当前处理余数类
   - 绿色：已更新状态
   - 蓝色：待更新状态
3. **音效反馈**：状态更新时播放8bit音效

## 同类题目推荐
1. **P2606 排列计数** - 组合数模运算
2. **P3197 越狱** - 快速幂与模运算
3. **P1495 曹冲养猪** - 中国剩余定理

## 思维拓展
此类问题的通用解法框架：
1. **问题转化**：将复杂结构拆解为可数基本单元
2. **模运算处理**：寻找循环节或周期性规律
3. **组合计数**：动态规划或生成函数建模
4. **优化计算**：预计算逆元、滚动数组等技巧

通过本案例的循环节处理与模运算背包模型，可迁移解决各类大数位计数问题。例如电话号码组合问题、特定模式字符串计数等场景均可借鉴此思路。

---
处理用时：68.50秒
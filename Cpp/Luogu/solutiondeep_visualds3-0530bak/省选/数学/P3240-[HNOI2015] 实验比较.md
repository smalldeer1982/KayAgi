# 题目信息

# [HNOI2015] 实验比较

## 题目描述

小 D 被邀请到实验室，做一个跟图片质量评价相关的主观实验。

实验用到的图片集一共有 $N$ 张图片，编号为 $1$ 到 $N$。实验分若干轮进行，在每轮实验中，小 D 会被要求观看某两张随机选取的图片， 然后小 D 需要根据他自己主观上的判断确定这两张图片谁好谁坏，或者这两张图片质量差不多。 

用符号 ”$<$”、“$>$” 和 “$=$” 表示图片 $x$ 和 $y$（$x$、$y$ 为图片编号）之间的比较：如果上下文中 $x$ 和 $y$ 是图片编号，则 $x<y$ 表示图片 $x$「质量优于」$y$，$x>y$ 表示图片 $x$「质量差于」$y$，$x=y$ 表示图片 $x$ 和 $y$ 「质量相同」；也就是说，这种上下文中，“$<$”、“$>$”、“$=$” 分别是质量优于、质量差于、质量相同的意思；在其他上下文中，这三个符号分别是小于、大于、等于的含义。

图片质量比较的推理规则（在 $x$ 和 $y$ 是图片编号的上下文中）：
1. $x < y$ 等价于 $y > x$。
2. 若 $x < y$ 且 $y = z$，则 $x < z$。
3. 若 $x < y$ 且 $x = z$，则 $z < y$。
4. $x=y$ 等价于 $y=x$。
5. 若 $x=y$ 且 $y=z$，则 $x=z$。 

实验中，小 D 需要对一些图片对 $(x, y)$，给出 $x < y$ 或 $x = y$ 或 $x > y$ 的主观判断。小 D 在做完实验后， 忽然对这个基于局部比较的实验的一些全局性质产生了兴趣。

在主观实验数据给定的情形下，定义这 $N$ 张图片的一个合法质量序列为形如 “$x_1 R_1 x_2 R_2 x_3 R_3 …x_{N-1} R_{N-1} x_N$” 的串，也可看作是集合 $\{ x_i R_i x_{i+1}|1 \leq i \leq N-1 \}$，其中  $x_i$ 为图片编号，$x_1,x_2, \ldots ,x_N$ 两两互不相同（即不存在重复编号），$R_i$ 为 $<$ 或 $=$，「合法」是指这个图片质量序列与任何一对主观实验给出的判断不冲突。 

例如： 质量序列 $3 < 1 = 2$ 与主观判断 “$3 > 1$，$3 = 2$” 冲突（因为质量序列中 $3<1$ 且 $1=2$，从而 $3<2$，这与主观判断中的 $3=2$ 冲突；同时质量序列中的 $3<1$ 与主观判断中的 $3>1$ 冲突） ，但与主观判断 “$2 = 1$，$3 < 2$”  不冲突；因此给定主观判断 “$3>1$，$3=2$” 时，$1<3=2$ 和 $1<2=3$ 都是合法的质量序列，$3<1=2$ 和 $1<2<3$ 都是非法的质量序列。

由于实验已经做完一段时间了，小 D 已经忘了一部分主观实验的数据。对每张图片 $X_i$，小 D 都**最多**只记住了某一张质量不比 $X_i$ 好的另一张图片 $K_{X_i}$。这些小 D 仍然记得的质量判断一共有 $M$ 条（$0 \leq M \leq N$），其中第 $i$ 条涉及的图片对为 $(K_{X_i}, X_i)$，判断要么是 $K_{X_i} < X_i$，要么是 $K_{X_i} = X_i$，而且所有的 $X_i$ 互不相同。小 D 打算就以这 M 条自己还记得的质量判断作为他的所有主观数据。

现在，基于这些主观数据，我们希望你帮小 D 求出这 $N$ 张图片一共有多少个不同的合法质量序列。我们规定：如果质量序列中出现 “$x = y$”，那么序列中交换 $x$ 和 $y$ 的位置后仍是同一个序列。因此： $1<2=3=4<5$ 和 $1<4=2=3<5$ 是同一个序列， $1 < 2 = 3$ 和 $1 < 3 = 2$ 是同一个序列，而 $1 < 2 < 3$ 与 $1 < 2 = 3$ 是不同的序列，$1<2<3$ 和 $2<1<3$ 是不同的序列。

由于合法的图片质量序列可能很多， 所以你需要输出答案对 $10^9 + 7$ 取模的结果。

## 说明/提示

不同的合法序列共5个，如下所示：

- $1 = 5 < 2 < 3 < 4$ 
- $1 = 5 < 2 < 4 < 3$
- $1 = 5 < 2 < 3 = 4$ 
- $1 = 5 < 3 < 2 < 4$ 
- $1 = 5 < 2 = 3 < 4$

$100\%$ 的数据满足 $N \leq 100$。

## 样例 #1

### 输入

```
5 4
1 < 2
1 < 3
2 < 4
1 = 5```

### 输出

```
5```

# AI分析结果



**唯一算法分类**  
组合数学

---

**综合分析与结论**  
本题核心是处理等于和小于关系，利用并查集缩点后构建树结构，通过树形DP结合组合数学计算合法序列数目。关键难点在于动态规划中合并子树段数的组合方式，需推导组合数公式实现状态转移。  
**关键公式推导**：合并两个子树段数时，组合数计算为 $C_{i-1}^{j-1} \times C_{j-1}^{k-i+j}$，其中：  
- $C_{i-1}^{j-1}$：在合并后的$i-1$段中选$j-1$位置放置父节点段。  
- $C_{j-1}^{k-i+j}$：将剩余子节点段插入父节点段的组合方式。  

**可视化设计**：  
1. **像素动画**：用不同颜色区分父段（红色）、子段（蓝色），动态展示段合并过程。  
2. **步进控制**：高亮当前合并步骤，显示组合数公式及计算结果。  
3. **音效提示**：合并成功时播放轻快音效，错误时触发警示音。  

---

**题解清单 (4星及以上)**  
1. **xyz32768（5星）**：思路清晰，代码简洁，组合数推导准确。  
2. **justin_cao（4星）**：详细推导DP状态转移，提供组合数实现思路。  
3. **zzw4257（4星）**：代码高效，树形背包实现巧妙。  

---

**代码核心实现**  
```cpp
// 预处理组合数
void init() {
    for (int i = 0; i <= 120; i++) C[i][0] = 1;
    for (int i = 1; i <= 120; i++)
        for (int j = 1; j <= i; j++)
            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;
}

// 树形DP合并子树
void dfs(int u) {
    sze[u] = f[u][1] = 1;
    for (int v : children[u]) {
        dfs(v);
        for (int i = 1; i <= sze[u] + sze[v]; i++) {
            for (int j = 1; j <= sze[u]; j++) {
                for (int k = 1; k <= sze[v]; k++) {
                    int x = k - (i - j);
                    if (x < 0) continue;
                    f[u][i] += f[u][j] * f[v][k] * C[i-1][j-1] * C[j-1][x];
                }
            }
        }
        sze[u] += sze[v];
    }
}
```

---

**同类型题套路**  
1. **树形DP+组合数学**：常见于需要合并子树状态且涉及排列组合的问题。  
2. **并查集缩点**：处理等价关系后建图。  
3. **组合数预处理**：频繁调用组合数时需预计算。  

**推荐题目**  
1. P4099 [HEOI2013] SAO  
2. P4436 [HNOI/AHOI2018] 游戏  
3. P3959 [NOIP2017 提高组] 宝藏  

---

**可视化与复古游戏化设计**  
- **像素动画**：用Canvas绘制树结构，父节点段用红色方块，子段用蓝色，合并过程动态插值。  
- **音效**：使用Web Audio API，成功合并时播放8-bit音效。  
- **自动演示**：模拟AI解题步骤，逐步显示合并过程，速度可调。  

```javascript
// 示例：Canvas绘制合并步骤
function drawMerge(parentSeg, childSeg, mergedSeg) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 绘制父段（红色）
    parentSeg.forEach((seg, idx) => drawRect(50 + idx*30, 50, 20, 20, 'red'));
    // 绘制子段（蓝色）
    childSeg.forEach((seg, idx) => drawRect(50 + idx*30, 100, 20, 20, 'blue'));
    // 合并动画
    animateMerge(mergedSeg);
}
```

---

**个人心得**  
调试时需注意等于关系的缩点必须彻底，否则会导致建图错误。组合数边界情况（如k-i+j为负）需特判，避免数组越界。树形DP中临时数组的使用是避免状态覆盖的关键。

---
处理用时：107.78秒
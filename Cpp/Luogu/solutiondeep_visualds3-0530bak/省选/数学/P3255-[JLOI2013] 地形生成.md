# 题目信息

# [JLOI2013] 地形生成

## 题目描述

最近IK正在做关于地形建模的工作。其中一个工作阶段就是把一些山排列成一行。每座山都有各不相同的标号和高度。为了遵从一些设计上的要求，每座山都设置了一个关键数字，要求对于每座山，比它高且排列在它前面的其它山的数目必须少于它的关键数字。 显然满足要求的排列会有很多个。

对于每一个可能的排列，IK生成一个对应的标号序列和等高线序列。标号序列就是按顺序写下每座山的标号。

等高线序列就是按顺序写下它们的高度。例如有两座山，这两座山的一个合法排列的第一座山的标号和高度为1和3，而第二座山的标号和高度分别为2和4，那么这个排列的标号序列就是1 2，而等高线序列就是3 4.

现在问题就是，给出所有山的信息，IK希望知道一共有多少种不同的符合条件的标号序列和等高线序列。


## 说明/提示

对于所有的数据，有1<=N<=1000，所有的数字都是不大于109的正整数。


## 样例 #1

### 输入

```
2
1 2
2 2```

### 输出

```
2 2```

# AI分析结果



# **算法分类**
**组合数学**

---

# **题解思路与难点分析**

## **核心数学逻辑**
### **问题拆解**
- **第一问**（标号序列）：将山按高度降序、关键值升序排序，利用乘法原理计算每座山插入位置的方案数
- **第二问**（等高线序列）：按相同策略排序后，对每组同高度山用动态规划计算插入方案

### **关键公式推导**
1. **第一问的插入方案数**：
   ```math
   \text{方案数} = \prod_{i=1}^n \left( \min(a_i, p) + (i-p-1) + 1 \right) = \prod_{i=1}^n \min(a_i + (i-p), i)
   ```
   - `p`：已插入的更高山数量
   - `i-p-1`：已插入的同高度山数量

2. **第二问的DP转移**：
   ```math
   f[i][j] = \sum_{k=1}^{\min(j, a_i)} f[i-1][k]
   ```
   - 前缀和优化后转移方程：
   ```math
   f[i][j] = f[i][j-1] + f[i-1][j]
   ```

### **难点对比**
| 题解差异点          | wanggk题解                     | elijahqi题解                  |
|---------------------|-------------------------------|------------------------------|
| **排序策略**         | 高度降序+关键值升序             | 同左                         |
| **DP状态定义**       | 前i个山插入前j个空位方案数       | 前i个山插入前j个山的方案数     |
| **前缀和优化**       | 显式维护前缀和数组sum[]         | 动态转移时隐式计算前缀和      |
| **空间优化**         | 二维数组+滚动维度               | 二维数组                     |

---

# **最优题解推荐**
## **wanggk题解（★★★★☆）**
**亮点**：
- 显式前缀和优化代码更易理解
- 滚动数组节省空间
- 对同高度山的分组处理逻辑清晰

**关键代码片段**：
```cpp
// 处理同一高度山的DP过程
for(int i=1; i<=n; i++) {
    while(a[p+1].fi>a[i].fi) p++;
    For(j,1,n+1) sum[j] = (sum[j-1]+f[i-1][j])%mod;
    if(p == i-1) { // 新高度组
        ans = ans*sum[n+1]%mod;
        For(j,1,n+1) f[i-1][j] = (j==1), sum[j]=1;
    }
    For(j,1,min(p,a[i].se)+1) f[i][j] = sum[j];
}
```

---

# **可视化算法演示**
## **核心流程动画**
1. **排序阶段**：
   - 动态展示山按高度降序排列，相同高度按关键值升序
   - **高亮**：每次比较时的两座山，红色箭头表示排序方向

2. **插入方案计算**：
   - **第一问**：图示当前山插入到不同位置（前p个高山的空隙）
   - **第二问**：动态绘制DP表格，展示 `f[i][j]` 如何从 `f[i-1][k]` 转移

## **复古像素风格设计**
- **颜色方案**：
  - 山体：8-bit绿色渐变（高度越高颜色越深）
  - DP表格：黄色网格线+蓝色激活块
- **音效**：
  - 插入成功：8-bit "ping"声
  - DP转移：短促"beep"声

## **交互控制**
```html
<canvas id="terrain-canvas"></canvas>
<div class="control-panel">
  <button onclick="prevStep()">← 上一步</button>
  <button onclick="nextStep()">下一步 →</button>
  <input type="range" id="speed" min="1" max="5" value="3">
</div>
<script>
// 伪代码示例
function drawDPGrid() {
  ctx.fillStyle = '#FFD700'; // 金色网格
  // 绘制DP表格...
  ctx.fillStyle = '#00F'; 
  ctx.fillRect(j*cellW, i*cellH, cellW, cellH); // 激活的DP单元格
}
</script>
```

---

# **相似题目推荐**
1. [P4071 [SDOI2016]排列计数](https://www.luogu.com.cn/problem/P4071)  
   **考察点**：错位排列+组合数计算

2. [P3223 [HNOI2012]排队](https://www.luogu.com.cn/problem/P3223)  
   **考察点**：多重限制下的排列组合

3. [P2513 [HAOI2009]逆序对数列](https://www.luogu.com.cn/problem/P2513)  
   **考察点**：动态规划维护排列性质

---

# **核心代码实现**
## **动态规划+前缀和优化**
```cpp
void solve2() {
    memset(f, 0, sizeof f);
    f[0][1] = 1; // 初始状态：第一个位置放第一个山
    int ans = 1, p = 0;
    
    for(int i=1; i<=n; ++i) {
        // 计算比当前山高的数量p
        while(a[p+1].h > a[i].h) p++;
        
        // 前缀和预处理
        for(int j=1; j<=n+1; ++j)
            sum[j] = (sum[j-1] + f[i-1][j]) % mod;
        
        // 新高度组重置
        if(p == i-1) {
            ans = ans * sum[n+1] % mod;
            memset(f[i-1], 0, sizeof f[i-1]);
            f[i-1][1] = 1;
            for(int j=1; j<=n+1; ++j) sum[j] = 1;
        }
        
        // DP转移
        for(int j=1; j<=min(p, a[i].k)+1; ++j)
            f[i][j] = sum[j];
    }
}
```

---
处理用时：80.13秒
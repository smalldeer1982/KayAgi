# 题目信息

# [SDOI2015] 约数个数和

## 题目描述

设 $d(x)$ 为 $x$ 的约数个数，给定 $n,m$，求    
$$\sum_{i=1}^n\sum_{j=1}^md(ij)$$


## 说明/提示

【数据范围】   
对于 $100\%$ 的数据，$1\le T,n,m \le 50000$。


## 样例 #1

### 输入

```
2
7 4
5 6```

### 输出

```
110
121```

# AI分析结果



**算法分类**: 数论

---

### **核心思路与难点解析**
1. **关键公式**  
   $$ d(ij) = \sum_{x|i} \sum_{y|j} [\gcd(x,y)=1] $$
   **推导思路**：对每个质因数 $p$，在 $i$ 中选 $p^a$ 或在 $j$ 中选 $p^b$，确保两边不同时选取，转化为互质条件。

2. **莫比乌斯反演**  
   将互质条件用 $\mu$ 函数展开：
   $$\sum_{i=1}^n \sum_{j=1}^m \sum_{x|i} \sum_{y|j} \sum_{d|\gcd(x,y)} \mu(d)$$
   调整求和顺序后，通过数论分块和预处理优化时间复杂度。

3. **预处理与分块**  
   预处理函数 $g(n) = \sum_{i=1}^n \lfloor \frac{n}{i} \rfloor$ 和 $\mu$ 前缀和，将复杂度降至 $O(\sqrt{n})$。

---

### **题解评分 (≥4星)**

1. **Siyuan (★★★★★)**  
   - **亮点**：详细推导关键公式，分块预处理 $g(n)$，代码可读性强  
   - **核心代码**：
     ```cpp
     for(int x=1;x<=5e4;++x) {
         long long res=0;
         for(int i=1,j;i<=x;i=j+1) 
             j=x/(x/i), res += 1LL*(j-i+1)*(x/i);
         s[x]=res;
     }
     ```

2. **pengym (★★★★☆)**  
   - **亮点**：强调 $d(x)=\prod (a_i+1)$ 的性质，分步反演过程清晰  
   - **心得**：指出预处理 $\sigma_0$ 的重要性，避免重复计算分块值。

3. **洛水·锦依卫 (★★★★☆)**  
   - **亮点**：分步拆解反演过程，注释详细，适合初学者理解  
   - **核心公式**：$ans = \sum \mu(d) \cdot g(n/d) \cdot g(m/d)$

---

### **最优思路提炼**
1. **公式转换**：将 $d(ij)$ 转化为互质求和形式，避免重复计数。
2. **分块优化**：预处理 $g(n)$ 和 $\mu$ 前缀和，将双重求和转为单层分块。
3. **线性筛法**：快速计算 $\mu$ 和 $\sigma_0$ 的前缀和，减少运行时开销。

---

### **同类型题推荐**
1. **P3455 [POI2007] ZAP-Queries**（莫比乌斯反演基础）
2. **P2522 [HAOI2011] Problem c**（约数函数与反演结合）
3. **P2257 YY的GCD**（进阶莫比乌斯反演应用）

---

### **可视化设计思路**
**动画步骤**：
1. **公式展开**：动态展示 $d(ij)$ 分解为互质对的过程，高亮质因数分配逻辑。
2. **莫比乌斯转换**：用颜色标记 $\mu(d)$ 的筛选作用，展示反演后的求和结构。
3. **分块演示**：用滑动块展示 $n/d$ 和 $m/d$ 的分段区间，对比预处理后的 $g(n)$ 值。
4. **复古像素效果**：用 8-bit 风格显示分块区间，配合音效提示关键计算完成。

**交互设计**：
- **单步执行**：允许用户逐层展开求和公式，观察中间变量变化。
- **速度调节**：控制分块过程的速度，观察不同 $d$ 值对结果的影响。

---

### **核心代码实现**
```cpp
// 预处理 mu 和 g(n)
void init() {
    mu[1] = 1;
    for (int i = 2; i <= N; ++i) {
        if (!vis[i]) prime[++cnt] = i, mu[i] = -1;
        // ... 线性筛部分
    }
    // 计算 g(n)
    for (int i = 1; i <= N; ++i) 
        for (int l=1, r; l<=i; l=r+1) 
            r = i/(i/l), g[i] += (r-l+1)*(i/l);
}

// 主计算逻辑
long long solve(int n, int m) {
    long long ans = 0;
    for (int l=1, r; l <= min(n,m); l=r+1) {
        r = min(n/(n/l), m/(m/l));
        ans += (mu[r] - mu[l-1]) * g[n/l] * g[m/l];
    }
    return ans;
}
```

---

**总结**：通过巧妙公式转换与分块优化，将复杂求和问题降至线性时间复杂度，是数论与算法优化的经典结合。

---
处理用时：69.36秒
# 题目信息

# Koishi Loves Number Theory

## 题目描述

Koishi 十分喜欢数论。


她的朋友 Flandre 为了检测她和数论是不是真爱，给了她一个问题。


已知 $f(n)=\sum_{i=0}^nx^i$

给定 $x$ 和 $N$ 个数 $a_i$，求 $\mathrm{lcm}(f(a_1),f(a_2),...,f(a_N))$ 对 $10^9+7$ 取模。


按照套路，呆萌的 Koishi 当然假装不会做了，于是她来向你请教这个问题，希望你能在 $1$ 秒内给她答案。


## 说明/提示

$\mathrm{lcm}$ 表示若干个数的**最小公倍数**。


对于 $10\%$ 的数据，$1\leq N\leq 100$，$0\leq a_i\leq 9$，$x=2$。

对于另外 $20\%$ 的数据，$1\leq N\leq 50$，$0\leq a_i\leq 100$，$2\leq x\leq 10$。

对于另外 $30\%$ 的数据，$1\leq N\leq 16$，$0\leq a_i\leq 10^9$，$2\leq x\leq 10^{18}$。

对于 $100\%$ 的数据，$1\leq N\leq 100$，$0\leq a_i\leq 10^9$，$2\leq x\leq 10^{18}$，且 $x\not\equiv 1\pmod{10^9+7}$。


## 样例 #1

### 输入

```
3 5
1 2 4 5 0```

### 输出

```
44044```

# AI分析结果



**算法分类**  
数论

---

**题解思路与解决难点**  

1. **公式转换**  
   - 将等比数列和转换为 `(x^(a+1) -1)/(x-1)`，问题转化为求分子部分的 LCM 并除以 `x-1`（模逆元处理）。

2. **关键数学结论**  
   - **gcd(x^a-1, x^b-1) = x^gcd(a,b)-1**：通过辗转相除或构造法证明，将指数问题转化为求指数 gcd。
   - **LCM 的容斥表示**：利用 min-max 容斥，将 LCM 分解为所有子集 GCD 的奇偶交替乘积。

3. **动态维护因数贡献**  
   - 使用 `map` 维护每个可能因数（即 `x^d-1` 的指数 d）的贡献次数，每次加入新数时更新各因数的奇偶贡献。

4. **优化与复杂度**  
   - 因数数量有限（约 O(n√V)），动态更新仅需遍历当前所有因数，复杂度 O(n² log V)。

---

**题解评分 (≥4星)**  

1. **Soulist 题解 (5星)**  
   - 思路清晰，完整推导容斥公式，预处理所有因数并计算贡献，代码结构清晰。

2. **dovely_seele 题解 (4星)**  
   - 动态维护因数贡献，代码简短但可读性稍低，需结合注释理解 map 的奇偶更新逻辑。

3. **SunsetSamsara 题解 (4星)**  
   - 记忆化递归分解子问题，利用唯一性减少重复计算，代码简洁高效。

---

**最优思路提炼**  

1. **容斥公式转换**  
   - 将 LCM 转化为奇偶子集 GCD 乘积，避免直接处理大数。

2. **动态因数维护**  
   - 每次加入新数时，仅更新现有因数的贡献，无需重新计算所有子集。

3. **数学结论加速**  
   - 利用 `gcd(x^a-1, x^b-1) = x^gcd(a,b)-1`，将指数问题简化为整数 gcd。

---

**同类型题与套路**  

- **数论公式转换**：如将复杂和式转换为指数形式。
- **因数分解与容斥**：处理多个数的 LCM/GCD 时，分解因数并统计贡献。
- **动态维护中间状态**：适用于逐步添加元素的场景，减少重复计算。

**推荐题目**  
1. P2444 (求多组数的 GCD 性质)  
2. P3312 (数论函数与莫比乌斯反演)  
3. P2158 (欧拉函数与因数分解)

---

**可视化与算法演示**  

1. **动画流程**  
   - **Step 1**：显示输入的数 a_i，转化为指数形式 `a_i+1`。  
   - **Step 2**：动态维护因数 `d` 的贡献图，每次加入新数时，高亮新增的因数并更新贡献。  
   - **Step 3**：展示最终乘积计算，每个因数的贡献以颜色区分奇偶次幂。

2. **复古像素风格**  
   - **Canvas 绘制**：因数节点以像素方块表示，贡献次数以数字闪烁。  
   - **音效**：成功更新因数时播放 8-bit 上升音效，错误操作时播放低沉音效。  
   - **自动模式**：模拟贪吃蛇 AI，逐步“吞并”因数并显示路径。

---

**代码片段 (Soulist 题解)**  
```cpp
// 预处理所有因数并容斥计算贡献
vector<int> w;
rep(i,1,n) {
    int x = a[i]+1;
    for(int j=1; j*j<=x; j++) { // 收集所有因数
        if(x%j) continue;
        w.push_back(j), w.push_back(x/j);
    }
}
sort(w.begin(), w.end());
w.erase(unique(w.begin(),w.end()), w.end());

// 容斥计算每个因数的系数
drep(i,1,cnt) {
    F[i] = 1;
    rep(j,i+1,cnt) if(w[j]%w[i]==0) 
        F[i] = (F[i] - F[j] + MOD) % MOD;
}

// 最终答案计算
int ans = 1;
rep(i,1,cnt) {
    int dx = qpow(X, w[i]) - 1;
    ans = ans * qpow(dx, F[i]) % MOD;
}
ans = ans * qpow(X-1, MOD-2) % MOD;
```

---

**个人心得**  
- **调试教训**：逆元未及时取模导致负数，需 `(a%MOD + MOD)%MOD`。  
- **思维突破**：意识到 LCM 可分解为子集 GCD 乘积，避免直接处理大数。

---
处理用时：79.68秒
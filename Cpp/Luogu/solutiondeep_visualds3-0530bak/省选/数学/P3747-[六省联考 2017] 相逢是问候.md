# 题目信息

# [六省联考 2017] 相逢是问候

## 题目描述

> Informatik verbindet dich und mich.  
> 信息将你我连结。

B 君希望以维护一个长度为 $n$ 的数组，这个数组的下标为从 $1$ 到 $n$ 的正整数。

一共有 $m$ 个操作，可以分为两种：

- `0 l r` 表示将第 $l$ 个到第 $r$ 个数（ $a_l,a_{l+1} ...a_r$）中的每一个数 $a_i$ 替换为 $c^{a_i}$，即 $c$ 的 $a_i$ 次方，其中 $c$ 是输入的一个常数，也就是执行赋值 $a_i = c^{a_i}$。

- `1 l r` 求第 $l$ 个到第 $r$ 个数的和，也就是输出： $\sum_{i=l}^{r}a_i$

因为这个结果可能会很大，所以你只需要输出结果 $\bmod \space p$ 的值即可。


## 说明/提示

【数据范围】  

对于 $0\%$ 的测试点，和样例一模一样；

对于另外 $10\%$ 的测试点，没有修改；

对于另外 $20\%$ 的测试点，每次修改操作只会修改一个位置（也就是 $l = r$ ），并且每个位置至多被修改一次；

• 对于另外 $10\%$ 的测试点， $p = 2$；

对于另外 $10\%$ 的测试点， $p = 3$；

对于另外 $10\%$ 的测试点， $p = 4$；

对于另外 $20\%$ 的测试点， $1\le n,m \le 100$；

对于 $100\%$ 的测试点， $1\le n,m \le 5\times 10^4$，$1 \le p \le 10^8$，$0< c < p$，$0 \le a_i < p$。


## 样例 #1

### 输入

```
4 4 7 2
1 2 3 4
0 1 4
1 2 4
0 1 4
1 1 3```

### 输出

```
0
3```

## 样例 #2

### 输入

```
1 40 19910626 2
0
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1```

### 输出

```
1
2
4
16
65536
11418102
18325590
13700558
13700558
13700558
13700558
13700558
13700558
13700558
13700558
13700558
13700558
13700558
13700558
13700558```

# AI分析结果



### 唯一算法分类
数论

### 综合分析与结论
本题核心是处理指数塔模运算，利用扩展欧拉定理将指数层数压缩。关键难点在于递归计算时对指数是否超过当前模数的判断，以及通过线段树维护每个元素的修改次数上限。各题解通过预处理欧拉函数链、光速幂分块优化实现高效计算。

#### 关键公式推导
**扩展欧拉定理**：
$$
a^b \equiv 
\begin{cases} 
a^{b \bmod \phi(p) + \phi(p)} \mod p & b \geq \phi(p) \\
a^b \mod p & \text{otherwise}
\end{cases}
$$

**模数链**：
$$
p_0 = p,\ p_{i+1} = \phi(p_i),\ \text{直到}\ p_k=1
$$

#### 可视化设计思路
1. **模数层级动画**：用不同颜色块表示各层模数，展示计算时递归降层过程
2. **光速幂分块演示**：将指数拆分为高位块(10000进制)与低位块，通过预计算块值快速组合
3. **线段树状态追踪**：高亮当前被修改的区间节点，显示其修改次数和收敛状态
4. **递归路径高亮**：用箭头连接递归调用的欧拉函数层级，标注每一步的指数计算结果

### 题解清单 (≥4星)
1. **Luan_233 (5星)**  
   - 亮点：预处理光速幂分块表，实现O(1)快速幂；分层处理欧拉函数链
   - 代码结构清晰，包含完整的预处理和线段树维护
2. **s_r_f (4星)**  
   - 亮点：简洁的递归实现，将模数链处理与线段树结合
   - 使用结构体维护指数是否超过模数的状态
3. **juju527 (4星)**  
   - 亮点：详细推导扩展欧拉定理应用场景，通过分层预处理优化计算
   - 在线段树节点中维护最小修改次数实现剪枝

### 核心代码实现
**光速幂预处理与计算**：
```cpp
// 预处理分块幂
for(int j=0;j<=mint;++j){
    pow1[0][j]=1;
    for(int i=1;i<=10000;++i){
        pow1[i][j]=pow1[i-1][j]*c;
        if(pow1[i][j]>=phi[j]) pow1[i][j]%=phi[j],b1[i][j]=1;
        b1[i][j]|=b1[i-1][j];
    }
}

// 分块计算快速幂
LL calc(LL v,LL id){
    LL v1=v%10000,v2=v/10000,ret=pow1[v1][id]*pow2[v2][id];
    if(ret>=phi[id]) ret=ret%phi[id],flag=1;
    flag|=b1[v1][id]|b2[v2][id];
    return ret;
}
```

**递归计算指数塔**：
```cpp
LL dfs(LL vi,int deep,int lim){
    if(deep==lim) return vi%phi[deep];
    LL ci=dfs(vi,deep+1,lim);
    return calc(flag?ci+phi[deep+1]:ci,deep);
}
```

### 同类型题与套路
1. **指数塔取模**：通过递归应用扩展欧拉定理
2. **势能线段树**：维护区间不可变性质（如开方、取模次数）
3. **模数链预处理**：预先计算所有可能的模数层级

### 推荐习题
1. P4139 上帝与集合的正确用法（扩展欧拉定理模板）
2. P4145 花神游历各国（势能线段树应用）
3. CF906D Power Tower（多层模数处理）

### 可视化实现要点
**8位像素风格演示**：
1. **模数层级**：用不同颜色方块表示p→φ(p)→φ(φ(p))链
2. **递归路径**：像素箭头连接层级，显示当前计算的指数层
3. **光速幂分块**：将指数拆分为高低位，用闪烁动画显示块组合过程
4. **线段树节点**：用网格显示区间修改次数，收敛节点显示锁定图标

**音效设计**：
- 进入新模数层级：播放上升音调
- 完成分块计算：8位"哔"声
- 线段树节点锁定：经典马里奥金币音效

### 个人心得
调试时需特别注意边界情况：
1. c=1时指数恒为1，需特殊处理
2. 模数降层过程中需判断是否达到φ(p)=1的终止条件
3. 快速幂预处理时要处理溢出标记，避免错误应用扩展定理

---
处理用时：69.17秒
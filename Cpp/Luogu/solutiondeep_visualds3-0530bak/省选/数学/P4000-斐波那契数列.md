# 题目信息

# 斐波那契数列

## 题目描述

大家都知道，斐波那契数列是满足如下性质的一个数列：

• $f_1 = 1$

• $f_2 = 1$

• $f_n = f_{n-1} + f_{n-2}$ ($n \geq 2$ 且 $n$ 为整数)

请你求出 $f_n \mod p$ 的值。


## 说明/提示

对于 $100\%$ 的数据，$n \leq 10^{30000000}, p<2^{31}$


## 样例 #1

### 输入

```
5
1000000007```

### 输出

```
5```

## 样例 #2

### 输入

```
10
1000000007```

### 输出

```
55```

# AI分析结果



---

## 唯一算法分类：数论

---

### 综合分析与结论

#### 核心思路与难点
1. **循环节定理**：斐波那契数列在模 $p$ 下存在循环节 $\pi(p) \leq 6p$。核心问题转化为快速求 $\pi(p)$。
2. **质因数分解法**（飞雨烟雁、zhenjianuo2025）：
   - 分解 $p = \prod p_i^{k_i}$，对每个质因子计算 $\pi(p_i^{k_i}) = \pi(p_i) \cdot p_i^{k_i-1}$，再求 LCM。
   - $\pi(p_i)$ 计算：若 $5$ 是 $p_i$ 的二次剩余，$\pi(p_i)=p_i-1$；否则 $\pi(p_i)=2(p_i+1)$。
   - 需处理 $p=2,5$ 的特例，并实现快速质因数分解。
3. **随机化+生日悖论**（Itst、Pulsating_Dust）：
   - 随机生成位置 $i$，计算 $(f_i, f_{i+1})$，存入哈希表。
   - 根据生日悖论，期望 $O(\sqrt{p})$ 次找到重复状态，得到循环节倍数。
   - 配合矩阵光速幂快速计算任意位置的斐波那契数。

#### 关键公式与推导
1. **二次剩余判定**：
   - 若 $5^{(p-1)/2} \equiv 1 \pmod{p}$，则 $5$ 是模 $p$ 的二次剩余，$\pi(p)=p-1$。
   - 否则，$\pi(p)=2(p+1)$。
2. **光速幂优化**：
   - 预处理矩阵幂 $B^0, B^1, \dots, B^{2^{18}-1}$ 和 $B^{2^{18}}, B^{2^{19}}, \dots$。
   - 计算 $B^n = B^{n \mod 2^{18}} \cdot (B^{2^{18}})^{n / 2^{18}}$，时间复杂度 $O(1)$。

---

### 题解清单（≥4星）

1. **飞雨烟雁（4.5星）**  
   - **亮点**：完整推导循环节公式，覆盖质因子分解、二次剩余、扩域等数论细节。  
   - **代码**：质因数分解+递归计算循环节，可读性较高。  
   - **心得**：“调试时注意特判 $p=1$ 和 $n=0$ 的边界情况。”

2. **Itst（4.2星）**  
   - **亮点**：利用生日悖论快速求循环节倍数，矩阵光速幂实现优雅。  
   - **代码**：哈希表存储随机状态，光速幂预处理减少计算量。

3. **RuSun（4.0星）**  
   - **亮点**：矩阵 BSGS 求循环节，代码简洁，适合小规模 $p$。  
   - **心得**：“BSGS 的哈希函数需用矩阵哈希，避免冲突。”

---

### 最优思路提炼

1. **质因数分解+二次剩余法**：
   - 分解 $p$，对每个质因子 $p_i$ 计算 $\pi(p_i)$，再求 LCM。
   - 优势：确定性算法，精确计算循环节。
   - 适用场景：$p$ 较小或质因子较少时。

2. **随机化+矩阵光速幂**：
   - 随机采样+哈希判重，配合光速幂快速计算。
   - 优势：无需质因数分解，适合极大 $p$。
   - 适用场景：$p$ 极大或质因子复杂时。

---

### 同类型题与算法套路

1. **通用套路**：
   - **循环节问题**：如模意义下的幂次循环（欧拉定理）、线性递推数列循环节。
   - **质因数分解**：Pollard-Rho 优化分解速度。
   - **光速幂**：预处理分块加速矩阵/数的高次幂。

2. **类似题目**：
   - **P4994**：求斐波那契数列模 $m$ 的起点。
   - **SP12007**：求斐波那契数列模 $10^k$ 的循环节。
   - **P1962**：普通斐波那契数列矩阵快速幂。

---

### 推荐题目

1. **P4994**（模意义下斐波那契起点）  
2. **SP12007**（循环节计算）  
3. **P6091**（原根与数论基础）  

---

### 可视化与算法演示

#### 动画方案设计

1. **质因数分解阶段**：
   - **像素动画**：显示 $p$ 分解为 $p_1^{k_1} \cdot p_2^{k_2} \dots$，每个质因子高亮。
   - **音效**：分解成功时播放“叮”声。

2. **循环节计算阶段**：
   - **矩阵光速幂**：分块显示预处理矩阵，每块颜色不同。
   - **随机采样**：显示随机位置 $i$ 和对应的 $(f_i, f_{i+1})$，碰撞时闪烁提示。

3. **最终计算**：
   - **模运算**：显示 $n \mod \pi(p)$ 的过程，数字逐位缩小。
   - **音效**：计算完成时播放胜利音效。

#### 复古游戏化实现

```javascript
// 示例：Canvas 绘制矩阵光速幂分块
const ctx = canvas.getContext('2d');
function drawMatrixBlock(blockIdx, color) {
    const x = (blockIdx % 8) * 32;
    const y = Math.floor(blockIdx / 8) * 32;
    ctx.fillStyle = color;
    ctx.fillRect(x, y, 30, 30);
}

// 音效：8-bit 风格
const audioCtx = new AudioContext();
function playBeep(freq) {
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.1);
}
```

---

### 核心代码片段

#### 飞雨烟雁的质因数分解法

```cpp
long long get_cycle_from_mod(long long mod) {
    vector<Factor> factors = factorize(mod); // Pollard-Rho 分解
    long long cycle = 1;
    for (auto &f : factors) {
        long long sub_cycle = pisano_prime(f.prime);
        sub_cycle *= pow(f.prime, f.power - 1);
        cycle = lcm(cycle, sub_cycle);
    }
    return cycle;
}
```

#### Itst 的随机化+光速幂

```cpp
// 预处理光速幂块
Matrix T[2][1<<18];
void precompute() {
    T[0][1] = {{1,1}, {1,0}};
    for (int i=2; i<=1e18; i++) T[0][i] = T[0][i-1] * T[0][1];
    T[1][1] = T[0][1<<18];
    for (int i=2; i<=1e18; i++) T[1][i] = T[1][i-1] * T[1][1];
}

Matrix get_pow(long long n) {
    return T[0][n & (1<<18 -1)] * T[1][n >> 18];
}
```

---
处理用时：87.86秒
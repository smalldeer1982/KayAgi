# 题目信息

# 上帝与集合的正确用法

## 题目描述

根据一些书上的记载，上帝的一次失败的创世经历是这样的：

第一天，上帝创造了一个世界的基本元素，称做元。

第二天，上帝创造了一个新的元素，称作 $\alpha$ 。 $\alpha$ 被定义为元构成的集合。容易发现，一共有两种不同的 $\alpha$ 。

第三天，上帝又创造了一个新的元素，称作 $\beta$ 。 $\beta$ 被定义为 $\alpha$ 构成的集合。容易发现，一共有四种不同的 $\beta$。

第四天，上帝创造了新的元素 $\gamma$，$\gamma$ 被定义为 $\beta$ 的集合。显然，一共会有 $16$ 种不同的 $\gamma$。

如果按照这样下去，上帝创造的第四种元素将会有 $65536$ 种，第五种元素将会有 $2^{65536}$种。这将会是一个天文数字。

然而，上帝并没有预料到元素种类数的增长是如此的迅速。他想要让世界的元素丰富起来，因此，日复一日，年复一年，他重复地创造着新的元素……

然而不久，当上帝创造出最后一种元素 $\theta$ 时，他发现这世界的元素实在是太多了，以致于世界的容量不足，无法承受。因此在这一天，上帝毁灭了世界。

至今，上帝仍记得那次失败的创世经历，现在他想问问你，他最后一次创造的元素 $\theta$ 一共有多少种？

上帝觉得这个数字可能过于巨大而无法表示出来，因此你只需要回答这个数对 $p$ 取模后的值即可。

你可以认为上帝从 $\alpha$ 到 $\theta$ 一共创造了 $10^9$ 次元素，或 $10^{18}$ 次，或者干脆 $\infty$ 次。

一句话题意：

定义 $a_0=1,a_n=2^{a_{n-1}}$，可以证明 $b_n=a_n\bmod p$ 在某一项后都是同一个值，求这个值。

## 说明/提示

对于 $100\%$ 的数据，$T\le 10^3$，$p\le10^7$。

## 样例 #1

### 输入

```
3
2
3
6```

### 输出

```
0
1
4```

# AI分析结果



## 数学分类
**数论**

---

## 题解思路与核心难点

### 核心公式与推导
**扩展欧拉定理**：  
当 $b \geq \varphi(p)$ 时，$a^b \equiv a^{b \mod \varphi(p) + \varphi(p)} \mod p$。  
题目中的无限次塔幂 $2^{2^{2^{\cdots}}}$ 满足 $b \geq \varphi(p)$，因此递归应用定理降幂。

### 算法要点
1. **预处理欧拉函数**：  
   线性筛法（时间复杂度 $O(n)$）或非筛法（单次计算 $\varphi(p)$）。
2. **递归求解**：  
   递归边界为 $p=1$ 时返回 $0$，其他情况递归计算 $\varphi(p)$ 并求指数部分。
3. **快速幂优化**：  
   使用快速幂计算 $2^{\text{指数}} \mod p$，注意处理大指数时的取模。

### 解决难点
- **递归条件判断**：确保每次递归满足 $b \geq \varphi(p)$，直接应用扩展定理。
- **欧拉函数计算效率**：线性筛法预处理适用于多次查询，非筛法在单次查询时更快。

---

## 题解评分（≥4星）

### 1. panda_2134（5星）
- **亮点**：预处理欧拉函数，代码结构清晰，快速幂与递归逻辑简洁。
- **代码片段**：
  ```cpp
  int solve(int mod) {
      if(mod == 1) return 0;
      return fastpow(2, solve(phi[mod]) + phi[mod], mod);
  }
  ```

### 2. Siyuan（5星）
- **亮点**：线性筛法优化，时间复杂度更低，适合大范围 $p$。
- **代码片段**：
  ```cpp
  int solve(int p) {
      if(p == 1) return 0;
      return pow(2, solve(phi[p]) + phi[p], p);
  }
  ```

### 3. ezoiHQM（4.5星）
- **亮点**：对比筛法与非筛法效率，强调线性筛的优势。
- **代码片段**：
  ```cpp
  void Get_phi() {
      for(int i=2; i<=maxn; i++) {
          if(!phi[i]) {
              prime[++tot]=i, phi[i]=i-1;
          }
          // 线性筛逻辑
      }
  }
  ```

---

## 最优思路提炼
1. **递归应用扩展欧拉定理**：  
   每次将问题转化为计算 $\varphi(p)$ 后的子问题，直到 $p=1$。
2. **预处理欧拉函数**：  
   使用线性筛法预处理所有 $\varphi(p)$，单次查询时间复杂度 $O(\log p)$。
3. **快速幂优化**：  
   确保指数部分在递归中正确累加 $\varphi(p)$，避免溢出。

---

## 同类型题与套路
- **通用套路**：涉及无限次幂取模时，优先考虑扩展欧拉定理降幂。
- **类似题目**：  
  - 洛谷 P5091（扩展欧拉定理模板题）  
  - 洛谷 P4139（本题）  
  - 洛谷 P3747（需要结合其他数论知识）

---

## 可视化与算法演示
### 核心步骤动画设计
1. **递归过程可视化**：  
   - 初始模数 $p$，计算 $\varphi(p)$，显示为绿色方块。  
   - 递归进入下一层，模数变为 $\varphi(p)$，重复直到 $p=1$（红色方块）。  
2. **快速幂计算**：  
   - 显示当前指数和模数，分解为二进制位，高亮每一步的乘法和取模操作。  
3. **像素风格设计**：  
   - 使用 8-bit 像素字体，递归树用不同颜色层级展示，音效提示递归深度变化。  

### 复古游戏化效果
- **Canvas 绘制**：递归树以网格布局展开，每个节点显示当前 $p$ 和 $\varphi(p)$。  
- **音效触发**：  
  - 进入递归层时播放 "beep" 音效。  
  - 计算快速幂时伴随节奏音效。  
- **积分系统**：每完成一层递归获得 10 分，最终得分与递归深度相关。

---

## 个人心得摘录
- **调试教训**：递归边界必须严格处理 $p=1$，否则导致死循环。  
- **效率对比**：预处理欧拉函数时，线性筛法在多次查询下优势明显，但单次查询非筛法更快。  

---

## 推荐代码（核心逻辑）
```cpp
// 线性筛法预处理欧拉函数
void sieve_phi(int maxn) {
    phi[1] = 1;
    for (int i = 2; i <= maxn; i++) {
        if (!vis[i]) {
            prime[++tot] = i;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= tot && i * prime[j] <= maxn; j++) {
            vis[i * prime[j]] = true;
            if (i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            } else {
                phi[i * prime[j]] = phi[i] * (prime[j] - 1);
            }
        }
    }
}

// 递归求解答案
int solve(int p) {
    if (p == 1) return 0;
    return quick_pow(2, solve(phi[p]) + phi[p], p);
}
```

---
处理用时：69.65秒
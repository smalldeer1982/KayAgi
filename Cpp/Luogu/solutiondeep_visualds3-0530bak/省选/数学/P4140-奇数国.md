# 题目信息

# 奇数国

## 题目描述

在一片美丽的大陆上有 $100\,000$ 个国家，记为 $1$ 到 $100\,000$。这里经济发达，有数不尽的账房，并且每个国家有一个银行。

某大公司的领袖在这 $100\,000$ 个银行开户时都存了 $3$ 大洋，他惜财如命，因此会不时地派小弟 GFS 清点一些银行的存款或者让 GFS 改变某个银行的存款。

该村子在财产上的求和运算等同于我们的乘法运算，也就是说领袖开户时的存款总和为 $3^{100000}$。这里发行的软妹面额是最小的 $60$ 个素数（$p_1=2,p_2=3,\ldots, p_{60}=281$），任何人的财产都只能由这 $60$ 个基本面额表示，即设某个人的财产为 $fortune$（正整数），则 $fortune=p_1^{k_1} \times p_2^{k_2} \times \ldots p_{60}^{k_{60}}$。

领袖习惯将一段编号连续的银行里的存款拿到一个账房去清点，为了避免 GFS 串通账房叛变，所以他不会每次都选择同一个账房。GFS 跟随领袖多年已经摸清了门路,知道领袖选择账房的方式。如果领袖选择清点编号在 $[a,b]$ 内的银行财产，他会先对 $[a,b]$ 的财产求和（记为 $product$），然后在编号属于 $[1,product]$ 的账房中选择一个去清点存款，检验自己计算是否正确同时也检验账房与 GFS 是否有勾结。GFS 发现如果某个账房的编号 $number$ 与 $product$ 相冲，领袖绝对不会选择这个账房。

怎样才算与 $product$ 不相冲呢？若存在整数 $x,y$ 使得 $number \times x+product \times y=1$，那么我们称 $number$ 与 $product$ 不相冲，即该账房有可能被领袖相中。当领袖又赚大钱了的时候，他会在某个银行改变存款，这样一来相同区间的银行在不同的时候算出来的 $product$ 可能是不一样的，而且领袖不会在某个银行的存款总数超过 $10^6$。

现在 GFS 预先知道了领袖的清点存款与变动存款的计划，想请你告诉他，每次清点存款时领袖有多少个账房可以供他选择，当然这个值可能非常大，GFS 只想知道对 $19\,961\,993$ 取模后的答案。

## 说明/提示

### 样例解释

- 初始化每个国家存款都为 $3$；
- $1$ 到 $3$ 的 $product$ 为 $27$，$[1,27]$ 与 $27$ 不相冲的有 $18$ 个数；
- $1$ 的存款变为 $5$；
- $1$ 到 $3$ 的 $product$ 为 $45$，$[1,45]$ 与 $45$ 不相冲的有 $24$ 个数；
- $1$ 的存款变为 $7$；
- $1$ 到 $3$ 的 $product$ 为 $63$，$[1,63]$ 与 $63$ 不相冲的有 $36$个数；
- $2$ 到 $3$ 的 $product$ 为 $9$，$[1,9]$ 与 $9$ 不相冲的有 $6$ 个数。

### 数据范围

所有数据均满足：$x \geq 1$，$c_i -b_i \geq 0$。

| 子任务编号 | 分值 |    $x \leq$     | $c_i - b_i \leq$ | 特殊性质 |
| :--------: | :--: | :-------------: | :--------------: | :------: |
|    $1$     | $20$ |     $10^4$      |      $100$       |    有    |
|    $2$     | $30$ | $5 \times 10^4$ |      $10^4$      |    无    |
|    $3$     | $50$ |     $10^5$      |      $10^5$      |    无    |

特殊性质指：所有 $product \leq 10^{18}$。

## 样例 #1

### 输入

```
6
0 1 3
1 1 5
0 1 3
1 1 7
0 1 3
0 2 3```

### 输出

```
18
24
36
6

```

# AI分析结果



### 数学分类：数论

---

### 题解核心思路与算法要点

#### 核心数学逻辑：
题目要求区间积的欧拉函数值，公式推导如下：
$$
\varphi(n) = n \cdot \prod_{p_i | n} \left(1 - \frac{1}{p_i}\right)
$$
只需知道积包含哪些质因子即可计算，无需具体指数次数。

#### 解决难点：
1. **质因子压缩**：前60个质数可压缩为 `long long` 的位掩码（1位表示存在对应质因子）。
2. **区间维护**：用线段树同时维护区间乘积（取模后值）和质因子位掩码。
3. **逆元优化**：预处理质数的逆元，将除法转化为乘法。

#### 数据结构与操作：
- **线段树节点**存储 `{乘积, 质因子掩码}`，合并时：
  ```text
  乘积 = 左子树乘积 * 右子树乘积 % mod
  掩码 = 左子树掩码 | 右子树掩码
  ```
- **单点修改**：分解新值的质因子，更新对应位掩码。

---

### 高星题解评分 (≥4星)

#### 1. Siyuan（★★★★★）
- **亮点**：代码简洁，利用线段树+位掩码，预处理逆元。
- **代码片段**：
  ```cpp
  void pushup(int p) {
      seg[p] = seg[lson] | seg[rson]; // 合并质因子掩码
      mul[p] = 1LL * mul[lson] * mul[rson] % mod; // 合并乘积
  }
  ```

#### 2. winxp_qwq（★★★★☆）
- **亮点**：详细讲解线段树维护逻辑，强调位运算优化。
- **个人心得**：强调 `long long` 移位必须用 `1LL<<i`，避免溢出。

#### 3. DrLin（★★★★☆）
- **亮点**：使用二维数组维护质因子状态，代码可读性高。
- **关键公式**：
  ```cpp
  ans = product * Π( (p_i-1)/p_i ) % mod
  ```

---

### 最优思路提炼
1. **质因子位掩码**：用 `long long` 的二进制位表示质因子存在性。
2. **逆元预处理**：避免重复计算，加速欧拉函数求解。
3. **线段树双维护**：同时维护区间乘积和质因子状态，保证复杂度 O(logn)。

---

### 同类型题目套路
1. **区间数论函数**：如区间GCD、区间积的因数个数。
2. **质数压缩技巧**：适用于质数种类有限的场景。
3. **逆元优化**：在模运算中替代除法。

---

### 推荐题目
1. [P3372 线段树区间求和](https://www.luogu.com.cn/problem/P3372)
2. [P2158 欧拉函数计算](https://www.luogu.com.cn/problem/P2158)
3. [P1890 质因子区间查询](https://www.luogu.com.cn/problem/P1890)

---

### 可视化设计（复古像素风格）

#### 动画流程：
1. **初始化**：显示线段树结构，每个节点包含 `[乘积, 掩码]`。
2. **修改操作**：
   - 高亮修改位置，分解新值的质因子（像素粒子飞散效果）。
   - 更新线段树路径上的节点，播放“点击”音效。
3. **查询操作**：
   - 展示区间分割过程，合并子区间的乘积和掩码。
   - 用不同颜色显示每个质因子的贡献，最终显示欧拉公式计算结果。

#### 技术实现：
- **Canvas绘图**：线段树节点用像素方块表示，掩码用二进制LED灯样式。
- **音效触发**：`AudioContext` 播放8-bit音效，如掩码合并时的“哔”声。

---

### 核心代码实现
```cpp
// 线段树节点合并
void pushup(int p) {
    seg[p] = seg[lson] | seg[rson]; // 质因子掩码合并
    mul[p] = mul[lson] * mul[rson] % mod; // 乘积合并
}

// 欧拉函数计算
int query(int l, int r) {
    int product = queryMul(l, r); // 区间乘积
    long long mask = queryFac(l, r); // 质因子掩码
    for (int i = 0; i < 60; i++) {
        if (mask & (1LL << i)) {
            product = product * (prime[i]-1) % mod; // 乘以(p-1)
            product = product * invpr[i] % mod;     // 乘以1/p的逆元
        }
    }
    return product;
}
```

---

### 个人心得摘录
> "调试时发现必须用 `1LL<<i` 而非 `1<<i`，否则位掩码会因溢出出错。这种细节在数论题中尤为致命。" —— winxp_qwq

---
处理用时：73.36秒
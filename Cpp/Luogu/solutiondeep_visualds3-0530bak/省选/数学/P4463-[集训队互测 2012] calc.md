# 题目信息

# [集训队互测 2012] calc

## 题目描述

一个序列 $a_1,a_2,\dots,a_n$ 是合法的，当且仅当：

- $a_1,a_2,\dots,a_n$ 都是 $[1,k]$ 中的整数。
- $a_1,a_2,\dots,a_n$ 互不相等。

一个序列的值定义为它里面所有数的乘积，即 $a_1\times a_2\times\dots\times a_n$。

求所有不同合法序列的值的和对 $p$ 取模后的结果。两个序列不同当且仅当他们任意一位不同。

## 说明/提示

【数据范围】

对于 $5\%$ 的数据，$k \le 10$，$n \le 10$。

对于 $20\%$ 的数据，$k \le 1000$，$n \le 20$。

对于 $50\%$ 的数据，$k \le 10^9$，$n \le 20$。

对于 $100\%$ 的数据，$k \le 10 ^ 9$，$n \le 500$，$p \le 10 ^ 9$，保证 $p$ 为素数，保证 $n + 1 < k < p$。

by WJMZBMR
****
$\mathsf i \color{red}\mathsf{ostream}$ 觉得这题数据太弱了，于是他造了个[加强版](https://www.luogu.com.cn/problem/P5850)

## 样例 #1

### 输入

```
9 7 10007```

### 输出

```
3611```

# AI分析结果



**唯一算法分类**  
组合数学

---

**综合分析与结论**  
本题核心是计算合法序列的乘积和，需结合动态规划与多项式插值优化。关键步骤如下：

1. **动态规划建模**  
   - 定义 $f(i,j)$ 为前i个数选值≤j的递增序列乘积和，转移方程：  
     $$f(i,j)=j\cdot f(i-1,j-1)+f(i,j-1)$$  
   - 递增序列转排列需乘 $n!$。

2. **多项式次数证明**  
   - 归纳证明 $f(n,j)$ 是关于j的2n次多项式。差分方程推导显示每次递推次数+2，初始条件为0次，总次数2n。

3. **拉格朗日插值优化**  
   - 计算前2n+1个点值，代入插值公式求f(n,k)。利用连续点优化至O(n)插值。

**可视化设计思路**  
- **DP表格像素动画**：用网格展示f(i,j)的递推，高亮当前计算格及依赖的前驱格。  
- **多项式次数标记**：每次更新j时显示当前多项式次数增长过程。  
- **插值步骤演示**：分步展示基函数构建、乘积计算及最终求和，用颜色区分各点贡献。  
- **8位音效**：转移成功时播放"哔"声，插值完成时用上升音调提示。

---

**题解清单 (4星及以上)**  
1. **GKxx (5星)**  
   - 清晰推导多项式次数，详述插值原理，代码简洁。  
   - 关键点：差分方程分析次数，预处理点值优化。

2. **Log_x (5星)**  
   - 数学归纳法严谨，代码注释详细。  
   - 个人心得：强调有序转无序的阶乘处理。

3. **Rainybunny (4星)**  
   - 结构清晰，代码模块化，适合快速实现。  
   - 优化点：利用连续点插值，减少计算量。

---

**核心代码实现**  
```cpp
int Lagrange(int x) {
    if (x <= 2*n) return f[n][x];
    int res = 0;
    for (int i = 0; i <= 2*n; ++i) {
        ll term = f[n][i];
        for (int j = 0; j <= 2*n; ++j) {
            if (i != j)
                term = term * (x - j) % mod * inv(i - j + mod) % mod;
        }
        res = (res + term) % mod;
    }
    return res;
}
```
**代码思想**：预计算f(n,0~2n)，通过拉格朗日基函数加权求和，模运算处理负数。

---

**相似题目推荐**  
1. [P4593 教科书般的亵渎](https://www.luogu.com.cn/problem/P4593)  
2. [P3270 成绩比较](https://www.luogu.com.cn/problem/P3270)  
3. [P4461 序列统计](https://www.luogu.com.cn/problem/P4461)

---

**可视化示例 (伪代码)**  
```javascript
// Canvas绘制DP表格
function drawDPGrid() {
    ctx.fillStyle = '#8BDBFF'; // 淡蓝背景
    ctx.fillRect(0, 0, width, height);
    for (let i = 0; i <= n; i++) {
        for (let j = 0; j <= 2*n; j++) {
            if (i === currentI && j === currentJ) {
                ctx.fillStyle = '#FF6B6B'; // 高亮当前计算格
                playBeep(); // 音效
            }
            ctx.fillText(f[i][j], j*cellW, i*cellH);
        }
    }
}
```

**复古风格**：16色调色板，像素字体，音效使用Web Audio合成8位方波。

---
处理用时：64.36秒
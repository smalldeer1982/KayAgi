# 题目信息

# [CTSC2018] 假面

## 题目背景


针针是绿绿的好朋友。

## 题目描述

针针喜欢玩一款叫做 DotA (**D**efense **o**f **t**he **A**lgorithm) 的游戏，在这个游戏中，针针会操纵自己的英雄与队友一起对抗另一支队伍。
针针在 DotA 中最喜欢使用的英雄叫做假面（Faceless），该英雄有 $2$ 个技能：

- 锁定：对一名指定的敌方单位使用，以 $p$ 的概率对该单位造成 $1$ 点伤害（使其减少 $1$ 点生命值）。
- 结界：在一片区域施放结界，让该区域内的所有其他单位无法动弹。
在游戏中，如果一个单位的生命值降至 $0$ 或 $0$ 以下，那么该单位就会死亡。

针针操纵假面的水平一般，因此他决定勤加练习。现在有 $n$ 个敌方单位（编号从 $1$ 至 $n$），编号为 $i$ 的敌方单位有 $h_i$ 点生命值。

针针已经安排好了练习的计划，他会按顺序施放 $Q$ 个技能：

- 对于锁定技能：针针会指定一个敌方单位 $id$ ，并对它施放。由于决定概率系数 $p$ 的因素很多，因此每次的 $p$ 都不一定相同。
特别地，如果该敌方单位已经死亡，那么该技能不会造成任何效果。
- 对于结界技能：针针会希望对 $k$ 个指定的敌方单位施放，但由于针针并不擅长施放该技能，因此他只能命中恰好 $1$ 个敌方单位。命中每个存活的敌方单位的概率是相等的（也就是说已经死亡的敌方单位不会有任何影响）。
特别地，如果这 $k$ 个敌方单位均已死亡，那么该技能同样不会命中任何敌方单位。

现在，围观针针进行练习的绿绿想知道：

1. 对于针针施放的每个结界技能，它命中各敌人的概率分别是多少。
2. 在针针的所有技能施放完毕后，所有敌方单位剩余生命值的期望分别是多少。

由于绿绿还要围观针针训练，所以请你帮他解决这两个问题。

为了防止精度误差，对于所有需要输出的数值，请输出其在模 $998244353$ 意义下的值。

由于结界为假面的终极技能，因此针针施放该技能的次数不会太多。具体请见”子任务“。

## 说明/提示

### 样例解释 1
针针按顺序施放如下技能：

1. 对敌方单位 $2$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。此时 $2$ 号敌方单位必定剩余 $1$ 点生命值。
2. 对敌方单位 $2$ 施放技能结界：（由于 $2$ 号敌方单位尚存活，）必定命中 $2$ 号单位。
3. 对敌方单位 $2$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。
4. 对敌方单位 $3$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。此时三个敌方单位的生命值一定分别为 $1, 0 ,2$ ，敌方单位 $2$ 一定死亡。
5. 对敌方单位 $2$ 施放技能结界：（由于 $2$ 号敌方单位已死亡，）必定不命中任何单位。
6. 对敌方单位 $1, 2, 3$ 施放技能结界：命中敌方单位 $1, 3$ 的概率是相等的，即各 $\frac{1}{2}$ 。 最终，三个敌方单位的剩余生命值一定为 $1 , 0 , 2$ 。

### 样例解释 2
对于各结界技能的分析：

1. 第 $1$ 个结界（目标为敌方单位 $1,2$ ）：
- $2$ 号敌方单位存活的概率为 $\frac{1}{2}$ ， $1$ 号敌方单位必定存活。
- 如果 $2$ 号敌方单位存活，那么结界命中 $1 , 2$ 的概率相等，均为 $\frac{1}{2}$ ；如果 $2$ 号敌方单位死亡，那么结界必定命中 $1$ 号敌方单位。
- 因此：命中 $1$ 号敌方单位的概率为 $\frac{1}{2} \times 1 + \frac{1}{2} \times \frac{1}{2} = \frac{3}{4}$ ；命中 $2$ 号敌方单位的概率为 $\frac{1}{2} \times 0 + \frac{1}{2} \times \frac{1}{2} = \frac{1}{4}$ 。
2. 第 $2$ 个结界（目标为敌方单位 $1, 2, 3$ ）：
- 三个敌方单位存活的概率分别为 $1, \frac{1}{2} , \frac{1}{3}$ 。
- $1 , 2 , 3$ 同时存活的概率为 $\frac{1}{6}$ ；只有 $1, 2$ 存活的概率为 $\frac{1}{3}$ ；只有 $1 , 3$ 存活的概率为 $\frac{1}{6}$ ；只有 $1$ 存活的概率为 $\frac{1}{3}$ 。
- 因此：命中 $1$ 号敌方单位的概率为 $\frac{1}{6} \times \frac{1}{3} + (\frac{1}{3}+\frac{1}{6}) \times \frac{1}{2}+ \frac{1}{3} \times 1 = \frac{23}{36}$ ；命中 $2$ 号敌方单位的概率为 $\frac{1}{6} \times \frac{1}{3} + \frac{1}{3} \times \frac{1}{2} = \frac{2}{9}$ ；命中 $3$ 号敌方单位的概率为 $\frac{1}{6} \times \frac{1}{3} + \frac{1}{6} \times \frac{1}{2} = \frac{5}{36}$ 。 最终，三个敌方单位的剩余生命值的期望值为 $1 , \frac{1}{2} , \frac{1}{3}$ 。


### 数据范围

我们记 $C$ 为结界技能的数量。

测试点编号|n=|Q=|C=|u,v|其他限制
-|-|-|-|-|-
1|5|21|6|u<v|无
2|60|199992|500|u<v|所有 p 均相等
3|60|23|6|u<v|所有m_i =1
4|60|199994|500|u<v|无
5|60|199995|500|u<v|无
6|60|199996|0|u<v|无
7|60|199997|500|u=v|无
8|200|199998|1000|u<v|无
9|200|199999|1000|u<v|无
10|200|200000|1000|u<v|无

对于所有测试点，保证 $n \le 200 , Q \le 200000 , C \le 1000 , m_i \le 100$ 。

提示

Q 的个位可以帮助你快速确定测试点的编号。
测试点顺序可能与难度无关。

感谢 @和泉正宗 提供题面 

## 样例 #1

### 输入

```
3
1 2 3
6
0 2 1 1
1 1 2
0 2 1 1
0 3 1 1
1 1 2
1 3 1 2 3```

### 输出

```
1
0
499122177 0 499122177
1 0 2
```

## 样例 #2

### 输入

```
3
1 1 1
4
0 2 1 2
1 2 1 2
0 3 2 3
1 3 1 2 3```

### 输出

```
249561089 748683265
804141285 887328314 305019108
1 499122177 332748118
```

# AI分析结果



## 算法分类
动态规划（概率DP）

---

## 综合分析与结论

### 核心思路
1. **维护每个单位的存活概率**  
   使用动态规划数组 `f[i][j]` 维护第 `i` 个单位剩余 `j` 点血量的概率，每次锁定操作时更新该数组。
2. **结界技能的概率计算**  
   预处理所有存活单位的存活概率，利用背包模型计算总存活人数概率 `g[j]`，再通过逆操作得到每个单位 `u` 的贡献，最终求出命中概率。

### 解决难点
- **动态规划逆操作**：通过预处理总存活概率 `g`，逆推得到排除某个单位后的存活概率 `h`，将复杂度从 `O(n^3)` 优化到 `O(n^2)`。
- **边界处理**：当存活概率为 1 或 0 时，需特殊处理避免分母为零。

### 可视化设计
1. **动态血条显示**  
   每个单位以像素块表示，颜色深浅表示当前血量概率分布（如红色越深概率越高）。
2. **背包逆操作动画**  
   - 初始展示总存活概率 `g[j]` 的分布柱状图。
   - 选择单位 `u` 后，逐步展示 `h[j] = (g[j] - alive_u * h[j-1]) / dead_u` 的计算过程，高亮当前计算的 `j` 值。
3. **复古像素风格**  
   使用 8-bit 风格界面，技能施放时播放短促音效（如锁定技能命中时的 "beep"，结界技能选中时的 "click"）。
4. **自动演示模式**  
   展示算法如何自动处理多个结界技能，通过 Canvas 网格动态更新 `f` 和 `g` 数组。

---

## 题解清单 (≥4星)

### 1. RabbitHu (5星)
- **亮点**：详细推导动态规划的逆操作，代码高效清晰，预处理与逆推逻辑完整。
- **关键代码**：
  ```cpp
  // 预处理总存活概率 g
  for(int i=1; i<=K; i++)
      for(int j=i; j>=0; j--)
          f[j] = (f[j-1] * alive_i + f[j] * dead_i) % mod;
  
  // 逆推得到 h
  if(dead_u == 0) h[j] = g[j+1];
  else h[j] = (g[j] - alive_u * h[j-1]) * inv_dead % mod;
  ```

### 2. Kelin (4.5星)
- **亮点**：优化逆元计算，利用背包模型简化代码，处理边界条件严谨。
- **心得摘录**：  
  > "预处理逆元避免重复计算，特判 `alive=1` 的情况是调试时的关键。"

### 3. ZCETHAN (4星)
- **亮点**：提供完整代码框架，注释清晰，适合快速理解整体结构。
- **核心片段**：
  ```cpp
  // 处理锁定技能
  f[id][j] = (f[id][j+1] * p + f[id][j] * q) % mod;
  
  // 计算存活概率
  for(int j=0; j<k; j++) 
      ans += h[j] * inv[j+1];
  ```

---

## 最优思路提炼

### 关键技巧
1. **动态维护概率数组**  
   每次锁定操作后，倒序更新 `f[i][j]` 以避免覆盖未计算的值。
2. **背包逆推优化**  
   通过逆操作从总存活概率 `g` 中快速分离出单个单位的贡献，避免重复计算。

### 同类型题套路
- **概率DP优化**：如 [P2473 奖励关](https://www.luogu.com.cn/problem/P2473)，利用状压DP处理概率转移。
- **背包模型逆操作**：如 [P4095 概率充电器](https://www.luogu.com.cn/problem/P4095)，通过树形DP的逆推优化。

---

## 推荐题目
1. **P1850 换教室**：期望DP与概率转移的综合应用。
2. **P2473 奖励关**：状态压缩与概率动态规划。
3. **P6835 概率生成树**：结合图论与概率模型。

---

## 可视化代码片段 (JavaScript)

```javascript
// Canvas 绘制存活概率分布
function drawGraph(ctx, data, color) {
  ctx.clearRect(0, 0, 400, 200);
  data.forEach((val, idx) => {
    ctx.fillStyle = color;
    ctx.fillRect(idx * 30, 200 - val * 100, 25, val * 100);
  });
}

// 背包逆推动画
function reverseStep(g, alive, dead) {
  let h = new Array(g.length).fill(0);
  h[0] = g[0] * inv(dead);
  for (let j = 1; j < g.length; j++) {
    h[j] = (g[j] - alive * h[j-1]) * inv(dead) % MOD;
  }
  return h;
}
```

---

## 复古像素风格设计
- **调色板**：使用 8 位红绿蓝基色，血量条用渐变红色表示。
- **音效触发**：
  - `lock()`：播放 `8-bit 射击音效`。
  - `barrier()`：播放 `选择确认音效`。
- **自动演示**：按空格键启动/暂停，算法步骤以 0.5 秒间隔自动执行。

---
处理用时：72.61秒
# 题目信息

# 【模板】Pollard-Rho

## 题目描述

Miller Rabin 算法是一种高效的质数判断方法。虽然是一种不确定的质数判断法，但是在选择多种底数的情况下，正确率是可以接受的。

Pollard rho 是一个非常玄学的方式，用于在 $O(n^{1/4})$ 的期望时间复杂度内计算合数 $n$ 的某个非平凡因子。事实上算法导论给出的是 $O(\sqrt p)$，$p$ 是 $n$ 的某个最小因子，满足 $p$ 与 $n/p$ 互质。但是这些都是期望，未必符合实际。但事实上 Pollard rho 算法在实际环境中运行的相当不错。

这里我们要写一个程序，对于每个数字检验是否是质数，是质数就输出 `Prime`；如果不是质数，输出它最大的质因子是哪个。

## 说明/提示

2018.8.14 新加数据两组，时限加大到 2s，感谢 @whzzt

2022.12.22 加入新的数据，感谢 @ftt2333 和 Library Checker

by @will7101

## 样例 #1

### 输入

```
6
2
13
134
8897
1234567654321
1000000000000```

### 输出

```
Prime
Prime
67
41
4649
5```

# AI分析结果



**唯一算法分类**：随机化算法

---

### **综合分析与结论**

**核心算法流程**  
Pollard-Rho算法结合**伪随机序列**与**生日悖论**实现快速质因数分解，核心流程分为：  
1. **Miller-Rabin素数检测**：通过固定基底确定性判定小范围质数  
2. **伪随机序列生成**：使用$x_{i+1}=(x_i^2 + c) \bmod n$生成ρ形序列  
3. **路径倍增优化**：累积127次差值后统一求GCD，减少模运算次数  
4. **递归分解因子**：将非质因子拆分为更小质因子求解  

**可视化设计要点**  
- **伪随机序列轨迹**：以像素网格展示ρ形循环结构，高亮当前计算的$x_t$和$x_{2t}$  
- **路径倍增标记**：当累积127次差值时，用闪烁动画表示GCD计算点  
- **因子分解过程**：以树状图动态展示递归分解过程，叶子节点显示质因子  
- **复古音效**：  
  - 发现非平凡因子时播放上升音调  
  - GCD计算失败时用低音提示  
  - 分解完成时播放8-bit胜利音乐  

---

### **题解清单 (≥4星)**

1. **LinearODE (4.5星)**  
   - 亮点：完整推导生日悖论应用，详解Floyd判环与路径倍增优化  
   - 代码片段：  
     ```cpp
     ll PR(ll x){ //路径倍增实现
         ll s=0,t=0,c=rand()%(x-1)+1;
         for(int goal=1;;goal<<=1,s=t){
             ll val=1;
             for(int stp=1;stp<=goal;stp++){
                 t = (mul(t,t,x)+c)%x; //伪随机生成
                 val = mul(val,abs(t-s),x);
                 if(stp%127==0){
                     ll d = gcd(val,x);
                     if(d>1) return d;
                 }
             }
             ll d = gcd(val,x);
             if(d>1) return d;
         }
     }
     ```

2. **warzone (4.2星)**  
   - 亮点：提出确定性Miller-Rabin基底选择，适用于int128范围  
   - 关键代码：  
     ```cpp
     bool is_prime(ll n){ //确定性检验
         const ll base[]={2,325,9375,28178,450775,9780504,1795265022};
         ll d=n-1, s=__builtin_ctzll(d); d>>=s;
         for(auto a:base){
             if(a>=n) continue;
             ll t=qpow(a,d,n);
             if(t==1||t==n-1) continue;
             for(int i=1;i<s && t!=n-1;i++){
                 t=mul(t,t,n);
                 if(t==1) return false;
             }
             if(t!=n-1) return false;
         }
         return true;
     }
     ```

3. **Piwry (4.0星)**  
   - 亮点：实现高效gcd优化，通过位运算加速因子计算  
   - 代码亮点：  
     ```cpp
     ll gcd(ll a,ll b){ //二进制gcd优化
         if(!a||!b) return a|b;
         int shift=__builtin_ctzll(a|b);
         a>>=__builtin_ctzll(a);
         do{
             b>>=__builtin_ctzll(b);
             if(a>b) swap(a,b);
             b-=a;
         }while(b);
         return a<<shift;
     }
     ```

---

### **最优思路与技巧**

1. **确定性Miller-Rabin基底**  
   - 针对$2^{64}$范围选择特定基底，避免随机化错误  
   - 实践：使用`{2,325,9375,28178,450775,9780504,1795265022}`7个基底

2. **路径倍增优化**  
   - 累积127次差值乘积后求GCD，减少模运算次数  
   - 实现：每生成127个随机数统一计算，平衡效率与准确性

3. **伪随机数生成器设计**  
   - 使用$x^2+c$避免循环过早闭合  
   - 关键参数：初始值$x_0=2$, $c$取非0/1随机数

---

### **同类型题与扩展**

1. **质因数分解扩展**  
   - 通用解法：Miller-Rabin判质 → Pollard-Rho找因子 → 递归分解  
   - 适用场景：RSA加密破解、组合数学质因数统计

2. **相似算法套路**  
   - **随机化哈希**：Bloom Filter中的多哈希函数设计  
   - **概率判重**：HyperLogLog基数估计的位模式观察

---

### **推荐练习题**
1. **P1075** 质因数分解（基础试除法应用）  
2. **P3847** 调整队形（随机化贪心算法）  
3. **P4139** 上帝与集合的正确用法（欧拉定理+质因数分解）

---

### **调试心得摘录**
> "实现时发现__int128乘法溢出问题，改用`(1LL*a*b)%n`在n较小时会出错，最终采用`(lll)a*b%n`显式转换"  
> ——作者LinearODE的调试笔记

> "路径倍增参数选择时，127次累积在i7-9700K上达到最佳时间平衡"  
> ——作者Piwry的性能测试结论

---

### **算法可视化示例（伪代码）**
```javascript
// Canvas绘制ρ形路径
function drawRhoPath(c, x0) {
  let x = x0, visited = new Set();
  while(!visited.has(x)) {
    visited.add(x);
    let next = (x*x + c) % n;
    drawArrow(x, next); //绘制箭头
    x = next;
  }
  highlightCycle(x); //红色标记循环节
}

// 执行单步时触发音效
function stepSound() {
  playBeep(800 + stepCount*10, 50); //频率渐高的提示音
}
```

---
处理用时：78.05秒
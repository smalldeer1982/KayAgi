# 题目信息

# [集训队作业2013] 城市规划

## 题目描述

刚刚解决完电力网络的问题，阿狸又被领导的任务给难住了。

刚才说过，阿狸的国家有 $n$ 个城市，现在国家需要在某些城市对之间建立一些贸易路线，使得整个国家的任意两个城市都直接或间接的连通。

为了省钱, 每两个城市之间最多只能有一条直接的贸易路径。对于两个建立路线的方案，如果存在一个城市对，在两个方案中是否建立路线不一样，那么这两个方案就是不同的，否则就是相同的。现在你需要求出一共有多少不同的方案。

好了，这就是困扰阿狸的问题。换句话说，你需要求出 $n$ 个点的简单 (无重边无自环) 有标号无向连通图数目。

由于这个数字可能非常大, 你只需要输出方案数对 $1004535809$ ( $479 \times 2 ^{21} + 1$ ) 取模即可。

## 说明/提示

【数据范围】   
对于 $20\%$ 的数据，$n \le 10$    
对于 $40\%$ 的数据，$n \le 1000$     
对于 $60\%$ 的数据，$n \le 30000$    
对于 $80\%$ 的数据，$n \le 60000$     
对于 $100\%$ 的数据，$n \le 130000$   

试题来源：$2013$ 中国国家集训队第二次作业

## 样例 #1

### 输入

```
3```

### 输出

```
4```

## 样例 #2

### 输入

```
4```

### 输出

```
38```

## 样例 #3

### 输入

```
100000```

### 输出

```
829847355
```

# AI分析结果



---

# 城市规划题解分析

## 算法分类
**生成函数与多项式求逆**

## 题解思路与算法要点

### 核心思路
题目要求计算n个点的有标号无向连通图数目。核心思路是将问题转化为生成函数形式，通过多项式运算求解：
1. **定义**：设`g[n]`为n个点所有无向图的数量，`f[n]`为连通图的数量。易得`g[n] = 2^(C(n,2))`。
2. **递推关系**：通过枚举1号点所在连通块大小，得到递推式`g[n] = Σ C(n-1,i-1)*f[i]*g[n-i]`。
3. **生成函数转换**：将递推式转化为生成函数形式`H(x) = F(x)*G(x)`，其中`H`和`G`分别对应不同生成函数。
4. **多项式求逆**：求解`F(x) = H(x)*G^{-1}(x)`，提取系数得到`f[n]`。

### 解决难点
- **生成函数构造**：正确推导生成函数的系数形式（如`G(x)`的系数为`g[i]/i!`）。
- **多项式求逆**：高效实现大模数下的多项式逆元计算，需结合快速数论变换（NTT）优化。

## 题解评分
| 题解作者       | 评分 | 亮点                                                         |
| -------------- | ---- | ------------------------------------------------------------ |
| Kinandra       | ★★★★ | 清晰的生成函数推导，完整的多项式求逆实现                     |
| w33z8kqrqk8zzzx33 | ★★★★ | 简洁的多项式对数方法，代码量少                               |
| EnofTaiPeople  | ★★★★ | 分治FFT与生成函数双视角解析，适合不同基础读者                 |

## 最优思路提炼
**关键步骤**：
1. **预处理阶乘与逆元**：快速计算组合数分母项。
2. **生成函数构建**：`G(x) = Σ (2^C(i,2)/i!)x^i`，`H(x) = Σ (2^C(i,2)/(i-1)!)x^i`。
3. **多项式求逆**：利用分治+NTT计算`G^{-1}(x)`。
4. **卷积运算**：将`H`与`G^{-1}`卷积，提取`F[n]`项并乘以`(n-1)!`得到结果。

**代码实现**：
```cpp
#include <iostream>
#define mod 1004535809
using namespace std;

typedef long long ll;
const int N = 1e5 + 5, L = 1 << 18;
ll inv[N], fac[N], finv[N], g[L], h[L], G_inv[L];

ll qpow(ll a, ll b) {
    ll res = 1;
    for (; b; b >>= 1, a = a * a % mod)
        if (b & 1) res = res * a % mod;
    return res;
}

void NTT(ll *a, int lim, int type) {
    // NTT实现（省略位逆序操作）
}

void poly_inv(ll *a, ll *b, int n) {
    if (n == 1) { b[0] = qpow(a[0], mod-2); return; }
    poly_inv(a, b, (n+1)/2);
    int lim = 1; while (lim < n*2) lim <<= 1;
    // NTT计算逆多项式（省略详细步骤）
}

int main() {
    int n; cin >> n;
    fac[0] = 1;
    for (int i=1; i<=n; ++i) {
        fac[i] = fac[i-1] * i % mod;
        g[i] = qpow(2, 1ll*i*(i-1)/2 % (mod-1)) * qpow(fac[i], mod-2) % mod;
        h[i] = g[i] * fac[i-1] % mod;
    }
    poly_inv(g, G_inv, n+1);
    // 多项式乘法计算F = H * G_inv
    ll ans = F[n] * fac[n-1] % mod;
    cout << ans;
}
```

## 同类题目推荐
1. **P4721** 分治FFT模板
2. **P4238** 多项式乘法逆元
3. **P4843** 生成函数应用进阶

## 可视化设计
**动画方案**：
1. **生成函数构建**：动态展示`g[i]`计算过程，用不同颜色区分阶乘和指数部分。
2. **多项式求逆**：分治过程可视化，递归步骤用树状结构展示，NTT变换用频谱图表示。
3. **卷积操作**：滑动窗口演示多项式乘法的蝴蝶操作，高亮关键系数变化。

**复古像素风格**：
- **调色板**：16色模式，用亮绿色表示有效数据，红色表示当前操作位置。
- **音效**：NTT变换步骤触发8-bit音效，成功计算时播放经典马里奥过关音效。

## 核心算法流程
1. **预处理**：计算阶乘、逆元、g数组（O(n)）
2. **生成函数初始化**：填充G和H系数（O(n)）
3. **多项式求逆**：分治+NTT（O(n log n)）
4. **卷积运算**：NTT加速乘法（O(n log n)）
5. **结果提取**：F[n] * (n-1)!（O(1)）

该方案完美结合数学推导与高效算法实现，适合处理大规模数据。

---
处理用时：106.86秒
# 题目信息

# LJJ爱数数

## 题目背景

题解请查看 <https://www.cnblogs.com/Blog-of-Eden/p/9367521.html>。

## 题目描述

PJY 某次翻阅杂志时，看到一道题：

求出所有的 **正整数** 三元组 $(a,b,c)$，满足 $a,b,c \leq n$，**$\bold{a,b,c}$ 三个数的最大公约数为 $\bold{1}$**，且 **$\bold{\frac{1}{a}+\frac{1}{b}=\frac{1}{c}}$**。

PJY 嫌这道题太水，于是把它甩给了爱数数的 LJJ，并加上了数据范围 $\bold{n \leq 10^{12}}$，让 LJJ 数出 **有多少组满足条件的三元组 $\bold{(a,b,c)}$**
（注意当 $a \not= b$ 时，$(a,b,c)$ 和 $(b,a,c)$ 是不同的三元组，要算两次）

LJJ 数到一半，发现这个数量太大了，于是他把问题抛给了你。请你输出这个数量。

## 说明/提示

对于 $20\%$ 的数据，$n \leq 2 \times 10^{3}$。

对于 $40\%$ 的数据，$n \leq 10^{5}$。

对于 $60\%$ 的数据，$n \leq 10^{7}$。

对于 $80\%$ 的数据，$n \leq 10^{9}$。

对于 $100\%$ 的数据，$n \leq 10^{12}$。

## 样例 #1

### 输入

```
10```

### 输出

```
3```

## 样例 #2

### 输入

```
100```

### 输出

```
43```

## 样例 #3

### 输入

```
100000```

### 输出

```
42139
```

# AI分析结果



## 算法分类
**数论与莫比乌斯反演**

---

## 题解思路与解决难点

### 核心推导
1. **等式变形**：将原式 $\frac{1}{a} + \frac{1}{b} = \frac{1}{c}$ 变形为 $(a-c)(b-c) = c^2$，引入变量替换 $a-c = x^2$，$b-c = y^2$，$c = xy$，得到 $a = x(x+y)$，$b = y(x+y)$，$c = xy$。
2. **互质条件**：$a, b, c$ 互质等价于 $x$ 和 $y$ 互质，且 $x, y$ 的取值需满足 $x^2 + xy \leq n$ 和 $y^2 + xy \leq n$。

### 关键变量与范围
- **变量范围**：$x \leq \sqrt{n}$，$y \leq \min\left(\frac{n}{x} - x, \frac{-x + \sqrt{x^2 + 4n}}{2}\right)$。
- **莫比乌斯反演**：统计每个 $x$ 对应的合法 $y$ 数（与 $x$ 互质），利用 $\sum_{d | x} \mu(d) \cdot \lfloor \frac{\text{上限}}{d} \rfloor$ 快速计算。

### 难点解决
1. **高效枚举**：预处理莫比乌斯函数，通过枚举因数 $d$ 及其倍数，将时间复杂度优化至 $O(\sqrt{n} \log \sqrt{n})$。
2. **边界处理**：精确计算 $y$ 的上界，避免冗余枚举。

---

## 题解评分 (≥4星)

1. **作者：lnzwz (★★★★★)**
   - **亮点**：代码简洁高效，预处理莫比乌斯函数后直接分块累加贡献，时间复杂度最优。
   - **代码片段**：
     ```cpp
     for (int i = 1; i <= m; i++) {
         if (u[i]) {
             for (int j = i; j <= m; j += i)
                 ans += u[i] * (R[j] / i);
         }
     }
     ```

2. **作者：滑大稽 (★★★★☆)**
   - **亮点**：详细推导变量替换过程，代码实现清晰，注释丰富。
   - **关键步骤**：预处理 $r(x)$ 并利用莫比乌斯函数累加贡献。

3. **作者：Ynoi (★★★★☆)**
   - **亮点**：深入分析变量替换后的互质条件，结合初三数学推导 $y$ 的范围。

---

## 最优思路提炼

1. **变量替换与互质条件**：通过 $x^2$ 和 $y^2$ 替换，将原问题转化为互质对的统计。
2. **莫比乌斯反演加速**：利用 $\mu(d)$ 的容斥性质，快速统计区间内与 $x$ 互质的 $y$ 数量。
3. **边界精确计算**：结合二次方程和不等式分析 $y$ 的上界，避免无效枚举。

---

## 类似题目推荐

1. **P2303 [SDOI2012] Longge 的问题**  
   （利用数论分块与欧拉函数统计互质对数）

2. **P2527 [SHOI2001] 小约翰的游戏**  
   （涉及分数等式变形与互质条件分析）

3. **P5261 建数字**  
   （莫比乌斯反演处理区间内互质数对）

---

## 可视化与算法演示

### 动画设计
1. **像素网格展示**：在 Canvas 上绘制 $x$ 和 $y$ 的二维网格，合法对 $(x, y)$ 显示为绿色方块，互质对高亮为金色。
2. **步进控制**：单步执行每个 $x$ 的枚举，动态显示当前 $x$ 和对应的 $y$ 范围。
3. **音效提示**：发现合法对时播放短促“叮”声，互质对播放上扬音效。

### 复古风格实现
- **8位像素调色板**：使用经典 FC 游戏的 16 色方案（如绿色、金色、灰色）。
- **自动演示模式**：算法自动运行，展示 $x$ 从 1 到 $\sqrt{n}$ 的枚举过程，高亮当前处理的 $x$ 和对应的 $y$ 范围。
- **控制面板**：允许暂停/继续，调节动画速度，显示当前统计的互质对数。

---

## 核心代码实现

```cpp
#include <stdio.h>
#define ll long long
ll R[1000010];
int sa[1000010], ss[1000010], u[1000010], sl = 0;

void getu(int n) {
    u[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!sa[i]) {
            ss[sl++] = i;
            u[i] = -1;
        }
        for (int j = 0; j < sl && i * ss[j] <= n; j++) {
            sa[i * ss[j]] = 1;
            if (i % ss[j] == 0) {
                u[i * ss[j]] = 0;
                break;
            }
            u[i * ss[j]] = -u[i];
        }
    }
}

int main() {
    ll n, ans = 0; int m = 0;
    scanf("%lld", &n);
    for (int i = 1; i <= n; i++) {
        R[i] = n / i - i;
        if (i - 1 < R[i]) R[i] = i - 1;
        if (R[i] <= 0) break;
        m = i;
    }
    getu(m);
    for (int i = 1; i <= m; i++) {
        if (u[i]) {
            for (int j = i; j <= m; j += i)
                ans += u[i] * (R[j] / i);
        }
    }
    printf("%lld", ans * 2);
    return 0;
}
```

---

## 个人心得

- **调试教训**：在计算 $y$ 的上界时，需同时考虑多个不等式，初始实现漏掉 $\frac{-x + \sqrt{x^2 + 4n}}{2}$ 导致部分测试点错误。
- **思维突破**：通过变量替换将原问题转化为互质对统计，是数论题的经典思路，需熟练掌握因式分解与莫比乌斯反演的结合应用。

---
处理用时：81.62秒
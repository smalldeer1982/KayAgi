# 题目信息

# [NOIP 2018 提高组] 填数游戏

## 题目背景

NOIP2018 提高组 D2T2

## 题目描述

小 D 特别喜欢玩游戏。这一天，他在玩一款填数游戏。
  
这个填数游戏的棋盘是一个 $n \times m$ 的矩形表格。玩家需要在表格的每个格子中填入一个数字（数字 $0$ 或者数字 $1$），填数时需要满足一些限制。   

下面我们来具体描述这些限制。   

为了方便描述，我们先给出一些定义： 
 
-  我们用每个格子的行列坐标来表示一个格子，即（行坐标，列坐标）。注意：行列坐标均从 $0$ 开始编号。
- 合法路径 $P$：一条路径是合法的当且仅当：   
    1. 这条路径从矩形表格的左上角的格子 $(0,0)$ 出发，到矩形的右下角格子 $(n - 1,m - 1)$ 结束；   
    2. 在这条路径中，每次只能从当前的格子移动到右边与它相邻的格子，或者从当前格子移动到下面与它相邻的格子。
    
  例如：在下面这个矩形中，只有两条路径是合法的，它们分别是 $P_1$：$(0,0)\to (0,1)\to (1,1)$ 和 $P_2$：$(0,0) \to (1,0) \to (1,1)$。
   
![](https://cdn.luogu.com.cn/upload/pic/43256.png)  

对于一条合法的路径 $P$，我们可以用一个字符串 $w(P)$ 来表示，该字符串的长度为 $n + m - 2$，其中只包含字符 $\texttt R$ 或者字符 $\texttt D$，第 $i$ 个字符记录了路径 $P$ 中第 $i$ 步的移动方法。$\texttt R$ 表示移动到当前格子右边与它相邻的格子，$\texttt D$ 表示移动到当前格子下面与它相邻的格子。例如，上图中对于路径 $P_1$，有 $w(P_1) = \texttt {RD}$；而对于另一条路径 $P_2$，有 $w(P_2) = \texttt {DR}$。   

同时，将每条合法路径 $P$ 经过的每个格子上填入的数字依次连接后，会得到一个长度为 $n + m - 1$ 的 $01$ 字符串，记为 $s(P)$。例如，如果我们在格子 $(0,0)$ 和 $(1,0)$ 上填入数字 $0$，在格子 $(0,1)$ 和 $(1,1)$ 上填入数字 $1$（见上图红色数字），那么对于路径 $P_1$，我们可以得到 $s(P_1) = 011$，对于路径 $P_2$，有 $s(P_2) = 001$。 

游戏要求小 D 找到一种填数字 $0$、$1$ 的方法，使得对于两条路径 $P_1$，$P_2$，如果 $w(P_1) > w(P_2)$，那么必须 $s(P_1) ≤ s(P_2)$。我们说字符串 $a$ 比字符串 $b$ 小，当且仅当字符串 $a$ 的字典序小于字符串 $b$ 的字典序，字典序的定义详见第一题。但是仅仅是找一种方法无法满足小 D 的好奇心，小 D 更想知道这个游戏有多少种玩法，也就是说，有多少种填数字的方法满足游戏的要求？ 

小 D 能力有限，希望你帮助他解决这个问题，即有多少种填 $0$、$1$ 的方法能满足题目要求。由于答案可能很大，你需要输出答案对 $10^9 + 7$ 取模的结果。 

## 说明/提示

**样例解释**  

![](https://cdn.luogu.com.cn/upload/pic/43257.png)  

**数据规模与约定** 

| 测试点编号 | $n\le$ | $m\le$ |
| :-----------: | :-----------: | :-----------: |
| $1\sim 4$ | $3$ | $3$ |
| $5\sim 10$ | $2$ | $10^6$ |
| $11\sim 13$ | $3$ | $10^6$ |
| $14\sim 16$ | $8$ | $8$ |
| $17\sim 20$ | $8$ | $10^6$ |


## 样例 #1

### 输入

```
2 2```

### 输出

```
12```

## 样例 #2

### 输入

```
3 3```

### 输出

```
112```

## 样例 #3

### 输入

```
5 5```

### 输出

```
7136```

# AI分析结果



### 算法分类：数学推导与递推规律

### 题解思路与核心难点
1. **性质推导**  
   - 每条对角线上的数字必须非递增（右上方≤左下方）  
   - 若相邻两格值相等，其右下子矩阵的对角线必须全相同  
2. **递推规律**  
   - 当 `n ≥ 4` 且 `m ≥ n+1` 时，`Ans(n, m+1) = 3 * Ans(n, m)`  
   - 利用对称性 `Ans(n, m) = Ans(m, n)`  
3. **分情况处理**  
   - `n=1`：直接计算 `2^m`  
   - `n=2`：公式为 `4*3^(m-1)`  
   - `n=3`：公式为 `112*3^(m-3)`  
   - `n≥4` 且 `m>n`：转化为 `Ans(n, n+1)*3^(m-n-1)`  

### 题解评分（≥4星）
1. **xenonex（★★★★★）**  
   - 通过严谨的数学证明推导出递推公式  
   - 代码简洁，直接按公式分类计算  
2. **Froggy（★★★★☆）**  
   - 暴力打表找规律，快速幂实现高效计算  
   - 代码简洁易懂，适合快速应用  
3. **Hope2075（★★★★）**  
   - 基于性质剪枝的暴力搜索，逻辑清晰  
   - 给出分阶段状态转移思路  

### 最优思路提炼
1. **关键递推式**  
   ```python
   if n >=4 and m > n+1:  
       Ans(n,m) = Ans(n,n+1) * 3^(m-n-1)  
   ```
2. **快速幂优化**  
   利用快速幂处理大指数计算：  
   ```cpp
   LL ksm(LL a, LL b) {  
       LL r=1;  
       for(;b; a=a*a%mod, b>>=1)  
           if(b&1) r=r*a%mod;  
       return r;  
   }  
   ```

### 类似题目推荐
1. [P1092 骨牌铺法](https://www.luogu.com.cn/problem/P1092)  
   - 递推规律与矩阵覆盖问题  
2. [P1436 棋盘分割](https://www.luogu.com.cn/problem/P1436)  
   - 分块递推与状态压缩  
3. [P3195 玩具装箱](https://www.luogu.com.cn/problem/P3195)  
   - 斜率优化与递推公式推导  

### 核心代码实现
```cpp
#include <cstdio>
#define mod 1000000007
typedef long long LL;

inline LL ksm(LL a, LL b) {
    LL r = 1;
    for (; b; a = a * a % mod, b >>= 1)
        if (b & 1) r = r * a % mod;
    return r;
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    if (n > m) n ^= m ^= n ^= m; // 保证n <= m
    if (n == 1) printf("%lld", ksm(2, m));
    else if (n == 2) printf("%lld", 4 * ksm(3, m-1) % mod);
    else if (n == 3) printf("%lld", 112 * ksm(3, m-3) % mod);
    else {
        if (m == n) printf("%lld", (83*ksm(8,n) + 5*ksm(2,n+7))%mod * 570312504 % mod);
        else printf("%lld", (83*ksm(8,n) + ksm(2,n+8)) % mod * ksm(3,m-n-1) % mod * 570312504 % mod);
    }
    return 0;
}
```

### 可视化设计思路
1. **像素动画**  
   - 用8位风格绘制网格，对角线用不同颜色标记  
   - 高亮当前处理的对角线，显示数字填充方向（从右上到左下递减）  
2. **音效触发**  
   - 每次填充对角线时播放“滴”声  
   - 发现递推规律时播放上升音调  
3. **自动演示模式**  
   - 逐步显示递推过程：从 `n=2` 到 `n=8` 的表格生成  
   - 用箭头指示当前计算的网格区域  

### 复古像素动画示例（伪代码）
```javascript
// Canvas绘制函数
function drawGrid(n, m) {
    ctx.fillStyle = "#000";
    for (let i=0; i<n; i++) {
        for (let j=0; j<m; j++) {
            ctx.fillRect(j*20+50, i*20+50, 18, 18);
            if (i>0 && j<m-1) {
                // 绘制对角线箭头
                if (grid[i][j] == grid[i-1][j+1]) {
                    ctx.fillStyle = "#F00";
                    drawArrow(j*20+60, i*20+40);
                }
            }
        }
    }
}

// 音效触发
function playBeep() {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(440, audioCtx.currentTime);
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

---
处理用时：68.28秒
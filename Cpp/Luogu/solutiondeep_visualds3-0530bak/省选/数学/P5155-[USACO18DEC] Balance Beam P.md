# 题目信息

# [USACO18DEC] Balance Beam P

## 题目描述

Bessie为了存钱给她的牛棚新建一间隔间，开始在当地的马戏团里表演，通过在平衡木上小心地来回走动来展示她卓越的平衡能力。

Bessie能够通过表演赚到的钱取决于她最终成功跳下平衡木的位置。平衡木上从左向右的位置记为 $ 0,1,\ldots,N+1 $ 。如果Bessie到达了位置 $ 0 $ 或是 $ N+1 $ ，她就会从平衡木的一端掉下去，遗憾地得不到报酬。

如果Bessie处在一个给定的位置 $ k $ ，她可以进行下面两项中的任意一项：

1. 投掷一枚硬币。如果背面朝上，她前往位置 $ k-1 $ ，如果正面朝上，她前往位置 $ k+1 $ （也就是说，每种可能性 $ 1/2 $ 的概率）。

2. 跳下平衡木，获得 $ f(k) $ 的报酬（ $ 0 \leq f(k) \leq 10^9 $ ）。

Bessie意识到她并不能保证结果能够得到某一特定数量的报酬，这是由于她的移动是由随机的掷硬币结果控制。然而，基于她的起始位置，她想要求出当她进行一系列最优的决定之后，她能够得到的期望报酬（“最优”指的是这些决定能够带来最高可能的期望报酬）。

例如，如果她的策略能够使她以 $ 1/2 $ 的概率获得 $ 10 $ 的报酬，$ 1/4 $ 的概率获得 $ 8 $ 的报酬，$ 1/4 $ 的概率获得 $ 0 $ 的报酬，那么她的期望报酬为加权平均值 $ 10 \times (1/2)+8 \times (1/4)+0 \times (1/4)=7 $ 。

## 样例 #1

### 输入

```
2
1
3```

### 输出

```
150000
300000
```

# AI分析结果



## 算法分类
**凸包/贪心**

---

## 综合分析与结论

### 核心思路
所有题解的核心思路是将最优策略转化为几何凸包问题：
1. **停止点性质**：当某点移动后的期望收益比直接停止更高时，该点不停止；否则成为停止点。
2. **凸包结构**：停止点构成的几何图形必然是给定点集的上凸包，保证任意中间点的移动期望不超过其两侧凸包点的线性插值。
3. **线性计算**：对每个点，找到凸包上左右相邻的停止点，用线性插值公式计算期望收益。

### 解决难点
- **停止点推导**：通过概率论中的随机游走模型（到达两端概率呈线性关系）与凸包性质的反证法，证明最优策略对应的几何结构必须是上凸包。
- **高效构建凸包**：使用单调栈在 O(n) 时间内维护上凸包结构，避免暴力枚举所有可能的停止点组合。

### 可视化设计
1. **动画方案**：
   - **坐标系展示**：绘制所有点 (i, f[i])，动态显示凸包构建过程（栈的压入弹出）。
   - **当前点高亮**：用不同颜色标记正在处理的点，红色表示当前点，绿色表示凸包上的关键点。
   - **插值线段**：当处理第 i 个点时，绘制其对应的凸包左右相邻点连线，并显示交点处的期望值计算过程。

2. **像素风格实现**：
   - **Canvas 网格**：将每个点映射到像素网格中，凸包线段用 8-bit 风格的粗线条渲染。
   - **音效触发**：在凸包点压栈时播放“点击”音效，弹出时播放“错误”音效，计算期望时播放成功音效。
   - **自动演示**：模拟算法执行流程，按步骤展示凸包构建与查询过程，支持暂停/步进。

---

## 题解清单（≥4星）

### 1. Mirach（5星）
- **亮点**：详细推导停止点与凸包的数学关系，代码简洁高效。
- **代码关键**：单调栈维护上凸包，插值计算避免浮点误差。
- **核心代码**：
  ```cpp
  void push(vec p) {
    while(tp && (p-st[tp])*(st[tp]-st[tp-1]) <= 0) --tp;
    st[++tp] = p;
  }
  ```

### 2. CXY07（4星）
- **亮点**：动态规划视角转换为凸包问题，代码结构清晰。
- **代码关键**：显式处理边界点 (0,0) 和 (n+1,0)，确保凸包闭合。
  ```cpp
  for(int i = 0; i <= n + 1; ++i) {
    while(top > 1 && slope(...)) --top;
    stk[++top] = i;
  }
  ```

### 3. AzusaCat（4星）
- **亮点**：数学归纳法证明凸包唯一性，处理高精度计算。
- **代码关键**：使用 `__int128` 避免精度丢失，线性扫描凸包点。
  ```cpp
  while(q[now+1] <= i) now++;
  write((q[now+1]-i)*a[q[now]] + (i-q[now])*a[q[now+1]] / (q[now+1]-q[now]));
  ```

---

## 最优思路提炼

### 关键技巧
1. **凸包转换**：将动态决策问题转化为几何凸包问题，利用凸性的数学性质保证最优解。
2. **线性期望计算**：对于非凸包点，其最优期望等于左右凸包点的线性插值，公式为：
   $$E(i) = \frac{(i-a)f(b) + (b-i)f(a)}{b-a}$$
3. **单调栈维护**：O(n) 时间构建上凸包，通过叉积判断点的凹凸性。

### 实现要点
- **数据结构**：使用数组模拟栈存储凸包点。
- **避免浮点**：全程整数运算，最后除法转换为乘法逆元或保留分数形式。
- **边界处理**：显式添加位置 0 和 n+1 的虚拟点，确保凸包覆盖整个数轴。

---

## 类似题目推荐
1. **P3199 最小圈**：分数规划与凸包思想的结合应用。
2. **P3620 数据备份**：贪心策略维护凸性结构。
3. **P3513 多维凸包**：扩展凸包问题到高维空间。

---

## 代码片段（凸包构建）
```cpp
// 维护上凸包的核心代码（Mirach 题解）
struct vec { int x; ll y; };
vector<vec> st;

void push(vec p) {
    while (st.size() >= 2) {
        vec a = st[st.size()-2], b = st.back();
        if ((p - b) * (b - a) <= 0) st.pop_back();
        else break;
    }
    st.push_back(p);
}

// 查询处理
for (int i = 1, j = 0; i <= n; ++i) {
    while (st[j+1].x <= i) ++j;
    if (st[j].x == i) printf("%lld\n", st[j].y);
    else {
        ll a = st[j].x, b = st[j+1].x;
        ll ans = ((b - i)*st[j].y + (i - a)*st[j+1].y) / (b - a); 
        printf("%lld\n", ans);
    }
}
```

---

## 可视化实现思路
1. **Canvas 绘制**：
   - **坐标映射**：将 i 映射为 x 轴，f[i] 缩放至画布高度。
   - **动态凸包**：红色线段表示当前处理的点，绿色线段表示已构建的凸包。
2. **音效设计**：
   - 添加点时播放 `beep.mp3`（8-bit 短音）。
   - 弹出栈时播放 `error.wav`（低沉提示音）。
3. **自动模式**：
   - 按固定时间间隔执行算法步骤，用 `requestAnimationFrame` 控制流程。
   - 提供速度滑块调节演示速度（0.5x~5x）。

---

通过将抽象的最优策略问题转化为直观的几何结构，结合高效的凸包算法，本问题的求解过程展现了数学建模与算法设计的精妙结合。

---
处理用时：72.99秒
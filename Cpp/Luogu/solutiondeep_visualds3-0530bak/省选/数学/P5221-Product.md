# 题目信息

# Product

## 题目背景

${\rm CYJian}$："听说$gcd$和$\sum$套起来比较好玩？？那我就......"

## 题目描述

${\rm CYJian}$最近闲的玩起了$gcd$。。他想到了一个非常简单而有意思的式子：

$$\prod_{i=1}^N\prod_{j=1}^N\frac{lcm(i,j)}{gcd(i,j)}\ (\bmod\ 104857601)$$

${\rm CYJian}$已经算出来这个式子的值了。现在请你帮他验算一下吧。${\rm CYJian}$只给你$0.2s$的时间哦。

2024.5.11 upd: 放宽时空限制。

## 说明/提示

样例解释：

|$\frac{lcm}{gcd}$|1|2|3|4|5|
|:--:|:--:|:--:|:--:|:--:|:--:|
|**1**|1|2|3|4|5|
|**2**|2|1|6|2|10|
|**3**|3|6|1|12|15|
|**4**|4|2|12|1|20|
|**5**|5|10|15|20|1|

对于$30\%$的数据：$1 \leq N \leq 5000$

对于$100\%$的数据：$1 \leq N \leq 1000000$

## 样例 #1

### 输入

```
5
```

### 输出

```
585494
```

# AI分析结果



# 算法分类
**数论（欧拉函数与莫比乌斯反演）**

---

## 综合分析与结论
### 核心思路
1. **分子处理**：  
   $$\prod_{i=1}^N\prod_{j=1}^N ij = (N!)^{2N}$$  
   直接通过阶乘快速幂计算。

2. **分母处理**：  
   $$\prod_{i=1}^N\prod_{j=1}^N \gcd(i,j)^2 = \prod_{d=1}^N d^{2\sum_{k=1}^{\lfloor N/d \rfloor} \phi(k)-1}$$  
   使用欧拉函数统计每个d的贡献次数，通过线性筛预处理欧拉函数前缀和，结合模数的欧拉定理优化指数计算。

### 难点对比
| 题解方法 | 核心优化 | 时间复杂度 | 空间优化 |
|---------|---------|------------|----------|
| 欧拉函数前缀和 | 预处理欧拉函数+分块 | O(n) | 利用模数性质避免long long |
| 莫比乌斯反演 | 两次整除分块 | O(n) | 尺取法避免阶乘数组 |
| 质因数分解 | 枚举质数的幂次 | O(n log n) | 动态统计质数贡献 |

---

## 题解评分（≥4星）
### 1. Nemlit（⭐⭐⭐⭐⭐）
- **思路清晰**：详细推导公式，结合欧拉函数前缀和。
- **代码简洁**：线性筛预处理+快速幂优化。
- **关键代码**：
```cpp
int sum[x] = ∑φ(i)  
for(d=1 to n) ans *= d^(2*sum[n/d]-1)
```

### 2. AThousandSuns（⭐⭐⭐⭐）
- **优化亮点**：双重整除分块+尺取法动态计算阶乘。
- **实现技巧**：通过指针移动避免存储阶乘数组，空间复杂度优化显著。

### 3. Soulist（⭐⭐⭐⭐）
- **空间优化**：用前缀和代替数组，通过分块减少计算量。
- **核心代码**：
```cpp
for(int i=2; i<=n; i<<=1) 
    ans *= floor(n/i)!^(4φ(i))
```

---

## 最优思路提炼
### 关键步骤
1. **分子计算**：  
   $$(n!)^{2n} \mod p$$  
   预处理阶乘后直接快速幂。

2. **分母计算**：  
   - 线性筛预处理欧拉函数φ(i)  
   - 计算前缀和sum[d] = ∑φ(1..d)  
   - 对每个d求指数：`2*sum[n/d] - 1`  
   - 最终分母为：`∏d^(指数)`

### 代码实现
```cpp
int main() {
    // 预处理欧拉函数
    phi[1] = 1;
    for(int i=2; i<=n; i++) {
        if(!vis[i]) prime[++cnt]=i, phi[i]=i-1;
        // 线性筛更新phi
    }
    // 计算前缀和
    for(int i=1; i<=n; i++) sum_phi[i] = (sum_phi[i-1] + phi[i]) % (mod-1);
    
    // 分子
    int numerator = pow(factorial(n), 2*n % (mod-1));
    
    // 分母
    int denominator = 1;
    for(int d=1; d<=n; d++) {
        int exponent = (2 * sum_phi[n/d] - 1) % (mod-1);
        denominator = (denominator * pow(d, exponent)) % mod;
    }
    
    // 最终结果
    int ans = numerator * pow(denominator, mod-2) % mod;
}
```

---

## 类似题目推荐
1. **P2158 [SDOI2008] 仪仗队**  
   - 核心：欧拉函数求互质点对
2. **P2522 [HAOI2011] Problem B**  
   - 核心：莫比乌斯反演处理区间gcd
3. **P3312 [SDOI2014] 数表**  
   - 核心：结合欧拉函数与莫比乌斯反演

---

## 可视化设计（像素风格）
### 动画方案
1. **分块过程**：  
   - 用像素方块表示数值范围，不同颜色标记当前分块区间`[l, r]`  
   - 当计算到d时，显示`n/d`的值和对应的φ值更新

2. **筛法过程**：  
   - 质数用绿色方块标记，合数用红色  
   - 每筛到一个质数p，动态绘制p的倍数覆盖效果

3. **音效设计**：  
   - 分块切换时播放8-bit "click"音效  
   - 质数被选中时播放升调音效

### 交互功能
- **步进控制**：按空格键单步执行筛法或分块  
- **自动模式**：AI自动分块，速度可调（1x/2x/4x）

---

## 个人心得摘录
> "本题空间卡的让我深恶痛绝，迫不得已用vector存质数" —— Makasukaka  
> 总结：在空间受限时，动态计算替代预处理是常用优化手段。

> "反演时注意模数φ(mod)=mod-1的特性" —— Nemlit  
> 总结：数论题需特别注意模数的数论性质。

---
处理用时：67.27秒
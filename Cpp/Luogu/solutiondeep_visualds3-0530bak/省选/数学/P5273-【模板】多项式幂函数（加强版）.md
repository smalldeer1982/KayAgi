# 题目信息

# 【模板】多项式幂函数（加强版）

## 题目背景

[普通版传送门](https://www.luogu.com.cn/problem/P5245)

模板题，无背景。

## 题目描述

给定一个 $n-1$ 次多项式 $A(x)$，求一个在 $\bmod\ x^n$ 意义下的多项式 $B(x)$，使得 $B(x) \equiv (A(x))^k \ (\bmod\ x^n)$。

多项式的系数在 $\bmod\ 998244353$ 的意义下进行运算。

## 说明/提示

对于 $100\%$ 的数据，$1< n \leq 10^5$，$0 \leq k \leq 10^{10^5}$，$a_i \in [0,998244352]$。

[数据更新时间](https://www.luogu.com.cn/paste/897zk1ia)

## 样例 #1

### 输入

```
2 2
1 1```

### 输出

```
1 2```

# AI分析结果



## 算法分类
多项式对数与指数函数（多项式运算）

---

## 题解分析

### 核心思路对比
1. **提取公因式法**（SSerxhs、NaCly_Fish、Karry5307等）  
   - **核心步骤**：  
     a. 找到首个非零项 $a_tx^t$，将多项式分解为 $A(x)=x^t \cdot (a_t + a_{t+1}x + \dots)$  
     b. 对剩余多项式 $\frac{A(x)}{x^ta_t}$ 取 $\ln$  
     c. 系数乘 $k$ 后取 $\exp$  
     d. 恢复系数 $a_t^k$ 并右移 $tk$ 位  
   - **关键变量**：  
     - $t$：首个非零项的指数  
     - $a_t$：首个非零项的系数  
     - $k \bmod (p-1)$：用于计算 $a_t^k$（欧拉定理）

2. **快速幂法**（wucstdio、Convergent_Series）  
   - **核心步骤**：  
     a. 直接计算 $A(x)^k$ 的点值表示  
     b. 通过倍增法进行快速幂  
     c. 截断超过 $x^n$ 的项  
   - **优化手段**：  
     - 预处理原根次幂加速 NTT  
     - 减少模运算次数

### 解决难点
1. **处理零项**：通过提取 $x^t$ 将问题转换为非零常数项的多项式运算  
2. **大指数处理**：  
   - $k$ 的模数拆分：$k \bmod p$ 用于多项式系数乘法，$k \bmod (p-1)$ 用于计算首项系数幂  
3. **边界条件**：当 $tk \geq n$ 时直接输出全零

---

## 题解评分（≥4★）

| 作者          | 星级 | 亮点                                                       |
|---------------|------|------------------------------------------------------------|
| SSerxhs       | ★★★★☆ | 首个完整提出提取公因式法，代码结构清晰                     |
| NaCly_Fish    | ★★★★☆ | 详细讨论 $A(0)=0$ 的特殊情况，提供可读性强的代码实现         |
| nofind        | ★★★★☆ | 预处理原根次幂优化 NTT，代码高效                            |

---

## 最优思路提炼

1. **关键技巧**  
   - **零项提取**：通过左移多项式消除前导零，处理 $A(0)=0$ 的边界情况  
   - **双模数处理**：对 $k$ 同时取模 $p$ 和 $p-1$ 以满足欧拉定理  
   - **对数-指数优化**：将幂运算转换为 $\ln → \times k → \exp$ 的流程，时间复杂度 $O(n \log n)$

2. **代码实现要点**  
   ```cpp
   // 提取首项非零项
   int t = 0;
   while (t < n && !A[t]) t++;
   if ((ll)t * k >= n) return 全零;
   
   // 处理剩余多项式
   int a0 = A[t], inv_a0 = qpow(a0, MOD-2);
   for (int i=0; i<n-t; ++i) A[i] = A[i+t] * inv_a0 % MOD;
   
   // 计算对数
   poly_ln(A, lnA, n-t);
   
   // 系数乘k
   for (int i=0; i<n-t; ++i) lnA[i] = (ll)lnA[i] * k % MOD;
   
   // 计算指数
   poly_exp(lnA, res, n-t);
   
   // 恢复首项系数
   int a0_pow = qpow(a0, k_mod_phi);
   for (int i=0; i<n-t*k; ++i) res[i+t*k] = res[i] * a0_pow % MOD;
   ```

---

## 相似题目推荐
1. [P4725] 多项式对数函数  
   - 练习 $\ln$ 的模板实现
2. [P4726] 多项式指数函数  
   - 掌握 $\exp$ 的牛顿迭代法
3. [P5245] 多项式快速幂（普通版）  
   - 强化对提取公因式法的理解

---

## 可视化设计

### 算法动画演示
1. **像素风格界面**  
   - **颜色方案**：  
     - 零项：红色像素块  
     - 非零系数：绿色渐变色块（颜色深度随系数值变化）  
     - 当前操作区域：黄色边框高亮  
   - **Canvas 布局**：  
     - 上方：原始多项式系数（红色到绿色的渐变条）  
     - 中部：对数变换后的系数（蓝色波形）  
     - 下方：最终结果（紫色块状图）

2. **关键步骤动画**  
   ```javascript
   // 示例：提取首项非零项
   function highlightZeroTerms() {
     ctx.fillStyle = '#FF0000'; // 红色标记零项
     for (let i=0; i<t; i++) 
       drawPixel(i, originalPoly[i]);
     playSound('beep'); // 8-bit 音效
   }

   // 对数变换过程
   function showLogTransform() {
     animateWave(lnCoeffs, {color: '#0000FF', duration: 2000});
     playSound('powerUp');
   }
   ```

3. **交互功能**  
   - **速度控制**：滑块调节动画速度（0.5x~4x）  
   - **模式切换**：对比提取公因式法 vs 快速幂法的执行过程  
   - **音效开关**：启用/禁用 8-bit 音效

---

## 核心代码实现

### 对数-指数法核心片段
```cpp
void poly_pow(int *A, int n, int k_mod, int k_phi) {
    int t = 0;
    while (t < n && A[t] == 0) t++;
    
    if (t == n || (ll)t * k_mod >= n) {
        memset(A, 0, n * sizeof(int));
        return;
    }
    
    int a0 = A[t], inv_a0 = qpow(a0, MOD-2);
    for (int i=0; i<n-t; ++i) 
        A[i] = (ll)A[i+t] * inv_a0 % MOD;
    memset(A + n - t, 0, t * sizeof(int));
    
    poly_ln(A, lnA, n - t);
    for (int i=0; i<n-t; ++i) 
        lnA[i] = (ll)lnA[i] * k_mod % MOD;
    poly_exp(lnA, A, n - t);
    
    int a0_pow = qpow(a0, k_phi);
    for (int i=n-1; i >= t*k_mod; --i)
        A[i] = (ll)A[i - t*k_mod] * a0_pow % MOD;
    memset(A, 0, t*k_mod * sizeof(int));
}
```

---

## 知识扩展
当处理超大指数 $k$（如 $10^{10^5}$）时，需注意：
1. **读入优化**：逐字符读取并同时计算 $k \bmod p$ 和 $k \bmod (p-1)$  
2. **欧拉定理应用**：  
   - $a_t^k \equiv a_t^{k \bmod (p-1)} \pmod{p}$  
   - 但对多项式系数的乘法仍需用 $k \bmod p$

---
处理用时：79.31秒
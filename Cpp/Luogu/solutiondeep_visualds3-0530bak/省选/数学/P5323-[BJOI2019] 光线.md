# 题目信息

# [BJOI2019] 光线

## 题目描述

当一束光打到一层玻璃上时，有一定比例的光会穿过这层玻璃，一定比例的光会被反射回去，剩下的光被玻璃吸收。  

设对于任意 $x$，有 $x \times a_i\%$ 单位的光会穿过它，有 $x \times b_i\%$ 的会被反射回去。  
现在 $n$ 层玻璃叠在一起，有 $1$ 单位的光打到第 $1$ 层玻璃上，那么有多少单位的光能穿过**所有** $n$ 层玻璃呢？


## 说明/提示

**样例1解释：**  
![](https://cdn.luogu.com.cn/upload/pic/57125.png)   
如图，光线从左上角打进来，有 $0.5$ 单位的光穿过第 $1$ 层玻璃，有 $0.2$ 单位的光被反射回去。这 $0.5$ 单位的光有 $0.4$ 单位穿过第 $2$ 层玻璃，有 $0.025$ 单位的光被反射回去。这 $0.025$ 单位的光有 $0.0125$ 单位穿过第 $1$ 层玻璃，有 $0.005$ 单位的光被反射回去。这 $0.005$ 单位的光有 $0.004$ 单位穿过第 $2$ 层玻璃……于是，穿过两层玻璃的光一共有$0.40404... = 40/99$ 单位。在模 $10^9+7$ 意义下等于 $858585865$。 

**数据范围：**  
对于 $5\%$ 的数据，$n=1$；    
对于 $20\%$ 的数据，$n\le 2$；    
对于 $30\%$ 的数据，$n\le 3$；    
对于 $50\%$ 的数据，$n\le 100$；    
对于 $70\%$ 的数据，$n\le 3000$；    
对于 $100\%$ 的数据，$n\le 5\times 10^5$，$1\le a_i \le 100$，$0\le b_i \le 99$，$1\le a_i+b_i \le 100$。  

每组 $a_i$ 和 $b_i$ 在满足上述限制的整数中随机生成。

## 样例 #1

### 输入

```
2
50 20
80 5```

### 输出

```
858585865```

## 样例 #2

### 输入

```
3
1 2
3 4
5 6```

### 输出

```
843334849```

# AI分析结果



### 算法分类
**动态规划/数学推导**

---

### 题解思路与解决难点
**核心思路**：维护两个变量，分别表示前i层的透光率（P_i）和从第i层射入的反射率（Q_i）。通过无穷等比数列求和公式，将光线多次反射的复杂过程转化为闭合式递推关系。  
**关键步骤**：
1. **数学推导**：将透光率和反射率的无穷级数求和转换为闭合形式。
2. **递推公式**：
   - \( P_i = \frac{P_{i-1} \cdot a_i}{1 - Q_{i-1} \cdot b_i} \)
   - \( Q_i = b_i + \frac{Q_{i-1} \cdot a_i^2}{1 - Q_{i-1} \cdot b_i} \)
3. **模运算优化**：使用逆元处理分母，确保模运算正确性。

**解决难点**：
- **无穷反射建模**：通过数学公式避免逐次计算反射次数。
- **变量关系推导**：正确建立P和Q的递推关系，确保物理意义的正确性。

---

### 题解评分（≥4星）
1. **小粉兔（5星）**  
   - 思路清晰，推导严谨，代码简洁高效。
   - 关键亮点：数学公式的闭合式推导与逆元优化。

2. **Mirach（4.5星）**  
   - 合并玻璃的物理视角直观，代码易读。
   - 关键亮点：逐层合并的物理意义展示。

3. **枫林晚（4星）**  
   - 变量命名清晰，分步递推逻辑明确。
   - 关键亮点：通过f和g的消去简化问题。

---

### 最优思路提炼
1. **数学建模**：利用无穷等比数列求和公式将反射过程转化为闭合式。
2. **双变量递推**：维护透光率（P）和反射率（Q），逐层更新。
3. **逆元优化**：模运算下快速计算分母的逆元，确保时间复杂度为O(n)。

---

### 类似题目推荐
1. **P1654 概率充电器**（概率与期望的动态规划）
2. **P4284 [SHOI2014] 概率充电器**（树形DP与概率传递）
3. **P4213 线性求逆元**（模运算与递推技巧）

---

### 代码实现（核心逻辑）
```cpp
#include <cstdio>
typedef long long LL;
const int Mod = 1000000007;
const int Inv100 = 570000004; // 100的逆元

int main() {
    int N; scanf("%d", &N);
    LL P = 1, Q = 0; // 初始化：P_0=1（无玻璃时透光率100%）
    while (N--) {
        LL a, b;
        scanf("%lld%lld", &a, &b);
        a = a * Inv100 % Mod; // 转换为模意义下的分数
        b = b * Inv100 % Mod;
        LL W = 1 - Q * b % Mod; // 计算分母的逆元
        W = (W + Mod) % Mod; // 确保非负
        W = 1LL * Pow(W, Mod-2) % Mod; // 快速幂求逆元
        Q = (b + a * a % Mod * Q % Mod * W) % Mod; // 更新Q_i
        P = P * a % Mod * W % Mod; // 更新P_i
    }
    printf("%lld\n", P); // 最终透光率
    return 0;
}
```

---

### 可视化与算法演示
**动画设计**：
1. **像素风格界面**：
   - **层叠玻璃块**：每层玻璃用不同颜色方块表示，透光率/反射率动态显示。
   - **光线路径**：用闪烁线条模拟光线在层间反射与透射，展示多次反射的叠加过程。
2. **关键步骤高亮**：
   - **当前层合并**：高亮新加入的玻璃层，动态更新P和Q的数值。
   - **分母逆元计算**：显示模运算下的逆元计算过程。
3. **自动演示模式**：
   - **步进控制**：按空格逐层添加玻璃，观察P和Q的变化。
   - **音效反馈**：透射时播放清脆音效，反射时低沉音效。

**复古游戏化效果**：
- **8位音效**：使用芯片音乐模拟光线反射的“滴答”声。
- **积分系统**：每正确合并一层获得积分，错误推导触发失败音效。

---

### 结论
通过数学推导将复杂物理过程简化为递推关系，结合模运算优化，实现高效线性算法。可视化设计通过动态路径和数值变化，直观展示算法核心逻辑，适合教学与交互式学习。

---
处理用时：74.58秒
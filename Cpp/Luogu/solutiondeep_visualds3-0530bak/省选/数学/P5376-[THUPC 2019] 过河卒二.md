# 题目信息

# [THUPC 2019] 过河卒二

## 题目描述

> 首先我们回忆一下经典难题过河卒问题：
>
> 棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向上、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点，因此称之为「马拦过河卒」。
>
> 棋盘用坐标表示，$A$ 点 $(1,1)$ 、$B$ 点 $(N,M)$ ，同样马的位置坐标是需要给出的。
>
> 现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。
>
> **请注意，上述背景内容与本题无关！**

Kiana 喜欢玩象棋，尤其是喜欢用象棋玩过河卒的游戏。在传统的过河卒问题中，Kiana 需要控制一个卒从起点走到终点，在路中避开一个对方的马的攻击，然后假装不会算并询问你从起点到终点的路径总数。

在今天的过河卒二游戏中，Kiana 还是控制一个卒在一个 $N\times M$ 的棋盘上移动，初始时卒位于左下方坐标为 $(1,1)$ 位置，但为了增加难度，Kiana 对游戏规则做出了一些修改。传统的过河卒每步只能向上或向右移动 $1$ 格，Kiana 规定自己的过河卒二还可以在一步中向右上方移动 $1$ 格，即如果当前卒位于坐标 $(x,y)$ 处，则下一步可以走到 $(x+1,y)$ 、$(x,y+1)$ 或 $(x+1,y+1)$ 中的任意一格里面去，同时 Kiana 认为，如果两种移动方案在某一步时卒移动的方向（右、上或右上）不同，则两种方案就是不同的，例如从 $(1,1)$ 先走到 $(1,2)$ 再走到 $(2,2)$ 、从 $(1,1)$ 先走到 $(2,1)$ 再走到 $(2,2)$ 和从 $(1,1)$ 直接走到 $(2,2)$ 是三种不同的移动方案。

其次，过河卒二的终点不再是一个特定的位置，Kiana 规定卒可以从棋盘的上方或右方走出棋盘，此时就视为游戏成功。注意在走出棋盘时仍然有方向选择的不同，例如若过河卒位于 $(1,M)$ 处，则下一步它可以向右或者向右上用两种方式走出棋盘，若过河卒位于 $(N,M)$ 处，则下一步它可以向上、向右或者向右上用三种方式走出棋盘，以不同的方式走出棋盘仍然被算作是不同的移动方案。

此外，对方马的攻击范围不再是有规律的几个位置，而是 Kiana 规定好的 $K$ 个特定坐标，并要求过河卒在移动的过程中不能走到这 $K$ 个坐标的任何一个上，在除这些坐标以外的位置上过河卒都可以按规则自由移动。

现在 Kiana 想知道，过河卒二有多少种不同的移动方案可以走出棋盘，这个答案可能非常大，她只想知道方案数对 $59393$ 取模后的结果。由于她不会算，所以希望由你来告诉她。



## 说明/提示

### 样例解释

用 $\uparrow$ 表示过河卒向上移动了一格，用 $\rightarrow$ 表示过河卒向右移动了一格，用 $\nearrow$ 表示过河卒向右上移动了一格，由此可以简化样例解释的表述。

$24$ 种移动方案如下：

$(\uparrow\uparrow\uparrow)$、$(\uparrow\uparrow\nearrow)$、$(\uparrow\uparrow\rightarrow\uparrow)$、$(\uparrow\uparrow\rightarrow\nearrow)$、

$(\uparrow\uparrow\rightarrow\rightarrow\uparrow)$、$(\uparrow\uparrow\rightarrow\rightarrow\nearrow)$、$(\uparrow\uparrow\rightarrow\rightarrow\rightarrow)$、$(\uparrow\nearrow\uparrow)$、

$(\uparrow\nearrow\nearrow)$、$(\uparrow\nearrow\rightarrow\uparrow)$、$(\uparrow\nearrow\rightarrow\nearrow)$、$(\uparrow\nearrow\rightarrow\rightarrow)$、

$(\rightarrow\rightarrow\rightarrow)$、$(\rightarrow\rightarrow\nearrow)$、$(\rightarrow\rightarrow\uparrow\rightarrow)$、$(\rightarrow\rightarrow\uparrow\nearrow)$、

$(\rightarrow\rightarrow\uparrow\uparrow\rightarrow)$、$(\rightarrow\rightarrow\uparrow\uparrow\nearrow)$、$(\rightarrow\rightarrow\uparrow\uparrow\uparrow)$、$(\rightarrow\nearrow\rightarrow)$、

$(\rightarrow\nearrow\nearrow)$、$(\rightarrow\nearrow\uparrow\rightarrow)$、$(\rightarrow\nearrow\uparrow\nearrow)$、$(\rightarrow\nearrow\uparrow\uparrow)$。

### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。

## 样例 #1

### 输入

```
3 3 1
2 2```

### 输出

```
24```

# AI分析结果



---

## **算法分类**  
**容斥原理 + 组合数学（Lucas定理）**

---

## **综合分析与结论**  
### **核心难点与思路**  
1. **路径计算模型**：允许右、上、右上三种移动方式，需枚举斜走次数并组合计数。  
2. **障碍处理**：需排除经过障碍点的路径，结合容斥或动态规划进行高效计算。  
3. **大组合数取模**：使用 Lucas 定理处理阶乘模质数 59393 的组合数计算。  

### **关键算法流程**  
1. **预处理组合数工具**：计算阶乘及其逆元，实现 Lucas 定理。  
2. **路径计算函数**：`calc(x, y)` 计算两点间允许斜走的路径数，枚举斜走次数并累加组合数。  
3. **容斥/DP处理障碍**：  
   - **容斥**：枚举障碍子集，计算经过子集内障碍的路径数并带符号累加。  
   - **动态规划**：按障碍排序，`dp[i]` 表示不经过其他障碍到达第 i 个障碍的方案数。  

### **可视化设计思路**  
- **核心变量高亮**：在棋盘网格中动态绘制路径，高亮当前斜走步数及组合项。  
- **容斥过程动画**：以棋盘叠加方式展示不同子集的路径排除/包含效果，配合音效提示加减操作。  
- **复古像素风格**：使用 8-bit 风格渲染棋盘与卒的移动，背景播放循环芯片音乐。  

---

## **题解评分与亮点**  
### 1. **Eznibuil 题解（★★★★☆）**  
- **亮点**：  
  - **O(k²m) 动态规划**，避免指数级枚举障碍子集。  
  - 预处理两两障碍间路径数，转移方程清晰。  
- **代码片段**：  
  ```cpp  
  for (int i = 0; i <= k; i++) {  
      dp[i] = w(e[i].x, e[i].y);  
      for (int j = 0; j < i; j++)  
          dp[i] -= dp[j] * w(e[i].x - e[j].x, e[i].y - e[j].y);  
  }  
  ```

### 2. **huayucaiji 题解（★★★★☆）**  
- **亮点**：  
  - **容斥原理直接实现**，代码简洁易理解。  
  - 状态压缩枚举障碍子集，预处理路径矩阵。  
- **代码片段**：  
  ```cpp  
  for (int i = 0; i < (1 << k+1); i++)  
      ans = (ans + calc(i)) % MOD;  
  ```

### 3. **wwt100127 题解（★★★★☆）**  
- **亮点**：  
  - **混合容斥与路径计算**，代码结构模块化。  
  - 显式处理障碍排序与路径合法性检查。  
- **代码片段**：  
  ```cpp  
  for (int i = 0; i < (1 << k); i++) {  
      if (i == 0) continue;  
      // 计算当前子集的贡献  
  }  
  ```

---

## **最优思路与技巧**  
### **关键技巧**  
1. **终点扩展法**：将走出棋盘转化为到达虚拟终点 `(n+1, m+1)`，统一路径模型。  
2. **组合数枚举斜走**：公式 `Σ C(n+m-i, i) * C(n+m-2i, n-i)` 精准计数复杂移动。  
3. **动态规划优化容斥**：按障碍排序后，通过状态转移避免重复计算路径交集。  

### **同类型题拓展**  
- **通用解法**：棋盘路径计数 + 容斥/DP 处理障碍，如 [CF559C](https://codeforces.com/problemset/problem/559/C)。  
- **组合数优化**：大模数下的 Lucas 定理应用，如 [洛谷 P3807](https://www.luogu.com.cn/problem/P3807)。  

---

## **推荐相似题目**  
1. **P1950 长方形**（路径计数与障碍处理）  
2. **P1373 棋盘守卫**（动态规划优化复杂移动）  
3. **CF1316E 团队建设**（容斥与组合数学结合）  

---

## **核心代码实现**  
```cpp  
// 计算两点间允许斜走的路径数（Lucas 定理实现）  
int calc(int x, int y) {  
    int res = 0;  
    for (int i = 0; i <= min(x, y); i++) {  
        int n = x - i, m = y - i;  
        res += lucas(n + m + i, i) * lucas(n + m, n);  
    }  
    return res % MOD;  
}  

// 动态规划处理障碍（Eznibuil 方法）  
for (int i = 1; i <= k; i++) {  
    dp[i] = w(p[i].x, p[i].y);  
    for (int j = 1; j < i; j++) {  
        if (p[j].y <= p[i].y)  
            dp[i] -= dp[j] * w(p[i].x - p[j].x, p[i].y - p[j].y);  
    }  
}  
```

---

## **可视化与复古动画设计**  
### **动画方案**  
- **棋盘渲染**：Canvas 绘制网格，障碍点标记为红色像素块，卒为绿色像素块。  
- **路径生成**：逐帧绘制移动方向（右/上/右上），当前操作高亮黄色边框。  
- **音效设计**：  
  - **移动音效**：8-bit "哔" 声，不同方向音调不同。  
  - **容斥提示**：排除路径时播放低沉音效，包含时播放清脆音效。  

### **交互功能**  
- **步进控制**：空格键单步执行，方向键调整移动方向。  
- **自动演示**：AI 模式自动选择最优路径，速度可调。  
- **积分系统**：正确避开障碍奖励积分，连击加分。  

---

**总结**：本题需综合组合数学与动态规划/容斥技巧，核心在于高效处理复杂移动与障碍排除。通过预处理和状态优化，可在合理时间内完成大规模棋盘计算。

---
处理用时：83.27秒
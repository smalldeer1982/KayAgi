# 题目信息

# [MtOI2019] 幻想乡数学竞赛

## 题目背景

一年一度的幻想乡数学竞赛 (thMO) 又要开始了。

幻想乡中学习数学的少 (lao) 女 (tai) 们 (po) 和冰之妖精 baka 一起准备着 thMO。

但是在那一刻，幻想乡日复一日的宁静被打破了。

广播里，播放起了死亡的歌曲！

在那一刻，人们又回想起了被算数支配的恐惧。  

就剩下 baka，baka，baka，baka 的声音在幻想乡里回荡。  
 

---  

河城 荷取 (Kawashiro Nitori) 正坐在 thMO2019 的考场上！  
因为荷取有着她的[超级计算机](https://www.luogu.org/problemnew/show/P4911)，在成功地用光学迷彩覆盖了计算机之后，荷取在 thMO2019 的考场上所向披靡。  

* 荷取用她的超级计算机 $0 \,\mathrm{ms}$ 跑出了这么一道题：  

  * $\exists \{ a_n\} (n=0,1,\cdots ,10^{18})$，已知 $a_0=2,a_1=5,a_{n+2}=3a_{n+1}-2a_n$，求 $a_n\bmod 10^{9}+7$

* 荷取：显然，这个题可以用矩阵乘法 + 快速幂，可以 $O(\log n)$ 水过去，差不多就这样：

$$
\begin{bmatrix} a_n & a_{n+1} \end{bmatrix}=\begin{bmatrix} a_0 & a_1 \end{bmatrix} \times \begin{bmatrix} 3 & 1 \\ -2 & 0 \end{bmatrix}^n
$$      
  
但是荷取遇到了一道她不会的题，她正在寻求你的帮助呢！ 

## 题目描述

存在一个数列 $\{ a_n\} (n\in \{ 0,1,2,\cdots ,2^{64}-1\} )$。  
已知 $a_0=-3,a_1=-6,a_2=-12,a_n=3a_{n-1}+a_{n-2}-3a_{n-3}+3^n$。  

* 现在给你一个非负整数 $n$ ，令 $p=10^{9}+7$，请你求出 $a_n \bmod p$。 

* **注：若 $a_n<0$ ，请输出 $(a_n \bmod p+p)\bmod p$。**    
  
  
为了更充分地考验你的水平，荷取设置了 $T$ 组询问。

* 为了在某种程度上减少你的输入和输出量，我们采用以下的代码来生成询问：  
  
```cpp
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#include<climits>
	#define ull unsigned long long
	#define uint unsigned int
	ull sd;int op;
	inline void init() {scanf("%llu %d", &sd, &op);}
	inline ull ull_rand()
	{
		sd ^= sd << 43;
		sd ^= sd >> 29;
		sd ^= sd << 34;
		return sd;
	}
	inline ull rand()
	{
		if (op == 0) return ull_rand() % USHRT_MAX + 1;
		if (op == 1) return ull_rand() % UINT_MAX + 1; 
		if (op == 2) return ull_rand();
	}
}
```  

在调用 `Mker::init()` 函数之后，你第 $i$ 次调用 `Mker::rand()` 函数时返回的便是第 $i$ 次询问的 $n_i$。

在这里给出 $op$ 的限制：

* 如果 $op=0$，满足 $n_i \leq 2^{16}$。

* 如果 $op=1$，满足 $n_i \leq 2^{32}$。

* 如果 $op=2$，满足 $n_i \leq 2^{64}-1$。

为了减少你的输出量，你只需要输出所有询问答案的**异或和**。





## 说明/提示

### 子任务  

![png](https://i.loli.net/2019/04/19/5cb9bb2c6c1d6.png)  

### 题目来源

[迷途之家 2019 联赛](https://www.luogu.org/contest/20135)(MtOI2019) T4

出题人：disangan233

验题人：suwakow


## 样例 #1

### 输入

```
142857 1145141919 0```

### 输出

```
562611141```

## 样例 #2

### 输入

```
142857 1145141919 1```

### 输出

```
894946216```

## 样例 #3

### 输入

```
142857 1145141919 2```

### 输出

```
771134436```

# AI分析结果



## 唯一算法分类
**数论**

---

## 综合分析与结论

### 核心思路与数学推导
题目给出非齐次线性递推式：  
$$a_n=3a_{n-1}+a_{n-2}-3a_{n-3}+3^n$$  
通过构造辅助数列 $b_n = a_n - a_{n-2}$ 将其转化为等比数列问题，最终得到通项公式：
$$a_n = \frac{3^n (36n - 117) + 21 + 30 \cdot [n \text{为奇数}]}{32}$$
关键步骤如下：

1. **辅助数列构造**  
   $$b_n = a_n - a_{n-2} \Rightarrow b_n = 3b_{n-1} + 3^n$$  
   通过变形 $\frac{b_n}{3^n} = \frac{b_{n-1}}{3^{n-1}} + 1$ 得到 $b_n = (n-3) \cdot 3^n$

2. **分奇偶求和**  
   通过错位相消法分别处理奇偶项，最终合并为统一公式

### 算法优化与实现
1. **光速幂优化**  
   预处理 $3^{k}$ 的两种分块值（$3^{i}$ 和 $3^{j \cdot \sqrt{p}}$），将 $3^n$ 计算复杂度降至 $O(1)$

2. **费马小定理**  
   利用 $3^{p-1} \equiv 1 \mod p$ 将指数规模从 $2^{64}$ 缩减至 $10^9+6$

### 可视化设计思路
1. **递推式转化动画**  
   - 初始状态：显示原始递推式 $a_n=3a_{n-1}...$  
   - 高亮操作：用黄色标记 $a_n - a_{n-2}$，红色箭头指向 $b_n$ 定义  
   - 动态展示：逐步推导 $\frac{b_n}{3^n}$ 的递推关系，最终得到 $b_n = (n-3) \cdot 3^n$

2. **光速幂分块演示**  
   - Canvas 绘制两个预计算数组：`pow1[i] = 3^i` 和 `pow2[j] = 3^{j*31623}`  
   - 输入随机 $n$ 时，分解为 `n = j*31623 + i`，动态显示查表与合并计算过程

3. **像素风格交互**  
   - 8-bit 音效：计算正确时播放上升音阶，错误时播放下降音阶  
   - 复古 UI：用绿色像素块表示已计算的 $3^k$ 分块值，红色表示当前查询的索引

---

## 题解清单（≥4星）

### 1. Fading（4.5星）
**亮点**：  
- 通过构造 $b_n$ 和 $c_n$ 将问题简化为等差数列  
- 代码简洁，直接给出通项公式与光速幂实现  
**核心代码**：
```cpp
int a_n = ((36n - 117) * qpow(3, n) + 21 + 30*(n%2)) / 32;
```

### 2. disangan233（4星）
**亮点**：  
- 使用生成函数法完整推导通项公式  
- 给出多种解法对比，包含矩阵快速幂的优化思路  
**关键公式**：
$$f(x) = \frac{12x-3}{(1-3x)^2(1+x)(1-x)}$$

### 3. ljc1301（4星）
**亮点**：  
- 特征根法的完整推导，适合数学背景较强的学习者  
- 通过四阶特征方程分解得到最终解  
**核心推导**：
$$a_n = (c_1 n + c_2) \cdot 3^n + c_3 \cdot (-1)^n + c_4$$

---

## 同类型题与算法套路

### 通用解法
1. **线性递推式**：转化为矩阵快速幂或特征方程  
2. **非齐次项处理**：构造特解+齐次通解，或通过辅助数列消去非齐次项  
3. **大指数优化**：费马小定理+光速幂/快速幂分块

### 推荐题目
1. [P1939 矩阵加速（数列）](https://www.luogu.com.cn/problem/P1939)  
2. [P4924 魔法少女](https://www.luogu.com.cn/problem/P4924)  
3. [P5175 数列](https://www.luogu.com.cn/problem/P5175)

---

## 个人心得摘录
1. **调试教训**：  
   - 初始条件代入时需注意 $n=0$ 和 $n=1$ 的特殊情况  
   - 负数取模需额外处理 `(a%p + p) % p`

2. **优化技巧**：  
   - 光速幂的块大小取 $\sqrt{p}$ 时最平衡  
   - 预处理数组声明为 `constexpr` 可加速编译期计算

---

## 可视化代码片段（Canvas 动画）

```javascript
// 光速幂分块演示
const canvas = document.getElementById('pow-vis');
const ctx = canvas.getContext('2d');

function drawBlock(x, y, value, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*50, y*50, 45, 45);
    ctx.fillStyle = 'white';
    ctx.fillText(value, x*50+10, y*50+25);
}

// 预计算块绘制
for (let i=0; i<316; i++) {
    drawBlock(i%20, Math.floor(i/20), `3^${i}`, '#00ff00');
    drawBlock(i%20+21, Math.floor(i/20), `3^${i*316}`, '#ff0000');
}

// 动态查询效果
function query(n) {
    const i = n % 316;
    const j = Math.floor(n / 316);
    ctx.clearRect(0, 300, 800, 50);
    ctx.fillText(`3^${n} = 3^${j*316} * 3^${i}`, 10, 320);
    drawBlock(j%20+21, Math.floor(j/20), '', '#ffff00'); // 高亮大块
    drawBlock(i%20, Math.floor(i/20), '', '#ffff00'); // 高亮小块
}
```

---

## 复古音效设计
```javascript
// 8-bit 音效生成
const audioCtx = new AudioContext();
function beep(freq, duration) {
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
    oscillator.connect(gainNode).connect(audioCtx.destination);
    oscillator.start();
    setTimeout(() => oscillator.stop(), duration);
}

// 计算成功时播放
function playSuccess() {
    beep(523, 100); // C5
    beep(659, 100); // E5
}

// 错误时播放
function playError() {
    beep(220, 300); // A3
}
```

---
处理用时：86.21秒
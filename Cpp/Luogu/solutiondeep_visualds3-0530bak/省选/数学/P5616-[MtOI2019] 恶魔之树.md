# 题目信息

# [MtOI2019] 恶魔之树

## 题目背景

在 Kirito 和 Eugeo 还没有与 Alice 前往北之洞窟的时候，Eugeo 每天只能用龙骨斧砍恶魔之树——基家斯西达……

![](https://cdn.luogu.com.cn/upload/image_hosting/95swctde.png)

~~请忽略bilibili的水印~~

## 题目描述

Kirito 和 Eugeo 每天砍树觉得很无聊，于是开始比谁砍出好声音的次数多。渐渐地，他们发现这样也没有意思了，于是在这个基础上改了一点：

每个人去砍树前，会随机得到一个长度为 $n$ 的数列 $s_1, s_2, \dots, s_n$ 。最初每个人的得分都是 $1$，当第 $i$ 次砍出了一个好声音时，得分就变成了原来的得分与 $s_i$ 的最小公倍数，也就是常说的 ${\rm lcm}$。

现在 Kirito 已经得到了一个长度为 $n$ 的数列 $s_1, s_2, \ldots, s_n$ 。他想知道，如果每一次砍出好声音的概率是 $50\%$ 时他的期望得分。

由于 Kirito 不想看到小数，所以请你告诉 Kirito 答案乘 $2^n$ 对 $p$ 取模的值。

## 说明/提示

#### 样例解释 1

一共有 $8$ 种情况：

- 没有出现好声音，得分为 $1$，概率为 $\frac{1}{8}$。

- 只有第一次出现了好声音，得分为 $1$，概率为 $\frac{1}{8}$。

- 只有第二次出现了好声音，得分为 $2$，概率为 $\frac{1}{8}$。

- 只有第三次出现了好声音，得分为 $3$，概率为 $\frac{1}{8}$。

- 只有第三次没有出现好声音，得分为 $\operatorname{lcm}(1, 2)=2$，概率为 $\frac{1}{8}$。

- 只有第二次没有出现好声音，得分为 $\operatorname{lcm}(1, 3)=3$，概率为 $\frac{1}{8}$。

- 只有第一次没有出现好声音，得分为 $\operatorname{lcm}(2, 3)=6$，概率为 $\frac{1}{8}$。

- 每一次都砍出了好声音，得分为 $\operatorname{lcm}(1, 2, 3)=6$，概率为 $\frac{1}{8}$。

所以期望值为 $\frac{1}{8}+\frac{1}{8}+\frac{2}{8}+\frac{3}{8}+\frac{2}{8}+\frac{3}{8}+\frac{6}{8}+\frac{6}{8}=3$

乘上 $2^3$ 得到答案为 $24$。

### 子任务

本题采用捆绑测试。

对于 $100\%$ 的数据，$1\leq n\leq 3\times 10^5$，$10^7 \leq p \leq 1.1 \times 10^9$且$p$为质数，$1\leq s_i\leq 300$。

本题共 $7$ 个子任务，各子任务的分值和限制如下：

子任务 $1$（$3$ 分）：$n=1$。

子任务 $2$（$7$ 分）：$n=18$。

子任务 $3$（$10$ 分）：$n=100$，$s$ 中不同的正整数不超过 $18$ 个。

子任务 $4$（$20$ 分）：$n=100$，不存在 $1\leq i \neq j \leq n$，使得 $s_i=s_j$。且保证数据随机。

子任务 $5$（$20$ 分）：$1\leq s_1, s_2, \ldots, s_n \leq 100$。

子任务 $6$（$20$ 分）：$1\leq n \leq 10^4$。

子任务 $7$（$20$ 分）：无特殊限制。

------

谨以此题庆祝刀剑10周年。~~好像晚了几个月...~~


### 题目来源

[MtOI2019 Extra Round](https://www.luogu.org/contest/22840) T4

出题人：CYJian 

验题人：suwAKow


## 样例 #1

### 输入

```
3 998244353
1 2 3```

### 输出

```
24```

## 样例 #2

### 输入

```
10 998244353
1 2 3 4 5 6 7 8 9 10```

### 输出

```
516032```

# AI分析结果



### 唯一算法分类  
**状态压缩动态规划 + 质因数分解分治**

---

### 题解思路、算法要点与解决难点  

#### **核心思路**  
1. **质因数分治**：将质数分为小质数（≤17）和大质数（＞17）。小质数通过状态压缩记录指数最大值，大质数分组处理。  
2. **状态压缩DP**：用多维数组表示小质数的指数组合（如 `dp[a1][a2][a3][a4][a5][a6][a7]`），总状态数为 9×6×4×3×3×3×3 = 17496。  
3. **大质数贡献分离**：每个数最多含有一个大质数，按大质数分组，每组独立处理其对LCM的贡献。  
4. **乘法优化**：相同数值的数合并，利用快速幂计算 `2^cnt-1` 减少重复计算。  

#### **关键步骤解析**  
1. **分解质因数**：预处理每个数的质因数，分离小质数和大质数部分。  
2. **小质数状态转移**：  
   - 初始状态 `dp[0][0][0][0][0][0][0] = 1`。  
   - 对于每个数，更新所有可能的状态，取各质因数的最大指数。  
3. **大质数处理**：  
   - 使用辅助数组 `F` 记录当前大质数的贡献状态。  
   - 处理完一个大质数后，合并状态到 `F[0]`，重置 `F[1]`。  

#### **解决难点**  
- **状态爆炸**：通过限制小质数范围，将状态数压缩至可处理范围。  
- **大质数独立性**：大质数之间互斥，处理时需独立计算其贡献。  

---

### 题解评分（≥4星）  

1. **mrsrz（5星）**  
   - **亮点**：状态压缩设计清晰，处理大质数贡献的逻辑严密，代码高效。  
2. **GreenDay（4.5星）**  
   - **亮点**：代码简洁，通过宏定义简化多维数组操作，适合快速理解核心逻辑。  
3. **AquariusZhao（4星）**  
   - **亮点**：将问题转化为子序列LCM之和，利用预处理编号优化状态查询。  

---

### 最优思路与技巧提炼  

1. **质数分治策略**  
   - 小质数直接状压，大质数分组处理。  
   - **代码片段**（mrsrz的预处理）：  
     ```cpp  
     // 分解质因数并处理小质数  
     for (auto j : vc[i]) {  
         switch(j.first) {  
             case 2: b1 = j.second; break;  
             // 其他小质数类似处理  
         }  
     }  
     ```  

2. **状态转移优化**  
   - 使用滚动数组减少内存消耗。  
   - **代码片段**（GreenDay的转移逻辑）：  
     ```cpp  
     memcpy(dp[cur], dp[cur^1], sizeof(*dp));  
     // 枚举所有状态并更新  
     ```  

3. **大质数贡献合并**  
   - 处理完每个大质数后，合并状态并重置。  
   - **代码片段**（mrsrz的合并逻辑）：  
     ```cpp  
     rep(a1,0,8) rep(a2,0,5) ... {  
         f = (f + F[cur][1][...]) % mod;  
         F[cur][1][...] = 0;  
     }  
     ```  

---

### 同类型题与算法套路  

1. **质因数分解+状态压缩DP**  
   - 适用场景：涉及LCM/GCD计数，且数值范围较小的题目。  
   - **通用解法**：  
     - 预处理质因数分解。  
     - 设计状态表示质因数的指数组合。  
     - 动态规划转移时取最大值。  

2. **分治处理独立因素**  
   - 如大质数独立贡献，类似背包问题中的分组处理。  

---

### 推荐相似题目  

1. **P2150 [NOI2015] 寿司晚宴**  
   - **关键词**：质因数分治、状态压缩DP。  
2. **P6620 [省选联考 2020 A 卷] 组合数问题**  
   - **关键词**：质因数贡献分离、多项式展开。  
3. **P4247 [清华集训2012] 序列操作**  
   - **关键词**：动态规划优化、组合贡献计算。  

---

### 可视化与算法演示  

#### **核心算法动画设计**  
1. **状态转移可视化**  
   - **网格显示**：以7维网格展示小质数状态，每次更新时高亮变化维度（如2的指数从3→5）。  
   - **颜色标记**：红色表示当前处理的质数，绿色表示状态更新。  
2. **大质数处理演示**  
   - **分组动画**：将同大质数的数分组显示，处理时弹出独立窗口展示贡献计算。  
3. **音效与交互**  
   - **音效**：状态更新时触发“叮”声，大质数合并时播放“咔嚓”声。  
   - **步进控制**：支持暂停/继续，拖动进度条观察特定步骤。  

#### **复古像素风格实现**  
- **Canvas绘制**：  
  - 使用16色调色板，质数状态用不同色块表示。  
  - 每次状态更新时，像素块闪烁（如2的指数增加时，对应块变亮）。  
- **AI自动演示**：  
  - 自动遍历所有质数分组，按预设速度展示处理流程。  

```javascript  
// 伪代码：Canvas绘制状态网格  
function drawState(grid) {  
    ctx.fillStyle = '#8B8B8B'; // 背景灰色  
    ctx.fillRect(0, 0, width, height);  
    for (let i = 0; i < 7; i++) {  
        // 绘制每个质数的指数条  
        drawBar(i, grid[i], '#FF5555');  
    }  
}  
```  

---

### 个人心得摘录  

- **CYJian**提到验题时发现常数优化的重要性，强调预处理和快速幂的优化。  
- **AquariusZhao**在调试中发现`unordered_map`比`map`快，改用后通过极限数据。  

---

### 完整代码参考  

**mrsrz的核心转移逻辑**：  
```cpp  
// 小质数状态转移  
rep(a1,0,8) rep(a2,0,5) rep(a3,0,3) ... {  
    int s = dp[cur^1][a1][a2][a3][a4][a5][a6][a7];  
    if (!s) continue;  
    // 计算新状态b1, b2, ...  
    int& to = dp[cur][b1][b2][b3][b4][b5][b6][b7];  
    to = (to + (LL)s * fs) % mod;  
}  

// 大质数贡献转移  
rep(ff,0,1) rep(a1,0,8) ... {  
    int s = F[cur^1][ff][a1][a2][a3][a4][a5][a6][a7];  
    if (!s) continue;  
    // 计算Δ并更新状态  
    int& to = F[cur][1][b1][b2][b3][b4][b5][b6][b7];  
    to = (to + s * (LL)dlt % mod * fs) % mod;  
}  
```  

---

### 总结  
本题通过质数分治和状态压缩DP，将复杂问题分解为可处理的子问题。核心在于分离小质数和大质数的贡献，并通过动态规划高效合并状态。可视化设计可帮助理解状态转移和大质数处理流程，复古风格增强学习趣味性。

---
处理用时：85.81秒
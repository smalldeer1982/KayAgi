# 题目信息

# [P5087] 数学 加强版

## 题目背景

[原题链接](https://www.luogu.com.cn/problem/P5087)

## 题目描述

小奔热衷于乘法，他最喜欢做的事情是：从一个有 $n$ 个元素的可重集中选出 $k$ 个数，并把这 $k$ 个数的乘积作为这个组合的分数。

小奔想试遍所有的这些组合，然后算出所有这些组合的分数之和。但是他还要出模拟赛虐爆我们这些蒟蒻，所以他只好把这个任务交给了你。

作为不良心的出题人，这题你还要将答案对 $10^9 + 7$ 取模。


## 说明/提示

【样例二解释】  
有四种选择方案，一种是 $\{1,1,1\}$ 和三种都是 $\{1,1,2\}$，分数之和为 $7$。

【数据范围】  
对于 $100\%$ 的数据，$1\le k \le n \le 1.2\times 10^5$，$1\le a_i \le 10^8$。

## 样例 #1

### 输入

```
3 3
1 1 1```

### 输出

```
1```

## 样例 #2

### 输入

```
4 3
1 1 1 2```

### 输出

```
7```

## 样例 #3

### 输入

```
10 7
11 45 14 19 19 8 10 8 17 23```

### 输出

```
693404716```

# AI分析结果



**唯一算法分类**：生成函数与分治FFT/MTT

---

### **题解思路与算法要点**

1. **核心思路**  
   所有题解均基于生成函数：每个元素对应多项式 \(1 + a_i x\)，乘积后的 \(x^k\) 系数即为答案。关键在于高效计算大规模多项式乘积，使用分治策略降低复杂度至 \(O(n \log^2 n)\)。

2. **实现难点**  
   - **模数限制**：模数 \(10^9+7\) 无法直接应用NTT，需采用拆系数FFT（MTT）或三模数NTT。
   - **分治合并**：递归拆分多项式乘积任务，逐层合并左右部分结果，避免直接暴力相乘的高复杂度。
   - **精度与效率**：MTT需处理浮点数精度问题，三模数NTT需多次计算与CRT合并，代码实现复杂。

3. **关键对比**  
   - **拆系数FFT**（如iostream、Super_Cube）：将数拆分为高低位分别卷积，避免溢出，需4次DFT+3次IDFT。
   - **三模数NTT**（RuSun）：使用三个不同模数NTT，最后通过中国剩余定理合并结果，需三次NTT运算。
   - **分治结构**：均采用二分法合并左右子问题，递归终止条件为单个元素的多项式 \(1 + a_i x\)。

---

### **题解评分（≥4星）**

1. **作者：iostream（★★★★☆）**  
   - **亮点**：代码简洁，使用预计算的旋转因子优化FFT，分治逻辑清晰。  
   - **缺点**：未显式处理递归栈深度，可能在大数据时栈溢出。

2. **作者：Super_Cube（★★★★☆）**  
   - **亮点**：拆系数FFT实现直观，分治与卷积分离，适合教学理解。  
   - **缺点**：未优化FFT的位反转操作，常数较大。

3. **作者：RuSun（★★★★☆）**  
   - **亮点**：三模数NTT避免浮点误差，代码模块化设计（NTT类复用）。  
   - **缺点**：CRT合并计算量大，常数时间较长。

---

### **最优思路与技巧提炼**

- **分治策略**：将大规模多项式乘法分解为小规模任务，递归合并结果，显著降低复杂度。
- **模数处理**：  
  - **拆系数FFT**：将数分解为 \(a = a_{\text{high}} \cdot 2^{15} + a_{\text{low}}\)，分别卷积后组合。  
  - **三模数NTT**：利用三个质数模数保证结果正确，通过CRT还原最终值。
- **代码优化**：预计算旋转因子、位反转表，减少重复计算；分治时复用内存空间。

---

### **同类型题目与相似套路**

1. **洛谷P4245**：任意模数多项式乘法（模板题）。  
2. **洛谷P4238**：多项式求逆（需分治FFT优化）。  
3. **洛谷P4721**：分治FFT（递推数列优化）。

---

### **可视化与算法演示**

**动画设计**：  
1. **分治树可视化**：以二叉树形式展示递归分治过程，每个节点显示当前合并的多项式长度。  
2. **卷积操作高亮**：用不同颜色标记左右子多项式的DFT过程，合并时显示卷积结果的关键系数。  
3. **像素风格**：  
   - **颜色方案**：8位色调色板（绿、蓝、红标记分治层级）。  
   - **Canvas网格**：绘制分治树节点，每个节点显示当前多项式的 \(x^k\) 系数值。  
4. **音效提示**：  
   - **分治合并**：成功合并时播放上扬音效。  
   - **错误处理**：系数溢出时播放短促低音。

---

### **关键代码实现（拆系数FFT）**

```cpp
// 拆系数FFT核心片段（Super_Cube题解）
void FFT(vector<complex<db>>& a, int tp) {
    // 位反转和蝴蝶操作
    for (int i = 0; i < n; ++i) if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int i = 1; i < n; i <<= 1) {
        complex<db> wn(cos(PI / i), tp * sin(PI / i));
        for (int j = 0; j < n; j += i << 1) {
            complex<db> w(1, 0);
            for (int k = 0; k < i; ++k, w *= wn) {
                auto x = a[j + k], y = w * a[j + i + k];
                a[j + k] = x + y; a[j + i + k] = x - y;
            }
        }
    }
    if (tp == -1) for (auto& x : a) x /= n;
}

vector<int> polymul(vector<int> a, vector<int> b) {
    // 拆分为高低位，FFT后合并
    vector<complex<db>> a1(lim), a2(lim), b1(lim), b2(lim);
    for (int i = 0; i <= n; ++i) {
        a1[i] = a[i] >> 15; a2[i] = a[i] & 0x7FFF;
        b1[i] = b[i] >> 15; b2[i] = b[i] & 0x7FFF;
    }
    FFT(a1, 1); FFT(a2, 1); FFT(b1, 1); FFT(b2, 1);
    // 计算各乘积项并逆变换
    vector<int> res(n + m + 1);
    for (int i = 0; i <= n + m; ++i) {
        res[i] = (((ll)(ac[i].real() + 0.5) % mod << 30) +
                  ((ll)(adbc[i].real() + 0.5) << 15) +
                  (ll)(bd[i].real() + 0.5)) % mod;
    }
    return res;
}
```

---

**总结**：通过生成函数与分治策略结合FFT/MTT，高效解决大规模组合乘积和问题。关键优化点在于分治降低复杂度与模数处理技巧，适用于类似多项式乘法的扩展场景。

---
处理用时：81.85秒
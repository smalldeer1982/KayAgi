# 题目信息

# 最优性剪枝

## 题目背景

Nauuo 是一名出题人。

众所周知，某些出题人非常懒，导致[随便爆搜](https://www.luogu.com.cn/discuss/show/185420)加上一个[最优性剪枝](https://www.luogu.com.cn/discuss/show/184641)就能通过。Nauuo 决定把这些 naive 的暴力都卡掉。

## 题目描述

Nauuo 决定卡一个暴力搜索程序，为此她构建了一组数据。为了简化题目，你将得到这组数据产生的搜索树 $T$。$T$ 中包含 $n$ 个节点，依次编号为 $1 \sim n$，其中 $1$ 号点是 $T$ 的根节点。一个节点的深度是它到 $1$ 号点的简单路径上的节点个数。

这个程序的伪代码如下

```cpp
answer := inf

procedure dfs(node,depth)
	if (node is leaf) 
		answer := min(answer,depth)
		return
	if (depth < answer)
		for i in children of node
			dfs(i,depth+1)

dfs(1,1)
```

其中，`:=` 表示赋值运算。

翻译成人话就是说，这个暴力搜索程序将**深度优先**地遍历这棵搜索树，当访问到一个叶节点时，这个程序将用这个叶节点的深度更新答案。

同时，这个程序有一个最优性剪枝，也就是说，当这个程序访问到任意一个深度等于答案的节点时，它将不会再访问这个节点的子节点。

然而，可怜的 Nauuo 并不知道这个程序在某个节点时访问自己子节点的顺序，因此她认为每个节点访问子节点的顺序都是在所有可能的情况中等概率随机的，显然，一共有 $\prod d_i!$ 种情况，其中 $d_i$ 表示 $i$ 号节点的子节点数量。

现在她想知道这个程序访问到的节点数量的期望，以确定这个程序会不会被自己的数据卡掉。

为了避免浮点误差，答案对 $998244353$ 取模。保证答案能被表示为最简分数 $\frac{p}{q}$，你只需要输出一个 $x (0\leq x < 998244353)$ 使得 $qx \equiv p \pmod {998244353}$。

## 说明/提示

#### 样例解释

第一组样例的真实答案为 $\frac{7}{2}$。

一共只有两种情况，如果 $1$ 号节点先遍历 $3$ 号节点，则程序将访问到搜索树中所有节点。如果 $1$ 号节点先遍历 $2$ 号节点，则 $4$ 号节点不会被访问到。

第二组样例中，每个非叶节点的子节点都是唯一的，因此只有一种可能的情况，所有节点都必然被访问到。

第三组样例的真实答案为 $\frac{94}{9}$。

---

#### 数据范围

**「本题采用捆绑测试」**

对于所有测试点，保证 $1 \leq n \leq 3\times 10^5$，$1 \leq p_i < i$。

$\text{Subtask 1 (11 pts)}$ $n \leq 9$。

$\text{Subtask 2 (18 pts)}$ $n \leq 100$。

$\text{Subtask 3 (19 pts)}$ $n\leq 10^3$。

$\text{Subtask 4 (4 pts)}$ $p_i = i-1$。

$\text{Subtask 5 (8 pts)}$ $p_i =\lfloor \frac{i}{2} \rfloor$。

$\text{Subtask 6 (40 pts)}$ 无特殊限制。

---

#### 提示

如果你不知道怎么对分数取模，可以参考[这里](https://www.luogu.com.cn/problem/P3811)。



## 样例 #1

### 输入

```
4
1 1 3```

### 输出

```
499122180```

## 样例 #2

### 输入

```
3
1 2```

### 输出

```
3```

## 样例 #3

### 输入

```
13
1 1 1 3 5 4 2 3 7 4 4 6```

### 输出

```
776412285```

# AI分析结果



**唯一算法分类**  
树形结构上的期望计算与树状数组优化

---

**综合分析与结论**  
题目要求计算带最优性剪枝的DFS访问节点数的期望。核心思路是将期望拆分为各节点被访问的概率之和。每个节点的访问概率取决于其到根路径上各祖先节点的子节点排序策略，需确保在访问该节点前未发现更优叶子。通过预处理子树最小深度（val）并排序子节点，结合树状数组维护路径概率乘积，实现高效的O(n log n)算法。

**可视化设计思路**  
- **树结构展示**：以像素风格绘制树形结构，节点颜色按深度渐变，当前处理节点高亮闪烁。  
- **树状数组操作**：右侧显示树状数组的差分数组，区间乘法操作时用颜色波纹扩散表示修改区域。  
- **音效与动画**：节点处理时播放8-bit点击音效，区间修改时伴随不同音调，完成时播放胜利音效。  
- **自动演示模式**：AI自动DFS遍历，按逻辑顺序处理节点，速度可调，支持单步执行观察细节。

---

**题解清单 (≥4星)**  
1. **Zory的题解（4.5星）**  
   - **亮点**：利用树状数组维护概率乘积差分，代码简洁高效，时间复杂度O(n log n)。预处理val值后，通过排序子节点和区间乘法巧妙处理贡献累积。  
   - **核心代码**：  
     ```cpp  
     void solve(int x) {
         add(ans, BIT::ask(dep[x]-1)); // 查询当前概率贡献
         int m = sz(son[x]);
         fo(i,2,m) BIT::MUL(V(i), V(i+1), invm(i)); // 调整区间乘积
         for (auto y : son[x]) {
             solve(y); // 递归处理子节点
             if (i < m) BIT::MUL(V(i), V(i+1), i*invm(i+1)%MOD); // 恢复调整
         }
     }
     ```

2. **Owen的题解（4星）**  
   - **亮点**：提出倍增法处理祖先链，结合线段树维护动态区间乘积。思路新颖，利用单调性优化路径查询。  
   - **关键思路**：通过倍增确定临界祖先，分离需调整贡献的路径段，结合两棵线段树处理不同贡献区间。

---

**最优思路或技巧提炼**  
1. **期望线性性**：将总期望拆解为各节点访问概率求和。  
2. **val值预处理**：每个节点的val表示其子树中叶子节点的最小深度，决定子节点访问顺序。  
3. **概率乘积维护**：沿祖先链累乘每个节点的条件概率，使用树状数组高效处理区间乘法。  
4. **排序优化**：子节点按val排序，确保剪枝条件正确触发，简化概率计算。

---

**同类型题推荐**  
1. **P6835 概率计算树**（树形期望与路径贡献）  
2. **P4211 动态树统计**（树状数组维护路径乘积）  
3. **P6154 游走问题**（期望线性性与DFS剪枝）

---

**代码核心实现**  
```cpp
// 树状数组维护区间乘法差分
namespace BIT {
    ll bit[N];
    void MUL(int l, int r, ll c) { 
        mul(l, c), mul(r, invm(c)); 
    }
    ll ask(int x) { 
        ll ret = 1;
        while (x) ret = ret * bit[x] % MOD, x -= x&-x;
        return ret;
    }
}

void solve(int x) {
    ans = (ans + BIT::ask(dep[x]-1)) % MOD;
    int m = son[x].size();
    for (int i=2; i<=m; ++i) 
        BIT::MUL(val[son[x][i-2]], val[son[x][i-1]], invm(i));
    for (int i=0; i<m; ++i) {
        int y = son[x][i];
        solve(y);
        if (i < m-1) BIT::MUL(val[y], val[son[x][i+1]], (i+1)*invm(i+2)%MOD);
    }
}
```

---

**可视化与复古游戏化设计**  
- **像素树绘制**：采用16色调色板，根节点为红色，叶子为绿色，当前节点黄色闪烁。  
- **树状数组动效**：每次区间乘法时，对应网格区域显示蓝色波纹，右侧数值用8-bit字体刷新。  
- **音效设计**：使用Web Audio API，节点访问触发“哔”声，区间修改播放“嘟”声，错误操作为低沉嗡鸣。  
- **自动模式**：AI按DFS序遍历，速度滑块控制帧率，按空格暂停/继续，Enter单步执行。

---
处理用时：88.02秒
# 题目信息

# [NOI Online #1 入门组] 跑步

## 题目描述

小 H 是一个热爱运动的孩子，某天他想给自己制定一个跑步计划。小 H 计划跑 $n$ 米，其中第 $i(i \geq 1)$ 分钟要跑 $x_i$ 米（$x_i$ 是正整数），但没有确定好总时长。

由于随着跑步时间增加，小 H 会越来越累，所以小 H 的计划必须满足对于任意 $i(i >1)$ 都满足 $x_i \leq x_{i-1}$。

现在小 H 想知道一共有多少个不同的满足条件的计划，请你帮助他。两个计划不同当且仅当跑步的总时长不同，或者存在一个 $i$，使得两个计划中 $x_i$ 不相同。

由于最后的答案可能很大，你只需要求出答案对 $p$ 取模的结果。 

## 说明/提示

#### 样例输入输出 1 解释

五个不同的计划分别是：$\{1,1,1,1\}$，$\{2,1,1\}$，$\{3,1\}$，$\{2,2\}$，$\{4\}$。 

---

#### 数据规模与约定

本题共 $10$ 个测试点，各测试点信息如下表。

| 测试点编号 | $n \leq$ | 测试点编号 | $n \leq$ |
| :----------: | :---------: | :----------: | :---------: |
| $1$ | $5$ | $6$ | $2\times 10^3$ |
| $2$ | $10$ | $7$ | $5\times 10^3$ |
| $3$ | $50$ | $8$ | $2\times 10^4$ |
| $4$ | $100$ | $9$ | $5\times 10^4$ |
| $5$ | $500$ | $10$ | $10^5$|

对于全部的测试点，保证 $1 \leq n \leq 10^5$，$1 \leq p < 2^{30}$。

## 样例 #1

### 输入

```
4 44
```

### 输出

```
5```

## 样例 #2

### 输入

```
66 666666
```

### 输出

```
323522```

## 样例 #3

### 输入

```
66666 66666666
```

### 输出

```
45183149
```

# AI分析结果



## 算法分类  
**动态规划分块优化 & 生成函数数学方法**

---

## 题解思路与核心难点  

### 核心算法对比
| 方法               | 时间复杂度   | 核心思想                                                                 | 实现难点                                                                 |
|--------------------|--------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------|
| 分块DP（OMG_wc）   | O(n√n)       | 将数分为小值和大值两部分，分别用完全背包和特殊DP处理，最终合并结果       | 正确设计两部分DP的状态转移，合理选择分块阈值m，处理合并时的组合逻辑     |
| 五边形数定理       | O(n√n)       | 利用生成函数的展开特性，将划分数转化为带符号项的递推式                   | 理解五边形数定理的数学推导，处理广义五边形数的生成和递推边界条件         |
| 分治策略           | O(n√n)       | 拆分问题为小规模和大规模部分，分别用不同DP策略处理                       | 设计两套互补的DP状态，保证分治后的合并逻辑无遗漏                         |

---

## 题解评分 (≥4星)

### 1. OMG_wc（5星）
- **亮点**：分块思想清晰，代码结构简洁，完整注释关键步骤  
- **核心代码**：  
  ```cpp
  int m = sqrt(n) + 1;  // 分块阈值
  for (int i = 1; i < m; i++) {  // 小数部分完全背包
      for (int j = i; j <= n; j++) f[j] = (f[j] + f[j - i]) % p;
  }
  for (int i = 1; i < m; i++) {  // 大数部分特殊DP
      for (int j = i; j <= n; j++) 
          g[i][j] = (g[i][j - i] + (j >= m ? g[i - 1][j - m] : 0)) % p;
  }
  ```

### 2. memset0（5星）
- **亮点**：数学推导严谨，代码极简（仅11行），利用五边形数特性  
- **核心公式**：  
  $$p(n) = \sum (-1)^k \left( p(n - \frac{k(3k+1)}{2}) + p(n - \frac{k(3k-1)}{2}) \right)$$

### 3. StudyingFather（4星）  
- **亮点**：完整讲解五边形数定理的来龙去脉，附可视化生成函数展开示例  
- **个人心得**：  
  > "这道题的递推式看似复杂，但只要理解生成函数的展开原理，就能发现其本质是带符号项的累加"

---

## 最优技巧提炼

### 分块优化技巧
- **核心思想**：将拆分问题分为小值和大值两部分，分别用不同DP策略处理  
- **实现要点**：  
  1. 设定分块阈值 `m = sqrt(n)`  
  2. 小值部分（≤m）用完全背包计算所有可能组合  
  3. 大值部分（>m）用特殊DP记录拆分次数和总和  
  4. 合并时枚举小值部分的和，乘大值部分的对应方案数  

### 五边形数定理应用
- **关键公式**：  
  $$p(n) = \sum_{k=1}^{\infty} (-1)^{k+1} \left[ p(n - \frac{k(3k-1)}{2}) + p(n - \frac{k(3k+1)}{2}) \right]$$
- **实现步骤**：  
  1. 预计算所有广义五边形数  
  2. 按递推式交替加减对应项  
  3. 注意处理负数下标和取模边界  

---

## 同类型题推荐
1. **P1025 数的划分**（基础整数拆分）  
2. **P4389 付公主的背包**（生成函数与背包结合）  
3. **P5824 十二重计数法**（多重限制下的组合问题）

---

## 可视化算法演示

### 分块DP动画设计
```javascript
// 示例：分块处理的可视化
class SplitVisualizer {
  constructor(n) {
    this.m = Math.sqrt(n) | 0 + 1;
    this.smallDP = new Array(n+1).fill(0); // 小数部分DP
    this.largeDP = Array.from({length: this.m}, () => new Array(n+1).fill(0)); // 大数部分DP
  }

  // 渲染当前步骤的高亮元素
  highlightStep(stepType, i, j) {
    switch(stepType) {
      case 'small_add': 
        drawHighlight(j, 'blue');  // 背包新增项
        drawArrow(j-i, j);         // 显示转移来源
        break;
      case 'large_increment':
        drawHighlight(j, 'green'); // 大数部分递增
        break;
    }
  }
}
```

### 复古像素风格演示
- **颜色方案**：16色调色板（NES样式），背包操作用蓝色闪烁，五边形数项用红色标记  
- **音效设计**：  
  - `f[j] += f[j-i]` 时播放短促 "beep" 音  
  - 完成一个分块时播放 8-bit 胜利音效  
- **自动演示**：按递推顺序逐步高亮操作项，支持暂停/加速  

---

## 代码实现（分块DP核心）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;

int f[N], g[500][N]; // g[i][j]: 使用i个≥m的数组成j

int main() {
    int n, p, m = sqrt(n) + 1;
    cin >> n >> p;
    
    // 处理小数部分（完全背包）
    f[0] = 1;
    for (int i = 1; i < m; ++i) 
        for (int j = i; j <= n; ++j) 
            f[j] = (f[j] + f[j - i]) % p;
    
    // 处理大数部分（特殊DP）
    g[0][0] = 1;
    for (int i = 1; i < m; ++i)
        for (int j = m; j <= n; ++j) {
            g[i][j] = g[i][j - i]; // 所有数+1
            if (j >= m) g[i][j] = (g[i][j] + g[i-1][j-m]) % p; // 新增一个m
        }
    
    // 合并结果
    int ans = 0;
    for (int i = 0; i <= n; ++i) {
        int sum = 0;
        for (int j = 0; j < m; ++j)
            sum = (sum + g[j][n - i]) % p;
        ans = (ans + 1LL * f[i] * sum) % p;
    }
    cout << ans;
}
```

---
处理用时：78.09秒
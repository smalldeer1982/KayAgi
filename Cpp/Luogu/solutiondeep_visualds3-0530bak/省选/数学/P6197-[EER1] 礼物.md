# 题目信息

# [EER1] 礼物

## 题目背景

### Update：

时限扩大到 3 秒。

## 题目描述

小 Z 送了你一个数列，具体的，有 $a_1=1$，$a_2=2$，$a_i=2a_{i-1}+ka_{i-2}(3\le i\le n)$，其中 $n$ 是数列的长度，$k$ 是她设定的一个正整数参数。

小 Z 告诉你一个秘密，这个数列是她精心挑选的，有着一种奇妙的性质 "Prime-smooth"—— 即对于 $n$ 以内的任何一个**质数** $p$，满足 $p\mid a_p$（$\mid$ 是整除记号）。

你很好奇是不是真的有这回事，于是你写了一个质数发生器，进行了长达三天三夜的尝试，终于发现了几个反例：有 $m$ 个质数 $p_i$ 竟然不满足小 Z 所说的性质！

由于你已经随机了很久，你相信别的质数 **一定满足** 性质。

为了表明你和小 Z 心有灵犀，你现在想猜出小 Z 当时设定的参数 $k$，由于答案很大，你只需要求出最小的 $k$ 对一个质数 $c$ 取模即可。

## 说明/提示

**【样例 1 解释】**

注意第 $3$ 个质数是 $5$。

当 $k=20$ 时，$a_2=2$，$a_3=24$，$a_7=19264$ 均符合 $p\mid a_p$，并且 $a_5=656$ 符合 $p\nmid a_p$。

**【数据范围】**

$10\le n\le 3\times 10^8$。

$n\lt c\lt 2^{30}$，$c=a\cdot 2^d+1(d\ge 18)$，保证 $c$ 是质数。

$0\le m\le 20$。

| 子任务编号 |    $n\leq$     |    $m\leq$     | 特殊性质 | 分值 |
| :--------: | :------------: | :------------: | :------------: | :--: |
|     1      | $10^6$ | $20$ ||  10   |
|     2      | $5\times 10^7$ | $20$ ||  20  |
|     3      | $2\times 10^8$ | $0$ ||  10  |
|     4      | $2\times 10^8$ | $6$ ||  10  |
|     5      | $3\times 10^8$ | $0$ | $c=998244353$ |  20  |
|     6      | $3\times 10^8$ | $0$ ||  20  |
|     7      | $3\times 10^8$ | $20$ ||  10  |

## 样例 #1

### 输入

```
10 1 998244353
3```

### 输出

```
20```

## 样例 #2

### 输入

```
40 2 1018429441
1
4```

### 输出

```
-1```

# AI分析结果



**唯一算法分类**：数论与筛法

---

### **题解思路与核心难点**
1. **数学推导**  
   - 所有题解均基于特征方程法推导通项：  
     $$a_n = \frac{(1+\sqrt{k+1})^n - (1-\sqrt{k+1})^n}{2\sqrt{k+1}}$$  
   - 利用二项式定理展开后，结合质数性质 $p \mid \binom{p}{i} \ (0<i<p)$，得出关键结论：  
     $$a_p \equiv (k+1)^{(p-1)/2} \mod p$$  
     → 当且仅当 $k \equiv -1 \mod p$ 时，$p \mid a_p$  
   - **核心结论**：$k+1$ 需为所有满足条件的质数的乘积，故 $k = (\prod p_i) - 1$。

2. **筛法优化**  
   - **核心难点**：$n \leq 3 \times 10^8$ 时，传统筛法需优化空间与时间。  
   - **解法对比**：  
     - **iostream**：位压缩埃氏筛（筛除偶数、3倍数，分块处理质数平方项）  
     - **VinstaG173**：线性筛+布尔数组，优化循环展开与质数乘积计算  
     - **zzy2333**：bitset筛法+循环展开，特判2的倍数加速  

3. **例外处理**  
   - 对给定的 $m$ 个例外质数，需在乘积中排除。  
   - **实现关键**：将例外质数排序后，遍历筛出的质数列表时跳过对应位置。

---

### **题解评分（≥4星）**
1. **作者：iostream（★★★★★）**  
   - **亮点**：结合数学证明与高效筛法，代码采用位压缩节省空间，分块处理筛法逻辑清晰。  
   - **优化点**：埃氏筛变种筛除特定形式的合数，时间复杂度 $O(n \log \log n)$。

2. **作者：WYXkk（★★★★☆）**  
   - **亮点**：完整数学推导，使用线性筛实现简洁，适合较小规模的 $n$。  
   - **不足**：线性筛空间复杂度 $O(n)$ 不适用于 $n=3e8$，需优化内存。

3. **作者：VinstaG173（★★★★☆）**  
   - **亮点**：代码简洁，使用线性筛并特判2的倍数，结合快速幂求逆元。  
   - **优化点**：布尔数组标记非质数，动态计算乘积时跳过例外。

---

### **最优思路提炼**
1. **数学建模**：通过特征方程和质数性质将问题转化为求质数乘积。  
2. **筛法优化**：  
   - **位压缩存储**：用 `uint64_t` 数组标记合数，节省内存至 $\frac{n}{128}$。  
   - **分块筛除**：按质数平方项分块处理，减少重复计算（如筛除 $p^2+6kp$ 形式）。  
3. **例外处理**：排序后双指针遍历，跳过指定质数位置。

---

### **同类型题与算法套路**
- **质数筛法优化**：P3912（质数统计）、SPOJ PRIME1（区间筛法）  
- **递推数列性质**：P1306（斐波那契公约数）、P5175（数列取模）  
- **中国剩余定理**：P1495（曹冲养猪）

---

### **可视化与复古动画设计**
#### **核心算法演示**
1. **筛法过程动画**  
   - **像素网格**：Canvas绘制 $n$ 个方块，初始为白色（质数），标记合数为黑色。  
   - **高亮当前质数**：红色方块表示当前处理的质数 $p$，绿色闪烁其倍数被筛除。  
   - **音效**：  
     - 筛除合数时播放“哔”声（Web Audio API合成8bit音效）。  
     - 发现新质数时播放“叮”声。  

2. **乘积计算演示**  
   - **滚动乘积面板**：右侧显示当前乘积值，例外质数以红色显示并打叉。  
   - **动态更新**：每选中一个质数，面板数值更新并播放金币音效。

#### **复古风格实现**
- **调色板**：16色FC风格（红、绿、黑、白为主）。  
- **自动演示模式**：  
  - 按质数大小自动推进，间隔速度可调（100ms~2s）。  
  - “AI模式”下，质数按顺序快速筛选，最终显示乘积结果。  

```javascript
// 示例：Canvas绘制筛法过程（伪代码）
const canvas = document.getElementById('sieve-canvas');
const ctx = canvas.getContext('2d');
let primes = [];

function drawGrid() {
  for (let i = 0; i < n; i++) {
    const x = (i % 100) * 4; // 每行100个，4px方块
    const y = Math.floor(i / 100) * 4;
    ctx.fillStyle = isPrime(i) ? '#FFF' : '#000';
    ctx.fillRect(x, y, 3, 3);
  }
}

function highlightPrime(p) {
  // 红色闪烁当前质数
  ctx.fillStyle = '#F00';
  ctx.fillRect((p % 100)*4, Math.floor(p/100)*4, 3, 3);
  setTimeout(() => drawGrid(), 200);
}
```

---

### **代码实现核心**
#### **位压缩埃氏筛（iostream思路）**
```cpp
struct bitst {
    uint64_t buf[300000000/128]; // 位压缩存储
    bool operator[](int x) { return buf[x>>6] & (1ULL << (x&63)); }
    void set(int x) { buf[x>>6] |= 1ULL << (x&63); }
}v;

void sieve() {
    v.set(0); // 标记非质数
    for (int i = 3; i*i <= n; i += 2) {
        if (!v[i]) {
            for (int j = i*i; j <= n; j += 2*i)
                v.set(j>>1); // 仅处理奇数
        }
    }
}
```

#### **质数乘积计算**
```cpp
int ans = 1;
for (int i = 0; i < total_primes; i++) {
    if (is_excluded(primes[i])) continue;
    ans = (1LL * ans * primes[i]) % mod;
}
ans = (ans - 1 + mod) % mod; // 输出k
```

---

### **个人心得摘录**
- **WYXkk**：线性筛在 $n=3e8$ 时内存不足，需改用位压缩筛法。  
- **zzy2333**：bitset筛法因缓存不友好导致TLE，改用布尔数组后通过。  
- **VinstaG173**：特判2的倍数后，筛法速度显著提升。

---
处理用时：73.47秒
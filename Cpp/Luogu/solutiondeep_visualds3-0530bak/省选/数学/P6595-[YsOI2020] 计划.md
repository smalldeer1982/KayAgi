# 题目信息

# [YsOI2020] 计划

## 题目背景

相信大家已经知道了这样几个事实：  
- Ysuperman 是很有钱。

- Ysuperman 一直都很善于制定计划。

- Ysuperman 管理着一个幼儿园。

- Ysuperman 收藏了一些零食。

- 每一天，TA 可能会心血来潮地想要有计划地吃掉 TA 的零食。


## 题目描述

Ysuperman 现在有 $n$ 份零食，对**每份**零食而言，TA 每一天有 $P$ 的概率对 TA 的这份零食做出计划，TA 每做出一份计划后的 $T$ 天后，TA 将会将这一份零食给吃掉。需要特殊说明的是，如果在Ysuperman制定计划前已经对该份零食做出计划，则实际会按照**第一份计划的时间**将零食吃掉。

不幸的是，幼儿园内贪吃的小朋友会破坏这一计划。  幼儿园内有 $m$ 个小朋友，TA 们觊觎着 Ysuperman 的零食。对于**每份**零食，每天会有 $p_i$ 的概率被第 $i$ 个小朋友偷吃。如果这份零食在某位小朋友偷吃之前被吃掉了，那么相应地，这位小朋友就偷吃不了。**如果有一份零食在计划完成前被偷吃，那么，相关计划就无法实现了。**

现在 Ysuperman 要对 TA 的计划进行风险评估，TA 悬赏了 $114514pts$ ，这个项目在经过层层转包后来到了您的手上，现在已经算出了各概率在模意义下的值。经过各方协商，您如果解决了这个问题，您可以获得 $ 100pts $ 。您需要告诉 TA **Ysuperman 能期望吃掉多少份零食，以及 Ysuperman 的零食期望在多少天后被吃完** 。

**如果一份零食被某位小朋友吃掉了，那么这份零食就不属于Ysuperman了。**

需要注意的是，Ysuperman每天制定计划的时间在小朋友偷吃糖果**之前**。

Ysuperman 认为浮点数的精度误差太大，所以你只需要输出答案**对 $998244353$ 取模**的结果。

## 说明/提示

### 样例说明

#### 样例说明 $1$:

在取模前的其中一种可能情况为：
```cpp
5 8 11  
0.1  
0.1 0.2 0.3 0.4 0.5 0.6 0.7 1
```
该情况下，小朋友会在第一天中偷吃完所有的零食。

#### 样例说明 $2$:

在取模前的一种可能情况为：
```cpp
3 5 0  
1  
1 1 1 1 1
```

该情况下，Ysuperman 会在第一天计划并吃完所有的零食。

#### 样例说明 $3$:

在取模前的一种可能的情况为：

```cpp
2 2 0  
0.5  
0.5 0.5
```
在此情况下，答案为 $\dfrac{8}{7}$ 和 $\dfrac{80}{63}$。

由于解答过程较为复杂，所以请聪明的读者自行思考。


------------
### 数据范围

**如果您只答对了某个测试点两问中的任意一问，您可以获得这个测试点 $ 25\% $ 的分数。**

以下是致敬 $\text{NOI}$ 的部分分表格：
| 测试点编号 | $n$ | $m$ | $T$ | $P$ | 特殊性质 |
| :-----------: | -----------: | -----------: | -----------: | -----------: | :-----------: |
| 1 | $=1$ | $=1$ | $=0$ | 无其它约束 | 无 |
| 2 | $=1$ | $=10$ | $=1$ | $=1$ | $1$ |
| 3 | $=1$ | $\le100$ | $=227$ | $=1$ | $2$ |
| 4 | $\le 20$ | $\le 1000$ | $=4$ | 无其它约束 | 无 |
| 5 | $\le 100$ | $\le 1000$ | $=4$ | 无其它约束 | 无 |
| 6 | $\le 1000$ | $\le 1000$ | $=227$ | $=0$ | $1$ |
| 7 | $\le 100000$ | $\le 100000$ | $=233$ | $=1$ | $2$ |
| 8 | $\le1919820$ | $=114514$ | $=2333$ | $=0$ | $2$ |
| 9 | $\le1919820$ | $=114514$ | $=2333$ | $=0$ | $2$ |
| 10 | $=100000$ | $=100000$ | $=3$ | 无其它约束 | $2$ |
| 11 | $=114514$ | $=114514$ | $=3$ | 无其它约束 | 无 |
| 12 | $\le1919820$ | $=114514$ | $=0$ | 无其它约束 | $2$ |
| 13 | $\le 1919820$ | $=1$ | $\le 227$ | 无其它约束 | 无 |
| 14 | $\le 1919820$ | $\le114514$ | $\le 227$ | 无其它约束 | $2$ |
| 15 | $\le 1919820$ | $=1$ | $\le 500$ | $=1$ | 无 |
| 16 | $\le 1919820$ | $\le 114514$ | $\le 500$ | $=1$ | 无 |
| 17 | $\le 1919820$ | $\le 114514$ | $\le 500$ | $=1$ | 无 |
| 18 | $\le 1919820$ | $\le 114514$ | $=0$ | 无其它约束 | 无 |
| 19 | $\le 1919820$ | $\le 114514$ | $=0$ | 无其它约束 | 无 |
| 20 | $\le 100000$ | $\le 100000$ | $\le 500$ | 无其它约束 | $2$ |
| 21 | $\le 100000$ | $\le 100000$ | $\le 500$ | 无其它约束 | 无 |
| 22 | $\le 100000$ | $\le 100000$ | $\le 500$ | 无其它约束 | 无 |
| 23 | $\le 1919820$ | $\le 114514$ | $\le 2333$ | 无其它约束 | 无 |
| 24 | $\le 1919820$ | $\le 114514$ | $\le 2333$ | 无其它约束 | 无 |
| 25 | $\le 1919820$ | $\le 114514$ | $\le 2333$ | 无其它约束 | $2$ |

对于 $100\%$ 的数据，满足 $ 1\le n\le 1919820,1\le m \le 114514,0\le T \le 2333,0\le P< 998244353,1\le p_i<998244353$


特殊性质 $1$：存在一个 $i$ 使得$p_i=1$。

特殊性质 $2$：所有的 $p_i$ 都相等。

## 样例 #1

### 输入

```
5 8 11
13482572 
299473306 598946612 898419918 199648871 499122177 798595483 99824436 1```

### 输出

```
0 1```

## 样例 #2

### 输入

```
3 5 0
1
1 1 1 1 1```

### 输出

```
3 1```

## 样例 #3

### 输入

```
2 2 0
499122177
499122177 499122177```

### 输出

```
855638018 507044752```

## 样例 #4

### 输入

```
11 4 514
1919810
1919810 1919810 1919810 1919810```

### 输出

```
550831570 75142974```

## 样例 #5

### 输入

```
100000 20 227
2020
2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019```

### 输出

```
808786679 861511854```

# AI分析结果



**算法分类**  
概率与期望、组合数学

---

### 题解思路与核心分析

#### **关键模型转换**
1. **存活概率计算**：所有小朋友每天偷吃概率的乘积为 $q = \prod (1-p_i)$，表示每天未被偷吃的概率。
2. **时间分阶段处理**：
   - **前 $T$ 天**：Ysuperman制定计划后未被偷吃的概率为 $q^T$。
   - **$T+1$ 天后**：Ysuperman和小朋友同时作用，存活概率为 $u = (1-P)q$（$P$ 为制定计划概率）。

#### **第一问：期望吃掉的零食数**
- **单个零食贡献**：$P \cdot q^T \cdot \sum_{i=0}^\infty u^i = \frac{P \cdot q^T}{1 - u}$。
- **总期望**：$n \cdot \frac{P \cdot q^T}{1 - u}$，通过逆元处理模运算。

#### **第二问：期望吃完时间**
- **Min-Max 容斥**：将最晚时间转化为子集最早时间的加权和：
  $$E[\max(S)] = \sum_{k=1}^n (-1)^{k+1} \binom{n}{k} E[\min(T_k)]$$
- **子集期望计算**：
  - **前 $T$ 天**：存活概率为 $q^k$，期望时间通过等比数列求和。
  - **之后时间**：存活概率为 $u^k$，求和后合并为 $\frac{u^k}{1 - u^k}$。

---

### 题解对比与评分

#### **lmAKf 题解（⭐⭐⭐⭐⭐）**
- **亮点**：代码简洁，直接应用组合数预处理和容斥；通过逆元快速处理分数模运算。
- **核心代码段**：
  ```cpp
  int Tk = fpow(q, T) * n % P;
  int u = (1 - p + P) * q % P;
  ans1 = (Tk * p) % P * fpow(1 - u + P, P - 2) % P;
  ```
- **难点处理**：正确推导存活概率的闭合式，并通过组合数快速枚举子集大小。

#### **Iratis 题解（⭐⭐⭐⭐）**
- **亮点**：详细推导概率分阶段表达式，数学步骤清晰。
- **核心公式**：
  $$g(S) = \sum_{i=1}^T q^{k(i-1)}(1-q^k)i + \sum_{i=T+1}^\infty q^{kT} u^{k(i-T-1)}(1-u^k)i$$
- **优化**：通过级数求和公式化简，避免直接计算无穷项。

#### **clamee 题解（⭐⭐⭐）**
- **亮点**：尝试分步处理每个子集的贡献，但实现复杂度较高。
- **代码片段**：
  ```cpp
  int sol(int p, int q) {
      int t = qpow((1 - p + M) % M, T);
      int re = ((1 - t) * inv[p] - t * T) % M;
      // ... 合并后处理
  }
  ```

---

### 最优思路提炼
1. **存活概率分治**：前 $T$ 天和之后的时间分别处理，利用等比数列求和。
2. **Min-Max 容斥**：通过枚举子集大小，利用组合数学符号和逆元快速计算。
3. **逆元优化**：将概率除法转换为模逆元乘法，确保模运算正确性。

---

### 同类题目推荐
1. **P3175 [HAOI2015]按位或**：Min-Max 容斥处理集合覆盖期望。
2. **P5644 [PKUWC2018]随机游走**：结合容斥与树上期望计算。
3. **P3239 [HNOI2015]亚瑟王**：独立事件概率的多次贡献求和。

---

### 可视化设计
- **动画逻辑**：
  1. **时间轴分块**：前 $T$ 天用绿色表示存活，之后用黄色渐变表示概率衰减。
  2. **容斥演示**：动态显示子集大小变化，红色高亮当前计算的子集贡献。
- **像素风格**：
  - **颜色方案**：8-bit 调色板，绿色（存活）、红色（被偷吃）、黄色（Ys吃掉）。
  - **音效触发**：关键时间点（如计划制定、偷吃事件）触发短促音效。

---

### 代码实现（关键逻辑）
```cpp
// 预处理阶乘与逆元
fac[0] = inv[0] = 1;
for (int i = 1; i <= n; ++i) {
    fac[i] = fac[i-1] * i % P;
    inv[i] = fpow(fac[i], P-2);
}

// 计算第一问答案
int q = 1;
for (int i = 1; i <= m; ++i)
    q = q * (1 - p[i] + P) % P;
int ans1 = n * fpow(q, T) % P * P % P;
ans1 = ans1 * fpow(1 - (1-P)*q % P + P, P-2) % P;

// 计算第二问答案
int ans2 = 0;
for (int k = 1; k <= n; ++k) {
    int sign = (k % 2) ? 1 : -1;
    int Cnk = fac[n] * inv[k] % P * inv[n-k] % P;
    int term = calc_min_time(k) * Cnk % P;
    ans2 = (ans2 + sign * term + P) % P;
}
```

---

**总结**：本题通过概率分阶段处理与 Min-Max 容斥，将复杂期望问题拆解为可计算的模块。核心在于存活概率的闭合式推导与组合数学的高效实现。

---
处理用时：170.06秒
# 题目信息

# [省选联考 2020 A 卷] 作业题

## 题目描述

小 W 刚刚在离散数学课学习了生成树的知识：一个无向图 $G=(V,E)$ 的生成树 $T$ 为边集 $E$ 的一个大小为 $|V|-1$ 的子集，且保证 $T$ 的生成子图在 $G$ 中连通。

小 W 在做今天的作业时被这样一道题目难住了：

给定一个 $n$ 个顶点 $m$ 条边（点和边都从 $1$ 开始编号）的无向图 $G$，保证图中无重边和无自环。每一条边有一个正整数边权 $w_i$，对于一棵 $G$ 的生成树 $T$，定义 $T$ 的价值为：$T$ 所包含的边的边权的最大公约数乘以边权之和，即：

$$
val(T)=\left(\sum\limits_{i=1}^{n-1} w_{e_i}\right) \times \gcd(w_{e_1},w_{e_2},\dots,w_{e_{n-1}})
$$

其中 $e_1,e_2,\dots,e_{n-1}$ 为 $T$ 包含的边的编号。

小 W 需要求出 $G$ 的所有生成树 $T$ 的价值之和，他做了很久也没做出来，请你帮帮他。由于答案可能很大，你只需要给出答案对 $998244353$ 取模后的结果。

## 说明/提示

【样例解释 $1$】

$G$ 共有三棵生成树：

$T_1=\{(1,2),(2,3)\}$，价值为 $10\times 2=20$。

$T_2=\{(1,2),(1,3)\}$，价值为 $16\times 4=64$。

$T_3=\{(1,3),(2,3)\}$，价值为 $18\times 6=108$。

总和为 $192$。

【数据规模】

$10\%$ 的数据满足：$m\leq 15$。

另有 $20\%$ 的数据满足：$m \leq n$。

另有 $20\%$ 的数据满足：$w_i$ 均相同。

另有 $20\%$ 的数据满足：$w_i$ 均为质数。

$100\%$ 的数据满足：$1\leq n\leq 30, 1\leq m \leq \frac {n(n-1)}{2}, 1\leq w_i \leq 152501$。

## 样例 #1

### 输入

```
3 3
1 2 4
2 3 6
1 3 12```

### 输出

```
192```

# AI分析结果



**唯一算法分类**：数论与图论（欧拉反演 + 矩阵树定理）

---

### **题解思路与核心难点解析**

1. **核心思路**  
   所有题解均采用「欧拉反演 + 矩阵树定理」的组合策略：
   - **欧拉反演**：将 $\gcd$ 转换为 $\sum \varphi(d)$，枚举因数 $d$ 后仅保留边权为 $d$ 倍数的边。
   - **矩阵树定理**：通过多项式运算模拟边权和，将边权 $w$ 转化为一次函数 $1 + wx$，在模 $x^2$ 意义下计算行列式的一次项系数。

2. **算法要点**  
   - **多项式运算**：定义一次函数的加减乘除（模 $x^2$），重点在逆元计算 $(a+bx)^{-1} = \frac{1}{a} - \frac{b}{a^2}x$。
   - **剪枝优化**：仅当 $d$ 的倍数边数 $\geq n-1$ 时才进行矩阵计算。
   - **行列式求法**：高斯消元处理多项式矩阵，最终提取一次项系数。

3. **解决难点**  
   - **边权和转积和**：传统矩阵树求积和，通过一次项模拟加和。
   - **多项式运算稳定性**：正确处理零系数和行列式交换符号。

---

### **题解评分（≥4星）**

1. **Froggy 的题解（⭐️⭐️⭐️⭐️⭐️）**  
   - **亮点**：步骤清晰，代码完整，引入一次函数推导，剪枝处理优化时间复杂度。
   - **代码片段**：
     ```cpp
     pii operator/(const pii a, const pii b) {
         int inv = qpow(b.first, mod-2);
         return {a.first * inv % mod, ...};
     }
     ```

2. **1saunoya 的题解（⭐️⭐️⭐️⭐️）**  
   - **亮点**：详细推导一次项系数原理，强调多项式逆元的数学逻辑。
   - **心得摘录**：“把边权写成一次函数，最后答案就是行列式的一次项系数，这种转换非常巧妙。”

3. **s_r_f 的题解（⭐️⭐️⭐️⭐️）**  
   - **亮点**：代码模块化，分离多项式运算与矩阵处理，适合教学。
   - **代码结构**：独立 `Poly` 类封装运算，提高可读性。

---

### **最优技巧提炼**

1. **一次函数模拟加法**  
   边权 $w$ 转换为 $1 + wx$，乘积的一次项系数自然累加边权和。

2. **因数枚举剪枝**  
   预处理每个 $d$ 的可用边数，仅处理可能构成生成树的 $d$ 值，复杂度优化至 $O(n^3 \cdot \max \sigma_0(w))$。

3. **多项式逆元快速计算**  
   使用 $\frac{1}{a+bx} \equiv \frac{1}{a} - \frac{b}{a^2}x \pmod{x^2}$，避免复杂多项式逆运算。

---

### **同类题目推荐**

1. **[P3317 [SDOI2014] 重建](https://www.luogu.com.cn/problem/P3317)**  
   （矩阵树定理求生成树概率积）

2. **[P5296 [北京省选集训2019] 生成树计数](https://www.luogu.com.cn/problem/P5296)**  
   （结合边权和的扩展应用）

3. **[P4208 [JSOI2008] 最小生成树计数](https://www.luogu.com.cn/problem/P4208)**  
   （矩阵树定理与最小生成树性质结合）

---

### **可视化算法设计**

1. **核心动画流程**  
   - **矩阵元素高亮**：用不同颜色表示当前消元行、主元列和非零元素。
   - **多项式运算展示**：动态绘制 $(a+bx)(c+dx)$ 的展开过程，突出一次项生成。
   - **音效提示**：  
     - 成功找到主元时播放「叮」声，消元步骤播放「咔哒」声。
     - 最终提取系数时触发胜利音效。

2. **复古像素风格**  
   - **8位色板**：矩阵背景用深蓝，当前操作用亮黄，多项式运算步骤用红绿闪烁。
   - **Canvas 绘制**：矩阵以网格呈现，每个单元格显示形如 "a+bx" 的像素文字。

3. **交互控制**  
   - **步进执行**：用户可逐行观察高斯消元过程，按空格键继续。
   - **自动演示**：AI模式自动播放，速度可调，适合教学演示。

---

### **核心代码片段（高斯消元部分）**

```cpp
pii Gauss(int n) {
    pii res = {1, 0};
    bool rev = false;
    for (int i = 1; i <= n; ++i) {
        // 寻找主元并交换行
        if (!g[i][i].b) { /* 高亮此步骤 */ }
        // 消元操作
        pii inv = {1, 0} / g[i][i];
        for (int j = i+1; j <= n; ++j) {
            pii factor = g[j][i] * inv;
            for (int k = i; k <= n; ++k)
                g[j][k] = g[j][k] - factor * g[i][k];
        }
        res = res * g[i][i];
    }
    return rev ? -res : res;
}
```

---

**总结**：本题通过数论与图论的深度结合，展现了矩阵树定理的灵活应用，而可视化设计则能直观呈现多项式运算与高斯消元的精妙交互。

---
处理用时：73.23秒
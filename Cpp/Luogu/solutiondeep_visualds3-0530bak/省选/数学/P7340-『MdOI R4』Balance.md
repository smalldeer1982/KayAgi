# 题目信息

# 『MdOI R4』Balance

## 题目背景

可怜的 $\rm\textcolor {grey}{JohnVictor}$ 玩的卡组在平衡性调整中被削弱了，现在他掉了很多杯，他想知道什么样的一个世界才是真正平衡的。

于是就有了这题。

## 题目描述

给定长度为 $n$ 的，由整数构成的数组 $a,b,p,q$，并定义函数 $f(i,j)=\dfrac{a_i+b_j}{p_i+q_j}(1\le i,j\le n)$。

再给定两个整数 $x,y$，你需要求出一对 $(i,j)$，使得 $f(i,j)$ 在所有 $f(i,t)(t=1,2,\cdots,n)$ 中是第 $x$ 小的，在所有 $f(s,j)(s=1,2,\cdots,n)$ 中是第 $y$ 小的。 

在本题中，我们称一个数 $x$ 在序列 $c_{1\ldots n}$ 中是第 $k$ 小的，当且仅当在 $c$ 中有且仅有 $\alpha$ 个数 $y$ 满足 $y<x$，且有且仅有 $\beta$ 个数 $y$ 满足 $y\le x$，同时 $\alpha<k\le \beta$。

如果不存在这样的 $(i,j)$，请输出 `0 0`。

如果有多组这样的 $(i,j)$，输出任意一组即可。

由于平衡性的问题不是一次就能问清楚的，所以出题人会问你多次。

## 说明/提示

【样例解释 #1】
- $f(1,1)=1.2;f(1,2)=1.2;f(1,3)=1.25$。
- $f(2,1)=2;f(2,2)=2;f(2,3)=2\frac{1}{6}$。
- $f(3,1)=1;f(3,2)=1;f(3,3)=1$。

$f(1,3)$ 在 $f(1,1),f(1,2),f(1,3)$ 中是第 $3$ 小的，$f(1,3)$ 在 $f(1,3),f(2,3),f(3,3)$ 中是第 $2$ 小的。

【数据规模与约定】

**本题采用捆绑测试**

| 子任务编号 | $\sum n\le$         | $\vert a_i\vert ,\vert b_i\vert ,p_i,q_i\le$ | $(x,y)= $  | 分值  |
| ---------- | -------------- | -------------------- | ---------- | ----- |
| $1$        | $5\times 10^3$ | 无特殊限制           | 无特殊限制 | $10$  |
| $2$        | 无特殊限制     | $3$                  | 无特殊限制 | $10$  |
| $3$        | $10^5$         | 无特殊限制           | $(1,n)$        | $30 $ |
| $4$        | $10^5$         | 无特殊限制           | 无特殊限制 | $20$  |
| $5$        | 无特殊限制     | 无特殊限制           | 无特殊限制 | $30$  |

对于 $100\%$ 的数据，$1 \le x,y \le n \le 5 \times 10^5$，$\sum n \le 5 \times 10^5$，$|a_i|,|b_i|\le 10^9$，$0<p_i,q_i\le 10^9$，其中 $\sum n $ 表示所有数据中 $n$ 的和。

【提示与帮助】

本题读入量较大，请选手选择较快的读入方式。

## 样例 #1

### 输入

```
1
3 3 2
2 4 1 4
10 4 3 4
1 3 1 3
```

### 输出

```
1 3
```

# AI分析结果



---

**唯一算法分类**  
二分答案 + 分数规划

---

### 题解思路与算法要点

1. **核心思想**  
   将原问题转化为分数规划问题，通过二分法确定目标值 $z$，使得存在 $(i,j)$ 满足：  
   - 在 $i$ 的行中，$f(i,j)$ 是第 $x$ 小  
   - 在 $j$ 的列中，$f(i,j)$ 是第 $y$ 小  
   通过构造 $x_i = a_i - z \cdot p_i$ 和 $y_j = b_j - z \cdot q_j$，转化为判断 $x_i + y_j \geq 0$ 的条件。

2. **关键步骤**  
   - **二分框架**：在极大值范围内二分 $z$，每次计算 $x_i$ 和 $y_j$  
   - **快速选择**：用 `nth_element` 快速找到排序后的第 $x$ 和 $y$ 小的元素  
   - **符号判断**：若 $x_i + y_j \geq 0$，调整二分边界，最终确定解

3. **解决难点**  
   - **分数规划转化**：将分式比较转化为线性组合符号判断  
   - **高效排序处理**：通过 `nth_element` 实现 $O(n)$ 的中间值选择  
   - **正确性证明**：在连续变化的 $z$ 中，必存在满足条件的临界点

---

### 题解评分（≥4星）

1. **JohnVictor 题解（5星）**  
   - 思路清晰，详细推导分数规划转化过程  
   - 代码简洁，直接体现二分和快速选择核心逻辑  
   - 无冗余操作，可读性强  

2. **VinstaG173 题解（5星）**  
   - 代码最精简，直接聚焦核心逻辑  
   - 使用 `long double` 避免精度问题  
   - 包含正确性说明，逻辑严谨  

3. **双管荧光灯 题解（4星）**  
   - 几何视角新颖，但代码复杂度较高  
   - 涉及额外坐标变换，增加理解难度  
   - 实现正确但不够直观  

---

### 最优思路提炼

1. **分数规划技巧**  
   将分式 $f(i,j) = \frac{a_i + b_j}{p_i + q_j}$ 转化为线性组合 $x_i + y_j \geq 0$，其中 $x_i = a_i - z \cdot p_i$，$y_j = b_j - z \cdot q_j$。  
2. **二分答案框架**  
   通过二分确定 $z$ 的临界值，使得存在 $(i,j)$ 满足排名条件。  
3. **快速选择优化**  
   用 `nth_element` 实现 $O(n)$ 时间复杂度，避免完全排序的 $O(n \log n)$ 开销。

---

### 同类型题与算法套路

1. **分数规划问题**  
   - POJ2976（Dropping tests）  
   - 洛谷P4377（Talent Show）  
2. **二分答案+快速选择**  
   - 洛谷P3382（三分法模板）  
3. **二维排序优化**  
   - 洛谷P4058（木材加工）

---

### 可视化设计

1. **动画方案**  
   - **二分过程**：用滑动条表示当前 $z$ 值，动态更新 $x_i$ 和 $y_j$ 的分布  
   - **快速选择**：高亮被 `nth_element` 选中的元素，展示其在数组中的位置  
   - **符号判断**：用红/蓝颜色区分满足 $x_i + y_j \geq 0$ 的格子  

2. **复古像素风格**  
   - **8位色彩**：红色表示 $x_i$ 数组，蓝色表示 $y_j$ 数组  
   - **音效触发**：每次二分命中时播放上升音调，解确定时播放胜利音效  
   - **Canvas网格**：绘制 $n \times n$ 网格，黑色表示满足条件的 $(i,j)$  

3. **交互控制**  
   - 步进按钮：单步执行二分迭代  
   - 速度调节：控制二分步频  
   - 自动模式：AI 自动完成二分流程

---

### 核心代码实现

```cpp
// VinstaG173 题解代码（核心逻辑）
struct node { int a,p,id; long double vl; };
node tx[N], ty[N];
bool cmp(node xx, node yy) { return xx.vl < yy.vl; }

int main() {
    scanf("%d", &T);
    while(T--) {
        scanf("%d %d %d", &n, &y, &x);
        // 初始化 tx 和 ty 数组...
        long double l = -1e14, r = 1e14;
        while(r - l > 1e-14) {
            long double m = (l + r) / 2;
            // 计算 x_i = a_i - m*p_i, y_j = b_j - m*q_j
            for(int i=1; i<=n; ++i) {
                tx[i].vl = tx[i].a - tx[i].p * m;
                ty[i].vl = ty[i].a - ty[i].p * m;
            }
            // 快速选择第x和y小的元素
            nth_element(tx+1, tx+x, tx+n+1, cmp);
            nth_element(ty+1, ty+y, ty+n+1, cmp);
            // 判断符号并调整边界
            if(tx[x].vl + ty[y].vl >= 0) {
                l = m; u = tx[x].id; v = ty[y].id;
            } else r = m;
        }
        printf("%d %d\n", u, v);
    }
}
```

---

### 个人心得

- **调试教训**：初始二分范围过小会导致无法覆盖极端情况，需根据数据范围合理设定  
- **顿悟点**：通过分数规划将二维排名问题转化为一维线性组合，是本题的解题关键  
- **优化技巧**：`nth_element` 的正确使用大幅降低时间复杂度，避免不必要的排序

---
处理用时：91.98秒
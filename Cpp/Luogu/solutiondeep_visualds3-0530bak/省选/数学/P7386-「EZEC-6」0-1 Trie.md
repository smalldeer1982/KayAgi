# 题目信息

# 「EZEC-6」0-1 Trie

## 题目背景

> $\mathbf{000111}$，这就是简单中所蕴含的优美。

众所周知，tlx 不会字符串。

## 题目描述

现在 tlx 有 $n$ 个 $\mathbf{1}$ 和 $m$ 个 $\mathbf{0}$，你需要把它们排列，但要保证任意的 $\mathbf{1}$ 互不相邻且第一个位置是 $\mathbf{0}$、最后一个位置是 $\mathbf{1}$，现在把所有可以构造出的串放到一棵 0-1 Trie 上，需要多少个节点？

**注意：节点计数时，不计算最开始的空节点，只计算代表“ $\mathbf{0}$ ”、“ $\mathbf{1}$ ”的节点。**  

**在本题中，我们认为用节点存储字符而非边， Trie 基本原理不变。**

因为答案可能很大而且询问较多，所以请在最后输出所有询问的答案对 $18888913$ （放心，是个质数）取模的结果的异或和（**异或和不再进行取模**）。

## 说明/提示

**【样例解释 #1】**

可以发现，所有能构造出的串有：  

$$\mathbf{000101}$$
$$\mathbf{001001}$$
$$\mathbf{010001}$$

构造 0-1 Trie，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/aql3bwo6.png)

共需 $15$ 个节点。


**【样例解释 #2】**

两次询问的答案分别为 $34$ 和 $4487317$。

------------

**【数据规模与提示】**

注意：本题采用**捆绑测试**，只有当你通过一个 Subtask 内的所有测试点后，你才能拿到这个 Subtask 的分数。

具体约束如下：  

Subtask $1$（$10\%$）：满足 $T\leq 10$，$n,m\leq 5$；

Subtask $2$（$20\%$）：满足 $T \leq 10$，$n,m\leq 1\times 10^3$；

Subtask $3$（$30\%$）：满足 $T\leq 10$，$n,m\leq 5\times 10^5$;


Subtask $4$（$40\%$）：无特殊限制。

对于 $100\%$ 的数据，满足 $1\le T \le 2\times10^6$，$1\le n,m\le 5\times 10^{18}$。

**本题输入量较大，建议采用较为快速的读入方式并注意常数因子对程序效率带来的影响。**



------------
 0-1 Trie 是一种特殊的 Trie ，只有 $\mathbf{0,1}$ 两种字符。
 
 如果你不了解 Trie，可以查看：[OI Wiki--Trie](https://deploy-preview-980--oi-wiki.netlify.app/string/trie/)。

## 样例 #1

### 输入

```
1
2 4```

### 输出

```
15```

## 样例 #2

### 输入

```
2
3 5
114514 1919810```

### 输出

```
4487351
```

## 样例 #3

### 输入

```
5
78 122
1000000 1000001
74859432 942432534
555555555 77777777 
6666666666 8888888888```

### 输出

```
12287990```

# AI分析结果



**唯一算法分类**: 组合数学

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
所有题解均将问题转化为组合数学问题，核心为推导合法串数目及节点数的组合表达式，最终利用Lucas定理高效计算大数组合数取模。

#### **解决难点**
1. **递推式转化**: 将动态规划的递推式转化为组合数表达式（如yyandy的递推式展开为网格路径数求和）。
2. **增量分析**: 部分题解（如hanzhongtlx）通过插入0的增量拆分，结合组合恒等式简化计算。
3. **生成函数/容斥**: 部分题解（如dengyaotriangle）通过生成函数或容斥原理直接推导通项。
4. **大数处理**: 所有题解均需处理n,m≤5e18的组合数计算，采用Lucas定理分治求模。

#### **关键步骤**
- **组合数表达式**: 最终通项形式为 `2*C(n+m+1,n) - C(n+m-1,n) - 2`。
- **Lucas优化**: 预处理模数内的阶乘和逆元，递归计算组合数。

---

### **题解评分 (≥4星)**

1. **yyandy (5星)**
   - **亮点**: 递推式展开为组合路径数，边界条件处理清晰，最终公式简洁。
   - **关键代码**: 利用递推式直接转化为组合数求和，代码紧凑。

2. **hanzhongtlx (4.5星)**
   - **亮点**: 插入增量拆分，结合组合恒等式（上指标求和）简化推导。
   - **关键代码**: 预处理阶乘优化Lucas计算，代码高效。

3. **dengyaotriangle (4星)**
   - **亮点**: 生成函数推导通项，数学严谨性强。
   - **关键代码**: 生成函数转化为组合数表达式，逻辑清晰。

---

### **最优思路或技巧提炼**
1. **组合路径映射**: 将递推式中的状态转移映射到网格路径数，利用组合数求和（如 `C(n+m, m)` 表示路径总数）。
2. **恒等式优化**: 利用上指标求和公式（如 `∑C(k, i) = C(n+1, k+1)`）简化复杂求和。
3. **Lucas分治**: 处理大数组合数时，递归分解为模数内的子问题，避免直接计算大数阶乘。

---

### **同类型题与算法套路**
- **组合递推**: 类似「卡特兰数」、「格子路径计数」问题。
- **Lucas优化**: 适用于模数较小但n/m极大的组合数问题（如「SDOI2010 古代猪文」）。

---

### **推荐相似题目**
1. **P3807 【模板】卢卡斯定理**  
   *练习Lucas定理的基础应用。*
2. **P1641 [SCOI2010]生成字符串**  
   *组合数路径模型，限制条件下的合法串计数。*
3. **P4369 [Code+#4]组合数问题**  
   *组合数拆分与递推式优化。*

---

### **个人心得摘录**
- **yyandy**: “保证任意两个1互不相邻这个条件比较阴间，尝试将一个1强制与一个0捆绑。”
- **Mivik**: “解决互不相邻问题时，01捆绑是经典套路，但末尾处理需谨慎。”
- **CatFromMars**: “递推式打表找规律，分离常数项是突破口。”

---

### **可视化与算法演示**
#### **动画设计**
- **网格路径模型**: 展示从(0,0)到(n,m)的路径，高亮不同组合数对应的路径分支。
- **Lucas分治**: 动态分解大数组合数为模数内的小问题，递归树可视化。
- **复古像素风格**: 路径以8位像素块移动，音效提示组合数计算完成。

#### **交互设计**
- **步进控制**: 单步展示路径扩展和组合数累加。
- **音效**: 路径扩展时播放“滴”声，错误路径播放低音。

---

### **核心代码实现**
```cpp
// Lucas定理计算组合数 (hanzhongtlx)
int Lucas(ll n,ll m) {
    int ans=1;
    for(;m;n/=MOD,m/=MOD) {
        int a=n%MOD,b=m%MOD;
        if(a<b) return 0;
        ans=1ll*ans*fac[a]%MOD*inv[fac[b]]%MOD*inv[fac[a-b]]%MOD;
    }
    return ans;
}
// 主计算逻辑
int solve(ll n,ll m) {
    if(n>m) return 0;
    return (2ll*Lucas(m+1,n) - Lucas(m-1,n) -2 + MOD*2) % MOD;
}
```

---

### **复古游戏化设计**
- **像素网格**: 使用Canvas绘制16x16像素的路径块，背景音乐为8位芯片音乐。
- **音效触发**: 正确路径扩展时播放NES风格音效，错误路径触发“失败”音效。
- **积分系统**: 每正确计算一个组合数获得10分，连击加速动画播放。

---
处理用时：57.72秒
# 题目信息

# [THUPC 2017] 组合数问题

## 题目描述

小葱是一名勇士。

小葱踏上了拯救世界的征途。

小葱面前有 $N$ 只大葱怪。

大葱怪很厉害，第 $i$ 只大葱怪攻击力为 $a_i$，防御力为 $d_i$。

小葱的攻击力为 $A$，防御力为 $D$。

小葱打掉第 $i$ 只大葱怪的代价是 $A\times d_i+D\times a_i$。

小葱打倒很多只大葱怪的代价不是打倒每一只大葱怪的代价之和，而是最大值。

小葱现在需要打倒 $R$ 只大葱怪。

神葱是葱的神，神葱会对小葱打倒 $R$ 只大葱怪做出评价。神葱对小葱打倒 $R$ 只大葱的评价为小葱打倒这 $R$ 只大葱怪所需要的代价除以小葱以同样的攻击力和防御力打倒所有 $N$ 只大葱怪的代价。

神葱是葱的神，所以神葱会在小葱选择了 $R$ 只要被打倒的大葱怪后，设定小葱的攻击力和防御力，使得小葱得到的评价最低。

神葱不希望这个值是负的，所以如果这个值是负的，神葱会强制把它变为 $0$。

小葱是一名勇士。

小葱不会屈服。

小葱需要选择出 $R$ 只大葱怪，使得自己能够从神葱那里得到的评价最高。

小葱求这个评价值。

小葱很善良，所以小葱为你写出了评价值的数学表示：
$$\max_{S\subseteq [N],|S|=R}\Big\lbrack\min_{A,D\in\Z^+}\dfrac{\max_{i\in S}(A\times d_i+D\times a_i)}{\max_{i\in [N]}(A\times d_i+D\times a_i)}\Big\rbrack$$

## 说明/提示

$1\le R\le N\le 10^3,a_i,d_i$ 均为正整数，数据组数不超过 $50$ 组，所有攻击力和防御力都是正整数。
#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。

## 样例 #1

### 输入

```
3 3
1 3
2 5
2 3
5 1
1 5
2 4
3 3
4 2
5 1```

### 输出

```
1.000000
0.600000```

# AI分析结果



**唯一算法分类**：二分答案与贪心算法

---

### **题解思路与算法要点**

#### **核心思路**
1. **二分答案**：将问题转化为判定性问题。假设当前评价值为 `x`，判断是否存在大小为 `R` 的集合 `S`，使得对于所有正实数 `A'`，存在 `i∈S` 满足 `A'd_i +a_i >=x*(A'd_j +a_j)` 对所有 `j` 成立。
2. **可行区间计算**：对每个候选元素 `i`，计算其满足条件的 `A'` 范围。这需要解多个线性不等式，取交集得到区间。
3. **区间覆盖判断**：将可行区间排序后，用贪心算法判断是否可用 `R` 个区间覆盖整个 `A'≥0` 的范围。

#### **关键步骤**
1. **数学转化**：将原式转化为每个 `i` 的线性函数在 `A'` 的覆盖范围。
2. **处理不等式**：对每个 `i` 和 `j`，解线性不等式得到约束条件，确定 `i` 的可行区间。
3. **贪心覆盖**：按左端点排序区间，每次选右端点最大的区间，直至覆盖整个范围。

#### **解决难点**
- **区间计算精度**：需处理分母为零、正负号反转等边界情况，确保数学推导正确。
- **时间复杂度优化**：对每组数据，二分次数约 30 次，每次需 O(N²) 处理所有 `i` 和 `j` 的约束，总体复杂度 O(TN² log V)。

---

### **最优思路提炼**
- **二分答案框架**：将最大化问题转化为判定性问题，显著缩小问题规模。
- **区间覆盖的贪心策略**：通过排序和选择右端点最大的区间，快速判断覆盖可行性。
- **线性不等式的分类讨论**：通过分母符号分情况处理，确保可行区间计算的正确性。

---

### **同类型题推荐**
1. **POJ 2566 - Bound Found**（区间最值，滑动窗口+二分）
2. **CF 939E Maximize!**（凸包与极值点性质）
3. **洛谷 P2218 [HAOI2007] 覆盖问题**（二分答案+贪心覆盖）

---

### **可视化算法分析**
**动画方案**：
1. **二分过程**：以进度条表示当前二分的上下界，动态调整区间。
2. **区间覆盖**：用不同颜色线段表示每个元素的可行区间，逐步叠加覆盖区域。
3. **高亮当前操作**：在计算每个 `i` 的区间时，高亮当前处理的 `i` 和 `j`，显示约束条件。
4. **贪心选择**：动态演示贪心过程，显示当前覆盖范围和选择的区间。

**复古像素风格**：
- **颜色方案**：绿色表示可行区间，红色表示不可行，黄色高亮当前处理元素。
- **音效**：选中区间时播放短促音效，覆盖完成时播放胜利音效。
- **Canvas绘制**：用像素块表示区间端点，动态拼接覆盖范围。

---

### **核心代码片段**
```cpp
#include <bits/stdc++.h>
using namespace std;

const double eps = 1e-8;
struct Interval {
    double l, r;
    bool operator<(const Interval& other) const {
        return l < other.l;
    }
};

bool check(vector<pair<int, int>>& a, int n, int R, double x) {
    vector<Interval> intervals;
    for (int i = 0; i < n; ++i) {
        double left = 0, right = 1e18;
        bool valid = true;
        for (int j = 0; j < n; ++j) {
            int ai = a[i].first, di = a[i].second;
            int aj = a[j].first, dj = a[j].second;
            double numer = x * aj - ai;
            double denom = di - x * dj;
            if (denom == 0) {
                if (numer > 0) { valid = false; break; }
                continue;
            }
            if (denom > 0) {
                double t = numer / denom;
                if (t > right + eps) { valid = false; break; }
                left = max(left, t);
            } else {
                if (numer > 0) { valid = false; break; }
                double t = numer / denom;
                if (t < -eps) { valid = false; break; }
                right = min(right, t);
            }
        }
        if (valid && left <= right + eps && right >= -eps) {
            intervals.push_back({max(left, 0.0), right});
        }
    }
    sort(intervals.begin(), intervals.end());
    int cnt = 0, i = 0;
    double last = 0;
    while (i < intervals.size() && last < 1e18) {
        if (intervals[i].l > last + eps) break;
        double max_r = last;
        while (i < intervals.size() && intervals[i].l <= last + eps) {
            max_r = max(max_r, intervals[i].r);
            ++i;
        }
        ++cnt;
        last = max_r;
        if (cnt > R) break;
    }
    return last >= 1e18 - eps && cnt <= R;
}

int main() {
    int T, n, R;
    while (scanf("%d%d", &n, &R) != EOF) {
        vector<pair<int, int>> a(n);
        for (int i = 0; i < n; ++i)
            scanf("%d%d", &a[i].first, &a[i].second);
        double l = 0, r = 1;
        for (int step = 0; step < 50; ++step) {
            double mid = (l + r) / 2;
            if (check(a, n, R, mid)) l = mid;
            else r = mid;
        }
        printf("%.6lf\n", l);
    }
    return 0;
}
```

---

**关键实现说明**：
- **check函数**：计算所有可行区间，贪心判断是否覆盖。
- **二分框架**：标准二分循环，逐步逼近最大评价值。
- **精度处理**：使用 `eps` 避免浮点误差，确保区间判断正确。

---
处理用时：244.32秒
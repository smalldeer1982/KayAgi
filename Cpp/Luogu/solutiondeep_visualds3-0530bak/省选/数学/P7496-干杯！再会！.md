# 题目信息

# 干杯！再会！

## 题目背景

>酒酣之时，等待你的会是……

黛米和哥哥在一个小城镇里经营着一家小酒吧。靠着哥哥调制的多夫林酒，这间小酒吧的生意也逐渐兴隆起来。

## 题目描述

这家小店有 $n$ 位常驻顾客。第 $i$ 位顾客来到这家小店时都会带上一瓶美味度为 $a_i$ 的底酒和一份美味度为 $b_i$ 的调料。这些顾客会让黛米帮忙调酒。对于一瓶美味度为 $x$ 的底酒和一份美味度为 $y$ 的调料，如果黛米将它们调制在一起，就能得到一瓶美味度为 $\gcd(x,y)$ 的美酒（我们认为美味度数值越低代表酒越好喝）。

这一天，这些顾客同时来到了这家小店想要黛米帮忙调酒。然而黛米在前一天喝了太多的酒导致意识错乱了，这导致她将调料加入到了错误的底酒里。不过好在这些顾客并不在意，他们只想知道对于**所有**黛米加入调料的情况下，他们将会拿到的酒的美味度的**方差**的**和**在对 $10^9+7$ 取模意义下是多少。如果你能回答出他们的问题，那么他们会很愿意帮你支付酒钱。

------------
#### 简要题意：
给定 $n$ 以及两个长度为 $n$ 的序列 $a,b$。对于一个 $1$ 到 $n$ 的排列 $p$，记 $c_i=\gcd(a_i,b_{p_i})$，$\sigma(c)$ 表示序列 $c$ 中所有元素的**方差**（方差公式详见提示），求：

$$\sum\limits_{p}\sigma(c)$$

对 $10^9+7$ 取模。

## 说明/提示

#### 样例一解释
+ $p=\{1,2,3\},c=\{1,2,3\},\sigma(c)=\dfrac{2}{3}$。
+ $p=\{1,3,2\},c=\{1,1,1\},\sigma(c)=0$。
+ $p=\{2,1,3\},c=\{1,1,3\},\sigma(c)=\dfrac{8}{9}$。
+ $p=\{2,3,1\},c=\{1,1,1\},\sigma(c)=0$。
+ $p=\{3,1,2\},c=\{1,1,1\},\sigma(c)=0$。
+ $p=\{3,2,1\},c=\{1,2,1\},\sigma(c)=\dfrac{2}{9}$。

总和为 $\dfrac{16}{9}$，对 $10^9+7$ 取模意义下为 $777777785$。

------------
#### 数据范围

**本题采用捆绑测试**。

+ Subtask 1 ( $5\%$ )：$n\leq8$。
+ Subtask 2 ( $15\%$ )：$n,a_i,b_i\leq100$。
+ Subtask 3 ( $25\%$ )：$a_i,b_i\leq10^3$。
+ Subtask 4 ( $25\%$ )：$n,a_i,b_i\leq 10^5$。
+ Subtask 5 ( $30\%$ )：无特殊限制。

对于所有数据，$2\leq n\leq 10^6,1\leq a_i,b_i\leq 10^6$。

------------
对于一个长度为 $n$ 的序列 $x$，方差 $\sigma(x)=\sum\limits_{i=1}^n\dfrac{1}{n}(x_i-\bar{x})^2$，其中 $\bar{x}$ 表示所有元素的平均数（$\bar{x}=\dfrac{1}{n}\sum\limits_{i=1}^nx_i$）。

## 样例 #1

### 输入

```
3
1 2 3
1 2 3
```

### 输出

```
777777785```

## 样例 #2

### 输入

```
12
1 3 4 2 3 5 7 3 5 6 8 9
4 3 10 2 5 6 4 8 2 9 12 5
```

### 输出

```
931089600```

# AI分析结果



## 唯一算法分类
**数论与组合数学**（容斥、莫比乌斯反演、欧拉函数）

---

## 综合分析与结论

### 核心思路与难点
题目要求计算所有排列下 $\gcd$ 方差的期望和，需解决以下核心问题：
1. **方差拆分**：将方差拆分为 $\frac{1}{n}\sum x_i^2 - (\frac{1}{n}\sum x_i)^2$，分别计算两部分。
2. **排列贡献处理**：所有排列的贡献需转化为组合计数问题，利用容斥处理交叉项。
3. **高效计算 $\gcd$ 出现次数**：通过数论函数（欧拉函数、莫比乌斯函数）和预处理优化复杂度。

### 关键算法步骤
1. **预处理统计倍数**：计算每个数作为因子的出现次数 $ca[x] = \sum [x|a_i]$，$cb[x] = \sum [x|b_i]$。
2. **容斥计算 $\gcd$ 分布**：用 $f_x = ca[x] \cdot cb[x] - \sum_{k>1} f_{kx}$ 得到 $\gcd(a_i, b_j) = x$ 的对数。
3. **欧拉反演优化交叉项**：将 $\gcd$ 转化为 $\sum_{d|x} \phi(d)$，避免暴力枚举。
4. **组合贡献计算**：通过排列数 $(n-1)!$ 和 $(n-2)!$ 加权各部分贡献。

---

## 题解清单（评分≥4星）

### 1. 作者：wolfind（⭐️⭐️⭐️⭐️⭐️）
- **亮点**：分阶段优化，从暴力到 $O(n \log n)$；详细推导方差拆分后的数学公式；代码结构清晰。
- **核心代码**：
  ```cpp
  for(int i = m; i >= 1; i--) {
      f[i] = 1ll * ca[i] * cb[i] % MOD;
      for(int j = 2; j * i <= m; j++) (f[i] -= f[j * i]) %= MOD;
  }
  ```
- **可视化**：高亮预处理 $ca$/$cb$ 的过程，用颜色区分不同因子的贡献。

### 2. 作者：Reunite（⭐️⭐️⭐️⭐️）
- **亮点**：引入狄利克雷前缀和优化至 $O(m \log \log m)$；独立推导 $\tau$ 函数处理平方贡献。
- **关键公式**：$H(n) = \sum_{d|n} d^2 \mu(\frac{n}{d})$，通过线性筛快速计算。

### 3. 作者：CloudDreamLake（⭐️⭐️⭐️⭐️）
- **亮点**：结合游戏化代码风格；实现高维前缀和与欧拉反演；提供加强版题目链接。
- **代码片段**：
  ```cpp
  for(int pr : prs) for(int j = W/pr; j >= 1; j--) 
      sa[j] += sa[j * pr], sb[j] += sb[j * pr];
  ```

---

## 最优思路提炼
1. **方差拆分**：$\sigma(x) = \frac{1}{n}\sum x_i^2 - (\frac{1}{n}\sum x_i)^2$，独立计算两部分。
2. **欧拉反演**：$\gcd(x,y) = \sum_{d|\gcd(x,y)} \phi(d)$，将 $\gcd$ 转化为可预处理的数论函数。
3. **高维前缀和**：用狄利克雷后缀和快速统计每个数的倍数出现次数。
4. **容斥优化交叉项**：处理 $res2 = tot1 - tot2 - tot3 + tot4$，避免重复计算。

---

## 相似题目推荐
1. **P1390 公约数的和**：统计所有数对的 $\gcd$ 之和，需类似预处理。
2. **P2158 [SDOI2008] 仪仗队**：利用欧拉函数计算可见点数。
3. **P2303 [SDOI2012] Longge的问题**：求 $\sum \gcd(i, n)$，数论分块与函数应用。

---

## 可视化与算法演示
### 动画设计
- **Canvas 网格**：每个格子表示一个数，颜色深浅表示其作为因子的出现次数。
- **步骤演示**：
  1. **预处理**：动态显示 $ca$ 和 $cb$ 数组的构建，高亮当前处理的数。
  2. **容斥计算**：从大到小更新 $f[x]$，用颜色渐变表示减法操作。
  3. **贡献统计**：用粒子效果展示 $res1$ 和 $res2$ 的累加过程。

### 复古像素风格
- **8-bit 音效**：
  - **预处理完成**：短促“滴”声。
  - **容斥步骤**：连续电子音调。
- **像素方块**：每个数用 8x8 像素块表示，红色表示 $a_i$ 的倍数，蓝色表示 $b_i$ 的倍数，紫色表示共同因子。

---

## 代码片段（wolfind 核心逻辑）
```cpp
// 预处理 ca 和 cb
for(int i = 1; i <= m; i++) 
    for(int j = i; j <= m; j += i) 
        ca[i] += a[j], cb[i] += b[j];

// 容斥计算 f[x]
for(int i = m; i >= 1; i--) {
    f[i] = ca[i] * cb[i];
    for(int j = 2 * i; j <= m; j += i)
        f[i] -= f[j];
}

// 计算 res1（平方和）
for(int i = 1; i <= m; i++)
    res1 += f[i] * i * i * (n-1)!;
```

---
处理用时：67.73秒
# 题目信息

# [省选联考 2022] 填树

## 题目背景

原题时限为 2s。

## 题目描述

有一棵 $n$ 个节点的无根树，刚开始树上每个节点的权值均为 $0$。KK 想对这棵树进行一些修改，他会任选一个节点作为初始的当前节点，然后重复以下动作：

1. 将当前节点 $i$ 的权值修改为一个**正整数** $x$，需满足 $l_i \leq x \leq r_i$。其中 $l_i, r_i$ 是输入中给出的两个正整数。
2. 结束修改过程，或移动到一个与当前节点相邻的权值为 $0$ 的节点（如果不存在这样的节点，则必须结束修改过程）。

现在 KK 有两个问题：

1. 在修改结束后，可以得到多少棵不同的树，满足树上**非零权值**的最大值和最小值的差小于等于 $K$？其中 $K$ 是输入中给出的一个正整数。

2. 这些满足条件的树的权值之和为多少？（树的权值定义为这棵树上所有节点的权值之和）

你需要输出这两个问题的答案模 $10^9 + 7$。我们认为两棵树不同当且仅当至少存在一个节点的权值不同。

温馨提示：

1. KK 至少会修改一个节点（初始节点）。
2. 实质上 KK 会修改树上的任意一条路径，最后需要满足这条路径上的点的权值最大值和最小值之差小于等于 $K$。

## 说明/提示

**【样例解释 #1】**

| | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | $9$ | $10$ | $11$ | $12$ | $13$ | $14$ |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 节点 $1$ | $2$ | $3$ | $2$ | $3$ | $3$ | $3$ | $3$ | $3$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| 节点 $2$ | $0$ | $0$ | $3$ | $3$ | $4$ | $0$ | $4$ | $3$ | $3$ | $4$ | $5$ | $0$ | $0$ | $0$ |
| 节点 $3$ | $0$ | $0$ | $0$ | $0$ | $0$ | $4$ | $4$ | $4$ | $0$ | $0$ | $0$ | $4$ | $5$ | $6$ |

表格中列出了全部 $14$ 棵满足条件的树，将这些树的权值加起来为 $78$。

**【数据范围】**

对于 $100\%$ 的数据，$1 \leq n \leq 200$，$1 \leq l_i \leq r_i \leq {10}^9$，$1 \leq K \leq {10}^9$。

| 测试点 | $n \leq $ | $r_i, K \leq$ | 其他限制 |
|:-:|:-:|:-:|:-:|
| $1$ | $5$ | $10$ | 无 |
| $2$ | $30$ | $10^9$ | 无 |
| $3$ | $30$ | $10^9$ | 无 |
| $4$ | $30$ | $500$ | 无 |
| $5$ | $200$ | $200000$ | 无 |
| $6$ | $200$ | $200000$ | 无 |
| $7$ | $200$ | $10^9$ | A |
| $8$ | $200$ | $10^9$ | A |
| $9$ | $200$ | $10^9$ | 无 |
| $10$ | $200$ | $10^9$ | 无 |

特殊限制 A：所有点构成一条链, 编号为 $i$ 的点和编号为 $i + 1$ 的点之间有连边

**【评分方式】**

本题共 $10$ 个测试点，每个测试点 $10$ 分。其中回答正确第一问可得 $7$ 分，回答正确第二问可得 $3$ 分。

## 样例 #1

### 输入

```
3 1
2 3
3 5
4 6
1 2
1 3
```

### 输出

```
14
78
```

## 样例 #2

### 输入

```
见附件中的 tree/tree2.in```

### 输出

```
见附件中的 tree/tree2.ans```

## 样例 #3

### 输入

```
见附件中的 tree/tree3.in```

### 输出

```
见附件中的 tree/tree3.ans```

# AI分析结果



**算法分类**  
树形动态规划（树形DP）与拉格朗日插值优化

---

### **题解思路与核心难点**

#### **核心思路**
1. **容斥原理**  
   计算区间 $[L, L+K]$ 的方案数时，减去 $[L+1, L+K]$ 的答案，确保最小值恰好为 $L$。
   
2. **分段多项式**  
   将值域拆分为 $O(n)$ 个关键段，每段内每个节点的可选区间是 $L$ 的一次或二次多项式。答案在每段内表现为多项式形式，通过拉格朗日插值快速求和。

3. **树形动态规划**  
   计算每个节点作为路径端点时的方案数（$f_u$）和权值和（$g_u$），合并子树时利用多项式乘法性质。

#### **解决难点**
- **分段推导**：通过分析 $\min(r_i, L+K)$ 和 $\max(l_i, L)$ 的断点关系，将值域拆分为 $O(n)$ 段。
- **多项式次数控制**：方案数为 $n$ 次多项式，权值和为 $n+1$ 次多项式，通过插值将复杂度优化至 $O(n^3)$。
- **动态规划优化**：将每个节点的贡献用多项式表示，并通过树上路径合并实现快速计算。

---

### **题解评分（≥4星）**

1. **WeLikeStudying（⭐️⭐️⭐️⭐️⭐️）**  
   - **亮点**：完整推导拉格朗日插值过程，代码实现清晰，包含容斥与分段优化。
   - **关键代码**：
     ```cpp
     void dfs(int u, int fa, int L, int R) {
         // 计算每个节点的贡献
         int ql = max(L, l[u]), qr = min(R, r[u]);
         // 多项式系数更新逻辑
     }
     ```

2. **Renshey（⭐️⭐️⭐️⭐️）**  
   - **亮点**：简洁的断点预处理与插值实现，使用树形DP高效计算分段答案。
   - **代码片段**：
     ```cpp
     inline void dp(int L, int R) {
         // 动态规划计算当前段的方案数与权值和
     }
     ```

3. **小木虫（⭐️⭐️⭐️⭐️）**  
   - **亮点**：详细拆解动态规划状态转移，适合初学者理解。
   - **核心公式**：
     $$
     f_u = \text{方案数的多项式表达式}, \quad g_u = \text{权值和的多项式表达式}
     $$

---

### **最优技巧与同类型题**

#### **关键技巧**
- **断点拆分**：通过分析 $\min/\max$ 的断点，将值域分为 $O(n)$ 段。
- **多项式加速**：利用自然数幂和的性质，通过插值将求和复杂度从 $O(W)$ 降为 $O(n)$。
- **容斥简化**：用两次不同范围的DP结果相减，避免重复计数。

#### **同类题目推荐**
1. **NOI2019 机器人**（动态规划与多项式优化）
2. **APIO2016 划艇**（值域分段与插值）
3. **CF622F The Sum of the k-th Powers**（自然数幂和插值）

---

### **可视化与算法演示**

#### **动态规划过程演示**
- **动画设计**：用像素风格绘制树结构，高亮当前处理的节点和路径。
- **步进控制**：单步展示每个节点的 $f_u$ 和 $g_u$ 更新过程，颜色标记变化部分。
- **插值可视化**：在Canvas中绘制多项式曲线，动态展示插值点的计算。

#### **复古像素风格**
- **颜色方案**：使用16色调色板，绿色表示有效区间，红色表示断点。
- **音效触发**：节点更新时播放8位音效，插值完成时播放成功音效。

---

### **代码实现（核心逻辑）**

```cpp
// 关键DP逻辑与插值计算
void dfs(int u, int fa, int L, int R) {
    int ql = max(L, l[u]), qr = min(R, r[u]);
    int cntu = (ql <= qr) ? qr - ql + 1 : 0;
    int sumu = (ql <= qr) ? (ql + qr) * (qr - ql + 1) / 2 % MOD : 0;
    f[u] = cntu, g[u] = sumu;
    for (int v : G[u]) {
        if (v == fa) continue;
        dfs(v, u, L, R);
        f[u] = (f[u] + f[v] * cntu) % MOD;
        g[u] = (g[u] + g[v] * cntu + f[v] * sumu) % MOD;
    }
}

// 拉格朗日插值计算段内总和
int lagrange(int y[], int x) {
    int res = 0;
    for (int i = 1; i <= n+2; i++) {
        int term = y[i];
        for (int j = 1; j <= n+2; j++) {
            if (i != j) term = term * (x - j) % MOD * inv[i-j] % MOD;
        }
        res = (res + term) % MOD;
    }
    return res;
}
```

---

### **个人心得摘录**
- **调试教训**：初始未处理负值导致插值错误，需对多项式系数取模后修正符号。
- **优化顿悟**：发现动态规划的合并过程本质是多项式乘法，从而引入插值优化。

---
处理用时：75.37秒
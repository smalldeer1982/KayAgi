# 题目信息

# [JRKSJ R6] func

## 题目描述

**这是一道 IO 交互题．**

你有一个一次函数 $f(x)=kx+b$（$1\le x \le n-1$）．这个一次函数满足 $k,b$ 均为整数且 $k>0$．

vectorwyx 修改了这个函数，具体而言，他会选择一个整数 $t$（$1\le t \le n-1$），将这个函数在直线 $x=t$ 及右侧的部分向右平移一个单位长度，并把两部分的端点用直线段连接，得到一个分段函数 $g(x)$：

$$
g(x)=\begin{cases}
kx+b&1\le x<t\\
kt+b& t\le x <t+1\\
k(x-1)+b& t+1\le x \le n
\end{cases}
$$

请通过交互的方式得到 $t$ 的值．

### 交互方式

**本题单个测试点中含有多组数据．**

1. 首先从标准输入流读入一个整数 $T$，表示数据组数．
1. 接下来你将进行 $T$ 组数据的交互．对于每组数据，首先从标准输入流读入三个整数 $n,Q,P$．
1. 你可以通过向标准输出流输出 `? l r p`（$1\le l \le r \le n$，$2\le p \le P$）的方式来询问．在单组数据中，你最多只能进行 $Q$ 次 `?` 操作．交互库会根据你的询问依次做出以下判断并向标准输入流发送返回结果：
    - 若你的询问数据范围错误，回答为 $-2$．此时交互库会直接返回 WA．你需要立刻退出你的程序来避免与已经结束程序的交互库交互引起超时．
    - 若 $g(l)=g(r)$，回答为 $-1$．
    - 否则回答为 $(g(l) + g(r))\bmod p$．
1. 你可以通过向标准输出流输出 `! t` 的方式来给出答案．你只能进行一次回答操作，且回答操作必须是你在每组数据中进行的最后一个操作．交互完成后，从标准输入流读入一个零或一的整数 $x$．若 $x=1$ 则代表当前数据回答正确，你需要回到步骤 $2$ 以进行下一组数据的交互．否则 $x=0$，你需要立刻退出自己的程序．

**不要忘记在每次输出后刷新缓冲区，否则你将会 TLE．**

下面是一些语言的刷新缓冲区操作：

- C++：`fflush(stdout)` 或 `cout.flush()`．
- C: `fflush(stdout)`．
- Java: `System.out.flush()`．
- Python: `stdout.flush()`．
- Pascal: `flush(output)`．
- 其他语言：请参考对应语言的帮助文档．


## 说明/提示

### 样例解释

请注意，样例仅用来表示交互的规则，不保证有逻辑性．

#### 样例 #1

$f(x)=3x-2$（$1\le x \le 4$），$t=3$．

$$
g(x)=\begin{cases}
3x-2&1\le x<3\\
7& 3\le x <4\\
3x-5& 4\le x \le 5.
\end{cases}
$$

所以第一次询问的结果 $(g(1) + g(3))\bmod 2 = (1+7)\bmod 2=0$，第二次询问的结果 $(g(4)+g(5))\bmod 2 = (7+ 10)\bmod 2=1$．

### 数据范围与约束

**本题采用捆绑测试．且不存在一个 Subtask 包含其它所有 Subtask 的限制．**

| Subtask | 分值 |    $n$     | $Q=$ |       $P=$        | $g(x)\le$ |    特殊性质     |
| ------- | ---- | ---------- | ---- | ----------------- | --------- | --------------- |
| $1$     | $10$ | $\le 10^9$ | $42$ | $2\times 10^{18}$ | $10^{18}$ | 无              |
| $2$     | $20$ | $\le 10^9$ | $30$ | $2$               | $10^{18}$ | 斜率 $k$ 为奇数 |
| $3$     | $30$ | $\le 10^9$ | $42$ | $50$              | $10^{18}$ | 无              |
| $4$     | $39$ | $\le 10^9$ | $32$ | $50$              | $10^{18}$ | 无              |
|$5$|$1$|$ = 1162261531$| $32$| $50$| $7857125847061472735$|无|

对于 $100\%$ 的数据，保证 $1 \le T \le 10$，$2\le n\le 1162261531$．且满足 $\forall x \in [1,n], 0 \le g(x)\le 7857125847061472735$．

### 提示

由于本题不存在一个 Subtask 包含其它所有 Subtask 的限制．所以数据范围中「对于 $100\%$ 的数据」部分的 $n$ 和 $g(x)$ 的上界没有任何意义．但由于直接写「对于 $100\%$ 的数据，满足 $n \ge 2$，$g(x)\ge 0$」会被某些管理以「你管这叫数据范围」打回，故此题中保留该没有意义的上界．

## 样例 #1

### 输入

```
1
5 999 999

0

1

1```

### 输出

```


? 1 3 2

? 4 5 2

! 3```

# AI分析结果



**唯一算法分类**  
交互题、模运算、二分/三分查找

---

### **综合分析与结论**  
#### **核心思路**  
题目要求通过交互式询问找到分段函数的拐点位置。核心步骤分为两阶段：  
1. **确定模数**：通过选择一组互质的模数，确保至少有一个模数不整除斜率k，从而解出k和b的模值。  
2. **三分法定位拐点**：在已知k和b模值的基础上，通过三次划分区间逐步缩小拐点范围。

#### **算法难点与解决**  
- **难点1**：如何高效确定模数p，使得k mod p ≠0。  
  **解决**：预先计算一组互质数（如49,47,45,43,41,37），其LCM足够大（覆盖k的可能最大值）。  
- **难点2**：减少询问次数以满足严格限制（如Sub5的32次限制）。  
  **解决**：用三分法代替二分，每次将区间长度缩小至1/3，将复杂度从O(log n)优化为O(log3 n)。  
- **子任务2的特殊处理**：当k为奇数时，利用模2的奇偶性直接二分。

#### **可视化设计思路**  
1. **动画展示**：  
   - **像素化区间条**：用像素块表示当前搜索区间，高亮三分点midl和midr。  
   - **颜色标记**：当前模数p用闪烁边框标记，询问结果（-1、0、1）用不同颜色反馈。  
   - **步进控制**：允许用户手动点击或自动播放，观察每一步如何缩小区间。  
2. **复古效果**：  
   - **音效**：每次询问时播放8-bit音效，成功找到拐点时播放胜利旋律。  
   - **Canvas绘制**：以网格形式展示函数图像，拐点区域用不同颜色填充。  
3. **AI自动演示**：自动按最优顺序选择模数并执行三分，模拟“完美解题路径”。

---

### **题解清单 (≥4星)**  
1. **vectorwyx（5星）**  
   - **亮点**：详细推导模数集合的选择逻辑，明确分析各子任务限制条件，代码结构清晰。  
   - **核心代码**：通过固定x=2解方程求k和2b的模值。  

2. **Eafoo（4星）**  
   - **亮点**：强调三分法实现细节，处理边界条件（如返回-1时直接确定拐点）。  
   - **代码片段**：动态调整三分点确保区间均匀划分。  

3. **星星与辰（4星）**  
   - **亮点**：分情况讨论模数选择与拐点影响，提供本地调试代码示例。  

---

### **最优思路与技巧提炼**  
#### **关键技巧**  
1. **模数选择策略**：贪心选取互质数集合，最大化LCM以覆盖k的可能最大值。  
2. **三分法优化**：通过`midl = (2l + r)/3`和`midr = (l + 2r)/3`划分区间，减少询问次数。  
3. **快速解模方程**：利用相邻点差值确定k mod p，避免解多元方程。  

#### **代码实现核心**  
```cpp
// vectorwyx题解核心代码（简化）
void solve() {
    int n = read(), Q = read(), P = read();
    if (P == 2) { /* 处理子任务2的二分 */ }
    // 确定模数p
    for (int p : {49,47,45,43,41,37}) {
        int x = ask(1,2,p), y = ask(2,3,p);
        if (x == -1) { answer(1); return; }
        if (y == -1) { answer(2); return; }
        if (x != y) { // 解k和b模p
            k = (y - x) * inv_2 % p;
            b = (x - 3*k) % p;
            break;
        }
    }
    // 三分法找拐点
    int l = 1, r = n;
    while (r - l > 1) {
        int midl = (2*l + r)/3, midr = (l + 2*r)/3;
        int res = ask(midl, midr, p);
        if (res == -1) { answer(midl); return; }
        // 根据结果调整区间
        if (res == expected1) r = midl;
        else if (res == expected2) l = midr;
        else { ... }
    }
    answer(l);
}
```

---

### **同类型题与推荐题目**  
1. **P1083 [NOIP2012 提高组] 借教室**（二分答案）  
2. **P1948 [USACO08OPEN] Telephone Lines S**（交互式二分）  
3. **P3384 【模板】树链剖分**（区间查询与分治思想）  

---

### **个人心得摘录**  
- **vectorwyx**：模数集合的LCM必须严格大于理论k的最大值，否则Sub5会WA。  
- **Eafoo**：三分时需动态调整midl和midr，避免区间不均匀导致超限。  
- **星星与辰**：本地对拍时构造极端数据验证模数选择的有效性。  

---

### **可视化与算法演示**  
#### **动画方案**  
1. **初始化阶段**：展示函数图像，红色块表示拐点t，绿色块表示已确定的区间。  
2. **选择模数p**：逐个高亮预选模数，显示询问结果，直到找到k≠0的p。  
3. **三分过程**：  
   - **步骤1**：绘制当前区间[l, r]，标记midl和midr。  
   - **步骤2**：显示询问结果，根据结果收缩区间（如返回-1则midl变红）。  
   - **步骤3**：重复直到区间长度为1，播放胜利动画。  

#### **复古风格实现**  
- **颜色方案**：16色调色板，用深蓝表示区间，黄色表示当前操作点。  
- **音效设计**：  
  - 询问时播放“哔”声，成功时播放《超级马里奥》过关音效。  
  - 错误时播放短促“嗡”声。  
- **Canvas绘制**：使用`ctx.fillRect`绘制像素块，`requestAnimationFrame`实现平滑过渡。  

```javascript
// 伪代码：Canvas绘制三分过程
function drawInterval(l, r, midl, midr) {
    ctx.fillStyle = '#2C3E50'; // 背景色
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    // 绘制区间
    ctx.fillStyle = '#3498DB';
    ctx.fillRect(l * scaleX, 0, (r-l)*scaleX, 50);
    // 标记三分点
    ctx.fillStyle = '#E74C3C';
    ctx.fillRect(midl * scaleX, 0, 5, 50);
    ctx.fillRect(midr * scaleX, 0, 5, 50);
}
```

---

**注**：以上内容整合了多篇题解的核心思想，突出算法优化与交互策略，适合快速掌握解题关键。

---
处理用时：81.06秒
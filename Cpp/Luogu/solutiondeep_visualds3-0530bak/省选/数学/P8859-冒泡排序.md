# 题目信息

# 冒泡排序

## 题目描述

有一个值域下标均为 $1\sim n$ 的排列或圆排列 $A$，定义 $f(A)$ 为将 $A$ 升序排序所需的最小操作次数。

每次操作中，你可以选择一个元素并向前**冒泡**若干次，一次**冒泡**定义为：若这个元素小于前一个元素，则可以交换它与前一个元素。当某次无法**冒泡**时，这次操作立即停止。否则可以连续**冒泡**任意次。

比如有排列 $[3,5,2,1,4]$，一次操作可以选择元素 $1$ ，得到排列 $[3,5,1,2,4],[3,1,5,2,4]$ 或 $[1,3,5,2,4]$ 。

若有圆排列 $[2,1,4,3]$，选择元素 $1$ 后可以得到圆排列 $[1,2,4,3],[3,2,4,1]$ 或 $[3,2,1,4]$ 。注意到圆排列中第 $1$ 个元素的前一个元素为第 $n$ 个元素。

排列或圆排列被升序排序，当且仅当对于所有 $\space 2 \leq i \leq n$，元素 $i$ 的前一个元素为元素 $i-1$。

给定 $n,k,type$，你需要：
- 在 $type=1$ 时求有多少长为 $n$ 的排列 $A$ 满足 $f(A)=k$ 。
- 在 $type=2$ 时求有多少长为 $n$ 的圆排列 $A$ 满足 $f(A)=k$ 。

答案对 $10^9+7$ 取模。

## 说明/提示

#### 【样例解释 #1】

有如下合法排列：

1. $[1,4,2,3]$
2. $[1,4,3,2]$
3. $[2,1,4,3]$
4. $[2,4,1,3]$
5. $[2,4,3,1]$
6. $[3,1,2,4]$
7. $[3,1,4,2]$
8. $[3,2,1,4]$
9. $[3,2,4,1]$
10. $[3,4,1,2]$
11. $[3,4,2,1]$

#### 【样例解释 #2】

有如下合法圆排列：

1. $[1,2,5,3,4]$
2. $[1,2,5,4,3]$
3. $[1,3,2,5,4]$
4. $[1,3,5,2,4]$
5. $[1,3,5,4,2]$
6. $[1,4,2,3,5]$
7. $[1,4,2,5,3]$
8. $[1,4,3,2,5]$
9. $[1,4,3,5,2]$
10. $[1,4,5,3,2]$
11. $[1,5,2,4,3]$
12. $[1,5,3,2,4]$
13. $[1,5,3,4,2]$
14. $[1,5,4,2,3]$

需要注意的是，我们认为 $[1,2,5,3,4]$ 和 $[2,5,3,4,1]$ 等是同一个圆排列。

也就是我们认为两个圆排列不同，当且仅当存在一个 $2 \leq i \leq n$，满足两个圆排列中元素 $i$ 的前一个元素不同。

#### 【数据范围】

|   测试点编号 | $n \leq$ | $k \leq$ | $type=$ |
|:------------:|:--------:|:--------:|:-------:|
|  $1 \sim 2$  |    $7$   |    $7$   |   $1$   |
|  $3 \sim 4$  |    $7$   |    $7$   |   $2$   |
|  $5 \sim 6$  |   $15$   |   $15$   |   $1$   |
|  $7 \sim 8$  |   $15$   |   $15$   |   $2$   |
|  $9 \sim 12$ |   $50$   |   $50$   |   $1$   |
| $13 \sim 16$ |   $50$   |   $50$   |   $2$   |
|     $17$     |   $500$  |    $10$   |   $1$   |
|     $18$     |   $500$  |    $10$   |   $2$   |
|     $19$     |   $500$  |   $500$  |   $1$   |
|     $20$     |   $500$  |   $500$  |   $2$   |

对于所有数据，$1 \leq k < n \leq 500$，$1 \leq type \leq 2$。  

## 样例 #1

### 输入

```
4 2 1```

### 输出

```
11```

## 样例 #2

### 输入

```
5 2 2```

### 输出

```
14```

## 样例 #3

### 输入

```
50 10 1```

### 输出

```
808620624```

## 样例 #4

### 输入

```
50 10 2```

### 输出

```
578144115```

# AI分析结果



## 算法分类  
动态规划与组合数学  

---

## 题解思路与算法要点  

### 核心思路对比  
**type=1（排列）**  
- **关键结论**：$f(A)=n-$前缀最大值个数  
- **动态规划模型**：$f_{i,j}$ 表示前i个数有j个前缀最大值的方案数，转移方程为 $f_{i,j}=f_{i-1,j-1}+(i-1)\cdot f_{i-1,j}$，对应第一类斯特林数  
- **解决难点**：将操作次数转化为前缀最大值的计数，利用插入式DP巧妙建模  

**type=2（圆排列）**  
- **关键转化**：固定最大值位置，转化为笛卡尔树的左链长度问题  
- **动态规划优化**：定义 $g_{i,j}$ 表示i个节点的树最大左链深度为j的方案数，通过前缀和优化将复杂度从 $O(n^4)$ 降为 $O(n^3)$  
- **解决难点**：处理循环位移的最小操作次数等价于求所有断链方式中前缀最大值个数的最大值，通过笛卡尔树结构建立映射  

---

## 题解评分（≥4星）  

### 1. 绝顶我为峰（5星）  
- **亮点**：完整推导前缀最大值与斯特林数的等价性，代码简洁清晰  
- **代码实现**：直接给出第一类斯特林数递推式，type=2部分引入树高概念并优化转移  

### 2. ZillionX（4星）  
- **亮点**：通过笛卡尔树深度模型建立DP状态，提供详细组合数预处理逻辑  
- **代码特点**：前缀和优化显著提升效率，差分计算最终答案  

### 3. UKE_Automation（4星）  
- **亮点**：明确将圆排列问题转化为笛卡尔树左链长度统计，代码模块化程度高  
- **关键代码段**：预处理组合数，通过三重循环实现优化后的状态转移  

---

## 最优思路与技巧  

### type=1  
- **斯特林数映射**：将元素插入过程视为构建循环排列，前缀最大值对应循环节个数  
- **代码实现技巧**：从大到小插入元素，利用滚动数组优化空间  

### type=2  
- **笛卡尔树建模**：将每个节点的左链长度视为节省的操作次数，通过树合并计算最大值  
- **前缀和优化**：用 $sum_{i,j}$ 表示i个节点树高≤j的方案数，避免重复计算子问题  

---

## 类似题目推荐  
1. **P5408 第一类斯特林数·行**（斯特林数递推与多项式）  
2. **P5434 圆排列计数**（循环位移与组合优化）  
3. **P6598 烷烃计数**（树形DP与组合合并）  

---

## 可视化设计  

### 算法演示方案  
1. **type=1动态插入**：  
   - **像素动画**：展示从大到小插入元素的过程，高亮当前插入位置  
   - **颜色标记**：红色标记前缀最大值，绿色箭头表示插入方向  
   - **音效**：插入成功时播放"哔"声，前缀更新时播放"叮"声  

2. **type=2笛卡尔树构建**：  
   - **8位风格树**：用方格表示节点，左链用黄色线条突出  
   - **自动演示**：AI自动选择最大值分裂点，展示左右子树合并过程  
   - **控制面板**：暂停/继续按钮调节构建速度，单步观察树高变化  

### 复古游戏化要素  
- **积分系统**：每正确构建一棵符合深度的树获得10分，连击加倍  
- **音效设计**：  
  - 背景音乐：8-bit风格循环旋律  
  - 错误提示：当尝试非法插入时播放低音"嘟"声  
- **关卡设计**：前5关训练type=1插入，后5关挑战type=2树构建  

---

## 核心代码实现  

### type=1 关键DP  
```cpp  
f[0][0] = 1;
for (int i = 1; i <= n; i++) 
    for (int j = 1; j <= i; j++)
        f[i][j] = (f[i-1][j-1] + (i-1)*f[i-1][j]) % mod;
```

### type=2 优化转移  
```cpp  
for (int i = 1; i <= n; i++) {
    C[i][0] = 1;
    for (int j = 1; j <= i; j++) 
        C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;
}
g[1][1] = 1;
for (int i = 1; i <= n; i++) sum[1][i] = 1;
for (int i = 2; i <= n; i++) {
    for (int j = 2; j <= n; j++) {
        if (j <= i) for (int k = 1; k < i; k++) 
            g[i][j] = (g[i][j] + C[i-2][k-1] * (...)) % mod;
        sum[i][j] = (sum[i][j-1] + g[i][j]) % mod;
    }
}
```

---

## 个人心得摘录  
> "赛时卡在圆排列的循环位移转化，后来意识到固定最大值可破局。笛卡尔树深度与操作次数的映射是本题最精妙的观察" —— ZillionX  

> "调试发现未处理模运算负数导致WA，加上`(x+mod)%mod`后AC。深刻教训：模运算必须全面处理减法！" —— Tony2  

---

通过综合动态规划与组合数学技巧，本问题展现了如何将复杂操作计数转化为经典数学模型，其思路对排列与树形结构问题具有重要借鉴意义。

---
处理用时：69.78秒
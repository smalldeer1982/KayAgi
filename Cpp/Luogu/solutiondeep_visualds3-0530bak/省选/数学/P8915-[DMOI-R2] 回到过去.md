# 题目信息

# [DMOI-R2] 回到过去

## 题目背景

 > 想回到过去\
试着抱你在怀里\
羞怯的脸带有一点稚气\
想看你看的世界\
想在你梦的画面\
只要靠在一起就能感觉甜蜜\
想回到过去\
试着让故事继续\
至少不再让你离我而去\
分散时间的注意\
这次会抱得更紧\
这样挽留不知还来不来得及\
想回到过去\
沉默支撑跃过陌生\
静静看着凌晨黄昏\
你的身影 失去平衡\
慢慢下沉\
想回到过去\
—— 周杰伦《[回到过去](https://www.bilibili.com/video/BV1fx411N7bU?p=32&vd_source=2f4592e5507d6452d7d44dc098844d6b)》
>

什么阻碍着两颗心的碰面？什么阻碍着两个人的相见？

或许是令人捉摸不透的时间吧。

## 题目描述

给出 $n,m,t$ 以及 $t$ 个障碍物坐标，求在 $n$ 行 $m$ 列的矩阵中的非障碍位置上放置 $k$ 个两两之间没有公共边的方格的方案有多少种，答案对 $10^9+7$ 取模。

## 说明/提示

#### 【样例解释 #4】

对于测试点 1，可以画出如下的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/9ld7rcxr.png)

其中用黑色格子表示障碍物，可发现只有 $\{(1,2)(1,4)\}\{(1,2)(2,3)\}\{(2,2)(1,4)\}\{(2,3)(1,4)\}$ 四种方案满足题意。

对于测试点 2，可以画出如下的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/74rbxvs6.png)

可发现只有 $\{(1,1)(1,3)(2,2)\}\{(1,1)(1,3)(2,4)\}\{(1,1)(2,2)(2,4)\}\{(1,3)(2,1)(2,4)\}\{(1,3)(2,2)(2,4)\}$ 五种情况符合题意。

### 数据点约定

|  数据点编号  |    $n$     |    $m$     |       $k$       |         $t$         |
| :----------: | :--------: | :--------: | :-------------: | :-----------------: |
|     $1$      |    $=1$    | $\le 10^9$ |      $=2$       |        $=0$         |
|     $2$      |    $=1$    | $\le 10^9$ |      $=3$       |        $=0$         |
|     $3$      |  $\le 20$  |  $\le 20$  |      $=2$       |        $=0$         |
|     $4$      |  $\le 20$  |  $\le 20$  |      $=3$       |        $=0$         |
|     $5$      |  $\le 20$  |  $\le 20$  |      $=2$       |      $\le 400$      |
|     $6$      |  $\le 20$  |  $\le 20$  |      $=3$       |      $\le 400$      |
|    $7,8$     | $\le 1000$ | $\le 1000$ |      $=2$       |        $=0$         |
|    $9,10$    | $\le 1000$ | $\le 1000$ |      $=3$       |        $=0$         |
|     $11$     | $\le 1000$ | $\le 1000$ |      $=2$       |      $\le 10$       |
|     $12$     | $\le 1000$ | $\le 1000$ |      $=3$       |      $\le 10$       |
|   $13,14$    | $\le 10^9$ |    $=n$    |      $=2$       |        $=0$         |
|   $15,16$    | $\le 10^9$ |    $=n$    |      $=3$       |        $=0$         |
|   $17,18$    | $\le 10^9$ | $\le 10^9$ |      $=2$       |        $=0$         |
|   $19,20$    | $\le 10^9$ | $\le 10^9$ |      $=3$       |        $=0$         |
|   $21,22$    | $\le 10^9$ | $\le 10^9$ |      $=2$       | $\le 2 \times 10^4$ |
|   $23,24$    | $\le 10^9$ | $\le 10^9$ |      $=3$       | $\le 2 \times 10^4$ |
| $25$ | $\le 10^9$ | $\le 10^9$ | $2 \le k \le 3$ | $\le 2 \times 10^4$ |

对于 $100\%$ 的数据，$1 \le n,m \le 10^9$，$2 \le k \le 3$，$0 \le t \le \min(n\cdot m,2 \times 10^4)$，$1 \le x_i \le n$，$1 \le y_i \le m$，$1 \le T \le 10$。每个数据点等分值。

## 样例 #1

### 输入

```
5
4 3 2 0
5 7 3 0
2 2 3 0
1 8 2 0
19 13 3 0```

### 输出

```
49
4773
0
21
2369219```

## 样例 #2

### 输入

```
10
4329 12935 3 0
125891 5949823 2 0
95023489 15327384 3 0
28592394 32891538 2 0
5894392 52374853 2 0
58963495 32591238 3 0
438291538 42819324 3 0
58493683 234728 2 0
284952 823499 3 0
528394298 25892948 3 0```

### 输出

```
468372138
510295355
536959469
56564283
462091483
842203294
778629925
806214146
91259493
793676806```

## 样例 #3

### 输入

```
10
55888076 506356561 3 3
48940088 192152177
33004718 365781091
45088097 31400730
65004621 206038505 2 3
50919157 24882066
50919158 24882064
50919156 24882067
249418509 7616530 2 1
205309921 4639136
164784593 419325145 3 4
105814446 200482317
105814449 200482315
105814443 200482315
79723922 206425705
477366546 180501076 3 4
39819749 14485585
39819746 14485582
39819743 14485588
39819748 14485585
84215455 29656489 3 0
524291275 23244413 3 4
8149961 10903189
8149958 10903192
8149958 10903193
8149961 10903191
584987873 823324694 3 1
540008401 27919189
25681672 419244427 2 4
4753299 108169462
4753301 108169463
4753298 108169462
4753298 108169464
313195991 98402123 3 3
7016773 83186671
7016770 83186674
7016767 83186675```

### 输出

```
580170965
521412840
890711205
353426094
41995284
193113183
352219667
748854206
767819374
351309432```

## 样例 #4

### 输入

```
10
2 4 2 4
1 1
1 3
2 1
2 4
2 4 3 3
1 2
2 3
1 4
1 1 3 0
3 4 2 0
3 2 2 1
1 2
4 2 3 0
2 3 2 0
5 4 3 3
2 4
1 3
1 1
4 5 2 2
1 4
2 1
3 1 2 0```

### 输出

```
4
5
0
49
5
12
8
385
128
1```

# AI分析结果



### 算法分类
**组合数学+容斥**

---

### 题解思路与算法要点

#### **核心思路**
1. **k=2 情况**  
   - **总方案数**：$\dbinom{nm-t}{2}$  
   - **不合法方案**：两格相邻的对数，初始为 $2nm-n-m$（无障碍时所有相邻边数）。  
   - **障碍处理**：每个障碍物的上下左右四个方向若有可放置格子，需扣除对应的相邻对数。

2. **k=3 情况**  
   - **总方案数**：$\dbinom{nm-t}{3}$  
   - **不合法方案**：  
     - 至少两两相邻的方案数为 $cnt_2 \times (nm-t-2)$（需容斥）。  
     - 三联通的方案数 $cnt_3$（L型或长条型结构，需统计中间点的出度组合）。

#### **解决难点**
- **障碍物动态调整**：通过遍历障碍物的邻域，快速更新相邻对数和三联通结构数目。  
- **数学推导**：  
  - 三联通结构的总数需分情况推导（如边角、中间、长条/L型）。  
  - 使用组合公式和容斥避免重复计数。

#### **数据结构与优化**
- **Map/Unordered_map**：存储障碍物坐标，快速判断某位置是否为障碍。  
- **公式化简**：针对不同数据范围（如 $n=1$ 或 $m=1$）优化计算逻辑。

---

### 题解评分（≥4星）

1. **daniEl_lElE（4星）**  
   - **亮点**：代码简洁，直接处理障碍物的邻域，清晰展示容斥逻辑。  
   - **代码片段**：  
     ```cpp
     for (每个障碍物) {
         // 更新相邻对数 nr 和三位一体数 nr2
         if (上/下/左/右非障碍) nr--;
         if (对角或两格邻域非障碍) nr2--;
     }
     ```

2. **__K2FeO4（4星）**  
   - **亮点**：详细推导公式，处理一维和二维情况，避免边界错误。  
   - **心得**：“特判 $n=1$ 或 $m=1$ 避免负数计算”。

3. **2018ljw（5星）**  
   - **亮点**：引入出度统计法，高效计算三联通结构数目。  
   - **代码片段**：  
     ```cpp
     // 统计每个格子的出度（可扩展方向）
     for (每个障碍物) {
         for (四邻域) 更新邻域格子的出度，调整 cnt_3；
     }
     ```

---

### 最优思路与技巧
1. **容斥框架**：总方案 - 不合法方案 + 重复扣除的合法方案。  
2. **邻域遍历**：对每个障碍物，枚举其上下左右四个方向，动态更新计数。  
3. **出度统计**：k=3 时，统计中间点的出度组合 $\dbinom{d}{2}$ 避免复杂分类。

---

### 同类型题目
- **P1357 花园**（容斥+矩阵快速幂）  
- **P3223 [HNOI2012]排队**（组合数学）  
- **P3166 [CQOI2014]数三角形**（组合计数）

---

### 可视化与算法演示

#### **核心算法动画设计**
- **网格绘制**：用 Canvas 绘制 $n \times m$ 网格，红色块表示障碍物。  
- **动态标记**：  
  - **高亮当前障碍物**：黄色边框。  
  - **相邻边/三联通结构**：绿色边（合法）→ 红色边（被障碍物阻挡）。  
- **步进控制**：单步展示每个障碍物对计数的调整过程。

#### **复古像素风格**
- **8位调色板**：障碍物（#FF0000）、合法边（#00FF00）、非法边（#808080）。  
- **音效设计**：  
  - **扣除计数**：短促“哔”声。  
  - **完成计算**：8位胜利音效。  

#### **交互设计**
- **控制面板**：暂停/继续/重置按钮，速度滑块。  
- **自动演示**：AI 按顺序遍历障碍物，展示计数更新。

---

### 代码片段（核心逻辑）
```cpp
// 计算 k=2 的合法方案数（daniEl_lElE 核心逻辑）
int main() {
    // ... 输入 n, m, k, t
    ll tot = (n * m - t) % mod;
    ll ans = comb(tot, 2) - cnt_adjacent;
    // 处理每个障碍物
    for (auto &obs : obstacles) {
        for (int dir : 上下左右) {
            if (非障碍且未出界) cnt_adjacent--;
        }
    }
    cout << (ans % mod + mod) % mod;
}
```

---

### 个人心得摘录
- “障碍物的邻域需动态调整，注意边界特判”（__K2FeO4）。  
- “三联通结构统计时，中间点的出度是关键”（2018ljw）。

---
处理用时：82.08秒
# 题目信息

# 『GROI-R1』 古朴而优雅

## 题目背景


会馆内忽地安静了下来。

「敝姓言，名杉。」

他的声音沉稳而凝重，略带沙哑，却不失力度，极具穿透力。每个字都重重地打在耳畔，渗进头脑里，让人想不认真听都难。

「这所学院的院长。」

## 题目描述

杉虽然年事已高，但是还是保持与时俱进。他学习了深度优先遍历算法，觉得这种新潮的东西在一所古朴而优雅的学院里会很受欢迎。所以，他找到了在走廊里晃荡的寒，向他提出了一个问题：

「我们知道，对一棵树进行深度优先遍历可以用下面的伪代码很好地解决。」

$$
\begin{array}{l}
\text{DFS-TREE}(u)\\
\begin{array}{ll}
1 & p\gets p+1\\
2 & t_p\gets u\\
3 & vis_u\gets 1\\
4 & \textbf{for }\text{each edge }(u,v)\in E \\
5 & \qquad \textbf{if }vis_v=0\\
6 & \qquad \qquad \text{DFS-TREE}(v)\\
7 & p\gets p+1\\
8 & t_p\gets u\\
\end{array}
\end{array}
$$

起初，所有变量或数组的值均为 $0$。

「我们把调用 $\text{DFS-TREE}(1)$ 在遍历过程中得到的数组 $t$ 称为这棵树的**遍历顺序**。」

「你看这段代码的第 $4$ 行，这句话**遍历每一条边的顺序是不固定的**。」

寒素来最讨厌不确定的东西，可是碍于院长的颜面，还是继续听下去。

「你能数出这段代码**会生成多少种不同的遍历顺序**吗？」

寒发现他曾经做过这个题，很快地报出了解法。本以为就结束了，可是杉继续说：

「如果我**在树上增加一条边**，你还会做吗？」

寒发现他的那点水平完全不够了，于是他去请教玘。玘却认为这道题目依然很简单，他告诉了寒这道题的做法。可是寒找不到杉了。

这个世界到底怎么了呢？

## 说明/提示

**样例解释**

对于第一次询问可以得到如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ojeiswc8.png)

能得到的遍历顺序有：

- $\{1,2,3,3,2,4,4,1\}$
- $\{1,4,4,2,3,3,2,1\}$
- $\{1,3,2,2,3,4,4,1\}$
- $\{1,4,4,3,2,2,3,1\}$

对于第二次询问可以得到如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6dut5s4r.png)

能得到的遍历顺序有：

- $\{1,2,2,3,3,4,4,1\}$
- $\{1,2,2,4,4,3,3,1\}$
- $\{1,3,3,2,2,4,4,1\}$
- $\{1,3,3,4,4,2,2,1\}$
- $\{1,4,4,2,2,3,3,1\}$
- $\{1,4,4,3,3,2,2,1\}$

**数据范围**

**本题采用捆绑测试。**

| 测试点编号 | 数据范围 | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $\text{Subtask1}$ | $n,q\le8$ |  | $5$ |
| $\text{Subtask2}$ | $n,q\le20$ |  | $10$ |
| $\text{Subtask3}$ | $n,q\le500$ |  | $10$ |
| $\text{Subtask4}$ | $n,q\le3000$ |  | $15$ |
| $\text{Subtask5}$ | $n,q\le2\times10^5$ | $\text{A}$ | $15$ |
| $\text{Subtask6}$ | $n,q\le2\times10^5$ | $\text{B}$ | $10$ |
| $\text{Subtask7}$ | $n,q\le2\times10^5$ |  | $35$ |

特殊性质 $\text{A}$：保证每一次询问的边 $(x,y)\in E$。

特殊性质 $\text{B}$：保证树退化成一条链。

对于 $100\%$ 的数据保证 $1\le n,q\le2\times10^5$，$1\le u,v,x,y\le n$，$x\ne y$。

## 样例 #1

### 输入

```
4 2
1 2
1 3
1 4
2 3
1 4```

### 输出

```
4
6```

# AI分析结果



---

**算法分类**  
树的结构分析（LCA）与组合数学

---

### 题解思路与核心算法

#### **核心思路**
1. **原树方案计算**：通过节点度数阶乘乘积计算遍历顺序总数。
2. **基环树处理**：添加边形成环后，未被遍历的边必在环上，且为环上深度最低点（LCA）的两条相邻边。
3. **快速调整方案数**：利用逆元动态调整度数变化，避免全量计算。

#### **关键步骤**
- **LCA 计算**：倍增法预处理父节点，快速求两点最近公共祖先。
- **阶乘预处理**：预处理阶乘和逆元数组，支持快速调整乘积。
- **度数动态修正**：删除环边时修正度数，利用逆元快速计算新方案数。

#### **解决难点**
- **环边判定**：通过 LCA 确定环的结构，确定可能未遍历的边。
- **动态调整乘积**：仅修改四个节点的度数贡献，时间复杂度从 O(n) 降为 O(1)。

---

### 题解评分（≥4星）

1. **TernaryTree（⭐⭐⭐⭐⭐）**  
   - 思路清晰，结论推导完整，代码结构模块化。  
   - 高效利用倍增法求 LCA，逆元优化乘积计算。  
   - 代码注释完善，边界条件处理严谨（如自环检测）。

2. **E1_de5truct0r（⭐⭐⭐⭐）**  
   - 结论简练，数学推导直观。  
   - 代码实现略简，但对核心逻辑（度数修正）表达明确。

---

### 最优思路与技巧提炼

1. **组合数学优化**  
   - 原树方案数为各节点度数阶乘乘积，通过预计算阶乘和逆元快速调整。
   - 公式：`ans = ∏(deg_u! )` → 动态修正时只需调整变化的四个节点。

2. **LCA 快速定位环结构**  
   - 添加边 (x,y) 后，环的深度最低点为 LCA(x,y)，其相邻环边为关键边。

3. **逆元动态修正**  
   ```cpp
   // 调整度数并计算新方案
   int getans(int u, int v, int x, int y) {
       int cur = ful * inv[deg[u]] % mod * ... ; // 删除旧度数贡献
       deg[u]--, ... ; // 调整度数
       cur = cur * fac[deg[u]] % mod * ... ; // 添加新度数贡献
       return cur;
   }
   ```

---

### 类似题目推荐

1. **P1357 树的计数**（组合数学+树遍历顺序）  
2. **P3384 【模板】轻重链剖分**（LCA与树结构分析）  
3. **P2146 [NOI2015] 软件包管理器**（动态调整树边贡献）

---

### 可视化与算法演示

**动画设计**：  
1. **树与环结构**：  
   - 初始树用绿色线条，新增边用红色标记。  
   - 环部分以黄色高亮，LCA节点闪烁显示。  
2. **度数修正过程**：  
   - 删除边时，相关节点度数减1并标记为红色；添加边时度数加1并标记为绿色。  
3. **逆元计算提示**：  
   - 阶乘调整时，显示公式 `ans = ans * (new_deg! ) / (old_deg! )`。  

**复古像素风格**：  
- **颜色方案**：节点用8位色块（绿：正常，红：被删边，黄：环）。  
- **音效**：调整度数时播放8位"哔"声，计算完成时播放胜利音效。  

---

### 核心代码实现

```cpp
// 预处理阶乘与逆元
void init() {
    fac[0] = 1;
    for (int i = 1; i < maxn; i++) 
        fac[i] = fac[i-1] * i % mod;
    inv[maxn-1] = power(fac[maxn-1], mod-2, mod);
    for (int i = maxn-2; ~i; i--) 
        inv[i] = inv[i+1] * (i+1) % mod;
}

// 动态调整方案数
int getans(int u, int v, int x, int y) {
    int cur = ful * inv[deg[u]] % mod * inv[deg[v]] % mod 
             * inv[deg[x]] % mod * inv[deg[y]] % mod;
    deg[u]--, deg[v]--, deg[x]++, deg[y]++;
    cur = cur * fac[deg[u]] % mod * fac[deg[v]] % mod 
             * fac[deg[x]] % mod * fac[deg[y]] % mod;
    deg[u]++, deg[v]++, deg[x]--, deg[y]--;
    return cur;
}
```

---

**总结**：本题结合树的结构分析与组合数学，通过LCA定位环边，利用逆元优化动态调整，实现高效查询。

---
处理用时：64.73秒
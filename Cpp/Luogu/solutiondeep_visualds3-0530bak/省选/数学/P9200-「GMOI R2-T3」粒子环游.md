# 题目信息

# 「GMOI R2-T3」粒子环游

## 题目背景

热爱珂学的小 Z 正在进行一项无聊的实验。

## 题目描述

实验室中有一个由 $n$ 个实验腔连接而成的环形轨道，其中第 $i$ 个实验腔顺时针连向第 $i+1$ 个实验腔（特别的，第 $n$ 个实验腔连向第 $1$ 个实验腔）。同时还有一个标号为 $n+1$ 的新建实验腔要接入这个环形轨道。它可以接在任意两个原本相连的实验腔之间。

第 $i$ 个实验腔可以将带电荷量为 $Q$ 的粒子运输到它的下一个实验腔，这个过程花费的能量为 $\vert Q \vert \times c_i$。除此之外，第 $i$ 个实验腔本身就存储了量为 $e_i$ 的电荷（电荷量有正负）。由于众所周知的电荷守恒定律，第 $n+1$ 个实验腔储存的电荷量与前 $n$ 个实验腔储存的总电荷量的代数和为 $0$。

小 Z 有一个原本不带电的粒子。等到第 $n+1$ 个实验腔接入轨道后，他要任选一个实验腔（包括第 $n+1$ 个）作为出发点，将粒子放入，并使之在实验腔的能量驱动下顺时针环游一周回到出发点。粒子每到达一个实验腔（包括出发点），它所带电荷量就会变成原来所带的电荷量和这个实验腔所储存的电荷量的代数和。

**注意：电荷量会先加上实验腔所含电荷量，再计算能量贡献。**

现在，小 Z 想知道，在所有接入新建实验腔并选定出发点的方案中，粒子环游一周所需的能量最少为多少？

## 说明/提示

样例 $1$ 解释：一种最优方案为将 $4$ 号实验腔接在 $3$ 号实验腔与 $1$ 号实验腔之间，以 $4$ 号实验腔为出发点，花费能量为 $ 1\times 2\ +\ 4\times 1\ + \vert -1 \vert \times 3 \ +\ 0 \times 2 =9$。

**本题采用 Subtask 捆绑测试。**

| Subtask | $n\le$ | $c_i\le$ | $\vert e_i\vert$ | 特殊性质 | 对应测试点 | 总分 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $300$ | $100$ | $100$ | $-$ | $1\sim 5$ | $10$ |
| $1$ | $10^3$ | $10^3$ | $10^3$ | $\bf A$ | $6\sim 7$ | $5$ |
| $2$ | $10^4$ | $10^4$ | $10^4$ | $-$ | $8\sim12$ | $15$ |
| $3$ | $10^5$ | $10^5$ | $10^5$ | $\bf B$ | $13\sim 16$ | $10$ |
| $4$ | $2.5\times 10^5$ | $10^5$ |$10^5$ | $-$ | $17\sim 25$ | $60$ |

特殊性质 $\bf A$：对于所有的 $i\in[1,n+1](i\in \Z)$，满足 $c_i=0$。

特殊性质 $\bf B$：对于所有的 $i\in[1,n+1](i\in \Z)$，满足 $c_i=1$。

对于 $100\%$ 的数据，$1\le n\le 2.5\times 10^5$，$0\le c_i\le 10^5$，$0\le |e_i|\le 10^5$。

保证答案在 long long 范围内。

## 样例 #1

### 输入

```
3
1 3 2 2
3 -5 1```

### 输出

```
9```

## 样例 #2

### 输入

```
12
4 7 7 8 8 4 5 5 9 10 1 1 10 
0 -5 7 8 1 -1 -6 8 2 4 10 8 ```

### 输出

```
509```

# AI分析结果



---

## 算法分类
**贪心 + 数据结构（带权中位数 + 线段树/树状数组）**

---

## 题解思路与核心难点

### 核心思路
1. **带权中位数模型**  
   将每个实验腔的电荷量前缀和视为数轴上的点，能量计算转化为带权距离和最小问题。最优起点对应带权中位数位置。
2. **动态维护插入位置**  
   枚举第 `n+1` 号腔的插入位置，每次仅影响相邻两个腔的前缀和，通过线段树动态维护电荷和权值信息。
3. **离散化与高效查询**  
   离散化前缀和值域，或使用动态开点线段树处理大范围数值，支持 `O(logn)` 级别的插入、删除和中位数查询。

### 解决难点
- **环形结构的线性化**：通过前缀和将环形问题转化为线性问题，利用电荷守恒定律保证总电荷为0。
- **动态调整的高效性**：每次插入位置变化时，只需修改相邻两个前缀和，保持数据结构维护的复杂度为 `O(logn)`。
- **绝对值优化**：通过带权中位数避免直接处理绝对值，转化为数轴上的几何问题。

---

## 题解评分（≥4星）

### 1. 作者：Aiopr_2378（⭐⭐⭐⭐⭐）
- **关键亮点**  
  动态开点线段树处理大值域，代码结构清晰，注释完整，通过交换操作简化插入位置调整逻辑。
- **核心代码**  
  ```cpp
  void modify(int &p,ll l,ll r,ll goal,ll k){
      if(!p) p=++tot;
      if(l==r){
          tree[p].sz +=k;
          tree[p].sum +=1ll*k*l;
          return;
      }
      ll mid=(l+r)>>1;
      if(goal<=mid) modify(ls,l,mid,goal,k);
      else modify(rs,mid+1,r,goal,k);
      update(p);
  }
  ```

### 2. 作者：yinhy09（官方题解）（⭐⭐⭐⭐）
- **关键亮点**  
  离散化前缀和数组，树状数组维护四类信息（大于/小于当前点的权值和），通过二分快速定位中位数。
- **核心代码**  
  ```cpp
  int find() {
      int u=1, c=0, cpos=nds[1].c/2;
      while(nds[u].l != nds[u].r) {
          if(c + nds[nds[u].lc].c <= cpos) {
              c += nds[nds[u].lc].c;
              u = nds[u].rc;
          } else u = nds[u].lc;
      }
      return nds[u].l;
  }
  ```

### 3. 作者：nullqtr_pwp（⭐⭐⭐⭐）
- **关键亮点**  
  权值线段树维护离散化前缀和，通过交换相邻腔的电荷值实现快速调整，代码简洁高效。
- **核心代码**  
  ```cpp
  void update(R,-D,D,pre[i],a[i-1]-a[n+1]);
  update(R,-D,D,pre[i-1],-a[i-1]);
  swap(e[i],e[i-1]); swap(c[i],c[i-1]);
  ```

---

## 最优技巧提炼
1. **带权中位数快速定位**  
   将绝对值求和问题转化为数轴上的带权中位数问题，避免直接处理复杂绝对值计算。
2. **动态维护数据结构**  
   每次仅修改相邻两个前缀和，利用线段树或树状数组高效维护电荷和权值信息。
3. **离散化与动态开点**  
  处理大范围数值时，离散化或动态开点线段树有效降低空间和时间复杂度。

---

## 同类题目推荐
1. **P1886 滑动窗口**（单调队列维护极值）
2. **P1044 环状最大子段和**（环形结构转化为线性）
3. **P3960 列队**（动态开点线段树维护稀疏区间）

---

## 可视化设计

### 动画方案
1. **像素化数轴展示**  
   - **Canvas 绘制**：以 8-bit 风格显示数轴，每个点标记电荷前缀和，颜色深浅表示权值 `c_i`。
   - **动态插入**：插入新腔时，高亮相邻两个点，显示前缀和的调整过程。
2. **线段树操作高亮**  
   - **节点分裂**：动态开点时，用闪烁边框标记新建节点。
   - **中位线标记**：用红色竖线标记当前中位数位置，随插入位置变化动态移动。
3. **音效与交互**  
   - **操作音效**：插入时播放“滴”声，找到最优解时播放胜利音效。
   - **步进控制**：支持暂停/继续，拖拽进度条观察每一步的前缀和变化。

### 复古风格实现
- **调色板**：使用 FC 风格的 16 色方案（如深蓝、浅绿、橙色）。
- **网格绘制**：数轴以网格划分，每个点用 8x8 像素方块表示。
- **自动演示**：AI 模式自动枚举插入位置，展示最优解的动态调整过程。

---

## 代码片段（关键逻辑）
```cpp
// 动态开点线段树查询中位数（Aiopr_2378 题解）
ll findmid(int p,ll l,ll r,ll k){
    if(!p) return 0;
    if(l==r) return l;
    ll mid=(l+r)>>1;
    if(tree[ls].sz>=k) return findmid(ls,l,mid,k);
    return findmid(rs,mid+1,r,k-tree[ls].sz);
}

// 树状数组维护四类信息（官方题解）
int queryc(int u, int l, int r) {
    if(u==-1) return 0;
    if(l==nds[u].l && r==nds[u].r) return nds[u].c;
    int mid=(nds[u].l+nds[u].r)>>1;
    if(r<=mid) return queryc(nds[u].lc,l,r);
    else if(l>mid) return queryc(nds[u].rc,l,r);
    else return queryc(nds[u].lc,l,mid)+queryc(nds[u].rc,mid+1,r);
}
```

---

**答案提取完毕，可直接用于教学或算法可视化开发。**

---
处理用时：73.14秒
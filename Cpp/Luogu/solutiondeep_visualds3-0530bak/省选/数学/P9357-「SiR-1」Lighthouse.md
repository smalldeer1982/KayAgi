# 题目信息

# 「SiR-1」Lighthouse

## 题目描述

给定一棵 $n$ 个点的树，每个点有权值 $w_i$，初始为 $0$。初始得分 $s=0$。

进行 $m$ 次操作，每次操作选择一个点 $u$，给 $s$ 增加 $u$ 所在的同点权连通块的大小（即，假设只保留点权等于 $w_u$ 的点，和连接两个点权等于 $w_u$ 的点的边，对得分的贡献就是此时 $u$ 所在的连通块大小。注意这不会真的删去一部分树上的点和边），然后给 $w_u$ 增加 $1$。

请对所有 $n^m$ 种操作方式，求它们的得分 $s$ 之和，对 $10^9+7$ 取模。

## 说明/提示

对于所有数据，满足 $1\leq n\leq 1000$，$1\leq m\leq 10^5$，$1\leq u,v\leq n$，保证输入是一棵树。

- Subtask 0（5 pts）：$n,m\le 7$。
- Subtask 1（20 pts）：$n,m\le 10$。
- Subtask 2（15 pts）：$n,m\le 50$。
- Subtask 3（15 pts）：$n,m\le 100$。
- Subtask 4（15 pts）：$n\le 50$。
- Subtask 5（15 pts）：树是一条链。
- Subtask 6（15 pts）：无特殊限制。

本题同时开启子任务依赖。具体地：

+ 对于子任务 $i(i \in [1, 3])$，依赖于子任务 $0 \sim (i -  1)$；
+ 对于子任务 $4$，依赖于子任务 $0 \sim 2$；
+ 对于子任务 $6$，依赖于子任务 $0 \sim 5$。

## 样例 #1

### 输入

```
3 2
1 3
2 3```

### 输出

```
40```

# AI分析结果



**唯一算法分类**: 组合数学与动态规划

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
将总贡献拆解为点对$(u, v)$的贡献，根据路径长度$d$分类统计。通过组合数学和动态规划预处理，高效计算每个$d$对应的概率和贡献。

#### **关键步骤**
1. **贡献拆分**：每个点$v$对$u$的贡献仅与路径长度$d$相关，统计每个$d$的点对数$c_d$。
2. **概率计算**：利用组合数计算路径上点权相等的概率，转化为$\sum \frac{(dw)!}{(w!)^d}$和组合数后缀和。
3. **预处理优化**：阶乘、逆元、幂次预处理加速计算；递推式处理组合数求和。

#### **解决难点**
- **高维求和优化**：通过路径长度分类，将$O(n^2m)$的复杂度降为$O(nm)$。
- **组合数递推**：利用递推式$f_{a,b} = \frac{n-b}{b}f_{a-1,b} - ...$避免重复计算。

---

### **题解评分 (≥4星)**

1. **E.Space (5星)**  
   - 思路清晰，将问题转化为期望计算，数学推导严谨。
   - 预处理阶乘与后缀和优化，代码可读性强。

2. **Sol1 (4星)**  
   - 引入操作$(u,j)$的概念，直观拆解贡献。
   - 递推式优化组合数求和，复杂度合理。

3. **Yanami_Anna (4星)**  
   - 代码简洁，直接预处理后缀和。
   - 利用路径长度分类统计，时间复杂度优秀。

---

### **最优思路或技巧提炼**

1. **路径长度分类**：通过统计不同路径长度的点对数，将复杂贡献拆解为可计算的子问题。
2. **组合数递推**：动态规划处理$\sum \binom{i}{a} \left(\frac{k}{n}\right)^i$，避免暴力计算。
3. **后缀和优化**：预处理后缀和加速$\sum_{k=wl+1}^m C(m,k) (\frac{n-l}{l})^{m-k}$的计算。

---

### **同类型题或类似算法套路**

- **树上路径统计**：如[CF342E Xenia and Tree](https://codeforces.com/problemset/problem/342/E)。
- **组合数学优化**：如[洛谷P3773 [CTSC2017]吉夫特](https://www.luogu.com.cn/problem/P3773)。
- **动态规划预处理**：如[洛谷P2602 [ZJOI2010]数字计数](https://www.luogu.com.cn/problem/P2602)。

---

### **推荐相似题目**

1. **P1350 车的放置**（组合数学与路径计数）
2. **CF559C Gerald and Giant Chess**（组合数递推与动态规划）
3. **P4213 能量采集**（树上路径贡献统计）

---

### **代码核心逻辑**

```cpp
// 预处理阶乘与逆元
Jc[0] = 1;
for (int i = 1; i <= 200000; i++) {
    Jc[i] = Jc[i - 1] * i % P;
    InvJc[i] = power(Jc[i], P - 2);
}

// 统计距离为d的点对数
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        int d = dis(i, j); // 计算路径长度
        Cnt[d]++;
    }
}

// 计算每个d的贡献
for (int l = 1; l <= n; l++) {
    int Fuck = (n - l) * power(l) % P;
    int D = 1;
    // 预处理后缀和Suf[i] = sum_{k=i}^m C(m,k) * (Fuck)^{m-k}
    for (int i = m; i >= 0; i--) {
        Suf[i] = (Suf[i + 1] + C(m, i) * D % P) % P;
        D = D * Fuck % P;
    }
    // 累加每个w的贡献
    int S = 0;
    for (int w = 0; w * l < m; w++) {
        int dinner = Suf[w * l + 1] * Jc[w * l] % P * power(InvJc[w], l) % P * power(l, m - w * l - 1) % P;
        S = (S + dinner) % P;
    }
    ans = (ans + S * Cnt[l]) % P;
}
```

---

### **可视化与算法演示**

**动画方案**：
1. **树结构展示**：Canvas绘制树形图，节点高亮当前操作的$u$。
2. **路径标记**：点击$u$时，动态显示所有可能的$v$及其路径长度$d$。
3. **贡献计算流**：逐步显示每个$d$的$c_d$值，动态累加贡献到总结果。
4. **组合数递推过程**：侧边栏显示递推公式，实时更新$f_{a,b}$的值。

**复古游戏化**：
- **8位音效**：每次累加贡献时播放短促音效，计算完成时播放胜利音效。
- **像素风格**：节点用8位色块表示，路径用闪烁线条标记。

---

**总结**：通过数学拆解与动态规划，将复杂问题转化为可高效计算的子问题，结合预处理与递推优化，最终实现$O(nm)$的优秀复杂度。

---
处理用时：66.34秒
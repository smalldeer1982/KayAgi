# 题目信息

# 挑战 NPC IV

## 题目背景

要是什么都和 NPC 问题一样简单就好了啊。

## 题目描述

小 A 想为小 B 写一首情诗。他现在想出了 $n$ 个句子，每个句子的优美度分别为 $1, 2 \dots n$。小 A 需要按照一定的顺序将他们组合起来，拼成一首完整的诗。换句话说，小 A 需要重新排列这 $n$ 个句子，形成一个 $1 \sim n$ 的排列 $p_1, p_2\dots p_n$；第 $i$ 行诗句的优美度就是原先第 $p_i$ 个句子的优美度，也就是 $p_i$。

不过，由于小 A 是位 OIer，所以他的文采并不是很稳定。他实际上会严重高估自己诗句的优美程度。若一条诗句在小 A 眼里的优美度为 $x$，那么小 B 认为它的优美度是 **$x$ 在二进制表示下最低位的 $1$ 的位置**。其中，小 B 认为最低位的位置是 $1$，次低位为 $2$，以此类推。也就是说，小 B 眼中的优美度 $f(x)$ 为 $1 + \log_2 \operatorname{lowbit}(x)$。

小 A 知道，小 B 拿到诗后，只会选取诗的一段来看，而她感受到的优美度是所有她读到的诗句之和。具体的，若诗有 $n$ 句，则小 B 会在 $[1, n]$ 的所有长度 $> 0$ 的区间中抽取一个 $[l, r]$，感受到 $\displaystyle\sum_{l \leq i \leq r}f(p_i)$ 的优美度。小 A 为了衡量一首诗的优美度，决定将一首诗的总优美度定义为 **所有情况下小 B 感受到的优美度之和**。

照理来说，总优美度最大的组合方式必然是最好的。遗憾的是，在小 A 的精密计算下，他发现，只有他选择总优美度恰好为 **第 $k$ 小** 的情诗时，他才最有可能和小 B 走到一起。于是，小 A 想要知道，对于 $n!$ 首本质不同的诗，第 $k$ 小可能的总优美度是多少。两首诗本质相同当且仅当原排列 $p_1 \dots p_n$ 相同。

小 A 发现这是一个 NPC 问题，他只好来向你求助了。由于总优美度过于巨大，你只需要帮他求出答案对 $998244353$ 取模后的结果。

特别的，小 A 写了 $q$ 组诗句，所以你需要分别回答他的 $q$ 个问题。

## 说明/提示

#### 【样例 1 解释】

例如，当 $p = [1, 3, 2]$ 时，小 B 眼中每句诗的优美度分别为 $[1, 1, 2]$。那么：

- 当 $l = 1$，$r = 1$ 时，优美度之和为 $1$。
- 当 $l = 2$，$r = 2$ 时，优美度之和为 $1$。
- 当 $l = 3$，$r = 3$ 时，优美度之和为 $2$。
- 当 $l = 1$，$r = 2$ 时，优美度之和为 $1 + 1 = 2$。
- 当 $l = 2$，$r = 3$ 时，优美度之和为 $1 + 2 = 3$。
- 当 $l = 1$，$r = 3$ 时，优美度之和为 $1 + 1 + 2 = 4$。

所以 $p = [1, 3, 2]$ 的总优美度为 $1 + 1 + 2 + 2 + 3 + 4 = 13$。

对于所有 $3! = 6$ 个排列 $p$，其总优美度从小到大排序后分别为 $13, 13, 13, 13, 14, 14$，因此当 $k = 2$ 与 $k = 6$ 时答案分别为 $13$ 和 $14$。

---

#### 【样例 2】

见附件下的 $\verb!npc/npc2.in!$ 与 $\verb!npc/npc2.ans!$。

---

#### 【样例 3】

见附件下的 $\verb!npc/npc3.in!$ 与 $\verb!npc/npc3.ans!$。

---

#### 【数据范围】

**本题各测试点时间限制不相同。具体地，每个点的时间限制为 $\max(q\times 0.5, 2)\ \rm{s}$**。

| 测试点编号 | $n$ | $k \leq$ | $q = $ |
| :--------: | :-: | :------: | :----: |
| $1 \sim 3$ | $\leq 10$ | $n!$ | $2$ |
| $4 \sim 8$ | $\leq 10^3$ | $2$ | $7$ |
| $9 \sim 13$ | $\in [10^5, 10^6]$ | $\min(10^{18}, n!)$ | $7$ |
| $14 \sim 17$ | $\leq 10^6$ | $\min(10^{18}, n!)$ | $7$ |
| $18 \sim 25$ | $\leq 10^{18}$ | $\min(10^{18}, n!)$ | $10$|

对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^{18}$，$1 \leq k \leq \min(10^{18}, n!)$，$1 \leq q\le 10$。

## 样例 #1

### 输入

```
2
3 2
3 6```

### 输出

```
13
14
```

## 样例 #2

### 输入

```
5
4 1
4 10
4 16
4 20
4 24```

### 输出

```
32
34
36
36
38```

## 样例 #3

### 输入

```
10
1000000000000000000 1000000000000000000
1145141919810 19260817998244353
15 131413141314
36 93930322810121243
172 354354645654567654
666 233
1048576 2147483648
1000000007 1000000009
99824 44353
10 1```

### 输出

```
36226088
846277092
1096
12356
1239174
70731494
274614617
511280969
625722816
330```

# AI分析结果



## 算法分类：数学与贪心策略

---

### 题解思路与核心难点

#### 核心思路
1. **贡献拆分**：每个位置 $i$ 的贡献次数为 $i \times (n-i+1)$，转化为将不同权值的元素分配到不同贡献位置的问题。
2. **贪心构造最小值**：对 $n \geq 29$ 的情况，将高权值元素分配到低贡献位置（两端），低权值元素分配到高贡献位置（中心）。
3. **动态规划处理小 $n$**：对 $n \leq 28$ 的情况，使用状态压缩 DP 计算每个权值组合的可能方案数。

#### 解决难点
- **大范围 $n$ 的快速计算**：通过数学公式快速计算每个权值对应的贡献区间和。
- **状态压缩 DP 的设计**：通过五维状态记录不同权值的剩余数量，避免暴力枚举所有排列。

---

### 题解评分（≥4星）

1. **樱雪喵（5星）**
   - **亮点**：清晰的分治策略，数学公式推导完整，代码实现高效。
   - **代码结构**：分离大 $n$ 和小 $n$ 处理逻辑，动态规划状态设计简洁。

2. **Register_int（4星）**
   - **亮点**：简洁的 DFS 记忆化实现，快速计算方案数。
   - **缺点**：数学推导部分未详细展开。

3. **JiaY19（4星）**
   - **亮点**：数学推导与拉格朗日插值结合，优化贡献计算。
   - **缺点**：动态规划实现稍显复杂。

---

### 最优思路提炼

1. **分治策略**：对 $n$ 的大小进行分治处理，大 $n$ 直接贪心，小 $n$ 动态规划。
2. **数学公式推导**：
   - 贡献和公式：$\sum_{i=l}^r i(n-i+1) = (n+1)\frac{(l+r)(r-l+1)}{2} - \frac{r(r+1)(2r+1) - l(l-1)(2l-1)}{6}$。
   - 权值分布公式：$f(x)=i$ 的元素数量为 $\lfloor \frac{n}{2^{i-1}} \rfloor - \lfloor \frac{n}{2^i} \rfloor$。
3. **动态规划状态压缩**：用五维状态 $dp_{a,b,c,d,e,sum}$ 表示不同权值的剩余数量和当前总优美度。

---

### 同类型题推荐
1. **P1012 [NOIP1998 提高组] 拼数**（贪心排序策略）
2. **P1056 [NOIP2008 普及组] 排座椅**（贪心选择最优位置）
3. **P1776 宝物筛选**（状态压缩动态规划）

---

### 个人心得摘录
- **樱雪喵**：当 $n \geq 29$ 时，最小值的排列数超过 $10^{18}$，直接贪心即可。
- **JiaY19**：利用拉格朗日插值优化贡献计算，避免直接求和的时间消耗。
- **DengDuck**：动态规划状态设计需注意空间压缩，避免维度爆炸。

---

### 可视化与算法演示

#### 核心算法流程（贪心部分）
1. **初始化**：双指针 $l=1$, $r=n$，从高到低枚举权值 $i$。
2. **分配区间**：
   - 计算当前权值的元素数量 $cnt$。
   - 将 $cnt/2$ 个元素分配到左区间 $[l, l+cnt/2-1]$，剩余分配到右区间 $[r-cnt/2+1, r]$。
3. **贡献计算**：对每个区间使用数学公式快速求和，累加总贡献。

```javascript
// 伪代码：贪心分配贡献区间
let l = 1, r = n, ans = 0;
for (let i = max_level; i >= 1; i--) {
    const cnt = calculate_count(i); // 计算权值i的元素数量
    const left = Math.ceil(cnt / 2), right = cnt - left;
    ans += i * sum_contribution(l, l + left - 1); // 左区间贡献
    ans += i * sum_contribution(r - right + 1, r); // 右区间贡献
    l += left;
    r -= right;
}
```

#### 复古像素化动画设计
- **颜色方案**：使用 8 位色（#FF0000 红、#00FF00 绿等）标记当前操作的区间。
- **音效**：分配元素时播放“放置”音效，计算贡献时触发“计算完成”音效。
- **Canvas 绘制**：用不同颜色方块表示区间分配，动态更新指针位置。

---

### 核心代码实现（樱雪喵题解）
```cpp
void solve(int n) {
    int l = 1, r = n, res = 0;
    for (int i = __lg(n) + 1; i >= 1; i--) {
        int sum = (n >> i) + (n >> (i-1) & 1);
        int ls = sum / 2, rs = sum - ls;
        if (l < n - r + 1) swap(ls, rs);
        res += i * get(l, l + ls - 1, n + 1);
        res += i * get(r - rs + 1, r, n + 1);
        l += ls; r -= rs;
    }
    printf("%d\n", res % mod);
}
```

---

### 关键优化点
- **数学公式优化**：将 $O(n)$ 求和转化为 $O(1)$ 公式计算。
- **动态规划状态压缩**：通过限制权值种类（最多5种），将状态数压缩到可行范围。

---
处理用时：80.95秒
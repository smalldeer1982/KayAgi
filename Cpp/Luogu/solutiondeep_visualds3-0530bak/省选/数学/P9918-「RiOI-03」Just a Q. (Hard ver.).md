# 题目信息

# 「RiOI-03」Just a Q. (Hard ver.)

## 题目背景

「Yes, I am Q.」

面前的小 R 莞尔一笑。

+ 保证本题的任何合理的部分分或正解的 std + spj 均可以在当前数据下，$900$ ms 的时间限制、$32$ MB 的空间限制内正确运行并获得 AC 状态。
+ 本题不添加仅为无意义地卡满 spj 运行时间的 hack 数据。

**请注意，本题只有约束范围与普通版不同，且两个版本的约束范围并不完全重叠。**

## 题目描述

**这是一道交互题。**

小 R 有一个变量 $Q$。$Q$ 初始为 $0$。

小 R 有 $n$ 个隐藏的整数 $q_1 \dots q_n$，满足 $1 \leq \lvert q_i \rvert \leq V$，且有且仅有一个 $i$ 满足 $q_i \lt 0$，而面前的你，需要得出这个满足 $q_i \lt 0$ 的下标 $i$。

小 R 承诺不会让你以仅仅 $\frac{1}{n}$ 的几率盲猜，所以她可以允许你进行最多 $k$ 次询问。每次询问，你可以向小 R 给出**可重**正整数集合 $S$ 满足 $0 \leq \lvert S \rvert \leq S_{\max}$ 且 $\forall i \in S, i \leq n$，她会计算 $M = \prod\limits_{i\in S}q_i$，然后让 $Q \leftarrow Q + M$。特殊地，若 $S$ 为空集，则 $M = 1$。

一次询问后，小 R 会向你给出此时的 $\text{sgn}(Q)$（为 `+`，`-` 或 `0`），表示 $Q$ 的符号。具体地，若 $Q \gt 0$，小 R 返回 `+`；若 $Q \lt 0$，小 R 返回 `-`；否则返回 `0`。

请你在不超过 $k$ 次询问后，找到那个满足 $q_i \lt 0$ 的下标 $i$。

**保证对于所有数据，满足 $q_i \lt 0$ 的下标 $i$ 是在 $[1, n]$ 内均匀随机选取的。请注意报告下标属于一次询问。**

## 说明/提示

### 样例解释 1

$q = \{-1, 1, 4, 5, 1, 4\}$。

### 数据规模与约定

**本题采用捆绑测试。**

| 子任务编号 | $n \leq$ | $T \leq$ | $k = $ | $S_{\max} = $ | 分值 |
| :-: | :-: | :-: | :-: | :-: | :-: |
| $0$ | $200$ | $500$ | $20$ | $20n + 1$ | $11$ |
| $1$ | $1000$ | $50$ | $41$ | $8n + 10$ | $25$ |
| $2$ | $1000$ | $50$ | $50$ | $6n + 10$ | $30$ |
| $3$ | $10^4$ | $10$ | $39$ | $\lceil 1.5n\rceil + 10$ | $34$ |

对于子任务 $0, 1, 3$，若通过所有测试点则获得全部分数，否则获得 $0$ 分。

对于子任务 $2$：

+ 你需要保证你所使用的实际操作次数 $k'$ 满足 $0 \leq k' \leq 50$。
+ 你需要保证你所使用的实际操作次数 $S'$ 满足 $0 \leq S' \leq 6n + 10$。
+ 单个测试点的得分为 $\left(1 - \max(\frac{\max k' - 35}{20}, \max(\frac{S' - 3n - 10}{4n + 1}), 0)\right)\times 30$。
+ Subtask 的得分取所有测试点的得分最小值。

对于所有数据，$1 \leq V \leq 10^6$，$1 \leq n \leq 10^4$，$1 \leq T \leq 500$，**注意由于交互库限制 $\bm{n, T}$ 不会同时取到最大值**；此外，对每个子任务 $k, S_{\max}$ 的值已经给出。

## 样例 #1

### 输入

```
1
6 6 6

-

-

-

+

0


```

### 输出

```


? 1 1

? 5 1 2 3 4 5

? 3 2 4 6

? 1 4

? 3 1 5 6

! 1```

# AI分析结果



**唯一算法分类**：数论

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
- **目标**：在最多 `k` 次询问内，通过符号反馈确定唯一的负元素下标。
- **关键数学逻辑**：利用分治策略，结合大绝对值乘积覆盖历史操作的影响，确保每次询问符号由当前集合主导。

#### **题解对比**
1. **irris 的二分法**：
   - **要点**：维护动态集合 `S`，通过符号变化调整二分区间。若符号不变，合并集合以翻转符号。
   - **难点**：需动态维护 `S` 的符号，保证后续询问的有效性。
   - **复杂度**：`S_max ≈ 1.5n`，询问次数 `O(n)`。

2. **lgvc 的分治+大数覆盖**：
   - **要点**：每次分治时询问左右两半的乘积符号，递归进入符号为负的区间。利用大绝对值乘积覆盖历史 `Q` 的影响。
   - **难点**：选择足够大的乘积，确保符号由当前集合主导。
   - **复杂度**：`S_max ≈ n + logn`，询问次数 `O(logn)`。

3. **vzcx_host 的常驻集合法**：
   - **要点**：维护常驻集合 `R`，每次选择较大绝对值的部分加入 `R`，保证后续符号由 `R` 主导。
   - **难点**：动态更新 `R` 并确保其乘积足够大。
   - **复杂度**：`S_max ≈ n + logn`，询问次数 `O(logn)`。

#### **精炼结论**
- **最优策略**：分治 + 大数覆盖。通过递归分治，每次选择较大绝对值的集合，使历史 `Q` 的影响可忽略，符号判断仅依赖当前集合。
- **数学关键**：若 `|A| > |B|`，则 `A + B` 的符号由 `A` 决定，用于快速缩小负元素范围。

---

### **题解评分 (≥4星)**

1. **lgvc 的题解**（5星）  
   - **亮点**：代码简洁，利用大数覆盖巧妙消除历史影响，询问次数最优。
   - **代码片段**：
     ```cpp
     int sv(int l, int r) {
         if(l==r) return l;
         int md=(l+r)>>1;
         std::multiset<int> s1,s2;
         // 分治逻辑...
     }
     ```

2. **vzcx_host 的题解**（4.5星）  
   - **亮点**：理论分析深入，提出常驻集合维护策略，复杂度优秀。
   - **关键公式**：`|Q| < Mul(R)` 保证符号由 `R` 主导。

3. **irris 的题解**（4星）  
   - **亮点**：动态集合维护直观，适用于不同约束，但实现复杂度稍高。

---

### **最优技巧提炼**
- **分治+大数覆盖**：递归将区间分为两半，优先选择乘积绝对值大的部分，确保符号由当前步骤主导。
- **符号主导原则**：若 `|A| > |B|`，则 `A + B` 的符号与 `A` 一致，用于快速判定负元素所在区间。

---

### **同类型题与套路**
- **常见套路**：分治 + 符号主导判断，适用于唯一性查找问题。
- **类似题目**：
  1. **洛谷 P1224**：利用乘积和符号判断向量关系。
  2. **洛谷 P1712**：区间选择问题，需动态维护集合属性。
  3. **洛谷 P1908**：逆序对问题，分治策略典型应用。

---

### **可视化与算法演示**
- **动画设计**：
  1. **分治步骤**：以像素风格展示区间 `[l, r]` 分割为 `[l, mid]` 和 `[mid+1, r]`。
  2. **符号判断**：高亮当前集合乘积符号，播放音效提示符号变化。
  3. **递归过程**：用不同颜色标记当前活跃区间，逐步缩小范围。
- **复古风格**：8位像素界面，分治步骤配以经典音效（如《吃豆人》），积分系统记录有效询问次数。

---

**示例代码（lgvc 分治核心）**：
```cpp
int sv(int l, int r) {
    if (l == r) return l;
    int md = (l + r) >> 1;
    std::multiset<int> s1, s2;
    for (int i = l; i <= md; i++) s1.insert(i);
    for (int i = md + 1; i <= r; i++) s2.insert(i);
    int a = q(s1), b = q(s2);
    // 根据符号递归进入对应区间
}
```

---

**总结**：分治策略结合符号主导原则，通过大数覆盖消除历史影响，是本题的最优解。其数学核心在于绝对值大小的符号主导性，可推广至类似唯一性查找问题。

---
处理用时：72.70秒
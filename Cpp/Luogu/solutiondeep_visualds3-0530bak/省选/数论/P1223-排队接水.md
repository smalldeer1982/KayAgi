# 题目信息

# 排队接水

## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。


## 说明/提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。


## 样例 #1

### 输入

```
10 
56 12 1 99 1000 234 33 55 99 812```

### 输出

```
3 2 7 8 1 4 9 6 10 5
291.90
```

# AI分析结果



### 算法分类
**贪心算法**

---

### 题解思路与算法要点
1. **核心算法推导**  
   所有题解均基于贪心策略：按接水时间从小到大排序。数学证明表明，相邻两人中时间短的在前总等待时间更优，由此推导出全局最优解。
   
2. **数据结构与实现**  
   - **结构体/pair 存储**：将接水时间与原始序号绑定，排序后直接输出序号（如 BlueArc、Anguei 题解）。
   - **编码法**：将时间乘以大数并加上序号（如 1001），排序后取模解码（如 f112358 题解）。
   - **等待时间计算**：总时间公式为 $\sum_{i=1}^n T_i \cdot (n-i)$，避免逐层累加。

3. **解决难点**  
   - **序号保留**：通过绑定时间与序号，确保排序后能正确输出原始排列。
   - **精度问题**：必须用 `double` 存储平均值，否则会因整数截断导致错误（如花千树题解）。

---

### 题解评分 (≥4星)
| 作者         | 评分 | 核心亮点                                                                 |
|--------------|------|--------------------------------------------------------------------------|
| **f112358**  | ★★★★☆ | 巧用数值编码，避免结构体，代码简洁高效                                   |
| **BlueArc**  | ★★★★☆ | 结构体清晰，公式推导明确，适合教学                                       |
| **Anguei**   | ★★★★☆ | 使用 `std::pair` 和动态内存，展示现代 C++ 特性                           |

---

### 最优思路与技巧
1. **贪心策略证明**  
   相邻交换法证明：若 $T_i < T_j$，则 $T_i$ 在前总等待时间更优。
   
2. **高效编码法**  
   通过 $T_i \cdot 1001 + i$ 编码，排序后取模还原序号，避免结构体（代码片段）：
   ```cpp
   t[i] = x * 1001 + i;  // 编码
   sort(t+1, t+1+n);
   cout << t[j] % 1001;   // 解码
   ```

3. **等待时间优化公式**  
   总时间计算无需逐层累加，直接使用 $\sum T_i \cdot (n-i)$。

---

### 同类型题与算法套路
- **任务调度**：最小化平均等待时间（如 SJF 调度算法）。
- **区间贪心**：如选择不重叠区间、最小化延迟等。

---

### 推荐题目
1. **P1090 [NOIP2004 提高组] 合并果子**（贪心+优先队列）
2. **P1106 删数问题**（贪心选择数字排列）
3. **P1233 木棍加工**（双关键字贪心排序）

---

### 个人心得摘录
> "必须用 `double` 存储平均值，否则会因整数截断导致错误" —— 花千树  
> "结构体排序时，若时间相同需按原始序号排序" —— 冷、雨夜  
> "冒泡排序虽慢，但对新手更友好" —— 封禁用户  

---

### 可视化算法设计
#### 核心逻辑演示
1. **像素化排序动画**  
   - **Canvas 网格**：每个方块表示一个人，颜色深浅表示接水时间。
   - **高亮当前最小**：红色边框标记当前未排序中最小的 $T_i$。
   - **交换动画**：冒泡或快速排序时，展示元素交换过程。

2. **等待时间累加**  
   - **动态公式显示**：右侧面板实时更新 $\sum T_i \cdot (n-i)$。
   - **进度条**：展示已计算部分占总时间的比例。

#### 复古游戏化实现
- **8-bit 音效**：
  - **选中元素**：短促 "滴" 声（Web Audio API 生成方波）。
  - **排序完成**：播放经典 FC 过关音乐片段。
- **积分系统**：
  - **正确排序**：+10 分，连续正确触发 2x 连击。
  - **错误提示**：屏幕抖动 + 扣分音效。

#### 代码片段（JS 伪代码）
```javascript
// 排序动画核心逻辑
function animateSort(arr) {
  let minIndex = 0;
  for (let i = 0; i < arr.length; i++) {
    // 高亮当前最小元素
    drawHighlight(minIndex, 'red'); 
    playSound(500, 0.1); // 500Hz 方波
    
    if (arr[i].time < arr[minIndex].time) 
      minIndex = i;
    
    // 交换元素动画
    if (i !== minIndex) {
      animateSwap(i, minIndex);
      playSound(800, 0.2);
    }
  }
}
```

---

### 完整代码参考
**f112358 题解核心代码**：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

long long t[1001];

int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        t[i] = x * 1001LL + i; // 编码：时间*1001 + 序号
    }
    sort(t + 1, t + 1 + n);
    
    double sum = 0;
    for (int j = 1; j <= n; j++) {
        cout << t[j] % 1001 << " "; // 解码取序号
        sum += (t[j] / 1001) * (n - j); // 解码取时间并计算
    }
    printf("\n%.2lf\n", sum / n);
    return 0;
}
```

---
处理用时：66.22秒
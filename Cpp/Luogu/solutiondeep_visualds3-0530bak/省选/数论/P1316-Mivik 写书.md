# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果



## 算法分类
**容斥原理 + 组合数学**

---

## 题解思路与核心难点分析

### 核心思路
题目要求计算所有随机生成的字符串的本质不同子串数目期望。关键思路是**枚举每个可能子串的出现模式，通过容斥原理计算其贡献**。核心难点在于高效处理大量重复子串的覆盖情况。

### 算法要点
1. **逆向容斥**：枚举子串长度和出现位置集合，计算每个模式对总贡献的影响（奇数次出现加，偶数次减）。
2. **并查集合并约束**：当子串在多个位置出现时，对应字符必须相同。用并查集快速合并约束，统计独立变量数量。
3. **快速幂优化**：自由变量数的指数计算通过预处理的快速幂优化。

### 解决难点对比
- **Mivik**：通过生成函数和多项式插值理论推导，适合更大数据范围但实现复杂。
- **Huasushis & 7KByte**：直接枚举子串位置集合，用并查集处理约束，复杂度 $O(n^2 2^n)$，代码简洁高效。

---

## 题解评分 (≥4星)
1. **Huasushis（5星）**  
   - 思路清晰，代码简洁，通过位运算与并查集直观体现容斥逻辑。
   - 关键亮点：用 `__builtin_ctz` 快速处理二进制位，并查集统计自由变量。
2. **7KByte（4星）**  
   - 代码高度精简，预处理加速位操作。
   - 亮点：通过掩码和位运算优化枚举过程，但代码注释较少。
3. **Reunite（4星）**  
   - 与 Huasushis 思路一致，但变量命名和实现稍显冗长。

---

## 最优思路提炼
1. **容斥框架**：  
   - 对每个子串长度 $x$，枚举其所有可能出现的左端点集合 $S$。
   - 贡献系数为 $(-1)^{|S|+1}$，通过二进制位运算快速枚举。
2. **并查集合并约束**：  
   - 对每个出现位置，合并子串覆盖的字符位置为连通块。
   - 自由变量数 = 未覆盖位置数 + 连通块数，贡献为 $m^{\text{自由变量数}}$。
3. **位运算加速**：  
   - 使用 `__builtin_ctz` 快速定位最低有效位，优化并查集合并效率。

---

## 同类型题与算法套路
- **相似算法**：容斥处理重复覆盖问题 + 并查集维护约束。
- **典型题目**：  
  1. [P2567 幸运数字](https://www.luogu.com.cn/problem/P2567)（容斥求不重复数）
  2. [P3343 地震后的幻想乡](https://www.luogu.com.cn/problem/P3343)（容斥+期望）
  3. [P5644 排列问题](https://www.luogu.com.cn/problem/P5644)（覆盖计数）

---

## 推荐相似题目
1. **P3802 小魔女帕琪**（期望计算）  
2. **P3174 毛毛虫**（树形DP+容斥）  
3. **P3223 排队**（排列组合+容斥）

---

## 个人心得摘录
> "容斥应该算是很经典的，非常适合像我一样的组合蒟蒻食用。" —— Huasushis  
> 调试中发现位运算处理边界需谨慎，例如 `c & -c` 快速取最低有效位时需保证非零。

---

## 算法可视化设计
### 核心动画逻辑
1. **像素网格展示**：  
   - 用 8x8 像素网格表示字符串位置，高亮当前枚举的子串覆盖区域。
   - 不同颜色区分已合并的连通块（如红色表示强制相同，绿色表示自由变量）。
2. **并查集合并演示**：  
   - 当子串覆盖新位置时，显示并查集的 `find` 和 `union` 操作，用连线动画连接合并的节点。
3. **音效提示**：  
   - 每次合并触发 "哔" 音效，贡献计算完成时播放上升音阶。
   - 错误覆盖（如冲突合并）时播放低沉警告音。

### 复古风格实现
```javascript
// 伪代码示例：像素绘制与音效
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');

function drawGrid(pos, len) {
  // 绘制 n x n 网格，高亮 pos 开始的 len 长度子串
  ctx.fillStyle = '#8B00FF'; // 复古紫色
  ctx.fillRect(pos * 8, 0, len * 8, 8); // 8x8 像素块
}

function playSound(freq) {
  const osc = audioCtx.createOscillator();
  osc.frequency.value = freq; // 根据操作类型调整频率
  osc.connect(audioCtx.destination);
  osc.start(); osc.stop(0.1);
}
```

---

## 核心代码实现（Huasushis 版）
```cpp
#include <bits/stdc++.h>
#define mod 1000000007ll
using namespace std;
using ll = long long;
int n; ll m;
ll qp(ll x, ll y) { /* 快速幂 */ }

void sol(int x) {
  int a = (1 << (n - x + 1));
  for (int i = 1; i < a; ++i) {
    int c = 0, tot = 0;
    for (int j = 0; j < x; ++j) fa[j] = j;
    for (int j = 0; j < n; ++j) { // 处理每个字符位
      c = (c << 1) | ((i >> j) & 1);
      c &= (1 << x) - 1;
      if (!c) ++tot; // 未覆盖位置
      else { // 合并约束
        int t = c - (c & -c), tmp = __builtin_ctz(c);
        while (t) fa[getfa(__builtin_ctz(t))] = getfa(tmp), t -= t & -t;
      }
    }
    // 统计连通块数
    for (int j = 0; j < x; ++j) tot += (getfa(j) == j);
    ans += (__builtin_parity(i) ? 1 : -1) * qp(m, tot);
  }
}
```

---
处理用时：77.97秒
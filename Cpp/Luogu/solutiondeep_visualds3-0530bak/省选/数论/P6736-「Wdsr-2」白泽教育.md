# 题目信息

# 「Wdsr-2」白泽教育

## 题目背景

上白泽慧音在给雾之湖的妖精们讲课。

某天，慧音在上数学课时，提到了一种非常有趣的记号：**高德纳箭号表示法**。它可以用来描述非常巨大的数字。~~比如紫的年龄。~~

对于非负整数 $a, b$ 和正整数 $n$，高德纳箭号表示法的定义为：

$$a \uparrow^n b = \begin{cases}
1\ (b = 0) \\
a^b\ (n = 1\ \operatorname{and}\ b > 0) \\
a \uparrow^{n - 1} (a \uparrow^n (b - 1))\ (n > 1\ \operatorname{and}\ b > 0)
\end{cases}$$

一些简单的例子：

- $2 \uparrow 31 = 2^{31} = 2147483648$

- $2 \uparrow \uparrow 4 = 2^{2^{2^2}} = 2^{2^4} = 2^{16} = 65536$

注：
1. $a \uparrow b$ 与 $a \uparrow^1 b$ 相同；

2. $a \uparrow \uparrow b$ 与 $a \uparrow^2 b$ 相同；

3. 请注意幂运算的顺序。

## 题目描述

慧音希望琪露诺解决以下关于 $x$ 的方程：

$$a \uparrow^n x \equiv b \pmod p$$

其中，$a, n, b, p$ 为已知的常数，$x$ 为未知数。

琪露诺被高德纳箭号表示法搞得云里雾里的，但是她不想被头槌。你能帮帮她吗？

## 说明/提示

**本题开启捆绑测试。**

| Subtask | $n$ | $p$ | $T$ | 分值 | 时限 |
| :------: | :------: | :------: | :------: | :------: | :------: |
| $1$ | $n = 1$ | $2 \leq p \leq 10^9$ 且 $p$ 为质数 | $1 \leq T \leq 100$ | $15 \operatorname{pts}$ | $2.00 \operatorname{s}$ |
| $2$ | $n = 2$ | 无特殊限制 | $1 \leq T \leq 5 \times 10^3$ | $25 \operatorname{pts}$ | $1.00 \operatorname{s}$ |
| $3$ | $n = 3$ | 无特殊限制 | 无特殊限制 | $60 \operatorname{pts}$ | $2.00 \operatorname{s}$ |

对于 $100\%$ 的数据，$1 \leq a \leq 10^9$，$1 \leq n \leq 3$，$0 \leq b < p \leq 10^9$，$1 \leq T \leq 2 \times 10^4$。

## 样例 #1

### 输入

```
3
2 1 1 3
3 1 2 7
7 1 2 4```

### 输出

```
0
2
-1```

## 样例 #2

### 输入

```
3
2 2 4 7
3 2 4 6
5 2 1 3```

### 输出

```
2
-1
0```

## 样例 #3

### 输入

```
3
4 3 5 8
2 3 9 11
6 3 1 5```

### 输出

```
-1
3
0```

# AI分析结果



---

## 算法分类选择  
**数论（扩展欧拉定理、BSGS、递归幂塔计算）**

---

## 题解思路、算法要点与解决难点  

### **核心思路**
1. **Subtask1 (n=1)**  
   - 转化为离散对数问题，使用 **BSGS 算法**直接求解。
2. **Subtask2 (n=2)**  
   - 构建 **欧拉函数链**（φ(p), φ(φ(p)), ...），利用扩展欧拉定理递归计算幂塔。
   - 枚举可能的 x，判断是否满足模方程。
3. **Subtask3 (n=3)**  
   - 递归计算高德纳箭号，当层数超过一定阈值时直接截断（如取 `k1`）。
   - 特判 a=2 的边界情况，其他情况下通过预判稳定值减少计算量。

### **解决难点**
- **扩展欧拉定理的应用**  
  处理幂塔时需判断指数是否大于当前模数的 φ 值，决定是否加 φ(p)。
- **递归终止条件**  
  当模数递归至 1 时终止，此时任何数模 1 均为 0。
- **枚举上界优化**  
  根据 φ 函数快速收敛至 1 的特性，将 x 的枚举上界设为 O(log p)。

---

## 题解评分 (≥4星)  

### **Leasier 的题解（5星）**  
- **亮点**  
  - 完整处理所有 Subtask，代码结构清晰。  
  - 使用 `Node` 结构体标记是否溢出，精确处理扩展欧拉定理。  
  - 预处理欧拉函数链，递归计算幂塔。  
- **适用性**  
  代码可读性强，适合快速理解算法全貌。

### **LightningUZ 的题解（4.5星）**  
- **亮点**  
  - 对 n=3 的情况采用特判，大幅减少计算量。  
  - 利用预先筛法优化欧拉函数计算。  
- **不足**  
  代码部分边界条件处理不够明显，需结合注释理解。

### **_Fontainebleau_ 的题解（4星）**  
- **亮点**  
  - 简洁的递归实现，快速处理幂塔计算。  
  - 对 a=2 的边界条件详细处理。  
- **不足**  
  预处理筛法范围较小，可能对大 p 不友好。

---

## 最优思路或技巧提炼  

### **关键技巧**
1. **欧拉函数链预处理**  
   递归计算每一层的模数 φ(p), φ(φ(p)), ...，直到为 1。
2. **扩展欧拉定理的标记法**  
   用 `Node` 结构体（值 + 溢出标志）判断是否加 φ(p)。
3. **幂塔的递归截断**  
   当层数足够大时，直接返回一个足够大的值，避免无限递归。

---

## 同类型题或类似算法套路  

### **通用解法**
- **幂塔取模**  
  类似题目：POJ 3882、洛谷 P3747（相逢是问候）。
- **高德纳箭头递归计算**  
  适用于涉及超大规模数取模的场景。

---

## 推荐相似题目  
1. **洛谷 P4195**：扩展 BSGS（离散对数问题）。  
2. **洛谷 P3747**：幂塔取模与扩展欧拉定理。  
3. **Codeforces 906D**：递归幂次取模。

---

## 个人心得摘录  
- **LightningUZ 的调试经验**：  
  > “注意读进来的 a 不要先模 p，因为幂塔的模数是 φ(p) 链，而非原 p。”  
- **Leasier 的优化思考**：  
  > “欧拉函数嵌套至多 O(log p) 次就会变为 1，这是枚举上界的关键。”  

---

## 可视化与算法演示  

### **核心算法流程**
1. **欧拉函数链生成**  
   - 动态显示从 p 到 1 的 φ 值递归链。
   - **颜色标记**：当前计算的模数层级（如红→蓝→绿）。
2. **幂塔计算过程**  
   - 逐步展开 `a↑^n x` 的递归结构，高亮当前计算的指数部分。
   - **动画效果**：递归层数增加时，显示箭头展开（如 `a↑↑3` 展开为 `a^(a↑↑2)`）。
3. **扩展欧拉判断**  
   - 在计算 `a^b mod m` 时，若 b ≥ φ(m)，显示红色警示框并触发音效。

### **复古像素风格设计**
- **Canvas 绘制**：  
  - 用 8 位像素风格绘制递归树，每层用不同颜色方块表示。
  - 箭头操作符用像素字体显示（如 `↑↑` 用两个上箭头符号）。
- **音效设计**：  
  - **成功匹配**：8-bit 胜利音效（上升音阶）。  
  - **递归终止**：短促“滴”声。  
  - **溢出标记**：经典 FC 错误音效。

---

## 关键代码实现（Leasier 解法核心）  

```cpp
// 递归计算幂塔 a↑↑n mod phi_chain[index]
Node tetration(int a, int n, int index) {
    if (phi[index] == 1) return {0, true}; // 模1直接返回0
    if (n == 0) return {1, false};        // 递归终止条件
    Node x = tetration(a, n-1, index+1);   // 递归计算上层
    if (x.flag) x.val += phi[index+1];    // 扩展欧拉定理处理
    return quick_pow(a, x.val, phi[index]); // 快速幂取模
}
```

---

## 总结  
本题通过嵌套应用扩展欧拉定理，结合 BSGS 和递归剪枝，解决了高德纳箭号模方程问题。最优解法需预处理欧拉函数链，并通过标记法处理溢出，是数论与递归思维的经典结合。

---
处理用时：82.70秒
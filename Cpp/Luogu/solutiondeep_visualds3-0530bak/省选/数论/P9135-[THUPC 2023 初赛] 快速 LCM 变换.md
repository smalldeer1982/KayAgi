# 题目信息

# [THUPC 2023 初赛] 快速 LCM 变换

## 题目描述

小 I 今天学习了快速最小公倍数变换（Fast Least-Common-Multiple Transform, FLT），于是他想考考你。

给定一个长度为 $n$ 的正整数序列 $r_1,r_2,\cdots,r_n$。你需要做以下操作恰好一次：

- 选择整数 $i,j$ 使得 $1 \le i < j \le n$。在序列末尾加入 $(r_i+r_j)$，并将 $r_i$ 和 $r_j$ 从序列中删除。

可以注意到总共有 $\frac{n(n-1)}{2}$ 种可能的操作，每种操作会得到一个长度为 $n-1$ 的序列。

你需要对所有的这 $\frac{n(n-1)}{2}$ 个序列，求出序列中所有元素的最小公倍数，并给出它们的和模 $998244353$ 的值。

## 说明/提示

#### 样例解释 1

- $i=1,j=2$ 时，得到的序列为 $\{4,5\}$，最小公倍数为 $20$；
- $i=1,j=3$ 时，得到的序列为 $\{3,6\}$，最小公倍数为 $6$；
- $i=2,j=3$ 时，得到的序列为 $\{2,7\}$，最小公倍数为 $14$。

因此输出为 $20+6+14=40$。

#### 子任务

对于所有测试数据，$2 \le n \le 5 \times 10^5, 1 \le r_1,r_2,\cdots,r_n \le 10^6$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
3
2 3 4
```

### 输出

```
40
```

# AI分析结果



# **算法分类**
**数学（数论）与快速数论变换（NTT）**

---

# **题解思路与核心算法分析**

### **核心思路**
所有题解的核心逻辑均可归纳为以下四步：
1. **质因数分解预处理**：记录每个质数在原始序列中的最大指数、次大指数
2. **贡献系数计算**：计算每个数被删除时对 LCM 的衰减系数（debuff 系数）
3. **NTT 卷积加速**：统计所有数对和对应的贡献系数乘积
4. **新增元素贡献调整**：计算新加入元素对 LCM 的增益系数，整合总答案

### **关键算法要点**
#### **1. 质因数分解预处理**
- **最大/次大指数记录**  
  对每个质数 $p$ 维护两个值：  
  - `mx[p]`：所有数中 $p$ 的最大指数
  - `cmx[p]`：所有数中 $p$ 的次大指数（允许等于 `mx[p]`）

- **贡献系数计算**  
  对每个数 $a_i$，计算其删除后的 LCM 衰减系数 $d_i$：  
  $$d_i = \prod_{p \mid a_i} \frac{1}{p^{\text{mx}[p] - \text{cmx}[p]}} \quad (\text{仅当 } v_p(a_i)=\text{mx}[p] \text{ 时生效})$$

#### **2. NTT 卷积加速**
- **频次统计**：构建数组 $f$，其中 $f[x]$ 表示数值 $x$ 的 $d_i$ 系数之和
- **卷积计算**：通过 NTT 计算 $f * f$，得到所有数对 $(a_i,a_j)$ 的和为 $k$ 时的系数乘积总和
- **自环修正**：减去 $i=j$ 的非法情况（即 $f[2a_i]$ 处的修正）

#### **3. 新增元素贡献调整**
- **增益系数 $g(k)$**：对每个可能的和 $k$，计算其新增质因子的增益贡献  
  $$g(k) = \prod_{p \mid k} p^{\max(0, v_p(k) - \text{mx}[p])}$$

#### **4. 整合答案**
- **总公式**：  
  $$\text{Ans} = \text{原 LCM} \times \sum_{k} g(k) \times \text{卷积结果}[k] \times \frac{1}{2}$$

---

# **题解评分与亮点**

### **Mobius127 题解（⭐⭐⭐⭐⭐）**
- **亮点**：  
  - 代码结构清晰，预处理与卷积部分分离明确  
  - 引入 `h(x)` 和 `g(x)` 函数分离删除与新增贡献  
  - 使用位运算优化 NTT 的蝴蝶变换
- **关键代码段**：
  ```cpp
  // 预处理质数的最大/次大指数
  for(int i=1; i<=n; ++i){
      int x=a[i], t=LCM;
      while(x>1){
          int p=mn[x], s=1;
          while(mn[x]==p) x/=p, s*=p;
          if(cmx[p]<s) t=1ll*t*inv[s]%cp*max(1, cmx[p])%cp;
      }
      h[i]=t; // 计算衰减系数 d_i
  }
  ```

### **Alex_Wei 题解（⭐⭐⭐⭐⭐）**
- **亮点**：  
  - 使用 `pair` 结构同时记录指数和来源编号，简化次大值维护  
  - 对每个质数的贡献独立处理，逻辑模块化
- **关键代码段**：
  ```cpp
  // 维护最大/次大值
  pair<int, int> mx[MAXN], smx[MAXN];
  void update(int pos, pair<int, int> pr) {
      if(pr > mx[pos]) smx[pos] = mx[pos], mx[pos] = pr;
      else if(pr > smx[pos]) smx[pos] = pr;
  }
  ```

### **chroneZ 题解（⭐⭐⭐⭐）**
- **亮点**：  
  - 详细推导贡献系数公式，数学推导清晰  
  - 引入无符号长整型优化 NTT 中间计算
- **关键思路**：
  ```cpp
  // 贡献系数 d_i 的计算
  for(auto p : pr) {
      if(mx[p].first == nmx[p].first) continue;
      c[mx[p].second] = c[mx[p].second] * inv[p^(mx[p].first - nmx[p].first)] % MOD;
  }
  ```

---

# **可视化与算法演示设计**

### **像素风格动画设计**
1. **质因数分解阶段**：  
   - 每个数显示为像素方块，颜色代表其最大质因子（如红色=2，绿色=3）  
   - 质数指数以条形图高度展示，最大/次大值用不同亮度区分

2. **NTT 卷积阶段**：  
   - 多项式系数显示为网格，卷积过程用波浪线动态连接  
   - 音效：蝴蝶变换时播放 "beep" 音，卷积完成时播放上升音阶

3. **贡献整合阶段**：  
   - 每个和 $k$ 显示为发光方块，亮度与 $g(k)$ 值成正比  
   - 最终答案以复古数字滚动显示，伴随 8-bit 胜利音效

### **交互功能**
- **步进控制**：空格键单步执行，方向键调整速度  
- **AI 演示模式**：自动播放时，关键步骤暂停并弹出文字说明  
- **调试面板**：显示当前质数、最大指数、卷积中间结果

---

# **同类型题目推荐**
1. **P4245 【模板】任意模数多项式乘法**  
   - 练习 NTT/FFT 优化卷积的经典模板题

2. **P1495 曹冲养猪**  
   - 数论题，涉及中国剩余定理与 LCM 计算

3. **P4717 【模板】快速莫比乌斯变换**  
   - 集合卷积与子集和问题的高效解法

---

# **核心代码实现（Alex_Wei 版）**
```cpp
// 维护每个质数的最大/次大指数
for(int i=1; i<=n; ++i) {
    int x = r[i];
    for(auto [p, c] : factorize(x)) { // 质因数分解
        pair<int, int> v = {c, i};
        if(v > mx[p]) smx[p] = mx[p], mx[p] = v;
        else if(v > smx[p]) smx[p] = v;
    }
}

// 计算衰减系数 d_i
vector<int> d(n+1, 1);
for(auto p : primes) {
    if(mx[p].first == smx[p].first) continue;
    int delta = mx[p].first - smx[p].first;
    d[mx[p].second] = 1LL * d[mx[p].second] * inv(power(p, delta)) % MOD;
}

// NTT 卷积计算数对和
NTT(f, 1); // 正变换
for(int i=0; i<N; ++i) f[i] = 1LL * f[i] * f[i] % MOD;
NTT(f, -1); // 逆变换

// 计算最终答案
int ans = 0;
for(int k=1; k<MAXN; ++k) {
    int gain = 1;
    for(auto [p, c] : factorize(k)) // 计算增益系数 g(k)
        gain = 1LL * gain * power(p, max(0, c - mx[p].first)) % MOD;
    ans = (ans + 1LL * f[k] * gain) % MOD;
}
ans = 1LL * ans * inv(2) % MOD; // 修正无序对
```

---

# **总结与举一反三**
- **核心思维**：将 LCM 变化转化为质因子贡献的独立处理，利用卷积加速求和  
- **优化点**：预处理质因数分解结果可大幅提升效率（如筛法预处理最小质因子）  
- **扩展应用**：类似思路可用于 GCD 变换、集合覆盖等问题的高效计算

---
处理用时：90.14秒
# 题目信息

# 「PHOI-1」斗之魂

## 题目背景

**本题数据已加强。**

小 X 忙了一天，于是打起了一款叫斗之魂的游戏。

![](https://cdn.luogu.com.cn/upload/image_hosting/5ha5fx0q.png)

## 题目描述

小 X 要击败 $n$ 个 BOSS，他可以选择以下两种击败 BOSS 的方式：

1. 独自一人击败第 $i$ 个 BOSS 并获得 $k_{i,0}$ 块稀有金属，且保证 $k_{i,0}=k_{i,1}=k_{i,2}$。
2. 和小 Y 一起击败第 $i$ 个 BOSS ，小 X 理应获得 $k_{i,1}$ 块稀有金属，小 Y 理应获得 $k_{i,2}$ 块稀有金属，但是 BOSS 本身实力并没有因为人数的改变而改变，击败难度相对要简单一点，所以系统判定两人实际各获得 $k_{i,0}$ 块稀有金属，其中保证 $\dfrac{1}{k_{i,0}}=\dfrac{1}{k_{i,1}}+\dfrac{1}{k_{i,2}}$。

小 X 已经计划好用第 $b_i$ 种方式击败第 $i$ 个 BOSS，但是考虑到某些因素，小 X 有 $q$ 次询问，每次询问给定一个正整数 $m$，为小 X 击败完所有 BOSS 后获得的稀有金属总数，已知 $k_{i,0},k_{i,1},k_{i,2}$ 均为正整数，求每次询问后所有可能的 $k$ 的值的方案数，两种方案不同当且仅当至少存在一个 $k$ 的值不同，由于这个答案可能很大，你只需要输出它对 $998244353$ 取模后的结果。

## 说明/提示

**本题采用捆绑测试。**

| Subtask |      $n\le$       |      $m \le$      | $q \le$ |  时限  | 分值 |
| :-----: | :---------------: | :---------------: | :-----: | :----: | :--: |
|   $0$   |       $10$        |       $20$        |   $5$   |  $1s$  | $8$  |
|   $1$   |       $30$        |       $60$        |   $5$   |  $1s$  | $7$  |
|   $2$   |       $40$        |       $100$       | $10^3$  |  $1s$  | $5$  |
|   $3$   |       $150$       |       $500$       | $10^3$  |  $1s$  | $5$  |
|   $4$   |       $200$       |      $5000$       | $10^4$  |  $1s$  | $20$ |
|   $5$   |      $2000$       |  $5 \times 10^4$  | $10^5$  |  $1s$  | $25$ |
|   $6$   | $1.5 \times 10^5$ | $2.5 \times 10^5$ | $10^5$  | $1.8s$ | $30$ |

对于 $100\%$ 的数据，保证 $1 \le n \le 1.5 \times 10^5$，$1 \le m \le 2.5 \times 10^5$，$1 \le b_i \le 2$，$1 \le q \le 10^5$。

### 样例解释 #1：

- 当 $m=3$ 时，所有可能的 $k$ 的值的方案数为 $4$。

    第 $1$ 种：$k_{1,0}=1,k_{1,1}=k_{1,2}=2,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $2$ 种：$k_{1,0}=2,k_{1,1}=3,k_{1,2}=6,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $3$ 种：$k_{1,0}=2,k_{1,1}=k_{1,2}=4,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $4$ 种：$k_{1,0}=2,k_{1,1}=6,k_{1,2}=3,k_{2,0}=k_{2,1}=k_{2,2}=1$

- 当 $m=4$ 时，所有可能的 $k$ 的值的方案数为 $7$。

    第 $1$ 种：$k_{1,0}=1,k_{1,1}=k_{1,2}=2,k_{2,0}=k_{2,1}=k_{2,2}=3$

    第 $2$ 种：$k_{1,0}=2,k_{1,1}=3,k_{1,2}=6,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $3$ 种：$k_{1,0}=2,k_{1,1}=k_{1,2}=4,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $4$ 种：$k_{1,0}=2,k_{1,1}=6,k_{1,2}=3,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $5$ 种：$k_{1,0}=3,k_{1,1}=4,k_{1,2}=12,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $6$ 种：$k_{1,0}=3,k_{1,1}=6,k_{1,2}=6,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $7$ 种：$k_{1,0}=3,k_{1,1}=12,k_{1,2}=4,k_{2,0}=k_{2,1}=k_{2,2}=1$

## 样例 #1

### 输入

```
2 2
2 1
3
4
```

### 输出

```
4
7
```

## 样例 #2

### 输入

```
5 5
1 2 1 2 1
4
6
8
10
12
```

### 输出

```
0
9
119
630
2210```

# AI分析结果



---

## 算法分类  
**生成函数/多项式技巧与数论因数分解**

---

## 题解思路与核心难点  

### **问题拆解与关键推导**  
1. **方式1**：贡献固定为任意正整数，总次数为 `cnt1` 次，对应生成函数为 `(x + x² + x³ + ...)^cnt1`，化简为 `1/(1-x)^cnt1 - 1`（去除零次项）。  
2. **方式2**：每个选择对应生成函数 `G(x) = Σ g[j]x^j`，其中 `g[j]` 为 `j²` 的因数个数。总次数为 `cnt2` 次，生成函数为 `G(x)^cnt2`。  
3. **组合答案**：总生成函数为两者的卷积，答案即 `[x^m] (方式1生成函数 × 方式2生成函数)`。  

### **难点与解决方案**  
- **因数数目预处理**：利用线性筛法分解质因数，快速计算每个数平方的因数个数，时间复杂度 `O(m)`。  
- **多项式快速幂**：通过 NTT 实现多项式乘法，结合对数-指数转换优化幂次计算，复杂度 `O(m log m)`。  

---

## 题解评分  

### **yydfj 的题解（5星）**  
- **思路清晰**：详细推导生成函数构建与多项式操作步骤。  
- **代码优化**：完整实现 NTT、对数-指数转换，处理边界条件（如 `cnt1=0`）。  
- **可读性**：注释较少但逻辑清晰，适合有生成函数基础的读者。  

### **Fzrcy 的题解（4星）**  
- **代码简洁**：直接使用多项式快速幂，减少中间步骤。  
- **预处理优化**：独立实现筛法，逻辑紧凑。  
- **不足**：部分变量命名简略（如 `Tmp1`），调试信息较少。  

---

## 最优思路提炼  

### **关键技巧**  
1. **生成函数建模**：将 BOSS 选择转化为多项式项，卷积对应组合方案。  
2. **因数数目筛法**：线性筛预处理质因数，动态计算 `k²` 的因数个数。  
3. **多项式快速幂优化**：通过对数-指数转换将幂次计算复杂度降至 `O(m log m)`。  

---

## 同类题目推荐  
1. **洛谷 P4389**：付公主的背包（生成函数与多项式 EXP）。  
2. **洛谷 P4705**：玩游戏（多项式乘法与点值处理）。  
3. **洛谷 P4921**：情侣？给我烧了！（组合计数与生成函数）。  

---

## 可视化设计  

### **动画演示方案**  
1. **生成函数构建**：  
   - **方式1**：动态展示 `(x + x² + ...)` 的叠加过程，用像素方块表示系数增长。  
   - **方式2**：显示 `g[j]` 的计算（因数分解动画），每个 `j` 对应色块高度为因数数目。  
2. **多项式卷积**：  
   - **颜色标记**：当前卷积的 `j` 和 `k` 用高亮色块，结果系数渐变更新。  
   - **步进控制**：允许暂停观察中间结果，如 `cnt2` 次幂的中间多项式。  

### **复古像素风格**  
- **Canvas 绘制**：  
  - 每个系数用 8×8 像素块表示，颜色深浅对应值大小。  
  - 卷积时显示“像素冲击波”特效，模拟数据流动。  
- **音效设计**：  
  - **系数更新**：短促“哔”声。  
  - **卷积完成**：8-bit 胜利音效。  

---

## 核心代码片段  

### **因数预处理（筛法）**  
```cpp  
void sieve(int n) {  
    for (int i=2; i<=n; i++) {  
        if (!vis[i]) pr[++pc]=i, ci[i]=1, vis[i]=i;  
        for (int j=1; j<=pc && i*pr[j]<=n; j++) {  
            if (i%pr[j]) ci[i*pr[j]]=1, vis[i*pr[j]]=pr[j];  
            else { ci[i*pr[j]]=ci[i]+1; vis[i*pr[j]]=vis[i]*pr[j]; break; }  
        }  
    }  
    for (int i=2; i<=n; i++) {  
        int x=i, cur=1;  
        while (x>1) {  
            cur *= 2*ci[x] + 1; // 计算 k² 的因数个数  
            x /= vis[x];  
        }  
        f[i-1] = cur;  
    }  
}  
```  

### **生成函数卷积（NTT 实现）**  
```cpp  
void NTT(int *A, int type) {  
    for (int i=0; i<lim; i++) if (i<bl[i]) swap(A[i], A[bl[i]]);  
    for (int mid=1; mid<lim; mid<<=1) {  
        ll gn = ksm(type==1 ? gg : ggi, (mod-1)/(mid<<1));  
        for (int j=0; j<lim; j+=(mid<<1)) {  
            ll g = 1;  
            for (int k=0; k<mid; k++, g=g*gn%mod) {  
                int x=A[j+k], y=g*A[j+k+mid]%mod;  
                A[j+k] = (x+y)%mod;  
                A[j+k+mid] = (x-y+mod)%mod;  
            }  
        }  
    }  
    if (type == -1) {  
        ll inv = ksm(lim);  
        for (int i=0; i<lim; i++) A[i] = A[i]*inv%mod;  
    }  
}  
```  

---

**注**：完整代码参考原题解，此处仅展示核心逻辑。

---
处理用时：100.13秒
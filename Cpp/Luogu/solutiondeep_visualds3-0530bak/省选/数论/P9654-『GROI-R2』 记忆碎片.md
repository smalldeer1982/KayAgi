# 题目信息

# 『GROI-R2』 记忆碎片

## 题目描述

记忆的碎片散落在各个角落，而爱丽丝想把它们拼合在一起。

碎片的顺序是给定的，因为记忆显然不能反过来进行。但是，碎片各自的形状和内容是可以打磨和修正的——毕竟所有人的记忆都会歪曲和遗忘。

每个碎片上的记忆都可以用一个**非负整数**来表示。而相邻的两个碎片能够完整地拼合起来，当且仅当它们记忆的和是一个**完全平方数**。

现在，爱丽丝可以打磨若干块碎片，使得每一对相邻的碎片都能够完整地拼合起来。对于每一次打磨，爱丽丝可以选择一块碎片，将这块碎片上的记忆修改为任意一个**非负整数**。爱丽丝想知道，她至少要打磨多少块碎片，才能实现她的目标。同时，她还希望你给出打磨之后，每块碎片上留有的记忆是多少。

**形式化题面**

给定一个**非负整数**序列 $\{a_n\}$，我们定义一次操作是任意选择一个 $i\in [1,n]$ 并将 $a_i$ 改为任意一个**非负整数** $x$。

问至少进行几次操作才可以满足 $\forall i\in [1,n-1]$ 有 $a_i+a_{i+1}$ 为**完全平方数**，并给出修改方案。

## 说明/提示

**样例解释**

对于第一组样例，不难证明爱丽丝至少要打磨一块碎片才能使所有的记忆满足条件。

请一定注意记忆碎片的顺序是不能改变的。

**评分规则**

如果你对于某一测试点输出的最少打磨次数是正确的，你将获得该测试点 $30\%$ 的分数。

如果你在最少打磨次数正确的基础上给出了正确的构造，你将获得该测试点 $100\%$ 的分数。

如果你只会求解最少打磨次数，那也请你在第二行输出以空格隔开的 $n$ 个在 $[0,10^{18}]$ 范围内的整数，否则可能被判为 $0$ 分。

请注意，你在每个 subtask 中得到的 $30\%$ 分数会被下取整计算。

**数据范围**

**本题采用捆绑测试**。

| $\text{Subtask}$ | $n\le$ | $a_i\le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $2$ | $10^8$ |  | $5$ |
| $2$ | $3$ | $10^8$ |  | $20$ |
| $3$ | $4$ | $10^8$ |  | $15$ |
| $4$ | $10^3$ | $10^8$ |  | $15$ |
| $5$ | $10^6$ | $10^4$ |  | $10$ |
| $6$ | $10^6$ | $10^8$ | $\text{A}$ | $10$ |
| $7$ | $10^6$ | $10^8$ |  | $25$ |

特殊性质 $\text{A}$：$\forall 1\le i,j\le n$ 满足 $a_i=a_j$。

对于 $100\%$ 的数据满足 $1\le n\le 10^6$，$0\le a_i\le 10^8$。

## 样例 #1

### 输入

```
4
1 3 5 8```

### 输出

```
1
1 3 1 8```

## 样例 #2

### 输入

```
3
3 4 5```

### 输出

```
1
0 4 5```

# AI分析结果



---

**唯一算法分类**  
动态规划

---

**题解思路、算法要点与解决难点**  
- **核心思路**：通过动态规划（DP）寻找最少修改次数，结合构造性策略填充中间值确保可行解。  
- **关键观察**：若两个保留点间隔≥2个修改点，必存在合法构造。据此简化状态转移，优化至线性复杂度。  
- **实现难点**：如何高效判断中间段是否可填充，并逆向构造具体解。利用完全平方数的模性质（如余数0/1）及数学构造技巧（如设定极大值）确保填充可行。  

---

**题解评分 (≥4星)**  
1. **迟暮天复明（★★★★☆）**  
   - **亮点**：详细证明构造可行性，状态转移清晰，代码结构完整。  
   - **改进点**：代码实现略复杂，构造部分可读性稍弱。  

2. **Graphcity（★★★★★）**  
   - **亮点**：利用间隔≥2必可解的观察优化DP转移，代码简洁高效，构造逻辑明确。  
   - **优化**：预处理平方数表加速查询，逆向推导构造方案。  

---

**最优思路或技巧提炼**  
1. **动态规划状态设计**：  
   - 定义 `f[i]` 表示前 `i` 个元素中保留 `i` 时的最大保留数，转移时枚举上一个保留点 `j`。  
   - 当 `i-j≥3` 时，直接取 `max(f[j]) +1`，利用间隔≥2必可解的结论。  

2. **构造填充策略**：  
   - 设定极大值（如 `inf=1e4`）生成 `a_i = inf² - a_{i-1}`，确保相邻和为完全平方数。  
   - 对间隔≥2的情况，通过数学构造（如平方差分解）快速生成合法值。  

---

**同类型题或类似算法套路**  
- **最少修改问题**：如「LeetCode 926. 将字符串翻转到单调递增」，通过DP寻找最小修改次数。  
- **构造性动态规划**：如「Codeforces 1352G. Special Permutation」，需结合构造策略设计状态转移。  

---

**推荐相似题目**  
1. [P5665 划分](https://www.luogu.com.cn/problem/P5665)  
2. [CF1352G. Special Permutation](https://codeforces.com/problemset/problem/1352/G)  
3. [LeetCode 926. Flip String to Monotone Increasing](https://leetcode.com/problems/flip-string-to-monotone-increasing/)  

---

**代码核心实现（Graphcity 题解）**  
```cpp
// 状态转移与构造逻辑  
For(i,3,n) {  
    j = max(j, f[i-3]); // 间隔≥3时取历史最大值  
    f[i] = j + 1;  
    // 检查相邻保留或间隔1的情况  
    if (相邻合法) f[i] = max(f[i], f[i-1]+1);  
    if (间隔1可构造) f[i] = max(f[i], f[i-2]+1);  
}  
// 逆向构造解  
Rof(i,p,1) {  
    if 间隔≥2: 填充极大值或数学构造解；  
    else if 间隔1: 计算中间值确保合法；  
}  
```

---

**可视化与算法演示**  
1. **动态规划状态转移动画**：  
   - **Canvas 网格**：每个格子代表序列位置，绿色表示保留，红色表示修改。  
   - **高亮转移路径**：当前处理位置 `i` 时，显示从 `j` 到 `i` 的箭头，颜色区分间隔长度（如蓝箭为间隔≥3，黄箭为间隔1）。  
   - **音效触发**：每次状态更新播放短促音效，合法转移成功时播放上扬音调。  

2. **构造填充演示**：  
   - **像素方块填充**：修改位置显示为闪烁方块，逐步填入计算后的数值。  
   - **验证相邻和**：连线相邻方块，显示其和及是否平方数，正确时亮起绿色边框。  

3. **复古游戏化设计**：  
   - **8位音效**：使用芯片音乐库（ChipTone）生成转移、成功、失败音效。  
   - **积分与连击**：每正确构造一段获得积分，连续无错构造触发连击奖励。  

---

**个人心得摘录**  
- **Graphcity**：预处理平方数表大幅加速查询，逆向推导构造时需注意边界条件，初始代码因未处理 `n=2` 特殊案例WA两次。  
- **迟暮天复明**：数学构造中 `d mod 4` 的分类讨论是关键，调试时通过暴力枚举验证了所有可能的余数情况。  

---

**可视化实现片段（伪代码）**  
```javascript
// Canvas 绘制动态规划状态  
function drawDPGrid() {  
  ctx.fillStyle = '#8BBAFF'; // 蓝色背景  
  ctx.fillRect(0, 0, width, height);  
  for (let i = 0; i < n; i++) {  
    // 绿色保留，红色修改  
    ctx.fillStyle = (isKept[i]) ? '#77DD77' : '#FF6961';  
    ctx.fillRect(i * cellSize, 0, cellSize, cellSize);  
    // 绘制转移箭头  
    if (prev[i] !== -1) {  
      drawArrow(prev[i], i, arrowColor);  
    }  
  }  
}  
// 触发音效  
function playSound(effect) {  
  const audio = new Audio(`sfx-${effect}.wav`);  
  audio.play();  
}  
```

---
处理用时：70.59秒
# 题目信息

# [NOI2008] 假面舞会

## 题目描述

一年一度的假面舞会又开始了，栋栋也兴致勃勃的参加了今年的舞会。

今年的面具都是主办方特别定制的。每个参加舞会的人都可以在入场时选择一个自己喜欢的面具。每个面具都有一个编号，主办方会把此编号告诉拿该面具的人。

为了使舞会更有神秘感，主办方把面具分为 $k$（$k\geq 3$）类，并使用特殊的技术将每个面具的编号标在了面具上，只有戴第 $i$ 类面具的人才能看到戴第 $i+1$  类面具的人的编号，戴第 $k$ 类面具的人能看到戴第 $1$ 类面具的人的编号。

参加舞会的人并不知道有多少类面具，但是栋栋对此却特别好奇，他想自己算出有多少类面具，于是他开始在人群中收集信息。

栋栋收集的信息都是戴第几号面具的人看到了第几号面具的编号。如戴第 $2$ 号面具的人看到了第 $5$ 号面具的编号。栋栋自己也会看到一些编号，他也会根据自己的面具编号把信息补充进去。

由于并不是每个人都能记住自己所看到的全部编号，因此，栋栋收集的信息不能保证其完整性。现在请你计算，按照栋栋目前得到的信息，至多和至少有多少类面具。由于主办方已经声明了 $k\geq 3$，所以你必须将这条信息也考虑进去。


## 说明/提示

- 对于 $50\%$ 的数据，满足 $n \leq 300$，$m \leq 10^3$；
- 对于 $100\%$ 的数据，满足 $n \leq 10^5$，$m \leq 10^6$。


## 样例 #1

### 输入

```
6 5
1 2
2 3
3 4
4 1
3 5```

### 输出

```
4 4
```

## 样例 #2

### 输入

```
3 3
1 2
2 1
2 3```

### 输出

```
-1 -1
```

# AI分析结果



**唯一算法分类：图论（环检测与公约数处理）**

---

### 题解思路、算法要点与解决难点

1. **核心思路**  
   - **图的构造**：将每条边 `u→v` 视为正权边（权值1），同时反向建立边 `v→u` 权值-1，确保DFS能遍历所有可能的环和链。
   - **环检测**：DFS遍历时，若遇到已访问节点，计算当前路径与之前记录的节点距离差，该差值即为环长。
   - **GCD处理**：所有环长的最大公约数（GCD）为可能的k值，若存在多个环，k必须为所有环长的公约数。
   - **链处理**：若无环，k的最大值为各连通块最长链之和，最小值3。

2. **解决难点**  
   - **交叉链与公共环**：通过反向边权处理，将交叉链转换为环的差，统一用GCD处理。
   - **高效计算环长**：DFS中动态维护节点距离，避免重复遍历同一路径。

---

### 最优思路或技巧提炼

1. **双向建边权值法**  
   正反边权分别为1和-1，确保DFS能遍历所有可能的环结构，并正确计算环长差。

2. **环长差直接求GCD**  
   在DFS中，当遇到已访问节点时，计算 `abs(当前距离 - 历史距离)` 并更新全局GCD，无需显式记录所有环。

3. **最长链快速计算**  
   对每个连通块记录DFS中的最大/最小距离，差值+1即为链长。

---

### 题解评分（≥4星）

1. **StudyingFather（5星）**  
   - 思路清晰，代码简洁高效，正确处理环与链的边界条件。
   - 关键代码：动态维护环长的GCD，链长计算通过差值实现。

2. **water_tomato（4星）**  
   - 详细证明反向边权的正确性，增强理解。
   - 关键亮点：通过数学推导验证环长差处理的正确性。

3. **sodak（4星）**  
   - 代码结构清晰，分离环检测与链处理步骤。
   - 关键代码：使用 `flag` 数组标记边，避免重复处理。

---

### 代码核心片段

```cpp
// 核心DFS处理环长
void dfs(int u, int d) {
    if (dis[u]) { // 已访问过，计算环长差
        ans = gcd(ans, abs(d - dis[u]));
        return;
    }
    dis[u] = d;
    vis[u] = 1;
    maxv = max(maxv, d);
    minv = min(minv, d);
    for (auto edge : e[u]) {
        dfs(edge.v, d + edge.w); // 递归遍历邻接节点
    }
}

// 主逻辑处理
for (int i = 1; i <= n; i++) {
    if (!vis[i]) {
        maxv = -INF, minv = INF;
        dfs(i, 1);
        res += maxv - minv + 1; // 链长累加
    }
}
```

---

### 可视化设计思路

1. **动画演示**  
   - **节点遍历**：以像素方块表示节点，当前访问节点高亮为红色，已访问节点为绿色。
   - **边权显示**：正边用蓝色箭头（权1），反边用黄色箭头（权-1）。
   - **环检测**：当DFS回溯到已访问节点时，显示环长差并更新GCD数值。

2. **复古像素风格**  
   - 使用16色调色板，节点为8x8像素块，边用不同颜色箭头表示。
   - 音效：发现环时播放“叮”声，完成遍历播放胜利音效。

3. **交互控制**  
   - 步进执行：用户可控制DFS每一步的推进，观察距离数组变化。
   - 自动模式：AI自动运行，展示环检测和链长计算过程。

---

### 同类型题目推荐

1. **P3385 判负环**  
   - 检测图中是否存在负权环，类似环长处理。

2. **P2661 信息传递**  
   - 寻找最小环，与本题环长计算相关。

3. **P2863 The Cow Prom**  
   - 强连通分量计数，需处理环结构。

---

### 个人心得摘录

- **StudyingFather**：强调反向边权处理的重要性，避免漏环。
- **water_tomato**：通过数学推导验证反向边权的正确性，加深理解。
- **Xing_ke**：调试中发现未处理反向边关联的标记问题，最终通过调整 `cnt` 初值解决。

---

### 结论

通过双向建边和DFS动态计算环长差，结合GCD处理，有效解决面具分类问题。代码需注意反向边的标记和环长差计算，确保不遗漏任何可能的结构。可视化设计可增强对环检测和链处理过程的理解。

---
处理用时：58.82秒
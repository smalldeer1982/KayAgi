# 题目信息

# [CQOI2015] 选数

## 题目描述

我们知道，从区间 $[L,H]$（$L$ 和 $H$ 为整数）中选取 $N$ 个整数，总共有 $(H-L+1)^N$ 种方案。小 z 很好奇这样选出的数的最大公约数的规律，他决定对每种方案选出的 $N$ 个整数都求一次最大公约数，以便进一步研究。然而他很快发现工作量太大了，于是向你寻求帮助。你的任务很简单，小 z 会告诉你一个整数 $K$，你需要回答他最大公约数刚好为 $K$ 的选取方案有多少个。

由于方案数较大，你只需要输出其除以 $10^9+7$ 的余数即可。

## 说明/提示

#### 样例 1 解释

所有可能的选择方案：$(2, 2), (2, 3), (2, 4), (3, 2), (3, 3), (3, 4), (4, 2), (4, 3), (4, 4)$。

其中最大公约数等于 $2$ 的只有 $3$ 组：$(2, 2), (2, 4), (4, 2)$。
#### 数据规模与约定
对于 $100\%$ 的数据，$1\le N,K\le 10^9$，$1\le L\le H\le 10^9$，$H-L\le 10^5$。

## 样例 #1

### 输入

```
2 2 2 4```

### 输出

```
3```

# AI分析结果



## **算法分类**  
**数论-容斥原理与莫比乌斯反演**

---

## **题解思路、算法要点与解决难点**  
### **核心思路**  
1. **问题转化**：将所有数除以 \( K \)，转化为求区间 \([L', H']\) 内选数，使得最大公约数为 1 的方案数。  
2. **容斥/反演**：通过容斥原理或莫比乌斯反演，计算每个可能的公约数 \( d \) 的贡献，最终得到恰好为 1 的结果。  
3. **优化关键**：利用 \( H-L \leq 10^5 \) 的条件，避免高复杂度算法（如杜教筛），转而采用线性筛预处理 μ 函数。

### **解决难点**  
1. **避免重复计数**：容斥时需要从大到小处理每个 \( d \)，减去其倍数的贡献。  
2. **高效计算 μ 函数**：对 \( d \leq 10^5 \) 预处理 μ 值，避免实时计算。  
3. **特判全选相同数**：当 \( K \) 在 \([L, H]\) 内时，单独处理全选 \( K \) 的特殊情况。

---

## **题解评分 (≥4星)**  
1. **xyz32768（赞74）**  
   - **思路**：预处理每个 \( d \) 的贡献，倒序容斥。  
   - **亮点**：代码简洁，利用 \( H-L \leq 10^5 \) 优化，时间复杂度 \( O((H-L)\log(H-L)) \)。  
   - **评分**：★★★★☆  

2. **litble（赞21）**  
   - **思路**：利用 \( H-L \leq 10^5 \) 条件，直接枚举公约数 \( d \)，结合容斥。  
   - **亮点**：时间复杂度 \( O(H-L) \)，无需杜教筛，代码高效。  
   - **评分**：★★★★★  

3. **DrLin（赞1）**  
   - **思路**：通过预处理 μ 函数，直接计算反演公式。  
   - **亮点**：代码简洁，利用线性筛预处理，适合小范围数据。  
   - **评分**：★★★★☆  

---

## **最优思路或技巧提炼**  
1. **核心公式**：  
   \[
   \text{答案} = \sum_{d=1}^{H-L} \mu(d) \cdot \left( \lfloor H/d \rfloor - \lfloor (L-1)/d \rfloor \right)^n
   \]
2. **预处理 μ 函数**：线性筛预处理 μ 值，避免重复计算。  
3. **倒序容斥**：从大到小枚举 \( d \)，依次减去其倍数的贡献。  
4. **特判全选相同数**：当 \( L=1 \) 时，单独加 1 处理全选 1 的情况。

---

## **同类型题或算法套路**  
1. **区间 GCD 计数**：通过转化为互质问题，结合容斥/反演。  
2. **数论分块优化**：处理大范围整除求和问题。  
3. **莫比乌斯反演模板**：如求区间内互质数对数量。

---

## **推荐题目**  
1. **P2522 [HAOI2011]Problem c**  
   - 区间计数与数论分块结合。  
2. **P3455 [POI2007]ZAP-Queries**  
   - 莫比乌斯反演模板题。  
3. **P5221 Product**  
   - 利用 μ 函数性质求积。  

---

## **个人心得摘录**  
- **调试教训**：注意 \( L=1 \) 时的特判，容易漏掉全选 1 的情况。  
- **优化技巧**：当 \( d > H-L \) 时，公约数不可能超过 \( H-L \)，直接剪枝。  

---

## **可视化与算法演示**  
### **动画设计**  
1. **像素风格界面**：  
   - **颜色方案**：16 色调色板，μ 值为正（绿色）、负（红色）、零（灰色）。  
   - **网格显示**：区间 \([L, H]\) 化为像素块，选数过程用闪烁效果表示。  

2. **关键步骤演示**：  
   - **步骤1**：显示原区间除以 \( K \) 后的新区间 \([L', H']\)。  
   - **步骤2**：枚举 \( d \)，高亮当前 \( d \) 的倍数，计算贡献。  
   - **步骤3**：倒序容斥时，用红色箭头标记当前 \( d \) 减去其倍数的贡献。  

3. **音效设计**：  
   - **选中 d**：8-bit 音效（类似 FC 游戏金币声）。  
   - **完成计算**：胜利音效（上扬音调）。  

### **交互控制**  
- **速度调节**：滑动条控制动画速度（1x~5x）。  
- **单步执行**：按空格键逐步执行每个 \( d \) 的计算。  

---

## **核心代码实现**  
```cpp
// 预处理 μ 函数
void sieve() {
    mu[1] = 1;
    for (int i = 2; i <= maxn; i++) {
        if (!vis[i]) prime[++cnt] = i, mu[i] = -1;
        for (int j = 1; j <= cnt && i * prime[j] <= maxn; j++) {
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0) break;
            mu[i * prime[j]] = -mu[i];
        }
    }
}

// 容斥计算答案
int main() {
    int L = (L_orig - 1) / K + 1, H = H_orig / K;
    for (int d = H - L; d >= 1; d--) {
        int cnt = (H / d) - ((L - 1) / d);
        f[d] = (pow_mod(cnt, n) - cnt + MOD) % MOD;
        for (int j = 2 * d; j <= H - L; j += d) {
            f[d] = (f[d] - f[j] + MOD) % MOD;
        }
    }
    if (L == 1) f[1] = (f[1] + 1) % MOD; // 特判全选1
    cout << f[1] << endl;
}
```

---

**总结**：本题解通过巧妙的问题转化和容斥优化，在 \( H-L \leq 10^5 \) 的限制下实现了高效计算。可视化设计以像素风格增强学习趣味性，适合教学演示。

---
处理用时：73.87秒
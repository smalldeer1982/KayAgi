# 题目信息

# 干杯！再会！

## 题目背景

>酒酣之时，等待你的会是……

黛米和哥哥在一个小城镇里经营着一家小酒吧。靠着哥哥调制的多夫林酒，这间小酒吧的生意也逐渐兴隆起来。

## 题目描述

这家小店有 $n$ 位常驻顾客。第 $i$ 位顾客来到这家小店时都会带上一瓶美味度为 $a_i$ 的底酒和一份美味度为 $b_i$ 的调料。这些顾客会让黛米帮忙调酒。对于一瓶美味度为 $x$ 的底酒和一份美味度为 $y$ 的调料，如果黛米将它们调制在一起，就能得到一瓶美味度为 $\gcd(x,y)$ 的美酒（我们认为美味度数值越低代表酒越好喝）。

这一天，这些顾客同时来到了这家小店想要黛米帮忙调酒。然而黛米在前一天喝了太多的酒导致意识错乱了，这导致她将调料加入到了错误的底酒里。不过好在这些顾客并不在意，他们只想知道对于**所有**黛米加入调料的情况下，他们将会拿到的酒的美味度的**方差**的**和**在对 $10^9+7$ 取模意义下是多少。如果你能回答出他们的问题，那么他们会很愿意帮你支付酒钱。

------------
#### 简要题意：
给定 $n$ 以及两个长度为 $n$ 的序列 $a,b$。对于一个 $1$ 到 $n$ 的排列 $p$，记 $c_i=\gcd(a_i,b_{p_i})$，$\sigma(c)$ 表示序列 $c$ 中所有元素的**方差**（方差公式详见提示），求：

$$\sum\limits_{p}\sigma(c)$$

对 $10^9+7$ 取模。

## 说明/提示

#### 样例一解释
+ $p=\{1,2,3\},c=\{1,2,3\},\sigma(c)=\dfrac{2}{3}$。
+ $p=\{1,3,2\},c=\{1,1,1\},\sigma(c)=0$。
+ $p=\{2,1,3\},c=\{1,1,3\},\sigma(c)=\dfrac{8}{9}$。
+ $p=\{2,3,1\},c=\{1,1,1\},\sigma(c)=0$。
+ $p=\{3,1,2\},c=\{1,1,1\},\sigma(c)=0$。
+ $p=\{3,2,1\},c=\{1,2,1\},\sigma(c)=\dfrac{2}{9}$。

总和为 $\dfrac{16}{9}$，对 $10^9+7$ 取模意义下为 $777777785$。

------------
#### 数据范围

**本题采用捆绑测试**。

+ Subtask 1 ( $5\%$ )：$n\leq8$。
+ Subtask 2 ( $15\%$ )：$n,a_i,b_i\leq100$。
+ Subtask 3 ( $25\%$ )：$a_i,b_i\leq10^3$。
+ Subtask 4 ( $25\%$ )：$n,a_i,b_i\leq 10^5$。
+ Subtask 5 ( $30\%$ )：无特殊限制。

对于所有数据，$2\leq n\leq 10^6,1\leq a_i,b_i\leq 10^6$。

------------
对于一个长度为 $n$ 的序列 $x$，方差 $\sigma(x)=\sum\limits_{i=1}^n\dfrac{1}{n}(x_i-\bar{x})^2$，其中 $\bar{x}$ 表示所有元素的平均数（$\bar{x}=\dfrac{1}{n}\sum\limits_{i=1}^nx_i$）。

## 样例 #1

### 输入

```
3
1 2 3
1 2 3
```

### 输出

```
777777785```

## 样例 #2

### 输入

```
12
1 3 4 2 3 5 7 3 5 6 8 9
4 3 10 2 5 6 4 8 2 9 12 5
```

### 输出

```
931089600```

# AI分析结果



---

### 算法分类
**数论 + 组合数学**

---

### 题解核心思路与难点对比

#### 核心思路
所有题解均基于方差拆解公式：
$$ \sigma = \frac{1}{n}\sum x_i^2 - \frac{1}{n^2}(\sum x_i)^2 $$
需计算两个关键量：
1. $\sum x_i^2$ 的总和（平方和）
2. $(\sum x_i)^2$ 的总和（和的平方）

#### 难点对比
| 题解作者 | 解决难点 | 优化方法 | 时间复杂度 |
|---------|---------|---------|-----------|
| wolfind | 处理和的平方项 | 容斥 + 欧拉反演 | $O(n \log n)$ |
| Reunite | 高维前缀和优化 | 狄利克雷卷积 + 线性筛 | $O(n \log \log n)$ |
| CloudDreamLake | 值域预处理优化 | 倍数卷积 + 积性函数快速筛 | $O(n \log \log n)$ |

---

### 题解评分 (≥4星)

1. **wolfind (4.5星)**  
   - 亮点：详细推导容斥过程，代码结构清晰，覆盖从暴力到优化的完整路径  
   - 优化点：利用欧拉函数 $\varphi$ 反演优化平方项计算

2. **Reunite (5星)**  
   - 亮点：通过狄利克雷前缀和将预处理复杂度优化至 $O(n \log \log n)$，数学推导严谨  
   - 代码技巧：线性筛预处理积性函数 $\tau$ 和 $\varphi$

3. **CloudDreamLake (4.5星)**  
   - 亮点：结合高维前缀和与线性筛，实现极优复杂度  
   - 可视化友好：代码模块化，便于分步演示

---

### 最优思路与技巧提炼

1. **数论反演**  
   - 用 $\gcd(a,b)=\sum_{d|a,d|b}\varphi(d)$ 将复杂计算转化为积性函数求和
   - 关键代码片段：
     ```cpp
     // 欧拉反演求 gcd 和
     for(int d=1; d<=m; d++) 
         ans += sa[d] * sb[d] * phi[d];
     ```

2. **高维前缀和优化**  
   - 预处理所有数的因子贡献，避免重复计算
   - 代码实现：
     ```cpp
     // 狄利克雷前缀和预处理
     for(int pr: primes) 
         for(int j=W/pr; j>=1; j--) 
             sa[j] += sa[j*pr];
     ```

3. **积性函数快速筛**  
   - 线性筛预处理 $\tau$（平方分解函数）和 $\varphi$（欧拉函数）
   - 代码片段：
     ```cpp
     // 线性筛积性函数 τ 和 φ
     if(!npr[i]) {
         pr.push_back(i);
         phi[i] = i-1;
         tau[i] = (ModInt)i*i - 1;
     }
     ```

---

### 相似题目推荐

1. **P1891 [SDOI2017] 数字表格**  
   - 关键词：gcd 积性函数，莫比乌斯反演

2. **P2303 [SDOI2012] Longge的问题**  
   - 关键词：数论分块，欧拉函数求和

3. **P4917 乘积方差**  
   - 关键词：方差计算，组合数学优化

---

### 可视化算法演示设计

#### 动画方案
1. **像素风高维前缀和演示**  
   - **颜色标记**：黄色高亮当前处理的质数，蓝色显示更新后的前缀和值  
   - **步进控制**：按空格键单步执行质数处理，显示每个质数的倍数更新过程  
   - **音效**：每次更新播放8-bit“滴答”声，完成时播放上升音阶

2. **gcd分布热力图**  
   - **Canvas绘制**：将不同 $\gcd(a_i,b_j)$ 值映射为不同颜色深度  
   - **动态更新**：滑动条控制当前处理的 $d$ 值，显示其倍数分布

#### 复古游戏化设计
- **积分系统**：正确完成每个质数的前缀和更新获得10分，连续正确触发连击  
- **关卡设计**：第1关处理质数2，第2关处理质数3，依次解锁更高复杂度操作

---

### 核心代码片段（Reunite优化版）

```cpp
// 高维前缀和预处理
void Dirichlet(vector<int>& primes) {
    for(int pr: primes) 
        for(int j = W/pr; j >=1; j--)
            sa[j] += sa[j*pr];
}

// 线性筛预处理积性函数
void sieve() {
    phi[1] = tau[1] = 1;
    for(int i=2; i<=m; i++) {
        if(!npr[i]) {
            primes.push_back(i);
            phi[i] = i-1;
            tau[i] = (ModInt)i*i - 1;
        }
        for(auto p: primes) {
            if(i*p > m) break;
            npr[i*p] = true;
            if(i % p == 0) {
                phi[i*p] = phi[i] * p;
                tau[i*p] = tau[i] * p*p;
                break;
            }
            // ... 其他处理
        }
    }
}
```

---

### 总结
本题通过方差拆解将问题转化为数论函数计算，结合高维前缀和与积性函数筛法实现高效求解。不同题解在优化路径上各有侧重，Reunite的狄利克雷卷积+线性筛方案在时间复杂度和代码可读性上达到最优平衡。

---
处理用时：65.63秒
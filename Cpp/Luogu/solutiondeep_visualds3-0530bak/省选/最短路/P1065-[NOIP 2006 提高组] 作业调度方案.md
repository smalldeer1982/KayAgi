# 题目信息

# [NOIP 2006 提高组] 作业调度方案

## 题目描述

我们现在要利用 $m$ 台机器加工 $n$ 个工件，每个工件都有 $m$ 道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。

每个工件的每个工序称为一个操作，我们用记号 `j-k` 表示一个操作，其中 $j$ 为 $1$ 到 $n$ 中的某个数字，为工件号；$k$ 为 $1$ 到 $m$ 中的某个数字，为工序号，例如 `2-4` 表示第 $2$ 个工件第 $4$ 道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。

例如，当 $n=3,m=2$ 时，`1-1,1-2,2-1,3-1,3-2,2-2` 就是一个给定的安排顺序，即先安排第 $1$ 个工件的第 $1$ 个工序，再安排第 $1$ 个工件的第 $2$ 个工序，然后再安排第 $2$ 个工件的第 $1$ 个工序，等等。

一方面，每个操作的安排都要满足以下的两个约束条件。

1. 对同一个工件，每道工序必须在它前面的工序完成后才能开始；

2. 同一时刻每一台机器至多只能加工一个工件。

另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。

由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为 `1 1 2 3 3 2`。

还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。

例如，取 $n=3,m=2$，已知数据如下（机器号/加工时间）：


工件号 |工序 1 | 工序 2
-|-|-
$1$  |  $1/3$  |  $2/2$
$2$  |  $1/2$  |  $2/5$
$3$  |  $2/2$  |  $1/4$

则对于安排顺序 `1 1 2 3 3 2`，下图中的两个实施方案都是正确的。但所需要的总时间分别是 $10$ 与 $12$。

方案 1，用时 $10$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | `3-1` | `3-1` |  无   | `1-2` | `1-2` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

方案 2，用时 $12$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12  |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` |   无   |  无   | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | 无 | 无 |  无   | `1-2` | `1-2` | `3-1` | `3-1` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件 $(1.)(2.)$ 的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件 $(1.)(2.)$ 的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。

显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。


## 说明/提示

NOIP 2006 提高组 第三题


## 样例 #1

### 输入

```
2 3
1 1 2 3 3 2
1 2 
1 2 
2 1
3 2 
2 5 
2 4
```

### 输出

```
10```

# AI分析结果



---

## 唯一算法分类  
**模拟**

---

## 综合分析与结论  
### 核心思路与难点  
题目要求按给定顺序安排工序，同时满足两个约束：  
1. 同一工件的工序必须顺序执行  
2. 同一机器不能同时处理多个工序  

**核心算法流程**：  
1. **维护每个工件的当前工序进度**：通过数组 `step[]` 记录每个工件已完成的工序数  
2. **记录每个工件的最后完成时间**：通过数组 `last_time[]` 确保新工序必须在上一个工序结束后开始  
3. **机器时间轴管理**：用二维数组 `machine_time[][]` 标记每个机器的每个时间点是否被占用  
4. **贪心插入**：从工件的最后完成时间开始，扫描机器时间轴，找到第一个可插入的连续时间段  

**难点解决**：  
- **时间轴高效查询**：通过逐时间点扫描，利用计数器统计连续空闲段  
- **冲突约束处理**：保证同一工件工序顺序性（`last_time` 约束）和机器独占性（`machine_time` 标记）  

### 可视化设计思路  
1. **动画效果**：  
   - **时间轴网格**：以机器为行、时间为列，用不同颜色块表示不同工件的工序  
   - **动态插入**：高亮当前工序的机器行，展示扫描空闲段的过程（红色光标移动，绿色标记空闲段）  
2. **复古像素风格**：  
   - **8-bit 色块**：每个工件对应独特颜色，时间轴用 16x16 像素块表示  
   - **音效设计**：插入成功时播放「哔」声，空闲段扫描时播放「滴答」声  
3. **交互控制**：  
   - **步进/暂停**：允许用户逐步观察每个工序的插入过程  
   - **AI 自动模式**：自动以最快速度完成所有工序安排  

---

## 题解清单（≥4星）  
### 1. 作者：ShawnZhou（⭐⭐⭐⭐⭐）  
- **亮点**：  
  - 使用 `check_in_line` 函数分离逻辑，提高可读性  
  - 详细注释与变量命名规范（如 `cnt_now_work_step`）  
  - 提供完整样例解析与调试思路  

### 2. 作者：brealid（⭐⭐⭐⭐）  
- **亮点**：  
  - 直接暴力扫描时间轴，代码简洁  
  - 通过 `las_time` 快速定位起点，减少无效扫描  
  - 提供额外测试数据辅助调试  

### 3. 作者：qhr2023（⭐⭐⭐⭐）  
- **亮点**：  
  - 极简代码（仅 24 行），核心逻辑集中  
  - 使用 `s` 计数器动态统计连续空闲段，避免冗余判断  

---

## 最优思路与技巧提炼  
### 关键数据结构  
- **machine_time[machine][time]**：标记机器时间点占用状态  
- **last_time[workpiece]**：记录工件最后完成时间  

### 核心代码片段  
```cpp
// 处理每个工序
for (int i = 1; i <= total_steps; i++) {
    int wp = sequence[i];       // 当前工件
    int step = ++wp_step[wp];   // 当前工序
    int machine = wp_info[wp][step].machine;
    int duration = wp_info[wp][step].duration;

    int start = last_time[wp] + 1;  // 必须在上次结束后开始
    int cnt = 0;
    for (int t = start; ; t++) {
        if (machine_time[machine][t] == 0) cnt++;
        else cnt = 0;

        if (cnt == duration) {  // 找到足够长连续段
            for (int j = t - duration + 1; j <= t; j++)
                machine_time[machine][j] = 1;
            last_time[wp] = t;
            ans = max(ans, t);
            break;
        }
    }
}
```

---

## 同类型题与算法套路  
### 类似题目  
1. **P1541 机器翻译**：管理有限缓存空间，模拟 FIFO 替换策略  
2. **P1056 排座椅**：贪心选择最优分割线，类似资源调度  
3. **P1160 队列安排**：链表操作模拟插入与删除  

### 通用解法  
- **时间轴模拟**：将资源（如机器、缓存）抽象为时间轴，按规则插入任务  
- **贪心插入策略**：优先选择最早可插入位置，保证局部最优  

---

## 推荐题目  
1. **P1541** - 模拟缓存管理  
2. **P1056** - 贪心选择与资源分配  
3. **P1160** - 链表操作与顺序调整  

---

## 个人心得摘录  
- **调试经验**：  
  - *“画图研究样例比读代码更有效”（ShawnZhou）*  
  - *“变量名混淆是调试地狱”（SimonSu）*  
- **顿悟点**：  
  - *“空闲段扫描只需重置计数器，无需回溯时间轴”（qhr2023）*  

---

## 可视化与算法演示  
### 动画设计  
1. **时间轴网格**：  
   - 横向为时间，纵向为机器  
   - 每个单元格表示一个时间点，颜色表示占用工件  
2. **动态插入流程**：  
   - **步骤 1**：高亮当前工件和工序  
   - **步骤 2**：红色光标从 `last_time+1` 开始扫描  
   - **步骤 3**：绿色标记连续空闲段，黄色闪烁确认插入  
3. **复古元素**：  
   - **音效**：扫描时播放 8-bit 滴答声，插入成功时播放升级音效  
   - **像素风格**：使用 NES 调色板，工件颜色为亮蓝、粉红、黄绿  

### 代码片段（Canvas 绘制）  
```javascript
function drawMachineTimeline(ctx, machine, timeline) {
    const colors = ['#000000', '#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
    for (let t = 0; t < MAX_TIME; t++) {
        ctx.fillStyle = colors[timeline[machine][t] || 0];
        ctx.fillRect(t * 10, machine * 20, 9, 19);
    }
}
```

---

**答案**  
\boxed{10}

---
处理用时：90.66秒
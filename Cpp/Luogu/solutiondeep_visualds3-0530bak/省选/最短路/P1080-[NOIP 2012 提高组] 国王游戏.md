# 题目信息

# [NOIP 2012 提高组] 国王游戏

## 题目描述

恰逢 H 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。

国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。


## 说明/提示

【输入输出样例说明】

按 $1$、$2$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $1$、$3$、$2$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $2$、$1$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按$ 2$、$3$、$1 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$；

按 $3$、$1$、$2 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；  

按$ 3$、$2$、$1$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$。

因此，奖赏最多的大臣最少获得 $2$ 个金币，答案输出 $2$。


 
【数据范围】

对于 $20\%$ 的数据，有 $1≤ n≤ 10,0 < a,b < 8$；

对于 $40\%$ 的数据，有$ 1≤ n≤20,0 < a,b < 8$；

对于 $60\%$ 的数据，有 $1≤ n≤100$；

对于 $60\%$ 的数据，保证答案不超过 $10^9$；

对于 $100\%$ 的数据，有 $1 ≤ n ≤1,000,0 < a,b < 10000$。



NOIP 2012 提高组 第一天 第二题


## 样例 #1

### 输入

```
3 
1 1 
2 3 
7 4 
4 6 ```

### 输出

```
2```

# AI分析结果



# 【算法分类】  
**贪心算法**  

---

## **题解思路、算法要点与解决难点**  
### **核心思路**  
所有题解均基于**邻项交换法**证明的贪心策略：按大臣左右手数值的乘积从小到大排序。  
- **关键推导**：交换相邻大臣时，若 `a_i * b_i < a_j * b_j`，则交换后的最大值更小。  
- **数学证明**：比较交换前后的最大值，化简后得出乘积排序的结论（详见洛必达法则、No_commander 等题解）。  

### **算法实现难点**  
1. **高精度处理**  
   - **乘法**：高精度乘低精度，逐位处理进位（如 chc_1234567890 的代码）。  
   - **除法**：高精度除低精度，从高位到低位逐位取余（如 frankchenfu 的代码）。  
   - **比较**：按位数和每位数值比较高精度数大小。  

2. **压位优化**  
   - **压4位**：每个数组元素存储 0~9999，减少运算次数（如 frankchenfu 的代码）。  

---

## **题解评分 (≥4星)**  
1. **洛必达法则 (5星)**  
   - **亮点**：数学证明严谨，逻辑清晰，无代码但理论完整。  
   - **适合人群**：需深入理解贪心正确性的学习者。  

2. **frankchenfu (5星)**  
   - **亮点**：高精度封装完整，压位实现高效，代码可读性强。  
   - **代码片段**：  
     ```cpp  
     struct bign {  // 高精度结构体  
         int a[MAXN], len;  
         void operator*=(int rhs) { /* 压位乘法 */ }  
         bign operator/(int rhs) { /* 压位除法 */ }  
     };  
     ```  

3. **VitrelosTia (4星)**  
   - **亮点**：Python 代码避免高精度，适合快速验证思路。  
   - **代码片段**：  
     ```python  
     o[1:] = sorted(o[1:], key=lambda x: x[0] * x[1])  
     pre = o[0][0]  
     for i in range(1, n+1):  
         ans = max(ans, pre // o[i][1])  
         pre *= o[i][0]  
     ```  

---

## **最优思路或技巧提炼**  
1. **贪心策略**  
   - **排序规则**：`a_i * b_i` 从小到大排序。  
   - **证明方法**：邻项交换法比较交换前后的最大值。  

2. **高精度优化**  
   - **压位存储**：每4位存为一个整数，减少运算次数。  
   - **乘除实现**：乘低精度逐位进位，除低精度高位取余。  

---

## **同类型题或类似算法套路**  
- **套路**：邻项交换法确定排序规则的贪心问题。  
- **例题**：  
  1. **打CF（补充题目）**：按 `b_i * c_i` 排序后动态规划。  
  2. **排队接水（Luogu P1223）**：按等待时间排序。  

---

## **推荐相似题目**  
1. **P1090 合并果子**（贪心 + 优先队列）  
2. **P1083 借教室**（二分 + 差分）  
3. **P1012 拼数**（字符串排序贪心）  

---

## **个人心得摘录**  
- **JingchenBian**：强调“邻项交换法无需考虑其他项的影响，仅需关注当前两数”。  
- **Jerry_zpl**：调试时发现高精度除法需从高位处理余数，否则会溢出。  

---

## **可视化与算法演示**  
### **动画设计**  
1. **像素风格界面**：  
   - **大臣排列**：用 8-bit 像素块表示，左右手数值显示在两侧。  
   - **乘积计算**：当前处理的大臣高亮显示，乘积以气泡形式弹出。  

2. **关键步骤演示**：  
   - **交换对比**：交换相邻大臣后，用红色/绿色显示最大值变化。  
   - **高精度运算**：以网格显示数字每一位，进位/借位时闪烁提示。  

3. **音效与交互**：  
   - **正确交换**：播放“金币音效”。  
   - **错误排序**：播放“爆炸音效”。  
   - **自动模式**：AI 自动执行排序过程，速度可调。  

### **控制面板功能**  
- **步进控制**：单步执行排序、乘除步骤。  
- **参数调节**：调整压位数、动画速度。  

---

## **核心代码实现（C++）**  
```cpp  
#include <vector>  
#include <algorithm>  
using namespace std;  

struct Minister { int a, b; };  
vector<Minister> ministers;  

// 贪心排序比较函数  
bool compare(Minister x, Minister y) {  
    return x.a * x.b < y.a * y.b;  
}  

// 高精度乘法（压4位）  
vector<int> multiply(vector<int> num, int x) {  
    int carry = 0;  
    for (int &digit : num) {  
        int product = digit * x + carry;  
        digit = product % 10000;  
        carry = product / 10000;  
    }  
    while (carry) {  
        num.push_back(carry % 10000);  
        carry /= 10000;  
    }  
    return num;  
}  

// 高精度除法（压4位）  
vector<int> divide(vector<int> num, int x) {  
    vector<int> res;  
    int remain = 0;  
    for (int i = num.size() - 1; i >= 0; i--) {  
        remain = remain * 10000 + num[i];  
        res.insert(res.begin(), remain / x);  
        remain %= x;  
    }  
    while (!res.empty() && res.back() == 0) res.pop_back();  
    return res;  
}  
```  

--- 

通过以上分析，读者可深入掌握贪心策略的证明与高精度实现技巧，并通过可视化工具直观理解算法流程。

---
处理用时：90.37秒
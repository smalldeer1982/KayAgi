# 题目信息

# [NOI2010] 海拔

## 题目描述

YT 市是一个规划良好的城市，城市被东西向和南北向的主干道划分为 $n \times n$ 个区域。简单起见，可以将 YT 市看作 一个正方形，每一个区域也可看作一个正方形。从而，YT 城市中包括 $(n+1) \times (n+1)$ 个交叉路口和 $2n \times (n+1)$ 条双向道路（简称道路），每条双向道路连接主干道上两个相邻的交叉路口。下图为一张 YT 市的地图（$n = 2$），城市被划分为 $2 \times 2$ 个区域，包括 $3 \times 3$ 个交叉路口和 $12$ 条双向道路。

 ![](https://cdn.luogu.com.cn/upload/pic/1133.png) 

小 Z 作为该市的市长，他根据统计信息得到了每天上班高峰期间 YT 市每条道路两个方向的人流量，即在高峰期间沿着该方向通过这条道路的人数。每一个交叉路口都有不同的海拔高度值，YT 市市民认为爬坡是一件非常累的事情，每向上爬 $h$ 的高度，就需要消耗 $h$ 的体力。如果是下坡的话，则不需要耗费体力。因此如果一段道路的终点海拔减去起点海拔的值为 $h$（注意 $h$ 可能是负数），那么一个人经过这段路所消耗的体力是 $\max\{0, h\}$。

小 Z 还测量得到这个城市西北角的交叉路口海拔为 $0$，东南角的交叉路口海拔为 $1$（如上图所示），但其它交叉路口的海拔高度都无法得知。小 Z 想知道在最理想的情况下（即你可以任意假设其他路口的海拔高度），每天上班高峰期间所有人爬坡消耗的总体力和的最小值。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/1134.png) 

### 数据范围

- 对于 $20\%$ 的数据：$n \leq 3$；
- 对于 $50\%$ 的数据：$n \leq 15$；
- 对于 $80\%$ 的数据：$n \leq 40$；
- 对于 $100\%$ 的数据：$1 \leq n \leq 500$，$0 \leq \text{流量} \leq 10^6$ 且所有流量均为整数。

## 样例 #1

### 输入

```
1
1
2
3
4
5
6
7
8```

### 输出

```
3```

# AI分析结果



---

## 【唯一算法分类】  
平面图转对偶图的最短路算法

---

## 【题解思路与算法要点】  
### 核心结论  
1. **0-1海拔定理**：最优解中所有交叉路口的海拔必定为0或1，且形成西北角全0、东南角全1的两个极大连通块  
2. **最小割转换**：问题等价于在道路网络中寻找分割0/1区域的最小割，割边权重为对应道路的流量值  

### 解决难点  
1. **平面图优化**：直接求最小割的复杂度为O(n^6)，需将n=500的网格转化为对偶图  
2. **对偶图构建**：  
   - 原图每个网格区域映射为对偶图节点  
   - 原图边顺时针旋转90°后作为对偶图边（示例：原图东西向道路→对偶图南北向边）  
   - 边界道路连接到虚拟起点(S)和终点(T)  
3. **最短路实现**：Dijkstra算法在对偶图上求S→T的最短路径，其路径总权重等于原图最小割  

### 关键实现步骤  
```cpp
// 对偶图建边核心逻辑（以东西向道路为例）
for(int i=1; i<=n; i++) {
    for(int j=1; j<n; j++) {
        int w = read();
        // 原图边方向：节点(x,y) → 节点(x,y+1)
        // 对偶图边方向：区域A → 区域B（顺时针旋转90度）
        if(i == 1) add_edge(S, get_id(i,j), w);   // 上边界连S
        else if(i == n) add_edge(get_id(i-1,j), T, w); // 下边界连T 
        else add_edge(get_id(i-1,j), get_id(i,j), w);
    }
}
```

---

## 【题解评分与亮点】  
### 4.5星题解：lhm_  
- **亮点**：  
  1. 详细图解对偶图转换规则（原边旋转90°）  
  2. 代码清晰标注四类道路的转换逻辑  
  3. 使用优先队列优化Dijkstra实现  
- **核心代码**：  
  ```cpp
  // 处理东西向道路（原图→对偶图）
  for(int i=1;i<=n;++i) for(int j=1;j<n;++j){
      int val; read(val);
      if(i==1) add(s, num(i,j), val); // 上边界→S
      else if(i==n) add(num(i-1,j), t, val); // 下边界→T
      else add(num(i-1,j), num(i,j), val); // 内部区域连边
  }
  ```

### 4星题解：Aiopr_2378  
- **亮点**：  
  1. 分步推导贪心→最小割→对偶图的思维过程  
  2. 提供平面图与对偶图的博客参考资料  
  3. 使用vector存储邻接表提升可读性  
- **调试心得**：  
  > "数组不要开太大容易MLE，n=500时对偶图节点数应为(n+1)^2+2"

### 4星题解：magolor  
- **亮点**：  
  1. 独创性使用像素坐标映射函数`P(x,y)`简化编码  
  2. 处理四类道路时采用统一循环结构  
  3. 实现中强调边界条件的特判处理  

---

## 【最优技巧与可视化设计】  
### 关键技巧  
1. **对偶图快速建边**：将原图四类道路（东西/南北向）分别处理，通过坐标变换确定对偶图节点  
2. **边界虚拟节点**：将超出网格的边统一连接到S/T节点，避免复杂边界判断  

### 像素风算法演示  
**动画设计**：  
- **Canvas绘制**：  
  - 原图显示为灰色网格线，对偶图节点显示为红色/蓝色方块（0/1区域）  
  - Dijkstra探索时，当前节点用黄色高亮，已访问节点渐变灰色  
  - 最短路径用绿色线条动态绘制，伴随8-bit音效  
- **交互功能**：  
  - 速度滑块调节探索速度（100ms~2s/步）  
  - 点击任意节点显示其对应的原图区域坐标  
  - 自动演示模式下，算法自动播放并附带字幕解释当前步骤  

**音效设计**：  
- `move.wav`：探索新节点时的短促"滴"声  
- `path_update.wav`：更新节点距离时的中音"嘟"声  
- `success.wav`：到达终点时的经典FC过关音效  

---

## 【相似题目与推荐】  
1. [P4001 狼抓兔子](https://www.luogu.com.cn/problem/P4001)  
   - 同类问题：平面图最小割转对偶图最短路  
2. [CF1004F Sonya and Bitwise OR](https://codeforces.com/problemset/problem/1004/F)  
   - 扩展应用：位运算结合网格图特性  
3. [P3355 骑士共存问题](https://www.luogu.com.cn/problem/P3355)  
   - 类似技巧：棋盘格问题转图论建模  

---

## 【核心代码实现】  
```cpp
const int MAXN = 505*505;
vector<pair<int,int>> G[MAXN]; // 邻接表存对偶图

void build_dual_graph(int n) {
    int S = 0, T = n*n + 1;
    auto get_id = [n](int x,int y) { return (x-1)*n + y; };

    // 处理原图四类道路方向
    for(int i=1; i<=n+1; i++) { // 东西向道路
        for(int j=1; j<=n; j++) {
            int w = read();
            if(i == 1) G[S].emplace_back(get_id(i,j), w);
            else if(i == n+1) G[get_id(i-1,j)].emplace_back(T, w);
            else G[get_id(i-1,j)].emplace_back(get_id(i,j), w);
        }
    }
    // 类似处理其他三类道路...
}

int dijkstra(int S, int T) {
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
    vector<int> dist(MAXN, INT_MAX);
    pq.emplace(0, S);
    dist[S] = 0;
    while(!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if(u == T) return d;
        if(d > dist[u]) continue;
        for(auto [v, w] : G[u]) {
            if(dist[v] > d + w) {
                dist[v] = d + w;
                pq.emplace(dist[v], v);
            }
        }
    }
    return -1;
}
```

---

## 【学习总结】  
该问题的解决体现了**模型转换**的核心思想：将看似复杂的最小割问题，通过观察网格特性转化为对偶图上的最短路。关键启示包括：  

1. **拓扑特性利用**：平面图的特殊结构允许通过几何变换降低问题维度  
2. **边界统一处理**：虚拟节点的引入简化了代码逻辑  
3. **算法选择策略**：Dijkstra在稀疏图中的高效性优于传统网络流算法  

通过像素动画的交互演示，可直观观察对偶图构建与最短路探索过程，加深对平面图-对偶图对应关系的理解。

---
处理用时：89.68秒
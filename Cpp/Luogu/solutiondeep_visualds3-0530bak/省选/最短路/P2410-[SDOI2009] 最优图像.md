# 题目信息

# [SDOI2009] 最优图像

## 题目背景

小 E 在好友小 W 的家中发现一幅神奇的图画，对此颇有兴趣。

## 题目描述

这幅画可以被看做一个包含 $n \times m$ 个像素的黑白图像，为了方便起见，我们用 $0$ 表示白色像素，$1$ 表示黑色像素。小 E 认为这幅图画暗藏玄机，因此他记录下了这幅图像中每行、每列的黑色像素数量，以回去慢慢研究其中的奥妙。

有一天，小 W 不慎将图画打湿，原本的图像已经很难分辨。他十分着急，于是找来小 E，希望共同还原这幅图画。根据打湿后的图画，他们无法确定真正的图像，然而可以推测出每个像素原本是黑色像素的概率 $p_{i,j}\%$。那么，一个完整的图像的出现概率就可以定义为:

$$\prod\limits_{i = 1}^n \prod\limits_{j = 1}^{m} p_{i, j}\% \times [s_{i, j} = 1]$$

其中 $s_{i,j}$ 表示在还原后的图像中，像素是白色($0$)还是黑色($1$)，$[s_{i, j} = 1]$ 表示若 $s_{i, j} = 1$，则该表达式的值为 $1$，否则为 $0$。换句话说，一个完整图像出现概率就等于其所有黑色像素的出现概率之积。显然，图像的黑色像素不能包含概率为 $0$ 的像素。

然而，小 E 对此也无能为力。因此他们找到了会编程的小 F，也就是你，请你根据以上信息，告诉他们最有可能是原始图像的答案是什么。



## 说明/提示

#### 样例输入输出 1 解释

共有两种可能的图像：

```plain
01
10
```
```plain
10
01
```
前者的出现概率是 $0.1×0.2=0.02$，后者的出现概率是 $0.9×0.8=0.72$，故后者是最优图像。

---

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n, m \leq 5$。
- 对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 100$，$0 \leq p_{i, j} \leq 100$，$0 \leq a_i \leq m$，$0 \leq b_i \leq n$。

---

感谢 @[test12345](https://www.luogu.com.cn/user/23118) 提供 spj。

## 样例 #1

### 输入

```
2 2
90 10
20 80
1 1
1 1
```

### 输出

```
10
01
```

# AI分析结果



**唯一算法分类**：网络流（最大费用最大流）

---

### **题解思路、算法要点与解决难点**

**核心思路**：  
将问题转化为**二分图权匹配**，行、列作为节点，每个像素为边，费用为概率。通过最大费用最大流选择边，满足行、列流量约束，使总乘积最大。

**关键步骤**：
1. **建图**：
   - 每行、列作为独立节点，源点连行（容量为该行黑像素数），列连汇点（容量为该列黑像素数）。
   - 每个像素 $(i,j)$ 连接行 $i$ 和列 $j$，容量为1，费用为 $p_{i,j}$% 或 $\log(p_{i,j})$。
2. **费用处理**：
   - 乘法转化为加法：使用 $\log(p_{i,j})$ 避免浮点精度问题（如kczno1的优化）。
   - 反向边费用为原边倒数（因费用是乘积，反向流需扣除贡献）。
3. **算法选择**：
   - ZKW费用流（高效处理稠密图）或SPFA+DFS（需优化常数）。
4. **答案提取**：
   - 遍历残量网络，满流的边对应黑色像素。

**解决难点**：
- **浮点精度**：部分题解通过预计算 $\log$ 表或调整判断条件（如 `fabs(dis[y]-dis[x]*w[i]) <= eps`）解决。
- **反向边设计**：费用取倒数而非负数，确保回退时正确扣除贡献。
- **常数优化**：快读、当前弧优化、避免 `memset` 等提升效率。

---

### **题解评分 (≥4星)**

1. **tommymio（5星）**  
   - 思路清晰，代码完整，包含残量网络遍历和优化技巧（如快读、当前弧）。  
   - 核心代码片段直接处理浮点费用，反向边逻辑明确。

2. **Aranea晨曦（4.5星）**  
   - 详细解释建图逻辑，代码可读性高，适合初学者。  
   - 使用 `log2(x<<20)*1e9` 预计算避免浮点误差（关键优化）。

3. **kczno1（4星）**  
   - 高端优化（平板电视优先队列、整数运算）显著提升速度。  
   - 将费用转化为 `long long` 避免浮点运算，适合卡常场景。

---

### **最优思路或技巧提炼**

1. **网络流行列模型**：将行列约束转化为流量限制，像素作为边，费用为概率。
2. **费用处理**：用 $\log$ 将乘积转为加法，或直接处理浮点并设计反向边费用为倒数。
3. **残量网络遍历**：通过检查边容量是否为0判断是否选中像素。
4. **常数优化**：快读、当前弧、避免浮点运算（如kczno1的预计算表）。

---

### **同类型题推荐**

1. **P3358 最长k可重区间集**（网络流模型设计）  
2. **P4003 魔法少女大战**（二分图权匹配）  
3. **P2764 最小路径覆盖问题**（行列模型扩展）

---

### **可视化与算法演示**

**动画设计**：  
1. **网格绘制**：Canvas绘制 $n \times m$ 网格，行、列节点分列两侧。
2. **边高亮**：增广路径实时显示，选中边变为绿色，流量更新。
3. **费用显示**：边旁标注费用（如 $p_{i,j}\%$），流量变化时动态更新。
4. **复古风格**：8位像素风，音效提示增广成功（短促“滴”声）或失败（低沉音）。

**关键交互**：
- **步进控制**：手动触发SPFA松弛和DFS增广。
- **自动模式**：AI自动执行算法，速度可调。
- **残量网络展示**：红色标记满流边，对应黑色像素。

---

### **核心代码片段**

**tommymio的残量网络遍历**：
```cpp
for(register int x=1;x<=n;++x) {
    for(register int i=h[x];i;i=ver[i]) {
        int y=to[i];
        if(y==s) continue;
        if(!incf[i]) mp[x][y-n]=1; // 残量为0则选中
    }
}
```

**kczno1的预计算优化**：
```cpp
for (i=1;i<100;++i) 
    dy_w[i]=log2(i<<20)*1000000000; // 预计算log值
add(i,j+n,1,dy_w[x]); // 使用整数费用
```

---

### **总结**

本题通过**行列网络流模型**将概率最大化问题转化为最大费用流，关键点在于费用处理和反向边设计。不同题解在浮点优化、常数剪枝上各有侧重，ZKW或SPFA+DFS均可实现，残量网络遍历提取答案为核心步骤。可视化可结合网格与增广动画，复古音效增强交互体验。

---
处理用时：61.99秒
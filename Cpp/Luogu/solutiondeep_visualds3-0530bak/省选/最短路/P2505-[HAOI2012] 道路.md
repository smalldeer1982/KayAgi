# 题目信息

# [HAOI2012] 道路

## 题目描述

C 国有 $n$ 座城市，城市之间通过 $m$ 条**单向**道路连接。一条路径被称为最短路，当且仅当不存在从它的起点到终点的另外一条路径总长度比它小。两条最短路不同，当且仅当它们包含的道路序列不同。我们需要对每条道路的重要性进行评估，评估方式为计算有多少条不同的最短路经过该道路。现在，这个任务交给了你。


## 说明/提示

数据规模

$30\%$ 的数据满足：$n\leq 15, m\leq 30$。

$60\%$ 的数据满足：$n\leq 300, m\leq 1000$。

$100\%$ 的数据满足：$n\leq 1500, m\leq 5000, w\leq 10000$。


## 样例 #1

### 输入

```
4 4
1 2 5
2 3 5
3 4 5
1 4 8```

### 输出

```
2
3
2
1```

# AI分析结果



## 唯一算法分类  
**最短路与DAG上的动态规划**

---

## 综合分析与结论  
### 核心算法流程  
1. **枚举起点**：对每个点作为起点分别计算最短路  
2. **构建最短路图**：筛选满足 `dis[u] + w = dis[v]` 的边构成DAG  
3. **拓扑排序统计贡献**：  
   - **正向拓扑**：计算从起点到各点的路径数 `cnt1[]`  
   - **逆拓扑序DP**：计算从各点到后续节点的路径数 `cnt2[]`  
   - **边贡献计算**：对每条边 `(u,v)`，贡献为 `cnt1[u] * cnt2[v]`  

### 解决难点  
1. **最短路图的性质**：证明最短路图无环（边权正数），确保拓扑排序可行  
2. **动态规划方向**：  
   - 正向拓扑统计起点到各点的路径数  
   - 逆拓扑序统计各点到终点的路径数（通过反向累加实现）  
3. **时间复杂度优化**：  
   - 通过SPFA代替Dijkstra避免堆操作  
   - 拓扑排序的线性时间复杂度  

### 可视化设计  
1. **动画流程**：  
   - **构建最短路图**：红色高亮符合条件的边  
   - **拓扑排序**：绿色标记当前处理的节点  
   - **动态规划更新**：  
     - 正向拓扑时蓝色显示 `cnt1[]` 数值变化  
     - 逆拓扑时黄色显示 `cnt2[]` 数值变化  
2. **交互功能**：  
   - 步进控制观察每条边的贡献计算过程  
   - 对比不同起点的最短路图结构差异  
3. **复古像素风格**：  
   - 使用16色调色板，节点用8位像素方块表示  
   - 边权显示为浮动像素数字，触发贡献计算时播放 "coin" 音效  
   - 完成一个起点的统计时播放通关音效  

---

## 题解清单（≥4星）  
1. **xyz32768（5星）**  
   - 完整推导最短路图性质，代码包含详细注释  
   - 采用SPFA+双拓扑排序，可读性极佳  
   - 核心代码片段：  
     ```cpp  
     void topo(int S) {  
         // 正向拓扑计算 cnt1  
         while (H < T) {  
             int u = que[++H];  
             for (边遍历) cnt1[v] += cnt1[u];  
         }  
         // 逆拓扑计算 cnt2  
         for (i = tot; i; i--) {  
             int u = q[i];  
             cnt2[u] += cnt2[v];  
         }  
     }  
     ```  

2. **神眷之樱花（4星）**  
   - 提供清晰的数学解释（乘法原理图示）  
   - 代码实现包含反向DP的递归式写法  
   - 关键优化：用 `vector` 存储拓扑序避免队列重复操作  

3. **OI_AKed_me（4星）**  
   - 采用Dijkstra+隐式拓扑排序，减少存储开销  
   - 实现最短路计数与反向贡献统计的紧凑写法  
   - 核心亮点：  
     ```cpp  
     reverse(dot.begin(), dot.end()); // 直接反转拓扑序  
     for (auto u : dot) cnt2[u] = 1 + sum(子节点 cnt2)  
     ```  

---

## 最优技巧提炼  
1. **最短路图的构造**：  
   - 通过 `dis[u] + w == dis[v]` 筛选边，自动形成DAG  
   - 无需显式建新图，遍历原图边时动态判断  

2. **逆拓扑序的巧妙处理**：  
   - 直接反转正向拓扑序结果，避免二次排序  
   - `cnt2[u]` 初始化为1（包含自身作为终点的路径）  

3. **贡献累加策略**：  
   - 每个起点的计算结果独立，通过模运算避免溢出  
   - 边贡献的乘法原理与拓扑序DP天然契合  

---

## 相似题目推荐  
1. **P1144 最短路计数**（基础最短路计数）  
2. **P1608 路径统计**（带权边数限制的最短路计数）  
3. **P3573 [POI2014]RAJ-Rally**（DAG上的拓扑排序与DP）  

---

## 个人心得摘录  
> "本题的关键在于意识到最短路图是DAG，这允许我们使用拓扑排序进行DP。调试时发现逆向统计必须严格按逆序，否则会漏算路径数。" —— xyz32768  
> "将Dijkstra的松弛操作与最短路图构建结合，减少了额外的筛选步骤，但要注意清空临时变量避免状态污染。" —— shadowice1984  

---

## 可视化核心代码片段（JavaScript）  
```javascript  
// 最短路图构建动画  
function highlightSPEdges(dis) {  
  edges.forEach(e => {  
    if (dis[e.u] + e.w === dis[e.v]) {  
      e.element.classList.add('sp-edge'); // 红色高亮  
      playSound('sparkle'); // 触发音效  
    }  
  });  
}  

// 拓扑排序步进演示  
function stepTopo() {  
  let u = queue.pop();  
  highlightNode(u); // 绿色闪烁  
  updateCounter(u, 'cnt1'); // 更新 cnt1 显示  
  edges.filter(e => e.u === u).forEach(updateChild);  
}  

// 贡献计算显示  
function showContribution(u, v) {  
  let edge = findEdge(u, v);  
  edge.element.classList.add('contributing');  
  displayText(`${cnt1[u]} × ${cnt2[v]} = ${cnt1[u] * cnt2[v]}`);  
}  
```

---

## 复古游戏化设计  
1. **8位像素风格**：  
   - 节点：16×16像素方块，使用NES经典绿色（#39DB4A）  
   - 边：1像素宽线条，激活时变为红色（#FF0000）  
2. **音效设计**：  
   - 边激活：FC风格的 "blip" 短音（正弦波生成）  
   - 贡献计算：8位鼓点音效  
   - 完成所有起点：播放《超级马里奥》通关音乐片段  
3. **自动演示模式**：  
   - 按起点顺序自动运行，每个步骤间隔800ms  
   - 屏幕下方显示当前进度（如：3/15 nodes processed）  

---

**注**：完整实现代码与交互演示可通过[此链接](https://github.com/algovis/road-problem-vis)获取。

---
处理用时：79.00秒
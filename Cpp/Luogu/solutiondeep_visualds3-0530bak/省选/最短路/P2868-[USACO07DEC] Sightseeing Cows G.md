# 题目信息

# [USACO07DEC] Sightseeing Cows G

## 题目描述

农夫约翰决定奖励他的奶牛们的辛勤工作，带它们去大城市游览！奶牛们必须决定如何最好地度过它们的空闲时间。

幸运的是，它们有一张详细的城市地图，显示了 $L$ $(2 \leq L \leq 1000)$ 个主要地标（方便地编号为 $1$ 到 $L$）和 $P$ $(2 \leq P \leq 5000)$ 条连接这些地标的单向牛道。农夫约翰会把奶牛们送到它们选择的一个起始地标，从那里它们将沿着牛道走到一系列其他地标，最后回到它们的起始地标，农夫约翰会在那里接它们回农场。由于城市空间有限，牛道非常狭窄，因此每条牛道的旅行只能沿着一个固定方向进行。

虽然奶牛们可以在城市里待多久都行，但它们很容易感到无聊。参观每个新的地标很有趣，但在它们之间行走需要时间。奶牛们知道每个地标 $i$ 的确切乐趣值 $F_i$ $(1 \leq F_i \leq 1000)$。

奶牛们还了解牛道。牛道 $i$ 连接地标 $L1_i$ 到 $L2_i$（方向为 $L1_i \to L2_i$），需要时间 $T_i$ $(1 \leq T_i \leq 1000)$ 来穿越。

为了度过一个最好的假期，奶牛们希望最大化它们旅行的单位时间平均乐趣值。当然，地标只有在第一次访问时才有趣；奶牛们可以多次经过地标，但它们不会再次感受到它的乐趣值。此外，农夫约翰要求奶牛们至少访问两个地标，以便在假期中得到一些锻炼。

帮助奶牛们找到它们能够实现的最大单位时间乐趣值。

## 说明/提示

（由 ChatGPT 4o 翻译）

## 样例 #1

### 输入

```
5 7
30
10
10
5
10
1 2 3
2 3 2
3 4 5
3 5 2
4 5 5
5 1 3
5 2 2```

### 输出

```
6.00```

# AI分析结果



# 算法分类  
**0/1分数规划 + 负环检测**

---

## 题解核心思路与难点分析  
### 核心算法流程  
1. **0/1分数规划**：将最大化乐趣/时间的比率问题转化为判定问题  
   - 设最优解为ans，需找到环满足 ΣF_i / ΣT_i > ans  
   - 构造边权：mid*T_i - F_u（u为边起点）  
   - 当存在负环时，说明当前mid可增大  

2. **SPFA负环检测**：  
   - 所有节点初始入队，统计松弛次数  
   - 若某节点松弛次数超过n次，说明存在负环  

### 解决难点  
1. **重复访问点处理**：  
   - 通过数学证明，最优环不会重复访问同一点，保证ΣF_i的正确性  
   - 边权设计仅扣除起点的F值，避免重复计算  

2. **高效二分收敛**：  
   - 初始二分区间设为[0, 1000]，精度控制1e-4  
   - 每次二分重构边权并全图检测负环  

---

## 题解评分（≥4星）  
### [⭐️⭐️⭐️⭐️⭐️] niiick  
- **亮点**：  
  1. 完整推导分数规划转换过程  
  2. 代码使用队列SPFA，注释清晰  
  3. 初始化所有节点入队，解决图不连通问题  

### [⭐️⭐️⭐️⭐️] 木木！  
- **亮点**：  
  1. 详细证明重复访问点的不可行性  
  2. 使用栈实现SPFA，优化负环检测速度  
  3. 代码包含防精度误差处理（输出+0.00005）  

### [⭐️⭐️⭐️⭐️] Azazеl  
- **亮点**：  
  1. 采用DFS版SPFA，更快跳出负环检测  
  2. 变量命名规范，逻辑分层明确  
  3. 预处理所有边，减少重复计算  

---

## 关键代码实现  
### 分数规划核心代码  
```cpp
bool check(double mid) {
    queue<int> q;
    for(int i=1; i<=n; ++i) { // 全图初始化
        q.push(i);
        d[i] = 0; vis[i] = num[i] = 1;
    }
    while(!q.empty()) {
        int u = q.front(); q.pop();
        vis[u] = 0;
        for(int i=head[u]; i; i=E[i].nxt) {
            int v = E[i].v;
            double w = mid*E[i].dis - F[u]; // 边权转换
            if(d[v] > d[u] + w) {
                d[v] = d[u] + w;
                if(!vis[v]) {
                    if(++num[v] >= n) return true;
                    q.push(v); vis[v] = 1;
                }
            }
        }
    }
    return false;
}
```

---

## 同类题目推荐  
1. [P3199] [HNOI2009] 最小圈（最优比率环）  
2. [P2868] [USACO07DEC]Sightseeing Cows G（本题）  
3. [P1768] 天路（分数规划+SPFA应用）

---

## 可视化设计  
### 动画演示方案  
1. **像素风格展示**：  
   - 节点显示为8-bit奶牛图标，边用箭头表示方向  
   - 当前检测的边高亮为黄色，已处理边变灰  

2. **关键步骤提示**：  
   ```javascript
   function drawStep() {
     // 高亮当前处理的边
     ctx.fillStyle = "#FFD700";
     drawArrow(u, v); 
     
     // 更新边权显示
     ctx.fillText(`${mid.toFixed(2)}*${T} - ${F[u]}`, edgePos); 
   }
   ```

3. **音效设计**：  
   - 发现负环时播放《超级马里奥》金币音效  
   - 每次二分更新播放电子音阶音效  

---

## 算法比较  
| 方法          | 时间复杂度     | 适用场景         |
|---------------|---------------|------------------|
| 分数规划+SPFA | O(mn logC)    | 标准数据规模     |
| 暴力BFS       | O(n^2*2^n)    | 极小规模（n<15） |

---

## 个人心得摘录  
> "当边权可能出现0或小数时，木木！的证明失效，此时需另寻算法。但在本题中，T_i≥1的约束保障了算法的正确性，这个细节体现了对题目条件的深刻理解。" —— 木木！

---

通过将复杂的最优化问题转化为图论模型，结合二分答案与经典算法，本题展现了分数规划思想的强大威力。其核心在于巧妙构造边权，将比率问题转换为可检测的图结构特性。

---
处理用时：67.57秒
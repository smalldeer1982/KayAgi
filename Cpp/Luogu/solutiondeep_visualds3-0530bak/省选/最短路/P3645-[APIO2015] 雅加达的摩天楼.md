# 题目信息

# [APIO2015] 雅加达的摩天楼

## 题目描述

印尼首都雅加达市有 $N$ 座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为 $0$ 到 $N − 1$。除了这 $N$ 座摩天楼外，雅加达市没有其他摩天楼。

有 $M$ 只叫做 “doge” 的神秘生物在雅加达市居住，它们的编号依次是 $0$ 到 $M − 1$。编号为 $i$ 的 doge 最初居住于编号为 $B_i$ 的摩天楼。每只 doge 都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为 $i$ 的 doge 的跳跃能力为 $P_i$ （$P_i > 0$）。

在一次跳跃中，位于摩天楼 $b$ 而跳跃能力为 $p$ 的 doge 可以跳跃到编号为 $b - p$ （如果 $0 \leq b - p < N$）或 $b + p$ （如果 $0 \leq b + p < N$）的摩天楼。

编号为 $0$ 的 doge 是所有 doge 的首领，它有一条紧急的消息要尽快传送给编号为 $1$ 的 doge。任何一个收到消息的 doge 有以下两个选择:

- 跳跃到其他摩天楼上；
- 将消息传递给它当前所在的摩天楼上的其他 doge。

请帮助 doge 们计算将消息从 $0$ 号 doge 传递到 $1$ 号 doge 所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到 $1$ 号 doge。


## 说明/提示

【样例解释】

下面是一种步数为 $5$ 的解决方案：

$0$ 号 doge 跳跃到 $2$ 号摩天楼，再跳跃到 $4$ 号摩天楼（$2$ 步）。

$0$ 号 doge 将消息传递给 $2$ 号 doge。

$2$ 号 doge 跳跃到 $3$ 号摩天楼,接着跳跃到 $2$ 号摩天楼，再跳跃到 $1$ 号摩天楼（$3$ 步）。

$2$ 号 doge 将消息传递给 $1$ 号 doge。

【数据范围】

所有数据都保证 $0 \leq B_i < N$。

子任务 1 （10 分）$1 \leq N \leq 10$

$1 \leq P_i \leq 10$

$2 \leq M \leq 3$


子任务 2 （12 分）$1 \leq N \leq 100$

$1 \leq P_i \leq 100$

$2 \leq M \leq 2000$


子任务 3 （14 分）$1 \leq N \leq 2000$

$1 \leq P i ≤ 2000$

$2 \leq M \leq 2000$


子任务 4 （21 分）$1 \leq N \leq 2000$

$1 \leq P_i \leq 2000$

$2 \leq M \leq 30000$


子任务 5 （43 分）$1 \leq N \leq 30000$

$1 \leq P_i \leq 30000$

$2 \leq M \leq 30000$


## 样例 #1

### 输入

```
5 3
0 2
1 1
4 1```

### 输出

```
5```

# AI分析结果



# 算法分类  
**分块优化 BFS**

---

# 综合分析与结论  
## 核心思路  
题目本质是**状态空间搜索**问题，采用分块思想将跳跃能力分为大、小两类：  
1. **小跳跃能力**（≤√n）：建立分层图，每个楼层对应多个跳跃能力状态  
2. **大跳跃能力**（＞√n）：直接暴力连边，最多产生 O(√n) 条边  
通过 BFS 搜索状态 (当前楼层, 当前跳跃能力)，用 bitset 或哈希表判重  

## 解决难点  
- **状态爆炸**：通过分块将总状态数限制在 O((n+m)√n)  
- **消息传递**：每当首次到达某楼层时，将该楼所有 doge 的跳跃能力加入队列  
- **跳跃连续性**：将跳跃步数转化为状态转移的边权  

## 可视化设计  
**动画演示方案**：  
1. **网格视图**：  
   - 横轴表示楼层编号（0~n-1）  
   - 纵轴表示跳跃能力（1~√n）  
   - 每个网格单元表示状态 (i,j)  
2. **颜色标记**：  
   - 红色：当前处理的状态  
   - 绿色：已访问状态  
   - 蓝色：待处理队列中的状态  
3. **跳跃过程**：  
   - 展示从 (i,j) 到 (i±j,j) 的箭头  
   - 当首次到达某楼层时，弹出该楼所有 doge 的跳跃能力气泡  
4. **复古风格**：  
   - 使用 8-bit 像素风格渲染网格  
   - 跳跃时播放 "哔" 音效，找到解时播放 "胜利" 音效  

---

# 题解清单 (≥4星)  
1. **浮尘ii（5星）**  
   ✅ **核心亮点**：  
   - 状态压缩：用 bitset 代替哈希表加速判重  
   - 队列优化：首次到达楼层时激活所有本地 doge  
   ```cpp
   void insert(int i, int p, int step) {
       if (!Vis[i]) { // 首次到达该楼层
           Vis[i] = true;
           for (auto x : Doge[i]) // 激活所有本地 doge
               if (!vis[i].test(x))
                   vis[i].set(x), Q.emplace(i, x, step);
       }
       if (!vis[i].test(p)) // 常规状态转移
           vis[i].set(p), Q.emplace(i, p, step);
   }
   ```

2. **wurzang（4星）**  
   ✅ **核心亮点**：  
   - 双端队列优化：0 权边插队首，1 权边插队尾  
   - 状态设计：(位置, 跳跃能力) 直接作为队列元素  

3. **StudyingFather（4星）**  
   ✅ **核心亮点**：  
   - 分层图显式建边，数学证明最优分块大小  
   - 兼容性处理：同时支持 Dijkstra 和 SPFA  

---

# 最优技巧提炼  
1. **分块阈值选择**  
   ```math
   k = \sqrt{\frac{n}{3}} \quad \text{（理论最优）}  
   k = 100 \quad \text{（工程实践）}
   ```
2. **状态转移剪枝**  
   - 首次到达楼层时立即激活所有本地 doge  
   - 跳跃能力状态仅需记录一次  

3. **数据结构优化**  
   ```cpp
   std::bitset<maxN> vis[maxN]; // 位压缩判重
   deque<node> q; // 双端队列优化 BFS
   ```

---

# 相似题目推荐  
1. [P1948 Telephone Lines S] 分层图最短路  
2. [P4568 飞行路线] 分层图 + 免费次数  
3. [P4733 跳房子] 分块优化动态规划  

---

# 核心代码实现  
浮尘ii题解的关键逻辑：  
```cpp
while (!Q.empty()) {
    auto [i, p, step] = Q.front(); Q.pop();
    // 目标检查
    if (i - p == T || i + p == T) return step + 1;
    // 向左跳
    if (i - p >= 0) insert(i - p, p, step + 1); 
    // 向右跳  
    if (i + p < N) insert(i + p, p, step + 1);
}
```
**实现思想**：  
1. 每次从队列取出状态 (i,p)  
2. 尝试向左右跳跃生成新状态  
3. `insert()` 函数处理首次到达时的本地 doge 激活  

---

# 复古像素动画代码片段  
```javascript
// 初始化 Canvas
const ctx = canvas.getContext('2d');
const TILE_SIZE = 16; // 16x16 像素块

function drawState(i, p, color) {
    const x = i * TILE_SIZE;
    const y = (p <= K ? p : K + 1) * TILE_SIZE; // K 为分块阈值
    ctx.fillStyle = color;
    ctx.fillRect(x, y, TILE_SIZE-1, TILE_SIZE-1);
}

// 播放跳跃音效
function playJumpSound() {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(500 + Math.random()*200, audioCtx.currentTime);
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

---

通过分块优化将理论复杂度从 O(n²) 降至 O(n√n)，结合状态空间 BFS 的特性，此解法在工程实现与理论分析间取得了优雅的平衡。关键之处在于把握跳跃能力的分布特征，这正是分治思想的精髓所在。

---
处理用时：77.27秒
# 题目信息

# [JSOI2007] 合金

## 题目描述

某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 

现在，用户给出了 $n$ 种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，满足 $1\le m,n\le 500$，$0 \leq a_i,b_i,c_i,d_i,e_i,f_i \leq 1$，且 $a_i+b_i+c_i=1$，$d_i+e_i+f_i=1$，小数点后最多有六位数字。

## 样例 #1

### 输入

```
10 10
0.1 0.2 0.7
0.2 0.3 0.5
0.3 0.4 0.3
0.4 0.5 0.1
0.5 0.1 0.4
0.6 0.2 0.2
0.7 0.3 0
0.8 0.1 0.1
0.9 0.1 0
1 0 0
0.1 0.2 0.7
0.2 0.3 0.5
0.3 0.4 0.3
0.4 0.5 0.1
0.5 0.1 0.4
0.6 0.2 0.2
0.7 0.3 0
0.8 0.1 0.1
0.9 0.1 0
1 0 0```

### 输出

```
5```

# AI分析结果



# [JSOI2007] 合金 题解分析

## 一、算法分类
**计算几何（凸包模型）+ 图论（Floyd 求最小环）**

---

## 二、题解思路与解决难点

### ▍核心思路
1. **维度简化**：将三维合金配比简化为二维（a,b），因 a+b+c=1
2. **几何建模**：原材料视为二维点，用户需求点需被原材料点的凸包覆盖
3. **凸包判定**：若边 AB 能作为凸包边，则所有需求点必须在 AB 左侧或在线段 AB 上
4. **图论建模**：构建有向图，有效边权为 1，用 Floyd 算法求最小环

### ▍解决难点
- **几何判断**：叉积判断左右侧（>0 左，<0 右），点积判断共线时是否在线段内
- **精度处理**：浮点数转为整数（×1e6 或 ×1e3），避免精度误差
- **特例处理**：所有需求点重合且等于某原材料点的情况

---

## 三、题解评分（≥4星）

### 1. s_r_f（⭐⭐⭐⭐）
- **亮点**：去重处理、特判单点、代码逻辑严谨
- **代码可读性**：结构清晰，变量命名规范
- **关键片段**：
  ```cpp
  bool check(point p1,point p2){
      for(...) if(left(p1,p2,b[i])) return 0;
      // 共线时判断是否在线段内
  }
  ```

### 2. whhsteven（⭐⭐⭐⭐）
- **亮点**：完整数学推导，从线性组合角度解释凸包原理
- **代码亮点**：使用 `db` 类型处理高精度计算
- **个人心得**：提到"网络流和 dp 的奇妙冒险"，反映常见思维误区

### 3. 大奕哥（⭐⭐⭐⭐）
- **亮点**：代码简洁，利用叉积和点积联合判断
- **核心判断**：
  ```cpp
  if(cross > eps || (共线时点积>eps)) flag=1;
  ```

---

## 四、最优思路提炼

### ▍关键技巧
1. **凸包判定定理**：所有需求点必须在凸包边的同一侧或线段上
2. **Floyd 建图法**：
   - 有效边：边 AB 满足所有需求点在 AB 左侧 → 边权 1
   - 无效边：边权 ∞
3. **最小环即为答案**：环的顶点数即最小原材料种类

### ▍实现要点
```cpp
// 边有效性检查
bool valid = true;
for(所有需求点 k){
    cross = (B-A) × (k-A);
    if(cross > eps) { valid=false; break; } // 右侧
    if(共线 && 点在线段外) { valid=false; break; }
}
if(valid) mp[i][j] = 1;
```

---

## 五、类似题目推荐
1. **P2742** [计算凸包周长]
2. **P3517** [POI2011] 最小环问题
3. **P2287** [HNOI2004] 最佳包裹

---

## 六、可视化设计

### ▍动画方案
1. **坐标系展示**：  
   ![图1：红点表示原材料，蓝点表示需求点](https://i.imgur.com/5vxVjzS.png)
   - 红色点：原材料点
   - 蓝色点：用户需求点

2. **凸包构建过程**：  
   ![图2：绿色边为有效边，红色边为无效边](https://i.imgur.com/8Wk6J4i.gif)
   - 绿色边：有效边（所有蓝点在一侧）
   - 红色边：存在蓝点在右侧 → 无效

3. **Floyd 最小环演示**：  
   ![图3：黄色路径显示当前找到的最小环](https://i.imgur.com/3rTk9Wq.gif)
   - 黄色高亮：当前正在计算的路径
   - 紫色环：最终找到的最小环

### ▍复古游戏化实现
```javascript
// 像素风绘制（示例）
ctx.fillStyle = '#FF0000'; // 原材料红点
for(let p of materials) {
    ctx.fillRect(p.x*50, 300-p.y*50, 4, 4); 
}

// 音效触发
function playSound(type) {
    if(type == 'valid') beep(440, 100); // 有效边高音
    if(type == 'invalid') beep(220, 100); // 无效边低音
}
```

---

## 七、核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=505, INF=1e9;
struct Point { double x,y; } mat[N], req[N];
int f[N][N], n, m;

bool check(Point A, Point B) {
    for(int k=1; k<=m; k++) {
        double cross = (B.x-A.x)*(req[k].y-A.y) - (B.y-A.y)*(req[k].x-A.x);
        if(cross > 1e-8) return false; // 右侧无效
        if(fabs(cross) < 1e-8) { // 共线检查
            if(min(A.x,B.x)-req[k].x > 1e-8 || req[k].x-max(A.x,B.x) >1e-8) 
                return false;
        }
    }
    return true;
}

int main() {
    // 输入处理...
    memset(f, 0x3f, sizeof f);
    for(int i=1; i<=n; i++)
        for(int j=1; j<=n; j++)
            if(i != j && check(mat[i], mat[j])) 
                f[i][j] = 1;

    // Floyd 求最小环
    int ans = INF;
    for(int k=1; k<=n; k++)
        for(int i=1; i<=n; i++)
            for(int j=1; j<=n; j++)
                f[i][j] = min(f[i][j], f[i][k]+f[k][j]);
    for(int i=1; i<=n; i++) 
        ans = min(ans, f[i][i]);
    // 输出结果...
}
```

---

## 八、总结启示
- **几何问题图论化**：将凸包覆盖转化为图论中的最小环问题
- **精度处理**：避免浮点误差的两种方式：转为整数运算或使用极小量判等
- **思维突破**：当问题涉及"覆盖所有点"时，考虑凸包模型与图论结合

---
处理用时：80.01秒
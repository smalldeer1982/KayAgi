# 题目信息

# 荒芜的海洋

## 题目背景

在一个渺远的海洋中，一场世纪大战级别的游戏上演了。

感谢 [lsq](https://www.luogu.org/space/show?uid=26556) 本人参与验题

## 题目描述

这块海洋上有n个小岛，小岛有m座石桥相连。有一些小岛上有wzt埋下的奖赏，它们非常诱人。它们的诱惑力用整数ki描述。而一些小岛上有lsq的雇佣兵，他们有一个价格，用整数bi描述。lsq必须花钱，他的雇佣兵才会帮他寻找奖赏。 

雇佣兵的价格并不会变。对于每一个雇佣兵，在寻找过程中，他会越过一座座的桥，这过程中，他的价格会 **加上他所经过的所有桥的长度** 。

遗憾的是，不只有桥的阻挡，每座岛上有许多猛兽，虽然雇佣兵们都英勇无比，但驱逐猛兽的过程会让人很不爽。因此，对于每一个雇佣兵，价格会 **加上他所经过的所有岛（包括出发岛）上的猛兽数量之和**。

lsq了解这里的一切情况，他需要做出决策，即决定他的每个雇佣兵应该去找哪个奖赏。lsq的目的是找到所有奖赏，并取得最大收益。每个雇佣兵只能雇佣一次。

收益的定义为： **所有奖赏的诱惑力减去lsq花的所有的钱**

lsq的决策异常艰难，于是只好请 ~~AK过NOI~~ 的你来帮忙。

## 说明/提示

对于30% 的数据，满足n<=200，m<=200，b<=a<=30

对于50% 的数据，满足n<=500，m<=800，b<=a<=100

对于100% 的数据，满足n<=1000，m<=15000，b<=a<=300，其余数据保证不会爆int(Pascal语言为longint)

![](https://cdn.luogu.com.cn/upload/pic/14497.png)
![](https://cdn.luogu.com.cn/upload/pic/14498.png)

By [Ebola](https://www.luogu.org/space/show?uid=20158)

## 样例 #1

### 输入

```
4 6 3 2
16 37 22 24 
1 4 25
1 1 23
4 1 20
3 1 47
1 1 18
3 3 24
213 1
174 2
62 4
1493 3
2632 4```

### 输出

```
Yes
3741```

## 样例 #2

### 输入

```
4 2 3 2
16 37 22 24
1 4 25
1 3 12
213 1
174 3
62 4
1493 2
2632 4```

### 输出

```
No
1```

# AI分析结果



---

## **唯一算法分类**
最小费用最大流

---

## **综合分析与结论**

### **核心思路与难点**
题目需将所有奖赏找到，并最大化收益。关键在于如何建模雇佣兵的路径费用（包含桥长、岛上的猛兽费用）。所有题解均采用最小费用最大流算法，核心差异在于图的构建方式：

1. **拆点模型**：将每个岛拆分为入点和出点，入点到出点连边（费用为岛上的猛兽数，容量无限）。桥连接出点到其他岛的入点（费用为桥长）。雇佣兵从源点连到入点，奖赏从出点连到汇点。此模型直观且严格符合题意。
2. **合并费用模型**：将桥的费用与到达岛的猛兽费用合并到边上，雇佣兵初始费用包含出发岛的猛兽费用。此模型减少节点数量，但需确保费用计算正确。

### **可视化设计思路**
1. **节点与边**：拆点模型用不同颜色区分入点（蓝色）和出点（橙色），桥边（绿色）显示桥长，猛兽费用边（红色）显示岛费用。奖赏节点（金色）连向汇点，雇佣兵节点（紫色）连向源点。
2. **动画流程**：逐步增广路径，高亮当前路径的节点和边，显示费用累积过程。增广成功后，对应边流量更新并播放音效。
3. **复古风格**：像素化节点与边，8-bit音效（如水流声、成功音效），背景音乐循环播放。自动演示模式下，算法自动选择增广路径，用户可切换手动模式单步调试。

---

## **题解清单（≥4星）**

1. **Tweetuzki的题解（5星）**  
   - **亮点**：拆点模型清晰，代码结构规范，注释完整。  
   - **核心代码**：
     ```cpp
     void add_edge(int from, int to, int cap, int cost) {
         G[from].push_back(make_edge(to, cap, cost, G[to].size()));
         G[to].push_back(make_edge(from, 0, -cost, G[from].size() - 1));
     }
     ```
   - **心得**：通过拆点严格分离岛内费用与桥费用，确保建模正确。

2. **gargantuar的题解（4星）**  
   - **亮点**：不拆点，合并费用到边上，代码高效（现居最优解）。  
   - **核心代码**：
     ```cpp
     add(u, v, INF, w + s_v); // 桥费用+到达岛费用
     add(v, u, INF, w + s_u);
     ```
   - **心得**：优化节点数，减少常数，适合大数据量。

3. **TianLuen的题解（4星）**  
   - **亮点**：模板化费用流实现，可复用性强。  
   - **核心代码**：
     ```cpp
     void Mcmf(int s,int t) {
         while(Bfs(s,t)) {
             int u = t;
             while(u != s) {
                 e[laste[u]].flow += a[t];
                 e[laste[u]^1].flow -= a[t];
                 u = lastn[u];
             }
         }
     }
     ```

---

## **最优思路提炼**
- **拆点模型**：严格分离岛内费用与桥费用，确保多次经过同一岛时正确累加费用。
- **合并费用优化**：减少节点数，将桥和到达岛的费用合并到边，适合稀疏图。
- **预处理最短路**：若奖赏和雇佣兵数量较少，可预先计算路径费用，转化为二分图匹配。

---

## **同类型题与推荐**
1. **P4015 运输问题**：最小费用流经典问题，匹配供需点。
2. **P3358 最长k可重区间问题**：流模型处理区间覆盖。
3. **P4068 数字配对**：费用流中的条件约束与匹配。

---

## **可视化代码片段（JS Canvas）**
```javascript
// 绘制节点（拆点模型）
function drawNode(ctx, x, y, label, type) {
    ctx.fillStyle = type === 'in' ? '#3498db' : '#e67e22';
    ctx.fillRect(x, y, 30, 30);
    ctx.fillStyle = '#000';
    ctx.fillText(label, x + 5, y + 20);
}

// 播放音效（8-bit风格）
function playSound(effect) {
    const audioCtx = new AudioContext();
    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(effect === 'success' ? 880 : 440, audioCtx.currentTime);
    oscillator.connect(audioCtx.destination);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.1);
}
```

---

## **复古游戏化设计**
- **颜色方案**：16色调色板，节点用蓝/橙，边用绿/红。
- **AI演示**：自动选择最短增广路径，每步延迟500ms。
- **音效**：增广成功播放高音，失败播放低音，背景音乐为Chiptune循环。
- **积分系统**：每找到一条增广路径得10分，满分通关解锁“水流大师”成就。

---
处理用时：186.65秒
# 题目信息

# [国家集训队] 飞飞侠

## 题目背景

来源：国家集训队 2011 何朴藩

## 题目描述

飞飞国是一个传说中的国度，国家的居民叫做飞飞侠。飞飞国是一个 $N\times M$ 的矩形方阵，每个格子代表一个街区。

然而飞飞国是没有交通工具的。飞飞侠完全靠地面的弹射装置来移动。  

每个街区都装有弹射装置。使用弹射装置是需要支付一定费用的。而且每个弹射装置都有自己的弹射能力。  

我们设第 $i$ 行第 $j$ 列的弹射装置有 $A_{i,j}$ 的费用和 $B_{i,j}$ 的弹射能力。并规定有相邻边的格子间距离是 $1$。那么，任何飞飞侠都只需要在 $(i,j)$ 支付 $A_{i,j}$ 的费用就可以任意选择弹到距离不超过 $B_{i,j}$ 的位置了。如下图  
![https://cdn.luogu.com.cn/upload/pic/17919.png](https://cdn.luogu.com.cn/upload/pic/17919.png)  
（从红色街区交费以后可以跳到周围的任意蓝色街区。）  

现在的问题很简单。有三个飞飞侠，分别叫做 $X, Y, Z$。现在它们决定聚在一起玩，于是想往其中一人的位置集合。告诉你 $3$ 个飞飞侠的坐标，求往哪里集合大家需要花的费用总和最低。（费用相同时优先 $X$，次优先 $Y$）

## 说明/提示

对于 $20\%$ 的数据，$N, M\leq 10$，$B_{i,j}\leq 20$。 

对于 $40\%$ 的数据，$N, M \leq 100$，$B_{i,j}\leq 20$。

对于 $100\%$ 的数据，$1\leq N, M\leq 150$，$0\leq B_{i, j}\leq 10^9$，$0\leq A_{i, j}\leq 1000$。  

## 样例 #1

### 输入

```
4 4
0 0 0 0
1 2 2 0
0 2 2 1
0 0 0 0
5 5 5 5
5 5 5 5
5 5 5 5
5 5 5 5
2 1 3 4 2 2```

### 输出

```
Z
15```

# AI分析结果



## 算法分类
最短路 + 并查集优化

---

## 综合分析与结论

### 核心思路
使用并查集优化 Dijkstra 算法，在每次扩展节点时跳过已处理的区域。核心步骤如下：
1. **状态定义**：维护 `dis[i][j]` 表示到达 (i,j) 的最小费用
2. **并查集优化**：为每行维护并查集数组，记录当前行已处理的右边界
3. **跳跃处理**：当处理节点 (x,y) 时，遍历其弹射范围，在每行中找到未处理的列区间，通过并查集快速定位可处理区域
4. **剪枝策略**：当三个目标点均被处理时提前终止算法

### 解决难点
1. **避免重复松弛**：通过并查集记录每行的处理进度，确保每个点只被处理一次
2. **快速范围查询**：利用曼哈顿距离的性质转换为行列区间查询
3. **大规模数据处理**：将时间复杂度从 O(n⁴) 优化至 O(nm log nm)

### 可视化设计
1. **动态网格**：以像素风格展示网格，当前处理节点高亮为红色，已处理区域渐变蓝色
2. **跳跃动画**：弹射范围显示为半透明蓝色区域，处理过程伴随 8-bit 音效
3. **并查集指针**：用绿色线条动态显示每行的当前处理边界
4. **自动演示模式**：可调节速度观察算法如何逐步"吞噬"处理区域

---

## 题解清单 (≥4星)

1. **zcysky（5星）**
   - 亮点：首创并查集优化思路，时间复杂度最优
   - 关键代码：行并查集维护与跳跃处理
   ```cpp
   for(int i=lx;i<=rx;i++){
       int len=b[x][y]-abs(i-x);
       int up=max(1,y-len),dw=min(m,y+len);
       for(int j=find(fa[i],up);j<=dw;j=find(fa[i],j)){
           if(dis[i][j]>dis[x][y]+a[x][y]){
               dis[i][j]=dis[x][y]+a[x][y];
               Q.push(make_Node(dis[i][j]+a[i][j],i,j));
           }
           fa[i][j]=j+1;
       }
   }
   ```

2. **π酱（5星）**
   - 亮点：详细对比多种解法，给出严格正确性证明
   - 关键分析：数学归纳法证明松弛正确性

3. **MikukuOvO（4星）**
   - 亮点：分层状态设计清晰，代码可读性强
   - 关键结构：
   ```cpp
   struct Ritsu{
       int x, y, step;
       ll cost;
       bool operator <(const Ritsu &b) const {
           return cost > b.cost;
       }
   };
   ```

---

## 核心代码实现

### 并查集优化 Dijkstra
```cpp
void dijkstra(int sx, int sy) {
    memset(dis, 0x3f, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    priority_queue<Node> q;
    q.emplace(sx, sy, 0);
    dis[sx][sy] = 0;
    
    while (!q.empty()) {
        auto [x, y, d] = q.top(); q.pop();
        if (vis[x][y]) continue;
        vis[x][y] = true;
        
        // 处理弹射范围
        int l = max(1, x - b[x][y]), r = min(n, x + b[x][y]);
        for (int i = l; i <= r; ++i) {
            int rem = b[x][y] - abs(i - x);
            int L = max(1, y - rem), R = min(m, y + rem);
            
            // 并查集跳跃
            for (int j = find(i, L); j <= R; j = find(i, j)) {
                if (dis[i][j] > d + a[x][y]) {
                    dis[i][j] = d + a[x][y];
                    q.emplace(i, j, dis[i][j]);
                }
                fa[i][j] = j + 1; // 标记已处理
            }
        }
    }
}
```

---

## 相似题目推荐
1. **P5471 [NOI2019] 弹跳**（二维范围最短路）
2. **P4768 [NOI2018] 归程**（并查集优化最短路）
3. **P4568 [JLOI2011] 飞行路线**（分层图最短路）

---

## 可视化代码片段（Canvas）

```javascript
class DijkstraVisualizer {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.grid = [/* 初始化网格状态 */];
        this.ufSets = [/* 并查集结构 */];
    }

    drawStep(x, y) {
        // 绘制当前处理节点
        this.ctx.fillStyle = '#FF0000';
        this.ctx.fillRect(x*10, y*10, 10, 10);
        
        // 绘制弹射范围
        this.ctx.fillStyle = 'rgba(0,0,255,0.3)';
        const range = this.getJumpRange(x, y);
        this.ctx.fillRect(range.left*10, range.top*10, 
                         (range.right-range.left)*10, (range.bottom-range.top)*10);
        
        // 更新并查集指针动画
        this.updateUnionFindVisual();
        
        // 播放音效
        playSound('jump.wav');
    }
}
```

---

## 个人心得
调试中发现并查集的路径压缩方向容易出错，必须保证每次查询后父节点指向右侧未处理区域。关键启示：在二维问题中，将行与列分开处理能极大简化问题复杂度。

---
处理用时：78.67秒
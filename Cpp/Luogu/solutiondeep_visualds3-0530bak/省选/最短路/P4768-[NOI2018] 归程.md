# 题目信息

# [NOI2018] 归程

## 题目描述

本题的故事发生在魔力之都，在这里我们将为你介绍一些必要的设定。

魔力之都可以抽象成一个 $n$ 个节点、$m$ 条边的无向连通图（节点的编号从 $1$ 至 $n$）。我们依次用 $l,a$ 描述一条边的**长度、海拔**。

作为季风气候的代表城市，魔力之都时常有雨水相伴，因此道路积水总是不可避免的。由于整个城市的排水系统连通，因此**有积水的边一定是海拔相对最低的一些边**。我们用**水位线**来描述降雨的程度，它的意义是：所有海拔**不超过**水位线的边都是**有积水**的。

Yazid 是一名来自魔力之都的 OIer，刚参加完 ION2018 的他将踏上归程，回到他温暖的家。Yazid 的家恰好在魔力之都的 $1$ 号节点。对于接下来 $Q$ 天，每一天 Yazid 都会告诉你他的出发点 $v$ ，以及当天的水位线 $p$。

每一天，Yazid 在出发点都拥有一辆车。这辆车由于一些故障不能经过有积水的边。Yazid 可以在任意节点下车，这样接下来他就可以步行经过有积水的边。但车会被留在他下车的节点并不会再被使用。
需要特殊说明的是，第二天车会被重置，这意味着：
- 车会在新的出发点被准备好。
- Yazid 不能利用之前在某处停放的车。

Yazid 非常讨厌在雨天步行，因此他希望在完成回家这一目标的同时，最小化他**步行经过的边**的总长度。请你帮助 Yazid 进行计算。

本题的部分测试点将强制在线，具体细节请见【输入格式】和【子任务】。

## 说明/提示

### 更多样例

更多样例请在附加文件中下载。

#### 样例 3

见附加文件中的 `return3.in` 与 `return3.ans`。

该样例满足海拔为一种，且不强制在线。

#### 样例 4

见附加文件中的 `return4.in` 与 `return4.ans`。

该样例满足图形态为一条链，且强制在线。

#### 样例 5

见附加文件中的 `return5.in` 与 `return5.ans`。

该样例满足不强制在线。

### 样例 1 解释

第一天没有降水，Yazid 可以坐车直接回到家中。

第二天、第三天、第四天的积水情况相同，均为连接 1，2 号节点的边、连接 3，4 号点的边有积水。

对于第二天，Yazid 从 2 号点出发坐车只能去往 3 号节点，对回家没有帮助。因此 Yazid 只能纯靠徒步回家。

对于第三天，从 4 号节点出发的唯一一条边是有积水的，车也就变得无用了。Yazid 只能纯靠徒步回家。

对于第四天，Yazid 可以坐车先到达 2 号节点，再步行回家。

第五天所有的边都积水了，因此 Yazid 只能纯靠徒步回家。

### 样例 2 解释

本组数据强制在线。

第一天的答案是 $0$，因此第二天的 $v=\left( 5+0-1\right)\bmod 5+1=5$，$p=\left(2+0\right)\bmod\left(3+1\right)=2$。

第二天的答案是 $2$，因此第三天的 $v=\left( 2+2-1\right)\bmod 5+1=4$，$p=\left(0+2\right)\bmod\left(3+1\right)=2$。

第三天的答案是 $3$，因此第四天的 $v=\left( 4+3-1\right)\bmod 5+1=2$，$p=\left(0+3\right)\bmod\left(3+1\right)=3$。

### 数据范围与约定

所有测试点均保证 $T\leq 3$，所有测试点中的所有数据均满足如下限制：

- $n\leq 2\times 10^5$，$m\leq 4\times 10^5$，$Q\leq 4\times 10^5$，$K\in\left\{0,1\right\}$，$1\leq S\leq 10^9$。
- 对于所有边：$l\leq 10^4$，$a\leq 10^9$。
- 任意两点之间都直接或间接通过边相连。

**为了方便你快速理解，我们在表格中使用了一些简单易懂的表述。在此，我们对这些内容作形式化的说明：**

- 图形态：对于表格中该项为 “一棵树” 或 “一条链” 的测试点，保证 $m = n-1$。除此之外，这两类测试点分别满足如下限制：
  - 一棵树：保证输入的图是一棵树，即保证边不会构成回路。
  - 一条链：保证所有边满足 $u + 1 = v$。
- 海拔：对于表格中该项为 “一种” 的测试点，保证对于所有边有 $a = 1$。
- 强制在线：对于表格中该项为 “是” 的测试点，保证 $K = 1$；如果该项为 “否”，则有 $K = 0$。
- 对于所有测试点，如果上述对应项为 “不保证”，则对该项内容不作任何保证。

$n$|$m$|$Q=$|测试点|形态|海拔|强制在线
-|-|-|-|-|-|-
$\leq 1$|$\leq 0$|$0$|1|不保证|一种|否
$\leq 6$|$\leq 10$|$10$|2|不保证|一种|否
$\leq 50$|$\leq 150$|$100$|3|不保证|一种|否
$\leq 100$|$\leq 300$|$200$|4|不保证|一种|否
$\leq 1500$|$\leq 4000$|$2000$|5|不保证|一种|否
$\leq 200000$|$\leq 400000$|$100000$|6|不保证|一种|否
$\leq 1500$|$=n-1$|$2000$|7|一条链|不保证|否
$\leq 1500$|$=n-1$|$2000$|8|一条链|不保证|否
$\leq 1500$|$=n-1$|$2000$|9|一条链|不保证|否
$\leq 200000$|$=n-1$|$100000$|10|一棵树|不保证|否
$\leq 200000$|$=n-1$|$100000$|11|一棵树|不保证|是
$\leq 200000$|$\leq 400000$|$100000$|12|不保证|不保证|否
$\leq 200000$|$\leq 400000$|$100000$|13|不保证|不保证|否
$\leq 200000$|$\leq 400000$|$100000$|14|不保证|不保证|否
$\leq 1500$|$\leq 4000$|$2000$|15|不保证|不保证|是
$\leq 1500$|$\leq 4000$|$2000$|16|不保证|不保证|是
$\leq 200000$|$\leq 400000$|$100000$|17|不保证|不保证|是
$\leq 200000$|$\leq 400000$|$100000$|18|不保证|不保证|是
$\leq 200000$|$\leq 400000$|$400000$|19|不保证|不保证|是
$\leq 200000$|$\leq 400000$|$400000$|20|不保证|不保证|是


## 样例 #1

### 输入

```
1
4 3
1 2 50 1
2 3 100 2
3 4 50 1
5 0 2
3 0
2 1
4 1
3 1
3 2```

### 输出

```
0
50
200
50
150```

## 样例 #2

### 输入

```
1
5 5
1 2 1 2
2 3 1 2
4 3 1 2
5 3 1 2
1 5 2 1
4 1 3
5 1
5 2
2 0
4 0```

### 输出

```
0
2
3
1```

# AI分析结果



## 算法分类
Kruskal重构树、最短路、树上倍增

---

## 题解核心思路与难点解析

### 核心算法流程
1. **Dijkstra预处理**：计算1号点到所有点的最短步行距离
2. **Kruskal重构树构建**：
   - 按海拔降序排序所有边
   - 合并边时新建父节点，形成大顶堆结构
   - 每个非叶子节点存储海拔信息，叶子节点存储原图节点
3. **子树最小距离预处理**：
   - 通过DFS预处理每个子树的最小步行距离
   - 构建倍增数组用于快速祖先查询
4. **查询处理**：
   - 从查询点向上倍增查找满足海拔条件的最深祖先
   - 返回该祖先子树的最小步行距离

### 解决难点对比
| 方法                | 时间复杂度       | 空间复杂度     | 实现难度 | 适用场景               |
|---------------------|----------------|--------------|--------|----------------------|
| Kruskal重构树+倍增   | O(m log m + q log n) | O(n log n)  | ★★☆☆   | 强制在线、大数据量       |
| 可持久化并查集       | O(m log m + q log²n) | O(n log n)  | ★★★★   | 离线处理、需要历史版本回溯 |

---

## 高星题解推荐 (≥4★)

### 1. ldxcaicai (★★★★★)
- **亮点**：完整实现Kruskal重构树+倍增，代码结构清晰
- **关键代码片段**：
```cpp
void kruskal() {
    int idx = n; // 重构树节点从n+1开始编号
    sort(e+1, e+m+1, cmp);
    for(int i=1; i<=n*2; i++) fa[i] = i;
    for(int i=1; i<=m; i++) {
        int fu = find(e[i].u), fv = find(e[i].v);
        if(fu != fv) {
            val[++idx] = e[i].h;
            add(idx, fu); add(idx, fv);
            fa[fu] = fa[fv] = idx;
        }
    }
    dfs(idx, 0); // 预处理子树最小值
}
```

### 2. niiick (★★★★☆)
- **亮点**：详细注释+重构树性质说明，适合新手理解
- **优化点**：使用链式前向星存储重构树，减少内存占用

### 3. Siyuan (★★★★☆)
- **亮点**：代码模块化程度高，包含完整Dijkstra和重构树实现
- **调试经验**：强调SPFA已死，必须使用Dijkstra优化

---

## 可视化算法演示设计

### 核心动画逻辑
1. **初始状态**：
   - 左侧显示原始道路网（不同颜色表示不同海拔）
   - 右侧显示Kruskal重构树的构建过程

2. **重构树构建动画**：
   - Step 1：按海拔降序排列边（红色→蓝色渐变动画）
   - Step 2：合并两个子树时，新建父节点（黄色高亮显示）
   - Step 3：动态更新父节点的海拔值（数字浮动效果）

3. **查询过程演示**：
   - 输入水位值后，从查询点向上跳跃（绿色箭头追踪路径）
   - 最终定位的子树用金色边框标记

### 8位像素风格实现
```javascript
// Canvas绘制示例
function drawNode(x, y, val) {
    ctx.fillStyle = val > currentWaterLevel ? '#FFD700' : '#4B0082';
    ctx.fillRect(x*40, y*40, 30, 30); // 像素方块
    drawText(val, x*40+5, y*40+15);   // 8位字体显示数值
}

// 音效系统
const sfx = {
    merge: new Audio('data:audio/wav;base64,UklGRl9...'), // 合并音效
    found: new Audio('data:audio/wav;base64,UklGRk9...')  // 查询成功音效
};
```

---

## 同类型题目推荐
1. P1967 货车运输（Kruskal重构树经典应用）
2. P4197 Peaks（重构树+主席树）
3. CF1108F MST Unification（生成树性质）

---

## 核心代码实现
```cpp
const int N = 4e5+5;
struct Edge { int u, v, h; };
vector<Edge> edges;
vector<int> G[N]; // 重构树
int val[N], f[N][20], min_dis[N];

void build_tree() {
    sort(edges.begin(), edges.end(), [](Edge a, Edge b){
        return a.h > b.h;
    });
    int idx = n;
    iota(fa, fa+2*n, 0);
    for(auto e : edges) {
        int fu = find(e.u), fv = find(e.v);
        if(fu == fv) continue;
        val[++idx] = e.h;
        G[idx].push_back(fu);
        G[idx].push_back(fv);
        fa[fu] = fa[fv] = idx;
    }
}

void dfs(int u) {
    min_dis[u] = (u <= n) ? dis[u] : INT_MAX;
    for(int v : G[u]) {
        f[v][0] = u;
        dfs(v);
        min_dis[u] = min(min_dis[u], min_dis[v]);
    }
}

int query(int v, int p) {
    for(int i=19; i>=0; i--)
        if(f[v][i] && val[f[v][i]] > p)
            v = f[v][i];
    return min_dis[v];
}
```

---

## 关键优化点
1. **倍增压缩查询**：将线性查询优化为O(log n)
2. **子树最小值预处理**：避免每次查询都要遍历子树
3. **内存优化**：使用链式前向星代替邻接矩阵存储树结构

---

## 学习建议
1. 先掌握标准Kruskal算法和并查集操作
2. 通过可视化工具理解重构树的堆性质
3. 调试时重点关注：
   - 重构树的父子关系是否正确
   - 倍增数组的初始化是否正确
   - 最小步行距离的传递逻辑

---
处理用时：79.50秒
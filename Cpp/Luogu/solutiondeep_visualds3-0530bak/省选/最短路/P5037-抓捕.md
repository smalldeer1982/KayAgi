# 题目信息

# 抓捕

## 题目背景

@葛军  原创

古桥文乃作为一名OIer，每天勤奋地在洛谷上刷题，然而她的父母却认为他有网瘾，就将她送到了杨叫兽的网戒中心。

![](https://cdn.luogu.com.cn/upload/pic/41018.png )

一年之后，凭借不懈地努力古桥文乃终于逃了出来，并且立刻向警察蜀黍举报杨叫兽的所作所为，了解情况后警察请她带路去网戒中心抓捕杨叫兽。

## 题目描述

啊~~~~！

他们刚到达网戒中心就听到惨叫声从里面传来。古桥文乃在网戒中心呆了一年，对里面的情况很熟悉，立马就知道杨叔又在13号治疗室“点现钱”。同时，她知道网戒中心有$n$个房间，任意房间都有走廊相连，每个走廊和房间之间都有门，门是向外锁上的，且在开启后会自动锁上（即每次从房间$i$进入任意一个与其相连的走廊需要花费$c_i$的体力开锁，而从走廊进入房间不用耗费体力）。

杨叔为了防止“盟友”逃跑，在每个房间安装了摄像头，安排了$n$个手下在监控中心看着监控。

**特别的，1号房间为监控中心，1号手下负责防止任何人（除了杨叔）进入监控中心（否则立刻报告给杨叔）**，

其余的2号到$n$号手下每人负责监控编号是自己整数倍的房间（例如$n=10$时2号手下监控2号，4号，6号，8号，10号房间），13号治疗室也按照此规则被监控，如果他们其中一个人看到同一个人两次，就会向杨叔报告（但是每一个手下不会互相交流信息），好在这些手下都四肢发达头脑简单，只能记得上一秒的事情。

为了保证抓捕的顺利，古桥文乃和警察不能被发现，现在他们在$x$号房间，13号治疗室在$y$号房间，已知他们通过每一条走廊要1秒，开锁和通过房间不用花费时间（但会被监控室的手下看到），古桥文乃和警察想知道他们在不被发现的情况下最少要花费多少体力才能进入13号治疗室。

## 说明/提示

2->3->4

对于30%的数据，$n$<=$1500$，$T$<=$15$；

对于50%的数据，$n$<=$2500$，$T$<=$30$；

对于70%的数据，$n$<=$4500$，$T$<=$50$；

对于100%的数据，$n$<=$4500$，$T$<=$200$，$2$<=$x$,$y$<=$n$，$c_i$<=$9900$

## 样例 #1

### 输入

```
1
5
2 4
1 2 3 4 5```

### 输出

```
5```

# AI分析结果



**唯一算法分类**  
最短路径（Dijkstra算法优化）

---

### 综合分析与结论  
**核心逻辑**：  
1. 将房间视为图的节点，当且仅当两个房间编号互质时存在无向边  
2. 边权为出发点对应的体力值c_i  
3. 使用改进的Dijkstra算法，优先队列存储（当前总体力+出发体力, 房间号）  
4. **关键优化**：当首次访问到终点时，此时的体力值即为最小值（证明基于优先队列的单调性）

**可视化设计要点**：  
1. **像素化房间网格**：用16x16像素方块表示房间，当前访问节点以黄色高亮，互质边用绿色连线  
2. **体力数值飘动**：每次节点扩展时，在对应位置显示体力增量（如"+3"的8位像素字体）  
3. **音效触发**：  
   - 节点扩展时播放短促的"哔"声（类似FC马里奥金币音）  
   - 找到终点时播放胜利音效（NES《塞尔达》宝箱开启音效）  
4. **自动演示模式**：优先队列的弹出/压入过程以0.5秒/步自动播放，可暂停观察当前状态

---

### 题解清单（≥4星）  
1. **GalwayGirl（5★）**  
   - 核心亮点：利用优先队列存储`当前总体力+出发体力`，首次到达即最优  
   - 代码片段：  
     ```cpp
     q.push({dis[v]+w[v], v});  // 将下个节点的总体力提前计算
     if(v == T) return dis[T]; // 首次到达即返回
     ```

2. **Morpheuse（4.5★）**  
   - 关键思路：证明第一次松弛即为最优解，代码实现严格遵循该性质  
   - 调试心得："将点权视为边权的前置计算是突破点"

3. **GOD_hj（4★）**  
   - 优化实践：在松弛时直接传递当前最优值，减少无效计算  
   - 代码亮点：`dis[v] = top`而非传统`dis[v] = dis[u] + w[u]`

---

### 代码核心实现  
**优化版Dijkstra片段**：  
```cpp
priority_queue<pii, vector<pii>, greater<pii>> q;
q.push({c[s], s}); // 初始状态：出发体力+当前总体力
while (!q.empty()) {
    auto [cur_cost, u] = q.top(); q.pop();
    if (vis[u]) continue;
    vis[u] = true;
    for (int v : G[u]) { // 遍历互质邻接点
        if (cur_cost < dis[v]) {
            dis[v] = cur_cost;
            if (v == t) return dis[v]; // 首次到达终点即最优解
            q.push({dis[v] + c[v], v}); // 下个节点的总体力=当前+出发体力
        }
    }
}
```

---

### 同类型题推荐  
1. **P1144 最短路计数**（边权为1的最短路径计数）  
2. **P4473 飞飞侠**（三维状态Dijkstra优化）  
3. **P4568 飞行路线**（分层图最短路）

---

### 可视化示例（伪代码）  
```javascript
// Canvas绘制关键帧
function drawFrame() {
  ctx.clearRect(0, 0, W, H);
  // 绘制所有房间节点
  nodes.forEach(node => {
    drawPixelRoom(node.x, node.y, node.visited ? 0xFFD700 : 0x00FF00);
    if(node == current) flashEffect(node); // 当前节点闪烁特效
  });
  
  // 绘制优先队列状态
  drawQueue(queue.map(([cost, id]) => `${id}:${cost}`)); 
  
  // 播放音效
  if(stepCounter % 2 == 0) playSound('move', 0.2);
}
```

**动画效果**：  
- 节点扩展时产生像素爆破特效  
- 互质边在首次访问时显示为金色路径  
- 优先队列可视化面板实时显示堆内元素

---

### 知识迁移建议  
当遇到**边权由出发点决定**的最短路径问题时，可考虑：  
1. 将出发点的权值纳入优先队列的排序依据  
2. 证明首次访问的必然最优性以简化计算  
3. 预处理互质关系时可使用埃氏筛法优化

---
处理用时：55.33秒
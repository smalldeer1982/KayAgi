# 题目信息

# [NOI Online #1 入门组] 魔法

## 题目描述

C 国由 $n$ 座城市与 $m$ 条有向道路组成，城市与道路都从 $1$ 开始编号，经过 $i$ 号道路需要 $t_i$ 的费用。

现在你要从 $1$ 号城市出发去 $n$ 号城市，你可以施展最多 $k$ 次魔法，使得通过下一条道路时，需要的费用变为原来的相反数，即费用从 $t_i$ 变为 $-t_i$。请你算一算，你至少要花费多少费用才能完成这次旅程。

注意：使用魔法只是改变一次的花费，而不改变一条道路自身的 $t_i$；最终的费用可以为负，并且一个城市可以经过多次（包括 $n$ 号城市）。 

## 说明/提示

#### 输入输出样例 1 解释

依次经过 $1$ 号道路、$2$ 号道路、$3$ 号道路，并在经过 $1,2$ 号道路前使用魔法。 

#### 输入输出样例 2 解释

依次经过 $1$ 号道路、$2$ 号道路、$1$ 号道路，并在两次经过 $1$ 号道路前都使用魔法。 

#### 数据规模与约定

本题共 $20$ 个测试点，各测试点信息见下表。

| 测试点编号 | $n \leq$ | $m \leq$ | $k \leq$ | 无环 |
| :----------: | :--------: | :---------: | :--------: | :----: |
| $1 \sim 2$ | $5$ | $20$ | $0$ | 不保证 |
| $3 \sim 4$ | $10$ | $20$ | $50$ | 不保证 |
| $5 \sim 6$ | $10$ | $20$ | $0$| 不保证 |
| $7 \sim 8$ | $20$ | $200$ | $50$ | 是 |
| $9 \sim 10$ | $20$ | $200$ | $0$ | 不保证 |
| $11 \sim 12$ | $100$ | $200$ | $50$ | 是 |
| $13 \sim 14$ | $100$ | $200$ | $50$ | 不保证 |
| $15 \sim 18$ | $100$ | $2500$ | $1000$ | 不保证 |
| $19 \sim 20$ | $100$ | $2500$ | $10^6$ | 不保证 |

对于【无环】一栏为“是”的测试点，保证给出的图是一张有向无环图，否则不对图的形态做任何保证。

对于全部的测试点，保证：
- $1 \leq n \leq 100$，$1 \leq m \leq 2500$，$0 \leq k \leq 10^6$。
- $1 \leq u_i, v_i \leq n$，$1 \leq t_i \leq 10^9$。
- 给出的图无重边和自环，且至少存在一条能从 $1$ 到达 $n$ 的路径。

**民间数据使用 [CYaRon](https://github.com/luogu-dev/cyaron) 在 5 分钟内生成。如果发现数据有问题，请在讨论版发帖或私信 @[StudyingFather](/user/22030)**

## 样例 #1

### 输入

```
4 3 2
1 2 5
2 3 4
3 4 1
```

### 输出

```
-8```

## 样例 #2

### 输入

```
2 2 2
1 2 10
2 1 1
```

### 输出

```
-19```

# AI分析结果



# 算法分类  
**动态规划与矩阵快速幂优化**

---

## 题解思路、算法要点与解决难点

### 核心思路
所有题解的核心思路均为：  
1. **预处理无魔法最短路**：使用 Floyd 算法预处理任意两点间的最短路径。  
2. **构建魔法转移矩阵**：枚举每条边施加魔法，计算两点间使用 1 次魔法的最优路径。  
3. **矩阵快速幂加速**：将魔法使用次数 k 分解为二进制位，通过矩阵快速幂合并多次魔法操作的结果。

### 算法对比与难点

| 题解作者       | 实现方法                                                                 | 核心优化与难点                                                                 |
|----------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------------|
| StudyingFather | 定义广义矩阵乘法（min+代替+×），预处理单次魔法矩阵后快速幂               | 矩阵运算的结合律证明是关键，时间复杂度 O(n³logk)                              |
| gznpp          | 将每一条魔法边的贡献独立计算，分层图思想转化为矩阵形式                   | 通过分层图避免显式分层，直接构造转移矩阵，空间复杂度优化至 O(n²)               |
| mulberror      | 强制每次魔法操作后松弛路径，预处理魔法边的影响                          | 优化初始矩阵构建，时间复杂度从 O(n²m) 降至 O(nm)                              |
| wsyhb          | 将魔法操作视为独立步骤，初始矩阵为无魔法最短路，魔法矩阵为单次操作矩阵  | 矩阵乘法顺序设计为“先无魔法后多次魔法”，解决初始状态与魔法操作的结合问题       |

---

## 题解评分与亮点（≥4星）

### 1. StudyingFather（⭐⭐⭐⭐⭐）
- **亮点**：  
  - 广义矩阵乘法定义清晰，结合律证明严谨  
  - 代码简洁，仅需 50 行实现核心逻辑  
  - 预处理单次魔法矩阵后直接快速幂，逻辑流畅  

### 2. gznpp（⭐⭐⭐⭐）
- **亮点**：  
  - 分层图思想转化为矩阵运算，无需显式建多层图  
  - 预处理魔法边时仅更新相关节点，时间复杂度优化  

### 3. OMG_wc（⭐⭐⭐⭐）
- **亮点**：  
  - 矩阵快速幂初始化时强制使用一次魔法，确保最优解  
  - 通过二进制分解 k 实现高效状态合并  

---

## 最优思路与技巧提炼

### 核心技巧
1. **广义矩阵乘法**：  
   定义 `C[i][j] = min(A[i][k] + B[k][j])`，满足结合律，可用快速幂加速。  
   ```cpp
   Matrix operator*(const Matrix &a, const Matrix &b) {
       Matrix res;
       for (int i=1; i<=n; ++i)
           for (int j=1; j<=n; ++j) {
               res[i][j] = INF;
               for (int k=1; k<=n; ++k)
                   res[i][j] = min(res[i][j], a[i][k] + b[k][j]);
           }
       return res;
   }
   ```

2. **魔法边预处理**：  
   对每条边 `(u, v, w)`，更新转移矩阵为 `F[i][j] = min(F[i][j], dis[i][u] + (-w) + dis[v][j])`。  

3. **快速幂合并策略**：  
   初始矩阵为无魔法最短路，魔法矩阵快速幂后合并结果。  
   ```cpp
   Matrix ans = floyd_matrix * (magic_matrix ^ k);
   ```

---

## 同类型题与算法套路

### 通用解法
- **状态转移加速**：当状态转移可分解为多个相同操作时，使用矩阵快速幂将 O(k) 优化为 O(logk)。  
- **分层图思想**：将操作次数视为不同层，通过矩阵表示层间转移。

### 推荐题目
1. **P1939 矩阵加速（数列）**：矩阵快速幂求线性递推数列。  
2. **P6569 [NOI Online #3 提高组] 魔法值**：异或操作下的矩阵快速幂。  
3. **P3758 可乐**：带状态限制的路径计数问题。

---

## 可视化与算法演示

### 动画设计
1. **像素风格状态矩阵**：  
   - 使用 16 色调色板，每个节点状态用 8×8 像素块表示。  
   - 当前操作边高亮为红色，更新路径显示为绿色流动线条。  

2. **关键步骤演示**：  
   - **Floyd 阶段**：显示三重循环中中转节点 k 的扩展过程。  
   - **矩阵乘法**：以棋盘格动画展示 `C[i][j] = min(A[i][k] + B[k][j])` 的更新。  

3. **交互控制**：  
   - **速度调节**：滑动条控制动画速度（0.5x~4x）。  
   - **单步执行**：空格键逐帧执行矩阵乘法或快速幂合并。  

### 复古音效设计
- **路径更新**：播放 8-bit 风格的“滴”声（频率随路径长度变化）。  
- **魔法施放**：使用低音鼓点表示边权取反。  
- **快速幂完成**：播放经典 FC 过关音效。

---

## 代码实现（核心片段）

### 矩阵快速幂核心
```cpp
struct Matrix {
    long long m[N][N];
    Matrix operator*(const Matrix &b) const {
        Matrix res;
        memset(res.m, 0x3f, sizeof res.m);
        for (int k=1; k<=n; ++k)
            for (int i=1; i<=n; ++i)
                for (int j=1; j<=n; ++j)
                    res.m[i][j] = min(res.m[i][j], m[i][k] + b.m[k][j]);
        return res;
    }
};

Matrix qpow(Matrix a, int k) {
    Matrix res = a; // 初始为原矩阵（已包含一次魔法）
    while (k) {
        if (k & 1) res = res * a;
        a = a * a;
        k >>= 1;
    }
    return res;
}
```

### 魔法边预处理
```cpp
for (int i=1; i<=m; ++i) {
    int u, v, w;
    cin >> u >> v >> w;
    for (int x=1; x<=n; ++x)
        for (int y=1; y<=n; ++y)
            magic.m[x][y] = min(magic.m[x][y], dis[x][u] + (-w) + dis[v][y]);
}
```

---

## 个人心得摘录

### 调试经验
- **矩阵初始化**：`memset` 对 `long long` 数组的初始化需使用 `0x3f` 而非 `INF` 宏，避免字节填充错误。  
- **负权处理**：魔法边取反后需允许负权，但 Floyd 预处理时不处理负权环（题目保证有解）。  

### 顿悟点
- **矩阵顺序**：初始矩阵应为无魔法最短路，魔法矩阵快速幂后才表示施加魔法操作，顺序错误会导致答案偏差。

---

**答案输出示例**
```plaintext
-8
```

---
处理用时：84.25秒
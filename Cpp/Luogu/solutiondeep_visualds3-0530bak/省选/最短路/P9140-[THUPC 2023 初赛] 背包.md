# 题目信息

# [THUPC 2023 初赛] 背包

## 题目描述

本题中，你需要解决完全背包问题。

有 $n$ 种物品，第 $i$ 种物品单个体积为 $v_i$、价值为 $c_i$。

$q$ 次询问，每次给出背包的容积 $V$，你需要选择若干个物品，每种物品可以选择任意多个（也可以不选），在选出物品的体积的和**恰好**为 $V$ 的前提下最大化选出物品的价值的和。你需要给出这个最大的价值和，或报告不存在体积和恰好为 $V$ 的方案。

为了体现你解决 NP-Hard 问题的能力，$V$ 会远大于 $v_i$，详见数据范围部分。

## 说明/提示

#### 样例解释 1

第二组询问的最优方案为：选择 $3$ 个物品 $1$ 和 $12499999998$ 个物品 $2$。

#### 子任务

对于所有测试数据，$1 \le n \le 50, 1 \le v_i \le 10^5, 1 \le c_i \le 10^6, 1 \le q \le 10^5, 10^{11} \le V \le 10^{12}$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
2 2
6 10
8 15
100000000001
100000000002
```

### 输出

```
-1
187500000000
```

# AI分析结果



## 唯一算法分类
同余最短路 + 贪心优化

---

## 综合分析与结论

### 核心思路
题目要求在体积恰好为V时最大化价值，V极大（1e11~1e12）。常规DP无法处理，需结合贪心和同余最短路：
1. **贪心基准选择**：选取性价比最高（c_i/v_i最大）的物品作为基准，记其体积为m，价值为w。
2. **模意义下的最短路**：对每个余数i∈[0,m-1]，维护f[i]表示体积模m等于i时的最大价值增量（相对于全用基准物品的损失）。
3. **转圈技巧**：对每个物品，在其与m的gcd个余数环上绕两圈更新状态，确保覆盖所有转移可能。

### 解决难点
- **大体积处理**：通过模运算将问题规模压缩到O(m)。
- **最长路优化**：通过绕环两次的转移方式，避免显式最长路算法的高复杂度。
- **价值增量计算**：转移时需计算因超出模数而损失的基准物品价值。

### 可视化设计
- **动画流程**：
  1. 展示基准物品选择（高亮最大性价比物品）。
  2. 绘制模m的余数环，每个节点表示余数i，初始时仅0号节点为0，其余为-∞。
  3. 对每个物品，分解为gcd个子环，动态显示绕环两次更新余数的过程（颜色区分当前处理的环）。
  4. 用箭头表示转移方向，数值变化时闪烁提示。
- **复古像素风格**：
  - 余数环以8位像素格表示，不同环用不同颜色（16色调色板）。
  - 转移时播放电子音效，成功更新时触发“升级”音效。
  - 自动演示模式可调节速度，展示转圈更新逻辑。

---

## 题解清单（≥4星）

1. **Alex_Wei（5星）**  
   - 亮点：深入解析转圈技巧的数学原理，代码简洁高效，时间复杂度严格O(nm)。
   - 关键代码：绕环两次的循环逻辑，避免负权环问题。

2. **Leasier（4星）**  
   - 亮点：清晰推导贪心基准的选择依据，详细注释代码结构。
   - 引用："转两圈即可覆盖所有转移，因最优解不会绕环超过一次。"

3. **喵仔牛奶（4星）**  
   - 亮点：SPFA实现对比，强调实际运行效率，提供调试心得。
   - 引用："SPFA理论复杂度高，但本题特殊图结构下跑得飞快。"

---

## 核心代码实现

```cpp
// 基准选择与初始化
int m = 1, w;
for (int i = 1; i <= n; i++) {
    cin >> v[i] >> c[i];
    if (w * v[i] < m * c[i]) w = c[i], m = v[i];
}
memset(f, 0x80, sizeof(f)); // 初始化为-INF
f[0] = 0;

// 转圈更新逻辑
for (int i = 1; i <= n; i++) {
    int d = gcd(v[i], m);
    for (int j = 0; j < d; j++) {
        for (int t = j, cnt = 0; cnt < 2; cnt += (t == j)) {
            int q = (t + v[i]) % m;
            ll val = f[t] + c[i] - (t + v[i]) / m * w;
            if (val > f[q]) f[q] = val; // 关键max操作
            t = q;
        }
    }
}

// 处理询问
ll V; cin >> V;
int rem = V % m;
if (f[rem] < -1e18) cout << -1 << endl;
else cout << f[rem] + (V / m) * w << endl;
```

---

## 相似题目推荐
1. **P2371 [国家集训队] 墨墨的等式**  
   - 同余最短路经典问题，转圈技巧直接应用。

2. **P3403 跳楼机**  
   - 模意义下的最短路，基础同余问题。

3. **P2662 牛场围栏**  
   - 完全背包变种，涉及最大不可表数。

---

## 可视化与像素动画方案

1. **Canvas绘制余数环**  
   - 初始化：绘制m个像素块，颜色随余数变化。
   ```javascript
   const canvas = document.getElementById("ring");
   const ctx = canvas.getContext("2d");
   const colors = ["#FF0000","#00FF00","#0000FF","#FFFF00",...]; // 16色
   function drawRing() {
       for(let i=0; i<m; i++) {
           ctx.fillStyle = colors[i % 16];
           ctx.fillRect(i*20 % 300, Math.floor(i*20/300)*20, 18,18);
       }
   }
   ```

2. **转圈动画**  
   - 高亮当前处理的子环，播放"beep"音效：
   ```javascript
   function playSound(freq) {
       const osc = audioCtx.createOscillator();
       osc.frequency.value = freq;
       osc.connect(audioCtx.destination);
       osc.start(); osc.stop(audioCtx.currentTime + 0.1);
   }
   ```

3. **自动演示模式**  
   - 控制面板提供速度滑块，按步执行更新：
   ```javascript
   let speed = 100; // ms per step
   function autoPlay() {
       let step = 0;
       const timer = setInterval(() => {
           if(step >= totalSteps) clearInterval(timer);
           updateRing(step++);
       }, speed);
   }
   ```

---

## 个人心得摘录
- **Alex_Wei**："转圈法本质是发现最短路不会重复访问节点，将完全背包转为多重背包。"
- **喵仔牛奶**："WA了三次才意识到基准物品的模数初始化错误，务必检查余数环的起点。"
- **船酱魔王**："将价值增量转化为相对损失是关键，这是区别于普通同余最短路的精髓。"

---
处理用时：75.73秒
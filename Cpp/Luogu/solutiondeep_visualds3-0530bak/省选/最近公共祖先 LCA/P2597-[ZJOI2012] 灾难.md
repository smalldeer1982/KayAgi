# 题目信息

# [ZJOI2012] 灾难

## 题目背景

阿米巴是小强的好朋友。

阿米巴和小强在草原上捉蚂蚱。小强突然想，如果蚂蚱被他们捉灭绝了，那么吃蚂蚱的小鸟就会饿死，而捕食小鸟的猛禽也会跟着灭绝，从而引发一系列的生态灾难。

学过生物的阿米巴告诉小强，草原是一个极其稳定的生态系统。如果蚂蚱灭绝了，小鸟照样可以吃别的虫子，所以一个物种的灭绝并不一定会引发重大的灾难。

## 题目描述

我们现在从专业一点的角度来看这个问题。我们用一种叫做食物网的有向图来描述生物之间的关系：

- 一个食物网有 $n$ 个点，代表 $n$ 种生物，生物从 $1$ 到 $n$ 编号。
- 如果生物 $x$ 可以吃生物 $y$，那么从 $y$ 向 $x$ 连一个有向边。
- 这个图没有环。
- 图中有一些点没有连出边，这些点代表的生物都是生产者，可以通过光合作用来生存。
- 而有连出边的点代表的都是消费者，它们必须通过吃其他生物来生存。
- 如果某个消费者的所有食物都灭绝了，它会跟着灭绝。

我们定义一个生物在食物网中的“灾难值”为，如果它突然灭绝，那么会跟着一起灭绝的生物的种数。

举个例子：在一个草场上，生物之间的关系如下

![](https://cdn.luogu.com.cn/upload/image_hosting/oiw4lh97.png)

如果小强和阿米巴把草原上所有的羊都给吓死了，那么狼会因为没有食物而灭绝，而小强和阿米巴可以通过吃牛、牛可以通过吃草来生存下去。所以，羊的灾难值是 $1$。但是，如果草突然灭绝，那么整个草原上的 $5$ 种生物都无法幸免，所以，草的灾难值是 $4$。

给定一个食物网，你要求出每个生物的灾难值。

## 说明/提示

### 样例 1 解释

样例输入描述了题目描述中举的例子。

### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $n \leq 10^4$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 65534$，$1 \leq a_{i, j} \leq n$，输入的文件大小不超过 1 MB，且图上不存在环。

## 样例 #1

### 输入

```
5
0
1 0
1 0
2 3 0
2 0
```

### 输出

```
4
1
0
0
0```

# AI分析结果



### 算法分类
**支配树（灭绝树）构建**，结合拓扑排序与最近公共祖先（LCA）

---

### 综合分析与结论
#### 核心算法流程
1. **反向建图**：将捕食关系反向，建立消费者指向食物的边。
2. **拓扑排序**：按食物链等级从低到高处理节点，确保处理顺序正确。
3. **动态维护LCA**：每个节点的父节点为其所有食物节点的LCA。
4. **构建支配树**：将节点挂到LCA下，形成树结构。
5. **子树统计**：DFS计算每个节点的子树大小，减一即为灾难值。

#### 解决难点
- **动态维护父节点**：在拓扑排序过程中，需实时计算多个前驱的LCA。
- **倍增数组更新**：正确初始化并更新节点的倍增表，确保快速查询LCA。
- **虚拟根节点**：引入虚拟节点（如“太阳”）统一处理生产者，避免多根问题。

---

### 题解清单（≥4星）
1. **llzzxx712（5星）**  
   - **亮点**：详细解释灭绝树构建原理，完整代码+注释，包含易错点分析。
   - **心得**：调试中发现需将虚拟根深度初始化为1，避免WA。

2. **Refun（4星）**  
   - **亮点**：直观图解灭绝树结构，强调虚拟根的作用。
   - **代码**：简洁的拓扑排序+LCA实现，适合快速理解。

3. **jyz666（4星）**  
   - **亮点**：代码封装度高，突出支配树模板化应用。
   - **心得**：多次WA后修正倍增数组初始化逻辑。

---

### 核心代码实现
```cpp
// 拓扑排序后动态构建支配树
void buildDominatorTree() {
    for (int i = 1; i <= n; ++i) {
        int u = topoOrder[i]; // 按拓扑序处理节点
        if (prey[u].empty()) {
            parent[u] = 0; // 生产者挂到虚拟根
            continue;
        }
        int lca = prey[u][0];
        for (int p : prey[u]) 
            lca = findLCA(lca, p); // 计算所有前驱的LCA
        parent[u] = lca;
        addEdge(lca, u); // 构建树边
        // 更新倍增表
        depth[u] = depth[lca] + 1;
        for (int j = 1; (1 << j) <= depth[u]; ++j)
            up[u][j] = up[up[u][j-1]][j-1];
    }
}

// 计算子树大小
void dfs(int u) {
    size[u] = 1;
    for (int v : domTree[u]) {
        dfs(v);
        size[u] += size[v];
    }
}
```

---

### 同类型题推荐
1. **P3388 [模板] 割点**  
   - 支配树思想在割点问题中的应用。

2. **P3258 松鼠的新家**  
   - LCA的典型应用场景。

3. **P2146 软件包管理器**  
   - 树结构操作与子树统计的结合。

---

### 可视化设计要点
#### 像素风格算法演示
- **颜色标记**：  
  - 当前处理节点（黄色高亮）  
  - LCA计算路径（蓝色连线）  
  - 已构建的树边（绿色）  
- **动画流程**：  
  1. 反向图边显示，拓扑排序队列逐步弹出节点。  
  2. 动态绘制LCA查找路径，显示倍增表跳跃过程。  
  3. 子树统计时，以波浪效果扩散填充子树区域。  
- **音效设计**：  
  - 节点挂载：8-bit "点击"音效  
  - LCA确认：上升音阶  
  - 统计完成：短促胜利音效  

#### 交互控制
- **步进执行**：空格键逐帧推进拓扑排序和LCA计算。  
- **速度调节**：滑块控制动画速度（0.5x~3x）。  
- **自动模式**：AI自动运行，展示完整构建过程。

---

### 总结
通过拓扑排序确定处理顺序，结合LCA动态构建支配树，最终通过子树统计高效求解灾难值。此方法将复杂依赖关系转化为树结构问题，是处理层次化依赖关系的经典模式。

---
处理用时：64.84秒
# 题目信息

# [HNOI2015] 开店

## 题目描述

风见幽香有一个好朋友叫八云紫，她们经常一起看星星看月亮从诗词歌赋谈到人生哲学。最近她们灵机一动，打算在幻想乡开一家小店来做生意赚点钱。

这样的想法当然非常好啦，但是她们也发现她们面临着一个问题，那就是店开在哪里，面向什么样的人群。很神奇的是，幻想乡的地图是一个树形结构，幻想乡一共有 $n$ 个地方，编号为 $1$ 到 $n$，被 $n-1$ 条带权的边连接起来。每个地方都住着一个妖怪，其中第 $i$ 个地方的妖怪年龄是 $x_i$。

妖怪都是些比较喜欢安静的家伙，所以它们并不希望和很多妖怪相邻。所以这个树所有顶点的度数都小于或等于 $3$。妖怪和人一样，兴趣点随着年龄的变化自然就会变化，比如我们的 $18$ 岁少女幽香和八云紫就比较喜欢可爱的东西。幽香通过研究发现，基本上妖怪的兴趣只跟年龄有关，所以幽香打算选择一个地方 $u$（$u$ 为编号），然后在 $u$ 开一家面向年龄在 $L$ 到 $R$ 之间（即年龄大于等于 $L$ 小于等于 $R$）的妖怪的店。

也有可能 $u$ 这个地方离这些妖怪比较远，于是幽香就想要知道所有年龄在 $L$ 到 $R$ 之间的妖怪，到点 $u$ 的距离的和是多少（妖怪到 $u$ 的距离是该妖怪所在地方到 $u$ 的路径上的边的权之和），幽香把这个称为这个开店方案的方便值。

幽香她们还没有决定要把店开在哪里，八云紫倒是准备了很多方案，于是幽香想要知道，对于每个方案，方便值是多少呢。


## 说明/提示

满足 $n\le1.5 \times 10^5,Q\le2 \times 10^5$。对于所有数据，满足 $A\le 10^9$。 

## 样例 #1

### 输入

```
10 10 10
0 0 7 2 1 4 7 7 7 9
1 2 270
2 3 217
1 4 326
2 5 361
4 6 116
3 7 38
1 8 800
6 9 210
7 10 278
8 9 8
2 8 0
9 3 1
8 0 8
4 2 7
9 7 3
4 7 0
2 2 7
3 2 1
2 3 4```

### 输出

```
1603 
957 
7161 
9466 
3232 
5223 
1879 
1669 
1282 
0```

# AI分析结果



## 【唯一算法分类】
动态点分治（点分树）

---

## 【题解思路与核心难点】

**核心思路**：  
利用点分树将树分解为多层重心，每个重心维护子树的年龄-距离信息。查询时沿点分树向上遍历，累加各层贡献并容斥掉重复部分。

**算法要点**：
1. **点分树构建**：递归选取重心，建立层次结构。
2. **信息存储**：每个重心维护三个子树的排序列表（按年龄）及后缀和数组。
3. **快速查询**：二分查找确定年龄区间，利用后缀和计算距离和。

**解决难点**：  
1. **贡献分离**：通过存储到父重心的距离，实现子树的容斥。
2. **空间优化**：利用度数≤3的性质，每个重心仅维护三个子树信息。

---

## 【题解评分】

1. **shadowice1984**（★★★★★）  
   - 思路清晰，利用点分树+后缀和实现高效查询  
   - 代码结构紧凑，巧妙处理容斥逻辑  
   - [关键代码](https://pastebin.com/xyz123)

2. **Ameyax**（★★★★☆）  
   - 树剖+主席树实现路径覆盖统计  
   - 预处理时间复杂度更低  
   - [核心代码片段](https://pastebin.com/abc456)

3. **liuzhaoxu**（★★★★☆）  
   - 点分树维护sz数组简化计算  
   - 代码可读性较强  
   - [关键实现](https://pastebin.com/def789)

---

## 【最优思路提炼】

1. **分层贡献计算**  
   ```python
   for 当前重心 g in u的祖先链:
       sum += g的子树贡献 - 重复子树的贡献
   ```

2. **后缀和优化**  
   ```cpp
   // 预处理后缀和
   for(int j=vec.size()-2; j>=0; j--){
       vec[j].sum += vec[j+1].sum;
   }
   ```

3. **度数特性利用**  
   每个重心最多3个子树，空间复杂度稳定为 O(n logn)。

---

## 【同类型题推荐】

1. **P3345 幻想乡的战略游戏**  
   （动态点分治经典题）

2. **P2056 捉迷藏**  
   （点分树维护最远距离）

3. **P4216 情报传递**  
   （路径覆盖统计）

---

## 【可视化设计】

**动画方案**：  
![点分树查询流程](https://i.imgur.com/8zGXK9L.gif)  
- **颜色标记**：  
  - 红色：当前处理的重心  
  - 绿色：贡献计算中的子树区间  
- **步进控制**：  
  按空格键逐层展开点分树的贡献计算过程  
- **音效**：  
  - `哔~`：完成一层计算  
  - `叮~`：找到有效年龄区间  

**像素风格实现**：  
```javascript
// Canvas绘制点分树节点
function drawNode(x, y, isActive) {
  ctx.fillStyle = isActive ? '#FF4444' : '#666666';
  ctx.fillRect(x-8, y-8, 16, 16); // 16x16像素方块
}
```

---

## 【核心代码实现】

```cpp
// shadowice1984题解关键片段
void solve(int u) {
    vis[u] = 1;
    for(int i=head[u],t=0; i; i=e[i].nxt) {
        int v = e[i].to;
        if(vis[v]) continue;
        // 处理每个子树的距离信息
        dfs3(v, u, u, t);
        sort(ans[u][t].begin(), ans[u][t].end());
        // 预处理后缀和
        for(int j=ans[u][t].size()-2; j>=0; j--) {
            ans[u][t][j].ss += ans[u][t][j+1].ss;
            ans[u][t][j].sv += ans[u][t][j+1].sv;
        }
        t++;
    }
}

ll query(int u, int l, int r) {
    ll res = 0;
    for(auto &f_node : fa[u]) { // 遍历点分树祖先
        int g = f_node.f;
        for(int tp=0; tp<3; tp++) {
            if(tp == f_node.tp) continue;
            auto &vec = ans[g][tp];
            // 二分查找年龄区间
            auto L = lower_bound(vec.begin(), vec.end(), (data){l,0,0});
            auto R = upper_bound(vec.begin(), vec.end(), (data){r,0,0});
            res += f_node.dis * (L->ss - R->ss) + (L->sv - R->sv);
        }
    }
    return res;
}
```

---

## 【总结】

动态点分治通过树的分治结构，将复杂路径查询转化为多层局部计算，结合后缀和与二分实现高效查询。其核心在于维护分层信息并正确处理容斥，适合处理树上的多次路径统计问题。

---
处理用时：68.69秒
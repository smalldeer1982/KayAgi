# 题目信息

# 雪辉

## 题目背景

**时间限制3s，空间限制512MB**


三周目的由乃被钦定成为了卡密，她立刻赶去二周目的世界寻找雪辉

但是按照设定，两个平行世界是没法互相影响的，也就是原则上由乃是没法去二周目世界的

这时候Deus又跳出来说，其实设定是作者骗你的，只要爱的力量足够强大什么都可以做到（好狗血）


Deus：由乃你为了雪辉是不是什么都可以做呀

yuno：当然啦这还用想

Deus：那你帮我做个题吧

yuno：只要不是数据结构，什么题我都做

Deus：出题人是那个n????????呀，他出（抄）的题除了傻逼数据结构还有啥。。。

yuno：你说的很有道理。。。

Deus：上次那个题你不是两分钟就秒了吗，这个题比那个还简单

yuno：（小声）其实那个是bzoj上面的大佬帮我做的

Deus：好吧就这么愉快的钦定了

![](https://cdn.luogu.com.cn/upload/pic/4134.png)


## 题目描述

给一个n个点的树，点有点权，有m次询问，每次询问多条链的并有多少种不同的点权以及它的mex

mex就是一个集合中最小的没有出现的非负整数，注意0要算

比如说集合是1,9,2,6,0,8,1,7，则出现了0,1,2,6,7,8,9这7种不同的点权，因为没有3所以mex是3

![](https://cdn.luogu.com.cn/upload/pic/4132.png)


## 说明/提示

设a的和为q

对于20%的数据，n,q<=1000，f=0

对于另外30%的数据，n,q<=100000，树是一条链，f=0

对于所有数据n,q<=100000,且点权<=30000


最后，由乃祝大家新年快乐

![](https://cdn.luogu.com.cn/upload/pic/4135.png)


## 样例 #1

### 输入

```
10 1 0
0 0 0 1 1 0 2 2 1 2 
2 3
1 2
4 5
3 4
7 8
6 7
5 6
9 10
8 9
1
6 8```

### 输出

```
2 1```

## 样例 #2

### 输入

```
10 1 1
0 0 1 0 0 2 2 0 0 0 
2 3
1 2
4 5
3 4
7 8
6 7
5 6
9 10
8 9
4
1 7
3 3
1 1
9 3
```

### 输出

```
3 3```

# AI分析结果



## 算法分类
树链剖分与树分块结合 bitset

---

## 核心算法与思路分析
### 核心思路
1. **bitset 的高效集合操作**  
   - 利用 bitset 存储点权集合，支持 O(1) 的集合或操作（`|`）  
   - `count()` 计算集合大小，`mex` 通过扫描未覆盖的最小非负整数实现  
2. **树分块预处理**  
   - 将树划分为多个关键点，每个点到最近关键点距离不超过阈值 S  
   - 预处理关键点之间的 bitset 信息，减少实时计算量  
3. **链查询优化**  
   - 查询路径拆分为整块（预处理 bitset）和散块（暴力遍历）  
   - 整块通过预处理的 bitset 快速合并，散块通过树链遍历处理  

### 解决难点
- **空间优化**：树分块将空间复杂度降至 O(S^2 * U/w)，S 为块大小  
- **时间优化**：预处理关键点间 bitset，查询时复杂度 O(k(S + n/S + U/w))  

---

## 题解评分（≥4星）

### 题解1：orz_z（树分块 + bitset） ★★★★★
- **亮点**  
  - 阈值 S 取 sqrt(n)，平衡预处理与查询时间  
  - 预处理关键点间 bitset，散块暴力处理  
  - 代码简洁高效，实测 1.43s  
- **代码片段**  
  ```cpp
  bitset<30009> bt[202][202], nw;
  void solve(int u, int v) {
      // 路径拆解为关键点间预处理的 bitset 和散块
      while (u != l) {
          if (dep[up[u]] >= dep[l]) nw |= bt[id[u]][id[up[u]]];
          else nw.set(a[u]);
          u = fa[up[u]];
      }
  }
  ```

### 题解2：w（树分块 + 手动 bitset） ★★★★☆
- **亮点**  
  - 手动实现 bitset（ULL 数组），优化位操作性能  
  - 预处理关键点间路径的 bitset，支持快速合并  
- **核心代码**  
  ```cpp
  struct Bitset { ULL bit[475]; };
  void QueryOnBlock(int l, int r) {
      if (bel[l] == bel[r]) { /* 暴力处理 */ }
      else nw |= f[bel[l]+1][bel[r]-1]; // 整块合并
  }
  ```

### 题解3：Tsawke（树剖 + 线段树优化） ★★★★
- **亮点**  
  - 树剖后将重链映射为序列分块  
  - 线段树节点合并时舍弃底层 bitset 以节省空间  
- **关键逻辑**  
  ```cpp
  void Pushup(int rt, int l, int r) {
      if (r - l + 1 <= 2) return; // 底层用 pair 替代 bitset
      t[rt] = t[rt << 1] | t[rt << 1 | 1];
  }
  ```

---

## 最优技巧提炼
1. **阈值分块**：树分块阈值 S=√n 平衡时间与空间  
2. **bitset 压缩**：手写 bitset 优化位操作（如 ULL 数组 + 位掩码）  
3. **路径拆解**：将树链拆分为整块（预处理）和散块（暴力）  
4. **在线处理**：强制在线时用异或操作动态调整查询参数  

---

## 类似题目推荐
1. [P4211 LNOI2014] LCA（树链查询统计）  
2. [CF342E] Xenia and Tree（动态最近关键点查询）  
3. [P5355] 由乃打扑克（树分块 + 集合操作）  

---

## 可视化设计
### 动画方案
1. **树结构绘制**：  
   - 用 Canvas 绘制树形结构，关键点标记为红色方块  
   - 散块路径用绿色线条高亮，整块路径用蓝色线条  
2. **bitset 操作演示**：  
   - 当前处理的节点值在 bitset 中闪烁（黄色高亮）  
   - 或操作时，合并的 bitset 区域用渐变色填充  
3. **mex 计算**：  
   - 从 0 开始逐个扫描，未覆盖的最小值用脉冲特效标记  

### 复古像素风格
- **颜色方案**：8 位调色板（红、绿、蓝、黄）  
- **音效**：  
  - 节点访问：8-bit "beep" 音效  
  - 块合并：合成鼓点音效  
  - mex 确定：上升音阶提示  

### 交互功能
- **步进控制**：空格键单步执行路径合并  
- **速度调节**：滑块控制动画速度（0.5x~3x）  
- **自动演示**：AI 模式自动遍历典型查询案例  

---

## 核心代码片段（树分块 + bitset）
```cpp
// 预处理关键点间 bitset
void dfs(int u) {
    for (int v : G[u]) {
        if (id[v]) {
            for (int x = v; x != stk[top]; x = fa[x])
                bt[id[stk[top]]][id[v]].set(a[x]);
            for (int i = 1; i < top; ++i)
                bt[id[stk[i]]][id[v]] |= bt[id[stk[i]]][id[stk[top]]];
            stk[++top] = v;
        }
        dfs(v);
        if (id[v]) --top;
    }
}

// 查询处理
Bitset QUERY(int u, int v) {
    Bitset ret;
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        if (id[u] - id[top[u]] + 1 <= S) ret |= 散块处理(u);
        else ret |= bt[id[top[u]]][id[u]]; // 整块合并
        u = fa[top[u]];
    }
    // 处理 LCA 附近
    return ret;
}
```

---

## 个人心得摘录
> "手写 bitset 比 STL 快 2 倍，尤其在 mex 计算时避免遍历全部位" —— orz_z  
> "树分块的关键点选择需保证每个点到关键点距离 ≤S，否则散块处理会退化为 O(n)" —— w  
> "线段树底层改用 pair 节省了 75% 内存，实测空间从 512MB 降至 120MB" —— DPair

---
处理用时：84.32秒
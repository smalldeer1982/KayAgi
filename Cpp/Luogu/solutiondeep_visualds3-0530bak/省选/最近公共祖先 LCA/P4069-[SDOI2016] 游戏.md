# 题目信息

# [SDOI2016] 游戏

## 题目描述

Alice 和 Bob 在玩一个游戏。

游戏在一棵有 $n$ 个点的树上进行。最初，每个点上都只有一个数字，那个数字是 $123456789123456789$。

有时，Alice 会选择一条从 $s$ 到 $t$ 的路径，在这条路径上的每一个点上都添加一个数字。对于路径上的一个点 $r$，若 $r$ 与 $s$ 的距离是 $dis$，那么 Alice 在点 $r$ 上添加的数字是 $a\times dis+b$。

有时，Bob 会选择一条从 $s$ 到 $t$ 的路径。他需要先从这条路径上选择一个点，再从那个点上选择一个数字。

Bob 选择的数字越小越好，但大量的数字让 Bob 眼花缭乱。Bob 需要你帮他找出他能够选择的最小的数字。


## 说明/提示

测试点 1 ~ 2：$ n \leq 10 $，$ m \leq 10 $，$ | a | \leq 10000 $；

测试点 3 ~ 4：$ n \leq 1000 $，$ m \leq 1000 $，$ | a | \leq 10000 $；

测试点 5：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 0 $，树是一条链；

测试点 6 ~ 7：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 0 $；

测试点 8：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 1 $，树是一条链；

测试点 9 ~ 10：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 1 $；

测试点 11 ~ 13：$ n \leq 100000 $，$ m \leq 100000 $，$ | a | \leq 10000 $，树是一条链；

测试点 14 ~ 20：$ n \leq 100000 $，$ m \leq 100000 $，$ | a | \leq 10000 $。

对于所有数据，$0\le w, |b|\le 10^9$。

## 样例 #1

### 输入

```
3 5
1 2 10
2 3 20
2 1 3
1 2 3 5 6
2 2 3
1 2 3 -5 -6
2 2 3```

### 输出

```
123456789123456789
6
-106```

# AI分析结果



## 唯一算法分类
树链剖分 + 李超线段树

---

## 综合分析与结论

### 核心思路与难点
1. **问题转化**：将路径上的线性函数插入转化为李超线段树维护。关键是将路径拆分为上链和下链，分别对应两种一次函数形式：
   - 上链：`y = -a*dis[i] + (a*dis[s] + b)`
   - 下链：`y = a*dis[i] + a*(dis[s] - 2*dis[lca]) + b`

2. **树剖作用**：将树路径转化为连续区间，使得李超线段树能在线性序列上维护。

3. **李超线段树优化**：
   - **标记永久化**：避免递归下传标记，提升效率
   - **最小值维护**：每个节点额外记录区间最小值，避免全树遍历

### 可视化设计
1. **像素动画流程**：
   - **树结构展示**：用像素网格绘制树形结构，不同颜色区分重链
   - **路径拆分**：高亮显示LCA点，用闪烁箭头表示上下链拆分
   - **线段树操作**：以8-bit风格展示线段树节点插入过程，当前操作的节点用绿色边框高亮
   - **最小值查询**：路径覆盖的线段树区间用红色渐变填充，实时显示当前最小值

2. **音效设计**：
   - 插入线段时播放短促的"滴"声
   - 查询最小值时播放上升音阶
   - 错误操作（如空树查询）播放低音警报

3. **自动演示模式**：
   - 模拟AI解题过程：自动执行树剖→路径拆分→线段插入→最小值查询的完整流程
   - 可暂停观察中间状态，支持步进控制（方向键控制）

---

## 题解清单（≥4星）

1. **disangan233（5星）**
   - **亮点**：最简洁的标记永久化实现，核心代码仅30行；利用树剖的`bel[]`数组直接映射原树节点
   - **关键代码**：
     ```cpp
     void update(re nl,re nr,re p,re l,re r,re x) {
         if(nl<=l&&r<=nr) {
             // 标记永久化更新逻辑
             return mn[p]=min(mn[p],min(cal(l,x),cal(r,x))), push_up(p);
         }
         // 递归更新子树
     }
     ```

2. **SovietPower✨（4.5星）**
   - **亮点**：详细推导函数转换过程，注释清晰；线段树维护`Lx/Rx`记录区间端点实际dis值
   - **个人心得**："注意线段树里的下标都是代表DFS序中的dis[i]，这保证了同链单调性"

3. **spider_oyster（4星）**
   - **亮点**：最短完整实现（<100行），采用非递归式树剖；引入`rev[]`数组优化原树映射
   - **优化点**：将李超树的`calc`函数内联，减少函数调用开销

---

## 最优思路与代码实现

### 核心代码（disangan233版）
```cpp
// 李超线段树更新逻辑
inline ll cal(re x,re id) {return k[id]*dis[bel[x]]+b[id];}

void update(re nl,re nr,re p,re l,re r,re x) {
    re mid=(l+r)>>1;
    if(nl<=l&&r<=nr) {
        if(cal(l,x)<=cal(l,t[p]) && cal(r,x)<=cal(r,t[p])) {
            t[p]=x; // 直接替换更优线段
            mn[p]=min(mn[p],min(cal(l,x),cal(r,x)));
            return;
        }
        // 判断交点位置选择递归子树
        if(k[x]<k[t[p]]) {
            if(cal(mid,x)<=cal(mid,t[p])) 
                update(nl,nr,ls(p),l,mid,t[p]),t[p]=x;
            else update(nl,nr,rs(p),mid+1,r,x);
        } else {
            if(cal(mid,x)<=cal(mid,t[p]))
                update(nl,nr,rs(p),mid+1,r,t[p]),t[p]=x;
            else update(nl,nr,ls(p),l,mid,x);
        }
        mn[p]=min(mn[p],min(cal(l,x),cal(r,x)));
        push_up(p);
        return;
    }
    // 常规区间更新
    if(nl<=mid) update(nl,nr,ls(p),l,mid,x);
    if(nr>mid) update(nl,nr,rs(p),mid+1,r,x);
    push_up(p);
}
```

### 实现思想
1. **标记永久化**：节点保存当前最优线段，不下传标记
2. **动态比较**：在区间中点比较新旧线段，决定递归方向
3. **最小值维护**：每个节点记录区间最小值，合并子树结果

---

## 相似题目推荐
1. [P4097 Segment]（李超线段树基础）
2. [P3384 树链剖分]（树剖模板题）
3. [CF1178G The Awesomest Vertex]（树上线性函数最值）

---

## 可视化代码片段（Canvas动画）
```javascript
// 绘制树链剖分过程
function drawChain(u, v, lca) {
    ctx.strokeStyle = '#FF5555'; // 红色表示当前操作路径
    while(top[u] != top[lca]) {
        drawPath(u, top[u]); 
        u = fa[top[u]];
    }
    drawPath(u, lca);
    // 类似绘制v到lca部分...
}

// 李超线段树插入动画
function animateInsert(l, r, line) {
    let node = 1, cl = 1, cr = n;
    while(true) {
        drawHighlight(node); // 高亮当前节点
        let mid = (cl + cr) >> 1;
        if(l <= cl && cr <= r) {
            compareLines(node, line); // 比较线段交点的动画
            break;
        }
        if(r <= mid) { node = node*2; cr = mid; }
        else { node = node*2+1; cl = mid+1; }
    }
}
```

---

## 调试心得
- **RE问题**：初始未考虑线段树四倍空间，导致越界。改为动态开点后解决
- **精度问题**：直接比较浮点交点导致错误，改用乘法移项避免除法
- **树剖映射**：忘记`dfn[]`和原节点对应，通过添加`bel[]`数组修复

---

## 复古像素风格设计
1. **调色板**：使用NES经典6色调色板（红、蓝、绿、黄、紫、黑）
2. **树节点**：用8x8像素方块表示，重链节点边框加粗
3. **线段树动画**：以《俄罗斯方块》式下落效果展示线段插入过程
4. **音效**：
   - 插入成功：FC《超级马里奥》金币音效（0x3A0-0x3C0）
   - 查询完成：FC《塞尔达》解谜成功音效（脉冲波+噪声通道混合）

---
处理用时：89.96秒
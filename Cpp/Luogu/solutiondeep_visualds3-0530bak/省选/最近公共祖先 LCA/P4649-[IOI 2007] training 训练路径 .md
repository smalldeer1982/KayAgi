# 题目信息

# [IOI 2007] training 训练路径 

## 题目描述

马克(Mirko)和斯拉夫克(Slavko)正在为克罗地亚举办的每年一次的双人骑车马拉松赛而紧张训练。他们需要选择一条训练路径。

他们国家有$N$个城市和$M$条道路。每条道路连接两个城市。这些道路中恰好有$N-1$条是铺设好的道路，其余道路是未经铺设的土路。幸运的是，每两个城市之间都存在一条由铺设好的道路组成的通路。换句话说，这$N$个城市和$N-1$条铺设好的道路构成一个树状结构。

此外，每个城市最多是$10$条道路的端点。

一条训练路径由某个城市开始，途经一些道路后在原来起始的城市结束。因为马克和斯拉夫克喜欢去看新城市，所以他们制定了一条规则：绝不中途穿越已经去过的城市，并且绝不在相同的道路上骑行两次（不管方向是否相同）。训练路径可以从任何一个城市开始，并且不需要访问所有城市。

显然，坐在后座的骑行者更为轻松，因为坐在前面的可以为他挡风。为此，马克和斯拉夫克在每个城市都要调换位置。为了保证他们的训练强度相同，他们要选择一条具有偶数条道路的路径。

马克和斯拉夫克的竞争者决定在某些未经铺设的土路上设置路障，使得他们两人不可能找到满足上述要求的训练路径。已知在每条土路上设置路障都有一个费用值（一个正整数），并且竞争者不能在铺设好的道路上设置路障。

给定城市和道路网的描述，写一个程序计算出为了使得满足上述要求的训练路径不存在，而需要的设置路障的最小总费用。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/20676.png )

第一个样例中道路与城市的布置。已被铺设好的道路以粗边显示。

![](https://cdn.luogu.com.cn/upload/pic/20677.png )

共有5种可能的路线。如果边1-3、3-5和2-5被封锁，则两人将会不能使用5种路线的任何一种。封锁这三条边的代价是5。

只封锁两条边，像是2-4和2-5，也是可以的，但这样会导致较高的代价，6。

在前30分的测试数据中，铺设好的道路会形成一条链。

## 样例 #1

### 输入

```
5 8 
2 1 0 
3 2 0 
4 3 0 
5 4 0 
1 3 2 
3 5 2 
2 4 5 
2 5 1 ```

### 输出

```
5```

## 样例 #2

### 输入

```
9 14 
1 2 0 
1 3 0 
2 3 14 
2 6 15 
3 4 0 
3 5 0 
3 6 12 
3 7 13 
4 6 10 
5 6 0 
5 7 0 
5 8 0 
6 9 11 
8 9 0 ```

### 输出

```
48```

# AI分析结果



### 唯一算法分类
**树形DP + 状态压缩**

---

### 综合分析与结论
#### 核心思路与难点
1. **问题转化**：将删除边的最小代价转化为保留边的最大权值和，需满足保留边构成的环均为奇环且互不相交。
2. **偶环判定**：非树边若连接两点树上距离为奇数，则直接构成偶环必须删除。
3. **仙人掌结构**：合法保留边构成的图需满足每条边至多属于一个简单环（类似仙人掌图）。
4. **树形DP设计**：
   - **状态定义**：`f[u][S]` 表示以 `u` 为根的子树中，不选子节点集合 `S` 时的最大权值。
   - **状态转移**：在 LCA 处处理非树边，沿路径合并贡献，排除冲突子节点（状压实现）。

#### 可视化设计思路
1. **树结构动画**：
   - **节点高亮**：当前处理的 LCA 节点标记为红色，路径上的节点渐变色标记。
   - **状态变化**：用二进制位图显示 `S` 的排除子节点状态（如绿色表示未排除，红色表示排除）。
   - **路径贡献**：动态绘制非树边路径，逐层向上累加贡献时显示数值变化。
2. **复古像素风格**：
   - 树节点显示为 16x16 像素方块，边显示为像素线。
   - 每次 DP 转移时播放 8-bit 音效，选中边时播放“金币收集”音效。
3. **AI自动演示**：
   - 自动遍历所有非树边，逐步展示路径合并和状态更新流程。
   - 可切换手动模式，单步调试关键状态转移（如选择/不选某条边）。

---

### 题解清单（≥4星）
1. **XG_Zepto（5星）**  
   - **亮点**：代码结构清晰，注释完整；动态规划状态转移逻辑明确，通过预处理 LCA 和贡献计算实现高效 DP。
   - **关键代码**：`f[u][S]` 的初始化和转移逻辑简洁，通过 `rid[a]` 和 `rid[b]` 快速定位冲突子节点。
   - **个人心得**：在博客中提到“仙人掌结构”的转化是解题关键。

2. **FOX_konata（4星）**  
   - **亮点**：详细证明了奇环交集性质，提供链状分治的 30 分思路，代码中通过预排序状态优化枚举顺序。
   - **关键代码**：`ckmax(dp[u][S], ...)` 的转移逻辑与 `val` 计算方式清晰。

3. **DaiRuiChen007（4星）**  
   - **亮点**：代码高度精简，用 `vector` 存储非树边，通过 `LCA` 预处理和 `bit` 快速生成状态。
   - **关键代码**：`dp[p][s]` 的转移逻辑与 `val` 计算逻辑简洁。

---

### 最优思路提炼
#### 关键算法步骤
1. **预处理 LCA**：所有非树边在 LCA 处统一处理。
2. **贡献计算**：沿路径累加每个节点的 `dp[fa(x), {x}]`。
3. **状压排除冲突**：用二进制位标记子节点是否被排除。

#### 核心代码实现
```cpp
// XG_Zepto 题解核心代码（简化）
void Solve(int u) {
    // 初始化子树贡献
    for (int S=0; S < (1<<son_cnt); S++) 
        f[u][S] = sum_child_not_in_S;
    
    // 处理每条非树边
    for (auto edge : B[u]) {
        int val = edge.w, a = u_child, b = v_child;
        val += f[a][0] + f[b][0];
        // 沿路径累加贡献
        while (fa[a] != u) val += f[fa(a)][rid[a]], a = fa(a);
        while (fa(b) != u) val += f[fa(b)][rid[b]], b = fa(b);
        
        // 状压转移
        for (int S : valid_states) 
            f[u][S] = max(f[u][S], f[u][S|mask] + val);
    }
}
```

---

### 相似题目推荐
1. **P2014 [CTSC1997] 选课**（树形DP + 依赖背包）
2. **P3959 [NOIP2017] 宝藏**（状压DP + 树形扩展）
3. **P5021 [NOIP2018] 赛道修建**（树形DP + 二分答案）

---

### 可视化代码片段（Canvas + 音效）
```javascript
// 伪代码：绘制树形结构
function drawTree(ctx, root) {
    ctx.fillStyle = '#8B0000'; // 复古红
    ctx.fillRect(root.x, root.y, 16, 16); // 16x16 像素节点
    for (let child of root.children) {
        ctx.beginPath();
        ctx.moveTo(root.x+8, root.y+8); // 中心点连线
        ctx.lineTo(child.x+8, child.y+8);
        ctx.strokeStyle = '#696969'; // 深灰
        ctx.stroke();
    }
}

// 音效触发：选中边时播放
function playCoinSound() {
    const osc = new OscillatorNode(ctx, { frequency: 880 });
    osc.connect(ctx.destination);
    osc.start(); osc.stop(ctx.currentTime + 0.1);
}
```

---

### 个人心得摘录
- **XG_Zepto**：在调试中发现必须将非树边挂在 LCA 处处理，否则会重复计算路径贡献。
- **FOX_konata**：通过预排序状态集合（按 1 的个数降序）优化了 DP 的更新顺序，避免覆盖问题。

---
处理用时：80.59秒
# 题目信息

# 『MdOI R1』Treequery

## 题目描述

给定一棵 $n$ 个点的无根树，边有边权。

令 $E(x,y)$ 表示树上 $x,y$ 之间的简单路径上的所有边的集合，特别地，当 $x=y$ 时，$E(x,y) = \varnothing$。

你需要 **实时** 回答 $q$ 个询问，每个询问给定 $p,l,r$，请你求出集合 $\bigcap_{i=l}^r E(p,i)$ 中所有边的边权和，即 $E(p, l\dots r)$ 的交所包含的边的边权和。

通俗的讲，你需要求出 $p$ 到 $[l,r]$ 内每一个点的简单路径的公共部分长度。



## 说明/提示

【样例 1 说明】

样例中的树如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/g6l15zpv.png)

下面解释中的询问参数均为异或 $lastans$ 之后得到的真实值。

对于第一个询问，$p=2$，$l=3$，$r=5$，$\bigcap_{i=3}^5 E(2,i)$ 为边 $(2,3)$，长度为 $3$。

对于第二个询问，$p=1$，$l=2$，$r=4$，$\bigcap_{i=2}^4 E(1,i)$ 为边 $(1,3)$，长度为 $2$；

对于第三个询问，$p=2$，$l=5$，$r=5$，$\bigcap_{i=5}^5 E(2,i)$ 为边集 $\{(2,3),(3,1),(1,5)\}$，长度为 $6$；

对于第四个询问，$p=3$，$l=3$，$r=4$，$\bigcap_{i=3}^4 E(3,i)=\varnothing$，长度为 $0$。


---

【数据范围】

**本题采用捆绑测试。**

| 子任务编号 |   $n,q\leq$    | 特殊性质 | 分值 |
| :--------: | :------------: | :------: | :--: |
|     1      |     $10^5$     |  $l=r$   |  8   |
|     2      |     $10^5$     |  $p=1$   |  20  |
|     3      |     $10^3$     |    无    |  20  |
|     4      |     $10^5$     |    无    |  26  |
|     5      | $2\times 10^5$ |    无    |  26  |

对于 $100\%$ 的数据，$1\leq n,q\leq 2\times 10^5$，$1\leq x,y,p\leq n$，$1\leq l\leq r\leq n$，$1\leq w\leq 10^4$。

## 样例 #1

### 输入

```
5 4
3 1 2
1 5 1
2 3 3
3 4 4
2 3 5
2 1 7
0 7 7
5 5 2```

### 输出

```
3
2
6
0```

## 样例 #2

### 输入

```
10 10
2 1 9907
3 2 8329
4 2 8402
5 4 3636
6 4 8747
7 4 3080
8 6 780
9 6 5414
10 9 3545
2 10 10
26107 26106 26101
4 9 10
14171 14166 14169
8958 8949 8949
36008 36014 36013
11485 11485 11472
3 9 9
30888 30894 30895
8404 8404 8411
```

### 输出

```
26108
0
14161
8959
36015
11482
0
30892
8402
0
```

# AI分析结果



---

**唯一算法分类**: LCA、主席树、区间查询

---

### 综合分析与结论

**核心思路**:  
所有题解的核心在于通过预处理维护区间内点的分布情况，结合 LCA 和分类讨论确定公共路径。关键步骤包括：
1. 利用主席树维护 DFS 序，判断区间点是否在子树内
2. 计算区间点的 LCA，结合其与 p 的祖先关系分类
3. 对子树内外情况分别处理，确定路径交集的边界点

**算法流程**：
1. **预处理**：建立 DFS 序、倍增 LCA、主席树维护点分布
2. **分类讨论**：
   - 若所有点在 p 子树内 → 取区间 LCA 到 p 的路径
   - 若同时存在子树内外点 → 答案为 0
   - 若所有点都在子树外 → 找最近公共祖先计算路径
3. **关键操作**：
   - 主席树查询区间极值（最小/大 DFS 序点）
   - 倍增法快速定位最深公共祖先

**可视化设计**：
- **动画步骤**：
  1. 高亮 p 节点和查询区间 [l, r]
  2. 用不同颜色标记子树内外的点
  3. 动态绘制路径交集（红色线段）
  4. 展示 LCA 计算过程和祖先跳跃路径
- **交互功能**：
  - 步进按钮观察主席树查询过程
  - 拖拽调节树结构后实时重新计算路径

---

### 题解清单（≥4星）

1. **Owen_codeisking（★★★★☆）**  
   - 亮点：主席树维护极值点，分类情况清晰  
   - 代码实现简洁，利用 DFS 序特性快速定位区间点

2. **Thinking（★★★★☆）**  
   - 亮点：结合树链剖分处理区间 LCA，逻辑分层明确  
   - 通过线段树合并优化子树存在性判断

3. **command_block（★★★★☆）**  
   - 亮点：使用欧拉序+ST表维护 LCA，代码复用率高  
   - 通过前驱后继查询优化路径判断

---

### 关键代码片段（Owen_codeisking）

```cpp
int solve(int x,int l,int r) {
    int sum=query_sum(rt[l-1],rt[r],1,n,st[x],ed[x]);
    if(sum>0 && sum<r-l+1) return 0;
    int a=solve1(x,l,r),b=solve2(x,l,r);
    if(sum==r-l+1) return dis[LCA(a,b)]-dis[x];
    int c=LCA(a,x),d=LCA(b,x);
    if(c==d) return dis[LCA(a,b)]+dis[x]-2*dis[c];
    return dis[x]-((dep[c]>dep[d])?dis[c]:dis[d]);
}
```

**核心逻辑**：
1. 查询子树内点数量判断是否混合分布
2. 通过主席树获取区间极值点（最小/大 DFS 序）
3. 根据 LCA 的深度关系确定最终路径长度

---

### 同类型题目推荐

1. **P3379 【模板】最近公共祖先（LCA）**  
   （基础 LCA 应用，掌握倍增/树剖实现）

2. P3302 [SDOI2013] 森林  
   （动态树 LCA 维护，结合主席树处理子树查询）

3. P4211 [LNOI2014] LCA  
   （区间 LCA 深度统计，离线处理技巧）

---

### 可视化方案（复古像素风格）

**实现要点**：
1. **树结构绘制**：  
   - 使用 Canvas 绘制 8-bit 风格树节点（16x16 像素方块）
   - 边权显示为黄色数字，LCA 节点用闪烁红框标记

2. **查询演示**：  
   ```javascript
   function animateQuery(p, l, r) {
       highlightNodes(p, 0xFF0000); // 红色标记p
       for(let i=l; i<=r; i++) {
           flashNode(i, 0x00FF00); // 绿色闪烁区间点
           drawPath(p, i); // 绘制临时路径
       }
       showLCAPath(); // 红色显示最终交集路径
   }
   ```

3. **音效设计**：  
   - 路径更新时播放 "beep" 音效（Web Audio API）
   - 找到 LCA 时播放胜利音效

**交互功能**：
- 方向键控制查询区间滑动
- A/B 键切换不同解法动画模式

---

### 总结

本题解通过巧妙的 DFS 序维护和 LCA 分类，将复杂路径交问题转化为可高效处理的数据结构查询。理解主席树维护极值点的思路是解题关键，配合复古风格可视化能直观展示算法核心流程。推荐通过实现简易版代码加深对极值点查询和 LCA 关系的理解。

---
处理用时：66.75秒
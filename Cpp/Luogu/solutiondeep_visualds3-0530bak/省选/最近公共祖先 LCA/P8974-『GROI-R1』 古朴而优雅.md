# 题目信息

# 『GROI-R1』 古朴而优雅

## 题目背景


会馆内忽地安静了下来。

「敝姓言，名杉。」

他的声音沉稳而凝重，略带沙哑，却不失力度，极具穿透力。每个字都重重地打在耳畔，渗进头脑里，让人想不认真听都难。

「这所学院的院长。」

## 题目描述

杉虽然年事已高，但是还是保持与时俱进。他学习了深度优先遍历算法，觉得这种新潮的东西在一所古朴而优雅的学院里会很受欢迎。所以，他找到了在走廊里晃荡的寒，向他提出了一个问题：

「我们知道，对一棵树进行深度优先遍历可以用下面的伪代码很好地解决。」

$$
\begin{array}{l}
\text{DFS-TREE}(u)\\
\begin{array}{ll}
1 & p\gets p+1\\
2 & t_p\gets u\\
3 & vis_u\gets 1\\
4 & \textbf{for }\text{each edge }(u,v)\in E \\
5 & \qquad \textbf{if }vis_v=0\\
6 & \qquad \qquad \text{DFS-TREE}(v)\\
7 & p\gets p+1\\
8 & t_p\gets u\\
\end{array}
\end{array}
$$

起初，所有变量或数组的值均为 $0$。

「我们把调用 $\text{DFS-TREE}(1)$ 在遍历过程中得到的数组 $t$ 称为这棵树的**遍历顺序**。」

「你看这段代码的第 $4$ 行，这句话**遍历每一条边的顺序是不固定的**。」

寒素来最讨厌不确定的东西，可是碍于院长的颜面，还是继续听下去。

「你能数出这段代码**会生成多少种不同的遍历顺序**吗？」

寒发现他曾经做过这个题，很快地报出了解法。本以为就结束了，可是杉继续说：

「如果我**在树上增加一条边**，你还会做吗？」

寒发现他的那点水平完全不够了，于是他去请教玘。玘却认为这道题目依然很简单，他告诉了寒这道题的做法。可是寒找不到杉了。

这个世界到底怎么了呢？

## 说明/提示

**样例解释**

对于第一次询问可以得到如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ojeiswc8.png)

能得到的遍历顺序有：

- $\{1,2,3,3,2,4,4,1\}$
- $\{1,4,4,2,3,3,2,1\}$
- $\{1,3,2,2,3,4,4,1\}$
- $\{1,4,4,3,2,2,3,1\}$

对于第二次询问可以得到如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6dut5s4r.png)

能得到的遍历顺序有：

- $\{1,2,2,3,3,4,4,1\}$
- $\{1,2,2,4,4,3,3,1\}$
- $\{1,3,3,2,2,4,4,1\}$
- $\{1,3,3,4,4,2,2,1\}$
- $\{1,4,4,2,2,3,3,1\}$
- $\{1,4,4,3,3,2,2,1\}$

**数据范围**

**本题采用捆绑测试。**

| 测试点编号 | 数据范围 | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $\text{Subtask1}$ | $n,q\le8$ |  | $5$ |
| $\text{Subtask2}$ | $n,q\le20$ |  | $10$ |
| $\text{Subtask3}$ | $n,q\le500$ |  | $10$ |
| $\text{Subtask4}$ | $n,q\le3000$ |  | $15$ |
| $\text{Subtask5}$ | $n,q\le2\times10^5$ | $\text{A}$ | $15$ |
| $\text{Subtask6}$ | $n,q\le2\times10^5$ | $\text{B}$ | $10$ |
| $\text{Subtask7}$ | $n,q\le2\times10^5$ |  | $35$ |

特殊性质 $\text{A}$：保证每一次询问的边 $(x,y)\in E$。

特殊性质 $\text{B}$：保证树退化成一条链。

对于 $100\%$ 的数据保证 $1\le n,q\le2\times10^5$，$1\le u,v,x,y\le n$，$x\ne y$。

## 样例 #1

### 输入

```
4 2
1 2
1 3
1 4
2 3
1 4```

### 输出

```
4
6```

# AI分析结果



---

### 唯一算法分类  
**基环树与动态维护**

---

### 题解思路与解决难点  

#### **核心思路**  
1. **基础树遍历方案**：初始树的遍历方案数为 $\prod_u \text{deg}_u!$，其中 $\text{deg}_u$ 为节点 $u$ 的子节点数。  
2. **基环树特性**：添加边 $(x,y)$ 后形成环，未被遍历的边必须在环上且为环上 LCA 的两条相邻边。  
3. **动态维护贡献**：每次询问仅需处理 4 个节点的度数变化，通过阶乘逆元快速计算新贡献。

#### **关键实现**  
- **LCA 预处理**：倍增法预处理 LCA，用于确定环的结构。  
- **度数维护**：动态调整删除/添加边后节点的度数，利用阶乘和逆元快速计算乘积变化。  
- **贡献分离**：基环树的遍历方案为删除两条可能的边后的方案之和。

---

### 题解评分 (≥4星)  
**TernaryTree 题解**（⭐⭐⭐⭐）  
- **亮点**：  
  - 详细推导 8 个结论，逻辑严密。  
  - 代码结构清晰，预处理阶乘、逆元、LCA 分离明确。  
  - 核心函数 `getans` 高效处理度数变化。  

---

### 最优思路与技巧  
1. **动态维护乘积**：仅修改 4 个节点的度数，利用逆元快速更新总乘积。  
2. **环边定位**：通过 LCA 确定环上两条候选边，避免全树遍历。  
3. **阶乘预处理**：提前计算阶乘及其逆元，将复杂度优化至 $O(1)$ 单次查询。

---

### 相似题型与算法  
- **同类型题**：树的动态修改（如删边/加边）后维护组合数性质。  
- **通用套路**：  
  - 预处理阶乘和逆元处理乘积型问题。  
  - 倍增法求 LCA 处理树结构问题。  

---

### 推荐题目  
1. **P2146 [NOI2015] 软件包管理器**（动态维护子树大小）  
2. **P4219 [BJOI2014] 大融合**（维护树的连通性）  
3. **P3384 【模板】树链剖分**（LCA 与路径处理）

---

### 可视化设计  
#### **核心逻辑动画**  
1. **树结构绘制**：Canvas 绘制树形结构，节点按层次排列。  
2. **环高亮显示**：添加边 $(x,y)$ 后，用红色线条标出环路径，绿色标出候选边。  
3. **度数动态更新**：  
   - **颜色标记**：被修改度数的节点闪烁黄色。  
   - **数值变化**：实时显示度数变化和阶乘乘积更新。  

#### **复古像素风格**  
- **UI 设计**：  
  - 节点用 16x16 像素方块表示，边用单色线条连接。  
  - 音效：遍历时播放“滴”声，计算成功时播放 8-bit 胜利音效。  
- **自动演示**：  
  - **AI 模式**：自动执行 LCA 计算、度数更新、方案求和。  
  - **关卡设计**：分步演示“基础树→加边→计算候选边→输出结果”。

---

### 核心代码片段  
```cpp
// 预处理阶乘和逆元
void init() {
    fac[0] = 1;
    for (int i = 1; i < maxn; i++) fac[i] = fac[i - 1] * i % mod;
    inv[maxn - 1] = power(fac[maxn - 1], mod - 2, mod);
    for (int i = maxn - 2; ~i; i--) inv[i] = inv[i + 1] * (i + 1) % mod;
}

// 动态计算删除两条边后的贡献
int getans(int u, int v, int x, int y) {
    int cur = ful * inv[deg[u]] % mod * inv[deg[v]] % mod * inv[deg[x]] % mod * inv[deg[y]] % mod;
    deg[u]--, deg[v]--, deg[x]++, deg[y]++;
    cur = cur * fac[deg[u]] % mod * fac[deg[v]] % mod * fac[deg[x]] % mod * fac[deg[y]] % mod;
    deg[u]++, deg[v]++, deg[x]--, deg[y]--;
    return cur;
}
```

---

### 个人心得摘录  
- **调试教训**：初始代码未处理根节点度数特殊减一（`deg[u] - (u != 1)`），导致贡献计算错误。  
- **优化技巧**：将 LCA 和度数修改分离，避免在每次查询时重新计算整树结构。  

---

### 总结  
通过预处理和动态维护，将看似复杂的基环树问题转化为树形结构上的局部修改问题，极大优化了时间复杂度。核心在于快速定位环边和高效维护组合数乘积。

---
处理用时：50.57秒
# 题目信息

# [NOIP 2003 提高组] 神经网络

## 题目背景

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。



## 题目描述

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)

神经元（编号为 $i$）


图中，$X_1 \sim X_3$ 是信息输入渠道，$Y_1 \sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)

兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）

$$C_i=\left(\sum\limits_{(j,i) \in E} W_{ji}C_{j}\right)-U_{i}$$

公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。



## 说明/提示

**【题目来源】**

NOIP 2003 提高组第一题

## 样例 #1

### 输入

```
5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
```

### 输出

```
3 1
4 1
5 1
```

# AI分析结果



# [NOIP 2003 提高组] 神经网络题解分析

## 唯一算法分类
拓扑排序

## 综合分析与结论
### 核心算法流程
1. **拓扑排序驱动信号传递**：  
   - 输入层节点（入度为0且C>0）作为初始激活节点入队  
   - 使用队列维护激活节点，按拓扑序处理神经元状态  
   - 每次从队列取出节点u，若其C>0则传播信号到所有邻接节点v：  
     ```math
     C_v += W_uv * C_u
     ```
   - 若v首次被激活（状态变为正数），则将其加入队列  

2. **阈值处理技巧**：  
   - 非输入层节点在初始化时直接扣除阈值：`C_i -= U_i`  
   - 输入层节点保持原值（阈值不扣除）

3. **输出层判定**：  
   - 出度为0的节点作为输出层  
   - 最终只输出C>0的输出层节点  

### 可视化设计要点
```javascript
// 伪代码示例：拓扑排序信号传播动画
function visualize() {
  // 初始化阶段
  1. 绘制分层网络图，输入层标记为绿色
  2. 初始激活节点闪烁后入队，队列区动态展示排队节点

  // 处理阶段
  while (!queue.isEmpty()) {
    3. 高亮当前处理节点u（红色边框）
    4. 若C_u >0，显示信号传播动画（粒子流向邻接节点）
    5. 更新邻接节点v的C值，若变正则触发"激活闪光"特效
    6. v节点入队时播放8-bit音效（类似马里奥金币声）
  }

  // 结果阶段
  7. 输出层节点中C>0的显示金色边框，其余灰色
}
```

## 题解清单 (≥4星)
### 1. Lucaster_（五星）
- **核心亮点**：  
  ① 拓扑排序实现简洁，用队列管理激活节点  
  ② 提前处理阈值减少运行时判断  
  ③ 使用`out[]`数组快速判断输出层  
- **关键代码**：
  ```cpp
  while (!q.empty()) {
    h = q.front(); q.pop();
    if (c[h] <= 0) continue;
    for (遍历邻接节点) {
      c[t] += w * c[h];
      if (!vis[t]) q.push(t);
    }
  }
  ```

### 2. zzlzk（四星）
- **核心亮点**：  
  ① 反向建图实现记忆化搜索  
  ② 递归计算保证依赖顺序  
- **关键思路**：
  ```cpp
  int DFS(int p) {
    if (是输入层) return c[p];
    递归计算所有前驱节点的贡献
    c[p] = sum(前驱贡献) - U[p];
  }
  ```

### 3. faker121（四星）
- **核心亮点**：  
  ① 显式记录层数实现分层处理  
  ② 使用二维数组存储每层节点  
- **关键片段**：
  ```cpp
  for (按层遍历) {
    for (当前层节点) {
      if (非输入层) c[i] -= U[i];
      if (c[i]>0) 传播信号到下层
    }
  }
  ```

## 同类型题推荐
1. **P1983 车站分级**（拓扑排序处理层级关系）  
2. **P4017 最大食物链计数**（DAG拓扑排序+路径统计）  
3. **P2741 [USACO4.4] 重叠的图像**（拓扑排序解决依赖关系）

## 个人心得摘录
- **Lucaster_**：  
  > "拓扑排序不一定都要用入度的，某些特定情况下可以用队列直接实现。输入时预处理阈值让我少踩很多坑。"  
- **faker121**：  
  > "调试时发现输入层可能同时是输出层，若不特判会WA第五个点。拓扑排序结束后需要重新扫描所有节点判断输出层。"  

## 核心代码实现（Lucaster_优化版）
```cpp
#include<queue>
#include<cstdio>
#define N 105
using namespace std;

struct edge { int to, w, nxt; } e[N*N];
int hd[N], c[N], out[N], vis[N];
queue<int> q;

int main() {
    scanf("%d%d", &n, &m);
    for (int i=1; i<=n; ++i) {
        scanf("%d%d", &c[i], &u);
        if (c[i]) q.push(i), vis[i]=1;
        else c[i] -= u; // 阈值预处理
    }
    
    while (m--) {
        scanf("%d%d%d", &u, &v, &w);
        e[++cnt] = {v, w, hd[u]};
        hd[u] = cnt; out[u] = 1; // 标记出度
    }

    while (!q.empty()) {
        int u = q.front(); q.pop();
        if (c[u] <= 0) continue;
        for (int i=hd[u]; i; i=e[i].nxt) {
            int v = e[i].to;
            c[v] += e[i].w * c[u];
            if (!vis[v]) q.push(v), vis[v]=1;
        }
    }

    bool flag = 0;
    for (int i=1; i<=n; ++i)
        if (!out[i] && c[i] > 0) 
            printf("%d %d\n", i, c[i]), flag=1;
    if (!flag) puts("NULL");
}
```

## 复古像素风可视化方案
1. **视觉设计**：  
   - 神经元节点：8x8像素方块，激活时变黄，平静时灰色  
   - 信号传播：绿色像素点沿边流动  
   - 队列区：右侧16x16像素区域动态显示排队节点编号  

2. **音效设计**：  
   - 节点激活：FC风格"叮"声（三角波，440Hz，0.1s）  
   - 信号传递：短促"哔"声（方波，220Hz，0.05s）  
   - 输出结果：胜利音效（三连音程）  

3. **自动演示模式**：  
   ```javascript
   function autoRun() {
     let speed = 1000; // 每步间隔(ms)
     let timer = setInterval(() => {
       if (queue.empty()) {
         showResult();
         clearInterval(timer);
       } else {
         processStep();
       }
     }, speed);
   }
   ```

---
处理用时：73.25秒
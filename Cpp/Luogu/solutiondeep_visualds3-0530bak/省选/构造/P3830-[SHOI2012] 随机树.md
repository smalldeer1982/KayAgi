# 题目信息

# [SHOI2012] 随机树

## 题目背景

SHOI2012 D1T3


## 题目描述

一棵含 $n$ 个叶结点的二叉树可以通过如下方式生成。初始时只有根结点。首先，将根结点展开（本题中的“展开”是指给一个叶结点添上左、右两个子结点）：

[a]

然后，等概率地随机将两个叶结点中的一个展开，即生成以下两棵树之一：

[b]

之后，每次在当前二叉树的所有叶结点中，等概率地随机选择一个，将其展开。

不断地重复这一操作，直至产生 $n$ 个叶结点为止。例如，某棵含 5 个叶结点的二叉树可能按如下步骤生成。

[c]

对于按该方式随机生成的一棵含 $n$ 个叶结点的二叉树，求：

1. **叶结点平均深度** 的数学期望值。
2. **树深度** 的数学期望值。约定根结点的深度为 0。

![](https://cdn.luogu.com.cn/upload/image_hosting/7ql5uhxn.png)

## 说明/提示

### 【样例1、样例2说明】
数学期望值是随机变量的值乘以其概率的总和：记随机变量 $X$ 可能的取值为 $x_1,x_2,\cdots,x_n$，它们取到的概率分别为 $p_1,p_2,\cdots,p_n$，那么随机变量 $X$ 的数学期望值就是

$E(X)=\sum_{i = 1}^{n}p_ix_i$

例如，掷一枚写有 1、2、3、4、5、6 这 6 个数的均匀骰子，掷到的数的数学期望值是：

$E=\frac{1}{6}\times1+\frac{1}{6}\times2+\frac{1}{6}\times3+\frac{1}{6}\times4+\frac{1}{6}\times5+\frac{1}{6}\times6 = 3.5$

尽管 3.5 不是骰子上的某个数。又如，一道 4 选 1 的选择题，答对得 5 分，不答不得分，答错倒扣 1 分。那么，当我们不答时，一定得 0 分；而等概率地随便猜一个时，得分的数学期望值是：

本题中，根据二叉树的生成方式，当 $n = 4$ 时，下图中前四棵树被生成的概率均为 $1/6$，最后一棵树被生成的概率为 $1/3$。它们的叶结点平均深度分别是 $9/4$、$9/4$、$9/4$、2，因此叶结点平均深度的数学期望值是

$E=\frac{1}{6}\times\frac{9}{4}+\frac{1}{6}\times\frac{9}{4}+\frac{1}{6}\times\frac{9}{4}+\frac{1}{6}\times\frac{9}{4}+\frac{1}{3}\times2=\frac{13}{6}$

而它们的树深度分别是 3、3、3、3、2，因此树深度的数学期望值是

$E=\frac{1}{6}\times3+\frac{1}{6}\times3+\frac{1}{6}\times3+\frac{1}{6}\times3+\frac{1}{3}\times2=\frac{8}{3}$

### 【数据规模】
| 测试数据编号 | $q$ | $n$ |
| ---- | ---- | ---- |
| 1,2 | $q = 1$ | $2\leq n\leq10$ |
| 3,4,5 | $q = 1$ | $2\leq n\leq100$ |
| 6,7 | $q = 2$ | $2\leq n\leq10$ |
| 8,9,10 | $q = 2$ | $2\leq n\leq100$ | 

![](https://cdn.luogu.com.cn/upload/pic/6556.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/6557.png) 

![](https://cdn.luogu.com.cn/upload/pic/6558.png)


## 样例 #1

### 输入

```
1 4```

### 输出

```
2.166667```

## 样例 #2

### 输入

```
2 4```

### 输出

```
2.666667```

## 样例 #3

### 输入

```
1 12```

### 输出

```
4.206421```

## 样例 #4

### 输入

```
2 12```

### 输出

```
5.916614```

# AI分析结果



## 算法分类
概率与期望、动态规划

---

## 题解思路与核心难点

### 第一问（叶结点平均深度）
**核心思路**：  
每次扩展叶子节点时，原有深度为d的叶子被替换为两个深度d+1的叶子。总深度增加量为 (d+1)*2 - d = d+2。通过递推公式推导出期望值的增量关系：

$$
f[i] = f[i-1] + \frac{2}{i}
$$

**实现要点**：  
- 初始化f[1] = 0  
- 循环计算累加增量，时间复杂度O(n)

### 第二问（树深度期望）
**核心思路**：  
利用概率DP，定义状态f[i][j]表示i个叶子的树深度≥j的概率。通过枚举左右子树划分k和i-k，计算深度条件概率：

$$
f[i][j] = \sum_{k=1}^{i-1} \frac{f[k][j-1] + f[i-k][j-1] - f[k][j-1] \cdot f[i-k][j-1]}{i-1}
$$

**难点突破**：  
- **均匀性证明**：通过组合数学分析，左右子树划分k的概率均为1/(i-1)  
- **容斥处理**：避免左右子树同时满足条件时的重复计算  

**代码实现**：  
- 三重循环处理i（叶子数）、j（深度）、k（左子树叶子数）  
- 初始条件f[i][0] = 1（深度≥0的概率为1）  
- 最终答案通过∑f[n][i]计算  

---

## 题解评分（≥4星）

1. **BJpers2（5星）**  
   - 完整证明了左右子树划分的均匀性，推导严谨  
   - 代码简洁，状态转移清晰  
   - 提供组合数学分析，深入核心难点  

2. **Fizzmy（4.5星）**  
   - 明确使用整数概率公式简化期望计算  
   - 状态定义直观，代码可读性强  
   - 缺少均匀性的详细证明，但结论正确  

3. **Scarlet_Hypoc（4星）**  
   - 提供两种状态定义对比（≥j vs =j）  
   - 包含组合数学推导和代码实现  
   - 优化思路明确，适合进阶学习  

---

## 最优思路提炼

1. **递推式构造**（第一问）  
   通过分析单次扩展对总深度的贡献，建立增量关系式，避免复杂概率计算。

2. **状态压缩技巧**（第二问）  
   使用≥j的概率代替精确值，利用整数期望公式∑P(X≥i)简化计算。

3. **均匀性利用**  
   通过组合数证明每个k的概率相等，使状态转移时能均分概率，避免枚举所有可能划分。

---

## 相似题目推荐

1. **P1365 WJMZBMR打osu!**（期望递推）  
2. **P1654 OSU!**（多维期望计算）  
3. **P1850 换教室**（概率DP与期望最优决策）

---

## 可视化设计

### 算法演示（第二问DP）
**动画方案**：  
1. **树形结构绘制**：  
   - 根节点分裂为左右子树，动态显示k和i-k的划分  
   - 当前操作节点用闪烁边框高亮  

2. **状态转移矩阵**：  
   - 表格显示f[i][j]的值，更新时高亮变化单元格  
   - 颜色标记转移来源（红:左子树，蓝:右子树）  

3. **概率流显示**：  
   - 用流动箭头表示概率从f[k][j-1]和f[i-k][j-1]合并到f[i][j]  

**复古像素风格**：  
```javascript
// 示例：Canvas绘制树节点（8位风格）
function drawNode(x, y, depth) {
    ctx.fillStyle = '#8B8B83'; // 灰绿色像素块
    ctx.fillRect(x, y, 16, 16); 
    ctx.fillStyle = '#000';
    ctx.fillText(`D:${depth}`, x+2, y+12);
}
```

**音效设计**：  
- 节点分裂：短促"哔"声（Web Audio合成方波）  
- 状态更新："叮"声提示  
- 计算完成：经典FC过关音效  

---

## 核心代码实现

### 第一问
```python
def q1(n):
    res = 0.0
    for i in range(2, n+1):
        res += 2.0 / i
    return res
```

### 第二问
```cpp
double dp[N][N]; // dp[i][j]: i叶子深度≥j的概率

void q2(int n) {
    for(int i=1; i<=n; i++) dp[i][0] = 1.0;
    
    for(int i=2; i<=n; i++)
        for(int j=1; j<i; j++) 
            for(int k=1; k<i; k++) {
                double p = dp[k][j-1] + dp[i-k][j-1];
                p -= dp[k][j-1] * dp[i-k][j-1];
                dp[i][j] += p;
            }
            dp[i][j] /= (i-1);
    
    double ans = 0;
    for(int j=1; j<n; j++) ans += dp[n][j];
}
```

---

## 关键证明片段

**均匀性证明**（组合数学）：  
当生成i个叶子的树时，左子树k个叶子的方案数为：
$$
\frac{(i-2)!}{(k-1)!(i-k-1)!} \times (k-1)! \times (i-k-1)! = (i-2)!
$$
与k无关，故每个k的概率均为1/(i-1)。

---

## 个人心得

1. **调试经验**：  
   初始未考虑深度≥j的容斥，导致结果偏大。通过小样例（n=4）验证发现错误。

2. **思维突破**：  
   将树深度问题转化为左右子树的"或"条件，避免直接计算最大值的复杂期望。

---

## 扩展思考

对于n较大的情况（如n=1e5），第二问的O(n³)DP无法处理。可研究数学规律或寻找递推式的闭合形式，例如通过生成函数或马尔可夫链建模。

---
处理用时：77.29秒
# 题目信息

# [CQOI2018] 社交网络

## 题目背景

当今社会，在社交网络上看朋友的消息已经成为许多人生活的一部分。通常，一个用户在社交网络上发布一条消息后，他的好友们也可以看见这条消息，并可能转发。转发的消息还可以继续被人转发，进而扩散到整个社交网络中。

## 题目描述

在一个实验性的小规模社交网络中我们发现，有时一条热门消息最终会被所有人转发。为了研究这一现象发生的过程，我们希望计算一条消息所有可能的转发途径有多少种。为了编程方便，我们将初始消息发送者编号为 $1$，其他用户编号依次递增。

该社交网络上的所有好友关系是已知的，也就是说对于 $a, b$ 两个用户，我们知道 $a$ 用户可以看到 $b$ 用户发送的消息。注意可能存在单向的好友关系，即 $a$ 能看到 $b$ 的消息，但 $b$ 不能看到 $a$ 的消息。

还有一个假设是，如果某用户看到他的多个好友转发了同一条消息，他只会选择从其中一个转发，最多转发一次消息。从不同好友的转发，被视为不同的情况。

如果用箭头表示好友关系，下图展示了某个社交网络中消息转发的所有可能情况。（初始消息是用户 $1$ 发送的，加粗箭头表示一次消息转发）

![](https://cdn.luogu.com.cn/upload/pic/17549.png)
![](https://cdn.luogu.com.cn/upload/pic/17550.png)
![](https://cdn.luogu.com.cn/upload/pic/17551.png)
![](https://cdn.luogu.com.cn/upload/pic/17552.png)
![](https://cdn.luogu.com.cn/upload/pic/17553.png)
![](https://cdn.luogu.com.cn/upload/pic/17554.png)

答案对 $10^4 + 7$ 取模。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 250$，$1 \leq m \leq n \times (n - 1)$，$1 \leq a, b \leq n$。

## 样例 #1

### 输入

```
4
7
2 1
3 1
1 3
2 3
3 2
4 3
4 2
```

### 输出

```
6```

# AI分析结果



---

## 唯一算法分类
图论-生成树计数（矩阵树定理）

---

## 综合分析与结论
### 核心问题与算法流程
题目要求计算以节点1为根的**有向生成树数量**（即每个非根节点有且仅有一个父节点的树形结构）。通过**有向图矩阵树定理**，算法流程如下：

1. **构建基尔霍夫矩阵**  
   - 入度矩阵：对角线元素为各节点的入度  
   - 邻接矩阵：非对角线元素为反向边的数量（若存在边`a->b`，则邻接矩阵`A[b][a]++`）  
   - 基尔霍夫矩阵 = 入度矩阵 - 邻接矩阵  

2. **删去根节点对应行列**  
   删除第1行第1列，保留`n-1`阶子矩阵  

3. **高斯消元求行列式**  
   通过模意义下的高斯消元，将矩阵转为上三角矩阵，对角线元素乘积即为答案  

### 解决难点与实现要点
- **边的方向处理**：题目中的边是`a能看到b`，对应树形图中的`父节点→子节点`关系，需反向存储为`b→a`的边  
- **负数处理**：每次操作后需将负数转为正数（`+mod`再取模）  
- **高斯消元优化**：用快速幂求逆元加速消元过程，避免浮点误差  

---

## 题解清单（评分≥4星）

### 1. autoint（★★★★☆）
**亮点**：代码结构清晰，变量命名规范，完整处理负数  
**核心代码**：
```cpp
for(int x,y; m--;) {
    read(x),read(y); // 反向存储边
    --A[y-1][x-1], ++A[x-1][x-1];
}
// 高斯消元时处理负数
for(int i=0; i<n; i++)for(int j=0; j<n; j++)
    if(A[i][j]<0) A[i][j]+=mod;
```

### 2. Prean（★★★★☆）
**亮点**：极简代码风格，使用位运算优化交换逻辑  
```cpp
inline int Gauss(){
    for(int i=2;i<=n;++i){
        if(a[j][i]) std::swap(a[i],a[j]); // 位运算交换
        int inv=pow(a[i][i]); // 快速幂逆元
    }
}
```

### 3. 月下萤火（★★★★☆）
**亮点**：完整注释高斯消元过程，适合教学  
```cpp
// 逆元优化消元
int t = qpow(K[i][i], mod - 2);
for(int j=i+1; j<=n; j++)
    K[j][k] = (K[j][k] - K[i][k]*t%mod*K[j][i]%mod + mod) % mod;
```

---

## 最优思路与技巧提炼
### 关键实现技巧
1. **反向边存储**：将输入边`a->b`存储为`b→a`，适配矩阵树定理中外向树的定义  
2. **模运算处理**：每次矩阵操作后立即处理负数，避免最终结果错误  
3. **行列式优化**：通过交换主元减少计算量，使用逆元代替浮点除法  

### 通用解法模板
```cpp
void solve() {
    构建基尔霍夫矩阵;
    删去根节点行列;
    高斯消元求行列式;
    输出结果;
}
```

---

## 类似题目推荐
1. **P6178 【模板】Matrix-Tree 定理**  
   （无向图生成树计数基础模板）

2. **P3317 [SDOI2014] 重建**  
   （带权图生成树计数，扩展概率处理）

3. **P4208 [JSOI2008] 最小生成树计数**  
   （最小生成树计数，结合并查集与矩阵树定理）

---

## 可视化与算法演示设计
### 核心动画方案
1. **矩阵构建阶段**  
   - 用像素方块表示矩阵元素，初始为白色  
   - 每读入一条边`a->b`，将对应`A[b][a]`方块变红闪烁，同时`D[b][b]`方块变蓝闪烁  
   - 最终显示完整的基尔霍夫矩阵（蓝-红对比色区分入度与边数）

2. **高斯消元过程**  
   - 当前主元行用绿色高亮，被消元行用黄色标记  
   - 行交换时播放"哔"声，消元时播放"滴"声  
   - 消元完成后，主元所在列变为灰色

3. **结果展示**  
   - 对角线元素逐个变为金色，最终乘积结果以8位字体弹出  

### 复古像素风格实现
- **颜色方案**：16色调色板（NES风格）  
- **音效设计**：  
  - 行交换：短促"咔嗒"声（8-bit square wave）  
  - 消元成功：上升音阶（C4→E4→G4）  
  - 错误操作：低沉"嗡"声（低音锯齿波）

---

## 关键代码片段（高斯消元核心）
```cpp
int gauss(int n) {
    int ans = 1;
    for (int i = 1; i <= n; ++i) {
        // 寻找主元
        int pivot = i;
        for (int j = i; j <= n; ++j)
            if (a[j][i]) { pivot = j; break; }
        
        if (!a[pivot][i]) return 0;
        if (pivot != i) {
            swap(a[i], a[pivot]);
            ans = mod - ans; // 行列式符号变化
        }
        
        // 模逆元消元
        int inv = qpow(a[i][i], mod-2);
        for (int j = i+1; j <= n; ++j) {
            int factor = a[j][i] * inv % mod;
            for (int k = i; k <= n; ++k)
                a[j][k] = (a[j][k] - factor * a[i][k] % mod + mod) % mod;
        }
        ans = ans * a[i][i] % mod;
    }
    return ans;
}
```

---

## 个人调试心得
1. **反向边易错**：初始实现时忘记反转边方向，导致WA多个测试点  
2. **模数特殊性**：题目模数10007不是质数？误判导致逆元计算错误（实际10007=10^4+7是质数）  
3. **行列式符号**：交换行时需要维护符号，最终结果需保证为正数  

---

## 算法演示截图（模拟）
![矩阵构建阶段](https://via.placeholder.com/400x200/000000/FFFFFF?text=Base+Matrix)  
![高斯消元过程](https://via.placeholder.com/400x200/000000/FFFFFF?text=Gauss+Elimination)  
![最终结果展示](https://via.placeholder.com/400x200/000000/FFFFFF?text=Det=6)  
（注：实际实现需动态展示矩阵变化过程）

---
处理用时：74.72秒
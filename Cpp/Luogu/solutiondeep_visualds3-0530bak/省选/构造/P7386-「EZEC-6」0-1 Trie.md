# 题目信息

# 「EZEC-6」0-1 Trie

## 题目背景

> $\mathbf{000111}$，这就是简单中所蕴含的优美。

众所周知，tlx 不会字符串。

## 题目描述

现在 tlx 有 $n$ 个 $\mathbf{1}$ 和 $m$ 个 $\mathbf{0}$，你需要把它们排列，但要保证任意的 $\mathbf{1}$ 互不相邻且第一个位置是 $\mathbf{0}$、最后一个位置是 $\mathbf{1}$，现在把所有可以构造出的串放到一棵 0-1 Trie 上，需要多少个节点？

**注意：节点计数时，不计算最开始的空节点，只计算代表“ $\mathbf{0}$ ”、“ $\mathbf{1}$ ”的节点。**  

**在本题中，我们认为用节点存储字符而非边， Trie 基本原理不变。**

因为答案可能很大而且询问较多，所以请在最后输出所有询问的答案对 $18888913$ （放心，是个质数）取模的结果的异或和（**异或和不再进行取模**）。

## 说明/提示

**【样例解释 #1】**

可以发现，所有能构造出的串有：  

$$\mathbf{000101}$$
$$\mathbf{001001}$$
$$\mathbf{010001}$$

构造 0-1 Trie，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/aql3bwo6.png)

共需 $15$ 个节点。


**【样例解释 #2】**

两次询问的答案分别为 $34$ 和 $4487317$。

------------

**【数据规模与提示】**

注意：本题采用**捆绑测试**，只有当你通过一个 Subtask 内的所有测试点后，你才能拿到这个 Subtask 的分数。

具体约束如下：  

Subtask $1$（$10\%$）：满足 $T\leq 10$，$n,m\leq 5$；

Subtask $2$（$20\%$）：满足 $T \leq 10$，$n,m\leq 1\times 10^3$；

Subtask $3$（$30\%$）：满足 $T\leq 10$，$n,m\leq 5\times 10^5$;


Subtask $4$（$40\%$）：无特殊限制。

对于 $100\%$ 的数据，满足 $1\le T \le 2\times10^6$，$1\le n,m\le 5\times 10^{18}$。

**本题输入量较大，建议采用较为快速的读入方式并注意常数因子对程序效率带来的影响。**



------------
 0-1 Trie 是一种特殊的 Trie ，只有 $\mathbf{0,1}$ 两种字符。
 
 如果你不了解 Trie，可以查看：[OI Wiki--Trie](https://deploy-preview-980--oi-wiki.netlify.app/string/trie/)。

## 样例 #1

### 输入

```
1
2 4```

### 输出

```
15```

## 样例 #2

### 输入

```
2
3 5
114514 1919810```

### 输出

```
4487351
```

## 样例 #3

### 输入

```
5
78 122
1000000 1000001
74859432 942432534
555555555 77777777 
6666666666 8888888888```

### 输出

```
12287990```

# AI分析结果



**唯一算法分类**：组合数学与数论

---

### **题解思路与核心难点**

1. **问题转化**  
   将每个1强制与前置0绑定形成"01"结构，问题转化为用`n`个"01"和`m-n`个"0"构造合法串，再计算所有前缀的Trie节点数。

2. **递推式与组合数推导**  
   建立递推式`F(n,m) = F(n-1,m) + F(n,m-1) + 2`，通过生成函数或路径计数模型推导出最终公式：  
   $$\text{Ans} = 2\binom{n+m+1}{n} - \binom{n+m-1}{n} - 2$$  
   其中组合数计算需处理超大规模数，采用Lucas定理分治计算。

3. **实现要点**  
   - **预处理阶乘与逆元**：模数`18888913`为质数，预处理`fac[i]`和`inv[i]`数组加速组合数计算。  
   - **Lucas递归分解**：将大数组合数分解为模数下的子问题。  
   - **边界特判**：当`n > m`时无解，直接返回0。

---

### **最优思路/技巧提炼**

1. **组合数路径模型**  
   将递推式视为网格路径计数问题，每个`F(n,m)`对应从起点到当前点的路径数，每步贡献常数项通过组合数路径求和公式统一计算。

2. **生成函数化简**  
   通过生成函数`F_n(x)`的闭式展开，直接得到组合数表达式，避免递推计算的复杂度。

3. **Lucas定理分治**  
   将大数组合数拆分为模数下的子问题，递归求解并合并结果，高效处理`n,m ≤5e18`的极端数据。

---

### **代码实现核心逻辑**

```cpp
const int MOD = 18888913;
int fac[MOD], inv[MOD];

// 预处理阶乘和逆元
void precompute() {
    fac[0] = 1;
    for (int i = 1; i < MOD; i++) 
        fac[i] = 1LL * fac[i-1] * i % MOD;
    inv[MOD-1] = pow(fac[MOD-1], MOD-2); // 费马小定理求逆元
    for (int i = MOD-2; i >= 0; i--)
        inv[i] = 1LL * inv[i+1] * (i+1) % MOD;
}

// Lucas定理递归计算组合数
int C(ll n, ll k) {
    if (k < 0 || k > n) return 0;
    if (n < MOD) 
        return 1LL * fac[n] * inv[k] % MOD * inv[n-k] % MOD;
    return 1LL * C(n/MOD, k/MOD) * C(n%MOD, k%MOD) % MOD;
}

int solve(ll n, ll m) {
    if (n > m) return 0;
    ll total = (2LL * C(n + m + 1, n) % MOD - C(n + m - 1, n) + MOD - 2) % MOD;
    return (total + MOD) % MOD; // 防止负数
}
```

---

### **可视化与算法演示**

1. **动态路径计数**  
   在Canvas中绘制网格，起点`(0,0)`到终点`(n,m)`的路径代表组合数计算过程，高亮当前递归层数的分解路径。

2. **Lucas分治动画**  
   用嵌套方块表示大数分解过程，每个方块显示`n%MOD`和`k%MOD`的组合数计算，递归深度用颜色渐变表示。

3. **复古像素风格**  
   - **网格绘制**：8-bit风格网格，路径用绿色像素块标记，当前操作块闪烁。  
   - **音效设计**：递归分解时播放短促“滴”声，计算完成时播放胜利音效。  
   - **自动演示**：按空格键逐步分解或自动播放，速度可调。

---

### **相似题目推荐**

1. [P3807 【模板】卢卡斯定理](https://www.luogu.com.cn/problem/P3807)  
   **标签**：组合数、Lucas定理

2. [P1641 [SCOI2010]生成字符串](https://www.luogu.com.cn/problem/P1641)  
   **标签**：合法串计数、组合数学

3. [P4369 [Code+#4]组合数问题](https://www.luogu.com.cn/problem/P4369)  
   **标签**：组合数性质、二进制拆分

---
处理用时：68.28秒
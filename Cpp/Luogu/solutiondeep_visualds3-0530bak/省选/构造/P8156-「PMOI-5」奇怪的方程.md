# 题目信息

# 「PMOI-5」奇怪的方程

## 题目描述

给出一个 $n$，现在有 $n\times n$ 个未知数 $a_{1},a_{2},\cdots,a_{n\times n}$。

给出 $2\times n$ 个方程，方程共有两种，每种分别有 $n$ 个。

第一种方程的 $i$ 个方程为 $\sum_{j=1}^na_{(i-1)\times n+j}=A_i$。   
第二种方程的 $i$ 个方程为 $\sum_{j=1}^na_{i+(j-1)\times n}=B_i$。

可这太简单了，给出 $m$ 个限制，你需要保证 $a_{p_i}=q_i$。

请求出任意一组合法的解。无解输出 `No Solution`，否则先输出 `OK`，接着给出解，其中 $\forall i\in[1,n^2]$，$a_i \in[-2^{63},2^{63})$ 且是个整数。

## 说明/提示

**本题采用捆绑测试。**

- Subtask1（1pts）：$n=1$；
- Subtask2（4pts）：$n\le3$；
- Subtask3（10pts）：$n\le 10$；
- Subtask4（15pts）：$n\le 100$；
- Subtask5（20pts）：$m\le n-1$；
- Subtask6（10pts）：$m=0$；
- Subtask7（20pts）：$T\le 10$，$n\le 500$；
- Subtask8（20pts）：无特殊限制。

对于 $100\%$ 的数据，$1\le T\le 10^5$，$1\le n \le 2000$，$1\le \sum n^2\le 4\times 10^6$，$-5\times 10^{12}\le A_i,B_i\le 5\times 10^{12}$，$0\le m\le n^2$，$1\le p_i\le n^2$，$-10^9\le q_i\le 10^9$。保证 $p_i$ 互不相同。

## 样例 #1

### 输入

```
1
5 17
8 10 12 8 45
16 17 18 18 14
3 2
4 3
6 3
7 2
8 2
10 2
11 2
12 4
13 2
14 3
18 3
19 2
21 9
22 9
23 9
24 9
25 9```

### 输出

```
OK
1 1 2 3 1 3 2 2 1 2 2 4 2 3 1 1 1 3 2 1 9 9 9 9 9```

# AI分析结果



## 算法分类
构造算法 / 图论-连通性

---

## 题解思路与难点分析

### 核心思路
1. **二维约束转化**：将每个未知数位置视为网格，行与列抽象为图的节点，未固定值的位置建立行节点与列节点的连边。
2. **连通块分解**：通过并查集划分连通块，每个连通块的行列和必须相等（$\sum A_i = \sum B_j$）。
3. **生成树拓扑排序**：对每个连通块构造生成树，按度数为1的节点依次确定变量值，确保解的存在性。

### 解决难点
- **约束传递**：通过连边建立行列间的依赖关系，保证每个连通块内的约束自洽。
- **动态调整行/列和**：每次确定一个变量后，实时更新对应的行和与列和。
- **时间复杂度控制**：使用并查集（$O(α(n))$）和拓扑排序（$O(n)$）处理大规模数据。

### 算法流程
```python
for 每个测试用例:
    初始化行和A_i、列和B_j
    处理固定值，更新对应行/列的和
    建立行与列的图结构（未固定值的位置连边）
    分解连通块，检查每个连通块的行列和是否相等
    对每个连通块：
        生成生成树
        拓扑排序确定变量值
    最终检查所有行/列和是否归零
```

---

## 题解评分
- **ddh123题解（4.5星）**
  - **亮点**：连通块分解思路清晰，生成树拓扑排序巧妙避免循环依赖。
  - **改进点**：DFS+BFS稍显冗余，可优化为纯BFS生成树。

---

## 最优技巧提炼
1. **图模型构建**：将行列视为节点，变量位置作为边，将二维约束转化为连通性问题。
2. **生成树拓扑法**：通过删除叶子节点逐步确定唯一解变量，类似剥洋葱过程。
3. **实时和更新**：每次赋值后立即扣除对应行/列和，保证后续计算的正确性。

---

## 同类题型推荐
1. **P2474 [SCOI2008] 天平**（差分约束+连通性）
2. **P2476 [SCOI2008] 着色方案**（多维约束构造）
3. **P3223 [HNOI2012] 排队**（矩阵约束优化）

---

## 代码核心片段
```cpp
// 连通块处理
void dfs(int p) {
    tvis[p] = 1, now.push_back(p);
    for (auto &&i : E[p])
        if (!tvis[i.fi]) {
            G[i.fi].push_back({p, i.se}); 
            in[i.fi]++; in[p]++;
            dfs(i.fi);
        }
}

// 拓扑排序赋值
void bfs() {
    queue<int> q;
    for (auto &&i : now)
        if (in[i] == 1) q.push(i);
    while (q.size()) {
        int u = q.front(); q.pop();
        tvis[u] = 2;
        for (auto &&i : G[u]) {
            int v = i.fi, x = i.se;
            // 计算行列索引tx,ty
            ans[tx][ty] = (u <= n ? a[u] : b[u-n]); 
            a[tx] -= ans[tx][ty]; b[ty] -= ans[tx][ty];
            if (--in[v] == 1) q.push(v);
        }
    }
}
```

---

## 可视化设计
### 动画方案
1. **像素网格**：用16x16像素块表示n×n网格，已固定值显示为灰色，待确定值闪烁。
2. **连通块染色**：不同连通块使用不同颜色（红/蓝/绿），边显示为发光线条。
3. **拓扑过程**：当前处理的节点高亮黄色，赋值时播放"滴"音效，错误时播放爆破音效。

### 复古特效
- **背景音乐**：8-bit芯片风格循环旋律
- **音效触发**：
  - `确定值` → 短促"哔"声（频率随值大小变化）
  - `连通块检查` → 扫描线音效
  - `无解` → 低沉错误音

---

## 个人心得
> "构造题常需自设约束，从特殊结构（如生成树）切入，通过逐步分解复杂问题为可处理的子模块。" —— 通过将全局约束分解为连通块，巧妙降低问题维度。

---

## 总结
该题解通过图论建模将二维约束转化为连通性问题，利用生成树拓扑排序构造解，时间复杂度$O(n^2)$。可视化设计强化了行列约束的传递过程，8-bit风格增强算法理解趣味性。

---
处理用时：60.85秒
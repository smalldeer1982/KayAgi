# 题目信息

# 「PFLOI R1」PFL 变换

## 题目背景

五大高手云集于此，思想的火花激烈碰撞。很快，PFLOI Round 1 准备完毕。

开始了……

## 题目描述

新的征途已经开始：智力踏上了寻香蕉之旅。道路上共有 $n$ 个香蕉，编号从 $1$ 到 $n$。

智力看到如此美食，非常激动。但是智力不想吃得太饱或太少，所以它会吃**刚好** $m$ 个香蕉。

智力是一个挑剔的人，只有当它吃的 $m$ 个香蕉的编号的异或和**恰好为** $2^{\lfloor\log_2 n\rfloor+1}-1$ 时他才会满意。请你帮忙找出他应该吃哪些香蕉，好让他满意。

如果怎样都不能满足智力的需求，就请输出 `-1` 吧。

------------

**形式化题面**：

请你从 $1$ 到 $n$ 中选出 $m$ 个数，使得它们的异或和恰好为 $2^{\lfloor\log_2 n\rfloor+1}-1$。若无解输出 `-1`。

## 说明/提示

**本题不采用捆绑测试**。

| 测试点编号 | 特殊性质 | 分值 |
| :----------: | :----------: | :-----:| 
| $1,2$ | $n\le15$ | $2\times4=8$ |
| $3\sim11 $ | $n\le128$ | $9\times3=27$ |
| $12\sim24 $ | $\sum n\le10^5$ | $13\times3=39$ |
| $25\sim29$ | 无特殊限制 | $5\times4=20$ |
| $30$ | 无特殊限制 | $1\times6=6$ |

对于所有数据，$1\le m\le n\le10^6$，$1\le\sum n,T\le10^6$。

## 样例 #1

### 输入

```
7
5 2
6 6
7 6
8 3
9 3
10 1
7 4```

### 输出

```
3 4
1 6 2 4 3 5 
1 2 3 4 5 6
8 6 1
8 1 6
-1
3 5 6 7```

# AI分析结果



## **算法分类**
构造法 + 分情况讨论

## **题解思路与核心分析**

### **核心思路**
1. **目标异或和**：设 t = 2^(floor(log2(n))+1)-1，构造 m 个数的异或和为 t
2. **二进制构造**：优先选择最高位相关数（如 2^k 和 2^k-1）作为异或基
3. **分情况处理**：
   - m=1 时直接检查 t 是否在 [1,n]
   - m 较大时构造全选后调整
   - m 较小时递归构造子问题

### **解决难点**
1. **异或性质应用**：利用 2i ⊕ (2i+1)=1 的配对性质快速构造低位
2. **边界特判**：处理 n=2^k-1、n=2^k-2 等特殊场景
3. **递归构造**：将大问题分解为高位选择和低位配对的子问题

### **题解对比**
| 题解作者       | 核心方法                     | 优势                   | 不足                   |
|---------------|-----------------------------|------------------------|------------------------|
| yydtq         | 打表+递归构造               | 小数据高效，逻辑清晰   | 表驱动不够灵活         |
| ddxrS_loves_zxr| 分情况构造+递归             | 覆盖场景全面           | 代码复杂度较高         |
| Z1qqurat      | 二进制分组+配对调整         | 代码简洁，思维巧妙     | 需处理更多特判         |

## **题解评分（≥4星）**
1. **yydtq（4.5星）**  
   - 亮点：打表处理小数据提升效率，递归构造逻辑清晰  
   - 代码：通过预处理表实现快速判断，关键递归步骤简明  
   - 心得："Ad-hoc 题目可以通过小范围规律、打表解决"

2. **Z1qqurat（4.2星）**  
   - 亮点：二进制分组思想优雅，配对调整直观  
   - 代码：关键构造仅需20行，利用位运算高效处理  
   - 示例：`ans = {(1<<k)-2, 1<<k}` 直接构造基数值

3. **ddxrS_loves_zxr（4.0星）**  
   - 亮点：全面覆盖各类边界场景  
   - 方法：通过 `solve(n>>1, m-1)` 实现递归降维  
   - 优化：预先计算 LOG 数组加速位运算

## **最优技巧提炼**
1. **二进制基选择**：  
   ```cpp
   int k = __lg(n);  // 最高位位置
   int t = (1 << (k+1)) - 1;  // 目标异或和
   ```
2. **配对构造法**：  
   ```cpp
   for (int i=2; i<=n; i+=2) 
       ans.push_back(i), ans.push_back(i+1);  // 利用 2i⊕(2i+1)=1
   ```
3. **递归降维思想**：  
   ```cpp
   vector<int> solve(int n, int m) {
       if (m < (1<<k)) 
           return solve(n>>1, m-1) + {n>>1 + 1};
   }
   ```

## **同类题目推荐**
1. P1469 找筷子（异或性质应用）
2. P2114 位运算的逆问题（二进制构造）
3. P2326 异或橙子（区间异和构造）

## **可视化设计**
### **像素动画方案**
1. **核心展示**：  
   - 左侧显示当前选择的数字集合  
   - 右侧用二进制位图显示异或和变化  
   ```javascript
   // 示例代码片段
   ctx.fillStyle = '#8B00FF';  // 紫色标记已选数
   selectedNums.forEach(num => {
       drawPixel(num, (1<<k)-1 ^ currentXor);
   });
   ```

2. **交互设计**：  
   - WASD 控制选择/取消数字  
   - 空格键触发异或和验证  
   ```javascript
   document.addEventListener('keydown', (e) => {
       if (e.code === 'Space') checkXor(target);
   });
   ```

3. **音效设计**：  
   - 选择数字时播放 8-bit "blip" 音效  
   - 验证成功时播放《超级马里奥》通关音效

## **核心代码实现**
### 构造法实现（Z1qqurat 改进版）
```cpp
vector<int> solve(int n, int m) {
    int k = __lg(n), t = (1<<(k+1))-1;
    if(m == 1) return {t <= n ? t : -1};
    
    vector<int> ans = {(1<<k)-2, 1<<k};  // 基数值
    if(m & 1) ans.push_back(1);          // 补齐奇偶
    
    for(int i=2; ans.size()<m; i+=2) {    // 低位配对
        if(i == (1<<k)-2) continue;       // 跳过基数值
        ans.insert(ans.end(), {i, i+1});
    }
    
    // 调整最终异或和
    if(accumulate(ans.begin(), ans.end(), 0, bit_xor<>()) != t)
        ans[0]++;  // 微调第一个元素
    
    return ans;
}
```

### 分情况递归（ddxrS_loves_zxr 精简版）
```cpp
void dfs(int n, int m, vector<int>& res) {
    if(m == 0) return;
    int high = 1 << __lg(n);
    if(m >= high/2) {
        res.push_back(high);
        dfs(high-1, m-1, res);
    } else {
        dfs(high-1, m, res);
    }
}
```

## **总结**
本题通过二进制分解与递归构造，将复杂异或问题转化为可管理的子问题。关键点在于识别最高位基数和配对调整策略，配合边界特判实现高效构造。可视化方案通过像素风格和交互反馈，生动展现位运算的构造过程。

---
处理用时：72.64秒
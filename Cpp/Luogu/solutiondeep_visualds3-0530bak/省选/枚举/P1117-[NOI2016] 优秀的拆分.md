# 题目信息

# [NOI2016] 优秀的拆分

## 题目描述

如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  
例如，对于字符串 $ \texttt{aabaabaa} $ ，如果令 $\text{A}=\texttt{aab}$，$\text{B}=\texttt{a}$，我们就找到了这个字符串拆分成 $\text{AABB}$ 的一种方式。

一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  
比如我们令 $\text{A}=\texttt{a}$，$\text{B}=\texttt{baa}$，也可以用 $\text{AABB}$ 表示出上述字符串；但是，字符串 $\texttt{abaabaa}$ 就没有优秀的拆分。

现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。

以下事项需要注意：

1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。
2. 在一个拆分中，允许出现 $\text{A}=\text{B}$。例如 $\texttt{cccc}$ 存在拆分 $\text{A}=\text{B}=\texttt{c}$。
3. 字符串本身也是它的一个子串。

## 说明/提示

### 样例解释

我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。

第一组数据中，共有三个子串存在优秀的拆分：  
$S[1,4]=\texttt{aabb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{b}$；  
$S[3,6]=\texttt{bbbb}$，优秀的拆分为 $\text{A}=\texttt{b}$，$\text{B}=\texttt{b}$；  
$S[1,6]=\texttt{aabbbb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{bb}$。  
而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。

第二组数据中，有两类，总共四个子串存在优秀的拆分：  
对于子串 $S[1,4]=S[2,5]=S[3,6]=\texttt{cccc}$，它们优秀的拆分相同，均为 $\text{A}=\texttt{c}$，$\text{B}=\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  
对于子串 $S[1,6]=\texttt{cccccc}$，它优秀的拆分有两种：$\text{A}=\texttt{c}$，$\text{B}=\texttt{cc}$ 和 $\text{A}=\texttt{cc}$，$\text{B}=\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  
所以第二组数据的答案是 $3+2=5$。

第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。

第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。

我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：

| 测试点编号   | $n \leq$  | 特殊性质           |
| ------------ | --------- | ------------------ |
| $1 \sim 2$   | $300$     | $S$ 中所有字符相同 |
| $3 \sim 4$   | $2\,000$  | $S$ 中所有字符相同 |
| $5 \sim 6$   | $10$      |                    |
| $7 \sim 8$   | $20$      |                    |
| $9 \sim 10$  | $30$      |                    |
| $11 \sim 12$ | $50$      |                    |
| $13 \sim 14$ | $100$     |                    |
| $15$         | $200$     |                    |
| $16$         | $300$     |                    |
| $17$         | $500$     |                    |
| $18$         | $1\,000$  |                    |
| $19$         | $2\,000$  |                    |
| $20$         | $30\,000$ |                    |

## 样例 #1

### 输入

```
4
aabbbb
cccccc
aabaabaabaa
bbaabaababaaba
```

### 输出

```
3
5
4
7
```

# AI分析结果



### 算法分类
**后缀数组 + 差分数组**

---

### 题解思路与核心要点
1. **问题转换**  
   - 统计每个位置结尾的 AA 型串数量（f 数组）和开头的 AA 型串数量（g 数组）  
   - 最终答案为 $\sum f[i] \cdot g[i+1]$

2. **关键步骤**  
   - **预处理正反后缀数组**：计算任意两点的 LCP（最长公共前缀）和 LCS（最长公共后缀）  
   - **调和级数枚举长度**：枚举可能的 A 的长度 len，每隔 len 设置关键点  
   - **相邻关键点贡献计算**：对每个关键点对 (i, j) 计算其 LCP 和 LCS，确定可形成 AA 串的区间  
   - **差分数组优化**：利用区间差分高效统计每个位置的 f 和 g 值

3. **解决难点**  
   - 快速计算 LCP/LCS：通过后缀数组预处理 + ST 表实现 O(1) 查询  
   - 避免暴力枚举：利用关键点相邻性减少计算量，复杂度优化至 O(n log n)

---

### 题解评分（≥4星）

1. **Gypsophila（★★★★☆）**  
   - 思路清晰，详细图解 LCP/LCS 的交叠情况  
   - 代码结合后缀数组 + ST 表，实现高效查询

2. **何俞均（★★★★☆）**  
   - 双后缀数组正反处理，差分统计区间贡献  
   - 代码注释详尽，关键逻辑分段明确

3. **George1123（★★★★★）**  
   - 完整代码展示哈希 + 调和级数枚举的替代方案  
   - 提供详细复杂度分析和调试建议

---

### 最优思路提炼
- **关键点分治**：每隔 len 长度的关键点，确保每个 AA 必定跨过两个相邻关键点  
- **差分数组**：将区间贡献转化为差分操作，避免逐个累加  
- **调和级数优化**：总枚举次数为 O(n log n)，显著降低复杂度

---

### 同类型题与算法套路
- **字符串分段处理**：如 CF319D（删除重复子串）  
- **调和级数枚举**：适用于所有需枚举长度倍数的问题  
- **后缀数组应用**：求 LCP/LCS 的通用解法可推广至多数字符串问题

---

### 推荐题目
1. **P3809 【模板】后缀排序**  
   （后缀数组基础实现）  
2. **P4559 不同子串统计**  
   （后缀数组 + 调和级数优化）  
3. **CF319D Have You Ever Heard About the Word?**  
   （类似的关键点分治 + 区间处理）

---

### 可视化与算法演示
**动画设计思路**：  
1. **像素网格展示**：  
   - 字符以 8x8 像素块显示，关键点高亮为红色  
   - LCP/LCS 用绿色/蓝色光柱动态延伸  
   ![](https://i.loli.net/2018/12/08/5c0b394224f12.png)  
   （图中红点为关键点，绿蓝为 LCP/LCS）  

2. **差分更新效果**：  
   - 当确定贡献区间时，对应位置闪烁黄色光晕  
   - 差分数组变化以数字浮层动态显示  

3. **复古音效**：  
   - 关键点匹配成功：8-bit "coin" 音效（↑↑↓↓←→←→BA）  
   - 区间更新完成：短促合成器音阶  

**交互控制**：  
- 速度滑块调节枚举 len 的速度  
- 单步调试模式可观察每个关键点对的贡献计算  

---

### 核心代码片段（SA+差分）
```cpp
for (int len=1; len<=n/2; ++len) {
    for (int i=len, j=i+len; j<=n; i+=len, j+=len) {
        int Lcp = min(A.query(i,j), len);
        int Lcs = min(B.query(n-i+1,n-j+1), len-1);
        if (Lcp + Lcs >= len) {
            int t = Lcp + Lcs - len + 1;
            // 差分更新 f 和 g 数组
            g[i-Lcs]++; g[i-Lcs+t]--;
            f[j+Lcp-t]++; f[j+Lcp]--;
        }
    }
}
// 前缀和统计答案
for (int i=1; i<=n; ++i) f[i]+=f[i-1], g[i]+=g[i-1];
long long ans = 0;
for (int i=1; i<n; ++i) ans += f[i] * g[i+1];
```

---

### 个人心得摘录
- **调试陷阱**：LCP 和 LCS 的边界处理需谨慎，避免越界导致 WA  
- **思维突破**：关键点的引入将问题转化为相邻点贡献，极大简化计算  
- **性能对比**：哈希法在随机数据下表现接近 SA，但极端案例可能退化为 O(n²)

---
处理用时：75.09秒
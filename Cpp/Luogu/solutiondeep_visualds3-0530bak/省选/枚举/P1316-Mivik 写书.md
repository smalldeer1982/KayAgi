# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果



## 算法分类
**容斥原理与组合计数**

---

## 题解思路与核心难点

### 核心思路
1. **期望线性性**：将总期望转化为每个子串出现概率之和。
2. **容斥原理**：通过枚举子串的出现位置集合，用容斥避免重复计数。
3. **并查集优化**：合并必须相同的字符位置，统计自由变量数目。

### 难点与解决
- **子串重叠处理**：通过二进制枚举所有可能的起始位置集合，并查集合并约束条件。
- **贡献计算**：对每个位置集合，计算满足条件的字符串数，结合容斥符号（奇加偶减）统计总贡献。

---

## 题解评分（≥4星）

1. **Huasushis（★★★★☆）**  
   - **亮点**：详细解释容斥思路，代码可读性强，位运算优化并查集。
   - **代码**：清晰展示枚举位置集合、并查集合并、贡献计算。

2. **7KByte（★★★★☆）**  
   - **亮点**：代码简洁高效，利用位运算快速处理约束，时间复杂度分析明确。
   - **核心段**：通过掩码合并字符位置，快速统计连通块。

---

## 最优思路提炼

### 关键步骤
1. **枚举子串长度**：对所有可能长度 \( x \) 遍历。
2. **二进制枚举起始位置**：用二进制数表示子串出现的位置集合。
3. **并查集处理约束**：合并重叠位置的字符，统计连通块数。
4. **容斥贡献计算**：根据集合奇偶性加减贡献，总贡献为 \( m^{\text{连通块数 + 自由位置数}} \)。

### 代码实现
```cpp
void sol(int x) {
    int a = (1 << (n - x + 1)), b = (1 << x) - 1;
    for (int i = 1; i < a; ++i) {
        int c = 0, tot = 0;
        for (int j = 0; j < x; ++j) fa[j] = j;
        for (int j = 0; j < n; ++j) {
            c = (c << 1) | ((i >> j) & 1);
            c &= b;
            if (!c) ++tot; // 自由位置
            else {
                int tmp = getfa(__builtin_ctz(c));
                for (int t = c - (c & -c); t; t -= t & -t)
                    fa[getfa(__builtin_ctz(t))] = tmp;
            }
        }
        for (int j = 0; j < x; ++j) tot += (j == fa[j]);
        ans += (__builtin_parity(i) ? 1 : -1) * qp(m, tot);
    }
}
```

---

## 同类题目推荐
1. **P1450 硬币购物**（容斥+背包）
2. **P2567 幸运数字**（容斥处理数组合）
3. **P3313 旅行**（树结构+并查集）

---

## 可视化设计

### 动画演示
- **网格表示字符串**：每个字符位置为像素块，起始位置集合高亮。
- **并查集动态合并**：用颜色渐变显示连通块合并过程。
- **贡献计算提示**：显示当前集合的符号（+/-）和自由变量数。

### 复古像素风格
- **8位调色板**：自由位置用绿色，连通块用不同暖色调。
- **音效触发**：
  - 合并时播放“哔”声。
  - 计算贡献时播放不同音高音符。

---

## 核心结论
通过容斥与并查集高效处理子串约束，将期望计算转化为多项式时间问题。代码实现充分利用位运算优化，适用于 \( n \leq 20 \) 的约束条件。

---
处理用时：108.98秒
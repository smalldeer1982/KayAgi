# 题目信息

# [NOI2013] 书法家

## 题目描述

小 E 同学非常喜欢书法，他听说 NOI2013 已经开始了，想题一幅 “NOI” 的字送给大家。

小 E 有一张非常神奇的纸，纸可以用一个 $n$ 行 $m$ 列的二维方格矩阵来表示，为了描述方便，我们定义矩阵左下角方格坐标为 $(1,1)$，右上角方格坐标为 $(m, n)$。

矩阵的每个方格有一个整数的幸运值。在格子上面写字可以增加大家的幸运度，幸运度的大小恰好是所有被笔写到的方格的幸运值之和。现在你要在上面写
上 `N`，`O`，`I` 三个字母。

下面给出 $3$ 个书法字的定义:
- `N` 由若干（$\ge 3$）个边平行于坐标轴的矩形组成，设由 $K$ 个矩形组成（标号 $1 \ldots K$），第 $i$ 个矩形的左下角方格坐标设为 $(L_i, B_i)$，右上角坐标设为 $(R_i, T_i )$，要求满足：
  1. $L_i \le R_i, B_i \le T_i$；
  2. 对任意 $1 < i \le K$，有 $L_i = R_{i-1} + 1$；
  3. 对任意 $3 \le i < K$，有 $B_{i−1} − 1 \le T_i \le T_{i-1}$，$B_i \le B_{i-1}$；
  4. $B_2 > B_1$，$T_2 = T_1$，$B_{K-1} = B_K$，$T_{K-1} < T_K$；
- `O` 由一个大矩形 $A$，挖去一个小矩形 $B$ 得到，这两个矩形的边都平行于坐标轴。设大矩形 $A$ 左下角的方格坐标为 $(u, v)$，长为 $W$，宽为 $H$，则小矩形 $B$ 满足左下角方格坐标为 $(u + 1, v + 1)$，长 $W - 2$，宽 $H - 2$。要求满足：
  1. $W \ge 3$，$H \ge 3$；
  2. $u > R_K + 1$；
- `I` 为 $3$ 个边平行于坐标轴的从下到上的实心矩形组成，从下到上依次标号为 $1,2,3$，第 $i$ 个矩形的左下角格子坐标设为 $(P_i , Q_i )$，右上角格子坐标设为 $(G_i , H_i )$，要求满足：
  1. $P_i \le G_i , Q_i \le H_i$；
  2. $P_1 = P_3 > u + W$，$G_1 = G_3$；
  3. $Q_1 = H_1 = Q_2 - 1, H_2 + 1 = Q_3 = H_3$；
  4. $P_1 < P_2 \le G_2 < G_1$。

下图是一个 `N`,`O`,`I` 的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/g7t4tquv.png)

另外，所有画的图形均不允许超过纸张的边界。现在小 E 想要知道,他能画出的最大幸运度是多少。

## 说明/提示

### 样例解释 1

![](https://cdn.luogu.com.cn/upload/image_hosting/vq7asar5.png)

### 样例解释 2

![](https://cdn.luogu.com.cn/upload/image_hosting/1ojygumc.png)

### 数据范围

| 测试点编号 |   $n$   |   $m$    | 幸运值范围 |
| :--------: | :------: | :------: | :--------: |
|     1      |   $=3$   |  $=12$   | $[-50,50]$ |
|     2      |   $=3$   |  $=12$   | $[-50,50]$ |
|     3      |   $=3$   |  $=12$   | $[-50,50]$ |
|     4      |   $=3$   |  $=12$   | $[-50,50]$ |
|     5      | $\le10$  | $\le20$  | $[-50,50]$ |
|     6      | $\le10$  | $\le20$  | $[-50,50]$ |
|     7      | $\le10$  | $\le20$  | $[-50,50]$ |
|     8      | $\le10$  | $\le20$  | $[-50,50]$ |
|     9      | $\le150$ | $\le500$ |    $=1$    |
|     10     | $\le150$ | $\le500$ |    $=1$    |
|     11     | $\le80$  | $\le80$  |    $[-200,200]$    |
|     12     | $\le80$  | $\le80$  |    $[-200,200]$    |
|     13     | $\le80$  | $\le80$  |    $[-200,200]$    |
|     14     | $\le80$  | $\le80$  |    $[-200,200]$    |
|     15     | $\le150$  | $\le500$  |    $[-200,200]$    |
|     16     | $\le150$  | $\le500$  |    $[-200,200]$    |
|     17     | $\le150$  | $\le500$  |    $[-200,200]$    |
|     18     | $\le150$  | $\le500$  |    $[-200,200]$    |
|     19     | $\le150$  | $\le500$  |    $[-200,200]$    |
|     20     | $\le150$  | $\le500$  |    $[-200,200]$    |

对于所有的测试数据，保证 $n \ge 3,m \ge 12$。

## 样例 #1

### 输入

```
3 13 
1 1 -1 -1 1 -1 1 1 1 -1 1 1 1 
1 -1 1 -1 1 -1 1 -1 1 -1 -1 1 -1 
1 -1 -1 1 1 -1 1 1 1 -1 1 1 1 
```

### 输出

```
24```

## 样例 #2

### 输入

```
3 13
-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1

```

### 输出

```
-20```

# AI分析结果



**唯一算法分类**  
动态规划

---

**综合分析与结论**  
题目要求将N、O、I三个字母的结构分解为多个阶段，通过动态规划分步求解最大幸运值。核心难点在于状态划分与转移优化，通过将每个字母拆解为多个矩形部分（如N的3部分、O的3部分、I的3部分），按列枚举并利用前缀和快速计算区间和。关键算法流程如下：  

1. **状态划分**：将整个图形分为11个部分（如N的左侧、中间、右侧，O的内外框等），每个部分对应一个状态。
2. **滚动数组优化**：使用二维数组存储每列各区间状态，避免三维数组的空间浪费。
3. **前缀和加速**：预处理每列的区间和，使得状态转移时的区间求和复杂度降为O(1)。
4. **状态转移方程**：根据不同部分的连接规则设计转移逻辑，如N的中间部分需考虑前一列的上下界约束。

**可视化设计思路**：  
- **列式动画**：按列从左到右展示处理过程，每列用不同颜色块表示当前处理的部分（如红色为N左侧，蓝色为O中间）。
- **高亮关键转移**：当状态更新时（如从N部分转移到O部分），用闪烁边框标记触发转移的列。
- **实时数值显示**：在网格旁动态显示当前列各状态的最大值，便于观察最优解的更新过程。

---

**题解清单 (≥4星)**  
1. **SimonGreenall（5星）**  
   - 状态划分清晰，代码结构简洁，利用11个二维数组分步处理，转移逻辑明确。
   - 关键亮点：前缀和与滚动数组结合，避免冗余计算，时间复杂度严格O(n²m)。

2. **myee（4星）**  
   - 详细推导状态转移方程，分阶段分析N、O、I的结构，适合理论理解。
   - 引用调试经历：“NOI2013D2T2 果然是绝世**题”体现实践难度。

3. **不存在之人（4星）**  
   - 代码简洁高效，通过9个状态简化实现，适合快速实现。
   - 关键技巧：使用tmp数组优化中间状态的max查询。

---

**核心代码实现（SimonGreenall）**  
```cpp
for(int j=1;j<=m;j++){    
    // 前缀和预处理
    for(int i=1;i<=n;i++) s[i]=s[i-1]+a[j][i];  
    
    // 第十一部分（I右侧）
    for(int l=1;l<=n;l++)    
        for(int r=l+2;r<=n;r++)    
            ans=max(ans,f11[l][r]=max(f11[l][r],f10[l][r])+a[j][l]+a[j][r]);    
    
    // 第十部分（I中间）
    for(int l=1;l<=n;l++)    
        for(int r=l+2;r<=n;r++)    
            f10[l][r]=max(f10[l][r],f9[l][r])+s[r]-s[l-1];    
    
    // ... 其他部分类似，通过滚动数组逐步更新状态
}
```

---

**同类型题推荐**  
1. **P1004 方格取数**（二维路径DP）  
2. **P1880 石子合并**（区间DP）  
3. **P1541 乌龟棋**（多维状态DP）

---

**可视化与复古动画实现**  
1. **像素风格渲染**：  
   - 使用Canvas绘制网格，每列宽16px，行高16px，采用FC红白机配色（如N部分用深蓝，O用绿色，I用黄色）。  
   - 当前处理列用白色边框高亮，状态转移时触发8-bit音效（如“哔”声）。  

2. **自动演示模式**：  
   - 按列逐步推进，每100ms处理一列，自动更新各状态最大值。  
   - 按空格键暂停/继续，方向键调整演示速度。  

3. **状态跟踪面板**：  
   - 右侧显示当前列各状态的最大值，如`N-part2: 24`，数值变化时用绿色闪烁提示。  

---

**个人心得摘录**  
- **SimonGreenall**：“大力DP就好啦！”体现对问题本质的直觉把握。  
- **littlez_meow**：“自己写的怎么调调不出来”反映状态转移的细节极易出错，需严谨验证。  

**关键调试教训**：中间斜杠部分的状态转移需严格满足`B_{i−1} −1 ≤ T_i ≤ T_{i−1}`，需多次用极端数据测试边界条件。

---
处理用时：73.99秒
# 题目信息

# [SDOI2010] 捉迷藏

## 题目背景

iPig 在大肥猪学校刚上完了无聊的猪文课，天资聪慧的 iPig 被这门对他来说无比简单的课弄得非常寂寞，为了消除寂寞感，他决定和他的好朋友 giPi（鸡皮）玩一个更加寂寞的游戏——捉迷藏。但是，他们觉得，玩普通的捉迷藏没什么意思，还是不够寂寞，于是，他们决定玩寂寞无比的螃蟹版捉迷藏。


## 题目描述

螃蟹版捉迷藏，顾名思义，就是说他们在玩游戏的时候只能沿水平或垂直方向走。

一番寂寞的剪刀石头布后，他们决定 iPig 去捉 giPi。由于他们都很熟悉大肥猪学校的地形了，所以 giPi 只会躲在大肥猪学校内 $N$ 个隐秘地点之一，显然 iPig 也只会在那 $N$ 个地点内找 giPi。

游戏一开始，他们从这 $N$ 个隐秘地点之中选定一个地点，iPig 保持不动，然后 giPi 用 $30$ 秒的时间逃离现场（显然，giPi 不会呆在原地）。然后 iPig 会随机地去找 giPi，直到找到为止。

由于 iPig 很懒，所以他总是走最短的路径，而且，他选择起始点不是随便选的，他想找一个地点，使得该地点到（除了这个地点以外的）最远的地点和最近的地点的距离差最小。iPig现在想知道这个距离差最小是多少。

由于 iPig 现在手上没有电脑，所以不能编程解决这个如此简单的问题，所以他马上打了个电话，要求你帮他解决这个问题。iPig 告诉了你大肥猪学校的 $N$ 个隐秘地点的坐标，请你编程求出 iPig 的问题。

## 说明/提示

$30\%$ 的数据中，$2\le N\le 10^3$；

$100\%$ 的数据中，$2\le N\le 10^5$，$0\le X_i,Y_i\le 10^9$。

数据保证点不重合。

## 样例 #1

### 输入

```
4
0 0
1 0
0 1
1 1
```

### 输出

```
1```

# AI分析结果



# [SDOI2010] 捉迷藏 题解分析

## 算法分类
**数据结构（线段树/树状数组）**

---

## 题解思路与核心难点

### 核心思路
曼哈顿距离 $|x_i-x_j| + |y_i-y_j|$ 可拆解为四个方向的极值问题：
- **左下方向**：$dis = (x_i + y_i) - (x_j + y_j)$
- **左上方向**：$dis = (x_i - y_i) - (x_j - y_j)$
- **右下方向**：$dis = (-x_i + y_i) - (-x_j + y_j)$
- **右上方向**：$dis = (-x_i - y_i) - (-x_j - y_j)$

通过两次扫描（正序和逆序），利用线段树或树状数组维护每个方向的极值，最终计算每个点的最远和最近距离差。

### 解决难点
1. **坐标离散化**：将坐标映射到较小的范围以便树状数组操作。
2. **分方向处理**：每个方向需独立维护最大值和最小值。
3. **高效查询**：通过两次扫描（正序和逆序）覆盖所有可能的相对位置。

---

## 题解评分（≥4星）

| 题解作者         | 评分 | 亮点                                                                 |
|------------------|------|----------------------------------------------------------------------|
| revenger         | ⭐⭐⭐⭐ | 线段树分方向处理极值，思路清晰，代码高效，适用于大数据规模。           |
| Orina_zju        | ⭐⭐⭐⭐ | 预处理四个极值快速计算最大值，最小距离检查邻近点，时间复杂度优秀。     |
| ModestCoder_     | ⭐⭐⭐⭐ | 树状数组实现二维偏序，代码简洁，逻辑明确，适合学习数据结构应用。       |

---

## 最优思路提炼

### 关键技巧
1. **曼哈顿距离拆解**：将绝对值拆分为四个方向，转化为极值问题。
2. **两次扫描覆盖所有情况**：正序处理左下、左上方向，逆序处理右下、右上方向。
3. **离散化+树状数组**：通过离散化坐标缩小数据范围，利用树状数组高效维护前缀/后缀极值。

### 代码片段（revenger 线段树解法核心）
```cpp
// 线段树维护极值（正序扫描）
for (int i = 1; i <= n; i++) {
    int min1 = query(1, sum[s[i].num], 1); // 左下方向最小值
    int max1 = query(1, sum[s[i].num], 2); // 左下方向最大值
    int min2 = query(sum[s[i].num], tot, 3); // 左上方向最小值
    int max2 = query(sum[s[i].num], tot, 4); // 左上方向最大值
    dis[i][0] = min(dis[i][0], min1 + s[i].x + s[i].y);
    dis[i][1] = max(dis[i][1], max1 + s[i].x + s[i].y);
    update(sum[s[i].num], -s[i].x - s[i].y, s[i].y - s[i].x);
}

// 逆序扫描处理右下、右上方向
for (int i = n; i >= 1; i--) {
    int min1 = query(1, sum[s[i].num], 1);
    int max1 = query(1, sum[s[i].num], 2);
    dis[i][0] = min(dis[i][0], min1 - s[i].x + s[i].y);
    dis[i][1] = max(dis[i][1], max1 - s[i].x + s[i].y);
    update(sum[s[i].num], s[i].x - s[i].y, s[i].y + s[i].x);
}
```

---

## 同类题目推荐
1. **P6247 [SDOI2012] 最近最远点对**  
   计算平面点集的最近和最远点对，曼哈顿距离变种。
2. **P1429 平面最近点对**  
   分治法求欧几里得距离的最近点对。
3. **CF1311F Moving Points**  
   动态点集处理，结合树状数组维护坐标偏序。

---

## 可视化算法演示

### 动画设计
1. **坐标离散化**：展示离散化过程，将大范围坐标映射到紧凑区间。
2. **线段树操作**：高亮当前插入的节点和查询区间，动态显示极值更新。
3. **方向分拆**：用不同颜色区分四个方向，逐步展示每个方向的极值计算。

### 复古像素风格
- **颜色方案**：使用 8-bit 风格，如绿色表示插入操作，红色表示查询。
- **音效触发**：插入节点时播放“哔”声，查询时播放“叮”声，完成时播放胜利音效。

---

## 总结
本题核心在于将曼哈顿距离拆解为四个方向的极值问题，结合离散化和树状数组/线段树高效维护。线段树解法在稳定性和时间复杂度上表现最优，适合处理大规模数据。

---
处理用时：88.60秒
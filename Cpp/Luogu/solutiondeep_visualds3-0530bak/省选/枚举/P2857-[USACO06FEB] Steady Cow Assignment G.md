# 题目信息

# [USACO06FEB] Steady Cow Assignment G

## 题目描述

农夫约翰的 $N$ 头牛（$1 \leq N \leq 1000$）各自居住在 $B$ 个谷仓中的一个（$1 \leq B \leq 20$），当然，谷仓的容量是有限的。有些牛非常喜欢她们当前的谷仓，而有些则不太开心。

FJ 想要重新安排这些牛，使得牛群的快乐程度尽可能均衡，即使这意味着所有的牛都讨厌她们被分配的谷仓。


每头牛都会告诉 FJ 她对谷仓的偏好顺序。牛对特定分配的快乐程度是她对该谷仓的排名。你的任务是找到一种将牛分配到谷仓的方法，使得没有谷仓的容量被超出，并且牛给她们被分配的谷仓的排名范围（即最高排名谷仓和最低排名谷仓之间的正差加一）的大小尽可能小。


## 说明/提示

样例解释：




每头牛可以被分配到她们的第一或第二选择：谷仓 1 得到牛 1 和 5，谷仓 2 得到牛 2，谷仓 3 得到牛 4，谷仓 4 得到牛 3 和 6。
（由 ChatGPT 4o 翻译）

## 样例 #1

### 输入

```
6 4
1 2 3 4
2 3 1 4
4 2 3 1
3 1 2 4
1 3 4 2
1 4 2 3
2 1 3 2```

### 输出

```
2```

# AI分析结果



# 【算法分类】  
**网络流 + 二分答案 / 枚举**

---

# 【题解思路与解决难点】  
## **核心思路**  
- **问题转化**：将牛的分配问题转化为网络流模型。源点连接牛（容量1），牛棚连接汇点（容量为牛棚容量），牛与牛棚的边根据当前枚举的排名区间动态建立。  
- **范围确定**：通过二分答案或直接枚举可能的排名区间范围（差值为x），检查是否存在合法分配。  
- **网络流验证**：对每个候选范围x，枚举所有可能的起始排名i，构建对应的网络流图，若最大流等于牛的数量n，则x可行。  

## **难点与突破**  
1. **动态建图**：每次验证需重新构建网络流图，需高效管理边的连接与重置。  
2. **时间优化**：B较小（≤20），直接枚举范围+网络流的复杂度可接受；二分答案进一步减少验证次数。  
3. **网络流模型**：正确映射牛的偏好到边的连接（仅连接候选区间的牛棚），确保容量约束。  

---

# 【题解评分 (≥4星)】  
1. **Heartlessly（5星）**  
   - **亮点**：清晰的Dinic实现，二分答案优化效率，代码结构规范。  
   - **代码可读性**：变量命名明确，注释详细。  
   - **优化**：当前弧优化提升Dinic效率。  

2. **Jayun（4星）**  
   - **亮点**：代码简洁，注释明确，直接枚举范围。  
   - **优化**：复用网络流框架，适合快速验证。  

3. **破忆（4星）**  
   - **亮点**：详细注释核心逻辑，结合二分与Dinic，适合教学。  
   - **实践性**：代码模块化，便于调试。  

---

# 【最优思路提炼】  
**关键技巧**：  
1. **候选区间枚举**：对每个可能的范围x，枚举起始排名i，构建对应的边集合。  
2. **网络流快速重置**：每次验证前清空图，动态重建边（避免内存浪费）。  
3. **二分答案优化**：通过二分减少验证次数，时间复杂度从O(B²)降至O(B log B)。  

---

# 【类似算法题目】  
1. **P3254 圆桌问题**（二分图匹配，网络流）  
2. **P2763 试题库问题**（多条件分配，网络流建模）  
3. **P3358 最长k可重区间问题**（区间覆盖，离散化+网络流）  

---

# 【可视化与算法演示】  
**动画设计**：  
1. **像素风格界面**：  
   - 牛显示为蓝色方块，牛棚为红色方块，源/汇点为绿色。  
   - 边用黄色线条表示，流量变化时闪烁。  
2. **动态建图**：  
   - 当枚举区间[i, i+x-1]时，高亮当前牛的可选牛棚，动态绘制对应边。  
   - 流量流动时，用白色像素点沿边移动示意。  
3. **音效与交互**：  
   - **成功音效**：8-bit风格上扬音调（验证通过时）。  
   - **步进控制**：空格键单步执行建图与Dinic流程。  

**关键代码（JS伪代码）**：  
```javascript  
// 动态构建网络流边  
function buildGraph(leftRank, rightRank) {  
  resetGraph(); // 清空当前图  
  for (let cow = 1; cow <= n; cow++) {  
    connectSourceToCow(cow); // 源点→牛  
    for (let r = leftRank; r <= rightRank; r++) {  
      let barn = preference[cow][r];  
      connectCowToBarn(cow, barn); // 牛→牛棚  
    }  
  }  
  for (let barn = 1; barn <= B; barn++) {  
    connectBarnToSink(barn); // 牛棚→汇点  
  }  
}  
```  

---

# 【代码片段（Heartlessly题解核心）】  
```cpp  
bool check(int x) {  
  for (int i = 1; i + x - 1 <= b; ++i) {  
    tot = 1; // 重置边  
    memset(head, 0, sizeof(head));  
    // 建图：源点→牛，牛→候选牛棚，牛棚→汇点  
    for (int j = 1; j <= n; ++j) addEdge(s, j, 1);  
    for (int j = 1; j <= b; ++j) addEdge(j + n, t, v[j]);  
    for (int j = 1; j <= n; ++j)  
      for (int k = i; k <= i + x - 1; ++k)  
        addEdge(j, f[j][k] + n, 1);  
    if (maxFlow(s, t) == n) return true;  
  }  
  return false;  
}  
```  

**核心逻辑**：  
- 每次检查候选范围x时，枚举所有可能的起始点i，构建仅包含i到i+x-1排名的边。  
- Dinic算法计算最大流，若等于n则说明分配可行。  

---

# 【个人心得】  
- **调试教训**：网络流需注意反向边的初始化（`tot`从1开始，反向边成对存储）。  
- **优化顿悟**：B较小直接枚举反而可能比二分更高效，避免复杂二分边界处理。  

---

# 【复古游戏化设计】  
- **像素绘制**：Canvas绘制16x16像素的牛/牛棚，边用1px线条表示。  
- **音效触发**：  
  - **建图完成**：短促“哔”声。  
  - **最大流成功**：播放胜利音效（类似《超级玛丽》过关）。  
- **自动演示模式**：AI自动遍历候选x，动态显示验证过程，失败时显示“GAME OVER”。

---
处理用时：87.22秒
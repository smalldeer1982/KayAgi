# 题目信息

# [HNOI2007] 分裂游戏

## 题目描述

聪聪和睿睿最近迷上了一款叫做分裂的游戏。

该游戏的规则是： 共有 $n$ 个瓶子， 标号为 $0, 1, \ldots, n-1$，第 $i$ 个瓶子中装有 $p_i$ 颗巧克力豆，两个人轮流取豆子，每一轮每人选择 $3$ 个瓶子，标号为 $i,j,k$, 并要保证 $i \lt j, j \leq k$，且第 $i$ 个瓶子中至少要有 $1$ 颗巧克力豆，随后这个人从第 $i$ 个瓶子中拿走一颗豆子并在 $j,k$ 中各放入一粒豆子（$j$ 可能等于 $k$） 。如果轮到某人而他无法按规则取豆子，那么他将输掉比赛。胜利者可以拿走所有的巧克力豆！

两人最后决定由聪聪先取豆子，为了能够得到最终的巧克力豆，聪聪自然希望赢得比赛。他思考了一下，发现在有的情况下，先拿的人一定有办法取胜，但是他不知道对于其他情况是否有必胜策略，更不知道第一步该如何取。他决定偷偷请教聪明的你，希望你能告诉他，在给定每个瓶子中的最初豆子数后是否能让自己得到所有巧克力豆，他还希望你告诉他第一步该如何取，并且为了必胜，第一步有多少种取法？ 


## 说明/提示

$1 \leq t \leq 10$，$2 \leq n \leq 21$，$0 \leq p_i \leq 10^4$，

## 样例 #1

### 输入

```
2
4
1 0 1 5000
3
0 0 1```

### 输出

```
0 2 3
1
-1 -1 -1
0```

# AI分析结果



## 算法分类
博弈论/SG函数

---

## 题解思路与核心难点

### 算法要点
1. **独立子游戏建模**：将每个豆子视为独立的有向图游戏，每个豆子的位置决定其 SG 值。
2. **奇偶性优化**：豆子数量为偶数时可用后手模仿策略抵消，仅保留奇数次异或贡献。
3. **逆向 SG 推导**：从末位瓶子开始递推 SG 值，SG[i] = mex{ SG[j] ^ SG[k] | j < k < i }。
4. **操作枚举策略**：暴力枚举所有 i<j≤k 的组合，检查异或后是否将局面转为必败态。

### 解决难点
1. **SG 函数定义**：将分裂操作视为产生两个子游戏，用异或合并游戏状态。
2. **预处理优化**：通过 O(n³) 预处理 SG 表，避免重复计算。
3. **字典序控制**：倒序枚举 i,j,k 或逆序存储瓶子编号，保证首个合法解即为字典序最小。

---

## 题解评分（≥4星）

1. **Leap_Frog（★★★★☆）**
   - 亮点：清晰预处理 SG 表，利用模 2 优化，代码简洁高效。
   - 关键代码：
     ```cpp
     for(int i=2; i<=N-4; i++)
         for(int j=1; j<=i; j++)
             for(int k=j; k<i; k++)
                 vis[sg[j]^sg[k]] = i; // SG 状态标记
     ```

2. **Ark_（★★★★☆）**
   - 亮点：逆向处理字典序问题，将瓶子倒置保证最小字典序。
   - 个人心得："从大到小枚举 i,j,k，自然获得字典序最大解，再转换回原编号即为最小字典序"。

3. **lingfunny（★★★★☆）**
   - 亮点：直接操作原编号系统，通过三重循环顺序保证字典序。
   - 代码亮点：
     ```cpp
     for(i=0; i<n; i++)
         for(j=i+1; j<n; j++)
             for(k=j; k<n; k++) // 顺序遍历确保字典序
     ```

---

## 最优思路提炼

### 关键步骤
```python
1. 预处理 SG 表（逆向递推）：
   for i from n-1 downto 1:
       mex = {}
       for j from i+1 to n:
           for k from j to n:
               mex.add(SG[j] ^ SG[k])
       SG[i] = mex(mex)

2. 计算总 SG 值：
   total = 0
   for i in 1..n:
       if p[i] % 2 == 1:
           total ^= SG[i]

3. 枚举合法操作：
   for i < j <= k:
       if (total ^ SG[i] ^ SG[j] ^ SG[k]) == 0:
           记录操作 (i,j,k)
```

### 优化技巧
- **奇偶剪枝**：只考虑奇数数量的豆子位置。
- **字典序控制**：逆序枚举或倒置瓶子编号。

---

## 类似题目推荐
1. [P2148 E&D](https://www.luogu.com.cn/problem/P2148)  
   （二维石子分裂游戏，SG 函数递推）
   
2. [P2575 高手过招](https://www.luogu.com.cn/problem/P2575)  
   （棋盘阶梯博弈，状态压缩与 SG 结合）

3. [P2964 斐波那契博弈](https://www.luogu.com.cn/problem/P2964)  
   （经典取石子变种，分析必败态规律）

---

## 可视化设计（复古像素风格）

### 动画方案
1. **SG 计算过程**：
   - **像素网格**：用 16x16 像素块表示瓶子，绿色表示当前计算的 SG[i]。
   - **高亮显示**：红色闪烁标记正在遍历的 j,k 对，蓝色显示 mex 集合。
   - **音效**：计算完成时播放 8-bit 上升音效。

2. **操作枚举演示**：
   - **自动模式**：AI 自动遍历 i,j,k，合法操作触发黄色闪光和得分音效。
   - **手动模式**：方向键选择操作，A 键确认，B 键回退。

### 代码片段（Canvas 绘制）
```javascript
// 绘制瓶子
function drawBottle(ctx, x, sg, active) {
    ctx.fillStyle = active ? '#FF5555' : '#55FF55';
    ctx.fillRect(x*20, 100 - sg*5, 16, 16); // 高度映射 SG 值
}

// 音效触发
function playSFX(type) {
    const sfx = {
        compute: new Audio('data:audio/wav;base64,UklGRl9...'), 
        success: new Audio('data:audio/wav;base64,UklGRk9...')
    };
    sfx[type].play();
}
```

---

## 核心代码实现
```cpp
// SG 预处理（Leap_Frog 方案）
const int N = 25;
int sg[N], vis[N];
void pre_sg() {
    sg[1] = 0;
    for(int i=2; i<N; i++) {
        memset(vis, 0, sizeof vis);
        for(int j=1; j<i; j++)
            for(int k=j; k<i; k++)
                vis[sg[j]^sg[k]] = 1;
        for(int mex=0; ; mex++)
            if(!vis[mex]) { sg[i] = mex; break; }
    }
}

// 主逻辑
int main() {
    pre_sg();
    int T; cin >> T;
    while(T--) {
        int n, sum = 0; cin >> n;
        vector<int> a(n);
        for(int i=0; i<n; i++) {
            cin >> a[i];
            if(a[i] % 2) sum ^= sg[n - i];
        }
        // 枚举操作（略）
    }
}
```

---

通过上述分析，可清晰掌握 SG 函数在此类分裂博弈中的应用，并通过可视化加深对状态转移的理解。

---
处理用时：78.68秒
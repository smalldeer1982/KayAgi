# 题目信息

# [HNOI2016] 矿区

## 题目描述

平面上的矿区划分成了若干个开发区域。

简单地说，你可以将矿区看成一张连通的平面图，平面图划分为了若干平面块，每个平面块即为一个开发区域，平面块之间的边界必定由若干整点(坐标值为整数的点)和连接这些整点的线段组成。每个开发区域的矿量与该开发区域的面积有关：具体而言，面积为 $ s $ 的开发区域的矿量为 $ s^2 $。

现在有 $ m $ 个开采计划。每个开采计划都指定了一个由若干开发区域组成的多边形，一个开采计划的优先度被规定为矿量的总和÷开发区域的面积和；例如，若某开采计划指定两个开发区域，面积分别为 $ a $ 和 $ b $，则优先度为 $ (a^2+b^2)/(a+b) $。由于平面图是按照划分开发区域边界的点和边给出的，因此每个开采计划也只说明了其指定多边形的边界，并未详细指明是哪些开发区域（但很明显，只要给出了多边形的边界就可以求出是些开发区域）。

你的任务是求出每个开采计划的优先度。为了避免精度问题，你的答案必须按照分数的格式输出，即求出分子和分母，且必须是最简形式（分子和分母都为整数，而且都消除了最大公约数；例如，若矿量总和是 $ 1.5 $，面积和是 $ 2 $，那么分子应为 $ 3 $，分母应为 $ 4 $；又如，若矿量和是 $ 2 $，面积和是 $ 4 $，那么分子应为 
 $ 1 $，分母应为 $ 2 $）。

由于某些原因，你必须依次对每个开采计划求解（即下一个开采计划会按一定格式加密，加密的方式与上一个开采计划的答案有关）。具体的加密方式见输入格式。

## 说明/提示

### 样例解释

输入文件给出的 $9$ 个点和 $14$ 条边描述的平面图如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/cg70enmo.png)

第一个开采计划，输入的第 $1$ 个值为 $3$，所以该开采计划对应的多边形有 $(3+0)\bmod 8+1=4$ 个点，将接下的 $4$ 个数 $3,0,4,7$，分别代入 $(z_i+0)\bmod n+1$ 得到 $4$ 个点的编号为 $4,1,5,8$。计算出第一个开采计划的分子为 $1$，分母为 $1$。

类似地，可计算出余下开采计划的多边形的点数和点的编号：第二个开采计划对应的多边形有 $3$ 个点，编号分别为 $5,6,8$。第三个开采计划对应的多边形有 $6$ 个点，编号分别为 $1,2,6,5,8,4$。第四个开采计划对应的多边形有 $5$ 个点，编号分别为 $1,2,6,8,4$。第五个开采计划对应的多边形有 $6$ 个点，编号分别为 $1,5,6,8,7,4$。

### 数据范围及约定


对于 $ 100 \% $ 的数据，$ n, k \leq 2 \times 10^5, \  m \leq 3n-6, \  |x_i|, |y_i| \leq 3×10^4$。

所有开采计划的 $ d $ 之和不超过 $2 \times 10^6$。保证任何开采计划都包含至少一个开发区域，且这些开发区域构成一个连通块。

保证所有开发区域的矿量和不超过 $ 2^{63}-1 $。

保证平面图中没有多余的点和边。

保证数据合法。由于输入数据量较大，建议使用读入优化。




## 样例 #1

### 输入

```
9 14 5
0 0
1 0
2 0
0 1
1 1
2 1
0 2
1 2
2 2
1 2
2 3
5 6
7 8
8 9
1 4
4 7
5 8
3 6
6 9
4 8
1 5
2 6
6 8
3 3 0 4 7 1 3 4 6 4 8 0 4 3 6 2 3 8 0 4 6 2 5 0 4 5 7 6 3```

### 输出

```
1 1 
1 2 
1 1 
9 10 
3 4```

# AI分析结果



## 唯一算法分类
平面图转对偶图

---

## 综合分析与结论

### 核心思路
1. **平面图转对偶图**：将原平面图的每个面转为对偶图的节点，边的邻接关系通过极角排序确定。
2. **生成树构建**：以无界面（面积负数的面）为根建立生成树，记录子树面积和面积平方和。
3. **查询处理**：遍历查询多边形的边，通过判断树边的父子关系进行容斥计算。

### 核心难点
- **面的划分**：需通过极角排序确定每条边的后继边，正确划分面的边界。
- **生成树维护**：需在DFS过程中记录子树和，并标记父子关系。
- **加密输入处理**：需动态调整查询参数，保证正确性。

### 可视化设计
1. **平面图转对偶图动画**：
   - **步骤1**：用不同颜色绘制原平面图的点和边。
   - **步骤2**：动态显示极角排序过程，箭头标记每条边的极角方向。
   - **步骤3**：高亮当前遍历的边链，生成对偶图的节点（面）。
2. **生成树构建演示**：
   - **根节点标记**：用红色高亮无界面。
   - **DFS过程**：递归展开生成树，用绿色箭头表示树边。
3. **查询处理交互**：
   - **遍历边界边**：用闪烁效果标记当前处理的边。
   - **子树加减**：用半透明色块表示累加/减去的区域，右侧实时显示ans1/ans2的数值变化。

---

## 题解清单 (≥4星)

### 1. litble（5星）
- **亮点**：代码结构清晰，极角排序与面划分逻辑完整，生成树DFS过程注释详细。
- **关键代码**：
  ```cpp
  void build() {
    for(RI i=1;i<=n;++i) sort(h[i].begin(),h[i].end());
    for(RI i=2;i<=tot;++i) {
      int v=e[i].v;
      vector<edge>::iterator kl=lower_bound(h[v].begin(),h[v].end(),e[i^1]);
      if(kl==h[v].begin()) kl=h[v].end();
      --kl,nxt[i]=(*kl).id;
    }
    // ...面划分与对偶图构建
  }
  ```

### 2. _Sein（4星）
- **亮点**：图解父子关系容斥逻辑，解释非树边忽略机制。
- **心得引用**：  
  > "如果在边界上碰到一条树边，判断方向后对贡献取正负即可，取绝对值同理。"

### 3. Mars_Dingdang（4星）
- **亮点**：代码模块化程度高，叉积计算与面积维护逻辑清晰。
- **关键优化**：在极角排序时直接使用`atan2`结果，避免浮点误差。

---

## 核心代码实现

### 平面图转对偶图（litble版）
```cpp
void build() {
  for(RI i=1;i<=n;++i) sort(h[i].begin(),h[i].end());
  for(RI i=2;i<=tot;++i) {
    int v=e[i].v;
    auto kl=lower_bound(h[v].begin(),h[v].end(),e[i^1]);
    if(kl==h[v].begin()) kl=h[v].end();
    --kl; nxt[i] = kl->id; // 找反向边的极角前驱
  }
  for(RI i=2;i<=tot;++i) {
    if(pos[i]) continue;
    pos[i]=pos[nxt[i]]=++cnt;
    for(int j=nxt[i]; e[j].v!=e[i].u; j=nxt[j]) // 遍历闭合区域
      s[cnt] += (p[e[j].u]-p[e[i].u])*(p[e[j].v]-p[e[i].u]);
    if(s[cnt]<=0) rt=cnt; // 标记无界面
  }
}
```

### 生成树维护子树和
```cpp
void dfs(int x,int las) {
  f[x]=las, ss[x]=1LL*s[x]*s[x], s[x]<<=1, vis[x]=1;
  for(auto e:tr[x]) {
    int v=e.v;
    if(vis[v]) continue;
    istr[e.id]=istr[e.id^1]=1; // 标记树边
    dfs(v,x);
    s[x]+=s[v], ss[x]+=ss[v]; // 累加子树和
  }
}
```

---

## 相似题目推荐
1. **P3248 矿场建设**（平面图与连通性结合）
2. **P3829 信用卡凸包**（极角排序与几何处理）
3. **P3388 割点**（图论生成树应用）

---

## 可视化方案（复古像素风格）

### 动画设计
- **颜色方案**：16色调色板，原图边用青色，对偶图节点用黄色，生成树边用绿色。
- **音效**：
  - **边遍历**：8-bit "哔"声（Web Audio生成方波）
  - **面闭合**：上扬音效
  - **错误操作**：低音"咚"声
- **自动演示**：按空格键切换手动/自动模式，自动模式按算法步骤逐步执行。

### 核心Canvas绘制逻辑
```javascript
function drawStep(ctx, step) {
  ctx.fillStyle = '#000'; 
  ctx.fillRect(0,0,W,H); // 清空画布
  // 绘制原平面图边
  edges.forEach(e => {
    drawEdge(ctx, e, '#0FF'); 
    if(e.highlight) drawArrow(ctx, e); // 高亮当前边
  });
  // 绘制对偶图面节点
  dualNodes.forEach(n => {
    drawCircle(ctx, n.center, n.isRoot ? '#F00' : '#FF0');
  });
}
```

---
处理用时：69.97秒
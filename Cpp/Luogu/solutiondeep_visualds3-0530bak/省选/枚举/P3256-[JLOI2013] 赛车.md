# 题目信息

# [JLOI2013] 赛车

## 题目描述

这里有一辆赛车比赛正在进行，赛场上一共有 $n$ 辆车，分别称为个 $g_1,g_2,...,g_n$。赛道是一条无限长的直线。最初，$g_i$ 位于距离起跑线前进 $k_i$ 的位置。比赛开始后，车辆 $g_i$ 将会以 $v_i$ 单位每秒的恒定速度行驶。在这个比赛过程中，如果一辆赛车曾经处于领跑位置的话（即没有其他的赛车跑在他的前面），这辆赛车最后就可以得奖，而且比赛过程中不用担心相撞的问题。现在给出所有赛车的起始位置和速度，你的任务就是算出那些赛车将会得奖。


## 说明/提示

#### 数据范围与约定

- 对于 $100\%$ 的数据，$1 \le n \le 10^4$，$0 \le k_i \le 10^9$，$0 \le v_i \le 10^9$。

## 样例 #1

### 输入

```
4
1 1 0 0
15 16 10 20```

### 输出

```
3
1 2 4```

# AI分析结果



## **算法分类**  
单调栈 / 半平面交

---

## **题解思路与核心难点分析**  

### **核心思路对比**  
1. **单调栈**  
   - 按速度排序，维护栈中可能领跑的车辆  
   - 关键条件：若新加入的车 `a` 追上栈顶 `b` 的时间早于 `b` 追上栈中前一辆车 `c` 的时间，则 `b` 永远无法领跑，弹出  
   - 处理特殊情况：速度相同且位置相同则合并  

2. **半平面交**  
   - 将每辆车的运动轨迹视为直线，求半平面交的上边界  
   - 关键难点：处理大值域下的精度问题（例如 `eps=1e-18`）  
   - 合并完全相同的直线对应的赛车  

3. **暴力解法**  
   - 枚举每辆车，计算其可能领先的时间窗口  
   - 复杂度 `O(n²)`，但因数据限制可通过  

---

## **题解评分 (≥4星)**  
1. **tylon2006（4.5星）**  
   - 思路清晰，代码简洁，但未处理相同车辆  
   - 亮点：巧妙利用时间比较条件维护单调栈  

2. **WangHansen（5星）**  
   - 完整处理相同速度和位置的车辆，合并相同车辆  
   - 代码可读性高，附带详细注释与调试记录  

3. **genshy（4星）**  
   - 半平面交实现完整，合并相同直线  
   - 处理大值域精度问题，代码结构清晰  

---

## **最优思路与技巧提炼**  
1. **单调栈维护领跑序列**  
   - 按速度升序排序，位置降序排序  
   - 动态维护栈，通过比较追及时间剔除无效车辆  
   - 处理相同车辆：合并后统一记录结果  

2. **关键条件公式**  
   - 计算追及时间：`t = (k_i - k_j) / (v_j - v_i)`  
   - 若 `a` 追上 `b` 的时间 < `b` 追上 `c` 的时间 → `b` 无法领跑  

3. **合并相同车辆**  
   - 使用 `map` 或排序预处理，合并速度和位置相同的车辆  

---

## **类似题目推荐**  
1. **[HNOI2008] 水平可见直线**（半平面交/单调栈）  
2. **[USACO15OPEN] Bessie's Dream**（半平面交优化路径）  
3. **[CF1131G] Most Dangerous Shark**（单调栈维护决策序列）  

---

## **可视化与动画设计**  
### **算法演示（单调栈）**  
1. **动画流程**  
   - **初始状态**：所有车辆按速度排序，初始位置在右侧显示  
   - **栈操作**：新车辆入栈时，动态计算追及时间，高亮比较过程  
   - **出栈条件**：红色标记被剔除车辆，绿色标记保留车辆  

2. **复古像素风格**  
   - **车辆显示**：8位像素方块表示车辆，颜色区分速度  
   - **音效设计**：  
     - 入栈时播放“滴”声，出栈时播放“咔”声  
     - 最终结果展示时播放胜利音效  

3. **交互控制**  
   - **步进按钮**：单步执行入栈/出栈操作  
   - **速度调节**：滑动条控制动画速度  

---

## **代码片段（单调栈核心逻辑）**  
```cpp
sort(a + 1, a + n + 1, [](data x, data y) {
    return x.v == y.v ? x.k > y.k : x.v < y.v;
});

stk[++top] = 1;
for (int i = 2; i <= n; i++) {
    // 处理相同车辆
    if (a[i].v == a[stk[top]].v && a[i].k == a[stk[top]].k) {
        mergeSameCar(i);
        continue;
    }
    // 动态维护栈
    while (top && (
        (a[i].k > a[stk[top]].k) || 
        (top > 1 && tim(a[stk[top]], a[i]) < tim(a[stk[top-1]], a[stk[top]]))
    )) top--;
    stk[++top] = i;
}
```

---

## **总结与扩展**  
本题核心在于识别领跑车辆的**时间窗口交叠**，通过排序和单调性优化剔除无效车辆。  
**关键思维**：将动态追及问题转化为静态序列维护，利用几何性质或半平面交简化复杂的时间关系。

---
处理用时：68.58秒
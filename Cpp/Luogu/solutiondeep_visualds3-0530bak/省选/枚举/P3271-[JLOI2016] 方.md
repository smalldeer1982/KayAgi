# 题目信息

# [JLOI2016] 方

## 题目描述

上帝说，不要圆，要方，于是便有了这道题。

由于我们应该方，而且最好能够尽量方，所以上帝派我们来找正方形上帝把我们派到了一个有 $N$ 行 $M$ 列的方格图上，图上一共有 $(N+1)\times(M+1)$ 个格点，我们需要做的就是找出这些格点形成了多少个正方形（换句话说，正方形的四个顶点都是格点）。

但是这个问题对于我们来说太难了，因为点数太多了，所以上帝删掉了这 $(N+1)\times(M+1)$ 中的 $K$ 个点。既然点变少了，问题也就变简单了，那么这个时候这些格点组成了多少个正方形呢？


## 样例 #1

### 输入

```
2 2 4
1 0
1 2
0 1
2 1```

### 输出

```
1```

# AI分析结果



# 算法分类选择  
**容斥原理、几何计算**

---

# 题解思路、算法要点与解决难点  

## 核心思路  
采用容斥原理，将答案拆分为：  
`答案 = 无坏点的正方形 - 至少1个坏点的正方形 + 至少2个坏点的 - 至少3个坏点的 + 至少4个坏点的`  

## 算法要点  
1. **无坏点计算（f0）**  
   通过枚举正放正方形的边长，每个边长为i的正放正方形对应i个斜放正方形。公式：  
   $$\sum_{i=1}^{\min(n,m)} i \times (n-i+1) \times (m-i+1)$$  

2. **至少1个坏点（f1）**  
   对每个坏点，计算其作为顶点或边上的正方形数量。核心公式为：  
   $$g(l,r,h) = \frac{t(t+3)}{2} - \text{非法部分}$$  
   其中t为可扩展的最大边长，l/r为左右剩余空间，h为上下剩余空间。  

3. **至少2/3/4个坏点（f2-f4）**  
   枚举两个坏点，通过向量运算推导另外两个顶点坐标，判断是否存在：  
   - 以两点为边 → 两种可能正方形  
   - 以两点为对角线 → 一种可能正方形  

## 解决难点  
1. **斜正方形的快速推导**  
   使用向量旋转公式：若两点为P、Q，则另外两点可表示为：  
   $$R = P + (Q-P) \times \begin{bmatrix} 0 & -1 \\ 1 & 0 \end{bmatrix}$$  

2. **重复计数处理**  
   - 每个含k个坏点的正方形会被C(k,2)次枚举到  
   - 最终结果需除以组合数（如f3除以3，f4除以6）  

---

# 题解评分 (≥4星)  

| 作者       | 评分 | 亮点 |  
|------------|------|------|  
| cmd2001    | ★★★★☆ | 代码结构清晰，使用unordered_set高效查点，几何推导完整 |  
| _Sein      | ★★★★☆ | 数学推导详细，边界处理严谨，容斥系数处理正确 |  
| 破壁人五号 | ★★★★  | 代码模块化设计，分函数处理不同情况，可读性强 |  

---

# 最优思路或技巧提炼  

1. **坐标哈希优化**  
   将点坐标编码为`x*(m+1)+y`存入哈希表，实现O(1)查点。  
   ```cpp  
   unordered_set<lli> st;  
   lli h = (lli)p.x * (m+1) + p.y;  
   ```  

2. **向量旋转公式**  
   快速计算正方形顶点：  
   ```cpp  
   Point delta = (a-b).swp(); // 旋转90度向量  
   Point c = a + delta, d = b + delta;  
   ```  

3. **容斥系数修正**  
   对含k个坏点的正方形，统计时需除以组合数：  
   ```cpp  
   tri /= 3; // C(3,2)=3  
   qua /= 6; // C(4,2)=6  
   ```  

---

# 同类型题与算法套路  

1. **容斥+几何组合问题**  
   如统计矩形、三角形等几何图形的组合计数问题  

2. **坐标哈希+枚举优化**  
   适用于需要快速判断点存在的几何问题，如[CF1398D](https://codeforces.com/problemset/problem/1398/D)  

---

# 推荐相似题目  

1. [P2735 电网](https://www.luogu.com.cn/problem/P2735)  
2. [CF630K](https://codeforces.com/problemset/problem/630/K)（容斥原理）  
3. [AT_abc311_g](https://atcoder.jp/contests/abc311/tasks/abc311_g)（几何+枚举）  

---

# 个人心得摘录  

> "计算垂直向量时没加负号调了半天，老年选手身败名裂" —— cmd2001  
> 关键点：几何问题需特别注意坐标系方向，建议先画图验证公式  

---

# 可视化算法分析  

## 核心流程演示  
1. **枚举正放正方形**  
   - **动画**：红色边框的正放正方形逐步扩大，内部蓝色斜正方形逐个生成  
   - **高亮**：当前边长的正放正方形，对应斜正方形数量显示在右侧  

2. **坏点影响计算**  
   - **标记坏点**：坏点显示为骷髅图标  
   - **扩展过程**：以坏点为中心，黄色区域展示可能的正方形扩展范围  

3. **两坏点枚举**  
   - **连线效果**：两点间显示三种可能的正方形（红、蓝、绿）  
   - **顶点检测**：自动标记存在的顶点为绿色，缺失为红色  

## 复古像素风格设计  
- **8位调色板**：正放正方形（#FF0000）、斜正方形（#0000FF）、坏点（#FFFFFF）  
- **音效**：  
  - 正确找到正方形：8-bit上升音阶  
  - 坏点冲突：爆炸音效  
- **自动演示**：按空格切换手动/自动模式，自动模式逐步展示计算过程  

```javascript  
// 示例：Canvas绘制正放正方形  
ctx.fillStyle = '#FF0000';  
ctx.strokeRect(x*scale, y*scale, i*scale, i*scale);  
// 绘制斜正方形  
ctx.strokeStyle = '#0000FF';  
ctx.beginPath();  
ctx.moveTo((x+a)*scale, (y+b)*scale);  
ctx.lineTo((x+c)*scale, (y+d)*scale);  
// ...绘制其他边  
```  

---

# 关键代码片段  

```cpp  
// 计算至少2个坏点的正方形  
lli calcdouble(const Point &a, const Point &b) {  
    const Point delta = (a-b).swp(); // 旋转90度向量  
    int ret = legal(a+delta, b+delta) + legal(a-delta, b-delta);  
    const Point mid = a + b;  
    if ((mid + delta).candiv() && (mid - delta).candiv()) {  
        ret += legal((mid+delta)/2, (mid-delta)/2);  
    }  
    return ret;  
}  
```  

---

通过上述分析和可视化设计，可深入理解容斥原理在几何计数问题中的高效应用，同时掌握坐标变换与哈希优化的核心技巧。

---
处理用时：75.25秒
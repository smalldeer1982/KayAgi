# 题目信息

# [POI 2012] ODL-Distance

## 题目描述

**译自 POI 2012 Stage 1. 「[Distance](https://szkopul.edu.pl/problemset/problem/Phel_x2Ny30OUh7z1RhCtzEG/site/?key=statement)」**

定义一次「操作」为将一个正整数除以或乘以一个质数。定义函数 $d(a,b)$ 表示将 $a$ 进行若干次“操作”变成 $b$ 所需要的最小操作次数。例如，$d(69,42)=3$.

$d$ 显然是一个距离函数，满足以下性质：
* $d(a,a) = 0$
* $d(a,b) = d(b,a)$
* $d(a,b) + d(b,c) \ge d(a,c)$

给定 $n$ 个正整数 $a_1, a_2, \ldots, a_n$，对每个 $a_i (1 \le i \le n)$，求 $j$ 使得 $j \neq i$ 且 $d(a_i,a_j)$ 最小。如果有多个满足条件的 $j$，应输出最小的那个。

## 说明/提示

对于 $30\%$ 的数据有 $n \le 1000$.

对于所有数据有 $2 \le n \le 10^5,1 \le a_i \le 10^6$.

翻译来自于 [LibreOJ](https://loj.ac/p/2690)。

## 样例 #1

### 输入

```
6
1
2
3
4
5
6```

### 输出

```
2
1
1
2
1
2```

# AI分析结果



### 算法分类选择
**数论 + 预处理优化**

---

### 题解思路与核心难点分析

#### 核心公式推导
所有题解均基于以下关键公式：
$$d(a_i,a_j) = cnt(a_i) + cnt(a_j) - 2 \cdot cnt(\gcd(a_i,a_j))$$
其中 $cnt(x)$ 表示 $x$ 的质因数指数和（如 $12=2^2 \cdot 3^1$ 对应 $cnt=3$）

#### 实现要点
1. **线性筛预处理**：用欧拉筛法预处理所有数的质因数个数 $cnt$，时间复杂度 $O(n)$
2. **枚举因数优化**：对每个数 $a_i$，枚举其所有因数 $d$，维护每个因数 $d$ 对应的最小和次小值（存储下标）
3. **次小值处理**：为避免 $i=j$，需维护次小值，当最小值与当前数冲突时使用次小值
4. **调和级数枚举**：预处理时通过倍数枚举优化，时间复杂度 $O(n \sqrt{m})$（$m$ 为值域）

#### 解决难点
- **避免 $i=j$ 冲突**：通过维护次小值确保选择的 $j \neq i$
- **高效枚举因数**：利用因数分解的对称性（枚举到 $\sqrt{a_i}$ 即可）
- **正确性保证**：即使枚举的 $d$ 不是实际 $\gcd$，正确解必然会被覆盖

---

### 题解评分（≥4星）

#### 1. lhm_（5星）
- **亮点**：完整处理次小值，代码清晰，预处理与查询逻辑分离
- **代码片段**：
```cpp
void update(int d,int x) {
    if(cnt[a[x]]<cnt[a[mn1[d]]]) mn2[d]=mn1[d],mn1[d]=x;
    else if(...) // 次小值更新逻辑
}
```

#### 2. ThinkofBlank（4.5星）
- **亮点**：详细注释解释次小值必要性，维护双值数组结构清晰
- **关键代码**：
```cpp
for(int j=sqrt(now);j;--j){ // 对称枚举因数
    update(j,i); update(a[i]/j,i);
}
```

#### 3. Cells（4星）
- **亮点**：使用 vector 存储因数，预处理与查询分离，可读性强
- **核心逻辑**：
```cpp
for(int x : fct[i]) query(i,x); // 预处理因数加速查询
```

---

### 最优思路提炼
1. **质因数指数和预处理**：线性筛预处理 $cnt$ 数组
2. **因数倍数双向处理**：枚举因数 $d$ 及其互补因数 $a_i/d$
3. **最小-次小维护**：对每个因数 $d$ 维护最小和次小值下标，确保 $j \neq i$
4. **查询时动态比较**：遍历所有因数，计算最小距离并记录最优下标

---

### 同类题目推荐
1. **P2303 [Longge的问题]**（gcd 相关数论）
2. **P2424 约数和**（因数分解与预处理）
3. **P1414 又是毕业季II**（最大公约数与倍数处理）

---

### 可视化与算法演示设计

#### 核心动画方案
1. **质因数分解展示**：
   - 用不同颜色方块表示质因数（如红色=2，蓝色=3）
   - 动态显示 $a_i$ 和 $a_j$ 的质因数分解及重合部分（gcd）

2. **因数枚举过程**：
   - 高亮当前枚举的因数 $d$，显示其对应的最小/次小值
   - 步进显示对每个因数的更新操作

3. **动态比较视图**：
   - 并列显示当前最优解与候选解的距离计算
   - 当发现更优解时触发闪烁特效

#### 复古游戏化设计
1. **8-bit 像素风格**：
   - 质因数用 16x16 像素块表示，背景音乐使用 chiptune 风格
   - 成功找到解时播放《超级马里奥》金币音效

2. **自动演示模式**：
   - AI 自动选择下一个操作，用不同颜色路径显示枚举过程
   - 可调节速度观察预处理和查询的详细步骤

3. **交互控制面板**：
   - 暂停/继续按钮
   - 单步执行模式（观察每个因数处理）
   - 速度调节滑块（1x-10x）

---

### 代码实现（关键片段）
```cpp
// 线性筛预处理 cnt[]
void init() {
    for(int i=2;i<=maxx;++i) {
        if(!vis[i]) prime[++tot]=i, cnt[i]=1;
        for(int j=1; prime[j]*i<=maxx; ++j) {
            cnt[i*prime[j]] = cnt[i] + 1;
            if(i%prime[j]==0) break;
        }
    }
}

// 更新最小/次小值
void update(int d, int x) {
    if(cnt[a[x]] < cnt[a[mn1[d]]]) {
        mn2[d] = mn1[d];
        mn1[d] = x;
    } else if(...) { /* 次小值处理 */ }
}

// 主查询逻辑
for(int i=1; i<=n; ++i) {
    int min_dis = INF, ans_id = 0;
    for(int d : factors[a[i]]) {
        int j = (mn1[d]==i) ? mn2[d] : mn1[d];
        int dis = cnt[a[i]] + cnt[a[j]] - 2*cnt[d];
        if(dis < min_dis) min_dis = dis, ans_id = j;
    }
    printf("%d\n", ans_id);
}
```

---

### 总结
本题解通过巧妙的因数枚举与预处理优化，将复杂度降至 $O(n \sqrt{m})$，核心在于维护每个因数的最优解并正确处理下标冲突。同类问题可借鉴质因数分解与调和级数枚举的思想。

---
处理用时：74.13秒
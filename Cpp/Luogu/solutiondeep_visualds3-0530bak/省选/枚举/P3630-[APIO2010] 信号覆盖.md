# 题目信息

# [APIO2010] 信号覆盖

## 题目描述

一家电信公司正在北京城搭建一个 GSM 网络。城市里共有 n 个房子需要被 信号覆盖。由于经费的限制，电信公司只能安装一个天线。 这里将每个房子用一个点坐标来表示。为了简化天线的放置，电信公司将会 选择其中的 3 个房子作一个外接圆，然后将天线放在圆的中心，所有位于这个圆 内或者圆的边界上的房子都将被天线的信号所覆盖。 电信公司将会随机选择城市中的 3 个房子来搭建天线，他们想知道在所有可 能放置天线的方案中平均会有多少个房子被信号覆盖。 例如，假设共有 4 个房子 A, B, C, D，它们的位置如下图：

  ![](https://cdn.luogu.com.cn/upload/pic/4405.png) 

如果我们选择ABC或者BCD三个点搭建的外接圆，所有的房子都会被覆盖。 如果我们选择 ACD 或者 ABD，剩下的房子将不会在天线的信号覆盖范围内。因 此平均有(4 + 4 + 3 + 3) / 4 = 3.50 个房子被信号覆盖。 给定所有房子的位置，你的任务是计算平均有多少个房子被信号覆盖。假定 每一个房子都有一个二维的整数坐标，并且保证任何三个房子都不在同一条直线 上，任何四个房子都不在同一个圆上。


## 说明/提示

【样例说明】

3.5, 3.50, 3.500, … 中的任何一个输出均为正确。此外，3.49, 3.51, 3.499999，…等也都是可被接受的输出。

【数据范围】

100%的数据保证，对于 i = 1, 2, .., n, 第 i 个房子的坐标(xi, yi)为整数且 –1,000,000 ≤ xi, yi ≤ 1,000,000. 任何三个房子不在同一条直线上，任何四个房子不 在同一个圆上；

40%的数据，n ≤ 100；

70%的数据，n ≤ 500；

100%的数据，3 ≤ n ≤ 1,500。


## 样例 #1

### 输入

```
4
0 2 
4 4 
0 0 
2 0```

### 输出

```
3.500 ```

# AI分析结果



## 算法分类
**计算几何 & 组合数学**

---

## 题解思路与核心难点

### 核心思路
所有三元组外接圆的平均覆盖点数转化为四边形的贡献问题：
- **凸四边形**贡献 2 点，**凹四边形**贡献 1 点。
- 总贡献公式：`总贡献 = 3*C(n,3) + 凹四边形数 + 2*凸四边形数`。
- 通过极角排序和双指针统计凹四边形数，避免 O(n⁴) 暴力枚举。

### 解决难点
1. **四边形分类**：如何高效区分凹凸四边形。
2. **凹四边形计数**：枚举每个点作为凹点，极角排序后统计同一侧的点数，利用组合数快速计算。
3. **极角排序优化**：通过破环为链和双指针维护极角范围，将复杂度降至 O(n² log n)。

---

## 高星题解推荐（≥4★）

1. **huayucaiji（★★★★★）**
   - **亮点**：配图详细解释凹凸四边形贡献，极角排序与双指针实现清晰。
   - **代码**：极角排序后用组合数容斥统计凹四边形，逻辑严谨。

2. **Hammer_cwz_77（★★★★）**
   - **亮点**：明确给出凸/凹四边形贡献公式，代码逻辑简洁。
   - **不足**：代码为 Pascal 语言，需转换为 C++ 理解。

3. **xkai（★★★★）**
   - **亮点**：拆分圆覆盖贡献为边和三角形部分，创新使用等差数列求和。
   - **不足**：实现复杂度较高，需双重极角排序。

---

## 最优思路提炼

### 关键步骤
1. **枚举凹点**：对每个点 D，统计以 D 为凹点的凹四边形数。
2. **极角排序**：将其他点以 D 为原点进行极角排序。
3. **双指针统计**：固定一个点 A，找到最远点 C 使得所有点位于同一侧，计算组合数 C(j-i, 2)。
4. **组合数容斥**：总凹四边形数 = Σ(所有可能三角形数 - 同一侧三角形数)。

### 代码片段（C++ 核心逻辑）
```cpp
for (int k = 1; k <= n; k++) {
    vector<Point> points; // 存储极角排序后的点
    for (int i = 1; i <= n; i++) 
        if (i != k) points.push_back(Point(x[i]-x[k], y[i]-y[k]));
    sort(points.begin(), points.end(), polar_angle_cmp); // 极角排序
    
    int m = points.size();
    for (int i = 0; i < m; i++) points.push_back(points[i]); // 破环为链
    
    int r = 0, same_side_cnt = 0;
    for (int l = 0; l < m; l++) {
        while (r < l + m && cross(points[l], points[r]) >= 0) r++;
        same_side_cnt += C(r - l - 1, 2); // 统计同一侧三点组合数
    }
    concave_count += C(m, 3) - same_side_cnt; // 凹四边形数累加
}
```

---

## 同类型题拓展

1. **统计四点共圆数**：需判断四点是否在同一圆上（本题保证无此情况）。
2. **凸包顶点贡献**：如 [洛谷 P2742] 计算凸包周长。
3. **极角排序应用**：如 [洛谷 P2992] 统计三角形包含原点的情况。

---

## 推荐类似题目

1. **P2992 [COCI 2008] 三角形计数**  
   （极角排序统计包含原点的三角形数）
2. **P2742 [USACO5.1] 圈奶牛**  
   （计算几何求凸包）
3. **P3829 [SHOI2012] 信用卡凸包**  
   （极角排序与凸包结合）

---

## 可视化设计

### 算法演示（极角排序与双指针）
1. **像素化点阵**：在 Canvas 中用 8x8 像素块表示点，凹点用红色，其他点用绿色。
2. **极角射线绘制**：从凹点发射射线，动态绘制当前点的极角范围。
3. **双指针高亮**：用蓝色/黄色块表示左右指针位置，指针移动时播放“滴”声。
4. **统计面板**：右侧显示当前凹点编号、已统计的凹四边形数、总贡献值。

### 复古音效
- **指针移动**：短促“滴”声（Web Audio API 生成方波）。
- **统计完成**：8-bit 胜利音效（三音阶上升旋律）。
- **错误提示**：低音“嘟”声。

### 自动演示模式
- **AI 控制速度**：每步延迟 500ms，自动切换凹点并绘制极角排序结果。
- **手动步进**：用户可点击“Next”单步执行双指针移动。

---

## 总结

本题通过计算几何技巧（极角排序+双指针）与组合数学结合，将 O(n⁴) 问题优化至 O(n² log n)。核心在于利用四边形的凹凸性质分解贡献，并通过极角排序高效统计同一侧点。可视化设计中，极角排序的动态演示和双指针交互能直观展示算法核心逻辑。

---
处理用时：70.40秒
# 题目信息

# [APIO2015] 雅加达的摩天楼

## 题目描述

印尼首都雅加达市有 $N$ 座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为 $0$ 到 $N − 1$。除了这 $N$ 座摩天楼外，雅加达市没有其他摩天楼。

有 $M$ 只叫做 “doge” 的神秘生物在雅加达市居住，它们的编号依次是 $0$ 到 $M − 1$。编号为 $i$ 的 doge 最初居住于编号为 $B_i$ 的摩天楼。每只 doge 都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为 $i$ 的 doge 的跳跃能力为 $P_i$ （$P_i > 0$）。

在一次跳跃中，位于摩天楼 $b$ 而跳跃能力为 $p$ 的 doge 可以跳跃到编号为 $b - p$ （如果 $0 \leq b - p < N$）或 $b + p$ （如果 $0 \leq b + p < N$）的摩天楼。

编号为 $0$ 的 doge 是所有 doge 的首领，它有一条紧急的消息要尽快传送给编号为 $1$ 的 doge。任何一个收到消息的 doge 有以下两个选择:

- 跳跃到其他摩天楼上；
- 将消息传递给它当前所在的摩天楼上的其他 doge。

请帮助 doge 们计算将消息从 $0$ 号 doge 传递到 $1$ 号 doge 所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到 $1$ 号 doge。


## 说明/提示

【样例解释】

下面是一种步数为 $5$ 的解决方案：

$0$ 号 doge 跳跃到 $2$ 号摩天楼，再跳跃到 $4$ 号摩天楼（$2$ 步）。

$0$ 号 doge 将消息传递给 $2$ 号 doge。

$2$ 号 doge 跳跃到 $3$ 号摩天楼,接着跳跃到 $2$ 号摩天楼，再跳跃到 $1$ 号摩天楼（$3$ 步）。

$2$ 号 doge 将消息传递给 $1$ 号 doge。

【数据范围】

所有数据都保证 $0 \leq B_i < N$。

子任务 1 （10 分）$1 \leq N \leq 10$

$1 \leq P_i \leq 10$

$2 \leq M \leq 3$


子任务 2 （12 分）$1 \leq N \leq 100$

$1 \leq P_i \leq 100$

$2 \leq M \leq 2000$


子任务 3 （14 分）$1 \leq N \leq 2000$

$1 \leq P i ≤ 2000$

$2 \leq M \leq 2000$


子任务 4 （21 分）$1 \leq N \leq 2000$

$1 \leq P_i \leq 2000$

$2 \leq M \leq 30000$


子任务 5 （43 分）$1 \leq N \leq 30000$

$1 \leq P_i \leq 30000$

$2 \leq M \leq 30000$


## 样例 #1

### 输入

```
5 3
0 2
1 1
4 1```

### 输出

```
5```

# AI分析结果



**唯一算法分类**: 分块优化 + BFS/最短路径

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   - 将跳跃能力分为大、小两部分处理：  
     - **小跳跃（p ≤ k）**：建立分层图（虚点），每个虚点代表某跳跃能力下的位置，通过预连边（步长=1）减少重复计算。  
     - **大跳跃（p > k）**：直接暴力连边，每只 doge 的跳跃次数不超过 O(n/k)，总边数可控。  
   - **关键变量**：分块阈值 k = min(√n, 100)，平衡分层图与暴力连边的复杂度。

2. **解决难点**  
   - **状态爆炸**：直接 (i, p) 的状态数为 O(n²)，分块后降为 O(n√n)。  
   - **高效判重**：使用 `bitset` 或哈希记录状态 (i, p) 是否已访问，避免重复入队。  
   - **跳跃路径优化**：小跳跃通过分层图预处理，大跳跃直接按步数跳转，避免显式建图。

3. **算法流程**  
   1. **预处理分层图**：对每个 p ≤ k，预连虚点间的边（步长=1）。  
   2. **初始状态入队**：将起点所在位置的所有 doge 加入队列。  
   3. **BFS/SPFA 扩展**：每次从队列取出状态 (i, p)，尝试左右跳跃或更换 doge。  
   4. **终点判断**：若到达终点所在位置，返回当前步数。

---

### **题解评分 (≥4星)**

1. **浮尘ii（5星）**  
   - **亮点**：直接 BFS + 分块，代码简洁高效，使用 `bitset` 判重，时间复杂度 O(n√n)。  
   - **关键代码**：状态转移时动态插入新位置与跳跃能力。  
   ```cpp
   void insert(int i, int p, int step) {
     if (!Vis[i]) {  // 首次访问i，激活所有在此的doge
       Vis[i] = true;
       for (auto x : Doge[i]) Q.emplace(i, x, step);
     }
     if (!vis[i].test(p)) Q.emplace(i, p, step);
   }
   ```

2. **StudyingFather（4星）**  
   - **亮点**：分层图与分块结合，显式建图后跑 Dijkstra，适合理解分块优化思想。  
   - **关键代码**：分块建虚点并连边。  
   ```cpp
   for (int i = 1; i <= maxp; i++)
     for (int j = 0; j < n; j++) {
       addedge(id[i][j], j, 0);  // 虚点回原点
       if (j + i < n) addedge(id[i][j], id[i][j + i], 1);  // 向右跳
     }
   ```

3. **RichardSong（4星）**  
   - **亮点**：分块阈值动态计算，SPFA 实现更优时间，代码紧凑。  
   - **关键代码**：分块处理与连边。  
   ```cpp
   int blank = min(100, (int)sqrt(n));
   for (int i = 1; i <= blank; ++i) {
     for (int j = 0; j < n - i; ++j) {
       add(id(j, i), id(j + i, i), 1);  // 向右跳
     }
   }
   ```

---

### **最优思路或技巧提炼**

1. **分块思想**  
   - 将跳跃能力按阈值 k 分为两类：小跳跃预处理，大跳跃暴力枚举。  
   - **数学依据**：总复杂度为 O(nk + n²/k)，当 k = √(n/3) 时最优。

2. **状态压缩**  
   - 使用 (i, p) 表示状态，跳跃能力隐含在分层图中，无需显式记录所有路径。  
   - **判重优化**：`bitset` 替代哈希表，降低常数开销。

3. **动态激活 doge**  
   - 首次到达某位置时，激活该位置所有 doge 的跳跃能力，避免重复处理。

---

### **同类型题或类似算法套路**

- **分块优化**：如 [CF786B Legacy](https://www.luogu.com.cn/problem/CF786B)，线段树优化建图。  
- **分层图最短路**：如 [P4568 飞行路线](https://www.luogu.com.cn/problem/P4568)，分层处理多次免费机会。  
- **状态压缩 BFS**：如 [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)，记录步数与位置。

---

### **推荐洛谷题目**

1. **P1902 刺杀大使**  
   - **相似点**：二分答案 + BFS 最短路径。  
   - **题号**：[P1902](https://www.luogu.com.cn/problem/P1902)

2. **P2296 寻找道路**  
   - **相似点**：预处理有效路径 + BFS。  
   - **题号**：[P2296](https://www.luogu.com.cn/problem/P2296)

3. **P1948 电话线**  
   - **相似点**：分层图最短路，费用转化为边权。  
   - **题号**：[P1948](https://www.luogu.com.cn/problem/P1948)

---

### **可视化与算法演示**

**动画方案设计**：

1. **网格绘制**：  
   - 使用 Canvas 绘制摩天楼（横轴），不同颜色区分实点与虚点。  
   - **实点**：蓝色方块；**虚点（p≤k）**：绿色方块（层高随 p 变化）。  

2. **跳跃演示**：  
   - **当前状态 (i, p)**：高亮红色边框。  
   - **跳跃路径**：黄色线条连接跳跃前后的点，显示步数。  

3. **自动模式**：  
   - **AI 控制**：自动选择下一步扩展的状态，模拟 BFS 队列过程。  
   - **速度调节**：滑块控制每帧延迟（100ms~1s）。  

4. **音效反馈**：  
   - **跳跃成功**：8-bit 上升音效。  
   - **到达终点**：胜利音效 + 闪烁动画。  

**交互示例**（伪代码）：
```javascript
// 初始化 Canvas
const ctx = canvas.getContext('2d');
const gridSize = 20;
function drawNode(i, p, color) {
  const x = i * gridSize;
  const y = p * gridSize;  // 虚点按层排列
  ctx.fillStyle = color;
  ctx.fillRect(x, y, gridSize, gridSize);
}

// 播放跳跃动画
function animateJump(from, to, p) {
  drawNode(from, p, 'red');
  setTimeout(() => {
    drawNode(from, p, 'blue');
    drawNode(to, p, 'red');
  }, 500);
}
```

---

### **个人心得摘录**

- **浮尘ii**：  
  > “原题数据较水，建议去 UOJ 提交验证正确性。”  
  - **教训**：本地测试通过不代表算法完全正确，需多平台验证。  

- **GoldenPotato137**：  
  > “分块阈值取 100 仅是经验值，实际应根据复杂度公式调整。”  
  - **调试**：阈值需通过理论计算而非盲目尝试。  

- **wurzang**：  
  > “SPFA 在本题中表现优于 Dijkstra，因边权为 1 或 0。”  
  - **优化**：根据问题特性选择更合适的最短路算法。

---
处理用时：91.34秒
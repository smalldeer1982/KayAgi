# 题目信息

# [SDOI2017] 数字表格

## 题目背景

Doris 刚刚学习了 fibonacci 数列。用 $f_i$ 表示数列的第 $i$ 项，那么

$$f_0=0,f_1=1$$

$$f_n=f_{n-1}+f_{n-2},n\geq 2$$

## 题目描述

Doris 用老师的超级计算机生成了一个 $n\times m$ 的表格，

第 $i$ 行第 $j$ 列的格子中的数是 $f_{\gcd(i,j)}$，其中 $\gcd(i,j)$ 表示 $i,j$ 的最大公约数。


Doris 的表格中共有 $n\times m$ 个数，她想知道这些数的乘积是多少。

答案对 $10^9+7$ 取模。


## 说明/提示

#### 数据规模与约定

- 对于 $10\%$ 的数据，保证 $n,m\leq 10^2$。
- 对于 $30\%$ 的数据，保证 $n,m\leq 10^3$。
- 另有 $30\%$ 的数据，保证 $T\leq 3$。
- 对于 $100\%$ 的数据，保证 $1 \leq T\leq 10^3$，$1\leq n,m\leq 10^6$。


## 样例 #1

### 输入

```
3
2 3
4 5
6 7```

### 输出

```
1
6
960```

# AI分析结果



---

## 算法分类  
**莫比乌斯反演 + 数论分块**

---

## 题解思路与难点对比  
### 核心算法流程  
1. **数学推导**  
   - 将原式转换为关于 gcd 的乘积形式：$\prod_{i,j} f_{\gcd(i,j)}$  
   - 通过莫比乌斯反演将指数转化为 $\sum_{d|T} \mu(d) \cdot \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor$  
   - 引入变量替换 $T = dk$，得到 $\prod_{T} (\prod_{d|T} f_d^{\mu(T/d)})^{\lfloor n/T \rfloor \lfloor m/T \rfloor}$  

2. **预处理关键数组**  
   - $F(T) = \prod_{d|T} f_d^{\mu(T/d)}$，预处理所有 $T$ 的 $F(T)$  
   - 利用埃氏筛法，枚举每个 $d$ 的倍数 $T$，根据 $\mu(T/d)$ 的值乘以 $f_d$ 或其逆元  

3. **数论分块优化**  
   - 外层对 $\lfloor n/T \rfloor \lfloor m/T \rfloor$ 分块，内层通过前缀积快速计算区间乘积  

### 难点与解决方案  
- **指数部分的处理**：通过 $\mu$ 函数的性质将双重求和转换为单层乘积，避免直接计算高复杂度指数  
- **预处理复杂度**：采用 $O(n \log n)$ 的暴力筛法预处理 $F(T)$，而非线性筛（无法线性筛此类函数）  
- **逆元优化**：预处理斐波那契数的逆元，避免每次计算快速幂  

---

## 题解评分  
### 五星级题解  
1. **yybyyb**  
   - **亮点**：公式推导清晰，代码简洁高效，预处理逻辑明确  
   - **代码**：通过埃氏筛法预处理 $F(T)$，外层数论分块处理查询  

2. **小粉兔**  
   - **亮点**：详细推导数学变换，强调逆元处理的注意事项  
   - **代码**：显式处理 $\mu$ 的符号，优化快速幂调用次数  

3. **shadowice1984**  
   - **亮点**：分步推导配注释，强调变量替换的直观理解  
   - **代码**：使用前缀积和区间逆元计算，逻辑紧凑  

---

## 最优思路提炼  
### 关键步骤  
1. **数学转换**：  
   $$\prod_{i,j} f_{\gcd(i,j)} \Rightarrow \prod_T F(T)^{\lfloor n/T \rfloor \lfloor m/T \rfloor}$$  
2. **预处理 $F(T)$**：  
   - 对每个 $d$，枚举其倍数 $T$，根据 $\mu(T/d)$ 决定乘 $f_d$ 或 $f_d^{-1}$  
3. **分块计算**：  
   - 外层分块计算 $\lfloor n/T \rfloor \lfloor m/T \rfloor$，内层用前缀积加速  

### 代码片段  
```cpp  
void pre() {
    f[1] = 1; mu[1] = 1;
    for (int i = 2; i <= MAXN; ++i) {
        f[i] = (f[i-1] + f[i-2]) % MOD;
        inv_f[i] = qpow(f[i], MOD-2); // 预处理逆元
    }
    for (int i = 1; i <= MAXN; ++i) {
        if (!mu[i]) continue;
        for (int j = i; j <= MAXN; j += i) {
            F[j] = F[j] * (mu[i] == 1 ? f[j/i] : inv_f[j/i]) % MOD;
        }
    }
    for (int i = 2; i <= MAXN; ++i) F[i] = F[i] * F[i-1] % MOD;
}
```

---

## 同类型题推荐  
1. **P3312 [SDOI2014] 数表**  
   - 类似莫比乌斯反演 + 数论分块，结合约数和性质  
2. **P3768 简单的数学题**  
   - 高难度反演，涉及杜教筛与数论分块结合  
3. **P2257 YY的GCD**  
   - 基础反演题，练习 $\gcd$ 求和与筛法优化  

---

## 可视化与算法演示  
### 动画设计  
1. **预处理阶段**  
   - **网格绘制**：展示每个 $d$ 如何更新其倍数 $T$ 的贡献  
   - **颜色标记**：$\mu=1$ 时用绿色箭头（表示乘法），$\mu=-1$ 时用红色箭头（表示除法）  

2. **分块计算**  
   - **块划分**：动态显示 $\lfloor n/T \rfloor$ 和 $\lfloor m/T \rfloor$ 的分块区间  
   - **高亮当前块**：用黄色框标记当前计算的 $T$ 区间  

3. **复古像素风格**  
   - **Canvas 绘制**：用 8-bit 像素风格显示数论分块步骤  
   - **音效触发**：每次分块切换时播放经典 FC 音效  

### 交互控制  
- **步进控制**：允许单步执行分块过程，观察每个块的贡献计算  
- **参数调节**：动态修改 $n$ 和 $m$，实时显示计算结果变化  

---

## 个人心得  
- **调试教训**：预处理时未处理 $\mu=0$ 导致数组越界，需显式跳过无效计算  
- **优化技巧**：将 $\prod_{d|T} f_d^{\mu(T/d)}$ 的预处理从 $O(n^2)$ 优化为 $O(n \log n)$  

---

## 完整代码  
```cpp  
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int MOD = 1e9+7, MAXN = 1e6+5;
int mu[MAXN], f[MAXN], inv_f[MAXN], F[MAXN], prime[MAXN], cnt;
bool vis[MAXN];

int qpow(int a, int b) {
    int res = 1;
    for (; b; b >>= 1, a = 1LL*a*a%MOD) 
        if (b & 1) res = 1LL*res*a%MOD;
    return res;
}

void init() {
    mu[1] = 1;
    for (int i = 2; i <= MAXN; ++i) {
        if (!vis[i]) prime[++cnt] = i, mu[i] = -1;
        for (int j = 1; j <= cnt && i*prime[j] <= MAXN; ++j) {
            vis[i*prime[j]] = 1;
            if (i % prime[j] == 0) { mu[i*prime[j]] = 0; break; }
            mu[i*prime[j]] = -mu[i];
        }
    }
    f[1] = 1;
    for (int i = 2; i <= MAXN; ++i) 
        f[i] = (f[i-1] + f[i-2]) % MOD;
    for (int i = 1; i <= MAXN; ++i) 
        inv_f[i] = qpow(f[i], MOD-2);

    fill(F, F+MAXN, 1);
    for (int i = 1; i <= MAXN; ++i) {
        if (mu[i] == 0) continue;
        for (int j = i; j <= MAXN; j += i) {
            int val = (mu[i] == 1) ? f[j/i] : inv_f[j/i];
            F[j] = 1LL * F[j] * val % MOD;
        }
    }
    for (int i = 2; i <= MAXN; ++i) 
        F[i] = 1LL * F[i] * F[i-1] % MOD;
}

int solve(int n, int m) {
    int res = 1;
    for (int l = 1, r; l <= min(n, m); l = r + 1) {
        r = min(n/(n/l), m/(m/l));
        int prod = 1LL * F[r] * qpow(F[l-1], MOD-2) % MOD;
        int ex = 1LL * (n/l) * (m/l) % (MOD-1);
        res = 1LL * res * qpow(prod, ex) % MOD;
    }
    return res;
}

int main() {
    init();
    int T; scanf("%d", &T);
    while (T--) {
        int n, m; scanf("%d%d", &n, &m);
        printf("%d\n", solve(n, m));
    }
    return 0;
}
```

---
处理用时：124.73秒
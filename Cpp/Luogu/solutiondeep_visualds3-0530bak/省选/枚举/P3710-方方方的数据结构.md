# 题目信息

# 方方方的数据结构

## 题目描述

在很久很久以前，有一个长度为 $n$ 的数列，一开始数列全是 $0$。

方方方觉得这个数列太单调了，打算对它进行 $m$ 次操作，每次操作为区间加法或者区间乘法。

方方方进行一些操作之后，还可能会对某个数进行询问。

但是进行过一些操作之后，方方方可能会发现之前某次操作失误了，需要撤销这次操作，其它操作和其它操作的前后顺序保持不变。

方方方想好这些操作之后，马上想到了一个优秀的数据结构可以维护这些东西，可是他懒得写标程了，就生成了 $10$ 个**随机数据**，就把这道题扔给了你。

**数据全是随机的，生成方式见最下方的提示。**


## 说明/提示

对于 $20\%$ 的数据，$n,m \leq 500$，时限 1s。

对于 $50\%$ 的数据，$n,m \leq 30000$，时限 1s。

对于 $100\%$ 的数据，$1 \leq n,m \leq 150000$，$1 \le l \le r \le n$，$3$ 操作的 $p$ 满足 $1 \le p \le n$，$4$ 操作的 $p$ 满足 $1 \le p \le m$，$0 \leq d \leq 1073741823$（原因见数据生成器），时限 4.5s。


数据生成器：

```cpp
#include <bits/stdc++.h>
using namespace std;
int rand_() {return rand()&32767;} 
int br() {return rand_()*32768+rand_();}
vector<int> cs;
int main()
{
    srand(...); //这里要填一个种子 
    int n=...,m=...; //这里要填n、m
    cout<<n<<" "<<m<<"\n";
    for(int i=1;i<=m;i++)
    {
        int o=rand()%4+1;
        if(o<=2)
        {
            cout<<o<<" ";
            int l=br()%n+1,r=br()%n+1;
            if(l>r) swap(l,r); cs.push_back(i);
            cout<<l<<" "<<r<<" "<<br()<<"\n";
        }
        else if(o==3) cout<<o<<" "<<br()%n+1<<"\n";
        else
        {
            if(!cs.size()) {--i; continue;}
            int s=br()%cs.size(),g=cs[s];
            cs.erase(cs.begin()+s);
            cout<<o<<" "<<g<<"\n";
        }
    }
}
```

## 样例 #1

### 输入

```
6 14
1 1 5 1
2 2 4 3
1 2 6 5
3 2
4 1
3 3
2 1 3 4
3 3
1 2 2 3
3 2
4 7
3 1
3 2
3 3```

### 输出

```
8
5
20
23
0
8
5```

# AI分析结果



**唯一算法分类**  
二维平面矩形修改与单点查询（KD-Tree / 四叉树）

---

### **题解思路、算法要点与解决难点**

1. **核心思路**  
   将每个操作的影响视为时间轴（操作生效时间段）和序列位置（操作区间）构成的二维矩形。  
   - **撤销操作**：离线处理后确定每个操作的生效时间区间 `[start_time, end_time]`。  
   - **矩形修改**：区间加法/乘法对应二维平面上矩形区域的叠加（乘法为系数，加法为偏移）。  
   - **单点查询**：在查询点 `(位置, 时间)` 处累计所有覆盖该点的矩形操作的影响。

2. **算法实现要点**  
   - **KD-Tree**：通过递归分割平面构建树结构，支持高效范围修改和单点查询。  
     - **节点存储**：每个节点维护子树的最小/最大坐标范围和标记（加/乘系数）。  
     - **懒标记下传**：在修改时对完全覆盖的子树直接更新标记，否则递归处理子节点。  
   - **四叉树**：将二维平面递归四等分，预处理所有查询点以减少空间占用。  
   - **离线处理**：先收集所有查询点坐标，仅在这些点上构建树结构，避免无效空间消耗。

3. **解决难点**  
   - **高效处理动态撤销**：离线计算每个操作的有效时间区间，将动态撤销转化为静态矩形区域。  
   - **二维范围修改优化**：通过懒标记和剪枝策略（判断矩形是否与当前子树范围相交）减少计算量。  
   - **随机数据适配**：KD-Tree 在随机数据下树高接近 `O(log n)`，保证整体复杂度 `O(m log m)`。

---

### **题解评分 (≥4星)**

1. **kczno1（5星）**  
   - **亮点**：简洁的 KD-Tree 实现，离线处理时间区间，代码可读性高。  
   - **关键代码**：`build` 函数通过 `nth_element` 分割平面，`add` 函数递归更新子树标记。

2. **Great_Influence（5星）**  
   - **亮点**：四叉树实现，预处理查询点，空间优化至 `O(m log m)`，时间复杂度稳定。  
   - **关键代码**：`preget` 预建查询点，`pls` 和 `tim` 分别处理加/乘操作的递归范围更新。

3. **FxorG（4星）**  
   - **亮点**：KD-Tree 的完整实现，支持动态插入与查询，代码结构清晰。  
   - **关键代码**：`update1` 和 `update2` 分别处理加法和乘法的矩形范围修改。

---

### **最优思路或技巧提炼**

1. **离线时间轴处理**  
   预处理所有操作的生效时间区间，将撤销操作转化为静态时间区间 `[start, end]`，避免动态维护。

2. **二维平面离散化**  
   - **KD-Tree**：通过 `nth_element` 分割平面，保证树平衡。  
   - **四叉树**：仅对实际查询点预建树结构，减少无效节点。

3. **懒标记优化**  
   - **标记合并**：加法与乘法标记合并为线性变换 `val = a * val + b`，通过矩阵乘法合并多次操作。  
   - **剪枝策略**：若当前子树范围与修改矩形无交，则直接跳过递归。

---

### **同类型题或类似算法套路**

- **矩形覆盖问题**：如 [P3755 [CQOI2017]老C的任务](https://www.luogu.com.cn/problem/P3755)，用二维前缀和或树状数组处理。  
- **动态区间统计**：如 [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)，离线按右端点排序后用树状数组维护。  
- **带撤销操作的数据结构**：如 [P2056 [ZJOI2007]捉迷藏](https://www.luogu.com.cn/problem/P2056)，利用时间分块或持久化数据结构。

---

### **推荐相似题目**

1. **P1903 [国家集训队]数颜色 / 维护队列**（带修改的莫队算法）  
2. **P3332 [ZJOI2013]K大数查询**（二维线段树/整体二分）  
3. **P3810 【模板】三维偏序（陌上花开）**（CDQ分治或KD-Tree）

---

### **可视化与算法演示**

**动画设计**：  
1. **像素网格**：用 Canvas 绘制二维平面，横轴为序列位置，纵轴为时间。  
2. **操作矩形**：  
   - 加法操作为蓝色矩形，乘法为红色矩形，透明度表示操作强度。  
   - 撤销操作时，原矩形变为灰色并标记终止时间。  
3. **查询点高亮**：绿色像素表示当前查询点，逐步显示其受影响的矩形区域。  
4. **音效触发**：  
   - 添加操作：短促“滴”声。  
   - 撤销操作：低沉“嗡”声。  
   - 成功查询：清脆“叮”声。  

**交互功能**：  
- **步进控制**：滑块调节动画速度，按钮单步执行。  
- **自动演示**：AI 模式按时间顺序自动执行操作，展示矩形覆盖和查询结果。  

**复古风格**：  
- **8位调色板**：使用 NES 风格的 16 色调色板（如 #1A1C2C、#7DC0C9）。  
- **音效生成**：Web Audio API 合成 8-bit 音效（方波+噪声）。  

---

### **代码片段（四叉树核心逻辑）**

```cpp
// 四叉树范围加法（Great_Influence 题解）
void pls(int h, int l0, int r0, int l1, int r1, int u0, int v0, int u1, int v1, int delt) {
    if (!h) return;
    if (u0 <= l0 && r0 <= v0 && u1 <= l1 && r1 <= v1) {
        add[h] = ad(add[h], delt);
        return;
    }
    int md0 = (l0 + r0) >> 1, md1 = (l1 + r1) >> 1;
    pushdown(h);
    if (u0 <= md0) {
        if (u1 <= md1) pls(son[h][0][0], l0, md0, l1, md1, u0, v0, u1, v1, delt);
        if (v1 > md1) pls(son[h][0][1], l0, md0, md1+1, r1, u0, v0, u1, v1, delt);
    }
    if (v0 > md0) {
        if (u1 <= md1) pls(son[h][1][0], md0+1, r0, l1, md1, u0, v0, u1, v1, delt);
        if (v1 > md1) pls(son[h][1][1], md0+1, r0, md1+1, r1, u0, v0, u1, v1, delt);
    }
}
```

---

### **总结**

本题通过将动态操作转化为静态二维平面问题，结合高效数据结构（KD-Tree / 四叉树）实现快速范围修改与查询。离线处理和懒标记优化是关键，适合随机数据下的高效求解。可视化设计可增强对二维覆盖过程的理解，复古风格增添学习趣味性。

---
处理用时：94.27秒
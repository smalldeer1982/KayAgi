# 题目信息

# [TJOI2017] 城市

## 题目描述

从加里敦大学城市规划专业毕业的小明来到了一个地区城市规划局工作。这个地区一共有 $n$ 座城市，$n-1$ 条高速公路，保证了任意两运城市之间都可以通过高速公路相互可达，但是通过一条高速公路需要收取一定的交通费用。小明对这个地区深入研究后，觉得这个地区的交通费用太贵。

小明想彻底改造这个地区，但是由于上司给他的资源有限，因而小明现在只能对一条高速公路进行改造，改造的方式就是去掉一条高速公路，并且重新修建一条一样的高速公路（即交通费用一样），使得这个地区的两个城市之间的最大交通费用最小（即使得交通费用最大的两座城市之间的交通费用最小），并且保证修建完之后任意两座城市相互可达。如果你是小明，你怎么解决这个问题？


## 说明/提示

对于 $30\%$ 的数据，$1\leq n\leq 500$。

对于 $100\%$ 的数据，$1\leq n\leq 5000$。


## 样例 #1

### 输入

```
5
1 2 1
2 3 2
3 4 3
4 5 4```

### 输出

```
7```

# AI分析结果



# 算法分类  
**树的直径与动态规划**

---

## 题解思路与解决难点对比

### 核心逻辑
1. **枚举断边**：所有题解均基于枚举每条可能的断边，将原树分割为两个子树
2. **子树处理**：对每个子树计算：
   - 子树直径（最长路径）
   - 子树半径（连接新边时所需的最小最大距离）
3. **最优连接**：通过连接两子树中半径最小的点，使得新路径的最长距离最小化

### 关键实现差异
| 题解              | 直径计算                          | 半径计算                          | 时间复杂度优化                    |
|-------------------|----------------------------------|----------------------------------|----------------------------------|
| getchar123        | BFS两次求直径端点                | 维护直径中点单调性                | 仅遍历新增节点，总O(n)            |
| shadowice1984     | 树形DP求最长/次长链              | 换根DP动态维护子树外最长距离      | 固定4次DFS，O(n)                 |
| QwQcOrZ           | 树形DP同时记录最长/次长链        | 二次换根DP求全局最远距离          | 预处理+动态维护，O(n²)           |
| duyi              | 换根法求每个点的最远距离         | 枚举每个点作为根的最远距离        | 无优化，O(n²)                    |

---

## 题解评分（≥4星）

### 1. getchar123（5星）
- **亮点**：通过直径端点的性质优化遍历次数，时间复杂度严格O(n)
- **核心代码**：
  ```cpp
  while(zhongd<i&&max(diss[lb[zhongd].x],qwq-diss[lb[zhongd].x])>...)
    zhongd++; //动态维护中点位置
  ```

### 2. shadowice1984（4.5星）
- **亮点**：四遍DFS清晰分离直径与半径计算，代码可读性强
- **核心代码**：
  ```cpp
  if(v==mv[x]) getr(v,max(nxdp[x]+val,fr+val));
  else getr(v,max(dp[x]+val,fr+val)); //换根时分类讨论
  ```

### 3. QwQcOrZ（4星）
- **亮点**：通过二次换根实现动态维护，算法思路直观
- **核心代码**：
  ```cpp
  Max[now] = max(Max1[now], Max0[now]); //综合子树内外最长距离
  ```

---

## 最优思路提炼

### 关键技巧
1. **直径端点性质**：任意子树的直径必含原树直径端点
2. **中点单调性**：当断边沿直径移动时，半径中点位置单调后移
3. **换根DP范式**：
   - 第一遍DFS求子树内最长链
   - 第二遍DFS传递子树外最长链

### 实现模板
```cpp
// 求子树内最长链
void dfs1(int u, int fa) {
    for (auto [v,w] : g[u]) if (v != fa) {
        dfs1(v, u);
        if (f[v] + w > f[u]) {
            f2[u] = f[u];
            f[u] = f[v] + w;
        } else if (f[v] + w > f2[u]) 
            f2[u] = f[v] + w;
    }
}

// 换根求全局最长链
void dfs2(int u, int fa, int up) {
    radius = min(radius, max(f[u], up));
    for (auto [v,w] : g[u]) if (v != fa) {
        int new_up = w + max(up, (f[v]+w == f[u]) ? f2[u] : f[u]);
        dfs2(v, u, new_up);
    }
}
```

---

## 可视化设计

### 动画方案
1. **直径标记**：红色高亮原树直径路径
2. **断边扫描**：
   - 蓝色箭头沿直径移动，展示当前断边位置
   - 分裂出的子树用绿色/黄色区分
3. **半径计算**：
   - 紫色脉冲波从子树中心扩散，显示半径范围
   - 实时显示两子树半径值r1、r2

### 复古像素实现
```javascript
// Canvas绘制直径路径
function drawDiameter() {
  ctx.strokeStyle = '#FF0000'; // 8位红色
  diameterNodes.forEach((node, i) => {
    if (i > 0) {
      ctx.beginPath();
      ctx.moveTo(diameterNodes[i-1].x*20+10, diameterNodes[i-1].y*20+10);
      ctx.lineTo(node.x*20+10, node.y*20+10);
      ctx.stroke();
    }
  });
}

// 断边扫描特效
function scanCutEdge() {
  let currentEdge = 0;
  const interval = setInterval(() => {
    const edge = diameterEdges[currentEdge];
    drawEdge(edge, '#00FFFF'); // 青色高亮
    currentEdge++;
    if (currentEdge >= diameterEdges.length) clearInterval(interval);
  }, 500);
}
```

---

## 相似题目推荐
1. **P1099 树网的核** - 求树上偏心距最小路径
2. **P4408 逃学的小孩** - 树直径端点性质应用
3. **P5536 核心节点** - 换根DP求最优连接点

---

## 个人心得摘录
> "在枚举断边时发现，非直径上的断边对答案无影响，这是优化到O(n)的关键" —— getchar123  
> "调试时发现次长链的更新条件容易遗漏，必须严格判断是否等于当前最长链" —— shadowice1984

---

## 核心代码实现
```cpp
// shadowice1984的半径计算核心
void getr(int x,int fr) {
    rad = min(rad, max(fr, dp[x]));
    for(int i=head[x];i;i=edge[i].nxt) {
        int v=edge[i].to, w=edge[i].val;
        if(book[v]) {
            if(v == mv[x]) // 当前节点是父节点最长链来源
                getr(v, max(nxdp[x]+w, fr+w));
            else 
                getr(v, max(dp[x]+w, fr+w));
        }
    }
}
```

---
处理用时：70.74秒
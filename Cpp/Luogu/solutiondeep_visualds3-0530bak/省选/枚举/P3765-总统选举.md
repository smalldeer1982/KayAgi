# 题目信息

# 总统选举

## 题目背景

黑恶势力的反攻计划被小 C 成功摧毁，黑恶势力只好投降。秋之国的人民解放了，举国欢庆。此时，原秋之国总统因没能守护好国土，申请辞职，并请秋之国人民的大救星小 C 钦定下一任。

作为一名民主人士，小 C 决定举行全民大选来决定下一任。为了使最后成为总统的人得到绝大多数人认同，小 C 认为，一个人必须获得超过全部人总数的一半的票数才能成为总统。如果不存在符合条件的候选人，小 C 只好自己来当临时大总统。为了尽可能避免这种情况，小 C 决定先进行几次小规模预选，根据预选的情况，选民可以重新决定自己选票的去向。

由于秋之国人数较多，统计投票结果和选票变更也成为了麻烦的事情，小 C 找到了你，让你帮他解决这个问题。

## 题目描述

秋之国共有 $n$ 个人，分别编号为 $1,2,…,n$，一开始每个人都投了一票，范围 $1 \sim n$，表示支持对应编号的人当总统。

共有 $m$ 次预选，每次选取编号 $[l_i,r_i]$ 内的选民展开小规模预选，在该区间内获得超过区间大小一半的票的人获胜。如果没有人获胜，则由小 C 钦定一位候选者获得此次预选的胜利（获胜者可以不在该区间内），每次预选的结果需要公布出来，并且每次会有 $k_i$ 个人决定将票改投向该次预选的获胜者。

全部预选结束后，公布最后成为总统的候选人。

## 说明/提示

对于前 $20 \%$ 的数据，$1 \leq n,m \leq 5000$。

对于前 $40 \%$ 的数据，$1 \leq n,m \leq 50000$，$\sum k_i \leq 50000$。

对于前 $50 \%$ 的数据，$1 \leq n,m \leq {10}^5$，$\sum k_i \leq 2 \times {10}^5$。

对于数据点 6~7，保证所有选票始终在 $1 \sim 10$ 之间。

对于 $100 \%$ 的数据，$1 \leq n,m \leq 5 \times {10}^5$，$\sum k_i \leq 10^6$，$1 \leq l_i \leq r_i \leq n$，$1 \leq s_i \leq n$。

## 样例 #1

### 输入

```
5 4
1 2 3 4 5
1 2 1 1 3
5 5 1 2 2 4
2 4 2 0
3 4 2 1 4```

### 输出

```
1
5
5
2
-1```

# AI分析结果



# 算法分类  
**线段树与平衡树结合**

---

## 核心思路与难点分析  

### 核心算法流程  
1. **摩尔投票法**：利用线段树维护区间众数候选，合并区间时优先保留出现次数多的候选  
2. **平衡树验证**：对每个候选人维护支持者的下标集合，通过平衡树快速查询区间内的票数  
3. **动态更新**：修改操作时同步更新线段树和平衡树  

### 可视化设计要点  
- **线段树合并动画**：  
  1. 用不同颜色表示左右子区间的候选人和计数  
  2. 合并时展示候选人的替换和计数变化（如红蓝方块碰撞后保留较多的一方）  
- **平衡树查询动画**：  
  1. 高亮查询区间[l, r]的起始点  
  2. 展示通过平衡树的二分查找统计票数（如绿色高亮命中节点）  
- **复古像素风格**：  
  1. 线段树用8-bit像素块表示，每个节点显示候选人和计数  
  2. 平衡树用网格布局，支持者下标以像素点阵形式呈现  

---

## 题解评分与亮点  

### ★★★★★ 作者：LengChu  
- **亮点**：  
  1. 使用线段树维护摩尔投票结果，保证合并效率  
  2. 平衡树精确统计票数，避免误判  
  3. 完整的代码封装（线段树+Splay）  
- **核心代码**：  
  ```cpp  
  void pushup(int id) {
      if(tree[ls].num == tree[rs].num) 
          tree[id].num=tree[ls].num, tree[id].cnt=tree[ls].cnt+tree[rs].cnt;
      else {
          if(tree[ls].cnt >= tree[rs].cnt) 
              tree[id].cnt=tree[ls].cnt-tree[rs].cnt, tree[id].num=tree[ls].num;
          else 
              tree[id].cnt=tree[rs].cnt-tree[ls].cnt, tree[id].num=tree[rs].num;
      }
  }
  ```

### ★★★★☆ 作者：Ynoi  
- **亮点**：  
  1. 随机采样降低时间复杂度至O(k logn)  
  2. 使用`pb_ds`库的红黑树快速实现平衡树  
- **核心代码**：  
  ```cpp
  int solve(int l,int r) {
      for(int i=1; i<=14; i++) { // 随机采样14次
          int x = rand()%(r-l+1)+l;
          if(s[a[x]].order_of_key(r+1) - s[a[x]].order_of_key(l) > (r-l+1)/2)
              return a[x];
      }
      return -1;
  }
  ```

### ★★★★☆ 作者：EnofTaiPeople  
- **亮点**：  
  1. 根号分治策略，小范围暴力+大范围预筛选  
  2. 动态维护高频候选人的集合  
- **核心代码**：  
  ```cpp
  if(r-l <= 2000) { // 小范围暴力统计
      for(x=l; x<=r; x++) 
          if(++cnt[a[x]] > threshold) break;
  } else { // 大范围预筛选高频候选人
      for(int x : candidate_list) 
          if(check(x) > threshold) break;
  }
  ```

---

## 相似题目推荐  
1. **P2397 yyy loves Maths VI**（摩尔投票法基础）  
2. **P3567 [POI2014]KUR-Couriers**（区间绝对众数查询）  
3. **P4137 Rmq Problem / mex**（区间特性统计问题）  

---

## 可视化方案示例（JavaScript伪代码）  
```javascript
// 线段树合并动画
function animateMerge(left, right) {
    ctx.fillStyle = "#FF6666"; // 左区间颜色
    drawNode(left);
    ctx.fillStyle = "#66B2FF"; // 右区间颜色
    drawNode(right);
    
    if(left.num === right.num) {
        ctx.fillStyle = "#99FF99"; // 合并成功颜色
        let merged = { num: left.num, cnt: left.cnt + right.cnt };
        drawMergedNode(merged);
    } else {
        let winner = left.cnt > right.cnt ? left : right;
        ctx.fillStyle = winner === left ? "#FF6666" : "#66B2FF";
        let merged = { num: winner.num, cnt: Math.abs(left.cnt - right.cnt) };
        drawMergedNode(merged);
    }
}

// 平衡树查询动画
function animateBSTQuery(root, l, r) {
    let path = [];
    let node = root;
    while(node) {
        path.push(node);
        if(node.val <= r) node = node.right;
        else node = node.left;
    }
    highlightNodes(path); // 高亮查找路径
}
```

---

## 关键优化技巧  
1. **摩尔投票法的区间可加性**：利用线段树合并特性，保证O(logn)时间完成任意区间的众数候选推导  
2. **平衡树的惰性删除**：通过`pb_ds`库实现高效动态维护，避免手写平衡树的复杂性  
3. **随机化的概率控制**：通过多次采样将错误概率降至可接受范围（如1/2^14 ≈ 0.006%）  

---

## 实战调试经验  
1. **线段树更新后必须重新验证**：某次提交未在修改后重新查询实际票数导致WA  
2. **平衡树边界处理**：插入-∞和+∞哨兵节点避免空树异常  
3. **摩尔投票法的局限性**：当不存在绝对众数时必须用实际票数校验  

---

## 扩展思考  
对于更大规模数据（n≥1e7），可结合**布隆过滤器**预筛高频候选人，再结合分层抽样策略进一步优化查询效率。

---
处理用时：81.43秒
# 题目信息

# 文艺数学题

## 题目背景

小Y在AK曼哈顿OI，CTSC和APIO之后，开始研究数学题。


## 题目描述

小Y有一张N个点，M条边的无向图（**可能有重边、自环**），每条边都有一个权值w。


你需要计算：所有**生成树的边权的最大公约数**之和，具体操作见样例。


由于答案可能很大，需要**对1000000007取模**。


## 说明/提示

### 样例1的解释



 ![](https://cdn.luogu.com.cn/upload/pic/13639.png) 

显然，这张图有8个不同的生成树。


用$(x,y,z)$表示x,y,z的最大公约数，则答案


$=(12,6,8)+(6,8,9)+(8,9,12)+(9,12,6)+(9,4,6)+(12,4,8)+(12,4,9)+(6,4,8)$


$=2+1+1+3+1+4+1+2$


$=15$

### 数据范围


对于20%的数据，$N\le 10, M\le 20$；

对于另外10%的数据，$N\le 12, M\le 24$；

对于另外20%的数据，$N\le 60, M\le 3000$，且满足$u_i+1=v_i$；

对于另外20%的数据，$N\le 40, M\le 1000, W\le 1000$；

对于另外15%的数据，$N\le 50, M\le 2000$；

对于所有100%的数据，$N\le 60, M\le 3000, W\le 1000000$；



## 样例 #1

### 输入

```
4 5  
1 2 12  
1 3 9  
2 4 6  
3 4 8  
1 4 4  ```

### 输出

```
15```

# AI分析结果



---

**唯一算法分类**：数论与图论结合（矩阵树定理 + 莫比乌斯反演/欧拉函数）

---

### **综合分析与结论**

**核心思路**：  
1. **问题转换**：将求所有生成树的 GCD 之和转换为枚举可能的 GCD 值，并计算其贡献。  
2. **数学工具**：利用欧拉函数和矩阵树定理，通过预处理和筛法优化计算。  
3. **优化策略**：仅处理边数足够的因数，避免无效计算。

**难点与解决**：  
- **生成树数量计算**：使用矩阵树定理快速计算指定边集的生成树数量。  
- **因数筛选**：通过预处理边权因数，仅保留有效因数（边数 ≥n-1）。  
- **数论优化**：推导发现贡献为 `F(d)*φ(d)`，避免直接计算莫比乌斯函数。

**可视化设计**：  
1. **动画流程**：  
   - **步骤1**：显示当前枚举的因数 `d`，高亮所有边权为 `d` 倍数的边。  
   - **步骤2**：动态绘制基尔霍夫矩阵，展示度数矩阵和邻接矩阵的更新过程。  
   - **步骤3**：高斯消元过程可视化，行列式计算结果同步显示。  
   - **步骤4**：累加 `F(d)*φ(d)` 到总和，用进度条表示当前枚举进度。  
2. **复古风格**：  
   - **像素网格**：用 8-bit 风格绘制图和矩阵，边选中时闪烁黄光。  
   - **音效设计**：  
     - 枚举有效 `d` 时播放短促“滴”声。  
     - 计算成功时播放 8-bit 胜利音效。  
   - **自动演示**：按 `d` 从小到大自动执行，速度可调。

---

### **题解清单 (4星以上)**

1. **作者：Prean (5星)**  
   - **亮点**：代码简洁，直接推导贡献公式 `F(d)*φ(d)`，高效筛法预处理。  
   - **关键代码**：线性筛计算欧拉函数，动态构建矩阵树。  
   - **个人心得**：通过反演转换问题，避免直接处理复杂容斥。

2. **作者：will7101 (4星)**  
   - **亮点**：详细推导公式，分阶段优化策略清晰。  
   - **关键优化**：利用因数数量限制减少计算量。  

---

### **最优思路与代码**

**核心实现思想**：  
```cpp
// 预处理欧拉函数
for (i=2; i<=mx; ++i) {
    if (!pos[i]) { // 质数情况
        pos[pri[++top]=i] = top;
        phi[i] = i-1;
    }
    // 筛法更新phi
    for (j=1; j<=pos[i] && (x=i*pri[j])<=mx; ++j) {
        phi[x] = phi[i] * (pri[j] - (j != pos[i]));
        pos[x] = j;
    }
}

// 计算每个d的贡献
for (i=1; i<=mx; ++i) {
    // 统计边数是否足够
    S = 0;
    for (j=1; (x=i*j)<=mx; ++j) S += id[x].size();
    if (S >= n-1) ans = (ans + 1ull*phi[i]*Solve(i)) % mod;
}

// 矩阵树定理实现
ui Solve(ui d) {
    // 动态构建基尔霍夫矩阵
    for (每条边权为d倍数的边) {
        G[u][v]--; G[v][u]--;
        G[u][u]++; G[v][v]++;
    }
    return Gauss(); // 高斯消元求行列式
}
```

**完整代码**：见问题描述中的 Prean 的代码片段。

---

### **同类型题与推荐题目**

1. **洛谷 P3317**：[生成树计数](https://www.luogu.com.cn/problem/P3317)（矩阵树定理扩展）  
2. **洛谷 P1587**：[欧拉函数](https://www.luogu.com.cn/problem/P1587)（数论基础）  
3. **洛谷 P3768**：[莫比乌斯反演](https://www.luogu.com.cn/problem/P3768)（数学与算法结合）

---

### **个人心得摘录**

- **调试经验**：初始化矩阵时需注意自环和重边的处理，避免度数计算错误。  
- **优化感悟**：因数筛选是关键，直接跳过无效 `d` 可节省 90% 时间。

---

**可视化与复古动画**：  
- **Canvas 动画**：用网格表示图的邻接矩阵，选中边时像素块闪烁。  
- **AI 模式**：自动遍历 `d`，右侧显示当前 `phi(d)` 和贡献值，下方进度条显示完成度。  
- **音效触发**：成功计算一个 `d` 后播放复古音效，失败时静音处理。

---
处理用时：110.93秒
# 题目信息

# [TJOI2008] 公共子串

## 题目描述

一个字符串的子串是在这个串基础上去掉0个或者若干个字符所形成的，例如abc, aa和abbc都是字符串aabbcc的子串，而aba不是。 现给你三个字符串，请问他们三个共同含有多少种子串（不算空串）?

注意： 有些相同的公共子串尽管出现在不同的位置，但仍算1种，详见样例。


## 说明/提示

3个字符串共有的公共子串有： “a”, “p”, “ap”, “pa”, “aa”, “apa”。 其中子串 “a” 有多个，但由于统计的是公共子串种类，所以 “a” 只算1种子串。


100%的数据中，字符串的长度不超过100。字符串中只含有小写字母。




## 样例 #1

### 输入

```
apartment
apache
approach
```

### 输出

```
6```

# AI分析结果



**唯一算法分类**  
动态规划（DP）与序列自动机结合  

---

### **题解思路、算法要点与解决难点**  

1. **核心思路**  
   所有题解围绕统计三个字符串的**本质不同公共子序列**展开，主要分为两类思路：  
   - **动态规划（DP）**：通过三维数组 `f[i][j][k]` 表示三个字符串前 `i, j, k` 个字符的公共子序列数量，利用容斥原理或字符重复性优化状态转移。  
   - **序列自动机 + 记忆化搜索**：预处理每个字符串的序列自动机（`nxt` 数组），记录每个位置后每个字符的首次出现位置，再通过记忆化搜索递归统计公共子序列数量。  

2. **解决难点**  
   - **避免重复计数**：通过预处理字符的最后出现位置（DP）或直接依赖序列自动机的唯一性（记忆化搜索）去重。  
   - **高效状态转移**：动态规划通过容斥公式组合子问题，序列自动机通过预处理直接枚举合法字符转移。  

---

### **题解评分 (≥4星)**  

1. **NZSWW33OMF2GC（4星）**  
   - **亮点**：详细推导状态转移方程，明确处理字符重复的逻辑，代码逻辑清晰。  
   - **不足**：容斥公式较为复杂，理解成本高。  

2. **DarkClever（5星）**  
   - **亮点**：系统讲解序列自动机的构建与应用，代码简洁高效，记忆化搜索逻辑直观。  
   - **心得**：强调序列自动机的通用性，适用于同类子序列问题。  

3. **XiaoQuQu（4星）**  
   - **亮点**：代码简洁，预处理与记忆化搜索结合紧密，适合模板化学习。  

---

### **最优思路或技巧提炼**  

1. **序列自动机预处理**  
   - **核心代码**：  
     ```cpp  
     void build_automaton(string s, int nxt[][26]) {  
         for (int i = s.size(); i >= 0; i--) {  
             for (int c = 0; c < 26; c++) nxt[i][c] = nxt[i+1][c];  
             if (i < s.size()) nxt[i][s[i]-'a'] = i+1;  
         }  
     }  
     ```  
   - **作用**：快速查询每个位置后任意字符的首次出现位置。  

2. **记忆化搜索统计子序列**  
   - **核心代码**：  
     ```cpp  
     ll dfs(int x, int y, int z) {  
         if (dp[x][y][z] != -1) return dp[x][y][z];  
         ll res = (x || y || z); // 非空则计数  
         for (int c = 0; c < 26; c++) {  
             int nx = nxt_a[x][c], ny = nxt_b[y][c], nz = nxt_c[z][c];  
             if (nx && ny && nz) res += dfs(nx, ny, nz);  
         }  
         return dp[x][y][z] = res;  
     }  
     ```  
   - **作用**：递归枚举所有可能的公共子序列，记忆化避免重复计算。  

---

### **同类型题与算法套路**  

1. **通用解法**  
   - **序列自动机**：适用于统计子序列存在性、数量、最长公共子序列等问题。  
   - **多维DP**：通过状态压缩和容斥原理处理多字符串的公共子结构问题。  

2. **推荐题目**  
   - **P1819 [公共子序列问题（四串）]**：直接扩展本题至四个字符串。  
   - **P3973 [TJOI2015] 棋盘**：利用序列自动机处理复杂子序列匹配。  
   - **P1816 统计差异子串**：结合哈希与动态规划统计不同子串。  

---

### **可视化与算法演示**  

1. **动画设计**  
   - **像素风格**：  
     - **Canvas绘制**：将三个字符串并排显示为像素网格，高亮当前处理的位置。  
     - **颜色标记**：当前字符用红色方块标记，已处理的公共子序列用绿色连线连接。  
   - **音效触发**：  
     - **字符匹配成功**：播放短促的“哔”声（8-bit音效）。  
     - **递归进入新状态**：播放“滴答”声提示状态转移。  

2. **交互控制**  
   - **步进执行**：允许单步查看每个字符的匹配过程。  
   - **自动模式**：AI自动选择下一个字符，模拟“最快路径”生成公共子序列。  

---

### **代码实现（核心片段）**  

```cpp  
// 序列自动机预处理  
int nxt_a[105][26], nxt_b[105][26], nxt_c[105][26];  
void build_automaton(string s, int nxt[][26]) {  
    int n = s.size();  
    for (int i = n; i >= 0; i--) {  
        for (int c = 0; c < 26; c++) nxt[i][c] = nxt[i+1][c];  
        if (i < n) nxt[i][s[i]-'a'] = i+1;  
    }  
}  

// 记忆化搜索  
ll dp[105][105][105];  
ll dfs(int x, int y, int z) {  
    if (dp[x][y][z] != -1) return dp[x][y][z];  
    ll res = (x || y || z); // 非空则计数  
    for (int c = 0; c < 26; c++) {  
        int nx = nxt_a[x][c], ny = nxt_b[y][c], nz = nxt_c[z][c];  
        if (nx && ny && nz) res += dfs(nx, ny, nz);  
    }  
    return dp[x][y][z] = res;  
}  

// 主函数  
int main() {  
    string a, b, c;  
    cin >> a >> b >> c;  
    build_automaton(a, nxt_a);  
    build_automaton(b, nxt_b);  
    build_automaton(c, nxt_c);  
    memset(dp, -1, sizeof(dp));  
    cout << dfs(0, 0, 0) - 1; // 减去空串  
    return 0;  
}  
```  

---

### **个人心得摘录**  

- **DarkClever**：序列自动机“模板化”处理子序列问题可大幅简化代码，避免复杂状态转移。  
- **Jμdge**：“多维DP的容斥公式容易漏项，必须画维恩图辅助推导。”  
- **elijahqi**：“重新统计所有字符结尾的子序列可避免遗漏，但需注意时间复杂度。”  

--- 

通过上述分析，序列自动机与记忆化搜索的组合在代码简洁性和效率上表现最优，适合作为本题的标准解法。

---
处理用时：95.92秒
# 题目信息

# [NOIP 2017 提高组] 宝藏

## 题目背景

NOIP2017 D2T2

## 题目描述

参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 $n$ 个深埋在地下的宝藏屋， 也给出了这 $n$ 个宝藏屋之间可供开发的 $m$ 条道路和它们的长度。

小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远，也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路则相对容易很多。

小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。

在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以 任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏屋之间的道路无需再开发。

新开发一条道路的代价是 $\mathrm{L} \times \mathrm{K}$。其中 $L$ 代表这条道路的长度，$K$ 代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋） 。

请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代价最小，并输出这个最小值。


## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/10868.png) 

【样例解释 $1$】

小明选定让赞助商打通了 $1$ 号宝藏屋。小明开发了道路 $1 \to 2$，挖掘了 $2$ 号宝藏。开发了道路 $1 \to 4$，挖掘了 $4$ 号宝藏。还开发了道路 $4 \to 3$，挖掘了 $3$ 号宝藏。

工程总代价为 $1 \times 1 + 1 \times 1 + 1 \times 2  = 4 $。

【样例解释 $2$】

小明选定让赞助商打通了 $1$ 号宝藏屋。小明开发了道路 $1 \to 2$，挖掘了 $2$ 号宝藏。开发了道路 $1 \to 3$，挖掘了 $3$ 号宝藏。还开发了道路 $1 \to 4$，挖掘了 $4$ 号宝藏。

工程总代价为 $1 \times 1 + 3 \times 1 + 1 \times 1  = 5$。


【数据规模与约定】

对于 $ 20\%$ 的数据： 保证输入是一棵树，$1 \le n \le 8$，$v \le 5\times 10^3$ 且所有的 $v$ 都相等。

对于 $40\%$ 的数据： $1 \le n \le 8$，$0 \le m \le 10^3$，$v \le 5\times 10^3$ 且所有的 $v$ 都相等。

对于 $ 70\%$ 的数据： $1 \le n \le 8$，$0 \le m \le 10^3$，$v \le  5\times 10^3$。

对于 $ 100\%$ 的数据： $1 \le n \le 12$，$0 \le m \le 10^3$，$v \le  5\times 10^5$。

---

$\text{upd 2022.7.27}$：新增加 $50$ 组 Hack 数据。


## 样例 #1

### 输入

```
4 5 
1 2 1 
1 3 3 
1 4 1 
2 3 4 
3 4 1 
 ```

### 输出

```
4```

## 样例 #2

### 输入

```
4 5 
1 2 1 
1 3 3 
1 4 1 
2 3 4 
3 4 2  ```

### 输出

```
5```

# AI分析结果



**唯一算法分类**：状压DP

---

### **题解思路与解决难点**

**核心算法流程**：
1. **状态设计**：设 `f[i][S]` 表示树高为 `i`，已选点集为 `S` 的最小代价。
2. **预处理子集转移代价**：计算从状态 `S-T` 扩展到 `S` 的最小边权和 `cost(S-T, T)`。
3. **分层动态规划**：枚举树高 `i` 和点集 `S`，通过子集枚举完成状态转移。

**关键难点与解决方案**：
- **子集枚举优化**：通过 `for(int j=S; j; j=(j-1)&S)` 高效枚举子集，复杂度从 `O(4^n)` 优化到 `O(3^n)`。
- **代价预处理**：利用 `lowbit` 分解点集，预处理每个点集到其补集子集的最小边权。
- **层数合并证明**：通过数学归纳法证明，将点连接到更高层不会更优，从而允许仅记录当前层信息。

---

### **题解评分 (≥4星)**

1. **FlashHu (5星)**  
   - **亮点**：预处理 `f[i][j]` 表示 `i` 到 `j` 的最小边权和，分层转移时利用 `lowbit` 优化枚举顺序，代码简洁高效。
   - **代码片段**：
     ```cpp
     for(int i=1;i<=S;++i)
         for(int j=i^S;j;j=(j-1)&(i^S))
             f[i][j] = f[i][j^(j&-j)] + min_edge;
     ```

2. **_zuoqingyuan (4.5星)**  
   - **亮点**：详细证明状态转移的正确性，通过邻接矩阵预处理最短边，代码中 `init()` 函数清晰展示预处理逻辑。
   - **关键步骤**：预处理 `cost` 数组，确保子集扩展的最小代价。

3. **HenryHuang (4星)**  
   - **亮点**：引入 `dis` 数组优化子集计算，通过双重循环压缩状态转移。
   - **代码优化**：使用 `for(int j=S; j; j=(j-1)&S)` 避免重复计算。

---

### **最优思路提炼**

**核心技巧**：
1. **分层状压DP**：将树高作为阶段，点集作为状态，通过 `f[i][S] = min(f[i-1][T] + i*cost)` 分层计算。
2. **子集代价预处理**：对每个点集 `S` 和其补集子集 `T`，预处理 `cost(S-T, T)` 为各点到 `S-T` 的最小边权和。
3. **高效枚举**：利用位运算技巧快速枚举子集，时间复杂度降至 `O(3^n)`。

**关键代码片段**：
```cpp
// 预处理每个状态到子集的最小边权和
for(int i=1; i<(1<<n); i++){
    for(int j=(i^((1<<n)-1)); j; j=(j-1)&(i^((1<<n)-1))){
        int x = log2(j & -j);
        int min_cost = INF;
        for(int y=0; y<n; y++)
            if((i>>y)&1) min_cost = min(min_cost, edge[x][y]);
        cost[i][j] = cost[i][j^(1<<x)] + min_cost;
    }
}
```

---

### **同类题目推荐**
1. **P1171 售货员的难题** - 状压DP求最短哈密顿回路。
2. **P2831 愤怒的小鸟** - 子集枚举优化抛物线覆盖。
3. **P2704 炮兵阵地** - 状态压缩与行间转移。

---

### **可视化设计**

**动画方案**：
1. **像素风格状态展示**：  
   - 每个点用 8x8 像素块表示，已选点为绿色，待扩展为黄色。
   - 当前操作子集用红色边框高亮，边权用蓝色线条粗细表示。

2. **分层动态演示**：  
   - **步骤1**：展示初始状态（单点，层数1）。
   - **步骤2**：枚举子集 `T`，用红色闪烁标识当前处理子集。
   - **步骤3**：计算 `cost(S-T, T)`，显示每个点的最小边。
   - **步骤4**：更新 `f[i][S]` 值，绿色数字显示最新结果。

**音效与交互**：
- **关键操作音效**：子集枚举时播放“滴”声，状态更新时播放“叮”声。
- **速度控制**：滑动条调节动画速度，支持暂停/继续。
- **AI自动演示**：自动按层推进，用不同颜色区分阶段。

**代码片段（Canvas绘制核心状态）**：
```javascript
function drawState(ctx, S, color) {
    for (let i = 0; i < n; i++) {
        if (S & (1 << i)) {
            ctx.fillStyle = color;
            ctx.fillRect(x[i] * 16, y[i] * 16, 8, 8);
        }
    }
}
```

---

### **个人心得摘录**
- **调试教训**：预处理时未考虑边权去重，导致 `min_edge` 计算错误（需用邻接矩阵存最小值）。
- **优化顿悟**：`j=(j-1)&S` 的枚举方式比暴枚快10倍，尤其在 `n=12` 时效果显著。

---

**结论**：状压DP通过分层和子集预处理，将复杂度优化至可接受范围，核心在于状态设计和高效率枚举。可视化通过分层动画和子集高亮，直观展示算法核心流程。

---
处理用时：72.98秒
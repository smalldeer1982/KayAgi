# 题目信息

# [TJOI2015] 弦论

## 题目描述

为了提高智商，ZJY 开始学习弦论。这一天，她在《String theory》中看到了这样一道问题：对于一个给定的长度为 $n$ 的字符串，求出它的第 $k$ 小子串是什么。你能帮帮她吗?


## 说明/提示

### 数据范围

对于 $10\%$ 的数据，$n\leq 1000$。

对于 $50\%$ 的数据，$t = 0$。

对于 $100\%$ 的数据，$1\leq n \leq 5 \times 10^5$，$0\leq t \leq 1$，$1\leq k \leq 10^9$。


## 样例 #1

### 输入

```
aabc
0 3```

### 输出

```
aab```

## 样例 #2

### 输入

```
aabc
1 3```

### 输出

```
aa```

## 样例 #3

### 输入

```
aabc
1 11```

### 输出

```
-1```

# AI分析结果



### 唯一算法分类  
后缀自动机（SAM）

---

### 核心思路与难点分析  
#### 算法核心流程  
1. **构建SAM**：将字符串转换为后缀自动机，每个节点表示一组结束位置相同的子串。  
2. **统计出现次数**：  
   - **t=1**时，通过parent树统计每个节点的`endpos`大小（即子串出现次数）。  
   - **t=0**时，所有节点贡献固定为1。  
3. **计算子串数量**：从每个节点出发，按字典序遍历所有可能的子串路径，累计路径总数。  
4. **递归查询**：从根节点开始，按字典序选择子节点，根据剩余k值确定路径。  

#### 解决难点  
- **出现次数统计**：需区分本质不同与位置不同的统计方式，通过parent树自底向上累加（t=1）或直接赋值为1（t=0）。  
- **字典序遍历**：递归时按字符顺序遍历子节点，利用前缀和快速确定k值所在子树。  

---

### 题解评分（≥4星）  
1. **xzyxzy（4.5星）**  
   - 亮点：简洁的SAM实现，通过拓扑排序预处理`siz`和`sum`数组，代码逻辑清晰。  
   - 关键代码片段：  
     ```cpp  
     for(int i=node;i>=1;i--)  
         for(int j=0;j<26;j++)  
             sum[A[i]] += sum[ch[A[i]][j]];  
     ```  
2. **万弘（4星）**  
   - 亮点：封装SAM结构，通过DFS遍历parent树统计`siz`，可读性高。  
   - 关键代码片段：  
     ```cpp  
     void dfs1(ll u) {  
         for(ll i=head[u];i;i=e[i].nxt)  
             dfs1(e[i].v), size[u] += size[e[i].v];  
         f[u] = size[u];  
     }  
     ```  
3. **George1123（4星）**  
   - 亮点：详细注释SAM状态转移，代码中体现`sum`和`f`的递推关系，适合初学者理解。  
   - 关键代码片段：  
     ```cpp  
     ll getFunc(int u) {  
         if(f[u] != -1) return f[u];  
         f[u] = (t ? sz[u] : 1);  
         for(int c = 0; c < 26; c++)  
             f[u] += getFunc(tr[u][c]);  
         return f[u];  
     }  
     ```  

---

### 最优思路与技巧  
1. **SAM节点贡献计算**：  
   - `t=1`时，`siz`表示子串出现次数；`t=0`时，每个节点仅贡献1次。  
2. **字典序递归查询**：  
   - 按字符顺序遍历子节点，利用前缀和跳过无效分支，时间复杂度稳定为O(n)。  
3. **拓扑排序优化**：  
   - 按节点`len`排序后逆序处理，确保父节点统计在子节点之后完成。  

---

### 类似题目推荐  
1. **P2408**：统计不同子串个数（SAM基础应用）。  
2. **P3804**：求各长度子串出现次数的最大值（SAM+parent树统计）。  
3. **P5341**：求字典序最小且出现次数最多的子串（SAM+递归查询）。  

---

### 可视化与算法演示  
#### 动画方案设计  
1. **SAM节点展示**：  
   - 用网格显示SAM节点，不同颜色区分`t=0`和`t=1`的贡献值。  
   - 高亮当前访问节点，显示其`sum`和`siz`值。  
2. **递归路径追踪**：  
   - 每次选择子节点时，显示剩余k值，路径线条动态延伸。  
   - 播放音效（如选择正确分支时“滴答”声）。  
3. **复古像素风格**：  
   - 使用16色调色板，节点显示为8-bit方块，背景音乐采用FC风格循环。  

#### 交互设计  
- **控制面板**：暂停/继续、步进执行、调整动画速度。  
- **自动模式**：AI自动遍历子节点，展示算法决策流程。  

---

### 代码实现（关键片段）  
```cpp  
// SAM构建与递归查询  
void insert(int c) {  
    int p = last, np = last = ++cnt;  
    len[np] = len[p] + 1; siz[np] = 1;  
    while (p && !ch[p][c]) ch[p][c] = np, p = fa[p];  
    if (!p) fa[np] = 1;  
    else {  
        int q = ch[p][c];  
        if (len[q] == len[p]+1) fa[np] = q;  
        else {  
            int nq = ++cnt; len[nq] = len[p]+1;  
            fa[nq] = fa[q]; fa[q] = fa[np] = nq;  
            memcpy(ch[nq], ch[q], sizeof(ch[q]));  
            while (p && ch[p][c] == q) ch[p][c] = nq, p = fa[p];  
        }  
    }  
}  

void dfs(int u, int k) {  
    if (k <= siz[u]) return;  
    k -= siz[u];  
    for (int c = 0; c < 26; c++) {  
        int v = ch[u][c];  
        if (!v) continue;  
        if (k > sum[v]) k -= sum[v];  
        else {  
            putchar('a' + c);  
            dfs(v, k);  
            return;  
        }  
    }  
}  
```  

---

### 个人心得摘录  
- **调试经验**：处理`sum`数组时需注意父节点更新顺序，逆拓扑排序避免循环依赖。  
- **优化技巧**：预处理字典序子节点列表，减少递归时的分支判断时间。  
- **顿悟点**：SAM的`sum`本质是子串的字典序前缀和，递归查询类似Trie树k大查询。  

--- 

**可视化演示示例**（伪代码）  
```javascript  
// Canvas绘制SAM节点  
function drawNode(node, x, y) {  
    ctx.fillStyle = node.highlight ? "#FF0000" : "#00FF00";  
    ctx.fillRect(x, y, 30, 30);  
    ctx.fillText(node.sum, x+5, y+15);  
}  

// 递归动画演示  
async function findKth(node, k) {  
    highlight(node);  
    if (k <= node.siz) return;  
    k -= node.siz;  
    for (const c of 'abcdefghijklmnopqrstuvwxyz') {  
        const child = node.children[c];  
        if (!child) continue;  
        if (k > child.sum) {  
            k -= child.sum;  
            playSound('skip');  
        } else {  
            playSound('select');  
            drawPath(node, child);  
            await findKth(child, k);  
            return;  
        }  
    }  
}  
```

---
处理用时：84.88秒
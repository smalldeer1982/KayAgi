# 题目信息

# [JXOI2017] 颜色

## 题目描述

可怜有一个长度为 $n$ 的正整数序列 $A_i$，其中相同的正整数代表着相同的颜色。

现在可怜觉得这个序列太长了，于是她决定选择一些颜色把这些颜色的所有位置都删去。

删除颜色 $i$ 可以定义为把所有满足 $A_j = i$ 的位置 $j$ 都从序列中删去。

然而有些时候删去之后，整个序列变成了好几段，可怜不喜欢这样，于是她想要知道有多少种删去颜色的方案使得最后剩下来的序列非空且连续。

例如颜色序列 $\{1, 2, 3, 4, 5\}$，删除颜色 $3$ 后序列变成了 $\{1, 2\}$ 和 $\{4, 5\}$ 两段，不满足条件。而删除颜色 $1$ 后序列变成了 $\{2, 3, 4, 5\}$，满足条件。

两个方案不同当且仅当至少存在一个颜色 $i$ 只在其中一个方案中被删去。


## 说明/提示

满足条件的删颜色方案有 $\{1\}, \{1, 3\}, \{1, 2, 3\}, \{1, 3, 4\}, \{2, 3, 4\}, \varnothing$。

对于 $20\%$ 的数据，保证 $1 \le \sum n \le  20$。

对于 $40\%$ 的数据，保证 $1 \le \sum n \le  500$。

对于 $60\%$ 的数据，保证 $1 \le \sum n \le  10^4$。

对于 $100\%$ 的数据，保证 $1 \le  T,\sum n \le  3 \times 10^5, 1 \le  A_i \le  n$。

$\text{Statement fixed by @Starrykiller.}$

## 样例 #1

### 输入

```
1
5
1 3 2 4 3```

### 输出

```
6```

# AI分析结果



### 唯一算法分类
**区间枚举与哈希前缀和**

---

### 综合分析与结论
**核心思路**：所有题解均围绕「合法区间即完全包含颜色出现位置的区间」这一核心条件展开，分为两类解法：
1. **随机哈希法**：通过给颜色分配特定权值，使得合法区间的前缀和/异或和为0，用哈希表统计出现次数。
2. **线段树+栈法**：枚举右端点，维护最近禁用边界，用线段树统计可用左端点数量。

**可视化设计**：
- **哈希法动画**：颜色块分配随机值，前缀和变化实时显示，相同值位置高亮为合法区间。
- **线段树+栈动画**：栈顶元素随右端点移动弹出，线段树区间赋0（禁用）以红色标记，合法左端点绿色闪烁。

---

### 题解清单 (≥4星)
1. **Iscream2001 的随机哈希法（4.5星）**
   - 亮点：代码简洁高效，O(n)时间复杂度，概率正确性保障。
2. **shadowice1984 的线段树+栈法（5星）**
   - 亮点：确定性解法，思路清晰，栈维护最近边界，线段树处理禁用区间。
3. **Ebola 的异或哈希法（4星）**
   - 亮点：异或操作简化哈希，概率分析增强可信度。

---

### 最优思路提炼
**随机哈希法的核心步骤**：
1. 为每个颜色生成随机值，同色值的总和为0。
2. 统计前缀和，若两位置前缀和相等，则区间合法。
3. 使用 `map` 统计相同前缀和的出现次数。

**线段树+栈法的关键操作**：
1. 枚举右端点 `i`，维护栈存储可能影响左端点的颜色。
2. 当 `i` 是某颜色右端点时，线段树禁用其内部区间 `[min+1, max]`。
3. 栈顶确定左端点下限 `l`，线段树查询 `[l+1, i]` 的可用点数。

---

### 同类型题与算法套路
**类似题目**：
1. **LeetCode 560. 和为K的子数组**（前缀和哈希）
2. **洛谷 P1972 [SDOI2009] HH的项链**（离线+树状数组）
3. **Codeforces 1000F. One Occurrence**（线段树维护最后出现位置）

**通用解法**：
- **前缀和哈希**：适用于统计满足特定累加条件的区间。
- **端点枚举+数据结构**：线段树/树状数组维护区间信息，栈/堆维护边界。

---

### 推荐洛谷题目
1. **P1972**：区间不同颜色数统计。
2. **P5490**：扫描线求矩形面积并。
3. **P1903**：带修莫队维护区间颜色。

---

### 可视化与算法演示
**哈希法动画设计**：
- **颜色分配**：每个颜色块随机填充红/蓝渐变色，同色块内随机值以不同亮度表示。
- **前缀和流**：实时显示前缀和数值，相同值高亮为黄色，统计计数器递增。
- **音效**：每次发现相同前缀和时播放“叮”声，背景8-bit音乐循环。

**线段树+栈动画设计**：
- **栈动态变化**：栈元素以像素方块表示，颜色随 `max` 值变化，弹出时爆炸特效。
- **线段树区间更新**：禁用区间红色覆盖，合法区间绿色闪烁，单步执行可调速度。
- **控制面板**：暂停/继续/回退，速度条调节，显示当前右端点和合法数。

---

### 核心代码片段
**Iscream2001 的哈希法**：
```cpp
for(int i=1;i<=n;++i){
    re += f[i];
    ans += mp[re];
    ++mp[re];
}
```

**shadowice1984 的线段树+栈法**：
```cpp
for(int i=1;i<=n;++i){
    if(i==ma[col[i]]) 
        lt.setval(1,0,n,mi[col[i]],ma[col[i]]);
    else s.push({col[i],i});
    while(!s.empty()&&ma[s.top().col]<=i) s.pop();
    int l = s.empty()?0:s.top().pos;
    ans += i - l - lt.sum(1,0,n,l,i);
}
```

---

通过对比，线段树+栈法在确定性场景下更可靠，而哈希法在竞赛中更高效。可视化设计可结合两种思路，帮助理解区间合法性判断的核心逻辑。

---
处理用时：72.11秒
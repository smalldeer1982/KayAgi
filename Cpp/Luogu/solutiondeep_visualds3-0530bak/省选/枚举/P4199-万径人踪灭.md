# 题目信息

# 万径人踪灭

## 题目背景

保先生是个好司机，总是开车带学生们上山玩。但是保先生去年开了最后一趟车后，由于一些奇奇怪怪的原因转行了。半年间，再也没有从这条路上山的人了。

当 VFleaKing 再次来到这座山玩的时候，发现已经没有往日的来来往往的游人了。算了，过去保先生还在的时候，来山上玩的人，也不全是来欣赏山上的风景的。

## 题目描述

如果机房马上要关门了，或者你急着要走，请直接跳到第六个自然段。

VFleaKing 注意到了这条上山下山的土路，有些地方能欣赏到美景，有些地方则不能。把上山的道路每 $10$ cm 分为一小段，则对于每一小段，用 `a` 表示能欣赏到美景，用 `b` 表示不能欣赏到美景，就能得到一个只含 `a`、`b` 的字符串 $s$。当然由于下山和上山是一条路，所以下山的道路的字符串就是将上山的道路的字符串反过来。

设上山字符串长度为 $n$，每个字符依次为 $s_1, s_2 .…, s_n$。在上山和下山的路上，VFleaKing 会选择某些小段查看旁边的景色，其他时间低头走路。即 VFleaKing 会选择 $k$ 个小段 $x_1, x_2 …x_k$，且 $k >0$，$1\le x_1<x_2<…<x_k\le n$，VFleaKing 上山和下山的过程中会在这些地方查看景色。

![](https://cdn.luogu.com.cn/upload/image_hosting/t9qpo3f9.png)

VFleaKing 希望，上山下山时看到的美景的情况相同。也就是说，VFleaKing 上山时是否看到了美景的情况是： $s_{x_1},s_{x_2},\cdots,s_{x_k}$ 记为字符序列 $T_1$，下山时是否看到了美景的情况是：$s_{x_k},s_{x_{k-1}},\cdots,s_{x_1}$ 记为字符序列 $T_2$。VFleaKing 希望 $T_1=T_2$。

VFleaKing 还希望，上山下山时查看景色的间隔相等。也就是说，上山时查看景色的间隔为：$x_2-x_1,x_3-x_2,x_k-x_{k-1}$，记为数列 $P_1$。下山时查看景色的间隔为：$x_k-x_{k-1},x_{k-1}-x_{k-2},…,x_2-x_1$，记为数列 $P_2$。VFleaKing 希望 $P_1=P_2$。

VFleaKing 觉得，如果第一次查看景色和最后一次查看景色这段时间里，没有一次低头看路他就会摔倒。也就是说，如果对于所有 $1\le i\le k$ 都有$x_i=x_1+i- 1$，VFleaKing 就会摔倒，VFleaKing不希望发生这样的情况。

就是要在一个只含 `a`、`b` 的字符串中选取一个子序列，使得:

1. 位置和字符都关于某条对称轴对称。
2. 不能是连续的一段。

以 $s = \texttt{"abaaaaabbabbabaa"}$ 为例。如果我们用符号 $[a_1, a_2,…,a_k]$ 表示一个序列，那么 $[1,4]$ 就是一个合法的序列 $x$，$[5,8,10,12,15]$ 也是，$[4,5,8,9,10,11,12,15,16]$ 也是。但是 $[1,2]$ 不满足 VFleaKing 第一个希望和第三个希望，所以不是。$[1,2,4]$ 不满足第二个希望，所以不是。$[9,10,11]$ 不满足第三个希望，所以不是。

![](https://cdn.luogu.com.cn/upload/image_hosting/6849dqla.png)

给你字符串 $s$，现在 VFleaKing 想知道，有多少个合法的 $x$。答案可能很大，VFleaKing 想知道对 $1000000007$ 取模的值。

## 说明/提示

## 样例解释

### 样例解释 1

$14$ 个方案分别是：

- $[1,3]$，$[1,4]$，$[2,5]$，$[1,6]$，$[3,6]$，$[4,6]$，$[1,7]$，$[3,7]$，$[4,7]$；
- $[1,4,7]$，$[3,5,7]$；
- $[1,3,4,6]$，$[1,2,5,6]$，$[3,4,6,7]$。

### 样例解释 2

我已经想到了一个绝妙的解释，可惜方案太多，写不下了。

### 样例解释 3

我已经想到了一个绝妙的解释，可惜方案太多，写不下了。

## 数据范围

- 其中 $10\%$ 的数据，字符串仅包含字母 `a` 或字母 `b`。
- 另有 $20\%$ 的数据，$n\le 1000$。
- 另有 $20\%$ 的数据，要么 `a` 的个数不超过 $10$，要么 `a` 的个数不超过 $10$。
- 另有 $10\%$ 的数据，$n\le 10000$。
- 对于 $100\%$ 的数据，$n \le 100000$。

## 来源

- 2013 湖北互测 week1
- bzoj 3160
- 信息学奥赛之数学一本通
- stong9070 整理



## 样例 #1

### 输入

```
abaabaa```

### 输出

```
14```

## 样例 #2

### 输入

```
aaabbbaaa```

### 输出

```
44```

## 样例 #3

### 输入

```
aaaaaaaa```

### 输出

```
53```

# AI分析结果



# 万径人踪灭题解分析

## 算法分类
**FFT（快速傅里叶变换）与Manacher算法结合**

---

## 题解思路与核心逻辑

### 核心算法流程
1. **问题转换**  
   总答案 = 位置对称的回文子序列数 - 回文子串数  
   - 回文子序列数通过**FFT统计对称字符对**  
   - 回文子串数通过**Manacher算法**直接计算

2. **对称对统计（FFT部分）**  
   - 构造两个多项式：`A`标记所有`a`的位置，`B`标记所有`b`的位置  
   - 多项式自乘后，系数`A^2[i]`表示以`i/2`为中心的`a`对称对数量，`B^2[i]`同理  
   - 总对称对数为`A^2 + B^2`的系数，需修正奇偶性（对称轴在字符或间隔）

3. **回文子序列计算**  
   - 对每个对称中心`k`，若有`x`个对称对，则贡献为`2^x-1`  
   - 注意：对称轴在字符时需额外+1（包含自身）

4. **Manacher处理**  
   - 插入分隔符处理偶长度回文  
   - 统计所有回文半径，扣除连续回文子串数

### 解决难点对比
| 题解差异点        | Orion545解法 | VenusM1nT解法 |
|-------------------|--------------|----------------|
| FFT实现方式       | 复数运算     | 实数优化        |
| 奇偶修正公式      | 显式位运算   | 统一表达式处理  |
| 模数处理          | 最后取模     | 分阶段取模      |
| 对称轴类型判断    | 分情况处理   | 统一偏移计算    |

---

## 题解评分（≥4星）

1. **Orion545（★★★★☆）**  
   - 亮点：详细推导对称对与指数关系，完整Manacher实现  
   - 不足：FFT代码冗余，未优化复数运算

2. **VenusM1nT（★★★★★）**  
   - 亮点：分离`a/b`卷积，统一公式处理奇偶，代码模块化  
   - 优化：使用实数多项式简化计算，分阶段模数防溢出

3. **xixike（★★★★☆）**  
   - 亮点：NTT实现避免浮点误差，详细数学推导  
   - 特色：引入平方消除符号影响，数学变形巧妙

---

## 最优思路提炼

### 关键技巧
1. **多项式分解**  
   ```cpp
   // 构造a/b两个多项式
   for(int i=0;i<n;i++) 
       A[i] = (s[i]=='a'), B[i] = (s[i]=='b');
   FFT(A), FFT(B);
   ```
   分离字符类型统计，避免交叉干扰

2. **对称轴统一处理**  
   ```cpp
   // 修正奇偶性
   ans[i] = ((ans[i] + (i%2==0)) >> 1) + (i%2==0);
   ```
   将对称轴在字符/间隔统一为整数下标

3. **Manacher快速统计**  
   ```cpp
   // 统计所有回文半径贡献
   for(int i=1;i<=tot;i++) 
       sum += (p[i]>>1);
   ```
   插入`#`后，直接取半即可得到实际回文数

---

## 可视化设计

### 动画演示方案
1. **FFT对称对统计**  
   - **步骤分解**：  
     - 初始字符串转为二维网格（a-红，b-蓝，空-灰）  
     - 滑动对称轴位置，高亮当前对称字符对  
     - 显示多项式乘法过程，用波形图展示频域叠加

2. **Manacher过程**  
   - **动态扩展**：  
     - 实时显示回文半径扩展，对比暴力扩展与优化跳跃  
     - 用不同颜色标记当前最大右边界`mx`和中心`id`

### 像素风格实现
```javascript
// Canvas绘制示例（对称轴扫描）
function drawAxis(ctx, pos, type) {
    ctx.fillStyle = type ? '#FF5555' : '#5555FF'; // 红/蓝轴
    ctx.fillRect(pos*16, 0, 2, canvas.height);
    
    // 扫描线动画
    let y = 0;
    const scan = setInterval(() => {
        ctx.fillStyle = '#FFFF00';
        ctx.fillRect(pos*16-8, y, 16, 2);
        y += 4;
        if(y > canvas.height) clearInterval(scan);
    }, 50);
}
```

### 音效设计
- **FFT计算完成**：8-bit上升音效  
- **回文扩展**：根据半径长度播放不同音高  
- **错误提示**：经典FC错误"哔-"声

---

## 相似题目推荐
1. **P3803 【模板】多项式乘法（FFT）**  
   - 练习FFT基础实现

2. **P4555 最长双回文串**  
   - Manacher与回文性质结合

3. **BZOJ3160 万径人踪灭**  
   - 本题原题，数据范围更大

---

## 核心代码片段
```cpp
// FFT计算对称对（VenusM1nT解法关键部分）
void solve(){
    for(int i=1;i<=n;i++) A[i] = (s[i]=='a'), B[i] = (s[i]=='b');
    
    // FFT卷积
    FFT(A,1), FFT(B,1);
    for(int i=0;i<lim;i++) A[i] = A[i]*A[i] + B[i]*B[i];
    FFT(A,-1);
    
    // 统计贡献
    for(int i=1;i<=2*n+1;i++){
        int cnt = (int)(A[i].x+0.5);
        cnt = (cnt + (i%2==0)) / 2; // 奇偶修正
        ans = (ans + qpow(2,cnt) - 1) % mod;
    }
    
    // 扣减Manacher结果
    ans = (ans - manacher() + mod) % mod;
}
```

---

## 总结
通过FFT高效统计对称特征，结合Manacher排除连续情况，展现了数学工具在字符串问题中的巧妙应用。分离字符类型卷积与统一公式处理是算法核心优化点，而可视化设计强化了对卷积与回文扩展过程的理解。

---
处理用时：76.70秒
# 题目信息

# [CTSC2018] 假面

## 题目背景


针针是绿绿的好朋友。

## 题目描述

针针喜欢玩一款叫做 DotA (**D**efense **o**f **t**he **A**lgorithm) 的游戏，在这个游戏中，针针会操纵自己的英雄与队友一起对抗另一支队伍。
针针在 DotA 中最喜欢使用的英雄叫做假面（Faceless），该英雄有 $2$ 个技能：

- 锁定：对一名指定的敌方单位使用，以 $p$ 的概率对该单位造成 $1$ 点伤害（使其减少 $1$ 点生命值）。
- 结界：在一片区域施放结界，让该区域内的所有其他单位无法动弹。
在游戏中，如果一个单位的生命值降至 $0$ 或 $0$ 以下，那么该单位就会死亡。

针针操纵假面的水平一般，因此他决定勤加练习。现在有 $n$ 个敌方单位（编号从 $1$ 至 $n$），编号为 $i$ 的敌方单位有 $h_i$ 点生命值。

针针已经安排好了练习的计划，他会按顺序施放 $Q$ 个技能：

- 对于锁定技能：针针会指定一个敌方单位 $id$ ，并对它施放。由于决定概率系数 $p$ 的因素很多，因此每次的 $p$ 都不一定相同。
特别地，如果该敌方单位已经死亡，那么该技能不会造成任何效果。
- 对于结界技能：针针会希望对 $k$ 个指定的敌方单位施放，但由于针针并不擅长施放该技能，因此他只能命中恰好 $1$ 个敌方单位。命中每个存活的敌方单位的概率是相等的（也就是说已经死亡的敌方单位不会有任何影响）。
特别地，如果这 $k$ 个敌方单位均已死亡，那么该技能同样不会命中任何敌方单位。

现在，围观针针进行练习的绿绿想知道：

1. 对于针针施放的每个结界技能，它命中各敌人的概率分别是多少。
2. 在针针的所有技能施放完毕后，所有敌方单位剩余生命值的期望分别是多少。

由于绿绿还要围观针针训练，所以请你帮他解决这两个问题。

为了防止精度误差，对于所有需要输出的数值，请输出其在模 $998244353$ 意义下的值。

由于结界为假面的终极技能，因此针针施放该技能的次数不会太多。具体请见”子任务“。

## 说明/提示

### 样例解释 1
针针按顺序施放如下技能：

1. 对敌方单位 $2$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。此时 $2$ 号敌方单位必定剩余 $1$ 点生命值。
2. 对敌方单位 $2$ 施放技能结界：（由于 $2$ 号敌方单位尚存活，）必定命中 $2$ 号单位。
3. 对敌方单位 $2$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。
4. 对敌方单位 $3$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。此时三个敌方单位的生命值一定分别为 $1, 0 ,2$ ，敌方单位 $2$ 一定死亡。
5. 对敌方单位 $2$ 施放技能结界：（由于 $2$ 号敌方单位已死亡，）必定不命中任何单位。
6. 对敌方单位 $1, 2, 3$ 施放技能结界：命中敌方单位 $1, 3$ 的概率是相等的，即各 $\frac{1}{2}$ 。 最终，三个敌方单位的剩余生命值一定为 $1 , 0 , 2$ 。

### 样例解释 2
对于各结界技能的分析：

1. 第 $1$ 个结界（目标为敌方单位 $1,2$ ）：
- $2$ 号敌方单位存活的概率为 $\frac{1}{2}$ ， $1$ 号敌方单位必定存活。
- 如果 $2$ 号敌方单位存活，那么结界命中 $1 , 2$ 的概率相等，均为 $\frac{1}{2}$ ；如果 $2$ 号敌方单位死亡，那么结界必定命中 $1$ 号敌方单位。
- 因此：命中 $1$ 号敌方单位的概率为 $\frac{1}{2} \times 1 + \frac{1}{2} \times \frac{1}{2} = \frac{3}{4}$ ；命中 $2$ 号敌方单位的概率为 $\frac{1}{2} \times 0 + \frac{1}{2} \times \frac{1}{2} = \frac{1}{4}$ 。
2. 第 $2$ 个结界（目标为敌方单位 $1, 2, 3$ ）：
- 三个敌方单位存活的概率分别为 $1, \frac{1}{2} , \frac{1}{3}$ 。
- $1 , 2 , 3$ 同时存活的概率为 $\frac{1}{6}$ ；只有 $1, 2$ 存活的概率为 $\frac{1}{3}$ ；只有 $1 , 3$ 存活的概率为 $\frac{1}{6}$ ；只有 $1$ 存活的概率为 $\frac{1}{3}$ 。
- 因此：命中 $1$ 号敌方单位的概率为 $\frac{1}{6} \times \frac{1}{3} + (\frac{1}{3}+\frac{1}{6}) \times \frac{1}{2}+ \frac{1}{3} \times 1 = \frac{23}{36}$ ；命中 $2$ 号敌方单位的概率为 $\frac{1}{6} \times \frac{1}{3} + \frac{1}{3} \times \frac{1}{2} = \frac{2}{9}$ ；命中 $3$ 号敌方单位的概率为 $\frac{1}{6} \times \frac{1}{3} + \frac{1}{6} \times \frac{1}{2} = \frac{5}{36}$ 。 最终，三个敌方单位的剩余生命值的期望值为 $1 , \frac{1}{2} , \frac{1}{3}$ 。


### 数据范围

我们记 $C$ 为结界技能的数量。

测试点编号|n=|Q=|C=|u,v|其他限制
-|-|-|-|-|-
1|5|21|6|u<v|无
2|60|199992|500|u<v|所有 p 均相等
3|60|23|6|u<v|所有m_i =1
4|60|199994|500|u<v|无
5|60|199995|500|u<v|无
6|60|199996|0|u<v|无
7|60|199997|500|u=v|无
8|200|199998|1000|u<v|无
9|200|199999|1000|u<v|无
10|200|200000|1000|u<v|无

对于所有测试点，保证 $n \le 200 , Q \le 200000 , C \le 1000 , m_i \le 100$ 。

提示

Q 的个位可以帮助你快速确定测试点的编号。
测试点顺序可能与难度无关。

感谢 @和泉正宗 提供题面 

## 样例 #1

### 输入

```
3
1 2 3
6
0 2 1 1
1 1 2
0 2 1 1
0 3 1 1
1 1 2
1 3 1 2 3```

### 输出

```
1
0
499122177 0 499122177
1 0 2
```

## 样例 #2

### 输入

```
3
1 1 1
4
0 2 1 2
1 2 1 2
0 3 2 3
1 3 1 2 3```

### 输出

```
249561089 748683265
804141285 887328314 305019108
1 499122177 332748118
```

# AI分析结果



### 算法分类选择  
**动态规划 + 概率论 + 逆元优化**

---

### 题解思路与核心难点分析  
#### **核心算法流程**  
1. **锁定技能处理**  
   - 维护每个敌方单位当前各血量的概率 `dp[i][j]`  
   - 每次攻击时更新 `dp[i][j]`，时间复杂度 `O(Q * m)`  
   - 转移公式：  
     ```  
     dp[id][j] = dp[id][j+1] * p + dp[id][j] * (1-p)  
     ```  
     （注意边界条件 `j=0` 时攻击无效的特殊处理）

2. **结界技能处理**  
   - **总存活概率计算**：对所有目标单位进行背包 DP，计算存活 `j` 人的概率 `g[j]`  
   - **逆推优化**：对每个目标单位 `u`，从 `g[j]` 推导出除去 `u` 后的存活概率 `h[j]`  
     - 若 `u` 存活概率为 1，则 `h[j] = g[j+1]`  
     - 否则通过逆元递推：  
       ```  
       h[j] = (g[j] - alive_u * h[j-1]) / (1 - alive_u)  
       ```  
   - **命中概率计算**：  
     ```  
     ans_u = alive_u * ∑ (h[j] / (j+1))  
     ```

3. **最终期望计算**  
   - 对每个单位，计算 `∑ (j * dp[i][j])` 作为期望剩余血量  

#### **解决难点**  
- **逆推优化**：通过总概率 `g[j]` 反推每个单位的影响，避免重复计算  
- **模运算处理**：使用逆元处理概率除法，保证计算在模意义下正确  

---

### 题解评分（≥4星）  
1. **RabbitHu（★★★★★）**  
   - **亮点**：详细解释逆推优化原理，代码实现清晰，处理了存活概率为 0 或 1 的特殊情况  
   - **代码**：通过双重循环实现背包 DP 和逆推，模块化设计  

2. **Kelin（★★★★☆）**  
   - **亮点**：代码简洁，直接通过前缀/后缀处理优化，适合快速理解  
   - **代码**：使用滚动数组减少内存占用，预处理逆元优化性能  

3. **ZCETHAN（★★★★☆）**  
   - **亮点**：提供完整的数学推导，代码注释详细，适合新手学习  
   - **代码**：严格处理模运算，优化边界条件  

---

### 最优思路提炼  
- **动态维护概率分布**：通过 `dp[i][j]` 实时更新每个单位的存活状态  
- **逆推法优化背包 DP**：避免重复计算，将复杂度从 `O(k^3)` 降为 `O(k^2)`  
- **逆元预处理**：加速概率除法，避免每次调用快速幂  

---

### 同类型题与算法套路  
- **类似题目**：  
  - **P1850 [NOIP2016 提高组] 换教室**：动态规划维护概率期望  
  - **P4095 [HEOI2013] Eden 的背包问题**：逆推法优化背包 DP  
  - **P3758 [TJOI2017] 可乐**：矩阵快速幂优化状态转移  

---

### 推荐题目  
1. **P1850**：动态规划与期望计算  
2. **P4095**：逆推优化背包问题  
3. **P3758**：状态转移矩阵优化  

---

### 可视化与算法演示  
#### **核心步骤可视化**  
1. **锁定技能攻击动画**  
   - **像素血条**：敌方单位显示为 8-bit 血条，攻击时血条闪烁  
   - **概率更新**：用箭头表示 `dp[i][j]` 的转移路径，高亮当前更新的血量  

2. **结界技能概率计算**  
   - **背包 DP 网格**：显示 `g[j]` 的更新过程，动态填充网格  
   - **逆推过程**：用不同颜色区分 `g[j]` 和 `h[j]`，展示逆推时的数值变化  

3. **复古风格交互**  
   - **音效触发**：攻击时播放 8-bit 音效，命中时播放上扬音调  
   - **自动演示模式**：按空格键逐步执行算法步骤，支持速度调节  

#### **Canvas 实现片段**  
```javascript
// 绘制敌方单位血条（伪代码）
function drawUnit(id, hp, maxHp) {
  ctx.fillStyle = '#FF0000'; // 红色血条
  ctx.fillRect(x, y, hp * 10, 20); // 每个血量单位占10像素宽
}

// 背包 DP 网格动态更新
function updateGrid(g) {
  for (let j = 0; j <= k; j++) {
    ctx.fillStyle = `hsl(${g[j] * 100}, 70%, 50%)`; // 颜色反映概率
    ctx.fillRect(j * 30, 100, 25, 25); // 每个格子30像素间距
  }
}
```

---

### 个人心得摘录  
- **调试教训**：逆元未预处理导致 TLE，需提前计算所有可能用到的逆元  
- **优化技巧**：将存活概率为 1 的情况单独处理，避免除以 0 的错误  

---

### 代码实现（核心逻辑）  
```cpp
// 锁定技能处理（RabbitHu 题解）
void attack(int tar, ll x) {
  ll y = (1 - x + P) % P;
  for (int i = 0; i <= b[tar]; i++) {
    if (i) rate[tar][i] = rate[tar][i] * y % P;
    if (i < b[tar]) rate[tar][i] = (rate[tar][i] + rate[tar][i+1] * x) % P;
  }
}

// 结界技能逆推（Kelin 题解）
if (px[i] == 1) {
  for (int j = 0; j < m; j++) f[j] = g[j + 1];
} else {
  int inv = qpow(sub(1, px[i]), P - 2);
  for (int j = 0; j < m; j++) {
    f[j] = (g[j] - (j ? f[j-1] * px[i] : 0)) * inv % P;
  }
}
```

---
处理用时：88.96秒
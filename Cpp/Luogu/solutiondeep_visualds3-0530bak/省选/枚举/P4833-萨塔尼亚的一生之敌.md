# 题目信息

# 萨塔尼亚的一生之敌

## 题目背景

“Trick or treat！”

万圣节到了，薇奈特、萨塔尼亚和菈菲尔敲开了珈百璃的门，但果然不出所料，珈百璃在打网游，真是颓废啊。

“干嘛，烦死了”珈百璃一脸嫌弃地看着她们

“珈百璃，好歹也出来玩玩嘛，天天待在家里打游戏，会烂掉的”薇奈特抢先说道

“哈？我每天都出去玩啊，去买泡面的时候顺路在家楼下逛了一圈啊”

“这只能算是去小卖部吧，根本不算是出去玩吧”

“对啊，而且万圣节到了，我们一起出去要糖果吃呀”

“哈？你几岁了？还玩这么无聊的游戏”

“不会啊，我觉得很有趣啊”三人异口同声

“真是的，好吧好吧，就陪你们玩玩”

于是珈百璃随着他们三个出去要糖果吃了

“那么，先去谁家呢？”

“我有提议！！”萨塔尼亚激动地抢着说

于是，她们一行人来到了某人家。

“咚咚咚”过了一会，门开了，走出来的，是一个光头吴克

“Trick or treat！”萨塔尼亚开心地叫倒。面前站的，就是她们的班主任。但是，除了萨塔尼亚在开心的要糖果，其他三个人早已经吓得瑟瑟发抖了

“呃。。班。。班主任。。。？老。。老师，这是有误会的。。。”薇奈特颤抖地说道

“哪有什么误会啊？班主任，Trick or treat！哦~再不给糖，就把你画成鬼~”萨塔尼亚依旧天不怕地不怕

“喂。。。”薇奈特微微后退了一步

但令人惊讶的是，老师居然进房间，拿了一袋礼品出来，其中包括萨塔尼亚最喜欢的限量版菠萝包

“啊！！！是限量版的！！！太好了！！！”当萨塔尼亚刚要伸手去拿菠萝包时，天使的走狗杀了出来，一把抢走了菠萝包。

“喂！！那是我的！！你给我回来”萨塔尼亚生气地望着天使的走狗，宣誓自己一定要抢回来

萨塔尼亚势力和天使的走狗势力占领着不同的区域，每个天使的走狗占领的区域都会有一个菠萝包，萨塔尼亚想抢回这些菠萝包，你能帮助她吗？


## 题目描述

详情是这样的，在萨塔尼亚强大的立场下，这个世界被分成了若干区域，有一些区域有连边。为了能够抢回菠萝包，萨亚尼亚将这些区域再分成了若干领域，使得每个领域由一些区域组成，萨塔尼亚占领了一些领域，并以这些领域为基础向走狗发起进攻。为了成功夺回所有菠萝包，萨塔尼亚决定让这些自己占领的领域满足以下性质

1、    为了能够及时支援友军，在自己占领的领域中，每两个存在于不同领域的两个点都要有连边

2、    为了能够灵活的进攻，自己的任意一个领域中的任意一个点和走狗占领的任意一个领域中的任意一个点都要有连边

当然走狗也不是吃干饭的，它为了羞辱萨塔尼亚，也选择了一些领域，这些领域满足的性质和萨塔尼亚选择的领域满足的性质一样，且走狗的领域和萨塔尼亚的领域互补

萨塔尼亚觉得，只要将领域分的越分散，胜利的几率就越大，于是想分尽可能多的领域，请问最多能分多少领域？每个领域有多少个区域组成？

\*特殊的，一个人可能占领不到任何一个领域，即占领的领域数量为0。如果你能告诉萨塔尼亚答案，萨塔尼亚就会占领最大的领域向走狗发起进攻，并最终失败。


## 说明/提示

样例解释：最多分成两个领域，区域1、3为一个领域，区域2为一个领域

请结合样例仔细读题！

对于40%的数据，n≤10^3，m≤5\*10^5

对于100%的数据，n≤10^5，m≤2\*10^6


## 样例 #1

### 输入

```
3 2
1 2
2 3
```

### 输出

```
2
1 2
```

# AI分析结果



---

**唯一算法分类**：图论（补图连通块）

---

### **题解思路与解决难点**

**核心问题**：求原图的补图连通块数目及每个块的大小。  
**关键难点**：补图边数巨大（$O(n^2)$），无法显式构建。需高效遍历补图。  
**解决思路**：  
1. **链表优化**：维护未访问节点的链表，避免重复检查已处理节点。  
2. **BFS遍历**：从某点出发，标记原图邻居，剩余未标记的即为补图邻居。  

---

### **题解评分**

1. **Resurgammm（5星）**  
   - 思路清晰，链表+BFS高效处理补图连通块。  
   - 代码简洁，用链表动态维护未访问节点，时间复杂度$O(n+m)$。  
   - 注释明确，适合快速理解核心逻辑。  

2. **mayike（4.5星）**  
   - BFS+链表删除实现，逻辑类似Resurgammm。  
   - 代码稍显紧凑，但核心逻辑明确。  

3. **斜揽残箫（4星）**  
   - 链表维护未访问节点，BFS处理补图邻居。  
   - 代码注释较少，但实现与高分题解一致。  

---

### **最优思路提炼**

**核心技巧**：  
- **链表维护未访问节点**：用双向链表存储未访问节点，每次处理时直接遍历链表，删除已访问节点。  
- **标记原图邻居**：遍历原图的邻接点，剩余未标记的节点即为补图中的可达节点。  

**代码片段（Resurgammm）**：  
```cpp
namespace list{
    int pre[maxn],nxt[maxn];
    inline void init(){ /* 初始化链表 */ }
    inline void del(int x){ /* 删除节点 */ }
}

void bfs(int u){
    vis[u] = 1;
    list::del(u);
    queue<int> q; q.push(u);
    while(!q.empty()){
        int x = q.front(); q.pop();
        // 标记原图邻居
        for(int j : e[x]) if(!vis[j]) org[j] = 1;
        // 遍历链表找补图邻居
        for(int j = list::nxt[0]; j; j = list::nxt[j]){
            if(!org[j]){
                vis[j] = 1;
                list::del(j);
                q.push(j);
            } else org[j] = 0;
        }
    }
}
```

---

### **同类题型与套路**

1. **补图相关问题**：如判断补图是否为二分图。  
2. **高效遍历隐式图**：如稀疏图中的连通块统计。  
**相似题目**：  
- [P3452 [POI2007] BIU-Offices](https://www.luogu.com.cn/problem/P3452)  
- [CF920E Connected Components?](https://codeforces.com/contest/920/problem/E)  

---

### **可视化设计**

**动画方案**：  
1. **像素网格**：每个节点显示为色块，不同颜色表示不同连通块。  
2. **链表高亮**：当前处理的节点及链表指针移动过程。  
3. **BFS扩散**：队列节点扩展时，补图邻居被染色并加入队列。  

**交互功能**：  
- **步进控制**：单步执行BFS，观察链表更新。  
- **音效**：节点加入队列时播放“滴”声，连通块完成时播放胜利音效。  

**复古风格**：  
- **8位调色板**：使用经典FC颜色（红、蓝、绿）区分状态。  
- **Canvas绘制**：节点排列为网格，链表用箭头连接。  

---

**总结**：本题核心在于利用链表优化补图的BFS遍历，避免显式建图，时间复杂度$O(n+m)$。通过链表动态维护未访问节点，结合原图邻居标记，高效求解补图连通块。

---
处理用时：52.27秒
# 题目信息

# Samcompu Loves Water

## 题目背景

Samcompu拥有大量的**"水"**资源！！

## 题目描述

Samcompu需要制定一个**水**计划。这个计划的主要目的就是为了避开老师监视的时间来水。

老师在中途会离开机房$T$次，第$i$次将会离开$tim_i$秒。Samcompu划水的时候可不是随便乱水的。他可是拥有**"水"**资源的。在他的库存中有$N$个可以水的网站。Samcompu拥有一种黑科技，他可以几乎不耗任何时间在网站与网站之间跳转并且把跳转的网页的信息秒存。也就是说，Samcompu并不需要在每一次跳转的时候花费时间去浏览网页。当然，这只局限于$N$个网站之间的$N-1$个跳转方式(保证每一个网站都可以跳转到另外的所有网站)。对于第$i$种跳转方式，第$u_i$个网站到第$v_i$个网站的跳转存在一个危险程度$w_i$，这个危险值可能会造成电脑卡死，如果Samcompu不能及时处理，那么就会**完美地**被老师发现。

值得一提的是，在被查水表很多次后，Samcompu总结出了一个规律：

老师走得越久，能够保证在被老师发现之前处理好电脑卡死的危险程度的上限就越高。简单来说，两者就是成正比的关系，比例系数为1。

可惜的是，Samcompu的黑科技并不稳定，在老师第$i$次离开的时候，第$K_i$个跳转方式就不可用了。

当然，每一次水都可以从任意一个网站开始，也可以从任意一个网站结束。

现在Samcompu想知道，对于第$i$次老师离开机房时，他能够有多少种不同的安全的水的方案。两种水的方案不同当且仅当这两种水的方案的第一个网站或者最后一个网站不同。

(补充说明: 一个安全的水的方案当且仅当当前是老师第$j$次离开教室时跳转的路径中不存在一个跳转方式$i$使得$tim_j \leqslant w_i$，每一次水完后不可用的跳转方式就会恢复。)

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/25960.png)

第一次连接1和2的边不可用，当前能经过的边的危险程度需要<1，并没有合法的方案。

第二次连接1和3的边不可用，当前能经过的边的危险程度需要<2，合法的方案有  (1,2)    (2,1)    (3,4)    (4,3)  共四种。

第三次连接3和4的边不可用，当前能经过的边的危险程度需要<3，合法的方案有  (1,2)    (1,3)    (2,1)    (2,3)    (3,1)    (3,2)  共六种。

提醒:本题计算答案按照点对的方式计算.也就是说,如果起点和终点一样,则只看做同一种方案.特别的,$(x,y)$和$(y,x)\ (x \neq y)$算作两种不同的方案.

数据范围：

Subtask 1(30 pts):

$$ T=1 \qquad 1 \leqslant K_i \leqslant N \leqslant 10^3 \qquad 1 \leqslant tim_i, w_i \leqslant 10^3 $$

Subtask 2(50 pts):

$$ 1 \leqslant T \leqslant 5*10^3 \qquad 1 \leqslant K_i \leqslant N \leqslant 10^4 \qquad 1 \leqslant tim_i, w_i \leqslant 10^3 $$

Subtask 3(20 pts):

$$ 1 \leqslant T \leqslant 10^4 \qquad 1 \leqslant K_i \leqslant N \leqslant 10^4 \qquad 1 \leqslant tim_i, w_i \leqslant 10^3 $$

数据保证不同的$K_i$最多只有$10^3$个。

温馨提醒：由于出题人数据比较毒瘤，所以请尽量卡常。

## 样例 #1

### 输入

```
3 5
1 2 1
1 3 2
3 4 1
3 5 3
1 1
2 2
3 3
```

### 输出

```
0
4
6
```

# AI分析结果



---

**算法分类**：并查集、离线处理、树状数组

---

### **题解思路与算法分析**

#### **核心问题**
- 每次老师离开时，求所有安全路径（边的危险程度 < 时间，且禁用某条边）的有序点对数目。

#### **关键步骤**
1. **离线处理**：将边按危险程度排序，询问按时间排序。
2. **并查集动态维护连通性**：逐步加入边，维护各连通块的大小。
3. **预处理断边影响**：对于可能被禁用的边，预处理断开后的分裂大小，快速计算答案变化。

#### **难点与解决方案**
- **断边处理**：常规并查集不支持删除操作。通过构建生成树，预处理每条边断开后的子树大小，利用树状数组维护子树信息。
- **高效查询**：用树状数组维护子树和，查询断边后的分裂大小只需 $O(\log n)$ 时间。

---

### **题解评分（≥4星）**
1. **CYJian的题解（4星）**
   - **亮点**：利用离线处理与并查集，处理不同 $K_i$ 较少的情况。
   - **不足**：需频繁备份并查集状态，时间复杂度较高。
2. **cjZYZtcl的题解（5星）**
   - **亮点**：通过生成树结构预处理断边影响，复杂度优化至 $O((n+T)\log n)$。
   - **代码可读性**：结构清晰，结合并查集与树状数组高效维护子树信息。

---

### **最优思路提炼**
1. **生成树预处理**：按危险程度排序边，构建生成树，记录每条边对应的子树大小。
2. **快速断边计算**：若禁用边的 $w < \text{tim}_j$，总方案数减少 $2 \times s_1 \times s_2$（$s_1, s_2$ 为分裂后的连通块大小）。
3. **树状数组维护**：实时更新子树大小，单点修改、区间查询复杂度为 $O(\log n)$。

---

### **同类型题与算法套路**
- **离线处理+并查集**：适用于动态连通性问题（如 [P1197 星球大战](https://www.luogu.com.cn/problem/P1197)）。
- **树状数组维护子树和**：适用于树结构的动态统计（如 [CF343D Water Tree](https://codeforces.com/problemset/problem/343/D)）。

---

### **推荐题目**
1. [P3367 并查集模板](https://www.luogu.com.cn/problem/P3367)
2. [P1197 星球大战](https://www.luogu.com.cn/problem/P1197)
3. [CF343D Water Tree](https://codeforces.com/problemset/problem/343/D)

---

### **代码核心实现**
```cpp
// 关键代码：合并连通块并更新贡献
void merge(int x, int y) {
    x = gf(x), y = gf(y);
    if (dep[x] > dep[y]) swap(x, y);
    add(dfn[F[x]], -sz[y]);
    add(dfn[F[y]], sz[y]);
    now -= sz[x] * (sz[x] - 1) + sz[y] * (sz[y] - 1);
    f[y] = x;
    sz[x] += sz[y];
    now += sz[x] * (sz[x] - 1);
}

// 处理询问
for (int i = 1; i <= 1000; i++) {
    for (auto u : que[i]) {
        int x = u.first, id = u.second;
        ans[id] = now;
        if (W[x] < i) {
            int Siz = sz[gf(X[x])], Sz = ask(Y[x]);
            ans[id] -= 2 * Sz * (Siz - Sz);
        }
    }
    // 继续加边...
}
```

---

### **可视化设计思路**
1. **动画效果**：用网格表示树结构，红色高亮当前处理的边，绿色表示连通块合并。
2. **像素风格**：8-bit 颜色，边按危险程度渐变色，断开时闪烁警告音效。
3. **交互控制**：步进按钮控制加边/断边，实时显示连通块大小和答案变化。

---

**总结**：通过生成树预处理断边影响，结合并查集与树状数组高效维护子树信息，是本题的最优解法。

---
处理用时：253.05秒
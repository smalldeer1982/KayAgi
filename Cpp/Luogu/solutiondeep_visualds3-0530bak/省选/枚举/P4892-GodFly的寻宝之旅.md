# 题目信息

# GodFly的寻宝之旅

## 题目背景

“蒹葭苍苍，白露为霜。所谓伊人，在水一方…”

怀着$a$ $burning$ $desire$，$GodFly$开启了他追寻学妹之路。

## 题目描述

我们把校园抽象成一个具有$n$个点的无向连通图，其中的$n$个结点分别编号为$1,2,3,...,n$。把$GodFly$经过的结点表示为一个路径集合$A=\left\{a_1,a_2,a_3,...,a_m\right\}$，表示他依次经过了编号为$a_1$、$a_2$、…、$a_m$的结点，由于集合的元素具有互异性，这意味着$GodFly$无法重复经过同一个结点。

$GodFly$现在要从第$1$个结点走到第$n$个结点，然而他的腿疾对他造成了许多不便。定义$GodFly$经过了$m$个结点，当前在点$a_m$，且路径集合$A=\left\{a_1,a_2,a_3...,a_{m-1}\right\}$（加入新结点$a_m$前）时，他的总体力耗费为$w_m=(w_{m-1}+a_m*sum(A))$%$2$，其中$w_{m-1}$表示上一个路径集合的体力耗费；且对于集合$A$，$sum(A)=a_1+a_2+...+a_{m-1}$。

对于$w=0$的情况，我们称$GodFly$处于“滑基态”，否则对于$w=1$的情况，我们称$GodFly$处于“对偶态”。现在$GodFly$想要知道，他走到$n$结点后处于滑基态或对偶态的方案数，由于这个数可能很大，你只需要输出它对$19260817$取膜（模）的结果；注意两个方案是不同的，当且仅当它们有至少一条经过的边不同，而非路径集合不同。

**注意：T3压缩包内第一个数据有误，以题面的样例为准。**

## 说明/提示

**【数据范围】**

对于$30$%的数据，$n<=10$，$k<=45$，无重边及自环；

对于$60$%的数据，$n<=15$，$k<=300$；

对于$80$%的数据，$n<=15$，$k<=100000$；

对于$100$%的数据，$n<=18$，$k<=100000$；

样例数据在**data.zip\fantasy\**中。

**【样例说明】**

![](https://cdn.luogu.com.cn/upload/pic/30986.png)

如图，初始时在$1$结点，路径集合为$\left\{1\right\}$，费用为$0$；

若从$1$走到$2$结点再走到$3$结点，到$2$结点时，费用为$(0+2*sum(\left\{1\right\}))$%$2=2*1$%$2=0$，并把$2$加入路径集合，则此时路径集合为$\left\{1,2\right\}$；到$3$结点时，因上一次费用为0，费用为$(0+3*sum(\left\{1,2\right\}))$%$2=3*(1+2)$%$2=1$；

若从$1$结点直接走到$3$结点，则费用为$(0+3*sum(\left\{1\right\}))$%$2=3*1$%$2=1$。

故最终走到$3$结点时费用为$1$的方案数为$2$。

**【提示】**

本题时限$3s$，且可以开启$O_2$优化，不必过分担心卡常数，但请确保算法足够优美。

## 样例 #1

### 输入

```
3 3
1 2
2 3
1 3
1```

### 输出

```
2```

# AI分析结果



---

**唯一算法分类**：状压动态规划

---

### **题解思路、算法要点与解决难点**

**核心思路**：  
- **路径集合顺序无关性**：路径的节点顺序不影响最终体力值，仅与集合元素有关。这一性质允许将状态简化为当前节点和已访问集合，无需维护路径顺序或中间状态。  
- **状态压缩**：用二进制数表示已访问的节点集合，状态为 `dp[i][s]`，表示当前在节点 `i`，访问集合为 `s` 的方案数。  

**解决难点**：  
1. **状态维度爆炸**：原需三维（节点、集合、w 状态），通过性质优化为二维。  
2. **边权重复处理**：允许重边，转移时直接乘边数贡献。  

**关键算法步骤**：  
1. 预处理所有集合的 `sum` 值（集合元素和模 2）。  
2. 状态转移：枚举当前状态 `s`、节点 `i`，遍历邻接节点 `j`，更新 `dp[j][s | (1<<j)]`。  
3. 最终统计：遍历所有包含起点和终点的集合 `s`，计算其 `w` 是否符合要求。  

---

### **最优思路提炼**

- **性质发现**：路径顺序不影响最终 `w`，仅由集合元素决定。  
- **状态压缩优化**：将三维状态压缩至二维，复杂度从 `O(n^2 * 2^n * 2)` 降至 `O(n^2 * 2^n)`。  
- **预处理求和**：预先计算所有集合的 `sum`，避免重复计算。  

---

### **题解评分 (≥4星)**

1. **Fellyhosn (5星)**  
   - **亮点**：利用关键性质简化状态，代码简洁高效。  
   - **实现**：预处理 `sum`，二维状态转移，复杂度最优。  

---

### **同类型题与算法套路**

- **状压 DP 模板题**：旅行商问题、子集覆盖问题。  
- **类似题目**：  
  1. [P3959 NOIP2017 提高组 宝藏](https://www.luogu.com.cn/problem/P3959)  
  2. [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)  
  3. [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)  

---

### **代码核心片段**

```cpp
// 预处理所有集合的 sum 值
for (int s = 0; s < (1 << n); s++) {
    int sum = 0;
    for (int i = 0; i < n; i++) 
        if (s & (1 << i)) sum += (i + 1);
    sum_mod[s] = sum % 2;
}

// 状态转移
for (int s = 1; s < (1 << n); s++) {
    for (int u = 0; u < n; u++) {
        if (!(s & (1 << u))) continue;
        for (int v = 0; v < n; v++) {
            if (s & (1 << v)) continue;
            int new_s = s | (1 << v);
            dp[v][new_s] += dp[u][s] * graph[u][v];
            dp[v][new_s] %= MOD;
        }
    }
}

// 统计答案
int ans = 0;
for (int s = 0; s < (1 << n); s++) {
    if ((s & 1) && (s & (1 << (n - 1)))) { // 包含起点和终点
        if (calculate_w(s) == target) ans = (ans + dp[n-1][s]) % MOD;
    }
}
```

---

### **可视化与算法演示**

**动画设计**：  
1. **像素网格**：节点以 8-bit 像素点表示，集合状态用二进制位高亮显示。  
2. **状态转移高亮**：当前活跃的节点和边用闪烁效果标记。  
3. **音效反馈**：  
   - **转移成功**：短促“哔”声。  
   - **统计完成**：经典 FC 过关音效。  

**交互控制**：  
- **速度调节**：滑块控制动画速度（0.5x~5x）。  
- **自动演示**：AI 按 BFS 顺序遍历状态，显示转移路径。  

---

### **总结**

本题通过**路径顺序无关性**的性质优化状态设计，结合**状压 DP** 高效求解。在类似问题中，应优先寻找可压缩状态的隐含性质，避免冗余维度。可视化设计可结合复古像素风格增强理解，突出关键状态变化与转移逻辑。

---
处理用时：69.37秒
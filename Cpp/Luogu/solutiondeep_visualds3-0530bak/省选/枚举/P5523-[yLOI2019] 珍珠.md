# 题目信息

# [yLOI2019] 珍珠

## 题目背景

> 别叹息太多告别，至少相遇很真切。  
> 摇曳着盛放枯竭，时间从未停歇。  
> 天涯浪迹的白雪，念念不忘山川蝴蝶。  
> 听说有人孤负黑夜，偏要点亮人间的月。

——银临《珍珠》

## 题目描述

扶苏给了你一个放珍珠的小匣子，这个匣子在左右两端都可以无限制的加入珍珠，珍珠在匣子里会排成一列，每次在左端加入珍珠，这个珍珠会被加入到这个珍珠序列的最左侧，在右端加入则会被加入到珍珠序列的最右侧。初始时，匣子是空的。

这些珍珠要么是黑色的，要么是白色的，为了方便起见，我们将白色看作 $0$，黑色看作 $1$。

在人鱼的世界中，定义颜色 $A$ **组合** 颜色 $B$ 为 $A\operatorname{nand}B$，读作 $A$ 与非 $B$。

定义 $A \operatorname{nand} B = \operatorname{not} (A \operatorname{and}B)$ ，其中 $\operatorname{and}$ 运算代表二进制与运算，$\operatorname{not}$ 运算代表二进制非运算。

定义位置 $x$ 到位置 $y$ 的组合和为：

从 $x$ 开始向 $y$ ，第一个颜色组合第二个颜色的结果组合第三个颜色，得到的结果组合第四个颜色……一直组合到位置 $y$ 的颜色的结果。特别的，$x = y$ 时，组合和为该颜色。

形式化的，设 $C_{x, y}$ 为序列 $A$ 从 $x$ 到 $y$ 的组合和，则
$$C_{x, y} = \begin{cases} C_{x, y - 1} \operatorname{nand} A_y & x < y \\  C_{x, y + 1} \operatorname{nand} A_y & x > y \\ A_x &x = y \end{cases}$$

例如，给定序列 $1, 1, 0, 0$，从 $2$ 到 $4$ 的组合和为 

$$(1 \operatorname{nand} 0) \operatorname{nand} 0 = 1 \operatorname{nand} 0 = 1$$

从 $3$ 到 $1$ 的组合和为

$$(0 \operatorname{nand} 1) \operatorname{nand} 1 = 1 \operatorname{nand} 1 = 0$$

从 $2$ 到 $2$ 的组合和为

$$1$$

扶苏会在匣子的两边加入一些珍珠，或者给定一个位置 $p$，询问你从左向右数第 $1$ 个位置到从左向右数第 $p$ 个位置的组合和，或者从右向左数第 $1$ 个位置到从右向左数第 $p$ 个位置的组合和。

## 说明/提示

#### 样例输入输出 1 解释

第一次操作，$x=0,y=1,z=0$，在匣子右端插入一个 $0$，那么匣子里的珍珠序列为 $\{0\}$

第二次操作，$x = 1,y = 0,z = 1$，查询从左向右数第一个数到第一个数的组合和，答案是 $0$。

第三次操作，$x = 0,y = 1,z = 1$，在匣子右端插入一个 $1$，匣子里的珍珠序列为 $\{0,~1\}$

第四次操作，$x = 1,y = 0,z = 1$，查询从左向右数第一个数到第一个数的组合和，答案是 $0$。

第五次操作，$x = 0,y = 0,z = 0$，在匣子左侧插入一个 $0$，那么匣子里的珍珠序列为 $\{0,~0,~1\}$

第六次操作，$x = 0,y = 1,z = 1$，在匣子右侧插入一个 $1$，那么匣子的珍珠序列为 $\{0,~0,~1,~1\}$

没有任何一次查询的结果满足【输出格式】中提到的任意一种情况，于是输出 ``0 0 0 0``。

---

#### 数据规模与约定

**本题采用多测试点捆绑测试，共有 $7$ 个子任务**。

- Subtask 1（5 points）：$n = m = 0$。
- Subtask 2（15 points）：$n = 1001$。
- Subtask 3（15 points）：$n = 10^5 + 2$。
- Subtask 4（10 points）：$n = 10^7 + 3$，对于所有 $x = 0$ 的操作，保证 $z = 1$。
- Subtask 5（10 points）：$n = 10^7 + 4$，对于所有 $x = 0$ 的操作，保证 $z = 0$。
- Subtask 6（15 points）：$n = 10^7 + 5$，$m = 0$。
- Subtask 7（30 points）：$n = 10^7 + 6$。

对于全部的测试点，保证 $0 \leq n \leq 10^7 + 6$，$0 \leq m \leq \min(n, 10^6)$，$x, y \in \{0, 1\}$，且对于所有 $x = 0$ 的操作，保证  $z \in \{0, 1\}$，若设 $k$ 为在任一查询时匣子里的珍珠个数，则保证对于 $x = 1$ 的操作，$1 \leq z \leq k$，匣子为空时不会有查询操作。

---

#### 提示与说明

- 请注意常数因子对程序效率造成的影响。
- $n$ 的末位数字可以帮助你快速的判断测试点所属的子任务。
- 由于涉及到非操作，与非运算可能不具备一些常见位运算的运算律，请格外注意。
- std 使用 C++ 语言，保证时限是 std 用时的 1.5 倍以上，**但是不保证其他语言能够通过本题**。
- 对于 C++ 选手，如果你直接复制上面的生成器，保证生成器运行总时间不超过 300ms。

## 样例 #1

### 输入

```
6
233 666 250 0```

### 输出

```
0 0 0 0```

# AI分析结果



---

**算法分类**: 数据结构（双端队列维护与预处理）

---

### 题解思路与核心分析

#### 核心难点
1. **与非运算的非结合性**：无法通过简单的前缀和或分段统计直接计算组合和。
2. **动态双端插入**：要求数据结构能高效处理两端插入操作，同时维护关键信息。
3. **高效查询**：需要在 O(1) 时间内响应每个查询，避免暴力计算。

#### 关键思路与实现
1. **运算特性挖掘**：
   - 若序列中存在 `0`，则所有后续运算结果会被其强制转换为 `1`。
   - 连续 `1` 的奇偶性决定最终结果：奇数个 `1` 运算结果为 `0`，偶数个为 `1`。
2. **数据结构设计**：
   - **最近零位置维护**：为每个位置记录左侧/右侧最近的 `0` 的位置（`Left[]` 和 `Right[]`）。
   - **插入操作优化**：插入 `0` 时，向后/向前更新相邻 `1` 的最近零位置，均摊 O(1) 时间复杂度。

---

### 题解评分 (≥4星)

1. **huangzirui (5星)**
   - **亮点**：代码简洁，直接维护 `Left[]` 和 `Right[]`，巧妙处理插入时的连续 `1` 更新。
   - **关键代码**：
     ```cpp
     if (x==0 && y==0 && z==0) { // 左插0
         nowL--;
         Right[nowL] = nowL;
         for (j=nowL+1; MU[j].v==1; j++) MU[j].lp = nowL;
     }
     ```
2. **llingy (4星)**
   - **亮点**：封装双端队列结构，独立维护前缀和后缀的最近零信息。
   - **心得**：通过 `dis[]` 数组记录距离，简化奇偶性判断逻辑。
3. **StudyingFather (4星)**
   - **亮点**：分左右两段数组处理插入，逻辑清晰，注释详细。
   - **优化**：利用 `ltop` 和 `rtop` 动态扩展数组，避免固定长度限制。

---

### 最优技巧提炼

1. **最近零维护法**：
   - **插入 `0` 时**：向后/向前遍历连续 `1`，更新其最近零位置。每个 `1` 仅被更新两次（左/右各一次），保证均摊 O(1)。
   - **查询时**：定位到最近的零，计算连续 `1` 长度奇偶性。
2. **奇偶性快速判断**：
   ```cpp
   // 示例代码（huangzirui）
   if (MU[p].v == 0) _ans = (z != 1); // 单独0的情况
   else {
       int k = MU[p].lp;
       _ans = (p - k + 1) & 1; // 奇偶判断
   }
   ```

---

### 类似题目推荐

1. **P1972 [SDOI2009] HH的项链**：维护区间内最后一个出现的元素位置。
2. **P5490 扫描线**：利用预处理信息优化区间查询。
3. **P3384 树链剖分**：动态维护树结构中的最近祖先信息。

---

### 可视化设计

#### 动画方案
- **像素风格显示**：用红（0）、蓝（1）色块表示双端队列元素。
- **插入操作**：
  - 插入 `0` 时，红色块闪烁，向右/左扩散绿色光晕更新相邻 `1` 的指针。
  - 插入 `1` 时，蓝色块淡入，继承前驱指针。
- **查询操作**：
  - 高亮查询范围，显示最近零位置（黄色标记）。
  - 显示连续 `1` 的奇偶性结果（闪烁数字 0/1）。

#### 交互控制
- **步进控制**：允许单步执行插入/查询，观察指针更新过程。
- **音效反馈**：
  - 插入 `0`：短促“滴”声。
  - 查询成功：8-bit 胜利音效。
  - 错误操作：低沉“哔”声。

---

### 核心代码片段

```cpp
// huangzirui 的插入与查询实现（简化）
void insert(int x, int y, int z) {
    if (x == 0 && y == 0) { // 左插
        if (z == 0) {
            nowL--;
            Left[nowL] = nowL;
            for (int i = nowL + 1; Left[i] == -1; i++) 
                Left[i] = nowL;
        }
    }
}

int query(int y, int z) {
    int pos = get_pos(y, z);
    if (a[pos] == 0) return (z == 1 ? 0 : 1);
    int nearest_zero = Left[pos];
    return (pos - nearest_zero) % 2;
}
```

---

### 总结

本题通过维护最近零位置，将复杂的与非运算转化为奇偶性判断，结合动态插入优化，实现高效查询。其核心在于对运算特性的深刻理解与数据结构的巧妙设计，适用于需要快速响应动态区间查询的场景。

---
处理用时：88.51秒
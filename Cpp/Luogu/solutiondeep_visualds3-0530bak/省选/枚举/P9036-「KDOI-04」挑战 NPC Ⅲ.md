# 题目信息

# 「KDOI-04」挑战 NPC Ⅲ

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/zn5t5x28.png)

## 题目描述

小 S 有一个伟大的梦想：证明 $\text{P}=\text{NP}$。

有一天，他得知一般图最大独立集是 NPC 问题后，决定解决他。

当然小 S 太菜了，解决不了，于是求助于你：

> 给出一个含有 $n$ 个顶点，$m$ 条边的无向图 $G$，求 $G$ 中大小恰好为 $n-k$ 的独立集的数量。由于答案可能很大，请将其对 $998~244~353$ 取模。

小 S 不喜欢多测，因为他在 NOIp 中因为多测挂分，所以本题包含多组测试数据。

## 说明/提示

**【样例解释】**

对于第 $1,2$ 组测试数据，图是完全图，容易发现，完全图的最大独立集为 $1$，并且每一个顶点都单独构成一个独立集。因此第 $1$ 组测试数据的答案为 $0$，第 $2$ 组测试数据的答案为 $4$。

对于第 $3$ 组测试数据，该组数据中给出的无向图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/abt8ho3b.png)

其中，所有大小为 $3$ 的独立集为：

+ $\{2,4,8\}$；
+ $\{2,3,7\}$；
+ $\{3,4,6\}$；
+ $\{2,4,6\}$；
+ $\{1,4,6\}$；
+ $\{2,3,6\}$；
+ $\{1,4,5\}$；
+ $\{2,3,4\}$。

**【数据范围】**

**本题采用捆绑测试。**

![数据范围](https://cdn.luogu.com.cn/upload/image_hosting/p3jwdqp3.png)

对于 $100\%$ 的数据，保证 $1\leq n\leq10^5$，$0\le m\le 10^5$，$0\leq k\leq \min(n-1,18)$，$1\leq T\leq 10^{4}$，$\sum n,\sum m\leq10^6$。

并且对于每个测试点保证：

设 $K=\max k$，即该测试点中所有 $k$ 的最大值，

+ 若 $K\ge 17$，则 $T=1$；
+ 若 $K\ge 15$，则 $T\le 3$；
+ 若 $K\ge 10$，则 $T\le 5$；
+ 若 $K\ge 5$，则 $T\le 300$。


## 样例 #1

### 输入

```
3
4 6 1
1 2
1 3
1 4
2 3
2 4
3 4
4 6 3
1 2
1 3
1 4
2 3
2 4
3 4
8 13 5
1 2
7 8
1 3 
2 5
3 8
6 8
4 7
5 6
5 7
5 8
6 7
1 8
3 5```

### 输出

```
0
4
8```

# AI分析结果



1. **算法分类**  
   - **剪枝的深度优先搜索（DFS）+ 组合数学**

---

### **综合分析与结论**

#### **核心思路与难点**
- **问题转化**：独立集大小 `n-k` ⇨ 点覆盖集大小 `k`。  
- **必选点处理**：度数 `>k` 的顶点必选，否则无法覆盖其邻边（需 `>k` 点，矛盾）。  
- **边数剪枝**：剩余边数若超过 `k²` 则无解（每个点度数 `≤k`，最多覆盖 `k²` 条边）。  
- **状态压缩搜索**：枚举每条未覆盖边的两端点状态（选/不选/强制不选），避免重复计数。  
- **组合数优化**：搜索结束后用组合数计算剩余可选点的合法选法。

#### **可视化设计要点**
- **动画流程**：  
  1. **预处理阶段**：红色高亮度数 `>k` 的必选点，删除其邻边。  
  2. **剩余边检测**：若边数超过 `k²`，显示红色警告并终止。  
  3. **DFS 过程**：  
     - 当前边高亮黄色，遍历其两端点。  
     - 选择左端点 → 蓝色标记，连带删除邻边；选择右端点 → 绿色标记，删除邻边。  
     - 回溯时恢复原色，播放像素音效。  
  4. **结果计算**：成功覆盖所有边后，显示剩余可选点数量，动态计算组合数。  
- **复古风格**：  
  - **8位像素网格**：顶点为 16x16 像素方块，边为单色连线。  
  - **音效**：选择时播放短促“滴”声，回溯时“哔”声，成功时经典 FC 过关音效。  
  - **自动演示**：按预设路径自动执行关键分支，展示最优搜索顺序。

---

### **题解清单 (≥4星)**

1. **Alex_Wei (5星)**  
   - **亮点**：状态标记清晰（0/1/2），组合数直接嵌入搜索函数，处理重边高效。  
   - **关键代码**：通过 `ban[]` 数组标记点状态，动态维护剩余边集合 `buc`。  

2. **_Diu_ (4星)**  
   - **亮点**：优先队列动态选最大度数点，回溯时恢复邻点度数，优化搜索顺序。  
   - **个人心得**：“每次选度数最大的点，剪枝效果显著”。  

3. **Jorisy (4星)**  
   - **亮点**：显式定义 `a_i` 状态，分情况讨论覆盖逻辑，代码结构易扩展。  
   - **关键优化**：预处理组合数表 `c[][]` 加速计算。

---

### **最优思路提炼**

#### **核心步骤**
1. **必选点筛选**：删除所有度数 `>k` 的点，更新剩余边和 `k` 值。  
2. **边数剪枝**：若剩余边 `>k²`，直接返回 0。  
3. **状态压缩搜索**：  
   - 对每条未覆盖边 `(u, v)`，枚举以下状态：  
     - `u` 选且 `v` 选 → 计数 `+2`  
     - `u` 选且 `v` 不选（或反之）→ 计数 `+1`  
   - 确保状态互斥（如不重复计算同时选 `u` 和 `v` 的情况）。  
4. **组合数统计**：剩余 `r` 个未定顶点中选 `k-cnt` 个，直接查表计算。

#### **关键技巧**
- **状态回溯**：用数组记录点的选择状态，搜索后恢复原状。  
- **组合数预处理**：提前计算 `C(n, k)` 避免重复计算。  
- **边去重**：用 `set` 或排序去重，确保边唯一。

---

### **相似题目推荐**
1. **P1979 华容道**（状态压缩+剪枝搜索）  
2. **P2831 愤怒的小鸟**（枚举覆盖组合）  
3. **P1074 靶形数独**（深度优先搜索+剪枝）

---

### **代码片段（核心逻辑）**

```cpp
// Alex_Wei 题解核心搜索逻辑
void dfs(int rest, int cur) {
  if(cur > k) return;
  int e = -1;
  // 找第一条未被覆盖的边
  for(auto it : buc) if(ban[u[it]] != 1 && ban[v[it]] != 1) { e = it; break; }
  if(e == -1) { // 所有边已覆盖
    ans = (ans + bin(rest, k - cur)) % mod;
    return;
  }
  int &x = ban[u[e]], &y = ban[v[e]];
  // 分情况递归
  if(x == 0 && y == 0) {
    x = y = 1; dfs(rest-2, cur+2); // 选两端
    x = 1, y = 2; dfs(rest-2, cur+1); // 选u，v不可选
    x = 2, y = 1; dfs(rest-2, cur+1); // 选v，u不可选
    x = y = 0; // 回溯
  }
}
```

---

### **可视化代码示例（Canvas 动画）**

```javascript
// 绘制顶点与边（简化版）
function drawGraph() {
  ctx.clearRect(0, 0, width, height);
  // 绘制边
  edges.forEach(e => {
    ctx.strokeStyle = e.covered ? '#888' : '#f00';
    drawLine(e.u, e.v);
  });
  // 绘制顶点
  nodes.forEach(node => {
    ctx.fillStyle = node.state === 1 ? '#00f' : 
                    node.state === 2 ? '#0f0' : '#fff';
    drawPixelSquare(node.x, node.y);
  });
}
```

---

**Note**：完整实现需结合具体框架，此处展示核心动画逻辑。实际开发中需处理交互事件与状态同步。

---
处理用时：72.74秒
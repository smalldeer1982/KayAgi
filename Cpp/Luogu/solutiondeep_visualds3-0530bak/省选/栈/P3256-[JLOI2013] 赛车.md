# 题目信息

# [JLOI2013] 赛车

## 题目描述

这里有一辆赛车比赛正在进行，赛场上一共有 $n$ 辆车，分别称为个 $g_1,g_2,...,g_n$。赛道是一条无限长的直线。最初，$g_i$ 位于距离起跑线前进 $k_i$ 的位置。比赛开始后，车辆 $g_i$ 将会以 $v_i$ 单位每秒的恒定速度行驶。在这个比赛过程中，如果一辆赛车曾经处于领跑位置的话（即没有其他的赛车跑在他的前面），这辆赛车最后就可以得奖，而且比赛过程中不用担心相撞的问题。现在给出所有赛车的起始位置和速度，你的任务就是算出那些赛车将会得奖。


## 说明/提示

#### 数据范围与约定

- 对于 $100\%$ 的数据，$1 \le n \le 10^4$，$0 \le k_i \le 10^9$，$0 \le v_i \le 10^9$。

## 样例 #1

### 输入

```
4
1 1 0 0
15 16 10 20```

### 输出

```
3
1 2 4```

# AI分析结果



---

## 唯一算法分类  
**单调栈**

---

## 综合分析与结论  

### 核心思路与难点
题目本质是找出在时间轴上可能成为最高点的直线。通过分析车辆运动轨迹的相遇时间，利用单调栈维护可能成为领跑者的候选车辆。关键要点：
1. **排序预处理**：按速度升序、起点降序排序，确保后续栈操作的正确性。
2. **相遇时间比较**：若当前车超过栈顶车的时间早于栈顶车与次栈顶车的相遇时间，则栈顶车无法领跑。
3. **特殊处理**：速度相同且起点相同的车辆需合并处理，避免重复计算。

### 可视化设计思路
1. **动画方案**：  
   - **动态栈操作**：用像素方块表示车辆，颜色区分不同速度，栈内元素高亮显示。  
   - **时间轴标记**：在时间轴上显示当前比较的相遇时间点，用不同颜色标注关键时间（如栈顶相遇时间 vs 新相遇时间）。  
   - **步进控制**：允许单步执行栈的弹出/压入操作，观察相遇时间变化。  

2. **复古像素风格**：  
   - **8位色块**：用 16 色调色板（如深蓝、红色、黄色）表示不同速度的车辆。  
   - **音效触发**：弹出栈时播放低音“哔”声，压入栈时播放高音“叮”声，成功保留车辆时播放胜利音效。  

3. **Canvas 实现**：  
   ```javascript
   // 伪代码：绘制栈状态
   function drawStack(ctx, stack) {
     stack.forEach((car, idx) => {
       ctx.fillStyle = getColor(car.speed);
       ctx.fillRect(100 + idx * 50, 300 - car.time * 10, 40, 20);
     });
   }
   ```

---

## 题解清单（≥4星）

1. **tylon2006（4.5星）**  
   - **亮点**：简洁的单调栈实现，通过排序与时间比较快速筛选有效车辆。  
   - **代码关键**：`tim`函数计算相遇时间，`while`循环维护栈的单调性。  
   ```cpp
   while(top && (a[i].k>a[stk[top]].k || (top>1 && tim(a[stk[top]],a[i])<tim(a[stk[top-1]],a[stk[top]])))) top--;
   ```

2. **WangHansen（5星）**  
   - **亮点**：处理速度相同且起点相同的车辆，合并答案避免遗漏。  
   - **个人心得**：“速度相同但起点不同的车辆需特殊处理，否则会漏掉并驾齐驱的情况。”  
   ```cpp
   if(c[i].v == sta.top().v && c[i].k == sta.top().k) 
       win[sta.top().id].push_back(c[i].id);
   ```

3. **genshy（4星）**  
   - **亮点**：半平面交的完整实现，处理重复直线与精度问题。  
   - **关键代码**：合并相同直线后求半平面交。  
   ```cpp
   map<PII,vector<int>> tp;
   for(auto &[k,v]: tp) line[++cnt] = {{0,k.x}, {1,k.x+k.y}, v};
   ```

---

## 最优思路提炼  
**单调栈 + 时间比较策略**  
1. **排序**：按速度升序，速度相同按起点降序排序。  
2. **栈维护**：若当前车相遇栈顶车的时间早于栈顶车与次栈顶车的相遇时间，弹出栈顶。  
3. **合并处理**：对速度与起点均相同的车辆合并到同一答案组。  

---

## 同类题目推荐  
1. **P3194 [HNOI2008] 水平可见直线**（单调栈求可见直线）  
2. **P2742 [USACO5.1] 圈奶牛**（计算几何基础，求凸包）  
3. **P1904 天际线**（单调栈处理高度变化）  

---

## 个人心得摘录  
> “速度相同且起点相同的车辆需要合并处理，否则会漏掉并驾齐驱的情况。这让我意识到特殊情况的处理在算法中至关重要。” —— WangHansen  

---

## 核心代码实现（单调栈）  
```cpp
#include<bits/stdc++.h>
using namespace std;
struct data{ int k,v,id; } a[10010];
int stk[10010], top;

bool cmp(data x, data y) {
    if(x.v == y.v) return x.k > y.k; // 速度相同时起点大的在前
    return x.v < y.v;
}

double tim(data a, data b) { // 计算相遇时间
    if(a.v == b.v) return 2e9; // 速度相同无法超越
    return (double)(a.k - b.k) / (b.v - a.v);
}

int main() {
    sort(a+1, a+n+1, cmp);
    stk[++top] = 1;
    for(int i=2; i<=n; i++) {
        // 弹出无效栈顶：当前车起点更大或相遇时间更早
        while(top && (a[i].k > a[stk[top]].k || 
             (top>1 && tim(a[stk[top]], a[i]) < tim(a[stk[top-1]], a[stk[top]])))) 
            top--;
        stk[++top] = i;
    }
    // 合并相同车辆并输出结果
}
```

---

## 可视化交互设计  
**像素动画控制面板**  
```html
<div id="controls">
  <button onclick="step()">▶️ 单步执行</button>
  <input type="range" id="speed" min="1" max="10" value="5">
</div>
<canvas id="anim" width="800" height="400"></canvas>
<script>
let stack = [], cars = sortedCars;
function step() {
  let curr = cars.shift();
  while(shouldPop(stack, curr)) {
    stack.pop(); 
    playSound('pop.wav');
  }
  stack.push(curr);
  drawCars(stack);
}
</script>
```

---
处理用时：85.00秒
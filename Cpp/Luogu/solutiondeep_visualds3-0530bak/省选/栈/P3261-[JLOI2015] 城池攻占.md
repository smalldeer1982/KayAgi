# 题目信息

# [JLOI2015] 城池攻占

## 题目描述

小铭铭最近获得了一副新的桌游，游戏中需要用 $m$ 个骑士攻占 $n$ 个城池。

这 $n$ 个城池用 $1$ 到 $n$ 的整数表示。除 $1$ 号城池外，城池 $i$ 会受到另一座城池 $f_i$ 的管辖，其中 $f_i<i$。也就是说，所有城池构成了一棵有根树。 

这 $m$ 个骑士用 $1$ 到 $m$ 的整数表示，其中第 $i$ 个骑士的初始战斗力为 $s_i$，第一个攻击的城池为 $c_i$。

每个城池有一个防御值 $h_i$，如果一个骑士的战斗力大于等于城池的生命值，那么骑士就可以占领这座城池；否则占领失败，骑士将在这座城池牺牲。占领一个城池以后，骑士的战斗力将发生变化，然后继续攻击管辖这座城池的城池，直到占领 $1$ 号城池，或牺牲为止。

除 $1$ 号城池外，每个城池 $i$ 会给出一个战斗力变化参数 $(a_i,v_i)$。若 $a_i=0$，攻占城池 $i$ 以后骑士战斗力会增加 $v_i$；若 $a_i=1$，攻占城池 $i$ 以后，战斗力会乘以 $v_i$。

注意每个骑士是单独计算的。也就是说一个骑士攻击一座城池，不管结果如何，均不会影响其他骑士攻击这座城池的结果。

现在的问题是，对于每个城池，输出有多少个骑士在这里牺牲；对于每个骑士，输出他攻占的城池数量。

## 说明/提示

对于 $100\%$ 的数据，$1\le n,m\le 3\times 10^5$，$
-10^{18}\le h_i,v_i,s_i\le 10^{18}$，$1\le f_i<i,1\le c_i\le n,a_i\in\{0,1\}$，保证 $a_i=1$ 时，$v_i>0$，保证任何时候骑士战斗力值的绝对值不超过 $10^{18}$。


## 样例 #1

### 输入

```
5 5
50 20 10 10 30
1 1 2
2 0 5
2 0 -10
1 0 10
20 2
10 3
40 4
20 4
35 5```

### 输出

```
2
2
0
0
0
1
1
3
1
1```

# AI分析结果



# 算法分类：左偏树（可并堆）+ 标记下传

## 算法要点与解决难点
1. **核心思路**  
   - 从叶子到根逆向处理城池，每个城池维护一个左偏树（小根堆）
   - 不断弹出堆顶战斗力不足的骑士（牺牲统计）
   - 幸存骑士合并到父节点堆，并应用城池的战斗力变换公式

2. **关键实现细节**  
   - **双标记系统**：维护乘法和加法标记（`tim[]`和`add[]`），遵循先乘后加原则
   - **标记下传顺序**：pushdown 时先处理乘法标记再处理加法标记
   - **树形结构处理**：通过`fa[]`数组逆向合并堆（类似后序遍历）

3. **复杂度优化**  
   - 堆合并操作均摊 O(log n) 复杂度
   - 使用左偏树特性保证堆结构的平衡性

---

## 题解评分（≥4星）

1. **George1123（★★★★★）**  
   - 亮点：完整标记下传实现、错误点分析、防御值比较逻辑清晰  
   - 代码注释详细，包含多个调试陷阱说明

2. **Soulist（★★★★☆）**  
   - 亮点：DFS合并子树堆、标记处理简洁  
   - 缺点：缺少对标记下传顺序的说明

3. **Yaha（★★★★）**  
   - 亮点：完整左偏树结构封装、pushdown函数独立  
   - 缺点：未处理根节点特殊情况的牺牲统计

---

## 最优思路与技巧提炼
```python
核心操作流程：
1. 初始化各城池的左偏树（出生点合并）
2. 从叶子到根遍历城池：
   while 堆顶 < 城池防御值：
       弹出牺牲骑士，记录死亡位置
   if 城池非根节点：
       应用战斗力变换公式（通过标记）
       合并到父节点堆
3. 最终处理根节点剩余骑士
```

---

## 可视化算法演示设计
**动画方案（复古像素风格）**
```html
<!-- 关键DOM结构 -->
<canvas id="castle-canvas"></canvas>
<div class="pixel-controls">
  <button onclick="step()">▶️ 步进执行</button>
</div>
```
```javascript
// 核心动画逻辑（伪代码）
function animateStep(castleId) {
  // 高亮当前城池节点（红色闪烁）
  highlightCastle(castleId); 
  
  // 弹出牺牲骑士动画（下落效果）
  while (heap.top() < castleDef) {
    let knight = heap.pop();
    knight.fallDown(); // 像素下落动画
    playSound('explosion.wav');
  }
  
  // 应用变换公式（绿色光效）
  if (castleId != 1) {
    applyTransformEffect();
    playSound('powerup.wav');
  }
  
  // 合并到父节点堆（粒子飞行动画）
  mergeToParent();
}
```

**复古效果设计**  
- **调色板**：使用NES经典的#6B6B6B（灰）、#FF0000（红）、#00FF00（绿）  
- **音效**：
  - 牺牲骑士：8位爆炸声（短促方波）  
  - 标记下传：上升琶音  
  - 堆合并：数据流动声效  
- **AI自动模式**：按城池ID倒序自动执行，每步间隔500ms

---

## 核心代码实现（George1123版精简）
```cpp
void pushdown(int x) {
  if (add[x] == 0 && tim[x] == 1) return;
  if (ls[x]) {
    tim[ls[x]] *= tim[x];
    add[ls[x]] = add[ls[x]] * tim[x] + add[x];
    s[ls[x]] = s[ls[x]] * tim[x] + add[x];
  }
  if (rs[x]) {
    tim[rs[x]] *= tim[x];
    add[rs[x]] = add[rs[x]] * tim[x] + add[x];
    s[rs[x]] = s[rs[x]] * tim[x] + add[x];
  }
  add[x] = 0, tim[x] = 1;
}

int merge(int x, int y) {
  if (!x || !y) return x + y;
  pushdown(x), pushdown(y);
  if (s[x] > s[y]) swap(x, y);
  rs[x] = merge(rs[x], y);
  if (dep[ls[x]] < dep[rs[x]]) swap(ls[x], rs[x]);
  dep[x] = dep[rs[x]] + 1;
  return x;
}
```

---

## 相似题目推荐
1. [P3377 左偏树（可并堆）模板](https://www.luogu.com.cn/problem/P3377)  
2. [P3273 棘手的操作（可并堆综合应用）](https://www.luogu.com.cn/problem/P3273)  
3. [P4331 序列攻击（树形结构+批量修改）](https://www.luogu.com.cn/problem/P4331)

---

## 调试心得摘录
> **George1123的踩坑记录**  
> - 未初始化`dep[0] = -1`导致堆高计算错误  
> - 乘法标记未同步更新加法标记（`add *= tim`容易遗漏）  
> - 根节点特判遗漏导致MLE  
> 
> **经验总结**：所有标记操作必须成对处理，防御值比较前必须下传标记

---

## 扩展思考
当城池形成DAG（非树结构）时，可引入拓扑排序确定处理顺序，配合优先队列管理多父节点合并。此时需要设计更复杂的标记传递系统。

---
处理用时：71.96秒
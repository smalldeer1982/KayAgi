# 题目信息

# [JXOI2017] 颜色

## 题目描述

可怜有一个长度为 $n$ 的正整数序列 $A_i$，其中相同的正整数代表着相同的颜色。

现在可怜觉得这个序列太长了，于是她决定选择一些颜色把这些颜色的所有位置都删去。

删除颜色 $i$ 可以定义为把所有满足 $A_j = i$ 的位置 $j$ 都从序列中删去。

然而有些时候删去之后，整个序列变成了好几段，可怜不喜欢这样，于是她想要知道有多少种删去颜色的方案使得最后剩下来的序列非空且连续。

例如颜色序列 $\{1, 2, 3, 4, 5\}$，删除颜色 $3$ 后序列变成了 $\{1, 2\}$ 和 $\{4, 5\}$ 两段，不满足条件。而删除颜色 $1$ 后序列变成了 $\{2, 3, 4, 5\}$，满足条件。

两个方案不同当且仅当至少存在一个颜色 $i$ 只在其中一个方案中被删去。


## 说明/提示

满足条件的删颜色方案有 $\{1\}, \{1, 3\}, \{1, 2, 3\}, \{1, 3, 4\}, \{2, 3, 4\}, \varnothing$。

对于 $20\%$ 的数据，保证 $1 \le \sum n \le  20$。

对于 $40\%$ 的数据，保证 $1 \le \sum n \le  500$。

对于 $60\%$ 的数据，保证 $1 \le \sum n \le  10^4$。

对于 $100\%$ 的数据，保证 $1 \le  T,\sum n \le  3 \times 10^5, 1 \le  A_i \le  n$。

$\text{Statement fixed by @Starrykiller.}$

## 样例 #1

### 输入

```
1
5
1 3 2 4 3```

### 输出

```
6```

# AI分析结果



## 算法分类
**哈希 + 前缀和统计**

---

## 题解思路与核心难点

### 核心问题转化
合法方案 ⟺ 剩余元素构成连续区间 ⟺ 区间内的颜色必须全部包含在区间内，且区间外的颜色全部被删除。等价于统计所有满足以下条件的区间 $[L,R]$：
1. 对区间内任意颜色 $c$，其在序列中的最左位置 $min_c \geq L$，最右位置 $max_c \leq R$
2. 区间外的颜色 $c$ 必须满足 $max_c < L$ 或 $min_c > R$

### 解决难点
- **暴力不可行**：直接枚举所有区间的复杂度为 $O(n^2)$，无法通过
- **高效区间合法性判断**：需要快速判断某区间是否满足颜色全包含的条件
- **去重与统计**：不同删除方案可能对应同一区间，需确保唯一性统计

---

## 最优思路提炼：随机哈希 + 前缀和统计

### 关键步骤
1. **随机哈希赋值**：对每个颜色 $c$ 的所有出现位置，随机生成哈希值，使得它们的和为 0（或异或和为 0）
2. **前缀和统计**：计算前缀哈希和，若 $sum[R] = sum[L-1]$，则区间 $[L,R]$ 哈希和为 0，代表颜色全部包含
3. **Map计数**：用 `map<LL, int>` 记录各前缀和的出现次数，统计合法区间数

### 代码实现核心
```cpp
// 为颜色c的每个位置生成随机哈希值
for (int c : colors) {
    vector<int> pos = positions[c];
    if (pos.size() == 1) continue;
    LL sum = 0;
    for (int i=0; i<pos.size()-1; ++i) {
        LL x = rand(); // 生成随机数
        val[pos[i]] = x;
        sum += x;
    }
    val[pos.back()] = -sum; // 最后一位补足和为0
}

// 统计合法区间
map<LL, int> cnt;
cnt[0] = 1;
LL ans = 0, sum = 0;
for (int i=1; i<=n; ++i) {
    sum += val[i];
    ans += cnt[sum];
    cnt[sum]++;
}
```

### 正确性保障
- 合法区间的哈希和必为0（颜色全包含）
- 错误率极低：若非法区间的哈希和为0，概率约为 $2^{-60}$

---

## 题解评分（≥4星）

### 1. Iscream2001 题解（4.5⭐）
- **亮点**：首创哈希思路，代码简洁高效
- **优化点**：使用累加和而非异或，减少冲突概率
- **代码可读性**：结构清晰，变量命名合理

### 2. Ebola 题解（4.2⭐）
- **亮点**：引入异或哈希和概率分析
- **理论支撑**：详细计算错误率，增强可信度
- **实现差异**：异或操作可能更快但冲突率稍高

### 3. Nemlit 题解（4.0⭐）
- **亮点**：提供两种解法对比
- **随机哈希实现**：代码更模块化，适合教学
- **缺点**：缺少详细错误率分析

---

## 可视化设计（复古像素风格）

### 动画流程
1. **初始化**：生成颜色块序列，每种颜色用不同像素色块表示
2. **哈希赋值**：为每个颜色块生成随机像素动画（如闪烁特效）
3. **前缀和计算**：从左到右扫描，显示当前哈希和的变化（类似贪吃蛇吞色块）
4. **合法区间高亮**：当 `sum[R] == sum[L-1]` 时，区间闪烁绿色边框

### 交互设计
- **速度控制**：滑动条调节扫描速度（1x~10x）
- **音效**：
  - `sum` 变化时播放 8-bit "beep"
  - 合法区间触发时播放胜利音效
- **自动演示**：AI 模式自动运行，暂停时显示当前统计结果

### 像素风格实现
```javascript
// Canvas 绘制色块
function drawBlock(x, y, color) {
    ctx.fillStyle = colorPalette[color];
    ctx.fillRect(x*16, y*16, 15, 15);
}

// 哈希和变化动画
function updateSumAnimation() {
    let sum = 0;
    for (let i=0; i<n; i++) {
        sum += hashValues[i];
        drawSumBar(i, sum); // 绘制动态进度条
        playBeep(sum % 4);  // 根据sum末2位调整音高
    }
}
```

---

## 同类型题目推荐
1. [P1972 HH的项链](https://www.luogu.com.cn/problem/P1972)  
   **相似点**：区间颜色统计，莫队或树状数组优化
2. [CF1000F One Occurrence](https://codeforces.com/problemset/problem/1000/F)  
   **相似点**：区间唯一颜色查询，线段树维护最后出现位置
3. [P4065 火星人](https://www.luogu.com.cn/problem/P4065)  
   **相似点**：哈希与前缀和的结合应用

---

## 个人心得摘录
> "哈希法的正确性虽然依赖概率，但在实际比赛中足够可靠。相比线段树的复杂调试，哈希代码更易实现且常数更小。" —— Iscream2001  
> "线段树+栈的方法需要精细处理区间覆盖和边界条件，调试时通过打印栈状态快速定位问题" —— shadowice1984

---

## 核心代码（随机哈希法）
完整代码见用户提供的 Iscream2001 或 Ebola 题解，关键逻辑已在前文提炼。

---
处理用时：78.60秒
# 题目信息

# [CEOI 2011] Balloons

## 题目描述

有 $n$ 个气球，他们一开始都是空的。

接下来，它们会按照从 $1$ 到 $n$ 的顺序依次充气，其中第 $i$ 个气球与地面在 $x_i$ 位置接触。

当气球碰到碰到前面的某个气球，或者达到半径最大限制时，就会停止充气。其中第 $i$ 个气球的半径最大限制为 $r_i$。

现在请你求出，每个气球最终半径是多少。

## 说明/提示

对于 $100\%$ 的数据，保证 $1\le n\le 200\ 000;0\le x_i\le 10^9;1\le r_i\le 10^9;x_1< x_2< \cdots < x_n$。

## 样例 #1

### 输入

```
3
0 9
8 1
13 7```

### 输出

```
9.000
1.000
4.694```

# AI分析结果



# 算法分类  
**单调栈**  

---

# 综合分析与结论  
## 核心思路与难点  
1. **数学推导**：两圆相切时半径关系公式 $r_i = \frac{(x_i - x_j)^2}{4r_j}$  
2. **单调性证明**：若栈顶气球 $j$ 的半径 $r_j$ 小于当前气球 $i$ 的半径 $r_i$，则 $j$ 之前的元素不会影响 $i$ 的后续决策  
3. **栈维护策略**：维护单调递增的半径序列，每次只需与栈顶元素比较，时间复杂度优化至 $O(n)$  

## 可视化设计要点  
1. **像素风格动画**：  
   - **气球**：用圆形像素块表示，颜色随半径渐变（绿色→红色表示半径增大）  
   - **单调栈**：右侧显示栈结构，栈元素用方块表示，方块高度对应半径大小  
   - **高亮操作**：当前比较的栈顶元素闪烁黄色，计算 $(x_i - x_j)^2/(4r_j)$ 时显示红色虚线连接两气球  
2. **交互功能**：  
   - **步进控制**：支持暂停/继续/单步执行，观察栈弹出与压入过程  
   - **自动模式**：AI 按固定速度自动运行，展示栈动态变化  
3. **音效设计**：  
   - **弹出栈顶**：播放“叮”声  
   - **压入栈**：播放“嘟”声  
   - **半径更新**：数值变化时伴随水滴音效  

---

# 题解清单 (≥4星)  
1. **嘉然小姐的狗（5星）**  
   - **亮点**：详细证明了单调栈的决策性质，代码简洁高效  
   - **代码片段**：  
     ```cpp  
     stack.clear();  
     for (i = 1 to n)  
         while (stack not empty)  
             j = stack.top();  
             r[i] = min(r[i], (x[i]-x[j])^2/(4*r[j]));  
             if (r[i] < r[j]) break;  
             else stack.pop();  
         stack.push(i);  
     ```  
2. **DiruiXiao（4星）**  
   - **亮点**：代码极简，直接体现核心逻辑  
   - **代码片段**：  
     ```cpp  
     while (top > 0) {  
         j = stack[top];  
         r[i] = min(r[i], (x[i]-x[j])*(x[i]-x[j])/(4*r[j]));  
         if (r[i] <= r[j]) break;  
         else top--;  
     }  
     ```  
3. **Liu_Tianze（4星）**  
   - **亮点**：图形化解释两圆相切的勾股定理推导  
   - **个人心得**：  
     > "若 $ans_{i-2} < ans_{i-1}$，则 $i$ 不会受 $i-2$ 影响——这一观察是单调栈优化的关键。"  

---

# 最优思路提炼  
1. **关键公式**：$r_i = \min \left( r_i, \frac{(x_i - x_j)^2}{4r_j} \right)$，$j$ 为栈中元素  
2. **单调性维护**：栈内半径严格递增，确保后续决策只需检查栈顶  
3. **弹出条件**：若当前半径 $r_i \geq r_j$，则栈顶 $j$ 不再影响后续元素，直接弹出  

---

# 同类型题与算法套路  
1. **直方图最大矩形（单调栈经典问题）**  
2. **接雨水（单调栈计算凹槽）**  
3. **滑动窗口最大值（单调队列）**  

---

# 推荐相似题目  
1. [P1901 发射站](https://www.luogu.com.cn/problem/P1901)  
2. [P4147 玉蟾宫](https://www.luogu.com.cn/problem/P4147)  
3. [P5788 单调栈模板](https://www.luogu.com.cn/problem/P5788)  

---

# 可视化与算法演示  
**核心流程动画步骤**：  
1. **初始化**：画布左侧显示按 $x_i$ 排列的气球（灰色未充气），右侧显示空栈  
2. **充气过程**：  
   - 当前气球变为蓝色，计算与栈顶气球（黄色高亮）的相切半径  
   - 若新半径小于栈顶半径，压入栈（绿色方块），否则弹出栈顶（红色闪烁）  
3. **动态更新**：气球半径实时显示，栈结构同步变化  

**复古特效代码片段**（伪代码）：  
```javascript  
// Canvas 绘制栈元素  
function drawStack() {  
    ctx.fillStyle = "#8B00FF"; // 紫色像素方块  
    stack.forEach((elem, idx) => {  
        ctx.fillRect(500, 300 - idx*30, 50, 20); // 栈方块位置  
        ctx.fillText(`r=${elem.r}`, 510, 315 - idx*30);  
    });  
}  
// 音效触发  
function playSound(effect) {  
    const sfx = { pop: "🔔", push: "🎵", update: "💧" };  
    new Audio(sfx[effect]).play();  
}  
```  

---

**总结**：通过单调栈维护决策集合的单调性，将问题复杂度从 $O(n^2)$ 优化至 $O(n)$，核心在于数学推导与栈操作的巧妙结合。

---
处理用时：68.38秒
# 题目信息

# 「Cfz Round 1」Wqs Game

## 题目背景

『博』和『奕』喜欢博弈，尤其喜欢 wqs 带权博弈。

## 题目描述

wqs 带权博弈在一个数列 $\{a_i\}$ 上进行，对应有一个 $01$ 串 $\{b_i\}$。

1. 若 $b_i=0$，则 $a_i$ 这个数字是属于『博』的；
2. 若 $b_i=1$，则 $a_i$ 这个数字是属于『奕』的。

游戏规则是，每次给定一个区间 $[l,r]$，从 $a_l$ 到 $a_r$，拥有这个数的人**依次**决定选该数或者不选，两个人都会采用**最优策略**。

因为『博』很强大，她会让着『奕』，于是博弈的规则是，如果最后两个人选的数**按位异或和不为零**，则『奕』获胜，否则『博』获胜。

注意每个人**能看到**对方的选数情况，可以选**多个**数（只要这个数是自己的），最后计算两个人选数的总**异或**和。

对于任意区间 $[l,r]$，若『奕』获胜，则 $w(l,r)=1$，否则 $w(l,r)=0$。

每次查询 $\sum\limits_{l=L}^R\sum\limits_{r=l}^Rw(l,r)$ 的值，对 $2^{32}$ 取模。

由于输入输出量过大，对于 $tp\ne 0$ 的测试点，选手需要自行生成数列 $a_i$ 和询问区间 $[L,R]$，并用特殊方式输出答案。

注意正解**不依赖**特殊的输入输出方式。

## 说明/提示

#### 【样例解释 #1】

只有 $w(1,1)=w(1,2)=1$。

对于区间 $[1,3]$，如果『奕』选第一个数，则『博』选后两个数，否则『博』不选，于是『博』获胜。

注意是从左往右依次选取，『博』在选后两个数之前能够知道『奕』是否选了第一个数。

#### 【样例解释 #2】

只有 $w(1,1)=w(1,2)=w(1,3)=w(1,4)=w(2,3)=w(2,4)=w(3,3)=w(3,4)=1$。

#### 【样例解释 #3】

由于本样例 $tp\ne 0$，所以你需要使用特殊方式输入输出。

#### 【数据范围】

对于所有数据，$1\le n\le5\times10^5,1\le q\le 1.5\times10^6,0<a_i<2^{60},1\le L\le R\le n,0\le tp<2^{64}$。

| 子任务编号 | 分值 |    $n\le$     |     $q\le$      |  $tp$  |  $a_i<$  | 特殊性质 |
| :--------: | :--: | :-----------: | :-------------: | :----: | :------: | :------: |
|    $1$     | $6$  |     $20$      |      $100$      |  $=0$  | $2^{60}$ |    有    |
|    $2$     | $7$  |     $100$     |     $10^3$      |  $=0$  | $2^{10}$ |    有    |
|    $3$     | $8$  |     $700$     |     $10^3$      |  $=0$  | $2^{10}$ |    无    |
|    $4$     | $9$  |    $3000$     |     $10^5$      |  $=0$  | $2^{60}$ |    无    |
|    $5$     | $14$ | $3\times10^4$ |     $10^5$      |  $=0$  | $2^{20}$ |    无    |
|    $6$     | $17$ | $2\times10^5$ | $1.5\times10^6$ | $\ge1$ | $2^{60}$ |    有    |
|    $7$     | $19$ | $5\times10^5$ | $1.5\times10^6$ | $\ge1$ | $2^{60}$ |    有    |
|    $8$     | $20$ | $5\times10^5$ | $1.5\times10^6$ | $\ge1$ | $2^{60}$ |    无    |

特殊性质：序列 $b_i$ 中最多有 $10$ 个 $0$。

#### 【备注】

数据生成方式：

```cpp
using ul=unsigned long long;
using ui=unsigned int;
ui Ans,ans;
ul Sd,Cnt;
ul Rd(){Sd^=Sd<<19,Sd^=Sd>>12,Sd^=Sd<<29;return Sd^=++Cnt;}
void GetA(ul &a){a=Rd()%((1ull<<60)-2)+1;}
void GetLR(int &l,int &r){
    l=Rd()%n+1,r=Rd()%n+1;
    if(l>r)swap(l,r);
}
int main(){
    //read n,q,tp,b[i]
    if(tp){
        Sd=tp,Cnt=0;
        for(int i=1;i<=n;++i)GetA(a[i]);
        for(int qi=1;qi<=q;++qi){
            GetLR(l,r);
            //sol
            Ans^=ans*qi;
        }
        printf("%u\n",Ans);
	}
}
```

## 样例 #1

### 输入

```
3 2 0
100
3 1 2
1 3
2 3```

### 输出

```
2
0```

## 样例 #2

### 输入

```
5 2 0
10100
2 7 6 3 5
1 5
2 4```

### 输出

```
8
4```

## 样例 #3

### 输入

```
20 100 8551679995685981130
11001000000000000000```

### 输出

```
1673```

# AI分析结果



## 【唯一算法分类】
博弈论+线性基+扫描线

## 【题解思路、算法要点与解决难点】

### 核心思路
奕获胜的条件是存在某个奕的数字无法被后续博的线性基抵消。预处理每个奕位i的最远右边界r_i（无法被i+1到r_i的博基表示），统计所有包含i且r≤r_i的区间贡献。

### 算法要点
1. **线性基动态维护**：从右往左扫描，维护博的线性基。遇到奕位i时，查询当前基是否能表示a_i，若不能则记录r_i为当前最大不可达位置。
2. **区间贡献统计**：利用树状数组维护右端点贡献，每个右端点r的合法左端点区间为[1, max_r_i]，通过区间加和前缀和快速统计。

### 解决难点
- **高效线性基维护**：采用时间戳优化的线性基，保证插入时优先保留更左的博位，便于快速判断奕位是否可抵消。
- **贡献区间合并**：将每个奕位i的贡献区间[i, r_i]快速合并到总贡献中，通过并查集或树状数组优化区间操作。

## 【最优思路或技巧提炼】
- **时间戳线性基**：在插入博位时维护每个基元的时间戳（位置），查询时自动选择最左的可用基元。
- **逆向扫描+贡献区间**：从右向左处理，动态维护线性基，并记录每个奕位的最远影响范围。
- **树状数组优化**：将二维区间求和转化为一维前缀操作，利用差分数组高效处理区间更新。

## 【题解评分】
- **EnofTaiPeople (5星)**: 逆向扫描+线性基栈合并，均摊O(nw)时间复杂度，代码高效
- **MaxBlazeResFire (4星)**: 前缀线性基+树状数组统计，思路清晰，实现简洁
- **翼德天尊 (4星)**: 时间戳线性基+线段树区间更新，逻辑严谨，注释详细

---

## 【同类型题或类似算法套路】
1. 异或最值问题（如CF 1100F）
2. 动态线性基维护（如LOJ 113）
3. 区间贡献扫描线统计（如LeetCode 850）

---

## 【推荐相似题目】
1. P4839「泉」的结构分析（线性基+区间统计）
2. CF1100F Ivan and Burgers（离线查询+线性基）
3. P3292 [SCOI2016]幸运数字（树上线性基+LCA）

---

## 【可视化与算法演示】

### 动画方案设计
1. **逆向扫描过程**：以像素风格展示从右向左移动的扫描线，博位插入线性基时显示基元变化。
2. **线性基查询**：当处理奕位时，高亮当前a_i值，并显示在基中的查询路径。
3. **贡献区间标记**：用不同颜色标记每个奕位的有效区间，动态展示树状数组的更新过程。

### 复古风格要素
- **8位音效**：插入基元时播放"哔"声，查询失败时播放"咔"声。
- **像素网格**：将数组元素显示为网格块，博位为蓝色，奕位为红色，基元用绿色闪烁。
- **自动演示**：按空格键启动/暂停扫描，方向键控制单步执行。

---

## 【核心代码实现】

### 时间戳线性基（关键片段）
```cpp
struct XXJ{
    ul c[60]; int ti[60];
    void add(ul x, int id){
        for(int i=59; i>=0; i--) if(x>>i&1){
            if(!c[i] || ti[i]>id) 
                swap(c[i],x), swap(ti[i],id);
            if(!x) return;
            x ^= c[i];
        }
    }
    int query(ul x){
        int mx = 0;
        for(int i=59; i>=0; i--) if(x>>i&1){
            if(!c[i]) return -1;
            mx = max(mx, ti[i]);
            x ^= c[i];
        }
        return x ? -1 : mx;
    }
};
```

### 扫描线+树状数组统计
```cpp
for(int i=n; i>=1; i--){ // 逆向扫描
    if(b[i]=='0') base.add(a[i],i);
    else {
        int r = base.query(a[i]);
        R[i] = (r==-1) ? n : r-1;
    }
}

BIT.init(n);
for(int i=1; i<=n; i++){ // 正向统计
    if(b[i]=='1'){
        BIT.add(i, R[i], 1); // 区间[i,R[i]]贡献+1
    }
    // 处理所有以i为右端的询问
    for(auto q : queries[i]) 
        ans[q.id] = BIT.query(q.l, i);
}
```

---

## 【个人心得摘录】
"线性基合并时要像贪吃蛇一样吞并前面的无效区间，每次合并都意味着旧基无法处理当前位，这种均摊思维是优化的关键。" —— EnofTaiPeople

---

## 【算法演示交互说明】
1. **Canvas布局**：左侧显示数组元素（红蓝方块），右侧显示线性基状态（绿色格子表示有效位）
2. **控制面板**：  
   - Speed: [▮▮▮▯▯] 调节扫描速度  
   - Sound: [✓] 开启8位音效  
   - Auto: [▶] 自动播放/暂停  
3. **操作提示**：点击奕位方块可查看其影响区间，悬浮基元显示对应二进制位和时间戳

---
处理用时：75.25秒
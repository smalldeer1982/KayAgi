# 题目信息

# [HAOI2018] 苹果树

## 题目背景

HAOI2018 Round2 第一题

## 题目描述

小 C 在自己家的花园里种了一棵苹果树, 树上每个结点都有恰好两个分支. 经过细心的观察, 小 C 发现每一天这棵树都会生长出一个新的结点.

第一天的时候, 果树会长出一个根结点, 以后每一天, 果树会随机选择一个当前树中没有长出过结点 的分支, 然后在这个分支上长出一个新结点, 新结点与分支所属的结点之间连接上一条边.

小 C 定义一棵果树的不便度为树上两两结点之间的距离之和, 两个结点之间 的距离定义为从一个点走到另一个点的路径经过的边数.

现在他非常好奇, 如果 $N$ 天之后小 G 来他家摘苹果, 这个不便度的期望 $E$ 是多少. 但是小 C 讨厌分数, 所以他只想知道 $E \times N !$ 对 $P$ 取模的结果, 可以证明这是一个整数.

## 说明/提示

![Explanation](https://cdn.luogu.com.cn/upload/pic/18067.png)

以上是所有 $N = 3$ 时可能的苹果树形态, 其中编号表示这个结点是第几天生
长出来的, 显然每种情况两两结点的距离均为 $4$ .

### 数据范围与约定
| 测试点编号   | $N$  | $P$  |
| :--------: | :--: | :--: |
| $1$ |  $\le 10$    |  $\le 10^9 + 7$    |
| $2$ |  $\le 10$    |   $\le 10^9 + 7$    |
| $3$ |  $\le 500$    |  $\le 10^9 + 7$     |
| $4$ |  $\le 500$    |   $\le 10^9 + 7$    |
| $5$ |  $\le 500$    |   $\le 10^9 + 7$    |
| $6$ |  $\le 2000$    |   $= 10^9 + 7$    |
| $7$ |  $\le 2000$    |   $= 10^9 + 7$    |
| $8$ |  $\le 2000$    |   $\le 10^9 + 7$    |
| $9$ |  $\le 2000$    |   $\le 10^9 + 7$    |
| $10$ | $\le 2000$     |    $\le 10^9 + 7$   |



## 样例 #1

### 输入

```
3 610745795```

### 输出

```
24```

## 样例 #2

### 输入

```
305 1000000007```

### 输出

```
865018107```

# AI分析结果



1. **算法分类**  
   组合数学、动态规划

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
- **边的贡献**：每条边对总距离的贡献为 `size * (n - size)`，其中 `size` 为子树大小。
- **组合数学**：通过枚举每个节点 `i` 及其可能的子树大小 `siz`，计算该情况出现的方案数，并累加贡献。

#### **算法要点**
1. **贡献拆分**：将总距离和转化为每条边的贡献。
2. **方案数计算**：
   - **子树内部**：选择 `siz-1` 个节点组成子树，方案数为 `C(n-i, siz-1) * siz!`。
   - **子树外部**：剩余节点的生成方式为 `i*(i-1)*(n-siz-1)!`。
3. **预处理**：阶乘和组合数预处理加速计算。

#### **解决难点**
- **动态规划优化**：通过 `O(n²)` 预处理组合数和阶乘，避免重复计算。
- **子树分割证明**：正确推导子树内外的方案数乘积关系，确保不重复不遗漏。

---

### **题解评分（≥4星）**

1. **shadowice1984（5星）**  
   - **亮点**：详细推导组合数与阶乘的拆分关系，代码简洁高效。  
   - **关键代码**：预处理阶乘和组合数，双重循环枚举 `i` 和 `siz`。

2. **TonyYin（5星）**  
   - **亮点**：分步骤图解子树内外生成过程，代码可读性强。  
   - **关键代码**：组合数直接计算贡献，避免逆元问题。

3. **lhm_（4星）**  
   - **亮点**：代码最简，直接实现核心公式，适合快速理解。  
   - **关键代码**：使用 `C(n-i, siz-1)` 和阶乘快速计算。

---

### **最优思路与技巧**

#### **关键公式**
总贡献为：
$$
\sum_{i=1}^n \sum_{siz=1}^{n-i+1} siz \cdot (n-siz) \cdot C_{n-i}^{siz-1} \cdot siz! \cdot i \cdot (i-1) \cdot (n-siz-1)!
$$

#### **实现技巧**
- **预处理组合数**：通过递推公式 `C[i][j] = C[i-1][j] + C[i-1][j-1]` 预处理。
- **阶乘加速**：直接计算阶乘模值，避免重复乘法。

---

### **同类型题推荐**
1. [P3974 组合数问题](https://www.luogu.com.cn/problem/P3974)  
2. [P1350 车的放置](https://www.luogu.com.cn/problem/P1350)  
3. [P3223 排队](https://www.luogu.com.cn/problem/P3223)  

---

### **可视化与算法演示**

#### **动画设计**
- **网格展示**：以 `i` 为横轴，`siz` 为纵轴，逐格高亮计算过程。
- **颜色标记**：
  - **红色**：当前计算的节点 `i` 和子树大小 `siz`。
  - **蓝色**：组合数 `C(n-i, siz-1)` 和阶乘项。
- **步进控制**：支持单步调试，观察每一步的乘积项如何累加到总答案。

#### **复古像素风格**
- **8位音效**：每次累加贡献时播放“滴”声，完成一行计算后播放短旋律。
- **Canvas绘制**：用像素方块表示 `i` 和 `siz`，动态更新贡献值。

---

### **核心代码实现**
```cpp
#include<cstdio>
using namespace std;
const int maxn=2010;
int n,mod,fac[maxn],C[maxn][maxn],ans;

void init() {
    fac[0]=1;
    for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;
    for(int i=0;i<=n;i++) {
        C[i][0]=1;
        for(int j=1;j<=i;j++) 
            C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
    }
}

int main() {
    scanf("%d%d",&n,&mod);
    init();
    for(int i=1;i<=n;i++)
        for(int siz=1;siz<=n-i+1;siz++) {
            ll term = 1ll * siz * (n - siz) % mod;
            term = term * C[n-i][siz-1] % mod;
            term = term * fac[siz] % mod;
            term = term * i % mod * (i-1) % mod;
            term = term * fac[n-siz-1] % mod;
            ans = (ans + term) % mod;
        }
    printf("%d",ans);
    return 0;
}
```

---

### **总结**
通过组合数学拆分每条边的贡献，预处理阶乘和组合数实现高效计算，时间复杂度 `O(n²)`，适合 `n ≤ 2000` 的数据范围。

---
处理用时：78.51秒
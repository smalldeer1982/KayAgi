# 题目信息

# [CSP-S2019] 树的重心

## 题目描述

小简单正在学习离散数学，今天的内容是图论基础，在课上他做了如下两条笔记：
1. 一个大小为 $n$ 的树由 $n$ 个结点与 $n - 1$ 条无向边构成，且满足任意两个结点间**有且仅有**一条简单路径。在树中删去一个结点及与它关联的边，树将分裂为若干个子树；而在树中删去一条边（保留关联结点，下同），树将分裂为**恰好**两个子树。
2. 对于一个大小为 $n$ 的树与任意一个树中结点 $c$，称 $c$ 是该树的**重心**当且仅当在树中删去 $c$ 及与它关联的边后，分裂出的所有子树的大小均**不超过** $\lfloor \frac{n}{2} \rfloor$（其中 $\lfloor x \rfloor$ 是下取整函数）。对于包含至少一个结点的树，它的重心只可能有 1 或 2 个。

课后老师给出了一个大小为 $n$ 的树 $S$，树中结点从 $1 \sim n$ 编号。小简单的课后作业是求出 $S$ 单独删去每条边后，分裂出的两个子树的重心编号和之和。即：

$$
\sum_{(u,v) \in E} \left( \sum_{1 \leq x \leq n \atop 且 x 号点是 S'_u 的重心} x + \sum_{1 \leq y \leq n \atop 且 y 号点是 S'_v 的重心} y \right)
$$

上式中，$E$ 表示树 $S$ 的边集，$(u,v)$ 表示一条连接 $u$ 号点和 $v$ 号点的边。$S'_u$ 与 $S'_v$ 分别表示树 $S$ 删去边 $(u,v)$ 后，$u$ 号点与 $v$ 号点所在的被分裂出的子树。

小简单觉得作业并不简单，只好向你求助，请你教教他。


## 说明/提示

【样例 1 解释】

对于第一组数据：

删去边 $(1,2)$，1 号点所在子树重心编号为 $\{1\}$，2 号点所在子树重心编号为 $\{2,3\}$。

删去边 $(2,3)$，2 号点所在子树重心编号为 $\{2\}$，3 号点所在子树重心编号为 $\{3,5\}$。

删去边 $(2,4)$，2 号点所在子树重心编号为 $\{2,3\}$，4 号点所在子树重心编号为 $\{4\}$。

删去边 $(3,5)$，3 号点所在子树重心编号为 $\{2\}$，5 号点所在子树重心编号为 $\{5\}$。

因此答案为 $1 + 2 + 3 + 2 + 3 + 5 + 2 + 3 + 4 + 2 + 5 = 32$。

【数据范围】

| 测试点编号 | $n =$ | 特殊性质 |
| :----------- | :----------- | :----------- |
| $1 \sim 2$ | $7$ | 无 |
| $3 \sim 5$ | $199$ | 无 |
| $6 \sim 8$ | $1999$ | 无 |
| $9 \sim 11$ | $49991$ | A |
| $12 \sim 15$ | $262143$ | B |
| $16$ | $99995$ | 无 |
| $17 \sim 18$ | $199995$ | 无 |
| $19 \sim 20$ | $299995$ | 无 |


表中特殊性质一栏，两个变量的含义为存在一个 $1 \sim n$ 的排列  $p_i (1 \leq i \leq n)$，使得：
- A：树的形态是一条链。即 $\forall 1 \leq i \lt n$，存在一条边 $(p_i, p_{i + 1})$。
- B：树的形态是一个完美二叉树。即 $\forall 1 \leq i \leq \frac{n-1}{2}$ ，存在两条边 $(p_i, p_{2i})$ 与 $(p_i, p_{2i+1})$。

对于所有测试点：$1 \leq T \leq 5 , 1 \leq u_i,v_i \leq n$。保证给出的图是一个树。

## 样例 #1

### 输入

```
2
5
1 2
2 3
2 4
3 5
7
1 2
1 3
1 4
3 5
3 6
6 7```

### 输出

```
32
56```

# AI分析结果



---

### 算法分类
树的重心性质 + 树状数组/倍增动态维护

---

### 核心思路与算法要点

#### **核心问题拆解**
1. **重心判定条件**：节点删除后所有子树大小不超过 ⌊n/2⌋  
2. **贡献拆分**：每条边分割为两个子树，分别计算各自的重心贡献  
3. **高效统计**：每个节点作为重心的次数，避免暴力枚举所有边

---

#### **关键算法流程**
1. **确定原始重心为根**  
   ```python
   def find_root():
      通过dfs计算子树大小，找到满足所有子树大小 ≤ n/2 的节点
   ```

2. **预处理子树信息**  
   ```python
   def preprocess():
      计算每个节点的子树大小 siz[u] 和最大子节点 g[u]
   ```

3. **动态维护与统计**  
   - **树状数组维护分割边信息**  
     ```python
     class BIT:
        动态记录不同子树大小的出现次数
     ```
   - **两次DFS处理子树内外情况**  
     ```python
     def dfs(u):
        进入节点时更新树状数组（排除当前子树）
        遍历子节点后回溯时再次查询（排除错误计数）
     ```

---

#### **解决难点**
1. **子树外贡献统计**  
   - 使用两个树状数组：c1维护全局信息，c2维护当前路径信息  
   - 通过进入和回溯时的差值计算有效贡献  

2. **根节点特殊处理**  
   - 维护最大和次大子树（u, v）  
   - 根据分割边是否在最大子树内切换条件判断  

---

### 题解评分（≥4★）

1. **xht的题解（4.5★）**  
   - 亮点：巧妙利用树状数组动态维护，时间复杂度 O(n logn)  
   - 优化点：清晰的变量命名与逻辑分层  

2. **soar_ing的题解（4.2★）**  
   - 亮点：倍增跳转重链快速定位重心，代码短小精悍  
   - 不足：预处理部分注释较少，理解成本略高  

3. **Kinandra的题解（4.0★）**  
   - 亮点：主席树维护子树分布，支持更复杂的查询场景  
   - 不足：空间复杂度较高，实现复杂度增加  

---

### 最优技巧提炼

#### **核心数据结构**
```cpp
struct BIT {
    int c[N];
    void update(int p, int k) { /* 单点增减 */ }
    int query(int p) { /* 前缀和查询 */ }
};
```

#### **重心动态维护**
```cpp
// 计算节点u作为重心的有效分割边数
int valid_count(int u) {
    int L = n - 2 * siz[u];
    int R = n - 2 * g[u];
    return bit.query(R) - bit.query(L-1);
}
```

#### **回溯容斥技巧**
```cpp
void dfs(int u) {
    bit1.remove(siz[u]); // 进入时排除当前子树
    bit2.add(siz[u]);   // 记录当前路径信息
    
    for (v in children):
        dfs(v);
    
    ans -= bit2.query(...); // 回溯时扣除错误计数
}
```

---

### 可视化算法演示

#### **动画设计**
1. **树结构展示**  
   - Canvas绘制树形结构，边用不同颜色标记  
   - 点击边时高亮显示分割后的两个子树  

2. **重心动态追踪**  
   ```javascript
   function highlightCentroid(node) {
      绘制脉冲光圈效果，红色标记当前候选重心
      实时显示子树大小和最大子节点信息
   }
   ```

3. **树状数组操作可视化**  
   ```javascript
   function showBITUpdate(val) {
      显示树状数组的更新过程，用绿色标记新增条目
      显示区间查询范围（黄色半透明覆盖）
   }
   ```

#### **复古像素风格**
- **调色板**：16色FC游戏风格（深绿、品红、青蓝为主）  
- **音效设计**：  
  - 发现重心时播放《超级马里奥》金币音效  
  - 错误操作时播放《塞尔达》受伤音效  
- **自动演示模式**：  
  ```javascript
  function autoPlay() {
     循环执行dfs步骤，每步间隔500ms
     关键操作时触发像素粒子特效
  }
  ```

---

### 相似题目推荐
1. **P1364 医院设置**（树的重心基础应用）  
2. **P1395 会议**（重心与路径统计结合）  
3. **P2634 [国家集训队] 聪聪可可**（点分治模板题）  

---

### 核心代码片段（xht解法）

```cpp
void dfs2(int x, int f) {
    add(c1, s[f], -1); // 排除父节点信息
    add(c1, n - s[x], 1); // 添加当前分割信息
    
    if (x != rt) {
        // 计算有效贡献区间
        ans += x * (query(c1, n-2*g[x]) - query(c1, n-2*s[x]-1));
        ans += x * (query(c2, n-2*g[x]) - query(c2, n-2*s[x]-1));
    }
    
    add(c2, s[x], 1); // 记录当前子树信息
    
    for (int y : children) {
        dfs2(y, x);
    }
    
    // 回溯恢复状态
    add(c1, s[f], 1);
    add(c1, n - s[x], -1);
}
```

---

### 总结
通过结合树的重心性质与高效数据结构，实现 O(n logn) 的最优复杂度。重点在于动态维护分割边的信息，并通过两次DFS巧妙排除错误计数。可视化方案通过像素风格和音效增强理解趣味性，适合教学演示场景。

---
处理用时：93.82秒
# 题目信息

# 「SWTR-4」Collecting Coins

## 题目背景

小 A 喜欢 Collecting Coins。他还有个好朋友叫做小 c。

小 c 在外出游玩的时候被困在了一个迷宫里面，小 A 得知消息后，立刻放下了自己手中正在打的树套树套树套树，出发去营救她。

## 题目描述

经过一番勘察，小 A 发现小 c 被困的迷宫由 $n$ 个房间组成，这些房间用 $n-1$ 扇门连接，**形成了一颗树**。小 c 被困在 $d$ 号房间。

小 A 还发现每扇门上都写有一个数字 $v$，经过该扇门就会获得 $v$ 个金币，但每扇门上的金币只能获得一次。

由于把小 c 困在迷宫里的坏人早已知道小 A 会来救她，所以他们在每个房间里都布下了陷阱，使得第 $i$ 个房间最多可以进入 $k_i$ 次，否则小 A 也会被困在迷宫里。Luckily，小 c 在向小 A 求救的时候，已经将这个陷阱告诉了他。

小 A 在进入迷宫的时候可以任选初始房间 $r$（进入迷宫算一次进入房间 $r$）。**小 A 可以离开迷宫，当且仅当他在房间 $r$。**

如果小 A 进入了 $d$ 号房间，我们就认为他成功地救下了小 c。在救下小 c 后，小 A 还可以带着她继续在迷宫中行动。

虽然小 A 并不是一个非常贪财的人，但还是想知道：在**成功救下小 c** 且离开迷宫的前提下，他最多能获得多少金币。

## 说明/提示

【样例 $1$ 说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/zwtjgksh.png)

一种最优的走法为：$2\to 4\to 2$，共可获得 $5$ 金币。

【样例 $2$ 说明】

如上图，小 A 只能空降到 $4$ 号房间，然后再离开迷宫，共可获得 $0$ 金币。

【样例 $4$ 说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/fmd43hzq.png)

一种最优的走法为：$3\to 9\to 10\to 8\to 10\to 12\to 6\to 12\to 10\to 9\to 3$，共可获得 $100+59+65+9+30=263$ 金币。

【数据范围与约定】

**本题使用捆绑测试。**

Subtask 编号 | $n\leq$ | 特殊性质 | 分值 |
:-: | :-: | :-: | :-: |
$1$ | $12$ | $k_i=1$ | $3$ |
$2$ | $12$ | $k_i\leq 3$ | $12$ |
$3$ | $10^3$ | 迷宫为一条链 | $9$ |
$4$ | $10^3$ | 无 | $16$ |
$5$ | $10^5$ | 迷宫为一条链 | $9$ |
$6$ | $10^5$ | 迷宫为一个菊花图 | $16$ |
$7$ | $10^5$ | 无 | $35$ |

对于 $100\%$ 的数据，$1\leq d,k_i\leq n\leq 10^5$，$1\leq v_i\leq 10^4$。

【Source】

[Sweet Round 04](https://www.luogu.com.cn/contest/26414)$\ \ $E

idea & std：[Alex_Wei](https://www.luogu.com.cn/user/123294)，验题：[chenxia25](https://www.luogu.com.cn/user/138400)

## 样例 #1

### 输入

```
6 4
1 2 3
2 3 4
2 4 5
3 5 2
3 6 3
1 2 1 1 2 2
```

### 输出

```
5```

## 样例 #2

### 输入

```
6 4
1 2 3
2 3 4
2 4 5
3 5 2
3 6 3
1 1 1 1 1 1
```

### 输出

```
0```

## 样例 #3

### 输入

```
6 4
1 2 3
2 3 4
2 4 5
3 5 2
3 6 3
2 2 2 2 2 2
```

### 输出

```
12```

## 样例 #4

### 输入

```
12 6
1 4 33
2 11 51
3 9 100
4 8 7
5 9 35
6 12 30
7 11 58
8 10 65
9 10 59
10 12 9
11 12 72
2 2 2 3 2 1 2 1 2 3 2 2
```

### 输出

```
263```

# AI分析结果



## 算法分类
**树形动态规划**

---

## 题解思路与核心难点

### 核心算法分析
1. **问题建模**  
   - 树形迷宫转化为以 $d$ 为根的树结构，每个节点的进入次数限制 $k_i$ 对应其度数限制。
   - 路径选择需满足：必须经过 $d$，且最终回到起点（入口 $r$）。

2. **状态设计**  
   - 核心状态：`f[u][0/1]`  
     - `f[u][0]`：以 $u$ 为根的子树中未选择入口时的最大金币。
     - `f[u][1]`：已选择入口时的最大金币。
   - 入口限制：入口 $r$ 需满足 `k_r` 的限制（入口算一次进入）。

3. **转移方程**  
   - **未选入口（`f[u][0]`）**  
     选择前 `k[u]-1` 大的子节点贡献（每个子节点 `f[v][0] + val(u,v)`）。
   - **已选入口（`f[u][1]`）**  
     分两种情况：
     1. 入口在子树外：需在 `k[u]-2` 个儿子的贡献中选择。
     2. 入口在子树内：枚举某个子节点 `x`，将其替换为 `f[x][1]` 的贡献。

4. **实现难点**  
   - 子节点贡献排序与动态替换。
   - 换根 DP 的父子节点贡献调整（处理父节点作为新子树的情况）。

---

## 题解评分（≥4星）

### z7z_Eta（⭐⭐⭐⭐⭐）
- **亮点**  
  - 状态设计清晰，通过 `f[u][0/1]` 明确区分入口选择。
  - 代码实现简洁，通过排序和贪心选择前 `k-1` 大的子节点。
  - 处理 `k[u]` 不足时的边界条件（如 `k[u] = 1` 时的特判）。

### Alex_Wei（⭐⭐⭐⭐⭐）
- **亮点**  
  - 换根 DP 的完整实现，两次扫描覆盖所有可能的入口选择。
  - 使用 `set` 维护选择的子节点集合，优化时间复杂度。
  - 官方题解详细解释每个步骤的逻辑和边界处理。

### BeyondHeaven（⭐⭐⭐⭐）
- **亮点**  
  - 一次 DFS 实现树形 DP，代码简洁高效。
  - 通过 `f[u]` 和 `g[u]` 分别处理入口是否在子树中的情况。
  - 预处理 `k[d]++` 巧妙处理根节点的入口限制。

---

## 最优思路与技巧

### 关键技巧
1. **子节点贡献排序**  
   - 对每个节点的子节点按 `f[v][0] + val(u,v)` 降序排序，选择前 `k-1` 大的贡献。
   - 动态替换策略：若入口在某个子节点中，用 `f[x][1]` 替换其 `f[x][0]` 的贡献。

2. **换根 DP 优化**  
   - 第一次 DFS 计算以 $d$ 为根的初始贡献。
   - 第二次 DFS 调整父节点和子节点的贡献，避免重复计算。

3. **边界条件处理**  
   - 入口节点的 `k[d]++` 处理初始进入次数。
   - `k[u] = 1` 时的特判（无法选择任何子节点）。

### 可视化设计思路
1. **树形结构展示**  
   - 用 Canvas 绘制树结构，节点标记 `k` 值和当前选择的子节点数。
   - 高亮当前处理的节点（如红色边框）和已选择的子节点（绿色边框）。

2. **动态排序与替换**  
   - 展示子节点贡献的排序过程（如冒泡排序动画）。
   - 替换操作时用闪烁效果标记被替换的子节点。

3. **复古像素风格**  
   - 节点和边用 8-bit 像素块表示，背景音乐为 8-bit 风格循环音轨。
   - 音效设计：
     - **选择子节点**：短促“滴”声。
     - **替换操作**：轻微“咔嚓”声。
     - **完成计算**：上扬音调。

---

## 类似题目与推荐
1. **P1272 重建道路**（树形 DP 剪枝）
2. **P2015 二叉苹果树**（树形 DP 选择子节点）
3. **P2585 三色二叉树**（状态设计与树形 DP）

---

## 代码实现（核心逻辑）

### z7z_Eta 的树形 DP 代码
```cpp
void dfs(int u, int fa) {
    vector<int> sons;
    for (auto &e : edges[u]) {
        if (e.to != fa) {
            dfs(e.to, u);
            sons.push_back(e.to);
            val[e.to] = e.weight;
        }
    }
    sort(sons.begin(), sons.end(), [](int a, int b) {
        return f[a][0] + val[a] > f[b][0] + val[b];
    });
    int max_choose = min(k[u] - 1, (int)sons.size());
    for (int i = 0; i < max_choose; i++) {
        f[u][0] += f[sons[i]][0] + val[sons[i]];
    }
    if (k[u] > sons.size()) {
        f[u][1] = f[u][0];
        return;
    }
    int replace_min = f[sons[k[u]-1]][0] + val[sons[k[u]-1]];
    f[u][1] = f[u][0] - replace_min;
    for (auto &v : sons) {
        if (/* 子节点 v 包含入口 */) {
            f[u][1] = max(f[u][1], f[v][1] + (f[u][0] - (f[v][0] + val[v])));
        }
    }
}
```

---

## 总结
本题通过树形 DP 和换根技巧，结合贪心选择子节点贡献，解决了树形迷宫中的金币最大化问题。核心在于状态设计和动态替换策略，通过排序和边界处理优化时间复杂度。可视化设计可增强对算法流程的理解，复古像素风格和音效则提升学习趣味性。

---
处理用时：89.55秒
# 题目信息

# [YsOI2020] 造林

## 题目背景

「承前」

Ysuperman 响应号召，决定在幼儿园外造林。

呐呐，如果这样的话，Ysuperman 便能在这炎热的夏天与小朋友们玩游戏了呢。

## 题目描述

为了落实环保工作，Ysuperman 购进了一批树，它们都长一个样。由于树还没有种下去，所以这些树还没有根，可以认为是**无根树**。

Ysuperman 觉得全都种长得一样的树太无聊了，于是 TA 请到了园艺公司帮 TA 规划。园艺公司提供给了 TA 一个方法——「嫁接」。

下面给出「嫁接」操作的定义：

定义「叶子节点」为树上度数为 $1$ 的节点。
 
「嫁接」操作指：在一棵**无根树**上接入一个新的「叶子节点」。

例如：  
![](https://cdn.luogu.com.cn/upload/image_hosting/jfaksqwy.png)

图 2 是由图 1 的树进行一次合法的嫁接操作后得到的树，图 3 也是由图 1 的树进行一次合法的嫁接操作后得到的树。

那么，我们还知道，树有一个基本属性：「品种」。

一棵树的「品种」是指**每个点的最大子树大小所构成的可重集**。

两棵树的「品种」不同，当且仅当**每个点的最大子树大小所构成的可重集不同**。

这里的一个点的**最大子树大小**指将这个点删掉后**最大的联通块所包含的点数**。

例如：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zzyznfl7.png)

图 4 的树的每个点的最大子树大小所构成的可重集为：$ \{ 2,2,3,3 \} $  
图 5 的树的每个点的最大子树大小所构成的可重集为：$ \{ 2,2,3,3 \} $  
图 6 的树的每个点的最大子树大小所构成的可重集为：$ \{ 1,3,3,3 \} $  
所以说，图 4 的树与图 5 的树「品种」相同，与图 6 的树「品种」不同。

Ysuperman 想知道，通过一次「嫁接」操作，可以构造出的树包含多少不同的「品种」，以及对于每个「品种」，有多少不同的「嫁接」方法可以构造。请**从小到大**输出每个「品种」的「嫁接」方法数。

两个「嫁接」方案不同，当且仅当在「嫁接」操作中与新接入的「叶子节点」直接相连的点不同。


## 说明/提示

**本题采用捆绑测试。**
### 样例解释 1
可以构造出 1 种「品种」为 $\{2,4,4,5,5,5\}$ 的树。  
可以构造出 2 种「品种」为 $\{3,3,4,5,5,5\}$ 的树。  
可以构造出 2 种「品种」为 $\{3,3,4,4,5,5\}$ 的树。
### 样例解释 2
可以构造出 1 种「品种」为 $\{3,5,5,7,7,7,7,7\}$ 的树。  
可以构造出 2 种「品种」为 $\{4,4,5,7,7,7,7,7\}$ 的树。  
可以构造出 4 种「品种」为 $\{4,4,5,6,7,7,7,7\}$ 的树。


对于 100% 的数据，满足 $1 \le n\le2\cdot 10^6$。

定义「链」为所有节点度数不超过 $2$ 的树。  
定义「菊花」为包含 $n-1$ 个「叶子节点」的树。

特殊性质 1：保证树的形态为一条「链」。  
特殊性质 2：保证树的形态为一朵「菊花」。  
特殊性质 3：保证树的形态为一棵完全二叉树。

| subtask | $n$ | 特殊性质 | 分值 | 时间限制 |
| :-----------: | :-----------: | :-----------: | :--------:| :---------:|
| 1 | $\le 2\cdot 10^6$ | 2 | 2 | 4s |
| 2 | $\le 2\cdot 10^6$ | 1 | 3 | 4s |
| 3 | $\le 300$ | 无 | 5 | 1s |
| 4 | $\le 2\cdot10^6$ | 3 | 7 | 4s |
| 5 | $\le 5000$ | 无 | 23 | 1s |
| 6 | $\le 5\cdot10^4$ | 无 | 29 | 2s |
| 7 | $\le 2\cdot10^6$ | 无 | 31 | 4s |

### 提示：

如果你不知道完全二叉树是什么意思，Ysuperman 提供了一个链接：[Link](https://zh.wikipedia.org/zh/%E4%BA%8C%E5%8F%89%E6%A0%91#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91)。

输入输出较大，请使用较快的输入输出方式。

如果您使用了所需栈空间较大的递归算法，可以在本地（NOI linux 下）先使用 ```sudo su``` 获取权限，再使用 ```ulimit -s unlimited ``` 命令开启无限栈。

题目并不难。

## 样例 #1

### 输入

```
5
1 2
2 3
3 4
4 5
```

### 输出

```
3
1
2
2
```

## 样例 #2

### 输入

```
7
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
1
2
4
```

## 样例 #3

### 输入

```
25
15 9
22 15
23 22
25 15
13 23
6 22
12 15
1 23
19 13
18 9
11 15
17 1
4 25
3 1
8 9
20 1
10 18
21 20
16 8
2 22
24 1
7 19
5 16
14 7
```

### 输出

```
17
1
1
1
1
1
1
1
1
1
1
2
2
2
2
2
2
3
```

# AI分析结果



### 算法分类  
树的重心与双哈希统计

---

### 题解核心思路与难点对比  
**核心逻辑**：  
1. **重心特性**：嫁接后不改变权值的节点构成一条链，链的起点为重心（或重心所在子树）  
2. **哈希维护**：通过双哈希对每个节点的权值变化进行编码，统计不同哈希值的出现次数  
3. **双重心处理**：若存在双重心（如偶数节点链），需分别处理两棵子树的哈希  

**关键实现对比**：  
| 题解 | 数据结构 | 哈希方式 | 重心处理 |  
|------|----------|----------|----------|  
| clamee | 树形DP+哈希表 | 单哈希（M1=998244353, M2=950009857） | 单次DFS找重心 |  
| _Arahc_ | 双模哈希+桶排序 | 双底数双模哈希（B1=114514, B2=11037） | 显式处理双重心 |  
| lamboo | 树状数组+区间标记 | 随机数异或哈希 | 未明确重心处理 |  

**解决难点**：  
- 确定嫁接后权值不变的节点链（需利用重心子树大小特性）  
- 高效计算哈希变化（通过DFS动态维护路径上的哈希累加值）  

---

### 题解评分（≥4星）  
1. **_Arahc_（★★★★☆）**  
   - **亮点**：双模哈希避免碰撞、显式处理双重心、桶排序优化  
   - **代码**：结构清晰，使用`map<Hashnum, int>`统计结果  

2. **clamee（★★★★☆）**  
   - **亮点**：多子任务特判、哈希表快速查询  
   - **代码**：通用解法中两次DFS处理重心路径  

---

### 最优思路与技巧提炼  
1. **重心路径动态哈希**：  
   - DFS遍历时维护路径哈希值`t1`和`t2`，每次进入子树前更新哈希  
   - 遇到重心最大子树时重置哈希（保证链的正确性）  

2. **双哈希碰撞避免**：  
   ```cpp  
   struct Hashnum {  
       int x1, x2; // 双模哈希值（mod1=1e9+9, mod2=998244853）  
       // 运算符重载确保哈希唯一性  
   };  
   ```  

3. **双重心处理**：  
   ```cpp  
   if (n为偶数且存在双重心) {  
       dfs3(zx2, -1, hs); // 分别处理两个重心子树  
   }  
   ```  

---

### 同类型题与算法套路  
1. **树重心性质**：如 [P1364 医院设置](https://www.luogu.com.cn/problem/P1364)  
2. **树哈希应用**：如 [P5043 树同构](https://www.luogu.com.cn/problem/P5043)  
3. **动态子树统计**：如 [P6591 植树问题](https://www.luogu.com.cn/problem/P6591)  

---

### 可视化设计要点  
**动画方案**：  
1. **树结构展示**：  
   - 用节点大小表示子树大小，红色高亮重心  
   - 嫁接点用闪烁绿色标记，路径链用黄色渐变  

2. **哈希变化过程**：  
   - 左侧面板实时显示当前哈希值`t1`和`t2`  
   - 路径上每个节点权值变化时，显示哈希增量（如`+pw[mx]`）  

3. **复古像素风格**：  
   - **Canvas绘制**：8-bit风格树节点（16x16像素方块）  
   - **音效触发**：  
     - 节点选中：8-bit "beep" 音效（Web Audio API）  
     - 哈希碰撞：短促 "coin" 音效  

**交互控制**：  
- **速度调节**：滑块控制DFS遍历速度（50ms~2s）  
- **AI演示**：自动遍历所有嫁接点，显示哈希统计过程  

---

### 核心代码片段（_Arahc_ 题解）  
```cpp  
// 双模哈希结构体  
struct Hashnum {  
    int x1, x2;  
    Hashnum(int A=0, int B=0) : x1(A), x2(B) {}  
    bool operator < (const Hashnum &b) const {  
        return x1 < b.x1 || (x1 == b.x1 && x2 < b.x2);  
    }  
};  

// DFS维护哈希  
void dfs3(int u, int fa, Hashnum hs) {  
    for (int i = e.hd[u]; i; i = e.nx[i]) {  
        int v = e.to[i];  
        if (v == fa || v == zx || v == zx2) continue;  
        Hashnum t = hs - Hashnum(pw1[mxs[v]+1], pw2[mxs[v]+1])  
                    + Hashnum(pw1[mxs[v]], pw2[mxs[v]]);  
        ++mp[t];  
        dfs3(v, u, t);  
    }  
}  
```  

---

### 总结  
本题通过树重心特性确定影响链，结合双哈希高效统计品种数。实现中需注意双重心和哈希碰撞问题，可视化可突出路径动态哈希与复古交互。

---
处理用时：90.29秒
# 题目信息

# [SNOI2020] 字符串

## 题目描述

有两个长度为 $n$ 的由小写字母组成的字符串 $a,b$，取出他们所有长为 $k$ 的子串（各有 $n-k+1$ 个），这些子串分别组成集合 $A,B$。现在要修改 $A$ 中的串，使得 $A$ 和 $B$ 完全相同。可以任意次选择修改 $A$ 中一个串的一段后缀，花费为这段后缀的长度。总花费为每次修改花费之和，求总花费的最小值。

## 说明/提示

#### 样例说明

对于样例 $1$，所有子串为：$A = \{aab,aba,baa\}, B = \{aba, bab, aba\}$。可以看出有一对 $aba$ 是相同的，另外要把 $aab$ 改成 $aba$（花费 $2$），$baa$ 改成 $bab$（花费 $1$），总花费为 $3$。

#### 数据规模与约定

对于所有数据，$1\le k\le n\le 1.5\times 10^5$。

- 对于 $10\%$ 的数据，$n \le 11$；
- 对于另外 $20\%$ 的数据，$n \le 200$；
- 对于另外 $20\%$ 的数据，$n \le 2000$；
- 对于另外 $10\%$ 的数据，字符串的每一位在小写字母中均匀随机；
- 对于余下 $40\%$ 的数据，无特殊限制。

## 样例 #1

### 输入

```
5 3
aabaa
ababa```

### 输出

```
3```

# AI分析结果



## 唯一算法分类
后缀自动机（SAM）/后缀数组（SA）+贪心匹配

---

## 综合分析与结论
### 核心思路与难点
1. **问题转化**：总代价最小等价于最大化所有匹配对的LCP之和。将A、B的子串视为两类节点，建立最大权匹配模型。
2. **数据结构选择**：利用后缀数组（SA）或后缀自动机（SAM）高效处理子串的LCP计算与匹配。
3. **贪心策略**：优先匹配LCP最大的子串对，通过并查集（SA方案）或树形DP（SAM方案）统计贡献。
4. **难点对比**：
   - SA方案需处理合并顺序与集合计数，代码实现细节多；
   - SAM方案利用parent树性质，通过反转字符串将前缀转化为后缀，在树形结构上直接统计贡献。

### 可视化设计
- **动画方案**：
  1. **后缀数组流程**：用颜色区分A/B子串，动态绘制height数组，高亮当前处理的LCP值。并查集合并时显示集合计数变化。
  2. **SAM树形结构**：以树状图展示parent树，不同颜色标记A/B子串的节点，动态显示树形DP过程（节点颜色深浅表示未匹配数量）。
- **复古像素风格**：
  - 使用8-bit音效：合并时播放“哔”声，匹配成功时播放“叮”声。
  - Canvas绘制网格化SA数组或SAM节点，步进执行时显示当前操作区域闪烁。

---

## 题解清单（≥4星）
1. **panyf（SA+并查集）** ⭐⭐⭐⭐⭐  
   - 亮点：代码简洁高效，直接按height降序合并，利用并查集维护未匹配计数。
2. **pomelo_nene（SAM贪心）** ⭐⭐⭐⭐  
   - 亮点：通过反转字符串转化LCP为公共后缀，parent树上自底向上贪心匹配。
3. **zyp123456（广义SAM）** ⭐⭐⭐⭐  
   - 亮点：在线构建SAM，直接统计每个节点的A/B数量，合并贡献时逻辑清晰。

---

## 核心代码实现
### panyf题解（SA+并查集）
```cpp
int gf(int x){return f[x]==x?x:f[x]=gf(f[x]);}
void mg(int x,int y,int w){
    p[y]+=p[x], q[y]+=q[x], f[x]=y;
    ans += w*1ll*min(p[y], q[y]); // 核心贡献计算
    if(p[y] > q[y]) p[y]-=q[y], q[y]=0;
    else q[y]-=p[y], p[y]=0;
}
int main(){
    // 构建SA和height数组...
    sort(id+2, id+n, [](int x,int y){return h[x]>h[y];}); // 按height降序
    for(i=2;i<n;++i) mg(gf(sa[id[i]]), gf(sa[id[i]-1]), max(0,o-h[id[i]]));
    cout<<ans;
}
```

### pomelo_nene题解（SAM贪心）
```cpp
void calcAnswer(){
    for(int i=cnt; i; --i){
        int minn = min(epd[i][0], epd[i][1]); // 取当前节点A/B最小值
        ans += minn * min(len[i],k); // 累加贡献
        epd[fa[i]][0] += epd[i][0]-minn; // 剩余未匹配上传父节点
        epd[fa[i]][1] += epd[i][1]-minn;
    }
}
```

---

## 最优技巧提炼
1. **反转字符串技巧**：将前缀匹配转化为后缀匹配，利用SAM的天然后缀处理能力。
2. **树形贪心匹配**：在parent树上自底向上合并，优先深度大的节点匹配（LCP更大）。
3. **并查集批量处理**：按LCP值从大到小合并集合，确保每次处理当前最大的可行匹配。

---

## 同类题目推荐
1. P2178 [NOI2015] 品酒大会（SA+并查集）
2. P4248 [AHOI2013] 差异（SA/后缀树）
3. P6640 [BJOI2020] 封印（SAM应用）

---

## 个人心得摘录
> "在线构建SAM时要注意las指针的复位，否则会错误继承前一个串的状态" —— zyp123456题解调试经验

---

## 可视化算法演示（SAM方案）
1. **初始化**：显示反转后的字符串构建SAM过程，节点随插入动态增长。
2. **贡献统计**：高亮当前处理的parent树节点，显示其A/B数量：
   ```javascript
   function drawNode(node) {
       ctx.fillStyle = node.A > node.B ? "#FF6666" : "#66B2FF"; 
       drawCircle(node.pos);
       drawText(node.A + "/" + node.B);
   }
   ```
3. **树形DP动画**：自底向上扫描，匹配时播放粒子效果，未匹配数量以数字渐变动画更新。

---

## 复古游戏化设计
- **音效设计**：
  - 插入SAM节点：8-bit "滴"声（Web Audio生成方波）
  - 成功匹配：FC风格胜利音效
- **积分系统**：每成功匹配一对得10分，连续深度匹配触发COMBO加成
- **自动演示模式**：
  ```javascript
  function autoPlay() {
      let node = deepestUnprocessedNode();
      if(node) processNode(node);
      else setTimeout(autoPlay, 1000); // 完成时暂停
  }
  ```

---
处理用时：79.99秒
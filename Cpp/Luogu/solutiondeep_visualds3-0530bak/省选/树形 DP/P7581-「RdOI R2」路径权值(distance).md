# 题目信息

# 「RdOI R2」路径权值(distance)

## 题目背景

此题读入量较大，请选择合适的读入方式。

## 题目描述

给你一棵 $n$ 个点的边带权有根树，根节点为编号为 $1$ 的节点。定义 $u$ 的 $k-son$ 为 $u$ 子树中深度（指经过边数）比 $u$ **恰好**大 $k$ 的所有点。  
$m$ 次询问求一个点 $u$ 的 $k-son$ 两两之间距离的和。你需要输出这个值 $\bmod\left(10^9+7\right)$ 的结果。

## 说明/提示

**样例 $1$ 解释**

以下是样例中的树。  
![](https://cdn.luogu.com.cn/upload/image_hosting/lz4oy8ao.png)

---

**样例 $2$ 解释**

以下是样例中的树。  
![](https://cdn.luogu.com.cn/upload/image_hosting/hb45pofr.png)

---

**数据范围**

对于 $20\%$ 的数据，$n,m,k\le100$。  
对于 $50\%$ 的数据，$n,m,k\le10^3$。  
对于 $80\%$ 的数据，$n,m,k\le10^5$。  
对于 $100\%$ 的数据，$1\le n,m,k\le10^6,1\le k\le n,1\le w\le10^5,1\le u,v\le n$，保证给出的是一棵树。  

## 样例 #1

### 输入

```
5 3 
1 2 2
1 3 1
2 4 1
2 5 2
1 1
1 2
2 1```

### 输出

```
3
3
3```

## 样例 #2

### 输入

```
10 5
1 2 1
1 3 3
2 4 2
2 5 2
3 6 3
3 7 1
5 8 2
6 9 1
6 10 3
1 2
3 2
6 1
1 3
2 2```

### 输出

```
40
4
4
30
0```

# AI分析结果



**唯一算法分类**  
长链剖分优化动态规划

---

### **题解思路、算法要点与解决难点**  
**核心思路**：预处理每个节点子树中各深度的信息，利用长链剖分优化空间，合并子树信息时通过指针偏移继承重儿子数据，暴力合并轻儿子。  
**关键变量**：  
- `f[u][k]`：u子树中深度k的节点两两距离和  
- `g[u][k]`：u子树中深度k的节点到u的距离和  
- `h[u][k]`：u子树中深度k的节点数量  

**解决难点**：  
1. **空间优化**：通过长链剖分，每个节点继承重儿子的数组指针，实现O(n)空间  
2. **合并公式**：轻儿子合并时，按公式计算跨子树贡献：  
   `f[u][k] += f[v][k-1] + g[u][k] * h[v][k-1] + h[u][k] * (g[v][k-1] + w*h[v][k-1])`  
3. **离线查询**：处理完节点子树后，立即响应挂在该节点上的所有查询  

---

### **题解评分 (≥4星)**  
1. **abruce (5星)**  
   - 完整实现长链剖分，指针偏移技巧  
   - 关键公式推导清晰，空间优化到位  
   - 调试细节：`dis[u]`预处理所有节点到根距离  

2. **RedreamMer (4星)**  
   - 引入懒标记处理重儿子继承  
   - 代码实现带详细注释  
   - 缺点：变量命名较晦涩  

3. **Tomle (4星)**  
   - 结构清晰，包含完整DP状态定义  
   - 实现指针池分配技巧  
   - 缺点：缺少公式推导注释  

---

### **最优思路或技巧提炼**  
**核心技巧**：  
1. **长链指针继承**：重儿子直接复用父节点数组，轻儿子暴力合并  
2. **三维状态压缩**：将`f/g/h`三组数据通过指针连续分配  
3. **离线响应机制**：DFS完成后立即处理该节点所有查询  

**数学推导**：  
两节点x,y的距离公式：  
```
dis(x,y) = (dis[x] - dis[lca]) + (dis[y] - dis[lca])  
          = (dis[x] + dis[y]) - 2*dis[lca]
```  
当x,y同属u子树时，合并贡献可拆分为各子树内部贡献和跨子树贡献。

---

### **同类型题与算法套路**  
**常见套路**：  
- 子树按深度统计问题 → 长链剖分  
- 离线查询优化 → 后序DFS时处理  
- 树形DP空间压缩 → 指针偏移  

**相似题目**：  
1. [CF1009F Dominant Indices](https://www.luogu.com.cn/problem/CF1009F)  
2. [P5904 [POI2014]HOT-Hotels](https://www.luogu.com.cn/problem/P5904)  
3. [P4292 [WC2010]重建计划](https://www.luogu.com.cn/problem/P4292)  

---

### **推荐相似题目**  
1. **P4211 [LNOI2014]LCA** - 离线处理树链查询  
2. **P3979 遥远的国度** - 树链剖分与子树查询  
3. **CF208E Blood Cousins** - 统计k级祖先子树  

---

### **代码核心逻辑片段**  
```cpp
// 长链剖分预处理
void dfs(int u, int fa) {
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        dis[v] = dis[u] + e[i].v;
        dfs(v, u);
        if (maxd[v] > maxd[son[u]]) 
            son[u] = v, len[u] = len[v] + 1;
    }
}

// DP合并轻儿子
void dp(int u) {
    if (son[u]) { // 继承重儿子
        f[son[u]] = f[u] + 1;
        g[son[u]] = g[u] + 1;
        dp(son[u]);
    }
    g[u][0] = dis[u], h[u][0] = 1;
    for (int v : light_son[u]) { // 轻儿子暴力合并
        dp(v);
        for (int k = 1; k <= len[v]; k++) {
            f[u][k] += f[v][k-1];
            f[u][k] += (g[u][k] - dis[u]*h[u][k]) * h[v][k-1];
            f[u][k] += h[u][k] * (g[v][k-1] - dis[u]*h[v][k-1]);
            g[u][k] += g[v][k-1];
            h[u][k] += h[v][k-1];
        }
    }
    // 响应u节点的所有k询问
    for (auto [k, id] : queries[u]) 
        if (k <= len[u]) ans[id] = f[u][k];
}
```

---

### **可视化与算法演示**  
**动画设计**：  
1. **树结构展示**：Canvas绘制树形结构，长链用红色高亮  
2. **指针偏移演示**：重儿子节点继承父节点数组时，显示指针+1的偏移动画  
3. **轻合并过程**：  
   - 轻子树展开为独立面板，显示其`f/g/h`数组  
   - 合并时数值飞入父节点对应位置，伴随粒子特效  
4. **状态面板**：实时显示当前节点的`f/g/h`值  

**复古像素化**：  
- **调色板**：16色模式，长链节点用亮绿色，轻子树用橙色  
- **音效**：  
  - 指针继承时播放8-bit "滴"声  
  - 合并完成时播放短促胜利音效  
- **自动演示**：按DFS顺序自动遍历，空格键暂停/继续  

---

### **个人心得摘录**  
> "调试时发现轻儿子合并顺序影响结果，必须保证每个轻子树完全处理后再合并。通过预排序子树确保稳定性。" —— abruce  
> "长链剖分的指针管理极易出错，采用`tmp`全局指针池分配内存后，代码可读性大幅提升。" —— Tomle  

---

**可视化实现片段（JS）**  
```javascript
// 绘制长链继承过程
function drawChain(u, ctx) {
    let node = tree[u];
    ctx.fillStyle = '#FF0000'; // 红色标记长链
    ctx.fillRect(node.x, node.y, 20, 20);
    if (node.heavyChild) {
        let child = tree[node.heavyChild];
        ctx.beginPath();
        ctx.moveTo(node.x+10, node.y+20);
        ctx.lineTo(child.x+10, child.y);
        ctx.strokeStyle = '#FF0000';
        ctx.stroke();
    }
}
// 合并动画
function animateMerge(parent, child) {
    let particles = [];
    // 生成粒子从child飞向parent的f/g/h数组位置
    // ...粒子系统实现...
}
```

---
处理用时：123.00秒
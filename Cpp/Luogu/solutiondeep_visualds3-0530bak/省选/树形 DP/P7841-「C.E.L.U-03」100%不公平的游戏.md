# 题目信息

# 「C.E.L.U-03」100%不公平的游戏

## 题目背景

今天 ice 出去玩了。原准备与 Alice 玩游戏的 Bob 只能和 Al 玩一场博弈游戏。

## 题目描述

这个游戏是在树上进行的。Bob 先手。Bob 和 Al 轮流进行以下操作，首先无法操作者判负。

- 在树上标记一条未被标记过的边。满足在每一次操作之后，存在一条简单路径遍历所有标记过的边。注意：这条简单路径**可以经过未标记过的边**。

如果给定的树对于 Bob 有必胜方案，输出 `Play now`，否则输出 `Restart`。

## 说明/提示

**样例数据也可见附件** $\textbf{\textit{game.in}/\textit{game.out}}$。

### 样例解释 1

**第一组数据：**

先手选择边 $(2,5)$ 必胜：  
若后手选择 $(1,2)$，先手选择 $(5,6)$ 可以获胜。  
若后手选择 $(2,3)$，先手选择 $(5,9)$ 可以获胜。  
若后手选择 $(3,4)$，先手选择 $(5,9)$ 可以获胜。  
若后手选择 $(5,6)$，先手选择 $(1,2)$ 可以获胜。  
若后手选择 $(5,9)$，先手选择 $(3,4)$ 可以获胜。  
若后手选择 $(7,9)$，先手选择 $(2,3)$ 可以获胜。  
若后手选择 $(8,9)$，先手选择 $(3,4)$ 可以获胜。  
综上，无论后手选那一条边，都不会获得胜利。  

**第二组数据：**

先手不存在必胜策略：  
若先手选择 $(1,2)$，后手选择 $(2,3)$ 获胜。  
若先手选择 $(2,3)$，后手选择 $(1,2)$ 获胜。


### 样例解释 2

各组数据详见下图，其中前两组数据与样例一相同。

![](https://cdn.luogu.com.cn/upload/image_hosting/imht95gt.png)

---

### 数据范围

$2\leq n\leq5\times10^5$

$1\leq T\leq10^4$

$\sum n\leq1.5\times10^6$

数据保证给定的图是一棵树。

### 子任务  
1. （8分）$n\leq6$。
2. （18分）$n\leq12,T\leq10$。
3. （6分） $n\leq28,T\leq10$。
4. （8分）$n\leq200,T\leq10$。
5. （30分）$n\leq2000,T\leq10$。
6. （6分）最多存在两个节点度数大于 $2$。
7. （12分）树的形态是一棵完全二叉树。
8. （12分）无特殊性质。

## 样例 #1

### 输入

```
2
9
9 5
2 1
9 8
3 2
5 6
7 9
4 3
5 2
3
1 2
2 3```

### 输出

```
Play now
Restart```

## 样例 #2

### 输入

```
附加两组样例详见
https://www.luogu.com.cn/paste/b6mh7ido```

### 输出

```
附加两组样例详见
https://www.luogu.com.cn/paste/b6mh7ido```

# AI分析结果



---

**算法分类**  
博弈论（SG函数） + 树形DP（换根DP）

---

### **题解思路与核心难点**

#### **核心思路**
1. **博弈模型转化**：每次标记边后，剩余合法操作转化为若干子游戏。  
2. **SG函数定义**：每个子树的SG值由其后继状态（子游戏分割后的异或值）的mex决定。  
3. **链的SG特性**：链长为奇数时SG=1，偶数时SG=0，源于操作后的奇偶性交替。  
4. **换根DP优化**：通过两次DFS预处理前缀/后缀状态，实现O(1)快速换根计算。

#### **关键难点**
- **SG值推导**：需数学归纳法证明链的SG特性，并推广到树结构。  
- **状态维护**：用bitset或动态最大值维护可能的后继SG值集合。  
- **换根实现**：维护父子节点的状态合并关系，避免重复计算。

---

### **题解评分 (≥4星)**

1. **VinstaG173的题解**（5星）  
   - **亮点**：严谨的SG定理推导，用bitset高效计算mex，换根前缀后缀分离实现。  
   - **引用心得**：“不要像我一样只用脑子想，最好用下草稿纸”——强调推导过程的重要性。

2. **幻影星坚强的题解**（4星）  
   - **亮点**：发现SG值与子树最大值/次大值的递推关系，简化状态转移。  
   - **优化**：省去集合操作，直接通过动态统计极值计算SG值。

---

### **最优思路提炼**

1. **SG递推优化**：  
   - 若子树SG最大值与次大值满足 `max = se+1`，则当前节点SG为 `max+1`；否则取 `max^1`。  
   - 通过动态维护最大值、次大值及其出现次数，实现O(1)复杂度转移。

2. **换根技巧**：  
   - 预处理每个节点的子节点前后缀状态集合，换根时直接合并前缀后缀，避免重复遍历子树。

---

### **同类型题推荐**

1. [P3185 HNOI2007]分裂游戏（SG函数应用）  
2. [P2148 SDOI2009]E&D（组合博弈与SG分析）  
3. [P2964 USACO09NOV]Coin Game（树形博弈与动态规划）

---

### **可视化设计**

#### **动画方案**
1. **树结构绘制**：  
   - 用Canvas绘制树形结构，节点为圆形，边为线条。  
   - **颜色标记**：当前处理节点为红色，已计算SG值的节点为绿色，当前边为蓝色。

2. **SG值计算演示**：  
   - 深度优先遍历时，高亮当前子树，显示其最大值/次大值统计过程。  
   - 换根时，动态显示父子节点状态集合的合并过程。

3. **音效交互**：  
   - **标记边**：8-bit风格“滴”声。  
   - **必胜判定**：成功时播放上升音阶，失败时播放下降音阶。  
   - **自动模式**：背景音乐为循环8-bit旋律，速度可调节。

#### **复古像素风格**  
- **调色板**：16色，节点用黄/蓝像素块，边用灰色像素线。  
- **网格布局**：树节点按层序排列在网格中，换根时滑动切换。

---

### **代码核心逻辑**

#### **VinstaG173的SG计算（片段）**
```cpp
void dfs1(int u, int f) {
    // 预处理前缀后缀bitset
    for (auto v : sons) {
        dfs1(v, u);
        lS[v][0] = tlS0; tlS0 |= S[v][1];
        // ...类似处理其他状态
    }
    // 计算当前节点SG值
    sg[u] = (~tlS0)._Find_first();
}
```

#### **幻影星坚强的极值维护（片段）**
```cpp
void dfs1(int o, int from) {
    for (auto v : sons) {
        if (sg[v] > maxs[o]) {
            th[o] = se[o]; se[o] = maxs[o]; maxs[o] = sg[v];
        } // 更新最大值/次大值
    }
    // 根据极值计算SG
    if (maxs == se^1 && se_tot >=1) sg[o] = maxs+1;
    else sg[o] = maxs_tot ? maxs^1 : 0;
}
```

---

### **总结**

本题通过将树形博弈转化为SG函数计算，结合换根DP高效处理所有初始边可能性。两种题解分别以bitset集合操作和极值递推实现核心逻辑，均达到线性复杂度。可视化设计可突出SG值的动态计算与换根状态切换，帮助理解博弈树的分割过程。

---
处理用时：101.60秒
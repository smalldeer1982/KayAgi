# 题目信息

# 「DAOI R1」Fireworks

## 题目背景

> 俯首，满城灯火交辉。
> 
> 回眸，漫天流星逆飞。

## 题目描述

人们以前通常会放烟花，而每个烟花都有它本身的美观度。

$ \texttt{Iratis} $ 想要在户外放烟花，但是有烟花之间有一些关系：

- 关系一：对于烟花 $ x $ ，有一个对应烟花 $ a_x $ ，若烟花 $ x $ 与烟花 $ a_x $ 一起燃放，就会使烟花 $ x $ 的美观度减少 $ b_x $ 。

- 关系二：有一些烟花是一个系列，必须同时燃放，其中有一个是主烟花，**每个烟花只会属于一个系列**。

特别地，若有一系列 $ S_1 $ （主烟花为 $ p_1 $ ） 。 $ p_1 $ 关系一所对应的烟花为系列 $ S_2 $ 中的烟花。而 $ S_1 $ 系列中的其他烟花与非 $ S_1,S_2 $ 系列中的烟花形成关系一。**那么对于这条关系一，它不会降低美观度。**

$ \texttt{Iratis} $ 家里有 $ n $ 个烟花，他希望选择其中的一些烟花燃放，使得这些**烟花的美观度总和**最大。

## 说明/提示

### 样例解释
#### 样例1解释

烟花 $ 1,2,3 $ 一起燃放，最大美观度为 $ 2+2+2-1-1-1=3 $ 。

#### 样例2解释

烟花 $ 1,3,4 $ 一起燃放。

由于 $ 1,3 $ 为同一系列且 $ 1 $ 为主烟花，所以 $ 3 $ 烟花的关系一不会生效。

故总的美观度为 $ 3 \times 3-2=7 $ 。

### 数据规模

**本题采用捆绑测试**

| Subtask | $ m $  | 分值 |
| :----------: | :----------: | :----------: |
| $ 0 $ | $ =0 $ | $ 30 $ |
| $ 1 $ | 无特殊限制 | $ 70 $ |

对于 $ 100\% $ 的数据，满足 $ 0 \leq m \leq n \leq 5 \times 10^5,0 \leq b_i \leq v_i \leq 10^{12},1 \leq a_i \leq n,a_i \neq i $ 。 

## 样例 #1

### 输入

```
3 0
2 2 1
2 3 1
2 1 1
```

### 输出

```
3```

## 样例 #2

### 输入

```
4 1
3 2 1
3 1 3
3 4 2
3 3 2
1 2 1 3
```

### 输出

```
7```

# AI分析结果



---

### **唯一算法分类**  
基环树动态规划 & 并查集

---

### **综合分析与结论**  
#### **核心思路**  
1. **系列合并**：将必须同时燃放的烟花系列用并查集合并为一个大节点，主烟花作为代表。  
2. **权值计算**：每个合并节点的总美观度为所有子烟花初始值之和，减去系列内部冲突的 $b_x$ 值。  
3. **基环树构建**：将合并后的节点按关系一建立边权，形成基环树或树结构的森林。  
4. **动态规划**：  
   - **树形 DP**：对每个树的根节点，计算选/不选的最大值。  
   - **环上 DP**：拆环为链，分起点选/不选两种情况，处理环的依赖关系。  

#### **解决难点**  
- **边权合并**：系列间的关系一需累加边权，系列内部的冲突需直接扣除总权值。  
- **环处理**：通过拓扑排序找环，拆环为链后分别强制起点状态进行 DP，避免循环依赖。  

#### **可视化设计**  
- **像素动画**：用 8 位风格展示节点合并过程（并查集操作），基环树的环检测（红色高亮环边）。  
- **动态规划演示**：  
  - 树形 DP：绿色标记选中节点，红色标记不选，显示子节点贡献。  
  - 环上 DP：拆环为链时，黄色标记起点，逐步更新链上节点的状态值。  
- **音效触发**：合并节点时播放“合成音效”，环检测成功时播放“成功音效”。  

---

### **题解清单 (≥4星)**  
1. **Yanami_Anna (4.5⭐)**  
   - **亮点**：详细处理基环树合并与环上 DP，覆盖所有特殊情况。  
   - **代码优化**：通过并查集和拓扑排序高效处理大规模数据。  
   - **心得**：强调避免 STL 的性能问题，提供 Hack 数据验证代码。  

2. **leihonglongyin (4.0⭐)**  
   - **亮点**：简洁的两次 DFS 完成树和环的 DP，代码可读性强。  
   - **关键点**：通过反边标记入度，分离树根与环根。  

---

### **最优思路提炼**  
1. **并查集合并系列**：将系列烟花缩点，主烟花代表整个系列。  
2. **基环树拆分**：通过拓扑排序分离环与树，分别处理。  
3. **环上强制状态 DP**：拆环为链，分起点选/不选两种状态，避免循环依赖。  
4. **权值预处理**：系列内部冲突直接扣除，系列间冲突累加边权。  

---

### **同类型题推荐**  
1. **P2607 [ZJOI2008] 骑士**：基环树森林上的最大权独立集。  
2. **P4381 [IOI2008] Island**：基环树的最长路径问题。  
3. **CF131D Subway**：基环树检测与环处理。  

---

### **个人心得摘录**  
- **Yanami_Anna**：  
  > “开 O2 才能过，任何 STL 终将绳之以法。”  
  → 避免 STL 容器在高频操作中的性能损耗，改用数组预处理。  

- **leihonglongyin**：  
  > “记得开 long long！”  
  → 数据规模大时，所有变量需用 `long long` 防止溢出。  

---

### **可视化算法演示**  
```javascript  
// 伪代码：基环树 DP 动画演示（简化）  
class PixelAnimation {  
  constructor(nodes) {  
    this.grid = new CanvasGrid(16, 16); // 8-bit 网格  
    this.nodes = nodes.map(node => new PixelNode(node));  
    this.playSound('bgm');  
  }  

  // 合并系列为节点  
  mergeSeries() {  
    this.nodes.forEach(node => {  
      if (node.isMaster) {  
        node.color = '#FF0000'; // 主节点红色  
        this.playSound('merge');  
      }  
    });  
  }  

  // 环检测与高亮  
  highlightCycle() {  
    this.findCycle().edges.forEach(edge => {  
      edge.color = '#FFFF00'; // 环边黄色  
      this.playSound('cycle');  
    });  
  }  
}  
```  

---

### **代码片段 (核心逻辑)**  
```cpp  
// 基环树 DP 核心代码（leihonglongyin）  
void dfs(int u) {  
    f[u][1] = v[u];  
    for (int i = a[u]; i; i = g[i].next) {  
        int j = g[i].to;  
        dfs(j);  
        f[u][0] += max(f[j][0], f[j][1]);  
        f[u][1] += max(f[j][0], f[j][1] - g[i].v);  
    }  
}  

// 环上 DP  
void dfs1(int u, int k) {  
    f[u][1] = v[u];  
    for (int i = a[u]; i; i = g[i].next) {  
        int j = g[i].to;  
        if (j == di[k]) {  
            // 处理环终点  
            f[u][1] += max(f[j][0], f[j][1] - g[i].v - zhi[k]);  
        } else {  
            // 正常转移  
            f[u][1] += max(f[j][0], f[j][1] - g[i].v);  
        }  
    }  
}  
```

---
处理用时：90.15秒
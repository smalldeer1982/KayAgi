# 题目信息

# [省选联考 2022] 填树

## 题目背景

原题时限为 2s。

## 题目描述

有一棵 $n$ 个节点的无根树，刚开始树上每个节点的权值均为 $0$。KK 想对这棵树进行一些修改，他会任选一个节点作为初始的当前节点，然后重复以下动作：

1. 将当前节点 $i$ 的权值修改为一个**正整数** $x$，需满足 $l_i \leq x \leq r_i$。其中 $l_i, r_i$ 是输入中给出的两个正整数。
2. 结束修改过程，或移动到一个与当前节点相邻的权值为 $0$ 的节点（如果不存在这样的节点，则必须结束修改过程）。

现在 KK 有两个问题：

1. 在修改结束后，可以得到多少棵不同的树，满足树上**非零权值**的最大值和最小值的差小于等于 $K$？其中 $K$ 是输入中给出的一个正整数。

2. 这些满足条件的树的权值之和为多少？（树的权值定义为这棵树上所有节点的权值之和）

你需要输出这两个问题的答案模 $10^9 + 7$。我们认为两棵树不同当且仅当至少存在一个节点的权值不同。

温馨提示：

1. KK 至少会修改一个节点（初始节点）。
2. 实质上 KK 会修改树上的任意一条路径，最后需要满足这条路径上的点的权值最大值和最小值之差小于等于 $K$。

## 说明/提示

**【样例解释 #1】**

| | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | $9$ | $10$ | $11$ | $12$ | $13$ | $14$ |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 节点 $1$ | $2$ | $3$ | $2$ | $3$ | $3$ | $3$ | $3$ | $3$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |
| 节点 $2$ | $0$ | $0$ | $3$ | $3$ | $4$ | $0$ | $4$ | $3$ | $3$ | $4$ | $5$ | $0$ | $0$ | $0$ |
| 节点 $3$ | $0$ | $0$ | $0$ | $0$ | $0$ | $4$ | $4$ | $4$ | $0$ | $0$ | $0$ | $4$ | $5$ | $6$ |

表格中列出了全部 $14$ 棵满足条件的树，将这些树的权值加起来为 $78$。

**【数据范围】**

对于 $100\%$ 的数据，$1 \leq n \leq 200$，$1 \leq l_i \leq r_i \leq {10}^9$，$1 \leq K \leq {10}^9$。

| 测试点 | $n \leq $ | $r_i, K \leq$ | 其他限制 |
|:-:|:-:|:-:|:-:|
| $1$ | $5$ | $10$ | 无 |
| $2$ | $30$ | $10^9$ | 无 |
| $3$ | $30$ | $10^9$ | 无 |
| $4$ | $30$ | $500$ | 无 |
| $5$ | $200$ | $200000$ | 无 |
| $6$ | $200$ | $200000$ | 无 |
| $7$ | $200$ | $10^9$ | A |
| $8$ | $200$ | $10^9$ | A |
| $9$ | $200$ | $10^9$ | 无 |
| $10$ | $200$ | $10^9$ | 无 |

特殊限制 A：所有点构成一条链, 编号为 $i$ 的点和编号为 $i + 1$ 的点之间有连边

**【评分方式】**

本题共 $10$ 个测试点，每个测试点 $10$ 分。其中回答正确第一问可得 $7$ 分，回答正确第二问可得 $3$ 分。

## 样例 #1

### 输入

```
3 1
2 3
3 5
4 6
1 2
1 3
```

### 输出

```
14
78
```

## 样例 #2

### 输入

```
见附件中的 tree/tree2.in```

### 输出

```
见附件中的 tree/tree2.ans```

## 样例 #3

### 输入

```
见附件中的 tree/tree3.in```

### 输出

```
见附件中的 tree/tree3.ans```

# AI分析结果



## 算法分类
树形动态规划（树形DP） + 拉格朗日插值

---

## 核心思路与难点分析

### 核心算法流程
1. **分段处理**：将值域划分为多个区间，每个区间内节点的权值范围变化是分段线性的。
2. **树形DP计算点值**：对每个区间，通过树形DP计算前n+2个点的方案数和权值和。
3. **拉格朗日插值**：利用插值快速求出整个区间的前缀和，避免逐点计算。
4. **容斥处理**：通过计算K和K-1两次结果之差，排除非最小值的干扰。

### 关键难点与解决
1. **大值域处理**：直接枚举值域不可行，通过断点划分将复杂度降为O(n)。
2. **多项式拟合**：发现方案数和权值和在区间内是多项式，利用插值优化求和。
3. **树形DP优化**：设计状态统计所有路径贡献，避免重复计算。

---

## 题解评分（≥4星）

### 1. WeLikeStudying（5星）
- **亮点**：完整推导多项式次数，给出容斥原理的清晰解释，代码实现简洁。
- **核心代码**：
```cpp
void dfs(int u, int fa, int L, int R){
    int left = max(L, l[u]), right = min(R, r[u]);
    int cnt = (left <= right) ? (right - left + 1) : 0;
    // DP转移逻辑...
}
```

### 2. Renshey（4.5星）
- **亮点**：巧妙拆分min/max表达式，使用双前缀和优化插值过程。
- **关键步骤**：预处理逆元加速插值，分段处理极值边界。

### 3. 小木虫（4星）
- **亮点**：详细推导DP状态方程，给出多项式次数证明，适合初学者理解。

---

## 最优思路提炼

### 关键步骤
1. **断点生成**：收集所有可能的区间变化点（l_i, r_i, l_i-K, r_i-K）。
2. **区间分段**：将值域划分为O(n)个连续区间。
3. **多项式DP**：每个区间内，方案数为n次多项式，权值和为n+1次多项式。
4. **拉格朗日插值**：用n+2个点值拟合区间和，时间复杂度O(n^3)。

### 实现技巧
```python
# 伪代码示例：拉格朗日插值核心逻辑
def lagrange(x_points, y_points, x):
    result = 0
    n = len(x_points)
    for i in range(n):
        term = y_points[i]
        for j in range(n):
            if i != j:
                term *= (x - x_points[j]) / (x_points[i] - x_points[j])
        result += term
    return result
```

---

## 相似题目推荐
1. [CF622F - The Sum of the k-th Powers](https://codeforces.com/problemset/problem/622/F)  
   **相似点**：自然数幂和计算，拉格朗日插值应用

2. [LOJ 6029 - 市场](https://loj.ac/p/6029)  
   **相似点**：分段处理区间操作，维护多项式性质

3. [洛谷P4512 - 多项式除法](https://www.luogu.com.cn/problem/P4512)  
   **相似点**：多项式运算与插值技术的结合

---

## 可视化设计（复古像素风格）

### 动画演示
1. **断点扫描**：用绿色像素块标记当前扫描的l_i/r_i值，红色方块显示当前处理的区间。
2. **树形DP过程**：以8位风格显示树结构，节点闪烁表示正在处理，路径用黄色高亮。
3. **插值演示**：显示多项式曲线拟合过程，每个采样点用像素星星标记，插值结果用渐变色带显示。

### 音效设计
- **断点生成**：8-bit "哔"声
- **DP完成**：短促胜利音效
- **插值计算**：数据流动音效

### 交互功能
- **速度调节**：复古滑动条控制动画速度
- **模式切换**：A/B键切换自动演示/手动步进
- **路径追踪**：方向键高亮显示当前计算的树路径

---

## 核心代码实现
```cpp
// 拉格朗日插值关键代码
int lagrange(int x[], int y[], int k, int X) {
    int res = 0;
    for (int i = 0; i <= k; ++i) {
        int num = y[i], den = 1;
        for (int j = 0; j <= k; ++j) {
            if (i != j) {
                num = 1LL * num * (X - x[j]) % MOD;
                den = 1LL * den * (x[i] - x[j]) % MOD;
            }
        }
        res = (res + 1LL * num * qpow(den, MOD-2)) % MOD;
    }
    return (res + MOD) % MOD;
}

// 树形DP核心转移
void dfs(int u, int fa) {
    int a = max(L, l[u]), b = min(R, r[u]);
    int cnt = max(0, b - a + 1);
    int sum = cnt ? (a + b) * cnt / 2 % MOD : 0;
    
    f[u][0] = f[u][1] = cnt;
    g[u][0] = g[u][1] = sum;
    
    for (int v : G[u]) {
        if (v == fa) continue;
        dfs(v, u);
        // 合并子树贡献...
    }
}
```

---

## 总结与心得
通过分治值域和多项式拟合，将看似O(nK)的问题优化到O(n^3)。调试时需特别注意：
1. 断点排序去重的正确性
2. 多项式次数与采样点数的匹配
3. 模运算中负数处理

关键突破：发现区间内权值函数的多项式性质，将树形DP与数值分析技术结合，大幅降低时间复杂度。

---
处理用时：90.34秒
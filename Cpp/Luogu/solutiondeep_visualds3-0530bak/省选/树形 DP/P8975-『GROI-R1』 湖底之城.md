# 题目信息

# 『GROI-R1』 湖底之城

## 题目背景

那年你我仍是无瑕的少年

在夜晚安逸的后院无所顾忌地笑谈人生

——怀念这样毫无猜忌的时光

## 题目描述

悦，玲和荧三个人在湖底之城闲游。湖底之城的道路错综复杂，形成了一棵有 $n$ 个节点的树。

她们三人的手上都有一个计数器，初始都为 $0$。她们每走到一个点的时候，**悦和荧**手上的计数器会自动加上刚刚经过的**这条边的边权**，同时**玲**的计数器会恰好**增加 $1$**。同时，她们整个过程中**没有经过某个点超过一次**。

由于她们的计数器不能存储很大的值，所以，当**玲**的计数器上的值是「湖之数」$p$ 的**倍数**时，**悦可以**将她的计数器上的值减去**荧**的计数器上的值，接下来，**玲和荧**的计数器都会立刻**归零**。

玘现在不知道她们闲游的起点和终点，所以天生计算能力很好的玘对于每一对起点和终点，计算出了悦手上计数器在终点时可能出现的最小值。玘把这个值记作 $f(u,v)$，意思是她们从点 $u$ 走到了点 $v$。可是，玘认为，没有红色彼岸花的寒，一定是算不出来这些答案的。所以，他让寒做一道更简单的题。玘给寒一个长度为 $m$ 的序列 $s$，让寒对于每一个点为 $u$ 时计算 $\min\limits_{i=1}^m\{f(s_i,u)\}$。

**形式化题面**

给定一个 $n$ 个点的树 $(V,E)$ 和一个正整数 $p$，每一条边有一个整数边权 $w_i$。

我们定义 $f(s,v)$ 表示为对 $u,a,b,c$ 进行若干次**拓展**后可以得到的当 $u=v$ 时的 $a$ 的最小值，其中最开始 $u\gets s$ 同时 $a,b,c\gets0$。

**拓展**的定义为依次进行如下操作：

- 选择任意一条边 $(u',v,w)\in E$ 满足 $u=u'$，令 $u\gets v,a\gets a+w,b\gets b+1,c\gets c+w$；

- 如果 $p\mid b$，你****可以****令 $a\gets a-c,b\gets 0,c\gets0$。

特别地，对于每一次**拓展**，你**不能**取一个之前取过的点。

给定序列 $\{s_m\}$，对于每个点 $u$ 求 $\min\limits_{i=1}^m\{f(s_i,u)\}$。



## 说明/提示

**样例解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/xo9b4yyn.png)

 - 如果她们从 $1$ 号点出发，首先有 $f(1,1)=0$。走到点 $2,3,4$ 时悦的计数器上的值分别为 $-2,1,2$，所以 $f(1,2)=-2,f(1,3)=1,f(1,4)=2$。她们走到点 $5,6$ 时，悦的计数器上的值分别为 $-5,8$。由于这时玲的计数器上的值等于 $2$，是 $p$ 的倍数，所以悦**可以**选择让她手上的计数器的值减去荧的计数器的值，不难得出 $f(1,5)=-5,f(1,6)=0$。
 
- 如果她们从 $5$ 号点出发，同理可得 $f(5,5)=0,f(5,2)=-3,f(5,6)=0,f(5,1)=-5,f(5,4)=-3,f(5,3)=-4$。

综上的 $\{ans_n\}=\{-5,-3,-4,-3,-5,0\}$。计算可得 $\text{xor}_{i=1}^n |ans_i|=4$。

**数据范围**

**本题采用捆绑测试。**

| 子任务编号 | 数据范围 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $\text{Subtask1}$ | $m\le n\le100$，$p\le20$ |  | $10$ |
| $\text{Subtask2}$ | $m\le n\le10^3$，$p\le100$ |  | $15$ |
| $\text{Subtask3}$ | $n\le10^5$，$p\le100$，$m=1$ |  | $10$ |
| $\text{Subtask4}$ | $m\le n\le10^5$，$p=1$ |  | $20$ |
| $\text{Subtask5}$ | $m\le n\le10^5$，$p\le100$ | 有 | $10$ |
| $\text{Subtask6}$ | $m\le n\le10^5$，$p\le100$ |  | $35$ |

特殊性质：保证树退化成一条链。

对于 $100\%$ 的数据 $1\le m\le n\le10^5$，$1\le p\le100$，$-10^4\le w\le10^4$，$1\le u,v,s_i\le n$。

## 样例 #1

### 输入

```
6 2 2
1 2 -2
1 3 1
1 4 2
2 5 -3
2 6 10
1 5
```

### 输出

```
4```

# AI分析结果



**算法分类选择**  
动态规划、树形DP  

**题解思路与算法要点**  
1. **状态设计**：定义`f[u][j]`为到达节点`u`时，玲的计数器模`p`为`j`时，悦的计数器的最小值。  
2. **状态转移**：从父节点`v`到子节点`u`，边权`w`，转移方程为：  
   `f[u][(j+1)%p] = min(f[u][(j+1)%p], f[v][j] + w)`  
3. **归零操作**：当`j=0`时，可选择将`a`减去当前路径的边权和（隐含在状态中），此时更新`f[u][0] = min(f[u][0], 0)`。  
4. **多源处理**：对每个起点`s_i`初始化`f[s_i][0] = 0`，并通过BFS或DP遍历树结构。  

**解决难点**  
- **路径唯一性**：树结构保证路径唯一，避免重复状态。  
- **归零操作隐式处理**：通过模运算和状态转移，隐式维护路径边权总和。  

**题解评分**  
4星：思路清晰，利用树结构和模运算优化状态转移，但归零操作处理细节需进一步验证。  

**最优思路提炼**  
- **树形动态规划**：利用树的无环特性，避免重复路径。  
- **模数状态压缩**：通过模运算将无限状态压缩为有限，保证时间复杂度。  
- **归零贪心决策**：在模为0时选择最优减操作，确保局部最优。  

**同类型题目**  
1. [P1354 树上最短路径](https://www.luogu.com.cn/problem/P1354)  
2. [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)  
3. [P2585 三色二叉树](https://www.luogu.com.cn/problem/P2585)  

**可视化与算法演示**  
1. **动画设计**：  
   - **节点高亮**：当前处理的节点以红色标记。  
   - **状态更新**：以绿色箭头表示状态转移，显示`f[u][j]`的更新过程。  
   - **模数变化**：用不同颜色背景表示当前模数`j`。  
   - **归零操作**：当`j=0`时，触发黄色闪烁提示可能的归零操作。  
2. **复古像素风格**：  
   - 用16色像素网格表示树结构，节点为方块，边为连线。  
   - 状态值以像素数字显示在节点旁，模数以颜色编码。  
3. **音效互动**：  
   - 状态更新时播放短促“滴”声，归零操作时播放“咔嚓”声。  
   - 背景音乐为8位循环旋律。  

**核心代码片段**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10, P = 105;
vector<pair<int, int>> g[N];
int f[N][P], ans[N], n, m, p;

void bfs(int s) {
    queue<int> q;
    if (f[s][0] == 0) return; // 已初始化
    f[s][0] = 0;
    q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto [v, w] : g[u]) {
            for (int j = 0; j < p; j++) {
                if (f[u][j] == 0x3f3f3f3f) continue;
                int nj = (j + 1) % p;
                int nval = f[u][j] + w;
                if (nval < f[v][nj]) {
                    f[v][nj] = nval;
                    q.push(v);
                }
                if (nj == 0) 
                    f[v][0] = min(f[v][0], nval - (nval - f[u][j]));
            }
        }
    }
}

int main() {
    memset(f, 0x3f, sizeof f);
    cin >> n >> m >> p;
    for (int i = 1; i < n; i++) {
        int u, v, w; cin >> u >> v >> w;
        g[u].emplace_back(v, w);
        g[v].emplace_back(u, w);
    }
    while (m--) {
        int s; cin >> s;
        bfs(s);
    }
    for (int u = 1; u <= n; u++) {
        ans[u] = *min_element(f[u], f[u] + p);
        // 处理结果异或
    }
    return 0;
}
```  
**代码解释**  
- **状态初始化**：`f`数组初始化为极大值，起点`s`的`f[s][0] = 0`。  
- **BFS遍历**：队列处理每个节点的状态转移，避免重复计算。  
- **归零操作**：当`nj == 0`时尝试更新归零后的状态（示例代码逻辑需完善）。  

**关键优化点**  
- **状态压缩**：仅维护模`p`的余数，空间复杂度`O(np)`。  
- **贪心更新**：每次转移取最小值，保证最优性。

---
处理用时：552.52秒
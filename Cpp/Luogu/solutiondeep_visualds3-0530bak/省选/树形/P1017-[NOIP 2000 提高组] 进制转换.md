# 题目信息

# [NOIP 2000 提高组] 进制转换

## 题目背景

NOIP2000 提高组 T1

## 题目描述

我们可以用这样的方式来表示一个十进制数：将每个阿拉伯数字乘以一个以该数字所处位置为指数，以 $10$ 为底数的幂之和的形式。例如 $123$ 可表示为 $1 \times 10^2+2\times 10^1+3\times 10^0$ 这样的形式。

与之相似的，对二进制数来说，也可表示成每个二进制数码乘以一个以该数字所处位置为指数，以 $2$ 为底数的幂之和的形式。  

一般说来，任何一个正整数 $R$ 或一个负整数 $-R$ 都可以被选来作为一个数制系统的基数。如果是以 $R$ 或 $-R$ 为基数，则需要用到的数码为 $0,1,\dots,R-1$。  

例如当 $R=7$ 时,所需用到的数码是 $0,1,2,3,4,5,6$，这与其是 $R$ 或 $-R$ 无关。如果作为基数的数绝对值超过 $10$，则为了表示这些数码，通常使用英文字母来表示那些大于 $9$ 的数码。例如对 $16$ 进制数来说,用 $A$ 表示 $10$，用 $B$ 表示 $11$，用 $C$ 表示 $12$，以此类推。

在负进制数中是用 $-R $ 作为基数，例如 $-15$（十进制）相当于 $(110001)_{-2}$（$-2$进制），并且它可以被表示为 $2$ 的幂级数的和数：

$$(110001)_{-2}=1\times (-2)^5+1\times (-2)^4+0\times (-2)^3+0\times (-2)^2+0\times (-2)^1 +1\times (-2)^0$$

设计一个程序，读入一个十进制数和一个负进制数的基数，并将此十进制数转换为此负进制下的数。


## 说明/提示

**数据范围**

对于 $100\%$ 的数据，$-20 \le R \le -2$，$|n| \le 37336$。




## 样例 #1

### 输入

```
30000 -2```

### 输出

```
30000=11011010101110000(base-2)```

## 样例 #2

### 输入

```
-20000 -2```

### 输出

```
-20000=1111011000100000(base-2)```

## 样例 #3

### 输入

```
28800 -16```

### 输出

```
28800=19180(base-16)```

## 样例 #4

### 输入

```
-25000 -16```

### 输出

```
-25000=7FB8(base-16)```

# AI分析结果



## 【唯一算法分类】  
数学模拟/数论

---

## 【题解思路与算法要点】  
**核心逻辑**：在负基数下，通过调整商和余数确保余数为正。当余数<0 时：  
1. 余数 = 余数 - 基数（负数基数的绝对值）  
2. 商 = 商 + 1（保证原式成立）  

**关键步骤**：  
1. 循环除以基数，记录余数  
2. 余数处理：负数时调整为正  
3. 递归/迭代处理商，直到商为0  
4. 倒序输出余数序列  

**解决难点**：  
- 传统除法余数可能为负  
- 需保证余数在 [0, |R|) 范围内  
- 调整后需维持被除数=商×基数+余数的等式关系  

---

## 【题解评分 (≥4星)】  
1. **老卡手机（4.5星）**  
   - 递归实现，代码简洁  
   - 关键公式推导清晰  
   - 直接通过字符运算省去数组倒序  

2. **judgejudge（4.5星）**  
   - 数学证明完整，逐步推导  
   - 非递归实现，适合大数据  
   - 余数转换公式解释透彻  

3. **Temp113（4星）**  
   - 代码极简，仅用单循环  
   - 直接处理余数调整  
   - 适合快速理解核心逻辑  

---

## 【最优思路提炼】  
**核心技巧**：  
```python
while n != 0:
    remainder = n % base
    n = n // base
    if remainder < 0:
        remainder -= base  # 余数调整为正
        n += 1             # 商调整+1
    ans.append(remainder)
```  
**数学本质**：通过调整余数和商，使得每次迭代的余数始终为正，维持 `n = q * base + r` 的等式成立。

---

## 【同类型题与算法套路】  
- **通用解法**：所有涉及负基数、非对称模运算的进制转换  
- **类似题目**：  
  1. LeetCode 504. Base 7（正基数简单版）  
  2. Codeforces 837D. Round Subset（负基数扩展）  
  3. 洛谷 P1143 进制转换（正负基数通用模板）  

---

## 【推荐相似题目】  
1. **P1143** 进制转换（正负基数通用）  
2. **P1062** 数列（负基数数列规律）  
3. **P2084** 进制转换（大数进制处理）  

---

## 【个人心得摘录】  
- **老卡手机**：递归输出顺序天然倒序，省去显式反转操作  
- **judgejudge**：通过公式推导验证余数调整的正确性  
- **Dancepted**：暴力法虽AC，但指出数据范围允许此类取巧  

---

## 【可视化与算法演示】  
**动画设计**：  
1. **网格绘制**：  
   - 用 Canvas 绘制余数队列，每个方块表示一位  
   - 红色高亮当前处理的余数  
   - 黄色标记调整后的余数和商  

2. **步进流程**：  
   ```plaintext
   Step 1: n = 30000, R = -2  
   → 30000 ÷ (-2) = -15000, 余数 0 → 记录 [0]  
   Step 2: n = -15000  
   → -15000 ÷ (-2) = 7500, 余数 0 → 记录 [0,0]  
   ...（后续步骤同理）  
   ```  

3. **复古像素效果**：  
   - 8-bit 风格字体显示余数  
   - 每次除法播放“滴”声，调整余数时播放“嘟”声  
   - 完成时播放《超级马里奥》过关音效  

**交互功能**：  
- 速度滑块控制动画帧率  
- 单步/连续模式切换  
- 显示当前公式 `n = q * R + r`  

---

## 【核心代码实现】  
```cpp
void convert(int n, int base) {
    if (n == 0) return;
    int rem = n % base;
    if (rem < 0) {
        rem -= base;  // 余数调整为正
        n += base;    // 商调整+1（等价于 n = (n - rem)/base）
    }
    convert(n / base, base); // 递归处理商
    cout << "0123456789ABCDEF"[rem]; // 直接映射字符
}
```  

**代码说明**：递归实现余数倒序输出，调整步骤仅需 3 行核心逻辑。

---
处理用时：62.42秒
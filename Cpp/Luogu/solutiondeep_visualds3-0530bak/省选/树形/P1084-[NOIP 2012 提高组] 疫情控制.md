# 题目信息

# [NOIP 2012 提高组] 疫情控制

## 题目描述

H 国有 $n $ 个城市，这 $n$ 个城市用 $ n-1 $ 条双向道路相互连通构成一棵树，$1 $ 号城市是首都，也是树中的根节点。

H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。

现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。

请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。


## 说明/提示

【输入输出样例说明】

第一支军队在 $2$ 号点设立检查点，第二支军队从 $2$ 号点移动到$ 3$ 号点设立检查点，所需时间为 $3$ 个小时。

 
【数据范围】

保证军队不会驻扎在首都。

- 对于 $20\%$ 的数据，$2 \le n\le 10$；
- 对于 $40\%$ 的数据，$2 \le n\le 50$，$0<w <10^5$；
- 对于 $60\%$ 的数据，$2 \le n\le 1000$，$0<w <10^6$；
- 对于 $80\%$ 的数据，$2 \le n\le 10^4$；
- 对于 $100\%$ 的数据，$2\le m\le n≤5\times 10^4$，$0<w <10^9$。


NOIP 2012 提高组 第二天 第三题


## 样例 #1

### 输入

```
4 
1 2 1 
1 3 2 
3 4 3 
2 
2 2```

### 输出

```
3```

# AI分析结果



1. **算法分类**  
   二分答案 + 树上倍增 + 贪心

---

### 综合分析与结论

#### 核心算法流程
1. **二分答案**：通过二分时间确定最小可行解
2. **树上倍增预处理**：预处理每个节点的 2^k 级祖先和对应距离，用于快速跳转
3. **军队上提**：对于每个军队，在二分时间内尽可能向上跳到根节点的子节点或最高位置
4. **贪心匹配**：
   - 收集能到达根节点的军队剩余时间（闲置军队）
   - 标记需要封锁的子树（未覆盖的根节点子节点）
   - 用双指针或优先队列匹配闲置军队与待封锁子树

#### 可视化设计
1. **树形结构绘制**：以根节点为中心绘制树状结构，用不同颜色标记已覆盖/未覆盖的子树
2. **军队移动动画**：
   - 用动态箭头表示军队沿倍增路径跳跃的过程
   - 军队到达根节点后显示剩余时间气泡
3. **贪心匹配演示**：
   - 用排序后的数组以条形图展示闲置军队和待封锁子树
   - 动态连线展示双指针匹配过程
4. **复古像素风格**：
   - 使用 8-bit 风格的树节点（像素方块）
   - 军队移动时播放 FC 风格音效（跳跃音、匹配成功音）

#### 关键难点解决方案
- **高效检查覆盖**：通过 DFS 标记已覆盖节点，避免暴力遍历
- **子树间最优分配**：排序后贪心匹配最大剩余时间军队与最远待封锁子树

---

### 题解清单 (4星及以上)

1. **TEoS（★★★★★）**
   - 亮点：步骤拆解清晰，代码结构规范，包含完整预处理和匹配逻辑
   - 关键代码：树上倍增预处理 + 双指针贪心匹配

2. **FlashHu（★★★★☆）**
   - 亮点：使用 DFS 替代倍增检查覆盖状态，代码简洁
   - 关键优化：O(n logn) 替代双 logn 复杂度

3. **litble（★★★★☆）**
   - 亮点：提出「剩余路程」概念，优化子树转移策略
   - 调试心得：详细注释关键变量作用

---

### 核心代码实现

#### 树上倍增预处理
```cpp
void bfs() { // 预处理倍增表
    queue<int> q; q.push(1); d[1] = 1;
    while(q.size()) {
        int x = q.front(); q.pop();
        for(int i = head[x]; i; i = Next[i]) {
            int y = ver[i];
            if(d[y]) continue;
            d[y] = d[x] + 1;
            f[y][0] = x, dist[y][0] = edge[i];
            for(int j=1; j<=t; j++) {
                f[y][j] = f[f[y][j-1]][j-1];
                dist[y][j] = dist[y][j-1] + dist[f[y][j-1]][j-1];
            }
            q.push(y);
        }
    }
}
```

#### 贪心匹配检查
```cpp
bool check(ll lim) {
    // ...（军队上提逻辑）
    
    // 排序双数组
    sort(tim+1, tim+atot+1);
    sort(ned+1, ned+btot+1);
    
    // 双指针匹配
    int i=1, j=1;
    while(i<=btot && j<=atot) {
        if(tim[j] >= ned[i]) i++, j++;
        else j++;
    }
    return i > btot;
}
```

---

### 同类型题推荐
1. **P5021 赛道修建** - 树形结构 + 二分答案
2. **P1081 开车旅行** - 倍增预处理 + 双指针
3. **P2680 运输计划** - 树上路径处理 + 二分答案

---

### 可视化代码片段（Canvas 演示）

```javascript
// 绘制树形结构
function drawTree(ctx) {
    // 根节点坐标 (400, 50)
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(395, 45, 10, 10);
    
    // 递归绘制子节点
    function drawNode(x, y, node, depth) {
        // 计算子节点位置
        let angle = Math.PI / (node.children.length + 1);
        node.children.forEach((child, i) => {
            let childX = x + Math.cos(angle*(i+1)) * 100;
            let childY = y + 80;
            // 画连线
            ctx.beginPath();
            ctx.moveTo(x+5, y+5);
            ctx.lineTo(childX+5, childY+5);
            ctx.strokeStyle = child.covered ? '#00FF00' : '#FF0000';
            ctx.stroke();
            // 递归绘制
            drawNode(childX, childY, child, depth+1);
        });
    }
    
    drawNode(400, 50, root, 0);
}
```

---

### 实现要点总结
1. **树上倍增**：预处理每个节点的 2^k 级祖先和距离，时间复杂度 O(n logn)
2. **贪心匹配**：通过排序+双指针实现 O(n logn) 的匹配检查
3. **覆盖判定**：DFS 标记已覆盖节点避免重复计算

通过合理的算法组合和数据结构选择，将看似复杂的树形问题转化为高效的可计算模型。

---
处理用时：61.55秒
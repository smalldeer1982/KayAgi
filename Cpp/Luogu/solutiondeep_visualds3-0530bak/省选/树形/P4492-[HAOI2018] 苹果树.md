# 题目信息

# [HAOI2018] 苹果树

## 题目背景

HAOI2018 Round2 第一题

## 题目描述

小 C 在自己家的花园里种了一棵苹果树, 树上每个结点都有恰好两个分支. 经过细心的观察, 小 C 发现每一天这棵树都会生长出一个新的结点.

第一天的时候, 果树会长出一个根结点, 以后每一天, 果树会随机选择一个当前树中没有长出过结点 的分支, 然后在这个分支上长出一个新结点, 新结点与分支所属的结点之间连接上一条边.

小 C 定义一棵果树的不便度为树上两两结点之间的距离之和, 两个结点之间 的距离定义为从一个点走到另一个点的路径经过的边数.

现在他非常好奇, 如果 $N$ 天之后小 G 来他家摘苹果, 这个不便度的期望 $E$ 是多少. 但是小 C 讨厌分数, 所以他只想知道 $E \times N !$ 对 $P$ 取模的结果, 可以证明这是一个整数.

## 说明/提示

![Explanation](https://cdn.luogu.com.cn/upload/pic/18067.png)

以上是所有 $N = 3$ 时可能的苹果树形态, 其中编号表示这个结点是第几天生
长出来的, 显然每种情况两两结点的距离均为 $4$ .

### 数据范围与约定
| 测试点编号   | $N$  | $P$  |
| :--------: | :--: | :--: |
| $1$ |  $\le 10$    |  $\le 10^9 + 7$    |
| $2$ |  $\le 10$    |   $\le 10^9 + 7$    |
| $3$ |  $\le 500$    |  $\le 10^9 + 7$     |
| $4$ |  $\le 500$    |   $\le 10^9 + 7$    |
| $5$ |  $\le 500$    |   $\le 10^9 + 7$    |
| $6$ |  $\le 2000$    |   $= 10^9 + 7$    |
| $7$ |  $\le 2000$    |   $= 10^9 + 7$    |
| $8$ |  $\le 2000$    |   $\le 10^9 + 7$    |
| $9$ |  $\le 2000$    |   $\le 10^9 + 7$    |
| $10$ | $\le 2000$     |    $\le 10^9 + 7$   |



## 样例 #1

### 输入

```
3 610745795```

### 输出

```
24```

## 样例 #2

### 输入

```
305 1000000007```

### 输出

```
865018107```

# AI分析结果



## 唯一算法分类
组合数学

---

## 综合分析与结论

### 核心思路与算法流程
1. **边的贡献分析**  
   每条边贡献为 `size * (n - size)`，其中 size 是子树大小。通过枚举每个节点 i 及其可能的子树大小 siz，计算所有情况下的贡献总和。

2. **组合数学计算方案数**  
   - **子树内部**：选择 `siz-1` 个点（从 `n-i` 个未选点中选），方案数为组合数 `C(n-i, siz-1)`；子树形态有 `siz!` 种  
   - **子树外部**：前 `i` 个点的排列为 `i!`，剩余点的排列为 `i*(i-1)*...*(n-siz-1)`，可简化为 `i*(i-1)*(n-siz-1)!`

3. **预处理优化**  
   预处理阶乘 `fac[]` 和组合数 `C[][]`，时间复杂度优化至 O(n²)

### 可视化设计
- **动画方案**：  
  以像素风格展示树的生长过程，每次新增节点时高亮当前操作的分支。  
  右侧面板同步显示枚举的节点 i 和子树大小 siz，动态计算组合数 `C(n-i, siz-1)` 和阶乘值。  
  边贡献 `size*(n-size)` 以闪烁颜色标记，累计总和实时更新。

- **复古元素**：  
  使用 8-bit 音效提示关键步骤（如组合数计算完成、贡献累加）。  
  树结构用像素方块表示，每个节点的添加伴随“生长音效”。  
  控制面板支持暂停/单步执行，可调节动画速度观察细节。

---

## 题解清单 (≥4星)

### 1. shadowice1984 (5星)
**关键亮点**：  
- 从边的贡献角度切入，推导严谨  
- 公式化简清晰，代码结构简洁  
- 预处理组合数和阶乘，时间复杂度严格 O(n²)  
- 注释详细，变量命名规范  

### 2. TonyYin (5星)  
**关键亮点**：  
- 分步骤说明组合数学推导过程  
- 代码模块化（预处理、循环计算分离）  
- 使用 `long long` 防止溢出，模运算处理规范  

### 3. lhm_ (4星)  
**关键亮点**：  
- 代码简洁，直接实现核心公式  
- 使用 `inline` 优化循环效率  
- 变量命名简短但语义明确  

---

## 核心代码实现

### 预处理组合数与阶乘
```cpp
ll fac[maxn], C[maxn][maxn];
void init() {
    fac[0] = 1;
    for(int i=1; i<=n; i++) fac[i] = fac[i-1] * i % mod;
    for(int i=0; i<=n; i++) {
        C[i][0] = 1;
        for(int j=1; j<=i; j++) 
            C[i][j] = (C[i-1][j-1] + C[i-1][j]) % mod;
    }
}
```

### 贡献计算主循环
```cpp
ll ans = 0;
for(int i=2; i<=n; i++) {
    for(int siz=1; siz<=n-i+1; siz++) {
        ll term = fac[siz] * C[n-i][siz-1] % mod;
        term = term * siz % mod * (n - siz) % mod;
        term = term * fac[n-siz-1] % mod * i % mod * (i-1) % mod;
        ans = (ans + term) % mod;
    }
}
```

---

## 同类型题推荐
1. **P3974 [TJOI2015] 组合数学**  
   组合数应用与递推优化

2. **P4921 情侣？给我烧了！**  
   组合数学与错位排列思想

3. **P4436 [HNOI/AHOI2018] 排列**  
   树形结构与贪心结合的组合问题

---

## 个人心得摘录
> "调试时发现模数非质数，必须严格预处理组合数而非逆元" —— lhm_  
> 关键教训：处理模数时需先确认其性质，避免错误使用逆元优化。

---

## 复古动画代码片段
```javascript
// 像素风格树节点绘制
function drawNode(x, y, size) {
    ctx.fillStyle = "#FF00FF"; // 8-bit 粉色
    ctx.fillRect(x*20, y*20, 18, 18); // 20px网格
    playSound('blip'); // 触发音效
}

// 自动演示模式
function autoRun() {
    for(let i=1; i<=n; i++) {
        for(let siz=1; siz<=n-i+1; siz++) {
            highlightEdge(i, siz); // 高亮当前边
            updateFormulaDisplay(i, siz); // 更新公式面板
            stepDelay(500); // 步进间隔
        }
    }
}
```

---
处理用时：69.55秒
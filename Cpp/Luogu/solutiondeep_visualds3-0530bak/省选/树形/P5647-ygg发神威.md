# 题目信息

# ygg发神威

## 题目背景

ygg 发神威了，机房的萌新们瑟瑟发抖。

## 题目描述

ygg 的机房内共有 $n$ 台电脑且都被使用，为了节省机房内电脑的开销，第 $i$ 台电脑会同时被 $a_i$ 个萌新使用。每台电脑都装有一个「多人在线交流平台」，一台电脑会直接地或间接地通过这个平台与其他所有电脑连接。由于「多人在线交流平台」仍然处于测试阶段，如果一台电脑有多于一种不同的消息传输方式将消息传输到另外的任意一台电脑，就会有各种稀奇古怪的问题产生。两种消息的传输方式被认为是不同的，当且仅当传输消息所经过的直接连接的线路的集合不同，或者传输所经过的电脑的集合不同。当然，消息的传输肯定不会经过一条线路多次。为了避免这种状况，「多人在线交流平台」的线路被特殊地设计了，以使得任意两台电脑之间的传输线路唯一。同时，为了防止一台电脑负荷过大，一台电脑最多会通过「多人在线交流平台」的线路与 $p$ 台电脑相连。

原本两台通过「多人在线交流平台」的线路相连的电脑之间可以相互传输数据，可是 ygg 发现，这会允许使用两台电脑的萌新们互相发送消息，引起大规模~~考试作弊~~膜拜 ygg 的行为。所以他大发神威，切断了所有连接线路的一半。具体地，他将原本通过「多人在线交流平台」的双向线路连接的两台电脑之间的线路变成了单向线路。即，原本通过一条双向线路连接的两台电脑中，只能有一台电脑向另一台电脑发送消息，而另一台电脑不能将任何消息发送回来。

机房内的萌新们在每个时刻都有若干条消息需要传递。如果一台电脑 $i$ 能够直接或间接地通过「多人在线交流平台」的线路连接到电脑 $j$，那么使用电脑 $i$ 的 $a_i$ 个萌新中的任何一个都可以向使用电脑 $j$ 的 $a_j$ 个萌新发送消息。显然，使用同一台电脑的萌新之间的消息只需要在线下传达，不需要使用「多人在线交流平台」，因此不会计入线上发送的消息。

其实机房中的萌新们早已知道了「多人在线交流平台」的管理员密码，所以能够对其线路的连接方向做出修改。可无论他们怎么尝试，都不能恢复最开始时双向连接的状态了。机房中的萌新们当然希望能够尽可能地发送消息，所以他们想要知道，在机房的电脑仅被单向的线路连接时，每一时刻最多能有多少条消息被通过「多人在线交流平台」发送。

为了简化问题，我们假设机房内的所有萌新均能够在同一时刻发送线上消息，并且每一个萌新可以同时向多个人发送消息。

**简要题面：给一棵结点编号** $1\sim n$**，结点权值** $a_i$**，且结点度数最大为** $p$ **的树。求将树的每条边改为有向边后下式的最大值：**

$$\sum_{i=1}^{n}\sum_{j=1}^{n}a_ia_j\left[i\rightarrow j\right]$$

$\left[i\rightarrow j\right]$ **定义为：若编号为** $i$ **的结点能通过有向边到达编号为** $j$ **的结点，则值为** $1$**；否则值为** $0$**，且** $\left[i\rightarrow i\right]=0$**。**

## 说明/提示

### 样例解释

能够发送的消息最多时的消息传递方向如下：

![](https://i.loli.net/2019/10/30/3AsqcyzdY25E8gP.png)

在该连接方式下发送消息最多的时刻，使用 $1$ 号电脑的 $1$ 个萌新向 $5$ 个萌新各发送了一条消息，共 $1\times5=5$ 条消息；  
使用 $2$ 号电脑的 $2$ 个萌新分别向 $3$ 个萌新各发送了一条消息，共 $2\times3=6$ 条消息；  
使用 $3$ 号电脑的 $3$ 个萌新不能向任何萌新发送线上消息，因此没有消息从该电脑发送；  
使用 $4$ 号电脑的 $4$ 个萌新分别向 $6$ 个萌新各发送了一条消息，共 $4\times6=24$ 条消息。  
因此，在某一时刻，最多可以有 $5+6+24=35$ 条线上消息被发送。   
可以使用枚举法验证，不存在一种单向的连接方式，使得在某一时刻发送的线上消息的数量能够达到 $36$ 条或更多。

### 数据范围及约定

对于 $10\%$ 的数据，$n\le10$；  
对于另外 $10\%$ 的数据，$n=p+1$；  
对于另外 $10\%$ 的数据，$p=2$；  
对于另外 $10\%$ 的数据，$p\le20$；  
对于另外 $10\%$ 的数据，$p\le40$；  

对于所有数据，$2\le n\le10^5$，$2\le p\le50$，$1\le a_i\le100$，$1\le u_i,v_i\le n$。保证给出的双向连接线路能够使任意两台电脑之间的消息传输线路唯一。保证至少有一台电脑原本通过「多人在线交流平台」连接的线路数恰好为 $p$，且没有电脑原本连接的线路数大于 $p$。

## 样例 #1

### 输入

```
4 2
1 2 3 4
1 2
3 2
4 1
```

### 输出

```
35
```

# AI分析结果



**唯一算法分类：树形动态规划 + 折半枚举**

---

### **题解思路与核心难点**

**题目核心**：给定一棵树，将每条边定向为有向边，使得所有可达节点对 (i, j) 的权值乘积之和最大。  
**关键难点**：如何高效选择边的方向，最大化贡献。需同时考虑根节点的贡献和各子树的内部贡献。

---

### **题解思路与算法分析**

1. **树形结构分析**  
   - 树形结构决定了边定向后的可达关系。  
   - 每个子树的内部贡献（内部可达对）是固定的，与边方向无关（题解结论）。

2. **贡献模型推导**  
   - 根节点贡献 = `sum_selected_sv * (S - sum_selected_sv + a_u)`，其中：  
     - `sum_selected_sv`：被反向子树的权值和。  
     - `S`：所有子树的权值和。  
   - 总贡献需最大化此二次函数，最优值在 `sum_selected_sv ≈ (S + a_u)/2` 时取得。

3. **折半枚举优化**  
   - 子树数目最多为 `p`，直接枚举所有子集不可行。  
   - **折半策略**：将子树分为两半，分别枚举可能的和，合并两部分结果以快速找到最优解。  
   - 时间复杂度：`O(n + 2^(p/2) * p)`，适用于 `p ≤ 50` 的约束。

4. **树的重心优化**  
   - 选择加权重心为根，使得各子树权值尽可能平衡，减少枚举复杂度。

---

### **最优思路提炼**

1. **动态规划与折半枚举**  
   - 对每个子树权值进行分组，分别计算可能的和，合并时查找最接近目标值的组合。  
   - **代码实现**：  
     ```cpp
     // 折半枚举核心代码
     vector<int> left = generate_sums(s_v的前半部分);
     vector<int> right = generate_sums(s_v的后半部分);
     sort(left.begin(), left.end());
     int best = 0;
     for (int r : right) {
         int target = (total + a_u)/2 - r;
         auto it = lower_bound(left.begin(), left.end(), target);
         if (it != left.end()) best = max(best, r + *it);
         if (it != left.begin()) best = max(best, r + *(it-1));
     }
     ```

2. **递归处理子树**  
   - 递归计算每个子树的内部贡献和权值，最终合并到根节点的计算中。

---

### **同类型题与算法套路**

- **类似问题**：树边定向问题、分组最大化乘积问题、树形背包问题。  
- **通用套路**：  
  - 利用树的重心分解优化树形问题。  
  - 折半枚举处理大范围子集问题。  
  - 动态规划处理权值和的最优化。

---

### **推荐题目**

1. **P1352 没有上司的舞会**（树形DP）  
2. **P2014 选课**（树形背包）  
3. **P4178 Tree**（树分治 + 折半枚举）

---

### **可视化与算法演示**

**核心算法动画方案**：  
1. **树结构展示**：Canvas绘制树形结构，根节点高亮为红色。  
2. **边定向过程**：  
   - 点击子树切换方向（红边为反向，蓝边为正向）。  
   - 实时更新当前贡献值。  
3. **折半枚举演示**：  
   - 左侧显示前半子树的所有可能的和，右侧显示后半子树。  
   - 动态连线匹配最优组合，突出最接近 `(S+a_u)/2` 的值。  

**复古像素风格**：  
- **颜色方案**：根节点（红），子树节点（绿/蓝），边（灰）。  
- **音效**：切换边方向时播放“哔”声，找到最优解时播放胜利音效。  

---

### **代码实现核心**

```cpp
struct Subtree {
    int sum, contrib;
    vector<int> s_v;
};

int solve(Node* root) {
    if (root == null) return 0;
    vector<Subtree> subtrees;
    int total = 0;
    // 递归处理所有子树
    for (auto child : root->children) {
        Subtree st = solve(child);
        subtrees.push_back(st);
        total += st.sum;
    }
    // 折半枚举选择最优子集
    vector<int> left = generate_sums(subtrees前半的s_v);
    vector<int> right = generate_sums(subtrees后半的s_v);
    int best_selected = find_best_combination(left, right, (total + root->a)/2);
    // 计算总贡献
    int total_contrib = best_selected * (total + root->a - best_selected);
    for (auto st : subtrees) total_contrib += st.contrib;
    return total_contrib + root->a * best_selected;
}
```

---

### **结论**

本题通过树形动态规划结合折半枚举，高效处理边定向的最优选择。核心在于正确建模贡献函数，并利用树的重心分解和子集和优化技术，在较大数据范围下仍保持高效。

---
处理用时：453.10秒
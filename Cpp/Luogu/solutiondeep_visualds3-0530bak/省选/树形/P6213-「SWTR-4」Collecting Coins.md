# 题目信息

# 「SWTR-4」Collecting Coins

## 题目背景

小 A 喜欢 Collecting Coins。他还有个好朋友叫做小 c。

小 c 在外出游玩的时候被困在了一个迷宫里面，小 A 得知消息后，立刻放下了自己手中正在打的树套树套树套树，出发去营救她。

## 题目描述

经过一番勘察，小 A 发现小 c 被困的迷宫由 $n$ 个房间组成，这些房间用 $n-1$ 扇门连接，**形成了一颗树**。小 c 被困在 $d$ 号房间。

小 A 还发现每扇门上都写有一个数字 $v$，经过该扇门就会获得 $v$ 个金币，但每扇门上的金币只能获得一次。

由于把小 c 困在迷宫里的坏人早已知道小 A 会来救她，所以他们在每个房间里都布下了陷阱，使得第 $i$ 个房间最多可以进入 $k_i$ 次，否则小 A 也会被困在迷宫里。Luckily，小 c 在向小 A 求救的时候，已经将这个陷阱告诉了他。

小 A 在进入迷宫的时候可以任选初始房间 $r$（进入迷宫算一次进入房间 $r$）。**小 A 可以离开迷宫，当且仅当他在房间 $r$。**

如果小 A 进入了 $d$ 号房间，我们就认为他成功地救下了小 c。在救下小 c 后，小 A 还可以带着她继续在迷宫中行动。

虽然小 A 并不是一个非常贪财的人，但还是想知道：在**成功救下小 c** 且离开迷宫的前提下，他最多能获得多少金币。

## 说明/提示

【样例 $1$ 说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/zwtjgksh.png)

一种最优的走法为：$2\to 4\to 2$，共可获得 $5$ 金币。

【样例 $2$ 说明】

如上图，小 A 只能空降到 $4$ 号房间，然后再离开迷宫，共可获得 $0$ 金币。

【样例 $4$ 说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/fmd43hzq.png)

一种最优的走法为：$3\to 9\to 10\to 8\to 10\to 12\to 6\to 12\to 10\to 9\to 3$，共可获得 $100+59+65+9+30=263$ 金币。

【数据范围与约定】

**本题使用捆绑测试。**

Subtask 编号 | $n\leq$ | 特殊性质 | 分值 |
:-: | :-: | :-: | :-: |
$1$ | $12$ | $k_i=1$ | $3$ |
$2$ | $12$ | $k_i\leq 3$ | $12$ |
$3$ | $10^3$ | 迷宫为一条链 | $9$ |
$4$ | $10^3$ | 无 | $16$ |
$5$ | $10^5$ | 迷宫为一条链 | $9$ |
$6$ | $10^5$ | 迷宫为一个菊花图 | $16$ |
$7$ | $10^5$ | 无 | $35$ |

对于 $100\%$ 的数据，$1\leq d,k_i\leq n\leq 10^5$，$1\leq v_i\leq 10^4$。

【Source】

[Sweet Round 04](https://www.luogu.com.cn/contest/26414)$\ \ $E

idea & std：[Alex_Wei](https://www.luogu.com.cn/user/123294)，验题：[chenxia25](https://www.luogu.com.cn/user/138400)

## 样例 #1

### 输入

```
6 4
1 2 3
2 3 4
2 4 5
3 5 2
3 6 3
1 2 1 1 2 2
```

### 输出

```
5```

## 样例 #2

### 输入

```
6 4
1 2 3
2 3 4
2 4 5
3 5 2
3 6 3
1 1 1 1 1 1
```

### 输出

```
0```

## 样例 #3

### 输入

```
6 4
1 2 3
2 3 4
2 4 5
3 5 2
3 6 3
2 2 2 2 2 2
```

### 输出

```
12```

## 样例 #4

### 输入

```
12 6
1 4 33
2 11 51
3 9 100
4 8 7
5 9 35
6 12 30
7 11 58
8 10 65
9 10 59
10 12 9
11 12 72
2 2 2 3 2 1 2 1 2 3 2 2
```

### 输出

```
263```

# AI分析结果



### 唯一算法分类
树形动态规划（换根DP）

---

### 题解思路与算法要点

#### 核心思路
1. **树形DP状态定义**：  
   以 `d` 为根节点，定义两个状态：
   - `f[u]`：以 `u` 为根的子树满足度数限制的最大金币（未选择入口）
   - `g[u]`：在 `f[u]` 基础上，允许选择一个子节点作为入口（需满足入口度数限制）

2. **关键转移逻辑**：
   - **子节点排序**：对每个节点的子节点按 `f[v]+边权` 降序排序，选择前 `k[u]-1` 个
   - **状态转移**：
     ```cpp
     f[u] = sum(前k[u]-1大的 f[v]+边权)
     g[u] = max(
         sum(前k[u]-2大的 f[v]+边权) + 最优的 g[v]+边权,  // 替换一个子节点
         sum(前k[u]-1大的 f[v]+边权) - 最小贡献 + 入口贡献
     )
     ```

#### 解决难点
- **入口选择**：入口 `r` 的度数需少1，通过 `g[u]` 状态巧妙处理
- **高效选择子节点**：通过排序快速选取前 `k-1` 大的贡献，时间复杂度 `O(n log n)`

---

### 题解评分（≥4星）

1. **BeyondHeaven（5星）**  
   - **亮点**：单次DFS高效处理，状态转移设计简洁，边界条件处理清晰  
   - **代码**：核心逻辑仅30行，利用排序和贪心选择子节点

2. **Alex_Wei（4星）**  
   - **亮点**：换根DP完整思路，详细推导父节点贡献转移  
   - **优化**：使用 `set` 维护动态选择的子节点集合

3. **z7z_Eta（4星）**  
   - **亮点**：双状态树形DP直观解释，代码注释详细  
   - **缺点**：部分边界条件未完全覆盖（如 `k[u]=1` 的特殊处理）

---

### 最优思路提炼
1. **根节点选择**：以 `d` 为根构建树，避免路径合法性判断
2. **贪心选择子节点**：通过排序快速选取前 `k-1` 大的子节点贡献
3. **入口替换策略**：在 `g[u]` 中用 `f[v]` 替换为 `g[v]` 来引入入口选择

---

### 类似题目推荐
1. **P2015 二叉苹果树**  
   （树形DP，选择边权最大的子树）
2. **P1273 有线电视网**  
   （树形DP结合背包问题，收益最大化）
3. **P2585 三色二叉树**  
   （树形DP状态分治，颜色分配策略）

---

### 可视化与算法演示设计

#### 动画方案
1. **树结构绘制**：  
   - 使用Canvas绘制树形结构，节点按层级分布
   - 当前处理节点高亮为**红色**，已处理节点为**绿色**

2. **动态排序与选择**：  
   - 子节点按贡献值排序，动态显示排序过程
   - 前 `k-1` 大的子节点用**金色边框**标记，被替换的子节点闪烁提示

3. **状态更新动画**：  
   - `f[u]` 和 `g[u]` 的值在节点旁实时更新
   - 替换操作时，用箭头动画表示贡献值的增减

#### 复古游戏化设计
- **像素风格**：  
  - 8位色调色板（红、绿、金、黑）
  - 节点用16x16像素方块表示，边用1像素线段
- **音效设计**：  
  - 节点处理完成：短促 "哔" 声
  - 子节点替换：两音阶 "叮咚"
  - 最优解达成：经典FC过关音效

---

### 核心代码实现（BeyondHeaven解法）
```cpp
void Dfs(int u, int fa, int val) {
    path[u] = val;
    if (k[u] == 1) { // 边界处理
        f[u] = 0; g[u] = -INF; return;
    }
    vector<int> sons;
    for (int i = head[u]; i; i = edge[i].next) {
        int v = edge[i].to;
        if (v != fa) {
            Dfs(v, u, edge[i].w);
            sons.push_back(v);
        }
    }
    // 按 f[v]+边权 降序排序
    sort(sons.begin(), sons.end(), [](int a, int b) {
        return f[a] + path[a] > f[b] + path[b];
    });
    // 计算 f[u]
    for (int i = 0; i < min(k[u]-1, (int)sons.size()); ++i)
        f[u] += f[sons[i]] + path[sons[i]];
    // 计算 g[u]
    if (k[u]-1 <= sons.size()) {
        int dec = f[sons[k[u]-2]] + path[sons[k[u]-2]];
        for (int i = 0; i < k[u]-1; ++i)
            dec = min(dec, f[sons[i]] - g[sons[i]]);
        g[u] = f[u] - dec;
    } else {
        g[u] = f[u];
    }
}
```

---

### 个人心得摘录
> "在转移 `g[u]` 时，最初忽略了 `k[u]=1` 时无法选择任何子节点的情况，导致WA。通过添加 `if(k[u]==1) g[u]=-INF` 才通过所有测试用例。"  
> —— BeyondHeaven调试笔记

---

### 扩展思考
- **时间复杂度优化**：使用堆（优先队列）替代全排序，将 `O(n log n)` 优化为 `O(n log k)`
- **空间优化**：用滚动数组替代 `f` 和 `g` 的二维存储

---
处理用时：76.33秒
# 题目信息

# [YsOI2020] 造林

## 题目背景

「承前」

Ysuperman 响应号召，决定在幼儿园外造林。

呐呐，如果这样的话，Ysuperman 便能在这炎热的夏天与小朋友们玩游戏了呢。

## 题目描述

为了落实环保工作，Ysuperman 购进了一批树，它们都长一个样。由于树还没有种下去，所以这些树还没有根，可以认为是**无根树**。

Ysuperman 觉得全都种长得一样的树太无聊了，于是 TA 请到了园艺公司帮 TA 规划。园艺公司提供给了 TA 一个方法——「嫁接」。

下面给出「嫁接」操作的定义：

定义「叶子节点」为树上度数为 $1$ 的节点。
 
「嫁接」操作指：在一棵**无根树**上接入一个新的「叶子节点」。

例如：  
![](https://cdn.luogu.com.cn/upload/image_hosting/jfaksqwy.png)

图 2 是由图 1 的树进行一次合法的嫁接操作后得到的树，图 3 也是由图 1 的树进行一次合法的嫁接操作后得到的树。

那么，我们还知道，树有一个基本属性：「品种」。

一棵树的「品种」是指**每个点的最大子树大小所构成的可重集**。

两棵树的「品种」不同，当且仅当**每个点的最大子树大小所构成的可重集不同**。

这里的一个点的**最大子树大小**指将这个点删掉后**最大的联通块所包含的点数**。

例如：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zzyznfl7.png)

图 4 的树的每个点的最大子树大小所构成的可重集为：$ \{ 2,2,3,3 \} $  
图 5 的树的每个点的最大子树大小所构成的可重集为：$ \{ 2,2,3,3 \} $  
图 6 的树的每个点的最大子树大小所构成的可重集为：$ \{ 1,3,3,3 \} $  
所以说，图 4 的树与图 5 的树「品种」相同，与图 6 的树「品种」不同。

Ysuperman 想知道，通过一次「嫁接」操作，可以构造出的树包含多少不同的「品种」，以及对于每个「品种」，有多少不同的「嫁接」方法可以构造。请**从小到大**输出每个「品种」的「嫁接」方法数。

两个「嫁接」方案不同，当且仅当在「嫁接」操作中与新接入的「叶子节点」直接相连的点不同。


## 说明/提示

**本题采用捆绑测试。**
### 样例解释 1
可以构造出 1 种「品种」为 $\{2,4,4,5,5,5\}$ 的树。  
可以构造出 2 种「品种」为 $\{3,3,4,5,5,5\}$ 的树。  
可以构造出 2 种「品种」为 $\{3,3,4,4,5,5\}$ 的树。
### 样例解释 2
可以构造出 1 种「品种」为 $\{3,5,5,7,7,7,7,7\}$ 的树。  
可以构造出 2 种「品种」为 $\{4,4,5,7,7,7,7,7\}$ 的树。  
可以构造出 4 种「品种」为 $\{4,4,5,6,7,7,7,7\}$ 的树。


对于 100% 的数据，满足 $1 \le n\le2\cdot 10^6$。

定义「链」为所有节点度数不超过 $2$ 的树。  
定义「菊花」为包含 $n-1$ 个「叶子节点」的树。

特殊性质 1：保证树的形态为一条「链」。  
特殊性质 2：保证树的形态为一朵「菊花」。  
特殊性质 3：保证树的形态为一棵完全二叉树。

| subtask | $n$ | 特殊性质 | 分值 | 时间限制 |
| :-----------: | :-----------: | :-----------: | :--------:| :---------:|
| 1 | $\le 2\cdot 10^6$ | 2 | 2 | 4s |
| 2 | $\le 2\cdot 10^6$ | 1 | 3 | 4s |
| 3 | $\le 300$ | 无 | 5 | 1s |
| 4 | $\le 2\cdot10^6$ | 3 | 7 | 4s |
| 5 | $\le 5000$ | 无 | 23 | 1s |
| 6 | $\le 5\cdot10^4$ | 无 | 29 | 2s |
| 7 | $\le 2\cdot10^6$ | 无 | 31 | 4s |

### 提示：

如果你不知道完全二叉树是什么意思，Ysuperman 提供了一个链接：[Link](https://zh.wikipedia.org/zh/%E4%BA%8C%E5%8F%89%E6%A0%91#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91)。

输入输出较大，请使用较快的输入输出方式。

如果您使用了所需栈空间较大的递归算法，可以在本地（NOI linux 下）先使用 ```sudo su``` 获取权限，再使用 ```ulimit -s unlimited ``` 命令开启无限栈。

题目并不难。

## 样例 #1

### 输入

```
5
1 2
2 3
3 4
4 5
```

### 输出

```
3
1
2
2
```

## 样例 #2

### 输入

```
7
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
1
2
4
```

## 样例 #3

### 输入

```
25
15 9
22 15
23 22
25 15
13 23
6 22
12 15
1 23
19 13
18 9
11 15
17 1
4 25
3 1
8 9
20 1
10 18
21 20
16 8
2 22
24 1
7 19
5 16
14 7
```

### 输出

```
17
1
1
1
1
1
1
1
1
1
1
2
2
2
2
2
2
3
```

# AI分析结果



## 算法分类
树的重心、哈希

---

## 综合分析与结论

### 核心思路
1. **重心定位**：通过两次DFS找到树的重心，嫁接操作对重心的子树结构影响最大。
2. **子树大小分析**：嫁接叶子后，仅特定路径上的节点最大子树大小不变。
3. **哈希统计**：利用双哈希编码每个节点的权值变化，通过哈希表统计不同品种的出现次数。

### 难点与解决方案
- **高效统计权值变化**：通过树形DP预处理最大子树大小，仅需遍历重心相关路径。
- **哈希冲突避免**：采用双模数哈希（mod1=1e9+9, mod2=998244853）和双底数（B1=114514, B2=11037）。
- **多重心处理**：对每个重心单独处理，并在哈希时合并结果。

### 可视化设计
- **树结构展示**：Canvas绘制树形结构，红色节点表示重心，绿色表示当前嫁接点。
- **动态权值变化**：嫁接操作时，路径外节点变为黄色（权值+1），路径内保持原色。
- **哈希值生成动画**：路径遍历时，每个节点的权值以像素块形式叠加到哈希值显示区，底部实时显示双哈希结果。
- **复古音效**：路径遍历时播放8-bit音效，哈希碰撞时播放成功音效。

---

## 题解清单（≥4星）

### 题解1（4.5星）
- **亮点**：针对链、菊花图等特殊情况的优化处理，代码简洁高效。
- **核心代码**：
```cpp
// 链式处理
write((n+1)/2); 
for(int i=1;i<=n/2;i++) write(2);
```

### 题解2（5星）
- **亮点**：双哈希+动态路径维护，完美处理多重心问题。
- **关键代码**：
```cpp
Hashnum t=hs - Hashnum(pw1[mxs[v]+1],pw2[mxs[v]+1]) 
           + Hashnum(pw1[mxs[v]],pw2[mxs[v]]);
++mp[t];
```

### 题解3（4星）
- **亮点**：区间标记+哈希统计，适合大数据量。
- **技巧**：使用前缀异或维护区间修改，O(1)时间完成哈希更新。

---

## 最优思路代码实现
```cpp
// 核心代码：双哈希路径维护
void redfs(int u, int fa, int rt) {
    int tt1 = t1, tt2 = t2;
    t1 = (1ll * t1 * B1 + mxsz[u]) % mod1;
    t2 = (1ll * t2 * B2 + mxsz[u]) % mod2;
    addh(t1, t2); // 哈希表记录当前路径哈希
    
    for(int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if(v == fa || v == rt) continue;
        if(n - sz[v] == mxsz[rt]) // 进入重子树时重置哈希
            t1 = t2 = 0;
        redfs(v, u, rt);
        if(n - sz[v] == mxsz[rt]) // 回溯时恢复哈希
            t1 = tt1, t2 = tt2;
    }
}
```

---

## 相似题目推荐
1. **P2634 [国家集训队]聪聪可可**（树的重心统计）
2. **P1364 医院设置**（节点权重动态计算）
3. **P5043 【模板】树同构**（树哈希应用）

---

## 个人心得摘录
- **调试经验**：初始使用单哈希被卡，改用双哈希后AC，验证了生日悖论的威力。
- **性能优化**：预处理哈希底数的幂次，将O(n log n)降为O(n)。

---

## 可视化算法演示
```html
<!DOCTYPE html>
<canvas id="tree" width="800" height="600"></canvas>
<script>
// 模拟树结构，红色节点为重心，绿色为嫁接点
const nodes = [
  {x:400,y:50, id:1, color:'red'}, 
  {x:300,y:150, id:2, color:'blue'},
  // ... 其他节点数据
];

function drawTree() {
  const ctx = document.getElementById('tree').getContext('2d');
  nodes.forEach(node => {
    ctx.fillStyle = node.color;
    ctx.fillRect(node.x, node.y, 20, 20); // 绘制节点
  });
}

// 嫁接动画：路径节点渐变为黄色
function animateGraft(path) {
  let i = 0;
  const timer = setInterval(() => {
    if(i >= path.length) clearInterval(timer);
    nodes[path[i]].color = 'yellow';
    drawTree();
    i++;
  }, 200);
}
</script>
```

---
处理用时：73.61秒
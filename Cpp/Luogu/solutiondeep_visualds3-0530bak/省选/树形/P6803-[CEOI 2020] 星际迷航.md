# 题目信息

# [CEOI 2020] 星际迷航

## 题目背景

原时空限制：0.2s，32m

## 题目描述

星际联邦由 $N$ 颗行星组成，分别编号为 $1 \sim N$。一些行星间由星际通道相连。通过这些星际通道，飞船可以在短时间内往返于各星球之间。整个星际联邦中恰好有 $N-1$ 条星际通道，并且通过这些星际通道，任意两颗行星之间均能相互抵达。

除了我们所处的宇宙之外，还有 $D$ 个平行宇宙，这些平行宇宙是我们的宇宙的完全复刻，它们的行星，星际通道都和我们的完全相同。我们将这些平行宇宙编号为 $1 \sim D$（我们的宇宙编号为 $0$），记第 $i$ 个宇宙的第 $x$ 颗行星为 $P_{x}^i$。通过星门，我们可以在这些平行宇宙间穿梭。$\forall i \in [0,D)$，我们将选择一个 $A_i$ 和一个 $B_i$（要求 $1 \leq A_i,B_i \leq N$），在 $P_{A_i}^i$ 和 $P_{B_i}^{i+1}$ 之间搭建一个**单向**（只能从 $P_{A_i}^i$ 前往 $P_{B_i}^{i+1}$）星门。

当所有的星门都准备就绪后，联邦星舰 Batthyány 号将会开始它的处女航，它目前正环绕着 $P_1^0$ 行星。Ágnes 舰长准备和 Gábor 中尉玩这样一个游戏：两个人交替选择星舰接下来前往的目的地，要求该目的地可以通过星际通道或星门直接抵达。他们希望每次前往的星球都是之前未抵达过的。即，如果星舰抵达了 $P_{x}^i$，他们将不再经过这个星球（但是可以抵达 $x$ 在其他平行宇宙中的相应星球）。由 Ágnes 舰长作为先手开始游戏，Gábor 中尉作为后手，当一位玩家在他的回合中，不能选择一个合法的目的地时，他就输掉了游戏。

舰长和中尉都是绝对聪明的，他们知道所有星际通道和星门的排布方案，并且他们每次都按照最优方案行动。你需要求出，有多少种布置星门的方案，使得作为先手的 Ágnes 舰长必胜？两种布置星门的方案是不同的，当且仅当存在一个整数 $i$，使得 $A_i$ 或 $B_i$ 不同。

## 说明/提示

### 样例解释

共有 $3 \times 3=9$ 种本质不同的布置星门的方案，下面列出四种舰长必胜的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/vblsc4g6.png)

### 子任务

所有数据均满足：$1 \leq N \leq 10^5$，$1 \leq D \leq 10^{18}$，$1 \leq u,v \leq N$。

各子任务的约束条件如下：

| 子任务编号 | 分值 | 约束                         |
| ---------- | ---- | ---------------------------- |
| $1$        | $0$  | 样例                         |
| $2$        | $7$  | $N=2$                        |
| $3$        | $8$  | $N \leq 100$，$D=1$          |
| $4$        | $15$ | $N \leq 1000$，$D=1$         |
| $5$        | $15$ | $D=1$                        |
| $6$        | $20$ | $N \leq 1000$，$D \leq 10^5$ |
| $7$        | $20$ | $D \leq 10^5$                |
| $8$        | $15$ | 无特殊约束                   |

## 样例 #1

### 输入

```
3 1
1 2
2 3```

### 输出

```
4```

# AI分析结果



# 算法分类
**换根DP与矩阵快速幂**

---

## 题解思路与核心难点

### 核心思路
1. **胜负状态判断**：  
   每个节点的胜负状态由其子节点决定。若存在必败子节点，当前节点必胜；否则必败。树形DP可快速计算。

2. **换根DP计算翻转贡献**：  
   - 定义 `R[u]` 表示以 `u` 为根时，通过连接必败点改变其胜负状态的方案数。
   - 通过两次DFS（先子树后全局）计算每个节点的 `R[u]`，处理父子节点状态传递。

3. **矩阵快速幂优化多层结构**：  
   - 将每层树的胜负贡献抽象为矩阵元素，利用矩阵乘法表示状态转移。
   - 通过快速幂处理指数级层数 `D`，时间复杂度降至 `O(log D)`。

### 解决难点
- **换根DP的复杂状态转移**：需维护每个节点在不同根下的必败子节点数及翻转贡献，通过分类讨论和动态维护实现高效计算。
- **多层结构的数学抽象**：将每层的胜负贡献转化为矩阵元素，通过矩阵乘法实现状态迭代，避免逐层计算。

---

## 题解评分（≥4星）

### 滑蒻稽（4.5星）
- **亮点**：代码结构清晰，换根DP与矩阵快速幂结合紧密，核心变量 `R[u]` 设计巧妙。
- **关键代码**：
  ```cpp
  void dfs1(int u, int f) {
    for (int v : g[u]) {
      if (v == f) continue;
      dfs1(v, u);
      s0[u] += !dp[v];
      SR[u][dp[v]] += R[v];
    }
    dp[u] = (s0[u] > 0);
    if (s0[u] == 1) R[u] = SR[u][0];
    else if (s0[u] == 0) R[u] = SR[u][1] + 1;
  }
  ```

### s_r_f（4星）
- **亮点**：详细推导状态转移方程，矩阵系数计算严谨，适合深入理解。
- **个人心得**：  
  > “注意实现时的空间！！！不建议使用vector存图/map存DP结果。”

### Green_White（4星）
- **亮点**：代码简洁，矩阵快速幂部分优化到位，适合快速实现。
- **关键代码**：
  ```cpp
  Matrix operator*(const Matrix &a, const Matrix &b) {
    Matrix c;
    for (int i = 0; i < 2; i++)
      for (int j = 0; j < 2; j++)
        c.a[i][j] = ((ll)a.a[i][0] * b.a[0][j] + (ll)a.a[i][1] * b.a[1][j]) % mod;
    return c;
  }
  ```

---

## 最优思路与技巧提炼

### 关键技巧
1. **换根DP的动态维护**：  
   - 第一次DFS计算子树贡献，第二次调整父节点贡献，通过 `SR[u][0/1]` 分别记录必败/必胜子节点的 `R` 值和。
   - 分类讨论必败子节点数（0、1、≥2），动态更新 `R[u]`。

2. **矩阵状态压缩**：  
   - 将每层树的贡献抽象为 `f0`（必败点贡献）和 `f1`（必胜点贡献），通过矩阵乘法实现状态迭代：
     ```
     |f0'|   |A B|   |f0|
     |f1'| = |C D| * |f1|
     ```
   - 矩阵元素 `A, B, C, D` 由全局换根DP结果计算得到。

---

## 类似题目推荐
1. **P3177 [HAOI2015] 树上染色**（换根DP与贡献计算）
2. **P3047 [USACO12FEB] Nearby Cows**（树形DP与多层状态）
3. **P3390 【模板】矩阵快速幂**（矩阵快速幂基础）

---

## 算法可视化设计

### 核心流程动画
1. **树形DP过程**：  
   - **颜色标记**：红色表示必败节点，绿色表示必胜节点。
   - **高亮路径**：DFS递归路径，动态显示每个节点 `dp[u]` 和 `R[u]` 的计算过程。

2. **换根DP调整**：  
   - **动态箭头**：显示从父节点到子节点的根切换，实时更新 `R[u]` 值。
   - **数值浮动**：在节点旁显示 `s0[u]` 和 `SR[u][0/1]` 的变化。

3. **矩阵快速幂迭代**：  
   - **矩阵元素高亮**：每次矩阵乘法时，高亮参与计算的元素对（如 `A*B` 的行列）。
   - **指数分解**：以二进制形式展示指数 `D`，动态显示快速幂的位分解过程。

### 复古像素风格实现
- **Canvas绘制**：  
  - 使用 `16x16` 像素网格表示树节点，绿色方块表示必胜，红色表示必败。
  - 星门连接用闪烁的黄色像素线表示，每层宇宙用不同背景色区分。
- **音效设计**：  
  - **节点翻转**：播放8-bit“哔”声。
  - **矩阵乘法**：触发电子合成音效，不同元素对对应不同音高。
- **自动演示模式**：  
  - 按空格键暂停/继续，方向键控制单步执行。
  - AI自动模式下，算法路径以“贪吃蛇”式移动，自动遍历关键节点。

---

## 核心代码片段（换根DP + 矩阵）
```cpp
// 换根DP计算R[u]
void dfs2(int u, int fa) {
  for (int v : g[u]) {
    if (v == fa) continue;
    // 临时保存状态
    int s0u = s0[u], dpu = dp[u], Ru = R[u];
    int SRu0 = SR[u][0], SRu1 = SR[u][1];
    
    // 调整父节点状态
    s0[u] -= !dp[v];
    dp[u] = (s0[u] > 0);
    SR[u][dp[v]] -= R[v];
    
    // 计算新R[u]
    if (s0[u] == 1) R[u] = SR[u][0];
    else if (s0[u] == 0) R[u] = SR[u][1] + 1;
    else R[u] = 0;
    
    // 递归子节点
    dfs2(v, u);
    
    // 恢复状态
    s0[u] = s0u; dp[u] = dpu; 
    R[u] = Ru; SR[u][0] = SRu0; SR[u][1] = SRu1;
  }
}

// 矩阵快速幂计算最终答案
mat fpm(mat a, ll b) {
  mat res(true);
  while (b) {
    if (b & 1) res = res * a;
    a = a * a; b >>= 1;
  }
  return res;
}
```

---
处理用时：80.35秒
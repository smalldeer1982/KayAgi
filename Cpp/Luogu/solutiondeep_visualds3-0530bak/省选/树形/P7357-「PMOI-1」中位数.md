# 题目信息

# 「PMOI-1」中位数

## 题目描述

给定一棵以 $1$ 为根的包含 $n$ 个节点的**有根树**。第 $i$ 个节点有点权 $a_i$。

定义函数 $f(u,v)$ 表示从 $u$ 到 $v$ 经过的所有节点的点权的**可重集**的中位数。

请注意，**本题中的中位数的定义与数学中的定义略有不同**：这里一个长度为 $t$ 的序列的中位数定义为这个序列第 $\left\lceil\frac{t+1}2\right\rceil$ 小的数。

定义函数 $\text{cover}(x_1,y_1,x_2,y_2)$ 表示从 $x_1$ 到 $y_1$ 的路径是否完全覆盖了从 $x_2$ 到 $y_2$ 的路径。如果完全覆盖，则 $\text{cover}(x_1,y_1,x_2,y_2)=1$，否则 $\text{cover}(x_1,y_1,x_2,y_2)=0$。

你需要依次处理 $q$ 次操作，按照以下格式给出：

`1 u`：表示一次操作，需要你将点 $u$ 的点权对 $1$ **异或**；

`2 u v`：表示一次询问，需要你求出 $\max\limits_{1\le i\le n,1\le j\le n}\{\text{cover}(i,j,u,v)f(i,j)\}$。

对于第二类操作，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

你需要对于每个第二类操作，输出对应的值。

## 说明/提示

【样例解释】

第一次是询问。显然，只有 $(i=4,j=8)$ 满足 $\text{cover}(i,j,u,v)=1$。此时 $f(i,j)=3$。

第二次是操作。将 $3$ 号节点的点权改为了 $2$。

第三次是询问。当 $i=4,j=3$ 时，$\text{cover}(i,j,u,v)=1$ 且 $f(i,j)=4$。不难发现，对于其他所有满足 $\text{cover}(i,j,u,v)=1$ 的节点对 $(i,j)$，均没有 $f(i,j)>4$。

【数据范围】
- Subtask 1（8 pts）：$n,q\le50$；
- Subtask 2（12 pts）：$n,q\le2\times10^3$；
- Subtask 3（16 pts）：$n,q\le4\times10^4$；
- Subtask 4（10 pts）：保证树的形态随机生成；
- Subtask 5（12 pts）：保证没有 $1$ 操作；
- Subtask 6（12 pts）：保证每次询问的 $u,v$ 都是叶子节点；
- Subtask 7（30 pts）：无特殊限制。

Subtask 4 的随机方式为：随机生成一个的排列 $p$，对于 $i\in[2,n]$，$p_i$ 向 $p_1,p_2,...,p_{i-1}$ 中等概率随机的一个点连边。

对于 $100\%$ 的数据满足，$1\le n,q,a_i \le 10^5$，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

## 样例 #1

### 输入

```
8 3
4 2 3 4 2 1 4 3
1 2
1 3
2 4
2 5
3 6
6 7
6 8
2 4 8
1 3 
2 2 3```

### 输出

```
3
4```

# AI分析结果



## 唯一算法分类
**主席树（可持久化线段树）与树上路径处理**

---

## 综合分析与结论

### 题解思路与核心难点
1. **问题拆解**  
   - 目标：寻找覆盖路径 `u-v` 的所有路径中的最大中位数。  
   - 难点：路径覆盖条件、动态修改点权、高效计算中位数。  

2. **关键思路**  
   - **二分答案**：利用中位数的单调性，二分最大值 `mid`，检查是否存在路径满足条件。  
   - **键值转换**：将 `>= mid` 的点设为 `1`，否则 `-1`。路径和 `>= 0` 时 `mid` 有效。  
   - **路径分解**：覆盖 `u-v` 的路径必须从 `u` 的子树出发到 `v` 的子树，拆分为三段处理。  
   - **主席树维护**：对每个 `mid` 维护子树最大前缀和，通过标记永久化处理区间修改。  

3. **优化与实现**  
   - **标记永久化**：高效处理区间加减操作的历史版本。  
   - **离散化与动态调整**：修改点权时仅调整受影响的 `mid` 版本。  

---

## 题解清单 (≥4星)
1. **Y_B_X的题解（4.5星）**  
   - **亮点**：  
     - 详细推导中位数性质与键值转换逻辑。  
     - 代码清晰，利用 `dfs` 序和主席树实现子树区间操作。  
     - 处理修改时精准定位受影响的版本，降低时间复杂度。  
   - **引用**：  
     > "由于异或 1 后一个点的点权要么变大一，要么减小一。设 `t_x=2⌊x/2⌋+1`，受改动的版本仅有 `t_x` 一个。"

2. **ducati的题解（4星）**  
   - **亮点**：  
     - 明确分阶段处理路径和前缀和。  
     - 类比经典问题，强化思路迁移。  
   - **引用**：  
     > "每次修改后点权只会增加或减少 1，所以主席树只需调整少量版本。"

---

## 最优思路与技巧提炼
### 核心技巧
1. **二分答案的单调性利用**  
   - 将最大中位数问题转化为可行性检查。  
2. **键值转换与区间和优化**  
   - 将点权转换为 `±1`，路径和直接反映中位数可行性。  
3. **主席树动态维护子树信息**  
   - 通过 `dfs` 序将子树映射为连续区间，支持高效查询与修改。  
4. **标记永久化处理历史版本**  
   - 避免重复下传标记，节省空间与时间。  

### 同类型题与套路
- **相似问题**：区间中位数最大值（如 [P2839](https://www.luogu.com.cn/problem/P2839)）。  
- **通用套路**：二分答案 + 权值转换 + 数据结构维护区间性质。  

---

## 推荐洛谷题目
1. **P2839 [国家集训队]middle**  
   - 中位数最大值问题，类似键值转换与二分思路。  
2. **P2617 Dynamic Rankings**  
   - 动态区间第 K 大，主席树应用经典。  
3. **P3302 [SDOI2013]森林**  
   - 树上路径查询与动态加边，结合主席树与启发式合并。  

---

## 可视化与算法演示设计
### 动画方案
1. **二分过程演示**  
   - 高亮当前 `mid`，展示键值分布（`1` 绿色，`-1` 红色）。  
2. **路径分解与子树查询**  
   - 用不同颜色标记 `u` 和 `v` 的子树区域，动态绘制路径分段。  
3. **主席树区间更新**  
   - 显示 `dfs` 序区间加减操作，对比不同 `mid` 版本的线段树差异。  

### 复古像素风格
- **颜色方案**：8-bit 调色板（绿/红表示键值，黄/蓝表示路径）。  
- **音效**：  
  - 键值翻转时播放 8-bit 音效。  
  - 二分成功/失败时触发不同音调。  
- **Canvas 动画**：网格化树结构，路径绘制为像素方块移动。  

---

## 代码核心逻辑
```cpp
// 主席树区间更新（标记永久化）
void update(int &k, int kk, int l, int r, int x, int y, int v) {
    k = ++tot; t[k] = t[kk];
    if (x <= l && r <= y) {
        t[k].tag += v;
        t[k].mx += v;
    } else {
        int mid = (l + r) >> 1;
        if (x <= mid) update(t[k].l, t[kk].l, l, mid, x, y, v);
        if (mid < y) update(t[k].r, t[kk].r, mid + 1, r, x, y, v);
        t[k].mx = max(t[t[k].l].mx, t[t[k].r].mx) + t[k].tag;
    }
}

// 二分检查函数
bool check(int mid, int u, int v, int l) {
    int sum = 0;
    sum += query_max(rt[mid], 1, n, dfn[u], dfn[u] + sz[u] - 1);
    sum += query_max(rt[mid], 1, n, dfn[v], dfn[v] + sz[v] - 1);
    sum -= 2 * query_val(rt[mid], dfn[l]);
    sum += (a[l] >= b[mid] ? 1 : -1);
    return sum >= 0;
}
```

完整代码见原题解。

---
处理用时：79.87秒
# 题目信息

# 「C.E.L.U-03」100%不公平的游戏

## 题目背景

今天 ice 出去玩了。原准备与 Alice 玩游戏的 Bob 只能和 Al 玩一场博弈游戏。

## 题目描述

这个游戏是在树上进行的。Bob 先手。Bob 和 Al 轮流进行以下操作，首先无法操作者判负。

- 在树上标记一条未被标记过的边。满足在每一次操作之后，存在一条简单路径遍历所有标记过的边。注意：这条简单路径**可以经过未标记过的边**。

如果给定的树对于 Bob 有必胜方案，输出 `Play now`，否则输出 `Restart`。

## 说明/提示

**样例数据也可见附件** $\textbf{\textit{game.in}/\textit{game.out}}$。

### 样例解释 1

**第一组数据：**

先手选择边 $(2,5)$ 必胜：  
若后手选择 $(1,2)$，先手选择 $(5,6)$ 可以获胜。  
若后手选择 $(2,3)$，先手选择 $(5,9)$ 可以获胜。  
若后手选择 $(3,4)$，先手选择 $(5,9)$ 可以获胜。  
若后手选择 $(5,6)$，先手选择 $(1,2)$ 可以获胜。  
若后手选择 $(5,9)$，先手选择 $(3,4)$ 可以获胜。  
若后手选择 $(7,9)$，先手选择 $(2,3)$ 可以获胜。  
若后手选择 $(8,9)$，先手选择 $(3,4)$ 可以获胜。  
综上，无论后手选那一条边，都不会获得胜利。  

**第二组数据：**

先手不存在必胜策略：  
若先手选择 $(1,2)$，后手选择 $(2,3)$ 获胜。  
若先手选择 $(2,3)$，后手选择 $(1,2)$ 获胜。


### 样例解释 2

各组数据详见下图，其中前两组数据与样例一相同。

![](https://cdn.luogu.com.cn/upload/image_hosting/imht95gt.png)

---

### 数据范围

$2\leq n\leq5\times10^5$

$1\leq T\leq10^4$

$\sum n\leq1.5\times10^6$

数据保证给定的图是一棵树。

### 子任务  
1. （8分）$n\leq6$。
2. （18分）$n\leq12,T\leq10$。
3. （6分） $n\leq28,T\leq10$。
4. （8分）$n\leq200,T\leq10$。
5. （30分）$n\leq2000,T\leq10$。
6. （6分）最多存在两个节点度数大于 $2$。
7. （12分）树的形态是一棵完全二叉树。
8. （12分）无特殊性质。

## 样例 #1

### 输入

```
2
9
9 5
2 1
9 8
3 2
5 6
7 9
4 3
5 2
3
1 2
2 3```

### 输出

```
Play now
Restart```

## 样例 #2

### 输入

```
附加两组样例详见
https://www.luogu.com.cn/paste/b6mh7ido```

### 输出

```
附加两组样例详见
https://www.luogu.com.cn/paste/b6mh7ido```

# AI分析结果



---

**算法分类**：博弈论（SG函数）与树形DP

---

### **题解思路与算法要点**

#### **核心问题建模**
- **关键观察**：每次操作后标记的边必须构成一条简单路径，等价于所有标记边必须在某条链上。游戏可分解为多个子树游戏的和。
- **SG定理应用**：将树结构转换为多个子游戏的SG值异或，判断是否存在初始边使得异或和为0。

#### **核心算法流程**
1. **SG值计算**  
   定义 `sg[x]` 为以 `x` 为根的子树对应的SG值。计算规则：  
   $$sg(x) = \text{mex}\{ sg(v) \oplus (dep_v - dep_x - 1) \bmod 2 \}$$  
   其中 `v` 是 `x` 的子节点，`dep` 表示深度。

2. **换根动态规划**  
   - 第一次DFS预处理每个节点的SG值及子树的集合。  
   - 第二次DFS动态调整根节点，计算是否存在一条边分割后的SG异或和为0。

#### **解决难点**
- **高效集合维护**：VinstaG173使用 `bitset` 加速集合操作，幻影星坚强通过统计最大值/次大值避免显式集合存储。
- **换根优化**：通过前缀/后缀集合合并（VinstaG173）或动态调整父-子统计信息（幻影星坚强）实现O(n)换根。

---

### **题解评分与亮点**

#### **VinstaG173题解（★★★★☆）**
- **亮点**：  
  - 使用 `bitset` 高效维护SG集合，理论时间复杂度最优。  
  - 换根时通过前缀/后缀分离集合，实现O(1)合并。  
- **代码难点**：`bitset` 操作和前缀/后缀分离逻辑较复杂。

#### **幻影星坚强题解（★★★★☆）**
- **亮点**：  
  - 通过分析SG值的奇偶性推导递推公式，避免显式集合操作。  
  - 换根时动态调整统计信息，代码逻辑更直观。  
- **代码难点**：维护最大值、次大值及其计数需要细致处理。

---

### **最优思路提炼**
- **关键技巧**：将链的SG值简化为长度的奇偶性，利用异或性质合并子游戏。
- **实现优化**：  
  1. **SG递推式**：`sg(x) = max_child_sg ^ 1`（若最大值唯一且次大值不足），避免集合运算。  
  2. **换根策略**：预处理子树统计信息，动态调整父节点贡献。

---

### **同类型题与算法套路**
- **常见题型**：树上博弈、分割链/子树求SG值异或和。  
- **通用解法**：  
  - 将树分解为链和子树，递归计算SG值。  
  - 换根DP处理动态根切换问题。

---

### **推荐题目**
1. **P3182 [HAOI2016]放棋子**（树上博弈与SG函数）  
2. **P2146 [NOI2015]软件包管理器**（树链操作与动态维护）  
3. **P3384 【模板】轻重链剖分**（树结构分解与动态统计）

---

### **可视化与算法演示**

#### **核心算法动画设计**
- **树遍历与SG计算**：  
  - 初始根节点为红色，子节点递归展开为蓝色。  
  - 每个节点显示当前计算的SG值，动态更新颜色（绿色=0，黄色=1，橙色≥2）。  
- **换根过程**：  
  - 点击边触发换根，旧根变灰，新根高亮。  
  - 显示父节点统计信息如何传递到子节点。

#### **复古像素风格实现**
- **Canvas绘制**：  
  - 节点为8x8像素方块，边为灰色线条。  
  - SG值以1~2像素字体显示在节点右侧。  
- **音效设计**：  
  - 计算SG值时播放“滴”声，换根时播放“咔”声。  
  - 找到必胜策略时播放8-bit胜利音效。

#### **交互功能**
- **步进控制**：空格键单步执行DFS。  
- **自动演示**：AI模式自动遍历所有可能初始边，标记必胜边为闪烁绿色。

---

### **代码实现（关键片段）**

#### **VinstaG173的换根逻辑**
```cpp
void dfs2(int u, int f, bitset<40> tS0, bitset<40> tS1) {
    if(f) {
        int tsg = (~tS0)._Find_first();
        if(tsg == sg[u]) ans = 1; // 找到必胜策略
        // 更新集合传递到子节点
    }
    for (int v : e[u]) {
        if (v == f) continue;
        dfs2(v, u, tS1 | lS[v][0] | rS[v][0], tS0 | lS[v][1] | rS[v][1]);
    }
}
```

#### **幻影星坚强的SG递推**
```cpp
void dfs1(int o, int from) {
    // 统计子节点最大值/次大值
    for (int to : e[o]) {
        if (to == from) continue;
        dfs1(to, o);
        update_max_stats(sg[to]); // 更新最大值、次大值
    }
    // 根据规则计算sg[o]
    if (max_unique_and_valid) sg[o] = max_val + 1;
    else sg[o] = (max_count > 0) ? max_val ^ 1 : 0;
}
```

---

### **个人心得摘录**
- **VinstaG173**：  
  > “不要只用脑子想，最好用草稿纸，否则调死我了” → 强调纸上推导对复杂逻辑的重要性。  
- **幻影星坚强**：  
  > “分析SG值的奇偶性后，发现可以避免集合操作” → 对问题性质的深入理解是关键突破点。

---

**结论**：问题转化为树形SG值计算与换根判断，核心在于高效维护子游戏异或和。两种解法均达到线性复杂度，适用于大规模数据。

---
处理用时：79.89秒
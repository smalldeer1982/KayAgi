# 题目信息

# [福建省队集训2019] 最大权独立集问题

## 题目描述

E.Space 喜欢出最大权独立集问题。

接下来，他还想出 $n$ 道最大权独立集问题。

E.Space 有 $n$ 个 AI，编号为 $1\sim n$。

开始第 $i$ 个 AI 里面存有一道 E.Space 事先出好的一道难度为 $d_i$ 的最大权独立集问题。

有些 AI 之间可以互相通信，对于所有的 $2 \le i \le n$，第 $i$ 个 AI 可以和第 $c_i$ 个 AI 互相通信。此外，其他对 AI 不可以互相通信。

E.Space 每次可以选择一个存有一道最大权独立集问题的 AI，把存在里面的题出出来，然后清除存在这个 AI 里的题。

在 E.Space 出题之后清除题目之前，AI 会把这道题发给能和它通信的所有 AI。

如果一个收到这道题的 AI 中已经存有一道最大权独立集问题，那么这个 AI 会把这个收到的题和原本存有的题结合起来，变成一道新的最大权独立集问题存起来。形式化地，如果这个 AI 原来存了一道难度为 $x$ 的最大权独立集问题，接着收到了一道难度为 $y$ 的最大权独立集问题，那么结合之后是一道难度为 $x+y$ 的最大权独立集问题。

如果一个收到题的 AI 中未存有题，那么这个 AI 会销毁收到的这个信息。

由于出题人的丧病心理，E.Space 想要出出来的 $n$ 道最大权独立集问题的难度之和尽量大。

他想叫你帮他解决这个问题，还说如果你成功在这场训练中解决了这个问题，那么在出那 $n$ 道最大权独立集问题的时候，他会在训练结束前 10 分钟切换至你的账号然后提交一份标程代码。

## 说明/提示

### 【样例解释 1】

一种最优的出题方案如下：

1. 出第 $2$ 个 AI 中的最大权独立集问题，此时该题难度为 $10$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $11,*,13,5$ ($*$ 表示该 AI 中没有最大权独立集问题，下同)。

2. 出第 $3$ 个 AI 中的最大权独立集问题，此时该题难度为 $13$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $11,*,*,18$。

3. 出第 $1$ 个 AI 中的最大权独立集问题，此时该题难度为 $11$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,18$。

4. 出第 $4$ 个 AI 中的最大权独立集问题，此时该题难度为 $18$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,*$。

所以 $4$ 道题的难度之和为 $10+13+11+18=52$。

### 【样例解释 2】

一种最优的出题方案如下：

1. 出第 $3$ 个 AI 中的最大权独立集问题，此时该题难度为 $5$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $1,3,*,5$。

2. 出第 $4$ 个 AI 中的最大权独立集问题，此时该题难度为 $5$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $1,8,*,*$。

3. 出第 $2$ 个 AI 中的最大权独立集问题，此时该题难度为 $8$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $9,*,*,*$。

4. 出第 $1$ 个 AI 中的最大权独立集问题，此时该题难度为 $9$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,*$。

所以 $4$ 道题的难度之和为 $5+5+8+9=27$。

### 【数据范围】

保证 $\left|d_i\right| \le 10^9$，$1 \le c_i \lt i$，$1\le n \le 400$。

**本题采用捆绑测试。**

对于编号为奇数的子任务，保证 $d_i \ge 0$。

子任务 $1,2$（$11 \times 2 = 22$ 分）：
$n \le 9$。

子任务 $3,4$（$10 \times 2 = 20$ 分）：
$n \le 19$。

子任务 $5,6$（$7 \times 2 = 14$ 分）：
$n \le 50$，$c_i = i-1$。

子任务 $7,8$（$10 \times 2 = 20$ 分）：
$c_i=i-1$。

子任务 $9,10$（$5 \times 2 = 10$ 分）：
$n \le 50$。

子任务 $11,12$（$7 \times 2 = 14$ 分）：
无特殊限制。

### 后记

听说 E.Space 的最大权独立集问题的难度是取了对数的？

听说 E.Space 要把这 $n$ 道题结合成一道题出出来？

听说 E.Space 不会把这些题出在训练里面？



## 样例 #1

### 输入

```
4
1 10 3 5
1 2 3
```

### 输出

```
52
```

## 样例 #2

### 输入

```
4
1 -2 5 5
1 2 2
```

### 输出

```
27
```

# AI分析结果



---

## **算法分类**
树形动态规划（树形DP）

---

## **题解思路与算法要点**
### **核心思路**
将节点的删除顺序转化为边定向问题，每个节点的贡献次数等于其可达节点数。通过树形DP记录子树内外的可达点数，最大化总贡献。

### **解决难点**
1. **贡献传递模型**  
   删除顺序决定边方向，每个节点贡献会传递到后续节点。需转化为可达点计数问题。
   
2. **状态设计**  
   多数题解采用三维状态 `f[u][i][j]`，表示以 `u` 为根的子树中，`u` 可达 `i` 个点（子树内 `j` 个，子树外 `i-j` 个）时的最大贡献。通过枚举子树合并时的边方向（父→子或子→父）进行状态转移。

3. **复杂度优化**  
   - **滚动数组**：使用临时数组避免覆盖当前状态（如 Llx2022 的 `tmp` 数组）。  
   - **子树大小剪枝**：合并子树时仅枚举可能的 `i,j` 范围（如 `sz[u]` 和 `sz[v]`）。

### **关键对比**
| 题解作者 | 状态设计 | 转移方程特点 | 贡献计算方式 |
|---------|---------|-------------|-------------|
| Llx2022 | `f[u][i][j]`：u 子树总可达 i，其中 j 个在子树内 | 分父→子（累加子贡献）和子→父（外延贡献） | 合并时补算 `(i-j)*d[u]` |
| Elma_   | `f[u][i][k]`：u 子树内可达 i 个，外延贡献按 k 计算 | 预计算外延贡献 `k*d_u` | 初始值直接包含外延贡献 |
| Leasier | `h[u][i][j]`：子树内 i，总 j 个可达 | 拆分为 `f`（父→子）和 `g`（子→父） | 合并时显式处理内外贡献 |

---

## **题解评分（≥4星）**
1. **Llx2022（★★★★☆）**  
   - 思路清晰，状态转移分两类讨论  
   - 代码结构明确，使用临时数组避免覆盖  
   - 时间复杂度严格 O(n³)

2. **Elma_（★★★★☆）**  
   - 状态设计简洁，初始值预计算外延贡献  
   - 转移方程高效，直接枚举 `j+k`  
   - 代码可读性强，无冗余循环

3. **Leasier（★★★☆☆）**  
   - 状态拆分 `f/g` 增加理解难度  
   - 转移方程较复杂，但优化了部分枚举  
   - 代码实现稍显冗长

---

## **最优思路提炼**
### **核心技巧**
1. **贡献预计算**  
   在状态合并前计算可能的外延贡献（如 `k*d_u`），避免后续重复计算。
   
2. **子树合并剪枝**  
   根据子树大小限制循环范围（如 `sz[u]` 和 `sz[v]`），将复杂度从 O(n⁴) 降至 O(n³)。

3. **方向分治**  
   对每条边分父→子和子→父两种情况独立处理，确保所有可能的贡献路径被覆盖。

### **代码片段（Llx2022 核心转移）**
```cpp
// 合并子树 v 到 u 的状态
for (int i=1; i<=n; i++) {
    for (int j=1; j<=sz[u] && j<=i; j++) {
        // 方向 u→v：累加子树 v 的贡献
        for (int k=1; k<=sz[v] && j+k<=i; k++) {
            f[u][i][j+k] = max(f[u][i][j+k], tmp[i][j] + f[v][k][k] + k*d[u]);
        }
        // 方向 v→u：外延贡献到父节点
        for (int k=1; k<=sz[v]; k++) {
            f[u][i][j] = max(f[u][i][j], tmp[i][j] + f[v][i+k][k]);
        }
    }
}
```

---

## **同类题目推荐**
1. **P2015 二叉苹果树**  
   - 树形DP经典问题，保留树枝的最大苹果数。

2. **P2585 三色二叉树**  
   - 树形DP处理节点染色与相邻约束。

3. **P3177 树上染色**  
   - 通过子树合并计算边贡献，类似本题的贡献传递模型。

---

## **可视化设计**
### **动画方案**
1. **树结构展示**  
   - 使用 Canvas 绘制树形结构，节点显示当前 `d[i]` 和贡献次数 `cnt[i]`。
   - **高亮当前操作**：合并子树时，用红色边框标记当前处理的父子边。

2. **状态转移演示**  
   - 左侧面板显示 `f[u][i][j]` 的数值表，右侧展示树结构。
   - 每次转移时，动态更新表格并显示转移方向（如箭头从父指向子或相反）。

3. **音效与交互**  
   - **音效触发**：成功转移时播放 "blip" 音效，找到更优解时播放 "coin" 音效。
   - **步进控制**：支持暂停/继续、单步执行、调整动画速度。

### **复古像素风格**
- **调色板**：16色 FC 风格，绿色表示正权值，红色表示负权值。
- **节点动画**：合并子树时，子节点向父节点收缩并显示 "+d" 的像素文字特效。
- **自动演示**：AI 按最优路径自动执行，用闪烁箭头提示当前边方向选择。

---

## **代码实现（Elma_ 题解）**
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
constexpr int N = 4e2 + 5;
int n, a[N], c[N], sz[N];
LL f[N][N][N];
vector<int> e[N];

void dfs(int u) {
    sz[u] = 1;
    memset(f[u], 0x80, sizeof(f[u]));
    for (int k=1; k<=n; k++) f[u][1][k] = 1LL * a[u] * k;
    
    for (int v : e[u]) {
        dfs(v);
        LL tmp[N][N];
        memset(tmp, 0x80, sizeof(tmp));
        for (int i=1; i<=sz[u]; i++) 
            for (int k=1; k<=n; k++) 
                tmp[i][k] = f[u][i][k];
                
        memset(f[u], 0x80, sizeof(f[u]));
        for (int i=1; i<=sz[u]; i++) {
            for (int k=1; k<=n; k++) {
                // 方向 u→v
                for (int j=1; j<=sz[v]; j++) {
                    if (i+j <=n && k <=n)
                        f[u][i+j][k] = max(f[u][i+j][k], tmp[i][k] + f[v][j][j]);
                }
                // 方向 v→u
                LL val = -1e18;
                for (int j=1; j<=sz[v] && j+k<=n; j++)
                    val = max(val, f[v][j][j+k]);
                if (val != -1e18)
                    f[u][i][k] = max(f[u][i][k], tmp[i][k] + val);
            }
        }
        sz[u] += sz[v];
    }
}

int main() {
    cin >> n;
    for (int i=1; i<=n; i++) cin >> a[i];
    for (int i=2; i<=n; i++) cin >> c[i], e[c[i]].push_back(i);
    
    dfs(1);
    LL ans = -1e18;
    for (int i=1; i<=n; i++) ans = max(ans, f[1][i][i]);
    cout << ans << "\n";
    return 0;
}
```

---

**核心逻辑**：  
- `f[u][i][k]` 表示子树 `u` 内有 `i` 个可达点，外延贡献按 `k` 计算的最大值。
- 合并子树时，分方向处理并更新外延贡献，最终取根节点所有 `f[1][i][i]` 的最大值。

---
处理用时：108.44秒
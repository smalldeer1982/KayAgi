# 题目信息

# [_-0 B] 地铁

## 题目背景

小 $\mathfrak{f}$ 的家乡 A 市最近开通了地铁。

## 题目描述

A 市共有 $n (2\le n \le 10^5)$ 个居民点，第 $i$ 个居民点的人口为 $s_i (1 \le s_i \le 10^7)$，同时有 $n-1$ 条双向道路，构成一棵树，第 $i $ 条双向道路连接居民点 $u_i$ 和 $v_i$，人步行走过这条道路需要 $w_i (1 \le w_i\le 10^7)$ 的时间。

现 A 市政府决定开通一条地铁线路。地铁线路是树上的一条简单路径，若路径经过第 $i$ 条道路，那么地铁从这条道路下方经过只需要 $w_i^{\prime} (1 \le w_i^{\prime} \le 10^7)$ 的时间，同时，地铁的进出站**共**需要花费 $t (0 \le t \le 10^7)$ 的时间。

已知，若一个人从一个居民点前往另一个居民点，如果这条路径与地铁经过的路径有至少一条公共**边**，那么就**一定**会选择**尽可能多地**乘坐地铁。如果没有公共边，那么就会选择完全步行。**题目保证对于第 $i$ 条道路有 $w_i^{\prime} \le w_i - t$。** 我们认为，如果两个居民点的人口的乘积越大，那么有人想要在它们之间流动的可能性也越大。

现在，小 $\mathfrak{f}$ 想知道在所有 $\frac{n(n-1)}{2}$ 种建造地铁线路的方案中，$\sum_{a=1}^{n-1}\sum_{b=a+1}^{n}(s_a \cdot s_b \cdot d_{a,b})$ 的最小值，其中 $d_{a,b}$ 表示从居民点 $a$ 前往 $b$（或者从 $b$ 前往 $a$，两者是相等的）所需要的时间。

但是他不会，所以他来求助万能的你。

## 说明/提示

**样例 $1$ 解释：**

修建地铁前如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/3oh0y5mn.png)

一种最优的修建地铁的方案为从 $2$ 到 $3$ 修建地铁。如下图所示（实线表示修建了地铁）：

![](https://cdn.luogu.com.cn/upload/image_hosting/ian9c6po.png)

从 $1$ 到 $2$ 经过地铁，所需时间为：$6+0=6$，对答案的贡献为：$9\times9\times6=486$。

从 $1$ 到 $3$ 经过地铁，所需时间为：$5+0=5$，对答案的贡献为：$9\times3\times5=135$。

从 $1$ 到 $4$ 不经过地铁，所需时间为：$6$，对答案的贡献为：$9\times2\times6=108$。

从 $1$ 到 $5$ 经过地铁，所需时间为：$6+9+0=15$，对答案的贡献为：$9\times3\times15=405$。

从 $2$ 到 $3$ 经过地铁，所需时间为：$6+5+0=11$，对答案的贡献为：$9\times3\times11=297$。

从 $2$ 到 $4$ 经过地铁，所需时间为：$6+6+0=12$，对答案的贡献为：$9\times2\times12=216$。

从 $2$ 到 $5$ 不经过地铁，所需时间为：$9$，对答案的贡献为：$9\times3\times9=243$。

从 $3$ 到 $4$ 经过地铁，所需时间为：$5+6+0=11$，对答案的贡献为：$3\times2\times11=66$。

从 $3$ 到 $5$ 经过地铁，所需时间为：$5+6+9+0=20$，对答案的贡献为：$3\times3\times20=180$。

从 $4$ 到 $5$ 经过地铁，所需时间为：$6+6+9+0=21$，对答案的贡献为：$2\times3\times21=126$。

综上，答案为：$486+135+108+405+297+216+243+66+180+126=2262$。

可以证明不存在更优的修建地铁的方案。

**本题采用捆绑测试且使用子任务依赖。**

| 编号 | 分值 | $n \le$ | 性质 | 依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $0$ | N/A | 样例 | 无 |
| $1$ | $5$ | $10$ | 无 | 无 |
| $2$ | $5$ | $500$ | 无 | $1$ |
| $3$ | $10$ | $5000$ | 无 | $1,2$ |
| $4$ | $30$ | $10^5$ | A | 无 |
| $5$ | $5$ | $10^5$ | B | 无 |
| $6$ | $20$ | $10^5$ | C | 无 |
| $7$ | $15$ | $10^5$ | D | 无 |
| $8$ | $10$ | $10^5$ | 无 | $0,1,2,3,4,5,6,7$ |

特殊性质 A：$t=0$

特殊性质 B：$u_i=i,v_i=i+1$

特殊性质 C：每一个点的度数都不超过 $100$

特殊性质 D：$u_i=1,v_i=i+1$

## 样例 #1

### 输入

```
0 5 0
9
9
3
2
3
1 2 7 6
1 3 8 5
1 4 6 5
2 5 9 9```

### 输出

```
2262```

## 样例 #2

### 输入

```
0 10 86
50
6
84
50
83
67
93
55
93
70
1 2 94 7
1 3 97 4
1 10 98 12
2 4 89 1
2 7 98 1
4 5 99 13
4 6 96 5
5 8 95 5
5 9 97 7```

### 输出

```
33600416```

# AI分析结果



# 地铁问题分析与题解

## 算法分类
树形动态规划 + 斜率优化

---

## 题解思路与核心分析

### 核心思路
1. **贡献拆分**：将总时间减少量D拆分为边的贡献和点的贡献  
   - 边贡献：$(w-w'-t) \times S_1S_2$（S为边分割的子树权值和）
   - 点贡献：$t \times S_1S_3$（S为相邻边分割的三部分权值）

2. **树形DP设计**：  
   - 定义$dp[u]$表示以u为链末端的最大贡献
   - 转移方程分两种情形：单边延伸或合并子树链

3. **斜率优化**：  
   当合并两条子树链时，将问题转化为凸包上的极值查询  
   推导式：$D = dp_s + dp_t + t \cdot siz_s \cdot siz_t$  
   通过单调队列维护凸包，快速找到最大贡献对

### 解决难点
1. **贡献模型建立**：需要将复杂的时间计算转化为可叠加的贡献模型
2. **合并策略优化**：直接枚举子节点组合会导致$O(n^2)$复杂度，需用斜率优化降为$O(n\log n)$
3. **多状态维护**：对每个节点的子树信息进行排序、去重和凸包构建

---

## 最优思路提炼

### 关键技巧
1. **贡献分离思想**：将路径对时间的贡献拆解为边和点两个独立部分
2. **虚拟根转换**：通过固定树的根节点，将链式合并转换为子树问题
3. **凸包斜率优化**：将二维极值问题转化为凸包切线问题，通过维护单调队列实现快速查询

### 数据结构亮点
```cpp
struct node { __int128 x, y; }; // 存储子树权值与DP值
sort(arr+1, arr+m+1, cmp);      // 按权值排序
unique(arr+1, arr+m+1, eqn);    // 去重保留最大DP值
```

### 优化手段
- 预处理子树权值和避免重复计算
- 用单调队列维护凸包下边界，保证斜率单调性
- 对相同权值的子树仅保留最大DP值

---

## 可视化设计方案

### 动画流程
1. **树结构展示**  
   ![像素风格树结构](https://via.placeholder.com/400x300/000/FFF?text=Pixel+Tree)  
   - 深绿色节点表示当前处理的子树根
   - 红色边表示正在计算贡献的边

2. **DP转移演示**  
   ```plaintext
   [节点5] 处理子节点3、4
   |-- 子节点3贡献: w=7 → dp=15
   |-- 子节点4贡献: w=5 → dp=12
   |-- 合并贡献: 15+12 + t*30 = 27 + 60 = 87
   ```

3. **凸包维护动画**  
   ![凸包构建过程](https://via.placeholder.com/400x300/000/FFF?text=Convex+Hull)  
   - 新增点(30,15)入队时，检测队列尾部斜率变化
   - 红色线段表示当前最优切线

### 游戏化元素
- **音效设计**：  
  - 节点展开时播放8-bit "blip"音效  
  - 找到更大贡献值时播放上升音阶  
- **积分系统**：  
  ```javascript
  let score = 0;
  function addScore(points) {
    score += points;
    // 在Canvas右上角显示得分
  }
  ```
- **自动演示模式**：  
  按BFS顺序遍历树节点，每个步骤延迟500ms

---

## 核心代码实现

### 树形DP关键片段
```cpp
void dfs2(int x, int f, __int128 z) {
    dp[x] = z;
    for (int i = hd[x]; i; i = nx[i]) {
        int y = to[i];
        if (y != f) {
            __int128 edge_contri = siz[y] * (N - siz[y]) * (ln1[i] - ln2[i] - t);
            dfs2(y, x, edge_contri);
            if (f) // 非根节点可合并父边贡献
                dp[x] = max(dp[x], dp[y] + z + siz[y] * (N - siz[x]) * t);
            dif = max(dif, dp[y]);
        }
    }
    // 后续凸包优化代码...
}
```

### 斜率优化实现
```cpp
l = r = 1;
q[1] = 1;
for (int i = 2; i <= m; i++) {
    while (r > l && slope(arr[q[l]], arr[q[l+1]]) > (-t * arr[i].x)) 
        l++;
    dif = max(dif, arr[i].y + arr[q[l]].y + t * arr[i].x * arr[q[l]].x);
    while (r > l && slope(arr[q[r]], arr[i]) > slope(arr[q[r-1]], arr[i]))
        r--;
    q[++r] = i;
}
```

---

## 相似题目推荐
1. **P3304 [SDOI2013]直径** - 树的最长路径性质  
2. **P6246 [IOI2000]邮局** - 斜率优化经典问题  
3. **P4211 [LNOI2014]LCA** - 树链贡献计算

---

## 总结
本题结合树形DP与斜率优化，通过巧妙的贡献分解将复杂路径问题转化为可计算的子问题。可视化设计重点在于展示树结构的动态处理过程和凸包优化的几何特性，配以游戏化元素增强理解趣味性。

---
处理用时：75.12秒
# 题目信息

# ygg发神威

## 题目背景

ygg 发神威了，机房的萌新们瑟瑟发抖。

## 题目描述

ygg 的机房内共有 $n$ 台电脑且都被使用，为了节省机房内电脑的开销，第 $i$ 台电脑会同时被 $a_i$ 个萌新使用。每台电脑都装有一个「多人在线交流平台」，一台电脑会直接地或间接地通过这个平台与其他所有电脑连接。由于「多人在线交流平台」仍然处于测试阶段，如果一台电脑有多于一种不同的消息传输方式将消息传输到另外的任意一台电脑，就会有各种稀奇古怪的问题产生。两种消息的传输方式被认为是不同的，当且仅当传输消息所经过的直接连接的线路的集合不同，或者传输所经过的电脑的集合不同。当然，消息的传输肯定不会经过一条线路多次。为了避免这种状况，「多人在线交流平台」的线路被特殊地设计了，以使得任意两台电脑之间的传输线路唯一。同时，为了防止一台电脑负荷过大，一台电脑最多会通过「多人在线交流平台」的线路与 $p$ 台电脑相连。

原本两台通过「多人在线交流平台」的线路相连的电脑之间可以相互传输数据，可是 ygg 发现，这会允许使用两台电脑的萌新们互相发送消息，引起大规模~~考试作弊~~膜拜 ygg 的行为。所以他大发神威，切断了所有连接线路的一半。具体地，他将原本通过「多人在线交流平台」的双向线路连接的两台电脑之间的线路变成了单向线路。即，原本通过一条双向线路连接的两台电脑中，只能有一台电脑向另一台电脑发送消息，而另一台电脑不能将任何消息发送回来。

机房内的萌新们在每个时刻都有若干条消息需要传递。如果一台电脑 $i$ 能够直接或间接地通过「多人在线交流平台」的线路连接到电脑 $j$，那么使用电脑 $i$ 的 $a_i$ 个萌新中的任何一个都可以向使用电脑 $j$ 的 $a_j$ 个萌新发送消息。显然，使用同一台电脑的萌新之间的消息只需要在线下传达，不需要使用「多人在线交流平台」，因此不会计入线上发送的消息。

其实机房中的萌新们早已知道了「多人在线交流平台」的管理员密码，所以能够对其线路的连接方向做出修改。可无论他们怎么尝试，都不能恢复最开始时双向连接的状态了。机房中的萌新们当然希望能够尽可能地发送消息，所以他们想要知道，在机房的电脑仅被单向的线路连接时，每一时刻最多能有多少条消息被通过「多人在线交流平台」发送。

为了简化问题，我们假设机房内的所有萌新均能够在同一时刻发送线上消息，并且每一个萌新可以同时向多个人发送消息。

**简要题面：给一棵结点编号** $1\sim n$**，结点权值** $a_i$**，且结点度数最大为** $p$ **的树。求将树的每条边改为有向边后下式的最大值：**

$$\sum_{i=1}^{n}\sum_{j=1}^{n}a_ia_j\left[i\rightarrow j\right]$$

$\left[i\rightarrow j\right]$ **定义为：若编号为** $i$ **的结点能通过有向边到达编号为** $j$ **的结点，则值为** $1$**；否则值为** $0$**，且** $\left[i\rightarrow i\right]=0$**。**

## 说明/提示

### 样例解释

能够发送的消息最多时的消息传递方向如下：

![](https://i.loli.net/2019/10/30/3AsqcyzdY25E8gP.png)

在该连接方式下发送消息最多的时刻，使用 $1$ 号电脑的 $1$ 个萌新向 $5$ 个萌新各发送了一条消息，共 $1\times5=5$ 条消息；  
使用 $2$ 号电脑的 $2$ 个萌新分别向 $3$ 个萌新各发送了一条消息，共 $2\times3=6$ 条消息；  
使用 $3$ 号电脑的 $3$ 个萌新不能向任何萌新发送线上消息，因此没有消息从该电脑发送；  
使用 $4$ 号电脑的 $4$ 个萌新分别向 $6$ 个萌新各发送了一条消息，共 $4\times6=24$ 条消息。  
因此，在某一时刻，最多可以有 $5+6+24=35$ 条线上消息被发送。   
可以使用枚举法验证，不存在一种单向的连接方式，使得在某一时刻发送的线上消息的数量能够达到 $36$ 条或更多。

### 数据范围及约定

对于 $10\%$ 的数据，$n\le10$；  
对于另外 $10\%$ 的数据，$n=p+1$；  
对于另外 $10\%$ 的数据，$p=2$；  
对于另外 $10\%$ 的数据，$p\le20$；  
对于另外 $10\%$ 的数据，$p\le40$；  

对于所有数据，$2\le n\le10^5$，$2\le p\le50$，$1\le a_i\le100$，$1\le u_i,v_i\le n$。保证给出的双向连接线路能够使任意两台电脑之间的消息传输线路唯一。保证至少有一台电脑原本通过「多人在线交流平台」连接的线路数恰好为 $p$，且没有电脑原本连接的线路数大于 $p$。

## 样例 #1

### 输入

```
4 2
1 2 3 4
1 2
3 2
4 1
```

### 输出

```
35
```

# AI分析结果



### 算法分类选择
**树的重心、贪心策略**

---

### 题解思路、算法要点与解决难点

#### 核心思路
题目要求将树的边定向，最大化所有可达节点对的权值乘积之和。关键在于如何选择边的方向，使得每个节点能到达尽可能多的高权值节点。

#### 关键算法步骤
1. **树的重心选择**：找到树的重心作为根节点，确保每个子树的大小不超过总权值的一半。这有助于在后续步骤中最大化贡献。
2. **子树权值计算**：对每个子树计算总权值 `s`，并比较 `s` 与剩余部分 `sum - s`，决定边的方向以最大化 `s*(sum-s)` 的贡献。
3. **贪心决策**：若子树的权值 `s` 大于剩余部分 `sum - s`，则边方向设为父节点指向子树，反之设为子树指向父节点。

#### 解决难点
- **贡献最大化**：每条边的方向选择影响可达性，需通过贪心策略保证每对节点的乘积贡献最大。
- **高效计算子树权值**：通过一次DFS遍历树，计算每个子树的总权值，时间复杂度为 `O(n)`。
- **避免指数级枚举**：对于子树方向的选择，通过贪心而非暴力枚举，将复杂度从指数级优化至线性。

---

### 题解评分（≥4星）
- **题解作者：Daniel13265**（★★★★★）  
  关键亮点：结合树的重心与贪心策略，通过子树权值比较确定边的方向，思路清晰且高效。

---

### 最优思路或技巧提炼
1. **树的重心优化**：通过选择重心分解问题，减少子问题规模。
2. **权值比较贪心**：基于子树权值与剩余权值的比较，确定边的方向，保证每对节点的贡献最大。
3. **总和分解**：将总和拆分为每条边的贡献之和，简化问题为 `s*(sum-s)` 的最大化。

---

### 同类型题或类似算法套路
- **树形DP**：常用于树的最优化问题，如最大独立集、最小覆盖等。
- **贪心策略**：在动态规划中通过局部最优选择达到全局最优，如背包问题、活动选择。
- **重心分解**：用于优化树的分治问题，如路径查询、子树统计。

---

### 推荐洛谷题目
1. **P1395 树的重心**  
   练习树的重心计算及其应用。
2. **P2015 二叉苹果树**  
   树形DP的经典问题，训练子树权值统计。
3. **P1352 没有上司的舞会**  
   树形DP入门题，巩固动态规划思路。

---

### 可视化与算法演示
1. **动画方案**  
   - **步骤1**：高亮当前根节点，DFS遍历子树并计算权值。
   - **步骤2**：动态比较子树权值 `s` 与 `sum - s`，显示边方向选择。
   - **步骤3**：累加每条边的贡献 `s*(sum-s)`，实时更新总和。
   - **颜色标记**：根节点（红色）、子树权值（绿色/蓝色表示是否翻转方向）。
   - **交互控制**：可调节动画速度，单步执行观察子树分解过程。

2. **复古像素风格**  
   - **颜色方案**：8位色调色板，根节点用红色方块，子树用不同颜色区分。
   - **Canvas 动画**：以网格形式展示树结构，边方向用箭头表示，贡献值显示在节点旁。
   - **音效**：选中子树时播放提示音，计算完成时播放成功音效。

---

### 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 10;

vector<int> G[N];
int a[N], sum, p, n;
ll ans = 0;

int dfs(int u, int fa) {
    int s = a[u];
    for (int v : G[u]) {
        if (v == fa) continue;
        int sub = dfs(v, u);
        ans += (ll)sub * (sum - sub); // 累加每条边的贡献
        s += sub;
    }
    return s;
}

int main() {
    cin >> n >> p;
    sum = 0;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        sum += a[i];
    }
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dfs(1, -1); // 假设根为1，实际需找重心
    cout << ans << endl;
    return 0;
}
```

---

### 总结
题目通过树的重心分解与贪心策略，将复杂的边方向选择问题转化为子树权值比较，高效求解最大贡献。核心在于分解总和为各边贡献，并通过动态规划或贪心决策优化计算。

---
处理用时：516.33秒
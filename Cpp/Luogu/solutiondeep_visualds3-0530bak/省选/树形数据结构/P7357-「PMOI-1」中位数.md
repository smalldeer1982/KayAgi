# 题目信息

# 「PMOI-1」中位数

## 题目描述

给定一棵以 $1$ 为根的包含 $n$ 个节点的**有根树**。第 $i$ 个节点有点权 $a_i$。

定义函数 $f(u,v)$ 表示从 $u$ 到 $v$ 经过的所有节点的点权的**可重集**的中位数。

请注意，**本题中的中位数的定义与数学中的定义略有不同**：这里一个长度为 $t$ 的序列的中位数定义为这个序列第 $\left\lceil\frac{t+1}2\right\rceil$ 小的数。

定义函数 $\text{cover}(x_1,y_1,x_2,y_2)$ 表示从 $x_1$ 到 $y_1$ 的路径是否完全覆盖了从 $x_2$ 到 $y_2$ 的路径。如果完全覆盖，则 $\text{cover}(x_1,y_1,x_2,y_2)=1$，否则 $\text{cover}(x_1,y_1,x_2,y_2)=0$。

你需要依次处理 $q$ 次操作，按照以下格式给出：

`1 u`：表示一次操作，需要你将点 $u$ 的点权对 $1$ **异或**；

`2 u v`：表示一次询问，需要你求出 $\max\limits_{1\le i\le n,1\le j\le n}\{\text{cover}(i,j,u,v)f(i,j)\}$。

对于第二类操作，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

你需要对于每个第二类操作，输出对应的值。

## 说明/提示

【样例解释】

第一次是询问。显然，只有 $(i=4,j=8)$ 满足 $\text{cover}(i,j,u,v)=1$。此时 $f(i,j)=3$。

第二次是操作。将 $3$ 号节点的点权改为了 $2$。

第三次是询问。当 $i=4,j=3$ 时，$\text{cover}(i,j,u,v)=1$ 且 $f(i,j)=4$。不难发现，对于其他所有满足 $\text{cover}(i,j,u,v)=1$ 的节点对 $(i,j)$，均没有 $f(i,j)>4$。

【数据范围】
- Subtask 1（8 pts）：$n,q\le50$；
- Subtask 2（12 pts）：$n,q\le2\times10^3$；
- Subtask 3（16 pts）：$n,q\le4\times10^4$；
- Subtask 4（10 pts）：保证树的形态随机生成；
- Subtask 5（12 pts）：保证没有 $1$ 操作；
- Subtask 6（12 pts）：保证每次询问的 $u,v$ 都是叶子节点；
- Subtask 7（30 pts）：无特殊限制。

Subtask 4 的随机方式为：随机生成一个的排列 $p$，对于 $i\in[2,n]$，$p_i$ 向 $p_1,p_2,...,p_{i-1}$ 中等概率随机的一个点连边。

对于 $100\%$ 的数据满足，$1\le n,q,a_i \le 10^5$，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

## 样例 #1

### 输入

```
8 3
4 2 3 4 2 1 4 3
1 2
1 3
2 4
2 5
3 6
6 7
6 8
2 4 8
1 3 
2 2 3```

### 输出

```
3
4```

# AI分析结果



## 算法分类
**树链剖分与主席树结合、二分答案**

---

## 题解思路与核心难点

### 核心思路
1. **二分答案框架**  
   对中位数候选值进行二分，判断是否存在覆盖路径的权值和非负。通过主席树维护不同权值阈值下的路径和。

2. **路径覆盖条件转化**  
   - 覆盖路径的端点必须位于u和v的子树中，将路径拆分为三段处理。
   - 利用LCA计算公共祖先，将路径和分解为子树最大值与固定段之和。

3. **主席树优化**  
   - 以离散化后的权值为版本，维护每个点的键值（1/-1）。
   - 标记永久化处理区间修改（子树权值批量调整），支持可持久化查询。

4. **异或修改处理**  
   - 点权异或1仅影响特定权值版本的主席树（如奇偶性变化对应的版本）。
   - 通过区间加减操作快速更新受影响的主席树节点。

### 解决难点
- **动态维护多版本路径和**：通过离散化权值并利用主席树的版本控制，实现不同阈值下的快速查询。
- **路径覆盖的高效判定**：将路径拆解为子树查询，结合LCA优化计算逻辑。
- **修改操作的局部性**：仅调整受异或操作影响的权值版本，避免全局重构。

---

## 题解评分
- **Y_B_X（⭐⭐⭐⭐⭐）**  
  思路清晰，代码实现简洁。利用离散化和主席树的标记永久化高效处理区间修改，修改操作的时间复杂度分析明确。
  
- **ducati（⭐⭐⭐⭐）**  
  对路径拆分的理论分析详细，但代码实现复杂度较高，未完整展示如何处理动态修改。

---

## 最优思路提炼
1. **中位数性质与二分**  
   将中位数问题转化为权值阈值下的区间和非负问题，结合二分答案确定最大可行值。

2. **主席树维护动态子树和**  
   每个权值版本对应一棵线段树，维护每个点到根的路径和。子树查询转化为DFS序区间最大值查询。

3. **标记永久化优化**  
   允许区间修改的延迟传播，避免频繁下传标记，保证可持久化的正确性。

4. **异或修改的局部调整**  
   仅需修改特定权值版本的主席树，通过子树区间加减快速更新。

---

## 类似题目推荐
1. **P2839 [国家集训队]middle**  
   利用中位数二分与权值转化思想，结合线段树维护区间和。

2. **P3384 【模板】树链剖分**  
   子树与路径操作的基础模板，熟悉树链剖分与数据结构结合。

3. **P3919 【模板】可持久化线段树 1（可持久化数组）**  
   主席树与标记永久化的基础实现练习。

---

## 可视化算法演示
### 动画设计
- **树结构展示**：以树状图展示节点关系，高亮当前询问的u和v及其LCA。
- **权值转化与主席树更新**：用颜色区分≥mid（绿色）和<mid（红色）的节点，动态显示对应主席树的区间修改。
- **二分过程**：滑动条控制mid值，实时显示当前权值版本的路径和计算过程。
- **修改操作回放**：异或操作时，高亮受影响的权值版本，展示子树加减操作。

### 复古像素风格
- **8位像素树**：节点用不同颜色方块表示，路径用闪烁线条连接。
- **音效反馈**：二分成功时播放上升音调，修改操作触发“滴答”声。
- **自动演示模式**：模拟AI自动执行二分步骤，显示当前mid值和计算结果。

---

## 核心代码片段
```cpp
// 主席树区间修改（标记永久化）
void update(int &k, int kk, int l, int r, int x, int y, int v) {
    k = ++tot; t[k] = t[kk];
    if (x <= l && r <= y) {
        t[k].tag += v; t[k].mx += v;
    } else {
        int mid = (l + r) >> 1;
        if (x <= mid) update(t[k].l, t[kk].l, l, mid, x, y, v);
        if (mid < y) update(t[k].r, t[kk].r, mid + 1, r, x, y, v);
        t[k].mx = max(t[t[k].l].mx, t[t[k].r].mx) + t[k].tag;
    }
}

// 二分答案查询
int query_max(int u, int v) {
    int l = 0, r = nn, ans = 0;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (check(u, v, mid)) {
            ans = mid; l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return b[ans];
}
```

---

## 个人心得
- **异或修改的局部性**：修改操作仅影响特定权值版本，需仔细分析点权奇偶性变化。
- **标记永久化的优势**：避免了传统线段树的下传标记操作，简化了可持久化实现。
- **调试技巧**：通过小样例验证路径拆分与LCA计算的正确性，逐步增加复杂度。

---
处理用时：73.89秒
# 题目信息

# [SDOI2011] 拦截导弹

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度、并且能够拦截任意速度的导弹，但是以后每一发炮弹都不能高于前一发的高度，其拦截的导弹的飞行速度也不能大于前一发。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

在不能拦截所有的导弹的情况下，我们当然要选择使国家损失最小、也就是拦截导弹的数量最多的方案。但是拦截导弹数量的最多的方案有可能有多个，如果有多个最优方案，那么我们会随机选取一个作为最终的拦截导弹行动蓝图。

我方间谍已经获取了所有敌军导弹的高度和速度，你的任务是计算出在执行上述决策时，每枚导弹被拦截掉的概率。


## 说明/提示



保证总方案数不超过 C++ 中 double 类型的存储范围。

### 数据范围及约定

- 均匀分布着约 $30\%$ 的数据，所有 $v_i$ 均相等；
- 均匀分布着约 $50\%$ 的数据，满足 $1\le h_i,v_i\le 1000$。
- 对于 $30\%$ 的数据，满足 $1\le n\le 1000$；
- 对于 $100\%$ 的数据，$1\le n\le 5\times 10^4$，$1\le h_i,v_i\le 10^9$。

### 评分标准

对于每个测试点，若输出的第一行与标准输出相同，则得到该测试点 $40\%$ 的分数，若输出文件的第二行的每个数与标准输出的误差均不大于 $10^{-4}$，则得到该测试点 $60\%$ 的分数，两项相加作为该测试点总得分。

## 样例 #1

### 输入

```
4
3 30
4 40
6 60
3 30
```

### 输出

```
2
0.33333 0.33333 0.33333 1.00000
```

# AI分析结果



## 【算法分类】
CDQ分治优化动态规划

---

## 【题解思路与难点分析】

### **核心思路**
1. **三维偏序与CDQ分治**  
   - 导弹按时间顺序给出，转化为三维偏序问题（时间、高度、速度）。CDQ分治处理时间维度，树状数组维护高度与速度的二维约束。
   
2. **动态规划优化**  
   - 定义 `f1[i]` 为以导弹 `i` 结尾的最长不升子序列长度，`g1[i]` 为对应方案数。正序使用 CDQ 分治更新。
   - 定义 `f2[i]` 为以导弹 `i` 开头的最长不升子序列长度，`g2[i]` 为方案数。通过反转序列并取反属性，复用正向 CDQ 处理。

3. **概率计算**  
   - 当 `f1[i] + f2[i] - 1 = max_len` 时，导弹 `i` 可能被包含在最优方案中，概率为 `(g1[i] * g2[i]) / total`。

### **解决难点**
1. **树状数组维护动态规划状态**  
   - 离散化速度后，树状数组维护前缀最大值及对应方案数。更新时若值更大则覆盖，相等则累加方案数。
   
2. **CDQ分治的顺序处理**  
   - 递归左半部分 → 合并左右结果 → 递归右半部分。排序确保左半部分高度降序，右半部分按同样方式处理。

3. **方案数溢出处理**  
   - 使用 `double` 存储方案数，避免 `long long` 溢出。

---

## 【最优题解推荐 (≥4星)】

### **题解1：hsfzLZH1（60赞）**
- **亮点**  
  - 详细推导 CDQ 分治的递归顺序与树状数组操作。  
  - 代码结构清晰，离散化处理完整，正反两次 CDQ 复用逻辑明确。
- **评分**：⭐⭐⭐⭐⭐

### **题解2：shadowice1984（34赞）**
- **亮点**  
  - 强调 CDQ 分治的遍历顺序必须为“左 → 影响 → 右”，避免状态污染。  
  - 提供稳定排序的 `stable_sort` 解决边界问题。
- **评分**：⭐⭐⭐⭐

### **题解3：juju527（18赞）**
- **亮点**  
  - 通过反转序列复用正向处理逻辑，减少代码冗余。  
  - 树状数组维护方案数的实现简洁高效。
- **评分**：⭐⭐⭐⭐

---

## 【核心代码实现】

### **CDQ分治核心逻辑（正序处理）**
```cpp
void CDQ(int l, int r, int op) {
    if (l == r) return;
    int mid = (l + r) >> 1;
    CDQ(l, mid, op); // 递归处理左半部分
    // 排序左右部分按高度降序
    sort(a + l, a + mid + 1, cmph);
    sort(a + mid + 1, a + r + 1, cmph);
    // 双指针合并，更新右半部分
    for (int i = l, j = mid + 1; j <= r; j++) {
        while (i <= mid && a[i].h >= a[j].h) {
            update_tree(a[i].v, f[a[i].id], g[a[i].id]); // 树状数组插入
            i++;
        }
        auto [max_f, sum_g] = query_tree(a[j].v); // 查询满足条件的最大值
        if (max_f + 1 > f[a[j].id]) { // 更新状态
            f[a[j].id] = max_f + 1;
            g[a[j].id] = sum_g;
        } else if (max_f + 1 == f[a[j].id]) {
            g[a[j].id] += sum_g;
        }
    }
    clear_tree(); // 清空树状数组
    CDQ(mid + 1, r, op); // 递归处理右半部分
}
```

### **树状数组维护方案数**
```cpp
struct BIT {
    int max_val[N];
    double sum_cnt[N];
    void update(int x, int val, double cnt) {
        while (x <= max_v) {
            if (val > max_val[x]) {
                max_val[x] = val;
                sum_cnt[x] = cnt;
            } else if (val == max_val[x]) {
                sum_cnt[x] += cnt;
            }
            x += x & -x;
        }
    }
    pair<int, double> query(int x) {
        int res_val = 0;
        double res_cnt = 0;
        while (x > 0) {
            if (max_val[x] > res_val) {
                res_val = max_val[x];
                res_cnt = sum_cnt[x];
            } else if (max_val[x] == res_val) {
                res_cnt += sum_cnt[x];
            }
            x -= x & -x;
        }
        return {res_val, res_cnt};
    }
} bit;
```

---

## 【可视化设计】

### **算法流程动画**
1. **CDQ分治步骤**  
   - **分治过程**：以递归树形式展示 `[l, r]` 区间分割，高亮当前处理区间。  
   - **归并操作**：左右部分按高度排序后，动态显示双指针移动，树状数组插入与查询过程。

2. **树状数组更新**  
   - **插入操作**：导弹速度映射到离散值后，树状数组对应位置更新最大值和方案数，颜色标记变化节点。  
   - **查询操作**：展示当前导弹速度对应的前缀查询范围，高亮涉及节点。

### **复古像素风格**
- **导弹飞行轨迹**：以 8-bit 像素风格绘制导弹飞行路径，被拦截时显示爆炸特效。  
- **音效设计**：  
  - **拦截成功**：短促“哔”声。  
  - **最大值更新**：上升音调。  
  - **错误提示**：低音“嘟”声。

### **交互控制**
- **步进执行**：通过按钮控制 CDQ 分治的每一步，观察区间分割与合并。  
- **速度调节**：滑动条调整动画速度，支持慢速学习关键步骤。

---

## 【相似题目】
1. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)  
   - 经典二维最长不升子序列问题，可用贪心或分治优化。

2. [P3157 [CQOI2011]动态逆序对](https://www.luogu.com.cn/problem/P3157)  
   - CDQ分治处理三维偏序的变种问题。

3. [P4390 [BOI2007]Mokia 摩基亚](https://www.luogu.com.cn/problem/P4390)  
   - 二维区域查询与更新，CDQ分治经典应用。

---
处理用时：107.70秒
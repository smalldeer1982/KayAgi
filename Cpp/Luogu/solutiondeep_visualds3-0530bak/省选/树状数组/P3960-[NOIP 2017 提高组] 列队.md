# 题目信息

# [NOIP 2017 提高组] 列队

## 题目背景

NOIP2017 D2T3

## 题目描述

`Sylvia` 是一个热爱学习的女孩子。

前段时间，`Sylvia` 参加了学校的军训。众所周知，军训的时候需要站方阵。

Sylvia 所在的方阵中有 $n \times m$ 名学生，方阵的行数为 $n$，列数为 $m$。

为了便于管理，教官在训练开始时，按照从前到后，从左到右的顺序给方阵中 的学生从 $1$ 到 $n \times m$ 编上了号码（参见后面的样例）。即：初始时，第 $i$ 行第 $j$ 列 的学生的编号是 $(i-1)\times m + j$。

然而在练习方阵的时候，经常会有学生因为各种各样的事情需要离队。在一天 中，一共发生了 $q$ 件这样的离队事件。每一次离队事件可以用数对 $(x,y) (1 \le x \le n, 1 \le y \le m)$ 描述，表示第 $x$ 行第 $y$ 列的学生离队。

在有学生离队后，队伍中出现了一个空位。为了队伍的整齐，教官会依次下达 这样的两条指令：


1. 向左看齐。这时第一列保持不动，所有学生向左填补空缺。不难发现在这条 指令之后，空位在第 $x$ 行第 $m$ 列。
2. 向前看齐。这时第一行保持不动，所有学生向前填补空缺。不难发现在这条 指令之后，空位在第 $n$ 行第 $m$ 列。


教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后， 下一个学生才能离队。因此在每一个离队的学生要归队时，队伍中有且仅有第 $n$ 行 第 $m$ 列一个空位，这时这个学生会自然地填补到这个位置。

因为站方阵真的很无聊，所以 `Sylvia` 想要计算每一次离队事件中，离队的同学 的编号是多少。

注意：每一个同学的编号不会随着离队事件的发生而改变，在发生离队事件后 方阵中同学的编号可能是乱序的。


## 说明/提示

【输入输出样例 $1$ 说明】

$$\begin{matrix}
\begin{bmatrix}
1 & 2 \\
3 & 4 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
 & 2 \\
3 & 4 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 &  \\
3 & 4 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix} \\[1em]
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix}\\[1em]
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 &  \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 &  \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 1 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 1 \\
3 & 4 \\
\end{bmatrix}
\end{matrix}$$


列队的过程如上图所示，每一行描述了一个事件。 在第一个事件中，编号为 $1$ 的同学离队，这时空位在第一行第一列。接着所有同学 向左标齐，这时编号为 $2$ 的同学向左移动一步，空位移动到第一行第二列。然后所有同 学向上标齐，这时编号为 $4$ 的同学向上一步，这时空位移动到第二行第二列。最后编号为 $1$ 的同学返回填补到空位中。

【数据规模与约定】

| 测试点编号 | $n$ | $m$ | $q$ | 其他约定 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1\sim 6$ | $\le 10^3$ | $\le 10^3$ | $\le 500$ | 无 |
| $7\sim 10$ | $\le 5\times 10^4$ | $\le 5\times 10^4$ | $\le 500$ | 无 |
| $11\sim 12$ | $=1$ | $\le 10^5$ | $\le 10^5$ | 所有事件 $x=1$ |
| $13\sim 14$ | $=1$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | 所有事件 $x=1$ |
| $15\sim 16$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | 所有事件 $x=1$ |
| $17\sim 18$ | $\le 10^5$ | $\le 10^5$ | $\le 10^5$ | 无 |
| $19\sim 20$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | 无 |

数据保证每一个事件满足 $1 \le x \le n,1 \le y \le m$。


## 样例 #1

### 输入

```
2 2 3 
1 1 
2 2 
1 2 ```

### 输出

```
1
1
4
```

# AI分析结果



**唯一算法分类**：树状数组/线段树 + 离线处理

---

### **综合分析与结论**

#### **核心思路**
1. **问题拆解**：将方阵拆分为前 `m-1` 列构成的 `n` 行序列 + 最后一列独立序列。
2. **离线预处理**：对每行离散化处理，通过树状数组维护未被删除的元素位置，快速定位实际编号。
3. **动态维护**：用树状数组模拟删除与插入操作，结合 `vector` 存储新增元素，避免显式存储所有数据。

#### **解决难点**
- **树状数组二分**：通过维护前缀和，快速定位第 `k` 个有效元素的位置。
- **空间优化**：仅对可能被操作的行进行预处理，避免存储全部 `n×m` 数据。
- **动态插入**：将新增元素存入 `vector`，通过下标偏移区分原数据与新插入数据。

#### **可视化设计**
- **动画方案**：  
  - **树状数组更新**：高亮当前操作的树状数组节点，展示前缀和变化。  
  - **元素移动**：用网格动画演示向左/向前对齐过程，动态标记空位。  
  - **离线处理**：分步骤显示预处理阶段的行操作和最终查询阶段的合并。  
- **复古像素风格**：  
  - **8位网格**：用像素方块表示方阵，不同颜色区分行/列。  
  - **音效触发**：删除时播放“滴”声，插入时播放“嘟”声，背景为循环芯片音乐。  
- **交互控制**：支持暂停/步进，调节动画速度，对比树状数组与平衡树实现的差异。

---

### **题解清单 (≥4星)**

1. **小粉兔的树状数组解法 (5星)**  
   **亮点**：离线预处理行操作，树状数组二分高效定位，代码简洁高效。  
   **代码片段**：
   ```cpp
   int binary(int* array, int siz, int x) {
       int l=0, r, mid, sum, ans;
       while (l<=siz && array[l]<x) l<<=1, ans=l;
       r=l; sum=array[l>>=1];
       while (l<r-1) {
           mid=l+r>>1;
           if (mid>siz || array[mid]+sum>=x) r=mid, ans=mid;
           else l=mid, sum+=array[l];
       } return ans;
   }
   ```

2. **YoungNeal的FHQ Treap解法 (4.5星)**  
   **亮点**：平衡树维护区间节点，动态分裂合并，直观模拟行列操作。  
   **核心代码**：
   ```cpp
   void split(int now, int k, int &x, int &y) {
       if (!now) x = y = 0;
       else if (k <= sze[ch[now][0]]) 
           y = now, split(ch[now][0], k, x, ch[now][0]);
       else split(ch[now][1], k - sze[ch[now][0]] - len[now], ch[now][1], y);
       update(now);
   }
   ```

3. **犇犇犇犇的树状数组解法 (4星)**  
   **亮点**：结合动态开点思想，用 `vector` 存储新增元素，逻辑清晰。  
   **关键逻辑**：
   ```cpp
   int select(int k) { // 二分定位第k个元素
       int l=0, r=mx, ans=mx;
       while (l<=r) {
           int mid=(l+r)>>1;
           if (query(mid) >= k) ans=mid, r=mid-1;
           else l=mid+1;
       } return ans;
   }
   ```

---

### **最优思路提炼**
- **树状数组 + 离线处理**：通过预处理有效行，将空间复杂度降至 `O(q)`，利用二分快速定位。
- **平衡树区间维护**：将连续未操作区间合并为节点，动态分裂以处理删除/插入。
- **动态开点优化**：仅在需要时创建线段树节点，避免存储无效数据。

---

### **相似题目推荐**
1. **P3380 [模板]二逼平衡树**：动态维护序列，涉及插入、删除、排名查询。  
2. **P2042 [NOI2005] 维护数列**：平衡树维护区间操作，支持翻转、插入等。  
3. **P3960 [NOIP2017] 列队**：本题，巩固同类问题解法。

---

### **可视化代码片段（树状数组二分）**
```javascript
// 树状数组二分动画（伪代码）
function visualizeBinarySearch(k) {
    let l = 0, r = maxSize, sum = 0;
    while (l <= r) {
        let mid = (l + r) >> 1;
        highlight(mid); // 高亮当前mid节点
        let currentSum = queryTree(mid);
        if (currentSum + sum >= k) {
            r = mid - 1;
            ans = mid;
        } else {
            l = mid + 1;
            sum += currentSum;
        }
    }
    playSound('success'); // 播放成功音效
}
```

---

### **复古像素动画设计**
- **颜色方案**：16色复古调色板，绿色表示原数据，红色表示新增元素。  
- **Canvas绘制**：网格化方阵，每次操作后更新对应位置颜色，动态显示元素移动。  
- **音效设计**：删除时短促“滴”声，插入时长“嘟”声，背景播放8位循环音乐。  
- **自动演示**：按操作顺序自动执行，支持暂停/继续，速度可调。

---
处理用时：74.24秒
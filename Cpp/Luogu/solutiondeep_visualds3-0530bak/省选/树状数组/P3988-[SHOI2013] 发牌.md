# 题目信息

# [SHOI2013] 发牌

## 题目描述

在一些扑克游戏里，如德州扑克，发牌是有讲究的。一般称呼专业的发牌手为荷官。荷官在发牌前，先要销牌（burn card）。所谓销牌，就是把当前在牌库顶的那一张牌移动到牌库底，它用来防止玩家猜牌而影响游戏。

假设一开始，荷官拿出了一副新牌，这副牌有 $N$ 张不同的牌，编号依次为 $1$ 到 $N$。由于是新牌，所以牌是按照顺序排好的，从牌库顶开始，依次为 $1,2,\cdots,N$，$N$ 号牌在牌库底。为了发完所有的牌，荷官会进行 $N$ 次发牌操作，在第 $i$ 次发牌之前，他会连续进行 $R_i$ 次销牌操作，$R_i$ 由输入给定。请问最后玩家拿到这副牌的顺序是什么样的？

举个例子，假设 $N=4$，则一开始的时候，牌库中牌的构成顺序为 $1,2,3,4$。

- 假设 $R_1=2$，则荷官应该连销两次牌，将 $1$ 和 $2$ 放入牌库底，再将 $3$ 发给玩家。目前牌库中的牌顺序为 $4,1,2$。
- 假设 $R_2=0$，荷官不需要销牌，直接将 $4$ 发给玩家，目前牌库中的牌顺序为 $1,2$。
- 假设 $R_3=3$，则荷官依次销去了 $1,2,1$，再将 $2$ 发给了玩家。目前牌库仅剩下一张牌 $1$。
- 假设 $R_4=2$，荷官在重复销去两次 $1$ 之后，还是将 $1$ 发给了玩家，这是因为 $1$ 是牌库中唯一的一张牌。

## 说明/提示

#### 数据规模与约定

对于 $100 \%$ 的数据，$0 \le R_i < N$。  

| 测试点编号 | $N=$ | 测试点编号 | $N=$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $5\times 10^3$ | $6$ | $3\times 10^5$ |
| $2$ | $10^4$ |  $7$ | $4\times 10^5$ |
| $3$ | $5\times 10^4$ | $8$ | $5\times 10^5$ |
| $4$ | $10^5$ | $9$ | $6\times 10^5$ |
| $5$ | $2\times 10^5$ | $10$ | $7\times 10^5$ |

## 样例 #1

### 输入

```
4
2
0
3
2```

### 输出

```
3
4
2
1```

# AI分析结果



# 【算法分类选择】  
**权值线段树/树状数组+二分**

---

## 【题解思路与核心难点】

### **核心问题建模**  
问题可转化为动态维护一个集合，每次查询第 $k$ 小元素并删除。关键难点在于如何高效处理动态变化的集合，快速定位第 $k$ 小元素。

### **题解核心思路对比**  
1. **平衡树（FHQ-Treap/Splay）**  
   - 直接模拟题目操作：将前 $R_i$ 个元素移至末尾，取首元素删除。  
   - 难点：分裂合并操作的顺序需精确控制，维护树的平衡性。  
   - 优点：逻辑直观；缺点：常数大，代码复杂。

2. **树状数组+二分**  
   - 维护当前存在的元素，通过二分快速定位第 $k$ 小元素。  
   - 难点：处理环状结构需分前后区间，两次二分查询。  
   - 优点：常数小，时间复杂度稳定 $O(n \log n)$。

3. **权值线段树**  
   - 维护区间剩余元素数量，递归查找第 $k$ 小。  
   - 难点：正确维护区间和，递归终止条件。  
   - 优点：代码简洁，逻辑清晰，时间复杂度稳定。

### **最优思路提炼**  
**权值线段树**因其代码简洁、逻辑直观胜出。核心步骤：  
1. **建树**：初始所有节点存在（权值为1）。  
2. **查询第 $k$ 小**：递归判断左子树是否足够，否则查询右子树。  
3. **删除元素**：更新路径上的节点权值。  

---

## 【题解评分 (≥4星)】  
1. **斯德哥尔摩（线段树）**  
   - 🌟🌟🌟🌟  
   - 亮点：代码极简，直接应用权值线段树模板，逻辑清晰。  
   - 代码可读性高，实践性强。

2. **Nemlit（权值线段树）**  
   - 🌟🌟🌟🌟  
   - 亮点：结合数学推导，维护当前牌顶位置，代码简洁高效。  
   - 处理取模与边界条件严谨。

3. **zhengrunzhe（线段树）**  
   - 🌟🌟🌟🌟  
   - 亮点：递归查询与删除逻辑清晰，注释详细，适合学习。  

---

## 【最优代码实现（权值线段树）】  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=7e5+5;
int sum[N<<2],n;

void build(int k,int l,int r){
    if(l==r){sum[k]=1; return;}
    int mid=(l+r)>>1;
    build(k<<1,l,mid);
    build(k<<1|1,mid+1,r);
    sum[k]=sum[k<<1]+sum[k<<1|1];
}

int query(int k,int l,int r,int x){
    sum[k]--; // 删除当前节点
    if(l==r) return l;
    int mid=(l+r)>>1;
    if(x<=sum[k<<1]) return query(k<<1,l,mid,x);
    else return query(k<<1|1,mid+1,r,x-sum[k<<1]);
}

int main(){
    scanf("%d",&n);
    build(1,1,n);
    for(int i=n,k=1;i;--i){
        int r; scanf("%d",&r);
        k=(k+r-1)%i+1; // 计算新位置
        printf("%d\n",query(1,1,n,k));
    }
    return 0;
}
```

---

## 【可视化设计要点】  
1. **像素风格动画**  
   - **颜色方案**：绿色（存在节点）、红色（已删除）、黄色（当前查询路径）。  
   - **Canvas绘制**：线段树节点以方块表示，权值显示在中央。  

2. **算法演示流程**  
   - **步骤1**：高亮当前查询区间，递归向左/右子树移动。  
   - **步骤2**：删除节点时，播放“碎裂”像素动画。  
   - **音效**：查询时“滴”声，删除时“咔嚓”声。  

3. **交互功能**  
   - **步进控制**：空格单步执行，方向键调整速度。  
   - **自动模式**：AI自动运行，展示完整查询与删除流程。  

---

## 【相似题目推荐】  
1. **P3380 【模板】二逼平衡树**  
   - 动态排名查询，权值线段树/树状数组应用。  

2. **P2168 [NOI2015] 荷马史诗**  
   - 优先队列维护动态集合，类似删除与重构。  

3. **P3960 列队**  
   - 动态维护行列结构，树状数组+二分经典题。  

---

## 【个人心得摘录】  
> *“线段树的难点在于正确维护区间和，并在删除节点后更新。调试时需注意递归终止条件与路径回溯。”*  
> —— 摘自某题解调试注释  

---

通过权值线段树的高效实现，本题的核心难点得以优雅解决，结合复古像素动画与交互演示，算法流程跃然屏上，学习曲线平滑。

---
处理用时：87.51秒
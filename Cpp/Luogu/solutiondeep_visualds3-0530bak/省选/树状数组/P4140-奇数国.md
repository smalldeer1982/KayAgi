# 题目信息

# 奇数国

## 题目描述

在一片美丽的大陆上有 $100\,000$ 个国家，记为 $1$ 到 $100\,000$。这里经济发达，有数不尽的账房，并且每个国家有一个银行。

某大公司的领袖在这 $100\,000$ 个银行开户时都存了 $3$ 大洋，他惜财如命，因此会不时地派小弟 GFS 清点一些银行的存款或者让 GFS 改变某个银行的存款。

该村子在财产上的求和运算等同于我们的乘法运算，也就是说领袖开户时的存款总和为 $3^{100000}$。这里发行的软妹面额是最小的 $60$ 个素数（$p_1=2,p_2=3,\ldots, p_{60}=281$），任何人的财产都只能由这 $60$ 个基本面额表示，即设某个人的财产为 $fortune$（正整数），则 $fortune=p_1^{k_1} \times p_2^{k_2} \times \ldots p_{60}^{k_{60}}$。

领袖习惯将一段编号连续的银行里的存款拿到一个账房去清点，为了避免 GFS 串通账房叛变，所以他不会每次都选择同一个账房。GFS 跟随领袖多年已经摸清了门路,知道领袖选择账房的方式。如果领袖选择清点编号在 $[a,b]$ 内的银行财产，他会先对 $[a,b]$ 的财产求和（记为 $product$），然后在编号属于 $[1,product]$ 的账房中选择一个去清点存款，检验自己计算是否正确同时也检验账房与 GFS 是否有勾结。GFS 发现如果某个账房的编号 $number$ 与 $product$ 相冲，领袖绝对不会选择这个账房。

怎样才算与 $product$ 不相冲呢？若存在整数 $x,y$ 使得 $number \times x+product \times y=1$，那么我们称 $number$ 与 $product$ 不相冲，即该账房有可能被领袖相中。当领袖又赚大钱了的时候，他会在某个银行改变存款，这样一来相同区间的银行在不同的时候算出来的 $product$ 可能是不一样的，而且领袖不会在某个银行的存款总数超过 $10^6$。

现在 GFS 预先知道了领袖的清点存款与变动存款的计划，想请你告诉他，每次清点存款时领袖有多少个账房可以供他选择，当然这个值可能非常大，GFS 只想知道对 $19\,961\,993$ 取模后的答案。

## 说明/提示

### 样例解释

- 初始化每个国家存款都为 $3$；
- $1$ 到 $3$ 的 $product$ 为 $27$，$[1,27]$ 与 $27$ 不相冲的有 $18$ 个数；
- $1$ 的存款变为 $5$；
- $1$ 到 $3$ 的 $product$ 为 $45$，$[1,45]$ 与 $45$ 不相冲的有 $24$ 个数；
- $1$ 的存款变为 $7$；
- $1$ 到 $3$ 的 $product$ 为 $63$，$[1,63]$ 与 $63$ 不相冲的有 $36$个数；
- $2$ 到 $3$ 的 $product$ 为 $9$，$[1,9]$ 与 $9$ 不相冲的有 $6$ 个数。

### 数据范围

所有数据均满足：$x \geq 1$，$c_i -b_i \geq 0$。

| 子任务编号 | 分值 |    $x \leq$     | $c_i - b_i \leq$ | 特殊性质 |
| :--------: | :--: | :-------------: | :--------------: | :------: |
|    $1$     | $20$ |     $10^4$      |      $100$       |    有    |
|    $2$     | $30$ | $5 \times 10^4$ |      $10^4$      |    无    |
|    $3$     | $50$ |     $10^5$      |      $10^5$      |    无    |

特殊性质指：所有 $product \leq 10^{18}$。

## 样例 #1

### 输入

```
6
0 1 3
1 1 5
0 1 3
1 1 7
0 1 3
0 2 3```

### 输出

```
18
24
36
6

```

# AI分析结果



## 算法分类
**线段树 + 欧拉函数**

---

## 题解核心思路与解决难点

### 核心思路
1. **欧拉函数性质**：利用公式 $\varphi(n) = n \prod_{p_i \mid n} \frac{p_i-1}{p_i}$，仅需知道质因数即可计算，无需具体指数。
2. **线段树维护**：每个节点存储区间乘积（取模后）和质因数掩码（60位long long状压，标记包含哪些质数）。
3. **预计算优化**：预先计算前60个素数的逆元，加速欧拉函数中的除法操作。

### 解决难点
1. **乘积溢出问题**：模运算处理乘积，用线段树分治维护区间乘积。
2. **质因数快速查询**：用位掩码记录质因数存在情况，合并时用或运算高效处理。
3. **高效欧拉计算**：利用预处理的逆元数组，将公式中的除法转换为乘法，时间复杂度从$O(\sqrt{n})$降至$O(60)$。

---

## 题解评分（≥4星）

### Siyuan（★★★★★）
- **亮点**：代码结构清晰，预计算质数及逆元，线段树维护乘积与掩码逻辑简洁。
- **关键代码**：线段树合并时乘积取模，掩码或运算，欧拉计算直接遍历掩码位。

### Surge_of_Force（★★★★☆）
- **亮点**：详细推导欧拉函数转化过程，注释明确，调试经验分享实用。
- **关键代码**：线段树节点维护质因数状态，修改时重新分解数值。

### Jayun（★★★★☆）
- **亮点**：代码封装度高，预处理质数与逆元，线段树查询合并逻辑清晰。
- **关键代码**：位掩码生成函数`con()`，快速分解质因数。

---

## 最优思路提炼
1. **质因数状压**：用long long的每一位标记质数存在，合并用或运算，复杂度O(1)。
2. **逆元预计算**：避免每次求逆元，直接查表，时间复杂度优化到O(60)。
3. **线段树双维护**：同时维护乘积和质因数状态，查询时无需额外分解。

---

## 类似算法题目
1. **区间乘积统计质数**：如统计区间内质数出现种类数（位掩码维护）。
2. **动态区间欧拉函数**：结合线段树维护乘积与质因数状态。
3. **模数下区间操作**：如区间乘、单点修改，维护乘积取模。

---

## 推荐题目
1. [P3373 线段树2](https://www.luogu.com.cn/problem/P3373)（区间乘加）
2. [P5494 线段树分裂](https://www.luogu.com.cn/problem/P5494)（动态维护区间）
3. [P1446 质数判定](https://www.luogu.com.cn/problem/P1446)（质因数分解优化）

---

## 可视化算法演示

### 核心逻辑动画
- **线段树节点更新**：高亮当前修改的叶子节点，递归更新父节点的乘积和掩码。
- **质因数分解**：分解数值时，用不同颜色标记质因数对应的位。
- **欧拉计算**：遍历掩码位时，动态显示每一步的乘法与逆元应用。

### 复古像素风格
- **颜色方案**：8位色（深绿背景，亮黄线段树节点，红色质因数标记）。
- **Canvas动画**：线段树以网格展开，质因数位用像素块点亮。
- **音效触发**：修改时播放“滴”声，查询成功时播放胜利音效。

---

## 代码片段（Siyuan题解核心）

```cpp
const int prime[] = {2,3,5,7,11,...,281}; // 前60个素数
const int invpr[] = {9980997,6653998,...,11153142}; // 对应逆元

struct Node {
    int mul;     // 乘积取模
    long long p; // 质因数掩码
} tree[N<<2];

void pushup(int p) {
    tree[p].mul = tree[p<<1].mul * tree[p<<1|1].mul % mod;
    tree[p].p = tree[p<<1].p | tree[p<<1|1].p;
}

void modify(int x, int v) {
    long long mask = 0;
    for (int i=0; i<60; ++i)
        if (v % prime[i] == 0) mask |= 1LL << i;
    // 更新线段树节点x的mul和mask
}

int query(int l, int r) {
    int product = get_product(l, r); // 区间乘积
    long long mask = get_mask(l, r);  // 质因数掩码
    int ans = product;
    for (int i=0; i<60; ++i) {
        if (mask & (1LL<<i)) 
            ans = ans * (prime[i]-1) % mod * invpr[i] % mod;
    }
    return ans;
}
```

---

## 总结
本题通过线段树维护区间乘积与质因数状态，结合欧拉函数性质，高效处理动态区间查询。核心在于位掩码优化质因数统计，预计算逆元加速公式计算，适合作为线段树与数论结合的典型例题。

---
处理用时：74.89秒
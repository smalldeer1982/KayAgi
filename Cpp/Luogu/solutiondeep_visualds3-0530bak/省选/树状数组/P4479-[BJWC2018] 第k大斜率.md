# 题目信息

# [BJWC2018] 第k大斜率

## 题目描述

在平面直角坐标系上，有 $n$ 个不同的点。任意两个不同的点确定了一条直线。请求出所有斜率存在的直线按斜率从大到小排序后，第 $k$ 条直线的斜率为多少。

为了避免精度误差，请输出斜率向下取整后的结果。（例如：$\lfloor 1.5 \rfloor = 1$，$\lfloor -1.5 \rfloor = -2$）。

## 说明/提示

**【样例说明】**

符合要求的直线的斜率分别为 $-3, -\frac{1}{2}, \frac{2}{3}, 1, 2, \frac{5}{2}$ 。

**【数据规模和约定】**

令 $M$ 为所有斜率存在的直线的数量 。

对于 $10 \%$ 的数据，$1 \le n \le 10$。  
对于 $20 \%$ 的数据，$1 \le n \le 100$，$|x_i|, |y_i| \le {10}^3$。  
对于 $30 \%$ 的数据，$1 \le n \le 1000$。  
对于 $40 \%$ 的数据，$1 ≤ n ≤ 5000$。  
对于另 $20 \%$ 的数据，满足 $k = 1$ 。  
对于另 $20 \%$ 的数据，满足 $1 \le x_i, y_i \le {10}^3$。  
对于 $100 \%$ 的数据，$1 \le n \le 100000$，$1 \le k \le M$，$|x_i|, |y_i| \le {10}^8$。

## 样例 #1

### 输入

```
4 1
-1 -1
2 1
3 3
1 4```

### 输出

```
2```

# AI分析结果



## 算法分类
二分答案 + 二维偏序

---

## 综合分析与结论

### 核心思路
1. **二分答案**：通过二分枚举可能的斜率值，判断大于等于该斜率的直线数量是否满足第k大的要求。
2. **二维偏序转换**：将斜率比较问题转化为点的属性比较问题，通过排序处理一维后，用树状数组或归并排序统计满足条件的点对数。
3. **离散化优化**：当使用树状数组时，需对动态变化的属性值进行离散化以压缩空间。

### 解决难点
1. **避免重复统计**：当两点x坐标相同时，其斜率不存在，需通过排序时优先按x升序、y降序的方式排除干扰。
2. **高效统计顺序对**：利用归并排序的分治特性或树状数组的前缀和特性，在O(n log n)时间内完成统计。
3. **二分边界处理**：正确维护二分区间，确保最终结果向下取整的准确性。

---

## 题解评分（≥4星）

1. **Zilljy258（5星）**
   - **亮点**：代码结构清晰，离散化处理完整，树状数组实现高效。
   - **核心代码**：
     ```cpp
     bool check(int mid) {
         // ...离散化t值，树状数组统计顺序对
     }
     ```

2. **傅思维666（4.5星）**
   - **亮点**：归并排序实现简洁，无需离散化，适合理解二维偏序本质。
   - **核心代码**：
     ```cpp
     void merge_sort(int l, int r) {
         // 归并过程中统计顺序对
     }
     ```

3. **TainityAnle（4星）**
   - **亮点**：树状数组与离散化结合紧密，注释详细便于理解。

---

## 最优思路提炼

1. **二分框架**：在[-2e8, 2e8]区间内二分，每次计算中点mid。
2. **属性转换**：对每个点计算t_i = y_i - mid*x_i，将问题转化为统计满足x_j > x_i且t_j > t_i的点对数。
3. **排序策略**：按x升序、y降序排序，自然过滤x相同的情况。
4. **统计方法**：
   - **归并排序**：在归并过程中统计右侧比当前元素小的个数，累加为总顺序对数。
   - **树状数组**：离散化t值后，按x顺序插入树状数组，查询当前t值的排名前缀和。

---

## 同类型题推荐

1. **P1908 逆序对**：基础二维偏序问题，练习树状数组/归并排序。
2. **P3810 三维偏序**：CDQ分治经典题，拓展高维偏序思路。
3. **P2163 园丁的烦恼**：二维数点问题，巩固离散化与树状数组结合技巧。

---

## 可视化设计

### 动画演示方案
1. **像素风格界面**：以16色像素网格展示平面点分布，红色标记当前处理的点对。
2. **二分过程**：左侧动态显示当前二分区间[mid_low, mid_high]，右侧显示对应统计的顺序对数。
3. **归并排序过程**：用绿色高亮正在合并的子数组，黄色标记已统计的顺序对。
4. **树状数组操作**：动态绘制树状数组结构，蓝色标记更新节点，粉色显示查询路径。

### 交互功能
- **速度调节**：滑动条控制动画速度（0.5x~3x）。
- **单步执行**：按空格键逐帧观察归并排序的分治过程。
- **音效反馈**：合并完成时播放8-bit音效，错误操作触发低沉蜂鸣。

---

## 核心代码实现

### 归并排序法（傅思维666）
```cpp
void merge_sort(int l, int r) {
    if (l == r) return;
    int mid = (l + r) >> 1;
    merge_sort(l, mid);
    merge_sort(mid + 1, r);
    int i = l, j = mid + 1, k = l;
    while (i <= mid && j <= r) {
        if (a[i] <= a[j]) {
            cnt += (r - j + 1); // 统计右侧剩余元素
            tmp[k++] = a[i++];
        } else {
            tmp[k++] = a[j++];
        }
    }
    while (i <= mid) tmp[k++] = a[i++];
    while (j <= r) tmp[k++] = a[j++];
    memcpy(a + l, tmp + l, (r - l + 1) * sizeof(ll));
}
```

### 树状数组法（Zilljy258）
```cpp
bool check(int mid) {
    for (int i = 1; i <= n; i++) 
        p[i].t = p[i].y - (ll)mid * p[i].x;
    sort(p + 1, p + n + 1); // 按x排序已预处理
    
    // 离散化t值
    vector<ll> disc;
    for (int i = 1; i <= n; i++) disc.push_back(p[i].t);
    sort(disc.begin(), disc.end());
    disc.erase(unique(disc.begin(), disc.end()), disc.end());
    
    BIT::clear();
    ll cnt = 0;
    for (int i = 1; i <= n; i++) {
        int rk = lower_bound(disc.begin(), disc.end(), p[i].t) - disc.begin() + 1;
        cnt += BIT::query(rk - 1);
        BIT::update(rk, 1);
    }
    return cnt >= k;
}
```

---

## 个人心得摘录

> "调试时发现x相同的点未被正确过滤，改为y降序排序后AC。二维偏序中排序策略的细节决定成败。" —— 作者Flaw_Owl

> "原以为离散化会很麻烦，但发现每次二分只需重新计算离散排名，树状数组清空即可复用。" —— 作者naroto2022

---

通过系统分析可见，二分结合二维偏序是解决此类问题的通用套路，关键在于熟练运用排序与高效统计方法。归并排序适合代码简洁性优先的场景，而树状数组在大数据量时更具优势。

---
处理用时：86.82秒
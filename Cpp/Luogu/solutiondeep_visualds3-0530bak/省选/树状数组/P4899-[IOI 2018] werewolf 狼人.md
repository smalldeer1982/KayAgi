# 题目信息

# [IOI 2018] werewolf 狼人

## 题目背景

本题为交互题，但在此请提交**完整程序**。

## 题目描述

在日本的茨城县内共有 $N$ 个城市和 $M$ 条道路。这些城市是根据人口数量的升序排列的，依次编号为 $0$ 到 $N - 1$。每条道路连接两个不同的城市，并且可以双向通行。由这些道路，你能从任意一个城市到另外任意一个城市。

你计划了 $Q$ 个行程，这些行程分别编号为 $0$ 至 $Q - 1$。第 $i(0 \leq i \leq Q - 1)$ 个行程是从城市 $S_i$ 到城市 $E_i$。

你是一个狼人。你有两种形态：**人形**和**狼形**。在每个行程开始的时候，你是人形。在每个行程结束的时候，你必须是狼形。在行程中，你必须要变身（从人形变成狼形）恰好一次，而且只能在某个城市内（包括可能是在 $S_i$ 或 $E_i$ 内）变身。

狼人的生活并不容易。当你是人形时，你必须避开人少的城市，而当你是狼形时，你必须避开人多的城市。对于每一次行程 $i(0 \leq i \leq Q - 1)$，都有两个阈值 $L_i$ 和 $R_i(0 \leq L_i \leq R_i \leq N - 1)$，用以表示哪些城市必须要避开。准确地说，当你是人形时，你必须避开城市 $0, 1, \ldots , L_i - 1$ ；而当你是狼形时，则必须避开城市 $R_i + 1, R_i + 2, \ldots , N - 1$。这就是说，在行程 $i$ 中，你必须在城市 $L_i, L_i + 1, \ldots , R_i$ 中的其中一个城市内变身。

你的任务是，对每一次行程，判定是否有可能在满足上述限制的前提下，由城市 $S_i$ 走到城市 $E_i$。你的路线可以有任意长度。

## 说明/提示

**限制条件**

- $2 \leq N \leq 200, 000$
- $N - 1 \leq M \leq 400, 000$
- $1 \leq Q \leq 200, 000$
- 对于每个 $0 \leq j \leq M - 1$
    - $0 \leq X_j \leq N - 1$
    - $0 \leq Y_j \leq N - 1$
    - $X_j \neq Y_j$
- 你可以通过道路由任意一个城市去另外任意一个城市。
- 每一对城市最多只由一条道路直接连起来。换言之，对于所有 $0 \leq j < k \leq M - 1$，都有 $(X_j, Y_j) \neq (X_k, Y_k)$ 和 $(Y_j, X_j) \neq (X_k, Y_k)$
- 对于每个 $0 \leq i \leq Q - 1$
    - $0 \leq L_i \leq S_i \leq N - 1$
    - $0 \leq E_i \leq R_i \leq N - 1$
    - $S_i \neq E_i$
    - $L_i \leq R_i$

**子任务**

- 1.（7 分）$N \leq 100$，$M \leq 200$，$Q \leq 100$。
- 2.（8 分）$N \leq 3, 000$，$M \leq 6, 000$，$Q \leq 3, 000$。
- 3.（34 分）$M = N - 1$ 且每个城市最多与两条路相连（所有城市是以一条直线的形式连起来）。
- 4.（51 分）没有附加限制。

## 样例 #1

### 输入

```
6 6 3
5 1
1 2
1 3
3 4
3 0
5 2
4 2 1 2
4 2 2 2
5 4 3 4
```

### 输出

```
1
0
0
```

## 样例 #2

### 输入

```
10 9 10
6 7
1 5
8 0
2 9
9 4
2 7
8 5
6 0
3 4
4 9 0 9
8 1 8 9
1 8 1 8
8 3 5 5
8 9 3 9
0 1 0 2
9 0 6 6
1 7 1 8
9 4 5 6
9 5 0 9
```

### 输出

```
1
1
1
0
1
1
0
1
0
1
```

# AI分析结果



## 算法分类
Kruskal 重构树 + 二维数点

---

## 综合分析与结论

### 核心思路
1. **问题转化**：将路径划分为人形阶段（≥L）和狼形阶段（≤R），寻找一个中间切换点。  
2. **Kruskal 重构树**：  
   - 树A：边权为两端点较小值，最大生成树重构，用于求取人形可达区域  
   - 树B：边权为两端点较大值，最小生成树重构，用于求取狼形可达区域  
3. **子树交集判定**：将两棵树的 DFS 序映射为二维平面上的点，转化为二维数点问题。  

### 解决难点
- **重构树构建**：正确理解边权选择和生成树类型（最大/最小）对可达区域的影响  
- **倍增跳跃**：在重构树上找到满足条件的最小子树根节点  
- **高效查询**：通过主席树或离线树状数组快速判断两个 DFS 序区间的交集  

### 可视化设计
1. **重构树动画**：  
   - 分步展示边的排序、节点合并过程  
   - 高亮当前处理的边，用不同颜色区分两棵重构树  
2. **二维数点演示**：  
   - 在平面坐标系中绘制 DFS 序映射点，动态显示查询矩形区域  
   - 使用红色高亮交集点，绿色表示存在可行解  
3. **复古像素风格**：  
   - 8-bit 音效：节点合并时播放 "blip" 音效，查询命中时播放上升音阶  
   - Canvas 绘制：用方格表示节点，箭头表示父子关系，动态更新子树范围  

---

## 题解清单 (4星及以上)

1. **y2823774827y（4.5星）**  
   - **亮点**：代码简洁，树状数组离线处理效率高  
   - **关键代码**：通过两棵重构树的 DFS 序生成事件点，离线排序后用树状数组统计  

2. **Nemlit（5星）**  
   - **亮点**：详细解释重构树原理，主席树实现清晰  
   - **核心步骤**：将第二棵树的 DFS 序映射到第一棵树，建立主席树进行区间查询  

3. **lhm_（4.5星）**  
   - **创新点**：线段树合并实现子树交集查询  
   - **关键思路**：在第二棵树上建立动态线段树，直接查询第一棵树的 DFS 序区间  

---

## 最优思路与代码实现

### 关键技巧
- **重构树倍增跳跃**：通过预处理父节点数组，快速定位满足条件的子树根  
- **DFS 序映射**：将两棵树的 DFS 序转化为二维坐标，实现高效的区间查询  

### 核心代码示例
```cpp
// Kruskal 重构树构建（以树A为例）
void build_A() {
    sort(e, e + m, [](Edge a, Edge b) { return max(a.x, a.y) < max(b.x, b.y); });
    for (int i = 1; i <= 2 * n; i++) fa[i] = i;
    int tot = n;
    for (auto [u, v] : e) {
        int fu = find(u), fv = find(v);
        if (fu == fv) continue;
        val[++tot] = max(u, v);
        addEdge(tot, fu); addEdge(tot, fv);
        fa[fu] = fa[fv] = tot;
    }
}

// 主席树查询交集
int query(int S, int T, int L, int R) {
    int rootA = jump_A(S, L); // 树A的子树根
    int rootB = jump_B(T, R); // 树B的子树根
    int l1 = dfnA[rootA], r1 = dfnA[rootA] + sizeA[rootA] - 1;
    int l2 = dfnB[rootB], r2 = dfnB[rootB] + sizeB[rootB] - 1;
    return query_persistent(l2, r2, l1, r1); // 主席树区间查询
}
```

---

## 相似题目推荐
1. **P4197 Peaks**（Kruskal 重构树 + 主席树）  
2. **P4768 [NOI2018] 归程**（重构树 + 最短路）  
3. **P3304 [SDOI2013] 直径**（DFS 序应用）

---

## 可视化算法演示
**步骤分解**：  
1. **重构树构建动画**：  
   - 初始显示所有节点和边  
   - 按边权排序后，逐步合并节点，生成树结构  
   - 高亮当前合并的边，显示新生成的父节点  

2. **倍增跳跃演示**：  
   - 输入查询参数 L 和 R  
   - 在两棵树上动态显示跳跃过程，高亮每次跳跃的父节点  

3. **二维数点交互**：  
   - 平面坐标系中显示所有点的 DFS 序映射  
   - 绘制当前查询的矩形区域，动态展示主席树查询过程  

**复古风格实现**：  
- 使用 16 色调色板，节点用 8x8 像素块表示  
- Canvas 绘制网格坐标系，查询时显示扫描线效果  
- 音效使用 Web Audio API 生成方波音效  

```javascript
// 示例：8-bit 音效生成
function playSound(freq, duration) {
    const ctx = new AudioContext();
    const osc = ctx.createOscillator();
    osc.type = 'square';
    osc.frequency.setValueAtTime(freq, ctx.currentTime);
    osc.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + duration / 1000);
}
```

---

## 总结
本题核心在于通过 Kruskal 重构树将路径限制转化为子树问题，结合二维数点实现高效查询。理解重构树的生成逻辑和 DFS 序映射是关键突破点，建议通过动态演示加深对倍增跳跃和区间查询过程的理解。

---
处理用时：86.06秒
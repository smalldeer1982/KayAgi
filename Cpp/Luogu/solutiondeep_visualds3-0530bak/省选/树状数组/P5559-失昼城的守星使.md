# 题目信息

# 失昼城的守星使

## 题目背景

> 月伏潮汐生，星染万屿寂，无晦明之变化者，是为失昼。   ————《失昼城手札·起源》

失昼城四面环海，建城于7325年前。

失昼城没有黑夜白天的变化，一轮明月自建城伊始就挂在天空，故名失昼。


失昼城城主月凌霜，掌控着失昼城的守星塔，守星塔在终日无昼的失昼城中作为照明的灯塔，一直是城里人们的精神寄托，她的另一个身份是失昼城的守星使，比起作为城主，月凌霜更喜欢守着守星塔。

失昼城的特殊环境导致其空间异常不稳定，根据失昼城城史记载，七千多年历史的失昼城，其和平的时间总共不超过三百年，其他大部分时间失昼城局部地区都在空间风暴的笼罩之下，依托于特殊空间存在的守星塔，同时兼具着向人们传递信息的功能，在不稳定的空间影响下，这是唯一能够维持信号稳定的方法。



## 题目描述

失昼城共由$N$座岛屿组成，由$N-1$条传递信息的空间通道联通。

作为失昼城的守星使，月凌霜具有部署守星塔的能力，具体而言，为了依靠特殊空间波动向每个有居民居住的岛屿传递消息，月凌霜可以任意数量地部署守星塔，每座岛屿只能部署一座守星塔，**但是同一时刻所有部署的守星塔必须依靠空间通道连成一条链**。

失昼城常年受到空间风暴的困扰，常常会出现某座岛屿遭受空间风暴，岛上全体居民被迫离开岛屿，此时，**守星塔不再需要向该地传输消息**，等到空间风暴散去，居民重新回到这里，**守星塔才需要恢复向该地的信息传输**。

由于空间波动的干扰，守星塔传递消息必须依靠联通岛屿的空间通道完成，具体而言，如果一座守星塔要向一座岛屿传递消息，**其消耗的能量为该座守星塔所处的岛屿到需要接收消息的岛屿的所有空间通道能耗总和**，当然，如果一座守星塔向自身所处的岛屿发送消息，则不需要消耗能量，守星塔对岛屿传递消息的信号波动互相独立，也就是说，**每座守星塔对于每座岛屿的能量传输互不干扰**。

作为城主兼守星使，月凌霜近期正在研究怎样部署守星塔才能使消息传递所消耗的能量最小，现在月凌霜已经找到了记载失昼城七千多年来空间风暴的爆发情况和当时失昼城的守星塔部署的资料，由于历史过于久远，每次能量的消耗情况已经不得而知，现在月凌霜希望你帮助她还原这些史料，具体详见输入格式。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/74843.png)

特殊性质$1$：$v_{i}=u_{i}+1$

特殊性质$2$：月凌霜所有的询问的$x$和$y$相同。

特殊性质$3$：月凌霜所有的询问的$x=1$。

对于所有的$w_{i}$，保证$0$<=$w_{i}$<=$10^{5}$

对于$100\%$的数据，保证$n,m\leq 200000,0\leq Type\leq 7$.

样例1解释：

![](https://cdn.luogu.com.cn/upload/pic/74831.png)

初始图像如左图。

对于第一个询问如中图，有$2,3,5$有居民，所以$ans_2=ans_3=0,ans_5=7.$所以$ans=7$.

对于第二组询问如右图，$ans_2=2+3=5,ans_3=0,ans_5=7,$,因此$ans=7+5=12$.

样例2解释：

![](https://cdn.luogu.com.cn/upload/pic/74836.png)

初始图如左上。

询问$1$点如图右上，存在$1,2,3,6$有居民。
$ans_1=0,ans_2=3,ans_3=5,ans_6=8+2=10.$因此$ans=3+5+10=18$

1操作后所有有居民点如左下。

接下来的操作图为右下，同上有$ans_1=0,ans_2=3,ans_3=0,ans_5=9,ans_6=0$,所以$ans=3+9=12$.

## 样例 #1

### 输入

```
5 2 0
1 2 2
1 3 3
4 3 2
5 3 7
0 1 1 0 1
2 2 4
2 4 3```

### 输出

```
7
12```

## 样例 #2

### 输入

```
6 3 0
2 1 3
3 1 5
4 1 2
6 4 8
4 5 9
1 1 1 0 0 1
2 1 1
1 5
2 3 6```

### 输出

```
18
12```

# AI分析结果



## 算法分类
**树链剖分 + 线段树**

---

## 题解思路与解决难点
### **核心问题拆解**
需要高效维护所有黑点到指定链的最短距离之和。关键难点在于如何将距离公式分解为可维护的数学项，并通过树链剖分与线段树实现动态更新。

### **题解对比与核心思路**
1. **Graphcity题解**  
   - **思路**：将距离拆分为两部分（链在 LCA 子树内/外），推导出四类贡献式（s_i, sd_i, d_i s_i, d_{fa_i} s_i），维护四棵线段树。  
   - **难点**：推导复杂公式，需多棵线段树同步更新。  
   - **亮点**：数学推导严谨，覆盖所有情况。

2. **EndSaH题解**  
   - **思路**：利用路径标记法，将黑点到根的路径边权累加，查询时通过两次路径和计算。  
   - **难点**：理解路径标记的物理意义（重复路径长度）。  
   - **亮点**：代码简洁，维护单一线段树，时间复杂度更优。

3. **Hoks题解**  
   - **思路**：基于暴力公式优化，拆解距离为 LCA 相关项，树剖维护子树信息。  
   - **难点**：公式转化与子树信息维护。  
   - **亮点**：思路直观，适合快速实现。

---

## 题解评分（≥4星）
1. **EndSaH（5星）**  
   - **思路清晰度**：公式拆解巧妙，路径标记法直观。  
   - **代码可读性**：单线段树维护，逻辑简洁。  
   - **优化程度**：O(n log²n) 实现，效率较高。  

2. **Graphcity（4星）**  
   - **思路清晰度**：覆盖所有情况，推导详尽。  
   - **代码可读性**：多线段树维护稍显复杂。  
   - **优化程度**：实现全面但代码量大。  

3. **Hoks（4星）**  
   - **思路清晰度**：暴力优化思路清晰。  
   - **代码可读性**：树剖模板复用，易理解。  
   - **实践性**：适合快速上手，但效率略低。  

---

## 最优思路提炼
**EndSaH 的路径标记法**  
1. **公式拆解**：利用 `dis(x,链) = dis(x, LCA) - 重复路径`，通过路径标记统计重复路径长度。  
2. **维护变量**：  
   - `sum`：所有黑点的 `dis` 之和。  
   - 线段树维护每条边的累加次数（黑点到根的路径边权标记）。  
3. **查询逻辑**：  
   - 计算 `sum + cnt * dis(LCA) - 2 * 重复路径和`。  

---

## 同类型题目
1. **[LNOI2014] LCA**（路径标记与深度查询）  
2. **P3384 树链剖分模板**（路径修改与查询）  
3. **P4211 子树统计与路径查询**  

---

## 推荐题目
1. **P4211 [LNOI2014] LCA**  
2. **P3384 【模板】树链剖分**  
3. **P2486 [SDOI2011]染色**  

---

## 核心代码实现（EndSaH 解法）
```cpp
void Add_root(int u, int addval) {
    while (top[u] != 1)
        Modify(dfn[top[u]], dfn[u], addval), u = fa[top[u]];
    Modify(2, dfn[u], addval); // 跳过根节点到自身的边（权为0）
}

LL Query_chain(int u, int v) {
    LL res = 0;
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        res += Query(dfn[top[u]], dfn[u]);
        u = fa[top[u]];
    }
    if (dep[u] > dep[v]) swap(u, v);
    return res + Query(dfn[u] + 1, dfn[v]); // 跳过LCA到自身的边
}

// 查询答案计算
LL ans = sum + cnt * dis_lca - 2 * Query_chain(1, lca) - Query_chain(x, y);
```

---

## 可视化设计
### **动画方案**
1. **树结构展示**：用 Canvas 绘制树形结构，节点颜色区分黑/白。  
2. **路径高亮**：查询链以红色标记，黑点到根的路径以蓝色渐变显示。  
3. **线段树更新**：右侧面板显示线段树节点，动态更新路径标记值。  

### **像素风格实现**
- **颜色方案**：黑点（黄色像素块），白点（灰色），查询链（红色边框）。  
- **音效**：翻转颜色时播放“哔”声，查询成功时播放“叮咚”音效。  
- **自动演示**：模拟 AI 自动执行翻转与查询，展示路径标记过程。  

### **交互功能**
- **步进控制**：支持暂停/继续，单步执行线段树更新。  
- **参数调节**：调整树的大小与动画速度。  

---

## 总结
通过路径标记与树链剖分，将复杂的距离求和转化为高效的线段树操作。EndSaH 的解法以简洁的代码和清晰的公式拆解脱颖而出，适合作为核心实现参考。

---
处理用时：72.87秒
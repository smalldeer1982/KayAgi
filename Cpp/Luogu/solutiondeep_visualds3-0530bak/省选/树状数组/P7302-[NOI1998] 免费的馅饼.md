# 题目信息

# [NOI1998] 免费的馅饼

## 题目描述

SERKOI 最新推出了一种叫做“免费馅饼”的游戏：游戏在一个舞台上进行。舞台的宽度为 $w$ 格（从左到右依次用 $1$ 到 $w$ 编号），游戏者占一格。开始时游戏者可以站在舞台的任意位置，手里拿着一个托盘。下图为天幕的高度为 $4$ 格时某一个时刻游戏者接馅饼的情景。

![](https://cdn.luogu.com.cn/upload/image_hosting/1gcg9awi.png)

游戏开始后，从舞台天幕顶端的格子中不断出现馅饼并垂直下落。游戏者左右移动去接馅饼。游戏者每秒可以向左或向右移动一格或两格，也可以站在原地不动。

当馅饼在某一时刻恰好到达游戏者所在的格子中，游戏者就收集到了这块馅饼。当馅饼落在一个游戏者不在的格子里时该馅饼就消失。

写一个程序，帮助我们的游戏者收集馅饼，使得所收集馅饼的分数之和最大。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq w \leq 10^8$，$1 \leq n \leq 10^5$，$1\leq t_i \leq 10^8$，$1\leq p_i \leq w$，$1\leq v_i \leq 1000$。

## 样例 #1

### 输入

```
3 4
1 2 3
5 2 3
6 3 4
1 1 5
 ```

### 输出

```
12```

# AI分析结果



# [NOI1998] 免费的馅饼 题解分析

## 一、算法分类
动态规划 + 二维偏序优化（树状数组/离散化）

---

## 二、题解思路与核心难点

### 核心思路
1. **暴力DP**  
   设 $f[i]$ 为接到第 $i$ 个馅饼的最大分数，转移条件为 $\text{abs}(p_i-p_j)\leq 2(t_i-t_j)$，但 $O(n^2)$ 无法通过。

2. **二维偏序优化**  
   将条件拆解为两个不等式：
   $$
   \begin{cases}
   2t_i - p_i \geq 2t_j - p_j \\
   2t_i + p_i \geq 2t_j + p_j
   \end{cases}
   $$
   - 按第一个条件排序，第二个条件离散化后用树状数组维护最大值。

### 解决难点
1. **条件转化**：通过数学推导将绝对值条件转化为二维偏序问题。
2. **离散化处理**：将第二个条件的值域压缩，便于树状数组操作。
3. **数据结构优化**：树状数组维护区间最大值，将时间复杂度从 $O(n^2)$ 降至 $O(n\log n)$。

---

## 三、题解评分（≥4星）

### 1. xiezheyuan（⭐⭐⭐⭐⭐）
- **亮点**：清晰推导二维偏序条件，代码简洁，树状数组维护逻辑明确。
- **代码片段**：
  ```cpp
  sort(a + 1, a + n + 1, cmp); // 按第一个条件排序
  for (int i = 1; i <= n; i++) {
      f[i] = query(a[i].x) + a[i].v; // 查询树状数组
      update(a[i].x, f[i]); // 更新树状数组
  }
  ```

### 2. SSL_TJH_蒟蒻（⭐⭐⭐⭐）
- **亮点**：详细图解二维偏序，代码注释丰富，离散化步骤清晰。
- **关键注释**：  
  > “先按第一个条件排序，再用树状数组维护第二个条件的大小关系。”

### 3. Seauy（⭐⭐⭐⭐）
- **亮点**：引入坐标变换思想，将问题转化为 LIS 问题，提供独特视角。
- **核心代码**：
  ```cpp
  sort(pies+1, pies+n+1, [](Pie x, Pie y){ 
      return x.l > y.l; // 按变换后的坐标排序
  });
  ```

---

## 四、最优思路提炼

### 关键步骤
1. **条件拆分**：将 $\text{abs}(p_i-p_j)\leq 2(t_i-t_j)$ 拆解为两个线性不等式。
2. **排序与离散化**：按第一个条件排序，对第二个条件离散化。
3. **树状数组维护**：动态维护满足条件的最大值，实现高效转移。

### 可视化设计
- **动画演示**：  
  ![二维偏序优化动态演示](https://via.placeholder.com/600x400?text=Tree+Array+Update+Demo)  
  1. 初始状态：所有馅饼按 $2t-p$ 排序。
  2. 离散化处理：将 $2t+p$ 映射到连续区间。
  3. 树状数组更新：动态显示查询和更新操作，高亮当前处理的馅饼。
- **像素风格**：用 8-bit 色块表示馅饼位置，音效提示每次查询/更新。

---

## 五、类似题目推荐
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)  
   （树状数组求逆序对，类似离散化思路）
2. [P1020 导弹拦截](https://www.luogu.com.cn/problem/P1020)  
   （LIS 问题，二维偏序的经典应用）
3. [CF1311F Moving Points](https://codeforces.com/problemset/problem/1311/F)  
   （坐标变换与树状数组结合）

---

## 六、核心代码实现（树状数组优化版）

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Pie { int t, p, v, x, y; };
int w, n, tree[100010], ans;

bool cmp(Pie a, Pie b) { return a.y > b.y; }

void update(int x, int val) {
    for (; x <= n; x += x & -x)
        tree[x] = max(tree[x], val);
}

int query(int x) {
    int res = 0;
    for (; x; x -= x & -x)
        res = max(res, tree[x]);
    return res;
}

int main() {
    cin >> w >> n;
    vector<Pie> pies(n+1);
    vector<int> disc;
    for (int i = 1; i <= n; ++i) {
        cin >> pies[i].t >> pies[i].p >> pies[i].v;
        pies[i].x = 2 * pies[i].t - pies[i].p;
        pies[i].y = 2 * pies[i].t + pies[i].p;
        disc.push_back(pies[i].y);
    }
    
    // 离散化处理
    sort(disc.begin(), disc.end());
    disc.erase(unique(disc.begin(), disc.end()), disc.end());
    for (int i = 1; i <= n; ++i)
        pies[i].y = lower_bound(disc.begin(), disc.end(), pies[i].y) - disc.begin() + 1;
    
    // 按第一个条件排序
    sort(pies.begin()+1, pies.end(), cmp);
    
    for (int i = 1; i <= n; ++i) {
        int current = query(pies[i].y) + pies[i].v;
        ans = max(ans, current);
        update(pies[i].y, current);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 七、总结
本题核心在于将动态规划的转移条件转化为二维偏序问题，通过排序和树状数组优化实现高效查询。关键是通过数学推导拆分条件，并合理利用数据结构维护状态。类似问题可参考二维偏序和树状数组/线段树的结合应用。

---
处理用时：68.27秒
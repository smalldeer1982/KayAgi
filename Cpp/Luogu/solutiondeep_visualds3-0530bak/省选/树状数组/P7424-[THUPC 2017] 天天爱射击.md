# 题目信息

# [THUPC 2017] 天天爱射击

## 题目描述

小 C 爱上了一款名字叫做《天天爱射击》的游戏。如图所示，这个游戏有一些平行于 $x$ 轴的木板。现在有一些子弹，按顺序沿着 $y$ 轴方向向这些木板射去。第 $i$ 块木板被 $S_i$ 个子弹贯穿以后，就会碎掉消失。一个子弹可以贯穿其弹道上的全部木板，特别的，如果一个子弹触碰到木板的边缘，也视为贯穿木板。

小 C 现在知道了游戏中 $n$ 块木板位置，以及知道了 $m$ 个子弹射击位置。现在问你每个子弹射出去以后，有多少木板会碎掉？

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/ocqlbnl3.png)
#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。

$\text{upd}2021.7.6$：感谢 @[jiangbowen](https://www.luogu.com.cn/user/366807) 提供的一组 hack 数据，不计分，但若不通过 hack 数据则不算通过此题。

## 样例 #1

### 输入

```
3 2
1 3 1
2 4 2
3 4 1
2
3```

### 输出

```
1
2```

# AI分析结果



## 算法分类
整体二分 / 主席树（可持久化线段树）

---

## 核心思路与难点分析

### 题解思路对比
1. **整体二分**（Suzt_ilymtics、JeffZhao 等）：
   - **核心逻辑**：将木板与子弹统一处理，通过二分每个木板被击碎的时间，利用树状数组统计区间子弹数
   - **关键步骤**：
     - 分治子弹时间区间 `[l, r]`
     - 对 `[l, mid]` 的子弹用树状数组统计覆盖次数
     - 根据木板剩余耐久值划分到左右区间递归处理
   - **难点**：处理未被击碎木板时的剩余耐久调整，以及树状数组的离线清空操作

2. **主席树**（MuYC、wdgm4 等）：
   - **核心逻辑**：将子弹按坐标排序后构建主席树，查询木板区间内的第 `s_i` 小时间
   - **关键步骤**：
     - 预处理每个坐标的子弹时间序列
     - 构建可持久化线段树维护时间轴
     - 查询区间 `[l, r]` 的第 `s_i` 小时间值
   - **难点**：处理同一坐标多子弹时的版本维护，无效子弹（未击碎）的特殊处理

---

## 最优题解（≥4星）

1. **Suzt_ilymtics（整体二分，5星）**
   - **亮点**：代码结构清晰，注释详细，处理 `m+1` 的特殊情况巧妙
   - **核心代码**：
     ```cpp
     void Solve(int l, int r, int ql, int qr) {
         if(ql > qr) return;
         if(l == r) { // 统计答案
             for(int i = ql; i <= qr; ++i) 
                 if(q[i].type) ans[l]++;
             return;
         }
         int mid = (l + r) >> 1;
         // 树状数组插入子弹并划分木板
     }
     ```

2. **MuYC（主席树，4.5星）**
   - **亮点**：将问题转化为静态区间第k小，时空复杂度最优
   - **核心代码**：
     ```cpp
     int Get(int u, int v, int l, int r, int k) {
         if(l == r) return l;
         int sum = T[T[v].ls].sum - T[T[u].ls].sum;
         if(k <= sum) return Get(T[u].ls, T[v].ls, l, mid, k);
         else return Get(T[u].rs, T[v].rs, mid+1, r, k - sum);
     }
     ```

3. **Alex_Wei（整体二分优化，4星）**
   - **亮点**：离散化优化空间，实现高效离线处理
   - **关键优化**：在分治前离散化坐标，减少树状数组操作范围

---

## 关键技巧与同类型题

### 最优技巧提炼
- **整体二分模板**：将操作与询问统一分治，树状数组维护动态区间和
- **主席树转化**：将子弹时间映射为值域，转换为区间第k小问题
- **无效处理技巧**：引入 `m+1` 虚拟子弹处理未被击碎的情况

### 同类型题推荐
1. [P3527 MET-Meteors](https://www.luogu.com.cn/problem/P3527)（整体二分经典题）
2. [P3834 静态区间第k小](https://www.luogu.com.cn/problem/P3834)（主席树模板）
3. [P2617 Dynamic Rankings](https://www.luogu.com.cn/problem/P2617)（带修区间第k小）

---

## 可视化设计

### 整体二分动画方案
1. **分治过程可视化**：
   - **颜色标记**：当前二分区间 `[l, r]` 用红框高亮，已处理子弹显示为蓝色圆点
   - **树状数组操作**：插入子弹时显示绿色闪烁，统计木板时黄色覆盖区间
   - **分组动画**：木板根据耐久值分裂为左右两组，用左右箭头示意

2. **交互功能**：
   - **步进控制**：单步执行分治过程，可调节二分裂速度
   - **数据跟踪**：点击木板显示当前剩余耐久，点击子弹显示覆盖区间

### 复古像素风格示例（JavaScript伪代码）
```javascript
// Canvas绘制子弹与木板
function drawBullet(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*10, y*10, 8, 8); // 8x8像素方块
}

// 音效触发
function playSound(effect) {
    const sfx = {
        split: new Audio('data:audio/wav;base64,UklGRl9...'), 
        hit: new Audio('data:audio/wav;base64,UklGRl9...')
    };
    sfx[effect].play();
}
```

---

## 核心代码实现（整体二分）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;

struct Node { int l,r,s,type,id; };
int ans[N],n,m;
vector<Node> q;

struct BIT {
    int tr[N];
    void add(int x,int v) { for(;x<N;x+=x&-x) tr[x]+=v; }
    int query(int x) { int res=0; for(;x;x-=x&-x) res+=tr[x]; return res; }
} T;

void solve(int l,int r,vector<Node>& nodes) {
    if(nodes.empty()) return;
    if(l == r) {
        for(auto& t:nodes) 
            if(t.type) ans[l]++;
        return;
    }
    
    int mid=(l+r)>>1;
    vector<Node> left,right;
    
    // 处理[l,mid]的子弹
    for(auto& t:nodes) {
        if(!t.type && t.id<=mid) T.add(t.l,1);
    }
    
    // 划分木板
    for(auto& t:nodes) {
        if(t.type) {
            int cnt=T.query(t.r)-T.query(t.l-1);
            if(cnt >= t.s) left.push_back(t);
            else t.s -= cnt, right.push_back(t);
        } else {
            if(t.id<=mid) left.push_back(t);
            else right.push_back(t);
        }
    }
    
    // 清空树状数组
    for(auto& t:nodes) 
        if(!t.type && t.id<=mid) T.add(t.l,-1);
    
    solve(l,mid,left);
    solve(mid+1,r,right);
}

int main() {
    scanf("%d%d",&n,&m);
    for(int i=1,l,r,s;i<=n;i++) {
        scanf("%d%d%d",&l,&r,&s);
        q.push_back({l,r,s,1,i});
    }
    for(int i=1,x;i<=m;i++) {
        scanf("%d",&x);
        q.push_back({x,0,0,0,i});
    }
    solve(1,m+1,q);
    for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
    return 0;
}
```

---
处理用时：80.18秒
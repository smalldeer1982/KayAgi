# 题目信息

# [USACO22OPEN] Up Down Subsequence P

## 题目描述

Farmer John 的 $N$ 头奶牛（$2 \leq N \leq 3\cdot 10^5$），编号为 $1 \ldots N$，排列成 $1\ldots N$ 的一个排列 $p_1,p_2,\ldots,p_N$。另外给定一个长为 $N-1$ 的字符串，由字母 U 和 D 组成。请求出最大的 $K\le N-1$，使得存在 $p$ 的一个子序列 $a_0,a_1,\ldots,a_{K}$，满足对于所有 $1\le j\le K$，当字符串中第 $j$ 个字母是 U 时 $a_{j - 1} < a_j$，当字符串中的第 $j$ 个字母是 D 时 $a_{j - 1} > a_j$。


## 说明/提示

【样例解释 1】

我们可以选择 $[a_0,a_1,a_2,a_3,a_4]=[p_1,p_2,p_3,p_4,p_5]$；整个排列与给定的字符串相一致。

【样例解释 2】

我们可以选择 $[a_0,a_1,a_2,a_3]=[p_1,p_3,p_4,p_5]$。

【测试点性质】

- 测试点 3-4 满足 $N\le 500$。
- 测试点 5-8 满足 $N\le 5000$。
- 测试点 9-12 中，字符串中的 U 均在 D 之前。
- 测试点 13-22 没有额外限制。


## 样例 #1

### 输入

```
5
1 5 3 4 2
UDUD```

### 输出

```
4```

## 样例 #2

### 输入

```
5
1 5 3 4 2
UUDD```

### 输出

```
3```

# AI分析结果



**唯一算法分类**  
动态规划 + 树状数组优化

---

### 题解思路与算法要点

**核心思路**  
使用动态规划维护每个位置的最长有效子序列长度，利用树状数组快速查询前缀最大值。定义两个树状数组分别处理上升（U）和下降（D）的情况：

1. **状态定义**  
   `f[i]` 表示以 `p[i]` 结尾的子序列能匹配的最长长度。  
   对每个元素 `p[i]`，根据当前字符是 U 还是 D，分别查询树状数组中的最大值。

2. **树状数组优化**  
   - **U 操作**：查询比当前值小的前缀最大值（`b1` 维护上升序列）  
   - **D 操作**：查询比当前值大的后缀最大值（`b2` 维护下降序列，通过将值映射为 `n - a[i]` 转化为前缀查询）

3. **更新规则**  
   每次计算完 `f[i]` 后，根据下一个字符的类型（U/D）更新对应的树状数组，为后续元素提供查询依据。

**解决难点**  
- 传统 DP 时间复杂度为 O(n²)，无法处理 3e5 规模。树状数组将查询和更新优化到 O(log n)。  
- 通过反向映射（`n - a[i]`）将下降序列转化为升序查询，复用树状数组逻辑。

---

### 题解评分（≥4星）

1. **xiaoyaowudi（5星）**  
   - 思路清晰：直接定义状态转移方程，树状数组维护极值  
   - 代码简洁：仅 20 行核心逻辑，双树状数组高效实现  
   - 时间复杂度 O(n log n)，完美通过最大数据规模  

2. **Elma_（4星）**  
   - 创新性：分段处理连续 U/D 段，贪心结合 DP  
   - 实现复杂：需维护多个树状数组和分段逻辑，代码较长  

3. **Purslane（4星）**  
   - 贪心思路：维护每个位置的最远匹配点  
   - 代码简洁性：类似最优解，但缺少严格证明  

---

### 最优思路提炼

**关键技巧**  
- **树状数组极值维护**：将序列值离散化为树状数组下标，实现 O(1) 更新和 O(log n) 查询  
- **反向映射**：用 `n - a[i]` 将下降序列问题转化为升序查询  
- **动态规划状态压缩**：仅维护当前最长长度，无需记录完整路径  

**同类型题套路**  
- 最长递增子序列（LIS）  
- 交替子序列问题（如 [LeetCode 376. Wiggle Subsequence](https://leetcode.com/problems/wiggle-subsequence/)）  

---

### 推荐相似题目

1. **P1020 [NOIP1999 普及组] 导弹拦截**（树状数组优化 LIS）  
2. **P4303 [AHOI2006] 基因匹配**（最长公共子序列优化）  
3. **P2782 最长公共上升子序列**（综合 LIS 和 LCS 的优化）

---

### 算法可视化设计

**动画方案**  
1. **元素高亮**：当前处理的 `p[i]` 标记为红色，树状数组节点更新时闪烁黄色  
2. **树状数组结构**：以柱状图展示 `b1`（U）和 `b2`（D）的当前状态  
3. **匹配过程**：  
   - U 字符时，显示从左侧较小值区域向上箭头  
   - D 字符时，显示从右侧较大值区域向下箭头  
4. **步进控制**：支持暂停/继续，单步观察树状数组更新  

**复古像素风格**  
- **颜色方案**：8-bit 调色板（红/黄/蓝）表示不同操作  
- **音效**：  
  - 更新树状数组时播放 "哔" 声  
  - 找到更优解时播放上升音阶  

---

### 核心代码实现

```cpp
int b1[N], b2[N];
void upd(int *b, int x, int v) {
    for (; x < N; x += (x & -x)) b[x] = max(b[x], v);
}
int qry(int *b, int x) {
    int ans = 0;
    for (; x; x -= (x & -x)) ans = max(ans, b[x]);
    return ans;
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
    scanf("%s", s + 1);
    int ans = 0;
    for (int i = 1; i <= n; ++i) {
        int f = max(qry(b1, a[i] - 1), qry(b2, n - a[i]));
        ans = max(ans, f);
        if (s[f + 1] == 'U') upd(b1, a[i], f + 1);
        else upd(b2, n - a[i] + 1, f + 1);
    }
    printf("%d\n", ans);
}
```

**代码解释**  
- `b1` 维护上升序列（U），`b2` 维护下降序列（D）  
- 对每个元素 `a[i]`，查询已有序列中的最大值，并根据下一个字符类型更新树状数组

---
处理用时：62.32秒
# 题目信息

# 「GMOI R2-T3」粒子环游

## 题目背景

热爱珂学的小 Z 正在进行一项无聊的实验。

## 题目描述

实验室中有一个由 $n$ 个实验腔连接而成的环形轨道，其中第 $i$ 个实验腔顺时针连向第 $i+1$ 个实验腔（特别的，第 $n$ 个实验腔连向第 $1$ 个实验腔）。同时还有一个标号为 $n+1$ 的新建实验腔要接入这个环形轨道。它可以接在任意两个原本相连的实验腔之间。

第 $i$ 个实验腔可以将带电荷量为 $Q$ 的粒子运输到它的下一个实验腔，这个过程花费的能量为 $\vert Q \vert \times c_i$。除此之外，第 $i$ 个实验腔本身就存储了量为 $e_i$ 的电荷（电荷量有正负）。由于众所周知的电荷守恒定律，第 $n+1$ 个实验腔储存的电荷量与前 $n$ 个实验腔储存的总电荷量的代数和为 $0$。

小 Z 有一个原本不带电的粒子。等到第 $n+1$ 个实验腔接入轨道后，他要任选一个实验腔（包括第 $n+1$ 个）作为出发点，将粒子放入，并使之在实验腔的能量驱动下顺时针环游一周回到出发点。粒子每到达一个实验腔（包括出发点），它所带电荷量就会变成原来所带的电荷量和这个实验腔所储存的电荷量的代数和。

**注意：电荷量会先加上实验腔所含电荷量，再计算能量贡献。**

现在，小 Z 想知道，在所有接入新建实验腔并选定出发点的方案中，粒子环游一周所需的能量最少为多少？

## 说明/提示

样例 $1$ 解释：一种最优方案为将 $4$ 号实验腔接在 $3$ 号实验腔与 $1$ 号实验腔之间，以 $4$ 号实验腔为出发点，花费能量为 $ 1\times 2\ +\ 4\times 1\ + \vert -1 \vert \times 3 \ +\ 0 \times 2 =9$。

**本题采用 Subtask 捆绑测试。**

| Subtask | $n\le$ | $c_i\le$ | $\vert e_i\vert$ | 特殊性质 | 对应测试点 | 总分 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $300$ | $100$ | $100$ | $-$ | $1\sim 5$ | $10$ |
| $1$ | $10^3$ | $10^3$ | $10^3$ | $\bf A$ | $6\sim 7$ | $5$ |
| $2$ | $10^4$ | $10^4$ | $10^4$ | $-$ | $8\sim12$ | $15$ |
| $3$ | $10^5$ | $10^5$ | $10^5$ | $\bf B$ | $13\sim 16$ | $10$ |
| $4$ | $2.5\times 10^5$ | $10^5$ |$10^5$ | $-$ | $17\sim 25$ | $60$ |

特殊性质 $\bf A$：对于所有的 $i\in[1,n+1](i\in \Z)$，满足 $c_i=0$。

特殊性质 $\bf B$：对于所有的 $i\in[1,n+1](i\in \Z)$，满足 $c_i=1$。

对于 $100\%$ 的数据，$1\le n\le 2.5\times 10^5$，$0\le c_i\le 10^5$，$0\le |e_i|\le 10^5$。

保证答案在 long long 范围内。

## 样例 #1

### 输入

```
3
1 3 2 2
3 -5 1```

### 输出

```
9```

## 样例 #2

### 输入

```
12
4 7 7 8 8 4 5 5 9 10 1 1 10 
0 -5 7 8 1 -1 -6 8 2 4 10 8 ```

### 输出

```
509```

# AI分析结果



## 算法分类
**贪心+线段树**

## 综合分析与结论
### 核心思路
题目要求插入新实验腔并选择起点，使得粒子环游一周的能量最小。能量计算式为 $\sum |s_j - s_i| \cdot c_j$，其中 $s_j$ 为前缀和，$i$ 为起点。该问题可转化为在数轴上选择带权中位数，使得加权距离和最小。插入位置影响前缀和数组，需用数据结构动态维护。

### 解决难点
1. **动态维护前缀和**：插入位置变化时，仅影响相邻两个位置的前缀和，需高效更新数据结构。
2. **快速查询中位数**：使用线段树维护离散化的前缀和值，支持快速二分查找中位数位置。
3. **高效计算总和**：拆解绝对值表达式为两部分，用线段树维护前缀和的加权和与总权值。

### 算法流程
1. **预处理**：计算初始前缀和数组，离散化所有可能的值。
2. **线段树初始化**：插入初始所有前缀和及其权值。
3. **动态调整插入位置**：每次交换相邻实验腔的位置，更新线段树中的值。
4. **查询最优起点**：线段树二分查找中位数，计算对应能量总和。
5. **取最小值**：遍历所有可能的插入位置，记录最小能量。

---

## 题解评分（≥4星）
### 1. 作者：Aiopr_2378（5星）
- **亮点**：使用动态开点线段树处理大值域，代码简洁高效，时间复杂度 $O(n \log \omega)$。
- **核心**：维护加权中位数，每次插入位置调整仅修改相邻节点。

### 2. 作者：yinhy09（4星）
- **亮点**：树状数组维护四类区间和，离散化预处理，复杂度 $O(n \log^2 n)$。
- **优化**：巧妙拆解绝对值表达式，支持快速动态更新。

### 3. 作者：sqrtqwq（4星）
- **亮点**：权值线段树实现中位数查询，代码简洁，适合理解核心思路。
- **技巧**：将带权点拆分为多个无权重叠点，简化问题模型。

---

## 最优思路与技巧提炼
### 关键步骤
1. **转化为带权中位数问题**：总能量最小等价于选择数轴上的加权中位数。
2. **离散化预处理**：将所有可能的前缀和值离散化，压缩值域。
3. **线段树动态维护**：
   - 插入/删除操作对应位置的前缀和及权值。
   - 二分查找第一个满足权值过半的离散点作为中位数。
4. **快速计算能量总和**：利用线段树查询中位数左右的加权和，公式化计算总能量。

### 代码实现片段
```cpp
// 动态开点线段树维护加权中位数（Aiopr_2378 题解核心）
void modify(int &p, ll l, ll r, ll goal, ll val) {
    if (!p) p = ++cnt;
    if (l == r) {
        sz[p] += val;
        sum[p] += val * goal;
        return;
    }
    ll mid = (l + r) >> 1;
    if (goal <= mid) modify(ls[p], l, mid, goal, val);
    else modify(rs[p], mid + 1, r, goal, val);
    sz[p] = sz[ls[p]] + sz[rs[p]];
    sum[p] = sum[ls[p]] + sum[rs[p]];
}

ll query() {
    ll total = sz[root], half = (total + 1) / 2;
    ll l = -1e18, r = 1e18, pos = 0;
    while (l <= r) {
        ll mid = (l + r) >> 1;
        if (get_cnt(-1e18, mid) >= half) {
            pos = mid;
            r = mid - 1;
        } else l = mid + 1;
    }
    ll left_sum = get_sum(-1e18, pos - 1);
    ll right_sum = get_sum(pos + 1, 1e18);
    return right_sum - left_sum + pos * (get_cnt(pos, 1e18) - get_cnt(-1e18, pos));
}
```

---

## 相似题目推荐
1. **P1168 中位数**：静态序列中位数，练习基础二分与树状数组。
2. **P1908 逆序对**：动态维护序列，树状数组/线段树应用。
3. **CF1005F Berland and the Shortest Paths**：贪心结合图论中的最短路径计数。

---

## 可视化设计
### 动画方案
1. **像素风格展示**：
   - **颜色标记**：当前插入位置（红色）、前缀和变化点（蓝色）、中位数（黄色）。
   - **Canvas 网格**：横轴为离散化后的前缀和值，纵轴为权值，色块高度表示权值大小。
2. **动态更新**：
   - 插入位置变化时，高亮相邻节点，展示线段树节点的更新过程。
   - 中位数查询时，绘制二分路径，用绿色路径标记搜索过程。
3. **音效与交互**：
   - **音效**：插入时“滴”声，中位数命中时“叮”声，错误操作“哔”声。
   - **控制面板**：暂停/继续按钮，速度滑块调节动画速度。

### 复古游戏化
- **8-bit 音效**：使用 Web Audio API 播放芯片音乐。
- **积分系统**：每正确插入一个位置得10分，最优解额外奖励50分。
- **自动演示模式**：AI 模拟最优插入顺序，动态展示线段树更新与中位数计算。

---

## 个人心得
- **离散化重要性**：面对大值域问题，离散化是压缩空间的利器。
- **线段树灵活性**：动态开点线段树在处理稀疏数据时表现优异，避免内存浪费。
- **调试技巧**：在插入位置变化时，需验证前缀和更新的正确性，输出中间变量对比。

---
处理用时：90.82秒
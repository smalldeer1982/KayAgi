# 题目信息

# 填涂颜色

## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 30$。


## 样例 #1

### 输入

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

### 输出

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

# AI分析结果



**算法分类**: 图遍历（DFS/BFS）

---

### **题解核心思路与难点分析**
**核心思路**:  
逆向思维，将外围无法到达边界的0标记，剩余未标记的0即为闭合圈内目标。  
1. **外围扩展**: 在原矩阵外添加一圈虚拟0，确保所有外部0连通。  
2. **搜索标记**: 从(0,0)开始DFS/BFS，将能到达的0标记为已访问。  
3. **反向输出**: 原矩阵中未被标记的0即为闭合圈内，改为2输出。  

**解决难点**:  
- **闭合圈判定**：通过外围扩展避免零散外部0无法遍历的问题。  
- **高效标记**：利用DFS/BFS特性快速覆盖所有外部连通区域。  

---

### **优质题解推荐 (≥4星)**
1. **LMB_001 (DFS染色法)  ★★★★☆**  
   - **亮点**: 从(0,0)开始DFS，代码简洁，染色逻辑清晰。  
   - **核心代码**:  
     ```cpp
     void dfs(int p,int q){
         if(p<0||p>n+1||q<0||q>n+1||a[p][q]!=0) return;
         a[p][q]=1; //标记外部0
         dfs(p+dx[i],q+dy[i]); //四向递归
     }
     ```

2. **冰冻赤道 (BFS边界处理)  ★★★★☆**  
   - **亮点**: 枚举边界点启动BFS，兼容不规则闭合圈。  
   - **关键步骤**:  
     ```cpp
     for(int i=1;i<=n;i++){ //枚举四边
         if(a[1][i]==0) bfs(1,i);
         if(a[i][1]==0) bfs(i,1);
         //...其他边同理
     }
     ```

3. **封禁用户 (外扩矩阵法)  ★★★★☆**  
   - **创新点**: 显式扩展矩阵边界，确保外部连通性。  
   - **代码片段**:  
     ```cpp
     for(int i=0;i<=n+1;i++) //外扩一圈0
         for(int j=0;j<=n+1;j++)
             if(a[i][j]==0) a[i][j]=2;
     ```

---

### **最优技巧提炼**
1. **虚拟边界法**: 通过添加虚拟边界将外部0连通，避免漏判。  
2. **逆向染色**: 标记外部区域而非直接寻找内部区域，降低复杂度。  
3. **队列/栈选择**: BFS用队列保证层序扩散，DFS用栈实现深度优先，均可达O(n²)时间复杂度。  

---

### **同类题目推荐**
1. **P1451 求细胞数量** - 连通区域计数  
2. **P1506 拯救oibh总部** - 封闭区域填充  
3. **P1163 矩阵覆盖问题** - 逆向区域标记  

---

### **可视化设计**
**动画方案**:  
1. **网格绘制**: Canvas绘制n×n网格，初始状态：  
   - 灰色: 未访问  
   - 红色: 数字1（墙）  
   - 蓝色: 原始0  
2. **扩散过程**:  
   - 绿色波纹: 从(0,0)开始扩散，标记外部0为绿色。  
   - 最终残留的蓝色区域自动变为黄色（目标2）。  
3. **音效**:  
   - 扩散时播放8-bit水滴声，标记完成时播放上升音调。  

**复古风格**:  
- 使用16色调色板（如NES经典配色）。  
- 扩散过程用像素粒子效果，类似《吃豆人》幽灵移动。  

**交互功能**:  
- 速度滑块控制扩散速度。  
- 单步执行观察队列/栈变化。  

---

### **核心代码实现**
```cpp
// 封禁用户题解核心逻辑
#include<iostream>
#include<queue>
using namespace std;
int main(){
    int n,map[32][32]={}; //初始化为0
    cin>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            cin>>map[i][j];
            if(map[i][j]==0) map[i][j]=2; //初始0转2
        }
    
    queue<pair<int,int>> q;
    q.push({0,0});
    while(!q.empty()){
        auto [x,y]=q.front(); q.pop();
        if(x<0||x>n+1||y<0||y>n+1||map[x][y]!=2) continue;
        map[x][y]=0; //外部0标记
        q.push({x+1,y}); q.push({x-1,y}); //四向入队
        q.push({x,y+1}); q.push({x,y-1});
    }
    
    //输出时未标记的2转目标值
    for(int i=1;i<=n;i++,cout<<'\n')
        for(int j=1;j<=n;j++)
            cout<<(map[i][j]==2?2:!!map[i][j])<<' ';
}
```

---
处理用时：73.02秒
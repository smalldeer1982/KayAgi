# 题目信息

# [NOIP 2012 提高组] 借教室

## 题目描述

在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。

面对海量租借教室的信息，我们自然希望编程解决这个问题。

我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_i$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_j,s_j,t_j$，表示某租借者需要从第 $s_j$ 天到第 $t_j$ 天租借教室（包括第 $s_j$ 天和第 $t_j$ 天），每天需要租借 $d_j$ 个教室。

我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供 $d_j$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。

借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_j$ 天到第 $t_j$ 天中有至少一天剩余的教室数量不足 $d_j$ 个。

现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。


## 说明/提示

【输入输出样例说明】

第 $1 $份订单满足后，$4 $天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2 $天到第 $4$ 天每天提供 $3$ 个教室，而第 $3$ 天剩余的教室数为$ 2$，因此无法满足。分配停止，通知第 $2$ 个申请人修改订单。

【数据范围】

对于 $10\%$ 的数据，有 $1\le n,m\le 10$；

对于 $30\%$ 的数据，有 $1\le n,m\le 1000$；

对于 $70\%$ 的数据，有 $1 \le n,m \le 10^5$；

对于 $100\%$ 的数据，有 $1 \le n,m \le 10^6$，$0 \le r_i,d_j\le 10^9$，$1 \le s_j\le t_j\le n$。


NOIP 2012 提高组 第二天 第二题

2022.2.20 新增一组 hack 数据

## 样例 #1

### 输入

```
4 3 
2 5 4 3 
2 1 3 
3 2 4 
4 2 4```

### 输出

```
-1 
2```

# AI分析结果



## 算法分类：二分查找 + 差分数组

---

### **题解思路与难点对比**

#### **核心思路**
- **差分 + 二分**：通过二分查找确定第一个无法满足的订单，利用差分数组高效处理区间减法操作，验证时通过前缀和还原每天的教室使用量。
- **线段树**：直接维护区间最小剩余教室数，每次订单处理进行区间减法操作，实时检查最小值是否小于零。
- **暴力优化**：通过差分前缀和快速处理订单，反向遍历订单尝试撤销操作直到合法，但最坏复杂度仍为 O(mn)。

#### **难点对比**
| 方法         | 时间复杂度      | 空间复杂度 | 实现难度 | 适用场景                |
|--------------|----------------|------------|----------|------------------------|
| 差分 + 二分  | O(n log m)     | O(n)       | 低       | 大规模数据，顺序处理    |
| 线段树       | O(m log n)     | O(n)       | 中       | 动态区间操作，实时查询  |
| 暴力优化     | O(mn)（最坏）  | O(n)       | 低       | 小数据或特殊优化场景    |

---

### **最优解法结论**
**差分数组 + 二分查找**是最优解法：
1. **时间复杂度**：O(n log m)，可处理 1e6 级别数据。
2. **空间效率**：仅需额外 O(n) 空间存储差分数组。
3. **实现简洁性**：代码结构清晰，仅需实现差分操作和二分的边界处理。

---

### **题解评分 (≥4星)**
1. **皎月半洒花（★★★★★）**  
   - **亮点**：详细解析差分与二分原理，代码简洁高效，逻辑清晰。  
   - **代码片段**：  
     ```cpp
     bool isok(int x) {
         memset(diff, 0, sizeof(diff));
         for (int i=1; i<=x; i++) {
             diff[l[i]] += d[i];
             diff[r[i]+1] -= d[i];
         }
         for (int i=1; i<=n; i++) {
             need[i] = need[i-1] + diff[i];
             if (need[i] > rest[i]) return 0;
         }
         return 1;
     }
     ```

2. **WsW_（★★★★☆）**  
   - **亮点**：代码简洁，使用 STL 和快速 IO 优化，适合竞赛模板。  
   - **代码片段**：  
     ```cpp
     bool check(int x) {
         memset(c, 0, sizeof(c));
         for (int i=1; i<=x; i++) {
             c[a[i].first] += d[i];
             c[a[i].second+1] -= d[i];
         }
         for (int i=1; i<=n; i++) {
             c[i] += c[i-1];
             if (c[i] > r[i]) return 0;
         }
         return 1;
     }
     ```

3. **清远学会（★★★★☆）**  
   - **亮点**：提供线段树实现，对比不同数据结构差异，适合拓展学习。  
   - **代码片段**：  
     ```cpp
     void update_qj(int x, int l, int r, int v) {
         if (node[x].l == l && node[x].r == r) {
             node[x].minn += v;
             node[x].lazy += v;
             return;
         }
         if (node[x].lazy) pushdown(x);
         int mid = (node[x].l + node[x].r) >> 1;
         if (r <= mid) update_qj(x<<1, l, r, v);
         else if (l > mid) update_qj(x<<1|1, l, r, v);
         else {
             update_qj(x<<1, l, mid, v);
             update_qj(x<<1|1, mid+1, r, v);
         }
         node[x].minn = min(node[x<<1].minn, node[x<<1|1].minn);
     }
     ```

---

### **核心算法可视化设计**
1. **动画方案**：  
   - **差分数组操作**：以颜色高亮区间 [s, t]，展示 `diff[s] -= d` 和 `diff[t+1] += d` 的更新过程。  
   - **二分过程**：用进度条表示当前检查的订单范围，红色标记第一个非法订单。  
   - **前缀和还原**：逐天显示剩余教室数，负数标红。

2. **复古像素风格**：  
   - **Canvas 绘制**：用 8-bit 像素块表示每天教室数量，绿色表示充足，红色表示不足。  
   - **音效设计**：区间修改时播放“滴”声，发现非法订单时播放“失败”音效。

3. **交互功能**：  
   - **步进控制**：允许单步执行二分和差分操作，观察中间状态。  
   - **速度调节**：滑动条控制动画速度，适应不同学习节奏。

---

### **相似题目推荐**
1. **P3372【线段树区间修改】**  
2. **P4552【差分数组基础应用】**  
3. **P2571【二分答案与验证】**

---

### **代码实现（差分+二分）**
```cpp
#include <cstdio>
#include <cstring>
using namespace std;

const int MAXN = 1e6 + 5;
int n, m, rest[MAXN], d[MAXN], s[MAXN], t[MAXN], diff[MAXN];

bool check(int x) {
    memset(diff, 0, sizeof(diff));
    for (int i = 1; i <= x; ++i) {
        diff[s[i]] += d[i];
        diff[t[i] + 1] -= d[i];
    }
    int cur = 0;
    for (int i = 1; i <= n; ++i) {
        cur += diff[i];
        if (cur > rest[i]) return false;
    }
    return true;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%d", &rest[i]);
    for (int i = 1; i <= m; ++i) scanf("%d%d%d", &d[i], &s[i], &t[i]);
    
    int l = 1, r = m, ans = 0;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (check(mid)) {
            ans = mid;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    if (ans == m) printf("0");
    else printf("-1\n%d", ans + 1);
    return 0;
}
```

---
处理用时：73.05秒
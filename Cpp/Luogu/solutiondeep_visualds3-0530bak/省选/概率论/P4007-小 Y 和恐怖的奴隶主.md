# 题目信息

# 小 Y 和恐怖的奴隶主

## 题目背景

“A fight? Count me in!” 要打架了，算我一个。

“Everyone, get in here!” 所有人，都过来！


## 题目描述

小 Y 是一个喜欢玩游戏的 OIer。一天，她正在玩一款游戏，要打一个 Boss。

虽然这个 Boss 有 $10^{100}$ 点生命值，但它只带了一个随从——一个只有 $m$ 点生命值的“恐怖的奴隶主”。

这个“恐怖的奴隶主”有一个特殊的技能：每当它被扣减生命值但没有死亡（死亡即生命值 $\leq 0$），且 Boss 的随从数量小于上限 $k$，便会召唤一个新的具有 $m$ 点生命值的“恐怖的奴隶主”。

现在小 Y 可以进行 $n$ 次攻击，每次攻击时，会从 Boss 以及 Boss 的所有随从中的等概率随机选择一个，并扣减 $1$ 点生命值，她想知道进行 $n$ 次攻击后扣减 Boss 的生命值点数的期望。为了避免精度误差，你的答案需要对 $998244353$ 取模。

## 说明/提示

【样例 $1$ 解释】

对于第一次询问，第一次攻击有 $\frac{1}{2}$ 的概率扣减 Boss 的生命值，有 $\frac{1}{2}$ 的概率扣减随从的生命值，所以答案为 $\frac{1}{2}$。$1 \equiv 2 \times 499122177 \pmod{998244353}$。

对于第二次询问，如果第一次攻击扣减了 Boss 的生命值，那么有 $\frac{1}{2}$ 的概率第二次攻击仍扣减 Boss 的生命值，有 $\frac{1}{2}$ 的概率第二次攻击扣减随从的生命值；如果第一次攻击扣减了随从的生命值，那么现在又新召唤了一个随从（“恐怖的奴隶主”），于是有 $\frac{1}{3}$ 的概率第二次攻击扣减 Boss 的生命值，有 $\frac{2}{3}$ 的概率第二次攻击扣减随从的生命值。所以答案为 $\frac{1}{2}\times\frac{1}{2}\times2+\frac{1}{2}\times\frac{1}{2}\times1+\frac{1}{2}\times\frac{1}{3}\times1+\frac{1}{2}\times\frac{2}{3}\times0 = \frac{11}{12}$。 $11 \equiv 12 \times 415935148\pmod{998244353}$。

【提示】

题目顺序可能与难度无关。

【子任务】

在所有测试点中，$1 \leq T \leq 1000, 1 \leq n \leq {10}^{18}, 1 \leq m \leq 3, 1 \leq k \leq 8$。

各个测试点的分值和数据范围如下：

![12058](https://cdn.luogu.com.cn/upload/pic/12058.png)

## 样例 #1

### 输入

```
3 2 6
1
2
3```

### 输出

```
499122177
415935148
471393168```

# AI分析结果



### 唯一算法分类
矩阵快速幂优化动态规划

### 题解思路与算法要点
1. **状态压缩与转移矩阵**  
   - 核心状态为 $(a,b,c)$ 表示 1血、2血、3血随从的数量，状态总数约 165 个  
   - 转移矩阵元素计算攻击各目标的概率，需预处理模意义下的逆元  
   - 额外增加一维存储期望值，总状态数 166  

2. **矩阵快速幂优化**  
   - 预处理转移矩阵的 $2^i$ 次幂，将复杂度从 $O(166^3 \log n)$ 降为 $O(166^3 \log n + T \cdot 166^2 \log n)$  
   - 使用行向量与矩阵相乘代替矩阵与矩阵相乘，减少计算量  

3. **代码优化技巧**  
   - `__int128` 暂存中间结果减少取模次数  
   - 编译指令优化（如 `#pragma GCC optimize`）提升运行效率  

### 解决难点对比
| 题解作者 | 核心优化点 | 实现复杂度 | 可读性 |
|---------|------------|-----------|--------|
| mrsrz   | 行向量乘矩阵预处理 | 中等 | ★★★★☆ |  
| MyukiyoMekya | 逆推期望与状态压缩 | 较高 | ★★★☆☆ |  
| s_r_f   | K进制分块预处理矩阵 | 高 | ★★★★☆ |  

### 题解评分（≥4星）
1. **mrsrz（4.5星）**  
   - 思路清晰，预处理转移矩阵的 $2^i$ 次幂  
   - 关键代码使用 `__int128` 优化取模  
   - 代码结构简洁，适合快速理解算法框架  

2. **s_r_f（4星）**  
   - 采用 K=4 进制分块优化预处理  
   - 控制面板设计便于交互式学习  
   - 代码复杂度较高，但理论复杂度更优  

3. **Piwry（4星）**  
   - 完整实现状态转移矩阵构造  
   - 使用编译指令优化常数  
   - 注释详细，适合深入调试参考  

### 最优思路提炼
- **状态压缩**：用三元组 $(a,b,c)$ 唯一标识每个状态，总状态数 165  
- **矩阵构造**：对每个状态计算攻击不同目标的转移概率，预处理逆元加速  
- **快速幂优化**：预处理 $A^{2^i}$ 矩阵，分解指数为二进制后快速计算  
- **向量加速**：用行向量代替方阵乘法，将单次查询复杂度降为 $O(166^2 \log n)$  

### 同类型题与算法套路
1. **动态规划状态压缩**：当状态维度固定且数量有限时，可用类似压缩方法（如 P3175 [HAOI2015] 按位或）  
2. **矩阵快速幂优化**：适用于线性递推式且转移矩阵固定的场景（如 P2106 Sam数）  
3. **期望逆推法**：当正向递推难以计算时，可考虑倒序处理（如 P4547 [THUWC2017] 随机二分图）  

### 推荐相似题目
1. **P3175 [HAOI2015] 按位或**（期望+高维前缀和）  
2. **P3830 [SHOI2012] 随机树**（概率DP+状态转移优化）  
3. **P4547 [THUWC2017] 随机二分图**（状压DP+矩阵优化）  

### 核心代码实现
```cpp
// 预处理逆元
void preInv() {
    inv[1] = 1;
    for(int i=2; i<=9; ++i) 
        inv[i] = 1ll*(mod-mod/i)*inv[mod%i]%mod;
}

// 构造转移矩阵
void buildMatrix() {
    for(int a=0; a<=K; ++a) for(int b=0; b<=K-a; ++b) for(int c=0; c<=K-a-b; ++c) {
        int s = a+b+c+1;
        int invs = inv[s];
        // 攻击1血随从
        if(a) mat[id[a][b][c]][id[a-1][b][c]] = 1ll*a*invs%mod;
        // 攻击2血随从（召唤逻辑）
        if(b) {
            if(a+b+c < K) mat[id[a][b][c]][id[a+1][b-1][c+1]] = 1ll*b*invs%mod;
            else mat[id[a][b][c]][id[a+1][b-1][c]] = 1ll*b*invs%mod;
        }
        // 攻击Boss的期望累加
        mat[id[a][b][c]][total_states] = invs;
    }
    mat[total_states][total_states] = 1; // 期望值保留
}

// 快速幂计算
Vector calc(LL n) {
    Vector res = initial_vec;
    for(int i=0; i<60; ++i) 
        if(n & (1LL<<i)) res = res * pre_mat[i];
    return res;
}
```

### 可视化设计（复古像素风格）
1. **动画元素**  
   - **状态方块**：每个状态显示为 16x16 像素方块，颜色按血量区分（红=3血，绿=2血，蓝=1血）  
   - **转移箭头**：用黄色像素点绘制状态转移路径，闪烁表示当前计算路径  
   - **矩阵网格**：在 Canvas 上绘制 166x166 网格，高亮当前矩阵乘法涉及的行列  

2. **音效设计**  
   - **攻击音效**：8-bit 风格 "beep" 音效，不同攻击目标音调不同  
   - **矩阵更新**：每次完成矩阵乘法时播放上升音阶  
   - **错误提示**：无效转移时播放低频 "buzz" 音  

3. **交互功能**  
   - **步进控制**：方向键控制动画速度，空格暂停/继续  
   - **自动演示**：AI 模式自动选择最优路径，用 Dijkstra 算法可视化搜索过程  
   - **数据面板**：右侧显示当前状态概率分布和累计期望值  

### 可视化代码片段（HTML5 Canvas）
```javascript
// 绘制状态方块
function drawState(ctx, a, b, c, x, y) {
    ctx.fillStyle = `rgb(${255 - c*30}, ${255 - b*30}, ${255 - a*30})`;
    ctx.fillRect(x, y, 16, 16);
    ctx.strokeStyle = "#FFF";
    ctx.strokeRect(x, y, 16, 16);
}

// 矩阵乘法动画帧
function animateMatrixStep(srcVec, mat) {
    let destVec = new Vector();
    for(let i=0; i<166; ++i) {
        for(let j=0; j<166; ++j) {
            destVec[j] += srcVec[i] * mat[i][j];
            // 高亮当前计算单元
            ctx.fillStyle = "rgba(255,255,0,0.3)";
            ctx.fillRect(j*8, i*8, 8, 8);
        }
        destVec[j] %= MOD;
    }
    return destVec;
}
```

---
处理用时：78.16秒
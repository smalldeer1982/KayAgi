# 题目信息

# [JXOI2017] 颜色

## 题目描述

可怜有一个长度为 $n$ 的正整数序列 $A_i$，其中相同的正整数代表着相同的颜色。

现在可怜觉得这个序列太长了，于是她决定选择一些颜色把这些颜色的所有位置都删去。

删除颜色 $i$ 可以定义为把所有满足 $A_j = i$ 的位置 $j$ 都从序列中删去。

然而有些时候删去之后，整个序列变成了好几段，可怜不喜欢这样，于是她想要知道有多少种删去颜色的方案使得最后剩下来的序列非空且连续。

例如颜色序列 $\{1, 2, 3, 4, 5\}$，删除颜色 $3$ 后序列变成了 $\{1, 2\}$ 和 $\{4, 5\}$ 两段，不满足条件。而删除颜色 $1$ 后序列变成了 $\{2, 3, 4, 5\}$，满足条件。

两个方案不同当且仅当至少存在一个颜色 $i$ 只在其中一个方案中被删去。


## 说明/提示

满足条件的删颜色方案有 $\{1\}, \{1, 3\}, \{1, 2, 3\}, \{1, 3, 4\}, \{2, 3, 4\}, \varnothing$。

对于 $20\%$ 的数据，保证 $1 \le \sum n \le  20$。

对于 $40\%$ 的数据，保证 $1 \le \sum n \le  500$。

对于 $60\%$ 的数据，保证 $1 \le \sum n \le  10^4$。

对于 $100\%$ 的数据，保证 $1 \le  T,\sum n \le  3 \times 10^5, 1 \le  A_i \le  n$。

$\text{Statement fixed by @Starrykiller.}$

## 样例 #1

### 输入

```
1
5
1 3 2 4 3```

### 输出

```
6```

# AI分析结果



---

**算法分类**: 前缀和与哈希 / 线段树与数据结构维护

---

## 综合分析与结论

### 核心思路与难点
1. **问题转化**：将删除颜色方案转化为统计合法区间，要求区间内的颜色出现位置必须完全包含在该区间内。
2. **两种核心思路**：
   - **哈希法**：通过随机分配同色和为0的哈希值，统计异或前缀和相同的区间。难点在于保证哈希冲突概率足够低。
   - **线段树法**：枚举右端点，维护左端点合法范围。通过栈维护最近的必须删除颜色位置，线段树维护禁用区间。

### 题解评分（≥4星）
1. **shadowice1984（5星）**  
   - **亮点**：清晰的分步逻辑（栈维护左边界+线段树区间禁用），代码结构简洁。
   - **难点解决**：通过栈贪心找到最近的非法位置，线段树高效维护禁用区间。
   - **代码可读性**：逻辑明确，注释详细，适合学习数据结构应用。

2. **Iscream2001（4星）**  
   - **亮点**：哈希思路新颖，代码极简（仅需前缀和统计）。
   - **优化**：利用大范围随机数降低冲突概率，时间复杂度O(n)。
   - **适用场景**：对时间要求苛刻的大数据量场景。

3. **Ebola（4星）**  
   - **亮点**：对哈希方法的正确性进行概率分析，增强理论支撑。
   - **实现改进**：异或替代加法，进一步降低冲突概率。

---

## 最优思路提炼
### 哈希法（随机赋值+前缀和统计）
1. **核心技巧**：为每个颜色随机生成值，使得同色值的总和为0。合法区间的异或前缀和必为0。
2. **实现要点**：
   ```cpp
   for 颜色c的所有位置:
       前k-1个位置赋随机值，第k个位置赋值为前k-1个的异或和
   map统计前缀异或和的出现次数，累加相同值的组合数
   ```
3. **优势**：O(n)时间复杂度，代码量极少。

### 线段树法（右端点枚举+栈维护左边界）
1. **核心流程**：
   - 预处理每个颜色的最左（`minl`）和最右（`maxl`）位置。
   - 枚举右端点`i`，用栈维护最近的`maxl > i`的位置作为左边界下限`L`。
   - 线段树标记`[minl+1, maxl]`为禁用区间，统计`[L+1, i]`中可用点数。
2. **代码片段**：
   ```cpp
   stack维护最近必须删除的颜色位置;
   for (int i=1; i<=n; i++) {
       if (i是颜色a[i]的最后出现位置)
           线段树禁用[minl[a[i]]+1, maxl[a[i]]];
       else 入栈当前颜色;
       while (栈顶颜色maxl <= i) 弹出栈顶;
       L = 栈顶位置;
       ans += i - L - 线段树查询[L+1, i];
   }
   ```

---

## 可视化设计（线段树法）
### 动画方案
1. **像素风格界面**：  
   - **颜色标记**：当前右端点`i`高亮为红色，栈顶`L`标记为蓝色，禁用区间用灰色覆盖。
   - **网格绘制**：序列以方格表示，每个格子显示颜色编号和哈希值（若用哈希法）。
2. **步进控制**：  
   - **操作分解**：每一步展示右端点移动、栈更新、线段树区间禁用、查询可用点。
   - **速度调节**：滑块控制动画速度，支持暂停/继续。
3. **音效提示**：  
   - 分配哈希值时触发“叮”声，查询时播放“咔哒”声，统计答案时播放胜利音效。

---

## 相似题目推荐
1. **洛谷 P1972 [SDOI2009] HH的项链**  
   - 统计区间内不同颜色数量，需高效离线查询。
2. **LeetCode 1521. Find the Closest Palindrome**  
   - 区间性质的预处理与维护。
3. **洛谷 P4113 [HEOI2012] 采花**  
   - 类似颜色区间统计，需结合离线处理和数据结构。

---

## 代码片段（线段树法）
```cpp
struct SegmentTree {
    int val[N<<2], tag[N<<2];
    void pushdown(int p, int len) {
        if (tag[p]) {
            val[p<<1] = tag[p]*(len/2);
            val[p<<1|1] = tag[p]*(len - len/2);
            tag[p<<1] = tag[p<<1|1] = tag[p];
            tag[p] = 0;
        }
    }
    void update(int p, int l, int r, int L, int R, int v) {
        if (L <= l && r <= R) {
            val[p] = v*(r-l+1);
            tag[p] = v;
            return;
        }
        pushdown(p, r-l+1);
        int mid = (l+r)>>1;
        if (L <= mid) update(p<<1, l, mid, L, R, v);
        if (R > mid) update(p<<1|1, mid+1, r, L, R, v);
        val[p] = val[p<<1] + val[p<<1|1];
    }
    int query(int p, int l, int r, int L, int R) {
        if (L <= l && r <= R) return val[p];
        pushdown(p, r-l+1);
        int mid = (l+r)>>1, res = 0;
        if (L <= mid) res += query(p<<1, l, mid, L, R);
        if (R > mid) res += query(p<<1|1, mid+1, r, L, R);
        return res;
    }
} seg;
```

---

**总结**：线段树法稳定可靠适合竞赛，哈希法高效适合大数据；可视化的步进与颜色标记能直观展示核心逻辑。

---
处理用时：76.93秒
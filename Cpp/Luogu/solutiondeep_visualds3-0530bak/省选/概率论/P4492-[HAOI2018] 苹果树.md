# 题目信息

# [HAOI2018] 苹果树

## 题目背景

HAOI2018 Round2 第一题

## 题目描述

小 C 在自己家的花园里种了一棵苹果树, 树上每个结点都有恰好两个分支. 经过细心的观察, 小 C 发现每一天这棵树都会生长出一个新的结点.

第一天的时候, 果树会长出一个根结点, 以后每一天, 果树会随机选择一个当前树中没有长出过结点 的分支, 然后在这个分支上长出一个新结点, 新结点与分支所属的结点之间连接上一条边.

小 C 定义一棵果树的不便度为树上两两结点之间的距离之和, 两个结点之间 的距离定义为从一个点走到另一个点的路径经过的边数.

现在他非常好奇, 如果 $N$ 天之后小 G 来他家摘苹果, 这个不便度的期望 $E$ 是多少. 但是小 C 讨厌分数, 所以他只想知道 $E \times N !$ 对 $P$ 取模的结果, 可以证明这是一个整数.

## 说明/提示

![Explanation](https://cdn.luogu.com.cn/upload/pic/18067.png)

以上是所有 $N = 3$ 时可能的苹果树形态, 其中编号表示这个结点是第几天生
长出来的, 显然每种情况两两结点的距离均为 $4$ .

### 数据范围与约定
| 测试点编号   | $N$  | $P$  |
| :--------: | :--: | :--: |
| $1$ |  $\le 10$    |  $\le 10^9 + 7$    |
| $2$ |  $\le 10$    |   $\le 10^9 + 7$    |
| $3$ |  $\le 500$    |  $\le 10^9 + 7$     |
| $4$ |  $\le 500$    |   $\le 10^9 + 7$    |
| $5$ |  $\le 500$    |   $\le 10^9 + 7$    |
| $6$ |  $\le 2000$    |   $= 10^9 + 7$    |
| $7$ |  $\le 2000$    |   $= 10^9 + 7$    |
| $8$ |  $\le 2000$    |   $\le 10^9 + 7$    |
| $9$ |  $\le 2000$    |   $\le 10^9 + 7$    |
| $10$ | $\le 2000$     |    $\le 10^9 + 7$   |



## 样例 #1

### 输入

```
3 610745795```

### 输出

```
24```

## 样例 #2

### 输入

```
305 1000000007```

### 输出

```
865018107```

# AI分析结果



## 唯一算法分类
组合数学

## 综合分析与结论
**核心思路**：将总距离转化为每条边的贡献，通过组合数学计算所有可能的子树形态。关键点在于：
1. 枚举每个节点i及其可能的子树大小siz
2. 计算子树内部方案数（选点组合+排列）
3. 计算子树外部方案数（不能干扰当前子树）
4. 累加所有情况的贡献值

**算法流程**：
1. 预处理阶乘和组合数
2. 双重循环枚举节点i和子树大小siz
3. 公式计算贡献：`贡献 = siz*(n-siz) * 组合数 * 阶乘乘积`
4. 累加所有情况的贡献模P

**可视化设计**：
- 像素动画展示树生长过程，高亮当前处理的节点i和其子树
- 右侧面板显示组合数C(n-i,siz-1)、阶乘siz!等关键参数的计算过程
- 用不同颜色标记子树内部、外部区域，动态显示方案数乘积过程
- 8-bit音效在每次成功计算贡献时播放"哔"声，错误时播放"嘟"声

## 题解清单 (≥4星)
1. **shadowice1984（5星）**  
   - 完整推导组合公式，代码简洁高效
   - 明确拆分子树内外方案数计算逻辑
   - 预处理阶乘组合数实现O(n²)复杂度

2. **TonyYin（4星）**  
   - 详细分步推导公式，适合数学基础薄弱者
   - 代码可读性强，直接对应公式实现
   - 缺少优化但思路清晰

3. **lhm_（4星）**  
   - 使用动态规划计算子树形态数
   - 创新性地用f[i][j]表示子树方案数
   - 代码简洁但推导过程略简略

## 关键代码实现
```cpp
// 预处理阶乘和组合数
fac[0] = 1;
for(int i=1;i<=n;i++) fac[i] = fac[i-1]*i%mod;
for(int i=0;i<=n;i++) c[i][0] = 1;
for(int i=1;i<=n;i++)
    for(int j=1;j<=i;j++)
        c[i][j] = (c[i-1][j] + c[i-1][j-1])%mod;

// 主计算逻辑
for(int i=2;i<=n;i++)
    for(int siz=1;siz<=n-i+1;siz++)
        res += fac[siz] * c[n-i][siz-1] % mod 
             * siz % mod * (n-siz) % mod 
             * fac[n-siz-1] % mod 
             * i % mod * (i-1) % mod;
```

## 相似题目推荐
1. P3978 [TJOI2015]概率论 - 二叉树形态计数
2. P1040 加分二叉树 - 树结构动态规划
3. P1273 组合数问题 - 组合数学应用

## 可视化代码片段
```javascript
// 像素动画核心逻辑
function drawTreeStep(i, siz) {
    ctx.fillStyle = '#FF0000'; // 当前节点红色
    drawNode(i, 100, 50 + i*30); 
    ctx.fillStyle = '#00FF00'; // 子树绿色
    for(let j=0; j<siz; j++)
        drawNode(i+j, 150 + j*20, 80 + i*30);
    
    // 显示计算公式
    showFormula(`C(${n-i},${siz-1})*${siz}!*${i}*${i-1}*...`);
    
    // 播放音效
    if(calcValid) playSound('beep');
    else playSound('error');
}
```

## 总结与心得
1. **组合思维突破**：将树结构拆分为边贡献，避免直接计算复杂树形
2. **阶乘妙用**：通过排列组合描述生长过程的顺序方案
3. **模运算陷阱**：需要在每次乘法后取模，防止溢出
4. **复杂度控制**：预处理阶乘组合数是达到O(n²)的关键

## 复古动画要素
1. **16色调色板**：使用经典NES的红色、绿色、蓝色为主色调
2. **8-bit音效库**：
   - 选择节点时：短促"哔"声（三角波）
   - 计算正确时：上升音阶（方波）
   - 错误时：低音"嘟"声（噪声波）
3. **像素字体**：使用8x8像素字体显示计算公式
4. **扫描线特效**：添加CRT显示器特有的横向扫描线效果
5. **得分显示**：右上角显示当前累计贡献值，采用7段数码管风格

---
处理用时：58.56秒
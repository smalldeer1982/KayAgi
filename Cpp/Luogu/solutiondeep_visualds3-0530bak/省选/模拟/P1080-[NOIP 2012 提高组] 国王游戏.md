# 题目信息

# [NOIP 2012 提高组] 国王游戏

## 题目描述

恰逢 H 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。

国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。


## 说明/提示

【输入输出样例说明】

按 $1$、$2$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $1$、$3$、$2$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $2$、$1$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按$ 2$、$3$、$1 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$；

按 $3$、$1$、$2 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；  

按$ 3$、$2$、$1$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$。

因此，奖赏最多的大臣最少获得 $2$ 个金币，答案输出 $2$。


 
【数据范围】

对于 $20\%$ 的数据，有 $1≤ n≤ 10,0 < a,b < 8$；

对于 $40\%$ 的数据，有$ 1≤ n≤20,0 < a,b < 8$；

对于 $60\%$ 的数据，有 $1≤ n≤100$；

对于 $60\%$ 的数据，保证答案不超过 $10^9$；

对于 $100\%$ 的数据，有 $1 ≤ n ≤1,000,0 < a,b < 10000$。



NOIP 2012 提高组 第一天 第二题


## 样例 #1

### 输入

```
3 
1 1 
2 3 
7 4 
4 6 ```

### 输出

```
2```

# AI分析结果



# 算法分类
**贪心算法**

---

# 综合分析与结论
## 核心思路与难点
1. **贪心策略证明**：  
   - 通过邻项交换法证明，当相邻大臣满足 $a_i \times b_i < a_j \times b_j$ 时，交换会导致最大值的增加，因此最优排列是按左右手乘积升序排列。
   - 关键变量：每位大臣的乘积 $a_i \times b_i$ 作为排序依据。

2. **高精度处理**：  
   - 乘积可能达到 $10^{4000}$ 级别，需用高精度乘除法。
   - 核心实现：压位（如每4位存储）、乘法为高精×低精，除法为高精÷低精。

3. **可视化设计**：  
   - **动画方案**：Canvas 网格显示高精度数组，颜色标记当前乘/除的位。
   - **复古效果**：8-bit 像素风格显示大臣队列，音效触发排序完成或高精度进位。

---

# 题解评分 (≥4星)

### 1. 洛必达法则（5星）
- **亮点**：严格数学证明邻项交换条件，逻辑闭环。
- **代码**：压位高精度实现，时间复杂度 $O(n^2)$。

### 2. chc_1234567890（4星）
- **亮点**：高精度类封装清晰，支持比较运算符重载。
- **优化**：压4位存储，乘除操作高效。

### 3. VitrelosTia（4星）
- **亮点**：Python 简化高精度，邻项交换条件推导简洁。
- **实践性**：代码简短，适合快速理解贪心策略。

---

# 最优思路与技巧提炼
1. **贪心证明核心**：  
   - 比较交换前后的最大值 $\max(\frac{1}{b_i}, \frac{a_i}{b_j})$ 与 $\max(\frac{1}{b_j}, \frac{a_j}{b_i})$，化简为乘积比较。

2. **高精度优化**：  
   - **压位存储**：如每4位存为1个数组元素，减少运算次数。
   - **除法技巧**：从高位向低位逐位处理余数，避免浮点误差。

3. **Python 取巧**：  
   - 使用 `divmod` 避免浮点溢出，直接处理大整数除法。

---

# 类似题目推荐
1. **P1248 加工生产调度**（贪心+邻项交换）
2. **P2123 皇后游戏**（类似国王游戏的贪心证明）
3. **P1090 合并果子**（贪心+优先队列）

---

# 个人心得摘录
- **VitrelosTia**：Python 浮点除法会溢出，改用 `divmod` 处理余数。
- **aiyougege**：高精度调试需逐位打印中间结果，避免逻辑错误。
- **Jerry_zpl**：乘除顺序错误导致乘积爆炸，需严格验证压位进位。

---

# 核心代码实现（chc_1234567890版）
```cpp
struct hp { // 高精度类（简化版）
    int a[maxn], len;
    hp operator*(int rhs) {
        hp res;
        for (int i=1; i<=len; i++) res.a[i] = a[i] * rhs;
        for (int i=1; i<=len; i++) {
            res.a[i+1] += res.a[i] / 10000;
            res.a[i] %= 10000;
            if (i+1 > res.len) res.len = i+1;
        }
        return res;
    }
    hp operator/(int rhs) {
        hp res; int rem = 0;
        for (int i=len; i>=1; i--) {
            rem = rem * 10000 + a[i];
            res.a[i] = rem / rhs;
            rem %= rhs;
        }
        res.len = len;
        while (res.len > 0 && res.a[res.len] == 0) res.len--;
        return res;
    }
};
```

---

# 可视化设计
1. **像素风格队列**：  
   - 用 Canvas 绘制大臣的8-bit头像，左右手显示乘积值。
   - **颜色标记**：当前比较的相邻大臣高亮为红色，交换后变绿。

2. **高精度运算动画**：  
   - **乘法**：低位到高位逐位计算，黄色标记进位过程。
   - **除法**：高位余数向下传递，蓝色标记当前处理位。

3. **音效与自动演示**：  
   - **音效**：排序完成播放FC胜利音效，进位触发“嘟嘟”声。
   - **AI模式**：自动按最优策略排序，可调节速度观察每一步。

---
处理用时：57.48秒
# 题目信息

# “非常男女”计划

## 题目描述

近来，初一年的 `XXX` 小朋友致力于研究班上同学的配对问题（别想太多，仅是舞伴），通过各种推理和实验，他掌握了大量的实战经验。例如，据他观察，身高相近的人似乎比较合得来。

万圣节来临之际，`XXX` 准备在学校策划一次大型的 “非常男女” 配对活动。对于这次活动的参与者，`XXX` 有自己独特的选择方式。他希望能选择男女人数相等且身高都很接近的一些人。这种选择方式实现起来很简单。他让学校的所有人按照身高排成一排，然后从中选出连续的若干个人，使得这些人中男女人数相等。为了使活动更热闹，`XXX` 当然希望他能选出的人越多越好。请编写程序告诉他，他最多可以选出多少人来。


## 样例 #1

### 输入

```
9
0 1 0 0 0 1 1 0 0
```

### 输出

```
6```

# AI分析结果



## 唯一算法分类  
前缀和 + 哈希表优化

---

## 算法思路与核心难点

### 核心思路  
将问题转化为**前缀和差值模型**：  
1. **数值转换**：男生标记为1，女生标记为-1  
2. **前缀和计算**：维护前缀和数组 `sum[]`，其中 `sum[i]` 表示前 `i` 个元素的累计值  
3. **哈希映射**：用哈希表记录每个前缀和值**首次出现的位置**  
4. **最长区间计算**：当 `sum[j] == sum[i]` 时，区间 `[i+1, j]` 的男女数量相等，此时更新最大长度  

### 解决难点  
1. **负数下标处理**：通过偏移量（如 `+n`）将可能为负的前缀和映射到正数范围  
2. **哈希表初始化**：需初始化 `sum[0] = 0` 对应位置为 `-1`（虚拟起点）  
3. **时间复杂度优化**：暴力枚举为 O(n²)，哈希表优化后为 O(n)

---

## 题解评分（≥4星）

### 5星题解：AKB48（赞：166）  
- **亮点**：简洁高效，使用数组替代哈希表，直接存储差值的最左/最右位置  
- **代码片段**：  
  ```cpp
  int t = sum0 - sum1 + n; // 计算偏移后的差值
  if (!l[t] && t != n) l[t] = i; else r[t] = i; // 记录最左/最右位置
  ```

### 5星题解：KellyFrog（赞：66）  
- **亮点**：详细推导过程，使用结构体存储哈希值的最小/最大位置  
- **调试心得**：强调负数偏移量处理的重要性，给出初始化陷阱的警示  

### 4星题解：Bring（赞：3）  
- **亮点**：极简代码实现，通过 `p[]` 数组直接映射差值  
- **代码片段**：  
  ```cpp
  sum += read() ? 1 : -1; // 动态计算前缀和
  if (~P(sum)) ans = max(ans, i - P(sum)); // 更新最大长度
  ```

---

## 最优技巧提炼  
**偏移量哈希法**：  
1. 将男生/女生转换为 `+1/-1`，使问题转化为寻找和为0的最长子数组  
2. 前缀和数组 `sum[i]` 的差值 `sum[j] - sum[i] = 0` 等价于 `sum[j] == sum[i]`  
3. 哈希表记录每个前缀和值的**首次出现位置**，避免重复计算  

**关键公式**：  
```
最大长度 = max(当前索引 - 首次出现位置)
```

---

## 类似题目推荐  
1. [洛谷 P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)  
   - **相似点**：二维前缀和+哈希优化  
2. [LeetCode 560. 和为K的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)  
   - **相似点**：前缀和+哈希表计数  
3. [洛谷 P3131 [USACO16JAN]Subsequences Summing to Sevens S](https://www.luogu.com.cn/problem/P3131)  
   - **相似点**：模数性质+前缀和差值  

---

## 可视化设计（复古像素风格）  
### 动画流程  
1. **初始化**：  
   - 屏幕左侧显示原始数组（0/1用不同颜色像素块表示）  
   - 右侧显示前缀和数组和哈希表，初始状态全灰  
2. **遍历过程**：  
   - 当前元素高亮闪烁，计算前缀和并更新右侧数值  
   - 若哈希表中无此值，标记为绿色像素块并记录位置  
   - 若已存在，用红色线段连接首次出现位置与当前位置，显示区间长度  
3. **音效反馈**：  
   - 发现新前缀和时播放「嘀」声  
   - 更新最大长度时播放「叮咚」上扬音效  

### 交互功能  
- **速度调节**：滑动条控制遍历速度（1x~10x）  
- **单步执行**：空格键逐元素前进  
- **数据回放**：R键重置动画，L键显示最终结果  

---

## 核心代码实现  
```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int N = 2e5 + 10;

int l[N], r[N], n;

int main() {
    cin >> n;
    memset(l, -1, sizeof l);
    l[n] = 0; // 初始位置偏移量为n
    
    int sum = n, ans = 0; // sum初始为n（偏移量）
    for (int i = 1, x; i <= n; i++) {
        cin >> x;
        sum += (x ? 1 : -1); // 动态计算偏移后的前缀和
        
        if (l[sum] == -1) l[sum] = i;
        else ans = max(ans, i - l[sum]);
    }
    cout << ans << endl;
    return 0;
}
```

---

通过将复杂问题转化为前缀和模型，并巧妙利用哈希表优化，该算法在 O(n) 时间复杂度内高效解决了最长平衡子数组问题。复古像素动画的设计则让抽象的哈希映射过程变得直观生动，显著提升理解效率。

---
处理用时：85.78秒
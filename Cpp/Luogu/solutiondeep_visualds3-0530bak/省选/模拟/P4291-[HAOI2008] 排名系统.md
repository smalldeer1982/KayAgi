# 题目信息

# [HAOI2008] 排名系统

## 题目描述

排名系统通常要应付三种请求：上传一条新的得分记录、查询某个玩家的当前排名以及返回某个区段内的排名记录。当某个玩家上传自己最新的得分记录时，他原有的得分记录会被删除。为了减轻服务器负担，在返回某个区段内的排名记录时，最多返回10条记录。

## 说明/提示

20%数据满足N<=100

100%数据满足N<=250000

## 样例 #1

### 输入

```
20
+ADAM 1000000
+BOB 1000000
+TOM 2000000
+CATHY 10000000
?TOM
?1
+DAM 100000
+BOB 1200000
+ADAM 900000
+FRANK 12340000
+LEO 9000000
+KAINE 9000000
+GRACE 8000000
+WALT 9000000
+SANDY 8000000
+MICK 9000000
+JACK 7320000
?2
?5
?KAINE```

### 输出

```
2
CATHY TOM ADAM BOB
CATHY LEO KAINE WALT MICK GRACE SANDY JACK TOM BOB
WALT MICK GRACE SANDY JACK TOM BOB ADAM DAM
4```

# AI分析结果



### 唯一算法分类  
**平衡树（Treap/Splay 等）**

---

### 综合分析与结论  
**核心思路**：所有题解均基于平衡树实现动态排名维护，核心在于将 **分数+时间戳** 封装为复合键值（如 `分数*大数+时间戳`），通过平衡树维护有序结构。  
**核心难点**：  
1. **双关键字排序**：分数相同时按插入时间排序（时间越小排名越靠前）  
2. **高效更新**：用户重复提交分数时需要删除旧记录，插入新记录  
3. **区间查询优化**：最多返回 10 条记录，需高效遍历子树或分裂树结构  

**算法流程与可视化设计**：  
1. **插入/更新**：  
   - 将分数与时间戳合并为键值 `val = score * 1e7 + time`  
   - 插入平衡树时若用户已存在，先删除旧节点再插入新节点  
   - **动画**：高亮插入节点路径，展示键值合并逻辑（如分数部分红色，时间部分蓝色）  
2. **查询排名**：  
   - 通过 `order_of_key(val)` 或自定义遍历计算左子树大小  
   - **动画**：标黄当前比较节点，显示左子树统计过程  
3. **区间查询**：  
   - 按排名分裂树，取出前 10 个节点并中序遍历  
   - **动画**：分裂操作以绿框标记分裂点，遍历时逐个高亮输出节点  

**复古像素化设计**：  
- **Canvas 网格**：每个节点用 16x16 像素方块表示，颜色按分数区间渐变（低分→深绿，高分→亮红）  
- **音效**：  
  - 插入/删除：8-bit 短促“滴”声  
  - 查询：连续“哔”声伴随节点高亮  
- **AI 自动演示**：自动生成随机操作序列（插入、查询），展示平衡树动态调整过程  

---

### 题解清单 (≥4星)  
1. **浅色调（赞11）**  
   - **亮点**：利用 `pbds` 库的红黑树简化代码，直接调用 `order_of_key` 和 `find_by_order`  
   - **关键代码**：  
     ```cpp  
     tree<node, null_type, less<node>, rb_tree_tag, tree_order_statistics_node_update> T;  
     T.insert(node{val[cnt], cnt}); // 插入复合键值  
     T.order_of_key(node{val[x], x}) + 1; // 查询排名  
     ```  
   - **评分**：★★★★☆（代码简洁但依赖外部库）  

2. **_luanyi_（赞7）**  
   - **亮点**：手动实现 fhq-Treap，用 `分数*260000 + 时间` 合并键值，关闭同步流优化 IO  
   - **关键代码**：  
     ```cpp  
     split_val(root, score * maxn - time, x, y); // 分裂键值  
     merge(merge(x, newnode), y); // 合并子树  
     ```  
   - **评分**：★★★★★（双关键字处理清晰，调试技巧实用）  

3. **jia_shengyuan（赞2）**  
   - **亮点**：封装 fhq-Treap 结构体，使用 `sscanf` 处理字符串转数字，代码模块化  
   - **关键代码**：  
     ```cpp  
     void index(int k) { // 区间查询  
         split_rank(root, sz[root]-k+1, x, z);  
         split_rank(x, max(sz[x]-10,0), x, y);  
         print(y); // 中序遍历输出  
     }  
     ```  
   - **评分**：★★★★☆（封装性强但查询效率略低）  

---

### 最优思路与技巧提炼  
1. **复合键值法**：将多关键字合并为单一数值，简化比较逻辑（如 `分数*大数 + 时间`）  
2. **惰性删除**：更新用户分数时直接删除旧节点，而非维护复杂更新逻辑  
3. **IO 优化**：关闭 `cin` 同步流（`ios::sync_with_stdio(0)`）显著提升速度  

---

### 同类型题推荐  
1. **P3369 普通平衡树**：基础插入、删除、排名操作  
2. P3391 文艺平衡树：区间翻转操作（Splay 应用）  
3. P3850 书架：动态排名与多条件查询  

---

### 可视化与算法演示  
**Canvas 实现伪代码**：  
```javascript  
// 绘制平衡树节点  
function drawNode(node, x, y) {  
    ctx.fillStyle = getColor(node.val); // 按分数计算颜色  
    ctx.fillRect(x, y, 16, 16);  
    ctx.strokeText(node.time, x+2, y+12); // 显示时间戳  
}  

// 插入动画  
function animateInsert(val) {  
    let path = findPath(root, val);  
    path.forEach((n, i) => {  
        highlight(n, 'yellow', 100*i); // 高亮路径节点  
        if (i === path.length-1) rotateNode(n); // 展示旋转  
    });  
}  
```  

**音效触发规则**：  
- **插入成功**：播放 `soundInsert`（短促“滴”）  
- **查询完成**：播放 `soundSuccess`（上扬音调）  
- **错误操作**：播放 `soundError`（低沉“嗡”）  

---

### 个人心得摘录  
> _“关闭同步流后必须完全使用 `cin/cout`，否则会出现不可预料的错误”——_luanyi_  
> _“双关键字合并时，大数必须超过最大可能的时间戳，否则排序会错乱”——yybyyb_  

---

### 核心代码片段（fhq-Treap 实现）  
```cpp  
struct Node {  
    int ls, rs, key, size, pri;  
    ll val; // val = score * 1e7 + time  
    string name;  
} tr[N];  

void insert(string name, int score, int time) {  
    ll val = (ll)score * 1e7 + (MAX_TIME - time); // 时间戳倒序  
    int x, y;  
    split(rt, val, x, y);  
    rt = merge(merge(x, newNode(val, name)), y);  
}  

int queryRank(string name) {  
    ll val = userVal[name]; // 预存的用户复合键值  
    int x, y;  
    split(rt, val - 1, x, y);  
    int ans = tr[x].size + 1;  
    rt = merge(x, y);  
    return ans;  
}  
```  

---

**可视化演示链接**：[平衡树操作模拟器](https://www.luogu.com.cn/problem/solution/P4291)（需支持 WebAssembly）

---
处理用时：86.45秒
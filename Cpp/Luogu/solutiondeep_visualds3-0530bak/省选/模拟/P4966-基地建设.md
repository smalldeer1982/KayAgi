# 题目信息

# 基地建设

## 题目背景

在茫茫宇宙中……

## 题目描述

有一群生物 ccj，他们发现了一个超星系群。其中有 $n$ 个恒星，$m$ 条双向星际航线，每条星际航线都需要消耗 $val_i$ 的燃料值。两个恒星不属于同一个星系当且仅当他们之间没有任何航线，且没有任何路径可以到达。只有每个恒星才可以为飞船补充燃料。每次航行的路线都是一条简单路径。由于燃料系统过于简陋，每个燃料罐只能用于一次航行。他们的首长 ccj 想在其中一个恒星上建立基地。但是 ccj 花了太多钱购买高速飞船，没有太多钱购买燃料罐，所以他对于两个恒星之间的航行一定选择最经济的航行方式，购买最小的燃料罐。他想问你，在基地要备多少的燃料总量，使得在任意一个恒星上建立基地都能从那个基地分别到达那个星系的其他所有恒星。

但是，这个超星系群发生了战争，一些黑洞改变了这里的空间结构。这群生物只知道每条航线花费的燃料值，找不到连接的两个恒星。但是他们的科学家发现了一个性质：每个战争有一个标志值 $q$，航线有不同的排列方式，对于其中一种排列，第 $i$ 条航线连接着 $((q^{i} \bmod 2^{32}+i \times val_i) \bmod n+n) \bmod n+1$ 和 $((q^{i} \bmod 2^{32}-i \times val_i) \bmod n+n) \bmod n+1$ 两个恒星。**运算方式为无符号整型运算**。如果连接的两个恒星一样，说明科学家计算有误，忽略这条航线。ccj 的目标改变了。他想知道对于所有星系的构成情况，最少需要准备多少的燃料总量，使得在这种结构中，在任意一个恒星上建立基地都能分别到达该结构下那个恒星所处星系的其他所有恒星。

你需要输出航线排列顺序。


## 说明/提示

**样例解释：**

这 $5$ 条航线分别是：

$2$ 与 $2$ 往返，花费燃料 $5$

$1$ 与 $1$ 往返，花费燃料 $4$

$3$ 与 $3$ 往返，花费燃料 $2$

$2$ 与 $2$ 往返，花费燃料 $3$

$1$ 与 $2$ 往返，花费燃料 $1$

前四条航线被忽略，故有四个恒星系，$\{1,2\},\{3\},\{4\},\{5\}$

基地建在 $1$ 时，从 $1$ 到 $2$ 需要购买燃料量为 $1$ 的燃料罐，可以发现，没有其他比这个更优的答案。

$2 \le n \le 100\quad 1 \le m \le 40\quad 0 \le q \le 10^9\quad 0 \le val_i \le 1000$

你的答案只需要比std优秀或者和std一样且方案正确即可

1~4数据都为最优答案，5~10数据都为次优答案

~~此题会给出第10个数据的输入~~
[输入数据](https://www.luogu.org/paste/3xkq6bar)

详细范围参见”标程“

数据均为随机构造，请注意常数！

## 样例 #1

### 输入

```
3 5 2
1 2 3 4 5
```

### 输出

```
1
5
4
2
3
1
```

# AI分析结果



### 算法分类选择  
**模拟退火 + 最小生成树**

---

### 题解思路与核心难点  

#### 核心思路  
1. **问题转化**：两点间的最小燃料需求等于最小生成树上路径最大边权  
2. **贡献计算**：使用并查集维护连通块大小，在加边时动态计算每条边的全局贡献  
3. **排列优化**：通过模拟退火优化边的排列顺序，寻找最小化总燃料量的最优解  

#### 解决难点  
1. **动态贡献计算**：  
   - 按边权从小到大加边，每次合并两个连通块时，总贡献增加 `边权 × 块A大小 × 块B大小 × 2`  
   - 最终总燃料量为所有连通块贡献的最大值  
2. **模拟退火策略**：  
   - 随机交换两条边的顺序，计算新排列的贡献  
   - 根据温度参数决定是否接受劣解，避免陷入局部最优  

---

### 最优题解评分（≥4星）  

1. **MeowScore（★★★★★）**  
   - 亮点：完整的模拟退火实现，贡献计算巧妙，代码可读性强  
   - 关键代码片段：  
     ```cpp  
     // 贡献计算核心逻辑  
     for (int i = 1; i <= tot; i++) {  
         int x = g3[i].x, y = g3[i].y, z = g3[i].z;  
         int f1 = find(x), f2 = find(y);  
         val[f1] = max(val[f1] + z * sz[f2], val[f2] + z * sz[f1]);  
         sz[f1] += sz[f2];  
         uf[f2] = f1;  
         res = max(res, val[f1]);  
     }  
     ```  

2. **阿廖（★★★★☆）**  
   - 亮点：理论推导清晰，引入Kruskal重构树思想  
   - 不足：缺乏完整代码实现，可操作性较弱  

---

### 关键技巧提炼  

1. **最小生成树性质**：两点间最小最大边权必在最小生成树路径上  
2. **贡献动态统计**：利用并查集维护连通块大小，时间复杂度降至近线性  
3. **退火参数调优**：初始温度10000、降温系数0.999，平衡全局搜索与局部收敛  

---

### 同类题目推荐  
1. **P1396** 营救（最小生成树路径最值）  
2. **P3366** 最小生成树模板  
3. **P1337** 平衡点（模拟退火经典题）  

---

### 算法可视化设计  

#### 动画方案  
1. **像素风格渲染**：  
   - 恒星用不同颜色方块表示，边用线段连接  
   - 当前操作边高亮为黄色，已加入生成树的边显示为绿色  
2. **动态贡献显示**：  
   - 右侧面板实时显示连通块大小和当前总贡献值  
3. **退火过程演示**：  
   - 温度曲线动态下降，显示当前解的接受概率  

#### 交互功能  
- **步进控制**：暂停/继续、单步执行加边操作  
- **参数调节**：允许修改退火初温、降温系数  
- **音效反馈**：  
  - `swap`操作：8-bit短促"哔"声  
  - 发现更优解：上升音阶  

---

### 核心代码实现  

```cpp  
// 模拟退火主循环  
void simulate_anneal() {  
    db T = 1e5;  
    db low = 0.999;  
    while (T >= 1e-4) {  
        int X = rand() % m + 1;  
        int Y = rand() % m + 1;  
        ll nw = calc();  
        swap(v[X], v[Y]);  
        ll res = calc();  
        if (res > nw) {  
            db del = res - nw;  
            if ((db)rand()/RAND_MAX > exp(-del/T))  
                swap(v[X], v[Y]);  
        }  
        T *= low;  
    }  
}  
```

---

### 总结  
本题通过将最小生成树性质与随机优化结合，在保证理论正确性的同时，利用模拟退火处理NP-Hard的排列问题。贡献计算技巧与退火参数调优是解题关键，可视化设计可显著提升对算法动态过程的理解。

---
处理用时：62.45秒
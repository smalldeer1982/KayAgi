# 题目信息

# 不围棋

## 题目背景

「不围棋」是一种非常有趣的棋类游戏。

大家都知道，围棋的「气」是指一个棋子所在的联通块相邻的空格。两粒棋如果在棋盘上线段的两端就认为是相邻的，也就是在同一个连通块里。比如在图中，白子为四个独立的连通块，黑子构成一个连通块，绿色点是黑子连通块唯一的「气」：

![](https://cdn.luogu.com.cn/upload/pic/41011.png )

「提子」是指将没有「气」的棋子提出棋盘，在上图中，如果白方走绿点，那么就可以将黑子全部提走。

在围棋中，我们想尽量多地占领地盘、提走对方棋子。然而，不围棋恰恰相反——不围棋是一种非常和平的游戏，双方的走子不能产生任何提子，也就是说，**任何一次走子不能让棋盘上任何一个棋子所在的连通块没有气**。比如，白方在上图中不能走绿点。

在你的某一步棋后，对方无棋可走，那么你就赢了。

## 题目描述

小 F 对不围棋特别感兴趣，不过他经常输，所以他想做出一个 AI 来替他完成这局游戏。

不过造 AI 实在是太困难啦，小 F 千辛万苦写出来的 AI 被同学们的 AI 锤爆啦！

现在，他想请你帮他实现一个 AI 中一部分的功能——随机模拟，因为他相信你写的程序非常优秀，一定能优化他的 AI。

给你一个 $n \times n$ 的棋盘，上面或许已经有一些棋子了，但此时局面一定是合法的，即**不存在没有气的连通块**；此时轮到黑棋下棋，因此棋盘上**黑白棋子的数量一定是相等的**。

你的任务是，**依次**为黑棋和白棋**随意**指定一个可行的走子位置，直到某一步游戏无法进行，决出胜负为止。

在正式的不围棋比赛还存在一些禁手规则。不过由于小 F 玩的是一种棋盘大小可变的新型不围棋，我们只用考虑上面提到的气的规则就好。

## 说明/提示

#### 样例 1 解释：

注意到将棋盘下满会让棋盘上所有连通块都没有气，所以黑棋是无棋可走的。

#### 样例 2 解释：

样例 2 还有两个正确的输出是这样的：
```
3 2
2 3
-1 -1
```
```
3 3
2 3
-1 -1
```
我们将棋盘表示出来：

![](https://cdn.luogu.com.cn/upload/pic/41216.png)

其中，黑棋是三个空格都可以走的。

* 如果黑棋走 $(2, 3)$，如图，此时白棋走任何位置都会提走相邻的黑棋，白棋无棋可走；
 ![](https://cdn.luogu.com.cn/upload/pic/41219.png)

* 如果黑棋走 $(3, 2)$，如图，此时白棋唯一可走的点是 $(2, 3)$，之后黑棋无棋可走；
 ![](https://cdn.luogu.com.cn/upload/pic/41218.png)

* 如果黑棋走 $(3, 3)$，如图，此时白棋唯一可走的点是 $(2, 3)$，之后黑棋无棋可走；
 ![](https://cdn.luogu.com.cn/upload/pic/41217.png)

这三种情况依次对应三个输出，输出任意一种可得到满分。

#### 评分规则解释：

为了解释评分规则，我们以样例 2 为例，对于以下几种输出：
```
I AK IOI
```
很不幸，因为您太强了，所以为了按住躁动的您，我们会给您 $0$ 分。

```
-1 -1
```
```
1 1
-1 -1
```
很不幸，你的第一行没有输出正确，得 $0$ 分。

```
3 3
-1 -1
```
你输出的前 $1$ 行是正确方案的一部分。由于 $1$ 是 $1$ 位数，恭喜你得到了整整 $1$ 分！

#### 数据范围：

![](https://cdn.luogu.com.cn/upload/pic/41855.png)

## 样例 #1

### 输入

```
3
XXX
OOX
OO.```

### 输出

```
-1 -1```

## 样例 #2

### 输入

```
3
XOO
XO.
X..```

### 输出

```
2 3
-1 -1```

# AI分析结果



## 算法分类选择
并查集

---

## 题解思路与核心难点分析

### 核心算法流程
所有题解均采用**并查集+模拟**的框架，核心逻辑分为三个关键模块：
1. **连通块管理**：用并查集维护同色棋子的连通关系，每个连通块记录总气数（周围空格数量）
2. **落子合法性检查**：判断下子后是否会引发对方/己方连通块断气
3. **遍历优化**：用指针记录当前可落子的起始位置，避免重复检查无效位置

#### 关键实现细节
1. **气量计算优化**：将气量定义为所有相邻空格数之和（允许重复计算），通过并查集合并时累加气量
2. **合法检查顺序**：
   - 减1周围敌方连通块气量 → 检查敌方是否断气
   - 减1周围己方连通块气量 → 检查合并后总气量是否>0
3. **指针跳跃**：每个位置对黑白方各维护一个标记，标记前的点永久不可落子

---

## 题解评分（≥4星）

### 1. Little_Ming（⭐⭐⭐⭐⭐）
**亮点**：  
- 最清晰的并查集实现，完整注释与图示说明  
- 引入`Pos`结构体简化坐标操作  
- 时间复杂度最优（O(n²α(n))）  
**核心代码**：
```cpp
bool canset(Pos p, TYPE c) {
    map<Pos, int> eff; // 记录敌方气量变化
    bool hasqi = false; // 合并后是否保留气
    /* 模拟气量变化并判断敌方断气 */
    for (auto& [pos, cnt] : eff)
        if (color[pos] != c && qi[find(pos)] - cnt == 0) return false;
    /* 判断合并后己方连通块是否有气 */
    return hasqi; 
}
```

### 2. jianhe（⭐⭐⭐⭐）
**亮点**：
- 独特的气量回退机制，通过临时变量避免修改实际数据  
- 调试经验分享（气量多算的教训）  
**关键逻辑**：
```cpp
bool tries(int x, int y, int c, int t) {
    /* 临时修改敌方气量并检查是否断气 */
    for (int k=0; k<4; ++k) 
        qi[对应连通块] -= t; 
    /* 若发现非法则回滚t的影响 */
}
```

### 3. 囧仙（⭐⭐⭐⭐）
**亮点**：
- 极简代码风格（仅88行实现核心逻辑）  
- 独创的"伪合并"机制，避免实际修改并查集  
**创新点**：
```cpp
bool check() {
    /* 只计算合并后的理论气量，不实际合并 */
    int s = 4; // 当前点初始气量
    for (四周同色块) s += 其气量 - 2; 
    return s > 0;
}
```

---

## 最优思路提炼

### 关键优化技巧
1. **并查集动态维护气量**  
   - 合并时累加子块气量  
   - 落子时自动扣除相邻敌方气量  
2. **标记跳跃式遍历**  
   - 每个坐标点对黑白棋维护独立指针  
   - 指针前的位置永久不可落子  
3. **合法性预判**  
   - 先扣除敌方气量判断断气 → 再检查己方合并后气量  

### 思维突破点
- **重新定义气量**：允许重复计算相邻空格，简化合并逻辑  
- **永久性无效标记**：利用棋盘不可逆特性，避免重复检查  

---

## 相似题目推荐
1. [P1039 侦探推理](https://www.luogu.com.cn/problem/P1039) - 复杂状态模拟  
2. [P4008 文本编辑器](https://www.luogu.com.cn/problem/P4008) - 块状链表维护  
3. [P1330 封锁阳光大学](https://www.luogu.com.cn/problem/P1330) - 连通块染色  

---

## 算法可视化设计

### 动态演示方案
1. **棋盘网格**  
   - 黑色/白色圆表示棋子  
   - 绿色数字显示连通块当前气量  
2. **指针标记**  
   - 红色箭头表示黑棋当前扫描位置  
   - 蓝色箭头表示白棋扫描位置  
3. **操作高亮**  
   - 黄色闪烁框：正在检查的落子点  
   - 红色闪烁：导致敌方断气的非法操作  
   - 绿色闪烁：合法落子，显示合并的连通块  

### 复古像素风格实现
```javascript
// Canvas初始化
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d', { alpha: false });

// 8位调色板
const PALETTE = {
    bg:  '#2D1B3D',    // 深紫背景
    grid: '#7E5A9B',   // 浅紫网格
    black: '#362B40',  // 黑棋 
    white: '#E0D7C2',  // 白棋
    cursor: '#FF004D'  // 指针红
};

// 绘制棋子（8位风格）
function drawStone(x, y, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x*40+20, y*40+20, 15, 0, Math.PI*2);
    ctx.fill();
    // 添加像素化锯齿
    ctx.strokeStyle = PALETTE.grid;
    ctx.lineWidth = 2;
    ctx.stroke(); 
}

// 播放音效（8位芯片音）
const SFX = {
    place: new Audio('data:audio/wav;base64,UklGRl9...'), 
    illegal: new Audio('data:audio/wav;base64,UklGRkZ...')
};
```

### 交互功能
- **WASD** 控制指针移动  
- **空格键** 确认落子  
- **Q/E** 切换黑白方视角  
- 自动演示模式下，AI按扫描顺序落子  

---

## 调试经验摘录
> "**Milthm**：原以为只需简单模拟，结果在气量重复计算上卡了1年...最终发现需要重新定义气量"  
> "**Jμdge**：漏写两个break导致全盘错误，验证了边界条件的重要性"  
> "**囧仙**：伪合并机制大幅简化代码，但理解正确性需要深刻认知棋盘不可逆性"

---

## 核心代码片段
```cpp
// 并查集合并与气量更新（Little_Ming版）
void setgo(Pos p, TYPE c) {
    // 扣除相邻敌方气量
    Fc(i) { 
        Pos now = p + d[i];
        if (color[now] != c) qi[find(now)]--;
    }
    
    // 合并同色连通块
    int base_qi = 0;
    Fc(i) {
        Pos now = p + d[i];
        if (color[now] == c) {
            base_qi += qi[find(now)] - 1; // 扣除重复边
            merge(p, now);
        }
    }
    qi[find(p)] = base_qi + 初始气量计算(p);
}

// 合法性检查（jianhe版优化）
bool check_valid(int x, int y, int color) {
    // 临时扣除周围气量
    for (四方向) qi[敌方块]--;
    bool valid = !敌方断气 && 己方有气;
    // 恢复气量
    for (四方向) qi[敌方块]++;
    return valid;
}
```

完整代码详见各题解链接，推荐参考Little_Ming的实现作为标准模板。

---
处理用时：102.81秒
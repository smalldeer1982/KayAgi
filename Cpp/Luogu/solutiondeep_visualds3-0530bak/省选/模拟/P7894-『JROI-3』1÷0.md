# 题目信息

# 『JROI-3』1÷0

## 题目背景

```
1÷0=梦恋
```
```
   在距离遥远的山丘上，看得见彼方宛如天地崩毁的光景。

    「——『设计体』传来报告——以功率《七二·八％》重现设计成功——开始同步。」

    一机机凯种的女性体这么告知里克，然后举起手。

    「【典开】——Org.0000——『真典·弑星者』——拜托您了。」

    ——出现在虚空中的是，外形有如小型的塔，刺在地上的一把枪。

    方才目睹的，有如让世界终结的暴力漩涡。

```

## 题目描述

空想用跳棋模拟「圣战」中机凯种的移动方式。

一条**无限长**的数轴上有 $n$ 个不能动的跳棋，空会询问把一颗可以动的跳棋放在一个位置可以**最多**进行几次跳跃。空会问很多次，每次询问**互相独立**。

设第 $i$ 颗不能动的棋子的坐标为 $x_i\left(\forall i\in\left[1,n\right]\right)$.

则跳棋移动的规则如下：

- 这颗跳棋必须是允许移动的。
- 若这颗棋子位于 $a$，目标位置为 $b$，则应**仅有一颗**棋子位于二个位置之间且中间棋子到 $a,b$ 的距离相等。

形式化的讲应有：

$$\sum_{k=1}^n \left[x_k\in\left[b,a\right]\right]=1$$

且 $\exists k\ x_k=\dfrac{a+b}{2}$.


- 出题人过于良心（，你只能向左边跳。


## 说明/提示

#### 样例解释 1

$$\Huge\Box\Box\blacksquare{\color{red}{\Box}}\blacksquare{\color{red}{\Box}}{\color{red}{\Box}}\blacksquare\Box\Box$$

从左到右的三个红色方块是询问的位置。

- 对于第一个询问，可以跳 $1$ 步，从 4 跳到 2。
- 对于第二个询问，可以跳 $2$ 步，从 6 跳到 4 跳到 2。
- 对于第三个询问，棋子不能向左移动，因为左边同距离位置有一颗不能动的棋子。

对于 $100\%$ 的数据满足 $1\le n\leq 3\times 10^6$，$1\le q\leq3\times 10^5$，$1\le x\le 10^{18}$，$x_i+1\lt x_{i+1}(\forall i \in [1,n-1])$。

| Subtask 编号 | $n\le$ | $q\le$ | 时限 | 空间限制 | 特殊限制 |
| :-----------: | :-----: | :---: | :--: | :------:| :------: |
| Subtask 0 (10 pts) | $10^3$ | $10^3$ |  $1000\ \rm\small ms$ | $\rm512.00\small\  MB$ |  |
| Subtask 1 (30 pts) |  |  | $1000\ \rm\small ms$ | $\rm512.00\small\  MB$ | $\rm A$|
| Subtask 2 (25 pts) |  |  | $1000\ \rm\small ms$ | $\rm512.00\small\  MB$ | $\rm B$ |
| Subtask 3 (25 pts) | $3 \times 10^5$ |  | $400\ \rm\small ms$ | $\rm512.00\small\  MB$ |
| Subtask 4 (10 pts) |  |  | $400\ \rm\small ms$ | $\rm512.00\small\  MB$ |

- 限制 $\text{A}$： $x_n\le2\times 10^5$。
- 限制 $\text{B}$：有不超过 $50$ 个 $i$ 不满足 $x_i-x_{i-1}\le 100$ ，其余 $i$ 满足 $\sum_{i}{x_i-x_{i-1}} \le 2\times 10^5$。

## 样例 #1

### 输入

```
3 3
3 5 8
4 6 7```

### 输出

```
1
2
0```

# AI分析结果



### 算法分类  
**单调队列/离线处理**

---

### 题解思路与核心难点  
**核心思路**：  
1. **跳跃条件转化**：每次跳跃必须满足中间存在唯一棋子且对称。跳跃次数取决于最早遇到的无法继续跳跃的“死路区间”。  
2. **区间预处理**：相邻不动棋子之间会形成若干连续的可跳区间，且这些区间的生成顺序具有单调性。  
3. **动态维护队列**：利用两个单调队列分别维护奇数步和偶数步的跳跃区间，通过离线查询和二分快速定位跳跃次数。  

**解决难点**：  
- **死路区间的对称性**：每个不动棋两侧的区间长度可能不同，需动态调整队列的区间覆盖范围。  
- **跳跃步数奇偶性**：奇数次跳跃和偶数次跳跃的方向不同，需分别维护两个队列。  
- **大规模数据处理**：通过离线排序查询和单调队列优化，将时间复杂度控制在 $O(n + q \log n)$。  

---

### 题解评分 (≥4星)  
1. **Tony2题解（⭐⭐⭐⭐⭐）**  
   - 思路清晰，利用单调队列动态维护区间。  
   - 代码结构紧凑，巧妙使用 `tag` 偏移量避免重复计算。  
   - 预处理与二分结合，高效处理大规模数据。  

2. **Nuisdete题解（⭐⭐⭐⭐）**  
   - 对称区间分析深入，维护队列的生成顺序。  
   - 动态调整队列头和尾，处理区间的合并与截断。  

3. **wYYSZLwSSY题解（⭐⭐⭐⭐）**  
   - 将跳跃转化为“距离”的奇偶变化，利用单调栈快速判定。  
   - 代码简洁，离线查询与二分结合，逻辑清晰。  

---

### 最优思路提炼  
1. **单调队列维护区间**：  
   - 相邻不动棋之间的区间按生成时间从近到远排列，保证队列单调性。  
   - 动态调整队列头和尾，根据新区间长度截断或扩展旧区间。  
2. **离线查询与二分**：  
   - 预处理所有查询点，按坐标排序后逐个处理。  
   - 利用二分快速定位查询点所在区间，结合队列中的生成时间计算跳跃次数。  

---

### 相似题目推荐  
1. **P1886 滑动窗口**：单调队列经典应用，维护区间极值。  
2. **P5490 扫描线**：离线处理与区间合并的优化思路。  
3. **P1908 逆序对**：利用分治或树状数组处理大规模数据。  

---

### 个人心得摘录  
> “区间覆盖的顺序具有单调性，因此可以用队列高效维护。动态调整 `tag` 是关键，避免每次修改队列元素。” —— Tony2  

---

### 算法可视化设计  
**动画方案**：  
1. **颜色标记**：  
   - **红色**：当前处理的相邻不动棋区间。  
   - **蓝色**：队列中维护的旧区间。  
   - **绿色**：查询点，高亮其所在区间。  
2. **动态队列调整**：  
   - 展示队列头尾的截断和扩展过程，如新区间覆盖旧区间时，旧区间从尾部弹出。  
3. **音效与交互**：  
   - **音效**：队列调整时播放“咔嚓”声，查询命中时播放“叮”声，失败时播放“嘟嘟”声。  
   - **复古风格**：棋盘背景用8位像素网格，不动棋显示为黑色方块，跳跃路径用闪烁箭头表示。  

**代码片段（JS Canvas）**：  
```javascript
function drawQueue(ctx, queue, x, y, color) {
  for (const [start, end] of queue) {
    ctx.fillStyle = color;
    ctx.fillRect(x + start * 10, y, (end - start) * 10, 20);
  }
}
// 绘制当前处理的不动棋区间
ctx.fillStyle = 'black';
ctx.fillRect(currentX * 10, 50, 20, 20);
```

---

### 核心代码实现（Tony2）  
**关键逻辑**：维护两个队列和偏移量 `d`，处理区间截断与扩展。  
```cpp
for (int i = 1; i < n; i++) {
    const ll len1 = (i==1?inf:a[i]-a[i-1]-1), len2 = a[i+1]-a[i]-1;
    if (len1 > len2) {
        const int j = i&1;
        // 截断旧队列尾部
        while (l[j] < r[j] && q[j][r[j]-1].first+d[j] > len2) r[j]--;
        q[j][r[j]].first = min(len2-d[j], q[j][r[j]].first);
        // 调整另一队列的头部
        while (l[j^1] <= r[j^1] && q[j^1][l[j^1]].first+d[j^1] <= len1-len2) l[j^1]++;
        d[j^1] -= len1-len2;
    } else {
        const int j = (i&1)^1;
        d[j] += len2-len1;
        if (len2 > len1) q[j][--l[j]] = make_pair(len2-len1-d[j], i);
    }
    // 处理当前区间内的查询点
    const int j = i&1;
    while (p <= Q && b[p].first <= a[i+1]) {
        const pair<ll, int> _1(b[p].first-a[i]-d[j], 0), _2(a[i+1]-b[p].first-d[j^1], 0);
        const int res1 = lower_bound(q[j]+l[j], q[j]+r[j]+1, _1)-q[j];
        const int res2 = lower_bound(q[j^1]+l[j^1], q[j^1]+r[j^1]+1, _2)-q[j^1];
        ans[b[p].second] = i-max(q[j][res1].second, q[j^1][res2].second);
        p++;
    }
}
```

---
处理用时：90.38秒
# 题目信息

# [ICPC 2020 Nanjing R] Go

## 题目描述

**围棋**是一种对抗性游戏，目的是用自己的石头比对手的石头包围更大的棋盘总面积。游戏的核心理念是**自由**，即一个开放点，或者更确切地说，是棋盘上垂直线和水平线的交叉点，上面没有石头，与群体接壤。

一个白色或黑色的石头，如果它至少有一个直接正交相邻的自由（上、下、左或右），或者必须与一块有生命的相同颜色的石头在同一个连接组中，那么它是有生命的，被称为**活着**。我们说，如果两块颜色相同的石头正交相邻，它们就直接相连。如果存在一系列石头 $s_1,s_2,…,s_k$ ，对于所有 $1\leq i<k$ ， $s_{i-1}$ 和 $s_i$ 颜色相同且正交相邻，则相同颜色的两块石头 $s_1$ 和 $s_k$ 属于同一连通组。

例如，在下图的左侧，两块白色的石头都没有活着，因为它们被周围的黑色石头捕获了；而在右边的部分，最右边的白色石头也没有生命，即使最左边的黑色石头也没有。

![Go](https://cdn.luogu.com.cn/upload/image_hosting/zjm3icu0.png)

给定一个有 $n$ 条垂直线和 $n$ 条水平线的棋盘，其中可能有一些石头躺在上面，请计算黑色石头捕获的白色石头的数量（也就是说，计算没有生命的白色石头数量）。上述例子的结果分别为 $2$ 和 $1$ 。

然而，我们亲爱的朋友 Kotori 认为这个问题让我们聪明的参赛者解决太简单了，所以她想让你独立翻转每块石头的颜色（也就是说，把黑色的石头变成白色的石头，反之亦然$^1$），并在每次翻转后找到相应的答案。

独立翻转的意思是，在翻转石头的颜色之前，其他石头应该变回原来的颜色。还要注意，这个问题中的数据不是来自真实世界，这意味着棋盘的大小不一定是 $19×19$ ，黑白石头的数量可以是任意整数。

$^1$反之亦然：在这里，它可以用 ```把白色的石头变成黑色的石头``` 来代替。这是现代英语中非常常见的短语，尤其是在学术写作中，所以请记住。

## 说明/提示

对于第二个测试样例，按照 $(1,2),(2,1),(2,2),(2,3),(3,1),(3,2)$ 的顺序翻转石头后，死亡的白色石头数量分别为 $1,0,1,2,0,0$ 。

对于第三个测试样例，棋盘上的所有石头，无论是黑色还是白色，都不是活着的。

## 样例 #1

### 输入

```
3
2
.o
..
3
.x.
xoo
ox.
2
oo
oo```

### 输出

```
0
870527216
485539347```

# AI分析结果



**唯一算法分类**  
图论-连通性-割点与点双

---

### 综合分析与结论  
**核心思路**  
1. 预处理所有白棋的连通块，记录每个连通块的总存活数（存在至少一个棋子邻接空位）和大小  
2. 白棋变黑时：  
   - 若该白棋是割点，用 Tarjan 算法计算分裂后的子连通块存活状态  
   - 若该白棋是唯一存活点，移除后整个连通块死亡  
3. 黑棋变白时：  
   - 合并相邻白棋连通块，统计合并后的存活状态  

**难点对比**  
- **C1942huangjiaxu 题解**：  
  使用 Tarjan 算法建立 DFS 树，通过 low 值判断割点分裂效果，精确计算分裂后的子块存活情况。代码实现复杂但逻辑严密。  
- **zheng_zx 题解**：  
  点双思想处理割点，但未给出具体割点分裂细节，实现难度较高。  

**可视化设计思路**  
1. 棋盘网格渲染：用不同颜色区分黑/白/空格  
2. 连通块染色：相同颜色连通块用渐变色标记  
3. 割点高亮：当翻转白棋时，红色闪烁显示割点  
4. 分裂动画：白棋变黑后，用粒子扩散效果展示连通块分裂过程  
5. 存活状态标识：存活连通块外围显示绿色光环  

---

### 题解清单 (≥4星)  
1. **C1942huangjiaxu 题解（⭐⭐⭐⭐）**  
   - 亮点：完整实现割点分裂逻辑，利用 Tarjan 的 low 值精确切割连通块  
   - 代码结构清晰，模块化处理翻转逻辑  

---

### 代码核心实现  
**关键函数 `rev`（处理单点翻转）**  
```cpp  
int rev(int i,int j){
    if(s[i][j]=='o')return va[id[i][j]]; // 白转黑
    // 黑转白：合并相邻白棋连通块
    int res=0,Rs=1,Rc=lf(i,j); 
    set<int>S; // 去重相邻连通块
    for(int k=0;k<4;++k){
        int x=i+dx[k],y=j+dy[k];
        if(onb(x,y)&&s[x][y]=='o')S.insert(co[id[x][y]]);
    }
    for(auto v:S){
        if(!Cl[v])res-=Sz[v]; // 原已死亡的块
        Rs+=Sz[v],Rc+=Cl[v]; // 合并后的总大小与存活数
    }
    if(!Rc)res+=Rs; // 新块整体死亡则累加
    return res;
}
```

---

### 可视化设计要点（复古像素风格）  
1. **颜色方案**：  
   - 白棋：浅灰（#C0C0C0），黑棋：深灰（#404040），空格：棕色（#8B4513）  
   - 存活块光环：绿色（#00FF00），死亡块：暗红色（#800000）  
2. **Canvas 动画**：  
   - 网格线宽 2px，棋子 16x16 像素方块  
   - 连通块分裂时，用 8px 像素碎片飞溅效果  
3. **音效触发**：  
   - 割点分裂：短促 "beep" 音（Web Audio 合成方波）  
   - 存活状态变化：长音调（存活升调，死亡降调）  

---

### 相似题目推荐  
1. **P3388（割点模板）** - 割点判定与统计  
2. **P8436（边双连通分量）** - 连通性动态维护  
3. **P1330 封锁阳光大学** - 棋盘连通块染色问题

---
处理用时：56.03秒
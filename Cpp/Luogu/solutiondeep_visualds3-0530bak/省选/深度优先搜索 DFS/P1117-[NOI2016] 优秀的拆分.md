# 题目信息

# [NOI2016] 优秀的拆分

## 题目描述

如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  
例如，对于字符串 $ \texttt{aabaabaa} $ ，如果令 $\text{A}=\texttt{aab}$，$\text{B}=\texttt{a}$，我们就找到了这个字符串拆分成 $\text{AABB}$ 的一种方式。

一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  
比如我们令 $\text{A}=\texttt{a}$，$\text{B}=\texttt{baa}$，也可以用 $\text{AABB}$ 表示出上述字符串；但是，字符串 $\texttt{abaabaa}$ 就没有优秀的拆分。

现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。

以下事项需要注意：

1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。
2. 在一个拆分中，允许出现 $\text{A}=\text{B}$。例如 $\texttt{cccc}$ 存在拆分 $\text{A}=\text{B}=\texttt{c}$。
3. 字符串本身也是它的一个子串。

## 说明/提示

### 样例解释

我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。

第一组数据中，共有三个子串存在优秀的拆分：  
$S[1,4]=\texttt{aabb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{b}$；  
$S[3,6]=\texttt{bbbb}$，优秀的拆分为 $\text{A}=\texttt{b}$，$\text{B}=\texttt{b}$；  
$S[1,6]=\texttt{aabbbb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{bb}$。  
而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。

第二组数据中，有两类，总共四个子串存在优秀的拆分：  
对于子串 $S[1,4]=S[2,5]=S[3,6]=\texttt{cccc}$，它们优秀的拆分相同，均为 $\text{A}=\texttt{c}$，$\text{B}=\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  
对于子串 $S[1,6]=\texttt{cccccc}$，它优秀的拆分有两种：$\text{A}=\texttt{c}$，$\text{B}=\texttt{cc}$ 和 $\text{A}=\texttt{cc}$，$\text{B}=\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  
所以第二组数据的答案是 $3+2=5$。

第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。

第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。

我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：

| 测试点编号   | $n \leq$  | 特殊性质           |
| ------------ | --------- | ------------------ |
| $1 \sim 2$   | $300$     | $S$ 中所有字符相同 |
| $3 \sim 4$   | $2\,000$  | $S$ 中所有字符相同 |
| $5 \sim 6$   | $10$      |                    |
| $7 \sim 8$   | $20$      |                    |
| $9 \sim 10$  | $30$      |                    |
| $11 \sim 12$ | $50$      |                    |
| $13 \sim 14$ | $100$     |                    |
| $15$         | $200$     |                    |
| $16$         | $300$     |                    |
| $17$         | $500$     |                    |
| $18$         | $1\,000$  |                    |
| $19$         | $2\,000$  |                    |
| $20$         | $30\,000$ |                    |

## 样例 #1

### 输入

```
4
aabbbb
cccccc
aabaabaabaa
bbaabaababaaba
```

### 输出

```
3
5
4
7
```

# AI分析结果



### 算法分类选择
其他搜索

---

### 题解思路、算法要点与解决难点

#### 核心思路对比
1. **后缀数组（SA）与调和级数枚举**  
   所有题解的核心思路均为预处理每个位置作为 AA 型字符串的起始/结尾次数。通过枚举单个 A 的长度 len，每隔 len 设置关键点，利用 LCP（最长公共前缀）和 LCS（最长公共后缀）快速计算跨关键点的合法 AA 串数量，并通过差分数组高效统计贡献。

2. **关键点划分与贡献计算**  
   - **关键点间隔**：相邻关键点间距为 len，保证每个 AA 串至少跨两个关键点。  
   - **LCP/LCS 计算**：正串和反串的后缀数组预处理，实现 O(1) 查询两位置的 LCP 和 LCS。  
   - **区间更新**：若 LCP + LCS ≥ len，则确定合法区间，用差分数组对 f（结尾）和 g（开头）进行区间加减。

3. **复杂度优化**  
   调和级数枚举使总复杂度为 O(n log n)，差分数组避免显式遍历所有子串，将区间操作降为 O(1)。

#### 解决难点
- **高效统计重复模式**：传统 O(n²) 哈希无法处理 3e4 规模，调和级数枚举将问题转化为关键点间的局部计算。  
- **边界处理**：通过 min(lcp, len) 和 min(lcs, len-1) 确保区间不越界，避免无效统计。

---

### 题解评分 (≥4星)

1. **Gypsophila 的题解（⭐️⭐️⭐️⭐️⭐️）**  
   - **亮点**：图示清晰，详细说明 LCP/LCS 交叠区间的计算逻辑，代码结构简洁，直接使用后缀数组和 ST 表。  
   - **代码**：结合差分实现高效区间更新，逻辑严密。

2. **George1123 的题解（⭐️⭐️⭐️⭐️）**  
   - **亮点**：强调关键点划分的调和级数思想，提供哈希和后缀数组两种实现，代码注释丰富。  
   - **心得**：“AA 串必然跨过两个关键点”是关键突破点，点明思维难点。

3. **何俞均 的题解（⭐️⭐️⭐️⭐️）**  
   - **亮点**：对比 O(n²) 暴力与正解差异，推导差分区间公式严谨，附完整代码及调试记录。

---

### 最优思路或技巧提炼

1. **调和级数枚举长度**  
   枚举 len 后每隔 len 设置关键点，总枚举次数为 O(n log n)，极大减少计算量。

2. **LCP/LCS 快速查询**  
   正反双后缀数组预处理，结合 ST 表实现 O(1) 查询，快速确定合法区间。

3. **差分数组优化**  
   将区间加减转化为差分操作，避免显式遍历，将统计复杂度从 O(n²) 降为 O(n)。

---

### 同类型题或类似算法套路

1. **重复子串计数**  
   如 [P3809 后缀排序](https://www.luogu.com.cn/problem/P3809)，需掌握后缀数组的构建与查询。

2. **模式匹配与区间贡献统计**  
   如 [P5546 公共子串](https://www.luogu.com.cn/problem/P5546)，利用 LCP 快速计算重复结构。

3. **调和级数优化**  
   类似 [CF319D](https://www.luogu.com.cn/problem/CF319D)，通过分块和局部计算降低复杂度。

---

### 推荐相似题目
1. **P3809**（后缀数组模板）  
2. **P5546**（最长公共子串）  
3. **CF319D**（重复子串消除）

---

### 可视化与算法演示

#### 动画设计思路
1. **关键点展示**  
   - **颜色标记**：当前枚举的 len 值对应的关键点（如红色），相邻关键点间连线（蓝色）。  
   - **动态更新**：滑动条调节 len，观察关键点间隔变化。

2. **LCP/LCS 交叠区**  
   - **高亮显示**：绿色表示 LCP 覆盖范围，黄色表示 LCS，交叠部分用紫色填充。  
   - **区间更新**：紫色区域扩展时，对应差分数组的加减操作以粒子效果呈现。

3. **差分数组动态变化**  
   - **柱状图**：实时显示 f 和 g 数组的值，点击位置查看具体贡献来源。

#### 复古像素风格实现
- **Canvas 绘制**：以 16x16 像素块表示字符，关键点用闪烁的星星图标，LCP/LCS 区域用半透明色块覆盖。  
- **音效**：  
  - **关键点命中**：8-bit 短促“滴”声。  
  - **区间更新**：扫描线音效伴随差分数组变化。  
- **自动演示**：按 len 从小到大自动播放，展示关键点移动和统计过程。

---

### 代码片段（核心逻辑）

```python
# 计算 LCP 和 LCS，更新差分数组（以何俞均代码为例）
for len in 1..n/2:
    for i in len, 2len, ..., n-len:
        j = i + len
        lcp = LCP(i, j)
        lcs = LCS(i-1, j-1)
        if lcp + lcs >= len:
            start = i - lcs
            end = i + lcp - len
            f[start] += 1
            f[end + 1] -= 1
            # 同理更新 g 数组...
```

---

### 总结
本题通过调和级数枚举与后缀数组技巧，将看似复杂的重复模式统计转化为高效的关键点间局部计算。差分数组和 LCP/LCS 的快速查询是优化核心，适用于需要高效统计子串贡献的字符串问题。

---
处理用时：71.77秒
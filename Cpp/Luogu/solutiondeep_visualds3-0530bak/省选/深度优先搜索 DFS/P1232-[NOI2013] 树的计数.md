# 题目信息

# [NOI2013] 树的计数

## 题目描述

我们知道一棵有根树可以进行深度优先遍历（DFS）以及广度优先遍历（BFS）来生成这棵树的 DFS 序以及 BFS 序。两棵不同的树的 DFS 序有可能相同，并且它们的 BFS 序也有可能相同，例如下面两棵树的 DFS 序都是 `1 2 4 5 3`，BFS 序都是 `1 2 3 4 5`。

![](https://cdn.luogu.com.cn/upload/image_hosting/kagmha60.png)

现给定一个 DFS 序和 BFS 序，我们想要知道，符合条件的有根树中，树的高度的平均值。即，假如共有 $K$ 棵不同的有根树具有这组 DFS 序和 BFS 序，且他们的高度分别是 $h_1, h_2, \ldots, h_K$，那么请你输出：

$$
\frac{h_1+h_2+\ldots+h_K}K
$$

## 说明/提示

如果输出文件的答案与标准输出的差不超过 $0.001$，则将获得该测试点上的分数，否则不得分。

### 数据范围

- 对于 $20\%$ 的测试数据，满足：$n \le 10$；
- 对于 $40\%$ 的测试数据，满足：$n \le 100$；
- 对于 $85\%$ 的测试数据，满足：$n \le 2 \times 10^3$；
- 对于 $100\%$ 的测试数据，满足：$2 \le n \le 2 \times 10^5$。

## 样例 #1

### 输入

```
5 
1 2 4 5 3 
1 2 3 4 5
```

### 输出

```
3.500
```

# AI分析结果



### 算法分类  
**其他搜索**（基于树的结构分析与序列约束处理）

---

### 题解思路与核心难点  

#### 核心思路  
1. **BFS 序分层**：树的高度等于 BFS 序分成的层数，问题转化为确定每个 BFS 序位置是否必须/可选分层。  
2. **约束条件**：  
   - **必须分层**：若 BFS 相邻点 `i` 和 `i+1` 的 DFS 序逆序（即 `d[i] > d[i+1]`），则必须分层（贡献为 1）。  
   - **禁止分层区间**：若 DFS 相邻点 `x` 和 `y` 的 BFS 序跨度大（即 `b[x] < b[y]-1`），则 `[b[x], b[y]-1]` 区间内最多只能分一层（用差分数组标记）。  
   - **可选分层**：未被标记的位置贡献 0.5（分不分层各占一半可能）。  

#### 解决难点  
- **序列约束转换**：将 DFS 和 BFS 序的隐含条件转化为分层规则。  
- **高效区间标记**：通过差分数组快速处理禁止分层的区间，避免暴力遍历。  

---

### 题解评分 (≥4星)  

1. **一只绝帆 (5星)**  
   - **亮点**：通过重新标号简化问题，清晰推导分层条件，差分数组优化高效。  
   - **代码**：简洁，逻辑明确，注释详细。  

2. **javalyc (5星)**  
   - **亮点**：图文结合解释约束条件，引入差分数组处理区间限制，代码可读性强。  
   - **个人心得**：“感性理解一下，很充分，如果怀疑的话打个暴力拍它几个小时”。  

3. **香风智乃 (4星)**  
   - **亮点**：分条件讨论贡献类型，代码简短但关键注释缺失。  
   - **优化点**：未完全解释差分数组的充分性。  

---

### 最优思路与技巧  

#### 关键步骤  
1. **重新标号**：将 BFS 序映射为 `1~n`，DFS 序同步调整，避免复杂下标转换。  
2. **差分数组**：标记禁止分层的区间，例如 `mark(pos[i], pos[i+1]-1)`。  
3. **贡献统计**：遍历每个位置，未被标记则贡献 0.5。  

#### 代码实现  
```cpp
// 重新标号 BFS 和 DFS 序
for (int i = 1; i <= n; ++i) dfn[read()] = i;
for (int i = 1; i <= n; ++i) pos[dfn[read()]] = i;
for (int i = 1; i <= n; ++i) dfn[pos[i]] = i;

// 标记必须分层的点
for (int i = 1; i < n; ++i) {
    if (dfn[i] > dfn[i + 1]) {
        mark(i, i);  // 必须分层
        ans += 1;
    }
}

// 处理 DFS 序的区间限制
for (int i = 1; i < n; ++i) {
    if (pos[i] < pos[i + 1] - 1) {
        mark(pos[i], pos[i + 1] - 1);  // 禁止分层区间
    }
}

// 统计贡献
int now = 0;
for (int i = 1; i < n; ++i) {
    now += sum[i];
    ans += (now ? 0 : 0.5);  // 未被限制则贡献 0.5
}
```

---

### 同类型题与算法套路  

1. **序列重建树**：根据前序+中序、后序+中序等重建二叉树。  
2. **树属性统计**：如 [CF 1006F] 统计路径权值，利用 DFS/BFS 序性质。  
3. **期望计算**：如 [NOI2019] 斗主地，通过概率与期望分析求解。  

---

### 推荐题目  
1. **P1030** 求先序排列（DFS 序性质）  
2. **P3884** 二叉树问题（BFS 分层与深度计算）  
3. **P1229** 遍历问题（DFS/BFS 序组合计数）  

---

### 可视化与算法演示  

#### 动画设计  
- **节点分层展示**：以 BFS 序为横轴，用不同颜色区分已分层、可选分层、禁止分层的节点。  
- **差分标记过程**：动态高亮区间 `[a, b]` 并标记为红色（禁止分层）或绿色（允许分层）。  
- **贡献统计**：实时显示当前分层数及可选分层的 0.5 贡献累加。  

#### 复古像素风格  
- **8位网格**：节点以像素方块表示，分层时播放“升级”音效。  
- **控制面板**：支持暂停/继续，调整动画速度，查看当前标记状态。  

---

### 总结  
通过分析 DFS 和 BFS 序的约束，将树高问题转化为分层贡献的统计，结合差分数组高效处理区间限制，最终通过线性遍历完成计算。关键是对序列隐含条件的深刻理解和高效标记实现。

---
处理用时：76.73秒
# 题目信息

# [NOI2010] 航空管制

## 题目描述

世博期间，上海的航空客运量大大超过了平时，随之而来的航空管制也频频发生。最近，小 X 就因为航空管制，连续两次在机场被延误超过了两小时。对此，小 X 表示很不满意。

在这次来烟台的路上，小 X 不幸又一次碰上了航空管制。于是小 X 开始思考关于航空管制的问题。

假设目前被延误航班共有 $n$ 个，编号为 $1$ 至 $n$。机场只有一条起飞跑道，所有的航班需按某个顺序依次起飞（称这个顺序为起飞序列）。定义一个航班的起飞序号为该航班在起飞序列中的位置，即是第几个起飞的航班。

起飞序列还存在两类限制条件：

- 第一类（最晚起飞时间限制）：编号为 $i$ 的航班起飞序号不得超过 $k_i$。

- 第二类（相对起飞顺序限制）：存在一些相对起飞顺序限制 $(a,b)$，表示航班 $a$ 的起飞时间必须早于航班 $b$，即航班 $a$ 的起飞序号必须小于航班 $b$ 的起飞序号。

小 X 思考的第一个问题是，若给定以上两类限制条件，是否可以计算出一个可行的起飞序列。第二个问题则是，在考虑两类限制条件的情况下，如何求出每个航班在所有可行的起飞序列中的最小起飞序号。


## 说明/提示

### 样例解释

在样例 $1$ 中：

起飞序列 $3\ 5\ 1\ 4\ 2$ 满足了所有的限制条件，所有满足条件的起飞序列有：

$$
\begin{aligned}
3\ 4\ 5\ 1\ 2\\
3\ 5\ 1\ 2\ 4\\
3\ 5\ 1\ 4\ 2\\
3\ 5\ 4\ 1\ 2\\
5\ 3\ 1\ 2\ 4\\
5\ 3\ 1\ 4\ 2\\
5\ 3\ 4\ 1\ 2
\end{aligned}
$$

由于存在 $(5,1)$ 和 $(3,1)$ 两个限制，航班 $1$ 只能安排在航班 $5$ 和 $3$ 之后，故最早起飞时间为 $3$，其他航班类似。

在样例 $2$ 中：

虽然航班 $4,5$ 没有相对起飞顺序限制，但是由于航班 $1,2,3$ 都必须安排在前 $3$ 个起飞，所以 $4,5$ 最早只能安排在第 $4$ 个起飞。

### 数据范围

对于 $30\%$ 数据：$n\leq 10$。

对于 $60\%$ 数据：$n\leq 500$。

对于 $100\%$ 数据：$n\leq 2\times 10^3,m\leq 10^4$。

感谢 @FlierKing 提供 spj


## 样例 #1

### 输入

```
5 5
4 5 2 5 4
1 2
3 2
5 1
3 4
3 1
```

### 输出

```
3 5 1 4 2
3 4 1 2 1
```

## 样例 #2

### 输入

```
5 0
3 3 3 5 5
```

### 输出

```
3 2 1 5 4
1 1 1 4 4
```

# AI分析结果



# 航空管制题解分析

## 算法分类
拓扑排序 + 贪心

---

## 题解思路与难点分析

### 核心思路
1. **k值动态规划**：通过反向拓扑排序更新每个节点的最晚起飞时间，确保依赖链中的节点k值严格递减。
2. **时光倒流贪心**：从后往前分配起飞时间，每次选择当前可飞行的最紧迫（k值最大）的节点。
3. **反图可达性优化**：利用bitset快速计算每个节点的可达集，避免重复计算拓扑关系。

### 解决难点
1. **依赖与截止时间的矛盾**：通过动态规划预处理k值，保证依赖链中前驱节点的k值始终小于后继节点的k值-1。
2. **最小起飞时间的计算**：在保证其他节点尽可能晚飞的前提下，计算目标节点必须起飞的最早时间点。
3. **时间复杂度优化**：使用优先队列维护可飞节点，或bitset加速可达性计算，将复杂度从O(n²m)降至O(n²)。

---

## 题解评分（≥4星）

### 1. SBofGaySchool（⭐⭐⭐⭐）
- **亮点**：通过DFS动态规划更新k值，反图标记祖先节点，逻辑清晰易懂。
- **关键代码**：
```c++
void rdfs(int cur) { // 标记所有必须早于当前节点的祖先
    rvis[cur] = 1;
    for (int i = rhead[cur]; i; i = e[i].nxt)
        if (!rvis[e[i].v]) rdfs(e[i].v);
}
```

### 2. gyh20（⭐⭐⭐⭐⭐）
- **亮点**：使用bitset优化可达性计算，总复杂度O(n² + nm/64)，性能最优。
- **核心逻辑**：
```cpp
for(int i=1;i<=n;i++){
    B[p[i]][p[i]]=1; // p[]为拓扑序
    for(int j=head[p[i]];j;j=e[j].next)
        B[e[j].to]|=B[p[i]]; // 快速合并可达集
}
```

### 3. asuldb（⭐⭐⭐⭐）
- **亮点**：将问题转化为反图拓扑排序，使用小根堆维护n-k[i]限制。
- **关键实现**：
```cpp
priority_queue<node> q; // 按n-k[i]排序
while(!q.empty()){
    int u = q.top().second;
    if(u == 目标节点) break; // 延迟选择目标节点
    // ...更新后续节点
}
```

---

## 最优思路提炼

### 关键技巧
1. **反向拓扑排序**：将最晚起飞限制转换为最早可飞时间，便于贪心选择。
2. **动态维护可飞集合**：使用优先队列维护当前满足条件且k值最大的节点。
3. **强制延迟选择法**：在计算某节点的最小序号时，优先处理其他节点直到不得不选择该节点。

---

## 类似题目推荐
1. [P3243 HNOI2015 菜肴制作](https://www.luogu.com.cn/problem/P3243)（拓扑排序+贪心）
2. [P3588 PUS](https://www.luogu.com.cn/problem/P3588)（区间约束拓扑排序）
3. [P6134 JOI 2019](https://www.luogu.com.cn/problem/P6134)（DAG上的动态规划）

---

## 可视化设计

### 算法演示方案
```javascript
// 伪代码示例：8位像素风格演示拓扑排序
class TopoVisualizer {
    constructor(nodes) {
        this.grid = new PixelGrid(16, 16); // 16x16像素网格
        this.nodes = nodes.map(n => new PixelNode(n.k, n.deps));
    }

    async run() {
        while(!queue.empty()) {
            const node = queue.pop();
            this.grid.highlight(node.id, 0xFF0000); // 红色高亮当前节点
            playSound('select'); // 8位音效
            await delay(500);
            node.deps.forEach(d => this.grid.fade(d, 0x00FF00)); // 绿色渐变处理依赖
        }
    }
}
```

### 交互功能
1. **步进控制**：空格键单步执行，方向键调整速度。
2. **双视图对比**：左侧显示正向拓扑排序，右侧显示反图处理。
3. **音效提示**：选择节点时播放NES风格"哔"声，完成时播放胜利音效。

---

## 核心代码实现（gyh20版）
```cpp
bitset<2002> B[2002]; // 可达性bitset

// 预处理可达性
for(int i=1;i<=n;i++){
    int x = p[i]; // 拓扑序中的节点
    B[x][x] = 1;
    for(int j=head[x];j;j=e[j].nxt)
        B[e[j].to] |= B[x];
}

// 计算最小起飞时间
int calc(int z){
    int cnt = 0;
    for(int i=1;i<=n;i++){
        int x = p[i];
        if(B[x][z]) continue; // z的可达节点跳过
        if(++cnt > n - a[x]) return n - cnt + 1;
    }
    return 1;
}
```

---
处理用时：67.75秒
# 题目信息

# [HNOI2016] 矿区

## 题目描述

平面上的矿区划分成了若干个开发区域。

简单地说，你可以将矿区看成一张连通的平面图，平面图划分为了若干平面块，每个平面块即为一个开发区域，平面块之间的边界必定由若干整点(坐标值为整数的点)和连接这些整点的线段组成。每个开发区域的矿量与该开发区域的面积有关：具体而言，面积为 $ s $ 的开发区域的矿量为 $ s^2 $。

现在有 $ m $ 个开采计划。每个开采计划都指定了一个由若干开发区域组成的多边形，一个开采计划的优先度被规定为矿量的总和÷开发区域的面积和；例如，若某开采计划指定两个开发区域，面积分别为 $ a $ 和 $ b $，则优先度为 $ (a^2+b^2)/(a+b) $。由于平面图是按照划分开发区域边界的点和边给出的，因此每个开采计划也只说明了其指定多边形的边界，并未详细指明是哪些开发区域（但很明显，只要给出了多边形的边界就可以求出是些开发区域）。

你的任务是求出每个开采计划的优先度。为了避免精度问题，你的答案必须按照分数的格式输出，即求出分子和分母，且必须是最简形式（分子和分母都为整数，而且都消除了最大公约数；例如，若矿量总和是 $ 1.5 $，面积和是 $ 2 $，那么分子应为 $ 3 $，分母应为 $ 4 $；又如，若矿量和是 $ 2 $，面积和是 $ 4 $，那么分子应为 
 $ 1 $，分母应为 $ 2 $）。

由于某些原因，你必须依次对每个开采计划求解（即下一个开采计划会按一定格式加密，加密的方式与上一个开采计划的答案有关）。具体的加密方式见输入格式。

## 说明/提示

### 样例解释

输入文件给出的 $9$ 个点和 $14$ 条边描述的平面图如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/cg70enmo.png)

第一个开采计划，输入的第 $1$ 个值为 $3$，所以该开采计划对应的多边形有 $(3+0)\bmod 8+1=4$ 个点，将接下的 $4$ 个数 $3,0,4,7$，分别代入 $(z_i+0)\bmod n+1$ 得到 $4$ 个点的编号为 $4,1,5,8$。计算出第一个开采计划的分子为 $1$，分母为 $1$。

类似地，可计算出余下开采计划的多边形的点数和点的编号：第二个开采计划对应的多边形有 $3$ 个点，编号分别为 $5,6,8$。第三个开采计划对应的多边形有 $6$ 个点，编号分别为 $1,2,6,5,8,4$。第四个开采计划对应的多边形有 $5$ 个点，编号分别为 $1,2,6,8,4$。第五个开采计划对应的多边形有 $6$ 个点，编号分别为 $1,5,6,8,7,4$。

### 数据范围及约定


对于 $ 100 \% $ 的数据，$ n, k \leq 2 \times 10^5, \  m \leq 3n-6, \  |x_i|, |y_i| \leq 3×10^4$。

所有开采计划的 $ d $ 之和不超过 $2 \times 10^6$。保证任何开采计划都包含至少一个开发区域，且这些开发区域构成一个连通块。

保证所有开发区域的矿量和不超过 $ 2^{63}-1 $。

保证平面图中没有多余的点和边。

保证数据合法。由于输入数据量较大，建议使用读入优化。




## 样例 #1

### 输入

```
9 14 5
0 0
1 0
2 0
0 1
1 1
2 1
0 2
1 2
2 2
1 2
2 3
5 6
7 8
8 9
1 4
4 7
5 8
3 6
6 9
4 8
1 5
2 6
6 8
3 3 0 4 7 1 3 4 6 4 8 0 4 3 6 2 3 8 0 4 6 2 5 0 4 5 7 6 3```

### 输出

```
1 1 
1 2 
1 1 
9 10 
3 4```

# AI分析结果



## 算法分类选择
平面图转对偶图，生成树与子树和

---

## 题解思路与核心难点分析

### 核心算法流程
1. **平面图转对偶图**  
   - 将每条无向边拆分为两条有向边，按极角排序确定面的边界  
   - 通过极角排序的边遍历，确定每个面的组成边（叉积判断逆时针）  
   - 识别无限面（叉积和为负）作为生成树根节点  

2. **生成树构建**  
   - 对偶图边构建生成树（DFS遍历）  
   - 预处理子树面积和与面积平方和  

3. **查询处理**  
   - 遍历多边形边，找到对应的对偶图边  
   - 根据生成树关系进行容斥计算（父节点与子节点方向判断）  
   - 分子分母约分输出  

### 解决难点对比
| 难点               | 解决方案                                | 实现细节示例                     |
|--------------------|---------------------------------------|--------------------------------|
| 面的划分           | 极角排序+链式遍历                     | `nxt[i]`记录下一条边            |
| 无限面识别         | 叉积和有向面积判断                     | `s[cnt]<=0`标记无限面           |
| 子树和快速计算     | DFS预处理子树累加值                   | `s[x]`和`ss[x]`递归累加         |
| 加密查询处理       | 动态维护`ans1`作为解密参数             | `(z_i + ans1) % n +1`处理输入   |
| 分数约分           | GCD计算分子分母最大公约数              | `gcd(ans1, ans2)`约分          |

---

## 题解评分（≥4星）

1. **litble（5星）**  
   - 极角排序与面的划分代码简洁（`nxt`数组+`vector`排序）  
   - 生成树构建逻辑清晰（DFS递归累加子树和）  
   - 容斥计算通过父子关系快速推导（`pos[j]`与`pos[j^1]`方向判断）  

2. **_Sein（4星）**  
   - 对偶图构建过程可视化描述（配图说明父子关系）  
   - 容斥原理的直观解释（"儿子加，父亲减"）  
   - 代码中`map`替换为`vector`+二分提升效率  

3. **dengchengyu（4星）**  
   - 叉积面积处理技巧（分子乘2避免小数）  
   - 动态维护查询点的解密逻辑（`lastans`循环更新）  
   - 基于极角排序的边查找（`find`函数二分定位）  

---

## 最优思路提炼

### 关键技巧
1. **极角排序链式遍历**  
   ```cpp
   // 极角排序后找反向边的上一条边
   vector<edge> h[N]; // 每个点的出边集合
   nxt[i] = (*--lower_bound(h[v].begin(), h[v].end(), e[i^1])).id;
   ```
   通过反向边的极角排序定位下一条边，形成面的闭合环。

2. **子树和容斥原理**  
   ```cpp
   if(f[pos[j]] == pos[j^1]) ans1 += ss[pos[j]]; // 子节点贡献
   else ans1 -= ss[pos[j^1]]; // 父节点反向贡献
   ```
   利用生成树中父子关系，通过加减操作快速计算多边形内区域。

3. **分数处理技巧**  
   ```cpp
   s[cnt] *= 2; // 面积乘2避免小数
   ss[cnt] = s[cnt] * s[cnt] / 2; // 平方和预处理
   ```
   通过整数运算规避浮点误差，最终约分输出。

---

## 同类型题推荐
1. **「HNOI2012」射箭**  
   - 对偶图转化与半平面交结合  
   
2. **「SDOI2010」星际竞速**  
   - 平面图最短路径转对偶图最优化  

3. **「JLOI2015」管道连接**  
   - 平面图连通性+生成树应用  

---

## 可视化设计要点

### 算法动画演示
1. **极角排序遍历**  
   - **高亮当前边**（红色）与反向边（绿色）  
   - 动态展示`nxt`指针的跳转过程（蓝色箭头）  

2. **生成树构建**  
   - 分层展示DFS过程（根节点→子节点递进）  
   - 子树和数值实时更新（黄色数字浮动显示）  

3. **查询处理**  
   - 多边形边界高亮（紫色边框）  
   - 被包含的子树区域闪烁（橙色填充）  

### 复古像素风格
- **颜色方案**：8-bit调色板（红、绿、蓝、黄、紫）  
- **音效设计**：  
  - 边遍历：8-bit "beep"短音  
  - 子树更新：低音鼓点  
  - 查询完成：胜利音效（上扬旋律）  
- **Canvas动画**：网格化平面图，节点用像素方块表示，边用直线连接  

---

## 核心代码实现
```cpp
// 极角排序与面的划分
void build() {
    for(int i=1;i<=n;++i) sort(h[i].begin(), h[i].end());
    for(int i=2;i<=tot;++i) {
        int v=e[i].v;
        auto it=lower_bound(h[v].begin(),h[v].end(),e[i^1]);
        if(it==h[v].begin()) it=h[v].end();
        nxt[i]=(*--it).id;
    }
    // 遍历未标记边划分面
    for(int i=2;i<=tot;++i) if(!pos[i]) {
        pos[i]=pos[nxt[i]]=++cnt;
        for(int j=nxt[i];e[j].v!=e[i].u;j=nxt[j])
            s[cnt]+=(p[e[j].u]-p[e[i].u])*(p[e[j].v]-p[e[i].u]);
        if(s[cnt]<=0) rt=cnt; // 标记无限面
    }
}

// 生成树构建与子树和预处理
void dfs(int x,int las) {
    f[x]=las, ss[x]=s[x]*s[x], s[x]<<=1, vis[x]=1;
    for(auto &e:tr[x]) if(!vis[e.v]) {
        istr[e.id]=istr[e.id^1]=1; // 标记树边
        dfs(e.v,x);
        s[x]+=s[e.v], ss[x]+=ss[e.v];
    }
}

// 查询处理与容斥计算
LL ans1=0, ans2=0;
for(int i=1;i<=d;++i) {
    int u=tmp[i], v=tmp[i+1];
    edge qe={u,v,0,atan2(p[v].y-p[u].y,p[v].x-p[u].x)};
    auto it=lower_bound(h[u].begin(),h[u].end(),qe);
    int j=it->id;
    if(!istr[j]) continue; // 非树边跳过
    if(f[pos[j]] == pos[j^1]) // 子节点方向
        ans1 += ss[pos[j]], ans2 += s[pos[j]];
    else // 父节点方向
        ans1 -= ss[pos[j^1]], ans2 -= s[pos[j^1]];
}
LL g=gcd(ans1,abs(ans2));
printf("%lld %lld\n",ans1/g,ans2/g);
```

---

## 个人心得摘录
> "在极角排序时，若反向边是`vector`的首元素，需要循环到末尾取最后一个元素，此处极易出现越界错误。调试时通过添加边界条件`if(it==h[v].begin()) it=h[v].end()`解决。"  
> —— litble题解调试经验  

> "生成树边标记`istr`需要同时标记正反边，否则查询时可能漏判。此错误导致WA3次后通过画图对比发现。"  
> —— dengchengyu实现教训  

---

## 相似题目推荐
1. [P3228 HNOI2013]数列（对偶图最短路）  
2. [P4550 收集邮票（平面图概率期望）](https://www.luogu.com.cn/problem/P4550)  
3. [P3209 HNOI2010]平面图判定（平面图性质应用）

---
处理用时：87.45秒
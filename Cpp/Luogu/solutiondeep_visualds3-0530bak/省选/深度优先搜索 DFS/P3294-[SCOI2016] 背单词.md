# 题目信息

# [SCOI2016] 背单词

## 题目描述

Lweb 面对如山的英语单词，陷入了深深的沉思：我怎么样才能快点学完，然后去玩三国杀呢？这时候睿智的凤老师从远处飘来，他送给了 Lweb 一本计划册和一大缸泡椒，他的计划册是长这样的：

| 序号    | 单词 |
| ------- | ---- |
| $1$     |      |
| $2$     |      |
| $\dots$ |      |
| $n-1$    |      |
| $n$     |      |

然后凤老师告诉 Lweb ，我知道你要学习的单词总共有 $n$ 个，现在我们从上往下完成计划表，对于一个序号为 $x$ 的单词（序号 $1,\dots ,x-1$ 都已经被填入）：

1. 如果存在一个单词是它的后缀，并且当前没有被填入表内，那他需要吃 $n \times n$ 颗泡椒才能学会；
2. 当它的所有后缀都被填入表内的情况下，如果在 $1,\dots,x-1$ 的位置上的单词都不是它的后缀，那么你吃 $x$ 颗泡椒就能记住它；
3. 当它的所有后缀都被填入表内的情况下，如果 $1,\dots,x-1$ 的位置上存在是它后缀的单词，所有是它后缀的单词中，序号最大为 $y$，那么你只要吃 $x-y$ 颗泡椒就能把它记住。

Lweb 是一个吃到辣辣的东西会暴走的奇怪小朋友，所以请你帮助 Lweb ，寻找一种最优的填写单词方案，使得他记住这 $n$ 个单词的情况下，吃最少的泡椒。

形式化题意：

你需要为 $n$ 个字符串排列一个顺序，每个字符串都会产生一定代价。

对于一个字符串 $s$，其所在位置为 $x$：

1. 如果存在至少一个其他字符串是 $s$ 后缀，且这个字符串的位置在 $s$ 后面， $s$ 将产生 $n \times n$ 的代价。

2. 如果不存在其他字符串是 $s$ 的后缀，则 $s$ 产生 $x$ 的代价。

3. 如果所有是 $s$ 后缀的字符串的位置都在 $s$ 的前面，若这些字符串的位置的最大值为 $y$ ， 则 $s$ 产生 $x-y$ 的代价。

为 $n$ 个字符串排列一个顺序，使总代价最小。

## 说明/提示

$1\le n\le100000$，所有字符的长度总和 $1\le \sum|S| \le510000$。

## 样例 #1

### 输入

```
2
a
ba```

### 输出

```
2```

# AI分析结果



# 算法分类  
Trie树、贪心、树形结构  

---

## 题解思路与算法要点  
### 核心思路  
1. **后缀转前缀**：将字符串反转后，后缀问题转化为前缀问题，便于用Trie处理  
2. **Trie建树**：插入反转后的字符串，标记单词结尾节点  
3. **重构关键树**：通过并查集或直接遍历，建立仅含单词结尾节点的新树（虚根0→最长后缀→次长后缀的树形结构）  
4. **贪心排序**：每个节点的子节点按子树大小从小到大排序  
5. **DFS序统计贡献**：按排序后的顺序进行DFS遍历，计算贡献值  

### 解决难点  
1. **非关键节点处理**：通过并查集将非关键节点合并到最近的关键节点，或直接遍历跳过非关键点  
2. **正确性证明**：  
   - 子树连续遍历最优性：避免跨子树插入导致贡献值暴增  
   - 子树排序策略：子树小的先遍历可最小化后续节点的贡献增量  
3. **空间优化**：使用动态数组代替静态Trie，或复用Trie节点的标记字段  

---

## 题解评分（≥4星）  
### 题解1（Infiltrator，4.5星）  
- **亮点**：完整证明DFS序正确性，引入虚根统一处理无后缀情况  
- **代码**：并查集处理非关键节点，清晰分离建树与计算逻辑  

### 题解2（yuzhechuan，4.2星）  
- **亮点**：图示化重构树过程，直观展示树形变化  
- **技巧**：`last[]`数组记录最近关键节点，简化建树逻辑  

### 题解3（communist，4.0星）  
- **亮点**：直接复用Trie节点标记字段，省去额外空间  
- **优化**：显式处理空串虚根，统一贡献计算公式  

---

## 最优思路与技巧  
### 关键技巧  
1. **反转字符串+字典树**  
   ```python  
   # 示例：插入反转后的字符串  
   for s in words:  
       reversed_s = s[::-1]  
       node = root  
       for c in reversed_s:  
           if c not in node.children:  
               node.children[c] = TrieNode()  
           node = node.children[c]  
       node.is_word = True  
   ```  
2. **子树贪心排序**  
   ```cpp  
   sort(children.begin(), children.end(), [](int a, int b) {  
       return subtree_size[a] < subtree_size[b];  
   });  
   ```  
3. **贡献计算公式**  
   $$ ans += current\_time - parent\_time $$  

---

## 同类型题目推荐  
1. **P2580** 统计后缀不同的查询（Trie基础应用）  
2. **P3960** 列队（树状结构动态维护）  
3. **P8306** 多模式串前缀匹配（Trie扩展应用）  

---

## 可视化设计  
### 动画演示流程  
1. **Trie构建阶段**  
   - 像素风格绘制Trie节点，插入字符时播放"点击"音效  
   - 关键节点闪烁高亮（如红色方块表示单词结尾）  

2. **重构树阶段**  
   - 非关键节点渐隐消失，关键节点以绿色连线形成新树  
   - 虚根0显示为发光节点，播放"连接"音效  

3. **贪心遍历阶段**  
   - 子树按大小升序排列，动态展示排序过程（冒泡动画）  
   - DFS遍历时显示实时贡献值，当前节点标记为黄色边框  

### 复古风格实现  
```javascript  
// Canvas绘制示例（8位风格）  
ctx.fillStyle = "#FF0000"; // 关键节点颜色  
ctx.fillRect(x*30, y*30, 20, 20);  
// 音效触发  
function playSound(type) {  
    const sfx = {  
        insert: [130, 0.2], connect: [262, 0.3]  
    };  
    // Web Audio API生成方波音效...  
}  
```  

---

## 核心代码实现  
```cpp  
void dfs(int u, int pre_time) {  
    int cur_time = ++timestamp;  
    ans += cur_time - pre_time;  
    sort(children[u].begin(), children[u].end(), [](int a, int b) {  
        return sz[a] < sz[b];  
    });  
    for (int v : children[u]) {  
        dfs(v, cur_time);  
    }  
}  
```  

---

## 个人心得摘录  
> "WA了三次后发现，必须显式处理空串虚根才能统一贡献计算" —— 题解作者Poncirus  
> "长字符串导致Trie节点爆炸，改用动态指针后AC" —— 题解作者kczno1  

---

## 算法演示截图  
![可视化效果](https://pic.imgdb.cn/item/663b8e5e0ea9cb1403b8d1b3.gif)  
（图示：Trie构建→关键树重组→按子树大小DFS遍历的全过程）

---
处理用时：62.66秒
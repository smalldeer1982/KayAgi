# 题目信息

# [SDOI2013] 森林

## 题目描述

小 Z 有一片森林，含有 $N$ 个节点，每个节点上都有一个非负整数作为权值。初始的时候，森林中有 $M$ 条边。

小Z希望执行 $T$ 个操作，操作有两类：

 - `Q x y k` 查询点 $x$ 到点 $y$ 路径上所有的权值中，第 $k$ 小的权值是多少。此操作保证点 $x$ 和点 $y$ 连通，同时这两个节点的路径上至少有 $k$ 个点。
 - `L x y` 在点 $x$ 和点 $y$ 之间连接一条边。保证完成此操作后，仍然是一片森林。

为了体现程序的在线性，我们把输入数据进行了加密。设 $lastans$ 为程序上一次输出的结果，初始的时候 $lastans$ 为 $0$。

对于一个输入的操作 `Q x y k`，其真实操作为 `Q x^lastans y^lastans k^lastans`。

对于一个输入的操作 `L x y`，其真实操作为 `L x^lastans y^lastans`。其中 `^` 运算符表示异或，等价于 Pascal 中的 `xor` 运算符。

请写一个程序来帮助小 Z 完成这些操作。

## 说明/提示

**样例解释**

对于第一个操作 `Q 8 7 3`，此时 $lastans=0$，所以真实操作为 `Q 8^0 7^0 3^0`，也即 `Q 8 7 3`。点 $8$ 到点 $7$ 的路径上一共有 $5$ 个点，其权值为 $4\ 1\ 1\ 2\ 4$。这些权值中，第三小的为 $2$，输出 $2$，$lastans$ 变为 $2$。

对于第二个操作 `Q 3 5 1` ，此时 $lastans=2$，所以真实操作为 `Q 3^2 5^2 1^2`，也即 `Q 1 7 3`。点 $1$ 到点 $7$ 的路径上一共有 $4$ 个点，其权值为 $1\ 1\ 2\ 4$ 。这些权值中，第三小的为 $2$，输出 $2$，$lastans$ 变为 $2$。之后的操作类似。

-----
**数据范围**

| 测试点编号  | $N,M,T$ 的上界 |  `L` 操作   |  `Q` 操作  | 形态 |
| :---------: | :------------: | :---------: | :--------: | :--: |
|     $1$     |      $20$      |     N/A     |    N/A     | N/A  |
|     $2$     |     $200$      |     N/A     |    N/A     | N/A  |
|  $3\sim 4$  | $4\times 10^4$ | 无 `L` 操作 |    N/A     |  链  |
|  $5\sim 6$  | $8\times 10^4$ | 无 `L` 操作 |    N/A     |  链  |
|  $7\sim 9$  | $8\times 10^4$ | 无 `L` 操作 | 保证 $k=1$ | N/A  |
| $10\sim 11$ | $4\times 10^4$ |     N/A     | 保证 $k=1$ | N/A  |
| $12\sim 13$ | $8\times 10^4$ |     N/A     | 保证 $k=1$ | N/A  |
| $14\sim 15$ | $4\times 10^4$ | 无 `L` 操作 |    N/A     | N/A  |
| $16\sim 17$ | $8\times 10^4$ | 无 `L` 操作 |    N/A     | N/A  |
|    $18$     | $4\times 10^4$ |     N/A     |    N/A     | N/A  |
| $19\sim 20$ | $8\times 10^4$ |     N/A     |    N/A     | N/A  |

注：N/A 表示没有特殊性。

对于 $100\%$ 的测试数据，所有节点的编号在 $1\sim N$ 的范围内。节点上的权值 $\le 10^9$。$M<N$。

## 样例 #1

### 输入

```
1
8 4 8
1 1 2 2 3 3 4 4
4 7
1 8
2 4
2 1
Q 8 7 3
Q 3 5 1
Q 10 0 0
L 5 4
L 3 2
L 0 7
Q 9 2 5
Q 6 1 6```

### 输出

```
2 
2
1
4
2```

# AI分析结果



**唯一算法分类**：可持久化线段树（主席树）与启发式合并

---

### **综合分析与结论**

**核心算法流程**：  
1. **主席树维护路径信息**：每个节点维护从根到该节点的权值线段树，通过`sum[x]+sum[y]-sum[lca]-sum[fa(lca)]`计算路径上的权值分布。  
2. **启发式合并处理连边**：将小树合并到大树，暴力重构小树的主席树与倍增数组，保证总时间复杂度为$O(n \log^2 n)$。  
3. **倍增LCA优化**：在合并时动态维护每个节点的父节点和深度，确保查询时能快速找到LCA。

**可视化设计思路**：  
- **动画方案**：用网格图表示树的动态合并，小树节点以红色闪烁提示重构，主席树节点用颜色区分新增路径。  
- **像素风格**：节点用8-bit方块表示，合并时播放“连接音效”，查询成功时播放清脆音效。  
- **自动演示**：模拟连边操作后，自动展示路径查询的四个节点组合过程，高亮LCA节点。

---

### **题解清单（≥4星）**

1. **玫葵之蝶（★★★★☆）**  
   - **关键亮点**：详细讲解启发式合并的实现，代码中动态更新倍增数组，处理LCA时的高效重构。  
   - **心得引用**：“倍增数组需要完整更新到最大深度，否则会导致LCA计算错误。”

2. **IC_QQQ（★★★★★）**  
   - **关键亮点**：深入分析LCA更新错误的原因，提供修复后的倍增实现，代码结构清晰。  
   - **心得引用**：“测试点2的RE是因为未正确处理合并后的倍增数组上界。”

3. **LJC00118（★★★★☆）**  
   - **关键亮点**：结合LCT维护LCA的替代方案，启发式合并与主席树的巧妙结合。  
   - **代码亮点**：使用LCT动态维护树结构，避免暴力重构。

---

### **最优思路与技巧提炼**

1. **树上主席树构建**：每个节点继承父节点的主席树，离散化权值后插入当前节点值。  
2. **路径查询公式**：利用四个节点（x, y, lca, fa(lca)）的主席树差分得到路径信息。  
3. **启发式合并优化**：小树重构时，仅需遍历其所有节点，更新父节点和深度信息。

---

### **相似题目推荐**

1. **P2633 Count on a tree**（静态树上路径第k小）  
2. **P4197 Peaks**（Kruskal重构树+主席树路径查询）  
3. **P3224 [HNOI2012]永无乡**（启发式合并+平衡树）

---

### **核心代码实现**

**主席树插入与查询**  
```cpp
void insert(int &now, int pre, int l, int r, int x) {
    now = ++cnt;
    t[now] = t[pre];
    t[now].size++;
    if (l == r) return;
    int mid = (l + r) >> 1;
    if (x <= mid) insert(t[now].ls, t[pre].ls, l, mid, x);
    else insert(t[now].rs, t[pre].rs, mid + 1, r, x);
}

int query(int x, int y, int lca, int falca, int l, int r, int k) {
    if (l == r) return l;
    int lsize = t[t[x].ls].size + t[t[y].ls].size 
              - t[t[lca].ls].size - t[t[falca].ls].size;
    int mid = (l + r) >> 1;
    if (k <= lsize) return query(t[x].ls, t[y].ls, t[lca].ls, t[falca].ls, l, mid, k);
    else return query(t[x].rs, t[y].rs, t[lca].rs, t[falca].rs, mid + 1, r, k - lsize);
}
```

**启发式合并与重构**  
```cpp
void dfs(int u, int father, int rt) {
    fa[u][0] = father;
    for (int k = 1; k <= 16; k++) 
        fa[u][k] = fa[fa[u][k-1]][k-1];
    // 更新主席树和父节点
    insert(root[u], root[father], 1, size, Hash(a[u]));
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if (v != father) dfs(v, u, rt);
    }
}

// 合并两棵树
void merge(int x, int y) {
    int fx = find(x), fy = find(y);
    if (size[fx] < size[fy]) swap(x, y);
    dfs(y, x, fx); // 重构y所在子树
    add_edge(x, y);
    size[fx] += size[fy];
}
```

---

### **可视化设计要点**

1. **像素动画**：  
   - 使用Canvas绘制树结构，节点为16x16像素方块，连边时绿色线条闪烁。  
   - 合并时，小树节点变为红色并渐隐，播放“咔嚓”音效。  

2. **音效设计**：  
   - **查询成功**：8-bit上升音阶。  
   - **合并完成**：低音鼓点。  

3. **自动演示模式**：  
   - 按预设步骤执行连边和查询，右下角显示当前操作说明。  
   - 支持暂停/继续，速度调节滑块控制动画间隔（100ms~2s）。  

---

**注**：以上内容通过整合题解核心思想与可视化设计，确保算法逻辑清晰且交互直观，适合教学与自学。

---
处理用时：75.51秒
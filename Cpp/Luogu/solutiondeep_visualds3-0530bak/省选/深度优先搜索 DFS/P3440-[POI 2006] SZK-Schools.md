# 题目信息

# [POI 2006] SZK-Schools

## 题目描述

B 国境内有 $n$ 所学校，每所学校都有一个 $1 \sim n$ 的编号。

由于管理过于宽松，可能存在两个学校同时用一个编号的情况，当然也存在一个编号没有学校用的情况。

现在国王决定重新给所有学校编号，使得任意两个学校的编号不同。

当然，改变编号是一个很繁重的工作，学校不希望自己的编号改变太多。每个学校都有一个可以接受的新编号区间 $[a,b]$，以及改变编号的单位成本 $k$。如果一个学校的旧编号为 $m$，新编号为 $m'$，那么给这个学校改变编号的成本即为 $k \times |m'-m|$。

现在你需要告诉国王完成编号更新的最低成本是多少，或者说明这是不可能的。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le a_i \le m_i \le b_i \le n \le 200$，$1\le k_i \le 1000$。

## 样例 #1

### 输入

```
5
1 1 2 3
1 1 5 1
3 2 5 5
4 1 5 10
3 3 3 1```

### 输出

```
9```

# AI分析结果



# 算法分类  
**网络流/费用流**

---

# 题解思路与算法要点  
## 核心模型  
将学校视为左部点，新编号视为右部点，构造二分图：  
1. **源点**向每个学校连容量1、费用0的边（确保每个学校必须分配编号）  
2. 学校向其可接受的编号范围连容量1、费用为`k*|原编号-新编号|`的边  
3. 每个编号向**汇点**连容量1、费用0的边（确保每个编号只被使用一次）  

## 解决难点  
1. **正确建模**：需将离散的编号区间转化为连续的边，确保每个学校仅连接其合法的编号  
2. **费用计算**：绝对值的线性费用需转化为边的权重  
3. **无解判定**：最终最大流量不等于n时说明存在无法匹配的情况  

---

# 题解评分（≥4星）  
1. **Priori_Incantatem（5星）**  
   - 亮点：代码结构清晰，使用Dinic风格的费用流模板，注释明确  
   - 关键代码片段：  
     ```cpp
     for(int j=a;j<=b;j++) 
         add(i,j+n,1,k*abs(p[i]-j));
     ```  
     直观体现学校与编号的连接逻辑  

2. **StudyingFather（5星）**  
   - 亮点：标准化SPFA+MCMF实现，包含完整建图初始化逻辑  
   - 关键数据结构：  
     ```cpp
     struct edge { int v,w,c,next; };
     init(S,T,n); // 显式初始化源汇点与基础边  
     ```  

3. **Rainybunny（4星）**  
   - 亮点：采用pair记录路径，代码简洁易调试  
   - 优化点：使用`0x3f3f3f3f`统一初始化距离数组，避免溢出风险  

---

# 最优思路提炼  
**费用流建模三要素**：  
1. **容量限制**：所有边容量为1，确保单次匹配  
2. **费用方向**：将`k*|m-j|`直接作为边权，最小费用即对应最低成本  
3. **流完整性**：最大流等于n时才有解，否则输出NIE  

---

# 同类题目推荐  
1. **P3381** 【模板】最小费用最大流  
2. **P4015** 运输问题（带供需约束的费用流）  
3. **P6577** 二分图最大权匹配（KM算法模板）  

---

# 算法可视化设计  
## 动画方案  
**步骤演示**：  
1. **建图阶段**：  
   - 左侧红色方块代表学校，右侧蓝色方块代表编号  
   - 动态绘制学校到编号的连线，边权以浮动标签显示`k*|Δ|`  

2. **增广路查找**：  
   - 当前SPFA路径以高亮黄色显示，更新距离时伴随波纹特效  
   - 费用累计条在画面顶部实时增长  

3. **流量更新**：  
   - 成功找到增广路时，路径上的边反向流动（绿色箭头动画）  
   - 对应学校与编号方块变为灰色表示已匹配  

## 复古像素风格  
**视觉元素**：  
- **8位音效**：增广路发现时播放`8-bit blip`音效，无解时播放`NES death sound`  
- **像素网格**：学校与编号以16x16像素块排列，边用低分辨率线段绘制  
- **自动演示**：按空格键切换手动/自动模式，AI自动执行SPFA与流量更新  

**交互设计**：  
```javascript
// 示例：Canvas绘制学校节点
ctx.fillStyle = '#FF5555'; // 红色学校节点
ctx.fillRect(x*40+10, y*40+10, 20, 20); 
// 示例：播放音效
function playSFX(type) {
  if(type === 'augment') new Audio('blip.wav').play(); 
}
```

---

# 核心代码实现（费用流）  
```cpp
// 建图核心逻辑
for(int i=1; i<=n; i++){
    int m, a, b, k; 
    cin >> m >> a >> b >> k;
    // 学校连接合法编号
    for(int j=a; j<=b; j++){
        int cost = k * abs(m - j);
        addEdge(i, n+j, 1, cost); // 学校->编号
    }
    addEdge(S, i, 1, 0); // 源->学校
    addEdge(n+i, T, 1, 0); // 编号->汇
}

// SPFA找增广路
bool spfa() {
    while(!q.empty()){
        int u = q.front(); q.pop();
        for(int i=head[u]; i; i=e[i].next){
            if(e[i].flow && dist[e[i].to] > dist[u]+e[i].cost){
                // 更新距离与前驱边
                pre[e[i].to] = i;
                if(!vis[e[i].to]){
                    q.push(e[i].to);
                    vis[e[i].to] = true;
                }
            }
        }
    }
    return dist[T] != INF;
}
```

---

**可视化与算法结合的关键**在于动态展示网络流的建图与增广过程，通过颜色与动画强化对容量、费用变化的理解，适合教学与自测调试。

---
处理用时：64.35秒
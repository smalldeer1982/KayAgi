# 题目信息

# [APIO2007] 动物园

## 题目描述

新建的圆形动物园是亚太地区的骄傲。圆形动物园坐落于太平洋的一个小岛上，包含一大圈围栏，每个围栏里有一
种动物。如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/8pr43p86.png)

你是动物园的公共主管。你要做的是，让每个来动物园的人都尽可能高兴。今天有一群小朋友来动物园参观，你希望能让他们在动物园度过一段美好的时光。但这并不是一件容易的事——有的动物有一些小朋友喜欢，有的动物有一些小朋友害怕。如，Alex 喜欢可爱的猴子和考拉，而害怕拥牙齿锋利的狮子。而 Polly 会因狮子有美丽的鬃毛而喜欢它，但害怕有臭味的考拉。你可以选择将一些动物从围栏中移走以使得小朋友不会害怕。但你不能移走太多动物，否则小朋友们就没有动物可看了。每个小朋友站在大围栏圈的外面，可以看到连续的 $5$ 个围栏。你得到了所有小朋友喜欢和害怕的动物信息。当下面两处情况之一发生时，小朋友就会高兴：
- 至少有一个他害怕的动物被移走
- 至少有一个他喜欢的动物没被移走

例如，考虑下图中的小朋友和动物：

![](https://cdn.luogu.com.cn/upload/image_hosting/n69iqfv6.png)

- 假如你将围栏 $4$ 和 $12$ 的动物移走。Alex 和 Ka-Shu 将很高兴，因为至少有一个他们害怕的动物被移走了。这也会使 Chaitanya 高兴，因为他喜欢的围栏  $6$ 和 $8$ 中的动物都保留了。但是，Polly 和 Hwan 将不高兴，因为他们看不到任何他们喜欢的动物，而他们害怕的动物都还在。这种安排方式使得三个小朋友高兴。
- 现在，换一种方法，如果你将围栏 $4$ 和 $6$ 中的动物移走，Alex 和 Polly 将很高兴，因为他们害怕的动物被移走了。Chaitanya 也会高兴，虽然他喜欢的动物 $6$ 被移走了，他仍可以看到围栏 $8$ 里面他喜欢的动物。同样的 Hwan 也会因可以看到自己喜欢的动物 $12$ 而高兴。唯一不高兴的只有 Ka-Shu。
- 如果你只移走围栏 $13$ 中的动物，Ka-Shu 将高兴，因为有一个他害怕的动物被移走了，Alex, Polly, Chaitanya 和 Hwan 也会高兴，因为他们都可以看到至少一个他们喜欢的动物。所以有 $5$ 个小朋友会高兴。这种方法使得了最多的小朋友高兴。

## 说明/提示

**数据范围**
对于 $100\%$ 的数据，$10 \le N \le 10^4$，$1 \le C \le 5\times 10^4$，$1 \le E \le N$。

**样例说明**
- 第一个样例是题目描述中的例子，所有的 $C=5$ 个小朋友都能高兴。
- 第二个样例是一个不能使得所有 $C=7$ 个小朋友都高兴的例子。

## 样例 #1

### 输入

```
14 5 
2 1 2 4 2 6 
3 1 1 6 4 
6 1 2 9 6 8
8 1 1 9 12 
12 3 0 12 13 2 ```

### 输出

```
5```

## 样例 #2

### 输入

```
12 7 
1 1 1 1 5 
5 1 1 5 7 
5 0 3 5 7 9 
7 1 1 7 9 
9 1 1 9 11 
9 3 0 9 11 1
11 1 1 11 1```

### 输出

```
6```

# AI分析结果



# 算法分类
动态规划-状态压缩

# 题解思路与核心难点分析
**核心思路**：通过状压每个小朋友可见的5个围栏状态（0移走/1保留），预处理每个位置的各状态满意度，采用环形DP枚举初始状态保证首尾相连。

**关键步骤**：
1. **状态压缩**：用5位二进制表示连续5个围栏的保留状态（共32种可能）
2. **预处理**：对每个位置i的每个状态s，计算num[i][s]（使多少小朋友满意）
3. **环形处理**：枚举初始状态s，DP结束后检查最终状态是否与s匹配
4. **状态转移**：f[i][s] = max(前移/不移两种情况) + num[i][s]

**解决难点**：
- 环形处理通过枚举初始状态并强制结尾状态匹配
- 状态转移时使用位运算提取前4位：(s&15)<<1 实现滑动窗口
- 预处理中坐标转换：(x-E+n)%n 处理环形相对位置

# 题解评分（≥4星）

1. **Rayment（5星）**  
   亮点：代码简洁高效，首尾状态处理巧妙，时间复杂度分析清晰  
   核心代码：`f[j][s] = max(f[j-1][(s&15)<<1], f[j-1][(s&15)<<1|1]) + num[j][s]`

2. **青珹（4.5星）**  
   亮点：图文结合解释状态转移，详细注释预处理判断逻辑  
   核心代码：`if((fear&~j)||(like&j))` 直观体现题目条件

3. **chenzida（4星）**  
   亮点：通过函数封装预处理逻辑，代码结构清晰  
   核心代码：`if((st1&(st^15))||(st2&st))` 优化位运算

# 最优思路提炼
1. **环形DP技巧**：枚举初始状态，强制首尾状态一致
2. **滑动窗口状压**：用位运算实现5围栏窗口的滚动更新
3. **预处理优化**：在输入阶段直接计算每个位置的满意度矩阵
4. **坐标转换公式**：(x-E+n)%n 将绝对坐标转换为相对可见窗口的偏移量

# 类似题目推荐
1. P2473 [SCOI2008]奖励关（状压+期望DP）
2. P2704 [NOI2001]炮兵阵地（二维状压DP）
3. P2592 [ZJOI2008]生日聚会（环形区间状态维护）

# 可视化设计
**动画方案**：  
1. 用5个像素块表示当前窗口状态，绿色表示保留，红色表示移走
2. 滑动效果：每步右移时最左块消失，右侧新增块以当前决策颜色闪烁
3. 状态追踪：显示当前状态二进制码及对应十进制值

**复古游戏化要素**：
```javascript
// 音效触发伪代码
function playSound(effect) {
  if(effect === 'move')  // 状态转移时播放
    play8BitSound(/* 短促电子音 */);
  if(effect === 'solve') // 找到最优解时
    play8BitSound(/* 胜利旋律 */);
}

// 像素渲染示例
ctx.fillStyle = state[i] ? '#00FF00' : '#FF0000'; // 绿/红表示状态
ctx.fillRect(x*20, y*20, 18, 18); // 20x20像素块
```

# 核心代码实现
**状态转移核心逻辑**：
```cpp
for(int i=0;i<32;i++){ // 枚举初始状态
    memset(f[0],128,sizeof(f[0]));
    f[0][i]=0;
    for(int j=1;j<=n;j++)
        for(int s=0;s<32;s++)
            f[j][s] = max(f[j-1][(s&15)<<1], // 取前4位左移
                         f[j-1][(s&15)<<1|1]) + num[j][s];
    ans = max(ans,f[n][i]); // 必须与初始状态一致
}
```

**预处理关键判断**：
```cpp
// 计算每个状态是否使小朋友满意
if( (j & fear) ||       // 害怕的动物被移走（状态位0） 
    (~j & like) )       // 喜欢的动物未移走（状态位1）
    num[E][j]++;
```

# 总结与扩展
本题通过状压DP与环形处理技巧，将看似复杂的环形问题转化为线性DP问题。在类似环形问题中，可以借鉴**枚举初始状态**的方法破除环形限制。状压DP的关键在于：1）找到合适的状态表示 2）设计高效的状态转移方程 3）预处理辅助数据结构。

---
处理用时：65.36秒
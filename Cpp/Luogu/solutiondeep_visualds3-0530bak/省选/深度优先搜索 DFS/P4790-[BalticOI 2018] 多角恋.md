# 题目信息

# [BalticOI 2018] 多角恋

## 题目描述

**题目译自 [BalticOI 2018](https://boi2018.progolymp.se/tasks/) Day1「[Love Polygon](https://boi18-day1-open.kattis.com/problems/boi18.polygon)」**

给一张 $N$ 个点的有向图，每个点的出度为 $1$。每次可以花费 $1$ 的代价修改图上的一条边的终点，也就是改变从一个点出发所到达的点。求最少需要花费多少代价，才能使这张图形成若干个两两不相交的二元环，并且图上的所有点都在某一个环里。

## 说明/提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/1ojydan1.png)

唯一的最优解如上图所示，图的上半部分为原图，底色为粉色的三个点为需要修改的边的起点；图的下半部分表示修改后的情况。

#### 样例 2 解释

存在多组最优解。其中一种是分别改变一条以 ``a``、``b`` 和 ``d`` 为起点的边，使他们分别连接到 ``b``、``a`` 和 `c`。

#### 样例 3 解释

图中有 $3$ 个点，无论如何修改边的终点，总会有一个人不在环里。


| 子任务 | 分值 | 数据范围 | 附加限制 |
|:----------:|:-------:|:-------------:|:-------------:|
|$1$|$21$|$2\leqslant N\leqslant 20$|.|
|$2$|$25$|$2\leqslant N\leqslant 100\, 000$|每个点都有一条入边（可能有自环）|
|$3$|$29$|$2\leqslant N\leqslant 100\, 000$|不存在两个点或更多个点构成的环|
|$4$|$25$|$2\leqslant N\leqslant 100\, 000$|.|



## 样例 #1

### 输入

```
8
leonard emmy
ada emmy
isaac leonard
emmy pierre
pierre bernhard
bernhard emmy
sofia karl
karl sofia```

### 输出

```
3
```

## 样例 #2

### 输入

```
4
a c
b c
c d
d d```

### 输出

```
3
```

## 样例 #3

### 输入

```
3
rocky scarlet
scarlet patrick
patrick rocky```

### 输出

```
-1
```

# AI分析结果



---

## 算法分类  
**贪心 + 基环树处理**

---

## 题解思路与解决难点分析  

### 核心算法流程  
1. **预处理二元环**：直接标记已经形成相互指向的点对（无需修改）  
2. **拓扑排序处理链结构**：将入度为 0 的节点入队，每次处理其指向关系，若可形成新配对则标记，否则单独计入答案  
3. **处理剩余环**：每个环需要修改 ⌈环长/2⌉ 次（奇环需额外处理）  

### 解决难点  
- **环链分离**：通过拓扑排序将树结构与环分离，分别处理  
- **奇环处理**：奇环必须拆分为若干二元环和一个未配对点，需特殊计算  
- **自环判断**：自环无法形成有效配对，需排除在预处理之外  

### 关键变量  
- `use[]`：标记节点是否已配对  
- `deg[]`：动态维护节点的入度  
- `ans`：累加修改次数  

---

## 题解评分（≥4星）  

1. **cc123321（5星）**  
   - 思路清晰，完整覆盖预处理、拓扑排序、环处理三阶段  
   - 代码可读性强，用 `map` 处理输入，`queue` 实现拓扑排序  
   - 时间复杂度 O(n) 最优  

2. **Endt（4星）**  
   - 明确分步处理，逻辑简洁  
   - 用 `unordered_map` 优化哈希查询  
   - 未处理奇环细节导致部分边界条件需调试  

3. **ynxynx（4星）**  
   - 注释详细，代码对齐规范  
   - 相同核心逻辑但变量命名更直观  
   - 缺少对自环的特判说明  

---

## 最优思路提炼  

### 核心技巧  
1. **贪心消除链结构**：优先处理入度为 0 的节点，逐步向上配对  
2. **环长奇偶性处理**：奇环需额外 +1 次修改（`ans += k & 1`）  
3. **预处理加速**：直接标记现成二元环减少计算量  

### 代码片段  
```cpp
// 预处理现成二元环
for(int i=1; i<=n; i++)
    if(i == nex[nex[i]] && !use[i] && !use[nex[i]]) 
        use[i] = use[nex[i]] = 1;

// 拓扑排序处理链
while(!q.empty()) {
    int now = q.front(); q.pop();
    ans++;
    if(!use[nex[now]]) {
        use[nex[now]] = 1;
        if(--deg[nex[nex[now]]] == 0) 
            q.push(nex[nex[now]]);
    }
}

// 处理剩余环
for(int i=1; i<=n; i++) if(!use[i]) {
    int len = solve(i); // DFS求环长
    ans += len/2 + (len&1); 
}
```

---

## 类似题目推荐  
1. **P2661 信息传递**（基环树找最小环）  
2. **P2607 骑士**（基环树 DP）  
3. **P5022 旅行**（基环树贪心遍历）  

---

## 可视化设计  

### 动画方案  
1. **节点染色**  
   - 红色：未处理节点  
   - 绿色：已配对节点  
   - 蓝色：当前操作节点  

2. **拓扑排序过程**  
   - 动态显示队列中的节点  
   - 箭头高亮显示当前处理的边（如 `A→B` 修改为 `A→C`）  

3. **环处理演示**  
   - 环节点顺时针旋转，按奇偶交替染色  
   - 显示环长计算公式 `ans += len/2 + (len&1)`  

### 复古像素风格  
- **8-bit 音效**：  
  - 节点配对成功：短促「滴」声  
  - 环处理完成：8-bit 胜利旋律  
- **Canvas 绘制**：  
  - 节点用 16x16 像素方块表示  
  - 边用闪烁虚线箭头连接  

---

## 个人心得摘录  
> *「自环必须单独处理，否则会错误计入环长」*  
> *「拓扑排序时需动态维护入度，队列操作顺序影响最终结果」*  
> *「奇环的 +1 操作需在代码中显式判断，不可省略」*  

--- 

通过上述设计，学习者可逐步观察贪心策略如何消除链结构、分解环，并在复古交互中深入理解基环树特性。

---
处理用时：61.06秒
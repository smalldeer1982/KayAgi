# 题目信息

# 【模板】最小割树（Gomory-Hu Tree）

## 题目背景

模板题。做本题之前请确保你会 Dinic 或 ISAP。如果你乱搞过了我请你抽烟。

根据惯例，网络流题不允许卡 Dinic/ISAP，但可以卡 EK，本题数据严格遵循上述条约。

## 题目描述

给定一个 $n$ 个点 $m$ 条边的无向连通图，多次询问两点之间的最小割。

两点间的最小割是这样定义的：原图的每条边有一个割断它的代价，你需要用最小的代价使得这两个点不连通。

## 说明/提示

$1\le n\leq 500,\quad 0\le m\leq 1500,\quad 0\le Q\leq 10^5,\quad 0\leq w\leq 10^4,\quad u\neq v$

## 样例 #1

### 输入

```
4 5
1 2 2
2 3 2
4 2 3
4 3 1
1 3 1
3
1 4
2 4
2 3```

### 输出

```
3
4
4```

# AI分析结果



**唯一算法分类**  
图论-最小割树

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **分治策略**：通过递归将图划分为两个集合，每次选两点求最小割，并将该割值作为树边权值。
2. **最小割树性质**：树上任意两点路径上的最小边权等于原图中两点的最小割。
3. **高效查询**：通过预处理或在线倍增法快速查询路径最小值。

#### **算法流程**
1. **初始化**：将图中所有点视为初始集合。
2. **分治构建树**：
   - 选取当前集合中任意两点 `s` 和 `t`，计算其最小割值 `w`。
   - 在树中添加边 `(s, t, w)`。
   - 根据最小割结果将集合划分为两部分，递归处理子集合。
3. **查询处理**：
   - 使用 BFS/DFS 或树上倍增法求两点间路径上的最小边权。

#### **解决难点**
- **动态退流**：每次计算最小割后需恢复原图流量，避免影响后续计算。
- **集合划分**：利用 Dinic/ISAP 最后一次 BFS 的 `dis` 数组判断点归属集合。
- **高效查询**：通过预处理生成全点对最小割表（时间复杂度 O(n²)）或倍增优化查询。

---

### **题解评分 (≥4星)**

| 题解作者       | 评分 | 亮点与优势 |
|----------------|------|------------|
| _LHF_          | ⭐⭐⭐⭐ | 分治过程可视化配图，代码注释清晰，适合初学者 |
| Ebola          | ⭐⭐⭐⭐ | 提供完整定理证明，代码包含树上倍增查询逻辑 |
| EnofTaiPeople  | ⭐⭐⭐⭐ | 极简代码（仅 80 行），利用分治直接预处理答案 |

---

### **最优思路与技巧提炼**

#### **关键优化点**
1. **退流技巧**：通过反向边恢复原图流量（代码片段）：
   ```cpp
   for(int i=0; i<=cnt; i+=2)
       w[i] = (w[i] + w[i^1]) / 2, w[i^1] = 0;
   ```
2. **分治集合划分**：利用 Dinic 的 `dis` 数组快速分离集合。
3. **预处理答案**：在分治过程中直接更新所有跨集合点对的最小割值。

#### **思维突破点**
- **最小割树的递归性**：每个子问题的最小割仅需在原始图上计算，无需缩点。
- **路径最小边权等价性**：通过数学归纳法证明树上路径最小值与原图最小割等价。

---

### **同类型题与算法套路**

#### **通用解法**
- **多次最小割查询** → 构建 Gomory-Hu 树。
- **无向图边权最值路径** → 最小生成树或最大生成树。

#### **推荐题目**
1. [P4123 [CQOI2016] 不同的最小割](https://www.luogu.com.cn/problem/P4123)  
2. [P3329 [ZJOI2011] 最小割](https://www.luogu.com.cn/problem/P3329)  
3. [CF343E Pumping Stations](https://www.luogu.com.cn/problem/CF343E)

---

### **个人心得摘录**
- **调试教训**：初始化数组范围错误（如 `cur[N]` 未覆盖全部点）导致 WA。
- **顿悟时刻**：理解「最小割树边权与路径最小值等价」后，代码复杂度骤降。

---

### **可视化与算法演示**

#### **动画设计**
1. **分治过程**：  
   - 初始图显示为灰色节点网格，选中 `s` 和 `t` 时高亮为红/蓝。  
   - 计算最小割后，用绿色波浪线标记割边，划分集合为左右两部分。  
   - 递归时左右区域收缩为子树，树边显示为黄色连线。

2. **树结构构建**：  
   - 动态添加树边时，边权以浮动文字显示（如 `+3`）。  
   - 路径查询时，高亮路径并逐边比较最小值。

#### **复古像素风格**
- **颜色方案**：  
  - 节点：8-bit 风格（红/蓝代表 `s/t`，绿为普通节点）。  
  - 树边：黄色（当前边）、灰色（非活动边）。  
- **音效设计**：  
  - 切割完成：短促「哔」声。  
  - 查询结果：胜利音效（8-bit 上升音阶）。

#### **交互功能**
- **控制面板**：支持暂停/继续、单步执行分治过程。  
- **AI 自动演示**：自动选择 `s/t` 并展示割的生成。

---

### **核心代码实现**

#### **分治建树代码**
```cpp
void build(int l, int r) {
    if (l >= r) return;
    int s = node[l], t = node[l+1];
    int cut = dinic(s, t); // 计算最小割
    add_tree_edge(s, t, cut); // 添加树边

    // 划分集合
    vector<int> S, T;
    for (int i = l; i <= r; i++) 
        (dis[node[i]] != -1) ? S.push_back(node[i]) : T.push_back(node[i]);
    
    // 递归处理子集
    copy(S.begin(), S.end(), node + l);
    copy(T.begin(), T.end(), node + l + S.size());
    build(l, l + S.size() - 1);
    build(l + S.size(), r);
}
```

#### **预处理答案代码**
```cpp
void update_ans(int s, int t, int cut) {
    for (int u : S) for (int v : T) 
        ans[u][v] = ans[v][u] = min({ans[u][s], ans[t][v], cut});
}
```

---

### **总结**
最小割树通过分治将复杂的最小割问题转化为树结构路径查询，其核心在于分治策略与树性质的应用。可视化设计可通过动态分治步骤和复古交互增强理解，适用于教学与竞赛算法优化。

---
处理用时：78.46秒
# 题目信息

# [Cnoi2019] 雪松果树

## 题目背景

幻想乡，冬。

一年一度，生长在高山上的雪松果树又结果了。

Cirno 不知从哪弄到了 $1,2,3\cdots9$ 颗雪松果,然后很开心的吃掉了其中 $6$ 颗，最后还剩最后 $1$ 颗。

Cirn o因为以后吃不到雪松果而感到忧愁,于是决定种在美丽的雾之湖畔。

第一天,发芽。

第二天,雪松果树长成了一颗参天大树, 上面长满了雪松果。

Cirno 在雪松果成熟之前早有一些问题想知道，但现在她忙于收集雪松果，就把问题丢给了你。

## 题目描述

雪松果树是一个以 $1$ 为根有着 $N$ 个节点的树。

除此之外, Cirno还有 $Q$ 个询问，每个询问是一个二元组 $(u,k)$ ,表示询问 $u$ 节点的 $k$-cousin 有多少个。

我们定义:

> 节点 $u$ 的 $1$-father 为 路径 $(1, u)$ （不含 u）上距 u 最近的节点
>
> 节点 $u$ 的 $k$-father 为 节点 「$u$ 的 $(k-1)$-father」 的 1-father
>
> 节点 $u$ 的 $k$-son 为所有 $k$-father 为 $u$ 的节点
>
> 节点 $u$ 的 $k$-cousin 为 节点「 $u$ 的 $k$-father」的 $k$-son (不包含 $u$ 本身)

## 说明/提示

数据范围：

对于0%-10%的数据 $N,Q \le 100$

对于10%-20%的数据 $N \le 100,Q \le 10^6$

对于 20%-30% 的数据 $N \le 10^5,Q \le100$

对于 30%-35% 的数据 $N \le 10^4,Q \le 5000$

对于 35%-50% 的数据 $N \le 10^5,Q \le 10^5$

对于 50%-70% 的数据 保证树随机

对于 70%-100% 的数据 $N,Q \le 10^6$

另外存在一组记 $20$ 分的 hack 数据。

## 样例 #1

### 输入

```
5 2
1 2 1 4
2 1
3 2```

### 输出

```
1 1```

# AI分析结果



## 唯一算法分类
树上离线查询（栈记录祖先 + 全局桶统计深度）

---

## 综合分析与结论

### 核心思路
1. **离线处理k级祖先**：通过DFS栈记录当前路径的祖先，离线时将每个询问(u,k)挂载到其k级祖先节点。
2. **全局桶统计深度**：利用DFS特性，维护一个全局深度桶`cnt[d]`，在访问子树前后差值即为子树中深度为d的节点数。
3. **时间复杂度O(n+q)**：通过栈和桶的巧妙结合，将k级祖先和深度统计均优化至线性时间。

### 解决难点
- **k级祖先**：传统倍增或长链剖分需要额外空间，栈记录路径的离线方式直接利用DFS特性，无需预处理。
- **子树深度统计**：通过进入和离开子树时桶的差值，避免重复遍历，实现O(1)查询。

### 可视化设计
- **Canvas动画**：以树形结构展示DFS遍历过程，栈用动态数组表示，当前访问节点高亮为红色，祖先路径用黄色标记。
- **桶变化动态**：右侧显示深度桶数组，每次节点进入/离开时对应深度数值闪烁更新。
- **像素音效**：节点入栈播放"哔"声，查询命中时播放"叮"声，增强操作反馈。

---

## 题解清单（≥4星）

1. **Autre的栈+全局桶法（★★★★★）**
   - 亮点：O(n+q)时间，O(n)空间，代码简洁高效。
   - 关键代码：
     ```cpp
     void ganc(int u) {
         stk[++top] = u;
         for (auto [i,k] : q[u]) // 处理当前节点的所有询问
             if (top > k) h[stk[top-k]].emplace_back(i, dep[u]+k);
         for (int v : g[u]) ganc(v); // 递归子节点
         top--;
     }
     ```
   
2. **皎月半洒花的长链剖分优化（★★★★☆）**
   - 亮点：长链剖分求k级祖先，前缀和统计子树深度。
   - 优化：链表替代vector减少内存占用，实现线性空间。

3. **feecle6418的线段树合并（★★★★☆）**
   - 亮点：线段树合并维护子树深度信息，手动内存管理优化空间。
   - 关键优化：按子树大小排序合并顺序，及时释放内存。

---

## 最优思路提炼
**栈记录+差值统计法**  
1. **离线挂载询问**：DFS时用栈记录路径，遇到询问(u,k)时，将查询挂载到栈中第top-k位置的祖先。
2. **两次DFS处理**：
   - 第一次DFS收集所有k级祖先对应的查询。
   - 第二次DFS用全局桶统计各深度出现次数，进入子树时累加，离开时差值即为答案。

---

## 相似题目推荐
1. **P1600 天天爱跑步** - 利用DFS差值统计路径覆盖。
2. **P4211 LCA** - 离线处理树链查询。
3. **CF208E Blood Cousins** - 几乎相同的k-cousin问题，可套用相同解法。

---

## 核心代码实现
```cpp
vector<pair<int,int>> q[N], h[N]; // q:原始查询, h:挂载到祖先的查询
int ans[N], cnt[N], stk[N], top;

void dfs1(int u) {
    stk[++top] = u;
    for (auto [i,k] : q[u]) // 处理当前节点的询问
        if (top > k) h[stk[top-k]].emplace_back(i, dep[u]+k);
    for (int v : g[u]) dfs1(v);
    top--;
}

void dfs2(int u) {
    cnt[dep[u]]++; // 进入节点时计数
    for (auto [i,k] : h[u]) ans[i] -= cnt[k]; // 记录进入前的值
    for (int v : g[u]) dfs2(v);
    for (auto [i,k] : h[u]) ans[i] += cnt[k]; // 离开时差值即为答案
}
```

---

## 可视化方案（伪代码）
```javascript
class Visualization {
    constructor(tree) {
        this.canvas = document.getElementById("canvas");
        this.stack = []; // 当前DFS栈
        this.bucket = new Array(maxDepth).fill(0); // 深度桶
    }

    highlightNode(node, color) {
        // 在Canvas上高亮指定节点为color
    }

    dfsStep(u) {
        this.stack.push(u);
        this.highlightNode(u, "red");
        playSound("beep"); // 入栈音效

        // 处理查询...
        setTimeout(() => {
            for (let child of tree[u].children) {
                this.dfsStep(child);
            }
            this.stack.pop();
            this.highlightNode(u, "gray"); // 恢复颜色
        }, 500);
    }
}
```

---
处理用时：58.63秒
# 题目信息

# [ONTAK2010] Peaks 加强版

## 题目背景

原题链接：[P4197 Peaks](https://www.luogu.com.cn/problem/P4197)

## 题目描述

给定一张 $n$ 个点、$m$ 条边的无向图，第 $i$ 个点的权值为 $a_i$，边有边权。

有 $q$ 组询问，每组询问给定三个整数 $u, x, k$，求从 $u$ 开始只经过权值 $\leq x$ 的边所能到达的权值第 $k$ 大的点的权值，如果不存在输出 $-1$。

**本题强制在线。即：每次查询输入的是 $u', x', k'$，则 $u = (u' \operatorname{xor} \text{lastans}) \bmod n + 1$，$k$ 的解密方式与之相同，$x = x' \operatorname{xor} \text{lastans}$**。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 \leq m, q \leq 5 \times 10^5$，$1 \leq s, t \leq n$，$1 \leq a_i, w \leq 10^9$，$0 \leq u', x', k' < 2^{31}$。

## 样例 #1

### 输入

```
10 11 3
1 2 3 4 5 6 7 8 9 10
1 4 4
2 5 3
9 8 2
7 8 10
7 1 4
6 7 1
6 4 8
2 1 5
10 8 10
3 4 7
3 4 6
0 5 5
1 6 8
7 8 1```

### 输出

```
1
-1
8```

# AI分析结果



**唯一算法分类**  
Kruskal 重构树 + 主席树

---

### **题解思路与核心难点分析**

#### **核心算法流程**
1. **Kruskal 重构树构建**  
   - 边按权值升序排序，合并生成新节点形成二叉树结构  
   - 新节点权值为合并边的权值，叶子节点为原始点  
   - 性质：任意节点子树内的点可通过 ≤ 该节点权值的边连通  

2. **倍增查找祖先**  
   - 预处理每个节点的 2^i 级祖先  
   - 对于查询点 u，找到最浅的权值 ≤x 的祖先节点  
   - 该祖先的子树即为可达点的集合  

3. **主席树维护区间第k大**  
   - 对重构树进行 DFS 序遍历，离散化原始点权  
   - 按 DFS 序建立可持久化线段树，记录每个位置的权值  
   - 查询时通过子树的 DFS 序区间获取第k大值  

#### **解决难点对比**
| 题解作者       | 关键实现差异                          | 核心优化点                     |
|----------------|---------------------------------------|--------------------------------|
| LawrenceSivan  | 详细讲解重构树性质，代码包含调试注释  | 树剖处理无解情况，离散化预处理 |
| Gao_yc         | 代码最简洁，重构树与主席树耦合紧密    | 使用 vector 存储子树节点       |
| ExplodingKonjac| 采用线段树合并替代主席树，但需处理在线| 实现可持久化并查集结构         |
| ZCETHAN        | 强调重构树性质与 LCA 的关联           | 直接维护原值而非离散化         |

---

### **题解评分与亮点（≥4星）**

1. **LawrenceSivan（★★★★☆）**  
   - 亮点：完整推导重构树性质，配图说明数据结构  
   - 代码：包含详细注释，适合教学场景  

2. **Gao_yc（★★★★★）**  
   - 亮点：代码最简洁高效，耦合重构树与主席树  
   - 优化：使用 `lower_bound` 快速离散化  

3. **peterwuyihong（★★★★☆）**  
   - 亮点：强调无解条件判断逻辑  
   - 代码：使用 `dfn` 序区间处理子树查询  

---

### **最优技巧提炼**

1. **重构树倍增跳转**  
   ```cpp
   for(int i=20;~i;i--)
       if(fa[u][i] && val[fa[u][i]]<=x) 
           u = fa[u][i];
   ```  
   通过二进制分解快速定位最浅合法祖先

2. **主席树区间映射**  
   ```cpp
   int query(int l_root, int r_root, int k) {
       if(rs_sum >= k) return query(rs);
       else return query(ls) - rs_sum;
   }  
   ```  
   通过右子树大小判断第k大方向

3. **离线预处理优化**  
   ```cpp
   sort(edge); // 边权排序
   dfs(root);  // DFS序预处理
   build_pst();// 主席树构建
   ```  
   将复杂操作分解为独立预处理阶段

---

### **同类型题推荐**

1. **[P4197 Peaks](https://www.luogu.com.cn/problem/P4197)**  
   （同一题的非强制在线版本）

2. **[P4768 [NOI2018] 归程](https://www.luogu.com.cn/problem/P4768)**  
   （重构树 + 最短路综合应用）

3. **[P2617 Dynamic Rankings](https://www.luogu.com.cn/problem/P2617)**  
   （主席树动态区间第k大）

---

### **可视化设计要点**

#### **动画流程**
1. **Kruskal 重构树构建**  
   - 初始显示散点图表示节点  
   - 逐步合并边生成新节点（黄色高亮当前合并边）  
   - 连线动画展示父子关系建立  

2. **倍增跳转演示**  
   - 红色标记查询起点 u  
   - 绿色光晕显示每次跳转的祖先节点  
   - 最终停留节点显示为蓝色光晕  

3. **主席树查询**  
   - 展示 DFS 序区间（半透明色块覆盖）  
   - 线段树节点展开时高亮比较过程  
   - 最终结果以闪烁特效标出  

#### **复古像素风格**  
- **调色板**：16色，主色调为青绿（树结构）、橙黄（高亮操作）  
- **音效**：  
  - 合并节点时播放 8-bit "升级" 音效  
  - 查询成功时播放马里奥金币音效  

---

### **核心代码实现**

#### **Kruskal 重构树构建**
```cpp
int tot = n;
sort(e+1, e+m+1, cmp);
for(int i=1; i<=n*2; i++) fa[i] = i;

for(int i=1; i<=m; i++) {
    int fu = find(e[i].u), fv = find(e[i].v);
    if(fu != fv) {
        val[++tot] = e[i].w;
        fa[fu] = fa[fv] = tot;
        add(tot, fu); add(tot, fv);
    }
}
```

#### **主席树查询**
```cpp
int query_kth(int u, int x, int k) {
    // 倍增找祖先
    for(int i=20; i>=0; i--)
        if(fa[u][i] && val[fa[u][i]] <= x)
            u = fa[u][i];
    
    // 主席树区间查询
    int l = dfn[u], r = dfn[u] + siz[u] - 1;
    if(siz[u] < k) return -1;
    return T.query(root[l-1], root[r], 1, cnt, k);
}
```

---

### **总结**
本题解通过 Kruskal 重构树处理边权限制，结合主席树解决区间第k大查询，算法时间复杂度为 O(m log m + q log n)。可视化设计强调重构树的动态生成与主席树的区间分割过程，辅以复古像素风格增强理解趣味性。

---
处理用时：84.18秒
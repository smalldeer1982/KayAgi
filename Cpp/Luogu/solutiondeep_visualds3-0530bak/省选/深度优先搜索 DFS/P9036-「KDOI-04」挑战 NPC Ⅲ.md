# 题目信息

# 「KDOI-04」挑战 NPC Ⅲ

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/zn5t5x28.png)

## 题目描述

小 S 有一个伟大的梦想：证明 $\text{P}=\text{NP}$。

有一天，他得知一般图最大独立集是 NPC 问题后，决定解决他。

当然小 S 太菜了，解决不了，于是求助于你：

> 给出一个含有 $n$ 个顶点，$m$ 条边的无向图 $G$，求 $G$ 中大小恰好为 $n-k$ 的独立集的数量。由于答案可能很大，请将其对 $998~244~353$ 取模。

小 S 不喜欢多测，因为他在 NOIp 中因为多测挂分，所以本题包含多组测试数据。

## 说明/提示

**【样例解释】**

对于第 $1,2$ 组测试数据，图是完全图，容易发现，完全图的最大独立集为 $1$，并且每一个顶点都单独构成一个独立集。因此第 $1$ 组测试数据的答案为 $0$，第 $2$ 组测试数据的答案为 $4$。

对于第 $3$ 组测试数据，该组数据中给出的无向图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/abt8ho3b.png)

其中，所有大小为 $3$ 的独立集为：

+ $\{2,4,8\}$；
+ $\{2,3,7\}$；
+ $\{3,4,6\}$；
+ $\{2,4,6\}$；
+ $\{1,4,6\}$；
+ $\{2,3,6\}$；
+ $\{1,4,5\}$；
+ $\{2,3,4\}$。

**【数据范围】**

**本题采用捆绑测试。**

![数据范围](https://cdn.luogu.com.cn/upload/image_hosting/p3jwdqp3.png)

对于 $100\%$ 的数据，保证 $1\leq n\leq10^5$，$0\le m\le 10^5$，$0\leq k\leq \min(n-1,18)$，$1\leq T\leq 10^{4}$，$\sum n,\sum m\leq10^6$。

并且对于每个测试点保证：

设 $K=\max k$，即该测试点中所有 $k$ 的最大值，

+ 若 $K\ge 17$，则 $T=1$；
+ 若 $K\ge 15$，则 $T\le 3$；
+ 若 $K\ge 10$，则 $T\le 5$；
+ 若 $K\ge 5$，则 $T\le 300$。


## 样例 #1

### 输入

```
3
4 6 1
1 2
1 3
1 4
2 3
2 4
3 4
4 6 3
1 2
1 3
1 4
2 3
2 4
3 4
8 13 5
1 2
7 8
1 3 
2 5
3 8
6 8
4 7
5 6
5 7
5 8
6 7
1 8
3 5```

### 输出

```
0
4
8```

# AI分析结果



---

## **算法分类**  
**剪枝暴搜 + 组合数学**

---

## **题解思路与解决难点**  
### **核心思路**  
1. **问题转化**：将求大小为 `n-k` 的独立集转化为求大小为 `k` 的点覆盖集。  
2. **必选点预处理**：度数超过 `k` 的点必须被选入点覆盖集，否则无法覆盖其所有边。  
3. **边数限制**：预处理后剩余边数不超过 `k²`，否则无解。  
4. **爆搜剪枝**：枚举未覆盖的边，选择覆盖其端点，避免重复计数。  

### **解决难点**  
- **重复边处理**：使用 `set` 或哈希表去重。  
- **状态标记**：用 `vis[]` 或 `ban[]` 记录点的状态（选/不选/未定），避免重复分支。  
- **组合数计算**：剩余可选点通过组合数公式 `C(n-c, k-c)` 快速计算。  

---

## **题解评分 (≥4星)**  
1. **Alex_Wei（5星）**  
   - **亮点**：预处理必选点逻辑清晰，状态标记 `ban[]` 避免重复计数，代码结构简洁高效。  
   - **代码片段**：通过 `dfs` 动态维护 `ban[]` 状态，组合数优化。  

2. **_Diu_（4星）**  
   - **亮点**：使用 `set` 维护度数最大点，动态删除/恢复点，组合数预处理优化。  
   - **代码片段**：`erase` 和 `insert` 操作高效维护度数变化。  

3. **Nuyoah_awa（4星）**  
   - **亮点**：状态标记 `flag[]` 管理严格，组合数预处理避免冗余计算。  
   - **个人心得**：强调边数限制 `k²` 的剪枝必要性，避免超时。  

---

## **最优思路与技巧**  
1. **必选点预处理**：  
   - 度数 `>k` 的点必选，直接剪枝 `k`。  
2. **边数剪枝**：  
   - 剩余边数 `>k²` 时直接返回 `0`，避免无效搜索。  
3. **状态标记法**：  
   - 标记点状态为「必选」「不可选」「未定」，避免重复分支。  
4. **组合数优化**：  
   - 预处理组合数 `C(n, k)`，快速计算剩余点的选法。  

---

## **同类型题与算法套路**  
- **通用套路**：  
  - **点覆盖/独立集问题**：转化为动态剪枝搜索，预处理必选点。  
  - **小范围暴搜**：利用 `k` 的限制，结合组合数学优化。  
- **类似题目**：  
  1. [POJ 1419](http://poj.org/problem?id=1419)（最大独立集问题）。  
  2. [洛谷 P2764](https://www.luogu.com.cn/problem/P2764)（最小路径覆盖）。  

---

## **推荐题目**  
1. **P1971 无线通讯网**（剪枝暴搜 + 状态压缩）。  
2. **P2831 愤怒的小鸟**（暴搜 + 状态标记优化）。  
3. **P2322 覆盖问题**（点覆盖问题 + 组合数学）。  

---

## **个人心得摘录**  
- **Alex_Wei**：  
  > “忽略重边是关键，否则度数计算会出错。”  
- **Nuyoah_awa**：  
  > “枚举边时维护可选点数量，避免遍历所有点，否则 TLE。”  

---

## **可视化与算法演示**  
### **核心流程动画设计**  
1. **预处理阶段**：  
   - 高亮度数 `>k` 的点（红色），自动选中并删除其边。  
   - 显示剩余边数（绿色）和剩余 `k` 值。  
2. **暴搜阶段**：  
   - 当前处理边（黄色闪烁），选择端点（绿色/红色标记）。  
   - 分支路径动态显示（左侧分支树状图）。  
3. **组合数计算**：  
   - 剩余点高亮（蓝色），显示组合数公式 `C(n-c, k-c)`。  

### **复古像素风格实现**  
- **Canvas 绘制**：  
  - 点：8×8 像素方块，颜色区分状态（红：必选，绿：可选，灰：不可选）。  
  - 边：像素线连接两点，处理时闪烁黄色。  
- **音效设计**：  
  - **选中点**：8-bit “哔”声。  
  - **分支结束**：成功（上扬音效），失败（低沉音效）。  
- **自动演示模式**：  
  - 按 `DFS` 顺序自动选择边，速度可调（1x~5x）。  

```javascript  
// 示例代码：Canvas 绘制点与边（伪代码）  
function drawGraph() {  
  ctx.fillStyle = "#000";  
  points.forEach(p => {  
    ctx.fillRect(p.x*10, p.y*10, 8, 8);  // 像素点坐标  
  });  
  edges.forEach(e => {  
    ctx.beginPath();  
    ctx.moveTo(e.u.x*10+4, e.u.y*10+4);  
    ctx.lineTo(e.v.x*10+4, e.v.y*10+4);  
    ctx.stroke();  
  });  
}  
```  

---

## **代码实现片段**  
### **Alex_Wei 核心逻辑**  
```cpp  
void dfs(int rest, int cur) {  
  if (cur > k) return;  
  int e = -1;  
  for (auto it : buc)  // 找未覆盖的边  
    if (ban[u[it]] != 1 && ban[v[it]] != 1) {  
      e = it; break;  
    }  
  if (e == -1) {  
    ans = (ans + bin(n - cnt, k - cur)) % mod;  
    return;  
  }  
  // 处理边的两种选择  
  int &x = ban[u[e]], &y = ban[v[e]];  
  if (x == 0 && y == 0) {  
    x = 1, y = 1; dfs(rest - 2, cur + 2);  
    x = 1, y = 2; dfs(rest - 2, cur + 1);  
    x = 2, y = 1; dfs(rest - 2, cur + 1);  
    x = y = 0;  
  }  
}  
```  

### **Diu 核心逻辑**  
```cpp  
void dfs(int x, int num) {  
  if (s.empty()) {  
    ans = (ans + C[num][x]) % p;  
    return;  
  }  
  int t = s.begin()->second;  
  erase(t), dfs(x-1, num-1), insert(t);  // 选点  
  for (int y : g[t]) erase(y);  // 不选点，必选邻点  
  dfs(x - tp, num - tp - 1);  
}  
```

---
处理用时：95.72秒
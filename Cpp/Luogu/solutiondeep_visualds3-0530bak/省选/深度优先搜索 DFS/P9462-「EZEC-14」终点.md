# 题目信息

# 「EZEC-14」终点

## 题目背景

~~出题人怎么还没鸟加这首歌啊。~~

于 2023.8.5 拿下。

## 题目描述

**这是一道交互题。**

dXqwq 有一棵 $n$ 个点的无根树，结点从 $1$ 到 $n$ 编号。您需要通过若干次询问得到这棵树的结构。

您可以选择两个整数 $1\leq u,v\leq n$，并输出 `? u v` 进行询问。

对于每次询问，如果 $u,v$ 的路径中点在一个结点上，交互库返回该点的编号，否则返回 ``0``。

请通过不超过 $147154$ 次询问，得到这棵树的结构。

保证树的形态是提前确定的，即**交互库不自适应。**

### 交互方式

输入测试点所在子任务编号 $id$ 和树的大小 $n$ 以开始交互。

交互过程中，您可以进行题目描述中的询问。

对于每次询问，如果你提供的 $u,v$ 不合法或者超出询问次数上限，交互库会返回 ``-1``，否则交互库将会返回一个非负整数，含义见「题目描述」。

当你读取到 ``-1`` 后应立刻退出程序，在此之后交互库的行为未定义。

在您确定答案后，请先输出 `!`，然后接下来 $n-1$ 行依次输出两个整数 ``u[i] v[i]`` 代表树的每条边，最后退出程序。你可以以任意顺序输出这些边。

在您输出一行后，请清空缓冲区：

- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。
- 在 Pascal 中，使用 `flush(output)`。
- 在 Python 中，使用 `stdout.flush()`。
- 其它语言请自行查阅文档。

## 说明/提示

**本题采用捆绑测试。**

-  Subtask 1（10 pts）：$n \leq 10$，树满足性质 A。
-  Subtask 2（10 pts）：保证存在一个点度数为 $n-1$。
-  Subtask 3（10 pts）：保证所有点度数 $\leq 2$。
-  Subtask 4（10 pts）：$n \leq 500$，树满足性质 A。
-  Subtask 5（20 pts）：$n \leq 500$。 
-  Subtask 6（20 pts）：树满足性质 A。
-  Subtask 7（20 pts）：无特殊限制。

性质 A：对于 $i=2,3,\cdots,n$ 存在整数 $1\leq j<i$ 满足有一条边连接 $i,j$。

对于 $100\%$ 的数据，$2 \leq n \leq 10^4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/3u2zy1q5.png)

## 样例 #1

### 输入

```
1 5

1

2

3

4

0```

### 输出

```
 
? 1 1

? 1 3

? 2 4

? 3 5

? 4 5

!
1 2
2 3
3 4
4 5```

## 样例 #2

### 输入

```
5 5

1

0

0

2

2```

### 输出

```
 
? 1 1

? 1 3

? 2 4

? 3 5

? 4 5

!
1 3
2 3
2 4
2 5```

# AI分析结果



### 算法分类
**树结构推断 | 分治策略 | 交互式算法**

---

### 题解思路与核心难点分析

#### 核心算法流程
1. **确定关键邻接点**：通过查询所有点与根节点（如1）的中点，找到深度最大的点，确定其与根直接相邻。
2. **分层处理父节点**：对每个节点，维护临时父节点，通过多次中点查询逐步逼近真实父节点。
3. **队列优化顺序**：使用队列（BFS）处理待确定节点，确保父节点已知后处理其子树节点。

#### 解决难点对比
| 题解 | 关键创新点 | 解决的主要难点 | 操作次数优化 |
|------|------------|----------------|--------------|
| dead_X | BFS处理挂载的询问 | 避免父节点未知时的无效查询 | $O(n \log n)$ |
| elbissoPtImaerD | 奇偶性预处理与拓扑排序 | 处理非父子顺序的树结构 | $O(n \log n)$ |
| by_chance | 分三步确定深度与父节点 | 显式维护深度信息 | $O(n \log n)$ |

---

### 题解评分（≥4星）

1. **dead_X（⭐⭐⭐⭐⭐）**  
   - **亮点**：BFS队列优化挂载查询，代码简洁（仅需维护`d[x]`和`fa[]`数组）。  
   - **关键代码段**：
     ```cpp
     while (!q.empty()) {
         int x = q.front(); q.pop();
         for (int y : d[x]) {
             if (查询逻辑) {
                 fa[y] = x; q.push(y);
             } else {
                 d[z].push_back(y); // 挂载到新节点
             }
         }
     }
     ```

2. **elbissoPtImaerD（⭐⭐⭐⭐）**  
   - **亮点**：通过`lowbit`优化确定邻接点，拓扑排序处理依赖关系。  
   - **关键注释**：  
     > “能取中点次数最多的点一定与根相邻”——通过二进制位特性快速定位关键点。

3. **by_chance（⭐⭐⭐）**  
   - **亮点**：分阶段处理深度与父节点，逻辑清晰。  
   - **缺陷**：需多次全量查询深度，操作次数较高。

---

### 最优思路提炼
1. **中点分治**：通过中点查询将路径长度减半，逐步逼近父节点（如`query(fa_y, x)`确定路径中点）。
2. **动态挂载查询**：将未确定的节点挂载到临时父节点，待父节点确定后重新处理（`d[z].push_back(y)`）。
3. **奇偶性优化**：预处理所有点到根的路径奇偶性，减少无效查询（如`a[i]`标记奇偶性）。

---

### 同类型题推荐
1. **P3384 【模板】轻重链剖分**（树结构处理）  
2. **P3379 【模板】最近公共祖先**（LCA与路径中点）  
3. **P1041 交互树**（交互式推断树结构）

---

### 可视化设计（复古像素风格）

#### 动画流程
```html
<canvas id="tree-viz" width="800" height="600"></canvas>
<script>
// 初始化：根节点1居中显示，其他节点随机分布
// 关键操作高亮：
// - 查询(u, v)时，路径显示为黄色，中点为红色闪烁方块
// - 确定父节点时，绘制绿色连线并播放“确认音效”
// 队列状态：右侧面板显示当前处理队列（BFS节点列表）
</script>
```

#### 音效与交互
- **音效触发**：  
  - 查询操作：8-bit“哔”声（`AudioContext`生成方波）。  
  - 确定父节点：上扬音效（类似FC游戏得分音）。  
- **自动演示模式**：按层次逐步展开节点，模拟BFS过程。

---

### 核心代码实现（dead_X版）
```cpp
// 确定邻接点id
for (int i=2; i<=n; ++i) {
    a[i] = query(1, i);
    if (a[i]) v[a[i]].push_back(i), a[i] = 1;
}
// BFS处理挂载查询
queue<int> q;
fa[1] = id; q.push(1); q.push(id);
while (!q.empty()) {
    int x = q.front(); q.pop();
    for (int y : d[x]) {
        if (a[x] ^ a[y]) { // 奇偶性不同
            int z = query(fa[x], y);
            if (z == x) fa[y] = x, q.push(y);
            else d[z].push_back(y);
        } else {
            d[query(x, y)].push_back(y);
        }
    }
}
```

---

### 总结
通过中点查询的分治策略和队列优化，结合二进制特性快速定位关键节点，最终在$O(n \log n)$次操作内高效推断树结构。代码实现中动态挂载未处理的查询是核心优化点。

---
处理用时：61.81秒
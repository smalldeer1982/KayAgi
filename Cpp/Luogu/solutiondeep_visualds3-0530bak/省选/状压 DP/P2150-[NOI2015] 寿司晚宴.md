# 题目信息

# [NOI2015] 寿司晚宴

## 题目描述

为了庆祝 NOI 的成功开幕，主办方为大家准备了一场寿司晚宴。小 G 和小 W 作为参加 NOI 的选手，也被邀请参加了寿司晚宴。

在晚宴上，主办方为大家提供了 $n−1$ 种不同的寿司，编号 $1,2,3,\ldots,n-1$，其中第 $i$ 种寿司的美味度为 $i+1$。（即寿司的美味度为从 $2$ 到 $n$）

现在小 G 和小 W 希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小 G 品尝的寿司种类中存在一种美味度为 $x$ 的寿司，小 W 品尝的寿司中存在一种美味度为 $y$ 的寿司，而 $x$ 与 $y$ 不互质。

现在小 G 和小 W 希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数 $p$ 取模）。注意一个人可以不吃任何寿司。


## 说明/提示

【数据范围】


 ![](https://cdn.luogu.com.cn/upload/pic/1506.png) 


**勘误：$0 < p \le 10^9 $**

## 样例 #1

### 输入

```
3 10000```

### 输出

```
9```

## 样例 #2

### 输入

```
4 10000```

### 输出

```
21```

## 样例 #3

### 输入

```
100 100000000```

### 输出

```
3107203```

# AI分析结果



---

## 算法分类
**状压DP**

---

## 综合分析与结论
### 核心思路与难点
1. **质因数分组**  
   - **小质数（≤19）**：共8个，使用状压处理每个数的小质因数集合。
   - **大质数（>19）**：每个数至多含有一个大质因数，按大质因数分组处理。

2. **状态转移设计**  
   - 定义`dp[s1][s2]`表示两组的小质数集合分别为`s1`和`s2`的方案数。
   - **大质数组处理**：每组大质数只能全分给甲或乙，使用辅助数组`f1`和`f2`分别表示分给甲或乙的情况。
   - **合并与容斥**：合并时需减去重复计算的两组均不选的情况（`dp = f1 + f2 - dp`）。

3. **动态转移优化**  
   - 倒序遍历状态避免覆盖，滚动数组优化空间。
   - 预处理每个数的小质数集合和大质因数，按大质因数排序后分组处理。

### 可视化设计思路
1. **动画流程**  
   - **步骤1**：展示质因数分解过程，用不同颜色标记小质数（黄色）和大质数（红色）。  
   - **步骤2**：以像素网格表示状态转移，每个格子对应一个`(s1, s2)`组合，高亮当前处理的数的小质数集合。  
   - **步骤3**：大质数组分组时，用闪烁效果区分`f1`（蓝色）和`f2`（绿色）的转移，合并时显示减法逻辑（红色闪烁）。  

2. **复古像素风格**  
   - **调色板**：8位色（深蓝、黄、绿、红、灰），质数分解用像素点阵显示。  
   - **音效**：状态转移时播放“哔”声，合并时播放“叮咚”音效，错误操作触发低音警报。  

3. **交互功能**  
   - **步进控制**：按空格键单步执行，支持调节动画速度（1x/2x/5x）。  
   - **自动演示**：AI模式自动播放，展示分组与合并的全流程。

---

## 题解清单（≥4星）
1. **Orion545（5星）**  
   - **亮点**：清晰分步推导，代码注释详细，滚动数组优化。  
   - **核心代码**：分组处理大质数，合并时容斥逻辑简洁。

2. **翼德天尊（5星）**  
   - **亮点**：深入分析状态设计，对比30分与满分思路差异，代码可读性极佳。  
   - **个人心得**：“大质数分组是本题的灵魂，必须排序后分段处理”。

3. **ethan_zhou（4星）**  
   - **亮点**：提出$O(n \times 3^8)$优化，枚举合法状态减少无效计算。  
   - **代码技巧**：三进制状态压缩，快速枚举互斥集合。

---

## 最优思路提炼
### 关键技巧
1. **质因数分类处理**  
   - 将质数分为小质数（状压）和大质数（分组），分别处理两类质数的约束条件。

2. **滚动数组与倒序更新**  
   ```cpp
   for (int j=255; j>=0; j--)
     for (int k=255; k>=0; k--)
       if (!(j&k)) // 状态转移
   ```
   避免覆盖未处理的状态。

3. **分组容斥合并**  
   ```cpp
   dp[j][k] = (f1[j][k] + f2[j][k] - dp[j][k] + mod) % mod;
   ```
   消除两组均不选大质数的重复计数。

### 代码实现片段
```cpp
// 预处理质因数
struct node{ int val, big, S; };
void init() {
    for (int i=2; i<=n; i++) {
        int tmp = i;
        for (int j=0; j<8; j++) 
            if (tmp % prime[j] == 0) {
                S |= (1<<j);
                while (tmp % prime[j] == 0) tmp /= prime[j];
            }
        big = (tmp == 1) ? -1 : tmp;
    }
    sort(a+2, a+n, cmp); // 按大质数排序
}

// 动态转移核心
for (int i=2; i<=n; i++) {
    if (大质数变化) memcpy(f1, dp), memcpy(f2, dp);
    // 更新f1和f2
    if (当前数可加入甲) f1[s1|S][s2] += f1[s1][s2];
    if (当前数可加入乙) f2[s1][s2|S] += f2[s1][s2];
    // 合并结果
    if (大质数组结束) dp = f1 + f2 - dp;
}
```

---

## 相似题目推荐
1. **P2704 [NOI2001]炮兵阵地**  
   - 状压DP经典题，处理相邻状态约束。

2. **P1896 [SCOI2005]互不侵犯**  
   - 棋盘状压DP，状态转移与互斥条件处理。

3. **P4163 [SCOI2007]排列**  
   - 质数判断与数位DP结合，需处理模数状态。

---

## 可视化代码片段（Canvas动画）
```javascript
// 绘制状态转移网格
function drawGrid() {
    ctx.fillStyle = "#2c3e50"; // 深蓝背景
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    for (let s1=0; s1<=255; s1++) {
        for (let s2=0; s2<=255; s2++) {
            if (dp[s1][s2] > 0) {
                ctx.fillStyle = (s1 & s2) ? "#e74c3c" : "#2ecc71"; // 冲突红/有效绿
                ctx.fillRect(s1*2, s2*2, 2, 2); // 像素点表示状态
            }
        }
    }
}
// 播放音效
function playSound(type) {
    if (type === "merge") 
        beep(440, 100); // 合并时高音
    else if (type === "error")
        beep(220, 200); // 冲突时低音
}
```

---

## 总结
本题通过质因数分类与状压DP的结合，巧妙处理了大规模质数约束问题。核心在于分治思想：小质数直接状压，大质数分组容斥。可视化设计通过像素风格和音效交互，使抽象的DP状态转移具象化，适合教学演示与算法理解。

---
处理用时：82.75秒
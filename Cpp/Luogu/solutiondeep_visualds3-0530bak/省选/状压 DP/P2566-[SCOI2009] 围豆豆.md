# 题目信息

# [SCOI2009] 围豆豆

## 题目背景

四川NOI2009省选


## 题目描述

是不是平时在手机里玩吃豆豆游戏玩腻了呢？最近MOKIA手机上推出了一种新的围豆豆游戏，大家一起来试一试吧。


游戏的规则非常简单，在一个N×M的矩阵方格内分布着D颗豆子，每颗豆有不同的分值Vi。游戏者可以选择任意一个方格作为起始格，每次移动可以随意的走到相邻的四个格子，直到最终又回到起始格。最终游戏者的得分为所有被路径围住的豆豆的分值总和减去游戏者移动的步数。矩阵中某些格子内设有障碍物，任何时刻游戏者不能进入包含障碍物或豆子的格子。游戏者可能的最低得分为0，即什么都不做。


注意路径包围的概念，即某一颗豆在路径所形成的多边形（可能是含自交的复杂多边形）的内部。下面有两个例子：

 
 ![](https://cdn.luogu.com.cn/upload/pic/1690.png) 

第一个例子中，豆在路径围成的矩形内部，所以豆被围住了。第二个例子中，虽然路径经过了豆的周围的8个格子，但是路径形成的多边形内部并不包含豆，所以没有围住豆子。

布布最近迷上了这款游戏，但是怎么玩都拿不了高分。聪明的你决定写一个程序来帮助他顺利通关。


## 说明/提示

50%的数据满足1≤D≤3。

100%的数据满足1≤D≤9，1≤N, M≤10，-10000≤Vi≤10000。


## 样例 #1

### 输入

```
3 8

3

30 -100 30

00000000

010203#0

00000000

```

### 输出

```
38```

# AI分析结果



# [SCOI2009] 围豆豆 题解分析

## 唯一算法分类
**状态压缩 BFS**

---

## 综合分析与结论

### 核心算法流程
1. **状态定义**：`f[x][y][s]` 表示在坐标 `(x,y)` 时，包围状态为 `s`（二进制位表示各豆豆是否被包围）的最小步数。
2. **射线法判断包围**：  
   - 对每个豆豆向右引射线，若路径上下移动穿过射线奇数次则被包围。
   - 方向为上下移动时（`i=1或3`），计算是否穿过豆豆右侧射线。
3. **状态转移**：  
   - 遍历四个方向移动，若为上下方向，通过异或操作更新包围状态（`solve()` 函数）。
4. **得分计算**：  
   - 预处理各状态 `s` 的总价值 `val[s]`，最终得分为 `val[s] - f[x][y][s]`。

### 可视化设计思路
1. **网格绘制**：用 Canvas 绘制 `n×m` 网格，障碍用黑色，豆豆用不同颜色标记。
2. **状态高亮**：  
   - 当前坐标用闪烁方块表示。
   - 被包围豆豆的射线用红色高亮，路径线段用渐变色区分方向。
3. **动画步进**：  
   - 每次移动时展示路径扩展（类似贪吃蛇）。
   - 状态 `s` 变化时播放 "beep" 音效，闭合路径时触发胜利音效。
4. **复古风格**：  
   - 8-bit 像素字体，网格线宽 2px。
   - 背景音乐使用 `chiptune.js` 生成的循环旋律。

---

## 题解清单（≥4星）

### 1. hzoi_liuchang（⭐⭐⭐⭐⭐）
**亮点**：  
- 详细解释射线法原理与状态转移数学证明  
- BFS 和 SPFA 双版本代码，注释清晰  
- 强调 vis 数组初始化的重要性（附错解对比）

### 2. Mr_HY43205（⭐⭐⭐⭐）
**亮点**：  
- 将状态转移抽象为图论松弛操作  
- 使用优先队列优化 Dijkstra 思路  
- 代码结构模块化（`dp()` 函数分离核心逻辑）

### 3. spdarkle（⭐⭐⭐⭐）
**亮点**：  
- 用位运算快速计算状态异或  
- 预处理 `score` 数组优化计算  
- 简洁的 SPFA 实现（仅 50 行核心代码）

---

## 最优思路提炼

### 关键技巧
1. **射线奇偶判定**：仅处理上下移动方向，避免水平移动干扰。
2. **异或更新状态**：路径穿过射线时 `ns ^= (1<<(i-1))` 快速翻转状态。
3. **预处理价值数组**：`val[s]` 提前计算各状态总得分，优化时间复杂度。

### 实现优化
```cpp
// 预处理 val[s]
for(int i=0; i<(1<<d); i++) 
    for(int j=1; j<=d; j++)
        if(i & (1<<(j-1))) val[i] += da[j];
```

### 状态转移核心代码
```cpp
int solve(int mx, int my, int nx, int ny, int ms) {
    int ns = ms;
    for(int i=1; i<=d; i++) {
        if( ((mx==ax[i] && nx<ax[i]) || (mx<ax[i] && nx==ax[i])) 
            && ny > ay[i] ) {
            ns ^= (1 << (i-1)); // 异或更新状态
        }
    }
    return ns;
}
```

---

## 类似题目推荐
1. **[NOIP2017 宝藏](https://www.luogu.com.cn/problem/P3959)**  
   （状压 DP + 最短路径覆盖）
2. **[P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)**  
   （状态压缩 + 几何路径计算）
3. **[P2622 关灯问题II](https://www.luogu.com.cn/problem/P2622)**  
   （位运算状态转移 + BFS）

---

## 可视化代码片段（Canvas 动画）

```javascript
// 绘制路径与状态
function drawStep(ctx, x, y, s) {
    ctx.fillStyle = "#FF5555"; // 当前坐标高亮
    ctx.fillRect(x*30, y*30, 28, 28);
    
    // 绘制被包围豆豆射线
    for(let i=0; i<d; i++) {
        if(s & (1<<i)) {
            ctx.strokeStyle = "#FF0000";
            ctx.beginPath();
            ctx.moveTo(beans[i].x*30+15, beans[i].y*30+15);
            ctx.lineTo(500, beans[i].y*30+15);
            ctx.stroke();
        }
    }
}
```

---

## 调试心得摘录
> "**hzoi_liuchang**：错解因未重置 vis 数组，导致后续起点遍历错误。正确做法是每个起点独立初始化队列和状态。"  
> **spdarkle**：发现水平移动不影响状态后，将方向判断简化为 `i==0||i==2`，减少冗余计算。"  
> **Mr_HY43205**：优先队列优化时发现步数可能为负，改用最大堆确保正确性。"

---
处理用时：74.90秒
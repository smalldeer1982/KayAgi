# 题目信息

# [WC2018] 州区划分

## 题目背景

**滥用本题评测将被封号！**

## 题目描述

小 S 现在拥有 $n$ 座城市，第 $i$ 座城市的人口为 $w_i$，城市与城市之间可能有双向道路相连。

现在小 S 要将这 $n$ 座城市划分成若干个州，每个州由至少一个城市组成，每个城市在恰好一个州内。

假设小 S 将这些城市划分成了 $k$ 个州，设 $V_i$ 是第 $i$ 个州包含的所有城市组成的集合。定义一条道路是一个州的内部道路，当且仅当这条道路的两个端点城市都在这个州内。如果一个州内部存在一条起点终点相同，不经过任何不属于这个州的城市，且经过这个州的所有内部道路都恰好一次并且经过这个州的所有城市至少一次的路径（路径长度可以为 $0$），则称这个州是不合法的。

定义第 $i$ 个州的满意度为：第 $i$ 个州的人口在前 $i$ 个州的人口中所占比例的 $p$ 次幂，即：

$$\left(\dfrac{\sum _ {x \in V _ i} w _ x}{\sum _ {j = 1} ^ i \sum _ {x \in V _ j} w _ x}\right) ^ p$$


定义一个划分的满意度为所有州的满意度的乘积。

求所有合法的划分方案的满意度之和。

答案对 $998244353$ 取模。
两个划分 $\{V_1, V _ 2, \cdots, V_k\}$ 和 $\{C_1, C _ 2, \cdots, C_s\}$ 是不同的，当且仅当 $k \neq s$，或存在某个 $1 \leq i \leq k$，使得 $V_i \neq C_i$。

## 说明/提示



【提示】

$x^{p-1} \equiv 1 \pmod p$，其中 $p$ 为质数， $x \in [1,p)$。

保证对于所有数据有：$0 \leq n \leq 21$， $0 \leq m \leq \dfrac{n\times (n-1)}{2}$ ， $0 \leq p \leq 2$， $1 \leq w_i \leq 100$。


## 样例 #1

### 输入

```
3 2 1
1 2
2 3
1 1 1```

### 输出

```
1```

# AI分析结果



### 【唯一算法分类】
状态压缩动态规划（子集卷积优化）

---

### 【题解思路、算法要点与解决难点】

#### **核心思路**
1. **合法性判断**：州合法当且仅当其不连通或存在奇数度顶点。通过并查集判断连通性，统计度数奇偶性。
2. **状态压缩DP**：定义 `f[S]` 为划分集合 `S` 的满意度之和。转移方程：
   $$
   f[S] = \sum_{T \subseteq S} \frac{f[S-T] \cdot g[T]}{(sum_S)^p}
   $$
   其中 `g[T]` 为合法州 `T` 的权值。
3. **子集卷积优化**：将状态按集合大小分层，利用 FWT/FMT 加速卷积计算，复杂度优化至 $O(n^2 2^n)$。

#### **关键难点**
- **分母处理**：动态维护 `sum_S` 的逆元，避免重复计算。
- **分层卷积**：按集合大小分层进行 FWT，确保子集不交。

#### **算法实现要点**
- **预处理合法性**：对每个子集 `S` 计算连通性和度数奇偶性。
- **分层FWT变换**：将 `f` 和 `g` 按集合大小分组进行快速变换。
- **逆元优化**：预先计算所有 `sum_S` 的逆元，转移时直接乘法代替除法。

---

### 【题解评分 (≥4星)】

1. **lahlah (5星)**  
   - **亮点**：代码结构清晰，注释详细；分层FWT实现高效；预处理合法性逻辑完整。  
   - **代码**：使用位运算优化合法性判断，分阶段处理卷积。

2. **bztMinamoto (5星)**  
   - **亮点**：详细解释子集卷积原理；代码模块化，易读性强；逆元处理巧妙。  
   - **代码**：FMT实现简洁，预处理 `sum` 和 `inv` 数组。

3. **约瑟夫用脑玩 (4星)**  
   - **亮点**：数学推导完整，分层转移逻辑清晰；代码包含详细注释。  
   - **缺点**：合法性判断部分代码较冗长。

---

### 【最优思路或技巧提炼】

1. **子集卷积分层优化**  
   - 将状态按集合大小分层，利用 FWT/FMT 分步卷积，避免子集交叠问题。
   - 核心代码：
     ```cpp
     for (int i = 1; i <= n; i++) {
         FWT(f[i-1], 1); // 正变换
         for (int j = 0; j < i; j++) {
             for (int s = 0; s < lim; s++)
                 f[i][s] += f[j][s] * g[i-j][s]; // 分层卷积
         }
         IFWT(f[i], -1); // 逆变换
         // 逆元处理
     }
     ```

2. **逆元预处理**  
   - 提前计算所有子集的逆元，避免重复快速幂计算：
     ```cpp
     inv[s] = qpow(qpow(sum[s], mod-2), p);
     ```

3. **合法性快速判断**  
   - 并查集检查连通性，统计度数奇偶性：
     ```cpp
     bool check(int s) {
         if (连通 && 全偶数度) return false;
         return true; // 合法
     }
     ```

---

### 【同类型题或类似算法套路】

- **子集卷积应用**：P6097 【模板】子集卷积
- **状压DP优化**：P2150 [NOI2015] 寿司晚宴
- **欧拉回路判断**：P1333 瑞瑞的木棍

---

### 【可视化与算法演示】

#### **动画设计**
- **状态压缩展示**：以网格表示所有子集，颜色标记当前处理的状态（如绿色为正在卷积的层）。
- **FWT变换高亮**：动态显示分层FWT的蝴蝶操作，红色标记变换中的关键位。
- **合法性检查**：对每个子集触发连通性和度数检查动画，灰色表示非法州。

#### **复古像素风格**
- **Canvas 网格**：每个子集用 8x8 像素块表示，合法州显示绿色，非法州红色。
- **音效触发**：成功转移时播放 8-bit 上升音效，非法状态触发低音警报。
- **自动演示**：按层逐步执行卷积，速度可调，支持暂停/继续。

---

### **核心代码片段（分层FWT实现）**

```cpp
void FWT(ll *a, int len, int opt) {
    for (int mid = 1; mid < len; mid <<= 1)
        for (int j = 0; j < len; j += mid << 1)
            for (int k = 0; k < mid; k++)
                a[j + mid + k] = (a[j + mid + k] + opt * a[j + k] + mod) % mod;
}

// 预处理合法性
for (int S = 0; S < (1 << n); S++) {
    if (check(S)) g[bitcnt[S]][S] = qpow(sum[S], p);
}

// 分层DP
f[0][0] = 1; FWT(f[0], 1);
for (int i = 1; i <= n; i++) {
    for (int j = 0; j < i; j++)
        for (int s = 0; s < lim; s++)
            f[i][s] = (f[i][s] + f[j][s] * g[i-j][s]) % mod;
    IFWT(f[i], -1);
    for (int s = 0; s < lim; s++)
        f[i][s] = (bitcnt[s] == i) ? f[i][s] * inv[s] % mod : 0;
    if (i != n) FWT(f[i], 1);
}
```

---

### **推荐题目**
1. [P6097 子集卷积模板](https://www.luogu.com.cn/problem/P6097)
2. [P2150 状压DP优化](https://www.luogu.com.cn/problem/P2150)
3. [P1333 欧拉回路判断](https://www.luogu.com.cn/problem/P1333)

---

### **总结**
本题通过子集卷积优化状压DP，将指数级复杂度降至多项式级别。核心在于分层处理状态和快速变换，结合预处理技巧大幅提升效率。可视化设计可帮助理解分层卷积和合法性判断的动态过程。

---
处理用时：71.47秒
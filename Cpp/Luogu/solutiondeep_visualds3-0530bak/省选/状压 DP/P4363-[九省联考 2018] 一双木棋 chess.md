# 题目信息

# [九省联考 2018] 一双木棋 chess

## 题目描述

菲菲和牛牛在一块 $n$ 行 $m$ 列的棋盘上下棋，菲菲执黑棋先手，牛牛执白棋后手。

棋局开始时，棋盘上没有任何棋子，两人轮流在格子上落子，直到填满棋盘时结束。  

落子的规则是：一个格子可以落子当且仅当这个格子内没有棋子且这个格子的左侧及上方的所有格子内都有棋子。

棋盘的每个格子上，都写有两个非负整数，从上到下第 $i$ 行中从左到右第 $j$ 列的格子上的两个整数记作 $a_{i,j}$ 和 $b_{i,j}$。

在游戏结束后，菲菲和牛牛会分别计算自己的得分：菲菲的得分是所有有黑棋的格子上的 $a_{i,j}$ 之和，牛牛的得分是所有有白棋的格子上的 $b_{i,j}$ 的和。

菲菲和牛牛都希望，自己的得分减去对方的得分得到的结果最大。现在他们想知道，在给定的棋盘上，如果双方都采用最优策略且知道对方会采用最优策略，那么，最终的结果如何？


## 说明/提示

### 样例 1 说明

![](https://cdn.luogu.com.cn/upload/pic/16877.png)

棋盘如图所示，双方都采用最优策略时，棋局如下：

- 菲菲下在第 $1$ 行第 $1$ 列（这是第一步时唯一可以落子的格子）。
- 牛牛下在第 $1$ 行第 $2$ 列。
- 菲菲下在第 $2$ 行第 $1$ 列。
- 牛牛下在第 $1$ 行第 $3$ 列。
- 菲菲下在第 $2$ 行第 $2$ 列。
- 牛牛下在第 $2$ 行第 $3$ 列（这是这一步时唯一可以落子的格子）。
- 填满棋盘，游戏结束。

盘面如下：

![](https://cdn.luogu.com.cn/upload/pic/16878.png)

菲菲的得分为 $2 + 9 + 1 = 12$，牛牛的得分为 $7 + 2 + 1 = 10$。

### 数据规模与约定

各测试点信息如下表。

![](https://cdn.luogu.com.cn/upload/pic/16879.png)

- 对于编号为奇数的测试点，保证 $b_{i, j} = 0$。
- 对于全部的测试点，保证 $1 \leq n, m \leq 10$，$0 \leq a_{i, j}, b_{i, j} \leq 10^5$。


## 样例 #1

### 输入

```
2 3
2 7 3
9 1 2
3 7 2
2 3 1
```

### 输出

```
2```

# AI分析结果



## 算法分类
状态压缩动态规划（轮廓线DP）

## 综合分析与结论

### 核心思路与难点
题目本质是博弈论+状态压缩的动态规划问题。核心在于：
1. 棋盘状态的特征为阶梯状轮廓线，可用二进制或行棋数序列表示状态
2. 使用Minimax对抗搜索策略（先手最大化差值，后手最小化差值）
3. 状态转移时需遍历所有合法落子位置，计算得分差值

**可视化设计思路**：
1. 棋盘动画：用不同颜色方块表示双方棋子，当前可落子位置高亮闪烁
2. 轮廓线演示：在棋盘边缘绘制动态移动的轮廓线，用红色箭头指示状态转移方向
3. 状态编码展示：在侧边栏实时显示二进制状态码的位变化过程
4. 决策树可视化：用动态展开的树状图展示当前状态的子状态评估值

## 高星题解推荐（≥4星）

### 1. Anoxiacxy（5星）
- **亮点**：轮廓线状态编码清晰，记忆化搜索实现简洁，代码可读性极佳
- **核心代码**：
```cpp
int dfs(int sta, bool who, int n, int m) {
    if (~f[sta]) return f[sta];
    int x = n, y = 0;
    // 遍历轮廓线寻找合法落子位置
    for(int i = 0; i < n+m-1; ++i) {
        if (sta >> i & 1) x--; else y++;
        if ((sta >> i & 3) != 1) continue;
        int nxt = sta ^ (3 << i); // 关键状态转移
        // Minimax对抗逻辑
    }
}
```

### 2. cmd2001（4.5星）
- **亮点**：map存储状态，行棋数序列编码直观，调试友好
- **核心技巧**：
```cpp
struct State {
    int v[N]; // 每行棋子数
    bool operator < (const State &s) const { // map排序用
        for(int i=1; i<=n; ++i)
            if(v[i] != s.v[i]) return v[i] < s.v[i];
        return false;
    }
};
```

### 3. yzhang（4星）
- **亮点**：详细注释轮廓线转移逻辑，包含二进制操作图解
- **关键注释**：
```cpp
// 状态转移：把01变成10
// 原轮廓: 0 1 -> 转移后: 1 0
int nxt = sta ^ (3 << i); // 异或操作翻转相邻两位
```

## 核心算法实现

### 轮廓线状态转移关键代码
```cpp
int dfs(int sta, bool who) {
    if(vis[sta]) return dp[sta];
    int x = n, y = 0; // 从棋盘左下角开始
    for(int i=0; i<m+n-1; ++i) {
        if(sta>>i &1) x--; else y++; // 解析轮廓线
        if((sta>>i &3) != 1) continue; // 寻找可翻转的01位
        int nxt = sta^(3<<i); // 翻转相邻两位
        int score = who ? -b[x][y] : a[x][y];
        res = who ? min(res, dfs(nxt,0)+score) 
                  : max(res, dfs(nxt,1)+score);
    }
    return dp[sta] = res;
}
```

## 同类型题目推荐
1. P2595（多米诺骨牌轮廓线DP）
2. P1973（NOI嘉年华-区间决策）
3. P2831（愤怒的小鸟-状态压缩）

## 复古像素风可视化方案

### 动画要素设计
1. **棋盘显示**：16x16像素格子，黑棋用深蓝方块，白棋用浅黄方块
2. **轮廓线动画**：红色LED灯式流动光效沿轮廓线移动
3. **状态编码显示**：右侧8-bit风格二进制滚动显示，关键位闪烁
4. **音效设计**：
   - 落子时：FC游戏《俄罗斯方块》方块落地音效
   - 状态转移：8-bit"哔"声提示
   - 终局结算：经典《超级马里奥》过关音效

### 核心动画逻辑（伪代码）
```javascript
class ChessAnimator {
    constructor(canvas) {
        this.gridSize = 16; // 像素块大小
        this.palette = ['#000055','#FFFF00','#FF0000']; // 调色板
    }
    
    drawState(sta) {
        let x = n, y = 0;
        for(let i=0; i<sta.length; i++) {
            if(sta & (1<<i)) {
                drawPixel(x, y, this.palette[0]); // 黑棋
                x--;
            } else {
                drawPixel(x, y, this.palette[1]); // 白棋
                y++;
            }
        }
        // 绘制流动轮廓线
        drawContourLine(sta, this.palette[2]); 
    }
}
```

## 调试心得摘录
> "考场上使用next作为变量名导致CE...命名规范太重要了！" —— Anoxiacxy  
> "发现状态数实际只有35万种后，果断用map代替数组" —— cmd2001  
> "轮廓线转移时忘记处理边界条件，调试2小时才找到越界问题" —— shadowice1984

## 总结
本题通过状态压缩将棋盘特征编码为轮廓线，结合Minimax对抗搜索实现最优策略计算。不同题解在状态表示（二进制、行棋数列）和存储方式（数组、map）上各有创新，但核心都是抓住棋盘状态的单调性特征。可视化时可重点表现轮廓线变化与状态编码的位操作过程，配合8-bit风格元素增强理解趣味性。

---
处理用时：66.17秒
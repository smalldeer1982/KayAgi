# 题目信息

# GodFly的寻宝之旅

## 题目背景

“蒹葭苍苍，白露为霜。所谓伊人，在水一方…”

怀着$a$ $burning$ $desire$，$GodFly$开启了他追寻学妹之路。

## 题目描述

我们把校园抽象成一个具有$n$个点的无向连通图，其中的$n$个结点分别编号为$1,2,3,...,n$。把$GodFly$经过的结点表示为一个路径集合$A=\left\{a_1,a_2,a_3,...,a_m\right\}$，表示他依次经过了编号为$a_1$、$a_2$、…、$a_m$的结点，由于集合的元素具有互异性，这意味着$GodFly$无法重复经过同一个结点。

$GodFly$现在要从第$1$个结点走到第$n$个结点，然而他的腿疾对他造成了许多不便。定义$GodFly$经过了$m$个结点，当前在点$a_m$，且路径集合$A=\left\{a_1,a_2,a_3...,a_{m-1}\right\}$（加入新结点$a_m$前）时，他的总体力耗费为$w_m=(w_{m-1}+a_m*sum(A))$%$2$，其中$w_{m-1}$表示上一个路径集合的体力耗费；且对于集合$A$，$sum(A)=a_1+a_2+...+a_{m-1}$。

对于$w=0$的情况，我们称$GodFly$处于“滑基态”，否则对于$w=1$的情况，我们称$GodFly$处于“对偶态”。现在$GodFly$想要知道，他走到$n$结点后处于滑基态或对偶态的方案数，由于这个数可能很大，你只需要输出它对$19260817$取膜（模）的结果；注意两个方案是不同的，当且仅当它们有至少一条经过的边不同，而非路径集合不同。

**注意：T3压缩包内第一个数据有误，以题面的样例为准。**

## 说明/提示

**【数据范围】**

对于$30$%的数据，$n<=10$，$k<=45$，无重边及自环；

对于$60$%的数据，$n<=15$，$k<=300$；

对于$80$%的数据，$n<=15$，$k<=100000$；

对于$100$%的数据，$n<=18$，$k<=100000$；

样例数据在**data.zip\fantasy\**中。

**【样例说明】**

![](https://cdn.luogu.com.cn/upload/pic/30986.png)

如图，初始时在$1$结点，路径集合为$\left\{1\right\}$，费用为$0$；

若从$1$走到$2$结点再走到$3$结点，到$2$结点时，费用为$(0+2*sum(\left\{1\right\}))$%$2=2*1$%$2=0$，并把$2$加入路径集合，则此时路径集合为$\left\{1,2\right\}$；到$3$结点时，因上一次费用为0，费用为$(0+3*sum(\left\{1,2\right\}))$%$2=3*(1+2)$%$2=1$；

若从$1$结点直接走到$3$结点，则费用为$(0+3*sum(\left\{1\right\}))$%$2=3*1$%$2=1$。

故最终走到$3$结点时费用为$1$的方案数为$2$。

**【提示】**

本题时限$3s$，且可以开启$O_2$优化，不必过分担心卡常数，但请确保算法足够优美。

## 样例 #1

### 输入

```
3 3
1 2
2 3
1 3
1```

### 输出

```
2```

# AI分析结果



### 唯一算法分类
状压DP

### 题解思路与解决难点
**核心思路**：  
题目要求统计从1到n的所有不重复路径中，满足特定状态（0/1）的方案数。难点在于状态计算与路径顺序无关的性质发现。关键步骤如下：

1. **状态压缩设计**：  
   - 用二进制位掩码表示已访问的节点集合，`f[i][s]`表示当前在节点i，已访问集合为s的方案数。
   - **关键优化**：发现路径集合的节点顺序不影响最终状态`w`的值，只需记录集合本身，无需维护中间状态，将状态压缩到二维。

2. **状态转移**：  
   - 枚举当前状态`s`和节点`i`，遍历所有可能的邻居节点`j`。  
   - 若边`i-j`存在且`j`未被访问过，则将方案数累加到新状态`s | (1<<(j-1))`和节点`j`上。

3. **最终计算**：  
   - 遍历所有包含起点1和终点n的集合`s`，计算该集合的`w`值，统计符合目标状态的方案数。

**难点对比**：  
- **未发现性质**的解法（如wind_seeker的题解）需额外维护`w`和`sum`的中间状态，导致三维甚至四维状态，时间和空间复杂度较高。  
- **发现性质**的解法（如Fellyhosn的题解）通过预处理集合的`sum`和`w`，将状态降为二维，极大优化效率。

### 题解评分（≥4星）
1. **Fellyhosn的题解（★★★★★）**  
   - **亮点**：利用路径顺序无关性质，状态设计简洁高效，代码可读性强。  
   - **关键代码**：预处理集合的`sum`，最后统一计算`w`，极大降低复杂度。

2. **JimmyF的题解（★★★★☆）**  
   - **亮点**：预处理每个状态的`sum`，直接按题意转移，思路清晰。  
   - **缺点**：未利用顺序无关性，状态数为三维，空间开销较大。

3. **soul_M的题解（★★★★☆）**  
   - **亮点**：明确状态定义和转移方程，适合理解基础状压DP。  
   - **缺点**：未优化状态维度，处理大规模数据时效率受限。

### 最优思路提炼
- **核心性质**：路径集合确定后，无论访问顺序如何，最终状态`w`的值相同。  
- **实现技巧**：  
  1. 状压DP记录节点和访问集合。  
  2. 预处理每个集合的`sum`，通过公式`w = (Σ a_i * sum_before_i) % 2`计算最终状态。  
  3. 最后过滤符合目标状态的集合，累加方案数。

### 类似题目推荐
1. **P3959 [NOIP2017 提高组] 宝藏**（状压DP，最小生成树变体）  
2. **P1433 吃奶酪**（状压DP，路径规划）  
3. **P2831 [NOIP2016 提高组] 愤怒的小鸟**（状压DP，集合覆盖问题）

### 可视化与算法演示
**动画设计**：  
1. **状态转移可视化**：  
   - 用网格表示所有可能的集合状态，高亮当前处理的节点和转移边。  
   - 动态显示二进制掩码的更新（如红色方块表示已访问节点）。  

2. **复古像素风格**：  
   - 8位像素节点和边，用不同颜色区分已访问/未访问节点。  
   - 音效提示：转移时播放“点击”声，状态合法时播放成功音效。  

3. **交互控制**：  
   - 步进执行观察每个状态的扩展过程。  
   - 自动模式展示AI如何选择最优转移路径。  

**关键代码片段（Fellyhosn的解法）**：
```cpp
int main() {
    // ... 输入处理
    f[1][1] = 1;
    for (int s = 1; s < (1<<n); s++) {
        for (int j = 1; j <=n; j++) {
            if (!(s & (1<<(j-1)))) continue;
            for (int k = 1; k <=n; k++) {
                if (s & (1<<(k-1)) || !a[j][k]) continue;
                int new_s = s | (1<<(k-1));
                f[k][new_s] = (f[k][new_s] + a[j][k] * f[j][s]) % mod;
            }
        }
    }
    // ... 统计结果
}
```

### 总结
本题通过发现路径顺序无关性质，将状态压缩到二维，极大优化了状压DP的效率。核心在于预处理集合的数学特征（如`sum`和`w`），避免维护冗余状态。可视化设计可结合像素风格和动态状态转移，直观展示算法核心流程。

---
处理用时：133.60秒
# 题目信息

# 「EZEC-2」甜梦

## 题目背景



> 昨是今非望无尽，生死相隔两茫茫。    
解愁肠，度思量，人间如梦，倚笑乘风凉。

## 题目描述

有 $n$ 个梦境场景，编号 $\in [1,n]$ 且互不相同。PF 有精神分裂症，他在同一时间会处于两个梦境。**这两个梦境所在的场景编号差别的绝对值不能大于 $l$**。场景之间有 $m$ 种**单向**关系，其中第 $i$ 个关系连接场景 $u_i$ 和 $v_i$。不存在不可能到达的场景。

每个场景都有一个快乐值，其中第 $j$ 个场景的快乐值为 $a_j$，在梦境**第一次**经过时增加。

一开始两个梦境均在场景 $1$，当两个梦境都移动到场景 $n$ 时，PF会醒来。

如果某次移动时，PF 目前梦境所在的两个场景 $A,B$ 都与某个场景 $C$ **直接相连**，那么 PF 可以**同时移动** 两个梦境到达场景 $C$ 。否则，PF **一次只能移动一个梦境**。

请你编一个程序，来计算醒来时可能得到的最大快乐值。

## 说明/提示

[大样例](https://www.luogu.com.cn/paste/ar8yuqg6)

**【样例解释 #1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/a3bbsu8i.png?x-oss-process=image/resize,m_lfit,h_340,w_500)

下文用 $A,B$ 表示目前正在进行的梦境：

移动梦境 $A \space 1 \to 3$，移动梦境 $B \space 1 \to 4$，移动梦境 $A \space 3 \to 5$，之后同时移动梦境 $A \space B$ 到达场景 $7$，快乐值总和为 $5+10+10 = 25$。

**注意**：如果想移动某一梦境到场景 $6$，那么另一梦境的编号必须大于等于 $4$。然而到 $6$ 的线路只有 $1\to 6$，而同时拥有场景 $1$ 和场景 $4$ 不满足中间相隔场景 $\le l$，故唯一通过场景 $6$ 的方案为将两个梦境同时移动到场景 $6$，而这么做能得到的快乐值为 $20$。

---

**【数据范围与约定】**
| 测试点编号 | $ n \le$ | $ m \le$ | $ l \le$ | $ a_i \le$| 时间 | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |:----------: | :----------: |:----------: |
| $1,2$ | $10$ | $15$| $5$ | $50$ | $1\text s$ |无 |
| $3\sim 4$ | $16$ | $40$ | $8$ | $5 \times 10^3$ |$1\text s$ |无 |
| $5\sim 6$ | $16$ | $120$ | $8$ | $5 \times 10^3$ |$1\text s$ |无 |
| $7 \sim 10$ | $100$| $10^3$|$10$ | $10^4$|$1 \text s$ |无|
| $11$ | $100$| $10^3$|$10$ | $10^4$|$1\text s$ |场景是一棵树|
| $12 \sim 14$ | $10^3$| $10^4$|$10$ | $10^4$|$1\text s$ |无|
| $15,16$ | $5\times10^3$| $3\times10^4$|$10$ | $10^4$|$1\text s$ |无|
| $17,18$ | $5\times10^3$| $3\times10^4$|$11$ | $10^4$|$2\text s$ |无|
| $19,20$ | $5\times10^3$| $3\times10^4$|$12$ | $10^4$|$3\text s$ |无|

对于 $100\%$ 的数据，$1\le u<v \le n$, $1 \le n \le 5\times 10^3$, $1 \le m \le 3\times 10^4$, $1 \le a_i \le 10^4$, $1 \le l \le 12$。

**输入保证每个场景都能从起点到达，并且都能连到终点。**

**输入不保证没有重边。**

**输入不对 $u,v$ 的编号差做任何保证。**

------------

**【移动范例】**

假设 $l=2$ 且关系存在，下面的格式表示 $A \space B$ $\to$ $A' \space B'$ 一次移动：

* $1 \space 3 \to 5\space 3$ (√)
* $1 \space 3 \to 1\space 4$ (×)
* $1 \space 3 \to 8\space 8$ (√)
* $1 \space 3 \to 6\space 8$ (×)

## 样例 #1

### 输入

```
7 9 2
0 4 5 10 10 20 0
1 2
1 3
1 4
1 6
2 5
3 5
4 7
5 7
6 7```

### 输出

```
25```

# AI分析结果



---

**算法分类**：状压动态规划

---

### **题解思路与算法要点**
1. **状态设计**  
   - **核心状态**：`f[u][S]` 表示当前两个梦境中较小点为 `u`，且状态 `S` 记录 `[u, u+l]` 范围内已访问的点。`S` 为二进制掩码，最高位对应较大点 `v = u + highbit(S)`。
   - **预计算**：预处理每个状态 `S` 的最高位 `highbit(S)`，用于快速确定较大点 `v`。

2. **转移逻辑**  
   - **同时移动**：若 `u` 和 `v` 均能到达新点 `w`，则转移至 `f[w][1]`（新状态为仅 `w` 被访问）。
   - **单独移动较大点 `v`**：枚举 `v` 的后继 `w`，更新 `S` 为 `S | (1 << (w - u))`，确保 `w - u ≤ l`。
   - **单独移动较小点 `u`**：  
     - 若新点 `w > v`，则较小点变为 `v`，状态右移 `v - u` 位后合并新位。  
     - 若 `w ≤ v`，则较小点变为 `w`，状态右移 `w - u` 位后重置最低位。

3. **优化技巧**  
   - **滚动数组**：对 `n` 较大的情况，使用 `dp[now][S]` 滚动存储，空间复杂度降至 `O(l * 2^l)`。
   - **状态离散化**：仅保留有效状态（含最低位为 `1`），减少无效计算。

---

### **题解评分 (≥4星)**
1. **奇米 (⭐⭐⭐⭐)**  
   - **亮点**：逻辑清晰，分三类转移详细注释，预处理 `highbit` 提升效率。  
   - **代码**：结构简明，适合快速理解核心逻辑。

2. **syksykCCC (⭐⭐⭐⭐)**  
   - **亮点**：代码简洁，注释明确，转移分类处理得当。  
   - **技巧**：直接枚举 `highbit`，避免复杂位运算。

3. **pocafup (⭐⭐⭐⭐⭐)**  
   - **亮点**：深入分析数据范围，提出滚动数组与离散化优化，解决空间瓶颈。  
   - **代码**：结合预处理与动态更新，适合大规模数据。

---

### **最优思路提炼**
- **状压状态压缩**：利用 `l` 的小范围，将连续区间访问状态压缩为二进制数。
- **无后效性保证**：图的无环性确保状态转移单向，避免重复计算。
- **高效转移分类**：分三类处理移动，确保不遗漏最优解。

---

### **同类型题推荐**
1. **P1433 吃奶酪**（状压DP求最短路径）  
2. **P2622 关灯问题II**（状态压缩+广度优先搜索）  
3. **P2831 愤怒的小鸟**（状压DP优化抛物线覆盖）

---

### **个人心得摘录**
- **调试教训**：贪心剪枝不可靠，需严格证明正确性（pocafup 题解）。  
- **空间优化**：滚动数组与离散化是状压DP处理大 `n` 的关键（代码实现中体现）。

---

### **可视化设计**
**动画方案**：  
1. **网格绘制**：以 `n` 个节点为纵轴，状态 `S` 为横轴，动态显示 `f[u][S]` 的值。  
2. **颜色标记**：  
   - **当前操作点**：红色高亮 `u`，蓝色高亮 `v`。  
   - **状态位**：绿色表示已访问，灰色未访问。  
3. **音效交互**：  
   - **移动成功**：轻快“滴”声。  
   - **状态更新**：短促“咔嗒”声。  
4. **自动演示**：按转移顺序自动播放，可调节速度或单步执行。

**复古像素风格**：  
- **8位色调色板**：红、蓝、绿、灰四色模拟FC风格。  
- **Canvas动画**：网格动态刷新，像素块表示状态变化。

---

**核心代码片段（奇米题解）**  
```cpp
for (int S = 0; S < (1 << l+1); S++) {
    if (!(S & 1)) continue; // 无效状态
    int u = i, v = i + High[S];
    for (int w : G[v]) { // 移动较大点
        if (mp[u][w]) f[w][1] = max(f[w][1], f[u][S] + val[w]);
        if (w - u > l) continue;
        f[u][S | (1 << (w - u))] = max(..., f[u][S] + val[w]);
    }
    for (int w : G[u]) { // 移动较小点
        if (w > v) {
            int nxt = (S >> (v - u)) | (1 << (w - v));
            f[v][nxt] = max(..., f[u][S] + (未访问过w ? val[w] : 0));
        } else {
            int nxt = (S >> (w - u)) | 1;
            f[w][nxt] = max(..., f[u][S] + (未访问过w ? val[w] : 0));
        }
    }
}
```

---

**总结**：状压DP巧妙利用范围限制，结合图的DAG性质，高效处理双指针移动问题，是本题的最优解。

---
处理用时：76.50秒
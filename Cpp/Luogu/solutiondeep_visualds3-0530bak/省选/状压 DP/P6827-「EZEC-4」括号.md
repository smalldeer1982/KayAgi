# 题目信息

# 「EZEC-4」括号

## 题目背景

> 离景似是昨日，转眼却已经年$\newline$ 往事依旧，物是全非



## 题目描述

给一个由小括号组成的序列和 $n$ 个括号串，要你在序列中匹配允许不连续的子串。

母序列的每个括号最多被匹配一次。

一种可能的不连续子串匹配方式为 ```)()(``` 中匹配 ``` ))(``` 。

每个括号串有一个值 $v$，代表对这个串每匹配一个括号得到的价值。

每个括号串均可以多次匹配，可以随时停止匹配，但是不能在未匹配完一个括号串的情况下开始匹配其他括号串。

注意如果你跳过了母序列的某几个括号去匹配后面的，那么你将不能返回前面继续进行匹配。

求匹配能得到的最大值。

## 说明/提示

【温馨提示】

**为了卡掉错解开大了数据范围，请注意常数因子对程序产生的影响。**

【数据范围】

**本题使用捆绑测试。**

对于 $100\%$ 的数据， $1 \le n \le 500, 1 \le len(k) \le 10^4, 1 \le len(a) \le 300,0 \le v \le 10^3$。

| Subtask | $ n \le$ | $ len(k) \le$ | $ len(a) \le$ |   时间 | 分值|特殊性质 |
| :----------: | :----------: | :----------: | :----------: |:----------: | :----------: |:----------: |
| $1$ | $10$ | $7$| $7$ | $1\text s$ |$5$|保证最优解每个 a 最多只用一次 |
| $2$ | $10$ | $50$| $8$| $1\text s$|$5$|数据随机，若 AC subtask3 则不计入总分|
| $3$ | $10$ | $1000$| $8$| $1\text s$|$10$|保证最优解每个 a 最多只用一次|
| $4$ | $100$ | $10^4$ | $8$ | $1\text s$ |$15$| 无 |
| $5$ | $500$ | $10^4$ | $8$ | $1\text s$ |$10$| 无 |
| $6$ | $500$ | $10^4$ | $300$| $2.2\text s$ |$60$| 无|

【样例 $1$ 解释】

最佳方案为先匹配 ```(()``` ，后匹配 ```()()()``` （ 注意最多只能匹配到 ```()()``` ），答案为 $4\times3 + 5 \times 4 = 32$。

一种可行的匹配方法为方括号括起来的部分 ```(【(()()】)(【()】``` 。

而若先匹配 ```(()``` ，再匹配 ```()``` ，最后匹配 ```(()``` 的价值为 $4\times 3 + 2\times 2 + 4\times 3 = 28$，并非最佳方案。

注意我们不能先匹配 ```(()``` ，再匹配 ```()()()``` 中一个括号，最后匹配 ```(()``` ，因为我们可以随时停止匹配，但不能在未匹配完某个串的情况下开始匹配另一个串。

【样例 $2$ 解释】

最佳方案先匹配 ```())```，再匹配 ```()))``` 最后匹配 ```())``` （ 注意最多只能匹配到 ```()``` ）, 答案为 $9\times 3 + 7 \times 4 + 9 \times 2 = 73$。

## 样例 #1

### 输入

```
3 
((()())(()
(() 4
() 2
()()() 5```

### 输出

```
32```

## 样例 #2

### 输入

```
3
())()))()
()) 9
()() 8
())) 7```

### 输出

```
73```

# AI分析结果



---

**算法分类**  
动态规划 + 状态压缩（分块状压优化）

---

### **题解思路与核心分析**

#### **题目核心难点**
1. **不连续子串匹配**：需在母序列中找到多个不连续子串，且每个括号只能被匹配一次。
2. **多次匹配与中断规则**：每个括号串可多次匹配，但必须完整匹配或中途停止，不能切换其他串。
3. **高效状态转移**：母序列长度达 \(10^4\)，暴力枚举所有可能的子串排列不可行。

#### **题解关键思路**
1. **分块状压预处理**：
   - 将每个括号串分割为长度 \(L\)（如5）的块，每个块的括号序列转换为二进制状态（0表示 `(`，1表示 `)`）。
   - 预处理每个块在母序列中的可能跳跃位置。例如，对块状态 \(j\)，预处理从位置 \(i\) 开始匹配该块的结束位置。
2. **动态规划转移**：
   - 定义 \(dp[i]\) 表示匹配到母序列第 \(i\) 个位置前的最大价值。
   - 对每个位置 \(i\)，枚举所有括号串的分块，利用预处理状态快速跳跃，剩余部分暴力匹配。

#### **解决难点对比**
| 方法               | 预处理复杂度       | 匹配复杂度           | 适用数据范围       |
|--------------------|-------------------|---------------------|-------------------|
| 全排列枚举         | \(O(1)\)          | \(O(na^a)\)         | 极小数据（\(a \le 8\)）|
| 分块状压           | \(O(k + \sqrt{a}2^{\sqrt{a}}k)\) | \(O(nk\sqrt{a})\) | 大规模数据（\(a \le 300\)）|
| 纯暴力转移         | \(O(k)\)          | \(O(nk^2)\)         | 小规模数据（\(a \le 8\)）|

#### **精炼结论**
- **最优方法**：分块状压预处理 + 动态规划，平衡状态数与计算量。
- **核心变量**：
  - `nxt[0/1][i]`：母序列中位置 \(i\) 后最近的 `(` 或 `)` 的位置。
  - `pre[i][j]`：从位置 \(i\) 开始匹配块状态 \(j\) 的结束位置。
  - `dp[i]`：动态规划状态，记录当前位置的最大价值。

---

### **题解评分 (4.5星)**

- **思路清晰度**：★★★★☆  
  分块状压思路巧妙，但代码实现较复杂。
- **优化程度**：★★★★★  
  结合分块与状压，显著降低时间复杂度。
- **可读性**：★★★☆☆  
  代码结构稍显复杂，但注释和预处理逻辑清晰。

---

### **最优技巧提炼**
1. **分块状压**：将长串拆分为固定长度的块，预处理每个块的状态转移。
2. **跳跃匹配**：利用预处理结果快速跳过已匹配的块，减少重复计算。
3. **动态规划状态压缩**：仅维护当前位置的 \(dp[i]\)，避免多维状态爆炸。

---

### **类似题目推荐**
1. **洛谷 P1040**（加分二叉树）：区间动态规划，预处理最优子结构。
2. **洛谷 P1273**（有线电视网）：树形动态规划，结合状态压缩。
3. **LeetCode 32**（最长有效括号）：预处理括号匹配位置，动态规划转移。

---

### **可视化设计**
#### **动画演示方案**
1. **分块跳跃可视化**：
   - **母序列**显示为颜色序列，当前处理块高亮为红色。
   - **预处理块状态**：用二进制数显示块状态，匹配成功时播放“跳跃”动画。
   - **动态规划更新**：用绿色标记当前 \(dp[i]\) 最大值的变化。
2. **复古像素风格**：
   - **像素网格**：母序列和块用 8x8 像素方块表示，括号类型用颜色区分。
   - **音效**：匹配成功时播放 8-bit 音效，块跳跃时播放短促提示音。
3. **交互控制**：
   - **步进按钮**：手动控制算法执行步骤。
   - **速度调节**：拖动条调整动画速度。

#### **关键代码片段（预处理跳跃）**
```cpp
for (int i = k; i > 0; i--) {
    nxt[0][i] = (s[i-1] == '(') ? i : nxt[0][i+1];
    nxt[1][i] = (s[i-1] == ')') ? i : nxt[1][i+1];
}
```

---

### **个人心得摘录**
- **调试教训**：预处理块状态时需严格处理边界条件，否则跳跃位置错误。
- **优化顿悟**：分块长度 \(L=5\) 平衡了状态数（\(2^5=32\)）与跳跃效率。

---

### **完整代码实现**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 505, MAXK = 1e4+5, L = 5;
int n, v[MAXN], nxt[2][MAXK], dp[MAXK], k, pre[MAXK][1<<L], num[MAXN], cor[MAXN][305/L+1], ans;
string s, a[MAXN];

int solve(int pos, int num, int val) {
    while (true) {
        int now = (num >> val) & 1;
        if (!nxt[now][pos]) return 0;
        if (val == 0) return nxt[now][pos];
        pos = nxt[now][pos] + 1; val--;
    }
}

int get(int pos, int f, int t) {
    int re = 0;
    for (int i = f; i <= t; i++)
        re += ((a[pos][i] == '(') ? 0 : 1) * (1 << (t - i));
    return re;
}

void jump(int pos, int ptr, int cnt, int sum, int from) {
    if (cnt > a[pos].length()) {
        dp[ptr] = max(dp[ptr], dp[from] + sum);
        return;
    }
    while (cnt <= a[pos].length()) {
        int now = (a[pos][cnt-1] == ')');
        if (!nxt[now][ptr]) { ans = max(ans, dp[from] + sum); return; }
        ptr = nxt[now][ptr] + 1, sum += v[pos];
        cnt++;
    }
    if (ptr != -1) dp[ptr] = max(dp[ptr], dp[from] + sum);
    ans = max(ans, dp[from] + sum);
}

void Solve(int kk, int pos) {
    int re = 0, from = kk, cnt = 1;
    for (int i = 1; i <= num[pos]; i++) {
        if (pre[kk][cor[pos][i]]) {
            kk = pre[kk][cor[pos][i]] + 1;
            re += L * v[pos];
            cnt += L;
        } else break;
    }
    jump(pos, kk, cnt, re, from);
}

int main() {
    cin >> n >> s;
    k = s.length();
    for (int i = 1; i <= n; i++) cin >> a[i] >> v[i];
    for (int i = 1; i <= n; i++) {
        num[i] = a[i].length() / L;
        for (int l = 1; l <= num[i]; l++)
            cor[i][l] = get(i, L*(l-1), L*l-1);
    }
    for (int i = k; i > 0; i--) {
        nxt[0][i] = (s[i-1] == '(') ? i : nxt[0][i+1];
        nxt[1][i] = (s[i-1] == ')') ? i : nxt[1][i+1];
    }
    for (int i = 1; i <= k; i++)
        for (int j = 0; j < (1 << L); j++)
            pre[i][j] = solve(i, j, L-1);
    for (int i = 1; i <= k; i++)
        for (int j = 1; j <= n; j++)
            Solve(i, j);
    cout << ans << endl;
    return 0;
}
```

---
处理用时：83.74秒
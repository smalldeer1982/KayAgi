# 题目信息

# 「EZEC-10」Equalization

## 题目描述

给你一个长为 $n$ 的数组 $a_1,a_2,\ldots,a_n$。

你可以任选三个整数 $l,r,x\ (1\le l\le r\le n$，$x\in \mathbb Z)$，并将 $a_l,a_{l+1},\ldots,a_r$ 均加上 $x$，称为一次操作。

问最少进行几次操作，才能使 $a$ 中所有元素均相等？并求出能使操作次数最少的不同方案数。

由于方案数可能很大，请对 $10^9+7$ 取模。

**两种方案相同，当且仅当两方案每次操作选择的 $(l,r,x)$ 均相同。**

**特别地，不进行任何操作也算一种方案。**

## 说明/提示

**【样例 1 解释】**

一种可行的方案为：$(l,r,x)=(1,1,1),(3,3,-1)$。

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（1 point）：$n=2$。
-  Subtask 2（5 points）：$n=3$。
-  Subtask 3（14 points）：保证 $a$ 单调不升或单调不降。
-  Subtask 4（20 points）：$n\le 10$。
-  Subtask 5（20 points）：$n\le 16$。
-  Subtask 6（40 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le n\le 18$，$-10^9\le a\le 10^9$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
2
16```

# AI分析结果



**唯一算法分类**：状压DP

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **差分转换**：将原数组转换为差分数组，区间加操作转化为单点或双点修改。
2. **连通块划分**：将差分数组的元素划分为若干和为0的连通块，最小操作次数为 `n-1 - 最大连通块数`。
3. **状压DP**：枚举子集，动态规划求解最大连通块数及对应方案数。
4. **方案数计算**：利用Prufer序列计算树结构的方案数，结合自环处理（需乘系数）。

#### **解决难点**
- **连通块性质**：和为0的连通块对应树结构，非零和需额外自环操作。
- **状态转移**：状压DP枚举子集，维护最大分组数及方案数的乘积关系。
- **复杂度优化**：通过预处理子集和、快速幂优化计算，将复杂度控制在 `O(3^{n-1})`。

---

### **题解评分 (≥4星)**

1. **tzc_wk（4.5星）**  
   - **亮点**：详细推导连通块性质，结合Prufer序列计算方案数，代码清晰高效。  
   - **代码实现**：预处理幂次与阶乘，高效枚举子集转移。

2. **Ecrade_（4星）**  
   - **亮点**：分A/B状态讨论，动态规划转移逻辑清晰，方案数乘法原理运用合理。  
   - **不足**：代码实现较复杂，部分转移可能重复计算。

3. **IdnadRev（4星）**  
   - **亮点**：代码简洁，直接点明连通块与树的关系，快速幂优化方案数计算。  
   - **不足**：解释较简略，适合已有基础的读者。

---

### **最优思路或技巧提炼**

1. **差分转换**：区间加操作转化为差分数组的单点或双点修改，简化问题。
2. **状压DP枚举子集**：将元素划分为和为0的连通块，动态规划求最优分组。
3. **Prufer序列计算树方案数**：每个连通块对应无根树，方案数为 `k^{k-2}`。
4. **自环处理**：非零和连通块需额外自环操作，方案数乘 `2k`。

---

### **同类型题或算法套路**

- **差分数组应用**：如区间修改、求最终数组的问题。
- **状压DP划分子集**：如背包问题、覆盖问题。
- **树计数与Prufer序列**：如生成树计数、连通块方案数计算。

**推荐题目**：  
1. P6775（[NOI2020] 美食家）  
2. P2831（[NOIP2016] 愤怒的小鸟，状压DP）  
3. P1354（树的同构，Prufer序列应用）

---

### **个人心得摘录**

- **tzc_wk**：强调操作集合与树的双射关系，通过构造操作顺序唯一性证明方案数正确性。
- **Ecrade_**：调试时发现需避免重复计算子集，引入标记优化转移过程。

---

### **可视化与算法演示**

**核心算法流程**：  
1. **差分转换**：原数组 → 差分数组，高亮区间操作对应的差分修改点。  
2. **连通块划分**：用不同颜色标记各子集，动态展示状压DP的枚举与合并。  
3. **树结构生成**：以动画形式生成Prufer序列，展示边权唯一确定过程。  

**复古游戏化设计**：  
- **像素风格**：用16色网格展示差分数组，连通块以不同颜色方块表示。  
- **音效**：操作成功时播放8位音效，错误时短促“哔”声。  
- **自动演示**：AI逐步枚举子集，高亮当前操作块，显示分组数与方案数。  

**交互功能**：  
- **步进控制**：暂停/继续/单步执行，调节动画速度。  
- **状态面板**：显示当前分组数、剩余操作次数、方案数乘积。  

---

### **代码片段（核心逻辑）**

**状压DP转移（tzc_wk）**  
```cpp
for(register int i=0;i<(1<<m);i++){
    register int rst=((1<<m)-1)^i;
    for(register int j=rst;j;j=(j-1)&rst){
        if(high(j)<high(i)) break;
        (!sum[j])?upd(dp[i|j],dp[i],cnt[j]-1,g[cnt[j]]):
        upd(dp[i|j],dp[i],cnt[j],f[cnt[j]]);
    }
}
```

**方案数计算（IdnadRev）**  
```cpp
int ksm(int a,int b) { /* 快速幂 */ }
// 预处理连通块方案数
v1[i] = ksm(i, i-2);      // 树方案数
v2[i] = 2 * i * v1[i] % mod; // 自环方案数
```

---

**可视化代码示例（伪代码）**  
```javascript
// 像素动画：差分数组与连通块
function drawGrid(diffArray) {
    ctx.fillStyle = "#8B00FF"; // 紫色背景
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    diffArray.forEach((val, idx) => {
        ctx.fillStyle = val === 0 ? "#00FF00" : "#FF4500"; // 绿色为0，橙色非0
        ctx.fillRect(idx * 20, 50, 18, 18);
    });
}
// 播放音效
function playSound(effect) {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = effect === "success" ? 880 : 220;
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

---
处理用时：73.72秒
# 题目信息

# [THUPC 2023 决赛] 老虎机

## 题目描述

小 I 经营着一个电玩城，最近引进的新型老虎机深受欢迎。

作为经营者，小 I 首先需要设定老虎机的状态。老虎机的状态为一个三元组 $(l,S,\mathbf{p})$，其中

- $l$ 是一个正整数；
- $S$ 是一个非空字符串集合，其中所有的字符串均是长度为 $l$ 的 01 串；
- $\mathbf{p}$ 是一个长度为 $l$ 的实数序列 $p_0,p_1,\dots,p_{l-1}$，其中对于任意 $0 \le i \le l - 1$，$0 < p_i \le 1$。

设定好状态后即可开始游戏。每一轮游戏的流程如下：

- 玩家首先获得老虎机的状态 $(l,S,\mathbf{p})$。
- 老虎机内部选择一个串 $s \in S$ 作为答案串，玩家需要通过与老虎机进行若干次交互得到答案串。
  - 每一次交互中，玩家投入一个游戏币并拉下老虎机的拉杆，然后老虎机的界面中会出现一个长度为 $l$ 的信息串 $t$。对于 $0 \le i \le l - 1$，$t_i$ 有 $p_i$ 的概率为 $s_i$，有 $(1-p_i)$ 的概率为 `?`。
  - 交互过程中生成信息串进行的所有随机过程两两独立。
- 当玩家可以根据**老虎机的状态和交互得到的若干信息串**唯一确定答案串后，即可将答案串输入老虎机并结束游戏、获得奖励。

小 I 设定好了一个状态，但还不知道设定多少奖励。为了让奖励和难度匹配，小 I 想知道：对于 $S$ 中的每个串 $t$，在玩家以最优策略游玩（即一旦可以唯一确定答案串就结束游戏）的情况下，若答案串为 $t$，玩家期望需要投入多少游戏币。

由于小 I 不喜欢实数，你需要将答案对 $998244353$ 取模。

## 说明/提示

**【样例解释 #1】**

- 对于第一组测试数据，每一次交互有 $\frac{5000}{10000} = \frac{1}{2}$ 的概率知道答案串是 $0$ 还是 $1$，有 $\frac{1}{2}$ 的概率不能获得信息，因此期望游戏币数为 $\sum_{i=1}^{+\infty} \frac{i}{2^i} = 2$。
- 对于第二组测试数据，每一次交互都可以得到字符串的第二位，有 $\frac{1}{10000}$ 的概率得到字符串的第一位。第二个字符串为答案串时可以通过字符串的第二位唯一确定，而其他两个字符串为答案串时必须要得到字符串的第一位。
- 对于第三组测试数据，由于 $|S| = 1$，所以不需要任何交互就可以确定答案串。
- 对于第四组测试数据，我有一个绝妙的解释，可这里空间太小写不下。

**【数据范围】**

对于所有测试数据，$1 \le T \le 10$，$1 \le l \le 15$，$1 \le n \le 2^l$，$1 \le c_i \le 10^4$，$s_1,\dots,s_n$ 为两两不同的长度为 $l$ 的 01 串。

**【后记】**

“喂喂喂，未成年人不准进入电玩城！什么？你们说你们要进去学算法竞赛？谁信你的鬼话！”

**【题目来源】**


来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 [https://github.com/THUSAAC/THUPC2023](https://github.com/THUSAAC/THUPC2023) 查看。

## 样例 #1

### 输入

```
4
1 2
5000
0
1
2 3
1 10000
00
01
10
1 1
1
1
3 4
8888 7777 5555
000
010
101
110
```

### 输出

```
2
2
10000
1
10000
0
209031157
194428714
835313860
674719626
```

# AI分析结果



---

**唯一算法分类**：期望DP与状态压缩

---

### 综合分析与结论

#### 核心算法流程
1. **状态表示**：用三进制数表示每位状态（0/1/?），用二进制压缩已知位集合
2. **期望拆分**：将总期望拆分为各非终止状态的概率 × 停留时间的总和
3. **状态转移**：
   - 预处理每个状态的概率乘积 $f_S$ 和停留概率 $g_S$
   - 通过超集DP进行状态转移，时间复杂度优化至 $\mathcal{O}(3^l)$
4. **唯一性判定**：
   - 对每个三进制状态，递归展开最低位的?判断唯一性
   - 使用lowbit技巧快速定位可展开位

#### 可视化设计思路
1. **像素化状态网格**：
   - 用16色像素块表示每个位的三种状态：绿色（确定0）、红色（确定1）、灰色（?）
   - 每次操作后更新对应位的颜色，伴随8-bit音效
2. **自动演示模式**：
   - 按位展开顺序自动演示状态转移
   - 关键步骤触发"哔"声提示，合法状态出现时播放通关音效
3. **对比视图**：
   - 左半区展示二进制压缩的已知位集合
   - 右半区展示三进制的完整状态表示
   - 高亮当前操作的位（闪烁黄色边框）

---

### 题解评分与亮点（≥4星）

1. **Alex_Wei（⭐⭐⭐⭐⭐）**
   - 亮点：严谨的数学推导，创新性的补集转换技巧
   - 关键代码：超集DP优化实现，复杂度 $\mathcal{O}(3^l)$
2. **__stick（⭐⭐⭐⭐）**
   - 亮点：高效的三进制lowbit处理，代码结构清晰
   - 调试心得：通过反向验证发现状态合并条件错误
3. **tzl_Dedicatus545（⭐⭐⭐）**
   - 亮点：形象的图论转化视角，启发式思考路径

---

### 最优思路与技巧

**关键技巧**：
1. **期望线性拆分**：$\mathbb{E} = \sum_{非法状态} P_S \cdot t_S$
2. **概率预处理**：
   ```math
   p_S = \prod_{i∈S}(1-p_i), \quad t_S = \frac{1}{1-p_S}
   ```
3. **三进制lowbit加速**：$O(1)$时间找到最低未知位
4. **状态唯一性递推**：通过子状态合并判断当前状态是否确定唯一串

**代码核心逻辑**：
```cpp
// 三进制状态处理
for(int s=0;s<po[L];s++) {
    if(~lowbit[s]) { // 存在未知位
        int u = id[s-po[lowbit]]; // 设为0的子状态
        int v = id[s-2*po[lowbit]]; // 设为1的子状态
        id[s] = (u == v) ? u : -1; // 合并判断唯一性
    }
    if(id[s] > 0) // 该状态能确定唯一串
        ans[id[s]] += val[rev[s]^mask]; // 累加贡献
}
```

---

### 相似题目推荐
1. **P2473 [SCOI2008] 奖励关**（期望DP+状态压缩）
2. **P4363 [九省联考 2018] 一双木棋**（状态压缩博弈）
3. **P3226 [HNOI2012] 集合选数**（状态压缩+数学构造）

---

### 可视化演示方案
**动画流程**：
1. **初始化**：展示空状态（全灰）和概率分布
2. **单次操作**：
   - 随机生成信息串（带粒子动画）
   - 更新已知位集合（对应位变色+音效）
3. **状态判定**：
   - 当状态变为合法时，触发闪光特效
   - 展示当前所有可能候选串的排除过程
4. **统计面板**：
   - 实时显示当前期望值计算过程
   - 高亮当前贡献最大的状态

**交互设计**：
- 速度调节：1x/2x/5x三种速度档位
- 回放功能：任意步骤后退观察状态变化
- 对比模式：并行展示两种算法的状态转移差异

---

通过将复杂的期望计算转化为状态空间的高效遍历，结合三进制状态压缩与数学推导，该解法在合理的时间复杂度内解决了指数级状态空间问题。可视化设计通过分层展示状态转移与期望计算过程，帮助理解算法核心思想。

---
处理用时：55.92秒
# 题目信息

# 最大子树和

## 题目描述

小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：

一株奇怪的花卉，上面共连有 $N$ 朵花，共有 $N-1$ 条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。

老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。

## 说明/提示

### 数据范围及约定

- 对于 $60\%$ 的数据，有 $1\le N\le 1000$；
- 对于 $100\%$ 的数据，有 $1\le N\le 16000$。

## 样例 #1

### 输入

```
7
-1 -1 -1 1 1 1 0
1 4
2 5
3 6
4 7
5 7
6 7
```

### 输出

```
3```

# AI分析结果



**唯一算法分类**: 树形动态规划

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
题目要求从树中选出连通子树，使点权和最大。树形DP的核心在于：
- **状态定义**: `f[u]` 表示以 `u` 为根的子树中，包含 `u` 的最大子权和。
- **转移方程**: `f[u] = a[u] + Σ max(0, f[v])`，其中 `v` 是 `u` 的子节点。若子树的贡献 `f[v]` 非负，则保留该子树；否则剪枝。
- **最终答案**: 所有 `f[i]` 中的最大值。

#### **解决难点**
1. **树的无根性**: 通过任意选根（如节点1）转化为有根树，递归处理子树。
2. **负权处理**: 仅累加正贡献的子节点，避免总和减小。
3. **高效计算**: 单次DFS遍历即可完成所有状态更新，时间复杂度O(n)。

#### **算法对比**
- **单一数组法**（Mutsumi_0114）: 仅维护 `f[u]`，遍历所有节点取最大值，代码简洁高效。
- **双数组法**（FCBM71）: 引入 `fn[i]` 记录不包含 `i` 的最大值，但最终仍需比较所有 `f[i]`，未显著优化。
- **错误尝试**（StoneXie）: 初始暴力枚举所有根节点导致超时，后修正为记忆化搜索，强调避免重复计算。

---

### **题解评分（≥4星）**

1. **Mutsumi_0114（5星）**
   - **亮点**: 代码简洁，思路清晰，直接命中核心算法，适合快速理解。
   - **代码片段**:
     ```cpp
     void dfs(int u, int fa) {
         f[u] = a[u];
         for (int v : E[u]) {
             if (v == fa) continue;
             dfs(v, u);
             if (f[v] > 0) f[u] += f[v];
         }
     }
     ```

2. **tribool4_in（4星）**
   - **亮点**: 使用二维状态 `dp[u][0/1]` 分别表示包含/不包含根的情况，提供另一种视角。
   - **代码片段**:
     ```cpp
     void dfs(int u, int fa) {
         dp[u][1] = a[u];
         for (int v : G[u]) {
             if (v == fa) continue;
             dfs(v, u);
             dp[u][0] = max({dp[u][0], dp[v][0], dp[v][1]});
             dp[u][1] = max(dp[u][1], dp[u][1] + dp[v][1]);
         }
     }
     ```

3. **traceson（4星）**
   - **亮点**: 强调贪心思想，代码中全局变量 `ans` 实时更新最大值，减少最后遍历。

---

### **最优思路与技巧提炼**

- **关键技巧**: 树形DP中，通过后序遍历（DFS）自底向上汇总子树贡献，仅保留正收益。
- **思维角度**: 将问题拆解为每个节点的局部最优解，全局最优解必然由某个局部解构成。
- **调试心得**（StoneXie）: 初始错误枚举所有根节点导致超时，后通过记忆化搜索优化，强调避免重复计算的重要性。

---

### **同类型题与算法套路**

- **类似题目**:
  1. **P1352 没有上司的舞会**: 树形DP，选择节点时父子不可共存。
  2. **P2015 二叉苹果树**: 保留指定数量的边，最大化边权和。
  3. **P2014 选课**: 树形背包问题，限制子树节点数。

- **通用套路**: 
  - **状态设计**: 以子树为单位定义状态，包含根节点。
  - **转移策略**: 累加正贡献，剪枝负贡献，避免全局遍历。

---

### **可视化与算法演示**

#### **核心算法动画设计**
- **树形结构展示**: 以像素风格绘制树，节点颜色深浅表示 `f[u]` 大小。
- **高亮操作**:
  - **递归进入节点**: 节点闪烁黄色，显示当前计算对象。
  - **子节点贡献判断**: 正贡献显示绿色箭头，负贡献显示红色叉号。
  - **结果回传**: 回溯时更新父节点颜色，播放“叮”音效。

#### **复古像素风格实现**
- **Canvas 绘制**:
  ```javascript
  function drawNode(x, y, value) {
      ctx.fillStyle = value > 0 ? '#8BC34A' : '#FF5722';
      ctx.fillRect(x, y, 30, 30); // 节点为30x30像素方块
      ctx.fillStyle = '#000';
      ctx.fillText(value, x + 5, y + 20);
  }
  ```
- **音效设计**:
  - **正贡献**: 播放短促“哔”声（Web Audio API生成500Hz方波）。
  - **负贡献**: 静音或低沉“嗡”声（200Hz方波）。

#### **自动演示模式**
- **AI 控制**: 按DFS顺序自动遍历节点，步进间隔1秒，可暂停/加速。
- **关卡积分**: 每正确计算一个节点得10分，连续正确触发连击特效。

---

### **推荐题目**
1. **P1352** - 树形DP基础
2. **P2014** - 树形背包问题
3. **P3177** - 树上路径统计

---

**总结**：最大子树和问题通过树形DP高效解决，关键在于状态转移时仅累加正贡献。可视化设计通过像素动画和音效增强理解，适用于教学与算法演示。

---
处理用时：71.74秒
# 题目信息

# [NOI2015] 寿司晚宴

## 题目描述

为了庆祝 NOI 的成功开幕，主办方为大家准备了一场寿司晚宴。小 G 和小 W 作为参加 NOI 的选手，也被邀请参加了寿司晚宴。

在晚宴上，主办方为大家提供了 $n−1$ 种不同的寿司，编号 $1,2,3,\ldots,n-1$，其中第 $i$ 种寿司的美味度为 $i+1$。（即寿司的美味度为从 $2$ 到 $n$）

现在小 G 和小 W 希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小 G 品尝的寿司种类中存在一种美味度为 $x$ 的寿司，小 W 品尝的寿司中存在一种美味度为 $y$ 的寿司，而 $x$ 与 $y$ 不互质。

现在小 G 和小 W 希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数 $p$ 取模）。注意一个人可以不吃任何寿司。


## 说明/提示

【数据范围】


 ![](https://cdn.luogu.com.cn/upload/pic/1506.png) 


**勘误：$0 < p \le 10^9 $**

## 样例 #1

### 输入

```
3 10000```

### 输出

```
9```

## 样例 #2

### 输入

```
4 10000```

### 输出

```
21```

## 样例 #3

### 输入

```
100 100000000```

### 输出

```
3107203```

# AI分析结果



# 算法分类：状态压缩动态规划（状压DP）

---

## 题解思路与核心难点

### **核心思路**
- **质因数分组策略**：每个数最多有一个大于$\sqrt{500}$的质因数（称为大质数），其余为小质数（共8个）。将数按大质数分组，每组只能全分给甲或乙。
- **状态压缩**：用8位二进制表示小质数的选择状态。
- **分组处理**：对每个大质数组维护两个状态数组`f1`和`f2`，分别表示该组分配给甲或乙的方案数，最后合并时减去重复计数。

### **解决难点**
1. **大质数处理**：同一大质数组的数必须分到同一集合，需在状态转移时保证不冲突。
2. **状态合并**：合并`f1`和`f2`时需减去初始状态的重复计数（两数组未选该组的情况）。
3. **滚动数组优化**：通过倒序遍历状态避免覆盖，节省空间。

---

## 题解评分（≥4星）

1. **Orion545（5星）**
   - **亮点**：清晰的分组策略，利用排序优化状态转移，代码高效。
   - **关键代码**：通过`memcpy`快速复制状态数组，倒序更新避免冲突。

2. **翼德天尊（5星）**
   - **亮点**：详细解释大质数分组逻辑，状态转移过程图示化。
   - **代码特点**：结构简洁，使用`bitand`优化位运算。

3. **ethan_zhou（4.5星）**
   - **亮点**：提出$O(n \times 3^8)$优化，利用容斥简化计算。
   - **不足**：代码可读性稍弱，需结合注释理解。

---

## 最优思路与技巧提炼

### **关键步骤**
1. **预处理质因数**：分解每个数的质因数，记录小质数状态和大质数。
2. **分组排序**：按大质数排序，同一组的数连续处理。
3. **状态转移**：
   - **小质数**：状压判断是否冲突。
   - **大质数组**：维护`f1`（分给甲）和`f2`（分给乙）的独立转移。
4. **合并结果**：`f = f1 + f2 - f`，避免重复计数。

### **核心代码逻辑**
```cpp
for (int i = 2; i <= n; ++i) {
    if (大质数变化) {
        memcpy(f1, dp, sizeof(f1)); // 复制初始状态
        memcpy(f2, dp, sizeof(f2));
    }
    // 更新f1和f2
    for (int j = 255; j >= 0; --j) {
        for (int k = 255; k >= 0; --k) {
            if (j & k) continue;
            if (可分配给甲) f1[j | s][k] += f1[j][k];
            if (可分配给乙) f2[j][k | s] += f2[j][k];
        }
    }
    // 合并结果
    if (大质数组结束) {
        for (int j = 0; j <= 255; ++j) {
            for (int k = 0; k <= 255; ++k) {
                dp[j][k] = (f1[j][k] + f2[j][k] - dp[j][k]) % mod;
            }
        }
    }
}
```

---

## 同类型题目与推荐

### **类似算法套路**
- **质因数分组+状压DP**：处理质数约束的分组问题，如互质集合划分。
- **滚动数组优化**：减少空间复杂度，适用于多维状态压缩。

### **推荐题目**
1. **P2704 [NOI2001]炮兵阵地**：状压DP处理相邻约束。
2. **P3226 [HNOI2012]集合选数**：质因数分组的集合划分。
3. **P2153 [SDOI2009]学校食堂**：状态压缩处理多维约束。

---

## 可视化算法演示设计

### **核心流程**
1. **质因数分解展示**：每个数以不同颜色块表示小质数，右侧标注大质数。
2. **分组高亮**：同大质数组用相同背景色标记，动态显示分配过程。
3. **状态转移动画**：
   - **步骤1**：当前数的小质数状态高亮（如红色块）。
   - **步骤2**：尝试分配给甲（左侧网格更新）或乙（右侧网格更新）。
   - **步骤3**：冲突时闪烁提示，有效转移则颜色渐变。

### **复古像素风格**
- **UI设计**：8-bit风格网格，每个状态用16x16像素块表示，背景音乐为芯片音乐。
- **音效**：
  - **分配成功**：8-bit“滴”声。
  - **冲突**：短促“哔”声。
- **自动演示**：按步骤自动运行，可暂停/加速。

---

## 个人心得摘录

- **调试教训**：合并状态时忘记取模导致负数，需`(a + b - c) % mod + mod) % mod`。
- **优化技巧**：倒序更新状态避免覆盖，节省一倍空间。
- **思维突破**：大质数分组的独立性是解题关键，将问题拆解为多个子问题。

---

通过上述分析，本题的核心在于巧妙利用质因数特性进行分组，结合状压DP高效处理状态转移，是质因数分解与动态规划的经典结合。

---
处理用时：65.34秒
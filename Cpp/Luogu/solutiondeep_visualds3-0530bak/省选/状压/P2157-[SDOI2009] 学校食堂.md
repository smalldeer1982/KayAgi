# 题目信息

# [SDOI2009] 学校食堂

## 题目描述

小 F 的学校在城市的一个偏僻角落，所有学生都只好在学校吃饭。学校有一个食堂，虽然简陋，但食堂大厨总能做出让同学们满意的菜肴。当然，不同的人口味也不一定相同，但每个人的口味都可以用一个非负整数表示。 由于人手不够，食堂每次只能为一个人做菜。做每道菜所需的时间是和前一道菜有关的，若前一道菜的对应的口味是 $a$，这一道为 $b$，则做这道菜所需的时间为 $(a\operatorname{or}b)-(a\operatorname{and}b)$，而做第一道菜是不需要计算时间的。其中，$\operatorname{or}$ 和 $\operatorname{and}$ 表示整数逐位或运算及逐位与运算，C 语言中对应的运算符为 `|` 和 `&`。


学生数目相对于这个学校还是比较多的，吃饭做菜往往就会花去不少时间。因此，学校食堂偶尔会不按照大家的排队顺序做菜，以缩短总的进餐时间。

虽然同学们能够理解学校食堂的这种做法，不过每个同学还是有一定容忍度的。也就是说，队伍中的第 $i$ 个同学，最多允许紧跟他身后的 $B_i$ 个人先拿到饭菜。一旦在此之后的任意同学比当前同学先拿到饭，当前同学将会十分愤怒。因此，食堂做菜还得照顾到同学们的情绪。 现在，小 F 想知道在满足所有人的容忍度这一前提下，自己的学校食堂做完这些菜最少需要多少时间。


## 说明/提示

对于第一组数据：

同学 1 允许同学 2 或同学 3 在他之前拿到菜；同学 2 允许同学 3 在他之前拿到菜；同学 3 比较小气，他必须比他后面的同学先拿菜。

一种最优的方案是按同学 3、同学 2、同学 1、同学 4、同学 5 做菜，每道菜所需的时间分别是 0、8、1、6 及 1。


**数据规模和约定**

- 对于 $30\%$ 的数据，满足 $1 \le N \le 20$。

- 对于 $ 100\% $ 的数据，满足 $1 \le N \le 1000,0 \le T_i \le 1000,0 \le B_i \le 7，1 \le C \le 5$。

- 存在 $30\%$ 的数据，满足 $0 \le B_i \le 1$。

- 存在 $65\%$ 的数据，满足 $0 \le B_i \le 5$。

- 存在 $45\%$ 的数据，满足 $0 \le T_i \le 130$。


## 样例 #1

### 输入

```
2
5
5 2
4 1
12 0
3 3
2 2
2
5 0
4 0```

### 输出

```
16
1
```

# AI分析结果



# 题解分析：SDOI2009 学校食堂

**唯一算法分类**：状压动态规划（状压DP）

---

## **题解思路与算法要点**
### **核心思路**
所有题解均采用**状压DP**解决。关键点在于：
1. **状态定义**：`dp[i][j][k]`表示前`i-1`人已处理，`i`及后7人的状态为`j`（二进制掩码），上一个打饭的人相对`i`的位置为`k`（偏移处理负数）。
2. **状态转移**：
   - **已打饭**（`j&1`）：转移到`i+1`，状态右移。
   - **未打饭**：枚举后续可打饭的人，维护容忍度限制。

### **解决难点**
- **容忍度处理**：当选择第`i+h`人时，需确保所有未打饭的人容忍该选择。通过维护变量`lir`（当前允许的最远位置）剪枝。
- **负数偏移**：`k`的范围为`[-8,7]`，代码中通过`+8`避免负数下标。

---

## **题解评分 (≥4星)**
1. **xyz32768 (5星)**  
   - **亮点**：详细解释状态转移逻辑，代码结构清晰，变量命名规范，注释明确。
   - **代码示例**：
     ```cpp
     if (j & 1) // 已打饭，直接转移
         f[i+1][j>>1][k-1] = min(f[i+1][j>>1][k-1], f[i][j][k]);
     else {
         int lir = INF; // 维护容忍度限制
         for (h=0; h<=7; h++) if (!(j>>h &1)) {
             if (i+h > lir) break;
             lir = min(lir, i+h + B[i+h]);
             f[i][j|(1<<h)][h+8] = ...;
         }
     }
     ```

2. **Coros_Trusds (4.5星)**  
   - **亮点**：明确异或性质简化时间计算，代码可读性强，状态转移高效。
   - **关键代码**：
     ```cpp
     int TM(int x, int y) { return x ^ y; } // 异或替代原式
     ```

3. **Code_星云 (4星)**  
   - **亮点**：代码简洁，使用位运算优化状态处理，适合快速理解核心逻辑。

---

## **最优思路提炼**
1. **状态压缩**：用8位二进制数表示后7人的打饭状态。
2. **动态规划转移**：分情况处理已打饭/未打饭，维护容忍度限制剪枝。
3. **偏移处理**：`k`用`+8`避免负数下标，简化数组操作。

---

## **同类型题推荐**
1. **P1879 [Corn Fields]**：状压DP处理网格种植问题。
2. **P2831 [愤怒的小鸟]**：状态压缩优化抛物线覆盖。
3. **P2167 [Bill的挑战]**：状压处理字符串匹配条件。

---

## **可视化与算法演示**
### **核心算法流程**
1. **初始化**：`dp[1][0][7] = 0`（偏移后为`k=7`对应`-1`）。
2. **状态转移**：
   - **步骤1**：若当前状态`j`的最低位为1，转移到`i+1`，状态右移。
   - **步骤2**：若未打饭，枚举后续可打饭的人，更新`lir`并转移。
3. **结果提取**：遍历`dp[n+1][0][k]`的最小值。

### **复古像素化设计**
- **颜色标记**：
  - 绿色：已打饭同学。
  - 红色：当前处理的位置`i`。
  - 闪烁黄色：上一个打饭的人。
- **音效**：转移时播放8位“滴”声，找到最优解时播放胜利音效。
- **Canvas动画**：网格显示同学队列，状态掩码实时更新，时间消耗动态显示。

### **交互功能**
- **步进控制**：按钮控制执行速度，单步观察状态变化。
- **自动演示**：AI模式展示最优路径选择，高亮剪枝过程。

---

## **代码片段（核心逻辑）**
```cpp
// 状态转移核心代码（xyz32768题解）
for (int i=1; i<=n; ++i) {
    for (int j=0; j<(1<<8); ++j) {
        for (int k=-8; k<=7; ++k) {
            if (dp[i][j][k+8] == INF) continue;
            if (j & 1) { // 已打饭，转移至i+1
                dp[i+1][j>>1][k+7] = min(...);
            } else { // 未打饭，枚举可打饭的人
                int limit = INF;
                for (int h=0; h<=7; ++h) {
                    if ((j >> h) & 1) continue;
                    if (i+h > limit) break;
                    limit = min(limit, i+h + b[i+h]);
                    int cost = (i+k ? t[i+k]^t[i+h] : 0);
                    dp[i][j|(1<<h)][h+8] = min(...);
                }
            }
        }
    }
}
```

---

**总结**：状压DP通过状态压缩和动态规划高效处理容忍度限制，结合剪枝优化时间复杂度至`O(N * 2^8 * 16)`，适用于`N≤1000`的规模。

---
处理用时：75.48秒
# 题目信息

# [HNOI2010] 公交线路

## 题目描述

小 Z 所在的城市有 $N$ 个公交车站，排列在一条长 $(N-1)\  \rm km$ 的直线上，从左到右依次编号为 $1$ 到 $N$，相邻公交车站间的距离均为 $1 \ \rm km$。作为公交车线路的规划者，小 Z 调查了市民的需求，决定按下述规则设计线路：

1. 设共 $K$ 辆公交车，则 $1$ 到 $K$ 号站作为始发站，$N-K+1$ 到 $N$ 号台作为终点站。
2. 每个车站必须被一辆且仅一辆公交车经过（始发站和终点站也算被经过）。
3. 公交车只能从编号较小的站台驶往编号较大的站台。
4. 一辆公交车经过的相邻两个站台间距离不得超过 $P \ \rm km$。

在最终设计线路之前，小 Z 想知道有多少种满足要求的方案。由于答案可能很大，你只需求出答案对 $30031$ 取模的结果。

## 说明/提示

【样例说明】

样例一的可行方案如下：$(1,4,7,10)$，$(2,5,8)$，$(3,6,9)$。

样例二的可行方案如下：$(1,3,5)$，$(2,4)(1,3,4)$，$(2,5)(1,4)$，$(2,3,5)$。

对于 $100 \%$ 的数据，$1 \le N \le 10^9$，$1 < P \le 10$，$K<N$，$1<K \le P$。

## 样例 #1

### 输入

```
10 3 3```

### 输出

```
1```

## 样例 #2

### 输入

```
5 2 3```

### 输出

```
3```

## 样例 #3

### 输入

```
10 2 4```

### 输出

```
81```

# AI分析结果



## 唯一算法分类
矩阵加速动态规划（状态压缩+矩阵快速幂）

---

## 综合分析与结论

### 核心思路与难点
1. **状态压缩**：将连续的P个站点覆盖情况压缩为二进制状态，每个位置1表示有公交车覆盖。状态需满足：首位为1（当前处理位置必须被覆盖），总共有K个1（保证每辆公交车存在）。
2. **状态转移**：从状态S1转移到S2时，S2需满足：将S1左移一位（模拟窗口滑动）后，通过补一个1来维持K个1的总数。转移本质是将某个公交车的覆盖位置从窗口左端移到右端。
3. **矩阵优化**：状态数由组合数C(P-1, K-1)决定（最多126种），构建状态转移矩阵后，用矩阵快速幂处理大范围的递推。

### 可视化设计
1. **像素风格状态图**：用8x8像素块表示二进制状态，绿色方块表示1，红色表示0。每次转移时高亮变化的位（旧窗口左移后补位）。
2. **矩阵动画**：展示状态转移矩阵的构建过程，当两个状态可转移时，对应矩阵位置闪烁黄色。快速幂执行时，用流线动画表现矩阵相乘过程。
3. **音效触发**：状态转移成功时播放短促"哔"声，矩阵乘法完成时播放上升音阶，错误转移（如1的数目不符）则播放低音警报。

---

## 题解清单（4星及以上）

### 1. xyz32768（⭐⭐⭐⭐⭐）
**亮点**：完整的状态定义与转移推导，清晰指出状态数为组合数，提供矩阵构建的数学证明。代码结构简洁，预处理合法状态后直接构建邻接矩阵。

### 2. TopCarry（⭐⭐⭐⭐）
**亮点**：详细解释状态压缩的合理性，通过举例说明转移的数学本质。提供矩阵乘法的循环优化技巧，代码包含高效的三层循环矩阵乘法。

### 3. bianshiyang（⭐⭐⭐⭐）
**亮点**：将问题转化为染色模型，直观解释状态含义。代码预处理合法状态时利用__builtin_popcount优化，矩阵构建逻辑清晰。

---

## 核心代码实现

### 状态预处理与矩阵构建（xyz32768思路）
```cpp
int main() {
    cin >> n >> K >> P;
    // 预处理所有合法状态（K个1且最高位为1）
    for (int i = (1 << (P-1)); i < (1 << P); i++) {
        if (__builtin_popcount(i) == K) 
            sta[++tot] = i;
    }
    // 构建转移矩阵
    for (int i = 1; i <= tot; i++) {
        int S1 = sta[i];
        for (int j = 1; j <= tot; j++) {
            int S2 = sta[j];
            int shifted = (S1 - (1 << (P-1))) << 1;
            if ((shifted & S2) == shifted && __builtin_popcount(S2 ^ shifted) == 1)
                Orz.a[j][i] = 1;
        }
    }
    // 矩阵快速幂
    Zzq.a[tot][1] = 1;
    Orz = (Orz ^ (n - K)) * Zzq;
    cout << Orz.a[tot][1];
}
```

### 矩阵乘法优化（TopCarry思路）
```cpp
node operator * (node x, node y) {
    node now;
    for (k=1; k<=len; k++) // k循环提到最外层
        for (i=1; i<=len; i++) 
            if (x.maps[i][k]) // 剪枝：跳过0值乘法
                for (j=1; j<=len; j++) 
                    now.maps[i][j] += x.maps[i][k] * y.maps[k][j];
    return now;
}
```

---

## 相似题目推荐
1. **P2151 [SDOI2009] HH去散步**  
   （矩阵快速幂+图论路径计数，状态转移类似）
2. **P2233 [HNOI2002] 公交车路线**  
   （状态压缩+递推优化，环形路线模型）
3. **P4159 [SCOI2009] 迷路**  
   （矩阵加速DP，处理带权图的路径计数）

---
处理用时：53.88秒
# 题目信息

# [九省联考 2018] 一双木棋 chess

## 题目描述

菲菲和牛牛在一块 $n$ 行 $m$ 列的棋盘上下棋，菲菲执黑棋先手，牛牛执白棋后手。

棋局开始时，棋盘上没有任何棋子，两人轮流在格子上落子，直到填满棋盘时结束。  

落子的规则是：一个格子可以落子当且仅当这个格子内没有棋子且这个格子的左侧及上方的所有格子内都有棋子。

棋盘的每个格子上，都写有两个非负整数，从上到下第 $i$ 行中从左到右第 $j$ 列的格子上的两个整数记作 $a_{i,j}$ 和 $b_{i,j}$。

在游戏结束后，菲菲和牛牛会分别计算自己的得分：菲菲的得分是所有有黑棋的格子上的 $a_{i,j}$ 之和，牛牛的得分是所有有白棋的格子上的 $b_{i,j}$ 的和。

菲菲和牛牛都希望，自己的得分减去对方的得分得到的结果最大。现在他们想知道，在给定的棋盘上，如果双方都采用最优策略且知道对方会采用最优策略，那么，最终的结果如何？


## 说明/提示

### 样例 1 说明

![](https://cdn.luogu.com.cn/upload/pic/16877.png)

棋盘如图所示，双方都采用最优策略时，棋局如下：

- 菲菲下在第 $1$ 行第 $1$ 列（这是第一步时唯一可以落子的格子）。
- 牛牛下在第 $1$ 行第 $2$ 列。
- 菲菲下在第 $2$ 行第 $1$ 列。
- 牛牛下在第 $1$ 行第 $3$ 列。
- 菲菲下在第 $2$ 行第 $2$ 列。
- 牛牛下在第 $2$ 行第 $3$ 列（这是这一步时唯一可以落子的格子）。
- 填满棋盘，游戏结束。

盘面如下：

![](https://cdn.luogu.com.cn/upload/pic/16878.png)

菲菲的得分为 $2 + 9 + 1 = 12$，牛牛的得分为 $7 + 2 + 1 = 10$。

### 数据规模与约定

各测试点信息如下表。

![](https://cdn.luogu.com.cn/upload/pic/16879.png)

- 对于编号为奇数的测试点，保证 $b_{i, j} = 0$。
- 对于全部的测试点，保证 $1 \leq n, m \leq 10$，$0 \leq a_{i, j}, b_{i, j} \leq 10^5$。


## 样例 #1

### 输入

```
2 3
2 7 3
9 1 2
3 7 2
2 3 1
```

### 输出

```
2```

# AI分析结果



### 唯一算法分类
**状态压缩动态规划（轮廓线DP）与博弈论对抗搜索**

---

### 题解思路与算法要点
#### 核心思路
1. **状态表示**：棋盘落子形成的阶梯状轮廓线可用以下方式表示：
   - **轮廓线DP**：用长度为 (n+m) 的 01 串表示从右下到左上的移动路径（1 表示向下，0 表示向右）
   - **行棋序列**：每行的棋子数构成单调不增序列，通过进制（如 11 进制）压缩为整数
2. **博弈对抗**：每个状态的决策由当前玩家决定：
   - 先手（菲菲）选择最大收益：`max(f[后继状态] + a[i][j])`
   - 后手（牛牛）选择最小损失：`min(f[后继状态] - b[i][j])`
3. **记忆化搜索**：通过哈希或 map 存储状态转移结果，避免重复计算

#### 解决难点
- **状态压缩的高效性**：轮廓线状态数仅 C(n+m, n) 级别（约 18 万种），确保可行性
- **转移方向判断**：通过异或操作快速生成合法后继状态（如轮廓线中 `01→10` 的翻转）
- **得分动态计算**：落子时直接累加当前格子的 a/b 值，避免全盘遍历

---

### 题解评分（≥4星）
1. **[Anoxiacxy] 轮廓线DP（5星）**
   - **亮点**：代码简洁，状态转移仅需异或操作，时间复杂度 O(组合数)
   - **代码片段**：
     ```cpp
     int dfs(int sta, bool who, int n, int m) {
         if (~f[sta]) return f[sta];
         f[sta] = who ? -oo : oo;
         int x = n, y = 0;
         for (int i=0; i<n+m-1; ++i) {
             if (sta>>i&1) x--; else y++;
             if ((sta>>i&3)!=1) continue;
             int nxt = sta^(3<<i);
             if (who) f[sta] = max(f[sta], dfs(nxt,!who,n,m)+a[x][y]);
             else f[sta] = min(f[sta], dfs(nxt,!who,n,m)-b[x][y]);
         }
         return f[sta];
     }
     ```
2. **[ouuan] 状态压缩对抗搜索（4.5星）**
   - **亮点**：通过二进制表示递增序列，直接推导转移方程
   - **关键逻辑**：通过奇偶判断当前玩家，交替进行 max/min 选择
3. **[cmd2001] 哈希记忆化搜索（4星）**
   - **亮点**：使用 map 存储状态，行棋序列用 11 进制压缩，代码易理解

---

### 最优思路提炼
1. **轮廓线状态表示**：将棋盘边界压缩为 01 序列，异或操作生成合法转移
2. **对抗搜索框架**：
   ```python
   def dfs(state, is_max_player):
       if state in memo: return memo[state]
       if is_max_player:
           return max( dfs(next_state, False) + a[i][j] )
       else:
           return min( dfs(next_state, True) - b[i][j] )
   ```
3. **降维技巧**：通过当前棋子总数的奇偶性判断玩家，无需额外参数

---

### 类似题目推荐
1. [P1973 NOI2011 棋盘覆盖](https://www.luogu.com.cn/problem/P1973)
2. [P4364 [九省联考2018]IIIDX](https://www.luogu.com.cn/problem/P4364)
3. [P3959 宝藏](https://www.luogu.com.cn/problem/P3959)

---

### 可视化设计（复古像素风格）
1. **动画元素**：
   - **轮廓线绘制**：用绿色像素块表示已落子区域，红色箭头显示当前转移方向
   - **得分浮动**：每次落子时显示 "+a[i][j]" 或 "-b[i][j]" 的 8-bit 数字特效
2. **音效设计**：
   - 转移时播放 `beep(440, 50)`（类似 FC 音效）
   - 胜负判定时播放胜利/失败旋律（使用 Web Audio API）
3. **交互功能**：
   ```javascript
   // 伪代码：自动演示模式
   function autoPlay(state) {
       let moves = getLegalMoves(state);
       for (let move of moves) {
           drawPixelMove(move); // Canvas 绘制
           playSound('move');
           autoPlay(nextState);
       }
   }
   ```

---

### 核心代码实现（轮廓线DP）
```cpp
int a[10][10], b[10][10], f[1<<20];
bool vis[1<<20];

int dfs(int state, bool is_max) {
    if (vis[state]) return f[state];
    vis[state] = true;
    
    int x = n, y = 0, res = is_max ? -INF : INF;
    for (int i=0; i<n+m-1; ++i) {
        if (state>>i&1) x--; else y++;
        if ((state>>i&3) != 1) continue;
        
        int next_state = state ^ (3<<i);
        if (is_max) 
            res = max(res, dfs(next_state, false) + a[x][y]);
        else 
            res = min(res, dfs(next_state, true) - b[x][y]);
    }
    return f[state] = res;
}

// 初始化：f[终局] = 0
```

---

### 个人心得摘录
> "考试时发现状态数远小于预期，直接暴力+记忆化就能过。轮廓线异或转移的技巧后来才想到，现场推导确实需要博弈问题经验。" —— Anoxiacxy

> "将行棋序列看作单调数列是突破口，11进制压缩比二进制更节省状态空间" —— cmd2001

---

通过轮廓线状态压缩和对抗搜索框架，该题将复杂的棋盘博弈转化为高效动态规划问题，结合记忆化优化和状态转移技巧，在合理时间复杂度内求得最优解。

---
处理用时：72.97秒
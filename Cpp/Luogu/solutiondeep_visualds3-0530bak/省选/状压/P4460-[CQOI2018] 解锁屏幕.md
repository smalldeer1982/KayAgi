# 题目信息

# [CQOI2018] 解锁屏幕

## 题目背景

使用过 Android 手机的同学一定对手势解锁屏幕不陌生。 Android 的解锁屏幕由 $3 \times 3$ 个点组成，手指在屏幕上画一条线，将其中一些点连接起来，即可构成一个解锁图案。如下面三个例子所示：

![](https://cdn.luogu.com.cn/upload/pic/17556.png)
![](https://cdn.luogu.com.cn/upload/pic/17557.png)
![](https://cdn.luogu.com.cn/upload/pic/17558.png)

## 题目描述

画线时还需要遵循一些规则：
1. 连接的点数不能少于 $4$ 个。也就是说只连接两个点或者三个点会提示错误。
2. 两个点之间的联线不能弯曲。
3. 每个点只能“使用”一次，不可重复。这里的“使用”是指手指划过一个点，该点变绿。
4. 两个点之间的连线不能“跨过”另一个点，除非那个点之前已经被“使用”过。

对于最后一条规则，参见下图的解释。左边两幅图违反了该规则；而右边两幅图（分别为 $ 2 \rightarrow 4 \rightarrow 1 \rightarrow 3 \rightarrow 6$ 和 $ 6 \rightarrow 5 \rightarrow 4 \rightarrow 1 \rightarrow 9 \rightarrow 2$ ）则没有违反规则，因为在“跨过”点时，点已经被使用过了。

![](https://cdn.luogu.com.cn/upload/pic/17566.png)

现在工程师希望改进解锁屏幕，增减点的数目，并移动点的位置，不再是一个九宫格形状，但保持上述画线规则不变。

请计算新的解锁屏幕上，一共有多少满足规则的画线方案。

## 说明/提示

#### 样例解释 1

设 $4$ 个点编号为 $1$ 到 $4$ ，方案有 $1 \rightarrow 2 \rightarrow 3 \rightarrow 4$ ， $2 \rightarrow 1 \rightarrow 3 \rightarrow 4$ ，  $3 \rightarrow 2 \rightarrow 1 \rightarrow 4$ ，  $2 \rightarrow 3 \rightarrow 1 \rightarrow 4$ 以及它们的镜像。

### 数据范围

- 对于 $30\%$ 的数据，$1 \le n \le 10$。
- 对于 $100\%$ 的数据，$-1000 \le x_i ,y_i \le 1000$，$ 1 \le n < 20$。各点坐标不相同。

## 样例 #1

### 输入

```
4
0 0
1 1
2 2
3 3```

### 输出

```
8```

## 样例 #2

### 输入

```
4
0 0
0 1
0 2
1 0```

### 输出

```
18```

# AI分析结果



**唯一算法分类**  
状压动态规划（状压DP）

---

### **综合分析与结论**

**核心思路与难点**  
题目要求计算满足特定规则的解锁方案数，关键在于处理“跨点”规则。所有题解均采用状压DP，状态`dp[i][j]`表示已选点集`i`且最后访问点为`j`的方案数。预处理两点间的必经点集合是核心优化，转移时检查必经点是否已被访问。

**可视化设计要点**  
- **动画流程**：  
  1. 用网格表示所有点，不同颜色标记已选/未选点。  
  2. 动态展示状态转移：选中新点时，高亮连线及必经点，若必经点已选则允许转移。  
  3. 状态更新时，用像素方块闪烁显示当前状态编码（二进制）。  
- **复古风格**：  
  - 8-bit音效：连线成功时播放上升音调，失败（必经点未选）播放低沉音效。  
  - Canvas绘制点阵，采用FC游戏风格调色板（如绿色表示安全点，红色表示错误）。  
- **自动演示模式**：  
  AI按最优路径自动选择点，展示状态转移的逐步决策过程，用户可暂停观察必经点检查逻辑。

---

### **题解清单（≥4星）**

1. **孙子隆的题解（4.5星）**  
   - **亮点**：高效预处理中间点，位运算优化显著减少常数时间。  
   - **代码核心**：预处理`nd[i][j]`存储必经点掩码，转移时直接按位与检查。

2. **StudyingFather的题解（4.5星）**  
   - **亮点**：清晰注释与结构，使用斜率判断共线，代码可读性高。  
   - **核心代码**：预处理`g[i][j]`存储必经点集合，转移时通过位掩码快速验证。

3. **littleseven的题解（4星）**  
   - **亮点**：详细解释状压DP设计思路，附带同类型题推荐。  
   - **关键步骤**：使用`lowbit`优化状态枚举，显著减少无效循环。

---

### **最优思路/技巧提炼**

1. **预处理必经点集合**  
   - 对每对点`(i,j)`，计算其连线上的所有中间点，存储为二进制掩码。例如：  
     ```cpp
     for (i=0; i<n; i++)
         for (j=0; j<n; j++)
             for (k=0; k<n; k++)
                 if (共线且介于i,j之间) nd[i][j] |= (1<<k);
     ```

2. **状压DP状态转移**  
   - 从状态`i`转移到`i | (1<<k)`时，检查`(nd[j][k] & i) == nd[j][k]`，确保必经点已选。

3. **位运算优化**  
   - 使用`__builtin_popcount`快速统计二进制中1的个数，判断是否满足点数≥4。

---

### **同类型题与推荐**

1. **洛谷P2831 [NOIP2016]愤怒的小鸟**  
   - 状压DP预处理抛物线覆盖点，类似必经点检查。

2. **洛谷P1433 吃奶酪**  
   - 状压DP求最短路径，处理点集遍历。

3. **洛谷P3959 宝藏**  
   - 状压DP结合生成树，处理状态分层转移。

---

### **核心代码实现**

**孙子隆题解的关键片段**  
```cpp
// 预处理必经点
for (int i=0;i<n;i++)
    for (int j=0;j<n;j++) {
        if (i==j) continue;
        for (int k=0;k<n;k++)
            if (共线且在i,j之间) nd[i][j] |= (1<<k);
    }

// 状态转移
for (int i=1;i<(1<<n);i++) {
    for (int j=0;j<n;j++) {
        if (dp[i][j] && ((1<<j)&i)) {
            for (int k=0;k<n;k++)
                if (!((1<<k)&i) && (nd[j][k]&i)==nd[j][k])
                    dp[i|(1<<k)][k] += dp[i][j];
        }
    }
}
```

---

### **可视化代码示例（伪代码）**

```javascript
// Canvas绘制点阵与连线
function drawPoints() {
    ctx.fillStyle = "#8B00FF"; // 复古紫
    points.forEach((p, idx) => {
        if (state & (1 << idx)) ctx.fillRect(p.x*50, p.y*50, 10, 10); // 已选点
        else ctx.strokeRect(p.x*50, p.y*50, 10, 10); // 未选点
    });
}

// 自动演示逻辑
function autoPlay() {
    let nextState = findNextValidState(currentState);
    if (nextState) {
        playSound('move'); // 8-bit音效
        highlightLine(currentState, nextState);
        currentState = nextState;
    } else {
        playSound('error');
    }
}
```

---

**总结**  
本题通过状压DP与预处理技术高效解决，核心在于状态设计与必经点检查。可视化设计可增强对状态转移的理解，复古风格与音效提升学习趣味性。

---
处理用时：72.12秒
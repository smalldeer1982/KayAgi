# 题目信息

# [SBCOI2020] 归家之路

## 题目背景

时光流逝，岁月无痕。  
小镇的夜空中，缀满了无数宝石一般的闪烁星辰。  
依旧是那片星空，依旧是那个小镇。  
......  
“好久不见啊。”  
“不知不觉，竟然已经过去了那么久了...”  
“但是，这座小镇还是曾经的那个小镇啊。”  
“只不过，我们都不再是过去的自己了呢。”  
“你还记得吗，我们曾经一起在这里看雪，一起玩游戏...”   
“可是游戏结局明明一开始就已经决定了...真是太坏了...”    
“嘿嘿，说起来你还从来没赢我过呢......”  
“我还记得，你以前说过，每当世界上有一份思念，便会化成一片雪花在这里飘落...”  
“嗯，我只要看着冬天的雪便能想起你了。我知道，这一定是你的思念吧...”    
“我也看到了，如同雪花般飘落的记忆......”  

天空中，点点滴滴的光芒融合在一起，清澈而宁静。眼前的风景是那么熟悉又陌生。  
![](https://cdn.luogu.com.cn/upload/image_hosting/ic5htl18.png)

“我们再待一会儿如何，就像以前一样......”  
“和你，和小镇，和星空......”

## 题目描述

天空中一共有 $2^n$ 颗星，依次编号为 $0,1,...,2^n-1$。每颗星都有一个亮度值。初始时第 $i$ 颗星的亮度值为 $a_i$。  

对于两个正整数 $a,b$ 我们定义一种布尔类型运算 $a\otimes b$ 。如果在 $a$ 的**二进制**表示中，满足每一个 $a$ 是 $1$ 的位，$b$ 的对应位也是 $1$，那么  $a\otimes b$ 为 `True` , 否则 $a\otimes b$ 为 `False`。  
若两数在二进制表示下的位数不同，则将两数 **右对齐** 后在左侧补0。例如两个数是 $1$ 和 $11$ （二进制），$1$ 会变成 $01$。

对于这些星的亮度值有两种操作：

第一种：$1$ $a$ $b$ $k$。对于所有的满足 $a\otimes c$ 值为 `True` 以及 $c\otimes b$ 值为 `True` 的 $c$，将第 $c$ 颗星的亮度值加上 $k$。

第二种：$2$ $a$ $b$。若第 $c$ 颗星的编号 $c$ 满足 $a\otimes c$ 值为 `True` 以及 $c\otimes b$ 值为 `True`。求出所有第 $c$ 颗星的亮度总和，答案对 $2^{32}$ 取模。  


## 说明/提示

**【样例解释】**

第一次是询问，$0$ 的二进制表示为 $000$， $7$ 的二进制表示为 $111$ 。此时，所有数都满足，即求的是所有数之和，为 $36$。

第二次是修改，$1$ 的二进制表示为 $001$，$5$ 的二进制表示为 $101$，发现 $c=1,5$ 满足，二进制表示分别为 $001$，$101$所以 $a_1,a_5$ 的值从 $2,6$ 变为 $3,7$。

第三次是询问，$1$ 的二进制表示为 $001$，$7$ 的二进制表示为 $111$，发现 $c=1,3,5,7$ 满足，二进制表示分别为 $001$，$011$，$101$，$111$。求的是 $a_1,a_3,a_5,a_7$ 的和 $3+4+7+8=22$。

**【数据范围】**

**本题捆绑测试，共有 $4$ 个子任务**。 

$Subtask 1(1\%)$：答案为样例。

$Subtask 2(9\%)$：$n \le 12,m \le 2\times 10^3$。

$Subtask 3(15\%)$：所有 $2$ 操作都在 $1$ 操作之后。

$Subtask 4(75\%)$：没有任何额外限制。

对于 $100\%$ 的数据，$1 \le n \le 16,1 \le m \le 2\times 10^5, 0 \le a,b \le 2^n-1,0 \le a_i,k \le 2^{32}-1$。

**【温馨提示】**

对 $2^{32}$ 取模，可以直接用无符号 `32` 位整形的数据类型进行运算。在 `c++` 中就是 `unsigned int`。

~~也就是【直接自然溢出啥事没有】。~~

## 样例 #1

### 输入

```
3 3
1 2 3 4 5 6 7 8
2 0 7
1 1 5 1
2 1 7```

### 输出

```
36
22```

# AI分析结果



## 唯一算法分类
分块（根号分治）与高维前缀和

---

## 综合分析与结论

### 核心算法流程
1. **分块处理**：将操作分为多个块，每块处理一定量（如√(2ⁿn)）的修改后，通过高维前缀和更新全局状态。
2. **动态决策**：对每个操作，根据子集位数选择暴力枚举（位数少时）或递归拆分（位数多时）：
   ```cpp
   if (子集位数 ≤ n/2) 暴力枚举子集
   else 递归拆分到高维前缀和
   ```
3. **高维前缀和**：维护子集和数组，用于快速响应静态情况下的查询。
4. **贡献叠加**：查询时，块外贡献通过高维前缀和计算，块内贡献通过遍历块内修改计算交集。

### 可视化设计思路
1. **分块动画**：用不同颜色方块表示分块（如蓝色块表示已处理块，红色块表示当前活跃块），展示块边界如何推进。
2. **高维前缀和更新**：以二进制网格形式展示每个维度如何被累加，用高亮箭头指示当前处理的二进制位。
3. **子集枚举**：用二进制树状展开效果，实时显示暴力枚举时的子集生成过程（如从111逐步变为000）。
4. **递归拆分演示**：用分形动画展示递归拆分过程，如将(110,111)拆分为(100,111)和(100,011)两个子问题。

---

## 题解清单（≥4星）

### 1. 作者：command_block（5星）
- **亮点**：基于时间分块的高效实现，代码简洁且通过FWT加速高维前缀和。
- **关键代码**：
  ```cpp
  // 分块更新逻辑
  if (cnt >= B) rebuild(), cnt=0;
  ```
- **核心思想**：用`rebuild()`函数将积累的修改通过FWT更新到主数组，块内查询时暴力计算贡献。

### 2. 作者：犇犇犇犇（5星）
- **亮点**：详细注释与分块实现细节，通过预处理bitcnt优化子集枚举速度。
- **关键代码**：
  ```cpp
  for(int s=dif;;s=(s-1)&dif){...} // 优雅的暴力子集枚举
  ```
- **个人心得**：强调分块大小的选择（`sqrt(n*(q+2^n))`）对实际运行效率的影响。

### 3. 作者：duyi（4.5星）
- **亮点**：清晰的递归公式推导与分块策略的数学证明。
- **关键公式**：
  $$f(x,y)=f(x-p,y)-f(x-p,y-p) \quad (\text{p为x的最低位1})$$
- **代码特色**：通过`add1`和`ask1`实现递归拆分，逻辑高度对称。

---

## 最优思路与技巧提炼

### 关键思路
1. **分块平衡复杂度**：块外用O(n2ⁿ)的高维前缀和，块内用O(B√2ⁿ)的暴力计算，总复杂度O(q√(2ⁿn))。
2. **动态决策子集处理**：根据子集位数选择暴力或递归，将指数复杂度降至多项式级别。
3. **贡献交集公式**：对修改与查询的交集范围，通过位运算`(a|a') & (b&b')`快速计算影响因子。

### 代码实现技巧
- **快速子集枚举**：`for(int s=dif;;s=(s-1)&dif)`实现不重复不遗漏遍历。
- **高维前缀和更新**：通过正序/逆序循环实现FWT变换：
  ```cpp
  for(int i=0;i<n;i++) // 正序累加实现OR变换
  for(int j=(1<<n)-1;j>=0;j--) // 逆序累加实现AND变换
  ```

---

## 同类题目推荐
1. **P5495 Dirichlet 前缀和**（高维前缀和模板题）
2. **P1972 [SDOI2009]HH的项链**（分块与莫队算法应用）
3. **P3834 【模板】可持久化线段树 2**（分块思想在查询历史版本中的应用）

---

## 个人心得摘录
> "分块大小的选择需要精细计算——太大导致块内暴力变慢，太小导致高维前缀和更新过于频繁。通过`sqrt(n*(q+2^n))`公式实现自动平衡。"  
> —— 犇犇犇犇题解中的调试经验

> "递归拆分时最容易被忽略的是终止条件，必须确保每一步递归都严格减少问题规模，否则会导致无限循环。"  
> —— duyi题解中的踩坑记录

---

## 可视化与复古动画设计

### 像素化算法演示（HTML/JS核心代码）
```html
<canvas id="algoCanvas"></canvas>
<script>
// 初始化16x16像素网格
const CELL_SIZE = 20;
const canvas = document.getElementById('algoCanvas');
canvas.width = CELL_SIZE * 16;
canvas.height = CELL_SIZE * 16;
const ctx = canvas.getContext('2d');

// 高亮当前处理位（复古绿/红）
function highlightBit(bitPos, color) {
    const x = (bitPos % 16) * CELL_SIZE;
    const y = Math.floor(bitPos / 16) * CELL_SIZE;
    ctx.fillStyle = color;
    ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
}

// 播放8位音效
function playSound(freq) {
    const oscillator = new OscillatorNode(ctx, {frequency: freq});
    oscillator.connect(ctx.destination);
    oscillator.start();
    setTimeout(() => oscillator.stop(), 100);
}
</script>
```

### 动画逻辑
1. **分块推进**：每处理完一个块，右侧进度条增长，伴随8-bit音效。
2. **子集枚举**：枚举时对应二进制位闪烁黄色，命中有效子集时播放“金币声”。
3. **递归拆分**：用分形动画展示问题分解，父节点裂变为两个子节点时播放“劈砍声”。

---

## 核心代码实现（分块与高维前缀和）
```cpp
void rebuild() {
    // 高维后缀和更新标记
    for(int i=0; i<n; i++)
        for(int j=(1<<n)-1; j>=0; j--)
            if(j & (1<<i)) mdf_s[j^(1<<i)] += mdf_s[j];
    
    // 合并到主数组并重新计算高维前缀和
    for(int i=0; i<(1<<n); i++) {
        a[i] += mdf_v[i] + mdf_s[i];
        s[i] = a[i];
    }
    fwt_or(s, (1<<n), 1u); // 正变换计算高维前缀和
}
```

该代码展示了分块更新时的关键步骤：通过逆序循环实现高维后缀和，再通过正序FWT计算新的前缀和数组。

---
处理用时：91.39秒
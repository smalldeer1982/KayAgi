# 题目信息

# 「EZEC-4」括号

## 题目背景

> 离景似是昨日，转眼却已经年$\newline$ 往事依旧，物是全非



## 题目描述

给一个由小括号组成的序列和 $n$ 个括号串，要你在序列中匹配允许不连续的子串。

母序列的每个括号最多被匹配一次。

一种可能的不连续子串匹配方式为 ```)()(``` 中匹配 ``` ))(``` 。

每个括号串有一个值 $v$，代表对这个串每匹配一个括号得到的价值。

每个括号串均可以多次匹配，可以随时停止匹配，但是不能在未匹配完一个括号串的情况下开始匹配其他括号串。

注意如果你跳过了母序列的某几个括号去匹配后面的，那么你将不能返回前面继续进行匹配。

求匹配能得到的最大值。

## 说明/提示

【温馨提示】

**为了卡掉错解开大了数据范围，请注意常数因子对程序产生的影响。**

【数据范围】

**本题使用捆绑测试。**

对于 $100\%$ 的数据， $1 \le n \le 500, 1 \le len(k) \le 10^4, 1 \le len(a) \le 300,0 \le v \le 10^3$。

| Subtask | $ n \le$ | $ len(k) \le$ | $ len(a) \le$ |   时间 | 分值|特殊性质 |
| :----------: | :----------: | :----------: | :----------: |:----------: | :----------: |:----------: |
| $1$ | $10$ | $7$| $7$ | $1\text s$ |$5$|保证最优解每个 a 最多只用一次 |
| $2$ | $10$ | $50$| $8$| $1\text s$|$5$|数据随机，若 AC subtask3 则不计入总分|
| $3$ | $10$ | $1000$| $8$| $1\text s$|$10$|保证最优解每个 a 最多只用一次|
| $4$ | $100$ | $10^4$ | $8$ | $1\text s$ |$15$| 无 |
| $5$ | $500$ | $10^4$ | $8$ | $1\text s$ |$10$| 无 |
| $6$ | $500$ | $10^4$ | $300$| $2.2\text s$ |$60$| 无|

【样例 $1$ 解释】

最佳方案为先匹配 ```(()``` ，后匹配 ```()()()``` （ 注意最多只能匹配到 ```()()``` ），答案为 $4\times3 + 5 \times 4 = 32$。

一种可行的匹配方法为方括号括起来的部分 ```(【(()()】)(【()】``` 。

而若先匹配 ```(()``` ，再匹配 ```()``` ，最后匹配 ```(()``` 的价值为 $4\times 3 + 2\times 2 + 4\times 3 = 28$，并非最佳方案。

注意我们不能先匹配 ```(()``` ，再匹配 ```()()()``` 中一个括号，最后匹配 ```(()``` ，因为我们可以随时停止匹配，但不能在未匹配完某个串的情况下开始匹配另一个串。

【样例 $2$ 解释】

最佳方案先匹配 ```())```，再匹配 ```()))``` 最后匹配 ```())``` （ 注意最多只能匹配到 ```()``` ）, 答案为 $9\times 3 + 7 \times 4 + 9 \times 2 = 73$。

## 样例 #1

### 输入

```
3 
((()())(()
(() 4
() 2
()()() 5```

### 输出

```
32```

## 样例 #2

### 输入

```
3
())()))()
()) 9
()() 8
())) 7```

### 输出

```
73```

# AI分析结果



**算法分类**: 动态规划（分块优化与状态预处理）

---

### **题解思路与核心难点**

#### **核心思路**
1. **预处理最近括号位置**：对母序列每个位置预处理下一个'('和')'的位置，用于快速跳跃匹配。
2. **分块状压预处理**：将每个子串分块（如块长L=5），每个块转为二进制状态（0='(', 1=')')，预处理每个块在母序列各位置的转移终点。
3. **动态规划转移**：DP状态`dp[i]`表示母序列前i个字符的最大价值。对每个子串分块跳跃，快速跳过完整块，剩余部分暴力匹配。

#### **解决难点**
- **多次匹配与不连续性**：子串可多次使用但必须完整匹配，需设计跳跃机制避免重复计算。
- **复杂度优化**：通过分块将单次匹配复杂度从O(a)降至O(√a)，预处理块状态避免重复扫描母序列。

---

### **最优思路与技巧提炼**
1. **分块跳跃**：将子串分割为多个固定长度块，预处理每块的转移终点，快速跳过已匹配部分。
2. **状压预处理**：块内字符转为二进制状态，预处理每个状态在母序列的转移位置，加速匹配。
3. **动态规划状态转移**：利用`dp[i]`记录前i位的最优解，每次尝试所有子串的分块跳跃更新后续状态。

---

### **题解评分（≥4星）**
1. **pocafup的题解（5星）**
   - **亮点**：覆盖多种数据范围，分块+状压的优化思路巧妙，代码预处理与跳跃逻辑清晰。
   - **代码可读性**：预处理与转移分离，注释详细。
   - **优化程度**：通过分块将复杂度降至可接受范围，适合大数据。

---

### **核心代码实现**
```cpp
// 预处理每个位置的最近括号位置
for (int i = k; i > 0; i--) {
    nxt[0][i] = (s[i-1] == '(') ? i : nxt[0][i+1];
    nxt[1][i] = (s[i-1] == ')') ? i : nxt[1][i+1];
}

// 分块预处理：生成块的状态
int get(int pos, int f, int t) {
    int re = 0;
    for (int i = f; i <= t; i++)
        re += ((a[pos][i] == '(') ? 0 : 1) * (1 << (t - i));
    return re;
}

// 动态规划转移
void Solve(int kk, int pos) {
    int re = 0, from = kk, cnt = 1;
    for (int i = 1; i <= num[pos]; i++) {
        if (pre[kk][cor[pos][i]]) {
            kk = pre[kk][cor[pos][i]] + 1;
            re += L * v[pos];
            cnt += L;
        } else break;
    }
    jump(pos, kk, cnt, re, from); // 处理剩余部分
}
```

---

### **同类型题目推荐**
1. **洛谷 P1944**（最长括号匹配）
2. **LeetCode 32**（最长有效括号）
3. **CodeForces 5C**（最长合法括号子串）

---

### **可视化算法演示**

#### **动画设计**
1. **母序列展示**：横向排列字符，颜色区分'('和')'。
2. **块跳跃高亮**：匹配子串时，当前块以闪烁像素框标记，母序列对应位置变为绿色。
3. **状态转移线**：箭头从当前块起点指向跳跃后的终点，颜色渐变表示价值增加。

#### **复古像素风格**
- **颜色方案**：8位色，绿色表匹配成功，红色表失败。
- **音效**：跳跃成功时播放“哔”声，块完成时播放升级音效。
- **自动演示**：按空格暂停/继续，方向键调整速度。

---

### **总结**
通过分块预处理与动态规划的结合，高效解决了不连续子串多次匹配的问题。核心在于将长串分解为可快速跳跃的块，显著降低复杂度，适合处理大数据范围的竞赛场景。

---
处理用时：60.81秒
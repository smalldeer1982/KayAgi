# 题目信息

# 「EZEC-10」Equalization

## 题目描述

给你一个长为 $n$ 的数组 $a_1,a_2,\ldots,a_n$。

你可以任选三个整数 $l,r,x\ (1\le l\le r\le n$，$x\in \mathbb Z)$，并将 $a_l,a_{l+1},\ldots,a_r$ 均加上 $x$，称为一次操作。

问最少进行几次操作，才能使 $a$ 中所有元素均相等？并求出能使操作次数最少的不同方案数。

由于方案数可能很大，请对 $10^9+7$ 取模。

**两种方案相同，当且仅当两方案每次操作选择的 $(l,r,x)$ 均相同。**

**特别地，不进行任何操作也算一种方案。**

## 说明/提示

**【样例 1 解释】**

一种可行的方案为：$(l,r,x)=(1,1,1),(3,3,-1)$。

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（1 point）：$n=2$。
-  Subtask 2（5 points）：$n=3$。
-  Subtask 3（14 points）：保证 $a$ 单调不升或单调不降。
-  Subtask 4（20 points）：$n\le 10$。
-  Subtask 5（20 points）：$n\le 16$。
-  Subtask 6（40 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le n\le 18$，$-10^9\le a\le 10^9$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
2
16```

# AI分析结果



**唯一算法分类**  
动态规划（状态压缩）

---

**题解思路、算法要点与解决难点**  
各题解均通过差分将问题转化为连通块划分问题，核心思路如下：  
1. **差分转换**：将原数组转化为差分数组，区间操作转化为差分数组的点操作。  
2. **连通块模型**：每次操作对应图中的边，形成连通块。每个连通块需满足和为0（树结构）或有自环调整。  
3. **状压DP**：枚举子集，用DP维护最少操作次数和方案数。  
4. **方案数计算**：树结构用Prufer序列计算生成树数（k^{k-2}），非树情况乘系数2。  

**解决难点**：如何高效处理子集划分与连通块贡献，以及正确维护方案数的组合关系。

---

**题解评分**  
1. **tzc_wk（★★★★★）**  
   - 思路清晰，代码结构紧凑，高效实现状压DP与方案数计算。  
   - 关键优化：预处理子集和，快速判断连通块合法性。  
2. **IdnadRev（★★★★☆）**  
   - 代码简洁，直接利用连通块性质，省略冗余步骤。  
   - 亮点：快速枚举子集，直接维护DP状态。  
3. **Ecrade_（★★★★☆）**  
   - 详细拆分状态（A/B状态），逻辑严谨。  
   - 缺点：代码复杂度略高，可读性稍逊。

---

**最优思路或技巧提炼**  
1. **差分转换与连通块划分**：将区间操作转化为图论模型，连通块性质决定操作次数。  
2. **状压DP优化**：枚举子集，预处理和快速转移，时间复杂度O(3^n)。  
3. **生成树计数**：利用Prufer序列计算树结构方案数，非树情况乘系数处理。  

---

**同类型题或类似算法套路**  
- 类似问题：CF1119H 的差分+状压思路。  
- 通用解法：将区间操作转化为差分模型，结合图论连通性分析。

---

**推荐洛谷题目**  
1. P6775（差分+连通块划分）  
2. P3177（生成树计数与DP结合）  
3. P2150（状压DP与数学分析）

---

**个人心得摘录**  
- 调试经验：需验证差分数组初始化和子集枚举的正确性，避免漏判sum=0的情况。  
- 核心顿悟：操作次数最少等价于最大连通块数，方案数为各块生成树数的乘积。

---

**可视化与算法演示**  
**动画设计**：  
1. **差分转换阶段**：原数组→差分数组的动态转换，用颜色区分变化区域。  
2. **连通块构建**：以像素网格展示子集划分，选中子集后高亮对应的连通块。  
3. **状压DP过程**：  
   - **状态转移**：用不同颜色方块表示当前DP状态，箭头指向转移后的新状态。  
   - **子集枚举**：动态显示子集的二进制位选中与取消。  
4. **复古像素风格**：  
   - **调色板**：8位色，绿色表示合法子集，红色表示非法。  
   - **音效**：转移成功时播放短促“哔”声，错误时“嘟”声。  
   - **Canvas绘制**：网格布局，每个方块代表一个子集，点击查看详细信息。  
**交互功能**：  
- **步进控制**：允许单步执行，观察每个子集的转移细节。  
- **自动模式**：AI自动运行，按最优路径推进状态转移。  

**关键代码片段（状压DP）**  
```cpp
for (int S = 0; S < (1 << m); S++) {
    int rst = ((1 << m) - 1) ^ S;
    for (int j = rst; j; j = (j - 1) & rst) {
        if (!sum[j]) 
            upd(dp[S|j], dp[S], cnt[j]-1, g[cnt[j]]);
        else 
            upd(dp[S|j], dp[S], cnt[j], f[cnt[j]]);
    }
}
```

**核心逻辑**：枚举每个状态S的补集rst，遍历所有子集j，根据sum[j]是否为0选择转移方式，更新DP状态。

---
处理用时：75.24秒
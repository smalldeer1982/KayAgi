# 题目信息

# [JSOI2008] 小店购物

## 题目背景

JSOI集训队的队员发现，在他们经常活动的集训地，有一个小店因为其丰富的经营优惠方案深受附近居民的青睐，生意红火。


## 题目描述

小店的优惠方案十分简单有趣：

一次消费过程中，如您在本店购买了精制油的话，您购买香皂时就可以享受 $2.00$ 元 / 块的优惠价；如果您在本店购买了香皂的话，您购买可乐时就可以享受 $1.50$ 元 / 听的优惠价……诸如此类的优惠方案可概括为：如果您在本店购买了商品 $A$ 的话，您就可以以 $P$ 元 / 件的优惠价格购买商品 $B$（购买的数量不限）。

有趣的是，你需要购买同样一些商品，由于不同的买卖顺序，老板可能会叫你付不同数量的钱。比如你需要一块香皂（原价 $2.50$ 元）、一瓶精制油（原价 $10.00$ 元）、一听可乐（原价 $1.80$ 元），如果你按照可乐、精制油、香皂这样的顺序购买的话，老板会问你要 $13.80$ 元；而如果你按照精制油、香皂、可乐这样的顺序购买的话，您只需付 $13.50$ 元。

该处居民发现 JSOI 集训队的队员均擅长电脑程序设计，于是他们请集训队的队员编写一个程序：在告诉你该小店商品的原价，所有优惠方案及所需的商品后，计算至少需要花多少钱（不允许购买任何不必要的商品，即使这样做可能使花的钱更少）。

## 说明/提示

数据范围见输入格式


## 样例 #1

### 输入

```
4
10.00 1
1.80 1
3.00 0
2.50 2
2
1 4 2.00
4 2 1.50```

### 输出

```
15.50```

# AI分析结果



# 算法分类
**最小树形图（朱刘算法）**

---

## 综合分析与结论
### 核心思路与难点
1. **问题建模**：  
   将每个商品视为图中的一个节点，优惠方案视为有向边。建立超级源点，向所有需购买的商品连边（边权为原价），优惠方案则连对应方向的边（边权为优惠价）。目标是找到以超级源点为根的最小树形图，其权值对应购买每个商品第一件的最优花费。

2. **解决难点**：  
   - **环处理**：朱刘算法通过缩点解决优惠方案中的循环依赖（如买A优惠B，买B优惠A）。  
   - **多件购买**：除第一件外，剩余商品用其最低价（预处理得到）购买，避免重复计算优惠。  
   - **无效商品过滤**：跳过购买数量为0的商品及其相关边。

### 可视化设计
1. **动画方案**：  
   - **步骤高亮**：用颜色标记当前处理的边（红色高亮）、已选边（绿色）、缩点后的新节点（黄色）。  
   - **缩点过程**：动态展示环的检测与缩点，将环内节点合并为新节点。  
   - **数据更新**：显示每个节点的入边权值更新和总花费的累加过程。

2. **复古像素风格**：  
   - **颜色方案**：使用16色调色板（如超级源点为蓝色，商品节点为灰色，边为白色）。  
   - **音效提示**：选择边时播放“哔”声，缩点时播放“叮”声，计算完成播放胜利音效。  
   - **自动演示**：按步骤自动执行朱刘算法，用户可暂停/调速观察。

---

## 题解评分（≥4星）
1. **D_14134（4星）**  
   - 简洁实现朱刘算法，预处理剩余商品的最低价格。  
   - 代码结构清晰，适合快速理解核心逻辑。

2. **chihik（4星）**  
   - 拆点处理多件购买，精确区分第一件与后续购买。  
   - 提供更细致的优惠叠加处理，适合复杂场景。

3. **神眷之樱花（4星）**  
   - 完整注释与详细变量说明，便于调试与学习。  
   - 预处理最低价并显式过滤无效边，减少计算冗余。

---

## 最优思路与技巧
1. **超级源点建模**：统一处理原价购买，避免单独处理每个商品的首件。  
2. **缩点自动优化**：朱刘算法自动合并环，处理循环优惠依赖。  
3. **分离计算逻辑**：首件用树形图计算，剩余件用预处理最低价求和。

---

## 类似题目
1. **P4716 最小树形图**（模板题）  
2. **P1772 [ZJOI2006]物流运输**（最短路+动态规划）  
3. **P1266 速度限制**（分层图最短路）

---

## 代码片段（D_14134实现）
```cpp
void mst() {
    while (1) {
        for (int i = 1; i <= num; ++i) inw[i] = inf;
        for (int i = 1; i <= cnt; ++i) // 选最小入边
            if (e[i].w < inw[e[i].v]) 
                inw[e[i].v] = e[i].w, pre[e[i].v] = e[i].u;
        // 缩环并统计答案
        int idx = 0;
        for (int i = 1; i <= num; ++i) {
            ans += inw[i];
            if (vis[i] == -1) {
                int nw = i;
                while (vis[nw] == -1) vis[nw] = i, nw = pre[nw];
                if (vis[nw] == i && nw != rt) { // 发现环
                    id[nw] = ++idx;
                    for (int j = pre[nw]; j != nw; j = pre[j]) id[j] = idx;
                }
            }
        }
        if (!idx) return; // 无环退出
        // 重标号
        for (int i = 1; i <= cnt; ++i) {
            e[i].w -= inw[e[i].v];
            e[i].u = id[e[i].u], e[i].v = id[e[i].v];
        }
        num = idx, rt = id[rt];
    }
}
```

---

## 可视化实现要点
1. **Canvas绘制**：  
   - 节点用圆形表示，边用箭头线段，当前操作边闪烁红色。  
   - 缩点时用黄色边框包裹环内节点，合并后显示新节点编号。  
2. **交互控制**：  
   - 按钮控制播放/暂停/步进，滑动条调节速度。  
   - 右侧面板显示当前步骤说明（如“选择入边”、“缩点”）。  
3. **音效触发**：  
   - `AudioContext`播放8-bit音效，不同操作触发不同音调。  
   - 完成计算后播放《超级马里奥》通关音乐片段。

---
处理用时：81.15秒
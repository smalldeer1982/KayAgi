# 题目信息

# [HNOI2016] 矿区

## 题目描述

平面上的矿区划分成了若干个开发区域。

简单地说，你可以将矿区看成一张连通的平面图，平面图划分为了若干平面块，每个平面块即为一个开发区域，平面块之间的边界必定由若干整点(坐标值为整数的点)和连接这些整点的线段组成。每个开发区域的矿量与该开发区域的面积有关：具体而言，面积为 $ s $ 的开发区域的矿量为 $ s^2 $。

现在有 $ m $ 个开采计划。每个开采计划都指定了一个由若干开发区域组成的多边形，一个开采计划的优先度被规定为矿量的总和÷开发区域的面积和；例如，若某开采计划指定两个开发区域，面积分别为 $ a $ 和 $ b $，则优先度为 $ (a^2+b^2)/(a+b) $。由于平面图是按照划分开发区域边界的点和边给出的，因此每个开采计划也只说明了其指定多边形的边界，并未详细指明是哪些开发区域（但很明显，只要给出了多边形的边界就可以求出是些开发区域）。

你的任务是求出每个开采计划的优先度。为了避免精度问题，你的答案必须按照分数的格式输出，即求出分子和分母，且必须是最简形式（分子和分母都为整数，而且都消除了最大公约数；例如，若矿量总和是 $ 1.5 $，面积和是 $ 2 $，那么分子应为 $ 3 $，分母应为 $ 4 $；又如，若矿量和是 $ 2 $，面积和是 $ 4 $，那么分子应为 
 $ 1 $，分母应为 $ 2 $）。

由于某些原因，你必须依次对每个开采计划求解（即下一个开采计划会按一定格式加密，加密的方式与上一个开采计划的答案有关）。具体的加密方式见输入格式。

## 说明/提示

### 样例解释

输入文件给出的 $9$ 个点和 $14$ 条边描述的平面图如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/cg70enmo.png)

第一个开采计划，输入的第 $1$ 个值为 $3$，所以该开采计划对应的多边形有 $(3+0)\bmod 8+1=4$ 个点，将接下的 $4$ 个数 $3,0,4,7$，分别代入 $(z_i+0)\bmod n+1$ 得到 $4$ 个点的编号为 $4,1,5,8$。计算出第一个开采计划的分子为 $1$，分母为 $1$。

类似地，可计算出余下开采计划的多边形的点数和点的编号：第二个开采计划对应的多边形有 $3$ 个点，编号分别为 $5,6,8$。第三个开采计划对应的多边形有 $6$ 个点，编号分别为 $1,2,6,5,8,4$。第四个开采计划对应的多边形有 $5$ 个点，编号分别为 $1,2,6,8,4$。第五个开采计划对应的多边形有 $6$ 个点，编号分别为 $1,5,6,8,7,4$。

### 数据范围及约定


对于 $ 100 \% $ 的数据，$ n, k \leq 2 \times 10^5, \  m \leq 3n-6, \  |x_i|, |y_i| \leq 3×10^4$。

所有开采计划的 $ d $ 之和不超过 $2 \times 10^6$。保证任何开采计划都包含至少一个开发区域，且这些开发区域构成一个连通块。

保证所有开发区域的矿量和不超过 $ 2^{63}-1 $。

保证平面图中没有多余的点和边。

保证数据合法。由于输入数据量较大，建议使用读入优化。




## 样例 #1

### 输入

```
9 14 5
0 0
1 0
2 0
0 1
1 1
2 1
0 2
1 2
2 2
1 2
2 3
5 6
7 8
8 9
1 4
4 7
5 8
3 6
6 9
4 8
1 5
2 6
6 8
3 3 0 4 7 1 3 4 6 4 8 0 4 3 6 2 3 8 0 4 6 2 5 0 4 5 7 6 3```

### 输出

```
1 1 
1 2 
1 1 
9 10 
3 4```

# AI分析结果



**唯一算法分类**：平面图转对偶图

---

### **题解思路与核心难点分析**

#### **核心思路**
1. **平面图转对偶图**：  
   - 将原图的每个面转化为对偶图的节点，原图的边转化为对偶图的边。  
   - 通过极角排序确定每个面的边界，计算面积并标记无限面（根节点）。  
2. **生成树构建**：  
   - 以无限面为根，DFS生成树，记录子树面积和面积平方的累加值。  
3. **查询处理**：  
   - 遍历查询多边形的边，找到对应的对偶图边，通过树边的父子关系动态加减子树贡献。  

#### **解决难点**
- **面的划分**：通过极角排序确定每条边的后继边，循环遍历形成闭合面。  
- **无限面识别**：利用叉积计算面积的正负，负面积对应无限面。  
- **动态贡献计算**：生成树中父节点与子节点的关系决定贡献符号（加减子树和）。  

---

### **题解评分 (≥4星)**
1. **litble (⭐⭐⭐⭐⭐)**  
   - 代码简洁高效，极角排序与生成树构建逻辑清晰，通过`nxt`数组高效划分面。  
   - 预处理子树和，查询时直接加减贡献，复杂度优秀。  
2. **_Sein (⭐⭐⭐⭐)**  
   - 图文结合解释生成树的容斥原理，强调父子关系判断，代码可读性较好。  
3. **dengchengyu (⭐⭐⭐⭐)**  
   - 详细注释叉积处理面积方向，使用二分查找优化边的定位，实现细节丰富。  

---

### **最优思路与技巧提炼**
1. **极角排序与面划分**  
   - 将每个点的出边按极角排序，确保逆时针遍历面边界。  
   ```cpp  
   sort(h[i].begin(), h[i].end());
   ```  
2. **生成树贡献计算**  
   - 子树和预处理：DFS遍历对偶图，累计面积和平方和。  
   ```cpp  
   void dfs(int x, int las) {
       f[x] = las; // 父节点记录
       s[x] = area; ss[x] = area²; // 初始化当前面
       for (遍历子树) {
           dfs(v, x); // 递归子树
           s[x] += s[v]; ss[x] += ss[v]; // 累加贡献
       }
   }
   ```  
3. **动态查询处理**  
   - 遍历多边形边，查找对应的对偶边，通过父子关系调整贡献。  
   ```cpp  
   if (父是子树) ans += 子树贡献;
   else ans -= 子树贡献;
   ```  

---

### **同类型题与算法套路**
- **对偶图应用**：如[NOI2010]海拔，将网格图转化为对偶图求最小割。  
- **生成树统计子树和**：类似树链剖分思想，预处理子树信息加速动态查询。  
- **极角排序与几何处理**：常见于平面图划分、凸包问题（如Graham扫描法）。  

---

### **推荐相似题目**
1. **P3248 [HNOI2016]树**  
   - 结合树的结构与动态查询，需高效处理子树贡献。  
2. **P2046 [NOI2010]海拔**  
   - 平面图转对偶图求最小割，对偶图构建思路相似。  
3. **P3388 割点**  
   - 平面图中的关键点/边判定，需结合图的双连通性。  

---

### **可视化与算法演示**

#### **动画设计**
- **步骤1：平面图转对偶图**  
  - 原图边高亮，逐步生成对偶图节点（颜色区分面），箭头表示对偶边。  
  - 极角排序动态演示，按角度顺序连接边形成面。  
- **步骤2：生成树构建**  
  - 根节点（无限面）标记为红色，DFS过程中子树用渐变色区分。  
  - 树边与非树边用虚实线区分，点击节点展开子树结构。  
- **步骤3：查询贡献计算**  
  - 多边形边遍历时，对应对偶边闪烁，贡献加减动态显示数值变化。  

#### **复古像素风格**  
- **颜色方案**：16色调色板，面用不同色块，树边绿色，非树边灰色。  
- **音效**：  
  - 边遍历时播放“哔”声，贡献加减时“叮”声，错误时“咔嚓”声。  
- **Canvas动画**：  
  ```javascript  
  function drawEdge(edge) {
      ctx.strokeStyle = edge.isTree ? "#0F0" : "#888";
      ctx.beginPath();
      ctx.moveTo(edge.from.x, edge.from.y);
      ctx.lineTo(edge.to.x, edge.to.y);
      ctx.stroke();
  }
  ```  

---

### **代码实现核心片段**
```cpp  
// 极角排序构建面  
void build() {
    for (int i = 1; i <= n; ++i) sort(h[i].begin(), h[i].end());
    for (int i = 2; i <= tot; ++i) {
        int v = e[i].v;
        auto it = lower_bound(h[v].begin(), h[v].end(), e[i^1]);
        if (it == h[v].begin()) it = h[v].end();
        --it; nxt[i] = it->id; // 找到下一条边
    }
    // 划分面并计算面积
    for (int i = 2; i <= tot; ++i) {
        if (pos[i]) continue;
        pos[i] = pos[nxt[i]] = ++cnt;
        for (int j = nxt[i]; e[j].v != e[i].u; j = nxt[j])
            s[cnt] += (p[e[j].u] - p[e[i].u]) * (p[e[j].v] - p[e[i].u]);
        if (s[cnt] <= 0) rt = cnt; // 标记无限面
    }
}

// 生成树预处理子树和  
void dfs(int x, int las) {
    f[x] = las; vis[x] = 1;
    ss[x] = s[x] * s[x]; s[x] *= 2; // 面积平方与双倍面积
    for (auto &edge : tr[x]) {
        if (vis[edge.v]) continue;
        istr[edge.id] = 1; // 标记树边
        dfs(edge.v, x);
        s[x] += s[edge.v]; ss[x] += ss[edge.v];
    }
}

// 查询处理动态加减贡献  
LL query() {
    LL ans1 = 0, ans2 = 0;
    for (遍历多边形边) {
        int j = 找到的对偶边;
        if (!istr[j]) continue; // 非树边跳过
        if (f[pos[j]] == pos[j^1]) // 父子关系判断
            ans1 += ss[pos[j]], ans2 += s[pos[j]];
        else 
            ans1 -= ss[pos[j^1]], ans2 -= s[pos[j^1]];
    }
    return 分数化简(ans1, ans2);
}
```

---
处理用时：93.36秒
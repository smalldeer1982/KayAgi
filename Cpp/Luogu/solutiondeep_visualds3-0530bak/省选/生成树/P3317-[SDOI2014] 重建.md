# 题目信息

# [SDOI2014] 重建

## 题目描述

T 国有 $N$ 个城市，用若干双向道路连接。一对城市之间至多存在一条道路。    

在一次洪水之后，一些道路受损无法通行。虽然已经有人开始调查道路的损毁情况，但直到现在几乎没有消息传回。    

幸运的是，此前 T 国政府调查过每条道路的强度，现在他们希望只利用这些信息估计灾情。具体地，给定每条道路在洪水后仍能通行的概率，请计算仍能通行的道路恰有 $N-1$ 条，且能联通所有城市的概率。


## 说明/提示

$1<N\leq 50$。

数据保证答案非零时，答案不小于 $10^{-4}$。


## 样例 #1

### 输入

```
3
0 0.5 0.5
0.5 0 0.5
0.5 0.5 0```

### 输出

```
0.375```

# AI分析结果



# 算法分析与题解总结

## 唯一算法分类
**矩阵树定理 (Matrix-Tree Theorem)**

---

## 综合分析与结论

### 核心思路
1. **数学推导**：将原问题概率表达式拆解为两部分：
   - **全局乘积**：所有边不出现的概率 $\prod (1-p_e)$
   - **生成树贡献**：通过矩阵树定理计算 $\sum_T \prod_{e\in T} \frac{p_e}{1-p_e}$
2. **边权调整**：将边权设为 $\frac{p_e}{1-p_e}$，将问题转换为标准矩阵树定理形式。
3. **数值稳定**：对 $p_e=1$ 或 $p_e=0$ 的情况，用微小量 $\epsilon$ 调整避免除以零错误。

### 解决难点
- **非树边概率乘积的分离**：通过数学变形将非树边概率转化为全局乘积，与生成树贡献分离。
- **矩阵构造**：基尔霍夫矩阵的对角线元素为邻接边权之和，非对角线元素为负边权。
- **高斯消元精度**：主元选择策略（最大绝对值行交换）减少浮点误差。

---

## 题解清单 (≥4星)

1. **玫葵之蝶 (5星)**  
   - 清晰推导边权调整的数学逻辑，代码中处理了浮点精度问题（如 `eps` 截断）。
   - 代码结构清晰，注释完整，包含调试技巧（如矩阵元素截断条件）。

2. **Kelin (5星)**  
   - 代码简洁高效，使用模板化高斯消元实现，适合快速移植。
   - 数学推导简明扼要，直击核心步骤，适合快速理解。

3. **wwlw (4.5星)**  
   - 直接对输入数据进行 $\epsilon$ 微调，避免复杂分类讨论。
   - 代码实现高度紧凑，适合竞赛场景快速编码。

---

## 最优思路提炼

### 关键步骤
1. **边权调整**：  
   将每条边的概率 $p_e$ 映射为 $\frac{p_e}{1-p_e}$，使得矩阵树定理可计算生成树贡献。
2. **全局乘积分离**：  
   计算所有边不出现的概率 $\prod (1-p_e)$，作为最终答案的乘数因子。
3. **数值稳定性处理**：  
   对 $p_e=1$ 的情况，强制设定 $p_e=1-\epsilon$；对 $p_e=0$ 的情况，设定 $p_e=\epsilon$。

### 代码实现
```cpp
double a[N][N], prod = 1;
for (int i=1; i<=n; i++) {
    for (int j=1; j<=n; j++) {
        scanf("%lf", &a[i][j]);
        if (a[i][j] == 1) a[i][j] -= eps; // 处理p=1的边
        if (i < j) prod *= (1 - a[i][j]);  // 计算全局乘积
        a[i][j] = a[i][j] / (1 - a[i][j]); // 调整边权
    }
}

// 构造基尔霍夫矩阵
for (int i=1; i<=n; i++) {
    a[i][i] = 0;
    for (int j=1; j<=n; j++) {
        if (i != j) {
            a[i][i] += a[i][j]; // 对角线元素为邻接边权和
            a[i][j] = -a[i][j]; // 非对角线元素为负边权
        }
    }
}

// 高斯消元求行列式
double det = gauss(n-1); // 省略消元实现细节
printf("%.8lf\n", det * prod);
```

---

## 同类型题推荐
1. **P4208 [JSOI2008]最小生成树计数**  
   （矩阵树定理统计不同边权生成树数量）
2. **P4336 [SHOI2016]黑暗前的幻想乡**  
   （矩阵树定理结合容斥原理）
3. **P5296 [北京省选集训2019]生成树计数**  
   （边权为多项式时的扩展矩阵树定理）

---

## 可视化与算法演示

### 动画设计
1. **矩阵构建阶段**：  
   - 用网格展示基尔霍夫矩阵，高亮当前处理的边权调整过程。
   - 显示 $\frac{p_e}{1-p_e}$ 的动态计算，当 $p_e$ 接近1时触发红色警告提示 $\epsilon$ 修正。

2. **高斯消元阶段**：  
   - 步进展示主元选择（最大绝对值行交换），当前消元行用绿色高亮。
   - 消元过程中，用流动线条表示行间的线性组合操作。

3. **复古像素风格**：  
   - 8-bit 风格音效：消元成功时播放“哔”声，主元交换时播放“咔嚓”声。
   - Canvas 绘制矩阵元素为像素块，数值变化时像素块闪烁。

### 交互控制
- **速度调节**：滑动条控制消元速度（0.5x~5x）。
- **单步执行**：按空格键逐行执行消元步骤。
- **自动演示**：AI模式自动运行，模拟“贪吃蛇AI”路径选择逻辑。

---

## 个人心得摘录
> **玫葵之蝶**：  
> “当矩阵中出现 $|a|<\epsilon$ 时设为 $\epsilon$，$|1-a|<\epsilon$ 时设为 $1-\epsilon$，这是保证数值稳定的关键。”  
> **启示**：浮点问题需显式处理边界条件，不可依赖默认计算。

> **Kelin**：  
> “代码中直接对输入数据进行 $\epsilon$ 调整，避免复杂的条件分支。”  
> **启示**：竞赛编程中简洁性优先，合理利用微小量统一处理边界。

---

## 核心算法流程图解

```plaintext
Input → 边概率矩阵 → 调整边权 → 构造基尔霍夫矩阵
           ↓                ↑
       全局乘积计算      高斯消元求行列式
           ↓                ↑
最终答案 = 全局乘积 × 行列式结果 → Output
```

**关键颜色标记**：  
- 红色：边权调整与 $\epsilon$ 处理  
- 绿色：基尔霍夫矩阵构造  
- 蓝色：高斯消元过程

---
处理用时：83.44秒
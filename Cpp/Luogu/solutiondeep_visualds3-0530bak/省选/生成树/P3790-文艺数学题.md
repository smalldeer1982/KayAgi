# 题目信息

# 文艺数学题

## 题目背景

小Y在AK曼哈顿OI，CTSC和APIO之后，开始研究数学题。


## 题目描述

小Y有一张N个点，M条边的无向图（**可能有重边、自环**），每条边都有一个权值w。


你需要计算：所有**生成树的边权的最大公约数**之和，具体操作见样例。


由于答案可能很大，需要**对1000000007取模**。


## 说明/提示

### 样例1的解释



 ![](https://cdn.luogu.com.cn/upload/pic/13639.png) 

显然，这张图有8个不同的生成树。


用$(x,y,z)$表示x,y,z的最大公约数，则答案


$=(12,6,8)+(6,8,9)+(8,9,12)+(9,12,6)+(9,4,6)+(12,4,8)+(12,4,9)+(6,4,8)$


$=2+1+1+3+1+4+1+2$


$=15$

### 数据范围


对于20%的数据，$N\le 10, M\le 20$；

对于另外10%的数据，$N\le 12, M\le 24$；

对于另外20%的数据，$N\le 60, M\le 3000$，且满足$u_i+1=v_i$；

对于另外20%的数据，$N\le 40, M\le 1000, W\le 1000$；

对于另外15%的数据，$N\le 50, M\le 2000$；

对于所有100%的数据，$N\le 60, M\le 3000, W\le 1000000$；



## 样例 #1

### 输入

```
4 5  
1 2 12  
1 3 9  
2 4 6  
3 4 8  
1 4 4  ```

### 输出

```
15```

# AI分析结果



---

**算法分类**：数论（莫比乌斯反演）与图论（矩阵树定理）

---

### **综合分析与结论**

#### **核心思路**
1. **问题转化**：将生成树 GCD 之和转化为枚举所有可能的公约数 d，计算其贡献。
2. **矩阵树定理**：快速计算边权为 d 倍数时的生成树数量。
3. **莫比乌斯反演**：通过欧拉函数 φ(d) 直接求和，避免复杂反演计算。

#### **难点与解决**
- **暴力枚举不可行**：直接枚举生成树的边权组合复杂度爆炸。
- **优化枚举 d**：仅处理边数 ≥N-1 的 d 值，利用因数分解减少枚举量。
- **快速计算 F(d)**：通过矩阵树定理 O(N³) 计算生成树数量。

---

### **题解清单 (≥4星)**

1. **will7101 的题解（5星）**
   - **亮点**：详细推导反演过程，分阶段优化思路清晰，给出多数据范围解法。
   - **关键优化**：因子筛选 + 矩阵树定理的剪枝。

2. **Prean 的题解（4星）**
   - **亮点**：代码简洁高效，直接利用欧拉函数 φ(d) 累加贡献。
   - **实现技巧**：预处理 phi 函数，动态维护边集合。

---

### **最优思路提炼**

1. **数学建模**：将问题转化为求每个 d 的贡献，公式为 `ans = ∑φ(d) * F(d)`。
2. **因子筛选优化**：仅处理满足条件的因子，避免无效计算。
3. **矩阵树定理应用**：通过高斯消元快速计算生成树数量。

---

### **同类型题推荐**
- **洛谷 P6178**：矩阵树定理模板题。
- **洛谷 P3317**：生成树计数与边权运算结合。
- **洛谷 P5221**：欧拉函数与图论结合的应用。

---

### **可视化设计要点**

#### **动画流程**
1. **枚举因子 d**：以像素方块显示当前 d 值，红色高亮有效因子。
2. **筛选边集合**：用绿色标记满足 `d|w` 的边，展示边数统计。
3. **矩阵树计算**：动态绘制邻接矩阵，用黄色高亮消元过程。
4. **贡献累加**：显示当前 d 的 φ(d) 和 F(d)，蓝色进度条表示总和。

#### **复古游戏化**
- **像素音效**：每次完成因子枚举时播放 "beep" 音效，成功计算贡献时播放 "coin" 音效。
- **Canvas 绘制**：用 8-bit 风格网格表示矩阵，边集合用不同颜色线段表示。
- **自动演示**：AI 模式按 d 升序自动执行，暂停时显示当前因子贡献。

---

### **核心代码实现**

```cpp
// Prean 的代码核心逻辑（节选）
inline ui Solve(const ui&x){
    // 初始化矩阵
    for(i=1;i^n;++i)for(j=1;j^n;++j)G[i][j]=i^j?mod:0;
    // 添加边权为 x 倍数的边
    for(i=1;(j=i*x)<=mx;++i)for(ui&x:id[j])
        ++G[u[x]][u[x]],++G[v[x]][v[x]],--G[u[x]][v[x]],--G[v[x]][u[x]];
    // 高斯消元计算生成树数量
    return Gauss();
}

// 主函数中的贡献累加
for(i=2;i<=mx;++i){
    // 筛法预处理 phi
    if(!pos[i]){/* 计算质数情况下的 phi */}
    // 仅处理有效因子
    if(S>=n-1)ans=(ans+1ull*phi[i]*Solve(i))%mod;
}
```

---

### **个人心得摘录**
- **调试教训**：矩阵树定理中的行列式计算需注意取模和交换行时的符号变化。
- **优化顿悟**：因子筛选可结合边数统计，大幅减少无效枚举。

--- 

**可视化演示链接**：[伪代码动画示例](https://example.com/demo)（需自行实现交互逻辑）

---
处理用时：59.99秒
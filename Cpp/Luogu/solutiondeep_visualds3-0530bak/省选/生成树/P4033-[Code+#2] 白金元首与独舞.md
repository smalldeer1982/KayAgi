# 题目信息

# [Code+#2] 白金元首与独舞

## 题目背景

```cpp
到河北省 见斯大林 / 在月光下 你的背影 / 让我们一起跳舞吧
```
うそだよ~ 河北省怎么可能有 Stalin。


可是…… 可是如果 Stalin 把自己当作炸弹扔到地堡花园里来了呢？


怀揣着这份小小的希望，元首 Adolf 独自走进了花园。终有一天会重逢的吧，Stalin。或许是在此处，或许是在遥远的彼方。


无论如何，在此之前，好好装点一番花园，编排一段优美的舞步吧！


## 题目描述

元首把花园分为 $n$ 行 $m$ 列的网格。每个格子中都可以放置一个标识，指向上、下、左、右四个方向中的任意一个。元首位于一个格子时，会按照其中标识所指的方向进入周围的格子，或者走出花园（即目的格子不在网格之内）。举个例子 —— 对于下面的放置方式，元首从第 $3$ 行第 $2$ 列的格子开始，会沿着以红色标出的路径走出花园；从第 $2$ 行第 22 列的格子开始，则会在以蓝色标出的环路内不断地行走。

 ![](https://cdn.luogu.com.cn/upload/pic/12659.png) 

元首已经设计好了大部分格子的标识。元首用字符 L、R、U、D 分别表示指向左、右、上、下四个方向的标识，用字符 . 表示未决定的格子。现在，元首希望将每个 . 替换为 L、R、U、D 中任意一种，使得从花园中的任意一个格子出发，按照上述规则行走，都可以最终走出花园。


你需要编写程序帮助元首计算替换的不同方案数。两个方案不同当且仅当存在一个格子，使得两个方案中该格子内的标识不同。当然，由于答案可能很大，只需给出方案数除以 $10^9 + 7$所得的余数即可。


## 说明/提示

**样例解释**

第 $1$ 组数据中，将惟一的 . 替换成 R、U 或 D 均满足要求。


第 $2$ 组数据中，将左上方和右下方的两个 . 分别替换成 LR、LU、LD、UR、UU、UD、DR 或 DD 均满足要求。


第 $3$ 组数据中，没有待决定的格子，原本的安排会使得元首陷入无尽的环路，故答案为 $0$。该组数据与**题目描述**中的例子相同。


第 $4$ 组数据中，也没有待决定的格子，但原本的安排已经满足要求，故答案为 $1$。


令 $k$ 表示标记未确定（即包含 “.”）的格子总数。


对于所有数据，有 $1 \leq T \leq 10$，$1 \leq n, m \leq 200$，$0 \leq k \leq \min(nm, 300)$。

 ![](https://cdn.luogu.com.cn/upload/pic/12660.png) 

“... wie Stalin!”


题面与史实无关。


来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/吕时清 命题/吕时清 验题/王聿中，杨景钦

Git Repo：https://git.thusaac.org/publish/CodePlus201712

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
5
3 9
LLRRUDUUU
LLR.UDUUU
LLRRUDUUU
4 4
LLRR
L.LL
RR.R
LLRR
4 3
LRD
LUL
DLU
RDL
1 2
LR
2 2
..
..```

### 输出

```
3
8
0
1
192```

# AI分析结果



---

### 唯一算法分类
**矩阵树定理（有向图内向树计数）**

---

### 综合分析与结论
**核心思路**：  
将网格视为有向图，每个格子指向其箭头方向。未定格子（.）可连四条边。引入虚点表示外部，合法方案需形成以虚点为根的**内向树**。应用矩阵树定理统计生成树数目，通过缩点优化将规模从 O(nm) 降至 O(k)（k 为未定点数）。

**关键难点与解决**：  
1. **缩点优化**：预处理每个未定点四个方向最终到达的下一个未定点/虚点，避免直接处理全部网格点。  
2. **矩阵构建**：基尔霍夫矩阵 = 入度矩阵 - 邻接矩阵，删去虚点对应行列求行列式。  
3. **环检测**：DFS 预处理判断初始图中是否存在环，直接排除非法情况。

**可视化设计**：  
- **网格动态缩点**：用不同颜色标记未定点和确定路径，点击未定点展示其四个方向缩点结果（连线至目标点）。  
- **矩阵计算动画**：高亮基尔霍夫矩阵的构建步骤，高斯消元过程逐步显示行变换，突出主元选择与消元操作。  
- **复古像素风格**：8 位像素网格，节点用方块表示，边用闪烁线条，音效在缩点和计算完成时触发。

---

### 题解清单（4星以上）
1. **shadowice1984（5星）**  
   - **亮点**：记忆化搜索优化缩点，高效处理大规模网格；代码结构清晰，处理行列式时避免浮点运算。  
   - **心得**：通过预处理 `tr` 数组避免重复计算，显著降低时间复杂度。

2. **Rainybunny（4星）**  
   - **亮点**：代码简洁，明确分离环检测与缩点步骤；使用独立 `findUnknown` 函数实现路径压缩。  
   - **心得**：通过 `col` 数组标记 DFS 路径，有效检测初始环。

---

### 核心代码实现
**shadowice1984 的缩点与矩阵构建**  
```cpp
inline int dfs(int px, int py) { // 记忆化搜索缩点
    if (px<1 || px>n || py<1 || py>m) return ctt;
    if (tr[px][py]) return tr[px][py];
    switch(mde[px][py]) { // 递归查找下一个节点
        case 'L': tr[px][py]=dfs(px,py-1); break;
        case 'R': tr[px][py]=dfs(px,py+1); break;
        // ... 类似处理 U/D
    }
    return tr[px][py];
}

for (int i=1; i<=n; ++i) // 构建基尔霍夫矩阵
    for (int j=1; j<=m; ++j)
        if (mde[i][j]=='.')
            for (int k=0; k<4; ++k)
                add(tr[i][j], dfs(i+dx[k], j+dy[k]));
```

---

### 同类型题推荐
1. **P3317 [SDOI2014]重建**（矩阵树定理扩展）  
2. **P4208 [JSOI2008]最小生成树计数**（生成树计数变式）  
3. **P5296 [北京省选集训2019]生成树计数**（边权与生成树结合）

---

### 个人心得摘录
- **缩点时机**：必须在预处理阶段完成所有确定路径的压缩，否则无法降低矩阵规模。  
- **方向处理**：内向树要求边指向根，矩阵构造时需确保边方向正确（入度矩阵 - 邻接矩阵）。  
- **行列式符号**：高斯消元中行交换次数需记录，避免符号错误。

---

### 可视化与算法演示
**复古像素动画设计**：  
1. **网格绘制**：Canvas 绘制 8-bit 风格网格，未定点闪烁，确定路径用箭头表示。  
2. **缩点过程**：点击未定点后，显示四个方向路径追踪动画，终点高亮并连线。  
3. **矩阵计算**：基尔霍夫矩阵以像素字体显示，消元时当前行/列高亮，音效随步骤触发。  
4. **自动演示**：AI 模式自动遍历未定点缩点，背景音乐为 8-bit 循环旋律。

**交互示例**：  
```javascript
// 伪代码：Canvas 绘制网格与边
function drawGrid() {
    ctx.fillStyle = "#8B8BEC"; // 像素蓝
    grid.forEach((row, i) => row.forEach((cell, j) => {
        if (cell === '.') ctx.fillRect(j*20, i*20, 18, 18); // 未定点方块
        else drawArrow(cell.direction); // 绘制方向箭头
    }));
}
// 音效：缩点完成时播放
const sfx = new AudioContext();
function playBeep() { /* 生成 8-bit 音效 */ }
```

---
处理用时：73.14秒
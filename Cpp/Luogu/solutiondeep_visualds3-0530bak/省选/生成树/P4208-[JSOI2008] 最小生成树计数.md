# 题目信息

# [JSOI2008] 最小生成树计数

## 题目描述

现在给出了一个简单无向加权图。你不满足于求出这个图的最小生成树，而希望知道这个图中有多少个不同的最小生成树。（如果两棵最小生成树中至少有一条边不同，则这两个最小生成树就是不同的）。由于不同的最小生成树可能很多，所以你只需要输出方案数对 $31011$ 的模就可以了。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le n \le 100$，$1 \le m \le 1000$，$1\leq c_i\leq 10^9$。

## 样例 #1

### 输入

```
4 6
1 2 1
1 3 1
1 4 1
2 3 2
2 4 1
3 4 1```

### 输出

```
8
```

# AI分析结果



**算法分类**：生成树计数、矩阵树定理、分治策略

---

### **题解思路与算法要点**

1. **定理基础**  
   - **同一权值边数量相同**：所有最小生成树中，相同权值的边出现的次数相同。
   - **连通性相同**：处理完某个权值的边后，图的连通性在所有最小生成树中一致。

2. **核心步骤**  
   - **Kruskal预处理**：计算每个权值在最小生成树中的出现次数。
   - **分权值处理**：对每个权值的边，计算其生成树贡献的方案数。
   - **乘法原理**：将各权值的方案数相乘得到总结果。

3. **实现难点**  
   - **并查集回溯**：枚举边组合时需要保存并恢复并查集状态（不可路径压缩）。
   - **矩阵树定理的模数处理**：当模数非质数时，需用辗转相除法计算行列式。

---

### **题解评分（≥4星）**

1. **smarthehe (5星)**  
   - **亮点**：结合枚举与矩阵树定理，证明清晰，代码可读性高。
   - **核心代码**：基尔霍夫矩阵行列式计算，并查集缩点优化。

2. **老K (4.5星)**  
   - **亮点**：矩阵树定理实现完整，模数处理使用浮点转整型技巧。
   - **代码片段**：行列式计算的浮点优化与模运算结合。

3. **Siyuan (4星)**  
   - **亮点**：暴力枚举与矩阵树双实现，适合不同数据规模。
   - **调试心得**：强调不可路径压缩的并查集设计。

---

### **最优思路提炼**

1. **分权值缩点**  
   - 对每个权值边，先处理更小的边形成连通块，缩点后构建基尔霍夫矩阵。

2. **枚举法的优化**  
   - 对每个权值的边组合进行DFS枚举，利用并查集回溯避免重复计算。

3. **矩阵树定理的高效实现**  
   - 辗转相除法处理非质数模数，避免逆元计算。

---

### **同类型题与推荐题目**

1. **P2144 [FJOI2007] 轮状病毒**  
   - 基尔霍夫矩阵的直接应用。

2. **P3317 [SDOI2014] 重建**  
   - 生成树概率加权与矩阵树结合。

3. **P5297 [北京省选集训2019] 完美塔防**  
   - 分治策略与连通性处理。

---

### **核心代码实现**

```cpp
// 分权值处理的主逻辑（smarthehe 题解核心）
for (int i = 1; i <= tl; i++) {
    if (!is[i]) continue; // 跳过未使用的权值
    init(n); // 初始化并查集
    // 缩点处理其他权值的边
    for (int j = 0; j < cnt; j++) 
        if (mst[j].v != i) uni(mst[j].x, mst[j].y);
    // 构建基尔霍夫矩阵
    for (auto &e : edge[i]) {
        int u = bel[e.x], v = bel[e.y];
        deg[u][u]++, deg[v][v]++;
        g[u][v]++, g[v][u]++;
    }
    // 矩阵树计算生成树数量
    ans = ans * treecnt() % MOD;
}
```

---

### **可视化设计思路**

1. **动画流程**  
   - **步骤1**：展示Kruskal算法逐步加边，不同权值用颜色区分。
   - **步骤2**：缩点时，用网格合并显示连通块。
   - **步骤3**：矩阵树计算时，高亮行列式消元过程。

2. **复古像素风格**  
   - **颜色方案**：16色调色板，边权用不同色块，连通块用闪烁边框。
   - **音效**：加边时8-bit音效，错误选择时短促“哔”声。

3. **交互设计**  
   - **自动演示**：AI按Kruskal顺序逐步执行，用户可暂停观察矩阵计算。
   - **关卡积分**：每正确处理一个权值获得积分，失败则重试。

---

### **总结**

通过分权值处理与矩阵树定理的结合，本问题被高效分解。枚举法在小规模边数时直接可行，矩阵树定理则适用于大规模数据。可视化设计中，复古风格与交互式步骤可增强算法理解。

---
处理用时：66.43秒
# 题目信息

# [SHOI2016] 黑暗前的幻想乡

## 题目背景

四年一度的幻想乡大选开始了，最近幻想乡最大的问题是很多来历不明的妖怪涌入了幻想乡，扰乱了幻想乡昔日的秩序。但是幻想乡的建制派妖怪（人类）博丽灵梦和八云紫等人整日高谈所有妖怪平等，幻想乡多元化等等，对于幻想乡目前面临的种种大问题却给不出合理的解决方案。

风见幽香是幻想乡里少有的意识到了问题严重性的大妖怪。她这次勇敢地站了出来参加幻想乡大选，提出包括在幻想乡边境建墙（并让人类出钱），大力开展基础设施建设挽回失业率等一系列方案，成为了大选年出人意料的黑马并顺利地当上了幻想乡的大统领。

## 题目描述

幽香上台以后，第一项措施就是要修建幻想乡的公路。幻想乡一共有 $n$ 个城市，之前原来没有任何路。幽香向选民承诺要减税，所以她打算只修 $n-1$ 条公路将这些城市连接起来。但是幻想乡有正好 $n-1$ 个建筑公司，每个建筑公司都想在修路的过程中获得一些好处。虽然这些建筑公司在选举前没有给幽香钱，幽香还是打算和他们搞好关系，因为她还指望他们帮她建墙。所以她打算让每个建筑公司都负责一条路来修。

每个建筑公司都告诉了幽香自己有能力负责修建的路是哪些城市之间的。所以幽香打算 $n - 1$ 条能够连接幻想乡所有城市的边，然后每条边都交给一个能够负责该边的建筑公司修建，并且每个建筑公司都恰好修建一条边。

幽香现在想要知道一共有多少种可能的方案呢？两个方案不同当且仅当它们要么修的边的集合不同，要么边的分配方式不同。

## 说明/提示

#### 数据规模与约定

+ 对于 $20\%$ 的测试点，$n \le 5$。
+ 对于 $50\%$ 的测试点，$n \le 8$。
+ 对于 $60\%$ 的测试点，$n \le 10$。
+ 对于 $100\%$ 的测试点，$2 \leq n \le 17$，$0 \leq m_i \leq \frac{n(n - 1)}{2}$，$1 \leq u, v \leq n$。

## 样例 #1

### 输入

```
4
2 3 2 4 2
5 2 1 3 1 3 2 4 1 4 3
4 2 1 3 2 4 1 4 2```

### 输出

```
17```

# AI分析结果



## 算法分类
容斥原理、矩阵树定理

---

## 题解思路、算法要点与解决难点

### 核心思路
题目要求选择n-1条边构成生成树，每条边必须来自不同的公司。关键点在于利用**容斥原理**排除不满足条件的情况，结合**矩阵树定理**计算生成树数量。

1. **容斥原理**  
   - 目标是统计**恰好覆盖所有公司**的生成树数目。通过枚举排除某些公司的情况，计算其生成树数目，再根据排除公司数量的奇偶性加减贡献。
   - 公式：$$ans = \sum_{S \subseteq \text{公司集合}} (-1)^{|S|} \cdot f(S)$$，其中$f(S)$表示不使用集合$S$中公司的边时的生成树数目。

2. **矩阵树定理**  
   - 对于每个子集$S$，构建对应的基尔霍夫矩阵，计算其行列式得到生成树数目。处理时需要考虑重边（不同公司的边可能相同）。

### 解决难点
- **状态枚举**：遍历所有可能的公司子集（共$2^{n-1}$种），时间复杂度较高但可接受。
- **符号处理**：容斥的符号由排除的公司数量奇偶性决定，需正确应用$(-1)^{|S|}$。
- **行列式计算**：在模意义下使用高斯消元法，注意逆元和行变换对行列式符号的影响。

---

## 最优思路或技巧提炼
1. **容斥与矩阵树结合**：通过枚举排除的公司集合，将问题转化为多个矩阵树计算问题，利用容斥处理覆盖条件。
2. **状态压缩优化**：用二进制表示公司集合，快速判断包含的公司数量。
3. **行列式快速计算**：模意义下使用高斯消元法，通过行交换和行变换高效计算行列式。

---

## 同类型题或类似算法套路
- **生成树计数结合限制条件**：如边权限制、颜色限制等，常通过容斥或生成函数处理。
- **子集枚举与容斥**：如P3349 [ZJOI2016] 小星星，利用容斥处理标号冲突。

---

## 推荐题目
1. [P3349 [ZJOI2016] 小星星](https://www.luogu.com.cn/problem/P3349)  
   （容斥与树形DP结合）
2. [P3214 [HNOI2011] 卡农](https://www.luogu.com.cn/problem/P3214)  
   （集合划分与容斥）
3. [P4208 [JSOI2008] 最小生成树计数](https://www.luogu.com.cn/problem/P4208)  
   （矩阵树定理应用）

---

## 题解评分 (≥4星)
1. **hhoppitree (4.5星)**  
   - 思路清晰，代码简洁，利用位运算枚举状态，行列式计算高效。
   - 关键代码：
     ```cpp
     int ans = 0;
     for (int i = 1; i < (1 << n); ++i) {
         // 构建基尔霍夫矩阵并计算行列式
         ans += ((cnt & 1) ? -1 : 1) * det();
     }
     ```
2. **shadowice1984 (4.5星)**  
   - 详细解释容斥与矩阵树结合的原理，代码注释丰富，适合理解底层逻辑。
3. **Kelin (4星)**  
   - 代码结构清晰，使用DFS递归实现容斥，易于扩展其他问题。

---

## 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 1e9+7;
int n, a[20][20];
vector<pair<int, int>> edge[20];

int det(int size) {
    int res = 1, sign = 1;
    for (int i = 1; i <= size; ++i) {
        for (int j = i + 1; j <= size; ++j) {
            while (a[i][i]) {
                int div = a[j][i] / a[i][i];
                for (int k = i; k <= size; ++k) {
                    a[j][k] = (a[j][k] - 1ll * div * a[i][k] % mod + mod) % mod;
                }
                swap(a[i], a[j]);
                sign *= -1;
            }
            swap(a[i], a[j]);
            sign *= -1;
        }
        res = 1ll * res * a[i][i] % mod;
    }
    return (res * sign + mod) % mod;
}

int main() {
    cin >> n;
    for (int i = 0; i < n-1; ++i) {
        int m, u, v;
        cin >> m;
        while (m--) {
            cin >> u >> v;
            edge[i].emplace_back(u, v);
        }
    }
    
    int ans = 0;
    for (int mask = 1; mask < (1 << (n-1)); ++mask) {
        memset(a, 0, sizeof(a));
        int cnt = __builtin_popcount(mask);
        for (int i = 0; i < n-1; ++i) {
            if (mask & (1 << i)) {
                for (auto [u, v] : edge[i]) {
                    a[u][u]++, a[v][v]++;
                    a[u][v]--, a[v][u]--;
                }
            }
        }
        // 符号由排除的公司数量奇偶性决定
        int sign = (n-1 - cnt) % 2 ? -1 : 1;
        ans = (ans + sign * det(n-1)) % mod;
    }
    cout << (ans % mod + mod) % mod << endl;
    return 0;
}
```

---

## 可视化与算法演示
### 动画方案
1. **网格展示**：  
   - 每个节点表示为圆形，边显示为连线，当前处理的公司用高亮颜色标记。
2. **状态切换**：  
   - 每步显示当前枚举的公司集合，对应边的颜色变化（选中/排除）。
3. **行列式计算**：  
   - 动态展示矩阵变换过程，高亮当前处理的行和主元。

### 复古像素风格
- **Canvas绘制**：节点为8x8像素块，边为低分辨率线段，颜色区分不同公司。
- **音效设计**：  
  - 行交换时播放 "blip" 音效  
  - 行列式计算完成时播放 "power-up" 音效  
- **自动演示**：按步长自动切换公司集合，显示矩阵和生成树变化。

---

## 总结
本题通过容斥原理枚举所有可能排除的公司组合，结合矩阵树定理高效计算生成树数目。核心难点在于正确应用容斥的符号和高效计算行列式。可视化设计可通过动态展示公司选择和矩阵变换，帮助理解算法流程。

---
处理用时：450.74秒
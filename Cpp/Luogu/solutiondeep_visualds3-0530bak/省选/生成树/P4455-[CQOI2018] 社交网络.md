# 题目信息

# [CQOI2018] 社交网络

## 题目背景

当今社会，在社交网络上看朋友的消息已经成为许多人生活的一部分。通常，一个用户在社交网络上发布一条消息后，他的好友们也可以看见这条消息，并可能转发。转发的消息还可以继续被人转发，进而扩散到整个社交网络中。

## 题目描述

在一个实验性的小规模社交网络中我们发现，有时一条热门消息最终会被所有人转发。为了研究这一现象发生的过程，我们希望计算一条消息所有可能的转发途径有多少种。为了编程方便，我们将初始消息发送者编号为 $1$，其他用户编号依次递增。

该社交网络上的所有好友关系是已知的，也就是说对于 $a, b$ 两个用户，我们知道 $a$ 用户可以看到 $b$ 用户发送的消息。注意可能存在单向的好友关系，即 $a$ 能看到 $b$ 的消息，但 $b$ 不能看到 $a$ 的消息。

还有一个假设是，如果某用户看到他的多个好友转发了同一条消息，他只会选择从其中一个转发，最多转发一次消息。从不同好友的转发，被视为不同的情况。

如果用箭头表示好友关系，下图展示了某个社交网络中消息转发的所有可能情况。（初始消息是用户 $1$ 发送的，加粗箭头表示一次消息转发）

![](https://cdn.luogu.com.cn/upload/pic/17549.png)
![](https://cdn.luogu.com.cn/upload/pic/17550.png)
![](https://cdn.luogu.com.cn/upload/pic/17551.png)
![](https://cdn.luogu.com.cn/upload/pic/17552.png)
![](https://cdn.luogu.com.cn/upload/pic/17553.png)
![](https://cdn.luogu.com.cn/upload/pic/17554.png)

答案对 $10^4 + 7$ 取模。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 250$，$1 \leq m \leq n \times (n - 1)$，$1 \leq a, b \leq n$。

## 样例 #1

### 输入

```
4
7
2 1
3 1
1 3
2 3
3 2
4 3
4 2
```

### 输出

```
6```

# AI分析结果



## 唯一算法分类
**矩阵树定理（有向图生成树计数）**

---

## 综合分析与结论

### 核心算法流程与难点
1. **构造基尔霍夫矩阵**：  
   - 入度矩阵 `D`（对角线为每个点的入度）  
   - 邻接矩阵 `A`（若存在边 `u→v`，则 `A[v][u]` 减1）  
   - 基尔霍夫矩阵 `C = D - A`  

2. **删除根节点对应行列**：  
   - 删去矩阵中根节点（编号1）所在的行和列，得到 `(n-1)×(n-1)` 矩阵  

3. **高斯消元求行列式**：  
   - 通过行交换、加减倍行操作将矩阵转为上三角矩阵  
   - 行列式值为对角线元素乘积  
   - 模运算下需处理负数和除法（逆元）

### 题解思路对比
- **核心推导**：xiezhiyu 的题解详细证明了有向图矩阵树定理的正确性，通过柯西-比内公式和行列式乘积性质证明树形图与行列式的关系  
- **代码实现**：所有题解均采用构造基尔霍夫矩阵后高斯消元的流程，区别在于行列式求法优化（如快速逆元、行列交换优化）  

### 可视化设计要点
1. **矩阵构造动画**：  
   - 用**红色高亮**当前处理的边 `u→v`  
   - 在基尔霍夫矩阵中，用**黄色闪烁**标记 `D[v][v]++` 和 `A[v][u]--` 的更新  

2. **高斯消元演示**：  
   - **绿色框**标注当前主元行  
   - **蓝色箭头**显示行交换操作  
   - **灰色半透明**表示已处理的行列  
   - 消元时用**渐变色条**表示倍行加减过程  

3. **复古像素风格**：  
   - 矩阵元素用 8×8 像素块表示，数值以 8-bit 字体渲染  
   - 消元过程伴随经典 FC 音效：行交换时播放“跳跃音效”，消元完成时播放“升级音效”  

---

## 题解清单（≥4星）

### 1. autoint（★★★★☆）
- **亮点**：代码最简洁，直接调用高斯消元函数，变量命名清晰  
- **关键代码**：
  ```cpp
  for(int x,y; m--;) {
    read(x),read(y); // y->x
    --A[y-1][x-1],++A[x-1][x-1]; // 构造基尔霍夫矩阵
  }
  ```

### 2. Prean（★★★★☆）
- **亮点**：极致代码精简，行列交换优化减少运算量  
- **关键优化**：
  ```cpp
  if(a[j][i]) // 提前跳过零元素
  for(int k=i;k<=n;++k) a[j][k]=Del(a[j][k],d*a[i][k]%mod);
  ```

### 3. 月下萤火（★★★★☆）  
- **亮点**：完整注释与模块化设计，适合教学  
- **高斯消元**：显式分离逆元计算与行列式更新  

---

## 最优思路与代码实现

### 核心代码（Prean 题解关键部分）
```cpp
inline int Gauss(){
    for(int i=2;i<=n;++i){
        int pos=i;
        for(int j=i;j<=n;++j) if(a[j][i]) {pos=j; break;}
        std::swap(a[i],a[pos]); // 行交换
        int inv=pow(a[i][i]);   // 计算逆元
        for(int j=i+1;j<=n;++j){
            int d=a[j][i]*inv%mod;
            for(int k=i;k<=n;++k) // 消元操作
                a[j][k]=(a[j][k]-d*a[i][k]%mod+mod)%mod;
        }
    }
    int ans=1;
    for(int i=2;i<=n;++i) ans=ans*a[i][i]%mod;
    return ans;
}
```

### 关键技巧
- **逆元优化**：在高斯消元中，用 `a[j][i] * inv(a[i][i])` 代替浮点除法  
- **行列式符号处理**：行交换时 `ans = mod - ans` 避免负数  
- **内存优化**：直接修改原矩阵，无需额外存储  

---

## 相似题目推荐
1. **P6178** 【模板】Matrix-Tree 定理  
   - 无向图生成树计数，权值扩展  

2. **P3317** [SDOI2014] 重建  
   - 变种矩阵树定理，处理边存在概率  

3. **P4208** [JSOI2008] 最小生成树计数  
   - 结合矩阵树定理与最小生成树性质  

---

## 调试与心得摘录
- **负值处理**：题解中多次出现 `(a[i][j]%mod + mod)%mod`，确保矩阵元素非负  
- **根节点偏移**：`u--,v--` 因代码中节点编号从0开始，需与题目描述的1号根对齐  
- **数据规模**：注意 `n≤250`，需使用 O(n³) 高斯消元而非暴力枚举  

---

## 可视化与复古动画实现

### Canvas 绘制逻辑
```javascript
function drawMatrix(ctx, matrix) {
    for(let i=0; i<size; i++) {
        for(let j=0; j<size; j++) {
            ctx.fillStyle = (i == currentRow && j == currentCol) ? '#FF0000' : '#FFF';
            ctx.fillRect(j*32, i*32, 30, 30); // 32x32 像素块
            ctx.fillStyle = '#000';
            ctx.fillText(matrix[i][j], j*32+8, i*32+20); // 8-bit 字体
        }
    }
}
```

### 音效触发
```javascript
// 行交换时播放音效
function playSwapSound() {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(440, audioCtx.currentTime); // A4 音符
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

### 自动演示模式
```javascript
function autoRun() {
    if(step >= steps.length) return;
    visualizeStep(steps[step++]);
    setTimeout(autoRun, 1000); // 每秒执行一步
}
```

---
处理用时：68.58秒
# 题目信息

# [NOI2019] 回家路线

## 题目背景

本题原题数据强度较低，若想要测试较强数据可以去 [P6302](https://www.luogu.com.cn/problem/P6302)，除数据范围外均与原题相同。

## 题目描述

猫国的铁路系统中有 $n$ 个站点，从 $1 - n$ 编号。小猫准备从 $1$ 号站点出发，乘坐列车回到猫窝所在的 $n$ 号站点。它查询了能够乘坐的列车，这些列车共 $m$ 班，从$1 - m$编号。小猫将在 $0$ 时刻到达 $1$ 号站点。对于 $i$ 号列车，它将在时刻 $p_i$ 从站点 $x_i$ 出发，在时刻 $q_i$ 直达站点 $y_i$，小猫只能在时刻 $p_i$ 上 $i$ 号列车，也只能在时刻 $q_i$ 下 $i$ 号列车。小猫可以通过多次换乘到达 $n$ 号站点。一次换乘是指对于两班列车，假设分别为 $u$ 号与 $v$ 号列车，若 $y_u = x_v$ 并且 $q_u \leq p_v$，那么小猫可以乘坐完 $u$ 号列车后在 $y_u$ 号站点等待 $p_v - q_u$ 个时刻，并在时刻 $p_v$ 乘坐 $v$ 号列车。

小猫只想回到猫窝并且减少途中的麻烦，对此它用烦躁值来衡量。

- 小猫在站点等待时将增加烦躁值，对于一次 $t (t \geq 0)$ 个时刻的等待，烦躁值将增加 $At^2 + Bt + C$，其中 $A, B,C$ 是给定的常数。注意：小猫登上第一班列车前，即从 $0$ 时刻起停留在 $1$ 号站点的那些时刻也算作一次等待。

- 若小猫最终在时刻 $z$ 到达 $n$ 号站点，则烦躁值将再增加 $z$。

形式化地说，若小猫共乘坐了 $k$ 班列车，依次乘坐的列车编号可用序列 $s_1, s_2, \cdots , s_k$表示。该方案被称作一条可行的回家路线，当且仅当它满足下列两个条件：

1. $x_{s1} = 1$ , $y_{sk} = n$

2. 对于所有 $j (1 \leq j < k)$，满足 $y_{sj} = x_{s_{j+1}}$ 且 $q_{sj}\leq p_{s_{j+1}}$

对于该回家路线，小猫得到的烦躁值将为：

$$q_{s_k}+(A\times p_{s_1}^2+B\times p_{s_1}+C)+\sum_{j=1}^{k-1}(A(p_{s_{j+1}}-q_{s_j})^2+B(p_{s_{j+1}}-q_{s_j})+C)$$

小猫想让自己的烦躁值尽量小，请你帮它求出所有可行的回家路线中，能得到的最
小的烦躁值。题目保证至少存在一条可行的回家路线。


## 说明/提示

### 更多样例

您可以通过附加文件获得更多样例。

#### 样例 3

见附加文件的 `route/route3.in` 与 `route/route3.ans`。

该样例的数据类型与最终测试点 $5 \sim 8$ 一致。

#### 样例 4

见附加文件的 `route/route4.in` 与 `route/route4.ans`。

该样例的数据类型与最终测试点 $11 \sim 14$ 一致。

#### 样例 5

见附加文件的 `route/route5.in` 与 `route/route5.ans`。

该样例的数据类型与最终测试点 $18 \sim 20$ 一致。

### 样例 1 解释

共有三条可行的回家路线：

- 依次乘坐 1，4 号列车，得到的烦躁值为：$10 + (1 \times 3^2 + 5 \times 3 + 10) + (1 \times (9 - 4)^2 + 5 \times (9 - 4) + 10)= 104$
- 依次乘坐 2，4 号列车，得到的烦躁值为：$10 + (1 \times 5^2 + 5 \times 5 + 10) + (1 \times (9 - 7)^2 + 5 \times (9 - 7) + 10)= 94$
- 依次乘坐 3，4 号列车，得到的烦躁值为：$10 + (1 \times 6^2 + 5 \times 6 + 10) + (1 \times (9 - 8)^2 + 5 \times (9 - 8) + 10)= 102$

第二条路线得到的烦躁值最小为 $94$。

### 数据范围

对于所有测试点：$2\le n\le 10^5,1\le m\le 2\times 10^5,0 \le A \le 10 , 0 \le B, C \le 10^6,1 \le x_i, y_i \le n , x_i \neq y_i , 0 \le p_i < q_i \le 10^3$。

每个测试点的具体限制见下表：

| 测试点编号  |        $n$         |          $m$          | $A,B,C$ 的特殊限制 | 其他特殊条件 |
| :---------: | :----------------: | :-------------------: | :----------------: | :----------: |
|  $1\sim 2$  |     $\le 100$      |        $=n-1$         |         无         | $y_i=x_i+1$  |
|  $3\sim 4$  |     $\le 100$      | $\le 100$ |     $A=B=C=0$      | $y_i=x_i+1$  |
|  $5\sim 8$  | $\le 2\times 10^3$ |  $\le 4\times 10^3$   |     $A=B=C=0$      |  $x_i<y_i$   |
|     $9$     | $\le 2\times 10^3$ |  $\le 4\times 10^3$   |      $A=B=0$       |  $x_i<y_i$   |
|    $10$     | $\le 2\times 10^3$ |  $\le 4\times 10^3$   |       $A=0$        |  $x_i<y_i$   |
| $11\sim 14$ | $\le 2\times 10^3$ |  $\le 4\times 10^3$   |         无         |      无      |
|    $15$     |     $\le 10^5$     |  $\le 2\times 10^5$   |      $A=B=0$       |      无      |
| $16\sim 17$ |     $\le 10^5$     |  $\le 2\times 10^5$   |       $A=0$        |      无      |
| $18\sim 20$ |     $\le 10^5$     |  $\le 2\times 10^5$   |         无         |      无      |

## 样例 #1

### 输入

```
3 4 1 5 10
1 2 3 4
1 2 5 7
1 2 6 8
2 3 9 10```

### 输出

```
94```

## 样例 #2

### 输入

```
4 3 1 2 3
1 2 2 3
2 3 5 7
3 4 7 9```

### 输出

```
34```

# AI分析结果



## 唯一算法分类
动态规划-斜率优化

---

## 综合分析与结论
### 核心思路与算法要点
1. **状态定义**：以每班列车为状态单位，设 $f_i$ 表示乘坐第 $i$ 班列车到达终点时的最小烦躁值（不含到达时间）。
2. **转移方程**：$f_i = \min_{j \text{满足 } y_j=x_i \text{且 } q_j \leq p_i} (f_j + A(p_i - q_j)^2 + B(p_i - q_j) + C)$
3. **斜率优化**：将二次函数转化为直线方程，维护下凸包结构，通过单调队列或二分快速决策最优转移点。

### 解决难点
1. **时间与空间双重限制**：通过按列车出发时间排序，保证转移顺序合法性；对每个站点维护独立凸包，避免无效状态干扰。
2. **二次函数优化**：将转移方程改写为 $Y_j = f_j + A q_j^2 - B q_j$，$k_i = 2A p_i$，转化为寻找最小截距的直线问题。
3. **事件分桶处理**：将列车按出发时间分桶，动态插入凸包避免重复遍历。

### 可视化设计思路
1. **像素动画**：以 8-bit 风格展示列车按时间轴流动，不同颜色表示不同站点，凸包结构用动态折线图展示。
2. **关键元素高亮**：
   - 红色方块：当前处理的列车
   - 绿色折线：维护中的凸包
   - 黄色箭头：当前最优决策点
3. **音效触发**：列车插入凸包时播放“滴”声，找到最优解时播放通关音效。

---

## 题解清单（≥4星）
1. **Great_Influence（★★★★★）**  
   核心亮点：完整推导斜率优化过程，提出事件分桶处理策略，时间复杂度 O(m)  
   代码亮点：使用 vector 维护站点凸包，通过事件队列动态插入决策点  

2. **yzhang（★★★★☆）**  
   核心亮点：详细拆解转移方程，给出完整斜率判断公式  
   代码亮点：预处理按 q 排序，使用双端队列维护凸包  

3. **Shallowy（★★★★）**  
   核心亮点：结合决策单调性分析，给出四边形不等式证明  
   代码亮点：用 vector 实现动态凸包，事件触发式插入  

---

## 核心代码实现（斜率优化）
```cpp
struct Train { int x, y, p, q; };
vector<Train> trains;
vector<int> bucket[MAX_TIME]; // 按出发时间分桶
deque<int> dq[MAX_SITE];      // 每个站点的凸包队列

// 斜率优化插入新决策点
void insert(int site, int i) {
    auto Y = [&](int j) { 
        return f[j] + A * trains[j].q * trains[j].q - B * trains[j].q;
    };
    while (dq[site].size() >= 2) {
        int j = dq[site].back(), k = dq[site][dq[site].size()-2];
        if ((Y(i)-Y(j))*(trains[i].q-trains[k].q) <= (Y(i)-Y(k))*(trains[i].q-trains[j].q))
            dq[site].pop_back();
        else break;
    }
    dq[site].push_back(i);
}

// 主DP过程
for (int t = 0; t <= max_time; ++t) {
    for (int i : bucket[t]) { // 处理当前时间出发的列车
        int x = trains[i].x;
        while (!dq[x].empty() && trains[dq[x].front()].q > t) 
            dq[x].pop_front(); // 移除过期决策
        
        if (!dq[x].empty()) {
            int j = dq[x].front();
            f[i] = f[j] + A*(t - trains[j].q)*(t - trains[j].q) 
                 + B*(t - trains[j].q) + C;
        }
        insert(trains[i].y, i); // 插入新决策点
    }
}
```

---

## 同类型题与相似套路
1. **二次费用优化**：将二次函数转化为直线截距问题（例：LOJ 分治题）
2. **时间轴分桶**：按事件触发顺序处理状态（例：CF 221D）
3. **多凸包维护**：每个位置独立维护决策集合（例：APIO 特别行动队）

---

## 推荐练习题
1. **P3195 玩具装箱**（斜率优化基础）  
2. **P3628 特别行动队**（多凸包维护）  
3. **CF939F Cutlet**（时间轴分桶技巧）

---

## 可视化与复古动画
1. **Canvas 动态演示**：  
   - 横向时间轴，纵向站点编号，列车表示为移动的像素方块  
   - 凸包更新时绘制绿色折线，决策点用闪烁黄点标记  
2. **8-bit 音效设计**：  
   - 插入凸包：短促 "beep" 音  
   - 找到最优解：经典马里奥通关音乐片段  
3. **自动演示模式**：  
   - 按时间步进，自动播放算法流程  
   - 支持暂停/继续，速度调节（1x, 2x, 5x）  

---

## 总结
本题核心在于将二次费用问题转化为斜率优化模型，通过维护站点凸包实现高效转移。掌握分时间桶处理和凸包维护技巧是解题关键，暴力解法虽可通过但缺乏普适性。推荐重点理解斜率优化的数学推导和实现细节。

---
处理用时：77.38秒
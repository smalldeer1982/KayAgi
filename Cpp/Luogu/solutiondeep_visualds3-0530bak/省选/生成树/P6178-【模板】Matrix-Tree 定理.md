# 题目信息

# 【模板】Matrix-Tree 定理

## 题目描述

给定一张 $n$ 个结点 $m$ 条边的带权图（可能为无向图，可能为有向图）。

定义其一个生成树 $T$ 的权值为 $T$ 中所有边权的乘积。

求其所有不同生成树的权值之和，对 $10^9+7$ 取模。

---

注意：

1. 本题中，有向图的生成树指的是 **以 $1$ 为根的外向树**；

2. 两棵生成树 $T_1,T_2$ 不同，当且仅当存在存在一条边 $e$，满足 $e\in T_1,\ \ e\notin T_2$。

## 说明/提示

【样例 $1$ 解释】

样例 $1$ 中的无向图如左图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/pxtx9z5a.png)

右图为其一个权值为 $3\times 1\times 2\times 3=18$ 的生成树的例子。

---

【样例 $2$ 解释】

样例 $2$ 中的有向图如左图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/4276yln3.png)

右图为其一个权值为 $1\times 1\times 1\times 2=2$ 的生成树（以 $1$ 为根的外向树）的例子。

---

【数据范围】

对于 $100\%$ 的数据：$1\leq n\leq 300,\ \ 1\leq m\leq 10^5,\ \ t\in \{0,1\},\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^9$。

对于测试点 $1,2,3,4,5,6$，$t=0$；对于测试点 $7,8,9,10,11$，$t=1$。

图中 **可能** 存在重边和自环，重边算作多条边。

## 样例 #1

### 输入

```
5 8 0
2 3 1
1 2 3
4 5 1
4 2 2
3 5 2
3 4 3
3 4 1
3 3 5
```

### 输出

```
144
```

## 样例 #2

### 输入

```
5 9 1
1 2 3
3 2 1
1 3 1
2 4 2
3 5 1
4 3 4
3 5 1
5 4 1
4 4 6
```

### 输出

```
72
```

# AI分析结果



# 【模板】Matrix-Tree 定理 题解分析

## 唯一算法分类
矩阵树定理（Matrix-Tree Theorem）

---

## 综合分析与结论

### 核心算法流程
1. **矩阵构造**  
   - 无向图：度数矩阵（对角元素为相邻边权和）减邻接矩阵（记录边权）
   - 有向图（外向树）：出度矩阵（对角元素为入边权和）减邻接矩阵
2. **行列式计算**  
   - 删去根节点对应行列（有向图）
   - 高斯消元法计算行列式，注意模数 $10^9+7$ 的逆元优化
   - 交换行时符号反转，最终结果为对角线乘积乘以符号系数

### 可视化设计思路
1. **动画方案**  
   - **矩阵构造阶段**：高亮度数矩阵对角元素（蓝色）、邻接矩阵非对角元素（红色）
   - **高斯消元阶段**：当前主元行（黄色）、正在消元的行（绿色），交换行时闪烁提示
   - **符号变化**：右上角实时显示当前行列式符号（+/-）
2. **复古像素风格**  
   - 使用 8-bit 风格网格展示矩阵，每个元素用 16x16 像素块表示
   - 消元时播放「哔」声效，交换行时播放「咔嗒」声效，计算完成播放胜利音效
3. **交互控制**  
   - 步进模式：空格键单步执行消元
   - 速度调节：方向键控制动画速度（0.5x~3x）
   - AI 自动演示：按 A 键自动完成全过程

---

## 题解清单（≥4星）

### 1. command_block（★★★★★）
- **亮点**：完整推导行列式性质，代码实现简洁高效（$O(n^3)$）
- **关键代码**：
  ```cpp
  // 构造矩阵（有向图）
  a[f][t] = (a[f][t] - w + mod) % mod;
  a[t][t] = (a[t][t] + w) % mod;
  // 行列式计算（交换行处理符号）
  if (i != j) { swap(a[i], a[j]); tr = !tr; }
  ```
- **个人心得**："注意自环需要跳过，重边会自然累加"

### 2. Achtoria（★★★★☆）
- **亮点**：严谨数学证明 Cauchy-Binet 公式，覆盖无向/有向图统一处理
- **核心贡献**：证明「关联矩阵的乘积等于 Kirchhoff 矩阵」

### 3. zhylj（★★★★☆）
- **亮点**：代码模块化清晰，独立 `Det()` 函数实现高斯消元
- **优化技巧**：预处理逆元加速消元，时间复杂度严格 $O(n^3)$

---

## 核心代码实现

### 高斯消元（模 $10^9+7$）
```cpp
ll det(ll **a) {
  ll ans = 1; bool tr = 0;
  for (int j = 1; j < n; j++) {
    for (int i = j; i < n; i++) // 找主元行
      if (a[i][j]) { swap(a[i], a[j]); tr ^= 1; break; }
    ll inv = powM(a[j][j], mod - 2); // 模逆元
    for (int i = j + 1; i < n; i++) {
      ll t = (mod - a[i][j]) * inv % mod;
      for (int k = j; k < n; k++)
        a[i][k] = (a[i][k] + t * a[j][k]) % mod;
    }
    ans = ans * a[j][j] % mod;
  }
  return tr ? (mod - ans) % mod : ans;
}
```

---

## 同类型题拓展
1. **P4336 [SHOI2016]黑暗前的幻想乡**  
   （矩阵树定理 + 容斥原理）
2. **P3317 [SDOI2014]重建**  
   （带概率权值的生成树计数）
3. **P4208 [JSOI2008]最小生成树计数**  
   （矩阵树定理在最小生成树场景的应用）

---

## 可视化实现要点（复古像素版）
1. **Canvas 初始化**  
   ```javascript
   const canvas = document.getElementById('matrix-canvas');
   const ctx = canvas.getContext('2d');
   // 16x16 像素块，每个元素占 32x32 像素
   const drawCell = (val, x, y, color) => {
     ctx.fillStyle = color;
     ctx.fillRect(x*32, y*32, 32, 32);
     ctx.fillStyle = 'white';
     ctx.fillText(val, x*32+4, y*32+20);
   };
   ```
2. **音效触发**  
   ```javascript
   function playSound(effect) {
     const audio = new Audio(`sfx/${effect}.wav`);
     audio.volume = 0.3;
     audio.play();
   }
   // 消元时播放
   playSound('blip');
   ```

---

通过结合严谨的数学推导与直观的可视化交互，学习者能深入理解矩阵树定理的核心思想，快速掌握代码实现的关键技巧。

---
处理用时：73.81秒
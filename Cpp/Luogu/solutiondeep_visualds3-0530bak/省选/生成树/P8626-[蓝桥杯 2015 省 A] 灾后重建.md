# 题目信息

# [蓝桥杯 2015 省 A] 灾后重建

## 题目描述

Pear 市一共有 $N$（$ \le 50000$）个居民点，居民点之间有 $M$（$ \le 2\times 10^5$）条双向道路相连。这些居民点两两之间都可以通过双向道路到达。这种情况一直持续到最近，一次严重的地震毁坏了全部 $M$ 条道路。

震后，Pear 打算修复其中一些道路，修理第 $i$ 条道路需要 $P_i$ 的时间。不过，Pear 并不打算让全部的点连通，而是选择一些标号特殊的点让他们连通。

Pear 有 $Q$（$ \le 50000$）次询问，每次询问，他会选择所有编号在 $[l,r]$ 之间，并且编号 $\bmod{K}=C$ 的点，修理一些路使得它们连通。由于所有道路的修理可以同时开工，所以完成修理的时间取决于花费时间最长的一条路，即涉及到的道路中 $P_i$ 的最大值。

你能帮助 Pear 计算出每次询问时需要花费的最少时间么？这里询问是独立的，也就是上一个询问里的修理计划并没有付诸行动。

## 说明/提示

对于 $20\%$ 的数据，$N,M,Q \le 30$。

对于 $40\%$ 的数据，$N,M,Q \le 2000$。

对于 $100\%$ 的数据，$N \le 50000,M \le 2 \times 10^5,Q \le 50000.P_i \le 10^6.L_i,R_i,K_i$ 均在 $[1,N]$ 范围内，$C_i$ 在 $[0,K_i)$ 范围内。

时限 5 秒, 256M。

蓝桥杯 2015 年省赛 A 组 J 题。

## 样例 #1

### 输入

```
7 10 4
1 3 10
2 6 9
4 1 5
3 7 4
3 6 9
1 5 8
2 7 4
3 2 10
1 7 6
7 6 9
1 7 1 0
1 7 3 1
2 5 1 0
3 7 2 1```

### 输出

```
9
6
8
8```

# AI分析结果



**唯一算法分类**  
最小生成树 + 根号分治

---

### **题解思路、算法要点与解决难点**

**核心思路**  
1. **最小生成树转换**：将问题转化为在生成树上求指定点集的连通路径最大边权。  
2. **根号分治**：  
   - **大 K（K > √N）**：直接暴力枚举点，利用生成树上路径的 `max` 可叠加性，逐个合并点集。  
   - **小 K（K ≤ √N）**：预处理每个余数 `C` 的链，用区间查询数据结构（线段树/分块）快速求最大值。  

**解决难点**  
1. **路径合并的优化**：通过 LCA 和树链剖分/倍增法快速求路径最大值。  
2. **预处理与查询平衡**：通过根号分治将总时间复杂度控制在 `O(N√N)`。  

---

### **题解评分 (≥4星)**

1. **XLao (4星)**  
   - **亮点**：分块处理链上 `max`，虚树优化。  
   - **代码亮点**：使用分块回滚技术降低空间复杂度。  

2. **_lbw_ (4星)**  
   - **亮点**：Kruskal 重构树直接求 LCA，zkw 线段树优化区间查询。  
   - **代码亮点**：预处理所有 `K` 的余数链，查询时直接调用。  

3. **zhouyuhang (4星)**  
   - **亮点**：线段树合并记录 LCA 和路径 `max`，树剖维护边权。  
   - **心得**：强调避免过度套题，注重思维灵活性。  

---

### **最优思路或技巧提炼**

1. **根号分治的核心**  
   - **大 K 暴力**：点数量少，直接遍历合并。  
   - **小 K 预处理**：按余数分组，区间数据结构快速查询。  

2. **链上 `max` 的快速计算**  
   - **树链剖分**：将树分解为轻/重链，线段树维护链上最大值。  
   - **倍增法**：预处理每个点的 `2^k` 祖先及路径最大值。  

3. **LCA 的优化应用**  
   - **欧拉序 + ST 表**：快速求多组点的 LCA。  
   - **区间线段树合并**：合并区间时动态维护 LCA 和 `max`。  

---

### **同类型题或类似算法套路**

1. **LCA + 路径查询**：如 [P3379【模板】最近公共祖先](https://www.luogu.com.cn/problem/P3379)。  
2. **根号分治应用**：如 [P3396 哈希冲突](https://www.luogu.com.cn/problem/P3396)。  
3. **区间最值维护**：如 [P3865 ST 表](https://www.luogu.com.cn/problem/P3865)。  

---

### **推荐洛谷题目**

1. **P4211 [LNOI2014] LCA**（LCA 与路径统计）  
2. **P4592 [TJOI2018] 异或**（树剖 + 可持久化 Trie）  
3. **P6177 Count on a tree II/【模板】树分块**（树分块应用）  

---

### **可视化与算法演示**

**核心流程动画设计**  
1. **最小生成树构建**：  
   - 展示 Kruskal 算法逐步合并边，边权从小到大加入。  
   - **颜色标记**：已选边红色，未选边灰色。  

2. **根号分治演示**：  
   - **大 K 处理**：高亮暴力合并的路径，显示最大边权。  
   - **小 K 处理**：显示预处理的分组链，区间查询时高亮线段树节点。  

**复古像素风格设计**  
- **Canvas 绘制**：  
  - 生成树以网格形式呈现，节点为 8x8 像素方块。  
  - 路径边用不同颜色区分（绿色为当前查询路径）。  
- **音效触发**：  
  - **合并成功**：短促“滴”声。  
  - **查询完成**：上扬音调。  

**AI 自动演示模式**  
- **自动播放**：按步展示 Kruskal 建树、分块预处理、查询逻辑。  
- **关卡设计**：  
  - **关卡 1**：生成树构建。  
  - **关卡 2**：大 K 暴力合并。  
  - **关卡 3**：小 K 预处理与查询。  

---

### **代码片段（核心逻辑）**

```cpp
// 树剖求路径最大值（zhouyuhang 题解片段）
int query_path(int x, int y) {
    int res = 0;
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) swap(x, y);
        res = max(res, seg.query(1, dfn[top[x]], dfn[x]));
        x = fa[top[x]];
    }
    if (dep[x] > dep[y]) swap(x, y);
    if (x != y) res = max(res, seg.query(1, dfn[x] + 1, dfn[y]));
    return res;
}

// 分块处理小 K（XLao 题解片段）
void dfs_calc(int u, int f) {
    add(dep[u], val[u]); // 分块更新当前路径 max
    for (auto [v, id] : G[u]) {
        if (id > 0) answer[id] = max(answer[id], ask(dep[v] + 1));
        else ans[-id] = max(ans[-id], ask(dep[v] + 1));
    }
    for (int v : tree[u]) dfs_calc(v, u);
    roll_back(); // 回滚分块状态
}
```

---

### **总结**  
本题通过最小生成树与根号分治的结合，高效处理了动态连通性问题。核心在于灵活应用预处理与暴力平衡，结合树结构特性优化路径查询。

---
处理用时：83.93秒
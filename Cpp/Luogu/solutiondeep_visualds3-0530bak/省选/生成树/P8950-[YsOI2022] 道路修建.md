# 题目信息

# [YsOI2022] 道路修建

## 题目背景

Ysuperman 正在给他幼儿园里的小朋友们准备一场模板测试，下面是一道模板题，他希望你可以帮他验一下题目。

## 题目描述

某地新建了 $n$ 座城市，拟定建造 $m$ 条**单向**道路，其中第 $i$ 条道路起点为 $u_i$，终点为 $v_i$，建造费用为正整数 $w_i$。

然而在道路开始修建之前突发紧急情况，需要马上选择这些道路中的一些来修建使得所有城市的人都可以走到某 $k$ 座城市中（也就是说，所有城市的人都可以走到这 $k$ 座城市中的**至少一座**城市中），你想要知道，如果这 $k$ 座城市是等概率随机在 $n$ 座城市中的选定的，那么期望的最小修建费用是多少。

为了避免分数输入输出，你只需要输出答案对 $998244353$ 取模的结果。

## 说明/提示

#### 样例 1 解释

总共有三种选定集合城市的方案：

1. 选定集合在城市 $1$，那么选择建造 $2\to 1,3\to 1$ 两条道路花费最少，为 $2+4=6$。

2. 选定集合在城市 $2$，那么选择建造 $1\to 2,3\to 1$ 两条道路花费最少，为 $1+4=5$。

3. 选定集合在城市 $3$，那么选择建造 $1\to 2,2\to 3$ 两条道路花费最少，为 $1+3=4$。

所以期望最小花费为 $(6+5+4)/3=5$。

#### 样例 2 解释

有 $6$ 种选择集合城市的方法：

1. 选城市 $1,2$，最小花费 $9$。

2. 选城市 $1,3$，最小花费 $6$。

3. 选城市 $1,4$，最小花费 $7$。

4. 选城市 $2,3$，最小花费 $5$。

5. 选城市 $2,4$，最小花费 $6$。

6. 选城市 $3,4$，最小花费 $3$。

所以期望最小花费为 $(9+6+7+5+6+3)\div 6=6$。

#### 样例 3 解释

这里太小写不下，只配个图算了：

![](https://cdn.luogu.com.cn/upload/image_hosting/cdnuoook.png)

#### 样例 4 解释

当集合城市选在 $1,2,3$ 时，城市 $4$ 无论如何都无法达到 $1,2,3$ 中的任意一个，所以答案为 $-1$。

#### 数据范围

对于 $10\%$ 的数据，满足 $n\le 15$，$m\le 30$。

对于 $30\%$ 的数据，满足 $n\le 20$，$m\le 50$。

另有 $5\%$ 的数据，满足所有 $w_i$ 相等。

另有 $5\%$ 的数据，满足 $k=n$。

另有 $5\%$ 的数据，满足 $k=n-1$。

另有 $10\%$ 的数据，满足 $m=n$。

另有 $20\%$ 的数据，满足 $k=1$。

对于 $100\%$ 的数据，满足 $2\le n\le 10^5$，$1\le m\le 2\times 10^5$，$1\le k\le n$，$1\le u_i,v_i\le n$，$0\le w_i\le 998244352$。

## 样例 #1

### 输入

```
3 4 1
1 2 1
2 1 2
2 3 3
3 1 4```

### 输出

```
5```

## 样例 #2

### 输入

```
4 6 2
1 2 1
1 3 3
2 3 2
3 4 5
4 1 4
4 2 6```

### 输出

```
6```

## 样例 #3

### 输入

```
8 16 3
5 6 7
7 2 10
4 6 4
5 7 5
8 4 12
1 3 8
2 3 6
4 1 8
1 7 2
8 3 1
2 5 3
6 4 11
7 3 14
3 8 9
8 1 13
6 7 16```

### 输出

```
160432162```

## 样例 #4

### 输入

```
4 1 3
2 4 1```

### 输出

```
-1```

# AI分析结果



---

## 唯一算法分类  
**最小树形图（朱刘算法优化）**

---

## 综合分析与结论  
### 核心思路与难点  
题目本质是求所有 k 点集的**最小内向生成森林**的期望值。核心难点在于：  
1. 动态维护每个点的最小出边  
2. 处理基环树中的环并计算贡献  
3. 高效计算期望的数学转化  

### 算法流程  
1. **初始化可并堆**：每个点的出边存入带懒标记的可并堆  
2. **朱刘式缩环**：  
   - 寻找当前点的最小出边  
   - 若形成环，合并环内所有点的出边，并调整边权（减去环内最小边）  
3. **贡献计算**：对每条边，计算其所在集合未被选中时的组合数贡献  
4. **无解判断**：若存在集合大小 +k >n 则无解  

### 可视化设计  
- **动画流程**：  
  1. 初始状态展示所有节点和边（红色箭头表示边权）  
  2. 高亮当前处理节点（黄色闪烁），显示其最小出边（绿色箭头）  
  3. 发现环时，将环内节点合并为像素块（8位风格爆炸特效），出边集体变蓝并显示偏移量  
  4. 贡献计算区域动态显示组合数公式（C(n-s, k)）  
- **音效设计**：  
  - 缩点时播放经典 FC 炸弹音效  
  - 计算正确贡献时播放金币音效  

---

## 题解清单 (4星及以上)  
### 题解作者：tobie（4.5星）  
- **亮点**：  
  - 完整实现朱刘算法优化版  
  - 利用可并堆+懒标记处理边权偏移  
  - 组合数学拆解贡献计算  
- **心得引用**：  
  > "缩点后的问题与原问题完全等价，可以持续递归处理"  
  > "通过带标记的可并堆高效维护最小边"  

---

## 核心代码实现  
```cpp
// 可并堆节点定义与合并
struct HeapNode { int w, to, lz, l, r, h; };
vector<HeapNode> heap(N);
int merge(int x, int y) {
    if (!x || !y) return x + y;
    if (heap[x].w > heap[y].w) swap(x, y);
    pushdown(x);
    heap[x].r = merge(heap[x].r, y);
    if (heap[heap[x].l].h < heap[heap[x].r].h) swap(heap[x].l, heap[x].r);
    heap[x].h = heap[heap[x].r].h + 1;
    return x;
}

// 缩环核心逻辑
for (int u = 1; u <= n; u++) {
    while (!heap[u].empty()) {
        auto [w, v] = heap[u].top();
        if (find(u) == find(v)) heap.pop();
        else {
            ans += C(n - size[find(u)], k) * w;
            if (check_cycle(u, v)) {
                // 合并环内所有堆并调整边权
                int delta = w;
                while (cycle_not_done) {
                    heap[u] = merge(heap[u], heap[v]);
                    heap[v].add_lazy_tag(-delta);
                }
            }
        }
    }
}
```

---

## 同类型题目推荐  
1. **P4716** 最小树形图（朱刘算法模板）  
2. **P2607** 基环树DP（处理环结构）  
3. **CF875D** 高维期望与组合数学  

---

## 复古游戏化设计要点  
- **像素风格**：城市用不同颜色方块表示，道路为箭头  
- **自动演示**：按空格键触发缩点动画，伴随芯片音效  
- **计分板**：显示当前贡献和剩余环数，每处理一个环+100分  
- **失败特效**：无解时屏幕抖动并显示"GAME OVER"（8位字体）  

--- 

通过此分析，可深入理解基于朱刘算法的动态缩点策略与期望计算的巧妙结合，为处理类似图论问题提供核心思路。

---
处理用时：74.59秒
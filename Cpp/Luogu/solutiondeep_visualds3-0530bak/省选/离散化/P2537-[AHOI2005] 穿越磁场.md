# 题目信息

# [AHOI2005] 穿越磁场

## 题目描述

探险机器人在Samuel星球上寻找一块奇特的矿石，然而此时它陷入了一片神秘的磁场区域，动弹不得。

探险空间站立刻扫描了这片区域，绘制出该区域的磁场分布平面图。这片区域中分布了N个磁场，每个磁场呈正方形，且边与坐标轴平行。

例如下图中，存在3个磁场，白点表示机器人的位置，黑点表示矿石的位置：

 ![](https://cdn.luogu.com.cn/upload/pic/1642.png) 

科学家们分析平面图，进一步发现：这些磁场为大小不一的正方形，可能相交，甚至覆盖，但是它们的边缘不会重合，顶点也不会重合。

例如下面的两种情形是不会出现的：

 ![](https://cdn.luogu.com.cn/upload/pic/1643.png) 

科学家们给探险机器人启动了磁力罩，这样它就可以在磁场中自由穿越了。

初始时，探险机器人和所有矿石都不在任何磁场的边缘。由于技术限制，在穿越过程中机器人只能够水平或垂直移动，且不能够沿着磁场的边缘行动。

由于磁力罩的能量有限，科学家们希望探险机器人穿越尽量少的磁场边缘采集到这块矿石。例如上图中，探险机器人最少需要穿越两次磁场边缘。

现在小联请你编写程序，帮助科学家们设计探险机器人的路线，统计探险机器人最少需要穿越多少次磁场边缘。


## 样例 #1

### 输入

```
2
1 3 3 
2 1 4
0 0 3 4```

### 输出

```
2```

# AI分析结果



---

## 唯一算法分类
**最短路 + 离散化**

---

## 综合分析与结论

### 核心思路与难点对比
1. **离散化关键点**  
   所有题解均通过离散化磁场边界坐标，将无限平面转化为有限网格图。核心难点在于：
   - 必须插入中间坐标（如相邻坐标差>1时），否则可能错误阻断可行路径
   - 需添加外边界（如-10和1e9）处理绕行外部的情况
   ```cpp
   // 示例：插入中间坐标
   for_xy(i, 2, tx) if(Sx[i] - Sx[i-1] > 1) Sx[++tx] = Sx[i]-1;
   ```

2. **边权建模**  
   在离散化网格中，若移动方向跨越磁场边界则边权为1，否则为0。实现方式分为两类：
   - **方向标记法**（litble/Zwaire）：用`visx`/`visy`标记横向/纵向磁场边界
   - **坐标区间法**（D_14134）：遍历磁场坐标区间，直接标记边界

3. **最短路优化**  
   - **01BFS**（litble）：双端队列优化，0权边从队首插入，1权边从队尾插入
   - **SPFA**（D_14134/Betrayer）：适合稀疏图，但需队列判重
   ```cpp
   // 01BFS核心代码（litble）
   if(v[x][y][i]) q.push_back((PR){kx,ky});
   else q.push_front((PR){kx,ky});
   ```

---

## 题解清单（≥4星）

### 1. litble（★★★★★）
- **亮点**：01BFS实现高效最短路，代码结构清晰
- **关键代码**：离散化后标记磁场边界方向，双端队列处理边权
- **个人心得**：通过添加无限外边界处理绕行情况

### 2. D_14134（★★★★☆）
- **亮点**：完整实现SPFA，离散化流程注释详细
- **优化点**：通过坐标映射处理磁场边界，但未使用双端队列优化

---

## 最优思路与可视化设计

### 关键技巧提炼
1. **离散化插入中间点**  
   保证相邻离散化坐标差为1，避免路径误判：
   ```cpp
   for (int i=2; i<=tx; ++i)
     if (Sx[i]-Sx[i-1]>1) Sx[++tx] = Sx[i]-1;
   ```
2. **方向标记法建图**  
   将磁场边界标记在网格的行/列方向，便于快速判断边权：
   ```cpp
   // 横向边权标记（litble）
   for(RI j=X1;j<X2;++j)
     v[j][Y1][2] = v[j][Y2-1][3] = 1; // 2/3表示左右方向
   ```

### 可视化方案设计
1. **像素化网格动画**  
   - **Canvas绘制**：用不同颜色区分磁场区域（红色）、普通网格（灰色）、当前路径（蓝色）
   - **步进演示**：高亮当前网格与移动方向，穿越磁场时播放"哔"音效
   ```javascript
   // 伪代码：绘制网格
   ctx.fillStyle = isMagnetic ? "#FF0000" : "#CCCCCC";
   ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
   ```

2. **AI自动演示模式**  
   - **自动播放**：按最短路径顺序移动，每步延迟200ms
   - **音效触发**：跨越磁场时播放高音调，终点到达时播放胜利音效

3. **复古游戏UI**  
   - **8-bit风格**：使用NES调色板（#306082主色，#000000边界）
   - **音效设计**：
     - 移动音效：方波短音（时长50ms）
     - 错误提示：三角波下降音调

---

## 同类型题与推荐
1. **相似套路题**  
   - P1141 01迷宫（离散化+连通块）
   - P2296 寻找道路（最短路+条件过滤）
   - P1825 [USACO11OPEN]Corn Maze S（网格最短路）

---

## 核心代码实现（litble版）
```cpp
void prework() {
    // 离散化并插入中间点
    sort(bx+1, bx+n+n+3);
    js1=1; for(RI i=2;i<=n+n+2;++i) 
        if(bx[i]!=bx[js1]) bx[++js1]=bx[i];
    // 标记磁场边界方向
    for(RI j=X1; j<X2; ++j)
        v[j][Y1][2] = v[j][Y2-1][3] = 1;
}

void bfs() {
    deque<PR> q;
    q.push_front((PR){sx, sy});
    while(!q.empty()) {
        PR kl = q.front(); q.pop_front();
        // 处理四个方向的移动
        for(RI i=0; i<4; ++i) {
            int kx = x+mvx[i], ky = y+mvy[i];
            if(dis[kx][ky] > dis[x][y] + v[x][y][i]) {
                if(v[x][y][i]) q.push_back((PR){kx, ky});
                else q.push_front((PR){kx, ky});
            }
        }
    }
}
```

---

## 个人心得摘录
> "离散化时必须插入中间坐标，否则相邻坐标差过大会导致路径被错误阻断。调试时发现机器人绕行外部的情况，添加-10和1e9作为外边界后解决。" —— litble

> "最初直接用SPFA结果WA，发现磁场边界标记方向错误，改为区分横向/纵向标记后AC。" —— D_14134

---

## 知识扩展
**离散化最短路通用解法**：
1. 提取所有关键坐标（起点/终点/图形顶点）
2. 排序去重后插入必要中间点
3. 构建网格图并标记特殊边权
4. 选择最短路算法（01BFS优先于SPFA）

---

通过该方案，学习者可深入理解离散化与网格最短路的核心思想，并借助可视化工具直观感受算法执行过程。

---
处理用时：68.99秒
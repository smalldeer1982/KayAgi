# 题目信息

# [JSOI2010] 缓存交换

## 题目背景

感谢@ACdreamer 贡献数据

## 题目描述

在计算机中，CPU只能和高速缓存Cache直接交换数据。当所需的内存单元不在Cache中时，则需要从主存里把数据调入Cache。此时，如果Cache容量已满，则必须先从中删除一个。 

例如，当前Cache容量为3，且已经有编号为10和20的主存单元。 
此时，CPU访问编号为10的主存单元，Cache命中。 

接着，CPU访问编号为21的主存单元，那么只需将该主存单元移入Cache中，造成一次缺失（Cache Miss）。 

接着，CPU访问编号为31的主存单元，则必须从Cache中换出一块，才能将编号为31的主存单元移入Cache，假设我们移出了编号为10的主存单元。 

接着，CPU再次访问编号为10的主存单元，则又引起了一次缺失。我们看到，如果在上一次删除时，删除其他的单元，则可以避免本次访问的缺失。 

在现代计算机中，往往采用LRU(最近最少使用)的算法来进行Cache调度——可是，从上一个例子就能看出，这并不是最优的算法。 
对于一个固定容量的空Cache和连续的若干主存访问请求，聪聪想知道如何在每次Cache缺失时换出正确的主存单元，以达到最少的Cache缺失次数。

## 说明/提示

在第4次缺失时将3号单元换出Cache。 

## 样例 #1

### 输入

```
6 2
1 2 3 1 2 3```

### 输出

```
4```

# AI分析结果



## 唯一算法分类
贪心算法（使用优先队列维护下次访问时间）

---

## 综合分析与结论
### 核心思路
**贪心策略**：当缓存满且需要替换时，移除**下一次访问最晚**的主存单元。  
**数据结构**：优先队列（最大堆）维护缓存中各单元的下次访问时间。  
**预处理**：离散化处理主存编号 + 反向遍历构建 next 数组（记录每个位置的下次访问时间）。

### 解决难点
1. **离散化处理**：将大范围的主存编号映射到小范围，便于数组操作。
2. **无效元素清理**：优先队列中可能存在已移出缓存的元素，需在每次操作前清理堆顶无效元素。
3. **动态更新**：每次访问时需更新当前元素的下次访问时间，并重新入堆。

### 可视化设计
- **动画流程**：
  1. **主存访问序列**：横向流水线显示待访问的主存单元，当前访问项高亮为黄色。
  2. **缓存状态**：用 8-bit 像素方块表示缓存槽位，绿色表示已缓存，红色表示被替换。
  3. **优先队列**：右侧显示堆结构，节点显示（下次访问时间, 主存ID），最大节点闪烁提示。
  4. **替换动画**：替换时显示红色箭头从堆顶指向被替换的缓存槽位，播放“哔”音效。
  5. **音效反馈**：缓存命中时播放清脆音效，缺失时播放低沉音效。

- **复古风格**：
  - **调色板**：使用 NES 风格的 8 色调色板（绿、红、黄、蓝为主）。
  - **音效设计**：使用 Web Audio API 生成 8-bit 音效（方波+噪声）。

---

## 题解清单（≥4星）
### 1. CW666 题解（⭐⭐⭐⭐⭐）
- **亮点**：代码结构清晰，优先队列维护时主动清理无效元素，注释详细。
- **关键代码**：
  ```cpp
  while (!h.empty() && !vis[h.top().second]) h.pop();
  if (vis[a[i]]) h.push(make_pair(next[i], a[i]));
  else {
      cnt++; // 缺失计数
      if (sum >= m) vis[h.top().second] = 0; // 替换逻辑
      h.push(make_pair(next[i], a[i]));
  }
  ```

### 2. SuperJvRuo 题解（⭐⭐⭐⭐）
- **亮点**：离散化与 next 数组构建一气呵成，代码简洁高效。
- **技巧**：反向遍历构建链表式 next 数组：
  ```cpp
  for (int i = n; i >= 1; --i) {
      next[i] = last[a[i]]; // 记录下次访问位置
      last[a[i]] = i; // 更新最后出现位置
  }
  ```

### 3. hovny 题解（⭐⭐⭐⭐）
- **亮点**：利用 `lower_bound` 简化离散化，优先队列直接存储下标。
- **核心逻辑**：维护 `vis` 数组标记缓存状态，动态更新堆：
  ```cpp
  if (!vis[b[i]]) {
      ans++; // 缺失计数
      if (cache.size() == m) cache.pop(); // 替换
      cache.push(i); // 新元素入堆
  }
  ```

---

## 最优思路提炼
### 关键技巧
1. **反向构建 next 数组**：从后向前遍历，记录每个位置的下次访问时间。
2. **堆的无效元素清理**：在每次堆操作前，循环检查堆顶元素是否仍在缓存中。
3. **离散化映射**：使用 `sort + unique + lower_bound` 三步压缩主存编号。

### 代码模板
```cpp
// 离散化
sort(b, b+n);
int k = unique(b, b+n) - b;
for (int i=0; i<n; i++) 
    a[i] = lower_bound(b, b+k, a[i]) - b;

// 构建 next 数组
memset(last, INF, sizeof(last));
for (int i=n-1; i>=0; i--) {
    next[i] = last[a[i]];
    last[a[i]] = i;
}

// 贪心维护缓存
priority_queue<pair<int, int>> pq;
int ans = 0, cnt = 0;
for (int i=0; i<n; i++) {
    if (in_cache[a[i]]) {
        pq.push({next[i], a[i]});
        continue;
    }
    ans++;
    if (cnt >= m) {
        in_cache[pq.top().second] = false;
        pq.pop();
    }
    pq.push({next[i], a[i]});
    in_cache[a[i]] = true;
    cnt = min(cnt+1, m);
}
```

---

## 类似题目推荐
1. [P3419 [POI2005]BAN-Bank Notes](https://www.luogu.com.cn/problem/P3419)  
   - 同类型贪心策略，需动态维护最优选择。
2. [CF802A Heidi and Library](https://www.luogu.com.cn/problem/CF802A)  
   - 缓存替换问题的变种，需结合费用计算。
3. [P2088 果汁店的难题](https://www.luogu.com.cn/problem/P2088)  
   - 贪心+优先队列维护资源分配。

---

## 个人心得摘录
- **离散化陷阱**：`lower_bound` 前必须确保数组有序，否则映射错误。（CW666 题解中的排序步骤）
- **堆维护误区**：直接删除堆顶可能遗留无效元素，需在每次操作前主动清理。（SuperJvRuo 题解中的 `while (!pq.empty() && !vis[...])`）
- **逆向思维**：构建 next 数组时，反向遍历可高效记录下次访问时间，避免双重循环。（hovny 题解中的反向遍历技巧）

---

## 可视化算法演示（伪代码）
```javascript
// Canvas 绘制缓存状态
function drawCache() {
    ctx.fillStyle = "#306230"; // NES 绿色
    for (let i = 0; i < cacheSize; i++) {
        if (cache[i]) {
            drawPixelBlock(10 + i*20, 50, 15, 15); // 绘制缓存槽位
        }
    }
}

// 播放 8-bit 音效
function playSound(type) {
    const osc = audioCtx.createOscillator();
    osc.type = type === 'hit' ? 'square' : 'noise';
    osc.frequency.setValueAtTime(type === 'hit' ? 880 : 220, audioCtx.currentTime);
    osc.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.1);
}

// 自动演示循环
function autoPlayStep() {
    if (currentStep >= n) return;
    const mem = accessSequence[currentStep];
    if (cache.has(mem)) {
        playSound('hit');
    } else {
        playSound('miss');
        if (cache.size >= m) {
            const victim = findFurthestNext(); // 选择替换目标
            cache.delete(victim);
        }
        cache.add(mem);
    }
    currentStep++;
    requestAnimationFrame(autoPlayStep);
}
```

---
处理用时：82.02秒
# 题目信息

# [BJWC2018] 第k大斜率

## 题目描述

在平面直角坐标系上，有 $n$ 个不同的点。任意两个不同的点确定了一条直线。请求出所有斜率存在的直线按斜率从大到小排序后，第 $k$ 条直线的斜率为多少。

为了避免精度误差，请输出斜率向下取整后的结果。（例如：$\lfloor 1.5 \rfloor = 1$，$\lfloor -1.5 \rfloor = -2$）。

## 说明/提示

**【样例说明】**

符合要求的直线的斜率分别为 $-3, -\frac{1}{2}, \frac{2}{3}, 1, 2, \frac{5}{2}$ 。

**【数据规模和约定】**

令 $M$ 为所有斜率存在的直线的数量 。

对于 $10 \%$ 的数据，$1 \le n \le 10$。  
对于 $20 \%$ 的数据，$1 \le n \le 100$，$|x_i|, |y_i| \le {10}^3$。  
对于 $30 \%$ 的数据，$1 \le n \le 1000$。  
对于 $40 \%$ 的数据，$1 ≤ n ≤ 5000$。  
对于另 $20 \%$ 的数据，满足 $k = 1$ 。  
对于另 $20 \%$ 的数据，满足 $1 \le x_i, y_i \le {10}^3$。  
对于 $100 \%$ 的数据，$1 \le n \le 100000$，$1 \le k \le M$，$|x_i|, |y_i| \le {10}^8$。

## 样例 #1

### 输入

```
4 1
-1 -1
2 1
3 3
1 4```

### 输出

```
2```

# AI分析结果



## 算法分类
二分答案 + 二维偏序统计

---

## 题解思路与核心难点

### 算法核心思想
1. **二分答案**：在可能的斜率范围内（-2e8到2e8）进行二分，每次假设中值 mid 是第k大的斜率。
2. **二维偏序统计**：将问题转化为统计满足以下条件的点对数量：
   - 按 x 坐标升序排列，保证 x_j > x_i 时 j > i
   - 计算每个点的 t = y - mid*x，统计 t_j > t_i 且 j > i 的顺序对数量

### 解决难点
1. **x相等时的处理**：排序时对相同 x 的点按 y 降序排列，避免计入无效斜率。
2. **离散化优化**：树状数组实现时需对 t 值离散化以压缩空间。
3. **高效统计顺序对**：归并排序的合并阶段可动态统计顺序对，时间复杂度稳定 O(n log n)。

---

## 题解评分（≥4星）

### 1. Zilljy258（⭐⭐⭐⭐⭐）
- **亮点**：树状数组实现，处理离散化完整，代码结构清晰。
- **代码**：排序与离散化逻辑严谨，二分边界处理正确。
```cpp
// 核心 check 函数
bool check(int mid) {
    for(int i=1; i<=n; i++) 
        p[i].t = p[i].y - 1ll * mid * p[i].x;
    sort(p + 1, p + n + 1);
    BIT::clear();
    ll rnk = 0;
    for(int i=1; i<=n; i++) {
        rnk += BIT::query(p[i].idx - 1);
        BIT::update(p[i].idx);
    }
    return rnk >= k;
}
```

### 2. 傅思维666（⭐⭐⭐⭐）
- **亮点**：归并排序实现，代码简洁易懂，无离散化步骤。
- **心得**：通过归并合并时的计数技巧避免树状数组的离散化。
```cpp
void merge_sort(int l,int r) {
    if(l==r) return;
    int mid=(l+r)>>1;
    merge_sort(l,mid);
    merge_sort(mid+1,r);
    int i=l,j=mid+1,k=l;
    while(i<=mid&&j<=r) {
        if(a[i]<=a[j]) 
            t[k++]=a[i++], ans += r-j+1;
        else t[k++]=a[j++];
    }
    // ... 后续处理
}
```

### 3. Dark_lightrq（⭐⭐⭐⭐）
- **亮点**：归并实现中强调相同x的处理，代码注释详细。
- **关键代码**：
```cpp
bool cmp(node a,node b){
    return a.x^b.x?a.x<b.x:a.y>b.y;
}
```

---

## 最优思路提炼
1. **二分框架**：通过二分将问题转化为计数问题。
2. **二维偏序转换**：将斜率比较转化为 t 值的顺序对统计。
3. **归并排序优化**：无需离散化，合并时直接统计顺序对数量。

---

## 相似题目推荐
1. **P1908 逆序对**：二维偏序基础题。
2. **P3810 三维偏序**：CDQ分治的经典应用。
3. **P2163 园丁的烦恼**：二维数点问题，树状数组应用。

---

## 可视化与算法演示

### 核心算法流程动画设计
1. **初始化**：画布展示排序后的点，x轴从左到右递增，相同x的点按y降序排列。
2. **二分步骤**：用滑动条调节mid值，动态显示当前mid对应的t值分布。
3. **归并过程**：
   - **分治可视化**：递归拆分数组时用不同颜色区块表示。
   - **合并计数**：高亮当前比较的左右元素，若左元素 <= 右元素，显示累计的右侧剩余元素数量。
4. **树状数组操作**：展示离散化后的t值插入与查询过程，节点动态高亮。

### 复古像素风格设计
- **颜色方案**：8位色，绿色表示已处理点，红色表示当前操作点。
- **音效**：
  - `merge` 合并时播放短促“哔”声。
  - 找到正确mid时播放胜利音效。
- **自动演示**：AI自动调节mid，以贪心策略逼近正确值，类似二分搜索动画。

---

## 代码片段（归并实现）
```cpp
bool check(int mid) {
    for(int i=1; i<=n; i++) 
        a[i] = p[i].y - mid * p[i].x;
    ans = 0;
    merge_sort(1, n);
    return ans >= k;
}

void merge_sort(int l, int r) {
    if(l == r) return;
    int mid = (l + r) >> 1;
    merge_sort(l, mid);
    merge_sort(mid+1, r);
    int i = l, j = mid+1, k = l;
    while(i <= mid && j <= r) {
        if(a[i] <= a[j]) {
            ans += r - j + 1; // 统计右侧剩余元素
            tmp[k++] = a[i++];
        } else {
            tmp[k++] = a[j++];
        }
    }
    // 合并剩余元素
}
```

该代码通过归并排序的合并阶段动态统计顺序对，无需额外数据结构，适合教学演示。

---
处理用时：87.44秒
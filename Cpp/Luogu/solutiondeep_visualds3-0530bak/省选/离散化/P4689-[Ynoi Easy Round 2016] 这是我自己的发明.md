# 题目信息

# [Ynoi Easy Round 2016] 这是我自己的发明

## 题目背景

一切伟大的世界历史事件与人物，可以说都会出现两次

第一次是作为悲剧出现

第二次，则是作为笑剧出现

——《路易.波拿巴的雾月十八日》

感动、

痛苦、

以及快乐、

都只是遥不可及的宝石

即便如此，人们啊，

获得幸福吧！

![](https://cdn.luogu.com.cn/upload/pic/21098.png)

世界将在7月20日终结

世界回归天空的日子

万物被天空侵染的日子

回归天空的日子

世界必须回归

世界的极限

世界的尽头

世界的终结

![](https://cdn.luogu.com.cn/upload/pic/21099.png)

你看…那就是极限…最尽头的天空

如今，已无应该之事了如今，已无忘却之物了

不需要的话语

![](https://cdn.luogu.com.cn/upload/pic/21100.png)

告别了永不相交的平行，我被吸进了…

垂直下落的世界

![](https://cdn.luogu.com.cn/upload/pic/21101.png)

虽哭亦喜

虽悲亦喜

各种感情混在一起...

比起其他所有，想必还是高兴占多吧

她高兴地抱着我

紧紧地抱着

再也不会松开了...

想永远这样...

她的思绪，以比语言更快的速度，传达给了我

有些东西，比语言更快

她的思绪，以比语言更快的速度，传达给了我

有些东西，比语音更准确

世界上无论多么短暂的瞬间，都有意义

有意义

块临近终结了

最后的瞬间

啊啊...

远方的警笛声

黑色的天空

月正笑

地正润潮

星正舞

风正凉

在我怀中，温暖的，

橘希实香

![](https://cdn.luogu.com.cn/upload/pic/21103.png)

她在我的怀中...静静地合上了双眼

然后我也...

静静地合上了双眼

## 题目描述

您正在打 galgame，然后突然家长进来了，于是您假装在写数据结构题：

给一个树，$n$ 个点，有点权，初始根是 1。

$m$ 个操作，种类如下：

`1 x` 将树根换为 $x$。

`2 x y` 给出两个点 $x,y$，从 $x$ 的子树中选每一个点，$y$ 的子树中选每一个点，求点权相等的情况数。


## 说明/提示

Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477

【数据范围】   
对于 $100\%$ 的数据，$1\le n \le 10^5$，$1 \le m \le 5\times 10^5$ , $1 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
5 5
1 2 3 4 5
1 2
1 3
3 4
3 5
2 4 5
2 1 5
2 3 5
1 5
2 4 5```

### 输出

```
0
1
1
1```

# AI分析结果



## 唯一算法分类：莫队算法 + 根号分治

---

### 核心思路与解决难点

1. **DFS序转换与换根处理**  
   - 将树转化为DFS序，换根操作通过判断根的位置动态调整子树对应的区间。当根在某个节点的子树中时，该节点的子树会被拆分为两个连续区间（原DFS序首尾部分）。

2. **莫队算法拆解区间对**  
   - 将每个查询的子树区间拆分为多个一维区间对，利用莫队算法离线处理这些区间对的统计。通过容斥原理将二维问题转化为一维前缀和的加减操作。

3. **根号分治优化复杂度**  
   - 对于出现次数较多的颜色，单独遍历所有出现位置计算贡献；对于出现次数较少的颜色，使用分块维护二维数点，避免高复杂度查询。

---

### 题解评分（≥4星）

1. **shadowice1984（★★★★★）**  
   - **亮点**：结合根号分治，分别处理高频和低频颜色，平衡时间复杂度。  
   - **关键代码**：预处理颜色出现次数，高频暴力遍历，低频分块统计。

2. **FlashHu（★★★★☆）**  
   - **亮点**：简化区间拆分为最多4个查询，利用分块替代树状数组优化扫描线。  
   - **关键代码**：`AddQuery`函数将子树区间拆解为四个前缀区间组合。

3. **yuzhechuan（★★★★☆）**  
   - **亮点**：通过倍长DFS序将环形区间转为线性，莫队处理更简洁。  
   - **关键代码**：`calc`函数动态生成换根后的区间组合。

---

### 最优技巧提炼

- **DFS序动态调整**：换根时通过LCA判断子树区间，拆分为首尾两段。  
- **莫队容斥**：将二维区间查询转化为前缀和加减，降低维度。  
- **分块优化**：对低频颜色使用分块统计，高频颜色直接暴力计算。

---

### 同类型题与套路

- **类似问题**：区间交/并的计数问题（如P5268 [SNOI2017]一个简单的询问）。  
- **通用解法**：DFS序转换 + 莫队离线处理，动态调整区间拆分。

---

### 推荐练习题

1. **P5268 [SNOI2017]一个简单的询问**（区间交贡献统计）  
2. **P4074 [WC2013]糖果公园**（树上莫队）  
3. **P3245 [HNOI2016]大数**（分块处理区间统计）

---

### 可视化设计思路

1. **DFS序转换动画**  
   - **颜色标记**：原树节点按DFS序编号，换根时高亮拆分后的区间。  
   - **步骤演示**：点击换根按钮，动态显示子树区间拆分（如红色标记原区间，蓝色标记新拆分区间）。

2. **莫队指针移动演示**  
   - **像素风格**：用网格展示DFS序，左右指针移动时播放8-bit音效。  
   - **高亮变化**：当前处理的区间对用闪烁方块表示，计数变化显示在侧边栏。

3. **自动演示模式**  
   - **AI模式**：自动执行换根和查询，展示区间拆分与莫队统计过程。  
   - **音效反馈**：每次指针移动触发“滴”声，统计完成时播放胜利音效。

---

### 核心代码片段（莫队处理）

```cpp
void add(int x, int kind) { // 莫队指针移动更新计数
    int y = c[x];
    ans_here += cnt2[y] * (kind == 0) + cnt1[y] * (kind == 1);
    (kind == 0 ? cnt1[y]++ : cnt2[y]++);
}

// 处理查询拆分
void AddQuery(int l1, int r1, int l2, int r2, int id) {
    q[++cnt] = {r1, r2, id, 1};
    q[++cnt] = {l1-1, r2, id, -1};
    q[++cnt] = {r1, l2-1, id, -1};
    q[++cnt] = {l1-1, l2-1, id, 1};
}
```

---

### 复古像素动画实现

```javascript
// Canvas绘制DFS序网格
function drawGrid() {
    ctx.fillStyle = '#2C3E50';
    for (let i = 0; i < n; i++) {
        ctx.fillRect(i * 20, 0, 18, 18); // 像素块表示节点
    }
}

// 莫队指针移动动画
function movePointer(l, r) {
    ctx.fillStyle = '#E74C3C';
    ctx.fillRect(l * 20, 20, 18, 18); // 左指针
    ctx.fillRect(r * 20, 40, 18, 18); // 右指针
    playSound('beep'); // 触发音效
}
```

**交互设计**：  
- 方向键控制莫队执行速度，空格暂停/继续。  
- 成功统计后显示8-bit风格“Solved!”动画。

---
处理用时：67.77秒
# 题目信息

# [NOI2015] 寿司晚宴

## 题目描述

为了庆祝 NOI 的成功开幕，主办方为大家准备了一场寿司晚宴。小 G 和小 W 作为参加 NOI 的选手，也被邀请参加了寿司晚宴。

在晚宴上，主办方为大家提供了 $n−1$ 种不同的寿司，编号 $1,2,3,\ldots,n-1$，其中第 $i$ 种寿司的美味度为 $i+1$。（即寿司的美味度为从 $2$ 到 $n$）

现在小 G 和小 W 希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小 G 品尝的寿司种类中存在一种美味度为 $x$ 的寿司，小 W 品尝的寿司中存在一种美味度为 $y$ 的寿司，而 $x$ 与 $y$ 不互质。

现在小 G 和小 W 希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数 $p$ 取模）。注意一个人可以不吃任何寿司。


## 说明/提示

【数据范围】


 ![](https://cdn.luogu.com.cn/upload/pic/1506.png) 


**勘误：$0 < p \le 10^9 $**

## 样例 #1

### 输入

```
3 10000```

### 输出

```
9```

## 样例 #2

### 输入

```
4 10000```

### 输出

```
21```

## 样例 #3

### 输入

```
100 100000000```

### 输出

```
3107203```

# AI分析结果



### 算法分类
**状压DP**

---

### 题解思路与核心难点

#### 核心思路
1. **质因数分治**：每个数最多有1个 >√n 的质因子（大质因子），其余为小质因子（≤19的8个质数）
2. **分层状压**：对小质因子集合进行状压（256种状态），对大质因子按组处理
3. **分组处理**：将大质因子相同的数分为一组，每组只能全选到集合A或B，或不选

#### 解决难点
1. **大质因子冲突处理**：同组大质因子的数必须同选或不选，使用临时数组`f1`和`f2`分别记录选到集合A/B的情况
2. **状态合并**：每组处理结束后合并`f1`和`f2`，通过`dp[i][j] = f1[i][j] + f2[i][j] - dp[i][j]`避免重复计数
3. **滚动数组优化**：通过倒序循环和滚动数组将空间复杂度优化到 O(256²)

---

### 题解评分（≥4星）

#### 1. Orion545 (4.5⭐)
- **亮点**：清晰分层思想，完整推导状态转移方程，代码结构工整
- **关键代码段**：
```cpp
for(int j=255;j>=0;j--) // 倒序循环避免覆盖 
for(int k=255;k>=0;k--){
    if((a[i].S&j)==0) f1[j][k|a[i].S] += f1[j][k];
    if((a[i].S&k)==0) f2[j|a[i].S][k] += f2[j][k];
}
```

#### 2. 翼德天尊 (4⭐)
- **亮点**：详细解释质因数分解策略，突出大质因子排序分组的必要性
- **调试经验**：强调排序后大质因子相同数连续排列的关键性

#### 3. ethan_zhou (4⭐)
- **亮点**：提出 O(n×3⁸) 优化，使用三进制枚举有效状态
- **代码技巧**：通过预处理质因子状态加速分解

---

### 最优思路提炼

#### 关键技巧
1. **质因数分层**：分离小质因子（状压处理）和大质因子（分组处理）
2. **滚动转移**：使用`f1`和`f2`临时数组处理同一大质因子组的两种选择
3. **互补状态合并**：最终状态通过`dp = f1 + f2 - dp`消除重复计数

#### 核心代码逻辑
```cpp
// 处理每组大质因子
memcpy(f1, dp, sizeof dp);
memcpy(f2, dp, sizeof dp);

// 状态转移
for(int i : 当前大质因子组){
    for(int j=255; j>=0; j--){ // 倒序关键！
        for(int k=255; k>=0; k--){
            if((j & s[i]) == 0) f2[j][k|s[i]] += f2[j][k];
            if((k & s[i]) == 0) f1[j|s[i]][k] += f1[j][k];
        }
    }
}

// 合并状态
for(int j=0; j<=255; j++){
    for(int k=0; k<=255; k++){
        dp[j][k] = (f1[j][k] + f2[j][k] - dp[j][k]) % MOD;
    }
}
```

---

### 类似题目推荐
1. **P2706 巧克力**（质因数分解+状压DP）
2. **P2831 [NOIP2016]愤怒的小鸟**（覆盖问题+状压优化） 
3. **P3092 [USACO13NOV]No Change G**（状态压缩+前缀和优化）

---

### 可视化设计

#### 动画方案
1. **分块展示**：左侧显示当前处理的大质因子组，右侧显示小质因子状压状态
2. **高亮变化**：
   - 红色闪烁：当前处理的大质因子组
   - 绿色边框：正在更新的`f1`/`f2`状态
3. **状态转移追踪**：用箭头动态显示`dp[j][k]`如何转移到`j|s[i]`或`k|s[i]`

#### 复古像素风格
1. **8位调色板**：小质因子用8种不同颜色方块表示，大质因子用闪烁方块
2. **音效设计**：
   - 状态更新：短促"嘟"声（Web Audio生成方波）
   - 错误操作：低音"哔"声
3. **自动演示**：按空格键切换手动/自动模式，自动模式以0.5秒/步演示

---

### 核心代码（带状压DP）
```cpp
int main() {
    // 预处理质因子状态
    for(int i=2; i<=n; i++) {
        int tmp = i;
        for(int j=0; j<8; j++) {
            while(tmp % prime[j] == 0) {
                a[i].s |= 1<<j;
                tmp /= prime[j];
            }
        }
        a[i].big = tmp;
    }

    sort(a+2, a+n+1, cmp); // 按大质因子排序
    
    // DP初始化
    dp[0][0] = 1;
    
    // 分组处理
    for(int i=2; i<=n; ) {
        int cur = i;
        memcpy(f1, dp, sizeof dp);
        memcpy(f2, dp, sizeof dp);
        
        // 处理同组大质因子
        while(i<=n && a[i].big == a[cur].big) {
            int s = a[i].s;
            for(int j=255; j>=0; j--) {
                for(int k=255; k>=0; k--) {
                    if(!(s & k)) f1[j|s][k] = (f1[j|s][k] + f1[j][k]) % mod;
                    if(!(s & j)) f2[j][k|s] = (f2[j][k|s] + f2[j][k]) % mod;
                }
            }
            i++;
        }
        
        // 合并状态
        for(int j=0; j<256; j++) {
            for(int k=0; k<256; k++) {
                dp[j][k] = (f1[j][k] + f2[j][k] - dp[j][k] + mod) % mod;
            }
        }
    }
}
```

---

### 关键调试经验
1. **排序遗漏**：未按大质因子排序导致分组错误（需`sort(a+2, a+n+1, cmp)`）
2. **状态覆盖**：正序循环导致过早覆盖原状态（必须倒序`j,k从255到0`）
3. **负数取模**：合并时未加`mod`直接取模导致负数（需`(a + mod) % mod`）

---

通过分层状压处理质因数，结合分组策略和滚动数组优化，该题展现了状压DP处理复杂约束的典型模式。理解质因数分治思想和状态合并技巧是掌握此类问题的关键。

---
处理用时：92.61秒
# 题目信息

# [SDOI2010] 古代猪文

## 题目背景

“在那山的那边海的那边有一群小肥猪。他们活泼又聪明，他们调皮又灵敏。他们自由自在生活在那绿色的大草坪，他们善良勇敢相互都关心……”

——选自猪王国民歌


很久很久以前，在山的那边海的那边的某片风水宝地曾经存在过一个猪王国。猪王国地理位置偏僻，实施的是适应当时社会的自给自足的庄园经济，很少与外界联系，商贸活动就更少了。因此也很少有其他动物知道这样一个王国。

猪王国虽然不大，但是土地肥沃，屋舍俨然。如果一定要拿什么与之相比的话，那就只能是东晋陶渊明笔下的大家想象中的桃花源了。猪王勤政爱民，猪民安居乐业，邻里和睦相处，国家秩序井然，经济欣欣向荣，社会和谐稳定。和谐的社会带给猪民们对工作火红的热情和对未来的粉色的憧憬。

小猪iPig是猪王国的一个很普通的公民。小猪今年10岁了，在大肥猪学校上小学三年级。和大多数猪一样，他不是很聪明，因此经常遇到很多或者稀奇古怪或者旁人看来轻而易举的事情令他大伤脑筋。小猪后来参加了全猪信息学奥林匹克竞赛(Pig Olympiad in Informatics, POI)，取得了不错的名次，最终保送进入了猪王国大学(Pig Kingdom University, PKU)深造。

现在的小猪已经能用计算机解决简单的问题了，比如能用P++语言编写程序计算出A + B的值。这个“成就”已经成为了他津津乐道的话题。当然，不明真相的同学们也开始对他刮目相看啦~

小猪的故事就将从此展开，伴随大家两天时间，希望大家能够喜欢小猪。


## 题目描述

猪王国的文明源远流长，博大精深。

iPig 在大肥猪学校图书馆中查阅资料，得知远古时期猪文文字总个数为 $n$。当然，一种语言如果字数很多，字典也相应会很大。当时的猪王国国王考虑到如果修一本字典，规模有可能远远超过康熙字典，花费的猪力、物力将难以估量。故考虑再三没有进行这一项劳猪伤财之举。当然，猪王国的文字后来随着历史变迁逐渐进行了简化，去掉了一些不常用的字。

iPig 打算研究古时某个朝代的猪文文字。根据相关文献记载，那个朝代流传的猪文文字恰好为远古时期的 $1/k$，其中 $k$ 是 $n$ 的一个正约数（可以是 $1$ 或 $n$）。不过具体是哪 $1/k$，以及 $k$ 是多少，由于历史过于久远，已经无从考证了。

iPig 觉得只要符合文献，每一种 $k|n$ 都是有可能的。他打算考虑到所有可能的 $k$。显然当 $k$ 等于某个定值时，该朝的猪文文字个数为 $n/k$。然而从 $n$ 个文字中保留下 $n/k$ 个的情况也是相当多的。iPig 预计，如果所有可能的 $k$ 的所有情况数加起来为 $p$ 的话，那么他研究古代文字的代价将会是 $g^p$。

现在他想知道猪王国研究古代文字的代价是多少。由于 iPig 觉得这个数字可能是天文数字，所以你只需要告诉他答案除以 $999911659$ 的余数就可以了。


## 说明/提示

#### 数据规模与约定
- 对于 $10\%$ 的数据，$1\le n \le 50$；  
- 对于 $20\%$ 的数据，$1\le n \le 1000$；  
- 对于 $40\%$ 的数据，$1\le n \le 10^5$；  
- 对于 $100\%$ 的数据，$1\le n,g \le 10^9$。


## 样例 #1

### 输入

```
4 2```

### 输出

```
2048```

# AI分析结果



## 算法分类
数论（组合数学、模运算、中国剩余定理）

---

## 题解思路与核心难点解析
### 核心思路
1. **欧拉定理降幂**：将指数部分通过费马小定理转换为模 999911658 的运算
2. **质因数分解**：将模数分解为 2×3×4679×35617 四个质数
3. **Lucas定理**：分别计算组合数对四个质数的模
4. **中国剩余定理（CRT）**：合并四个模数的结果
5. **快速幂**：计算最终答案

### 解决难点
- **组合数取模难题**：模数非质数时，通过分解质因数+CRT解决
- **大数阶乘处理**：预处理阶乘和逆元加速组合数计算
- **约数枚举优化**：通过√n复杂度枚举约数，避免重复计算

---

## 题解评分与亮点（≥4星）
1. **Owen_codeisking（★★★★☆）**
   - 亮点：清晰的模块化代码结构，包含特判处理
   - 关键代码：
```cpp
void CRT() {
    for(LL i=1;i<=4;i++)
        val = (val + a[i]*(mod/b[i])%mod*fast_pow(mod/b[i],b[i]-2,b[i]))%mod;
}
```

2. **Saliеri（★★★★★）**
   - 亮点：完整的数学推导过程，包含阶乘逆元预处理优化
   - 关键实现：
```cpp
void Init(LL p) {
    fac[0] = 1;
    for(LL i=1;i<=p;i++) fac[i] = fac[i-1]*i%p;
    inv[p-1] = power(fac[p-1],p-2,p);
}
```

3. **FlashHu（★★★★☆）**
   - 亮点：简洁的质因数处理，使用exgcd求逆元
   - 关键片段：
```cpp
int excrt() {
    int ans=0, mod=Mod-1;
    for(int i=0;i<4;i++) 
        ans += a[i]*(mod/p[i])%mod*inv(mod/p[i],p[i])%mod;
}
```

---

## 最优思路提炼
1. **四步分解法**：
   ```mermaid
   graph TD
     A[欧拉定理降幂] --> B[质因数分解模数]
     B --> C[Lucas定理分治计算]
     C --> D[中国剩余定理合并]
   ```

2. **关键优化点**：
- **阶乘预处理**：针对每个质数p，预处理1~p的阶乘和逆元
- **约数成对处理**：i与n/i同时计算，减少枚举次数
- **快速幂优化**：使用二进制分解加速指数运算

---

## 同类题型推荐
1. P3868 [TJOI2009]猜数字（中国剩余定理）
2. P3807 【模板】卢卡斯定理（组合数取模）
3. P4774 [NOI2018]屠龙勇士（扩展中国剩余定理）

---

## 可视化设计（像素风格演示）
**算法流程动画**：
1. **分解阶段**：4个像素方块代表分解后的质因数（2/3/4679/35617）
2. **计算阶段**：
   - 黄色方块闪烁：当前处理的质数
   - 绿色箭头：约数枚举过程（i → n/i）
   - 红色数字跳动：Lucas递归调用深度
3. **合并阶段**：CRT公式逐步拼合（像素字体显示公式）
4. **音效设计**：
   - 8-bit音效：质因数分解成功（↑↑↑）、CRT合并（♪）、快速幂完成（♪♪）

**交互功能**：
- 速度调节滑块（1x/2x/5x）
- 单步执行按钮（观察每一步模数处理）
- 自动演示模式（AI自动完成所有计算）

---

## 核心代码实现
```cpp
// 中国剩余定理合并
int CRT(int a[], int m[]) {
    int res = 0, M = 999911658;
    for(int i=0; i<4; i++) {
        int Mi = M/m[i];
        int t = inv(Mi, m[i]); // 像素动画展示逆元计算
        res = (res + a[i]*Mi%M*t%M) % M;
    }
    return res;
}

// Lucas定理计算组合数
int lucas(int n, int m, int p) {
    if(!m) return 1;
    // 像素动画显示递归调用过程
    return 1ll * C(n%p,m%p,p) * lucas(n/p,m/p,p) % p;
}
```

---

## 学习建议
1. **调试技巧**：当模数较大时，验证阶乘预处理是否正确（如4679! mod 4679应为0）
2. **常见错误**：
   - 未处理n为平方数时的重复计算
   - 中国剩余定理合并时忘记取模
3. **思维拓展**：将四步分解法迁移到其他模数分解问题（如RSA算法中的大数分解）

---
处理用时：68.50秒
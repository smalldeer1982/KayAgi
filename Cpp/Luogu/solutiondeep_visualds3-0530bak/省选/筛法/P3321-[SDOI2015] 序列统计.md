# 题目信息

# [SDOI2015] 序列统计

## 题目描述

小C有一个集合 $S$，里面的元素都是小于 $m$ 的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为 $n$ 的数列，数列中的每个数都属于集合 $S$。  

小C用这个生成器生成了许多这样的数列。但是小C有一个问题需要你的帮助：给定整数 $x$，求所有可以生成出的，且满足数列中所有数的乘积 $\bmod \ m$ 的值等于 $x$ 的不同的数列的有多少个。  

小C认为，两个数列 $A$ 和 $B$ 不同，当且仅当 $\exists i \text{ s.t. } A_i \neq B_i$。另外，小C认为这个问题的答案可能很大，因此他只需要你帮助他求出答案对 $1004535809$ 取模的值就可以了。


## 说明/提示

【样例说明】

可以生成的满足要求的不同的数列有(1,1,1,1)、(1,1,2,2)、(1,2,1,2)、(1,2,2,1)、(2,1,1,2)、(2,1,2,1)、(2,2,1,1)、(2,2,2,2)。

【数据规模和约定】

对于 $10\%$ 的数据，$1\le n \le 1000$；   
对于 $30\%$ 的数据，$3 \le m \le 100$；    
对于 $60\%$ 的数据，$3 \le m \le 800$；   
对于 $100\%$ 的数据，$1 \le n \le 10^9$，$3 \le m \le 8000$，$1\le x < m$。   
$m$ 为质数，输入数据保证集合 $S$ 中元素不重复。


## 样例 #1

### 输入

```
4 3 1 2
1 2```

### 输出

```
8```

# AI分析结果



### 【唯一算法分类】
**原根与多项式快速幂**

---

### 【题解思路、算法要点与解决难点】

#### **核心思路**
1. **原根转换**：利用质数原根将乘积转换为加法，将问题转化为多项式卷积问题。
2. **多项式快速幂**：通过快速幂和NTT加速多项式乘法，处理模意义下的指数累加。

#### **算法步骤**
1. **求原根**：找到模数 $m$ 的原根 $g$，构建原数与原根指数的映射表。
2. **初始化多项式**：将集合 $S$ 中的数转换为原根指数，构建初始多项式。
3. **快速幂加速**：通过倍增和NTT实现多项式快速幂，计算长度为 $n$ 的序列的指数组合方案数。
4. **模处理**：每次卷积后将超过 $m-1$ 的项累加到对应模位置。

#### **解决难点**
- **原根映射**：正确建立原数与指数的双向映射表，确保乘法转换为加法后不冲突。
- **快速幂优化**：通过倍增思想将时间复杂度从 $O(n^2)$ 优化到 $O(m \log m \log n)$。
- **模意义下的卷积**：每次NTT后需手动将高位结果累加到低位，保证模的正确性。

---

### 【题解评分 (≥4星)】
1. **ZigZagKmp（★★★★★）**  
   - **亮点**：详细推导原根与多项式的关系，分步骤引入例题，代码注释清晰。
   - **心得**：强调“模处理”的重要性，指出调试时需注意高位累加的逻辑。

2. **何俞均（★★★★☆）**  
   - **亮点**：代码简洁高效，直接调用NTT库函数，适合快速实现。
   - **不足**：对原根求解过程解释较少，新手可能难以理解。

3. **Keln（★★★★☆）**  
   - **亮点**：代码高度优化，使用指针操作减少内存拷贝，性能优异。
   - **心得**：在注释中提醒“集合中的0必须特判”，避免常见错误。

---

### 【最优思路或技巧提炼】
1. **原根转换乘法为加法**  
   - 核心：利用原根性质 $g^{a} \cdot g^{b} = g^{a+b} \mod m$，将乘积问题转化为多项式卷积。
2. **快速幂与NTT结合**  
   - 通过倍增法将多项式乘法次数从 $O(n)$ 降到 $O(\log n)$，结合NTT的 $O(m \log m)$ 复杂度实现高效计算。
3. **模处理技巧**  
   - 每次卷积后手动将 $[m, 2m)$ 的项累加到 $[0, m)$，保证模运算的正确性。

---

### 【同类型题与算法套路】
1. **通用解法**  
   - **模意义下的组合计数**：通过原根或离散对数转换乘法为加法，再用多项式/生成函数求解。
2. **类似题目**  
   - **洛谷P4245**：任意模数NTT，需处理非质数模数下的卷积。
   - **洛谷P4238**：多项式求逆，快速求解生成函数的逆元。
   - **洛谷P4721**：多项式除法，分治FFT优化递推。

---

### 【推荐相似题目】
1. **P4245**：任意模数NTT，练习非质数模下的卷积处理。
2. **P4238**：多项式求逆，掌握生成函数求逆的技巧。
3. **P4721**：多项式除法，学习分治FFT优化递推。

---

### 【可视化与算法演示设计】
#### **动画方案**
1. **原根映射显示**  
   - **像素风格**：左侧显示原数，右侧显示对应的原根指数，颜色标记当前操作数。
   - **音效**：映射成功时播放“滴”声，失败时播放低音。
2. **多项式快速幂流程**  
   - **网格绘制**：Canvas中显示多项式系数数组，快速幂步骤高亮当前处理的二进制位。
   - **步进控制**：允许单步执行，观察NTT变换、点乘、逆变换的过程。
3. **模处理动画**  
   - **颜色高亮**：将超过 $m-1$ 的项标记为红色，累加时显示箭头移动到对应位置。
   - **音效**：累加时播放“咔嚓”声，增强操作反馈。

#### **复古游戏化设计**
- **8位像素风**：使用16色调色板，原根映射表显示为复古终端样式。
- **背景音乐**：循环播放8位芯片音乐，音效采用FC风格。
- **AI自动演示**：点击“Auto”按钮后，算法自动执行，展示快速幂和NTT的流程。

---

### **代码片段（核心逻辑）**
```cpp
// ZigZagKmp 题解中的快速幂与NTT核心代码
void Ksm(int p) {
    g[0] = 1;
    for (int i = 32; ~i; i--) {
        if ((p >> i) & 1)
            Poly::mul(f[i], g, g, m-1, m-1, m-1);
    }
}

// 何俞均题解中的NTT调用
void Mul(int *A, int *B) {
    NTT(A, 1); NTT(B, 1);
    for (int i = 0; i < Limit; i++) A[i] = 1LL * A[i] * B[i] % Mod;
    NTT(A, -1); // 逆变换后处理模
}
```

---

### **总结**
本题解通过原根与多项式快速幂的巧妙结合，解决了模意义下的乘积计数问题。其核心在于将复杂运算转换为多项式卷积，并通过NTT优化计算效率。可视化设计进一步增强了算法流程的直观性，适合教学与自学。

---
处理用时：73.12秒
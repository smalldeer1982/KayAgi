# 题目信息

# 奇数国

## 题目描述

在一片美丽的大陆上有 $100\,000$ 个国家，记为 $1$ 到 $100\,000$。这里经济发达，有数不尽的账房，并且每个国家有一个银行。

某大公司的领袖在这 $100\,000$ 个银行开户时都存了 $3$ 大洋，他惜财如命，因此会不时地派小弟 GFS 清点一些银行的存款或者让 GFS 改变某个银行的存款。

该村子在财产上的求和运算等同于我们的乘法运算，也就是说领袖开户时的存款总和为 $3^{100000}$。这里发行的软妹面额是最小的 $60$ 个素数（$p_1=2,p_2=3,\ldots, p_{60}=281$），任何人的财产都只能由这 $60$ 个基本面额表示，即设某个人的财产为 $fortune$（正整数），则 $fortune=p_1^{k_1} \times p_2^{k_2} \times \ldots p_{60}^{k_{60}}$。

领袖习惯将一段编号连续的银行里的存款拿到一个账房去清点，为了避免 GFS 串通账房叛变，所以他不会每次都选择同一个账房。GFS 跟随领袖多年已经摸清了门路,知道领袖选择账房的方式。如果领袖选择清点编号在 $[a,b]$ 内的银行财产，他会先对 $[a,b]$ 的财产求和（记为 $product$），然后在编号属于 $[1,product]$ 的账房中选择一个去清点存款，检验自己计算是否正确同时也检验账房与 GFS 是否有勾结。GFS 发现如果某个账房的编号 $number$ 与 $product$ 相冲，领袖绝对不会选择这个账房。

怎样才算与 $product$ 不相冲呢？若存在整数 $x,y$ 使得 $number \times x+product \times y=1$，那么我们称 $number$ 与 $product$ 不相冲，即该账房有可能被领袖相中。当领袖又赚大钱了的时候，他会在某个银行改变存款，这样一来相同区间的银行在不同的时候算出来的 $product$ 可能是不一样的，而且领袖不会在某个银行的存款总数超过 $10^6$。

现在 GFS 预先知道了领袖的清点存款与变动存款的计划，想请你告诉他，每次清点存款时领袖有多少个账房可以供他选择，当然这个值可能非常大，GFS 只想知道对 $19\,961\,993$ 取模后的答案。

## 说明/提示

### 样例解释

- 初始化每个国家存款都为 $3$；
- $1$ 到 $3$ 的 $product$ 为 $27$，$[1,27]$ 与 $27$ 不相冲的有 $18$ 个数；
- $1$ 的存款变为 $5$；
- $1$ 到 $3$ 的 $product$ 为 $45$，$[1,45]$ 与 $45$ 不相冲的有 $24$ 个数；
- $1$ 的存款变为 $7$；
- $1$ 到 $3$ 的 $product$ 为 $63$，$[1,63]$ 与 $63$ 不相冲的有 $36$个数；
- $2$ 到 $3$ 的 $product$ 为 $9$，$[1,9]$ 与 $9$ 不相冲的有 $6$ 个数。

### 数据范围

所有数据均满足：$x \geq 1$，$c_i -b_i \geq 0$。

| 子任务编号 | 分值 |    $x \leq$     | $c_i - b_i \leq$ | 特殊性质 |
| :--------: | :--: | :-------------: | :--------------: | :------: |
|    $1$     | $20$ |     $10^4$      |      $100$       |    有    |
|    $2$     | $30$ | $5 \times 10^4$ |      $10^4$      |    无    |
|    $3$     | $50$ |     $10^5$      |      $10^5$      |    无    |

特殊性质指：所有 $product \leq 10^{18}$。

## 样例 #1

### 输入

```
6
0 1 3
1 1 5
0 1 3
1 1 7
0 1 3
0 2 3```

### 输出

```
18
24
36
6

```

# AI分析结果



## 算法分类
线段树、数论（欧拉函数）

---

## 综合分析与结论

### 核心思路
所有题解均基于以下关键点：
1. **质因数限制**：所有数只能由前60个质数构成
2. **欧拉函数公式**：$\varphi(n) = n \prod_{p|n} \frac{p-1}{p}$
3. **区间维护**：用线段树/树状数组维护区间乘积和质因数集合

### 实现差异对比
| 方法                | 数据结构   | 质因数存储方式          | 时间复杂度       |
|---------------------|------------|-------------------------|------------------|
| Siyuan              | 线段树     | long long位掩码         | $O(60m\log n)$   |
| gyh20               | 树状数组   | 60个树状数组维护指数     | $O(60m\log n)$   |
| Surge_of_Force      | 线段树     | long long位掩码 + 乘积  | $O(60m\log n)$   |

### 可视化设计
1. **线段树节点展示**：
   - 每个节点显示乘积值（如27）和二进制掩码（如0b100）
   - 合并时高亮位或操作和乘积计算
2. **质因数分解动画**：
   - 输入数值（如45=3²×5）时显示质因数分解过程
   - 用不同颜色标记出现的质因数
3. **欧拉函数计算过程**：
   - 动态展示公式运算：$45×(1-\frac{1}{3})×(1-\frac{1}{5})$

---

## 题解评分（≥4星）

### Siyuan（★★★★☆）
- **亮点**：清晰的线段树双维护（乘积+掩码）、预处理逆元优化
- **核心代码**：
```cpp
void pushup(int p) {
    seg[p] = seg[lson] | seg[rson]; // 位或合并质因数
    mul[p] = mul[lson] * mul[rson] % mod;
}
```

### Surge_of_Force（★★★★☆）
- **亮点**：详细注释调试经历（线段树边界问题）、代码可读性高
- **心得摘录**："状压要开long long！建树是1~1e5不是输入的n！"

### Jayun（★★★★☆）
- **亮点**：代码高度模块化、独立封装质因数分解类
- **优化**：快速幂求欧拉函数，避免浮点误差

---

## 最优技巧提炼

### 核心算法流程
1. **线段树构建**：
   ```python
   class SegmentTree:
       def __init__(self):
           self.tree = []  # 每个节点存储(乘积, 质因数掩码)
           
       def merge(left, right):
           product = left.product * right.product % mod
           mask = left.mask | right.mask
           return Node(product, mask)
   ```

2. **欧拉函数计算**：
   ```python
   def euler(product, mask):
       result = product
       for i in 0..59:
           if mask & (1 << i):
               result = result * (prime[i]-1) * inv_prime[i] % mod
       return result
   ```

### 可视化实现要点
- **复古像素风格**：
  - 用16色调色板（如#0F0F0F背景，#FF0000质因数标记）
  - Canvas绘制线段树结构，节点用8x8像素块表示
- **音效设计**：
  ```javascript
  function playSound(type) {
      if(type == 'merge') beep(440, 50);  // 合并节点时播放
      if(type == 'prime') beep(880, 100); // 发现新质因数
  }
  ```

---

## 相似题目推荐
1. P3373 线段树区间乘加
2. P2158 欧拉函数计数
3. P1440 区间质数查询

---

## 个人心得摘录
> "debug时发现初始化区间应为[1,1e5]而非输入的n，血的教训！long long移位必须用1LL，否则会溢出变成负数..."

---

## 核心代码实现
```cpp
// 线段树查询关键逻辑
pair query(int l, int r) {
    if(当前节点完全在[l,r]内)
        return {product, mask};
    auto left = query左区间;
    auto right = query右区间;
    return {
        left.product * right.product % mod,
        left.mask | right.mask
    };
}

// 欧拉函数计算
int calc_euler(int product, long long mask) {
    int res = product;
    for(int i=0; i<60; ++i) {
        if(mask & (1LL<<i)) {
            res = 1LL * res * (prime[i]-1) % mod;
            res = 1LL * res * inv_prime[i] % mod;
        }
    }
    return res;
}
```

---
处理用时：74.30秒
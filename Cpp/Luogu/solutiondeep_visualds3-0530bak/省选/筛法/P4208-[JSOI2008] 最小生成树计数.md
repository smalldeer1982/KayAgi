# 题目信息

# [JSOI2008] 最小生成树计数

## 题目描述

现在给出了一个简单无向加权图。你不满足于求出这个图的最小生成树，而希望知道这个图中有多少个不同的最小生成树。（如果两棵最小生成树中至少有一条边不同，则这两个最小生成树就是不同的）。由于不同的最小生成树可能很多，所以你只需要输出方案数对 $31011$ 的模就可以了。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le n \le 100$，$1 \le m \le 1000$，$1\leq c_i\leq 10^9$。

## 样例 #1

### 输入

```
4 6
1 2 1
1 3 1
1 4 1
2 3 2
2 4 1
3 4 1```

### 输出

```
8
```

# AI分析结果



**唯一算法分类**：生成树计数（结合Kruskal算法与Matrix-Tree定理）

---

### 综合分析与结论

#### 核心思路
1. **定理应用**：所有最小生成树中，相同权值的边数量相等。利用此性质将问题分解为各权值边的独立计算。
2. **分阶段处理**：按边权从小到大处理，对每个权值w的边：
   - **缩点**：将已处理的非w权边形成的连通块缩为超级节点
   - **生成树计数**：在缩点后的图上，计算权w边的生成树方案数（使用基尔霍夫矩阵行列式计算）
3. **乘法原理**：各权值方案数相乘即为最终答案

#### 可视化设计要点
```javascript
// 伪代码示例：基尔霍夫矩阵计算动画
function animateMatrix() {
  // 绘制n×n像素网格，每个格子代表矩阵元素
  ctx.fillStyle = '#8B00FF'; // 紫色背景
  ctx.fillRect(x, y, size, size); 
  
  // 高亮当前消元行和列
  ctx.strokeStyle = '#FFD700'; // 金色描边
  ctx.strokeRect(activeCol*size, activeRow*size, size, size);
  
  // 显示行列式计算结果
  drawText(`det=${currentDet}`, canvas.width-100, 20);
}
```

---

### 题解清单（≥4星）

1. **smarthehe（5星）**
   - **亮点**：同时提供枚举法与生成树计数两种解法，代码清晰标注缩点逻辑
   - **核心代码**：
     ```cpp
     // 缩点后构建基尔霍夫矩阵
     for(int j=1;j<=n;j++) bel[j]=bel[rt(j)];
     for(int j=0;j<siz;j++) {
         int bx=bel[edge[i][j].x], by=bel[edge[i][j].y];
         deg[bx][bx]++, deg[by][by]++;
         g[bx][by]++, g[by][bx]++;
     }
     ```

2. **Kelin（5星）**
   - **亮点**：矩阵行列式计算采用辗转相除法，时间复杂度优化到O(n³)
   - **关键步骤**：
     ```cpp
     while(b) { // 辗转相除消元
         a -= (a/b)*b; swap(a,b);
         for(int k=i;k<=n;k++) 
             swap(mat[i][k], mat[j][k]);
         ans *= -1;
     }
     ```

3. **ShuYuMo（4星）**
   - **亮点**：完整实现缩点与矩阵构建逻辑，代码结构模块化
   - **缩点实现**：
     ```cpp
     void dfs(int now, int W) { // 连通块标记
         SCC[now] = nodetot;
         for(int i=head[now];i;i=edge[i].nxt) 
             if(!SCC[edge[i].node] && edge[i].w!=W)
                 dfs(edge[i].node, W);
     }
     ```

---

### 关键代码实现（smarthehe版核心逻辑）

```cpp
int treecnt() { // 基尔霍夫行列式计算
    int ans=1;
    for(int i=1;i<n;i++) {
        for(int j=i+1;j<n;j++) {
            while(mat[j][i]) { // 辗转相除消元
                int div=mat[i][i]/mat[j][i];
                for(int k=i;k<n;k++) 
                    mat[i][k]=(mat[i][k]-1ll*mat[j][k]*div%MOD+MOD)%MOD;
                swap(mat[i],mat[j]);
                ans*=-1;
            }
        }
        ans=1ll*ans*mat[i][i]%MOD;
    }
    return (ans+MOD)%MOD;
}
```

---

### 同类型题推荐
1. **P3366** 【模板】最小生成树（基础Kruskal练习）
2. **P6177** Count on a tree II（树哈希与计数结合）
3. **P4111** [HEOI2015]小Z的房间（基尔霍夫矩阵经典题）

---

### 复古像素化动画设计
1. **颜色方案**：
   - 连通块：16色调色板的#FF0000（红）、#00FF00（绿）、#0000FF（蓝）交替
   - 当前边：闪烁金色边框（#FFD700）
   - 矩阵元素：紫色背景（#8B00FF）配白色数字

2. **音效设计**：
   - `select.wav`：选中边时的8bit"滴"声
   - `merge.wav`：合并连通块时的上升音阶
   - `error.wav`：形成环时的低沉警示音

3. **自动演示逻辑**：
   ```javascript
   function autoRun() {
       let speed = 500; // 每步500ms
       edges.sort((a,b) => a.w - b.w);
       edges.forEach((e, idx) => {
           highlightEdge(e); // 高亮当前边
           playSound('select.wav');
           if(!tryUnion(e)) playSound('error.wav');
           updateCanvas();
           delay(speed);
       });
   }
   ```

---

**可视化核心**：通过分阶段染色连通块、动态绘制基尔霍夫矩阵消元过程，结合音效反馈，将抽象的数学证明转化为直观的像素动画。

---
处理用时：72.34秒
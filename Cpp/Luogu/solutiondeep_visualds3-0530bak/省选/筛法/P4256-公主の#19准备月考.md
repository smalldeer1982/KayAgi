# 题目信息

# 公主の#19准备月考

## 题目背景

公主在玩完游戏后，也要月考了。（就算是公主也要月考啊QWQ）


## 题目描述

公主的文综太差了，全校排名1100+（全校就1100多人），她分析了好久，发现她如果把所有时间放在选择题上，得分会比较好一点。

文综题目共有n个，编号从1到n

公主给每个题目算出来了一个预估值Ai，她认为，一段连续题目的答案会在它们的预估值的gcd和lcm之间；有时候她的想法不同了，一些题目的预估值会改变；有时候，会出现多选题，多选题的答案数量就是一段连续题目答案的预估值的公约数的个数。

具体来说，对于一个数列，有四种操作：

L x y p 表示公主询问区间[x,y]的数字的lcm对p取模之后的值

G x y p 表示公主询问区间[x,y]的数字的gcd对p取模之后的值

C x y c 表示公主改变区间[x,y]的数字的值，统一为c

S x y p 表示公主询问区间[x,y]的数字的公因数个数对p取模之后的值

公主月考不能挂科，不然她就不能学习OI了（假的），所以请你帮帮她吧！


## 说明/提示

对于30%的数据，1<=n,q<=1000

对于另外20%的数据，1<=n<=1000，1<=q<=100000

对于另外20%的数据，1<=n<=100000，1<=q<=100000，保证没有修改操作

对于100%的数据，1<=n<=300000，1<=q<=300000

保证任何时刻每个题目的预估值都在[1,100]之间，答案取模之后不超过int


## 样例 #1

### 输入

```
10 10
42 68 35 1 70 25 79 59 63 65 
L 2 6 28
L 2 6 43
G 2 7 5
G 3 4 83
L 7 9 96
G 2 7 39
S 3 8 100
L 4 5 12
G 4 4 65
L 2 4 69```

### 输出

```
0
32
1
1
75
1
1
10
1
34```

# AI分析结果



## 算法分类
线段树 + 状态压缩

---

## 核心思路与算法分析

### 关键算法流程
1. **质因数压缩**  
   将每个数分解为质因数，并将各质因数的次数用二进制位压缩存储。例如：
   - 2^6（6用3位存储）
   - 3^4（4用3位存储）
   - 其他质数只需1位（存在性标记）
   总压缩位数为31位（刚好存入int）或64位（long long）。

2. **线段树设计**  
   每个线段树节点存储两个压缩值：
   - `gcd_val`：区间内所有数的质因数次数取min的压缩值
   - `lcm_val`：区间内所有数的质因数次数取max的压缩值
   合并时通过位运算提取各质因数次数，进行min/max后重新组合。

3. **快速计算模值**  
   - 查询时，将压缩值转换为实际质因数次数，快速幂计算模结果。
   - S操作（公约数个数）通过分解gcd的质因数次数，计算乘积。

### 解决难点对比
| 题解 | 压缩方式 | 合并效率 | 代码复杂度 |
|------|----------|----------|------------|
| Vingying | int（31位） | 位掩码分段处理 | 较高（需处理多段位） |
| Maniac坚果 | long long（64位） | 统一位运算 | 较低（位操作更简洁） |
| Hadtsti | 数组存储次数 | 无需位运算 | 较高（空间/时间开销大） |

### 最优思路提炼
- **核心技巧**：质因数次数的二进制压缩与位运算合并
- **优化点**：预处理每个数的压缩值，线段树合并时O(1)完成min/max
- **思维突破**：利用值域小的特点，将复杂质因数操作转化为位运算

---

## 高分题解推荐（≥4星）

1. **Vingying（5星）**  
   - **亮点**：精确位分配设计，31位int极限压缩，预处理位偏移表
   - **代码片段**：
     ```cpp
     int cal(int tmp) { // 压缩质因数
         int v=0;
         for(int i=0;i<=24;++i) v|=(cnt[i]<<b[i]);
         return v;
     }
     ```

2. **Maniac坚果（4.5星）**  
   - **亮点**：long long简化位操作，统一处理质因数存在性
   - **代码片段**：
     ```cpp
     inline LL fchange(int p) {
         LL res=0;
         for(int i=0;i<25;++i) 
             while(p%pri[i]==0) res|=1LL<<bitpos[i];
         return res;
     }
     ```

3. **Butterfly_qwq（4星）**  
   - **亮点**：预处理合并表FF，O(1)完成lcm计算
   - **代码片段**：
     ```cpp
     inline int F(int x,int y) { // 预处理的lcm合并
         return FF[x&1023][y&1023] | ((x|y)&高段位);
     }
     ```

---

## 可视化设计

### 算法动画方案
1. **线段树节点展示**  
   - 每个节点显示压缩值的二进制位，不同颜色区分质因数段
   - 高亮当前合并操作的质因数段（如红色表示2的次数段）

2. **位操作演示**  
   - 分解操作：点击节点弹出质因数分解面板，动态显示位提取过程
   - 合并操作：用粒子动画表示两个压缩值的位段如何取min/max

3. **复古像素风格**  
   - **调色板**：16色，使用FC经典红/蓝/绿像素块表示不同质因数
   - **音效**：
     - 质因数分解：8-bit "哔"声
     - 线段树合并：短促电子音
     - 错误操作：低沉嗡鸣声

### 交互功能
- **步进控制**：空格暂停/继续，方向键单步前进/后退
- **模式切换**：F1切换普通/像素风格，F2开关音效
- **自动演示**：AI模式自动执行样例输入，展示算法全流程

---

## 相似题目推荐
1. P3373 线段树区间修改（区间乘加操作）
2. P1494 质因数分解统计
3. P3865 ST表（区间最值查询）

---

## 核心代码实现
以Vingying的质因数压缩为例：
```cpp
// 预处理质因数位偏移
int b[] = {0,3,6,8,10,11,...}; 

struct Node {
    int gcd, lcm, lazy;
    // gcd存储各质数次数的min压缩
    // lcm存储各质数次数的max压缩
};

void pushup(int id) {
    t[id].gcd = calgcd(t[ls].gcd, t[rs].gcd);
    t[id].lcm = callcm(t[ls].lcm, t[rs].lcm);
}

int query_gcd(int l, int r) {
    // 返回压缩值，分解后计算实际gcd
}
```

---

## 总结与扩展
本题解展示了如何通过**质因数压缩**将复杂数论问题转化为位运算问题，结合线段树实现高效处理。该思路可扩展至其他值域受限的区间统计问题，例如区间平方因子数统计、区间欧拉函数值查询等。掌握位压缩技巧对优化此类问题至关重要。

---
处理用时：88.42秒
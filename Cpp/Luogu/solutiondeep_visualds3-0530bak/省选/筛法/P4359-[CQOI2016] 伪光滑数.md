# 题目信息

# [CQOI2016] 伪光滑数

## 题目描述

若一个大于 $1$ 的整数 $M$ 的质因数分解有 $k$ 项，其最大的质因子为 $a_k$ ，并且满足 $a_{k}^{k} \le N$，$a_k < 128$，我们就称整数 $M$ 为 $N$ - 伪光滑数。

现在给出 $N$，求所有整数中，第 $K$ 大的 $N$ - 伪光滑数。

### 题意澄清

设 $M = 36 = 2^2 \times 3^2$，则其对应的 $k = 4$，也就是说，对 $M$ 运用唯一分解定理，$M = \prod_{i=1}^n{p_i^{c_i}}$，$k = \sum_{i=1}^n{c_i}$。

第 $K$ 大为字面意思，是真的从大到小第 $K$ 个。

modified by expect2004 2020-11-25，这或许是他退役前对洛谷公共题库的最后一次贡献

## 说明/提示

对于 $30\%$ 的数据，$N \le 10^6$；  
对于 $100\%$ 的数据，$2 \le N \le 10^{18},1 \le K \le 800000$。保证至少有 $K$ 个满足要求的数。

## 样例 #1

### 输入

```
12345 20```

### 输出

```
9167```

# AI分析结果



# 算法分类选择  
**堆（优先队列）**

---

## 题解思路、算法要点与解决难点  
### 核心思路  
所有题解的核心思路是利用**堆维护候选数**，通过不断弹出最大值并生成次大候选数的策略寻找第 K 大伪光滑数。关键在于**替换质因子**：每次将当前数的最大质因子替换为更小的质因子，生成新的候选数，保证不重复且覆盖所有可能性。

### 解决难点  
1. **候选数的生成规则**：需保证每次生成的数满足 $a_k^k \le N$，同时不遗漏任何可能的候选数。  
2. **避免重复**：通过限制替换的质因子只能为更小的质数，并记录替换位置（如 `lim` 或 `z` 变量），确保单调性。  
3. **高效维护候选集**：堆的每次操作时间复杂度为 $O(\log K)$，总复杂度 $O(K \log K)$，适合 $K \le 8 \times 10^5$ 的数据范围。

---

## 题解评分（≥4星）  
### 1. ycyaw 题解（⭐⭐⭐⭐⭐）  
- **亮点**：代码简洁，初始将所有质数的幂次加入堆，替换时通过 `lim` 避免重复。  
- **关键代码**：  
  ```cpp
  q.push((node){now.val/now.p*pr[i], now.p, now.mi-1, i});
  ```

### 2. 龙翔凤翥 题解（⭐⭐⭐⭐）  
- **亮点**：结构体设计清晰，记录 `z` 表示可替换质数的右界，代码易读。  
- **关键代码**：  
  ```cpp
  q.push((Node){now.t / now.x * p[i], now.x, now.y - 1, i});
  ```

### 3. konyakest 题解（⭐⭐⭐⭐⭐）  
- **亮点**：优化质数表处理，通过指针移动生成候选数，避免重复计算，代码高效且为本题最优解。  
- **关键代码**：  
  ```cpp
  q.push({d.p, d.k, d.las, d.n, d.m+1, d.val/prs[d.m]*prs[d.m+1]});
  ```

---

## 最优思路或技巧提炼  
### 关键技巧  
1. **质因子替换策略**：每次弹出堆顶后，将其中一个最大质因子替换为更小的质数（如 $p_i \to p_{i-1}$），保证候选数严格递减。  
2. **初始候选数生成**：对每个质数 $p$，计算其最大可能的幂次 $p^k \le N$，并将这些值作为初始候选集。  
3. **单调性保证**：通过 `lim` 或 `z` 变量限制替换质数的范围，确保生成数的质因子序列单调不增。

---

## 同类型题或类似算法套路  
1. **丑数问题**：用堆维护候选数，每次弹出最小值并生成新候选（乘质因子）。  
2. **合并K个有序链表**：堆维护当前最小节点，每次弹出后加入下一节点。  
3. **第K大异或值**：通过堆维护候选数的生成过程。

---

## 推荐相似题目  
1. [P2646 丑数](https://www.luogu.com.cn/problem/P2723)  
2. [P2048 [NOI2010] 超级钢琴](https://www.luogu.com.cn/problem/P2048)  
3. [P313 [USACO16OPEN] 248](https://www.luogu.com.cn/problem/P313)  

---

## 个人心得摘录  
- **ycyaw**：通过替换最大质因子的思路，避免重复且覆盖所有可能候选数。  
- **konyakest**：优化质数表处理时发现指针移动策略，减少不必要的计算。  
- **调试教训**：初始未正确计算质数的最大幂次，导致候选数生成不全。

---

## 可视化与算法演示  
### 动画设计  
1. **堆操作可视化**：  
   - **颜色标记**：当前堆顶用红色高亮，新加入的候选数用绿色标记。  
   - **质因子替换演示**：用箭头表示最大质因子 $p_i$ 被替换为 $p_{i-1}$ 的过程。  
2. **复古像素风格**：  
   - **8-bit 质数方块**：不同质数用不同颜色方块表示，替换时播放 8-bit 音效。  
   - **Canvas 网格**：每行表示一个质数的幂次，列表示替换步骤。  
3. **自动演示模式**：  
   - **AI 步进**：自动执行弹出堆顶、生成新候选数的过程，速度可调。  
   - **音效触发**：弹出堆顶时播放“叮”声，加入新候选时播放“嗒”声。

### 关键代码片段（JS 伪代码）  
```javascript
// 初始化堆并生成初始候选数
const heap = new PriorityQueue();
primes.forEach(p => {
    let val = p;
    for (let k = 1; val <= N; val *= p, k++) {
        heap.push({ val, p, k, lim: prevPrimeIndex });
    }
});

// 弹出堆顶并生成新候选
function step() {
    const { val, p, k, lim } = heap.pop();
    if (k > 1) {
        for (let i = 0; i < lim; i++) {
            const newVal = val / p * smallerPrimes[i];
            heap.push({ val: newVal, p, k: k - 1, lim: i });
        }
    }
}
```

---

## 核心代码实现  
### ycyaw 题解关键片段  
```cpp
priority_queue<node> q;
for (int i = 1; i <= 31; i++) {
    ll now = pr[i];
    for (int j = 1; now <= n; j++, now *= pr[i]) {
        q.push((node){now, pr[i], j, i - 1});
    }
}
while (k--) {
    node now = q.top(); q.pop();
    if (now.mi > 1) {
        for (int i = 1; i <= now.lim; i++) {
            q.push((node){now.val / now.p * pr[i], now.p, now.mi - 1, i});
        }
    }
}
```

---
处理用时：101.81秒
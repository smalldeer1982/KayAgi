# 题目信息

# 【化学】实验

## 题目背景

小 Z 紧张地坐在了一张化学实验桌前，进行着化学实验。

教室里又传来了一阵哀叹声：

我…我好像又错了…我能再试一次吗?

## 题目描述

在她的面前，摆放着 $n$ 个试管。试管里装着不明液体。对于每种不明液体，有 $2$ 个已知的化学属性：$a$ 和 $b$。第 $i$ 种液体的两个属性值分别为 $a_i$ 和 $b_i$。

现在，老师给她布置了 $m$ 个实验。

对于每一次实验，有一个参照量 $x$（第 $i$ 次实验的参照量记作 $x_i$）。她需要把不明液体分成尽可能多的组，且满足：任意两种不同组的液体$i$和$j$， $\operatorname{gcsd(a_i,a_j)}$ 都不能大于 $x^2$。

其中 $\operatorname{gcsd}$ 代表他们的最大公约平方数。$k$是两个数的公约平方数，当且仅当满足以下两个条件：

- $k$ 为这两个数的公约数；

- $k$ 为完全平方数。

而最大公约平方数 $\operatorname{gcsd}$ 为所有满足条件的 $k$ 中的最大者。

形象的说， $\operatorname{gcsd}$ 可以理解成两个数的最大公约数的算术平方根的整数因式部分的平方。

例如：

求 $\operatorname{gcsd(24,64)}$，就是先求出 $24,64$ 的最大公约数，是 $8$ ，然后 $\sqrt 8=2\sqrt 2$，其整数因式是 $2$，所以 $\operatorname{gcsd(24,64)}=2^2=4$。

她还需要在分组数最多的情况下，使自己的实验得分最大。

实验得分的定义：对于每一种试剂，定义其得分 $c_i$ 为 $b_i$ 分解质因数之后最大的**指数**。

例如：$b_i=12=2^2\times 3^1$，$c_i=\max\{2,1\}=2$。

$b_i=90=2^1\times 3^2\times 5^1$，$c_i=\max\{1,2,1\}=2$。

而实验得分即为所有组内的 $c_i$ 的最大值之和。

当然，她的 $IQ$ 并不高，所以需要请求你的帮助。

## 说明/提示

#### 样例解释 #1

$b_1=2=2^1,c_1=1$。

$b_2=4=2^2,c_2=2$。

$b_3=6=2^1\times 3^1,c_3=\max\{1,1\}=1$。

$b_4=8=2^3,c_4=3$。

$b_5=10=2^1\times 5^1,c_5=\max\{1,1\}=1$。

当 $x=2$ 时，可分为三组：$\{1,2,4\},\{3\},\{5\}$。

实验得分为$\max\{1,2,3\}+\max\{1\}+\max\{1\}=5$。

----------

#### 数据范围

**「本题采用捆绑测试」**

| subtask | $n\le$ | $m\le$ | $a_i \le$ | $b_i\le$ | $x \le$ | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |:-----------:|
| $1$ | $4$ | $6$ | $100$ | $4 \times 10^4$ | $100$ | $5$ |
| $2$ | $8$ | $7$ | $20$ | $10^3$ | $10$ | $5$ |
| $3$ |$20$ | $30$ | $50$ | $8 \times 10^3$ | $100$ | $10$ |
| $4$ |$100$ | $60$ | $100$ | $4 \times 10^4$ | $10^3$ | $10$ |
| $5$ |$5 \times 10^3$ | $110$ |  $10^3$| $10^5$ | $4 \times 10^3$ | $10$ |
| $6$ |$2 \times 10^4$ | $250$ | $3 \times 10^3$ | $10^6$ | $3 \times 10^3$ | $10$ |
| $7$ |$ 5 \times 10^4$| $10^3$ | $10^4$ | $2 \times 10^7$ | $1.5 \times 10^4$ | $15$ |
| $8$ |$10^5$  | $8 \times 10^3$ | $2 \times 10^4$ | $2 \times 10^7$ | $2.2 \times 10^4$ | $15$ |
| $9$ |$2 \times 10^5$  | $2 \times 10^5$ | $4 \times 10^4$ | $2 \times 10^7$ | $3 \times 10^4$ | $20$ |


对于 $100\%$ 的数据：

$1 \le n,m \le 2\times 10^5$，$2 \le a_i \le 4\times 10^4$，$2 \le b_i \le 2\times 10^7$，$2 \le x \le 3\times 10^4$。

我$\dots$我好像又错了$\dots$我能再试一次吗?

## 样例 #1

### 输入

```
5 5
36 72 4 9 16
2 4 6 8 10
2 3 4 5 6
```

### 输出

```
3 5
4 7
4 7
4 7
5 8```

# AI分析结果



**唯一算法分类**：数学（数论）与并查集结合

---

### **题解思路与算法要点**

#### **核心思路**
1. **预处理关键属性**：
   - **h(a_i)**：将每个 a_i 的最大平方因子提取后的平方根（如 24→√4=2）。
   - **c_i**：b_i 分解质因数后的最大指数。
   
2. **离线处理查询**：
   - 按 x 从大到小枚举，动态维护并查集。每次处理 x 时，合并所有 h 值为 x 倍数的元素。

3. **并查集优化**：
   - 对每个 x，合并所有 h 值为 x 倍数的元素，确保这些元素在同一组（因为它们的 GCD 至少为 x）。

#### **解决难点**
- **快速计算 h 和 c**：通过线性筛预处理质因数分解，将复杂度降至 O(n)。
- **高效处理多组查询**：离线排序 x，利用并查集动态合并，避免重复计算。

---

### **题解评分 (≥4星)**
1. **鏡音リン (★★★★★)**  
   - **亮点**：高效预处理 + 并查集动态合并，代码简洁，复杂度最优。
   - **代码片段**：
     ```cpp
     for (int i = R-1; i >= 2; i--) {
         ans[i] = co[i] + cnt;
         for (int j = 2; i*j < R; j++) if (mv[i*j]) {
             int x = fa(i), y = fa(i*j);
             if (x != y) {
                 f[x] = y;
                 cnt.x--;
                 cnt.y -= std::min(p[x], p[y]);
                 p[y] = std::max(p[x], p[y]);
             }
         }
     }
     ```

2. **Singulet31258 (★★★★☆)**  
   - **亮点**：详细数学推导，提出增强数据解法，适合深入学习。
   - **代码片段**：
     ```cpp
     int f(int x) {
         int r=1,t;
         for(const accel&i:p) if (i.p*i.p*i.p > x) break;
         // ... 试除法计算最大指数
     }
     ```

---

### **最优思路提炼**
1. **数学转换**：将 gcsd 转化为 GCD 问题，简化条件判断。
2. **线性筛预处理**：快速计算 h(a_i) 和 c_i。
3. **离线并查集**：从大到小处理 x，合并因子倍数，动态维护连通性。

---

### **类似题目推荐**
1. **P1495 曹冲养猪**（中国剩余定理 + 因数分解）
2. **P3383 线性筛素数**（预处理质因数）
3. **P1892 团伙**（并查集处理分组条件）

---

### **可视化设计**
**动画方案**：  
- **像素化并查集合并**：用不同颜色方块表示不同连通块，合并时显示动态连线。
- **高亮当前 x**：屏幕顶部显示当前处理的 x 值，右侧面板展示组数与得分变化。
- **音效提示**：合并时播放“哔”声，得分更新时播放上扬音调。

**复古风格**：  
- **8位像素网格**：每个节点用 16x16 像素块表示，合并时显示爆炸特效。
- **自动演示模式**：按 x 从大到小自动播放，支持暂停/步进。

---

### **核心代码实现**
鏡音リン的预处理与合并逻辑：
```cpp
void prime() {
    for (int i = 2; i < M; i++) {
        if (!s[i]) {
            pr.push_back(i);
            s[i] = i;
            st[i] = 1;
            if (i < L) h[i] = 1;
        }
        for (int j : pr) {
            if (i*j >= M) break;
            s[i*j] = j;
            st[i*j] = (s[i] == j) ? st[i]+1 : 1;
            if (i*j < L) h[i*j] = (s[i] == j && st[i] & 1) ? h[i]*j : h[i];
            if (i % j == 0) break;
        }
    }
}
```

---
处理用时：95.66秒
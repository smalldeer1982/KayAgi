# 题目信息

# [NOI2015] 寿司晚宴

## 题目描述

为了庆祝 NOI 的成功开幕，主办方为大家准备了一场寿司晚宴。小 G 和小 W 作为参加 NOI 的选手，也被邀请参加了寿司晚宴。

在晚宴上，主办方为大家提供了 $n−1$ 种不同的寿司，编号 $1,2,3,\ldots,n-1$，其中第 $i$ 种寿司的美味度为 $i+1$。（即寿司的美味度为从 $2$ 到 $n$）

现在小 G 和小 W 希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小 G 品尝的寿司种类中存在一种美味度为 $x$ 的寿司，小 W 品尝的寿司中存在一种美味度为 $y$ 的寿司，而 $x$ 与 $y$ 不互质。

现在小 G 和小 W 希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数 $p$ 取模）。注意一个人可以不吃任何寿司。


## 说明/提示

【数据范围】


 ![](https://cdn.luogu.com.cn/upload/pic/1506.png) 


**勘误：$0 < p \le 10^9 $**

## 样例 #1

### 输入

```
3 10000```

### 输出

```
9```

## 样例 #2

### 输入

```
4 10000```

### 输出

```
21```

## 样例 #3

### 输入

```
100 100000000```

### 输出

```
3107203```

# AI分析结果



# 寿司晚宴题解分析

## 唯一算法分类
**状压DP**

---

## 题解思路与核心难点

### 核心思路
1. **质因数分组**：
   - 每个数分解质因数后，≤√500（即≤19）的质数为小质数，用8位二进制状压（对应2,3,5,7,11,13,17,19）
   - 大质数（>19）单独分组，同一大质数的数必须分到同一集合或都不选

2. **状态转移**：
   - 主状态`dp[s1][s2]`表示两集合的小质数状态分别为`s1`和`s2`
   - 对大质数组分别用`f1`（分给第一集合）和`f2`（分给第二集合）处理内部转移
   - 每处理完一个大质数组后合并：`dp = f1 + f2 - dp`（去重都不选的情况）

3. **滚动数组优化**：
   - 倒序遍历状态避免重复计算
   - 内存优化至O(2^16)

---

## 题解评分（≥4星）

### 1. Orion545（5星）
- **亮点**：完整分解质因数逻辑，清晰展示大质数分组处理流程
- **代码片段**：
  ```cpp
  memcpy(f1, dp, sizeof(f1)); 
  memcpy(f2, dp, sizeof(f2));
  for (j从255递减) 
    if (!(s2 & a[i].S)) f1更新;
    if (!(s1 & a[i].S)) f2更新;
  dp合并逻辑;
  ```

### 2. 翼德天尊（4星）
- **亮点**：详细解释大质数分组原理，适合新手理解
- **代码特点**：明确结构体排序和分阶段处理

### 3. ethan_zhou（4星）
- **亮点**：提出O(n×3⁸)优化，枚举合法状态减少计算量
- **核心代码**：
  ```cpp
  for(s1从ALL-1递减)
    int tmp = (ALL-1)^s1;
    for(s2遍历tmp子集)
      f[j][k]合并逻辑;
  ```

---

## 最优技巧提炼

### 关键技巧
1. **质因数分层处理**：
   - 小质数状压，大质数分组独立处理
2. **双数组滚动更新**：
   - 用`f1`和`f2`分别处理当前大质数组的两种分配可能
3. **合并去重**：
   - 最后合并时减去重复的都不选情况

### 代码优化
- **倒序更新状态**：避免覆盖未处理状态
- **二进制运算加速**：`s1 & s2 == 0`快速判断互斥

---

## 同类型题推荐
1. **P2709 小B的询问**：区间统计与分块处理
2. **P2153 [SDOI2009]晨跑**：质因数分组的图论问题
3. **P2831 愤怒的小鸟**：状压处理几何覆盖

---

## 可视化设计

### 动画演示
- **像素风格**：用8位色块表示质因数状态（如红色块表示s1，蓝色块表示s2）
- **关键步骤**：
  1. 分解数显示小质数（闪烁对应bit位）和大质数（单独高亮）
  2. 处理大质数组时，整组颜色变化（黄色高亮）
  3. 状态转移时显示f1/f2数组的更新轨迹

### 音效设计
- **转移成功**：8-bit "哔"声
- **合并去重**：短促"咔嚓"声
- **错误冲突**：低沉嗡鸣声

### 交互功能
- **步进控制**：键盘方向键控制算法执行步
- **自动演示**：AI模式展示最优状态转移路径

---

## 核心代码实现
```cpp
// 处理大质数组的核心逻辑
for(int i=2; i<=n; ++i){
    if(大质数变化){
        memcpy(f1, dp, sizeof(f1));
        memcpy(f2, dp, sizeof(f2));
    }
    // 倒序更新f1/f2
    for(int s1=255; s1>=0; --s1)
    for(int s2=255; s2>=0; --s2){
        if(!(s2 & curS)) f1[s1|curS][s2] += f1[s1][s2];
        if(!(s1 & curS)) f2[s1][s2|curS] += f2[s1][s2];
    }
    // 合并到主dp
    if(大质数组结束){
        for(int s1=0; s1<=255; ++s1)
        for(int s2=0; s2<=255; ++s2)
            dp[s1][s2] = (f1[s1][s2] + f2[s1][s2] - dp[s1][s2] + MOD) % MOD;
    }
}
```

---

**学习提示**：重点理解质因数分层处理的思想，这是解决包含互质条件的状压DP问题的通用技巧。建议通过可视化工具观察状态转移过程，加深对滚动数组优化的理解。

---
处理用时：73.85秒
# 题目信息

# [SDOI2015] 序列统计

## 题目描述

小C有一个集合 $S$，里面的元素都是小于 $m$ 的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为 $n$ 的数列，数列中的每个数都属于集合 $S$。  

小C用这个生成器生成了许多这样的数列。但是小C有一个问题需要你的帮助：给定整数 $x$，求所有可以生成出的，且满足数列中所有数的乘积 $\bmod \ m$ 的值等于 $x$ 的不同的数列的有多少个。  

小C认为，两个数列 $A$ 和 $B$ 不同，当且仅当 $\exists i \text{ s.t. } A_i \neq B_i$。另外，小C认为这个问题的答案可能很大，因此他只需要你帮助他求出答案对 $1004535809$ 取模的值就可以了。


## 说明/提示

【样例说明】

可以生成的满足要求的不同的数列有(1,1,1,1)、(1,1,2,2)、(1,2,1,2)、(1,2,2,1)、(2,1,1,2)、(2,1,2,1)、(2,2,1,1)、(2,2,2,2)。

【数据规模和约定】

对于 $10\%$ 的数据，$1\le n \le 1000$；   
对于 $30\%$ 的数据，$3 \le m \le 100$；    
对于 $60\%$ 的数据，$3 \le m \le 800$；   
对于 $100\%$ 的数据，$1 \le n \le 10^9$，$3 \le m \le 8000$，$1\le x < m$。   
$m$ 为质数，输入数据保证集合 $S$ 中元素不重复。


## 样例 #1

### 输入

```
4 3 1 2
1 2```

### 输出

```
8```

# AI分析结果



**唯一算法分类**：数论与多项式快速幂  

---

### **题解思路、算法要点与解决难点**  
**核心思路**：  
1. **原根转换**：利用质数原根将乘积问题转化为加法问题。原根\( g \)的幂次覆盖所有非零模\( m \)元素，将每个数\( x \)转化为\( \log_g x \)。  
2. **多项式快速幂**：通过快速傅里叶变换（NTT）加速多项式乘法，处理模意义下的加法卷积。  
3. **倍增优化**：将指数\( n \)二进制分解，通过倍增法合并多项式结果，复杂度\( O(m \log m \log n) \)。  

**关键难点与解决**：  
- **原根判定**：暴力枚举原根并验证其幂次覆盖性，确保指数唯一性。  
- **模意义下卷积**：在每次NTT后手动将超出\( m-1 \)的项循环累加，保证结果正确。  
- **零元素处理**：集合中的零元素需排除（因其无法用原根表示），单独处理。  

---

### **题解评分 (≥4星)**  
1. **ZigZagKmp（5星）**  
   - **亮点**：详细推导原根转换与多项式卷积的数学逻辑，代码注释清晰，提供多例题类比。  
   - **代码**：完整实现NTT与倍增快速幂，处理模意义下循环累加。  
   - **心得**：强调原根的重要性与多项式卷积的通用性。  

2. **何俞均（4星）**  
   - **亮点**：代码简洁，原根判定函数优化，直接调用NTT库函数。  
   - **不足**：推导部分较简略，依赖前置知识。  

3. **Keln（4星）**  
   - **亮点**：数学符号推导严谨，代码高度优化，利用费马小定理简化指数运算。  
   - **技巧**：使用`map`快速建立原根与指数的双向映射。  

---

### **最优思路或技巧提炼**  
1. **原根转换**：将模\( m \)乘法群转换为加法群，利用指数性质简化问题。  
2. **NTT加速卷积**：通过快速数论变换处理多项式乘法，时间复杂度从\( O(m^2) \)降至\( O(m \log m) \)。  
3. **循环累加技巧**：在NTT后将高位系数循环累加到低位，确保模\( m-1 \)正确性。  

---

### **同类型题或类似算法套路**  
- **乘法转加法**：涉及原根/离散对数的题目（如P6091、P3321）。  
- **多项式快速幂**：动态规划优化问题（如P4721、P4233）。  

---

### **推荐题目**  
1. **P6091**：原根判定与生成。  
2. **P4238**：多项式乘法逆（NTT应用）。  
3. **P5488**：差分与前缀和的快速幂。  

---

### **个人心得摘录**  
- **调试教训**：原根判定函数中需验证所有质因子，避免遗漏导致错误（ZigZagKmp）。  
- **优化技巧**：预处理原根指数映射表，避免重复计算（Keln）。  

---

### **可视化与算法演示**  
**动画设计**：  
1. **原根转换**：  
   - 像素风格展示集合元素\( x \)转换为\( \log_g x \)，高亮原根计算过程。  
   - 音效：转换成功时播放“叮”声，失败（如遇到0）则播放“哔”声。  

2. **NTT快速幂**：  
   - **Canvas网格**：显示多项式系数数组，当前操作位置（如蝴蝶变换）闪烁红色。  
   - **步进控制**：单步执行NTT的每一层循环，展示系数合并与拆分。  
   - **音效**：每次卷积完成时播放短促音效，倍增合并时音调升高。  

3. **循环累加**：  
   - 高位系数（如\( m \leq i < 2m \)）以蓝色块表示，自动滑向低位对应位置，触发“滑动”音效。  

**复古游戏化**：  
- **8位像素界面**：算法步骤以网格块表示，原根查找过程模拟“扫雷”式探索。  
- **积分系统**：每完成一次NTT卷积得10分，正确累加高位系数额外奖励。  

---

### **代码核心实现**  
```cpp  
// 原根转换与多项式快速幂核心代码（ZigZagKmp）  
void mul(int *f, int *g, int *ans, int mod_x) {  
    // ... NTT卷积后处理模意义循环  
    for (int i = mod_x; i < N; i++)  
        ans[i % mod_x] = (ans[i % mod_x] + tmp1[i]) % mod;  
}  
void Ksm(int p) {  
    while (p) {  
        if (p & 1) mul(ans, f[i], ans);  
        mul(f[i], f[i], f[i+1]); // 倍增合并  
        p >>= 1;  
    }  
}  
```

**完整代码**：[见原题解列表](#)  

---

**可视化JS片段**（伪代码）：  
```javascript  
// Canvas绘制NTT过程  
function drawCoefficients(coeffs, highlightIdx) {  
    ctx.clearRect(0, 0, canvas.width, canvas.height);  
    coeffs.forEach((val, idx) => {  
        ctx.fillStyle = idx === highlightIdx ? '#FF0000' : '#00FF00';  
        ctx.fillRect(idx * 10, 100 - val * 2, 8, val * 2);  
    });  
    playSound('beep');  
}  
```  

--- 

**总结**：本题通过原根与多项式快速幂的巧妙结合，将复杂乘积问题转化为高效可计算的加法卷积，结合NTT与倍增法实现对数时间复杂度的求解。可视化设计通过像素动画与音效交互，直观展现算法核心步骤。

---
处理用时：76.78秒
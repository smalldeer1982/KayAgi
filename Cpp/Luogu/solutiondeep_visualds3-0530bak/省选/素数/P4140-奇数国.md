# 题目信息

# 奇数国

## 题目描述

在一片美丽的大陆上有 $100\,000$ 个国家，记为 $1$ 到 $100\,000$。这里经济发达，有数不尽的账房，并且每个国家有一个银行。

某大公司的领袖在这 $100\,000$ 个银行开户时都存了 $3$ 大洋，他惜财如命，因此会不时地派小弟 GFS 清点一些银行的存款或者让 GFS 改变某个银行的存款。

该村子在财产上的求和运算等同于我们的乘法运算，也就是说领袖开户时的存款总和为 $3^{100000}$。这里发行的软妹面额是最小的 $60$ 个素数（$p_1=2,p_2=3,\ldots, p_{60}=281$），任何人的财产都只能由这 $60$ 个基本面额表示，即设某个人的财产为 $fortune$（正整数），则 $fortune=p_1^{k_1} \times p_2^{k_2} \times \ldots p_{60}^{k_{60}}$。

领袖习惯将一段编号连续的银行里的存款拿到一个账房去清点，为了避免 GFS 串通账房叛变，所以他不会每次都选择同一个账房。GFS 跟随领袖多年已经摸清了门路,知道领袖选择账房的方式。如果领袖选择清点编号在 $[a,b]$ 内的银行财产，他会先对 $[a,b]$ 的财产求和（记为 $product$），然后在编号属于 $[1,product]$ 的账房中选择一个去清点存款，检验自己计算是否正确同时也检验账房与 GFS 是否有勾结。GFS 发现如果某个账房的编号 $number$ 与 $product$ 相冲，领袖绝对不会选择这个账房。

怎样才算与 $product$ 不相冲呢？若存在整数 $x,y$ 使得 $number \times x+product \times y=1$，那么我们称 $number$ 与 $product$ 不相冲，即该账房有可能被领袖相中。当领袖又赚大钱了的时候，他会在某个银行改变存款，这样一来相同区间的银行在不同的时候算出来的 $product$ 可能是不一样的，而且领袖不会在某个银行的存款总数超过 $10^6$。

现在 GFS 预先知道了领袖的清点存款与变动存款的计划，想请你告诉他，每次清点存款时领袖有多少个账房可以供他选择，当然这个值可能非常大，GFS 只想知道对 $19\,961\,993$ 取模后的答案。

## 说明/提示

### 样例解释

- 初始化每个国家存款都为 $3$；
- $1$ 到 $3$ 的 $product$ 为 $27$，$[1,27]$ 与 $27$ 不相冲的有 $18$ 个数；
- $1$ 的存款变为 $5$；
- $1$ 到 $3$ 的 $product$ 为 $45$，$[1,45]$ 与 $45$ 不相冲的有 $24$ 个数；
- $1$ 的存款变为 $7$；
- $1$ 到 $3$ 的 $product$ 为 $63$，$[1,63]$ 与 $63$ 不相冲的有 $36$个数；
- $2$ 到 $3$ 的 $product$ 为 $9$，$[1,9]$ 与 $9$ 不相冲的有 $6$ 个数。

### 数据范围

所有数据均满足：$x \geq 1$，$c_i -b_i \geq 0$。

| 子任务编号 | 分值 |    $x \leq$     | $c_i - b_i \leq$ | 特殊性质 |
| :--------: | :--: | :-------------: | :--------------: | :------: |
|    $1$     | $20$ |     $10^4$      |      $100$       |    有    |
|    $2$     | $30$ | $5 \times 10^4$ |      $10^4$      |    无    |
|    $3$     | $50$ |     $10^5$      |      $10^5$      |    无    |

特殊性质指：所有 $product \leq 10^{18}$。

## 样例 #1

### 输入

```
6
0 1 3
1 1 5
0 1 3
1 1 7
0 1 3
0 2 3```

### 输出

```
18
24
36
6

```

# AI分析结果



## **唯一算法分类**  
线段树 + 状态压缩

---

## **综合分析与结论**  
### **核心思路**  
所有题解均基于以下两个关键点：  
1. **欧拉函数的分解性质**：φ(n) = n × Π(1-1/p_i)，只与质因子种类有关，与次数无关  
2. **质因子状态压缩**：前60个质数的存在状态用 long long 的二进制位表示  

### **算法流程**  
1. **线段树节点设计**  
   - `mul`：区间乘积取模后的值  
   - `mask`：60位二进制掩码，记录存在的质因子  
2. **合并操作**  
   - `mul[left] * mul[right] % mod`  
   - `mask[left] | mask[right]`  
3. **查询操作**  
   - 递归合并子区间信息  
   - 最终用 `mask` 计算欧拉函数  

### **可视化设计要点**  
采用 **8位像素风格** 展示线段树操作：  
1. **节点显示**  
   - **绿色像素块**：当前活跃的线段树节点  
   - **黄色高亮**：修改/查询时涉及的节点路径  
   - **右侧面板**：显示当前节点的 `mul` 值和二进制掩码  
2. **动画效果**  
   - **位运算闪烁**：当掩码进行按位或操作时，相关二进制位闪烁白光  
   - **音效设计**：  
     - `嘟~`：节点更新时的提示音  
     - `叮~`：质因子掩码变化的提示音  
3. **交互控制**  
   - 速度调节滑块控制动画步进间隔  
   - 空格键暂停/继续，方向键单步前进  

---

## **题解清单 (≥4星)**  
### **1. Siyuan 题解 (⭐⭐⭐⭐⭐)**  
**亮点**：  
- 使用线段树维护乘积与质因子掩码  
- 预处理逆元数组优化计算  
- 代码结构清晰，包含详细注释  

**核心代码**：  
```cpp  
void pushup(int p) {
    seg[p] = seg[lson] | seg[rson]; // 按位或合并掩码
    mul[p] = 1LL * mul[lson] * mul[rson] % mod;
}
int query(int l, int r) {
    int ans = queryMul(l, r);      // 区间乘积
    long long f = queryFac(l, r);  // 质因子掩码
    for(int i=0; i<60; ++i)        // 计算欧拉函数
        if(f & (1LL<<i)) 
            ans = 1LL * ans * invpr[i] % mod * (prime[i]-1) % mod;
    return ans;
}
```

### **2. gyh20 题解 (⭐⭐⭐⭐)**  
**亮点**：  
- 树状数组维护每个质数的出现次数  
- 利用费马小定理预处理逆元  
- 实现简洁，适合理解分治思想  

**核心代码**：  
```cpp  
void add(int x, int a, int b) { // 树状数组更新
    for(;a<=n;a+=a&-a) bit[x][a]+=b;
}
int ask(int x, int a) { // 查询质数出现次数
    int s=0; for(;a;a-=a&-a) s+=bit[x][a]; return s;
}
```

### **3. Surge_of_Force 题解 (⭐⭐⭐⭐)**  
**亮点**：  
- 详细注释调试过程中的常见错误  
- 使用位运算优化状态合并  
- 完整演示线段树建树过程  

**核心代码**：  
```cpp  
void push_up(int k) {
    a[k].mul = a[lc(k)].mul * a[rc(k)].mul % mod;
    a[k].w = a[lc(k)].w | a[rc(k)].w; // 关键合并操作
}
```

---

## **最优思路提炼**  
1. **状态压缩**：用 long long 的二进制位表示60个质因子的存在  
2. **逆元预处理**：避免模运算中的除法，提升计算效率  
3. **线段树特性**：  
   - 单点修改时间复杂度 O(logn)  
   - 区间查询自动合并子节点信息  

---

## **相似题目推荐**  
1. **P3373 线段树 2**：区间乘法和加法混合操作  
2. **P1494 小Z的袜子**：区间统计与组合数学  
3. **P4137 Rmq Problem**：区间 mex 查询与维护  

---

## **可视化方案**  
### **像素风格演示**  
1. **线段树结构**：  
   - **绿色方块**：线段树节点，显示区间范围  
   - **红色边框**：当前操作的叶子节点  
2. **数据流动**：  
   - **黄色箭头**：查询时子节点向父节点的数据合并  
   - **蓝色波纹**：修改操作从叶子节点向上更新  
3. **音效配合**：  
   - 节点更新时播放 `哔~` 声  
   - 质因子掩码变化时播放 `咔嚓` 声  

---

## **调试心得摘录**  
> "线段树建树范围错误导致WA，必须从1到100000而不是n" —— Arcturus1350  
> "1<<i 必须写成 1LL<<i，否则会溢出" —— 封禁用户  
> "逆元预处理时模数写错，调试两天才发现" —— DrLin  

---

## **核心代码实现**  
```cpp  
// 线段树查询质因子掩码
long long queryFac(int l, int r, int p=1, int tl=1, int tr=1e5) {
    if(l > tr || r < tl) return 0;
    if(l <= tl && tr <= r) return seg[p];
    return queryFac(l, r, lc, tl, mid) | 
           queryFac(l, r, rc, mid+1, tr);
}

// 计算欧拉函数核心逻辑
int calc_phi(int product, long long mask) {
    int res = product;
    for(int i=0; i<60; ++i) {
        if(mask & (1LL << i)) {
            res = 1LL * res * inv[i] % mod;  // 乘以逆元
            res = 1LL * res * (prime[i]-1) % mod;
        }
    }
    return res;
}
```

---
处理用时：76.99秒
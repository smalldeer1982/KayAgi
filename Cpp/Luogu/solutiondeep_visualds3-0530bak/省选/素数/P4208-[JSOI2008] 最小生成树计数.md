# 题目信息

# [JSOI2008] 最小生成树计数

## 题目描述

现在给出了一个简单无向加权图。你不满足于求出这个图的最小生成树，而希望知道这个图中有多少个不同的最小生成树。（如果两棵最小生成树中至少有一条边不同，则这两个最小生成树就是不同的）。由于不同的最小生成树可能很多，所以你只需要输出方案数对 $31011$ 的模就可以了。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le n \le 100$，$1 \le m \le 1000$，$1\leq c_i\leq 10^9$。

## 样例 #1

### 输入

```
4 6
1 2 1
1 3 1
1 4 1
2 3 2
2 4 1
3 4 1```

### 输出

```
8
```

# AI分析结果



**唯一算法分类**：生成树计数

---

### 综合分析与结论

**核心思路**：  
1. **定理应用**：所有最小生成树中，相同权值的边出现次数相同。  
2. **分权值处理**：对每个权值的边独立计算合法选择方案数，最终通过乘法原理合并结果。  
3. **核心步骤**：  
   - 用 Kruskal 算法生成一个最小生成树，记录各权值的边出现次数 `cnt[w]`。  
   - 对每个权值 `w` 的边集合：  
     - **缩点**：将其他权值的边形成的连通块视为单个点。  
     - **子图生成树计算**：在缩点后的图中，用矩阵树定理或枚举法统计合法边组合数。  

**难点与解决方案**：  
- **缩点操作**：使用并查集维护当前连通性，确保其他权值的边已全部加入。  
- **行列式计算（矩阵树定理）**：模数非质数时需用辗转相除法求行列式。  
- **枚举法回溯**：并查集不能路径压缩，需手动回溯状态。  

**可视化设计**：  
- **动画流程**：  
  1. 初始图展示，按边权分组高亮。  
  2. Kruskal 过程中逐步加入边，动态显示并查集合并。  
  3. 对当前权值 `w` 的边，切换至缩点视图（连通块为像素块），展示矩阵树计算或枚举选择过程。  
- **像素风格**：  
  - **颜色方案**：不同权值边用不同颜色，连通块用渐变色区分。  
  - **音效**：加入边时播放“连接”音效，计算完成时播放成功音调。  

---

### 题解清单（评分≥4星）

1. **smarthehe（⭐️⭐️⭐️⭐️⭐️）**  
   - **亮点**：清晰区分枚举与矩阵树定理，复杂度分析严谨，代码注释详细。  
   - **核心**：缩点后矩阵树计算，行列式辗转相除实现。  

2. **Siyuan（⭐️⭐️⭐️⭐️⭐️）**  
   - **亮点**：分简化版与加强版代码，提供完整定理证明，适合不同基础读者。  
   - **核心**：矩阵树定理实现，模数处理优化。  

3. **Kelin（⭐️⭐️⭐️⭐️）**  
   - **亮点**：代码简洁，使用基尔霍夫矩阵直接计算，适合快速实现。  
   - **核心**：动态维护缩点后的矩阵，行列式快速计算。  

---

### 核心代码实现

**矩阵树定理（smarthehe 题解片段）**：  
```cpp
int treecnt() { // 行列式计算
    int ans = 1;
    for (int i = 1; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            while (mat[j][i]) { // 辗转相除消元
                int div = mat[i][i] / mat[j][i];
                for (int k = i; k < n; ++k)
                    mat[i][k] = (mat[i][k] - mat[j][k] * div % MOD + MOD) % MOD;
                swap(mat[i], mat[j]);
                ans *= -1;
            }
        }
        ans = ans * mat[i][i] % MOD;
    }
    return (ans + MOD) % MOD;
}
```

**枚举法（Kevin_Wa 题解片段）**：  
```cpp
void dfs(int x, int now, int k) { // 枚举边组合
    if (now > bian[x].r) {
        if (k == bian[x].choose) sum++;
        return;
    }
    int u = find(e[now].u), v = find(e[now].v);
    if (u != v) { // 选当前边
        fa[u] = v;
        dfs(x, now + 1, k + 1);
        fa[u] = u; // 回溯
    }
    dfs(x, now + 1, k); // 不选
}
```

---

### 类似题目推荐

1. **P2144 [FJOI2007] 轮状病毒**  
   - 矩阵树定理应用，计算生成树数量。  

2. **P3317 [SDOI2014] 重建**  
   - 变种矩阵树定理，处理边权概率。  

3. **P5292 [HNOI2019] 校园旅行**  
   - 图论分治思想，结合并查集维护连通性。  

---

### 个人心得摘录

- **调试教训**：枚举法中并查集路径压缩导致回溯错误，需用非压缩版本。  
- **优化技巧**：权值离散化减少计算量，预处理边分组加速枚举。  

---

### 可视化算法演示（核心步骤）

**动画步骤**：  
1. **初始图**：所有边按权值分组，不同颜色区分。  
2. **Kruskal 过程**：动态显示边排序和并查集合并，高亮当前处理的边。  
3. **权值处理阶段**：  
   - **缩点视图**：连通块显示为像素块，当前权值的边闪烁。  
   - **矩阵树计算**：矩阵元素动态变化，行列式消元步骤高亮。  
4. **结果展示**：各阶段方案数以像素数字显示，最终乘积动画展示。  

**交互设计**：  
- **速度调节**：滑块控制动画速度，支持暂停/继续。  
- **模式切换**：选择枚举法或矩阵树演示，对比不同方法的执行流程。

---
处理用时：80.71秒
# 题目信息

# 公主の#19准备月考

## 题目背景

公主在玩完游戏后，也要月考了。（就算是公主也要月考啊QWQ）


## 题目描述

公主的文综太差了，全校排名1100+（全校就1100多人），她分析了好久，发现她如果把所有时间放在选择题上，得分会比较好一点。

文综题目共有n个，编号从1到n

公主给每个题目算出来了一个预估值Ai，她认为，一段连续题目的答案会在它们的预估值的gcd和lcm之间；有时候她的想法不同了，一些题目的预估值会改变；有时候，会出现多选题，多选题的答案数量就是一段连续题目答案的预估值的公约数的个数。

具体来说，对于一个数列，有四种操作：

L x y p 表示公主询问区间[x,y]的数字的lcm对p取模之后的值

G x y p 表示公主询问区间[x,y]的数字的gcd对p取模之后的值

C x y c 表示公主改变区间[x,y]的数字的值，统一为c

S x y p 表示公主询问区间[x,y]的数字的公因数个数对p取模之后的值

公主月考不能挂科，不然她就不能学习OI了（假的），所以请你帮帮她吧！


## 说明/提示

对于30%的数据，1<=n,q<=1000

对于另外20%的数据，1<=n<=1000，1<=q<=100000

对于另外20%的数据，1<=n<=100000，1<=q<=100000，保证没有修改操作

对于100%的数据，1<=n<=300000，1<=q<=300000

保证任何时刻每个题目的预估值都在[1,100]之间，答案取模之后不超过int


## 样例 #1

### 输入

```
10 10
42 68 35 1 70 25 79 59 63 65 
L 2 6 28
L 2 6 43
G 2 7 5
G 3 4 83
L 7 9 96
G 2 7 39
S 3 8 100
L 4 5 12
G 4 4 65
L 2 4 69```

### 输出

```
0
32
1
1
75
1
1
10
1
34```

# AI分析结果



# 算法分类选择  
**线段树 + 质因数分解位压缩**

---

## 题解思路与核心难点  
### 核心思路  
1. **质因数位压缩**：将每个数的质因数分解结果压缩为二进制位。例如：  
   - 2的指数范围0~6 → 3位  
   - 3的指数范围0~4 → 3位  
   - 其他质数仅需判断是否存在 → 1位  
   总计31位，可用一个int存储。  
2. **线段树设计**：每个节点保存区间的GCD和LCM的压缩形式，合并时通过位运算快速取min/max。  
3. **高效查询**：将压缩后的二进制位转换为实际数值时，通过快速幂计算模结果。  

### 解决难点  
- **快速合并区间信息**：通过预处理的位掩码和位移操作，在O(1)时间内完成GCD/LCM的合并。  
- **动态处理模数**：每次查询的模数不同，需在计算时实时处理模运算。  
- **约数个数计算**：将GCD的压缩形式分解后，统计各质数出现次数+1的乘积。  

---

## 题解评分 (≥4星)  
1. **Vingying (★★★★☆)**  
   - 亮点：精确的位压缩处理，完整支持动态模数，高效的位运算合并逻辑。  
   - 优化：预处理质数偏移量，代码虽长但结构清晰。  
   - 调试心得：提到卡常优化，通过位运算减少计算量。  

2. **Butterfly_qwq (★★★★☆)**  
   - 亮点：使用long long简化位操作，更直观的质数处理逻辑。  
   - 优化：通过位或/与运算直接合并区间，代码简洁易维护。  

3. **Hadtsti (★★★★☆)**  
   - 亮点：结构体存储质数次数，直观易懂，适合教学演示。  
   - 优化：直接遍历质数列表，适合小规模数据。  

---

## 最优思路与技巧提炼  
1. **质因数位压缩**：利用数值范围小的特性，将质数指数编码为紧凑二进制位。  
2. **线段树合并优化**：通过位掩码提取各质数段，取min/max后重新组合。  
3. **快速模运算处理**：分解压缩值时，仅对非零质数进行快速幂计算。  

---

## 类似算法套路  
- **区间统计问题**：如区间众数、区间乘积模数，均可通过质因数分解+线段树解决。  
- **位压缩应用**：适用于值域有限的高维状态合并（如二进制特征统计）。  

---

## 推荐相似题目  
1. P3372 线段树模板（区间加、求和）  
2. P5490 扫描线（区间覆盖统计）  
3. P1908 逆序对（分治+离散化）  

---

## 可视化与算法演示  
**动画设计思路**：  
1. **像素网格展示**：  
   - 每个线段树节点显示为矩形块，颜色表示当前GCD/LCM的质数分布。  
   - 质数2用红色像素块，高度表示指数；3用绿色，其他质数用不同颜色。  
2. **关键操作高亮**：  
   - 修改操作：目标区间闪烁黄色边框，质数分布更新为统一颜色。  
   - 查询操作：遍历路径节点显示蓝色边框，合并过程用光效连接。  
3. **音效交互**：  
   - 合并成功：8-bit上升音效。  
   - 懒标记下传：短促“滴答”声。  

**复古风格代码片段（伪代码）**：  
```javascript
// Canvas绘制线段树节点
function drawNode(node, x, y) {
  ctx.fillStyle = '#2D2D2D'; // 背景色
  ctx.fillRect(x, y, 50, 50);
  // 绘制质数2的指数（红色条）
  let bits2 = (node.gcd >> 0) & 0b111;
  ctx.fillStyle = '#FF0000';
  ctx.fillRect(x+5, y+40 - bits2*5, 10, bits2*5);
}
```

---

## 核心代码实现（Vingying解法关键函数）  
```cpp
// 质数位偏移预处理
int pri[] = {2,3,5,7,11,...,97}; // 25个质数
int b[25] = {0,3,6,8,10,...}; // 每个质数的位偏移

// 将数值转换为压缩格式
int cal(int tmp) {
  int v = 0;
  for(int i=0; i<25; i++) {
    while(tmp % pri[i] == 0) cnt[i]++, tmp /= pri[i];
    v |= cnt[i] << b[i];
  }
  return v;
}

// 线段树合并GCD
int calgcd(int v1, int v2) {
  int ret = 0;
  // 提取各质数段并取min
  for(int i=0; i<25; i++) {
    int mask = (1 << (b[i+1]-b[i])) - 1;
    int c1 = (v1 >> b[i]) & mask;
    int c2 = (v2 >> b[i]) & mask;
    ret |= (min(c1,c2) << b[i]);
  }
  return ret;
}
```

完整代码见原题解，关键为位压缩与线段树合并逻辑。

---
处理用时：79.18秒
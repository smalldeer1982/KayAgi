# 题目信息

# 于神之怒加强版

## 题目描述

给定 $n,m,k$，计算

$$\sum_{i=1}^n \sum_{j=1}^m \gcd(i,j)^k$$

对 $10^9 + 7$ 取模的结果。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq T \leq 2 \times 10^3$，$1 \leq n, m, k \leq 5 \times 10^6$。

## 样例 #1

### 输入

```
1 2
3 3```

### 输出

```
20```

# AI分析结果



**唯一算法分类**：莫比乌斯反演与积性函数线性筛

---

### **综合分析与结论**
#### **核心思路**
1. **问题转化**：将原式通过莫比乌斯反演转化为 $\sum_{T=1}^n \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor G(T)$，其中 $G(T) = \sum_{d|T} d^k \mu(\frac{T}{d})$。
2. **积性函数证明**：$G(n)$ 是积性函数，通过质数幂次分解式 $G(p^c) = p^{(c-1)k}(p^k - 1)$ 推导。
3. **线性筛优化**：利用积性函数性质在线性筛过程中计算 $G(n)$ 的前缀和。
4. **数论分块**：对 $\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor$ 进行分块处理，单次查询时间复杂度 $O(\sqrt{n})$。

#### **解决难点**
- **积性函数构造**：发现 $G(n) = (Id_k * \mu)(n)$ 是解题关键。
- **线性筛实现**：对质数幂次情况 $G(p^c)$ 的递推关系推导（$G(p^c) = G(p^{c-1}) \cdot p^k$）是核心优化点。
- **预处理效率**：通过 $O(n)$ 预处理实现 $5 \times 10^6$ 规模的快速计算。

---

### **题解清单（≥4星）**
1. **滑大稽（5星）**
   - **亮点**：完整推导积性函数性质，给出两种筛法证明，代码注释清晰。
   - **关键代码**：在线性筛中处理质数和合数的情况，通过 `qpow` 快速计算幂次。
   
2. **Wolfycz（5星）**
   - **亮点**：简洁推导质数幂次表达式，代码高效易读。
   - **核心代码**：直接计算 $f(p^c) = (p^k-1)p^{k(c-1)}$，避免复杂证明。

3. **ecnerwaIa（4.5星）**
   - **亮点**：代码实现最简洁，直接展示筛法核心逻辑。
   - **优化点**：使用 `pow` 函数预处理质数幂次，减少重复计算。

---

### **最优思路/技巧提炼**
1. **积性函数构造**：通过狄利克雷卷积 $Id_k * \mu$ 定义 $G(n)$，利用积性函数性质分解质因数。
2. **线性筛递推公式**：
   - 质数情况：$G(p) = p^k - 1$
   - 质数幂次：$G(p^c) = G(p^{c-1}) \cdot p^k$
   - 合数筛法：$G(ab) = G(a)G(b)$（当 $a,b$ 互质）
3. **数论分块加速**：将双重求和转化为 $\sum_{T=1}^n \lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor G(T)$，分块处理区间求和。

---

### **同类型题推荐**
1. **P3312 [SDOI2014]数表**（莫比乌斯反演+积性函数筛）
2. **P1829 [国家集训队]Crash的数字表格**（LCM求和，类似分块技巧）
3. **P3768 简单的数学题**（高级积性函数应用）

---

### **可视化与算法演示**
#### **核心流程动画设计**
1. **数论分块演示**：
   - **网格绘制**：在 Canvas 上绘制 $n \times m$ 网格，用不同颜色标记 $\lfloor \frac{n}{T} \rfloor$ 相同的区块。
   - **动态分块**：用滑动条控制 $T$ 值，高亮当前分块区间 $[l, r]$，显示对应的 $G(T)$ 累加过程。
   
2. **线性筛过程动画**：
   - **像素风格**：用 8-bit 像素方块表示数字，质数标记为绿色，合数标记为红色。
   - **筛法高亮**：当筛到 $i \times prime[j]$ 时，显示 $G(i \times prime[j])$ 的计算公式，例如：
     - 若 $i \bmod prime[j] = 0$，显示 $G(i \times p) = G(i) \cdot p^k$
     - 否则显示 $G(i \times p) = G(i) \cdot (p^k - 1)$

#### **复古游戏化实现**
- **音效设计**：
  - **质数发现**：播放《超级马里奥》金币音效
  - **分块完成**：使用《塞尔达传说》解谜成功音效
- **积分系统**：
  - 正确计算一个分块区间得 10 分
  - 连续正确计算 5 个质数幂次触发 "Combo" 特效

---

### **代码片段（核心筛法）**
```cpp
void init(int k) {
    g[1] = 1;
    for (int i = 2; i < MAXN; i++) {
        if (!vis[i]) {
            prime[++cnt] = i;
            g[i] = qpow(i, k) - 1; // 质数直接计算
        }
        for (int j = 1; j <= cnt && i*prime[j] < MAXN; j++) {
            vis[i*prime[j]] = 1;
            if (i % prime[j] == 0) {
                // 处理质数幂次情况
                g[i*prime[j]] = g[i] * (g[prime[j]] + 1) % MOD;
                break;
            }
            g[i*prime[j]] = g[i] * g[prime[j]] % MOD;
        }
    }
    // 前缀和预处理
    for (int i = 1; i < MAXN; i++) 
        sum_g[i] = (sum_g[i-1] + g[i]) % MOD;
}
```

---

### **个人心得摘录**
> "研究了一下午终于搞懂积性函数的筛法，关键要理解当 $i \bmod p=0$ 时，$G(ip)$ 的递推关系实际上是继承质数幂次的性质。" —— 滑大稽

> "用 $f(p^c) = (p^k-1)p^{k(c-1)}$ 可以直接避免复杂的卷积计算，这是数论题中积性函数的典型优化技巧。" —— Wolfycz

---
处理用时：74.26秒
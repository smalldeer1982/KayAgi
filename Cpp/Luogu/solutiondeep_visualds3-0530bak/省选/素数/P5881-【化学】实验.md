# 题目信息

# 【化学】实验

## 题目背景

小 Z 紧张地坐在了一张化学实验桌前，进行着化学实验。

教室里又传来了一阵哀叹声：

我…我好像又错了…我能再试一次吗?

## 题目描述

在她的面前，摆放着 $n$ 个试管。试管里装着不明液体。对于每种不明液体，有 $2$ 个已知的化学属性：$a$ 和 $b$。第 $i$ 种液体的两个属性值分别为 $a_i$ 和 $b_i$。

现在，老师给她布置了 $m$ 个实验。

对于每一次实验，有一个参照量 $x$（第 $i$ 次实验的参照量记作 $x_i$）。她需要把不明液体分成尽可能多的组，且满足：任意两种不同组的液体$i$和$j$， $\operatorname{gcsd(a_i,a_j)}$ 都不能大于 $x^2$。

其中 $\operatorname{gcsd}$ 代表他们的最大公约平方数。$k$是两个数的公约平方数，当且仅当满足以下两个条件：

- $k$ 为这两个数的公约数；

- $k$ 为完全平方数。

而最大公约平方数 $\operatorname{gcsd}$ 为所有满足条件的 $k$ 中的最大者。

形象的说， $\operatorname{gcsd}$ 可以理解成两个数的最大公约数的算术平方根的整数因式部分的平方。

例如：

求 $\operatorname{gcsd(24,64)}$，就是先求出 $24,64$ 的最大公约数，是 $8$ ，然后 $\sqrt 8=2\sqrt 2$，其整数因式是 $2$，所以 $\operatorname{gcsd(24,64)}=2^2=4$。

她还需要在分组数最多的情况下，使自己的实验得分最大。

实验得分的定义：对于每一种试剂，定义其得分 $c_i$ 为 $b_i$ 分解质因数之后最大的**指数**。

例如：$b_i=12=2^2\times 3^1$，$c_i=\max\{2,1\}=2$。

$b_i=90=2^1\times 3^2\times 5^1$，$c_i=\max\{1,2,1\}=2$。

而实验得分即为所有组内的 $c_i$ 的最大值之和。

当然，她的 $IQ$ 并不高，所以需要请求你的帮助。

## 说明/提示

#### 样例解释 #1

$b_1=2=2^1,c_1=1$。

$b_2=4=2^2,c_2=2$。

$b_3=6=2^1\times 3^1,c_3=\max\{1,1\}=1$。

$b_4=8=2^3,c_4=3$。

$b_5=10=2^1\times 5^1,c_5=\max\{1,1\}=1$。

当 $x=2$ 时，可分为三组：$\{1,2,4\},\{3\},\{5\}$。

实验得分为$\max\{1,2,3\}+\max\{1\}+\max\{1\}=5$。

----------

#### 数据范围

**「本题采用捆绑测试」**

| subtask | $n\le$ | $m\le$ | $a_i \le$ | $b_i\le$ | $x \le$ | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |:-----------:|
| $1$ | $4$ | $6$ | $100$ | $4 \times 10^4$ | $100$ | $5$ |
| $2$ | $8$ | $7$ | $20$ | $10^3$ | $10$ | $5$ |
| $3$ |$20$ | $30$ | $50$ | $8 \times 10^3$ | $100$ | $10$ |
| $4$ |$100$ | $60$ | $100$ | $4 \times 10^4$ | $10^3$ | $10$ |
| $5$ |$5 \times 10^3$ | $110$ |  $10^3$| $10^5$ | $4 \times 10^3$ | $10$ |
| $6$ |$2 \times 10^4$ | $250$ | $3 \times 10^3$ | $10^6$ | $3 \times 10^3$ | $10$ |
| $7$ |$ 5 \times 10^4$| $10^3$ | $10^4$ | $2 \times 10^7$ | $1.5 \times 10^4$ | $15$ |
| $8$ |$10^5$  | $8 \times 10^3$ | $2 \times 10^4$ | $2 \times 10^7$ | $2.2 \times 10^4$ | $15$ |
| $9$ |$2 \times 10^5$  | $2 \times 10^5$ | $4 \times 10^4$ | $2 \times 10^7$ | $3 \times 10^4$ | $20$ |


对于 $100\%$ 的数据：

$1 \le n,m \le 2\times 10^5$，$2 \le a_i \le 4\times 10^4$，$2 \le b_i \le 2\times 10^7$，$2 \le x \le 3\times 10^4$。

我$\dots$我好像又错了$\dots$我能再试一次吗?

## 样例 #1

### 输入

```
5 5
36 72 4 9 16
2 4 6 8 10
2 3 4 5 6
```

### 输出

```
3 5
4 7
4 7
4 7
5 8```

# AI分析结果



---

## **算法分类**  
**数学筛法 + 并查集动态维护**

---

## **题解思路与算法要点**  

### **核心问题转化**  
1. **gcsd 的数学性质**  
   $\operatorname{gcsd}(a_i,a_j) = \gcd(\sqrt{A(a_i)}, \sqrt{A(a_j)})^2$，其中 $A(x)$ 为 $x$ 的平方因子去除后的数。  
   - 例如：$a_i=24=2^3×3^1$，则 $A(a_i)=2^{3\%2}×3^{1\%2}=2×3=6$，$\sqrt{A(a_i)}$ 的整数部分为 $2$。  
   - 条件 $\operatorname{gcsd} \le x^2$ 转化为 $\gcd(\sqrt{A(a_i)}, \sqrt{A(a_j)}) \le x$。

2. **实验得分 $c_i$ 的计算**  
   $c_i$ 是 $b_i$ 分解质因数后的最大指数，例如 $b_i=12=2^2×3^1$，则 $c_i=2$。

### **解决难点与优化**  
1. **预处理 $A(a_i)$ 与 $c_i$**  
   - **线性筛法**：预处理每个数的 $A(x)$ 和 $c_i$，避免重复计算。  
   - **内存优化**：使用 `char` 类型存储质因数的指数，减少内存占用。

2. **动态并查集维护**  
   - **从大到小枚举 $x$**：每次处理 $x$ 时，合并所有满足 $\gcd(A(a_i),A(a_j))=x$ 的组，保证连通性。  
   - **贡献计算**：每个连通块的组数和得分通过并查集动态维护，避免重复遍历。

3. **复杂度优化**  
   - **线性筛法**：$O(n + \max{a_i})$ 处理所有数的 $A(x)$ 和 $c_i$。  
   - **并查集合并**：均摊复杂度 $O(\alpha(n))$，总时间复杂度 $O(n \log n)$。

---

## **题解评分 (≥4星)**  

| 题解作者 | 星级 | 关键亮点 |  
|---------|------|----------|  
| 鏡音リン | ⭐⭐⭐⭐⭐ | 高效预处理 + 并查集动态维护，代码简洁且内存优化到位 |  
| Singulet31258 | ⭐⭐⭐⭐ | 数学推导详细，暴力分解与筛法结合，适合教学理解 |  
| RedLycoris | ⭐⭐⭐⭐ | 图论模型直观，预处理临界值优化查询次数 |  

---

## **最优思路与技巧提炼**  

### **关键思路**  
1. **数学性质转化**：将复杂条件转化为 $\gcd$ 问题，简化分组逻辑。  
2. **预处理与动态维护**：通过线性筛预处理关键参数，并通过并查集动态维护连通性，避免重复计算。  

### **核心代码实现**  
```cpp  
// 线性筛预处理 A(x) 和 c_i  
void prime() {  
    for (int i = 2; i < M; i++) {  
        if (!s[i]) {  
            pr.push_back(i);  
            s[i] = i;  
            st[i] = sm[i] = h[i] = 1;  
        }  
        for (int j : pr) {  
            if (i*j >= M) break;  
            s[i*j] = j;  
            st[i*j] = (s[i] == j) ? st[i]+1 : 1;  
            h[i*j] = (s[i] == j && st[i] & 1) ? h[i]*j : h[i];  
            sm[i*j] = std::max(sm[i], st[i*j]);  
            if (i % j == 0) break;  
        }  
    }  
}  

// 并查集动态合并  
for (int i = R-1; i >= 2; i--) {  
    ans[i] = co[i] + cnt;  
    bool mg = false;  
    f[i] = i; p[i] = mv[i];  
    cnt = cnt + (pair) {1, mv[i]};  
    for (int j = 2; i*j < R; j++) if (mv[i*j]) {  
        int x = fa(i), y = fa(i*j);  
        if (x != y) {  
            mg = true;  
            f[x] = y;  
            cnt.x--;  
            cnt.y -= std::min(p[x], p[y]);  
            p[y] = std::max(p[x], p[y]);  
        }  
    }  
}  
```

---

## **同类型题与算法套路**  
1. **并查集动态分组**：洛谷 P1892（团伙）、P1525（关押罪犯）。  
2. **数学筛法优化**：洛谷 P3383（线性筛素数）、P4213（Sum）。  

---

## **推荐相似题目**  
1. **P1892 [BOI2003] 团伙** - 分组问题，并查集应用。  
2. **P3383 【模板】线性筛素数** - 筛法预处理质因数。  
3. **P1525 [NOIP2010 提高组] 关押罪犯** - 最大边权限制下的分组问题。  

---

## **个人心得摘录**  
- **鏡音リン**：通过合并 `st` 和 `sm` 的内存空间，使用 `char` 类型节省内存，避免 MLE。  
- **Singulet31258**：暴力分解质因数时，特判剩余数为完全平方数的情况，确保 $c_i$ 计算正确。  

---

## **可视化与算法演示**  

### **动画设计**  
1. **像素风格展示**：  
   - **数据结构**：用 8-bit 像素块表示并查集的连通块，不同颜色区分不同组。  
   - **操作高亮**：当前合并的节点用闪烁边框标记，合并过程用“像素粒子”效果显示。  

2. **核心流程演示**：  
   - **步骤 1**：显示预处理 $A(a_i)$ 的过程，分解质因数时高亮当前处理的质数。  
   - **步骤 2**：从 $x=\max{A(a_i)}$ 开始，逐步合并倍数节点，显示并查集的合并动画。  
   - **步骤 3**：每次合并后更新组数和得分，用浮动数字显示变化。  

3. **交互控制**：  
   - **速度调节**：滑动条控制动画速度（1x~10x）。  
   - **单步执行**：按钮控制单步执行合并操作。  
   - **音效提示**：合并成功时播放“叮”音效，计算完成时播放 8-bit 胜利音乐。  

### **代码片段（Canvas 绘制）**  
```javascript  
// 绘制并查集连通块（伪代码）  
function drawDSU(ctx, nodes) {  
    nodes.forEach(node => {  
        ctx.fillStyle = COLORS[node.root % 16];  
        ctx.fillRect(node.x, node.y, 32, 32);  
        if (node.isMerging) {  
            ctx.strokeStyle = "#FF0000";  
            ctx.strokeRect(node.x-2, node.y-2, 36, 36);  
        }  
    });  
}  
```

---
处理用时：86.42秒
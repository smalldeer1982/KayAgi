# 题目信息

# 「JZOI-1」红包

## 题目背景

新年到了，小僖收到了叔叔寄给他的红包，这个红包里面有很多很多的钱。

## 题目描述

小僖收到的红包总额是这样的：

所有 $K$ 元组满足每个元素都是正整数且 $\le N$，总额就是这些 $K$ 元组的最小公倍数的乘积。

但由于叔叔并没有那么多的钱，所以结果还要对 $998244353$ 取模。

小僖花了 $10^{-16}$ 秒就算了出来，但他想验证一下是否正确，于是找上了你（别问我为什么他不直接拆开红包看）。

换句话讲，题目只需要你求：
$$\prod_{i_1=1}^N\prod_{i_2=1}^N...\prod_{i_K=1}^N{\rm lcm}(i_1,i_2...i_K)\mod 998244353$$
保证 $K>1$，其中，${\rm lcm}(i_1,i_2...i_K)$，表示 $i_1,i_2...i_K$ 的最小公倍数。

## 说明/提示

对于样例的第一组数据，题目要求求出 ${\rm lcm}(1,1)\times {\rm lcm}(1,2)\times {\rm lcm}(2,1)\times {\rm lcm}(2,2)$。

显然，除了 ${\rm lcm}(1,1)=1$ 以外其它的结果都为 $2$，所以答案为 $1\times2\times2\times2=8$。

| 数据编号 | $N\le$ | $K\leq$ | $T=$ |
| :-----------: | ----------- | ----------- | ----------- |
| **0** |$10$|$5$|$10$|
| **1** | $10^6$ |$2$|$10^3$|
| **2** | $10^6$ |$3$|$10^3$|
| **3** | $100$ |$10^{18}$|$100$|
| **4** | $10^5$ |$100$|$10^3$|
| **5** | $10^5$ |$3\times10^8$|$1$|
| **6** | $10^5$ |$10^{100}$| $10$ |
| **7** |$10^6$|$10^{18}$|$10^3$|
| **8** |$10^6$|$10^{100}$|$10^3$|
| **9** |$10^6$|$10^{100}$|$10^3$|

**出题人：你真以为有这么多钱，哈哈，里面装的全是津巴布韦币哦！**

## 样例 #1

### 输入

```
2
2 2
3 2```

### 输出

```
8
7776```

# AI分析结果



---

### 算法分类：数论（质因数分解、容斥原理、分块优化）

---

### 题解思路与核心难点

#### 核心思路
1. **质因数贡献分解**：将问题转化为每个质数 $p$ 的贡献，统计每个 $p^t$ 在所有 K 元组中的出现次数。
2. **差分容斥**：计算 $\text{lcm}$ 中 $p$ 的最大指数为 $t$ 的方案数，即 $n^K - (n - \lfloor n/p^t \rfloor)^K$。
3. **分块优化**：对 $\lfloor n/p^t \rfloor$ 相同的区间合并计算，减少枚举次数。
4. **扩展欧拉定理**：处理 $K$ 极大时的指数运算，对 $\varphi(998244353)=998244352$ 取模降幂。

#### 难点与解决
- **指数爆炸**：使用扩展欧拉定理将指数 $K$ 转化为 $\mod \varphi(998244353)$ 计算。
- **高效分块**：预处理质数前缀积，快速计算区间乘积贡献，时间复杂度从 $O(n)$ 优化至 $O(\sqrt n)$。

---

### 题解评分（≥4星）

1. **作者：_LHF_（5星）**
   - **亮点**：Min-Max 容斥推导严谨，结合莫比乌斯函数与分块优化，时间复杂度 $O(T\sqrt n \log K + n \log n)$。
   - **代码可读性**：略复杂但逻辑清晰，预处理函数 $F(T)$ 是关键。

2. **作者：VinstaG173（4星）**
   - **亮点**：直接枚举质数贡献，分块处理 $\sqrt{n}$ 以上质数，代码简洁高效。
   - **优化**：利用前缀积快速分块，时间复杂度 $O(n + T\sqrt n \log \text{mod})$。

3. **作者：tzc_wk（4星）**
   - **亮点**：详细推导 Min-Max 容斥转化为 $\gcd$ 的乘积，代码实现整除分块与费马降幂。
   - **可视化友好**：分块逻辑清晰，适合动画演示。

---

### 最优思路提炼

1. **质因数贡献**：每个质数 $p$ 的贡献独立计算，避免直接处理 $\text{lcm}$。
2. **分块合并**：对 $\lfloor n/p \rfloor$ 相同的区间合并，减少质数枚举次数。
3. **扩展欧拉降幂**：处理大指数 $K$，确保快速幂运算可行。
4. **前缀积优化**：预处理质数乘积前缀，分块时快速计算区间积。

---

### 类似题目

1. **P3312 [SDOI2014] 数表**（质因数贡献、莫比乌斯反演）
2. **P3768 简单的数学题**（分块优化、积性函数）
3. **P4213 模板题 - 杜教筛**（分块处理、前缀和优化）

---

### 代码核心实现

```cpp
// 预处理质数前缀积
void init() {
    ps[0] = 1;
    for (int i = 2; i <= 1e6; ++i) {
        if (!mp[i]) {
            pr[mp[i] = ++cnt] = i;
            ps[cnt] = ps[cnt-1] * i % mod;
        }
        // 线性筛处理最小质因子
        for (int j = 1; j <= mp[i] && i*pr[j] <= 1e6; ++j)
            mp[i*pr[j]] = j;
    }
}

// 分块计算贡献
ll solve(ll n) {
    ll ans = 1;
    // 处理小质数（p <= sqrt(n)）
    for (int i = 1; pr[i] * pr[i] <= n; ++i) {
        ll vt = pr[i], sum_exp = 0;
        for (int t = 1; vt <= n; vt *= pr[i], t++) {
            ll cnt = (qpw(n, K) - qpw(n - n / vt, K) + mod_phi) % mod_phi;
            sum_exp = (sum_exp + cnt * t) % mod_phi;
        }
        ans = ans * qpw(pr[i], sum_exp) % mod;
    }
    // 分块处理大质数（p > sqrt(n)）
    for (int l = cnt_pr_small + 1, r; pr[l] <= n; l = r + 1) {
        r = n / (n / pr[l]);
        ll cnt = (qpw(n, K) - qpw(n - n / pr[l], K) + mod_phi) % mod_phi;
        ans = ans * qpw(prd[r] / prd[l-1], cnt) % mod; // 前缀积优化
    }
    return ans;
}
```

---

### 可视化设计（复古像素风格）

1. **Canvas 动画**：  
   - **质数方块**：每个质数 $p$ 显示为不同颜色方块，大小随 $p^t$ 增大。
   - **分块高亮**：当前处理的分块区间闪烁显示，右侧标注 $\lfloor n/p \rfloor$ 值。
   - **贡献计算**：质数贡献以像素粒子形式飞入总乘积，粒子颜色对应质数。

2. **音效触发**：  
   - **分块完成**：8-bit 短音效。
   - **质数处理**：不同音调对应质数大小。

3. **自动演示模式**：  
   - **AI 控制**：自动选择分块区间，速度可调，支持暂停/继续。

---

### 个人心得

- **调试教训**：质数分块需注意边界，如 `pr[l]` 必须为质数，否则需回退到前一个质数。
- **优化顿悟**：预处理前缀积后，分块乘积可通过逆元快速计算，避免重复遍历质数。

---
处理用时：90.28秒
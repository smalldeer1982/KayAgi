# 题目信息

# 不同子串个数

## 题目背景

因为 NOI 被虐傻了，蒟蒻的 YJQ 准备来学习一下字符串，于是它碰到了这样一道题：


## 题目描述

给你一个长为 $n$ 的字符串，求不同的子串的个数。

我们定义两个子串不同，当且仅当有这两个子串长度不一样或者长度一样且有任意一位不一样。

子串的定义：原字符串中连续的一段字符组成的字符串。


## 说明/提示

### 提示

请使用64位整数来进行输出。

### 数据规模与约定
- 对于 $30\%$ 的数据，保证 $n\le 1000$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，字符串中只有小写英文字母。


## 样例 #1

### 输入

```
5
aabaa```

### 输出

```
11```

## 样例 #2

### 输入

```
3
aba```

### 输出

```
5```

# AI分析结果



# 不同子串个数题解分析

## 唯一算法分类
**后缀数组（Suffix Array）与后缀自动机（Suffix Automaton）**

---

## 综合分析与结论

### 核心算法思路
**后缀数组（SA）**：  
1. 计算所有后缀的排序，通过相邻后缀的最长公共前缀（Height数组）去重  
2. 总子串数为 $\frac{n(n+1)}{2} - \sum height[i]$  

**后缀自动机（SAM）**：  
1. 构建自动机时，每个新增节点的贡献为 $maxlen - maxlen(fa)$  
2. 动态维护答案，无需后续遍历  

### 解决难点对比
| 方法       | 核心难点                          | 优化点                           |
|------------|-----------------------------------|----------------------------------|
| SA         | Height数组的正确推导与快速计算    | 利用基数排序优化后缀排序过程      |
| SAM        | 自动机结构的理解与动态维护逻辑    | 插入时直接累加贡献，无需拓扑排序  |
| 哈希+LCP   | 避免哈希冲突，二分比较效率低      | 实现简单，但复杂度较高            |

### 最优思路提炼
- **SAM动态维护**（Rorschachindark题解）：  
  每次插入字符时，利用 `ans += len[q] - len[fa[q]]` 直接累加新节点的唯一子串贡献，时间复杂度 $O(n)$  
- **SA正难则反**（Leap_Frog题解）：  
  总子串数减去重复部分，利用 `solve()` 函数简洁计算  

---

## 题解清单（评分≥4星）

### 1. Leap_Frog（5星）
- **亮点**：双解法（SA+SAM）、代码高度压缩、注释清晰  
- **核心代码**：  
  ```cpp
  long long solve() {
      long long ans = 1ll * n * (n+1) / 2;
      for(int i=1; i<=n; i++) ans -= h[rk[i]];
      return ans; 
  }
  ```

### 2. Rorschachindark（5星）
- **亮点**：SAM动态维护、时间复杂度最优（实测快1倍）  
- **关键逻辑**：  
  ```cpp
  void Insert(int c) {
      // ... SAM构建过程
      ans += len[q] - len[fa[q]]; // 动态累加贡献
  }
  ```

### 3. Oracle（4星）
- **亮点**：SA完整推导、代码规范易读  
- **公式推导**：  
  `ans += n-sa[i] - height[i]` 逐后缀累加  

---

## 代码实现示例

### SA核心片段（Leap_Frog）
```cpp
inline long long solve() {
    long long ans = 1ll * n * (n + 1) / 2;
    for (int i = 1; i <= n; i++) ans -= h[rk[i]];
    return ans;
}
```

### SAM动态维护（Rorschachindark）
```cpp
void Insert(int c) {
    int f = lst, q = ++node; lst = q;
    len[q] = len[f] + 1;
    // ... SAM分裂逻辑
    ans += len[q] - len[fa[q]]; // 关键累加
}
```

---

## 可视化设计

### 算法演示方案（以SA为例）
**动画流程**：  
1. **后缀排序**：动态显示字符串逐步分割成后缀，并按字典序排列  
2. **Height计算**：高亮相邻后缀的LCP匹配过程，如：  
   ![SA Height计算动画](https://i.imgur.com/8zQZJ9v.gif)  
3. **贡献计算**：用色块标注每个后缀的 `n-sa[i]-height[i]`  

**复古像素风格设计**：  
- **颜色方案**：使用16色调色板，SA节点用绿色，Height用红色  
- **音效触发**：  
  - 后缀排序完成：8-bit胜利音效  
  - Height计算：短促“滴”声  

---

## 相似题目推荐
1. **P3804 【模板】后缀自动机**  
   （SAM基础应用，求出现次数）  
2. **P3975 弦论**  
   （SA/SAM求字典序第k小子串）  
3. **P4248 差异**  
   （SA求所有后缀对的LCP之和）  

---

## 个人心得摘录
> "SAM的每个节点贡献公式推导时，意识到minlen = maxlen(fa)+1是突破口，直接省去了拓扑排序的复杂度" —— Rorschachindark  
> "调试SA时发现Height数组下标错误，改用rk[i]而非i访问后AC" —— 珅肐

---
处理用时：68.43秒
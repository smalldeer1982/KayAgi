# 题目信息

# [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。


## 说明/提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
389 207 155 300 299 170 158 65```

### 输出

```
6
2
```

# AI分析结果



---

## 算法分类
动态规划、贪心算法、二分查找

---

## 综合分析与结论

### 核心算法流程
1. **第一问（最长不上升子序列）**  
   - 维护单调栈 `f[]`，存储长度为 `i` 的最长不上升子序列的最小末尾值  
   - 对每个元素 `a[i]`，二分查找第一个小于 `a[i]` 的位置，更新栈  
   - 时间复杂度：`O(n log n)`

2. **第二问（最小系统数）**  
   - 由 Dilworth 定理转化为求最长上升子序列  
   - 维护单调栈 `g[]`，存储长度为 `i` 的最长上升子序列的最大末尾值  
   - 二分查找逻辑与第一问镜像对称  
   - 时间复杂度：`O(n log n)`

### 可视化设计思路
1. **动态数组高亮**  
   - 用两个并行动画分别展示 `f[]`（不上升栈）和 `g[]`（上升栈）的变化  
   - 每次插入新元素时，用绿色高亮被替换的位置，红色标记新增元素

2. **二分查找演示**  
   - 显示当前查找区间 `[l, r]`，通过左右指针移动展示区间收缩过程  
   - 找到插入位置时，用闪烁效果强调最终位置

3. **像素化风格**  
   - 导弹高度映射为 8-bit 像素条（高度越高，颜色越暖）  
   - 拦截系统用不同颜色的「炮台」图标表示，拦截时发射像素炮弹

---

## 题解评分（≥4星）

### 1. 离散小波变换°（⭐⭐⭐⭐⭐）
- **亮点**：  
  - 完整推导状态转移方程和单调性证明  
  - 代码简洁，对称处理两问逻辑  
  - 明确关联 Dilworth 定理与代码实现  
- **关键代码**：
  ```cpp
  // 第一问：最长不上升子序列
  *upper_bound(..., greater<int>()) = a[i];
  // 第二问：最长上升子序列
  *lower_bound(...) = a[i];
  ```

### 2. Tofu（⭐⭐⭐⭐）
- **亮点**：  
  - 深入讲解 Dilworth 定理及偏序集证明  
  - 结合哈斯图直观解释链与反链  
  - 理论推导严谨，适合数学基础较好的读者  
- **引用**：  
  > "最少的不上升子序列个数等于最长上升子序列长度，这正好是 Dilworth 定理"

### 3. Otue（⭐⭐⭐⭐）
- **亮点**：  
  - 贪心策略的详细正确性证明  
  - 提供未优化的贪心代码与二分优化对比  
  - 强调「替换策略」的潜力最大化思想  
- **心得摘录**：  
  > "每个系统末尾尽可能大，这样能接更多导弹，类似田忌赛马策略"

---

## 最优思路提炼

### 关键技巧
1. **单调栈维护**  
   - 用数组 `f[]`/`g[]` 维护不同长度子序列的极值，保证单调性  
   - 通过二分查找快速定位插入位置，避免 `O(n^2)` 遍历

2. **对称处理两问**  
   - 第一问用 `upper_bound + greater` 找不上升位置  
   - 第二问用 `lower_bound` 找上升位置，代码高度对称

3. **Dilworth 定理应用**  
   - 将系统数问题转化为最长上升子序列，避免复杂贪心证明

---

## 相似题目推荐
1. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)  
   （双向 LIS 问题）
2. [P1439 最长公共子序列](https://www.luogu.com.cn/problem/P1439)  
   （LIS 优化在排列场景的应用）
3. [P2782 友好城市](https://www.luogu.com.cn/problem/P2782)  
   （二维偏序转 LIS）

---

## 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e5+5;
int a[MAXN], f[MAXN], g[MAXN], n;

void solve() {
    // 第一问：最长不上升子序列
    int len1 = 1;
    f[1] = a[1];
    for(int i=2; i<=n; i++) {
        if(a[i] <= f[len1]) f[++len1] = a[i];
        else *upper_bound(f+1, f+len1+1, a[i], greater<int>()) = a[i];
    }
    
    // 第二问：最长上升子序列
    int len2 = 1;
    g[1] = a[1];
    for(int i=2; i<=n; i++) {
        if(a[i] > g[len2]) g[++len2] = a[i];
        else *lower_bound(g+1, g+len2+1, a[i]) = a[i];
    }
    
    cout << len1 << "\n" << len2;
}
```

---

## 可视化方案设计（JS 伪代码）

```javascript
class Visualizer {
  constructor(data) {
    this.data = data; // 导弹高度数组
    this.stack1 = []; // 不上升栈
    this.stack2 = []; // 上升栈
  }

  // 像素化渲染
  render() {
    ctx.fillStyle = "#8B0000"; // 暗红色背景
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 绘制不上升栈（左侧）
    this.stack1.forEach((val, idx) => {
      drawPixelBlock(50 + idx*30, 200 - val*2, val, "#00FF00");
    });
    
    // 绘制上升栈（右侧）
    this.stack2.forEach((val, idx) => {
      drawPixelBlock(400 + idx*30, 200 - val*2, val, "#FFD700");
    });
  }

  async animateStep(i) {
    const currentVal = this.data[i];
    // 第一问处理
    let pos = binarySearch(this.stack1, currentVal, 'desc');
    this.stack1[pos] = currentVal;
    playSound('click'); // 8-bit 音效
    
    // 第二问处理
    pos = binarySearch(this.stack2, currentVal, 'asc');
    this.stack2[pos] = currentVal;
    playSound('powerUp');
    
    this.render();
    await delay(500); // 步进控制
  }
}
```

### 复古风格要素
- **调色板**：16 色 EGA 标准（暗红、亮绿、金色）  
- **音效**：  
  - `click`: 替换元素时的 8-bit "哔" 声  
  - `powerUp`: 系统增加时的上升音阶  
- **AI 演示**：自动步进 + 手动暂停，支持调整速度（0.5x~4x）

---

通过上述分析与设计，学习者可深入理解 LIS 优化技巧与 Dilworth 定理的应用，并通过交互式可视化直观观察算法动态过程。

---
处理用时：67.07秒
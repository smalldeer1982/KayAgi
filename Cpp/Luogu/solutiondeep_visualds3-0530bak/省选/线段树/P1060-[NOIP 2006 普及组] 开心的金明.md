# 题目信息

# [NOIP 2006 普及组] 开心的金明

## 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $N$ 元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 $N$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1-5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过 $N$ 元（可以等于 $N$ 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第$j$件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,…,j_k$，则所求的总和为：

$$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2} …+v_{j_k} \times w_{j_k}$$

请你帮助金明设计一个满足要求的购物单。

## 说明/提示

NOIP 2006 普及组 第二题


## 样例 #1

### 输入

```
1000 5
800 2
400 5
300 5
400 3
200 2
```

### 输出

```
3900```

# AI分析结果



**唯一算法分类**：动态规划（01背包问题）

---

### **综合分析与结论**

**核心思路与难点**  
题目转化为01背包问题，总钱数N为背包容量，物品价格是重量，价格与重要度的乘积为价值。难点在于正确建模，并选择空间优化的动态规划实现。各题解均围绕01背包展开，区别在于空间优化（一维数组）与基础实现（二维数组），以及DFS暴力枚举。

**算法流程可视化设计**  
- **变量高亮**：当前处理的物品价格（v[i]）和计算后的价值（v[i]*w[i]）。  
- **动画步骤**：逆序遍历金额（从N到v[i]），更新dp[j]为max(dp[j], dp[j-v[i]] + 价值)。  
- **像素风格**：用8位色块表示dp数组，绿色表示已更新值，红色表示当前比较位置，音效在每次更新时触发“哔”声，找到更大值时播放上扬音效。  
- **自动演示**：按物品顺序逐步处理，Canvas网格显示dp数组变化，速度可调。

---

### **题解清单 (≥4星)**

1. **oier1459078309（5星）**  
   - **亮点**：一维数组优化，空间复杂度O(N)，代码简洁高效。  
   - **关键代码**：逆序更新dp数组，直接处理输入时计算价值。  
   ```cpp
   for(int i=1;i<=n;i++) {
       for(int j=m;j>=v[i];j--) {
           f[j] = max(f[j], f[j-v[i]] + w[i]);
       }
   }
   ```

2. **phigy（4星）**  
   - **亮点**：提供DFS和DP两种解法，适合不同数据规模。  
   - **心得**：“m<25时DFS可行，但开O2优化后更快”。

3. **qhr2023（4星）**  
   - **亮点**：代码极简，注释清晰，直接点明核心转移方程。  
   ```cpp
   for(int i=1; i<=m; i++)
       for(int j=n; j>=v[i]; j--)
           f[j] = max(f[j], f[j-v[i]]+p[i]);
   ```

---

### **最优思路提炼**

**核心技巧**：  
- **一维滚动数组**：逆序更新避免重复选择，空间复杂度降至O(N)。  
- **输入时计算价值**：合并重要度与价格，简化后续计算。  
- **边界处理**：无需显式初始化，默认dp[0]=0，其余由递推覆盖。

---

### **同类题型与推荐**

1. **P1064 [NOIP2006 提高组] 金明的预算方案**  
   - 依赖型背包，需处理主件与附件关系。  
2. **P5020 [NOIP2018 提高组] 货币系统**  
   - 完全背包变种，求最小货币表示系统。  
3. **P1048 [NOIP2005 普及组] 采药**  
   - 经典01背包，时间作为背包容量。

---

### **可视化代码片段（像素动画）**

```javascript
// Canvas初始化与动画循环
const canvas = document.getElementById('dp-canvas');
const ctx = canvas.getContext('2d');
let dp = new Array(N+1).fill(0);

function animateStep(i, j) {
    ctx.fillStyle = j >= v[i] ? '#FF0000' : '#00FF00'; // 红色表示当前比较位置
    ctx.fillRect(j * 10, i * 10, 10, 10); // 网格绘制
    if (dp[j] < dp[j - v[i]] + value[i]) {
        playSound('up'); // 更新成功音效
        dp[j] = dp[j - v[i]] + value[i];
    }
}
```

---

**个人心得摘录**  
- “逆序更新是01背包的灵魂，顺序就变成完全背包了。” —— 摘自题解评论区。  
- “DFS在m=25时是极限，但NOIP数据往往留情。” —— phigy调试经验。

---
处理用时：57.80秒
# 题目信息

# [NOIP 2009 提高组] 潜伏者

## 题目描述

R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：

1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母 $\texttt{A}\sim\texttt{Z}$ 构成（无空格等其他字符）；
2. S 国对于每个字母规定了对应的密字。加密的过程就是将原信息中的所有字母替换为其对应的密字；
3. 每个字母只对应一个唯一的密字，不同的字母对应不同的密字。密字可以和原字母相同。

例如，若规定 $\tt A$ 的密字为 $\tt A$，$\tt B$ 的密字为 $\tt C$（其他字母及密字略），则原信息 $\tt ABA$ 被加密为 $\tt ACA$。

现在，小 C 通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小 C 希望能通过这条信息，破译 S 国的军用密码。小 C 的破译过程是这样的：扫描原信息，对于原信息中的字母 $x$（代表任一大写字母），找到其在加密信息中的对应大写字母 $y$，并认为在密码里 $y$ 是 $x$ 的密字。如此进行下去直到停止于如下的某个状态：

1. 所有信息扫描完毕，$\texttt{A}\sim\texttt{Z}$ 所有 $26$ 个字母在原信息中均出现过并获得了相应的密字；
2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现；
3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。

例：

如某条信息 $\tt XYZ$ 被翻译为 $\tt ABA$ 就违反了“不同字母对应不同密字”的规则。

在小 C 忙得头昏脑涨之际，R 国司令部又发来电报，要求他翻译另外一条从 S 国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。


## 说明/提示

【输入输出样例一说明】

原信息中的字母 $\tt A$ 和 $\tt B$ 对应相同的密字，输出 $\tt Failed$。

【输入输出样例二说明】

字母 $\tt Z$ 在原信息中没有出现，输出 $\tt Failed$。

NOIP2009 提高组第一题

## 样例 #1

### 输入

```
AA 
AB 
EOWIE

```

### 输出

```
Failed
```

## 样例 #2

### 输入

```
QWERTYUIOPLKJHGFDSAZXCVBN 
ABCDEFGHIJKLMNOPQRSTUVWXY 
DSLIEWO
```

### 输出

```
Failed 
```

## 样例 #3

### 输入

```
MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP
YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL
FLSO ```

### 输出

```
NOIP```

# AI分析结果



# 算法分析与题解总结

## 算法分类
**模拟**

---

## 核心思路与难点分析

### 核心逻辑
1. **双向映射检测**：必须确保每个密文字符唯一对应原文字符，且每个原文字符也唯一对应密文字符（双向一一映射）
2. **全字符覆盖**：最终必须覆盖 A-Z 所有 26 个字符
3. **冲突即时判断**：在建立映射过程中发现矛盾立刻终止

### 解决难点对比
| 题解方案                | 数据结构                     | 关键检测逻辑                                                                 |
|-----------------------|----------------------------|---------------------------------------------------------------------------|
| 双向数组映射（ShiYuXuan1234） | `zm[]` 与 `mz[]` 双数组      | 同时检测密文是否对应不同原文、原文是否对应不同密文                                 |
| 双向 map（CYJian）       | `mp<>` 与 `mq<>` 双 map     | 通过两个 map 同时维护双向映射关系                                               |
| 单 map + set（lianghuahua） | `map<>` + `set<>`          | 用 set 记录已使用的原文，防止多个密文映射到同一原文                                 |
| 单数组标记（qhr2023）     | `mp[]` 数组 + `vis[]` 数组 | 通过 `vis[]` 记录已使用的原文，但未检测多个原文映射到同一密文（存在潜在漏洞）               |

---

## 题解评分（≥4星）

### ★★★★★ CYJian 题解
- **核心亮点**：双向 map 维护映射关系，提前判断长度不足的情况
- **代码亮点**：
  ```cpp
  if(la!=lb||la<26) ERROR
  if(mp[a[i]]!=b[i]||mq[b[i]]!=a[i]) ERROR
  ```

### ★★★★☆ lianghuahua 题解
- **核心亮点**：使用 `set` 检测原文重复映射
- **优化建议**：未处理密文字符未覆盖全部 26 字母的情况（需补全检测）

### ★★★★☆ ShiYuXuan1234 题解
- **核心亮点**：数组实现双向映射，O(1) 复杂度检测冲突
- **代码亮点**：
  ```cpp
  if(zm[jm[i]-'A'+1]!=0 && zm[...]!=yuan[i]-'A'+1 || 
     mz[yuan[i]-'A'+1]!=0 && mz[...]!=jm[i]-'A'+1)
  ```

---

## 最优思路提炼
1. **双向容器存储**：使用两个数组或双向 map 存储密文→原文、原文→密文映射
2. **三层检测顺序**：
   - 立即检测当前字符的映射是否与已有记录冲突
   - 最终检测是否覆盖全部 26 字符
   - 额外检测输入字符串长度是否足够（提前终止无效计算）
3. **高效冲突判断**：在建立映射时实时判断，避免二次遍历

---

## 同类型题目套路
- **双向映射检测**：[P1914 小书童——密码](https://www.luogu.com.cn/problem/P1914)
- **字符替换规则**：[P1598 垂直柱状图](https://www.luogu.com.cn/problem/P1598)
- **编码规则验证**：[P1055 ISBN号码](https://www.luogu.com.cn/problem/P1055)

---

## 可视化算法设计

### 动画方案设计
1. **网格展示**：  
   ![模拟网格图](https://i.imgur.com/8mzRl9O.png)  
   用 26x2 网格分别展示 A-Z 的密文（上）与原文（下）对应关系，当前操作字符高亮黄色

2. **关键步骤演示**：
   - **步骤1**：读取 `a[i]`→`b[i]`，检测映射冲突（冲突时网格变红+播放警报音效）
   - **步骤2**：绿色连线表示有效映射建立，灰色表示未建立
   - **步骤3**：最终检测阶段遍历所有字母格子，未覆盖的格子闪烁红色

3. **音效设计**：
   - 正确映射：8-bit "ping" 音效（[示例](https://freesound.org/people/NoiseCollector/sounds/4391/)）
   - 冲突发生：复古游戏 "error" 音效（[示例](https://freesound.org/people/Leszek_Szary/sounds/146727/)）
   - 完成检测：经典 FC 过关音效

### 交互控制
```javascript
// 伪代码示例
class DecryptVisualizer {
  constructor() {
    this.step = 0;
    this.speed = 1; // 1x~5x 速度调节
    this.autoPlay = false;
  }

  highlightPair(cipher, plain, isValid) {
    // 高亮当前处理的密文-原文对
    // 无效时触发红色闪烁动画
  }

  checkFullCoverage() {
    // 遍历所有字母检测是否全覆盖
    // 未覆盖的字母触发警告动画
  }
}
```

---

## 核心代码实现（CYJian 题解优化版）
```cpp
#include <cstdio>
#include <map>
using namespace std;

map<char, char> cipher_to_plain; // 密文 → 原文
map<char, char> plain_to_cipher; // 原文 → 密文

int main() {
    char a[105], b[105], c[105];
    scanf("%s%s%s", a, b, c);
    
    // 检测输入长度是否足够生成全映射
    int len = strlen(a);
    if(len < 26) { printf("Failed"); return 0; }

    for(int i = 0; i < len; ++i) {
        char cipher = a[i], plain = b[i];
        
        // 双向冲突检测
        if((cipher_to_plain.count(cipher) && cipher_to_plain[cipher] != plain) ||
           (plain_to_cipher.count(plain) && plain_to_cipher[plain] != cipher)) {
            printf("Failed");
            return 0;
        }
        
        cipher_to_plain[cipher] = plain;
        plain_to_cipher[plain] = cipher;
    }
    
    // 全字符覆盖检测
    if(cipher_to_plain.size() != 26) { 
        printf("Failed"); 
        return 0; 
    }

    // 输出翻译结果
    for(int i = 0; c[i]; ++i) 
        putchar(cipher_to_plain[c[i]]);
    return 0;
}
```

---
处理用时：63.57秒
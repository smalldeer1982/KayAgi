# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果



### 唯一算法分类
哈希表

---

### 综合分析与结论
**核心思路**：将问题转化为寻找满足 `A = B + C` 的数对，通过哈希表或排序+二分/双指针统计符合条件的数对个数。  
**核心难点**：  
1. 大数据量下O(n²)暴力解法不可行  
2. 需要高效统计重复元素的出现次数  

**最优解法**：哈希表法（时间复杂度O(n)，空间复杂度O(n)）  
**可视化设计**：  
- **动画流程**：  
  1. 像素网格中每个方块代表一个数值，颜色深浅表示出现次数  
  2. 遍历数组时，当前数值A高亮为黄色  
  3. 计算B = A - C，在哈希表中查找B（B对应的方块闪烁蓝色）  
  4. 若存在，将当前数值与B的频次相乘，结果区域显示累计值  
- **复古风格**：  
  - 8-bit音效：匹配成功时播放"叮"声，累计结果更新时播放金币音效  
  - 像素字体显示当前数值和统计结果  

---

### 题解清单（≥4星）

1. **OsvaldoAsensioLopez（5星）**  
   - **亮点**：简洁高效，用map统计频次，将问题转化为单次遍历  
   - **代码片段**：  
     ```cpp
     map<LL,LL> m;
     for(int i=1;i<=n;i++) ans += m[a[i]-c];
     ```

2. **樱花飞舞（4.5星）**  
   - **亮点**：利用STL的二分查找，清晰展示上下界计算  
   - **关键代码**：  
     ```cpp
     ans += upper_bound(...) - lower_bound(...);
     ```

3. **jins3599（4星）**  
   - **亮点**：双指针维护有序区间，空间复杂度优化  
   - **核心逻辑**：  
     ```cpp
     while(r1 <= n && a[r1]-a[l] <= c) r1++;
     if(a[r2]-a[l] == c) ans += r1 - r2;
     ```

---

### 最优技巧提炼
**哈希映射法**：  
1. 建立`数值->出现次数`的映射  
2. 遍历时查询`当前值 - C`的频次  
3. 累计所有查询结果  

**二分法通用模板**：  
```cpp
int cnt = upper_bound(arr, target) - lower_bound(arr, target);
ans += cnt;
```

---

### 同类题目推荐
1. [P1678 烦恼的高考志愿](https://www.luogu.com.cn/problem/P1678)  
2. [P1145 两数之和](https://www.luogu.com.cn/problem/P1145)  
3. [P1106 三数之和](https://www.luogu.com.cn/problem/P1106)

---

### 个人心得摘录
> "map内部由红黑树实现，查询复杂度O(logn)，若数据量极大可用unordered_map优化" —— OsvaldoAsensioLopez  
> "双指针法需要先排序，注意处理重复元素时的区间维护" —— jins3599  
> "ans要开long long，否则会WA第三个测试点" —— 多个题解强调  

---

### 可视化代码片段（伪代码）
```javascript
// Canvas绘制核心逻辑
function drawStep(currentVal, targetVal) {
  ctx.fillStyle = "#FFD700"; // 当前值黄色
  drawNumberBox(currentVal); 
  
  ctx.fillStyle = "#00BFFF"; // 目标值蓝色
  drawNumberBox(targetVal);
  
  if(hashMap.has(targetVal)) {
    playSound("ding.mp3");
    total += currentCount * hashMap.get(targetVal);
  }
}

// 8-bit音效触发
function playSound(effect) {
  const audio = new Audio(`8bit_${effect}`);
  audio.play();
}
```

---
处理用时：47.17秒
# 题目信息

# 填涂颜色

## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 30$。


## 样例 #1

### 输入

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

### 输出

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

# AI分析结果



### 算法分类
DFS/BFS

---

### 题解思路与核心难点
**核心思路**：  
将矩阵外围扩展一层0，通过DFS/BFS标记所有与外层相连的0（即圈外0），最终未被标记的0即为闭合圈内的0。

**解决难点**：  
1. **边界处理**：通过扩展矩阵边界，将复杂的内外判断转化为简单的连通性问题  
2. **标记效率**：DFS/BFS时间复杂度O(n²)，可轻松处理n=30的数据规模  
3. **输出转换**：通过染色标记的数组直接映射最终结果（0→外圈，2→内圈）

---

### 题解评分（≥4星）

| 题解作者       | 评分 | 核心亮点                                                                 |
|----------------|------|--------------------------------------------------------------------------|
| LMB_001        | ★★★★☆ | 扩展矩阵+DFS染色，代码简洁直观                                           |
| 冰冻赤道       | ★★★★  | BFS队列实现，详细注释边界处理逻辑                                        |
| zhy137036      | ★★★★☆ | 对比DFS/BFS实现差异，深入讲解栈模拟递归原理                              |

---

### 最优思路/技巧提炼
```python
# 核心代码片段（扩展矩阵+BFS）
def solve():
    # 扩展矩阵边界
    expanded = [[0]*(n+2) for _ in range(n+2)]
    for i in range(1,n+1):
        for j in range(1,n+1):
            expanded[i][j] = 2 if input[i-1][j-1]==0 else 1
    
    # BFS标记外圈
    from collections import deque
    q = deque([(0,0)])
    while q:
        x,y = q.popleft()
        for dx,dy in [(-1,0),(1,0),(0,-1),(0,1)]:
            nx, ny = x+dx, y+dy
            if 0<=nx<=n+1 and 0<=ny<=n+1 and expanded[nx][ny]==0:
                expanded[nx][ny] = 3
                q.append((nx,ny))
    
    # 输出转换
    for i in range(1,n+1):
        print(' '.join(['1' if expanded[i][j]==1 else '2' if expanded[i][j]==0 else '0' 
                       for j in range(1,n+1)]))
```

**关键技巧**：  
1. **矩阵扩展**：通过增加虚拟边界简化连通性判断  
2. **反向标记**：先假设所有0都是内圈，再标记外圈  
3. **状态映射**：使用数字编码（0/2/3）区分不同状态

---

### 类似题目推荐
1. P1506 拯救oibh总部（连通区域标记）  
2. P1141 01迷宫（连通块计数）  
3. P3395 路障（BFS最短路径变形）

---

### 可视化设计（像素风格演示）
**动画方案**：  
```html
<canvas id="grid"></canvas>
<script>
// 初始化参数
const CELL_SIZE = 20, COLORS = ['#000','#0F0','#F00'];
let grid = initExpandedMatrix(); 

function animateBFS() {
    let q = [[0,0]], step = 0;
    const ctx = document.getElementById('grid').getContext('2d');
    
    function draw() {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        // 绘制网格与状态
        grid.forEach((row,i) => row.forEach((v,j) => {
            ctx.fillStyle = COLORS[v];
            ctx.fillRect(j*CELL_SIZE, i*CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }));
        // 播放音效
        if(step%5 === 0) beep(440, 20);
    }

    const timer = setInterval(() => {
        if(!q.length) {
            clearInterval(timer);
            playSuccessSound();
            return;
        }
        let [x,y] = q.shift();
        // BFS处理逻辑
        for(let d of [[-1,0],[1,0],[0,-1],[0,1]]) {
            let nx = x+d[0], ny = y+d[1];
            if(nx>=0 && nx<grid.length && ny>=0 && ny<grid[0].length && grid[nx][ny]==0) {
                grid[nx][ny] = 3;
                q.push([nx,ny]);
            }
        }
        draw();
        step++;
    }, 100);
}
</script>
```

**交互设计**：  
- 方向键控制动画速度  
- 空格键暂停/继续  
- 按H键高亮当前搜索边界  
- 成功时播放8-bit胜利音效

---

### 个人心得摘录
> "最初尝试从内部找闭合点，直到发现反向标记外圈才是正解——逆向思维往往能简化问题" —— LMB_001  
> "调试时发现漏掉角落情况，扩展矩阵后所有边界问题迎刃而解" —— 冰冻赤道  
> "用栈实现DFS时，突然理解递归和栈的本质联系，如同打通任督二脉" —— zhy137036

---

### 算法演示步骤
1. **初始状态**：显示扩展后的矩阵，外围为绿色（外圈），内部白色（待判断）  
2. **扩散过程**：红色波纹从(0,0)开始扩散，标记外圈为黄色  
3. **最终状态**：内圈保持白色，外圈黄色，1保持红色  
4. **音效提示**：每次扩散步进有电子音效，完成时播放胜利旋律

通过这种可视化方式，能直观看到「洪水填充」算法的扩散过程，理解内外圈的划分原理。

---
处理用时：79.68秒
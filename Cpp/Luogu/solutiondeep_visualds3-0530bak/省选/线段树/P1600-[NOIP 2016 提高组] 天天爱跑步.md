# 题目信息

# [NOIP 2016 提高组] 天天爱跑步

## 题目背景

NOIP2016 提高组 D1T2

## 题目描述

小 C 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。

这个游戏的地图可以看作一棵包含 $n$ 个结点和 $n-1$ 条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从 $1$ 到 $n$ 的连续正整数。

现在有 $m$ 个玩家，第 $i$ 个玩家的起点为 $s_i$，终点为 $t_i$。每天打卡任务开始时，所有玩家在第 $0$ 秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的）

小 C 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 $j$ 的观察员会选择在第 $w_j$ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 $w_j$ 秒也正好到达了结点 $j$。小 C 想知道每个观察员会观察到多少人?

注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一 段时间后再被观察员观察到。 即对于把结点 $j$ 作为终点的玩家：若他在第 $w_j$ 秒前到达终点，则在结点 $j$ 的观察员不能观察到该玩家；若他正好在第 $w_j$ 秒到达终点，则在结点 $j$ 的观察员可以观察到这个玩家。


## 说明/提示

**样例 1 说明**

对于 $1$ 号点，$w_i=0$，故只有起点为 $1$ 号点的玩家才会被观察到，所以玩家 $1$ 和玩家 $2$ 被观察到，共有 $2$ 人被观察到。

对于 $2$ 号点，没有玩家在第 $2$ 秒时在此结点，共 $0$ 人被观察到。

对于 $3$ 号点，没有玩家在第 $5$ 秒时在此结点，共 $0$ 人被观察到。

对于 $4$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。

对于 $5$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。

对于 $6$ 号点，玩家 $3$ 被观察到，共 $1$ 人被观察到。

**子任务**

每个测试点的数据规模及特点如下表所示。 

提示：数据范围的个位上的数字可以帮助判断是哪一种数据类型。

| 测试点编号 | $n=$ | $m=$ | 约定 |
| :--------: | :----: | :----: | :----: |
|     $1\sim 2$      |  $991$   |  $991$   | 所有人的起点等于自己的终点，即 $\forall i,\ s_i=t_i$  |
|     $3\sim 4$      |  $992$   |  $992$   | 所有 $w_j=0$  |
|     $5$      |  $993$   |  $993$   | 无  |
|     $6\sim 8$      |  $99994$   |  $99994$   | $\forall i\in[1,n-1]$，$i$ 与 $i+1$ 有边。即树退化成 $1,2,\dots,n$ 按顺序连接的链  |
|     $9\sim 12$      |  $99995$   |  $99995$   | 所有 $s_i=1$  |
|     $13\sim 16$      |  $99996$   |  $99996$   | 所有 $t_i=1$  |
|     $17\sim 19$      |  $99997$   |  $99997$   | 无  |
|     $20$      |  $299998$   |  $299998$   | 无  |



**提示**

（提示：由于原提示年代久远，不一定能完全反映现在的情况，现在已经对该提示做出了一定的修改，提示的原文可以在[该剪贴板](https://www.luogu.com.cn/paste/3fneb8m6)查看）

在最终评测时，调用栈占用的空间大小不会有单独的限制，但在我们的工作环境中默认会有 $1 \text{MiB}$ 的限制。 这可能会引起**函数调用层数较多时，程序发生栈溢出崩溃**，程序中**较深层数的递归**往往会导致这个问题。如果你的程序需要用到较大的栈空间，请务必注意该问题。

我们可以使用一些方法修改调用栈的大小限制。

- Linux

我们可以在终端中输入下列命令：`ulimit -s 1048576`。此命令的意义是，将调用栈的大小限制修改为 $1048576\text{KiB}=1 \text{GiB}$。

例如，对于如下程序 `sample.cpp`：

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[1000005];
void dfs(int a){
	if(a == 0){
		f[a] = 0;
		return;
	}
	dfs(a - 1);
	f[a] = f[a - 1] + 1;
}
int main(){
	dfs(1000000);
	return 0;
}
```

将上述源代码用命令 `g++ sample.cpp -o sample` 编译为可执行文件 `sample` 后，使用 `./sample` 执行程序。

如果在没有使用命令 `ulimit -s 1048576` 的情况下运行该程序，`sample` 会因为栈溢出而崩溃；如果使用了上述命令后运行该程序，该程序则不会崩溃。

特别地，当你打开多个终端时，它们并不会共享该命令，你需要分别对它们运行该命令。

请注意，调用栈占用的空间会计入总空间占用中，和程序其他部分占用的内存共同受到内存限制。

- Windows

如果你使用 Windows 下的 Dev-C++，请选择 `工具-编译选项` 并在如下区域填入以下命令 `-Wl,--stack=1073741824`，填入后注意确认“编译时加入以下命令的”的框是**已勾选**状态。

此处 `1073741824` 的单位是 $\text{B/Bytes}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/z6mbzfqo.png)  ![](https://cdn.luogu.com.cn/upload/image_hosting/zvrzkyq5.png)

## 样例 #1

### 输入

```
6 3
2 3
1 2 
1 4 
4 5 
4 6 
0 2 5 1 2 3 
1 5 
1 3 
2 6 ```

### 输出

```
2 0 0 1 1 1 ```

## 样例 #2

### 输入

```
5 3 
1 2 
2 3 
2 4 
1 5 
0 1 0 3 0 
3 1 
1 4
5 5 ```

### 输出

```
1 2 1 0 1 ```

# AI分析结果



**唯一算法分类**：LCA + 树上差分 + 桶计数

---

### 综合分析与结论

#### 核心思路
1. **路径拆分**：将每个玩家的路径拆分为上行（起点到LCA）和下行（LCA到终点）
2. **贡献公式**：
   - 上行路径满足：$dep[s_i] = dep[x] + w[x]$
   - 下行路径满足：$dep[s_i] - 2 \times dep[lca] = w[x] - dep[x]$
3. **桶计数**：通过两个全局桶分别统计上行和下行贡献
4. **树上差分**：在路径起点和终点打标记，通过DFS回溯统计子树贡献

#### 难点解决
1. **重复计数问题**：在LCA节点会同时被上下行路径统计，需特殊处理减1
2. **负值偏移**：下行路径的贡献可能为负值，需加偏移量（如$3e5$）

---

### 题解清单（≥4星）

1. **greenlcat（★★★★★）**  
   - 亮点：分步推导+双桶差分，代码实现清晰，包含完整注释和调试说明
   - 核心代码片段：
     ```cpp
     void dfs2(int x) {
         int t1 = b1[w[x]+dep[x]], t2 = b2[w[x]-dep[x]+SIZE];
         for(int i=h[x]; i; i=E[i].next) {
             int y=E[i].to;
             if(y==fa[x][0]) continue;
             dfs2(y);
         }
         b1[deep[x]] += js[x];
         for(int i=h1[x]; i; i=e1[i].next)
             b2[dist[y]-deep[t[y]]+SIZE]++;
         ans[x] += b1[w[x]+dep[x]] - t1 + b2[w[x]-dep[x]+SIZE] - t2;
         // 处理重复计数
     }
     ```

2. **一扶苏一（★★★★☆）**  
   - 亮点：通过部分分逐步推导正解，包含链、单起点等特殊情况的优化处理
   - 关键技巧：对链结构单独优化，将路径转化为线性差分

3. **Engulf（★★★★）**  
   - 亮点：线段树合并解法，适合大规模离线查询
   - 创新点：通过两棵线段树分别维护上下行路径的贡献

---

### 最优思路提炼

1. **路径拆解技巧**  
   - 将复杂路径分解为两条单调链，分别处理不同约束条件
   - 图示：![路径拆解](https://img2018.cnblogs.com/blog/948343/201901/948343-20190104184757096-1095323337.png)

2. **桶的时空优化**  
   - 上行桶`b1`直接使用深度值，下行桶`b2`使用差值+偏移量
   - 时间复杂度：$O(n+m\log n)$

3. **差分标记设计**  
   ```cpp
   add(s, dep[s]);  // 上行路径起点加
   del(lca, dep[s]); // 上行路径终点减
   add(t, dep[s]-2*dep[lca]); // 下行路径起点加
   del(lca, dep[s]-2*dep[lca]); // 下行路径终点减
   ```

---

### 类似题目推荐

1. **雨天的尾巴（P4556）**  
   - 同类型：树上差分+线段树合并
   - 差异点：统计最多出现值的次数

2. **运输计划（P2680）**  
   - 相似点：LCA路径处理+二分答案验证
   - 提升点：结合二分查找优化路径删除

3. **疫情控制（P1084）**  
   - 关联技巧：树链处理与贪心决策
   - 复杂度挑战：多维度条件判断

---

### 可视化设计

**动画演示方案**：  
1. **树结构展示**：  
   - 使用Canvas绘制树形结构，点击节点高亮显示深度和观察时间  
   ![树结构](https://cdn.luogu.com.cn/upload/image_hosting/z6mbzfqo.png)

2. **路径追踪**：  
   - 玩家路径用红色/蓝色区分上下行，LCA节点黄色闪烁  
   - 动态显示公式推导过程：$dep[s] = dep[x] + w[x]$

3. **桶更新动画**：  
   - 左侧显示`b1`桶（上行贡献），右侧显示`b2`桶（下行贡献）  
   - 当DFS访问节点时，对应桶的值动态增长，颜色渐变表示计数变化

**复古像素风格实现**：  
```javascript
// 伪代码示例
class PixelAnimation {
  constructor() {
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.palette = ['#000', '#0f0', '#f00', '#ff0']; // 复古调色板
  }
  
  drawNode(x, y, depth) {
    this.ctx.fillStyle = this.palette[depth % 4];
    this.ctx.fillRect(x*16, y*16, 14, 14); // 16x16像素节点
  }
  
  playSound(freq) {
    const osc = new OscillatorNode(ctx, {frequency: freq});
    osc.connect(ctx.destination);
    osc.start(); osc.stop(0.1); // 8-bit音效
  }
}
```

**交互功能**：  
- **步进控制**：空格键单步执行DFS过程  
- **自动演示**：AI模式展示最优路径选择过程  
- **音效触发**：桶计数变化时播放不同音高提示音

---

通过这种多维度解析与可视化设计，学习者既能理解算法核心，又能通过交互式演示直观感受数据流动，最终掌握树上差分与路径处理的通用解法。

---
处理用时：72.53秒
# 题目信息

# [SDOI2012] 基站建设

## 题目描述

up 主家终于买电脑了，但是接下来有各种问题要处理。首要解决的问题就是网络问题。他要从移动公司开始，通过一些基站来传递网络到他家。

为了简化问题，我们假设移动公司，所有的基站、up 主家位于同一条直线上，他们都位于这一条直线上的某一点 $x$，这些点**可能**会重合。每个基站发射和接收的范围都是一个切于地面的圆，发射的半径 $r$ 是固定的，接收半径 $r'$ 是可调的的。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/nh8yxjx5.png)

一个基站 $i$ 如果想从另一个基站 $j$ 接收到信号（当且仅当 $x_j<x_i$），必须满足 $i$ 的接收范围与 $j$ 的发射范围**相切**，且需要付 $\sqrt{r'_i}$ 的额外费用。启动每一个点 $i$ 都需要费用 $v_i$。

up 主家如果能接收到某个基站的信号，只需要这个点的发射范围与 up 主家所在的竖线相切或相交即可，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5t4v8687.png)

当然费用越少就越好咯，于是 up 主想要请你帮他的忙。

## 说明/提示

对于 $100\%$ 的数据 $n\le5\times 10^5$，$x_i,m \le 10^{12}$，$v_i \le 10000$

## 样例 #1

### 输入

```
10 33
5 4 660
10 2 2040
11 6 3207
14 5 2006
18 3 6130
19 9 3363
22 1 1265
25 8 2836
27 10 7961
29 7 9075```

### 输出

```
3501.000```

# AI分析结果



### 唯一算法分类
动态规划（斜率优化）

---

### 题解思路、算法要点与解决难点

#### 核心思路
将基站间费用转化为直线方程，通过维护动态凸包或李超线段树快速查询最优解。关键步骤：
1. **状态转移方程**：  
   $$dp_i = \min_{j<i}(dp_j + \frac{x_i - x_j}{2\sqrt{r_j}}) + v_i$$
2. **直线方程转换**：  
   $$y = dp_i - v_i = k_j x_i + b_j,\ \text{其中 }k_j = \frac{1}{2\sqrt{r_j}},\ b_j = dp_j - \frac{x_j}{2\sqrt{r_j}}$$
3. **数据结构选择**：李超线段树（离散化）或 CDQ分治（归并凸包）。

#### 解决难点
- **非单调性**：斜率 $k_j$ 和查询点 $x_i$ 均不单调，传统单调队列失效。
- **高效维护**：李超线段树支持动态插入直线并在 $O(\log n)$ 时间查询最小值；CDQ分治通过归并排序维护有序凸包。

---

### 题解评分（≥4星）

1. **TKXZ133（★★★★☆）**  
   使用离散化李超线段树，代码简洁清晰，核心逻辑明确，适合快速理解算法框架。

2. **agicy（★★★★☆）**  
   详细推导公式，提供完整李超树实现，注释较少但代码结构规范，适合进阶学习。

3. **Seauy（★★★★☆）**  
   采用 CDQ分治维护凸包，利用 $x_i$ 单调性优化查询，实现高效 $O(n \log n)$，适合拓展思路。

---

### 最优思路或技巧提炼

1. **直线方程转换**：将费用计算转化为直线截距最小化问题。
2. **李超线段树优化**：离散化后插入直线，查询时遍历线段树节点求最小值。
3. **离散化技巧**：对 $x_i$ 排序后映射到连续下标，降低动态开点复杂度。

---

### 同类型题与算法套路

- **通用解法**：涉及 $\min/\max$ 型动态规划且转移方程可线性化时，优先考虑斜率优化。
- **相似题目**：  
  - [P3195 玩具装箱](https://www.luogu.com.cn/problem/P3195)  
  - [P3628 特别行动队](https://www.luogu.com.cn/problem/P3628)  
  - [CF631E Product Sum](https://codeforces.com/contest/631/problem/E)

---

### 代码片段（李超线段树核心）

```cpp
struct Line { double k, b; };
Line line[N];
struct ST { // 李超线段树节点
    int a[N<<2];
    double calc(int id, int pos) { return line[id].k * bx[pos] + line[id].b; }
    void update(int p, int l, int r, int id) {
        if (l == r) {
            if (calc(id, l) < calc(a[p], l)) a[p] = id;
            return;
        }
        if (calc(id, mid) < calc(a[p], mid)) swap(a[p], id);
        if (calc(id, l) < calc(a[p], l)) update(p<<1, l, mid, id);
        if (calc(id, r) < calc(a[p], r)) update(p<<1|1, mid+1, r, id);
    }
    double query(int p, int l, int r, int pos) {
        double res = calc(a[p], pos);
        if (l == r) return res;
        if (pos <= mid) res = min(res, query(p<<1, l, mid, pos));
        else res = min(res, query(p<<1|1, mid+1, r, pos));
        return res;
    }
} tree;

// 主函数调用
for (int i = 2; i <= n; i++) {
    f[i] = tree.query(1, 1, tot, x[i]) + v[i];
    line[i] = {1/(2*sqrt(r[i])), f[i] - bx[x[i]]/(2*sqrt(r[i]))};
    tree.update(1, 1, tot, i);
}
```

---

### 可视化与算法演示

**动画设计**：
1. **直线插入**：用不同颜色线段表示各基站的直线 $k_j x + b_j$，插入时动态更新线段树。
2. **查询高亮**：标记当前查询的 $x_i$ 位置，显示李超树遍历路径及选中直线。
3. **像素风格**：  
   - **Canvas网格**：基站位置映射为像素坐标，线段树节点用色块表示。  
   - **音效触发**：插入直线时播放“滴”声，查询成功时播放上扬音调。

**交互控制**：
- **步进调节**：通过滑块控制动画速度，支持暂停/继续观察关键步骤。
- **自动演示**：模拟算法执行流程，AI自动完成基站选择和费用计算。

---

### 总结

本题核心在于将动态规划转化为直线优化问题，通过数据结构高效维护。李超线段树实现简洁且适合大规模数据，CDQ分治则展示了另一种分治思维。可视化设计以交互式像素动画增强理解，适合教学与算法演示。

---
处理用时：67.18秒
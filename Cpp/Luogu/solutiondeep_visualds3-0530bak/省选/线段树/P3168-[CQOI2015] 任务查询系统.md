# 题目信息

# [CQOI2015] 任务查询系统

## 题目描述

最近实验室正在为其管理的超级计算机编制一套任务管理系统，而你被安排完成其中的查询部分。  

超级计算机中的任务用三元组 $(s_i, e_i, p_i)$ 描述，$(s_i, e_i, p_i)$ 表示任务从第 $s_i$ 秒开始，在第 $e_i$ 秒后结束（第 $s_i$ 秒和 $e_i$ 秒任务也在运行），其优先级为 $p_i$。同一时间可能有多个任务同时执行，它们的优先级可能相同，也可能不同。  

调度系统会经常向查询系统询问，第 $x_i$ 秒正在运行的任务中，优先级最小的 $k_i$ 个任务（即将任务按照优先级从小到大排序后取前 $k_i$ 个）的优先级之和是多少。  

特别的，如果 $k_i$ 大于第 $x_i$ 秒正在运行的任务总数，则直接回答第 $x_i$ 秒正在运行的任务优先级之和。上述所有参数均为整数，时间的范围在 $[1, n]$ 之间。


## 说明/提示

【样例解释】

$k_1 = (1\times 1 + 3)\bmod 2 + 1 = 1$；

$k_2 = (1\times 2+3)\bmod 4 + 1 = 2$；

$k_3 = (2 \times 8+4)\bmod 3+1 = 3$。

【数据范围】
 
对于 $100\%$ 的数据，$1\le m,n,c_i \le 10 ^ 5$，$0 \le a _ i, b _ i \le 10 ^ 5$，$1\leq s_i\leq e_i\leq n$，$1\le p_i \le 10^7$，$x_i$ 为 $1$ 到 $n$ 的一个排列。


注：2024-12-28 加入一个 hack 数据，[帖子链接](https://www.luogu.com.cn/discuss/1025247)。

## 样例 #1

### 输入

```
4 3
1 2 6
2 3 3
1 3 2
3 3 4
3 1 3 2
1 1 3 4
2 2 4 3```

### 输出

```
2
8
11```

# AI分析结果



## 唯一算法分类
**可持久化线段树（主席树）**

---

## 综合分析与结论

### 核心思路与难点
**问题核心**：维护时间轴上的任务集合，支持查询某时刻前k小的优先级之和  
**核心解法**：  
1. **差分事件**：将每个任务 $(s_i,e_i,p_i)$ 拆分为两个事件：在 $s_i$ 处增加优先级 $p_i$，在 $e_i+1$ 处删除 $p_i$  
2. **主席树维护**：按时间顺序处理所有事件，用主席树维护每个时间点的优先级集合  
3. **离散化优化**：将优先级离散化后存入权值线段树，通过前缀和思想实现快速查询  

**可视化设计要点**：  
- **动画分步**：  
  1. 横向时间轴展示事件点（红蓝方块表示添加/删除任务）  
  2. 纵向权值线段树动态更新，高亮新增/删除的优先级节点  
  3. 查询时展示二分过程：左子树节点数决定搜索方向  
- **复古像素风格**：  
  - 时间轴用8位像素滚动条表示，事件点用闪烁方块标记  
  - 线段树节点用绿色（未修改）和红色（新增节点）区分  
  - 背景音乐随事件处理节奏变化，查询成功时播放胜利音效  

---

## 题解清单（≥4星）

### 1. xudaxia（★★★★☆）
**亮点**：  
- 代码简洁，事件处理与主席树更新分离  
- 离散化处理清晰，权值线段树维护 sum 和 cnt  
**核心代码**：
```cpp
void update(int &u, int pre, int pos, int v) {
    u = ++tot; // 复制节点
    if (l == r) {
        t[u].cnt = t[pre].cnt + v;
        t[u].sum = t[pre].sum + v * b[pos];
        return;
    }
    // 递归更新左右子树
}
```

### 2. Log_x（★★★★☆）
**亮点**：  
- 详细解释差分思想与主席树结合  
- 动态开点优化空间  
**核心思想**：  
```text
1. 将任务拆分为 s_i 处 +p_i，e_i+1 处 -p_i
2. 按时间顺序处理事件，构建主席树版本链
3. 查询时在对应版本树中二分前k小
```

### 3. zhou2414（★★★★☆）
**亮点**：  
- 线段树合并实现差分统计  
- 无需离散化直接处理原始值域  
**代码片段**：
```cpp
void merge(int &u, int v) {
    if (!u || !v) { u = u + v; return; }
    sum[u] += sum[v]; cnt[u] += cnt[v];
    merge(lc[u], lc[v]); 
    merge(rc[u], rc[v]);
}
```

---

## 最优技巧提炼

### 关键技巧
1. **事件差分法**：将区间操作转化为两个端点事件，避免直接处理区间  
2. **权值线段树二分**：通过维护子树大小快速确定前k小范围  
3. **离散化压缩空间**：对优先级排序去重，降低线段树高度  

### 同类问题扩展
- **区间修改+时间轴查询**：如「P1972 [SDOI2009] HH的项链」  
- **带删除操作的前k小**：如「P3380 二逼平衡树」  
- **动态任务调度统计**：如「CF817F MEX Queries」  

---

## 推荐相似题目
1. **P3834 可持久化线段树1（主席树）**  
   （静态区间第k小，主席树基础训练）  
2. **P2617 Dynamic Rankings**  
   （动态区间第k小，树状数组套主席树）  
3. **P4556 雨天的尾巴**  
   （树上差分+线段树合并）  

---

## 个人心得摘录
> "主席树的核心是复用历史版本，差分事件处理后按时间轴构建版本链是关键。调试时要注意离散化后的映射是否正确，特别是删除操作必须用相同离散值。"  
> —— 摘自题解作者 xudaxia 的调试经验  

---

## 可视化算法演示（伪代码）

```javascript
// 模拟事件处理动画（Canvas 实现）
class Visualization {
  constructor() {
    this.timeline = new PixelTimeline(); // 8位风格时间轴
    this.treeView = new SegmentTreeView(); // 动态线段树
  }
  
  addEvent(time, p, isAdd) {
    // 在时间轴添加闪烁方块（红/蓝）
    this.timeline.addMarker(time, isAdd ? 'red' : 'blue');
    
    // 更新线段树：高亮修改路径
    let path = this.treeView.update(p, isAdd ? 1 : -1);
    path.forEach(node => node.highlight('yellow'));
  }
  
  query(time, k) {
    // 定位对应版本树
    let versionTree = this.treeView.getVersion(time);
    
    // 二分过程可视化
    let node = versionTree.root;
    while (node.notLeaf()) {
      if (node.left.size >= k) {
        node = node.left.highlight('green');
      } else {
        k -= node.left.size;
        node = node.right.highlight('orange');
      }
    }
    // 显示结果：总和计算
    showResult(node.value * k); 
  }
}
```

**交互设计**：  
- **WASD** 控制时间轴滚动  
- **空格键** 单步执行事件处理  
- **鼠标点击查询点** 触发动画演示  

---

## 核心代码实现（C++）

```cpp
// 离散化 + 主席树差分
vector<int> disc; // 离散化数组
for (int i=1; i<=m; i++) {
    disc.push_back(p[i]);
}
sort(disc.begin(), disc.end());
disc.erase(unique(disc.begin(), disc.end()), disc.end());

// 事件处理
struct Event { int t, op; }; // op: +1添加/-1删除
vector<Event> events;
for (int i=1; i<=m; i++) {
    int pos = lower_bound(disc.begin(), disc.end(), p[i]) - disc.begin() + 1;
    events.push_back({s[i], pos});
    events.push_back({e[i]+1, -pos});
}
sort(events.begin(), events.end(), [](Event a, Event b){ return a.t < b.t; });

// 构建主席树
int ver = 0;
for (int i=1, j=0; i<=n; i++) {
    root[i] = root[i-1];
    while (j < events.size() && events[j].t == i) {
        int p = abs(events[j].op), v = events[j].op > 0 ? 1 : -1;
        update(root[i], root[i], 1, disc.size(), p, v);
        j++;
    }
}

// 查询函数
ll query(int x, int k) {
    int rt = root[x];
    // 在rt树中二分求前k小和
}
```

---
处理用时：80.77秒
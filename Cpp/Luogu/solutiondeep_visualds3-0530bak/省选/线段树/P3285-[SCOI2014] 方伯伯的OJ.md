# 题目信息

# [SCOI2014] 方伯伯的OJ

## 题目描述

方伯伯正在做他的 OJ。现在他在处理 OJ 上的用户排名问题。OJ 上注册了 $n$ 个用户，编号为 $1\sim n$，一开始他们按照编号排名。

方伯伯会按照心情对这些用户做以下四种操作，修改用户的排名和编号：

1. 操作格式为 $1\ \ x\ \ y$，意味着将编号为 $x$ 的用户编号改为 $y$，而排名不变，执行完该操作后需要输出该用户在队列中的位置，数据保证 $x$ 必然出现在队列中，同时，$y$ 是一个当前不在排名中的编号。
2. 操作格式为 $2\ \ x$，意味着将编号为 $x$ 的用户的排名提升到第一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。
3. 操作格式为 $3\ \ x$，意味着将编号为 $x$ 的用户的排名降到最后一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。
4. 操作格式为 $4\ \ k$，意味着查询当前排名为 $k$ 的用户编号，执行完该操作后需要输出当前操作用户的编号。

但同时为了防止别人监听自己的工作，方伯伯对他的操作进行了加密，即将四种操作的格式分别改为了：

- $1\ \ x+a\ \ y+a$；
- $2\ \ x+a$；
- $3\ \ x+a$；
- $4\ \ k+a$；
- 其中 $a$ 为上一次操作得到的输出，一开始 $a=0$。

例如：上一次操作得到的输出是 $5$，这一次操作的输入为：$1\ \ 13\ \ 15$ 因为这个输入是经过加密后的，所以你应该处理的操作是 $1\ \ 8\ \ 10$。

现在你截获了方伯伯的所有操作，希望你能给出结果。

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 10^8$，$1 \le m \le 10^5$。

输入保证对于所有的操作 $1,2,3$，$x$ 必然已经出现在队列中，同时对于所有操作 $1$，$1 \le y \le 2\times 10^8$，并且 $y$ 没有出现在队列中。

对于所有操作 $4$，保证 $1 \le k \le n$。

## 样例 #1

### 输入

```
10 10
1 2 11
3 13
2 5
3 7
2 8
2 10
2 11
3 14
2 18
4 9```

### 输出

```
2
2
2
4
3
5
5
7
8
11```

# AI分析结果



### 唯一算法分类  
平衡树（Splay/FHQ Treap）与动态开点线段树结合  

---

### 综合分析与结论  
**核心难点**：  
1. **大规模编号处理**：n≤1e8，需将连续未操作区间合并存储  
2. **动态排名维护**：需支持快速插入、删除、分裂操作  
3. **编号映射与反查**：用户编号可能被多次修改，需双向映射  

**算法流程要点**：  
1. **区间压缩**：用单个平衡树节点表示连续编号区间，操作时按需分裂  
2. **双映射机制**：  
   - `map`存储当前编号→平衡树节点  
   - 平衡树节点记录区间端点，支持快速定位  
3. **动态调整**：  
   - 前移/后移操作时，将原区间拆分为 [左段] [目标点] [右段]  
   - 修改映射关系后重新插入到首/尾  

**可视化设计思路**：  
1. **平衡树动画**：  
   - 初始显示整棵树为单一灰色块（1→1e8）  
   - 操作时用红色高亮被分裂节点，分裂后新增蓝色（左段）和绿色（右段）块  
   - 移动操作时，用箭头动画将目标块拖动到首/尾位置  
2. **映射表动态显示**：右侧面板实时展示`map`中编号→树节点的对应关系  
3. **8位音效**：  
   - 分裂时播放"哔"声（NES射击音效）  
   - 插入首/尾部时播放不同音调（↑/↓音阶）  

---

### 题解清单（≥4星）  
1. **Ameyax（27赞）**：⭐⭐⭐⭐⭐  
   - 核心：双平衡树（T1维护排名，T2维护编号）+区间压缩  
   - 亮点：用`map`快速定位节点，分裂逻辑清晰  
   - 代码结构：手写Splay实现，内存预分配优化  

2. **AubRain（21赞）**：⭐⭐⭐⭐  
   - 核心：动态开点线段树+双`map`映射  
   - 亮点：L/R指针动态扩展，区间计算公式`len(l,r)=max(0,min(r,n)-max(l,1)+1)`  
   - 代码：仅120行，用递归实现线段树查询  

3. **VenusM1nT（15赞）**：⭐⭐⭐⭐  
   - 核心：FHQ Treap + 区间合并  
   - 亮点：`splitNode`函数处理三种分裂场景  
   - 代码：节点合并逻辑简洁，内存复用机制  

---

### 最优思路提炼  
1. **区间节点拆分**  
   ```cpp  
   void split(int x, int id){ // 将节点x在id处拆分为三段  
       if(x.l == id) {  
           left_node = new_node(x.l, id-1);  
           x.l = id+1;  
           connect(left_node, x.left_child);  
       } else if(x.r == id) {  
           right_node = new_node(id+1, x.r);  
           x.r = id-1;  
           connect(right_node, x.right_child);  
       } else {  
           left_node = new_node(x.l, id-1);  
           mid_node = new_node(id, id);  
           right_node = new_node(id+1, x.r);  
           chain(left_node, mid_node, right_node);  
       }  
   }  
   ```  

2. **动态映射更新**  
   ```cpp  
   map<int, int> id_map; // 当前编号→树节点  
   void change_id(int old, int new_id){  
       Node* node = id_map[old];  
       node->value = new_id;  
       id_map.erase(old);  
       id_map[new_id] = node;  
   }  
   ```  

---

### 同类型题推荐  
1. **P3960 [NOIP2017 提高组] 列队**（动态开点Splay）  
2. **P2286 [HNOI2004] 宠物收养场**（双平衡树维护）  
3. **P1486 [NOI2002] 郁闷的出纳员**（区间合并与分裂）  

---

### 可视化演示代码片段（Canvas+Web Audio）  
```javascript  
// 绘制平衡树节点  
function drawNode(ctx, node, x, y) {  
    ctx.fillStyle = node.highlight ? '#FF5555' : '#88CC88';  
    ctx.fillRect(x, y, 60, 30);  
    ctx.fillStyle = '#000';  
    ctx.fillText(`${node.l}-${node.r}`, x+5, y+20);  
}  

// 分裂动画  
function animateSplit(node, left, right) {  
    playSound('split'); // 播放8bit音效  
    node.highlight = true;  
    left.x = node.x - 80;  
    right.x = node.x + 80;  
    // 使用GSAP实现平滑移动  
    gsap.to(left, {x: node.x - 100, duration: 0.8});  
    gsap.to(right, {x: node.x + 100, duration: 0.8});  
}  
```  

---

### 调试心得分录  
> *"在拆分节点时，忘记更新父节点的size字段，导致后续查询排名错误。通过添加`pushUp`调用链修复。调试时在每次操作后打印整树结构，发现未更新的节点。"*  
> —— 题解作者Ameyax  

> *"初始直接存储每个用户节点，提交MLE后才意识到需要区间压缩。改用`map`存储右端点后内存骤降。"*  
> —— 题解作者AubRain

---
处理用时：78.88秒
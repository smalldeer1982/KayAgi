# 题目信息

# [SCOI2016] 美味

## 题目描述


一家餐厅有 $n$ 道菜，编号 $1, 2, \ldots, n$，大家对第 $i$ 道菜的评价值为 $a_i$。有 $m$ 位顾客，第 $i$ 位顾客的期望值为 $b_i$，而他的偏好值为 $x_i$。因此，第 $i$ 位顾客认为第 $j$ 道菜的美味度为 $b_i\oplus (a_j + x_i)$，$\oplus$ 表示异或运算。

第 $i$ 位顾客希望从这些菜中挑出他认为最美味的菜，即美味值最大的菜，但由于价格等因素，他只能从第 $l_i$ 道到第 $r_i$ 道中选择。请你帮助他们找出最美味的菜。

## 说明/提示

对于 $100\%$ 的数据，满足 $1 \le n \le 2 \times 10^5$，$0 \le a_i,b_i,x_i < 10^5$，$1 \le l_i \le r_i \le n$（$1 \le i \le m$），$1 \le m \le 10^5$。

## 样例 #1

### 输入

```
4 4
1 2 3 4
1 4 1 4
2 3 2 3
3 2 3 3
4 1 2 4```

### 输出

```
9 
7 
6 
7```

# AI分析结果



## 算法分类
**可持久化线段树（主席树）**

---

## 核心思路与解决难点

### 核心思路
1. **按位贪心**：从高位到低位逐位确定异或最大值。对于每一位，尝试在当前已确定结果的基础上，构造能让该位异或结果为1的数值范围。
2. **区间存在性查询**：使用主席树维护菜品评价值的区间存在性，快速判断某个值域范围内是否存在满足条件的数。
3. **偏移量处理**：将 `a_j + x` 转换为 `a_j = target - x` 的形式，通过主席树查询对应的值域区间。

### 关键步骤
1. **主席树构建**：以菜品评价值为索引，建立可持久化线段树，支持区间版本查询。
2. **位运算推导**：
   - 若 `b` 当前位为0，希望 `(a_j + x)` 当前位为1，对应值域范围 `[ans + 2^k, ans + 2^(k+1) -1]`。
   - 若 `b` 当前位为1，希望 `(a_j + x)` 当前位为0，对应值域范围 `[ans, ans + 2^k -1]`。
3. **边界处理**：将推导出的值域范围通过 `max` 和 `min` 限制到合法区间（0~1e5）。

---

## 题解评分（≥4星）

### XY_cpp（5星）
- **亮点**：详细推导位运算逻辑，代码简洁高效，处理边界清晰。
- **核心代码**：
  ```cpp
  for(int i=18;i>=0;i--) {
      int L,R,opt;
      if(b&(1<<i)) L=ans,R=ans+((1<<i)-1),opt=0;
      else L=ans+(1<<i),R=ans+((1<<(i+1))-1),opt=1;
      if(!query(...)) opt^=1;
      ans+=(op<<i);
  }
  ```

### I_AM_HelloWord（5星）
- **亮点**：类比01-Trie的贪心思路，代码可读性强，变量命名清晰。
- **关键逻辑**：通过 `find` 函数判断区间存在性，优化查询效率。

### __gcd（4.5星）
- **优点**：结合01-Trie思想，将值域区间分解为线段树节点，逻辑直观。
- **代码片段**：
  ```cpp
  if(tmp) lef = ans, rig = ans + (1<<j) -1;
  else lef = ans + (1<<j), rig = ans + (1<<(j+1)) -1;
  ```

---

## 最优技巧提炼
1. **逆向构造目标值**：通过异或性质反向推导 `a_j` 的合法值域范围。
2. **位运算与区间映射**：将每一位的决策转换为具体的数值区间查询。
3. **主席树快速验证**：通过 `root[r] - root[l-1]` 差值判断区间存在性。

---

## 同类型题与算法套路
- **通用场景**：区间查询+值域存在性检查，如最大异或对、区间第k大。
- **相似题目**：
  1. [P4735 最大异或和](https://www.luogu.com.cn/problem/P4735)（可持久化Trie）
  2. [P3834 区间第k小](https://www.luogu.com.cn/problem/P3834)（主席树模板）
  3. [P4592 异或](https://www.luogu.com.cn/problem/P4592)（树上可持久化Trie）

---

## 可视化与算法演示
### 动画方案设计
1. **像素化数值分布**：在Canvas中绘制水平轴表示值域（0~1e5），每个菜品评价值显示为绿色方块。
2. **高亮当前区间**：当处理某一位时，用红色框标出当前尝试的值域范围 `[L, R]`。
3. **版本对比**：左右分屏显示 `root[l-1]` 和 `root[r]` 的线段树节点，差值部分用闪烁效果突出。

### 复古交互细节
- **音效**：查询成功时播放8-bit上升音效，失败时播放短促低音。
- **自动步进**：按空格键逐步执行每一位的决策，ESC键切换自动模式。
- **伪代码展示**：右侧面板显示当前位的推导公式和主席树查询逻辑。

---

## 核心代码实现
```cpp
void update(int pre, int &now, int l, int r, int pos) {
    now = ++tot;
    tree[now] = tree[pre];
    tree[now].sum++;
    if (l == r) return;
    int mid = (l + r) >> 1;
    if (pos <= mid) update(tree[pre].l, tree[now].l, l, mid, pos);
    else update(tree[pre].r, tree[now].r, mid + 1, r, pos);
}

bool query(int L, int R, int l, int r, int ql, int qr) {
    if (ql > r || qr < l) return false;
    if (ql <= l && r <= qr) 
        return tree[R].sum - tree[L].sum > 0;
    int mid = (l + r) >> 1;
    return query(tree[L].l, tree[R].l, l, mid, ql, qr) || 
           query(tree[L].r, tree[R].r, mid + 1, r, ql, qr);
}

int solve(int b, int x, int l, int r) {
    int ans = 0;
    for (int i = 17; i >= 0; i--) {
        int want = !((b >> i) & 1);
        int L = ans + (want << i) - x;
        int R = L + (1 << i) - 1;
        if (query(root[l-1], root[r], 0, MAXA, max(0, L), min(MAXA, R)))
            ans |= (want << i);
        else
            ans |= ((!want) << i);
    }
    return ans ^ b;
}
```

---
处理用时：82.34秒
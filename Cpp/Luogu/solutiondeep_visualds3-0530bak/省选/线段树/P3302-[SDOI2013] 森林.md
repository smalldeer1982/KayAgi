# 题目信息

# [SDOI2013] 森林

## 题目描述

小 Z 有一片森林，含有 $N$ 个节点，每个节点上都有一个非负整数作为权值。初始的时候，森林中有 $M$ 条边。

小Z希望执行 $T$ 个操作，操作有两类：

 - `Q x y k` 查询点 $x$ 到点 $y$ 路径上所有的权值中，第 $k$ 小的权值是多少。此操作保证点 $x$ 和点 $y$ 连通，同时这两个节点的路径上至少有 $k$ 个点。
 - `L x y` 在点 $x$ 和点 $y$ 之间连接一条边。保证完成此操作后，仍然是一片森林。

为了体现程序的在线性，我们把输入数据进行了加密。设 $lastans$ 为程序上一次输出的结果，初始的时候 $lastans$ 为 $0$。

对于一个输入的操作 `Q x y k`，其真实操作为 `Q x^lastans y^lastans k^lastans`。

对于一个输入的操作 `L x y`，其真实操作为 `L x^lastans y^lastans`。其中 `^` 运算符表示异或，等价于 Pascal 中的 `xor` 运算符。

请写一个程序来帮助小 Z 完成这些操作。

## 说明/提示

**样例解释**

对于第一个操作 `Q 8 7 3`，此时 $lastans=0$，所以真实操作为 `Q 8^0 7^0 3^0`，也即 `Q 8 7 3`。点 $8$ 到点 $7$ 的路径上一共有 $5$ 个点，其权值为 $4\ 1\ 1\ 2\ 4$。这些权值中，第三小的为 $2$，输出 $2$，$lastans$ 变为 $2$。

对于第二个操作 `Q 3 5 1` ，此时 $lastans=2$，所以真实操作为 `Q 3^2 5^2 1^2`，也即 `Q 1 7 3`。点 $1$ 到点 $7$ 的路径上一共有 $4$ 个点，其权值为 $1\ 1\ 2\ 4$ 。这些权值中，第三小的为 $2$，输出 $2$，$lastans$ 变为 $2$。之后的操作类似。

-----
**数据范围**

| 测试点编号  | $N,M,T$ 的上界 |  `L` 操作   |  `Q` 操作  | 形态 |
| :---------: | :------------: | :---------: | :--------: | :--: |
|     $1$     |      $20$      |     N/A     |    N/A     | N/A  |
|     $2$     |     $200$      |     N/A     |    N/A     | N/A  |
|  $3\sim 4$  | $4\times 10^4$ | 无 `L` 操作 |    N/A     |  链  |
|  $5\sim 6$  | $8\times 10^4$ | 无 `L` 操作 |    N/A     |  链  |
|  $7\sim 9$  | $8\times 10^4$ | 无 `L` 操作 | 保证 $k=1$ | N/A  |
| $10\sim 11$ | $4\times 10^4$ |     N/A     | 保证 $k=1$ | N/A  |
| $12\sim 13$ | $8\times 10^4$ |     N/A     | 保证 $k=1$ | N/A  |
| $14\sim 15$ | $4\times 10^4$ | 无 `L` 操作 |    N/A     | N/A  |
| $16\sim 17$ | $8\times 10^4$ | 无 `L` 操作 |    N/A     | N/A  |
|    $18$     | $4\times 10^4$ |     N/A     |    N/A     | N/A  |
| $19\sim 20$ | $8\times 10^4$ |     N/A     |    N/A     | N/A  |

注：N/A 表示没有特殊性。

对于 $100\%$ 的测试数据，所有节点的编号在 $1\sim N$ 的范围内。节点上的权值 $\le 10^9$。$M<N$。

## 样例 #1

### 输入

```
1
8 4 8
1 1 2 2 3 3 4 4
4 7
1 8
2 4
2 1
Q 8 7 3
Q 3 5 1
Q 10 0 0
L 5 4
L 3 2
L 0 7
Q 9 2 5
Q 6 1 6```

### 输出

```
2 
2
1
4
2```

# AI分析结果



### 唯一算法分类
主席树 + 启发式合并

---

### 综合分析与结论
#### 核心算法流程
1. **主席树构建**：每个节点维护从根到该节点的权值线段树，继承父节点树结构
2. **路径查询**：通过 x,y,lca(x,y),fa(lca(x,y)) 四个节点的线段树做差分运算
3. **启发式合并**：较小子树整体重构，更新倍增数组、深度、并查集关系
4. **倍增LCA**：合并时动态维护父节点的倍增关系

#### 可视化设计思路
1. **像素风格动画**：用 16x16 像素块表示树节点，合并时小树节点变色闪烁
2. **线段树差分演示**：四棵线段树用不同颜色高亮，动态显示权值叠加过程
3. **合并过程跟踪**：展示小树节点被DFS遍历时的递归深度和倍增层级更新
4. **音效设计**：合并成功时播放合成音，查询时根据k值变化播放不同音阶

---

### 题解清单（≥4星）

1. **玫葵之蝶（★★★★★）**
- 亮点：完整实现启发式合并流程，通过DFS同时更新倍增数组和主席树
- 代码关键：在DFS递归中实时更新父节点和倍增数组

2. **IC_QQQ（★★★★☆）**
- 亮点：深入分析倍增数组更新问题，给出测试点调试经验
- 心得摘录："LCA的倍增层级必须覆盖最大可能深度，否则重构后查询会出错"

3. **LJC00118（★★★★☆）**
- 亮点：提出LCT维护LCA的替代方案，对比不同实现复杂度
- 技巧：通过LCT的findroot操作获取fa[lca]

---

### 核心代码实现
#### 主席树差分查询
```cpp
int query(int x, int y, int lca, int falca, int k) {
    int l=1, r=len, sum;
    while(l < r) {
        int mid = (l+r)/2;
        sum = t[ls(x)].cnt + t[ls(y)].cnt 
            - t[ls(lca)].cnt - t[ls(falca)].cnt;
        if(k <= sum) { // 左子树查询
            x=ls(x), y=ls(y);
            lca=ls(lca), falca=ls(falca);
            r = mid;
        } else { // 右子树查询
            k -= sum;
            x=rs(x), y=rs(y);
            lca=rs(lca), falca=rs(falca);
            l = mid+1;
        }
    }
    return l;
}
```

#### 启发式合并核心
```cpp
void merge(int x, int y) {
    x = find(x), y = find(y);
    if(sz[x] < sz[y]) swap(x,y);
    
    // 重构较小树y
    fa[y][0] = x;
    dfs(y, x); // 更新y的子树
    
    sz[x] += sz[y];
    add_edge(x,y);
}
```

---

### 同类型题推荐
1. **P2633 Count on a tree**（静态树路径第k小）
2. **P4197 Peaks**（离线路径查询+并查集）
3. **P3293 [SCOI2016]美味**（可持久化结构+异或查询）

---

### 可视化实现要点
1. **Canvas网格布局**：用16x16像素表示节点，父节点连线动态绘制
2. **合并动画**：小树节点从绿色渐变为大树颜色，伴随像素溶解特效
3. **音效触发**：
   - `new Audio('blip.wav').play()` 当节点被DFS访问时
   - `synth.triggerAttackRelease('C4', '8n')` 当查询命中k值时
4. **自动演示模式**：通过递归调用setTimeout实现分步动画

---

### 复古游戏化设计
```javascript
// 8位音效生成
function playBlip() {
    const ctx = new AudioContext();
    const osc = ctx.createOscillator();
    osc.type = 'square';
    osc.frequency.value = 440 + Math.random()*100;
    osc.connect(ctx.destination);
    osc.start(); osc.stop(ctx.currentTime + 0.1);
}

// 像素动画帧绘制
function drawNode(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*20, y*20, 18, 18); // 保留2像素边框
}
```

---

该解决方案完美结合了可持久化数据结构的空间效率和启发式合并的时间效率，通过动态维护树结构的拓扑关系，实现了在森林环境下高效的路径查询与动态合并操作。

---
处理用时：62.82秒
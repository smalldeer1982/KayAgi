# 题目信息

# [ZJOI2013] K大数查询

## 题目描述

你需要维护 $n$ 个可重整数集，集合的编号从 $1$ 到 $n$。  
这些集合初始都是空集，有 $m$ 个操作：  

- `1 l r c`：表示将 $c$ 加入到编号在 $[l,r]$ 内的集合中  
- `2 l r c`：表示查询编号在 $[l,r]$ 内的集合的并集中，第 $c$ 大的数是多少。  

注意可重集的并是不去除重复元素的，如 $\{1,1,4\}\cup\{5,1,4\}=\{1,1,4,5,1,4\}$。


## 说明/提示

【样例说明】   
第 $1$ 次操作在 $1,2$ 号集合中分别加入了一个  $1$。    
第 $2$ 次操作在 $1,2$ 号集合中分别加入了一个 $2$。   
第 $3$ 次操作查询 $1$ 号集合中第 $2$ 大的数，答案为 $1$。  
第 $4$ 次操作查询 $1$ 号集合中第 $1$ 大的数，答案为 $2$。    
第 $5$ 次操作查询 $1,2$ 号集合的并集 $\{1,2,1,2\}$ 中第 $3$ 大的数，答案为 $1$。

【数据范围】  
$1 \le n,m \le 5\times 10^4$   
$1\le l,r \le n$   
$1$ 操作中 $|c|\le n$   
$2$ 操作中 $1\le c < 2^{63}$，第 $c$ 大的数存在

---

$\text{upd 2023.8.23}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
2 5
1 1 2 1
1 1 2 2
2 1 1 2
2 1 1 1
2 1 2 3```

### 输出

```
1
2
1```

# AI分析结果



**算法分类**：整体二分、树套树（线段树套线段树/树状数组套线段树）

---

### **综合分析与结论**
#### **核心算法流程**
1. **整体二分**  
   - **流程**：通过二分答案，将操作分为「对当前答案有贡献」和「无贡献」两类。  
     - 修改操作：若值大于mid则对区间打标记贡献  
     - 查询操作：统计区间标记数，判断答案在左/右区间  
   - **可视化设计**：  
     - **动画**：以分治树形式展示，左侧为[mid+1, r]，右侧为[l, mid]，高亮当前操作的分类流向  
     - **颜色标记**：修改操作用蓝色（影响右区间）、查询用绿色（成功匹配）和红色（未匹配）  
     - **步进控制**：允许单步执行分治过程，观察每层递归的区间划分  

2. **树套树（权值线段树套区间线段树）**  
   - **流程**：外层权值线段树维护数值范围，内层区间线段树维护位置信息  
     - 插入：按权值定位外层节点，内层执行区间加法  
     - 查询：权值线段树上二分，内层统计区间和  
   - **可视化设计**：  
     - **嵌套结构**：外层树节点展开显示对应的内层线段树  
     - **动态开点**：用闪烁效果表示新创建的节点  
     - **标记永久化**：高亮当前路径上的累计标记  

---

### **题解清单（评分≥4星）**
1. **整体二分（5星）**  
   - **亮点**：代码简洁（约60行），用差分树状数组优化区间统计  
   - **关键代码**：  
     ```cpp
     void solve(int st,int en,int l,int r){
         if(l==r){ /*记录答案*/ return; }
         int mid=(l+r)>>1;
         // 分类操作并统计贡献
         for(int i=st;i<=en;i++){
             if(q[i].op==1 && q[i].v>mid) add(q[i].l,q[i].r,1);
             else if(q[i].op==2){
                 ll val=query(q[i].l,q[i].r);
                 if(val<q[i].v) q[i].v-=val, 分到左区间;
                 else 分到右区间;
             }
         }
         // 递归处理
     }
     ```

2. **线段树套线段树（4.5星）**  
   - **亮点**：动态开点+标记永久化优化内存  
   - **核心片段**：  
     ```cpp
     void update(int &o,int l,int r,int L,int R){
         if(!o) o=++cnt;
         sum[o] += (min(R,r)-max(L,l)+1);
         if(L<=l && r<=R) { tag[o]++; return; }
         // 递归更新子节点...
     }
     ```

3. **树状数组套线段树（4星）**  
   - **亮点**：用二次差分实现区间修改  
   - **关键公式**：  
     ```math
     ∑a_i = (n+1)∑b_i - ∑i·b_i
     ```

---

### **最优思路提炼**
1. **整体二分**  
   - **离线处理**：批量操作通过分治降低时间复杂度至O(n log²n)  
   - **差分优化**：用树状数组维护区间和的增减，避免线段树的复杂实现  

2. **标记永久化**  
   - **优势**：减少递归下传标记的开销，适用于树套树的深层嵌套结构  
   - **实现**：在查询路径上累加历史标记值  

---

### **同类题目推荐**
1. **P2617 Dynamic Rankings**  
   （动态区间第k小，树套树模板题）  
2. **P3380 二逼平衡树**  
   （区间排名+前驱/后继，综合应用树套树）  
3. **P1972 HH的项链**  
   （离线查询+树状数组，练习分治思想）

---

### **可视化与复古动画设计**
1. **8位像素风格**  
   - **颜色方案**：  
     - 线段树节点：绿色（活跃）、灰色（未访问）  
     - 操作流：黄色箭头指示分类方向  
   - **音效**：  
     - 分治切割：短促"哔"声  
     - 标记更新：连续"滴答"声  

2. **Canvas动画示例**  
   ```javascript
   function drawTree(x, y, l, r, depth){
       ctx.fillStyle = "#00FF00"; // 节点颜色
       ctx.fillRect(x, y, 30, 30); 
       ctx.fillText(`${l}-${r}`, x+5, y+20);
       if(l != r){
           drawTree(x-50, y+50, l, mid, depth+1); // 左子树
           drawTree(x+50, y+50, mid+1, r, depth+1); // 右子树
       }
   }
   ```

---

### **代码实现（整体二分完整版）**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=5e4+5;
struct Q{int op,l,r,id; ll v;}q[N],L[N],R[N];
ll ans[N],bit1[N],bit2[N];
int n,m;

void add(int p,int v){
    for(int x=p;x<=n;x+=x&-x) 
        bit1[x]+=v, bit2[x]+=v*p;
}
ll query(int p){
    ll res=0;
    for(int x=p;x;x-=x&-x)
        res+=bit1[x]*(p+1)-bit2[x];
    return res;
}

void solve(int ql,int qr,int l,int r){
    if(ql>qr) return;
    if(l==r){
        for(int i=ql;i<=qr;i++)
            if(q[i].op==2) ans[q[i].id]=l;
        return;
    }
    int mid=(l+r)>>1, cntL=0, cntR=0;
    // 分类操作
    for(int i=ql;i<=qr;i++){
        if(q[i].op==1){
            if(q[i].v>mid) 
                add(q[i].l,1), add(q[i].r+1,-1), R[++cntR]=q[i];
            else L[++cntL]=q[i];
        }else{
            ll t=query(q[i].r)-query(q[i].l-1);
            if(t<q[i].v) q[i].v-=t, L[++cntL]=q[i];
            else R[++cntR]=q[i];
        }
    }
    // 撤销标记
    for(int i=ql;i<=qr;i++)
        if(q[i].op==1 && q[i].v>mid)
            add(q[i].l,-1), add(q[i].r+1,1);
    // 合并结果
    int pos=ql;
    for(int i=1;i<=cntL;i++) q[pos++]=L[i];
    for(int i=1;i<=cntR;i++) q[pos++]=R[i];
    solve(ql,ql+cntL-1,l,mid);
    solve(ql+cntL,qr,mid+1,r);
}

int main(){
    scanf("%d%d",&n,&m);
    int cntq=0;
    for(int i=1;i<=m;i++){
        scanf("%d%d%d%lld",&q[i].op,&q[i].l,&q[i].r,&q[i].v);
        if(q[i].op==2) q[i].id=++cntq;
    }
    solve(1,m,-n,n);
    for(int i=1;i<=cntq;i++) printf("%lld\n",ans[i]);
    return 0;
}
```

---
处理用时：86.97秒
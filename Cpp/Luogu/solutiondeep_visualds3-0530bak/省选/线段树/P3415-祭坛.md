# 题目信息

# 祭坛

## 题目背景

在遥远的Dgeak大陆，生活着一种叫做Dar-dzo-nye的怪物。每当这种怪物降临，人们必须整夜对抗怪物而不能安睡。为了乞求这种怪物不再降临，人们决定建造祭坛。


## 题目描述

Dgeak大陆可以看成一个用平面直角坐标系表示的巨大平面。在这个平面上，有 n 个Swaryea水晶柱，每个水晶柱可以用一个点表示。

如果 4 个水晶柱依次相连可以构成一个四边形，满足其两条对角线分别平行于 x 轴和 y 轴，并且对角线的交点位于四边形内部（不包括边界），那么这 4 个水晶柱就可以建立一个结界。其中，对角线的交点称作这个结界的中心。

例如下左图中，水晶柱 ABCD 可以建立一个结界，其中心为 O。

![](https://cdn.luogu.com.cn/upload/pic/3591.png)   ![](https://cdn.luogu.com.cn/upload/pic/3592.png)

为了起到抵御Dar-dzo-nye的最佳效果，人们会把祭坛修建在最多层结界的保护中。其中不同层的结界必须有共同的中心，这些结界的边界不能有任何公共点，并且中心处也不能有水晶柱。这里共同中心的结界数量叫做结界的层数。

为了达成这个目的，人们要先利用现有的水晶柱建立若干个结界，然后在某些结界的中心建立祭坛。

例如上右图中，黑色的点表示水晶柱（注意 P 和 O 点不是水晶柱）。祭坛的一个最佳位置为 O 点，可以建立在 3 层结界中，其结界的具体方案见下左图。当然，建立祭坛的最佳位置不一定是唯一，在上右图中，O 点左侧 1 单位的点 P 也可以建立一个在 3 层结界中的祭坛，见下右图。

![](https://cdn.luogu.com.cn/upload/pic/3593.png)   ![](https://cdn.luogu.com.cn/upload/pic/3594.png)

现在人们想知道：

1. 祭坛最佳选址地点所在的结界层数；

2. 祭坛最佳的选址地点共有多少个。


## 说明/提示

对于30%的数据 n <= 1000

另外30%的数据 n <= 10000

剩下的40%数据 n <= 100000

保证 0 <= x, y <= n


## 样例 #1

### 输入

```
26
0 5
1 1
1 5
1 9
3 5
3 10
4 0
4 1
4 2
4 4
4 6
4 9
4 11
5 0
5 2
5 4
5 8
5 9
5 10
5 11
6 5
7 5
8 5
9 10
10 2
10 5```

### 输出

```
3
2```

# AI分析结果



## 唯一算法分类
**扫描线+线段树**

---

## 综合分析与结论
### 核心思路
题目要求寻找平面上能形成最多层结界的中心点。关键点在于：  
1. **二维降维**：将二维平面问题通过扫描线转化为一维处理  
2. **统计约束**：每个有效中心需满足上下左右四个方向均有足够水晶柱  
3. **动态维护**：用线段树快速统计满足条件的区间  

### 算法流程
1. **离散化**：将坐标映射到整数范围  
2. **扫描线处理**：按行或列扫描，维护当前行/列两侧的水晶数量  
3. **线段树维护**：  
   - **最大层数**：维护区间上下限的最小值  
   - **可行区域**：统计满足条件的区间交集  
4. **两次扫描**：第一次求最大层数，第二次统计符合该层数的中心点数量  

### 可视化设计
- **像素网格**：用 Canvas 绘制离散化后的平面网格，水晶柱显示为彩色方块  
- **扫描线高亮**：当前扫描的行/列以流动光带效果显示  
- **线段树动画**：右侧显示线段树结构，更新节点时触发闪光特效  
- **音效反馈**：扫描线移动时播放低音脉冲，找到可行区间时触发清脆音效  

---

## 题解清单（≥4星）
1. **ddd（4星）**  
   - **亮点**：二分答案思路清晰，离散化处理严谨  
   - **优化**：通过二分快速缩小搜索范围  
   - **不足**：O(nlog²n)复杂度略高  

2. **Ameyax（4.5星）**  
   - **亮点**：两次扫描分离求值与统计，代码结构清晰  
   - **关键点**：分两次用线段树维护最大值和区间和  
   - **优化**：O(nlogn)复杂度，适合大数据  

---

## 最优思路提炼
### 核心技巧
- **双维度扫描**：横向扫描处理列，纵向扫描处理行，线段树维护交叠区间  
- **分离统计阶段**：先求最大层数，再统计符合该层数的具体位置  
- **离散化压缩**：将大范围坐标映射到小范围整数，降低处理复杂度  

### 代码片段（Ameyax题解核心）
```cpp
// 第一次扫描求最大层数
for (int k = i; k < j; k++) {
    if (t[k+1].xx > t[k].xx+1 && min(suml,sumr) > ans)
        ans = max(ans, min(sgt.querymax(...), min(suml,sumr)));
    suml++; sumr--;
}
// 第二次扫描统计数量
if (t[k+1].xx > t[k].xx+1 && min(suml,sumr) >= ans)
    sumans += sgt.querysum(...);
```

---

## 同类型题
1. **SDOI2009 虔诚的墓主人**（二维扫描线+线段树）  
2. **CF 869E 矩形覆盖**（二维数点+哈希）  
3. **洛谷 P3810 三维偏序**（分治+树状数组）  

---

## 推荐洛谷题目
1. **P2154** 虔诚的墓主人  
2. **P1972** HH的项链（区间统计）  
3. **P3810** 三维偏序  

---

## 个人心得摘录
- **离散化细节**：需注意坐标去重后的大小关系  
- **线段树更新时机**：必须在处理完当前行所有点后更新  
- **边界处理**：区间查询时需排除端点避免重复计数  

---

## 可视化与算法演示
### 动画设计
1. **初始化阶段**：  
   - 离散化后的网格显示在左侧 Canvas  
   - 每个水晶柱以蓝色方块表示  
   - 右侧显示空线段树结构  

2. **扫描线运行**：  
   - 横向黄色光带从上至下扫描每一行  
   - 当前行的水晶柱变为橙色  
   - 线段树节点根据当前行数据动态更新（绿色高亮）  

3. **区间查询**：  
   - 当扫描线发现可行区间时，对应网格区域闪烁红色边框  
   - 线段树相关查询路径以紫色标记  

### 复古游戏化效果
- **音效**：  
  - 扫描线移动：8-bit低音脉冲（频率随扫描速度变化）  
  - 找到可行区间：FC风格胜利音效（短促三连音）  
- **像素艺术**：水晶柱用16x16像素块，线段树节点用复古绿色数字显示  
- **自动演示模式**：按空格键切换手动/自动，自动模式下算法以2倍速运行  

---

## 核心算法演示（伪代码）
```javascript
// 初始化离散化网格
const grid = new PixelGrid(canvasWidth, canvasHeight);
points.forEach(p => grid.addPoint(p.x, p.y));

// 扫描线主循环
for (let y = 0; y < maxY; y++) {
    playSound(scrollBeep); // 扫描音效
    const rowPoints = getPointsInRow(y);
    rowPoints.sort((a,b) => a.x - b.x);
    
    // 更新线段树
    rowPoints.forEach(p => {
        const cnt = updateCounters(p.x);
        tree.update(p.x, cnt);
    });
    
    // 查询可行区间
    const validRanges = tree.queryValidRanges();
    validRanges.forEach(range => {
        grid.highlightArea(range.x1, range.x2, y);
        playSound(foundSound);
    });
}
```

---
处理用时：68.54秒
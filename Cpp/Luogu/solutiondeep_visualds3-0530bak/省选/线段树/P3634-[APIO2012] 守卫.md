# 题目信息

# [APIO2012] 守卫

## 题目描述

APIO 王国正被忍者攻击！忍者非常厉害，因为他们在进攻的时候可以躲在 阴影里面使得其他人看不到他们。整个王国除了国王居住的 APIO 城堡以外都已 经被占领了。在城堡前，有 N 个灌木丛，从 1 到 N 编号，有 K 个忍者躲在恰好 K 个灌木丛后面。APIO 城堡里有 M 个守卫。守卫 i 监视着编号从 Ai到 Bi的连续 的一段灌木丛。每个守卫都向国王报告在他所监视范围内是否有忍者出现。作为 国王的仆人，你需要告诉国王，基于守卫的报告，哪些灌木丛后面一定躲着一个 忍者，即对于任何和守卫报告不矛盾的忍者排列方式，在这个灌木丛后面都躲着 一个忍者。

你需要写一个程序来输出所有的这些灌木丛的编号。


## 说明/提示

【样例说明 1】

在这个样例中，有两种可能的安排方式：1，3，5 或者 2，3，5。即 3 和 5 后面必然躲着一个忍者。 考虑第一个灌木丛，存在一种安排方案使得它的后面躲着忍者，但也存在一 种安排方案使得它后面没有躲忍者，因此不应该输出 1。同理，不应该输出 2。

【样例说明 2】

在这个样例中，没有灌木丛后面一定躲着忍者。

灌木的数量 1 ≤ N ≤ 100,000 ；

忍者数 1 ≤ K ≤ N ；

守卫数 0 ≤ M < 100,000 。

 
对于 10%的数据，N ≤ 20， M ≤ 100；

对于 50%的数据，N ≤ 1000， M ≤ 1000。


## 样例 #1

### 输入

```
5 3 4 
1 2 1 
3 4 1 
4 4 0 
4 5 1```

### 输出

```
3
5
```

## 样例 #2

### 输入

```
5 1 1 
1 5 1```

### 输出

```
-1```

# AI分析结果



---

### 唯一算法分类
**贪心算法 + 区间处理**

---

### 综合分析与结论

#### 核心算法流程
1. **预处理必须为0的区间**：  
   通过差分数组或线段树标记所有被必须为0的区间覆盖的点，剩余的点重新编号为连续序列。
   
2. **区间去重与排序**：  
   对必须为1的区间处理，去除包含其他区间的无效大区间，并按左端点排序，使剩余区间满足左右端点均递增。

3. **贪心确定候选点**：  
   从左到右扫描区间，若当前区间未被覆盖，则在其右端点放置忍者，记录前缀最少点数 `f[i]`；同理从右到左记录后缀最少点数 `g[i]`。

4. **必选点判断**：  
   对每个候选点，假设不选它，在左半区间贪心选点，右半区间贪心选点，若总点数超过 `k`，则该点必选。通过二分快速定位左右半区间。

#### 可视化设计思路
1. **像素动画流程**：  
   - **步骤1**：显示原始区间，红色高亮必须为0的区间，绿色为可能为1的点。  
   - **步骤2**：动态绘制重新编号后的连续区间，灰色表示被去除的大区间。  
   - **步骤3**：贪心选点过程，用黄色方块标记右端点，并显示 `f[i]` 和 `g[i]` 的更新。  
   - **步骤4**：必选点判断时，用闪烁效果展示候选点，红色叉表示不选后的总点数超标，绿色勾表示必选。

2. **复古交互设计**：  
   - **8位音效**：放置忍者时播放“滴”声，必选点确认时播放“胜利”音效。  
   - **Canvas 网格**：每个点用16x16像素方块表示，区间用连线连接左右端点。  
   - **AI自动演示**：按空格切换手动/自动模式，自动模式下算法逐步执行并语音解说。

---

### 题解清单 (≥4星)
1. **by_chance（5星）**  
   - **亮点**：完整覆盖所有边界情况，代码结构清晰，利用前缀/后缀数组快速计算最小点数。  
   - **关键代码**：贪心选右端点 + 二分查找左右半区间。

2. **小塘空明（4.5星）**  
   - **亮点**：详细注释与变量命名规范，对区间去重和二分判断有完整推导。  
   - **个人心得**：“必须放到最右边左边一个不可行”的调试过程。

3. **Milky_Way（4星）**  
   - **亮点**：结合图形示例解释贪心策略，代码中嵌入调试输出逻辑。  
   - **关键优化**：单调栈去重包含区间的高效实现。

---

### 核心代码实现
```cpp
// by_chance 题解核心逻辑
for (int i=1; i<=t; i++) {
    if (p[i].l == p[i].r) { // 单点区间必选
        printf("%d\n", h[p[i].r]);
        continue;
    }
    if (f[i] != f[i-1]+1) continue; // 当前区间未新增忍者
    
    // 二分找右半区间起始位置
    int l = i+1, r = t, pos = t+1;
    while (l <= r) {
        int mid = (l+r)>>1;
        if (p[mid].l > p[i].r-1) pos=mid, r=mid-1;
        else l = mid+1;
    }
    
    if (f[i] + g[pos] > k) // 不选则总数超标
        printf("%d\n", h[p[i].r]);
}
```

---

### 相似题目推荐
1. **P1250 种树**：区间最少点数覆盖，贪心右端点。  
2. **P1514 引水入城**：区间覆盖与贪心验证。  
3. **P2082 区间覆盖**：去除包含区间后计算覆盖。

---

### 复古像素动画代码片段
```javascript
// Canvas 绘制贪心选点（伪代码）
function drawGreedy(pos, intervals) {
    ctx.fillStyle = "#FFD700"; // 金色表示当前选中点
    ctx.fillRect(pos*16, 50, 16, 16); 
    intervals.forEach((itv, idx) => {
        ctx.strokeStyle = "#00FF00"; // 绿色区间
        ctx.beginPath();
        ctx.moveTo(itv.l*16, 30);
        ctx.lineTo(itv.r*16, 30);
        ctx.stroke();
    });
    playSound("beep"); // 8位音效
}
```

---

### 总结
本题解通过贪心与区间处理结合，核心在于预处理和高效验证必选点。可视化可增强对“右端点贪心”和“二分验证”步骤的理解，复古风格则提升学习趣味性。

---
处理用时：59.50秒
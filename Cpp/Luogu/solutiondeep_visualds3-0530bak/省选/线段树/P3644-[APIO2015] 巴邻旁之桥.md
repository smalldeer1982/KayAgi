# 题目信息

# [APIO2015] 巴邻旁之桥

## 题目描述

一条东西走向的穆西河将巴邻旁市一分为二，分割成了区域 $A$ 和区域 $B$。

每一块区域沿着河岸都建了恰好 $1000000001$ 栋的建筑，每条岸边的建筑都从 $0$ 编号到 $1000000000$。相邻的每对建筑相隔 $1$ 个单位距离，河的宽度也是 $1$ 个单位长度。区域 $A$ 中的 $i$ 号建筑物恰好与区域 $B$ 中的 $i$ 号建筑物隔河相对。

城市中有 $N$ 个居民。第 $i$ 个居民的房子在区域 $P_i$ 的 $S_i$ 号建筑上，同时他的办公室坐落在 $Q_i$ 区域的 $T_i$ 号建筑上。一个居民的房子和办公室可能分布在河的两岸，这样他就必须要搭乘船只才能从家中去往办公室，这种情况让很多人都觉得不方便。为了使居民们可以开车去工作，政府决定建造不超过 $K$ 座横跨河流的大桥。

由于技术上的原因，每一座桥必须刚好连接河的两岸，桥梁必须严格垂直于河流，并且桥与桥之间不能相交。

当政府建造最多 $K$ 座桥之后，设 $D_i$ 表示第 $i$ 个居民此时开车从家里到办公室的最短距离。请帮助政府建造桥梁，使得 $D_1 + D_2 + \cdots + D_N$ 最小。


## 说明/提示

【数据范围】

所有数据都保证：$P_i$ 和 $Q_i$ 为字符 “A” 和 “B” 中的一个， $0 \leq S_i, T_i \leq 1000000000$，同一栋建筑内可能有超过 $1$ 间房子或办公室（或二者的组合，即房子或办公室的数量同时大于等于 $1$）。

子任务 1 （8 分）$K = 1$

$1 \leq N \leq 1000$


子任务 2 （14 分）$K = 1$

$1 \leq N \leq 100000$


子任务 3 （9 分）$K = 2$

$1 \leq N \leq 100$


子任务 4 （32 分）$K = 2$

$1 \leq N \leq 1000$


子任务 5 （37 分）$K = 2$

$1 \leq N \leq 100000$


## 样例 #1

### 输入

```
1 5
B 0 A 4
B 1 B 3
A 5 B 7
B 2 A 6
B 1 A 7```

### 输出

```
24
```

## 样例 #2

### 输入

```
2 5
B 0 A 4
B 1 B 3
A 5 B 7
B 2 A 6
B 1 A 7```

### 输出

```
22```

# AI分析结果



## 算法分类
贪心 + 中位数优化

---

## 题解思路与解决难点

### 核心思路
1. **K=1 时**：  
   所有需要过桥的住户的坐标视为数轴上的点，求中位数即可最小化总距离。预处理所有坐标后取中位数计算。

2. **K=2 时**：  
   - 按 `(家坐标 + 办公室坐标)` 排序，将问题拆分为前缀和后缀两个子问题。  
   - 枚举分界点，左侧用一座桥，右侧用另一座桥。  
   - 动态维护前缀和后缀的中位数及距离和，采用对顶堆或平衡树优化。

### 解决难点
- **动态中位数维护**：通过两个堆（大根堆存较小一半，小根堆存较大一半）实现高效插入和平衡调整。  
- **快速距离和计算**：利用堆的性质，总距离可转化为 `大堆总和 - 小堆总和` 的形式，无需遍历所有元素。

---

## 最优思路提炼

### 关键技巧
1. **对顶堆维护中位数**：  
   - 插入元素时先放入大根堆，调整平衡后交换堆顶。  
   - 计算距离和时直接取堆顶元素和大小差值。

2. **排序分治策略**：  
   - 按 `家 + 办公室` 排序后，分割点左侧必选左桥，右侧必选右桥，转化为独立子问题。

### 代码实现要点
```cpp
// 对顶堆动态维护中位数及距离和
priority_queue<int, vector<int>, less<int>> q1;    // 大根堆（前一半）
priority_queue<int, vector<int>, greater<int>> q2; // 小根堆（后一半）
long long s1, s2;                                 // 堆内元素总和

void insert(int x) {
    q1.push(x); s1 += x;
    // 调整平衡
    q2.push(q1.top()); s2 += q1.top();
    q1.pop(); s1 -= q2.top();
    if (q1.size() && q1.top() > q2.top()) {
        // 交换堆顶元素
        int a = q1.top(), b = q2.top();
        q1.pop(); q2.pop();
        q1.push(b); q2.push(a);
        s1 += b - a; s2 += a - b;
    }
}
// 当前距离和为 s2 - s1
```

---

## 推荐相似题目
1. **P1168 中位数**  
   - 动态维护中位数的模板题，可用对顶堆或平衡树解决。

2. **CF818D 动态中位数扩展**  
   - 结合滑动窗口的动态中位数问题，需优化数据维护方式。

3. **P3620 数据备份**  
   - 贪心策略与中位数优化结合，需维护动态选择的优先级。

---

## 可视化设计

### 动画方案（K=2 分治策略）
1. **数轴展示**：  
   - 将家和办公室的坐标绘制为红蓝点，连线中点用绿色标记。  
   - 分界点移动时，左右桥位置动态更新为对应区域的中位数。

2. **堆操作高亮**：  
   - 插入元素时，新点闪烁后进入大根堆，堆顶调整时用箭头标记交换。  
   - 堆内元素用不同颜色区分，堆顶高亮为黄色。

3. **分界点枚举**：  
   - 滑动条控制分界点位置，实时显示左右桥位置和总距离变化曲线。

### 复古像素风格（示例代码）
```javascript
// Canvas绘制像素化数轴
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
const scale = 10; // 每个单位10像素

function drawPoint(x, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * scale, 50, scale, scale); // 家在数轴下方
    ctx.fillRect(x * scale, 150, scale, scale); // 办公室在数轴上方
}

function updateBridges(leftX, rightX) {
    // 绘制桥为白色像素块
    ctx.fillStyle = '#FFF';
    ctx.fillRect(leftX * scale, 100, scale, scale);
    ctx.fillRect(rightX * scale, 100, scale, scale);
}
```

---

## 题解评分（≥4星）

### 1. ix35（★★★★☆）
- **亮点**：简洁的对顶堆实现，预处理前后缀距离和。  
- **关键代码**：动态调整堆顶平衡，时间复杂度 O(n log n)。

### 2. StudyingFather（★★★★☆）
- **亮点**：模块化代码结构，清晰拆分 K=1 和 K=2 的逻辑。  
- **心得引用**：*“对顶堆维护中位数时需注意堆顶交换的边界条件”*。

### 3. tommymio（★★★★☆）
- **亮点**：FHQ Treap 实现动态中位数，适合大规模数据。  
- **关键优化**：通过排序分治减少平衡树操作次数。

---

## 个人心得摘录
- **ix35**：*“无需复杂数据结构，两个堆即可高效处理动态中位数问题。”*  
- **Ebola**：*“调试时发现堆顶交换逻辑错误，需严格保证大根堆顶 ≤ 小根堆顶。”*

---

## 核心代码（K=2 动态分治）
```cpp
sort(p, p + n, [](Node a, Node b) { 
    return a.x + a.y < b.x + b.y; 
});
for (int i = 0; i < n; i++) {
    insert(p[i].x); insert(p[i].y);
    pre_sum[i] = s2 - s1; // 前缀距离和
}
// 处理后缀同理，取 min(pre[i] + suf[i+1])
```

---
处理用时：72.54秒
# 题目信息

# [ZJOI2017] 树状数组

## 题目描述

漆黑的晚上，九条可怜躺在床上辗转反侧。难以入眠的她想起了若干年前她的一次悲惨的 OI 比赛经历。那是一道基础的树状数组题。

给出一个长度为 $n$ 的数组 $A$，初始值都为 $0$，接下来进行 $m$ 次操作，操作有两种：

* $1\ x$，表示将 $A_x$  变成 $(A_x + 1) \bmod 2$。
* $2\ l\ r$，表示询问 $(\sum_{i=l}^r A_i) \bmod 2$。

尽管那个时候的可怜非常的 simple，但是她还是发现这题可以用树状数组做。当时非常 young 的她写了如下的算法：

![](https://cdn.luogu.com.cn/upload/pic/4744.png)

其中 $\mathrm{lowbit}(x)$ 表示数字 $x$ **最低**的非 $0$ 二进制位，例如 $\text{lowbit}(5) = 1, \text{lowbit}(12) = 4$。进行第一类操作的时候就调用 $\mathrm{Add}(x)$，第二类操作的时候答案就是 $\mathrm{Query}(l, r)$。

如果你对树状数组比较熟悉，不难发现可怜把树状数组写错了：**$\text{Add}$ 和 $\text{Find}$ 中 $x$  变化的方向反了**。因此这个程序在最终测试时华丽的爆 0 了。

然而奇怪的是，在当时，这个程序通过了出题人给出的大样例——这也是可怜没有进行对拍的原因。

现在，可怜想要算一下，这个程序回答对每一个询问的概率是多少，这样她就可以再次的感受到自己是一个多么非的人了。然而时间已经过去了很多年，即使是可怜也没有办法完全回忆起当时的大样例。幸运的是，她回忆起了大部分内容，唯一遗忘的是每一次第一类操作的 $x$ 的值，因此她假定这次操作的 $x$ 是在 $[l_i, r_i]$  范围内**等概率随机**的。

具体来说，可怜给出了一个长度为 $n$ 的数组 $A$，初始为 $0$，接下来进行了 $m$ 次操作：

* $1\ l\ r$，表示在区间 $[l, r]$ 中等概率选取一个 $x$ 并执行 $\text{Add}(x)$ 。

* $2\ l\ r$，表示询问执行 $\text{Query}(l, r)$ 得到的结果是正确的概率是多少。

## 说明/提示

#### 样例说明

在进行完 $\mathrm{Add}(3)$ 之后，$A$ 数组变成了 $[0, 1, 1, 0, 0]$。所以前两次询问可怜的程序答案都是 $1$，因此第一次询问可怜一定正确，第二次询问可怜一定错误。

#### 数据范围

| 测试点编号 |        $n$         |              $m$               |      其他约定      |
| :--------: | :----------------: | :----------------------------: | :----------------: |
|    $1$     |      $\le 5$       |            $\le 10$            |         无         |
|    $2$     |      $\le 50$      |      $\le 50$      |         无         |
|    $3$     |      $\le 50$      |      $\le 50$      |         无         |
|    $4$     | $\le 3\times 10^3$ | $\le 3\times 10^3$ |         无         |
|    $5$     | $\le 3\times 10^3$ | $\le 3\times 10^3$ |         无         |
|    $6$     |       $10^5$       |       $10^5$       | 所有询问都在修改后 |
|    $7$     |       $10^5$       |       $10^5$       | 所有询问都在修改后 |
|    $8$     |       $10^5$       |       $10^5$       |         无         |
|    $9$     |       $10^5$       |       $10^5$       |         无         |
|    $10$    |       $10^5$       |       $10^5$       |         无         |


对于 $100\%$ 的数据，保证 $1\leq l\leq r\leq n$。

更新：2018/05/13 @larryzhong 提供了 5 组强的数据。

## 样例 #1

### 输入

```
5 5
1 3 3
2 3 5
2 4 5
1 1 3
2 2 5```

### 输出

```
1
0
665496236```

# AI分析结果



### 唯一算法分类  
二维线段树（树套树）

---

### 综合分析与结论  
题目核心在于将错误树状数组的查询转化为后缀和比较，维护点对 $(l-1, r)$ 的相等概率。关键难点在于处理多区间修改对概率的影响，需通过二维线段树高效实现区间修改与单点查询。核心算法流程如下：  
1. **问题转化**：正确性等价于 $A_{l-1} = A_r$ 的概率。  
2. **概率合并**：每次修改的影响通过结合律运算合并（$PQ + (1-P)(1-Q)$）。  
3. **二维线段树**：外层维护左端点，内层维护右端点，动态开点+标记永久化处理区间修改。  

可视化设计思路：  
- **颜色标记**：高亮当前修改影响的区间（如红色表示完全包含，蓝色表示部分包含）。  
- **步进控制**：展示线段树分裂区间、标记更新的过程，突出概率计算逻辑。  
- **复古像素风格**：用 8-bit 网格表示线段树结构，音效提示区间修改类型（如不同音调对应不同区域影响）。

---

### 题解清单（≥4星）  
1. **鬼·烨弑（4.5星）**  
   - 亮点：代码简洁，动态开点节省空间，标记永久化处理清晰。  
   - 关键思路：外层线段树维护左端点，内层维护右端点，通过概率合并公式更新区间。  

2. **shadowice1984（4星）**  
   - 亮点：详细解释矩阵乘法结合律，处理 $l=1$ 的特殊情况。  
   - 关键思路：二维线段树标记永久化，分三类讨论修改影响。  

3. **Gypsophila（4星）**  
   - 亮点：KDT 实现替代二维线段树，提供另一种数据结构思路。  
   - 关键思路：KDT 维护平面点对，分块处理修改影响。  

---

### 核心代码实现  
**鬼·烨弑的二维线段树核心代码**  
```cpp
void changey(int &k,int l,int r,int x,int y,ll p) {
    if(!k) k=++cnt, tr[k].v=1;
    if(x<=l && y>=r) { tr[k].v = mul(tr[k].v,p); return; }
    int mid=(l+r)>>1;
    if(x<=mid) changey(tr[k].ls,l,mid,x,y,p);
    if(y>mid)  changey(tr[k].rs,mid+1,r,x,y,p);
}

void changex(int k,int l,int r,int lx,int rx,int ly,int ry,ll p) {
    if(lx<=l && rx>=r) { changey(rt[k],1,n,ly,ry,p); return; }
    int mid=(l+r)>>1;
    if(lx<=mid) changex(k<<1,l,mid,lx,rx,ly,ry,p);
    if(rx>mid)  changex(k<<1|1,mid+1,r,lx,rx,ly,ry,p);
}
```

---

### 同类型题与推荐  
**相似算法题目**  
1. **P1972 [SDOI2009] HH的项链**：树状数组处理区间查询。  
2. **P3332 [ZJOI2016] 大数**：二维数点问题，类似区间影响维护。  
3. **P4054 [JSOI2009] 计数问题**：二维树状数组的直接应用。  

---

### 个人心得摘录  
- **调试经历**：处理 $l=1$ 时的概率需单独维护，初始未考虑导致 WA。  
- **顿悟感想**：概率合并的交换律是标记永久化的关键，否则无法高效处理区间修改。  

---

### 可视化设计要点  
**复古像素风格实现**  
1. **Canvas 绘制**：线段树节点以网格表示，修改时闪烁对应区间。  
2. **音效触发**：  
   - 完全包含区间：高音调“哔”。  
   - 部分包含区间：中音调“嘟”。  
3. **自动演示**：模拟修改步骤，AI 逐步展示区间分裂与标记更新。  

**交互设计**  
- **速度调节**：滑动条控制动画速度。  
- **关卡模式**：将修改操作设为关卡，正确维护后解锁下一关。  

--- 

### 核心算法可视化示例（伪代码）  
```javascript
// 示例：二维线段树区间修改动画
function visualizeUpdate(x1, x2, y1, y2) {
    highlightOuterNode(x1, x2); // 高亮外层区间
    splitInnerTree(y1, y2, (yNode) => {
        playSound('modify'); // 播放修改音效
        yNode.markUpdate();  // 标记永久化
    });
}
```

---
处理用时：73.11秒
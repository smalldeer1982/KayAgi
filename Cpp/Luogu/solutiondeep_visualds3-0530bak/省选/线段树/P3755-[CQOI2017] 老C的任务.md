# 题目信息

# [CQOI2017] 老C的任务

## 题目描述

老 C 是个程序员。


最近老 C 从老板那里接到了一个任务——给城市中的手机基站写个管理系统。作为经验丰富的程序员，老 C 轻松地完成了系统的大部分功能，并把其中一个功能交给你来实现。

由于一个基站的面积相对于整个城市面积来说非常的小，因此每个的基站都可以看作坐标系中的一个点，其位置可以用坐标 $(x,y)$ 来表示。此外，每个基站还有很多属性，例如高度、功率等。运营商经常会划定一个区域，并查询区域中所有基站的信息。

现在你需要实现的功能就是，对于一个给定的矩形区域，回答该区域中（包括区域边界上的）所有基站的功率总和。如果区域中没有任何基站，则回答 $0$。


## 说明/提示

对于第 $1\sim2$ 个测试点，$1≤n,m≤100$；

对于第 $3\sim5$ 个测试点，$1≤n≤50000,1≤m≤10000$；

对于第 $6\sim10$ 个测试点，$1≤n≤100000,1≤m≤100000$，数据有梯度；

对于所有测试点，$-2^{31}\le x_i,y_i,p_i,x_1,y_1,x_2,y_2<2^{31},x_1\le x_2,y_1\le y_2$。


## 样例 #1

### 输入

```
4 2   
0 0 1 
0 1 2  
2 2 4  
1 0 8  
0 0 1 1 
1 1 5 6 ```

### 输出

```
11
4```

## 样例 #2

### 输入

```
3 2
-100 0 16 
1 -10 32 
1000 100 64 
0 0 0 1 
-1000 -1000 10000 10000 ```

### 输出

```
0
112```

# AI分析结果



# 算法分类  
**二维数点/离线扫描线**  

---

## 综合分析与结论  

### 核心思路与难点  
题目要求高效处理二维平面上的矩形区域和查询，主要挑战在于处理大范围坐标（需离散化）与高数据量（需 O(n log n) 算法）。各题解解法核心如下：  

1. **离线+树状数组/CDQ分治**（最优思路）  
   - **核心逻辑**：  
     - 将矩形查询拆分为四个二维前缀和查询（容斥原理）。  
     - 按 x 坐标排序所有点与查询，用树状数组维护 y 轴前缀和。  
     - 离散化坐标，离线处理查询。  
   - **可视化设计**：  
     - **动画步骤**：  
       1. 绘制离散化后的坐标平面，标记所有基站。  
       2. 展示排序后从左到右扫描的过程，动态更新树状数组。  
       3. 高亮当前扫描线位置和正在处理的查询点。  
       4. 用不同颜色区分四个拆分查询的贡献。  
     - **复古像素风格**：  
       - 使用 8-bit 网格背景，基站显示为闪烁点，查询矩形以不同颜色边框表示。  
       - 扫描线移动时播放“滴答”音效，树状数组更新时触发短促“哔”声。  

2. **CDQ分治**  
   - **核心逻辑**：  
     - 将问题视为三维偏序（x, y, 操作类型），分治处理归并排序。  
     - 归并时统计左半部分对右半部分查询的贡献。  
   - **难点**：处理操作顺序与归并时的条件判断。  

3. **主席树**  
   - **核心逻辑**：  
     - 按 x 轴排序后，对每个 x 版本建立可持久化线段树维护 y 轴前缀和。  
   - **适用场景**：支持在线查询，但空间复杂度较高。  

---

## 题解清单（≥4星）  

1. **niiick（CDQ分治，赞14）**  
   - **亮点**：简洁的归并实现，将查询拆分为四个点统一处理。  
   - **核心代码**：  
     ```cpp  
     void CDQ(int ll, int rr) {  
         // 归并处理y轴，统计左半部分对右半的贡献  
         while (t2 <= rr) {  
             while (a[t1].y <= a[t2].y && t1 <= mid) {  
                 if (a[t1].opt==1) cnt += a[t1].p;  
                 b[p++] = a[t1++];  
             }  
             if (a[t2].opt==2) a[t2].ans += cnt;  
             b[p++] = a[t2++];  
         }  
     }  
     ```  

2. **Diaоsi（树状数组，赞11）**  
   - **亮点**：代码简洁，离散化与查询拆分清晰。  
   - **核心代码**：  
     ```cpp  
     sort(q+1, q+tot+1, cmp);  
     for (int i=1; i<=tot; i++)  
         if (!q[i].id) add(Q(q[i].y), q[i].v);  
         else ans[q[i].id] += q[i].mul * ask(Q(q[i].y));  
     ```  

3. **liangbowen（CDQ分治，赞13）**  
   - **亮点**：三维偏序转化为二维，优化树状数组为变量累加。  
   - **关键点**：`sum`变量直接累加左半部分的贡献，避免树状数组。  

---

## 最优思路与技巧提炼  

1. **查询拆分与容斥**  
   - 将矩形查询转化为四个二维前缀和的加减操作：  
     ```  
     ans = sum(x2,y2) - sum(x1-1,y2) - sum(x2,y1-1) + sum(x1-1,y1-1)  
     ```  

2. **离线排序+树状数组**  
   - **步骤**：  
     1. 离散化所有坐标。  
     2. 按 x 排序所有点和查询。  
     3. 从左到右扫描，树状数组维护当前 y 轴前缀和。  

3. **CDQ分治的归并优化**  
   - 归并时利用排序后的 y 轴有序性，直接累加贡献，减少比较次数。  

---

## 类似题目推荐  

1. **P2163 [SHOI2007] 园丁的烦恼**  
   - 二维数点模板题，直接应用离线树状数组方法。  

2. **P4390 [BOI2007] Mokia**  
   - 动态二维数点，需处理插入与查询交替操作，适合CDQ分治。  

3. **P1972 [SDOI2009] HH的项链**  
   - 一维区间数颜色，思维迁移到离线处理与树状数组。  

---

## 可视化算法演示（树状数组版）  

### 动画设计  
1. **初始化**：  
   - 绘制离散化后的网格，基站显示为绿色点，查询矩形为红色边框。  

2. **扫描线推进**：  
   - 垂直线从左到右移动，经过每个点将其加入树状数组（蓝色高亮）。  

3. **查询处理**：  
   - 当扫描线到达查询点的 x 坐标时，显示树状数组查询范围（黄色高亮 y 区间）。  

4. **音效与交互**：  
   - 扫描线移动：循环播放低音“嗡嗡”声。  
   - 树状数组更新：短促“咔嗒”声。  
   - 查询结果显示：成功时播放上升音阶。  

```javascript  
// 伪代码示例：树状数组更新与查询动画  
function visualize() {  
    points.sortByX();  
    let bit = new BinaryIndexedTree();  
    for (let p of points) {  
        if (p.isBaseStation) {  
            bit.update(p.y, p.power);  
            drawPoint(p, COLOR_GREEN);  
            playSound('click');  
        } else {  
            let sum = bit.query(p.y1, p.y2);  
            drawRectangle(p, COLOR_RED);  
            animateQueryResult(sum);  
            playSound('success');  
        }  
        moveScanLine(p.x);  
    }  
}  
```  

---

## 核心代码（树状数组+离线）  

```cpp  
#include<bits/stdc++.h>  
using namespace std;  
typedef long long ll;  
const int N=1e6+5;  

struct Query { int x, y, id, mul; };  
vector<Query> q;  
vector<int> ys;  

ll ans[N], tree[N];  
int n, m;  

void add(int p, ll v) {  
    for (; p<N; p+=p&-p) tree[p] += v;  
}  
ll ask(int p) {  
    ll res=0;  
    for (; p; p-=p&-p) res += tree[p];  
    return res;  
}  

int main() {  
    scanf("%d%d", &n, &m);  
    for (int i=0; i<n; i++) {  
        int x, y, p;  
        scanf("%d%d%d", &x, &y, &p);  
        q.push_back({x, y, 0, p});  
        ys.push_back(y);  
    }  
    for (int i=1; i<=m; i++) {  
        int x1,y1,x2,y2;  
        scanf("%d%d%d%d", &x1,&y1,&x2,&y2);  
        q.push_back({x2, y2, i, 1});  
        q.push_back({x1-1, y2, i, -1});  
        q.push_back({x2, y1-1, i, -1});  
        q.push_back({x1-1, y1-1, i, 1});  
        ys.insert(ys.end(), {y1-1, y2});  
    }  

    sort(ys.begin(), ys.end());  
    ys.erase(unique(ys.begin(), ys.end()), ys.end());  

    auto getY = [&](int y) {  
        return lower_bound(ys.begin(), ys.end(), y) - ys.begin() + 1;  
    };  

    sort(q.begin(), q.end(), [](Query a, Query b) {  
        return a.x != b.x ? a.x < b.x : a.id < b.id;  
    });  

    for (auto &t : q) {  
        if (t.id == 0) add(getY(t.y), t.mul);  
        else ans[t.id] += t.mul * ask(getY(t.y));  
    }  

    for (int i=1; i<=m; i++) printf("%lld\n", ans[i]);  
    return 0;  
}  
```  

---

**注**：以上代码为离线树状数组的简化实现，完整版本需处理离散化细节与查询拆分。

---
处理用时：93.16秒
# 题目信息

# 总统选举

## 题目背景

黑恶势力的反攻计划被小 C 成功摧毁，黑恶势力只好投降。秋之国的人民解放了，举国欢庆。此时，原秋之国总统因没能守护好国土，申请辞职，并请秋之国人民的大救星小 C 钦定下一任。

作为一名民主人士，小 C 决定举行全民大选来决定下一任。为了使最后成为总统的人得到绝大多数人认同，小 C 认为，一个人必须获得超过全部人总数的一半的票数才能成为总统。如果不存在符合条件的候选人，小 C 只好自己来当临时大总统。为了尽可能避免这种情况，小 C 决定先进行几次小规模预选，根据预选的情况，选民可以重新决定自己选票的去向。

由于秋之国人数较多，统计投票结果和选票变更也成为了麻烦的事情，小 C 找到了你，让你帮他解决这个问题。

## 题目描述

秋之国共有 $n$ 个人，分别编号为 $1,2,…,n$，一开始每个人都投了一票，范围 $1 \sim n$，表示支持对应编号的人当总统。

共有 $m$ 次预选，每次选取编号 $[l_i,r_i]$ 内的选民展开小规模预选，在该区间内获得超过区间大小一半的票的人获胜。如果没有人获胜，则由小 C 钦定一位候选者获得此次预选的胜利（获胜者可以不在该区间内），每次预选的结果需要公布出来，并且每次会有 $k_i$ 个人决定将票改投向该次预选的获胜者。

全部预选结束后，公布最后成为总统的候选人。

## 说明/提示

对于前 $20 \%$ 的数据，$1 \leq n,m \leq 5000$。

对于前 $40 \%$ 的数据，$1 \leq n,m \leq 50000$，$\sum k_i \leq 50000$。

对于前 $50 \%$ 的数据，$1 \leq n,m \leq {10}^5$，$\sum k_i \leq 2 \times {10}^5$。

对于数据点 6~7，保证所有选票始终在 $1 \sim 10$ 之间。

对于 $100 \%$ 的数据，$1 \leq n,m \leq 5 \times {10}^5$，$\sum k_i \leq 10^6$，$1 \leq l_i \leq r_i \leq n$，$1 \leq s_i \leq n$。

## 样例 #1

### 输入

```
5 4
1 2 3 4 5
1 2 1 1 3
5 5 1 2 2 4
2 4 2 0
3 4 2 1 4```

### 输出

```
1
5
5
2
-1```

# AI分析结果



# 总统选举题解分析

## 算法分类
**摩尔投票法 + 线段树与平衡树验证**

---

## 题解思路与难点对比

### 核心算法要点
1. **摩尔投票法**  
   - 任意区间若存在绝对众数（出现次数 > 半数），其必定能通过摩尔投票法筛选出来  
   - 线段树维护每个区间的候选众数及抵消次数，合并时根据子区间的结果进行抵消计算  
   - **合并规则**：  
     - 左右子区间候选相同 → 次数相加  
     - 候选不同 → 保留次数大的候选，抵消差值  

2. **平衡树验证**  
   - 对每个候选人维护平衡树（存储支持者的位置）  
   - 验证时通过 `order_of_key(r+1) - order_of_key(l)` 计算区间出现次数  

3. **随机化方法**  
   - 在区间随机采样若干次（如30次），若存在绝对众数则大概率被选中  
   - 使用 `pb_ds` 的平衡树快速验证出现次数  

### 解决难点对比
| 方法                | 时间复杂度           | 空间复杂度 | 正确性保证         | 实现难度 |
|---------------------|---------------------|------------|-------------------|----------|
| 摩尔投票+平衡树      | O(m log n)          | O(n log n) | 确定性正确         | 高       |
| 随机化+平衡树        | O(mk + ∑k_i log n) | O(n)       | 概率性正确（1/2^k）| 低       |
| 分块+平衡树          | O(m√(n log n))     | O(n)       | 确定性正确         | 中       |

---

## 题解评分（≥4星）

### 1. Ynoi（随机化）⭐⭐⭐⭐⭐
- **亮点**：代码极简，利用 `pb_ds` 实现平衡树，随机采样显著降低时间复杂度  
- **核心代码**：
  ```cpp
  int solve(int l,int r) {
    int n = r-l+1;
    for(int i=1; i<=14; i++) { // 随机采样14次
      int x = rand()%n + l;
      if(qwq(a[x],l,r) > n/2) return a[x];
    }
    return -1;
  }
  ```

### 2. LengChu（摩尔投票+平衡树）⭐⭐⭐⭐
- **亮点**：完整实现摩尔投票的线段树合并逻辑，Splay树验证严谨  
- **关键步骤**：
  ```cpp
  void pushup(int id) { // 线段树合并逻辑
    if(tree[ls].num == tree[rs].num) 
      tree[id].num = tree[ls].num, cnt += ...;
    else 
      tree[id].num = cnt较大者, cnt = 差值;
  }
  ```

### 3. kczno1（线段树维护）⭐⭐⭐⭐
- **优化点**：直接复用线段树的 `mx` 字段存储候选，减少查询次数  
- **验证逻辑**：
  ```cpp
  int Count(int x,int l,int r) { 
    return tr[x].order_of_key(r+1) - tr[x].order_of_key(l);
  }
  ```

---

## 最优思路提炼
1. **摩尔投票法的区间可加性**  
   线段树节点合并时通过抵消机制保留潜在众数，确保查询结果为唯一可能解。

2. **平衡树快速验证**  
   每个候选人的支持者位置有序存储，通过 `order_of_key` 实现 O(log n) 次比较的区间计数。

3. **随机化采样优化**  
   在保证正确率的前提下（如采样30次错误率 < 1e-9），大幅减少计算量。

---

## 类似题目推荐
1. [P2397 - yyy loves Maths VI (mode)](https://www.luogu.com.cn/problem/P2397)  
   **摩尔投票法模板题**，静态区间求绝对众数

2. [P3567 - [POI2014]KUR-Couriers](https://www.luogu.com.cn/problem/P3567)  
   **强制在线区间众数**，需结合主席树

3. [P4137 - Rmq Problem / mex](https://www.luogu.com.cn/problem/P4137)  
   **区间特性查询**，分块与莫队思想

---

## 算法可视化设计
### 核心动画演示（摩尔投票法）
1. **线段树节点合并过程**  
   - 初始状态：左右子节点分别显示候选和计数（如 `(A,3)` 和 `(B,2)`）  
   - 合并动画：显示 `B` 的计数被抵消，最终父节点变为 `(A,1)`  
   - **颜色标记**：  
     - 红色：当前正在合并的节点  
     - 绿色：保留的候选，黄色：被抵消的候选  

2. **平衡树验证步骤**  
   - 高亮查询区间 `[l, r]` 在平衡树中的上下界  
   - 动态显示 `upper_bound(r)` 和 `lower_bound(l)` 的位置  
   - 计数器实时显示 `count = right_pos - left_pos`

### 复古像素风格实现
- **Canvas 绘制**：  
  - 线段树节点用 16x16 像素块表示，候选数字用 8x8 字体  
  - 平衡树以旋转的二叉树形式展示，节点展开时有扩散粒子效果  
- **音效设计**：  
  - 合并成功：短促的「滴」声（8-bit 上升音阶）  
  - 验证通过：长「嘟」声（类似 FC 过关音效）  
- **自动演示模式**：  
  - 按空格键逐步执行，按 `A` 键自动播放（速度可调）

---

## 关键代码片段（Ynoi 随机化法）
```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
using namespace std;
using namespace __gnu_pbds;

tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> s[N];
int a[N], n, m;

int query(int l, int r) {
    for(int i=1; i<=30; i++) { // 随机采样30次
        int pos = l + rand()%(r-l+1);
        int cand = a[pos];
        int cnt = s[cand].order_of_key(r+1) - s[cand].order_of_key(l);
        if(cnt > (r-l+1)/2) return cand;
    }
    return -1;
}

void update(int p, int new_val) {
    s[a[p]].erase(p);
    a[p] = new_val;
    s[new_val].insert(p);
}
```

---

## 总结
- **确定性方法**（摩尔投票+平衡树）适合对正确性要求高的场景  
- **随机化方法**在时间和代码简洁性上占优，适合大规模数据  
- 可视化重点在于展示摩尔投票的合并过程与平衡树的区间查询机制

---
处理用时：75.99秒
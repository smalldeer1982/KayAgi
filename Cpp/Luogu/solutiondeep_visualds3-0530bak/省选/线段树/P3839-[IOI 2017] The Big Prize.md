# 题目信息

# [IOI 2017] The Big Prize

## 题目背景

这里是洛谷。如果有疑问，可以发帖求助。

如果你习惯于写函数式交互，以下内容可能对你有帮助：

```cpp
vector<int>ask(int i)
{
	printf("? %d\n",i);fflush(stdout);
	vector<int>ret(2);
	scanf("%d%d",&ret[0],&ret[1]);
	return ret;
}
int find_best(int n)
{
	//
}
main()
{
	int n;scanf("%d",&n);
	printf("! %d\n",find_best(n));
}
```

无论如何，你都不应引入额外的头文件。

## 题目描述

“大奖”是一个家喻户晓的 TV 游戏节目。这次你很幸运地进入到最后一轮。已知编号从 $0$ 到 $n-1$ 的 $n$ 个盒子从左到右排成一行，你就站在这排盒子的前面。每个盒子里面放有一个奖品，必须打开盒子才能看到是什么奖品。已知有 $v\leq5$ 种不同类型的奖品。这 $v$ 种类型按照奖品价值的降序从 $1$ 到 $v$ 排列。

类型 $1$ 的奖品是一块钻石，价值最高。所有盒子加起来刚好只有一块钻石。类型 $v$ 的奖品是一块棒棒糖，价值最低。为使得游戏更加激动人心，相对便宜的奖品数量远比价值昂贵的奖品数量要多。更具体一点，对于满足 $2\leq t \leq v$ 的所有 $t$，我们有： 如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。

你的目标是赢得那块钻石。在游戏结束时，你必须打开一个盒子并收取盒子内的奖品。在选择要打开的盒子之前，你可以向节目主持人 Rambod 提一些问题。在每一个问题中，你选择就某个 $i$ 号盒子进行提问。Rambod 将给你一个包含两个整数的数组 $a$ 作为回答。这两个整数的意义如下：

- 在 $i$ 号盒子左面的盒子中，刚好有 $a[0]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。
- 在 $i$ 号盒子右面的盒子中，刚好有 $a[1]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。

例如，假设 $n=8$，在你的问题中，你选择就 $i=2$ 号盒子进行提问。Rambod 的回答是 $a=[1,2]$。这个回答的意义是：

- $0$ 号盒子和 $1$ 号盒子中恰好有一个盒子中的奖品比 $i$ 号盒子中的奖品更贵。
- 在 $3,4,\cdots,7$ 号盒子中恰好有 $2$ 个盒子中的奖品比 $2$ 号盒子中的奖品更贵。

你的任务就是通过问少量的问题找出包含钻石的盒子。

## 说明/提示

### 样例解释

```plain
8
3 2 3 1 3 3 2 3
```

![](https://cdn.luogu.com.cn/upload/pic/6728.png)

上图阐释了这个例子。图中上半部分给出了每个盒子中奖品的类型。图中的下半部分阐释了询问 `? 2`。

### 限制

- $3\leq n \leq200000$.
- 每个盒子中奖品的类型介于 $1$ 和 $v$ 之间（含）。
- 类型 $1$ 的奖品恰有一个。
- 对于所有 $2\leq t \leq v$，如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。


### 子任务与评分

1.  （$20$ 分）恰好有 $1$ 个钻石和 $n-1$ 个棒棒糖 （所以，$v=2$）。你可以询问最多 $10000$ 次。
2.  （$80$ 分）没有附加限制。


在子任务 2 中你可以获得部分分。令 $q$ 是在这个子任务的所有测试数据上发起询问的最大次数，那么你在这个子任务上的得分将按照下表计算：

![](https://cdn.luogu.com.cn/upload/pic/6729.png)

## 样例 #1

### 输入

```
8

0 3

0 1

1 2

0 0

2 1

2 1

1 0

3 0```

### 输出

```

? 0

? 1

? 2

? 3

? 4

? 5

? 6

? 7

! 3```

# AI分析结果



---

### **唯一算法分类**  
**分治算法与剪枝优化**

---

### **综合分析与结论**  
题目核心是通过有限次数的交互式查询定位唯一钻石盒。关键难点在于如何利用奖品类型的指数级数量分布特性（类型 t 的数量 > 类型 t-1 的平方），结合分治策略与剪枝优化，快速排除无关区间。

**核心算法流程**：  
1. **分块初始化**：将整个盒子序列划分为多个块（如每块 293 个），随机化块顺序以减少最坏情况。  
2. **递归分治**：对每个块的左右端点进行查询，若端点类型相同（通过询问结果的和 `x+y` 判断），则中间区域可能无更高类型奖品，直接剪枝；否则递归处理子区间。  
3. **动态剪枝**：通过记录已查询的盒子类型和位置，结合类型分布特性，跳过不可能包含钻石的区间。

**可视化设计思路**：  
- **分块展示**：用不同颜色标记各个分块，高亮当前处理的块。  
- **递归过程**：以树状图展示分治步骤，动态展开子节点表示递归进入子区间。  
- **剪枝提示**：当检测到端点类型相同时，用红色叉号标记该区间，并显示“剪枝”动画。  
- **复古像素风格**：用 8 位像素风绘制盒子序列，每次查询时播放“滴”声，剪枝时播放“咔嚓”音效。

---

### **题解评分 (≥4星)**  
1. **phigy 题解（4.5★）**  
   - **亮点**：分块+随机化策略有效减少最坏情况查询次数，代码逻辑简洁。  
   - **不足**：分块大小固定，未动态调整。  
2. **Aiopr_2378 题解（4.0★）**  
   - **亮点**：利用递归分治和剪枝条件，代码中通过 `set` 记录查询结果，逻辑严谨。  
   - **不足**：递归条件判断较复杂，可读性稍差。

---

### **最优思路与技巧提炼**  
1. **类型和剪枝**：利用 `x_i + y_i` 的和判断类型，相同类型端点间无需深入查询。  
2. **分块随机化**：降低最坏情况概率，避免对手构造极端数据。  
3. **递归剪枝**：通过递归分治动态排除无关区间，时间复杂度接近 `O(√n log n)`。

---

### **同类型题与算法套路**  
- **交互式分治**：如 IOI 2019 “排列鞋子”，需结合分治与交互反馈。  
- **指数分布剪枝**：类似“寻找众数”问题，利用数据分布特性快速缩小范围。

---

### **推荐相似题目**  
1. **P1972 [SDOI2009] HH的项链**（分块与剪枝）  
2. **P3834 可持久化线段树 1**（区间分治与递归查询）  
3. **P1527 [国家集训队] 矩阵乘法**（分治+二分答案）

---

### **个人心得摘录**  
- **phigy**：随机化分块顺序是突破查询次数限制的关键，避免被固定分块策略卡死。  
- **Aiopr_2378**：调试中发现 `set` 必须记录所有查询过的点，否则剪枝条件可能失效。

---

### **代码核心实现**  
**phigy 的分块与递归代码片段**：  
```cpp
void solve(int L, int R) {
    ask(L); ask(R);
    if (R - L == 1) return;
    if (a[L] == a[R]) return; // 剪枝条件
    int mid = (L + R) >> 1;
    solve(L, mid); solve(mid, R);
}
// 主函数中的分块与随机化处理
vector<int> tmp;
for (i = 0; i*B < n; i++) {
    tmp.push_back(i);
    ask(i*B); ask(min(n-1, (i+1)*B));
}
random_shuffle(tmp.begin(), tmp.end());
```

---

### **可视化与游戏化设计**  
**复古像素风格算法演示**：  
1. **Canvas 绘制**：盒子序列以 16x16 像素方块表示，当前查询的盒子闪烁高亮。  
2. **音效触发**：  
   - **查询**：播放 8-bit “哔”声（Web Audio API 生成 500Hz 方波）。  
   - **剪枝**：播放“咔嚓”声（白噪声短脉冲）。  
3. **自动演示模式**：AI 自动选择分块和递归路径，用户可暂停观察当前状态。  
4. **积分系统**：每成功剪枝一个区间得 10 分，剩余未查询盒子数越少得分越高。

**动画关键帧示例**：  
- **Step 1**：初始分块，随机打乱顺序，绿色边框标记当前块。  
- **Step 2**：递归进入子块，黄色箭头指示分治方向。  
- **Step 3**：检测到端点类型相同，红色叉号标记剪枝，累计积分上升。  

---

**总结**：通过分治与剪枝优化，结合交互式查询特性，将高类型奖品数量指数分布的优势转化为算法效率提升的关键，最终在约 5000 次查询内定位钻石。

---
处理用时：65.13秒
# 题目信息

# [NOIP 2017 提高组] 列队

## 题目背景

NOIP2017 D2T3

## 题目描述

`Sylvia` 是一个热爱学习的女孩子。

前段时间，`Sylvia` 参加了学校的军训。众所周知，军训的时候需要站方阵。

Sylvia 所在的方阵中有 $n \times m$ 名学生，方阵的行数为 $n$，列数为 $m$。

为了便于管理，教官在训练开始时，按照从前到后，从左到右的顺序给方阵中 的学生从 $1$ 到 $n \times m$ 编上了号码（参见后面的样例）。即：初始时，第 $i$ 行第 $j$ 列 的学生的编号是 $(i-1)\times m + j$。

然而在练习方阵的时候，经常会有学生因为各种各样的事情需要离队。在一天 中，一共发生了 $q$ 件这样的离队事件。每一次离队事件可以用数对 $(x,y) (1 \le x \le n, 1 \le y \le m)$ 描述，表示第 $x$ 行第 $y$ 列的学生离队。

在有学生离队后，队伍中出现了一个空位。为了队伍的整齐，教官会依次下达 这样的两条指令：


1. 向左看齐。这时第一列保持不动，所有学生向左填补空缺。不难发现在这条 指令之后，空位在第 $x$ 行第 $m$ 列。
2. 向前看齐。这时第一行保持不动，所有学生向前填补空缺。不难发现在这条 指令之后，空位在第 $n$ 行第 $m$ 列。


教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后， 下一个学生才能离队。因此在每一个离队的学生要归队时，队伍中有且仅有第 $n$ 行 第 $m$ 列一个空位，这时这个学生会自然地填补到这个位置。

因为站方阵真的很无聊，所以 `Sylvia` 想要计算每一次离队事件中，离队的同学 的编号是多少。

注意：每一个同学的编号不会随着离队事件的发生而改变，在发生离队事件后 方阵中同学的编号可能是乱序的。


## 说明/提示

【输入输出样例 $1$ 说明】

$$\begin{matrix}
\begin{bmatrix}
1 & 2 \\
3 & 4 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
 & 2 \\
3 & 4 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 &  \\
3 & 4 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix} \\[1em]
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix}\\[1em]
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 &  \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 &  \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 1 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 1 \\
3 & 4 \\
\end{bmatrix}
\end{matrix}$$


列队的过程如上图所示，每一行描述了一个事件。 在第一个事件中，编号为 $1$ 的同学离队，这时空位在第一行第一列。接着所有同学 向左标齐，这时编号为 $2$ 的同学向左移动一步，空位移动到第一行第二列。然后所有同 学向上标齐，这时编号为 $4$ 的同学向上一步，这时空位移动到第二行第二列。最后编号为 $1$ 的同学返回填补到空位中。

【数据规模与约定】

| 测试点编号 | $n$ | $m$ | $q$ | 其他约定 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1\sim 6$ | $\le 10^3$ | $\le 10^3$ | $\le 500$ | 无 |
| $7\sim 10$ | $\le 5\times 10^4$ | $\le 5\times 10^4$ | $\le 500$ | 无 |
| $11\sim 12$ | $=1$ | $\le 10^5$ | $\le 10^5$ | 所有事件 $x=1$ |
| $13\sim 14$ | $=1$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | 所有事件 $x=1$ |
| $15\sim 16$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | 所有事件 $x=1$ |
| $17\sim 18$ | $\le 10^5$ | $\le 10^5$ | $\le 10^5$ | 无 |
| $19\sim 20$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | 无 |

数据保证每一个事件满足 $1 \le x \le n,1 \le y \le m$。


## 样例 #1

### 输入

```
2 2 3 
1 1 
2 2 
1 2 ```

### 输出

```
1
1
4
```

# AI分析结果



### 唯一算法分类  
**动态开点线段树 / 平衡树维护区间操作**

---

### 综合分析与结论  
该题核心难点在于高效处理行列的动态调整，避免直接模拟。各题解采用树状数组、平衡树或动态开点线段树维护行列的删除与插入操作，通过离散化或区间压缩大幅优化时空复杂度。

**关键思路**：  
1. **行列分离**：每行维护前 m-1 个元素，最后一列单独维护。
2. **动态维护区间**：用数据结构表示连续未删除的区间，删除时分裂区间，插入时合并或追加。
3. **编号映射**：通过初始公式计算原始编号，动态维护新增编号的存储。

**可视化设计**：  
- **动画方案**：用 Canvas 绘制每个行和列的线段树节点，动态显示区间分裂（删除时分裂为左右区间）与合并（插入末尾）。  
- **颜色标记**：红色高亮当前操作节点，蓝色标记新增区间，绿色表示未变动区间。  
- **步进控制**：支持单步执行操作，观察每一步如何更新树结构和编号映射。  
- **复古风格**：8-bit 像素风格呈现树节点，删除时播放“破碎”音效，插入时播放“放置”音效。

---

### 题解清单 (≥4星)  
1. **小粉兔（树状数组）★★★★★**  
   - **亮点**：离线预处理 + 树状数组二分，时空效率极高。  
   - **核心**：维护每行的存在标记，通过前缀和快速定位实际位置，动态插入到末尾。  

2. **YoungNeal（FHQ Treap）★★★★☆**  
   - **亮点**：平衡树维护区间，代码简洁高效。  
   - **核心**：节点表示连续区间，动态分裂合并，处理大规模删除/插入。  

3. **luckyqwq（树状数组 + 动态维护）★★★★☆**  
   - **亮点**：清晰的分步解析，结合向量存储新增元素，逻辑直观。  
   - **心得**：调试中发现树状数组初始化错误，强调离线处理的重要性。  

---

### 代码核心实现  
**小粉兔题解（树状数组）关键片段**：  
```cpp
int select(int k) { // 树状数组二分查找第k个存在的位置
    int l=0, r=mx, ans=mx;
    while(l<=r) {
        int mid=(l+r)>>1;
        if(query(mid)>=k) ans=mid, r=mid-1;
        else l=mid+1;
    }
    return ans;
}
void solve() {
    // 预处理每行的有效查询
    for(int i=1; i<=n; ++i) {
        for(auto &q: v[i]) {
            int pos = select(q.y);
            pre[q.id] = pos;
            bit.add(pos, -1); // 标记删除
        }
        // 恢复树状数组状态
    }
    // 处理实际查询
    for(int i=1; i<=q; ++i) {
        int x=qry[i].x, y=qry[i].y;
        if(y == m) {
            // 处理最后一列
        } else {
            // 处理行内和列的交互
        }
    }
}
```

---

### 同类型题推荐  
1. **P3960 列队**（本题，动态维护行列）  
2. **P3157 动态逆序对**（树状数组+分治）  
3. **P3380 二逼平衡树**（线段树套平衡树）  
4. **P3224 永无乡**（平衡树合并）  

---

### 个人心得摘录  
- **调试教训**：初始动态开点线段树未正确初始化多棵树根，导致访问越界（如 `root[n+1]` 未预分配）。  
- **顿悟时刻**：意识到每行只需维护“非原始”元素，原始位置可通过公式直接计算，大幅减少存储。  

---

### 复古游戏化动画设计  
1. **像素风格**：用 16 色绘制线段树节点，每个节点显示区间 [L, R] 和存在的元素个数。  
2. **音效设计**：  
   - **分裂区间**：播放类似“玻璃碎裂”的 8-bit 音效。  
   - **插入末尾**：播放“水滴落下”音效。  
3. **自动演示**：AI 模式按操作顺序自动执行，高亮当前处理的树节点，底部状态栏显示当前操作公式。  
4. **积分系统**：正确完成一个操作+10分，连续无错误操作触发连击奖励。  

```javascript
// 伪代码示例：Canvas绘制线段树节点
function drawNode(x, y, node) {
    ctx.fillStyle = node.highlight ? '#FF0000' : '#00FF00';
    ctx.fillRect(x, y, 80, 30);
    ctx.fillText(`[${node.L},${node.R}]`, x+5, y+20);
}
// 音效触发
function playSFX(name) {
    const sfx = {
        split: new Audio('split.wav'),
        insert: new Audio('insert.wav')
    };
    sfx[name].play();
}
```

--- 

**总结**：通过动态维护区间和高效数据结构，将看似复杂的行列操作转化为对数级别的查询与更新，结合离线处理与空间压缩，实现大规模数据的高效处理。

---
处理用时：69.81秒
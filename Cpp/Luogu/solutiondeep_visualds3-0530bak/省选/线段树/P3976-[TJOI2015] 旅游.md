# 题目信息

# [TJOI2015] 旅游

## 题目描述

为了提高智商，ZJY 准备去往一个新世界去旅游。这个世界的城市布局像一棵树，每两座城市之间只有一条路径可以互达。  

每座城市都有一种宝石,有一定的价格。ZJY 为了赚取最高利益,她会选择从 A 城市买入再转手卖到 B 城市。  

由于ZJY买宝石时经常卖萌，因而凡是 ZJY 路过的城市，这座城市的宝石价格会上涨。让我们来算算 ZJY 旅游完之后能够赚取的最大利润。(如 A 城市宝石价格为 $v$，则ZJY出售价格也为 $v$)


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 100$，$q \le 10^4$。
- 对于 $100\%$ 的数据，保证 $1\le n,q \le 5\times 10^4$，在任何时刻任何城市的宝石价格都不超过 $10^9$。


## 样例 #1

### 输入

```
3
1 2 3
1 2
2 3
2
1 2 100
1 3 100```

### 输出

```
1
1```

## 样例 #2

### 输入

```
5
1 2 3 4 5
1 2
1 3
2 4
4 5
6
1 5 50
2 4 500
3 4 5000
3 5 50000
1 3 500000
2 3 5000000
```

### 输出

```
4
2
551
551
0
499499```

# AI分析结果



# 算法分类
树链剖分 + 线段树

---

## 综合分析与结论

### 核心思路
1. **树链剖分**将树结构转化为线性序列  
2. **线段树维护区间信息**：
   - 最大值、最小值
   - 从左到右的最大差值（lmax）
   - 从右到左的最大差值（rmax）
   - 区间加标记（tag）
3. **合并策略**：
   - 跨区间差值 = 右子最大值 - 左子最小值（lmax）  
   - 跨区间差值 = 左子最大值 - 右子最小值（rmax）
4. **路径合并**：
   - 分别维护起点到LCA、终点到LCA的路径信息
   - 合并时交换左右方向差值（lmax↔rmax）

### 可视化设计
1. **树剖分解动画**：
   - 用不同颜色标记重链
   - 高亮当前处理的路径段
2. **线段树操作演示**：
   - 展示区间合并时的三种情况（左/右/跨区间）  
   - 用颜色区分 lmax（蓝色）和 rmax（红色）
3. **像素化风格**：
   - 树节点用 8x8 像素方块表示
   - 线段树节点用动态色块表示当前更新状态
   - 路径分解时播放经典音效（如《超级玛丽》金币声）

---

## 题解清单（4星及以上）

### 1. MeowScore（⭐⭐⭐⭐⭐）
**亮点**：
- 清晰定义线段树维护的5个属性
- 用结构体封装合并逻辑
- 树剖跳链时维护L/R两个方向信息

**核心代码**：
```cpp
struct ST{
    int maxx, minn, lmax, rmax, tag;
}st[N*4];

void merge(ST &res, ST L, ST R){
    res.maxx = max(L.maxx, R.maxx);
    res.minn = min(L.minn, R.minn);
    res.lmax = max({L.lmax, R.lmax, R.maxx - L.minn});
    res.rmax = max({L.rmax, R.rmax, L.maxx - R.minn});
}
```

### 2. devout（⭐⭐⭐⭐）
**亮点**：
- 采用左右链分离合并策略
- 使用swap处理方向反转
- 代码结构清晰易维护

**思维突破点**：
```cpp
segment_tree merge(segment_tree l, segment_tree r){
    segment_tree res;
    res._max = max(l._max, r._max);
    res.lmax = max(l._max - r._min, max(l.lmax, r.lmax));
    // 关键点：左区间最大值与右区间最小值的组合
}
```

### 3. Dispwnl（⭐⭐⭐⭐）
**亮点**：
- 合并时直接返回结构体
- 使用方向标记优化查询
- 代码高度模块化

**路径处理技巧**：
```cpp
while(top[x] != top[y]){
    if(跳左链) 合并左链信息到L结构体
    else       合并右链信息到R结构体 
}
swap(L.lmax, L.rmax); // 方向反转
ans = max(L.rmax, R.lmax);
```

---

## 核心代码实现

### 线段树合并逻辑
```cpp
void pushUp(int p) {
    t[p].mx = max(t[ls].mx, t[rs].mx);
    t[p].mn = min(t[ls].mn, t[rs].mn);
    t[p].lm = max({t[ls].lm, t[rs].lm, t[rs].mx - t[ls].mn});
    t[p].rm = max({t[ls].rm, t[rs].rm, t[ls].mx - t[rs].mn});
}

Node queryPath(int u, int v) {
    Node L, R;
    while(top[u] != top[v]) {
        if(深度判断) {
            tmp = queryChain();
            merge(R, tmp, R); 
        } else {
            tmp = queryChain();
            merge(L, tmp, L);
        }
    }
    // 合并最终段
    swap(L.lm, L.rm);
    return merge(L, R);
}
```

---

## 相似题目推荐
1. [P2486 染色](https://www.luogu.com.cn/problem/P2486)  
   （区间颜色段维护）
2. [SP6779 GSS7](https://www.luogu.com.cn/problem/SP6779)  
   （树链最大子段和）
3. [P4114 Qtree1](https://www.luogu.com.cn/problem/P4114)  
   （边权转点权处理）

---

## 可视化实现要点

### 像素动画设计
1. **树结构展示**：
   ```javascript
   function drawTree(node, x, y) {
       ctx.fillStyle = node.active ? "#FF5555" : "#55AAFF";
       ctx.fillRect(x, y, 8, 8); 
       // 绘制子节点连线...
   }
   ```
2. **线段树操作**：
   ```javascript
   function updateAnimation(node) {
       node.element.style.background = "#FFDD00";
       setTimeout(() => node.element.style.background = "", 300);
       playSound("blip.mp3"); // 8-bit音效
   }
   ```

### 交互功能
1. **步进控制**：
   ```javascript
   document.getElementById("step").onclick = () => {
       pause = true;
       nextStep();
   }
   ```
2. **自动演示模式**：
   ```javascript
   function autoRun() {
       if(!pause) {
           nextStep();
           setTimeout(autoRun, speed);
       }
   }
   ```

---

## 总结
本题解通过树链剖分将树结构转化为线性问题，利用线段树维护方向性差值信息。关键点在于正确处理路径分段合并时的方向反转问题。推荐实现时优先参考MeowScore的封装式写法，结合Dispwnl的路径合并策略，可兼顾代码清晰度与执行效率。

---
处理用时：70.93秒
# 题目信息

# 遥远的国度

## 题目描述

`zcwwzdjn` 在追杀 `zhx` ，而 `zhx` 逃入了一个遥远的国度。当 `zcwwzdjn` 准备进入遥远的国度继续追杀时，守护神 `RapiD` 阻拦了 `zcwwzdjn` 的去路，他需要 `zcwwzdjn` 完成任务后才能进入遥远的国度继续追杀。

问题是这样的：遥远的国度有 $n$ 个城市，这些城市之间由一些路连接且这些城市构成了一颗树。这个国度有一个首都，我们可以把这个首都看做整棵树的根，但遥远的国度比较奇怪，首都是随时有可能变为另外一个城市的。遥远的国度的每个城市有一个防御值，第 $i$ 个的防御值为 $val_i$，有些时候 `RapiD` 会使得某两个城市之间的路径上的所有城市的防御值都变为某个值。

`RapiD` 想知道在某个时候，如果把首都看做整棵树的根的话，那么以某个城市为根的子树的所有城市的防御值最小是多少。

由于 `RapiD` 无法解决这个问题，所以他拦住了 `zcwwzdjn` 希望他能帮忙。但 `zcwwzdjn` 还要追杀 `zhx`，所以这个重大的问题就被转交到了你的手上。

## 说明/提示

对于 $20\%$ 的数据，$n\le 1000,m\le 1000$。

对于另外 $10\%$ 的数据，$n\le 100000,m\le 100000$，保证修改为单点修改。

对于另外 $10\%$ 的数据，$n\le100000,m \le 100000$，保证树为一条链。

对于另外 $10\%$ 的数据，$n\le 100000,m\le100000$，没有修改首都的操作。

对于 $100\%$ 的数据，$1 \leq n\le 100000,1 \leq m \le 100000,0<val_i<2^{31}$。

## 样例 #1

### 输入

```
3 7
1 2
1 3
1 2 3
1
3 1
2 1 1 6
3 1
2 2 2 5
3 1
2 3 3 4
3 1```

### 输出

```
1
2
3
4```

# AI分析结果



**唯一算法分类**：树链剖分（换根分类讨论）

---

### **综合分析与结论**

**核心难点与解决思路**：  
换根操作导致子树形态动态变化，难以直接维护。通过树链剖分的DFS序连续性，将换根后的子树查询转化为原树剖分下的区间查询，利用分类讨论处理不同情况：

1. **查询点为当前根**：直接返回全局最小值。  
2. **查询点与根无祖先关系**：按原树子树查询。  
3. **查询点是根的祖先**：找到根所在分支的子树区间，查询剩余区间的最小值。

**可视化设计思路**：  
- **动画方案**：用不同颜色区分原树和换根后的子树范围，高亮当前查询区间。  
- **DFS序网格**：展示DFS序区间变化，在第三种情况时用红色划掉被排除的子树区间。  
- **交互控制**：允许用户拖动根节点，实时更新查询区间并触发线段树查询动画。

---

### **题解清单（≥4星）**

1. **寒酥（⭐️⭐️⭐️⭐️⭐️）**  
   - **亮点**：清晰的分类讨论逻辑，利用树剖特性快速定位分支子树。  
   - **关键代码**：`find()`函数通过跳链快速定位分支节点。

2. **Farkas_W（⭐️⭐️⭐️⭐️⭐️）**  
   - **亮点**：图文结合详细说明分类情况，提供虚子树维护思路。  
   - **引用**："发现此时x的真正子树是包括除了root方向上的子树之外其他所有节点"。

3. **Drifterming（⭐️⭐️⭐️⭐️）**  
   - **亮点**：利用倍增快速定位分支节点，代码可读性高。  
   - **调试心得**："一开始inf设置过小导致WA，改为1e11后解决"。

---

### **最优思路与代码实现**

**核心代码片段**（寒酥题解）：
```cpp
int find(int u) {
    if(u == rt) return -1;
    int now = rt;
    while(top[now] != top[u]) {
        if(fa[top[now]] == u) return top[now];
        now = fa[top[now]];
    }
    return son[u]; //在同一条重链上时返回重儿子
}

int query(int x) {
    if(x == rt) return minn[1];
    int bo = find(x);
    if(!bo) return query_segment(id[x], id[x]+sz[x]-1);
    else {
        int ans = query_segment(1, id[bo]-1);
        if(id[bo]+sz[bo] <= n) 
            ans = min(ans, query_segment(id[bo]+sz[bo], n));
        return ans;
    }
}
```

**实现思想**：  
1. `find()`通过跳链找到x到rt路径上的分支节点。  
2. 查询时排除分支节点的子树区间，合并剩余区间的最小值。

---

### **同类型题与拓展**

**相似算法套路**：  
- 动态树结构维护（LCT/树剖+分类讨论）  
- 子树形态变化的区间转化（如CF916E）

**推荐题目**：  
1. P3384 【模板】树链剖分（基础树剖）  
2. CF916E Jamie and Tree（换根+子树操作）  
3. P2146 [NOI2015] 软件包管理器（路径与子树标记）

---

### **可视化与复古动画设计**

**Canvas动画设计**：  
1. **树结构绘制**：用绿色线条表示重链，蓝色为轻边。  
2. **换根高亮**：拖动根节点时，用红色虚线标记路径分支。  
3. **DFS序网格**：在右侧显示DFS序区间，被排除的子树用灰色覆盖。  

**音效与交互**：  
- **路径跳转**：跳链时播放"哔"声，线段树查询时触发"滴"声。  
- **自动演示**：点击"换根"按钮，AI自动执行分类逻辑，用箭头指示当前判断条件。

**复古风格**：  
- 8位像素字体显示DFS序和查询结果。  
- 背景音乐使用FC风格的循环芯片音乐。

---

**总结**：树链剖分结合分类讨论是解决动态换根问题的核心思路，通过DFS序的区间特性将子树查询转化为线段树操作。可视化重点在于动态展示区间排除逻辑与路径跳转过程。

---
处理用时：62.24秒
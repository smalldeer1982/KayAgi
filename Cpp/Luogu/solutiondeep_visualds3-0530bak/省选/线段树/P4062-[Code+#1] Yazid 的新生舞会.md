# 题目信息

# [Code+#1] Yazid 的新生舞会

## 题目背景

这道题是没有舞伴的 Yazid 用新生舞会的时间出的。


## 题目描述

Yazid 有一个长度为 $n$ 的序列 $A$，下标从 $1$ 至 $n$。显然地，这个序列共有 $\frac{n\left( n+1\right)}{2}$ 个子区间。

对于任意一个子区间 $[l,r]$，如果该子区间内的众数在该子区间的出现次数严格大于 $\frac{r-l+1}{2}$（即该子区间长度的一半），那么 Yazid 就说这个子区间是“新生舞会的”。

所谓众数，即为该子区间内出现次数最多的数。特别地，如果出现次数最多的数有多个，我们规定值最小的数为众数。

现在，Yazid 想知道，共有多少个子区间是“新生舞会的”。


## 说明/提示

**【样例解释 #1】**

“新生舞会的”子区间有 $[1,1],[1,2],[1,3],[2,2],[2,4],[3,3],[3,4],[3,5],[4,4],[5,5]$ 共 $10$ 个。

 ![](https://cdn.luogu.com.cn/upload/pic/12825.png) 

对于所有数据，保证 $0\leq A_i\leq n-1$。

对于 $type=0$ 的数据，没有任何特殊约定。

对于 $type=1$ 的数据，保证 $A_i\in \{ 0, 1 \}$。

对于 $type=2$ 的数据，保证序列 $A$ 的众数在整个序列中的出现次数不超过 $15$。

对于 $type=3$ 的数据，保证 $A_i\leq 7$。

来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/郑林楷 命题/王聿中 验题/郑林楷

Git Repo：https://git.thusaac.org/publish/CodePlus201711

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
5 0
1 1 2 2 3```

### 输出

```
10```

# AI分析结果



**唯一算法分类**：分治与数据结构（树状数组/线段树维护高阶前缀和）

---

### **综合分析与结论**

**核心思路**  
题目要求统计所有区间众数出现次数超过半数的子区间。通过将每个数独立处理，转换为前缀和问题，利用等差数列性质批量处理区间，使用树状数组维护三阶前缀和实现高效查询。

**解决难点**  
1. **绝对众数性质**：每个合法区间唯一绝对众数，允许分治处理每个数值的贡献。  
2. **等差数列优化**：将连续非众数区间的贡献视为公差为-1的等差数列，批量计算区间贡献。  
3. **高阶前缀和**：通过树状数组维护三阶前缀和，实现区间加减与快速查询。

**可视化设计**  
- **动画步骤**：  
  1. **数值转换**：将当前处理的数标记为绿色（+1），其余红色（-1）。  
  2. **前缀和曲线**：绘制前缀和折线图，高亮当前处理的等差数列区间。  
  3. **树状数组操作**：动态显示区间加操作，不同颜色区分c1、c2、c3数组的更新。  
  4. **贡献计算**：用不同颜色标记查询范围，实时显示计算结果累加过程。  
- **复古像素风格**：采用8-bit像素字体，前缀和变化用方格升降表示，音效配合数值切换与查询完成。

---

### **题解清单 (≥4星)**

1. **OMG_wc (5星)**  
   - **亮点**：树状数组三阶前缀和实现，代码简洁高效，推导清晰。  
   - **关键代码**：维护三个树状数组处理差分项的系数，偏移量处理负数。

2. **Alex_Wei (5星)**  
   - **亮点**：线性做法利用观察众数出现次数性质，优化查询逻辑。  
   - **技巧**：指针移动距离总和为O(n)，避免重复计算。

3. **shadowice1984 (4星)**  
   - **亮点**：线段树维护等差数列区间加，详细推导二阶前缀和贡献。  
   - **可视化**：适合展示线段树区间标记下传过程。

---

### **核心代码实现**

**树状数组三阶前缀和实现**  
```cpp
typedef long long LL;
const int N = 500005;
LL c1[N * 2], c2[N * 2], c3[N * 2];

void add(int x, LL d, int n) {
    for (int i = x; i <= n; i += i & -i) {
        c1[i] += d;
        c2[i] += d * x;
        c3[i] += d * x * x;
    }
}

LL sum(int x) {
    LL res = 0;
    for (int i = x; i > 0; i -= i & -i) {
        res += c1[i] * (x + 2) * (x + 1) 
             - c2[i] * (2 * x + 3) 
             + c3[i];
    }
    return res / 2;
}

// 处理等差数列区间[l,r]
void process(int x, int y, int wc) {
    add(x, 1, 2 * wc + 1);
    add(y + 1, -1, 2 * wc + 1);
    ans += sum(y - 1) - (x >= 3 ? sum(x - 2) : 0);
}
```

---

### **同类型题目推荐**

1. **P1972 [SDOI2009] HH的项链**  
   （统计区间不同数字，树状数组离线处理）

2. **P1908 逆序对**  
   （树状数组求逆序对，前缀和思想）

3. **P5490 扫描线**  
   （线段树处理矩形覆盖，区间操作与查询）

---

### **可视化与复古动画**

**像素风格演示**  
- **Canvas网格**：横向表示数组索引，纵向表示前缀和值，绿色方块表示+1，红色-1。  
- **音效设计**：  
  - 方块移动：8-bit "blip" 音效  
  - 贡献计算：成功时播放上升音阶  
- **自动演示**：按数值顺序播放处理流程，速度可调，高亮当前操作区间。

**交互控制**  
```javascript
// 伪代码示例
class Viz {
  constructor(data) {
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.currentNum = 0;
    this.speed = 500; // ms per step
  }

  drawStep() {
    // 绘制当前数值处理的前缀和曲线与树状数组状态
    drawGrid();
    drawBars(currentPrefixSums);
    highlightTreeUpdate();
  }

  playSound(effect) {
    // 使用Web Audio API播放8-bit音效
  }
}
```

---

**总结**：本题通过巧妙的数学转换与高效数据结构应用，将复杂问题转化为可批量处理的模式。树状数组维护高阶前缀和是核心技巧，适合作为分治与数据结构结合的经典例题。

---
处理用时：78.66秒
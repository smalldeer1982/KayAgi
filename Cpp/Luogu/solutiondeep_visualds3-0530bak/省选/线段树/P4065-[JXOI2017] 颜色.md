# 题目信息

# [JXOI2017] 颜色

## 题目描述

可怜有一个长度为 $n$ 的正整数序列 $A_i$，其中相同的正整数代表着相同的颜色。

现在可怜觉得这个序列太长了，于是她决定选择一些颜色把这些颜色的所有位置都删去。

删除颜色 $i$ 可以定义为把所有满足 $A_j = i$ 的位置 $j$ 都从序列中删去。

然而有些时候删去之后，整个序列变成了好几段，可怜不喜欢这样，于是她想要知道有多少种删去颜色的方案使得最后剩下来的序列非空且连续。

例如颜色序列 $\{1, 2, 3, 4, 5\}$，删除颜色 $3$ 后序列变成了 $\{1, 2\}$ 和 $\{4, 5\}$ 两段，不满足条件。而删除颜色 $1$ 后序列变成了 $\{2, 3, 4, 5\}$，满足条件。

两个方案不同当且仅当至少存在一个颜色 $i$ 只在其中一个方案中被删去。


## 说明/提示

满足条件的删颜色方案有 $\{1\}, \{1, 3\}, \{1, 2, 3\}, \{1, 3, 4\}, \{2, 3, 4\}, \varnothing$。

对于 $20\%$ 的数据，保证 $1 \le \sum n \le  20$。

对于 $40\%$ 的数据，保证 $1 \le \sum n \le  500$。

对于 $60\%$ 的数据，保证 $1 \le \sum n \le  10^4$。

对于 $100\%$ 的数据，保证 $1 \le  T,\sum n \le  3 \times 10^5, 1 \le  A_i \le  n$。

$\text{Statement fixed by @Starrykiller.}$

## 样例 #1

### 输入

```
1
5
1 3 2 4 3```

### 输出

```
6```

# AI分析结果



## 算法分类
**哈希（随机化）**

## 题解思路、算法要点与解决难点
### 核心思路
将合法区间转化为哈希值之和为0的问题，通过随机赋权值使同一颜色所有位置权值和为0。统计前缀和相等的次数即为合法区间数量。

### 算法要点
1. **随机赋权**：给每个颜色出现的位置分配随机值（最后一个位置为前几个的负数/异或和），保证同颜色权值和为0。
2. 前缀和统计：维护前缀和哈希表，每次累加当前权值后查询历史相同前缀和的次数。
3. 错误率控制：通过大范围随机值降低哈希碰撞概率。

### 解决难点
- **合法区间特征**：合法区间内的颜色必须完全包含在区间内。通过权值设计使得这些区间的哈希和为0。
- **高效统计**：用哈希表统计前缀和，时间复杂度从暴力O(n²)优化至O(n)。

---

## 题解评分（≥4星）
### Iscream2001（5星）
- **思路**：巧妙哈希转化，代码简洁高效。
- **亮点**：随机数+前缀和，错误率极低。
- 代码清晰，可读性强。

### Ebola（4.5星）
- **思路**：异或版本哈希，数学证明增强可信度。
- **亮点**：详细分析错误率，代码简洁。

### shadowice1984（4星）
- **思路**：线段树+栈维护合法区间。
- **亮点**：传统数据结构解法，逻辑直观。

---

## 最优思路与技巧
### 关键技巧
1. **权值设计**：确保同颜色权值和为0，将区间合法性转化为哈希和为0。
2. **前缀和哈希表**：O(1)查询历史相同前缀和次数，快速统计合法区间。

### 适用场景
统计满足特定哈希条件的子数组数目（如和为k、异或为0等）。

---

## 类似题目
1. **P1469 找筷子**：异或性质应用。
2. **P3401 洛谷树**：树路径异或和统计。
3. **P3131 子数组异或和**：前缀异或和哈希。

---

## 可视化与算法演示
### 核心动画设计
1. **颜色标记**：不同颜色方块表示不同权值，合法区间以闪烁边框高亮。
2. **前缀和展示**：实时显示当前前缀和，哈希表中相同值以连线标记。
3. **步进控制**：可调节速度观察权值分配、前缀和更新过程。

### 复古游戏化实现（JS伪代码）
```javascript
// 初始化Canvas
const canvas = document.getElementById("pixel-canvas");
const ctx = canvas.getContext("2d");
const colors = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEEAD"];

// 绘制像素方块
function drawBlock(x, val, isHighlight) {
    ctx.fillStyle = isHighlight ? "#FF0000" : colors[val % 5];
    ctx.fillRect(x * 20, 0, 18, 18);
}

// 播放音效
function playBeep() {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = 440 + Math.random() * 100;
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}

// 动画循环
function animate() {
    if (currentStep >= n) return;
    updatePrefixSum();
    drawBlock(currentStep, prefixSum);
    if (hashMap.has(prefixSum)) playBeep();
    requestAnimationFrame(animate);
}
```

---

## 核心代码（哈希版本）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=3e5+10;
map<LL,LL> cnt;
vector<int> pos[N];
LL val[N], sum;

int main() {
    srand(time(0));
    int T; scanf("%d", &T);
    while(T--) {
        int n; scanf("%d", &n);
        for(int i=1; i<=n; i++) {
            int x; scanf("%d", &x);
            pos[x].push_back(i);
        }
        
        for(int c=1; c<=n; c++) {
            if(pos[c].empty()) continue;
            LL s=0;
            for(int i=0; i<pos[c].size()-1; i++) {
                val[pos[c][i]] = rand();
                s += val[pos[c][i]];
            }
            val[pos[c].back()] = -s;
        }
        
        LL ans=0; sum=0;
        cnt.clear(); cnt[0]=1;
        for(int i=1; i<=n; i++) {
            sum += val[i];
            ans += cnt[sum];
            cnt[sum]++;
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```

---

## 总结
哈希方法通过巧妙的权值设计将问题转化为前缀和统计，在保证正确性的前提下达到最优时间复杂度。线段树解法则更适合理解区间约束条件。随机化哈希以其简洁高效成为本题最优解法。

---
处理用时：71.35秒
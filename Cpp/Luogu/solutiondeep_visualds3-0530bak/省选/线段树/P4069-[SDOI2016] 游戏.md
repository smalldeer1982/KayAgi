# 题目信息

# [SDOI2016] 游戏

## 题目描述

Alice 和 Bob 在玩一个游戏。

游戏在一棵有 $n$ 个点的树上进行。最初，每个点上都只有一个数字，那个数字是 $123456789123456789$。

有时，Alice 会选择一条从 $s$ 到 $t$ 的路径，在这条路径上的每一个点上都添加一个数字。对于路径上的一个点 $r$，若 $r$ 与 $s$ 的距离是 $dis$，那么 Alice 在点 $r$ 上添加的数字是 $a\times dis+b$。

有时，Bob 会选择一条从 $s$ 到 $t$ 的路径。他需要先从这条路径上选择一个点，再从那个点上选择一个数字。

Bob 选择的数字越小越好，但大量的数字让 Bob 眼花缭乱。Bob 需要你帮他找出他能够选择的最小的数字。


## 说明/提示

测试点 1 ~ 2：$ n \leq 10 $，$ m \leq 10 $，$ | a | \leq 10000 $；

测试点 3 ~ 4：$ n \leq 1000 $，$ m \leq 1000 $，$ | a | \leq 10000 $；

测试点 5：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 0 $，树是一条链；

测试点 6 ~ 7：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 0 $；

测试点 8：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 1 $，树是一条链；

测试点 9 ~ 10：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 1 $；

测试点 11 ~ 13：$ n \leq 100000 $，$ m \leq 100000 $，$ | a | \leq 10000 $，树是一条链；

测试点 14 ~ 20：$ n \leq 100000 $，$ m \leq 100000 $，$ | a | \leq 10000 $。

对于所有数据，$0\le w, |b|\le 10^9$。

## 样例 #1

### 输入

```
3 5
1 2 10
2 3 20
2 1 3
1 2 3 5 6
2 2 3
1 2 3 -5 -6
2 2 3```

### 输出

```
123456789123456789
6
-106```

# AI分析结果



### 算法分类
树链剖分 + 李超线段树

---

### 综合分析与结论
**题目核心**：在树链剖分的框架下，通过李超线段树维护路径上动态插入的线性函数，并快速查询最小值。

**关键思路与难点**：
1. **树链剖分**：将树结构转换为线性序列，便于用线段树处理路径操作。
2. **李超线段树**：支持动态插入一次函数，并在区间内快速计算最小值。难点在于如何将路径操作拆解为两个线性函数，并正确维护每个线段树节点的最优线段。
3. **路径拆分**：将路径分为 `s→lca` 和 `lca→t` 两部分，分别推导出对应的直线方程：
   - `s→lca`：`y = -a·dis[u] + (a·dis[s] + b)`
   - `lca→t`：`y = a·dis[u] + (a·dis[s] - 2a·dis[lca] + b)`
4. **最小值维护**：每个线段树节点需额外记录区间最小值，避免递归查询时重复计算。

---

### 题解清单（≥4星）
1. **disangan233（★★★★★）**
   - **亮点**：代码简洁，明确拆分路径并推导直线方程，李超树维护永久化标记。
   - **核心代码**：
     ```cpp
     k[++tot] = -x, b[tot] = x*dis[s] + y;  // s→lca的直线
     k[++tot] = x, b[tot] = x*(dis[s] - 2*dis[lca]) + y;  // lca→t的直线
     ```
2. **SovietPower（★★★★☆）**
   - **亮点**：详细解释线段树节点如何维护最小值，强调 `push_up` 的必要性。
   - **个人心得**：提到“李超线段树的常数较小，树剖复杂度可接受”。
3. **Rubyonly（★★★★☆）**
   - **亮点**：在代码中显式处理线段树节点的左右端点，确保区间最小值正确计算。

---

### 最优思路与技巧
1. **路径拆分与直线推导**：通过 LCA 将路径分为两段，分别计算对应的直线方程。
2. **李超树优化**：利用线段树节点的永久化标记，避免重复插入线段；维护区间最小值以加速查询。
3. **树剖加速**：将路径操作分解为多个重链区间操作，复杂度从 $O(n)$ 降至 $O(\log n)$。

---

### 类似题目
1. [P4097 [HEOI2013]Segment](https://www.luogu.com.cn/problem/P4097)：李超线段树模板题。
2. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)：树剖基础应用。
3. [P4069 [SDOI2016]游戏](https://www.luogu.com.cn/problem/P4069)：本题的同类变种。

---

### 可视化与算法演示
**动画设计**：
1. **树结构展示**：用节点与连线表示树，边权以数字标注。路径高亮为红色（s→lca）和蓝色（lca→t）。
2. **李超线段树操作**：
   - **插入**：路径拆分后，每个重链区间插入对应直线，动画显示线段插入线段树的过程。
   - **查询**：沿路径合并各区间的最小值，当前处理的线段树节点高亮为黄色。
3. **复古像素风格**：
   - **颜色方案**：树节点用绿色像素块，线段树节点用蓝色边框，当前操作节点闪烁。
   - **音效**：插入线段时播放“滴”声，查询最小值时播放“叮”声。

**交互功能**：
- **步进控制**：支持暂停/继续，调整动画速度。
- **自动演示**：模拟算法执行过程，AI 自动拆分路径并插入线段。

---

### 核心代码实现
**李超线段树插入逻辑**：
```cpp
void update(int p, int l, int r, int x) {
    if (calc(mid, x) < calc(mid, t[p])) swap(t[p], x);
    if (calc(l, x) < calc(l, t[p])) update(lc, l, mid, x);
    if (calc(r, x) < calc(r, t[p])) update(rc, mid+1, r, x);
    mn[p] = min({mn[p], calc(l, t[p]), calc(r, t[p])});
}
```

**树剖路径插入**：
```cpp
void modifyPath(int u, int v, int id) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        modify(1, 1, n, dfn[top[u]], dfn[u], id);
        u = fa[top[u]];
    }
    if (dep[u] > dep[v]) swap(u, v);
    modify(1, 1, n, dfn[u], dfn[v], id);
}
```

---

**总结**：本题需结合树剖的路径处理与李超线段树的动态维护，核心在于正确推导直线方程并高效实现区间操作。通过复古风格的动画演示，可直观展示算法关键步骤，帮助理解复杂数据结构在树上的应用。

---
处理用时：78.78秒
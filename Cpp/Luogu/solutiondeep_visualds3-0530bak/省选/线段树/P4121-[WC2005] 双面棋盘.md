# 题目信息

# [WC2005] 双面棋盘

## 题目描述

佳佳有一个 $n$ 行 $n$ 列的黑白棋盘，每个格子都有两面，一面白色，一面黑色。佳佳把棋盘平放在桌子上，因此每个格子恰好一面朝上，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/rcejbuct.png)

我们把每行从上到下编号为 $1$，$2$，$3$，……，$n$，各列从左到右编号为 $1$，$2$，$3$，……，$n$，则每个格子可以用棋盘坐标$(x, y)$表示。在上图中，有 $8$ 个格子黑色朝上，另外 $17$ 个格子白色朝上。

如果两个同色格子有一条公共边，我们称这两个同色格子属于同一个连通块。上图共有 $5$ 个黑色连通块和 $3$ 个白色连通块。

佳佳可以每分钟将一个格子翻转（即白色变成黑色，黑色变成白色），然后计算当前有多少个黑色连通块和白色连通块，你能算得更快吗？


## 说明/提示

【样例说明】

翻转 $(3, 2)$ 之后，棋盘变为：

![](https://cdn.luogu.com.cn/upload/image_hosting/9oqt0zsv.png)

有 $4$ 个黑色区域和 $3$ 个白色区域

翻转 $(2, 3)$ 之后，棋盘变为：

![](https://cdn.luogu.com.cn/upload/image_hosting/f335hulm.png)

有 $5$ 个黑色区域和 $2$ 个白色区域

【数据范围】   
对于 $100\%$ 的数据，$1\le n \le 200$，$1\le m \le 10^4$。


## 样例 #1

### 输入

```
5
0 1 0 0 0
0 1 1 1 0
1 0 0 0 1
0 0 1 0 0
1 0 0 0 0
2
3 2
2 3```

### 输出

```
4 3
5 2```

# AI分析结果



### 唯一算法分类
线段树与并查集结合应用

---

### 综合分析与结论
#### 核心思路与难点
- **核心逻辑**：将棋盘按行划分，用线段树维护行区间的连通性。每个线段树节点存储该区间的上下行连通块信息，合并时检查相邻行的颜色与连通性，动态调整并查集结构。
- **关键难点**：
  1. **行合并时的跨行连通性处理**：需遍历每列检查相邻行颜色，合并对应的并查集。
  2. **单点修改的更新机制**：修改某行后需逐层更新线段树节点，重新计算合并后的连通块数。
- **时间复杂度**：O(n² + mn log²n)，适合 n=200 的数据规模。

#### 可视化设计
- **动画方案**：
  - 用网格表示棋盘，不同颜色表示黑白格子。
  - 线段树节点展开时显示其维护的上下行边界，合并时高亮相邻列的连通检查。
  - 并查集合并时用连线动画表示连通块的合并。
- **复古游戏化效果**：
  - 8-bit 像素风格棋盘，音效触发：翻转时播放 "beep"，合并时播放 "click"。
  - Canvas 绘制动态并查集合并过程，自动演示模式下自动播放修改与合并流程。
  - 控制面板支持步进/暂停，可调节动画速度观察关键步骤。

---

### 题解清单 (≥4星)
1. **iiiiiyang (4.5星)**  
   - **亮点**：线段树节点维护行区间的最上行与最下行连通性，合并时暴力遍历列检查颜色。
   - **代码清晰**：详细注释 + 并查集复用技巧，pushup 函数逻辑简明。
   - **调试启示**：强调并查集的 "最小表示法" 避免重复合并。

2. **XiaoQuQu (4星)**  
   - **亮点**：用独立并查集维护每行的左右连通性，合并时独立处理黑白颜色。
   - **优化点**：分离黑白连通块统计，减少冗余计算。

3. **RedLycoris (4星)**  
   - **亮点**：通过预处理每行初始连通性，快速构建线段树。
   - **技巧**：用 "forceUpdate" 函数重构单行并查集，确保修改后状态正确。

---

### 核心代码实现
```cpp
struct Segment_tree {
    int white, black, l, r;
    int ls[MAX], rs[MAX]; // 维护上下行的连通性
    void pushup(int i) {
        // 合并相邻行，调整并查集
        for (int j=1; j<=n; j++) {
            int l = find(t[i<<1].rs[j]);
            int r = find(t[i<<1|1].ls[j]);
            if (g[mid][j] == g[mid+1][j] && l != r) {
                fa[l] = r;
                if (g[mid][j] == 0) white--;
                else black--;
            }
        }
        // 更新当前节点的上下行信息
        // ... (略)
    }
    void build(int i, int l, int r) {
        if (l == r) {
            // 初始化单行的并查集
            for (int j=1; j<=n; j++) 
                ls[j] = rs[j] = get(l, j);
            // ... (统计初始连通块)
        }
        // ... (递归构建左右子树)
    }
    void change(int i, int to) {
        if (t[i].l == t[i].r) {
            // 重构该行的并查集
            for (int j=1; j<=n; j++) 
                ls[j] = rs[j] = get(to, j);
        }
        // ... (递归修改并更新父节点)
    }
};
```

---

### 类似题目推荐
1. **P2147 [SDOI2008] 洞穴勘测**（LCT 维护动态连通性）
2. **P3224 [HNOI2012] 永无乡**（并查集 + 线段树合并）
3. **P3950 部落冲突**（离线处理 + 时间线段树）

---

### 可视化关键代码片段（Canvas 动画）
```javascript
// 绘制棋盘与连通块
function drawGrid() {
    ctx.clearRect(0, 0, width, height);
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            // 绘制格子颜色
            ctx.fillStyle = grid[i][j] ? "#000" : "#FFF";
            ctx.fillRect(j*cellSize, i*cellSize, cellSize, cellSize);
            // 绘制连通块编号
            ctx.fillStyle = "#F00";
            ctx.fillText(rootId[i][j], j*cellSize + 2, i*cellSize + 12);
        }
    }
}
// 合并动画（伪代码）
function animateMerge(x, y) {
    const duration = 500;
    const start = Date.now();
    requestAnimationFrame(function update() {
        const t = (Date.now() - start) / duration;
        // 绘制合并连线...
        if (t < 1) requestAnimationFrame(update);
        else drawGrid(); // 刷新最终状态
    });
}
```

---

### 个人心得摘录
> "合并时需注意并查集的根节点必须是最小元素，否则重复合并会导致计数错误。调试时通过打印每个节点的 ls/rs 数组发现未正确更新父节点。" —— iiiiuyang  
> "离线分治写法常数较大，n=200 时线段树套并查集的暴力合并反而更优。" —— TheLostWeak

---

### 复古像素风格设计
- **调色板**：8 色，黑白用 #000/#FFF，连通块编号用 #F00/#0F0。
- **音效**：Web Audio 合成 8-bit 音效，合并时触发短促 "嘟" 声。
- **自动演示**：按时间轴逐步执行修改与合并，用 setTimeout 控制节奏。
- **交互**：空格暂停/继续，左右键调整速度，Enter 单步执行。

---
处理用时：89.47秒
# 题目信息

# [JSOI2008] Blue Mary 开公司

## 题目背景

Blue Mary 最近在筹备开一家自己的网络公司。由于他缺乏经济头脑，所以先后聘请了若干个金融顾问为他设计经营方案。

## 题目描述

万事开头难，经营公司更是如此。开始的收益往往是很低的，不过随着时间的增长会慢慢变好。也就是说，**对于一个金融顾问 $i$，他设计的经营方案中，每天的收益都比前一天高，并且均增长一个相同的量 $P_i$。**

由于金融顾问的工作效率不高，**所以在特定的时间，Blue Mary 只能根据他已经得到的经营方案来估算某一时间的最大收益**。由于 Blue Mary 是很没有经济头脑的，所以他在估算每天的最佳获益时完全不会考虑之前的情况，而是直接从所有金融顾问的方案中选择一个在当天获益最大的方案的当天的获益值，例如：

有如下两个金融顾问分别对前四天的收益方案做了设计：

|   | 第一天 | 第二天 | 第三天 | 第四天 | $P_i$ |
| :-: | :-: | :-: | :-: | :-: | :-: |
| 顾问 1 | $1$ | $5 $| $9$ | $13$ | $4$ |
| 顾问 2 | $2$ | $5$ | $8$ | $11$ | $3$ |

在第一天，Blue Mary 认为最大收益是 $2$（使用顾问 2 的方案），而在第三天和第四天，他认为最大收益分别是 $9$ 和 $13$（使用顾问 1 的方案）。而他认为前四天的最大收益是：$2 + 5 + 9 + 13 = 29$。

现在你作为 Blue Mary 公司的副总经理，会不时收到金融顾问的设计方案，也需要随时回答 Blue Mary 对某天的“最大收益”的询问（这里的“最大收益”是按照 Blue Mary 的计算方法）。**一开始没有收到任何方案时，你可以认为每天的最大收益值是 0**。下面是一组收到方案和回答询问的例子：


- 询问 $2$，回答 $0$。
- 收到方案：$0\ 1\ 2\ 3\ 4\ 5\ \cdots$
- 询问 $2$，回答 $1$。
- 收到方案：$2\ 2.1\ 2.2\ 2.3\ 2.4\ \cdots$
- 询问 $2$，回答 $2.1$。

## 说明/提示

**数据范围**

$1 \leq N \leq 10 ^ 5$，$1 \leq T \leq 5\times 10 ^ 4$，$0 < P < 100$，$|S| \leq 10 ^ 5$。

**提示**

本题读写数据量可能相当巨大，请选手注意选择高效的文件读写方式。

## 样例 #1

### 输入

```
10
Project 5.10200 0.65000
Project 2.76200 1.43000
Query 4
Query 2
Project 3.80200 1.17000
Query 2
Query 3
Query 1
Project 4.58200 0.91000
Project 5.36200 0.39000```

### 输出

```
0
0
0
0
0```

# AI分析结果



# 算法分类  
**李超线段树**

---

## 综合分析与结论  
**核心思路**：  
题目要求动态插入一次函数（形如 y=kx+b），并查询给定 x 坐标处的最大函数值。李超线段树的核心思想是每个线段树节点维护在其区间中点处最优的线段，插入时通过比较新线段与当前线段在中点处的值及斜率关系，递归决定是否替换当前线段，并在子区间继续处理。查询时遍历所有覆盖目标点的区间，比较这些区间维护的最优线段在目标点的值。

**解决难点**：  
1. **动态维护最优线段**：通过标记永久化，每个区间维护局部最优线段而非全局最优。  
2. **递归插入策略**：根据斜率大小和中点值比较，决定替换当前线段并递归处理左/右子区间。  
3. **高效查询**：利用线段树结构遍历覆盖查询点的所有区间，时间复杂度 O(log T)。

**可视化设计思路**：  
- **动画流程**：  
  1. **插入线段**：  
     - 用红色高亮当前处理的线段树区间，显示当前维护的线段方程。  
     - 比较新线段与原线段在中点处的值，若新线段更优则替换为蓝色并递归子区间。  
  2. **查询操作**：  
     - 从根节点向下遍历，用绿色高亮路径上的区间，实时显示各区间线段在查询点的值。  
  3. **标记永久化**：用不同颜色区分永久化标记（如黄色）与临时计算值。  
- **复古像素风格**：  
  - 使用 8-bit 风格网格绘制线段树结构，节点用 16x16 像素块表示，显示线段方程简写（如 k=2,b=1）。  
  - 音效设计：插入时播放“滴”声，替换线段时播放“咔嚓”声，查询成功时播放经典 FC 过关音效。  

---

## 题解清单 (≥4星)  
1. **LengChu (5星)**  
   - **亮点**：代码简洁，使用标记永久化，注释清晰解释李超树原理。  
   - **核心代码**：  
     ```cpp  
     void updata(int id,int l,int r,int x) {  
         if(w(x,l)>w(t[id],l) && w(x,r)>w(t[id],r)) { t[id]=x; return; }  
         // ... 递归处理子区间  
     }  
     ```  
2. **DQYdqy (4.5星)**  
   - **亮点**：详细注释插入策略，代码结构模块化，适合学习。  
   - **核心代码**：  
     ```cpp  
     void change(int q,int l,int r,int id) {  
         if(l==r) { if(val > current) update; return; }  
         // ... 分类讨论斜率与中点值  
     }  
     ```  
3. **风羽跃 (4星)**  
   - **亮点**：处理线段替换时的递归方向，包含调试心得。  
   - **核心代码**：  
     ```cpp  
     void change(int p,int l,int r,double k,double b) {  
         // ... 比较新线段与原线段在端点的值  
     }  
     ```  

---

## 最优思路与技巧提炼  
1. **标记永久化**：每个区间维护局部最优线段，避免下传标记。  
2. **中点比较策略**：根据新线段与原线段在中点的值及斜率关系，决定递归方向。  
3. **离线处理替代方案**：CDQ分治按时间排序后维护凸包，适合离线场景。  

---

## 类似题目推荐  
1. **P4097 [HEOI2013]Segment** - 动态插入线段并查询区间最大值。  
2. **P4069 [SDOI2016]游戏** - 树链剖分结合李超线段树。  
3. **P4655 [CEOI2017]Building Bridges** - 斜率优化DP转李超树维护。  

---

## 个人心得摘录  
> **Scarlet_Hypoc**：CDQ方法浮点运算较多，实际效率略低，但提供了一种离线思路。  
> **BeyondStars**：暴力线段树在数据水时可通过，但需注意最坏复杂度。  

---

## 核心代码实现（李超线段树）  
```cpp  
double k[MAXN], b[MAXN]; // 存储线段参数  
int t[MAXN<<2]; // 线段树节点维护的线段ID  

void update(int id, int l, int r, int x) {  
    if (k[x] > k[t[id]]) {  
        if (calc(x, mid) > calc(t[id], mid)) {  
            update(ls, l, mid, t[id]);  
            t[id] = x;  
        } else update(rs, mid+1, r, x);  
    } else {  
        if (calc(x, mid) > calc(t[id], mid)) {  
            update(rs, mid+1, r, t[id]);  
            t[id] = x;  
        } else update(ls, l, mid, x);  
    }  
}  

double query(int id, int l, int r, int x) {  
    double res = calc(t[id], x);  
    if (l == r) return res;  
    return max(res, (x <= mid) ? query(ls,l,mid,x) : query(rs,mid+1,r,x));  
}  
```  

---

## 可视化代码片段（Canvas动画）  
```javascript  
// 绘制线段树节点  
function drawNode(ctx, x, y, text) {  
    ctx.fillStyle = "#8B00FF"; // 紫色像素块  
    ctx.fillRect(x*32, y*32, 30, 30);  
    ctx.fillStyle = "#FFF";  
    ctx.font = "8px Arial";  
    ctx.fillText(text, x*32+2, y*32+10);  
}  

// 插入动画示例  
function animateInsert(line) {  
    let current = root;  
    while (current) {  
        highlight(current); // 高亮当前区间  
        let mid = (current.l + current.r) >> 1;  
        if (compare(line, current.line, mid)) {  
            flash(current, "replace"); // 播放替换动画  
            current = current.left;  
        } else {  
            current = current.right;  
        }  
    }  
}  
```  

**复古音效设计**：  
- 插入线段：`beep(440, 50)`（440Hz短音）  
- 线段替换：`beep(880, 30)`（高频提示音）  
- 查询成功：`playSound('coin.wav')`（经典马里奥金币音效）  

---

**总结**：李超线段树通过中点比较策略高效维护动态线段，结合标记永久化实现 O(n log T) 复杂度，是该题的最优解。

---
处理用时：76.87秒
# 题目信息

# 公主の#19准备月考

## 题目背景

公主在玩完游戏后，也要月考了。（就算是公主也要月考啊QWQ）


## 题目描述

公主的文综太差了，全校排名1100+（全校就1100多人），她分析了好久，发现她如果把所有时间放在选择题上，得分会比较好一点。

文综题目共有n个，编号从1到n

公主给每个题目算出来了一个预估值Ai，她认为，一段连续题目的答案会在它们的预估值的gcd和lcm之间；有时候她的想法不同了，一些题目的预估值会改变；有时候，会出现多选题，多选题的答案数量就是一段连续题目答案的预估值的公约数的个数。

具体来说，对于一个数列，有四种操作：

L x y p 表示公主询问区间[x,y]的数字的lcm对p取模之后的值

G x y p 表示公主询问区间[x,y]的数字的gcd对p取模之后的值

C x y c 表示公主改变区间[x,y]的数字的值，统一为c

S x y p 表示公主询问区间[x,y]的数字的公因数个数对p取模之后的值

公主月考不能挂科，不然她就不能学习OI了（假的），所以请你帮帮她吧！


## 说明/提示

对于30%的数据，1<=n,q<=1000

对于另外20%的数据，1<=n<=1000，1<=q<=100000

对于另外20%的数据，1<=n<=100000，1<=q<=100000，保证没有修改操作

对于100%的数据，1<=n<=300000，1<=q<=300000

保证任何时刻每个题目的预估值都在[1,100]之间，答案取模之后不超过int


## 样例 #1

### 输入

```
10 10
42 68 35 1 70 25 79 59 63 65 
L 2 6 28
L 2 6 43
G 2 7 5
G 3 4 83
L 7 9 96
G 2 7 39
S 3 8 100
L 4 5 12
G 4 4 65
L 2 4 69```

### 输出

```
0
32
1
1
75
1
1
10
1
34```

# AI分析结果



**唯一算法分类**：线段树结合质因数分解的位压缩

---

### **题解思路与算法要点**

#### **核心思路**
1. **质因数分解位压缩**  
   - 将每个数的质因数次数按固定位数编码到整型变量中，如：2的次数用3位，3用3位，5、7各用2位，剩余质数用1位，总计31位（适合int）。
   - 例如：`42 = 2^1 * 3^0 * 5^0 * 7^0 * 11^0 ...` → 编码为二进制段。

2. **线段树维护区间信息**  
   - 每个线段树节点存储区间的`gcd`和`lcm`的压缩值，合并时通过位运算快速取`min`（gcd）或`max`（lcm）。
   - 区间赋值操作通过懒标记下传，直接更新压缩值。

3. **查询优化**  
   - LCM查询：分解压缩值，计算各质数最大次幂的积模`p`。
   - GCD查询：分解压缩值，计算各质数最小次幂的积模`p`。
   - 公约数个数：对GCD的压缩值统计各质数次数的乘积。

#### **解决难点**
- **位压缩与快速合并**：通过预定义的二进制位分配规则，将质数次数转换为位掩码，合并时用位运算快速取极值。
- **懒标记处理**：区间赋值时直接覆盖压缩值，避免逐个分解质因数。
- **模运算与快速幂**：利用快速幂处理质数高次幂的模运算，避免溢出。

---

### **题解评分与亮点**

#### **Vingying（★★★★☆）**
- **亮点**：  
  - 精确的位分配与位运算实现，代码高效。  
  - 预处理质因数分解，减少重复计算。  
- **不足**：代码较长，部分位操作可读性较差。

#### **玫葵之蝶（★★★★☆）**
- **亮点**：  
  - 使用`long long`存储35位，简化位分配逻辑。  
  - 合并操作直接通过`&`和`|`实现，代码更简洁。  
- **不足**：`long long`可能略微增加内存占用。

#### **s_r_f（★★★★☆）**
- **亮点**：  
  - 预处理合并函数表，实现O(1)复杂度合并。  
  - 代码高度优化，运行速度快。  
- **不足**：预处理表占用较大内存（1024x1024）。

---

### **最优思路与技巧**
1. **质因数分解的位压缩**  
   - **关键点**：将质数次数映射到固定二进制段，如`2^6`用3位存储。
   - **代码片段**：
     ```cpp
     // Vingying的cal函数（分解数为二进制掩码）
     int cal(int tmp) {
         int v = 0;
         for (int i = 0; i < 25; ++i) {
             int cnt = 0;
             while (tmp % pri[i] == 0) tmp /= pri[i], cnt++;
             v |= (cnt << b[i]); // b[i]为预计算的位偏移
         }
         return v;
     }
     ```

2. **线段树合并优化**  
   - **关键点**：合并时用位掩码取极值，如`callcm`取`max`，`calgcd`取`min`。
   - **代码片段**：
     ```cpp
     // 玫葵之蝶的线段树合并
     lc[x] = lc[x<<1] | lc[x<<1|1]; // LCM取或
     g[x] = g[x<<1] & g[x<<1|1];    // GCD取与
     ```

---

### **类似题目推荐**
1. **P3372 线段树区间求和**（基础线段树）  
2. **P3870 位运算区间翻转**（位压缩与线段树结合）  
3. **P2158 质因数分解统计**（质数次数处理）

---

### **可视化与算法演示**
1. **像素化线段树动画**  
   - **展示方式**：在Canvas中以网格表示线段树节点，每个节点显示二进制掩码的高亮位。  
   - **颜色标记**：  
     - 红色：当前操作的质数位（如2的位段）。  
     - 绿色：合并过程中变化的位。  
   - **交互设计**：  
     - 步进控制：按空格键逐步执行区间查询/修改。  
     - 音效：合并成功时播放8-bit音效，模运算完成时播放“通关”音效。

2. **复古游戏化效果**  
   - **像素风格**：线段树节点用16x16像素块表示，掩码位用不同颜色方块填充。  
   - **自动演示模式**：AI自动生成随机操作序列，展示算法如何处理高并发查询。

---

### **代码片段（核心逻辑）**
```cpp
// 玫葵之蝶的线段树合并与查询
struct node {
    LL g[maxn<<2], lc[maxn<<2], lz[maxn<<2];
    void change(int now, int L, int R, int l, int r, LL c) {
        if (L == l && R == r) { lz[now] = c; g[now] = lc[now] = c; return; }
        // ... 递归更新子节点
        lc[now] = lc[now<<1] | lc[now<<1|1]; // LCM合并
        g[now] = g[now<<1] & g[now<<1|1];    // GCD合并
    }
    LL queryg(int now, int L, int R, int l, int r) {
        // ... 递归查询并返回区间GCD掩码
    }
};
```

---

### **个人心得摘录**
> “**Vingying**：卡常大赛……最后没开O2比开了O2还快？！”  
> —— 通过精细的位运算优化，即使不依赖编译器优化也能极致提速。

> **Hadtsti**：直接记录质数次数更直观，但需权衡时间与空间。  
> —— 在代码可读性与性能间找到平衡是关键。

---
处理用时：78.03秒
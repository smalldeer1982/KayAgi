# 题目信息

# [BalticOI 2004] Sequence 数字序列

## 题目描述

给定一个整数序列 $a_1, a_2, \cdots , a_n$，求出一个递增序列 $b_1 < b_2 < ··· < b_n$，使得序列 $a_i$ 和 $b_i$ 的各项之差的绝对值之和 $|a_1 - b_1| + |a_2 - b_2| + \cdots + |a_n - b_n|$ 最小。

## 说明/提示

【数据范围】

- $40\%$ 的数据 $n≤5000$；
- $60\%$ 的数据 $n≤300000$；
- $100\%$ 的数据 $n≤10^6 , 0≤a_i≤2^{31}-1$；

题目来源：BalticOI 2004 Day 1, Sequence。

感谢 @TimeTraveller 提供 SPJ。


## 样例 #1

### 输入

```
5
2 5 46 12 1
```

### 输出

```
47
2 5 11 12 13```

# AI分析结果



**唯一算法分类**：贪心 + 数据结构（左偏树/可并堆）

---

### **题解思路、算法要点与解决难点**

#### **核心思路**  
1. **问题转化**：将严格递增的 `b` 转化为非递减序列，令 `a[i] -= i`，求解后 `b[i] += i` 恢复递增性。  
2. **分段维护中位数**：将序列划分为若干段，每段的最优解为该段中位数。若当前段的中位数小于前一段，则合并两段并重新计算合并后的中位数。  
3. **数据结构选择**：使用左偏树或可并堆动态维护每段的中位数，支持高效合并与中位数查询。

#### **解决难点**  
- **中位数动态维护**：合并区间时需快速找到新中位数，左偏树通过维护大根堆保留前一半元素，保证堆顶即为中位数。  
- **合并条件判断**：当新加入的段中位数小于前一段时触发合并，确保最终所有段的中位数非递减。  
- **时间复杂度优化**：左偏树合并复杂度为 `O(log n)`，整体算法复杂度为 `O(n log n)`；整体二分法通过分治策略优化至 `O(n log v)`。

---

### **题解评分 (≥4星)**

1. **Soulist（4.5星）**  
   - **亮点**：详细推导贪心策略，结合左偏树实现区间合并，代码结构清晰。  
   - **代码可读性**：使用带注释的左偏树合并逻辑，变量命名规范。  
   - **关键引用**：“合并的前提是左平均数小于右平均数，把左全部丢入右，平均数变大”。

2. **wzporz（4星）**  
   - **亮点**：仅用 STL 优先队列实现，无需复杂数据结构，适合快速实现。  
   - **优化点**：通过维护堆顶拐点简化中位数计算，代码短小高效。  
   - **不足**：代码注释较少，部分逻辑需结合论文理解。

3. **Rayment（4星）**  
   - **亮点**：结合论文思路，代码简洁，变量命名直观。  
   - **可视化友好**：通过 `data` 结构体明确记录每段区间信息，便于动画展示分段过程。

---

### **最优思路或技巧提炼**

1. **中位数贪心**：将序列分段，每段取中位数，确保绝对值和最小。  
2. **左偏树合并**：动态维护区间中位数，合并时保留前一半元素。  
3. **整体二分法**：对数值域二分，确定每点最优取值，避免复杂数据结构。

---

### **同类型题与算法套路**

- **通用套路**：序列分段 + 中位数贪心 + 可并堆维护。  
- **相似题目**：  
  - **P1168** 动态中位数（维护滑动窗口中位数）  
  - **P3871** 合并果子（可并堆优化）  
  - **CF713C** 使序列严格递增（类似绝对值最小化）

---

### **推荐相似洛谷题目**

1. **P1168** [中位数](https://www.luogu.com.cn/problem/P1168)  
   - **考察点**：动态维护中位数，堆的应用。

2. **P3871** [TJOI2010] 中位数  
   - **考察点**：左偏树维护中位数，支持插入与删除。

3. **CF713C** Sonya and Problem Wihtout a Legend  
   - **考察点**：严格递增序列的绝对值最小化，转化为非递减问题。

---

### **代码片段（左偏树核心逻辑）**

```cpp
// 左偏树合并函数
int merge(int x, int y) {
    if (!x || !y) return x + y;
    if (a[x] < a[y]) swap(x, y);
    rs[x] = merge(rs[x], y);
    if (dis[ls[x]] < dis[rs[x]]) swap(ls[x], rs[x]);
    dis[x] = dis[rs[x]] + 1;
    return x;
}

// 分段合并逻辑
for (int i = 1; i <= n; i++) {
    s[++top] = {i, i, 1, i, a[i]};
    while (top > 1 && s[top-1].val > s[top].val) {
        top--;
        s[top].rt = merge(s[top].rt, s[top+1].rt);
        s[top].sz += s[top+1].sz;
        s[top].r = s[top+1].r;
        while (s[top].sz > (s[top].r - s[top].l + 2) / 2) {
            s[top].sz--;
            s[top].rt = merge(ls[s[top].rt], rs[s[top].rt]);
        }
        s[top].val = a[s[top].rt];
    }
}
```

---

### **可视化与算法演示设计**

#### **核心动画流程**  
1. **初始分段**：将每个 `a[i]` 显示为独立色块，颜色区分不同段。  
2. **合并过程**：当两段中位数逆序时，触发合并动画，色块渐变为同一颜色。  
3. **中位数调整**：显示左偏树弹出堆顶元素，动态更新当前段的中位数位置。

#### **复古像素风格实现**  
- **颜色方案**：使用 8 色调色板，不同段用不同颜色，中位数标记为闪烁方块。  
- **Canvas 绘制**：  
  - 网格布局表示序列，每个单元格表示一个元素。  
  - 合并时显示线段连接两段，左偏树结构以树形图侧边展示。  
- **音效触发**：合并时播放 “哔” 音，中位数更新时播放 “叮” 音。

#### **交互设计**  
- **步进控制**：按钮控制执行“下一步”，高亮当前操作段。  
- **自动演示**：AI 模式自动合并逆序段，速度可调。  
- **状态面板**：显示当前段数、合并次数、总绝对值和。

---

### **个人心得摘录**

- **调试教训**：  
  - “合并后需立即更新中位数，否则后续分段会错误”（Soulist）。  
  - “整体二分的 `val` 更新需注意边界，避免死循环”（a154051）。  
- **优化技巧**：  
  - “STL 堆替代左偏树时，需记录拐点横坐标简化计算”（wzporz）。

---
处理用时：69.51秒
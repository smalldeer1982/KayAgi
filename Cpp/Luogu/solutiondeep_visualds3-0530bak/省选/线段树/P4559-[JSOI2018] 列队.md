# 题目信息

# [JSOI2018] 列队

## 题目描述

作为一名大学生，九条可怜在去年参加了她人生中的最后一次军训。

军训中的一个重要项目是练习列队，为了训练学生，教官给每一个学生分配了一个休息位置。每次训练开始前，所有学生都在各自的休息位置休息，但是当教官发出集合命令后，被点到的学生必须要到指定位置集合。

为了简化问题，我们把休息位置和集合位置抽象成一根数轴。一共有 $n$ 个学生，第 $i$ 个学生的休息位置是 $a_i$。每一次命令，教官会指定一个区间 $[l,r]$ 和集合点 $K$ ，所有编号在 $[l,r]$ 内的学生都必须赶到集合点列队。在列队时，每一个学生需要选择 $[K,K+r-l]$ 中的一个整数坐标站定且不能有任何两个学生选择的坐标相同。学生从坐标 $x$ 跑到坐标 $y$ 需要耗费体力 $\vert y-x \vert$ 。

在一天的训练中，教官一共发布了 $m$ 条命令 $(l,r,K)$ ，现在你需要计算对于每一条命令，在所有可能的列队方案中，消耗的体力值总和最小是多少。

以下是对题意的一些补充：

1.    任何两条命令是无关的，即在一条集合命令结束后，所有学生都会回到自己的休息位置，然后教官才会发出下一条命令。
    
2.    在集合的时候，可能有编号不在 $[l,r]$ 内的学生处在区间 $[K,K+r-l]$ 中，这时他会自己跑开，且跑动的距离不记在消耗的体力值总和中。



## 说明/提示

**样例 1 解释**


在第一条命令中，五名学生依次跑到 $[2,5,4,6,3]$，则总代价为 $|2-1|+|5-5|+|4-7|+|6-6|+|3-2|=5$。
    
在第二条命令中，五名学生依次跑到 $[4,5,7,6,3]$，则总代价为 $|4-1|+|5-5|+|7-7|+|6-6|+|3-2|=4$。
    
在第三条命令中，三名学生依次跑到 $[11,10,9]$，则总代价为 $|11-1|+|10-5|+|9-7|=17$。
    
在第四条命令中，三名学生依次跑到 $[4,2,3]$，则总代价为 $|4-5|+|2-7|+|3-6|=9$。
    
在第五条命令中，三名学生依次跑到 $[7,6,5]$，则总代价为 $|7-7|+|6-6|+|5-2|=3$。

**数据范围**

对于 $10\%$ 的数据，$n,m \leq 10$；

对于 $40\%$ 的数据，$n,m \leq 10^3$；

对于 $70\%$ 的数据，$n,m \leq 10^5$；

对于 $100\%$ 的数据，$n,m \leq 5 \times 10^5,1 \leq a_i,K \leq 10^6$。

对于 $100\%$ 的数据，学生休息的位置两两不同。


## 样例 #1

### 输入

```
5 5
1 5 7 6 2
1 5 2
1 5 3
1 3 9
2 4 2
3 5 5```

### 输出

```
5
4
17
9
3```

# AI分析结果



---

**唯一算法分类**：可持久化线段树（主席树）

---

### **题解思路与算法要点**

1. **核心思路**  
   - 学生按位置排序后，保持相对顺序移动到目标区间 `[K, K + r - l]`，此时总体力消耗最小。  
   - 利用主席树维护学生位置，递归查询每个区间内的学生是否全部向左/右移动，或需分割处理。

2. **关键步骤**  
   - **主席树构建**：维护每个版本的线段树，统计区间内的学生数量与位置和。  
   - **递归查询**：在目标区间内判断当前线段树节点的学生是否全部向左/右移动，否则继续分割递归。  
   - **贡献计算**：向左移动的体力贡献为 `∑(a_i - (K + rk_i - 1))`，向右为 `∑((K + rk_i - 1) - a_i)`，利用等差数列公式优化计算。

3. **解决难点**  
   - **动态分割点**：通过递归判断分界点 `mid`，确定学生移动方向的分割位置。  
   - **高效统计**：主席树支持快速查询区间内的学生数量和位置和，时间复杂度为 `O((n + m) log n)`。

---

### **题解评分（≥4星）**

1. **小粉兔（★★★★☆）**  
   - 思路清晰，代码简洁，递归条件处理明确。  
   - 关键代码片段：递归判断区间是否全部向左/右移动，直接计算贡献。  
   - **亮点**：使用等差数列快速求和公式，代码可读性强。

2. **shadowice1984（★★★★☆）**  
   - 详细证明分割点存在性，结合二分与主席树实现。  
   - **亮点**：通过二分确定分割点 `mid`，计算左右部分贡献。  
   - **代码片段**：递归二分过程中维护 `vl` 和 `sl` 统计贡献。

3. **Alex_Wei（★★★★★）**  
   - 代码高度优化，变量命名清晰，递归逻辑紧凑。  
   - **亮点**：直接在线段树上递归分割，避免显式二分。  
   - **代码片段**：`query` 函数处理四种情况，直接返回贡献值。

---

### **最优思路提炼**

1. **主席树维护区间信息**  
   - 每个版本的主席树维护学生位置的数量和总和，支持快速区间查询。

2. **递归分割判断**  
   - 递归过程中，若当前区间的学生全部向左/右移动，直接计算贡献；否则分割处理。

3. **等差数列优化**  
   - 利用等差数列公式 `(首项 + 末项) * 项数 / 2` 快速计算目标位置的体力贡献。

---

### **同类型题推荐**

1. **P3834 【模板】可持久化线段树 2（静态区间第k小）**  
   - 使用主席树维护区间信息，核心思路相似。

2. P2617 Dynamic Rankings（动态区间第k小）  
   - 结合树状数组与主席树，处理动态更新。

3. P4592 [TJOI2018] 异或  
   - 利用可持久化字典树处理区间异或问题。

---

### **代码核心实现**

```cpp
// 小粉兔题解核心代码
LL Qur(int rt1, int rt2, int l, int r, int f, int k) {
    if (!(sz[rt1] - sz[rt2])) return 0;
    LL Sz = sz[rt1] - sz[rt2], Sum = sum[rt1] - sum[rt2];
    if (l >= k + f) return Sum - (2*k + 2*f + Sz - 1) * Sz / 2;
    if (r <= k + f + Sz - 1) return (2*k + 2*f + Sz - 1) * Sz / 2 - Sum;
    int mid = l + r >> 1, lsz = sz[ls[rt1]] - sz[ls[rt2]];
    return Qur(ls[rt1], ls[rt2], l, mid, f, k) + 
           Qur(rs[rt1], rs[rt2], mid + 1, r, f + lsz, k);
}
```

---

### **可视化设计**

1. **动画方案**  
   - **像素风格线段树**：每个线段树节点显示为 8-bit 方块，颜色表示区间范围（如绿色表示 `[1, 1e6]`）。  
   - **高亮当前节点**：递归过程中，当前处理的节点变为黄色，分割线显示为红色虚线。  
   - **贡献计算提示**：向左移动的区间显示蓝色箭头，向右显示红色箭头，体力值实时更新。

2. **音效与交互**  
   - **音效**：递归进入节点时播放“滴”声，计算完成时播放“叮”声，错误处理播放“哔”声。  
   - **自动演示**：按空格键切换自动/手动模式，方向键控制递归速度。  
   - **控制面板**：显示当前递归深度、体力总和、分割点位置。

3. **复古元素**  
   - **背景音乐**：8-bit 风格循环音乐，类似《超级马里奥》地下关卡。  
   - **积分系统**：正确完成一次递归得 10 分，连击无错误额外加分。

---

### **总结**

本题通过主席树维护学生位置，结合递归分割与等差数列优化，高效计算最小体力消耗。可视化设计通过复古像素风格和交互式动画，直观展示算法流程，适合教学与自学。

---
处理用时：63.24秒
# 题目信息

# [CTSC2018] 混合果汁

## 题目描述

小 R 热衷于做黑暗料理，尤其是混合果汁。

商店里有 $n$ 种果汁，编号为 $0,1,\cdots,n-1$ 。$i$ 号果汁的美味度是 $d_i$，每升价格为 $p_i$。小 R 在制作混合果汁时，还有一些特殊的规定，即在一瓶混合果汁中，$i$ 号果汁最多只能添加 $l_i$ 升。

现在有 $m$ 个小朋友过来找小 R 要混合果汁喝，他们都希望小 R 用商店里的果汁制作成一瓶混合果汁。其中，第 $j$ 个小朋友希望他得到的混合果汁总价格不大于 $g_j$，体积不小于 $L_j$。在上述这些限制条件下，小朋友们还希望混合果汁的美味度尽可能地高，一瓶混合果汁的美味度等于所有参与混合的果汁的美味度的最小值。请你计算每个小朋友能喝到的最美味的混合果汁的美味度。

## 说明/提示

对于所有的测试数据，保证 $n, m \le 100000$，$1 \le d_i,p_i,l_i \le 10^5$，$1 \le g_j, L_j \le 10^{18}$。

测试点编号|$n=$|$m=$|其他限制
-|-|-|-
$1,2,3$|$10$|$10$|无
$4,5,6$|$500$|$500$|无
$7,8,9$|$5000$|$5000$|无
$10,11,12$|$100000$|$100000$|$p_i=1$
$13,14,15$|$100000$|$100000$|$l_i=1$
$16,17,18,19,20$|$100000$|$100000$|无

## 样例 #1

### 输入

```
3 4
1 3 5
2 1 3
3 2 5
6 3
5 3
10 10
20 10```

### 输出

```
3
2
-1
1```

# AI分析结果



# 算法分类  
**二分答案 + 可持久化数据结构**

---

## 题解思路与核心难点  
### 核心思路  
1. **二分答案**：将问题转化为「判定某个美味度d是否可行」，通过二分找到最大可行的d值  
2. **可持久化数据结构**：将果汁按美味度排序后，对每个二分点建立权值线段树（以价格为下标），维护价格区间内的总容量和总花费  
3. **贪心验证**：验证时优先选择价格最低的果汁，通过线段树上的前缀和计算是否能满足体积和花费限制  

### 解决难点对比  
| 题解方案             | 数据结构          | 时间复杂度    | 核心优化点                     |  
|---------------------|-----------------|-------------|------------------------------|  
| 可持久化线段树       | 主席树           | O(n log²n)  | 按美味度排序后建立版本历史      |  
| 整体二分+树状数组    | 双树状数组       | O(n log²n)  | 动态维护当前二分区间的果汁集合 |  
| 平衡树+整体二分      | multiset        | O(n log³n)  | 利用平衡树自动维护价格顺序      |  

### 精炼结论  
**最优方案**：可持久化权值线段树，在预处理时按美味度倒序建立主席树版本，每个版本存储价格≤当前版本的所有果汁信息。验证时在对应版本线段树上贪心选择低价果汁，实现高效查询。

---

## 题解评分（≥4星）  
### [kouylan] ★★★★☆  
- **亮点**：完整的主席树实现，代码结构清晰  
- **关键代码**：  
  ```cpp
  void insert(int &o,int pre,int l,int r,int x,int v) {
      // 主席树插入操作，维护体积和花费
  }
  int query(int o,int l,int r,int k) {
      // 线段树上贪心查询
  }
  ```

### [Kelin] ★★★★  
- **亮点**：将线段树查询与二分答案解耦，逻辑更易理解  
- **核心判断逻辑**：  
  ```cpp
  if(res<=g && t[root[mid]].s>=lim) // 验证条件
  ```

### [Fading] ★★★★  
- **亮点**：用树状数组代替线段树，代码更简洁  
- **关键优化**：  
  ```cpp
  void add(int x,ll k) { /* 维护双树状数组 */ }
  ll query(int x) { /* 二分查找临界点 */ }
  ```

---

## 最优思路提炼  
### 关键技巧  
1. **二分边界处理**：在果汁列表末尾添加虚拟节点（d=-1）处理无解情况  
2. **价格离散化**：将果汁价格映射到1e5的离散范围减少内存消耗  
3. **贪心查询设计**：在线段树查询时优先左子树（低价区），若容量不足则全取左子树并递归右子树  

### 代码实现要点  
```cpp
// 按美味度排序并建立主席树
sort(a+1,a+n+1,cmp);
for(int i=1;i<=n;i++)
    insert(root[i],root[i-1],1,MAXP,a[i].p,a[i].l);

// 二分验证过程
int l=1,r=n,ans=-1;
while(l<=r) {
    int mid = (l+r)>>1;
    if(check(root[mid], g, L)) 
        ans=mid, l=mid+1;
    else 
        r=mid-1;
}
```

---

## 类似题目推荐  
1. **P1527 [国家集训队]矩阵乘法**（二维区间第k小）  
2. **P3380 【模板】二逼平衡树**（树套树应用）  
3. **P3332 [ZJOI2013]K大数查询**（整体二分经典题）

---

## 可视化设计  
### 算法演示方案  
![混合果汁算法演示](https://via.placeholder.com/600x400/FF6B6B/FFFFFF?text=Animation+Preview)  
1. **像素风格界面**：  
   - 左侧8-bit风格果汁瓶按价格排列，右侧显示当前二分区间  
   - 每次二分时mid点高亮显示（红色像素框）  
   - 线段树节点用绿色方块表示已覆盖的价格区间  

2. **关键动画步骤**：  
   - **Step1**：果汁按d值降序飞入画面并排序  
   - **Step2**：二分指针l/r向mid收缩，当前检查的果汁集合高亮  
   - **Step3**：线段树节点逐层展开，显示体积和花费的累加过程  

3. **音效设计**：  
   - 二分成功：8-bit上升音阶（♪~♪♫）  
   - 验证失败：低沉嗡鸣声（哔——）  
   - 线段树遍历：点击声效（咔嗒）

---

## 代码实现（核心片段）  
```cpp
// 可持久化线段树查询函数
ll query(int u, int l, int r, ll need) {
    if(l == r) return min(need, sum[u]) * l; // 叶子节点处理
    
    ll left_sum = sum[ls[u]];
    if(left_sum >= need) 
        return query(ls[u], l, mid, need);
    else 
        return val[ls[u]] + query(rs[u], mid+1, r, need-left_sum);
}

// 主二分逻辑
for(auto &q : queries) {
    int l=1, r=n, ans=-1;
    while(l <= r) {
        int mid = (l+r)/2;
        if(tree.query(root[mid], q.L) <= q.G) 
            ans = mid, l = mid+1;
        else 
            r = mid-1;
    }
    output[q.id] = ans;
}
```

---

## 总结  
该问题的核心在于将**最优化问题**转化为**判定问题**，通过可持久化数据结构维护历史版本实现高效查询。不同题解在数据结构选择上各有优劣，但核心思想均围绕二分答案与贪心验证展开。

---
处理用时：70.55秒
# 题目信息

# [IOI 2018] werewolf 狼人

## 题目背景

本题为交互题，但在此请提交**完整程序**。

## 题目描述

在日本的茨城县内共有 $N$ 个城市和 $M$ 条道路。这些城市是根据人口数量的升序排列的，依次编号为 $0$ 到 $N - 1$。每条道路连接两个不同的城市，并且可以双向通行。由这些道路，你能从任意一个城市到另外任意一个城市。

你计划了 $Q$ 个行程，这些行程分别编号为 $0$ 至 $Q - 1$。第 $i(0 \leq i \leq Q - 1)$ 个行程是从城市 $S_i$ 到城市 $E_i$。

你是一个狼人。你有两种形态：**人形**和**狼形**。在每个行程开始的时候，你是人形。在每个行程结束的时候，你必须是狼形。在行程中，你必须要变身（从人形变成狼形）恰好一次，而且只能在某个城市内（包括可能是在 $S_i$ 或 $E_i$ 内）变身。

狼人的生活并不容易。当你是人形时，你必须避开人少的城市，而当你是狼形时，你必须避开人多的城市。对于每一次行程 $i(0 \leq i \leq Q - 1)$，都有两个阈值 $L_i$ 和 $R_i(0 \leq L_i \leq R_i \leq N - 1)$，用以表示哪些城市必须要避开。准确地说，当你是人形时，你必须避开城市 $0, 1, \ldots , L_i - 1$ ；而当你是狼形时，则必须避开城市 $R_i + 1, R_i + 2, \ldots , N - 1$。这就是说，在行程 $i$ 中，你必须在城市 $L_i, L_i + 1, \ldots , R_i$ 中的其中一个城市内变身。

你的任务是，对每一次行程，判定是否有可能在满足上述限制的前提下，由城市 $S_i$ 走到城市 $E_i$。你的路线可以有任意长度。

## 说明/提示

**限制条件**

- $2 \leq N \leq 200, 000$
- $N - 1 \leq M \leq 400, 000$
- $1 \leq Q \leq 200, 000$
- 对于每个 $0 \leq j \leq M - 1$
    - $0 \leq X_j \leq N - 1$
    - $0 \leq Y_j \leq N - 1$
    - $X_j \neq Y_j$
- 你可以通过道路由任意一个城市去另外任意一个城市。
- 每一对城市最多只由一条道路直接连起来。换言之，对于所有 $0 \leq j < k \leq M - 1$，都有 $(X_j, Y_j) \neq (X_k, Y_k)$ 和 $(Y_j, X_j) \neq (X_k, Y_k)$
- 对于每个 $0 \leq i \leq Q - 1$
    - $0 \leq L_i \leq S_i \leq N - 1$
    - $0 \leq E_i \leq R_i \leq N - 1$
    - $S_i \neq E_i$
    - $L_i \leq R_i$

**子任务**

- 1.（7 分）$N \leq 100$，$M \leq 200$，$Q \leq 100$。
- 2.（8 分）$N \leq 3, 000$，$M \leq 6, 000$，$Q \leq 3, 000$。
- 3.（34 分）$M = N - 1$ 且每个城市最多与两条路相连（所有城市是以一条直线的形式连起来）。
- 4.（51 分）没有附加限制。

## 样例 #1

### 输入

```
6 6 3
5 1
1 2
1 3
3 4
3 0
5 2
4 2 1 2
4 2 2 2
5 4 3 4
```

### 输出

```
1
0
0
```

## 样例 #2

### 输入

```
10 9 10
6 7
1 5
8 0
2 9
9 4
2 7
8 5
6 0
3 4
4 9 0 9
8 1 8 9
1 8 1 8
8 3 5 5
8 9 3 9
0 1 0 2
9 0 6 6
1 7 1 8
9 4 5 6
9 5 0 9
```

### 输出

```
1
1
1
0
1
1
0
1
0
1
```

# AI分析结果



---

### 唯一算法分类  
**Kruskal 重构树 + 二维数点**

---

### 综合分析与结论  

#### 核心思路  
1. **问题转化**：将路径问题转化为两个点集的交集问题。人形态能到达的点集和狼形态能到达的点集若有交集，则存在合法路径。  
2. **Kruskal 重构树**：  
   - **人形态树（A树）**：按边的 max(u,v) 升序构建最小生成树重构树，子树表示能到达的 ≥L 的点集。  
   - **狼形态树（B树）**：按边的 min(u,v) 降序构建最大生成树重构树，子树表示能到达的 ≤R 的点集。  
3. **倍增查询**：在两棵树上分别通过倍增找到满足条件的子树根节点。  
4. **二维数点**：将两棵树的 DFS 序映射为二维平面上的点，判断矩形区域是否有交点。  

#### 可视化设计  
1. **重构树构建动画**：  
   - 展示边的排序过程（A树按 max 升序，B树按 min 降序）。  
   - 每合并两个连通块时，生成新的重构树节点，用不同颜色标记人形态树（红色）和狼形态树（蓝色）。  
2. **子树范围查找**：  
   - 高亮当前节点在树上的倍增路径，展示如何找到满足条件的子树根节点。  
3. **二维数点演示**：  
   - 在笛卡尔坐标系中，用绿色方块表示点的分布（横轴为 A 树 DFS 序，纵轴为 B 树 DFS 序）。  
   - 动态绘制查询的矩形区域，若存在交点则播放成功音效。  

#### 复古游戏化设计  
- **像素风格界面**：使用 8-bit 调色板（红/蓝/绿为主色），树结构用网格表示，边合并时播放经典 FC 音效。  
- **AI 自动演示**：  
  - 自动播放重构树构建过程，关键步骤暂停并显示文字说明。  
  - 查询时展示“自动寻路”效果，用闪烁光标标记当前查询的子树范围。  
- **音效设计**：  
  - 合并节点时播放“哔”声，成功查询时播放“叮咚”音效，失败时播放“嘟”声。  

---

### 题解清单（≥4星）  

1. **作者：y2823774827y（4.5星）**  
   - **亮点**：离线树状数组处理二维数点，代码简洁高效。  
   - **核心代码**：通过两棵重构树的 DFS 序映射，离线排序后用树状数组统计交集。  

2. **作者：Nemlit（4.5星）**  
   - **亮点**：主席树在线查询，详细解释二维映射原理。  
   - **核心代码**：将 B 树的 DFS 序映射到 A 树的排列，通过主席树查询区间交。  

3. **作者：asd_a（4星）**  
   - **亮点**：明确分步讲解重构树性质，代码模块化清晰。  
   - **个人心得**：强调重构树的子树性质是解题关键，避免陷入复杂路径分析。  

---

### 关键代码实现（以 y2823774827y 解法为例）  

#### Kruskal 重构树构建  
```cpp  
// A树：按 max(u,v) 升序构建最小生成树  
void kruskal(bool type) {
    sort(e, e+m, [](edge a, edge b) { 
        return type ? max(a.u,a.v) < max(b.u,b.v) : min(a.u,a.v) > min(b.u,b.v);
    });
    for(int i=1; i<=2*n; i++) fa[i] = i;
    int tot = n;
    for(auto [u,v] : e) {
        int fu = find(u), fv = find(v);
        if(fu == fv) continue;
        val[++tot] = type ? max(u,v) : min(u,v);
        add(tot, fu); add(tot, fv); // 添加边到重构树
        fa[fu] = fa[fv] = tot;
    }
}
```

#### 二维数点查询  
```cpp  
// 树状数组离线处理  
vector<Query> qlist; // 存储所有查询的矩形区域  
sort(qlist.begin(), qlist.end(), [](Query a, Query b) {
    return a.x < b.x; // 按 x 坐标排序
});

int ptr = 0;
for(auto [x1, y1, x2, y2, id] : qlist) {
    while(ptr <= x2) {
        update(B_dfn[ptr]); // 插入当前点的 y 坐标
        ptr++;
    }
    ans[id] += query(y2) - query(y1-1);
}
```

---

### 同类型题目推荐  
1. **P4197 Peaks**（Kruskal 重构树 + 主席树）  
2. **CF1093E Intersection of Permutations**（二维数点问题）  
3. **P3384 轻重链剖分**（DFS 序区间性质应用）  

---

### 可视化与游戏化实现片段  

#### Canvas 绘制重构树（伪代码）  
```javascript  
function drawTree(node, x, y, depth) {
    if (node == null) return;
    drawPixelSquare(x, y, color[node.type]); // 人形态树红色，狼形态树蓝色
    if (node.left) {
        drawLine(x, y, x - 50 + depth*10, y + 50); // 连线到左子树
        drawTree(node.left, x - 50 + depth*10, y + 50, depth+1);
    }
    if (node.right) {
        drawLine(x, y, x + 50 - depth*10, y + 50);
        drawTree(node.right, x + 50 - depth*10, y + 50, depth+1);
    }
}
```

#### 自动演示控制  
```javascript  
let autoPlay = setInterval(() => {
    if (currentStep >= maxStep) clearInterval(autoPlay);
    else {
        highlightCurrentEdge(edges[currentStep]); // 高亮当前处理的边
        playSound('beep.wav'); // 播放合并音效
        currentStep++;
    }
}, 1000); // 每秒执行一步
```

---

通过结合 Kruskal 重构树的高效性质与二维数点的巧妙映射，本题解将复杂的路径问题转化为直观的几何查询，辅以复古像素动画和音效交互，使算法学习更具趣味性。

---
处理用时：74.08秒
# 题目信息

# HMR的LIS Ⅲ

## 题目背景

[HMR的LIS Ⅰ](https://www.luogu.org/problemnew/show/T51390)

[HMR的LIS Ⅱ](https://www.luogu.org/problemnew/show/T51391)

在你帮助HMR切掉AKIOI的神仙LSK的两道题后，LSK很不满，决定好好刁难一下你（而不是HMR）

## 题目描述

LSK又给出了一个长度为n的序列，要求你求出它的IBvl序列

IBvl序列满足以下要求：

1.一个IBvl序列满足$ \forall ~ i \in (1,len] , L < a_i - a_{i-1} < R $，其中$len$为IBvl序列的长度

2.IBvl序列中的元素相对顺序应满足在原序列中的相对顺序

3.在所有满足条件的序列中长度最长

我们视位置不同的元素为不同元素，有任一组成元素不同的IBvl序列为不同IBvl序列

现在要求你输出原序列的IBvl序列的长度，并输出字典序第k小（以元素在原序列中的位置为关键字排序）的序列的每个元素在原序列中的位置

## 说明/提示

#### 样例解释：

对于给出的数据，一共有$5$种IBvl序列，分别是:$\{6\},\{8\},\{0\},\{2\},\{7\}$。

他们在原序列中位置的编号序列分别是$\{1\},\{2\},\{3\},\{4\},\{5\}$

IBvl序列的长度为1。

要求输出字典序第$3$小的编号序列，于是输出$3$。

#### 数据范围与约定：

对于20%的数据，$ n \le 18$

对于50%的数据，$ n \le 1000 , | l | , | r | \leq 10^9 , r-l>1 , 0 \le a[i] \le 10^9 $

对于另外10%的数据，$ l=0 , r=10^9+1 , k=1 $

对于另外20%的数据，$ l=0 , r=10^9+1 , k \le 3 $

对于100%的数据，$ n \le 5*10^5 , | l | , | r | \le 10^9 , r-l>1 , k \le 10^{13} , 0 \le a[i] \le 10^9 $

对于所有数据，保证合法且有解。

对于前50%的数据，时限为1s，后50%的数据，时限为2s（~~凉~~良心不卡常）

## 样例 #1

### 输入

```
5 3 2 4
6 8 0 2 7```

### 输出

```
1
3```

# AI分析结果



---

## **算法分类**  
动态规划 + 线段树优化 + 贪心

---

## **题解思路与核心难点**  
### **核心问题拆解**  
1. **最长IBvl序列**：需满足相邻元素差在 (L, R) 区间，且相对顺序不变。  
2. **字典序第k小序列**：以元素在原序列中的位置为字典序依据。  

### **动态规划优化**  
- **状态设计**：  
  - `f[i]` 表示以第 `i` 个元素开头的最长IBvl序列长度。  
  - `num[i]` 表示以 `i` 开头的方案数。  
- **转移方程**：  
  `f[i] = max{ f[j] + 1 }`，其中 `j > i` 且 `L < a[j] - a[i] < R`。  
- **线段树优化**：  
  离散化后，用线段树维护区间最大值和方案数之和，将转移复杂度从 O(n²) 优化至 O(n log m)。  

### **离散化与预处理**  
- 将原数组 `a` 及其可能的转移边界 `a[i]+L` 和 `a[i]+R` 一起离散化，压缩值域。  
- 预处理每个 `a[i]` 的有效转移区间 `[NL[i], NR[i]]`，用于线段树查询。  

### **字典序贪心**  
从前往后逐位确定序列：  
1. 对所有可能的位置按原下标排序，优先选择下标小的。  
2. 若当前候选位置的方案数 `num[i] >= k`，则必须选它；否则减去 `num[i]` 并跳过。  

---

## **题解评分**  
### **DDOSvoid的题解（4.5星）**  
- **亮点**：代码结构清晰，注释详细，离散化与线段树实现规范。  
- **改进**：方案数的累加未完全优化（部分边界处理可简化）。  

### **rqy的题解（4星）**  
- **亮点**：高效预处理转移区间，内存占用更低。  
- **不足**：变量命名较简略，可读性稍差。  

---

## **最优思路与技巧提炼**  
1. **离散化+线段树区间查询**：将复杂条件转化为离散值的区间查询。  
2. **反向DP转移**：从后往前计算 `f[i]`，便于利用线段树维护已处理部分的最优值。  
3. **贪心选择字典序**：按原下标排序候选位置，利用方案数快速确定第k小序列。  

---

## **同类型题与算法套路**  
- **类似题目**：最长上升子序列（LIS）及其变种（如字典序最小、方案数统计）。  
- **通用套路**：  
  - 动态规划 + 数据结构优化（线段树、树状数组）。  
  - 离散化处理大范围数值。  
  - 贪心选择字典序最小的元素。  

---

## **推荐相似题目**  
1. **P1439 【模板】最长公共子序列**（离散化 + 贪心优化）  
2. **P4303 [AHOI2006]基因匹配**（线段树优化DP）  
3. **P2215 [HAOI2007]上升序列**（字典序最小LIS构造）  

---

## **个人心得摘录**  
- **离散化细节**：需将 `a[i]`、`a[i]+L`、`a[i]+R` 一起离散化，否则无法正确确定区间边界。  
- **线段树维护内容**：需同时记录最大值和方案数，方案数需取 `min(K+1)` 避免溢出。  
- **调试经验**：在字典序贪心时，需严格检查候选位置是否满足 `a[j] - a[i]` 的条件。  

---

## **可视化与算法演示**  
### **动画设计**  
1. **动态规划步骤**：  
   - 从右向左遍历数组，高亮当前元素 `i`。  
   - 显示线段树查询区间 `[a[i]+L, a[i]+R]` 的过程，展示如何更新 `f[i]` 和 `num[i]`。  
2. **字典序选择过程**：  
   - 用不同颜色标注候选位置，动态显示 `k` 的减少过程。  
   - 当选定位时，高亮其对应的线段树区间。  

### **复古像素风格实现**  
- **Canvas绘制**：  
  - 数组元素以像素方块表示，线段树节点显示为树形结构。  
  - 当前操作元素闪烁，线段树查询区域用红色边框标记。  
- **音效**：  
  - **查询区间**：短促“滴”声。  
  - **确定位置**：上扬“成功”音效。  

### **交互控制**  
- **步进执行**：支持暂停/继续，调整动画速度。  
- **自动演示**：模拟“AI”自动完成最长序列构造与字典序选择。  

---

## **核心代码片段**  
### **离散化与线段树更新（DDOSvoid）**  
```cpp  
void init_hash() {  
    // 离散化处理  
    c1 = n; a[0] = INF;  
    for (int i = 1; i <= n; ++i) b[i] = a[i] = read();  
    for (int i = 1; i <= n; ++i) b[++c1] = a[i] + L, b[++c1] = a[i] + R;  
    sort(b + 1, b + c1 + 1);  
    cnt = unique(b + 1, b + c1 + 1) - b - 1;  
}  

void update(int i, int l, int r, int k, cs &o) {  
    // 线段树更新最大值和方案数  
    if (l == r) {  
        if (o.v > T[i].v) T[i] = o;  
        else if (o.v == T[i].v) T[i].s += o.s;  
        T[i].s = min(T[i].s, K + 1);  
        return;  
    }  
    // ... 递归更新子节点  
}  
```

### **字典序贪心选择（rqy）**  
```cpp  
for (int i = ans1, last = -1, l = 0, r = m - 1; i; --i)  
    for (int j = hd[i]; ~j; j = nxt[j])  
        if (j > last && A[j] >= l && A[j] <= r)  
            if (num[j] >= K) {  
                // 选择当前位置  
                write[(last = j) + 1][' '];  
                l = NL[A[j]]; r = NR[A[j]];  
                break;  
            } else K -= num[j];  
```  

---

**答案输出**  
```plaintext  
1. 最长IBvl序列长度为1。  
2. 字典序第3小的位置序列为3。  
```

---
处理用时：84.22秒
# 题目信息

# 水の数列

## 题目背景

${\rm CYJian}$想到了一个很好玩的游戏呢...

## 题目描述

${\rm CYJian}$现在给你一个长度为$N$的数列，你可以选择一个数$x$，然后获得一个得分，得分越大越好。

得分是这样计算的:

首先把小于等于$x$的数标记，然后你的得分就是每一个连续标记的区间的长度的平方和。

${\rm CYJian}$觉得这样太简单了，~~答案显然就是最大值嘛~~所以他就把得分改成了原来的得分除以你选择的数。

${\rm CYJian}$还是觉得这样太简单了，所以他需要你选择的数得到的区间的个数在$l$~$r$的范围内。

${\rm CYJian}$还是觉得这样太简单了，所以他加上了$T$组询问。

${\rm CYJian}$还是觉得这样太简单了，所以他决定强制在线。

## 说明/提示

${\rm Subtask\ 1(30\ pts)}:\qquad 1 \leq N,T \leq 10^2$

${\rm Subtask\ 2(30\ pts)}:\qquad 1 \leq N,T \leq 10^3$

${\rm Subtask\ 3(40\ pts)}:\qquad 1 \leq N \leq 10^6 \qquad 1 \leq T \leq 10^3$

$1 \leq Num_i \leq 10^6$

其余输入的数字均在${\rm int}$范围内。

## 样例 #1

### 输入

```
5 3
3 5 1 2 4
233 666 1 3
555 999 2 3
123 987 233 888```

### 输出

```
25 5
1 3 0
10 4
2 3 0
-1 -1
3 3 0
```

# AI分析结果



## 算法分类  
**并查集 + 分块/RMQ**

---

## 题解思路与解决难点  

### 核心思路  
1. **预处理所有可能的x**：将数列排序后从小到大枚举x，每次合并连续区间，用并查集维护连通块数量和长度平方和。  
2. **动态维护得分**：每个x对应一个区间数cnt，记录每个cnt的最优得分（得分=平方和/x）。  
3. **高效查询**：预处理每个区间数的最优解后，使用分块或ST表处理区间最大值查询。  

### 关键难点与解决  
1. **空间优化**：  
   - 直接开ST表（O(n log n)）会MLE，改用分块+ST表（每块大小log n）或线段树。  
   - 利用区间数上限为n/2的特性压缩数组。  
2. **强制在线处理**：  
   - 用`__int128`或模运算处理乘法溢出，避免lastans计算错误。  
3. **分数比较**：  
   - 避免浮点误差，用乘法比较（如`a.score*b.x < b.score*a.x`）。  

---

## 题解评分 (≥4星)  

1. **vectorwyx（★★★★★）**  
   - 思路清晰，用分块+并查集实现，预处理与查询逻辑简洁。  
   - 代码结构清晰，关键变量命名合理（如`frac`结构体）。  

2. **Brilliance_Z（★★★★☆）**  
   - 详细解释了分数比较的优化技巧，代码中维护最大x的写法值得参考。  
   - 使用线段树处理RMQ，适合大区间查询。  

3. **ComplexPlanck（★★★★☆）**  
   - 强调了空间卡常技巧（vector的resize和shrink_to_fit）。  
   - 代码中`go()`函数详细注释了并查集合并过程。  

---

## 最优思路与技巧  
1. **并查集动态合并**：维护连续区间时，每次合并左右相邻块，更新平方和与区间数。  
2. **分块+ST表**：整块用ST表，零散点暴力查询，平衡时间与空间。  
3. **分数乘法比较**：通分后比较分子，避免精度问题。  

---

## 类似题目与套路  
1. **P5490 扫描线**：区间合并与面积计算。  
2. **P1197 星球大战**：动态并查集维护连通块。  
3. **P3224 永无乡**：并查集+权值线段树维护第k大。  

---

## 个人心得摘录  
> “处理分数比较时一定要用乘法，否则会被精度卡到怀疑人生。”  
> “分块处理RMQ时，块大小取√n或log n需根据数据规模权衡。”  
> “强制在线模运算前先加n再取模，防止负数导致RE。”  

---

## 可视化算法演示  

### 核心流程  
1. **并查集合并动画**：  
   - 初始时所有点独立，颜色标记为灰色。  
   - 选中x时，点亮对应点为绿色，若左右相邻则合并为同一色块，显示合并过程。  
2. **分块查询演示**：  
   - 用不同颜色区分块，查询区间时高亮整块和零散点。  

### 复古像素风格设计  
- **8位像素调色板**：  
  - 未处理点：深灰（#555555）  
  - 当前处理点：亮绿（#00FF00）  
  - 合并块：渐变蓝（#0000FF → #00FFFF）  
- **音效设计**：  
  - 合并成功：短促“叮”声（500Hz）。  
  - 查询完成：8-bit胜利音效。  
- **Canvas动画**：  
  - 网格布局，每个点占10x10像素，合并时动态绘制色块扩展。  

### 交互功能  
- **步进控制**：空格暂停/继续，方向键调整速度。  
- **自动演示**：AI模式自动遍历x，显示得分变化曲线。  

---

## 核心代码片段  
```cpp
// 并查集合并与得分更新（vectorwyx题解）
void merge(int x, int y, ll &res1, int &res2) {
    int fx = find(x), fy = find(y);
    if (fx != fy) {
        res1 -= (ll)size[fx]*size[fx] + (ll)size[fy]*size[fy];
        res2--;
        if (size[fx] < size[fy]) swap(fx, fy);
        fa[fy] = fx;
        size[fx] += size[fy];
        res1 += (ll)size[fx]*size[fx];
    }
}

// 分块查询（Brilliance_Z题解）
frac query(int l, int r) {
    int x = log2(r - l + 1);
    return max(st[l][x], st[r - (1 << x) + 1][x]);
}
```

---

## 总结  
本题解通过并查集维护动态区间，结合分块/RMQ优化查询，是处理强制在线统计问题的经典模式。可视化设计以像素动画直观展示合并过程，适合教学演示。

---
处理用时：64.48秒
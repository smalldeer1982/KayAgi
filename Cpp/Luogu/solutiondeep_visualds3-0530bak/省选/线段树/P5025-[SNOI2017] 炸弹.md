# 题目信息

# [SNOI2017] 炸弹

## 题目描述

在一条直线上有 $n$ 个炸弹，每个炸弹的坐标是 $ x_i $，爆炸半径是 $ r_i $，当一个炸弹爆炸时，如果另一个炸弹所在位置 $ x_j $ 满足： 
$ |x_j-x_i| \le r_i $ ，那么，该炸弹也会被引爆。    
现在，请你帮忙计算一下，先把第 $i$ 个炸弹引爆，将引爆多少个炸弹呢？ 

答案对 $10^9 + 7$ 取模

## 说明/提示

【数据范围】  
对于  $20\%$ 的数据： $n\leq 100$。

对于  $50\%$ 的数据： $n\leq 1000$。

对于  $80\%$ 的数据： $n\leq 100000$。

对于  $100\%$ 的数据： $1\le n\leq 500000$，$-10^{18}\leq x_{i}\leq 10^{18}$，$0\leq r_{i}\leq 2\times 10^{18}$。

## 样例 #1

### 输入

```
4
1 1
5 1
6 5
15 15```

### 输出

```
32```

# AI分析结果



## 算法分类
**区间合并**

---

## 综合分析与结论

### 核心思路与难点
1. **问题本质**  
   每个炸弹的爆炸会引发连续区间的连锁反应，最终引爆的炸弹必然是一个连续的区间。关键在于快速计算每个炸弹的最终影响区间。

2. **核心算法流程**  
   - **线性区间扩展**：通过两次遍历（左→右维护左边界，右→左维护右边界）动态更新每个炸弹的最远影响范围。
   - **跳跃式更新**：利用已计算的相邻区间的结果，通过跳跃式合并快速扩展当前炸弹的影响区间。

3. **关键数据结构**  
   - `l[i]` 和 `r[i]`：记录每个炸弹的初始和最终影响区间的左右边界。
   - `range[i]`：动态更新炸弹的实际爆炸半径，考虑连锁反应后的扩展效果。

4. **时间复杂度**  
   通过跳跃合并的摊还分析，每个边界最多被合并一次，总时间复杂度为 **O(n)**。

---

## 题解清单（≥4星）

### 1. Krystallos（⭐⭐⭐⭐⭐）
**核心亮点**：
- 线性时间复杂度，代码简洁高效。
- 两次遍历维护左右边界，通过`range[i]`动态更新爆炸半径。
- 跳跃式合并避免重复计算。

**代码片段**：
```cpp
for (int i = 2; i <= n; i++) {
    while (l[i] > 1 && a[i] - a[l[i]-1] <= range[i]) {
        range[i] = max(range[i], range[l[i]-1] - (a[i] - a[l[i]-1]));
        l[i] = l[l[i]-1];
    }
}
for (int i = n-1; i >= 1; i--) {
    while (r[i] < n && a[r[i]+1] - a[i] <= range[i]) {
        l[i] = min(l[i], l[r[i]+1]);
        r[i] = r[r[i]+1];
    }
}
```

### 2. NaCly_Fish（⭐⭐⭐⭐）
**核心亮点**：
- 线段树优化建图，逻辑清晰。
- 通过虚拟节点将区间连边复杂度降为 **O(n log n)**。
- Tarjan缩点后维护区间端点。

**关键步骤**：
1. 线段树节点表示区间，叶子节点对应实际炸弹。
2. 每个炸弹向能覆盖的线段树节点连边。
3. 缩点后拓扑排序更新区间端点。

### 3. Holy_Push（⭐⭐⭐⭐）
**核心亮点**：
- 贪心连边，每个点仅连左右最近可引爆点。
- 缩点后维护区间端点，避免冗余计算。
- 通过单调栈预处理左右边界。

**优化思想**：
- 若左侧炸弹`j`能引爆`i`，则更远的`k`可通过`j`间接影响`i`，无需显式连边。

---

## 最优思路提炼

### 关键步骤
1. **初始区间**：每个炸弹的初始影响区间为自身。
2. **左扩展**：
   - 从左到右遍历，若当前炸弹能引爆左邻，则合并左邻的爆炸半径。
   - 更新左边界为左邻的左边界（跳跃式合并）。
3. **右扩展**：
   - 从右到左遍历，若当前炸弹能引爆右邻，则合并右邻的区间。
   - 更新右边界为右邻的右边界。

### 核心技巧
- **跳跃更新**：通过`l[i] = l[l[i]-1]`直接跳到已合并的区间，避免逐次遍历。
- **动态半径**：`range[i]`在合并时更新为`max(range[i], 左邻半径 - 距离)`。

---

## 同类型题与算法套路

### 相似问题
1. **区间合并问题**：如合并重叠区间（LeetCode 56）。
2. **连锁反应问题**：如多米诺骨牌效应（LeetCode 838）。
3. **跳跃游戏**：判断能否到达终点（LeetCode 55）。

### 通用解法
- **贪心区间扩展**：通过动态维护当前最大可达范围。
- **跳跃式更新**：利用已有结果快速合并相邻区间。

---

## 推荐练习题
1. **P1904 天际线问题**（区间覆盖与合并）
2. **P1886 滑动窗口**（区间最值维护）
3. **P2285 打鼹鼠**（动态规划与区间跳跃）

---

## 可视化设计

### 动画方案
1. **数据结构**：水平数轴显示炸弹坐标，不同颜色标记当前处理炸弹。
2. **关键步骤**：
   - **左扩展**：高亮当前炸弹和左邻，显示`l[i]`向左跳跃。
   - **右扩展**：高亮当前炸弹和右邻，显示`r[i]`向右跳跃。
3. **动态半径**：用半透明色块表示`range[i]`的实时变化。

### 复古像素风格
- **颜色方案**：16色调色板，炸弹用红色方块，区间用绿色线条。
- **音效**：
  - **合并成功**：8-bit 上扬音效。
  - **边界更新**：短促“滴”声。

### 交互控制
- **步进/暂停**：观察每次合并的细节。
- **速度调节**：慢速展示跳跃过程，快速自动播放整体效果。

```javascript
// 示例：Canvas绘制炸弹区间
function drawBomb(ctx, x, y, range, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x - 10, y - 10, 20, 20); // 炸弹图标
    ctx.strokeStyle = 'rgba(0,255,0,0.5)';
    ctx.beginPath();
    ctx.arc(x, y, range, 0, Math.PI * 2);
    ctx.stroke();
}
```

---

## 个人心得
- **调试教训**：初始未考虑连锁反应后的半径更新，导致区间计算错误。
- **优化顿悟**：发现跳跃式合并可大幅减少遍历次数，是线性的关键。
- **代码简洁**：避免复杂数据结构，优先寻找问题中的隐藏单调性。

---
处理用时：68.89秒
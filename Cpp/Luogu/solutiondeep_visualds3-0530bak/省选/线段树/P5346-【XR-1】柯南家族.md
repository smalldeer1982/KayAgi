# 题目信息

# 【XR-1】柯南家族

## 题目背景

xht37 最近沉迷于名侦探柯南。

在某集中，小兰又在怀疑柯南的真实身份了。为了让小兰不再怀疑，柯南编造出自己的家族背景来应对小兰的询问。

## 题目描述

这个家族一开始只有一个人，后来不断有人有了孩子，直到现在，这个家族有 $n$ 个人，第 $n$ 个人正是柯南。易知这个家族构成了一个 $n$ 个点的树形结构。

柯南为了使自己编造的家庭背景更加真实，他给家族中的每个人赋予了一个**智商值**。但是，一个人的**聪明程度**不仅仅只与他的**智商值**有关，还可能与他**祖先的聪明程度**及他**出生的时代**有关。

具体来说，在这个家族中，A 比 B 聪明**当且仅当** A 和 B 满足下面三种情况中的某一种：

1. A 的智商值比 B 的智商值高；
2. A 的智商值与 B 的智商值一样且 A 和 B 有不同的父亲，A 的父亲比 B 的父亲聪明；
3. A 的智商值与 B 的智商值一样且 A 和 B 的父亲是同一个人或某一个人没有父亲，A 比 B 后出生。

有一个很显然的结论是，这个家族中不会有两个人一样聪明。

柯南需要回答小兰的 $q$ 个询问。为了方便说明，假设第 $i$ 个出生的人编号为 $i$。

每个询问是下面三种情况中的某一种：

1. `1 x`：询问编号为 $x$ 的人在整个家族中聪明程度排第几。
2. `2 x k`：询问编号为 $x$ 的人及其祖先中第 $k$ 聪明的人的编号。
3. `3 x k`：询问编号为 $x$ 的人及其后代中第 $k$ 聪明的人的编号。

柯南还有许多案子要办，他不想在回答小兰的问题上浪费时间，他希望你能编程帮他回答小兰的所有询问。

## 说明/提示

【样例说明】

形成的树如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/eie1mrxb.png)

首先比较编号为 $2,3$ 的两个人，由于** $3$ 号的智商值与 $2$ 号的智商值一样且他们的父亲是同一个人，$3$ 号比 $2$ 号后出生**满足第 $3$ 种情况，因此 $3$ 号比 $2$ 号聪明。

再比较编号为 $4,5$ 的两个人，由于** $4$ 号的智商值与 $5$ 号的智商值一样且他们有不同的父亲，$4$ 号的父亲 $3$ 号比 $5$ 号的父亲 $2$ 号聪明**满足第 $2$ 种情况，因此 $4$ 号比 $5$ 号聪明。

再比较编号为 $1,5$ 的两个人，由于** $5$ 号的智商值与 $1$ 号的智商值一样且 $1$ 号没有父亲，$5$ 号比 $1$ 号后出生**满足第 $3$ 种情况，因此 $5$ 号比 $1$ 号聪明。

再根据第 $1$ 种情况比较编号为 $2,4$ 的两个人，可对 $5$ 人的聪明程度排序：$3 > 2 > 4 > 5 > 1$。

【数据规模与约定】

一共 $10$ 个测试点。

对于前 $20\%$ 的数据，$1 \le n, q \le 10 ^ 3$，每个测试点 $7$ 分，时限 1s。

对于另 $20\%$ 的数据，保证一个人最多只有一个儿子，每个测试点 $9$ 分，时限 4s。

对于另 $20\%$ 的数据，$1 \le n, q \le 10 ^ 5$，每个测试点 $9$ 分，时限 1.5s。

对于另 $20\%$ 的数据，保证只有第一种询问，每个测试点 $12$ 分，时限 1.5s。

对于 $100\%$ 的数据，$1 \le n, q \le 5 \times 10 ^ 5$，$1 \le a_i \le 10 ^ 9$，每个测试点 $13$ 分，时限 2.5s。

## 样例 #1

### 输入

```
5 11
1 1 3 2
1 2 2 1 1
1 1
1 2
1 3
1 4
1 5
2 4 1
2 5 3
3 1 1
3 1 2
3 1 3
3 1 4```

### 输出

```
5
2
1
3
4
3
1
3
2
4
5```

# AI分析结果



## 算法分类
**树上后缀数组 (Suffix Array on Tree)**

## 题解思路与解决难点

### 核心思路
1. **排序规则转化**：将题目中的三层比较规则转化为树上节点的字典序比较。通过树上后缀数组（SA）的倍增排序方法，为每个节点赋予唯一的排名。
2. **倍增预处理**：预处理每个节点的祖先链，通过比较智商值和祖先链的字典序，使用类似后缀数组的倍增法进行排序。
3. **主席树处理查询**：对祖先路径和子树分别建立主席树，支持查询路径或子树中的第k大。

### 难点对比
- **暴力排序**：直接模拟比较规则会导致O(n²)复杂度，无法处理大规模数据。
- **树上SA**：通过倍增和哈希优化比较过程，将复杂度降至O(n log n)。
- **替罪羊树**：动态维护节点的权值实现排序，但实现复杂且需处理精度问题。

## 题解评分 (≥4星)
1. **xht (5星)**  
   - **思路清晰**：详细推导树上SA的实现，结合倍增和哈希。
   - **代码规范**：提供完整std代码，结构清晰。
   - **优化显著**：O(n log n)复杂度，适合大规模数据。

2. **dsidsi (4星)**  
   - **代码简洁**：使用替罪羊树实现动态排序，代码可读性较高。
   - **动态维护**：适合需要动态插入的场景，但精度处理需注意。

3. **Owen_codeisking (4星)**  
   - **思路独特**：后缀平衡树结合主席树，提供另一种高效实现。
   - **实现完整**：包含完整代码和调试思路，但逻辑较复杂。

## 最优技巧提炼
1. **树上倍增哈希**：通过预处理每个节点的2^k级祖先，快速比较两个节点的祖先链字典序。
2. **双关键字基数排序**：在SA构建中，先按次关键字（父节点排名）排序，再按主关键字（当前节点排名）排序。
3. **主席树路径维护**：对每个节点维护到根的主席树版本，实现O(log n)查询祖先路径第k大。

## 同类型题推荐
1. **P5353【模板】树上后缀排序** - 直接应用树上SA的模板题。
2. **P2633 Count on a tree** - 主席树维护路径第k大。
3. **P3302 [SDOI2013]森林** - 动态树结构下的路径查询。

## 可视化设计
### 动画方案
1. **树上比较过程**：
   - **高亮当前节点**：红色标记正在比较的两个节点。
   - **祖先链追踪**：绿色线条显示向上查找祖先的过程，直到发现智商差异。
   - **比较结果提示**：弹出文字说明触发哪种比较规则（如智商值更高、父亲更聪明等）。

2. **SA构建过程**：
   - **分步倍增**：左侧显示当前倍增步长w，右侧展示按次关键字排序后的临时数组。
   - **基数排序动画**：用柱状图展示每个桶的计数过程，动态显示元素分配到正确位置。

3. **主席树查询**：
   - **路径追踪**：蓝色高亮当前查询路径，黄色标记被跳过的子树。
   - **区间统计**：左右子树大小动态显示，红色进度条表示剩余k值。

### 复古像素风格
- **颜色方案**：16色调色板，节点用8x8像素方块表示，不同颜色区分智商层级。
- **音效设计**：
  - **正确比较**：8-bit上升音效（类似《超级马里奥》吃金币）。
  - **错误分支**：短促下降音效。
  - **查询完成**：经典过关音效（《塞尔达传说》宝箱开启）。

## 核心代码片段（树上SA）
```cpp
namespace SA {
    int sa[N], rk[N], rkk[N], tp[N], rk2[N], tx[N];
    inline void tsort(int *sa, int *rk, int *tp, int m) {
        // 基数排序实现
    }
    inline bool pd(int i, int t) {
        // 判断两个节点是否在倍增后仍相同
    }
    inline void main() {
        // 构建树上后缀数组
        for (int w = 1, t = 0; w < n; w <<= 1, ++t) {
            // 按次关键字排序
            for (int i = 1; i <= n; i++) rk2[i] = rkk[f[t][i]];
            tsort(tp, rk2, sa, n);
            // 按主关键字排序
            tsort(sa, rk, tp, p);
            // 合并生成新排名
        }
    }
}
```

## 个人心得
- **哈希冲突处理**：在实现树上SA时，需保证不同祖先链的哈希值唯一，采用双哈希或大质数模数避免冲突。
- **调试技巧**：对小型测试用例手动计算SA结果，验证倍增每一步的正确性。
- **性能优化**：预处理所有节点的2^k级祖先，使用指针优化内存访问模式。

---
处理用时：60.93秒
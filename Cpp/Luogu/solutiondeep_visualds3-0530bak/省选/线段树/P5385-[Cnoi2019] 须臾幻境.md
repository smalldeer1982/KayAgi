# 题目信息

# [Cnoi2019] 须臾幻境

## 题目背景

这曾今有一个凄婉哀伤的故事，但是被出题人删档弄丢了。

## 题目描述

你有一个无向图 $G( V, E )$, $E$ 中每一个元素用一个二元组 $( u, v )$ 表示。

现在把 $E$ 中的元素排成一个长度为 $|E|$ 序列 $A$。

然后给你 $q$ 个询问二元组 $( l, r )$,

表示询问 图 $ G'\big( V, \mathop{\bigcup}\limits_{ i \in [l, r] } \{A_i\} \big) $ 的联通块的个数。

## 说明/提示

Subtask1( 15% ): $|V|, |E|, q \le 5000$

Subtask2( 25% ): $t = 0$

Subtask3( 22% ): $|V| \le 10^4, |E|, q \le 3*10^4$

Subtask4( 38% ): 无特殊限制.

对于 100% 的数据保证, $|V| \le 10^5, |E| \le 2*10^5, q \le 10^5, t \in \{0,1\}$

## 样例 #1

### 输入

```
80 100 100 0
25 73
4 10
9 27
19 26
52 55
4 18
19 31
25 29
14 72
10 13
17 23
13 63
25 46
9 11
40 64
32 48
1 2
19 34
7 39
9 14
57 59
6 47
8 36
40 66
15 67
66 76
21 49
15 38
13 25
4 61
6 32
52 58
1 12
26 44
12 68
1 37
2 45
5 22
47 77
21 60
7 28
29 69
10 78
39 43
11 50
5 6
76 79
5 7
64 70
27 33
1 51
15 75
19 24
46 56
1 3
30 42
23 35
28 57
21 41
11 53
61 65
13 15
28 30
20 49
6 8
1 5
18 40
1 9
34 62
7 16
46 54
56 74
1 17
16 20
11 71
7 19
3 4
13 21
2 80
28 52
29 7
55 27
6 71
46 27
2 68
50 75
37 41
17 13
62 57
72 51
1 54
49 33
1 14
58 29
11 53
1 38
17 46
78 33
1 47
61 5
76 91
99 29
64 67
65 32
85 8
77 57
62 19
42 37
51 41
57 71
79 63
9 17
21 16
87 43
1 77
53 37
38 37
25 69
1 1
97 72
27 31
1 95
66 29
29 63
27 74
18 63
73 11
63 81
33 46
85 19
91 78
15 66
36 89
61 63
21 9
59 23
5 61
41 59
97 79
21 41
81 51
33 57
49 27
37 71
1 9
59 73
16 6
53 41
61 37
3 88
43 43
11 3
41 27
43 30
67 5
1 33
67 15
26 35
21 45
7 65
1 41
25 82
51 4
70 60
15 1
87 77
21 83
63 51
46 43
1 41
99 28
41 17
11 44
45 56
8 31
81 43
37 71
69 6
79 75
1 46
6 75
29 34
21 21
61 39
90 26
76 88
77 41
71 53
25 71
71 43
99 88
5 41
15 51
41 61
37 86
14 47
70 35
81 3
98 4
25 1
```

### 输出

```
64
15
76
46
5
59
36
74
69
65
63
71
74
35
3
63
78
35
79
54
75
1
42
45
32
34
17
61
66
13
66
28
28
77
67
43
23
61
61
59
49
55
57
45
71
65
69
67
55
2
79
71
65
66
17
47
27
70
55
21
39
22
32
69
65
69
17
67
76
39
15
55
46
68
56
41
45
16
75
34
10
74
79
57
18
67
43
61
33
51
68
43
43
59
30
46
44
2
2
55
```

# AI分析结果



## 算法分类
**LCT + 主席树**

---

## 题解思路与核心难点

### 核心思路
1. **生成森林边数与连通块关系**  
   图的连通块数 = 点数 - 生成森林边数。维护任意生成森林边数即可求解。

2. **LCT动态维护最大生成树**  
   - 将边按顺序加入，若形成环则删除环上最早加入的边。  
   - 用虚点表示边（点权为边编号），维护最小边权以实现动态替换。

3. **主席树统计有效边**  
   - 对每个右端点r，记录其对应生成树中包含的边。  
   - 查询时统计区间[l, r]内未被删除的边数。

### 解决难点
- **LCT维护边权**：将边转化为虚点，点权为边编号，维护链上最小值。
- **强制在线处理**：通过主席树维护历史版本，实现任意区间查询。
- **自环处理**：自环边直接标记为无效，不参与生成树计算。

---

## 题解评分（≥4星）

### lhm_ (⭐⭐⭐⭐⭐)
- **亮点**：代码结构清晰，LCT与主席树结合逻辑明确，处理自环直接跳过。

### Fuyuki (⭐⭐⭐⭐)
- **亮点**：代码简洁高效，注释详细，特别强调自环处理与主席树查询逻辑。

### strcmp (⭐⭐⭐⭐)
- **亮点**：代码精简，LCT操作封装良好，主席树动态更新逻辑直观。

---

## 最优思路与技巧

### 关键思路
- **边权转虚点**：将边视为虚点，点权为边编号，LCT维护链最小值。
- **动态替换策略**：保证生成树边尽可能晚被删除，确保查询区间内边数最大化。
- **主席树二维数点**：统计区间[l, r]内有效边数，时间复杂度O(log m)。

### 技巧提炼
- **自环直接跳过**：若边连接同一顶点，不参与生成树计算。
- **强制在线调整**：通过公式 `l = (l + ans) % m + 1` 处理加密输入。

---

## 同类型题与套路

### 类似算法套路
- **动态图连通性**：LCT维护生成树，处理边增删。
- **历史版本查询**：主席树维护时间轴上的状态变化。

### 推荐题目
1. **P4219 [BJOI2014]大融合**（LCT维护子树大小）
2. **P2147 [SDOI2008]洞穴勘测**（LCT基础操作）
3. **BZOJ3514**（原题，动态生成树统计）

---

## 可视化与算法演示

### 动画设计
1. **LCT动态维护**  
   - **像素风格**：顶点为绿色方块，边虚点为黄色方块，当前操作边高亮红色。
   - **操作演示**：插入新边时，若形成环，找到最小边（蓝色闪烁）并删除。

2. **主席树更新**  
   - **网格绘制**：每条边对应网格行，时间轴为列，有效边标记为金色像素点。
   - **区间查询**：绿色框选区间[l, r]，统计金色点数量。

### 交互功能
- **步进控制**：单步执行LCT的link/cut操作，观察生成树变化。
- **音效提示**：成功插入边（清脆音效），删除边（低沉音效），查询完成（胜利音效）。

---

## 代码实现（核心片段）

### LCT维护生成树
```cpp
// LCT维护边权最小值（虚点）
void pushup(int x) {
    mn[x] = min(val[x], min(mn[ch[x][0]], mn[ch[x][1]]));
}

// 插入边i，处理替换
if (findroot(u) == findroot(v)) {
    int p = query_min(u, v); // 找到环上最早边
    cut(e[p].u, p + n); 
    cut(e[p].v, p + n);
    modify主席树(p, -1); // 标记删除
}
link(u, i + n); 
link(v, i + n);
```

### 主席树查询
```cpp
// 查询区间[l, r]有效边数
int query(int r, int l) {
    return n - 主席树.query(rt[r], l, r);
}
```

---

## 个人心得
- **调试教训**：LCT的`cut`操作需确保边存在，否则会导致生成树错误。
- **顿悟点**：主席树维护的是“每个右端点对应的边状态”，而非时间轴，简化了查询逻辑。

---
处理用时：61.40秒
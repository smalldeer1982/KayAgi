# 题目信息

# 【模板】线段树分裂

## 题目描述

给出一个可重集 $a$（编号为 $1$），它支持以下操作：

`0 p x y`：将可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值移动到一个新的可重集中（新可重集编号为从 $2$ 开始的正整数，是上一次产生的新可重集的编号+1）。

`1 p t`：将可重集 $t$ 中的数放入可重集 $p$，且清空可重集 $t$（数据保证在此后的操作中不会出现可重集 $t$）。

`2 p x q`：在 $p$ 这个可重集中加入 $x$ 个数字 $q$。

`3 p x y`：查询可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值的个数。

`4 p k`：查询在 $p$ 这个可重集中第 $k$ 小的数，不存在时输出 `-1`。

## 说明/提示

对于 $30\%$ 的数据，$1\leq n \leq {10}^3$，$1 \le m \le {10}^3$；  
对于 $100\%$ 的数据，$1 \le n \le 2 \times {10}^5$，$1 \le x, y, q \le m \le 2 \times {10}^5$。保证数据合法。

不开 `long long` 见祖宗！！

---

题面 by @[Limit](https://www.luogu.com.cn/user/86625)

std by @[Limit](https://www.luogu.com.cn/user/86625)（线段树分裂）

验题 by @[Froggy](https://www.luogu.com.cn/user/100285)（平衡树，不过合并的复杂度假掉了，倒数第二个测试点就是 hack 数据）

数据 by @[Froggy](https://www.luogu.com.cn/user/100285)

## 样例 #1

### 输入

```
5 12
0 0 0 0 0
2 1 1 1
2 1 1 2
2 1 1 3
3 1 1 3
4 1 2
2 1 1 4
2 1 1 5
0 1 2 4
2 2 1 4
3 2 2 4
1 1 2
4 1 3```

### 输出

```
3
2
4
3
```

# AI分析结果



# 【模板】线段树分裂

## 唯一算法分类
线段树分裂与合并

## 综合分析与结论

### 题解思路与核心难点
本题需要维护多个可重集，支持分裂、合并、插入、查询等操作。核心在于动态开点线段树的**分裂**与**合并**：
1. **合并**：递归合并两棵线段树的对应节点，若一方为空则直接返回另一方。时间复杂度均摊 O(n log n)
2. **分裂**：类似 FHQ Treap，根据左子树大小判断分裂方向，递归处理左右子树。单次操作 O(log n)
3. **动态开点**：通过节点池管理内存，避免空间浪费
4. **关键变量**：`val[]` 存储区间和，`ch[][]` 存储左右子节点指针

### 可视化设计要点
1. **动画演示**：用 Canvas 绘制线段树结构，分裂时高亮移动的区间（红色边框），合并时用绿色箭头表示节点合并
2. **像素风格**：节点用 16x16 像素方块表示，不同颜色区分操作类型（分裂红、合并绿）
3. **步进控制**：可暂停/继续，拖拽进度条观察每一步递归过程
4. **音效反馈**：分裂时播放 "blip" 音效，合并时播放 "click" 音效

## 题解清单（4星及以上）

### 1. ix35 题解（4.5星）
**亮点**：
- 完整推导线段树合并的均摊复杂度
- 提供分裂示意图与代码注释
- 代码含垃圾回收优化

**核心代码**：
```cpp
int merge(int x, int y) {
    if (!x||!y) return x+y;
    val[x] += val[y];
    ch[x][0] = merge(ch[x][0], ch[y][0]);
    ch[x][1] = merge(ch[x][1], ch[y][1]);
    del(y);
    return x;
}
```

### 2. cyffff 题解（4星）
**亮点**：
- 用三张图展示分裂过程
- 分操作类型详细讲解实现
- 提供合并复杂度证明思路

**分裂函数**：
```cpp
void split(int x, int &y, ll k) {
    if (!x) return;
    y = newnode();
    ll v = val[ch[x][0]];
    if (k > v) split(ch[x][1], ch[y][1], k-v);
    else swap(ch[x][1], ch[y][1]);
    if (k < v) split(ch[x][0], ch[y][0], k);
    val[y] = val[x] - k;
    val[x] = k;
}
```

### 3. Limit 题解（4星）
**亮点**：
- 手绘分裂示意图
- 实现节点删除池优化空间
- 析构函数自动回收内存

**析构函数**：
```cpp
~split_segment_tree(){
    de(root); // 递归删除所有节点
}
void de(node*&p){
    if(p==null) return;
    de(p->l), de(p->r);
    delete p;
}
```

## 最优思路提炼
1. **分裂三步法**：
   - 若全包含直接移动子树
   - 递归处理左右子树
   - 更新分裂后两树的区间和
2. **合并优化**：
   - 优先复用空树节点
   - 合并后立即删除废弃节点
3. **内存管理**：
   - 使用节点池(stk[])回收删除的节点
   - 动态开点时优先从池中取节点

## 相似题目推荐
1. P4556 [线段树合并] 树上路径众数
2. P2824 [排序操作] 利用分裂合并实现O(n log n)排序
3. CF558E 通过分裂维护字符串排序

## 可视化代码片段（JS）
```javascript
// 绘制线段树节点
function drawNode(x, y, val, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y, 16, 16);
    ctx.fillStyle = '#000';
    ctx.fillText(val, x+2, y+12);
}

// 分裂动画步骤
function animateSplit(p, q, l, r) {
    if (!p) return;
    if (l <= currL && currR <= r) { // 全包含
        playSound('split');
        drawNode(...getPos(q), val[p], '#f00');
        return;
    }
    // 递归绘制左右子树
    animateSplit(lc[p], lc[q], l, mid);
    animateSplit(rc[p], rc[q], mid+1, r);
}
```

## 个人调试心得
- **节点回收**：忘记重置`ch[][]`导致合并出错，后增加`delnode()`统一清理
- **分裂边界**：未处理`k=0`的情况导致RE，增加`if(k<=0)return`
- **复杂度验证**：对1e5随机数据测试，合并次数与节点数成线性关系

---
处理用时：71.51秒
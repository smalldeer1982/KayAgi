# 题目信息

# 失昼城的守星使

## 题目背景

> 月伏潮汐生，星染万屿寂，无晦明之变化者，是为失昼。   ————《失昼城手札·起源》

失昼城四面环海，建城于7325年前。

失昼城没有黑夜白天的变化，一轮明月自建城伊始就挂在天空，故名失昼。


失昼城城主月凌霜，掌控着失昼城的守星塔，守星塔在终日无昼的失昼城中作为照明的灯塔，一直是城里人们的精神寄托，她的另一个身份是失昼城的守星使，比起作为城主，月凌霜更喜欢守着守星塔。

失昼城的特殊环境导致其空间异常不稳定，根据失昼城城史记载，七千多年历史的失昼城，其和平的时间总共不超过三百年，其他大部分时间失昼城局部地区都在空间风暴的笼罩之下，依托于特殊空间存在的守星塔，同时兼具着向人们传递信息的功能，在不稳定的空间影响下，这是唯一能够维持信号稳定的方法。



## 题目描述

失昼城共由$N$座岛屿组成，由$N-1$条传递信息的空间通道联通。

作为失昼城的守星使，月凌霜具有部署守星塔的能力，具体而言，为了依靠特殊空间波动向每个有居民居住的岛屿传递消息，月凌霜可以任意数量地部署守星塔，每座岛屿只能部署一座守星塔，**但是同一时刻所有部署的守星塔必须依靠空间通道连成一条链**。

失昼城常年受到空间风暴的困扰，常常会出现某座岛屿遭受空间风暴，岛上全体居民被迫离开岛屿，此时，**守星塔不再需要向该地传输消息**，等到空间风暴散去，居民重新回到这里，**守星塔才需要恢复向该地的信息传输**。

由于空间波动的干扰，守星塔传递消息必须依靠联通岛屿的空间通道完成，具体而言，如果一座守星塔要向一座岛屿传递消息，**其消耗的能量为该座守星塔所处的岛屿到需要接收消息的岛屿的所有空间通道能耗总和**，当然，如果一座守星塔向自身所处的岛屿发送消息，则不需要消耗能量，守星塔对岛屿传递消息的信号波动互相独立，也就是说，**每座守星塔对于每座岛屿的能量传输互不干扰**。

作为城主兼守星使，月凌霜近期正在研究怎样部署守星塔才能使消息传递所消耗的能量最小，现在月凌霜已经找到了记载失昼城七千多年来空间风暴的爆发情况和当时失昼城的守星塔部署的资料，由于历史过于久远，每次能量的消耗情况已经不得而知，现在月凌霜希望你帮助她还原这些史料，具体详见输入格式。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/74843.png)

特殊性质$1$：$v_{i}=u_{i}+1$

特殊性质$2$：月凌霜所有的询问的$x$和$y$相同。

特殊性质$3$：月凌霜所有的询问的$x=1$。

对于所有的$w_{i}$，保证$0$<=$w_{i}$<=$10^{5}$

对于$100\%$的数据，保证$n,m\leq 200000,0\leq Type\leq 7$.

样例1解释：

![](https://cdn.luogu.com.cn/upload/pic/74831.png)

初始图像如左图。

对于第一个询问如中图，有$2,3,5$有居民，所以$ans_2=ans_3=0,ans_5=7.$所以$ans=7$.

对于第二组询问如右图，$ans_2=2+3=5,ans_3=0,ans_5=7,$,因此$ans=7+5=12$.

样例2解释：

![](https://cdn.luogu.com.cn/upload/pic/74836.png)

初始图如左上。

询问$1$点如图右上，存在$1,2,3,6$有居民。
$ans_1=0,ans_2=3,ans_3=5,ans_6=8+2=10.$因此$ans=3+5+10=18$

1操作后所有有居民点如左下。

接下来的操作图为右下，同上有$ans_1=0,ans_2=3,ans_3=0,ans_5=9,ans_6=0$,所以$ans=3+9=12$.

## 样例 #1

### 输入

```
5 2 0
1 2 2
1 3 3
4 3 2
5 3 7
0 1 1 0 1
2 2 4
2 4 3```

### 输出

```
7
12```

## 样例 #2

### 输入

```
6 3 0
2 1 3
3 1 5
4 1 2
6 4 8
4 5 9
1 1 1 0 0 1
2 1 1
1 5
2 3 6```

### 输出

```
18
12```

# AI分析结果



## 唯一算法分类  
树链剖分 + 线段树维护路径信息

---

## 综合分析与结论  
### 核心算法流程  
1. **距离公式拆解**：将黑点到链的距离拆解为 $\sum (dis_i - 2 \cdot dis_{lca})$ 形式，其中 $dis_i$ 是黑点到根的距离，$dis_{lca}$ 是黑点与链的最近公共祖先距离  
2. **树链剖分**：将树结构转换为链式结构，便于用线段树进行路径操作  
3. **四重维护**：  
   - $s_i$（子树黑点数量）  
   - $sd_i$（子树黑点深度和）  
   - $d_is_i$（深度×子树黑点数量）  
   - $d_{fa_i}s_i$（父节点深度×子树黑点数量）  
4. **动态更新**：翻转颜色时沿路径更新四个线段树的值  

### 可视化设计要点  
**动画方案**：  
1. 树结构采用层次布局展示，当前查询链用红色高亮  
2. 线段树节点用不同颜色区分维护的四个变量（如蓝-数量、绿-深度和）  
3. 更新操作时：  
   - 沿树链路径逐段闪烁黄色边框  
   - 对应线段树节点同步显示数值变化（+/- 增量数值）  
4. 查询操作时：  
   - 显示公式中各部分计算结果（漂浮文字提示）  
   - 用蓝色光晕标记当前计算的 LCA 节点  

**复古像素风格**：  
- 使用 8-bit 调色板（#1A1A1A 背景，#FFD700 树链，#00FF00 线段树有效区）  
- 线段树节点用 16×16 像素块表示，数值变化时播放 8-bit "blip" 音效  
- 自动演示模式下，算法流程以 500ms/步的速度推进，可随时暂停单步观察  

---

## 题解清单 (≥4星)  
### 1. EndSaH 题解（★★★★★）  
**亮点**：  
- 将距离公式拆解为 $\sum dis_i + cnt \cdot dis_{lca} - 2 \cdot sum_{lca}$ 的简洁形式  
- 利用单线段树维护路径标记，代码量仅 120 行  
- 关键代码段：  
```cpp  
LL Query_chain(int u, int v) { // 路径和查询  
    LL res = 0;  
    while(top[u] != top[v]) {  
        if(dep[top[u]] < dep[top[v]]) swap(u, v);  
        res += Ask(dfn[top[u]], dfn[u]);  
        u = fa[top[u]];  
    }  
    if(dep[u] > dep[v]) swap(u, v);  
    return res + Ask(dfn[u] + 1, dfn[v]);  
}  
```

### 2. Graphcity 题解（★★★★☆）  
**亮点**：  
- 维护四棵线段树处理复杂公式项  
- 分类讨论 LCA 在子树内外的两种情况  
- 调试心得：通过绘制贡献表验证公式推导正确性  

---

## 同类型题推荐  
1. **P4211 [LNOI2014]LCA**（路径标记求 LCA 深度和）  
2. **P3384 【模板】树链剖分**（路径修改/查询基础模板）  
3. **P2486 [SDOI2011]染色**（路径颜色段维护）  

---

## 核心代码实现  
**EndSaH 题解关键片段**：  
```cpp  
void Oper(int x) { // 翻转颜色操作  
    if(vis[x]) {  
        sum -= HLD::dis[x], --cnt;  
        vis.reset(x), HLD::Add_root(x, -1);  
    } else {  
        sum += HLD::dis[x], ++cnt;  
        vis.set(x), HLD::Add_root(x, 1);  
    }  
}  

LL Query(int x, int y) {  
    int lca = HLD::LCA(x, y);  
    LL tmp = sum + cnt * HLD::dis[lca] - (HLD::Query_chain(1, lca) << 1);  
    LL minus = HLD::Query_chain(x, y);  
    return tmp - minus;  
}  
```

**可视化 JS 片段**（路径高亮）：  
```javascript  
function highlightPath(u, v) {  
    while(u != v) {  
        if(depth[top[u]] < depth[top[v]]) [u, v] = [v, u];  
        ctx.strokeStyle = "#FF0000";  
        ctx.lineWidth = 3;  
        drawLine(nodePos[u], nodePos[top[u]]);  
        u = father[top[u]];  
    }  
    ctx.strokeStyle = "#00FF00";  
    drawLine(nodePos[u], nodePos[v]);  
}  
```

---

## 个人心得摘录  
**EndSaH 调试经验**：  
> "最初忘记处理 LCA 到根的路径段（dfn[x]+1），导致贡献计算错误。通过构造链式数据（1-2-3-4-5）单步跟踪发现缺失+1修正项。"

**Graphcity 优化技巧**：  
> "将 d_{fa_i}s_i 与 d_is_i 分开维护，避免每次计算时重复遍历子树，使时间复杂度稳定在 O(log²n)"

---
处理用时：65.57秒
# 题目信息

# 最小mex生成树

## 题目背景

这是一道经典题。

## 题目描述

给定 $n$ 个点 $m$ 条边的无向连通图，边有边权。  

设一个自然数集合 $S$ 的 $\text{mex}$ 为：最小的、没有出现在 $S$ 中的自然数。  

现在你要求出一个这个图的生成树，使得其边权集合的 $\text{mex}$ 尽可能小。

## 说明/提示

【数据范围】   
- 对于 $20\%$ 的数据，$1\le n \le 100$，$1\le m \le 200$。
- 对于 $50\%$ 的数据，$1\le n \le 2000$，$1\le m \le 3000$。
- 对于 $80\%$ 的数据，$1\le n \le 10^5$，$1\le m \le 2\times 10^5$。
- 对于 $100\%$ 的数据，$1\le n \le 10^6$，$1\le m \le 2\times 10^6,0\le w \le 10^5$。

输入数据规模较大，建议使用高效的读入方式。

## 样例 #1

### 输入

```
3 3
1 2 0
2 3 1
3 2 2
```

### 输出

```
1```

# AI分析结果



**唯一算法分类**  
线段树分治

---

### **题解思路、算法要点与解决难点**

**核心思路**  
题目要求找到生成树的边权集合的最小mex。关键观察是：若答案mex为x，则删除所有边权为x的边后，剩余边必须能形成生成树。通过枚举x并验证其可行性，结合分治和可撤销并查集优化查询效率。

**算法流程**  
1. **分治框架**：将权值区间分治处理。对当前区间[l, r]，递归检查左半和右半能否作为答案。
2. **并查集维护**：使用可撤销并查集动态维护连通性。每次递归前将不属于当前处理区间的边加入，回溯时撤销操作。
3. **剪枝优化**：一旦发现当前区间可能的最小解，立即终止搜索。

**解决难点**  
- **高效枚举**：直接枚举x会导致O(mw)复杂度。分治将问题分解为O(log w)层，每层处理O(m)条边。
- **动态连通性**：可撤销并查集支持合并与回退，避免重复计算。路径压缩难以撤销，需采用按秩合并策略。

---

### **题解评分 (≥4星)**

1. **djh123 (5星)**  
   - **亮点**：分治实现简洁，直接递归处理权值区间，优先左半缩小答案。
   - **关键代码**：通过`pos`指针控制边范围，利用栈记录合并操作实现撤销。

2. **Rorschachindark (4星)**  
   - **亮点**：线段树显式构建区间，每条边插入到排除对应权值的区间。
   - **优化点**：代码结构清晰，但线段树节点存储边集合可能增加内存。

3. **s_r_f (4星)**  
   - **亮点**：空间优化至O(n+m)，预处理边权分布缩小分治范围。
   - **难点**：代码紧凑，需仔细处理权值区间与边的映射。

---

### **最优思路提炼**

1. **分治权值区间**：将权值划分为[l, mid]和[mid+1, r]，优先处理左半以尽早找到最小解。
2. **可撤销并查集**：按秩合并记录操作栈，递归回溯时回退合并步骤，维护状态一致性。
3. **边排序预处理**：按权值排序后，通过指针快速定位当前区间对应的边集合。

**代码片段 (djh123)**  
```cpp
void solve(int l, int r, int pos) {
    if(l == r) { 
        if(siz[find(1)] == n) { cout << l; exit(0);} 
        return ; 
    }
    int mid = (l + r) >> 1;
    vector<int> v;
    // 处理权值>mid的边，递归左半区间
    for(; e[pos].w <= r && pos <= m; ++pos) 
        if(e[pos].w > mid) v.push_back(unit(e[pos].u, e[pos].v));
    solve(l, mid, tmp);
    // 撤销操作，处理权值<=mid的边，递归右半区间
    for(; e[pos].w <= mid && pos <= m; ++pos) 
        v.push_back(unit(e[pos].u, e[pos].v));
    solve(mid + 1, r, pos);
}
```

---

### **相似题目推荐**

1. **P3366 最小生成树** - 基础Kruskal算法练习。
2. **P1197 星球大战** - 逆向并查集与连通块维护。
3. **P5785 动态连通性** - 线段树分治处理动态图连通性问题。

---

### **可视化设计**

**动画方案**  
- **分治树展示**：左侧显示权值区间划分树，当前处理区间高亮为黄色。
- **并查集操作**：右侧网格表示节点，合并时连线变绿，回退时变红。音效伴随每次合并/撤销。
- **复古像素风**：使用8-bit风格，合并时播放“哔”声，找到解时播放胜利音效。

**交互功能**  
- **步进控制**：按钮控制分治步骤，可单步观察区间划分与并查集变化。
- **自动演示**：AI模式自动执行分治流程，速度可调。

---

### **核心算法演示**

1. **分治过程**  
   - 初始区间[0, max_w+1]，递归分割为左右子区间。
   - 每次递归优先处理左半，若找到解则终止。

2. **并查集操作**  
   - 合并时记录操作栈，回溯时弹出栈顶恢复状态。
   - 合并动画：节点连线渐显，撤销时渐隐。

**示例步骤**  
- **Step 1**：处理区间[0,3]，权值>1的边加入，检查左半[0,1]。
- **Step 2**：撤销权值>1的边，加入权值<=1的边，处理右半[2,3]。

---

通过分治与可撤销结构的结合，将复杂度优化至O(m log m log w)，适用于大规模数据。

---
处理用时：106.29秒
# 题目信息

# 「ACOI2020」惊吓路径

## 题目背景

![T6](https://s2.ax1x.com/2020/01/12/lopZpq.png)

3 年 E 班的同学们赢得了去南方的冲绳小岛的机会，在渚打败了鹰冈之后，他们受杀老师的邀请参加“试胆大会”。

试胆大会在一个黑漆漆的洞窟里面进行。赤羽 業（Akabane Karma）现在和奧田 愛美站在洞窟的门口。突然，業想到了一个事情。。。

## 题目描述

杀老师告诉过他们，洞窟可以近似地看成 $n$ 个点的外向树，因为地形原因，所以一个点到另一个点的边是有方向的，且边的方向都是同向的。这棵树的树根为入度为 $0$ 的点。每个点都有一个惊吓值，给出每个点的惊吓值 $a_i$。

杀老师告诉他们，这个洞穴有很多惊吓路径。如果两个节点 $u,v$ 构成的路径是一条惊吓路径的话，满足以下条件：

- $v$ 一定在 $u$ 的子树中。

- $u, v$ 这条路径上的所有的点的惊吓值的或值 $\geq k$。

走过一条惊吓路径就会收到杀老师的惊喜大礼。杀老师已经提前准备好了惊喜大礼，但是業当然已经知道杀老师有一些下流的意图，更别说惊喜大礼的数量可能不够！杀老师已经承诺有多少条惊吓路径就有多少个惊喜大礼。業已经通过一些神奇的途径知道了杀老师准备的惊喜大礼的个数，现在他想知道有多少条惊吓路径，也就是杀老师最少需要准备惊喜大礼的个数。如果不够，他就会揭穿杀老师的意图。现在業当然想赚，好好捉弄一下杀老师。所以他~~作弊~~提前得到了杀老师的地图，想问这个图里面有多少条惊吓路径？

## 说明/提示

#### 样例解释 #1

![](https://cdn.luogu.com.cn/upload/image_hosting/lqu4ejku.png)

只有两条路径满足条件：

1. $3\to 1\to 2$，这条路径的所有点的惊吓值的或值是 $6\operatorname{or}5\operatorname{or}9=15$。

2. $1 \to 2$，这条路径的所有点的惊吓值的或值是 $5\operatorname{or}9=13$。

------------
#### 数据范围 
**本题采用捆绑测试**。

- Subtask 1（10 points）：$n \leq 5 \times 10^3$，$k \leq 10^5$。    
- Subtask 2（30 points）：对于任意一条边，$v=u+1$，$n \leq 10^6$，$k,a_i \leq 10^9$。     
- Subtask 3（20 points）：$n \leq 10^5$，$k,a_i \leq 10^9$。    
- Subtask 4（40 points）：$n \leq 5 \times 10^5$，$k,a_i \leq 10^9$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$，$1 \leq k,a_i \leq 10^9$。

------------
#### 提示
**第四个子任务中的测试点空间 256MB，其余子任务中的测试点空间 128MB。**

## 样例 #1

### 输入

```
5 10
5 9 6 4 2
3 1
3 4
1 2
1 5
```

### 输出

```
2```

## 样例 #2

### 输入

```
7 5
6 7 4 5 7 8 9
1 2
2 3
2 4
1 5
5 6
5 7
```

### 输出

```
16```

## 样例 #3

### 输入

```
8 5
4 3 2 5 6 7 6 2
1 2
1 5
2 3
2 4
5 6
5 7
6 8
```

### 输出

```
16```

# AI分析结果



## 算法分类
**树上倍增 + 链双指针特判**

---

## 题解思路与算法要点

### 核心思路
1. **或运算的单调性**：路径向上扩展时，或值不会减少。因此对于每个节点v，存在唯一最深的u，使得u到v路径或值≥k。贡献为u的深度（u的祖先到v的路径也满足条件）。
2. **倍增法**：预处理每个节点的2^i级祖先及其路径或值，通过跳跃快速找到满足条件的u。
3. **链结构特判**：链结构下可用双指针维护滑动窗口，动态计算或值，时间复杂度优化至O(n)。

### 解决难点
- **空间优化**：通过DFS栈维护当前路径的倍增数组，避免存储全部祖先信息（LanrTabe的题解）。
- **数据分治**：对链结构单独处理，使用ST表或双指针（zhengrunzhe、漠寒的题解）。
- **或运算的实时维护**：链上双指针滑动时，用位计数数组动态加减或值（yuzhechuan的题解）。

---

## 题解评分（≥4星）

1. **zhengrunzhe（5星）**  
   - **亮点**：完整处理树与链两种结构，Splay优化链查询，代码实现巧妙。  
   - **心路**：通过随机Splay维持平衡，极限卡过空间限制。

2. **LanrTabe（4.5星）**  
   - **亮点**：DFS栈维护倍增数组，空间优化到100MB，非递归DFS避免栈溢出。  
   - **关键代码**：用`f[i][Top]`动态更新当前路径的或值。

3. **yuzhechuan（4星）**  
   - **亮点**：双指针+位计数数组维护链或值，代码简洁高效。  
   - **核心逻辑**：`inc`和`dec`函数动态调整或值，时间复杂度O(n loga)。

---

## 最优思路提炼
1. **树上倍增法**  
   - 预处理每个节点的2^i祖先及路径或值。  
   - 从v向上跳跃，找到首个满足条件的u，贡献其深度。
   
2. **链双指针特判**  
   - 维护滑动窗口的或值，右指针扩展，左指针收缩，动态统计合法区间。

---

## 同类型题与算法套路
- **相似题目**：  
  - [CF 893F Subtree Minimum Query](https://codeforces.com/problemset/problem/893/F)（树上倍增+DFS序）  
  - [Luogu P3379 LCA](https://www.luogu.com.cn/problem/P3379)（倍增法求最近公共祖先）  
- **通用解法**：  
  - 对于路径单调性问题（如或、与、最大值），优先考虑向上跳跃的倍增法。

---

## 推荐题目
1. **P3304 [SDOI2013] 直径**（树上路径性质）  
2. **P4513 小白逛公园**（线段树维护区间或）  
3. **P4632 [APIO2018] 新家**（双指针+ST表）

---

## 可视化与算法演示

### 核心算法动画设计
1. **树上倍增跳跃**  
   - **颜色标记**：当前节点v为蓝色，跳跃路径高亮黄色，满足条件的u标红。  
   - **步进控制**：逐层展示跳跃2^i步的过程，右侧显示当前或值。

2. **链双指针滑动**  
   - **像素网格**：链节点排成一行，左右指针用绿色/红色方块，或值用二进制位显示。  
   - **音效**：指针移动时播放“滴”声，满足条件时触发“金币”音效。

### 复古游戏化实现
- **8位像素风格**：树节点用16x16像素块表示，路径用连线。  
- **Canvas绘制**：  
  ```javascript
  function drawNode(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * 30, y * 30, 24, 24); // 像素块间隔6px
  }
  ```
- **音效触发**：  
  ```javascript
  function playSound(freq) {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = freq;
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(0.1);
  }
  ```

---

## 关键代码片段
### 树上倍增（LanrTabe）
```cpp
void Calc(int x) {
    s[++Top] = x, f[0][Top] = c[x];
    for(int i=1; (1<<i)<=Top; ++i) // 动态更新当前路径的或值
        f[i][Top] = f[i-1][Top] | f[i-1][Top-(1<<(i-1))];
    int p = Top+1, v = 0;
    for(int i=19; i>=0; --i) // 逆序跳跃
        if((1<<i) < p && (f[i][p-1] | v) < k)
            v |= f[i][p-1], p -= 1<<i;
    Ans += p-1;
}
```

### 链双指针（yuzhechuan）
```cpp
void subchain() {
    for(int i=1, pt=0; i<=n; i++) {
        dec(val[i-1]); // 左指针右移
        while(pt+1 <=n && oum < k) inc(val[++pt]); // 右指针扩展
        if(oum < k) break;
        ans += n - pt + 1;
    }
}
```

---

## 个人心得摘录
> "出题人卡内存差评... 幸好链有特殊性质，双指针救场" —— yuzhechuan  
> **总结**：算法需兼顾通用与特例，空间优化常需创造性思维。

> "随机Splay到根，玄学AC" —— zhengrunzhe  
> **教训**：在严格卡常场景，随机化可能带来意外的高效。

---
处理用时：70.50秒
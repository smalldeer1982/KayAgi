# 题目信息

# 最优性剪枝

## 题目背景

Nauuo 是一名出题人。

众所周知，某些出题人非常懒，导致[随便爆搜](https://www.luogu.com.cn/discuss/show/185420)加上一个[最优性剪枝](https://www.luogu.com.cn/discuss/show/184641)就能通过。Nauuo 决定把这些 naive 的暴力都卡掉。

## 题目描述

Nauuo 决定卡一个暴力搜索程序，为此她构建了一组数据。为了简化题目，你将得到这组数据产生的搜索树 $T$。$T$ 中包含 $n$ 个节点，依次编号为 $1 \sim n$，其中 $1$ 号点是 $T$ 的根节点。一个节点的深度是它到 $1$ 号点的简单路径上的节点个数。

这个程序的伪代码如下

```cpp
answer := inf

procedure dfs(node,depth)
	if (node is leaf) 
		answer := min(answer,depth)
		return
	if (depth < answer)
		for i in children of node
			dfs(i,depth+1)

dfs(1,1)
```

其中，`:=` 表示赋值运算。

翻译成人话就是说，这个暴力搜索程序将**深度优先**地遍历这棵搜索树，当访问到一个叶节点时，这个程序将用这个叶节点的深度更新答案。

同时，这个程序有一个最优性剪枝，也就是说，当这个程序访问到任意一个深度等于答案的节点时，它将不会再访问这个节点的子节点。

然而，可怜的 Nauuo 并不知道这个程序在某个节点时访问自己子节点的顺序，因此她认为每个节点访问子节点的顺序都是在所有可能的情况中等概率随机的，显然，一共有 $\prod d_i!$ 种情况，其中 $d_i$ 表示 $i$ 号节点的子节点数量。

现在她想知道这个程序访问到的节点数量的期望，以确定这个程序会不会被自己的数据卡掉。

为了避免浮点误差，答案对 $998244353$ 取模。保证答案能被表示为最简分数 $\frac{p}{q}$，你只需要输出一个 $x (0\leq x < 998244353)$ 使得 $qx \equiv p \pmod {998244353}$。

## 说明/提示

#### 样例解释

第一组样例的真实答案为 $\frac{7}{2}$。

一共只有两种情况，如果 $1$ 号节点先遍历 $3$ 号节点，则程序将访问到搜索树中所有节点。如果 $1$ 号节点先遍历 $2$ 号节点，则 $4$ 号节点不会被访问到。

第二组样例中，每个非叶节点的子节点都是唯一的，因此只有一种可能的情况，所有节点都必然被访问到。

第三组样例的真实答案为 $\frac{94}{9}$。

---

#### 数据范围

**「本题采用捆绑测试」**

对于所有测试点，保证 $1 \leq n \leq 3\times 10^5$，$1 \leq p_i < i$。

$\text{Subtask 1 (11 pts)}$ $n \leq 9$。

$\text{Subtask 2 (18 pts)}$ $n \leq 100$。

$\text{Subtask 3 (19 pts)}$ $n\leq 10^3$。

$\text{Subtask 4 (4 pts)}$ $p_i = i-1$。

$\text{Subtask 5 (8 pts)}$ $p_i =\lfloor \frac{i}{2} \rfloor$。

$\text{Subtask 6 (40 pts)}$ 无特殊限制。

---

#### 提示

如果你不知道怎么对分数取模，可以参考[这里](https://www.luogu.com.cn/problem/P3811)。



## 样例 #1

### 输入

```
4
1 1 3```

### 输出

```
499122180```

## 样例 #2

### 输入

```
3
1 2```

### 输出

```
3```

## 样例 #3

### 输入

```
13
1 1 1 3 5 4 2 3 7 4 4 6```

### 输出

```
776412285```

# AI分析结果



---

### 算法分类
**树形动态规划 + 概率期望 + 数据结构优化**

---

### 题解思路与算法要点
1. **核心思想**  
   每个节点的访问概率等于其所有祖先在处理其所在分支时的概率乘积。通过预处理子树最小深度（val）和动态维护路径概率乘积，高效计算期望。

2. **关键步骤**  
   - **预处理 val**：自底向上计算每个节点的子树最小叶深度。
   - **子树排序**：对每个节点的子节点按 val 升序排序。
   - **树状数组优化**：维护区间乘法操作，动态调整概率系数。

3. **解决难点**  
   - **概率乘积的动态维护**：通过树状数组在遍历时调整区间乘法，避免重复计算。
   - **子节点顺序的影响**：排序后，每个子节点的访问顺序直接影响后续剪枝概率。

---

### 题解评分（≥4星）
1. **Zory 的题解（5星）**  
   - **亮点**：树状数组高效处理区间乘法，预处理排序清晰，代码可读性强。
   - **代码片段**：
     ```cpp
     namespace BIT {
         ll bit[N];
         void MUL(int l, int r, ll c) { mul(l,c), mul(r,invm(c)); }
         ll ask(int x) { ... }
     };
     void solve(int x) {
         add(ans, BIT::ask(dep[x]-1));
         // 调整树状数组区间乘法系数
     }
     ```

2. **Owen 的题解（4星）**  
   - **亮点**：提出线段树与倍增结合，优化路径查询，理论复杂度优秀。
   - **不足**：无完整代码，实现细节待补充。

---

### 最优思路与技巧
- **概率拆分与线性性**：将期望拆分为每个节点的访问概率之和。
- **子树最小深度预处理**：自底向上动态规划快速计算 val。
- **树状数组区间操作**：通过差分乘法高效维护路径乘积。

---

### 类似题目与算法套路
1. **期望线性性拆分**：CF280C（随机删除链的期望步数）。
2. **树形动态规划**：洛谷 P3177（树上分组背包）。
3. **数据结构优化路径乘积**：洛谷 P4211（离线路径查询）。

---

### 代码核心实现
```cpp
// 预处理 val 和子节点排序
void pre(int x) {
    val[x] = (son[x].empty() ? dep[x] : INF);
    for (int y : son[x]) pre(y), val[x] = min(val[x], val[y]);
    sort(son[x].begin(), son[x].end(), [&](int a, int b) { return val[a] < val[b]; });
}

// 树状数组维护区间乘法
namespace BIT {
    ll bit[N];
    void MUL(int l, int r, ll c) {
        mul(l, c), mul(r, invm(c));
    }
}

// 递归遍历树，调整概率系数
void solve(int x) {
    ans += BIT::ask(dep[x] - 1);
    for (int i = 0; i < son[x].size(); ++i) {
        int y = son[x][i];
        BIT::MUL(val_before, val_after, inv(i+1));
        solve(y);
        BIT::MUL(val_before, val_after, (i+1));
    }
}
```

---

### 可视化设计
**动画方案**：  
1. **像素风格树结构**：节点以 8-bit 方块表示，颜色深浅表示 val 值。
2. **动态高亮路径**：当前遍历路径（根到 x）以闪烁边框标记。
3. **概率乘积更新**：树状数组区间调整时，对应区间显示乘数并播放音效。
4. **自动演示模式**：按层遍历节点，展示 val 计算、子树排序、概率更新过程。

**交互设计**：  
- **控制面板**：暂停/继续、单步执行、速度调节。
- **音效**：区间更新时触发“滴答”声，节点访问时播放短音阶。

---

### 结论
通过拆分期望为节点概率之和，结合树形动态规划和树状数组优化，时间复杂度降至 O(n log n)。关键点在于预处理 val 和高效维护路径概率乘积。

---
处理用时：78.72秒
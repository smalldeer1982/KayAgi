# 题目信息

# 有趣的游戏

## 题目背景

小 A 和小 B 正在玩一个有趣的电脑游戏。

## 题目描述

游戏在一棵大小为 $n$ 的树上进行。其中每个点都有点权，第 $i$ 个点的点权为 $w_i$。

每一次系统会给出一条链，小 A 可以从这条链上找出两个**点权不同**的点 $x,y$，他的得分是 $w_x\bmod w_y$。然后小 B 会从**整棵树**中选取两个**小 A 没有选过**的点，计分方式同小 A。

为了保持游戏难度，系统有时会增加一个点的权值。

当然，小 A 会尽可能使自己得分最大，他想知道这个值是多少。同时，他想知道，在自己得分最大的情况下，小 B 的最大得分是多少。

## 说明/提示

样例解释：

第一次：小 A 选择点 $3$ 和点 $2$，得分为 $3\bmod 4=3$，小 B 选择点 $6$ 和点 $1$ 得分为 $4\bmod 5=4$。

第二次：小 A 选择点 $2$ 和点 $1$，得分为 $4\bmod 5=4$，小 B 选择点 $7$ 和点 $6$ 得分为 $3\bmod 4=3$。

第三次：小 A 选择点 $2$ 和点 $1$，得分为 $4\bmod 5=4$，小 B 选择点 $7$ 和点 $6$ 得分为 $3\bmod 4=3$。

第四次：第 $2$ 个点点权变为 $5$。

第五次：小 A 选择点 $5$ 和点 $1$，得分为 $1\bmod 5=1$，小 B 选择点 $6$ 和点 $2$ 得分为 $4\bmod 5=4$。

第六次：小 A 可以选的点只有 $1,2$ ，点权都是 $5$，没有可以选的方案。

**本题采用捆绑测试。**
| Subtasks |$n,q$  |特殊性质  |分数  |
| :----------: | :----------: | :----------: | :----------: |
|Subtask1  |$\leq10^3$  |无  |$10$  |
|Subtask2  |$\leq10^5$  |树的形态，点权随机  |$15$  |
|Subtask3  |$\leq10^5$  |最多有 $5$ 种不同的点权，且没有修改 |$15$  |
|Subtask4  |$\leq10^5$  |树为一条链，且第 $i$$(i>1)$ 个点的父亲为 $i-1$ |$25$  |
|Subtask5  |$\leq10^5$  |无  |$35$  |

对于所有数据 $1 \leq n,q \leq 10^5$，$1 \leq w_i \leq 10^4$，增加的数为不大于 $10^3$ 的正整数，且输入为一棵合法的树。**保证任何时候不同种类的数大于等于 $4$。**

## 样例 #1

### 输入

```
7
1 2
2 3
2 4
1 5
5 6
5 7
5 4 3 2 1 4 3
6
1 3 4
1 2 5
1 2 1
0 2 1
1 2 5
1 2 1```

### 输出

```
3 4
4 3
4 3
1 4
-1```

# AI分析结果



### 【唯一算法分类】
树链剖分 + 线段树 + 数据结构

---

### 【综合分析与结论】
#### 核心算法流程
1. **问题转化**：  
   通过数学推导得出，当 $w_y$ 为链上最大值且 $w_x$ 为严格次大值时，$w_x \bmod w_y$ 最大，此时结果即为次大值。  
   **证明**：若 $w_x < w_y$，则 $w_x \bmod w_y = w_x$；若 $w_x > w_y$，则结果必然小于 $w_y$，故最优解为次大值模最大值。

2. **树链剖分**：  
   将树拆分为重链，使得每条链的节点在 DFS 序中连续，便于线段树维护路径信息。

3. **线段树维护**：  
   每个线段树节点存储区间的**最大值**和**严格次大值**，合并子区间时需去重并排序。  
   **合并示例**：区间 A 的值为 `[5,4]`，区间 B 的值为 `[6,3]`，合并后最大值取 6，严格次大取 5。

4. **全局维护**：  
   使用 `multiset` 维护整棵树的所有权值，查询小 B 的答案时，先删除小 A 选中的两个值，再求剩余值的严格次大。

#### 可视化设计思路
1. **树结构动画**：  
   - 初始状态以**像素风格**绘制树形结构，不同颜色区分重链和轻边。  
   - 修改操作时，高亮目标节点并显示权值变化，同步更新线段树对应节点。  
   - 查询操作时，动态展示路径分解为多个重链的过程，合并线段树节点结果。

2. **关键步骤高亮**：  
   - **线段树合并**：用红色框标记当前合并的两个子区间，黄色闪烁显示最终选取的最大/次大值。  
   - **multiset 操作**：删除元素时显示元素消失动画，查询时用绿色箭头指向当前候选的严格次大值。

3. **复古音效设计**：  
   - 线段树节点更新时播放 8-bit "点击" 音效（频率 440Hz，时长 0.1s）。  
   - 查询到严格次大值时播放上升音阶（C4 → E4 → G4）。

---

### 【题解清单 (≥4星)】
1. **Alex_Wei（5星）**  
   - **亮点**：简洁的线段树合并逻辑，利用 `multiset` 高效处理全局删除与查询。  
   - **代码片段**：  
     ```cpp
     struct data{ int fi,se; };
     data mer(data a,data b){
         int fi=max(a.fi,b.fi);
         int se=max( a.fi==fi?a.se:a.fi, b.fi==fi?b.se:b.fi );
         return {fi,se};
     }
     ```

2. **Genius_Star（4星）**  
   - **亮点**：维护全局前四大值，避免多次查询 `multiset`。  
   - **难点**：合并前四大值时需多次排序去重，时间复杂度略高但正确性更强。

3. **Limit（4星）**  
   - **亮点**：自定义 `FMSM` 结构体合并严格次大值，逻辑清晰易扩展。  
   - **代码片段**：  
     ```cpp
     FMSM MergeFMSM(FMSM a,FMSM b){
         int fi = max(a.first_max, b.first_max);
         int se = (a.first_max != b.first_max) ? 
             max(min(a.first_max, b.first_max), max(a.second_max, b.second_max)) :
             max(a.second_max, b.second_max);
         return {fi, se};
     }
     ```

---

### 【最优思路与技巧提炼】
1. **严格次大值的维护**  
   - **去重技巧**：合并区间时先用 `sort` + `unique` 去重，再取前两大值。  
   - **数据结构选择**：优先用 `multiset` 而非平衡树，简化代码（见 Alex_Wei 的 `s.erase(s.find(val))` 操作）。

2. **树剖路径分解优化**  
   - **链式跳跃**：每次跳到当前链顶的父节点，将路径分解为 $O(\log n)$ 段连续区间。

3. **全局与局部分离**  
   - **分离处理**：小 A 的答案仅依赖路径，小 B 的答案依赖全局，二者通过 `multiset` 解耦。

---

### 【同类型题与算法套路】
1. **树剖 + 线段树维护极值**  
   - **套路**：路径查询最大值、最小值、第 K 大等。  
   - **例题**：  
     - [洛谷 P3384 - 树链剖分模板](https://www.luogu.com.cn/problem/P3384)  
     - [洛谷 P1505 - 旅游](https://www.luogu.com.cn/problem/P1505)

2. **动态维护集合极值**  
   - **套路**：插入、删除、查询严格次大值。  
   - **例题**：  
     - [洛谷 P2073 - 送花](https://www.luogu.com.cn/problem/P2073)

---

### 【推荐相似题目】
1. **P3384** - 树链剖分模板（路径修改与求和）  
2. **P1505** - 路径最大值与严格次大值维护  
3. **P3313** - 树剖 + 线段树维护多种属性（带颜色限制）

---

### 【个人心得摘录】
- **Alex_Wei**：  
  > “线段树合并时要注意重复值的情况，必须保证严格次大值不与最大值相等。”  
  > **启示**：合并逻辑中需显式判断 `a.fi == b.fi`，避免误选重复值。

- **Genius_Star**：  
  > “维护前四大值虽然增加了复杂度，但在某些数据分布下可以避免 multiset 的频繁删除。”  
  > **教训**：当权值种类较少时，直接维护多个极值比动态数据结构更优。

---

### 【可视化与算法演示】
#### 核心算法动画设计
1. **树结构绘制**  
   - **像素风格**：节点用 16x16 像素方块表示，重链用亮绿色边，轻边用灰色。  
   - **Canvas 初始化**：  
     ```javascript
     const canvas = document.getElementById('tree-canvas');
     const ctx = canvas.getContext('2d');
     ctx.fillStyle = '#2ecc71'; // 重链颜色
     ```

2. **线段树操作高亮**  
   - **合并过程**：用红色边框标记当前合并的两个区间，逐步显示排序去重后的结果。  
   - **代码片段**：  
     ```javascript
     function highlightMerge(node1, node2) {
         drawBorder(node1, 'red');
         drawBorder(node2, 'red');
         // 排序去重动画...
     }
     ```

3. **音效触发**  
   - **查询成功**：播放 `[600, 800, 1000] Hz` 的上升音调，模拟“找到答案”的反馈。  
   - **修改操作**：播放 `200Hz` 短促音效，增强操作感知。

#### 交互式演示
- **步进控制**：  
  ```html
  <button onclick="stepForward()">下一步</button>
  <input type="range" id="speed" min="1" max="10" onchange="setSpeed(this.value)">
  ```
- **自动演示模式**：  
  ```javascript
  let autoPlay = setInterval(() => {
      if (!algorithmStep()) clearInterval(autoPlay); 
  }, 1000 / speed);
  ```

---

### 【核心代码片段】
#### Alex_Wei 的线段树合并
```cpp
data query(int u, int v) {
    data res = {-1, -1};
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        res = mer(res, querySeg(dfn[top[u]], dfn[u]));
        u = fa[top[u]];
    }
    if (dep[u] > dep[v]) swap(u, v);
    return mer(res, querySeg(dfn[u], dfn[v]));
}
```

#### 全局 multiset 处理
```cpp
multiset<int> s;
void handleQuery(int u, int v) {
    auto [mx, sec] = query(u, v);
    s.erase(s.find(mx)); s.erase(s.find(sec));
    int ansB = *(--s.lower_bound(*s.rbegin()));
    s.insert(mx); s.insert(sec);
    printf("%d %d\n", sec, ansB);
}
```

---
处理用时：89.94秒
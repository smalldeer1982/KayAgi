# 题目信息

# 查找 Search

## 题目背景

>   也许，同学间最好的结局就是朋友吧。

$\mu ry$ 是一个可爱的女孩子。

在她所住的小区里有排成一排的 $n$ 个垃圾桶，从左至右第 $i$ 个垃圾桶里都装着编号为 $a_i$ 的垃圾。

$\mu ry$ 不喜欢无序，于是就想把社区里编号和为 $w$ 的垃圾都清在一起。

但是调皮的 $\text{LeverImmy}$ 可能会把某个垃圾桶里的垃圾偷换成另一种。

生气的 $\mu ry$ 想考考 $\text{LeverImmy}$ 一个区间 $[l, r]$ 内是否存在编号和为 $w$ 的垃圾。

但 $\text{LeverImmy}$ 也不会解决这个问题，于是他找到了聪明的你。


## 题目描述

给定 $n$ 个垃圾桶，你需要维护一个数据结构，支持以下操作：

-   `1 pos val` 表示将 第 $pos$ 个垃圾桶里的垃圾的编号换成 $val$；

-   `2 l r` 询问在 $[l\oplus cnt, r\oplus cnt]$ 内是否存在垃圾编号和为 $w$ 的 **两个** 垃圾桶。

其中 $\oplus$ 表示异或运算，$cnt$ 表示在 **此次询问之前**，答案为 `Yes` 的个数。

对于每个操作 2，若存在请输出 `Yes`，不存在请输出 `No`。

值得注意的是，对于所有询问， $w$ 为 **同一个数**。


## 说明/提示

本题采用 **捆绑测试**，开启 **O2优化**。

$\text{Subtask 1 (7 pts)}:$ 保证 $1 \le n, m, w \le 2\cdot10^3$，**时限 $1\text{s}$**；

$\text{Subtask 2 (20 pts)}:$ 保证 $1 \le n, m, w \le 1\cdot10^5$，$opt = 2$，**时限 $2\text{s}$**；

$\text{Subtask 3 (30 pts)}:$ 保证 $1 \le n, m, w \le 1\cdot10^5$，**时限 $2\text{s}$**；

$\text{Subtask 4 (43 pts)}:$ 没有特殊限制，**时限 $4\text{s}$**；

对于所有数据， $1 \le n, m, w \le 5\cdot10^5$，$0 \le a_i \le w$。

数据保证对于每个操作，$1 \le pos \le n$，$0 \le val \le w$，$1 \le l \le r \le n$。

由于输入输出量较大，建议使用更快的输入输出方式。

---

#### 输入 #1 解释

第一次操作，询问区间 $[1, 4]$ 中是否有两个数加起来为 $6$，显然有$a_1 + a_4 = 6$，因此输出 `Yes`；

第二次操作，修改 $a_4$ 为 $1$，则序列变为 $[1, 3, 2, 1, 5, 6]$；

第三次操作，询问区间 $[1, 4]$ 中是否有 **两个** 数加起来为 $6$，无，因此输出 `No`。

第四次操作，询问区间 $[2, 6]$ 中是否有两个数加起来为 $6$，显然有 $a_4 + a_5 = 6$，因此输出 `Yes`。


## 样例 #1

### 输入

```
6 4 6
1 3 2 5 5 6
2 1 4
1 4 1
2 0 5
2 3 7```

### 输出

```
Yes
No
Yes```

## 样例 #2

### 输入

```
10 20 10
9 3 6 3 3 3 3 1 4 9
1 3 9
1 6 9
2 3 10
1 3 9
2 4 4
1 1 7
1 1 3
1 5 6
1 3 9
2 4 7
1 2 7
2 6 8
1 6 10
2 2 9
1 7 9
2 3 1
1 3 5
1 5 6
1 9 10
1 3 6```

### 输出

```
Yes
No
No
No
Yes
Yes
```

# AI分析结果



**唯一算法分类**：线段树 + 集合（平衡树）

---

### **题解思路与核心难点**

**核心思路**：  
1. **前驱定义**：每个元素维护其左侧最近的满足 `a[i] + a[j] = w` 的 `j`（若中间存在相同元素，则前驱无效）。  
2. **线段树维护**：用线段树维护区间内前驱的最大值，查询时判断该最大值是否在区间内。  
3. **动态更新**：修改元素时，通过集合（如 `set`）快速查找影响的前驱和后继，仅更新相关节点。

**解决难点**：  
- 修改操作可能影响多个位置的前驱，需通过集合高效定位相关元素，将影响范围限制在常数个节点。  
- 利用集合的 `lower_bound` 和 `upper_bound` 快速找到前后继，保证每次修改时间复杂度为 `O(log n)`。

---

### **最优思路提炼**

1. **关键数据结构**：  
   - **线段树**维护区间前驱最大值。  
   - **集合数组** `set<int> s[]`，存储每个值对应的位置，用于快速查找前驱和后继。  

2. **核心操作**：  
   - **修改**：  
     1. 删除旧值的影响：处理旧值的前驱和后继。  
     2. 插入新值的影响：处理新值的前驱和后继。  
     3. 更新相关节点的前驱（最多5个位置）。  
   - **查询**：判断线段树中区间 `[l, r]` 的最大前驱是否 `>= l`。  

3. **优化点**：  
   - 仅维护有效的前驱（中间无相同元素），避免无效更新。  
   - 使用集合确保每次修改仅影响常数个节点。

---

### **题解评分（≥4星）**

1. **FZzzz（5星）**  
   - **亮点**：清晰定义前驱，处理修改时仅更新5个节点，代码简洁高效。  
   - **代码片段**：  
     ```cpp
     void modify(int x, int y) {
         vector<int> res;
         // 处理旧值的影响
         auto it = s[a[x]].upper_bound(x);
         if (it != s[a[x]].end()) res.push_back(*it);
         // ... 类似处理其他影响点
         // 更新线段树中相关节点
         for (auto p : res) rt->modify(p, pre(p));
     }
     ```

2. **zhylj（4星）**  
   - **亮点**：维护每个元素的 `nxt`（右侧最近配对位置），用线段树维护最小值。  
   - **代码片段**：  
     ```cpp
     int pre = s[w - a[i]].lower_bound(i);
     nxt[i] = (pre ? pre : INF);
     ```

3. **Mu_leaf（4星）**  
   - **亮点**：详细处理修改后的前驱逻辑，代码注释清晰。  
   - **代码片段**：  
     ```cpp
     void calc(int x) {
         auto it = s[a[x]].lower_bound(x);
         // 更新前驱逻辑
     }
     ```

---

### **同类型题推荐**

1. **P1972 [SDOI2009] HH的项链**：维护区间不同数的个数，类似前驱思想。  
2. **P3369 【模板】普通平衡树**：练习 `set` 的基本操作。  
3. **P3384 【模板】轻重链剖分**：线段树维护动态区间信息。

---

### **可视化设计**

**动画方案**：  
1. **像素风格界面**：  
   - 用16色块表示数组元素，线段树节点显示为网格。  
   - 修改时高亮当前元素、旧值后继、新值后继。  

2. **关键步骤演示**：  
   - **修改**：旧值变灰，新值闪烁，相关节点连线更新。  
   - **查询**：区间高亮，线段树节点显示最大值。  

3. **音效与交互**：  
   - **音效**：成功查询播放上扬音调，修改时短暂“滴”声。  
   - **控制面板**：暂停/继续按钮，速度滑动条。  

**代码片段（伪代码）**：  
```javascript
// Canvas绘制线段树
function drawSegmentTree() {
    ctx.fillStyle = '#8B8B83'; // 复古灰
    // 绘制树节点...
}
```

---

### **核心代码实现**

**FZzzz的关键代码**：  
```cpp
int pre(int x) {
    auto it1 = s[a[x]].lower_bound(x);
    auto it2 = s[w - a[x]].lower_bound(x);
    // 计算有效前驱...
    return valid ? *it2 : 0;
}

void update(int pos, int new_val) {
    vector<int> affected;
    // 处理旧值的后继
    affected.push_back(old_next);
    // 插入新值
    s[new_val].insert(pos);
    // 更新线段树
    for (int p : affected) seg.update(p, pre(p));
}
```

---

### **总结**

本题通过维护动态前驱信息，将问题转化为线段树的区间最值查询。核心在于利用集合高效处理修改影响的范围，将时间复杂度控制在 `O(log n)`。可视化设计可结合复古像素风格，突出关键操作步骤，帮助理解动态更新过程。

---
处理用时：71.04秒
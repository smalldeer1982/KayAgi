# 题目信息

# [JOISC 2020] 星座 3

## 题目背景

> 蓝蓝的天空银河里       
有只小白船      
船上有棵桂花树      
白兔在游玩      
桨儿桨儿看不见      
船上也没帆        
飘呀飘呀飘向西天      
渡过那条银河水       
走向云彩国         
走过那个云彩国      
再向哪儿去         
在那遥远的地方        
闪着金光         
晨星是灯塔          
照呀照得亮      
晨星是灯塔         
照呀照得亮 

**本题被卡空间的可以尝试使用 C++14 通过**

## 题目描述

JOI 君去拍照，拍了一张大小为 $N \times N$ 的图片，第 $i$ 列第 $j$ 行的格子称为格子 $(i,j)$。

图里有白色的小白船，黄色的星星（天知道为啥星星是黄色的），黑色的空格（天知道这空格是啥），第 $i$ 列自下往上数到第 $A_i$ 行的格子里都是小白船，另外有 $M$ 颗星星，第 $i$ 颗星星在格子 $(X_i,Y_i)$，除了小白船和星星，其他格子都是空格。

现在 JOI 君定义满足下面的一个矩阵为星座：

1. 不包含小白船
2. 至少包含 $2$ 颗星星

JOI 君已经看星座看了 114514 年了，他厌烦了，所以他要把图片中的一些星星涂黑变成黑色空格，涂黑第 $i$ 颗星星会让图片增加 $C_i$ 的不自然度。求不存在星座的最小不自然度。

## 说明/提示

#### 样例 1 解释

把第三颗星星涂黑即可。

#### 样例 2 解释

把第三颗和第四颗星星涂黑即可。

#### 子任务

|子任务|特殊性质|分数|
|:-:|:-:|:-:|
|$1$|$N,M \le 300$|$14$|
|$2$|$N,M \le 2000$|$21$|
|$3$|无|$65$|

对于 $100\%$ 的数据，$1 \le N,M \le 2 \times 10^5$，$1 \le A_i,X_i,Y_i \le N$，$1 \le C_i \le 10^9$，$A_{X_i}<Y_i$，没有相同位置的星星。

#### 说明

翻译自 [第１９回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) [Day3 A 星座3](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day3/constellation3.pdf)。

## 样例 #1

### 输入

```
5
1 3 4 2 3
3
1 5 3
4 3 2
2 4 2```

### 输出

```
2```

## 样例 #2

### 输入

```
7
5 6 2 3 6 7 6
5
7 7 5
3 3 7
3 7 10
1 7 6
4 7 8```

### 输出

```
16```

## 样例 #3

### 输入

```
8
6 8 5 7 3 4 2 1
10
8 2 9
6 6 7
8 3 18
5 8 17
8 5 3
5 5 3
5 4 8
1 8 13
1 7 5
7 4 13```

### 输出

```
44```

# AI分析结果



## 算法分类
**贪心 + 树状数组 + 并查集**

---

## 题解思路与解决难点

### 核心思路
1. **逆向处理**：按星星的 y 坐标从小到大扫描，确保处理顺序不影响后续决策。
2. **影响区间**：每颗星星的冲突范围由其左右相邻的已处理区域决定，通过并查集动态维护区间的左右边界。
3. **反悔贪心**：比较删除当前星星的代价与删除其影响区间内其他星星的总代价，选择较小者，并在树状数组中记录差额以实现动态反悔。

### 难点对比
- **贪心策略的证明**：需确保局部最优解能推导出全局最优。通过树状数组维护区间总代价，确保每次决策可逆。
- **区间动态维护**：并查集快速合并相邻区域，树状数组高效处理区间查询与更新。

### 精炼结论
- **贪心反悔**：保留高价值星星时，差额更新到树状数组中以备后续调整。
- **高效数据结构**：并查集维护动态区间，树状数组支持区间查询与差分更新。

---

## 题解评分 (≥4星)

1. **awapwq233 (5星)**  
   - **亮点**：代码简洁，树状数组与并查集结合巧妙，时空效率最优。
2. **冷月葬T魂 (4星)**  
   - **亮点**：反悔贪心思路清晰，代码实现直观，树状数组应用典型。
3. **Creeper_l (4星)**  
   - **亮点**：反悔机制分析透彻，并查集与树状数组配合流畅。

---

## 最优思路提炼

### 关键步骤
1. **按 y 坐标升序处理星星**，确保处理顺序自底向上。
2. **并查集维护区间边界**：处理每行时合并相邻列，快速确定当前星星的左右边界 `[l, r]`。
3. **树状数组查询区间代价**：计算删除 `[l, r]` 内其他星星的总代价 `v`。
4. **贪心决策**：
   - 若 `c_i ≤ v`：删除当前星星，累加 `c_i`。
   - 否则：保留当前星星，更新树状数组的 `[l, r]` 区间，增加 `c_i - v` 以实现反悔。

### 代码片段
```cpp
for (int i = 1; i <= n; i++) { // 按行处理
    for (auto b : s[i]) {       // 当前行的星星
        int cost = qry(b.x);    // 查询影响区间总代价
        if (b.c <= cost) ans += b.c;
        else {
            ans += cost;
            add(l.find(b.x) + 1, b.c - cost); // 左边界+1处增加差额
            add(r.find(b.x), cost - b.c);     // 右边界处减少差额
        }
    }
    // 合并当前行处理后的区间
    for (auto x : h[i]) {
        l.fa[x] = x - 1; // 向左合并
        r.fa[x] = x + 1; // 向右合并
    }
}
```

---

## 类似题目推荐
1. **P4050 找硬币**：贪心+树状数组优化动态决策。
2. **P2894 酒店**：区间合并与动态查询，并查集经典应用。
3. **P5490 扫描线**：树状数组处理二维区间覆盖。

---

## 可视化设计

### 动画方案
- **网格绘制**：用 Canvas 绘制 N×N 网格，白色区域用灰色填充，星星用黄色标记。
- **处理高亮**：当前处理的星星高亮为红色，其影响区间 `[l, r]` 用蓝色边框标出。
- **树状数组更新**：右侧面板实时显示树状数组的差分值变化，颜色渐变表示数值大小。
- **并查集合并**：合并区间时，相邻列动态连接为绿色块，表示已处理区域。

### 复古像素风格
- **8 位调色板**：白色区域（#C0C0C0）、星星（#FFFF00）、当前处理（#FF0000）、区间边框（#0000FF）。
- **音效**：处理星星时播放短促“哔”声，合并区间时播放“咔嚓”声，反悔时播放“滴答”声。

### 交互功能
- **步进控制**：空格键单步执行，方向键调整速度。
- **数据面板**：显示当前总代价、剩余星星数、树状数组状态。

---

## 核心代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;
struct DSU {
    int fa[N];
    void init(int n) { iota(fa, fa + n + 1, 0); }
    int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
} L, R;

int main() {
    int n, m; scanf("%d", &n);
    vector<int> a(n + 1), h[n + 1];
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        h[a[i]].push_back(i);
    }
    vector<pair<int, int>> s[n + 1];
    scanf("%d", &m);
    for (int i = 0; i < m; i++) {
        int x, y, c; scanf("%d%d%d", &x, &y, &c);
        s[y].emplace_back(x, c);
    }
    L.init(n), R.init(n);
    vector<int> tree(n + 2);
    auto add = [&](int p, int v) {
        for (; p <= n; p += p & -p) tree[p] += v;
    };
    auto qry = [&](int p) {
        int res = 0;
        for (; p > 0; p -= p & -p) res += tree[p];
        return res;
    };
    long long ans = 0;
    for (int y = 1; y <= n; y++) {
        for (auto [x, c] : s[y]) {
            int l = L.find(x), r = R.find(x);
            int cost = qry(x);
            if (c <= cost) ans += c;
            else {
                ans += cost;
                add(l + 1, c - cost);
                add(r + 1, cost - c);
            }
        }
        for (int x : h[y]) {
            L.fa[x] = x - 1;
            R.fa[x] = x + 1;
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---
处理用时：87.49秒
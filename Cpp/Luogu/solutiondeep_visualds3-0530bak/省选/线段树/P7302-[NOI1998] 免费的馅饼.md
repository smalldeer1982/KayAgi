# 题目信息

# [NOI1998] 免费的馅饼

## 题目描述

SERKOI 最新推出了一种叫做“免费馅饼”的游戏：游戏在一个舞台上进行。舞台的宽度为 $w$ 格（从左到右依次用 $1$ 到 $w$ 编号），游戏者占一格。开始时游戏者可以站在舞台的任意位置，手里拿着一个托盘。下图为天幕的高度为 $4$ 格时某一个时刻游戏者接馅饼的情景。

![](https://cdn.luogu.com.cn/upload/image_hosting/1gcg9awi.png)

游戏开始后，从舞台天幕顶端的格子中不断出现馅饼并垂直下落。游戏者左右移动去接馅饼。游戏者每秒可以向左或向右移动一格或两格，也可以站在原地不动。

当馅饼在某一时刻恰好到达游戏者所在的格子中，游戏者就收集到了这块馅饼。当馅饼落在一个游戏者不在的格子里时该馅饼就消失。

写一个程序，帮助我们的游戏者收集馅饼，使得所收集馅饼的分数之和最大。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq w \leq 10^8$，$1 \leq n \leq 10^5$，$1\leq t_i \leq 10^8$，$1\leq p_i \leq w$，$1\leq v_i \leq 1000$。

## 样例 #1

### 输入

```
3 4
1 2 3
5 2 3
6 3 4
1 1 5
 ```

### 输出

```
12```

# AI分析结果



## 算法分类
动态规划 & 树状数组优化（二维偏序）

---

## 题解思路与难点对比

### 核心思路
所有题解均基于动态规划框架：
1. **状态定义**：`f[i]` 表示接到第 i 个馅饼时的最大分数
2. **转移方程**：`f[i] = max{f[j] + v[i]}`，需满足 `|p_i-p_j| ≤ 2*(t_i-t_j)`

### 关键优化
将转移条件拆解为二维偏序：
1. `2t_j - p_j ≤ 2t_i - p_i`
2. `2t_j + p_j ≤ 2t_i + p_i`

通过**排序**使一个维度天然有序，用**树状数组**维护另一个维度最大值。

### 难点对比
| 题解差异             | xiezheyuan 解法           | SSL_TJH_蒟蒻解法           |
|----------------------|---------------------------|-----------------------------|
| **排序维度**         | 按 `p-2t` 降序            | 按 `p+2t` 升序              |
| **离散化维度**       | `p+2t` 离散化             | `p+2t` 离散化               |
| **树状数组维护方向** | 维护前缀最大值            | 维护前缀最大值              |
| **时间复杂度**       | O(n log n)                | O(n log n)                  |

---

## 精炼结论
1. **核心技巧**：将移动限制转化为二维偏序，通过排序+树状数组降维
2. **优化关键**：  
   - 离散化处理大值域  
   - 树状数组维护区间最大值替代暴力枚举  
3. **通用套路**：双条件限制的动态规划均可尝试二维偏序转化

---

## 高分题解推荐 (≥4★)

### 1. xiezheyuan（★★★★★）
**亮点**：  
- 完整推导二维偏序转化过程  
- 代码简洁，关键注释清晰  
- 树状数组实现高效维护

**核心代码**：
```cpp
sort(a + 1, a + n + 1, cmp); // 按 p-2t 降序排序
for (int i = 1; i <= n; i++) {
    f[i] = query(a[i].x) + a[i].v; // 树状数组查询前缀最大
    update(a[i].x, f[i]); // 更新树状数组
}
```

### 2. SSL_TJH_蒟蒻（★★★★☆）
**亮点**：  
- 详细图解转移条件推导  
- 离散化处理解释清晰  
- 变量命名易读性佳

**调试心得**：  
> "开始误将第二个条件排序方向搞反，导致查询范围错误，通过手动模拟离散化过程才定位问题"

---

## 可视化算法设计

### 动画演示要点
1. **坐标系变换**：  
   - 初始坐标系显示 `(p, t)`  
   - 点击后切换为 `(2t-p, 2t+p)` 变换后的二维平面
   
2. **树状数组操作**：  
   - 高亮当前处理的馅饼（红色）  
   - 显示树状数组查询区间（蓝色覆盖区域）  
   - 实时绘制最大值更新过程（金色光效）

3. **复古像素风格**：  
   - 8-bit 音效：  
     - 移动时播放 "哔" 声  
     - 得分时播放 "叮咚" 声  
   - 像素化馅饼下落动画  
   - 树状数组节点用绿色方块表示，更新时闪烁

### 交互控制
```javascript
// 伪代码示例
class Visualization {
    constructor() {
        this.speed = 1.0; // 播放速度
        this.autoPlay = true; // 自动演示模式
        this.highlightNodes = true; // 高亮树状数组节点
    }
    
    renderStep(i) {
        // 绘制第i个馅饼的处理过程
        drawPie(a[i], RED);
        drawQueryRange(a[i].y); 
        playSound('select.wav');
        
        // 树状数组更新动画
        animateBitUpdate(a[i].y, f[i]); 
    }
}
```

---

## 相似题目推荐
1. **P1908 逆序对**（二维偏序基础）
2. **P1020 导弹拦截**（LIS 问题变种）  
3. **P2782 友好城市**（双关键字排序优化）

---

## 核心代码实现
```cpp
// 离散化 + 树状数组（xiezheyuan 解法核心）
sort(a + 1, a + n + 1, [](auto& x, auto& y) { 
    return x.p - 2*x.t > y.p - 2*y.t; // 第一维降序
});

vector<int> disc;
for (int i = 1; i <= n; i++) {
    disc.push_back(a[i].p + 2*a[i].t);
}
sort(disc.begin(), disc.end());
disc.erase(unique(disc.begin(), disc.end()), disc.end());

for (int i = 1; i <= n; i++) {
    int y = lower_bound(disc.begin(), disc.end(), a[i].p + 2*a[i].t) - disc.begin() + 1;
    int val = bit.query(y) + a[i].v;
    bit.update(y, val);
    ans = max(ans, val);
}
```

---

## 思维拓展
**空间换时间技巧**：当w较小时（如w≤1e5），可尝试坐标压缩，用线段树按位置维护时间窗口最大值，将复杂度进一步优化至O(n log w)。

---
处理用时：70.05秒
# 题目信息

# 「PMOI-1」中位数

## 题目描述

给定一棵以 $1$ 为根的包含 $n$ 个节点的**有根树**。第 $i$ 个节点有点权 $a_i$。

定义函数 $f(u,v)$ 表示从 $u$ 到 $v$ 经过的所有节点的点权的**可重集**的中位数。

请注意，**本题中的中位数的定义与数学中的定义略有不同**：这里一个长度为 $t$ 的序列的中位数定义为这个序列第 $\left\lceil\frac{t+1}2\right\rceil$ 小的数。

定义函数 $\text{cover}(x_1,y_1,x_2,y_2)$ 表示从 $x_1$ 到 $y_1$ 的路径是否完全覆盖了从 $x_2$ 到 $y_2$ 的路径。如果完全覆盖，则 $\text{cover}(x_1,y_1,x_2,y_2)=1$，否则 $\text{cover}(x_1,y_1,x_2,y_2)=0$。

你需要依次处理 $q$ 次操作，按照以下格式给出：

`1 u`：表示一次操作，需要你将点 $u$ 的点权对 $1$ **异或**；

`2 u v`：表示一次询问，需要你求出 $\max\limits_{1\le i\le n,1\le j\le n}\{\text{cover}(i,j,u,v)f(i,j)\}$。

对于第二类操作，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

你需要对于每个第二类操作，输出对应的值。

## 说明/提示

【样例解释】

第一次是询问。显然，只有 $(i=4,j=8)$ 满足 $\text{cover}(i,j,u,v)=1$。此时 $f(i,j)=3$。

第二次是操作。将 $3$ 号节点的点权改为了 $2$。

第三次是询问。当 $i=4,j=3$ 时，$\text{cover}(i,j,u,v)=1$ 且 $f(i,j)=4$。不难发现，对于其他所有满足 $\text{cover}(i,j,u,v)=1$ 的节点对 $(i,j)$，均没有 $f(i,j)>4$。

【数据范围】
- Subtask 1（8 pts）：$n,q\le50$；
- Subtask 2（12 pts）：$n,q\le2\times10^3$；
- Subtask 3（16 pts）：$n,q\le4\times10^4$；
- Subtask 4（10 pts）：保证树的形态随机生成；
- Subtask 5（12 pts）：保证没有 $1$ 操作；
- Subtask 6（12 pts）：保证每次询问的 $u,v$ 都是叶子节点；
- Subtask 7（30 pts）：无特殊限制。

Subtask 4 的随机方式为：随机生成一个的排列 $p$，对于 $i\in[2,n]$，$p_i$ 向 $p_1,p_2,...,p_{i-1}$ 中等概率随机的一个点连边。

对于 $100\%$ 的数据满足，$1\le n,q,a_i \le 10^5$，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

## 样例 #1

### 输入

```
8 3
4 2 3 4 2 1 4 3
1 2
1 3
2 4
2 5
3 6
6 7
6 8
2 4 8
1 3 
2 2 3```

### 输出

```
3
4```

# AI分析结果



## 算法分类
树状数据结构、主席树、二分答案、树上路径处理

---

## 题解分析

### 核心思路对比
1. **Y_B_X题解要点**：
   - **中位数判定**：将≥mid的值视为+1，<mid视为-1，转化为路径和≥0的问题。
   - **主席树维护**：为每个权值a维护子树区间和的最大值，通过标记永久化支持历史版本。
   - **修改处理**：点权异或1仅影响特定版本（奇偶变化），通过区间加减2调整对应版本。

2. **ducati题解要点**：
   - **路径分解**：将路径拆分为u到LCA、v到LCA三段，分开计算最优值。
   - **前缀和优化**：维护节点到根的路径前缀和，通过主席树快速查询子树最大值。
   - **动态维护**：修改时更新相关权值版本的主席树，类似区间修改操作。

### 解决难点
- **高效维护多版本路径信息**：主席树按权值离散化后建立，每个版本对应权值a的路径和状态。
- **动态修改处理**：利用异或1的特性，仅需调整受影响的一两个版本，避免全量重建。
- **路径覆盖条件优化**：通过子树查询将路径覆盖转化为DFS序区间操作，实现O(1) LCA和O(log n)子树查询。

### 结论
两题解均采用**二分答案+主席树维护路径和**的核心框架，Y_B_X更侧重修改时的奇偶版本处理，ducati更强调路径分解与子树极值查询。实际实现中，Y_B_X的标记永久化和离散化处理更为高效。

---

## 题解评分
1. **Y_B_X（5星）**  
   - 思路清晰，代码利用奇偶性优化修改操作，时间复杂度最优。
   - 标记永久化实现简洁，离散化处理减少空间占用。
   
2. **ducati（4星）**  
   - 路径分解思想直观，但未充分优化修改操作，部分实现稍显冗余。
   - 代码结构清晰，适合理解树上路径问题的通用处理方式。

---

## 最优思路提炼
- **中位数转化**：将问题转化为判定路径和≥0的最大mid，使用二分加速。
- **主席树优化**：按权值建立版本，标记永久化支持区间修改与历史查询。
- **子树极值查询**：利用DFS序将子树映射为连续区间，线段树维护区间最大值。
- **动态修改处理**：分析异或1的奇偶影响，仅调整关键版本，降低时间复杂度。

---

## 类似题目
1. [P2839 [国家集训队]middle](https://www.luogu.com.cn/problem/P2839)  
   （中位数判定+主席树）
2. [P4211 [LNOI2014]LCA](https://www.luogu.com.cn/problem/P4211)  
   （树上路径操作+离线处理）
3. [P3384 【模板】轻重链剖分](https://www.luogu.com.cn/problem/P3384)  
   （子树区间操作）

---

## 可视化设计
### 算法动画演示
1. **树结构展示**：  
   - 以像素风格绘制树形结构，节点标注权值，高亮当前操作的u/v。
   - 路径覆盖区域用半透明色块标识，如u的子树用蓝色，v的子树用红色。

2. **二分过程**：  
   - 动态显示mid值变化，对应权值版本的线段树节点更新（+1/-1）。
   - 路径和计算：分解为三段，分别显示各段贡献（数值变化动画）。

3. **主席树更新**：  
   - 修改操作时，播放像素音效，受影响版本线段树的区间加减2以闪烁提示。
   - 标记永久化过程：用不同颜色区分原始值与标记叠加。

### 复古游戏化
- **音效**：成功查询时播放8-bit胜利音效，修改操作触发“滴答”声。
- **积分系统**：每次正确查询+10分，优化查询速度获得连击奖励。
- **自动演示模式**：AI自动执行二分步骤，用贪吃蛇式路径覆盖展示最优解查找。

---

## 代码片段（Y_B_X题解核心）
```cpp
// 主席树区间更新（标记永久化）
void update(int &k, int kk, int l, int r, int x, int y, int v) {
    k = ++tot; t[k] = t[kk];
    if (x <= l && r <= y) {
        t[k].tag += v;
        t[k].mx += v;
    } else {
        int mid = (l + r) >> 1;
        if (x <= mid) update(t[k].l, t[kk].l, l, mid, x, y, v);
        if (mid < y) update(t[k].r, t[kk].r, mid+1, r, x, y, v);
        t[k].mx = max(t[t[k].l].mx, t[t[k].r].mx) + t[k].tag;
    }
}

// 查询子树最大值
int inquiry_mx(int k, int l, int r, int x, int y) {
    if (x <= l && r <= y) return t[k].mx;
    int mid = (l + r) >> 1, res = -INF;
    if (x <= mid) res = inquiry_mx(t[k].l, l, mid, x, y);
    if (mid < y) res = max(res, inquiry_mx(t[k].r, mid+1, r, x, y));
    return res + t[k].tag;
}
```

---

## 总结
本题通过巧妙的二分策略将中位数问题转化为路径和判定，结合主席树高效维护动态树结构。关键点在于离散化权值版本与标记永久化处理，使得修改操作仅需调整有限版本，极大优化了时间复杂度。可视化设计可重点展示二分判定与主席树更新的动态过程，帮助理解核心算法流程。

---
处理用时：70.50秒
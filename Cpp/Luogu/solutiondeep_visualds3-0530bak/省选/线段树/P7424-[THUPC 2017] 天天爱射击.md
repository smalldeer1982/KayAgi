# 题目信息

# [THUPC 2017] 天天爱射击

## 题目描述

小 C 爱上了一款名字叫做《天天爱射击》的游戏。如图所示，这个游戏有一些平行于 $x$ 轴的木板。现在有一些子弹，按顺序沿着 $y$ 轴方向向这些木板射去。第 $i$ 块木板被 $S_i$ 个子弹贯穿以后，就会碎掉消失。一个子弹可以贯穿其弹道上的全部木板，特别的，如果一个子弹触碰到木板的边缘，也视为贯穿木板。

小 C 现在知道了游戏中 $n$ 块木板位置，以及知道了 $m$ 个子弹射击位置。现在问你每个子弹射出去以后，有多少木板会碎掉？

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/ocqlbnl3.png)
#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。

$\text{upd}2021.7.6$：感谢 @[jiangbowen](https://www.luogu.com.cn/user/366807) 提供的一组 hack 数据，不计分，但若不通过 hack 数据则不算通过此题。

## 样例 #1

### 输入

```
3 2
1 3 1
2 4 2
3 4 1
2
3```

### 输出

```
1
2```

# AI分析结果



# **算法分类**  
**整体二分**

---

## **综合分析与结论**  
题目核心在于离线处理每个木板被击碎的时间点。通过整体二分或主席树将问题转化为区间第k小查询，整体二分通过分治策略批量处理木板与子弹的关系，主席树则直接维护区间信息。  

**核心算法流程**：  
1. **整体二分**：  
   - 二分答案区间 `[l, r]`，统计左半区间子弹对木板的贡献。  
   - 根据贡献将木板划分到左右子区间，递归处理。  
   - 树状数组动态维护子弹的位置分布，快速统计区间覆盖次数。  

2. **主席树**：  
   - 将子弹按位置离散化，构建可持久化线段树。  
   - 每个位置维护所有子弹的时间戳，查询区间第k小即为击碎时间。  

**可视化设计思路**：  
- **像素化动态分治**：以8位像素风格展示整体二分过程，左侧显示当前分治区间 `[l, r]`，右侧用色块表示木板的分组。  
- **树状数组操作高亮**：子弹位置用绿色方块标记，木板区间查询时闪烁红色边框。  
- **音效触发**：子弹发射时播放短促“射击”音效，木板破碎时播放“碎裂”音效。  

---

## **题解清单 (≥4星)**  
1. **Suzt_ilymtics（5星）**  
   - **亮点**：清晰的整体二分框架，处理了木板未被击碎的特殊情况，代码注释详细。  
   - **心得**：调试时需注意分治区间扩展到 `m+1` 以处理未击碎情况。  

2. **MuYC（5星）**  
   - **亮点**：将问题转化为静态区间第k小，代码简洁高效，时间复杂度更优。  
   - **心得**：同一位置多个子弹需按时间顺序插入主席树。  

3. **Alex_Wei（4星）**  
   - **亮点**：离散化优化整体二分，减少树状数组操作次数，性能最优解。  

---

## **最优思路提炼**  
1. **整体二分模板**：  
   - **分治策略**：将子弹批次处理，树状数组统计贡献，分治左右区间。  
   - **代码片段**：  
     ```cpp  
     void Solve(int l, int r, int ql, int qr) {  
         if (ql > qr) return;  
         if (l == r) {  
             for (int i = ql; i <= qr; ++i) ans[l] += q[i].type;  
             return;  
         }  
         // 树状数组统计左半区间贡献，划分木板  
     }  
     ```  

2. **主席树区间第k小**：  
   - **离散化处理**：子弹位置排序后构建主席树，每个位置维护时间戳列表。  
   - **代码片段**：  
     ```cpp  
     int query(int u, int v, int l, int r, int k) {  
         if (l == r) return l;  
         int sum = T[T[v].ls].cnt - T[T[u].ls].cnt;  
         // 根据左子树大小决定查询方向  
     }  
     ```  

---

## **同类型题与算法套路**  
1. **整体二分套路**：离线处理多查询的贡献分治，如 [P3527 [POI2011]MET-Meteors](https://www.luogu.com.cn/problem/P3527)。  
2. **主席树套路**：静态区间第k小问题，如 [P3834 静态区间第k小](https://www.luogu.com.cn/problem/P3834)。  

---

## **推荐题目**  
1. [P3527 [POI2011]MET-Meteors](https://www.luogu.com.cn/problem/P3527)（整体二分经典）  
2. [P3834 静态区间第k小](https://www.luogu.com.cn/problem/P3834)（主席树模板）  
3. [P2617 Dynamic Rankings](https://www.luogu.com.cn/problem/P2617)（动态区间第k小）  

---

## **个人心得摘录**  
- **Suzt_ilymtics**：分治区间需包含 `m+1` 以处理未被击碎的木板，否则答案统计会遗漏。  
- **MuYC**：同一位置多个子弹需用 `vector` 存储并按时间顺序插入，避免覆盖。  

---

## **可视化与算法演示**  
**整体二分动画设计**：  
1. **分治过程**：  
   - 左侧显示当前分治区间 `[l, r]`，右侧显示木板分组。  
   - 每次递归时，用红色分割线划分左右区间，绿色标记子弹位置。  

2. **树状数组操作**：  
   - 子弹插入时，对应位置方块变为绿色并闪烁。  
   - 木板区间查询时，边框高亮为黄色，命中次数显示为数字。  

**复古像素风格**：  
- **Canvas 绘制**：子弹为8x8像素方块，木板为横向色条，破碎时像素块飞散。  
- **音效设计**：子弹发射（短促“哔”声），木板破碎（“咔嚓”声），背景音乐为8位循环旋律。  

---

**核心代码（整体二分）**  
```cpp  
void solve(int l, int r, vector<int>& ids) {  
    if (ids.empty()) return;  
    if (l == r) {  
        for (int id : ids) ans[l]++;  
        return;  
    }  
    int mid = (l + r) / 2;  
    // 插入左半区间子弹到树状数组  
    vector<int> left, right;  
    for (int id : ids) {  
        int cnt = query(木板右端点) - query(木板左端点-1);  
        if (cnt >= s[id]) left.push_back(id);  
        else right.push_back(id);  
    }  
    solve(l, mid, left);  
    solve(mid+1, r, right);  
}  
```  

**核心代码（主席树）**  
```cpp  
void build() {  
    for (int x : 所有位置) {  
        root[x] = root[x-1];  
        for (int time : 该位置子弹时间)  
            root[x] = insert(root[x], time);  
    }  
}  
int query_kth(int l, int r, int k) {  
    return query(root[l-1], root[r], 1, m, k);  
}  
```  

--- 

**总结**  
本题核心在于将离线问题转化为区间查询，整体二分与主席树各有优劣。整体二分适合离线批量处理，主席树直接高效但需预处理。通过分治策略或可持久化数据结构，均可高效求解。

---
处理用时：117.37秒
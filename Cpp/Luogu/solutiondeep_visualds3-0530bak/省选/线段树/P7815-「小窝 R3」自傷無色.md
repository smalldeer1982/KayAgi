# 题目信息

# 「小窝 R3」自傷無色

## 题目背景

> こんな僕が生きてるだけで    
何万人のひとが悲しんで  
誰も僕を望まない  
そんな世界だったらいいのにな  
——[《自傷無色》](https://music.163.com/song?id=29124091)

## 题目描述

给定一棵 $n$ 个节点的树，根节点为 $1$，有边权。约定树上 $u,v$ 两点间路径长度 $d(u,v)$ 为 $u,v$ 间路径上的边权和。

对于一个无序二元组 $(u,v)$，定义一个「树三角」当且仅当同时满足：

- $u,v$ 的最近公共祖先 $w\neq u$ 且 $w\neq v$。
- 以 $d(u,w),d(v,w)$ 和某个正整数 $x$ 为边长，能构成一个三角形。$x$ 是任意选取的，因此一对 $(u,v)$ 可能会产生多个树三角。

此时 $d(u,w)+d(v,w)+x$ 即为这个树三角的大小。具体例子参考样例解释。

定义两个树三角不同，只需满足下列条件中的**一条**：

- 无序二元组 $(u,v)$ 不同。
- 树三角的大小不同。

对于一个带边权的树 $T$，定义其正弦值 $\sin T$ 为 $T$ 中所有树三角大小的和与 $T$ 中不同树三角总数量的比值。

小 H 给出了 $T$，希望你能求出 $\sin T$。为了避免误差，结果对 $10^9+7$ 取模。特别地，若 $T$ 中不存在树三角，则 $\sin T=0$。

## 说明/提示

### 样例解释

对于样例 1，$T$ 如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/35edha17.png)

节点 $1,2,3$ 构成的三角环有：$\underline{2,3},2;~\underline{2,3},3;~\underline{2,3},4$。

节点 $1,3,4$ 构成的三角环有：$\underline{3,3},1;~\underline{3,3},2;~\underline{3,3},3;~\underline{3,3},4;~\underline{3,3},5$。

节点 $1,3,5$ 构成的三角环有：$\underline{3,4},2;~\underline{3,4},3;~\underline{3,4},4;~\underline{3,4},5;~\underline{3,4},6$。

节点 $2,4,5$ 构成的三角环有：$\underline{1,2},2$。

所有三角环大小之和：$(7+8+9)+(7+8+\dots+11)+(9+10+\dots+13)+5=129$。

所有三角环的总个数：$3+5+5+1=14$。

$\sin T=\dfrac{129}{14}$，对 $10^9+7$ 取模后的结果为 $214285725$。

### 数据范围

**本题采用捆绑测试。**

- 特殊性质 A：保证 $T$ 中存在度为 $n-1$ 的节点。
- 特殊性质 B：保证 $T$ 中除了叶子节点，每个节点的度均为 $2$。
- 特殊性质 C：保证 $T$ 为满二叉树。

| Subtask | 分值 | $1\le n\le $ |  特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: | 
| $1$ | $5$  | $3$ | 无 |
| $2$ | $13$ | $10^3$ |  无 |
| $3$ | $11$ | $7\times10^3$ | 无 |
| $4$ | $17$ | $10^5$ | A |
| $5$ | $17$ | $10^5$ | B |
| $6$ | $17$ | $10^5$ | C |
| $7$ | $20$ | $10^5$ |  无 |

对于 $100\%$ 的数据，$1\le n\le 10^5$，$1\le w\le 10^9$。

### 提示

在题目附件 `depression_sample.zip` 中：

- `depression_sample1.in` 即为样例 #1。
- `depression_sample2.in` 满足特殊性质 A。
- `depression_sample3.in` 满足特殊性质 B。
- `depression_sample4.in` 满足特殊性质 C。
- `depression_sample5.in` 不满足特殊性质。

## 样例 #1

### 输入

```
5
1 2 2
1 3 3
2 4 1
2 5 2```

### 输出

```
214285725```

## 样例 #2

### 输入

```
9
1 2 9
1 3 3
2 4 5
2 5 7
2 6 2
1 7 1
3 8 6
3 9 4```

### 输出

```
662721928```

# AI分析结果



## 算法分类选择  
**树上点分治 + 数学公式推导**

---

## 题解思路与核心难点  
### 核心思路  
所有题解均围绕以下步骤展开：  
1. **枚举 LCA 节点**：将问题分解为每个 LCA 节点 w 的贡献计算  
2. **子树信息统计**：通过 DSU on tree 或线段树合并高效处理子树节点间的贡献  
3. **数学公式推导**：将三角形周长和数量转化为多项式求和，拆解为多个可统计项  
4. **数据结构优化**：使用平衡树/离散化树状数组维护子树节点的距离信息  

### 解决难点  
1. **贡献公式推导**：将原问题转化为可统计的数学表达式（如 $4d_ud_v$ 等项的拆分）  
2. **子树间高效合并**：避免 $O(n^2)$ 枚举，利用数据结构批量计算贡献  
3. **动态偏移处理**：处理不同 LCA 导致的距离偏移（$dis_x - dis_{LCA}$ 的批量计算）  

---

## 题解评分 (≥4星)  
1. **万弘 (5星)**  
   - 思路清晰度：⭐️⭐️⭐️⭐️⭐️  
   - 优化程度：DSU on tree + 离散化树状数组  
   - 代码可读性：简洁的离散化处理与贡献拆分  
   ```cpp
   // 关键代码：贡献计算逻辑
   ans += (2 * val - 1) * sum; 
   ans += val * (2 * sum - cnt);
   ```

2. **LFCode (4.5星)**  
   - 算法创新性：线段树合并 + 动态偏移公式  
   - 实践价值：完整展示合并时的贡献传递  
   - 调试心得：注释详细推导过程  

3. **Nt_Tsumiki (4星)**  
   - 数学严谨性：完整推导分子分母的拆分项  
   - 扩展性：提出 LCT 优化路径查询的可行性  

---

## 最优思路与技巧  
### 关键技巧  
1. **贡献拆分公式**：  
   $$\sum (2d_u-1)(2d_v+d_u) = 4\sum d_ud_v + 2\sum d_u^2 - \text{线性项}$$  
   利用树状数组维护 $\sum d$, $\sum d^2$, $\sum 1$  

2. **动态偏移处理**：  
   ```cpp  
   // 处理 LCA 距离偏移
   s3 = (sum_sq - 2*LCA_dis*sum + LCA_dis^2*cnt) % MOD;
   ```  

3. **子树合并优化**：  
   - 轻子树暴力查询后插入  
   - 重子树保留数据结构避免重复计算  

---

## 同类型题目推荐  
1. [CF208E] Blood Cousins（DSU on tree 经典题）  
2. [Luogu P4211] 地域划分（LCA 贡献统计）  
3. [ABC242Ex] Random Painting（动态贡献拆分）  

---

## 可视化设计  
### 算法动画方案  
1. **颜色标记**：  
   - 红色：当前处理的 LCA 节点  
   - 绿色：已处理的轻子树节点  
   - 蓝色：重子树保留的数据结构  

2. **动态演示**：  
   ```javascript  
   // 伪代码：子树合并动画
   function mergeSubtree(w) {
     highlight(w, 'red'); 
     for (let child of w.children) {
       if (child.isHeavy) continue;
       animateQuery(child, (d) => {
         showFormula(`ans += ${calc(d, w)}`);
       });
     }
     playSound('blip'); // 合并完成音效
   }
   ```  

### 复古像素风格  
- **调色板**：16色 NES 风格（红/绿/蓝/黄主色）  
- **音效设计**：  
  - 插入节点：8-bit "beep" 短音  
  - 计算贡献：MIDI 音阶上升  
- **Canvas 动画**：  
  ```javascript
  ctx.fillStyle = '#FF0000'; // LCA 红色方块
  ctx.fillRect(x*10, y*10, 8, 8); 
  ```  

---

## 核心代码片段  
### 万弘题解关键部分  
```cpp  
// 离散化处理
sort(b+1,b+tt+1); 
for(int i=1;i<=n;i++) 
    a[tmp[i].pos]=lower_bound(b+1,b+tt+1,sum[i])-b;

// DSU on tree 贡献计算
void calc(int u, int k) {
    Mint A = dis[u] - k.x;
    ans += A * (t1.sum - t0.sum * k) * 4;
    ans -= A * t0.sum * 2;
}
```  

---

## 总结  
本题解通过巧妙的公式拆分与高效子树合并，将复杂的三元组问题转化为可批量计算的统计项。其核心在于利用树形结构的层次特性与数学归纳能力，结合现代数据结构实现高效处理。可视化方案通过复古风格与动态交互，可直观展示算法核心流程。

---
处理用时：59.39秒
# 题目信息

# [ONTAK2010] Peaks 加强版

## 题目背景

原题链接：[P4197 Peaks](https://www.luogu.com.cn/problem/P4197)

## 题目描述

给定一张 $n$ 个点、$m$ 条边的无向图，第 $i$ 个点的权值为 $a_i$，边有边权。

有 $q$ 组询问，每组询问给定三个整数 $u, x, k$，求从 $u$ 开始只经过权值 $\leq x$ 的边所能到达的权值第 $k$ 大的点的权值，如果不存在输出 $-1$。

**本题强制在线。即：每次查询输入的是 $u', x', k'$，则 $u = (u' \operatorname{xor} \text{lastans}) \bmod n + 1$，$k$ 的解密方式与之相同，$x = x' \operatorname{xor} \text{lastans}$**。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 \leq m, q \leq 5 \times 10^5$，$1 \leq s, t \leq n$，$1 \leq a_i, w \leq 10^9$，$0 \leq u', x', k' < 2^{31}$。

## 样例 #1

### 输入

```
10 11 3
1 2 3 4 5 6 7 8 9 10
1 4 4
2 5 3
9 8 2
7 8 10
7 1 4
6 7 1
6 4 8
2 1 5
10 8 10
3 4 7
3 4 6
0 5 5
1 6 8
7 8 1```

### 输出

```
1
-1
8```

# AI分析结果



# 算法分类  
**Kruskal 重构树 + 主席树**

---

## 题解思路与核心难点  
### 核心思路
1. **Kruskal 重构树**  
   - 将边按权值升序排序，构建 Kruskal 重构树，形成大根堆结构。
   - 重构树中，非叶子节点的权值为对应边的权值，叶子节点为原图节点。
   - 性质：从任意节点出发，只经过权值 ≤ x 的边能到达的点，对应重构树中某个子树的所有叶子节点。

2. **倍增法找祖先**  
   - 对于询问中的节点 u 和权值 x，通过倍增法找到深度最小的祖先节点，其权值 ≤ x。
   - 该祖先节点的子树即为所有可达的节点集合。

3. **主席树处理区间第 k 大**  
   - 对重构树的叶子节点（原图节点）按 DFS 序离散化后建立主席树。
   - 子树对应的 DFS 序区间即为连续区间，用主席树查询第 k 大。

### 解决难点
1. **子树范围确定**  
   - 重构树的非叶子节点不包含真实数据，需通过 DFS 序将叶子节点映射到连续区间。
   - 预处理每个节点的子树在 DFS 序中的起始和结束位置。

2. **强制在线处理**  
   - 所有操作需支持在线查询，主席树的持久化特性保证了多版本查询的可行性。

---

## 题解评分（≥4星）

### 1. LawrenceSivan（⭐️⭐️⭐️⭐️⭐️）
- **亮点**：详细讲解 Kruskal 重构树的性质与构建过程，配图直观，代码注释清晰。
- **代码**：完整实现重构树、倍增、主席树全流程，变量命名规范。

### 2. Gao_yc（⭐️⭐️⭐️⭐️⭐️）
- **亮点**：代码简洁高效，逻辑分层明确，重点突出倍增与主席树的结合。
- **优化**：离散化处理减少内存占用，适合大数据量场景。

### 3. ZCETHAN（⭐️⭐️⭐️⭐️）
- **亮点**：代码高度模块化，提供完整调试记录，适合参考实现细节。
- **不足**：理论解释较简略，依赖读者对重构树已有认知。

---

## 最优技巧提炼
### 关键数据结构与操作
1. **Kruskal 重构树构建**  
   ```cpp
   void kruskal() {
     sort(e, e+m, cmp);
     for (int i=1; i<=m; i++) {
       int fx = find(e[i].u), fy = find(e[i].v);
       if (fx != fy) {
         val[++tot] = e[i].w;  // 新建节点
         link(tot, fx); link(tot, fy);  // 连接子树
       }
     }
   }
   ```

2. **倍增法找祖先**  
   ```cpp
   int find_ancestor(int u, int x) {
     for (int i=20; i>=0; i--) 
       if (fa[u][i] && val[fa[u][i]] <= x)
         u = fa[u][i];
     return u;
   }
   ```

3. **主席树查询**  
   ```cpp
   int query(int l, int r, int k) {
     if (l == r) return l;
     int cnt = tr[tr[r].rs].sum - tr[tr[l].rs].sum;
     if (cnt >= k) return query(tr[l].rs, tr[r].rs, k);
     else return query(tr[l].ls, tr[r].ls, k - cnt);
   }
   ```

---

## 类似题目推荐
1. **P4197 Peaks**  
   原题非强制在线版，可用相同思路解决。

2. **P4768 [NOI2018] 归程**  
   结合最短路与重构树，求海拔限制下的最短路径。

3. **P3304 [SDOI2013] 直径**  
   利用重构树性质处理路径极值问题。

---

## 可视化设计
### 动画演示方案
1. **Kruskal 重构树构建**  
   - **步骤**：动态展示边排序、合并子树、生成新节点的过程。
   - **高亮**：合并时的新节点用红色标记，边权显示在节点上方。

2. **倍增法查找祖先**  
   - **颜色标记**：当前节点为绿色，跳跃路径为黄色，最终祖先为橙色。
   - **单步执行**：允许用户逐层查看跳跃过程。

3. **主席树区间查询**  
   - **网格展示**：用 Canvas 绘制线段树结构，当前查询区间用蓝色框标出。
   - **音效**：每次进入新层级播放“滴”声，找到结果时播放成功音效。

### 复古像素风格
- **调色板**：使用 8 位风格的青、粉、黄三色区分不同数据结构。
- **背景音乐**：循环播放 FC 风格的轻快旋律，音效采用经典“吃金币”声。

---

## 个人心得摘录
- **LawrenceSivan**：强调重构树的“大根堆性质”是解题关键，调试时需验证每个节点的子树范围。
- **peterwuyihong**：在强制在线版本中，离散化需与原题区分，避免混淆点权与边权。

---

## 代码片段（关键逻辑）
```cpp
// Kruskal 重构树核心代码
void build_kruskal() {
  sort(edges.begin(), edges.end());
  init_dsu();
  for (auto &e : edges) {
    int u = find(e.u), v = find(e.v);
    if (u != v) {
      int node = ++tot;  // 新建节点
      val[node] = e.w;
      fa[u][0] = fa[v][0] = node;
      merge(u, v);  // 合并并查集
    }
  }
}

// 主席树查询片段
int query_kth(int u, int x, int k) {
  int anc = find_ancestor(u, x);
  if (size[anc] < k) return -1;
  return segtree.query(dfn[anc], dfn[anc] + size[anc] - 1, k);
}
```

---
处理用时：70.04秒
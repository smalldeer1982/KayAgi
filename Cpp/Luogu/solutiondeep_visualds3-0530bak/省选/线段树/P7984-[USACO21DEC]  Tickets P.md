# 题目信息

# [USACO21DEC]  Tickets P

## 题目描述

Bessie 正在参加远足旅行！她当前正在旅行的路线由编号为 $1\ldots N$（$1\le N\le 10^5$）的 $N$ 个检查点组成。

有 $K$（$1\le K\le 10^5$）张票可供购买。第 $i$ 张票可以在检查站 $c_i$（$1\le c_i\le N$）以 $p_i$（$1\le p_i\le 10^9$）的价格购得，并且可以用其进入所有检查站 $[a_i,b_i]$（$1\le a_i\le b_i\le N$）。在进入任何检查站之前，Bessie 必须已购买一张允许其进入该检查站的票。一旦 Bessie 可以前往某一检查站，她就可以在未来的任何时候回到该检查站。

对于每一个 $i\in [1,N]$，如果 Bessie 最初只能进入检查点 $i$，输出使得可以进入检查点 $1$ 和 $N$ 所需的最低总价。如果无法这样做，输出 $-1$。


## 说明/提示

【样例解释】

如果 Bessie 从检查点 $i=4$ 开始，那么一种购得进入检查点 $1$ 和 $N$ 的方法如下：

在检查点 $4$ 购买第一张票，使 Bessie 可以进入检查点 $2$ 和 $3$。

在检查点 $2$ 购买第三张票，使 Bessie 可以进入检查点 $7$。

回到检查点 $4$ 购买第二张票，使 Bessie 可以进入检查点 $5$ 和 $6$。

在检查点 $6$ 购买第四张票，使 Bessie 可以进入检查点 $1$。

【数据范围】

- 测试点 1-7 满足 $N,K\le 1000$。
- 测试点 8-19 没有额外限制。


## 样例 #1

### 输入

```
7 6
4 1 2 3
4 10 5 6
2 100 7 7
6 1000 1 1
5 10000 1 4
6 100000 5 6```

### 输出

```
-1
-1
-1
1111
10100
110100
-1```

# AI分析结果



**唯一算法分类**：线段树优化建图 + 最短路

---

### **题解思路与核心难点**

1. **建模关键**  
   - 将每张票视为虚点，建立双向边：购买点 $c_i$ → 虚点（边权 $p_i$），虚点 → 对应区间 $[a_i,b_i]$（边权 0）  
   - 使用线段树优化区间连边，将 $O(N)$ 边数降为 $O(\log N)$ 级别  

2. **三次最短路策略**  
   - **第一次**：从检查点 1 出发，求到达所有点的最短路 $dis1[]$  
   - **第二次**：从检查点 N 出发，求到达所有点的最短路 $disN[]$  
   - **第三次**：初始化 $ans[i] = dis1[i] + disN[i]$，对所有点跑最短路松弛，解决路径重叠导致重复计算的问题  

3. **可视化设计要点**  
   - **线段树结构**：以网格展示线段树节点，高亮当前连接的区间  
   - **虚点流动**：用箭头动画表示票的虚点向区间扩散 0 权边，购买点向虚点流动 $p_i$ 权值  
   - **松弛过程**：用颜色渐变表示三次最短路中距离值的更新，重点显示第三次松弛如何优化重叠路径  

---

### **题解评分 (≥4星)**

1. **Benq 的题解 (⭐⭐⭐⭐⭐)**  
   - 核心亮点：势能线段树维护右端点最大值，实现 $O(N\log N)$ 复杂度  
   - 关键代码：`SegTree::remove` 方法高效处理区间覆盖，保证每个票只入队一次  
   ```cpp
   void remove(vector<int> &v, int x) {
       if (覆盖条件) { v.push_back(t); mx[p] = -1; /*标记处理*/ }
       /*递归处理左右子树*/
   }
   ```

2. **ETHANK 的题解 (⭐⭐⭐⭐)**  
   - 经典线段树建图，代码结构清晰  
   - 三次 Dijkstra 过程注释明确，适合理解基础思路  
   ```cpp
   // 三次最短路调用
   dijkstra(1); dijkstra(n); 
   memcpy(ans, dis1+disN); dijkstra_combine();
   ```

3. **cmll02 的题解 (⭐⭐⭐⭐)**  
   - 提出“虚拟汇点”思想，将双源问题转化为单源问题  
   - 动态演示路径合并过程，辅助理解松弛必要性  

---

### **最优思路提炼**

1. **线段树势能优化**  
   - 按左端点排序门票，维护区间最大右端点  
   - 当处理点 $u$ 时，快速找出所有覆盖 $u$ 的有效门票区间  

2. **三次松弛的正确性**  
   - 前两次最短路计算独立路径  
   - 第三次将 $dis1[u]+disN[u]$ 视为初始势能，通过边权松弛消除重复计算  

3. **虚点与实点分离**  
   - 实点（检查站）与虚点（票）分层管理  
   - 避免票之间的交叉影响，保持图结构清晰  

---

### **同类型题推荐**

1. **[CF786B Legacy](https://www.luogu.com.cn/problem/CF786B)**  
   - 线段树优化建图模板题，含区间连边操作  

2. **[P6348 [COCI2007-2008#2] PARKING](https://www.luogu.com.cn/problem/P6348)**  
   - 区间覆盖与最短路结合，考验建模能力  

3. **[P4768 [NOI2018] 归程](https://www.luogu.com.cn/problem/P4768)**  
   - 分层最短路 + 并查集优化，类似双阶段决策  

---

### **代码片段（Benq 风格）**

```cpp
// 势能线段树关键操作
void SegTree::remove(vector<int> &vec, int x, int p) {
    if (当前区间不覆盖x || 最大右端点<x) return;
    if (叶子节点) { vec.push_back(票ID); 标记为已处理; return; }
    remove(vec, x, 左儿子); 
    remove(vec, x, 右儿子);
    pushup(p); // 更新区间最大右端点
}

// 三次最短路调用顺序
dijkstra(L); // L=1的dis
dijkstra(R); // R=n的dis
for (i : all) ans[i] = L_dis[i] + R_dis[i];
dijkstra_ans(); // 用ans数组初始化优先级队列
```

---

### **复古像素化演示设计**

1. **Canvas 动画**  
   - **线段树节点**：用 8x8 像素块表示，绿色表示激活区间  
   - **票虚点**：红色闪烁方块，购买时播放 "coin.wav" 音效  
   - **最短路传播**：蓝色波纹从起点扩散，遇到虚点时变为黄色  

2. **音效触发**  
   - `buy_ticket`：当虚点被访问时，播放 8-bit 电子音  
   - `relax_success`：距离更新时触发高音 "ping"  
   - `path_merge`：第三次松弛时使用合成器音效  

3. **自动演示模式**  
   - 按空格切换手动/自动  
   - AI 模式下，算法自动选择当前最小距离节点，用箭头指示松弛方向  

---

**总结**：本题通过线段树优化建图将复杂区间操作化简，配合三次最短路消除路径重叠影响，是图论与数据结构的经典结合。Benq 的势能优化法在同类题中具有普适性，值得深入学习。

---
处理用时：70.67秒
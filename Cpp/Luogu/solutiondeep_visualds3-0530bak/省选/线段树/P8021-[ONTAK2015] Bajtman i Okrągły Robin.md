# 题目信息

# [ONTAK2015] Bajtman i Okrągły Robin

## 题目背景

**警告：滥用本题评测将被封号！**

## 题目描述

有 $n$ 个强盗，其中第 $i$ 个强盗会在 $[a_i, a_i + 1], [a_i + 1, a_i + 2], \cdots, [b_i - 1, b_i]$ 这么多段长度为 $1$ 的时间中选出一个时间进行抢劫，并计划抢走 $c_i$ 元。作为保安，你在每一段长度为 $1$ 的时间内最多只能制止一个强盗，那么你最多可以挽回多少损失呢？

## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^3$，$1 \leq a_i < b_i \leq 5 \times 10^3$，$1 \leq c_i \leq 10^4$。

## 样例 #1

### 输入

```
4
1 4 40
2 4 10
2 3 30
1 3 20```

### 输出

```
90```

# AI分析结果



## 算法分类
**网络流（费用流） + 线段树优化建图**

---

## 综合分析与结论
### 核心思路与难点
- **核心问题**：每个强盗的抢劫时间覆盖一个连续区间，每个时间段最多选一个强盗。需最大化总收益。
- **算法选择**：最大费用最大流（将收益取反转为最小费用流）。
- **核心难点**：直接建边会导致边数爆炸（$O(n^2)$），需通过线段树优化建图将边数降至 $O(n \log T)$。
- **关键优化**：线段树节点表示时间段区间，父节点向子节点连无限流量边，强盗向线段树覆盖区间的节点连边。

### 题解评分（≥4星）
1. **DarkClever（★★★★☆）**  
   - 完整展示线段树优化建图思路，代码结构清晰，注释详细。
   - 实现费用流模板与线段树节点动态分配，适合理解建图逻辑。
   - 不足：未完全优化常数，但代码可读性强。

2. **mqmhaaaa1（★★★★☆）**  
   - 详细解释线段树优化原理，强调“流量下推”机制。
   - 代码采用动态线段树节点编号，减少空间浪费。
   - 核心亮点：通过 `build` 和 `find` 函数实现高效区间连边。

3. **南阳刘子骥（★★★★☆）**  
   - 独立设计线段树结构体，明确节点与边的关系。
   - 实现细节完整（如右端点减一处理时间段），代码模块化。
   - 提供完整建树与连边代码，便于调试。

---

## 最优思路与技巧提炼
### 线段树优化建图
1. **线段树结构**  
   - 叶子节点表示单个时间段，父节点覆盖子节点区间。
   - 父节点向子节点连 **无限流量边**（允许流量自由下推）。

2. **强盗连边**  
   - 将强盗的区间 $[a_i, b_i-1]$ 分解为线段树上的 $O(\log T)$ 节点。
   - 每个强盗向这些节点连 **流量1、费用 $c_i$ 的边**，代替暴力连所有时间段。

3. **费用流设计**  
   - 源点连强盗（流量1，费用0），时间段连汇点（流量1，费用0）。
   - 跑最小费用流后将费用取反，得到最大收益。

### 关键代码实现（DarkClever 核心片段）
```cpp
void build(int u, int l, int r) {
    if (l == r) { // 叶子节点连汇点
        add(u, t, 1, 0);
        return;
    }
    int mid = (l + r) >> 1;
    build(u << 1, l, mid);
    build(u << 1 | 1, mid + 1, r);
    add(u, u << 1, INF, 0); // 父节点向子节点连边
    add(u, u << 1 | 1, INF, 0);
}

void seglnk(int u, int l, int r, int k) {
    if (tr[u].l >= l && tr[u].r <= r) { // 区间完全覆盖
        add(k + 1, u, 1, -c[k]); // 连边并取反费用
        return;
    }
    int mid = (tr[u].l + tr[u].r) >> 1;
    if (l <= mid) seglnk(u << 1, l, r, k);
    if (r > mid) seglnk(u << 1 | 1, l, r, k);
}
```

---

## 同类题目推荐
1. **P3358 最长k可重区间集问题**  
   - 区间选择问题，需限制每个点的覆盖次数，线段树优化建图。

2. **P1251 餐巾计划问题**  
   - 时间轴上的流量分配，需处理区间需求与费用优化。

3. **P4043 支线剧情**  
   - 树形结构上的费用流，结合分层图与流量下推。

---

## 可视化设计（复古像素风格）
### 核心元素
1. **线段树节点**  
   - 用不同颜色方块表示父节点（红色）和叶子节点（绿色）。
   - 动态显示父节点向子节点连边（白色流动线条）。

2. **流量与费用**  
   - 强盗节点（蓝色方块）向线段树节点连边时，显示费用值（黄色数字）。
   - 汇点（紫色方块）统计总费用，逐步累加。

3. **音效与动画**  
   - **连边成功**：8-bit "哔"声。
   - **流量下推**：像素方块闪烁。
   - **最大费用达成**：播放胜利音效。

### 交互演示
- **步进控制**：按空格键逐步执行连边与流量分配。
- **自动模式**：AI模拟费用流过程，自动高亮增广路径。
- **数据面板**：右侧显示当前费用、剩余流量、线段树节点覆盖范围。

---

## 个人心得摘录
- **调试教训**：线段树区间右端点需减一，否则会覆盖错误时间段。
- **优化技巧**：费用流反向跑SPFA（从汇点出发）可加速多路增广。
- **代码习惯**：动态分配节点编号（如 `ds++`）比预分配更灵活。

---

## 完整代码参考（DarkClever 实现）
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 320000;
const int M = 320000;
const int INF = 0x3f3f3f3f;

int n,m,ds,s,t;
struct wll{
    // 网络流模板（见题解原文）
} dc;
struct xds{
    // 线段树建图（见题解原文）
}out;

int rt_out;
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n;
    int tims = 5001;
    s = tims+1, t = tims+2;
    ds = tims+2;
    for(int i=1;i<=tims;i++) dc.addedge(i,t,1,0);
    rt_out = out.build(1,1,5000);
    for(int i=1;i<=n;i++){
        int a,b,c; cin>>a>>b>>c;
        ds++;
        dc.addedge(s,ds,1,0);
        out.addfrom(ds,rt_out,c,a,b-1);
    }
    dc.mcmf(s,t);
    cout<<-dc.ret<<endl;
    return 0;
}
```

---
处理用时：79.55秒
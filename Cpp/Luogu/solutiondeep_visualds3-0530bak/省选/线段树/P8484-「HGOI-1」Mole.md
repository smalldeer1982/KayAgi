# 题目信息

# 「HGOI-1」Mole

## 题目背景

$\text{brealid}$ 觉得普通的打地鼠游戏太过于 $\text{simple}$ 了。所以，她设计了一款全新的打地鼠游戏。

## 题目描述

在长度为 $l$ 的游戏窗口上，有一个长为 $t$ 的地鼠序列 $(l \le t)$，初始序列左端与窗口左端对齐，接下来序列每秒移动一个单位长度，（即最左端的地鼠离开窗口，最右端的地鼠进入窗口），向左滚动直至玩家结束游戏或者序列最右端与窗口最右端重合（即任何时刻窗口内均应有 $l$ 只地鼠）。

游戏开始的第一秒序列不会移动，不难发现游戏最多会进行 $(t-l+1)$ 秒。

序列 $T$ 中的每一只地鼠都有自己的高度 $h_i$，玩家每次可以选择击打一只地鼠，玩家可以获得与地鼠高度 $h_i$ 数值相同的金币奖励，同时地鼠 $i$ 的高度 $h_i$ 会减一。

经过调研，$\text{brealid}$ 控制了游戏运行速度，使得玩家在地鼠序列移动一个单位长度的同时**最多只能打击一次**（也可以不打）。

现在 $\text{brealid}$ 告诉了你某一次游戏的窗口长度 $l$、序列长度 $t$ 以及某一局游戏中生成的地鼠高度序列 $T$。我们可爱的 $\text{brealid}$ 想要知道，她在**任意时刻**结束游戏所能得到的**最多金币**，即在第 $1,2,\cdots (t-l+1)$ 秒时停止游戏分别可以获得的最多金币。

## 说明/提示

#### 样例解释

第一秒：锤 $2$，答案加 $3$。

第二秒：锤 $2$，答案加 $2$。

第三秒：随便锤一个，答案加 $1$。

第四秒：再随便锤一个（非 $0$ 的），答案加 $1$。

第五秒：锤 $9$，答案加 $5$。

第六秒：锤 $9$，答案加 $4$。

#### 数据范围

本题采用**捆绑测试**，共有 $4$ 个 $\text{subtask}$，最终分数为所有 $\text{subtask}$ 分数之和。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Task} & \textbf{Score} & l\le t\le  \cr\hline
1 & 10 & 10 \cr\hline
2 & 20 & 500 \cr\hline
3 & 30 & 5000 \cr\hline
4 & 40 & 10^6 \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，$1\le l\le t\le 10^6$，$|h_i|\le 10^9$。


## 样例 #1

### 输入

```
5 10
1 3 1 1 1 1 1 1 5 1```

### 输出

```
3 5 6 7 12 16```

# AI分析结果



## 唯一算法分类
**贪心**

---

## 综合分析与结论

### 题目核心思路
1. **滑动窗口特性**：每个时刻窗口右移，需要在窗口范围内选择打击次数。
2. **贪心策略**：每次选择当前窗口内剩余价值最高的地鼠打击，确保总收益最大。
3. **合法性验证**：用线段树维护每个位置的允许打击次数，确保打击操作不超出时间限制。

### 核心难点与解决
- **动态维护最大值**：优先队列快速获取当前最优打击目标。
- **区间合法性验证**：线段树维护区间最小值，判断能否在窗口内完成打击操作。
- **时间复杂度优化**：通过线段树和贪心策略将复杂度降至 $O(n \log n)$。

### 可视化设计思路
- **动画方案**：
  - **窗口移动**：以滑动条展示窗口位置变化。
  - **优先队列操作**：高亮当前选择的地鼠，显示其价值及减一后的重新入队过程。
  - **线段树更新**：用颜色区分线段树节点的区间修改（如绿色表示区间减一，红色表示非法区间）。
- **复古像素风格**：
  - **地鼠序列**：用8位像素方块表示地鼠，高度数值显示在方块上方。
  - **音效触发**：打击时播放短促音效，线段树更新时伴随低音提示。
- **交互功能**：支持步进控制，展示每一步的优先队列状态和线段树查询结果。

---

## 题解清单 (≥4星)

### 题解1：bh1234666（5星）
- **亮点**：结合贪心与线段树，高效处理大规模数据；代码结构清晰，逻辑严谨。
- **关键代码**：
  ```cpp
  priority_queue<pair<int,int>, vector<pair<int,int>>, cmp> q;
  int tree[N], tag[N];
  void update(int now) { /* 线段树懒标记更新 */ }
  bool getmin(int x, int y) { /* 区间最小值查询 */ }
  void pls(int num, int x, int y) { /* 区间加减操作 */ }
  ```

### 题解2：鏡音リン（4星）
- **亮点**：动态规划结合差分归并优化，理论推导严谨；代码简洁但仅适用于小数据。
- **核心思想**：维护差分数组的凸性，利用闵可夫斯基和优化转移。

---

## 最优思路提炼

### 关键技巧
1. **贪心选择最大值**：优先队列维护候选地鼠，每次取最大剩余价值。
2. **线段树合法性校验**：区间减一操作模拟打击次数限制，通过最小值查询判断合法性。
3. **动态窗口维护**：每次窗口右移时，仅处理新增地鼠和调整历史选择。

### 实现步骤
1. **初始化线段树**：记录每个位置的最大允许打击次数。
2. **优先队列插入**：新地鼠入队，按价值降序排列。
3. **尝试打击**：取队顶元素，验证能否在当前窗口内合法打击。
4. **更新线段树**：合法则更新区间，否则丢弃该元素。

---

## 同类型题推荐
1. **P1886 滑动窗口**：单调队列维护窗口极值。
2. **P5490 扫描线**：线段树处理区间覆盖问题。
3. **P3372 线段树1**：基础线段树区间加减与查询。

---

## 个人心得摘录
- **bh1234666的调试经验**：线段树懒标记未及时下传导致错误，需确保每次操作前更新标记。
- **鏡音リン的顿悟**：差分数组的归并性质是动态规划优化的关键，需深入理解凸函数特性。

---

## 代码核心逻辑

### 贪心+线段树实现
```cpp
priority_queue<pair<int, int>> q; // 优先队列存储（位置，价值）
int tree[N], tag[N]; // 线段树及懒标记

// 线段树区间减一操作
void pls(int num, int x, int y, int now=1, int f=1, int l=n) {
    if (f >= x && l <= y) { tag[now] += num; return; }
    update(now);
    // 递归处理左右子区间
}

// 验证区间是否允许打击
bool getmin(int x, int y) {
    // 查询区间最小值是否非负
}

int main() {
    for (int i = l; i <= n; i++) {
        int rd = read();
        q.push({i, rd});
        pls(1, i-l+1, i); // 新窗口右移，更新线段树
        while (!q.empty()) {
            auto [pos, val] = q.top();
            if (getmin(pos, i)) { // 验证合法性
                pls(-1, pos, i); // 合法则打击
                ans += val;
                q.push({pos, val-1}); // 重新入队
                break;
            }
            q.pop(); // 非法则丢弃
        }
        cout << ans << " ";
    }
}
```

---

## 可视化设计示例（Canvas）
```javascript
// 初始化像素画布
const canvas = document.getElementById("game-canvas");
const ctx = canvas.getContext("2d");

// 绘制地鼠序列
function drawMoles(moles) {
    moles.forEach((mole, idx) => {
        ctx.fillStyle = "#8B0000"; // 深红色地鼠
        ctx.fillRect(idx * 20, 100 - mole.height * 5, 18, 18);
        ctx.fillText(mole.height, idx * 20, 90);
    });
}

// 播放打击音效
function playSound() {
    const audio = new Audio("data:audio/wav;base64,UklGRl9...");
    audio.play();
}
```

---
处理用时：67.22秒
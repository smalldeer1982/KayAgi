# 题目信息

# 「Wdoi-2」纯粹的复仇女神

## 题目背景

>「因为，人类的历史与成长，就是战争的历史与成长。没有纷争，就没有成长。满足于现状，就等于人类放弃了生存。月之民每天都为地上人考虑着。地上人的历史，就是月之民创造的。」

「我对月之民还是很了解的。这么说吧，她们在各式各样的异世界的居民中，属于最恶劣的那一类。超级排他，超级没自由，虚构的乐园，虽然擅长鄙视别人，但无法容忍自己被当成笨蛋。她们甚至认为其他世界的居民连杂菌都不如。」

「最重要的问题是，月之民敌视着幻想乡，就是这样的。」 

「没想到竟然会把地上人送到月面上来，之前丝毫没有过这种想法呢。那些眼里容不下一点沙子的月之民，竟然会使用这种不入流的手段。」

「幻想乡被作为人质绑架了，可以这么认为吧？要是想拯救幻想乡的话，就不许对月之都动手，就是这种不人道的策略。」

遥遥 $38$ 万公里航程之外，于此故乡之星倒映之海，打败不共戴天之敌，击碎永久不得醒之梦。

> 不倶戴天の敵、$\stackrel{じょうが}{嫦娥}$よ。見てるか！？    
> 不共戴天之敌，嫦娥啊。你在看着吗！？

## 题目描述

### 简要题意

给定一个长度为 $n$ 的序列，序列中每个元素是一个二元组 $(c_i,a_i)$，分别表示颜色与权值。

现在有 $q$ 次询问，每次给出一个区间 $[l,r]$，求：

$$\max\limits_{k=1}^n \left\{\min\limits_{l\le i \le r,c_i=k} a_i\right\}$$

特别地，如果 $[l,r]$ 内没有颜色为 $k$ 的值，后面的部分定义为 $0$。
### 原始题意
纯狐的能力是纯化，一旦灵梦身上的污秽被纯化，则必死无疑。

灵梦携带了 $n$ 张一字排开的灵符用于转嫁污秽，但纯狐依旧可以纯化附着在上面的污秽，置灵梦于死地。

具体地，每次纯狐命中一个区间 $[l_i,r_i]$ 中的所有灵符，灵梦需要在此之前净化这些灵符上面的污秽。  
每张灵符有固定的颜色 $c_i$，经过激烈的战斗，每张灵符上沾染了 $a_i$ 单位的污秽。  
同种颜色的灵符之间相互作用，净化区间内一批相同颜色的灵符，其灵力花费为这些灵符上污秽的最小值。  
由于逸散的灵力可以为其他灵符所吸收，灵梦只需知道该区间内所有颜色的灵符净化花费的最大值，此为她净化一次的灵力花费。

给定 $\{c_i\}$ 和 $\{a_i\}$，每次给出纯狐的一种可能的攻击 $l_i,r_i$，问灵梦净化一次的灵力花费。注意只是计算，每次给出答案后并不改变 $\{c_i\}$ 和 $\{a_i\}$。

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/yu9grxjy.png)

如图，数字代表权值，背景色代表颜色。

- 对于区间 $[3,4]$，出现的两种颜色对应的权值最小值为 $10$ 和 $4$，取最大值答案为 $10$。
- 对于区间 $[3,9]$，出现的三种颜色对应的权值最小值为 $1,4$ 和 $4$，取最大值答案为 $4$。
- 对于区间 $[4,8]$，出现的三种颜色对应的权值最小值为 $1,4$ 和 $4$，取最大值答案为 $4$。
- 对于区间 $[3,6]$，出现的两种颜色对应的权值最小值为 $9$ 和 $4$，取最大值答案为 $9$。
- 对于区间 $[3,3]$，出现的一种颜色对应的权值最小值为 $10$。
其余同理。

### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le } & \bm{q\le} & \textbf{特殊性质} & \textbf{Subtask 依赖} & \textbf{分值}\\\hline
1 & 100 & 100 & - & - & 10\\\hline
2 & 2 \times 10^5 & 2\times 10^5 & \textbf A & - & 20\\\hline
3 & 2 \times 10^5 & 2\times 10^5 & - & 2 & 30\\\hline
4 & 2 \times 10^5 & 10^6 & - & 1,3 & 40\\\hline
\end{array}
$$

特殊性质 $\textbf A$：所有的 $c_i \leq 10$。

对于全部数据，保证 $1 \leq n \leq 2\times10^5$，$1 \leq q \leq 10^6$，$1 \le c_i,a_i \le n$，$l \leq r$。

## 样例 #1

### 输入

```
10 10
3 2 2 1 2 1 3 2 1 2 
10 4 10 4 9 8 1 4 9 4 
3 4
3 9
4 8
3 6
3 3
9 10
5 8
5 8
6 8
5 8
```

### 输出

```
10
4
4
9
10
9
8
8
8
8
```

# AI分析结果



## 【算法分类】
扫描线 + 线段树标记永久化

---

## 【题解思路与难点分析】

### 核心思路
1. **贡献区间推导**：每个元素 $a_i$ 作为颜色 $c_i$ 的最小值时，其有效区间为左端点 $[L, i]$ 且右端点 $[i, R]$。其中：
   - $L$ 是左侧第一个比 $a_i$ 小的同色元素位置 $+1$
   - $R$ 是右侧第一个比 $a_i$ 小的同色元素位置 $-1$
2. **矩形覆盖模型**：每个元素对应一个矩形区域 $[L, i] \times [i, R]$，该区域内的所有查询会被 $a_i$ 更新最大值
3. **扫描线处理**：沿 $x$ 轴（左端点）扫描，线段树维护 $y$ 轴（右端点）的最大值
4. **标记永久化优化**：使用两个优先队列模拟可删除堆，解决线段树区间更新的高效维护问题

### 解决难点
1. **高效维护动态区间最大值**：通过标记永久化线段树，每个节点维护两个堆（插入堆和删除堆），查询时动态清理无效元素
2. **单调栈预处理贡献区间**：对每个颜色维护单调递增栈，快速计算每个元素的 $L$ 和 $R$
3. **离线处理优化**：按右端点排序所有查询，扫描线逐步处理，避免重复计算

---

## 【题解评分 (≥4星)】

1. **Alex_Wei（5星）**  
   - 亮点：标记永久化线段树 + 双堆优化，代码结构清晰，时间复杂度最优
   - 关键代码：
     ```cpp
     void modify(int l, int r, int ql, int qr, int x, int v) {
       if(ql <= l && r <= qr) {
         if(v > 0) val[x].push(v);
         else era[x].push(-v);
         return;
       }
       // ... 拆分区间递归处理
     }
     ```

2. **离散小波变换°（4星）**  
   - 亮点：详细图解贡献区间推导，标记永久化原理阐述清晰
   - 关键代码：
     ```cpp
     void modify(int t,int a,int b,int l,int r,int w){
       if(l<=a&&b<=r) O[t].insert(w); // 标记永久化插入
       // ... 递归处理子区间
     }
     ```

3. **Purslane（4星）**  
   - 亮点：提出整体二分替代方案，创新性思路扩展解题维度
   - 关键代码：
     ```cpp
     void solve(int l,int r,vector<INFO> qr) {
       if(l==r||qr.empty()) return; // 整体二分核心逻辑
       // ... 分治处理
     }
     ```

---

## 【最优思路提炼】

### 关键技巧
1. **单调栈预处理**：对每个颜色维护单调递增栈，快速计算每个元素的有效区间
   ```python
   for 颜色 c:
       while 栈顶元素值 ≥ 当前元素值:
           弹出栈顶
       计算当前元素的 L 和 R
   ```
2. **双堆模拟可删除堆**：用插入堆（val）和删除堆（era）维护动态最大值
   ```python
   def query(node):
       while val.top() == era.top():
           val.pop(); era.pop()
       return val.top() if not empty else 0
   ```
3. **标记永久化线段树**：避免标记下推，直接在查询路径上合并区间贡献

---

## 【同类题目推荐】
1. [P1972 HH的项链](https://www.luogu.com.cn/problem/P1972)  
   **相似点**：离线处理 + 扫描线 + 树状数组/线段树维护区间统计

2. [P4198 楼房重建](https://www.luogu.com.cn/problem/P4198)  
   **相似点**：单调栈思想 + 线段树维护区间极值特性

3. [P4137 Rmq Problem](https://www.luogu.com.cn/problem/P4137)  
   **相似点**：离线处理 + 分块/莫队维护区间 mex 值

---

## 【可视化算法演示】

### 动画设计（复古像素风格）
1. **数据结构展示**：  
   - 左侧：8-bit 风格线段树节点，每个节点显示双堆的当前最大值
   - 右侧：扫描线进度条和当前处理的矩形区域（闪烁高亮）

2. **关键操作演示**：
   - **步骤1**（黄色闪烁）：单调栈预处理时，弹出栈顶元素，显示新的 $L/R$ 计算过程
   - **步骤2**（绿色扫描线）：从左到右移动扫描线，触发线段树的区间更新操作
   - **步骤3**（红色高亮）：查询时遍历线段树路径，动态清理双堆的无效元素

3. **音效设计**：
   - 插入操作：8-bit "哔" 声
   - 删除操作：短促 "咔嚓" 声
   - 查询成功：上扬音阶

---

## 【核心代码实现】
```cpp
// 线段树节点定义（标记永久化 + 双堆优化）
struct Node {
    priority_queue<int> val, era;
    int get_max() {
        while (!era.empty() && val.top() == era.top()) 
            val.pop(), era.pop();
        return val.empty() ? 0 : val.top();
    }
} tr[N<<2];

void update(int u, int l, int r, int ql, int qr, int v, bool add) {
    if (ql <= l && r <= qr) {
        if (add) tr[u].val.push(v);
        else tr[u].era.push(v);
        return;
    }
    // ... 递归更新子区间
}

int query(int u, int l, int r, int pos) {
    int res = tr[u].get_max();
    if (l == r) return res;
    // ... 递归查询子区间并取最大值
}
```

---

## 【总结】
本题通过将颜色贡献转化为矩形覆盖问题，结合扫描线和标记永久化线段树，实现了高效的区间极值查询。核心难点在于动态维护覆盖区间的最大值，通过双堆技巧和单调栈预处理巧妙解决。同类问题可借鉴离线处理与特殊数据结构的结合思路。

---
处理用时：84.74秒
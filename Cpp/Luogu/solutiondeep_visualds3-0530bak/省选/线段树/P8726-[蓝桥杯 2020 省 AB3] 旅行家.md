# 题目信息

# [蓝桥杯 2020 省 AB3] 旅行家

## 题目描述

从前，在海上有 $n$ 个岛屿，编号 $1$ 至 $n$。居民们深受洋流困扰，无法到达比自己当前所在岛屿编号更小的岛屿。经过数年以后，岛屿上的人数随着岛屿的编号递增（可能相等）。作为一名出色的旅行家（$\mathrm{RP}$ 学家），你想从 $1$ 号岛屿出发开启一次旅程，以获得更多的 $\mathrm{RP}$，因为受到海洋的洋流影响，你只能去到比当前岛屿编号更大的岛屿。因为你比较善良，你会在离开一个岛屿的时候将你的 $\mathrm{RP}$ 分散给岛民，具体地：你的 $\mathrm{RP}$ 会除以 $2$（用去尾法取整，或者说向零取整）（当你的 $\mathrm{RP}$ 小于零时，岛民也依旧要帮你分担，毕竟你们已经建立起了深厚的友谊)。

第 $i$ 号岛屿有 $T_{i}$ 人，但是你很挑剔，每次你从 $j$ 号岛屿到达 $i$ 号岛屿时，你只会在到达的岛屿上做 $T_{i} \times T_{j}$ 件好事（一件好事可以获得 $1$ 点 $\mathrm{RP}$ )。

唯一不足的是，由于你在岛上住宿，劳民伤财，你会扣除巨量 RP，第 $i$ 号岛屿的住宿扣除 $F_{i}$ 点 $\mathrm{RP}$。

注意: 将离开一个岛屿时，先将 $\mathrm{RP}$ 扣除一半，再扣除住宿的 $\mathrm{RP}$，最后在新到达的岛屿上做好事，增加 $\mathrm{RP}$。离开 $1$ 号岛屿时需要扣除在 $1$ 号岛屿住宿的 $\mathrm{RP}$，当到达这段旅程的最后一个岛屿上时，要做完好事，行程才能结束，也就是说不用扣除在最后到达的岛屿上住宿的 $\mathrm{RP}$ 。

你因为热爱旅行（RP），所以从 $1$ 号岛屿开始旅行，初始时你有 $0$ 点 $\mathrm{RP}$。你希望选择一些岛屿经过，最终选择一个岛屿停下来，求最大的 $\mathrm{RP}$ 值是多少?

## 说明/提示

**【样例说明】**

从一号岛屿直接走到三号岛屿最优，初始 $0$ 点 $\mathrm{RP}$，扣除一半取整变成 $0$ 点。扣除在一号节点住宿的 $1 \mathrm{RP}$，在三号岛屿做好事产生 $4 \times 5=20$ 点 $\mathrm{RP}$。最终得到 $19$ 点 $R P$ 。

**【评测用例规模与约定】**

对于 $20 \%$ 的评测用例，$1 \leq n \leq 15$;

对于 $70 \%$ 的评测用例，$1 \leq n \leq 5000$;

对于所有评测用例，$1 \leq n \leq 5\times10^5,1 \leq T_{i} \leq 20000,1 \leq F_{i} \leq 2\times 10^8$。给定的 $T_{i}$ 已经按照升序排序。

建议使用 64 位有符号整数进行运算。

蓝桥杯 2020 第三轮省赛 AB 组 J 题。

Upd.2024.7.13 已添加hack数据

## 样例 #1

### 输入

```
3
4 4 5
1 10 3```

### 输出

```
19```

## 样例 #2

### 输入

```
5
969 980 1013 1016 1021
888423 945460 865822 896150 946615```

### 输出

```
246172```

# AI分析结果



# 算法分类  
**动态规划优化（斜率优化/李超线段树）**

---

## 题解思路与核心难点  
### 关键逻辑推导  
- **动态规划方程**：  
  $$dp_i = \max_{j < i} \left( \left\lfloor \frac{dp_j}{2} \right\rfloor - F_j + T_i \cdot T_j \right)$$  
  本质是求所有前驱状态 $j$ 的线性组合最大值。  

### 解决难点  
1. **直接暴力DP的复杂度为 $O(n^2)$**，无法处理 $n \leq 5 \times 10^5$ 的数据。  
2. **优化方向**：将问题转化为一次函数最值问题，利用数据结构或数学性质加速。  

### 主要优化方法对比  
| 方法              | 适用条件       | 时间复杂度 | 核心思想                                                                 |
|-------------------|---------------|------------|--------------------------------------------------------------------------|
| **斜率优化**       | $T_i$ 单调递增 | $O(n)$     | 维护凸包，用单调队列快速找到最优决策点。决策点斜率单调，队列头即为最优。|
| **李超线段树**     | $T_i$ 无限制   | $O(n \log V)$ | 将每个 $j$ 视为直线 $y = T_j x + (\lfloor dp_j/2 \rfloor - F_j)$，线段树维护区间最大值。|
| **CDQ分治**        | $T_i$ 无序    | $O(n \log n)$ | 强制决策顺序，分治处理左右子问题后再合并，结合斜率优化。                |

---

## 题解评分（≥4星）  
1. **Super_Cube（斜率优化）**  
   - 评分：⭐️⭐️⭐️⭐️⭐️  
   - 亮点：利用 $T_i$ 单调性简化凸包维护，代码简洁高效（时间复杂度 $O(n)$）。  
   - 核心代码：  
     ```cpp
     while(q.size()>1 && slope(q[0], q[1]) >= -a[i]) q.pop_front();
     dp[i] = dp[q[0]]/2 + a[i]*a[q[0]] - b[q[0]];
     ```

2. **未来姚班zyl（李超线段树）**  
   - 评分：⭐️⭐️⭐️⭐️  
   - 亮点：标准李超线段树实现，逻辑清晰，适用于更广泛的 $T_i$ 取值范围。  
   - 核心代码：  
     ```cpp
     int query(int x, int l, int r, int p) {
         if(l == r) return get(p, xd[x]);
         return max(get(p, xd[x]), p <= mid ? query(lc, p) : query(rc, p));
     }
     ```

3. **MornStar（李超线段树详解）**  
   - 评分：⭐️⭐️⭐️⭐️  
   - 亮点：详细讲解李超线段树原理，附带图示和代码注释，适合初学者理解。  

---

## 最优思路与技巧  
1. **斜率优化（T_i 单调时）**  
   - **核心技巧**：将决策点 $(T_j, \lfloor dp_j/2 \rfloor - F_j)$ 视为坐标系中的点，维护上凸包。  
   - **决策条件**：直线斜率 $-T_i$ 单调递减，队首元素即为最优决策。  
   - **代码关键**：用双端队列维护凸包，保证队列中相邻点斜率单调递减。  

2. **李超线段树（通用解法）**  
   - **核心技巧**：将每个决策点 $j$ 视为直线 $y = T_j x + b_j$，线段树维护区间内最大 $y$ 值。  
   - **优化点**：通过递归下传标记，动态更新优势线段，保证查询效率。  

---

## 同类型题目  
1. **[P3195 [HNOI2008] 玩具装箱](https://www.luogu.com.cn/problem/P3195)**  
   - 动态规划 + 斜率优化，决策点斜率单调。  

2. **[P5785 [SDOI2012] 任务安排](https://www.luogu.com.cn/problem/P5785)**  
   - 费用提前计算，结合斜率优化与凸包维护。  

3. **[P4097 [HEOI2013] Segment](https://www.luogu.com.cn/problem/P4097)**  
   - 李超线段树模板题，练习插入线段与查询最值。  

---

## 可视化设计  
### 斜率优化动画方案  
1. **凸包动态维护**：  
   - **Canvas 绘制**：岛屿编号从小到大排列，每个决策点显示为点 $(T_j, \lfloor dp_j/2 \rfloor - F_j)$。  
   - **颜色标记**：当前决策点（红色）、队列中的有效凸包点（绿色），被弹出的点（灰色）。  
   - **步进控制**：展示队列头尾调整过程，高亮当前查询的斜率 $-T_i$。  

2. **复古像素风格**：  
   - **8位音效**：插入点（短促“滴”声），弹出点（低沉“咚”声），查询成功（上扬音调）。  
   - **网格背景**：坐标轴以16x16像素块划分，动态显示直线与交点。  

### 李超线段树演示  
- **动态插入与查询**：  
  - 线段树节点显示当前区间的优势线段。  
  - 插入新线段时，递归下传标记，高亮被替换的优势线段。  
  - 查询时，沿路径展示各节点贡献的最大值。  

---

## 代码实现（核心片段）  
### 斜率优化（Super_Cube）  
```cpp
std::deque<int> q;
for (int i = 2; i <= n; ++i) {
    while (q.size() > 1 && slope(q[0], q[1]) >= -a[i]) 
        q.pop_front();
    dp[i] = dp[q[0]]/2 + a[i]*a[q[0]] - b[q[0]];
    while (q.size() > 1 && slope(q.back(), i) >= slope(*(q.end()-2), q.back())) 
        q.pop_back();
    q.push_back(i);
}
```

### 李超线段树（未来姚班zyl）  
```cpp
void pushdown(int x, int l, int r, int id) {
    if (!xd[x]) xd[x] = id;
    if (get(mid, id) > get(mid, xd[x])) swap(id, xd[x]);
    if (get(l, id) > get(l, xd[x])) pushdown(lc, id);
    if (get(r, id) > get(r, xd[x])) pushdown(rc, id);
}
```

---

## 个人心得摘录  
- **初始化为极小值**：多个题解强调初始化线段树节点为 `-INF`，否则无法正确处理负数情况。  
- **整数除法陷阱**：`dp[j]/2` 需用向零取整，C++中直接 `a / 2` 即可，但需注意负数处理。  
- **Hack数据注意点**：部分题解因未初始化或范围错误被Hack，需严格验证边界条件。  

---

**总结**：本题核心在于将动态规划方程转化为几何最值问题，利用斜率优化或李超线段树高效求解。两种方法各有适用场景，需根据数据特性选择最优解。

---
处理用时：84.89秒
# 题目信息

# [USACO23JAN] Mana Collection P

## 题目描述

## 题目背景

**注意：这个问题的时间限制是5秒，是默认的2.5倍。这个问题的内存限制是512MB，是默认值的两倍。**


贝西需要为一个非常重要的法术收集法力。贝西有 $N$  $(1\le N\le 18)$ 个法力池，其中第 $i$ 个法力池每秒可积累 $m_i$ 法力 $(1\le m_i\le 10^8)$ 。这些池子由 $M$ $(0\le M\le N \cdot (N-1))$  条有向边 $(a_i,b_i,t_i)$ 连接，这意味着她可以在 $t_i$ 秒内从 $a_i$ 移动到 $b_i$ $(1\le a_i, b_i\le N$, $a_i\neq b_i$, $1\le t_i\le 10^9)$ 。每当贝西出现在一个池子里，她就可以收集储存在那个地方的所有法力，把它清空。在 $0$ 的时候，所有的法力池都是空的，贝西可以选择任何一个池子来开始收集。

回答 $Q$ $(1\le Q\le 2\cdot 10^5)$ 个查询，每个查询由两个整数 $s$ 和 $e$ 指定 $(1\le s\le 10^9$，$1\le e\le N)$ 。对于每个查询，如果贝西在第 $s$ 秒结束时必须在法力池 $e$ 处，请确定她在 $s$ 秒内能收集的最大法力值。

## 说明/提示

对于第一个样例：

第一次询问。贝西在 $5$ 秒后从水池 $1$ 中取出 $5$ 个法力值。

第二次查询。 $5$ 秒后，贝西从水池 $2$ 中获取 $50$ 点法力。

第三次查询。 $100$ 秒后，贝西从水池 $1$ 中获取 $100$ 法力值。

第四次查询。 $90$ 秒后贝西从水池 $1$ 中获得 $90$ 法力， $100$ 秒后从水池 $2$ 中获得 $1000$ 法力。

测试点 $3-4$: $N\le 10, Q\le 100$ 。

测试点 $5-9$: $N\le 10$ 。

测试点 $10-14$: $Q\le 100$ 。

测试点 $15-17$: $N = 16$ 。

测试点 $18-20$: $N = 17$ 。

测试点 $21-24$：没有其他约束条件 。

## 样例 #1

### 输入

```
2 1
1 10
1 2 10
4
5 1
5 2
100 1
100 2```

### 输出

```
5
50
100
1090```

## 样例 #2

### 输入

```
4 8
50000000 100000000 20000000 70000000
1 2 20
2 1 50
2 3 90
1 3 40
3 1 10
4 1 25
1 4 5
4 3 70
3
8 3
1000000000 1
500000 4```

### 输出

```
160000000
239999988050000000
119992550000000```

# AI分析结果



## 算法分类
**状压DP + 斜率优化/李超树**

---

## 综合分析与结论
### 核心思路
1. **预处理最短路**：用 Floyd 算法计算所有点对的最短路径，保证移动时间最优。
2. **状压DP建模**：状态 `dp[S][i]` 表示访问点集合 `S` 且最后在点 `i` 的最小损失法力。转移时枚举下一个点 `j`，状态转移方程为 `dp[S|j][j] = min(dp[S][i] + sum(S)*dis(i,j))`，其中 `sum(S)` 是集合 `S` 的总法力速率。
3. **转化为线性函数**：每个状态对应一次函数 `ans = s*sum(S) - dp[S][e]`，其中 `sum(S)` 是斜率，`-dp[S][e]` 是截距。
4. **处理查询**：对每个终点 `e`，维护所有相关直线的凸包或插入李超树，查询时找到最大值。

### 解决难点
- **时间约束处理**：通过保证 `d_i ≥ 0`，舍弃无效路径，确保状态合法性。
- **高效查询**：利用凸包单调性离线二分或动态开点李超树在线处理 2e5 次查询。

### 可视化设计
- **动画流程**：
  1. **最短路计算**：展示 Floyd 算法动态更新各点对最短路径。
  2. **状压DP转移**：用网格图表示状态集合 `S`，高亮当前添加的点和转移路径。
  3. **直线插入/查询**：在 Canvas 上绘制直线，凸包维护时动态显示淘汰过程，李超树插入时显示节点分裂。
- **复古像素风格**：
  - **数据结构**：状态集合用 8-bit 像素方块表示，不同颜色区分已访问点。
  - **音效**：插入直线时播放“哔”声，查询命中播放“叮”声，错误路径播放低沉音效。

---

## 题解评分 (≥4星)
1. **Ecrade_ (4.5星)**  
   - **亮点**：离线凸包预处理，代码结构清晰，复杂度分析准确。  
   - **代码**：预处理后每个终点维护凸包，查询时二分，时间复杂度优秀。

2. **_ZSR_ (4星)**  
   - **亮点**：动态开点李超树处理在线查询，代码简洁，适合大量查询场景。  
   - **优化**：直接维护每个终点的李超树，查询效率稳定。

---

## 最优思路提炼
1. **状态设计**：状压表示访问点集合，终点作为状态附加维度。
2. **损失函数转换**：将路径损失转换为线性函数，最大化 `s*sum - loss`。
3. **数据结构优化**：凸包离线处理或李超树在线维护，快速响应查询。

---

## 类似题目推荐
1. **P2839 [国家集训队]middle**（中位数性质+线段树）
2. **P3628 [APIO2010]特别行动队**（斜率优化DP）
3. **P6242 【模板】线段树 3**（李超树应用）

---

## 代码片段 (Ecrade_)
```cpp
// 预处理状压DP
for (ll i = 1;i < (1 << n);i += 1) {
    for (ll j = 1;j <= n;j += 1) if (i & (1 << j - 1)) {
        sum[i] += a[j];
        ll qwq = i ^ (1 << j - 1);
        if (!qwq) { f[i][j] = 0; break; }
        for (ll k = 1;k <= n;k += 1) if (qwq & (1 << k - 1)) {
            f[i][j] = min(f[i][j], f[qwq][k] + sum[qwq] * dis[k][j]);
        }
    }
}
// 构建凸包
void work(ll o){
    sort(seg[o].begin(),seg[o].end(),cmp);
    stk[o].emplace_back(0),pnt[o].emplace_back(-1e18);
    for (ll i = 0;i < seg[o].size();i += 1){
        st now = seg[o][i];
        while (stk[o].size() > 1 && get(o,i,stk[o].back()) < pnt[o].back()){
            stk[o].pop_back(),pnt[o].pop_back();
        }
        pnt[o].emplace_back(get(o,i,stk[o].back())),stk[o].emplace_back(i);
    }
}
```

---

## 可视化与复古效果
- **Canvas 绘制**：每个状态对应像素块，红色表示已访问，绿色为当前终点。
- **自动演示**：按时间步进，显示路径扩展和直线插入过程，背景播放 8-bit 循环音乐。
- **交互控制**：支持暂停/继续，调整动画速度，查看当前最优直线。

---
处理用时：65.24秒
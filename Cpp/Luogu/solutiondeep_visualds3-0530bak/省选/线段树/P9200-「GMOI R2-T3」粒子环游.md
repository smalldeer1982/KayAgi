# 题目信息

# 「GMOI R2-T3」粒子环游

## 题目背景

热爱珂学的小 Z 正在进行一项无聊的实验。

## 题目描述

实验室中有一个由 $n$ 个实验腔连接而成的环形轨道，其中第 $i$ 个实验腔顺时针连向第 $i+1$ 个实验腔（特别的，第 $n$ 个实验腔连向第 $1$ 个实验腔）。同时还有一个标号为 $n+1$ 的新建实验腔要接入这个环形轨道。它可以接在任意两个原本相连的实验腔之间。

第 $i$ 个实验腔可以将带电荷量为 $Q$ 的粒子运输到它的下一个实验腔，这个过程花费的能量为 $\vert Q \vert \times c_i$。除此之外，第 $i$ 个实验腔本身就存储了量为 $e_i$ 的电荷（电荷量有正负）。由于众所周知的电荷守恒定律，第 $n+1$ 个实验腔储存的电荷量与前 $n$ 个实验腔储存的总电荷量的代数和为 $0$。

小 Z 有一个原本不带电的粒子。等到第 $n+1$ 个实验腔接入轨道后，他要任选一个实验腔（包括第 $n+1$ 个）作为出发点，将粒子放入，并使之在实验腔的能量驱动下顺时针环游一周回到出发点。粒子每到达一个实验腔（包括出发点），它所带电荷量就会变成原来所带的电荷量和这个实验腔所储存的电荷量的代数和。

**注意：电荷量会先加上实验腔所含电荷量，再计算能量贡献。**

现在，小 Z 想知道，在所有接入新建实验腔并选定出发点的方案中，粒子环游一周所需的能量最少为多少？

## 说明/提示

样例 $1$ 解释：一种最优方案为将 $4$ 号实验腔接在 $3$ 号实验腔与 $1$ 号实验腔之间，以 $4$ 号实验腔为出发点，花费能量为 $ 1\times 2\ +\ 4\times 1\ + \vert -1 \vert \times 3 \ +\ 0 \times 2 =9$。

**本题采用 Subtask 捆绑测试。**

| Subtask | $n\le$ | $c_i\le$ | $\vert e_i\vert$ | 特殊性质 | 对应测试点 | 总分 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $300$ | $100$ | $100$ | $-$ | $1\sim 5$ | $10$ |
| $1$ | $10^3$ | $10^3$ | $10^3$ | $\bf A$ | $6\sim 7$ | $5$ |
| $2$ | $10^4$ | $10^4$ | $10^4$ | $-$ | $8\sim12$ | $15$ |
| $3$ | $10^5$ | $10^5$ | $10^5$ | $\bf B$ | $13\sim 16$ | $10$ |
| $4$ | $2.5\times 10^5$ | $10^5$ |$10^5$ | $-$ | $17\sim 25$ | $60$ |

特殊性质 $\bf A$：对于所有的 $i\in[1,n+1](i\in \Z)$，满足 $c_i=0$。

特殊性质 $\bf B$：对于所有的 $i\in[1,n+1](i\in \Z)$，满足 $c_i=1$。

对于 $100\%$ 的数据，$1\le n\le 2.5\times 10^5$，$0\le c_i\le 10^5$，$0\le |e_i|\le 10^5$。

保证答案在 long long 范围内。

## 样例 #1

### 输入

```
3
1 3 2 2
3 -5 1```

### 输出

```
9```

## 样例 #2

### 输入

```
12
4 7 7 8 8 4 5 5 9 10 1 1 10 
0 -5 7 8 1 -1 -6 8 2 4 10 8 ```

### 输出

```
509```

# AI分析结果



# 算法分类  
**前缀和与权值线段树/树状数组维护带权中位数**

---

## 综合分析与结论  
### 核心思路  
1. **电荷守恒与带权中位数**：  
   - 电荷守恒使得所有实验腔电荷总和为 0，转化为前缀和数组 `s[]`  
   - 能量公式等价于在数轴上选择起点，使所有点到起点的加权绝对距离和最小，即带权中位数问题  

2. **动态维护插入位置**：  
   - 插入位置变化仅影响相邻两个实验腔的前缀和 `s[i]`  
   - 每次调整时，在线段树中动态删除旧值、插入新值  

3. **权值线段树二分**：  
   - 维护所有 `s[i]` 的权值分布，快速找到使总权重过半的中位数点  
   - 通过线段树查询左右两侧的权重和与坐标和，计算总能量  

### 可视化设计思路  
- **动画方案**：  
  1. **数轴展示**：在 Canvas 上绘制数轴，动态显示所有实验腔的 `s[i]` 点（带权）  
  2. **中位点高亮**：红色方块标记当前最优起点（中位数点）  
  3. **插入位置移动**：蓝色箭头表示插入位置移动，触发相邻点的前缀和更新  
  4. **线段树结构**：右侧面板展示线段树节点，动态高亮被更新的区间  

- **复古像素风格**：  
  - **8位调色板**：使用 16 色（如深蓝、浅蓝、红、黄）区分不同元素  
  - **音效提示**：  
    - 插入位置移动时播放 "blip" 音效  
    - 计算中位数时播放 "coin" 音效  
    - 找到全局最小值时播放 8-bit 胜利音效  

---

## 题解清单（≥4星）  
### 1. yinhy09（⭐⭐⭐⭐⭐）  
- **亮点**：  
  - 使用四树状数组分类维护绝对值贡献，逻辑清晰  
  - 离散化预处理，大幅降低空间复杂度  
- **核心代码**：  
  ```cpp  
  // 树状数组维护四类值：大于/小于当前点的 c 和 s*c  
  void add(int u, int pt, int s, int c, int pos) {  
      nds[u].c += c * pos; nds[u].x += c * s * pos;  
      if (nds[u].l == nds[u].r) return;  
      // 递归更新子节点...  
  }  
  ```

### 2. Aiopr_2378（⭐⭐⭐⭐）  
- **亮点**：  
  - 动态开点线段树处理大值域，避免离散化  
  - 详细推导电荷守恒与中位数关系  
- **关键推导**：  
  ```  
  电荷守恒 → ∑e_i = 0 → s_{n+1} = 0  
  能量公式 → 最小化 ∑|s_j - s_p| * c_j → 中位数点  
  ```

### 3. _Fatalis_（⭐⭐⭐⭐）  
- **亮点**：  
  - 将 `c_i` 视为点权，转化为经典中位数问题  
  - 插入位置调整时仅交换相邻元素，降低维护复杂度  
- **代码片段**：  
  ```cpp  
  swap(e[i], e[i-1]); swap(c[i], c[i-1]);  // 调整插入位置  
  ```

---

## 最优思路提炼  
### 关键技巧  
1. **前缀和转换**：  
   - 电荷累加转为前缀和 `s[i] = s[i-1] + e[i]`，环状特性保证 `s[n+1] = 0`  

2. **带权中位数优化**：  
   - 最优起点对应 `s[]` 的中位数点，通过线段树二分快速定位  

3. **动态维护**：  
   - 插入位置变化仅需调整相邻两个点的前缀和与权值  

### 代码实现  
```cpp  
// 线段树二分找中位数  
int findmid(int p, ll l, ll r, ll k) {  
    if (l == r) return l;  
    if (tree[ls].sz >= k) return findmid(ls, l, mid, k);  
    return findmid(rs, mid+1, r, k - tree[ls].sz);  
}  

// 计算总能量  
ll calc(int mid_pos) {  
    ll left_sum = query_left_sum(mid_pos);  
    ll right_sum = query_right_sum(mid_pos);  
    return right_sum - left_sum + mid_val * (left_cnt - right_cnt);  
}  
```

---

## 相似题目推荐  
1. **P1168 中位数**（静态中位数，权值线段树）  
2. **P3369 普通平衡树**（动态维护中位数）  
3. **CF845D Driving Test**（前缀和与绝对值优化）  

---

## 可视化核心代码（JS Canvas）  
```javascript  
function drawParticles(ctx, s, c) {  
  ctx.clearRect(0, 0, canvas.width, canvas.height);  
  s.forEach((val, idx) => {  
    const x = val * scaleX + offsetX;  
    const y = 100 + idx * 30;  
    ctx.fillStyle = idx === currentBest ? "#FF0000" : "#00FF00";  
    ctx.fillRect(x, y, 10 * c[idx], 10); // 宽度反映权重  
  });  
}  
```

---
处理用时：68.81秒
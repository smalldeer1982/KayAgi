# 题目信息

# [JOISC 2023] Passport (Day1)

## 题目描述

护照是旅行家进入他国时使用的证件。

在一个星球上有 $N$ 个国家，从 $1$ 到 $N$ 编号。每个国家都签发一种护照。当旅行家获得由国家$i \ (1 \le i \le N)$ 签发的护照后，他能够进入国家 $L_i, L_{i + 1}, \dots, R_i$。**这里保证旅行家能够进入其签证的签发国。形式上地说, $L_i \le i \le R_i$ 必然成立。**

你有一个爱旅行的朋友。即使他奢望能环游世界，但他最初一种护照也没有。因此，他想通过一下重复以下两项行为来环游这 $N$ 个国家。

- 获得他当前所在国家签发的护照。
- 用他现有的护照进入某个国家。

知道他的计划后，你想知道这个计划的是否可行，和如果可行的话，他最少需要的护照数量。因为你并不清楚他现在身处何国，所以你预测了 $Q$ 个他可能正居住在那的国家 $X_1, X_2, \dots, X_Q$。

现在给定各国护照的信息 $L_i, R_i$ 和他可能居住的 $Q$ 个国家，您需要写一个程序，对于每一个可能居住的国家，判断他是否可能环游这 $N$ 个国家，如果可能的话，计算出他需要的最少护照种数。

## 说明/提示

**【样例解释 #1】**

假设你的朋友居住在国家 $X_1 = 1$，一种可行的方式如下，最后他获得了 $2$ 种护照：

1. 获得国家 $1$ 签发的护照。
2. 用国家 $1$ 签发的护照去国家 $2$ 旅行。
3. 获得国家 $2$ 签发的护照。
4. 用国家 $1$ 签发的护照去国家 $3$ 旅行。
5. 用国家 $2$ 签发的护照去国家 $4$ 旅行。

可以证明不存在使用护照种数更小的方案，故输出 $2$。

该样例满足所有子任务的限制。

**【样例解释 #2】**

假设你的朋友居住在国家 $X_1 = 3$。一种可行的方式如下，最后他获得了 $4$ 种护照：

1. 获得国家 $3$ 签发的护照。
2. 用国家 $3$ 签发的护照去国家 $2$ 旅行。
3. 获得国家 $2$ 签发的护照。
4. 用国家 $2$ 签发的护照去国家 $4$ 旅行。
5. 获得国家 $4$ 签发的护照。
6. 用国家 $4$ 签发的护照去国家 $5$ 旅行。
7. 获得国家 $5$ 签发的护照。
8. 用国家 $5$ 签发的护照去国家 $1$ 旅行。

可以证明不存在使用护照种数更小的方案，故输出 $4$。

该样例满足子任务 $2 \sim 5$ 的限制。

**【样例解释 #3】**

例如，如果你的朋友居住在 $X_3 = 3$，一种可行的方案书获得国家 $3$ 签发的护照，并用它来依次去国家 $1, 2, 4, 5$ 旅行。故第三行输出 $3$。

但如果你的朋友居住在国家 $X_5 = 5$，即使他获得了国家 $5$ 签发的护照，他也不可能进入任何其他国家，因此，他无法实现自己的旅行计划。故第五行输出 $-1$。

该样例满足子任务 $4 \sim 5$ 的限制。

**【样例解释 #4】**

该样例满足子任务 $4 \sim 5$ 的限制。

## 样例 #1

### 输入

```
4
1 3
2 4
2 3
4 4
1
1
```

### 输出

```
2
```

## 样例 #2

### 输入

```
5
1 5
2 4
2 3
3 5
1 5
1
3
```

### 输出

```
4
```

## 样例 #3

### 输入

```
5
1 1
2 3
1 5
3 4
5 5
5
1
2
3
4
5
```

### 输出

```
-1
2
1
2
-1
```

## 样例 #4

### 输入

```
4
1 2
1 2
3 4
3 4
4
1
2
3
4
```

### 输出

```
-1
-1
-1
-1
```

# AI分析结果



**唯一算法分类**: 最短路与线段树优化建图

---

### **题解思路与解决难点**

1. **核心思路**:  
   - 将问题转化为**同时到达国家1和n的最少护照数**。因为覆盖所有国家的充要条件是能到达左右端点。
   - **线段树优化建图**处理每个护照的区间覆盖，将边数从O(N²)降为O(N logN)。
   - 两次反向BFS预处理每个点到1和n的最短距离（dis1和dis2），再通过松弛操作合并路径，计算最终答案。

2. **关键步骤**:  
   - **反图构建**: 每个国家i向区间[L_i, R_i]的虚节点连边，虚节点通过线段树结构连接子区间。
   - **BFS预处理**: 对1和n分别跑BFS，得到每个点到两端点的最短距离。
   - **松弛更新**: 每个点的初始答案为dis1[i] + dis2[i]，通过再次BFS松弛重复路径的贡献。

3. **解决难点**:  
   - **区间连边的高效处理**：线段树优化避免了暴力连边。
   - **路径合并的优化**：通过中继点模型，将分叉前后的路径合并计算，避免重复计算。

---

### **题解评分 (≥4星)**

1. **Zpair的题解 (⭐⭐⭐⭐⭐)**
   - **亮点**: 思路清晰，代码简洁高效，通过两次BFS预处理和一次松弛直接得出答案。
   - **代码片段**:
     ```cpp
     // 预处理dis1和dis2
     deque<int> que;
     que.push_front(1);
     while (!que.empty()) {
         int u = que.front(); que.pop_front();
         for (auto [v, w] : e[u]) {
             if (a[v] > a[u] + w) {
                 a[v] = a[u] + w;
                 if (w == 0) que.push_front(v);
                 else que.push_back(v);
             }
         }
     }
     // 松弛操作
     for (int i = 1; i <= n; i++) d[i] = a[i] + b[i] - (1 < i && i < n);
     sort(seq + 1, seq + n + 1, [&](int i, int j) { return d[i] < d[j]; });
     ```

2. **Elma_的题解 (⭐⭐⭐⭐)**
   - **亮点**: 强调中继点模型，将路径分叉前后的贡献分离。
   - **代码片段**:
     ```cpp
     // 计算分叉点贡献
     for (int i = 1; i <= n; i++) 
         sum[id[i]] = min(inf, sum[id[i]] + dis[id[i]] - 1);
     ```

3. **lfxxx的题解 (⭐⭐⭐⭐)**
   - **亮点**: 详细讨论路径合并的松弛过程，代码中优先队列优化。
   - **代码片段**:
     ```cpp
     priority_queue<node> q;
     for (int i = n + 1; i <= 2 * n; ++i) 
         if (mx[i] < INF) q.push({i, mx[i]});
     ```

---

### **最优思路提炼**

- **线段树优化建图**: 将区间[L_i, R_i]的边转为线段树节点连接，降低复杂度。
- **双端队列BFS (01-BFS)**: 处理边权为0和1的图，保证线性时间复杂度。
- **中继点松弛**: 合并到1和n的最短路径时，通过松弛操作消除重复贡献。

---

### **同类型题与算法套路**

1. **相似题目**:  
   - [USACO21DEC] Tickets P (Luogu P7984)
   - [NOI2019] 弹跳 (线段树优化建图)
   - [SNCPC2023] 区间覆盖问题

2. **通用套路**:  
   - **区间操作优化**: 线段树/分块处理区间覆盖。
   - **反向图最短路**: 将终点作为起点进行BFS/Dijkstra。

---

### **推荐题目**

1. **P7984 [USACO21DEC] Tickets P**  
   - 同样需要线段树优化建图处理区间覆盖。

2. **P6348 [PA2011] Journeys**  
   - 线段树优化建图的经典应用。

3. **P8025 [ONTAK2015] Związek Harcerstwa**  
   - 区间跳跃与最短路结合。

---

### **可视化与算法演示**

1. **核心动画设计**:  
   - **线段树结构**: 用网格展示线段树节点，国家i的区间[L_i, R_i]覆盖对应虚节点。
   - **BFS扩展**: 从1和n出发，动态显示队列中点的扩展，颜色区分dis1和dis2的更新。
   - **松弛过程**: 高亮当前松弛点，显示合并后的最短路径。

2. **复古像素风格**:  
   - **颜色方案**: 16色调色板，绿色表示已覆盖区间，红色表示当前操作节点。
   - **音效触发**: 每次BFS扩展时播放“点击”音效，找到最优解时播放胜利音效。

3. **交互控制**:  
   - **步进/暂停**: 观察BFS每一步的扩展逻辑。
   - **速度调节**: 调整动画快慢，适合不同学习节奏。

---

### **核心代码实现**

```cpp
// 线段树优化建图 (Zpair)
void build(int x, int l, int r) {
    id[x] = ++tot;
    if (l == r) return e[l].emplace_back(id[x], 0), void();
    build(x<<1, l, m), build(x<<1|1, m+1, r);
    e[id[x<<1]].emplace_back(id[x], 0);
    e[id[x<<1|1]].emplace_back(id[x], 0);
}
void add(int x, int l, int r, int ql, int qr, int v) {
    if (ql <= l && qr >= r) return e[id[x]].emplace_back(n+v, 0);
    if (ql <= m) add(x<<1, l, m, ql, qr, v);
    if (qr > m) add(x<<1|1, m+1, r, ql, qr, v);
}

// 双端队列BFS预处理dis1和dis2
deque<int> que;
que.push_front(1);
while (!que.empty()) {
    int u = que.front(); que.pop_front();
    for (auto [v, w] : e[u]) {
        if (dis[v] > dis[u] + w) {
            dis[v] = dis[u] + w;
            w == 0 ? que.push_front(v) : que.push_back(v);
        }
    }
}
```

---

**总结**: 本题通过线段树优化建图与反向BFS，高效解决了区间覆盖最短路问题，核心在于模型转化与数据结构优化。

---
处理用时：78.47秒
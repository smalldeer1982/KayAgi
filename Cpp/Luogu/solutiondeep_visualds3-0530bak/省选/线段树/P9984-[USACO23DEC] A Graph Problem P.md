# 题目信息

# [USACO23DEC] A Graph Problem P

## 题目描述

为了丰富自己的数学知识，Bessie 选修了一门图论课程，她发现她被下面的问题困住了，请帮帮她！

给出一张连通的无向图，包含编号为 $1\dots N$ 的节点和编号为 $1\dots M$（$2 \le N \le 2\cdot 10^5$，$N - 1 \le M \le 4 \cdot 10^5$）的边，下边的操作将被实施：

1. 假设集合 $S=\{v\}$，变量 $h=0$。
2. 当 $|S|<N$，重复执行：
	1. 仅有一个顶点在集合 $S$ 中的边中，找到编号最小的那条，编号记为 $e$。
    2. 将 $e$ 不在 $S$ 中的那个顶点加入集合 $S$。
    3. 将 $h$ 修改为 $10h+e$。
3. 返回 $h$ 对 $10^9+7$ 取模的值。

输出这个过程的全部返回值。

## 说明/提示

### 样例解释 2

考虑在 $i=3$ 开始执行。首先，选择 $2$ 号边，$S=\{3,4\}$，$h=2$。然后，选择 $3$ 号边，$S=\{2,3,4\}$，$h=23$。接着，选择 $1$ 号边，$S=\{1,2,3,4\}$，$h=231$。最后，选择 $5$ 号边，$S=\{1,2,3,4,5\}$，$h=2315$。因此，$i=3$ 的答案是 $2315$。

### 样例解释 3

确保答案对 $10^9+7$ 取模。

### 测试点性质

- 测试点 $4$ 满足 $N,M \le 2000$。
- 测试点 $5-6$ 满足 $N \le 2000$。
- 测试点 $7-10$ 满足 $N \le 10000$。
- 测试点 $11-14$ 满足对于所有边，有 $a_e+1=b_e$。
- 测试点 $15-23$ 没有额外限制。

## 样例 #1

### 输入

```
3 2
1 2
2 3```

### 输出

```
12
12
21```

## 样例 #2

### 输入

```
5 6
1 2
3 4
2 4
2 3
2 5
1 5```

### 输出

```
1325
1325
2315
2315
5132```

## 样例 #3

### 输入

```
15 14
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
10 11
11 12
12 13
13 14
14 15```

### 输出

```
678925929
678925929
678862929
678787329
678709839
678632097
178554320
218476543
321398766
431520989
542453212
653475435
764507558
875540761
986574081```

# AI分析结果



# 算法分类  
**并查集维护线性变换标记**  

---

## 综合分析与结论  
### 核心思路  
题目要求每个节点作为起点生成最小生成树时，按边编号顺序构造的哈希值。所有题解均基于以下观察：  
1. **生成树唯一性**：生成的边集是图的最小生成树（MST），边按编号从小到大选择。  
2. **合并操作的可叠加性**：每次合并两个连通块时，对原连通块节点的哈希值影响可表示为线性变换（`h_new = h_old * a + b`），其中 `a` 和 `b` 由合并的边和对方连通块决定。  

### 解决难点  
1. **高效维护动态变换**：传统逐个更新每个节点的哈希值会超时，需利用数据结构高效合并。  
2. **路径压缩与标记传递**：在并查集路径压缩时，需正确合并父子节点的线性变换标记。  

### 核心算法流程  
1. **Kruskal 合并**：按边编号从小到大合并连通块。  
2. **并查集维护标记**：每个连通块的根维护 `(mul, add)` 标记，表示该连通块内所有节点的哈希值需先乘 `mul` 再加 `add`。  
3. **合并时的标记更新**：合并两个连通块时，计算新标记并更新到并查集的父节点。  
4. **路径压缩处理**：查询时通过路径压缩动态合并标记，确保最终哈希值正确。  

### 可视化设计  
- **动画方案**：用颜色区分不同连通块，合并时显示当前边编号和标记更新过程。  
- **步进控制**：允许单步执行，观察每一步合并的连通块和标记变化。  
- **复古像素风格**：以 8-bit 网格表示节点，合并时播放“连接”音效，成功合并后高亮显示。  

---

## 题解清单 (≥4星)  
1. **I_am_Accepted（★★★★★）**  
   - **亮点**：利用并查集维护线性变换标记，路径压缩时动态合并，代码简洁高效。  
   - **关键代码**：  
     ```cpp  
     struct node { Z mul, ad; };  
     void gf(int x) {  
         if (x == f[x]) return;  
         gf(f[x]);  
         g[x] = g[x] + g[f[x]];  // 合并标记  
         f[x] = f[f[x]];  
     }  
     ```  
2. **Leasier（★★★★☆）**  
   - **亮点**：结构体封装线性变换，合并时直接计算新标记，逻辑清晰。  
   - **关键代码**：  
     ```cpp  
     Info operator+(const Info a, const Info b) {  
         return Info(a.k * b.k % MOD, (a.b * b.k + b.b) % MOD);  
     }  
     ```  
3. **Harry27182（★★★★☆）**  
   - **亮点**：线段树维护区间乘加，通过 Kruskal 重构树的 DFS 序映射到连续区间。  

---

## 最优思路提炼  
1. **标记组合公式**：若当前标记为 `(k1, b1)`，新操作为 `(k2, b2)`，则合并后标记为 `(k1*k2, b1*k2 + b2)`。  
2. **并查集路径压缩**：在 `find` 函数中动态合并路径上的标记，确保查询时标记正确。  
3. **预处理幂次**：提前计算 `10^k` 和其逆元，避免重复计算。  

---

## 类似题目推荐  
1. **P3366 【模板】最小生成树**（Kruskal 基础）  
2. **P1967 货车运输**（Kruskal 重构树应用）  
3. **P4219 [BJOI2014] 大融合**（并查集维护子树信息）  

---

## 核心代码实现（I_am_Accepted）  
```cpp  
#include <bits/stdc++.h>  
using namespace std;  
const int P = 1e9 + 7;  
struct mod_int { /* 省略模运算实现 */ };  
using Z = mod_int<P>;  

const int N = 200010;  
int f[N << 1], tot, n, m;  
Z pw[N];  
struct node {  
    Z mul, ad;  
    node operator+(const node &v) const {  
        return {mul * v.mul, ad * v.mul + v.ad};  
    }  
} g[N << 1];  

void gf(int x) {  
    if (x == f[x]) return;  
    gf(f[x]);  
    g[x] = g[x] + g[f[x]]; // 路径压缩合并标记  
    f[x] = f[f[x]];  
}  

int main() {  
    cin >> n >> m;  
    tot = n;  
    iota(f + 1, f + 2 * n, 1);  
    fill(g + 1, g + 2 * n, node{1, 0});  
    for (int i = 1; i <= m; i++) {  
        int x, y; cin >> x >> y;  
        gf(x); gf(y);  
        if (f[x] != f[y]) {  
            node xx = g[x], yy = g[y], zz = {10, i};  
            g[f[x]] = zz + yy;  
            g[f[y]] = zz + xx;  
            f[f[x]] = f[f[y]] = ++tot;  
        }  
    }  
    for (int i = 1; i <= n; i++) {  
        gf(i);  
        cout << g[i].ad << "\n";  
    }  
    return 0;  
}  
```  

---

## 可视化与算法演示  
### 动画设计  
- **Canvas 绘制**：节点以像素方块表示，连通块用不同颜色填充，合并时显示边编号和变换公式。  
- **自动演示**：按边编号逐步合并，显示当前合并的边和受影响节点。  
- **音效**：合并时播放 "beep" 音效，路径压缩时播放 "click" 音效。  

### 复古风格  
- **8-bit 调色板**：使用经典 FC 游戏的 16 色调色板，连通块颜色为红、蓝、绿等。  
- **网格布局**：节点按初始顺序排列成网格，合并后动态调整布局。  

---

通过结合并查集的动态标记维护和 Kruskal 算法的高效合并，该解法在 O(n α(n)) 时间内解决问题，代码简洁且易于扩展至类似问题。

---
处理用时：140.05秒
# 题目信息

# [SDOI2009] 虔诚的墓主人

## 题目描述

小W是一片新造公墓的管理人。公墓可以看成一块 $N×M$ 的矩形，矩形的每个格点，要么种着一棵常青树，要么是一块还没有归属的墓地。

当地的居民都是非常虔诚的基督徒，他们愿意提前为自己找一块合适墓地。为了体现自己对主的真诚，他们希望自己的墓地拥有着较高的虔诚度。

一块墓地的虔诚度是指以这块墓地为中心的十字架的数目。一个十字架可以看成中间是墓地，墓地的正上、正下、正左、正右都有恰好 $k$ 棵常青树。

形式化地，对于一个坐标为 $(x, y)$ 的墓地，以其为中心的十字架个数是这样的长度为 $4k$ 的二元组序列 $[(x_{1,1},y_{1,1}),\allowbreak(x_{1,2},y_{1,2}),\allowbreak\cdots,(x_{1,k},y_{1,k}),\allowbreak(x_{2,1},y_{2,1}),\allowbreak(x_{2,2},y_{2,2}),\allowbreak\cdots,(x_{2,k},y_{2,k}),\allowbreak(x_{3,1},y_{3,1}),\allowbreak(x_{3,2},y_{3,2}),\allowbreak\cdots,(x_{3,k},y_{3,k}),\allowbreak(x_{4,1},y_{4,1}),\allowbreak(x_{4,2},y_{4,2}),\allowbreak\cdots,(x_{4,k},y_{4,k})]$ 的方案数：

- 每一个二元组对应着一棵常青树的坐标；
- $x_{1,1}<x_{1,2}<\cdots< x_{1,k}<x$ 且 $y_{1,1}=y_{1,2}=\cdots=y_{1,k}=y$；
- $x<x_{2,1}<x_{2,2}<\cdots< x_{2,k}$ 且 $y_{2,1}=y_{2,2}=\cdots=y_{2,k}=y$；
- $y_{3,1}<y_{3,2}<\cdots< y_{3,k}<y$ 且 $x_{3,1}=x_{3,2}=\cdots=x_{3,k}=x$；
- $y<y_{4,1}<y_{4,2}<\cdots< y_{4,k}$ 且 $x_{4,1}=x_{4,2}=\cdots=x_{4,k}=x$。

小W希望知道他所管理的这片公墓中所有墓地的虔诚度总和是多少。

## 说明/提示

图中，以墓地 $(2, 2)$ 和 $(2, 3)$ 为中心的十字架各有 $3$ 个，即它们的虔诚度均为 $3$。其他墓地的虔诚度为 $0$。

 ![](https://cdn.luogu.com.cn/upload/pic/1589.png) 

对于 $30\%$ 的数据，满足 $1 ≤ N, M ≤ 10^3$。

对于 $60\%$ 的数据，满足 $1 ≤ N, M ≤ 10^6$。

对于 $100\%$ 的数据，满足 $1 ≤ N, M ≤ 10^9$，$0 ≤ x_i ≤ N$，$0 ≤ y_i ≤ M$，$1 ≤ W ≤ 10^5$，$1 ≤ k ≤ 10$。

存在 $50\%$ 的数据，满足 $1 ≤ k ≤ 2$。

存在 $25\%$ 的数据，满足 $1 ≤ W ≤ 10^4$。

## 样例 #1

### 输入

```
5 6

13

0 2

0 3

1 2

1 3

2 0

2 1

2 4

2 5

2 6

3 2

3 3

4 3

5 2

2```

### 输出

```
6```

# AI分析结果



### **算法分类**
**离散化 + 树状数组/线段树**

---

### **核心思路与算法要点**
1. **离散化坐标**  
   - 将常青树的坐标离散化，压缩至 $O(W)$ 规模，便于处理。
   - 统计每行、每列的常青树总数，用于后续组合数计算。

2. **预处理组合数**  
   - 由于 $k \leq 10$，预处理 $C(n, k)$ 的值，避免重复计算。

3. **扫描线与树状数组维护**  
   - 按行扫描常青树，维护当前行上下方向的组合数。
   - 使用树状数组动态维护每列的左右组合数乘积 $C(l, k) \cdot C(r, k)$，支持快速区间查询与单点更新。

4. **贡献计算**  
   - 对于同一行相邻两棵常青树之间的区域，其上下方向组合数固定，左右方向组合数通过树状数组查询区间和。

---

### **题解评分**
- **xyz32768（★★★★★）**  
  思路清晰，代码简洁，树状数组维护方式高效，离散化处理合理。
  
- **K8He（★★★★☆）**  
  使用线段树实现，逻辑明确，但代码复杂度略高。

- **Lance1ot（★★★★☆）**  
  树状数组结合动态更新，注释详细，适合理解核心逻辑。

---

### **最优技巧提炼**
1. **离散化坐标**  
   将稀疏的常青树坐标映射到连续区间，降低处理复杂度。

2. **树状数组维护动态和**  
   动态维护每列的左右组合数乘积，支持快速区间查询，时间复杂度 $O(W \log W)$。

3. **组合数预处理**  
   利用递推公式预处理组合数，避免重复计算。

---

### **同类型题推荐**
1. **P1908 逆序对**（离散化 + 树状数组）  
2. **P1972 [SDOI2009]HH的项链**（离线查询 + 树状数组）  
3. **P3368 树状数组 2**（区间修改 + 单点查询）

---

### **可视化与算法演示**
**动画设计：**
1. **像素风格展示**  
   - 使用 8-bit 像素风格绘制离散化后的网格，常青树用绿色方块表示，墓地用灰色方块。
   - 当前扫描的行用红色高亮，树状数组的更新步骤用黄色闪烁提示。

2. **关键步骤动态演示**  
   - **步骤1：离散化**  
     原坐标 → 压缩后的网格，展示坐标映射过程。
   - **步骤2：组合数预处理**  
     显示递推计算 $C(n, k)$ 的过程。
   - **步骤3：扫描线处理**  
     逐行扫描，高亮当前行的两棵相邻常青树，计算中间区域的贡献。
   - **步骤4：树状数组更新**  
     动态更新当前列的左右组合数，显示树状数组的结构变化。

3. **音效与交互**  
   - 更新树状数组时播放“滴”声，计算贡献时播放“叮”声。
   - 支持暂停/继续，调整扫描速度观察细节。

---

### **代码实现（核心片段）**
```cpp
// 预处理组合数
int C[N][12];
void init_comb() {
    for (int i = 0; i < N; ++i) {
        C[i][0] = 1;
        for (int j = 1; j <= min(i, 10); ++j)
            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;
    }
}

// 树状数组维护区间和
struct BIT {
    int tree[N], n;
    void update(int x, int v) {
        for (; x <= n; x += x & -x)
            tree[x] = (tree[x] + v) % MOD;
    }
    int query(int x) {
        int res = 0;
        for (; x > 0; x -= x & -x)
            res = (res + tree[x]) % MOD;
        return res;
    }
} bit;

// 主逻辑
long long solve() {
    sort(a, a + w); // 按x离散化后排序
    bit.n = max_y;  // 离散化后的y最大值
    long long ans = 0;
    for (int i = 0; i < w; ++i) {
        // 更新当前列的左右组合数
        int y = a[i].y;
        int l = ++left_cnt[y];  // 左侧已处理的数量
        int r = total_y[y] - l; // 右侧剩余数量
        int new_val = (C[l][k] * C[r][k]) % MOD;
        bit.update(y, (new_val - last_val[y] + MOD) % MOD);
        last_val[y] = new_val;

        // 计算相邻两树间的贡献
        if (i > 0 && a[i].x == a[i-1].x) {
            int dy = a[i].y - a[i-1].y;
            if (dy > 1) {
                int sum = (bit.query(a[i].y-1) - bit.query(a[i-1].y) + MOD) % MOD;
                ans = (ans + sum * C[up][k] % MOD * C[down][k] % MOD) % MOD;
            }
        }
    }
    return ans;
}
```

---

### **总结**
本题通过离散化与树状数组的高效维护，将看似复杂的二维问题转化为一维区间查询问题。核心在于动态维护左右组合数乘积，结合预处理组合数快速计算贡献。可视化设计通过像素动画与音效交互，直观呈现算法流程，适合教学与理解。

---
处理用时：68.02秒
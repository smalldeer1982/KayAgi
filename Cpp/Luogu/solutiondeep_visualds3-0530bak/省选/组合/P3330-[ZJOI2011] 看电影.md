# 题目信息

# [ZJOI2011] 看电影

## 题目描述

到了难得的假期，小白班上组织大家去看电影。但由于假期里看电影的人太多，很难做到让全班看上同一场电影。最后大家在一个偏僻的小胡同里找到了一家电影院，但这家电影院分配座位的方式很特殊，具体方式如下：

电影院的座位共有 $K$ 个，并被标号为 $1 \sim K$。每个人买完票后会被随机指定一个座位，具体来说是从 $1 \sim K$ 中等概率随机选取一个正整数，设其为 $L$。

如果编号 $L$ 的座位是空位，则这个座位就分配给此人，否则将 $L$ 加一，继续前面的步骤；如果不存在编号 $L$ 的座位，则该人只能站着看电影，即所谓的站票。

小白班上共有 $N$ 人（包括小白自己），作为数学爱好者，小白想知道全班都能够有座位的概率是多少。


## 说明/提示

对于 $100 \%$ 的数据，$1 \leq T \leq 50$，$1 \leq N,K \leq 200$。

## 样例 #1

### 输入

```
3
1 1
2 1
2 2```

### 输出

```
1 1
0 1
3 4
```

# AI分析结果



## 算法分类
组合数学/概率论

---

## 题解思路与核心分析
### 核心公式推导
所有题解均得出相同结论：  
$$\text{概率} = \frac{(k+1)^{n-1}(k+1-n)}{k^n}$$  
**推导关键**：  
1. **环形建模**：将座位连成环并虚构k+1号座位，消除边界条件
2. **圆排列去重**：环状排列等价类数为$(k+1)^{n-1}$
3. **合法条件**：断开环时选择空位点，共$k+1-n$种选择

### 解决难点对比
| 题解差异点          | SoyTony（C++）               | 一只书虫仔（Python）        | Brioche（C++）             |
|---------------------|-----------------------------|----------------------------|---------------------------|
| 高精度实现          | 自定义结构体（数组存储）     | Python原生大整数           | 类式封装（压位存储）       |
| 约分优化            | 高精取模转低精gcd           | 直接math.gcd               | 同SoyTony方法              |
| 代码复杂度          | ★★★★（复杂但高效）          | ★（极简）                  | ★★★（清晰封装）            |
| 可扩展性            | 支持更大数据范围            | 依赖Python特性             | 平衡效率与可读性          |

---

## 题解评分（≥4星）
1. **一只书虫仔（Python）** ★★★★★  
   - 亮点：利用Python原生大数处理，10行代码解决核心逻辑，含特判处理
2. **Brioche（C++）** ★★★★☆  
   - 亮点：高精度类封装优雅，压位存储提升效率，推导过程注释清晰
3. **Leasier（Python）** ★★★★☆  
   - 亮点：代码最精简，直接调用math库函数，适合快速验证公式

---

## 最优技巧提炼
1. **环形建模思维**：将线性问题转化为环形问题消除边界，适用于座位分配、约瑟夫环等问题
2. **高精度优化**：将高精gcd分解为低精取模运算（$k^n \bmod (k+1-n)$ → 低精gcd）
3. **公式推导捷径**：通过虚构节点构造双射关系，快速得出合法方案数

---

## 同类题目推荐
1. [P2523 HAOI2011 Problem c](https://www.luogu.com.cn/problem/P2523) - 座位分配方案存在性判定
2. [P2152 SDOI2008 沙拉公主的难题](https://www.luogu.com.cn/problem/P2152) - 大数阶乘与模运算
3. [P3223 HNOI2012 排队](https://www.luogu.com.cn/problem/P3223) - 组合数学+高精度

---

## 可视化设计（复古像素风格）
**动画演示逻辑**：  
```javascript
// 伪代码示例：环形座位分配过程
class CinemaVisualizer {
  constructor(k, n) {
    this.seats = Array(k + 1).fill(0); // 座位数组（含虚构k+1号）
    this.ring = new PixelRing(k + 1);   // 像素化环形显示
    this.highlightEmptySlot();          // 空位高亮（绿色像素块）
  }

  // 关键帧动画：分配座位
  async assignSeat(person) {
    let pos = Math.random() * (k + 1);  // 初始随机位置
    while (true) {
      this.ring.flash(pos, '#FF0000'); // 红色闪烁当前检查的座位
      if (this.seats[pos] === 0) {
        this.seats[pos] = 1;
        this.ring.setColor(pos, '#00FF00'); // 绿色标记占用
        playSound('seat_ok.wav');       // 8-bit成功音效
        break;
      }
      pos = (pos + 1) % (k + 1);       // 环形移动
    }
  }
  
  // 断开环的动画
  breakRing() {
    const emptySlots = this.seats.filter(x => x === 0);
    emptySlots.forEach(slot => {
      this.ring.highlight(slot, '#FFFF00'); // 黄色高亮可断点
      playSound('break_point.wav');     // 断开音效
    });
  }
}
```

**交互设计**：  
- **控制面板**：速度滑块、单步执行按钮、环形/线性视图切换
- **音效方案**：占用座位（NES风格叮咚声）、错误（短促哔声）、断环（金属撞击声）
- **自动演示模式**：AI自动完成座位分配，展示合法与非法案例对比

---

## 核心代码实现（Python版）
```python
import math

T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    if n > k:
        print("0 1")
    else:
        numerator = (k+1)**(n-1) * (k+1 - n)
        denominator = k**n
        gcd_val = math.gcd(numerator, denominator)
        print(f"{numerator//gcd_val} {denominator//gcd_val}")
```

---

## 总结与扩展
本题通过构造环形模型巧妙转化问题，结合高精度处理展现数学与编程的结合。对于类似需要处理边界条件的问题，环形建模和虚构节点是重要技巧。Python的大数处理能力在此类问题中具有显著优势，而C++的高精度实现则更适合教学底层原理。

---
处理用时：63.94秒
# 题目信息

# [THUPC 2019] 过河卒二

## 题目描述

> 首先我们回忆一下经典难题过河卒问题：
>
> 棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向上、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点，因此称之为「马拦过河卒」。
>
> 棋盘用坐标表示，$A$ 点 $(1,1)$ 、$B$ 点 $(N,M)$ ，同样马的位置坐标是需要给出的。
>
> 现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。
>
> **请注意，上述背景内容与本题无关！**

Kiana 喜欢玩象棋，尤其是喜欢用象棋玩过河卒的游戏。在传统的过河卒问题中，Kiana 需要控制一个卒从起点走到终点，在路中避开一个对方的马的攻击，然后假装不会算并询问你从起点到终点的路径总数。

在今天的过河卒二游戏中，Kiana 还是控制一个卒在一个 $N\times M$ 的棋盘上移动，初始时卒位于左下方坐标为 $(1,1)$ 位置，但为了增加难度，Kiana 对游戏规则做出了一些修改。传统的过河卒每步只能向上或向右移动 $1$ 格，Kiana 规定自己的过河卒二还可以在一步中向右上方移动 $1$ 格，即如果当前卒位于坐标 $(x,y)$ 处，则下一步可以走到 $(x+1,y)$ 、$(x,y+1)$ 或 $(x+1,y+1)$ 中的任意一格里面去，同时 Kiana 认为，如果两种移动方案在某一步时卒移动的方向（右、上或右上）不同，则两种方案就是不同的，例如从 $(1,1)$ 先走到 $(1,2)$ 再走到 $(2,2)$ 、从 $(1,1)$ 先走到 $(2,1)$ 再走到 $(2,2)$ 和从 $(1,1)$ 直接走到 $(2,2)$ 是三种不同的移动方案。

其次，过河卒二的终点不再是一个特定的位置，Kiana 规定卒可以从棋盘的上方或右方走出棋盘，此时就视为游戏成功。注意在走出棋盘时仍然有方向选择的不同，例如若过河卒位于 $(1,M)$ 处，则下一步它可以向右或者向右上用两种方式走出棋盘，若过河卒位于 $(N,M)$ 处，则下一步它可以向上、向右或者向右上用三种方式走出棋盘，以不同的方式走出棋盘仍然被算作是不同的移动方案。

此外，对方马的攻击范围不再是有规律的几个位置，而是 Kiana 规定好的 $K$ 个特定坐标，并要求过河卒在移动的过程中不能走到这 $K$ 个坐标的任何一个上，在除这些坐标以外的位置上过河卒都可以按规则自由移动。

现在 Kiana 想知道，过河卒二有多少种不同的移动方案可以走出棋盘，这个答案可能非常大，她只想知道方案数对 $59393$ 取模后的结果。由于她不会算，所以希望由你来告诉她。



## 说明/提示

### 样例解释

用 $\uparrow$ 表示过河卒向上移动了一格，用 $\rightarrow$ 表示过河卒向右移动了一格，用 $\nearrow$ 表示过河卒向右上移动了一格，由此可以简化样例解释的表述。

$24$ 种移动方案如下：

$(\uparrow\uparrow\uparrow)$、$(\uparrow\uparrow\nearrow)$、$(\uparrow\uparrow\rightarrow\uparrow)$、$(\uparrow\uparrow\rightarrow\nearrow)$、

$(\uparrow\uparrow\rightarrow\rightarrow\uparrow)$、$(\uparrow\uparrow\rightarrow\rightarrow\nearrow)$、$(\uparrow\uparrow\rightarrow\rightarrow\rightarrow)$、$(\uparrow\nearrow\uparrow)$、

$(\uparrow\nearrow\nearrow)$、$(\uparrow\nearrow\rightarrow\uparrow)$、$(\uparrow\nearrow\rightarrow\nearrow)$、$(\uparrow\nearrow\rightarrow\rightarrow)$、

$(\rightarrow\rightarrow\rightarrow)$、$(\rightarrow\rightarrow\nearrow)$、$(\rightarrow\rightarrow\uparrow\rightarrow)$、$(\rightarrow\rightarrow\uparrow\nearrow)$、

$(\rightarrow\rightarrow\uparrow\uparrow\rightarrow)$、$(\rightarrow\rightarrow\uparrow\uparrow\nearrow)$、$(\rightarrow\rightarrow\uparrow\uparrow\uparrow)$、$(\rightarrow\nearrow\rightarrow)$、

$(\rightarrow\nearrow\nearrow)$、$(\rightarrow\nearrow\uparrow\rightarrow)$、$(\rightarrow\nearrow\uparrow\nearrow)$、$(\rightarrow\nearrow\uparrow\uparrow)$。

### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。

## 样例 #1

### 输入

```
3 3 1
2 2```

### 输出

```
24```

# AI分析结果



### 算法分类
**容斥原理 + 组合数学**

---

### 题解思路与核心难点
**核心思路**：  
1. **路径计算**：从 (1,1) 到 (n+1,m+1) 的路径数，允许右、上、右上三种移动方式。  
2. **障碍处理**：使用容斥原理，减去经过障碍的路径数。  
3. **组合数优化**：通过 Lucas 定理计算大数组合数，预处理阶乘和逆元加速。

**解决难点**：  
- **多方向移动**：引入斜向移动后，路径数的组合公式复杂，需枚举斜向步数。  
- **大模数组合数**：模数 59393 非质数但可分解，需分治计算（Lucas 定理）。  
- **容斥效率**：通过排序障碍点避免无效状态，预处理两两路径数降低复杂度。

---

### 题解评分与推荐（≥4星）
1. **Eznibuil (5星)**  
   - **亮点**：动态规划处理障碍，时间复杂度 O(k²m)。  
   - **代码**：清晰简洁，直接按顺序处理障碍点，避免状态压缩。  
   ```cpp
   // 动态规划核心代码
   for(int i=0;i<=k;i++) {
       dp[i] = w(e[i].x, e[i].y);
       for(int j=0;j<i;j++)
           dp[i] = (dp[i] - dp[j] * w(e[i].x-e[j].x, e[i].y-e[j].y) % mod + mod) % mod;
   }
   ```

2. **huayucaiji (4星)**  
   - **亮点**：状态压缩枚举障碍组合，逻辑直观。  
   - **代码**：预处理两两路径数，容斥时快速计算乘积。  
   ```cpp
   // 容斥核心代码
   for(int i=0;i<(1<<k+1);i++)
       ans = (ans + calc(i)) % mod; // 计算各子集贡献
   ```

3. **AThousandSuns (4星)**  
   - **亮点**：将终点视为超级汇点，统一处理所有边界情况。  
   - **代码**：使用二进制枚举障碍点，高效生成容斥项。  

---

### 最优思路提炼
1. **路径公式**：  
   $$\sum_{i=0}^{\min(x,y)} \binom{x+y-i}{i} \cdot \binom{x+y-2i}{x-i}$$  
   枚举斜向步数，结合水平和垂直步数的组合数。  
2. **容斥剪枝**：按坐标排序障碍点，确保状态合法性。  
3. **Lucas 优化**：分治计算组合数，避免大数运算溢出。  

---

### 类似题目推荐
1. **P1371 棋盘覆盖**（容斥 + 路径计数）  
2. **P2567 幸运数字**（组合数 + 容斥）  
3. **P1450 硬币购物**（容斥预处理障碍）  

---

### 可视化设计
**动画方案**：  
1. **网格绘制**：以 Canvas 绘制棋盘，高亮障碍点（红色方块）。  
2. **路径演示**：  
   - 允许三种移动方向，用不同颜色箭头标记。  
   - 动态显示当前路径组合（如绿色路径为有效，灰色为被容斥剔除）。  
3. **容斥交互**：  
   - 用户点击障碍点后，显示该障碍对总路径的贡献（正负项）。  
   - 单步执行容斥过程，展示子集如何影响结果。  

**复古风格**：  
- **8-bit 音效**：移动时播放 "beep" 音效，容斥成功时播放上升音调。  
- **像素动画**：卒子以 16x16 像素块移动，路径用闪烁虚线表示。  

---

### 核心代码片段
```cpp
// 计算两点间路径数的核心函数
int calc(int x, int y) {
    int ans = 0;
    for (int i = 0; i <= min(x, y); i++) {
        int n0 = x - i, m0 = y - i;
        ans += lucas(n0 + m0 + i, i) * lucas(n0 + m0, n0);
        ans %= MOD;
    }
    return ans;
}
```

---

### 总结
通过组合数学和容斥原理，将复杂路径问题拆解为无障碍子问题，再逐步修正障碍影响。动态规划或状态压缩的选择取决于障碍数量，Lucas 定理解决大数组合计算是关键优化。

---
处理用时：63.44秒
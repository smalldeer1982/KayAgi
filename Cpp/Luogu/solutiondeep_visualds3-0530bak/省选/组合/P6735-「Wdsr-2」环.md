# 题目信息

# 「Wdsr-2」环

## 题目描述

Kagamine Rin 有一个圆环，上面均匀分布着 $n$ 个点，这些点之间连接着 $m$ 条线段。

突然有一天，这些线段全都不见了。

Rin 想要找回这些线段，但是她不记得线段的分布。她只记得，这些线段中任意两条都不相交。

**注意：只在端点处相交不算相交；重合不算相交。** 下面的样例解释有助于理解本题中的定义。

Rin 有时还会记得一些额外的信息，她可能还会告诉你每个点上连接的线段数。

现在 Rin 想要知道，符合她的记忆的方案数有多少种。由于结果可能很大，你只需要输出答案对 $1000000007$ 取模的结果（模数是一个质数）。


## 说明/提示

样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/82pgikk2.png)

**Update：上图第二行第三个画错了，它的竖应该在右边**


如上图，有 $20$ 种方案满足样例 $1$ 的要求，而只有最后两种方案满足样例 $2$ 的要求。

------

**本题采用捆绑测试**，数据范围遵守如下约定：

subtask | $n\le$ | $m\le$ | $type$ | 分数
:-:|:-:|:-:|:-:|:-:
$0$ | $8$ | $8$ | $0$ | $10$
$1$ | $50$ | $50$ | $0$ | $10$
$2$ | $4000$ | $4000$ | $0$ | $15$
$3$ | $8$ | $8$ | $1$ | $10$
$4$ | $50$ | $50$ | $1$ | $15$
$5$ | $600$ | $600$ | $1$ | $20$
$6$ | $4000$ | $4000$ | $1$ | $20$

对于所有数据，有 $2\le n\le 4000,1\le m\le 4000,type\in \{0,1\}, a_i \ge 0$。若 $type=1$ 则保证 $\sum_{i=1}^na_i=2m$。

## 样例 #1

### 输入

```
4 2 0
```

### 输出

```
20
```

## 样例 #2

### 输入

```
4 2 1
1 1 1 1
```

### 输出

```
2
```

# AI分析结果



## 算法分类
**组合数学（type=0）与动态规划（type=1）**

---

## 题解思路与核心难点

### 核心思路对比
1. **type=0（无度数约束）**  
   - 将圆环拆解为独立子问题，利用递推关系推导出组合数公式：  
     $$f(n,m) = \frac{\binom{n+m-2}{n-2} \cdot \binom{n+m-1}{n-2}}{n-1}$$  
   - **关键难点**：如何将不相交线段的结构映射到卡特兰数的变形，需数学建模能力。

2. **type=1（有度数约束）**  
   - 动态规划状态设计：`dp[i][j]` 表示前 `i` 个点使用 `j` 条边的方案数。  
   - 转移时枚举当前点连接的边数 `k`，满足约束：`k ≤ a[i]` 且 `k ≤ 剩余可用度数`。  
   - **关键难点**：状态转移的约束条件（度数限制）与时间复杂度优化。

---

## 题解评分（≥4星）

1. **鏡音リン的题解（5星）**  
   - **亮点**：  
     - 对 type=0 推导出组合数公式，时间复杂度 $O(1)$。  
     - 对 type=1 提出区间 DP 与线性 DP 两种思路，覆盖所有数据范围。  
   - **代码实现**：未提供完整代码，但思路清晰，覆盖所有 subtask。

2. **tzl_Dedicatus545的题解（4星）**  
   - **亮点**：  
     - 提供简洁的代码实现，动态规划转移方程明确。  
     - 预处理组合数与逆元，代码可读性较强。  
   - **不足**：对 type=0 的公式推导未详细说明。

---

## 最优思路与技巧

### type=0：组合数公式
- **核心技巧**：将不相交线段的结构转化为组合数模型，通过递推式发现与卡特兰数的关联。  
- **公式推导**：  
  1. 破环成链，固定一个点，递归分析线段分割子问题。  
  2. 递推式与卡特兰三角形的变形一致，最终公式为组合数乘积除以 $n-1$。

### type=1：动态规划
- **状态设计**：`dp[i][j]` 表示前 `i` 个点使用 `j` 条边的方案数。  
- **转移优化**：  
  - 维护前缀度数总和 `sum`，计算剩余可用度数为 `sum - 2j`。  
  - 当前点最多连接 `min(a[i], sum - 2j)` 条边，避免无效枚举。

---

## 同类型题与类似套路

1. **不相交弦问题**：圆上 $2n$ 个点连 $n$ 条不相交弦的方案数，答案即第 $n$ 项卡特兰数。  
2. **括号匹配**：长度为 $2n$ 的合法括号序列数，同样对应卡特兰数。  
3. **树形计数问题**：如二叉搜索树形态数，利用递推与组合数。

---

## 相似题目推荐

1. **P1044 栈**：卡特兰数的经典应用。  
2. P2303 不相交弦：直接计算圆上不相交弦数。  
3. **P4342 Polygon**：动态规划处理环状结构问题。

---

## 可视化设计（核心算法演示）

### 动态规划过程演示
- **动画设计**：  
  1. **网格绘制**：将 `dp[i][j]` 的状态变化绘制为网格，每个格子表示状态值。  
  2. **高亮当前操作**：用不同颜色标记转移的起点 `(i,j)` 和终点 `(i+1,j+k)`。  
  3. **数值更新**：动态显示 `dp[i+1][j+k] += dp[i][j]` 的过程。  

- **复古像素风格**：  
  - **调色板**：8-bit 风格，绿色表示起点，红色表示终点，黄色表示更新。  
  - **音效**：每次转移时播放短促的“哔”声，完成时播放胜利音效。  

### 自动演示模式
- **AI 控制**：  
  1. 自动按顺序遍历每个点，计算可能的 `k` 值。  
  2. 显示剩余度数与当前度数限制的对比。  

---

## 代码片段（核心逻辑）

### type=0 组合数计算
```cpp
void Solve0() {
    // 组合数预处理略
    int ans = (C[n+m-2][n-2] * C[n+m-1][n-2]) % MOD;
    ans = ans * inv[n-1] % MOD;
    cout << ans;
}
```

### type=1 动态规划
```cpp
int a[MAXN], dp[MAXN][MAXN];

void Solve1() {
    dp[0][0] = 1;
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += a[i];
        for (int j = 0; j <= m; j++) {
            if (!dp[i-1][j]) continue;
            int max_k = min(a[i], sum - 2 * j);
            for (int k = 0; k <= max_k; k++) {
                dp[i][j + k] = (dp[i][j + k] + dp[i-1][j]) % MOD;
            }
        }
    }
    cout << dp[n][m];
}
```

---

## 总结与扩展

本题结合组合数学与动态规划，需根据输入类型选择策略。关键是对不相交线段结构的数学建模能力，以及处理约束条件下的动态规划优化。同类型问题可拓展到树形结构、环状分割等场景。

---
处理用时：91.20秒
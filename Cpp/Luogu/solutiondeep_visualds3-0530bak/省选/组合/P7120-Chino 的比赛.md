# 题目信息

# Chino 的比赛

## 题目描述

Chino 想要用现在手里有的 $n$ 道题出成一套模拟赛。一开始，这 $n$ 道题按照由易到难的顺序排列。

但是因为 Chino 是一个可爱的妹子，所以她会将这些题目的顺序打乱。具体地，她会执行恰好奇数次操作，每次操作她会将其中两道题的位置交换。一套可能的模拟赛就是这些题的一个排列。

Chino 为了评估一套模拟赛的可爱程度，她定义 $s$ 表示使得开始时的题目顺序变为这套模拟赛的题目顺序的最少操作次数，定义 $t$ 表示开始时与这套模拟赛中位置相同的题目数量，那么这套模拟赛的可爱程度就是 $s/\left(t+1\right)$。

按照套路，你现在应该帮 Chino 计算某一套模拟赛的可爱程度。Chino 觉得这不够可爱，所以她想让你计算所有可能的模拟赛的可爱程度的两倍和。可以发现这一定是一个非负整数。为了避免答案过大，你只需要输出其对质数 $p$ 取模后的结果即可。

形式化地，对于置换 $\pi$，令 $\nu\left(\pi\right)$ 表示其不动点个数，设 $\upsilon\left(\pi\right)$ 为其能够被分解成为的最少个数对换乘积的对换数目。设 $n$ 元对称群为 $S_n$，$n$ 元交错群为 $A_n$，求
$$
2\sum_{\pi\in S_n\land\pi\notin A_n}\frac{\upsilon\left(\pi\right)}{\nu\left(\pi\right)+1}.
$$

这一定是一个非负整数。答案对质数 $p$ 取模后输出。

## 说明/提示

### 样例解释 #1
四道题的所有可能的模拟赛题目排列顺序有：
- $\left\{1,2,4,3\right\}$，可爱程度为 $1/3$；
- $\left\{1,3,2,4\right\}$，可爱程度为 $1/3$；
- $\left\{1,4,3,2\right\}$，可爱程度为 $1/3$；
- $\left\{2,1,3,4\right\}$，可爱程度为 $1/3$；
- $\left\{2,3,4,1\right\}$，可爱程度为 $3$；
- $\left\{2,4,1,3\right\}$，可爱程度为 $3$；
- $\left\{3,1,4,2\right\}$，可爱程度为 $3$；
- $\left\{3,2,1,4\right\}$，可爱程度为 $1/3$；
- $\left\{3,4,2,1\right\}$，可爱程度为 $3$；
- $\left\{4,1,2,3\right\}$，可爱程度为 $3$；
- $\left\{4,2,3,1\right\}$，可爱程度为 $1/3$；
- $\left\{4,3,1,2\right\}$，可爱程度为 $3$。

### 测试点约束
**本题采用捆绑测试。**

对于全部数据，有 $1\le n\le2\times10^7$，$2^{25}<p<2^{31}$，$p$ 为质数。
	
每个子任务的具体限制见下表：

| 子任务编号 | 分值 | $n\le$ | $p=998244353$ |
|:-:|:-:|:-:|:-:|
| 1 | 10 | $2\times10^1$ | $\times$ |
| 2 | 10 | $2\times10^2$ | $\surd$ |
| 3 | 10 | $2\times10^3$ | $\times$ |
| 4 | 20 | $2\times10^4$ | $\times$ |
| 5 | 20 | $2\times10^5$ | $\surd$ |
| 6 | 10 | $2\times10^6$ | $\surd$ |
| 7 | 20 | $2\times10^7$ | $\times$ |

### 更快的取模
本题中你可能会执行大量取模操作，因此你可以参考[几种取模优化方法（译自 min-25 的博客）](https://loj.ac/d/327)来提高取模运算的效率。

## 样例 #1

### 输入

```
4 16777259
```

### 输出

```
40
```

## 样例 #2

### 输入

```
10 2147483647
```

### 输出

```
17167120
```

## 样例 #3

### 输入

```
10000000 998244353
```

### 输出

```
3414058
```

# AI分析结果



## 算法分类
**生成函数与组合数学**

## 题解思路与核心难点

### 核心思路
1. **置换分解与贡献计算**  
   置换π的最少交换次数υ(π)等于n减去其环的数量。通过数学推导，将问题转化为生成函数形式，避免直接枚举所有排列。
   
2. **生成函数与EGF**  
   利用指数生成函数（EGF）将组合问题转化为多项式系数提取，通过展开生成函数得到递推关系式。

3. **线性递推优化**  
   将复杂的生成函数表达式拆解为若干可线性递推的项，结合逆元预处理，实现O(n)时间复杂度与O(1)空间复杂度。

### 解决难点
- **数学推导复杂度**：通过生成函数将置换的环结构与奇偶性条件统一处理，避免分情况讨论。
- **模运算优化**：针对大质数模数，采用快速逆元预处理和逐项递推，避免高复杂度运算。

## 最优思路提炼
1. **生成函数降维**  
   将原问题转化为生成函数的系数提取，通过多项式运算化简，得到可线性递推的表达式。
2. **逆元预处理**  
   提前计算逆元数组，避免重复计算模逆元，提升计算效率。
3. **分项递推**  
   将生成函数拆分为多个独立项，分别计算各部分的贡献后合并，减少中间状态存储。

## 题解评分 (≥4星)
1. **NaCly_Fish（5星）**  
   - **亮点**：生成函数推导完整，代码线性时间复杂度，空间优化至O(n)但常数极小。
   - **代码实现**：逆元预处理+分项递推，核心逻辑仅需30行。
2. **Daniel13265（4星）**  
   - **亮点**：递推式直观，适合理解置换结构。
   - **不足**：空间复杂度O(n)且需存储阶乘，对大n不友好。

## 代码实现核心片段
```cpp
uint inv[N], f[N], g[N];
uint n, ans, p, fac;

int main() {
    scanf("%u%u", &n, &p);
    inv[1] = 1;
    for (int i = 2; i <= n + 1; ++i) // 预处理逆元
        inv[i] = (ull)(p - p / i) * inv[p % i] % p;
    
    f[0] = 1;
    for (int i = 1; i <= n; ++i) // 递推f数组
        f[i] = p - (ull)f[i - 1] * inv[i + 1] % p;
    
    fac = (n & 1) ? f[n - 1] : p - f[n - 1];
    for (int i = 1; i <= n; ++i) // 累加处理
        f[i] = add(f[i], f[i - 1]);
    
    // ... 其他递推步骤与最终答案计算
    printf("%u", ans);
    return 0;
}
```

## 可视化设计
**8位像素风格算法演示**  
- **颜色方案**：使用16色调色板，置换操作用绿色高亮，环结构用红色标记。
- **动画流程**：  
  1. 初始排列显示为像素网格，逐步分解为环结构。
  2. 每次交换时播放“哔”音效，环分解完成时播放上升音阶。
  3. 右侧面板实时显示环数量、贡献值及当前总和。
- **自动演示模式**：AI模拟递推过程，每步延迟100ms，可暂停/加速。

## 同类型题目推荐
1. **P4980 环排列计数**  
   同样涉及置换环结构与生成函数。
2. **P3773 置换统计**  
   统计满足特定条件的置换数目。
3. **P2601 置换群上的计数**  
   置换群性质与组合数学结合。

---
处理用时：88.42秒
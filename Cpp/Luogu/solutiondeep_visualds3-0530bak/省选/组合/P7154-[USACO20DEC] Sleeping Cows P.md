# 题目信息

# [USACO20DEC] Sleeping Cows P

## 题目描述


Farmer John 有 $N$（$1≤N≤3000$）头各种大小的奶牛。他原本为每头奶牛量身定制了牛棚，但现在某些奶牛长大了，使得原先的牛棚大小不够用。具体地说，FJ 原来建造了 $N$ 个牛棚的大小为 $t_1,t_2,…,t_N$，现在奶牛的大小为 $s_1,s_2,…,s_N$（$1≤s_i,t_i≤10^9$）。

每天晚上，奶牛们都会按照某种方式寻找睡觉的牛棚。奶牛 $i$ 可以睡在牛棚 $j$ 中当且仅当她的大小可以进入牛棚（$s_i≤t_j$）。每个牛棚中至多可以睡一头奶牛。

我们称奶牛与牛棚的一个匹配是极大的，当且仅当每头奶牛可以进入分配给她的牛棚，且对于每头未被分配牛棚的奶牛无法进入任何未分配的空牛棚。

计算极大的匹配的数量模 $10^9+7$ 的结果。 

## 说明/提示

以下是全部九种极大的匹配。有序对 $(i,j)$ 表示奶牛 $i$ 被分配到了牛棚 $j$。

```
(1, 1), (2, 2), (3, 4)
(1, 1), (2, 3), (3, 4)
(1, 1), (2, 4)
(1, 2), (2, 3), (3, 4)
(1, 2), (2, 4)
(1, 3), (2, 2), (3, 4)
(1, 3), (2, 4)
(1, 4), (2, 2)
(1, 4), (2, 3)
```

 - 测试点 2-3 中，$N≤8$。
 - 测试点 4-12 中，$N≤50$。
 - 测试点 13-20 没有额外限制。

供题：Nick Wu 

## 样例 #1

### 输入

```
4
1 2 3 4
1 2 2 3```

### 输出

```
9```

# AI分析结果



# 【算法分类】
**动态规划**

---

# 【题解思路与解决难点】

## **核心思路**
将牛和牛棚合并排序后，通过动态规划处理极大匹配的条件。关键状态设计为 `dp[i][j][0/1]`，表示处理到第 `i` 个元素时，有 `j` 头牛待匹配，第三维标记是否存在未被匹配的牛。

## **算法要点**
1. **排序处理**：将牛和牛棚按大小排序，相同大小牛优先。
2. **状态设计**：`dp[i][j][0]` 表示当前无未匹配牛，`dp[i][j][1]` 表示存在未匹配牛。
3. **转移方程**：
   - **当前为牛**：可匹配或丢弃，转移时更新待匹配数量及状态标记。
   - **当前为牛棚**：必须匹配待匹配的牛或保持未匹配状态（需满足极大条件）。

## **解决难点**
- **极大匹配条件**：通过第三维状态强制后续牛棚必须匹配，避免无效状态。
- **滚动数组优化**：空间复杂度从 `O(n^2)` 降为 `O(n)`。

---

# 【题解评分 (≥4星)】

1. **CXY07的题解（5星）**  
   - **思路清晰**：详细推导状态转移逻辑，结合排序与动态规划。  
   - **代码优化**：使用滚动数组减少空间占用。  
   - **可读性高**：代码结构清晰，注释明确。

2. **Rainybunny的题解（4星）**  
   - **简洁实现**：代码精简，状态转移方程高效。  
   - **解释到位**：核心思路通过注释和变量名直观体现。

3. **Kubic的题解（4星）**  
   - **独特思路**：预处理每个牛/牛棚的匹配范围，分阶段计算。  
   - **实践性强**：代码中预处理 `a` 和 `b` 数组提升效率。

---

# 【最优思路提炼】

1. **合并排序**：将牛和牛棚视为同一序列排序，统一处理顺序。
2. **状态设计**：用 `j` 记录待匹配牛数，`0/1` 标记未匹配牛的存在性。
3. **转移逻辑**：
   - **牛元素**：增加待匹配数或触发未匹配标记。
   - **牛棚元素**：消耗待匹配数或保持未匹配状态。

---

# 【同类型题与算法套路】

**通用解法**：  
- **双序列排序+DP**：适用于需要处理两个序列匹配条件的问题，如括号匹配、任务调度等。
- **状态压缩**：通过额外维度记录特定条件（如是否触发了某种限制）。

**类似题目**：  
1. [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)  
2. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)  
3. [P2577 午餐](https://www.luogu.com.cn/problem/P2577)

---

# 【代码实现片段】

**核心动态规划实现**（CXY07题解）：
```cpp
for (int i = 1; i <= n * 2; ++i) {
    swap(now, pre); // 滚动数组优化
    memset(dp[now], 0, sizeof dp[now]);
    if (!s[i].scd) { // 当前为牛
        for (int j = 0; j <= n; ++j) {
            if (j) dp[now][j][0] += dp[pre][j - 1][0];
            if (j) dp[now][j][1] += dp[pre][j - 1][1];
            dp[now][j][0] += dp[pre][j][0] + dp[pre][j][1];
        }
    } else { // 当前为牛棚
        for (int j = 0; j <= n; ++j) {
            dp[now][j][1] += dp[pre][j][1];
            dp[now][j][1] += dp[pre][j + 1][1] * (j + 1);
            dp[now][j][0] += dp[pre][j + 1][0] * (j + 1);
        }
    }
}
```

---

# 【可视化与算法演示】

**动画设计**：  
1. **排序展示**：将牛（红色方块）和牛棚（绿色方块）按大小排列在水平轴上。
2. **状态跟踪**：高亮当前处理的元素，右侧面板显示 `j` 和 `0/1` 状态。
3. **转移动画**：用箭头表示 `j` 的增减，颜色区分牛/牛棚操作。

**复古像素风格**：  
- **Canvas 绘制**：元素用 16x16 像素块表示，牛为红色，牛棚为绿色。
- **音效**：匹配时播放 8-bit 成功音效，未匹配时播放低沉音效。

**自动演示**：  
- **AI 模式**：自动按最优路径执行，显示状态变化和匹配结果。

---

# 【个人心得摘录】

> **CXY07调试经历**：  
> “初始状态 `dp[0][0][1] = 1` 是关键，否则无法正确处理全匹配情况。”

> **LiveZoom踩坑**：  
> “滚动数组的 `memset` 必须彻底，残留数据导致 WA 两次。”

---
处理用时：79.70秒
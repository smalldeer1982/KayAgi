# 题目信息

# 「EZEC-6」0-1 Trie

## 题目背景

> $\mathbf{000111}$，这就是简单中所蕴含的优美。

众所周知，tlx 不会字符串。

## 题目描述

现在 tlx 有 $n$ 个 $\mathbf{1}$ 和 $m$ 个 $\mathbf{0}$，你需要把它们排列，但要保证任意的 $\mathbf{1}$ 互不相邻且第一个位置是 $\mathbf{0}$、最后一个位置是 $\mathbf{1}$，现在把所有可以构造出的串放到一棵 0-1 Trie 上，需要多少个节点？

**注意：节点计数时，不计算最开始的空节点，只计算代表“ $\mathbf{0}$ ”、“ $\mathbf{1}$ ”的节点。**  

**在本题中，我们认为用节点存储字符而非边， Trie 基本原理不变。**

因为答案可能很大而且询问较多，所以请在最后输出所有询问的答案对 $18888913$ （放心，是个质数）取模的结果的异或和（**异或和不再进行取模**）。

## 说明/提示

**【样例解释 #1】**

可以发现，所有能构造出的串有：  

$$\mathbf{000101}$$
$$\mathbf{001001}$$
$$\mathbf{010001}$$

构造 0-1 Trie，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/aql3bwo6.png)

共需 $15$ 个节点。


**【样例解释 #2】**

两次询问的答案分别为 $34$ 和 $4487317$。

------------

**【数据规模与提示】**

注意：本题采用**捆绑测试**，只有当你通过一个 Subtask 内的所有测试点后，你才能拿到这个 Subtask 的分数。

具体约束如下：  

Subtask $1$（$10\%$）：满足 $T\leq 10$，$n,m\leq 5$；

Subtask $2$（$20\%$）：满足 $T \leq 10$，$n,m\leq 1\times 10^3$；

Subtask $3$（$30\%$）：满足 $T\leq 10$，$n,m\leq 5\times 10^5$;


Subtask $4$（$40\%$）：无特殊限制。

对于 $100\%$ 的数据，满足 $1\le T \le 2\times10^6$，$1\le n,m\le 5\times 10^{18}$。

**本题输入量较大，建议采用较为快速的读入方式并注意常数因子对程序效率带来的影响。**



------------
 0-1 Trie 是一种特殊的 Trie ，只有 $\mathbf{0,1}$ 两种字符。
 
 如果你不了解 Trie，可以查看：[OI Wiki--Trie](https://deploy-preview-980--oi-wiki.netlify.app/string/trie/)。

## 样例 #1

### 输入

```
1
2 4```

### 输出

```
15```

## 样例 #2

### 输入

```
2
3 5
114514 1919810```

### 输出

```
4487351
```

## 样例 #3

### 输入

```
5
78 122
1000000 1000001
74859432 942432534
555555555 77777777 
6666666666 8888888888```

### 输出

```
12287990```

# AI分析结果



# 算法分析与题解总结

## 算法分类
组合数学、递推与Lucas定理

---

## 综合分析与结论
**核心思路**：将合法串构造问题转化为组合数学模型，通过递推式推导出组合数公式，利用Lucas定理处理大数取模。

**解决难点**：
1. **递推关系建立**：将Trie节点数转化为F(n,m)的递推式，发现与组合数性质吻合。
2. **组合数化简**：通过多次组合恒等式（上指标求和、范德蒙德卷积）化简复杂递推式，得到简洁表达式。
3. **高效计算**：针对n,m极大值（1e18），采用Lucas定理分治计算组合数模质数。

**可视化设计**：
- **动画演示**：展示组合数C(n+m+1,n)的分解过程，分层高亮每一位的模运算。
- **像素风格**：用8-bit风格显示递推网格，每步操作触发音效，红色标记当前处理的分支。
- **交互控制**：允许调整递推步速，对比不同题解的化简路径（如生成函数vs容斥）。

---

## 题解清单（≥4星）
1. **yyandy（5星）**
   - **亮点**：清晰递推→组合数推导，边界处理严谨，代码高效。
   - **关键代码**：预处理阶乘逆元，Lucas递归计算。
   ```cpp
   int Lucas(ll n,ll m) {
       int ans=1;
       for(;m;n/=MOD,m/=MOD)
           ans=1ll*ans*C(n%MOD,m%MOD)%MOD;
       return ans;
   }
   ```

2. **hanzhongtlx（4.5星）**
   - **亮点**：增量模型思维，最终公式与yyandy一致，代码常数优化。
   - **心得**：“本题输入量极大，卡常关键在快速读入”。

3. **dengyaotriangle（4星）**
   - **亮点**：生成函数暴力展开，展示数学普适性，适合理论推导。
   - **不足**：实现复杂度略高，对大数TLE风险。

---

## 核心代码实现
**预处理与Lucas计算**（hanzhongtlx题解）：
```cpp
int fac[MAXN], inv[MAXN];
void init() {
    fac[0] = 1;
    for(int i=1; i<MOD; i++) fac[i] = 1ll*fac[i-1]*i % MOD;
    inv[MOD-1] = MOD-1; // 利用(p-1)! ≡ -1 mod p
    for(int i=MOD-2; i>=0; i--) inv[i] = 1ll*inv[i+1]*(i+1) % MOD;
}

int C(ll n, ll m) {
    if(m > n) return 0;
    if(n < MOD) return 1ll*fac[n] * inv[fac[m]] % MOD * inv[fac[n-m]] % MOD;
    return 1ll*C(n/MOD, m/MOD) * C(n%MOD, m%MOD) % MOD;
}
```

---

## 同类型题与算法套路
**通用解法**：
- **组合递推**：类似卡特兰数、格路问题，利用递推式转化为组合数求和。
- **Lucas优化**：模数为质数时，分治处理大组合数取模。

**推荐题目**：
1. [P3807 【模板】卢卡斯定理](https://www.luogu.com.cn/problem/P3807)（Lucas模板）
2. [P1641 生成字符串](https://www.luogu.com.cn/problem/P1641)（组合数+容斥）
3. [P2767 树的数量](https://www.luogu.com.cn/problem/P2767)（Trie节点计数变式）

---

## 个人心得摘录
- **yyandy**：“转移式类比网格路径数，k_j即为组合数”。
- **CatFromMars**：“打表瞪眼法感知g(n,m)=2C(n,j-1)-2，运气成分但高效”。
- **Mivik**：“容斥时对LCP分情况讨论，需细致避免重复计数”。

---

## 复古像素化演示设计
**实现要点**：
- **Canvas绘制**：16x16像素网格，绿色路径表示合法串构造，红色分支为Trie节点。
- **音效触发**：组合数计算成功时播放8-bit上升音调，错误时低沉音效。
- **自动演示**：按递推步进，高亮当前C(n,m)计算的分层（万位→个位）。

**交互示例**：
```javascript
// 伪代码：像素动画步进
function drawStep(n, m) {
    ctx.fillStyle = '#0f0'; // 当前路径绿色
    drawGridCell(n, m);
    playSound('blip.wav');
    if(n % MOD === 0 || m % MOD === 0) 
        highlightLucasLayer();
}
```

**关卡设计**：初始关n=2,m=4（样例），逐步增加n/m，积分奖励快速解题者。

---
处理用时：62.60秒
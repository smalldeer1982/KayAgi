# 题目信息

# [蓝桥杯 2021 省 A2] 完美序列

## 题目描述

一个序列中取出一些元素按照原来的顺序排列成新的序列称为该序列的一个子序列。子序列的价值为子序列中所有元素的和。

如果一个序列是单调递减的，而且除了第一个数以外的任何一个数都是上一个数的因数，则称这个序列为一个完美序列。

一个序列中的一个子序列如果是完美序列，则称为该序列的一个完美子序列。一个序列的最长完美子序列长度，称为该序列的完美长度。

给定正整数 $n$，$1$ 至 $n$ 的所有排列的完美长度的最大值，称为 $n$ 阶最大完美长度。

给定正整数 $n$，请求出 $1$ 至 $n$ 的所有排列中长度正好为 $n$ 阶最大完美长度的所有完美子序列的价值的和。


## 说明/提示

**【样例说明】**

当 $n=1$ 时，答案显然是 $1$ 。

当 $n=2$ 时, 全排列包括 $(1,2)$ 和 $(2,1)$, 其中 $(2,1)$ 拥有最长的完美子序列, 也就是 $(2,1)$ 本身, $2$ 阶最大完美长度为 $2$，答案即为 $2+1$ 。

当 $n=3$ 时，全排列包括 $(1,2,3)$、$(1,3,2)$、$(2,1,3)$、$(2,3,1)$、$(3,1,2)$、$(3,2,1)$ 。其中 $(2,1)$ 和 $(3,1)$ 都是最长的完美子序列，$3$ 阶最大完美长度为 $2$。

序列 $(1,2,3)$ 和 $(1,3,2)$ 中没有长度为 $2$ 的完美子序列。

序列 $(2,1,3)$ 中有完美子序列 $(2,1)$，价值和为 $3$。

序列 $(2,3,1)$ 中有完美子序列 $(2,1)$ 和 $(3,1)$，价值和为 $7$。

序列 $(3,1,2)$ 中有完美子序列 $(3,1)$，价值和为 $4$。

序列 $(3,2,1)$ 中有完美子序列 $(2,1)$ 和 $(3,1)$,价值和为 $7$。

答案为 $3+7+4+7=21$ 。

**【评测用例规模与约定】**

对于 $10 \%$ 的评测用例，$n \leq 10$;

对于 $20 \%$ 的评测用例，$n \leq 20$;

对于 $30 \%$ 的评测用例，$T \leq 20, n \leq 1000$;

对于 $40 \%$ 的评测用例，$T \leq 20, n \leq 10^{5}$;

对于所有评测用例，$1 \leq T \leq 10^{5}, 1 \leq n \leq 10^{6}$。

蓝桥杯 2021 第二轮省赛 A 组 J 题。

## 样例 #1

### 输入

```
5
1
2
3
5
10```

### 输出

```
1
3
21
140
2268000```

# AI分析结果



**唯一算法分类**：组合数学与数论

---

### **题解思路与核心难点**

1. **核心算法流程**：
   - **确定最大长度**：通过数学推导得出最大完美长度 `x = floor(log2(n)) + 1`。
   - **分情况求和**：
     - **全2序列**：和为 `2^x - 1`。
     - **含3序列**：当 `3*2^(x-2) ≤ n` 时，存在一个3倍项，和为 `(3x-4)*2^(x-1) - x + 2`。
   - **计算出现次数**：组合数 `C(n, x) * (n-x)!`，表示选x个位置并排列剩余元素。

2. **解决难点**：
   - **数学推导**：通过等比数列求和和分情况讨论，得出含3序列的和式。
   - **高效预处理**：阶乘、逆元、幂次预处理，实现O(1)查询。

---

### **题解评分（≥4星）**

1. **Demeanor_Roy（5星）**  
   - **亮点**：数学推导清晰，代码高效，预处理阶乘逆元，时间复杂度O(T + n)。  
   - **核心代码**：
     ```cpp
     ans = (n! / x!) * (2^x - 1) % mod;
     if (含3情况) ans += (n! / x!) * ((3x-4)*2^{x-1} - x + 2) % mod;
     ```

2. **liuChF（4星）**  
   - **亮点**：详细拆解和式推导，适合数学学习，但代码未完全体现推导。  
   - **个人心得**：通过观察分块求和，发现通项公式。

3. **AgOH（4星）**  
   - **亮点**：简洁代码实现，预处理逆元，但推导部分略简。  
   - **代码片段**：
     ```cpp
     LL tot = fact[n] * inv[len] % mod;
     ans = tot * ((1<<len) - 1) % mod;
     ```

---

### **最优思路与技巧提炼**

1. **数学推导**：  
   - 通过等比数列和分块讨论，快速计算全2和含3序列的和。
   - **关键公式**：含3序列和 `Sum = (3x-4)*2^(x-1) - x + 2`。

2. **组合优化**：  
   - 预处理阶乘和逆元，快速计算组合数 `C(n, x)`，时间复杂度O(1)。

3. **边界处理**：  
   - 判断 `3*2^(x-2) ≤ n` 决定是否包含含3序列。

---

### **同类题型推荐**

1. **P1108 低价购买**（最长递减子序列计数）
2. **P1025 数的划分**（组合数应用）
3. **P1061 迎春舞会之木棒**（因数分解与动态规划）

---

### **可视化与算法演示**

**动画设计**：
- **像素风格**：用8位色块表示序列元素，蓝色表示2的幂次，红色表示3倍项。
- **步进演示**：逐步生成全2序列和含3序列，高亮当前操作元素。
- **音效提示**：播放“点击”音效当元素被选中，成功生成序列时播放胜利音效。

**交互设计**：
- **控制面板**：允许调节动画速度，单步执行观察组合数计算。
- **Canvas 示例**：
  ```javascript
  function drawSequence(sequence) {
    ctx.fillStyle = "#8B0000"; // 复古红
    sequence.forEach((num, idx) => {
      drawPixel(num, idx * 32, 0); // 在Canvas绘制像素块
    });
  }
  ```

---

### **核心代码实现**

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=1e6+5, mod=1e9+7;
LL fac[N], inv[N], pow2[N];

void init() {
    fac[0] = pow2[0] = 1;
    for(int i=1; i<N; ++i) {
        fac[i] = fac[i-1] * i % mod;
        pow2[i] = pow2[i-1] * 2 % mod;
    }
    inv[N-1] = 1;
    for(LL a=fac[N-1], p=mod-2; p; p>>=1, a=a*a%mod)
        if(p&1) inv[N-1] = inv[N-1]*a % mod;
    for(int i=N-2; i>=0; --i) inv[i] = inv[i+1]*(i+1) % mod;
}

int main() {
    init();
    int T; scanf("%d", &T);
    while(T--) {
        int n; scanf("%d", &n);
        if(n == 1) { puts("1"); continue; }
        int x = log2(n) + 1;
        LL ans = fac[n] * inv[x] % mod * (pow2[x] - 1) % mod;
        if(x >=2 && (1 << (x-2)) * 3 <= n) {
            LL add = ((3LL*x -4) * pow2[x-1] % mod - x + 2 + mod) % mod;
            ans = (ans + fac[n] * inv[x] % mod * add) % mod;
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```

---

**总结**：本题通过数学推导与组合优化，高效解决了完美子序列的价值和问题，核心在于分情况讨论与预处理技术。可视化设计通过复古像素风格增强理解，适合算法教学演示。

---
处理用时：82.18秒
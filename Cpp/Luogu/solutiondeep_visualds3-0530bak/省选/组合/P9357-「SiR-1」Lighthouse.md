# 题目信息

# 「SiR-1」Lighthouse

## 题目描述

给定一棵 $n$ 个点的树，每个点有权值 $w_i$，初始为 $0$。初始得分 $s=0$。

进行 $m$ 次操作，每次操作选择一个点 $u$，给 $s$ 增加 $u$ 所在的同点权连通块的大小（即，假设只保留点权等于 $w_u$ 的点，和连接两个点权等于 $w_u$ 的点的边，对得分的贡献就是此时 $u$ 所在的连通块大小。注意这不会真的删去一部分树上的点和边），然后给 $w_u$ 增加 $1$。

请对所有 $n^m$ 种操作方式，求它们的得分 $s$ 之和，对 $10^9+7$ 取模。

## 说明/提示

对于所有数据，满足 $1\leq n\leq 1000$，$1\leq m\leq 10^5$，$1\leq u,v\leq n$，保证输入是一棵树。

- Subtask 0（5 pts）：$n,m\le 7$。
- Subtask 1（20 pts）：$n,m\le 10$。
- Subtask 2（15 pts）：$n,m\le 50$。
- Subtask 3（15 pts）：$n,m\le 100$。
- Subtask 4（15 pts）：$n\le 50$。
- Subtask 5（15 pts）：树是一条链。
- Subtask 6（15 pts）：无特殊限制。

本题同时开启子任务依赖。具体地：

+ 对于子任务 $i(i \in [1, 3])$，依赖于子任务 $0 \sim (i -  1)$；
+ 对于子任务 $4$，依赖于子任务 $0 \sim 2$；
+ 对于子任务 $6$，依赖于子任务 $0 \sim 5$。

## 样例 #1

### 输入

```
3 2
1 3
2 3```

### 输出

```
40```

# AI分析结果



**算法分类**：组合数学 + 动态规划

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
所有题解均将总贡献拆解为点对之间的路径长度相关项，通过预处理组合数和动态规划优化计算。核心步骤包括：
1. **路径长度统计**：计算所有点对间路径长度为 d 的数目 cnt[d]。
2. **概率与贡献分解**：将每次操作的贡献拆解为路径上的操作次数和分布概率，结合组合数学公式。
3. **后缀和优化**：预处理组合数后缀和，避免重复计算。

#### **解决难点**
1. **贡献拆分**：将总贡献转换为按路径长度分组的计算，避免 O(n^2m) 的暴力枚举。
2. **组合数爆炸**：通过阶乘、逆元预处理，以及动态规划递推 f(a,b)，将复杂度降至 O(nm)。
3. **高效计算后缀和**：对每个 d 预处理后缀和 Suf，快速计算路径操作的组合贡献。

---

### **题解评分（≥4星）**

1. **E.Space（5星）**  
   - **亮点**：将问题转化为期望计算，利用路径长度分组处理，代码清晰。
   - **关键公式**：  
     $$\sum_{d=1}^n c_d \sum_{w=0}^{\lfloor(m-1)/d\rfloor} \frac{(dw)!}{(w!)^d d^{dw+1}} \text{Suf}(dw+1)$$

2. **Yanami_Anna（4.5星）**  
   - **亮点**：代码实现简洁高效，预处理后缀和和组合数，时间复杂度最优。
   - **代码片段**：  
     ```cpp
     for(int l=1;l<=n;l++){
         int Fuck=(n-l)*power(l)%P;
         int D=1;
         for(int i=m;i>=0;i--){
             Suf[i]=(Suf[i+1]+C(m,i)*D%P)%P;
             D=D*Fuck%P;
         }
         // 计算每个w的贡献...
     }
     ```

3. **Sol1（4星）**  
   - **亮点**：递推式 f(a,b) 的设计巧妙，避免直接计算复杂组合数。
   - **关键推导**：  
     $$f_{a,b} = \frac{n-b}{b}f_{a-1,b} - \frac{n}{b}\binom{m}{a}\left(\frac{n-b}{n}\right)^m$$

---

### **最优思路提炼**
1. **路径长度分组**：统计所有点对路径长度 d，将总贡献转换为 $\sum cnt[d] \cdot G(d)$。
2. **组合数后缀和**：预处理后缀和 Suf，将嵌套循环优化为 O(m) 计算。
3. **动态规划递推**：设计递推式 f(a,b) 处理组合数求和，避免重复计算。

---

### **同类型题推荐**
1. **P1357 花园**（组合数学 + 状态压缩）
2. **P3223 [HNOI2012]排队**（树形结构 + 组合计数）
3. **P4071 [SDOI2016]排列计数**（错位排列 + 组合数预处理）

---

### **代码核心实现**
**关键预处理与后缀和计算**：
```cpp
// 预处理组合数
for(int i=0;i<=m;i++) Co[i] = C(m, i);

// 计算每个d的后缀和
for(int l=1; l<=n; l++){
    int Fuck = (n-l) * power(l) % P; // 比例因子 (n-l)/l
    int D = 1; // 当前项的比例因子幂次
    for(int i=m; i>=0; i--){
        Suf[i] = (Suf[i+1] + Co[i] * D % P) % P;
        D = D * Fuck % P;
    }
    // 计算每个w的贡献...
}
```

---

### **可视化与算法演示**
**动画设计**：
1. **树结构展示**：用 Canvas 绘制树形结构，节点高亮当前路径。
2. **操作模拟**：动态显示每次操作对路径的影响，颜色标记连通块。
3. **组合数计算**：以网格形式展示后缀和 Suf 的更新过程，高亮当前计算的 i 和 D。
4. **复古像素风格**：采用 8-bit 音效，每次后缀和更新时播放“滴”声，完成时播放胜利音效。

**交互设计**：
- **步进控制**：允许单步执行后缀和计算，观察 Suf[i] 的变化。
- **路径高亮**：点击节点展示其所有路径长度统计 cnt[d]。

---

**总结**：本题通过路径长度分组和组合数优化，将复杂贡献计算转化为可处理形式。代码实现中，预处理和动态规划是关键，时间复杂度优化至 O(nm + m log m)。

---
处理用时：58.27秒
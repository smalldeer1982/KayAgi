# 题目信息

# 血缘关系

## 题目描述

我们正在研究妖怪家族的血缘关系。每个妖怪都有相同数量的基因，但是不同的妖怪的基因可能是不同的。我们希望知道任意给定的两个妖怪之间究竟有多少相同的基因。由于基因数量相当庞大，直接检测是行不通的。但是，我们知道妖怪家族的家谱，所以我们可以根据家谱来估算两个妖怪之间相同基因的数量。

妖怪之间的基因继承关系相当简单：如果妖怪 $C$ 是妖怪 $A$ 和 $B$ 的孩子，则 $C$ 的任意一个基因只能是继承 $A$ 或 $B$ 的基因，继承 $A$ 或 $B$ 的概率各占 $50\%$。所有基因可认为是相互独立的，每个基因的继承关系不受别的基因影响。

现在，我们来定义两个妖怪 $X$ 和 $Y$ 的基因相似程度。例如，有一个家族，这个家族中有两个毫无关系（没有相同基因）的妖怪 $A$ 和 $B$，及它们的孩子 $C$ 和 $D$。那么 $C$ 和 $D$ 相似程度是多少呢？因为 $C$ 和 $D$ 的基因都来自 $A$ 和 $B$，从概率来说，各占 $50\%$。所以，依概率计算 $C$ 和 $D$ 平均有 $50\%$ 的相同基因，$C$ 和 $D$ 的基因相似程度为 $50\%$。需要注意的是，如果 $A$ 和 $B$ 之间存在相同基因的话，$C$ 和 $D$ 的基因相似程度就不再是 $50\%$ 了。

你的任务是写一个程序，对于给定的家谱以及成对出现的妖怪，计算它们之间的基因相似程度。

## 样例 #1

### 输入

```
7 4                                                    

4 1 2                                          

5 2 3                                          

6 4 5                                          

7 5 6

4

1 2

2 6

7 5

3 3

```

### 输出

```
0%

50%

81.25%

100%

```

# AI分析结果



---

## 唯一算法分类  
动态规划

---

## 综合分析与结论  
### 核心算法流程  
1. **递推公式**：设 f[i][j] 表示妖怪 i 和 j 的基因相似度，递推公式为：  
   f[i][j] = (f[i][fa[j][0]] + f[i][fa[j][1]]) / 2 （当 j 辈分较低时）  
   或  
   f[i][j] = (f[fa[i][0]][j] + f[fa[i][1]][j]) / 2 （当 i 辈分较低时）

2. **拓扑排序确定辈分**：通过 BFS 拓扑排序确定每个节点的层级（辈分），确保计算时总从辈分高的节点向辈分低的节点递推。

3. **记忆化搜索**：结合辈分比较，动态选择递推方向避免无限递归。

4. **高精度实现**：用定点小数存储，支持加法和除2操作，处理最多300位小数。

### 可视化设计思路  
- **树状结构展示**：用 Canvas 绘制家谱树，节点按拓扑层级排列，当前计算的节点对用闪烁边框标记。
- **递推路径高亮**：当计算 f[7][5] 时，动态显示分解路径 f[7][5] → (f[5][5] + f[6][5])/2，用箭头连接相关节点。
- **高精度运算动画**：在侧边栏展示除法过程，如计算 81.25% 时，用逐位染色的方式展示 (75% + 87.5%)/2 的运算过程。

---

## 题解清单（≥4星）  
1. **jiangyougogogo（4.5星）**  
   - 亮点：完整的拓扑排序实现 + 定点数高精度设计  
   - 关键代码：`div()` 函数通过余数传递实现除2运算，`C(x,y)` 函数优雅处理辈分比较

2. **Salamander（4.2星）**  
   - 亮点：用运算符重载实现高精度，代码结构清晰  
   - 关键优化：辈分比较时直接交换节点，避免重复代码

3. **Comentropy（4.0星）**  
   - 亮点：分离高精度运算为独立结构体，支持链式调用  
   - 可视化友好：`print()` 函数直接处理百分数格式化输出

---

## 核心代码实现  
### 拓扑排序与辈分计算  
```cpp
queue<int> q;
for(int i=1; i<=n; i++)
    if(!in[i]) q.push(i), dep[i]=1;

while(!q.empty()) {
    int u = q.front(); q.pop();
    for(int v : sons[u]) {
        if(--in[v] == 0) {
            dep[v] = dep[u] + 1;
            q.push(v);
        }
    }
}
```

### 高精度除2运算  
```cpp
struct High {
    short data[305]; // data[0]整数位，data[1..300]小数位
    int len;
};

High div2(High x) {
    int carry = 0;
    for(int i=0; i<=x.len; i++) {
        int val = x.data[i] + carry * 10;
        x.data[i] = val / 2;
        carry = val % 2;
    }
    if(carry && x.len<300) {
        x.len++;
        x.data[x.len] = 5; // 处理最后余数
    }
    return x;
}
```

---

## 同类型题与算法套路  
1. **树形DP+概率计算**：如计算二叉树中两节点共同祖先的概率  
2. **拓扑序依赖的动态规划**：如工程调度中的最优顺序计算  
3. **定点数高精度应用**：货币计算、科学模拟等场景

---

## 推荐练习题  
1. P1436 棋盘分割（动态规划+浮点精度控制）  
2. P1340 兽径管理（拓扑排序+路径计算）  
3. P2602 数字计数（高精度数位统计）

---

## 可视化与复古动画设计  
### 像素风格演示  
```html
<canvas id="gene-tree"></canvas>
<script>
// 绘制家谱树
function drawTree(nodes) {
    ctx.fillStyle = "#8B0000"; // 深红节点
    nodes.forEach(node => {
        drawPixelRect(node.x, node.y, 16, 16); // 16x16像素方块
        if(node.active) { // 当前激活节点
            ctx.strokeStyle = "#FFD700"; // 金色边框
            ctx.strokeRect(node.x-2, node.y-2, 20, 20);
        }
    });
}

// 触发音效
function playSound(type) {
    const sfx = {
        calc: [500, 0.2, , , 0.02], // 计算音效
        done: [1200, 0.5, , , 0.1]  // 完成音效
    };
    synth.triggerAttackRelease(sfx[type][0], sfx[type][1]);
}
</script>
```

### 交互设计  
- **步进控制**：空格键单步执行当前计算步骤  
- **自动模式**：按 A 键启动自动演示（速度可调）  
- **音效反馈**：每次除2运算播放 8bit 风格 "blip" 音效，完成时播放上升音阶

---

## 个人心得摘录  
> "调试时发现高精度的余数传递顺序写反了，导致样例中的 81.25% 始终算成 75%。后来通过逐位打印中间变量才定位到问题。" —— jiangyougogogo

> "运算符重载让代码更直观，但初始化时忘记清零数组导致 WA 了三次。血的教训：永远要 memset！" —— Salamander

---
处理用时：77.65秒
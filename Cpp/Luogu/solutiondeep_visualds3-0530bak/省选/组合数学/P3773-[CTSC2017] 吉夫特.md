# 题目信息

# [CTSC2017] 吉夫特

## 题目描述

简单的题目，既是礼物，也是毒药。

B 君设计了一道简单的题目，准备作为 gift 送给大家。

输入一个长度为  $n$  的数列  $a_1, a_2, \cdots , a_n$  问有多少个长度大于等于  $2$  的不上升的子序列满足：

 $$\prod _{i=2}^{k} \binom{a_{b_{i-1}}}{a_{b_i}} \bmod 2 = \binom{a_{b_1}}{a_{b_2}} \times \binom{a_{b_2}}{a_{b_3}} \times \cdots \binom{a_{b_{k-1}}}{a_{b_k}} \bmod 2 > 0$$ 

输出这个个数对  $1000000007$  取模的结果。

G 君看到题目后，为大家解释了一些基本概念。

我们选择任意多个整数  $b_i$  满足

 $$1 \leq b_1 < b_2 < \dots < b_{k-1} < b_k \leq n$$ 

我们称  $a_{b_1}, a_{b_2}, \cdots, a_{b_k} $  是  $a$  的一个子序列。

如果这个子序列同时还满足

 $$a_{b_1} \geq a_{b_2} \geq \cdots \geq a_{b_{k-1}}\geq a_{b_k}$$ 

我们称这个子序列是不上升的。

组合数  $\binom {n} {m} $  是从  $n$  个互不相同的元素中取  $m$  个元素的方案数，具体计算方案如下：

 $$\binom {n}{m}=\frac{n!}{m!(n-m)!}=\frac{n \times (n-1) \times \cdots \times 2 \times 1}{(m \times (m-1) \cdots \times 2 \times 1)((n-m)\times(n-m-1)\times \cdots \times 2 \times 1)}$$ 

这里要特别注意，因为我们只考虑不上升子序列，所以在求组合数的过程中，一定满足  $n \geq m$ ，也就是 $\binom {a_{b_{i-1}}}{a_{b_i}}$ 中一定有 $a_{b_{i-1}} \geq a_{b_i}$ 。

我们在这里强调取模  $x \mod y$  的定义：

 $x \bmod y = x -\left \lfloor \frac{x}{y} \right \rfloor \times y$ 

其中  $\left \lfloor n \right \rfloor$  表示小于等于  $n$  的最大整数。

 $x \bmod 2 > 0$  ，就是在说  $x$  是奇数。

与此同时，经验告诉我们一个长度为  $n$  的序列，子序列个数有  $O(2^n)$  个，所以我们通过对答案取模来避免输出过大。

B 君觉得 G 君说的十分有道理，于是再次强调了这些基本概念。

最后， G 君听说这个题是作为 gift 送给大家，她有一句忠告。

“Vorsicht, Gift!”

“小心. . . . . .剧毒！ ”

## 说明/提示

对于前 $10\%$ 的测试点，$n \leq 9$，$1\leq a_i\leq 13$。

对于前 $20\%$ 的测试点，$n\leq 17$，$1\leq a_i\leq 20$。

对于前 $40\%$ 的测试点，$n\leq 1911$，$1\leq a_i\leq 4000$。

对于前 $70\%$ 的测试点，$n\leq 2017$。

对于前 $85\%$ 的测试点，$n\leq 100084$。

对于 $100\%$ 的测试点，$1\leq n\leq 211985$，$1\leq a_i\leq 233333$。所有的 $a_i$ 互不相同，也就是说不存在 $i, j$ 同时满足 $1\leq i < j\leq n$ 和 $a_i = a_j$。


## 样例 #1

### 输入

```
4
15
7
3
1```

### 输出

```
11```

# AI分析结果



## 算法分类
动态规划 + 位运算优化

## 题解思路与算法分析

### 核心思路
通过 Lucas 定理推导出组合数奇偶性条件：当且仅当 $a_j$ 的二进制是 $a_i$ 的子集时，$\binom{a_i}{a_j} \mod 2 = 1$。问题转化为求所有满足元素二进制依次为子集的子序列个数。

### 难点对比
1. **直接枚举子集法**（如_ctz题解）：
   - 时间复杂度 $O(3^{\log \max a_i})$，实测可通过
   - 代码极简，直接枚举每个数的所有二进制子集
   - 需预处理每个数出现的位置

2. **分块优化法**（如SovietPower题解）：
   - 将二进制拆分为前9位和后9位
   - 前9位枚举超集，后9位枚举子集
   - 时间复杂度优化至 $O(3^{9} \times 3^{9}) = 3^{18}$

3. **逆向DP法**（如litble题解）：
   - 从后往前计算，利用桶记录数值位置
   - 枚举子集时直接查询桶中是否存在更大下标
   - 复杂度与直接枚举子集法相同，但实现更直观

### 最优思路提炼
**关键点**：
1. 利用 `x & (x-1)` 快速枚举二进制子集
2. 动态规划状态转移方程：  
   $f[a_i] = 1 + \sum_{S \subseteq a_i} f[S]$
3. 滚动累加答案时需减去单元素序列

**代码实现核心**：
```cpp
for (int i = 1; i <= n; ++i) {
    a = read();
    // 枚举所有子集
    for (int S = a; ; S = (S-1)&a) {
        sum += f[S];
        if (!S) break;
    }
    ans += sum;
    // 更新当前数的贡献
    for (int S = a; S; S = (S-1)&a) 
        f[S] += sum + 1;
}
```

## 题解评分（≥4星）
1. **_ctz的题解**（★★★★☆）  
   - 代码极简（仅20行），核心逻辑清晰
   - 直接利用位运算枚举子集
   - 时间复杂度可接受（实测AC）

2. **SovietPower的题解**（★★★★★）  
   - 分块优化显著降低理论复杂度
   - 前/后9位拆分技巧具有普适性
   - 实现包含高效位运算技巧

3. **litble的题解**（★★★★☆）  
   - 逆向DP思路直观易懂
   - 利用桶记录位置优化查询
   - 代码包含详细注释

## 可视化设计
### 算法演示方案
1. **动态位运算展示**  
   - **Canvas绘制**：每个数以二进制形式显示为8x8像素块（0=灰色，1=黄色）
   - **高亮标记**：
     - 当前处理的数：红色边框
     - 正在枚举的子集：绿色闪烁
   - **数据流动画**：当子集S被找到时，从父集向S绘制箭头，伴随像素音效

2. **复古游戏化要素**  
   - **音效设计**：
     - 枚举子集时：短促"哔"声（Web Audio合成方波）
     - 找到有效子集：上升音调
     - 答案更新：金币收集音效
   - **积分系统**：
     - 每次成功转移+10分
     - 连续无重复子集触发连击倍率

3. **自动演示模式**  
   ```javascript
   function autoPlay() {
       let timer = setInterval(() => {
           if (!stepNext()) clearInterval(timer);
       }, 1000); // 可调节速度
   }
   ```

## 同类型题目推荐
1. [P4869 组合数问题](https://www.luogu.com.cn/problem/P4869)  
   （组合数奇偶性判断的扩展）
2. [P2150 寿司晚宴](https://www.luogu.com.cn/problem/P2150)  
   （子集动态规划的经典问题）
3. [CF165E Compatible Numbers](https://codeforces.com/problemset/problem/165/E)  
   （二进制子集查询的巧妙应用）

---

## 完整代码实现（_ctz版）
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#define maxn 250005
using namespace std;
const int mod = 1e9 + 7;

int f[maxn], ans;

int main() {
    int n, a;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &a);
        int sum = 0;
        // 枚举所有子集（包括空集）
        for (int S = a; ; S = (S-1)&a) {
            sum = (sum + f[S]) % mod;
            if (S == 0) break;
        }
        ans = (ans + sum) % mod;
        // 更新当前数的所有子集
        for (int S = a; S; S = (S-1)&a)
            f[S] = (f[S] + sum + 1) % mod;
    }
    printf("%d\n", ans);
    return 0;
}
```

---
处理用时：61.92秒
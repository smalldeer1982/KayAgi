# 题目信息

# [THUPC 2019] 过河卒二

## 题目描述

> 首先我们回忆一下经典难题过河卒问题：
>
> 棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向上、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点，因此称之为「马拦过河卒」。
>
> 棋盘用坐标表示，$A$ 点 $(1,1)$ 、$B$ 点 $(N,M)$ ，同样马的位置坐标是需要给出的。
>
> 现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。
>
> **请注意，上述背景内容与本题无关！**

Kiana 喜欢玩象棋，尤其是喜欢用象棋玩过河卒的游戏。在传统的过河卒问题中，Kiana 需要控制一个卒从起点走到终点，在路中避开一个对方的马的攻击，然后假装不会算并询问你从起点到终点的路径总数。

在今天的过河卒二游戏中，Kiana 还是控制一个卒在一个 $N\times M$ 的棋盘上移动，初始时卒位于左下方坐标为 $(1,1)$ 位置，但为了增加难度，Kiana 对游戏规则做出了一些修改。传统的过河卒每步只能向上或向右移动 $1$ 格，Kiana 规定自己的过河卒二还可以在一步中向右上方移动 $1$ 格，即如果当前卒位于坐标 $(x,y)$ 处，则下一步可以走到 $(x+1,y)$ 、$(x,y+1)$ 或 $(x+1,y+1)$ 中的任意一格里面去，同时 Kiana 认为，如果两种移动方案在某一步时卒移动的方向（右、上或右上）不同，则两种方案就是不同的，例如从 $(1,1)$ 先走到 $(1,2)$ 再走到 $(2,2)$ 、从 $(1,1)$ 先走到 $(2,1)$ 再走到 $(2,2)$ 和从 $(1,1)$ 直接走到 $(2,2)$ 是三种不同的移动方案。

其次，过河卒二的终点不再是一个特定的位置，Kiana 规定卒可以从棋盘的上方或右方走出棋盘，此时就视为游戏成功。注意在走出棋盘时仍然有方向选择的不同，例如若过河卒位于 $(1,M)$ 处，则下一步它可以向右或者向右上用两种方式走出棋盘，若过河卒位于 $(N,M)$ 处，则下一步它可以向上、向右或者向右上用三种方式走出棋盘，以不同的方式走出棋盘仍然被算作是不同的移动方案。

此外，对方马的攻击范围不再是有规律的几个位置，而是 Kiana 规定好的 $K$ 个特定坐标，并要求过河卒在移动的过程中不能走到这 $K$ 个坐标的任何一个上，在除这些坐标以外的位置上过河卒都可以按规则自由移动。

现在 Kiana 想知道，过河卒二有多少种不同的移动方案可以走出棋盘，这个答案可能非常大，她只想知道方案数对 $59393$ 取模后的结果。由于她不会算，所以希望由你来告诉她。



## 说明/提示

### 样例解释

用 $\uparrow$ 表示过河卒向上移动了一格，用 $\rightarrow$ 表示过河卒向右移动了一格，用 $\nearrow$ 表示过河卒向右上移动了一格，由此可以简化样例解释的表述。

$24$ 种移动方案如下：

$(\uparrow\uparrow\uparrow)$、$(\uparrow\uparrow\nearrow)$、$(\uparrow\uparrow\rightarrow\uparrow)$、$(\uparrow\uparrow\rightarrow\nearrow)$、

$(\uparrow\uparrow\rightarrow\rightarrow\uparrow)$、$(\uparrow\uparrow\rightarrow\rightarrow\nearrow)$、$(\uparrow\uparrow\rightarrow\rightarrow\rightarrow)$、$(\uparrow\nearrow\uparrow)$、

$(\uparrow\nearrow\nearrow)$、$(\uparrow\nearrow\rightarrow\uparrow)$、$(\uparrow\nearrow\rightarrow\nearrow)$、$(\uparrow\nearrow\rightarrow\rightarrow)$、

$(\rightarrow\rightarrow\rightarrow)$、$(\rightarrow\rightarrow\nearrow)$、$(\rightarrow\rightarrow\uparrow\rightarrow)$、$(\rightarrow\rightarrow\uparrow\nearrow)$、

$(\rightarrow\rightarrow\uparrow\uparrow\rightarrow)$、$(\rightarrow\rightarrow\uparrow\uparrow\nearrow)$、$(\rightarrow\rightarrow\uparrow\uparrow\uparrow)$、$(\rightarrow\nearrow\rightarrow)$、

$(\rightarrow\nearrow\nearrow)$、$(\rightarrow\nearrow\uparrow\rightarrow)$、$(\rightarrow\nearrow\uparrow\nearrow)$、$(\rightarrow\nearrow\uparrow\uparrow)$。

### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。

## 样例 #1

### 输入

```
3 3 1
2 2```

### 输出

```
24```

# AI分析结果



---

**算法分类**：组合数学 + 容斥原理 / 动态规划

---

### 题解思路与核心难点

#### 核心思路
1. **问题转化**：将“走出棋盘”转化为走到虚拟点 $(n+1, m+1)$，只需计算从 $(1,1)$ 到该点的合法路径数。
2. **无障碍路径计算**：允许斜走的路径数公式为 $\sum_{i=0}^{\min(x,y)} \binom{x+y-i}{i} \cdot \binom{x+y-2i}{x-i}$，其中 $x,y$ 是坐标差。
3. **障碍处理**：使用容斥原理或动态规划排除经过障碍的路径。

#### 解决难点
- **组合数计算**：模数 59393 较小，需用 Lucas 定理处理大数组合数。
- **障碍点排序**：按坐标排序后，确保路径合法（仅允许向右/上移动）。
- **容斥优化**：状态压缩枚举障碍子集，预处理两点间路径数降低复杂度。

---

### 题解评分（≥4星）

#### 1. huayucaiji (5星)
- **亮点**：状态压缩容斥，预处理路径数，Lucas 定理高效实现。
- **代码**：结构清晰，模块化阶乘/逆元预处理。

#### 2. Eznibuil (4星)
- **亮点**：动态规划处理障碍点，复杂度 $O(k^2 \cdot m)$，适合大 $k$。
- **代码**：简洁的 DP 转移，利用排序保证单调性。

#### 3. AThousandSuns (4星)
- **亮点**：容斥与排序结合，预处理关键路径数，代码注释详尽。
- **心得**：强调问题转化和虚拟汇点的巧妙性。

---

### 最优思路提炼
- **路径计算**：枚举斜走次数，组合数公式快速求解两点间路径。
- **容斥技巧**：按坐标排序障碍点，预处理合法路径数，避免重复计算。
- **动态规划优化**：用 $dp[i]$ 表示不经过前序障碍到达第 $i$ 个点的方案数，复杂度更低。

---

### 同类型题推荐
1. **P3958 [NOIP2017 提高组] 奶酪**（容斥与几何路径）
2. **P1352 没有上司的舞会**（树形 DP 与状态转移）
3. **P1020 [NOIP1999 提高组] 导弹拦截**（动态规划与单调性优化）

---

### 可视化与算法演示设计

#### 复古像素动画
- **Canvas 绘制**：以网格表示棋盘，绿色方块为起点，红色为障碍，金色为终点。
- **路径高亮**：当前路径用蓝色标记，斜走时显示对角线动画。
- **音效设计**：
  - **移动**：8-bit 短音效。
  - **触碰障碍**：低音失败音效。
  - **到达终点**：胜利旋律。

#### 控制面板
- **步进控制**：单步执行观察路径生成。
- **容斥演示**：显示当前子集的障碍点，计算贡献时闪烁对应路径。

```javascript
// 示例代码片段：路径计算与动画
function drawPath(path) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  path.forEach((step, idx) => {
    setTimeout(() => {
      drawPixel(step.x, step.y, 'blue');
      if (idx > 0) drawLine(path[idx-1], step);
    }, idx * 500);
  });
}
```

---

### 代码片段（核心逻辑）

#### 路径计算（组合数）
```cpp
int calc(int x, int y) {
  int ans = 0;
  for (int i = 0; i <= min(x, y); ++i)
    ans = (ans + lucas(x + y - i, i) * lucas(x + y - 2*i, x - i)) % MOD;
  return ans;
}
```

#### 动态规划（容斥）
```cpp
for (int i = 1; i <= k; ++i) {
  dp[i] = calc(p[i].x, p[i].y);
  for (int j = 1; j < i; ++j)
    if (p[j].y <= p[i].y)
      dp[i] = (dp[i] - dp[j] * calc(p[i].x - p[j].x, p[i].y - p[j].y)) % MOD;
}
```

---

### 总结
本题核心在于灵活运用组合数学与容斥/DP 处理路径计数，通过预处理和状态优化降低复杂度。可视化设计可增强对路径生成和容斥过程的理解，复古风格增添趣味性。

---
处理用时：61.58秒
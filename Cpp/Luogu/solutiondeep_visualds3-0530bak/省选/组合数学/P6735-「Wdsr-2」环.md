# 题目信息

# 「Wdsr-2」环

## 题目描述

Kagamine Rin 有一个圆环，上面均匀分布着 $n$ 个点，这些点之间连接着 $m$ 条线段。

突然有一天，这些线段全都不见了。

Rin 想要找回这些线段，但是她不记得线段的分布。她只记得，这些线段中任意两条都不相交。

**注意：只在端点处相交不算相交；重合不算相交。** 下面的样例解释有助于理解本题中的定义。

Rin 有时还会记得一些额外的信息，她可能还会告诉你每个点上连接的线段数。

现在 Rin 想要知道，符合她的记忆的方案数有多少种。由于结果可能很大，你只需要输出答案对 $1000000007$ 取模的结果（模数是一个质数）。


## 说明/提示

样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/82pgikk2.png)

**Update：上图第二行第三个画错了，它的竖应该在右边**


如上图，有 $20$ 种方案满足样例 $1$ 的要求，而只有最后两种方案满足样例 $2$ 的要求。

------

**本题采用捆绑测试**，数据范围遵守如下约定：

subtask | $n\le$ | $m\le$ | $type$ | 分数
:-:|:-:|:-:|:-:|:-:
$0$ | $8$ | $8$ | $0$ | $10$
$1$ | $50$ | $50$ | $0$ | $10$
$2$ | $4000$ | $4000$ | $0$ | $15$
$3$ | $8$ | $8$ | $1$ | $10$
$4$ | $50$ | $50$ | $1$ | $15$
$5$ | $600$ | $600$ | $1$ | $20$
$6$ | $4000$ | $4000$ | $1$ | $20$

对于所有数据，有 $2\le n\le 4000,1\le m\le 4000,type\in \{0,1\}, a_i \ge 0$。若 $type=1$ 则保证 $\sum_{i=1}^na_i=2m$。

## 样例 #1

### 输入

```
4 2 0
```

### 输出

```
20
```

## 样例 #2

### 输入

```
4 2 1
1 1 1 1
```

### 输出

```
2
```

# AI分析结果



---

**唯一算法分类**：组合数学、动态规划

---

### 综合分析与结论

**核心思路**  
1. **type=0（无度数约束）**：转化为组合数学问题，利用卡特兰数变形模型。公式为：  
   $$ ans = \frac{\binom{n+m-2}{n-2} \cdot \binom{n+m-1}{n-2}}{n-1} $$  
   通过预处理组合数实现高效计算。  
2. **type=1（有度数约束）**：动态规划（DP）模型。状态 `dp[i][j]` 表示前 `i` 个点使用 `j` 条线段的方案数，转移时需满足度数约束和线段不交叉的条件。

**解决难点**  
- **组合公式推导**：发现线段不交叉的匹配与卡特兰数的关联，通过递推关系导出组合公式。  
- **动态规划设计**：状态转移需同时处理度数约束（`a[i]`）和线段数限制（`sum-2j`），避免相交结构。

**可视化设计**  
- **type=0的动画**：以圆环为背景，用像素方块表示线段，动态展示不交叉线段的所有可能组合，最终收敛到公式计算结果。  
- **type=1的DP动画**：  
  - **像素网格**：用网格表示 `dp[i][j]`，当前处理点用红色高亮，转移路径用绿色连线。  
  - **音效**：每次状态更新播放“哔”声，成功转移时播放上升音调。  
  - **自动模式**：AI按最优顺序填充网格，展示转移逻辑。

---

### 题解评分（≥4星）

1. **鏡音リン的题解（4.5星）**  
   - **亮点**：详细推导递推关系与组合公式，覆盖所有子任务，代码结构清晰。  
   - **优化**：数学公式直接解决type=0的大数据情况，时间复杂度极低。  
2. **tzl_Dedicatus545的题解（4星）**  
   - **亮点**：简洁的代码实现，动态规划部分逻辑明确，适合快速理解核心转移。  
   - **改进**：缺乏公式推导的详细解释，但对type=1的DP实现高效。

---

### 最优思路与技巧

1. **组合数学模型**  
   - 将环拆解为链，通过不交叉线段的匹配模式发现与卡特兰数的关联。  
   - 利用组合数公式直接计算答案，避免高复杂度的递推。  
2. **动态规划优化**  
   - 状态设计 `dp[i][j]` 表示前 `i` 个点使用 `j` 条线段，转移时利用前缀和优化。  
   - 约束条件 `k ≤ min(a[i], sum-2j)` 确保合法性，避免无效计算。

---

### 同类题目推荐

1. **P1044 [NOIP2003 普及组] 栈**  
   - 卡特兰数的经典应用，计算栈操作序列的可能数。  
2. **P1641 [SCOI2010] 生成字符串**  
   - 组合数学与不合法路径计数，类似不交叉线段问题。  
3. **P4381 [IOI2008] Island**  
   - 动态规划处理环形结构，与本题的环拆链思想相关。

---

### 代码实现（核心逻辑）

**type=0的组合数解法**  
```cpp
void Solve0() {
    // 预处理组合数C[n+m-2][n-2]和C[n+m-1][n-2]
    // 答案公式：ans = (C1 * C2) / (n-1) mod MOD
    long long C1 = comb[n + m - 2][n - 2];
    long long C2 = comb[n + m - 1][n - 2];
    long long inv_n = inverse(n - 1); // 逆元计算
    cout << (C1 * C2 % MOD) * inv_n % MOD << endl;
}
```

**type=1的动态规划解法**  
```cpp
int dp[MAXN][MAXM]; // dp[i][j]: 前i个点使用j条线段
void Solve1() {
    dp[0][0] = 1;
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += a[i];
        for (int j = 0; j <= m; j++) {
            if (dp[i-1][j] == 0) continue;
            int max_k = min(a[i], sum - 2 * j);
            for (int k = 0; k <= max_k; k++) {
                dp[i][j + k] = (dp[i][j + k] + dp[i-1][j]) % MOD;
            }
        }
    }
    cout << dp[n][m] << endl;
}
```

---

### 可视化与游戏化设计

**8位像素风格动态规划演示**  
- **Canvas布局**：横向为点编号，纵向为线段数，每个格子表示 `dp[i][j]`。  
- **颜色标记**：  
  - 红色：当前处理的点 `i`。  
  - 绿色：转移路径 `j → j+k`。  
  - 黄色：有效状态更新。  
- **音效**：  
  - `jump.wav`：状态转移时播放。  
  - `success.wav`：到达最终状态 `dp[n][m]`。  
- **自动模式**：AI按从左到右、自上而下的顺序填充格子，模拟DP过程。

**交互控制**  
- **速度调节**：滑动条控制动画速度（1x-5x）。  
- **单步执行**：按空格键逐步执行转移。  
- **数据重置**：随机生成新的 `a[i]` 重新演示。

---

**总结**：本题通过组合数学与动态规划的巧妙结合，展示了不同约束条件下的计数方法。核心在于识别问题模型并选择最优策略，公式法或DP各有适用场景。

---
处理用时：94.80秒
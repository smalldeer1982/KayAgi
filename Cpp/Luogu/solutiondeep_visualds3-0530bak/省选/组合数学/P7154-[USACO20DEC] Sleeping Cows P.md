# 题目信息

# [USACO20DEC] Sleeping Cows P

## 题目描述


Farmer John 有 $N$（$1≤N≤3000$）头各种大小的奶牛。他原本为每头奶牛量身定制了牛棚，但现在某些奶牛长大了，使得原先的牛棚大小不够用。具体地说，FJ 原来建造了 $N$ 个牛棚的大小为 $t_1,t_2,…,t_N$，现在奶牛的大小为 $s_1,s_2,…,s_N$（$1≤s_i,t_i≤10^9$）。

每天晚上，奶牛们都会按照某种方式寻找睡觉的牛棚。奶牛 $i$ 可以睡在牛棚 $j$ 中当且仅当她的大小可以进入牛棚（$s_i≤t_j$）。每个牛棚中至多可以睡一头奶牛。

我们称奶牛与牛棚的一个匹配是极大的，当且仅当每头奶牛可以进入分配给她的牛棚，且对于每头未被分配牛棚的奶牛无法进入任何未分配的空牛棚。

计算极大的匹配的数量模 $10^9+7$ 的结果。 

## 说明/提示

以下是全部九种极大的匹配。有序对 $(i,j)$ 表示奶牛 $i$ 被分配到了牛棚 $j$。

```
(1, 1), (2, 2), (3, 4)
(1, 1), (2, 3), (3, 4)
(1, 1), (2, 4)
(1, 2), (2, 3), (3, 4)
(1, 2), (2, 4)
(1, 3), (2, 2), (3, 4)
(1, 3), (2, 4)
(1, 4), (2, 2)
(1, 4), (2, 3)
```

 - 测试点 2-3 中，$N≤8$。
 - 测试点 4-12 中，$N≤50$。
 - 测试点 13-20 没有额外限制。

供题：Nick Wu 

## 样例 #1

### 输入

```
4
1 2 3 4
1 2 2 3```

### 输出

```
9```

# AI分析结果



**唯一算法分类**：动态规划

---

### **题解思路、算法要点与解决难点**

**核心思路**：  
将牛和牛棚合并排序后，通过动态规划维护以下状态：  
- `dp[i][j][0/1]`：处理到排序后的第i个元素时，有j头牛待匹配，第三维表示是否所有之前的牛都被分配（0：存在未分配的牛，1：所有牛已分配）。

**关键步骤**：  
1. **排序**：将牛和牛棚按大小排序，大小相同时牛优先。
2. **状态转移**：根据当前元素是牛还是牛棚进行不同处理：
   - **遇到牛**：可选择分配或不分配。若不分配，则状态转为存在未分配的牛。
   - **遇到牛棚**：必须匹配所有未分配的牛，或放弃该牛棚（仅当无未分配牛时）。

**解决难点**：  
- **极大匹配的条件**：确保未分配的牛无法与后续未使用的牛棚匹配。通过维护第三维状态（0/1）来保证这一点。
- **复杂度优化**：使用滚动数组将空间复杂度从O(n²)降为O(n)。

---

### **题解评分 (≥4星)**

1. **CXY07的题解（5星）**  
   - **亮点**：状态定义清晰，滚动数组优化，代码可读性高。  
   - **代码片段**：  
     ```cpp
     if (!s[i].scd) { // 牛的处理
         for (int j = 0; j <= n; ++j) {
             if (j) (dp[now][j][0] += dp[pre][j - 1][0]) %= mod;
             (dp[now][j][0] += dp[pre][j][0] + dp[pre][j][1]) %= mod;
         }
     } else { // 牛棚的处理
         for (int j = 0; j <= n; ++j) {
             (dp[now][j][1] += dp[pre][j][1]) %= mod;
             (dp[now][j][1] += dp[pre][j + 1][1] * (j + 1)) %= mod;
         }
     }
     ```

2. **Rainybunny的题解（4星）**  
   - **亮点**：简洁的状态转移方程，直接维护“未匹配牛的最小值 > 未匹配牛棚的最大值”。  
   - **代码片段**：  
     ```cpp
     if (a[i].second == 0) { // 牛
         dp[i+1][j+1][0] = (dp[i][j][0] + ...) % MOD;
     } else { // 牛棚
         dp[i+1][j-1][1] = (dp[i][j][1] * j + ...) % MOD;
     }
     ```

3. **Time_tears的题解（4星）**  
   - **亮点**：分治思想，预处理前后缀DP数组，枚举未匹配的最小牛。  

---

### **最优思路提炼**

**关键技巧**：  
1. **合并排序**：将牛和牛棚统一排序，确保处理顺序合理。  
2. **状态压缩**：用0/1表示是否所有牛已分配，避免无效状态。  
3. **滚动数组**：减少空间占用至O(n)。  

**思维突破点**：  
极大匹配的条件等价于未匹配牛的最小值 > 未匹配牛棚的最大值，通过排序后动态规划天然保证这一条件。

---

### **同类型题与类似算法**

- **类似题目**：  
  - P1896 [SCOI2005] 互不侵犯（状态压缩DP）  
  - P1273 有线电视网（树形DP维护条件）  
  - P3188 [HNOI2007] 梦幻岛宝珠（多维条件DP）  

---

### **推荐相似题目**

1. **P1896**：状态压缩DP解决棋盘放置问题。  
2. **P1273**：树形DP维护收益平衡。  
3. **P3188**：多维背包问题，需处理特殊条件。  

---

### **个人心得摘录**

- **调试教训**：排序时若牛和牛棚大小相同，必须将牛排在前面，否则会导致错误的状态转移。  
- **顿悟点**：极大匹配的条件可通过排序后的自然顺序隐式保证，无需显式判断。  

---

### **可视化与算法演示**

**动画设计**：  
1. **排序展示**：将牛（🐄）和牛棚（🏠）按大小排列，相同大小牛优先。  
2. **状态转移高亮**：  
   - **红色框**：当前处理元素。  
   - **绿色箭头**：状态转移方向（如`j→j+1`表示新增待匹配牛）。  
3. **交互控制**：  
   - **步进按钮**：单步执行状态转移。  
   - **速度调节**：调整动画播放速度。  

**复古像素风格**：  
- **8位色板**：牛用黄色像素块，牛棚用蓝色像素块。  
- **音效**：匹配成功时播放“叮”声，错误时播放“哔”声。  

---

**代码片段（核心DP逻辑）**  
```cpp
// 合并排序后的主循环
for (int i = 1; i <= 2*n; ++i) {
    if (是牛) {
        // 转移逻辑：选择匹配或不匹配
    } else {
        // 转移逻辑：必须匹配或放弃（根据状态）
    }
}
```

**完整代码**参见CXY07题解，已包含滚动数组优化。

---
处理用时：65.97秒
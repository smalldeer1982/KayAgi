# 题目信息

# 「EZEC-6」0-1 Trie

## 题目背景

> $\mathbf{000111}$，这就是简单中所蕴含的优美。

众所周知，tlx 不会字符串。

## 题目描述

现在 tlx 有 $n$ 个 $\mathbf{1}$ 和 $m$ 个 $\mathbf{0}$，你需要把它们排列，但要保证任意的 $\mathbf{1}$ 互不相邻且第一个位置是 $\mathbf{0}$、最后一个位置是 $\mathbf{1}$，现在把所有可以构造出的串放到一棵 0-1 Trie 上，需要多少个节点？

**注意：节点计数时，不计算最开始的空节点，只计算代表“ $\mathbf{0}$ ”、“ $\mathbf{1}$ ”的节点。**  

**在本题中，我们认为用节点存储字符而非边， Trie 基本原理不变。**

因为答案可能很大而且询问较多，所以请在最后输出所有询问的答案对 $18888913$ （放心，是个质数）取模的结果的异或和（**异或和不再进行取模**）。

## 说明/提示

**【样例解释 #1】**

可以发现，所有能构造出的串有：  

$$\mathbf{000101}$$
$$\mathbf{001001}$$
$$\mathbf{010001}$$

构造 0-1 Trie，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/aql3bwo6.png)

共需 $15$ 个节点。


**【样例解释 #2】**

两次询问的答案分别为 $34$ 和 $4487317$。

------------

**【数据规模与提示】**

注意：本题采用**捆绑测试**，只有当你通过一个 Subtask 内的所有测试点后，你才能拿到这个 Subtask 的分数。

具体约束如下：  

Subtask $1$（$10\%$）：满足 $T\leq 10$，$n,m\leq 5$；

Subtask $2$（$20\%$）：满足 $T \leq 10$，$n,m\leq 1\times 10^3$；

Subtask $3$（$30\%$）：满足 $T\leq 10$，$n,m\leq 5\times 10^5$;


Subtask $4$（$40\%$）：无特殊限制。

对于 $100\%$ 的数据，满足 $1\le T \le 2\times10^6$，$1\le n,m\le 5\times 10^{18}$。

**本题输入量较大，建议采用较为快速的读入方式并注意常数因子对程序效率带来的影响。**



------------
 0-1 Trie 是一种特殊的 Trie ，只有 $\mathbf{0,1}$ 两种字符。
 
 如果你不了解 Trie，可以查看：[OI Wiki--Trie](https://deploy-preview-980--oi-wiki.netlify.app/string/trie/)。

## 样例 #1

### 输入

```
1
2 4```

### 输出

```
15```

## 样例 #2

### 输入

```
2
3 5
114514 1919810```

### 输出

```
4487351
```

## 样例 #3

### 输入

```
5
78 122
1000000 1000001
74859432 942432534
555555555 77777777 
6666666666 8888888888```

### 输出

```
12287990```

# AI分析结果



---

## 算法分类
组合数学、Lucas定理

---

## 题解思路与解决难点

### 核心思路
1. **问题转化**：将1与0的排列问题转化为组合问题。每个1必须前接0，形成"01"块，剩余0自由插入。
2. **递推关系**：建立递推式 `F(n,m) = F(n-1,m) + F(n,m-1) + 2`，表示分情况插入"01"块或0。
3. **组合恒等式**：通过生成函数或数学归纳，将递推式转换为组合数表达式：`2*C(n+m+1,n) - C(n+m-1,n) - 2`。
4. **大数处理**：使用Lucas定理计算超大组合数取模。

### 关键难点
1. **递推式推导**：需理解Trie树的结构特征，抽象出递推关系。
2. **组合数转化**：需熟练运用组合恒等式（如范德蒙德卷积）将递推式转换为封闭形式。
3. **模数处理**：对5e18级别的参数，需递归应用Lucas定理分解计算。

---

## 最优题解（4星及以上）

### 题解1：yyandy（5星）
**亮点**：  
- 通过递推式直接推导出组合公式  
- 完整数学证明过程  
- 代码简洁高效，预处理阶乘逆元

**核心代码**：
```cpp
int Lucas(ll n,ll m) {
    int ans=1;
    for(;m;n/=MOD,m/=MOD)
        ans = ans * C(n%MOD,m%MOD) % MOD;
    return ans;
}
```

### 题解2：dengyaotriangle（4星）
**亮点**：  
- 生成函数方法推导  
- 详细数学变换过程  
- 边界条件处理清晰

**核心公式**：  
`f(n,m) = 2*C(m+1,n) - C(m-1,n) - 2`

### 题解3：Mivik（4星）
**亮点**：  
- LCP容斥计数思路  
- 创新的分叉点分析方法  
- 详细系数推导过程

---

## 最优技巧提炼

1. **组合数转化技巧**：  
   ``` 
   递推式 → 组合数求和 → 上指标求和 → 封闭式
   ```

2. **Lucas优化**：  
   - 预处理阶乘和逆元数组  
   - 递归分解大数计算  
   - 模数特性利用（质数性质）

3. **边界处理公式**：  
   `n > m时无解`  
   `n=1时直接返回m+2`

---

## 相似题目推荐

1. **P1494 [国家集训队] 小Z的袜子**  
   （组合数概率计算）

2. **P3807 【模板】卢卡斯定理**  
   （大组合数取模练习）

3. **P2606 [ZJOI2010]排列计数**  
   （递推式转组合数）

---

## 可视化设计（像素风格）

### 动画元素
- **Trie构建**：  
  以8位像素风格展示字符串插入Trie过程，每次插入时：
  - 新节点显示为绿色方块  
  - 已存在节点显示为黄色闪烁  
  - 背景播放"咔嗒"音效

- **组合数计算**：  
  用动态网格展示Lucas分解过程：
  ```text
  C(114514,1919) 
  → C(114514%MOD, 1919%MOD) * C(114514/MOD,1919/MOD)
  ```

### 交互功能
- **速度控制**：滑块调节动画速度（0.5x~3x）  
- **单步执行**：按空格键逐帧查看组合数分解  
- **音效开关**：可关闭/开启8位音效

### 代码片段（Canvas绘制）
```javascript
// 绘制Trie节点
function drawNode(x, y, isNew) {
    ctx.fillStyle = isNew ? '#00FF00' : '#FFFF00';
    ctx.fillRect(x*30, y*30, 25, 25);
    if(isNew) playSound('blip');
}

// 8位音效
function playSound(type) {
    const osc = audioCtx.createOscillator();
    osc.frequency.value = type === 'blip' ? 440 : 880;
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(0.1);
}
```

---

## 核心算法实现

```cpp
const int MOD = 18888913;
int fac[MOD], inv[MOD];

void init() {
    fac[0] = 1;
    for(int i=1; i<MOD; i++) 
        fac[i] = 1LL*fac[i-1]*i % MOD;
    inv[MOD-1] = MOD-1; // (p-1)! ≡ -1 mod p
    for(int i=MOD-2; i>=0; i--)
        inv[i] = 1LL*inv[i+1]*(i+1) % MOD;
}

int C(ll n, ll m) {
    if(m > n) return 0;
    if(n < MOD) return 1LL*fac[n]*inv[m]%MOD * inv[n-m]%MOD;
    return 1LL*C(n/MOD, m/MOD) * C(n%MOD, m%MOD) % MOD;
}

int solve(ll n, ll m) {
    if(n > m) return 0;
    int a = Lucas(m+1, n);
    int b = Lucas(m-1, n);
    return (2LL*a - b - 2 + 2*MOD) % MOD;
}
```

---

## 个人心得

**调试经验**：  
- 注意`n > m`时的特判，否则会计算非法组合数  
- Lucas递归时需判断`m == 0`的边界条件  
- 预处理阶乘数组要覆盖整个模数范围

**优化技巧**：  
- 利用`(p-1)! ≡ -1 mod p`快速计算逆元  
- 预处理时逆元数组倒序计算更高效

**思维突破**：  
- 将Trie节点计数转化为组合数问题需要跳出常规树结构思维  
- 发现递推式中的+2项可分离处理是关键突破口

---
处理用时：75.77秒
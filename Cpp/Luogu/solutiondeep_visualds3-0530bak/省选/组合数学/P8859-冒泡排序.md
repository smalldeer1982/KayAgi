# 题目信息

# 冒泡排序

## 题目描述

有一个值域下标均为 $1\sim n$ 的排列或圆排列 $A$，定义 $f(A)$ 为将 $A$ 升序排序所需的最小操作次数。

每次操作中，你可以选择一个元素并向前**冒泡**若干次，一次**冒泡**定义为：若这个元素小于前一个元素，则可以交换它与前一个元素。当某次无法**冒泡**时，这次操作立即停止。否则可以连续**冒泡**任意次。

比如有排列 $[3,5,2,1,4]$，一次操作可以选择元素 $1$ ，得到排列 $[3,5,1,2,4],[3,1,5,2,4]$ 或 $[1,3,5,2,4]$ 。

若有圆排列 $[2,1,4,3]$，选择元素 $1$ 后可以得到圆排列 $[1,2,4,3],[3,2,4,1]$ 或 $[3,2,1,4]$ 。注意到圆排列中第 $1$ 个元素的前一个元素为第 $n$ 个元素。

排列或圆排列被升序排序，当且仅当对于所有 $\space 2 \leq i \leq n$，元素 $i$ 的前一个元素为元素 $i-1$。

给定 $n,k,type$，你需要：
- 在 $type=1$ 时求有多少长为 $n$ 的排列 $A$ 满足 $f(A)=k$ 。
- 在 $type=2$ 时求有多少长为 $n$ 的圆排列 $A$ 满足 $f(A)=k$ 。

答案对 $10^9+7$ 取模。

## 说明/提示

#### 【样例解释 #1】

有如下合法排列：

1. $[1,4,2,3]$
2. $[1,4,3,2]$
3. $[2,1,4,3]$
4. $[2,4,1,3]$
5. $[2,4,3,1]$
6. $[3,1,2,4]$
7. $[3,1,4,2]$
8. $[3,2,1,4]$
9. $[3,2,4,1]$
10. $[3,4,1,2]$
11. $[3,4,2,1]$

#### 【样例解释 #2】

有如下合法圆排列：

1. $[1,2,5,3,4]$
2. $[1,2,5,4,3]$
3. $[1,3,2,5,4]$
4. $[1,3,5,2,4]$
5. $[1,3,5,4,2]$
6. $[1,4,2,3,5]$
7. $[1,4,2,5,3]$
8. $[1,4,3,2,5]$
9. $[1,4,3,5,2]$
10. $[1,4,5,3,2]$
11. $[1,5,2,4,3]$
12. $[1,5,3,2,4]$
13. $[1,5,3,4,2]$
14. $[1,5,4,2,3]$

需要注意的是，我们认为 $[1,2,5,3,4]$ 和 $[2,5,3,4,1]$ 等是同一个圆排列。

也就是我们认为两个圆排列不同，当且仅当存在一个 $2 \leq i \leq n$，满足两个圆排列中元素 $i$ 的前一个元素不同。

#### 【数据范围】

|   测试点编号 | $n \leq$ | $k \leq$ | $type=$ |
|:------------:|:--------:|:--------:|:-------:|
|  $1 \sim 2$  |    $7$   |    $7$   |   $1$   |
|  $3 \sim 4$  |    $7$   |    $7$   |   $2$   |
|  $5 \sim 6$  |   $15$   |   $15$   |   $1$   |
|  $7 \sim 8$  |   $15$   |   $15$   |   $2$   |
|  $9 \sim 12$ |   $50$   |   $50$   |   $1$   |
| $13 \sim 16$ |   $50$   |   $50$   |   $2$   |
|     $17$     |   $500$  |    $10$   |   $1$   |
|     $18$     |   $500$  |    $10$   |   $2$   |
|     $19$     |   $500$  |   $500$  |   $1$   |
|     $20$     |   $500$  |   $500$  |   $2$   |

对于所有数据，$1 \leq k < n \leq 500$，$1 \leq type \leq 2$。  

## 样例 #1

### 输入

```
4 2 1```

### 输出

```
11```

## 样例 #2

### 输入

```
5 2 2```

### 输出

```
14```

## 样例 #3

### 输入

```
50 10 1```

### 输出

```
808620624```

## 样例 #4

### 输入

```
50 10 2```

### 输出

```
578144115```

# AI分析结果



**唯一算法分类**：动态规划、组合数学

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
- **type=1（排列）**：  
  每个元素是否需要操作取决于其是否为前缀最大值。答案等价于统计前缀最大值数目为 `n-k` 的排列数，对应**第一类斯特林数**。递推式：  
  `f[i][j] = f[i-1][j-1] + (i-1)*f[i-1][j]`  
- **type=2（圆排列）**：  
  通过固定最大值位置转化为排列问题，所有循环移位后的排列的最小操作次数对应笛卡尔树左链最大深度。DP状态 `g[i][j]` 表示 `i` 个节点的树中最大左链深度为 `j`，通过前缀和优化转移。

#### **解决难点**
- **圆排列的循环特性**：需考虑所有可能的断环方式，转化为笛卡尔树结构分析。
- **高效DP转移**：通过前缀和优化将复杂度从 `O(n^4)` 降至 `O(n^3)`。

---

### **题解评分 (≥4星)**
1. **绝顶我为峰 (5星)**  
   - 思路清晰，代码简洁，直接关联斯特林数与笛卡尔树模型。
   - 前缀和优化显著提升效率。
   - 代码可读性强，注释详细。

2. **OtoriEmu (4.5星)**  
   - 详细推导斯特林数与DP关系，笛卡尔树分析直观。
   - 代码实现稍复杂但逻辑明确。

3. **simonG (4星)**  
   - 笛卡尔树模型分析到位，代码精简。
   - 缺乏详细注释但核心逻辑清晰。

---

### **最优思路提炼**
1. **type=1的斯特林数递推**：从大到小插入元素，统计前缀最大值。
2. **type=2的笛卡尔树DP**：左链深度决定操作次数，前缀和优化合并子树贡献。

---

### **同类型题与算法套路**
- **排列计数**：利用斯特林数或组合递推。
- **树形结构DP**：通过子树合并优化复杂度。

---

### **推荐题目**
1. P4609 [FJOI2016] 建筑师（斯特林数应用）
2. P5824 十二重计数法（组合计数综合）
3. P2150 [NOI2015] 寿司晚宴（树形结构优化）

---

### **代码片段**
**type=1 (绝顶我为峰)**
```cpp
// 核心递推
f[1][0] = 1;
for (int i=2; i<=n; ++i)
    for (int j=1; j<i; ++j)
        f[i][j] = (f[i-1][j] + (i-1)*f[i-1][j-1]) % mod;
```

**type=2 (前缀和优化)**
```cpp
// 前缀和辅助转移
sum[1][i] = 1;
for (int i=2; i<=n; ++i) {
    for (int j=2; j<=n; ++j) {
        for (int k=1; k<i; ++k) {
            g[i][j] = (g[i][j] + C(...)) % mod; // 组合数分配子树
        }
    }
    sum[i][j] = (sum[i][j-1] + g[i][j]) % mod;
}
```

---

### **可视化设计**
1. **动画演示**  
   - **排列插入**：高亮当前插入元素，显示其是否成为前缀最大值。
   - **笛卡尔树构建**：动态绘制树结构，标红左链路径。

2. **复古像素风格**  
   - **8-bit网格**：用16色块表示数组元素，冒泡时元素向左滑动。
   - **音效触发**：插入时播放“点击”音效，成功排序后播放胜利音效。

3. **交互控制**  
   - **步进/暂停**：观察每步插入或子树合并。
   - **自动模式**：AI按最优策略插入元素或构建树。

---

**总结**：通过斯特林数和笛卡尔树模型将复杂问题转化为高效DP，结合前缀和优化显著提升性能。可视化可直观展示插入与树构建过程。

---
处理用时：58.41秒
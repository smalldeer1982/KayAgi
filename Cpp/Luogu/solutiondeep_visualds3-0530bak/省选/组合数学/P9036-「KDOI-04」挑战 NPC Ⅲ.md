# 题目信息

# 「KDOI-04」挑战 NPC Ⅲ

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/zn5t5x28.png)

## 题目描述

小 S 有一个伟大的梦想：证明 $\text{P}=\text{NP}$。

有一天，他得知一般图最大独立集是 NPC 问题后，决定解决他。

当然小 S 太菜了，解决不了，于是求助于你：

> 给出一个含有 $n$ 个顶点，$m$ 条边的无向图 $G$，求 $G$ 中大小恰好为 $n-k$ 的独立集的数量。由于答案可能很大，请将其对 $998~244~353$ 取模。

小 S 不喜欢多测，因为他在 NOIp 中因为多测挂分，所以本题包含多组测试数据。

## 说明/提示

**【样例解释】**

对于第 $1,2$ 组测试数据，图是完全图，容易发现，完全图的最大独立集为 $1$，并且每一个顶点都单独构成一个独立集。因此第 $1$ 组测试数据的答案为 $0$，第 $2$ 组测试数据的答案为 $4$。

对于第 $3$ 组测试数据，该组数据中给出的无向图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/abt8ho3b.png)

其中，所有大小为 $3$ 的独立集为：

+ $\{2,4,8\}$；
+ $\{2,3,7\}$；
+ $\{3,4,6\}$；
+ $\{2,4,6\}$；
+ $\{1,4,6\}$；
+ $\{2,3,6\}$；
+ $\{1,4,5\}$；
+ $\{2,3,4\}$。

**【数据范围】**

**本题采用捆绑测试。**

![数据范围](https://cdn.luogu.com.cn/upload/image_hosting/p3jwdqp3.png)

对于 $100\%$ 的数据，保证 $1\leq n\leq10^5$，$0\le m\le 10^5$，$0\leq k\leq \min(n-1,18)$，$1\leq T\leq 10^{4}$，$\sum n,\sum m\leq10^6$。

并且对于每个测试点保证：

设 $K=\max k$，即该测试点中所有 $k$ 的最大值，

+ 若 $K\ge 17$，则 $T=1$；
+ 若 $K\ge 15$，则 $T\le 3$；
+ 若 $K\ge 10$，则 $T\le 5$；
+ 若 $K\ge 5$，则 $T\le 300$。


## 样例 #1

### 输入

```
3
4 6 1
1 2
1 3
1 4
2 3
2 4
3 4
4 6 3
1 2
1 3
1 4
2 3
2 4
3 4
8 13 5
1 2
7 8
1 3 
2 5
3 8
6 8
4 7
5 6
5 7
5 8
6 7
1 8
3 5```

### 输出

```
0
4
8```

# AI分析结果



## 算法分类
**搜索+剪枝**

---

## 题解思路与核心难点

### 关键思路
1. **问题转化**：将大小为 \(n-k\) 的独立集转化为大小为 \(k\) 的点覆盖集。
2. **必选点处理**：度数大于 \(k\) 的点必须被选入点覆盖集，否则无法覆盖所有边。
3. **剪枝优化**：预处理后剩余边数不超过 \(k^2\)，用状态标记（选/不选/未定）避免重复计算。
4. **组合数统计**：搜索结束后，剩余可选点用组合数 \(\binom{\text{可选点数}}{k - \text{已选点数}}\) 统计答案。

### 解决难点
- **避免重复计算**：通过状态标记（如 `ban` 数组）确保每个点的选择状态唯一。
- **高效剪枝**：动态选择度数最大的点或未覆盖边，减少无效搜索路径。
- **重边处理**：用 `set` 或 `map` 去重，保证度数计算正确。

---

## 题解评分 (≥4星)

### 1. Alex_Wei (⭐⭐⭐⭐⭐)
- **亮点**：状态标记清晰，预处理必选点后直接搜索，代码结构简洁高效。
- **核心代码**：
  ```cpp
  void dfs(int rest, int cur) {
    if(cur > k) return;
    int e = -1;
    // 找未覆盖边...
    if(e == -1) { ans = (ans + bin(rest, k - cur)) % mod; return; }
    // 状态转移...
  }
  ```

### 2. _Diu_ (⭐⭐⭐⭐)
- **亮点**：动态维护度数最大点，用 `set` 优化剪枝，思路新颖。
- **核心代码**：
  ```cpp
  void dfs(int x, int num) {
    if(s.empty() || s.begin()->first == 0) { ans += C[num][x]; return; }
    // 删点、递归、回溯...
  }
  ```

### 3. Jorisy (⭐⭐⭐⭐)
- **亮点**：枚举边状态分三种情况，维护可选点数避免遍历全图。
- **核心代码**：
  ```cpp
  void solve(int csn) {
    // 枚举边状态...
    if(id == -1) { ans += c[ind][k - csn]; return; }
    // 处理三种状态...
  }
  ```

---

## 最优技巧提炼
1. **必选点预处理**：快速筛选度数超限的点，大幅减少搜索规模。
2. **状态标记法**：用 `0/1/2` 标记点状态（未定/选中/不选），避免重复计算。
3. **组合数优化**：预处理组合数 \(\binom{n}{k}\)，搜索结束时直接查表统计答案。

---

## 类似题目与算法
- **同类型题**：Pxxx（最大独立集计数）、Pyyy（点覆盖搜索）。
- **通用套路**：小规模爆搜 + 组合数学统计，适用于图论问题中 \(k\) 较小的场景。

---

## 推荐题目
1. **Pxxxx**：求图的最小点覆盖数（\(k \leq 15\)）。
2. **Pyyyy**：带权独立集的计数问题。
3. **Pzzzz**：动态图中剪枝搜索最大匹配。

---

## 可视化设计
### 核心算法演示
- **动画方案**：  
  - **步骤1**：红色高亮必选点（度数>\(k\)），删除其连边。  
  - **步骤2**：蓝色标记剩余边，按搜索顺序处理，绿色表示选中点，灰色表示不选。  
  - **步骤3**：统计时黄色高亮剩余可选点，显示组合数计算过程。

- **复古像素风格**：  
  - **Canvas 网格**：用 16x16 像素块表示点，边为连线。  
  - **音效**：选中点播放“哔”声，统计答案时播放胜利音效。  
  - **自动演示**：按预设路径自动选择边，展示搜索树生成过程。

---

## 代码片段（核心逻辑）
```cpp
// Alex_Wei 的搜索函数（简化）
void dfs(int rest, int cur) {
  if(cur > k) return;
  int e = find_uncovered_edge();
  if(e == -1) { ans += comb(rest, k - cur); return; }
  int u = u_of(e), v = v_of(e);
  if(ban[u] == 0 && ban[v] == 0) {
    // 分支1: 选u和v
    ban[u] = ban[v] = 1;
    dfs(rest-2, cur+2);
    // 分支2: 选u不选v
    ban[v] = 2;
    dfs(rest-2, cur+1);
    // 分支3: 选v不选u 
    ban[u] = 2, ban[v] = 1;
    dfs(rest-2, cur+1);
    // 回溯
    ban[u] = ban[v] = 0;
  }
}
```

---

## 个人心得摘录
> "月赛快结束的时候听同学说这题很难不会... 发现是道小清新题，关键在于将问题转化为点覆盖并利用 \(k\) 小的特点爆搜。" —— _Diu_  
> **总结**：转化问题比直接暴力更重要，小数据范围暗示剪枝可行性。

---
处理用时：69.76秒
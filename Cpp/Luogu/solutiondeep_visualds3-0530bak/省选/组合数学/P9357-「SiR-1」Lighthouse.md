# 题目信息

# 「SiR-1」Lighthouse

## 题目描述

给定一棵 $n$ 个点的树，每个点有权值 $w_i$，初始为 $0$。初始得分 $s=0$。

进行 $m$ 次操作，每次操作选择一个点 $u$，给 $s$ 增加 $u$ 所在的同点权连通块的大小（即，假设只保留点权等于 $w_u$ 的点，和连接两个点权等于 $w_u$ 的点的边，对得分的贡献就是此时 $u$ 所在的连通块大小。注意这不会真的删去一部分树上的点和边），然后给 $w_u$ 增加 $1$。

请对所有 $n^m$ 种操作方式，求它们的得分 $s$ 之和，对 $10^9+7$ 取模。

## 说明/提示

对于所有数据，满足 $1\leq n\leq 1000$，$1\leq m\leq 10^5$，$1\leq u,v\leq n$，保证输入是一棵树。

- Subtask 0（5 pts）：$n,m\le 7$。
- Subtask 1（20 pts）：$n,m\le 10$。
- Subtask 2（15 pts）：$n,m\le 50$。
- Subtask 3（15 pts）：$n,m\le 100$。
- Subtask 4（15 pts）：$n\le 50$。
- Subtask 5（15 pts）：树是一条链。
- Subtask 6（15 pts）：无特殊限制。

本题同时开启子任务依赖。具体地：

+ 对于子任务 $i(i \in [1, 3])$，依赖于子任务 $0 \sim (i -  1)$；
+ 对于子任务 $4$，依赖于子任务 $0 \sim 2$；
+ 对于子任务 $6$，依赖于子任务 $0 \sim 5$。

## 样例 #1

### 输入

```
3 2
1 3
2 3```

### 输出

```
40```

# AI分析结果



**唯一算法分类**：组合数学与树结构分析

---

### **综合分析与结论**

**题目核心**：  
计算所有操作序列的总得分，转化为统计每个点对在不同权值阶段的连通贡献，利用组合数学与树结构分析高效求和。

**核心难点**：  
1. **贡献拆分**：将总得分拆分为各点对在不同权值阶段的贡献，避免枚举所有操作序列。  
2. **路径长度依赖**：点对的贡献仅与路径长度有关，需统计所有路径长度的出现次数。  
3. **组合优化**：快速计算复杂组合式，如阶乘、逆元、高次幂等，需预处理和递推优化。

**解决方案**：  
- **期望转换**：将总得分视为期望乘以方案数，利用线性性拆分贡献。  
- **路径统计**：预处理所有点对的路径长度，统计各长度的出现次数。  
- **组合预处理**：阶乘、逆元、组合数预处理，后缀和优化求和式。  

**可视化设计**：  
- **树结构展示**：用Canvas绘制树，动态高亮不同路径长度。  
- **贡献计算动画**：分步显示路径长度统计、阶乘计算、后缀和累加。  
- **复古像素风**：8位风格节点与路径，音效提示关键步骤（如路径统计完成、组合式计算）。  

---

### **题解清单 (≥4星)**

1. **E.Space（5星）**  
   - **亮点**：期望转换、路径长度统计、后缀和优化。  
   - **关键推导**：将概率拆解为路径操作次数与均匀分布条件，数学严谨。  
   - **代码实践**：预处理阶乘逆元、路径统计、分d处理贡献，高效清晰。

2. **Sol1（4星）**  
   - **亮点**：操作序列拆分为(u,j)事件，枚举贡献条件。  
   - **优化**：递推组合式后缀和，减少重复计算。  

3. **EnofTaiPeople（4星）**  
   - **亮点**：点对贡献的路径长度统一处理，暴力预处理优化。  

---

### **最优思路提炼**

1. **贡献拆分与期望**：  
   将总得分转化为每个点对的独立贡献，利用期望的线性性简化计算。

2. **路径长度统计**：  
   所有点对的路径长度d通过LCA快速计算，统计次数c_d，避免逐个枚举。

3. **组合式优化**：  
   - 预处理阶乘、逆元、组合数，O(1)查询。  
   - 后缀和数组优化求和，时间复杂度从O(m²)降至O(m)。

---

### **类似题目推荐**

1. **P3978 [TJOI2015] 概率论**：树结构的组合计数与期望分析。  
2. **P4213 道路计数**：路径贡献统计与组合数学优化。  
3. **P2633 Count on a tree**：树路径统计与高效预处理结合。  

---

### **代码实现关键**

**预处理阶乘与逆元**：  
```cpp
Jc[0] = 1;
InvJc[0] = 1;
for(int i=1; i<=MAXN; i++){
    Jc[i] = Jc[i-1] * i % P;
    InvJc[i] = power(Jc[i], P-2);
}
```

**路径长度统计（LCA）**：  
```cpp
int dis(int x, int y) {
    int lca = LCA(x, y);
    return dep[x] + dep[y] - 2 * dep[lca] + 1; //点数=边数+1
}
```

**后缀和优化贡献计算**：  
```cpp
for(int i=m; i>=0; i--){
    Suf[i] = (Suf[i+1] + Co[i] * D % P) % P;
    D = D * Fuck % P; // Fuck = (n-d)/d
}
```

---

### **可视化与复古游戏化设计**

1. **树结构绘制**：  
   - **Canvas网格**：节点用像素方块表示，路径用连线高亮。  
   - **动态颜色**：当前处理路径用闪烁效果，音效提示统计完成。

2. **贡献计算动画**：  
   - **步进显示**：分步展示d的统计、w的枚举、后缀和累加。  
   - **8位音效**：关键步骤（如阶乘计算）触发复古音效。

3. **自动演示模式**：  
   - **AI自动播放**：按d从小到大自动处理，积分奖励完成关卡。  
   - **连击积分**：快速处理多个d时获得连击加分，增强趣味性。  

---

**总结**：通过数学转换与高效预处理，将复杂问题转化为可计算的组合式，树结构分析结合路径统计，代码实现兼顾效率与可读性。

---
处理用时：115.79秒
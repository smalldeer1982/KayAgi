# 题目信息

# [NOIP 2006 普及组] 明明的随机数

## 题目描述

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 $N$ 个 $1$ 到 $1000$ 之间的随机整数 $(N\leq100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。


## 说明/提示

NOIP 2006 普及组 第一题


## 样例 #1

### 输入

```
10
20 40 32 67 40 20 89 300 400 15
```

### 输出

```
8
15 20 32 40 67 89 300 400
```

# AI分析结果



## 算法分类
**桶排序**

---

## 题解思路与核心难点
### 核心逻辑
所有题解围绕「去重+排序」展开，核心差异在于数据结构的选用：
1. **桶排序**：利用值域1-1000的特点，用布尔数组标记出现过的数字，遍历桶即有序且去重
2. **排序后去重**：先标准排序，再遍历相邻元素消重，需注意连续重复元素的处理
3. **STL容器**：set自动去重排序，unique函数配合sort实现原地去重

### 解决难点
- **去重与排序的同步性**：桶排序天然满足，其他方法需分步处理
- **空间效率**：桶排序需要1001长度的数组，但本题范围可接受
- **时间复杂度**：桶排序O(n+1000)最优，排序法O(n log n)次之

---

## 题解评分 (≥4星)
1. **qr小盆友（5星）**  
   桶排序经典实现，思路清晰且附带示意图，变量命名直观（book数组标记存在性）  
   核心亮点：用final变量统计总数时同步处理去重，循环输出时天然有序

2. **mcturtle（5星）**  
   使用set容器自动去重排序，代码极简（仅10行核心代码）  
   亮点：利用STL特性省去显式排序步骤，迭代器遍历输出规范高效

3. **qhr2023（4星）**  
   桶排序极致简化版，用三目运算符实现去重统计  
   亮点：sum+=(!b[x]) 实现一行代码完成存在性判断与计数

---

## 最优思路与技巧
### 桶排序优化技巧
```cpp
bool book[1001] = {0}; // 标记数组
int final = 0;
for (int i=0; i<n; i++) {
    if (!book[a[i]]) final++; // 首次出现则计数
    book[a[i]] = 1;           // 标记存在
}
// 输出时遍历1-1000，book[i]为1则输出
```
**核心优势**：  
- 去重与排序在一次遍历中完成  
- 天然升序输出无需额外排序  
- 时间复杂度O(n+m)（m为值域）

### STL应用技巧
```cpp
set<int> s;
s.insert(x); // 自动去重排序
cout << s.size() << endl;
for (auto it : s) cout << it << " "; // 遍历即有序
```
**适用场景**：值域较大但数据量较小的情况（如n≤1e5且值域≤1e9）

---

## 同类型题与算法套路
1. **统计频次**：如[P2550 彩票摇奖](https://www.luogu.com.cn/problem/P2550)  
2. **去重处理**：如[P1308 统计单词数](https://www.luogu.com.cn/problem/P1308)（需处理连续重复）  
3. **小范围排序**：如[P1177 快速排序](https://www.luogu.com.cn/problem/P1177)（当值域较小时可用桶排优化）

---

## 推荐练习题
1. P1177 【模板】快速排序  
   （练习基础排序算法）  
2. P1781 宇宙总统  
   （大数排序+去重思想）  
3. P1051 谁拿了最多奖学金  
   （结构体排序+频次统计）

---

## 个人心得摘录
- **qr小盆友**：图示桶排序原理，强调"标记前判定首次出现"的同步计数技巧  
- **2023z**：指出错误代码中将重复元素置零会导致后续判断错误，强调必须保持原数组完整  
- **jscaj0921**：提出排序后通过比较前驱元素实现去重，避免修改原数组

---

## 算法可视化设计
### 桶排序动画方案
1. **初始化界面**  
   - 顶部显示输入数列（如20,40,32,67,40...）  
   - 中间区域绘制1001个桶（简化为1-1000数字标签+圆形状态灯）  
   - 底部显示输出队列

2. **关键帧演示**  
   | 步骤 | 操作 | 视觉效果 |
   |---|---|--|
   | 输入数字 | 高亮当前数字，对应桶状态灯变绿 | 数字飞入桶上方后消失 |
   | 重复检测 | 若桶已亮，显示"已存在"提示 | 桶闪烁红色边框 |
   | 统计总数 | 遍历亮灯桶，计数器同步增加 | 亮灯桶下方显示累计数 |
   | 结果输出 | 从左到右扫描亮灯桶，数字依次移到底部 | 输出区数字按序排列 |

3. **复古风格实现**  
   ```javascript
   // 伪代码示例
   class Bucket {
     constructor(x, y) {
       this.value = i;
       this.lit = false; // 是否点亮
       this.draw = () => {
         ctx.fillStyle = this.lit ? "#8BFF32" : "#4A4A4A";
         drawPixelCircle(x, y, 8); // 8位风格圆点
       }
     }
   }
   // 音效触发
   function playSFX(type) {
     if(type === "hit") beep(523, 0.1); // 高音提示有效操作
     if(type === "dup") beep(220, 0.3); // 低音提示重复
   }
   ```

---

## 核心代码实现
### 桶排序标准版
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    bool book[1001] = {0};
    int n, final = 0; cin >> n;
    for (int i=0, x; i<n; i++) {
        cin >> x;
        if (!book[x]) final++;
        book[x] = 1;
    }
    cout << final << endl;
    for (int i=1; i<=1000; i++)
        if (book[i]) cout << i << " ";
    return 0;
}
```

### 像素动画JS片段
```javascript
// Canvas绘制桶状态
function drawBuckets() {
  ctx.clearRect(0, 0, W, H);
  buckets.forEach((bucket, i) => {
    ctx.fillStyle = bucket.lit ? "#00FF00" : "#333";
    ctx.fillRect(i*12 + 50, 100, 10, 10); // 每个桶占12像素宽
  });
}
// 输入数字时的动画
function animateInput(num) {
  let x = num*12 + 50;
  anime({ targets: num, x: [W/2, x], update: () => draw() });
}
```

---
处理用时：141.89秒
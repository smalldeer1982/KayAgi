# 题目信息

# [USACO1.1] 坏掉的项链 Broken Necklace

## 题目描述

你有一条由 $n$ 个红色的，白色的，或蓝色的珠子组成的项链，珠子是随意安排的。 这里是 $n=29$ 的两个例子:

![](https://cdn.luogu.com.cn/upload/image_hosting/i7imvc0g.png) 

第一和第二个珠子在图片中已经被作记号。

图片 A 中的项链可以用下面的字符串表示：

`brbrrrbbbrrrrrbrrbbrbbbbrrrrb`

假如你要在一些点打破项链，展开成一条直线，然后从一端开始收集同颜色的珠子直到你遇到一个不同的颜色珠子，在另一端做同样的事(颜色可能与在这之前收集的不同)。 确定应该在哪里打破项链来收集到最大数目的珠子。

例如，在图片 A 中的项链中，在珠子 $9$ 和珠子 $10$ 或珠子 $24$ 和珠子 $25$ 之间打断项链可以收集到 $8$ 个珠子。

白色珠子什么意思?

在一些项链中还包括白色的珠子(如图片B) 所示。

当收集珠子的时候，一个被遇到的白色珠子可以被当做红色也可以被当做蓝色。

表现含有白珠项链的字符串将会包括三个符号 `r`，`b`，`w` 。

写一个程序来确定从一条被给出的项链可以收集到的珠子最大数目。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$3\le n \le 350$

题目翻译来自NOCOW。

USACO Training Section 1.1

## 样例 #1

### 输入

```
29 
wwwbbrwrbrbrrbrbrwrwwrbwrwrrb
```

### 输出

```
11```

# AI分析结果



---

## 唯一算法分类  
**环形结构处理 + 枚举**

---

## 综合分析与结论  
本题核心在于将环形结构转化为线性处理，并通过枚举断点计算左右最大连续收集数。主要难点在于：  
1. **环形结构处理**：通过复制字符串形成三倍长度（w_y_c）或两倍长度（田阙西）来消除环形特性  
2. **白色珠子动态决策**：遇到白色珠子时需考虑其作为红/蓝两种可能性（w_y_c）或通过预处理左右连续值（青衫白叙）  
3. **高效计算**：部分题解通过动态规划预处理左右最大连续值实现O(n)时间复杂度  

**可视化设计要点**：  
- **环形展开动画**：用Canvas绘制环形项链，点击断点时展开为线性结构并高亮当前断点  
- **双指针扫描**：用红蓝箭头表示左右扫描指针，动态显示收集范围  
- **白色决策提示**：当扫描到白色珠子时弹出红/蓝选项按钮，展示两种可能性下的收集范围  
- **实时统计面板**：显示当前断点位置、左右收集数、历史最大值  

---

## 题解清单 (≥4星)

### 1. 作者：w_y_c（★★★★☆）  
**亮点**：  
- 三倍字符串巧妙处理环形结构  
- 对白色珠子进行红/蓝双重尝试  
- 代码清晰注释完整  
```cpp
a = a + a + a;  // 关键环形处理
for(int i = n; i < 2*n; i++){  // 仅需遍历中间段
    if(a[i] == 'w'){
        a[i] = 'r'; ans = max(ans,f(i));  // 白珠双重尝试
        a[i] = 'b'; ans = max(ans,f(i));
    }
}
```

### 2. 作者：青衫白叙（★★★★☆）  
**亮点**：  
- O(n)时间复杂度单次扫描  
- 动态维护左右段长度和白色计数  
- 代码极简但思维巧妙  
```cpp
for(int i=0;i<n<<1;i++){
    if(s[i]=='w') b++,w++;
    else if(s[i]==c) b++,w=0;
    else ans=max(ans,a+b),a=b-w,b=w+1,w=0,c=s[i];
}
```

### 3. 作者：田阙西（★★★★☆）  
**亮点**：  
- 动态规划预处理左右连续值  
- 分离红蓝状态避免决策冲突  
- 结构清晰易扩展  
```cpp
// 预处理左连续
for(int i=1;i<=2*n;i++){
    if(c[i]=='w') lR[i]=lR[i-1]+1, lB[i]=lB[i-1]+1;
    else if(c[i]=='r') lR[i]=lR[i-1]+1;
    else lB[i]=lB[i-1]+1;
}
// 计算答案
ans = max(ans, max(lR[i],lB[i]) + max(rR[i+1],rB[i+1]));
```

---

## 最优思路提炼  
1. **环形转线性**：通过字符串复制将环形遍历转为线性问题  
2. **双策略处理白色**：遇到起始白色时分别尝试红/蓝两种可能  
3. **动态维护连续值**：扫描过程中维护左右段长度和白色计数  
4. **预处理优化**：通过DP预处理左右连续值减少重复计算  

---

## 类似题目推荐  
1. **P1886 滑动窗口** - 线性区间极值问题  
2. **P1047 校门外的树** - 区间合并与统计  
3. **P1638 逛画展** - 环形窗口滑动技巧  

---

## 可视化算法演示  
**动画设计**：  
1. **初始化阶段**：  
   - 绘制环形彩色珠子（红/蓝/白三色）  
   - 点击"展开"按钮时展开为三倍长度线性结构  

2. **断点扫描阶段**：  
   - 红色竖线标记当前断点位置  
   - 左侧蓝色箭头向左扫描，右侧红色箭头向右扫描  
   - 收集到的珠子用半透明色块覆盖  

3. **白色决策交互**：  
   - 当扫描起始为白色时弹出红/蓝选择按钮  
   - 选择不同颜色后展示对应收集范围差异  

4. **数据面板**：  
   ```text
   当前断点：珠子24-25
   左收集：8（红） | 右收集：3（蓝）
   历史最大值：11
   ```

---

## 个人心得摘录  
> "当遇到起始白珠时，必须尝试两种颜色可能性，否则会漏解。我通过临时修改白珠颜色并还原的方法解决了这个问题" —— w_y_c  
> "维护左右段长度时要注意连续的w可能跨越断点，通过记录w计数实现了无缝衔接" —— 青衫白叙  

---

## 核心代码实现（像素风格版）  
```javascript
// Canvas初始化（8位风格）
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false; // 保持像素化

function drawBead(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*16, y*16, 15, 15); // 16x16像素单位
}

function animateScan(leftPos, rightPos) {
    // 绘制扫描过程
    drawBead(leftPos, 0, '#00FFFF');  // 青色左指针
    drawBead(rightPos, 0, '#FF00FF'); // 品红右指针
    playSound('move'); // 播放8位音效
}
```

---

通过这种结构化的解析，学习者可以快速掌握环形处理的核心技巧，并通过交互式可视化深入理解扫描过程与白色决策机制。

---
处理用时：117.42秒
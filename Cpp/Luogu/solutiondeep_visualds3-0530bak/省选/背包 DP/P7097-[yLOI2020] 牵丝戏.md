# 题目信息

# [yLOI2020] 牵丝戏

## 题目背景

> 风雪依稀秋白发尾， 灯火葳蕤，揉皱你眼眉。  
> 假如你舍一滴泪，假如老去我能陪。  
> 烟波里成灰，也去得完美。 

——银临 & Aki阿杰《牵丝戏》

## 题目描述

扶苏和扶咕咕最近在玩一款叫做「ddt」的游戏，因为玩「ddt」时一直在循环《牵丝戏》，所以想到牵丝戏就想到了这个游戏。

为了简化问题，我们认为这是一款一对一回合制游戏。双方玩家各有一个属性，被称为 delay 值，简称 $d$ 值。$d$ 值会根据回合中玩家使用的道具类型和数量来进行相应的增加。我们定义玩家 $x$ 的回合为玩家 $x$ 从发动攻击到结束的整个过程。**在玩家 $x$ 的回合中，只有玩家 $x$ 可以使用道具和发动攻击，并且玩家 $x$ 一定会发动攻击**。当一个玩家的回合结束以后，下一回合将是两个玩家中 $d$ 值**较小**的玩家的回合。当两个玩家的 $d$ 值相同时，因为扶苏氪金很多，下一回合一定是**扶苏的回合**。

这款游戏共有 $m$ 种道具，第 $i$ 种道具会将本回合的伤害增加**不计算其他道具的原始伤害**的 $\frac{k_i}{10^5}$ 倍，同时会增加 $p_i$ 点 $d$ 值。每回合**每种道具只能使用一次，本回合的道具不会对下回合产生伤害增益效果**。同时，每回合结束以后，发动攻击的玩家一定会增加 $w$ 点 $d$ 值。

而使用道具是受到双方 $d$ 值差限制的。具体的，任何回合所使用的道具应该满足本回合结束以后双方 $d$ 值（包括发动攻击的玩家一定增加的 $w$ 点 $d$ 值）之差的绝对值**不超过** $100$。一个显然的事实是，只要保证了 $w \le 100$，玩家就一定存在一种选择道具的方法（包括不选择），来满足这个限制。

例如，在扶咕咕的回合中，若她的原始伤害 $t=10^5$，初始时 $d$ 值 $d_0=3$，规定 $w=2$，她使用了两个道具，$k_1=114$，$k_2=514$，$p_1=19$，$p_2=81$，那么本回合她造成的伤害为 

$$t + t \times k_1 + t \times k_2 = 10^5 + 114 + 514 =  100628$$

她回合结束后的 $d$ 值为

$$d_0 + w + p_1 + p_2 = 3 + 2 + 19 + 81 = 105$$

而假如下回合还是她的回合，并且她没有使用道具，那么她下回合造成的伤害为 

$$t =  100000$$

她下回合结束后的 $d$ 值为 

$$105 + w = 105 + 2 = 107$$

现在扶苏和扶咕咕正在对战。给定游戏的道具列表，和他们的原始伤害、 $d$ 值。游戏一共会进行 $n$ 回合，不妨认为无论造成多大的伤害，双方都不会死亡。请你最大化「扶苏对扶咕咕造成的伤害 - 扶咕咕对扶苏造成的伤害」这个差的值。

当然，扶咕咕也会尽可能最大化「她对扶苏造成伤害 - 扶苏对她造成伤害」的值。不妨认为扶苏是 yLOI 世界中最聪明的男孩子，扶咕咕是 yLOI 世界中最聪明的女孩子，也就是**他们都会选择最优的策略来使用道具而不会出错**，题目所求即为在这种情况下伤害差的最大值。

## 说明/提示

### 样例 1 解释

- 第一回合开始前，扶苏 $d$ 值为 $2$，扶咕咕 $d$ 值为 $3$，第一回合由扶苏出手。扶苏不使用道具，伤害为 $100000$，$d$ 值增加 $1$，总伤害差为 $100000$。
- 第一回合结束后，双方 $d$ 值均为 $3$，第二回合由扶苏出手。扶苏使用第一个道具，伤害为 $100050$，$d$ 值增加 $21$，总伤害差为 $200050$。
- 第二回合结束后，扶苏 $d$ 值为 $24$，扶咕咕 $d$ 值为 $3$，第三回合由扶咕咕出手。扶咕咕使用 $1$ 、 $2$ 两个道具，伤害为 $200102$，$d$ 值增加 $121$，总伤害差为 $-52$。这回合结束后，双方 $d$ 值差恰好为 $100$，符合要求。

### 数据规模与约定


**本题采用多测试点捆绑测试**。

- 子任务 $1$（$5$ 分）：保证 $n=0$。
- 子任务 $2$（$10$ 分）：保证 $m=0$。
- 子任务 $3$（$15$ 分）：保证 $n,m \le 5$。
- 子任务 $4$（$20$ 分）：保证 $n \le 3$。
- 子任务 $5$（$20$ 分）：保证 $m \le 10$。
- 子任务 $6$（$30$ 分）：无特殊约定。

对于全部的测试点，保证 $0 \le n \le 10^3$，$0 \le m \le 10^5$，$1 \le p_i,w \le 100$，$1 \le x_a,x_b,k_a,d_a,d_b \le 10^9$，$x_a$ 与 $x_b$ 是 $10^5$ 的倍数，$1 \le |d_a-d_b| \le 100$。

### 提示

共有 4 个样例文件，请见附加文件中的 opera.zip。  
对于样例 2，满足 $m = 0$。  
对于样例 3，满足 $n \leq 3$。

## 样例 #1

### 输入

```
0
3 2 1
50 1
20 100
100000 200000 2 3```

### 输出

```
-52```

# AI分析结果



# 算法分类  
**动态规划（博弈DP+背包）**

---

## 题解思路与算法要点  

### 核心问题拆解  
1. **回合内道具选择的最优化**：每个回合使用道具的组合需满足delay差约束，并最大化伤害增益。  
2. **回合间博弈策略**：双方交替行动，需通过动态规划处理最优子决策的叠加。  

### 关键算法步骤  
1. **01背包预处理**：对每个可能的delay增量，计算其对应的最大伤害增益。  
   - 状态定义：`f[j]`表示delay增加j时的最大增益值。  
   - 转移方程：`f[j] = max(f[j], f[j-p_i] + k_i)`。  
2. **博弈DP状态转移**：  
   - 状态定义：`g[i][j]`表示第i回合结束时，双方delay差为j时的最大伤害差。  
   - 转移逻辑：  
     - 若当前回合是扶苏（j ≤ 100），枚举可能增加的delay增量，取最大值。  
     - 若当前回合是扶咕咕（j > 100），枚举可能的delay增量，取最小值。  

### 解决难点  
- **状态压缩**：将delay差映射到[-100, 100]的合法范围，通过偏移量（+100）处理负数下标。  
- **博弈交替决策**：需在同一个DP数组中分别处理双方的最优策略，通过正负号区分目标函数。  

---

## 题解评分  

### 一扶苏一（⭐⭐⭐⭐⭐）  
- **亮点**：代码结构清晰，背包预处理与博弈DP分离，时间复杂度优化到位（O(nt²)）。  
- **关键代码**：通过双循环分别处理扶苏和扶咕咕的决策，逻辑对称且高效。  

### 烟灬（⭐⭐⭐⭐）  
- **亮点**：详细注释与变量命名规范，适合初学者理解。  
- **改进点**：状态转移中`maxd`的边界处理稍显冗余。  

### Cesare（⭐⭐⭐）  
- **亮点**：逆向DP设计，尝试从最后一回合倒推。  
- **不足**：代码可读性较差，部分边界条件未明确处理。  

---

## 最优思路提炼  

### 核心技巧  
1. **背包预处理**：将道具选择转化为固定delay增量的最优解，避免每回合重复计算。  
2. **博弈DP状态设计**：通过正负差值和回合数刻画状态，交替取最大/最小值模拟双方博弈。  

### 思维突破  
- **差值偏移映射**：将delay差j ∈ [-100, 100] 映射到j + 100 ∈ [0, 200]，避免负数下标。  
- **伤害增益分离**：将原始伤害除以1e5，直接与k_i相加，避免浮点运算。  

---

## 同类型题与算法套路  
- **常见组合**：博弈论（minimax） + 背包预处理。  
- **类似题目**：  
  1. 洛谷 P2584（回合制游戏策略）  
  2. 洛谷 P1434（背包+状态压缩DP）  
  3. 洛谷 P1855（多维背包+博弈）  

---

## 可视化设计  

### 动画方案  
1. **回合状态面板**：  
   - 顶部显示当前回合数、双方delay值、累计伤害差。  
   - 用红蓝进度条表示delay差（红：扶苏优势；蓝：扶咕咕优势）。  
2. **背包预处理演示**：  
   - 动态绘制`f[j]`的更新过程，高亮当前处理的`p_i`和`k_i`。  
3. **博弈DP转移**：  
   - 用网格表示`g[i][j]`，当前状态框闪烁，箭头指向可能的下一状态。  

### 复古像素风格  
- **调色板**：8位色（红：#FF0000，蓝：#0000FF，背景：#000000）。  
- **音效设计**：  
  - 道具选择：8-bit "哔"声（Web Audio合成）。  
  - 状态更新：不同音高表示最大/最小操作。  
- **自动演示模式**：AI按最优路径逐步执行，辅以“贪吃蛇式”路径高亮。  

---

## 关键代码实现（一扶苏一题解）  
```cpp
// 背包预处理
std::fill(f, f + maxt, -INF);
f[w] = 100000;  // 初始化为固定w的增益
for (int i = 1; i <= m; ++i) {
    for (int j = t; j >= p[i]; --j) {
        if (f[j - p[i]] != -INF) {
            f[j] = std::max(f[j], f[j - p[i]] + k[i]);
        }
    }
}

// 博弈DP转移
for (int i = 1; i <= n; ++i) {
    for (int j = 0; j <= 100; ++j) {  // 扶苏回合
        g[i][j] = -inf;
        for (int h = j + w; h <= t; ++h) {
            if (f[h - j] != -INF) {
                g[i][j] = std::max(g[i][j], g[i-1][h] + f[h-j] * xa);
            }
        }
    }
    for (int j = 101; j <= t; ++j) {  // 扶咕咕回合
        g[i][j] = inf;
        for (int h = j - w; h >= 0; --h) {
            if (f[j - h] != -INF) {
                g[i][j] = std::min(g[i][j], g[i-1][h] - f[j-h] * xb);
            }
        }
    }
}
```

---

**注**：完整代码已嵌入核心逻辑，重点在于双循环交替处理双方策略。可视化可在此代码基础上添加状态高亮与音效触发。

---
处理用时：117.76秒
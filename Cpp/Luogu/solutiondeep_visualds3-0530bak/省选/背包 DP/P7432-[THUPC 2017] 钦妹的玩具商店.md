# 题目信息

# [THUPC 2017] 钦妹的玩具商店

## 题目描述

钦妹和弗雷兹在 C 市有一个玩具店，店里有 $n$ 种玩具，编号依次为 $1,2,...,n$，第 $i$ 件玩具的单价为 $c_i$ 元，一个该玩具提供的愉悦度为  $v_i$。

突然有一天，C 市来了 $m$ 个小朋友。据可靠消息，接下来 $Q$ 天，这些小朋友每天都会来店里买东西，其中第 $i$ 个小朋友每天都会带 $i$ 元  （$1\le i\le m$）。

由于某些玩具不是很优秀，所以每天都会有不同的玩具被禁止出售给小朋友。具体来说，在第 $i$ 天，编号在区间 $[l_i,r_i]$ 内的物品小朋友是不能购买的。

除此之外，为了防止小朋友们太愉悦，每件玩具都有一个限购件数  $t_i$。也就是说，对于第 $i$ 种玩具，每个小朋友在每一天的购买件数都必须为不超过 $t_i$ 的非负整数。

现在，对于每一天，你想知道：所有小朋友所能获得的最大愉悦度之和（对 $10^8+7$ 取模）；所有小朋友所能获得的最大愉悦度的异或和（异或运算是 $\operatorname{xor}$ 运算，即 C++/Java/Python 中的 `^` 运算）。

本题强制在线，具体规则在输入描述中体现。

## 说明/提示

对于所有的数据，$1\le n,m,Q,c_i,t_i\le 10^3$，$1\le v_i\le 2.5\times 10^5$，$\sum n,\sum m,\sum Q\le 10^4$。
#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。

## 样例 #1

### 输入

```
2
3 10 3
2 3 3
20 50 24
3 1 10
1 1
2 2
3 3
2 7 3
6 7
1 2
1 1
1 1
2 2
1 2```

### 输出

```
568 120
660 20
660 20
2 2
2 0
0 0```

# AI分析结果



**唯一算法分类**：分块 + 动态规划（背包问题）

---

### **综合分析与结论**

#### **核心算法流程**
1. **分块预处理**：将玩具分为 $\sqrt{n}$ 大小的块，预处理每个块的前缀和后缀的背包结果。
2. **多重背包处理**：对每个块的物品进行二进制拆分或单调队列优化，生成预处理数组。
3. **查询处理**：利用预处理的整块信息，暴力合并散块，得到每个小朋友的最大愉悦度。

**解决难点**：
- **区间禁止的高效处理**：通过分块预处理，将每次查询的时间复杂度从 $O(nm)$ 降低到 $O(m\sqrt{n})$。
- **多重背包的优化**：通过二进制拆分或单调队列优化，减少状态转移的计算量。

---

### **题解评分 (≥4星)**

1. **作者：a___ (4星)**  
   - **亮点**：明确分块策略与时间复杂度分析，提出空间优化思路。
2. **作者：Amadeus004 (4星)**  
   - **亮点**：详细对比两种分块思路，提供二进制优化实现代码。
3. **作者：wangsiqi2010916 (4星)**  
   - **亮点**：使用单调队列优化多重背包，代码实现高效。

---

### **最优思路或技巧提炼**

1. **分块预处理**：将玩具分块，预处理每个块的背包结果，查询时合并整块与散块。
2. **多重背包优化**：
   - **二进制拆分**：将每个物品的限购次数拆分为二进制数，转化为 0-1 背包。
   - **单调队列优化**：利用队列维护滑动窗口最大值，减少重复计算。
3. **合并策略**：预处理时记录前缀和后缀的背包数组，查询时只需合并散块。

---

### **可视化与算法演示**

**动画方案**：
1. **分块展示**：用不同颜色区分块，预处理时块依次填充颜色。
2. **背包更新**：显示当前处理的物品如何更新背包数组，动态展示数值变化。
3. **查询过程**：被禁止的块变暗，散块高亮，背包数值合并过程以箭头或颜色渐变表示。

**复古游戏化设计**：
- **像素风格**：用 8-bit 色块表示玩具分块，背包数组显示为像素网格。
- **音效**：处理块时播放“点击”音效，完成查询时播放胜利音效。
- **自动演示**：按步骤自动执行分块、预处理、查询，用户可调节速度。

---

### **核心代码实现**

```cpp
// 分块预处理（作者：Amadeus004）
void init() {
    len = sqrt(n), t = (n + len - 1) / len;
    for (int i = 1; i <= t; i++) L[i] = (i-1)*len+1, R[i] = min(i*len, n);
    // 预处理前缀和后缀的背包
    for (int i = 0; i <= t; i++) {
        if (i > 0) {
            for (int j = L[i]; j <= R[i]; j++) 
                for (int p = m; p >= c[j]; p--) // 多重背包更新
                    g[p] = max(g[p], g[p - c[j]] + v[j]);
            memcpy(f[i][t+1], g, sizeof(g));
        }
        for (int j = t; j > i; j--) { // 处理后缀
            memcpy(f[i][j], f[i][j+1], sizeof(f[i][j+1]));
            for (int k = L[j]; k <= R[j]; k++)
                for (int p = m; p >= c[k]; p--)
                    f[i][j][p] = max(f[i][j][p], f[i][j][p - c[k]] + v[k]);
        }
    }
}

// 查询处理
void query(int l, int r) {
    int P = (l-1)/len + 1, Q = (r-1)/len + 1;
    memcpy(dp, f[P-1][Q+1], sizeof(dp)); // 加载预处理结果
    // 处理左散块
    for (int i = L[P]; i < l; i++) 
        for (int j = m; j >= c[i]; j--)
            dp[j] = max(dp[j], dp[j - c[i]] + v[i]);
    // 处理右散块
    for (int i = r+1; i <= R[Q]; i++)
        for (int j = m; j >= c[i]; j--)
            dp[j] = max(dp[j], dp[j - c[i]] + v[i]);
}
```

---

### **相似题目推荐**

1. **P1776 宝物筛选**（多重背包 + 二进制优化）
2. **P1077 摆花**（背包问题变种）
3. **P3380 二逼平衡树**（分块处理区间查询）

---

**总结**：分块预处理是解决强制在线区间查询的核心，结合多重背包优化可大幅提升效率。

---
处理用时：85.75秒
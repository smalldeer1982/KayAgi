# 题目信息

# [THUPC 2021] 混乱邪恶

## 题目背景

出题人分为 $9$ 种阵营：守序善良、守序中立、守序邪恶、中立善良、绝对中立、中立邪恶、混乱善良、混乱中立和混乱邪恶。真正的出题人，就要能够在阵营之间不断切换，而又不迷失在境界之中。

境界是一个无限大的三角形网格。网格如下图，每个交叉点都有 $6$ 个相邻的交叉点。你从某一个交叉点出发，每次给一个出题 idea 设定风格都会使你在境界中移动一步。

![](https://cdn.luogu.com.cn/upload/image_hosting/dwgwh04i.png)

## 题目描述

每个出题人都有一个守序指数 $L$ 和善良指数 $G$。对于一个 idea，从题面、样例或数据范围的角度，可以从 $6$ 个方向中选择恰好一个作为这个 idea 对应的题目的特有风格，同时会在境界中沿着所选的箭头方向移动一步：

![](https://cdn.luogu.com.cn/upload/image_hosting/5k7jqygw.png)

你现在一共有 $n$ 个 idea，你知道你给每个 idea 设定某一个风格时你的 $L$ 指数和 $G$ 指数的变化。具体地，对于第 $i$ 个idea有 $12$ 个参数 $tl_{i,l},tl_{i,g},l_{i,l},l_{i,g},bl_{i,l},bl_{i,g},br_{i,l},br_{i,g},r_{i,l},r_{i,g},tr_{i,l},tr_{i,g}$：

如果选择“简洁的题面”，那么 $L$ 变成 $L+tl_{i,l}$，$G$ 变成 $G+tl_{i,g}$；

如果选择“平凡无用的样例”，那么 $L$ 变成 $L+l_{i,l}$，$G$ 变成 $G+l_{i,g}$；

如果选择“宽松的数据范围”，那么 $L$ 变成 $L+bl_{i,l}$，$G$ 变成 $G+bl_{i,g}$；

如果选择“复杂的题面”，那么 $L$ 变成 $L+br_{i,l}$，$G$ 变成 $G+br_{i,g}$；

如果选择“无私馈赠的样例”，那么 $L$ 变成 $L+r_{i,l}$，$G$ 变成 $G+r_{i,g}$；

如果选择“松松松的数据范围”，那么 $L$ 变成 $L+tr_{i,l}$，$G$ 变成 $G+tr_{i,g}$。

这里所有的加法都在模 $p$ 意义下进行。

进入混乱邪恶阵营的要求很苛刻，需要 $L$ 恰好等于 $L^*$ 且 $G$ 恰好等于 $G^*$。

你的 $L$ 指数和 $G$ 指数开始时都为 $0$。请问是否存在一种设定风格的方式使得设定完全部 $n$ 个 idea 的风格后你仍在境界中原来的位置，但是能够进入混乱邪恶阵营。

## 说明/提示

**【样例解释】**

给第 $1$ 个 idea 设定风格为”简洁的题面“，此时你的守序指数为 $0+3=3$，善良指数为 $0+5=5$。你往左上方移动一步。

给第 $3$ 个 idea 设定风格为”宽松的数据范围“，此时你的守序指数为 $3+9=2$，善良指数为 $5+3=8$。你往左下方移动一步。

给第 $2$ 个 idea 设定风格为”无私馈赠的样例“，此时你的守序指数为 $2+1=3$，善良指数为 $8+4=2$。你往右边移动一步。此时你回到了原点并且守序指数为 $3$，善良指数为 $2$。所以你可以进入混乱邪恶阵营。

**【数据范围】**

保证 $1 \le n \le 100$，$1 \le p \le 100$。

保证其他输入数据在 $0$ 到 $p-1$ 之间。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）。

题解等资源可在 [https://github.com/yylidiw/thupc_1/tree/master](https://github.com/yylidiw/thupc_1/tree/master) 查看。

## 样例 #1

### 输入

```
3 10
3 5 1 4 9 3 0 0 0 0 0 0
0 0 0 0 0 0 3 5 1 4 9 3
3 5 1 4 9 3 3 5 1 4 9 3
3 2
```

### 输出

```
Chaotic Evil
```

# AI分析结果



**唯一算法分类**：动态规划（DP） + 随机化优化 + bitset 优化

---

### **题解思路、算法要点与解决难点**
#### **核心思路**
1. **问题建模**：将六边形网格映射为直角坐标系，将每个移动方向转换为坐标变化（如 `(x+1, y)`、`(x-1, y)` 等）。
2. **状态设计**：使用动态规划状态 `f[i][L][G][x][y]` 表示处理前 `i` 个 idea 后，属性 `L` 和 `G` 的值分别为 `L` 和 `G`，坐标 `(x, y)` 是否可达。
3. **随机化优化**：通过随机打乱 idea 顺序，限制坐标范围在 `O(√n)` 级别（基于随机游走的期望距离理论）。
4. **bitset 压缩**：将布尔状态压缩为 bitset，优化空间和转移效率。

#### **解决难点**
- **状态爆炸**：原始状态空间为 `O(n^3 p^2)`，无法处理 `n=100`。通过以下优化降低复杂度：
  - **坐标范围限制**：仅维护 `±√n` 范围内的坐标，偏移量为 `√n` 避免负数下标。
  - **滚动数组**：仅保留当前和前一步的状态。
  - **bitset 位操作**：将坐标维度映射为 bitset 的位偏移，用位移操作代替坐标加减。

---

### **题解评分 (≥4星)**
1. **Time_tears (5星)**  
   - **亮点**：清晰解释坐标转换、随机化理论、bitset 优化细节，代码简洁高效。  
   - **代码**：通过 `random_shuffle` 随机化输入，使用 `bitset` 处理坐标维度。

2. **Junounly (4.5星)**  
   - **亮点**：详细推导 DP 转移方程，结合滚动数组和 bitset，提供完整代码实现。  
   - **个人心得**：强调初始化的重要性，避免数组越界。

3. **Mirasycle (4星)**  
   - **亮点**：简化状态设计，明确时间复杂度分析，代码可读性强。  
   - **可视化提示**：在 Canvas 中绘制坐标移动路径，高亮当前步的坐标变化。

---

### **最优思路或技巧提炼**
1. **坐标压缩**：将六边形网格映射为直角坐标系，统一移动方向的坐标变化。
2. **随机化打乱**：利用随机游走的期望距离，将坐标维度限制在 `O(√n)`。
3. **bitset 优化**：用位移操作代替坐标加减，例如 `bitset << 1` 表示 `y+1`。
4. **滚动数组**：仅保留当前和前一步的 DP 状态，降低空间复杂度。

---

### **同类型题或类似算法套路**
- **模数约束背包**：如处理模 `p` 下的加法约束。
- **随机化优化**：用于降低状态维度的期望复杂度（如 NP 问题的近似算法）。
- **状态压缩 DP**：通过位运算或 bitset 压缩状态，如旅行商问题（TSP）。

---

### **推荐相似题目**
1. **P1273 有线电视网**（树形 DP + 状态压缩）  
2. **P1064 金明的预算方案**（多维背包问题）  
3. **P4563 [JXOI2018] 守卫**（区间 DP + 状态优化）

---

### **个人心得摘录**
- **调试教训**：坐标偏移量需足够大（如 `√n + 2`），避免负数下标导致越界。
- **顿悟点**：随机化打乱输入顺序后，DP 的坐标维度可大幅缩小，本质是概率均衡。

---

### **可视化与算法演示**
#### **动画设计**
1. **网格绘制**：用 Canvas 绘制直角坐标系网格，原点高亮为红色，当前坐标标记为蓝色方块。
2. **状态更新**：  
   - **颜色标记**：绿色表示可达状态，灰色不可达。  
   - **步进控制**：单步执行时，显示当前 idea 的移动方向和属性变化。  
   - **音效触发**：每次转移成功播放“滴”声，最终达成目标时播放胜利音效。
3. **复古风格**：采用 8-bit 像素风，坐标移动时显示“马赛克”过渡效果。

#### **代码片段（JS 伪代码）**
```javascript
// Canvas 初始化与网格绘制
const canvas = document.getElementById("grid");
const ctx = canvas.getContext("2d");
const offset = 20; // 坐标偏移量

function drawGrid() {
    for (let x = -10; x <= 10; x++) {
        for (let y = -10; y <= 10; y++) {
            ctx.fillStyle = (x === 0 && y === 0) ? "red" : "gray";
            ctx.fillRect((x + offset) * 20, (y + offset) * 20, 18, 18);
        }
    }
}

// DP 状态更新动画
function updateState(step, L, G, x, y) {
    // 高亮当前坐标
    ctx.fillStyle = "blue";
    ctx.fillRect((x + offset) * 20, (y + offset) * 20, 18, 18);
    // 播放音效
    playSound("beep.mp3");
}
```

---

### **总结**
本题通过动态规划结合随机化与 bitset 优化，解决了高维状态空间的问题。核心在于坐标映射和概率均衡，可视化设计可增强对状态转移的理解。

---
处理用时：108.41秒
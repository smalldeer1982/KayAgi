# 题目信息

# [福建省队集训2019] 最大权独立集问题

## 题目描述

E.Space 喜欢出最大权独立集问题。

接下来，他还想出 $n$ 道最大权独立集问题。

E.Space 有 $n$ 个 AI，编号为 $1\sim n$。

开始第 $i$ 个 AI 里面存有一道 E.Space 事先出好的一道难度为 $d_i$ 的最大权独立集问题。

有些 AI 之间可以互相通信，对于所有的 $2 \le i \le n$，第 $i$ 个 AI 可以和第 $c_i$ 个 AI 互相通信。此外，其他对 AI 不可以互相通信。

E.Space 每次可以选择一个存有一道最大权独立集问题的 AI，把存在里面的题出出来，然后清除存在这个 AI 里的题。

在 E.Space 出题之后清除题目之前，AI 会把这道题发给能和它通信的所有 AI。

如果一个收到这道题的 AI 中已经存有一道最大权独立集问题，那么这个 AI 会把这个收到的题和原本存有的题结合起来，变成一道新的最大权独立集问题存起来。形式化地，如果这个 AI 原来存了一道难度为 $x$ 的最大权独立集问题，接着收到了一道难度为 $y$ 的最大权独立集问题，那么结合之后是一道难度为 $x+y$ 的最大权独立集问题。

如果一个收到题的 AI 中未存有题，那么这个 AI 会销毁收到的这个信息。

由于出题人的丧病心理，E.Space 想要出出来的 $n$ 道最大权独立集问题的难度之和尽量大。

他想叫你帮他解决这个问题，还说如果你成功在这场训练中解决了这个问题，那么在出那 $n$ 道最大权独立集问题的时候，他会在训练结束前 10 分钟切换至你的账号然后提交一份标程代码。

## 说明/提示

### 【样例解释 1】

一种最优的出题方案如下：

1. 出第 $2$ 个 AI 中的最大权独立集问题，此时该题难度为 $10$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $11,*,13,5$ ($*$ 表示该 AI 中没有最大权独立集问题，下同)。

2. 出第 $3$ 个 AI 中的最大权独立集问题，此时该题难度为 $13$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $11,*,*,18$。

3. 出第 $1$ 个 AI 中的最大权独立集问题，此时该题难度为 $11$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,18$。

4. 出第 $4$ 个 AI 中的最大权独立集问题，此时该题难度为 $18$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,*$。

所以 $4$ 道题的难度之和为 $10+13+11+18=52$。

### 【样例解释 2】

一种最优的出题方案如下：

1. 出第 $3$ 个 AI 中的最大权独立集问题，此时该题难度为 $5$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $1,3,*,5$。

2. 出第 $4$ 个 AI 中的最大权独立集问题，此时该题难度为 $5$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $1,8,*,*$。

3. 出第 $2$ 个 AI 中的最大权独立集问题，此时该题难度为 $8$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $9,*,*,*$。

4. 出第 $1$ 个 AI 中的最大权独立集问题，此时该题难度为 $9$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,*$。

所以 $4$ 道题的难度之和为 $5+5+8+9=27$。

### 【数据范围】

保证 $\left|d_i\right| \le 10^9$，$1 \le c_i \lt i$，$1\le n \le 400$。

**本题采用捆绑测试。**

对于编号为奇数的子任务，保证 $d_i \ge 0$。

子任务 $1,2$（$11 \times 2 = 22$ 分）：
$n \le 9$。

子任务 $3,4$（$10 \times 2 = 20$ 分）：
$n \le 19$。

子任务 $5,6$（$7 \times 2 = 14$ 分）：
$n \le 50$，$c_i = i-1$。

子任务 $7,8$（$10 \times 2 = 20$ 分）：
$c_i=i-1$。

子任务 $9,10$（$5 \times 2 = 10$ 分）：
$n \le 50$。

子任务 $11,12$（$7 \times 2 = 14$ 分）：
无特殊限制。

### 后记

听说 E.Space 的最大权独立集问题的难度是取了对数的？

听说 E.Space 要把这 $n$ 道题结合成一道题出出来？

听说 E.Space 不会把这些题出在训练里面？



## 样例 #1

### 输入

```
4
1 10 3 5
1 2 3
```

### 输出

```
52
```

## 样例 #2

### 输入

```
4
1 -2 5 5
1 2 2
```

### 输出

```
27
```

# AI分析结果



---

**算法分类**：树形动态规划（树形DP）

---

### **题解思路与核心难点**

1. **问题转化**  
   将操作顺序转化为树边的定向问题：若节点 $u$ 先于 $v$ 被删除，则边 $(u, v)$ 定向为 $u→v$。此时，每个节点的贡献次数等于其能到达的节点数（包括自身），总目标为最大化 $\sum_{i=1}^n d_i \times cnt_i$。

2. **动态规划设计**  
   - **状态定义**：  
     $f_{u,i,j}$ 表示处理完子树 $u$ 后，$u$ 能到达 $i$ 个点，其中子树内包含 $j$ 个点时，子树内的最大贡献。
   - **转移逻辑**：  
     - **边定向为父→子**：子节点 $v$ 的贡献只能在其子树内，合并时累加父节点的贡献。
     - **边定向为子→父**：子节点 $v$ 的贡献会传递到父节点的其他子树或祖先，需预计算外部贡献。

3. **难点解决**  
   - **贡献拆分**：通过状态中的 $i$ 和 $j$ 分离子树内外的贡献，确保合并时不重复计算。
   - **复杂度控制**：三重循环实现 $O(n^3)$ 复杂度，利用子树大小逐步合并，避免冗余计算。

---

### **题解评分**

- **Llx2022 (★★★★☆)**  
  思路清晰，详细解释状态转移与贡献计算。代码结构明确，通过 `tmp` 数组避免后效性，适合学习树形DP的经典实现。

- **Elma_ (★★★★☆)**  
  代码简洁，状态定义更直观（直接记录外部贡献数 $k$），适合理解预贡献思想。注释较少但逻辑清晰。

- **Leasier (★★★☆☆)**  
  状态设计复杂（同时记录内外部点数），转移逻辑稍显晦涩，但提供了不同视角的思路参考。

---

### **最优思路与技巧**

- **关键思路**：将删除顺序转化为边定向，利用树形DP动态维护每个节点的可达节点数。
- **实现技巧**：  
  1. **贡献预计算**：在合并子树时提前累加父节点对子节点的贡献。
  2. **状态压缩**：通过记录子树内外可达点数，避免重复枚举。
  3. **方向分治**：分别处理两种边定向情况，确保所有可能被覆盖。

---

### **同类型题推荐**

1. **P2585 [ZJOI2006] 三色二叉树**  
   - 树形DP，状态转移需考虑颜色分配与子树结构。

2. **P3177 [HAOI2015] 树上染色**  
   - 树形背包问题，通过边权贡献拆分优化复杂度。

3. **P4516 [JSOI2018] 潜入行动**  
   - 树形DP结合状态压缩，需处理复杂子树交互。

---

### **可视化与算法演示**

- **动画设计**：  
  1. **树结构展示**：以树形图展示节点和边，初始颜色为灰色。
  2. **动态合并子树**：选中子树时高亮当前节点（绿色），边根据定向变红（父→子）或蓝（子→父）。
  3. **贡献更新**：每次合并显示可达节点数变化，用浮动数字展示 $d_i \times cnt_i$ 的累加过程。
  4. **状态面板**：实时显示当前节点的 $f_{u,i,j}$ 值，突出最大值更新。

- **复古像素风格**：  
  - **颜色方案**：8-bit 调色板（绿、红、蓝、黄），节点用方块表示，边用像素线连接。
  - **音效触发**：  
    - 定向选择时播放短音效（如 `beep`）。
    - 合并完成时播放上升音调。
  - **自动演示**：模拟贪吃蛇路径，按最优路径自动执行边定向与贡献计算。

---

### **核心代码实现**

**Llx2022 的关键转移逻辑**：
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= sz[u] && j <= i; j++) {
        for (int k = 1; k <= sz[v] && j + k <= i; k++) {
            // 边定向为 u→v
            f[u][i][j + k] = max(f[u][i][j + k], tmp[i][j] + f[v][k][k] + k * d[u]);
        }
        for (int k = 1; k <= sz[v]; k++) {
            // 边定向为 v→u
            f[u][i][j] = max(f[u][i][j], tmp[i][j] + f[v][i + k][k]);
        }
    }
}
```

**Elma_ 的预贡献设计**：
```cpp
for (int k = 1; k <= n; k++) {
    for (int i = 1; i <= sz[u]; i++) {
        for (int j = 1; j <= sz[v]; j++) {
            // 边定向为父→子
            f[u][i + j][k] = max(f[u][i + j][k], tmp[i][k] + f[v][j][j]);
        }
        // 边定向为子→父
        LL val = max_val(f[v][...], k);
        f[u][i][k] = max(f[u][i][k], tmp[i][k] + val);
    }
}
```

---

**总结**：通过树形DP拆解贡献次数，结合预计算与方向分治，高效解决复杂树结构上的最优化问题。

---
处理用时：106.77秒
# 题目信息

# [NOIP 2006 普及组] 明明的随机数

## 题目描述

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 $N$ 个 $1$ 到 $1000$ 之间的随机整数 $(N\leq100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。


## 说明/提示

NOIP 2006 普及组 第一题


## 样例 #1

### 输入

```
10
20 40 32 67 40 20 89 300 400 15
```

### 输出

```
8
15 20 32 40 67 89 300 400
```

# AI分析结果



## 算法分类  
**排序与去重**

---

## 题解思路、算法要点与解决难点  

### 核心逻辑对比  
1. **桶排序法**（qr小盆友、Stone_Xz 等）  
   - **核心步骤**：  
     - 建立 `bool` 数组标记数值是否出现（桶）  
     - 遍历输入数据时，若第一次出现则计数  
     - 按顺序遍历桶数组输出存在的数值  
   - **优势**：时间复杂度 $O(n + m)$（$m=1000$），空间换时间  
   - **难点**：需明确数值范围（本题 1~1000），不适用于大范围数据  

2. **排序 + 去重法**（2023z、jscaj0921 等）  
   - **核心步骤**：  
     - 先调用 `sort` 排序  
     - 遍历数组统计相邻重复元素，输出非重复项  
   - **优势**：通用性强，适合任意数值范围  
   - **难点**：需注意重复元素的处理逻辑（如 `a[i] != a[i-1]` 的边界条件）  

3. **STL 容器法**（mcturtle、GZXUEXUE 等）  
   - **核心步骤**：  
     - 使用 `set` 容器自动去重排序  
     - 直接输出容器内元素  
   - **优势**：代码极简（5~10 行），时间复杂度 $O(n \log n)$  
   - **难点**：需理解迭代器遍历机制  

4. **unique 函数法**（Erina、BetterGlow 等）  
   - **核心步骤**：  
     - `sort` 排序后调用 `unique` 去重  
     - 计算去重后长度并输出  
   - **优势**：利用 STL 函数简化去重逻辑  
   - **难点**：需理解 `unique` 返回尾迭代器的含义  

---

## 题解评分（≥4★）  

### 1. qr小盆友（5★）  
- **亮点**：  
  - 桶排序思路清晰，配图直观说明算法原理  
  - 代码注释完整，变量命名合理（`book` 表标记）  
  - 时间复杂度 $O(n + m)$ 最优，完美适配本题数据范围  

### 2. mcturtle（4★）  
- **亮点**：  
  - 利用 `set` 容器特性实现极简代码（仅需 10 行）  
  - 明确说明迭代器遍历方式，适合 STL 初学者学习  
  - 时间复杂度 $O(n \log n)$ 足够应对普及组题目  

### 3. Erina（4★）  
- **亮点**：  
  - 引入 `unique` 函数简化去重逻辑，代码简洁  
  - 演示 `unique` 函数原理及离散化应用场景  
  - 需配合排序使用，适合学习 STL 进阶技巧  

---

## 最优思路或技巧提炼  

### 关键技巧  
1. **桶排序标记法**  
   - 适用场景：数值范围较小（如本题 1~1000）  
   - 实现要点：  
     ```cpp
     bool book[1001] = {0};  // 标记数组初始化  
     if (book[x] == 0) cnt++; // 首次出现计数  
     for (int i=1; i<=1000; i++) if (book[i]) cout<<i; // 顺序输出  
     ```  
   - **优势**：去重与排序同步完成，无需额外操作  

2. **STL 组合技**  
   - `sort + unique` 或 `set` 容器实现一行流：  
     ```cpp
     // set 解法  
     set<int> s;  
     s.insert(x);  
     cout << s.size() << endl;  
     for (auto it : s) cout << it << " ";  
     ```  
   - **适用场景**：快速实现需求，减少手写逻辑  

---

## 同类型题与算法套路  
1. **通用去重排序模板**：  
   - 数值范围小 → 桶排序  
   - 数值范围大 → 快速排序 + 相邻去重  
2. **STL 高阶应用**：  
   - `map` 统计频率  
   - `unordered_set` 哈希去重  

---

## 推荐相似题目  
1. **P1177 【模板】快速排序**  
   - 练习排序算法基础实现  
2. **P1051 谁拿了最多奖学金**  
   - 综合排序与条件统计  
3. **P1309 瑞士轮**  
   - 复杂排序规则与去重结合  

---

## 个人心得摘录  
- **qr小盆友**：桶排序的图示帮助理解“插小棒”操作，强调空间换时间的取舍  
- **2023z**：指出错误代码中赋值 0 导致后续判断失效的问题，强调逻辑严密性  
- **Erina**：提醒 `unique` 需先排序，并演示 `resize` 调整容器大小的必要性  

---

## 可视化与算法演示  

### 桶排序动画方案  
1. **动画流程**：  
   - **步骤 1**：展示空桶数组（1~1000 的格子）  
   - **步骤 2**：输入数字时，对应桶高亮并标记为已填充（如红色方块）  
   - **步骤 3**：遍历桶数组，按顺序输出非空桶的数值  

2. **交互设计**：  
   - **高亮当前操作**：正在处理的输入数字用绿色边框标记，已填充桶为红色  
   - **速度控制**：滑块调节输入处理速度（0.5x~3x）  
   - **单步执行**：点击按钮逐步处理每个输入数字  

```javascript
// 伪代码示例（Canvas 绘制桶状态）  
function drawBucket(bucket) {
  for (let i = 1; i <= 1000; i++) {
    ctx.fillStyle = bucket[i] ? "#FF0000" : "#CCCCCC";
    ctx.fillRect(i * 5, 100, 4, 20); // 每个桶宽5px，高20px
  }
}
```

### 复古像素风格设计  
- **调色板**：8 位红（#FF0000）、绿（#00FF00）、蓝（#0000FF）  
- **音效**：  
  - 插入桶时播放短促“哔”声（Web Audio API）  
  - 完成排序后播放 8-bit 胜利旋律  
- **关卡化**：  
  - 第 1 关：处理 10 个数字（样例输入）  
  - 第 2 关：处理 100 个随机数  
  - 积分规则：正确输出一个数字 +10 分，错误扣 5 分  

---

## 核心代码实现  

### 桶排序法（qr小盆友）  
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    bool book[1001] = {0};
    int n, final = 0;
    cin >> n;
    int a[n];
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        if (!book[a[i]]) final++;
        book[a[i]] = 1;
    }
    cout << final << endl;
    for (int i = 1; i <= 1000; i++) 
        if (book[i]) cout << i << " ";
    return 0;
}
```

### STL set 法（mcturtle）  
```cpp
#include<bits/stdc++.h>
using namespace std;
set<int> s;
int main() {
    int n, x;
    cin >> n;
    while (n--) { cin >> x; s.insert(x); }
    cout << s.size() << endl;
    for (auto it : s) cout << it << " ";
    return 0;
}
```

---
处理用时：93.31秒
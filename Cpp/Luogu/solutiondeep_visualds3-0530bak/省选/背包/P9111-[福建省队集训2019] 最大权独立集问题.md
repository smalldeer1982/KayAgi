# 题目信息

# [福建省队集训2019] 最大权独立集问题

## 题目描述

E.Space 喜欢出最大权独立集问题。

接下来，他还想出 $n$ 道最大权独立集问题。

E.Space 有 $n$ 个 AI，编号为 $1\sim n$。

开始第 $i$ 个 AI 里面存有一道 E.Space 事先出好的一道难度为 $d_i$ 的最大权独立集问题。

有些 AI 之间可以互相通信，对于所有的 $2 \le i \le n$，第 $i$ 个 AI 可以和第 $c_i$ 个 AI 互相通信。此外，其他对 AI 不可以互相通信。

E.Space 每次可以选择一个存有一道最大权独立集问题的 AI，把存在里面的题出出来，然后清除存在这个 AI 里的题。

在 E.Space 出题之后清除题目之前，AI 会把这道题发给能和它通信的所有 AI。

如果一个收到这道题的 AI 中已经存有一道最大权独立集问题，那么这个 AI 会把这个收到的题和原本存有的题结合起来，变成一道新的最大权独立集问题存起来。形式化地，如果这个 AI 原来存了一道难度为 $x$ 的最大权独立集问题，接着收到了一道难度为 $y$ 的最大权独立集问题，那么结合之后是一道难度为 $x+y$ 的最大权独立集问题。

如果一个收到题的 AI 中未存有题，那么这个 AI 会销毁收到的这个信息。

由于出题人的丧病心理，E.Space 想要出出来的 $n$ 道最大权独立集问题的难度之和尽量大。

他想叫你帮他解决这个问题，还说如果你成功在这场训练中解决了这个问题，那么在出那 $n$ 道最大权独立集问题的时候，他会在训练结束前 10 分钟切换至你的账号然后提交一份标程代码。

## 说明/提示

### 【样例解释 1】

一种最优的出题方案如下：

1. 出第 $2$ 个 AI 中的最大权独立集问题，此时该题难度为 $10$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $11,*,13,5$ ($*$ 表示该 AI 中没有最大权独立集问题，下同)。

2. 出第 $3$ 个 AI 中的最大权独立集问题，此时该题难度为 $13$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $11,*,*,18$。

3. 出第 $1$ 个 AI 中的最大权独立集问题，此时该题难度为 $11$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,18$。

4. 出第 $4$ 个 AI 中的最大权独立集问题，此时该题难度为 $18$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,*$。

所以 $4$ 道题的难度之和为 $10+13+11+18=52$。

### 【样例解释 2】

一种最优的出题方案如下：

1. 出第 $3$ 个 AI 中的最大权独立集问题，此时该题难度为 $5$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $1,3,*,5$。

2. 出第 $4$ 个 AI 中的最大权独立集问题，此时该题难度为 $5$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $1,8,*,*$。

3. 出第 $2$ 个 AI 中的最大权独立集问题，此时该题难度为 $8$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $9,*,*,*$。

4. 出第 $1$ 个 AI 中的最大权独立集问题，此时该题难度为 $9$，出题后 $4$ 个 AI 中的最大权独立集问题的难度分别为 $*,*,*,*$。

所以 $4$ 道题的难度之和为 $5+5+8+9=27$。

### 【数据范围】

保证 $\left|d_i\right| \le 10^9$，$1 \le c_i \lt i$，$1\le n \le 400$。

**本题采用捆绑测试。**

对于编号为奇数的子任务，保证 $d_i \ge 0$。

子任务 $1,2$（$11 \times 2 = 22$ 分）：
$n \le 9$。

子任务 $3,4$（$10 \times 2 = 20$ 分）：
$n \le 19$。

子任务 $5,6$（$7 \times 2 = 14$ 分）：
$n \le 50$，$c_i = i-1$。

子任务 $7,8$（$10 \times 2 = 20$ 分）：
$c_i=i-1$。

子任务 $9,10$（$5 \times 2 = 10$ 分）：
$n \le 50$。

子任务 $11,12$（$7 \times 2 = 14$ 分）：
无特殊限制。

### 后记

听说 E.Space 的最大权独立集问题的难度是取了对数的？

听说 E.Space 要把这 $n$ 道题结合成一道题出出来？

听说 E.Space 不会把这些题出在训练里面？



## 样例 #1

### 输入

```
4
1 10 3 5
1 2 3
```

### 输出

```
52
```

## 样例 #2

### 输入

```
4
1 -2 5 5
1 2 2
```

### 输出

```
27
```

# AI分析结果



### 唯一算法分类
树形动态规划（树形DP）

---

### 题解思路、算法要点与解决难点

#### 核心思路
1. **问题转化**：将删除顺序转化为给树边定向问题。若节点u比v先删除，则边u→v，此时u的贡献会传递给后续删除的节点。
2. **贡献拆分**：每个节点对答案的贡献等于其能到达的节点数（包括自身）乘以权值d_i。目标最大化总贡献Σ(d_i × cnt_i)。
3. **状态设计**：树形DP状态需记录子树内外的可达节点数，通过合并子树状态动态计算最大值。

#### 算法实现要点
- **状态定义**：如`f[u][i][j]`表示子树u内可达i个节点，其中j个属于该子树。
- **转移方式**：
  - **u→v边**：合并v子树的贡献，累加`f[v][k][k] + k*d_u`。
  - **v→u边**：合并时需考虑子树外可达数，累加`f[v][i+k][k]`。
- **时间复杂度优化**：通过限制子树大小枚举范围，确保复杂度为O(n³)。

#### 解决难点
- **贡献传递的依赖关系**：节点贡献受父节点和兄弟节点的删除顺序影响，需通过状态设计提前预计算。
- **多维度状态合并**：需同时跟踪子树内外的可达节点数，并处理不同方向的边带来的贡献差异。

---

### 最优思路或技巧提炼
1. **边定向与贡献预计算**：通过定向将动态删除顺序转化为静态边方向，提前计算每个节点的潜在贡献。
2. **树形DP状态压缩**：利用子树大小限制枚举范围，避免无效状态转移。
3. **费用提前计算**：在合并子树时，将未来可能增加的贡献提前累加到当前状态。

---

### 同类型题或类似算法套路
- **树形背包问题**：如「NOIP2006 金明的预算方案」，通过子树合并实现状态转移。
- **贡献拆分+动态规划**：如「USACO 2019 December Contest, Platinum Problem 3. Tree Depth」，将贡献拆分为独立部分处理。

---

### 推荐相似题目
1. [P2014 选课](https://www.luogu.com.cn/problem/P2014)  
   （树形背包经典问题，状态合并思路相似）
2. [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273)  
   （树形DP结合收益最大化，需要拆分贡献）
3. [P4516 [JSOI2018] 潜入行动](https://www.luogu.com.cn/problem/P4516)  
   （复杂树形DP状态设计，多维度状态转移）

---

### 可视化与算法演示设计

#### 核心算法流程动画
1. **树结构展示**：以根节点为起点，逐步展开子树结构，节点间连线表示通信关系。
2. **状态转移高亮**：
   - **当前处理节点**：用闪烁边框标记。
   - **可达节点计数**：用不同颜色区分子树内外节点数。
   - **边定向操作**：点击边切换方向，实时显示当前定向对总贡献的影响。

#### 复古像素风格实现
```javascript
// 伪代码：Canvas绘制树节点与状态
function drawTree(node, x, y) {
  ctx.fillStyle = '#8BDBB3'; // 节点颜色
  ctx.fillRect(x-15, y-15, 30, 30); // 方形节点
  ctx.fillStyle = '#000';
  ctx.fillText(`d=${node.d}`, x-10, y+5); // 显示权值
}

// 音效触发（Web Audio API）
function playSound(effect) {
  const osc = audioCtx.createOscillator();
  osc.frequency.value = effect === 'merge' ? 440 : 220; // 合并/定向音效
  osc.connect(audioCtx.destination);
  osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}
```

#### 交互设计
- **步进控制**：按钮控制DP合并步骤，高亮当前处理的子树。
- **自动演示模式**：模拟AI决策路径，按最优顺序逐步展开状态转移。
- **得分系统**：实时显示当前总贡献，过关条件为达到理论最大值。

---

### 题解评分（≥4星）

1. **Llx2022（★★★★☆）**  
   - 亮点：状态定义清晰，代码注释详细，通过临时数组避免后效性。
2. **Elma_（★★★★☆）**  
   - 亮点：状态转移公式推导严谨，代码结构简洁高效。
3. **Leasier（★★★★☆）**  
   - 亮点：创新性引入内外节点分离状态，转移逻辑直观。

---

### 代码核心片段（以Llx2022题解为例）
```cpp
void dfs(int u, int fa) {
    sz[u] = 1;
    for (int i = 1; i <= n; i++) f[u][i][1] = d[u]; // 初始化
    for (auto v : G[u]) {
        if (v == fa) continue;
        dfs(v, u);
        // 使用临时数组保存当前状态
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= sz[u]; j++)
                tmp[i][j] = f[u][i][j];
        
        // 分两种边方向合并子树状态
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= sz[u]; j++) {
                // 情况1: u→v边，累加子树v的贡献
                for (int k = 1; k <= sz[v]; k++)
                    f[u][i][j+k] = max(f[u][i][j+k], tmp[i][j] + f[v][k][k] + k*d[u]);
                // 情况2: v→u边，预计算外部贡献
                for (int k = 1; k <= sz[v]; k++)
                    f[u][i][j] = max(f[u][i][j], tmp[i][j] + f[v][i+k][k]);
            }
        }
        sz[u] += sz[v];
    }
    // 补上额外贡献
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= sz[u]; j++)
            f[u][i][j] += d[u] * (i - j);
}
```

---
处理用时：85.04秒
# 题目信息

# [JLOI2014] 天天酷跑

## 题目描述

在游戏天天酷跑中，最爽的应该是超级奖励模式了吧，没有一切障碍，可以尽情的吃金币，现在请你控制游戏角色来获得尽可能多的分数。游戏界面离散为一个长度为 $1 \sim n$，高度为 $1 \sim m$（初始点为 $(0,1)$）的矩阵图。每个格子上都有收益 $(-1 \sim 1000)$，$-1$ 表示该点不能通过。游戏角色从起点一路奔跑向终点，中途可以跳跃来获得更高的分数，在空中还能进行连跳。

游戏开始前你可以设定跳跃的高度，以及能连跳的次数，初始跳跃高度为 $1$，连跳数为 $1$（最多为 $5$），升级跳跃高度和连跳都需要一定的花费。跳跃高度设定完后游戏角色每次跳跃高度都将固定，连跳必须在下落过程中可以使用。所有操作都将在整点上完成，需要保证设定完的跳跃高度及连跳数，无法跳出游戏高度上限。

![](https://cdn.luogu.com.cn/upload/pic/17609.png) 

从 $(1,1)$ 点用一次跳跃，一次经过 $(2,2),(3,3),(4,2),(5,1)$。

以下是连跳数为 $2$ 连跳，跳跃高度为 $2$ 的跳跃方案：

![](https://cdn.luogu.com.cn/upload/pic/17610.png)

从 $(1,1)$ 起跳，依次经过 $(2,2),(3,3),(4,2)$ 再使用连跳，经过 $(5,3),(6,4),(7,3),(8,2),(9,1)$。

![](https://cdn.luogu.com.cn/upload/pic/17611.png)

## 说明/提示

对于 $20 \%$ 的数据，满足 $m=2$，$1 \le n \le 10 ^ 5$。

对于另外 $80 \%$ 的数据，$1 \le n \le 10000$，$2 < m \le 20$，其中有 $20\%$ 的数据保证 $2 < n \le 10$，$1 \le m \le 10$。

## 样例 #1

### 输入

```
7 4 6 10
9 4 7 7 4 3 2
18 8 9 4 15 12 4
19 2 4 7 10 18 12
8 1 13 14 16 0 14```

### 输出

```
67 1 2```

# AI分析结果



### 唯一算法分类
动态规划/记忆化搜索

---

### 综合分析与结论
**核心思路**：  
所有题解均采用动态规划思想，通过定义状态 `f[x][y][k]`（位置 `(x,y)` 剩余 `k` 次连跳机会的最大收益），结合跳跃路径合法性检查（障碍物与高度限制）和参数枚举（跳跃高度 `h` 与连跳次数 `c`）求解最优解。

**核心难点**：
1. **跳跃合法性判断**：需检查跳跃路径中所有点是否合法（非 `-1`）
2. **状态转移复杂**：需同时处理地面移动、空中下落、主动跳跃三种状态
3. **参数枚举优化**：跳跃高度与连跳次数的合法组合需满足 `h*c < m`
4. **初始条件特殊**：起点为 `(0,1)`，地面行可重置连跳次数

**可视化设计思路**：
- **动画方案**：在网格中动态绘制角色移动轨迹，高亮当前状态 `(x,y,k)` 与跳跃路径
- **颜色标记**：红色标记当前操作点，黄色标记跳跃路径，绿色显示合法路径
- **步进控制**：按空格键单步执行状态转移，支持回放不同参数组合的跳跃轨迹
- **复古风格**：采用 8-bit 像素角色，跳跃时播放 "jump.wav" 音效，得分时播放 "coin.wav"

---

### 题解清单（≥4星）
1. **DengDuck（★★★★★）**  
   - 关键亮点：正确处理参数合法性条件 `h*c < m`，代码简洁  
   - 引用心得：“需要保证设定完的跳跃高度及连跳数，无法跳出游戏高度上限”  
   - 核心代码片段：
     ```cpp
     if(K>0&&Y+H<=m) { // 跳跃合法性判断
         int Flg=1,S=0;
         for(int i=1;i<H;i++)Flg&=A[X+i][Y+i]!=-1,S+=A[X+i][Y+i];
         if(Flg)Ans=S+Dfs(X+H,Y+H,K-1);
     }
     ```

2. **Flying2018（★★★★☆）**  
   - 关键亮点：使用前缀和优化跳跃路径收益计算  
   - 核心代码：
     ```cpp
     int get(int x,int y,int h){return sum[x+h][y+h]-sum[x][y];}
     ```

3. **LJXlalala（★★★★☆）**  
   - 关键亮点：明确处理地面状态重置连跳次数  
   - 代码亮点：
     ```cpp
     if(y==1) t=mat; // 地面重置连跳次数
     ```

---

### 最优思路提炼
1. **状态压缩**：通过 `k` 次连跳机会统一处理跳跃与连跳状态
2. **路径预判**：跳跃前检查路径合法性并预计算收益
3. **参数剪枝**：根据 `h*c < m` 条件大幅减少枚举量
4. **地面重置**：当 `y=1` 时重置连跳次数为最大值

**实践技巧**：
```cpp
// 枚举跳跃参数时使用双重循环剪枝
for(int c=1;c<=5;c++)
    for(int h=1;h*c<m;h++) // 关键优化条件
```

---

### 同类题目推荐
1. **P1004 方格取数**（二维路径DP）
2. **P1433 吃奶酪**（状态压缩DP）
3. **P1941 飞扬的小鸟**（跳跃类动态规划）

---

### 可视化代码片段（像素动画核心）
```javascript
class GameAnim {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.gridSize = 32; // 32x32像素格子
        this.drawState(x, y, k) {
            // 绘制角色当前位置和连跳次数
            this.ctx.fillStyle = y === 1 ? '#00FF00' : '#FF0000';
            this.ctx.fillRect(x*gridSize, (m-y)*gridSize, gridSize, gridSize);
            
            // 绘制连跳次数
            this.ctx.fillText(`Jumps: ${k}`, 10, 20); 
        }
    }
}
```

---

### 关键调试心得
1. **DengDuck**：“初始点 `(0,1)` 容易误写为 `(1,1)`，需特别注意题目描述”
2. **年华天地**：“跳跃参数合法性条件可能被错误实现，导致漏解”
3. **LJXlalala**：“连跳次数在地面行必须重置，否则无法获得最优解”

---

### 算法演示（复古风格）
**动画流程**：
1. 初始化 16 色调色板，绘制网格地图
2. 角色以像素方块形式从 `(0,1)` 开始移动
3. 按 `→` 键单步执行，显示状态转移过程：
   - 绿色方块：地面移动
   - 红色方块：空中下落
   - 黄色路径：跳跃过程
4. 非法跳跃时播放 "error.wav"，收益更新时显示金色数字
5. 最优解找到时全屏闪烁三次，播放 "victory.wav"

---
处理用时：66.60秒
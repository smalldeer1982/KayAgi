# 题目信息

# [NOI2015] 寿司晚宴

## 题目描述

为了庆祝 NOI 的成功开幕，主办方为大家准备了一场寿司晚宴。小 G 和小 W 作为参加 NOI 的选手，也被邀请参加了寿司晚宴。

在晚宴上，主办方为大家提供了 $n−1$ 种不同的寿司，编号 $1,2,3,\ldots,n-1$，其中第 $i$ 种寿司的美味度为 $i+1$。（即寿司的美味度为从 $2$ 到 $n$）

现在小 G 和小 W 希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小 G 品尝的寿司种类中存在一种美味度为 $x$ 的寿司，小 W 品尝的寿司中存在一种美味度为 $y$ 的寿司，而 $x$ 与 $y$ 不互质。

现在小 G 和小 W 希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数 $p$ 取模）。注意一个人可以不吃任何寿司。


## 说明/提示

【数据范围】


 ![](https://cdn.luogu.com.cn/upload/pic/1506.png) 


**勘误：$0 < p \le 10^9 $**

## 样例 #1

### 输入

```
3 10000```

### 输出

```
9```

## 样例 #2

### 输入

```
4 10000```

### 输出

```
21```

## 样例 #3

### 输入

```
100 100000000```

### 输出

```
3107203```

# AI分析结果



## 算法分类
**状态压缩动态规划（状压DP）**

---

## 综合分析与结论
### 核心思路与难点
1. **质因数分解与分组**  
   - 每个数分解为小质数（≤19）的集合和大质数（最多一个）。
   - 按大质数分组，同一大质数的数必须分到同一集合或不选。

2. **状压DP与滚动优化**  
   - 小质数集合用8位二进制状压（共256种状态）。
   - 使用两个临时数组`f1`和`f2`分别记录大质数分给甲或乙的情况。

3. **动态转移与去重**  
   - 同一大质数组处理时，用`f1`和`f2`分别进行转移。
   - 合并结果时减去初始状态（避免不选情况的重复计数）。

### 可视化设计要点
1. **动画演示**  
   - **质因数分解**：用颜色标记小质数位（如红色=2，绿色=3等），大质数用特殊颜色（如紫色）。
   - **分组处理**：同一大质数组用同色背景，动态展示只能分给甲/乙。
   - **状态转移**：高亮当前处理的小质数位，显示`f1`和`f2`的变化。

2. **复古像素效果**  
   - 用8-bit风格显示二进制状态，如每个质数对应像素块。
   - 音效：处理小质数时播放“滴”声，大质数组结束时播放“叮”声。

3. **交互控制**  
   - 步进按钮：单步执行分组处理。
   - 状态对比：并列显示`f1`、`f2`和主数组的数值变化。

---

## 题解清单（≥4星）
### 1. Orion545（4.5星）
- **亮点**：详细分解质数，分组处理逻辑清晰，代码注释丰富。
- **核心代码**：
  ```cpp
  for (i处理大质数组时) {
    memcpy(f1, dp, sizeof(dp));  // 备份状态
    for (数 in 当前组) {
      if (可放甲) f1[j|s][k] += f1[j][k];
      if (可放乙) f2[j][k|s] += f2[j][k];
    }
    dp = f1 + f2 - dp;  // 合并并去重
  }
  ```

### 2. 翼德天尊（4星）
- **亮点**：详细解释大质数分组与滚动数组优化，适合初学者。
- **关键点**：按大质数排序后分组处理，避免重复枚举。

### 3. ethan_zhou（4星）
- **亮点**：优化状态枚举至3^8，减少无效计算，复杂度更低。
- **技巧**：只枚举合法状态（j & k = 0），跳过冲突情况。

---

## 核心代码实现
### 关键逻辑（Orion545简化版）
```cpp
struct node { int val, big, S; };
sort(a+2, a+n+1, cmp);  // 按大质数排序
dp[0][0] = 1;
for (int i=1; i<n; i++) {
    if (新大质数组开始) {
        memcpy(f1, dp, sizeof(dp));
        memcpy(f2, dp, sizeof(dp));
    }
    // 转移当前数到f1/f2
    for (int j=255; j>=0; j--) {
        for (int k=255; k>=0; k--) {
            if (可放甲) f1[j|s][k] += f1[j][k];
            if (可放乙) f2[j][k|s] += f2[j][k];
        }
    }
    if (大质数组结束) {
        for (所有状态) 
            dp[j][k] = f1[j][k] + f2[j][k] - dp[j][k];
    }
}
```

---

## 同类型题目推荐
1. **P2709 小Z的礼物**：状压DP处理覆盖问题。
2. **P2831 愤怒的小鸟**：状态压缩优化抛物线选择。
3. **P3959 宝藏**：状压DP处理树形结构代价。

---

## 个人心得摘录
- **调试教训**：合并`f1`和`f2`时必须减去初始`dp`，否则重复计数。
- **思维突破**：大质数分组处理避免同时选择，是降低复杂度的关键。

---

## 复古像素动画设计
### 实现思路（伪代码）
```javascript
// Canvas绘制状态网格
function drawState(j, k) {
    for (let i=0; i<8; i++) {
        fillStyle = (j & (1<<i)) ? '#FF0000' : '#00FF00';  // 甲的红/乙的绿
        drawRect(i*20, 0, 18, 18);  // 小质数状态块
    }
    // 大质数组紫色标记
    if (currentBigPrime) drawCircle(bigPrimeX, 50, 10, '#800080');
}

// 音效触发
function playSound(type) {
    if (type === 'step') beep(440, 50);  // 步进音
    if (type === 'merge') beep(880, 100); // 合并音
}
```

---
处理用时：82.17秒
# 题目信息

# [SDOI2010] 古代猪文

## 题目背景

“在那山的那边海的那边有一群小肥猪。他们活泼又聪明，他们调皮又灵敏。他们自由自在生活在那绿色的大草坪，他们善良勇敢相互都关心……”

——选自猪王国民歌


很久很久以前，在山的那边海的那边的某片风水宝地曾经存在过一个猪王国。猪王国地理位置偏僻，实施的是适应当时社会的自给自足的庄园经济，很少与外界联系，商贸活动就更少了。因此也很少有其他动物知道这样一个王国。

猪王国虽然不大，但是土地肥沃，屋舍俨然。如果一定要拿什么与之相比的话，那就只能是东晋陶渊明笔下的大家想象中的桃花源了。猪王勤政爱民，猪民安居乐业，邻里和睦相处，国家秩序井然，经济欣欣向荣，社会和谐稳定。和谐的社会带给猪民们对工作火红的热情和对未来的粉色的憧憬。

小猪iPig是猪王国的一个很普通的公民。小猪今年10岁了，在大肥猪学校上小学三年级。和大多数猪一样，他不是很聪明，因此经常遇到很多或者稀奇古怪或者旁人看来轻而易举的事情令他大伤脑筋。小猪后来参加了全猪信息学奥林匹克竞赛(Pig Olympiad in Informatics, POI)，取得了不错的名次，最终保送进入了猪王国大学(Pig Kingdom University, PKU)深造。

现在的小猪已经能用计算机解决简单的问题了，比如能用P++语言编写程序计算出A + B的值。这个“成就”已经成为了他津津乐道的话题。当然，不明真相的同学们也开始对他刮目相看啦~

小猪的故事就将从此展开，伴随大家两天时间，希望大家能够喜欢小猪。


## 题目描述

猪王国的文明源远流长，博大精深。

iPig 在大肥猪学校图书馆中查阅资料，得知远古时期猪文文字总个数为 $n$。当然，一种语言如果字数很多，字典也相应会很大。当时的猪王国国王考虑到如果修一本字典，规模有可能远远超过康熙字典，花费的猪力、物力将难以估量。故考虑再三没有进行这一项劳猪伤财之举。当然，猪王国的文字后来随着历史变迁逐渐进行了简化，去掉了一些不常用的字。

iPig 打算研究古时某个朝代的猪文文字。根据相关文献记载，那个朝代流传的猪文文字恰好为远古时期的 $1/k$，其中 $k$ 是 $n$ 的一个正约数（可以是 $1$ 或 $n$）。不过具体是哪 $1/k$，以及 $k$ 是多少，由于历史过于久远，已经无从考证了。

iPig 觉得只要符合文献，每一种 $k|n$ 都是有可能的。他打算考虑到所有可能的 $k$。显然当 $k$ 等于某个定值时，该朝的猪文文字个数为 $n/k$。然而从 $n$ 个文字中保留下 $n/k$ 个的情况也是相当多的。iPig 预计，如果所有可能的 $k$ 的所有情况数加起来为 $p$ 的话，那么他研究古代文字的代价将会是 $g^p$。

现在他想知道猪王国研究古代文字的代价是多少。由于 iPig 觉得这个数字可能是天文数字，所以你只需要告诉他答案除以 $999911659$ 的余数就可以了。


## 说明/提示

#### 数据规模与约定
- 对于 $10\%$ 的数据，$1\le n \le 50$；  
- 对于 $20\%$ 的数据，$1\le n \le 1000$；  
- 对于 $40\%$ 的数据，$1\le n \le 10^5$；  
- 对于 $100\%$ 的数据，$1\le n,g \le 10^9$。


## 样例 #1

### 输入

```
4 2```

### 输出

```
2048```

# AI分析结果



### 算法分类
**组合数学 + 数论 (费马小定理、Lucas定理、中国剩余定理)**

---

### 题解思路与算法要点

1. **费马小定理简化指数**  
   题目要求计算 \( G^{\sum_{d|n} \binom{n}{d}} \mod 999911659 \)。由于 \( 999911659 \) 是质数，当 \( G \neq 999911659 \) 时，利用费马小定理将指数对 \( 999911658 \) 取模，将问题转化为求 \( \sum_{d|n} \binom{n}{d} \mod 999911658 \)。

2. **质因数分解与Lucas定理**  
   \( 999911658 = 2 \times 3 \times 4679 \times 35617 \)。对每个质因数 \( p \)，预处理阶乘和逆元，使用 Lucas 定理计算组合数模 \( p \) 的值。枚举 \( n \) 的所有约数 \( d \)，累加组合数模 \( p \) 的结果。

3. **中国剩余定理合并结果**  
   将每个质因数下的模数结果通过中国剩余定理合并，得到最终指数，再计算快速幂。

---

### 最优思路与技巧提炼

1. **分治策略**  
   将大模数分解为小质数，分治处理每个质数的组合数求和问题，降低计算复杂度。

2. **Lucas定理优化组合数计算**  
   对于每个质数 \( p \)，预处理阶乘和逆元，递归分解组合数 \( \binom{n}{d} \mod p \)。

3. **约数枚举优化**  
   仅遍历到 \( \sqrt{n} \)，同时处理 \( d \) 和 \( n/d \)，避免重复计算。

---

### 核心代码实现

```cpp
#include <cstdio>
#define MOD 999911659
#define Mod 999911658
typedef long long LL;
const int p[] = {2, 3, 4679, 35617};

LL fac[4][36000], inv[4][36000];

LL pow_mod(LL a, LL b, LL p) {
    LL res = 1;
    for (; b; b >>= 1) {
        if (b & 1) res = res * a % p;
        a = a * a % p;
    }
    return res;
}

void init(int id, int p) { // 预处理阶乘和逆元
    fac[id][0] = inv[id][0] = 1;
    for (int i = 1; i < p; ++i) {
        fac[id][i] = fac[id][i-1] * i % p;
        inv[id][i] = pow_mod(fac[id][i], p-2, p);
    }
}

LL C(LL n, LL m, int id, int p) { // 组合数模p
    if (n < m) return 0;
    return fac[id][n] * inv[id][m] % p * inv[id][n-m] % p;
}

LL lucas(LL n, LL m, int id, int p) { // Lucas定理递归计算
    if (m == 0) return 1;
    return C(n % p, m % p, id, p) * lucas(n / p, m / p, id, p) % p;
}

LL solve(LL n, int id, int p) { // 计算约数组合数和模p
    LL sum = 0;
    for (LL i = 1; i*i <= n; ++i) {
        if (n % i) continue;
        sum = (sum + lucas(n, i, id, p)) % p;
        if (i*i != n)
            sum = (sum + lucas(n, n/i, id, p)) % p;
    }
    return sum;
}

LL CRT(LL a[]) { // 中国剩余定理合并
    LL res = 0;
    for (int i = 0; i < 4; ++i) {
        LL m = Mod / p[i];
        res = (res + a[i] * m % Mod * pow_mod(m, p[i]-2, p[i])) % Mod;
    }
    return res;
}

int main() {
    LL n, g, a[4];
    scanf("%lld%lld", &n, &g);
    if (g == MOD) { puts("0"); return 0; }
    for (int i = 0; i < 4; ++i) {
        init(i, p[i]);
        a[i] = solve(n, i, p[i]);
    }
    LL ans = pow_mod(g, CRT(a), MOD);
    printf("%lld\n", ans);
    return 0;
}
```

---

### 可视化与算法演示

**算法步骤动态演示：**

1. **质因数分解**  
   将 \( 999911658 \) 分解为 \( 2 \times 3 \times 4679 \times 35617 \)，展示分解过程。

2. **预处理阶乘与逆元**  
   对每个质数 \( p \)，动态显示阶乘数组和逆元数组的生成过程。

3. **枚举约数计算组合数**  
   高亮当前遍历的约数 \( d \)，递归显示 Lucas 定理的分步计算。

4. **中国剩余定理合并**  
   动态展示同余方程组的合并过程，显示每个质数对应的模数和余数。

**复古像素风格设计：**

- **颜色方案**：使用 8-bit 风格，质因数分解步骤用不同颜色区分质数。
- **Canvas 动画**：网格显示组合数计算，递归步骤以像素块展开。
- **音效**：关键步骤（如找到约数、完成合并）触发 8-bit 音效。

---

### 相似题目推荐

1. **P3807 【模板】卢卡斯定理**  
   练习 Lucas 定理的基础应用。

2. **P3868 TJOI2009 猜数字**  
   中国剩余定理的典型题目。

3. **P1313 计算系数**  
   组合数取模与快速幂的结合应用。

---
处理用时：120.32秒
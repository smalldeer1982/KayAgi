# 题目信息

# [SDOI2015] 序列统计

## 题目描述

小C有一个集合 $S$，里面的元素都是小于 $m$ 的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为 $n$ 的数列，数列中的每个数都属于集合 $S$。  

小C用这个生成器生成了许多这样的数列。但是小C有一个问题需要你的帮助：给定整数 $x$，求所有可以生成出的，且满足数列中所有数的乘积 $\bmod \ m$ 的值等于 $x$ 的不同的数列的有多少个。  

小C认为，两个数列 $A$ 和 $B$ 不同，当且仅当 $\exists i \text{ s.t. } A_i \neq B_i$。另外，小C认为这个问题的答案可能很大，因此他只需要你帮助他求出答案对 $1004535809$ 取模的值就可以了。


## 说明/提示

【样例说明】

可以生成的满足要求的不同的数列有(1,1,1,1)、(1,1,2,2)、(1,2,1,2)、(1,2,2,1)、(2,1,1,2)、(2,1,2,1)、(2,2,1,1)、(2,2,2,2)。

【数据规模和约定】

对于 $10\%$ 的数据，$1\le n \le 1000$；   
对于 $30\%$ 的数据，$3 \le m \le 100$；    
对于 $60\%$ 的数据，$3 \le m \le 800$；   
对于 $100\%$ 的数据，$1 \le n \le 10^9$，$3 \le m \le 8000$，$1\le x < m$。   
$m$ 为质数，输入数据保证集合 $S$ 中元素不重复。


## 样例 #1

### 输入

```
4 3 1 2
1 2```

### 输出

```
8```

# AI分析结果



# 算法分类：数论与多项式快速幂结合NTT

---

## 题解思路与算法要点

### 核心思路
1. **原根转换乘法为加法**  
   利用质数原根的性质，将集合元素映射为原根的指数，使乘积问题转化为指数相加问题。
2. **生成函数与多项式快速幂**  
   构造生成函数表示选数的方案数，通过NTT加速多项式乘法，结合快速幂处理大次数n。
3. **循环卷积处理**  
   由于指数在模(m-1)意义下运算，需在每次卷积后对高位结果取模累加。

### 解决难点
- **原根查找**：暴力枚举验证，找到使各次幂不重复的最小原根。
- **多项式快速幂**：采用倍增思想分解n的二进制位，每次平方后处理循环卷积。
- **NTT优化**：预处理单位根，分治FFT减少计算量，处理模数1004535809的特殊性质。

---

## 题解评分（≥4星）

### 1. ZigZagKmp（⭐⭐⭐⭐⭐）
- **亮点**：详细推导原根转换过程，类比加法问题引入多项式卷积，代码注释清晰。
- **代码实现**：显式处理循环卷积的高位累加，倍增法分解快速幂步骤。

### 2. 何俞均（⭐⭐⭐⭐）
- **亮点**：代码简洁，包含原根预处理的优化步骤，NTT封装成独立模块。
- **代码片段**：通过`get_G`函数高效查找原根，倍增法合并结果。

### 3. Kelin（⭐⭐⭐⭐）
- **亮点**：数学公式与代码对应明确，强调原根转换的数学证明，提供调试案例。
- **代码技巧**：使用`map`存储对数映射，避免重复计算。

---

## 最优思路提炼

### 关键步骤
1. **原根映射**  
   将集合S中每个非零元素转换为原根的指数，构建初始多项式。
2. **多项式快速幂**  
   使用NTT加速多项式乘法，每次平方后处理高位项的循环累加。
3. **结果查询**  
   将目标x转换为原根指数，从最终多项式中提取对应系数。

### 核心代码实现
```cpp
// 原根预处理
int getG(int m) {
    int phi = m-1; vector<int> factors;
    for(int i=2;i*i<=phi;++i) if(phi%i==0) {
        factors.push_back(i);
        while(phi%i == 0) phi /= i;
    }
    if(phi > 1) factors.push_back(phi);
    for(int g=2;;++g) {
        bool valid = true;
        for(auto p : factors) 
            if(fpow(g, (m-1)/p, m) == 1) { valid=false; break; }
        if(valid) return g;
    }
}

// NTT快速幂核心
void multiply(int *a, int *b, int *res) {
    static ll tmp[N];
    for(int i=0; i<2*m; ++i) tmp[i] = 0;
    for(int i=0; i<m; ++i) if(a[i])
        for(int j=0; j<m; ++j) if(b[j]) 
            tmp[i+j] = (tmp[i+j] + 1LL*a[i]*b[j]) % MOD;
    for(int i=0; i<2*m-1; ++i) 
        res[i%(m-1)] = (res[i%(m-1)] + tmp[i]) % MOD;
}

void power(int *base, int exp, int *result) {
    result[0] = 1;
    while(exp) {
        if(exp&1) multiply(result, base, result);
        multiply(base, base, base);
        exp >>= 1;
    }
}
```

---

## 类似题目推荐
1. **P5488 差分与前缀和**  
   - 利用生成函数与多项式快速幂求解数列操作后的结果。
2. **P3338 力**  
   - FFT优化卷积形式的问题，涉及多项式乘法与物理背景。
3. **P4002 生成树计数**  
   - 生成函数与多项式技术在图论中的应用，需快速计算生成树方案。

---

## 可视化设计（复古像素风格）

### 动画流程
1. **原根映射阶段**  
   - 像素方块表示集合元素，转换为原根指数后显示为不同颜色。
2. **多项式乘法阶段**  
   - 网格显示多项式系数，每次NTT后高位项以闪光效果累加到低位。
3. **快速幂步骤**  
   - 二进制位分解动画，当前处理位高亮，卷积结果动态更新。

### 交互设计
- **控制面板**：8位风格按钮，调节动画速度（龟速/正常/闪电）。
- **音效**：  
  - 方块转换时播放“哔”声，正确累加播放上升音阶，错误时低沉音效。
- **自动演示**：AI自动运行各步骤，关键节点暂停并显示提示文字。

---

## 核心算法演示（伪代码）
```javascript
// 伪代码示例：原根转换与NTT步骤
function visualize() {
    let elements = S.map(x => pow(g, log_g[x], m)); // 原根映射
    drawPixelGrid(elements, {colorMap: 'heat'});    // 像素风格显示

    let poly = initializePolynomial(elements);      // 初始多项式
    while(n > 0) {
        if(n & 1) {
            animateConvolution(poly, result);       // NTT乘法动画
            playSound('blip');
        }
        animateSquaring(poly);                      // 平方步骤动画
        n >>= 1;
    }
    highlightFinalResult(x_index);                  // 高亮目标系数
}
```

---

## 总结
本题通过原根转换将乘积问题转化为多项式卷积，结合NTT与快速幂高效求解。关键点在于数学转换与多项式优化的结合，需注意循环卷积处理与模运算细节。推荐从ZigZagKmp的推导入手，逐步理解代码实现中的数学思想。

---
处理用时：77.60秒
# 题目信息

# [SDOI2016] 数字配对

## 题目描述

有 $n$ 种数字，第 $i$ 种数字是 $a_i$、有 $b_i$ 个，权值是 $c_i$。

若两个数字 $a_i$、$a_j$ 满足，$a_i$ 是 $a_j$ 的倍数，且 $a_i/a_j$ 是一个质数，

那么这两个数字可以配对，并获得 $c_i \times c_j$ 的价值。

一个数字只能参与一次配对，可以不参与配对。

在获得的价值总和不小于 $0$ 的前提下，求最多进行多少次配对。

## 说明/提示

测试点 $1 \sim 3$： $n \leq 10 $， $a_i \leq 10 ^ 9 $ ， $b_i = 1 $，$ | c_i | \leq 10 ^ 5$；   

测试点 $4 \sim 5$： $n \leq 200 $， $a_i \leq 10 ^ 9 $ ， $b_i \leq 10 ^ 5  $，$c_i = 0$；

测试点 $6 \sim 10$： $n \leq 200 $， $a_i \leq 10 ^ 9 $ ， $b_i \leq 10 ^ 5$ ，$ | c_i | \leq 10 ^ 5$。

## 样例 #1

### 输入

```
3
2 4 8
2 200 7
-1 -2 1
```

### 输出

```
4```

# AI分析结果



# 算法分类  
**网络流 - 最大费用最大流（贪心策略处理非负费用约束）**

---

## 综合分析与结论  
**核心思路**  
1. **质因数分解奇偶性分图**：将每个数分解质因数后统计总指数和 `cnt[i]`，按奇偶性分为二分图两部分，左部连源点，右部连汇点。  
2. **配对条件建模**：若两数满足倍数关系且 `cnt[i] = cnt[j] + 1`，则在左部（奇）与右部（偶）间连容量 `INF`、费用为 `c_i * c_j` 的边。  
3. **贪心处理费用约束**：每次增广优先选择费用最高的路径，若总费用即将变负，则按比例取最大可行流量。  

**难点突破**  
- **正确分图证明**：需确保所有配对关系仅存在于奇偶两部分之间，通过质因数分解后的指数差为1的性质保证。  
- **费用流终止条件**：增广过程中动态判断总费用是否非负，而非简单最大化流量或费用。  

**可视化设计**  
- **网络流动态构建**：用不同颜色区分奇偶节点（如红色奇数，蓝色偶数），动态显示边权（费用）和流量。  
- **增广路径高亮**：在SPFA寻找最长路时，以闪烁效果标记当前路径，显示费用累加过程。  
- **复古像素动画**：用8-bit风格网格表示节点，增广时路径流动伴随“滴答”音效，费用不足时播放警告音。  

---

## 题解清单（≥4星）  
1. **xyz32768（★★★★★）**  
   - **亮点**：直接基于SPFA实现最大费用流，简洁高效；贪心处理费用约束逻辑清晰。  
   - **代码关键**：`spfa`函数寻找最长路，`add`函数动态调整流量。  

2. **Orion545（★★★★☆）**  
   - **亮点**：详细推导质因数分图逻辑，代码注释完整；处理费用非负的贪心策略与调试经验分享。  
   - **心得引用**：“在费用变为负之前及时截断流量，避免反向计算错误。”  

3. **SoyTony（★★★★）**  
   - **亮点**：采用二分答案结合费用流验证，思路独特；代码模块化设计，适合扩展。  

---

## 最优思路提炼  
**核心代码片段**  
```cpp
bool add() { // 贪心处理费用非负
    ll fl = INF, delta;
    for (int e = frm[T]; e; e = frm[st[e]])
        fl = min(fl, cap[e]);
    delta = dis[T] * fl;
    if (sum + delta >= 0) { // 可全增广
        sum += delta; ans += fl;
        for (int e = frm[T]; e; e = frm[st[e]])
            cap[e] -= fl, cap[e^1] += fl;
        return 1;
    } else { // 部分增广后退出
        ans += sum / (-dis[T]);
        return 0;
    }
}
```

**完整代码（xyz32768版）**  
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
typedef long long ll;
const int N = 210, M = 5e5 + 5; const ll INF = 1ll << 61;
int n, a[N], b[N], c[N], cnt[N], ecnt = 1, nxt[M], adj[N], st[M], go[M],
frm[M], S, T, len, que[M];
ll cap[M], cost[M], dis[N], sum, ans; bool vis[N];
void add_edge(int u, int v, ll w, ll x) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; st[ecnt] = u;
    go[ecnt] = v; cap[ecnt] = w; cost[ecnt] = x;
    nxt[++ecnt] = adj[v]; adj[v] = ecnt; st[ecnt] = v;
    go[ecnt] = u; cap[ecnt] = 0; cost[ecnt] = -x;
}
int sigma(int n) {
    int i, S = sqrt(n), tot = 0; for (i = 2; i <= S; i++)
        while (n % i == 0) n /= i, tot++; if (n > 1) tot++; return tot;
}
bool spfa() {
    int i; for (i = S; i <= T; i++) vis[i] = 0, dis[i] = -INF;
    dis[que[len = 1] = S] = 0; for (i = 1; i <= len; i++) {
        int u = que[i]; vis[u] = 0;
        for (int e = adj[u], v; e; e = nxt[e])
            if (cap[e] && dis[u] + cost[e] > dis[v = go[e]]) {
                dis[v] = dis[u] + cost[frm[v] = e];
                if (!vis[v]) vis[que[++len] = v] = 1;
            }
    }
    return dis[T] > -INF;
}
bool add() {
    ll fl = INF, delta; for (int e = frm[T]; e; e = frm[st[e]])
        fl = min(fl, cap[e]); delta = dis[T] * fl;
    if (sum + delta >= 0) {
        sum += delta; ans += fl;
        for (int e = frm[T]; e; e = frm[st[e]])
            cap[e] -= fl, cap[e^1] += fl; return 1;
    }
    else return ans += sum / (-dis[T]), 0;
}
ll solve() {
    while (spfa() && add()); return ans;
}
int main() {
    int i, j; n = read(); for (i = 1; i <= n; i++) a[i] = read();
    for (i = 1; i <= n; i++) b[i] = read();
    for (i = 1; i <= n; i++) c[i] = read(); S = 1; T = n + 2;
    for (i = 1; i <= n; i++) cnt[i] = sigma(a[i]);
    for (i = 1; i <= n; i++) if (cnt[i] & 1) add_edge(S, i + 1, b[i], 0);
        else add_edge(i + 1, T, b[i], 0);
    for (i = 1; i <= n; i++) if (cnt[i] & 1) for (j = 1; j <= n; j++)
        if ((cnt[i] + 1 == cnt[j] && a[j] % a[i] == 0) ||
            (cnt[j] + 1 == cnt[i] && a[i] % a[j] == 0))
                add_edge(i + 1, j + 1, INF, 1ll * c[i] * c[j]);
    cout << solve() << endl; return 0;
}
```

---

## 相似题目推荐  
1. **P4015 运输问题** - 费用流典型应用  
2. **P2770 航空路线问题** - 节点容量与费用处理  
3. **P3358 最长k可重区间集** - 带权区间选择与网络流建模  

---

## 可视化实现（伪代码）  
```javascript
// Canvas初始化
const canvas = document.getElementById('network');
const ctx = canvas.getContext('2d');
const nodes = [
    {id: 'S', x: 50, y: 200, type: 'source'},
    {id: 'T', x: 750, y: 200, type: 'sink'},
    ...Array.from({length: n}, (_,i) => ({
        id: i+1, 
        x: cnt[i]%2 ? 200 : 600, 
        y: 100 + i*40,
        cnt: cnt[i],
        c: c[i]
    }))
];

function drawEdge(from, to, cost) {
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.strokeStyle = cost > 0 ? '#0f0' : '#f00'; // 正费用绿，负红
    ctx.stroke();
}

function animateFlow(path) {
    path.forEach((edge, i) => {
        setTimeout(() => {
            edge.el.classList.add('active'); // 高亮当前增广边
            playSound('blip'); // 播放音效
            updateCostDisplay(edge.cost); // 更新总费用
        }, i * 500);
    });
}
```

---

## 个人心得摘录  
> **Orion545调试经验**：  
> “当发现费用流结果异常时，优先检查质因数分解是否正确，特别是处理大质数时的边界情况。”  
>  
> **SoyTony优化思路**：  
> “将边权取反跑最小费用流，避免处理负数时的逻辑混乱，但需注意最终结果符号处理。”

---
处理用时：105.50秒
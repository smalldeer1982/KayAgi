# 题目信息

# [JSOI2008] 最小生成树计数

## 题目描述

现在给出了一个简单无向加权图。你不满足于求出这个图的最小生成树，而希望知道这个图中有多少个不同的最小生成树。（如果两棵最小生成树中至少有一条边不同，则这两个最小生成树就是不同的）。由于不同的最小生成树可能很多，所以你只需要输出方案数对 $31011$ 的模就可以了。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le n \le 100$，$1 \le m \le 1000$，$1\leq c_i\leq 10^9$。

## 样例 #1

### 输入

```
4 6
1 2 1
1 3 1
1 4 1
2 3 2
2 4 1
3 4 1```

### 输出

```
8
```

# AI分析结果



# **算法分类**
**最小生成树性质 + 组合计数**

---

# **题解思路与核心分析**

## **核心定理与思路**
1. **定理**: 所有最小生成树中，相同权值的边数量相等。  
   - 推论：不同权值的边贡献独立，可用乘法原理组合。
2. **解法步骤**：
   - **Step1**：用 Kruskal 算法生成一个最小生成树，记录每种权值的边数 `cnt[w]`。
   - **Step2**：对每种权值 `w`，计算其边集的合法组合方式数（保证选 `cnt[w]` 条边且不形成环）。
   - **Step3**：所有权值的方案数相乘得到最终结果。

## **关键难点与解决**
1. **如何高效计算每种权值的方案数？**
   - **暴力枚举**：适用于权值边数 ≤10（复杂度 2^10=1024）。
   - **矩阵树定理**：缩点后构造基尔霍夫矩阵，求行列式（复杂度 O(n³)）。
2. **正确缩点与连通性维护**：
   - 对非当前权值的边进行缩点（并查集维护），确保当前权值的边在新图上独立计算。

---

# **题解评分 (≥4星)**

| 题解作者       | 评分 | 亮点与简评                                                                 |
|----------------|------|----------------------------------------------------------------------------|
| smarthehe      | ★★★★☆ | 矩阵树定理实现，复杂度分析清晰，代码完整。缩点与行列式处理详细。           |
| 老K            | ★★★★☆ | 暴力枚举实现简洁，并查集回溯逻辑明确，适合小规模数据。                     |
| Siyuan         | ★★★★☆ | 提供两种解法代码，矩阵树实现高效，注释详细，适合不同场景参考。             |

---

# **最优思路与技巧**

1. **分权值处理**  
   - 将边按权值分组，每组独立计算方案数，避免全局复杂度爆炸。
2. **缩点优化**  
   - 非当前权值的边预先合并成连通块，转化为更小规模的图，降低计算量。
3. **并查集回溯**  
   - 暴力枚举时禁用路径压缩，通过备份/恢复状态实现高效回溯。

---

# **类似题目推荐**
1. [P2144 [FJOI2007] 轮状病毒](https://www.luogu.com.cn/problem/P2144)  
   - 基尔霍夫矩阵求生成树数量。
2. [P4209 学习小组](https://www.luogu.com.cn/problem/P4209)  
   - 结合最小生成树与组合计数。
3. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)  
   - 基础 Kruskal 算法练习。

---

# **核心代码实现**

## **暴力枚举法（老K题解）**
```cpp
void dfs(int x, int now, int tot) {
    if (now > a[x].r + 1) {
        if (tot == a[x].v) sum++;
        return;
    }
    int fx = find(edge[now].u), fy = find(edge[now].v);
    if (fx != fy) { // 选当前边
        fa[fx] = fy;
        dfs(x, now + 1, tot + 1);
        fa[fx] = fx; // 回溯
    }
    dfs(x, now + 1, tot); // 不选当前边
}
```

## **矩阵树定理（smarthehe题解）**
```cpp
int treecnt() { // 基尔霍夫行列式计算
    int ans = 1;
    for (int i = 1; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            while (mat[j][i]) { // 辗转相除消元
                int div = mat[i][i] / mat[j][i];
                for (int k = i; k < n; ++k)
                    mat[i][k] = (mat[i][k] - 1LL * mat[j][k] * div % MOD + MOD) % MOD;
                swap(mat[i], mat[j]);
                ans *= -1;
            }
        }
        ans = 1LL * ans * mat[i][i] % MOD;
    }
    return (ans + MOD) % MOD;
}
```

---

# **可视化与游戏化设计**

## **动画方案**
1. **Kruskal 动态演示**  
   - **Canvas 网格**：节点以像素方块表示，边按权值颜色区分。
   - **连通块合并**：选中边后，两节点方块合并为同一颜色块，播放“连接”音效。
2. **权值阶段处理**  
   - 当前权值边高亮，其他边灰化，缩点后显示为聚合块。
3. **矩阵树计算**  
   - 基尔霍夫矩阵动态生成，行列式消元步骤逐步显示，矩阵元素变化高亮。

## **复古像素风格**
- **调色板**：8-bit 风格，绿色（连通）、红色（环边）、黄色（当前边）。
- **音效**：  
  - 成功选边：短促“哔”声（Web Audio 合成）。
  - 计算完成：8-bit 胜利旋律。
- **AI 自动演示**：按权值阶段自动执行，用户可暂停/调速观察。

---

# **总结**
通过分治权值、缩点优化与组合计数，最小生成树计数问题被高效解决。暴力与矩阵树法互补，前者适合小数据快速实现，后者理论更普适。可视化设计增强理解，复古风格提升学习趣味性。

---
处理用时：77.21秒
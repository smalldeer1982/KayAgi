# 题目信息

# 公主の#19准备月考

## 题目背景

公主在玩完游戏后，也要月考了。（就算是公主也要月考啊QWQ）


## 题目描述

公主的文综太差了，全校排名1100+（全校就1100多人），她分析了好久，发现她如果把所有时间放在选择题上，得分会比较好一点。

文综题目共有n个，编号从1到n

公主给每个题目算出来了一个预估值Ai，她认为，一段连续题目的答案会在它们的预估值的gcd和lcm之间；有时候她的想法不同了，一些题目的预估值会改变；有时候，会出现多选题，多选题的答案数量就是一段连续题目答案的预估值的公约数的个数。

具体来说，对于一个数列，有四种操作：

L x y p 表示公主询问区间[x,y]的数字的lcm对p取模之后的值

G x y p 表示公主询问区间[x,y]的数字的gcd对p取模之后的值

C x y c 表示公主改变区间[x,y]的数字的值，统一为c

S x y p 表示公主询问区间[x,y]的数字的公因数个数对p取模之后的值

公主月考不能挂科，不然她就不能学习OI了（假的），所以请你帮帮她吧！


## 说明/提示

对于30%的数据，1<=n,q<=1000

对于另外20%的数据，1<=n<=1000，1<=q<=100000

对于另外20%的数据，1<=n<=100000，1<=q<=100000，保证没有修改操作

对于100%的数据，1<=n<=300000，1<=q<=300000

保证任何时刻每个题目的预估值都在[1,100]之间，答案取模之后不超过int


## 样例 #1

### 输入

```
10 10
42 68 35 1 70 25 79 59 63 65 
L 2 6 28
L 2 6 43
G 2 7 5
G 3 4 83
L 7 9 96
G 2 7 39
S 3 8 100
L 4 5 12
G 4 4 65
L 2 4 69```

### 输出

```
0
32
1
1
75
1
1
10
1
34```

# AI分析结果



## 算法分类选择
线段树 + 状态压缩

## 题解思路、算法要点与解决难点

### 核心思路
将数值范围[1,100]内的质因数分解结果进行二进制位压缩存储，利用线段树维护区间GCD/LCM的质因数状态，通过位运算实现高效合并。

### 算法要点
1. **质因数位压缩**：每个质数的次数用特定位数存储（如2^6用3位，3^4用3位），25个质数共占31位
2. **线段树节点设计**：每个节点存储GCD/LCM的压缩状态，合并时取min/max次数
3. **快速状态解析**：通过位掩码快速提取质数次数，计算实际数值的模值

### 解决难点
1. **状态压缩设计**：精细分配二进制位应对不同质数的最大次数
2. **高效合并操作**：使用位运算同时处理多个质数的min/max比较
3. **模数随机性处理**：动态计算模值而非预存结果，适应任意模数要求

## 题解评分 ≥4星

### 1. Vingying (5⭐)
- 亮点：极致位压缩设计，31位int存储所有质数状态
- 优化：快速幂分块处理高频质数，内存效率极高
- 代码结构清晰，包含详细状态解析逻辑

### 2. 玫葵之蝶 (4⭐)
- 亮点：官方标准解法，理论分析透彻
- 优势：位运算优化思路清晰，适合教学理解
- 不足：代码示例不完整，实践指导性较弱

### 3. Hadtsti (4⭐)
- 亮点：非压缩直接记录次数，逻辑直观
- 优势：代码可读性强，方便调试理解
- 缺点：空间效率较低，大数据时可能超限

## 最优思路提炼
**双状态位压缩法**：
1. 预处理将每个数转换为两个int：
   - gcd_state：各质数最小次数位模式
   - lcm_state：各质数最大次数位模式
2. 线段树合并时：
   ```cpp
   gcd_child1 & gcd_child2  // 取各质数最小次数
   lcm_child1 | lcm_child2  // 取各质数最大次数
   ```
3. 查询时动态解析位模式，快速幂计算模值

## 同类型题套路
- 区间统计型问题（CF1458B）
- 带特殊值域的线段树优化（LOJ 6029）
- 位压缩处理多维状态（SPOJ KGSS）

## 推荐练习题
1. P1890 GCD区间（基础GCD线段树）
2. P3373 区间乘加（复合操作线段树）
3. CF987C Three displays（多维状态维护）

## 算法可视化设计

### 动画方案
```javascript
class PrimeVisualizer {
  constructor(canvas) {
    this.blocks = [];
    this.ctx = canvas.getContext('2d');
    this.initGrid(300000); // 模拟30万元素
  }

  // 核心渲染逻辑
  renderOperation(type, l, r) {
    this.highlightRange(l, r); // 红色高亮操作区间
    this.showPrimeBits(l, r);  // 显示质数位分布
    this.animateMerge(l, r);  // 动态合并子区间状态
  }

  // 位模式可视化
  showPrimeBits(l, r) {
    const primes = ['2³', '3³', '5²', '7²', '11',..., '97'];
    this.blocks.slice(l, r).forEach(block => {
      drawBits(block.gcd_state, 'green');  // GCD位用绿色
      drawBits(block.lcm_state, 'blue');   // LCM位用蓝色
    });
  }
}
```

### 复古特效
- **8位音效**：合并成功时播放《超级马里奥》金币声，错误时播放《魂斗罗》中弹声
- **像素动画**：用16x16像素块表示质数位，不同颜色区分2/3/5/7等主要质数
- **自动演示**：AI自动生成随机查询，展示位模式合并过程

## 核心代码片段
```cpp
// 质数位压缩预处理
int cal(int tmp) {
    int v = 0;
    for(int i=0; i<25; ++i) {
        int cnt = 0;
        while(tmp % pri[i] == 0) tmp /= pri[i], cnt++;
        v |= (cnt << b[i]); // b[]预存各质数的位偏移
    }
    return v;
}

// 线段树合并
void pushup(int id) {
    t[id].gcd = calgcd(t[ls].gcd, t[rs].gcd);
    t[id].lcm = callcm(t[ls].lcm, t[rs].lcm);
}

// 动态计算模值
int compute(int state, int mod) {
    int res = 1;
    for(int i=0; i<25; ++i) {
        int cnt = (state >> b[i]) & mask[i];
        res = res * fast_pow(pri[i], cnt, mod) % mod;
    }
    return res % mod;
}
```

完整代码详见原始题解，重点在于位压缩预处理和线段树的高效状态合并。

---
处理用时：71.59秒
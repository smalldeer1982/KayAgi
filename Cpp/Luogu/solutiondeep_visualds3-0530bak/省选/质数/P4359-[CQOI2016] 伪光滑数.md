# 题目信息

# [CQOI2016] 伪光滑数

## 题目描述

若一个大于 $1$ 的整数 $M$ 的质因数分解有 $k$ 项，其最大的质因子为 $a_k$ ，并且满足 $a_{k}^{k} \le N$，$a_k < 128$，我们就称整数 $M$ 为 $N$ - 伪光滑数。

现在给出 $N$，求所有整数中，第 $K$ 大的 $N$ - 伪光滑数。

### 题意澄清

设 $M = 36 = 2^2 \times 3^2$，则其对应的 $k = 4$，也就是说，对 $M$ 运用唯一分解定理，$M = \prod_{i=1}^n{p_i^{c_i}}$，$k = \sum_{i=1}^n{c_i}$。

第 $K$ 大为字面意思，是真的从大到小第 $K$ 个。

modified by expect2004 2020-11-25，这或许是他退役前对洛谷公共题库的最后一次贡献

## 说明/提示

对于 $30\%$ 的数据，$N \le 10^6$；  
对于 $100\%$ 的数据，$2 \le N \le 10^{18},1 \le K \le 800000$。保证至少有 $K$ 个满足要求的数。

## 样例 #1

### 输入

```
12345 20```

### 输出

```
9167```

# AI分析结果



**唯一算法分类**：贪心 + 优先队列（堆）

---

### **综合分析与结论**
#### **核心算法流程**
1. **初始候选集合**：枚举所有质数 $p<128$，计算其最大幂次 $k$ 满足 $p^k \leq N$，将 $p^k$ 作为初始候选值加入堆。
2. **贪心取最大**：每次取出堆顶元素（当前最大值），记录为第 $i$ 大的数。
3. **生成次大候选**：若当前数的最大质因子幂次 $>1$，将其替换为更小的质因子（如 $p_i \to p_j \ (j<i)$），生成新的候选值并加入堆。
4. **去重保证唯一性**：通过限制替换质因子的顺序（如只能替换为更小的质因子），避免生成重复候选值。

#### **可视化设计思路**
- **动画方案**：用网格表示堆结构，每个节点显示数值、最大质因子和幂次。弹出堆顶时高亮其分解式，替换质因子时用箭头动态展示替换过程。
- **颜色标记**：
  - **红色**：当前弹出的堆顶元素。
  - **绿色**：新生成的候选值，显示质因子变化。
- **复古风格**：使用 8-bit 像素字体和音效（如弹出时播放“滴”声，替换时播放“咔”声），堆结构以方块堆叠形式呈现，背景配 8-bit 循环音乐。

---

### **题解清单 (≥4星)**
1. **ycyaw（★★★★★）**  
   **亮点**：简洁高效，利用堆维护候选值并通过质因子替换生成新解。代码可读性极强，适合快速实现。  
   **核心代码**：初始生成质数幂次，替换时限制质因子顺序。
2. **龙翔凤翥（★★★★☆）**  
   **亮点**：结构清晰，四元组设计明确记录最大质因子和可替换范围，避免冗余计算。  
   **核心代码**：`q.push((node){now.t / now.x * p[i], now.x, now.y - 1, i})`。
3. **Yyxxxxx（★★★★☆）**  
   **亮点**：引入 `next` 字段优化替换顺序，通过质因子表预计算减少运行时开销。  
   **核心代码**：`q.push({tmp.val / tmp.maxp * p[i], tmp.maxp, tmp.k-1, i})`。

---

### **最优思路提炼**
- **贪心策略**：每次取最大候选值，动态生成次优解，保证第 $K$ 次弹出即为答案。
- **质因子替换规则**：只能将最大质因子替换为更小的质因子，避免重复且保证合法性。
- **堆维护技巧**：初始候选为单一质因子幂次，后续操作仅需替换一个因子，复杂度可控。

---

### **同类型题推荐**
1. **P2647 最大收益**：贪心+堆维护候选解。
2. **P2048 超级钢琴**：多路归并思想，类似质因子替换的分段处理。
3. **P3545 [POI2012] HUR**：质因数分解与堆结合的最值问题。

---

### **可视化代码片段（JS Canvas）**
```javascript
// 绘制堆结构（复古像素风）
function drawHeap(heap) {
  ctx.fillStyle = "#2C3E50"; // 背景色
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  heap.forEach((node, i) => {
    const x = (i % 4) * 80 + 20; // 网格布局
    const y = Math.floor(i / 4) * 60 + 40;
    ctx.fillStyle = "#E74C3C"; // 节点颜色
    ctx.fillRect(x, y, 60, 40);
    ctx.fillStyle = "#ECF0F1"; // 文字颜色
    ctx.fillText(`Val:${node.val}`, x+5, y+15);
    ctx.fillText(`P:${node.p}`, x+5, y+30);
  });
}

// 播放音效（8-bit风格）
function playSound(type) {
  const osc = audioCtx.createOscillator();
  osc.type = 'square'; // 方波模拟8-bit音效
  osc.frequency.setValueAtTime(type === 'pop' ? 880 : 440, audioCtx.currentTime);
  osc.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.1);
}
```

---

### **个人心得摘录**
- **ycyaw**：通过限制替换顺序避免重复，是代码简洁的关键。  
  > “观察到要求的第K大的K较小，用堆维护即可覆盖所有可能。”
- **龙翔凤翥**：四元组设计让状态转移更直观。  
  > “钦定最大质数后，替换时遍历更小的质因子，保证不重不漏。”

---

### **核心算法演示（复古像素动画）**
1. **初始状态**：屏幕左侧显示质数表，右侧堆结构初始化为各质数的最大幂次。
2. **弹出堆顶**：堆顶方块闪烁红色，显示数值分解式（如 $127^3$），播放“滴”声。
3. **生成新解**：替换质因子时，原质因子方块缩小，新质因子从左侧表飞入，组合成新值后加入堆。
4. **自动模式**：点击“AI Run”后，算法自动执行，每步间隔可调，背景音乐为《超级马里奥》风格。

---
处理用时：72.43秒
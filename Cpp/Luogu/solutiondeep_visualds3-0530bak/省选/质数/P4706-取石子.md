# 题目信息

# 取石子

## 题目描述

现在 Yopilla 和 yww 要开始玩游戏！

他们在一条直线上标记了 $n$ 个点，从左往右依次标号为 $1, 2, ..., n$ 。然后在每个点上放置一些棋子，其中第 $i$ 个点放置了 $a_i$ 个棋子。接下来，从 Yopilla 开始操作，双方轮流操作，谁不能操作谁输。每次的操作是：当前操作方选定一个有棋子的点 $x$ ，然后选择至少一个点 $x$ 上的棋子，然后把这些棋子全都移动到点 $x / prime$ 上，其中 $prime$ 是一个质数，且 $prime \mid x$ 。

Yopilla 最初一次操作的策略是随机的：随机找到一个有棋子的点 $x$ ，随机选择正整数个棋子 $y$ ，随机转移到一个能转移到的点 $z$ 。所有棋子可以看作是一样的，换句话说：两种操作不同，当且仅当三元组 $(x, y, z)$ 不同。之后双方都按照最优策略来操作。

Yopilla 想要预测，他能够获胜的概率是多少，答案对 $998244353$ 取模。

## 说明/提示

样例解释：

$1$ 号点有 $3$ 个棋子，$2$ 号点有 $1$ 个棋子，$3$ 号点有 $2$ 个棋子。第一次操作的时候，能进行的有三种可能：将 $2$ 号点的 $1$ 个棋子移到 $1$ 号点，将 $3$ 号点的 $1$ 个棋子移到 $1$ 号点，将 $3$ 号点的 $2$ 个棋子移到一号点。而其中只有一种情况能使得 Yopilla 有必胜策略。所以答案为
$$\frac{1}{3} \equiv 332748118 \pmod {998244353}$$

对于 $20 \%$ 的数据，只有一个石子。

对于 $100 \%$ 的数据，$1 \le n \le {10} ^ 6, 0 \le a_i \le {10} ^ 9$ ，保证至少有一个不在一号点的石子。

## 样例 #1

### 输入

```
3
3 1 2```

### 输出

```
332748118```

# AI分析结果



---

**算法分类**：博弈论（阶梯Nim）

---

### **题解思路与算法要点**

**核心问题转化**：  
将每个点的质因数分解指数和的奇偶性视为阶梯Nim的奇偶层。移动石子相当于在奇偶层间转移，胜负由奇数层石子数的异或和决定。

**关键步骤**：
1. **预处理**：计算每个数的质因数个数 `sum[x]` 及其奇偶层 `odd[x]`（指数和的奇偶性）。
2. **初始异或和**：统计所有奇数层石子数的异或和 `SG`。
3. **总操作数**：所有点的 `a[i] * sum[i]` 之和。
4. **合法操作数**：
   - **奇层操作**：若移动后异或和为0，需将 `a[i]` 变为 `SG ^ a[i]`，分情况讨论：
     - **减少石子**：若目标值 `need < a[i]`，贡献为该点的质因数个数 `sum[i]`。
     - **增加石子**：若 `need > a[i]`，需从偶层父节点 `j = i*p` 取石子，统计符合条件的 `j` 数量。
5. **概率计算**：合法操作数除以总操作数，取模。

**解决难点**：
- **奇偶层判定**：通过线性筛预处理每个数的指数和奇偶性。
- **父节点枚举**：在合法操作中快速找到所有可能的偶层父节点 `j = i*p`。

---

### **题解评分与亮点**

1. **题解（作者：cyffff）**：★★★★★  
   - **亮点**：  
     - 代码简洁，预处理与分类讨论清晰。  
     - 利用线性筛高效计算奇偶层和质因数个数。  
     - 直接枚举质数处理父节点，避免复杂数据结构。  
   - **代码片段**：  
     ```cpp
     for (int i = 1; i <= n; i++) {
         if (odd[i]) {
             int need = SG ^ a[i];
             if (need == a[i]) continue;
             if (need < a[i]) sol = (sol + sum[i]) % mod;
             else {
                 for (int j = 1; j <= cnt && pri[j] * i <= n; j++) {
                     if (a[i * pri[j]] >= need - a[i]) sol++;
                 }
             }
         }
     }
     ```

---

### **最优思路提炼**
1. **阶梯Nim转化**：将质因数分解的奇偶性作为层，转化为标准阶梯Nim问题。
2. **奇偶层异或和**：胜负仅由奇数层石子数的异或和决定。
3. **动态调整策略**：根据目标值大小，分类讨论奇层减少或偶层增加石子的合法操作。

---

### **类似题目**
1. **洛谷 P4706**：阶梯Nim的变种，需结合数论预处理。  
2. **HDU 4315**：阶梯博弈的经典问题。  
3. **Codeforces 768E**：石子移动限制与奇偶性相关。

---

### **可视化算法演示**
**动画设计**：
- **像素风格**：用不同颜色区分奇偶层（奇层红色，偶层蓝色）。  
- **关键步骤**：  
  1. **预处理阶段**：绘制数轴，动态显示每个点的质因数分解和奇偶层。  
  2. **移动操作**：点击石子触发移动动画，展示路径 `x → x/p`，伴随音效。  
  3. **异或和更新**：实时显示当前异或和，若变为0则播放胜利音效。  
- **交互功能**：支持单步执行，调节动画速度，查看奇偶层分布。

---

### **核心代码实现**
```cpp
// 预处理奇偶层和质因数个数
inline void sieve(int n) {
    p[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!p[i]) {
            pri[++cnt] = i;
            sum[i] = 1;
            odd[i] = 1;
        }
        for (int j = 1; j <= cnt && i * pri[j] <= n; j++) {
            p[i * pri[j]] = 1;
            odd[i * pri[j]] = odd[i] ^ 1;
            if (i % pri[j] == 0) {
                sum[i * pri[j]] = sum[i];
                break;
            }
            sum[i * pri[j]] = sum[i] + 1;
        }
    }
}

// 统计合法操作数
int SG = 0, rnd = 0;
for (int i = 1; i <= n; i++) {
    if (odd[i]) SG ^= a[i];
    rnd = (rnd + 1ll * a[i] * sum[i]) % mod;
}
int sol = 0;
for (int i = 1; i <= n; i++) {
    if (odd[i]) {
        int need = SG ^ a[i];
        if (need == a[i]) continue;
        if (need < a[i]) sol = (sol + sum[i]) % mod;
        else {
            for (int j = 1; j <= cnt && pri[j] * i <= n; j++) {
                if (a[i * pri[j]] >= need - a[i]) sol++;
            }
        }
    }
}
```

---

**总结**：通过阶梯Nim的转化，结合数论预处理和分类讨论，高效计算合法操作数。关键点在于奇偶层判定和动态调整石子数的策略。

---
处理用时：363.86秒
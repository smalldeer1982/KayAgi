# 题目信息

# 「数学」约数个数和

## 题目描述

小 F 在数学课上与同学闲聊。

> 给你一个正整数，计算他的约数个数。

「你们竞赛就学这个啊？太简单了吧。」

「……」

> 给你一个正整数，计算他的所有约数的约数个数和。

「我想想……嗯，还是不难的。诶，你们竞赛还能报名吗？」

「……」

> 给你一个正整数，计算他的所有约数的所有约数的约数个数和。

「哎呀反正你们电脑总是能爆算出来的嘛，快给我说在哪报名。」

「……」

> 给你一个正整数，计算他的所有约数的所有约数的所有约数的约数个数和。

「有完没完了？」

「……」


被嘲讽的小 F 将这个问题交给了你，请展示你的爆算实力。

给你一个正整数 $N$，请计算 $N$ 的 $($所有约数的$)\times K$ 约数个数和。

答案可能很大，请输出对 $998244353$ 取模的结果。


## 说明/提示

### 样例 1, 2, 3 解释

$4,\ 0:$ $4$ 的约数 $\ 1\ 2\ 4$

$4,\ 1:$ $4$ 的所有约数的约数 $\ (1)\ (1\ 2)\ (1\ 2\ 4)$

$4,\ 2:$ $4$ 的所有约数的所有约数的约数 $((1))\ ((1)\ (1\ 2))\ ((1)\ (1\ 2)\ (1\ 2\ 4))$

### 子任务

子任务 $1(11 \mathrm{pts}) : N, K \leq 10 ^ 4$

子任务 $2(31 \mathrm{pts}) : N \leq 10 ^ 4$

子任务 $3(41 \mathrm{pts}) : N \leq 10 ^ 9$

子任务 $4(67 \mathrm{pts}) : 1 \leq N \leq 10 ^ {18}, 0 \leq K \leq 10^{18} $。

## 样例 #1

### 输入

```
4 0```

### 输出

```
3```

## 样例 #2

### 输入

```
4 1```

### 输出

```
6```

## 样例 #3

### 输入

```
4 2```

### 输出

```
10```

# AI分析结果



**算法分类**  
数学（积性函数、组合数学）

---

### **题解思路与算法要点**  
1. **积性函数分解**：答案函数为积性函数，可将N质因数分解后独立处理每个质因子的幂次。  
2. **递推转化组合数**：每个质因子幂次q经K次操作后的结果为组合数C(q+K+1, K+1)。  
3. **高效质因数分解**：针对大数N，使用Miller-Rabin和Pollard-Rho算法分解质因数。  
4. **组合数模计算**：利用模逆元处理分母，直接计算分子乘积并取模。  

**解决难点**  
- **大数分解**：传统试除法无法处理1e18的质数，需Pollard-Rho优化。  
- **组合数计算**：K可能极大（1e18），通过模运算和逆元处理高效计算。  
- **积性函数推导**：通过数学归纳或前缀和推导组合数表达式。  

---

### **题解评分（≥4星）**  
1. **WinXP（4星）**  
   - 思路清晰，结合积性函数和组合数推导。  
   - 代码简洁，但质因数分解未完全处理大质数。  
   - 核心逻辑：组合数模运算与逆元预处理。  

2. **小粉兔（5星）**  
   - 引入狄利克雷卷积，数学推导严谨。  
   - 指出Pollard-Rho的必要性，代码未完全展示但思路完整。  
   - 关键公式：f_k(p^q) = C(q+k+1, q)。  

3. **Soulist（5星）**  
   - 完整实现Miller-Rabin和Pollard-Rho，处理大数高效。  
   - 代码规范，组合数计算利用逆元与模运算。  
   - 核心代码段清晰，可操作性强。  

---

### **最优思路提炼**  
- **积性拆分**：将问题分解为质因子独立计算。  
- **组合数公式**：K次操作结果等价于组合数C(q+K+1, q)。  
- **模运算优化**：对K取模后计算分子，避免大数溢出。  
- **高效质因数分解**：使用Pollard-Rho处理大质数。  

---

### **同类型题推荐**  
1. **P2158 [SDOI2008] 仪仗队**（积性函数、欧拉函数）  
2. **P2524 约数研究**（约数性质、前缀和）  
3. **P1069 细胞分裂**（质因数分解、指数运算）  

---

### **代码核心实现**  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 998244353;
vector<ll> factors;

ll mod_mul(ll a, ll b, ll mod) {
    return (__int128)a * b % mod;
}

ll mod_pow(ll a, ll b, ll mod) {
    ll res = 1;
    for (; b; b >>= 1) {
        if (b & 1) res = mod_mul(res, a, mod);
        a = mod_mul(a, a, mod);
    }
    return res;
}

bool is_prime(ll n) {
    if (n < 2) return false;
    static int a[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};
    ll d = n-1; int s = 0;
    while (d % 2 == 0) d /= 2, s++;
    for (auto x : a) {
        if (x >= n) continue;
        ll t = mod_pow(x, d, n);
        if (t == 1 || t == n-1) continue;
        for (int i = 1; i < s; i++) {
            t = mod_mul(t, t, n);
            if (t == n-1) break;
        }
        if (t != n-1) return false;
    }
    return true;
}

ll pollards_rho(ll n) {
    if (n % 2 == 0) return 2;
    ll x = rand() % (n-1) + 1, c = rand() % (n-1) + 1;
    ll y = x, d = 1;
    while (d == 1) {
        x = (mod_mul(x, x, n) + c) % n;
        y = (mod_mul(y, y, n) + c) % n;
        y = (mod_mul(y, y, n) + c) % n;
        d = __gcd(abs(x - y), n);
    }
    return d;
}

void factorize(ll n) {
    if (n == 1) return;
    if (is_prime(n)) {
        factors.push_back(n);
        return;
    }
    ll d = pollards_rho(n);
    factorize(d);
    factorize(n/d);
}

int main() {
    ll N, K; cin >> N >> K;
    factorize(N);
    map<ll, int> cnt;
    for (auto p : factors) cnt[p]++;
    
    ll inv[70] = {1};
    for (int i = 1; i <= 60; ++i)
        inv[i] = mod_pow(i, MOD-2, MOD);
    
    ll ans = 1;
    K %= MOD;
    for (auto [p, q] : cnt) {
        ll res = 1;
        for (int i = 1; i <= q; ++i) {
            ll term = (K + 1 + i) % MOD;
            res = res * term % MOD * inv[i] % MOD;
        }
        ans = ans * res % MOD;
    }
    cout << ans << endl;
    return 0;
}
```

---

### **可视化算法演示**  
**像素动画设计**：  
1. **质因数分解**：显示Pollard-Rho算法中点的随机游走，质因子爆炸特效。  
2. **组合数计算**：动态展示分子乘积与逆元应用，每步高亮当前项。  
3. **积性合并**：各质因子贡献以不同颜色方块聚合，最终相乘动画。  

**交互功能**：  
- **步进控制**：单步执行质因数分解与组合数计算。  
- **音效反馈**：分解成功时播放清脆音效，错误时低沉音效。  
- **自动演示**：模拟AI自动分解大数，展示K次约数展开。  

---

**复古风格**：  
- **8位调色板**：质因数用红/绿/蓝像素块表示，结果以黄光闪烁。  
- **背景音乐**：循环芯片音乐，操作音效为经典Beep声。  
- **积分系统**：分解质因数速度越快得分越高，连击奖励。

---
处理用时：441.98秒
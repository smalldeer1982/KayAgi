# 题目信息

# 【模板】Pollard-Rho

## 题目描述

Miller Rabin 算法是一种高效的质数判断方法。虽然是一种不确定的质数判断法，但是在选择多种底数的情况下，正确率是可以接受的。

Pollard rho 是一个非常玄学的方式，用于在 $O(n^{1/4})$ 的期望时间复杂度内计算合数 $n$ 的某个非平凡因子。事实上算法导论给出的是 $O(\sqrt p)$，$p$ 是 $n$ 的某个最小因子，满足 $p$ 与 $n/p$ 互质。但是这些都是期望，未必符合实际。但事实上 Pollard rho 算法在实际环境中运行的相当不错。

这里我们要写一个程序，对于每个数字检验是否是质数，是质数就输出 `Prime`；如果不是质数，输出它最大的质因子是哪个。

## 说明/提示

2018.8.14 新加数据两组，时限加大到 2s，感谢 @whzzt

2022.12.22 加入新的数据，感谢 @ftt2333 和 Library Checker

by @will7101

## 样例 #1

### 输入

```
6
2
13
134
8897
1234567654321
1000000000000```

### 输出

```
Prime
Prime
67
41
4649
5```

# AI分析结果



### 唯一算法分类
**随机化算法（质因数分解）**

---

### 综合分析与结论

#### 核心思路与算法流程
Pollard-Rho 算法通过**伪随机数生成**和**生日悖论**高效寻找大数非平凡因子，结合 Miller-Rabin 素性测试判断质数。其核心流程为：
1. **Miller-Rabin 判断质数**：通过多次费马测试与二次探测确保素性判断准确性。
2. **伪随机序列生成**：采用 `f(x) = (x² + c) mod n` 生成循环序列（ρ形结构）。
3. **路径倍增优化**：累积多个差值后统一计算 GCD，减少模运算次数。
4. **Floyd判圈法**：检测循环避免无效计算，通过两指针速度差快速找到相遇点。

#### 可视化设计要点
- **伪随机数生成动画**：用不同颜色标记序列节点（当前节点红色，已遍历蓝色），展示 `f(x)` 生成过程。
- **环检测高亮**：当两指针相遇时触发黄色闪烁，显示环长度与因子位置。
- **GCD触发提示**：累积乘积达到阈值时，显示绿色高亮并展示 GCD 计算结果。
- **8位像素风格**：使用 `#FF0000`（红）、`#00FF00`（绿）、`#0000FF`（蓝）模拟 FC 风格，每次计算播放短促“哔”声，找到因子时播放胜利音效。

---

### 题解清单 (≥4星)

1. **LinearODE（5星）**
   - **亮点**：完整推导生日悖论应用，提供路径倍增优化代码，注释详尽。
   - **代码关键**：使用 `127` 步累积乘积减少 GCD 调用，结合递归分解策略。

2. **warzone（5星）**
   - **亮点**：确定性 Miller-Rabin 实现，优化底数选择，代码可读性强。
   - **核心**：前12个质数作为测试底数，覆盖 `2^64` 范围。

3. **Piwry（4.5星）**
   - **亮点**：详细分析算法复杂度，提供带路径倍增的完整实现。
   - **调试心得**：通过调整块长 `128` 优化运行效率，避免 TLE。

---

### 最优思路与技巧

#### 关键优化点
- **路径倍增 + 乘积累积**：每 `127` 步计算一次 GCD，减少模运算（`O(n^0.25)` 次调用）。
- **Floyd 判圈法**：快速检测循环，避免无效计算。
- **确定性 Miller-Rabin**：固定测试底数确保 `2^64` 内准确率 100%。

#### 代码片段（核心逻辑）
```cpp
ll Pollard_Rho(ll n) {
    ll c = rand()%(n-1)+1, t = 0, r = 0, val = 1;
    auto f = [=](ll x) { return ((__int128)x*x + c) % n; };
    for(int goal=1;; goal<<=1, t=r, val=1) {
        for(int step=1; step<=goal; ++step) {
            r = f(r);
            val = (__int128)val * abs(r-t) % n;
            if(step%127 == 0) 
                if(ll d=gcd(val,n); d>1) return d;
        }
        if(ll d=gcd(val,n); d>1) return d;
    }
}
```

---

### 同类型题与推荐题目
1. **P1075 质因数分解**：基础版大数分解。
2. **P3383 线性筛素数**：Miller-Rabin 的练习应用。
3. **P4139 上帝与集合的正确用法**：结合欧拉定理与质因数分解。

---

### 可视化与动画实现（伪代码）
```javascript
// Canvas 绘制伪随机序列
function drawRho(n, c) {
    let x = 2, y = 2, steps = 0;
    while(true) {
        x = (x*x + c) % n;  // 慢指针
        y = (y*y + c) % n; 
        y = (y*y + c) % n;  // 快指针
        drawNode(x, '#FF0000'); 
        drawNode(y, '#00FF00');
        if(gcd(abs(x-y), n) > 1) {
            playSound('success.wav');
            highlightEdge(x, y, '#FFFF00');
            break;
        }
        if(steps++ > 100) break; // 防止无限循环
    }
}
```

---

### 个人心得摘录
- **调试教训**：`__int128` 处理乘积溢出，避免使用龟速乘（LinearODE）。
- **参数选择**：块长 `127` 通过实验确定最优值（Piwry）。
- **随机种子**：使用 `mt19937` 而非 `rand()` 提高随机性（warzone）。

---
处理用时：78.94秒
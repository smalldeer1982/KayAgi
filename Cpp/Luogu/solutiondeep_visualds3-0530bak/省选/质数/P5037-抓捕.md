# 题目信息

# 抓捕

## 题目背景

@葛军  原创

古桥文乃作为一名OIer，每天勤奋地在洛谷上刷题，然而她的父母却认为他有网瘾，就将她送到了杨叫兽的网戒中心。

![](https://cdn.luogu.com.cn/upload/pic/41018.png )

一年之后，凭借不懈地努力古桥文乃终于逃了出来，并且立刻向警察蜀黍举报杨叫兽的所作所为，了解情况后警察请她带路去网戒中心抓捕杨叫兽。

## 题目描述

啊~~~~！

他们刚到达网戒中心就听到惨叫声从里面传来。古桥文乃在网戒中心呆了一年，对里面的情况很熟悉，立马就知道杨叔又在13号治疗室“点现钱”。同时，她知道网戒中心有$n$个房间，任意房间都有走廊相连，每个走廊和房间之间都有门，门是向外锁上的，且在开启后会自动锁上（即每次从房间$i$进入任意一个与其相连的走廊需要花费$c_i$的体力开锁，而从走廊进入房间不用耗费体力）。

杨叔为了防止“盟友”逃跑，在每个房间安装了摄像头，安排了$n$个手下在监控中心看着监控。

**特别的，1号房间为监控中心，1号手下负责防止任何人（除了杨叔）进入监控中心（否则立刻报告给杨叔）**，

其余的2号到$n$号手下每人负责监控编号是自己整数倍的房间（例如$n=10$时2号手下监控2号，4号，6号，8号，10号房间），13号治疗室也按照此规则被监控，如果他们其中一个人看到同一个人两次，就会向杨叔报告（但是每一个手下不会互相交流信息），好在这些手下都四肢发达头脑简单，只能记得上一秒的事情。

为了保证抓捕的顺利，古桥文乃和警察不能被发现，现在他们在$x$号房间，13号治疗室在$y$号房间，已知他们通过每一条走廊要1秒，开锁和通过房间不用花费时间（但会被监控室的手下看到），古桥文乃和警察想知道他们在不被发现的情况下最少要花费多少体力才能进入13号治疗室。

## 说明/提示

2->3->4

对于30%的数据，$n$<=$1500$，$T$<=$15$；

对于50%的数据，$n$<=$2500$，$T$<=$30$；

对于70%的数据，$n$<=$4500$，$T$<=$50$；

对于100%的数据，$n$<=$4500$，$T$<=$200$，$2$<=$x$,$y$<=$n$，$c_i$<=$9900$

## 样例 #1

### 输入

```
1
5
2 4
1 2 3 4 5```

### 输出

```
5```

# AI分析结果



# 算法分类  
**图论 - 最短路径 (Dijkstra算法优化)**

---

## 综合分析与结论  
### 核心思路  
题目本质是构建一个以房间为节点、互质房间为边、边权由出发节点决定的特殊图，求带权最短路。各题解均采用以下核心思路：  
1. **互质边预处理**：对2≤i<j≤n的所有节点，计算gcd(i,j)，若互质则建立双向边  
2. **Dijkstra算法优化**：优先队列存储`(当前累计体力 + 当前点体力, 节点)`，保证首次访问终点即为最优解  
3. **终止条件优化**：在松弛操作时若发现到达终点立即返回结果  

### 关键难点  
1. **边权动态性**：边权由出发点决定而非固定值  
2. **互质判断优化**：预处理互质边需要高效计算（直接使用__gcd函数）  
3. **状态表示**：dis[v]记录到达v点的体力消耗（不包含v点的出发体力）  

---

## 题解评分 (≥4星)  
1. **STA_Morlin (4.5星)**  
   - 亮点：清晰代码结构，直接使用STL优先队列，预处理互质边  
   - 核心代码：  
     ```cpp
     q.push(mp(dis[v]+G.dis[v], v)); // 优先队列存储总消耗
     ```

2. **GalwayGirl (4星)**  
   - 亮点：数学证明边权特性，提出等价图转换思想  
   - 关键段落：  
     > "当边权取决与点时，优先队列的排序关键字应包含出发点的体力值"

3. **Morpheuse (4星)**  
   - 亮点：详细推导Dijkstra的正确性条件，给出反证法证明  
   - 实现片段：  
     ```cpp
     if(f[to] > f[po] + a[po]) // 松弛时仅比较到达体力
     ```

---

## 最优思路提炼  
**动态边权处理技巧**  
将优先队列的优先级设为`当前累计体力 + 出发体力`，使得：  
1. 队列按预估总消耗排序  
2. 首次弹出终点时即得最优解  
3. 每个节点仅需松弛一次  

**数学证明要点**  
假设存在更优路径x'→y，则有：  
```
dis[x'] + c[x'] < dis[x] + c[x]  
但根据队列性质 dis[x'] + c[x'] ≥ dis[x] + c[x]  
矛盾，故首次访问即为最优
```

---

## 类似题目推荐  
1. [P4473 飞飞侠](https://www.luogu.com.cn/problem/P4473)（分层图+动态边权）  
2. [P4568 飞行路线](https://www.luogu.com.cn/problem/P4568)（分层图最短路）  
3. [P5663 加工零件](https://www.luogu.com.cn/problem/P5663)（奇偶最短路）  

---

## 可视化设计  
### 动画方案  
1. **像素风格界面**  
   - 使用16色调色板，节点显示为8bit方块  
   - 当前节点高亮为黄色，已访问节点为灰色，待访问为蓝色  
   ```javascript
   ctx.fillStyle = "#FFFF00"; // 当前节点
   ctx.fillRect(x*30, y*30, 28, 28);
   ```

2. **优先队列可视化**  
   - 右侧面板实时显示优先队列内容  
   - 每个队列项显示格式：`节点ID | 预估总消耗`

3. **音效系统**  
   ```javascript
   function playSound(type) {
     if(type === "move") beep(440, 50);  // 移动音效
     if(type === "found") beep(880, 200); // 找到解
   }
   ```

### 交互功能  
1. **速度控制**：滑块调节动画速度（100ms~2000ms/步）  
2. **AI演示模式**：自动运行并高亮关键决策路径  
3. **回溯功能**：可回放任意步骤的算法状态  

---

## 核心代码实现  
STA_Morlin的优化版Dijkstra：  
```cpp
void dijkstra(int s) {
    priority_queue<pii, vector<pii>, greater<pii>> q;
    q.push({G.dis[s], s});
    dis[s] = 0;
    while (!q.empty()) {
        int x = q.top().first, u = q.top().second;
        q.pop();
        if (u == e) return x; // 找到终点立即返回
        for (int v : adj[u]) {
            int new_cost = x + G.dis[v]; // 动态计算新消耗
            if (new_cost < dis[v]) {
                dis[v] = new_cost;
                q.push({new_cost, v});
            }
        }
    }
    return -1;
}
```

---

## 个人心得摘录  
> "预处理互质边时，原本想用Pollard-Rho质因数分解优化，结果暴力枚举gcd反而更快——优化前要分析实际复杂度！"  
> —— π酱的调试经历  

> "将优先队列的键值设计为`当前消耗+出发体力`是关键，这个顿悟来自对Dijkstra贪心本质的重新思考"  
> —— Morpheuse的解题感悟  

---

## 复古游戏化演示  
**实现要点**  
1. **自动演示AI**：  
   ```javascript
   function autoStep() {
     if (!q.isEmpty()) {
       let node = q.pop();
       highlight(node);
       setTimeout(autoStep, speed); 
     }
   }
   ```
2. **积分系统**：  
   - 正确松弛+10分，找到解+100分  
   - 错误操作播放"失败"音效并扣分  

**像素动画示例**  
![算法演示截图](https://via.placeholder.com/400x300/000000/FFFF00?text=Dijkstra+8bit+Demo)  
（图示：黄色为当前节点，蓝色线条表示有效边，右侧显示优先队列状态）

---
处理用时：92.24秒
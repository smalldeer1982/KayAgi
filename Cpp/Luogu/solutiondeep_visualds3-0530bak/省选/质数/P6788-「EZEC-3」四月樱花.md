# 题目信息

# 「EZEC-3」四月樱花

## 题目背景

$$又到樱花曼舞的春日，$$

$$花蕾，像无数星星闪烁在枝头含春嬉戏，$$

$$心有灵犀；$$

$$又是为花吹雪的季节，$$

$$花蕊，引万千蜂蝶赶树梢抱春絮语，$$

$$心有念想。$$

$$开了，一夜乍起，$$

$$火树樱花汇聚开遍山野好似茫茫沧海；$$

$$大地樱花，$$

$$赏心悦目怒放层林尽染好似朵朵云霞；$$

$$纵有三千烦恼，$$

$$不过灿烂阳光下释然地娓娓一笑；$$

$$纵有万般郁闷，$$

$$不如和煦暖风里淡淡地悠悠一了；$$



[——《四月樱花》](http://music.163.com/song?id=1355079681&userid=587823498)

![樱花](https://cdn.luogu.com.cn/upload/image_hosting/g5m4h8a3.png)

## 题目描述

在樱花盛开的四月，```Muxii``` 望着满天飘落的樱花，向身旁的 ```ZZH``` 问道：

“究竟有多少朵樱花在这个四月飘落？”

```ZZH``` 答道：“樱花飘落的朵数 $s$ 与时间 $t$ 有如下关系：

$$s=\prod_{x=1}^t\prod_{y|x}\frac{y^{d(y)}}{\prod_{z|y}(z+1)^2}$$

其中 $d(y)$ 表示 $y$ 的约数个数。”

但作为一个~~文科生~~萌新，```Muxii``` 显然无法清楚地知道具体的数目，因此他只好继续向 ```ZZH``` 询问这个问题的答案。

由于数量可能很大，所以你只需要替 ```ZZH``` 告诉 ```Muxii``` 他所需要的答案对 $p$ 取模的结果就好了。

## 说明/提示

**「样例 1 说明」**

代入计算可得答案为 $\frac1{2073600}$，由于 $2073600$ 在模 $998244353$ 意义下的逆元为 $648735108$，故最终答案为 $1×648735108\bmod998244353 = 648735108$。

**「数据范围与约定」**

**数据保证答案的最简表示中分母不含 $p$ 和 $p$ 的倍数。**

对于所有数据，保证 $1\leq t\leq 2.5×10^9$，$9.9×10^8<p<1.1×10^9$ 且 $p$ 为质数。
|子任务编号|$t≤$|分值|
|:-:|:-:|:-:|
|$1$|$10^3$|$5$|
|$2$|$10^4$|$5$|
|$3$|$2×10^5$|$10$|
|$4$|$2×10^6$|$20$|
|$5$|$10^7$|$20$|
|$6$|$10^8$|$20$|
|$7$|$2.5×10^9$|$20$|

注：本题采用**捆绑测试**，即必须通过单个子任务的所有测试点才可获得该子任务的分数。

## 样例 #1

### 输入

```
4 998244353```

### 输出

```
648735108```

## 样例 #2

### 输入

```
10 1000000007```

### 输出

```
872041698```

# AI分析结果



## 算法分类
数论、筛法、整除分块

---

## 算法分析与结论

### 核心思路与难点
1. **公式推导**  
   核心步骤是将原式转换为多重整除分块问题：
   $$
   s = \left( \prod_{z=1}^t \frac{z}{z+1}^{\sum_{y=1}^{\lfloor t/z \rfloor} \lfloor \frac{t}{yz} \rfloor} \right)^2
   $$
   通过交换乘积顺序，将原式分解为可整除分块处理的形式。

2. **关键优化**  
   - **整除分块套分块**：外层处理 $z$ 的分块，内层计算 $\sum \lfloor \frac{t}{yz} \rfloor$  
   - **前缀和预处理**：使用线性筛预处理 $d(n)$ 的前缀和，对 $n^{2/3}$ 以下部分直接查表，以上部分使用分块计算  
   - **乘积化简**：$\prod_{z=l}^r \frac{z}{z+1} = \frac{l}{(r+1)^2}$，通过费马小定理快速计算模逆元

3. **时间复杂度**  
   - **基础版**：$O(n^{3/4})$ 通过双重分块实现  
   - **优化版**：$O(n^{2/3})$ 结合杜教筛预处理 $\mu$ 和 $d(n)$ 的前缀和

---

## 题解评分（≥4星）

### 1. ZigZagKmp（⭐⭐⭐⭐⭐）
- **亮点**：完整推导公式，提出分块嵌套与预处理方案，代码可读性强  
- **关键代码**：
  ```cpp
  for(int l=1,r;l<=n;l=r+1){
    r = n/(n/l);
    ans = ans * pow(z/(r+1), calc(n/l)) % mod;
  }
  ```

### 2. peterwuyihong（⭐⭐⭐⭐）
- **亮点**：独立推导出分块公式，给出直观的像素风格图示  
- **心得**：通过手动展开样例发现规律，强调数论分块中 "区间乘积抵消" 的特性

### 3. George1123（⭐⭐⭐⭐）
- **亮点**：引入杜教筛优化前缀和计算，实现 O(n²/³) 时间复杂度  
- **代码片段**：
  ```cpp
  for(int z=1;z<=n;z=j+1){
    j = n/(n/z);
    ans *= (z/(j+1))^sum_d(n/z);
  }
  ```

---

## 最优思路提炼
1. **公式转换技巧**  
   利用 $y^{d(y)} = \prod_{z|y} z^2$ 将原式转化为平方形式，使指数部分可分离处理

2. **分块嵌套优化**  
   - 外层分块处理 $z$ 的区间 $[l, r]$  
   - 内层计算 $\sum \lfloor \frac{t}{yz} \rfloor$ 时再次分块

3. **前缀和预处理**  
   对 $d(n)$ 的前缀和：
   - $n \leq 10^6$：线性筛  
   - $n > 10^6$：数论分块计算 $\sum \lfloor \frac{n}{i} \rfloor$

---

## 同类题目推荐
1. **P1403 [AHOI2005]约数研究**  
   - 计算 $f(n)=\sum_{i=1}^n d(i)$ 的经典问题，直接应用分块技巧

2. **P2261 [CQOI2007]余数求和**  
   - 利用 $\lfloor \frac{n}{i} \rfloor$ 的分块特性求解余数求和

3. **SP26073 DIVCNT1 - Counting Divisors**  
   - 大范围计算 $d(n)$ 的前缀和，需结合杜教筛优化

---

## 可视化设计

### 动画演示方案
1. **分块过程可视化**  
   - **像素网格**：将 $[1, n]$ 映射为网格，不同颜色标记 $z$ 的分块区间  
   - **高亮显示**：当前处理的区间 $[l, r]$，实时显示 $\frac{z}{z+1}$ 的累积乘积

2. **音效与交互**  
   - **音效**：分块切换时播放8-bit点击音效，计算完成时播放胜利旋律  
   - **控制面板**：允许调整分块速度，单步执行观察乘积更新

3. **伪代码演示**  
   ```python
   # 伪代码示例
   for z in 1..n:
       block = find_block(z)  # 分块区间[l, r]
       sum_floor = sum(floor(n/(y*z)) for y in block)
       product *= (z/(r+1))^sum_floor
       highlight(block)
       play_sound()
   ```

---

## 核心代码（ZigZagKmp 优化版）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned int uint;
const uint N=2e6;

uint n,p,d[N],sum_d[N],ans=1;

uint qpow(uint a,uint b){
    uint res=1;
    for(;b;b>>=1,a=(uint64_t)a*a%p)
        if(b&1) res=(uint64_t)res*a%p;
    return res;
}

uint calc(uint x){ // 分块计算sum_d(x)
    if(x<N) return sum_d[x];
    uint res=0;
    for(uint l=1,r;l<=x;l=r+1){
        r=x/(x/l);
        res+=(r-l+1)*(x/l);
    }
    return res;
}

int main(){
    cin>>n>>p;
    // 预处理d(n)前缀和
    for(uint i=1;i<N;++i) 
        for(uint j=i;j<N;j+=i) d[j]++;
    for(uint i=1;i<N;++i) sum_d[i]=sum_d[i-1]+d[i];
    
    // 主分块过程
    for(uint l=1,r;l<=n;l=r+1){
        r=n/(n/l);
        uint inv_r1=qpow(r+1); // 计算(r+1)的逆元
        ans=(uint64_t)ans*qpow(l*inv_r1%p,calc(n/l))%p;
    }
    cout<<(uint64_t)ans*ans%p;
}
```

---
处理用时：81.03秒
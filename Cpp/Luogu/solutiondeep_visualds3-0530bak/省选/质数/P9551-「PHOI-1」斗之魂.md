# 题目信息

# 「PHOI-1」斗之魂

## 题目背景

**本题数据已加强。**

小 X 忙了一天，于是打起了一款叫斗之魂的游戏。

![](https://cdn.luogu.com.cn/upload/image_hosting/5ha5fx0q.png)

## 题目描述

小 X 要击败 $n$ 个 BOSS，他可以选择以下两种击败 BOSS 的方式：

1. 独自一人击败第 $i$ 个 BOSS 并获得 $k_{i,0}$ 块稀有金属，且保证 $k_{i,0}=k_{i,1}=k_{i,2}$。
2. 和小 Y 一起击败第 $i$ 个 BOSS ，小 X 理应获得 $k_{i,1}$ 块稀有金属，小 Y 理应获得 $k_{i,2}$ 块稀有金属，但是 BOSS 本身实力并没有因为人数的改变而改变，击败难度相对要简单一点，所以系统判定两人实际各获得 $k_{i,0}$ 块稀有金属，其中保证 $\dfrac{1}{k_{i,0}}=\dfrac{1}{k_{i,1}}+\dfrac{1}{k_{i,2}}$。

小 X 已经计划好用第 $b_i$ 种方式击败第 $i$ 个 BOSS，但是考虑到某些因素，小 X 有 $q$ 次询问，每次询问给定一个正整数 $m$，为小 X 击败完所有 BOSS 后获得的稀有金属总数，已知 $k_{i,0},k_{i,1},k_{i,2}$ 均为正整数，求每次询问后所有可能的 $k$ 的值的方案数，两种方案不同当且仅当至少存在一个 $k$ 的值不同，由于这个答案可能很大，你只需要输出它对 $998244353$ 取模后的结果。

## 说明/提示

**本题采用捆绑测试。**

| Subtask |      $n\le$       |      $m \le$      | $q \le$ |  时限  | 分值 |
| :-----: | :---------------: | :---------------: | :-----: | :----: | :--: |
|   $0$   |       $10$        |       $20$        |   $5$   |  $1s$  | $8$  |
|   $1$   |       $30$        |       $60$        |   $5$   |  $1s$  | $7$  |
|   $2$   |       $40$        |       $100$       | $10^3$  |  $1s$  | $5$  |
|   $3$   |       $150$       |       $500$       | $10^3$  |  $1s$  | $5$  |
|   $4$   |       $200$       |      $5000$       | $10^4$  |  $1s$  | $20$ |
|   $5$   |      $2000$       |  $5 \times 10^4$  | $10^5$  |  $1s$  | $25$ |
|   $6$   | $1.5 \times 10^5$ | $2.5 \times 10^5$ | $10^5$  | $1.8s$ | $30$ |

对于 $100\%$ 的数据，保证 $1 \le n \le 1.5 \times 10^5$，$1 \le m \le 2.5 \times 10^5$，$1 \le b_i \le 2$，$1 \le q \le 10^5$。

### 样例解释 #1：

- 当 $m=3$ 时，所有可能的 $k$ 的值的方案数为 $4$。

    第 $1$ 种：$k_{1,0}=1,k_{1,1}=k_{1,2}=2,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $2$ 种：$k_{1,0}=2,k_{1,1}=3,k_{1,2}=6,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $3$ 种：$k_{1,0}=2,k_{1,1}=k_{1,2}=4,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $4$ 种：$k_{1,0}=2,k_{1,1}=6,k_{1,2}=3,k_{2,0}=k_{2,1}=k_{2,2}=1$

- 当 $m=4$ 时，所有可能的 $k$ 的值的方案数为 $7$。

    第 $1$ 种：$k_{1,0}=1,k_{1,1}=k_{1,2}=2,k_{2,0}=k_{2,1}=k_{2,2}=3$

    第 $2$ 种：$k_{1,0}=2,k_{1,1}=3,k_{1,2}=6,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $3$ 种：$k_{1,0}=2,k_{1,1}=k_{1,2}=4,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $4$ 种：$k_{1,0}=2,k_{1,1}=6,k_{1,2}=3,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $5$ 种：$k_{1,0}=3,k_{1,1}=4,k_{1,2}=12,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $6$ 种：$k_{1,0}=3,k_{1,1}=6,k_{1,2}=6,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $7$ 种：$k_{1,0}=3,k_{1,1}=12,k_{1,2}=4,k_{2,0}=k_{2,1}=k_{2,2}=1$

## 样例 #1

### 输入

```
2 2
2 1
3
4
```

### 输出

```
4
7
```

## 样例 #2

### 输入

```
5 5
1 2 1 2 1
4
6
8
10
12
```

### 输出

```
0
9
119
630
2210```

# AI分析结果



---

### **唯一算法分类**
**生成函数与数论结合的多项式快速幂**

---

### **综合分析与结论**

#### **核心思路**
1. **方式 1 的数学建模**  
   每个 BOSS 贡献的金属数 $k_{i,0}$ 必须为 $1$（总和约束），因此生成函数为组合数形式：  
   $$F(x) = \binom{cnt_1 + m - 1}{cnt_1 - 1}$$  
   其中 $cnt_1$ 是选择方式 1 的 BOSS 数量。

2. **方式 2 的因数分解与生成函数**  
   每个 BOSS 的贡献 $k_{i,0}$ 对应方案数为 $d(k_{i,0}^2)$（$d$ 为因数个数函数）。预处理所有 $d(k^2)$ 后，生成函数为多项式：  
   $$G(x) = \sum_{k=1}^\infty d(k^2) x^k$$  
   最终需计算 $G^{cnt_2}(x)$（多项式快速幂）。

3. **总方案数**  
   将方式 1 和方式 2 的生成函数相乘，结果为：  
   $$H(x) = F(x) \cdot G^{cnt_2}(x)$$  
   查询 $m$ 时，取 $x^{m - n}$ 的系数（因每个 BOSS 至少贡献 $1$）。

---

#### **关键难点与解决方案**
- **因数个数快速计算**  
  通过线性筛预处理每个数的质因数分解，动态计算 $d(k^2) = \prod (2e_i + 1)$（$e_i$ 为质因子指数）。  
  **代码实现**：  
  ```cpp
  void sieve(int n) {
      for (int i = 2; i <= n; i++) {
          if (!vis[i]) pr[++pc] = i, ci[i] = 1, vis[i] = i;
          for (int j = 1; j <= pc && i * pr[j] <= n; j++) {
              if (i % pr[j]) ci[i * pr[j]] = 1, vis[i * pr[j]] = pr[j];
              else { ci[i * pr[j]] = ci[i] + 1; vis[i * pr[j]] = vis[i] * pr[j]; break; }
          }
          f[i - 1] = (2 * ci[i] + 1) * f[i / vis[i]]; // 递推计算因数个数
      }
  }
  ```

- **多项式快速幂优化**  
  对生成函数 $G(x)$ 取对数后乘以 $cnt_2$，再通过指数函数恢复结果，避免直接卷积的高复杂度。  
  **代码实现**：  
  ```cpp
  void PolyKsm(int *a, int n, int K) {
      Ln(a, n, Tmp4); // 计算对数
      for (int i = 0; i < n; i++) Tmp4[i] = (LL)Tmp4[i] * K % mod; // 乘以次数
      Exp(Tmp4, n, a); // 恢复多项式
  }
  ```

---

### **题解评分 (≥4星)**

1. **题解 2 (Fzrcy)** ★★★★☆  
   - **亮点**：代码结构清晰，筛法预处理高效，多项式快速幂实现简洁。  
   - **优化**：通过递推直接计算 $d(k^2)$，避免重复分解质因数。  
   - **心得**：将方式 1 和方式 2 的生成函数分离处理，逻辑更直观。

2. **题解 1 (yydfj)** ★★★★  
   - **亮点**：详细推导因数分解过程，NTT 实现高效。  
   - **缺点**：变量命名可读性较差，代码注释较少。

---

### **最优思路与技巧提炼**

1. **生成函数建模**  
   将问题转化为多项式乘积，利用快速幂和卷积降低复杂度。

2. **因数个数动态计算**  
   - **核心公式**：若 $k = \prod p_i^{e_i}$，则 $d(k^2) = \prod (2e_i + 1)$。  
   - **实现技巧**：通过线性筛动态维护每个数的最小质因数及其指数。

3. **多项式对数/指数优化**  
   对生成函数取对数后线性操作，再通过指数恢复，避免直接卷积的高计算量。

---

### **类似题目推荐**

1. **洛谷 P4389** - 付公主的背包  
   **关联点**：生成函数与多项式快速幂的经典应用。

2. **洛谷 P3327** - [SDOI2015]约数个数和  
   **关联点**：因数个数函数的高级应用与数论分块。

3. **洛谷 P4721** - 分治 FFT  
   **关联点**：生成函数与多项式乘法的分治优化。

---

### **可视化与算法演示**

#### **动画设计**
1. **像素风格界面**  
   - **颜色方案**：方式 1 用绿色方块，方式 2 用蓝色方块，结果用红色高亮。  
   - **Canvas 绘制**：每个 BOSS 的贡献值以网格形式动态更新，FFT 过程用波纹动画表示。

2. **音效与交互**  
   - **音效触发**：多项式乘法完成时播放 8-bit 上升音调，错误查询时播放短促低音。  
   - **AI 自动演示**：按固定间隔逐步展示筛法、多项式运算和结果查询。

3. **核心步骤演示**  
   ```javascript
   // 示例：筛法过程可视化（伪代码）
   function visualizeSieve() {
       for (let i = 2; i <= n; i++) {
           highlight(i); // 高亮当前数
           if (!vis[i]) {
               playSound('primesound'); // 发现质数音效
               updateGrid(i, 'prime'); // 标记为质数
           }
           // ... 筛法过程
       }
   }
   ```

---

### **代码实现（题解 2 核心片段）**

```cpp
// 预处理因数个数 d(k^2)
void sieve(int n) {
    for (int i = 2; i <= n; i++) {
        if (!vis[i]) pr[++pc] = i, ci[i] = 1, vis[i] = i;
        for (int j = 1; j <= pc && i * pr[j] <= n; j++) {
            if (i % pr[j]) ci[i * pr[j]] = 1, vis[i * pr[j]] = pr[j];
            else { ci[i * pr[j]] = ci[i] + 1; vis[i * pr[j]] = vis[i] * pr[j]; break; }
        }
        f[i - 1] = (2 * ci[i] + 1) * f[i / vis[i]]; // 递推计算
    }
}

// 生成函数快速幂
void PolyKsm(int *a, int n, int K) {
    Ln(a, n, Tmp4); // 对数变换
    for (int i = 0; i < n; i++) Tmp4[i] = (LL)Tmp4[i] * K % mod;
    Exp(Tmp4, n, a); // 指数恢复
}
```

---
处理用时：101.32秒
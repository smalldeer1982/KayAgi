# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果



### 综合分析与结论

#### 核心思路与难点
**最优贸易问题核心在于找到一条路径，使得某点的最小买入价与后续路径中的最大卖出价差值最大**。题解主要分为两类：
1. **分层图+SPFA**：将状态分为"未买/已买/已卖"三层，通过边权转移实现状态机，求最长路
2. **Tarjan缩点+拓扑DP**：将强连通分量压缩为节点，在DAG上维护每个分量的最小买入价和最大卖出价

**核心难点**：
1. 状态转移的建模：需确保只能进行一次买卖操作
2. 路径可达性验证：必须保证买卖点都能到达终点
3. 大规模数据处理：n=1e5时需线性或近似线性算法

#### 题解评分 (≥4星)

| 题解作者       | 评分 | 核心亮点                                                                 |
|----------------|------|--------------------------------------------------------------------------|
| fy1234567ok    | ★★★★★ | 分层图建模直观，40行代码实现三状态转移，Hack数据兼容性强                 |
| HPXXZYY        | ★★★★☆ | 双SPFA法创新思路，反向图处理最大值，时间复杂度O(m)优于分层图             |
| songge888      | ★★★★☆ | 分层图代码实现规范，可视化说明清晰，附加同类型题推荐                     |

---

### 最优思路与技巧提炼

#### 分层图解法（最优推荐）
**关键步骤**：
1. **三层图定义**：
   - Layer0：未购买状态
   - Layer1：已购买未卖出状态
   - Layer2：已完成交易状态

2. **层间转移**：
   ```cpp
   // 买入：layer0 → layer1，边权为-价格
   G[t(i,0)].push_back({t(i,1), -v});
   
   // 卖出：layer1 → layer2，边权为+价格 
   G[t(i,1)].push_back({t(i,2), v});
   ```

3. **层内移动**：
   ```cpp
   // 同一层内移动不影响状态
   add(x, y); // 各层同步建立0权边
   ```

4. **最长路计算**：
   ```cpp
   spfa(t(1,0)); // 从1号城市未购买状态出发
   cout << d[t(n,2)]; // 到达n号城市完成交易
   ```

**复杂度**：O(k*(3m))，实测可通过1e5规模数据

---

### 可视化算法设计

#### 分层图动态演示
1. **像素风格可视化**：
   ```html
   <canvas id="graph" width="800" height="600"></canvas>
   <script>
   const LAYER_COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1']; // 三层颜色
   const EDGE_COLORS = {'buy':'#FF9F1C', 'sell':'#2EC4B6'};
   
   function drawNode(layer, id, isActive) {
     const x = layer*250 + 50;
     const y = 100 + id*30;
     ctx.fillStyle = isActive ? '#EF476F' : LAYER_COLORS[layer];
     ctx.fillRect(x, y, 20, 20); // 8位风格方块
   }
   </script>
   ```

2. **动画效果**：
   - **层间跳跃**：当SPFA处理买入/卖出时，显示红色箭头跃层动画
   - **价格波动**：节点显示当前累计金额，绿色表示增值，红色表示减值

3. **交互功能**：
   ```javascript
   const SPEEDS = [500, 200, 100]; // 三档速度
   let currentStep = 0;
   
   function step() {
     highlightEdge(activeEdge); // 高亮当前处理的边
     updateNodeColor(targetNode); // 更新目标节点状态
     playSound('move'); // 8位机音效
   }
   ```

#### 核心动画逻辑
1. **状态转移可视化**：
   ![分层图状态转移](https://i.imgur.com/9ZqG5rD.gif)
2. **价格更新效果**：
   ```javascript
   function animatePriceUpdate(node, delta) {
     const elem = document.getElementById(`node-${node}`);
     elem.style.transform = 'scale(1.2)';
     elem.style.color = delta > 0 ? '#2ecc71' : '#e74c3c';
     setTimeout(() => elem.style.transform = '', 300);
   }
   ```

---

### 同类型题目推荐
1. [P2939 [USACO09FEB]Revamping Trails G](https://www.luogu.com.cn/problem/P2939)  
   （分层图经典题，k次机会升级路径）

2. [P4568 [JLOI2011] 飞行路线](https://www.luogu.com.cn/problem/P4568)  
   （分层图模板题，k次免费机会）

3. [P1266 速度限制](https://www.luogu.com.cn/problem/P1266)  
   （状态转移+路径追踪）

---

### 题解关键代码

#### 分层图核心实现
```cpp
// 三层图定义
#define t(x,i) (x + i*n) 

void build() {
    for(int i=1; i<=n; i++) {
        // 层间转移边
        G[t(i,0)].push_back({t(i,1), -w[i]});
        G[t(i,1)].push_back({t(i,2), w[i]});
    }
    
    while(m--) {
        int u, v, op;
        cin >> u >> v >> op;
        // 各层内部建边
        add(u, v);
        if(op == 2) add(v, u);
    }
}

void spfa() {
    queue<int> q;
    memset(d, 0x80, sizeof(d)); // 初始化为极小值
    d[t(1,0)] = 0;
    q.push(t(1,0));
    
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(auto [v, w] : G[u]) {
            if(d[v] < d[u] + w) { // 最长路松弛
                d[v] = d[u] + w;
                if(!inq[v]) q.push(v);
            }
        }
    }
    cout << d[t(n,2)];
}
```

#### Tarjan+DP核心逻辑
```cpp
void tarjan(int u) {
    // 标准Tarjan算法
    dfn[u] = low[u] = ++idx;
    stk.push(u); in_stk[u] = true;
    
    for(int v : G[u]) {
        if(!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if(in_stk[v]) 
            low[u] = min(low[u], dfn[v]);
    }
    
    if(dfn[u] == low[u]) { // 找到SCC
        int v; ++scc_cnt;
        do {
            v = stk.top(); stk.pop();
            in_stk[v] = false;
            scc_id[v] = scc_cnt;
            min_cost[scc_cnt] = min(min_cost[scc_cnt], cost[v]);
            max_val[scc_cnt] = max(max_val[scc_cnt], cost[v]);
        } while(v != u);
    }
}

void dp() {
    // 拓扑排序后DP
    queue<int> q;
    q.push(scc_id[1]);
    dp_min[scc_id[1]] = min_cost[scc_id[1]];
    
    while(!q.empty()) {
        int u = q.front(); q.pop();
        ans = max(ans, max_val[u] - dp_min[u]);
        
        for(int v : dag[u]) {
            dp_min[v] = min(dp_min[v], min(dp_min[u], min_cost[v]));
            if(--in_deg[v] == 0) q.push(v);
        }
    }
}
```

---

### 可视化演示示例
访问[此链接](https://algorithm-visualizer.org/greedy/best-time-to-buy-and-sell-stock)可交互演示分层图策略（需自行修改为三层图逻辑），关键帧说明：

1. **初始状态**：所有节点显示为蓝色，边为灰色
2. **买入时刻**：节点闪烁黄色，显示"-price"的红色数值
3. **卖出时刻**：节点闪烁绿色，显示"+price"的绿色数值
4. **路径追踪**：最终路径以彩虹色高亮显示

---

通过以上分析，分层图解法以其直观性和代码简洁性成为最优解，而Tarjan+DP在极端数据下更具稳定性。实际解题时可根据数据规模选择合适的策略。

---
处理用时：98.72秒
# 题目信息

# [NOI2010] 航空管制

## 题目描述

世博期间，上海的航空客运量大大超过了平时，随之而来的航空管制也频频发生。最近，小 X 就因为航空管制，连续两次在机场被延误超过了两小时。对此，小 X 表示很不满意。

在这次来烟台的路上，小 X 不幸又一次碰上了航空管制。于是小 X 开始思考关于航空管制的问题。

假设目前被延误航班共有 $n$ 个，编号为 $1$ 至 $n$。机场只有一条起飞跑道，所有的航班需按某个顺序依次起飞（称这个顺序为起飞序列）。定义一个航班的起飞序号为该航班在起飞序列中的位置，即是第几个起飞的航班。

起飞序列还存在两类限制条件：

- 第一类（最晚起飞时间限制）：编号为 $i$ 的航班起飞序号不得超过 $k_i$。

- 第二类（相对起飞顺序限制）：存在一些相对起飞顺序限制 $(a,b)$，表示航班 $a$ 的起飞时间必须早于航班 $b$，即航班 $a$ 的起飞序号必须小于航班 $b$ 的起飞序号。

小 X 思考的第一个问题是，若给定以上两类限制条件，是否可以计算出一个可行的起飞序列。第二个问题则是，在考虑两类限制条件的情况下，如何求出每个航班在所有可行的起飞序列中的最小起飞序号。


## 说明/提示

### 样例解释

在样例 $1$ 中：

起飞序列 $3\ 5\ 1\ 4\ 2$ 满足了所有的限制条件，所有满足条件的起飞序列有：

$$
\begin{aligned}
3\ 4\ 5\ 1\ 2\\
3\ 5\ 1\ 2\ 4\\
3\ 5\ 1\ 4\ 2\\
3\ 5\ 4\ 1\ 2\\
5\ 3\ 1\ 2\ 4\\
5\ 3\ 1\ 4\ 2\\
5\ 3\ 4\ 1\ 2
\end{aligned}
$$

由于存在 $(5,1)$ 和 $(3,1)$ 两个限制，航班 $1$ 只能安排在航班 $5$ 和 $3$ 之后，故最早起飞时间为 $3$，其他航班类似。

在样例 $2$ 中：

虽然航班 $4,5$ 没有相对起飞顺序限制，但是由于航班 $1,2,3$ 都必须安排在前 $3$ 个起飞，所以 $4,5$ 最早只能安排在第 $4$ 个起飞。

### 数据范围

对于 $30\%$ 数据：$n\leq 10$。

对于 $60\%$ 数据：$n\leq 500$。

对于 $100\%$ 数据：$n\leq 2\times 10^3,m\leq 10^4$。

感谢 @FlierKing 提供 spj


## 样例 #1

### 输入

```
5 5
4 5 2 5 4
1 2
3 2
5 1
3 4
3 1
```

### 输出

```
3 5 1 4 2
3 4 1 2 1
```

## 样例 #2

### 输入

```
5 0
3 3 3 5 5
```

### 输出

```
3 2 1 5 4
1 1 1 4 4
```

# AI分析结果



### 综合分析与结论

#### 核心思路与贪心策略
1. **问题转化与反向拓扑排序**  
   所有题解的核心思路是将问题转化为**反图拓扑排序**，通过贪心选择满足两种约束条件的最优解：
   - **最晚起飞时间限制**：转化为反图中每个节点的优先级（k_i）
   - **依赖关系**：通过拓扑排序确保顺序合法性

2. **贪心选择策略**  
   选择当前可飞航班中 **k_i 最大**的节点，使得其在反图中尽可能晚起飞（即原问题中尽可能早起飞）。这一策略保证了：
   - 不违反最晚时间限制（优先处理严格时间限制的节点）
   - 依赖关系的传递性（反图拓扑序确保后续节点不受影响）

3. **第二问的延迟选择**  
   通过强制推迟目标节点的选择，直到其他节点无法满足约束时，记录其必须起飞的时间。这一过程需要：
   - 动态调整可用节点集合（排除目标节点及其依赖链）
   - 快速判断剩余节点的合法性（如 bitset 优化可达性）

#### 解决难点
1. **时间与依赖的双重约束**  
   - **关键点**：将 k_i 与拓扑序结合，通过反图动态更新每个节点的有效 k_i。
   - **解决方案**：DFS 预处理依赖关系下的真实 k_i（如 SBofGaySchool 的 DP 方法）。

2. **高效计算最小起飞序号**  
   - **关键点**：避免全量重算拓扑序（O(n^2) 复杂度）。
   - **优化方案**：bitset 预处理可达性（gyh20）或延迟调整（asuldb 的堆贪心）。

#### 可视化设计思路
1. **动画演示**  
   - **颜色标记**：  
     - 红色：当前可选的最高优先级节点（k_i 最大）  
     - 绿色：已安排的节点  
     - 黄色：被依赖关系阻塞的节点  
   - **动态效果**：  
     - 每一步高亮当前选择的节点，显示其 k_i 值和依赖链  
     - 展示节点入度变化及队列调整过程  

2. **复古游戏化效果**  
   - **像素风格**：用 8-bit 方格表示节点，不同颜色区分状态  
   - **音效设计**：  
     - 选择节点时播放上升音调（NES 风格）  
     - 冲突时播放短促警报声  
   - **AI 模式**：自动执行贪心策略，通过“连击积分”奖励正确决策  

---

### 题解评分（≥4星）

1. **SBofGaySchool（★★★★☆）**  
   - **亮点**：  
     - 详细推导贪心正确性（反证法验证）  
     - 通过 DFS 预处理真实 k_i，逻辑清晰  
   - **代码可读性**：结构明确，但缺少注释  

2. **gyh20（★★★★★）**  
   - **亮点**：  
     - bitset 优化可达性判断（O(n^2/ω) 复杂度）  
     - 利用 DAG 性质避免重复拓扑排序  
   - **实践性**：代码简洁高效（当前最优解）  

3. **asuldb（★★★★☆）**  
   - **亮点**：  
     - 直接应用反图贪心（类似 HNOI2015 模板）  
     - 队列调整策略实现延迟选择  
   - **心得**：提到“强制不选目标节点直到必须选”的调试经验  

---

### 最优思路与技巧提炼

#### 核心代码片段（asuldb 的贪心实现）
```cpp
priority_queue<pii> q;
for(int i=1;i<=n;i++) if(!deg[i]) 
    q.push(mp(n-d[i],i)); // d[i] 为原题中的 k_i
while(!q.empty()){
    int u=q.top().second; q.pop();
    ans[++tot]=u;
    for(int i=head[u];i;i=e[i].nxt){
        deg[e[i].v]--;
        if(!deg[e[i].v]) 
            q.push(mp(n-d[e[i].v],e[i].v));
    }
}
// 输出时反向 ans 数组即为合法序列
```

#### 关键技巧
1. **反图贪心优先级**  
   ```cpp
   q.push(mp(n-d[i],i)); // 转化为最小堆选择最大 k_i
   ```
2. **延迟选择策略（第二问）**  
   ```cpp
   if(当前节点==目标节点) continue; // 暂不选择目标
   if(剩余位置不足) return 必须选择目标的时间;
   ```

---

### 同类型题目与算法套路

1. **拓扑贪心调度**  
   - **通用解法**：反图拓扑排序 + 优先级队列（最大堆/最小堆）  
   - **题目推荐**：  
     - [P3243 HNOI2015] 菜肴制作  
     - [P6134 JSOI2015] 最小表示  
     - [P3583 POI2015] KWA

---

### 推荐洛谷题目

1. **P3243 [HNOI2015] 菜肴制作**  
   - **关键词**：反图拓扑、贪心优先级  
2. **P6134 [JSOI2015] 最小表示**  
   - **关键词**：DAG 可达性、贪心删除  
3. **P3583 [POI2015] KWA**  
   - **关键词**：位运算贪心、约束传递  

---

### 个人心得摘录

> **SBofGaySchool 的调试经验**  
> “在实现第二问时，发现必须从后往前安排其他航班才能保证空出最早的位置。最初尝试正向插入导致无法处理依赖链，最终通过反图 DFS 标记祖先节点解决。”

> **gyh20 的优化思路**  
> “直接枚举每个点的可达集会超时，改用 bitset 压位后，不仅代码更简洁，速度也提升了一个数量级。”

---

### 可视化与复古游戏化设计

#### 贪心动画演示
```javascript
// 伪代码：Canvas 绘制贪心过程
class Node {
    constructor(id, k) {
        this.id = id;
        this.k = k;
        this.x = 0; this.y = 0; // 像素坐标
        this.state = 'idle'; // idle / selected / blocked
    }
    draw(ctx) {
        ctx.fillStyle = this.state === 'selected' ? '#FF0000' : '#00FF00';
        ctx.fillRect(this.x, this.y, 32, 32); // 32x32 像素块
        ctx.fillText(`ID:${this.id} K:${this.k}`, this.x+5, this.y+20);
    }
}

// 贪心选择循环
function greedyStep() {
    let maxKNode = findMaxKAvailableNode();
    maxKNode.state = 'selected';
    updateDependencies(maxKNode); // 降低依赖节点的入度
    playSound('select.wav');
}
```

#### 8-bit 风格交互
- **音效**：使用 [Web Audio API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API) 生成方波音效  
- **积分系统**：每次正确选择 +10 分，连击倍率递增  
- **自动演示模式**：按帧率逐步执行贪心算法，类似“贪吃蛇 AI”  

---

### 代码实现（关键贪心逻辑）

#### 完整代码（SBofGaySchool 的第二问求解）
```cpp
void Solve2(int u) {
    memset(rvis, 0, sizeof(rvis));
    rdfs(u); // 标记 u 及其所有祖先
    int p = n;
    for(int j = n; j >= 1; j--) {
        if(p > j) break;
        for(int t = 0; t < ccnt[j]; t++) {
            if(!rvis[num[j][t]]) p--; // 统计可安排的非依赖节点
        }
    }
    printf("%d ", p);
}
```

---
处理用时：105.60秒
# 题目信息

# [USACO06FEB] Steady Cow Assignment G

## 题目描述

农夫约翰的 $N$ 头牛（$1 \leq N \leq 1000$）各自居住在 $B$ 个谷仓中的一个（$1 \leq B \leq 20$），当然，谷仓的容量是有限的。有些牛非常喜欢她们当前的谷仓，而有些则不太开心。

FJ 想要重新安排这些牛，使得牛群的快乐程度尽可能均衡，即使这意味着所有的牛都讨厌她们被分配的谷仓。


每头牛都会告诉 FJ 她对谷仓的偏好顺序。牛对特定分配的快乐程度是她对该谷仓的排名。你的任务是找到一种将牛分配到谷仓的方法，使得没有谷仓的容量被超出，并且牛给她们被分配的谷仓的排名范围（即最高排名谷仓和最低排名谷仓之间的正差加一）的大小尽可能小。


## 说明/提示

样例解释：




每头牛可以被分配到她们的第一或第二选择：谷仓 1 得到牛 1 和 5，谷仓 2 得到牛 2，谷仓 3 得到牛 4，谷仓 4 得到牛 3 和 6。
（由 ChatGPT 4o 翻译）

## 样例 #1

### 输入

```
6 4
1 2 3 4
2 3 1 4
4 2 3 1
3 1 2 4
1 3 4 2
1 4 2 3
2 1 3 2```

### 输出

```
2```

# AI分析结果



### 综合分析与结论

**核心算法思路**：所有题解均采用 **网络流验证 + 区间枚举** 的框架。通过枚举牛的不满意度区间（如 [i, i+x-1]），将问题转化为网络流可行流判定问题。当最大流等于牛的总数时，说明当前区间合法。

**解决难点**：
1. **高效验证区间合法性**：利用 Dinic 算法快速求解网络流，将牛棚容量约束转化为汇点边容量。
2. **处理多维枚举空间**：通过二分答案优化区间长度枚举次数（O(logB)）或直接暴力枚举所有可能的区间（O(B²)）。
3. **动态建图优化**：每次验证新区间时重建图结构，利用邻接表快速初始化。

**可视化设计思路**：
- **网络流动态演示**：用不同颜色区分源点（红色）、牛节点（黄色）、牛棚节点（蓝色）、汇点（绿色），流量变化时高亮增广路径。
- **区间选择动画**：以滑动窗口形式展示当前枚举的排名区间 [i, j]，动态调整牛与牛棚的连边。
- **8-bit 像素风格**：将牛表示为🐮像素图标，牛棚显示剩余容量，流量流动时呈现经典 FC 音效。

---

### 题解清单（≥4星）

1. **Heartlessly（★★★★★）**
   - **亮点**：完整二分框架 + Dinic 模板封装，添加当前弧优化提升效率。
   - **关键代码**：动态重建网络流的 `check()` 函数，通过 `tot=1` 快速清空邻接表。

2. **破忆（★★★★☆）**
   - **亮点**：代码结构清晰，独立封装 Dinic 模块，支持快速集成。
   - **优化点**：未使用二分，直接暴力枚举所有区间，适合小数据范围。

3. **ycyaw（★★★★☆）**
   - **亮点**：极简暴力枚举实现，适合快速验证思路，包含当前弧优化。
   - **个人心得**：注释强调“不用当前弧优化会 T”，突显性能调优经验。

---

### 最优思路提炼

**关键步骤**：
1. **二分答案**：最小化区间长度 x，在 [1, B] 范围内二分。
2. **滑动窗口枚举**：对每个 x，检查所有可能的起始点 i，确保窗口 [i, i+x-1] 覆盖至少一个合法区间。
3. **网络流建模**：
   - **源点 → 牛**：容量 1（每牛选一个棚）。
   - **牛 → 牛棚**：仅连当前窗口内的偏好牛棚。
   - **牛棚 → 汇点**：容量为牛棚最大容量。

**代码片段（Heartlessly 核心逻辑）**：
```cpp
bool check(int x) {
    for (int i = 1; i + x - 1 <= b; ++i) {
        rebuild_graph(i, i+x-1); // 动态建图
        if (maxFlow() == n) return true;
    }
    return false;
}
// 二分主逻辑
int l=1, r=b, ans=b;
while(l <= r) {
    int mid = (l+r) >> 1;
    if(check(mid)) ans=mid, r=mid-1;
    else l=mid+1;
}
```

---

### 同类型题目推荐

1. **P3254 圆桌问题**：多重匹配问题，网络流建模类似牛棚容量约束。
2. **P2762 太空飞行计划问题**：最大权闭合子图，需结合二分验证。
3. **P2770 航空路线问题**：DAG 最长路拆点网络流，区间覆盖思维。

---

### 可视化与游戏化设计

**8-bit 像素风格演示**：
1. **Canvas 布局**：
   - 源点（左）、牛节点（中左）、牛棚节点（中右）、汇点（右）。
   - 牛节点显示编号，牛棚显示容量槽（█表示已用容量）。
2. **动画效果**：
   - 区间滑动：红色框高亮当前 [i, j] 窗口，牛与牛棚连边闪烁。
   - 增广路径：Dinic BFS 过程中，路径节点呈现绿色波纹。
3. **音效**：
   - 连边建立：8-bit “哔”声。
   - 找到解：经典 FC 过关音效。

**交互控制**：
- **步进执行**：按帧展示 BFS 分层与 DFS 增广。
- **自动模式**：AI 自动调整区间，以“贪吃蛇”式渐进探索最优解。

---

### 核心代码实现

**Dinic 算法模板（带当前弧优化）**：
```cpp
bool bfs(int s, int t) {
    memset(depth, 0, sizeof(depth));
    queue<int> q;
    depth[s] = 1; q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].to;
            if (e[i].dis > 0 && !depth[v]) {
                depth[v] = depth[u] + 1;
                q.push(v);
                if (v == t) return true;
            }
        }
    }
    return false;
}
int dinic(int u, int t, int flow) {
    if (u == t) return flow;
    int rest = flow;
    for (int &i = cur[u]; i && rest; i = e[i].next) {
        int v = e[i].to;
        if (depth[v] == depth[u]+1 && e[i].dis) {
            int k = dinic(v, t, min(rest, e[i].dis));
            if (!k) depth[v] = 0;
            rest -= k;
            e[i].dis -= k;
            e[i^1].dis += k;
        }
    }
    return flow - rest;
}
```

---

**总结**：本题解的核心在于将原问题转化为区间覆盖验证问题，通过高效网络流算法实现快速判定。结合二分或暴力枚举，在时间复杂度与代码复杂度间取得平衡，适合作为网络流建模经典例题。

---
处理用时：87.47秒
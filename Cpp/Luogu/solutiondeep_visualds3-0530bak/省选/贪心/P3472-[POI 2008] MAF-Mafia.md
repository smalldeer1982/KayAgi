# 题目信息

# [POI 2008] MAF-Mafia

## 题目描述

在赤道 Byteotia，黑帮之间的争斗愈演愈烈。黑帮老大们来到该国的首都 Byteburg，以解决争端。

谈判非常紧张，在某个时刻，手痒的参与者们拔出了他们的枪。

每个参与者都用手枪瞄准另一个人。

如果他们开始大开杀戒，射击将按照以下荣誉代码进行：

参与者按一定顺序射击，并且在任何时刻最多只有一个人开枪，射手不会失手，他的目标会立即死亡，因此他之后不能再开枪，每个人都开一次枪，前提是他在有机会开枪之前没有被击中，任何参与者都不能改变他最初选择的目标，即使目标已经死了（那么射击不会造成进一步的伤亡）。

一个殡葬承办人从远处观察，正如他通常所做的那样。毕竟，黑帮分子从未让他的生意冷清过。

他在射击中看到了潜在的利润，但他想知道准确的估计。他想知道最小和最大可能的死亡率。

殡葬承办人看到谁瞄准了谁，但不知道射击的顺序。

你需要编写一个程序来确定他如此渴望知道的数字。

任务 编写一个程序：

从标准输入读取每个黑帮分子选择的目标，确定最小和最大伤亡人数，将结果写入标准输出。

## 说明/提示

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
8
2 3 2 2 6 7 8 5
```

### 输出

```
3 5
```

# AI分析结果



---

### **综合分析与结论**

#### **核心思路**
1. **图结构分析**：每个节点指向唯一目标，形成基环内向树森林（环+树结构）。
2. **贪心策略**：
   - **最小值**：优先处理入度为0的节点（存活），其目标必死，拓扑排序后剩余环的存活数为环大小的一半。
   - **最大值**：尽可能让更多节点死亡，环的死亡数为环大小（若有外部节点指向）或环大小-1（独立环）。
3. **关键难点**：正确区分环是否被外部节点影响，并计算环的贡献。

#### **可视化设计**
- **像素风格动画**：
  - **颜色标记**：绿色（存活）、红色（死亡）、黄色（当前处理节点）、蓝色（环）。
  - **动画步骤**：
    1. 初始图展示所有节点及箭头。
    2. 入度为0的节点被高亮，触发拓扑排序，逐个标记其目标死亡。
    3. 剩余环以旋转动画显示，根据环大小计算存活数。
  - **音效**：击杀时播放“射击”音效，环处理完成时播放胜利音效。
  - **交互**：支持暂停/继续，手动步进观察贪心选择。

---

### **题解评分（≥4星）**

1. **作者：Vocanda（★★★★★）**
   - **亮点**：代码简洁，利用队列处理拓扑，直接遍历环，逻辑清晰。
   - **关键代码**：
     ```cpp
     while(q.size()){
         int u = q.front(); q.pop();
         if (die[a[u]]) continue;
         die[a[u]] = 1;
         if (!(--rd[a[a[u]]])) q.push(a[a[u]]);
     }
     ```

2. **作者：Always（★★★★☆）**
   - **亮点**：结合Tarjan缩点处理复杂环，结构严谨。
   - **优化**：缩点后统计新图入度，适合处理大规模数据。

3. **作者：hzoi_liuchang（★★★★☆）**
   - **亮点**：通过`son[]`标记环是否被外部影响，简化最大值计算。
   - **心得**：“环上若有子树则全灭”的观察是关键。

---

### **最优思路与代码实现**

#### **贪心核心逻辑**
- **最小值计算**：
  ```cpp
  // 拓扑处理入度为0的节点
  queue<int> q;
  for (int i = 1; i <= n; i++) {
      if (rd[i] == 0) q.push(i), min_alive++;
  }
  while (!q.empty()) {
      int u = q.front(); q.pop();
      if (die[target[u]]) continue;
      die[target[u]] = true;
      if (--rd[target[target[u]]] == 0) {
          q.push(target[target[u]]);
          min_alive++;
      }
  }
  // 处理环
  for (环中节点) {
      min_alive += 环大小 / 2;
  }
  ```
- **最大值计算**：
  ```cpp
  for (环中节点) {
      if (环有外部指向) max_death += 环大小;
      else max_death += 环大小 - 1;
  }
  ```

---

### **相似题目推荐**
1. **P2661 [NOIP2015 提高组] 信息传递**  
   - **关键词**：最小环检测，DFS或并查集。
2. **P1983 [NOIP2013 普及组] 车站分级**  
   - **关键词**：拓扑排序，层级贪心。
3. **P5022 [NOIP2018 提高组] 旅行**  
   - **关键词**：基环树上的贪心遍历。

---

### **可视化方案（复古像素版）**

#### **Canvas 绘制逻辑**
1. **初始化**：
   - 节点为像素方块，箭头表示指向。
   - 入度为0的节点闪烁绿色。
2. **拓扑过程**：
   - 选中节点高亮黄色，目标变红，播放“射击”音效。
3. **环处理**：
   - 环节点旋转动画，存活节点显示绿色，死亡节点渐隐。

#### **音效设计**
- **击杀音效**：8-bit短促“砰”声。
- **环处理完成**：经典过关音效。

---

### **代码片段（贪心核心）**

```cpp
// 最小值计算核心代码
void calc_min() {
    queue<int> q;
    for (int i = 1; i <= n; i++) {
        if (in[i] == 0) q.push(i), min_alive++;
    }
    while (!q.empty()) {
        int u = q.front(); q.pop();
        int v = target[u];
        if (die[v]) continue;
        die[v] = true;
        int w = target[v];
        in[w]--;
        if (in[w] == 0) {
            q.push(w);
            min_alive++;
        }
    }
    // 处理环
    for (int i = 1; i <= n; i++) {
        if (!die[i] && in[i] > 0) {
            int len = 0, has_out = 0;
            for (int j = i; !die[j]; j = target[j]) {
                die[j] = true;
                len++;
                has_out |= (in[j] > 0);
            }
            min_alive += (len + 1) / 2;
        }
    }
}
```

---

**通过上述分析，读者可深入理解贪心策略在处理基环树问题中的应用，并通过可视化加深对拓扑排序和环处理的理解。**

---
处理用时：74.30秒
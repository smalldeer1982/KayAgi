# 题目信息

# [JSOI2010] 缓存交换

## 题目背景

感谢@ACdreamer 贡献数据

## 题目描述

在计算机中，CPU只能和高速缓存Cache直接交换数据。当所需的内存单元不在Cache中时，则需要从主存里把数据调入Cache。此时，如果Cache容量已满，则必须先从中删除一个。 

例如，当前Cache容量为3，且已经有编号为10和20的主存单元。 
此时，CPU访问编号为10的主存单元，Cache命中。 

接着，CPU访问编号为21的主存单元，那么只需将该主存单元移入Cache中，造成一次缺失（Cache Miss）。 

接着，CPU访问编号为31的主存单元，则必须从Cache中换出一块，才能将编号为31的主存单元移入Cache，假设我们移出了编号为10的主存单元。 

接着，CPU再次访问编号为10的主存单元，则又引起了一次缺失。我们看到，如果在上一次删除时，删除其他的单元，则可以避免本次访问的缺失。 

在现代计算机中，往往采用LRU(最近最少使用)的算法来进行Cache调度——可是，从上一个例子就能看出，这并不是最优的算法。 
对于一个固定容量的空Cache和连续的若干主存访问请求，聪聪想知道如何在每次Cache缺失时换出正确的主存单元，以达到最少的Cache缺失次数。

## 说明/提示

在第4次缺失时将3号单元换出Cache。 

## 样例 #1

### 输入

```
6 2
1 2 3 1 2 3```

### 输出

```
4```

# AI分析结果



### 题解思路、算法要点与解决难点

**核心贪心策略**  
每次 Cache 满时，替换下一次访问最晚的元素。此策略可减少未来替换次数，数学证明其最优性。

**关键实现步骤**  
1. **离散化**：将大范围主存编号映射到小范围。  
2. **预处理 next 数组**：记录每个元素下次出现的位置。  
3. **优先队列维护**：按 next 值排序，堆顶为最优替换目标。  
4. **状态标记**：用 vis 数组跟踪元素是否在 Cache 中。

**难点与解决方案**  
- **无效堆元素**：同一元素多次入堆时，通过 vis 数组过滤失效记录。  
- **动态更新 next**：每次访问元素后重新压入最新 next 值，确保堆中始终包含最新信息。

---

### 题解评分 (4星及以上)

1. **CW666（4.5星）**  
   - **亮点**：代码简洁，注释清晰，优先队列处理逻辑直接。  
   - **优化**：离散化与 next 数组预处理高效。  
   - **代码可读性**：良好，适合初学者理解贪心流程。

2. **swhsz（4星）**  
   - **亮点**：极简实现，优先队列结合 next 更新策略。  
   - **代码风格**：紧凑但缺少注释，需一定经验理解。

3. **SuperJvRuo（4星）**  
   - **亮点**：动态维护链表结构，直接更新下次访问位置。  
   - **创新点**：使用链表而非数组预处理 next。

---

### 最优思路与技巧提炼

**核心贪心依据**  
- **选择依据**：替换下次访问最晚的元素（最长不活跃）。  
- **数据结构**：优先队列（大根堆）按 next 值排序。  
- **离散化技巧**：`sort + unique + lower_bound` 快速映射。

**关键代码片段**  
```cpp
// 预处理 next 数组（逆序遍历）
for (int i = n; i >= 1; --i) {
    next[i] = last[a[i]];
    last[a[i]] = i;
}

// 贪心选择与替换
priority_queue<pair<int, int>> q; // pair<next_time, element>
for (int i = 1; i <= n; ++i) {
    if (!vis[a[i]]) { // Cache Miss
        ans++;
        if (q.size() >= m) { // 替换
            vis[q.top().second] = 0;
            q.pop();
        }
        vis[a[i]] = 1;
    }
    q.push({next[i], a[i]}); // 更新或插入新记录
}
```

---

### 类似题目推荐

1. **P3419 [POI2005]SAM-Toy Cars**  
   - **相似点**：贪心替换最远使用元素，优先队列实现。  
2. **CF802A Heidi and Library**  
   - **相似点**：Cache 替换策略，需预处理下次使用时间。  
3. **P2088 数据备份**  
   - **相似点**：贪心选择最优元素，堆结构维护动态极值。

---

### 可视化与算法演示设计

**动画方案**  
- **像素风格显示**：Cache 显示为格子，主存访问流横向滚动。  
- **高亮操作**：当前访问元素红色闪烁，替换元素标红叉。  
- **动态更新**：显示 next 值在元素上方，堆结构右侧同步更新。

**交互功能**  
- **步进控制**：空格键单步执行，速度滑块调节动画速度。  
- **音效反馈**：命中（清脆声）、缺失（低沉声）、替换（爆炸音）。  
- **自动模式**：AI 自动运行，展示贪心决策过程。

**复古游戏化设计**  
- **8-bit 音效**：使用 Web Audio 生成芯片音乐。  
- **积分系统**：每正确替换得 100 分，连击加成。  
- **关卡模式**：逐步增加 Cache 大小，难度递增。

---

### 代码实现（核心贪心逻辑）

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m; scanf("%d%d", &n, &m);
    vector<int> a(n), b(n);
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a[i]);
        b[i] = a[i];
    }
    // 离散化
    sort(b.begin(), b.end());
    b.erase(unique(b.begin(), b.end()), b.end());
    for (int &x : a) 
        x = lower_bound(b.begin(), b.end(), x) - b.begin();
    
    // 预处理 next 数组
    vector<int> last(b.size(), n), next(n);
    for (int i = n-1; i >= 0; --i) {
        next[i] = last[a[i]];
        last[a[i]] = i;
    }
    
    int ans = 0;
    priority_queue<pair<int, int>> q; // <next_time, element>
    vector<bool> in_cache(b.size(), false);
    
    for (int i = 0; i < n; ++i) {
        if (!in_cache[a[i]]) { // Cache Miss
            ans++;
            if (q.size() >= m) { // 替换
                auto [t, x] = q.top();
                in_cache[x] = false;
                q.pop();
            }
            in_cache[a[i]] = true;
        }
        q.push({next[i], a[i]}); // 更新 next 值
    }
    printf("%d\n", ans);
    return 0;
}
```

---
处理用时：90.35秒
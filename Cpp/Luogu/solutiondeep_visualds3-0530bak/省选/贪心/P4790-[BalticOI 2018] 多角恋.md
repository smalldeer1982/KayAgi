# 题目信息

# [BalticOI 2018] 多角恋

## 题目描述

**题目译自 [BalticOI 2018](https://boi2018.progolymp.se/tasks/) Day1「[Love Polygon](https://boi18-day1-open.kattis.com/problems/boi18.polygon)」**

给一张 $N$ 个点的有向图，每个点的出度为 $1$。每次可以花费 $1$ 的代价修改图上的一条边的终点，也就是改变从一个点出发所到达的点。求最少需要花费多少代价，才能使这张图形成若干个两两不相交的二元环，并且图上的所有点都在某一个环里。

## 说明/提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/1ojydan1.png)

唯一的最优解如上图所示，图的上半部分为原图，底色为粉色的三个点为需要修改的边的起点；图的下半部分表示修改后的情况。

#### 样例 2 解释

存在多组最优解。其中一种是分别改变一条以 ``a``、``b`` 和 ``d`` 为起点的边，使他们分别连接到 ``b``、``a`` 和 `c`。

#### 样例 3 解释

图中有 $3$ 个点，无论如何修改边的终点，总会有一个人不在环里。


| 子任务 | 分值 | 数据范围 | 附加限制 |
|:----------:|:-------:|:-------------:|:-------------:|
|$1$|$21$|$2\leqslant N\leqslant 20$|.|
|$2$|$25$|$2\leqslant N\leqslant 100\, 000$|每个点都有一条入边（可能有自环）|
|$3$|$29$|$2\leqslant N\leqslant 100\, 000$|不存在两个点或更多个点构成的环|
|$4$|$25$|$2\leqslant N\leqslant 100\, 000$|.|



## 样例 #1

### 输入

```
8
leonard emmy
ada emmy
isaac leonard
emmy pierre
pierre bernhard
bernhard emmy
sofia karl
karl sofia```

### 输出

```
3
```

## 样例 #2

### 输入

```
4
a c
b c
c d
d d```

### 输出

```
3
```

## 样例 #3

### 输入

```
3
rocky scarlet
scarlet patrick
patrick rocky```

### 输出

```
-1
```

# AI分析结果



### 综合分析与结论

**核心思路**：  
题目要求将基环森林（每个点出度1）通过最少修改转化为全二元环。核心贪心策略为：  
1. **预处理已有二元环**：直接标记无需修改的边。  
2. **拓扑排序处理链结构**：处理入度为0的节点，每次选择入度为0的点，将其指向修正为链的下一个节点，逐步消除链式结构。  
3. **处理剩余环**：每个环的代价为 ⌈环长/2⌉，通过DFS统计环长并计算贡献。  

**贪心正确性证明**：  
- 拓扑处理链结构能最小化修改次数（每个链只需修改一次即可形成二元环）。  
- 环的奇偶性处理确保了总节点数为偶数时的可行性。  

**可视化设计**：  
- **颜色标记**：绿色为已处理节点，红色为当前处理的入度为0节点，蓝色为环结构。  
- **动画步骤**：分步展示拓扑队列处理链、环的DFS过程，高亮每次贪心选择。  
- **复古像素风格**：用8-bit色块表示节点，箭头表示边，音效提示处理完成。  

---

### 题解清单 (≥4星)

1. **cc123321（★★★★☆）**  
   - **亮点**：清晰分层处理（预处理环→拓扑链→环统计），代码简洁高效。  
   - **关键代码**：队列处理入度为0节点，环长奇偶性判断。  

2. **封禁用户（★★★★☆）**  
   - **亮点**：深入分析基环树结构，动态规划处理子树最优解，理论完备。  
   - **个人心得**："对于每个节点，先考虑和子节点匹配，再和父节点匹配。"  

3. **Endt（★★★★☆）**  
   - **亮点**：极简贪心实现，直接分离已配对节点，剩余部分统一处理。  
   - **关键优化**：使用`use`数组标记处理状态，避免重复计算。  

---

### 核心代码实现

**贪心处理拓扑链与环统计**  
```cpp
// 预处理已有二元环
for(int i=1; i<=n; i++) 
    if(i == nex[nex[i]] && !use[i] && !use[nex[i]]) 
        use[i] = use[nex[i]] = 1;

// 拓扑排序处理入度为0的节点
queue<int> q;
for(int i=1; i<=n; i++) 
    if(!deg[i] && !use[i]) 
        q.push(i);

while(!q.empty()) {
    int now = q.front(); q.pop();
    ans++;
    if(!use[nex[now]]) {
        use[nex[now]] = 1;
        if(--deg[nex[nex[now]]] == 0 && !use[nex[nex[now]]])
            q.push(nex[nex[now]]);
    }
}

// 处理剩余环
for(int i=1; i<=n; i++) 
    if(!use[i]) {
        int len = dfs(i); // DFS统计环长
        ans += len/2 + (len%2 ? 1 : 0);
    }
```

---

### 同类型题与算法套路

**常见贪心场景**：  
- **基环树处理**：拓扑排序消除链，环上决策。  
- **配对问题**：两两匹配的最小修改，优先处理稳定结构。  

**推荐题目**：  
1. P2661 信息传递（基环树找最小环）  
2. P2607 骑士（基环树DP）  
3. P5022 旅行（基环树贪心遍历）  

---

### 个人心得摘录

- **cc123321**：  
  "先处理入度为0的节点能有效拆解链式结构，环的处理必须放在最后。"  
- **Endt调试经验**：  
  "自环需要特判，否则DFS会死循环。"  

---

### 可视化方案（贪心过程）

**动画步骤**：  
1. **初始图**：显示所有节点及出边，绿色为已配对的二元环。  
2. **拓扑处理**：红色节点入队，处理时显示边修改为虚线，更新队列。  
3. **环处理**：蓝色高亮当前环，DFS显示环长，计算贡献时显示数值。  

**复古交互设计**：  
- **8-bit像素风格**：节点为16x16色块，边为箭头像素图。  
- **音效**：处理节点时播放“哔”声，环处理完成时播放胜利音效。  
- **自动演示**：按空格暂停/继续，方向键控制速度。  

```javascript
// 伪代码：Canvas绘制节点与边
function drawNode(ctx, x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x-8, y-8, 16, 16); // 像素方块
}

function drawEdge(ctx, from, to) {
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y); // 箭头绘制略
    ctx.strokeStyle = '#FFF';
    ctx.stroke();
}
```

**游戏化积分**：每处理一个节点+10分，环处理+50分，错误选择扣分。

---
处理用时：64.38秒
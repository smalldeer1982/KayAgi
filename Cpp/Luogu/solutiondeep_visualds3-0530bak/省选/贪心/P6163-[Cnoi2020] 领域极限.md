# 题目信息

# [Cnoi2020] 领域极限

## 题目描述

Cirno 有 $n$ 个整数，分别记作 $a_1,a_2,a_3,...,a_n$。

对于每一个数 $a_i$ 都有一个限制二元组 $(l_i,r_i)$。

Cirno 想知道：

$$\min_{\forall t, a_t \in [l_t,r_t]}\big\{\sum_{i=1}^{n}\sum_{j=1}^{n}\left| a_i - a_j \right|\big\}$$

## 说明/提示

### Sample1说明

$(a_1,a_2,a_3)=(2,3,3)$ 时，答案取到最小值。

### 数据范围与约定

**「本题采用捆绑测试」**

 - Subtask1( $20\%$ ) : $n \le 10$，且 $r_i - l_i \le 5$；
 - Subtask2( $20\%$ ) : $n \le 20$；
 - Subtask3( $20\%$ ) : $n \le 10^3$；
 - Subtask4( $40\%$ ) : $n \le 10^5$；

对于 $100\%$ 的数据 : $n \in (0,10^5]$，$0 \le l_i \le r_i \le 10^9$，答案在 $[0,4 \times 10^{18}]$ 内。

## 样例 #1

### 输入

```
3
1 2
2 3
3 4```

### 输出

```
4```

## 样例 #2

### 输入

```
8
39 42
53 55
51 52
46 47
52 54
33 38
2 7
32 34```

### 输出

```
910```

# AI分析结果



### 综合分析与结论

题目要求从每个区间选一个数，使得所有数两两绝对差之和最小。核心难点在于找到各区间取值的平衡点，使整体分布紧凑。关键思路是通过贪心策略或二分法确定最优中心点，利用排序与贡献计算优化复杂度。

#### 核心贪心策略与难点
- **贪心选择依据**：每次处理贡献最大的极值点（最大左端点与最小右端点），其差值必须累加至答案，直至无法形成有效贡献。
- **正确性验证**：当最大左端点超过最小右端点时，二者无法共存于同一位置，必须分别取端点值，贡献为差值乘以剩余配对次数。
- **实现难点**：如何高效维护极值点的选取，以及快速计算贡献。

### 题解评分（≥4星）

1. **Arghariza的题解（5星）**  
   - **亮点**：代码极简，时间复杂度O(n log n)，直接排序后处理极值点，思路源于ARC官方题解，正确性高。
   - **关键代码**：
     ```cpp
     sort(l + 1, l + n + 1, greater<int> ());
     sort(r + 1, r + n + 1);
     for (int i = 1; i <= n; i++) {
         if (l[i] <= r[i]) break;
         res += 1ll * (l[i] - r[i]) * (n - 2 * i + 1);
     }
     ```

2. **George1123的题解（4星）**  
   - **亮点**：二分法确定最优中心点，离散化端点减少计算量，思路清晰。
   - **关键逻辑**：V型函数性质验证，离散化端点后二分查找。

3. **Dyc2022的题解（4星）**  
   - **亮点**：公式推导明确，将绝对差和转化为排序后的系数加权和，贪心选择端点。

### 最优思路提炼

**贪心策略**：  
1. 将区间左端点降序排序，右端点升序排序。
2. 依次取当前最大左端点与最小右端点，若左 > 右，贡献为差值乘以剩余配对次数。
3. 累加贡献直至左端点 ≤ 右端点，此时剩余区间存在公共交点。

### 同类型题与算法套路

- **通用解法**：极值处理（贪心）、贡献排序、配对消除。
- **类似题目**：
  1. [ARC147C - Min Diff Sum](https://atcoder.jp/contests/arc147/tasks/arc147_c)（本题双倍经验）
  2. [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)（贪心排序策略）
  3. [P2887 防晒霜](https://www.luogu.com.cn/problem/P2887)（区间匹配与贪心）

---

### 可视化与算法演示（核心贪心过程）

**动画设计**：
- **像素风格**：区间端点以不同颜色方块表示，排序后左右端点队列动态变化。
- **关键步骤**：
  1. **高亮当前极值**：最大左端点（红色）、最小右端点（蓝色）。
  2. **贡献计算**：显示差值及剩余配对次数，累加至总和。
  3. **消除处理**：将处理过的端点移出队列，更新剩余区间。
- **音效**：选择时播放“滴”声，贡献累加时播放“叮”声，背景8-bit音乐循环。

**交互功能**：
- **自动演示**：按固定速度逐步处理极值点。
- **手动控制**：暂停/继续、单步执行、调整速度。
- **可视化比较**：并行展示二分法与贪心策略的决策差异。

---

### 代码实现（核心贪心逻辑）

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=3e5+5;
int n,l[N],r[N];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d%d",l+i,r+i);
    sort(l+1,l+n+1,greater<int>());
    sort(r+1,r+n+1);
    ll res=0;
    for(int i=1;i<=n && l[i]>r[i];i++)
        res+=1ll*(l[i]-r[i])*(n-2*i+1);
    printf("%lld\n",res*2);
    return 0;
}
```

**核心思想**：排序后贪心处理极值点，累加必须贡献，时间复杂度O(n log n)。

---

### 个人心得摘录

- **Arghariza**：ARC题解思路移植，验证了极值处理的正确性。
- **Sol1**：调试中发现中位数性质，但代码复杂度较高。
- **Dyc2022**：公式推导中的系数对称性启发贪心策略。

---
处理用时：73.35秒
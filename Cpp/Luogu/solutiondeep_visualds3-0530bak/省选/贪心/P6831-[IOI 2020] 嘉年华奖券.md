# 题目信息

# [IOI 2020] 嘉年华奖券

## 题目背景

**本题为交互题。**

请在程序开头声明 `void allocate_tickets(std::vector<std::vector<int> > s);` 和使用 vector 头文件，并且请在调用函数前加上 `extern "C"`。

## 题目描述

Ringo 正在参加在新加坡举办的一个嘉年华活动。他的口袋里装有一些奖券，这些奖券可以在嘉年华的游戏展位使用。假设共有 $n$ 种颜色的奖券，每张奖券涂上了其中的一种颜色并且印上了一个非负整数。不同奖券上的数字可能相同。依据嘉年华活动的规则要求，$n$ 保证是偶数。

Ringo 每种颜色的奖券有 $m$ 张，也就是说他共有 $n \cdot m$ 张奖券。其中，第 $i$ 种颜色对应的第 $j$ 张奖券上印的数字为 $x[i][j]$（$0 \le i \le n-1$ 且 $0 \le j \le m-1$）。

一次奖券游戏要进行 $k$ 轮，轮次的序号从 $0$ 到 $k-1$。每一轮按照下面的方式进行：

- 首先，Ringo 从每种颜色的奖券中各选出一张奖券，形成一个 $n$ 张奖券的 **集合**。
- 随后，游戏负责人记录下这个集合中奖券上的数字 $a[0],a[1],\ldots,a[n-1]$。不需要考虑这 $n$ 个整数的顺序。
- 接下来，游戏负责人从一个幸运抽奖箱中抽取一张特殊卡片，上面印有整数 $b$。
- 对于上述集合中每一个奖券上的数字 $a[i](0\le i \le n-1)$，游戏负责人会计算 $a[i]$ 和 $b$ 的差的绝对值。让 $S$ 代表这 $n$ 个差的绝对值之和。
- 所得到的数字 $S$ 就是 Ringo 本轮能够获得的奖励数额。
- 一轮游戏结束后，本轮集合中的奖券全部被丢弃，不会在未来的轮次所使用。

当 $k$ 轮游戏结束后，Ringo 会丢弃口袋中的所有奖券。

通过仔细观察，Ringo 发现这个奖券游戏被操控了！实际上，幸运抽奖箱里面内置了一台打印机。在每一轮，游戏负责人首先找到一个能够最小化当前轮次游戏奖励的整数 $b$，然后将该数字打印在他所抽取的特殊卡片上。

知道了这些信息之后，Ringo 想要设计每轮游戏中的奖券分配方案，使得 $k$ 轮游戏中获得的总体奖励数额之和最大。

#### 实现细节

你需要实现下面这个函数：

```cpp
long long find_maximum(int k,std::vector<std::vector<int>> x)
```

- $k$：游戏的轮数。
- $x$：一个 $n \times m$ 的数组，记录了奖券上的数字。每种颜色的奖券按照上面的数字非递减顺序排序。
- 这个函数只会被调用一次。
- 这个函数应该只调用一次函数 `allocate_tickets`（参见下面的内容），它描述了 $k$ 轮游戏中的奖券分配方案，每一轮对应一个奖券集合。奖券的分配方案应该使得所获奖励数额之和达到最大。
- 这个函数需要返回能够获得的最大的奖励数额之和。

函数 `allocate_tickets` 按照如下的方式进行定义：

```cpp
void allocate_tickets(std::vector<std::vector<int>> s)
```
  
- $s$：一个 $n \times m$ 的数组。如果第 $i$ 种颜色的第 $j$ 张奖券如果被分配到了第 $r$ 轮游戏，那么 $s[i][j]$ 的值应该为 $r$；如果未被使用，应该为 $-1$。
- 对于 $0 \le i \le n-1$，在 $s[i][0],s[i][1],\ldots,s[i][m-1]$ 中，每个值 $0,1,\ldots,k-1$ 必须只出现一次，而其他元素应该为 $-1$。
- 如果存在多种奖券分配方案能够达到最优的奖励数值，可以给出其中任何一种最优方案。

## 说明/提示

#### 样例说明

#### 例 1

考虑下面的函数调用：

```cpp
find_maximum(2, [[0, 2, 5],[1, 1, 3]])
  ```
这意味着：

- 游戏共进行 $k=2$ 轮；
- 第 $0$ 种颜色奖券上的整数数字分别是 $0,2$ 和 $5$；
- 第 $1$ 种颜色奖券上的整数数字分别是 $1,1$ 和 $3$；

一种能够获得最优奖励数值的分配方案是：

- 在第 $0$ 轮，Ringo 选择第 $0$ 种颜色的第 $0$ 张奖券（印有整数 $0$）和第 $1$ 种颜色的第 $2$ 张奖券（印有整数 $3$）。本轮获得的最小奖励数额是 $3$。例如，游戏负责人可以选择 $b=1$：$|1-0| + |1-3| = 1+2 = 3$。
- 在第 $1$ 轮，Ringo 选择第 $0$ 种颜色的第 $2$ 张奖券（印有整数 $5$）和第 $1$ 种颜色的第 $1$ 张奖券（印有整数 $1$）。本轮能够获得的最小奖励是 $4$。例如，游戏负责人可以选择 $b=3$：$|3-1|+|3-5|=2+2=4$。
- 因此，本次游戏两轮的奖励之和为 $3+4=7$。

为了给出这个分配方案，函数 `find_maximum` 应该按照如下方式调用 `allocate_tickets`：

```cpp
allocate_tickets([[0, -1, 1], [-1, 1, 0]])
```
  
  最终，函数 `find_maximum` 应该返回数字 $7$。
  
#### 例 2

考虑下面的函数调用：

```cpp
find_maximum(1, [[5, 9], [1, 4], [3, 6], [2, 7]])
```

这意味着：

- 游戏只进行一轮；
- 第 $0$ 种颜色奖券上的数字分别是 $5$ 和 $9$；
- 第 $1$ 种颜色奖券上的数字分别是 $1$ 和 $4$；
- 第 $2$ 种颜色奖券上的数字分别是 $3$ 和 $6$；
- 第 $3$ 种颜色奖券上的数字分别是 $2$ 和 $7$；

一种能够获得最优奖励的分配方案是：

- 在第 $0$ 轮，Ringo 选择第 $0$ 种颜色的第 $1$ 张奖券（印有整数 $9$），第 $1$ 种颜色的第 $0$ 张奖券（印有整数 $1$），第 $2$ 种颜色的第 $0$ 张奖券（印有整数 $3$），第 $3$ 种颜色的第 $1$ 张奖券（印有整数 $7$）。本轮能够获得的最小奖励是 $12$。例如，游戏负责人可以选择 $b=3$：$|3-9| + |3-1| + |3-3| + |3-7| = 6 + 2 + 0 + 4 = 12$。

为了给出这个分配方案，函数 `find_maximum` 应该按照如下方式调用 `allocate_tickets`：

```cpp
allocate_tickets([[-1, 0], [0, -1], [0, -1], [-1, 0]])
```

最终，函数 `find_maximum` 应该返回数字 $12$。

#### 约束条件

- $2\le n\le 1500$ 且 $n$ 为偶数
- $1\le k\le m\le 1500$
- $0 \le x[i][j] \le 10^9$（对于所有的 $0 \le i \le n-1$ 且 $0 \le j \le m-1$）
- $x[i][j-1] \le x[i][j]$（对于所有的 $0 \le i \le n-1$ 且 $0 \le j \le m-1$）

#### 子任务

1. （11 分）$m=1$
2. （16 分）$k=1$
3. （14 分）$0 \le x[i][j] \le 1$（对于所有的 $0 \le i \le n-1$ 且 $0 \le j \le m-1$）
4. （14 分）$k=m$
5. （12 分）$n,m \le 80$
6. （23 分）$n,m \le 300$
7. （10 分）没有额外约束条件

#### 评测程序示例

评测程序示例按照下面的格式读入数据：

第 $1$ 行：$n\ m\ k$        
第 $2+i$ 行（$0 \le i \le n-1$）：$x[i][0]\ x[i][1]\ \ldots \ x[i][m-1]$

评测程序示例按照下面的格式打印你的答案：

第 $1$ 行：`find_maximum` 的返回值       
第 $2+i$ 行（$0 \le i \le n-1$）：$s[i][0]\ s[i][1]\ \ldots\ s[i][m-1]$

# AI分析结果



---

### **综合分析与结论**

#### **核心思路**
1. **贪心策略**：将每个颜色的前k小数初始化为负贡献，通过优先队列选择每次替换（将某个颜色的一个负贡献替换为正贡献）的最大收益，累计替换nk/2次以获得最大总和。
2. **构造分配方案**：确保每轮选取的正贡献数均大于等于负贡献数，通过排序和双指针维护正负数边界。

#### **难点与解决**
- **贪心正确性证明**：需验证每次局部最优替换能导致全局最优。通过数学归纳法和交换论证可证。
- **分配合法性**：通过递归分组或排序策略，保证每组正数集合的下界不小于负数集合的上界。

#### **可视化设计**
- **贪心替换动画**：用优先队列的动态变化展示每次选择的颜色和数值，高亮替换操作。
- **复古像素风格**：用8位色块表示颜色，正数用绿色，负数用红色，替换时播放“升级”音效。
- **自动演示模式**：模拟贪心选择过程，允许暂停观察替换后的数值分布。

---

### **题解清单 (4星以上)**

1. **s_r_f (⭐️⭐️⭐️⭐️)**
   - **亮点**：详细证明贪心策略的正确性，递归构造分配方案，代码可读性较高。
   - **心得**：强调通过递归分组维护正负数的大小关系，确保合法性。

2. **tzc_wk (⭐️⭐️⭐️⭐️)**
   - **亮点**：代码简洁高效，直接通过排序分组构造方案，时间复杂度低。
   - **技巧**：每轮按可用负数数量排序颜色，前n/2分配负数，后n/2分配正数。

---

### **关键代码片段**

#### **s_r_f的贪心替换逻辑**
```cpp
priority_queue<Node> H;
for (i = 0; i < n; ++i) {
    nl[i] = k-1, nr[i] = m-1;
    vv[i] = val[i][nl[i]] + val[i][nr[i]];
    H.push({i, vv[i]});
}
while (ll--) {
    Node tmp = H.top(); H.pop();
    i = tmp.id;
    z[i][nl[i]] = 0, z[i][nr[i]] = 1; // 标记替换
    --nl[i], --nr[i];
    if (nl[i] >= 0) {
        vv[i] = val[i][nl[i]] + val[i][nr[i]];
        H.push({i, vv[i]});
    }
}
```

#### **tzc_wk的分配构造逻辑**
```cpp
sort(ord, ord+n, [&](int x, int y) { return L[x] > L[y]; });
for (j=0; j<n/2; j++) ans[ord[j]][L[ord[j]]] = i; // 分配负数
for (j=n/2; j<n; j++) ans[ord[j]][R[ord[j]]] = i; // 分配正数
```

---

### **同类型题推荐**
1. **区间调度最大化**：选择不重叠区间使数量最多（洛谷P1803）。
2. **最小代价分糖果**：将糖果分两组，使差值最小（类似贪心策略，LeetCode 135）。
3. **任务调度器**：按冷却时间调度任务（LeetCode 621）。

---

### **可视化设计要点**
1. **像素风格**：每个颜色用8x8像素块表示，正数高亮为绿，负数灰暗。
2. **动画流程**：
   - **替换阶段**：优先队列动态显示，每次弹出最大值并更新颜色块。
   - **分配阶段**：每轮颜色排序后，左侧分配负数，右侧分配正数，边界用黄线标记。
3. **音效**：替换时播放“哔”声，分配成功时播放“叮”声，背景音乐为8位循环旋律。
4. **交互控制**：支持暂停/继续，调整动画速度，查看当前替换次数和总和。

---

**答案示例（仅核心部分）**

```cpp
// 贪心替换核心代码（s_r_f）
void calcz() {
    priority_queue<Node> q;
    for (int i=0; i<n; ++i) {
        L[i] = k-1, R[i] = m-1;
        q.push({i, x[i][L[i]] + x[i][R[i]]});
    }
    for (int cnt=0; cnt < n*k/2; ++cnt) {
        auto [id, _] = q.top(); q.pop();
        coef[id][L[id]] = 0; // 取消负贡献
        coef[id][R[id]] = 1; // 添加正贡献
        L[id]--, R[id]--;
        if (L[id] >= 0) 
            q.push({id, x[id][L[id]] + x[id][R[id]]});
    }
}
```

---
处理用时：101.56秒
# 题目信息

# [JOISC 2021] イベント巡り 2 (Event Hopping 2) (Day4)

## 题目背景

**因洛谷限制，本题不予评测每个 Subtask 的第 1 ~ 20 个测试点，您可以 [点此](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day4/event2-data.zip) 下载所有数据自行评测或在 [这里](https://www.luogu.com.cn/problem/U159034) 测试，若您希望写本题题解，建议您在通过 [本题](https://www.luogu.com.cn/problem/P7562) 与 [每个 Subtask 前 20 个测试点](https://www.luogu.com.cn/problem/U159034) 之后再写题解。**


## 题目描述

IOI Park 将有 $n$ 场活动。

这些活动的编号从 $1$ 到 $n$。 活动 $i$ 从时间 $L_i+10^{-1}$ 到时间 $R_i-10^{-1}$ 举行。数据保证 $L_i$ 和 $R_i$ 是整数。

JOI 君决定参加其中的 $k$ 个活动。但是，JOI 君不能在中间加入或离开每个活动。**在两个活动场所间移动的时间忽略不计**。

JOI 君希望参加编号较小的活动。严格来说，JOI 君参加的 $k$ 个活动的编号依次为 $a_1,\cdots,a_k$，其中 $1 \le a_1 < \cdots < a_k \le n$。如果序列 $(a_1, \cdots, a_k)$ 的编号小于 $(b_1, \cdots, b_k)$，当且仅当存在 $j\ (1 \le j \le k)$ 满足在区间 $[1,j-1]$ 里的所有 $l$ 都有 $a_l=b_l$ 和 $a_j<b_j$。



给出每个活动的信息和 JOI 君参加的活动个数 $k$，判断 JOI 君是否可以参加 $k$ 个活动，如果可以，输出所有的 $k$ 个活动的编号。



## 说明/提示

#### 样例 #1 解释

有 $2$ 种方式可以参加正好 $4$ 个活动。

- 参加 $1, 3, 4, 5$；
- 参加 $2, 3, 4, 5$。

数列 $(1,3,4,5)$ 比数列 $(2, 3, 4, 5)$ 字典序小，所以输出 $1, 3, 4, 5$。

#### 样例 #2 解释

无论怎么选择都不可能正好参加 $3$ 个活动，所以输出 $\tt -1$。

#### 样例 #3 解释

本样例满足所有 Subtask 的条件。

#### 数据规模与约定

**因洛谷限制，本题不予评测每个 Subtask 的第 $1\sim 20$ 个测试点。**

**本题采用 Subtask 计分法。**

| Subtask | 分值占比百分率 | $n$ | $L_i$ |
| :----: | :----: | :----: | :----:|
| $1$ | $7\%$ | / | $L_i \le L_{i+1}\ (1 \le i \le n − 1)$ |
| $2$ | $1\%$ | $\le20$ | / |
| $3$ | $31\%$ | $\le 3 \times 10^3$ |/ |
| $4$ | $61\%$ | / | / |

**注：斜线表示无特殊限制。**

对于 $100\%$ 的数据：
- $1\le n\le 10^5$；
- $1 \le k \le n$；
- $1\le L_i < R_i \le 10^9 (1\le i \le n)$。


#### 说明

本题译自 [第２０回日本情報オリンピック 2020/2021春季トレーニング合宿 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [競技 4 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day4/2021-sp-d4-notice.pdf) [T1 日文题面](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day4/event2.pdf)。


## 样例 #1

### 输入

```
5 4
1 3
2 5
8 9
6 8
10 15
```

### 输出

```
1
3
4
5
```

## 样例 #2

### 输入

```
4 3
1 4
3 5
4 9
7 10
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
10 6
77412002 93858605
244306432 318243514
280338037 358494212
439397354 492065507
485779890 529132783
571714810 632053254
659767854 709114867
718405631 733610573
786950301 815106357
878719468 899999649
```

### 输出

```
1
2
4
6
7
8
```

## 样例 #4

### 输入

```
20 16
250732298 258217736
26470443 34965880
252620676 260043105
692063405 697656580
497457675 504191511
391372149 397942668
858168758 867389085
235756850 241022021
585764751 593366541
207824318 217052204
661682908 671226688
886273261 892279963
770109416 778960597
264372562 270395107
176883483 186662376
509929119 519063796
109491630 118520141
162731982 168101507
662727316 668317158
757072772 765493222
```

### 输出

```
1
2
4
5
6
7
8
9
10
11
12
13
14
15
16
17
```

# AI分析结果



### 综合分析与结论

#### 核心思路
1. **贪心策略**：按编号从小到大遍历，若当前活动能被选中且不影响后续选够k个，则强制选择。
2. **区间维护**：用 `set` 维护空闲区间，通过重载运算符判断区间包含关系。
3. **快速查询**：倍增预处理每个点向右最多选 $2^j$ 个区间的终点，实现 $O(\log n)$ 的区间最大活动数查询。

#### 解决难点
- **字典序验证**：通过分割空闲区间并计算剩余容量，确保强制选择后仍有解。
- **高效查询**：通过离散化+倍增预处理，将区间最大活动数查询优化到对数时间。
- **区间管理**：自定义 `set` 的比较规则，使得相交区间可快速定位。

#### 可视化设计思路
- **动画演示**：时间轴用像素块表示，选中区间时高亮，分割后显示新空闲区间。
- **音效反馈**：选择成功时播放上扬音效，冲突时短促提示音。
- **复古风格**：8-bit 像素界面，时间轴类似经典横版游戏场景。

---

### 题解评分（≥4星）

| 题解作者       | 评分 | 关键亮点 |
|----------------|------|----------|
| GaoKui         | ★★★★★ | 详细解释 `set` 比较机制与倍增原理，代码结构清晰 |
| 喵仔牛奶       | ★★★★☆ | 代码简洁，核心逻辑完整，注释较少但实现高效 |
| AquariusZhao   | ★★★★☆ | 结合猫树思想，可视化描述区间分割过程清晰 |

---

### 最优思路与技巧提炼

1. **贪心选择依据**  
   - 强制选择编号最小的可行活动，分割空闲区间后验证剩余容量。
   - 关键公式：`new_capacity = old_capacity - old_query + left_query + right_query + 1`

2. **倍增预处理**  
   - `f[i][j]` 表示从离散化后的点i出发选 $2^j$ 个区间的终点。
   - 预处理时从右向左递推，保证每个点的最优跳跃。

3. **区间管理技巧**  
   ```cpp
   struct Seg { int l, r; bool operator<(const Seg &rhs) const { return r < rhs.l; } };
   set<Seg> st; // 自动处理相交区间判断
   ```

4. **离散化优化**  
   - 将所有端点排序去重，转为连续整数便于处理。

---

### 核心代码实现

#### 倍增预处理与查询
```cpp
// 初始化f数组
memset(f, 0x3f, sizeof(f));
for (int i=1; i<=n; i++) 
    f[L[i]][0] = min(f[L[i]][0], R[i]);
for (int i=m; i>=1; i--) {
    f[i][0] = min(f[i][0], f[i+1][0]);
    for (int j=1; j<20; j++)
        f[i][j] = f[f[i][j-1]][j-1];
}

// 查询[l,r]最多选多少个
int query(int l, int r) {
    int res = 0, cur = l;
    for (int j=19; j>=0; j--) {
        if (f[cur][j] <= r) {
            res += (1 << j);
            cur = f[cur][j];
        }
    }
    return res;
}
```

#### 贪心主循环
```cpp
set<Seg> st;
st.insert({1, m});
int remain = query(1, m);
vector<int> ans;

for (int i=1; i<=n && ans.size()<k; i++) {
    auto it = st.find({L[i], R[i]});
    if (it == st.end()) continue;
    Seg seg = *it;
    if (seg.l > L[i] || seg.r < R[i]) continue;

    int new_cap = query(seg.l, L[i]-1) + query(R[i]+1, seg.r) + 1;
    if (remain - query(seg.l, seg.r) + new_cap >= k) {
        ans.push_back(i);
        st.erase(it);
        st.insert({seg.l, L[i]-1});
        st.insert({R[i]+1, seg.r});
        remain = remain - query(seg.l, seg.r) + new_cap;
    }
}
```

---

### 同类型题目推荐
1. **P1803 活动安排** - 基础区间贪心，选择最多不重叠区间。
2. **P2107 小Z的AK计划** - 时间线管理+贪心选择。
3. **P2949 工作调度** - 带权区间选择与优先队列结合。

---

### 可视化与复古游戏化设计

1. **像素时间轴**  
   - 用Canvas绘制离散化后的时间轴，每个区间用不同颜色块表示。
   - 当前处理的活动高亮闪烁，分割后显示新区间。

2. **音效设计**  
   - 选择成功：8-bit "升级"音效。
   - 冲突提示：短促"错误"音效。
   - 背景音乐：循环芯片音乐。

3. **自动演示模式**  
   ```javascript
   function autoPlay() {
       let interval = setInterval(() => {
           if (!selectNextActivity()) clearInterval(interval);
       }, 1000); // 每秒自动选择下一个活动
   }
   ```

4. **游戏化关卡**  
   - 每成功选择k个活动通关，显示"LEVEL CLEAR"像素动画。
   - 连击奖励：连续正确选择时分数翻倍。

---

### 总结
本题解通过贪心策略与高效数据结构的结合，解决了字典序最小化选择问题。其核心在于利用倍增预处理快速验证可行性，配合 `set` 维护区间状态，实现复杂度与可读性的平衡。可视化设计以复古游戏风格增强学习沉浸感，适合算法教学与竞赛训练。

---
处理用时：86.95秒
# 题目信息

# [CCO 2021] Travelling Merchant

## 题目描述

一个国家有 $n$ 个城市和 $m$ 条单向道路，一个旅行商在这些城市之间旅行。

第 $i$ 条道路从城市 $a_i$ 到城市 $b_i$，只有当他的资产不少于 $r_i$ 元才可以走这条道路，走过这条道路之后他的资产会增加 $p_i$ 元。

他希望自己可以永远不停的游走下去，于是他想知道从任意一个城市出发至少需要多少元初始资产。

## 说明/提示

#### 样例 #1 解释
以第 $2$ 座城市为例：从第 $2$ 座城市出发，初始资产 $3$ 元，则可以在第 $2, 1, 3$ 三座城市无限绕圈。
#### 数据范围
对于 $\frac{2}{7}$ 的数据，$2 \leq n, m \leq 2 \times 10^3$；

对于另 $\frac{15}{49}$ 的数据，$p_i = 0$；

对于 $100\%$ 的数据，$2 \leq n, m \leq 2 \times 10^5$，$1 \leq a_i, b_i \leq n$，$a_i \neq b_i$，$0 \leq r_i, p_i \leq 10^9$，**保证没有自环但可能有重边**。
#### 题目来源
[CCO2021](https://cemc.math.uwaterloo.ca/contests/computing/2021/index.html) D2T1

## 样例 #1

### 输入

```
5 5
3 1 4 0
2 1 3 0
1 3 1 1
3 2 3 1
4 2 0 2```

### 输出

```
2 3 3 1 -1```

# AI分析结果



### 综合分析与结论

**核心思路**：  
所有题解均采用 **贪心策略 + 拓扑排序** 的组合算法。核心思想为：
1. **按边权 r_i 降序处理**，每次选最大 r 的边作为当前可能的最优解。
2. **反图拓扑更新**：将边存入反图，通过拓扑排序逐步确定每个节点的最小初始资产。
3. **动态删边**：处理完一条边后，将其从图中删除，若导致起点出度为 0 则入队处理。

**贪心策略验证**：  
- 最大 r_i 的边所在环的初始资产只需满足该 r_i，后续边的 r_i 更小不会影响此决策。
- 通过反图更新，确保每个节点的 ans 仅在其所有下游节点处理后更新，避免环的干扰。

**难点与解决**：  
- **环的处理**：通过拓扑排序删去无法构成环的节点，将图转化为 DAG。
- **高效更新**：用优先队列维护边，O(m log m) 排序确保贪心顺序，拓扑过程线性时间。

---

### 题解评分（≥4星）

1. **bsTiat（5星）**  
   - **亮点**：代码结构清晰，链式前向星存反图，处理顺序明确，注释详细。  
   - **关键代码**：按 r 升序排序（后续逆序处理），拓扑与边处理交替进行。

2. **uniqueharry（4.5星）**  
   - **亮点**：理论分析透彻，反图动态规划式更新，变量命名规范。  
   - **代码**：直接对边排序，队列处理与边删除逻辑简洁。

3. **翼德天尊（4星）**  
   - **亮点**：逆向思维归纳法分析，代码带调试输出，适合理解过程。  
   - **心得**：强调“删边归纳”和环的最大 r 性质。

---

### 最优思路提炼

1. **贪心选择依据**：  
   - 按 r_i 降序处理边，每次选当前最大 r 的边，确保其所在环的最小初始资产为 r。

2. **拓扑更新顺序**：  
   - 反图存储边，当节点出度为 0 时入队，保证其 ans 不再被下游节点更新。

3. **动态删边优化**：  
   - 处理过的边立即标记删除，减少后续无效判断，提升效率。

**关键代码片段（bsTiat）**：
```cpp
sort(edge+1, edge+1+m); // 按 r 升序排序
for(i=m;i>=1;--i) {    // 逆序处理，实际按 r 降序
    while(!q.empty()) {
        u = q.front(); q.pop();
        for(遍历反图边) {
            更新起点 ans，删边，若出度 0 则入队;
        }
    }
    if(边未删除) {
        ans[起点] = min(ans[起点], r);
        删边，若出度 0 则入队;
    }
}
```

---

### 同类题目与算法套路

**同类型题目特征**：  
- 图中存在环，需处理依赖关系或动态约束。
- 最优化问题（如最小初始值、最大收益），需贪心选择策略。

**推荐题目**：  
1. **P1967 货车运输**（最大生成树 + 路径最小值）  
2. **P4017 最大食物链计数**（拓扑排序 + DP）  
3. **P2741 [USACO4.4] 重叠矩形**（贪心选择 + 区间处理）

---

### 可视化与游戏化设计

**动画方案**：  
1. **贪心选择高亮**：当前处理的边显示为红色，节点根据 ans 值渐变（深绿已确定，黄色待更新）。
2. **拓扑过程演示**：队列中的节点以脉冲效果展示，删边时边逐渐淡化消失。
3. **音效设计**：  
   - 选择最大 r 边时播放“叮”声，节点入队时“咔哒”声，确定 ans 时上扬音效。

**复古游戏化实现**：  
- **像素风格**：节点为 16x16 像素方块，边为虚线连接，背景 8-bit 音乐循环。  
- **自动演示**：按空格暂停/继续，方向键调整速度。积分系统：每正确处理一条边+10 分，连击奖励。  

**交互代码片段（伪代码）**：  
```javascript
class Edge {
    constructor(a, b, r) { this.a = a; this.b = b; this.r = r; }
}

function drawPixelNode(ctx, x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*20, y*20, 16, 16); // 像素风格留黑边
}

function autoPlay() {
    let edge = getMaxRUnprocessedEdge();
    highlight(edge);
    playSound('select');
    processEdge(edge);
    updateTopoQueue();
}
```

---

### 个人心得摘录

- **bsTiat**：首次写题解注重结构，强调“边排序后逆序处理”是关键。  
- **翼德天尊**：通过调试输出理解删边过程，顿悟“最大 r 边决定环的性质”。  
- **Creeper_l**：实现时曾忽略无解点特判，导致 WA，后增加 `ans[u] != INF` 判断修复。  

---

### 总结

本题解通过贪心与拓扑排序的结合，高效处理了带环图中的最优化问题。核心在于按边权降序贪心选择，并通过反图拓扑更新确保正确性。可视化设计以像素风格和音效增强理解，适合教学与自学。

---
处理用时：102.74秒
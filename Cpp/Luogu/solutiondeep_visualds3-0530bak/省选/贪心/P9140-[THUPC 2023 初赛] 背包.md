# 题目信息

# [THUPC 2023 初赛] 背包

## 题目描述

本题中，你需要解决完全背包问题。

有 $n$ 种物品，第 $i$ 种物品单个体积为 $v_i$、价值为 $c_i$。

$q$ 次询问，每次给出背包的容积 $V$，你需要选择若干个物品，每种物品可以选择任意多个（也可以不选），在选出物品的体积的和**恰好**为 $V$ 的前提下最大化选出物品的价值的和。你需要给出这个最大的价值和，或报告不存在体积和恰好为 $V$ 的方案。

为了体现你解决 NP-Hard 问题的能力，$V$ 会远大于 $v_i$，详见数据范围部分。

## 说明/提示

#### 样例解释 1

第二组询问的最优方案为：选择 $3$ 个物品 $1$ 和 $12499999998$ 个物品 $2$。

#### 子任务

对于所有测试数据，$1 \le n \le 50, 1 \le v_i \le 10^5, 1 \le c_i \le 10^6, 1 \le q \le 10^5, 10^{11} \le V \le 10^{12}$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
2 2
6 10
8 15
100000000001
100000000002
```

### 输出

```
-1
187500000000
```

# AI分析结果



### 综合分析与结论

#### 核心思路与难点
1. **贪心策略**：选取性价比（$c_i/v_i$）最高的物品作为基准模数 $m$，用其填充绝大部分体积，余数部分通过同余最短路处理
2. **同余最短路优化**：用转圈技巧代替传统最短路算法，每个物品形成的环转两圈即可覆盖所有转移（时间复杂度 $O(nm)$）
3. **价值计算**：定义 $f_i$ 为模 $m$ 余 $i$ 时的最大价值补偿（相比全选基准物品的损失/增益）
4. **难点**：证明转移过程不会成环（基于基准物品的最优性），保证余数部分体积不超过 $m^2$

#### 可视化设计要点
1. **贪心选择高亮**：用金色边框标记性价比最高的基准物品，动态显示 $c_i/v_i$ 计算过程
2. **环状转移动画**：对每个物品生成的 $\gcd(v_i,m)$ 个子环，用不同颜色标记，展示转两圈的转移过程
3. **像素化呈现**：
   - 背包体积用横向像素条表示，基准物品填充部分显示为金色方块
   - 余数部分用红色光标在环形数轴上滑动，每次转移时播放8-bit音效
4. **自动演示模式**：
   - 第一阶段自动选择基准物品，展示性价比计算
   - 第二阶段按环形顺序演示转圈转移，关键步骤暂停并显示数学公式
   - 最终显示 $f_{V\bmod m}$ 的计算结果与整体价值的合成

---

### 题解清单（评分≥4星）

#### 1. Alex_Wei（★★★★★）
- **核心亮点**：开创性提出转两圈的环处理技巧，时间复杂度严格线性
- **代码亮点**：预处理取模优化，代码简洁高效（24行核心逻辑）
- **关键代码段**：
  ```cpp
  for(int j=0,lim=__gcd(v[i],m);j<lim;j++){
    for(int t=j,c=0;c<2;c+=t==j){
      int p = t + _v[i], d = _d[i];
      if(p >= m) p -= m, d++;
      f[p] = max(f[p], f[t]+c[i]-d*w);
      t = p;
    }
  }
  ```

#### 2. Leasier（★★★★☆）
- **创新点**：将环的转移次数明确为 $2\times (m/\gcd)$，增强可理解性
- **调试心得**：在注释中提及SPFA被卡的经历，强调转圈法的必要性
- **关键优化**：
  ```cpp
  for(int k = j, l = 1; l <= len; l++){
    int newv = k + v[i], nxt = newv % v[base];
    if(dis[k] != -inf) dis[nxt] = max(...);
  }
  ```

#### 3. 喵仔牛奶（★★★★☆）
- **教学价值**：用SPFA实现最长路，更易理解同余最短路的本质
- **可视化友好**：显式建图过程适合动画演示边的生成
- **核心片段**：
  ```cpp
  for(int j=1;j<=n;j++)
    add(i, (i+w[j])%m, v[j]-(i+w[j])/m*t);
  ```

---

### 最优技巧提炼

1. **基准选择定理**：设 $m$ 为性价比最高物品的体积，则最优解中非 $m$ 物品的总体积不超过 $m^2$
2. **环处理法则**：对每个 $\gcd(v_i,m)$ 子环转两圈，保证覆盖所有可能的转移
3. **价值补偿公式**：$f_{(p+v_i)\bmod m} = \max(f_p + c_i - \lfloor(p+v_i)/m\rfloor w)$
4. **余数终局计算**：$ans = f_{V\bmod m} + \lfloor V/m \rfloor w$

---

### 同类型题目推荐

1. **P2371 [国家集训队]墨墨的等式**  
   （同余最短路模板题，完全背包可行性问题）

2. **P3403 跳楼机**  
   （同余最短路经典应用，求可达楼层数）

3. **P2662 牛场围栏**  
   （最大化不可达体积的同余最短路变种）

---

### 可视化代码片段（JS Canvas）

```javascript
class PixelBackpack {
  constructor() {
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.modRing = []; // 环形余数状态
  }

  drawModRing(highlightPos) {
    const radius = 100;
    this.ctx.strokeStyle = '#8B0000'; // 暗红色环形
    this.ctx.beginPath();
    this.ctx.arc(150,150,radius,0,2*Math.PI);
    this.ctx.stroke();

    // 绘制余数点
    this.modRing.forEach((val, i) => {
      const angle = i*2*Math.PI/this.mod;
      const x = 150 + radius*Math.cos(angle);
      const y = 150 + radius*Math.sin(angle);
      this.ctx.fillStyle = val > -1e9 ? '#00FF00' : '#FF0000';
      this.ctx.fillRect(x-3,y-3,6,6);
    });

    // 高亮当前转移位置
    if(highlightPos !== undefined) {
      const angle = highlightPos*2*Math.PI/this.mod;
      const x = 150 + 120*Math.cos(angle);
      const y = 150 + 120*Math.sin(angle);
      this.ctx.strokeStyle = '#FFFF00';
      this.ctx.beginPath();
      this.ctx.arc(x,y,10,0,2*Math.PI);
      this.ctx.stroke();
    }
  }

  playTransferSound() {
    const osc = audioCtx.createOscillator();
    osc.frequency.setValueAtTime(500 + Math.random()*200, audioCtx.currentTime);
    osc.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
  }
}
```

---

### 算法演示规则（游戏化）

1. **连击机制**：连续正确转移时，背景色渐变，连击数增加得分
2. **错误特效**：转移导致价值下降时，屏幕抖动并播放低沉音效
3. **自动演示AI**：
   - 优先选择当前环上未处理的物品
   - 每次转移后计算性价比变化，动态调整演示速度
4. **关卡解锁**：
   - 新手关：仅基准物品选择
   - 进阶关：单个物品的环转移
   - BOSS关：多物品混合转移

---

### 关键结论

1. **转圈法统治性优势**：比传统最短路算法快10倍以上，严格 $O(nm)$ 复杂度
2. **基准选择验证**：通过交叉比较 $c_i \times v_j > c_j \times v_i$ 避免浮点误差
3. **实战要点**：
   ```cpp
   // 预处理避免重复取模
   _v[i] = v[i] % m; 
   _d[i] = v[i] / m;
   ```
4. **错误陷阱**：未初始化 $f_0=0$ 将导致全盘错误，需特别检查

---
处理用时：94.87秒
# 题目信息

# [HNOI2010] 公交线路

## 题目描述

小 Z 所在的城市有 $N$ 个公交车站，排列在一条长 $(N-1)\  \rm km$ 的直线上，从左到右依次编号为 $1$ 到 $N$，相邻公交车站间的距离均为 $1 \ \rm km$。作为公交车线路的规划者，小 Z 调查了市民的需求，决定按下述规则设计线路：

1. 设共 $K$ 辆公交车，则 $1$ 到 $K$ 号站作为始发站，$N-K+1$ 到 $N$ 号台作为终点站。
2. 每个车站必须被一辆且仅一辆公交车经过（始发站和终点站也算被经过）。
3. 公交车只能从编号较小的站台驶往编号较大的站台。
4. 一辆公交车经过的相邻两个站台间距离不得超过 $P \ \rm km$。

在最终设计线路之前，小 Z 想知道有多少种满足要求的方案。由于答案可能很大，你只需求出答案对 $30031$ 取模的结果。

## 说明/提示

【样例说明】

样例一的可行方案如下：$(1,4,7,10)$，$(2,5,8)$，$(3,6,9)$。

样例二的可行方案如下：$(1,3,5)$，$(2,4)(1,3,4)$，$(2,5)(1,4)$，$(2,3,5)$。

对于 $100 \%$ 的数据，$1 \le N \le 10^9$，$1 < P \le 10$，$K<N$，$1<K \le P$。

## 样例 #1

### 输入

```
10 3 3```

### 输出

```
1```

## 样例 #2

### 输入

```
5 2 3```

### 输出

```
3```

## 样例 #3

### 输入

```
10 2 4```

### 输出

```
81```

# AI分析结果



### 唯一算法分类
**状态压缩动态规划（状压DP）与矩阵快速幂优化**

---

### 综合分析与结论

#### 核心算法流程
1. **状态设计**：  
   每个状态表示一个长度为 `P` 的窗口，其中必须恰好有 `K` 个 `1`（表示公交车覆盖的站点）。状态的高位对应最近的站点，最低位必须为 `1`（避免重复覆盖）。
   
2. **合法状态筛选**：  
   预处理所有满足 `1` 的个数为 `K` 且最高位为 `1` 的二进制数，状态数为组合数 `C(P-1, K-1)`（最多 126 种）。

3. **转移条件**：  
   状态 `S1` 能转移到 `S2`，当且仅当将 `S1` 左移一位后，去掉最高位，与 `S2` 相比至多有一位不同（即移动一辆公交车到新的位置）。

4. **矩阵快速幂优化**：  
   将状态转移关系构建为邻接矩阵，通过矩阵快速幂在 `O(log N)` 时间内完成递推，总复杂度 `O(S^3 log N)`（`S` 为合法状态数）。

#### 可视化设计思路
- **像素动画演示**：  
  - **状态窗口**：用 `P` 个像素块表示当前窗口，红色块表示 `1`（有车），绿色块表示 `0`。  
  - **转移过程**：当状态变化时，高亮变化的位（黄色闪烁），并播放“滴”音效。  
  - **矩阵乘法**：在右侧面板展示邻接矩阵的非零元素（白色点），动态显示矩阵相乘时的组合过程。  

- **复古音效与交互**：  
  - **正确转移**：播放 8-bit 上扬音效；**错误转移**（如超过 `P` 距离）播放低沉音效。  
  - **AI 自动模式**：点击“自动演示”后，算法以贪吃蛇式自动遍历状态转移路径，展示矩阵快速幂的倍增思想。  

---

### 题解评分（≥4星）

1. **xyz32768（5星）**  
   - **亮点**：思路清晰，状态转移条件推导严谨，代码规范，矩阵乘法实现高效。  
   - **代码片段**：  
     ```cpp
     for (i = 1; i <= tot; i++) for (j = 1; j <= tot; j++) {
         int S1 = sta[i], S2 = sta[j]; S1 = S1 - (1 << P - 1) << 1;
         for (k = 0; k < P; k++) if (!((S1 >> k) & 1) && S1 + (1 << k) == S2)
             Orz.a[j][i] = 1;
     }
     ```

2. **TopCarry（5星）**  
   - **亮点**：详细解释状压的合法性，矩阵乘法优化（循环重排提升缓存命中率）。  
   - **心得引用**：“k 提到外层减少分支判断，分分钟冲上最优解”。  

3. **dsjkafdsaf（4星）**  
   - **亮点**：预处理合法状态，代码可读性强，强调初始状态与末态的处理。  
   - **代码片段**：  
     ```cpp
     for (int i = 1; i <= cnt; i++)
         for (int j = 1; j <= cnt; j++)
             if (check(all[i], all[j])) Z.maps[i][j] = 1;
     ```

---

### 最优思路提炼
1. **状态压缩技巧**：用二进制位表示窗口覆盖，确保状态数可控（`C(P-1, K-1)`）。  
2. **转移条件优化**：通过位运算快速判断状态合法性，仅需检查差异位数。  
3. **矩阵快速幂加速**：将线性递推转化为矩阵幂运算，复杂度从 `O(N)` 降至 `O(log N)`。  

---

### 同类型题与推荐
- **相似题目**：  
  - **P2109 [NOI2007]生成树计数**（状压+矩阵）  
  - **P2233 [HNOI2002]公交车路线**（矩阵快速幂直接应用）  
  - **P2151 [SDOI2009]HH去散步**（状态转移与矩阵结合）

---

### 可视化代码片段（Canvas 动画）
```javascript
// 绘制状态窗口（8-bit风格）
function drawState(ctx, state, x, y) {
    const colors = ['#00FF00', '#FF0000']; // 绿:0, 红:1
    for (let i = 0; i < P; i++) {
        const bit = (state >> (P - 1 - i)) & 1;
        ctx.fillStyle = colors[bit];
        ctx.fillRect(x + i * 20, y, 18, 18);
    }
}

// 状态转移动画
function animateTransition(fromState, toState) {
    const diff = (fromState << 1 ^ toState) & ((1 << P) - 1);
    const changedBit = Math.log2(diff); // 找到变化的位
    highlightBit(changedBit); // 高亮该位并播放音效
}
```

---

### 个人心得摘录
- **调试关键**：初始状态必须满足最高位为 `1`，否则会漏解。  
- **优化经验**：矩阵乘法时调整循环顺序（k在最外层）可提升 10 倍速度。  
- **思维突破**：发现每个窗口的公交车数恒为 `K`，避免无效状态枚举。

---
处理用时：82.60秒
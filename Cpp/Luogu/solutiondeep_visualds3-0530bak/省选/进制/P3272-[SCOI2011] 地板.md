# 题目信息

# [SCOI2011] 地板

## 题目描述

lxhgww 的小名叫“小 L”，这是因为他总是很喜欢 L 型的东西。

小 L 家的客厅是一个 $r\times c$ 的矩形，现在他想用 L 型的地板来铺满整个客厅，客厅里有些位置有柱子，不能铺地板。

现在小 L 想知道，用 L 型的地板铺满整个客厅有多少种不同的方案？

需要注意的是，如下图所示，L 型地板的两端长度可以任意变化，但不能长度为 $0$。

![](https://cdn.luogu.com.cn/upload/pic/4636.png)

铺设完成后，客厅里面所有没有柱子的地方都必须铺上地板，但同一个地方不能被铺多次。

## 说明/提示

#### 数据规模与约定
| 测试点编号 | 数据限制 |
| :----------: | :----------: |
| $1\sim 2$ | $1\le r\times c\le 25$ |
| $3\sim 5$ | $1\le r\times c\le 100$ 并且 （$r=2$ 或者 $c=2$） |
| $6\sim 10$ | $1\le r\times c\le 100$ |

## 样例 #1

### 输入

```
2 2
*_
__```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3
 ___
 _*_
 ___```

### 输出

```
8```

# AI分析结果



**唯一算法分类**  
插头DP

---

**综合分析与结论**  

**核心思路**：  
- **插头状态定义**：  
  - `0` 无插头  
  - `1` 未拐弯的L型路径插头（可延伸）  
  - `2` 已拐弯的L型路径插头（需终止或继续延伸）  
- **状态编码**：使用四进制/三进制压缩当前行的插头状态，用哈希表存储有效状态  
- **转移规则**：根据当前格子的左插头（`left`）和上插头（`up`）状态，分类讨论6种情况：  
  - 无插头时创建新L型分支  
  - 单插头时延伸或拐弯  
  - 双插头时合并路径  

**可视化设计要点**：  
- **网格绘制**：Canvas绘制棋盘，障碍格子用深灰色标记，当前处理格子高亮  
- **插头动画**：用不同颜色表示插头类型（绿色为`1`，红色为`2`），箭头表示延伸方向  
- **状态更新**：每次转移时显示状态码的二进制分解，动态更新轮廓线插头  
- **复古风格**：8位像素音效（路径合并时播放"嘟"声，错误状态时播放"哔"声）  
- **自动演示**：按行/列自动步进，可暂停观察状态码与插头对应关系  

---

**题解清单 (≥4星)**  

1. **Orion545（5星）**  
   - **亮点**：  
     - 完整分类6种转移情况，逻辑清晰  
     - 使用哈希表+滚动数组优化空间  
     - 预处理矩阵旋转优化时间  
   - **代码**：核心转移部分完整覆盖所有情况  

2. **LittleMoMol（4星）**  
   - **亮点**：  
     - 状态转移图辅助理解  
     - 代码模块化，易读性强  
   - **调试心得**：提到代码调试时间长，强调画图验证的重要性  

3. **Conan15（4星）**  
   - **亮点**：  
     - 采用Modint类自动处理取模  
     - 状态转移注释详细  
   - **代码技巧**：使用位运算快速提取插头状态  

---

**最优思路与技巧**  

1. **关键优化**：  
   - **矩阵旋转**：当`n<m`时交换行列，保证轮廓线长度≤10，降低状态数  
   - **哈希表压缩**：仅存储有效状态，避免遍历全状态空间  

2. **状态转移分类**：  
   - **无插头时**：可创建垂直/水平新L型，或作为拐点生成双`2`插头  
   - **单插头延伸**：`1`插头可继续同向延伸或拐弯转为`2`  
   - **双插头合并**：仅允许两个`1`插头合并，形成完整L型路径  

3. **终止条件**：  
   - 最终有效格子（最后一个可铺砖位置）需统计合法终止状态  

---

**同类型题与推荐题目**  

1. **P5056** 【模板】插头DP（基础路径覆盖问题）  
2. **P3205** [HNOI2010]合唱队（状态压缩与插头思想结合）  
3. **P2289** [HNOI2005]星际旅行（复杂路径形状处理）  

---

**代码核心片段**  

```cpp
// Orion545 题解中的关键转移逻辑
void dp() {
    insert(0, 1); // 初始状态
    for (int i=1; i<=n; i++) {
        for (int j=1; j<=m; j++) {
            for (所有状态k) {
                int right = (state >> bit[j-1]) % 4;
                int down = (state >> bit[j]) % 4;
                
                // 情况1：无插头
                if (!right && !down) {
                    if (可向下) insert(新下插头1);
                    if (可向右) insert(新右插头1);
                    if (可拐弯) insert(双插头2);
                }
                // 情况2：单右插头1
                else if (right==1 && !down) {
                    if (可向下) insert(右插头转下插头2);
                    if (可向右) insert(延续右插头1);
                }
                // ...其他情况类似
            }
        }
    }
}
```

---

**可视化实现示例（JavaScript伪代码）**  

```javascript
class PlugDPVisualizer {
  constructor(grid) {
    this.canvas = document.getElementById("grid-canvas");
    this.ctx = this.canvas.getContext("2d");
    this.grid = grid; // 棋盘数据
    this.states = [new Map()]; // 当前状态集合
    this.currentCell = {x:0, y:0}; // 当前处理格子
  }

  drawGrid() {
    // 绘制棋盘，障碍格用灰色填充
    this.grid.forEach((row, i) => {
      row.forEach((cell, j) => {
        if (cell === 0) this.ctx.fillStyle = "#666";
        else this.ctx.fillStyle = "#fff";
        this.ctx.fillRect(j*40, i*40, 40, 40);
      });
    });
  }

  drawPlug(plug, direction) {
    // 绘制插头：direction为"left"或"up"
    const colors = {1: "#0f0", 2: "#f00"};
    const [x, y] = this.currentCell;
    if (direction === "left") {
      this.ctx.beginPath();
      this.ctx.moveTo(x*40, y*40 + 20);
      this.ctx.lineTo((x+1)*40, y*40 + 20);
      this.ctx.strokeStyle = colors[plug];
      this.ctx.stroke();
    }
    // 类似绘制上插头...
  }

  animateStep() {
    const {x, y} = this.currentCell;
    // 高亮当前处理格子
    this.ctx.fillStyle = "rgba(255,255,0,0.3)";
    this.ctx.fillRect(y*40, x*40, 40, 40);
    
    // 绘制当前插头状态
    this.states.forEach(state => {
      const leftPlug = getLeftPlug(state, y);
      const upPlug = getUpPlug(state, y+1);
      this.drawPlug(leftPlug, "left");
      this.drawPlug(upPlug, "up");
    });
    
    // 播放对应音效
    if (isValidState) playSound("blip.wav");
    else playSound("error.wav");
  }
}
```

---
处理用时：80.96秒
# 题目信息

# [CTSC2017] 吉夫特

## 题目描述

简单的题目，既是礼物，也是毒药。

B 君设计了一道简单的题目，准备作为 gift 送给大家。

输入一个长度为  $n$  的数列  $a_1, a_2, \cdots , a_n$  问有多少个长度大于等于  $2$  的不上升的子序列满足：

 $$\prod _{i=2}^{k} \binom{a_{b_{i-1}}}{a_{b_i}} \bmod 2 = \binom{a_{b_1}}{a_{b_2}} \times \binom{a_{b_2}}{a_{b_3}} \times \cdots \binom{a_{b_{k-1}}}{a_{b_k}} \bmod 2 > 0$$ 

输出这个个数对  $1000000007$  取模的结果。

G 君看到题目后，为大家解释了一些基本概念。

我们选择任意多个整数  $b_i$  满足

 $$1 \leq b_1 < b_2 < \dots < b_{k-1} < b_k \leq n$$ 

我们称  $a_{b_1}, a_{b_2}, \cdots, a_{b_k} $  是  $a$  的一个子序列。

如果这个子序列同时还满足

 $$a_{b_1} \geq a_{b_2} \geq \cdots \geq a_{b_{k-1}}\geq a_{b_k}$$ 

我们称这个子序列是不上升的。

组合数  $\binom {n} {m} $  是从  $n$  个互不相同的元素中取  $m$  个元素的方案数，具体计算方案如下：

 $$\binom {n}{m}=\frac{n!}{m!(n-m)!}=\frac{n \times (n-1) \times \cdots \times 2 \times 1}{(m \times (m-1) \cdots \times 2 \times 1)((n-m)\times(n-m-1)\times \cdots \times 2 \times 1)}$$ 

这里要特别注意，因为我们只考虑不上升子序列，所以在求组合数的过程中，一定满足  $n \geq m$ ，也就是 $\binom {a_{b_{i-1}}}{a_{b_i}}$ 中一定有 $a_{b_{i-1}} \geq a_{b_i}$ 。

我们在这里强调取模  $x \mod y$  的定义：

 $x \bmod y = x -\left \lfloor \frac{x}{y} \right \rfloor \times y$ 

其中  $\left \lfloor n \right \rfloor$  表示小于等于  $n$  的最大整数。

 $x \bmod 2 > 0$  ，就是在说  $x$  是奇数。

与此同时，经验告诉我们一个长度为  $n$  的序列，子序列个数有  $O(2^n)$  个，所以我们通过对答案取模来避免输出过大。

B 君觉得 G 君说的十分有道理，于是再次强调了这些基本概念。

最后， G 君听说这个题是作为 gift 送给大家，她有一句忠告。

“Vorsicht, Gift!”

“小心. . . . . .剧毒！ ”

## 说明/提示

对于前 $10\%$ 的测试点，$n \leq 9$，$1\leq a_i\leq 13$。

对于前 $20\%$ 的测试点，$n\leq 17$，$1\leq a_i\leq 20$。

对于前 $40\%$ 的测试点，$n\leq 1911$，$1\leq a_i\leq 4000$。

对于前 $70\%$ 的测试点，$n\leq 2017$。

对于前 $85\%$ 的测试点，$n\leq 100084$。

对于 $100\%$ 的测试点，$1\leq n\leq 211985$，$1\leq a_i\leq 233333$。所有的 $a_i$ 互不相同，也就是说不存在 $i, j$ 同时满足 $1\leq i < j\leq n$ 和 $a_i = a_j$。


## 样例 #1

### 输入

```
4
15
7
3
1```

### 输出

```
11```

# AI分析结果



---

**唯一算法分类**：动态规划（子集枚举优化）

---

### 综合分析与结论

**核心思路**：  
利用卢卡斯定理得出组合数为奇数的条件等价于二进制子集关系，将问题转化为寻找所有满足前项是后项超集的子序列数目。通过动态规划枚举子集实现高效计数。

**解决难点**：  
1. **二进制子集推导**：通过卢卡斯定理将模2问题转化为位运算关系  
2. **高效枚举**：使用位运算技巧快速遍历所有子集  
3. **空间优化**：利用数组直接存储数值位置，避免重复计算

**算法流程**：  
1. 倒序处理每个元素`a[i]`  
2. 通过`(a[i]-1)&a[i]`得到初始子集  
3. 循环`j = (j-1)&a[i]`枚举所有子集  
4. 累加子集对应的DP值  
5. 结果统计时排除单元素情况

**可视化设计**：  
1. **像素网格**：用不同颜色方块表示数值的二进制位  
2. **高亮显示**：  
   - 红色：当前处理的`a[i]`  
   - 绿色：正在枚举的子集`j`  
   - 蓝色：已统计的子序列  
3. **音效触发**：  
   - "滴"声：成功找到子集  
   - "叮"声：完成一个元素处理  
4. **自动演示**：按从右向左顺序自动处理元素，可调节速度

---

### 题解清单 (4星及以上)

1. **_ctz题解 (5星)**  
   - **亮点**：最简代码实现，核心逻辑仅10行  
   - **技巧**：利用`S = a-1 & a`快速初始化子集枚举  
   ```cpp
   for(S=a-1&a; S; S=S-1&a) // 子集枚举
   ```

2. **SovietPower题解 (5星)**  
   - **优化**：分块处理降低复杂度至O(3^9)  
   - **实现**：前9位与后9位分离处理  
   ```cpp
   A = x>>9, B = x&511; // 分块处理
   ```

3. **litble题解 (4星)**  
   - **特色**：显式处理位置映射表  
   - **心得**：强调"Vorsicht, Gift!"的解题提示

---

### 最优思路代码实现

**核心逻辑**：
```cpp
int main() {
    int n=read(), ans=0;
    for(int i=1; i<=n; ++i) {
        int a=read();
        int sum = 1; // 当前元素自身计数
        // 枚举所有子集
        for(int j=(a-1)&a; j; j=(j-1)&a) 
            sum = (sum + f[j]) % MOD;
        ans = (ans + sum - 1) % MOD; // -1排除单元素
        // 更新父集
        for(int j=a; ; j=(j-1)&a) {
            f[j] = (f[j] + sum) % MOD;
            if(!j) break;
        }
    }
    printf("%d", ans);
}
```

**完整代码**：参见_ctz题解代码

---

### 同类型拓展

**通用解法**：  
1. 二进制子集问题 → 枚举子集`j = (j-1)&a`  
2. 超集计数 → 分块处理或高维前缀和

**推荐题目**：  
1. [P4917] 天守阁的地板 - 子集计数  
2. [P2150] 寿司晚宴 - 状态压缩DP  
3. [P6222] 「简单题」加强版 - 位运算优化

---

### 可视化设计要点

**复古像素实现**：  
1. **颜色方案**：  
   - 背景：#2D2D2D  
   - 数值块：16色调色板循环  
2. **Canvas绘制**：  
   ```javascript
   function drawNumber(x, y, num) {
       ctx.fillStyle = getColor(num);
       ctx.fillRect(x*30, y*30, 28, 28); // 像素块
   }
   ```
3. **音效系统**：  
   ```javascript
   const beep = new Audio('data:audio/wav;base64,UklGRl...'); // 8-bit音效
   ```

**自动演示逻辑**：  
```javascript
function autoPlay() {
    let i = n;
    const timer = setInterval(() => {
        highlightNumber(a[i]);
        enumerateSubsets(a[i]); // 枚举子集动画
        i--;
        if(i < 0) clearInterval(timer);
    }, 1000);
}
```

---

通过这种可视化设计，学习者可以直观观察子集枚举过程和DP状态传播，配合复古音效增强算法理解与记忆。

---
处理用时：60.10秒
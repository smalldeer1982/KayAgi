# 题目信息

# 公主の#19准备月考

## 题目背景

公主在玩完游戏后，也要月考了。（就算是公主也要月考啊QWQ）


## 题目描述

公主的文综太差了，全校排名1100+（全校就1100多人），她分析了好久，发现她如果把所有时间放在选择题上，得分会比较好一点。

文综题目共有n个，编号从1到n

公主给每个题目算出来了一个预估值Ai，她认为，一段连续题目的答案会在它们的预估值的gcd和lcm之间；有时候她的想法不同了，一些题目的预估值会改变；有时候，会出现多选题，多选题的答案数量就是一段连续题目答案的预估值的公约数的个数。

具体来说，对于一个数列，有四种操作：

L x y p 表示公主询问区间[x,y]的数字的lcm对p取模之后的值

G x y p 表示公主询问区间[x,y]的数字的gcd对p取模之后的值

C x y c 表示公主改变区间[x,y]的数字的值，统一为c

S x y p 表示公主询问区间[x,y]的数字的公因数个数对p取模之后的值

公主月考不能挂科，不然她就不能学习OI了（假的），所以请你帮帮她吧！


## 说明/提示

对于30%的数据，1<=n,q<=1000

对于另外20%的数据，1<=n<=1000，1<=q<=100000

对于另外20%的数据，1<=n<=100000，1<=q<=100000，保证没有修改操作

对于100%的数据，1<=n<=300000，1<=q<=300000

保证任何时刻每个题目的预估值都在[1,100]之间，答案取模之后不超过int


## 样例 #1

### 输入

```
10 10
42 68 35 1 70 25 79 59 63 65 
L 2 6 28
L 2 6 43
G 2 7 5
G 3 4 83
L 7 9 96
G 2 7 39
S 3 8 100
L 4 5 12
G 4 4 65
L 2 4 69```

### 输出

```
0
32
1
1
75
1
1
10
1
34```

# AI分析结果



# 算法分类  
线段树 + 状态压缩  

---

# 题解思路与核心难点  

## 核心逻辑  
1. **质因数压缩**：  
   利用数值范围[1,100]的特性，将每个数的质因数分解信息压缩为二进制位：  
   - 2^6（3位）、3^4（3位）、5^2（2位）、7^2（2位）  
   - 其他质数仅需1位（存在性标记）  
   总压缩后占31位（int）或35位（long long）

2. **线段树设计**：  
   - 每个节点存储两个状态：区间GCD的质因数组合、区间LCM的质因数组合  
   - 合并规则：  
     ```text  
     GCD组合 = 各质因数取min次数  
     LCM组合 = 各质因数取max次数  
     ```  
   - 区间覆盖操作直接将整个区间的GCD/LCM设为相同值

3. **查询转换**：  
   - 根据查询类型将压缩状态转换为实际值  
   - S操作（因数个数）需要计算GCD的质因数次数乘积  

## 解决难点  
1. **状态合并效率**：通过预处理的位运算规则（如Vingying的callcm/calgcd函数）实现O(1)合并  
2. **空间优化**：压缩存储避免了存储完整质因数次数表（否则需要25个int）  
3. **查询计算**：快速幂优化质因数次数的还原（如对前4个质数用快速幂，后续直接乘）  

---

# 题解评分  

## [Vingying] ★★★★★  
**亮点**：  
- 极致的位运算优化（31位int存储）  
- 预处理质数分解表提升查询效率  
- 处理了p=1等边界情况  

## [Maniac] ★★★★☆  
**亮点**：  
- 使用long long存储35位，合并更直观（直接位与/位或）  
- 代码结构清晰，S操作计算因数个数的优化  

## [Hadtsti] ★★★★☆  
**亮点**：  
- 结构体直接记录质因数次数，便于理解  
- 处理模数变化的快速幂计算  

---

# 最优思路提炼  

## 关键技巧  
1. **质因数位压缩**：  
   ```cpp  
   // Vingying的压缩函数示例  
   int cal(int tmp) {
       memset(cnt, 0, sizeof cnt);
       for(int i=0; tmp>1; i++) 
           while(tmp%pri[i]==0) tmp/=pri[i], cnt[i]++;
       return 按二进制位组合cnt数组;
   }
   ```

2. **线段树合并规则**：  
   ```cpp  
   // LCM合并（取max）
   int callcm(int v1, int v2) {
       for每个质数i: cnt[i] = max(v1的cnt[i], v2的cnt[i]);
       return 压缩后的cnt组合;
   }
   ```

3. **查询结果快速计算**：  
   ```cpp  
   // 将压缩状态转为实际值（以LCM为例）
   int get_lcm(int state, int mod) {
       int res = 1;
       for每个质数i: res = res * pow(pri[i], state中i的次数) % mod;
       return res;
   }
   ```

---

# 类似题目推荐  
1. **P1890 gcd区间**（区间GCD查询）  
2. **P3452 [POI2007]BIU-Offices**（因数个数相关）  
3. **P4513 小白逛公园**（区间最值维护）  

---

# 可视化设计  

## 动画方案  
1. **线段树动态显示**：  
   - 每个节点显示其GCD/LCM的质因数分解状态  
   - 高亮当前操作的区间（如修改区间为红色，查询区间为蓝色）  

2. **质因数分解演示**：  
   ![质因数分解动图](https://i.imgur.com/7nQZb3L.gif)  
   - 数值分解时显示质数气泡（如42 → 2、3、7气泡）  
   - 合并时用箭头连接左右子树，展示max/min过程  

3. **复古风格**：  
   - **8位像素风**：线段树节点用方格表示，质因数用不同颜色像素块  
   - **音效**：  
     - 合并成功：8-bit "ding"  
     - 区间覆盖："boom"爆炸音  

---

# 核心代码片段  

## Vingying的线段树合并逻辑  
```cpp  
// LCM合并（取max）
int callcm(int v1, int v2) {
    for(int i=0; i<25; i++) {
        int c1 = (v1 >> offset[i]) & mask[i]; // 取出v1的质数i次数
        int c2 = (v2 >> offset[i]) & mask[i];
        cnt[i] = max(c1, c2);
    }
    return 将cnt数组压缩为整数;
}
```

## Maniac的线段树查询  
```cpp  
LL queryg(int now,int L,int R,int l,int r) {
    if(当前区间被完全覆盖) return gcd状态;
    pushdown();
    return queryg左子树 & queryg右子树; // 位与实现取min次数
}
```

---

# 个人心得摘录  
> "卡常大赛... 最后没开O2比开了O2还快？！" —— Vingying  
> "模数没说，但严重怀疑是偷懒随机弄了一些小模数" —— Maniac  
> "结构体直接记录次数，虽然空间稍大但更易调试" —— Hadtsti  

---

# 实现建议  
1. **优先采用int压缩**（31位），节省内存  
2. **预处理合并规则表**（如FF数组）加速位运算  
3. **注意模数p=1时的输出处理**（所有操作结果都是0）  

--- 

通过这种精心的状态压缩和线段树设计，能在O(n log n)时间复杂度下高效处理大规模区间查询，是质因数分解与线段树结合的经典案例。

---
处理用时：75.54秒
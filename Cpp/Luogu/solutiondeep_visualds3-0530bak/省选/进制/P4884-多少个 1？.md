# 题目信息

# 多少个 1？

## 题目描述

给定整数 $K$ 和质数 $m$，求最小的正整数 $N$，使得 $ 11\cdots1$（$N$ 个 $1$）$\equiv K \pmod m$。

说人话：就是 $111\cdots 1111 \bmod m = K$。

## 说明/提示

$30\%$ 的数据保证 $m\leq 10^6$。

$60\%$ 的数据保证 $m\leq 5\times 10^7$。

$100\%$ 的数据保证 $6\leq m\leq 10^{11}$，$0< K< m$，保证 $m$ 是质数。

## 样例 #1

### 输入

```
9 17```

### 输出

```
3```

# AI分析结果



## 算法分类
**BSGS（大步小步算法）**

---

## 题解思路与解决难点
### 核心思路
将问题转化为求最小的N，使得 \(10^N \equiv 9K+1 \pmod{m}\)，使用BSGS算法解高次同余方程。

### 解决难点
1. **大数运算溢出**：  
   - m最大为 \(10^{11}\)，直接计算 \(a \cdot b \mod m\) 会溢出。  
   - 解决方案：快速乘（分块乘法、`__int128`、Python高精度）。
2. **BSGS效率优化**：  
   - 预处理小步哈希表时，避免重复计算 \(a^j \mod m\)。  
   - 使用手写哈希表代替STL的 `map` 提高查询速度。
3. **正确性保证**：  
   - 确保BSGS的初始条件（如 \(10\) 和 \(m\) 互质）成立，因 \(m\) 是质数且 \(m \geq 6\)，故条件自动满足。

---

## 题解评分（≥4星）
### sxyugao（5星）
- **亮点**：高效快速乘（分块位运算）、推导清晰、复杂度分析透彻。
- **代码**：快速乘复杂度O(1)，BSGS分块实现。

### Lates（4.5星）
- **亮点**：使用 `__int128` 简化运算，代码简洁。
- **缺点**：依赖编译器支持 `__int128`，部分环境不可用。

### Ajwallet（4星）
- **亮点**：手写哈希表优化查询，结合 `long double` 快速乘。
- **代码**：哈希表设计紧凑，适合大数据范围。

---

## 最优思路与技巧
### 关键技巧
1. **快速乘分块优化**  
   将乘数分解为高位和低位，利用乘法分配律：
   ```cpp
   LL mul(LL a, LL b, LL P) {
       LL L = a * (b >> 25LL) % P * (1LL << 25) % P;
       LL R = a * (b & ((1LL << 25) - 1)) % P;
       return (L + R) % P;
   }
   ```
2. **BSGS分块策略**  
   - 预处理小步 \(j \in [0, \sqrt{m}]\)，存入哈希表。
   - 大步迭代时复用 \(a^{\sqrt{m}}\) 的幂次，复杂度 \(O(\sqrt{m})\)。

3. **手写哈希表**  
   避免 `map` 的查询开销，降低常数因子：
   ```cpp
   struct Hash { 
       ll a[p], b[p]; 
       void push(ll x, ll num) { /*...*/ } 
       ll get(ll x) { /*...*/ } 
   };
   ```

---

## 同类型题与算法套路
- **通用解法**：BSGS适用于离散对数问题，如 \(a^x \equiv b \pmod{p}\)。
- **类似题目**：  
  - P3846 [TJOI2007] 可爱的质数  
  - P2485 [SDOI2011] 计算器  
  - P3306 [XMYZ] 随机数生成器

---

## 推荐洛谷题目
1. **P4195 【模板】exBSGS**  
   （拓展BSGS，处理非互质情况）
2. **P2485 [SDOI2011] 计算器**  
   （结合快速幂、逆元、BSGS的综合题）
3. **P3306 [XMYZ] 随机数生成器**  
   （递推数列中的离散对数问题）

---

## 个人心得摘录
- **sxyugao**：  
  > “快速乘的位运算分块其实是乘法分配律的应用，小学生都会，但用在模运算中却能避免溢出。”
- **未见堇开**：  
  > “数据范围调整后，BSGS的正确性得到保证，但调试时仍要注意模数是否为质数。”

---

## 可视化与算法演示
### 核心算法流程
1. **预处理小步**  
   - **动画**：在网格中逐格填充 \( (9K+1) \cdot 10^j \mod m \)，颜色标记哈希表插入。
2. **大步迭代**  
   - **动画**：从左到右扫描 \( (10^{\sqrt{m}})^i \mod m \)，高亮当前值与哈希表匹配。
3. **匹配成功**  
   - **特效**：目标块闪烁，播放胜利音效。

### 复古像素风格设计
- **颜色方案**：  
  - 哈希表插入：绿色像素块  
  - 大步扫描：红色指针移动  
  - 匹配成功：金色爆炸特效
- **音效**：  
  - 插入哈希表：8-bit“滴”声  
  - 找到解：经典马里奥过关音效
- **Canvas实现**：  
  动态绘制网格，每步更新后调用 `ctx.fillRect` 渲染色块。

```javascript
// 示例：绘制哈希表插入
function drawHashStep(j, val) {
    ctx.fillStyle = '#00FF00'; // 绿色
    ctx.fillRect(j * CELL_SIZE, 0, CELL_SIZE, CELL_SIZE);
    playSound('insert'); // 触发音效
}
```

---

## 核心代码实现（sxyugao优化版）
```cpp
#include <cmath>
#include <map>
using namespace std;
typedef long long LL;

LL mul(LL a, LL b, LL P) {
    LL L = a * (b >> 25LL) % P * (1LL << 25) % P;
    LL R = a * (b & ((1LL << 25) - 1)) % P;
    return (L + R) % P;
}

LL qpow(LL a, LL b, LL P) {
    LL res = 1;
    for (; b; b >>= 1, a = mul(a, a, P))
        if (b & 1) res = mul(res, a, P);
    return res;
}

LL bsgs(LL a, LL b, LL P) {
    a %= P, b %= P;
    map<LL, LL> hash;
    LL t = ceil(sqrt(P)), val = b;
    for (LL j = 0; j < t; ++j) {
        hash[val] = j;
        val = mul(val, a, P);
    }
    a = qpow(a, t, P), val = 1;
    for (LL i = 1; i <= t; ++i) {
        val = mul(val, a, P);
        if (hash.count(val))
            return i * t - hash[val];
    }
    return -1;
}

int main() {
    LL K, m; 
    scanf("%lld%lld", &K, &m);
    printf("%lld", bsgs(10, (9 * K + 1) % m, m));
    return 0;
}
```

---
处理用时：77.75秒
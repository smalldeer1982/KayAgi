# 题目信息

# 奇数国

## 题目描述

在一片美丽的大陆上有 $100\,000$ 个国家，记为 $1$ 到 $100\,000$。这里经济发达，有数不尽的账房，并且每个国家有一个银行。

某大公司的领袖在这 $100\,000$ 个银行开户时都存了 $3$ 大洋，他惜财如命，因此会不时地派小弟 GFS 清点一些银行的存款或者让 GFS 改变某个银行的存款。

该村子在财产上的求和运算等同于我们的乘法运算，也就是说领袖开户时的存款总和为 $3^{100000}$。这里发行的软妹面额是最小的 $60$ 个素数（$p_1=2,p_2=3,\ldots, p_{60}=281$），任何人的财产都只能由这 $60$ 个基本面额表示，即设某个人的财产为 $fortune$（正整数），则 $fortune=p_1^{k_1} \times p_2^{k_2} \times \ldots p_{60}^{k_{60}}$。

领袖习惯将一段编号连续的银行里的存款拿到一个账房去清点，为了避免 GFS 串通账房叛变，所以他不会每次都选择同一个账房。GFS 跟随领袖多年已经摸清了门路,知道领袖选择账房的方式。如果领袖选择清点编号在 $[a,b]$ 内的银行财产，他会先对 $[a,b]$ 的财产求和（记为 $product$），然后在编号属于 $[1,product]$ 的账房中选择一个去清点存款，检验自己计算是否正确同时也检验账房与 GFS 是否有勾结。GFS 发现如果某个账房的编号 $number$ 与 $product$ 相冲，领袖绝对不会选择这个账房。

怎样才算与 $product$ 不相冲呢？若存在整数 $x,y$ 使得 $number \times x+product \times y=1$，那么我们称 $number$ 与 $product$ 不相冲，即该账房有可能被领袖相中。当领袖又赚大钱了的时候，他会在某个银行改变存款，这样一来相同区间的银行在不同的时候算出来的 $product$ 可能是不一样的，而且领袖不会在某个银行的存款总数超过 $10^6$。

现在 GFS 预先知道了领袖的清点存款与变动存款的计划，想请你告诉他，每次清点存款时领袖有多少个账房可以供他选择，当然这个值可能非常大，GFS 只想知道对 $19\,961\,993$ 取模后的答案。

## 说明/提示

### 样例解释

- 初始化每个国家存款都为 $3$；
- $1$ 到 $3$ 的 $product$ 为 $27$，$[1,27]$ 与 $27$ 不相冲的有 $18$ 个数；
- $1$ 的存款变为 $5$；
- $1$ 到 $3$ 的 $product$ 为 $45$，$[1,45]$ 与 $45$ 不相冲的有 $24$ 个数；
- $1$ 的存款变为 $7$；
- $1$ 到 $3$ 的 $product$ 为 $63$，$[1,63]$ 与 $63$ 不相冲的有 $36$个数；
- $2$ 到 $3$ 的 $product$ 为 $9$，$[1,9]$ 与 $9$ 不相冲的有 $6$ 个数。

### 数据范围

所有数据均满足：$x \geq 1$，$c_i -b_i \geq 0$。

| 子任务编号 | 分值 |    $x \leq$     | $c_i - b_i \leq$ | 特殊性质 |
| :--------: | :--: | :-------------: | :--------------: | :------: |
|    $1$     | $20$ |     $10^4$      |      $100$       |    有    |
|    $2$     | $30$ | $5 \times 10^4$ |      $10^4$      |    无    |
|    $3$     | $50$ |     $10^5$      |      $10^5$      |    无    |

特殊性质指：所有 $product \leq 10^{18}$。

## 样例 #1

### 输入

```
6
0 1 3
1 1 5
0 1 3
1 1 7
0 1 3
0 2 3```

### 输出

```
18
24
36
6

```

# AI分析结果



## 算法分类
线段树 / 欧拉函数快速计算

---

## 题解思路与核心难点

### 核心算法流程
1. **质因数预处理**  
   前60个质数预先存入数组，计算每个质数的模逆元（用于快速计算欧拉函数的分母部分）
2. **线段树设计**  
   - 每个节点维护两个值：区间乘积的模值、质因数出现状态的位掩码（用long long存储，每位表示对应质数是否存在）
   - 合并节点时：乘积取模相乘，质因数掩码按位或
3. **欧拉函数计算**  
   根据公式 $\varphi(n) = n \prod_{p|n} \frac{p-1}{p}$，用预处理的质数和逆元快速计算

### 解决难点
- **质因数分解优化**：利用题目中“质数仅限前60个”的特性，用位掩码代替实际分解
- **区间合并效率**：通过位运算和模运算实现O(1)时间复杂度的节点合并
- **欧拉函数快速计算**：预处理逆元避免除法操作，时间复杂度从O(k log p)优化到O(k)

---

## 题解评分（≥4星）

### Siyuan（★★★★★）
- **亮点**：  
  采用线段树+位掩码，代码结构清晰  
  预计算逆元数组，优化欧拉函数计算效率  
  完整处理初始化逻辑，完美适配题目初始值均为3的情况

### Surge_of_Force（★★★★☆）
- **亮点**：  
  详细注释和调试心得（如线段树区间范围错误）  
  单独封装质因数分解函数，增强代码可读性  
  使用位掩码的long long存储方式节省空间

### gyh20（★★★★☆）
- **亮点**：  
  树状数组实现，空间复杂度更优（每个质数独立数组）  
  动态计算质因数幂次，避免预处理分解  
  代码简洁，适合快速实现场景

---

## 最优思路提炼
1. **双维护线段树**  
   同时维护区间乘积的模值和质因数位掩码，实现O(1)合并
2. **位掩码压缩存储**  
   用long long的每一位表示对应质数的存在性，节省空间且便于位运算
3. **逆元预计算**  
   提前计算所有质数的模逆元，将欧拉函数中的除法转换为乘法
4. **质因数快速提取**  
   通过位掩码遍历所有存在的质数，避免实际分解操作

---

## 类似题目推荐
1. **P2158 [NOI 2012] 仪仗队**  
   欧拉函数求互质对数
2. **P2398 GCD SUM**  
   区间GCD统计与欧拉函数应用
3. **P1447 [NOI 2010] 能量采集**  
   二维平面上的欧拉函数应用

---

## 核心代码实现
```cpp
const int prime[]={2,3,5,7,11,...,281}; // 前60个质数
const int invpr[]={9980997,6653998,...}; // 对应质数逆元

struct Node {
    int mul;     // 乘积模值
    long long p; // 质因数掩码
} tree[N<<2];

void pushup(int p) {
    tree[p].mul = (tree[p<<1].mul * tree[p<<1|1].mul) % mod;
    tree[p].p = tree[p<<1].p | tree[p<<1|1].p;
}

void update(int x, int v) {
    long long mask = 0;
    for(int i=0; i<60; ++i)
        if(v % prime[i] == 0) mask |= 1LL<<i;
    // 递归更新叶子节点...
}

int query(int l, int r) {
    int product = get_product(l, r);
    long long mask = get_mask(l, r);
    int res = product;
    for(int i=0; i<60; ++i) 
        if(mask & (1LL<<i))
            res = res * 1LL * invpr[i] % mod * (prime[i]-1) % mod;
    return res;
}
```

---

## 可视化设计思路
1. **线段树动画**  
   - 节点显示：每个节点显示模值和二进制掩码（如`0b1010`表示包含第2、4质数）
   - 颜色标记：修改时路径节点高亮红色，查询路径高亮蓝色
2. **质因数分解展示**  
   - 每个数值下方显示分解结果（如3→3¹, 5→5¹等）
3. **欧拉函数计算过程**  
   - 逐步显示：乘积值→遍历每个质数→应用逆元和(p-1)因子
4. **交互控制**  
   - 速度调节滑块控制动画速度
   - 单步执行按钮分步观察合并过程

---

## 复古像素风实现
1. **8位风格界面**  
   - 线段树节点用16x16像素块表示，绿色表示未修改，红色表示更新路径
2. **音效设计**  
   - 节点更新时播放短促的"哔"声
   - 查询完成时播放上升音阶
3. **自动演示模式**  
   - 随机生成修改/查询操作，展示算法自动处理过程
   - 得分系统：正确处理操作+10分，错误操作-5分

---

## 个人调试心得
1. **线段树区间错误**  
   初始化时必须从1到100000建树而非输入的n
2. **位运算陷阱**  
   必须使用`1LL<<i`而非`1<<i`以避免整数溢出
3. **逆元预计算**  
   忘记预处理导致计算结果错误，通过小数据测试发现

---

通过上述分析，该题的核心在于合理设计数据结构以高效维护乘积和质因数信息，结合数学优化实现快速计算。线段树与位运算的巧妙结合是解题的关键突破口。

---
处理用时：697.18秒
# 题目信息

# [CQOI2016] 密钥破解

## 题目描述

一种非对称加密算法的密钥生成过程如下：

1.任选两个不同的质数$p,q$

2.计算$N=p \times q$，$r=(p-1)(q-1)$

3.选取小于$r$，且与$r$互质的整数$e$

4.计算整数$d$，使得$ed≡1(mod r)$

5.二元组$(N,e)$称为公钥，二元组$(N,d)$称为私钥。

当需要加密消息$n$时，（假设$n$是一个小于$N$的整数，因为任何格式的消息都可转为整数表示），使用公钥$(N,e)$，按照

$$n^e≡c(mod N)$$

运算，可得到密文$c$

对密文$c$解密时，用私钥$(N,d)$，按照

$$c^d≡n(mod N)$$

运算，可得到原文 $n$。算法正确性证明省略。

由于用公钥加密的密文仅能用对应的私钥解密，而不能用公钥解密，因此称为非对称加密算法。通常情况下，公钥由消息的接收方公开，而私钥由消息的接收方自己持有。这样任何发送消息的人都可以用公钥对消息加密，而只有消息的接收方自己能够解密消息。

现在，你的任务是寻找一种可行的方法来破解这种加密算法，即根据公钥破解出私钥，并据此解密密文。

## 说明/提示

对于$30\%$的数据，$e,N,c \le 2^{20}$；

对于$100\%$的数据，$e,N,c \le 2^{62},c<N$

## 样例 #1

### 输入

```
3 187 45```

### 输出

```
107 12```

# AI分析结果



---

## 算法分类
**Pollard-Rho算法**

---

## 综合分析与结论
### 核心思路与难点
1. **核心逻辑**  
   - 分解大数 $N=pq$ 是解题关键，使用 Pollard-Rho 算法实现高效分解  
   - 通过扩展欧几里得算法求 $e$ 在模 $r=(p-1)(q-1)$ 下的逆元 $d$  
   - 快速幂计算 $c^d \bmod N$ 得到明文 $n$  

2. **实现难点**  
   - **大数分解**：传统试除法无法处理 $2^{62}$ 量级的 $N$  
   - **整数溢出**：需用快速乘或 __int128 处理大数乘法  
   - **随机性控制**：Pollard-Rho 的随机参数选择影响分解效率  

3. **最优技巧**  
   - **Pollard-Rho 优化**：结合 Miller-Rabin 质数检测加速分解  
   - **快速乘技巧**：龟速乘或 __int128 避免乘法溢出  
   - **扩展欧几里得优化**：处理负数解转化为最小正整数解  

---

## 题解评分（≥4星）

### 1. Fatalis_Lights（★★★★☆）
- **亮点**  
  - 完整实现 Miller-Rabin + Pollard-Rho 组合  
  - 使用 __int128 处理大数运算，代码简洁  
  - 模块化设计（质因数分解、逆元、快速幂）  
- **代码片段**  
  ```cpp
  // 使用 __int128 的快速幂
  __int128 ksm(__int128 a, __int128 b, __int128 m) {
      __int128 res = 1;
      while (b) {
          if (b & 1) res = res * a % m;
          a = a * a % m;
          b >>= 1;
      }
      return res;
  }
  ```

### 2. andysk（★★★★☆）
- **亮点**  
  - 实现 Pollard-Rho 的 Brent 优化版本  
  - 结合试除法优化分解小质数情况  
  - 清晰的代码注释和异常处理  
- **核心逻辑**  
  ```cpp
  // Pollard-Rho 核心循环
  while (true) {
      x = (mul(x, x, n) + c) % n;
      d = gcd(abs(x - y), n);
      if (d > 1 && d < n) return d;
      if (x == y) return n; // 重新选择参数
  }
  ```

### 3. Guess00（★★★★☆）
- **亮点**  
  - 暴力分解优化到 O(√N) 通过测试数据  
  - 利用质数模6特性加速试除  
  - 代码极简适合快速实现  
- **关键代码**  
  ```cpp
  // 基于模6优化的试除法
  j = sqrt(n);
  while (j % 6 != 5) j--;
  for (i = 5; n % i && ...; i += 6, j -= 6);
  ```

---

## 核心代码实现
### Pollard-Rho 分解 + 快速幂解密
```cpp
#include <cstdlib>
#include <ctime>
using namespace std;
typedef long long ll;

ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }

ll pollard_rho(ll n) {
    if (n % 2 == 0) return 2;
    ll x = rand() % n, y = x, c = rand() % (n - 1) + 1;
    for (ll d = 1, cnt = 0;; cnt++) {
        x = ((__int128)x * x + c) % n;
        y = ((__int128)y * y + c) % n;
        y = ((__int128)y * y + c) % n;
        d = gcd(abs(x - y), n);
        if (d != 1) return d;
    }
}

void exgcd(ll a, ll b, ll &x, ll &y) {
    if (!b) x = 1, y = 0;
    else exgcd(b, a % b, y, x), y -= a / b * x;
}

int main() {
    ll e, N, c; 
    cin >> e >> N >> c;
    
    // 分解N
    ll p = pollard_rho(N), q = N / p;
    ll r = (p-1) * (q-1);
    
    // 求d
    ll d, y;
    exgcd(e, r, d, y);
    d = (d % r + r) % r;
    
    // 解密n
    ll n = 1;
    for (; d; d >>= 1, c = (__int128)c * c % N)
        if (d & 1) n = (__int128)n * c % N;
    
    cout << d << " " << n;
}
```

---

## 同类型题目推荐
1. **P4718** 【模板】Pollard-Rho算法（质因数分解模板）  
2. **P3868** 猜数字（扩展欧几里得应用）  
3. **P1061** RSA解密（类似密钥破解场景）  

---

## 可视化设计（Pollard-Rho 分解过程）
### 动画方案
1. **颜色标记**  
   - 🔴 当前随机数 `x`  
   - 🔵 跟踪数 `y`  
   - 🟢 成功找到因子时的 `d`  

2. **步进控制**  
   - 按钮控制单步执行 `x = f(x)`  
   - 速度滑块调节动画帧间隔（100ms~2s）  

3. **像素风格**  
   - 8-bit 字体显示当前数值  
   - 分解成功时触发 🎵 8-bit 胜利音效  
   - 网格显示数值变化轨迹  

4. **伪代码演示**  
   ```python
   while True:
       x = (x² + c) mod N
       y = (y² + c)² + c mod N
       d = gcd(|x-y|, N)
       if d > 1: break
   ```

---

## 个人心得摘录
> "暴力分解从 $\sqrt{N}$ 双向枚举，结合模6优化，意外通过所有测试点——但正规比赛务必使用 Pollard-Rho" —— critnos  
> "调试时发现 rand() 种子未初始化导致分解失败，添加 srand(time(0)) 后解决" —— thecold

---
处理用时：85.81秒
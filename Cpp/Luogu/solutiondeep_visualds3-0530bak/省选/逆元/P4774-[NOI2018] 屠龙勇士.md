# 题目信息

# [NOI2018] 屠龙勇士

## 题目描述

小 D 最近在网上发现了一款小游戏。游戏的规则如下：

- 游戏的目标是按照编号 $1 \rightarrow n$ 顺序杀掉 $n$ 条巨龙，每条巨龙拥有一个初始的生命值 $a_i$ 。同时每条巨龙拥有恢复能力，当其使用恢复能力时，它的生命值就会每次增加 $p_i$ ，直至生命值非负。只有在攻击结束后且当生命值 **恰好** 为 $0$ 时它才会死去。
- 游戏开始时玩家拥有 $m$ 把攻击力已知的剑，每次面对巨龙时，玩家只能选择一把剑，当杀死巨龙后这把剑就会消失，但作为奖励，玩家会获得全新的一把剑。

小 D 觉得这款游戏十分无聊，但最快通关的玩家可以获得 ION2018 的参赛资格，于是小 D 决定写一个笨笨的机器人帮她通关这款游戏，她写的机器人遵循以下规则：

- 每次面对巨龙时，机器人会选择当前拥有的，攻击力不高于巨龙初始生命值中攻击力最大的一把剑作为武器。如果没有这样的剑，则选择 **攻击力最低** 的一把剑作为武器。
- 机器人面对每条巨龙，它都会使用上一步中选择的剑攻击巨龙固定的 $x$ 次，使巨龙的生命值减少 $x \times ATK$ 。
- 之后，巨龙会不断使用恢复能力，每次恢复 $p_i$ 生命值。若在使用恢复能力前或某一次恢复后其生命值为 $0$ ，则巨龙死亡，玩家通过本关。

那么显然机器人的攻击次数是决定能否最快通关这款游戏的关键。小 D 现在得知了每条巨龙的所有属性，她想考考你，你知道应该将机器人的攻击次数 $x$ 设置为多少，才能用最少的攻击次数通关游戏吗？

当然如果无论设置成多少都无法通关游戏，输出 $-1$ 即可。

## 说明/提示

### 更多样例

更多样例请在附加文件中下载。

### 样例 2

见附加文件中的 `dragon2.in` 与 `dragon2.ans`。

### 样例 1 解释

第一组数据：
- 开始时拥有的剑的攻击力为 $\{1,9,1000\}$，第 $1$ 条龙生命值为 $3$，故选择攻击力为 $1$ 的剑，攻击 $59$ 次，造成 $59$ 点伤害，此时龙的生命值为 $-56$，恢复 14 次后生命值恰好为 $0$，死亡。

- 攻击力为 $1$ 的剑消失，拾取一把攻击力为 $7$ 的剑，此时拥有的剑的攻击力为
$\{7,9,1000\}$，第 2 条龙生命值为 $5$，故选择攻击力为 $7$ 的剑，攻击 $59$ 次，造成 $413$ 点伤害，此时龙的生命值为 $-408$，恢复 $68$ 次后生命值恰好为 $0$，死亡。

- 此时拥有的剑的攻击力为 $\{3,9,1000\}$，第 $3$ 条龙生命值为 $7$，故选择攻击力为 $3$ 的剑，攻击 $59$ 次，造成 $177$ 点伤害，此时龙的生命值为 $-170$，恢复 $17$ 次后生命值恰好为 0，死亡。

- 没有比 $59$ 次更少的通关方法，故答案为 $59$。

第二组数据：
不存在既能杀死第一条龙又能杀死第二条龙的方法，故无法通关，输出 $-1$。

### 子任务

测试点编号 |　　　$n$　　　|　　　$m$　　　|　　　$p_i$　　　|　　　$a_i$　　　| 　　攻击力　　 | 其他限制
-|-|-|-|-|-|-
1|$\le 10^5$|$=1$|$=1$|$\le 10^5$|$=1$| 无
2|$\le 10^5$|$=1$|$=1$|$\le 10^5$|$=1$| 无
3|$\le 10^5$|$=1$|$=1$|$\le 10^5$|$\le 10^5$| 无
4|$\le 10^5$|$=1$|$=1$|$\le 10^5$|$\le 10^5$| 无
5|$\le 10^3$|$\le 10^3$|$\le 10^5$|$\le 10^5$|$\le 10^5$| 特性 1、特性 2
6|$\le 10^3$|$\le 10^3$|$\le 10^5$|$\le 10^5$|$\le 10^5$| 特性 1、特性 2
7|$\le 10^3$|$\le 10^3$|$\le 10^5$|$\le 10^5$|$\le 10^5$| 特性 1、特性 2
8|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
9|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
10|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
11|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
12|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
13|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
14|$=10^5$|$=10^5$|$=1$|$\le 10^8$|$\le 10^6$| 无特殊限制
15|$=10^5$|$=10^5$|$=1$|$\le 10^8$|$\le 10^6$| 无特殊限制
16|$\le 10^5$|$\le 10^5$| 所有 $p_i$ 是质数 |$\le 10^{12}$|$\le 10^6$| 特性 1
17|$\le 10^5$|$\le 10^5$| 所有 $p_i$ 是质数 |$\le 10^{12}$|$\le 10^6$| 特性 1
18|$\le 10^5$|$\le 10^5$| 无特殊限制 |$\le 10^{12}$|$\le 10^6$| 特性 1
19|$\le 10^5$|$\le 10^5$| 无特殊限制 |$\le 10^{12}$|$\le 10^6$| 特性 1
20|$\le 10^5$|$\le 10^5$| 无特殊限制 |$\le 10^{12}$|$\le 10^6$| 特性 1

特性 1 是指：对于任意的 $i$，$a_i \le p_i$。

特性 2 是指：$\operatorname{lcm}(p_i) \le 10^6$，即所有 $p_i$ 的 **最小公倍数** 不大于 $10^6$。

对于所有的测试点，$T \le 5$，所有武器的攻击力 $\le 10^6$，所有 $p_i$ 的最小公倍数 $\le 10^{12}$。

保证 $ T, n, m $ 均为正整数。

### 提示

你所用到的中间结果可能很大，注意保存中间结果的变量类型。

## 样例 #1

### 输入

```
2
3 3
3 5 7
4 6 10
7 3 9
1 9 1000
3 2
3 5 6
4 8 7
1 1 1
1 1```

### 输出

```
59
-1```

# AI分析结果



### 唯一算法分类
扩展中国剩余定理（ExCRT）

---

### 综合分析与结论
**核心思路**：将每条龙的攻击问题转化为带系数的同余方程，通过扩展欧几里得算法（exgcd）消去系数后，使用扩展中国剩余定理（ExCRT）合并方程组求解最小非负整数解。

**解决难点**：
1. **剑的选择**：用 multiset 维护当前可用剑，通过 upper_bound 快速找到攻击力不大于龙血量的最大剑。
2. **同余方程转化**：对每个方程 `b_i*x ≡ a_i (mod p_i)`，用 exgcd 将其转化为 `x ≡ c_i (mod m_i)` 的标准形式。
3. **合并方程**：通过 ExCRT 逐步合并方程，处理模数不互质的情况。
4. **特殊处理**：当 p_i=1 时直接求最大攻击次数，当系数与模数不整除时判无解。

**可视化设计**：
- **动画流程**：以 8 位像素风格展示剑选择、方程转化、ExCRT 合并过程。
- **高亮元素**：当前处理的龙、选择的剑、方程的系数变化。
- **音效提示**：成功合并方程时播放上升音调，无解时播放失败音效。
- **步进控制**：允许单步执行查看每步的 exgcd 计算和方程合并细节。

---

### 题解清单（≥4星）
1. **emptysetvvvv（5星）**  
   清晰实现 ExCRT 框架，代码简洁高效，使用 `__int128` 处理大数乘法。

2. **shadowice1984（4.5星）**  
   详细推导方程转化过程，完整处理各类特殊情况，给出严谨数学证明。

3. **FlashHu（4星）**  
   引入快速乘防止溢出，通过分层特判处理边界条件，代码鲁棒性强。

---

### 核心代码实现
```cpp
// ExCRT 核心合并过程（emptysetvvvv 题解片段）
long long ExCRT() {
    long long ans = 0, lcm = 1, x, y, gcd, A, B, C;
    for(int i = 1; i <= n; ++i) {
        A = (__int128)b[i] * lcm % p[i];
        B = p[i];
        C = (a[i]-b[i]*ans%p[i]+p[i]) % p[i];
        exgcd(A, B, x, y, gcd), x = (x%B+B) % B;
        if(C % gcd) return -1;
        ans += (__int128)(C/gcd) * x % (B/gcd) * lcm % (lcm*=B/gcd);
        ans %= lcm;
    }
    if(ans < mx) ans += ((mx-ans-1)/lcm+1) * lcm;
    return ans;
}
```

---

### 同类型题推荐
1. **P4777 【模板】扩展中国剩余定理（ExCRT）**  
   裸 ExCRT 模板题，练习基本合并方法。

2. **P1495 曹冲养猪**  
   传统中国剩余定理问题，理解模数互质场景。

3. **P3868 猜数字**  
   带系数的同余方程组，需要结合快速乘处理溢出。

---

### 个人心得摘录
- **调试经验**：处理多组数据时务必清空 multiset，否则残留元素导致后续计算错误（作者 liuzhangfeiabc 因此丢分）。
- **思维顿悟**：当 p_i=1 时攻击次数只需满足 `x ≥ ceil(a_i/ATK_i)`，无需同余计算。
- **优化技巧**：使用 `__int128` 临时处理大数乘法，避免手写快速乘提升代码可读性。

---

### 复古游戏化动画设计
1. **像素风格界面**：  
   - 使用 16 色调色板，龙以红色像素块表示，剑为蓝色方块。
   - 方程合并过程用绿色网格动态展示模数变化。

2. **音效设计**：  
   - **攻击成功**：8-bit 风格 "叮" 声（Web Audio API 生成 440Hz 方波）。
   - **方程合并**：连续上升音调表示步骤推进。
   - **无解提示**：急促低频噪音（200Hz 三角波）。

3. **AI 演示模式**：  
   自动分步执行 ExCRT 合并过程，用箭头高亮当前操作的模数和余数，右侧面板显示中间变量变化。

```javascript
// 伪代码：ExCRT 合并动画演示
function animateExCRT(equations) {
    let ans = 0, lcm = 1;
    equations.forEach((eq, i) => {
        highlightEquation(i); // 高亮当前方程
        let [A, B, C] = computeCoefficients(eq, ans, lcm);
        let [x, gcd] = exgcdStep(A, B); // 展示 exgcd 计算过程
        if (C % gcd !== 0) playErrorSound();
        else {
            ans = updateAnswer(ans, x, C, gcd, lcm);
            lcm = computeNewLcm(lcm, B, gcd);
            playSuccessSound();
        }
        drawVariables(ans, lcm); // 更新右侧面板显示
    });
}
```

---
处理用时：691.75秒
# 题目信息

# [SDOI2010] 捉迷藏

## 题目背景

iPig 在大肥猪学校刚上完了无聊的猪文课，天资聪慧的 iPig 被这门对他来说无比简单的课弄得非常寂寞，为了消除寂寞感，他决定和他的好朋友 giPi（鸡皮）玩一个更加寂寞的游戏——捉迷藏。但是，他们觉得，玩普通的捉迷藏没什么意思，还是不够寂寞，于是，他们决定玩寂寞无比的螃蟹版捉迷藏。


## 题目描述

螃蟹版捉迷藏，顾名思义，就是说他们在玩游戏的时候只能沿水平或垂直方向走。

一番寂寞的剪刀石头布后，他们决定 iPig 去捉 giPi。由于他们都很熟悉大肥猪学校的地形了，所以 giPi 只会躲在大肥猪学校内 $N$ 个隐秘地点之一，显然 iPig 也只会在那 $N$ 个地点内找 giPi。

游戏一开始，他们从这 $N$ 个隐秘地点之中选定一个地点，iPig 保持不动，然后 giPi 用 $30$ 秒的时间逃离现场（显然，giPi 不会呆在原地）。然后 iPig 会随机地去找 giPi，直到找到为止。

由于 iPig 很懒，所以他总是走最短的路径，而且，他选择起始点不是随便选的，他想找一个地点，使得该地点到（除了这个地点以外的）最远的地点和最近的地点的距离差最小。iPig现在想知道这个距离差最小是多少。

由于 iPig 现在手上没有电脑，所以不能编程解决这个如此简单的问题，所以他马上打了个电话，要求你帮他解决这个问题。iPig 告诉了你大肥猪学校的 $N$ 个隐秘地点的坐标，请你编程求出 iPig 的问题。

## 说明/提示

$30\%$ 的数据中，$2\le N\le 10^3$；

$100\%$ 的数据中，$2\le N\le 10^5$，$0\le X_i,Y_i\le 10^9$。

数据保证点不重合。

## 样例 #1

### 输入

```
4
0 0
1 0
0 1
1 1
```

### 输出

```
1```

# AI分析结果



# 算法分类  
**平面几何与数据结构优化**

---

## 题解思路、算法要点与解决难点  
### 核心思路  
所有题解围绕曼哈顿距离公式拆解展开，通过数学变换消除绝对值，利用数据结构维护极值。关键点如下：  
1. **曼哈顿距离拆解**：将绝对值拆分为四种方向组合（如 `x_i ± y_i` 的线性组合）。  
2. **极值维护**：通过排序、线段树/树状数组/K-D树等数据结构，高效查询前缀或区域的极值。  
3. **方向对称性处理**：对坐标系进行翻转（x/y轴镜像），重复计算不同方向的极值。  

### 解决难点  
- **绝对值处理**：通过分类讨论将曼哈顿距离转换为线性表达式，消除绝对值。  
- **多维查询**：K-D树通过剪枝加速高维最近/最远点查询；线段树/树状数组通过离散化和排序将问题降为一维。  
- **代码实现复杂度**：如线段树需处理四次不同方向的极值更新，K-D树需正确实现剪枝逻辑。  

---

## 题解评分 (≥4星)  
1. **revenger (线段树) [⭐⭐⭐⭐⭐]**  
   - **亮点**：完整推导距离拆解，利用两次线段树遍历覆盖所有方向，zkw线段树优化效率。  
   - **代码**：逻辑清晰，但需处理离散化和多棵线段树。  

2. **Wilderness_ (预处理+邻近枚举) [⭐⭐⭐⭐]**  
   - **亮点**：数学直觉强，预处理四个全局极值，枚举邻近点简化计算，实测效率极高。  
   - **局限**：正确性依赖邻近点数量选择，理论需进一步验证。  

3. **ModestCoder_ (树状数组) [⭐⭐⭐⭐]**  
   - **亮点**：树状数组维护前缀极值，代码简洁，四遍处理覆盖所有方向。  
   - **局限**：变量命名和逻辑嵌套较深，可读性稍低。  

---

## 最优思路与技巧提炼  
### 关键技巧  
1. **极值拆分与对称性**：  
   - 曼哈顿距离最大值为 `max(x±y) - min(x±y)`，最小值为枚举邻近点或数据结构查询。  
   - 通过镜像翻转坐标系，覆盖所有方向组合（如代码中翻转x/y轴处理四次）。  

2. **数据结构选择**：  
   - **线段树/树状数组**：离散化坐标后维护前缀/后缀极值，单次操作O(logn)。  
   - **K-D树**：剪枝时计算点到区域的最小/最大可能距离，跳过无效子树。  

3. **局部性原理优化**：  
   - 按x排序后，最小距离点大概率在邻近位置，枚举前/后500点大幅减少计算量。  

---

## 类似题目与算法套路  
1. **POJ 3241**（曼哈顿最小生成树，极值拆分）  
2. **洛谷 P6247**（K-D树求最近/最远点对）  
3. **LeetCode 1131**（矩阵中的曼哈顿距离最大值）  

---

## 代码核心实现  
### 线段树拆解极值 (revenger)  
```cpp  
void change(int x, int m1, int m2) {  
    x += m;  
    tree[x][1] = min(tree[x][1], m1);  
    tree[x][2] = max(tree[x][2], m1);  
    // ... 更新父节点  
}  
int ask(int l, int r, int nm) {  
    // ZKW线段树区间查询极值  
}  
```

### 预处理极值 (Wilderness_)  
```cpp  
int max_d = max({  
    (x + y) - T[0], (x - y) - T[1],  
    (-x + y) - T[2], (-x - y) - T[3]  
});  
int min_d = min_neighbor(i); // 枚举邻近点  
ans = min(ans, max_d - min_d);  
```

---

## 可视化与算法演示  
### 动画设计  
- **像素风格网格**：在Canvas中绘制二维点，用不同颜色标记当前处理点、邻近点、极值点。  
- **动态极值更新**：当点移动或坐标系翻转时，高亮线段树节点或K-D树区域，显示极值变化。  
- **音效提示**：查询极值时播放“滴”声，找到最优解时播放胜利音效。  

### 控制面板  
- **步进控制**：暂停/继续/单步执行，观察数据结构更新步骤。  
- **参数调节**：调整邻近点数量（Wilderness_方法），实时查看效果变化。  

### 复古效果  
- **8位色彩**：用16色调色板区分点状态（如红色为当前点，绿色为极值点）。  
- **FC音效**：使用Web Audio API播放8位音效，增强交互感。  

---

## 个人心得摘录  
- **Wilderness_**：  
  > “根据数学直觉，最小距离的另一个点在数组中肯定不会离那个固定的点太远。” —— 通过局部性简化计算，实测高效。  

- **revenger**：  
  > “线段树需要处理正反两次遍历，确保覆盖所有方向。” —— 强调全面性验证的重要性。  

---

## 推荐题目  
1. **洛谷 P6247**（K-D树应用）  
2. **洛谷 P2479**（同题）  
3. **POJ 3241**（曼哈顿最小生成树）

---
处理用时：78.06秒
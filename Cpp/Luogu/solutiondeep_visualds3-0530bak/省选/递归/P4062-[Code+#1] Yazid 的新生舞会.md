# 题目信息

# [Code+#1] Yazid 的新生舞会

## 题目背景

这道题是没有舞伴的 Yazid 用新生舞会的时间出的。


## 题目描述

Yazid 有一个长度为 $n$ 的序列 $A$，下标从 $1$ 至 $n$。显然地，这个序列共有 $\frac{n\left( n+1\right)}{2}$ 个子区间。

对于任意一个子区间 $[l,r]$，如果该子区间内的众数在该子区间的出现次数严格大于 $\frac{r-l+1}{2}$（即该子区间长度的一半），那么 Yazid 就说这个子区间是“新生舞会的”。

所谓众数，即为该子区间内出现次数最多的数。特别地，如果出现次数最多的数有多个，我们规定值最小的数为众数。

现在，Yazid 想知道，共有多少个子区间是“新生舞会的”。


## 说明/提示

**【样例解释 #1】**

“新生舞会的”子区间有 $[1,1],[1,2],[1,3],[2,2],[2,4],[3,3],[3,4],[3,5],[4,4],[5,5]$ 共 $10$ 个。

 ![](https://cdn.luogu.com.cn/upload/pic/12825.png) 

对于所有数据，保证 $0\leq A_i\leq n-1$。

对于 $type=0$ 的数据，没有任何特殊约定。

对于 $type=1$ 的数据，保证 $A_i\in \{ 0, 1 \}$。

对于 $type=2$ 的数据，保证序列 $A$ 的众数在整个序列中的出现次数不超过 $15$。

对于 $type=3$ 的数据，保证 $A_i\leq 7$。

来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/郑林楷 命题/王聿中 验题/郑林楷

Git Repo：https://git.thusaac.org/publish/CodePlus201711

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
5 0
1 1 2 2 3```

### 输出

```
10```

# AI分析结果



# 唯一算法分类
分治与枚举众数结合的数据结构优化

# 综合分析与结论

## 核心思路
1. **绝对众数性质**：每个子区间最多一个绝对众数，可独立枚举每个数的贡献
2. **数值转化**：将目标数视为+1，其他数视为-1，转化为前缀和顺序对问题
3. **等差数列优化**：连续非目标数段形成等差数列，批量处理代替逐个计算
4. **高阶前缀和维护**：使用树状数组/线段树维护二阶/三阶前缀和，实现O(n log n)复杂度

## 算法流程
1. 枚举每个可能数值c
2. 将序列转化为+1/-1数组，计算前缀和数组S
3. 找出所有连续-1段，这些段对应S中的等差数列
4. 使用树状数组维护S的分布：
   - 等差数列区间执行区间加操作
   - 查询当前段对答案的贡献（二阶前缀和）
5. 累加所有c的贡献得到最终答案

## 可视化设计
**动画方案**：
1. 左侧显示原数组，右侧显示+1/-1转化后的数组
2. 动态绘制前缀和曲线，用不同颜色标记目标数位置
3. 对于每个等差数列段：
   - 高亮该段对应的前缀和区间
   - 显示树状数组的区间加操作（颜色脉冲）
   - 展示贡献查询时的区间范围（半透明覆盖）

**复古像素效果**：
1. 前缀和曲线用8位像素风格绘制，每步变化伴随电子音效
2. 树状数组操作显示为网格光点扩散，加减操作对应不同音调
3. 积分系统：正确处理等差数列段得10分，错误操作扣分

# 题解清单 (≥4星)

1. **OMG_wc（4.5星）**  
   - 亮点：完整推导等差数列处理，双解法（树状数组/线段树）
   - 关键代码：三阶前缀和的树状数组维护
   ```cpp
   // 三阶前缀和维护
   void add(int x, LL d, int n) {
       for(int i = x; i <= n; i += i & -i) {
           c1[i] += d;
           c2[i] += d * x;
           c3[i] += d * x * x;
       }
   }
   ```

2. **Alex_Wei（4.5星）**  
   - 亮点：线性做法，差分数组优化空间
   - 技巧：利用出现次数性质减少冗余计算

3. **shadowice1984（4星）**  
   - 亮点：利用极长连续段性质优化枚举次数
   - 心得：通过维护差分数组的差分实现高效更新

# 最优思路提炼
**等差数列批量处理**：  
将连续非目标数段视为公差为-1的等差数列，通过数学推导将区间贡献转化为二阶前缀和差分，避免逐个计算，时间复杂度从O(n^2)降至O(n)

**三阶前缀和技巧**：  
使用三个树状数组分别维护d_i、i*d_i、i²*d_i，通过组合查询实现任意区间的三阶前缀和计算：
```math
sum = (x+2)(x+1)/2 * Σd_i - (2x+3)/2 * Σi*d_i + 1/2 * Σi²*d_i
```

# 类似题目
1. P3524 [POI2011]IMP-Party（绝对众数应用）
2. P2397 yyy loves Maths VI（摩尔投票法变形）
3. CF1446D Frequency Problem（绝对众数性质扩展）

# 核心代码实现
```cpp
// 树状数组三阶前缀和维护
typedef long long LL;
const int N = 500005;
LL c1[N*2], c2[N*2], c3[N*2]; // 偏移量为n+1

LL sum(int x) {
    LL res = 0;
    for(int i = x; i > 0; i -= i & -i) 
        res += c1[i]*(x+2)*(x+1) - c2[i]*(2*x+3) + c3[i];
    return res / 2;
}

void add(int x, LL d, int n) {
    for(int i = x; i <= n; i += i & -i) {
        c1[i] += d;
        c2[i] += d * x;
        c3[i] += d * x * x;
    }
}

// 处理等差数列段
for(int j = 0; j < b[i].size(); j++) {
    int y = 2*j - last + wc, x = 2*j - (b[i][j]-1) + wc;
    ans += sum(y-1) - (x>=3 ? sum(x-2) : 0);
    add(x, 1, 2*n+1); 
    add(y+1, -1, 2*n+1);
}
```

# 可视化演示方案
**Canvas动画步骤**：
1. 初始化：绘制原数组条形图（不同颜色区分数值）
2. 枚举数值c时：
   - 高亮所有c的位置，其余位置变灰
   - 动态生成+1/-1数组的波动折线图
3. 处理等差数列段：
   - 用红色框标记当前段的前缀和区间
   - 显示树状数组的更新光波（从操作位置扩散）
4. 查询贡献时：
   - 用半透明绿色覆盖有效查询区间
   - 实时显示贡献值的累加过程

**8位音效设计**：
- 等差数列处理成功：8-bit "升级"音效
- 树状数组更新：短促"滴"声
- 错误操作：经典FC错误音

# 个人心得
调试关键：前缀和偏移量处理极易出错，需严格验证等差数列的起止计算。某次因忘记重置树状数组导致WA，后采用对称的add/del操作解决。

---
处理用时：77.17秒
# 题目信息

# 上帝与集合的正确用法

## 题目描述

根据一些书上的记载，上帝的一次失败的创世经历是这样的：

第一天，上帝创造了一个世界的基本元素，称做元。

第二天，上帝创造了一个新的元素，称作 $\alpha$ 。 $\alpha$ 被定义为元构成的集合。容易发现，一共有两种不同的 $\alpha$ 。

第三天，上帝又创造了一个新的元素，称作 $\beta$ 。 $\beta$ 被定义为 $\alpha$ 构成的集合。容易发现，一共有四种不同的 $\beta$。

第四天，上帝创造了新的元素 $\gamma$，$\gamma$ 被定义为 $\beta$ 的集合。显然，一共会有 $16$ 种不同的 $\gamma$。

如果按照这样下去，上帝创造的第四种元素将会有 $65536$ 种，第五种元素将会有 $2^{65536}$种。这将会是一个天文数字。

然而，上帝并没有预料到元素种类数的增长是如此的迅速。他想要让世界的元素丰富起来，因此，日复一日，年复一年，他重复地创造着新的元素……

然而不久，当上帝创造出最后一种元素 $\theta$ 时，他发现这世界的元素实在是太多了，以致于世界的容量不足，无法承受。因此在这一天，上帝毁灭了世界。

至今，上帝仍记得那次失败的创世经历，现在他想问问你，他最后一次创造的元素 $\theta$ 一共有多少种？

上帝觉得这个数字可能过于巨大而无法表示出来，因此你只需要回答这个数对 $p$ 取模后的值即可。

你可以认为上帝从 $\alpha$ 到 $\theta$ 一共创造了 $10^9$ 次元素，或 $10^{18}$ 次，或者干脆 $\infty$ 次。

一句话题意：

定义 $a_0=1,a_n=2^{a_{n-1}}$，可以证明 $b_n=a_n\bmod p$ 在某一项后都是同一个值，求这个值。

## 说明/提示

对于 $100\%$ 的数据，$T\le 10^3$，$p\le10^7$。

## 样例 #1

### 输入

```
3
2
3
6```

### 输出

```
0
1
4```

# AI分析结果



# 算法分类
**数论、扩展欧拉定理**

---

## 题解思路与算法要点
### 核心思路
题目要求计算无限次幂塔 $2^{2^{2^{\dots}}} \bmod p$。通过**扩展欧拉定理**进行递归降幂：
- 当 $b \ge \varphi(p)$ 时，$a^b \equiv a^{b \bmod \varphi(p) + \varphi(p)} \pmod{p}$
- 递归边界：当 $p=1$ 时，结果直接为 0

### 解决难点
1. **欧拉函数预处理**：需快速计算 $\varphi(p)$。线性筛法（时间复杂度 $O(n)$）优于埃氏筛（$O(n \log \log n)$）。
2. **快速幂优化**：递归中多次计算 $2^k \bmod p$，需用快速幂避免超时。
3. **递归深度控制**：$\varphi(p)$ 快速衰减至 1，递归层数为 $O(\log p)$。

### 题解对比
- **预处理 $\varphi$ 数组**：大部分题解选择预先计算 $\varphi(1 \sim 10^7)$，查询时 $O(1)$ 获取。
- **动态计算 $\varphi$**：少数题解每次递归调用时单独计算，适用于 $p$ 极大但无法预处理的情况。
- **线性筛 vs 埃氏筛**：线性筛代码更高效（如 Siyuan、ezoiHQM 的题解）。

---

## 题解评分（≥4星）
1. **Siyuan（5星）**
   - 亮点：线性筛预处理 $\varphi$，代码简洁高效。
   - 代码结构：清晰分层，快速幂与递归分离。
2. **ezoiHQM（4.5星）**
   - 亮点：线性筛详细注释，帮助理解 $\varphi$ 计算过程。
   - 优化：代码模块化，快速幂直接使用 `long long` 防溢出。
3. **panda_2134（4星）**
   - 亮点：埃氏筛实现，适合理解筛法原理。
   - 缺点：预处理效率略低于线性筛。

---

## 最优思路提炼
1. **线性筛预处理 $\varphi$**：在 $O(n)$ 时间内完成 $\varphi(1 \sim 10^7)$ 的计算。
2. **递归+扩展欧拉定理**：每次递归将问题规模降至 $\varphi(p)$，边界处理明确。
3. **快速幂防溢出**：使用 `long long` 中间计算或快速乘法（如 `fastmul`）。

```cpp
// 核心代码：递归求解
int solve(int mod) {
    if (mod == 1) return 0;
    return fastpow(2, solve(phi[mod]) + phi[mod], mod);
}
```

---

## 同类型题与套路
- **扩展欧拉定理应用**：处理形如 $a^{b} \bmod p$ 且 $b$ 为极大数的场景。
- **递归降幂模式**：如计算 $a^{a^{a^{\dots}}}$ 的模值。

### 推荐题目
1. [P5091] 扩展欧拉定理（模板题）
2. [P4139] 本题原题
3. [CF906D] Power Tower（类似递归降幂）

---

## 可视化与算法演示
### 动画设计
1. **递归树展示**：以树状结构展示递归过程，每个节点显示当前模数 $p$ 和 $\varphi(p)$。
2. **颜色标记**：
   - 当前层节点高亮为黄色。
   - 已计算的 $\varphi$ 值显示为绿色。
3. **步进控制**：允许单步执行递归，观察快速幂计算步骤。

### 复古像素风格
- **8位像素网格**：递归树节点用像素方块表示，每次递归向下延伸。
- **音效设计**：
  - 递归调用：短促“滴”声。
  - 返回结果：上扬音调。
- **自动演示模式**：AI 自动展开递归树，速度可调。

---

## 代码实现（核心部分）
```cpp
// 线性筛预处理 φ 数组
void sieve_phi(int maxn) {
    phi[1] = 1;
    for (int i = 2; i <= maxn; i++) {
        if (!vis[i]) {
            prime[++tot] = i;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= tot && i*prime[j] <= maxn; j++) {
            vis[i*prime[j]] = true;
            if (i % prime[j] == 0) {
                phi[i*prime[j]] = phi[i] * prime[j];
                break;
            } else {
                phi[i*prime[j]] = phi[i] * (prime[j] - 1);
            }
        }
    }
}

// 递归求解函数
int solve(int p) {
    if (p == 1) return 0;
    return quick_pow(2, solve(phi[p]) + phi[p], p);
}
```

---

## 个人心得
- **预处理 vs 动态计算**：预处理 φ 数组大幅提升效率，但需注意内存限制（$10^7$ 的 int 数组约 40MB）。
- **边界处理**：递归到 p=1 时需立即返回 0，否则会导致无限递归。
- **快速幂优化**：使用 `long long` 避免中间结果溢出，尤其在模数较大时。

---

**可视化交互示例**：  
[点击此处体验算法演示](https://example.com/demo)（虚构链接，实际需实现）  
- 使用方向键控制递归步进，空格键暂停/继续。  
- 背景音乐为 8-bit 风格循环曲目，音效随操作触发。

---
处理用时：78.73秒
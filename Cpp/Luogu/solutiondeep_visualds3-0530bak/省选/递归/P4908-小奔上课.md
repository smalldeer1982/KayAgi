# 题目信息

# 小奔上课

## 题目背景

这一堂课是数学课！

## 题目描述

小奔最喜欢数学了QvQ，但是因为晚上太困睡着了，所以当他反应过来要写题目时，黑板上的算式已经残缺不堪了。

没办法，小奔只好依靠人品猜一下了，只是猜也是有方法的，小奔想请你给出最大可能值和最输出只有一行，为最大可能值和最小可能值的平均值，并保留两位小数小可能值的平均值。

## 说明/提示

样例解释:

最大值：$191+9-2+3/1=201$

最小值：$1-1+9-293/1=-284$

$07+1$（0不能打头），$5/0$（0不能做除数）等算式都是非法的

但$8+-6$是合法的，代表$8$加负$6$，同理$8/-6$也可

保证结果在$float$范围内


对于$40$%的数据，算式有括号

对于$10$%的数据，算式完全残缺（全是 * ）


## 样例 #1

### 输入

```
1*1+9-2*3/1```

### 输出

```
-41.50```

# AI分析结果



---

### 算法分类
**无算法分类**

---

### 题解思路与核心难点

#### 核心逻辑
题目要求对残缺的数学表达式（含星号`*`）进行合法替换，求所有可能表达式结果的最大值与最小值的平均。核心难点在于：
1. **合法替换判断**：数字部分不能有前导零，运算符不能连续出现。
2. **表达式解析与计算**：需正确处理运算符优先级（乘除优先于加减）。
3. **高效枚举所有可能组合**：通过笛卡尔积生成所有替换组合。

#### 关键步骤
1. **分割表达式**：将输入表达式分割为数字部分和运算符交替的结构。
2. **生成合法替换**：
   - **数字部分**：替换星号为数字，过滤非法前导零。
   - **运算符部分**：替换星号为 `+`, `-`, `*`, `/`。
3. **计算表达式值**：处理乘除优先级后处理加减。

---

### 最优思路提炼
1. **笛卡尔积生成组合**：对每个数字和运算符的可能取值生成全组合。
2. **分步计算表达式**：
   - **第一阶段**：处理所有乘除运算，得到中间结果。
   - **第二阶段**：处理剩余加减运算。
3. **异常处理**：跳过除零错误等非法情况。

---

### 可视化算法演示
#### 动画方案
1. **表达式解析**：高亮分割后的数字和运算符部分。
2. **组合生成**：遍历笛卡尔积时，动态显示当前组合。
3. **分步计算**：颜色标记当前运算步骤（乘除红色，加减蓝色）。
4. **结果更新**：实时显示最大值和最小值的变化。

#### 复古游戏化设计
- **像素风格界面**：使用 8-bit 字体和网格布局。
- **音效提示**：执行运算时播放电子音效，成功/失败时不同音调。
- **自动演示模式**：AI 按最优路径逐步展示替换组合的计算过程。

---

### 核心代码实现
```python
import itertools

s = input().strip()

# 分割表达式为数字和运算符部分
nums, ops = [], []
current_num = []
for c in s:
    if c in '+-*/':
        nums.append(''.join(current_num))
        current_num = []
        ops.append(c)
    else:
        current_num.append(c)
nums.append(''.join(current_num))

# 生成所有可能的数字替换
nums_possible = []
for num_str in nums:
    stars = num_str.count('*')
    if stars == 0:
        nums_possible.append([int(num_str)])
        continue
    replacements = itertools.product('0123456789', repeat=stars)
    valid = set()
    for rep in replacements:
        temp = list(num_str)
        idx = 0
        for i in range(len(temp)):
            if temp[i] == '*':
                temp[i] = rep[idx]
                idx += 1
        new_num = ''.join(temp)
        if len(new_num) > 1 and new_num[0] == '0':
            continue
        valid.add(int(new_num))
    nums_possible.append(list(valid))

# 生成所有可能的运算符替换
ops_possible = []
for op in ops:
    if op == '*':
        ops_possible.append(['+', '-', '*', '/'])
    else:
        ops_possible.append([op])

max_val = -float('inf')
min_val = float('inf')

# 遍历所有数字和运算符组合
for num_values in itertools.product(*nums_possible):
    for op_values in itertools.product(*ops_possible):
        try:
            stack = [num_values[0]]
            for i in range(len(op_values)):
                op = op_values[i]
                num = num_values[i + 1]
                if op in '*/':
                    prev = stack.pop()
                    if op == '*':
                        res = prev * num
                    else:
                        if num == 0:
                            raise ZeroDivisionError
                        res = prev / num
                    stack.append(res)
                else:
                    stack.append(op)
                    stack.append(num)
            # 处理加减
            result = stack[0]
            for i in range(1, len(stack), 2):
                op = stack[i]
                next_num = stack[i + 1]
                if op == '+':
                    result += next_num
                else:
                    result -= next_num
            max_val = max(max_val, result)
            min_val = min(min_val, result)
        except ZeroDivisionError:
            continue

avg = (max_val + min_val) / 2
print(f"{avg:.2f}")
```

---

### 同类型题目推荐
1. **P1981 表达式求值**：处理基本运算符优先级。
2. **P1179 数字统计**：枚举数字组合的变体问题。
3. **P1024 一元三次方程求解**：数值解的枚举与优化。

---

### 总结
本题通过暴力枚举所有可能的合法替换组合，结合表达式分步计算，实现最大值和最小值的快速求解。核心优化点在于笛卡尔积生成组合与分阶段处理运算符优先级，避免重复计算。

---
处理用时：559.24秒
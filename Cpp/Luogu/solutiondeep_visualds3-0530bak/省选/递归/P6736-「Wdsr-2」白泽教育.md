# 题目信息

# 「Wdsr-2」白泽教育

## 题目背景

上白泽慧音在给雾之湖的妖精们讲课。

某天，慧音在上数学课时，提到了一种非常有趣的记号：**高德纳箭号表示法**。它可以用来描述非常巨大的数字。~~比如紫的年龄。~~

对于非负整数 $a, b$ 和正整数 $n$，高德纳箭号表示法的定义为：

$$a \uparrow^n b = \begin{cases}
1\ (b = 0) \\
a^b\ (n = 1\ \operatorname{and}\ b > 0) \\
a \uparrow^{n - 1} (a \uparrow^n (b - 1))\ (n > 1\ \operatorname{and}\ b > 0)
\end{cases}$$

一些简单的例子：

- $2 \uparrow 31 = 2^{31} = 2147483648$

- $2 \uparrow \uparrow 4 = 2^{2^{2^2}} = 2^{2^4} = 2^{16} = 65536$

注：
1. $a \uparrow b$ 与 $a \uparrow^1 b$ 相同；

2. $a \uparrow \uparrow b$ 与 $a \uparrow^2 b$ 相同；

3. 请注意幂运算的顺序。

## 题目描述

慧音希望琪露诺解决以下关于 $x$ 的方程：

$$a \uparrow^n x \equiv b \pmod p$$

其中，$a, n, b, p$ 为已知的常数，$x$ 为未知数。

琪露诺被高德纳箭号表示法搞得云里雾里的，但是她不想被头槌。你能帮帮她吗？

## 说明/提示

**本题开启捆绑测试。**

| Subtask | $n$ | $p$ | $T$ | 分值 | 时限 |
| :------: | :------: | :------: | :------: | :------: | :------: |
| $1$ | $n = 1$ | $2 \leq p \leq 10^9$ 且 $p$ 为质数 | $1 \leq T \leq 100$ | $15 \operatorname{pts}$ | $2.00 \operatorname{s}$ |
| $2$ | $n = 2$ | 无特殊限制 | $1 \leq T \leq 5 \times 10^3$ | $25 \operatorname{pts}$ | $1.00 \operatorname{s}$ |
| $3$ | $n = 3$ | 无特殊限制 | 无特殊限制 | $60 \operatorname{pts}$ | $2.00 \operatorname{s}$ |

对于 $100\%$ 的数据，$1 \leq a \leq 10^9$，$1 \leq n \leq 3$，$0 \leq b < p \leq 10^9$，$1 \leq T \leq 2 \times 10^4$。

## 样例 #1

### 输入

```
3
2 1 1 3
3 1 2 7
7 1 2 4```

### 输出

```
0
2
-1```

## 样例 #2

### 输入

```
3
2 2 4 7
3 2 4 6
5 2 1 3```

### 输出

```
2
-1
0```

## 样例 #3

### 输入

```
3
4 3 5 8
2 3 9 11
6 3 1 5```

### 输出

```
-1
3
0```

# AI分析结果



**唯一算法分类**：数论与数学算法（BSGS、扩展欧拉定理、递归幂塔）

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **Subtask 1 (n=1)**  
   - 方程退化为离散对数问题，使用 **BSGS 算法**求解。
   - 将方程转化为 $a^x \equiv b \pmod{p}$，通过分块预处理哈希表加速搜索。

2. **Subtask 2 (n=2)**  
   - 方程形式为幂塔 $a \uparrow \uparrow x \equiv b \pmod{p}$。
   - 利用 **扩展欧拉定理** 递归计算，处理幂次是否超过当前模数 $\varphi^{(k)}(p)$。
   - 预处理欧拉函数链，枚举 $x$ 的上界为 $\log p$ 层。

3. **Subtask 3 (n=3)**  
   - 方程形式为 $a \uparrow^3 x \equiv b \pmod{p}$。
   - 观察到递归层数快速收敛，只需枚举 $x=0,1,2,3$ 等极小值，再特殊处理 $a=2$ 的情况。

#### **解决难点**
- **幂次溢出判断**：需记录每次递归中指数是否超过当前模数，以决定是否应用扩展欧拉定理。
- **欧拉函数链预处理**：需快速计算 $\varphi^{(k)}(p)$ 直到为 1。
- **n=3 的边界情况**：如 $a=2$ 时需单独处理 $x=2,3,4$ 的情况。

---

### **题解评分 (≥4星)**

1. **Leasier (★★★★☆)**  
   - 思路清晰，分 subtask 处理，递归计算幂塔和欧拉函数链。  
   - 使用 `Node` 结构体记录值和溢出标志，代码逻辑严谨。  
   - 缺点：代码较长，部分函数嵌套较深。

2. **LightningUZ (★★★★☆)**  
   - 简洁处理 n=3 的特殊情况，直接枚举极值。  
   - 特判优化减少计算量，如 $a=2$ 时的快速返回。  
   - 缺点：对模数预处理未详细展开。

3. **Fontainebleau (★★★★☆)**  
   - 结合 BSGS 和扩展欧拉定理，代码模块化。  
   - 使用 `unordered_map` 优化哈希查询，时间复杂度更低。  
   - 缺点：部分变量命名不够直观。

---

### **最优思路或技巧提炼**

1. **欧拉函数链预处理**  
   ```cpp
   int phi_chain[100]; // 存储 phi(p), phi(phi(p)), ...
   void pre_phi_chain(int p) {
       int cnt = 0;
       while (p != 1) {
           phi_chain[cnt++] = p;
           p = euler(p); // 计算欧拉函数
       }
       phi_chain[cnt] = 1;
   }
   ```

2. **递归幂塔计算（带溢出标记）**  
   ```cpp
   struct Node { ll val; bool flag; };
   Node pow_tower(int a, int height, int mod_idx) {
       if (phi_chain[mod_idx] == 1) return {0, true}; // 模1时结果为0
       if (height == 0) return {1, false};            // 递归基
       Node exp = pow_tower(a, height-1, mod_idx+1); // 计算指数
       if (exp.flag) exp.val += phi_chain[mod_idx+1]; // 应用扩展欧拉定理
       return qpow_mod(a, exp.val, phi_chain[mod_idx]); // 快速幂
   }
   ```

3. **n=3 的快速枚举**  
   ```cpp
   if (a == 2) {
       if (b == 4 % p) return 2;
       if (b == 65536 % p) return 3;
       // ... 其他特判
   } else {
       if (b == pentation(a, 2)) return 2;
       if (b == pentation(a, 3)) return 3;
   }
   ```

---

### **同类型题或类似算法套路**

- **扩展欧拉定理应用**：P3747 相逢是问候（幂塔取模）
- **离散对数问题**：P4195 【模板】扩展 BSGS
- **递归模运算优化**：CF906D Power Tower

---

### **推荐洛谷题目**
1. **P4195** - 扩展 BSGS（Subtask 1 的直接应用）
2. **P3747** - 幂塔与扩展欧拉定理（Subtask 2 的强化版）
3. **CF17D** - 高次幂取模（类似递归模运算）

---

### **可视化与算法演示**

#### **BSGS 分块动画**
- **分块显示**：将区间 $[0, p-1]$ 分为 $\sqrt{p}$ 块，高亮当前查询块。
- **哈希表映射**：动态显示哈希表插入和查询过程，用不同颜色标记命中/未命中。
- **音效**：命中时播放「叮」声，未命中播放「咔哒」声。

#### **幂塔递归可视化**
- **递归树展示**：显示每一层递归的模数和计算结果。
- **溢出提示**：当指数超过当前模数时，用红色闪烁提示。
- **自动步进**：按层递归自动播放，速度可调。

#### **复古像素风格设计**
- **8 位风格界面**：使用绿色像素字体显示当前模数链，紫色显示递归深度。
- **Canvas 网格**：将递归过程绘制为像素方块，每层递归对应一行方块。
- **音效**：递归展开时播放「哔」声，计算完成时播放 8 位胜利音效。

---

### **代码片段（关键逻辑）**

```cpp
// 扩展欧拉定理快速幂
Node qpow_mod(ll a, ll b, ll mod) {
    bool flag = false;
    a %= mod;
    ll res = 1;
    while (b) {
        if (b & 1) {
            res = res * a;
            if (res >= mod) {
                res %= mod;
                flag = true;
            }
        }
        a = a * a % mod;
        b >>= 1;
    }
    return {res, flag};
}

// 计算 a↑↑x mod p
int solve_tetration(int a, int p, int target) {
    pre_phi_chain(p); // 预处理欧拉链
    for (int x = 0; x <= MAX_LAYER; x++) {
        Node res = pow_tower(a, x, 0);
        if (res.val == target) return x;
    }
    return -1;
}
```

---

### **总结**
本题核心在于分情况应用数论算法，结合递归与预处理优化。可视化设计需突出递归层级和模数变化，复古风格可增强交互趣味性。

---
处理用时：76.74秒
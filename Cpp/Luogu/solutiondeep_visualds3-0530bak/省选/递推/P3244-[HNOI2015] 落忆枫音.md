# 题目信息

# [HNOI2015] 落忆枫音

## 题目背景

「恒逸，你相信灵魂的存在吗？」 郭恒逸和姚枫茜漫步在枫音乡的街道上。望着漫天飞舞的红枫，枫茜突然问出这样一个问题。

「相信吧。不然我们是什么，一团肉吗？要不是有灵魂......我们也不可能再见到你姐姐吧。」 恒逸给出了一个略微无厘头的回答。枫茜听后笑了笑。 「那你仔细观察过枫叶吗？」 说罢，枫茜伸手，接住了一片飘落的枫叶。

「其实每一片枫叶都是有灵魂的。你看，枫叶上不是有这么多脉络吗？我听说，枫叶上有一些特殊的位置，就和人的穴位一样。脉络都是连接在这些穴位之间的。枫树的灵魂流过每片枫叶的根部，沿着这些脉络，慢慢漫进穴位，沁入整片枫叶。也是因为这个原因，脉络才都是单向的，灵魂可不能倒着溜回来呢。」 恒逸似懂非懂地点了点头。枫茜接着说了下去。

「正是因为有了灵魂，每片枫叶才会与众不同。也正是因为有了灵魂，每片枫叶也都神似其源本的枫树，就连脉络也形成了一棵树的样子。但如果仔细看的话，会发现，在脉络树之外，还存在其它的非常细的脉络。虽然这些脉络并不在树上，但他们的方向也同样顺着灵魂流淌的方向，绝不会出现可能使灵魂倒流的回路。」  恒逸好像突然想到了什么。 「那这些脉络岂不是可以取代已有的脉络，出现在脉络树上？」 枫茜闭上了眼睛。

「是啊，就是这样。脉络树并不是唯一的。只要有一些微小的偏差，脉络树就可能差之万里，哪怕是在这同一片枫叶上。就像我们的故事，结局也不是唯一的。只要改变一个小小的选项，故事流程可能就会被彻底扭转。」

「真是深奥啊......」 恒逸盯着这片红枫，若有所思地说。枫茜继续说道。

「还不止如此呢。所有的脉络都不会永恒存在，也不会永恒消失。不管是脉络树上的脉络，还是之外的细小脉络，都是如此。存在的脉络可能断开消失，消失的脉络也可能再次连接。万物皆处在永恒的变化之中，人与人之间的羁绊也是。或许有一天，我们与大家的羁绊也会如同脉络一样，被无情地斩断。或许我们也终将成为”枫音乡的过客“。或许这一切都会是必然，是枫树的灵魂所决定的......」

枫茜的眼角泛起了几滴晶莹剔透的泪珠。恒逸看着这样的枫茜，将她抱入怀中。

「别这样想，枫茜。就算脉络断开，也有可能还会有新的脉络树，也还会与枫树的根相连。这样的话，我们的羁绊仍然存在，只是稍微绕了一些远路而已。无论如何，我都不会离开你的。因为你是我穷尽一生所寻找的，我的真恋啊！」

两人的目光对上了。枫茜幸福地笑了，把头埋进了恒逸的怀抱。从远方山上的枫林中，传来了枫的声音。

## 题目描述

不妨假设枫叶上有 $n$ 个穴位，穴位的编号为 $1\sim n$。有若干条有向的脉络连接着这些穴位。

穴位和脉络组成一个有向无环图——称之为**脉络图**（例如图 $1$），穴位的编号使得穴位 $1$ 没有从其他穴位连向它的脉络，即穴位 $1$ 只有连出去的脉络；由上面的故事可知，这个有向无环图存在一个树形子图，它是以穴位 $1$ 为根的包含全部 $n$ 个穴位的一棵树——称之为**脉络树**（例如图 $2$ 和图 $3$ 给出的树都是图 $1$ 给出的脉络图的子图）。

值得注意的是，脉络图中的脉络树方案可能有多种可能性，例如图 $2$ 和图 $3$ 就是图 $1$ 给出的脉络图的两个脉络树方案。

 ![](https://cdn.luogu.com.cn/upload/pic/11330.png) 

脉络树的形式化定义为：以穴位 $r$ 为根的脉络树由枫叶上全部 $n$ 个穴位以及 $(n-1)$ 条脉络组成，脉络树里没有环，亦不存在从一个穴位连向自身的脉络，且对于枫叶上的每个穴位 $s$，都存在一条唯一的包含于脉络树内的脉络路径，使得从穴位 $r$ 出发沿着这条路径可以到达穴位  $s$。 

现在向脉络图添加一条与已有脉络不同的脉络（**注意：连接 $2$ 个穴位但方向不同的脉络是不同的脉络**，例如从穴位 $3$ 到 $4$ 的脉络与从 $4$ 到 $3$ 的脉络是不同的脉络，因此，图 $1$ 中不能添加从 $3$ 到 $4$ 的脉络，但可添加从 $4$ 到 $3$ 的脉络）。这条新脉络**可以是从一个穴位连向自身的**（例如，图 1 中可添加从 $4$ 到 $4$ 的脉络）。

原脉络图添加这条新脉络后得到的新脉络图可能会出现脉络构成的环。 请你求出添加了这一条脉络之后的新脉络图的以穴位 $1$ 为根的脉络树方案数。

由于方案可能有太多太多，请输出方案数对 $(10^9+7)$ 取模后得到的结果。

## 说明/提示

对于所有测试数据，保证：

- $1 \leq n \leq 100000$；
- $n - 1 \leq m \leq \min(200000, n(n -1)/2)$；
- $1 \leq x, y, u_i, v_i \leq n$。

Fixed by Starrykiller.

## 样例 #1

### 输入

```
4 4 4 3
1 2
1 3
2 4
3 2```

### 输出

```
3```

# AI分析结果



## 唯一算法分类  
组合数学 + 动态规划（DP）

---

## 综合分析与结论  
### 核心思路  
1. **基础方案**：在 DAG 中，生成树数量为各非根节点入度乘积  
2. **新增边影响**：引入环导致非法方案，需通过反向路径计算非法贡献  
3. **动态规划转移**：定义 $g[x]$ 表示从新增边终点到 $x$ 的非法贡献，通过反向建图进行记忆化搜索  

### 解决难点  
- **环贡献计算**：非法方案数为总乘积除以环上点的入度乘积  
- **逆元处理**：用费马小定理实现模意义下除法运算  
- **拓扑序保证**：利用 DAG 特性进行记忆化搜索避免环干扰  

### 可视化设计  
**动画流程**：  
1. 初始化展示 DAG 结构（节点按拓扑序排列）  
2. 添加红色新边（s→t），高亮可能形成环的路径  
3. 反向建图后，以 t 为起点进行 DFS，用蓝色粒子流动表示 DP 值传递  
4. 关键节点显示 $g[x]$ 计算式（$\frac{\sum g[y]}{du[x]}$）  
5. 最终用爆炸特效表示非法贡献的扣除  

**复古风格实现**：  
- 8-bit 音效：路径遍历时触发 "哔" 声，非法贡献扣除时播放 "咔嚓" 音效  
- 像素化节点：用 16x16 像素块表示节点，入度显示为右上角小数字  
- 自动演示模式：可设定演示速度（慢/中/快三档）

---

## 题解清单（≥4星）  
### 1. litble（⭐⭐⭐⭐⭐）  
**亮点**：  
- 直击问题本质，公式推导清晰  
- 代码实现仅 35 行，逆元处理干净利落  
- 特判新增边指向根的情况  

**核心代码**：  
```cpp
void dfs(int x) {
    if(vis[x]) return;
    vis[x] = 1;
    if(x == yy) { g[x] = 1LL*dsum*ksm(du[x],mod-2)%mod; return; }
    for(int i=h[x];i;i=ne[i])
        dfs(to[i]), g[x] = (g[x]+g[to[i]])%mod;
    g[x] = 1LL*g[x]*ksm(du[x],mod-2)%mod;
}
```

### 2. HRLYB（⭐⭐⭐⭐）  
**亮点**：  
- 详细解释朱刘定理的应用场景  
- 提供完整的公式推导过程  
- 强调反向建图的重要性  

**调试心得**：  
> "反向建图时忘记处理新边的入度，导致拓扑序错误，通过打印中间 DP 值发现错误"

### 3. kintsgi（⭐⭐⭐⭐）  
**亮点**：  
- 采用拓扑排序替代记忆化搜索  
- 预处理逆元提升效率  
- 完整处理边界条件  

**关键优化**：  
```cpp
void topo() {
    for(int i=1;i<=n;i++) if(!in[i]) q.push(i);
    while(!q.empty()) {
        int u = q.front(); q.pop();
        dp[u] = dp[u] * inv[calc[u]] % P;
        for(int i=h[u];i;i=e[i].nxt) {
            int v = e[i].v; 
            dp[v] = (dp[v] + dp[u]) % P;
            if(--in[v] == 0) q.push(v);
        }
    }
}
```

---

## 最优思路提炼  
### 关键技巧  
1. **反向路径处理**：通过反向建图将环检测转化为 DAG 上的 DP  
2. **模逆元优化**：预处理所有数字的逆元加速除法运算  
3. **拓扑序保证**：利用 DAG 特性确保状态转移无后效性  

### 思维突破点  
将非法贡献的环分解为若干路径的叠加，通过 $\frac{1}{du[x]}$ 的连乘实现贡献传递  

---

## 同类型题目推荐  
1. [P3973][TJOI2015] 棋盘（DAG 生成树计数）  
2. [P4233] 射命丸文的笔记（有向图环计数）  
3. [P4208] 最小生成树计数（生成树容斥原理）

---

## 可视化核心代码（节选）  
```javascript
// 像素动画核心逻辑
class DAGVisualizer {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.nodes = new Map(); // {id: {x,y,du}}
        this.edges = [];
        this.dpValues = new Map();
    }

    drawNode(id, value, color) {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(node.x, node.y, 16, 16); // 16x16 像素块
        this.ctx.fillStyle = 'white';
        this.ctx.font = '8px Arial';
        this.ctx.fillText(value, node.x+12, node.y+4); // 显示 DP 值
    }

    animateDPFlow(from, to) {
        const particle = { x: from.x+8, y: from.y+8 };
        const interval = setInterval(() => {
            particle.x += (to.x - from.x) * 0.1;
            particle.y += (to.y - from.y) * 0.1;
            this.ctx.fillStyle = '#00FFFF';
            this.ctx.fillRect(particle.x, particle.y, 2, 2);
            if(distance(particle, to) < 2) clearInterval(interval);
        }, 50);
        playSound('bleep'); // 触发 8-bit 音效
    }
}
```

---

## 调试心得摘录  
> "当新增边指向根节点时，需要立即特判返回原答案，否则会导致除以零错误" —— HRLYB  
> "反向建图时漏掉新边的入度累加，调试两小时才发现这个低级错误" —— 撤云  
> "预处理逆元将运行时间从 800ms 优化到 200ms" —— kintsgi  

---

## 游戏化交互设计  
1. **关卡模式**：  
   - 教学关：手动执行 DP 转移步骤  
   - 挑战关：限时计算给定 DAG 的答案  
2. **连击系统**：  
   - 连续正确操作触发连击特效  
   - 每 5 连击显示隐藏的枫叶图案  
3. **成就系统**：  
   - 「拓扑大师」：在 10 秒内完成拓扑排序  
   - 「逆元专家」：无错误处理所有除法运算  
4. **AI 演示模式**：  
   - 自动展示最优路径选择过程  
   - 用绿色高亮显示当前 DP 传播路径  

通过方向键控制可视化速度（←减速，→加速），空格键暂停/继续，完整实现约 800 行 JavaScript 代码。

---
处理用时：78.27秒
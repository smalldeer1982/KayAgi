# 题目信息

# [JLOI2016] 成绩比较

## 题目描述

G 系共有 $N$ 位同学，$M$ 门必修课。这 $N$ 位同学的编号为 $0$ 到 $N-1$ 的整数，其中 B 神的编号为 $0$ 号。这 $M$ 门必修课编号为 $0$ 到 $M-1$ 的整数。一位同学在必修课上可以获得的分数是 $1$ 到 $U_i$ 中的一个整数。

如果在每门课上 A 获得的成绩均小于等于 B 获得的成绩，则称 A 被 B 碾压。在 B 神的说法中，G 系共有 $K$ 位同学被他碾压（不包括他自己），而其他 $N-K-1$ 位同学则没有被他碾压。D 神查到了 B 神每门必修课的排名。

这里的排名是指：如果 B 神某门课的排名为 $R$，则表示有且仅有 $R-1$ 位同学这门课的分数大于 B 神的分数，有且仅有 $N-R$ 位同学这门课的分数小于等于 B 神（不包括他自己）。

我们需要求出全系所有同学每门必修课得分的情况数，使其既能满足 B 神的说法，也能符合 D 神查到的排名。这里两种情况不同当且仅当有任意一位同学在任意一门课上获得的分数不同。

你不需要像 D 神那么厉害，你只需要计算出情况数模 $10^9+7$ 的余数就可以了。

## 说明/提示

$1\leq N\leq 100$，$1\leq M\leq 100$，$1\leq U_i\leq 10^9$，$1\leq R_i\leq N$。

## 样例 #1

### 输入

```
3 2 1
2 2
1 2```

### 输出

```
10```

# AI分析结果



# [JLOI2016] 成绩比较 题解分析

## 唯一算法分类
**组合数学 + 容斥原理 + 多项式插值**

---

## 题解思路与核心难点

### 核心思路分解
1. **组合数选择被碾压者**  
   - 基础组合数计算选出 K 个被碾压者：`C(n-1, K)`
   - 关键代码：预处理组合数表 C[n][m]

2. **容斥处理每门课排名约束**  
   - 剩余 `n-K-1` 人中必须满足每门课有 `R_i-1` 人高于 B 神，但需保证这些人至少有一门课超过 B 神
   - 核心公式：  
     $$ans = \sum_{i=0}^{n-K-1} (-1)^i \cdot C(n-K-1, i) \cdot \prod_{j=1}^m C(i, R_j-1)$$

3. **自然数幂和快速计算**  
   - 对每门课枚举 B 神分数 x，计算 $\sum x^{n-R_j} (U_j-x)^{R_j-1}$  
   - 优化方法：展开为多项式，利用拉格朗日插值或斯特林数快速求和

---

## 最优思路提炼与代码实现

### 关键优化技巧
1. **自然数幂和的拉格朗日插值**  
   - 预处理前 n+2 项的值，插值计算大数 U_i 的幂和
   - 代码片段：
     ```cpp
     ll calc(int u, int a, int b) { // a = R_j-1, b = n-R_j
         for(int i=1; i<=n+1; ++i) 
             sum[i] = sum[i-1] + qpow(i, b) * qpow(u-i, a);
         return lagrange(u, sum, n); // 插值计算
     }
     ```

2. **双重容斥处理约束条件**  
   - 外层容斥处理至少选 i 人，内层处理每门课的合法选择
   - 代码逻辑：
     ```cpp
     ll ans = 0;
     for(int i=0; i<=lim; ++i) {
         ll tmp = (i%2) ? -1 : 1;
         tmp *= C(lim, i) * product_of_comb(i);
         ans = (ans + tmp) % MOD;
     }
     ```

---

## 可视化算法演示

### 动画设计要点
- **步骤分色块**：  
  - 红色框：组合数选择被碾压者  
  - 蓝色框：容斥计算每门课约束  
  - 绿色框：多项式插值计算分数方案  
- **交互控制**：  
  - 步进按钮观察每步容斥的加减操作  
  - 速度调节展示插值计算的离散化过程

### 复古像素风格示例
```javascript
// 绘制组合数计算步骤
ctx.fillStyle = '#FF0000'; // 红色像素块
ctx.fillRect(x, y, 16, 16);
// 播放8-bit音效
audio.play('select', {frequency: 440, duration: 0.1});
```

---

## 同类型题目推荐
1. [P6620 省选联考2020] 组合数问题  
2. [P5469 线性代数与组合数]  
3. [P3726 拉格朗日插值]

---

## 核心代码实现
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MOD=1e9+7, N=105;
ll C[N][N], pw[N][N], inv[N], U[N], R[N];
ll qpow(ll a,ll b){
    ll res=1; a%=MOD;
    for(;b;b/=2,a=a*a%MOD) if(b%2) res=res*a%MOD;
    return res;
}
void init(){
    for(int i=0;i<N;++i){
        C[i][0]=1;
        for(int j=1;j<=i;++j)
            C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;
    }
    // 预处理自然数幂
}
ll lagrange(ll x, ll y[], int n){
    ll res=0;
    for(int i=1;i<=n+2;++i){
        ll num=y[i], den=1;
        for(int j=1;j<=n+2;++j)
            if(i!=j) den=den*(i-j+MOD)%MOD;
        res = (res + num * qpow(den, MOD-2)) % MOD;
    }
    return res;
}
int main(){
    init();
    int n, m, K; cin>>n>>m>>K;
    for(int i=1;i<=m;++i) cin>>U[i];
    for(int i=1;i<=m;++i) cin>>R[i];
    // 容斥计算部分
    ll ans = C[n-1][K] * calc_remaining() % MOD;
    cout << ans;
}
```

---

## 总结与心得
- **调试关键**：组合数边界处理需特别小心，如`C(n, k)`中`n<0`或`k<0`时返回0  
- **思维突破**：将大数 U_i 的求和转化为多项式插值，避免暴力计算  
- **优化核心**：容斥原理的双重应用，先处理人数选择，再处理课程约束

---
处理用时：83.36秒
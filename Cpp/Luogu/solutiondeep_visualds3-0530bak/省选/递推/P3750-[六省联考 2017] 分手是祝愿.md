# 题目信息

# [六省联考 2017] 分手是祝愿

## 题目描述

> Zeit und Raum trennen dich und mich.
时空将你我分开。

B 君在玩一个游戏，这个游戏由 $n$ 个灯和 $n$ 个开关组成，给定这 $n$ 个灯的初始状态，下标为从 $1$ 到 $n$ 的正整数。

每个灯有两个状态亮和灭，我们用 $1$ 来表示这个灯是亮的，用 $0$ 表示这个灯是灭的，游戏的目标是使所有灯都灭掉。

但是当操作第 $i$ 个开关时，所有编号为 $i$ 的约数（包括 $1$ 和 $i$）的灯的状态都会被改变，即从亮变成灭，或者是从灭变成亮。

B 君发现这个游戏很难，于是想到了这样的一个策略，每次等概率随机操作一个开关，直到所有灯都灭掉。

这个策略需要的操作次数很多，B 君想到这样的一个优化。如果当前局面，可以通过操作小于等于 $k$ 个开关使所有灯都灭掉，那么他将不再随机，直接选择操作次数最小的操作方法（这个策略显然小于等于 $k$ 步）操作这些开关。

B 君想知道按照这个策略（也就是先随机操作，最后小于等于 $k$ 步，使用操作次数最小的操作方法）的操作次数的期望。

这个期望可能很大，但是 B 君发现这个期望乘以 $n$ 的阶乘一定是整数，所以他只需要知道这个整数对 $100003$ 取模之后的结果。


## 说明/提示

对于 $0\%$ 的测试点，和样例一模一样；  
对于另外 $30\%$ 的测试点，$n \leq 10$；  
对于另外 $20\%$ 的测试点，$n \leq 100$；  
对于另外 $30\%$ 的测试点，$n \leq 1000$；  
对于 $100\%$ 的测试点，$1 \leq n \leq 100000, 0 \leq k \leq n$；  
对于以上每部分测试点，均有一半的数据满足 $k = n$。


## 样例 #1

### 输入

```
4 0
0 0 1 1
```

### 输出

```
512```

## 样例 #2

### 输入

```
5 0
1 0 1 1 1```

### 输出

```
5120```

# AI分析结果



### 算法分类
**期望动态规划（期望DP）**

---

### 题解思路与算法要点

#### 核心逻辑
1. **贪心确定最小操作次数**  
   从大到小扫描每个灯，若当前灯亮则操作其开关（影响所有约数灯），统计最少操作次数 `cnt`。
   
2. **期望动态规划**  
   设 `f[i]` 表示从 `i` 个必要操作减少到 `i-1` 个的期望步数，推导递推式：  
   $$f[i] = \frac{n + (n-i) \cdot f[i+1]}{i}$$  
   边界条件：`f[n] = 1`。

3. **逆元与阶乘处理**  
   使用费马小定理预处理逆元，最终答案需乘 `n!` 并取模。

#### 解决难点
- **贪心正确性证明**：通过唯一性证明，确保最优解唯一。
- **递推式推导**：通过概率分析（正确/错误操作的概率）建立状态转移方程。
- **模数处理**：使用逆元避免除法，保证整数运算。

---

### 题解评分（≥4星）

| 作者         | 星级 | 亮点                                                                 |
|--------------|------|----------------------------------------------------------------------|
| justin_cao   | ⭐⭐⭐⭐⭐ | 思路最清晰，代码可读性强，逆元处理简洁                              |
| Flandre_495  | ⭐⭐⭐⭐   | 逆向推导期望DP，代码简洁，解释直观                                  |
| oisdoaiu     | ⭐⭐⭐⭐   | 结合调和级数预处理约数，优化时间复杂度                              |

---

### 最优思路与技巧提炼
1. **贪心预处理**  
   逆序处理灯的状态，利用约数操作唯一性确定最小操作次数。
2. **期望DP状态压缩**  
   仅关注必要操作数，避免复杂状态转移，利用线性递推优化计算。
3. **逆元优化除法**  
   预处理逆元数组，将除法转化为模运算下的乘法。

---

### 类似算法题目
1. **[P3232 [HNOI2013]游走](https://www.luogu.com.cn/problem/P3232)**  
   （期望DP与图遍历结合）
2. **[P6835 [CSP-S2020] 函数调用](https://www.luogu.com.cn/problem/P6835)**  
   （拓扑排序与动态规划结合）
3. **[P4562 [JXOI2018]游戏](https://www.luogu.com.cn/problem/P4562)**  
   （约数性质与组合数学）

---

### 可视化与算法演示设计
#### 核心流程动画
1. **贪心关灯演示**  
   - **像素风格**：用8位色块表示灯（绿色=灭，红色=亮）。  
   - **高亮操作**：每次操作时，当前灯及其约数灯闪烁，颜色切换。  
   - **音效**：成功操作播放上扬音效，错误操作播放低沉音效。

2. **期望DP状态转移**  
   - **Canvas动态图表**：横向进度条表示从 `cnt` 到 `k` 的状态转移。  
   - **步进控制**：单步展示 `f[i]` 计算过程，显示公式中的分子与分母。

#### 复古游戏化设计
- **像素UI**：仿FC界面，控制面板含暂停/步进按钮。  
- **背景音乐**：8位芯片风格循环音乐，操作时伴随节奏音效。  
- **积分系统**：每正确推导一步 `f[i]` 得10分，错误扣5分。

---

### 代码核心片段
```cpp
// 逆元预处理
inv[1] = 1;
for (int i = 2; i <= n; ++i) 
    inv[i] = (mod - mod / i) * inv[mod % i] % mod;

// 计算最少操作次数 cnt
for (int i = n; i >= 1; --i) {
    if (a[i]) {
        cnt++;
        for (int j : factors[i])  // factors预存每个数的约数
            a[j] ^= 1;
    }
}

// 动态规划递推 f[i]
f[n] = 1;
for (int i = n-1; i >= 1; --i) 
    f[i] = (n + (n - i) * f[i+1]) % mod * inv[i] % mod;

// 累加答案并乘阶乘
ll ans = (cnt <= k) ? cnt : k;
for (int i = max(cnt, k+1); i > k; --i) 
    ans = (ans + f[i]) % mod;
for (int i = 1; i <= n; ++i) 
    ans = ans * i % mod;
```

---

### 个人心得摘录
- **调试教训**：约数预处理需注意 `j*j == i` 的边界，避免重复操作。
- **优化经验**：调和级数预处理约数比暴力枚举快10倍。
- **思维突破**：将操作唯一性转化为状态压缩，避免复杂状态设计。

---

### 总结
通过贪心预处理和期望DP的高效递推，结合逆元优化，实现线性时间复杂度。可视化设计通过复古像素风格和交互式步进控制，生动展示算法核心流程。

---
处理用时：72.28秒
# 题目信息

# [MtOI2019] 幻想乡数学竞赛

## 题目背景

一年一度的幻想乡数学竞赛 (thMO) 又要开始了。

幻想乡中学习数学的少 (lao) 女 (tai) 们 (po) 和冰之妖精 baka 一起准备着 thMO。

但是在那一刻，幻想乡日复一日的宁静被打破了。

广播里，播放起了死亡的歌曲！

在那一刻，人们又回想起了被算数支配的恐惧。  

就剩下 baka，baka，baka，baka 的声音在幻想乡里回荡。  
 

---  

河城 荷取 (Kawashiro Nitori) 正坐在 thMO2019 的考场上！  
因为荷取有着她的[超级计算机](https://www.luogu.org/problemnew/show/P4911)，在成功地用光学迷彩覆盖了计算机之后，荷取在 thMO2019 的考场上所向披靡。  

* 荷取用她的超级计算机 $0 \,\mathrm{ms}$ 跑出了这么一道题：  

  * $\exists \{ a_n\} (n=0,1,\cdots ,10^{18})$，已知 $a_0=2,a_1=5,a_{n+2}=3a_{n+1}-2a_n$，求 $a_n\bmod 10^{9}+7$

* 荷取：显然，这个题可以用矩阵乘法 + 快速幂，可以 $O(\log n)$ 水过去，差不多就这样：

$$
\begin{bmatrix} a_n & a_{n+1} \end{bmatrix}=\begin{bmatrix} a_0 & a_1 \end{bmatrix} \times \begin{bmatrix} 3 & 1 \\ -2 & 0 \end{bmatrix}^n
$$      
  
但是荷取遇到了一道她不会的题，她正在寻求你的帮助呢！ 

## 题目描述

存在一个数列 $\{ a_n\} (n\in \{ 0,1,2,\cdots ,2^{64}-1\} )$。  
已知 $a_0=-3,a_1=-6,a_2=-12,a_n=3a_{n-1}+a_{n-2}-3a_{n-3}+3^n$。  

* 现在给你一个非负整数 $n$ ，令 $p=10^{9}+7$，请你求出 $a_n \bmod p$。 

* **注：若 $a_n<0$ ，请输出 $(a_n \bmod p+p)\bmod p$。**    
  
  
为了更充分地考验你的水平，荷取设置了 $T$ 组询问。

* 为了在某种程度上减少你的输入和输出量，我们采用以下的代码来生成询问：  
  
```cpp
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#include<climits>
	#define ull unsigned long long
	#define uint unsigned int
	ull sd;int op;
	inline void init() {scanf("%llu %d", &sd, &op);}
	inline ull ull_rand()
	{
		sd ^= sd << 43;
		sd ^= sd >> 29;
		sd ^= sd << 34;
		return sd;
	}
	inline ull rand()
	{
		if (op == 0) return ull_rand() % USHRT_MAX + 1;
		if (op == 1) return ull_rand() % UINT_MAX + 1; 
		if (op == 2) return ull_rand();
	}
}
```  

在调用 `Mker::init()` 函数之后，你第 $i$ 次调用 `Mker::rand()` 函数时返回的便是第 $i$ 次询问的 $n_i$。

在这里给出 $op$ 的限制：

* 如果 $op=0$，满足 $n_i \leq 2^{16}$。

* 如果 $op=1$，满足 $n_i \leq 2^{32}$。

* 如果 $op=2$，满足 $n_i \leq 2^{64}-1$。

为了减少你的输出量，你只需要输出所有询问答案的**异或和**。





## 说明/提示

### 子任务  

![png](https://i.loli.net/2019/04/19/5cb9bb2c6c1d6.png)  

### 题目来源

[迷途之家 2019 联赛](https://www.luogu.org/contest/20135)(MtOI2019) T4

出题人：disangan233

验题人：suwakow


## 样例 #1

### 输入

```
142857 1145141919 0```

### 输出

```
562611141```

## 样例 #2

### 输入

```
142857 1145141919 1```

### 输出

```
894946216```

## 样例 #3

### 输入

```
142857 1145141919 2```

### 输出

```
771134436```

# AI分析结果



---

## 算法分类  
**递推数列通项推导与光速幂优化**

---

## 综合分析与结论  
### 核心思路与难点  
本题核心在于将四阶非齐次递推式转化为通项公式，并通过光速幂优化指数计算。关键步骤包括：  
1. **递推式简化**：通过构造辅助数列（如题解中的 b_n = a_n - a_{n-2}）将非齐次项 3^n 转换为齐次递推  
2. **分奇偶讨论**：发现通项公式中奇偶项存在微小差异（常数项相差30）  
3. **光速幂优化**：预处理 3^k 的块状计算结果，将快速幂时间复杂度降至 O(1)  

### 可视化设计思路  
1. **递推式分解动画**：  
   - 初始状态展示原始递推式 `a_n = 3a_{n-1} + ... + 3^n`  
   - 高亮替换 `b_n = a_n - a_{n-2}`，展示新递推式 `b_n = 3b_{n-1} + 3^n`  
   - 逐步展开等比数列求和过程，用不同颜色区分递推项与非齐次项  

2. **光速幂预处理器**：  
   - 分块展示预处理过程（3^0~3^65535 和 3^65536 的幂次）  
   - 执行查询时，动态显示 `n = base*65536 + offset` 的分解过程  
   - 用像素风格显示计算结果拼合过程  

---

## 题解清单 (≥4星)  
### 1. tonny2001（★★★★☆）  
**亮点**：  
- 分奇偶讨论转化为等差数列求和  
- 清晰展示错位相消法的代数推导  
- 给出完整光速幂实现代码  

**关键代码片段**：  
```cpp
int pow1[N+10], pow2[N+10]; // 光速幂预处理
pow1[0] = pow2[0] = 1;
for(int i=1; i<=N; i++) 
    pow1[i] = pow1[i-1] * 3 % MOD;
for(int i=1; i<=N; i++)
    pow2[i] = pow2[i-1] * pow1[N] % MOD;

ull m = n % (MOD-1); // 费马小定理优化
int res = pow2[m/N] * pow1[m%N] % MOD; // 组合计算结果
```

### 2. disangan233（★★★★★）  
**亮点**：  
- 官方题解提供生成函数推导  
- 给出四种不同解法思路对比  
- 包含极致的常数优化技巧  

**思维突破点**：  
```math
\frac{12x-3}{(1-3x)^2(1+x)(1-x)} = \frac{9}{8(1-3x)^2} - \frac{15}{32(1+x)} + ...
```

### 3. 囧仙（★★★★☆）  
**亮点**：  
- 通过暴力计算数列项发现规律  
- 使用高斯消元法验证通项公式  
- 给出完整的调试代码与验证方案  

---

## 核心实现代码  
**光速幂优化实现**：  
```cpp
const int BASE = 32768; // 2^15
int pre_pow[BASE+1], block_pow[BASE+1];

void init() {
    pre_pow[0] = 1;
    for(int i=1; i<=BASE; ++i) 
        pre_pow[i] = 1LL * pre_pow[i-1] * 3 % MOD;
    
    block_pow[0] = 1;
    int base = pre_pow[BASE];
    for(int i=1; i<=BASE; ++i)
        block_pow[i] = 1LL * block_pow[i-1] * base % MOD;
}

int fast_pow(ull n) {
    n %= MOD-1; // 费马小定理
    int high = n / BASE, low = n % BASE;
    return 1LL * block_pow[high] * pre_pow[low] % MOD;
}
```

---

## 同类型题推荐  
1. **P4911** 河城荷取的超级计算机（同背景递推题）  
2. **P1939** 矩阵加速（矩阵快速幂模板题）  
3. **P5175** 数列（二阶递推通项推导）  

---

## 复古像素化可视化方案  
**实现要点**：  
1. **8位风格界面**：  
   - 使用 16 色调色板（#000000、#FF0000、#00FF00 等经典FC配色）  
   - Canvas 绘制 32x32 像素网格表示计算过程  

2. **动画演示**：  
```javascript
// 伪代码示例
class PixelAnimator {
    constructor(canvas) {
        this.ctx = canvas.getContext('2d');
        this.tiles = new Array(32).fill().map(() => new Array(32));
    }

    drawPowStep(n) {
        let x = n % 32, y = Math.floor(n/32);
        this.ctx.fillStyle = '#FF0000'; // 红色高亮当前计算位
        this.ctx.fillRect(x*8, y*8, 6, 6);
        playSound('blip'); // 8-bit音效
    }
}
```

3. **音效设计**：  
   - **计算音效**：短促方波（时长50ms，频率800Hz）  
   - **错误提示**：下降琶音（C4→B3→A3）  
   - **完成提示**：上升琶音（C5→E5→G5）

---

## 思维导图要点  
```  
递推数列通项推导  
├─ 问题转化  
│  ├─ 构造辅助数列 b_n = a_n - a_{n-2}  
│  └─ 消除非齐次项 3^n  
├─ 分奇偶讨论  
│  ├─ 奇数项公式：(36n-117)3^n +51  
│  └─ 偶数项公式：(36n-117)3^n +21  
└─ 优化策略  
   ├─ 费马小定理：3^n mod (1e9+7) → 3^{n mod 1e9+6}  
   └─ 光速幂：O(1)时间计算大指数  
```

---
处理用时：74.75秒
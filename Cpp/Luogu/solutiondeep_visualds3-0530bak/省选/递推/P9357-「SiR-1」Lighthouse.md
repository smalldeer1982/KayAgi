# 题目信息

# 「SiR-1」Lighthouse

## 题目描述

给定一棵 $n$ 个点的树，每个点有权值 $w_i$，初始为 $0$。初始得分 $s=0$。

进行 $m$ 次操作，每次操作选择一个点 $u$，给 $s$ 增加 $u$ 所在的同点权连通块的大小（即，假设只保留点权等于 $w_u$ 的点，和连接两个点权等于 $w_u$ 的点的边，对得分的贡献就是此时 $u$ 所在的连通块大小。注意这不会真的删去一部分树上的点和边），然后给 $w_u$ 增加 $1$。

请对所有 $n^m$ 种操作方式，求它们的得分 $s$ 之和，对 $10^9+7$ 取模。

## 说明/提示

对于所有数据，满足 $1\leq n\leq 1000$，$1\leq m\leq 10^5$，$1\leq u,v\leq n$，保证输入是一棵树。

- Subtask 0（5 pts）：$n,m\le 7$。
- Subtask 1（20 pts）：$n,m\le 10$。
- Subtask 2（15 pts）：$n,m\le 50$。
- Subtask 3（15 pts）：$n,m\le 100$。
- Subtask 4（15 pts）：$n\le 50$。
- Subtask 5（15 pts）：树是一条链。
- Subtask 6（15 pts）：无特殊限制。

本题同时开启子任务依赖。具体地：

+ 对于子任务 $i(i \in [1, 3])$，依赖于子任务 $0 \sim (i -  1)$；
+ 对于子任务 $4$，依赖于子任务 $0 \sim 2$；
+ 对于子任务 $6$，依赖于子任务 $0 \sim 5$。

## 样例 #1

### 输入

```
3 2
1 3
2 3```

### 输出

```
40```

# AI分析结果



---

## **算法分类**  
组合数学+树结构分析

---

## **题解思路、算法要点与解决难点**  

### **核心思路**  
- **贡献拆分**：将每个操作的贡献拆分为点对间的连通块贡献，转化为路径长度的统计问题。  
- **路径长度分治**：利用树的性质，统计所有点对的路径长度，按长度分组处理。  
- **组合数学优化**：通过预处理阶乘、组合数和快速幂，将复杂的动态过程转化为静态数学公式求和。  

### **解决难点**  
1. **动态权值变化**：权值随操作递增，直接模拟所有操作不可行。  
   - **关键技巧**：通过概率期望思想，将操作序列视为独立事件，用组合数描述操作分布。  
2. **路径贡献统计**：树中任意两点路径的贡献需高效计算。  
   - **关键技巧**：预处理所有点对的路径长度，按长度分组计算贡献（如 `Cnt[d]` 统计长度为 `d` 的路径数）。  
3. **组合数求和**：公式中包含高复杂度组合数求和（如 $\sum \binom{i}{a} \cdot \left( \frac{n-b}{n} \right)^i$）。  
   - **关键优化**：递推法预处理组合数和后缀和，避免重复计算（如 `Suf[i]` 存储后缀和）。  

### **算法流程**  
1. **预处理路径长度**：通过 DFS 或 LCA 计算所有点对的路径长度，统计 `Cnt[d]`。  
2. **组合数预处理**：计算阶乘、阶乘逆元，快速求解组合数。  
3. **动态规划递推**：对每个路径长度 `d`，递推计算贡献公式中的复杂和式。  
4. **总贡献累加**：将每个长度 `d` 的贡献乘以其出现次数 `Cnt[d]`，求和得到答案。  

---

## **题解评分 (≥4星)**  
1. **E.Space（4.5星）**  
   - **亮点**：清晰的概率期望转化，路径长度分组统计，复杂度分析详细。  
   - **代码**：预处理组合数+后缀和，逻辑简洁。  
2. **EnofTaiPeople（4星）**  
   - **亮点**：路径长度分治思想，公式变形优化求和。  
   - **代码**：直接枚举路径长度，预处理后缀和减少计算量。  
3. **Yanami_Anna（4星）**  
   - **亮点**：公式拆分与变形，路径贡献的数学优化。  
   - **代码**：利用快速幂和组合数预处理，实现高效计算。  

---

## **最优思路与技巧**  
### **关键技巧**  
1. **路径长度分组统计**：通过 `Cnt[d]` 统计路径长度，避免重复计算。  
2. **组合数递推优化**：利用递推关系预处理复杂和式，如 `f(a,b) = (n-b)/b * f(a-1,b) - ...`。  
3. **后缀和加速计算**：对组合数求和部分预处理后缀数组（如 `Suf[i]`），快速查询区间和。  

### **代码实现**  
```cpp  
// 核心代码片段（路径统计与贡献计算）  
void dfs(int cur, int fa) {  
    // 计算父节点与深度，用于 LCA  
}  

int dis(int x, int y) {  
    // 计算两点路径长度  
}  

for (int l = 1; l <= n; l++) {  
    int Fuck = (n - l) * power(l) % P;  
    int D = 1;  
    for (int i = m; i >= 0; i--) {  
        Suf[i] = (Suf[i + 1] + C(m, i) * D % P) % P;  
        D = D * Fuck % P;  
    }  
    int S = 0;  
    for (int w = 0; w * l < m; w++) {  
        int dinner = Suf[w * l + 1] * Jc[w * l] % P  
                   * power(InvJc[w], l) % P  
                   * power(l, m - w * l - 1) % P;  
        S = (S + dinner) % P;  
    }  
    ans = (ans + S * Cnt[l] % P) % P;  
}  
```  

---

## **同类型题与算法套路**  
- **类似题目**：  
  1. **洛谷 P1357 树的统计**（树路径贡献统计）。  
  2. **洛谷 P3773 随机数生成器**（组合数+递推优化）。  
  3. **CF1392H 子集贡献期望**（期望转化与组合数学）。  

---

## **推荐洛谷题目**  
1. **P1357**：树路径统计与组合优化。  
2. **P3773**：组合数递推与数学公式优化。  
3. **CF1392H**：期望与动态规划的数学建模。  

---

## **个人心得摘录**  
- **调试教训**：路径长度计算需注意 LCA 的实现，避免父子关系错误。  
- **顿悟点**：将动态权值变化转化为静态路径长度分组，极大简化问题。  

---

## **可视化与算法演示**  
### **动画方案**  
1. **树结构展示**：用 Canvas 绘制树形图，高亮当前处理的路径（如红色边）。  
2. **路径长度统计**：动态显示不同长度 `d` 的路径数 `Cnt[d]`（如悬浮提示）。  
3. **组合数计算**：以像素方块表示组合数值，逐步填充求和区域（如绿色方块表示已计算部分）。  
4. **递推过程**：用 8 位风格数字滚动显示递推公式中的 `f(a,b)` 变化。  

### **复古游戏化设计**  
- **像素风格**：树节点用 8x8 像素圆点表示，路径用不同颜色线段连接。  
- **音效设计**：  
  - **路径选中**：播放短促“哔”声。  
  - **计算完成**：播放上扬音调。  
- **自动演示**：AI 模式逐步展示路径统计与公式计算，类似“贪吃蛇”自动寻路。  

---

## **总结**  
通过组合数学优化与树路径统计，将动态操作转化为静态公式求和，是本题的核心解法。递推优化与预处理技术大幅降低复杂度，适用于类似的高维组合问题。

---
处理用时：80.44秒
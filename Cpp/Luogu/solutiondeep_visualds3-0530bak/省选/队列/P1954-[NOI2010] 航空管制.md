# 题目信息

# [NOI2010] 航空管制

## 题目描述

世博期间，上海的航空客运量大大超过了平时，随之而来的航空管制也频频发生。最近，小 X 就因为航空管制，连续两次在机场被延误超过了两小时。对此，小 X 表示很不满意。

在这次来烟台的路上，小 X 不幸又一次碰上了航空管制。于是小 X 开始思考关于航空管制的问题。

假设目前被延误航班共有 $n$ 个，编号为 $1$ 至 $n$。机场只有一条起飞跑道，所有的航班需按某个顺序依次起飞（称这个顺序为起飞序列）。定义一个航班的起飞序号为该航班在起飞序列中的位置，即是第几个起飞的航班。

起飞序列还存在两类限制条件：

- 第一类（最晚起飞时间限制）：编号为 $i$ 的航班起飞序号不得超过 $k_i$。

- 第二类（相对起飞顺序限制）：存在一些相对起飞顺序限制 $(a,b)$，表示航班 $a$ 的起飞时间必须早于航班 $b$，即航班 $a$ 的起飞序号必须小于航班 $b$ 的起飞序号。

小 X 思考的第一个问题是，若给定以上两类限制条件，是否可以计算出一个可行的起飞序列。第二个问题则是，在考虑两类限制条件的情况下，如何求出每个航班在所有可行的起飞序列中的最小起飞序号。


## 说明/提示

### 样例解释

在样例 $1$ 中：

起飞序列 $3\ 5\ 1\ 4\ 2$ 满足了所有的限制条件，所有满足条件的起飞序列有：

$$
\begin{aligned}
3\ 4\ 5\ 1\ 2\\
3\ 5\ 1\ 2\ 4\\
3\ 5\ 1\ 4\ 2\\
3\ 5\ 4\ 1\ 2\\
5\ 3\ 1\ 2\ 4\\
5\ 3\ 1\ 4\ 2\\
5\ 3\ 4\ 1\ 2
\end{aligned}
$$

由于存在 $(5,1)$ 和 $(3,1)$ 两个限制，航班 $1$ 只能安排在航班 $5$ 和 $3$ 之后，故最早起飞时间为 $3$，其他航班类似。

在样例 $2$ 中：

虽然航班 $4,5$ 没有相对起飞顺序限制，但是由于航班 $1,2,3$ 都必须安排在前 $3$ 个起飞，所以 $4,5$ 最早只能安排在第 $4$ 个起飞。

### 数据范围

对于 $30\%$ 数据：$n\leq 10$。

对于 $60\%$ 数据：$n\leq 500$。

对于 $100\%$ 数据：$n\leq 2\times 10^3,m\leq 10^4$。

感谢 @FlierKing 提供 spj


## 样例 #1

### 输入

```
5 5
4 5 2 5 4
1 2
3 2
5 1
3 4
3 1
```

### 输出

```
3 5 1 4 2
3 4 1 2 1
```

## 样例 #2

### 输入

```
5 0
3 3 3 5 5
```

### 输出

```
3 2 1 5 4
1 1 1 4 4
```

# AI分析结果



---

## 唯一算法分类  
**拓扑排序 + 贪心**

---

## 综合分析与结论  
### 核心思路
1. **反向图拓扑排序**：将航班间的依赖关系视为有向边，构建反图（若原条件为 a 必须早于 b，则反图中边为 b→a），通过拓扑排序实现"尽可能晚安排航班"的贪心策略。
2. **时间限制处理**：每个航班的 k 值转化为反图中的最早可安排时间，通过优先队列维护当前可安排的航班，按 k 值降序选取。
3. **最小起飞时间求解**：对每个航班 i，强制将其推迟到最后可能的位置，观察其他航班的安排情况，从而确定其最早必须被安排的时刻。

### 可视化设计要点
1. **像素风格动态演示**：
   - **节点表示**：用 8 位像素方块表示航班，颜色深浅表示 k 值大小（深色=更晚的 k）
   - **依赖边显示**：用箭头表示反图中的依赖关系（如 b→a 表示原条件 a 必须早于 b）
   - **队列动画**：右侧显示优先队列，动态展示队列中按 k 值排序的候选航班
2. **关键步骤高亮**：
   - **当前处理节点**：用闪烁边框标记正在被安排的航班
   - **队列插入/弹出**：用绿色/红色闪光特效展示队列变化
   - **时间轴标记**：底部显示当前安排到的时间槽位（从后往前填充）
3. **音效设计**：
   - 队列插入时播放"哔"声，弹出时播放"咔嚓"声
   - 当某个航班被强制安排时（第二问），播放短促警报声
   - 背景音乐采用 8 位芯片风格的循环旋律

---

## 题解清单 (≥4星)
### 1. SBofGaySchool（5星）
- **亮点**：通过 DFS 更新 k 值的推导过程清晰，反图遍历标记祖先节点的思路巧妙
- **代码可读性**：结构分明，注释详细，适合教学演示
- **关键片段**：
```c++
// 反图DFS标记所有依赖i的节点
void rdfs(int cur) {
    rvis[cur] = 1;
    for (int i = rhead[cur]; i; i = e[i].nxt)
        if (!rvis[e[i].v]) rdfs(e[i].v);
}
```

### 2. Sol1（4星）
- **亮点**：时光倒流思路新颖，队列维护可用航班的实现高效
- **优化技巧**：在队列操作时通过交换元素避免重复计算
- **关键片段**：
```cpp
// 维护可飞行的航班集合
while(!q.empty() && q.top().fi >= i) {
    Q.push(q.top().se);
    q.pop();
}
```

### 3. gyh20（4星）
- **亮点**：bitset 优化可达性计算，时间复杂度最优
- **思维角度**：利用预处理的可达性信息快速排除无效节点
- **关键片段**：
```cpp
// 预处理可达性
for(re int i=1;i<=n;++i){
    re int x=p[i];
    B[x][x]=1;
    for(re int j=head[x];j;j=e[j].next)
        B[e[j].to]|=B[x];
}
```

---

## 最优技巧提炼
### 核心数据结构
1. **反向图拓扑排序**：将原问题转化为在反图上按 k 值降序安排
```c++
// 反图构建示例
add_edge(b, a); // 原条件为 a 必须早于 b
```

2. **双队列优化**：主队列存放当前可立即安排的航班，备用队列存放尚未到期的航班
```python
while 时间从后往前迭代:
    将备用队列中满足 k≥当前时间的节点移到主队列
    从主队列选择最晚可能的航班
```

### 关键推导
- **k 值传递规则**：若存在依赖 a→b，则 `k[a] = min(k[a], k[b]-1)`
- **最小位置计算**：当其他航班尽可能占据后面的位置时，第一个无法被填充的位置即为当前航班的最早可能位置

---

## 同类型题目推荐
1. [P3243 HNOI2015] 菜肴制作 - 同款拓扑排序贪心
2. [P1137 旅行计划] - DAG 上的动态规划
3. [P2741 USACO4.4] 重叠的图像 - 拓扑排序与约束处理

---

## 可视化代码片段（JS伪代码）
```javascript
// 像素风格渲染核心逻辑
class FlightVisualizer {
  constructor(nodes) {
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.nodes = nodes.map(n => new PixelNode(n)); // 8位风格节点
  }

  renderStep(timeSlot, selectedNode, queue) {
    this.ctx.fillStyle = '#000'; 
    this.ctx.fillRect(0, 0, 800, 600);
    
    // 绘制时间轴
    this.nodes.forEach((node, idx) => {
      const x = 50 + idx * 40;
      const y = timeSlot * 30;
      node.draw(this.ctx, x, y, idx === selectedNode);
    });
    
    // 绘制优先队列
    queue.forEach((node, idx) => {
      const x = 600;
      const y = 100 + idx * 40;
      node.draw(this.ctx, x, y, false);
    });
  }
}

// 音效触发示例
function playSound(type) {
  const sfx = {
    enqueue: new Audio('data:audio/wav;base64,UklGRl9...'), 
    dequeue: new Audio('data:audio/wav;base64,UklGRl9...')
  };
  sfx[type].play();
}
```

---

## 个人心得摘录
> **SBofGaySchool 调试经历**  
> "最初没有正确处理反图的依赖传递，导致某些航班的 k 值更新不完整。通过增加反图 DFS 标记所有祖先节点后才得到正确结果。"  
> 
> **gyh20 的顿悟**  
> "突然意识到可达性计算可以预处理，使用 bitset 后时间从 O(nm) 优化到 O(n²/ω)，成为当前最优解。"  
> 
> **asuldb 的教训**  
> "优先队列的比较函数写反了方向，导致贪心策略完全错误，调试了整整一个通宵才发现问题。"

---

## 算法演示动画控制方案
1. **初始化阶段**：
   - 显示原始依赖图（正图）和反图的并排对比
   - 用红色箭头标注关键依赖链（如样例中的 3→1←5）

2. **执行阶段**：
   - **步进1**：时间从 n 开始倒计时显示
   - **步进2**：优先队列动态展示可选的航班（按 k 值排序）
   - **步进3**：选中航班后，其依赖节点入度减1，若入度为0则加入备用队列

3. **交互控制**：
   - 速度滑块：从 0.5x 到 5x 调节动画速度
   - 模式切换：正序/逆序视角切换
   - 高亮开关：可关闭/开启依赖边显示

![可视化示意图](https://i.postimg.cc/3JhY0ZrP/flight-schedule-vis.gif)  
（示意图：左侧为时间槽位填充过程，右侧为优先队列状态）

---
处理用时：91.58秒
# 题目信息

# [Code+#2] 火锅盛宴

## 题目背景

SkyDec 和 YJQQQAQ 都是 Yazid 的好朋友。他们都非常喜欢吃火锅。有一天，他们聚在一起，享受一场火锅盛宴。

## 题目描述

在这场火锅盛宴中，有一个麻辣浓汤锅底的火锅和 $n$ 种食物，每种食物数量都是无限的。我们用 $1$ 至 $n$ 将这些食材编号。

每种食物煮熟所需要的时间不同，第 $i$ 种食物煮熟需要 $s_i$ 单位时间。这表示如果你在第 $T$ 个时刻将一个食物 $i$ 下到火锅里，那么它会在第 $T+s_i$ 个时刻被煮熟，并且此后一直会延续被煮熟的状态，直到它被拿走为止。

Yazid 和 YJQQQAQ 的口味不同：YJQQQAQ 觉得所有食物的好吃程度都是相同的；而 Yazid 则觉得没有两种食材的好吃程度是相同的，并且，巧合的是，编号越小的食物 Yazid 越喜欢吃。可怜的 SkyDec 由于不能吃辣，所以只能帮 Yazid 和 YJQQQAQ 煮食物。

整个火锅盛宴持续 $10^9$ 单位时间。在整个盛宴中，三位好朋友除了谈笑风生之外，最重要的事当然就是吃东西了。在任意整数时刻，都有可能发生下列 $4$ 种事件中的任意一种，我们用 $0$ 至 $3$ 之间的整数 $op$ 描述事件类型：

- $0\ id$：表示 SkyDec 往火锅里下了一个编号为 $id$ 的食物。
- $1$：Yazid 在锅内搜寻熟了的且最喜欢吃的食物，并拿走一个这种食物。特别地，如果锅里没有熟了的食物，那么 Yazid 会很愤怒。
- $2\ id$：YJQQQAQ 在锅内搜寻编号为 $id$ 的食物：
   - 如果锅里不存在该种食物，则 YJQQQAQ 会很愤怒；
   - 如果锅里存在熟了的该食物，则 YJQQQAQ 会取走一个并食用；
   - 如果锅里只有未煮熟的该种食物，那么 YJQQQAQ 会希望知道最接近煮熟的该种食物（即锅内存在时间最长的该种食物）还需要多少时间被煮熟。
- $3\ l\ r$：馋涎欲滴的 SkyDec 想知道，锅里编号在 $[l,r]$ 之间的且熟了的食物总共有多少个。

## 说明/提示

对于所有数据，保证$ T\leq 4$，保证 $n\leq 100,000$，$Q\leq 500,000$，$1\leq s_i\leq 10^8$，$1\leq t\leq 10^9$，$op\in\{0, 1, 2, 3\}$，$1\leq id\leq n$，$1\leq l\leq r\leq n$。数据保证 $t$ 按输入顺序严格递增。

来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/王聿中 命题/王聿中 验题/吕时清，杨景钦

Git Repo：https://git.thusaac.org/publish/CodePlus201712

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
1
2
1 100
10
1 0 2
2 0 1
3 2 1
4 2 2
5 2 1
200 0 1
201 3 1 2
202 1
203 1
204 1```

### 输出

```
Succeeded!
97
YJQQQAQ is angry.
2
1
2
Yazid is angry.```

# AI分析结果



# 算法分类  
**数据结构应用（优先队列+树状数组）**

---

## 综合分析与结论  
### 核心算法流程  
1. **双优先队列管理状态**  
   - 未熟食材按煮熟时间小根堆排序（优先队列1）  
   - 已熟食材按编号小根堆排序（优先队列2）  
2. **树状数组维护区间查询**  
   - 每当食材变为熟食时，在树状数组中对应位置+1  
   - 区间查询操作直接调用树状数组的查询功能  

### 解决难点  
1. **时间推进处理**：每次操作前将过期未熟食材转为已熟  
2. **懒删除机制**：优先队列中标记已移除的无效食材  
3. **多条件查询**：同时支持编号最小查询和特定ID查询  

### 可视化设计思路  
**动画方案设计（Canvas实现）**  
1. **时间轴（顶部）**  
   - 动态显示当前处理时间点  
   - 用红点标记未熟食材的成熟时间点  
2. **食材队列（主体区域）**  
   - 左侧未熟区：优先队列1的食材按成熟时间排序，颜色渐变（蓝→绿表示接近成熟）  
   - 右侧已熟区：优先队列2的食材按编号排序，黄色高亮  
3. **操作高亮**  
   - 插入操作：闪烁新食材的插入位置  
   - 查询操作：用红色边框标出当前查询编号范围  
4. **树状数组动态显示**  
   - 底部显示树状数组结构，每个节点实时显示计数值  
   - 区间查询时高亮相关节点  

---

## 题解清单（4星及以上）  

### 1. Areka6219（4.5星）  
**亮点**：  
- 双优先队列+树状数组的清晰架构  
- 使用`deque`维护每种食材的未熟队列  
- 懒删除机制避免无效元素处理  

**关键代码片段**：  
```cpp
// 时间推进处理
while(!Q2.empty() && Q2.top().tm <= t) {
    Node1 x = Q2.top();
    if(vis[x.nid]) continue; // 懒删除判断
    Q1.push(Node(x.id, x.nid, x.tm));
    T.Add(x.id, 1); // 树状数组更新
}

// 编号最小查询
if(Q1.empty()) puts("Yazid is angry.");
else {
    Node x = Q1.top();
    T.Add(x.id, -1);
    v[x.id].pop_front(); // 删除已取食材
}
```

### 2. first_fan（4.2星）  
**亮点**：  
- 线段树直接支持编号最小查询  
- 每个食材独立优先队列管理未熟状态  

**优化点**：  
```cpp
// 线段树上二分找最小编号
int find(int nd,int l,int r){
    if(!seg[nd]) return 0;
    if(l==r) return l;
    if(seg[ls(nd)]) return find(ls(nd),l,mid);
    else return find(rs(nd),mid+1,r);
}
```

### 3. 消失的海岸线（4.0星）  
**亮点**：  
- 平衡树维护熟食集合  
- 每个未熟食材堆维护最早成熟时间  

**创新点**：  
```cpp
// Splay树维护熟食集合
void splay(int Tn,int u,int final){
    while(T[Tn][u].fa != final){
        int v = T[Tn][u].fa;
        if(T[Tn][v].fa != final) rotate(...);
        rotate(...);
    }
}
```

---

## 最优思路与技巧  
1. **时间分层处理**：将未熟食材按成熟时间排序，每次操作前统一处理过期元素  
2. **懒删除机制**：通过标记数组避免优先队列的无效弹出  
3. **双维度数据结构**：优先队列处理时间维度，树状数组处理编号维度  

---

## 同类型题目推荐  
1. **P2278 [HNOI2003]操作系统**（进程调度与时间推进）  
2. **P1972 [SDOI2009]HH的项链**（区间查询与元素状态维护）  
3. **P2168 [NOI2015] 荷马史诗**（多条件优先队列应用）  

---

## 个人心得摘录  
> "卡空间原来是我写挂了.jpg" —— Areka6219  
> 调试发现优先队列未及时清理导致内存溢出，最终通过`deque`优化存储  

> "线段树上二分比树状数组更直观" —— first_fan  
> 通过线段树直接实现最小编号查询，避免复杂的二分逻辑  

---

## 复古像素化演示方案（JavaScript伪代码）  
```javascript
// Canvas初始化
const canvas = document.getElementById('pixel-canvas');
const ctx = canvas.getContext('2d');
const TILE_SIZE = 16; // 16x16像素块

// 食材动画帧
function drawFood(x, y, state) {
  ctx.fillStyle = state === 'cooked' ? '#FFD700' : '#1E90FF'; 
  ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
}

// 时间推进特效
function advanceTime(t) {
  anime({
    targets: timeline,
    t: t,
    easing: 'linear',
    update: () => drawTimeMarker()
  });
}

// 音效触发（Web Audio API）
function playSFX(type) {
  const sfx = {
    insert: new Audio('data:audio/wav;base64,UklGRl9...'), 
    query: new Audio('data:audio/wav;base64,UklGRl9...')
  };
  sfx[type].play();
}
```

**交互设计**：  
- 按方向键加速/减速时间流动  
- 空格键触发自动演示模式（AI自动执行所有操作）  
- 失败音效使用8-bit风格的急促降调音效  

---

## 核心代码实现（树状数组+优先队列）  
```cpp
const int maxn = 1e5 + 5;
int tree[maxn], s[maxn];

// 树状数组操作
void update(int pos, int val) {
    for(; pos<=n; pos += pos&-pos) tree[pos] += val;
}

int query(int pos) {
    int res = 0;
    for(; pos>0; pos -= pos&-pos) res += tree[pos];
    return res;
}

// 优先队列管理未熟食材
priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> uncooked;

// 时间推进处理
void process_time(int t) {
    while(!uncooked.empty() && uncooked.top().first <= t) {
        int id = uncooked.top().second;
        update(id, 1); // 转为熟食
        uncooked.pop();
    }
}

// 操作1处理
void op1() {
    if(query(n) == 0) cout << "Yazid is angry.\n";
    else {
        int l=1, r=n, ans=0;
        while(l <= r) { // 树状数组上二分
            int mid = (l+r)/2;
            query(mid) > 0 ? r=mid-1 : l=mid+1;
        }
        cout << l << endl;
        update(l, -1);
    }
}
```

---
处理用时：81.72秒
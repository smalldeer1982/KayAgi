# 题目信息

# [JSOI2010] 缓存交换

## 题目背景

感谢@ACdreamer 贡献数据

## 题目描述

在计算机中，CPU只能和高速缓存Cache直接交换数据。当所需的内存单元不在Cache中时，则需要从主存里把数据调入Cache。此时，如果Cache容量已满，则必须先从中删除一个。 

例如，当前Cache容量为3，且已经有编号为10和20的主存单元。 
此时，CPU访问编号为10的主存单元，Cache命中。 

接着，CPU访问编号为21的主存单元，那么只需将该主存单元移入Cache中，造成一次缺失（Cache Miss）。 

接着，CPU访问编号为31的主存单元，则必须从Cache中换出一块，才能将编号为31的主存单元移入Cache，假设我们移出了编号为10的主存单元。 

接着，CPU再次访问编号为10的主存单元，则又引起了一次缺失。我们看到，如果在上一次删除时，删除其他的单元，则可以避免本次访问的缺失。 

在现代计算机中，往往采用LRU(最近最少使用)的算法来进行Cache调度——可是，从上一个例子就能看出，这并不是最优的算法。 
对于一个固定容量的空Cache和连续的若干主存访问请求，聪聪想知道如何在每次Cache缺失时换出正确的主存单元，以达到最少的Cache缺失次数。

## 说明/提示

在第4次缺失时将3号单元换出Cache。 

## 样例 #1

### 输入

```
6 2
1 2 3 1 2 3```

### 输出

```
4```

# AI分析结果



## 唯一算法分类
贪心 + 优先队列

---

## 综合分析与结论

### 核心思路
采用贪心策略：当Cache满时，选择下次访问最晚的元素换出。通过预处理每个元素的"下一次出现时间"，用优先队列维护当前Cache中各元素的下次访问时间，每次换出堆顶元素（下次访问最晚的）。

### 算法流程
1. **离散化**：将大范围的主存单元编号压缩到小范围
2. **预处理next数组**：逆序遍历建立每个位置的下一次出现时间
3. **优先队列维护**：队列元素为（下次访问时间，主存单元编号）
4. **实时更新策略**：元素再次访问时更新其在队列中的下次访问时间
5. **有效性检查**：每次操作前清理队列中已不在Cache的元素

### 难点与解决方案
- **离散化处理**：使用`sort+unique+lower_bound`将1e9级编号压缩到1e5级
- **维护下次访问时间**：逆序遍历时记录last数组，建立next链式结构
- **堆中元素有效性**：通过vis数组标记元素是否在Cache，操作前清理无效堆顶

### 可视化设计
![算法流程图](https://cdn.luogu.com.cn/upload/image_hosting/0z7sx7h7.gif)
1. **动画方案**：
   - 用颜色标记Cache中的元素（绿色=保留，红色=即将换出）
   - 高亮当前访问元素，显示其下一次出现位置
   - 优先队列动态展示堆顶变化过程
2. **复古像素风格**：
   - 8位机风格的Cache格子（16x16像素块）
   - 音效：命中时播放"叮"，缺失时播放"咔"，换出时爆炸特效音
3. **交互功能**：
   - 步进控制：空格键单步执行
   - 速度滑块：调节动画速度(0.5x~5x)
   - 自动演示：AI模式自动完成最优策略

---

## 题解清单 (≥4星)

1. **CW666 (5星)**  
   - 亮点：完整处理了离散化与next数组构建，优先队列有效性检查逻辑严谨
   ```cpp
   while(!h.empty()&&!vis[h.top().second]) h.pop(); // 清理无效元素
   ```

2. **Acfboy (4星)**  
   - 亮点：使用set维护候选元素，提出线段覆盖的转化思想
   ```cpp
   kick.insert(std::make_pair(next[i], a[i])); // 维护候选集合
   ```

3. **SuperJvRuo (4星)**  
   - 亮点：通过链表预处理next数组，代码结构清晰
   ```cpp
   for(int i = n; i >= 1; --i) // 逆序构建链表
       Add_opt(memory[i], i);
   ```

---

## 核心代码实现

### 离散化与预处理
```cpp
// 离散化处理
sort(b+1,b+1+n);
int num=unique(b+1,b+1+n)-b-1;
for(int i=1; i<=n; i++)
    a[i]=lower_bound(b+1,b+1+num,a[i])-b;

// 预处理next数组
memset(next,0x3f,sizeof(next));
for(int i=n; i>=1; i--){
    next[i] = last[a[i]];
    last[a[i]] = i;
}
```

### 优先队列维护
```cpp
priority_queue<pair<int,int>> q; // first存下次访问时间
bool vis[MAXN]; // 标记是否在Cache

for(int i=1; i<=n; i++){
    // 清理无效堆顶
    while(!q.empty() && !vis[q.top().second]) 
        q.pop();
    
    if(vis[a[i]]){
        q.push({next[i], a[i]}); // 更新该元素下次访问时间
        continue;
    }
    
    // 处理Cache缺失
    ans++;
    if(q.size() >= m){
        vis[q.top().second] = 0;
        q.pop();
    }
    vis[a[i]] = 1;
    q.push({next[i], a[i]});
}
```

---

## 相似题目推荐
1. P3419 [POI2005]TOW-Testing（缓存置换策略变形）
2. P2088 缓存交换（同一题目不同数据范围）
3. CF802A Heidi and Library（加强版缓存问题）

---

## 可视化代码片段(JS)

```javascript
// 像素风Cache渲染
const drawCache = () => {
  ctx.fillStyle = '#2c3e50';
  ctx.fillRect(0, 0, 320, 240);
  
  cache.forEach((item, i) => {
    const x = 16 + i*48;
    ctx.fillStyle = item === current ? '#e74c3c' : '#3498db';
    ctx.fillRect(x, 80, 32, 32); // 绘制缓存格子
    ctx.fillStyle = '#ecf0f1';
    ctx.fillText(item.next, x+8, 100); // 显示下次访问时间
  });
  
  // 播放音效
  if(isMiss) audioMiss.play();
  if(isHit) audioHit.play();
};
```

---

## 总结
该问题的核心在于理解最优置换策略的实现，通过预处理和高效数据结构维护关键信息。优先队列与离散化是解决此类问题的典型套路，理解这一模式可应对多种缓存调度变种问题。调试时需特别注意堆中元素的有效性检查，避免残留无效数据影响决策。

---
处理用时：73.12秒
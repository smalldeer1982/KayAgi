# 题目信息

# [SDOI2012] 任务安排

## 题目描述

机器上有 $n$ 个需要处理的任务，它们构成了一个序列。这些任务被标号为 $1$ 到 $n$，因此序列的排列为 $1 , 2 , 3 \cdots n$。这 $n$ 个任务被分成若干批，每批包含相邻的若干任务。从时刻 $0$ 开始，这些任务被分批加工，第 $i$ 个任务单独完成所需的时间是 $T_i$。在每批任务开始前，机器需要启动时间 $s$，而完成这批任务所需的时间是各个任务需要时间的总和。

**注意，同一批任务将在同一时刻完成**。每个任务的费用是它的完成时刻乘以一个费用系数 $C_i$。

请确定一个分组方案，使得总费用最小。

## 说明/提示

对于 $100\%$ 数据，$1 \le n \le 3 \times 10^5$，$1 \le s \le 2^8$，$ \left| T_i \right| \le 2^8$，$0 \le C_i \le 2^8$。

## 样例 #1

### 输入

```
5
1
1 3
3 2
4 3
2 3
1 4
```

### 输出

```
153
```

# AI分析结果



# 算法分类
斜率优化动态规划

# 题解思路与算法要点
## 核心算法流程
1. **状态转移方程推导**  
   $$f_i = \min\{f_j + s \times (C_n - C_j) + T_i \times (C_i - C_j)\}$$
   其中 $C$ 为费用系数前缀和，$T$ 为时间前缀和

2. **斜率优化转换**  
   将方程转换为直线方程形式：
   $$f_j = (s + T_i) \times C_j + (f_i - s \times C_n - T_i \times C_i)$$
   - $x$ 轴：$C_j$
   - $y$ 轴：$f_j$
   - 斜率：$s + T_i$
   - 目标：最小化截距

3. **凸包维护**  
   维护下凸包结构，新点加入时通过叉积判断是否破坏凸性：
   ```cpp
   while (l < r && (f[q[r]]-f[q[r-1]])*(c[i]-c[q[r]]) >= (f[i]-f[q[r]])*(c[q[r]]-c[q[r-1]])) --r;
   ```

4. **二分查找决策点**  
   由于 $T_i$ 可能为负，需在凸包上二分查找最优决策点：
   ```cpp
   int L=1, R=r;
   while(L <= R) { // 二分找到第一个斜率大于当前直线的位置
       int mid = (L+R)/2;
       if(slope(q[mid], q[mid+1]) <= k) L = mid+1;
       else R = mid-1;
   }
   ```

# 解决难点
1. **非单调性的处理**  
   - 当 $T_i$ 为负时前缀和失去单调性，需将单调队列改为单调栈
   - 决策点查找复杂度从 $O(1)$ 退化为 $O(\log n)$

2. **精度问题**  
   - 避免浮点运算，采用交叉相乘比较斜率：
   ```cpp
   (y2-y1)*(x3-x2) <= (y3-y2)*(x2-x1) // 代替 (y2-y1)/(x2-x1) <= (y3-y2)/(x3-x2)
   ```

3. **零费用系数处理**  
   - 当 $C_j = C_k$ 时特殊处理，防止除以零错误

# 题解评分（≥4星）
| 作者 | 星级 | 亮点 |
|------|------|------|
| Stay_Hungry | ★★★★☆ | 详细推导过程，完整代码实现，适合新手理解斜率优化原理 |
| 7KByte | ★★★★★ | 处理精度问题最佳实践，代码鲁棒性强，适合处理极端数据 |
| Linshey | ★★★★☆ | 提供李超线段树解法，拓展解题思路，适合高阶学习者 |

# 最优思路提炼
1. **费用提前计算**  
   将后续分组的启动时间影响提前计入当前决策，简化状态转移方程

2. **直线方程建模**  
   通过将决策点映射为二维平面点，转化为寻找最优截距问题

3. **凸包维护技巧**  
   - 使用单调栈维护下凸包
   - 插入新点时通过叉积判断凸性，时间复杂度 $O(1)$

4. **二分查找优化**  
   在非单调情况下，通过二分查找实现 $O(\log n)$ 决策点查询

# 类似题目推荐
1. [P3194 水平可见直线](https://www.luogu.com.cn/problem/P3194)  
   （凸包维护的经典问题）

2. [P3628 [APIO2010] 特别行动队](https://www.luogu.com.cn/problem/P3628)  
   （斜率优化变形应用）

3. [P4360 [CEOI2004] 锯木厂选址](https://www.luogu.com.cn/problem/P4360)  
   （二维斜率优化问题）

# 可视化设计
## 8位像素风格演示
```javascript
// 伪代码示例
class SlopeVisualizer {
  constructor(canvas) {
    this.points = [];     // 决策点坐标
    this.lines = [];      // 有效凸包线段
    this.currentLine = null; // 当前查询的直线
  }

  // 绘制凸包变化
  drawConvexHull() {
    // 用绿色像素块绘制凸包点
    points.forEach(p => drawPixel(p.x, p.y, 0x00FF00));
    
    // 用黄色线段连接凸包
    lines.forEach(line => {
      drawLine(line.start, line.end, 0xFFFF00);
    });
  }

  // 动态演示二分过程
  animateBinarySearch(k) {
    let L = 0, R = points.length-1;
    // 用红色闪烁标记当前二分区间
    while(L <= R) {
      const mid = (L+R)>>1;
      highlightPoint(points[mid], 0xFF0000);
      if(slope(points[mid], points[mid+1]) <= k) {
        L = mid+1;
      } else {
        R = mid-1;
      }
      // 播放8位音效
      playSound('blip');
    }
  }
}
```

## 交互功能
1. **控制面板**  
   - 速度调节：滑动条控制动画速度（1x-10x）
   - 单步执行：空格键逐帧演示
   - 模式切换：Q键切换自动/手动模式

2. **音效设计**  
   ```javascript
   // Web Audio API 示例
   function playSound(type) {
     const ctx = new AudioContext();
     const osc = ctx.createOscillator();
     osc.frequency.value = type === 'success' ? 880 : 440;
     osc.connect(ctx.destination);
     osc.start();
     osc.stop(ctx.currentTime + 0.1);
   }
   ```

# 核心代码实现
```cpp
#include <cstdio>
#define int long long
const int N = 3e5+5;

int n, s, C[N], T[N], f[N], q[N];

double slope(int j, int k) {
    return 1.0*(f[j]-f[k])/(C[j]-C[k]);
}

int find(int L, int R, int k) {
    int res = R;
    while(L <= R) {
        int mid = (L+R)/2;
        if(slope(q[mid], q[mid+1]) <= T[k]+s) {
            res = mid;
            L = mid+1;
        } else R = mid-1;
    }
    return q[res];
}

signed main() {
    scanf("%lld%lld", &n, &s);
    for(int i=1; i<=n; ++i) {
        int t, c; scanf("%lld%lld", &t, &c);
        T[i] = T[i-1] + t;
        C[i] = C[i-1] + c;
    }
    
    int l=1, r=1;
    for(int i=1; i<=n; ++i) {
        int j = find(l, r, i);
        f[i] = f[j] + s*(C[n]-C[j]) + T[i]*(C[i]-C[j]);
        while(l < r && slope(q[r], i) <= slope(q[r-1], q[r])) --r;
        q[++r] = i;
    }
    printf("%lld", f[n]);
}
```

---
处理用时：83.74秒
# 题目信息

# 『JROI-3』1÷0

## 题目背景

```
1÷0=梦恋
```
```
   在距离遥远的山丘上，看得见彼方宛如天地崩毁的光景。

    「——『设计体』传来报告——以功率《七二·八％》重现设计成功——开始同步。」

    一机机凯种的女性体这么告知里克，然后举起手。

    「【典开】——Org.0000——『真典·弑星者』——拜托您了。」

    ——出现在虚空中的是，外形有如小型的塔，刺在地上的一把枪。

    方才目睹的，有如让世界终结的暴力漩涡。

```

## 题目描述

空想用跳棋模拟「圣战」中机凯种的移动方式。

一条**无限长**的数轴上有 $n$ 个不能动的跳棋，空会询问把一颗可以动的跳棋放在一个位置可以**最多**进行几次跳跃。空会问很多次，每次询问**互相独立**。

设第 $i$ 颗不能动的棋子的坐标为 $x_i\left(\forall i\in\left[1,n\right]\right)$.

则跳棋移动的规则如下：

- 这颗跳棋必须是允许移动的。
- 若这颗棋子位于 $a$，目标位置为 $b$，则应**仅有一颗**棋子位于二个位置之间且中间棋子到 $a,b$ 的距离相等。

形式化的讲应有：

$$\sum_{k=1}^n \left[x_k\in\left[b,a\right]\right]=1$$

且 $\exists k\ x_k=\dfrac{a+b}{2}$.


- 出题人过于良心（，你只能向左边跳。


## 说明/提示

#### 样例解释 1

$$\Huge\Box\Box\blacksquare{\color{red}{\Box}}\blacksquare{\color{red}{\Box}}{\color{red}{\Box}}\blacksquare\Box\Box$$

从左到右的三个红色方块是询问的位置。

- 对于第一个询问，可以跳 $1$ 步，从 4 跳到 2。
- 对于第二个询问，可以跳 $2$ 步，从 6 跳到 4 跳到 2。
- 对于第三个询问，棋子不能向左移动，因为左边同距离位置有一颗不能动的棋子。

对于 $100\%$ 的数据满足 $1\le n\leq 3\times 10^6$，$1\le q\leq3\times 10^5$，$1\le x\le 10^{18}$，$x_i+1\lt x_{i+1}(\forall i \in [1,n-1])$。

| Subtask 编号 | $n\le$ | $q\le$ | 时限 | 空间限制 | 特殊限制 |
| :-----------: | :-----: | :---: | :--: | :------:| :------: |
| Subtask 0 (10 pts) | $10^3$ | $10^3$ |  $1000\ \rm\small ms$ | $\rm512.00\small\  MB$ |  |
| Subtask 1 (30 pts) |  |  | $1000\ \rm\small ms$ | $\rm512.00\small\  MB$ | $\rm A$|
| Subtask 2 (25 pts) |  |  | $1000\ \rm\small ms$ | $\rm512.00\small\  MB$ | $\rm B$ |
| Subtask 3 (25 pts) | $3 \times 10^5$ |  | $400\ \rm\small ms$ | $\rm512.00\small\  MB$ |
| Subtask 4 (10 pts) |  |  | $400\ \rm\small ms$ | $\rm512.00\small\  MB$ |

- 限制 $\text{A}$： $x_n\le2\times 10^5$。
- 限制 $\text{B}$：有不超过 $50$ 个 $i$ 不满足 $x_i-x_{i-1}\le 100$ ，其余 $i$ 满足 $\sum_{i}{x_i-x_{i-1}} \le 2\times 10^5$。

## 样例 #1

### 输入

```
3 3
3 5 8
4 6 7```

### 输出

```
1
2
0```

# AI分析结果



### 唯一算法分类  
**离线处理 + 单调队列/栈**

---

### 综合分析与结论  
题目核心为跳跃次数计算，关键在于预处理相邻棋子间的跳跃限制，维护单调结构以快速回答查询。各题解共性如下：  
1. **跳跃区间对称性**：每个相邻棋子间的跳跃死区呈现对称性，可用单调队列维护区间边界。  
2. **离线处理查询**：将查询排序后按坐标顺序处理，利用单调队列/栈快速定位答案。  
3. **奇偶性分治**：跳跃方向与奇偶性相关，需维护两个队列处理不同情况。  

**核心难点**在于动态维护跳跃区间的覆盖关系，避免重复计算。  
**关键数据结构**：单调队列/栈，通过 `tag` 记录偏移量，实现区间长度的动态调整。  

---

### 题解清单（≥4星）  
1. **Tony2（⭐⭐⭐⭐⭐）**  
   - **亮点**：巧妙维护两个单调队列，利用 `tag` 实现区间偏移，代码高效且逻辑清晰。  
   - **个人心得**：通过覆盖机制处理区间重叠，确保查询时二分结果正确。  

2. **wYYSZLwSSY（⭐⭐⭐⭐）**  
   - **亮点**：将跳跃距离转化为奇偶交替序列，通过单调栈维护极值点。  
   - **优化**：利用奇偶性分类讨论，减少判断分支，提高代码效率。  

---

### 最优思路或技巧提炼  
1. **离线排序 + 单调结构**  
   - 预处理查询后按坐标排序，与棋子区间顺序同步处理，确保每个查询仅需一次二分。  
2. **动态偏移量（tag）**  
   - 维护两个队列分别对应奇偶情况，通过 `tag` 记录整体偏移，避免频繁修改队列元素。  
3. **对称性剪枝**  
   - 跳跃死区的长度由左右相邻棋子的间距决定，短间距限制长间距的扩展范围。  

**核心代码片段（Tony2 解法）**：  
```cpp
// 处理每个相邻棋子区间
for (int i = 1; i < n; i++) {
    const ll len1 = ... , len2 = ...;
    if (len1 > len2) {
        // 调整队列边界，剪枝过长区间
        while (l[j] < r[j] && q[j][r[j]-1].first > len2 - d[j]) r[j]--;
        q[j][r[j]].first = min(...);
        // 更新另一队列的偏移量
        d[j^1] -= len1 - len2;
    } else {
        // 添加新区间到队列头部
        q[j][--l[j]] = make_pair(...);
    }
    // 处理当前区间内的所有查询
    while (p <= Q && b[p].first <= a[i+1]) {
        // 二分查找两个队列中的极值
        ans[b[p].second] = i - max(...);
        p++;
    }
}
```

---

### 同类型题或类似算法套路  
- **单调队列优化 DP**：如滑动窗口极值、最长合法子数组。  
- **离线处理 + 扫描线**：如区间覆盖问题、二维数点。  
- **奇偶性分治**：如交替跳跃问题、棋盘覆盖。  

---

### 推荐题目  
1. **P1886 滑动窗口**（单调队列模板题）  
2. **P1904 天际线**（扫描线 + 优先队列）  
3. **P3580 [POI2015] KAM**（奇偶性分治 + 离线处理）  

---

### 个人心得摘录  
- **Tony2**：覆盖机制避免重复处理，强调“单调队列的队尾剪枝是保持高效的关键”。  
- **wYYSZLwSSY**：“奇偶分类讨论让代码逻辑更清晰，但初始化边界容易出错，需仔细验证”。  

---

### 可视化与算法演示  
**动画方案设计**：  
1. **数轴绘制**：Canvas 绘制数轴，不动棋用黑色方块，可动棋用红色方块标记。  
2. **跳跃演示**：点击查询位置后，红色方块向左跳跃，每次跳跃后高亮中间棋子。  
3. **队列状态面板**：右侧显示两个单调队列的当前元素和 `tag` 值，颜色区分奇偶队列。  

**复古像素风格**：  
- **颜色方案**：黑色（#000）、红色（#FF0000）、绿色（#00FF00）代表不同状态。  
- **音效**：跳跃时播放 8-bit 弹跳音效，查询完成时播放胜利音效。  
- **自动演示**：按棋子坐标自动步进，高亮当前处理的区间和队列变化。  

**交互功能**：  
- **速度调节**：滑动条控制动画速度（1x~5x）。  
- **单步执行**：按空格键逐帧观察队列更新和查询处理。  

```javascript
// 示例代码：Canvas 绘制跳跃过程（伪代码）
function drawJump(a, b, mid) {
    ctx.fillStyle = "#FF0000";
    ctx.fillRect(a * scale, yPos, 10, 10); // 起点
    ctx.fillStyle = "#000";
    ctx.fillRect(mid * scale, yPos, 10, 10); // 中间棋子
    animateRedBlockTo(b); // 红色方块移动到终点
    playSound("jump.wav"); // 播放音效
}
```

---
处理用时：77.39秒
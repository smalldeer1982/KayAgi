# 题目信息

# [NOI2006] 神奇口袋

## 题目描述

Pòlya 获得了一个奇妙的口袋，上面写着人类难以理解的符号。Pòlya 看得入了迷，冥思苦想，发现了一个神奇的模型（被后人称为 Pòlya 模型)。为了生动地讲授这个神奇的模型，他带着学生们做了一个虚拟游戏：游戏开始时，袋中装入 $a_1$ 个颜色为 $1$ 的球，$a_2$ 个颜色为 $2$ 的球，……，$a_t$ 个颜色为 $t$ 的球，其中 $a_i \in \mathbb Z^+$（$1 \le i \le t$）。

游戏开始后，每次严格进行如下的操作：

从袋中随机的抽出一个小球（袋中所有小球被抽中的概率相等），Pòlya 独自观察这个小球的颜色后将其放回，然后再把 $d$ 个与其颜色相同的小球放到口袋中。

设 $c_i$ 表示第 $i$ 次抽出的小球的颜色（$1 \le C_i \le t$），一个游戏过程将会产生一个颜色序列（$c_1, c_2, \ldots, c_n, \ldots$）。Pòlya 把游戏开始时 $t$ 种颜色的小球每一种的个数 $a_1, a_2, \ldots, a_t$ 告诉了所有学生。然后他问学生：一次游戏过程产生的颜色序列满足下列条件的概率有多大？ 

$$c_{x_1}=y_1, c_{x_2}=y_2, \ldots, c_{x_n}=y_n$$

其中 $0 < x_1 < x_2 < \cdots < x_n$，$1 \le y_i \le t$。换句话说，已知 $(t, n, d, a_1, a_2, \ldots, a_t, x_1, y_1, x_2, y_2, \ldots, x_n, y_n)$，你要回答有多大的可能性会发生下面的事件：“对所有 $k$（$1 \le k \le n$），第 $x_k$ 次抽出的球的颜色为 $y_k$”。

## 说明/提示

**【样例解释 #1】**

初始时，两种颜色球数分别为 $(1, 1)$，取出色号为 $1$ 的球的概率为 $1/2$；第二次取球之前，两种颜色球数分别为 $(2, 1)$，取出色号为 $2$ 的球的概率为 $1/3$；第三次取球之前，两种颜色球数分别为 $(2, 2)$，取出色号为 $1$ 的球的概率为 $1/2$，所以三次取球的总概率为 $1/12$。

**【数据规模和约定】**

对于 $100 \%$ 的数据，$1 \le t, n \le 1000$，$1 \le a_k, d \le 10$，$1 \le x_1 < x_2 < \cdots < x_n \le 10000$，$1 \le y_k \le t$。

## 样例 #1

### 输入

```
2 3 1
1 1
1 1
2 2
3 1
```

### 输出

```
1/12
```

## 样例 #2

### 输入

```
3 1 2
1 1 1
5 1
```

### 输出

```
1/3
```

# AI分析结果



## 算法分类
**数学（概率论）**

---

## 题解思路、算法要点与解决难点

### 核心思路
所有题解均基于以下核心发现：
1. **时序无关性**：无论抽球顺序如何，每次抽到某颜色的概率仅取决于当前球的总数和该颜色球的数量。
2. **概率乘积简化**：所求概率可拆解为各次抽球事件的独立概率乘积，无需考虑时序干扰。

### 算法要点对比
| 题解作者 | 核心贡献 | 数据结构/技巧 | 解决难点 |
|---------|----------|---------------|----------|
| yybyyb   | 通过数学归纳法证明时序无关性 | 质因数分解、高精度计算 | 处理大数分数乘法避免溢出 |
| w33z8kqrqk8zzzx33 | 使用Python的`fractions`模块简化分数运算 | Python内置分数运算 | 避免手写高精度逻辑 |
| Purslane | 质因数分解+分子分母约分 | 质因数分解统计幂次 | 高效处理分数约分 |

---

## 题解评分（≥4星）

### 1. w33z8kqrqk8zzzx33（⭐⭐⭐⭐⭐）
- **思路清晰度**：数学归纳法证明简洁明确
- **代码可读性**：仅10行Python，利用内置分数类
- **优化程度**：无需处理高精度，直接语言特性解决
- **代码片段**：
```python
from fractions import *
t, n, d = map(int, input().split())
ar = list(map(int, input().split()))
s = sum(ar)
ans = Fraction(1)
for i in range(n):
    x, y = map(int, input().split())
    y -= 1
    ans *= Fraction(ar[y], s)
    ar[y] += d
    s += d
print(ans)
```

### 2. yybyyb（⭐⭐⭐⭐）
- **核心贡献**：完整推导概率独立性
- **实践性**：C++质因数分解+高精度实现
- **代码亮点**：
```cpp
void Calc(int x,int *f) {
    for(int i=1;i<=tot;++i)
        while(x%pri[i]==0) f[pri[i]]++,x/=pri[i];
}
// 质因数统计后约分
```

### 3. Purslane（⭐⭐⭐⭐）
- **实现技巧**：质因数幂次统计
- **代码亮点**：约分逻辑清晰
```cpp
multiset<int> fz,fm; // 分子分母质因数存储
void insert(int val,int op) { /* 约分逻辑 */ }
```

---

## 最优思路/技巧提炼
1. **数学归纳法**：证明每次抽球概率仅依赖当前状态
2. **独立事件乘积**：将复杂时序问题转化为独立概率连乘
3. **质因数分解约分**：避免高精度除法，通过统计质因数幂次实现分数化简

---

## 同类题型与算法套路
- **Polya Urn模型扩展**：如颜色增加规则变化后的概率计算
- **动态概率问题**：状态转移仅依赖当前状态的场景
- **推荐题目**：
  1. [P1654 产品排序](https://www.luogu.com.cn/problem/P1654)（概率动态规划）
  2. [P3239 亚瑟王的生日](https://www.luogu.com.cn/problem/P3239)（时序无关概率计算）
  3. [P1850 换教室](https://www.luogu.com.cn/problem/P1850)（期望概率的动态规划）

---

## 可视化与算法演示设计

### 核心动画逻辑
1. **初始状态展示**：用不同颜色圆球表示各颜色数量，右侧显示当前总球数
   ```javascript
   // 伪代码示例
   drawBalls(colors) {
       ctx.clearRect(0,0,width,height);
       colors.forEach((cnt, idx) => {
           for(let i=0; i<cnt; i++) 
               drawCircle(xPos, colorMap[idx]);
       });
   }
   ```
2. **抽球过程高亮**：
   - 当前抽取的球闪烁显示（颜色高亮+缩放动画）
   - 显示当前概率分数（如$\frac{3}{10}$→绿色箭头指向分子分母）

3. **状态更新效果**：
   - 新增的d个球以"掉落动画"进入袋子
   - 总球数更新时显示`+d`的上升数字特效

### 复古像素风格实现
- **调色板**：使用16色NES配色（红、蓝、绿、黄等经典组合）
- **音效设计**：
  - 抽球时：8-bit "blip"短音（Web Audio API生成）
  - 错误时：低沉方波警示音
  - 正确约分：上升音阶奖励音
- **Canvas动画**：
  ```javascript
  class PixelAnimator {
      constructor() {
          this.gridSize = 8; // 8x8像素颗粒
          this.drawBall(x, y, color) {
              ctx.fillStyle = NES_COLORS[color];
              ctx.fillRect(x*gridSize, y*gridSize, gridSize, gridSize);
          }
      }
  }
  ```

---

## 个人心得摘录
> "**约分时忘记处理重复质因数**，导致最终结果错误。应该用`multiset`而非普通计数，因为同一质因数可能多次出现。" —— Purslane调试笔记

---

## 代码实现（核心逻辑）
Python简洁版（w33z8kqrqk8zzzx33思路）：
```python
from fractions import Fraction

t, n, d = map(int, input().split())
a = list(map(int, input().split()))
total = sum(a)
prob = Fraction(1, 1)
for _ in range(n):
    x, y = map(int, input().split())
    y -= 1  # 转为0-based
    if a[y] == 0:
        print("0/1")
        exit()
    prob *= Fraction(a[y], total)
    a[y] += d
    total += d
print(prob)
```

---
处理用时：75.39秒
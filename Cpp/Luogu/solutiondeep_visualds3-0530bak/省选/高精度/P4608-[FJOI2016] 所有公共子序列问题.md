# 题目信息

# [FJOI2016] 所有公共子序列问题

## 题目描述

一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列 $X=x_1x_2\ldots x_m$，则另一序列 $Z=z_1z_2\ldots z_k$ 是 $X$ 的子序列是指存在一个严格递增下标序列 $i_1,i_2, \ldots ,i_k$ 使得对于所有 $j=1,2,…,k$ 有 $z_j=x_{i_j}$。

例如，序列 $Z=$``GACT`` 是序列 $X=$``GCTACT`` 的子序列，相应的递增下标序列为 $1,4,5,6$。给定两个序列 $X$ 和 $Y$，当另一序列 $Z$ 既是 $X$ 的子序列又是 $Y$ 的子序列时，称 $Z$ 是序列 $X$ 和 $Y$ 的公共子序列。例如，若 $X=$``GCTACT``， $Y=$``GATCCT``，序列 $T$ 是 $X$ 和 $Y$ 的一个公共子序列，序列 ``GACT`` 也是 $X$ 和 $Y$ 的一个公共子序列。注意对于任何给定的序列 $X$ 和 $Y$，空序列总是它们的一个公共子序列。

所有公共子序列问题是要求对于给定的 $2$ 个序列 $X=x_1x_2\ldots x_m$ 和 $Y=y_1y_2\ldots y_m$，找出 $X$ 和 $Y$ 的所有不同的公共子序列。

## 说明/提示

$1 \leq m,n \leq 3010$

答案....很大啦

## 样例 #1

### 输入

```
6 6
GCTACT
GATCCT 1```

### 输出

```
A
AC
ACT
AT 
C  
CC 
CCT
CT 
G  
GA 
GAC
GACT
GAT 
GC  
GCC 
GCCT
GCT 
GT  
GTC 
GTCT
GTT 
T   
TC  
TCT 
TT  
26```

# AI分析结果



---

**唯一算法分类**：序列自动机 + 动态规划（高精度优化）

---

### **题解思路、算法要点与解决难点**

#### **核心思路**
1. **序列自动机构建**：预处理每个位置后续字符的位置，形成快速跳转结构。
   - 对两个字符串分别建立序列自动机，`nxt[i][c]`表示在位置`i`后字符`c`首次出现的位置。
2. **动态规划（DP）**：定义`f[i][j]`为从第一个字符串的`i`位置和第二个字符串的`j`位置开始的公共子序列数量。
   - 转移方程：枚举所有字符`c`，若两字符串在`i`和`j`后均有`c`，则`f[i][j] += f[nxt1[i][c]][nxt2[j][c]]`。
3. **高精度优化**：因答案极大，需用压位高精度（如每9位存一个`long long`）。
4. **DFS输出路径**：当`k=1`时，按字典序遍历所有可能的字符，递归生成公共子序列。

#### **解决难点**
- **高效跳转**：序列自动机预处理使得每个状态转移的复杂度为`O(1)`。
- **字典序输出**：DFS时按字符顺序（如`A→Z, a→z`）遍历，自然保证字典序。
- **空间优化**：滚动数组或记忆化搜索减少DP状态占用空间。
- **大数处理**：压位高精度避免MLE并提升计算速度。

---

### **题解评分 (≥4星)**

1. **枫林晚 (⭐⭐⭐⭐⭐)**  
   - **亮点**：详细讲解序列自动机原理，代码结构清晰，压位高精度实现完整。
   - **代码**：结合DFS输出和DP计算，逻辑严密。
2. **s_r_f (⭐⭐⭐⭐)**  
   - **亮点**：高精度结构体封装简洁，DFS与DP分离，适合教学。
   - **代码**：直接处理空序列，无遗漏边界条件。
3. **Fzrcy (⭐⭐⭐⭐)**  
   - **亮点**：代码简洁，结构体封装高效，适合快速实现。
   - **优化**：直接使用`58`位字符集（包含大小写字母）。

---

### **最优思路或技巧提炼**

1. **序列自动机构建**：逆序预处理每个位置的字符跳转，时间复杂度`O(n·|Σ|)`。
   ```cpp
   void build(char *s, int Len) {
     for (int i=Len; i; i--) {
       for (int j=0; j<58; j++) ch[i-1][j] = ch[i][j];
       ch[i-1][s[i]-'A'] = i;
     }
   }
   ```
2. **DFS按字典序输出**：优先遍历`A→Z, a→z`保证顺序，递归路径记录。
   ```cpp
   void dfs(int x, int y) {
     printf("%s\n", sta); // 当前路径
     for (char c='A'; c<='z'; c++) {
       int nx = nxt1[x][c], ny = nxt2[y][c];
       if (nx && ny) dfs(nx, ny);
     }
   }
   ```
3. **压位高精度加法**：每9位存一个`long long`，进位处理高效。
   ```cpp
   struct BigInt {
     ll s[20]; int c;
     void add(BigInt &o) {
       for (int i=0; i<=max(c,o.c); i++) {
         s[i] += o.s[i];
         if (s[i] >= MOD) s[i+1] += s[i]/MOD, s[i] %= MOD;
       }
     }
   };
   ```

---

### **同类型题或类似算法套路**

1. **最长公共子序列（LCS）计数**：类似状态转移，但无需处理高精度。
2. **子序列自动机应用**：如判断子序列存在性、统计子序列种类数。
3. **双序列联合遍历**：如联合DFS/DP处理两个序列的匹配问题。

---

### **推荐题目**

1. **[P1819 公共子序列问题](https://www.luogu.com.cn/problem/P1819)**  
   - **相似点**：统计公共子序列数量，需高精度。
2. **[P5826 子序列自动机](https://www.luogu.com.cn/problem/P5826)**  
   - **相似点**：序列自动机模板题，预处理跳转表。
3. **[P1439 最长公共子序列](https://www.luogu.com.cn/problem/P1439)**  
   - **相似点**：LCS问题，可扩展为计数版本。

---

### **个人心得摘录**

- **枫林晚**：  
  > “序列自动机本质是子序列的跳转树，每个节点到根的路径即所有子序列。”
- **i207M**：  
  > “滚动数组优化空间，需注意状态转移的方向。”

---

### **可视化与算法演示**

#### **核心算法流程**
1. **序列自动机构建**：  
   - **动画**：逆序填充跳转表，用颜色标记当前处理的字符位置。
   - **高亮**：当前字符`c`的跳转位置更新（如`nxt[i][c] = i+1`）。

2. **DFS遍历路径**：  
   - **像素风格**：路径字符以8位像素字体显示，每次递归时添加新字符块。
   - **音效**：每次输出子序列时播放“收集金币”音效。

3. **动态规划状态转移**：  
   - **网格视图**：二维网格表示`f[i][j]`，箭头指向转移方向。
   - **颜色渐变**：数值越大颜色越深，高亮当前更新的状态。

#### **复古游戏化设计**
- **Canvas动画**：  
  - 网格绘制自动机节点，绿色方块表示有效跳转，红色为无效。
  - 路径生成时，字符块从左侧滑入，伴随8-bit音效。
- **AI自动演示**：  
  - 自动按字典序选择字符，路径生成速度可调节。
- **积分系统**：  
  - 每生成一个子序列得10分，连续无重复字符得额外奖励。

---

### **代码片段（核心逻辑）**

#### **序列自动机构建**
```cpp
void build(char *s, int Len) {
  memset(nxt[Len], 0, sizeof(nxt[Len])); // 末位初始化为0
  for (int i=Len-1; i>=0; i--) {
    memcpy(nxt[i], nxt[i+1], sizeof(nxt[i])); // 继承后序状态
    nxt[i][s[i+1]-'A'] = i+1; // 更新当前字符跳转
  }
}
```

#### **DFS输出子序列**
```cpp
char path[3000];
int top = 0;
void dfs(int x, int y) {
  if (top > 0) printf("%s\n", path); // 输出非空序列
  for (char c='A'; c<='Z'; c++) { // 按字典序遍历
    int nx = nxt1[x][c], ny = nxt2[y][c];
    if (nx && ny) {
      path[top++] = c;
      dfs(nx, ny);
      path[--top] = '\0'; // 回溯
    }
  }
}
```

#### **压位高精度加法**
```cpp
struct Big {
  ll s[20] = {0}; int c = 0;
  void add(const Big &o) {
    c = max(c, o.c);
    for (int i=0; i<=c; i++) {
      s[i] += o.s[i];
      if (s[i] >= MOD) s[i+1] += s[i]/MOD, s[i] %= MOD;
    }
    if (s[c+1] > 0) c++;
  }
};
```

---

**可视化代码片段（伪代码）**
```javascript
// Canvas绘制序列自动机跳转
function drawAutomaton(ctx, nxt) {
  for (let i=0; i<nxt.length; i++) {
    for (let c=0; c<52; c++) {
      if (nxt[i][c]) {
        ctx.fillStyle = '#7FFF00'; // 绿色跳转
        ctx.fillRect(i*10, c*10, 8, 8);
      }
    }
  }
}

// 播放音效（Web Audio）
function playSound(note) {
  const osc = audioContext.createOscillator();
  osc.frequency.setValueAtTime(440 * Math.pow(2, note/12), audioContext.currentTime);
  osc.connect(audioContext.destination);
  osc.start(); osc.stop(audioContext.currentTime + 0.1);
}
```

---
处理用时：101.68秒
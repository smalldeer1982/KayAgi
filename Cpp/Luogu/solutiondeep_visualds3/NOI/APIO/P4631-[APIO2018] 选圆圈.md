# 题目信息

# [APIO2018] 选圆圈

## 题目描述

在平面上，有 $n$ 个圆，记为 $c_1, c_2,...,c_n$ 。我们尝试对这些圆运行这个算法：

1. 找到这些圆中半径最大的。如果有多个半径最大的圆，选择编号最小的。记为 $c_i$。
2. 删除 $c_i$ 及与其有交集的所有圆。两个圆有交集当且仅当平面上存在一个点，这个点同时在这两个圆的圆周上或圆内。（原文直译：如果平面上存在一个点被这两个圆所包含，我们称这两个圆有交集。一个点被一个圆包含，当且仅当它位于圆内或圆周上。）
3. 重复上面两个步骤直到所有的圆都被删除。

![QQ20180525194902.png](https://cdn.luogu.com.cn/upload/pic/19974.png)

当 $c_i$ 被删除时，若循环中第 $1$ 步选择的圆是 $c_j$，我们说 $c_i$ 被 $c_j$ 删除。对于每个圆，求出它是被哪一个圆删除的。

## 说明/提示

**提示**

题目描述中的图片对应了样例一中的情形。

**子任务（注：这里给出的子任务与本题在这里的最终评测无关，仅供参考）**

- Subtask 1(points: $7$): $n \leq 5000$
- Subtask 2(points: $12$): $n \leq 3 × 10^5$，对于所有的圆 $y_i = 0$
- Subtask 3(points: $15$): $n \leq 3 × 10^5$，每个圆最多和一个其他圆有交集
- Subtask 4(points: $23$): $n \leq 3 × 10^5$，所有的圆半径相同
- Subtask 5(points: $30$): $n \leq 10^5$
- Subtask 6(points: $13$): $n \leq 3 × 10^5$

所有数据均满足：$-10^9 ≤ x_i, y_i ≤ 10^9, 1 ≤ r_i ≤ 10^9$。

## 样例 #1

### 输入

```
11
9 9 2
13 2 1
11 8 2
3 3 2
3 12 1
12 14 1
9 8 5
2 8 2
5 2 1
14 4 2
14 14 1
```

### 输出

```
7 2 7 4 5 6 7 7 4 7 6```

# AI分析结果

# 💡 Kay的C++算法解析：[APIO2018]选圆圈 深入学习指南 💡

<introduction>
今天我们来一起分析APIO2018的经典题目“选圆圈”。这道题需要我们在平面上的圆中，每次选最大的未被删除的圆，删除它和所有相交的圆，最后输出每个圆被哪个圆删除。本指南将帮助大家理解核心思路、掌握优化技巧，并通过像素动画直观感受算法流程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（侧重二维平面范围查询的优化暴力）

🗣️ **初步分析**：
解决这道题的核心是**“高效找邻居”**——每次选最大的圆后，要快速找到所有和它相交的圆。直接暴力遍历所有圆（O(n²)）会超时，所以需要用**优化的暴力**：用数据结构缩小查询范围，只检查“可能相交”的圆。

打个比方：就像你收拾玩具时，先拿最大的玩具车，只需要找它周围1米内的玩具（因为大玩具不会和远处的小玩具碰到），而不是翻遍整个房间。这里的“1米”就是数据结构帮我们划定的“可能范围”。

### 核心算法流程与可视化设计
1. **排序选最大**：先把圆按半径从大到小排序（半径相同选编号小的），确保每次处理的都是当前最大的未被删除的圆。
2. **范围查询**：用KDT或分块把平面分成“格子”，只检查当前圆所在格子及周围8个格子的圆（或KDT中剪枝掉不可能相交的子树）。
3. **标记删除**：找到相交的圆，标记它们被当前圆删除。

**可视化设计思路**：
- 用8位像素风展示平面，圆用不同颜色的像素块表示（比如红色代表当前最大圆，黄色代表相交的圆）。
- 每次选最大圆时，圆会闪烁并播放“叮”的音效；删除相交圆时，这些圆会“消失”并播放“咻”的音效。
- 控制面板有“单步执行”（一步步看选圆→找邻居→删除）、“自动播放”（像贪吃蛇AI一样自动完成），还有速度滑块调整播放速度。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3个优质题解，帮大家快速掌握不同的优化方法！
</eval_intro>

**题解一：KDT优化暴力（来源：ysner）**
* **点评**：这道题解用KDT（k维树）维护平面上的圆，把每个圆的范围转化为矩形（圆心±半径），通过子树的矩形范围剪枝，只检查可能相交的圆。思路清晰，代码规范，能通过洛谷数据，是最经典的解法之一。

**题解二：排序剪枝暴力（来源：D0000）**
* **点评**：这道题解的思路特别巧妙！先按x或y轴排序，每次选最大圆后，用二分找x轴或y轴上“可能相交”的范围（距离≤2倍当前圆半径），然后暴力检查这些圆。代码简单易懂，时间复杂度O(n√n)，适合入门学习者。

**题解三：分块重构优化（来源：Lice）**
* **点评**：这是复杂度最有保证的解法！把平面分成边长为2R（当前最大圆半径）的格子，只检查当前圆所在格子及周围8个格子的圆。当当前圆半径太小（<原来的1/4）时，重构格子。复杂度O(n(logn+logR))，是官方题解的方法，适合想深入理解的同学。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是“避开无效工作”，下面是3个核心难点及解决方法：
</difficulty_intro>

1. **难点1：如何高效找到相交的圆？**
   - **分析**：直接遍历所有圆会超时，需要缩小查询范围。
   - **解决方法**：用KDT或分块把平面分成小范围，只检查“可能相交”的圆。比如KDT中，若子树的矩形和当前圆的矩形没有交集，直接跳过；分块中，只检查当前格子及周围8个格子的圆。
   - 💡 **学习笔记**：数据结构的核心是“剪枝”——去掉不可能的情况，减少计算量。

2. **难点2：如何处理动态删除？**
   - **分析**：圆被删除后，不能再被查询到。
   - **解决方法**：维护未被删除的圆集合。比如分块中，每次检查格子中的圆时，跳过已删除的；KDT中，标记已删除的节点，查询时跳过。
   - 💡 **学习笔记**：动态问题的关键是“维护有效集合”，避免重复处理已删除的元素。

3. **难点3：如何保证每次选最大的圆？**
   - **分析**：每次必须选当前未被删除的最大圆。
   - **解决方法**：预先按半径从大到小排序（半径相同按编号从小到大），依次处理每个圆，跳过已被删除的圆。
   - 💡 **学习笔记**：预处理排序可以避免每次找最大圆的开销，是常用的优化技巧。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**KDT优化的通用核心实现**，帮大家理解整体框架；再分析两个优质题解的关键片段！
</code_intro_overall>

### 本题通用核心C++实现参考（KDT解法）
* **说明**：本代码来自ysner的题解，用KDT维护圆的矩形范围，剪枝查询，是最经典的实现之一。
* **完整核心代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#define re register
#define il inline
#define ll long long
#define db double
#define ls t[k].l
#define rs t[k].r
#define eps 1e-6
#define pf(x) ((db)(1.0)*(x)*(x))
#define max(a,b) (((a)>(b)?(a):(b)))
#define min(a,b) (((a)<(b)?(a):(b)))
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
const int N=3e5+100;
int now,n,rt,ans[N];
struct dat { int d[2],r,id; bool operator < (const dat &o) const { return d[now]<o.d[now]; } };
struct node { dat a; int l,r,mn[2],mx[2]; };
node t[N];
dat a[N];

il int gi() {
    re int x=0,t=1; re char ch=getchar();
    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
    if(ch=='-') t=-1,ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
    return x*t;
}

struct kd_tree {
    il void upd(re int k,re int p) {
        t[k].mn[0]=min(t[k].mn[0],t[p].mn[0]); t[k].mx[0]=max(t[k].mx[0],t[p].mx[0]);
        t[k].mn[1]=min(t[k].mn[1],t[p].mn[1]); t[k].mx[1]=max(t[k].mx[1],t[p].mx[1]);
    }
    il void pushup(re int k) {
        re int x=t[k].a.d[0],y=t[k].a.d[1],r=t[k].a.r;
        t[k].mn[0]=x-r; t[k].mx[0]=x+r;
        t[k].mn[1]=y-r; t[k].mx[1]=y+r;
        if(ls) upd(k,ls); if(rs) upd(k,rs);
    }
    il void Build(re int &k,re int l,re int r,re int tag) {
        re int mid=l+r>>1; now=tag;
        nth_element(a+l,a+mid,a+r+1); k=mid;
        t[k].a=a[mid];
        if(l<mid) Build(ls,l,mid-1,tag^1); else ls=0;
        if(mid<r) Build(rs,mid+1,r,tag^1); else rs=0;
        pushup(k);
    }
    il bool check(re int k,re dat A) {
        re int x=A.d[0],y=A.d[1],r=A.r+t[k].a.r,xx=t[k].a.d[0],yy=t[k].a.d[1];
        return pf(1ll*x-xx)+pf(1ll*y-yy)-eps<=pf(r);
    }
    il int far(re int k,re dat A) {
        re int x=A.d[0],y=A.d[1],r=A.r;
        if(x+r<t[k].mn[0]) return 1;
        if(y+r<t[k].mn[1]) return 1;
        if(x-r>t[k].mx[0]) return 1;
        if(y-r>t[k].mx[1]) return 1;
        return 0;
    }
    il void Query(re int k,re dat A) {
        if(far(k,A)) return;
        if(!ans[t[k].a.id]&&check(k,A)) ans[t[k].a.id]=A.id;
        if(ls) Query(ls,A); if(rs) Query(rs,A);
    }
}kd;

int main() {
    n=gi();
    fp(i,1,n) {
        a[i].d[0]=gi(); a[i].d[1]=gi(); a[i].r=gi(); a[i].id=i;
    }
    kd.Build(rt,1,n,0);
    sort(a+1,a+1+n,[](dat x,dat y){ return x.r==y.r?x.id<y.id:x.r>y.r; });
    fp(i,1,n) if(!ans[a[i].id]) kd.Query(rt,a[i]);
    fp(i,1,n) printf("%d ",ans[i]); puts("");
    return 0;
}
```
* **代码解读概要**：
  1. **输入与初始化**：读取每个圆的坐标、半径和编号，存入`a`数组。
  2. **构建KDT**：按x或y轴分割平面，构建KDT树，每个节点维护子树的矩形范围（mn/mx数组）。
  3. **排序选最大**：按半径从大到小排序`a`数组。
  4. **查询与删除**：依次处理每个圆，用KDT查询相交的圆，标记被当前圆删除。


### 题解一：KDT的剪枝逻辑（来源：ysner）
* **亮点**：用子树的矩形范围剪枝，只检查可能相交的圆，避免无效查询。
* **核心代码片段**：
```cpp
il int far(re int k,re dat A) {
    re int x=A.d[0],y=A.d[1],r=A.r;
    if(x+r<t[k].mn[0]) return 1; // 当前圆的右边界 < 子树的左边界，不可能相交
    if(y+r<t[k].mn[1]) return 1; // 当前圆的上边界 < 子树的下边界，不可能相交
    if(x-r>t[k].mx[0]) return 1; // 当前圆的左边界 > 子树的右边界，不可能相交
    if(y-r>t[k].mx[1]) return 1; // 当前圆的下边界 > 子树的上边界，不可能相交
    return 0;
}

il void Query(re int k,re dat A) {
    if(far(k,A)) return; // 剪枝：不可能相交，直接跳过
    if(!ans[t[k].a.id]&&check(k,A)) ans[t[k].a.id]=A.id; // 标记被删除
    if(ls) Query(ls,A); if(rs) Query(rs,A); // 递归查询左右子树
}
```
* **代码解读**：
  - `far`函数判断当前子树的矩形是否和当前圆的矩形有交集：如果没有，直接返回1（剪枝）。
  - `Query`函数先剪枝，再检查当前节点的圆是否和当前圆相交，如果相交且未被删除，标记它被当前圆删除，最后递归查询左右子树。
* **学习笔记**：剪枝是优化暴力的关键，通过“范围判断”跳过不可能的情况，可以大幅减少计算量。


### 题解二：排序剪枝的核心逻辑（来源：D0000）
* **亮点**：通过x或y轴排序，二分找范围，暴力检查，代码简单易懂。
* **核心代码片段**：
```cpp
sort(qq+1,qq+n+1,dmy); // 按x轴排序
sort(q2+1,q2+n+1,dhx); // 按y轴排序

// 处理当前最大圆cc
int lt=1,rt=n,mt,lx,rx,ly=0,ry;
// 二分找x轴上的范围：x∈[cc.x-2*cc.r, cc.x+2*cc.r]
while(lt<=rt) { mt=(lt+rt)>>1; if(a[qq[mt]].x<a[cc].x-2*a[cc].r) lt=mt+1; else rt=mt-1,lx=mt; }
while(lt<=rt) { mt=(lt+rt)>>1; if(a[qq[mt]].x>a[cc].x+2*a[cc].r) rt=mt-1; else lt=mt+1,rx=mt; }
// 同样找y轴上的范围ly-ry

// 选择x或y轴范围更小的那个，暴力检查
if(rx-lx+1<=ry-ly+1) {
    for(int i=lx;i<=rx;i++) if(!a[qq[i]].b&&pd(qq[i],cc)) {
        del(a[qq[i]].golian); a[qq[i]].b=1; a[qq[i]].ans=cc;
    }
} else {
    for(int i=ly;i<=ry;i++) if(!a[q2[i]].b&&pd(q2[i],cc)) {
        del(a[q2[i]].golian); a[q2[i]].b=1; a[q2[i]].ans=cc;
    }
}
```
* **代码解读**：
  - 先按x和y轴排序`qq`和`q2`数组。
  - 对于当前最大圆`cc`，二分找x轴上“可能相交”的范围（x±2*r，因为r_cc≥r_other，所以相交的话x差≤r_cc+r_other≤2*r_cc）。
  - 同样找y轴的范围，选择范围更小的那个，暴力检查里面的圆是否相交。
* **学习笔记**：排序+二分是入门级的优化技巧，虽然复杂度不如KDT，但代码简单，容易理解，适合新手。


## 5. 算法可视化：像素动画演示

**动画演示主题**：像素探险家之“圆的大清扫”
**核心演示内容**：展示选最大圆→找相交圆→删除的全过程，结合8位像素风、音效和交互。

### 动画帧步骤与交互关键点
1. **场景初始化**：
   - 屏幕展示8位像素风的平面，圆用不同颜色的像素块表示（比如蓝色代表未被删除的圆，红色代表当前最大圆）。
   - 控制面板有“开始/暂停”“单步执行”“重置”按钮，还有速度滑块（从“慢”到“快”）。
   - 播放8位风格的轻松背景音乐（比如《超级马里奥》的背景音乐）。

2. **算法启动**：
   - 按半径排序后的圆列表显示在屏幕右侧，当前处理的圆会高亮。
   - 第一次选最大圆时，红色圆闪烁并播放“叮”的音效，周围8个格子的圆会轻微闪烁（提示可能相交）。

3. **核心步骤演示**：
   - **找相交圆**：红色圆的周围圆会逐个检查，相交的圆变成黄色，并播放“滴”的音效。
   - **删除圆**：黄色圆会“消失”（变成透明），并播放“咻”的音效，同时屏幕下方显示“删除了x个圆”的提示。

4. **交互控制**：
   - 点击“单步执行”：一步步看选圆→找邻居→删除的过程。
   - 点击“自动播放”：像贪吃蛇AI一样自动完成所有步骤，速度可以通过滑块调整。
   - 点击“重置”：回到初始状态，重新开始演示。

**设计亮点**：
- 用像素风降低学习压力，让算法更直观。
- 音效强化关键操作的记忆（比如“叮”对应选最大圆，“咻”对应删除）。
- 自动播放像游戏一样，让学习者在“观看AI玩游戏”中理解算法。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心是**二维平面的范围查询与动态删除**，以下是相似问题和进阶练习，帮大家巩固技巧！
</similar_problems_intro>

### 相似问题
1. **POJ 2926**：最小包围圆问题，需要找到覆盖所有点的最小圆，用到随机增量法，也是平面范围查询的应用。
2. **HDU 1542**：扫描线求矩形面积并，用线段树维护区间覆盖，是平面范围查询的经典问题。
3. **洛谷 P3796**：AC自动机的简单应用？不，其实是KDT的模板题，维护平面上的点，查询最近点对。

### 进阶练习
- 尝试用分块重构的方法实现这道题（参考Lice的题解），理解分块的复杂度分析。
- 尝试给KDT的代码加上旋转坐标系（比如旋转2.33弧度），解决LOJ的hack数据（参考Treaker的题解）。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
以下是题解作者的经验分享，帮大家避开踩坑！
</insights_intro>

> **参考经验 (来自D0000)**：“我一开始用O(n²)暴力，直接超时，后来想到按x或y轴排序，二分找范围，暴力检查，居然过了！”
>
> **点评**：很多时候，简单的剪枝就能解决问题，不一定需要复杂的数据结构。动手试一下简单的方法，可能会有惊喜！


## 总结

本次关于“APIO2018选圆圈”的分析就到这里！这道题的核心是**优化的暴力**，用数据结构（KDT、分块）缩小查询范围，避免无效计算。希望大家能掌握“剪枝”的思想，在以后的题目中灵活运用！

记住：编程的本质是“解决问题”，不是“用复杂的算法”——适合问题的方法才是最好的方法！下次我们再一起探索新的编程挑战！💪

---
处理用时：137.40秒
# 题目信息

# 『SpOI - R1』我看到了，谢谢你们

## 题目描述

**本题包含多组测试。**

**特别注意：本题中，border 的定义有所不同。对于串 $s,t$，若同时存在 $s$ 的一对前缀后缀（可空也可为 $s$ 本身）等于 $t$，则 $t$ 是 $s$ 的 border。**

有一个长度为 $n$ 的字符串 $S$。我们使用这个串上的信息来选举总统。

令 $p_i$ 表示 $S$ 的 $i$ 长前缀，特别地，$p_0$ 表示包含第 $0$ 位的空前缀。现在有 $n+1$ 位候选人站在这 $n+1$ 个前缀上，编号为 $[0,n]$，编号为 $i$ 的人对应前缀 $i$。每个人有一个票数 $a_i$ 和花费 $w_i$。

得票数量**严格**超过总票数一半的人可以当选总统。

初始时所有人都处于**未被控制**状态。每一个时刻，任何一个**未被控制**且**之前一直在等待**的人 $i$ 都可以做出三种选择之一：

1. 进行一次**对 $v$ 投票**操作：将自己的 $a_i$ 票花费 $w_i$ 的代价投给人 $v$。
2. 进行一次**对 $v$ 揽票**操作：
	- 花费 $w_i$ 选中人 $v$，需要满足 $p_i$ 是 $p_v$ 的一个 border。
	- $\forall j\in[0,n]$，若 $p_v$ 是 $p_j$ 的一个 border，且 $j$ 在此时刻**未被控制**，则 $j$ 下一时刻变为**被控制**，他的 $a_j$ 票都花费 $w_j$ 投给 $i$。
3. 等待下一个时刻。

每个候选人都希望其他人不会成为总统，且都是绝顶聪明的。**特别地**，当他们的操作出现了交叉导致一个人的票需要投给多人时，被交叉者的票可以分别独立投出并都有效（你可以理解为他的票分裂了）。因此，总统可能有多个。

你可以干涉这个过程。具体来说，你可以在 $0$ 时刻操作一个候选人 $x$，让 $x$ 进行指定的一种选择，并钦定选择涉及的所有变量。$x$ 此后不能再做任何选择，剩下的人必须从 $1$ 时刻再开始选择。你干涉的代价就是 $x$ 这次选择的总花费。

票数 $a$ 和花费 $w$ 都会发生 $q$ 次变化。

每一次变化会改变票数 $a$ 中的某一项或是花费 $w$ 中的某一项。票数 $a$ 可能会变为任意正整数，花费 $w$ 只会变小或者不变。

在每次变化之后，你都需要找到这样一个人 $x$，满足你有一种干涉他的方案使得他一定可以成为总统，且你干涉的代价最小。你只需要输出这个最小代价。

可以证明一定存在这样的人。

本题**强制在线**。

## 说明/提示

#### 样例 #1 解释

对于第一组数据：

考虑第一次修改之前。全场共有 $11$ 票，则当选总统需要 $>5.5$ 票。

干涉 $0$ 号候选人，且选择第一种选择，使用 $w_0=1$ 的花费进行一次**对 $0$ 投票**操作后，$0$ 号候选人得到 $6$ 票，直接达到了总统要求，可以证明这是花费最小的答案。

第一次修改后，全场共有 $7$ 票，则当选总统需要 $>3.5$ 票。

干涉 $1$ 号候选人，且选择第二种选择，进行一次**对 $1$ 揽票**操作后，$1$ 号候选人将得到 $5$ 票，总花费为 $-1+(-1)+2=0$。他直接达到了总统要求，可以证明这是花费最小的答案。

对于第三组数据，去掉强制在线后的修改操作为：

- $o=2,p=3,x=5$；
- $o=1,p=5,x=100$；
- $o=1,p=5,x=1$；
- $o=2,p=1,x=-8$；
- $o=2,p=5,x=0$；
- $o=1,p=2,x=4$。

### 数据范围

**请注意常数因子对程序效率的影响。**

**本题开启子任务捆绑与子任务依赖。**

对于 $100\%$ 的数据，$1\leq T\leq 2000$，$1\leq n\leq 10^5$，$0\leq q\leq 10^5$，$0\leq type\leq 1$，且在任何时候都保证 $1\leq a_i\leq 2\times 10^9$，$|w_i|\leq 2\times 10^9$。

保证字符串中只含有小写字母。

对于任意一次修改，保证 $o$ 为 $1$ 或 $2$，且 $0\leq p\leq n$。在 $o=1$ 时，$1\leq x\leq 2\times 10^9$；$o=2$ 时，$0\leq |x|\leq 2\times 10^9$。

特别地，$w_i$ 中的每一项在被操作的过程中一定单调不递增。

| Subtask | $T\leq$ | $n,q\leq$ | $a_i,\lvert w_i\rvert \leq$ | 特殊性质 | 得分 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | $2000$ | $20$ | $10^5$ | 无 | $5$ | 无 |
| 2 | $2000$ | $200$ | $10^5$ | 无 | $10$ | 1 |
| 3 | $3$ | $10^5$ | $2\times 10^9$ | $A$ | $15$ | 无 |
| 4 | $3$ | $10^5$ | $2\times 10^9$ | $B$ | $5$ | 无 |
| 5 | $3$ | $10^5$ | $2\times 10^9$ | $C$ | $15$ | 无 |
| 6 | $3$ | $10^5$ | $2\times 10^9$ | $D$ | $20$ | 无 |
| 7 | $3$ | $10^5$ | $2\times 10^9$ | 无 | $30$ | 1,2,3,4,5,6 |

特殊性质 $A$：保证 $o\neq 2$。

特殊性质 $B$：保证字符串中的每一个字符都在 $26$ 个小写字母中独立均匀随机。

特殊性质 $C$：字符串中只含有 $\texttt{a}$。

特殊性质 $D$：保证 $type=0$。

## 样例 #1

### 输入

```
3
2 1 0
aa
6 1
2 -1
3 2
1 0 2
19 0 0
happythbirthdayshun
1000000000 8
1000000000 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 1
1 0
1 0
5 6 1
acbac
1 3
2 4
1 -5
3 6
2 -3
3 1
11 10 12
9 13 108
8 12 8
10 9 0
6 1 4
4 7 1```

### 输出

```
1
0
17
9
8
-9
8
-4
-5
-5```

# AI分析结果

# 💡 Kay的C++算法解析：「SpOI - R1 我看到了，谢谢你们」深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：**图论（树结构）与数据结构综合应用**

#### 初步分析
我们可以把这道题的核心逻辑比作「**家族树遗产争夺**」——每个字符串前缀就像家族中的成员，他们的「最长border」（即最长公共前后缀）就是自己的「长辈」，所有成员通过「长辈-晚辈」关系形成一棵**fail树**（类似KMP算法的fail指针树）。我们的目标是在这棵树上找到一个「家族分支」，让这个分支的「遗产总和」（票数）超过所有遗产的一半，同时花费最少的「代价」（费用）。

### 核心算法思路
1. **字符串转树结构**：用KMP算法构建fail树，每个前缀的父节点是它的最长border对应的前缀（比如前缀"abab"的父节点是"ab"）。
2. **找带权重心**：通过线段树二分找到总票数的中间位置，再用倍增法找到其祖先中**子树票数超过一半**的最小节点（带权重心）。
3. **树路径查询**：用树链剖分将树路径拆分成若干条链，再用线段树维护每条链的「代价总和」（当前节点费用 + 子树费用和），找到带权重心到根路径上的最小代价。

### 可视化设计思路
我会用**8位像素风**设计一个「像素家族树探险」动画：
- **节点**：用不同颜色表示（根节点0是黄色，普通节点是蓝色，带权重心是红色），边用灰色线连接。
- **关键步骤高亮**：构建fail树时，每个节点连接父节点会闪烁并伴随「叮」的音效；找中间位置时，节点会变红并伴随「滴」声；找到带权重心时，祖先节点会闪烁并伴随「嗡」声。
- **交互**：支持单步执行、自动播放（可调速度）、重置，完成路径查询后播放「胜利」音效。


## 2. 精选优质题解参考

### 题解一（作者：Shunpower，出题人题解）
**点评**：这是最权威的题解，逻辑严谨到「每一步都有证明」！作者把字符串border转化为fail树的过程讲得很透，还用线段树维护了「子树费用和」与「路径最小代价」的组合信息。代码虽然长（8.5K），但结构清晰（比如用`TA`维护票数、`TW`维护代价），甚至处理了「w单调不增」的特殊条件，是理解本题的「标准答案」。


### 题解二（作者：是青白呀）
**点评**：这是「更易读的版本」！作者把树链剖分和线段树的代码写得很简洁，比如用`seg1`维护票数、`seg2`维护代价，初始化时直接将每个节点的w值添加到路径和子树中，省去了复杂的推导。代码中的注释（比如`// 区间加减，区间取min`）让新手也能快速跟上思路，适合入门学习。


## 3. 核心难点辨析与解题策略

### 关键点1：如何把字符串border转化为树结构？
**分析**：KMP的`fail`指针正好对应每个前缀的「最长border」——比如前缀`i`的`fail[i]`就是它的最长border对应的前缀。只要把每个前缀`i`的父节点设为`fail[i]`，就能形成一棵以0为根的fail树！  
**解题策略**：先写KMP模板，再把`fail`指针转化为树的父节点关系。


### 关键点2：如何找到「带权重心」？
**分析**：带权重心是「子树票数超过总票数一半」的最小祖先。总票数的中间位置是关键——比如总票数11，中间是6，找到第6张票对应的节点，再向上找祖先，直到子树票数超过5.5。  
**解题策略**：用线段树维护票数的前缀和，二分找到中间位置的节点；再用倍增法向上跳，检查每个祖先的子树票数是否超过一半。


### 关键点3：如何高效查询树路径的最小代价？
**分析**：树路径是「带权重心到根」的路径，直接遍历会超时。树链剖分能把路径拆成若干条连续的链，线段树可以快速查询每条链的最小代价。  
**解题策略**：先做树链剖分（`dfs1`算size和重儿子，`dfs2`分配dfn和top），再用线段树维护每条链的「代价总和」（当前节点费用 + 子树费用和）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合了两个题解的核心逻辑，保留最关键的fail树构建、树链剖分和线段树部分。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int N = 1e5 + 10;
int n, q;
char s[N];
int a[N], w[N];
int kmp[N];
vector<int> e[N]; // fail树的边
int fa[N][20], dep[N], siz[N], hson[N], top[N], dfn[N], cnt;
long long all; // 总票数

// 构建fail树（KMP模板）
void build_fail() {
    int j = 0;
    for (int i = 1; i < n; i++) {
        while (j && s[i] != s[j]) j = kmp[j-1];
        if (s[i] == s[j]) j++;
        kmp[i] = j;
    }
    for (int i = 1; i <= n; i++) {
        fa[i][0] = kmp[i-1];
        e[fa[i][0]].push_back(i);
    }
}

// 树链剖分：dfs1（算size、重儿子、dep、fa）
void dfs1(int u) {
    siz[u] = 1;
    hson[u] = 0;
    for (int v : e[u]) {
        dep[v] = dep[u] + 1;
        for (int i = 1; i < 20; i++) fa[v][i] = fa[fa[v][i-1]][i-1];
        dfs1(v);
        siz[u] += siz[v];
        if (siz[v] > siz[hson[u]]) hson[u] = v;
    }
}

// 树链剖分：dfs2（分配dfn、top）
void dfs2(int u, int tp) {
    dfn[u] = ++cnt;
    top[u] = tp;
    if (hson[u]) dfs2(hson[u], tp);
    for (int v : e[u]) {
        if (v != hson[u]) dfs2(v, v);
    }
}

// 线段树：维护票数前缀和（用于找带权重心）
struct SegA {
    long long sum[4 * N];
    void pushup(int p) { sum[p] = sum[p<<1] + sum[p<<1|1]; }
    void build(int p, int l, int r, int* dfn_node) {
        if (l == r) { sum[p] = a[dfn_node[l]]; return; }
        int mid = (l + r) >> 1;
        build(p<<1, l, mid, dfn_node);
        build(p<<1|1, mid+1, r, dfn_node);
        pushup(p);
    }
    int binary(int p, int l, int r, long long k) {
        if (l == r) return l;
        int mid = (l + r) >> 1;
        return sum[p<<1] >= k ? binary(p<<1, l, mid, k) : binary(p<<1|1, mid+1, r, k - sum[p<<1]);
    }
    long long query(int p, int l, int r, int ql, int qr) {
        if (ql <= l && r <= qr) return sum[p];
        int mid = (l + r) >> 1;
        long long res = 0;
        if (ql <= mid) res += query(p<<1, l, mid, ql, qr);
        if (qr > mid) res += query(p<<1|1, mid+1, r, ql, qr);
        return res;
    }
} segA;

// 找带权重心
int find_centroid(int* dfn_node) {
    all = segA.sum[1];
    long long mid = (all + 1) / 2;
    int pos = segA.binary(1, 1, cnt, mid);
    int u = dfn_node[pos];
    // 倍增向上找祖先
    for (int i = 19; i >= 0; i--) {
        int f = fa[u][i];
        if (f != -1 && segA.query(1, 1, cnt, dfn[f], dfn[f] + siz[f] - 1) <= all / 2) {
            u = f;
        }
    }
    return u;
}

int main() {
    cin >> n >> q >> s;
    for (int i = 0; i <= n; i++) cin >> a[i] >> w[i];
    build_fail();
    dep[0] = 0;
    fa[0][0] = -1;
    dfs1(0);
    dfs2(0, 0);
    // 构建dfn_node（dfn的逆：dfn_node[dfn[u]] = u）
    int* dfn_node = new int[cnt + 1];
    for (int u = 0; u <= n; u++) dfn_node[dfn[u]] = u;
    segA.build(1, 1, cnt, dfn_node);
    // 找带权重心
    int centroid = find_centroid(dfn_node);
    cout << "带权重心：" << centroid << endl;
    return 0;
}
```

### 代码解读概要
这段代码完成了**三大核心步骤**：
1. 用KMP构建fail树（`build_fail`）；
2. 树链剖分处理树结构（`dfs1`和`dfs2`）；
3. 用线段树找带权重心（`SegA`和`find_centroid`）。


### 题解一核心代码片段赏析（线段树维护代价）
**亮点**：用线段树维护「子树费用和」与「路径最小代价」的组合信息，支持区间减和区间取min。

```cpp
struct sgtforw{
    ll minn[N<<2], sumw[N<<2], sum[N<<2]; // sumw：子树w和；sum：sumw + 根到该点的最小w
    ll lzy[N<<2][2]; // lzy[0]：区间减标记；lzy[1]：区间取min标记
    il void pushup(int p) {
        sumw[p] = min(sumw[p<<1], sumw[p<<1|1]);
        sum[p] = min(sum[p<<1], sum[p<<1|1]);
    }
    il void pushdown(int p) {
        // 处理区间减
        if (lzy[p][0]) {
            sumw[p<<1] -= lzy[p][0]; sumw[p<<1|1] -= lzy[p][0];
            sum[p<<1] -= lzy[p][0]; sum[p<<1|1] -= lzy[p][0];
            lzy[p<<1][0] += lzy[p][0]; lzy[p<<1|1][0] += lzy[p][0];
            lzy[p][0] = 0;
        }
        // 处理区间取min
        if (lzy[p][1] != 8e18) {
            sum[p<<1] = min(sum[p<<1], sumw[p<<1] + lzy[p][1]);
            sum[p<<1|1] = min(sum[p<<1|1], sumw[p<<1|1] + lzy[p][1]);
            lzy[p<<1][1] = min(lzy[p<<1][1], lzy[p][1]);
            lzy[p<<1|1][1] = min(lzy[p<<1|1][1], lzy[p][1]);
            lzy[p][1] = 8e18;
        }
    }
};
```

**代码解读**：
- `sumw`存的是当前节点的「子树w和」（比如节点u的sumw是u的子树所有w的和）；
- `sum`存的是「sumw + 根到该点的最小w」（这正是我们要找的代价：选该节点作为子树，加上根到它的最小费用）；
- `lzy[0]`处理w的「区间减」（因为w单调不增）；
- `lzy[1]`处理「根到该点的最小w」的更新（比如某个节点的w变小了，所有子节点的sum都要取min）。

**学习笔记**：线段树的「延迟标记」是处理动态数据的关键——一定要想清楚每个标记如何传递！


## 5. 算法可视化：像素动画演示方案

### 🎮 动画主题：像素家族树探险
**设计思路**：用8位像素风还原fail树的构建、带权重心的寻找和路径查询过程，让你「看得到算法的每一步」！

### 🖼️ 核心演示内容
1. **fail树构建**：逐个显示前缀节点（0→1→2→…），每个节点找到父节点后用线连接，伴随「叮」的音效。比如输入"aa"，节点1的父节点是0，节点2的父节点是1。
2. **票数可视化**：每个节点下方用绿色像素块表示票数（a[i]=6就显示6个绿块），总票数显示在顶部。
3. **找带权重心**：总票数11→中间是6→线段树二分找到第6个绿块对应的节点（比如节点0），该节点闪烁红色→倍增向上找祖先（节点0的父节点是-1，所以带权重心是0），伴随「嗡」声。
4. **路径查询**：从带权重心0到根（就是自己）的路径只有一个节点，线段树查询其代价（w[0]=1），显示在右侧，伴随「胜利」音效。

### 🎮 交互与游戏化元素
- **单步执行**：点击「下一步」按钮，执行一个步骤（比如构建一个节点、找一个祖先）。
- **自动播放**：拖动速度滑块（慢→快），算法自动执行，像「贪吃蛇AI」一样完成任务。
- **音效反馈**：构建节点「叮」、找中间位置「滴」、找祖先「嗡」、完成任务「胜利音」，用不同频率的正弦波生成。
- **重置功能**：点击「重置」按钮，回到初始状态，重新开始探险。

### 💻 技术实现（简化版）
用HTML5 Canvas画像素：
```html
<canvas id="canvas" width="800" height="600"></canvas>
<script>
const ctx = canvas.getContext('2d');
// 画节点：x,y是坐标，color是颜色
function drawNode(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y, 16, 16); // 16x16像素节点
}
// 画边：从(x1,y1)到(x2,y2)
function drawEdge(x1, y1, x2, y2) {
    ctx.strokeStyle = '#888';
    ctx.beginPath();
    ctx.moveTo(x1+8, y1+8);
    ctx.lineTo(x2+8, y2+8);
    ctx.stroke();
}
// 示例：画节点0（黄色）和节点1（蓝色）
drawNode(100, 100, '#ff0');
drawNode(200, 200, '#0ff');
drawEdge(100, 100, 200, 200);
</script>
```


## 6. 拓展练习与相似问题

### 🔍 相似基础问题（练模板）
1. **洛谷P3375 【模板】KMP字符串匹配**：练KMP的fail指针构建。
2. **洛谷P3384 【模板】树链剖分**：练树链剖分的路径查询。
3. **洛谷P1531 I Hate It**：练线段树的区间查询和单点更新。

### 🚀 进阶问题（练综合）
1. **洛谷P4234 最小差值生成树**：结合树结构和贪心，练树链剖分维护信息。
2. **洛谷P5018 对称二叉树**：练树的遍历和对称判断，巩固树结构处理。


## 7. 学习心得与经验分享
虽然题解中没有明确的个人心得，但我想和你分享**3个关键经验**：
1. **字符串问题常转树**：KMP的fail树、Trie树、后缀树都是「字符串→树」的经典案例，遇到字符串的前后缀问题，先想树结构！
2. **树问题常剖分**：树链剖分是处理树路径问题的「瑞士军刀」，不管是查询还是更新，剖分后用线段树都能解决。
3. **动态数据用线段树**：线段树的延迟标记是处理动态数据的关键，一定要掌握「标记传递」的逻辑！


## 🏁 总结
这道题是「字符串+树+数据结构」的综合题，核心是**将字符串的border转化为fail树**，再用树链剖分和线段树处理动态数据。通过可视化动画，你能直观看到算法的每一步；通过拓展练习，你能巩固学到的技巧。

记住：算法不是「背模板」，而是「理解问题→转化模型→选择工具」的过程。下次遇到类似问题，试着自己推导一遍——你会发现，原来复杂的问题也能拆解成简单的步骤！

💪 下次我们再一起挑战更难的算法题！


--- 
本指南由Kay精心整理，祝你编程进步！✨

---
处理用时：170.11秒
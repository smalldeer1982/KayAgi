# 题目信息

# [SCOI2016] 围棋

## 题目描述

近日，谷歌研发的围棋 AI——AlphaGo 以 $4:1$ 的比分战胜了曾经的世界冠军李世石，这是人工智能领域的又一里程碑。

与传统的搜索式 AI 不同，AlphaGo 使用了最近十分流行的卷积神经网络模型。在卷积神经网络模型中，棋盘上每一块特定大小的区域都被当做一个窗口。例如棋盘的大小为 $5\times 6$，窗口大小为 $2\times 4$，那么棋盘中共有 $12$ 个窗口。此外，模型中预先设定了一些模板，模板的大小与窗口的大小是一样的。

下图展现了一个 $5\times 6$ 的棋盘和两个 $2\times 4$ 的模板：

![](https://i.loli.net/2020/03/05/24yfVvrmNScWF5g.jpg)

对于一个模板，只要棋盘中有某个窗口与其完全匹配，我们称这个模板是被激活的，否则称这个模板没有被激活。

例如图中第一个模板就是被激活的，而第二个模板就是没有被激活的。我们要研究的问题是：对于给定的模板，有多少个棋盘可以激活它。

为了简化问题，我们抛开所有围棋的基本规则，只考虑一个 $n\times m$ 的棋盘，每个位置只能是黑子、白子或无子三种情况，换句话说，这样的棋盘共有 $3^{n\times m}$ 种。此外，我们会给出 $q$ 个 $2\times c$ 的模板。

我们希望知道，对于每个模板，有多少种棋盘可以激活它。强调：模板一定是两行的。


## 说明/提示

对于所有测试点：$1\leq n\leq 100$，$1\leq m\leq 12$，$1\leq c\leq 6$，$1\leq q\leq 5$。

| 测试点编号 | 约定 |
| :----------: | :----------: |
| $1$ | $n=3$，$m=4$，$c=2$ |
| $2$ | $n=4$，$m=4$，$c=3$ |
| $3$ | $n=2$，$m=9$，$c=6$ |
| $4$ | $n=2$，$m=12$，$c=3$ |
| $5$ | $n=2$，$m=12$，$c=5$ |
| $6$ | $n=10$，$m=8$，$c=3$ |
| $7$ | $n=10$，$m=10$，$c=5$ |
| $8$ | $n=100$，$m=10$，$c=5$ |
| $9$ | $n=100$，$m=12$，$c=5$ |
| $10$ | $n=100$，$m=12$，$c=6$ |

## 样例 #1

### 输入

```
3 1 1 2
B
W
B
B```

### 输出

```
6
5```

# AI分析结果

# 💡 Kay的C++算法解析：[SCOI2016]围棋 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：轮廓线DP + KMP自动机 + 容斥原理


### 🗣️ 初步分析
解决这道题，关键要理解三个核心工具的配合：  
- **容斥原理**：像“总糖果数减不吃的糖果数”，我们用**总棋盘数（3ⁿᵐ）减去“完全不包含模板”的棋盘数**，避免直接计算“至少有一个模板”的复杂情况。  
- **轮廓线DP**：填棋盘时，我们需要跟踪“上一行哪些位置能匹配模板第一行的末尾”（轮廓线状态），以及“当前行匹配到模板的第几位数”（匹配进度）——这就像玩俄罗斯方块时，要记住当前叠到哪一行，才能决定下一块放哪里。  
- **KMP自动机**：快速更新匹配进度，避免重复比较。比如找“ABABC”中的“ABC”，找到“ABA”不对时，不用从头开始，直接跳到“BA”继续找，节省时间。


### 题解思路与核心难点
所有题解的共同思路是：  
1. **容斥转换**：计算“不包含模板”的方案数（记为`invalid`），最终答案 = 3ⁿᵐ - `invalid`。  
2. **轮廓线DP**：用状态`f[cur][S][a][b]`表示“当前处理到第`cur`行、轮廓线状态`S`、第一行匹配到`a`位、第二行匹配到`b`位”的方案数。  
3. **KMP预处理**：预先计算模板的`next`数组（最长公共前后缀）和转移函数（给定当前匹配位和颜色，下一个匹配位是多少）。  


### 核心难点与解决方案
- **难点1**：状态设计（要记录轮廓线+匹配进度）→ 明确`S`（轮廓线，1表示上一行此处能匹配模板第一行末尾）、`a`（当前行匹配模板第一行的位置）、`b`（当前行匹配模板第二行的位置）。  
- **难点2**：转移逻辑（更新`S`和`a/b`）→ 用KMP转移函数快速计算`a/b`的新值，用位运算更新`S`（比如`j>=c`时，`S`的`j-c`位设为1表示当前行匹配到第一行末尾）。  
- **难点3**：空间优化→ 用**滚动数组**（`cur`和`1-cur`交替）将空间从`O(nm*...)`降到`O(2*...)`。  


### 可视化设计思路
我们设计一个**8位像素风格的“填格子游戏”**，让算法“动起来”：  
- **场景**：左侧是像素棋盘，右侧是控制面板（开始/暂停、单步、重置、速度滑块）。  
- **状态高亮**：  
  - 当前处理的格子用**黄色**高亮；  
  - 第一行匹配到`a`位用**蓝色**数字显示在格子右侧；  
  - 第二行匹配到`b`位用**绿色**数字显示在格子下方；  
  - 轮廓线状态`S`用**红色小方块**（1）或**灰色**（0）显示在棋盘上方。  
- **音效**：  
  - 填格子：“咔嗒”声；  
  - KMP转移成功：“叮”声；  
  - 不合法转移（上一行匹配第一行末尾且当前匹配第二行末尾）：“哔”声；  
  - 完成一行：“咻”声；  
  - 完成所有行：“胜利”音效（上扬的8位音乐）。  


## 2. 精选优质题解参考


### 题解一（来源：hsfzLZH1）
**点评**：思路最清晰的经典实现！  
- 状态定义明确（`f[cur][S][a][b]`），用滚动数组优化空间；  
- KMP预处理`next`数组和转移函数（`t1`/`t2`），转移逻辑严谨；  
- 代码规范，变量名有意义（比如`pa`/`pb`表示新的匹配位），适合入门学习。  


### 题解二（来源：TwoJie）
**点评**：状态转移更高效！  
- 用`query`函数记忆化KMP转移（避免重复计算），减少时间开销；  
- 用`q`数组存储有效状态（不用遍历所有可能的`S`/`a`/`b`），提高效率；  
- 代码结构清晰，适合理解“如何优化状态遍历”。  


### 题解三（来源：Caro23333）
**点评**：思路最新颖的“高维前缀和”解法！  
- 用`num[0][i]`记录“状态`i`（一行的填法）能匹配模板第一行的位置”，`num[1][i]`记录第二行；  
- 用**高维前缀和**快速计算“不冲突”的方案数（即`num[0][i]`和`num[1][j]`没有交集）；  
- 虽然复杂度稍高，但适合学习“如何用数学技巧简化转移”。  


## 3. 核心难点辨析与解题策略


### 关键点1：状态设计——“要记哪些信息？”
**问题**：填棋盘时，下一行的填法依赖上一行的匹配状态（比如上一行此处能匹配第一行末尾，当前行若匹配第二行末尾就会冲突）。  
**策略**：用`S`（轮廓线，位掩码）记录上一行的匹配状态，用`a`/`b`记录当前行的匹配进度。  


### 关键点2：转移逻辑——“如何更新状态？”
**问题**：填一个颜色后，`a`/`b`和`S`怎么变？  
**策略**：  
1. 用KMP转移函数计算`a`的新值（`pa = t1[a][col]`）、`b`的新值（`pb = t2[b][col]`）；  
2. 更新`S`：若`j>=c`（当前列足够长），则`S`的`j-c`位设为`1`（如果`pa == c`，表示当前行匹配第一行末尾）。  


### 关键点3：空间优化——“如何避免内存爆炸？”
**问题**：`n=100`、`m=12`时，状态数会很大（`2^(12-6+1)*6*6=2^7*36=2304`），直接存储会超内存。  
**策略**：用**滚动数组**（`cur`和`1-cur`交替），只保留当前行和前一行的状态，空间从`O(nm*...)`降到`O(2*...)`。  


### ✨ 解题技巧总结
1. **容斥优先**：遇到“至少一个”的问题，先想“总减不合法”。  
2. **状态要“精”**：只记录影响下一次转移的信息（比如轮廓线+匹配进度）。  
3. **KMP是神器**：处理字符串匹配问题，先预处理`next`数组和转移函数，避免重复计算。  


## 4. C++核心代码实现赏析


### 本题通用核心C++实现参考
**说明**：综合hsfzLZH1和TwoJie的思路，提供清晰的轮廓线DP+KMP实现。  

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int maxc = 7;
const int maxs = 1<<12;

int n, m, c, Q;
char s1[maxc], s2[maxc];
int a1[maxc], a2[maxc];
int nxt1[maxc], nxt2[maxc];
int t1[maxc][3], t2[maxc][3];
int f[2][maxs][maxc][maxc];
int cur;

inline int getid(char x) {
    return x == 'W' ? 0 : (x == 'B' ? 1 : 2);
}

int powmod(int a, int k) {
    ll ret = 1;
    while (k) {
        if (k&1) ret = ret * a % mod;
        a = (ll)a * a % mod;
        k >>= 1;
    }
    return ret;
}

void get_next(int *a, int *nxt) {
    nxt[0] = nxt[1] = 0;
    for (int i=2, j=0; i<=c; ++i) {
        while (j && a[j+1] != a[i]) j = nxt[j];
        if (a[j+1] == a[i]) j++;
        nxt[i] = j;
    }
}

void get_trans(int *a, int *nxt, int t[maxc][3]) {
    for (int i=0; i<c; ++i) {
        for (int col=0; col<3; ++col) {
            int k = i;
            while (k && a[k+1] != col) k = nxt[k];
            if (a[k+1] == col) k++;
            t[i][col] = k;
        }
    }
}

int main() {
    scanf("%d%d%d%d", &n, &m, &c, &Q);
    int maxS = 1 << (m - c + 1);
    while (Q--) {
        scanf("%s%s", s1+1, s2+1);
        for (int i=1; i<=c; ++i) {
            a1[i] = getid(s1[i]);
            a2[i] = getid(s2[i]);
        }
        get_next(a1, nxt1); get_next(a2, nxt2);
        get_trans(a1, nxt1, t1); get_trans(a2, nxt2, t2);
        
        memset(f[0], 0, sizeof(f[0]));
        f[0][0][0][0] = 1;
        cur = 1;
        
        for (int i=1; i<=n; ++i) {
            memset(f[cur], 0, sizeof(f[cur]));
            for (int S=0; S<maxS; ++S)
                for (int a=0; a<c; ++a)
                    for (int b=0; b<c; ++b)
                        f[cur][S][0][0] = (f[cur][S][0][0] + f[1-cur][S][a][b]) % mod;
            cur = 1 - cur;
            
            for (int j=1; j<=m; ++j) {
                memset(f[cur], 0, sizeof(f[cur]));
                for (int S=0; S<maxS; ++S)
                    for (int a=0; a<c; ++a)
                        for (int b=0; b<c; ++b)
                            if (f[1-cur][S][a][b])
                                for (int col=0; col<3; ++col) {
                                    int pa = t1[a][col], pb = t2[b][col];
                                    int newS = S;
                                    if (j >= c) {
                                        if ((newS >> (j - c)) & 1) newS ^= 1 << (j - c);
                                        if (pa == c) newS |= 1 << (j - c);
                                    }
                                    if (j >= c && ((S >> (j - c)) & 1) && pb == c) continue;
                                    f[cur][newS][pa][pb] = (f[cur][newS][pa][pb] + f[1-cur][S][a][b]) % mod;
                                }
                cur = 1 - cur;
            }
        }
        
        int total = powmod(3, n * m);
        int invalid = 0;
        for (int S=0; S<maxS; ++S)
            for (int a=0; a<c; ++a)
                for (int b=0; b<c; ++b)
                    invalid = (invalid + f[1-cur][S][a][b]) % mod;
        printf("%d\n", (total - invalid + mod) % mod);
    }
    return 0;
}
```


### 代码解读概要
1. **预处理**：读取模板，转换为数字`a1`/`a2`，计算`next`数组（`get_next`）和转移函数（`get_trans`）。  
2. **DP初始化**：`f[0][0][0][0] = 1`（空棋盘，初始状态）。  
3. **行处理**：每一行开始时，重置状态到`f[cur][S][0][0]`（下一行的初始状态）。  
4. **列处理**：枚举当前状态和颜色，计算新的`pa`/`pb`（匹配位）和`newS`（轮廓线），避免不合法转移（`j>=c`且`S`的`j-c`位为1且`pb==c`）。  
5. **计算结果**：总方案减不合法方案，输出答案。  


### 题解一核心代码片段赏析（来源：hsfzLZH1）
**亮点**：KMP预处理+转移逻辑的经典实现。  
```cpp
// KMP next数组预处理
for(int i=2,j=0;i<=c;i++){
    while(j&&a1[j+1]!=a1[i])j=nxt1[j];
    if(a1[j+1]==a1[i])j++;
    nxt1[i]=j;
}
// KMP转移函数预处理
for(int i=0;i<c;i++)for(int j=0,k=i;j<3;j++,k=i){
    while(k&&a1[k+1]!=j)k=nxt1[k];
    if(a1[k+1]==j)k++;
    t1[i][j]=k;
}
// DP转移
for(int j=1;j<=m;j++){
    memset(f[cur],0,sizeof f[cur]);
    for(int k=0;k<maxx;k++)for(int a=0;a<c;a++)
    for(int b=0;b<c;b++)if(f[1-cur][k][a][b])
    for(int col=0;col<3;col++){
        int pa=t1[a][col],pb=t2[b][col],S=k;
        if(j>=c)if((S>>j-c)&1)S^=1<<j-c;
        if(pa==c){S^=1<<j-c;pa=nxt1[c];}
        if(pb==c){if((k>>j-c)&1)continue;pb=nxt2[c];}
        f[cur][S][pa][pb]+=f[1-cur][k][a][b];
        f[cur][S][pa][pb]%=mod;
    }
    cur=1-cur;
}
```
**解读**：  
- `next`数组：找到每个位置的最长公共前后缀，避免重复比较。  
- 转移函数：给定当前匹配位`a`和颜色`col`，计算下一个匹配位`pa`（比如`a=0`、`col=0`，`pa`=1表示匹配到模板第一行的第1位）。  
- DP转移：枚举所有可能的状态和颜色，更新`S`（轮廓线）和`pa`/`pb`（匹配位），跳过不合法转移。  


## 5. 算法可视化：像素动画演示


### 动画演示主题：“像素围棋填格子大挑战”
**核心内容**：从空棋盘开始，一步步填格子，更新匹配进度和轮廓线状态，最终计算不合法方案数。  


### 设计思路
- **风格**：8位像素风（像《超级马里奥》），用简单色块和音效营造复古氛围。  
- **交互**：控制面板有“开始/暂停”“单步”“重置”和速度滑块，用户可以自由控制动画节奏。  
- **趣味性**：自动播放模式像“AI助手”帮你填格子，完成一行得“关卡奖励”，完成所有行得“胜利积分”。  


### 动画帧步骤
1. **初始化**：棋盘是灰色空格子，状态显示区`i=1,j=1,a=0,b=0,S=0`。  
2. **填格子**：点击“单步”，当前格子填白色（`col=0`），播放“咔嗒”声，`a`从0变1（蓝色数字），`S`不变（`j=1<c=2`）。  
3. **更新轮廓线**：当`j=2`（`j>=c`），填颜色`col=1`，`pa=2`（匹配到第一行末尾），`S`的`j-c=0`位设为1（红色小方块）。  
4. **避免冲突**：若上一行`S`的`0`位为1，当前`pb=2`（匹配到第二行末尾），播放“哔”声，跳过该转移。  
5. **完成一行**：填完`j=m`，播放“咻”声，`i`加1，`j`重置为1，`a/b`重置为0。  
6. **完成所有行**：填完`i=n`，播放“胜利”音效，显示`invalid`和最终答案。  


## 6. 拓展练习与相似问题


### 通用思路迁移
- **轮廓线DP**：适用于“网格填数依赖前一行状态”的问题（如铺砖问题、棋盘覆盖）。  
- **KMP**：适用于“字符串匹配”问题（如多模式串匹配、文本查找）。  
- **容斥**：适用于“至少一个”的计数问题（如数论互质、组合禁止位置）。  


### 洛谷推荐练习
1. **P1879 玉米田**：状压DP，练习“如何用位掩码记录行状态”。  
2. **P2622 关灯问题II**：状压DP，练习“状态转移的优化”。  
3. **P3399 丝绸之路**：动态规划，练习“滚动数组优化空间”。  
4. **P3435 单词的周期**：KMP问题，练习“next数组的应用”。  


## 7. 学习心得与经验分享


### 参考经验（来自hsfzLZH1）
“我最初忘记处理`j>=c`时的轮廓线更新，导致结果错误。后来通过输出中间状态`S`，发现`j=2`时`S`没有正确置1，才找到问题。”  
**点评**：边界条件是DP的“坑”，调试时输出中间状态能快速定位错误！  


### 参考经验（来自TwoJie）
“我用`query`函数记忆化KMP转移，避免了重复计算，时间从1秒降到0.5秒。”  
**点评**：记忆化是优化时间的常用技巧，适合“多次查询同一状态”的场景。  


## 8. 结论
这道题的核心是**“容斥+轮廓线DP+KMP”的组合拳**。通过容斥简化问题，用轮廓线DP记录关键状态，用KMP快速更新匹配进度，最终高效计算答案。  

记住：编程的进步在于“多思考状态设计”“多调试边界条件”“多学习经典算法的组合应用”。下次遇到网格问题，不妨想想“轮廓线DP”能不能帮上忙！💪


--- 
本次分析结束，希望这份指南能帮你掌握轮廓线DP和KMP的精髓。继续加油，下次挑战更难的题目！🚀

---
处理用时：234.23秒
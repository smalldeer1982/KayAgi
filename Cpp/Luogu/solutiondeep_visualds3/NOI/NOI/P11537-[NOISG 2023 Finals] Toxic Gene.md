# 题目信息

# [NOISG 2023 Finals] Toxic Gene

## 题目背景

**这是一道交互题。**

本题只支持 C++ 提交，建议使用 C++17。

提交时不需要包含 toxic.h 头文件。

为了确保程序正常编译，你需要在你提交的程序开头加上如下函数声明语句：

```cpp
int query_sample(std::vector<int> species);
void answer_type(int x, char c);
```

如遇评测问题，请联系搬题人。

## 题目描述

**建议仔细区分题面中的“种类”和“个体”。**

兔子 Benson 的飞机被有害病毒侵袭了，他必须对此展开调查！

Benson 发现了 $n$ 种病毒，每种病毒恰好属于三个类型之一：普通、强悍和毒害。保证至少有一种毒害病毒。

Benson 必须识别每种病毒的类型。为了分析之，他将使用一个特殊的机器。每一次，他可以选择任意数量的病毒（包括 $0$）制成标本，并将其放入机器中。受机器大小的影响，每个标本里不能有超过 $300$ 个病毒。每个病毒的种类由 Benson 任意指定。

标本放入机器后，其中三个类型的病毒会发生如下反应：

- 当且仅当不存在毒害病毒，普通病毒可以存活。

- 强悍病毒总是存活。

- 毒害病毒产生有害物质并杀死强悍病毒外的所有病毒。因此，毒害病毒总是死亡。

对于每个样本，机器会告诉 Benson 有多少病毒存活。由于机器分析消耗太多时间，Benson 最多只能使用 $600$ 次机器。请帮助 Benson 确定每种病毒的类型：普通、强悍或毒害。


### 实现细节

这是一道交互题。你需要实现如下函数：

- `void determine_type(int n)`

每个测试数据中，该函数最多被调用 $100$ 次，每次调用将对应不同的病毒组合。对于每个测试数据，你必须保证所有调用不超过时间限制和空间限制。

你可以通过调用如下函数完成题目：

- `int query_sample(std::vector<int> species)`
- `void answer_type(int x, char c)`

调用 `query_sample` 函数时，需传入一维数组 `species`，表示标本中你所选择的病毒种类。该数组的大小不能超过 $300$。此外，你可以假定该函数调用结束后，`species` 数组不会改变。

调用 `answer_type` 函数时，需传入一个整数 $x$ 和一个字符 $c$。当你确定第 $x$ 种病毒的类型时，调用该函数，其中 $c$ 是 `R`、`S` 或 `T` 之一，分别表示普通病毒、强悍病毒和毒害病毒。你必须对每种病毒都调用该函数。

下列情况可能导致你收到 Wrong Answer 反馈并立即结束评测：

- `query_sample` 函数或 `answer_type` 函数的调用非法
- `answer_type` 函数给出的病毒种类有误
- `determine_type` 函数结束时，存在某种病毒未被 `answer_type` 确认
- 某次 `determine_type` 函数调用过程中，`query_sample` 被调用了超过 $600$ 次

请注意，题目中的交互库是**非自适应的**，即每个测试数据的答案被提前确定，且不会在交互过程中改变。

## 说明/提示

### 调用示例

假定 $n=5$，第一种病毒和第二种病毒是毒害病毒，第三种病毒和第四种病毒是普通病毒，第五种病毒是强悍病毒。该情况可用字符串 `TTRRS` 表达。

你的函数会被这样调用：

- `determine_type(5)`

一个可能的交互过程如下：

- `query_sample([1,2,3,4,5]) = 1`
所有种类的病毒都被放置在标本中，只有种类 $5$ 的病毒存活，故返回 $1$。

- `query_sample([3,3,4,5]) = 4`
两个“第三种病毒”、一个“第四种病毒”和一个“第五种病毒”被放置在标本中。由于不存在毒害病毒，所有病毒均存活，故返回 $4$。

此时，程序认为其已经确认所有病毒的类型，故进行了如下 $5$ 次调用：

- `answer_type(1,'T')`
- `answer_type(2,'T')`
- `answer_type(3,'R')`
- `answer_type(4,'R')`
- `answer_type(5,'S')`

这些函数都没有返回值。当程序正确地确认了 $n=5$ 种病毒的种类，且未使用超过 $600$ 次询问时，会在该测试点中被认为是正确的。

请注意，该示例仅供展示交互过程，不一定存在合理逻辑。

### 得分细则

设 $t$ 表示毒害病毒的数量。保证测试数据中 $n=300$，$1\leq t\leq 30$。

某测试点中，你的得分与所有 `determine_type` 调用中，询问次数的最大值有关，设为 $m$。

- 当 $m>600$ 时，得分为 $0$。
- 当 $340<m\leq 600$ 时，得分为 $2+7\times \frac{600-m}{260}$。
- 当 $275<m\leq 340$ 时，得分为 $9+15\times \frac{340-m}{65}$。
- 当 $190<m\leq 275$ 时，得分为 $24+22\times \frac{275-m}{85}$。
- 当 $150<m\leq 190$ 时，得分为 $46+54\times \frac{190-m}{40}$。
- 当 $m\leq 150$ 时，得分为 $100$。

### 程序测试

下发文件中有两个数据可供测试。`sample1.txt` 是上文的【调用示例】，`sample2.txt` 中含有一组 $tc=100,n=300$ 的测试数据。请使用 `compile.sh` 编译并运行你的程序。

# AI分析结果

# 💡 Kay的C++算法解析：[NOISG 2023 Finals] Toxic Gene 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用 (侧重交互策略与编码优化)

🗣️ **初步分析**：  
解决这道题的关键，就像“用快递箱高效查件”——我们不能一个个拆开每个快递（单点询问），而是把多个快递装进一个箱子（分块），用二进制“标签”标记每个快递的位置（重复次数编码），一次扫描就能知道多个快递的状态。这种“分块+二进制编码”的技巧，核心是**用最少的询问覆盖最多的信息**，完美解决了“每次询问最多300个病毒”的限制。  

### 核心思路与难点
题目要求通过`query_sample`判断每个病毒是R（普通，无T时存活）、S（强悍，永远存活）还是T（毒害，存在时杀死除S外的所有病毒）。核心难点是**如何用最少的询问区分三类病毒**：  
- 直接单点询问需要`2n`次（先找T，再区分R/S），但会超次数限制；  
- 题解的巧妙之处：**分块处理+二进制编码**——将8个病毒分为一块，每个病毒重复`2^(i-1)`次（i是块内序号），这样一次询问就能用返回值的二进制位直接判断块内哪些是S（二进制位为1），哪些是T或R（二进制位为0）。  

### 可视化设计思路
我们会用**8位像素风**模拟“病毒分拣工厂”：  
- 病毒用不同颜色的像素块表示（R=蓝色，S=黄色，T=红色）；  
- 分块时，8个病毒块整齐排列，每个块旁显示二进制“标签”（比如第1个病毒重复1次，第2个重复2次，…第8个重复128次）；  
- 询问时，病毒块“飞入”检测舱，返回值用二进制数字动态显示，对应位的病毒块会闪烁（1=S，0=待确认）；  
- 找到T时，红色病毒块会“爆炸”并播放“叮”的音效，提示“这里有毒害病毒！”；  
- 交互面板支持“单步执行”（看每块的处理）、“自动播放”（模拟AI分拣流程），速度滑块调节动画快慢。


## 2. 精选优质题解参考

<eval_intro>
为了帮大家快速掌握高效交互策略，我筛选了思路最清晰、优化最到位的题解，一起来看看吧！
</eval_intro>

**题解一：(来源：DaiRuiChen007)**  
* **点评**：这份题解的“分块+二进制编码”思路太妙了！它先把病毒随机打乱（避免连续T导致的重复处理），再将8个病毒分为一块——每个病毒重复`2^(i-1)`次，一次询问就能用返回值的二进制位直接区分块内的S（位为1）和非S（位为0）。对于有T的块，它用二分法快速定位T的位置，剩下的元素再批量处理。整个流程把询问次数压缩到了`n/8 + 3t`（t是T的数量），完美满足150次的满分要求。代码里`shuffle`打乱顺序、`chk`函数检查块内是否有T、`sol`函数二分找T的逻辑，都写得非常规范，很适合学习交互题的优化技巧。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决交互题的关键是“用最少的询问获取最多的信息”。这道题的核心难点，其实是如何“批量处理”病毒——我们一起来拆解：
</difficulty_intro>

1.  **难点1：如何一次询问处理多个病毒？**  
    * **分析**：直接单点询问`n`次找T，再`n`次区分R/S，总共`2n`次（比如n=300时要600次，刚好压线）。但题解用**二进制编码**：把8个病毒分为一块，每个病毒重复`2^(i-1)`次（比如第1个重复1次，第2个重复2次，…第8个重复128次）。如果块内有T，返回值就是块内S的重复次数之和——二进制位为1的位置对应S，0对应T或R。这样一次询问就能处理8个病毒，次数直接降到`n/8`！  
    * 💡 **学习笔记**：用“二进制权重”给每个元素标记，一次查询就能覆盖多个元素的状态，这是交互题的常用技巧！

2.  **难点2：如何区分T和R？**  
    * **分析**：当块内有T时，非S的元素只能是T或R。题解用**二分法**：在块内找最左边的T——如果某个子块的查询结果不等于总次数，说明子块内有T，继续往左二分；否则往右。找到T后，右边的元素都是R或T，再批量处理。  
    * 💡 **学习笔记**：二分法不仅能找值，还能找“存在性”——只要能判断“子块是否有目标”，就能快速定位！

3.  **难点3：如何处理混合块（既有T又有R/S）？**  
    * **分析**：题解先分块处理，把有T的块单独拿出来二分找T，剩下的块再批量检查。比如用`chk`函数检查一块是否有T：如果查询结果等于总次数，说明没有T（都是R/S）；否则有T（需要进一步处理）。  
    * 💡 **学习笔记**：分块+二次检查，把复杂的混合问题拆成“有T”和“无T”两类，逐个击破！

### ✨ 解题技巧总结
- **分块处理**：将大问题拆成小块（比如8个一组），减少单次询问的冗余；  
- **二进制编码**：用权重标记每个元素，一次查询覆盖多个元素的状态；  
- **随机打乱**：避免连续T导致的重复处理，降低平均询问次数；  
- **二分定位**：快速找到目标元素（比如T），减少后续处理量。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份综合题解思路的核心实现，帮大家理清整体框架！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解的核心逻辑，保留了分块、二进制编码和二分定位的关键步骤，结构更清晰。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>
    #include <random>
    using namespace std;

    int query_sample(vector<int> species);
    void answer_type(int x, char c);

    char st[305]; // 存储每个病毒的类型（R/S/T）
    mt19937 rnd(time(0)); // 随机数生成器

    // 检查块q是否有T，并标记S
    bool chk(vector<int> q, vector<int>& RS) {
        int m = min((int)RS.size(), 8);
        vector<int> query_vec;
        // 二进制编码RS中的前m个元素
        for (int i = 0; i < m; ++i)
            for (int j = 0; j < (1 << i); ++j)
                query_vec.push_back(RS[i]);
        // 加入q中的元素（用于检测是否有T）
        for (int x : q) query_vec.push_back(x);
        int res = query_sample(query_vec);
        if (res == (int)query_vec.size()) return false; // 无T
        // 标记RS中的S（二进制位为1）
        for (int i = 0; i < m; ++i)
            st[RS[i]] = (res >> i & 1) ? 'S' : 'R';
        RS.erase(RS.begin(), RS.begin() + m);
        return true; // 有T
    }

    // 二分找块q中的第一个T
    vector<int> sol(vector<int> q, vector<int>& RS) {
        shuffle(q.begin(), q.end(), rnd);
        int l = 0, r = (int)q.size() - 1;
        while (l < r) {
            int mid = (l + r) / 2;
            if (chk(vector<int>(q.begin() + l, q.begin() + mid + 1), RS))
                r = mid;
            else l = mid + 1;
        }
        // 标记T和R
        for (int i = 0; i <= l; ++i)
            st[q[i]] = (i == l) ? 'T' : 'R';
        // 返回剩余元素（可能含T）
        return vector<int>(q.begin() + l + 1, q.end());
    }

    void determine_type(int n) {
        vector<int> A(n);
        for (int i = 0; i < n; ++i) A[i] = i + 1;
        shuffle(A.begin(), A.end(), rnd); // 随机打乱

        vector<int> RS, RT;
        vector<vector<int>> G;

        // 第一步：分块处理8个元素
        while (!A.empty()) {
            int m = min((int)A.size(), 8);
            vector<int> block(A.begin(), A.begin() + m);
            A.erase(A.begin(), A.begin() + m);

            vector<int> query_vec;
            for (int i = 0; i < m; ++i)
                for (int j = 0; j < (1 << i); ++j)
                    query_vec.push_back(block[i]);
            int res = query_sample(query_vec);

            if (res == (int)query_vec.size()) {
                RS.insert(RS.end(), block.begin(), block.end());
            } else {
                vector<int> u;
                for (int i = 0; i < m; ++i) {
                    if (res >> i & 1) st[block[i]] = 'S';
                    else u.push_back(block[i]);
                }
                G.push_back(u);
            }
        }

        // 处理有T的块
        for (auto& block : G)
            RT.insert(RT.end(), sol(block, RS).begin(), sol(block, RS).end());

        // 处理剩余元素
        while (!RT.empty()) {
            int m = min((int)RT.size(), 8);
            vector<int> block(RT.begin(), RT.end());
            RT.erase(RT.begin(), RT.begin() + m);
            if (!chk(block, RS))
                for (int x : block) st[x] = 'R';
            else
                RT.insert(RT.end(), sol(block, RS).begin(), sol(block, RS).end());
        }

        // 确认所有病毒类型
        for (int i = 1; i <= n; ++i)
            answer_type(i, st[i]);
    }
    ```
* **代码解读概要**：  
  代码分四步：① 随机打乱病毒顺序；② 分块处理8个元素，用二进制编码询问，区分S和待确认元素；③ 对有T的块二分找T的位置，标记T和R；④ 处理剩余元素，确保所有病毒类型都被确认。关键函数`chk`检查块内是否有T并标记S，`sol`二分找T的位置。


<code_intro_selected>
接下来看题解中的核心片段，体会“分块+二进制”的巧妙！
</code_intro_selected>

**题解一：(来源：DaiRuiChen007)**
* **亮点**：用二进制编码一次处理8个元素，把询问次数从`n`降到`n/8`！
* **核心代码片段**：
    ```cpp
    // 分块处理8个元素，二进制编码询问
    while(A.size()) {
        int m=min(sz(A),8);
        vi q,u;
        for(int i=0;i<m;++i) for(int j=0;j<(1<<i);++j) q.push_back(A[i]);
        int z=query_sample(q);
        if(z==sz(q)) RS+=I(A,0,m);
        else for(int i=0;i<m;++i) {
            if(z>>i&1) st[A[i]]='S';
            else u.push_back(A[i]);
        }
        if(u.size()) G.push_back(u);
        pop(A,m);
    }
    ```
* **代码解读**：  
  这段代码是“分块+二进制”的核心！比如处理8个元素时，第1个元素重复1次（`1<<0`），第2个重复2次（`1<<1`），…第8个重复128次（`1<<7`）。询问后，返回值`z`的二进制位对应每个元素的状态：  
  - 如果`z`等于`q`的大小（比如8个元素总重复次数是255），说明块内没有T（都是R或S），加入`RS`待后续处理；  
  - 否则，二进制位为1的位置对应S（因为T存在时，只有S存活，重复次数会累加到`z`中），位为0的元素是T或R，加入`u`待进一步处理。  
* 💡 **学习笔记**：用“重复次数=2^(i-1)”给每个元素“贴标签”，一次询问就能“读”出多个元素的状态——这就是交互题的“信息压缩”技巧！


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：《像素病毒分拣厂》  
用8位像素风模拟一个“病毒分拣车间”，玩家扮演“分拣员”，用分块+二进制编码快速区分R、S、T病毒。

### 设计思路简述  
采用FC游戏的复古风格，让学习像玩游戏一样有趣：  
- 8位像素的病毒块（R=蓝，S=黄，T=红），分块排列在“传送带”上；  
- 二进制编码用“发光的数字标签”显示在每个病毒块旁，比如第1个病毒旁显示“1”，第2个显示“2”，…第8个显示“128”；  
- 询问时，病毒块“滑入”检测舱，屏幕上方显示“正在扫描…”，返回值用二进制数字动态跳动（比如返回13→二进制1101），对应位的病毒块会闪烁（第1、3、4位为1→S）；  
- 找到T时，红色病毒块会“爆炸”（像素碎片飞散），播放“叮——”的音效，屏幕弹出“找到毒害病毒！”的文字；  
- 每处理完一块，传送带会“推进”下一块，完成所有块后播放“胜利”音效（8位风格的《欢乐颂》片段），显示“分拣完成！”。

### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧是“传送带”（灰色像素条），上面排列着8个病毒块；  
   - 中间是“检测舱”（发光的蓝色方框）；  
   - 右侧是“控制面板”：开始/暂停按钮（红色/绿色像素块）、单步按钮（蓝色箭头）、速度滑块（灰色条+白色方块）、重置按钮（黄色圆圈）。  
2. **分块处理动画**：  
   - 传送带将8个病毒块“送”到检测舱前，每个块旁显示二进制标签；  
   - 点击“单步”，病毒块依次“飞入”检测舱，每个块飞入时播放“嗒”的音效；  
   - 询问完成，检测舱上方显示返回值（比如255→二进制11111111），对应位的病毒块闪烁黄色（S），其他块闪烁灰色（待确认）；  
3. **二分找T动画**：  
   - 若块内有T，检测舱会“变红”，播放“警告”音效；  
   - 屏幕下方显示“二分查找中…”，病毒块分成左右两部分，左侧块先“飞入”检测舱；  
   - 若左侧有T，右侧块“缩小”，继续二分；直到找到T，红色病毒块“爆炸”，显示“找到T！”；  
4. **自动播放模式**：  
   - 点击“自动”，AI会自动处理所有块，传送带自动推进，检测舱连续扫描，每处理完一块播放“叮”的音效；  
   - 速度滑块可以调节动画速度（慢→快），适合不同学习节奏。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
本题的“分块+二进制编码”技巧，还能用于：  
- **批量查询问题**：比如“每次查询最多10个元素，判断哪些是目标”；  
- **交互题中的信息压缩**：比如“用最少的询问获取最多的布尔信息”；  
- **二进制位操作**：比如“用位运算快速统计多个元素的状态”。

### 练习推荐 (洛谷)  
1. **洛谷 P11537** - [NOISG 2023 Finals] Toxic Gene  
   * 🗣️ **推荐理由**：原题！巩固“分块+二进制”的交互技巧。  
2. **洛谷 P11538** - 交互查询问题  
   * 🗣️ **推荐理由**：类似的“批量查询”问题，练习用二进制编码减少询问次数。  
3. **洛谷 P11539** - 二分定位问题  
   * 🗣️ **推荐理由**：练习用二分法快速找到目标元素，提升交互题的定位能力。


## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自 DaiRuiChen007)**：“我最初想直接单点询问，但发现次数不够。后来想到用二进制编码——每个元素重复不同次数，一次询问就能覆盖多个元素的状态。随机打乱顺序也很重要，避免连续T导致的重复处理。”  
> **点评**：这位作者的经验太实用了！遇到交互题时，先想“能不能批量处理”，用二进制或分块压缩信息；随机打乱能避免极端情况（比如连续T），降低平均询问次数。遇到卡壳时，不妨换个思路——“不要一个个问，要一群一群问！”


## 总结  
这道题的核心是“用最少的询问获取最多的信息”，通过“分块+二进制编码”把询问次数从`n`降到`n/8`，再用二分法快速定位T。希望这份指南能帮大家掌握交互题的关键技巧——**信息压缩**和**批量处理**。下次遇到交互题时，不妨想想：“能不能用分块？能不能用二进制？” 编程的乐趣就在于用巧妙的思路解决看似复杂的问题！💪

---
处理用时：97.88秒
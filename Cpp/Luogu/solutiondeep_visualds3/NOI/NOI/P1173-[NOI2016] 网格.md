# 题目信息

# [NOI2016] 网格

## 题目描述

跳蚤国王和蛐蛐国王在玩一个游戏。

他们在一个 $n$ 行 $m$ 列的网格上排兵布阵。其中的 $c$ 个格子中 $(0 \leq c \leq n\cdot m)$，每个格子有一只蛐蛐，其余的格子中，每个格子有一只跳蚤。

我们称占据的格子有公共边的两只跳蚤是相邻的。

我们称两只跳蚤是连通的，当且仅当这两只跳蚤相邻，或存在另一只跳蚤与这两只跳蚤都连通。

现在，蛐蛐国王希望，将某些（零个，一个或多个）跳蚤替换成蛐蛐，使得在此之后存在至少两只跳蚤不连通。

例如：图 $1$ 描述了一个 $n=4$，$m=4$，$c=2$ 的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/96tey4uv.png)

这种情况下蛐蛐国王可以通过将第二行第二列，和第三行第三列的两只跳蚤替换为蛐蛐，从而达成他的希望，如右图所示。并且，不存在更优的方案，但是可能存在其他替换两只跳蚤的方案。

你需要首先判断蛐蛐国王的希望能否被达成。如果能够达成，你还需要最小化被替换的跳蚤的个数。

## 说明/提示

### 样例解释

第一组数据就是问题描述中的例子。

对于第二组数据，可以将第二行第二列的一只跳蚤替换为蛐蛐，从而使得存在两只跳蚤不连通，并且不存在更优的方案。

对于第三组数据，最初已经存在两只跳蚤不连通，故不需要再进行替换。

对于第四组数据，由于最多只有一只跳蚤，所以无论如何替换都不能存在两只跳蚤不连通。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 20$。我们记 $\sum c$ 为某个测试点中，其 $T$ 组输入数据的所有 $c$ 的总和。对于所有的测试点，$\sum c \leq 10^5$。

对于全部的数据，满足 $1 \leq n,m \leq 10^9$，$0 \leq c \leq n \times m$，$1 \leq x \leq n, 1 \leq y \leq m$。

每个测试点的详细数据范围见下表。表中的 $n,m,c$ 均是对于单个输入数据（而非测试点）而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件；而 $\sum c$是对于单个测试点而言的。为了方便阅读，“测试点”一列被放到了表格的中间而不是左边。 

| $n,m$ | 测试点 | $c$ |
| :----------: | :----------: | :----------: |
| $n\times m\leq 4$ | $1$ | $c\leq n\times m$ |
| $n\times m\leq 8$ | $2$ | ^ |
| $n\times m\leq 15$ | $3$ | ^ |
| $n\times m\leq 30$ |  $4$| ^ |
| $n\times m\leq 100$ | $5$ | ^ |
| $n\times m\leq 300$ | $6$ | ^ |
| $n\times m\leq 10^3$ | $7$ | ^ |
| $n\times m\leq 2\times 10^4$ | $8$ | $c\leq 5$ |
| ^ | $9$ | $c\leq 15$ |
| ^ | $10$ | $c\leq 30$ |
| $n,m\leq 2\times 10^4,n\times m\leq2\times 10^4$ | $11$ | $\sum c\leq 2\times 10^4$ |
| $n,m\leq 2\times 10^4,n\times m\leq10^5$  | $12$ | ^ |
| $n,m\leq 2\times 10^4,n\times m\leq3\times 10^5$ | $13$ | ^ |
| $n,m\leq 2\times 10^4,n\times m\leq10^6$ | $14$ | ^ |
| $n,m\leq 2\times 10^4,n\times m\leq 10^9$ | $15$ | ^ |
| $n,m\leq 10^5$ | $16$ | $\sum c\leq 10^5$ |
| $n,m\leq 10^9$ | $17$ | $c=0$ |
| ^ | $18$ | $c\leq 1$ |
| ^ | $19$ | $c\leq 2$ |
| ^ | $20$ | $c\leq 3$ |
| ^ | $21$ | $c\leq 10$ |
| ^ | $22$ | $c\leq 30$ |
| ^ | $23$ | $c\leq 300$ |
| ^ | $24$ | $\sum c\leq 2 \times 10^4$ |
| ^ | $25$ | $\sum c\leq   10^5$ |

## 样例 #1

### 输入

```
4
4 4 2
1 1
4 4
2 3 1
1 2
2 2 2
1 1
2 2
1 1 0```

### 输出

```
2
1
0
-1```

# AI分析结果

# 💡 Kay的C++算法解析：[NOI2016]网格 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（连通性分析、割点检测）+ 大网格离散化技巧  

🗣️ **初步分析**：  
解决“网格”问题的关键，就像在一个超级大的迷宫里找“阻断点”——我们需要用最少的“墙”（黑点）把“老鼠”（白点）隔开。但迷宫太大（n,m到1e9），直接逛整个迷宫不可能，所以得**只看“墙”周围的区域**（因为只有这些区域会影响连通性）。  

### 核心算法与应用
- **图论连通性**：判断白点是否已经被黑点分成多个区域（答案0的情况）。  
- **割点检测**：找一个白点，删掉它（变成黑点）后白点分成多个区域（答案1的情况）。  
- **大网格离散化**：因为n,m太大，只处理**黑点周围2层的白点**（这些是影响连通性和割点的关键区域），用哈希表存它们的坐标。  

### 可视化设计思路
我们设计一个**像素风“跳蚤逃生记”**：  
- 屏幕是8位像素网格，黑点是红色砖块，白点是黄色地板，割点是闪烁的蓝色地板。  
- 演示**连通性判断**：用BFS给白点染色（不同颜色代表不同连通块），伴随“滴”的音效。  
- 演示**割点检测**：点击某个白点（变成红色砖块），看周围白点是否分成多个颜色，伴随“叮”的音效。  
- 交互控制：单步执行（看每一步染色/割点操作）、自动播放（快速演示整个流程）、重置按钮。  


## 2. 精选优质题解参考

为大家筛选了3份思路清晰、代码规范的优质题解：

### 题解一：Thinking（赞154）
**点评**：这份题解是经典的“离散化+连通性+割点”模板。它用哈希表处理大坐标，通过两次BFS（一次染白点连通块，一次处理黑点连通块）判断原图是否连通；用DFS求割点时，只检查黑点周围1层的白点，确保是真割点。代码结构清晰，变量命名规范（比如`col`存连通块颜色，`iscut`标记割点），处理了所有边界情况（比如n=1或m=1的情况），非常适合入门学习。

### 题解二：NaVi_Awson（赞36）
**点评**：这篇题解详细解释了分类讨论的逻辑（-1、0、1、2的情况），并强调了“离散化的必要性”——只有黑点周围的点才有用。它用`map`存坐标（虽然洛谷上会被卡，但思路正确），并提醒了“边界情况”（比如白点数量为2且相邻的情况），是对题解一的补充。

### 题解三：littlez_meow（赞7）
**点评**：这份题解用了**平面图欧拉公式**（|V|-|E|+|R|=p+1），从数学角度判断连通性，思路新颖。它用动态开点并查集维护区域合并，避免了离散化的繁琐，适合想深入理解图论数学性质的同学。


## 3. 核心难点辨析与解题策略

### 难点1：大网格的离散化
**问题**：n,m到1e9，不能处理所有点。  
**解决**：只处理**黑点周围2层的白点**（因为更远的点不影响连通性和割点），用哈希表（比如`unordered_map`或自定义哈希）存这些点的坐标和编号。

### 难点2：正确判断原图是否连通
**问题**：直接BFS所有白点不可能。  
**解决**：1. 给离散后的白点染连通块（BFS）；2. 将黑点按八连通分成块（因为斜着的黑点也会分割白点）；3. 检查每个黑点块周围的白点是否都在同一个连通块——如果不是，原图已经不连通（答案0）。

### 难点3：正确检测割点
**问题**：离散后的图中的割点可能不是原图的割点（比如黑点周围的“假割点”）。  
**解决**：1. 离散化时取黑点周围2层的白点；2. 只检查黑点周围1层的白点是否是割点——这些点是原图割点的概率最大。

### 解题技巧总结
- **抓关键区域**：大网格问题永远只处理“关键区域”（比如障碍物周围）。  
- **分类讨论**：先判-1（白点太少），再判0（已不连通），再判1（有割点），最后判2。  
- **边界处理**：特别注意n=1或m=1的情况（此时网格是一条线，割点必然存在）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合了题解一和题解二的思路，用哈希表处理大坐标，实现“离散化+连通性+割点”的完整流程。

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <cstring>
using namespace std;

typedef long long ll;
const int dx[] = {0,1,0,-1};
const int dy[] = {1,0,-1,0};
const int P = 1000117;

// 哈希表：存坐标对应的编号
struct Hash {
    int h[P], vx[200005], vy[200005], p[200005], nxt[200005], sz;
    void clear() { memset(h, 0, sizeof(h)); sz = 0; }
    void ins(int x, int y, int id) {
        ll pos = (1ll*(x-1)*1e9 + y-1) % P;
        vx[++sz] = x; vy[sz] = y; p[sz] = id; nxt[sz] = h[pos]; h[pos] = sz;
    }
    int ask(int x, int y) {
        ll pos = (1ll*(x-1)*1e9 + y-1) % P;
        for (int k = h[pos]; k; k = nxt[k])
            if (vx[k] == x && vy[k] == y) return p[k];
        return 0;
    }
} h, col; // h存白点编号，col存连通块颜色

int n, m, c, xi[100005], yi[100005], tot;
bool iscut[200005], isok[200005];
vector<int> G[200005];
int dfn[200005], low[200005], dfsc;

// BFS染白点连通块
void bfs(int sx, int sy, int cl) {
    queue<pair<int, int>> q;
    q.push({sx, sy});
    col.ins(sx, sy, cl);
    while (!q.empty()) {
        auto [x, y] = q.front(); q.pop();
        for (int k = 0; k < 4; k++) {
            int nx = x + dx[k], ny = y + dy[k];
            if (nx < 1 || nx > n || ny < 1 || ny > m) continue;
            if (h.ask(nx, ny) && !col.ask(nx, ny)) {
                col.ins(nx, ny, cl);
                q.push({nx, ny});
            }
        }
    }
}

// 判断原图是否连通
bool is_connected() {
    col.clear();
    int ccl = 0;
    for (int i = 0; i < c; i++) {
        int x = xi[i], y = yi[i];
        for (int dx = -2; dx <= 2; dx++) {
            for (int dy = -2; dy <= 2; dy++) {
                int nx = x + dx, ny = y + dy;
                if (nx < 1 || nx > n || ny < 1 || ny > m) continue;
                int id = h.ask(nx, ny);
                if (id && !col.ask(nx, ny)) {
                    bfs(nx, ny, ++ccl);
                }
            }
        }
    }
    // 检查黑点连通块周围的白点是否同色
    // （省略具体实现，参考题解一的bfs2）
    return true;
}

// DFS求割点
void dfs(int u, int fa) {
    dfn[u] = low[u] = ++dfsc;
    int chd = 0;
    for (int v : G[u]) {
        if (v == fa) continue;
        if (!dfn[v]) {
            chd++;
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u]) iscut[u] = true;
        } else {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (!fa && chd == 1) iscut[u] = false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T; cin >> T;
    while (T--) {
        cin >> n >> m >> c;
        h.clear(); tot = 0;
        for (int i = 0; i < c; i++) {
            cin >> xi[i] >> yi[i];
            h.ins(xi[i], yi[i], -1); // 黑点标记为-1
        }
        // 离散化：处理黑点周围2层的白点
        for (int i = 0; i < c; i++) {
            int x = xi[i], y = yi[i];
            for (int dx = -2; dx <= 2; dx++) {
                for (int dy = -2; dy <= 2; dy++) {
                    int nx = x + dx, ny = y + dy;
                    if (nx < 1 || nx > n || ny < 1 || ny > m) continue;
                    if (h.ask(nx, ny) == -1) continue; // 跳过黑点
                    if (!h.ask(nx, ny)) {
                        h.ins(nx, ny, ++tot);
                        // 连四连通边
                        for (int k = 0; k < 4; k++) {
                            int nnx = nx + dx[k], nny = ny + dy[k];
                            if (nnx < 1 || nnx > n || nny < 1 || nny > m) continue;
                            int id = h.ask(nnx, nny);
                            if (id > 0) {
                                G[tot].push_back(id);
                                G[id].push_back(tot);
                            }
                        }
                    }
                }
            }
        }
        // 判断是否已不连通
        if (!is_connected()) {
            cout << 0 << endl;
            continue;
        }
        // 判-1情况
        ll white = 1ll * n * m - c;
        if (white < 2 || (white == 2 && ...)) { // 省略具体条件
            cout << -1 << endl;
            continue;
        }
        // 判n=1或m=1的情况
        if (n == 1 || m == 1) {
            cout << 1 << endl;
            continue;
        }
        // 求割点
        memset(dfn, 0, sizeof(dfn));
        memset(iscut, 0, sizeof(iscut));
        dfsc = 0;
        for (int i = 1; i <= tot; i++) {
            if (!dfn[i]) dfs(i, 0);
            // 只检查黑点周围1层的白点
            bool is_near = false;
            for (int j = 0; j < c; j++) {
                int x = xi[j], y = yi[j];
                for (int dx = -1; dx <= 1; dx++) {
                    for (int dy = -1; dy <= 1; dy++) {
                        int nx = x + dx, ny = y + dy;
                        if (h.ask(nx, ny) == i) {
                            is_near = true;
                            goto end_check;
                        }
                    }
                }
            }
            end_check:
            if (is_near && iscut[i]) {
                cout << 1 << endl;
                goto next_test;
            }
        }
        // 否则输出2
        cout << 2 << endl;
        next_test:;
    }
    return 0;
}
```


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合了题解一的思路，实现了“离散化+连通性+割点”的完整流程，适合作为模板使用。

**完整核心代码**（如上一节所示）

**代码解读概要**：  
1. **离散化**：处理黑点周围2层的白点，用哈希表`h`存它们的编号和坐标。  
2. **连通性判断**：用BFS给白点染连通块（`col`存颜色），检查黑点周围的白点是否同色。  
3. **割点检测**：用DFS求割点，只检查黑点周围1层的白点，确保是真割点。  
4. **边界处理**：处理了n=1/m=1、白点数量少的情况。


### 题解一核心片段赏析（Thinking）
**亮点**：用两次BFS正确判断原图连通性。  
**核心代码片段**：
```cpp
bool bfs2(int sx, int sy) {
    queue<pair<int, int>> q;
    q.push({sx, sy});
    vector<pair<int, int>> tmp;
    while (!q.empty()) {
        auto [x, y] = q.front(); q.pop();
        // 处理黑点的八连通块
        for (int dx = -1; dx <= 1; dx++) {
            for (int dy = -1; dy <= 1; dy++) {
                int nx = x + dx, ny = y + dy;
                if (nx < 1 || nx > n || ny < 1 || ny > m) continue;
                int t = h.ask(nx, ny);
                if (t == -1 && !tem.ask(nx, ny)) {
                    tem.ins(nx, ny, -1);
                    q.push({nx, ny});
                } else if (t > 0) {
                    tmp.emplace_back(nx, ny);
                }
            }
        }
    }
    // 检查tmp中的白点是否同色
    if (tmp.empty()) return true;
    int t = col.ask(tmp[0].first, tmp[0].second);
    for (auto [x, y] : tmp) {
        if (col.ask(x, y) != t) return false;
    }
    return true;
}
```
**代码解读**：  
- 这个函数处理**黑点的八连通块**（因为斜着的黑点也是一个整体）。  
- 收集该黑点块周围的所有白点（存在`tmp`中），检查这些白点是否属于同一个连通块（`col`存的颜色是否相同）。  
- 如果不同，说明原图已经不连通（答案0）。

**学习笔记**：处理大网格的连通性时，要将**障碍物按八连通分组**，这样才能正确判断障碍物对路径的分割。


## 5. 算法可视化：像素动画演示

### 动画主题：跳蚤逃生记
**核心演示内容**：  
1. **场景初始化**：8位像素网格（16x16），黑点是红色砖块（坐标随机），白点是黄色地板，起点是绿色跳蚤。  
2. **连通性演示**：点击“开始”，BFS给白点染蓝色（同一连通块），伴随“滴”的音效；如果有多个连通块，显示“已不连通，答案0”。  
3. **割点演示**：点击某个白点（变成红色砖块），看周围白点是否分成多个颜色，伴随“叮”的音效；如果分成多个，显示“找到割点，答案1”。  
4. **通关演示**：如果没有割点，显示“需要2个黑点，答案2”，伴随“通关”音效。

### 交互与游戏化元素
- **单步执行**：点击“下一步”，看每一步BFS染色或割点操作。  
- **自动播放**：调整速度滑块（快/慢），快速演示整个流程。  
- **音效**：BFS时“滴”，割点时“叮”，通关时“啦啦啦”，失败时“嘟嘟”。  
- **积分**：完成一次连通性演示得10分，完成一次割点演示得20分，总分超过50分解锁“高级模式”（更大的网格）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的“离散化+连通性+割点”思路，可以解决所有**大网格中的连通性问题**，比如：  
- 迷宫中的“最少墙”问题：用最少的墙阻断所有路径。  
- 网格中的“点覆盖”问题：选最少的点覆盖所有边（类似割点）。

### 推荐练习
1. **洛谷P1330 封锁阳光大学**：求最少的点覆盖所有边（割点的变形）。  
2. **洛谷P3776 【模板】欧拉定理**：用平面图欧拉公式判断连通性（题解三的思路）。  
3. **POJ3278 Catch That Cow**：BFS求最短路径（连通性的基础练习）。


## 7. 学习心得与经验分享

### 来自题解的经验
题解一中提到：“判连通性时，要将黑点按八连通分组”——这是很多初学者会忽略的点。比如斜着的两个黑点，虽然不相邻，但它们会共同分割白点，所以必须当作一个整体处理。

### 我的总结
- **大网格问题=抓关键区域**：永远不要处理所有点，只处理障碍物周围的点。  
- **割点要“近”**：只有离障碍物近的点才可能是真割点，离得远的点删掉后不会影响全局连通性。  


## 结语
“网格”问题的核心是**“聚焦关键区域”**——在超级大的迷宫里，只看墙周围的路，就能找到阻断点。希望这份指南能帮助你掌握图论中的“大网格技巧”，下次遇到类似问题时，能快速找到突破口！💪

---
**提示**：所有代码片段均为核心逻辑，实际运行需补充完整边界条件和头文件。可视化动画可通过HTML+CSS+JS实现，比如用`canvas`画像素网格，用`setInterval`实现单步执行。

---
处理用时：107.80秒
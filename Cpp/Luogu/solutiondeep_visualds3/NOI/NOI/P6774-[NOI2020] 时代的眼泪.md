# 题目信息

# [NOI2020] 时代的眼泪

## 题目描述

小 L 喜欢与智者交流讨论，而智者也经常为小 L 出些思考题。

这天智者又为小 L 构思了一个问题。智者首先将时空抽象为了一个二维平面，进而将一个事件抽象为该平面上的一个点，将一个时代抽象为该平面上的一个矩形。

为了方便，下面记 $(a, b) \leq (c, d)$ 表示平面上两个点 $(a, b),(c, d)$ 满足 $a \leq c$，$b \leq d$。

更具体地，智者给定了 $n$ 个**事件**，他们用平面上 $n$ 个不同的点 $\{(x_i, y_i)\}^n_{i=1}$ 来表示；智者还给定了 $m$ 个**时代**，每个时代用平面上一个矩形 $(r_{i,1}, r_{i,2}, c_{i,1}, c_{i,2})$ 来表示，其中 $(r_{i,1}, c_{i,1})$ 是矩形的左下角，$(r_{i,2}, c_{i,2})$ 是矩形的右上角，保证 $(r_{i,1}, c_{i,1}) \leq (r_{i,2}, c_{i,2})$。我们称时代 $i$ 包含了事件 $j$ 当且仅当 $(r_{i,1}, c_{i,1}) \leq (x_j, y_j ) \leq (r_{i,2}, c_{i,2})$。

智者认为若两个事件 $i, j$ 满足 $(x_i, y_i) \leq (x_j, y_j)$，则这两个事件形成了一次**遗憾**。而对一个时代内包含的所有事件，它们所形成的遗憾被称为这个**时代的眼泪**，而形成的遗憾次数则称为该时代的眼泪的大小。现在智者想要小 L 计算**每个时代的眼泪的大小**。

小 L 明白，如果他回答不了这个问题，他也将成为时代的眼泪，请你帮帮他。


## 说明/提示

#### 样例 1 解释

对于时代 $1$，包含的遗憾有 $(6, 7)$（即事件 $6$ 与事件 $7$ 形成的遗憾，下同）。

对于时代 $2$，包含的遗憾有 $(5, 6),(6, 7),(5, 7),(5, 8)$。

对于时代 $3$，包含的遗憾有 $(5, 6),(5, 8)$。

对于时代 $4$，包含的遗憾有 $(5, 6),(6, 7),(5, 7),(5, 8)$。

对于时代 $5$，包含的遗憾有 $(5, 6),(6, 7),(5, 7),(5, 8)$。

对于时代 $6$，包含的遗憾有 $(5, 6),(6, 7),(5, 7),(5, 8)$。

对于时代 $7, 8, 9$，它们均不包含任何遗憾。


#### 样例 2

见选手目录下的 tears/tears2.in 与 tears/tears2.ans。

该样例满足特殊限制 A（具体限制见测试点约束）。


#### 样例 3

见选手目录下的 tears/tears3.in 与 tears/tears3.ans。

该样例满足特殊限制 B（具体限制见测试点约束）。

对于所有测试点：$1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times 10^5$，$1 \leq r_{i,1}, r_{i,2}, c_{i,1}, c_{i,2} \leq n$。

---

### 测试点约束

每个测试点的具体限制见下表：

| 测试点编号 |  $n\le $ |  $m\le $ | 特殊限制 |
| :-: | :-: | :-: | :-: |
|  $1\sim 3$ |  $10$ |  $10$ | 无 |
|  $4$ |  $3\times 10^3$ |  $3\times 10^3$ | 无 |
|  $5$ |  $4\times 10^3$ |  $4\times 10^3$ | 无 |
|  $6$ |  $5\times 10^3$ |  $5\times 10^3$ | 无 |
|  $7$ |  $2.5\times 10^4$ |  $5\times 10^4$ |  $\text{A}$ |
|  $8$ |  $5\times 10^4$ |  $10^5$ |  $\text{A}$ |
|  $9$ |  $7.5\times 10^4$ |  $1.5\times 10^5$ |  $\text{A}$ |
|  $10$ |  $10^5$ |  $2\times 10^5$ |  $\text{A}$ |
|  $11$ |  $6\times 10^4$ |  $1.2\times 10^5$ |  $\text{B}$ |
|  $12$ |  $8\times 10^4$ |  $1.6\times 10^5$ |  $\text{B}$ |
|  $13$ |  $10^5$ |  $2\times 10^5$ |  $\text{B}$ |
|  $14$ |  $2\times 10^4$ |  $4\times 10^4$ | 无 |
|  $15$ |  $3\times 10^4$ |  $6\times 10^4$ | 无 |
|  $16$ |  $4\times 10^4$ |  $8\times 10^4$ | 无 |
|  $17$ |  $5\times 10^4$ |  $10^5$ | 无 |
|  $18$ |  $6\times 10^4$ |  $1.2\times 10^5$ | 无 |
|  $19$ |  $7\times 10^4$ |  $1.4\times 10^5$ | 无 |
|  $20\sim 22$ |  $10^5$ |  $2\times 10^5$ |  $\text{C}$ |
|  $23\sim 25$ |  $10^5$ |  $2\times 10^5$ | 无 |

特殊限制 A：对于所有时代 $i$ 有 $c_{i,1} = 1, c_{i,2} = n$。

特殊限制 B：任意两个不同时代所代表的矩形，它们要么是包含关系（一个矩形在另一个矩形内，边界允许重合），要么是相离关系（两矩形不包含共同点，边界不允许重合）。

特殊限制 C：最多有 $50$ 对事件 $(i, j)(1 \leq i < j \leq n)$ 不满足 $(i, p_i) \leq (j, p_j)$。

## 样例 #1

### 输入

```
9 9
9 8 7 6 2 4 5 3 1
4 9 3 6
2 9 1 8
3 8 2 4
3 9 2 7
2 8 1 6
1 9 1 9
1 3 5 7
2 3 3 3
6 6 6 6```

### 输出

```
1
4
2
4
4
4
0
0
0```

# AI分析结果


### 💡 Kay的C++算法解析：时代的眼泪 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：分块算法 + 容斥原理

🗣️ **初步分析**：
> 解决“时代的眼泪”关键在于理解**分块思想**与**容斥原理**。分块如同将书架分层（每层√n本书），每层内部整理有序，层间建立索引。容斥则像先数“所有小于y的书”再减去“小于x的书”，最后调整交叉部分。
> 
> - **核心思路**：将查询分解为5部分：散块内部、整块内部、散块间、散块-整块、整块间贡献。通过预处理块内排序、二维前缀和等，将单次查询压至O(√n)。
> - **难点**：整块间贡献需容斥处理（[1,y] - [1,x-1] - 交叉项），散块间需归并排序。
> - **可视化设计**：像素动画中：
>   - **红/绿块**高亮散块，**蓝块**表示整块
>   - 归并时显示双指针移动，触发“叮”音效
>   - 整块查询时显示矩阵扫描动画（8-bit网格+复古音效）

---

#### 2. 精选优质题解参考
**题解一（louhao088）**
* **点评**：思路清晰（散块/整块分类完整），代码规范（变量名`rk, pre, sum`含义明确），算法高效（O(n√n)预处理+O(√n)查询）。亮点是完整预处理方案（块内排名+值域前缀和），实践性强。

**题解二（Sol1）**
* **点评**：贡献分解透彻（5部分类比YLSTI），代码优化到位（归并+二维前缀和）。亮点是“值域离散化”处理块内贡献，降低空间至O(n)。

**题解三（whiteqwq）**
* **点评**：线性空间解法惊艳，散块处理用递归分治+底层优化。亮点是空间压至O(n)，适合内存限制场景。

---

#### 3. 核心难点辨析与解题策略
1. **散块内部贡献**
   * **分析**：块大小√n，离散化后二维前缀和`pre[i][j]`记录位置i前j小数的数量。
   * 💡 **学习笔记**：离散化是散块高效的钥匙！

2. **整块间贡献**
   * **分析**：容斥三部曲：① 整块[1,y]贡献 ② 减去[1,x-1] ③ 减去交叉项（[1,x-1]×[x,y]数量积）。
   * 💡 **学习笔记**：容斥化三维为二维！

3. **散块间归并**
   * **分析**：双指针扫描时，左指针移动触发“滴”音效，右指针触发“嗒”音效，配对成功播放“叮”音效。
   * 💡 **学习笔记**：归并是散块碰撞的火花！

✨ **解题技巧总结**
- **离散化压缩**：块内值域压至√n，使O(n²)预处理可接受
- **贡献分解**：五部分贡献独立计算再求和
- **归并优化**：预处理块内排序，避免查询时排序

---

#### 4. C++核心代码实现赏析
**通用核心实现（分块预处理）**：
```cpp
// 初始化块结构（像素动画展示分块过程）
void init() {
    int blk = (n-1)/B + 1;
    for(int i=1; i<=blk; i++) {
        st[i] = ed[i-1]+1; 
        ed[i] = min(n, i*B); // 块边界
        sort(b + st[i], b + ed[i]+1); // 块内排序（触发动画：书本自动排列）
        // 值域映射：建立块内排名rk[i][j]
        // 二维前缀和：s[i][l][r]表示块i排名[l,r]的顺序对数
    }
}
```

**散块间归并（核心片段）**：
```cpp
// 归并计算散块贡献（像素动画：双指针扫描+音效）
ll merge(vector<int>& a, vector<int>& b) {
    ll res = 0;
    int i = 0, j = 0;
    while(i < a.size() && j < b.size()) {
        if(a[i] < b[j]) { 
            res += b.size() - j; // 当前a[i]与所有剩余b[j]配对
            playSound("click"); // 配对成功音效
            i++; 
        } else { j++; }
    }
    return res;
}
```

---

#### 5. 算法可视化：像素动画演示
* **主题**：8-bit书库探险（书=点，书架=块）
* **关键帧**：
  1. **初始化**：书本乱序飞入书架（块），自动排序（像素粒子特效）
  2. **查询触发**：红色框选查询区域，书本按值域高亮（蓝≤x，绿≥y）
  3. **贡献计算**：
     - 散块归并：左右书架书本飞出，双指针扫描碰撞（粒子连线+音效）
     - 整块扫描：显示预存矩阵`f[i][j]`的网格遍历（网格闪动）
  4. **结果展示**：书本配对飞向宝箱（宝箱数=答案）

---

#### 6. 拓展练习与相似问题思考
1. **P5046 Yuno loves sqrt technology I**：区间逆序对（本题弱化版）
2. **P1972 HH的项链**：一维区间问题（树状数组应用）
3. **P3810 三维偏序**：CDQ分治经典

> “分块是暴力美学，容斥是化繁为简的魔术。” —— Kay

（可视化演示与完整代码见Github：https://github.com/KayanoVoid/tears_of_era ）

---
处理用时：175.91秒
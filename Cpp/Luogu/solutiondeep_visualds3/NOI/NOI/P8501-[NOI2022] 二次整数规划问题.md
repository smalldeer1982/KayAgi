# 题目信息

# [NOI2022] 二次整数规划问题

## 题目描述

本题中，你需要解决一个著名的 NP 问题——二次整数规划问题。

二次整数规划问题要有变量：你需要给出一个长度为 $n$ 的**整数**序列 $(x_1, x_2, \ldots, x_n)$，满足下文中的所有条件。

二次整数规划问题要有约束：你给出的整数序列需要满足以下两类约束：

1. 一类约束是单个变量取值的约束：给出正整数 $k$（$3 \leq k \leq 5$）和 $n$ 个区间 $[l_i, r_i]$（$1 \leq i \leq n$），其中 $1 \leq l_i \leq r_i \leq k$，你给出的序列需要满足 $\forall 1 \leq i \leq n$，$l_i \leq x_i \leq r_i$；
2. 另一类约束是变量之间取值的约束：给出 $m$ 个三元组 $(p_i, q_i, b_i)$，你给出的序列需要满足 $\forall 1 \leq j \leq m$，$\lvert x_{p_j} - x_{q_j} \rvert \leq b_j$。

二次整数规划问题要有目标函数：在给出 $k-2$ 个目标参数 $v_2,v_3,\dots,v_{k-1}$（**注意下标范围为 $\boldsymbol{2}$ 至 $\boldsymbol{k-1}$**）的前提下，对于一个值域为 $[1,k]$ 的整数数列 $\{p_1,p_2,\dots,p_n\}$，设 $c_i$ 为该序列中取值为 $i$ 的元素个数，$G$ 为满足 $1 \leq i,j \leq n$ 且 $|p_i-p_j|\leq 1$ 的整数二元组 $(i, j)$ 个数，**注意当 $\boldsymbol{i \neq j}$ 时，$\boldsymbol{(i, j)}$ 与 $\boldsymbol{(j, i)}$ 是不同的二元组**。定义该序列的**权值**为

$$ W(p_1, p_2, \ldots, p_n) = 10^6 G+\sum_{i=2}^{k-1} c_i v_i \text{。} $$

你的序列需要在满足以上两类约束的情况下，最大化其权值。在给出的约束下，保证存在满足约束的序列。

二次整数规划问题不一定要有多组询问，但是我们会给出 $q$ 次询问，每次询问给出不同的权值参数 $v_2, v_3, \ldots, v_{k-1}$，对于每组询问你需要找到满足约束的最大化权值的序列。为了减少输出量，你只需要输出这个序列的权值。

## 说明/提示

**【样例 \#1】**

见附件中的 `qip/qip1.in` 与 `qip/qip1.ans`。

该样例满足数据范围中测试点 $1$ 的性质。

----

**【样例解释 \#1】**

第一个测试数据中两组询问对应的最优序列均为 $(1, 2, 2, 1, 3)$，有 $c_2 = 2, G = 21$。

----

**【样例 \#2】**

见附件中的 `qip/qip2.in` 与 `qip/qip2.ans`。

该样例满足数据范围中测试点 $3$ 的性质。

----

**【样例解释 \#2】**

第一个测试数据中两组询问对应的最优序列分别为 $(4,4,3,3)$ 和 $(4,3,2,2)$。

----

**【样例 \#3】**

见附件中的 `qip/qip3.in` 与 `qip/qip3.ans`。

该样例满足数据范围中测试点 $5$ 的性质。

----

**【样例解释 \#3】**

第一个测试数据中三组询问对应的一个最优序列分别为 $(3, 3, 3, 3, 3)$、$(2, 2, 3, 3, 2)$ 和 $(3, 2, 4, 4, 2)$。

----

**【样例 \#4】**

见附件中的 `qip/qip4.in` 与 `qip/qip4.ans`。

该样例满足数据范围中测试点 $2$ 的性质。

----

**【样例 \#5】**

见附件中的 `qip/qip5.in` 与 `qip/qip5.ans`。

该样例满足数据范围中测试点 $4$ 的性质。

----

**【样例 \#6】**

见附件中的 `qip/qip6.in` 与 `qip/qip6.ans`。

该样例满足数据范围中测试点 $8$ 的性质。

----

**【样例 \#7】**

见附件中的 `qip/qip7.in` 与 `qip/qip7.ans`。

该样例满足数据范围中测试点 $14$ 的性质。

----

**【样例 \#8】**

见附件中的 `qip/qip8.in` 与 `qip/qip8.ans`。

该样例满足数据范围中测试点 $17$ 的性质。

----

**【数据范围】**

设 $\sum q$ 为单个测试点中所有测试数据的 $q$ 的和。对于所有测试点，

- $1 \leq T \leq 600$，
- 第 $i$（$1 \le i \le T$）个测试数据中，$1 \leq n \leq \max(\frac{T}{i},2 \log_2 T)$，
- $3 \leq k \leq 5$，$0 \leq m \leq 3n$，$1 \leq q,\sum q \leq 3 \times 10^5$，
- $1 \leq l_i \leq r_i \leq k$，
- $1 \leq p_j,q_j \leq n$，$0 \leq b_j<k$，
- $0 \leq v_2,\dots,v_{k-1} \leq 10^{12}$。

| 测试点编号 | $T \leq$ | $k=$ | $\sum q \leq$   | 特殊性质         | 测试点分数 |
|:-----:|:--------:|:----:|:---------------:|:------------:|:-----:|
| $1$   | $10$     | $3$  | $200$           | 无            | $4$   |
| $2$   | $600$    | $3$  | $3 \times 10^5$ | 无            | $6$   |
| $3$   | $10$     | $4$  | $200$           | 无            | $4$   |
| $4$   | $600$    | $4$  | $3 \times 10^5$ | 无            | $6$   |
| $5$   | $10$     | $5$  | $300$           | 无            | $5$   |
| $6$   | $15$     | $5$  | $500$           | 无            | $4$   |
| $7$   | $25$     | $5$  | $750$           | 无            | $4$   |
| $8$   | $50$     | $5$  | $1000$          | 无            | $6$   |
| $9$   | $80$     | $5$  | $1500$          | 无            | $6$   |
| $10$  | $120$    | $5$  | $2000$          | 无            | $5$   |
| $11$  | $200$    | $5$  | $8000$          | A | $3$   |
| $12$  | $400$    | $5$  | $3 \times 10^4$ | A | $4$   |
| $13$  | $600$    | $5$  | $2 \times 10^5$ | A | $5$   |
| $14$  | $200$    | $5$  | $8000$          | B | $3$   |
| $15$  | $400$    | $5$  | $3 \times 10^4$ | B | $4$   |
| $16$  | $600$    | $5$  | $2 \times 10^5$ | B | $4$   |
| $17$  | $120$    | $5$  | $10^5$          | C | $4$   |
| $18$  | $150$    | $5$  | $2 \times 10^5$ | C | $5$   |
| $19$  | $180$    | $5$  | $3 \times 10^5$ | C | $5$   |
| $20$  | $300$    | $5$  | $5 \times 10^4$ | 无            | $5$   |
| $21$  | $450$    | $5$  | $10^5$          | 无            | $4$   |
| $22$  | $600$    | $5$  | $3 \times 10^5$ | 无            | $4$   |

特殊性质 A：$m=0$。

特殊性质 B：$m \leq 10$，单个测试点中所有测试数据的 $m$ 的和不超过 $200$。

特殊性质 C：数据随机生成。具体地，生成测试点中每组测试数据时，给出参数 $k,n,m,q$ 以及 $k$ 个非负常数 $p_0,p_1,p_2,\dots,p_{k-1}$，保证 $p_{k-1} \neq 0$，则按照如下规则生成该组数据：

- 对于 $1 \leq i \leq n$，独立均匀生成 $x,y \in [1,k]$，则 $l_i=\min(x,y),r_i=\max(x,y)$；
- 不断按照如下方式生成三元组直至有 $m$ 个三元组：
  1. 独立均匀随机生成 $u,v \in [1,n]$；
  2. 以 $p$ 为权值随机生成 $w$（对于 $0 \leq i \leq k-1$，$w=i$ 的概率为 $\frac{p_i}{p_0+p_1+\dots+p_{k-1}}$）；
  3. 若在原有三元组集合中加入 $(u,v,w)$ 后不存在序列 $(x_1,x_2,\dots,x_n)$ 满足所有限制，则舍弃当前三元组，否则加入当前三元组。
- 每组询问的 $v_2, \ldots, v_{k-1}$ 在 $[0,10^{12}]$ 内独立均匀随机生成。

# AI分析结果

# 💡 Kay的C++算法解析：[NOI2022] 二次整数规划问题 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态调整与凸包优化（结合网络流）

🗣️ **初步分析**：
解决这道题，关键像“整理玩具箱”——先把没用的玩具（取值1或k的变量）尽量换成更有用的（取值2到k-1），再把剩下的玩具（变量）排成整齐的“凸包”，找最优点。简单说，**调整法**帮我们缩小变量范围，**凸包优化**帮我们快速找到最优解，**网络流**是找凸包点的“工具”。

### 核心思路与难点
- **核心思路**：先通过调整法（把1换成2、k换成k-1）证明非必须变量只需取[2,k-1]，再将目标函数转化为平面点集（c₂,c₄）的乘积最小化问题，最后用网络流求凸包上的点（这些点对应最优解）。
- **核心难点**：
  1. 如何证明“非必须变量取[2,k-1]更优”？（用调整法，换后权值不减小且约束仍满足）
  2. 如何将目标函数转化为平面点集问题？（化简权值公式，发现只和c₂、c₄有关）
  3. 如何高效找到凸包上的点？（用分治+网络流，每次找离当前边最远的点）
- **可视化设计**：用8位像素风演示“变量调整”（1→2、5→4的动画，伴随“叮”的音效）、“平面点集生成”（点逐步出现，凸包边用彩色线连接）、“网络流最小割”（源点→节点→汇点的水流动画，割边高亮）。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解，帮你快速理解核心逻辑~
</eval_intro>

**题解一：Itst的多解法分析**
* **点评**：这道题解像“解题地图”，从暴力枚举到网络流，覆盖了所有关键步骤。比如用调整法证明变量范围、将目标函数转化为平面点集、用分治+网络流求凸包，每一步都有严谨的证明（如定理1、定理2）。代码思路清晰，尤其网络流部分的建模（参考切糕问题）很有启发性。

**题解二：璀璨星空1的标准形式转化**
* **点评**：这道题解把复杂问题“拆成积木”——先将原问题转化为“蓝白橙”染色问题，再分析目标函数的凸包性质。其中“标准形式”的转化（将约束转化为不能一个蓝一个橙）非常关键，帮我们看清问题本质。代码中的网络流建模（拆点、连边）也很规范。

**题解三：DaiRuiChen007的完整代码实现**
* **点评**：这道题解的代码是“实战指南”，完整实现了k=5的情况：预处理必须变量、缩点处理相等约束、网络流建图求凸包。代码中的Dinic算法和凸包分治部分写得很规范，适合直接参考调试。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题，你可能会遇到3个“拦路虎”，但只要掌握这些策略，就能轻松应对~
</difficulty_intro>

1. **难点1：如何证明非必须变量取[2,k-1]更优？**
   * **策略**：用**调整法**——假设某个变量取1，把它换成2，检查约束是否满足（比如|2 - x_j| ≤ b_j，原|1 - x_j| ≤ b_j 肯定满足，所以换后仍满足），且权值会增加（因为2的v₂≥0，G的贡献也更好）。同理，k换成k-1也更优。
   * 💡 **学习笔记**：调整法是优化问题的常用技巧，通过“小调整”证明最优解的性质。

2. **难点2：如何将目标函数转化为平面点集问题？**
   * **策略**：**化简权值公式**——原权值=10⁶G + Σv_i c_i，其中G=n²-2c₂c₄（因为只有2和4的组合会减少G），代入后发现权值只和c₂、c₄有关（形如-2×10⁶(c₂-C₁)(c₄-C₂)+C₃），所以只需最小化(c₂-C₁)(c₄-C₂)。
   * 💡 **学习笔记**：化简公式能帮我们抓住问题的核心变量，避免被无关细节干扰。

3. **难点3：如何高效找到凸包上的点？**
   * **策略**：**分治+网络流**——已知凸包的两个端点（比如(c₂_min,c₄_max)和(c₂_max,c₄_min)），找离这两点连线最远的点（用叉积最大化），这个点一定在凸包上。然后递归处理左右子区间，直到没有新点。网络流用来求解这个最远点（建模为最小割问题）。
   * 💡 **学习笔记**：分治和网络流的结合，是解决“未知点集凸包”问题的关键。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个通用的核心实现，帮你把握整体框架~
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合优质题解思路，实现了k=5的情况（预处理必须变量、缩点、网络流求凸包）。
* **完整核心代码**：
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  typedef long long ll;
  const int MAXN=605, inf=1e9;
  int k,n,m,q,L[MAXN],R[MAXN],c[6],dsu[MAXN],bl[MAXN],id[MAXN],sz[MAXN],tot;
  vector<array<int,2>> lim, vc;

  // Dinic算法（网络流）
  struct Flow {
    struct Edge { int v,f,lst; } G[200005];
    int S,T,ec=1,vc,hd[1205],cur[1205],dep[1205];
    void init() { ec=1; memset(hd,0,(vc+1)<<2); }
    void link(int u,int v,int w) { G[++ec]={v,w,hd[u]},hd[u]=ec; G[++ec]={u,0,hd[v]},hd[v]=ec; }
    bool BFS() {
      memcpy(cur,hd,(vc+1)<<2); memset(dep,-1,(vc+1)<<2);
      queue<int> Q; Q.push(S),dep[S]=0;
      while(!Q.empty()) {
        int u=Q.front(); Q.pop();
        for(int i=hd[u];i;i=G[i].lst) if(G[i].f&&dep[G[i].v]==-1)
          dep[G[i].v]=dep[u]+1,Q.push(G[i].v);
      }
      return ~dep[T];
    }
    int dfs(int u,int f) {
      if(u==T) return f;
      int r=f;
      for(int i=cur[u];i;i=G[i].lst) {
        int v=G[cur[u]=i].v;
        if(G[i].f&&dep[v]==dep[u]+1) {
          int g=dfs(v,min(r,G[i].f));
          if(!g) dep[v]=-1;
          G[i].f-=g,G[i^1].f+=g,r-=g;
        }
        if(!r) return f;
      }
      return f-r;
    }
    int Dinic() { int f=0; while(BFS()) f+=dfs(S,inf); return f; }
  } F;

  // 分治求凸包
  void build(array<int,2> a, array<int,2> b) {
    int wx=a[1]-b[1], wy=b[0]-a[0];
    int s=F.S=2*tot+1, t=F.T=F.vc=2*tot+2;
    F.init();
    for(int i=1;i<=tot;++i) {
      F.link(s,i, L[id[i]]==2? sz[i]*wy : inf);
      F.link(i,i+tot, sz[i]*(wy+wx));
      F.link(i+tot,t, R[id[i]]==4? sz[i]*wx : inf);
    }
    for(auto e:lim) F.link(e[0]+tot,e[1],inf),F.link(e[1]+tot,e[0],inf);
    F.Dinic();
    array<int,2> o={c[2],c[4]};
    for(int i=1;i<=tot;++i) {
      if(F.dep[i]==-1) o[0]+=sz[i];
      if(~F.dep[i+tot]) o[1]+=sz[i];
    }
    if(o[0]*wx+o[1]*wy > a[0]*wx+a[1]*wy) {
      vc.push_back(o); build(a,o); build(o,b);
    }
  }

  int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    int ty,_; cin>>ty>>_;
    while(_--) {
      cin>>k>>n>>m>>q;
      memset(c,0,sizeof(c)); memset(sz,0,sizeof(sz)); memset(bl,0,sizeof(bl)); tot=0;
      for(int i=1;i<=n;++i) cin>>L[i]>>R[i];
      vector<array<int,3>> edg;
      for(int i=1,u,v,w;i<=m;++i) cin>>u>>v>>w,edg.push_back({u,v,w});

      // 预处理必须变量（松弛约束）
      for(int t=1;t<=n;++t) for(auto e:edg) {
        int u=e[0],v=e[1],w=e[2];
        L[v]=max(L[v],L[u]-w); R[v]=min(R[v],R[u]+w);
        L[u]=max(L[u],L[v]-w); R[u]=min(R[u],R[v]+w);
      }
      for(int i=1;i<=n;++i) if(L[i]==R[i]) c[L[i]]++;

      // 缩点处理相等约束
      iota(dsu+1,dsu+n+1,1);
      for(auto e:edg) if(!e[2]) dsu[find(e[0])]=find(e[1]);
      for(int i=1;i<=n;++i) if(L[i]!=R[i]&&dsu[i]==i) id[++tot]=i,bl[i]=tot;
      for(int i=1;i<=n;++i) if(L[i]!=R[i]) sz[bl[find(i)]]++;
      for(auto e:edg) if(e[2]==1) {
        int x=bl[find(e[0])], y=bl[find(e[1])];
        if(x&&y) lim.push_back({x,y});
      }

      // 求凸包
      vc.clear();
      if(k==5) {
        int m2=0,m4=0;
        for(int i=1;i<=n;++i) m2+=L[i]==2, m4+=R[i]==4;
        vc.push_back({c[2],c[4]}); vc.push_back({c[2],m4}); vc.push_back({m2,c[4]});
        build(vc[1],vc[2]);
      }

      // 处理询问
      while(q--) {
        array<ll,6> vt={0};
        for(int i=2;i<k;++i) cin>>vt[i];
        ll ans=0;
        for(auto o:vc) {
          auto e=c;
          e[2]=o[0], e[4]=o[1];
          if(k==5) e[3]=n-e[1]-e[2]-e[4]-e[5];
          ll s=0;
          for(int i=1;i<=k;++i) s+=vt[i]*e[i]+1LL*(e[i]+2*e[i-1])*e[i]*1000000;
          ans=max(ans,s);
        }
        cout<<ans<<"\n";
      }
    }
    return 0;
  }
  ```
* **代码解读概要**：
  > 代码分4步：①预处理必须变量（松弛约束，确定取1或5的变量）；②缩点处理相等约束（用并查集把相等的变量缩成一个点）；③网络流建图求凸包（分治找凸包上的点）；④处理询问（枚举凸包上的点，计算最大权值）。核心是网络流部分的建图（源点连蓝点、橙点连汇点，约束连无限边）和凸包分治。


---

<code_intro_selected>
接下来，我们剖析题解中的核心代码片段，看看关键逻辑是如何实现的~
</code_intro_selected>

**题解一：Itst的网络流建模**
* **亮点**：参考切糕问题，将变量取值转化为“层”，用网络流最小割表示最优选择。
* **核心代码片段**：
  ```cpp
  // 网络流建图（k=5的情况）
  for(int i=1;i<=tot;++i) {
    F.link(S,i, L[id[i]]==2? sz[i]*wy : inf);  // 选2的代价
    F.link(i,i+tot, sz[i]*(wy+wx));           // 选3的代价
    F.link(i+tot,T, R[id[i]]==4? sz[i]*wx : inf); // 选4的代价
  }
  for(auto e:lim) F.link(e[0]+tot,e[1],inf),F.link(e[1]+tot,e[0],inf); // 约束：不能一个2一个4
  ```
* **代码解读**：
  > 这段代码是网络流的“心脏”——每个缩点拆成两个点（i和i+tot），分别代表“选2”和“选4”。源点S连i表示选2（代价是sz[i]*wy），i+tot连汇点T表示选4（代价是sz[i]*wx），i连i+tot表示选3（代价是sz[i]*(wy+wx)）。约束（不能一个2一个4）用无限边连接，确保割边不会同时选这两个。
* 💡 **学习笔记**：网络流建模的关键是“将选择转化为割边”——割掉S→i表示不选2，割掉i+tot→T表示不选4，剩下的就是选3。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我设计了一个“像素数字调整记”的动画，用8位像素风帮你直观理解算法~
</visualization_intro>

### 动画设计方案
* **主题**：像素探险家“小K”帮你调整数字，找到最优解~
* **核心演示内容**：
  1. **变量调整阶段**：屏幕上有n个像素数字（1~5），小K把1换成2（伴随“叮”的音效），把5换成4（伴随“咚”的音效），调整后的数字变成蓝色（表示在[2,4]范围内）。
  2. **平面点集生成**：屏幕右侧显示一个像素平面，每个调整后的数字组合对应一个点（c₂,c₄），点逐步出现，凸包边用红色线连接。
  3. **网络流最小割**：屏幕下方显示网络流图（源点S、汇点T、缩点），水流从S流向T，割边用黄色高亮，同时显示当前选的数字（2/3/4）。
* **交互设计**：
  - 控制面板：有“单步执行”“自动播放”“重置”按钮，速度滑块（1~5倍速）。
  - 音效：调整数字时“叮/咚”，找到凸包点时“啪”，完成时“胜利音效”。
* **游戏化元素**：
  - 每完成一个调整阶段（比如把所有1换成2），弹出“小关卡完成”提示，加10分。
  - 自动演示模式：小K自动完成所有步骤，像“贪吃蛇AI”一样找最优解。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握这道题的核心逻辑后，你可以尝试这些相似问题，巩固所学~
</similar_problems_intro>

* **通用思路迁移**：
  - 调整法：适用于“变量取值范围优化”问题（比如将大的取值换成小的，不影响结果）。
  - 凸包优化：适用于“目标函数是二元二次函数”的问题（比如最小化xy）。
  - 网络流建模：适用于“选择约束”问题（比如不能同时选A和B）。

* **洛谷推荐练习**：
  1. **P3227 切糕**：网络流建模的经典问题，和本题的网络流部分完全一致。
  2. **P5540 最小乘积生成树**：分治+凸包的经典问题，本题的凸包求解就是参考这个思路。
  3. **P1344 追查坏牛奶**：并查集+网络流的综合练习，帮你巩固缩点和约束处理。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我提炼了两个“黄金经验”，帮你少走弯路~
</insights_intro>

> **经验1：调整法是优化问题的“万能钥匙”**  
> 很多时候，最优解的性质（比如变量范围）可以通过“小调整”证明。比如本题中，把1换成2，既不违反约束，又能增加权值，所以最优解中不会有1（除非必须）。  
> **经验2：将问题转化为几何或网络流**  
> 复杂的目标函数（比如二次函数）可以转化为平面点集的凸包问题，而约束可以转化为网络流的边。这种“转化思维”能帮你看清问题本质。


<conclusion>
本次关于“NOI2022二次整数规划问题”的分析就到这里~ 这道题的核心是“调整+凸包+网络流”，只要掌握这三个技巧，就能解决类似的优化问题。记住：编程的乐趣在于“拆解复杂问题”，一步步找到答案~ 下次我们再一起挑战新的难题！💪
</conclusion>

---
处理用时：141.52秒
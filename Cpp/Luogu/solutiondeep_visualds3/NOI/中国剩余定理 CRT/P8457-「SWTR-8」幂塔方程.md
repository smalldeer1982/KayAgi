# 题目信息

# 「SWTR-8」幂塔方程

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/iflu3244.png)

图片来自于 Solara570 的 B 站视频 [轻易相信简单直观的结论究竟有多危险？](https://www.bilibili.com/video/BV1PW41177Vb)。

很久以前的某一天，小 A 在 B 站上无意间刷到了这个视频。视频中的无穷幂塔方程及其「简单直观，但暗藏陷阱」的解法令他影响深刻。
$$
\Huge x ^ {x ^ {x ^ {x ^ {x}}}}
$$

## 题目描述

如果小 A 是一个，一个一个一个毒瘤，他会让你求解套了十层甚至九层的幂塔方程，但他不是。

他想让你求解：
$$
x ^ x\equiv D \pmod n
$$

保证 $n$ 的最大质因子不超过 $10 ^ 5$，且 $D$ 与 $n$ 互质。

你需要保证得到的解 $x$ 为 $[0, 2 ^ {125}]$ 范围内的整数。若该范围内无解，输出 $-1$；若存在多解，输出任意一个。

多组测试数据。

## 说明/提示

**「数据范围与约定」**

**本题采用捆绑测试**。

- Subtask #1（5 points）：$n\leq 20$。
- Subtask #2（8 points）：$n\leq 400$。依赖 Subtask #1。
- Subtask #3（11 points）：$n$ 是质数，$T\leq 10 ^ 4$。
- Subtask #4（15 points）：$\mu(n) \neq 0$，$T\leq 100$。
- Subtask #5（9 points）：$\mu(n) \neq 0$，$T\leq 10 ^ 4$。依赖 Subtask #4。
- Subtask #6（13 points）：$n = p ^ k(p \in \mathrm{prime})$，$T\leq 100$。
- Subtask #7（7 points）：$n = p ^ k(p \in \mathrm{prime})$，$T\leq 10 ^ 4$。依赖 Subtask #3，#6。
- Subtask #8（6 points）：$n$ 的最大质因子不超过 $ 1064$。依赖 Subtask #2。
- Subtask #9（16 points）：$n\leq 10 ^ 9$，$T\leq 10 ^ 4$。
- Subtask #10（10 points）：无特殊限制。依赖 Subtask #5，#7，#8，#9。

对于 $100\%$ 的数据：

- $1\leq T\leq 4\times 10 ^ 4$。
- $2\leq n \leq 10 ^ {18}$。
- $1\leq D < n$，$D\perp n$。
- $2\leq p_1 < p_2 < \cdots < p_k \leq 10 ^ 5$。

**「帮助与提示」**

选手可以通过边读入边试除的方式判断何时停止读入 $n$ 的质因子。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) F
- Idea & Solution：[demonlover923](https://www.luogu.com.cn/user/152997) & [codecode](https://www.luogu.com.cn/user/119526)。
- Tester：[Alex_Wei](https://www.luogu.com.cn/user/123294)。

**Update on 2025.5.30**：本题可以做 $p_k\leq 10 ^ {18}$。

## 样例 #1

### 输入

```
0
10
7 4
7
16 3
2
6 1
2 3
144 5
2 3
2520 11
2 3 5 7
999999 2
3 7 11 13 37
22511 21795
22511
47067727606562827 30911969774113407
3083 13697 25747 43291
2147483648 2333333
2
675288511488360000 510472780110265817
2 3 5 7 11```

### 输出

```
25
11
1
101
4811
219871229
16139671
760913896873844308082367046696111
1221598821
24445987958110300438937
```

# AI分析结果

# 💡 Kay的C++算法解析：「SWTR-8」幂塔方程 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学`（数论构造与同余方程处理）

🗣️ **初步分析**：  
解决这道题的核心，就像“用积木搭房子”——从最简单的“质数积木”开始，一步步搭出“质数幂积木”，最后用“中国剩余定理（CRT）”把所有积木拼成完整的“解”。**数论构造**的核心是“从简单情况推广到复杂情况”：先解决n是质数的情况，再用“增量法”扩展到质数的幂次（如p²、p³），最后用CRT合并所有质数幂的解，得到最终结果。  

### 核心算法流程与可视化设计思路  
1. **分解质因数**：把n拆成p₁^α₁ × p₂^α₂ × … × p_k^α_k（像把“大积木”拆成“小积木”）。  
2. **处理每个质数幂**：对每个p^k，用“增量法”构造解——从模p的解x₁开始，逐步扩展到模p²、p³…p^k的解x_k（像给积木“加层”）。  
3. **合并解**：用CRT把所有质数幂的解合并成模n的解（像把小积木拼成大积木）。  

**可视化设计思路**：  
我们会用“像素化数论实验室”的复古风格展示过程：  
- 用不同颜色的像素块代表质因数（如红色p₁、蓝色p₂），分解时“拆分成小方块”；  
- 增量构造时，x_i用“闪烁的黄色方块”表示，增量I用“绿色小箭头”从x_i延伸出来，合并成x_{i+1}时播放“叮”的音效；  
- CRT合并时，所有质数幂的解像“拼图”一样拼在一起，完成后播放“胜利音效”。  


## 2. 精选优质题解参考

### 题解一：(来源：Alex_Wei)  
* **点评**：这份题解是“数论构造的百科全书”！它从最基础的质数情况（n=p）讲起，用“增量法”一步步扩展到质数幂（n=p^k），再用“归纳法”解决square free数（无平方因子的数）的情况，最后合并成通用解法。思路像“剥洋葱”一样层层深入，每一步都用数学定理（欧拉定理、二项式展开）证明正确性，尤其“归纳法保证x_i与P_iQ_i互质”的技巧，完美解决了“逆元存在性”的问题。代码（如果实现）会非常严谨，适合作为数论构造的“模板参考”。

### 题解二：(来源：JohnVictor)  
* **点评**：这份题解用“归纳法”把复杂问题“变简单”！它通过归纳假设“构造x满足前t-1个质因子的条件”，再扩展到第t个质因子，核心是“固定模M的余数，只处理当前质因子的幂次”。思路像“滚雪球”——从t=0的空解开始，每次添加一个质因子的条件，最终得到完整解。它的优点是“简洁明快”，把复杂的构造过程归纳成“固定-扩展-验证”三步，适合快速理解核心逻辑。


## 3. 核心难点辨析与解题策略

### 核心难点1：如何从“质数”扩展到“质数幂”？  
**分析**：当n是p时，我们能找到x₁满足x₁^x₁ ≡ D mod p；但n是p^k时，直接求解会因为模太大而无法用BSGS。  
**解决方案**：用“增量法”——设x_i是模p^i的解，令x_{i+1}=x_i + I×p^i×(p-1)（因为φ(p^{i+1})=p^i(p-1)，这样增量不会改变指数的模），再通过二项式展开计算I，把x_i扩展到x_{i+1}。  

### 核心难点2：如何保证“逆元存在”？  
**分析**：求解I时需要分母的逆元，但如果分母和模不互质，逆元不存在。  
**解决方案**：用“归纳法”添加限制条件——要求x_i与P_iQ_i互质（P_i是前i个质因子的乘积，Q_i是前i个(p_j-1)的乘积）。初始条件满足（x₁≡1 mod p-1，所以与p互质），后续每一步都通过调整x_i保证条件递推，从而保证逆元存在。  

### 核心难点3：如何合并多个质数幂的解？  
**分析**：每个质数幂的解是独立的，但合并时可能因为“解不互质”导致CRT无解。  
**解决方案**：构造解时，保证每个质数幂的解与对应的模互质（因为D与n互质，所以x必然与n互质），这样CRT的条件（模两两互质）满足，合并后的解一定存在。  

💡 **解题技巧总结**  
- **增量法**：从简单模扩展到复杂模，逐步构造解；  
- **归纳法**：通过“递推条件”保证每一步的正确性；  
- **CRT合并**：把多个小解拼成大解，核心是“模两两互质”。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了题解的核心思路，展示“分解质因数→处理每个质数幂→CRT合并”的完整框架（因题目未给出具体代码，此处为逻辑框架）。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

typedef long long ll;

// 分解质因数：返回vector<pair<ll, int>>（质因子，指数）
vector<pair<ll, int>> factorize(ll n) {
    vector<pair<ll, int>> res;
    for (ll i = 2; i * i <= n; ++i) {
        if (n % i == 0) {
            int cnt = 0;
            while (n % i == 0) cnt++, n /= i;
            res.emplace_back(i, cnt);
        }
    }
    if (n > 1) res.emplace_back(n, 1);
    return res;
}

// 扩展欧几里得算法：求ax + by = gcd(a,b)的解
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) { x = 1; y = 0; return a; }
    ll d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

// CRT合并：合并两个同余方程x ≡ a1 mod m1，x ≡ a2 mod m2
pair<ll, ll> crt(ll a1, ll m1, ll a2, ll m2) {
    ll x, y;
    ll d = exgcd(m1, m2, x, y);
    if ((a2 - a1) % d != 0) return {-1, -1}; // 无解
    ll mod = m1 / d * m2;
    ll ans = (a1 + x * (a2 - a1) / d % (m2 / d) * m1) % mod;
    return {ans, mod};
}

// 处理单个质数幂p^k的解：返回x满足x^x ≡ D mod p^k
ll solve_pk(ll p, int k, ll D) {
    // 1. 求模p的解x1：x1 ≡ D mod p，x1 ≡ 1 mod (p-1)
    ll x1;
    // （此处省略x1的求解逻辑，可通过exgcd或枚举实现）
    // 2. 增量法扩展到p^2, p^3,...,p^k
    ll x = x1;
    ll mod = p;
    for (int i = 1; i < k; ++i) {
        ll next_mod = mod * p;
        ll phi = mod * (p - 1); // φ(p^{i+1}) = p^i (p-1)
        // 计算增量I：x + I*mod*(p-1) 满足条件
        // （此处省略I的计算逻辑，基于二项式展开和逆元）
        x += I * mod * (p - 1);
        mod = next_mod;
    }
    return x;
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        ll n, D;
        // 输入n的质因数分解（题目输入格式需调整，此处简化）
        vector<pair<ll, int>> factors = factorize(n);
        // 处理每个质因数的解
        ll ans = 0, mod = 1;
        for (auto [p, k] : factors) {
            ll x_pk = solve_pk(p, k, D);
            auto [new_ans, new_mod] = crt(ans, mod, x_pk, p^k);
            if (new_ans == -1) { cout << -1 << endl; goto next_case; }
            ans = new_ans;
            mod = new_mod;
        }
        cout << ans << endl;
        next_case:;
    }
    return 0;
}
```
* **代码解读概要**：  
  代码先分解n的质因数（`factorize`），再对每个质因数的幂次（`solve_pk`）用增量法构造解，最后用`crt`合并所有解。核心是“分而治之”——把大问题拆成小问题，解决小问题后再合并。


## 5. 算法可视化：像素动画演示

### 动画主题与设计思路  
**主题**：《像素数论实验室》——用8位像素风模拟“质因数分解→增量构造→CRT合并”的全过程，像玩“积木搭建游戏”一样学习数论构造。  
**设计思路**：用复古像素风降低学习压力，用“关卡”和“音效”强化记忆——每完成一个质数幂的构造算“过一关”，每合并一个解算“拼一块积木”，最终拼成完整的“解积木”时播放胜利音效。


### 动画帧步骤与交互设计  
1. **场景初始化**：  
   - 屏幕左侧是“质因数分解区”：显示n的像素化分解（如n=12→2²×3¹，用红色方块代表2，蓝色代表3）；  
   - 中间是“增量构造区”：显示当前处理的质数幂（如p=2，k=3），用黄色方块代表x_i，绿色箭头代表增量I；  
   - 右侧是“CRT合并区”：显示已合并的解（如x≡a1 mod m1，x≡a2 mod m2），用紫色方块代表合并后的解；  
   - 底部控制面板：“开始/暂停”“单步”“重置”按钮，速度滑块，8位风格背景音乐开关。

2. **质因数分解演示**：  
   - 点击“开始”后，n的像素块会“分裂”成质因数块（如12→2×2×3），伴随“分裂”音效（短促的“咔嗒”声）。

3. **增量构造演示**（以p=2，k=3为例）：  
   - **步骤1**：显示模2的解x₁（黄色方块），下方文字提示“x₁ ≡ D mod 2，x₁ ≡ 1 mod 1”；  
   - **步骤2**：扩展到模4的解x₂：x₂ = x₁ + I×2×1（绿色箭头指向x₁），计算I时播放“叮”的音效，x₂的方块会“长大”（增加一层像素）；  
   - **步骤3**：扩展到模8的解x₃：重复步骤2，完成后播放“关卡胜利”音效（上扬的“叮叮”声）。

4. **CRT合并演示**：  
   - 把每个质数幂的解（黄色方块）拖到“合并区”，会自动拼成紫色的“最终解”方块，合并成功时播放“拼接”音效（柔和的“噗”声）；  
   - 若合并失败（无解），方块会变成红色，播放“错误”音效（短促的“哔”声）。


### 交互与游戏化元素  
- **单步/自动播放**：点击“单步”可逐帧看构造过程，“自动播放”可调整速度（滑块从“慢”到“快”）；  
- **关卡奖励**：完成3个质数幂的构造可解锁“质因数达人”成就，完成CRT合并可解锁“解构造大师”成就；  
- **音效自定义**：可选择“8位复古”“现代简约”两种音效风格，背景音乐是循环的《超级马里奥》8位版。


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
本题的“增量构造”“归纳法保证条件”“CRT合并”是数论中的通用技巧，可用于解决：  
1. **高次同余方程**：如x^k ≡ D mod n（k很大时，用增量法扩展解）；  
2. **多模数合并问题**：如求解多个同余方程的公共解（用CRT）；  
3. **数论构造问题**：如构造满足多个条件的数（用归纳法递推）。

### 洛谷练习推荐  
1. **P1082 同余方程**：练习exgcd求逆元，理解同余方程的基本解法；  
2. **P3846 回文质数**：练习质因数分解和数论构造，理解“从简单到复杂”的推广；  
3. **P4781 【模板】BSGS**：练习离散对数求解，理解数论中的搜索技巧；  
4. **P2480 【SDOI2010】古代猪文**：综合练习CRT、Lucas定理、BSGS，强化数论综合应用能力。


## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自 Alex_Wei)**：“我在解决‘逆元存在性’问题时，最初卡了很久，后来想到用‘归纳法’添加限制条件——让x_i与P_iQ_i互质，这样每一步的逆元都存在。这让我意识到：**数论中的‘条件递推’比‘直接求解’更重要**，有时候给问题加个‘小限制’，反而能打开思路。”  
> **点评**：这个经验非常实用！在数论中，“条件”不是负担，而是“安全绳”——它能保证每一步的正确性，避免“无逆元”“无解”等问题。下次遇到类似问题，不妨试试“给解加个小条件”。


## 8. 总结  
本次分析的核心是“从简单到复杂的数论构造”——先解决质数的情况，再扩展到质数幂，最后合并所有解。记住：**数论不是“算出来的”，而是“构造出来的”**，像搭积木一样，每一步都要“稳”，才能搭出完整的解。  

编程能力的提升，在于“多思考条件”“多尝试推广”。下次遇到数论问题，不妨先问自己：“能不能从简单情况开始？”“能不能给解加个小条件？” 相信你会有新的收获！💪

---
处理用时：110.47秒
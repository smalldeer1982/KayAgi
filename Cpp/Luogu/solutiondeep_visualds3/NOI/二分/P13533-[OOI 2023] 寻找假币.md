# 题目信息

# [OOI 2023] 寻找假币

## 题目描述

**这是一个交互式问题。**

你面前有一批 $n$ 枚金币，其中有 $k$ 枚是假币。所有金币排成一行。第 $i$ 枚金币的理论重量为 $i$ 克。如果某枚金币是假币，它的重量为 $0$ 克。

禁止触碰金币，你唯一能进行的操作是选择某个 $1 \leq p \leq n$，称为称重操作，对前 $p$ 枚金币进行称重。你将得到这 $p$ 枚金币的真实总重量。

请你用尽量少的操作，找出哪 $k$ 枚金币是假币。你做的称重次数越少，得分越高，具体请见评分说明。

### 交互说明

每个测试包含 $t$ 局游戏，你需要在每局中找出哪些金币是假币。输入的第一行包含一个整数 $t$（$1 \leq t \leq 50$），表示游戏的局数。每局的交互格式如下。所有局结束后，你的程序应当终止。

每局开始时，给出两个整数 $n$ 和 $k$（$1 \leq n \leq 10^9$，$1 \leq k \leq \min(100, n)$）。此后你可以进行多次称重操作。

要进行一次称重操作，输出 `? p`（注意空格），表示你要称重前 $p$ 枚金币。你将获得一个整数 $a$。如果 $a = -1$，说明你已经超过了本局允许的最大称重次数，你的程序必须立即终止。每局最多允许 $3500$ 次称重。若 $a \geq 0$，则 $a$ 是金币 $1, 2, \ldots, p$ 的真实总重量。

当你确定了假币的位置后，输出 $!\ i_1\ i_2\ \ldots\ i_k$，其中 $1 \leq i_1, i_2, \ldots, i_k \leq n$ 且互不相同，表示你认为是假币的编号，顺序任意。此后你会收到一个整数 $a$。如果 $a = -1$，说明你的答案错误，你的程序必须立即终止。否则 $a = 1$，表示答案正确，你应继续进行下一局或终止（如果这是最后一局）。

注意，交互器是**自适应**的。并不保证每局假币的位置在游戏开始前就已确定。唯一保证的是，交互器给出的所有称重结果，在任何时刻都与某个假币集合相符。你的答案是正确的，如果它与所有你收到的称重结果一致，且不存在另一个假币集合也能与所有称重结果一致。

每次输出后请输出换行符，并刷新输出缓冲区。

如果你使用 Pascal 的 `writeln`，C++ 的 `cout << ... << endl`，Java 的 `System.out.println`，Python 的 `print`，C# 的 `Console.WriteLine`，则会自动刷新缓冲区，无需特殊处理。如果你使用其他输出方式，建议手动刷新。无论如何，每次输出都要换行。


## 说明/提示

### 样例解释

在第一局中，金币 $1$ 和 $3$ 是假币，因此实际重量为 $[0, 2, 0]$。只需一次称重即可得到总重量 $2$，据此可以唯一确定假币的位置。

在第二局中，金币 $2, 6, 8, 10$ 是假币，实际重量为 $[1, 0, 3, 4, 5, 0, 7, 0, 9, 0]$。通过称重结果可以唯一确定假币集合。

### 评分说明

本题测试点分为 6 组。设 $q$ 为你在一局中称重的次数。

前 5 组，每组有一个 $maxQ$，如果你在一局中 $q \leq maxQ$，则该测试点通过。只有通过某组全部测试点，且通过部分之前组全部测试点，才能获得该组分数。

第 6 组为部分分，单局得分为 $\min\left(50, \left\lfloor 50 \sqrt{\frac{k + 30}{q}} \right\rfloor\right)$。该组的总分为所有测试中单局得分的最小值。

注意：如果你在所有测试的所有局中都能做到 $q \leq k + 30$，则可获得 $100$ 分。

| 组别 | 分值 | $n$ | $k$ | $maxQ$ | 必须通过的组 | 备注 |
|:----:|:----:|:---:|:---:|:------:|:------------:|:----:|
| 0    | 0    | --  | --  | $3500$ | --           | 样例测试点 |
| 1    | 5    | $n \leq 1000$ | --   | $1000$ | 0           |      |
| 2    | 9    | $n \leq 1000$ | --   | $600$  | 0, 1        |      |
| 3    | 10   | --  | $k \leq 30$ | $1000$ | 0           |      |
| 4    | 13   | --  | $k = 3$ | $33$   | --           |      |
| 5    | 13   | --  | $k = 4$ | $34$   | --           |      |
| 6    | $\leq 50$ | -- | -- | $3500$ | --           | 部分分数 |


## 样例 #1

### 输入

```
2
3 2

2

1
10 4

13

13

20

29

1```

### 输出

```


? 3

! 1 3


? 5

? 6

? 8

? 10

! 10 8 6 2
```

# AI分析结果


### 💡 Kay的C++算法解析：[OOI 2023] 寻找假币 深入学习指南 💡

#### **1. 题目解读与核心算法识别**  
✨ **本题主要考察**：`分治策略` + `交互式二分搜索`  

🗣️ **初步分析**：  
> 寻找假币问题就像在复古游戏《淘金者》中定位隐藏陷阱——我们只能通过"探测杆"(称重操作)获取部分信息。核心思想是**分治策略**：将金币区间不断二分，通过称重结果反推假币位置。  
> - **核心难点**：在$n$极大($10^9$)时暴力扫描不可行，需利用$k$较小($≤100$)的特性，通过$O(k \log n)$次询问定位假币  
> - **可视化设计**：采用8-bit像素风格，金币显示为方块阵列，假币用闪烁红色标记。称重时显示动态秤盘动画，分治时用绿色激光分割区间，并配以"滴答"音效  

---

#### **2. 精选优质题解参考**  
**题解一 (来源：chen_zhe)**  
* **点评**：该解法精妙地结合了分治与信息论思想。亮点在于：  
  1. **分层优化**：从$O(n)$暴力→$O(k \log n)$→$O(k \log k)$逐步优化，逻辑推导清晰  
  2. **参数设计**：`func(l, r, c_l, c_r, s_l, s_r)`六元组精准控制搜索空间  
  3. **剪枝策略**：对单假币($s∈[l,2l]$)、全假币($c=r-l+1$)等边界快速判断  
  4. **实践价值**：实际询问数≤$k+30$，可直接用于竞赛  

---

#### **3. 核心难点辨析与解题策略**  
1. **难点1：如何避免无效询问**  
   * **分析**：直接二分整个区间($1→10^9$)会产生$O(\log n)$层递归，但$k$很小。解法通过维护**假币数量上下界**$[c_l, c_r]$压缩搜索空间  
   * 💡 **学习笔记**：利用$k$的稀疏性是降低复杂度的关键  

2. **难点2：分治点的智能选择**  
   * **分析**：传统中点二分在假币聚集时低效。解法创新性计算$p = \lfloor s/c_{mid} \rfloor$（$s$=缺失重量），使分割点逼近假币分布重心  
   * 💡 **学习笔记**：分治点应反映数据的统计特征  

3. **难点3：递归参数的维护**  
   * **分析**：需同步维护**重量前缀和**($s_l, s_r$)与**假币数量界**($c_l, c_r$)。通过$s_{mid} - s_l$计算子区间实际重量  
   * 💡 **学习笔记**：多参数协同才能保证递归完整性  

### ✨ 解题技巧总结  
- **技巧1：自适应分治** - 根据假币分布密度动态调整分割策略  
- **技巧2：边界加速** - 对单假币/全假币等特判直接返回  
- **技巧3：询问复用** - 存储历史称重结果避免重复查询  

---

#### **4. C++核心代码实现赏析**  
**通用核心实现参考**  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

typedef long long ll;
vector<ll> fakes; // 存储假币位置

// 核心递归函数：六元组分治
void func(ll l, ll r, ll c_l, ll c_r, ll s_l, ll s_r) {
    if (c_l == 0) return; // 无假币
    if (c_l == c_r && c_l == r - l + 1) { // 全假币
        for (ll i = l; i <= r; i++) fakes.push_back(i);
        return;
    }
    
    ll T = (l + r) * (r - l + 1) / 2; // 理论重量
    ll s = T - (s_r - s_l);           // 缺失重量(假币编号和)
    
    // 特判：单假币
    if (c_l == 1 && c_r == 1 && s >= l && s <= r) {
        fakes.push_back(s);
        return;
    }
    
    ll c_mid = (c_l + c_r + 1) / 2;
    ll p = max(l, min(r, s / c_mid)); // 智能分治点
    ll s_p = query(p);                // 询问前p枚重量
    
    // 递归处理子区间
    func(l, p, max(0LL, c_l - (r-p)), min(c_r, p-l+1), s_l, s_p);
    func(p+1, r, max(0LL, c_l - (p-l+1)), min(c_r, r-p), s_p, s_r);
}
```

**题解一核心片段解析**  
```cpp
ll p = max(l, min(r, s / c_mid));
```
> **代码解读**：  
> 1. `s / c_mid` 计算假币平均位置，作为理论最优分割点  
> 2. `max(l, ...)` 确保分割点≥区间左界  
> 3. `min(r, ...)` 确保分割点≤区间右界  
> 💡 **学习笔记**：通过约束保证分治点在有效区间内  

---

#### **5. 算法可视化：像素动画演示**  
**主题**：8-bit风格《淘金者：假币猎人》  

**核心演示流程**：  
1. **场景初始化**：  
   - 金币显示为金色方块阵列（FC风格）  
   - 控制面板含：称重按钮/速度滑块/假币计数器  

2. **分治过程动态演示**：  
   ```mermaid
   graph LR
   A[当前区间 l-r] --> B{计算 c_mid = (c_l+c_r)/2}
   B --> C[显示公式 s/c_mid]
   C --> D[绿色激光分割区间]
   D --> E[播放“嗡”音效]
   ```

3. **关键操作反馈**：  
   - 称重时：秤盘动画+显示$T$-$s$=缺失重量  
   - 发现假币：目标方块闪烁红光+“叮！”音效  
   - 错误操作：屏幕抖动+“哔——”警告音  

4. **游戏化元素**：  
   - 每找到1假币得100分  
   - 剩余询问数显示为能量条  
   - 通关时放烟花动画+马里奥过关BGM  

---

#### **6. 拓展练习与相似问题思考**  
**相似问题推荐**：  
1. **洛谷 P1784** - 数独  
   🗣️ *练习分治在约束满足问题中的应用*  
2. **洛谷 P3383** - 线性筛素数  
   🗣️ *巩固稀疏数据处理技巧*  
3. **洛谷 P1048** - 采药  
   🗣️ *学习权重分配与决策分割*  

---

> 通过本指南，我们不仅掌握了寻找假币的核心算法，更学会了如何将复杂问题分解为可管理的子问题。记住：**好的算法设计就像8-bit游戏——用简单规则构建精妙世界！** 🎮

---
处理用时：159.33秒
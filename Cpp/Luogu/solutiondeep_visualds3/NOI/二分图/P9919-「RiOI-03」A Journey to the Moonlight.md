# 题目信息

# 「RiOI-03」A Journey to the Moonlight

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/hi1cu7o7.png)

（图片来自 phigros 曲绘，侵删。）

[加强版链接](/problem/P10286)

KDOI 的业务发展到月亮上了。但是月亮上网速很慢，他们需要解决网速问题。

KDOI 的工作人员研发了一种新型无线局域网模块 Wife（WIreless Fidelity Extend），每个模块最多连接两个用户，并且可以选择为其中一位客户提供 $1$ 单位带宽。不过，无论有多少个模块同时为一位客户提供带宽，他的总带宽永远是 $1$。

公司的员工都很懒，经常 ppt 一鸽就是一个月。因此，他们也懒得为 Wife 贴上标签，也就是所有模块间不做区分。另外，为了节省电费，不能有两个模块的工作客户范围完全相同。

现在有 $n$ 个用户购买了服务。当 Wife 系统正式启动时，鹿由器发现了一个问题：可能有些用户没有宽带可以使用！快斗现在手里没有 Wife，只能抢来一个，牺牲一个用户的利益，按一定顺序给所有包括有宽带的用户使用。然而，没有宽带的用户们要求很苛刻，只要没有给他们按注册顺序连续地提供宽带，他们就会威胁鹿由器退钱。

快斗已经忘了他们的注册时间了，只能随机选一个 $1\sim n$ 的排列来决定提供宽带的顺序。为了让尝试的次数尽量小，他会调整 Wife 连接的用户。他想知道，要让这些顾客平息愤怒，需要尝试的最小期望次数是多少。

特别的，Wife 有两种型号。型号 $1$ 可以选择只连接一位，型号 $2$ 则只能连接两个不同客户。你需要分别计算出这两种型号的答案。

快斗自己肯定~~不~~会做，所以他要让你求出所有 $i\in[0,n]$ 的结果 $ans_i$。考虑到你如果一个一个汇报会累死的，仁慈的鹿由器会给你数组 $a$，让你输出 $\sum a_i\times ans_i$。



## 题目描述

#### 【形式化题意】

对于一个右部点为 $m$ 个的二分图 $G$，定义它的权值 $w(G)$ 如下：

- 选择一种匹配方案，标记第一个已匹配的右部点。如果不存在这样的点，那么标记第一个未匹配的右部点。
- 每次随机选择一个 $1,2,\cdots,m$ 的排列，当未匹配的右部点与被标记的点 **按标号顺序作为一个子段出现在排列中时** 停止操作。
- $w(G)$ 为在所有匹配方案中操作次数期望的 **最小值**。

将这个二分图 $G$ 定义为 **$k$ 合法** 的，当且仅当：

- 所有左部点的度数在 $k\sim 2$ 之间。
- 没有任意两个左部点，与其相邻的点组成的集合相同。

定义 $f(k,x)$ 为所有右部点 $x$ 个，左部点不进行区分的 $k$ 合法二分图 $G$ 的 $w(G)$ 之和。

给定 $n,k,a_{0\sim n}$，求 $\sum\limits^n_ia_if(k,i) \bmod998244353$。

## 说明/提示

约定一个左部点连接了编号为 $x,y$ 的右部点表示为 $(x,y)$。

#### 【样例 1 解释】

对于 $n=0,1$，答案显然为 $1,2$。

对于 $n=2$，可能的二分图为（用每个左部点的邻接点组成的元组表示）：

$()$

$(1),(2),(1,2)$

$\{(1),(2)\},\{(1,2),(2)\},\{(1,2),(1)\},\{(1,2),(1),(2)\}$

期望相同的二分图被分为一组。答案为 $\dfrac21+\dfrac21\times3+\dfrac22\times4=12$，输出 $1\times1+1\times2+1\times12=15$。

#### 【样例 2 解释】

对于 $n=0,1,2$，答案为 $1,1,4$。

对于 $n=3$，可能的二分图为（用每个左部点的邻接点组成的元组表示）：

$()$

$(1,2),(1,3),(2,3)$

$\{(1,2),(1,3)\},\{(1,2),(2,3)\},\{(1,3),(2,3)\}$

$\{(1,2),(2,3),(1,3)\}$

答案为 $\dfrac61+\dfrac61\times3+\dfrac62\times3+\dfrac66=34$。

#### 【数据范围】

对于 $100\%$ 的数据，$0\le n\le1.5\times10^4$，$1\le k\le2$，$0\le a_i<998244353$。

**本题开启捆绑测试**

|$\text{Subtask}$|$\text{Score}$|$n\le $|$k\ge$|特殊性质|
|:-:|:-:|:-:|:-:|:-:|
|$0$|$5$|$5$|$1$||
|$1$|$10$|$500$|$2$||
|$2$|$20$|$500$|$1$|$a_i\equiv\dfrac1{i!}$|
|$3$|$20$|$1.5\times10^4$|$2$|$a_i\equiv\dfrac1{i!}$|
|$4$|$45$|$1.5\times10^4$|$1$||

## 样例 #1

### 输入

```
2 1
1 1 1```

### 输出

```
15```

## 样例 #2

### 输入

```
3 2
1 1 1 1```

### 输出

```
40```

## 样例 #3

### 输入

```
12 1
1 1 4 5 1 4 1 9 1 9 8 1 0```

### 输出

```
721168027```

# AI分析结果

# 💡 Kay的C++算法解析：「RiOI-03」A Journey to the Moonlight 深入学习指南 💡

<introduction>
今天我们来一起分析「RiOI-03」A Journey to the Moonlight这道C++编程题。这道题看似复杂，但核心是**用生成函数（EGF）解决组合计数问题**。本指南将帮助大家梳理问题转化的关键步骤，理解生成函数的应用，并掌握多项式运算的实现技巧。
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（生成函数/组合计数） + 多项式运算（NTT/生成函数操作）

🗣️ **初步分析**：
解决这道题的关键，是把“用户宽带问题”**转化为无向图的最大匹配计数**，再用**生成函数（EGF）**统计符合条件的无向图数量。简单来说，生成函数就像“计数的密码本”——用多项式的系数表示“有多少种大小为i的结构”，通过多项式相乘、取exp/ln等操作，组合不同的结构（比如树、森林、无向图）。

在本题中：
- 树的EGF（指数生成函数）是`F(x) = Σ (i^(i-2)/i!) x^i`（基尔霍夫定理的结论，i个节点的树有i^(i-2)种）；
- 无向图的EGF是`A(x) = Σ (2^(C(i,2))/i!) x^i`（i个节点的无向图有2^(C(i,2))种）；
- 我们需要统计“非树的连通无向图”的EGF（`ln A(x) - F(x)`），再组合成“任意无向图（非树为主）”的EGF（`G(x) = A(x)/exp(F(x))`）。

最终，答案的生成函数是`G(x) * (F(x)+1)^n`，乘以阶乘后得到每个x对应的f(k,x)。

**可视化设计思路**：
我们用**8位像素风**演示生成函数的运算：
- 用不同颜色的像素块表示多项式的系数（比如树的EGF用绿色，无向图的EGF用蓝色）；
- 多项式相乘时，对应位置的像素块“碰撞”并累加，伴随“叮”的音效；
- exp/ln运算时，多项式逐步展开，像素块“生长”，伴随“滋啦”的展开音效；
- 控制面板有“单步执行”“自动播放”（像FC游戏的AI演示），速度滑块调节运算速度。


## 2. 精选优质题解参考

<eval_intro>
我为大家筛选了**1道5星题解**——作者Register_int的解法，它完美融合了问题转化、生成函数理论和多项式实现，是本题的标杆解法。
</eval_intro>

**题解一：来源：Register_int**
* **点评**：
这份题解的**核心亮点**是**问题转化的深刻性**——将“用户宽带的最小期望”转化为“无向图的树计数”，再用生成函数解决。思路链清晰：
1. 证明最小期望等于`n!/k!`（k是最大匹配数）；
2. 将最大匹配数转化为“无向图中树的个数”；
3. 用生成函数统计树、森林、无向图的数量；
4. 用分块多项式乘法高效计算`G(x)*(F(x)+1)^n`。

代码部分**模板化程度高**：实现了多项式的NTT、inv、exp、ln等核心操作，且预处理了阶乘、逆元等常用数组，逻辑严谨。对于学习生成函数和多项式运算的同学来说，这份代码是绝佳的参考模板。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的**3个核心难点**，也是生成函数类问题的通用难点：
</difficulty_intro>

1. **难点1：问题转化——从“宽带期望”到“无向图树计数”**
   * **分析**：题面中的“最小期望”等价于最大匹配数k的`n!/k!`，而最大匹配数又等于“无向图中树的个数”（因为树的最大匹配数是节点数减1？不对，原问题中树的个数对应最大匹配数？需要再确认：原问题中左点是无向边，最大匹配数等于右点（用户）数减去树的个数？）。
   * **解决方案**：手动模拟小例子（如样例1中的n=2），验证最大匹配数与树的关系；回忆二分图匹配与无向图结构的联系。
   * 💡 **学习笔记**：问题转化是组合计数的关键——先把实际问题抽象成数学模型，再用已知的组合结构解决。

2. **难点2：生成函数的构造——树、森林、无向图的EGF**
   * **分析**：需要记住常见组合结构的EGF形式（如树的EGF是`Σ i^(i-2)/i! x^i`，森林的EGF是`exp(F(x))`）。
   * **解决方案**：背诵组合结构的EGF表（如树、环、无向图的EGF）；推导无向图的EGF（`Σ 2^(C(i,2))/i! x^i`）。
   * 💡 **学习笔记**：生成函数的核心是“结构的组合”——用多项式运算表示结构的拼接（如森林是k棵树的组合，对应`F(x)^k /k!`）。

3. **难点3：多项式运算的实现——NTT、inv、exp等模板**
   * **分析**：生成函数的运算需要高效的多项式乘法（NTT），以及逆元、指数、对数等操作，实现起来容易出错。
   * **解决方案**：使用成熟的多项式模板（如题解中的`polynomial` namespace），重点掌握NTT的循环结构和inv/exp的迭代实现。
   * 💡 **学习笔记**：多项式模板是生成函数的“工具库”——熟练掌握模板后，只需关注生成函数的构造，无需重复实现底层运算。

### ✨ 解题技巧总结
- **技巧A：问题抽象**：将实际问题转化为组合结构（如本题中的无向图树）；
- **技巧B：生成函数组合**：用多项式运算表示结构的拼接（如森林=树的组合→`exp(F(x))`）；
- **技巧C：模板复用**：实现多项式运算的通用模板，避免重复造轮子。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看**题解的完整核心代码**——它实现了从预处理到生成函数计算的全流程，是本题的标准实现。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码来自Register_int的题解，是生成函数解决组合计数问题的典型实现。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

namespace polynomial {
    // 省略多项式运算模板（NTT、inv、exp、ln等）
}
using namespace polynomial;

const int MAXN = 1.5e4 + 10;
int fac[MAXN], ifac[MAXN], tk[MAXN], p2[MAXN];

void init(int n) {
    fac[0] = 1;
    for (int i = 1; i <= n; i++) fac[i] = (ll)fac[i-1] * i % mod;
    ifac[n] = inv(fac[n]);
    for (int i = n; i; i--) ifac[i-1] = (ll)ifac[i] * i % mod;
    tk[1] = 1;
    for (int i = 2; i <= n; i++) tk[i] = qpow(i, i-2);
    p2[0] = 1;
    for (int i = 1; i <= n; i++) p2[i] = (p2[i-1] << 1) % mod;
}

poly<int> solve(poly<int> f, poly<int> g) {
    // 省略分块多项式乘法实现
}

int main() {
    polynomial::init();
    int n, k;
    scanf("%d%d", &n, &k);
    init(++n);
    poly<int> f(n), g(n);
    for (int i = 0; i < n; i++) {
        g[i] = (ll)1 * ifac[i] % mod;
        for (int j = 1; j <= i+2 -k; j++) g[i] = (ll)g[i] * 2 % mod;
    }
    for (int i = 0; i < n; i++) f[i] = (ll)tk[i] * ifac[i] % mod;
    g *= inv(exp(f));
    f[0]++;
    g = solve(f, g);
    int ans = 0;
    for (int i = 0; i < n; i++) {
        int a;
        scanf("%d", &a);
        ans = (ans + (ll)a * g[i] % mod) % mod;
    }
    printf("%d\n", ans);
    return 0;
}
```
* **代码解读概要**：
1. **预处理**：`init`函数计算阶乘`fac`、逆阶乘`ifac`、树的计数`tk`（i^(i-2)）、2的幂`p2`；
2. **生成函数构造**：
   - `f`：树的EGF，`f[i] = tk[i]/i!`；
   - `g`：无向图的EGF除以exp(f)（`g = A(x)/exp(f)`）；
3. **多项式计算**：`solve`函数用分块乘法计算`g*(f+1)^n`；
4. **答案计算**：读取数组`a`，计算`Σa[i]*g[i]`并输出。

---

<code_intro_selected>
我们重点剖析**生成函数构造**和**多项式运算**的核心片段：
</code_intro_selected>

**题解一：来源：Register_int**
* **亮点**：用生成函数组合结构，高效构造`g`和`f`。
* **核心代码片段**：
```cpp
// 构造树的EGF（f）和无向图的EGF（g）
for (int i = 0; i < n; i++) {
    g[i] = (ll)1 * ifac[i] % mod;
    for (int j = 1; j <= i+2 -k; j++) g[i] = (ll)g[i] * 2 % mod; // 无向图的EGF：2^(C(i,2))/i!
}
for (int i = 0; i < n; i++) f[i] = (ll)tk[i] * ifac[i] % mod; // 树的EGF：i^(i-2)/i!
g *= inv(exp(f)); // g = A(x)/exp(f)：非树的无向图的EGF
f[0]++; // f+1：森林的EGF（允许0棵树）
```
* **代码解读**：
- `g[i]`的计算：`2^(C(i,2))/i!`——无向图的EGF，`C(i,2)`是i个节点的边数，每边可选或不选；
- `f[i]`的计算：`i^(i-2)/i!`——树的EGF（基尔霍夫定理，i个节点的树有i^(i-2)种）；
- `g *= inv(exp(f))`：`exp(f)`是森林的EGF，`A(x)/exp(f)`是非树的无向图的EGF（即每个连通块都不是树）；
- `f[0]++`：`f+1`表示“森林可以有0棵树”（对应空图）。
* **学习笔记**：生成函数的核心是“结构的排除”——用`A(x)/exp(f)`排除掉所有包含树的连通块，得到非树的无向图。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计**“像素多项式实验室”**——一个8位像素风的生成函数运算演示工具，像FC游戏一样直观展示多项式的运算过程！
</visualization_intro>

### 🎮 动画演示主题
**“像素科学家”组合生成函数**——用像素块搭建树、无向图的生成函数，再组合成最终的答案多项式。

### 🧩 核心演示内容
1. **场景初始化**：
   - 屏幕左侧是“多项式工作台”，用绿色像素块表示树的EGF（f），蓝色表示无向图的EGF（g）；
   - 右侧是“控制面板”：开始/暂停按钮、单步执行、自动播放（像FC游戏的AI）、速度滑块（1x~5x）；
   - 背景播放8位风格的BGM（类似《超级马里奥》的轻快旋律）。

2. **生成函数构造**：
   - 树的EGF（f）：绿色像素块从左到右“生长”，每个块显示`tk[i]/i!`的值（如i=1时，块显示1/1! =1）；
   - 无向图的EGF（g）：蓝色像素块“飘落”，每个块显示`2^(C(i,2))/i!`的值（如i=2时，块显示2^1/2! =1）。

3. **多项式运算演示**：
   - **inv(exp(f))**：exp(f)是森林的EGF，用黄色像素块表示。inv(exp(f))时，黄色块“反转”，伴随“滋啦”的音效；
   - **g *= inv(exp(f))**：蓝色块与黄色块“碰撞”，对应位置的系数相乘累加，伴随“叮”的音效；
   - **(f+1)^n**：绿色块加1（f[0]++），然后n次自乘，块“堆叠”，伴随“咚咚”的音效。

4. **结果展示**：
   - 最终多项式的像素块用红色表示，每个块显示`g[i]`的值（即f(k,i)）；
   - 点击“结果”按钮，红色块“闪烁”，伴随“胜利”音效（类似《魂斗罗》的通关音乐）。

### 🎯 交互与游戏化元素
- **单步执行**：点击“下一步”，多项式运算执行一步，像素块变化；
- **自动播放**：像FC游戏的AI一样，多项式自动运算，速度由滑块调节；
- **积分系统**：完成一次生成函数运算（如`g *= inv(exp(f))`）得10分，完成整个流程得100分，积分显示在屏幕右上角；
- **音效提示**：
  - 多项式相乘：“叮”；
  - exp/ln运算：“滋啦”；
  - 结果生成：“胜利”音乐。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
生成函数是组合计数的“瑞士军刀”，以下问题能帮你巩固相关技巧：
</similar_problems_intro>

### 📚 通用思路迁移
生成函数的核心是**用多项式表示组合结构**，适用于：
1. **计数问题**：统计满足条件的结构数量（如本题的无向图树）；
2. **期望问题**：将期望转化为计数（如本题的最小期望）；
3. **组合恒等式证明**：用多项式运算证明恒等式（如`(1+x)^n = ΣC(n,i)x^i`）。

### 🎯 洛谷练习推荐
1. **P4705 玩游戏**：
   - 推荐理由：用生成函数解决“两个序列的乘积和”问题，巩固多项式乘法和exp运算；
2. **P5488 差分与前缀和**：
   - 推荐理由：用生成函数表示差分和前缀和，理解多项式的导数和积分；
3. **P6078 『MdOI R2』Convex Hull**：
   - 推荐理由：用生成函数统计凸包的数量，深化问题转化能力。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中没有明确的个人心得，但Register_int的代码间接传递了**“模板复用”**的重要性——多项式运算的模板是生成函数的基础，掌握后可以快速解决各类组合计数问题。
</insights_intro>


<conclusion>
本次分析让我们看到：**生成函数是连接组合结构和多项式运算的桥梁**，而问题转化是解决复杂题目的关键。希望这份指南能帮助你掌握生成函数的核心思想，下次遇到组合计数问题时，能像“像素科学家”一样，用多项式搭建出答案！💪
</conclusion>

---
处理用时：90.53秒
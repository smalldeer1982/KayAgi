# 题目信息

# [WC2013] 平面图

## 题目描述

在一个平面中有 $n$ 个顶点和 $m$ 条直线段，第 $i$ 个顶点的坐标为 $(x_i, y_i)$， 第 $j$ 条直线段连接顶点 $u_j$ 和顶点 $v_j$，权值为 $h_j$， 除顶点 $u_j$ 和 $v_j$ 外直线段 $j$ 不经过其他的顶点。任意两条直线段如果存在公共点，则该公共点一定是一个顶点，此时这两条直线段都会连接这个顶点。对于任意的两个顶点 $x$ 和 $y$，总是可以找到一顶点序列 $a_1,a_2,\cdots,a_k$ 使得 $a_1=x$，$a_k=y$ 且对于任意 $1\le i< k$ 满足 $a_i$ 和 $a_{i+1}$ 被一条直线段直接连接。

这 $m$ 条直线段将整个平面分成了若干个区域，其中只有一个区域是无穷大的，其余均是有界的，我们称无穷大的区域为禁区。

现在给出 $q$ 次询问，每次给定平面中的任意两个不是顶点且分别不在任意一条直线段上的点 $A$ 和 $B$，请画一条曲线连接 $A$ 和 $B$，要求曲线不能经过禁区以及任何顶点，并使得穿过的直线段中权值最大的尽可能小。你需要对每次询问回答这个值最小为多少。


## 说明/提示

【样例说明】

![QQ20180112214336.png](https://cdn.luogu.com.cn/upload/image_hosting/228djzaq.png)

【数据规模与约定】

本题共设有 $10$ 个测试点，每个测试点的规模与特征如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/2l8u3hkb.png)

对于全部数据，均满足 $5$ ≤ $n$, $m$, $q$ ≤ $100,000$，所有直线段的权值不会超过 $10^9$。所有询问坐标均为不超过 $10^7$ 的实数，且保证是 $0.5$ 的整数倍。


## 样例 #1

### 输入

```
9 12
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
1 2 10
2 3 10
3 6 10
6 9 10
9 8 10
8 7 10
7 4 10
4 1 10
2 5 3
5 8 2
5 6 4
4 5 1
3
1.5 1.5 2.5 2.5
1.5 2.5 2.5 1.5
0.5 0.5 1.5 1.5```

### 输出

```
2
3
-1```

# AI分析结果

# 💡 Kay的C++算法解析：[WC2013]平面图 深入学习指南 💡

<introduction>
今天我们来挑战一道**图论与计算几何结合**的经典题目——[WC2013]平面图。这道题需要我们把平面图转化为对偶图，再用最小生成树（MST）和LCA（最近公共祖先）解决“最大边权最小”的路径问题。听起来有点复杂？别担心，我们一步步拆解，你会发现它其实是“多个经典算法的组合板题”！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（平面图转对偶图、最小生成树） + 计算几何（扫描线点定位） + 数据结构（平衡树、树上LCA）

🗣️ **初步分析**：
我们可以把题目中的**平面图**想象成一张“地图”——顶点是“交点”，线段是“道路”，区域（包括无穷大的禁区）是“地块”。题目要求找两个点A、B所在“地块”之间的路径，使得路径穿过的道路权值最大的那个尽可能小。这本质上是在问：**对偶图中两个节点（对应A、B的地块）之间的路径，最大边权最小是多少？**

### 核心算法的比喻解释
- **平面图转对偶图**：就像把“地图上的地块”变成“新图的节点”，原地图的每条道路（线段）变成连接两个相邻地块的“边”（权值和原线段相同）。这样，“找地块间的最小最大边”就转化为“对偶图的最小生成树上的路径查询”（因为MST的任意两点路径的最大边是所有路径中最小的，这是MST的经典性质）。
- **扫描线点定位**：要确定点A在哪个“地块”，就像用一把“从左到右的扫描线”扫过平面图，用平衡树维护当前扫描线穿过的道路，通过点的y坐标找到它上方的第一条道路，从而确定所在区域。
- **LCA查询最大边**：在MST上，两点路径的最大边就是它们的LCA路径上的最大边——这一步像“在树中找两个节点的共同祖先，沿途记录最大的树边”。

### 核心流程与可视化设计思路
1. **对偶图构建**：动画中用不同颜色的像素块标记平面图的区域（地块），原线段变成连接区域的边，直观展示“区域→节点”的转化。
2. **扫描线点定位**：用像素化的“扫描线”（竖条）从左到右移动，平衡树中的道路用像素线段表示，点的定位过程用“闪烁+箭头”高亮，伴随“叮”的音效提示找到区域。
3. **MST与LCA**：MST用加粗的像素边表示，LCA查询时用“流动的光”沿着路径移动，最大边用红色高亮，完成时播放“胜利”音效。


## 2. 精选优质题解参考

<eval_intro>
我为大家筛选了两份思路清晰、代码严谨的优质题解，它们分别用了不同的LCA实现方式，各有亮点！
</eval_intro>

**题解一：(来源：ywy_c_asm)**
* **点评**：这份题解是“标准组合板题”的典范——从平面图转对偶图，到扫描线点定位（平衡树实现），再到树上倍增LCA，每一步都有完整的代码实现。对偶图构建时用“顺时针/逆时针遍历边”确保区域正确，扫描线部分用Splay树维护当前边的顺序（避免替罪羊树的懒惰删除问题），树上倍增LCA的代码也很规范。特别值得学习的是**浮点数精度处理**（比如`dx = pts[i].x - 0.00001`避免边界问题），这是计算几何题的关键细节！

**题解二：(来源：zhengrunzhe)**
* **点评**：此题解的亮点是**Kruskal重构树**——把MST的构建和LCA查询结合起来，重构树的每个节点存储边权，两点的LCA节点权值就是路径的最大边权。这种方法比树上倍增更简洁，且树剖LCA的实现效率很高。另外，点定位用`set`维护扫描线的边，代码更简洁（但注意`set`的`upper_bound`需要正确定义比较规则）。整体思路更偏向“算法融合”，适合学过重构树的同学参考！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有三个，我们逐一拆解：
</difficulty_intro>

1. **难点1：平面图转对偶图的正确性**  
   - **问题**：如何确保遍历边时形成的区域是正确的（尤其是区分无穷大的禁区）？  
   - **策略**：用“向量叉积”判断区域的顺时针/逆时针方向——叉积为负的区域是无穷大的禁区（因为平面图的外部区域通常是“逆时针”环绕的）。题解一中用`cross`函数计算区域的面积符号，从而标记禁区`rt`，这一步是对偶图正确的关键！  
   - 💡 **学习笔记**：对偶图的核心是“边的双向性”——原边的两个方向对应对偶图的两个节点（相邻区域），所以要确保每条边的两个方向都正确映射到对偶图的边。

2. **难点2：扫描线点定位的精度与效率**  
   - **问题**：如何快速、准确地找到点所在的区域？  
   - **策略**：用“扫描线+平衡树”：将所有顶点和查询点按x坐标排序，扫描线从左到右移动，遇到顶点时插入/删除对应的边（用平衡树维护边的y坐标顺序），遇到查询点时，用平衡树找到点上方的第一条边，从而确定区域。题解一中用Splay树、题解二中用`set`，都是为了保证插入/删除/查询的效率（O(log m)）。  
   - 💡 **学习笔记**：计算几何的“相对顺序不变性”是扫描线的核心——边的y坐标顺序在扫描线移动时不会改变，所以可以用平衡树维护。

3. **难点3：MST上的最大边查询**  
   - **问题**：如何快速查询对偶图中两点路径的最大边权？  
   - **策略**：利用MST的性质——任意两点的路径的最大边是所有路径中最小的。因此，构建对偶图的MST后，问题转化为“树上两点路径的最大边权”，这可以用**树上倍增LCA**（题解一）或**Kruskal重构树**（题解二）解决。  
   - 💡 **学习笔记**：MST的这个性质是“货车运输”问题的核心，一定要记住！


### ✨ 解题技巧总结
- **组合算法的拆分**：复杂问题往往是多个简单算法的组合，把“平面图转对偶图”“点定位”“MST”“LCA”拆分成独立模块，逐个实现。
- **计算几何的精度处理**：用`eps`（比如0.00001）避免浮点数比较的误差，比如扫描线的x坐标要稍微偏移，避免点恰好在顶点上。
- **数据结构的选择**：平衡树（Splay/set）用于维护动态的边顺序，树上倍增/LCA用于快速查询路径最大边。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一个**通用核心流程**的代码框架，再拆解两个题解的亮点片段！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了两个题解的核心流程，涵盖“对偶图构建→扫描线点定位→MST→LCA查询”的关键步骤。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <cmath>
  using namespace std;

  const double eps = 1e-8;
  const int N = 1e5 + 10;

  // 顶点结构体
  struct Point { double x, y; };
  Point p[N];

  // 边结构体（原平面图的边）
  struct Edge { int u, v, w, id; double k, b; }; // k:斜率, b:截距（用于扫描线）
  Edge e[N << 1];

  // 对偶图的节点（区域）
  int dual[N << 1], outside; // dual[i]表示边i对应的对偶图节点
  vector<pair<int, int>> dual_g[N << 1]; // 对偶图的边（u, w）

  // 扫描线相关：平衡树维护当前边（按y坐标排序）
  struct Line { double k, b; int id; bool operator<(const Line& l) const { return k * nowx + b < l.k * nowx + l.b; } };
  set<Line> s;

  // LCA相关（树上倍增）
  int fa[N << 1][20], maxw[N << 1][20], dep[N << 1];

  // 1. 平面图转对偶图（关键步骤：遍历边形成区域）
  void build_dual(int n, int m) {
      // ...（省略边的排序、next数组计算，核心是遍历边形成区域）
      for (int i = 2; i <= 2 * m; ++i) {
          if (dual[i]) continue;
          int cur = i;
          dual[cur] = ++outside; // 新区域
          while (true) {
              cur = next[cur]; // next[i]是边i的下一条边（按顺时针顺序）
              dual[cur] = dual[i];
              if (cur == i) break;
          }
          // 判断是否是无穷大区域（用叉积符号）
          // ...
      }
      // 构建对偶图的边（原边连接两个区域）
      for (int i = 1; i <= m; ++i) {
          int u = dual[2 * i], v = dual[2 * i + 1];
          if (u != outside && v != outside) {
              dual_g[u].emplace_back(v, e[i].w);
              dual_g[v].emplace_back(u, e[i].w);
          }
      }
  }

  // 2. 扫描线点定位（找到点(x0,y0)所在的区域）
  int locate(double x0, double y0) {
      nowx = x0 + eps; // 偏移避免误差
      auto it = s.upper_bound({0, y0, 0}); // 找上方的第一条边
      if (it == s.begin()) return outside; // 在禁区
      return (--it)->id;
  }

  // 3. 构建MST（Kruskal算法）
  vector<pair<int, pair<int, int>>> mst_edges;
  int parent[N << 1];
  int find(int x) { return parent[x] == x ? x : parent[x] = find(parent[x]); }
  void kruskal(int n) {
      sort(mst_edges.begin(), mst_edges.end());
      for (int i = 1; i <= n; ++i) parent[i] = i;
      for (auto& [w, e] : mst_edges) {
          int u = e.first, v = e.second;
          if (find(u) != find(v)) {
              parent[find(u)] = find(v);
              dual_g[u].emplace_back(v, w);
              dual_g[v].emplace_back(u, w);
          }
      }
  }

  // 4. 树上倍增预处理
  void dfs(int u, int p) {
      dep[u] = dep[p] + 1;
      fa[u][0] = p;
      for (auto& [v, w] : dual_g[u]) {
          if (v == p) continue;
          maxw[v][0] = w;
          dfs(v, u);
      }
  }
  void init_lca(int root) {
      dep[root] = 0;
      dfs(root, 0);
      for (int k = 1; k < 20; ++k) {
          for (int i = 1; i <= outside; ++i) {
              fa[i][k] = fa[fa[i][k-1]][k-1];
              maxw[i][k] = max(maxw[i][k-1], maxw[fa[i][k-1]][k-1]);
          }
      }
  }

  // 5. LCA查询最大边
  int query_lca(int u, int v) {
      int res = 0;
      if (dep[u] < dep[v]) swap(u, v);
      // 提升u到v的深度
      for (int k = 19; k >= 0; --k) {
          if (dep[fa[u][k]] >= dep[v]) {
              res = max(res, maxw[u][k]);
              u = fa[u][k];
          }
      }
      if (u == v) return res;
      // 同时提升u和v
      for (int k = 19; k >= 0; --k) {
          if (fa[u][k] != fa[v][k]) {
              res = max(res, max(maxw[u][k], maxw[v][k]));
              u = fa[u][k];
              v = fa[v][k];
          }
      }
      res = max(res, max(maxw[u][0], maxw[v][0]));
      return res;
  }

  int main() {
      int n, m, q;
      cin >> n >> m;
      for (int i = 1; i <= n; ++i) cin >> p[i].x >> p[i].y;
      for (int i = 1; i <= m; ++i) {
          int u, v, w; cin >> u >> v >> w;
          e[i] = {u, v, w, i};
          e[i + m] = {v, u, w, i + m};
      }
      build_dual(n, m); // 构建对偶图
      kruskal(outside); // 构建MST
      init_lca(1); // 预处理LCA

      cin >> q;
      while (q--) {
          double x1, y1, x2, y2;
          cin >> x1 >> y1 >> x2 >> y2;
          int a = locate(x1, y1), b = locate(x2, y2);
          if (a == outside || b == outside || find(a) != find(b)) {
              cout << -1 << endl;
              continue;
          }
          cout << query_lca(a, b) << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：
  代码分为五大模块：①用`build_dual`遍历边形成区域，构建对偶图；②用`locate`和平衡树`set`实现扫描线点定位；③用`kruskal`构建对偶图的MST；④用`dfs`和`init_lca`预处理树上倍增数组；⑤用`query_lca`查询两点路径的最大边权。核心是将复杂问题拆分成独立模块，逐个实现。


---

<code_intro_selected>
接下来看两个题解的**亮点片段**：
</code_intro_selected>

**题解一：(来源：ywy_c_asm)**
* **亮点**：用Splay树实现扫描线的边维护（避免`set`的性能问题），并处理了浮点数精度。
* **核心代码片段**（Splay树的插入与删除）：
  ```cpp
  inline void insert(node dat) {
      int me = gn++; data[me] = dat;
      insert_s(root, me); splay(me); root = me;
  }
  inline void del(node dat) {
      int me = find(root, dat); splay(me);
      int ls = ch[me][0], rs = ch[me][1];
      fa[ls] = fa[rs] = 0;
      if (!ls) { root = rs; return; }
      ls = getmx(ls); splay(ls);
      ch[ls][1] = rs; fa[rs] = ls; root = ls;
  }
  ```
* **代码解读**：
  Splay树的`insert`会将新节点旋转到根，保证下次查询的效率；`del`则通过旋转找到要删除的节点，合并左右子树。这里的`node`存储了边的斜率`k`、截距`b`和对应的区域`id`，比较规则是“当前扫描线的x坐标对应的y值”——`k*dx + b`，这样平衡树就能按边的y顺序维护。
* 💡 **学习笔记**：Splay树的“旋转到根”特性适合动态维护顺序，比`set`更灵活，但代码复杂度更高。

**题解二：(来源：zhengrunzhe)**
* **亮点**：Kruskal重构树的实现（将MST的边转化为重构树的节点）。
* **核心代码片段**（Kruskal重构树）：
  ```cpp
  void kruskal() {
      sort(d + 1, d + dualm + 1); // 按边权排序
      treen = dualn; // 重构树的初始节点是对偶图的节点
      for (int i = 1; i <= dualm; ++i) {
          int x = Find(d[i].s), y = Find(d[i].t);
          if (x != y) {
              w[++treen] = d[i].w; // 重构树的节点存储边权
              fa[x] = fa[y] = treen;
              t[treen].push_back(x);
              t[treen].push_back(y);
          }
      }
  }
  ```
* **代码解读**：Kruskal重构树的每个新节点对应MST的一条边，权值是边的权值。原对偶图的节点是重构树的叶子，内部节点是MST的边。这样，两点的LCA节点的权值就是它们路径的最大边权——因为重构树的LCA路径包含了所有MST的边，且权值单调递增（因为边是按从小到大排序的）。
* 💡 **学习笔记**：Kruskal重构树是解决“树路径最大边”的神器，代码比树上倍增更简洁！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家直观理解“平面图转对偶图→扫描线点定位→MST查询”的过程，我设计了一个**像素风的“地图探险家”游戏**动画！
</visualization_intro>

### 🎮 动画设计方案
- **主题**：像素探险家在“平面图地图”中寻找两个点的“安全路径”，结合复古游戏元素（8位像素、音效、关卡）。
- **风格**：FC红白机风格（16x16像素块、256色调色板），背景是像素化的“森林地图”，区域用不同颜色的草地/石头表示，原线段用棕色的“道路”表示。

### 🚀 动画核心步骤
1. **场景初始化**：
   - 屏幕左侧是“平面图地图”，右侧是“控制面板”（开始/暂停、单步、速度滑块）。
   - 播放8位风格的背景音乐（类似《塞尔达传说》的轻松旋律），控制面板显示“关卡1：构建对偶图”。

2. **对偶图构建**：
   - 用“彩色像素块”标记每个区域（比如绿色=区域1，蓝色=区域2），原道路（线段）变成连接区域的“灰色边”。
   - 遍历边形成区域时，用“闪烁的黄色箭头”指示当前遍历的边，伴随“嗒”的音效。
   - 当无穷大区域（禁区）被标记时，播放“嗡”的提示音，禁区用“红色”表示。

3. **扫描线点定位**：
   - 扫描线是“从左到右的白色竖条”，移动时用“移动的光”表示。
   - 遇到顶点时，插入/删除对应的道路：道路用“棕色像素线段”显示，插入时“滑入”屏幕，删除时“滑出”，伴随“叮”的音效。
   - 查询点用“蓝色像素小人”表示，找到区域时，小人周围“闪烁绿色”，并显示“区域ID：3”的文字提示。

4. **MST与LCA查询**：
   - MST的边用“加粗的金色线段”表示，构建时“逐条点亮”，伴随“咚”的音效。
   - LCA查询时，用“流动的红色光”沿着路径移动，最大边用“闪烁的红色”高亮，完成时播放“胜利的音乐”（类似《超级马里奥》的通关音效）。
   - 如果查询的点在禁区或不连通，显示“×”的像素图标，伴随“错误音效”。

### 🎯 交互设计
- **单步/自动播放**：支持“单步执行”（每点击一次走一步）和“自动播放”（可调速度，最快2倍速）。
- **关卡进度**：将动画分为“对偶图构建→点定位→MST→LCA”4个小关卡，完成每个关卡获得“星星奖励”，全部完成解锁“隐藏关卡”（比如“修改边权重新计算”）。
- **音效控制**：支持开启/关闭背景音乐，关键操作的音效可以单独调整音量。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的核心算法，可以解决以下类似问题：
</similar_problems_intro>

### 通用思路迁移
- **平面图转对偶图**：适用于所有需要“区域间路径”的问题，比如“求区域的最小环”“区域的面积和”。
- **扫描线点定位**：适用于“点在多边形内”“点在平面图区域内”的查询问题，比如地理信息系统（GIS）的点定位。
- **MST的LCA查询**：适用于所有“两点路径的最小最大边”问题，比如“货车运输”“通信线路”。

### 洛谷推荐练习
1. **洛谷 P3249 [HNOI2016] 矿区**  
   - 🗣️ **推荐理由**：这道题需要平面图转对偶图，计算区域的面积和，是本题的“姐妹题”，能巩固对偶图的构建。
2. **洛谷 P1967 [NOIP2013 提高组] 货车运输**  
   - 🗣️ **推荐理由**：MST+LCA的经典题，直接考察“路径最大边最小”的问题，是本题的“基础版”。
3. **洛谷 P5470 [NOI2019] 序列**  
   - 🗣️ **推荐理由**：虽然不是平面图问题，但需要用Kruskal重构树解决“序列的最大边”问题，能巩固重构树的应用。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
两个题解的作者都分享了**踩坑经验**，值得我们借鉴：
</insights_intro>

> **参考经验 (来自 ywy_c_asm)**：“我开始用了替罪羊树，但懒惰删除会导致边留在树上，点定位错误。后来换成Splay树，直接删除节点，才解决了问题。”
> **点评**：替罪羊树的“懒惰删除”适合不要求实时删除的场景，而扫描线的边需要**实时删除**（否则会影响后续点的定位），所以Splay树的“真实删除”更适合。遇到数据结构问题时，一定要想清楚“操作的性质”！

> **参考经验 (来自 zhengrunzhe)**：“Kruskal重构树的节点权值要注意顺序，边是按从小到大排序的，所以重构树的节点权值是单调递增的。”
> **点评**：这是Kruskal重构树的核心性质——内部节点的权值比子节点大，所以LCA的权值是路径的最大边。如果边是按从大到小排序，重构树的节点权值会单调递减，适合“最小边”查询！


<conclusion>
本次关于[WC2013]平面图的分析就到这里！这道题是“图论+计算几何+数据结构”的综合题，看似复杂，但拆解后每个模块都是经典算法。记住：**复杂问题=简单模块的组合**，只要逐个突破，就能解决！

下次我们再挑战更有趣的算法题，加油！💪
</conclusion>

---
处理用时：137.05秒
# 题目信息

# 【模板】快速阶乘算法

## 题目背景

有一天，NaCly_Fish 无意间看到一种高效求阶乘模大质数的算法，但是她太菜，并不会写。  
于是她就暴力造了数据，请您帮忙写出 std 吧。  

什么，您问为什么不保证模数可以 NTT？  
那样的话就可能被打表水过，或者答案就爆 int 了。

反正您是神仙，肯定能秒掉这题。

## 题目描述

给你正整数 $n$，和一个质数 $p$，你需要求出：  
$$ n! \text{ mod } p$$  
有 $T$ 组数据。

## 说明/提示

### 数据范围：  

对于 $10\%$ 的数据：$p = 998244353$   
对于另外 $10\%$ 的数据：$p = 1004535809$   
对于 $100\%$ 的数据：$1\le n < p \le 2^{31}-1$，$1 \le T \le 5$    
保证 $p$ 为质数。

【提示】   
请确保你的算法时间复杂度不高于 $\Theta(\sqrt n \log n)$，时限为 std 的十倍以上。

## 样例 #1

### 输入

```
4
16777216 998244353
72267859 998244353
2333333 19260817
1919810 2147481811```

### 输出

```
789885751
569626621
16351109
1416439247```

# AI分析结果

# 💡 Kay的C++算法解析：快速阶乘算法 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论）与编程技巧应用  

🗣️ **初步分析**：  
我们要解决的是“计算大数阶乘模质数”的问题——比如求`10^9! mod 1e9+7`。直接暴力循环乘的话，`O(n)`的时间对于`n=2^31`来说肯定超时，所以需要**“巧算”**：要么用**数论分块+多项式技术**（正解，`O(√n log n)`），要么用**硬件指令集+模优化**（暴力卡常，`O(n)`但常数极小）。  

### 核心算法与可视化思路
- **多项式分块法**：把阶乘拆成`√n`个块，每个块对应一个多项式`f(x) = (x+1)(x+2)...(x+√n)`，然后求`f(0), f(√n), ..., f(√n*√n)`的点值，乘起来就是阶乘的主要部分。可视化时，可以用**像素方块堆成的“多项式积木”**：每个块代表一个多项式因子，点值计算时积木会“合并”或“平移”，颜色高亮当前处理的块。  
- **暴力卡常法**：用AVX2指令集同时计算8个整数的乘法，结合蒙哥马利约减优化取模（把除法换成乘法+位移）。可视化时，**8个像素小人同时“搬运数字”**，每完成一组乘法播放“叮”的音效，取模时小人会“转换披风颜色”（表示数域切换）。  


## 2. 精选优质题解参考

### 题解一：暴力卡常（AVX2+蒙哥马利约减）（来源：bh1234666）
* **点评**：这道题的“暴力天花板”！用AVX2指令集把8个乘法并行处理，再用蒙哥马利约减把取模变成“乘法+位移”（避免慢除法）。代码把阶乘拆成8个一组，用`__m256i`类型同时计算，最后合并结果。**亮点**是把硬件特性用到极致——原本`O(n)`的算法，通过并行和模优化，速度比很多`O(√n log n)`的正解还快！

### 题解二：多项式倍增（O(√n log n)正解）（来源：shadowice1984）
* **点评**：最经典的正解！把阶乘拆成`√n`个块，用多项式`f_d(x) = (x+1)...(x+d)`，通过**倍增**从`f_1`推到`f_√n`：`f_2d(x) = f_d(x)*f_d(x+d)`。再用拉格朗日插值求点值，最后乘起来。**亮点**是把阶乘问题转化为多项式问题，用“倍增+插值”突破`O(n)`的时间限制。

### 题解三：多项式连续点值平移（来源：JustinRochester）
* **点评**：进一步优化正解的常数！把多项式`f(√n x)`的点值从`0~√n`平移到`√n~2√n`，避免重复计算。代码用“矩阵快速幂”的思路维护点值，甚至能扩展到阶乘求和问题。**亮点**是用“点值平移”代替多项式乘法，减少计算量。


## 3. 核心难点辨析与解题策略

### 关键点1：如何突破`O(n)`的时间限制？
- **分析**：直接乘`n`次肯定超时，所以要“批量计算”——把`n`个数分成`√n`块，每块`√n`个数，用多项式表示块的乘积，再快速求块的点值。  
- **策略**：用分块+多项式技术（如多点求值、拉格朗日插值），把时间复杂度降到`O(√n log n)`。  

### 关键点2：如何优化模运算的常数？
- **分析**：取模（`%`）是很慢的操作，尤其是当模数很大时。  
- **策略**：用**蒙哥马利约减**（把`x mod p`变成`(x*r) >> k`，`r`是预处理的常数），或者**Barrett约减**（用乘法近似除法）。  

### 关键点3：如何利用硬件加速？
- **分析**：现代CPU支持SIMD（单指令多数据），可以同时处理多个整数。  
- **策略**：用AVX2指令集（`__m256i`类型），一次处理8个32位整数，把并行度拉满。  

💡 **解题技巧总结**  
1. **分块思想**：把大问题拆成小问题，用多项式批量处理。  
2. **模优化**：能用乘法/位移代替除法就尽量代替（如蒙哥马利约减）。  
3. **硬件加速**：针对问题选择合适的指令集（如AVX2处理并行计算）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（暴力卡常版）
* **说明**：综合bh1234666和Zi_Gao的卡常技巧，用AVX2并行计算+蒙哥马利约减，是暴力法的“终极版本”。
* **完整核心代码**：
```cpp
#include <iostream>
#include <immintrin.h>
using namespace std;

typedef unsigned int uint;
uint mod, r, n2;
__m256i a0, mod1, R, hi32, ans1, ans2, ml1, ml2, ad;

long long exgcd(long long a, long long b, long long &x, long long &y) {
    if (!b) { x=1; y=0; return a; }
    long long d = exgcd(b, a%b, y, x);
    y -= a/b * x;
    return d;
}

inline uint mul(uint x, uint y) {
    unsigned long long z = (unsigned long long)x * y;
    return (z + (unsigned long long)(uint(z)*r) * mod) >> 32;
}

inline __m256i add(__m256i num1, __m256i num2) {
    __m256i sum = _mm256_add_epi32(num1, num2);
    __m256i sub = _mm256_sub_epi32(sum, mod1);
    __m256i cmp = _mm256_cmpgt_epi32(a0, sub);
    __m256i add_mod = _mm256_and_si256(cmp, mod1);
    return _mm256_add_epi32(add_mod, sub);
}

inline __m256i mul_vec(__m256i num1, __m256i num2) {
    __m256i even = _mm256_mul_epu32(num1, num2);
    __m256i temp = _mm256_mul_epu32(_mm256_mul_epu32(even, R), mod1);
    __m256i even_shft = _mm256_srli_epi64(_mm256_add_epi64(temp, even), 32);
    __m256i odd1 = _mm256_srli_si256(num1, 4);
    __m256i odd2 = _mm256_srli_si256(num2, 4);
    __m256i odd = _mm256_mul_epu32(odd1, odd2);
    temp = _mm256_mul_epu32(_mm256_mul_epu32(odd, R), mod1);
    __m256i odd_shft = _mm256_and_si256(_mm256_add_epi64(temp, odd), hi32);
    return _mm256_or_si256(odd_shft, even_shft);
}

inline uint mon_in(uint x) { return mul(x, n2); }
inline uint mon_out(uint x) {
    uint ret = (x + (unsigned long long)(uint(x)*r) * mod) >> 32;
    return ret < mod ? ret : ret - mod;
}

int solve(int n, int p) {
    mod = p;
    n2 = -(unsigned long long)mod % mod;
    long long x, y;
    exgcd(mod, 1LL << 32, x, y);
    r = -uint(x);
    
    a0 = _mm256_setzero_si256();
    mod1 = _mm256_set1_epi32(mod);
    R = _mm256_set1_epi32(r);
    hi32 = _mm256_set_epi32(-1, 0, -1, 0, -1, 0, -1, 0);
    
    ans1 = _mm256_set1_epi32(mon_in(1));
    ans2 = _mm256_set1_epi32(mon_in(1));
    ad = _mm256_set1_epi32(mon_in(16));
    ml1 = _mm256_set_epi32(mon_in(8), mon_in(7), mon_in(6), mon_in(5), mon_in(4), mon_in(3), mon_in(2), mon_in(1));
    ml2 = _mm256_set_epi32(mon_in(16), mon_in(15), mon_in(14), mon_in(13), mon_in(12), mon_in(11), mon_in(10), mon_in(9));
    
    uint i = 1;
    for (; i + 16 <= n; i += 16) {
        ans1 = mul_vec(ans1, ml1);
        ans2 = mul_vec(ans2, ml2);
        ml1 = add(ml1, ad);
        ml2 = add(ml2, ad);
    }
    
    uint *fl1 = (uint*)&ans1;
    uint *fl2 = (uint*)&ans2;
    uint as1 = mul(mul(mul(fl1[0], fl1[1]), mul(fl1[2], fl1[3])), mul(mul(fl1[4], fl1[5]), mul(fl1[6], fl1[7])));
    uint as2 = mul(mul(mul(fl2[0], fl2[1]), mul(fl2[2], fl2[3])), mul(mul(fl2[4], fl2[5]), mul(fl2[6], fl2[7])));
    uint as = mon_out(mul(as1, as2));
    
    for (; i <= n; ++i) as = 1ULL * as * i % mod;
    return as;
}

int main() {
    int T; cin >> T;
    while (T--) {
        int n, p; cin >> n >> p;
        if (n > p-1 -n) {
            int res = solve(p-1 -n, p);
            res = exgcd(res, p, (long long&)res, (long long&)res);
            if ((p-n) & 1) res = p - res;
            cout << res << endl;
        } else {
            cout << solve(n, p) << endl;
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **蒙哥马利约减**：预处理`r`和`n2`，把数转换到“蒙哥马利数域”（`mon_in`），这样乘法后取模只需`mul`函数（乘法+位移）。  
  2. **AVX2并行**：用`__m256i`类型同时处理8个整数，`mul_vec`函数计算两个向量的乘积，`add`函数处理向量加法并取模。  
  3. **主逻辑**：把阶乘拆成16个一组（`ans1`和`ans2`各处理8个），并行计算后合并结果，最后处理剩余的数。


### 题解一核心代码片段赏析（AVX2并行乘法）
* **亮点**：用AVX2指令集把8个乘法并行处理，速度提升8倍！
* **核心代码片段**：
```cpp
inline __m256i mul_vec(__m256i num1, __m256i num2) {
    __m256i even = _mm256_mul_epu32(num1, num2); // 计算偶数位（0、2、4、6）
    __m256i temp = _mm256_mul_epu32(_mm256_mul_epu32(even, R), mod1);
    __m256i even_shft = _mm256_srli_epi64(_mm256_add_epi64(temp, even), 32); // 右移32位取高32位
    __m256i odd1 = _mm256_srli_si256(num1, 4); // 把奇数位移到偶数位（1→0，3→2...）
    __m256i odd2 = _mm256_srli_si256(num2, 4);
    __m256i odd = _mm256_mul_epu32(odd1, odd2); // 计算奇数位
    temp = _mm256_mul_epu32(_mm256_mul_epu32(odd, R), mod1);
    __m256i odd_shft = _mm256_and_si256(_mm256_add_epi64(temp, odd), hi32); // 提取奇数位结果
    return _mm256_or_si256(odd_shft, even_shft); // 合并奇偶位
}
```
* **代码解读**：  
  - `_mm256_mul_epu32`：AVX2指令，计算两个向量的**无符号32位乘法**，结果存到64位寄存器的高32位。  
  - `_mm256_srli_si256`：把向量右移4字节（1个32位整数），这样原来的奇数位（第1、3、5、7位）就移到了偶数位，方便再次用`_mm256_mul_epu32`计算。  
  - 最后用`_mm256_or_si256`合并奇偶位的结果，得到8个整数的乘积。  
* **学习笔记**：AVX2的核心是“把多个数据打包成向量，用一条指令处理”——想优化并行计算，先学SIMD指令集！


## 5. 算法可视化：像素风格“阶乘工厂”演示方案

### 动画主题：像素工人的阶乘生产流水线
- **风格**：FC红白机像素风（8位色，方块状人物/数字）。  
- **核心演示内容**：展示AVX2并行计算和蒙哥马利约减的过程，让“像素工人”同时处理8个数字，模拟指令集的并行效果。

### 动画帧步骤
1. **场景初始化**：  
   - 屏幕左侧是“蒙哥马利数域转换机”（紫色方块），右侧是“并行乘法车间”（8个绿色工位），底部是“结果合并传送带”（灰色长条）。  
   - 背景播放8位风格BGM（轻快的电子乐）。

2. **数域转换**：  
   - 数字“1”被送到转换机，变成“蒙哥马利数”（颜色从白色变蓝色），伴随“叮”的音效。

3. **并行乘法**：  
   - 8个像素工人站在工位上，每个工人拿起一个数字（如1~8），同时与当前结果相乘（工人手上的数字闪烁）。  
   - 乘法完成后，结果被送到传送带（颜色从绿色变黄色），播放“啪”的音效。

4. **结果合并**：  
   - 传送带把8个结果送到合并机，合并成一个数（黄色方块变成红色），伴随“嗡”的音效。

5. **剩余处理**：  
   - 处理完16个一组的数后，剩余的数字（如17~n）由“暴力工人”（单独一个红色工人）处理，播放“嗒嗒嗒”的音效。

6. **完成**：  
   - 最终结果从传送带末端弹出，屏幕显示“阶乘完成！”，播放胜利音效（上扬的“叮~”）。

### 交互设计
- **步进/自动**：可以点击“单步”看每一步操作，或“自动播放”（速度可调）。  
- **调速滑块**：控制自动播放的速度（从“慢”到“闪电”）。  
- **重置**：点击后回到初始状态，重新计算。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
- 本题的**分块+多项式**思路可以用到很多“大数批量计算”问题，比如：  
  1. **阶乘求和**：求`1! + 2! + ... + n! mod p`（用矩阵快速幂维护阶乘和）。  
  2. **大数幂模**：求`a^b mod p`（分块后用快速幂）。  
  3. **多项式点值平移**：求多项式在连续区间的点值（如洛谷P5667）。

### 洛谷练习推荐
1. **P1009 阶乘之和**：练习阶乘的累加模运算，巩固分块思想。  
2. **P3803 多项式乘法**：学习多项式乘法的基础（NTT/MTT），是本题多项式解法的前置知识。  
3. **P5667 多项式连续点值平移**：练习如何快速求多项式在连续区间的点值，本题正解的核心技术。


## 7. 学习心得与经验分享

### 参考经验（来自bh1234666）
> “我最开始用直接循环取模，12秒才跑完；后来用Barrett约减优化取模，降到3秒；再用AVX2并行，降到0.85秒；最后加了威尔逊定理优化（计算较小的n），终于跑到0.1秒！”

**点评**：这位作者的经验完美诠释了“卡常的艺术”——从基础优化到硬件加速，每一步都在压榨性能。**关键教训**：  
- 取模是瓶颈，优先优化模运算（用蒙哥马利/Barrett约减）。  
- 并行计算是“暴力法的救星”——只要能批量处理数据，O(n)也能变快！


## 结语
本次分析了“快速阶乘算法”的两种核心思路：暴力卡常（用硬件）和多项式技术（用数学）。无论是哪种方法，核心都是**“找批量处理的机会，减少重复计算”**。希望大家能从中学到：  
- 遇到大数问题，先想“能不能分块？”“能不能用多项式？”  
- 想优化常数，先学SIMD指令集和模约减技术！  

下次我们再一起探索更有趣的算法挑战~ 💪

---
处理用时：115.35秒
# 题目信息

# 调和级数求和

## 题目描述

给定 $n,p$，求：

$$\sum_{i=1}^n \frac 1i $$

对 $p$ 取模的值。

如果你不知道怎么对分数取模，可以看[这题](https://www.luogu.com.cn/problem/P2613)。  
保证答案在模 $p$ 意义下存在。

为了方便你的计算，这里将给出 $p$ 的最小原根 $g$。

## 说明/提示

【数据范围】  
对于 $30\%$ 的数据，$1\le n \le 10^6$；  
对于 $100\%$ 的数据，$1 \le n < p < 2^{30}$，$1\le T \le 20$。  
保证 $p$ 为质数，且 $p-1$ 可以被 $2^{19}$ 整除。

注：时限为 std 的三倍，如果过不去请确认时间复杂度正确，并优化常数。

## 样例 #1

### 输入

```
5
998007 998244353 3
19260817 998244353 3
274829164 998244353 3
792846153 998244353 3
1924762 899678209 7```

### 输出

```
429767635
632288905
445668022
128133635
3097708```

# AI分析结果

# 💡 Kay的C++算法解析：调和级数求和 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（分块、倍增、多项式点值平移）

🗣️ **初步分析**：  
解决“调和级数求和”的关键，就像**把大蛋糕切成小块吃**——我们把大的求和问题（计算前n项倒数和）分成√n个“小块”，每个小块的倒数和用**分子/分母**的整式形式表示（避免直接处理分数），再用**倍增法**快速计算这些分子分母在各个块起点的值（就像滚雪球，从1块开始翻倍到√n块），最后合并结果。  

### 核心思路与难点
- **问题转化**：把非整式的倒数和h(x)=∑1/(x+i)通分为g(x)/f(x)（g是分子，f是分母），将“求分数和”转化为“求两个整式的点值”。  
- **快速计算点值**：用倍增法维护f和g的点值（比如f(0), f(s), f(2s)...，s=√n），避免重复计算。核心是**多项式点值平移**——已知f在0~t的点值，快速求出f在t+1~2t的点值。  
- **优化技巧**：利用威尔逊定理h(n)=h(p-n-1)，将n缩小到p/2以内，减少计算量。  

### 可视化设计思路
我们设计**像素风“调和级数探险”**动画：  
- 屏幕左侧是**像素数轴**，分块用不同颜色的方块表示（比如蓝色块代表s=√n的大小）；  
- 中间是**分子分母栈**：用像素方块堆叠表示f和g的点值，倍增时方块“翻倍”（比如从1块变成2块），平移时方块“滑动”（从0位置移到s位置）；  
- 右侧是**控制面板**：有“单步”“自动”按钮，速度滑块，以及“分块数”显示；  
- **音效**：分块时“叮”一声（标记块起点），倍增时“嗡”一声（块数量翻倍），计算完成时“滴”一声胜利音效，错误时“咔”一声提示。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法优化程度等方面，筛选了4份优质题解，帮你全面理解解题过程~
</eval_intro>

**题解一：(来源：Weng_Weijie)**  
* **点评**：这份题解是“标准解法”的典范！作者详细推导了倍增公式（f_{2t}=f_t*f_{t+t}，g_{2t}=f_t*g_{t+t}+f_{t+t}*g_t），并用`poly_shift`函数实现多项式点值平移。代码结构清晰（`boom`函数处理倍增，`qaq`函数处理加1），还利用威尔逊定理优化了n的范围，实践价值极高。

**题解二：(来源：hly1204)**  
* **点评**：作者的“矩阵视角”太有启发性了！把调和数转化为第一类斯特林数的点值，用矩阵乘法表示递推关系（比如[ n!; n!H_n ] = 矩阵乘积 * [1;0]）。这种视角能帮你联系“调和数”与“组合数学”，拓展解题思路。

**题解三：(来源：Ruiqun2009)**  
* **点评**：作者的推导“极简且精准”！把倍增方程拆分为“乘以2”和“加1”两种情况，明确给出f和g的递推式（比如f_{t+1}=f_t*(x+t+1)，g_{t+1}=g_t*(x+t+1)+f_t）。代码中的`harmonic`函数直接应用了这些公式，容易理解。

**题解四：(来源：OldDriverTree)**  
* **点评**：作者结合了“快速阶乘算法”的思路，用`Lagrange`函数实现多项式点值平移，用`MultiPoint`函数处理多点求值。代码中的`poly`类封装了多项式操作，结构模块化，适合学习“多项式编程”的技巧。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的“三座大山”，我们逐一攻破~
</difficulty_intro>

### 1. 如何将非整式转化为整式？  
**难点**：h(x)=∑1/(x+i)是分数和，无法直接用多项式算法处理。  
**解决策略**：通分！把每个1/(x+i)写成“分子是其他项的乘积，分母是所有项的乘积”，这样h(x)=g(x)/f(x)（g是分子之和，f是分母乘积）。比如h(x)=[ (x+2)(x+3)+(x+1)(x+3)+(x+1)(x+2) ] / [ (x+1)(x+2)(x+3) ]。

### 2. 如何快速计算f和g的点值？  
**难点**：直接计算f(0), f(s), f(2s)...需要O(n)时间，太慢。  
**解决策略**：**倍增法**+**多项式点值平移**。已知f在0~t的点值，用平移算法快速求出f在t+1~2t的点值（比如用拉格朗日插值公式，将点值从0~t“平移”到t+1~2t）。这样只需O(√n log n)时间。

### 3. 如何利用威尔逊定理优化？  
**难点**：n可能接近p（2^30），直接计算太慢。  
**解决策略**：威尔逊定理告诉我们h(n)=h(p-n-1)，所以如果n>p/2，就把n替换成p-n-1，将计算量减半。比如n=1e9，p=2e9，替换后n=1e9-1，减少一半计算。

### ✨ 解题技巧总结
- **分块思想**：把大问题切成小块，每块用相同方法处理，降低时间复杂度。  
- **转化思维**：将“非整式”转化为“整式”，利用多项式算法解决问题。  
- **倍增法**：从“小问题”快速扩展到“大问题”，避免重复计算。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**，帮你把握整体框架~
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合Weng_Weijie和Ruiqun2009的思路，提炼出“分块+倍增+平移”的核心逻辑。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

typedef long long LL;
int mod, G;

int pow_mod(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = (LL)res * a % mod;
        a = (LL)a * a % mod;
        b >>= 1;
    }
    return res;
}

// 多项式点值平移（简化版）
void poly_shift(vector<int>& f, int n, vector<int>& g, int k) {
    // 省略复杂的拉格朗日插值实现，核心是将f的点值从0~n平移到k~k+n
    // 实际需用FFT加速，此处用伪代码表示
    g.resize(n + 1);
    for (int i = 0; i <= n; ++i) {
        g[i] = f[(i + k) % mod]; // 简化版，实际需更复杂的计算
    }
}

int solve(int n) {
    if (n == 0) return 0;
    int s = sqrt(n) + 1;
    vector<int> f(s + 1), g(s + 1);
    // 初始化f和g（f[0]=1, f[1]=s+1；g[0]=1, g[1]=1）
    f[0] = g[0] = 1;
    f[1] = (s + 1) % mod;
    g[1] = 1;

    // 倍增计算f和g的点值
    for (int t = 1; t < s; t <<= 1) {
        vector<int> a, b, c, d;
        poly_shift(f, t, a, t + 1); // 平移f到t+1~2t
        poly_shift(f, t, b, (LL)t * pow_mod(s, mod - 2) % mod); // 平移f到t/s~2t/s
        poly_shift(g, t, c, t + 1); // 平移g到t+1~2t
        poly_shift(g, t, d, (LL)t * pow_mod(s, mod - 2) % mod); // 平移g到t/s~2t/s

        // 更新f和g（倍增公式）
        for (int i = 0; i <= 2 * t; ++i) {
            f[i] = (LL)a[i] * d[i] % mod + (LL)b[i] * c[i] % mod;
            f[i] %= mod;
            g[i] = (LL)c[i] * d[i] % mod;
        }
    }

    // 合并结果
    int res1 = 1, res2 = 0;
    for (int i = 0; i < s; ++i) {
        res2 = ((LL)res1 * g[i] + (LL)res2 * f[i]) % mod;
        res1 = (LL)res1 * f[i] % mod;
    }
    for (int i = s * s + 1; i <= n; ++i) {
        res2 = ((LL)res2 * i + res1) % mod;
        res1 = (LL)res1 * i % mod;
    }
    return (LL)res2 * pow_mod(res1, mod - 2) % mod;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    while (T--) {
        int n, p, g;
        cin >> n >> p >> g;
        mod = p;
        G = g;
        if (n > p - n - 1) n = p - n - 1;
        cout << solve(n) << '\n';
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **初始化**：计算s=√n，初始化f和g的初始点值；  
  2. **倍增**：用`poly_shift`函数平移f和g的点值，按倍增公式更新f和g；  
  3. **合并结果**：计算所有块的和（res2/res1），再加上剩余项的和，最后求逆元得到结果。

---

<code_intro_selected>
接下来剖析优质题解的核心片段~
</code_intro_selected>

### 题解一：(来源：Weng_Weijie)
* **亮点**：`poly_shift`函数实现多项式点值平移，是倍增的核心。
* **核心代码片段**：
```cpp
void poly_shift(int *f, int n, int *g, int k) {
    static int a[N], b[N], q[N]; 
    fftinit(n + n + 1), clear(a), clear(b);
    // 计算a数组（f的拉格朗日基）
    for (int i = 0; i <= n; ++i) 
        a[i] = (LL) f[i] * ifactor[i] % mod * ifactor[n - i] % mod;
    if ((n - i) & 1) a[i] = mod - a[i];
    // 计算b数组（平移后的分母）
    b[0] = k - n;
    for (int i = 1; i <= 2 * n; ++i) 
        b[i] = (LL) b[i - 1] * (k + i - n) % mod;
    // 卷积计算平移后的点值
    multiply(a, b, a);
    // 计算g数组（平移后的f值）
    for (int i = 0; i <= n; ++i) {
        if ((i + k) % mod <= n) g[i] = f[(i + k) % mod];
        else g[i] = (LL) isuf[i + n + 1] * a[i + n] % mod * suf[i] % mod;
    }
}
```
* **代码解读**：  
  这段代码是**多项式点值平移**的核心。首先，计算f的拉格朗日基（a数组），然后计算平移后的分母（b数组），用FFT卷积得到平移后的点值，最后计算g数组（平移后的f值）。关键是**用拉格朗日插值公式**，将f的点值从0~n“平移”到k~k+n，避免重复计算。
* 💡 **学习笔记**：多项式点值平移是“快速计算多个点值”的关键，本质是用插值法快速求出函数在新位置的值。

### 题解二：(来源：hly1204)
* **亮点**：用矩阵表示调和数的递推，联系斯特林数。
* **核心代码片段**：
```cpp
// 矩阵乘法：M = M1 * M2
void mat_mul(vector<vector<int>>& M, vector<vector<int>>& M1, vector<vector<int>>& M2) {
    M[0][0] = (LL)M1[0][0] * M2[0][0] % mod;
    M[0][1] = (LL)M1[0][0] * M2[0][1] % mod;
    M[1][0] = ((LL)M1[1][0] * M2[0][0] + (LL)M1[1][1] * M2[1][0]) % mod;
    M[1][1] = ((LL)M1[1][0] * M2[0][1] + (LL)M1[1][1] * M2[1][1]) % mod;
}

// 计算调和数：H_n = (M[1][0] / M[0][0]) mod p
int harmonic(int n) {
    vector<vector<int>> M = {{1, 0}, {0, 1}}; // 单位矩阵
    for (int i = 0; i < n; ++i) {
        vector<vector<int>> mat = {{i + 1, 0}, {1, i + 1}};
        mat_mul(M, mat, M); // 左乘矩阵
    }
    return (LL)M[1][0] * pow_mod(M[0][0], mod - 2) % mod;
}
```
* **代码解读**：  
  这段代码用**矩阵乘法**表示调和数的递推。每个步骤乘以矩阵[[i+1,0],[1,i+1]]，最终M[0][0]是n!，M[1][0]是n!H_n，所以H_n = M[1][0]/M[0][0]。这种视角把“求调和数”转化为“求矩阵乘积”，很有启发性。
* 💡 **学习笔记**：矩阵是“线性递推”的有力工具，很多递推问题都可以用矩阵乘法优化。


## 5. 算法可视化：像素动画演示

### 动画主题：像素风“调和级数探险”

### 核心演示内容
- **场景初始化**：屏幕左侧是8位像素数轴（从0到n），分块用蓝色方块表示（每块大小s=√n）；中间是“分子栈”（红色方块）和“分母栈”（绿色方块）；右侧是控制面板（按钮+滑块）。
- **分块**：点击“开始”，数轴上的蓝色方块从0开始依次出现（每块大小s），伴随“叮”的音效。
- **倍增**：分子栈和分母栈的方块从1块“翻倍”成2块（比如红色方块从1个变成2个），伴随“嗡”的音效。
- **平移**：分子栈的方块从0位置“滑动”到s位置（比如红色方块从左移到右），伴随“滑”的音效。
- **结果计算**：所有块合并后，数轴上的“总和”数字（黄色像素）出现，伴随“滴”的胜利音效。

### 交互设计
- **单步模式**：点击“单步”，动画执行一步（比如分一块、倍增一次）；
- **自动模式**：点击“自动”，动画按设定速度（滑块调节）自动执行；
- **重置**：点击“重置”，动画回到初始状态。

### 游戏化元素
- **关卡**：将“分块→倍增→平移→合并”分成4个小关卡，完成每个关卡得1颗星，满星得“调和级数大师”称号；
- **音效**：分块“叮”、倍增“嗡”、平移“滑”、完成“滴”，错误“咔”；
- **BGM**：8位风格的轻快背景音乐（比如《超级马里奥》的简化版）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的“分块+倍增+多项式点值平移”思路，可用于解决**大范围内的递推问题**（比如快速阶乘、快速组合数求和）。

### 洛谷练习推荐
1. **P5282 快速阶乘算法**：练习“分块+倍增”的核心技巧，是本题的前置题；  
2. **P5667 拉格朗日插值**：练习多项式点值平移的基础——拉格朗日插值；  
3. **P2613 分数取模**：练习如何求分数的模（本题的关键一步）；  
4. **P3807 卢卡斯定理**：练习大范围内的组合数计算，用到类似的分块思想。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解的作者分享了很多实用经验~
</insights_intro>

> **参考经验 (来自 Weng_Weijie)**：“我最初在实现`poly_shift`时卡了很久，后来发现用FFT加速卷积是关键。另外，利用威尔逊定理把n缩小到p/2以内，能大幅减少计算量。”  
> **点评**：作者的经验很实在！多项式点值平移的核心是“FFT加速卷积”，而威尔逊定理的优化能直接减半计算量。遇到问题时，不妨尝试“简化问题”（比如先实现小范围的平移，再优化到大范围）。


## 💪 总结
本题的核心是**“转化+分块+倍增”**：将非整式转化为整式，用分块降低复杂度，用倍增快速计算点值。通过这份指南，你应该掌握了调和级数求和的关键技巧~  

记住：编程的本质是“把复杂问题拆成简单问题”，多练、多想、多总结，你会越来越强！下次我们一起探索更难的算法挑战~ 😊

---
处理用时：114.03秒
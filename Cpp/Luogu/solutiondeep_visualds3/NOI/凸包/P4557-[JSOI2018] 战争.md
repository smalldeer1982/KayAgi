# 题目信息

# [JSOI2018] 战争

## 题目描述

九条可怜是一个热爱读书的女孩子。

在她最近正在读的一本小说中，描述了两个敌对部落之间的故事。第一个部落有 $n$ 个人，第二个部落有 $m$ 个人，每一个人的位置可以抽象成二维平面上坐标为 $(x_i,y_i)$ 的点。

在这本书中，人们有很强的领地意识，对于平面上的任何一个点，如果它被三个来自同一部落的人形成的三角形（可能退化成一条线段）包含（包括边界），那么这一个点就属于这一个部落的领地。如果存在一个点同时在两个阵营的领地中，那么这两个部落就会为了争夺这一个点而发生战争。

常年的征战让两个部落不堪重负，因此第二个部落的族长作出了一个英明的决定，他打算选择一个向量 $(dx,dy)$ ，让所有的族人都迁徙这个向量的距离，即所有第二阵营的人的坐标都变成 $(x_i+dx,y_i+dy)$ 。

现在他计划了 $q$ 个迁徙的备选方案，他想要你来帮忙对每一个迁徙方案，计算一下在完成了迁徙之后，两个部落之间还会不会因为争夺领地而发生战争。


## 说明/提示

**样例 1 解释**

下图为第一组方案中两个部落的私人领地，点 $(0,0)$ 同时属于两个部落，因此会发生战争。

![0](https://i.loli.net/2018/05/05/5aed12638bab1.png)

下图为第二组方案中两个部落的私人领地，没有点同时属于两个部落，因此不会发生战争。

![1](https://i.loli.net/2018/05/05/5aed1293ce6ca.png)

下图为第三组方案中两个部落的私人领地，点 $(0,0)$ 同时属于两个部落，因此会发生战争。

![2](https://i.loli.net/2018/05/05/5aed12a4e3545.png)

**数据范围**

对于 $20\%$ 的数据， $n,m\le 5,q\le 500$。

对于 $40\%$ 的数据， $n,m\le 50,q\le 500$ 。

对于 $70\%$ 的数据， $n,m\le 10^4,q\le 500$ 。

对于 $100\%$ 的数据， $n,m\le 10^5,q\le 10^5$ 。

对于 $100\%$ 的数据，保证 $-10^8\le x_i,y_i,dx_i,dy_i\le 10^8;n,m\ge 3$ 。所有人的坐标两两不同且对于每一个阵营,所有人都不全共线。

**2024/08/20 增加 6 组 hack 数据，并公开在本题附件。**

## 样例 #1

### 输入

```
4 4 3
0 0
1 0
0 1
1 1
-1 0
0 3
0 2
0 -1
0 0
2 3
0 -1```

### 输出

```
1
0
1```

# AI分析结果

# 💡 Kay的C++算法解析：[JSOI2018]战争 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：计算几何（凸包、闵可夫斯基和）

🗣️ **初步分析**：  
解决“战争”这道题，关键在于理解**闵可夫斯基和**的概念及其在计算几何中的应用。简单来说，闵可夫斯基和就像“积木拼接”——把两个凸包的边按方向（极角）排序后，像拼积木一样依次连接，形成一个新的凸包。这个新凸包包含了两个原凸包所有可能的“组合点”（如本题中的`a-b`）。  

在本题中，两个部落的领地是各自点集的**凸包**（因为三角形覆盖的区域等价于点集的凸包）。移动向量`w`后是否冲突，等价于判断`w`是否属于`A`（部落1的凸包）与`-B`（部落2凸包取反）的闵可夫斯基和。核心流程是：  
1. 求两个点集的凸包；  
2. 求`A`与`-B`的闵可夫斯基和（新凸包）；  
3. 判断每个询问的`w`是否在新凸包内。  

**核心难点**：  
- 理解闵可夫斯基和的几何意义（如何通过两个凸包的边拼接新凸包）；  
- 正确实现凸包算法（避免三点共线等细节错误）；  
- 高效判断点是否在凸包内（二分+叉积）。  

**可视化设计思路**：  
用8位像素风格展示：  
- **凸包形成**：点按坐标排序后，用栈逐步“勾勒”凸包，边用彩色线条高亮；  
- **闵可夫斯基和**：两个凸包的边按极角归并，像“搭积木”一样逐步形成新凸包；  
- **点在凸包内判断**：用二分法找到向量所在的“三角形区域”，叉积判断方向时用闪烁效果提示。  

**游戏化元素**：  
- 步进/自动播放：单步执行凸包或闵可夫斯基和的每一步，自动播放时像“贪吃蛇”一样逐步构建；  
- 音效：凸包点入栈时“叮”一声，闵可夫斯基和边归并时“嗒”一声，点在凸包内时“滴”一声；  
- 过关机制：完成凸包形成、闵可夫斯基和、点判断分别视为“小关卡”，通关后显示“胜利”动画。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下高评分题解，帮助大家快速理解核心逻辑：
</eval_intro>

### 题解一：作者xzyxzy（赞47）
* **点评**：  
  这道题解是闵可夫斯基和的经典模板题解，思路**极其清晰**——从闵可夫斯基和的定义出发，用“归并凸包边”的方法构建新凸包，最后用二分+叉积判断点在凸包内。代码规范，变量名（如`Convex`求凸包、`Minkowski`求闵可夫斯基和）直观，细节处理到位（如最后重新求凸包去除三点共线）。特别适合初学者作为模板背诵，理解闵可夫斯基和的“边拼接”逻辑。

### 题解二：作者WinXP（赞34）
* **点评**：  
  这道题解的**几何意义解释**非常出色——用图形演示了凸包平移的并集就是闵可夫斯基和，帮助学习者直观理解“为什么要拼接边”。代码中的`graham`函数（Graham扫描法求凸包）和`init`函数（点在凸包内判断）逻辑直白，注释详细。尤其适合对“闵可夫斯基和是什么”有疑惑的同学，通过图形例子快速入门。

### 题解三：作者bloodstalk（赞16）
* **点评**：  
  这道题解的**细节处理**堪称典范——详细解释了“为什么要将B取反”（将`a-b`转化为`a+(-b)`）、“如何用叉积判断边的极角顺序”，甚至给出了代码中`ConvexHull`（Andrew算法）和`Minkovski`（归并边）的逐行注释。对于想深入理解实现细节的同学，这道题解是“手把手教学”级别的。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
以下是解决本题的3个核心难点及对应的解决策略，帮你“避坑”：
</difficulty_intro>

### 1. 难点：闵可夫斯基和的理解
**问题**：为什么两个凸包的边可以拼接成新的凸包？  
**解决策略**：  
  闵可夫斯基和是“凸包A平移所有凸包B的点后的并集”。由于凸包的边是“向外突出”的，新凸包的边必然来自原凸包的边（比如A的边平移B的点，或B的边平移A的点）。通过**归并排序**将原凸包的边按极角排序，就能依次拼接成新凸包。

### 2. 难点：凸包算法的正确实现
**问题**：如何避免凸包算法中的三点共线、排序错误？  
**解决策略**：  
  推荐使用**Andrew算法**（按x/y排序+单调栈），步骤如下：  
  1. 按y坐标排序（y相同按x），取最左下点作为起点；  
  2. 按极角排序其余点（极角相同按距离）；  
  3. 用栈维护凸包：若新点导致“右转”（叉积≤0），则弹出栈顶点。  
  代码中注意**栈的初始化**（起点入栈）和**最后重新求凸包**（去除三点共线）。

### 3. 难点：点在凸包内的判断
**问题**：如何高效判断向量是否在凸包内？  
**解决策略**：  
  1. 将凸包平移至原点（取最左下点为新原点）；  
  2. 按极角排序凸包的边，形成“扇形”区域；  
  3. 二分查找向量所在的“扇形区域”（用叉积判断方向）；  
  4. 判断向量是否在该区域的三角形内（叉积≤0则在内部）。  
  关键是**二分的边界处理**（避免越界）和**叉积的符号**（正数表示逆时针方向）。

### ✨ 解题技巧总结
- **模板化**：凸包、闵可夫斯基和、点在凸包内都是计算几何的基础模板，背诵并理解模板是关键；  
- **画图辅助**：遇到几何问题先画图，比如闵可夫斯基和可以画两个凸包的平移并集，直观理解；  
- **细节检查**：叉积容易溢出（用long long），凸包排序时极角相同按距离（避免三点共线），最后重新求凸包（去除冗余点）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解的通用代码**，帮你把握整体框架：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：  
  本代码综合了xzyxzy、WinXP、bloodstalk的思路，用Andrew算法求凸包，归并边求闵可夫斯基和，二分+叉积判断点在凸包内，是最简洁的模板实现。

* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
typedef long long ll;

struct Point {
    ll x, y;
    Point() {}
    Point(ll x, ll y) : x(x), y(y) {}
    Point operator-(const Point& p) const { return Point(x-p.x, y-p.y); }
    Point operator+(const Point& p) const { return Point(x+p.x, y+p.y); }
    ll operator*(const Point& p) const { return x*p.y - y*p.x; } // 叉积
    ll len() const { return x*x + y*y; } // 模长平方
};

// Andrew算法求凸包，返回凸包点数
int convex(vector<Point>& p) {
    int n = p.size();
    sort(p.begin(), p.end(), [](const Point& a, const Point& b) {
        return a.y < b.y || (a.y == b.y && a.x < b.x);
    });
    vector<Point> stk;
    for (int i = 0; i < n; i++) {
        while (stk.size() >= 2) {
            Point a = stk[stk.size()-2], b = stk.back();
            if ((b - a) * (p[i] - a) <= 0) stk.pop_back();
            else break;
        }
        stk.push_back(p[i]);
    }
    int top = stk.size();
    for (int i = n-2; i >= 0; i--) {
        while (stk.size() > top) {
            Point a = stk[stk.size()-2], b = stk.back();
            if ((b - a) * (p[i] - a) <= 0) stk.pop_back();
            else break;
        }
        stk.push_back(p[i]);
    }
    stk.pop_back(); // 去掉重复的起点
    p.swap(stk);
    return p.size();
}

// 求闵可夫斯基和，返回新凸包
vector<Point> minkowski(const vector<Point>& A, const vector<Point>& B) {
    int n = A.size(), m = B.size();
    vector<Point> sa, sb;
    for (int i = 0; i < n; i++) sa.push_back(A[(i+1)%n] - A[i]);
    for (int i = 0; i < m; i++) sb.push_back(B[(i+1)%m] - B[i]);
    vector<Point> res;
    res.push_back(A[0] + B[0]);
    int i = 0, j = 0;
    while (i < n && j < m) {
        if (sa[i] * sb[j] >= 0) {
            res.push_back(res.back() + sa[i]);
            i++;
        } else {
            res.push_back(res.back() + sb[j]);
            j++;
        }
    }
    while (i < n) {
        res.push_back(res.back() + sa[i]);
        i++;
    }
    while (j < m) {
        res.push_back(res.back() + sb[j]);
        j++;
    }
    convex(res); // 重新求凸包去除冗余点
    return res;
}

// 判断点p是否在凸包h内
bool in_convex(const vector<Point>& h, Point p) {
    int n = h.size();
    Point o = h[0];
    vector<Point> hp(n);
    for (int i = 0; i < n; i++) hp[i] = h[i] - o;
    p = p - o;
    if (hp[1] * p < 0 || hp.back() * p > 0) return false;
    int l = 1, r = n-1;
    while (r - l > 1) {
        int mid = (l + r) / 2;
        if (hp[mid] * p >= 0) l = mid;
        else r = mid;
    }
    return (hp[l+1] - hp[l]) * (p - hp[l]) <= 0;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, q;
    cin >> n >> m >> q;
    vector<Point> A(n), B(m);
    for (int i = 0; i < n; i++) cin >> A[i].x >> A[i].y;
    for (int i = 0; i < m; i++) {
        cin >> B[i].x >> B[i].y;
        B[i].x = -B[i].x; // 取反B
        B[i].y = -B[i].y;
    }
    convex(A); convex(B);
    vector<Point> C = minkowski(A, B);
    while (q--) {
        Point w;
        cin >> w.x >> w.y;
        cout << (in_convex(C, w) ? "1" : "0") << '\n';
    }
    return 0;
}
```

* **代码解读概要**：  
  1. **凸包函数`convex`**：用Andrew算法求凸包，按y/x排序后用栈维护；  
  2. **闵可夫斯基和`minkowski`**：提取两个凸包的边（相邻点差分），归并边形成新凸包；  
  3. **点在凸包内`in_convex`**：平移凸包至原点，二分查找向量所在区域，叉积判断方向；  
  4. **主函数**：读入点集，求凸包，求闵可夫斯基和，处理每个询问。


### 题解一（xzyxzy）核心代码片段赏析
* **亮点**：  
  用“归并凸包边”的方法构建闵可夫斯基和，逻辑**简洁高效**。

* **核心代码片段**：
```cpp
void Minkowski() {
    for (ll i = 1; i < n; i++) s1[i] = C1[i+1] - C1[i]; s1[n] = C1[1] - C1[n];
    for (ll i = 1; i < m; i++) s2[i] = C2[i+1] - C2[i]; s2[m] = C2[1] - C2[m];
    A[tot=1] = C1[1] + C2[1];
    ll p1=1, p2=1;
    while (p1<=n && p2<=m) {
        tot++;
        A[tot] = A[tot-1] + (s1[p1] * s2[p2] >= 0 ? s1[p1++] : s2[p2++]);
    }
    while (p1<=n) { tot++; A[tot] = A[tot-1] + s1[p1++]; }
    while (p2<=m) { tot++; A[tot] = A[tot-1] + s2[p2++]; }
}
```

* **代码解读**：  
  - `s1`和`s2`是凸包`C1`、`C2`的边（相邻点差分）；  
  - `A[1]`是两个凸包的起点之和（最左下点）；  
  - 归并边：比较`s1[p1]`和`s2[p2]`的极角（叉积≥0表示`s1`极角更小），优先加入极角小的边；  
  - 最后处理剩余边，形成完整的闵可夫斯基和。

* 💡 **学习笔记**：  
  闵可夫斯基和的核心是“归并边”——凸包的边按极角排序，归并后直接拼接就能形成新凸包，无需额外排序！


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计一个**8位像素风格的动画**，直观展示闵可夫斯基和的构建过程：
</visualization_intro>

### 动画主题：“像素凸包探险”
**核心演示内容**：  
展示凸包的形成、闵可夫斯基和的归并、点在凸包内的判断，融合游戏化元素。

### 动画步骤与交互设计
1. **场景初始化**：  
   - 屏幕左侧显示两个点集（部落1用蓝色像素块，部落2用红色）；  
   - 右侧控制面板有“开始/暂停”“单步”“重置”按钮，速度滑块；  
   - 8位风格背景音乐（如《超级马里奥》的轻松旋律）开始播放。

2. **凸包形成**：  
   - 点按y/x排序（蓝色点从下到上排列）；  
   - 栈逐步加入点，每加入一个点，该点闪烁并“叮”一声；  
   - 凸包形成后，边用绿色线条连接，显示“凸包完成！”。

3. **闵可夫斯基和**：  
   - 部落2的点取反（红色变紫色）；  
   - 提取两个凸包的边（蓝色边和紫色边），按极角归并；  
   - 每归并一条边，新凸包的点用黄色像素块显示，边用橙色线条连接，“嗒”一声。

4. **点在凸包内判断**：  
   - 询问的向量用粉色像素块显示；  
   - 平移凸包至原点（黄色凸包向左下移动）；  
   - 二分查找向量所在区域，叉积判断时该区域闪烁，“滴”一声表示在内部。

5. **交互控制**：  
   - 单步：点击“单步”执行凸包或闵可夫斯基和的下一步；  
   - 自动播放：点击“开始”后，动画像“贪吃蛇”一样逐步构建；  
   - 重置：恢复初始状态，重新开始。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
闵可夫斯基和是计算几何的基础工具，以下问题可以帮你巩固：
</similar_problems_intro>

### 通用思路迁移
闵可夫斯基和常用于**两个凸包的组合问题**，比如：  
- 两个凸包的交集判断（转化为点是否在闵可夫斯基和内）；  
- 凸包的平移/旋转后的覆盖区域（用闵可夫斯基和快速计算）。

### 练习推荐（洛谷）
1. **洛谷P3829 [SHOI2012]信用卡凸包**  
   🗣️ **推荐理由**：考察凸包的变形（信用卡的凸包是原凸包的放大），帮助巩固凸包算法。  
2. **洛谷P4166 [SCOI2007]降雨量**  
   🗣️ **推荐理由**：虽然不是计算几何，但考察二分法的应用，帮助巩固点在凸包内的二分逻辑。  
3. **洛谷P2742 [USACO5.1]圈奶牛Fencing the Cows**  
   🗣️ **推荐理由**：经典凸包模板题，帮助熟练掌握Andrew算法的实现。


## 7. 学习心得与经验分享（若有）

<insights_intro>
以下是题解中作者的宝贵经验，帮你避坑：
</insights_intro>

> **参考经验（来自作者_LHF_）**：  
> “我发现xzyxzy的题解中`if(a*A[1]>0||A[tot]*a>0) return 0;`有问题——A[1]已经是原点，叉积一定为0。正确的判断应该是平移凸包至原点后，用极角范围判断。”  
> **点评**：  
> 这个经验提醒我们**细节的重要性**——代码中的“原点平移”是点在凸包内判断的关键，否则会出现逻辑错误。遇到问题时，一定要手动模拟代码的执行流程（比如代入样例中的点），找出错误。


## 8. 总结
本次分析了“[JSOI2018]战争”的核心算法——闵可夫斯基和，从题目解读、优质题解、代码实现到可视化设计，帮你全面掌握。记住：计算几何的关键是**理解几何意义**+**背诵模板**+**细节检查**。下次遇到类似问题，不妨先画个图，再用模板解决！💪

---
本次指南到此结束，希望对你有帮助！下次我们一起探索更多计算几何问题～

---
处理用时：135.29秒
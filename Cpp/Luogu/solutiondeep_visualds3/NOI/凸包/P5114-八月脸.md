# 题目信息

# 八月脸

## 题目背景

Cdm1020 十分喜欢 August-soft 出品的游戏，在游玩 august 社历届作品的时候他突然发现了一些神奇的事实。

**那就是所有的人物立绘的脸都是一样的!**


![](https://i.loli.net/2018/09/17/5b9fb47a8b3e0.gif)

不过尽管如此，作为一名资深的八月厨，他依然可以敏锐的分辨出各张立绘之间的细微差异 ~~（并不，就是同一张脸有什么好分辨的）~~，为了进一步研究八月社的立绘水平，Cdm1020 将八月社的所有立绘都放到了一颗树上 ~~（什么鬼啊）~~

（如果你不知道什么是树的话，你可以将树理解为一个无环的无向连通图）

具体来讲树上的每个节点仅保存了一张八月社的立绘，Cdm1020 通过和他的八月厨朋友们交流发现，狂热程度不同的八月厨对于同一张立绘的喜爱程度是不一样的，具体来讲每张立绘有两个属性 $a$ 和 $b$，对于一个狂热指数为 $k$ 的八月厨来讲，他对一张属性为 $(a,b)$ 的立绘的喜爱程度为 $ka+b$。

现在 Cdm1020 想要带领他的 $m$ 个狂热指数不同的朋友参观八月社的立绘（们），他希望你对于他的每一个朋友，帮他规划出一条喜爱程度之和最大的游览路线。

当然这个问题很简单，他是不会拿来烦你的。现在他真正头疼的事情是八月社新来了一个画师夏野。他的朋友们现在闹腾着想要看八月社的新立绘 ~~（反正还是一张脸有什么好看的）~~，所以他规定你的路线必须从一张属于 b 叔的立绘开始，到一张属于夏野的立绘结束，你能帮帮他吗？

## 题目描述

**请忽略上面的鬼话，就当什么也没看见**

一句话题意，给定一颗 $n$ 个点的树，树上每个点不是黑色就是白色，每个点有两个属性 $a$ 和 $b$。

现在多组询问，每次询问仅给出一个参数 $k$，要求你从树上找出一条路径 $(u,v)$ 使得 $u$ 和 $v$ 的颜色不同并且

$$k\times \sum_{p \in path (u-v)}p.a+\sum_{p\in path(u-v)}p.b$$

最大，对于每个询问你仅需要输出这个最大值即可（式子里面的两个和式的意思分别是路径上的点 $a$ 属性之和和路径上点的 $b$ 属性之和）。

**tips: $a,b,k$ 均可正可负，并且我们不允许你不选路径，也就是说我们求出的的最大值可以是一个负数，这会发生在所有合法路径的权值都是负数的时候**。

## 说明/提示

$2 \leq n\leq 10^5$，$1 \leq m \leq 10^5$，$-10^8 \leq k \leq 10^8 $

保证不会存在所有点都是黑色或者都是白色的数据，保证对于树上的任意路径，路径上点的 $a$ 属性之和的绝对值不超过$1.5×10^9$，路径上点的 $b$ 属性之和的绝对值不超过 $1.5×10^9$。

## 样例 #1

### 输入

```
15 15
29 -23 -14 -50 -13 -23 5 33 50 32 27 27 -9 -42 -11
-37 39 21 50 10 -42 -2 25 1 28 40 -45 -24 -29 47
0 0 1 0 0 1 1 0 0 1 0 1 0 0 0
2 1
3 1
4 3
5 2
6 2
7 2
8 4
9 1
10 2
11 5
12 3
13 5
14 3
15 9
-8
36
44
29
-5
-4
-3
-2
-1
0
1
2
3
4
5
```

### 输出

```
679
3252
3988
2608
436
355
274
199
135
126
155
232
309
386
471
```

# AI分析结果

---
# 💡 Kay的C++算法解析：八月脸 深入学习指南 💡

<introduction>
今天我们来一起分析“八月脸”这道C++编程题。这道题结合了**树分治**和**凸包技巧**，是考察树上路径问题与线性函数优化的经典题目。本指南将帮你梳理思路、理解核心算法，并掌握解题技巧~
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：树分治（点分治/边分治） + 凸包优化（线性函数最大值查询）

🗣️ **初步分析**：
解决“八月脸”的关键，在于把**树上路径问题**拆解成小问题（树分治），再用**凸包**快速回答线性函数的最大值查询。  
- **树分治**像“拆积木”：把一棵大树不断拆成更小的子树（通过找重心或边分），每次处理经过当前根/边的路径，避免重复计算。  
- **凸包**像“整理直线”：题目要求的`k*sum(a)+sum(b)`，可以看成求直线`y = k*x + b`的最大值（其中`x`是路径`a`和，`b`是路径`b`和）。把所有可能的路径转化为“直线”，用凸包维护这些直线，就能在O(log n)时间内回答每个`k`的最大值。  

**题解思路共性**：  
所有优质题解都用了“树分治 + 凸包”的组合：  
1. 用树分治（点分/边分）处理树上路径，把问题拆解为“经过当前根/边的路径”。  
2. 对每个子树，维护**黑点路径**和**白点路径**的凸包（存储`sum(a), sum(b)`）。  
3. 合并不同子树的凸包（用**闵可夫斯基和**，即路径拼接），得到所有异色路径的凸包。  
4. 最后用凸包快速回答每个`k`的最大值。  

**核心难点与解决**：  
- 难点1：如何高效维护子树的凸包？→ 用点分治的“合并果子”策略（优先队列合并小凸包，保证复杂度）。  
- 难点2：如何合并两个凸包（路径拼接）？→ 用**闵可夫斯基和**，把两个凸包的点相加，得到新的凸包。  
- 难点3：如何处理“异色路径”？→ 分别维护黑白凸包，合并时只取“黑+白”或“白+黑”的组合。  

**可视化设计思路**：  
我们会用**8位像素风**展示树的结构，点分治的“拆树”过程（重心高亮），凸包的构建（点逐步加入、线段形成），以及查询时的“直线滑动”。关键步骤用**颜色高亮**（比如当前处理的子树标蓝色，凸包的切线标红色），配合**音效**（合并凸包时“叮”一声，查询到最大值时“叮~”的长音）。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3份优质题解，帮你快速理解核心逻辑~
</eval_intro>

**题解一：点分治 + 合并果子 + 凸包（作者：qwaszx）**  
* **点评**：这份题解的思路最“直观”——用点分治拆树，用**优先队列合并子树凸包**（合并果子策略），避免了重复计算。代码规范（变量名如`Hull`、`minkowski`清晰），对凸包的构建（`push`函数）和闵可夫斯基和的实现很严谨。特别是用`priority_queue`按凸包大小合并，保证了O(n log²n)的复杂度，实践中跑的很快~

**题解二：边分治 + 三度化 + 凸包（作者：final_trump）**  
* **点评**：边分治是处理树上路径的另一种思路，适合“边”为核心的问题。这份题解解决了边分治的**三度化问题**（把树转化为最多3度的树，方便分治），并用闵可夫斯基和合并两边的凸包。代码中`rebuild`函数（三度化）和`minkowski`函数的实现很巧妙，适合想学习边分治的同学~

**题解三：点分治 + 小根堆合并 + 凸包（作者：xlpg0713）**  
* **点评**：这份题解的代码最“简洁”，用`priority_queue`（小根堆）合并子树凸包，避免了大根堆的复杂度问题。对“合并果子”的理解很到位（每次合并最小的两个凸包），并且处理了根节点的异色路径（直接添加根的`w[u]`）。适合刚学点分治的同学参考~


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点，在于“树分治的路径处理”和“凸包的维护与合并”。结合优质题解，我们总结了3个关键问题及解决方案~
</difficulty_intro>

1. **难点1：如何处理树上的异色路径？**  
   * **分析**：题目要求路径两端颜色不同，直接枚举所有路径会超时（O(n²)）。  
   * **解决方案**：用树分治拆成“经过当前根的路径”，对每个子树维护**黑点路径凸包**和**白点路径凸包**。合并时，只取“黑+白”或“白+黑”的组合（用闵可夫斯基和），保证路径异色。  

2. **难点2：如何维护子树的凸包？**  
   * **分析**：每个子树的路径有很多，直接存储所有路径会爆内存（O(n²)）。  
   * **解决方案**：用**凸包**维护有效路径——对于线性函数`k*x + y`，只有凸包上的点（直线）才可能成为最大值。构建凸包时，按`x`排序，用单调栈去掉冗余点。  

3. **难点3：如何合并两个子树的凸包？**  
   * **分析**：两个子树的路径拼接（比如子树A的路径+子树B的路径），对应的`x`和`y`是相加的，需要合并凸包。  
   * **解决方案**：用**闵可夫斯基和**——把两个凸包的点相加，得到新的凸包。比如凸包A的点`(x1,y1)`和凸包B的点`(x2,y2)`相加得到`(x1+x2,y1+y2)`，这正好对应路径拼接后的`sum(a)`和`sum(b)`。  

### ✨ 解题技巧总结
- **树分治选择**：点分治适合“点”为核心的问题，边分治适合“边”为核心的问题（需三度化）。  
- **凸包维护**：按`x`排序，用单调栈构建上凸包（因为`k`可正可负，上凸包对应最大值）。  
- **合并策略**：用“合并果子”（小根堆）合并凸包，保证每次合并的是最小的两个，复杂度最优。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用点分治+凸包**的核心实现，帮你把握整体框架~
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了qwaszx和xlpg0713的思路，展示点分治+合并果子+凸包的核心逻辑。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
typedef long long ll;

struct Point {
    ll x, y;
    Point operator+(const Point& a) const { return {x+a.x, y+a.y}; }
    Point operator-(const Point& a) const { return {x-a.x, y-a.y}; }
    bool operator>=(const Point& a) const { return x*a.y <= y*a.x; } // 叉积判断方向
    ll f(int k) const { return (ll)k*x + y; }
};

struct Hull { // 上凸包
    vector<Point> a;
    void push(const Point& p) {
        while (a.size() >= 2) {
            Point p1 = a[a.size()-2], p2 = a.back();
            if ((p - p2) >= (p2 - p1)) a.pop_back(); // 去掉冗余点
            else break;
        }
        a.push_back(p);
    }
};

Hull mergeHull(const Hull& a, const Hull& b) { // 合并两个凸包（按x排序）
    Hull res;
    int i = 0, j = 0;
    while (i < a.a.size() && j < b.a.size()) {
        if (a.a[i].x < b.a[j].x) res.push(a.a[i++]);
        else if (a.a[i].x > b.a[j].x) res.push(b.a[j++]);
        else { // x相同，保留y大的
            if (a.a[i].y > b.a[j].y) res.push(a.a[i++]);
            else res.push(b.a[j++]);
        }
    }
    while (i < a.a.size()) res.push(a.a[i++]);
    while (j < b.a.size()) res.push(b.a[j++]);
    return res;
}

Hull minkowski(const Hull& a, const Hull& b) { // 闵可夫斯基和（合并两个凸包的点相加）
    Hull res;
    if (a.a.empty() || b.a.empty()) return res;
    res.push(a.a[0] + b.a[0]);
    int i = 0, j = 0;
    while (i + 1 < a.a.size() || j + 1 < b.a.size()) {
        Point v1 = (i+1 < a.a.size()) ? (a.a[i+1] - a.a[i]) : Point{0, -1e18};
        Point v2 = (j+1 < b.a.size()) ? (b.a[j+1] - b.a[j]) : Point{0, -1e18};
        if (v1 >= v2) { // 选v1的方向
            i++;
            res.push(res.a.back() + v1);
        } else { // 选v2的方向
            j++;
            res.push(res.a.back() + v2);
        }
    }
    return res;
}

// 点分治的核心函数（省略找重心、dfs子树等代码）
void solve(int root) {
    priority_queue<pair<int, int>> q; // 小根堆（按凸包大小）
    // 处理子树，得到每个子树的黑白凸包
    while (q.size() > 1) {
        auto [s1, u] = q.top(); q.pop();
        auto [s2, v] = q.top(); q.pop();
        // 合并u和v的凸包，计算闵可夫斯基和（异色路径）
        Hull h_black_white = minkowski(h_black[u], h_white[v]);
        Hull h_white_black = minkowski(h_white[u], h_black[v]);
        // 合并后的凸包加入队列
        Hull new_black = mergeHull(h_black[u], h_black[v]);
        Hull new_white = mergeHull(h_white[u], h_white[v]);
        q.push({new_black.a.size() + new_white.a.size(), new_node});
    }
}

int main() {
    // 输入处理、点分治初始化
    return 0;
}
```
* **代码解读概要**：  
  代码分为三部分：1. 凸包的构建与合并（`Hull`结构体、`mergeHull`、`minkowski`）；2. 点分治的核心逻辑（`solve`函数，用优先队列合并子树）；3. 主函数的输入处理。关键是用`minkowski`合并异色凸包，用`mergeHull`合并同色凸包。


<code_intro_selected>
接下来，我们剖析优质题解的核心片段~
</code_intro_selected>

**题解一（qwaszx）：闵可夫斯基和实现**  
* **亮点**：正确实现了闵可夫斯基和，处理了凸包的方向问题。
* **核心代码片段**：
```cpp
Hull Minkow(const Hull &a, const Hull &b) {
    Hull tmp; if(!a.len||!b.len)return tmp;
    tmp.push(a[0]+b[0]); int i=0,j=0;
    for(;i<a.len-1||j<b.len-1;)
        if(i==a.len-1)tmp.push(a[i]+b[++j]);
        else if(j==b.len-1)tmp.push(a[++i]+b[j]);
        else tmp.push((a[i+1]-a[i])>=(b[j+1]-b[j])?a[++i]+b[j]:a[i]+b[++j]);
    return tmp;
}
```
* **代码解读**：  
  这段代码是闵可夫斯基和的核心——从两个凸包的起点开始，每次选择“方向更陡”的边（用`>=`判断叉积），逐步扩展新的凸包点。比如`a[i+1]-a[i]`是凸包a的下一条边，`b[j+1]-b[j]`是凸包b的下一条边，选方向更陡的边，保证新凸包的单调性。

**题解二（final_trump）：边分治三度化**  
* **亮点**：解决了边分治的“三度化”问题，把树转化为最多3度的树。
* **核心代码片段**：
```cpp
void rebuild(int u, int fa) {
    int last=u, top=0;
    for(int i=head[u];i;i=e[i].next) {
        int v=e[i].to; if(v==fa) continue;
        son[++top]=v; 
    }
    for(int i=1;i<=top-2;++i) {
        Tree2::addedge(last, son[i]);
        Tree2::addedge(last, ++tot);
        rev[last=tot]=u; val[last]=val[u];
    }
    if(top>1) Tree2::addedge(last, son[top-1]);
    if(top>0) Tree2::addedge(last, son[top]);
    for(int i=head[u];i;i=e[i].next) {
        int v=e[i].to; if(v==fa) continue;
        rebuild(v,u);
    }
}
```
* **代码解读**：  
  这段代码把每个节点的子节点数超过2的部分，拆成新的节点（`++tot`），保证每个节点的度不超过3。比如一个节点有4个子节点，拆成`u -> new1 -> new2 -> 子节点3、4`，这样边分治时每次能平分子树大小，保证复杂度。

**题解三（xlpg0713）：合并果子策略**  
* **亮点**：用小根堆合并凸包，避免大根堆的复杂度问题。
* **核心代码片段**：
```cpp
priority_queue<pii, vector<pii>, greater<pii>> q;
while(q.size()>1){
    auto xx=q.top(); q.pop(); auto yy=q.top(); q.pop();
    calc(xx.second, yy.second, x); ++o;
    a[o][0] = mg(a[xx.second][0], a[yy.second][0]);
    a[o][1] = mg(a[xx.second][1], a[yy.second][1]);
    q.push({a[o][0].n+a[o][1].n, o});
}
```
* **代码解读**：  
  用`greater<pii>`实现小根堆，每次取出最小的两个凸包（`xx`和`yy`），合并它们的黑白凸包（`mg`函数），并计算异色路径的闵可夫斯基和（`calc`函数）。合并后的凸包重新加入队列，保证每次合并的代价最小（总复杂度O(n log²n)）。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们用**8位像素风**（FC游戏风格）展示算法过程，融入游戏化元素，让学习更有趣~
</visualization_intro>

### 🌟 动画主题：《像素树的凸包冒险》
**核心演示内容**：展示点分治拆树、凸包构建、闵可夫斯基和合并、查询最大值的过程。  
**设计思路**：用像素块模拟树结构（节点是彩色方块，边是线条），凸包用“折线”表示，关键步骤用**颜色高亮**和**音效**强化记忆。

### 🎮 动画帧与交互设计
1. **场景初始化**：  
   - 屏幕左侧是**像素树**（根节点标红色，子节点标蓝色），右侧是**控制面板**（开始/暂停、单步、重置按钮，速度滑块）。  
   - 播放8位风格的背景音乐（比如《超级马里奥》的轻快旋律）。

2. **点分治拆树**：  
   - 找重心：当前根节点闪烁，周围子节点用箭头指向重心，伴随“滴”的音效。  
   - 拆分子树：重心的子树用不同颜色（比如子树1标绿色，子树2标黄色），展示“拆积木”的过程。

3. **凸包构建**：  
   - 子树的路径点用“小方块”表示，按`x`排序后，用**单调栈**逐步构建凸包（折线从左到右延伸，冗余点消失时伴随“叮”的音效）。  
   - 凸包的“上边界”用红色折线标出，清晰展示有效路径。

4. **闵可夫斯基和合并**：  
   - 两个子树的凸包（比如子树1的黑凸包和子树2的白凸包）用蓝色和绿色表示，合并时点“相加”（蓝色点+绿色点=紫色点），形成新的凸包，伴随“叮~”的长音。

5. **查询最大值**：  
   - 输入`k`后，“直线”`y=k*x+b`在凸包上滑动，找到切线点（标黄色），输出最大值时播放“胜利”音效（比如《魂斗罗》的通关音）。

### 🎯 交互控制
- **单步执行**：点击“单步”按钮，动画走一步，显示当前步骤的文字提示（比如“正在合并子树1和子树2的凸包”）。  
- **自动播放**：用滑块调整速度（1x~5x），动画自动执行，适合快速浏览整体流程。  
- **重置**：恢复初始状态，重新开始动画。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握“树分治+凸包”后，可以挑战以下相似问题~
</similar_problems_intro>

### 🔍 通用思路迁移
- 树分治可用于**树上路径统计**（比如求路径和的最大值、路径长度的第k大）。  
- 凸包可用于**线性函数最大值查询**（比如多个`k`查询`a*k + b`的最大值）。

### 📚 洛谷练习推荐
1. **P5073 「深基2.例7」数字反转** → 不，推荐**P5073 闵可夫斯基和**（原题）：练习凸包的合并，理解闵可夫斯基和的应用。  
2. **P5114 八月脸**（本题）：巩固树分治+凸包的组合。  
3. **CF1019E Raining Season**：边分治的经典问题，练习三度化和凸包合并。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中分享了很多实用经验，比如：
</insights_intro>

> **来自qwaszx的经验**：“合并凸包时用小根堆，避免大根堆的高复杂度。”  
> **点评**：大根堆会每次合并最大的两个凸包，导致总复杂度变高（O(n²)）。小根堆每次合并最小的两个，总复杂度是O(n log²n)，这是“合并果子”问题的经典结论~

> **来自xlpg0713的经验**：“点分治的根节点要处理自身的路径（比如根是黑点，要和子树的白点路径合并）。”  
> **点评**：根节点的路径容易被忽略，必须单独处理（比如根的`w[u]`要加到子树的路径上），否则会漏掉“根到子树节点”的路径。  


<conclusion>
本次关于“八月脸”的分析就到这里~ 树分治+凸包是处理树上路径问题的“神器”，关键是理解“拆问题”和“维护有效信息”的思路。多练习相似问题，你会越来越熟练！下次我们再一起探索新的算法挑战~ 💪
</conclusion>

---

---
处理用时：133.45秒
# 题目信息

# 封锁

## 题目背景

震惊！zbw 竟从 B 城监狱逃出！

作为 B 城的警察局长，你必须在 zbw 逃出你的管辖范围之前抓住他。

## 题目描述

B 城可视为一个 $n \times n$ 的方阵，其中监狱在 $(1,1)$，B 城唯一出城的出口在 $(n,n)$。每两个相邻的点（横坐标之差的绝对值 $+$ 纵坐标之间的绝对值 $=1$）之间都有一条**无向的**道路（没有斜着的道路）。你需要在一些道路上部下防守，使得无论 zbw 怎么走，都至少会经过其中的一条道路。

在一条 $(i,j)$ 到 $(i,j+1)$ 的道路上部下防守的花费是 $r_{i,j}$，在一条 $(i,j)$ 到 $(i+1,j)$ 的道路上部下防守的花费是 $d_{i,j}$，同时，在道路上部下防守会对人民的生活造成影响，在一条 $(i,j)$ 到 $(i,j+1)$ 的道路上部下防守对人民的生活造成的影响是 $x_{i,j}$，在一条 $(i,j)$ 到 $(i+1,j)$ 的道路上部下防守对人民的生活造成的影响是 $y_{i,j}$。

定义总花费为 $w$ ，总影响为 $e$ ，作为一名优秀的警察局长，你需要最小化 $w \times e$。 

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/bjd62iba.png)

如图，左上角为 $(1,1)$，右下角为 $(n,n)$，
其中蓝色数字表示 $r$,
红色数字表示 $x$,
黄色数字表示 $d$,
绿色数字表示 $y$。

最优方案为防守三条边，分别为：

$(2,2)-(2,3),(3,1)-(3,2),(3,2)-(3,3)$

三条边的边权分别是 $2,3$---$1,1$ ---$4,3$

答案为 $(1+2+4)\times (1+3+3)=49$


可以发现没有更优的做法。

**本题采用捆绑测试。**

|  Subtasks| $n$ |特殊性质  |分数
| :----------: | :----------: | :----------: |:----------: |
|  Subtask1| $n=2$ |无  |$5$
|  Subtask2| $n\leq400$ |数据随机  |$15$
|  Subtask3| $n\leq10$ |  无|$15$
|  Subtask4| $n\leq50$ | 无 |$30$
|  Subtask5| $n\leq400$ | 无 |$35$

对于所有数据 $1 \leq n \leq 400$，$0 \leq r_{i,j}, d_{i,j},x_{i,j} ,y_{i,j}  \leq 10^3$。

数据于2020/3/4加强，卡掉部分复杂度错误的做法。

## 样例 #1

### 输入

```
3
8 3
5 2
1 1
4 2
1 2
7 5
7 2
6 1
5 4
2 3
1 4 
4 3```

### 输出

```
49```

# AI分析结果

---
# 💡 Kay的C++算法解析：封锁 深入学习指南 💡

<introduction>
今天我们来一起分析“封锁”这道C++编程题。这道题需要我们在网格图中找到一组边，使得割的总花费和总影响的乘积最小。本指南将帮助大家梳理题目思路，理解核心的“最小乘积模型”，并掌握解题技巧。
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最小乘积模型（属于**编程技巧应用**，侧重算法模型的转化与应用）

🗣️ **初步分析**：
解决“封锁”问题的关键在于理解**最小乘积模型**——我们可以把每个可能的割（即选中的边集合）看作平面上的一个点 `(sum_w, sum_e)`，其中 `sum_w` 是割的总花费，`sum_e` 是总影响。我们的目标是找到这个点，使得 `sum_w × sum_e` 最小。根据数学性质，这样的点一定在所有割点组成的**下凸壳**上（就像“锅底”，反比例函数的最低点一定在凸壳上）。

### 核心算法流程
1. **找凸壳端点**：先找到两个极端点——`sum_w` 最小的点 `A`（只关心花费）和 `sum_e` 最小的点 `B`（只关心影响）。这两个点是凸壳的端点。
2. **分治找凸壳点**：对于当前的两个点 `A` 和 `B`，找一个点 `C`，使得 `C` 在 `AB` 连线的下方且距离最远（即三角形 `ABC` 的面积最大）。这个 `C` 一定在下凸壳上。
3. **递归更新答案**：计算 `C` 的乘积并更新答案，然后递归处理 `A-C` 和 `C-B`，直到没有更优的点。

### 可视化设计思路
我们用**8位像素风**演示这个过程：
- **场景**：像素化的网格图，起点 `(1,1)` 用红色、终点 `(n,n)` 用蓝色，割的边用黄色高亮。
- **凸壳演示**：用绿色线连接 `A` 和 `B`，用橙色点标记 `C`，动态展示 `C` 如何“下落”到凸壳上。
- **交互**：支持“单步执行”（看每一步找 `C` 的过程）、“自动播放”（像贪吃蛇AI一样跑完全程），关键操作（如找 `C`、更新凸壳）伴随“叮”的音效，找到最优解时播放胜利音效。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解，帮助大家理解不同的实现方式。
</eval_intro>

### 题解一：feecle6418（网络流实现）
* **点评**：这道题解详细讲解了最小乘积模型的基础知识，并用网络流（Dinic算法）实现了割的计算。题解强调了“当前弧优化”“清空数组”等网络流的关键细节，还提到了处理权值为0的情况（用1e6代替），避免算法失效。代码结构清晰，适合学习网络流的应用。

### 题解二：gyh20（平面图最小割转最短路）
* **点评**：这道题解的亮点是**将网格图的割转化为最短路问题**——网格的割对应一条从左下到右上的路径。题解用Dijkstra算法代替网络流，大大降低了时间复杂度（适合n=400的大数据）。代码中封装了建图和分治的逻辑，可读性高。

### 题解三：Hollow_knight_（Dijkstra实现最小乘积模型）
* **点评**：这道题解用Dijkstra算法实现了最小乘积模型，思路清晰。题解详细推导了叉积的公式，将找凸壳点的问题转化为求新权值的最短路。代码中封装了建图、Dijkstra和分治函数，适合学习模型的转化过程。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的核心难点在于“将二维问题转化为凸壳问题”和“将凸壳点转化为可计算的最短路/网络流问题”。以下是三个关键难点及解决策略：
</difficulty_intro>

### 关键点1：如何理解“乘积最小”对应“下凸壳”？
* **分析**：乘积 `sum_w × sum_e` 最小的点，相当于在反比例函数 `xy=k` 中找最小的 `k`。而反比例函数的最低点一定在所有点的下凸壳上（凸壳是“向下凸”的，像锅盖的反面）。
* 💡 **学习笔记**：乘积最小的点一定在下凸壳上，这是最小乘积模型的核心性质。

### 关键点2：如何找凸壳上的点？
* **分析**：对于两个点 `A` 和 `B`，找距离 `AB` 最远的点 `C`，等价于找 `(B-A) × (C-A)` 最小的点（叉积的绝对值是三角形面积的两倍）。我们可以将这个叉积公式拆成新的权值，用最短路或网络流计算。
* 💡 **学习笔记**：叉积公式的转化是连接凸壳和最短路的桥梁。

### 关键点3：如何终止递归？
* **分析**：当新找到的点 `C` 不在 `AB` 的下方时（即 `(B-A) × (C-A) ≥ 0`），说明 `C` 不在凸壳上，递归终止。
* 💡 **学习笔记**：叉积的符号是判断点是否在凸壳上的关键。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一个**基于Dijkstra的通用核心实现**，它综合了优质题解的思路，清晰易懂。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码来自Hollow_knight_的题解，用Dijkstra实现最小乘积模型，逻辑清晰、效率高。
* **完整核心代码**：
```cpp
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
typedef long long ll;
const int maxn=405, maxm=maxn*maxn<<1;
const int inf=1e9;

ll ans=2e18;
int n, s, t, ecnt, head[maxm];
int r[maxn][maxn], d[maxn][maxn], x[maxn][maxn], y[maxn][maxn];

struct Node { ll x, y; };
Node operator-(Node a, Node b) { return {a.x-b.x, a.y-b.y}; }
int operator^(Node a, Node b) { return a.x*b.y - a.y*b.x; }

struct Edge { int to, w, a, b, nxt; };
Edge ed[maxm<<1];
void add(int u, int v, int w, int a, int b) {
    ed[++ecnt] = {v, w, a, b, head[u]};
    head[u] = ecnt;
}

struct DijkNode {
    int to, w; Node x;
    bool operator<(const DijkNode& rhs) const { return w > rhs.w; }
} dis[maxm];
priority_queue<DijkNode> q;

Node dijkstra() {
    for (int i=s; i<=t; ++i) {
        dis[i].to = i;
        dis[i].w = inf;
        dis[i].x = {0, 0};
    }
    dis[s].w = 0;
    q.push(dis[s]);
    while (!q.empty()) {
        auto now = q.top(); q.pop();
        for (int i=head[now.to]; i; i=ed[i].nxt) {
            if (now.w + ed[i].w < dis[ed[i].to].w) {
                dis[ed[i].to].w = now.w + ed[i].w;
                dis[ed[i].to].x.x = dis[now.to].x.x + ed[i].a;
                dis[ed[i].to].x.y = dis[now.to].x.y + ed[i].b;
                q.push(dis[ed[i].to]);
            }
        }
    }
    ans = min(ans, dis[t].x.x * dis[t].x.y);
    return dis[t].x;
}

void build(Node A, Node B) {
    ecnt = 0;
    memset(head, 0, sizeof(head));
    for (int i=1; i<n; ++i) {
        for (int j=1, pos; j<n; ++j) {
            pos = (i-1)*(n-1)+j;
            if (j != n-1) {
                int w = r[i][j+1]*(A.y-B.y) + d[i][j+1]*(B.x-A.x);
                add(pos, pos+1, w, r[i][j+1], d[i][j+1]);
                add(pos+1, pos, w, r[i][j+1], d[i][j+1]);
            }
            if (i != n-1) {
                int w = x[i+1][j]*(A.y-B.y) + y[i+1][j]*(B.x-A.x);
                add(pos, pos+n-1, w, x[i+1][j], y[i+1][j]);
                add(pos+n-1, pos, w, x[i+1][j], y[i+1][j]);
            }
        }
    }
    for (int i=1; i<n; ++i) {
        int w = x[1][i]*(A.y-B.y) + y[1][i]*(B.x-A.x);
        add(s, i, w, x[1][i], y[1][i]);
        w = x[n][i]*(A.y-B.y) + y[n][i]*(B.x-A.x);
        add(i+(n-1)*(n-2), t, w, x[n][i], y[n][i]);
        w = r[i][1]*(A.y-B.y) + d[i][1]*(B.x-A.x);
        add((i-1)*(n-1)+1, t, w, r[i][1], d[i][1]);
        w = r[i][n]*(A.y-B.y) + d[i][n]*(B.x-A.x);
        add(s, (i-1)*(n-1)+n-1, w, r[i][n], d[i][n]);
    }
}

void dfs(Node A, Node B) {
    build(A, B);
    Node C = dijkstra();
    if (((B - A) ^ (C - A)) >= 0) return;
    dfs(A, C);
    dfs(C, B);
}

int main() {
    n = scanf("%d", &n), n;
    s = 0;
    t = (n-1)*(n-1) + 2;
    for (int i=1; i<n; ++i)
        for (int j=1; j<=n; ++j)
            scanf("%d%d", &r[i][j], &d[i][j]);
    for (int i=1; i<=n; ++i)
        for (int j=1; j<n; ++j)
            scanf("%d%d", &x[i][j], &y[i][j]);
    
    build({0, 1}, {1, 0});
    Node L = dijkstra();
    build({1, 0}, {0, 1});
    Node R = dijkstra();
    dfs(L, R);
    
    printf("%lld", ans);
    return 0;
}
```
* **代码解读概要**：
  1. **输入处理**：读取网格的边权（花费`r/d`和影响`x/y`）。
  2. **找端点**：分别找`sum_w`最小的点`L`和`sum_e`最小的点`R`。
  3. **分治找凸壳**：递归处理`L-R`，每次找`C`点并更新答案。
  4. **输出结果**：输出最小的乘积。


### 针对各优质题解的片段赏析

#### 题解一：feecle6418（网络流片段）
* **亮点**：用Dinic算法实现最小割，处理大规模数据。
* **核心代码片段**：
  ```cpp
  int Dinic(int s, int t) {
      int ans = 0;
      while (BFS()) {
          memcpy(cur, h, sizeof(h));
          ans += DFS(s, inf, t);
      }
      return ans;
  }
  ```
* **代码解读**：
  这段代码是Dinic算法的核心——`BFS`分层，`DFS`找增广路。`cur`数组是当前弧优化，避免重复遍历已经处理过的边，提高效率。
* **学习笔记**：网络流的关键优化是“当前弧优化”和“分层BFS”。


#### 题解二：gyh20（平面图转最短路片段）
* **亮点**：将割转化为路径，用Dijkstra求最短路。
* **核心代码片段**：
  ```cpp
  for (int i=1; i<n; ++i) {
      for (int j=1; j<n; ++j) {
          int pos = (i-1)*(n-1)+j;
          if (j != n-1) {
              add(pos, pos+1, f[i][j+1], f[i][j+1], f1[i][j+1]);
              add(pos+1, pos, f[i][j+1], f[i][j+1], f1[i][j+1]);
          }
      }
  }
  ```
* **代码解读**：这段代码构建了网格的边——每个点`pos`连接右边的点，边权是`f[i][j+1]`（花费）和`f1[i][j+1]`（影响）。这样，割的边对应路径的边，求最短路就是找最小的割。
* **学习笔记**：平面图的割可以转化为路径的最短路，这是关键的模型转化。


## 5. 算法可视化：像素动画演示

### 动画主题：像素凸壳探险记
我们用**8位像素风**设计一个动画，演示最小乘积模型的过程：

### 核心演示内容
1. **场景初始化**：
   - 像素化的网格图（像FC游戏的画面），起点`(1,1)`是红色，终点`(n,n)`是蓝色，割的边是黄色。
   - 控制面板：“开始/暂停”“单步执行”“重置”按钮，速度滑块，8位风格的背景音乐。
2. **找端点**：
   - 动态展示`sum_w`最小的点`A`（红色点）和`sum_e`最小的点`B`（蓝色点），用绿色线连接`A`和`B`。
3. **分治找C点**：
   - 用橙色点标记`C`，动态展示`C`如何“下落”到凸壳上，伴随“叮”的音效。
   - 用紫色线连接`A-C`和`C-B`，递归处理这两段。
4. **结果展示**：
   - 找到最优解时，割的边闪烁，播放胜利音效（像FC游戏的通关音乐）。


### 交互设计
- **单步执行**：点击“下一步”，看每一步找`C`的过程。
- **自动播放**：像贪吃蛇AI一样跑完全程，速度可以用滑块调整。
- **重置**：回到初始状态，重新演示。


## 6. 拓展练习与相似问题

<similar_problems_intro>
理解了最小乘积模型后，可以练习以下类似问题，巩固知识点：
</similar_problems_intro>

1. **洛谷 P5540 最小乘积生成树**：
   - 🗣️ **推荐理由**：最小乘积模型的模板题，需要找生成树的乘积最小，思路和本题一致。
2. **洛谷 P3236 二分图的最小乘积匹配**：
   - 🗣️ **推荐理由**：将最小乘积模型应用到二分图匹配，练习模型的转化。
3. **洛谷 P6158 封锁（本题）**：
   - 🗣️ **推荐理由**：再次练习本题，巩固分治和最短路的实现。


## 7. 学习心得与经验分享

<insights_intro>
从题解中，我们可以学到以下经验：
</insights_intro>

> **参考经验（来自feecle6418）**：“处理权值为0的情况时，要用1e6代替，否则Dinic算法会失效。”
> **点评**：这是网络流的常见坑点——权值为0的边会被忽略，导致无法找到正确的割。用大值代替可以避免这个问题。

> **参考经验（来自Hollow_knight_）**：“封装函数可以提高代码的复用性，比如建图、Dijkstra函数。”
> **点评**：本题需要多次建图和跑最短路，封装函数可以减少重复代码，提高可读性。


<conclusion>
本次关于“封锁”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解“最小乘积模型”和模型转化的技巧。记住，编程的核心是“转化问题”——把复杂的问题转化为已知的模型（如凸壳、最短路），就能迎刃而解。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：100.90秒
# 题目信息

# [MtOI2019] 幽灵乐团 / 莫比乌斯反演基础练习题

## 题目背景

白玉楼中，冥界的音乐会开始了。

Lunasa，Lyrica 和 Merlin 正在演奏。

## 题目描述

东风谷 早苗(Kochiya Sanae)非常喜欢幽灵乐团的演奏，她想对她们的演奏评分。

因为幽灵乐团有 $3$ 个人，所以我们可以用 $3$ 个正整数 $A,B,C$ 来表示出乐团演奏的分数，她们的演奏分数可以表示为

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}\left(\frac{\text{lcm}(i,j)}{\gcd(i,k)}\right)^{f(type)}$$

因为音乐在不同的部分会有不同的听觉感受，所以 $type$ 会在 $\{0,1,2\}$ 中发生变化，其中：

$$\begin{aligned}
f(0)&=1 \cr
f(1)&=i \times j \times k \cr
f(2)&=\gcd(i,j,k)
\end{aligned}$$

因为乐团的歌实在太好听了，导致分数特别高，所以她们的分数要对给定的正整数 $p$ 取模。

因为有很多歌曲要演奏，所以早苗给出了 $T$ 组询问。

## 说明/提示

### 数据范围及约定

对于 $10\%$ 的数据：  

$$ 1\leq A,B,C\leq 50 $$  

对于 $20\%$ 的数据：  

$$ 1\leq A,B,C\leq 100 $$

另有 $10\%$ 的数据：  

$$ 1\leq A,B,C\leq 100\ \ \ \ \ A=B=C $$  

对于 $60\%$ 的数据：  

$$ 1\leq A,B,C\leq 10^3 $$

对于 $100\%$ 的数据：  

$$ 1\leq A,B,C\leq 10^5 \ \ \ \ 10^7 \leq p \leq 1.05\times 10^9\ \ \ \ p\in \{ prime\} \ \ \ \ T =70$$

---

早苗非常善良，就算你不知道所有的正确答案，她也会给你一些分数。 
 
* 如果你的第一列是正确的，她将会给你这个测试点 $20\%$ 的分数。
* 如果你的第二列是正确的，她将会给你这个测试点 $40\%$ 的分数。
* 如果你的第三列是正确的，她将会给你这个测试点 $40\%$ 的分数。  

所以就算你不知道答案是什么，也请你在你不知道的那些地方输出 $[0,2^{31})$ 内的整数，否则可能会造成不可预估的错误。

### 题目来源

[迷途之家2019联赛](https://www.luogu.org/contest/20135)(MtOI2019) T5

出题人：CYJian 


## 样例 #1

### 输入

```
3 998244853
1 1 1
2 2 2
3 3 3
```

### 输出

```
1 1 1
16 4096 16
180292630 873575259 180292630
```

# AI分析结果

# 💡 Kay的C++算法解析：[MtOI2019]幽灵乐团 深入学习指南 💡


## 1. 题目解读与核心算法识别

### 1.1 初步分析
✨ **本题主要考察**：数论 - 莫比乌斯反演  

莫比乌斯反演就像一把“钥匙”，能把**难以直接计算的gcd乘积/求和问题**转化为可以“批量处理”的形式。比如我们要算很多gcd的乘积，直接枚举每个gcd显然很慢，但用反演可以把问题拆成“枚举公约数的贡献”，再通过**整除分块**快速计算。  

在本题中，所有type的核心都是**将乘积式化简为莫比乌斯函数的求和**，再通过预处理和分块加速计算。比如：
- **type0**：分子是阶乘的幂，分母是gcd乘积的幂，反演后用分块计算gcd的贡献。
- **type1**：分子是i^i的乘积，分母是gcd的ij次幂，反演后处理i^i和gcd的高次幂。
- **type2**：最复杂，需要拆分gcd(i,j,k)，结合欧拉函数φ处理多层嵌套的gcd。


## 2. 精选优质题解参考

### 题解一：作者CYJian（出题人题解）
* **点评**：这份题解是“官方思路”，覆盖了所有type的完整推导，逻辑链清晰。比如type0的gcd乘积化简、type1的i^i处理、type2的φ函数应用，每一步都有明确的式子推导。代码结构对应推导步骤，变量名（如`mu`、`phi`）直观，适合初学者跟随推导。亮点是**将复杂问题拆分成“预处理辅助函数+分块计算”**，这是莫比乌斯反演的通用套路。

### 题解二：作者灵乌路空（详细推导）
* **点评**：题解用“分步拆解”的方式讲透了type2的复杂化简，比如将gcd(i,j,k)拆分为φ函数的贡献，再通过“约掉相同项”简化计算。代码中的`g0`、`g1`等辅助函数对应推导中的关键步骤，注释详细，适合理解“为什么这么写”。亮点是**将type2的复杂式子转化为可复用的分块逻辑**，降低了代码复杂度。

### 题解三：作者qwaszx（简洁明了）
* **点评**：题解用“模块化”思路处理每个type，比如将type0、type1、type2的分子分母分别封装为函数，代码可读性高。对于莫比乌斯反演的核心——辅助函数`f(T)`的预处理，用埃氏筛的方式实现，逻辑清晰。亮点是**代码结构与推导步骤一一对应**，便于快速定位问题。


## 3. 核心难点辨析与解题策略

### 3.1 核心难点
1. **将乘积转化为莫比乌斯反演形式**：如何把`gcd(i,j)`的乘积转化为`mu`函数的求和？  
2. **预处理辅助函数**：如何高效预处理`f(T) = product_{d|T} d^mu(T/d)`？  
3. **处理多个变量的整除分块**：比如type2中同时涉及A、B、C三个变量的分块，如何嵌套处理？  
4. **type2的复杂拆分**：如何将`gcd(i,j,k)`的贡献拆分为φ函数的乘积？

### 3.2 解题策略
1. **乘积转反演**：利用`gcd(i,j)=d`等价于`i=dx, j=dy, gcd(x,y)=1`，再用莫比乌斯函数替换`gcd(x,y)=1`。  
2. **预处理辅助函数**：用埃氏筛枚举每个d，将d的贡献乘到其倍数T上（根据mu(T/d)的正负）。  
3. **整除分块**：对于多个变量，取最小的分块边界（如`r = min(A/(A/l), B/(B/l), C/(C/l))`），批量处理相同分块的贡献。  
4. **type2拆分**：利用`gcd(i,j,k) = gcd(gcd(i,j),k)`，先处理`gcd(i,j)`的贡献，再用φ函数处理`gcd(k, d)`的求和。


## 4. C++核心代码实现赏析

### 4.1 本题通用核心C++实现参考
* **说明**：综合优质题解的核心逻辑，实现type0的计算（其他type可类似扩展）。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
using namespace std;

const int N = 1e5 + 5;
int mod, phi[N], mu[N], prime[N], cnt;
long long fac[N], f[N], inv[N];
bool vis[N];

long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

void init() {
    // 预处理mu、phi
    mu[1] = phi[1] = 1;
    for (int i = 2; i < N; ++i) {
        if (!vis[i]) {
            prime[++cnt] = i;
            mu[i] = -1;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= cnt && i * prime[j] < N; ++j) {
            vis[i * prime[j]] = true;
            if (i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            mu[i * prime[j]] = -mu[i];
            phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        }
    }
    // 预处理阶乘
    fac[0] = 1;
    for (int i = 1; i < N; ++i) fac[i] = fac[i - 1] * i % mod;
    // 预处理f(T) = product_{d|T} d^mu(T/d)
    for (int i = 1; i < N; ++i) f[i] = 1;
    for (int d = 1; d < N; ++d) {
        for (int T = d; T < N; T += d) {
            if (mu[T / d] == 1) f[T] = f[T] * d % mod;
            else if (mu[T / d] == -1) f[T] = f[T] * qpow(d, mod - 2) % mod;
        }
    }
    // 预处理f的前缀积
    for (int i = 1; i < N; ++i) f[i] = f[i] * f[i - 1] % mod;
    // 预处理逆元
    inv[1] = 1;
    for (int i = 2; i < N; ++i) inv[i] = inv[mod % i] * (mod - mod / i) % mod;
}

long long calc_g(int A, int B, int C) {
    long long res = 1;
    for (int l = 1, r; l <= min(A, B); l = r + 1) {
        r = min(A / (A / l), B / (B / l));
        long long term = qpow(f[r] * qpow(f[l - 1], mod - 2) % mod, 1LL * (A / l) * (B / l) % (mod - 1));
        res = res * qpow(term, C) % mod;
    }
    return res;
}

long long solve_type0(int A, int B, int C) {
    long long num = qpow(fac[A], 1LL * B * C % (mod - 1)) * qpow(fac[B], 1LL * A * C % (mod - 1)) % mod;
    long long den = calc_g(A, B, C) * calc_g(A, C, B) % mod;
    return num * qpow(den, mod - 2) % mod;
}

int main() {
    int T;
    cin >> T >> mod;
    init();
    while (T--) {
        int A, B, C;
        cin >> A >> B >> C;
        cout << solve_type0(A, B, C) << endl;
        // 其他type类似扩展
    }
    return 0;
}
```

### 4.2 代码解读概要
- **预处理部分**：`init()`函数预处理`mu`、`phi`、阶乘、辅助函数`f(T)`及其前缀积，为后续计算做准备。
- **分块计算**：`calc_g()`函数用整除分块计算`gcd(i,j)`的乘积贡献，通过`f`的前缀积快速获取分块内的乘积。
- **type0计算**：`solve_type0()`计算分子（阶乘的幂）和分母（gcd乘积的幂），再用逆元求最终结果。


## 5. 算法可视化：像素动画演示

### 5.1 动画设计思路
**主题**：像素风“莫比乌斯反演分块计算器”  
**风格**：8位红白机风格，用像素方块表示`d`、`T`、`mu`值，分块过程用滑动动画展示。

### 5.2 动画步骤
1. **初始化**：屏幕显示`A=5`、`B=5`、`C=5`的参数，下方是`d`的枚举进度条，右侧是`f(T)`的预处理结果。
2. **枚举d**：进度条滑动到`d=2`，屏幕上用绿色方块标记`d=2`的倍数`T=2,4,6,...`，并显示`mu(T/d)`的正负（红色为负，蓝色为正）。
3. **分块计算**：当`d=2`时，分块边界`r=4`，用黄色方块标记分块内的`T=2,3,4`，计算`f[r] * inv(f[l-1])`的贡献，屏幕显示“分块贡献：x”。
4. **结果展示**：计算完成后，屏幕显示最终结果，伴随“叮”的胜利音效，并用像素文字提示“计算完成！”。

### 5.3 交互设计
- **单步执行**：点击“下一步”按钮，逐次展示`d`的枚举和分块过程。
- **自动播放**：点击“自动”按钮，动画按1倍速播放，分块时的音效增强记忆。
- **重置**：点击“重置”按钮，回到初始状态，重新开始演示。


## 6. 拓展练习与相似问题

### 6.1 相似问题
1. **P3455 [POI2007]ZAP-Queries**：基础的莫比乌斯反演题，练习将`gcd(i,j)=k`转化为`mu`求和。
2. **P1829 [国家集训队]Crash的数字表格**：类似本题type1，练习处理`gcd(i,j)`的高次幂。
3. **P3704 [SDOI2017]数字表格**：本题的“简化版”，练习辅助函数`f(T)`的预处理和分块计算。

### 6.2 进阶练习
- **P5221 Product**：处理多个变量的莫比乌斯反演，练习嵌套分块。
- **P6055 [RC-02] GCD**：结合容斥原理的莫比乌斯反演，提升综合应用能力。


## 7. 学习心得与经验分享

### 7.1 参考经验
- **来自CYJian**：“莫比乌斯反演的关键是‘拆gcd’，把问题转化为`mu`的求和，再通过分块批量处理。”  
- **来自灵乌路空**：“type2的复杂式子不要怕，拆成`gcd(i,j)`和`gcd(k,d)`两部分，分别处理后再合并。”

### 7.2 点评
这些经验强调了**“拆分”和“预处理”**的重要性。莫比乌斯反演的难点在于“如何拆”，而预处理辅助函数则是“如何高效算”。通过拆分复杂问题，将其转化为可复用的模块，能大幅降低代码难度。


## 8. 总结

本题是莫比乌斯反演的综合应用，覆盖了从基础到复杂的各种情况。通过理解“拆gcd→转mu→预处理→分块”的套路，能解决大多数数论中的gcd乘积问题。记住：**莫比乌斯反演不是“魔法”，而是将难以直接计算的问题转化为可批量处理的形式**。多练习相似问题，就能掌握其核心逻辑！

下次我们将探索更复杂的数论问题，比如杜教筛和欧拉函数的高级应用，敬请期待！💪

---
处理用时：95.81秒
# 题目信息

# [WC2014] 紫荆花之恋

## 题目描述

强强和萌萌是一对好朋友。有一天他们在外面闲逛，突然看到前方有一棵紫荆树。这已经是紫荆花飞舞的季节了，无数的花瓣以肉眼可见的速度从紫荆树上长了出来。

仔细看看的话，这个大树实际上是一个带权树。每个时刻它会长出一个新的叶子节点，每个节点上有一个可爱的小精灵，新长出的节点上也会同时出现一个新的小精灵。小精灵是很萌但是也很脆弱的生物，每个小精灵 $i$ 都有一个感受能力值 $r_i$，小精灵 $i,j$ 成为朋友当且仅当在树上 $i$ 和 $j$ 的距离 $dist(i,j) \leq r_i+r_j$，其中 $dist(i,j)$ 表示在这个树上从 $i$ 到 $j$ 的唯一路径上所有边的边权和。

强强和萌萌很好奇每次新长出一个叶子节点之后，这个树上总共有几对朋友。


我们假定这个树一开始为空，节点按照加入的顺序从 1 开始编号。由于强强非常好奇，你必须在他每次出现新结点后马上给出总共的朋友对数，不能拖延哦。

## 说明/提示

所有数据均满足 $1 \leq c_i \leq 10^4$，$a_i \leq 2\times 10^9$，$r_i \leq 10^9$。

| 测试点编号       | 约定                                                         |
| :----------------: | :------------------------------------------------------------: |
| $1,2$            | $n \leq 100$                                                 |
| $3,4$            | $n \leq 1000$                                                |
| $5,6,7,8$        | $n \leq 10^5$，节点 1 最多有两个子节点，其他节点最多有一个子节点 |
| $9,10$           | $n \leq 10^5$，$r_i \leq 10$                                 |
| $11,12$          | $n \leq 10^5$，树是随机生成的                                |
| $13,14,15$       | $n \leq 7\times 10^4$                                        |
| $16,17,18,19,20$ | $n \leq 10^5$                                                |

## 样例 #1

### 输入

```
0
5
0 0 6
1 2 4
0 9 4
0 5 5
0 2 4
```

### 输出

```
0
1
2
4
7
```

# AI分析结果


### 题目分析
本题是动态点分治的经典问题，需要支持在树上动态插入叶子节点，并实时统计满足条件（两点间距离不超过点权之和）的点对数量。题解主要采用点分树结合替罪羊树式重构和平衡树维护信息的方法。

#### 核心算法：动态点分治 + 平衡树 + 替罪羊树重构
1. **点分树结构**：
   - 每个点分树节点维护两棵平衡树：
     - `rt1[u]`：存储管辖区域内所有点 `x` 的 `dis(u,x)-r_x`（用于整体贡献）
     - `rt2[u]`：存储子节点 `v` 管辖区域中 `dis(fa[u],x)-r_x`（用于容斥）
2. **插入新节点**：
   - 连接新节点 `v` 到父节点 `f`
   - 计算 `v` 到点分树祖先的距离
   - 沿点分树向上遍历祖先 `u`：
     - 在 `rt1[u]` 中查询满足 `dis(u,v)-r_v <= r_x - dis(u,x)` 的 `x` 的数量（即 `rt1[u]` 中 `<= r_v - dis(u,v)` 的元素个数）
     - 减去 `rt2[v]` 中同样条件的数量（容斥）
     - 将 `dis(u,v)-r_v` 插入 `rt1[u]` 和 `rt2[v]`
   - 更新祖先的子树大小并检查重构条件
3. **重构机制**：
   - 当某点 `u` 的最大子树大小超过 `α * size[u]`（`α≈0.8`）时，重构以 `u` 为根的子树：
     - 清空子树内所有平衡树
     - 重新选择重心建立点分树
     - 重构平衡树信息
4. **距离计算**：
   - 使用倍增LCA或动态存储到点分树祖先的距离
   - 新节点继承父节点的距离信息并更新

#### 难点对比
| 难点 | 解决方案 |
|------|----------|
| 动态树结构 | 点分树 + 替罪羊树式重构 |
| 距离计算 | 倍增LCA / 动态维护到祖先距离 |
| 平衡树性能 | 替罪羊树/Treap等高速平衡树 |
| 空间优化 | 平衡树节点内存池回收 |

#### 精炼结论
- **时间复杂度**：均摊 $O(n \log^2 n)$（平衡树操作 $O(\log n)$，点分树高度 $O(\log n)$）
- **空间复杂度**：$O(n \log n)$（每个点在每层点分树出现一次）
- **关键优化**：
  - 重构阈值 $\alpha=0.8$ 平衡重构开销
  - 两棵平衡树设计实现高效容斥
  - 内存池回收平衡树节点

#### 算法可视化（像素风格设计）
```plaintext
[动态树生长过程]
1. 插入节点动画：
   - 新节点闪烁出现并连接到父节点
   - 红色箭头沿点分树向上遍历祖先

2. 平衡树操作：
   - 左侧：祖先u的平衡树rt1，显示插入值 d-r
   - 右侧：容斥平衡树rt2，显示查询范围
   - 高亮显示满足条件的节点

3. 重构过程：
   - 不平衡节点闪烁红色警告
   - 子树节点标记为待重构（黄色）
   - 显示新选择的重心（金色）

4. 控制面板：
   [单步执行] [播放/暂停] [速度调节条]
   [当前答案：7] [重构次数：2]
```

### 精选优质题解参考

#### 题解一：shadowice1984（核心代码赏析）
```cpp
// 核心片段：点分树插入与重构
void ins(int x,int f,int c) {
    add(f,x,c); // 原树连接
    // 初始化点分树结构
    fa[x]=f, dep[x]=dep[f]+1;
    sz[x]=1; 

    // 遍历点分树祖先
    for(int u=x; u; u=fa[u]) {
        d = dist(u,x); // 计算距离
        // 查询贡献
        ans += query(rt1[u], r[x]-d);
        if(fa[u]) ans -= query(rt2[u], r[x]-d);
        
        // 插入新值
        insert(rt1[u], d-r[x]);
        if(fa[u]) insert(rt2[u], d-r[x]);
        
        // 更新大小并检查重构
        sz[u]++;
        if(sz[u]*alpha < max_son_size) 
            rebuild(u);
    }
}

// 重构函数
void rebuild(int u) {
    vector<int> nodes = extract_subtree(u);
    // 清空平衡树
    for(auto v:nodes) {
        clear(rt1[v]); clear(rt2[v]);
    }
    // 重建点分树
    int new_rt = build_centroid(nodes);
    // 重新连接
    link_to_parent(new_rt, fa[u]);
}
```

**亮点**：
1. 完整实现点分树+替罪羊树重构框架
2. 内存池管理平衡树节点
3. 严格处理容斥逻辑
4. 封装平衡树操作提高可读性

#### 题解二：panyf（根号重构平衡树）
```cpp
// 根号重构平衡树设计
struct DS {
    vector<int> a, b; // a为有序数组，b为缓冲区
    
    void insert(int x) {
        b.insert(lower_bound(b.begin(),b.end(),x),x);
        if(b.size() > SQRT_N) { // 超过阈值
            vector<int> c(a.size()+b.size());
            merge(a.begin(),a.end(),b.begin(),b.end(),c.begin());
            a = c; b.clear();
        }
    }
    
    int query(int x) {
        return (upper_bound(a.begin(),a.end(),x)-a.begin())
             + (upper_bound(b.begin(),b.end(),x)-b.begin());
    }
};
```

**亮点**：
1. 免平衡树设计降低常数
2. 根号重构简化实现
3. 适合卡常数场景

### 核心难点辨析与解题策略

#### 难点1：动态树结构维护
- **问题**：传统点分树静态构建，无法处理动态插入
- **解决**：替罪羊树重构机制
  - 插入时检查 $size[son] > \alpha \times size[fa]$
  - 重构整个子树并重建点分树
- **学习笔记**：重构是维护动态树结构的通用思路

#### 难点2：高效贡献计算
- **问题**：需要快速计算满足 $dist(u,x) \leq r_u + r_x$ 的点对
- **解决**：
  $$dist(u,x) \leq r_u + r_x \iff dis(u,x)-r_x \leq r_u - dis(u,u)$$
  转化为平衡树上的排名查询
- **学习笔记**：距离不等式转化为值域查询是点分治核心技巧

#### 难点3：距离计算优化
- **问题**：动态插入时无法预处理全图距离
- **解决**：
  - 方案1：倍增LCA（$O(\log n)$/次）
  - 方案2：存储点到点分树祖先的距离
    ```cpp
    for(int k=0;k<dep[u];k++)
        dis_v[k] = dis_fa[k] + edge_cost;
    ```
- **学习笔记**：空间换时间策略的典型应用

### 算法可视化方案（像素风格）

#### 设计概念
```plaintext
[复古游戏界面]
1. 主场景：
   - 左侧：动态生长的树（8-bit风格节点）
   - 右侧：点分树结构（分层显示）
   - 下方：平衡树可视化（柱状图表示键值分布）

2. 动画序列：
   [插入节点]
   - 新节点闪烁（黄色）
   - 红色路径显示原树连接
   - 蓝色路径显示点分树遍历

   [平衡树操作]
   - 高亮显示被查询区间 [r-dis, +∞)
   - 绿色标记满足条件的节点

   [重构过程]
   - 不平衡节点变红震动
   - 子树节点集体闪烁
   - 新重心金色光芒

3. 控制台：
   - 8-bit风格按钮：单步/播放/暂停
   - 速度滑块：像素风格刻度
   - 数据面板：当前答案/重构次数
```

#### 技术实现
```javascript
// 伪代码实现核心动画
class Visualizer {
    constructor() {
        this.scene = new PixelScene(800, 600);
        this.treeView = new TreeWidget(0, 0, 400, 600);
        this.bstView = new BSTWidget(400, 0, 400, 300);
        this.controlPanel = new ControlPanel(400, 300, 400, 300);
    }
    
    onInsertNode(v, f) {
        this.scene.flashNode(v, 'yellow'); 
        this.scene.drawLine(v, f, 'red');
        
        // 点分树遍历动画
        let u = v;
        while(u) {
            this.scene.highlightNode(u, 'blue');
            const d = this.calcDistance(u, v);
            this.bstView.queryRange(u.rt1, r-d, Infinity);
            u = u.parent;
        }
    }
    
    onRebuild(subtree) {
        this.scene.flashNodes(subtree, 'red');
        const newRoot = findCentroid(subtree);
        this.scene.zoomTo(newRoot, () => {
            this.scene.glow(newRoot, 'gold');
        });
    }
}
```

### 拓展练习
1. **相似问题**：
   - 动态点分治：BZOJ3730（震波）
   - 带修改树分治：Luogu P3241（开店）
   - 动态树直径：CF1192B

2. **洛谷推荐**：
   | 题目ID | 标题 | 推荐理由 |
   |--------|------|----------|
   | P2056 | [ZJOI2007]捉迷藏 | 动态点分治维护最长链 |
   | P3345 | [ZJOI2015]幻想乡战略 | 动态点分治求带权重心 |
   | P4216 | [SCOI2015]情报传递 | 树链剖分+时间维度处理 |

> "理解动态点分治的关键在于把握点分树的层次结构和重构时机，这如同在动态的世界中寻找平衡的支点。" —— Kay

---
处理用时：193.77秒
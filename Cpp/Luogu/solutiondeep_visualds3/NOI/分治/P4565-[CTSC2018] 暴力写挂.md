# 题目信息

# [CTSC2018] 暴力写挂

## 题目描述

temporaryDO 是一个很菜的 OIer。在 4 月，他在省队选拔赛的考场上见到了《林克卡特树》一题，其中 $k = 0$ 的部分分是求树 $T$ 上的最长链。可怜的 temporaryDO 并不会做这道题，他在考场上抓猫耳挠猫腮都想不出一点思路。

这时，善良的板板出现在了空中，他的身上发出璀璨却柔和的光芒，荡漾在考场上。“题目并不难。” 板板说。那充满磁性的声音，让 temporaryDO 全身充满了力量。

他决定：写一个枚举点对求 LCA 算距离的 $k = 0$ 的 $O(n^2 \log n)$ 的部分分程序！于是， temporaryDO 选择以 $1$ 为根，建立了求 LCA 的树链剖分结构，然后写了二重 for 循环枚举点对。

然而，菜菜的 temporaryDO 不小心开小了数组，于是数组越界到了一片神秘的内存区域。但恰好的是，那片内存区域存储的区域恰好是另一棵树 $T'$ 。这样一来，程序并没有 RE ，但他求 $x$ 和 $y$ 的距离的时候，计算的是 

$$ \mathrm{depth}(x) + \mathrm{depth}(y) -  ({\mathrm{depth}(\mathrm{LCA}(x,y))}+{\mathrm{depth'}(\mathrm{LCA'}(x,y))})$$



最后程序会输出每一对点对 $i, j$（$i \le j$） 的如上定义的“距离” 的最大值。
temporaryDO 的程序在评测时光荣地爆零了。但他并不服气，他决定花好几天把自己的程序跑出来。请你根据 $T$ 和 $T'$ 帮帮可怜的 temporaryDO 求出他程序的输出。

## 说明/提示

### 样例解释 1
点对 $(3, 4)$ 的距离计算为 $3 + 0 - (0 + (-2)) = 5$ 。

### 数据范围
对于所有数据， $1\le n \le 366666$，$|v| \le 2017011328$ 。 详细数据范围见下表，表格中的“无” 表示无特殊限制。

测试点编号|$n \le$|$v$|$T$ 是一条链|$T'$ 是一条链
-|-|-|-|-
$1$|$36$|$=1$|否|否
$2$|$366$|$=1$|否|否
$3$|$1388$|$>0$|否|否
$4$|$1999$|$>0$|否|否
$5$|$2666$|$>0$|否|否
$6$|$5666$|无|否|否
$7$|$8666$|无|否|否
$8$|$11111$|无|否|否
$9$|$12345$|无|否|否
$10$|$366666$|$>0$|是|是
$11$|$366666$|无|是|是
$12\sim 13$|$366666$|$>0$|是|否
$14$|$366666$|无|是|否
$15\sim 16$|$366666$|$>0$|否|是
$17$|$366666$|无|否|是
$18\sim 20$|$366666$|无|否|否

$\mathrm{depth}(p)$ 和 $\mathrm{depth'}(p)$ 分别表示树 $T$，$T'$ 中点 $1$ 到点 $p$ 的距离，这里规定，距离指的是经过的边的边权总和，其中 $\mathrm{depth}(1) = 0$。

$\mathrm{LCA}(x, y)$ 和 $\mathrm{LCA'}(x, y)$ 分别表示树 $T$，$T'$ 中点 $x$ 与点 $y$ 的最近公共祖先，即在从 $x$ 到 $y$ 的最短路径上的距离根**经过边数最少**的点。

## 样例 #1

### 输入

```
6
1 2 2
1 3 0
2 4 1
2 5 -7
3 6 0
1 2 -1
2 3 -1
2 5 3
2 6 -2
3 4 8```

### 输出

```
5
```

# AI分析结果


### Kay的C++算法解析：[CTSC2018]暴力写挂 深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`边分治`与`虚树`的高效协同  
🗣️ **初步分析**：
> 题目要求最大化点对距离组合：$\text{depth}(x)+\text{depth}(y)-\text{depth}(\text{LCA}(x,y))-\text{depth}'(\text{LCA}'(x,y))$。通过数学变换可转化为：  
> $$\frac{1}{2} \left( \underbrace{\text{depth}(x)+\text{depth}(y)+\text{dis}(x,y)}_{\text{边分治处理}} - \underbrace{2\cdot\text{depth}'(\text{LCA}'(x,y))}_{\text{虚树处理}} \right)$$
> **边分治核心思想**：将树递归分割为两个连通块（类比切蛋糕），在分治边处计算跨块点对。**虚树作用**：在第二棵树中提取关键点建立轻量化结构，高效计算LCA深度贡献。  
> **可视化设计**：
> - 像素动画展示三度化重构（防退化）→ 分治边闪烁（红/蓝块）→ 虚树节点动态生成
> - 高亮变量：连通块点权$f(x)/g(y)$、虚树DP合并时的最大值更新
> - 复古音效：分治边切割声（8-bit音效）、虚树节点合并声（清脆提示音）

#### 2. 精选优质题解参考
**题解一（asuldb）**  
* **亮点**：  
  - 三度化重构优雅（添加虚点防菊花图退化）  
  - 虚树DP简洁高效：双数组$f[u][0/1]$维护子树的A/B类点最大权值  
  - 边界处理严谨（特判单点贡献）  
* **代码片段**：  
  ```cpp
  void dp(int u) {
    f[u][0]=f[u][1]=-INF;
    if(col[u]==1) f[u][0]=val[u]; 
    for(int v:vt[u]) {
      dp(v);
      ans = max(ans, f[u][0]+f[v][1]-2*dep2[u]); // 关键合并
      f[u][0] = max(f[u][0], f[v][0]); // 更新最大值
    }
  }
  ```

**题解二（ywy_c_asm）**  
* **亮点**：  
  - 边分树合并实现O(n log n)复杂度  
  - 二叉树链结构模拟分治历史（左/右儿子=历史连通块归属）  
  - 空间复用技巧（动态开点）  
* **创新点**：  
  ```cpp
  int merge(int a,int b,int d) {
    ans = max(ans, lc[a].mx + rc[b].mx - 2*d); // 跨块点对计算
    lc[a] = merge(lc[a], lc[b], d); // 递归合并左子树
    // ... 右子树同理
  }
  ```

**题解三（seajupiter）**  
* **亮点**：  
  - 点分治替代边分治避免重构  
  - 虚树线性建树（基数排序预处理DFS序）  
  - 路径去重技巧（容斥处理同子路径）  

#### 3. 核心难点辨析与解题策略
1. **三度化防退化**  
   - **问题**：原树可能退化为菊花图，导致边分治效率骤降  
   - **解决**：添加虚点构建二叉树（如图：原节点分裂为链式结构）  
   - **学习笔记**：虚点边权为0不影响距离计算  

2. **跨树贡献计算**  
   - **关键公式**：$f(x)+g(y)-2\cdot \text{depth}'(z)$（$z=\text{LCA}'(x,y)$）  
   - **DP优化**：  
     - 自底向上合并时，用$f[u][0]+f[v][1]$更新答案（异色点对）  
     - 维护子树最大单色值避免O(n²)配对  

3. **虚树空间控制**  
   - **策略**：按分治层分批建树，节点复用  
   - **复杂度**：每层O(k)（k=连通块点数），总和O(n log n)  

#### 4. C++核心代码实现赏析
**通用边分治框架**  
```cpp
void edge_div(int u,int SZ) {
  find_edge(u, 0, SZ); // 找重心边
  int u1=e[u].to, u2=e[e[u].rev].to; 
  cut_edge(u); // 切断当前边
  build_vtree(u1, u2); // 建虚树
  dp(rt); // 虚树DP
  edge_div(u1, sz[u1]); // 递归分治
}
```

**虚树DP关键片段**  
```cpp
void vt_dp(int u) {
  for(int v:vt[u]) {
    vt_dp(v);
    ans = max(ans, max(f[u][0]+g[v][1], g[u][1]+f[v][0]) - 2*dep2[u]);
    f[u][0] = max(f[u][0], f[v][0]); // 合并A类点
    g[u][1] = max(g[u][1], g[v][1]); // 合并B类点
  }
}
```

#### 5. 算法可视化：像素动画演示
**动画设计**：  
- **场景1**：树T的三度化重构  
  - 原树节点展开为二叉链（虚点闪烁黄色）  
- **场景2**：边分治过程  
  - 分治边高亮闪烁（红色），连通块染红/蓝色  
  - 音效：切割声（8-bit短促音）  
- **场景3**：虚树构建  
  - 关键点从T'中升起（绿色像素块），LCA节点自动生成（粒子特效）  
- **场景4**：DP合并  
  - 子树最大值碰撞时迸发星火（星形粒子），数值实时显示  

**交互控制**：  
- 单步执行：空格键步进分治过程  
- 速度滑块：调整自动播放速度  
- 模式切换：对比边分治与点分治效率差异  

#### 6. 拓展练习
1. **同类问题迁移**  
   - [WC2018]通道（三棵树扩展）  
   - [HNOI2015]开店（点分树应用）  
2. **洛谷题库**  
   - P4220：边分治+虚树综合训练  
   - P3241：点分治与树上动态规划结合  

#### 7. 学习启示录
> **调试警语（asuldb）**：  
> *“虚树DP务必清空数组！初始化为-INF比判空更安全”*  
> **Kay总结**：多树问题需建立**维度分离思维**——第一棵树分解问题，第二棵树合并答案，通过虚树实现信息压缩是通用优化范式。

> **算法灵魂**：  
> 分治的本质是降维，虚树的本质是聚焦  
> 在树的重重嵌套中捕捉光年外的星火，  
> 这便是算法宇宙的浪漫诗篇。

---
处理用时：435.98秒
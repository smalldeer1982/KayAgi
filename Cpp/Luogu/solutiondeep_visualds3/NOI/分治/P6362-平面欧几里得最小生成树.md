# 题目信息

# 平面欧几里得最小生成树

## 题目背景

2025/06/13 @[ケロシ](https://www.luogu.com.cn/user/511639) 加入十组 hack 数据，位于 Subtask 1。

## 题目描述

平面上有 $n$ 个点，第 $i$ 个点坐标为 $(x_i, y_i)$。连接 $i, j$ 两点的边权为 $\sqrt{(x_i - x_j) ^ 2 + (y_i - y_j) ^ 2}$。求最小生成树的边权之和。

## 说明/提示

#### 样例解释 1

该样例中，最小生成树如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/p0dtxt2l.png)

边权之和为 $2 \sqrt{5} + 2 \approx 6.47213595500$。

---

#### 数据规模与约定

- 对于 $50\%$ 的数据，$n \le 5000$。
- 对于 $100\%$ 的数据，$3 \le n \le 10 ^ 5$，$\lvert x_i \rvert, \lvert y_i \rvert \le 10 ^ 5$。

## 样例 #1

### 输入

```
4
0 0
1 2
-1 2
0 4```

### 输出

```
6.472136```

# AI分析结果


### 💡 Kay的C++算法解析：平面欧几里得最小生成树 深入学习指南 💡

<introduction>
今天我们来分析“平面欧几里得最小生成树”这道题目。本指南将帮助你理解如何高效解决平面点集的最小生成树问题，掌握 Delaunay 三角剖分等核心算法，并通过像素动画直观理解算法过程。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`计算几何`与`最小生成树`（Delaunay 三角剖分 + Kruskal/Boruvka）

🗣️ **初步分析**：
> 本题要求计算平面点集的最小生成树（MST），若直接使用 Kruskal 或 Prim 算法会因 $O(n^2)$ 边数超时。**核心突破口**在于：欧式 MST 的边集是 Delaunay 三角剖分的子集（理论保证）。这让我们只需处理 $O(n)$ 量级的边：
> - **Delaunay 三角剖分**：通过空圆性（三角形外接圆内无其他点）保证 MST 边被保留
> - **主要解法**：
>   1. **Guibas-Stolfi 分治算法**：$O(n \log n)$ 构建三角剖分
>   2. **Boruvka + KD 树**：多轮迭代找最近邻点（$O(n \log^2 n)$）
>   3. **人类智慧法**：随机扰动后局部搜索（非严格但高效）
> - **可视化设计**：像素网格中动态展示三角剖分（点=像素块，边=彩色线），高亮当前处理的三角形外接圆和 MST 新增边。加入 8-bit 音效（点插入="滴"，边翻转="咔嚓"），自动演示模式模拟"贪吃蛇"式扩张。

---

## 2. 精选优质题解参考

<eval_intro>
综合思路清晰度、代码质量、算法效率，精选以下题解：

**题解一（作者：Tweetuzki）**
* **点评**：
  - **思路**：严谨推导 Delaunay 性质，证明 MST 边是其子集，并用三维映射法解决外接圆判断的精度问题
  - **代码**：Guibas-Stolfi 分治实现工整，变量名规范（如 `inCircumcircle` 函数）
  - **算法**：$O(n \log n)$ 理论最优，三维几何方法避免浮点误差
  - **实践**：可直接用于竞赛，边界处理完整（如凸包点初始化）

**题解二（作者：wishapig）**
* **点评**：
  - **思路**：Boruvka 分轮合并 + KD 树加速最近邻搜索，复杂度 $O(n \log^2 n)$
  - **代码**：模块化设计（`Graph`/`Tree` 结构体），随机旋转防卡
  - **亮点**：巧妙利用 Boruvka 轮数少的特性，每轮仅需 $O(n \log n)$ 操作

**题解三（作者：zzzz1234567）**
* **点评**：
  - **思路**：人类智慧法（坐标扰动 + 局部搜索），牺牲理论保证换实践效率
  - **代码**：简洁高效，仅 50 行实现 Prim 算法 + 邻域搜索
  - **价值**：在随机数据下 $O(1000n)$ 边数，适合时限紧迫场景

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三个关键难点：

1. **难点：完全图边数爆炸（$O(n^2)$）**
   * **分析**：利用 Delaunay 三角剖分的空圆性，将边数缩减至 $O(n)$。数学证明：欧式 MST 边必在 Delaunay 边中。
   * 💡 **学习笔记**：Delaunay 三角剖分是平面点集的“最规则”剖分，完美适配 MST。

2. **难点：Delaunay 剖分的高效实现**
   * **分析**：
     - Guibas-Stolfi 分治算法需处理合并时的“基边”查找（`getInitialBaseEdge`）
     - 用三维映射（点→抛物面）判断点在外接圆内：$\text{点}(x,y) \rightarrow (x,y,x^2+y^2)$，通过平面法向量判断上下位置
   * 💡 **学习笔记**：三维方法比直接计算外接圆半径精度更高！

3. **难点：精度与随机性处理**
   * **分析**：浮点误差可能导致剖分失败。解决方案：
     - 随机扰动点坐标（`shake()` 函数）
     - 避免直接比较浮点数相等（用 $\epsilon$ 容差）
   * 💡 **学习笔记**：计算几何中，随机扰动是解决退化情况的利器。

### ✨ 解题技巧总结
<summary_best_practices>
- **技巧1：问题转化**：将 MST 问题转化为 Delaunay 边集上的稀疏图问题
- **技巧2：分治优化**：Guibas-Stolfi 分治时，合并阶段只需处理相邻点
- **技巧3：调试策略**：可视化中间结果（如输出三角网结构），对拍验证
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
**本题通用核心实现**（综合自题解一）：
```cpp
#include <vector>
#include <cmath>
using namespace std;

struct Point { double x, y; };
vector<Point> pt;
vector<pair<int, int>> delaunayEdges; // Delaunay 边集

// 三维映射法判断点是否在圆内 (核心精度优化)
bool inCircle(Point a, Point b, Point c, Point p) {
    double A = a.x - p.x, B = a.y - p.y;
    double C = b.x - p.x, D = b.y - p.y;
    double E = c.x - p.x, F = c.y - p.y;
    return A*(D*E - C*F) - B*(C*E - D*F) + (C*C + D*D)*(E*F - D*E) < 0;
}

// Guibas-Stolfi 分治主函数
void delaunay(int l, int r) {
    if (r - l <= 2) { /* 直接生成边 */ return; }
    int mid = (l + r) / 2;
    delaunay(l, mid);
    delaunay(mid + 1, r);
    // 合并左右剖分（需实现基边查找、新边添加）
    // ... 
}
```
* **说明**：此代码框架展示核心流程，省略合并实现细节（详见题解）
* **解读概要**：分治递归构建三角剖分，用三维方法避免浮点误差
</code_intro_overall>

<code_intro_selected>
**题解一核心：Guibas-Stolfi 合并逻辑**
```cpp
void merge(int l, int r) {
    auto base = findBaseEdge(l, r); // 找连接左右部分的基边
    while (true) {
        int leftCandidate = -1, rightCandidate = -1;
        // 左侧：找与基边夹角最小的点（满足空圆性）
        for (int neighbor : leftPoints) {
            if (cross(base.vec(), neighbor.vec()) > 0 && 
                (leftCandidate == -1 || inCircle(base, leftCandidate, neighbor)))
                leftCandidate = neighbor;
        }
        // 类似处理右侧...
        if (!leftCandidate && !rightCandidate) break;
        // 添加新边并更新基边
    }
}
```
* **亮点**：动态维护基边，空圆性检查保证 Delaunay 性质
* **学习笔记**：合并时只需检查基边附近的候选点，降低复杂度

**题解二核心：Boruvka + KD 树**
```cpp
void boruvka() {
    while (components > 1) {
        // 从 KD 树删除当前连通块的点
        for (int u : component) kdtree.remove(u);
        // 为每个点找最近邻（不同连通块）
        for (int u : component) {
            auto [dist, v] = kdtree.nearest(u);
            updateMinEdge(componentId, u, v, dist);
        }
        // 添加最小边并合并连通块
    }
}
```
* **亮点**：KD 树高效支持动态删除/插入
* **学习笔记**：Boruvka 轮数 $\log n$，每轮 $O(n \log n)$
</code_intro_selected>

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
设计一个 **8-bit 风格动画** 演示 Delaunay 分治与 MST 构建：
</visualization_intro>

1. **场景设计**：
   - **像素网格**：坐标范围 $[-10^5, 10^5]$ 映射到 $256\times256$ 像素画布
   - **元素表示**：
     - 点：红色像素方块（★）
     - Delaunay 边：浅灰色直线
     - MST 边：闪烁的黄色直线
   - **控制面板**：步进/暂停/速度滑块（调速范围 1x-10x）

2. **关键动画帧**：
   ```plaintext
   Frame 1: 初始点集显示（随机散布红色方块）
   Frame 2: 分治过程（左右半区用蓝/绿色框标记）
   Frame 3: 合并阶段（基边高亮为紫色，新添加边显示为橙色）
   Frame 4: 三角剖分完成（所有 Delaunay 边显示为网格）
   Frame 5: Kruskal 执行（MST 边逐条转为黄色，播放“滴答”音效）
   ```

3. **交互与游戏化**：
   - **音效设计**：
     - 添加边：8-bit 短音（频率 500Hz）
     - 错误操作：低频嗡鸣（200Hz）
     - 完成 MST：胜利旋律（上升音阶）
   - **自动演示**：AI 像“贪吃蛇”一样逐步扩张三角网
   - **关卡挑战**：将算法分为“分治→合并→MST”三关，通关显示用时评分

4. **技术实现**：
   ```javascript
   // 伪代码：绘制外接圆检查
   function drawCircumcircle(a, b, c) {
     const center = calculateCircleCenter(a, b, c);
     ctx.drawCircle(center, radius, {color: '#5555FF'});
     if (mouseHover(center)) {
        playSound('hollow.wav'); // 悬停时播放空灵音效
     }
   }
   ```

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握 Delaunay 剖分后，可解决更多几何问题：
</similar_problems_intro>

1. **洛谷 P1429**（平面最近点对）  
   → 推荐理由：Delaunay 图中最近边必为最近点对

2. **洛谷 P7883**（平面点集三角剖分）  
   → 推荐理由：直接练习 Delaunay 剖分实现，数据规模适中

3. **洛谷 P3366**（最小生成树模板）  
   → 推荐理由：练习 Boruvka 算法在通用图上的应用

---

## 7. 学习心得与经验分享

<insights_intro>
作者调试经验摘录与点评：
</insights_intro>

> **Tweetuzki 的调试经验**：  
> *“最初用传统方法计算外接圆半径，在 $|x|>10^4$ 时遇到浮点溢出。改用三维映射法后精度问题消失。”*  
> **Kay 点评**：这印证了几何问题中，**坐标映射法**比解析几何更稳定。建议学习者掌握向量叉积等数值稳定的操作。

---

<conclusion>
本次分析展示了解决平面 MST 的三种思路：严谨的 Delaunay 剖分、高效的 Boruvka+KD 树、实用的人类智慧法。理解算法背后的几何性质（如空圆性）比记忆代码更重要。下次我们将探索 Voronoi 图的相关应用！
</conclusion>
```

---
处理用时：213.39秒
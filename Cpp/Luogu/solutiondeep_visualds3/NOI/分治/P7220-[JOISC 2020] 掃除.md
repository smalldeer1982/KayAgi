# 题目信息

# [JOISC 2020] 掃除

## 题目背景

JOISC2020 Day 1 T3

由于数据点较多，本题只评测其中的部分数据。

希望获得完整数据的可以到[这里](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day1/sweeping-data.zip)自行下载。

## 题目描述

由于 Bitaro AK 了 IOI，所以 IOI 主办方送了他一套房子，为一个边长为 $N$ 的等腰直角三角形。房间内一点用坐标 $(x,y)$ 表示，其中 $0\leq x+y\leq N$。直角顶点为原点，三角形两腰分别为 $x$ 轴与 $y$ 轴。

![](https://cdn.luogu.com.cn/upload/image_hosting/3m2wdn4u.png)

一天，Bitaro 发现自己已经 AK 了 1919810 届 IOI 闲的没事做准备打扫房间里的灰尘。这些灰尘一开始一共有 $M$ 堆，其中第 $i$ 堆位于 $(X_i,Y_i)$。同时，可能存在多堆灰尘位于同一个位置上的情况。

现在 Bitaro 准备用扫帚打扫房间。我们认为扫帚是放置在房间里的一条线段，并且将这条线段的长度称为扫帚的宽度。由于 Bitaro 很有条理，所以他只会用以下的两种方式打扫房间：

- Bitaro 将扫帚平行于 $y$ 轴放置，一端位于原点。然后他会垂直向右移动扫帚，直到不能移动为止。如果扫帚的宽度为 $l$，那么原来一堆满足 $x<N-l,y\leq l$ 的灰尘 $(x,y)$ 将会被移动到 $(N-l,y)$。（这个位置可能会存在多堆灰尘）我们称这个过程为过程 H。

- Bitaro 将扫帚平行于 $x$ 轴放置，一端位于原点。然后他会水平向上移动扫帚，直到不能移动为止。如果扫帚的宽度为 $l$，那么原来一堆满足 $x\leq l,y<N-l$ 的灰尘 $(x,y)$ 将会被移动到 $(x,N-l)$。（这个位置可能会存在多堆灰尘）我们称这个过程为过程 V。

在 Bitaro 的房间里，依次会发生 $Q$ 个事件。第 $i$ 个事件形如以下 $4$ 种：

- Bitaro 想要计算第 $P_i$ 堆灰尘的位置坐标；

- Bitaro 使用宽度为 $L_i$ 的扫帚，进行了过程 H；

- Bitaro 使用宽度为 $L_i$ 的扫帚，进行了过程 V；

- 有一堆新的灰尘出现在点 $(A_i,B_i)$ 处。如果在这个事件之前一共有 $c$ 堆灰尘，那么这堆灰尘就是房间中的第 $c+1$ 堆灰尘。

由于 Bitaro 已经 AK 了 IOI，啥都不想干，所以你需要写一个程序，给出房间的腰长，每一堆灰尘的位置坐标和每个事件的细节，求出要求的某堆灰尘的位置坐标。

## 说明/提示

### 样例 1 解释

一开始第一堆灰尘位于 $(1,1)$，第二堆灰尘位于 $(4,0)$。图一描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/8e305ll6.png)

在第一个事件中，添加了 $(2,3)$ 位置上的第三堆灰尘。图二描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/wili6lmg.png)

在第二个事件中，Bitaro 用宽度为 $3$ 的扫帚进行了过程 V。之后，第一堆灰尘移动到了 $(1,3)$，图三描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/x5x5nsvb.png)

在第三个事件中，Bitaro 计算了第一堆灰尘的坐标 $(1,3)$。

在第四个事件中，添加 $(1,2)$ 位置上的第四堆灰尘。图四描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/sxqf521x.png)

在第五个事件中，Bitaro 用宽度为 $3$ 的扫帚进行了过程 H，第一堆灰尘移到了 $(3,3)$，第三堆灰尘移到了 $(3,3)$，第四堆灰尘移到了 $(3,2)$。图五描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/0lt0inff.png)

在第六个事件中，Bitaro 用宽度为 $0$ 的扫帚进行了过程 H，第二堆灰尘移到了 $(6,0)$。图六描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/wnv1lqz7.png)

在第七个事件中，Bitaro 计算了第四堆灰尘的坐标 $(3,2)$。

在第八个事件中，Bitaro 用宽度为 $2$ 的扫帚进行了过程 V，然而什么都没有发生。图七描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/s4rebol9.png)

在第九个事件中，Bitaro 计算了第三堆灰尘的坐标 $(3,3)$。

在第十个事件中，Bitaro 计算了第二堆灰尘的坐标 $(6,0)$。

这组样例满足子任务 1 和子任务 5 的限制。

#### 样例 2~5 解释

第二组样例满足子任务 1,2,4,5 的限制。

第三组样例满足子任务 1,2,5 的限制。

第四组样例满足子任务 1,3,4,5 的限制。

第五组样例满足子任务 1,5 的限制。

#### 子任务

| 子任务编号 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| Subtask 1 | $m\leq 2\times 10^3,Q\leq 5\times 10^3$ | $1$ |
| Subtask 2 | $T\in\{1,2,4\}$ | $10$ |
| Subtask 3 | $T\in\{1,2,3\},X_i\leq X_{i+1},Y_i\geq Y_{i+1}(1\leq i\leq m-1)$ | $11$ |
| Subtask 4 | $T\in\{1,2,3\}$ | $53$ |
| Subtask 5 | 无 | $25$ | 

对于 $100\%$ 的数据，$1\leq n\leq 10^9,1\leq m\leq 5\times 10^5,1\leq Q\leq 10^6$。保证：

- $0\leq X_i,Y_i\leq N,X_i+Y_i\leq N(1\leq i\leq m)$；

- $1\leq P_i\leq M^\prime(1\leq i\leq Q)$，其中 $M^\prime$ 表示事件 $i$ 发生时灰尘的堆数；

- $0\leq L_i\leq n-1(1\leq i\leq Q)$；

- $0\leq A_i,B_i\leq n,A_i+B_i\leq n(1\leq i\leq Q)$；

- 至少存在一个 $T_i=1$ 的事件。


## 样例 #1

### 输入

```
6 2 10
1 1
4 0
4 2 3
3 3
1 1
4 1 2
2 3
2 0
1 4
3 2
1 3
1 2```

### 输出

```
1 3
3 2
3 3
6 0```

## 样例 #2

### 输入

```
9 4 8
2 3
3 1
1 6
4 3
2 6
1 3
2 2
1 4
2 3
1 2
2 4
1 1```

### 输出

```
3 6
4 3
7 1
6 3```

## 样例 #3

### 输入

```
8 1 8
1 5
4 4 1
2 6
1 2
2 3
4 2 2
2 5
1 1
1 3```

### 输出

```
4 1
3 5
3 2```

## 样例 #4

### 输入

```
7 4 9
1 5
2 2
4 2
5 0
2 6
2 3
1 2
3 6
1 4
3 1
1 1
2 2
1 3```

### 输出

```
4 2
5 1
1 6
5 2```

## 样例 #5

### 输入

```
20 5 25
10 6
0 4
2 1
1 0
2 3
2 18
3 9
4 1 5
4 0 2
3 10
4 3 3
3 3
2 9
4 9 1
3 12
1 4
3 19
1 3
1 9
2 1
1 7
1 6
4 3 3
1 10
1 1
1 5
2 0
1 2
2 2
1 7```

### 输出

```
2 17
2 17
9 8
0 17
1 17
3 3
10 10
2 17
2 17
0 17```

# AI分析结果


### 💡 Kay的C++算法解析：掃除 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`分治与数据结构应用`  
🗣️ **初步分析**：
> 解决「掃除」题目的核心在于运用**分治思想**结合**高效数据结构**，如同在迷宫中分层探索不同区域。分治将复杂操作序列拆解为独立区间处理（类似关卡分区），而平衡树/线段树则高效维护灰尘位置状态（如实时更新坐标）。  
- **核心难点**：H/V操作互相影响（如V操作后H操作范围受限）、动态插入灰尘的实时处理、10^9级坐标规模下的空间优化。
- **解决方案**：主流思路采用**时间分治**（线段树分治/CDQ分治）将操作序列分段，每个区间内用平衡树维护点集，实现O(Q log Q log n)复杂度。
- **可视化设计**：用像素网格模拟三角形房间，灰尘显示为彩色方块。H操作时扫帚（蓝色像素条）从左向右扫过，被影响灰尘（红色）水平移动至右边界；V操作时扫帚（绿色像素条）从下向上扫，灰尘垂直上移。关键变量（扫帚宽度L）实时显示，移动路径高亮。

#### 2. 精选优质题解参考
**题解一（jun头吉吉）**  
* **点评**：思路清晰度⭐️⭐️⭐️⭐️⭐️ 通过线段树分治将操作按时间区间分解，每个区间用FHQ Treap维护灰尘位置。代码规范性优秀（变量名`f[i]`、`pre[i]`含义明确），算法有效性突出（处理动态插入和坐标更新），实践价值高（可直接用于竞赛，边界处理严谨）。亮点：用`splitX`/`splitY`高效分离受操作影响的点集。

**题解二（周子衡）**  
* **点评**：创新性⭐️⭐️⭐️⭐️ 离线计算每个点首次被清扫的时间，转化为静态问题。代码逻辑严密（离散化处理大坐标），算法优化显著（避免动态维护，平衡树维护轮廓线）。亮点：作者心得强调"离线处理是简化动态问题的关键"，启发先分析操作依赖性。

**题解三（lcjqwq）**  
* **点评**：结构严谨度⭐️⭐️⭐️⭐️ 采用CDQ分治，左区间处理插入，右区间处理查询。代码模块化强（分离`PushDown`/`Merge`），空间效率高（O(n)）。亮点：用扫描线求首次清扫时间，类比"时空隧道追溯影响"。

#### 3. 核心难点辨析与解题策略
1. **操作互相影响**  
   * **分析**：H/V操作会改变灰尘坐标，后续操作范围随之变化。如题解一用分治隔离操作区间，题解二离线计算首次影响时间切断依赖链。  
   💡 **学习笔记**：分治是化解操作耦合性的利剑。

2. **动态插入处理**  
   * **分析**：新增灰尘可能位于历史操作影响范围内。题解三在CDQ分治中递归前向子区间插入点，确保时序正确性。  
   💡 **学习笔记**：动态问题静态化——通过时间分治冻结状态。

3. **大规模数据优化**  
   * **分析**：坐标达10^9级需离散化或动态开点。题解二用离散化压缩空间，题解一在分治区间内仅维护相关点。  
   💡 **学习笔记**：空间优化 = 问题分解 + 按需计算。

✨ **解题技巧总结**  
- **分而治之**：将Q次操作分治为log Q层，每层独立处理（如线段树分治）。  
- **数据结构选择**：平衡树（FHQ Treap）处理区间分裂/合并，线段树维护首次清扫时间。  
- **边界艺术**：`max(x, n-l)`本质是坐标下界约束，用`chmax`函数统一处理。  

#### 4. C++核心代码实现赏析
**通用核心实现（综合自题解一）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX = 2e6 + 100;

struct Node { int x, y, lc, rc, tagx, tagy; }; // 平衡树节点
struct Operation { int type, L, id; };        // 操作类型
vector<Operation> tree[MAX * 4];             // 分治线段树

void solve(int l, int r, int idx) {
    auto& ops = tree[idx];
    // 1. 初始化平衡树
    // 2. 处理当前区间操作：H/V操作用split分离点集并更新坐标
    // 3. 递归子区间：[l,mid] 和 [mid+1,r]
}
```
* **代码解读概要**：  
  ① 线段树分治结构隔离操作区间；② FHQ Treap维护灰尘坐标；③ H操作用`splitY`分离`y≤L`的点并更新`x=max(x,n-L)`；④ 递归时仅传递相关点集。

**题解一核心片段**  
```cpp
void SplitY(int root, int L, int& left, int& right) {
    if (!root) return;
    if (y[root] <= L) { 
        left = root; 
        SplitY(right[root], L, right[root], right); 
    } else { /*...*/ }
}
```
* **解读**：`SplitY`将平衡树按`y≤L`分割，左侧受H操作影响。`left`子树中所有点x坐标更新为`max(x,n-L)`，类比"渔网分离小鱼"。  
💡 **学习笔记**：平衡树分裂是高效范围操作的核心。

#### 5. 算法可视化：像素动画演示  
**主题**：8-bit像素扫除冒险  
**核心演示**：  
1. **场景**：三角形房间网格（棕色边框），灰尘为彩色像素点（红/黄/蓝），扫帚为长条像素块（H操作：蓝色横条，V操作：绿色竖条）。  
2. **操作动画**：  
   - H操作：蓝色横条从y轴向右扫，`y≤L`的灰尘水平右移至`x=n-L`处（移动轨迹高亮，伴随"滴"音效）。  
   - V操作：绿色竖条从x轴上升，`x≤L`的灰尘垂直上移至`y=n-L`处（"叮"音效）。  
3. **交互控制**：  
   - 单步执行：按空格逐步播放操作。  
   - 自动模式：AI自动演示（调速滑块控制速度），如"贪吃蛇AI"寻路。  
   - 状态面板：显示当前操作类型、扫帚宽度L、受影响灰尘数。  
4. **游戏化元素**：  
   - 每完成10次操作解锁新"关卡"，积分奖励（正确操作+10分）。  
   - 成功查询时灰尘闪烁金色，播放胜利音效；操作无效时短促警示音。  

#### 6. 拓展练习与相似问题思考  
**通用技巧迁移**：  
- 分治+数据结构适用于：动态点集维护（如矩形区域查询）、操作时序依赖性强的场景。  

**洛谷推荐**：  
1. **P1502 窗口的星星**（分治处理矩形覆盖）  
   🗣️ *推荐理由*：强化扫描线+线段树应用，理解"分治冻结状态"思想。  
2. **P2161 [SHOI2009]会场预约**（平衡树维护区间）  
   🗣️ *推荐理由*：FHQ Treap实战，类比灰尘坐标的区间分裂。  
3. **P3332 [ZJOI2013]K大数查询**（CDQ分治经典）  
   🗣️ *推荐理由*：深入掌握CDQ分治时空分解技巧。  

#### 7. 学习心得与经验分享  
> **jun头吉吉的经验**："从部分分入手（如无插入的子任务），逐步搭建解法框架。"  
> **Kay的总结**：调试时重点验证首次清扫时间的计算——用日志输出关键变量，模拟小规模数据流。  

---  
💪 掌握分治与数据结构的交响乐，你将在动态问题中所向披靡！下次我们继续探索算法宇宙的星辰大海！

---
处理用时：167.90秒
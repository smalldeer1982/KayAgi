# 题目信息

# [OOI 2023] 寻找假币

## 题目描述

**这是一个交互式问题。**

你面前有一批 $n$ 枚金币，其中有 $k$ 枚是假币。所有金币排成一行。第 $i$ 枚金币的理论重量为 $i$ 克。如果某枚金币是假币，它的重量为 $0$ 克。

禁止触碰金币，你唯一能进行的操作是选择某个 $1 \leq p \leq n$，称为称重操作，对前 $p$ 枚金币进行称重。你将得到这 $p$ 枚金币的真实总重量。

请你用尽量少的操作，找出哪 $k$ 枚金币是假币。你做的称重次数越少，得分越高，具体请见评分说明。

### 交互说明

每个测试包含 $t$ 局游戏，你需要在每局中找出哪些金币是假币。输入的第一行包含一个整数 $t$（$1 \leq t \leq 50$），表示游戏的局数。每局的交互格式如下。所有局结束后，你的程序应当终止。

每局开始时，给出两个整数 $n$ 和 $k$（$1 \leq n \leq 10^9$，$1 \leq k \leq \min(100, n)$）。此后你可以进行多次称重操作。

要进行一次称重操作，输出 `? p`（注意空格），表示你要称重前 $p$ 枚金币。你将获得一个整数 $a$。如果 $a = -1$，说明你已经超过了本局允许的最大称重次数，你的程序必须立即终止。每局最多允许 $3500$ 次称重。若 $a \geq 0$，则 $a$ 是金币 $1, 2, \ldots, p$ 的真实总重量。

当你确定了假币的位置后，输出 $!\ i_1\ i_2\ \ldots\ i_k$，其中 $1 \leq i_1, i_2, \ldots, i_k \leq n$ 且互不相同，表示你认为是假币的编号，顺序任意。此后你会收到一个整数 $a$。如果 $a = -1$，说明你的答案错误，你的程序必须立即终止。否则 $a = 1$，表示答案正确，你应继续进行下一局或终止（如果这是最后一局）。

注意，交互器是**自适应**的。并不保证每局假币的位置在游戏开始前就已确定。唯一保证的是，交互器给出的所有称重结果，在任何时刻都与某个假币集合相符。你的答案是正确的，如果它与所有你收到的称重结果一致，且不存在另一个假币集合也能与所有称重结果一致。

每次输出后请输出换行符，并刷新输出缓冲区。

如果你使用 Pascal 的 `writeln`，C++ 的 `cout << ... << endl`，Java 的 `System.out.println`，Python 的 `print`，C# 的 `Console.WriteLine`，则会自动刷新缓冲区，无需特殊处理。如果你使用其他输出方式，建议手动刷新。无论如何，每次输出都要换行。


## 说明/提示

### 样例解释

在第一局中，金币 $1$ 和 $3$ 是假币，因此实际重量为 $[0, 2, 0]$。只需一次称重即可得到总重量 $2$，据此可以唯一确定假币的位置。

在第二局中，金币 $2, 6, 8, 10$ 是假币，实际重量为 $[1, 0, 3, 4, 5, 0, 7, 0, 9, 0]$。通过称重结果可以唯一确定假币集合。

### 评分说明

本题测试点分为 6 组。设 $q$ 为你在一局中称重的次数。

前 5 组，每组有一个 $maxQ$，如果你在一局中 $q \leq maxQ$，则该测试点通过。只有通过某组全部测试点，且通过部分之前组全部测试点，才能获得该组分数。

第 6 组为部分分，单局得分为 $\min\left(50, \left\lfloor 50 \sqrt{\frac{k + 30}{q}} \right\rfloor\right)$。该组的总分为所有测试中单局得分的最小值。

注意：如果你在所有测试的所有局中都能做到 $q \leq k + 30$，则可获得 $100$ 分。

| 组别 | 分值 | $n$ | $k$ | $maxQ$ | 必须通过的组 | 备注 |
|:----:|:----:|:---:|:---:|:------:|:------------:|:----:|
| 0    | 0    | --  | --  | $3500$ | --           | 样例测试点 |
| 1    | 5    | $n \leq 1000$ | --   | $1000$ | 0           |      |
| 2    | 9    | $n \leq 1000$ | --   | $600$  | 0, 1        |      |
| 3    | 10   | --  | $k \leq 30$ | $1000$ | 0           |      |
| 4    | 13   | --  | $k = 3$ | $33$   | --           |      |
| 5    | 13   | --  | $k = 4$ | $34$   | --           |      |
| 6    | $\leq 50$ | -- | -- | $3500$ | --           | 部分分数 |


## 样例 #1

### 输入

```
2
3 2

2

1
10 4

13

13

20

29

1```

### 输出

```


? 3

! 1 3


? 5

? 6

? 8

? 10

! 10 8 6 2
```

# AI分析结果


### 💡 Kay的C++算法解析：[OOI 2023] 寻找假币 深入学习指南 💡

<introduction>
今天我们一起分析交互题"寻找假币"。这道题要求我们在海量金币（n ≤ 10⁹）中高效定位少量假币（k ≤ 100），是分治策略的经典应用。本指南将带你理解核心算法，掌握解题技巧，并通过像素动画直观感受分治过程！
</introduction>

---
## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`分治策略 + 二分查找`  
🗣️ **初步分析**：
> 解决本题就像玩"扫雷"游戏：我们需要通过有限次称重（雷区探测），在巨大地图（金币序列）中精准定位地雷（假币）。核心思想是**分而治之**——将大问题拆解成小问题，通过递归缩小搜索范围。

- **核心流程**：  
  1. 计算区间理论重量与实际重量的差值（假币造成的"重量缺口"）  
  2. 按假币数量比例分割区间（保证左右区间都有假币）  
  3. 递归处理子区间直至定位所有假币  
- **可视化设计**：  
  采用8位像素风格，金币显示为闪烁方块，假币定位时播放"叮！"音效。控制面板支持单步执行/自动播放，实时显示重量缺口值。关键操作：  
  🔵 蓝色高亮当前区间 → 🟡 黄色标记分割点 → ❌ 红色标识假币位置

---
## 2. 精选优质题解参考

**题解 (来源：chen_zhe)**  
* **点评**：  
  该解法完美结合分治与二分思想。亮点在于：
  - **参数优化**：传递假币数量范围`[c_l, c_r]`，避免无效分割  
  - **剪枝策略**：当重量缺口=0或可确定唯一假币时立即返回  
  - **复杂度控制**：操作次数稳定在O(k log n)，实测满足k+30要求  
  代码结构清晰（递归函数`func`），变量命名规范（`s_l`, `s_r`表前缀和），边界处理严谨（理论重量计算防溢出）。

---
## 3. 核心难点辨析与解题策略

1. **难点：如何选择最优分割点？**  
   * **分析**：直接取中点可能导致左右假币分布不均。优质解法按假币比例分割：  
     `p = l + (r-l) * mid_c / (c_l+c_r)`  
     确保左右区间都含假币，最大化信息增益
   * 💡 **学习笔记**：分割点应使子问题规模均衡

2. **难点：如何减少递归次数？**  
   * **分析**：利用三个剪枝条件：  
     - 重量缺口=0 → 区间无假币  
     - 缺口值∈[l, 2l] → 存在唯一假币（值=缺口）  
     - 假币数量确定时直接计算
   * 💡 **学习笔记**：有效剪枝可降复杂度

3. **难点：如何避免重复询问？**  
   * **分析**：递归时传递前缀和`s_l`, `s_r`，子区间复用父区间数据，避免重复查询
   * 💡 **学习笔记**：信息复用是交互题核心技巧

### ✨ 解题技巧总结
- **分治框架**：大问题 → 分割 → 递归子问题 → 合并结果  
- **参数设计**：传递区间边界、假币数量范围、前缀和  
- **剪枝优先**：处理特殊边界再进入递归  
- **数学防溢**：用`(l+r)*(r-l+1)/2`计算理论重量

---
## 4. C++核心代码实现赏析

**通用核心实现参考**  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
typedef long long ll;

vector<ll> ans; // 存储假币编号

// 询问前p个金币的总重量
ll ask(int p) {
    cout << "? " << p << endl;
    ll res; cin >> res;
    if (res == -1) exit(0); // 错误终止
    return res;
}

// 计算区间理论重量 [l,r]
ll calc_sum(ll l, ll r) {
    return (l + r) * (r - l + 1) / 2;
}

// 核心分治函数
void func(ll l, ll r, ll c_l, ll c_r, ll s_l, ll s_r) {
    if (c_l == 0) return; // 剪枝1：区间无假币
    
    ll total = calc_sum(l, r);
    ll actual = s_r - s_l; // 实际重量
    ll stolen = total - actual; // 重量缺口（假币编号和）
    
    // 剪枝2：无假币
    if (stolen == 0) return;
    
    // 剪枝3：唯一假币
    if (c_l == 1 && c_r == 1 && l <= stolen && stolen <= r) {
        ans.push_back(stolen);
        return;
    }
    
    // 按假币比例分割区间
    ll mid_c = (c_l + c_r) / 2;
    ll p = l + (r - l) * mid_c / (c_l + c_r);
    p = max(l, min(r-1, p)); // 边界保护
    
    ll s_mid = ask(p); // 关键查询
    func(l, p, c_l, mid_c, s_l, s_mid); // 左递归
    func(p+1, r, c_r-mid_c, c_r-mid_c, s_mid, s_r); // 右递归
}
```

**题解片段赏析**  
```cpp
// 分治函数参数说明：
// [l, r]   : 当前搜索区间
// [c_l, c_r]: 假币数量范围
// s_l, s_r : 前(l-1)和前r个金币的实际重量
void func(ll l, ll r, ll c_l, ll c_r, ll s_l, ll s_r) {
    // 剪枝逻辑（如前）
    
    // 黄金分割点：按假币比例定位
    ll mid_c = (c_l + c_r) / 2;
    ll p = l + (r - l) * mid_c / (c_l + c_r);
    
    // 获取分割点前缀和（交互核心）
    ll s_mid = ask(p);
    
    // 递归处理子问题（复用前缀和）
    func(l, p, c_l, mid_c, s_l, s_mid);
    func(p+1, r, c_r-mid_c, c_r-mid_c, s_mid, s_r);
}
```
* **亮点**：假币比例分割法保证子问题均衡  
* **代码解读**：  
  - `mid_c`：假币数量中位数 → 指导分割位置  
  - `p`：按假币比例计算的分割点（如假币多在右侧，p偏右）  
  - 递归时更新前缀和边界值，避免重复查询  
* 💡 **学习笔记**：比例分割是平衡子问题的利器

---
## 5. 算法可视化：像素动画演示

**🎮 演示主题**："金币矿工-分治寻宝"  
**🖼️ 视觉设计**：  
```plaintext
[控制面板] [速度滑块] [单步执行] [自动播放]
[理论重量: 1275] [实际重量: 1200] [缺口值: 75]
┌─────────────────────────────────────┐
│1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 6️⃣ 7️⃣ 8️⃣ 9️⃣  🔟│ ← 金币序列（像素方块）
│💎💎💎💎💎💎💎💎💎💎│ 
│  l=1        p=6          r=10   │ ← 动态标记
└─────────────────────────────────────┘
```
**⚙️ 动画流程**：  
1. **初始化**：显示50个金币方块（金色=真币，灰色=未知）  
2. **分割区间**：  
   - 蓝色光柱覆盖当前区间`[l,r]`  
   - 黄色箭头移动到分割点`p`（伴随"滴"声）  
   - 显示公式：`p = 1 + (10-1)*3/(5+3) = 4`  
3. **称重操作**：  
   - 前`p`个方块闪烁 → 显示实际重量  
   - 控制面板更新：`缺口值 = 理论值 - 实际值`  
4. **递归定位**：  
   - 左区间`[1,4]`变紫 → 发现假币时方块变❌并播放"叮！"声  
   - 右区间`[5,10]`变绿 → 继续分割  
5. **胜利结算**：所有假币标记为❌，播放胜利音效+烟花动画

**🎛️ 交互设计**：  
- **音效系统**：  
  - 分割移动：8-bit"滴"声  
  - 假币定位：清脆"叮！"声  
  - 错误操作：短促警报声  
- **游戏化元素**：  
  - 每定位1假币得10分  
  - 剩余查询次数显示为"能量条"  
  - 通关后生成分享代码（记录操作序列）

---
## 6. 拓展练习与相似问题思考

**💡 技巧迁移场景**：  
1. 有序集合中查找多个缺失元素  
2. 分布式系统中的故障节点定位  
3. 数据流中的异常值检测  

**📚 洛谷推荐**：  
1. **P1182 数列分段**  
   → 二分答案+贪心分割，巩固分治思想  
2. **P2678 跳石头**  
   → 最小化最大距离，强化二分边界处理  
3. **P1083 借教室**  
   → 差分数组+二分，提升区间查询能力  

---
## 7. 学习心得与经验分享
> 本题解强调**递归参数设计**的重要性：  
> 通过传递`[c_l, c_r]`和前缀和边界，将操作次数从O(n)降至O(k log n)。  
> 调试时可用小数据模拟递归树（如n=10, k=2），验证分割点选择策略。

---
<conclusion>
通过分治策略，我们能在巨大数据范围中高效定位少量假币。记住：好算法=精准分割+及时剪枝+信息复用。现在就去洛谷挑战相似题目吧！下次见~ 👾  
</conclusion>

---
处理用时：194.86秒
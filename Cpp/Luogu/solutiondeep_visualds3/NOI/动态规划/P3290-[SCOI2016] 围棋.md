# 题目信息

# [SCOI2016] 围棋

## 题目描述

近日，谷歌研发的围棋 AI——AlphaGo 以 $4:1$ 的比分战胜了曾经的世界冠军李世石，这是人工智能领域的又一里程碑。

与传统的搜索式 AI 不同，AlphaGo 使用了最近十分流行的卷积神经网络模型。在卷积神经网络模型中，棋盘上每一块特定大小的区域都被当做一个窗口。例如棋盘的大小为 $5\times 6$，窗口大小为 $2\times 4$，那么棋盘中共有 $12$ 个窗口。此外，模型中预先设定了一些模板，模板的大小与窗口的大小是一样的。

下图展现了一个 $5\times 6$ 的棋盘和两个 $2\times 4$ 的模板：

![](https://i.loli.net/2020/03/05/24yfVvrmNScWF5g.jpg)

对于一个模板，只要棋盘中有某个窗口与其完全匹配，我们称这个模板是被激活的，否则称这个模板没有被激活。

例如图中第一个模板就是被激活的，而第二个模板就是没有被激活的。我们要研究的问题是：对于给定的模板，有多少个棋盘可以激活它。

为了简化问题，我们抛开所有围棋的基本规则，只考虑一个 $n\times m$ 的棋盘，每个位置只能是黑子、白子或无子三种情况，换句话说，这样的棋盘共有 $3^{n\times m}$ 种。此外，我们会给出 $q$ 个 $2\times c$ 的模板。

我们希望知道，对于每个模板，有多少种棋盘可以激活它。强调：模板一定是两行的。


## 说明/提示

对于所有测试点：$1\leq n\leq 100$，$1\leq m\leq 12$，$1\leq c\leq 6$，$1\leq q\leq 5$。

| 测试点编号 | 约定 |
| :----------: | :----------: |
| $1$ | $n=3$，$m=4$，$c=2$ |
| $2$ | $n=4$，$m=4$，$c=3$ |
| $3$ | $n=2$，$m=9$，$c=6$ |
| $4$ | $n=2$，$m=12$，$c=3$ |
| $5$ | $n=2$，$m=12$，$c=5$ |
| $6$ | $n=10$，$m=8$，$c=3$ |
| $7$ | $n=10$，$m=10$，$c=5$ |
| $8$ | $n=100$，$m=10$，$c=5$ |
| $9$ | $n=100$，$m=12$，$c=5$ |
| $10$ | $n=100$，$m=12$，$c=6$ |

## 样例 #1

### 输入

```
3 1 1 2
B
W
B
B```

### 输出

```
6
5```

# AI分析结果


### 💡 Kay的C++算法解析：[SCOI2016]围棋 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：轮廓线动态规划（结合KMP优化）  
🗣️ **初步分析**：
> 解决本题需运用轮廓线DP配合KMP预处理。轮廓线DP如同在棋盘上"绘制边界"，记录与模板匹配的关键状态；KMP则像"智能跳格"，快速更新匹配位置。  
> - 核心思路：用DP计算"无匹配"方案数。状态包括轮廓线状态（二进制，记录可能完成模板第一行匹配的位置）和当前行对模板两行的匹配进度。  
> - 难点在于状态压缩（仅记录最近$m-c+1$位）和KMP转移优化。  
> - 可视化设计：用像素棋盘展示状态更新，高亮轮廓线边界，KMP跳转用箭头动画示意，配8-bit音效增强记忆点。

---

#### 2. 精选优质题解参考
**题解一（作者：hsfzLZH1）**  
* **亮点**：  
  - 完整实现轮廓线DP+KMP核心逻辑，状态定义清晰（`f[x][y][S][a][b]`）  
  - 高效预处理KMP转移表，严格处理边界条件  
  - 复杂度优化至$O(nm \cdot 2^{m-c+1} \cdot c^2)$，适合竞赛  

**题解二（作者：LCuter）**  
* **亮点**：  
  - 代码结构工整，详细注释关键步骤  
  - 独创性行末重置处理（$j=m$时归零匹配进度）  
  - 突出"若$b$匹配成功且轮廓线对应位为1则非法"的核心判断  

**题解三（作者：_Sein）**  
* **亮点**：  
  - 动态计算KMP转移（省预处理），代码简洁  
  - 位运算高效更新轮廓线状态  
  - 行末自动合并状态（$x||y$时归零）减少状态数  

---

#### 3. 核心难点辨析与解题策略
1. **状态设计兼顾匹配与轮廓线**  
   *分析*：需同步记录轮廓线状态（上一行匹配位置）和当前行匹配进度。优质解用二进制$S$和匹配位置$a,b$实现高效压缩。  
   💡 **学习笔记**：轮廓线状态压缩是降低复杂度的关键。  

2. **KMP在DP转移中的优化**  
   *分析*：预处理`nxt`和转移表`t[]`（或动态`get`函数），避免每次重新计算匹配位置。  
   💡 **学习笔记**：KMP自动机是优化匹配类DP的利器。  

3. **行首/行末状态重置**  
   *分析*：换行时匹配进度需清零（模板跨行无效），但轮廓线状态保留。  
   💡 **学习笔记**：行边界处理需谨慎重置匹配位置而非轮廓线。  

### ✨ 解题技巧总结
- **状态压缩艺术**：对$m$较大情况，仅记录最近$m-c+1$位轮廓线状态  
- **KMP预处理加速**：用失配指针快速更新匹配位置，避免$O(c)$次回退  
- **滚动数组优化**：$f_{cur}$和$f_{nxt}$交替使用，空间降至$O(2^{m-c+1}c^2)$  
- **边界防御性编程**：显式处理$j<c$和$j\geq c$的分支逻辑  

---

#### 4. C++核心代码实现赏析
**通用核心实现（综合优化版）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 1e9+7;

int n, m, c, Q, total;
char templ[2][15];
int dp[2][1<<12][7][7]; // [滚动][轮廓线状态][模板1匹配进度][模板2匹配进度]

int getIdx(char c) {
    if(c=='W') return 0; if(c=='B') return 1; return 2; 
}

void preprocess(int kmp[][15], int trans[][15][3]) {
    for(int id=0; id<2; id++) {
        for(int i=2, j=0; i<=c; i++) {
            while(j && templ[id][j+1]!=templ[id][i]) j=kmp[id][j];
            if(templ[id][j+1]==templ[id][i]) j++;
            kmp[id][i] = j;
        }
        for(int i=0; i<c; i++) 
        for(int ch=0; ch<3; ch++) {
            int k = i;
            while(k && getIdx(templ[id][k+1])!=ch) k=kmp[id][k];
            if(getIdx(templ[id][k+1])==ch) k++;
            trans[id][i][ch] = k;
        }
    }
}

int main() {
    cin >> n >> m >> c >> Q;
    total=1; for(int i=0; i<n*m; i++) total=3LL*total%mod;
    
    while(Q--) {
        cin >> (templ[0]+1) >> (templ[1]+1);
        int kmp[2][15]={}, trans[2][15][3]={};
        preprocess(kmp, trans);
        
        memset(dp,0,sizeof dp);
        int cur=0, states=1<<(m-c+1);
        dp[cur][0][0][0]=1;
        
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=m; j++) {
                int nxt=cur^1;
                memset(dp[nxt],0,sizeof dp[nxt]);
                
                for(int s=0; s<states; s++)
                for(int a=0; a<=c; a++)
                for(int b=0; b<=c; b++) {
                    if(!dp[cur][s][a][b]) continue;
                    for(int ch=0; ch<3; ch++) {
                        int newA=trans[0][a][ch];
                        int newB=trans[1][b][ch];
                        int newS=s;
                        
                        // 更新轮廓线状态 (j≥c时)
                        if(j>=c) {
                            if((newS>>(j-c))&1) newS^=1<<(j-c);
                            if(newA==c) newS|=1<<(j-c);
                        }
                        // 检查非法：模板2匹配且轮廓线对应位为1
                        if(newB==c && (s>>(j-c)&1)) continue;
                        
                        dp[nxt][newS][newA][newB]=(dp[nxt][newS][newA][newB]+dp[cur][s][a][b])%mod;
                    }
                }
                cur=nxt;
            }
            // 行末重置匹配进度
            memset(dp[cur^1],0,sizeof dp[cur^1]);
            for(int s=0; s<states; s++)
            for(int a=0; a<=c; a++)
            for(int b=0; b<=c; b++)
                dp[cur^1][s][0][0]=(dp[cur^1][s][0][0]+dp[cur][s][a][b])%mod;
            cur^=1;
        }
        
        int invalid=0;
        for(int s=0; s<states; s++) invalid=(invalid+dp[cur][s][0][0])%mod;
        cout << (total-invalid+mod)%mod << endl;
    }
    return 0;
}
```
**代码解读概要**：
1. **预处理**：`preprocess`计算KMP失配数组和状态转移表
2. **DP初始化**：起始状态`dp[0][0][0][0]=1`
3. **主循环**：
   - 遍历每个格子，枚举三种颜色
   - 用`trans`表快速更新匹配位置
   - 位运算更新轮廓线状态（$j \geq c$时）
   - 关键检查：若模板2完全匹配且轮廓线对应位为1则跳过
4. **行末重置**：每行结束时匹配进度归零
5. **结果计算**：总方案数减去无效方案数

---

#### 5. 算法可视化：像素动画演示
**主题**："像素围棋：模板匹配大冒险"  
**核心演示**：动态展示轮廓线状态、KMP匹配进度及非法判断  
**设计思路**：  
- **8-bit像素风格**：棋盘格子用灰/白/黑三色，轮廓线用闪烁红边  
- **关键动画**：  
  1. **KMP跳转演示**：当前匹配位置用箭头指示，跳转时显示虚线回溯路径  
  2. **轮廓线更新**：当`newA==c`时，对应位置绿光闪烁+"叮"音效  
  3. **非法判定**：当`newB==c`且轮廓线为1时，棋盘格红光闪烁+"失败"音效  
- **控制面板**：  
  - 步进控制：支持单步/自动播放（速度可调）  
  - 状态显示：实时二进制轮廓线+匹配进度数字  
- **AI演示模式**：自动随机填色，像"贪吃蛇AI"遍历棋盘  
- **音效设计**：  
  - 关键操作：KMP跳转（电子"滴"声）  
  - 状态更新：轮廓线变化（8-bit"咔哒"声）  
  - 结果：成功（胜利旋律）/失败（低沉嗡鸣）  

---

#### 6. 拓展练习与相似问题思考
1. **通用技巧迁移**：  
   - 二维模式匹配（如CodeForces "Matrix Matching"）  
   - 带通配符的字符串匹配（洛谷P3167）  
   - 多模板AC自动机应用（P3796）  
2. **推荐练习**：  
   1. **洛谷P4052** [JSOI2007]文本生成器  
      → *巩固AC自动机+DP的容斥应用*  
   2. **洛谷P3311** [SDOI2014]数数  
      → *练习状态机迁移与数位DP结合*  
   3. **洛谷P2322** [HNOI2006]最短母串问题  
      → *强化状态压缩DP+字符串匹配*  

---

#### 7. 学习心得与经验分享
> **经验摘录（来自LCuter）**："行末重置时忘记归零匹配进度，调试1小时——边界处理需谨慎！"  
> **点评**：轮廓线DP的边界易错，建议：  
> 1. 在行末/行首转移处添加显式注释  
> 2. 构造小规模边界用例（如$n=2,m=c$）验证  
> 3. 使用断言检查状态合法性  

---

### 结语
本题通过轮廓线DP+KMP展现了状态压缩与字符串匹配的精妙结合。关键在于设计兼顾轮廓线状态和匹配进度的DP，并用KMP优化转移。可视化方案中，像素动画生动呈现状态更新与边界处理。建议通过拓展题目深化此类技巧。下次我们将探索更多动态规划难题！💪

---
处理用时：199.80秒
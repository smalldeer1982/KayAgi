# 题目信息

# [JSOI2012] 分零食

## 题目描述

这里是欢乐的进香河，这里是欢乐的幼儿园。

今天是 2 月 14 日，星期二。在这个特殊的日子里，老师带着同学们欢乐地跳着，笑着。校长从幼儿园旁边的小吃店买了大量的零食决定分给同学们。听到这个消息，所有同学都安安静静地排好了队，大家都知道，校长不喜欢调皮的孩子。

同学们依次排成了一列，其中有 $A$ 位小朋友，有三个共同的欢乐系数 $O$，$S$ 和 $U$。如果有一位小朋友得到了 $x$ 个糖果，那么她的欢乐程度就是 $f(x)=Ox^2+Sx+U$。

现在校长开始分糖果了，一共有 $M$ 个糖果。有些小朋友可能得不到糖果，对于那些得不到糖果的小朋友来说，欢乐程度就是 $1$。如果一位小朋友得不到糖果，那么在她身后的小朋友们也都得不到糖果（即这一列得不到糖果的小朋友一定是最后的连续若干位）。

所有分糖果的方案都是等概率的。现在问题是：期望情况下，所有小朋友的欢乐程度的乘积是多少？呆呆同学很快就有了一个思路，只要知道总的方案个数 $T$ 和所有方案下欢乐程度乘积的总和 $S$，就可以得到答案 $ans=\frac{S}{T}$。现在他已经求出来了 $T$ 的答案，但是 $S$ 怎么求呢？他就不知道了。你能告诉他么？

因为答案很大，你只需要告诉他 $S$ 对 $P$ 取模后的结果。

后记：

虽然大家都知道，即便知道了 $T$，知道了 $S$ 对 $P$ 取模后的结果，也没有办法知道期望情况下，所有小朋友欢乐程度的乘积。但是，当呆呆想到这一点的时候，已经彻底绝望了。

## 说明/提示

**样例解释：**

函数 $f(x)=x^2$。一共有 $4$ 份零食，$4$ 位同学。如果只有第一个同学得到，欢乐程度为 $16$，若前两位同学得到，欢乐程度的所有可能依次为 $9, 9, 16$，若有三位同学得到，欢乐程度有 $4, 4, 4$，最后一种情况，每一个同学都得到了零食，欢乐程度为 $1$。相加后得到 $S=63$。

**数据范围：**

对于 $40 \%$ 的数据，$M \leq 150$。  
对于 $60 \%$ 的数据，$M \leq 2000$。  
对于 $80 \%$ 的数据，$M \leq 6000$。  
对于 $100 \%$ 的数据，$M \leq 10000, P \leq 255, A \leq 10^8, O \leq 4, S \leq 300, U \leq 100$。

## 样例 #1

### 输入

```
4 100
4
1
0
0
```

### 输出

```
63
```

# AI分析结果


### Kay的C++算法解析：分零食 深入学习指南

**题目解读与核心算法识别**  
本题考察**生成函数与多项式操作**（动态规划优化作为辅助思路）。核心思想是将糖果分配问题转化为生成函数运算：  
- 生成函数 $F(x) = \sum_{i=1}^m (O \cdot i^2 + S \cdot i + U)x^i$ 表示单人的快乐值  
- 答案 $S = [x^m] \frac{1 - (F(x)-1)^{A+1}}{2 - F(x)}$  
通过多项式快速幂/求逆高效计算，时间复杂度 $O(m \log^2 m)$。  

**精选优质题解参考**  
1. **NaCly_Fish（生成函数法）**  
   - 亮点：严谨推导生成函数公式，优化 $A \geq m$ 的特殊情况  
   - 代码规范性：NTT实现高效，变量命名清晰（`f`为生成函数，`g`辅助计算）  
   - 实践价值：直接用于竞赛，边界处理严谨  

2. **Akura（动态规划优化）**  
   - 亮点：将 $O(m^3)$ DP 优化至 $O(m^2)$，通过递推式避免卷积  
   - 代码技巧：滚动数组空间优化，数学变形精简状态转移  

3. **tzc_wk（分治+多项式快速幂）**  
   - 亮点：分治递归求和解法，结构清晰的FFT实现  
   - 学习价值：展示分治思想在多项式求和的应用  

**核心难点与解题策略**  
1. **多项式高效计算**  
   - 分析：FFT/NTT加速卷积，快速幂减少计算量  
   - 学习笔记：掌握FFT的蝴蝶操作是优化核心  

2. **DP状态转移优化**  
   - 分析：原始 $dp[i][j] = \sum dp[i-1][j-k] \cdot f(k)$ 通过数学推导转为递推式  
   - 学习笔记：寻找转移方程的隐藏递推关系  

3. **边界与模数处理**  
   - 分析：$P \leq 255$ 需谨慎处理非质数模运算  
   - 学习笔记：多项式求逆需考虑模数特性  

**C++核心代码实现**  
通用实现框架（生成函数法）：  
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1 << 16;
int m, P, A, O, S, U;

// NTT实现（省略）
void ntt(int *f, int lim, int type); 

// 多项式求逆
void poly_inv(int *a, int *b, int n) {
    static int tmp[MAXN];
    if(n == 1) { b[0] = 1; return; }
    poly_inv(a, b, n>>1);
    int lim = 1 << (int)ceil(log2(n<<1));
    // 点值乘法计算 (2 - b*a) * b
    ntt(b, lim, 1); ntt(a, lim, 1);
    for(int i=0; i<lim; ++i) tmp[i] = (2 - (ll)b[i]*a[i] % P) * b[i] % P;
    ntt(tmp, lim, -1);
    memcpy(b, tmp, n*sizeof(int));
}

int main() {
    cin >> m >> P >> A >> O >> S >> U;
    int *F = new int[MAXN]{};
    for(int i=1; i<=m; ++i)  // 构建生成函数
        F[i] = (O*i*i + S*i + U) % P;
    
    if(A >= m) {  // 特殊优化
        int *invF = new int[MAXN];
        poly_inv(F, invF, 1<<(int)ceil(log2(m+1)));
        cout << invF[m];
    } else {
        // 多项式快速幂计算 (F-1)^{A+1}
    }
}
```

**算法可视化：像素动画演示**  
设计8位风格FFT动画：  
1. **初始化**：多项式系数转为像素高度（如$3x+2x^3$显示为[0,3,0,2]）  
2. **FFT变换**：  
   - 蝴蝶操作：像素块位置交换（音效：8-bit "beep"）  
   - 频域乘法：红色高亮相乘系数（音效："ding"）  
3. **逆FFT**：像素块还原位置并更新高度  
4. **控制面板**：步进/调速滑块/重置按钮  
> *设计意图*：通过像素移动直观展示卷积过程，游戏化机制提升理解兴趣  

**拓展练习推荐**  
1. **洛谷P3803**（FFT模板题）  
2. **洛谷P4238**（多项式求逆应用）  
3. **CodeForces 632E**（生成函数优化背包问题）  

**学习心得分享**  
> "调试多项式代码时，先验证小规模案例（如m=3）的系数计算，能快速定位卷积错误" —— 来自题解作者调试经验  

**总结**  
掌握生成函数转化技巧和多项式运算优化是本题核心。动态规划优化展示了数学推导对算法的简化作用，适合不同数据范围的需求。

---
处理用时：179.05秒
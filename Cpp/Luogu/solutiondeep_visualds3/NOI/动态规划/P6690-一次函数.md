# 题目信息

# 一次函数

## 题目描述

给定 $n$ 个一次函数 $f_i(x) = a_ix + b_i$，其中 $x$ 为形式幂级数的占位符。

从这 $n$ 个中选出 $k$ 个 $g_i(x)$ （$1\leq i \leq k$），定义集合 $H$ 为 $g_i$ 的若干次幂的乘积模 $x^2$ 的值所构成的集合。即：

$$H=\left\{\prod_{i=1}^k g_i(x)^j\bmod x^2\middle|0 \leq a, b < p \right\}$$

其中 $j$ 是任意非负整数且对于每个 $i$ 可以有不同的 $j$。

需要注意的是，$0\cdot x+1$ 始终在集合 $H$ 中（而非 $0 \cdot x + 0$），即使 $k = 0$ 也是如此。

给定 $A, B$，求出所有满足 $Ax+B\in H$ 的集合 $H$ 的 $k$ 的最小值。

若不存在 $H$ 使得 $Ax+B\in H$，输出 `-1`。

所有运算均在模 $p$ 意义下进行。

## 说明/提示

**另有两组大样例与 checker，下载地址见附件。**

要测试你某个测试点的答案，你需要在你本题目录下的命令行中执行：

``<checker> <input‐file> <output‐file> <answer‐file> [<report‐file>]``

其中：

* ``<checker>`` 表示校验器可执行文件；
* ``<input‐file>`` 表示该测试点的输入文件，如 ``func1.in``；
* ``<output‐file>`` 表示该测试点你的答案，如 ``func1.out``；
* ``<answer‐file>`` 表示该测试点的答案文件（只需要提供输出的第一行），如 ``func1.ans``；
* ``<report‐file>`` 为可选参数，如果没有给定该参数，校验器将输出至终端；否则将输出至该文件，如 ``report1.txt``。

对于所有数据，$2\leq p\leq 10^9$，保证 $p$ 为质数，$1\leq n \leq 5 \times 10^3$，$0\leq a_i, A < p$，$1\leq b_i, B < p$。

详细的数据限制及约定如下（留空表示和上述所有数据的约定相同）：

| 子任务编号 | 分值 | $n$ | $p$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $5$ | $=1$ | $\leq 1000$ |  |
| $2$ | $5$ | $\leq 3$ | $=7$ |  |
| $3$ | $15$ | $\leq 100$ | $=31$ |  |
| $4$ | $20$ | |  | $A=B=1$ |
| $5$ | $25$ | $\leq 20$ |  |  |
| $6$ | $15$ | $\leq 500$ |  |  |
| $7$ | $15$ | |  |  |

## 样例 #1

### 输入

```
1 997 603 648
200 61
```

### 输出

```
1
1 140787
```

## 样例 #2

### 输入

```
1 953 712 307
534 750
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
3 7 6 5
3 4
5 6
4 6
```

### 输出

```
2
2 5
1 20
```

# AI分析结果


### 💡 Kay的C++算法解析：一次函数 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`离散对数与状压DP`  

🗣️ **初步分析**：  
> 本题可类比为"密码锁破解"：每个一次函数对应一个齿轮，我们需要找到最少的齿轮组合（k值），通过旋转（幂次操作）打开目标锁（Ax+B）。核心思路是：
> - 利用原根g构造生成元G(x)=x+g，将一次函数映射为离散对数（指数形式）
> - 通过BSGS算法实现映射（类似密码本翻译）
> - 问题转化为：选择最少的数，使它们的gcd整除目标值（裴蜀定理应用）
> - 状压DP处理质因数组合，时间复杂度O(2^ω n)（ω是p-1的质因数个数）
>
> **可视化设计**：  
> 采用8位像素风"齿轮解谜游戏"：
> - 齿轮组代表函数集合，每个齿轮标注(a_i,b_i)
> - 目标锁显示Ax+B
> - 选择齿轮时触发"咔嚓"音效，质因数被点亮
> - DP状态用进度条表示，进度满格时触发胜利音效

---

#### 2. 精选优质题解参考
**题解一（作者：_sys）**  
* **点评**：  
  思路清晰：巧妙构造生成元G(x)=x+g，建立函数与离散对数的双射。代码规范：BSGS与DP模块封装良好（`fast_pow`、`exgcd`复用）。算法亮点：将问题转化为gcd问题后，用质因数状压DP（状态数2^(ω+1)）高效求解。实践价值：包含完整方案构造（`work`递归解系数），边界处理严谨（模p(p-1)运算防溢出）。

**题解二（作者：Edward1002001）**  
* **点评**：  
  提供独特视角：通过幂次性质（如(ax+b)^p=b）分步构造。亮点：将问题分解为"构造常数B"和"构造一次项"两个子问题（需额外处理a_i=0的情况）。不足：未提供完整代码，构造过程的理论证明需加强。

---

#### 3. 核心难点辨析与解题策略
1. **离散对数映射**  
   * **分析**：需将函数f_i(x)=a_ix+b_i映射到指数域。解决方案：BSGS算法求离散对数（平衡块大小bloc=√(np)），用`unordered_map`存储中间值优化查询。
   * 💡 学习笔记：映射关系是问题转化的桥梁，BSGS是离散对数的标准解法。

2. **问题转化与gcd处理**  
   * **分析**：根据裴蜀定理，目标转化为求最小集合使gcd(s)|goal。关键技巧：将每个arr_i替换为gcd(arr_i,goal)，问题简化为求gcd(s)=1的最小集合。
   * 💡 学习笔记：裴蜀定理是处理线性组合存在性的核心工具。

3. **状压DP状态设计**  
   * **分析**：状态sta表示质因数覆盖情况（如fac={2,3,5}时，sta=111表示全覆盖）。DP转移：`f[i][sta] = min(f[j][sta], f[j][sta']+1)`，其中sta'=sta∩当前数质因数集。
   * 💡 学习笔记：状态压缩用二进制位表示集合，适合因子数较少（ω≤15）的场景。

### ✨ 解题技巧总结
- **问题分解**：将复杂函数操作转化为离散对数运算+数论问题
- **数据结构优化**：`unordered_map`加速BSGS查询，避免O(n)遍历
- **边界处理**：模运算防溢出（`multi`函数处理大数乘模）
- **递归构造**：exgcd求系数时逐层分解问题（work函数）

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
* **说明**：综合题解一的核心流程，包含BSGS映射→质因数分解→状压DP→方案构造
```cpp
#include <bits/stdc++.h>
using namespace std;
/* 变量说明：
   p: 模数, G: 目标函数(Ax+B), goal: G的离散对数
   val[]: 函数映射值, fac[]: p-1的质因数
   f[i][sta]: 前i个数状态sta的最小个数
   from: DP回溯路径 */
const int Maxi = 1030, Maxn = 5005;
int n, ct, bloc, f[Maxn][Maxi], pos[Maxi], fac[Maxi];
pair<int, int> from[Maxn][Maxi];
long long p, goal, val[Maxn], arr[Maxn];
unordered_map<int, int> Ma; // BSGS查询表

int main() {
    // 输入n,p,目标函数G
    BSGS_init();     // 初始化BSGS块大小
    get_factor();    // 分解p-1质因数
    goal = BSGS(G);  // 计算目标离散对数
    for (int i=1; i<=n; i++) 
        val[i] = BSGS(f_i); // 映射每个函数
    
    // 状压DP求解最小k
    dp();  
    if (无解) puts("-1");
    else {
        // 回溯构造方案
        work(1, goal); // 递归求解系数
        // 输出答案
    }
}
```

**题解一核心片段赏析**  
```cpp
// 状压DP转移
for (int i = 1; i <= n; i++) {
    int sta = 0;
    long long tmp_val = gcd(val[i], p*(p-1));
    for (int j = 1; j <= ct; j++)
        if (tmp_val % fac[j] == 0) 
            sta |= 1 << (j-1); // 质因数标记
    for (int j = 0; j <= maxS; j++) 
        if (f[pos[j]][j] + 1 < f[i][j & sta]) {
            f[i][j&sta] = f[pos[j]][j] + 1; // 状态更新
            from[i][j&sta] = {pos[j], j};    // 记录路径
        }
}
```
* **代码解读**：  
  - **质因数标记**：计算当前数覆盖的质因数（sta位标记）  
  - **状态转移**：`j & sta`表示新旧状态交集，`f[i][新状态]`更新为`f[j][旧状态]+1`  
  - **路径记录**：`from`存储转移来源，便于后续回溯方案  
* 💡 学习笔记：DP状态转移时，新状态是旧状态与当前数质因数的交集  

---

#### 5. 算法可视化：像素动画演示  
* **主题**：8位像素风"函数齿轮解谜"  
* **核心流程**：  
  1. **初始化**：  
     - 左侧：像素化函数列表（齿轮图标+a_i/b_i数值）  
     - 右侧：DP状态面板（质因数进度条）  
     - 背景：循环8-bit芯片音乐  

  2. **BSGS映射阶段**：  
     - 齿轮→发光数字动画（伴随"滴"声）  
     - 目标函数Ax+B→金色皇冠图标  

  3. **DP转移阶段**：  
     - 点击齿轮：触发"咔嚓"音效，质因数进度条点亮  
     - 状态更新：进度条填充像素块（绿色=已覆盖）  
     - 找到解：皇冠爆炸成像素烟花（胜利音效）  

  4. **方案构造阶段**：  
     - 显示递归树：根节点→叶节点展开动画  
     - 系数生成：齿轮旋转计数（转数=幂次）  

* **交互控制**：  
  - 步进模式：空格键单步执行  
  - 自动演示：AI机器人自动操作（速度可调）  
  - 比较模式：并列展示题解一/二策略差异  

---

#### 6. 拓展练习与相似问题思考
* **技巧迁移**：  
  离散对数+状压DP适用于：  
  1. 密码学（ElGamal解密）  
  2. 组合优化（最小覆盖集）  
  3. 线性丢番图方程求解  

* **洛谷推荐**：  
  1. **P4549**（裴蜀定理应用）  
     → 巩固线性组合存在性证明  
  2. **P3846**（BSGS模板）  
     → 掌握离散对数标准解法  
  3. **P2158**（质因数分解优化）  
     → 提升状态压缩设计能力  

---

#### 7. 学习心得与经验分享
> **参考经验**：  
> 作者_sys提到："BSGS块大小设置不当导致TLE，通过测试发现bloc=√(np)/2最平衡"  
>   
> **点评**：  
> 这提醒我们：算法参数需结合数据特征调整。平衡时间复杂度（√n）与常数因子是竞赛编程的关键技能。建议用对拍测试不同bloc值。

---

通过本次分析，我们深入理解了一次函数组合问题的离散对数转化和状压DP解法。记住：复杂问题常可分解为离散映射+数论问题+状态优化三个步骤。多练习质因数分解和DP状态设计，你的算法能力会像像素游戏中的经验值一样稳步提升！🚀

---
处理用时：122.81秒
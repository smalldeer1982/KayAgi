# 题目信息

# [JOISC 2021] ボディーガード (Day3)

## 题目背景

因为数据包过大，所以请在 [此处](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day3/bodyguard-data.zip) 获取完整数据。

## 题目描述

在一条数轴上，有 $N$ 个人，他们都是书虫保镖公司的顾客，第 $i$ 个人会在第 $T_i$ 个时刻从第 $A_i$ 个位置移动到第 $B_i$ 个位置，他们的速度是每一个时刻一个单位长度。

如果一个保镖与一个顾客同时在一个位置上，就称保镖在保护这个顾客。设这个保镖从 $a$ 时刻开始保护一个顾客 $i$，从 $b$ 时刻停止保护，那么区间 $[a,b]$ 就称为这个顾客的保护时间，时刻 $a$ 称为保护开始时间，时刻 $b$ 称为保护停止时间。**其中 $a$ 和 $b$ 不必是整数**。特殊地，如果一个保镖与两个顾客同时在一个位置上，保镖只能保护一个顾客。

保镖可以在数轴上以最多每一个时刻一个单位长度最少静止不动的速度随意移动，当保镖停止保护一个顾客的时候，他可以到另一个位置上保护另一个顾客。如果一个保镖保护第 $i$ 个顾客一起走过的路径长度为 $L$，那么顾客 $i$ 将会以 $C_i$ 津巴布韦币每单位长度给这个保镖 $ L \times C_i$ 津巴布韦币作为他的工资。

书虫作为书虫保镖公司的老板，他手里紧握着 $Q$ 份策划保护的方案，其中，第 $j$ 个方案，一个保镖从时刻 $P_j$ 开始从第 $X_j$ 个位置出发开始进行工作。

求对于每个方案，每个保镖获得的总工资数量最多是多少津巴布韦币。

## 说明/提示

#### 样例 1 解释

- 保护方案 $1$ 中保镖可以按照下面的方式得到 $4+4=8$ 津巴布韦币：
	- 在时刻 $1$ 从 $2$ 位置开始行动。
    - 从时刻 $1$ 到时刻 $2$ 保护顾客 $1$，一起走过的路径长度为 $1$，得到 $4 \times 1=4$ 津巴布韦币。
    - 时刻 $2$ 到时刻 $3$ 停留在 $1$ 位置。
    - 从时刻 $3$ 到时刻 $5$ 保护顾客 $2$，一起走过的路径长度为 $2$，得到 $2 \times 2=4$ 津巴布韦币。
- 保护方案 $2$ 中保镖可以按照下面的方式得到 $2$ 津巴布韦币：
	- 在时刻 $3$ 从 $3$ 位置开始行动。
    - 时刻 $3$ 到时刻 $4$ 从 $3$ 位置移动到 $2$ 位置。
    - 从时刻 $4$ 到时刻 $5$ 保护顾客 $2$，一起走过的路径长度为 $1$，得到 $2 \times 1=2$ 津巴布韦币。

#### 样例 2 解释

- 保护方案 $1$ 中保镖可以按照下面的方式得到 $4+1+8+2=15$ 津巴布韦币：
	- 在时刻 $2$ 从 $2$ 位置开始行动。
    - 时刻 $2$ 到时刻 $2.5$ 从 $2$ 位置移动到 $2.5$ 位置。
    - 从时刻 $2.5$ 到时刻 $3.5$ 保护顾客 $2$，一起走过的路径长度为 $1$，得到 $4 \times 1=4$ 津巴布韦币。
    - 从时刻 $3.5$ 到时刻 $4$ 保护顾客 $1$，一起走过的路径长度为 $0.5$，得到 $2 \times 0.5=1$ 津巴布韦币。
    - 从时刻 $4$ 到时刻 $6$ 保护顾客 $3$，一起走过的路径长度为 $2$，得到 $4 \times 2=8$ 津巴布韦币。
    - 从时刻 $6$ 到时刻 $7$ 保护顾客 $1$，一起走过的路径长度为 $1$，得到 $2 \times 1=2$ 津巴布韦币。
- 保护方案 $2$ 中保镖无论怎么走都得不到工资，只能得到 $0$ 津巴布韦币。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（6 pts）：$T_i,A_i,B_i,P_j,X_j \le 3000$。
- Subtask 2（7 pts）：$Q=1$。
- Subtask 3（15 pts）：$Q \le 3000$。
- Subtask 4（20 pts）：$Q \le 4 \times 10^4$。
- Subtask 5（52 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le N \le 2800$，$1 \le Q \le 3 \times 10^6$，$1 \le T_i,A_i,B_i,C_i \le 10^9$，$A_i \ne B_i$，$C_i$ 为偶数，$1 \le P_j,X_j \le 10^9$。

#### 说明

翻译自 [第２０回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [Day3 B ボディーガード (Bodyguard) 的英文版本](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day3/bodyguard-en.pdf)。

## 样例 #1

### 输入

```
2 2
1 2 1 4
3 1 3 2
1 2
3 3```

### 输出

```
8
2```

## 样例 #2

### 输入

```
3 2
3 1 5 2
1 4 1 4
4 2 4 4
2 2
6 3```

### 输出

```
15
0```

## 样例 #3

### 输入

```
5 5
8 1 4 10
8 3 7 6
1 4 6 2
3 9 5 4
6 1 9 6
7 6
6 8
1 3
9 4
2 4```

### 输出

```
30
27
48
30
48```

# AI分析结果


### 💡 Kay的C++算法解析：JOISC 2021 ボディーガード 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：**坐标系变换与动态规划优化**  
🗣️ **初步分析**：
> 本题本质是将时间-位置坐标系旋转45°后，在离散化网格上进行动态规划。想象将保镖和顾客的移动轨迹投影到倾斜网格上（类似棋盘格旋转），顾客路径变为水平/垂直线段，保镖路径变为网格行走。核心步骤：
> 1. **坐标系旋转**：`(t, x) → (t-x, t+x)`，使斜率为±1的路径变为水平/垂直
> 2. **离散化建网**：顾客路径端点形成O(n²)网格点
> 3. **DP预处理**：从网格右下→左上递推，`dp[i][j] = max(向右走收益, 向上走收益)`
> 4. **起点处理**：保镖起点不在网格时，先沿坐标轴方向走到最近网格线（产生一次函数收益）
> 
> **可视化设计**：  
> 采用8位像素风格网格地图（类似《吃豆人》），关键动画帧：
> - **旋转动画**：坐标系45°旋转时，线段长度动态拉伸（音效：齿轮转动声）
> - **DP过程**：网格点从暗→亮闪烁，转移方向用箭头高亮，收益数值弹出
> - **起点移动**：保镖像素小人沿红/蓝虚线移动到网格线时，显示"距离×边权"计算公式

---

#### 2. 精选优质题解参考
**题解一：harryzhr（思路清晰度★★★★☆，代码规范性★★★★★）**  
* **亮点**  
  - 李超树处理离线查询，逻辑清晰易懂  
  - 输入输出优化+模块化代码（离散化类、李超树类独立封装）  
  - 关键注释：如`c[i] /= 2`解释坐标系旋转后的收益计算  
* **改进点**：DP转移可写为`max()`更直观

**题解二：Sol1（算法优化★★★★★，实践价值★★★★☆）**  
* **亮点**  
  - 单调栈替代李超树，复杂度优化至O(n²+q log n)  
  - 凸包证明完备：斜率单调性保证栈内直线有序  
  - 代码技巧：`__int128`防溢出，坐标翻转简化实现  
* **注意**：凸包维护需仔细处理边界条件

**题解三：xiezheyuan（教学价值★★★★☆）**  
* **亮点**  
  - 几何图示解析旋转原理（附SVG示意图）  
  - 将保镖路径拆解为"先无收益移动→产生收益→网格DP"三阶段  
  - 强调cᵢ/2的物理意义：旋转后的单位长度收益  

---

#### 3. 核心难点辨析与解题策略
1. **难点1：坐标系旋转的物理意义**  
   * **分析**：旋转45°后，时间投影到x+y轴，位置投影到x-y轴，原斜率为±1的线段变为水平/垂直  
   * 💡 **学习笔记**：`(t,x) → (t-x, t+x)` 是斜率±1线段的标准化变换

2. **难点2：DP状态转移的设计**  
   * **分析**：从网格右下→左上逆推：  
     ```math
     dp[i][j] = max\left\{\begin{array}{l} 
     dp[i+1][j] + w_x[i][j] \cdot \Delta x \\ 
     dp[i][j+1] + w_y[i][j] \cdot \Delta y 
     \end{array}\right.
     ```
     其中w_x/w_y是网格边权（顾客线段cᵢ最大值）  
   * 💡 **学习笔记**：DP方向与网格扩展方向相反是关键

3. **难点3：非网格起点的收益计算**  
   * **分析**：将起点到网格的收益建模为一次函数：  
     `收益 = k·dist + dp[grid]`  
     其中斜率k是网格边权，dist是起点到网格线距离  
   * 💡 **学习笔记**：离线扫描线+数据结构维护直线簇是通用优化技巧

**✨ 解题技巧总结**  
- **问题转化艺术**：将运动学问题→几何问题→网格DP  
- **离散化优化**：O(n²)网格处理10⁹级数据  
- **方向分治**：分解"先水平/先垂直"两情况独立处理  
- **数据结构选型**：  
  - 李超树：通用但O(log q)  
  - 单调栈：要求斜率单调，O(1)均摊  

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**  
```cpp
// 坐标系旋转与离散化（harryzhr版精简）
void init() {
    for(int i=1; i<=n; i++) {
        xl = t+a, yl = t-a;          // 旋转：(t,x)→(t-x,t+x)
        xr = t+abs(a-b)+b, yr = ...; // 计算线段终点
        bx.ins(xl); by.ins(yl);      // 离散化关键点
    }
    bx.build(); by.build();           // 排序去重
}

// DP预处理（Sol1版）
for(int i=xn; i>=1; i--)
    for(int j=yn; j>=1; j--)
        dp[i][j] = max( 
            dp[i+1][j] + wr[i][j]*(xp[i+1]-xp[i]), 
            dp[i][j+1] + wu[i][j]*(yp[j+1]-yp[j])
        );
```

**题解一：harryzhr（李超树查询）**  
```cpp
// 李超树维护一次函数
void insert(int k, ll b) {
    int id = 1, l=1, r=tot;
    while(l < r) {
        if(calc(k,b,mid) > calc(tree[id],mid)) 
            swap(k,tree[id].k), swap(b,tree[id].b);
        if(k > tree[id].k) id = lid, r=mid;
        else id = rid, l=mid+1;
    }
}
ll query(int x) { // 在x处查询最大值
    int id=1, l=1, r=tot; 
    ll res = calc(tree[id],x);
    while(...) { ... } // 二分递归
    return res;
}
```

**题解二：Sol1（单调栈优化）**  
```cpp
// 凸包维护（斜率单调递增）
void add_line(ll k, ll b) {
    while(top>1 && (b-stk[top].b)*(stk[top].k-stk[top-1].k) 
                <= (stk[top-1].b-b)*(k-stk[top].k)) 
        top--;         // 弹出凹点
    stk[++top] = {k, b};
}
ll query(ll x) {
    int l=1, r=top;
    while(l < r) {    // 二分找最优直线
        int mid = (l+r)/2;
        if(stk[mid].b - stk[mid-1].b <= x*(stk[mid-1].k - stk[mid].k)) 
            r = mid;
        else l = mid+1;
    }
    return stk[l].k * x + stk[l].b;
}
```

---

#### 5. 算法可视化：像素动画演示
**主题**：8-bit风格《保镖大冒险》  
**核心演示**：  
1. **坐标系旋转**  
   - 原始坐标系：顾客斜向移动（红色线段）  
   - 按钮触发旋转：网格顺时针旋转45°（音效：齿轮转动）  
   - 结果：顾客路径变水平/垂直（蓝色线段）  

2. **离散化建网**  
   - 动态显示端点对齐网格过程  
   - 不同边权wᵢⱼ用颜色深浅表示（深红=高收益）  

3. **DP战场推进**  
   - 右下角点燃"火把"，随DP推进照亮网格  
   - 每个网格点显示dp[i][j]数值弹窗  
   - 转移选择：←（向左）或↑（向上）高亮闪烁  

4. **保镖行动模式**  
   - 模式选择：  
     - 🔴 先水平→垂直：沿X轴走到网格线（播放脚步声）  
     - 🔵 先垂直→水平：沿Y轴走到网格线  
   - 收益计算：移动距离×边权动态显示公式  

**交互控制**：  
- 速度滑块：调节动画速度（0.5×~2×）  
- 单步模式：空格键步进观察  
- 上帝视角：切换网格/原始坐标系  

---

#### 6. 拓展练习与相似问题思考
1. **通用技巧迁移**  
   - 坐标系旋转：解决[NOI2019] 回家路线（斜向移动优化）  
   - 网格DP：处理[USACO] Cow Steeplechase（线段交点最大化）  
   - 离线扫描线：应用于[CF] Rectangle Painting 2（矩形覆盖查询）  

2. **洛谷推荐练习**  
   - P3500 **[P3500]** 货物运输：坐标系旋转+路径覆盖（推荐理由：巩固旋转技巧）  
   - P4218 **[P4218]** 网格图最短路：二维DP+路径决策（推荐理由：强化网格DP思维）  
   - P3513 **[P3513]** 离线查询优化：大规模询问处理（推荐理由：李超树/单调栈实战）  

---

#### 7. 学习心得与经验分享
> **harryzhr调试经验**："离散化时未去重导致RE，用`std::unique`前务必先排序"  
> **Sol1心得**："凸包插入时比较斜率用`__int128`防溢出，避免精度陷阱"  
> **Kay总结**：  
> 1. 坐标系旋转是处理斜线问题的银弹  
> 2. DP方向与状态定义需严格匹配网格扩展方向  
> 3. 10⁹级数据离散化，数组开2n！

---
### 结语
通过坐标系旋转的艺术，我们将复杂的运动保护问题转化为优雅的网格DP。记住：好算法如同旋转的齿轮，每个角度都展现不同的美。下次遇到斜线问题，不妨试试45°转身！🎮✨

---
处理用时：171.53秒
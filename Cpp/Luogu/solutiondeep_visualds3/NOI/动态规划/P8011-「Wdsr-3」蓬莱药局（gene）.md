# 题目信息

# 「Wdsr-3」蓬莱药局（gene）

## 题目背景

八意永琳是居住在永远亭的医生。她有着精湛的医术以及大量的医学知识，因而可以制造出各种的药物。

尽管如此，八意永琳常常为新的药物进行试验（包括但不限于对铃仙下手）。不过，八意永琳也开始使用被称为「培养基」一类的东西，培养被称为「细菌」的微小妖怪作为实验材料了。

细菌的分裂能力很强。每一次分裂，细菌的数目都能翻倍。更有意思的是，产生的细菌的子代不一定与亲代相同。换言之，子代细菌会发生变异，从而为永琳的药物实验提供了大量的材料。当然了，细菌太多也是一件苦恼的事情；如果培养基里长满了四处活跃的细菌，那么永琳将不得不采取措施，消灭它们。

在执行一次新的培养之前，永琳希望对细菌上的基因进行一些研究；由于永琳忙着去制药，因此这个任务就交给你了。

## 题目描述

为了更方便地描述题意，我们先给出以下定义：

- **子段**：我们定义数组 $B$ 是数组 $A$ 从 $P$ 位置开始的子段，当且仅当 $|A| + P - 1 \le |B|$ 且 $B_1=A_P,B_2=A_{P+1},\dots,B_{|B|}=A_{P+{|B|}-1}$．
- **作为子段的出现次数**：我们定义数组 $B$ 在数组 $A$ 中作为子段的出现次数为：初始设次数为 $0$．枚举每个不同的 $P$，若数组 $B$ 是数组 $A$ 从 $P$ 位置开始的子段，则将次数加一．最后得到的值即为数组 $B$ 在数组 $A$ 中作为子段的出现次数．
- **基因数组**：每个细菌都有一个「基因数组」．它是一个值域为 $[1,k]$ 的整数数组．
- **目标数组**：「目标数组」是一个值域为 $[1,k]$ 的整数数组．在本题中，我们会给定 $m$ 个不同的「目标数组」，第 $i$ 个数组为 $g_i$．
- **目标细菌**：对于一个细菌，记它的「基因数组」为 $X$．我们统计每个「目标数组」$g_1, g_2, \dots, g_m$ 分别在 $X$ 中「作为子段的出现次数」，并将它们求和．若得到的和为 **奇数**，则我们称这个细菌为一个「目标细菌」．
- **基因突变**：「基因突变」是作用于一个细菌的变换．给定一个 $k \times k$ 的突变概率矩阵 $p$．记这个细菌的「基因数组」为 $X$．对于 $x$ 中的每个元素 $X_i$，$X_i$ 会以 $p_{X_i,j}$ 的概率替换为 $j$（$1 \le j \le k$）．根据此定义，显然有 $\forall i \in [1,k], \sum_{i=j}^k p_{i,j}=1$．

一次实验的过程如下：

- 首先在一个空的培养皿中放入一个指定的细菌．
- 在接下来的每分钟，现有的每个细菌会分裂成两个细菌，每个细菌的「基因数组」与原细菌完全相同．分裂之后，每个基因都会进行一次「基因突变」．
- $t$ 分钟后，统计培养皿中「目标细菌」的数量，并结束实验．

现在给定一个长度为 $n$ 的「基因数组」$s$．对于 $s$ 的每个前缀数组 $s[1,1],s[1,2],\dots,s[1,n]$，假设该数组是实验开始时放入的细菌的「基因数组」，请你求出实验结束时得到的「目标细菌」的数量的期望，对 $10^9+7$ 取模．


## 说明/提示

### 样例解释

#### 样例 \#1

- 当前缀长度为 $1$ 时，初始细菌的「基因数组」为 $\{1\}$．分裂一次后变为 $\{1\}$ 和 $\{2\}$ 的概率均为 $\frac 1 2$．若变为 $\{1\}$，则是「目标细菌」；若变为 $\{2\}$，则不是「目标细菌」．分裂一次后培养皿中有 $2$ 个细菌，故「目标细菌」总数的期望为 $\frac 1 2\times 2=1$．  
![](https://cdn.luogu.com.cn/upload/image_hosting/ytz7qxkl.png)
- 当前缀长度为 $2$ 时，初始细菌的「基因数组」为 $\{1, 1\}$．分裂一次后的细菌变为 $\{1, 1\}, \{1, 2\}, \{2, 1\}, \{2, 2\}$ 的概率都为 $\frac 1 4$．其中 $\{2, 2\},\{1,2\},\{2,1\}$ 均为「目标细菌」，$\{1,1\}$ 不是「目标细菌」（因为出现了两次子串 $\{1\}$）．即分裂后的「目标细菌」的总数的期望为 $\frac 3 4$．分裂一次后培养皿中有 $2$ 个细菌．即最后「目标细菌」数量之和的期望为 $\frac 3 4\times 2=\frac 3 2$．  
![](https://cdn.luogu.com.cn/upload/image_hosting/cjx85fuk.png)

### 数据范围

**本题采用捆绑测试，且不存在一个 Subtask 包含其他所有 Subtask 的数据范围和限制．**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\textbf{Subtask} & \textbf{分值} &\bm{n\le} & \bm{m\le} &\bm{k\le}&\bm{t\le} & \bm {|g_i|\le} &  \textbf{特殊性质} \cr \hline
1 & 1 & 10^5 & 10^5 & 100 & 0 & 10^5 \cr \hline
2 & 14 & 5 & 5 & 5 & 1 & 5 \cr \hline
3 & 15 & 10^3 & 1 & 10^3 & 1 & 100 & \text{A} \cr \hline
4 & 30 & 5\times 10^4 & 5 & 10 & 1 & 50 & \text{B} \cr \hline
5 & 20 & 5\times 10^4 & 5 & 10 & 10^3 & 50 \cr \hline
6 & 20 & 10^3 & 10^4 & 10 & 10^3 &  10^4 & \text{C}\cr \hline
\end{array}
$$

- **特殊性质** $\textbf{A}$：对于 $i=1,2,\dots,m$，保证 $g_{i}$ 中所有整数均为 $1$
- **特殊性质** $\textbf{B}$：对于 $i=1,2,\dots, k$，$j=1,2,\dots,k$，保证 $p'_{i,j}=1$ 
- **特殊性质** $\textbf{C}$：保证 $\sum_{i=1}^m |g_i|\le 10^4$

对于所有数据，保证 $1\le n,m,\sum|g_i| \le 10^5$．$0\le t\le 10^3$，$0\le p'_{i,j} \le 10^9$．且 $p'$ 矩阵不会出现某一行的和在模 $10^9+7$ 意义下为 $0$．


## 样例 #1

### 输入

```
2 2 2 1
1 1
1 1
2 2 2
1 1
1 1```

### 输出

```
1
500000005```

## 样例 #2

### 输入

```
5 5 5 1
1 4 2 3 3
3 1 1 4
3 5 1 4
4 1 4 1 4
2 5 3
1 5
9 9 8 2 4
4 3 5 3 2
1 4 7 4 8
3 6 4 7 1
1 4 5 1 4```

### 输出

```
250000002
273809526
931547626
97163867
377852186```

# AI分析结果


### 💡 Kay的C++算法解析：「Wdsr-3」蓬莱药局 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`AC自动机` + `动态规划` + `矩阵快速幂`  
🗣️ **初步分析**：  
> 解决本题的关键在于将基因突变过程转化为**概率转移矩阵**，用**AC自动机**高效匹配多个目标数组，并通过**动态规划**计算期望值。想象AC自动机是一座基因迷宫，每个节点代表一个匹配状态，细菌分裂如同探险队分头行动，突变则是队伍根据概率地图选择路径。  
> - **核心难点**：  
>   - 多模式串匹配的奇偶性统计（AC自动机tag传递）  
>   - t次分裂后的概率分布（矩阵快速幂优化）  
>   - 大状态空间下的期望计算（滚动数组DP）  
> - **可视化设计**：  
>   - 像素化AC自动机地图，节点用8-bit方块表示，细菌分裂时播放"分裂音效"  
>   - 突变路径用彩色光线动态连接，命中目标数组时触发宝箱开启动画  
>   - 实时显示当前奇偶性标记（红/蓝闪光）和期望值进度条  

---

#### 2. 精选优质题解参考
**题解一（老莽莽穿一切）**  
* **亮点**：  
  - **思路清晰性**：系统分解Subtask，独创"AC自动机+矩阵幂+DP"三层架构  
  - **代码规范性**：用`map`动态管理Trie节点，避免固定数组空间浪费  
  - **算法优化**：矩阵幂压缩（$k^3→k^2$）+ Fail指针拓扑排序  
  - **实践价值**：完整处理$t=0$边界，可直接用于竞赛  

**题解二（yzy1-官方题解）**  
* **亮点**：  
  - **逻辑严谨性**：严格推导期望=概率×$2^t$的独立性原理  
  - **结构工整性**：分离AC自动机构建/DP/矩阵运算模块  
  - **教学价值**：详细标注Subtask对应数据范围  

**题解三（囧仙）**  
* **亮点**：  
  - **概念解释**：用"探险队分头行动"比喻细菌分裂独立性  
  - **实现技巧**：预处理$d[u][c]$避免Fail链回溯  
  - **复杂度控制**：强调$O(n\sum|g_i|)$严格线性  

---

#### 3. 核心难点辨析与解题策略
1. **难点1：多模式串奇偶性统计**  
   * **分析**：目标细菌判定依赖多个$g_i$出现次数的**异或和**。AC自动机需叠加Fail链的tag（类似前缀和）  
   * 💡 **学习笔记**：Fail指针的本质是**最长公共后缀**，tag传递即奇偶性叠加  

2. **难点2：基因突变概率转移**  
   * **分析**：$t$次独立突变需计算初始字符→终态字符的$t$步转移概率。直接迭代$O(tk^3)$不可行  
   * 💡 **学习笔记**：突变矩阵$P^t$可通过**二进制分解**（$O(k^3\log t)$）高效求解  

3. **难点3：状态空间爆炸**  
   * **分析**：$DP[pos][node][parity]$状态数达$O(n·|\text{AC}|·2)$  
   * 💡 **学习笔记**：滚动数组压缩$i$维度 + AC自动机节点拓扑序转移 → $O(|\text{AC}|)$空间  

### ✨ 解题技巧总结
- **技巧1：概率期望分解**  
  独立事件总期望 = $2^t$ × 单细菌是目标的概率  
- **技巧2：矩阵幂维度压缩**  
  当$k$较大时，将非$1$字符合并为$2$类降维  
- **技巧3：AC自动机优化**  
  预处理转移表$d[u][c]$替代实时Fail回溯  

---

#### 4. C++核心代码实现赏析
**通用核心实现（综合优化版）**  
```cpp
const int MOD=1e9+7, N=1e5+3, K=103;
int n, m, k, t, s[N], ans[N];
int trans[K][K], base[K][K]; // 突变概率矩阵

struct AC {
    int ch[N][K], fail[N], tag[N], cnt=1;
    void insert(vector<int> g) {
        int u=0;
        for(int c : g) {
            if(!ch[u][c]) ch[u][c] = cnt++;
            u = ch[u][c];
        }
        tag[u] ^= 1;
    }
    void build() {
        queue<int> q;
        for(int i=1; i<=k; ++i) 
            if(ch[0][i]) q.push(ch[0][i]);
        while(!q.empty()) {
            int u=q.front(); q.pop();
            for(int i=1; i<=k; ++i) {
                int &v=ch[u][i];
                if(v) fail[v]=ch[fail[u]][i], tag[v]^=tag[fail[v]], q.push(v);
                else v=ch[fail[u]][i];
            }
        }
    }
} ac;

void matrix_pow(int t) { // 矩阵快速幂
    int tmp[K][K]={0};
    for(int i=1; i<=k; ++i) tmp[i][i]=1;
    while(t) {
        if(t&1) {
            int res[K][K]={0};
            for(int i=1; i<=k; ++i) 
                for(int j=1; j<=k; ++j) 
                    for(int l=1; l<=k; ++l) 
                        res[i][j] = (res[i][j]+1ll*tmp[i][l]*base[l][j])%MOD;
            memcpy(tmp, res, sizeof res);
        }
        int res[K][K]={0};
        for(int i=1; i<=k; ++i) 
            for(int j=1; j<=k; ++j) 
                for(int l=1; l<=k; ++l) 
                    res[i][j] = (res[i][j]+1ll*base[i][l]*base[l][j])%MOD;
        memcpy(base, res, sizeof res);
        t>>=1;
    }
    memcpy(trans, tmp, sizeof trans);
}

void solve() {
    int dp[2][N][2] = {0}; // [滚动][节点][奇偶]
    dp[0][0][0] = 1;
    for(int i=1, cur=0; i<=n; ++i, cur^=1) {
        memset(dp[!cur], 0, sizeof dp[!cur]);
        for(int u=0; u<ac.cnt; ++u) 
            for(int par=0; par<2; ++par) 
                if(dp[cur][u][par]) 
                    for(int c=1; c<=k; ++c) {
                        int v=ac.ch[u][c];
                        int npar=par ^ ac.tag[v];
                        int prob=trans[s[i]][c];
                        dp[!cur][v][npar] = (dp[!cur][v][npar] + 1ll*dp[cur][u][par]*prob)%MOD;
                    }
        for(int u=0; u<ac.cnt; ++u)
            ans[i] = (ans[i] + dp[!cur][u][1])%MOD;
        ans[i] = 1ll * ans[i] * (1<<t) % MOD; // 乘总数
    }
}
```

**题解一亮点代码（矩阵压缩）**  
```cpp
// 当k较大时压缩状态
void compress_matrix() {
    int sum[K]={0};
    for(int i=1; i<=k; ++i) 
        for(int j=2; j<=k; ++j) // 合并非1字符
            sum[i] = (sum[i]+base[i][j])%MOD;
    base[1][2]=1; // 新状态2代表非1字符
    for(int i=2; i<=k; ++i) 
        base[i][2]=1;
}
```

---

#### 5. 算法可视化：像素动画演示  
**主题**：`基因迷宫探险`（8-bit像素风）  
**核心演示流程**：  
1. **场景构建**：  
   - 16×16像素网格，每个AC节点显示为不同颜色方块（根节点=绿色城堡）  
   - 细菌显示为像素小人，分裂时播放"嘟"音效+分身动画  

2. **突变过程**：  
   ```plaintext
   第1分钟：[细菌A] → 突变选择 → {路径1: 概率50% → 细菌A1, 路径2: 概率50% → 细菌A2}
   ```  
   - 用彩色光束连接节点，光束颜色深度表示概率大小  

3. **目标检测**：  
   - 当细菌进入带tag节点：触发红光闪烁 + "叮！"音效  
   - 奇偶计数器（屏幕顶部）红蓝切换  

4. **控制面板**：  
   - 速度滑块：调节分裂动画速度（0.5x~4x）  
   - 上帝视角：同时显示所有细菌路径（半透明分身）  

**技术实现**：  
```javascript
// 伪代码：关键帧绘制
function drawFrame() {
  drawGrid(); // 绘制AC自动机网格
  for(const bac of bacteria) {
    drawBac(bac.position, bac.color); 
    if(bac.isSplitting) {
      playSound('split'); 
      drawLightning(bac, bac.nextPositions); // 绘制突变路径
    }
    if(bac.hitTarget) {
      playSound('ding');
      drawExplosion(bac.position); 
    }
  }
  drawParityCounter(); // 奇偶计数器
}
```

---

#### 6. 拓展练习与相似问题
1. **洛谷 P5357** [AC自动机模板]  
   → 巩固AC自动机基础操作  
2. **洛谷 P3758** [可乐]  
   → 矩阵快速幂优化图转移  
3. **洛谷 P2414** [阿狸的打字机]  
   → AC自动机与Fail树结合  

---

#### 7. 学习心得  
> **调试经验（老莽莽穿一切）**：  
> “在构建Fail指针时，未及时传递tag导致奇偶性错误——建议用小数据手工模拟Fail链”  
>   
> **Kay总结**：AC自动机的tag传递需满足**结合律**，类似前缀异或和。推荐用链式数据验证：  
> ```python
> 测试用例： 
>   目标数组 = [1,1], [2]  
>   基因序列 = [1,1,2]  
>   验证节点5的tag应为 1([1,1])⊕1([2]) = 0  
> ```

---
处理用时：198.70秒
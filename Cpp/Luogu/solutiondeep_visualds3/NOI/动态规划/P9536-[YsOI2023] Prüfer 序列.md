# 题目信息

# [YsOI2023] Prüfer 序列

## 题目背景

Ysuperman 模板测试的计数题。

众所周知，Prüfer 序列几乎没有在正赛中出现过，所以它需要出现在洛谷月赛中。

## 题目描述

众所周知，一棵 $n$ 个点的有标号无根树与他的 Prüfer 序列一一对应。如果你不知道 Prüfer 序列指的是什么，可以参考下面提示说明中对 Prüfer 序列的解释。

现在给你一个长度为 $m$ 的正整数序列 $a$，其中 $a_i\in[1,n]$。等概率随机选择这个序列的一个长度为 $n-2$ 的子序列（只要选择下标不同就认为两个子序列不同）作为 Prüfer 序列构造得到一棵树 $T$，对于所有 $1\le i<n$，你需要求出 $\mathrm{dist}(i,n)$ 的期望（$\mathrm{dist}(u,v)$ 定义为 $u,v$ 两点简单路径的边数）。

答案对 $10^9+7$ 取模。

## 说明/提示

#### 对 Prüfer 序列的解释

对于一棵给定的无根有标号树，Prüfer 序列的构建过程如下：每次选择一个编号最小的叶结点并删掉它，然后在序列中记录下它连接到的那个结点，重复 $n-2$ 次后就只剩下两个结点，此时记录下来的那个序列就是这棵无根有标号树的 Prüfer 序列。

我们可以证明，一棵结点数量大于 $1$ 的无根有标号树和一个 Prüfer 序列是一一对应的，并且任意一个长度为 $n-2$ 每个数取 $[1,n]$ 范围内的整数的 Prüfer 序列都有唯一对应它的树，所以同样的，我们也可以根据一个 Prüfer 序列还原出一棵树。

有关 Prüfer 序列更加详细的内容，你可以参考 [OI wiki 上关于 Prüfer 序列的描述](https://oi-wiki.org/graph/prufer/)。

#### 样例 1 解释

共有三种等可能选择的子序列：$2,4$，$2,3$，$4,3$。

1. $2,4$ 对应的树为一条链 $1-2-4-3$，其中 $1,2,3$ 与 $4$ 的距离分别为 $2,1,1$。
2. $2,3$ 对应的树为一条链 $1-2-3-4$，其中 $1,2,3$ 与 $4$ 的距离分别为 $3,2,1$。
3. $4,3$ 对应的树为一条链 $1-4-3-2$，其中 $1,2,3$ 与 $4$ 的距离分别为 $1,2,1$。

所以 $\mathrm{dist}(1,4)$ 期望为 $(2+3+1)/3=2$，$\mathrm{dist}(2,4)$ 期望为 $(1+2+2)/3=5/3\equiv 666666673\pmod{10^9+7}$，$\mathrm{dist}(3,4)$ 期望为 $(1+1+1)/3=1$。

#### 样例 2 解释

仅有一种可能的子序列 $4,6,5,2$，对应的树为一条链 $1-4-5-2-6-3$，$1,2,3,4,5$ 与 $6$ 的距离依次为 $4,1,1,3,2$，即为答案。

#### 数据范围

本题共 $20$ 个测试点：

|测试点编号|$n$|$m$|
|:-:|:-:|:-:|
|$1$|$=4$|$=6$|
|$2$|$=8$|$=15$|
|$3$|$=10$|$=20$|
|$4$|$=10$|$=50$|
|$5$|$=10$|$=200$|
|$6$|$=10$|$=1000$|
|$7$|$=10$|$=1750$|
|$8$|$=10$|$=2500$|
|$9$|$=11$|$=500$|
|$10$|$=11$|$=1000$|
|$11$|$=12$|$=250$|
|$12$|$=12$|$=375$|
|$13$|$=12$|$=400$|
|$14$|$=13$|$=80$|
|$15$|$=13$|$=120$|
|$16$|$=13$|$=160$|
|$17$|$=13$|$=200$|
|$18$|$=14$|$=60$|
|$19$|$=14$|$=90$|
|$20$|$=15$|$=40$|

另外，对于所有数据，保证 $1\le a_i\le n$。

**请注意，前 $19$ 个测试点空间限制为 $512\rm{MB}$，最后一个点空间限制为 $150\rm{MB}$。**

## 样例 #1

### 输入

```
4 3
2 4 3
```

### 输出

```
2 666666673 1```

## 样例 #2

### 输入

```
6 4
4 6 5 2```

### 输出

```
4 1 1 3 2```

## 样例 #3

### 输入

```
10 12
6 9 2 10 1 5 5 9 10 7 8 3
```

### 输出

```
585858594 60606064 8080810 834343444 638383846 785858595 913131322 595959602 286868692```

# AI分析结果


### 💡 Kay的C++算法解析：[YsOI2023] Prüfer 序列 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`动态规划` + `状态压缩` + `概率期望`

🗣️ **初步分析**：
> 这道题的核心是理解Prüfer序列与树的对应关系，并计算随机子序列对应树中节点到根节点n的期望距离。解题关键在于：
> - **动态规划**：像搭积木一样逐步构建状态（当前可删除节点集合、已删除节点集合）
> - **状态压缩**：用二进制表示节点集合（如0010表示节点2存在）
> - **概率期望**：计算所有可能子序列的距离平均值
> 
> **核心难点**是如何高效表示树构建过程中的状态。优质题解通过三个关键优化：
> 1. 发现可删节点集(S)总是全集(L=S∪T)的后缀+至多一个散点
> 2. 只关心目标节点j是否在S中（用01状态代替具体节点）
> 3. 距离计算只在删除目标节点时更新
>
> **可视化设计**：采用8位像素风格展示Prüfer序列构建树的过程：
> - 用不同颜色像素块表示：未处理节点（灰色）、可删节点（绿色）、已删节点（红色）
> - 当前操作节点高亮闪烁，删除节点时播放"咔嚓"音效
> - 右侧面板实时显示状态压缩值（如"1010"）和距离期望值

---

#### 2. 精选优质题解参考
**题解一（作者：xiaolilsq）**
* **点评**：思路清晰度极佳，从朴素DP到优化层层递进。核心贡献在于将状态空间从O(3ⁿ)优化到O(2ⁿn²m)，通过两个关键观察：1) S总是L的后缀+至多一个点 2) 只需记录目标节点是否在S中。代码规范性稍弱但算法思想深刻，对状态转移的解释尤其精辟。

**题解二（作者：Purslane）**
* **点评**：提供完整代码框架和状态设计细节。亮点在于巧妙处理距离更新：当删除目标节点j时，其距离=父节点距离+1。实践价值突出，虽然最终优化未完全实现，但状态转移方程的设计极具启发性（如dp1存储方案数，dp2存储距离和）。

---

#### 3. 核心难点辨析与解题策略
1. **状态空间爆炸**
   * **分析**：直接存储S和T集合需O(3ⁿ)空间。优质解法发现S总是L的特定子集，通过二进制编码L和S的特征后缀，将状态降至O(2ⁿn²)
   * 💡 **学习笔记**：观察状态转移的特殊性质是优化DP的关键

2. **距离动态更新**
   * **分析**：当删除节点j时，dist(j,n)=dist(aᵢ,n)+1。题解用dp2[j]累加此值，其他节点直接继承父节点距离
   * 💡 **学习笔记**：在树相关DP中，利用父子关系递推距离

3. **概率期望整合**
   * **分析**：最终答案=距离总和/子序列数。题解用dp1累加方案数，用逆元处理除法取模
   * 💡 **学习笔记**：模数下的除法需转换为乘法逆元

### ✨ 解题技巧总结
- **状态压缩技巧**：用二进制位表示节点存在性（如`1<<(j-1)`）
- **滚动数组优化**：dp[i]只依赖dp[i+1]，用`dp[now]`和`dp[pre]`交替计算
- **逆元预处理**：`qpow(C[m-1][n-2], MOD-2)`快速计算分母逆元
- **边界处理**：序列末尾添加虚拟节点n简化终止状态

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=16, MAXM=2505, MOD=1e9+7;

int n,m,a[MAXM],f[1<<MAXN][MAXN],g[1<<MAXN][MAXN];
int invC; // 子序列总数的逆元

int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++) cin>>a[i];
    
    // 初始化：所有节点未处理(L=全集), 无目标节点在S中
    f[(1<<n)-1][0]=1; 
    
    for(int i=m;i>=1;i--){ // 倒序处理序列
        for(int L=0;L<(1<<n);L++){ // 状态压缩：L=S∪T
            for(int j=1;j<=n;j++){ // 目标节点j
                if(!(L&(1<<(j-1)))) continue; // j必须在L中
                int newL = L^(1<<(j-1)); // 删除j后的L
                
                // 情况1：选择a[i]作为父节点
                if(a[i]!=n){
                    f[newL][j]=(f[newL][j]+f[L][0])%MOD;
                    g[newL][j]=(g[newL][j]+g[L][0]+f[L][0])%MOD;
                }
                
                // 情况2：不选a[i]（j不在当前操作点）
                f[newL][0]=(f[newL][0]+f[L][j])%MOD;
                g[newL][0]=(g[newL][0]+g[L][j])%MOD;
            }
        }
    }
    // 计算最终答案（略）
}
```
**代码解读概要**：倒序DP处理序列，f[L][j]记录方案数，g[L][j]记录距离和。关键转移：
1. 当目标节点j被删除时：距离+=父节点距离+1
2. 其他情况直接继承状态

---

#### 5. 算法可视化：像素动画演示
* **主题**：Prüfer序列构建树 - 像素工厂流水线
* **核心演示**：
  ```mermaid
  graph LR
    A[输入序列] --> B[8位像素网格]
    B --> C[状态面板：L=1011, j=2]
    C --> D[操作：删除节点2]
    D --> E[连接2→4]
    E --> F[距离更新：g+=父距离+1]
  ```
* **交互设计**：
  1. **像素网格**：15×15网格，节点用不同颜色方块表示
     - 绿色：当前可删节点(S)
     - 红色：已删节点(T)
     - 闪烁黄色：当前操作节点
  2. **控制面板**：
     - 速度滑块：调节单步执行速度
     - 状态显示器：实时显示二进制压缩状态（如"L:1101"）
     - 距离追踪器：显示当前dist(j,n)期望值
  3. **音效系统**：
     - 删除节点：8位"碎裂"音效
     - 距离更新：上升琶音
     - 错误操作：低沉蜂鸣
  4. **教学模式**：
     - 点击任意节点查看其状态解释
     - "AI演示"自动展示完整建树过程

---

#### 6. 拓展练习与相似问题思考
* **技巧迁移**：
  1. 状态压缩DP：解决子集相关计数问题
  2. 树形结构期望：处理随机生成的图结构问题
  3. Prüfer序列应用：树计数、生成树编码

* **推荐练习**：
  1. **洛谷 P6177** - 树统计
     * 理由：强化树DP和状态压缩技巧
  2. **洛谷 P2606** - 排列计数
     * 理由：类似概率期望+组合数学问题
  3. **洛谷 P4547** - 随机图生成
     * 理由：扩展随机图结构下的期望计算

---

> 通过本指南，希望大家掌握状态压缩DP的优化思路，理解Prüfer序列的奇妙性质。记住：好的算法设计=深刻问题洞察+巧妙状态优化！🚀

---
处理用时：102.37秒
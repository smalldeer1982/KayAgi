# 题目信息

# [集训队互测 2023] 茧

## 题目描述

Lily 是一个有趣的女孩子。她经常和 Kaguya 玩一些奇怪的游戏。

今天她们在玩一个名为 nim 的游戏。具体地，nim 游戏的规则如下：

- 有若干排数目已知的棋子，两人轮流从任意一排移除任意正整数枚棋子。
- Lily 先手，无法操作者负，即移除最后一枚棋子者获胜。

因为其最优策略非常简单，所以几局过后，她们就开始感到无趣了。于是，她们在原有规则的基础上增加了一条规则：

- 在一排 $x$ 枚棋子中可以移除 $y$ 枚，当且仅当 $y^k \le x$。

这下游戏变得有趣了。不过，由于策略比较复杂，Lily 在计算的时候常常感到力不从心。

可以证明，这个游戏的任意一个局面都满足：要么 Lily 有必胜策略，要么 Kaguya 有必胜策略。

于是，Lily 想请你编写一个程序来计算某个局面下谁有必胜策略（Lily 总是先手），以便复盘时分析哪次操作失误了。

由于求知欲旺盛的 Lily 可能会对局面进行比较细致的分析，所以你需要回答她的多次询问。

由于所有局面都是复盘同一局游戏时衍生出来的，所以所有询问的参数 $k$ 都相同。

**本题询问的局面形式比较特殊，详见输入格式。**

## 说明/提示

样例三、四、五见下发文件。

对于所有测试数据保证：$1 \le k \le 5$，$1 \le n, \sum n \le 10^5$，$1 \le a_i \lt 2^{60}$。

每个子任务的具体限制见下表：

| 子任务编号 | $n$                        | $k$             | $a_i$          | 特殊性质 | 分值 |
| ---------- | -------------------------- | --------------- | -------------- | -------- | ---- |
| 1          | $\sum n \le 10^5$          | $k = 1$         | $a_i < 2^{60}$ |          | $5$  |
| 2          | $\sum n \le 10^5$          | $2 \le k \le 5$ | $a_i < 2^{16}$ |          | $5$  |
| 3          | $\sum n \le 10^5$          | $2 \le k \le 5$ | $a_i < 2^{22}$ |          | $10$ |
| 4          | $\sum n \le 10^3$，$n = 2$ | $2 \le k \le 3$ | $a_i < 2^{32}$ | A        | $10$ |
| 5          | $\sum n \le 10^3$          | $2 \le k \le 5$ | $a_i < 2^{32}$ | A        | $10$ |
| 6          | $\sum n \le 10^5$          | $k = 2$         | $a_i < 2^{60}$ | A        | $10$ |
| 7          | $\sum n \le 10^5$          | $k = 3$         | $a_i < 2^{60}$ | A        | $10$ |
| 8          | $\sum n \le 10^3$          | $k = 2$         | $a_i < 2^{32}$ |          | $10$ |
| 9          | $\sum n \le 10^3$          | $k = 3$         | $a_i < 2^{32}$ |          | $10$ |
| 10         | $\sum n \le 10^5$          | $1 \le k \le 5$ | $a_i < 2^{60}$ |          | $20$ |

特殊性质 A：保证 $2 \mid n$，且 $a_{2k - 1} = a_{2k} - 1 \pod{1 \le k \le \frac n 2}$。

提示：如果你得到了预期之外的 TLE，你或许可以尝试优化你的时间复杂度。

> 微调了题面里的几处用词（）
>
> 原题面请以 QOJ 为准（）

## 样例 #1

### 输入

```
3 1
2
1 5
3
1 2 3
1
3
```

### 输出

```
Kaguya
Lily
Kaguya
```

## 样例 #2

### 输入

```
4 2
2
1 2
2
1 3
3
5 6 7
1
3
```

### 输出

```
Kaguya
Lily
Kaguya
Kaguya
```

# AI分析结果

# 💡 Kay的C++算法解析：[集训队互测 2023] 茧 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：博弈论（SG函数）、数学推导（递归/异或性质）、编程技巧应用（大数值快速计算）


🗣️ **初步分析**：  
解决这道题的关键，是理解**Nim游戏的SG定理**——每个游戏状态的“胜负密码”（SG函数）异或后，若结果非零则先手（Lily）必胜，否则后手（Kaguya）必胜。而本题的特殊规则（只能移除满足`y^k ≤ x`的棋子），需要我们**快速计算SG函数的前缀异或和**（因为`a_i`能达到`2^60`，暴力计算完全不可行）。  

题解的核心思路是：  
1. **找SG函数的循环规律**：通过数学归纳发现，SG函数在`r^k ≤ x < (r+1)^k`区间内有长度为`r+1`的循环节，避免逐点计算；  
2. **快速计算前缀异或**：用`h0`（普通异或和）、`h1`（递归处理的异或和）等辅助函数，结合循环节的奇偶性，快速得到前缀异或结果；  
3. **大数值分解**：对于每个`a_i`，先找到最大的`r`使得`r^k ≤ a_i`，再分两段计算异或和（前`r-1`段的总和 + 当前段的剩余部分）。  

**核心难点**：如何将SG函数的数学规律转化为可代码实现的递归式，以及处理`2^60`级别的大数值计算。题解的解决方案是：用`pow`函数快速找`r`（再调整边界），用递归的`s`函数处理循环节内的异或，用`sigma`函数整合前`r-1`段的结果。  

**可视化设计思路**：  
我会设计一个**像素博弈者**的复古游戏动画，用8位像素风展示SG函数的计算过程：  
- 左侧屏幕显示`x`的数值分解（比如`x=5`，`k=2`时，`r=2`，因为`2²=4≤5<3²=9`），用不同颜色的像素块标记`r`、`r^k`、`x-r^k`；  
- 右侧动态展示`sigma(r-1)`和`s(r, x-r^k)`的计算：`r`从1开始“增长”（像素块向上跳动），找到正确`r`时闪烁并伴随“叮”的音效；`s`函数的递归过程用“像素箭头”指向当前处理的变量（如`d`的循环节）；  
- 控制面板有“单步”“自动播放”按钮，速度滑块，以及“重置”功能，方便观察每一步的变化。


## 2. 精选优质题解参考

**题解一：来源：max67**  
* **点评**：这份题解从SG函数的定义出发，通过数学归纳法一步步推导出循环规律，逻辑链极其清晰。它的最大亮点是**将复杂的数学规律转化为可代码实现的递归式**——比如`h0`利用异或的4循环性质（`4x`到`4x+3`的异或和为0）快速计算，`h1`用递归拆分奇偶项减少计算量，`s`函数处理循环节内的异或时，还利用了异或的“对称性”（`d>r`时直接异或`h0(r)`再递归）。代码风格非常规范，变量名（如`sigma`、`solve`）语义明确，甚至处理了`pow`函数的精度问题（通过调整`r`的边界确保`r^k ≤ x`）。对于`2^60`的大数值，这份代码能在`O(log x)`的时间内完成计算，实践价值极高——完全可以直接用于竞赛中的同类问题。


## 3. 核心难点辨析与解题策略

### 核心难点1：理解SG函数与Nim游戏的关联  
**分析**：SG函数是每个游戏状态的“胜负标签”——`SG(x)=mex{SG(x-y) | y^k ≤x}`（`mex`表示未出现的最小非负整数）。Nim游戏的胜负由所有堆的SG函数异或结果决定：非零则先手胜，零则后手胜。  
**解决策略**：先回忆基础Nim游戏的规则，再通过小例子（如`k=1`时，`SG(x)=x`，异或和就是普通Nim和）验证，逐步理解“SG函数是状态的胜负密码”这一概念。


### 核心难点2：推导SG函数的循环规律  
**分析**：直接计算`SG(x)`对于`x=2^60`完全不可行，必须找规律。题解通过归纳发现，`SG(r^k + d)`（`0≤d<(r+1)^k - r^k`）有长度为`r+1`的循环节（即`SG(r^k + d) = SG(r^k + d - (r+1))`）。  
**解决策略**：尝试手动计算小`r`和`k`的情况（如`k=2`，`r=1`时，`1²=1≤x<4`，`SG(1)=1`，`SG(2)=0`，`SG(3)=1`，循环节长度为2），观察规律后再用数学归纳法证明。


### 核心难点3：处理大数值的快速计算  
**分析**：`a_i`能达到`2^60`，无法逐点计算`SG`或前缀异或。题解的关键是**将大数值分解为`r`段**（每段对应`r^k`到`(r+1)^k`），再用辅助函数快速计算每段的异或和。  
**解决策略**：用`pow(x, 1.0/k)`快速找到`r`的近似值，再通过`power(r, k)`调整边界（确保`r^k ≤x <(r+1)^k`）；用`sigma(r-1)`计算前`r-1`段的异或和，用`s(r, x-r^k)`计算当前段的剩余部分。


### ✨ 解题技巧总结  
- **数学规律优先**：遇到大数值问题，先手动计算小例子找规律，再尝试证明（比如异或的循环性质、SG函数的循环节）；  
- **递归简化计算**：将重复的计算（如`h1`的奇偶拆分）用递归实现，减少代码量；  
- **边界处理要严谨**：用`pow`找`r`时，必须调整边界（比如`power(r, k)`可能超过`x`，需要`r--`），避免精度错误。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：此代码来自max67的题解，是博弈论中“大数值SG函数计算”的典型实现，逻辑完整且高效。  
* **完整核心代码**：  
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;

int k;
int power(int x, int y) { int t=1; for(; y; y>>=1, x*=x) if(y&1) t*=x; return t; }
int h0(int x) { int res=0; for(int i=0; i<=x%4; i++) res^=x-i; return res; }
int h1(int x) { if(x<=1) return 0; return h1((x-1)/2) ^ h0(x/2); }

int s(int r, int d) {
    if(d>2*r+2) d%=2*r+2;
    if(d>r) return h0(r) ^ s(r, d-r-1);
    if(k%2==0) return h0(r) ^ h0(r - (d/2) -1) ^ h1(r-1) ^ h1(r - (d+1)/2 -1);
    if(d==0) return r;
    return r ^ h0(d-1);
}

int sigma(int x) {
    if(!x) return 0;
    if(k%2==0) return h1(x);
    return h0(x) ^ (1<=x%8 && x%8<=4 ? 1 : 0);
}

int solve(int x) {
    if(k==1) return h0(x);
    int r=pow(x, 1.0/k);
    while(power(r, k)>x) r--; while(power(r+1, k)<=x) r++;
    return sigma(r-1) ^ s(r, x - power(r, k));
}

signed main() {
    int _; scanf("%lld%lld", &_, &k);
    while(_--) {
        int t, res=0, x; scanf("%lld", &t);
        while(t--) { scanf("%lld", &x); res^=solve(x); }
        puts(res?"Lily":"Kaguya");
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **辅助函数**：`power`计算`x^y`，`h0`利用异或的4循环性质快速计算`0~x`的异或和，`h1`递归拆分奇偶项计算；  
  2. **核心函数**：`s`处理循环节内的异或和（根据`k`的奇偶性选择不同逻辑），`sigma`计算前`r-1`段的异或总和，`solve`分解`x`并计算最终结果；  
  3. **主函数**：处理多组查询，读取每个`a_i`的`solve`结果并异或，输出胜负。


### 题解一核心代码片段赏析  
**题解一：来源：max67**  
* **亮点**：用递归和异或的对称性，将循环节内的计算复杂度从`O(r)`降到`O(log r)`。  
* **核心代码片段**：  
```cpp
int s(int r, int d) {
    if(d>2*r+2) d%=2*r+2;  // 利用异或的2*(r+1)循环（异或两次相同值抵消）
    if(d>r) return h0(r) ^ s(r, d-r-1);  // d超过r时，异或h0(r)再递归
    if(k%2==0) return h0(r) ^ h0(r - (d/2) -1) ^ h1(r-1) ^ h1(r - (d+1)/2 -1);
    if(d==0) return r;
    return r ^ h0(d-1);
}
```
* **代码解读**：  
  - 第一行：异或的性质是“异或两次相同值等于没异或”，所以`d`超过`2*(r+1)`时直接取模（循环节的两倍）；  
  - 第二行：`d>r`时，利用异或的对称性（`s(r, d) = h0(r) ^ s(r, d-r-1)`），减少递归深度；  
  - 第三行：当`k`为偶数时，用`h0`和`h1`拆分`d`的奇偶项，快速计算异或和；  
  - 最后两行：`k`为奇数时，SG函数的规律更简单（`d=0`时为`r`，否则为`r ^ h0(d-1)`）。  
* **学习笔记**：异或的“对称性”和“循环性”是处理大数值异或的关键——比如`d>r`时，我们不需要重新计算，只需异或`h0(r)`再递归，这大大减少了计算量。


## 4. 算法可视化：像素动画演示方案（详细设计）

### 动画主题：像素博弈者的“SG解码之旅”  
**设计思路**：用8位FC游戏的风格，将SG函数的计算转化为“探索数值迷宫”的游戏，通过可视化让抽象的数学规律变得直观。


### 动画帧步骤与交互设计  
1. **场景初始化（8位像素风）**：  
   - 屏幕分为三部分：左侧是“数值分解区”（显示`x`、`k`、`r`、`r^k`、`x-r^k`），中间是“计算流程区”（动态展示`sigma`和`s`函数的递归），右侧是“控制面板”；  
   - 数值分解区用不同颜色的像素块标记：`x`是黄色，`r`是蓝色，`r^k`是绿色，`x-r^k`是红色；  
   - 控制面板有：`开始/暂停`（红色按钮）、`单步`（蓝色按钮）、`重置`（灰色按钮）、速度滑块（从“慢”到“快”），以及当前步骤的文字提示（如“正在找r...”）。


2. **算法启动与数据初始化**：  
   - 输入`x=5`、`k=2`后，屏幕中央弹出“开始解码”的像素文字，伴随8位风格的“滴”声；  
   - 数值分解区显示`x=5`（黄色），`k=2`（紫色），`r`从1开始“增长”（蓝色像素块向上跳动），每跳一次计算`r^k`（绿色像素块显示`1²=1`、`2²=4`、`3²=9`）。


3. **核心算法步骤演示**：  
   - **找r的过程**：当`r=2`时，`2²=4≤5`，而`3²=9>5`，此时`r`的像素块闪烁3次，伴随“叮”的音效，数值分解区显示`r=2`（蓝色）、`r^k=4`（绿色）、`x-r^k=1`（红色）；  
   - **计算sigma(r-1)**：`r-1=1`，`sigma(1)`根据`k=2`（偶数）调用`h1(1)`，计算过程用“像素箭头”指向`h1`函数，显示`h1(1)=0`；  
   - **计算s(r, x-r^k)**：`r=2`，`d=1`，`k=2`（偶数），调用`h0(2) ^ h0(2-0-1) ^ h1(1) ^ h1(2-1-1)`，每一步的计算结果用“像素气泡”显示（如`h0(2)=3`，`h0(1)=1`，`h1(1)=0`，`h1(0)=0`），最终结果`3^1^0^0=2`；  
   - **异或结果**：`sigma(1)=0` ^ `s(2,1)=2` = `2`，屏幕右侧显示“当前结果：2”，伴随“嗒”的音效。


4. **交互与游戏化元素**：  
   - **单步模式**：点击“单步”按钮，动画会停在每一步（如找`r`、计算`sigma`、计算`s`），并弹出文字提示（如“现在计算s函数的d=1，k是偶数哦～”）；  
   - **自动播放**：点击“开始”按钮，动画会以设定的速度自动运行，每完成一个步骤（如找到`r`、计算完`sigma`），会有“小关卡完成”的提示（如像素星星闪烁）；  
   - **音效设计**：找`r`成功时“叮”，计算`s`函数时“嗒”，结果非零（Lily胜）时播放上扬的“胜利音”，结果为零（Kaguya胜）时播放短促的“失败音”；  
   - **背景音乐**：循环播放8位风格的轻松BGM（类似《超级马里奥》的背景音乐）。


### 技术实现考量  
- 用HTML5 Canvas绘制像素块，用JavaScript实现递归动画（如`r`的增长、`s`函数的递归步骤）；  
- 音效用Web Audio API生成8位波形（如正弦波、方波），关键操作时触发；  
- 所有代码打包成一个HTML文件（包含CSS和JavaScript），无需额外依赖，直接用浏览器打开即可运行。


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
本题的核心技巧（**找数学规律简化计算**、**利用异或的循环性质**、**递归处理大数值**）可以迁移到以下场景：  
1. **变种Nim游戏**：如移除棋子的规则改为“`y`是质数”“`y`是`x`的因数”，只需重新推导SG函数的规律；  
2. **大数值异或问题**：如计算`0~x`的异或和（本题的`h0`函数就是典型应用）；  
3. **递归优化**：如处理有循环节的函数计算（如斐波那契数列的快速幂优化）。


### 推荐练习（洛谷）  
1. **洛谷 P2197 - Nim游戏**：基础Nim游戏，巩固SG定理的应用（每个堆的SG函数是堆的大小，异或和决定胜负）；  
2. **洛谷 P2575 - 高手过招**：变种Nim游戏，SG函数的规则更复杂（每次可以取一行的连续若干棋子），需要推导SG函数的规律；  
3. **洛谷 P3150 - pb的游戏（续）**：变种Nim游戏，规则是“每次可以取`1~k`个棋子”，SG函数的规律是`SG(x)=x mod (k+1)`，练习快速计算SG和；  
4. **洛谷 P4136 - 谁能赢呢？**：博弈论中的“取石子”游戏，需要找必胜态的规律，类似本题的“找循环节”思路。


## 7. 学习心得与经验分享

**参考经验（来自max67）**：“赛场上还是有不少巨佬过这题的，我觉得他们可能是能打表出`σ(r)`的规律（形式简洁），对于`2∤k`的情况，打表发现`g(r,d)`呈现`log`段公差为1的等差数列，再暴力计算。”  
**点评**：这位作者的经验非常实用——当遇到复杂的数学规律时，**打表找小例子的规律**是最快的突破口。比如本题的`σ(r)`函数，若直接推导可能需要很长时间，但打表后会发现`k`为奇数时，`σ(r)`的规律是`h0(r) ^ (x%8是否在1~4)`，这比推导更直接。此外，**暴力计算小例子**也是验证规律正确性的关键——比如`k=2`时，手动计算`r=1`、`r=2`的`σ(r)`，再和代码结果对比，能快速发现错误。


## 结语  
本次关于“茧”的C++解题分析就到这里。这道题的难点在于将抽象的数学规律转化为可代码实现的递归式，但只要掌握了“找规律→验证→递归优化”的思路，就能解决这类大数值博弈问题。记住：**数学规律是解决大数值问题的钥匙，而递归是将规律转化为代码的桥梁**。下次我们再一起探索更有趣的博弈论问题！💪

---
处理用时：137.14秒
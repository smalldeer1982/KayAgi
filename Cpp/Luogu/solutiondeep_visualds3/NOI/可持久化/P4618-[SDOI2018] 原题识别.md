# 题目信息

# [SDOI2018] 原题识别

## 题目背景

 - Input file: old.in
 - Output file: old.out
 - Time limit: 10 seconds
 - Memory limit: 512 megabytes

## 题目描述

“人肉题库” 小 $Q$ 刷题非常勤奋，题量破万。每当有人拿题目请教他时，小 $Q$ 总能在 $1$ 秒内报出这
是哪个 $OJ$ 的哪道题。因此，小 $Q$ 是被当作 “原题搜索机” 一样的存在。

有一天，小 $Q$ 来到了一棵 $n$ 个节点的有根树下，这棵树的根节点为 $1$ 号点，且每个节点都印着一道
题目。凭借超大的题量，小 $Q$ 迅速识别出了每道题的来源，并发现有些题目被搬运了好多次。他把每个
节点的题目都做了一个分类，第 $i$ 个节点的题目对应的题目种类为 $a_i$，当且仅当 $a_i=a_j$ 时，$i$ 点和 $j$ 点的题目来源是相同的。

同一道题目做多次除了增加 $AC$ 数以外，对本身的水平没有任何提高。为了调查这棵树的题目质量，
小 $Q$ 会不断提出以下两种询问共 $m$ 次：

- $1$ $x$ $y$：如果将 $x$ 点到 $y$ 点的最短路径上的所有点 (包括 $x$ 和 $y$) 对应的题目都做一遍，那么一共可
以做到多少道本质不同的题目？

- $2$ $A$ $B$：如果在 $A$ 点到根的最短路径上 (包括 $A$ 点和根) 等概率随机选择一个点 $x$，在 $B$ 点到根的最短路径上 (包括 $B$ 点和根) 等概率随机选择一个点 $y$，那么询问 $1$ $x$ $y$ 的答案期望是多少？

定义 $cnt_x$ 表示 $x$ 点到根最短路径上的节点个数，因为小 $Q$ 不喜欢分数，而且第 $2$ 类询问的答案一
定可以表示成$\frac{ans}{{cnt_A}*{cnt_B}}$的形式，你只需要告诉他 $ans$ 的值就可以了。

识别这些题目消耗了小 $Q$ 太大的精力，他没有办法自己去计算这些简单的询问的答案。请写一个程序回答小 $Q$ 的所有 $m$ 个问题。

## 说明/提示

 -$1 ≤ T ≤ 3,2 ≤ p ≤ n ≤ 100000,1 ≤ m ≤ 200000$
 -$ 10000 ≤ SA, SB, SC ≤ 1000000,1 ≤ x, y, A, B ≤ n$

子任务 $1$（$30$ 分）：只含第 $1$ 类询问。

子任务 $2$（$30$ 分）：满足 $p = n$。

子任务 $3$（$40$ 分）：没有任何附加的限制。

## 样例 #1

### 输入

```
2
5 3 10000 12345 54321
3
1 2 3
2 1 3
1 3 2
10 6 23456 77777 55555
5
1 1 10
2 3 5
2 7 5
2 5 4
1 8 6```

### 输出

```
1
5
1
4
34
61
45
3```

# AI分析结果


### 题目解读与核心算法识别
✨ **本题主要考察**：`树上路径查询与期望计算`（结合主席树、随机数据特性）

🗣️ **初步分析**：
> 解决[SDOI2018]原题识别这道题，关键在于处理树上路径的颜色查询和期望计算。核心思想是将树拆分为长链（主链）和短链（随机子树），利用数据随机性（树深度O(log n)，颜色出现次数O(1)）优化复杂度。
> 
> - **题解思路**：对操作1（路径颜色数查询），用主席树处理长链部分，短链部分暴力枚举；对操作2（期望计算），将期望转化为求和问题，分直链和弯链情况讨论，分别用主席树和短链暴力处理。
> - **核心难点**：短链暴力时需高效判断颜色是否在长链中出现（可持久化数组记录颜色最后出现位置）。
> - **可视化设计**：采用8位像素风格展示树结构（主链为横轴，子树为纵轴）。操作1高亮路径并播放“叮”音效标记新颜色；操作2用粒子动画模拟随机选点过程，实时显示路径颜色统计结果。关键变量（pre_i、LCA）用闪烁像素箭头标记。

---

### 精选优质题解参考
**题解一（shadowice1984）**
* **点评**：思路最完整清晰，充分利用随机数据特性。主席树维护长链的pre_i信息，可持久化数组记录颜色最后位置。操作2的贡献分情况推导严谨（直链套用序列公式，弯链分长链/短链处理）。代码虽复杂但边界处理严谨，可直接用于竞赛。亮点：短链暴力时通过跳pre_i（期望O(1)步）优化查询效率。

**题解二（Leasier）**
* **点评**：代码更简洁，延续shadowice思路但优化短链处理。核心改进：用vector存储同色点位置，实现O(1)查找颜色在长链的首次出现。操作2的贡献公式用前缀和简化计算，提升效率。实践价值高，适合掌握基础后进阶学习。

---

### 核心难点辨析与解题策略
1. **路径拆分与LCA定位**
   * **分析**：树由长链+随机子树构成，任意路径可拆为长链部分（O(1)深度）和短链部分（O(log n)深度）。用DFS序快速定位LCA，长链部分用主席树查询，短链暴力枚举。
   * 💡 **学习笔记**：路径拆解是处理树上问题的核心策略。

2. **短链暴力高效性保证**
   * **分析**：利用颜色随机特性（同色点少），短链枚举时用可持久化数组查询颜色最后出现位置，并跳pre_i检查首次出现位置（期望O(1)步）。
   * 💡 **学习笔记**：随机数据下暴力复杂度正确，需选择高效数据结构。

3. **期望计算的贡献分拆**
   * **分析**：操作2转化为$\sum f(u,v)$计算。分三种情况：直链（主席树）、弯链长链（主席树+贡献公式）、弯链短链（暴力+同色点位置查询）。
   * 💡 **学习笔记**：复杂问题分情况讨论，化整为零。

### ✨ 解题技巧总结
- **随机特性利用**：树深度、颜色分布均匀时，短链暴力+跳pre_i高效。
- **双数据结构配合**：主席树处理长链pre_i，可持久化数组记录颜色位置。
- **贡献公式拆解**：将$\sum f(u,v)$拆为直链和弯链独立计算，避免重复。

---

### C++核心代码实现赏析
**通用核心实现参考**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+10;
int n,m,p,a[N],fa[N],dep[N],pre[N],top[N];
vector<int> G[N],col_pos[N]; // 树结构与颜色位置

// 可持久化数组（简化版）
struct PersArray {
    vector<int> ver[N];
    void update(int u,int c) { 
        ver[c].push_back(u); 
    }
    int query(int c,int max_dep) { // 查询颜色c在max_dep以下最后出现位置
        auto it=upper_bound(ver[c].begin(),ver[c].end(),max_dep);
        return it==ver[c].begin()?0:*(--it);
    }
} PA;

// 操作1：路径颜色数查询
int query_path(int x,int y) {
    int lca=LCA(x,y), ans=query_long_chain(lca,y); // 长链部分
    for(int u=x;u!=lca;u=fa[u]) // 短链暴力
        if(PA.query(a[u],dep[lca]) < dep[lca]) 
            ans++;
    return ans;
}
```

**题解一核心片段（shadowice1984）**
```cpp
// 操作2期望计算（弯链短链部分）
ll calc_short_chain(int A,int B,int lca) {
    ll res=0;
    for(int u=A;u!=lca;u=fa[u]) {
        int last=PA.query(a[u],dep[B]); // 长链中同色最后位置
        while(dep[pre[last]]>=dep[lca]) last=pre[last]; // 跳pre找首次出现
        res += (dep[u]-dep[lca]+1) * (dep[last]-dep[lca]);
    }
    return res;
}
```
* **代码解读**：
  - `PA.query`：用可持久化数组查颜色最后出现位置
  - `while`循环：从最后位置跳`pre`找到首次出现位置（期望O(1)步）
  - 贡献公式：短链点深度差×长链首次位置深度差
* 💡 **学习笔记**：随机数据下跳pre高效，避免暴力遍历。

---

### 算法可视化：像素动画演示
**主题**：`像素探险家之树形寻宝`（融合复古游戏元素）  
**设计思路**：  
- **树结构**：主链横向8位像素块（红），随机子树纵向延伸（蓝）。路径显示为闪烁黄点。
- **操作1演示**：
  1. 高亮`x→y`路径，遍历长链时主席树节点展开（右侧面板）
  2. 新颜色出现时播放“叮”声，像素块变绿
  3. 短链点闪烁检查：同色则显示红叉，否则绿勾
- **操作2演示**：
  1. `A/B`到根路径显示为光带
  2. 随机选点`x/y`：粒子动画从路径飞出碰撞
  3. 计算碰撞路径颜色数：成功时播放胜利音效
- **控制面板**：
  - 步进/暂停/调速滑块
  - 实时显示`pre_i`、`LCA`深度值
  - 8位背景音乐循环

---

### 拓展练习与相似问题思考
**通用技巧迁移**  
- `主席树+树链拆分`：洛谷P4211（查询路径第k小）
- `随机数据暴力优化`：CodeForces 1175E（随机序列区间覆盖）
- `期望计算转化`：LOJ 2473（树上随机游走期望）

**洛谷推荐**  
1. **P4211 [LNOI2014]LCA**  
   🗣️ 练习主席树维护树链信息，强化路径拆分解题思维  
2. **P3302 [SDOI2013]森林**  
   🗣️ 随机森林背景下主席树动态维护，拓展数据随机性应用  
3. **P5354 [Ynoi2017]由乃打扑克**  
   🗣️ 分块+随机数据优化，提升暴力复杂度分析能力  

---

### 学习心得与经验分享
> **参考经验**：  
> “调试时先验证长链部分，再用小规模短链测试边界。主席树版本管理易错，建议DFS时显式传递上一版本。”  
> 
> **点评**：  
> 长链/短链分离调试是核心技巧。主席树版本控制需注意DFS回溯时还原状态，避免版本污染。短链暴力用时间戳数组清空，避免memset超时。

---

> 本次解析提炼了树上路径查询的核心技巧：随机数据优化+双数据结构配合。掌握分情况讨论贡献的方法，即可应对各类变形问题。下次我们将解析动态树分治！💪

---
处理用时：139.92秒
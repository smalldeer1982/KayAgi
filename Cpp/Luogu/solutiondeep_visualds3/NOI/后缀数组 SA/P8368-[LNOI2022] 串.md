# 题目信息

# [LNOI2022] 串

## 题目描述

为了让你更好地理解题面，给出若干关于字符串的定义：

- 对于一个字符串 $S = s_1 s_2 \cdots s_n$，定义其长度为 $\lvert S \rvert = n$。
- 对于两个字符串 $S = s_1 s_2 \cdots s_n$ 和 $T = t_1 t_2 \cdots t_m$，称 $T$ 为 $S$ 的子串，若 $m = 0$（即 $T$ 为空串）或者 $\exists 1 \le i \le j \le n$，$T = s_i s_{i + 1} \cdots s_j$。若 $m = 0$ 或上述判断条件中 $i$ 可以取到 $1$，则称 $T$ 为 $S$ 的前缀；若 $m = 0$ 或上述判断条件中 $j$ 可以取到 $n$，则称 $T$ 为 $S$ 的后缀。

给定一个英文小写字母构成的字符串 $S$，你需要找到一个尽可能长的字符串序列 $(T_0, T_1, \ldots, T_l)$，满足：

- $T_0$ 是 $S$ 的子串；
- $\forall 1 \le i \le l$，$\lvert T_i \rvert - \lvert T_{i - 1} \rvert = 1$；
- $\forall 1 \le i \le l$，存在 $S$ 的一个长度为 $\lvert T_i \rvert + 1$ 的子串 $S'_i$，使得 $S'_i$ 的长度为 $\lvert T_{i - 1} \rvert$ 的前缀为 $T_{i - 1}$，长度为 $\lvert T_i \rvert$ 的后缀为 $T_i$。

输出这样的字符串序列的长度的最大值（即 $l$ 的最大值）。

## 说明/提示

**【样例解释 \#1】**

下文中使用符号 $\epsilon$ 表示空串。

对于第一组测试数据，可以找到如下字符串序列：$T_0 = \epsilon, T_1 = \texttt{b}, T_2 = \texttt{cd}$，其中 $S'_1 = \texttt{ab}, S'_2 = \texttt{bcd}$。

对于第二组测试数据，可以找到如下字符串序列：$T_0 = \epsilon, T_1 = \texttt{b}, T_2 = \texttt{ab}, T_3 = \texttt{bab}$，其中 $S'_1 = \texttt{ab}, S'_2 = \texttt{bab}, S'_3 = \texttt{abab}$。

对于第三组测试数据，可以找到如下字符串序列：$T_0 = \epsilon$。

**【样例 \#2】**

见附件中的 `string/string2.in` 与 `string/string2.ans`。

该组样例中的字符串长度有一定梯度，你可以利用该组样例对程序进行检查。

**【样例 \#3】**

见附件中的 `string/string3.in` 与 `string/string3.ans`。

该组样例满足特殊性质 A。

**【数据范围】**

设 $\sum |S|$ 表示测试点中所有测试数据的字符串长度和。

对于 $100 \%$ 的测试数据，$T \ge 1$，$1 \le \lvert S \rvert \le 5 \times {10}^5$，$1 \le \sum \lvert S \rvert \le 1.5 \times {10}^6$。

| 测试点编号 | $\lvert S \rvert \le$ | $\sum \lvert S \rvert \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1 \sim 2$ | $30$ | $150$ | 无 |
| $3 \sim 5$ | $200$ | $800$ | 无 |
| $6 \sim 8$ | $1000$ | $3000$ | 无 |
| $9 \sim 11$ | $5 \times {10}^5$ | $1.5 \times {10}^6$ | A |
| $12 \sim 15$ | $6 \times {10}^4$ | $3 \times {10}^5$ | 无 |
| $16 \sim 20$ | $5 \times {10}^5$ | $1.5 \times {10}^6$ | 无 |

特殊性质 A：字符串中的每个字符在小写字母中独立均匀随机生成。

**【提示】**

本题输入输出量较大，请使用较为快速的输入输出方式。

例如，若你的代码使用了 `cin` 和 `cout` 作为输入输出方式，你可以选择在代码的**输入输出重定向语句**（`freopen` 语句、 `fopen` 语句等）**之后**加入以下语句加速输入输出速度。

```cpp
ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
```

**加入该语句后不建议同时使用 `cin, cout` 和其他输入输出方式。**

## 样例 #1

### 输入

```
3
abcd
abab
a
```

### 输出

```
2
3
0
```

# AI分析结果

# 💡 Kay的C++算法解析：[LNOI2022] 串 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：字符串处理（后缀自动机SAM/后缀数组SA）

🗣️ **初步分析**：  
解决这道题的关键，在于理解**字符串的“重复子串”能帮我们“续命”**——就像玩游戏时找到“存档点”，可以反复回到之前的位置继续前进。而**后缀自动机（SAM）**就是我们的“存档点探测器”：它能高效压缩所有子串，把结尾位置相同的子串归为一类（endpos等价类），并快速统计每个子串的出现次数和首次出现位置。  

### 核心思路与难点
题目要求构造最长的字符串序列，**逆向思考**是突破口：  
- 最基础的构造是从空串开始，每次右移左端点1位、右端点2位（比如空串→b→cd），最多能走`n/2`步（下界）。  
- 若某个子串**出现至少两次**，我们可以从它开始“反向跳”（比如从`[c,d]`跳回`[a,b]`），这样能额外多走`r-l+1`步（子串长度），再加上后续的`(n-r)/2`步（右端点剩余的跳跃次数）。  

**核心难点**：  
1. 如何快速找到所有出现至少两次的子串？  
2. 如何计算这些子串的最大贡献？  

**解决方案**：用SAM维护每个子串的`出现次数`（endpos大小）和`首次出现位置`（子串的最左右端点），遍历所有状态计算贡献，最后取最大值与下界比较。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度筛选了以下优质题解，帮大家快速理解核心逻辑：
</eval_intro>

**题解一：作者_slb（赞：11）**  
* **点评**：这份题解的逆向构造思路非常清晰——直接点出“重复子串能续命”的关键，并用SAM完美实现了子串的出现次数和位置统计。代码结构工整，SAM的插入、parent树构建、DFS统计都很规范，尤其是`pos`数组维护了子串的首次出现位置，计算贡献的逻辑（`len[x] + (n - pos[x])/2`）直接对应核心公式。对于刚学SAM的同学，这是一份很好的模板参考。

**题解二：作者ix35（赞：8）**  
* **点评**：题解通过引理一步步推导，证明了“最优解从空串开始”的结论，逻辑严谨。后续用后缀数组（SA）维护最长公共前缀（LCP），同样能找到重复子串的贡献。虽然SA的实现比SAM稍复杂，但引理的推导过程能帮大家更深入理解题目性质。

**题解三：作者wjyppm1403（赞：2）**  
* **点评**：题解用生动的比喻（“前后缀覆盖”）解释了重复子串的作用，SAM的实现简洁，尤其是`mnpos`数组维护子串的最左位置，代码中的`dfs`函数清晰统计了每个状态的出现次数。对于想快速上手的同学，这份代码的注释和结构很友好。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键，在于突破三个“思维关卡”：
</difficulty_intro>

1. **关卡1：理解序列的构造方式——逆向思考**  
   - **难点**：正向构造序列（长度递增）时，“跳转”过程难以跟踪；  
   - **策略**：逆向思考（长度递减），把“续命”转化为“找重复子串”——就像从终点往起点走，遇到重复的路就能多走一段。

2. **关卡2：发现重复子串的“续命”作用**  
   - **难点**：为什么重复子串能延长序列？  
   - **策略**：画个图！比如子串`[l,r]`出现两次，从`[l,r]`反向跳，每次左移1、右移2，当跳到第一次出现的位置时，就能“跳回”第二次出现的位置，继续跳直到空串。

3. **关卡3：用SAM高效维护子串信息**  
   - **难点**：如何快速统计每个子串的出现次数和位置？  
   - **策略**：学习SAM的基础操作：  
     - 插入字符时维护每个状态的`len`（子串长度）和`pos`（首次出现位置）；  
     - 构建parent树，通过DFS统计每个状态的`size`（出现次数）；  
     - 遍历所有状态，计算符合条件的子串贡献。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份通用的SAM实现——综合了多个优质题解的思路，清晰展示了从输入到计算答案的全流程：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码整合了SAM的插入、parent树构建、DFS统计，以及答案计算，是解决本题的标准模板。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 2e6 + 10;
char s[MAXN];
int n, ans;

struct SAM {
    int ch[MAXN][26], len[MAXN], fa[MAXN], pos[MAXN], siz[MAXN];
    int tot, lst;
    vector<int> e[MAXN];

    void init() {
        tot = lst = 1;
        memset(ch[1], 0, sizeof(ch[1]));
        len[1] = fa[1] = pos[1] = siz[1] = 0;
    }

    void insert(int c, int id) {
        int p = lst, cur = ++tot;
        memset(ch[cur], 0, sizeof(ch[cur]));
        len[cur] = len[p] + 1;
        pos[cur] = id;
        siz[cur] = 1;
        lst = cur;
        while (p && !ch[p][c]) {
            ch[p][c] = cur;
            p = fa[p];
        }
        if (!p) fa[cur] = 1;
        else {
            int q = ch[p][c];
            if (len[q] == len[p] + 1) fa[cur] = q;
            else {
                int nq = ++tot;
                memcpy(ch[nq], ch[q], sizeof(ch[q]));
                len[nq] = len[p] + 1;
                fa[nq] = fa[q];
                pos[nq] = n + 1; // 虚节点的pos设为极大值
                while (p && ch[p][c] == q) {
                    ch[p][c] = nq;
                    p = fa[p];
                }
                fa[q] = fa[cur] = nq;
            }
        }
    }

    void build() {
        for (int i = 2; i <= tot; ++i)
            e[fa[i]].push_back(i);
    }

    void dfs(int u) {
        for (int v : e[u]) {
            dfs(v);
            siz[u] += siz[v];
            pos[u] = min(pos[u], pos[v]);
        }
        if (siz[u] > 1) {
            ans = max(ans, len[u] + (n - pos[u]) / 2);
        }
    }
} sam;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    while (T--) {
        cin >> s;
        n = strlen(s);
        sam.init();
        for (int i = 0; i < n; ++i)
            sam.insert(s[i] - 'a', i + 1);
        sam.build();
        ans = n / 2;
        sam.dfs(1);
        cout << ans << endl;
        // 清空SAM（可选，根据题目要求）
        for (int i = 1; i <= sam.tot; ++i)
            sam.e[i].clear();
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **SAM初始化**：`init`函数初始化SAM的根节点（状态1）；  
  2. **插入字符**：`insert`函数逐个插入字符串的字符，维护每个状态的长度、父节点、位置；  
  3. **构建parent树**：`build`函数将每个状态的父节点连接成树；  
  4. **统计信息**：`dfs`函数遍历parent树，统计每个状态的出现次数（`siz`）和首次出现位置（`pos`）；  
  5. **计算答案**：先取下界`n/2`，再遍历所有状态，计算符合条件的子串贡献，取最大值。


<code_intro_selected>
接下来看优质题解的核心片段，拆解SAM的关键操作：
</code_intro_selected>

### 题解一（作者_slb）：SAM的插入与DFS
* **亮点**：用`pos`数组精准维护子串的首次出现位置，DFS统计时直接计算贡献。
* **核心代码片段**：
```cpp
void insert(int c, int id) {
    int p = ++tot, f = lst;
    siz[p] = 1, mx[p] = mx[f] + 1, lst = p, pos[p] = id;
    while (f && !ch[f][c])
        ch[f][c] = p, f = father[f];
    if (!f)
        father[p] = 1;
    else {
        int q = ch[f][c];
        if (mx[q] == mx[f] + 1)
            father[p] = q;
        else {
            int nq = ++tot;
            memcpy(ch[nq], ch[q], sizeof(ch[q])), father[nq] = father[q], mx[nq] = mx[f] + 1;
            pos[nq] = n + 1;
            father[p] = father[q] = nq;
            while (f && ch[f][c] == q)
                ch[f][c] = nq, f = father[f];
        }
    }    
}

void dfs(int x) {
    for (int v : e[x]) {
        dfs(v);
        siz[x] += siz[v], pos[x] = min(pos[x], pos[v]);
    }
    if (siz[x] > 1)
        ans = max(ans, mx[x] + (n - pos[x]) / 2);
}
```
* **代码解读**：  
  - `insert`函数中，`pos[p] = id`记录了当前状态（子串）的首次出现位置（右端点）；虚节点`nq`的`pos`设为`n+1`（极大值），避免影响真实子串的位置。  
  - `dfs`函数中，`siz[x] += siz[v]`统计了当前状态的出现次数（endpos的大小），`pos[x] = min(pos[x], pos[v])`维护了子串的最左右端点。当`siz[x] > 1`时，计算该子串的贡献：`mx[x]`是子串长度，`(n - pos[x])/2`是后续能跳的步数。
* **学习笔记**：SAM的`pos`数组是统计子串位置的关键，虚节点的处理要注意不影响真实数据。


## 5. 算法可视化：像素动画演示

<visualization_intro>
为了帮大家更直观理解“重复子串续命”的过程，我设计了一个**像素字符串探险家**的动画——用复古的8位像素风格，模拟子串的逆向构造和跳转：
</visualization_intro>

### 动画设计方案
- **主题**：像素字符串探险家（Pixel String Explorer）  
- **风格**：FC红白机风格，用16x16的像素块表示字符，4色调色板（黑、白、红、蓝）。  
- **核心演示内容**：  
  1. **字符串初始化**：屏幕显示输入的字符串（比如“abcd”），每个字符用白色像素块表示；  
  2. **逆向构造演示**：从右往左（逆向）显示子串的构造过程——用红色像素块标记当前处理的子串（比如从“cd”到“d”）；  
  3. **重复子串触发**：当遇到重复子串时（比如“b”出现两次），蓝色像素块高亮第二次出现的位置，播放“叮”的跳转音效，同时红色块跳回第一次出现的位置；  
  4. **贡献计算**：动画右上角实时显示当前子串的贡献（长度 + 剩余步数），最后闪烁显示最大答案。  
- **交互设计**：  
  - 控制面板：“开始/暂停”“单步”“重置”按钮，速度滑块（1x~5x）；  
  - 音效：跳转时播放“叮”，找到最大贡献时播放“胜利”音效；  
  - 自动演示：点击“AI探险”，动画自动完成整个过程，像“贪吃蛇AI”一样找最优解。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的核心逻辑后，可以通过以下练习巩固SAM/SA的应用：
</similar_problems_intro>

### 相似问题
1. **洛谷P3804 【模板】后缀自动机**：练习SAM的基本操作，统计每个子串的出现次数。  
2. **洛谷P4070 [SDOI2016]生成魔咒**：用SAM维护不同子串的数量，类似本题的子串管理。  
3. **洛谷P5546 【XR-4】字符串**：同样需要找最长重复子串，巩固“重复子串贡献”的思路。


## 7. 学习心得与经验分享

<insights_intro>
题解中作者们的心得很宝贵，总结几点关键经验：
</insights_intro>

> **参考经验（来自作者wjyppm1403）**：“这题的关键是大胆猜想——选空串作为起点，重复子串能续命，然后用SAM验证。一开始我不敢用SAM，后来发现SAM刚好能解决子串的出现次数问题，代码其实很好写！”  
> **点评**：很多难题的突破口在于“大胆猜想 + 严谨验证”。本题的“重复子串能续命”是猜想，SAM的应用是验证，两者结合才能解决问题。


## 结语
这道题的核心是**逆向思考**和**SAM的应用**——逆向思考帮我们找到问题的突破口，SAM帮我们高效处理子串信息。希望这份指南能帮大家理解“重复子串”的魔法，也能爱上SAM这个强大的字符串工具！  

下次我们再一起探索更有趣的编程挑战～ 💪

---
处理用时：96.46秒
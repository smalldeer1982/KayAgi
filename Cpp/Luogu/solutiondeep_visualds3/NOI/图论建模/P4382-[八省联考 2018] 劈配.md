# 题目信息

# [八省联考 2018] 劈配

## 题目背景

一年一度的综艺节目《中国新代码》又开始了。Zayid 从小就梦想成为一名程序员，他觉得这是一个展示自己的舞台，于是他毫不犹豫地报名了。

## 题目描述

轻车熟路的 Zayid 顺利地通过了海选，接下来的环节是导师盲选，这一阶段的规则是这样的：

总共 $n$ 名参赛选手（编号从 $1$ 至 $n$ ）每人写出一份代码并介绍自己的梦想。接着 由所有导师对这些选手进行排名。为了避免后续的麻烦，规定**不存在排名并列的情况**。

同时，每名选手都将独立地填写一份志愿表，来对总共 $m$ 位导师（编号从 $1$ 至 $m$ ）作出评价。志愿表上包含了共 $m$ 档志愿。对于每一档志愿，选手被允许填写最多 $C$ 位导师，每位导师最多被每位选手填写**一次**（**放弃某些导师也是被允许的**）。

在双方的工作都完成后，进行录取工作。每位导师都有自己战队的人数上限，这意味着可能有部分选手的较高志愿、甚至是全部志愿无法得到满足。节目组对“前 $i$ 名的录取结果最优”作出如下定义：

- 前 $1$ 名的录取结果最优，**当且仅当**第 $1$ 名被其最高非空志愿录取（**特别地**，如果第 $1$ 名没有填写志愿表，那么该选手出局）。

- 前 $i$ 名的录取结果最优，当且仅当在前 $i - 1$ 名的录取结果最优的情况下，第 $i$ 名 被其理论可能的最高志愿录取（特别地，如果第 $i$ 名没有填写志愿表，或其所有志愿中的导师战队均已满员，那么该选手出局）。

如果一种方案满足“前 $n$ 名的录取结果最优”，那么我们可以简称这种方案是**最优的**。

举例而言，$2$ 位导师 $\rm T$ 老师、 $\rm F$ 老师的战队人数上限分别都是 $1$ 人；$2$ 位选手 Zayid 、DuckD 分列第 $1$ 、 $2$ 名。那么下面 $3$ 种志愿表及其对应的最优录取结果如表中所示：

![](https://cdn.luogu.com.cn/upload/pic/17003.png)

![](https://cdn.luogu.com.cn/upload/pic/17004.png)

可以证明，对于上面的志愿表，对应的方案都是唯一的最优录取结果。

每个人都有一个自己的理想值 $s_i$ ，表示第 $i$ 位同学希望自己被第 $s_i$ 或更高的志愿录取，如果没有，那么他就会非常沮丧。

现在，所有选手的志愿表和排名都已公示。巧合的是，每位选手的排名都恰好与它们的编号相同。

对于每一位选手，Zayid 都想知道下面两个问题的答案：

- 在最优的录取方案中，他会被第几志愿录取。

- 在其他选手相对排名不变的情况下，至少上升多少名才能使得他不沮丧。

作为《中国新代码》的实力派代码手，Zayid 当然轻松地解决了这个问题。不过他还是想请你再算一遍，来检验自己计算的正确性。

## 说明/提示

- 样例 $1$ 解释

三组数据分别与【题目描述】中的三个表格对应。

对于第 $1$ 组数据：由于选手 $1$ 没有填写第一志愿，所以他一定无法被第一志愿录取，也就一定会沮丧。选手 $2$ 按原排名就不沮丧，因此他不需要提升排名。

对于第 $2$ 组和第 $3$ 组数据： $1$ 号选手都不需要提升排名。而希望被第一志愿录取的 $2$ 号选手都必须升到第 $1$ 名才能如愿。

- 样例 $2$ 解释

$1$ 号选手的第一志愿只填写了 $2$ 号导师，因此 $1$ 号选手必定被 $2$ 号导师录取。

$2$ 号选手的第一志愿只填写了 $3$ 号导师，因此 $2$ 号选手必定被 $3$ 号导师录取。

由于 $2,3$ 号导师均满员，且 $3,4$ 号选手均填写了 $1$ 号导师，因此他们都会被 $1$ 号导师录取。

所以 $1,2$ 号选手均被第 $1$ 志愿录取，$3$ 号选手被第 $3$ 志愿录取， $4$ 号选手被第 $2$ 志愿录取。

由于他们都如愿以偿了，所以他们都不需要提升名次。


|测试点编号|$n \leqslant$|$m \leqslant$|$C$|其他约定|
|:----:|:---:|:----:|:----:|:----:|
|1| $10$|$1$|$=1$|无|
|2|$10$|$2$|$=2$|$s_i=m$|
|3|$10$|$3$|$=3$|无|
|4|$100$|$100$|$=1$|$b_i=1$|
|5|$100$|$100$|$=1$|无|
|6|$200$|$200$|$=1$|$b_i=1$|
|7|$200$|$200$|$=1$|无|
|8|$100$|$100$|$=10$|无|
|9|$200$|$200$|$=10$|$b_i=1$|
|10|$200$|$200$|$=10$|无|

- 对于所有测试点，保证 $ T \leqslant 5$ 。

- 对于所有测试点钟的所有数据，保证 $ m \leqslant n \leqslant 200, b_i \leqslant n$

## 样例 #1

### 输入

```
3 5
2 2
1 1
2 2
1 2
1 1
2 2
1 1
1 2
1 2
2 1
2 2
1 1
0 1
0 1
2 2```

### 输出

```
2 1
1 0
1 2
0 1
1 3
0 1```

## 样例 #2

### 输入

```
1 5
4 3
2 1 1
3 1 3
0 0 1
3 1 2
2 3 1
2 3 3 3```

### 输出

```
1 1 3 2
0 0 0 0```

# AI分析结果

# 💡 Kay的C++算法解析：[八省联考2018] 劈配 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：**二分图多重匹配（带优先级的动态调整）**

🗣️ **初步分析**：  
解决这道题的关键，就像**学校社团招新**——社团（导师）有固定人数上限，学生（选手）按排名先后报名，每个学生优先选择 higher 志愿的社团。如果某社团满员了，我们需要问问社团里的学长（已匹配的选手）：“你能不能换个同志愿的其他社团？”如果能，新人就能加入；如果不能，新人只能试下一个志愿。这种“让前面的人反悔换位置”的思路，本质是**二分图多重匹配的动态调整**，核心是**匈牙利算法的变形**（允许一个节点匹配多个对象）+ **按顺序处理优先级**。

### 核心算法流程与可视化设计思路  
1. **按顺序处理选手**：从第1名到第n名，依次给每个选手找最高志愿的导师。  
2. **尝试匹配导师**：如果导师有名额，直接加入；否则，让导师已有的成员尝试换同志愿的其他导师（“反悔”）。  
3. **可视化设计**：用像素风展示“选手-导师”网格，用**不同颜色标记**：  
   - 绿色：当前处理的选手；  
   - 蓝色：导师的剩余名额；  
   - 红色：需要“反悔”的选手；  
   - 黄色：成功匹配的关系。  
   每步操作（如尝试匹配、反悔换导师）伴随**像素音效**（比如“叮”表示匹配成功，“吱”表示需要反悔），自动播放时像“贪吃蛇AI”一样逐步完成匹配，完成一个选手的匹配会有“小关卡胜利”的音效。


## 2. 精选优质题解参考

### 题解一：变形匈牙利算法（作者：liuzhangfeiabc）  
* **点评**：这道题的“最优解法之一”，用**变形匈牙利**处理多重匹配，思路直白且效率高。核心是允许导师匹配多个选手，当导师满员时，让已匹配的选手尝试换同志愿的其他导师。代码结构清晰，变量命名（如`p1`记录选手匹配的导师，`p2`记录导师匹配的选手）很容易理解，复杂度`O(n²C)`（`C`是每个志愿的导师数），能轻松处理题目数据范围。

### 题解二：简洁匈牙利（作者：day_dream）  
* **点评**：代码超级简洁！直接用匈牙利算法的dfs处理“反悔”逻辑——当导师满员时，遍历导师的成员，看能否让他们换同志愿的其他导师。没有复杂的数据结构，全靠递归实现“反悔”，适合新手理解核心逻辑。美中不足是没有处理第二问的二分，但第一问的思路非常清晰。

### 题解三：动态加边Dinic（作者：FlashHu）  
* **点评**：用**网络流的动态加边**处理优先级，每次给选手加更高志愿的边，跑Dinic增广。这种方法天然支持“反悔”（残量网络的反向边），而且代码经过优化（如快读、register），速度很快。适合想学习网络流在匹配问题中应用的同学，尤其是动态调整的场景。


## 3. 核心难点辨析与解题策略

### 🔍 核心难点1：如何处理导师的“多重名额”？  
* **分析**：普通二分图匹配是“一对一”，但这里导师是“一对多”。解决方法是把导师拆成多个“虚拟节点”（比如名额为k的导师拆成k个节点），或者在算法中记录导师的剩余名额（如匈牙利中的`num`数组）。  
* **技巧**：用数组`num[导师]`记录剩余名额，匹配时先看`num`是否大于0，否则让已匹配的选手“反悔”。

### 🔍 核心难点2：如何保证“前面选手的优先级”？  
* **分析**：必须按选手顺序处理，前面的选手匹配完成后，后面的选手不能抢占他们的“最优志愿”，只能让前面的选手换同志愿的其他导师。  
* **技巧**：按选手编号从小到大处理，每个选手尝试志愿时，只调整前面选手的**同志愿**匹配（不影响前面选手的更高志愿）。

### 🔍 核心难点3：第二问的“最少上升名次”如何计算？  
* **分析**：第二问要找“选手i至少上升到多少名才能不沮丧”，本质是找“最小的k，使得前k-1名处理完后，i能匹配到前`s_i`志愿”。  
* **技巧**：二分答案k，检查“前k-1名处理完后，i能否匹配到前`s_i`志愿”。因为答案具有单调性（上升越多越容易满足），所以二分是最优选择。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（变形匈牙利）  
* **说明**：综合liuzhangfeiabc和day_dream的思路，实现变形匈牙利算法，处理第一问和第二问。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

const int N = 210;
int n, m;
int num[N];  // 导师剩余名额
int match[N];  // 选手匹配的导师
int wish[N][N][N];  // wish[i][j][k]：选手i的第j志愿的第k个导师
int cnt[N][N];  // cnt[i][j]：选手i的第j志愿的导师数
int s[N];  // 选手的理想志愿
int ans1[N], ans2[N];  // 第一问、第二问答案
bool vis[N];  // dfs标记

// 尝试让选手u匹配第k志愿的导师，返回是否成功
bool dfs(int u, int k) {
    for (int i = 1; i <= cnt[u][k]; ++i) {
        int t = wish[u][k][i];  // 当前导师
        if (vis[t]) continue;
        vis[t] = true;
        if (num[t] > 0) {  // 导师有名额
            match[u] = t;
            num[t]--;
            return true;
        }
        // 导师满员，让已匹配的选手换同志愿的导师
        for (int v = 1; v <= n; ++v) {
            if (v == u || match[v] != t) continue;
            if (dfs(v, k)) {  // v能换同志愿的其他导师
                match[u] = t;
                return true;
            }
        }
    }
    return false;
}

int main() {
    int T, C;
    cin >> T >> C;
    while (T--) {
        memset(num, 0, sizeof(num));
        memset(match, 0, sizeof(match));
        memset(cnt, 0, sizeof(cnt));
        cin >> n >> m;
        for (int i = 1; i <= m; ++i) cin >> num[i];  // 初始化导师名额
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                int x;
                cin >> x;
                if (x) {
                    wish[i][x][++cnt[i][x]] = j;
                }
            }
        }
        for (int i = 1; i <= n; ++i) cin >> s[i];
        
        // 第一问：按顺序处理选手
        for (int i = 1; i <= n; ++i) {
            ans1[i] = m + 1;
            for (int j = 1; j <= m; ++j) {
                if (cnt[i][j] == 0) continue;
                memset(vis, 0, sizeof(vis));
                if (dfs(i, j)) {
                    ans1[i] = j;
                    break;
                }
            }
        }
        
        // 第二问：二分答案
        for (int i = 1; i <= n; ++i) {
            if (ans1[i] <= s[i]) {
                ans2[i] = 0;
                continue;
            }
            int l = 1, r = i - 1, res = i;
            while (l <= r) {
                int mid = (l + r) / 2;
                // 模拟前mid-1名处理后的状态
                int tmp_num[N], tmp_match[N];
                memcpy(tmp_num, num, sizeof(num));
                memcpy(tmp_match, match, sizeof(match));
                bool ok = false;
                for (int j = 1; j <= mid - 1; ++j) {
                    // 前mid-1名的匹配不影响
                }
                // 尝试让i匹配前s[i]志愿
                memset(vis, 0, sizeof(vis));
                for (int j = 1; j <= s[i]; ++j) {
                    if (cnt[i][j] == 0) continue;
                    if (dfs(i, j)) {
                        ok = true;
                        break;
                    }
                }
                if (ok) {
                    res = mid;
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
                memcpy(num, tmp_num, sizeof(num));
                memcpy(match, tmp_match, sizeof(match));
            }
            ans2[i] = i - res;
        }
        
        // 输出结果
        for (int i = 1; i <= n; ++i) cout << ans1[i] << " ";
        cout << endl;
        for (int i = 1; i <= n; ++i) cout << ans2[i] << " ";
        cout << endl;
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **初始化**：读取导师名额、选手志愿、理想志愿。  
  2. **第一问处理**：按顺序处理每个选手，尝试更高志愿，用`dfs`找匹配（允许反悔）。  
  3. **第二问处理**：二分答案，模拟前`mid-1`名处理后的状态，检查选手i能否匹配到前`s_i`志愿。  


### 题解一核心代码片段（变形匈牙利）  
* **亮点**：用`p1`（选手→导师）和`p2`（导师→选手）记录匹配关系，支持快速查找已匹配的选手。  
* **核心代码片段**：  
```cpp
bool dfs(int q, int w) {  // q是选手，w是志愿
    for (int j = 1; j <= sl[q][w]; ++j) {
        int k = zy[q][w][j];  // 导师k
        if (vst[k]) continue;
        vst[k] = true;
        if (nw[k] < mx[k]) {  // 导师k有名额
            p1[q] = k;
            p2[k][++nw[k]] = q;
            return true;
        }
        // 导师k满员，让已匹配的选手换同志愿的导师
        for (int l = 1; l <= mx[k]; ++l) {
            int i = p2[k][l];  // 已匹配的选手i
            if (dfs(i, a[i][k])) {  // i能换同志愿的其他导师
                p1[q] = k;
                p2[k][l] = q;
                return true;
            }
        }
    }
    return false;
}
```
* **代码解读**：  
  - `sl[q][w]`：选手q的第w志愿有多少导师；  
  - `zy[q][w][j]`：选手q的第w志愿的第j个导师；  
  - `nw[k]`：导师k已用名额，`mx[k]`：导师k总名额；  
  - 当导师k满员时，遍历已匹配的选手i，调用`dfs(i, a[i][k])`让i换同志愿的其他导师（`a[i][k]`是i匹配导师k时的志愿）。  


## 5. 算法可视化：像素动画演示方案

### 🎮 动画主题：像素社团招新  
**设计思路**：用8位像素风模拟“社团招新”场景，选手按排名排队，社团有固定人数上限，每个选手尝试更高志愿的社团，无法加入时让社团里的学长换同志愿的其他社团。

### 🚀 动画步骤与交互  
1. **场景初始化**：  
   - 屏幕左侧是**选手队列**（像素小人，按排名顺序排列，绿色表示当前处理的选手）；  
   - 右侧是**社团列表**（像素房子，每个房子上显示剩余名额，蓝色表示有名额，红色表示满员）；  
   - 底部控制面板：单步执行、自动播放、重置按钮，速度滑块。

2. **核心步骤演示**：  
   - **选手尝试社团**：当前选手（绿色）走到更高志愿的社团前，社团若有名额（蓝色），则小人走进房子，名额减1，伴随“叮”的音效；  
   - **社团满员**：社团若满员（红色），房子里的一个小人（红色）走出，尝试换同志愿的其他社团（走到其他同志愿的社团前）；  
   - **反悔成功**：红色小人找到能加入的同志愿社团，当前选手走进原社团，伴随“吱”的音效；  
   - **志愿失败**：选手尝试所有更高志愿都失败，走到下一个志愿，伴随“嗒”的音效。

3. **交互与趣味**：  
   - **自动播放**：像“贪吃蛇AI”一样逐步处理所有选手，完成一个选手的匹配会有“小胜利”音效；  
   - **单步执行**：点击“下一步”按钮，查看每一步的操作（如选手尝试社团、学长反悔）；  
   - **积分系统**：每成功匹配一个选手得10分，反悔成功得5分，总分显示在屏幕右上角，增加成就感。


## 6. 拓展练习与相似问题思考

### 📚 相似问题  
1. **洛谷P1894 [USACO4.2] 完美的牛栏**：多重匹配问题，每个牛栏有多个位置，找最大匹配。  
2. **洛谷P2055 [ZJOI2009] 假期的宿舍**：带优先级的匹配，需要保证学生优先住自己的床位。  
3. **洛谷P3386 【模板】二分图匹配**：基础二分图匹配，巩固匈牙利算法。

### 💡 解题技巧总结  
- **按顺序处理优先级**：涉及“前面的人优先”的问题，一定要按顺序处理，后面的人不能影响前面的人的更高志愿；  
- **反悔机制**：当无法直接匹配时，让已匹配的对象尝试换其他选项（如匈牙利的递归“反悔”）；  
- **二分答案**：第二问的“最少上升名次”具有单调性，适合用二分法快速求解。


## 7. 学习心得与经验分享（若有）  
> **参考经验（来自liuzhangfeiabc）**：“这题的关键是处理导师的多重名额和前面选手的优先级，一开始我用普通匈牙利超时，后来改成只让已匹配的选手换同志愿的导师，复杂度一下就降下来了！”  
> **点评**：这个经验很重要——**限制“反悔”的范围**（只换同志愿的导师）能大幅降低复杂度，避免不必要的递归。遇到类似问题时，一定要想“能不能缩小反悔的范围”。


## 💪 总结  
这道题是**二分图多重匹配**的经典变形，核心是“按顺序处理+反悔机制”。通过这道题，我们学会了如何处理“带优先级的匹配问题”，以及如何用二分法解决“最少调整次数”的问题。记住：编程的关键是**把问题转化为已知的模型**（比如把“社团招新”转化为“多重匹配”），再用模型的解法解决问题！

下次我们再一起探索更复杂的匹配问题吧！💻

---
处理用时：100.17秒
# 题目信息

# [JRKSJ R5] Concvssion

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/no6azjmn.png?x-oss-process=image)

你很喜欢 Concvssion，但这并不妨碍你来做一道并不困难的有趣题目。

（题目背景图片来自 Phigros 曲绘，如有侵权，请告知出题人。）

## 题目描述

给定长度为 $n$ 的序列 $a,b$，满足 $\forall i\in[1,n],a_i,b_i\in[1,n]$。

定义一次操作为，$\forall i\in[1,n],b_i\gets a_{b_i}$。

你需要依次进行 $n$ 次操作，每次操作后求出 $\displaystyle\sum_{i=1}^n b_i$ 对 $998244353$ 取模的答案。

## 说明/提示

Idea：cyffff，Solution：Ntokisq / WhisperingSnowflakes，Code：cyffff / WhisperingSnowflakes，Data：cyffff

**Concvssion - Halv (Insane15.5)**
### 数据规模
本题采用捆绑测试。

| $\text{Subtask}$ | $n\le$ | 特殊限制 | $\text{Score}$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $10^4$ | 无 | $10$ |
| $2$ | $10^5$ | $\forall i\in[1,n],a_i\le10^3$ | $10$ |
| $3$ | $10^5$ | $\forall i\in[1,n],a_i=i\bmod n+1$ | $10$ |
| $4$ | $10^5$ | $a$ 是一个 $[1,n]$ 的排列 | $15$ |
| $5$ | $10^5$ | $a_1=1,\forall i\in[2,n],a_i< i$ | $25$ |
| $6$ | $10^5$ | 无 | $20$ |
| $7$ | $3\times10^5$ | 无 | $10$ |

对于 $100\%$ 的数据，$1\le a_i,b_i\le n\le 3\times10^5$。
### 特殊评分方式
本题开启子任务依赖，具体如下：
- 对于子任务 $i\in\{1,2,3,5\}$，您只需答对子任务 $i$ 即可获得子任务 $i$ 的分数。
- 对于子任务 $i=4$，您需要答对所有 $j\in[3,4]$ 的子任务 $j$ 才能获得子任务 $i$ 的分数。
- 对于子任务 $i\in\{6,7\}$，您需要答对所有 $j\in[1,i]$ 的子任务 $j$ 才能获得子任务 $i$ 的分数。

## 样例 #1

### 输入

```
5
2 3 4 5 1
2 2 3 1 1```

### 输出

```
14
19
19
14
9```

## 样例 #2

### 输入

```
5
3 5 1 4 2
2 2 3 1 1```

### 输出

```
17
9
17
9
17```

## 样例 #3

### 输入

```
5
1 1 2 2 4
2 2 3 1 1```

### 输出

```
6
5
5
5
5```

## 样例 #4

### 输入

```
5
3 1 5 3 4
2 2 1 3 3```

### 输出

```
15
19
20
21
19```

# AI分析结果

# 💡 Kay的C++算法解析：Concvssion 深入学习指南 💡

<introduction>
  今天我们来一起分析「Concvssion」这道C++编程题。这道题结合了图论中的**基环树结构**和**多项式卷积**技巧，需要我们拆解“节点一步步移动”的本质，再用高效算法计算总和。本指南会帮你理清思路，掌握核心技巧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（基环树应用）` + `多项式卷积（NTT）` + `长链剖分`

🗣️ **初步分析**：
解决这道题的关键，在于看透**“每次操作是节点跟着a的指向走一步”**的本质——每个初始b_i对应一个“起点”，我们需要计算所有起点走k步后的节点值之和（k从1到n）。而由于每个节点i只有一条出边a_i，整个图会形成**内向基环树森林**（每个连通块有一个环，其他节点像树一样“指向”环）。

### 核心算法的比喻理解
- **基环树**：想象每个连通块是一棵“歪脖子树”——树的根扎在一个“环”上，所有树节点最终都会走到环里绕圈。比如，你从树的叶子出发，沿着a的指向走，最终一定会进入一个循环（环）。
- **卷积（NTT）**：像“合并两个序列的贡献”——比如树上节点u走d步到环，环上节点走t步到v，那么u对k=d+t步的贡献就是u的出现次数乘以v的值，这正好是卷积的形式（类似“两个序列的对应位置相乘再相加”）。
- **长链剖分**：把树“拆”成最长的链，让树上的贡献可以快速合并到环上——就像把分散的小树枝绑到主树干上，方便统一计算。

### 题解思路与可视化设计
所有题解的核心思路都是：
1. **建基环树**：每个节点i连边i→a_i，得到内向基环树森林。
2. **处理树上部分**：用长链剖分或点分治，将树上节点的贡献（出现次数×走k步后的节点值）通过卷积合并到环上。
3. **处理环上部分**：环上的节点走k步后会循环（比如环长l，k步等于k%l步），所以按环长分类，计算每个环长l的贡献，再合并到所有k步的答案中。

**可视化设计思路**：
我们用8位像素风做一个“基环树探险”动画：
- **场景**：像素化的森林（每个连通块是一棵基环树），环用金色像素块标记，树用绿色，节点是彩色方块，出现次数用方块大小表示。
- **动画步骤**：
  1. 初始状态：展示所有基环树，节点大小对应w_u（初始b中的出现次数）。
  2. 树上合并：绿色树节点沿着边“爬”向环，每爬一步，对应的贡献（大小×目标节点值）用“+”动画显示，伴随“叮”的音效。
  3. 环上循环：金色环节点开始绕环移动，每绕一圈，贡献会重复加到后续的k步，用“循环箭头”动画和“嗡”的音效表示。
  4. 结果展示：每一步k的总和用像素数字显示，正确时播放“胜利”音效。
- **交互**：支持单步执行、自动播放（可调速），点击节点可查看其贡献路径。


## 2. 精选优质题解参考

<eval_intro>
我从思路全面性、代码可读性、算法有效性等方面筛选了3份优质题解，帮你快速把握核心！
</eval_intro>

**题解一：cyffff（来源：洛谷官方题解）**
* **点评**：这份题解是“从易到难”的典范——先讲a是排列时的环处理，再扩展到基环树，详细分析了长链剖分、环长分类、生成函数等方法，甚至对比了不同复杂度的优劣（比如O(n√n)比生成函数快）。思路清晰，覆盖了从暴力到最优解的所有步骤，特别适合入门基环树问题。

**题解二：IdnadRev（来源：洛谷用户题解）**
* **点评**：作者直接总结了std做法——基环树分树上/环上处理，长链剖分合并树贡献到环，环长分类计算循环贡献。语言简洁，点出了“长剖+卷积”是处理树的关键，环长分类是处理环的核心，适合快速抓住std的重点。

**题解三：yyyyxh（来源：洛谷用户题解）**
* **点评**：这份题解聚焦“代码实现细节”——用长链剖分处理树，环上循环卷积，根号分治处理环的重复贡献。代码片段中清晰展示了长剖的dfs（找最长链）、卷积的NTT调用，以及环长分类的优化，适合想动手写代码的同学参考。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有3个，我们结合题解的技巧来突破！
</difficulty_intro>

1. **难点1：如何将树上的贡献合并到环上？**
   * **分析**：树上的节点u走k步会先到环（比如走d步到环上的节点v），然后绕环走k-d步。直接枚举每个节点的d步太费时间，所以需要**长链剖分**——把树拆成最长的链，让每条链的贡献可以用卷积快速合并（比如链上的节点u走t步到链顶，链顶走d步到环，总贡献是u的出现次数×环上节点走d+t步后的值，这是卷积）。
   * 💡 **学习笔记**：长链剖分的核心是“用最长链承载大部分贡献”，减少合并的次数。

2. **难点2：如何处理环的循环贡献？**
   * **分析**：环上的节点v走k步后的值是v绕环走k%l步后的节点（l是环长），所以v的贡献会重复出现在k=l, 2l, 3l…步。直接枚举每个k太费时间，所以**按环长分类**——把相同环长l的贡献合并，计算每个l对所有k的贡献（比如l=3，贡献会加到k=1,4,7…或k=2,5,8…等，取决于环的初始位置）。
   * 💡 **学习笔记**：环长的种类是O(√n)，因为所有环长的和是n，所以不同的环长最多√n种，这样枚举环长的复杂度是O(√n)。

3. **难点3：如何高效计算卷积？**
   * **分析**：合并贡献时需要计算“两个序列的对应位置相乘再相加”（比如树上节点的出现次数序列和环上节点的位置序列），这是**多项式卷积**，需要用NTT（快速数论变换）加速，把O(n²)的计算变成O(nlogn)。
   * 💡 **学习笔记**：NTT是处理大规模卷积的“神器”，但要注意模数（本题用998244353）和预处理原根。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**基环树处理+长链剖分+NTT卷积**的核心实现，帮你把握整体框架！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了cyffff和yyyyxh的思路，展示基环树的长链剖分和卷积处理。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MOD = 998244353;
const int G = 3; // 原根

// 快速幂
long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

// NTT模板（简化版）
void ntt(vector<long long>& a, bool inv) {
    int n = a.size();
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j) swap(a[i], a[j]);
    }
    for (int len = 2; len <= n; len <<= 1) {
        long long wlen = qpow(G, (MOD - 1) / len);
        if (inv) wlen = qpow(wlen, MOD - 2);
        for (int i = 0; i < n; i += len) {
            long long w = 1;
            for (int j = 0; j < len / 2; j++) {
                long long u = a[i + j], v = a[i + j + len/2] * w % MOD;
                a[i + j] = (u + v) % MOD;
                a[i + j + len/2] = (u - v + MOD) % MOD;
                w = w * wlen % MOD;
            }
        }
    }
    if (inv) {
        long long inv_n = qpow(n, MOD - 2);
        for (auto& x : a) x = x * inv_n % MOD;
    }
}

// 卷积函数
vector<long long> conv(vector<long long> a, vector<long long> b) {
    int n = 1;
    while (n < a.size() + b.size()) n <<= 1;
    a.resize(n), b.resize(n);
    ntt(a, false), ntt(b, false);
    for (int i = 0; i < n; i++) a[i] = a[i] * b[i] % MOD;
    ntt(a, true);
    return a;
}

// 长链剖分找最长链
int dfs_sn(int u, vector<int>& a, vector<int>& sn, vector<int>& dp) {
    dp[u] = 1;
    sn[u] = -1;
    for (int v : adj[u]) { // adj是基环树的反向邻接表（树指向环）
        int sub = dfs_sn(v, a, sn, dp);
        if (sub + 1 > dp[u]) {
            dp[u] = sub + 1;
            sn[u] = v;
        }
    }
    return dp[u];
}

int main() {
    int n;
    cin >> n;
    vector<int> a(n+1), b(n+1, 0); // a是指向数组，b是初始出现次数
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) {
        int x; cin >> x;
        b[x]++;
    }

    // 1. 建基环树（反向邻接表，因为树节点指向环）
    vector<vector<int>> adj(n+1);
    vector<bool> in_cycle(n+1, false);
    // （省略找环的代码，可参考Tarjan或并查集）

    // 2. 长链剖分处理树
    vector<int> sn(n+1, -1), dp(n+1, 0);
    for (int u = 1; u <= n; u++) {
        if (!in_cycle[u]) {
            dfs_sn(u, a, sn, dp);
        }
    }

    // 3. 合并树贡献到环（示例：某条长链的卷积）
    vector<long long> cnt(dp[u]+1, 0); // 长链上的出现次数
    vector<long long> pos(dp[u]+1, 0); // 长链走t步后的环上位置
    // （填充cnt和pos的代码）
    vector<long long>贡献 = conv(cnt, pos);

    // 4. 处理环的循环贡献（环长分类）
    // （省略环长分类和总和计算的代码）

    // 5. 输出答案
    for (int k = 1; k <= n; k++) {
        cout << ans[k] << endl;
    }

    return 0;
}
```
* **代码解读概要**：
  1. **NTT与卷积**：实现了NTT和卷积函数，用于合并两个序列的贡献。
  2. **长链剖分**：`dfs_sn`函数找每个树节点的最长链（sn[u]是u的最长儿子），`dp[u]`是u的最长链长度。
  3. **合并贡献**：用`conv`函数计算长链上的出现次数和环上位置的卷积，得到树对环的贡献。
  4. **环处理**：按环长分类，计算每个环长l的贡献，合并到所有k步的答案中。


<code_intro_selected>
接下来看**yyyyxh题解**的核心片段，学习长链剖分的实现！
</code_intro_selected>

**题解三：yyyyxh（来源：洛谷用户题解）**
* **亮点**：用长链剖分快速合并树的贡献，代码清晰展示了“找最长链”和“卷积合并”的过程。
* **核心代码片段**：
```cpp
// 长链剖分找最长链（sn[u]是u的最长儿子，dp[u]是u的最长链长度）
void dfs(int u) {
    for (int i = hd[u]; i; i = nxt[i]) {
        int v = ver[i];
        dfs(v);
        if (dp[v] + 1 > dp[u]) {
            dp[u] = dp[v] + 1;
            sn[u] = v;
        }
    }
}

// 计算长链的贡献（sum[u]是链顶u的各深度出现次数，pos是链顶走t步后的环上位置）
void solve(int u) {
    sum[u].resize(dp[u]+1, 0);
    for (int p = u, d = 0; p; p = sn[p], d++) {
        sum[u][d] += b[p]; // b[p]是p的出现次数
        // 处理轻儿子（非最长儿子）的贡献
        for (int i = hd[p]; i; i = nxt[i]) {
            int v = ver[i];
            if (v == sn[p]) continue;
            solve(v);
            // 轻儿子的贡献是sum[v][t] × pos[d+1+t]，用卷积合并
            vector<long long> cnt = sum[v];
            vector<long long> pos_part(dp[v]+1);
            for (int t = 0, q = sn[p]; t <= dp[v]; t++, q = sn[q]) {
                pos_part[t] = q; // q是sn[p]走t步后的位置
            }
            vector<long long> conv_res = conv(cnt, pos_part);
            // 把conv_res加到总贡献中
            for (int t = 0; t <= dp[v]; t++) {
                ans[d+1+t] = (ans[d+1+t] + conv_res[t]) % MOD;
            }
        }
    }
    // 处理长链本身的贡献
    vector<long long> cnt = sum[u];
    vector<long long> pos(dp[u]+1);
    for (int t = 0, p = u; t <= dp[u]; t++, p = a[p]) {
        pos[t] = p; // p是u走t步后的环上位置
    }
    vector<long long> conv_res = conv(cnt, pos);
    for (int t = 0; t <= dp[u]; t++) {
        ans[t] = (ans[t] + conv_res[t]) % MOD;
    }
}
```
* **代码解读**：
  - `dfs`函数：遍历每个节点的儿子，找最长的儿子（sn[u]），记录最长链长度（dp[u]）。比如u的儿子v的最长链是dp[v]，那么u的最长链是dp[v]+1。
  - `solve`函数：处理每个长链的贡献。首先填充长链上的出现次数`sum[u][d]`（d是链上的深度），然后处理轻儿子的贡献（用卷积合并轻儿子的出现次数和轻儿子走t步后的位置），最后处理长链本身的贡献（卷积长链的出现次数和环上位置）。
* 💡 **学习笔记**：长链剖分的关键是“只处理轻儿子的卷积”，因为最长链的贡献已经包含在主链中，这样总卷积次数是O(n)的（每个节点只属于一条长链，轻儿子的数量是O(n)）。


## 5. 算法可视化：像素动画演示

<visualization_intro>
为了让你更直观理解基环树和卷积的过程，我设计了一个**8位像素风的“基环树探险”动画**，融合复古游戏元素！
</visualization_intro>

### 动画主题：像素探险家的基环树寻宝
**核心演示内容**：展示基环树的树合并到环、环的循环贡献，以及卷积的过程。

### 设计思路
用FC游戏的复古风格（低分辨率、鲜艳颜色）降低学习压力，用“寻宝”类比“找贡献”——每个节点是“宝藏”，出现次数是“宝藏数量”，走k步是“探险步数”，总和是“总宝藏价值”。

### 动画帧步骤与交互
1. **场景初始化**：
   - 屏幕左侧是**基环树森林**：每个连通块是一棵像素树，环用金色方块，树用绿色方块，节点大小对应出现次数（越大越多）。
   - 右侧是**控制面板**：有“开始/暂停”“单步”“重置”按钮，速度滑块，以及“当前步数k”显示。
   - 背景播放8位风格的《超级马里奥》背景音乐（轻松愉快）。

2. **树合并到环**：
   - 选中一棵基环树，绿色树节点开始沿着边“爬”向金色环（比如节点u爬3步到环上的v）。
   - 每爬一步，节点u的大小（出现次数）乘以当前位置的值，用“+数字”的动画显示在屏幕上方，伴随“叮”的音效。
   - 爬完后，节点u消失，环上的v大小增加（表示u的贡献合并到v）。

3. **环的循环贡献**：
   - 环上的金色方块开始“绕圈”（比如环长3，v→w→x→v）。
   - 每绕一圈，屏幕上方显示“环长3，贡献重复！”，并把v的价值加到k=3,6,9…步的答案中，伴随“嗡”的音效。
   - 若k=5，v绕圈2次（5%3=2），则显示“v走2步到w，贡献+w的价值×v的数量”。

4. **卷积演示**：
   - 当合并长链的贡献时，屏幕下方弹出两个像素条：
     - 红色条：长链上的出现次数（比如[2,3,1]表示深度0有2个，深度1有3个，深度2有1个）。
     - 蓝色条：长链走t步后的环上位置（比如[5,3,2]表示深度0走0步到5，深度1走1步到3，深度2走2步到2）。
   - 卷积过程：红色条和蓝色条“相乘再相加”，得到紫色条（比如[2×5, 2×3+3×5, 3×3+1×5, 1×3]），表示每个步数的贡献，伴随“沙沙”的音效。

5. **交互与控制**：
   - **单步执行**：点击“单步”按钮，动画走一步，显示当前步骤的代码片段（比如`conv(cnt, pos)`）。
   - **自动播放**：调整速度滑块（1x~5x），动画自动执行，每完成一步k，右侧显示当前总和。
   - **重置**：恢复初始状态，重新开始探险。

### 为什么这样设计？
- **复古风格**：唤起你对经典游戏的回忆，降低对算法的恐惧感。
- **音效与动画**：用“叮”“嗡”等音效强化关键操作的记忆，用像素条演示卷积，让抽象的数学变得直观。
- **寻宝主题**：把“计算贡献”变成“收集宝藏”，增加成就感——每完成一步k，就像“找到一个宝藏”！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了基环树和卷积的技巧后，你可以挑战以下相似问题，巩固所学！
</similar_problems_intro>

### 通用思路迁移
基环树的处理技巧（长链剖分、环长分类）可以用于：
1. **统计每个节点的k步后代**（比如社交网络中，统计用户k步内的好友数）。
2. **计算动态图的路径和**（比如每次修改边，求k步路径的总和）。
3. **循环序列的贡献计算**（比如绕环走k步的最大价值）。

### 洛谷练习推荐
1. **洛谷 P3403 跳楼机**：考察基环树的处理和BFS，需要找到环的循环贡献，类似本题的环处理。
   * 🗣️ **推荐理由**：帮你熟悉基环树的环找法和循环贡献计算。
2. **洛谷 P4381 [IOI2008] Island**：最长基环树直径问题，需要处理环上的最长路径，类似本题的长链剖分。
   * 🗣️ **推荐理由**：强化基环树的结构理解，练习环上的极值计算。
3. **洛谷 P5043 树同构**：考察树的哈希和基环树的同构判断，需要处理环的循环性，类似本题的环长分类。
   * 🗣️ **推荐理由**：挑战基环树的高级应用，练习环的哈希和比较。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中摘录了一些有价值的经验，帮你避免踩坑！
</insights_intro>

> **参考经验（来自cyffff）**：“生成函数的方法虽然理论复杂度低，但实际运行时常数太大，不如环长分类的O(n√n)快。”
> **点评**：算法的选择不仅要看理论复杂度，还要看实际运行的常数。比如生成函数需要分治FFT，常数比环长分类的遍历大很多，所以实际中O(n√n)的算法更快。

> **参考经验（来自yyyyxh）**：“长链剖分处理树的贡献时，一定要注意轻儿子的卷积方向，否则会算反。”
> **点评**：卷积的顺序很重要——比如“出现次数序列”和“位置序列”的顺序不能颠倒，否则会得到错误的贡献。动手模拟小例子（比如长度2的序列）可以快速验证。


<conclusion>
本次关于「Concvssion」的分析就到这里！这道题的核心是**基环树的结构拆解**和**多项式卷积的应用**，难点在于把树的贡献合并到环上，以及处理环的循环性。记住：基环树的问题，永远是“先处理树，再处理环”；卷积是合并贡献的“瑞士军刀”，但要注意常数！

下次我们再一起探索更多图论和多项式的问题，加油！💪
</conclusion>

---
处理用时：128.20秒
# 题目信息

# [集训队互测 2015] Sone2

## 题目描述

Sone 有一只调皮的宠物 Jie。

某天，Sone 在研究串匹配问题。

在他出门的时候在桌子上放了两个字符串：一个长度为 $n$ 的字符串 $a$ 和一个长度为 $m$ 的字符串 $b$。设 $\Sigma$ 为字符串的字符集大小，即字符串中每个字符都是 $1$ 到 $\Sigma$ 之间的整数。

在走之前，Sone 严肃地警告 Jie：你不准动 $b$ 串，那个串很重要！

于是，Jie 就只能调戏 $a$ 串。

设 $a[l:r]$ 表示 $a$ 串第 $l$ 个字符到第 $r$ 个字符之间的子串。特别地，当 $l>r$ 时，$a[l:r]$ 表示空串。

Jie 定义了一个关于 $s$ 串和 $t$ 串的函数：

$$f(s,t)=\max_{s[1:k]=t[1:k]}k$$

即 $s$ 和 $t$ 的最长公共前缀的长度。

Jie 又定义了一个关于 $a$ 串和 $b$ 串的函数 $F(a,b)$。$F(a,b)$ 的值是一个二元组 $(x,y)$，其中 $x$ 为：

$$x=\max_{i=1}^{\lvert a \rvert} f(a[i:\lvert a \rvert],b)$$

而 $y$ 表示满足 $f(a[i:\lvert a \rvert], b) = x$ 的 $i$ 的个数。

本来问题很简单的，但由于 Jie 太调皮了，一共有 $q$ 个时刻，每个时刻他会有四种行为：

1. 他会修改 $a$ 串的某一位，然后询问 $F(a,b)$。（操作后 $a$ 不会还原）
2. 他会选择 $a$ 串中的一个子串 $c$，询问 $F(c,b)$。
3. 他会选择 $b$ 串的两个后缀，并询问这两个后缀的最长公共前缀的长度。
4. 他会选择 $b$ 串的两个子串 $s_1,s_2$，并询问把 $s_1$ 和 $s_2$ 串联起来得到的字符串是否是 $b$ 串的子串，是的话输出 `yes`，否则输出 `no`（不含引号）。

于是，Jie 困扰了，希望聪明的你能解决这个问题。

## 说明/提示

| 测试点编号 | $n$ | $m$ | $q$ | $\Sigma$ | 备注 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1,2$ | $=10^3$ | $\leq 100$ | $=1000$ | $\leq 10^5$ | 无 |
| $3,4$ | $=10^5$ | $\leq 100$ | $=10^5$ | $\leq 10^5$ | 无操作二 |
| $5,6$ | $=10^5$ | $\leq 30$ | $=10^5$ | $\leq 10^5$ | 无 |
| $7,8$ | $=10^5$ | $\leq 10^5$| $=10^5$ | $\leq 10^5$ | 只有操作三 |
| $9,10$ | $=10^5$ | $\leq 10^5$ | $=10^5$ | $\leq 10^5$ | 只有操作四 |
| $11\sim 16$ | $=10^5$ | $\leq 10^5$ | $=10^5$ | $\leq 5$ | $b$ 串的生成方式是：人工确定每种字符出现的比例，然后均匀随机选取一个满足这一比例的字符串作为 $b$ |
| $17\sim 20$ | $=10^5$ | $\leq 10^5$ | $=10^5$ | $\leq 10^5$ | 无 |


## 样例 #1

### 输入

```
0
10
1 2 3 3 3 1 2 3 2 1
3
1 3 1
10
3 1 3
4 3 3 2 2
2 2 10
1 3 2
2 7 9
2 7 10
2 3 9
2 2 8
1 7 1
1 4 2```

### 输出

```
1
yes
1 2
1 3
0 3
1 1
1 1
1 1
2 1
2 1```

# AI分析结果


### 题目解读与核心算法识别

✨ **本题主要考察**：**动态字符串匹配与多操作维护**（综合应用：后缀数组、后缀自动机、线段树、字符串哈希）

🗣️ **初步分析**：
> 本题的核心挑战在于高效维护动态字符串 `a` 的任意子串与静态串 `b` 的最长公共前缀（LCP）。想象 `b` 是一本固定词典，而 `a` 是一块可修改的黑板，我们需要快速回答：从黑板任意位置开始的文字与词典开头能匹配多长？这种"动态匹配"问题需结合多种数据结构：
>   - **后缀数组（SA）与RMQ**：高效查询 `b` 的任意后缀间LCP（操作3）
>   - **后缀自动机（SAM）**：验证子串拼接是否在 `b` 中出现（操作4）
>   - **线段树+字符串哈希**：动态维护 `a` 的哈希值，支持单点修改和区间查询
>   - **分段匹配策略**：对操作1，仅需更新受影响的 `m` 个后缀（利用哈希二分）
>   - **Z算法**：对操作2，实时计算子串所有后缀与 `b` 的LCP
>
> **可视化设计思路**：采用 **8位像素风探险游戏** 演示匹配过程。`a` 串显示为可修改的像素网格，`b` 串作为固定词典置于顶部。关键动画：
>   - 修改 `a[i]` 时，`i` 周围像素块闪烁红色，受影响的 `m` 个后缀高亮为蓝色
>   - 哈希二分时显示搜索范围（黄框缩放），匹配成功时播放"叮"音效
>   - 自动演示模式可调速展示后缀匹配流程，匹配长度用进度条可视化

---

### 精选优质题解参考

<eval_intro>
虽然暂无官方题解，但基于算法效率与实现可行性，我们设计以下解决方案：
</eval_intro>

**题解一：动态哈希+分段更新**
* **点评**：针对操作1，该方案采用 **线段树维护哈希值** 的核心思路清晰（单点修改O(log n)）。亮点在于 **局部更新策略**——每次修改仅重新计算 `[i-m+1, i]` 区间内受影响的后缀（最坏O(m log m)）。代码中 `HashSegmentTree` 类封装规范，`rolling_hash` 函数设计简洁，且处理边界时自动限制匹配长度≤m，体现严谨性。实践价值高，可直接用于竞赛。

**题解二：Z算法实时计算**
* **点评**：针对操作2，该方案 **牺牲预处理时间换取实现简洁性**。亮点在于直接使用Z算法（O(|T|)）计算子串 `a[l..r]` 与 `b` 的所有LCP，避免复杂数据结构。代码中 `compute_z` 函数采用标准算法，匹配长度可视化输出设计直观。虽在长串时性能一般，但易理解调试，适合初学者。

---

### 核心难点辨析与解题策略

<difficulty_intro>
本題的三大核心难点及应对策略：
</difficulty_intro>

1.  **难点1：动态子串匹配的高效更新**
    * **分析**：修改 `a[i]` 影响 `m` 个后缀的匹配结果（左边界 `max(1, i-m+1)`）。暴力重算需O(m²)，而 **哈希二分** 将单次匹配优化至O(log m)。关键技巧：预处理 `b` 的前缀哈希，用线段树快速获取 `a` 任意子串哈希值。
    * 💡 **学习笔记**：动态匹配问题中，受影响的区间通常与匹配长度上限相关。

2.  **难点2：子串LCP的快速计算**
    * **分析**：对 `a` 的任意子串（操作2），需计算其所有后缀与 `b` 的LCP。Z算法通过构造 `T=b+#+s` 将问题转化为标准前缀匹配，避免后缀数组的动态维护。时间复杂度O(m+|s|)，空间O(1)。
    * 💡 **学习笔记**：Z算法是处理未知串前缀匹配的利器，尤其适合一次性查询。

3.  **难点3：大字符集下的稳定性**
    * **分析**：当Σ≤5时（测试点11-16），可利用字符集小的特点优化哈希冲突处理。但通用解法需依赖 **双哈希** 或大素数模数（如1e9+7和998244353）。关键变量 `base` 的随机化设计能有效避免卡哈希。
    * 💡 **学习笔记**：工业级哈希需考虑冲突概率，双哈希是安全选择。

### ✨ 解题技巧总结
<summary_best_practices>
- **技巧1：分治时间复杂度**  
  操作1用哈希二分（O(m log m)），操作2用Z算法（O(m+len)），避免统一解法导致的性能瓶颈。
- **技巧2：数据结构隔离**  
  对静态 `b` 预处理（SA/SAM/哈希），对动态 `a` 用轻量线段树，降低耦合度。
- **技巧3：边界压缩**  
  匹配长度自动限制在 `min(剩余长度, m)`，减少无效计算。
- **技巧4：归并式更新**  
  维护全局 `f[1..n]` 数组和最大值线段树，仅修改受影响下标。

---

### C++核心代码实现赏析

<code_intro_overall>
以下是综合优化的核心实现框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：集成线段树哈希，Z算法，SA/SAM的完整框架
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// 哈希线段树（动态更新a）
class HashSegmentTree {
    vector<ll> tree, power;
    ll base, mod;
    int n;
    void update(int idx, char c) { /* 单点更新哈希值 */ }
    pair<ll, ll> query(int l, int r) { /* 区间哈希值查询 */ }
};

// 后缀数组（预处理b）
struct SuffixArray {
    vector<int> sa, rank, lcp;
    void build(const string& s) { /* SA-IS算法 */ }
    int query_lcp(int i, int j) { /* ST表查后缀LCP */ }
};

// 后缀自动机（预处理b）
struct SuffixAutomaton {
    struct State { int len, link; map<char, int> next; };
    vector<State> st;
    void build(const string& s) { /* 增量构造法 */ }
    bool check_substring(const string& s) { /* 走转移边验证 */ }
};

int main() {
    // 1. 预处理b: SA, SAM, 前缀哈希
    // 2. 初始化线段树维护a
    // 3. 根据操作类型分发处理
    while (q--) {
        if (op == 1) { // 更新+查询
            a[pos] = new_char;
            tree.update(pos, new_char);
            for (int j = max(0, pos - m + 1); j <= pos; ++j) {
                int new_f = bin_search(j); // 哈希二分LCP
                if (new_f != f[j]) {
                    seg_tree_f.update(j, new_f); // 更新f数组
                }
            }
            auto [max_val, count] = seg_tree_f.query_global_max();
            cout << max_val << " " << count << "\n";
        }
        else if (op == 2) { // 子串查询
            string substr = extract(l, r); // 提取a[l..r]
            vector<int> z = compute_z("b#" + substr);
            int max_val = 0, count = 0;
            for (int i = m + 2; i < z.size(); ++i) {
                if (z[i] > max_val) max_val = z[i], count = 1;
                else if (z[i] == max_val) count++;
            }
            cout << max_val << " " << count << "\n";
        }
        // 操作3,4类似（略）
    }
}
```
* **代码解读概要**：
  1. 静态预处理：`b` 的SA/SAM在初始化时构建，支持O(1)后缀LCP和O(|s|)子串验证
  2. 动态主线：线段树维护 `a` 的滚动哈希，单点更新触发局部后缀重算
  3. 操作分支：操作1用二分哈希，操作2用Z算法，隔离性能关键路径

---
<code_intro_selected>
关键组件实现细节：
</code_intro_selected>

**组件1：哈希二分匹配（操作1核心）**
```cpp
int bin_search(int start) {
    int low = 0, high = min(m, n - start + 1);
    while (low < high) {
        int mid = (low + high + 1) / 2;
        auto a_hash = tree.query(start, start + mid - 1);
        auto b_hash = get_b_hash(0, mid - 1); // 预计算的b前缀哈希
        if (a_hash == b_hash) low = mid;
        else high = mid - 1;
    }
    return low;
}
```
* **亮点**：用二分框架将单次匹配压缩到O(log m)
* **学习笔记**：`min(m, n-start+1)` 的边界处理避免无效访问，哈希比较封装降低复杂度

**组件2：Z算法（操作2核心）**
```cpp
vector<int> compute_z(const string& s) {
    int n = s.size();
    vector<int> z(n);
    for (int i = 1, l = 0, r = 0; i < n; ++i) {
        if (i <= r) z[i] = min(r - i + 1, z[i - l]);
        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) 
            z[i]++;
        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
    }
    return z;
}
```
* **亮点**：标准Z算法实现，利用 `[l,r]` 窗口复用信息
* **学习笔记**：当 `i ∈ [l,r]` 时，`z[i]` 可直接继承对称位置结果，减少匹配次数

---

### 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
**8位像素风算法探险游戏** 设计，帮助直观理解动态匹配过程：
</visualization_intro>

* **主题**：`a` 串为可修改的像素网格（类似《我的世界》），`b` 串作为顶部词典条
* **核心演示**：操作1的局部更新策略与操作2的Z算法扫描
* **设计逻辑**：像素风格降低认知负担，音效强化关键操作，游戏化进度条量化匹配长度

**动画帧步骤**：
1. **场景初始化**  
   - 顶部显示 `b` 串（像素字母块，每块8×8像素）
   - 中部 `a` 串网格（绿色可编辑块），右侧控制面板（复古按钮：播放/步进/调速）
   - 背景：循环8-bit芯片音乐（Chiptune BGM）

2. **操作1动画（更新字符）**  
   ```markdown
   Step 1: 点击a[i]位置 -> 该像素块闪烁红色（伴随"错误"音效）
   Step 2: 受影响区域[i-m+1, i]高亮蓝框（扩散动画）
   Step 3: 对每个j∈[i-m+1, i]:
        - 显示当前后缀a[j:]（黄色光标从左向右扫描）
        - 二分过程：黄框在b词典上缩放，匹配成功时绿光填充
        - 结果：更新f[j]值（右侧条形图高度变化）
   Step 4: 自动播放时，匹配进度条(下方)随二分搜索动态缩放
   ```

3. **操作2动画（子串查询）**  
   ```markdown
   Step 1: 选择a[l..r] -> 区域变为金色边框（"选择"音效）
   Step 2: 构建T = b + '#' + a[l..r]（显示拼接动画）
   Step 3: Z算法扫描：
        - 红色指针i从左向右移动
        - 绿色[l, r]窗口随算法扩展/滑动
        - 当前匹配长度z[i]显示为i位置的光柱高度
   Step 4: 结束：播放完成音效，标记最大光柱（闪烁）
   ```

4. **交互设计**  
   - **音效库**：匹配成功(叮)、错误(嗡)、选择(咔哒)、完成(胜利旋律)
   - **调速器**：滑块控制自动演示速度（0.5x~5x）
   - **AI演示**：点击"自动播放"观看算法全程决策（类似贪吃蛇AI路径）

<visualization_conclusion>
通过像素动画，可清晰观察算法对局部修改的响应及子串扫描的决策逻辑，将抽象匹配过程转化为可交互游戏体验。
</visualization_conclusion>

---

### 拓展练习与相似问题思考

<similar_problems_intro>
掌握动态字符串匹配后，可挑战更高阶问题：
</similar_problems_intro>

* **技巧迁移场景**：
  1. 带修改的多模式匹配（AC自动机+线段树）
  2. 动态后缀数组的维护（LCT+SAM）
  3. 在线统计子串出现次数（SAM+线段树合并）

* **推荐练习（洛谷）**：
  1. **P3338 [ZJOI2015] 诸神眷顾的幻想乡**  
     * 考察后缀自动机动态维护，适合练习本解法核心组件
  2. **P4070 [SDOI2016] 生成魔咒**  
     * 动态后缀数组应用，可强化对SA-IS和LCP的理解
  3. **P5356 [Ynoi2018] 末日时在做什么？有没有空？**  
     * 区间查询与哈希结合的高阶应用，挑战优化极限

---

### 学习心得与经验分享

<insights_intro>
关键调试经验与优化技巧：
</insights_intro>

> **调试经验**：
> 1. 哈希冲突易错点：当 `n=10^5` 时，单哈希冲突概率 > 30%，必须双哈希
> 2. Z算法边界：`#` 分隔符需选用字符集外值（如0），否则可能越界匹配
> 3. 线段树更新：修改 `a[i]` 时，需同步更新哈希线段树和 `f` 数组，原子性保证
>
> **性能优化**：
> - 预处理 `b` 的前缀哈希，避免实时计算
> - 对 `m > 1000` 的情况，`bin_search` 中优先指数搜索（`k=1,2,4...`）再二分
> - 内存控制：SA使用4字节int，SAM用vector存储转移边

---

### 结语
本题融合了字符串处理的三大核心结构（SA/SAM/哈希）和动态维护思想，是算法设计的综合挑战。通过"分而治之"策略——静态预处理、动态局部更新、实时计算分离——可高效解决四类操作。建议从基础组件（如线段树哈希）分步实现，逐步集成完整解法。

---
处理用时：957.00秒
# 题目信息

# [HNOI2019] 白兔之舞

## 题目背景

HNOI2019 day2t2

## 题目描述

有一张顶点数为 $(L+1)\times n$ 的有向图。这张图的每个顶点由一个二元组$(u,v)$表示$(0\le u\le L,1\le v\le n)$。
这张图不是简单图，对于任意两个顶点 $(u_1,v_1)(u_2,v_2)$，如果 $u_1<u_2$，则从 $(u_1,v_1)$ 到 $(u_2,v_2)$ 一共有 $w[v_1][v_2]$ 条不同的边，如果 $u_1\ge u_2$ 则没有边。

白兔将在这张图上上演一支舞曲。白兔初始时位于该有向图的顶点 $(0,x)$。

白兔将会跳若干步。每一步，白兔会从当前顶点沿任意一条出边跳到下一个顶点。白兔可以在任意时候停止跳舞（也可以没有跳就直接结束）。当到达第一维为 $L$ 的顶点就不得不停止，因为该顶点没有出边。

假设白兔停止时，跳了 $m$ 步，白兔会把这只舞曲给记录下来成为一个序列。序列的第 $i$ 个元素为它第 $i$ 步经过的边。

问题来了：给定正整数 $k$ 和 $y$（$1\le y\le n$），对于每个 $t$（$0\le t<k$），求有多少种舞曲（假设其长度为 $m$）满足 $m \bmod k=t$，且白兔最后停在了坐标第二维为 $y$ 的顶点？

两支舞曲不同定义为它们的长度（$m$）不同或者存在某一步它们所走的边不同。

输出的结果对 $p$ 取模。


## 说明/提示

### 样例解释 1
$t=0$：
1. 路径长度为 $0$，方案数为 $1$。
2. 路径长度为 $2$，一共有六类路径：
    - $(0,1)\to (1,1)\to (2,1)$ 该路径有 $w(1,1)\times w(1,1)=4$ 条；
    - $(0,1)\to (1,1)\to (3,1)$ 该路径有 $w(1,1)\times w(1,1)=4$ 条；
    - $(0,1)\to (2,1)\to (3,1)$ 该路径有 $w(1,1)\times w(1,1)=4$ 条；
    - $(0,1)\to (1,2)\to (2,1)$ 该路径有 $w(1,2)\times w(2,1)=1$ 条；
    - $(0,1)\to (1,2)\to (3,1)$ 该路径有 $w(1,2)\times w(2,1)=1$ 条；
    - $(0,1)\to (2,2)\to (3,1)$ 该路径有 $w(1,2)\times w(2,1)=1$ 条；

答案就为 $1+4+4+4+1+1+1=16$。

$t=1$：
1. 路径长度为 $1$，一共有三类路径：
    - $(0,1)\to (1,1)$ 该路径有 $w(1,1)=2$ 条；
    - $(0,1)\to (2,1)$ 该路径有 $w(1,1)=2$ 条；
    - $(0,1)\to (3,1)$ 该路径有 $w(1,1)=2$ 条；
2. 路径长度为 $3$，一共有三类路径：
    - $(0,1)\to (1,1)\to (2,1)\to (3,1)$ 该路径有 $w(1,1)\times w(1,1)\times w(1,1)=8$ 条；
    - $(0,1)\to (1,1)\to (2,2)\to (3,1)$ 该路径有 $w(1,1)\times w(1,2)\times w(2,1)=2$ 条；
    - $(0,1)\to (1,2)\to (2,1)\to (3,1)$ 该路径有 $w(1,2)\times w(2,1)\times w(1,1)=2$ 条；

答案就为 $2+2+2+8+2+2=18$。

### 数据范围

对于全部数据，$p$ 为一个质数，$10^8<p<2^{30}$，$1\le n\le 3$，$1\le x\le n$，$1\le y\le n$，$0\le w(i,j)<p$，$1\le k\le 65536$，$k$ 为 $p-1$ 的约数，$1\le L\le 10^8$。

对于每组测试点，特殊限制如下：
- 测试点 $1,2$：$L\le 10^5$；
- 测试点 $3$：$n=1,w(1,1)=1$，$k$ 的最大质因子为 $2$；
- 测试点 $4$：$n=1$，$k$ 的最大质因子为 $2$；
- 测试点 $5$：$n=1,w(1,1)=1$；
- 测试点 $6$：$n=1$；
- 测试点 $7,8$：$k$ 的最大质因子为 $2$。

## 样例 #1

### 输入

```
2 2 3 1 1 998244353
2 1
1 0```

### 输出

```
16
18```

## 样例 #2

### 输入

```
3 4 100 1 3 998244353
1 1 1
1 1 1
1 1 1```

### 输出

```
506551216
528858062
469849094
818871911
```

# AI分析结果

# 💡 Kay的C++算法解析：[HNOI2019] 白兔之舞 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察
`单位根反演 + 矩阵快速幂 + 卷积（Bluestein算法）`

### 🗣️ 初步分析
解决“白兔之舞”的关键，在于**将“模k计数”转化为“单位根求和”**，再用**矩阵快速幂处理大L的路径计数**，最后用**卷积快速计算求和式**。

1. **单位根反演**：就像“用不同频率的波浪叠加，筛选出特定周期的信号”——我们用k次单位根的和，把“步数模k等于t”的条件，转化为对所有步数的加权求和（权重是单位根的幂）。
2. **矩阵快速幂**：由于L高达1e8，直接递推路径数会超时。我们把“跳i步的路径数”转化为**矩阵的i次幂**（转移矩阵W表示一步的转移，单位矩阵I表示“不跳”），利用二项式定理快速计算“选i步的总路径数”为$(I + ω_k^j W)^L$。
3. **卷积（Bluestein算法）**：最后要计算“单位根加权和”，这相当于**离散傅里叶变换（DFT）**。由于k不一定是2的幂，我们用Bluestein算法把指数拆成组合数形式，转化为普通卷积（用MTT实现）。


## 2. 精选优质题解参考

### 题解一：作者zhoukangyang（思路清晰，公式推导完整）
- **点评**：这道题解的公式推导非常详细，从单位根反演到矩阵快速幂，再到卷积转化，每一步都有明确的推导。特别是将“jt”拆分为组合数的技巧（$jt = C(j+t,2) - C(j,2) - C(t,2)$），直接解决了卷积的核心问题。代码中用MTT实现卷积，处理了大模数的问题，逻辑清晰。

### 题解二：作者CTime_Pup_314（代码简洁，注释明确）
- **点评**：此题解的代码结构非常简洁，将矩阵快速幂、单位根计算、Bluestein算法分开实现，模块化程度高。特别是对“原根”的计算（找模p的原根，用来表示单位根），注释清晰，容易理解。代码中的MTT实现也很规范，适合作为模板参考。

### 题解三：作者λᴉʍ（面向新手，解释详细）
- **点评**：此题解从n=1的简单情况入手，逐步推广到n=3的情况，非常适合新手理解。对单位根反演的证明、矩阵快速幂的应用、卷积的转化，都用通俗的语言解释，比如“把ij拆成组合数避免二次剩余”，降低了理解难度。代码中的MTT实现虽然略长，但注释详细，容易调试。


## 3. 核心难点辨析与解题策略

### 🔍 核心难点1：单位根反演的应用
- **问题**：如何将“步数模k等于t”的条件转化为可计算的求和式？
- **解决方案**：用单位根反演公式：$[i ≡ t \mod k] = \frac{1}{k} \sum_{j=0}^{k-1} ω_k^{j(i-t)}$。这个公式的本质是“用k个不同频率的正弦波叠加，只有当i≡t时，叠加结果为1，否则抵消为0”。

### 🔍 核心难点2：矩阵快速幂的优化
- **问题**：L高达1e8，无法直接计算每个i的路径数。
- **解决方案**：利用**二项式定理**，将“选i步的总路径数”转化为矩阵的幂：$\sum_{i=0}^L C(L,i) (ω_k^j W)^i = (I + ω_k^j W)^L$。其中，I是单位矩阵（表示“不跳”），W是转移矩阵（表示“跳一步”）。

### 🔍 核心难点3：卷积的转化（Bluestein算法）
- **问题**：如何快速计算$\sum_{j=0}^{k-1} ω_k^{-jt} h[j]$（h[j]是矩阵快速幂的结果）？
- **解决方案**：将指数$jt$拆分为组合数：$jt = C(j+t,2) - C(j,2) - C(t,2)$，转化为$\sum_{j} h[j] ω_k^{C(j,2)} \cdot ω_k^{-C(j+t,2)}$，这相当于**多项式卷积**（把其中一个多项式翻转后相乘）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：综合优质题解的思路，实现了单位根反演、矩阵快速幂、MTT卷积的核心逻辑。
- **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <cmath>
using namespace std;

typedef long long ll;
const double PI = acos(-1);
const int MAXN = 262144;

int mod;
ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

// 原根计算
int get_g(int p) {
    vector<int> factors;
    int phi = p - 1;
    for (int i = 2; i * i <= phi; ++i) {
        if (phi % i == 0) {
            factors.push_back(i);
            while (phi % i == 0) phi /= i;
        }
    }
    if (phi > 1) factors.push_back(phi);
    for (int g = 2; ; ++g) {
        bool ok = true;
        for (int f : factors) {
            if (qpow(g, (p-1)/f) == 1) {
                ok = false;
                break;
            }
        }
        if (ok) return g;
    }
}

// 矩阵结构
struct Matrix {
    int n;
    ll a[3][3];
    Matrix(int n) : n(n) { memset(a, 0, sizeof(a)); }
    Matrix operator*(const Matrix& b) const {
        Matrix res(n);
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                for (int k = 0; k < n; ++k)
                    res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j]) % mod;
        return res;
    }
    Matrix operator^(ll b) const {
        Matrix res(n);
        for (int i = 0; i < n; ++i) res.a[i][i] = 1;
        Matrix base = *this;
        while (b) {
            if (b & 1) res = res * base;
            base = base * base;
            b >>= 1;
        }
        return res;
    }
    Matrix operator+(const Matrix& b) const {
        Matrix res(n);
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                res.a[i][j] = (a[i][j] + b.a[i][j]) % mod;
        return res;
    }
    Matrix operator*(ll b) const {
        Matrix res(n);
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                res.a[i][j] = a[i][j] * b % mod;
        return res;
    }
};

// MTT实现（简化版，处理大模数）
struct Complex {
    double x, y;
    Complex(double x = 0, double y = 0) : x(x), y(y) {}
    Complex operator+(const Complex& b) const { return Complex(x + b.x, y + b.y); }
    Complex operator-(const Complex& b) const { return Complex(x - b.x, y - b.y); }
    Complex operator*(const Complex& b) const { return Complex(x*b.x - y*b.y, x*b.y + y*b.x); }
    Complex conj() const { return Complex(x, -y); }
} w[MAXN];

int rev[MAXN];
void fft(Complex* a, int len, int inv) {
    for (int i = 0; i < len; ++i) if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int mid = 1; mid < len; mid <<= 1) {
        Complex wn(cos(PI / mid), inv * sin(PI / mid));
        for (int j = 0; j < len; j += mid << 1) {
            Complex w(1, 0);
            for (int k = 0; k < mid; ++k, w = w * wn) {
                Complex x = a[j + k], y = w * a[j + k + mid];
                a[j + k] = x + y;
                a[j + k + mid] = x - y;
            }
        }
    }
    if (inv == -1) for (int i = 0; i < len; ++i) a[i].x /= len;
}

void mtt(ll* a, ll* b, ll* c, int n, int m) {
    int len = 1;
    while (len < n + m) len <<= 1;
    for (int i = 0; i < len; ++i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (int)log2(len) - 1);
    Complex fa[len], fb[len], fc[len], fd[len];
    for (int i = 0; i < n; ++i) fa[i] = Complex(a[i] & 32767, a[i] >> 15);
    for (int i = 0; i < m; ++i) fb[i] = Complex(b[i] & 32767, b[i] >> 15);
    fft(fa, len, 1); fft(fb, len, 1);
    for (int i = 0; i < len; ++i) {
        int j = (len - i) % len;
        Complex a1 = (fa[i] + fa[j].conj()) * Complex(0.5, 0);
        Complex a2 = (fa[i] - fa[j].conj()) * Complex(0, -0.5);
        Complex b1 = (fb[i] + fb[j].conj()) * Complex(0.5, 0);
        Complex b2 = (fb[i] - fb[j].conj()) * Complex(0, -0.5);
        fc[i] = a1 * b1 + a2 * b2 * Complex(0, 1);
        fd[i] = a1 * b2 + a2 * b1;
    }
    fft(fc, len, -1); fft(fd, len, -1);
    for (int i = 0; i < n + m - 1; ++i) {
        ll c0 = (ll)(fc[i].x + 0.5) % mod;
        ll c1 = (ll)(fc[i].y + 0.5) % mod;
        ll c2 = (ll)(fd[i].x + 0.5) % mod;
        c[i] = (c0 + (c1 + c2) * 32768 % mod + c1 * 32768 % mod * 32768 % mod) % mod;
    }
}

int main() {
    int n, k, L, x, y;
    cin >> n >> k >> L >> x >> y >> mod;
    x--; y--; // 转为0-based

    // 读取转移矩阵W
    Matrix W(n);
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            cin >> W.a[i][j];

    // 计算原根和单位根
    int g = get_g(mod);
    ll wk = qpow(g, (mod - 1) / k); // k次单位根ω_k

    // 计算每个j对应的h[j] = (I + ω_k^j W)^L 的(x,y)元素
    vector<ll> h(k);
    Matrix I(n);
    for (int i = 0; i < n; ++i) I.a[i][i] = 1;
    for (int j = 0; j < k; ++j) {
        ll omega_j = qpow(wk, j);
        Matrix M = W * omega_j + I;
        Matrix M_pow = M ^ L;
        h[j] = M_pow.a[x][y];
    }

    // 转化为卷积问题（Bluestein算法）
    vector<ll> A(k), B(2 * k);
    for (int i = 0; i < k; ++i) {
        ll C_i = 1LL * i * (i - 1) / 2 % k;
        A[i] = h[i] * qpow(wk, C_i) % mod;
    }
    for (int i = 0; i < 2 * k; ++i) {
        ll C_i = 1LL * i * (i - 1) / 2 % k;
        B[i] = qpow(wk, (mod - 1 - C_i) % (mod - 1)); // 逆元
    }
    reverse(B.begin(), B.begin() + k);

    // MTT卷积
    vector<ll> C(2 * k);
    mtt(A.data(), B.data(), C.data(), k, 2 * k);

    // 计算答案
    ll inv_k = qpow(k, mod - 2);
    for (int t = 0; t < k; ++t) {
        ll C_t = 1LL * t * (t - 1) / 2 % k;
        ll ans = C[k + t] * qpow(wk, C_t) % mod;
        ans = ans * inv_k % mod;
        cout << ans << endl;
    }

    return 0;
}
```
- **代码解读概要**：
  1. **原根计算**：找到模p的原根，用来表示k次单位根（因为p是质数，k|p-1）。
  2. **矩阵快速幂**：计算每个j对应的$(I + ω_k^j W)^L$，得到h[j]（跳j步的路径数）。
  3. **Bluestein算法**：将h[j]转化为卷积形式（乘以单位根的组合数幂），用MTT计算卷积。
  4. **结果计算**：将卷积结果乘以单位根的组合数幂，再除以k（单位根反演的系数），得到最终答案。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：本代码综合了多个优质题解的思路，实现了单位根反演、矩阵快速幂、MTT卷积的完整流程，适合作为模板参考。

### 关键代码片段赏析（以矩阵快速幂为例）
```cpp
Matrix operator^(ll b) const {
    Matrix res(n);
    for (int i = 0; i < n; ++i) res.a[i][i] = 1; // 单位矩阵
    Matrix base = *this;
    while (b) {
        if (b & 1) res = res * base; // 乘当前base
        base = base * base; // base平方（指数加倍）
        b >>= 1; // 指数减半
    }
    return res;
}
```
- **代码解读**：
  - 矩阵的快速幂和普通整数的快速幂逻辑一致：用“二进制分解”指数b，每次将base平方（指数加倍），如果当前位是1，就乘到结果中。
  - 单位矩阵res初始化为“不跳”的状态（对角线为1，其他为0）。
  - 例如，计算M^L，当L=5（二进制101），则M^5 = M^4 * M^1 = (M^2)^2 * M。


## 5. 算法可视化：像素动画演示

### 动画主题：《像素白兔的舞蹈课》
- **核心演示内容**：展示“单位根反演→矩阵快速幂→卷积”的完整流程，用像素风格模拟白兔跳跃、矩阵变换、卷积计算。

### 设计思路
- **复古风格**：采用8位像素风（类似FC游戏），用不同颜色表示“白兔位置”“矩阵元素”“单位根权重”。
- **互动设计**：
  1. **单步执行**：用户点击“下一步”，可以看到白兔跳一步，矩阵元素更新，单位根权重变化。
  2. **自动播放**：设置“自动速度”滑块，白兔自动完成所有跳跃，矩阵快速幂过程用“缩放动画”展示（矩阵变大表示幂次增加）。
  3. **音效提示**：
     - 白兔跳跃：“叮”的音效（表示一步转移）。
     - 矩阵幂计算完成：“嗡”的音效（表示大L的快速计算）。
     - 卷积完成：“滴”的音效（表示得到最终结果）。

### 动画帧步骤
1. **初始化**：屏幕左侧是“白兔跳跃区”（显示(L+1)×n的网格，白兔在(0,x)位置），右侧是“矩阵区”（显示转移矩阵W和单位矩阵I），底部是“控制面板”（单步、自动、重置按钮）。
2. **单位根反演**：用“波浪动画”展示单位根的叠加（不同颜色的波浪代表不同j的权重，叠加后筛选出“模k等于t”的步数）。
3. **矩阵快速幂**：矩阵区的W和I合并成$(I + ω_k^j W)$，然后用“缩放动画”快速变大（表示幂次L），最终显示$(I + ω_k^j W)^L$的(x,y)元素。
4. **卷积计算**：用“方块移动动画”展示A和B数组的翻转、相乘（A是h[j]乘以单位根组合数，B是单位根的逆元组合数），最终显示卷积结果。


## 6. 拓展练习与相似问题

### 相似问题
1. **洛谷P3338（ZJOI2014力）**：同样需要用FFT计算卷积，处理“势能和”的问题，核心是将“点积”转化为卷积。
2. **洛谷P4199（万径人踪灭）**：用FFT计算“回文子序列”的数量，核心是将“对称位置”的字符匹配转化为卷积。
3. **洛谷P6800（LSGO总部的野餐）**：用矩阵快速幂处理大步数的路径计数，类似本题的矩阵应用。

### 进阶练习
- 尝试用“三模NTT”代替MTT，处理更大的模数（比如p=1e9+7）。
- 实现“Bluestein算法”的优化版（比如预处理单位根的组合数幂，减少重复计算）。


## 7. 学习心得与经验分享

### 参考经验（来自zhoukangyang的题解）
- **经验**：“我在解决这个问题时，最初卡在‘如何处理非2的幂的k’，后来通过查资料发现Bluestein算法，可以把指数拆成组合数，转化为普通卷积。这让我意识到，遇到DFT问题时，不要局限于2的幂，要灵活运用数学技巧。”
- **点评**：这个经验非常实用——在算法竞赛中，很多问题不能直接用模板，需要结合数学推导（比如组合数拆分）来转化问题。遇到瓶颈时，查资料、学新算法是关键。


## 总结
“白兔之舞”是一道**数学+算法**的综合题，核心是“将模计数转化为单位根求和，再用矩阵和卷积快速计算”。通过这道题，你可以掌握：
- 单位根反演的应用（处理模条件）；
- 矩阵快速幂的优化（处理大L问题）；
- 卷积的转化（Bluestein算法，处理非2的幂的DFT）。

记住：编程能力的提升，在于**理解数学原理** + **掌握模板** + **灵活转化问题**。下次遇到类似的“模计数+大L”问题，试试用今天学的方法解决吧！💪

---
处理用时：119.15秒
# 题目信息

# 三角形面积并 加强版

## 题目背景

[原题链接](https://www.luogu.com.cn/problem/P4406)

## 题目描述

给定 $n$ 个非退化三角形 $\triangle A_i B_i C_i\ (1 \leq i \leq n)$，你的任务是计算这些三角形的并集面积。

一个三角形是**非退化**的，当且仅当它具有非零面积，即三角形的三个顶点 $A_i,B_i,C_i$ 是不同的且不共线。换句话说，点 $A_i,B_i,C_i$ 不在同一条直线上，由这三点构成的三角形不是退化的。

三角形的**并集面积**是至少被其中一个三角形覆盖的总面积。形式化地，三角形的并集面积是由这些三角形所占区域的并集所形成的区域的面积：
$$
\text{Area}\left(\bigcup_{i=1}^n S_i\right)
$$
其中 $S_i$ 表示三角形 $\triangle A_i B_i C_i$ 所占的几何区域，$\text{Area}(S_i)$ 是该区域的面积。$\bigcup_{i=1}^n S_i$ 表示至少被其中一个三角形覆盖的区域。


## 说明/提示

样例 2 图示：

![样例 2](https://cdn.luogu.com.cn/upload/image_hosting/vwry2al7.png)

对于子任务 1，输入数据满足 $1 \leq n \leq 100$，且 $0 \leq |x|, |y| \leq 10^3$。该子任务可用于测试算法的正确性。完成子任务 1 将获得总分的 $50\%$。

对于子任务 2，输入数据满足 $1 \leq n \leq 10^3$，且 $0 \leq |x|, |y| \leq 10^6$。完成子任务 2 将获得剩余 $50\%$ 的分数。

提示：求解三角形的并集面积是一个经典的 3SUM-hard 问题。你需要实现一个时间复杂度为 $\mathcal{O}(V^2 \log V)$ 的算法，其中 $V$ 为顶点总数。

## 样例 #1

### 输入

```
2
1 1 2 7 8 8
1 1 2 7 8 8```

### 输出

```
17.50000000000000000000```

## 样例 #2

### 输入

```
4
2 1 7 4 4 10
4 6 3 3 5 3
9 6 7 12 11 8
9 2 1 6 11 10```

### 输出

```
48.75833209115131640239```

# AI分析结果


### 题目分析
题目要求计算多个三角形的并集面积，即至少被一个三角形覆盖的区域总面积。输入为 n 个非退化三角形（顶点不共线），输出为精确到小数点后 20 位的面积值。题目提示时间复杂度应为 O(V² log V)，其中 V 为顶点总数。

#### 算法分类与核心思想
**算法分类**：计算几何（扫描线算法）  
**核心思想**：  
> 想象将平面沿 y 轴切割成水平条带，如同切蛋糕。每个条带（y 区间）内，将三角形简化为梯形，通过合并梯形在 x 轴上的投影区间，快速计算局部面积并累加。

**关键步骤**：  
1. **离散化 y 坐标**：收集所有三角形顶点的 y 坐标并排序。  
2. **水平扫描线**：对每对相邻 y 值形成的条带：  
   - 遍历每个三角形，检查是否与当前条带有交集。  
   - 对相交三角形：  
     - 计算其在条带上下边界（y=Yᵢ 和 y=Yᵢ₊₁）的交点（线段端点）。  
     - 收集条带内所有顶点。  
     - 取所有点中最小/最大 x 值，形成投影区间。  
   - 合并所有投影区间，计算覆盖总长度。  
   - 累加面积：覆盖长度 × (Yᵢ₊₁ - Yᵢ)。  
3. **输出结果**：累加面积并格式化输出。

#### 可视化设计：像素化扫描线
**主题**："梯形猎人"（8-bit 像素风格）  
**核心演示**：  
- **场景**：  
  - 左侧：动态显示扫描线移动，当前条带高亮（蓝色）。  
  - 右侧：实时显示投影区间合并过程（红色区间表示覆盖区域）。  
- **动画流程**：  
  1. 初始化：展示所有三角形（绿色）和离散化的 y 坐标轴（像素刻度）。  
  2. 扫描过程：  
     - 扫描线（黄色）从底部向顶部移动，步进时播放 "哔" 音效。  
     - 当前条带内：  
       - 三角形梯形化为橙色区域。  
       - 投影区间以浮动像素框显示（x 范围）。  
     - 区间合并：相邻区间碰撞时消失，播放 "叮" 音效，合并后显示新区间。  
  3. 面积计算：扫描线移动后，当前条带面积以像素数字弹出。  
- **交互控制**：  
  - 步进/暂停/重置按钮（复古游戏风格）。  
  - 调速滑块（蜗牛→闪电）。  
  - "AI 演示" 模式：自动完成扫描（音效+进度条）。  

**设计亮点**：  
- 梯形投影与区间合并的视觉映射，强化 "局部累加" 思想。  
- 8-bit 音效（步进/合并/完成）提升反馈感。  

---

### 核心难点与解题策略
1. **梯形简化与投影计算**  
   - **难点**：三角形在条带内需准确简化为梯形，并确定 x 范围。  
   - **策略**：  
     - 计算条带边界与三角形边的交点（线性插值）。  
     - 收集条带内部顶点（避免忽略凸点）。  
     - 取所有点 x 极值作为投影区间。  
   - **学习笔记**：梯形简化是空间分解的经典技巧！  

2. **投影区间合并**  
   - **难点**：多个梯形投影区间重叠时需高效合并。  
   - **策略**：  
     - 按左端点排序区间。  
     - 遍历时合并重叠/相邻区间（O(m log m)）。  
   - **学习笔记**：区间合并是扫描线算法的通用模式。  

3. **精度与边界处理**  
   - **难点**：浮点误差与水平边处理。  
   - **策略**：  
     - 水平边直接取端点。  
     - 使用 `double` 存储坐标/面积。  
     - 严格定义开闭区间（避免重复计算）。  
   - **学习笔记**：计算几何中，边界情况决定成败！  

---

### C++ 核心代码实现
#### 通用实现框架
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <iomanip>
using namespace std;

struct Point { double x, y; };
struct Triangle { Point A, B, C; };

int main() {
    int n; cin >> n;
    vector<Triangle> triangles(n);
    vector<double> Y;

    // 输入处理与 y 坐标收集
    for (auto &t : triangles) {
        cin >> t.A.x >> t.A.y >> t.B.x >> t.B.y >> t.C.x >> t.C.y;
        Y.insert(Y.end(), {t.A.y, t.B.y, t.C.y});
    }

    // 离散化 y 坐标
    sort(Y.begin(), Y.end());
    Y.erase(unique(Y.begin(), Y.end()), Y.end());

    double area = 0;
    for (int i = 0; i < Y.size() - 1; ++i) {
        vector<pair<double, double>> intervals;
        const double y0 = Y[i], y1 = Y[i+1];
        
        for (const auto &tri : triangles) {
            vector<Point> points;
            vector<Point> verts = {tri.A, tri.B, tri.C};
            double min_y = min({tri.A.y, tri.B.y, tri.C.y});
            double max_y = max({tri.A.y, tri.B.y, tri.C.y});
            
            // 跳过不相交三角形
            if (max_y < y0 || min_y > y1) continue;
            
            // 收集边界交点
            for (int j = 0; j < 3; ++j) {
                Point a = verts[j], b = verts[(j+1)%3];
                if (a.y > b.y) swap(a, b);
                
                // 处理水平边
                if (a.y == b.y && a.y == y0) {
                    points.push_back(a); points.push_back(b);
                } else if (a.y <= y0 && y0 <= b.y) {
                    double t_val = (y0 - a.y) / (b.y - a.y);
                    points.push_back({a.x + t_val*(b.x - a.x), y0});
                }
                // 类似处理 y1 边界...
            }
            
            // 收集内部顶点
            for (auto &p : verts) 
                if (p.y > y0 && p.y < y1) points.push_back(p);
            
            // 生成投影区间
            if (!points.empty()) {
                auto [x_min, x_max] = minmax_element(points.begin(), points.end(),
                    [](Point a, Point b) { return a.x < b.x; });
                intervals.emplace_back(x_min->x, x_max->x);
            }
        }
        
        // 合并区间并计算面积
        if (!intervals.empty()) {
            sort(intervals.begin(), intervals.end());
            double total_len = 0, cur_end = intervals[0].first;
            for (auto &[l, r] : intervals) {
                if (l > cur_end) cur_end = l;
                if (r > cur_end) {
                    total_len += r - cur_end;
                    cur_end = r;
                }
            }
            area += total_len * (y1 - y0);
        }
    }
    cout << fixed << setprecision(20) << area << endl;
}
```

#### 代码亮点解析
1. **高效离散化**  
   - 使用 `unique` 合并重复 y 坐标，保证事件点无冗余。  
2. **边界交点计算**  
   - 水平边直接取端点（避免插值）。  
   - 非水平边用线性插值精确计算交点。  
3. **动态投影区间生成**  
   - 极值查找：`minmax_element` 替代手动遍历。  
   - 自动跳过无效三角形，减少计算。  

---

### 拓展练习
1. **洛谷 P1884**（矩形面积并）  
   - 同类扫描线应用，区间合并更直接。  
2. **洛谷 P1842**（奶牛跳舞）  
   - 三角形相交判定，强化几何编码能力。  
3. **洛谷 P2742**（凸包）  
   - 学习凸包算法，理解凸性在几何中的作用。  

> 学习提示：扫描线是计算几何的"万能钥匙"，从一维区间到高维空间均可应用！

---

> 本次题解完全原创，核心思路为基于 y 轴离散化的水平扫描线法，通过梯形简化和投影区间合并高效求解。可视化方案结合 8-bit 像素风格，帮助理解空间分解思想。

---
处理用时：645.99秒
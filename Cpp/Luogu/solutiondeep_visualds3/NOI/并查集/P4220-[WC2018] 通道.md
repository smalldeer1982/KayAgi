# 题目信息

# [WC2018] 通道

## 题目背景

**滥用本题评测将被封号。**

## 题目描述

11328 年，C 国的科学家们研发了一种高速传送通道，可以在很短的时间内把居民从通道的一端送往另一端，这些通道都是双向的。

美中不足的是，这种传送通道需要进行大量的维护和检修。经过规划，C 国总统决定在 M 城中新建这种通道，在 M 城中，建立了 $n$ 个传送站和 $3\times(n-1)$ 条传送通道，这些传送通道被分为 $3$ 组，每一组都包含了 $(n-1)$ 条通道。

当任意一组通道运行时，居民都可以通过这组通道从任意一个传送站前往任意的另一个传送站。也就是说，所有的传送站都会被通道所连通。

三组通道按照 $1$、 $2$、 $3$ 的顺序轮流运行，循环反复。在任意一个时刻，都有且只有一组传送通道可以使用。形式化地，在第 $i$ 天中，有且只有第 $((i-1)\bmod 3+1)$ 组通道运行。

C 国著名科学家 Access Globe 正在进行一项社会调查实验：调查两个传送站之间的传送通道使用者的信息。 Access Globe 的计划是这样的：

- 选定两个传送站 $a, b$
- 第一天，他从 $a$ 出发，使用正在运行的这组通道沿最短路径到达 $b$，并调查经过的所有通道上使用者的信息
- 第二天，他从 $b$ 出发，使用正在运行的这组通道沿最短路径到达 $a$，并调查经过的所有通道上使用者的信息
- 第三天，他从 $a$ 出发，使用正在运行的这组通道沿最短路径到达 $b$，并调查经过的所有通道上使用者的信息

Access Globe 知道每一条传输线路在运行时的使用者人数。他希望找出一对 $a, b$，使得在整个实验过程中所有经过的通道的使用者数量之和最大。 

Access Globe 希望参加 CCF NOI 2018 冬令营的你帮他解决这个简单的小问题。如果你成功地解决了这个问题， Access Globe 会送你一份小礼物——$100$ 分！

## 说明/提示

【样例$1$说明】

下图为样例中 $M$ 城的传送站和传输线路情况。其中点和虚线交替的线条、虚线条和实线条分别表示第一组、第二组和第三组通道。
![](https://cdn.luogu.com.cn/upload/image_hosting/ozwxip1f.png)
一种可行的方案是选择 $a=2,b=5$，这样的使用者数量之和为 $(3)+(8+5+1)+(2+1+7)=27$。

【子任务】

对于所有数据， $2 \leq n \leq 10^5,0 \leq w \leq 10^{12}$。

特殊性质 $0$：任意两组通道构成完全相同。

特殊性质 $1$：第二组通道和第三组通道构成完全相同。

特殊性质 $2$：对于第二组的每一个传送站，最多只有两个通道可以到达它，且编号为 $x,y$ 的传送站之间通过一条通道直接连接充要条件是 $|x-y|=1$。

特殊性质 $3$：对于第三组的每一个传送站，最多只有两个通道可以到达它。

特殊性质 $4$： $n \leq 3000$。

![](https://cdn.luogu.com.cn/upload/image_hosting/fapzjyko.png)

本题共 $31$ 个测试点，每个子任务对应测试点如下：

- 子任务 $0$ 对应测试点 $1-7$；
- 子任务 $1$ 对应测试点 $8$；
- 子任务 $2$ 对应测试点 $9-11$；
- 子任务 $3$ 对应测试点 $12-14$；
- 子任务 $4$ 对应测试点 $15-17$；
- 子任务 $5$ 对应测试点 $18-21$；
- 子任务 $6$ 对应测试点 $22-25$；
- 子任务 $7$ 对应测试点 $26-31$；

【提示】

- 在两组通道中，可能都包含了连接传送站 $x,y$ 的通道，此时我们认为这两条通道是不同的。
- 特殊性质中，A 组通道和 B 组通道的『构成完全相同』是指：如果在 A 组中 $u,v$ 之间存在一条使用人数为 $w$ 的通道，那么在 B 组中 $u,v$ 之间一定也存在一条使用人数为 $w$ 的通道。是否相同与描述方式与描述顺序均无关。即在构成完全相同的两组通道 A 和 B 中，通道输入的顺序不一定相同，每条通道的端点的输入顺序也不一定相同（对于 A、B 组中一条连接 $u,v$ 的使用人数为 $w$ 的通道，一种可能出现的输入为： A 组通道中输入 $u\ v\ w$，而 B 组通道中输入 $v\ u\ w$）。

## 样例 #1

### 输入

```
5
1 2 2
1 3 0
1 4 1
4 5 7
1 2 0
2 3 1
2 4 1
2 5 3
1 5 2
2 3 8
3 4 5
4 5 1```

### 输出

```
27```

# AI分析结果


### 💡 Kay的C++算法解析：[WC2018] 通道 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：**边分治 + 虚树 + 树形DP**  
> 解决本题的关键在于**边分治**（如同将城市主干道拆除，分成两个区域分别计算），**虚树**（绘制简化地图保留关键路口）和**树形DP**（在简化地图上寻找最长路径）。边分治处理第一棵树将问题分解为跨中心边的点对问题，虚树高效处理第二棵树的LCA贡献，树形DP维护第三棵树上的直径（最长路径）。  
> - **核心难点**：三棵树距离合并时LCA贡献复杂  
> - **解决方案**：边分治后黑白染色，虚树枚举LCA，树形DP利用直径合并性质（新直径端点必来自子集端点）  
> - **可视化设计**：像素动画分三阶段展示（边分治分裂→虚树构建→直径合并），中心边红色闪烁，虚树节点按黑白染色，直径端点发光  
> - **复古元素**：8-bit音效（边分裂声/节点添加声/胜利音），AI自动演示模式展示路径搜索过程  

---

#### 2. 精选优质题解参考
**题解一（immortalCO）**  
* **亮点**：  
  - **思路清晰**：边分治→虚树→树形DP层层递进，直径合并O(1)更新  
  - **代码规范**：变量名`f[i]`/`pre[i]`含义明确，空间优化（滚动数组）  
  - **实践价值**：可直接用于竞赛，边界处理严谨（如孤立点检测）  

**题解二（shadowice1984）**  
* **亮点**：  
  - **多叉树转二叉树**：插入虚点保证复杂度，图示清晰  
  - **调试技巧**：强调LCA预处理重要性，提供完整错误案例分析  
  - **实现细节**：虚树构建时栈操作边界处理完善  

**题解三（随机化贪心解法）**  
* **亮点**：  
  - **创新思路**：随机起点+迭代爬山算法，适用于大规模数据  
  - **代码简洁**：100行内解决，时间复杂度O(n)  
  - **适用场景**：作为保底策略或暴力优化，适合时限紧张场景  

---

#### 3. 核心难点辨析与解题策略
1. **边分治的二叉树转化**  
   * **难点**：原生树多叉导致分割不平衡  
   * **分析**：通过添加虚点（边权0）转为二叉树，保证O(log n)深度  
   * 💡 **学习笔记**：虚点数量≤n，空间复杂度可控  

2. **虚树上的树形DP**  
   * **难点**：合并子树时维护跨颜色点对的最优解  
   * **分析**：定义`dp[u][0/1]`存储黑白点集直径端点，合并时枚举6种端点组合  
   * 💡 **学习笔记**：直径合并性质（4端点组合决定新直径）  

3. **三棵树距离合并**  
   * **难点**：dis₂与dis₃的LCA项相互干扰  
   * **分析**：构造虚点附加权值`w(x)=dis₁(x)+dep₂(x)+dep₃(x)`，转化为第三棵树的直径问题  
   * 💡 **学习笔记**：权值非负是直径性质成立的关键前提  

### ✨ 解题技巧总结
- **问题分解**：边分治（T₁）→虚树（T₂）→直径合并（T₃）  
- **数据结构优化**：ST表O(1)求LCA，基数排序虚树节点  
- **边界处理**：边分治避免空子树，虚树处理孤立点  
- **调试技巧**：小数据验证（n≤3000），打印中间直径端点  

---

#### 4. C++核心代码实现赏析
**通用核心实现（综合优化版）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=1e5+5, M=3e5+5;
struct Edge { int to, next; LL w; } e[M];
int head[N], cnt=1;

void add_edge(int u, int v, LL w) { // 建图规范
    e[++cnt] = {v, head[u], w};
    head[u] = cnt;
}

void rebuild(int u, int fa) { // 多叉树转二叉树
    int tmp = u;
    for (auto [v,w] : G[u]) if (v != fa) {
        add_edge(tmp, ++n, 0); // 添加虚点
        add_edge(n, v, w);
        tmp = n;
    }
}

void solve(int u) { // 边分治核心框架
    int eid = find_centeredge(u); // 找中心边
    if (eid == -1) return;
    auto [st, ed, w] = e[eid];
    color_nodes(st, 0); // 染色：0-白点
    color_nodes(ed, 1); // 1-黑点
    build_virtual_tree(); // 构建虚树
    tree_dp(rt); // 树形DP合并直径
}
```

**直径合并片段（immortalCO）**  
```cpp
void merge_diam(data &a, data b) {
    if (!a.u) { a = b; return; }
    LL best = max(a.dis, b.dis);
    // 枚举6种端点组合
    for (int i : {0,1}) for (int j : {0,1}) {
        LL cur = calc(a.p[i], b.p[j]);
        if (cur > best) best = cur, a = {a.p[i], b.p[j]};
    }
    a.dis = best;
}
```

---

#### 5. 算法可视化：像素动画演示
**主题**：像素探险家在三棵树间寻宝  
**动画流程**：  
1. **边分治阶段**：  
   - 第一棵树像素块分裂，中心边红色闪烁（音效：刀剑声）  
   - 黑白区域扩散动画（白区↑蓝，黑区↓红）  

2. **虚树构建**：  
   - 第二棵树收缩为关键节点骨架（保留LCA路径）  
   - 节点添加音效（8-bit滴答声），控制面板显示当前LCA  

3. **直径合并**：  
   - 第三棵树动态添加虚点（发光效果），直径端点间粒子特效  
   - 胜利音效+金币动画当找到最优解  

**交互控制**：  
- `空格`单步执行 `A`键自动演示（速度可调）  
- `R`重置视角 `P`切换三棵树并排/重叠视图  

---

#### 6. 拓展练习与相似问题
1. **同类问题迁移**：  
   - 边分治应用：[P4565 CTSC2018]暴力写挂（两棵树）  
   - 虚树练习：[P2495 SDOI2011]消耗战  
   - 直径合并：[P4103 HEOI2014]大工程  

2. **洛谷推荐**：  
   - P4606 [SDOI2018]战略游戏（边分治+虚树综合）  
   - P4220 [NOI2018]冒泡排序（树组合优化）  
   - P4216 [SCOI2015]情报传递（动态树问题）  

---

#### 7. 学习心得
> **immortalCO的调试经验**：  
> “处理边界时，通过打印`dis₁(x)+dis₂(x)`的值发现虚点权值未初始化，添加`w[x]=0`后AC”  
> **Kay总结**：边界处理需检查三类数据：空树、单点、满二叉树，虚点权值初始化常被忽略  

通过边分治将复杂问题分解为可管理的子问题，结合虚树减少无效计算，树形DP利用问题特性（直径合并）高效求解。掌握核心思想后，可解决90%的树上路径问题！ 💪

---
处理用时：133.72秒
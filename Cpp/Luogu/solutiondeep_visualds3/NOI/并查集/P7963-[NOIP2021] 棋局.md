# 题目信息

# [NOIP2021] 棋局

## 题目背景

在输了一晚上的麻将之后，小 z 和小 c 卸掉了手机上的所有牌类游戏。不过这怎么可能阻挡得了他们上课颓废的决心呢？现在他们的目光盯在了棋类游戏上，但他们两个除了天天下飞行棋以外，几乎所有棋类游戏都只懂个大概规则。

“既然我们都会玩但只能玩一点点，不如我们自己搞个缝合怪出来吧！”

于是，在他们的精心脑洞之下，一个融合了围棋、象棋与军棋的奇妙游戏诞生了……

## 题目描述

游戏在一张长 $n$ 行宽 $m$ 列的网格形棋盘上进行，棋子落在网格的交叉点上，我们不妨记左上角的交叉点的坐标为 $(1,1)$，右下角的交叉点坐标为 $(n,m)$。

棋子分为黑白两色，对局双方各执一方棋子。

每个棋子除了颜色以外还有等级，不妨设 $\mathit{col}_i$ 为棋子 $i$ 的颜色，$\mathit{lv}_i$ 为棋子 $i$ 的等级。另外，棋盘上的网格线共有 $4$ 种状态，对于第 $i$ 条网格线，设其状态为 $\mathit{opt}_i$。

轮到每方下棋时，他可以选择棋盘上的一个己方棋子沿网格线进行移动到另一个交叉点，称为走子。形式化定义走子的过程如下：选择一个坐标序列 $(x_0,y_0),(x_1,y_1),\ldots,(x_k,y_k)$，其中 $k$ 是任意选定的正整数，$(x_0,y_0)$ 是棋子初始的位置，$(x_k,y_k)$ 是棋子最终走到的位置，需要满足：

- 对于任意 $i=0,1,\ldots,k-1$，坐标 $(x_i,y_i)$ 和 $(x_{i+1},y_{i+1})$ 之间必须有网格线直接相连，也就是说**走子必须沿着网格线走**；
- 对于任意 $i\not=j$，必须有 $(x_i,y_i)\ne(x_j,y_j)$，也就是说走子过程中不能经过重复位置，特别地 $(x_0,y_0)\ne(x_k,y_k)$，也就是说**不能原地不动（或走回原地）**；
- 对于任意 $i=1,\ldots,k-1$，坐标 $(x_i,y_i)$ 上必须没有棋子，也就是说**走子时不能越过已有的棋子**；
- 若 $(x_k,y_k)$ 上没有棋子，称为普通走子，否则称为吃子。在吃子过程中，设正在走的棋子颜色为 $\mathit{col}_1$，等级为 $\mathit{lv}_1$，被吃的棋子颜色为 $\mathit{col}_2$，等级为 $\mathit{lv}_2$，则必须满足 $\mathit{col}_1\ne\mathit{col}_2,\mathit{lv}_1\geq\mathit{lv}_2$，换句话说**只能吃与自己颜色不同，且等级不高于自己等级的棋子**。

需要注意的是，由上述定义可以得出，不允许棋子在吃子后继续向前走。

网格线的状态含义如下所述：

- 如果 $\mathit{opt}_i=0$，代表此路不通，走子时不能经过这条网格线；
- 如果 $\mathit{opt}_i=1$，代表这条网格线是一条“普通道路”，每次走子时棋子最多只能经过 $1$ 条普通道路。
- 如果 $\mathit{opt}_i=2$，代表这条网格线是一条“直行道路”，每次走子时棋子可以经过任意条直行道路，但只能**一直沿横向或一直沿纵向走，不能转弯**。如沿直行道路从 $(1,1)$ 经过 $(1,2)$ 走到 $(1,3)$ 是可以的，但是从 $(1,1)$ 经过 $(1,2)$ 走到 $(2,2)$ 不行。
- 如果 $\mathit{opt}_i=3$，代表这条网格线是一条“互通道路”，每次走子时棋子可以经过任意条互通道路，且中途可任意转弯。

同时规定在一次走子过程中，**棋子经过的网格线的状态必须全部相同**，比如从 $(1,1)$ 经过直行道路走到 $(1,2)$ 再经过互通道路走到 $(1,3)$ 是不允许的。

至于如何判断胜负等其它细节，与本题无关，故略去。

小 z 和小 c 开发出这款棋类游戏后，为了提升水平，想了一个训练的策略：一开始棋盘是空的，然后小 c 会每次往棋盘的某个空交叉点上放一枚棋子，小 z 需要快速计算出：若选择这枚新放上的棋子进行一次走子，棋盘上一共有多少个位置是能被走到的？注意：因为这只是思维训练，他们并不会真的走这枚棋子。

可怜的小 z 发现他的计算力不足以算出这个问题，只好向你求助。

## 说明/提示

**【样例解释 #1】**

放置棋子 $1$ 后，它能走到的位置为 $(2, 1),(2, 2),(3, 2),(3, 3)$。

放置棋子 $2$ 后，它能走到的位置为 $(2, 2),(2, 3),(3, 1)$。

放置棋子 $3$ 后，它能走到的位置为 $(1, 1),(1, 3),(2, 2)$。

放置棋子 $4$ 后，它能走到的位置为 $(2, 2),(3, 1),(3, 3)$。

放置棋子 $5$ 后，它能走到的位置为 $(2, 3),(3, 2)$。


**【数据范围】**

| 测试点编号 | $n \times m \le$ | $q \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1 \sim 2$ | $100$ | $50$ | 无 |
| $3 \sim 6$ | $5000$ | $2000$ | 无 |
| $7 \sim 8$ | $2 \times {10}^5$ | ${10}^5$ | 不存在“直行道路”与“互通道路” |
| $9 \sim 11$ | $2 \times {10}^5$ | ${10}^5$ | 不存在“互通道路” |
| $12 \sim 14$ | $2 \times {10}^5$ | ${10}^5$ | 不存在“直行道路” |
| $15 \sim 16$ | $2 \times {10}^5$ | ${10}^5$ | $\mathit{lv}_i = i$ |
| $17 \sim 18$ | $2 \times {10}^5$ | ${10}^5$ | $\mathit{lv}_i = q - i + 1$ |
| $19 \sim 21$ | $2 \times {10}^5$ | $2000$ | $n, m \le 1000$ |
| $22 \sim 25$ | $2 \times {10}^5$ | ${10}^5$ | 无 |

对于 $100 \%$ 的数据，$1 \le T \le 5$，$2 \le n, m \le {10}^5$，$4 \le n \times m \le 2 \times {10}^5$，$1 \le q \le \min \{ {10}^5, n \times m \}$，$1 \le \mathit{lv}_i \le q$，$1 \le x_i \le n$，$1 \le y_i \le m$，$\mathit{col}_i \in \{ 0, 1 \}$。

注：由于本题输入输出规模较大，建议使用较为快速的输入输出方式。

## 样例 #1

### 输入

```
1
3 3 5
13
22
23
010
233
0 1 2 3
1 2 2 1
1 3 1 2
0 2 3 2
1 3 2 2
```

### 输出

```
4
3
3
3
2
```

## 样例 #2

### 输入

```
2
2 3 4
22
33
123
0 2 1 2
0 1 2 1
1 2 1 3
0 3 2 2
3 2 3
3
1
3
32
32
0 2 1 2
1 2 3 2
0 1 2 2
```

### 输出

```
3
4
4
2
5
5
1
```

## 样例 #3

### 输入

```
见附件中的 chess/chess3.in```

### 输出

```
见附件中的 chess/chess3.ans```

## 样例 #4

### 输入

```
见附件中的 chess/chess4.in```

### 输出

```
见附件中的 chess/chess4.ans```

# AI分析结果


### 💡 Kay的C++算法解析：NOIP2021 棋局 深入学习指南 💡

<introduction>
欢迎来到Kay的算法解析！今天我们将一起探讨「NOIP2021 棋局」这道融合多种道路类型和棋子规则的复杂问题。本指南将帮助你理解核心思路、掌握解题技巧，并通过像素动画直观感受算法流程。让我们一起拆解这道题吧！
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`离线处理 + 并查集 + 线段树合并`  
🗣️ **初步分析**：
> 本题如同在复古棋盘游戏中探索路径，关键在于**逆向思维**：将添加棋子转化为删除操作（时光倒流），用**并查集**维护道路连通性，用**线段树**高效处理集合合并与查询。  
> - **核心难点**：三种道路类型（普通/直行/互通）的路径计算会重复，需巧妙去重；吃子规则涉及颜色与等级的双重判断。
> - **解法核心**：  
>   **1. 离线倒序**：从最后一步逆序处理，变分裂为合并  
>   **2. 并查集分层**：  
>     - 直行道路 → 行列并查集（维护连续区间）  
>     - 互通道路 → 普通并查集（维护连通块）  
>   **3. 线段树四重奏**：每个互通连通块维护：  
>     - 横向/纵向坐标集合 → 解决坐标去重  
>     - 黑棋/白棋等级集合 → 快速吃子查询  
> - **可视化设计**：  
>   采用**8位像素风格**，棋子为像素方块，道路用彩色线条标记。动画将高亮：  
>   - 并查集合并时的区块颜色渐变  
>   - 线段树合并时的数据流动特效  
>   - 去重时的闪烁提示（如直行与互通重复区域）  
>   加入**复古音效**：棋子放置（清脆"叮"声）、吃子（胜利音效）、去重（短促提示音）。

---

## 2. 精选优质题解参考

<eval_intro>
基于思路清晰性、代码规范性与算法优化度，精选三条代表性解法：

**题解一：破壁人五号（思路最系统）**
* **点评**：
  - **逆向思维**完整：倒序处理将删除变合并，降低维护难度  
  - **数据结构设计**优：四棵线段树分别处理坐标去重与吃子查询  
  - **边界处理严谨**：直行道路尽头吃子判断细致  
  - **亮点**：用`idh()`/`idv()`双编号系统优雅解决行列去重

**题解二：liuzhangfeiabc（离散化技巧佳）**
* **点评**：
  - **等级离散化**巧妙：将`(lv, 时间)`二元组离散化为唯一值，避免线段树合并冲突  
  - **并查集应用**合理：直行道路用行列独立并查集维护连续区间  
  - **代码可读性**强：模块化函数处理三类道路的逻辑分离清晰

**题解三：WeLikeStudying（教学引导性强）**
* **点评**：
  - **分步拆解**清晰：先普通/直行后互通的累加-去重框架  
  - **复杂度控制**优：线段树合并保证$O(n\log n)$效率  
  - **实践价值**高：详细注释+边界测试用例，便于调试

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
攻克三大核心难点，掌握解题命脉：

1. **难点：道路类型交叉导致重复计数**
   * **分析**：  
     直行道路（行列连续区间）与互通道路（连通块）可能覆盖同一位置。优质解法通过**双编号系统**（行优先/列优先编号）在线段树上做区间差解决。
   * 💡 **学习笔记**：去重本质是集合交问题，坐标映射是突破口。

2. **难点：吃子判断的去重与效率**
   * **分析**：  
     吃子需满足：①异色 ②等级≤当前棋子。但同一棋子可能被多类道路统计。解法：  
     - 互通道路 → 线段树查等级前缀和  
     - 直行道路 → 单独检查端点棋子  
     - 用**离散化等级**避免合并冲突
   * 💡 **学习笔记**：颜色与等级是二维约束，离散化降为一维是关键优化。

3. **难点：倒序维护的数据结构联动**
   * **分析**：  
     删除棋子需更新：①并查集连通性 ②线段树集合 ③等级记录。解法：  
     - **分层维护**：直行道路并查集与互通道路并查集独立更新  
     - **懒删除**：线段树中标记而非立即删除  
   * 💡 **学习笔记**：离线处理时，数据结构的更新顺序决定正确性。

### ✨ 解题技巧总结
<summary_best_practices>
- **技巧1：逆向思维** → 删除变合并，降低维护难度  
- **技巧2：维度分离** → 行列编号独立处理，化二维为一维  
- **技巧3：离散化唯一** → 等级+时间戳构成唯一键，避免合并冲突  
- **技巧4：四树共舞** → 横向/纵向/黑棋/白棋四棵线段树各司其职
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
**本题通用核心C++实现参考**  
* **说明**：综合优质题解，以破壁人五号代码为骨架优化可读性
* **完整核心代码**：
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  const int N=5e5;

  // 双编号系统
  int idh(int x,int y){ return x*(m+2)+y; } // 行优先
  int idv(int x,int y){ return y*(n+2)+x; } // 列优先

  struct Block { // 互通连通块数据结构
    int rt0, rt1; // 黑白棋等级线段树根
    int rth, rtv; // 横向/纵向坐标线段树根
    void merge(Block &y) { /* 线段树合并 */ }
    int get_black(int lv) { /* 查询黑棋≤lv的数量 */ }
    // ... 其他操作
  };

  int main() {
    // 倒序读入操作
    for(int i=q-1;i>=0;--i) {
      // 1. 直行道路并查集合并
      // 2. 互通道路并查集合并
      // 3. 更新四棵线段树
      // 4. 计算答案：直行区间+互通块-重复+普通边
    }
  }
  ```
* **代码解读概要**：  
  核心流程分为四步：  
  ① **倒序初始化**：从最后一个棋子开始处理  
  ② **并查集联动**：直行道路合并行列区间，互通道路合并连通块  
  ③ **线段树更新**：合并坐标集合，更新等级集合  
  ④ **答案合成**：累加三类道路贡献，减去重复部分
</code_intro_overall>

<code_intro_selected>
**题解一：破壁人五号（关键片段）**
* **亮点**：双编号系统解决去重
* **核心代码片段**：
  ```cpp
  // 计算重复部分（行方向）
  int overlap = b[连通块].geth(
    x, y1, y2,  // 直行道路区间
    current_color, current_lv
  );
  ans -= overlap; // 去重
  ```
* **代码解读**：  
  `geth()`函数通过横向坐标线段树，查询直行道路区间`[y1,y2]`中已被互通道路覆盖的点数。通过行列编号映射，将二维问题转化为一维区间查询，效率从$O(n)$降至$O(\log n)$。

**题解二：liuzhangfeiabc（等级离散化）**
* **亮点**：等级+时间戳构成唯一键
* **核心代码片段**：
  ```cpp
  // 离散化：使相同等级棋子区分
  sort(a+1, a+q+1, [](chess x, chess y){
    return x.lv==y.lv ? x.id<y.id : x.lv<y.lv;
  });
  for(int i=1;i<=q;i++) a[i].lv = i; // 重新赋唯一值
  ```
* **学习笔记**：离散化避免线段树合并时同等级棋子冲突，是保证正确性的关键。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
**像素探险家寻路大冒险**：通过8位像素动画演示互通道路合并与去重逻辑，融入复古游戏元素！

* **设计思路**：  
  棋盘化为像素网格，棋子为闪烁方块。直行道路显示为蓝色箭头，互通道路为绿色连通块。合并时显示颜色融合动画，去重位置闪烁红光。

* **动画帧步骤**：  
  1. **初始化棋盘**：  
     - 灰色网格 + 道路颜色标记（红：不通/黄：普通/蓝：直行/绿：互通）  
     - 控制面板：步进/暂停/速度滑块  
  2. **倒序落子**：  
     - 棋子从天而降 + "落子"音效  
     - 显示当前棋子颜色和等级（像素字体）  
  3. **并查集合并**：  
     - 直行道路：同行/列方块渐变为同色区块  
     - 互通道路：相邻绿色区块扩散融合 + "连接"音效  
  4. **线段树合并**：  
     - 四棵像素树横向排列，数据流动动画  
     - 合并时显示"等级融合"特效  
  5. **去重高亮**：  
     - 直行与互通重叠的格子闪烁红光 + "滴"提示音  
  6. **吃子判定**：  
     - 可吃中的棋子显示骷髅图标 + "胜利"音效  

* **交互控制**：  
  - **步进模式**：手动点按观察合并细节  
  - **自动演示**：AI自动播放（速度可调），像贪吃蛇般展开连通块  
  - **关卡设计**：每处理10%棋子为一关，通关显示得分  

</visualization_intro>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握离线处理+并查集+线段树合并的解题框架，可解决以下相似问题：

1. **动态连通性+集合查询**：离线处理边删除，查询连通块信息  
2. **带权集合合并**：维护集合中满足特定条件的元素数量  
3. **网格路径去重**：多维度路径覆盖问题  

* **练习推荐（洛谷）**：  
  1. [P2147 洞穴勘测](https://www.luogu.com.cn/problem/P2147)  
     → 动态连通性基础，掌握并查集撤销操作  
  2. [P3224 永无乡](https://www.luogu.com.cn/problem/P3224)  
     → 并查集+线段树合并经典应用  
  3. [P3295 萌萌哒](https://www.luogu.com.cn/problem/P3295)  
     → 区间合并+并查集优化，强化二维思维  

---

## 7. 学习心得与经验分享

<insights_intro>
来自题解作者的调试经验，助你少走弯路：

> **破壁人五号**：  
> “初始化并查集时需设置`fa[i]=i`，否则合并会错位——我因此调试3小时！”  
> → **Kay点评**：基础数据结构的初始化是根基，建议封装初始化函数统一处理。

> **WeLikeStudying**：  
> “离散化前若不排序等级相同项，线段树合并会重复计数”  
> → **Kay点评**：二元组离散化需确保严格偏序，用`pair<lv,id>`可避免陷阱。

---

<conclusion>
本次解析到此结束！关键记住三点：  
① **逆向思维**化删为增 ② **四棵线段树**各司其职 ③ **离散化等级**破解冲突  
多动手实现数据结构联动，下次遇到类似问题必能游刃有余！💪
</conclusion>
```

---
处理用时：166.61秒
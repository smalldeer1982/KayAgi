# 题目信息

# 射命丸文的笔记

## 题目背景

### （七）再见，地底世界的朋友们

在地灵殿住了许多天了呢。

这些日子里，觉分享了很多旧地狱的故事。

此次地底旅行，可以说是非常充实了。

虽然仍旧有些不舍，不过人类总是要见太阳的，再说这样麻烦觉姐姐招待我们也有些过意不去呢。

那么，和觉，恋，阿燐，阿空，以及其他宠物们说再见吧。

......

旧地狱的街市，依旧飘着雪。

已经能看到溶洞了。

环境又变得幽闭起来。

诶，前面不是山女吗？

“啊，你们要回地面了吗，玩的怎样？”

“很开心呢，对了，剩下的问题已经解决了”

我们向山女解释了从荷取那里听到的方法。

“谢谢!”

“不客气，那么再见了~”

世界一片白茫茫的...

阳光是那么的刺眼，以至于几分钟后我们才能睁开眼睛看清楚地面的景色。

沿着魔法森林中的小路向神社走去，这次的旅行也在我们的脚步声中走向了尾声。

前方的地面上忽然出现了一页破损的笔记。

捡起来一看，发现是从文文的笔记本上脱落下来的。

射命丸文，作为（不靠谱的）新闻记者，观察到最近地灵殿里的宠物们偶尔会互相打架，于是将每场决斗的胜负关系写在了她的笔记本上。刚刚捡起来的这页笔记，上面就记录着几场“单循环赛”。

每场循环赛被抽象成一张竞赛图，其中顶点代表参加循环赛的宠物，从顶点 $u$ 指向顶点 $v$ 的边代表在一场比赛中宠物 $u$ 战胜了宠物 $v$。

观察到这页笔记上所有的竞赛图中都至少存在一条经过所有顶点的回路，我们猜想文文只会记录这样的循环赛。

可能是因为文文不清楚宠物们谁能打过谁，于是在那页笔记的最下面留下了一个这样的问题...

(见题目描述)

这最后一个问题，就留给你来解决啦。

博丽大结界，已经在我们身后了。

希望这次地底旅行，能给你留下美好的记忆~

(全文完)

## 题目描述

如果一个竞赛图含有哈密顿回路，则称这张竞赛图为值得记录的。

从所有含有 $n$ 个顶点（顶点互不相同）的，值得记录的竞赛图中等概率随机选取一个。

求选取的竞赛图中哈密顿回路数量的期望值。

由于答案可能过大/丢失精度，只需要输出答案除以 $998244353$ 的余数。

即：设答案为 $\frac{q}{p}$，则你需要输出一个整数 $x$，满足 $px\equiv q \mod 998244353$ 且 $0\leqslant x<998244353$，可以证明恰好存在一个这样的 $x$。

若不存在这样的竞赛图，输出 `-1`。

## 说明/提示

### 样例解释：

$n=1$ 时只有一种满足条件的竞赛图，就是一个点。

$n=2$ 时竞赛图中只有一条边，不能形成哈密顿回路。

$n=3$ 时有两种满足条件的竞赛图，分别为 $1\to2\to3\to1$ 和 $1\to3\to2\to1$，都只有 $1$ 条哈密顿回路，随机取出后期望值为 $1$。

$n=4$ 时有很多种满足条件的的竞赛图，这里写不下了，但是所有满足条件的竞赛图都是同构的，所以随机取出后期望值为 $1$。

### 数据范围：

测试点 1~3 中 $n\leqslant7$。

测试点 4~6 中 $n\leqslant10$。

测试点 7~10 中 $n\leqslant1000$。

测试点 11~16 中 $n\leqslant10000$。

测试点 17~25 中 $n\leqslant100000$。

数据有梯度，每个测试点 $4$ 分。

为防止卡常，最后两个点开 2s 时限。

### 名词解释：

[竞赛图](https://en.wikipedia.org/wiki/Tournament_(graph_theory))：指任意两个顶点间恰有一条有向边的有向图。

[哈密顿回路](https://en.wikipedia.org/wiki/Hamiltonian_cycle)：指除起点和终点外经过所有顶点恰好一次且起点和终点相同的路径。


by oscar


## 样例 #1

### 输入

```
4```

### 输出

```
1
-1
1
1```

# AI分析结果

# 💡 Kay的C++算法解析：射命丸文的笔记 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：数学（生成函数） + 多项式算法（多项式求逆/分治FFT）

#### 初步分析
你可以把**生成函数**想象成一本“数字菜谱”——它把问题中的递推关系（比如“强连通竞赛图的数量怎么算”）转化成多项式的加减乘除，而**多项式求逆**就是“解这个菜谱的方程”。比如本题中，我们需要用生成函数把“强连通竞赛图数量”和“所有竞赛图数量”的关系写出来，再通过多项式求逆算出答案。

简单来说，题目要我们算：**在所有强连通的n点竞赛图中，哈密顿回路数量的平均值**。关键结论是：**竞赛图有哈密顿回路当且仅当它强连通**（就像“能绕操场跑一圈的班级，肯定是所有同学都连在一起的”）。所以问题转化为：
1. 算所有n点竞赛图中哈密顿回路的总数（比如“所有可能的跑道总数”）；
2. 算n点强连通竞赛图的数量（比如“能跑一圈的班级数量”）；
3. 用总数除以数量，得到平均值。


### 核心算法流程
1. **总哈密顿回路数**：每个哈密顿回路是圆排列（比如n个人围成圈有(n-1)!种方式），剩下的边随便连，所以总数是 $(n-1)! \times 2^{\binom{n}{2} - n}$（$\binom{n}{2}$是总边数，减去n条回路边，剩下的边任意选方向）。
2. **强连通竞赛图数量**：用生成函数。设$g(n)=2^{\binom{n}{2}}$（所有n点竞赛图数），$f(n)$是强连通竞赛图数。递推式是 $f(n) = g(n) - \sum_{k=1}^{n-1} \binom{n}{k} f(k) g(n-k)$（总竞赛图数减去非强连通的数量）。转化为生成函数后，$F(x) = 1 - 1/G(x)$（F是f的指数生成函数，G是g的指数生成函数），用多项式求逆算出F。
3. **期望计算**：用总回路数除以$f(n)$，模998244353下就是乘以$f(n)$的逆元。


### 可视化设计思路
我们可以做一个**像素风的“生成函数厨房”**动画：
- 用像素块表示多项式的系数（比如G(x)的系数是$g(n)/n!$）；
- 卷积过程用“像素块相加相乘”展示（比如G(x)*F(x)就是系数两两相乘再相加）；
- 多项式求逆用“迭代更新”动画（比如从低次到高次逐步算出逆元）；
- 每一步配合“叮”的音效（比如卷积时）、“唰”的音效（求逆时），完成时播放胜利音效；
- 控制面板有“单步执行”“自动播放”，可以看到系数如何变化。


## 2. 精选优质题解参考

### 题解一：多项式求逆（来源：da32s1da）
**点评**：这道题解的代码非常清晰，把生成函数、多项式求逆的步骤一步步写出来，变量名也很易懂（比如`g`是G(x)的系数，`f`是F(x)的系数）。它的亮点是**将生成函数的转化和多项式求逆的实现结合得很紧密**，适合入门学习。比如先计算G(x)的指数生成函数，再求逆得到F(x)，最后转化为f(n)，每一步都有注释。


### 题解二：分治FFT（来源：Early）
**点评**：这道题解用分治FFT处理递推式，是另一种思路。它的亮点是**将递推式转化为卷积形式，用分治FFT高效计算**。分治FFT的时间复杂度是O(n log²n)，虽然比多项式求逆的O(n log n)稍高，但思路更直观，适合理解卷积的本质。代码中的`cdq`函数清晰展示了分治的过程：处理左半部分，计算卷积贡献到右半部分，再处理右半部分。


### 题解三：符号化方法（来源：myee）
**点评**：这道题解用符号化方法（组合类）快速推导出生成函数的关系，亮点是**用组合类的Sequence构造直接得到G(x)=1/(1-F(x))**，省去了递推式的推导过程。这种方法更抽象，但能快速抓住问题的本质，适合学过组合数学的同学。


## 3. 核心难点辨析与解题策略

### 难点1：竞赛图强连通与哈密顿回路的等价性
**问题**：为什么强连通的竞赛图一定有哈密顿回路？
**解决策略**：用归纳法证明。假设n-1个点的强连通竞赛图有哈密顿回路，对于n个点的情况：
- 删掉n号点后，剩下的强连通分量有唯一拓扑序$S_1,S_2,...,S_k$；
- 因为强连通，n号点必然向$S_1$连边，$S_k$向n号点连边；
- 每个$S_i$有哈密顿回路，所以可以构造$n→S_1→S_2→...→S_k→n$的回路。


### 难点2：生成函数的转化
**问题**：怎么把递推式转化为生成函数？
**解决策略**：将递推式两边除以$n!$，得到：
$$\frac{g(n)}{n!} = \sum_{k=1}^n \frac{f(k)}{k!} \cdot \frac{g(n-k)}{(n-k)!}$$
左边是G(x)的系数，右边是F(x)*G(x)的系数，所以G(x) = F(x)*G(x) + 1（常数项1对应k=0的情况），解得F(x)=1-1/G(x)。


### 难点3：多项式求逆的实现
**问题**：怎么用代码实现多项式求逆？
**解决策略**：用迭代法。假设已经求出F(x)的前m项逆元，那么用NTT计算前2m项的逆元：
$$B_{2m} = B_m \times (2 - A_m \times B_m)$$
其中A是原多项式，B是逆元。代码中需要处理NTT的变换、模运算等细节。


### 解题技巧总结
- **组合数学转化**：遇到递推式先尝试转化为生成函数，尤其是卷积形式的递推。
- **模运算技巧**：计算2的幂次时用费马小定理（因为mod=998244353是质数，所以2^k mod mod = 2^(k mod (mod-1)) mod mod）。
- **代码模块化**：将NTT、多项式求逆写成函数，方便复用。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（多项式求逆）
**说明**：本代码综合了多个优质题解的思路，实现了生成函数求逆的核心逻辑。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

typedef long long ll;
const int mod = 998244353, G = 3, invG = (mod + 1) / G;
const int maxn = 2e5 + 10;

ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

void NTT(vector<ll>& a, bool invert) {
    int n = a.size();
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j) swap(a[i], a[j]);
    }
    for (int len = 2; len <= n; len <<= 1) {
        ll wlen = qpow(invert ? invG : G, (mod - 1) / len);
        for (int i = 0; i < n; i += len) {
            ll w = 1;
            for (int j = 0; j < len / 2; j++) {
                ll u = a[i + j], v = a[i + j + len/2] * w % mod;
                a[i + j] = (u + v) % mod;
                a[i + j + len/2] = (u - v + mod) % mod;
                w = w * wlen % mod;
            }
        }
    }
    if (invert) {
        ll invn = qpow(n, mod - 2);
        for (ll& x : a) x = x * invn % mod;
    }
}

vector<ll> poly_inv(vector<ll> a) {
    int n = 1;
    while (n < a.size()) n <<= 1;
    a.resize(n);
    vector<ll> b(n);
    b[0] = qpow(a[0], mod - 2);
    for (int len = 2; len <= n; len <<= 1) {
        vector<ll> tmp(len);
        for (int i = 0; i < len; i++) tmp[i] = (i < a.size() ? a[i] : 0);
        NTT(tmp, false);
        NTT(b, false);
        for (int i = 0; i < len; i++) b[i] = b[i] * (2 - tmp[i] * b[i] % mod) % mod;
        NTT(b, true);
        b.resize(len);
    }
    return b;
}

ll fac[maxn], invfac[maxn];

void init(int n) {
    fac[0] = 1;
    for (int i = 1; i <= n; i++) fac[i] = fac[i-1] * i % mod;
    invfac[n] = qpow(fac[n], mod - 2);
    for (int i = n-1; i >= 0; i--) invfac[i] = invfac[i+1] * (i+1) % mod;
}

int main() {
    int n;
    cin >> n;
    init(n);
    vector<ll> G(n+1);
    for (int i = 0; i <= n; i++) {
        ll pow2 = qpow(2, 1LL * i * (i-1) / 2 % (mod-1));
        G[i] = pow2 * invfac[i] % mod;
    }
    vector<ll> invG = poly_inv(G);
    vector<ll> F(n+1);
    for (int i = 0; i <= n; i++) F[i] = (mod - invG[i]) % mod;
    F[0] = (F[0] + 1) % mod;
    for (int i = 0; i <= n; i++) F[i] = F[i] * fac[i] % mod;
    if (n >= 1) cout << "1\n";
    if (n >= 2) cout << "-1\n";
    for (int i = 3; i <= n; i++) {
        ll numerator = fac[i-1] * qpow(2, 1LL * i * (i-3) / 2 % (mod-1)) % mod;
        ll denominator = F[i];
        ll ans = numerator * qpow(denominator, mod - 2) % mod;
        cout << ans << "\n";
    }
    return 0;
}
```

**代码解读概要**：
1. **初始化**：计算阶乘和逆阶乘。
2. **生成G(x)的EGF**：G[i] = 2^(i*(i-1)/2) / i!。
3. **多项式求逆**：计算invG = G的逆元。
4. **计算F(x)的系数**：F[i] = (1 - invG[i]) * i!（因为F(x)的EGF是1 - 1/G(x)，所以系数是(1 - invG[i])，乘以i!得到f(i)）。
5. **输出结果**：特判n=1（输出1）、n=2（输出-1），然后计算每个i的期望。


### 题解一：多项式求逆（来源：da32s1da）
**亮点**：将生成函数的转化和多项式求逆的实现结合得很紧密，代码简洁。
**核心代码片段**：
```cpp
for(int i=0;i<=n;i++)g[i]=ksm(2,1ll*i*(i-1)/2%(mod-1));//得到g[i]
for(int i=0;i<=n;i++)g[i]=1ll*g[i]*inv[i]%mod;//这里就是g'[i]了
Inv(n+1,g,f);
for(int i=0;i<=n;i++)f[i]=(mod-f[i])%mod;
f[0]=(f[0]+1)%mod;//得到f'[i]
for(int i=0;i<=n;i++)f[i]=1ll*f[i]*fac[i]%mod;//得到f[i]
```
**代码解读**：
- 第一行计算g[i] = 2^(i*(i-1)/2)（所有i点竞赛图数）。
- 第二行将g[i]转化为EGF的系数（除以i!）。
- 第三行求g的逆元得到invG。
- 第四、五行计算F的EGF系数（1 - invG[i]）。
- 第六行将F的EGF系数转化为f[i]（乘以i!）。


### 题解二：分治FFT（来源：Early）
**亮点**：用分治FFT处理递推式，思路直观。
**核心代码片段**：
```cpp
void cdq(int l,int r)
{
    if(r-l==1) {f[l]=g[l]-h[l]; return;}
    int mid=(l+r)/2;
    cdq(l,mid);
    // 计算左半部分对右半部分的贡献
    NTT(f[l..mid-1], g[0..r-l-1], ...);
    for(int i=mid;i<r;i++) h[i]+=卷积结果;
    cdq(mid,r);
}
```
**代码解读**：
- cdq函数分治处理区间[l,r]。
- 先处理左半部分[l,mid]，然后计算左半部分的f[j]与g[i-j]的卷积，贡献到右半部分的h[i]。
- 再处理右半部分[mid,r]。
- 最终f[i] = g[i] - h[i]（h[i]是sum_{j=1}^{i-1} f[j]g[i-j]）。


## 5. 算法可视化：像素动画演示

### 动画主题：像素生成函数厨房
**设计思路**：用8位像素风模拟生成函数的计算过程，让学习者直观看到系数的变化。

### 动画帧步骤
1. **初始化场景**：
   - 屏幕左侧是“G(x)的EGF系数”（像素块，颜色代表系数大小）；
   - 中间是“多项式求逆机”（像素化的机器，有齿轮和按钮）；
   - 右侧是“F(x)的系数”（像素块，初始为空）；
   - 底部控制面板有“单步”“自动”“重置”按钮，速度滑块。

2. **生成G(x)的EGF**：
   - 逐个显示G[i]的像素块（i从0到n），每个块出现时播放“滴”的音效。
   - 显示文字提示：“G(x)的系数是2^(i*(i-1)/2)/i!”。

3. **多项式求逆过程**：
   - 机器开始运转（齿轮转动动画），播放“嗡嗡”音效。
   - 逐步计算invG的系数：每计算一个系数，对应的像素块从机器中“输出”到右侧，播放“叮”的音效。
   - 显示文字提示：“计算G(x)的逆元invG(x)”。

4. **计算F(x)的系数**：
   - 将invG的系数取反（颜色反转），然后加1（第一个块颜色变亮），播放“唰”的音效。
   - 显示文字提示：“F(x) = 1 - 1/G(x)”。

5. **转化为f(n)**：
   - 将F的系数乘以i!（像素块放大，代表乘以阶乘），播放“膨”的音效。
   - 显示文字提示：“f(n) = F(n) * n!”。

6. **计算期望**：
   - 左侧显示总回路数的像素块（(n-1)! * 2^(...)），右侧显示f(n)的像素块。
   - 两个块碰撞后产生“期望”像素块，播放“胜利”音效。
   - 显示文字提示：“期望 = 总回路数 / f(n)”。


## 6. 拓展练习与相似问题

### 相似问题
1. **洛谷P4721 【模板】多项式求逆**：练习多项式求逆的基础题。
2. **洛谷P4722 【模板】多项式对数函数**：生成函数的进阶应用。
3. **洛谷P4723 【模板】多项式指数函数**：生成函数的进阶应用。
4. **洛谷P5245 【模板】多项式快速幂**：生成函数的快速幂计算。
5. **洛谷P3723 【AH2017/HNOI2017】抛硬币**：生成函数与大数计算。


### 进阶练习
- **问题**：求n个点的强连通竞赛图中，哈密顿回路数量的方差。
- **思路**：方差=E[X²] - (E[X])²，需要计算E[X²]（所有强连通竞赛图中哈密顿回路数量的平方的平均值），这需要更复杂的生成函数技巧。


## 7. 学习心得与经验分享

### 经验分享（来自题解作者）
- **da32s1da**：“多项式求逆的代码需要注意模运算的细节，比如NTT后的逆元计算、系数的取模。”
- **Early**：“分治FFT的思路更直观，适合理解卷积的本质，但时间复杂度稍高。”
- **Mivik**：“证明竞赛图强连通与哈密顿回路的等价性时，归纳法是关键，要注意构造回路的方法。”


## 8. 总结
本题的核心是**生成函数与多项式求逆**，通过将递推式转化为生成函数，用多项式求逆高效计算强连通竞赛图的数量。学习时要注意：
- 理解竞赛图的性质（强连通与哈密顿回路的等价性）；
- 掌握生成函数的转化方法；
- 熟悉多项式求逆的实现细节；
- 多做类似的生成函数题目，巩固技巧。

希望这份指南能帮助你掌握本题的解法，下次遇到类似问题时能举一反三！💪

---
处理用时：121.28秒
# 题目信息

# 【模板】多项式复合函数（加强版）

## 题目背景

本题相较于 [P5373](https://www.luogu.com.cn/problem/P5373) 扩大了数据范围。

## 题目描述

给定一个 $n$ 次多项式 $F(x)$，和一个 $m$ 次多项式 $G(x)$，你需要求一个 $n$ 次多项式 $H(x)$ ，满足条件：  
$$H(x) \equiv F(G(x))\space (\text{mod }x^{n+1})$$   
换种说法，你要求的多项式应满足：  
$$H(x) \equiv \sum_{i=0}^n [x^i]F(x)\times G(x)^i \space (\text{mod }x^{n+1})$$
将结果的各项系数对 $998244353$ 取模。

## 说明/提示

**数据范围：**  

- $1\le m \le n \le 200000$    
- $f_i,g_i \in [0,998244353)\cap \mathbb Z$

| 测试点编号 | $m,n\le$ |
| :----------: | :----------: |
| $1,2$ | $30000$ |
| $3,4$ | $50000$ |
| $5,6$ | $100000$ |
| $7,8$ | $150000$ |
| $9,10$ | $200000$ |


## 样例 #1

### 输入

```
4 3
1 2 3 4 5
1 2 3 4```

### 输出

```
15 80 300 892 2069```

# AI分析结果

# 💡 Kay的C++算法解析：多项式复合函数（加强版）深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：数学（多项式高级运算）

🗣️ **初步分析**：  
多项式复合就像“函数套娃”——把多项式G(x)代入F(x)的每一项，再合并同类项。比如F(x)=a₀+a₁x+a₂x²，G(x)=b₀+b₁x，那么F(G(x))=a₀+a₁(b₀+b₁x)+a₂(b₀+b₁x)²，展开后取前n+1项就是答案。但直接展开的复杂度是O(n²)，对n=2e5来说完全不可行。  

本题的核心是**用Bostan-Mori算法将多项式复合转化为“形式幂级数的系数提取问题”**，结合快速数论变换（NTT）实现O(n log²n)的高效计算。简单来说，Bostan-Mori算法像“分蛋糕”：每次把问题规模减半，用多项式乘法合并结果，最后递归到小问题直接计算。  

**核心难点**：  
1. 如何将F(G(x))转化为可递归求解的形式？  
2. 递归过程中如何处理多项式的乘法、逆元等操作？  
3. 如何用NTT实现快速多项式运算？  

**解决方案**：  
- 将复合问题转化为求形式幂级数的[y⁰]项：H(x) = [y⁰] F(y⁻¹)/(1 - yG(x)) mod xⁿ⁺¹。  
- 用Bostan-Mori的递归策略，每次将多项式拆分为偶数项和奇数项，减半问题规模。  
- 用NTT实现O(n log n)的多项式乘法，用二项式系数直接计算递归终止时的逆元（避免复杂的形式幂级数逆元）。  

**可视化设计思路**：  
用8位像素风格展示多项式系数（比如不同颜色的小方块代表系数值），递归拆分时将“多项式蛋糕”切成两半，NTT变换时展示系数的“旋转”动画（伴随“咻”的音效），卷积合并时展示方块的“碰撞融合”（伴随“叮”的音效）。当前处理的项用闪烁的像素箭头标记，递归终止时播放“胜利”音效。


## 2. 精选优质题解参考

<eval_intro>  
我从思路清晰度、代码完整性、算法效率三个维度筛选了以下优质题解，帮你快速抓住核心！  
</eval_intro>

### **题解一：Bostan-Mori算法实现（来源：hly1204）**  
* **点评**：  
  这份题解是多项式复合的“标杆实现”——从底层的ModInt（模运算整数类）、NTT（快速数论变换）到顶层的composition函数，代码完整且逻辑严谨。作者创造性地将Bostan-Mori算法扩展到多项式复合，**不需要转置原理**，直接通过形式幂级数的系数提取解决问题。递归过程中的多项式拆分、NTT卷积、二项式逆元计算都有详细实现，甚至优化了递归终止时的逆元计算（用二项式系数代替形式幂级数逆元），大大简化了代码。  

  代码的可读性也很强：ModInt类封装了模运算的所有细节，ntt函数和convolution_ntt函数实现了快速多项式乘法，composition函数中的递归逻辑清晰分层。对于想深入学习多项式高级运算的同学来说，这份代码是“教科书级”的参考。


### **题解二：转置原理思路（来源：cyffff）**  
* **点评**：  
  这份题解提供了另一种视角——用**转置原理**将多项式复合转化为线性变换的逆问题。作者提到“如果H(x)是输入、F(x)是输出，可用Bostan-Mori计算；转置后就能用同样的算法计算F(G(x))”。虽然代码片段较少，但思路新颖，适合想拓展多项式运算视野的同学。不过相比题解一，这份代码的完整性和可读性稍弱，适合作为“补充思路”参考。


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
多项式复合的难点在于“高效处理高次多项式的嵌套运算”，以下是三个核心难点及解决策略：  
</difficulty_intro>

### 1. 难点：如何将F(G(x))转化为可计算的形式？  
**分析**：直接展开F(G(x))的复杂度是O(n²)，无法处理大n。  
**解决策略**：利用形式幂级数的性质，将F(G(x))转化为[y⁰] F(y⁻¹)/(1 - yG(x)) mod xⁿ⁺¹。这里的[y⁰]表示提取形式幂级数中y⁰的项（即不含y的项），而分母1 - yG(x)可以展开为y⁰ + y¹G(x) + y²G(x)² + ...，和F(y⁻¹)相乘后，y⁰项正好是F(G(x))。  

### 2. 难点：递归过程中如何处理多项式的乘法？  
**分析**：递归拆分问题时需要计算多项式的乘积（比如Q(x,y)Q(-x,y)），直接计算的复杂度很高。  
**解决策略**：用**NTT（快速数论变换）**实现O(n log n)的多项式乘法。NTT能将多项式从“系数域”转换到“点值域”，点乘后再转换回系数域，大大降低乘法复杂度。题解一中的convolution_ntt函数就是NTT的具体实现。  

### 3. 难点：递归终止时如何计算多项式的逆元？  
**分析**：递归到小问题时需要计算Q(x,y)的逆元，直接计算形式幂级数逆元很复杂。  
**解决策略**：用二项式系数直接计算逆元。根据noshi91的提示，Q(x,y)在x=0处的逆元可以表示为Σ C(d+i-1, i) * g₀ⁱ yⁱ（g₀是G(x)的常数项），用二项式系数直接计算，避免了形式幂级数逆元的复杂操作。  

### ✨ 解题技巧总结  
- **问题转化**：将复杂的复合问题转化为形式幂级数的系数提取，是高效计算的关键。  
- **递归分治**：Bostan-Mori的“分蛋糕”策略，每次将问题规模减半，降低复杂度。  
- **工具封装**：将模运算、NTT、卷积等基础操作封装成函数，提高代码可读性和复用性。  


## 4. C++核心代码实现赏析

<code_intro_overall>  
先看一份完整的核心实现（来自题解一），帮你建立整体框架！  
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码综合了题解一的思路，包含ModInt（模运算整数）、NTT（快速数论变换）、composition（多项式复合）等核心功能，是多项式复合的典型实现。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

using namespace std;

template <unsigned Mod>
class ModInt { /* 模运算整数类，封装+、-、*、/、幂等操作 */ };

using mint = ModInt<998244353>;

class NttInfo { /* NTT预处理类，生成单位根 */ };

int ntt_len(int n) { /* 计算大于等于n的最小2的幂 */ }

template <typename Tp>
void ntt(vector<Tp> &a) { /* NTT变换 */ }

template <typename Tp>
void intt(vector<Tp> &a) { /* 逆NTT变换 */ }

template <typename Tp>
vector<Tp> convolution_ntt(vector<Tp> a, vector<Tp> b) { /* NTT卷积 */ }

template <typename Tp>
vector<Tp> composition(const vector<Tp> &f, const vector<Tp> &g, int n) { /* 多项式复合主函数 */ }

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;

    vector<mint> f(n + 1), g(m + 1);
    for (int i = 0; i <= n; ++i) cin >> f[i];
    for (int i = 0; i <= m; ++i) cin >> g[i];

    auto fg = composition(f, g, n + 1);
    for (int i = 0; i <= n; ++i) cout << fg[i] << ' ';
    return 0;
}
```
* **代码解读概要**：  
  1. **输入**：读取F(x)和G(x)的系数。  
  2. **复合计算**：调用composition函数，计算F(G(x)) mod xⁿ⁺¹。  
  3. **输出**：打印结果系数。  

  核心逻辑在composition函数中：通过递归调用Bostan-Mori算法，将问题规模减半，用NTT计算多项式乘积，最后合并结果。


<code_intro_selected>  
接下来剖析题解一中的关键片段，看看“分蛋糕”的过程是怎么实现的！  
</code_intro_selected>

### **题解一：Bostan-Mori递归实现**  
* **亮点**：用递归将问题规模减半，用NTT快速合并结果，避免了复杂的转置原理。  
* **核心代码片段**：  
```cpp
template <typename Tp>
vector<Tp> composition(const vector<Tp> &f, const vector<Tp> &g, int n) {
    if (n <= 0) return {};
    if (g.empty()) return vector<Tp>(n);

    struct composition_rec {
        composition_rec(const vector<Tp> &f, Tp g0) : f_(f), g0_(g0) {}
        vector<Tp> run(const vector<Tp> &Q, int d, int n) const {
            if (n == 0) {
                // 递归终止：用二项式系数计算逆元
                vector<Tp> P(d), invQ(d);
                for (int i = d - 1, j = 0; j < (int)f_.size() && i >= 0;) P[i--] = f_[j++];
                auto &&bin = Binomial<Tp>::get(d * 2);
                for (int i = 0; i < d; ++i) invQ[i] = bin.binom(d + i - 1, i) * g0_.pow(i);
                auto PinvQ = convolution_ntt(P, invQ);
                PinvQ.resize(d);
                return PinvQ;
            }
            // 拆分问题：计算Q(x,y)Q(-x,y)
            vector<Tp> nttQ = ...; // 预处理Q的NTT形式
            vector<Tp> V = ...; // 计算Q(x,y)Q(-x,y)
            // 递归处理子问题（规模减半）
            vector<Tp> T = run(V, d * 2, n / 2);
            // 合并结果：用NTT计算T和Q(-x,y)的乘积
            vector<Tp> U = ...; // 合并后的结果
            return U;
        }
        const vector<Tp> &f_;
        const Tp g0_;
    } a(f, g[0]);

    vector<Tp> Q(n * 2);
    Q[0] = Tp::from_raw(1);
    for (int i = n, j = 0; j < (int)g.size() && i < n * 2;) Q[i++] = -g[j++];
    auto res = a.run(Q, 1, max(n - 1, (int)f.size() - 1));
    res.resize(n);
    return res;
}
```
* **代码解读**：  
  - **composition_rec结构体**：封装递归逻辑，f_是F(y⁻¹)的系数，g0_是G(x)的常数项。  
  - **run函数**：递归计算[ y⁰ ] F(y⁻¹)/(1 - yG(x)) mod xⁿ⁺¹。  
    - **递归终止（n=0）**：用二项式系数计算Q(x,y)的逆元，直接计算P*invQ（P是F(y⁻¹)的系数）。  
    - **拆分问题**：计算Q(x,y)Q(-x,y)，将问题规模减半到n/2。  
    - **合并结果**：用NTT计算子问题结果T和Q(-x,y)的乘积，得到当前问题的结果。  
* 💡 **学习笔记**：递归分治+NTT是处理多项式高级运算的“黄金组合”，能将O(n²)的复杂度降到O(n log²n)。


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：像素多项式的“分蛋糕”冒险  

**设计思路**：用8位像素风格模拟Bostan-Mori算法的递归过程，结合“分蛋糕”的游戏化元素，让抽象的多项式运算变得直观。  

### 📽️ 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧显示“多项式蛋糕”（不同颜色的小方块代表系数，比如红色代表F(x)，蓝色代表G(x)）。  
   - 右侧是“控制面板”：有“开始/暂停”“单步”“重置”按钮，速度滑块（从“龟速”到“光速”），还有8位风格的背景音乐（比如《超级马里奥》的轻松旋律）。  

2. **算法启动**：  
   - 用像素化的“魔法棒”点击“开始”，屏幕中央弹出“目标：计算F(G(x)) mod x⁵”（比如样例中的n=4）。  
   - G(x)的常数项g₀（比如样例中的1）用黄色方块标记，伴随“叮”的音效。  

3. **递归分治演示**：  
   - **拆分蛋糕**：用像素刀将“多项式蛋糕”切成两半（偶数项和奇数项），伴随“咔嚓”的音效。  
   - **NTT变换**：将拆分后的多项式从“系数域”转换到“点值域”，方块旋转并改变颜色（比如红色变橙色），伴随“咻”的音效。  
   - **卷积合并**：点值域的方块“碰撞融合”（比如橙色方块和蓝色方块合并成紫色），伴随“叮”的音效，合并后的方块回到系数域。  

4. **递归终止**：  
   - 当问题规模缩小到1时，用二项式系数计算逆元：屏幕下方弹出“二项式魔法”，用绿色方块显示C(d+i-1, i)的系数，伴随“魔法生效”的音效。  
   - 计算完成后，紫色方块组成最终的H(x)系数，屏幕中央弹出“胜利！”，播放上扬的8位胜利音效。  

5. **交互控制**：  
   - **单步模式**：点击“单步”，每一步都有文字提示（比如“现在拆分多项式到n=2”），帮助理解每一步的作用。  
   - **自动播放**：滑动速度滑块，选择“快速”模式，算法像“贪吃蛇AI”一样自动完成分蛋糕、合并的过程。  


## 6. 拓展练习与相似问题思考

### 🔍 通用思路迁移  
多项式复合是多项式高级运算的基础，以下场景都能用到：  
1. **多项式求逆**：比如求F(G(x))=x的G(x)，就是F(x)的逆多项式。  
2. **多项式对数/指数**：比如log F(x) = -Σ (1-F(x))ⁱ / i，可以用复合计算。  
3. **线性递推序列**：Bostan-Mori算法原本就是用于计算线性递推序列的第n项。  

### 📚 洛谷练习推荐  
1. **P5373 多项式复合函数**：本题的基础版，n≤1e4，适合入门。  
   - 🗣️ **推荐理由**：用基础的多项式展开实现，帮你理解复合的基本概念。  
2. **P4721 多项式求逆**：多项式高级运算的基础题，用到NTT和递归分治。  
   - 🗣️ **推荐理由**：练习NTT和递归分治，为多项式复合打基础。  
3. **P4722 多项式对数函数**：用复合计算log F(x)，拓展多项式运算的应用。  
   - 🗣️ **推荐理由**：将log转化为复合问题，加深对形式幂级数的理解。  


## 7. 学习心得与经验分享

> **参考经验（来自hly1204）**：“递归终止时的逆元计算，原本想用形式幂级数逆元，但noshi91告诉我可以用二项式系数直接计算，省去了很多麻烦。”  
> **点评**：这提醒我们，**站在巨人的肩膀上**很重要！遇到复杂的问题，不妨参考前人的优化技巧（比如noshi91的提示），能大大简化代码。另外，**动手模拟小例子**也很有效——比如用样例中的F(x)=1+2x+3x²+4x³+5x⁴，G(x)=1+2x+3x²+4x³，手动计算前几项，验证算法的正确性。  


## 🎉 总结  
本次分析了多项式复合的高效算法——Bostan-Mori算法，结合NTT实现O(n log²n)的计算。记住：**问题转化+递归分治+工具封装**是处理多项式高级运算的关键。下次遇到多项式问题，不妨想想“能不能用分蛋糕的方法解决？”  

编程的乐趣在于将抽象的数学转化为可运行的代码，继续加油吧！💪

---
处理用时：119.67秒
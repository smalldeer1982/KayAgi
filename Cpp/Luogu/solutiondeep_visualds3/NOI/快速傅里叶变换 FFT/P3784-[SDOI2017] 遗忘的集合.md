# 题目信息

# [SDOI2017] 遗忘的集合

## 题目描述

小 Q 在他的个人主页上放出了一个悬赏：征集只含正整数的非空集合 $S$，其中的每个元素都不超过 $n$，并且满足一些附加条件。

众所周知，我们可以很轻松地对于任意不超过 $n$ 的正整数 $x$，计算出把 $x$ 表示成 $S$ 中元素之和的方案数 $f(x)$，在这里我们约定，在任意方案中每个数字可以出现多次，但是不考虑数字出现的顺序。

例如，当 $S=\{1,2,3,4,5\}$ 时，我们可以计算出 $f(2) = 2, f(3) = 3, f(4) = 5, f(5) = 7$。

再例如，当 $S=\{1,2,5\}$ 时，我们可以计算出 $f(4) = 3, f(5) = 4, f(6) = 5, f(7) = 6$。

麻烦地是现在小 Q 忘记了 $S$ 里有哪些元素，幸运地是他用存储设备记录下了所有 $f(i)\bmod p$ 的值，小 Q 希望你能利用这些信息帮他恢复出 $S$ 原来的样子。

具体来说，他希望你找到这样一个正整数的**非空**集合 $S$，其中的每个元素都不超过 $n$，并且对于任意的 $i = 1, 2,\cdots ,n$，满足把 $i$ 表示成 $S$ 中元素之和的方案数在模 $p$ 意义下等于 $f(i)$，其中 $p$ 是记录在存储设备中的一个质数。他向你保证：**一定存在**这样的集合$S$。

然而，小 Q 觉得他存储的信息并不足以恢复出唯一的 $S$，也就是说，可能会存在多个这样的集合 $S$，所以小 Q 希望你能给出所有解中**字典序最小**的解。

对于满足条件的两个不同的集合 $S_1$ 和 $S_2$，我们认为 $S_1$ 的字典序比 $S_2$ 的字典序小，当且仅当存在非负整数 $k$，使得 $S_1$ 的前 $k$ 小元素与 $S_2$ 的前 $k$ 小元素完全相等，并且，要么 $S_1$ 的元素个数为 $k$，且 $S_2$ 的元素个数至少为 $(k + 1)$，要么 $S_1$ 和 $S_2$ 都有至少 $(k + 1)$ 个元素，且 $S_1$ 的第 $(k + 1)$ 小元素比 $S_2$ 的第 $(k + 1)$ 小元素小。


## 说明/提示

对于 $100\%$ 的数据，有 $1 \leq n < 2^{18} , 10^6 \leq p < 2^{30} , 0 \leq f(i) < p\quad (i=1,2, \cdots , n)$。

![](https://cdn.luogu.com.cn/upload/pic/5548.png)


## 样例 #1

### 输入

```
5 1000003
1 2 3 5 7```

### 输出

```
5
1 2 3 4 5```

## 样例 #2

### 输入

```
9 1000003
1 2 2 3 4 5 6 7 8```

### 输出

```
3
1 2 5```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2017]遗忘的集合 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论反演）+ 编程技巧应用（任意模数多项式操作）


### 初步分析
我们可以把这道题比作**“从蛋糕反推配方”**：  
- 题目中的**方案数f(x)**是“蛋糕的味道”，由集合S中的“原料”（每个元素）按一定比例混合而成（生成函数的乘积）。  
- 我们的目标是**从味道反推原料**——这需要两步关键操作：  
  1. **“拆蛋糕”**：用多项式ln将乘积形式的生成函数转化为求和形式（把混合的原料拆成单独的成分）；  
  2. **“解码”**：用狄利克雷反演从求和结果中找出每个原料是否存在（像解码一样从总和中提取每个元素的贡献）。


### 题解核心思路与难点
所有题解的核心逻辑高度一致：  
1. **生成函数建模**：方案数的生成函数 \( F(x) = \prod_{i=1}^n \left(\frac{1}{1-x^i}\right)^{a_i} \)（\( a_i=1 \) 表示i在集合中）；  
2. **取ln转求和**：\( \ln F(x) = \sum_{i=1}^n a_i \sum_{j=1}^\infty \frac{x^{ij}}{j} \)（将乘积拆成求和，方便反推）；  
3. **狄利克雷反演**：将求和式转化为卷积形式 \( g(T) = \sum_{d|T} a_d \cdot d \)，再反演得到 \( a_i \)（用调和级数O(n log n)高效计算）。  

**核心难点**：  
- **任意模数多项式ln**：模数p不是NTT友好模数（如998244353），需用MTT（基于复数FFT）或三模NTT实现；  
- **狄利克雷反演的正确应用**：需准确推导卷积形式，并避免暴力枚举因数（用调和级数优化）。


### 可视化设计思路
我们用**“像素实验室”**的复古场景展示算法流程，关键设计如下：  
- **F(x)展示区**：红色像素块，高度对应f(x)的值（如f(1)=1→1个像素高的红块）；  
- **G(x)展示区**：蓝色像素块，高度对应ln F(x)的系数（拆后的“原料成分”）；  
- **a_i展示区**：绿色像素块，亮起表示该元素在集合中（最终“配方”）。  

**动画亮点**：  
- **ln操作**：F(x)块逐个“分解”成G(x)块，伴随“叮”的音效；  
- **反演过程**：G(x)块高亮（如i=1的蓝块闪烁），其倍数块减去i的贡献（高度降低），伴随“咻”的音效；  
- **结果输出**：a_i块中存在的元素亮起绿色，播放“胜利”音效（如FC游戏通关音乐）。  


## 2. 精选优质题解参考

### 题解一：来源（Salamander）
**点评**：思路最直接的“标准解法”——从生成函数到ln再到反演，每一步推导清晰。代码用MTT实现任意模数多项式ln，结构模块化（求导、逆、乘、积分分开），正确性高。美中不足是多项式操作的细节较紧凑，新手需仔细梳理。


### 题解二：来源（litble）
**点评**：反演步骤的“简化版”——不用预处理莫比乌斯函数，直接**逐步减去倍数贡献**（如i的倍数j减去g(i)）。这种方法更直观，避免了数论函数的预处理，适合新手理解反演的本质。


### 题解三：来源（zhiyangfan）
**点评**：结合正向问题（付公主的背包）的“对比版”——通过对比正向问题的生成函数，帮助理解逆过程的逻辑。代码用三模NTT实现多项式乘法，正确性强，但代码量较大，适合学习高精度多项式操作。


## 3. 核心难点辨析与解题策略

### 关键点1：生成函数的ln转换
**难点**：如何将乘积形式的生成函数拆成求和？  
**策略**：记住ln的展开式 \( \ln(1-x^i) = -\sum_{j=1}^\infty \frac{x^{ij}}{j} \)，或用**求导+积分**推导（如题解中所示）。


### 关键点2：任意模数多项式ln的实现
**难点**：模数p不是NTT模数，常规NTT无法用。  
**策略**：选择**MTT**（基于复数FFT，将大数拆成两部分计算）或**三模NTT**（用三个NTT模数计算，再用CRT合并）。MTT代码更简洁，三模NTT正确性更高。


### 关键点3：狄利克雷反演的高效计算
**难点**：如何快速计算卷积 \( g(T) = \sum_{d|T} a_d \cdot d \) 的逆？  
**策略**：用**调和级数优化**——遍历每个i，更新其倍数j=i,2i,…,n的g(j)。这种方法时间复杂度O(n log n)，适合n=2¹⁸的规模。


### 解题技巧总结
1. **生成函数逆问题的通用解法**：遇到“已知乘积结果求因子”，优先用ln转求和；  
2. **任意模数多项式操作**：掌握MTT或三模NTT，应对非NTT模数；  
3. **狄利克雷反演的优化**：用调和级数代替暴力枚举因数，降低时间复杂度；  
4. **代码模块化**：将多项式操作（求导、逆、乘、ln）封装成函数，提高可读性。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合题解一、二的思路，用MTT实现任意模数多项式ln，调和级数反演，结构清晰。

```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

typedef long long ll;
const double PI = acos(-1.0);
const int MAXN = 1 << 19;

struct Complex { double re, im; Complex(double r=0, double i=0):re(r),im(i){} };
Complex operator+(const Complex& a, const Complex& b) { return Complex(a.re+b.re, a.im+b.im); }
Complex operator-(const Complex& a, const Complex& b) { return Complex(a.re-b.re, a.im-b.im); }
Complex operator*(const Complex& a, const Complex& b) { return Complex(a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re); }

Complex w[MAXN]; int rev[MAXN];
void init_fft(int len) {
    int k = 0; while ((1<<k) < len) k++;
    for (int i=0; i<len; i++) rev[i] = (rev[i>>1]>>1) | ((i&1)<<(k-1));
    for (int i=0; i<len; i++) w[i] = Complex(cos(2*PI*i/len), sin(2*PI*i/len));
}

void fft(Complex* a, int len, int type) {
    for (int i=0; i<len; i++) if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int mid=1; mid<len; mid<<=1) {
        int step = mid << 1;
        for (int i=0; i<len; i+=step) {
            for (int j=0; j<mid; j++) {
                Complex tmp = w[len/step*j] * a[i+j+mid];
                a[i+j+mid] = a[i+j] - tmp;
                a[i+j] = a[i+j] + tmp;
            }
        }
    }
    if (type == -1) { reverse(a+1, a+len); for (int i=0; i<len; i++) a[i].re /= len; }
}

void mtt(ll* A, ll* B, ll* C, int n, int m, ll mod) {
    int len = 1; while (len < n+m) len <<=1;
    init_fft(len); Complex a[len], b[len];
    for (int i=0; i<len; i++) {
        a[i] = Complex(i<n ? A[i]>>15 : 0, i<n ? A[i]&32767 : 0);
        b[i] = Complex(i<m ? B[i]>>15 : 0, i<m ? B[i]&32767 : 0);
    }
    fft(a, len, 1); fft(b, len, 1);
    Complex c[len], d[len];
    for (int i=0; i<len; i++) {
        int j = (len - i) % len;
        c[i] = (a[i] + Complex(a[j].re, -a[j].im)) * b[i] / 2;
        d[i] = (a[i] - Complex(a[j].re, -a[j].im)) * b[i] / 2;
    }
    fft(c, len, -1); fft(d, len, -1);
    for (int i=0; i<n+m-1; i++) {
        ll high = (ll)round(c[i].re) % mod;
        ll mid = ((ll)round(c[i].im) + (ll)round(d[i].im)) % mod;
        ll low = (mod - (ll)round(d[i].re) % mod) % mod;
        C[i] = ((high << 30) + (mid << 15) + low) % mod;
    }
}

void poly_inv(ll* a, ll* b, int len, ll mod) {
    if (len == 1) { b[0] = 1; return; }
    poly_inv(a, b, (len+1)/2, mod);
    ll* tmp = new ll[2*len];
    mtt(a, b, tmp, len, (len+1)/2, mod);
    mtt(tmp, b, tmp, len, (len+1)/2, mod);
    for (int i=0; i<len; i++) b[i] = (2*b[i] - tmp[i] + mod) % mod;
    delete[] tmp;
}

void poly_der(ll* a, ll* b, int len, ll mod) {
    for (int i=0; i<len-1; i++) b[i] = (i+1)*a[i+1] % mod;
    b[len-1] = 0;
}

void poly_int(ll* a, ll* b, int len, ll mod, vector<ll>& inv) {
    b[0] = 0; for (int i=1; i<len; i++) b[i] = a[i-1] * inv[i] % mod;
}

void poly_ln(ll* a, ll* b, int len, ll mod, vector<ll>& inv) {
    ll* der = new ll[len]; ll* inv_a = new ll[len];
    poly_der(a, der, len, mod); poly_inv(a, inv_a, len, mod);
    ll* tmp = new ll[2*len]; mtt(der, inv_a, tmp, len, len, mod);
    poly_int(tmp, b, len, mod, inv);
    delete[] der; delete[] inv_a; delete[] tmp;
}

void init_mu(int n, vector<int>& mu, vector<bool>& is_prime, vector<int>& primes) {
    mu.resize(n+1); is_prime.assign(n+1, true); primes.clear();
    mu[1] = 1; is_prime[0] = is_prime[1] = false;
    for (int i=2; i<=n; i++) {
        if (is_prime[i]) { primes.push_back(i); mu[i] = -1; }
        for (int p : primes) {
            if (i*p > n) break;
            is_prime[i*p] = false;
            if (i%p == 0) { mu[i*p] = 0; break; }
            else mu[i*p] = -mu[i];
        }
    }
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    int n; ll p; cin >> n >> p;
    vector<ll> f(n+1); f[0] = 1;
    for (int i=1; i<=n; i++) cin >> f[i];

    vector<ll> inv(n+1); inv[1] = 1;
    for (int i=2; i<=n; i++) inv[i] = (p - p/i) * inv[p%i] % p;

    vector<ll> g(n+1);
    poly_ln(f.data(), g.data(), n+1, p, inv);

    for (int i=1; i<=n; i++) g[i] = g[i] * i % p;

    vector<int> mu; vector<bool> is_prime; vector<int> primes;
    init_mu(n, mu, is_prime, primes);

    vector<ll> a(n+1, 0);
    for (int d=1; d<=n; d++) {
        for (int i=d; i<=n; i+=d) {
            a[i] = (a[i] + mu[d] * g[i/d]) % p;
        }
    }

    for (int i=1; i<=n; i++) if (a[i] < 0) a[i] += p;

    int cnt = 0; vector<int> ans;
    for (int i=1; i<=n; i++) if (a[i] != 0) { cnt++; ans.push_back(i); }

    cout << cnt << endl;
    for (int x : ans) cout << x << " ";
    cout << endl;
    return 0;
}
```


### 代码解读概要
1. **输入处理**：读取n、p和f数组（f[0]=1）；  
2. **预处理逆元**：计算1~n的模p逆元，用于多项式积分；  
3. **多项式ln**：通过“求导+逆+乘+积分”得到ln F(x)；  
4. **反演计算**：用调和级数计算a[i]（集合元素的存在标志）；  
5. **输出结果**：统计并输出集合元素。


### 题解一片段赏析（多项式ln的实现）
**亮点**：模块化实现多项式ln的核心步骤，逻辑清晰。  
**核心代码**：
```cpp
void poly_ln(ll* a, ll* b, int len, ll mod, vector<ll>& inv) {
    ll* der = new ll[len];    // 求导结果
    ll* inv_a = new ll[len];  // a的逆元
    poly_der(a, der, len, mod);   // 1. 求导
    poly_inv(a, inv_a, len, mod); // 2. 求逆
    ll* tmp = new ll[2*len];
    mtt(der, inv_a, tmp, len, len, mod); // 3. 乘法（导数*逆元）
    poly_int(tmp, b, len, mod, inv);     // 4. 积分（得到ln结果）
    delete[] der; delete[] inv_a; delete[] tmp;
}
```

**解读**：  
多项式ln的本质是“导数→逆元→乘法→积分”的组合——导数将ln转化为分式，逆元处理分母，乘法合并结果，积分还原ln。


### 题解二片段赏析（简化反演）
**亮点**：不用莫比乌斯函数，直接**逐步剥离贡献**，更直观。  
**核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = i * 2; j <= n; j += i) {
        g[j] = (g[j] - g[i] + p) % p; // 减去i的贡献
    }
}
```

**解读**：  
g数组是“i * ln F(x)的系数”，即 \( g(j) = \sum_{d|j} a[d] \cdot d \)。对于每个i，其倍数j的g(j)包含i的贡献，减去后剩下的就是a[j]·j（当i是j的最小因数时）。


## 5. 算法可视化：像素动画演示方案

### 动画主题：像素实验室之“遗忘的集合解码”

### 核心演示内容
展示从f(x)到集合S的完整流程，包括：  
1. F(x)初始化→2. ln操作拆分成G(x)→3. 反演得到a_i→4. 输出结果。

### 交互设计
- **步进控制**：点击“下一步”走一个步骤（如从x=1到x=2的ln操作）；  
- **自动播放**：滑块调节速度（1~5档），连续播放；  
- **重置**：回到初始状态，所有块暗。

### 技术实现
- **轻量化**：纯HTML/CSS/JS实现，Canvas绘制像素块，Web Audio API播放音效；  
- **音效设计**：  
  - ln操作：“叮”（8位音效）；  
  - 反演：“咻”（短促音效）；  
  - 胜利：“通关音乐”（FC风格）。


## 6. 拓展练习与相似问题思考

### 相似问题
- **P4389 付公主的背包**：正向问题（给定集合求方案数），练习生成函数的乘积；  
- **P5245 多项式快速幂**：多项式操作的基础练习；  
- **P3455 ZAP-Queries**：狄利克雷反演的数论应用。


### 进阶练习
- 尝试用**三模NTT**替换MTT，实现多项式ln；  
- 扩展可视化，添加“对比模式”（同时展示两种反演方法）。


## 7. 学习心得与经验分享
### 参考经验（来自zhiyangfan）
> “调了一下午，这不得写篇题解纪念一下。”

**点评**：多项式操作的调试需**分步验证**：  
1. 先验证多项式乘法（如(1+2x)*(3+4x)=3+10x+8x²）；  
2. 输出ln后的g数组，看是否符合预期（如样例1中g[i]=1）；  
3. 参考优秀模板（如OI-wiki的MTT），避免重复踩坑。


## 总结
本题的核心是**生成函数的逆问题**，通过ln将乘积拆成求和，再用反演解码集合元素。掌握任意模数多项式操作和狄利克雷反演，能解决更多类似的“逆推”问题。多练习、多调试，才能熟练掌握这些技巧！  

下次我们将分析更多算法问题，一起进步！💪

---
处理用时：270.40秒
# 题目信息

# 射命丸文的笔记

## 题目背景

### （七）再见，地底世界的朋友们

在地灵殿住了许多天了呢。

这些日子里，觉分享了很多旧地狱的故事。

此次地底旅行，可以说是非常充实了。

虽然仍旧有些不舍，不过人类总是要见太阳的，再说这样麻烦觉姐姐招待我们也有些过意不去呢。

那么，和觉，恋，阿燐，阿空，以及其他宠物们说再见吧。

......

旧地狱的街市，依旧飘着雪。

已经能看到溶洞了。

环境又变得幽闭起来。

诶，前面不是山女吗？

“啊，你们要回地面了吗，玩的怎样？”

“很开心呢，对了，剩下的问题已经解决了”

我们向山女解释了从荷取那里听到的方法。

“谢谢!”

“不客气，那么再见了~”

世界一片白茫茫的...

阳光是那么的刺眼，以至于几分钟后我们才能睁开眼睛看清楚地面的景色。

沿着魔法森林中的小路向神社走去，这次的旅行也在我们的脚步声中走向了尾声。

前方的地面上忽然出现了一页破损的笔记。

捡起来一看，发现是从文文的笔记本上脱落下来的。

射命丸文，作为（不靠谱的）新闻记者，观察到最近地灵殿里的宠物们偶尔会互相打架，于是将每场决斗的胜负关系写在了她的笔记本上。刚刚捡起来的这页笔记，上面就记录着几场“单循环赛”。

每场循环赛被抽象成一张竞赛图，其中顶点代表参加循环赛的宠物，从顶点 $u$ 指向顶点 $v$ 的边代表在一场比赛中宠物 $u$ 战胜了宠物 $v$。

观察到这页笔记上所有的竞赛图中都至少存在一条经过所有顶点的回路，我们猜想文文只会记录这样的循环赛。

可能是因为文文不清楚宠物们谁能打过谁，于是在那页笔记的最下面留下了一个这样的问题...

(见题目描述)

这最后一个问题，就留给你来解决啦。

博丽大结界，已经在我们身后了。

希望这次地底旅行，能给你留下美好的记忆~

(全文完)

## 题目描述

如果一个竞赛图含有哈密顿回路，则称这张竞赛图为值得记录的。

从所有含有 $n$ 个顶点（顶点互不相同）的，值得记录的竞赛图中等概率随机选取一个。

求选取的竞赛图中哈密顿回路数量的期望值。

由于答案可能过大/丢失精度，只需要输出答案除以 $998244353$ 的余数。

即：设答案为 $\frac{q}{p}$，则你需要输出一个整数 $x$，满足 $px\equiv q \mod 998244353$ 且 $0\leqslant x<998244353$，可以证明恰好存在一个这样的 $x$。

若不存在这样的竞赛图，输出 `-1`。

## 说明/提示

### 样例解释：

$n=1$ 时只有一种满足条件的竞赛图，就是一个点。

$n=2$ 时竞赛图中只有一条边，不能形成哈密顿回路。

$n=3$ 时有两种满足条件的竞赛图，分别为 $1\to2\to3\to1$ 和 $1\to3\to2\to1$，都只有 $1$ 条哈密顿回路，随机取出后期望值为 $1$。

$n=4$ 时有很多种满足条件的的竞赛图，这里写不下了，但是所有满足条件的竞赛图都是同构的，所以随机取出后期望值为 $1$。

### 数据范围：

测试点 1~3 中 $n\leqslant7$。

测试点 4~6 中 $n\leqslant10$。

测试点 7~10 中 $n\leqslant1000$。

测试点 11~16 中 $n\leqslant10000$。

测试点 17~25 中 $n\leqslant100000$。

数据有梯度，每个测试点 $4$ 分。

为防止卡常，最后两个点开 2s 时限。

### 名词解释：

[竞赛图](https://en.wikipedia.org/wiki/Tournament_(graph_theory))：指任意两个顶点间恰有一条有向边的有向图。

[哈密顿回路](https://en.wikipedia.org/wiki/Hamiltonian_cycle)：指除起点和终点外经过所有顶点恰好一次且起点和终点相同的路径。


by oscar


## 样例 #1

### 输入

```
4```

### 输出

```
1
-1
1
1```

# AI分析结果

# 💡 Kay的C++算法解析：射命丸文的笔记 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：数学（生成函数）+ 多项式算法（多项式求逆/分治FFT）

#### 初步分析
你可以把**生成函数**想象成“数学魔法书”——它能把复杂的计数问题（比如“有多少个强连通竞赛图”）转化为多项式运算，让我们用代数方法解决。而**多项式求逆**就是这本魔法书里的“高级咒语”，能快速算出我们需要的系数（比如强连通竞赛图的数量）。

在本题中，我们需要解决两个问题：
1. **算总数**：所有n点竞赛图中，哈密顿回路的总条数（公式是$(n-1)! \times 2^{\binom{n}{2}-n}$，后面会解释）；
2. **算分母**：有多少个n点强连通竞赛图（因为只有强连通的竞赛图才有哈密顿回路）。

核心难点是**求强连通竞赛图的数量**。我们用**容斥原理**推导：总竞赛图数减去非强连通的竞赛图数。非强连通的竞赛图可以拆成“一个小的强连通分量 + 剩下的任意连边”，但直接计算会重复，所以用**生成函数**把这个关系转化为多项式乘法，再用**多项式求逆**快速求解。

### 可视化设计思路
我们可以做一个**“像素魔法师的生成函数实验室”**复古动画：
- 用8位像素块代表多项式的系数（比如$g[i]$是“总竞赛图数的生成函数系数”，$f[i]$是“强连通竞赛图的生成函数系数”）；
- 演示多项式乘法时，像素块会“碰撞”并产生新的系数块；
- 多项式求逆时，用“反向魔法”动画展示如何从$g$算出$f$；
- 每算出一个$f[i]$，会播放“叮”的音效，完成全部计算后有“胜利”音效。


## 2. 精选优质题解参考

### 题解一：oscar的核心公式推导（来源：本题官方题解）
**点评**：这份题解是“解题的钥匙”——它直接点出了核心公式：强连通竞赛图数量$f(n) = 2^{\binom{n}{2}} - \sum_{i=1}^{n-1} C(n,i)f(i)2^{\binom{n-i}{2}}$，并解释了哈密顿回路总数的计算方法。思路清晰，是所有后续解法的基础。

### 题解二：da32s1da的多项式求逆实现（来源：综合题解内容）
**点评**：这份题解给出了完整的C++代码，用多项式求逆解决了生成函数的问题。代码风格规范（比如用`fac`存阶乘，`invfac`存逆元），关键变量命名易懂（`g`是总竞赛图的生成函数，`f`是强连通竞赛图的生成函数）。它的亮点是把复杂的生成函数转化为多项式运算，适合入门学习。

### 题解三：Early的分治FFT实现（来源：综合题解内容）
**点评**：这份题解用分治FFT代替多项式求逆，思路更直观（分治处理卷积）。代码中的`cdq`函数清晰展示了分治的过程，适合想理解“生成函数卷积”底层逻辑的同学。


## 3. 核心难点辨析与解题策略

### 🔍 核心难点1：强连通竞赛图的容斥计数
**问题**：如何计算强连通竞赛图的数量？  
**解法**：总竞赛图数是$2^{\binom{n}{2}}$（每对顶点有2种边方向）。非强连通的竞赛图可以拆成“一个最小的强连通分量（大小i） + 剩下的点任意连边”，所以用容斥减去这些情况：$f(n) = 2^{\binom{n}{2}} - \sum_{i=1}^{n-1} C(n,i)f(i)2^{\binom{n-i}{2}}$。

### 🔍 核心难点2：生成函数的转化
**问题**：如何快速计算容斥式子中的求和？  
**解法**：把$f(n)$和$g(n)=2^{\binom{n}{2}}$转化为**指数生成函数（EGF）**：$F(x) = \sum_{n=0}^\infty \frac{f(n)}{n!}x^n$，$G(x) = \sum_{n=0}^\infty \frac{g(n)}{n!}x^n$。容斥式子会变成$G(x) = F(x) \times G(x) + 1$，解得$F(x) = 1 - \frac{1}{G(x)}$——这需要用**多项式求逆**计算$\frac{1}{G(x)}$。

### 🔍 核心难点3：多项式求逆的实现
**问题**：如何用C++实现多项式求逆？  
**解法**：多项式求逆是用分治的方法：先求低次多项式的逆，再用NTT（快速数论变换）计算高次多项式的逆。关键是理解“用低次逆近似高次逆”的思路，代码中用`Inv`函数递归实现。

### ✨ 解题技巧总结
1. **计数问题先找容斥**：遇到“所有情况减不符合情况”的问题，先考虑容斥。
2. **生成函数是计数神器**：复杂的求和可以转化为多项式乘法，用NTT加速。
3. **多项式算法要记模板**：多项式求逆、分治FFT的模板要熟练，注意模数（本题用998244353）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：本代码综合了da32s1da和Early的题解思路，用多项式求逆计算强连通竞赛图数量，是本题的典型实现。

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int mod = 998244353;
const int G = 3;
const int maxn = 262150;

long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

long long fac[maxn], invfac[maxn];
void init_fac(int n) {
    fac[0] = 1;
    for (int i = 1; i <= n; ++i) fac[i] = fac[i-1] * i % mod;
    invfac[n] = qpow(fac[n], mod-2);
    for (int i = n-1; i >= 0; --i) invfac[i] = invfac[i+1] * (i+1) % mod;
}

void ntt(vector<long long>& a, bool inv) {
    int n = a.size();
    vector<int> rev(n);
    for (int i = 0; i < n; ++i) {
        rev[i] = rev[i>>1] >> 1;
        if (i & 1) rev[i] |= n >> 1;
    }
    for (int i = 0; i < n; ++i) if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int len = 2; len <= n; len <<= 1) {
        long long wn = qpow(G, (mod-1)/len);
        if (inv) wn = qpow(wn, mod-2);
        for (int i = 0; i < n; i += len) {
            long long w = 1;
            for (int j = 0; j < len/2; ++j) {
                long long u = a[i+j], v = a[i+j+len/2] * w % mod;
                a[i+j] = (u + v) % mod;
                a[i+j+len/2] = (u - v + mod) % mod;
                w = w * wn % mod;
            }
        }
    }
    if (inv) {
        long long inv_n = qpow(n, mod-2);
        for (auto& x : a) x = x * inv_n % mod;
    }
}

vector<long long> poly_inv(vector<long long> a) {
    int n = 1;
    while (n < a.size()) n <<= 1;
    a.resize(n);
    vector<long long> b(n);
    b[0] = qpow(a[0], mod-2);
    for (int len = 2; len <= n; len <<= 1) {
        vector<long long> c(a.begin(), a.begin() + len);
        c.resize(len * 2); ntt(c, false);
        vector<long long> d(b.begin(), b.begin() + len);
        d.resize(len * 2); ntt(d, false);
        for (int i = 0; i < len * 2; ++i)
            c[i] = c[i] * d[i] % mod * d[i] % mod;
        ntt(c, true);
        for (int i = 0; i < len; ++i)
            b[i] = (2 * b[i] - c[i] + mod) % mod;
    }
    return b;
}

int main() {
    int n; cin >> n;
    init_fac(n);
    vector<long long> g(n+1);
    for (int i = 0; i <= n; ++i)
        g[i] = qpow(2, 1LL * i * (i-1) / 2) * invfac[i] % mod;
    vector<long long> inv_g = poly_inv(g);
    vector<long long> f(n+1);
    for (int i = 0; i <= n; ++i)
        f[i] = (mod - inv_g[i]) % mod;
    f[0] = (f[0] + 1) % mod;
    for (int i = 0; i <= n; ++i)
        f[i] = f[i] * fac[i] % mod;
    if (n >= 1) cout << "1\n";
    if (n >= 2) cout << "-1\n";
    for (int i = 3; i <= n; ++i) {
        long long ans = fac[i-1] * qpow(2, 1LL * i * (i-3) / 2) % mod;
        ans = ans * qpow(f[i], mod-2) % mod;
        cout << ans << "\n";
    }
    return 0;
}
```

**代码解读概要**：  
1. **阶乘与逆元初始化**：`init_fac`计算阶乘`fac`和逆元`invfac`，用于生成函数的转化。  
2. **NTT实现**：`ntt`函数实现快速数论变换，用于多项式乘法。  
3. **多项式求逆**：`poly_inv`函数用分治和NTT计算多项式的逆元。  
4. **主逻辑**：计算总竞赛图的生成函数`g`，求逆得到`inv_g`，再计算强连通竞赛图的数量`f`，最后输出期望（哈密顿回路总数除以`f[i]`）。


### 针对各优质题解的片段赏析

#### 题解二：da32s1da的多项式求逆片段
**亮点**：用简洁的代码实现了多项式求逆，清晰展示了生成函数的转化过程。  
**核心代码片段**：
```cpp
vector<long long> poly_inv(vector<long long> a) {
    int n = 1;
    while (n < a.size()) n <<= 1;
    a.resize(n);
    vector<long long> b(n);
    b[0] = qpow(a[0], mod-2);
    for (int len = 2; len <= n; len <<= 1) {
        vector<long long> c(a.begin(), a.begin() + len);
        c.resize(len * 2); ntt(c, false);
        vector<long long> d(b.begin(), b.begin() + len);
        d.resize(len * 2); ntt(d, false);
        for (int i = 0; i < len * 2; ++i)
            c[i] = c[i] * d[i] % mod * d[i] % mod;
        ntt(c, true);
        for (int i = 0; i < len; ++i)
            b[i] = (2 * b[i] - c[i] + mod) % mod;
    }
    return b;
}
```
**代码解读**：  
- 初始化`b[0]`为`a[0]`的逆元（低次项的逆）。  
- 分治处理：对于每个长度`len`，计算`a`的前`len`项与`b`的前`len`项的平方（用NTT加速），然后更新`b`的前`len`项（用公式$b_{new} = 2b - a b^2$）。  
- 最终`b`就是`a`的逆多项式。  
**学习笔记**：多项式求逆的核心是“用低次逆近似高次逆”，NTT是加速多项式乘法的关键。


## 5. 算法可视化：像素动画演示方案

### 🎮 动画主题：生成函数的“魔法乘法”
**设计思路**：用8位像素风模拟生成函数的乘法过程，把多项式系数变成“魔法水晶”，乘法变成“水晶融合”，让抽象的多项式运算变得直观。

### 🌟 动画步骤
1. **场景初始化**：屏幕左侧是“总竞赛图生成函数G”的像素水晶（每个水晶代表一个系数$g[i]$），右侧是“强连通生成函数F”的水晶。背景是复古的魔法实验室，播放8位风格的背景音乐。  
2. **生成函数乘法**：当计算$G = F \times G + 1$时，左侧的G水晶会和右侧的F水晶“碰撞”，产生新的水晶（代表卷积后的系数）。每碰撞一次，播放“叮”的音效。  
3. **多项式求逆**：当计算$F = 1 - 1/G$时，右侧的F水晶会“吸收”左侧的G水晶的逆（用闪烁效果表示），然后生成新的F水晶。完成时播放“胜利”音效。  
4. **结果展示**：最后，屏幕下方会显示强连通竞赛图的数量`f[i]`，并用像素文字提示“哈密顿回路期望是1！”（因为样例中除了n=2，其他情况期望都是1）。

### 🎯 交互设计
- **单步执行**：点击“下一步”按钮，逐步展示生成函数乘法和求逆的过程。  
- **自动播放**：点击“自动”按钮，动画会以每秒2步的速度自动演示，适合快速理解流程。  
- **重置**：点击“重置”按钮，回到初始状态，重新开始演示。


## 6. 拓展练习与相似问题

### 🔍 相似问题
1. **洛谷P4721 【模板】分治 FFT**：练习分治FFT的实现，加深对生成函数卷积的理解。  
2. **洛谷P3803 【模板】多项式乘法（FFT）**：学习NTT的基础模板，掌握多项式乘法的实现。  
3. **洛谷P4234 最小差值生成树**：虽然不是生成函数问题，但涉及图的强连通分量，适合巩固图论基础。


## 7. 学习心得与经验分享 (若有)
> **参考经验 (来自 Early 的题解)**：“分治FFT比多项式求逆更直观，适合入门学习生成函数的卷积。”  
> **点评**：这位作者的经验很实用！如果觉得多项式求逆太难，可以先学分治FFT，理解“分治处理卷积”的思路，再进阶到多项式求逆。


## 💪 总结与鼓励
本次分析的“射命丸文的笔记”是一道典型的**生成函数 + 多项式算法**题。关键是要理解“强连通竞赛图的容斥计数”和“生成函数的转化”，然后用多项式求逆或分治FFT快速计算。  

记住：生成函数是“计数的魔法”，多项式算法是“魔法的工具”——只要掌握了这些工具，再复杂的计数问题也能迎刃而解！下次我们再一起探索更多的编程挑战吧！😊

---
处理用时：103.57秒
# 题目信息

# 【模板】快速阶乘算法

## 题目背景

有一天，NaCly_Fish 无意间看到一种高效求阶乘模大质数的算法，但是她太菜，并不会写。  
于是她就暴力造了数据，请您帮忙写出 std 吧。  

什么，您问为什么不保证模数可以 NTT？  
那样的话就可能被打表水过，或者答案就爆 int 了。

反正您是神仙，肯定能秒掉这题。

## 题目描述

给你正整数 $n$，和一个质数 $p$，你需要求出：  
$$ n! \text{ mod } p$$  
有 $T$ 组数据。

## 说明/提示

### 数据范围：  

对于 $10\%$ 的数据：$p = 998244353$   
对于另外 $10\%$ 的数据：$p = 1004535809$   
对于 $100\%$ 的数据：$1\le n < p \le 2^{31}-1$，$1 \le T \le 5$    
保证 $p$ 为质数。

【提示】   
请确保你的算法时间复杂度不高于 $\Theta(\sqrt n \log n)$，时限为 std 的十倍以上。

## 样例 #1

### 输入

```
4
16777216 998244353
72267859 998244353
2333333 19260817
1919810 2147481811```

### 输出

```
789885751
569626621
16351109
1416439247```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】快速阶乘算法 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学` (分块思想+多项式技术)

🗣️ **初步分析**：  
解决“快速阶乘”问题的核心，就像把一本厚书分成若干章——我们把大的阶乘计算（`n!`）拆成**√n个小“块”**，每个块是连续的√n个数的乘积（比如第i块是`(i√n+1)×(i√n+2)×…×(i+1)√n`）。这些块的乘积可以用**多项式**快速计算：构造多项式`f(x) = (x+1)(x+2)...(x+√n)`，那么第i块的乘积就是`f(i√n)`。最后把所有块的乘积相乘，再乘上剩余的数（超过√n²的部分），就得到`n!`。  

**核心算法流程**：  
1. 分块：设`B=√n`，构造多项式`f(x) = ∏_{i=1}^B (x+i)`；  
2. 求点值：计算`f(0), f(B), f(2B), ..., f(B²-B)`（每个块的乘积）；  
3. 合并：将这些点值相乘，再乘上`B²+1`到`n`的数，得到`n! mod p`。  

**可视化设计思路**：  
我们用**8位像素风**模拟“分块计算”的过程：  
- 屏幕左侧显示像素化的“阶乘数轴”，用不同颜色的方块标记每个块（比如第i块是蓝色，剩余部分是灰色）；  
- 中间区域动态展示多项式`f(x)`的构造：每个`x+i`用小像素点闪烁表示，乘积过程用“合并”动画（方块叠在一起）；  
- 右侧控制面板有“单步执行”“自动播放”按钮，单步时会高亮当前计算的块，并用“叮”的音效提示；  
- 完成所有块计算后，数轴会整体闪烁，伴随“胜利”音效，显示最终结果。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了以下3道优质题解，覆盖“正解”和“暴力卡常”两种思路：
</eval_intro>

### 题解一：正解（倍增+拉格朗日插值，来源：shadowice1984）
* **点评**：  
  这道题解是**O(√n logn)**的标准正解，思路非常清晰——通过**倍增**维护多项式的点值，用**拉格朗日插值**实现点值平移（比如从`f(x)`的点值得到`f(x+B)`的点值）。代码规范，处理了“非NTT模数”的痛点（用MTT做任意模数多项式乘法），甚至还拓展了“阶乘求和”的变种问题。它的亮点在于**将多项式技术与分块思想结合**，完美贴合题目要求的时间复杂度。

### 题解二：暴力卡常（AVX2+蒙哥马利约减，来源：bh1234666）
* **点评**：  
  这道题解走“暴力优化”路线，用**AVX2指令集**（单指令多数据）将乘法并行化，用**蒙哥马利约减**优化取模（替换高成本的`%`运算）。虽然理论复杂度是O(n)，但通过“循环展开+指令集”卡掉了120倍的常数，最终比部分正解还快。它的亮点在于**把硬件特性用到极致**，适合学习“如何优化暴力算法”。

### 题解三：正解（多项式连续点值平移，来源：JustinRochester）
* **点评**：  
  这道题解进一步优化了正解的常数——通过**多项式连续点值平移**，直接从`f(x)`的点值推导出`f(x+B)`的点值，避免了重复计算多项式系数。代码简洁，注释详细，甚至用“矩阵乘法”拓展到了阶乘求和问题。它的亮点在于**对多项式性质的深刻理解**，适合学习“如何用点值而非系数表示多项式”。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决“快速阶乘”问题的核心难点，在于“如何将大阶乘拆小并快速计算”。以下是3个关键问题及解决策略：
</difficulty_intro>

### 1. 如何将阶乘分块并构造多项式？
* **难点**：直接计算`n!`是O(n)，但分块后需要用多项式表示块的乘积，这一步容易卡壳。  
* **策略**：设`B=√n`，构造`f(x) = (x+1)(x+2)...(x+B)`——这样`f(iB)`就是第i块的乘积（`(iB+1)×…×(i+1)B`）。通过多项式多点求值，可以快速得到所有`f(iB)`的点值。  
* 💡 **学习笔记**：分块的本质是“用空间换时间”，把大问题拆成小问题，再用多项式技术快速合并。

### 2. 如何处理非NTT模数的多项式乘法？
* **难点**：题目中的模数`p`不一定支持NTT（比如不是形如`c×2^k+1`的质数），直接用FFT会精度爆炸。  
* **策略**：用**MTT（任意模数多项式乘法）**——将系数拆成高16位和低16位，用FFT计算后合并，避免精度损失。  
* 💡 **学习笔记**：MTT是处理“任意模数多项式乘法”的通用工具，一定要掌握！

### 3. 如何用倍增快速计算多项式点值？
* **难点**：直接构造多项式`f(x)`需要O(B²)时间，太慢。  
* **策略**：用**倍增**——从`f_1(x)=x+1`开始，逐步合并得到`f_B(x)`（比如`f_2d(x) = f_d(x)×f_d(x+d)`）。合并时用拉格朗日插值得到`f_d(x+d)`的点值。  
* 💡 **学习笔记**：倍增是“从小往大”构造解的常用技巧，尤其适合多项式这类“可合并”的结构。

### ✨ 解题技巧总结
- **分块思想**：遇到“大尺寸计算”时，先拆成√n大小的块，再合并结果；  
- **多项式技术**：用多项式表示“连续乘积”，用MTT处理任意模数，用拉格朗日插值做点值平移；  
- **硬件优化**：暴力算法可以用AVX2、循环展开等技巧卡常，但正解更依赖算法设计。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**O(√n logn)的正解核心实现**，基于“倍增+拉格朗日插值”思路，处理了任意模数的情况：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了shadowice1984和JustinRochester的题解思路，是“分块+多项式”的典型实现。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <complex>
#include <algorithm>
using namespace std;

typedef long long ll;
typedef vector<ll> poly;
const double Pi = acos(-1.0);
ll mod;

ll power(ll a, ll b = mod-2) {
    ll res = 1;
    for (; b; b >>= 1, a = a*a%mod)
        if (b&1) res = res*a%mod;
    return res;
}

void FFT(vector<complex<double>>& a, bool inv) {
    int n = a.size();
    for (int i = 1, j = 0; i < n; ++i) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j) swap(a[i], a[j]);
    }
    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2*Pi/len * (inv ? -1 : 1);
        complex<double> wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            complex<double> w(1);
            for (int j = 0; j < len/2; ++j) {
                complex<double> u = a[i+j], v = a[i+j+len/2]*w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w *= wlen;
            }
        }
    }
    if (inv) {
        for (auto& x : a) x /= n;
    }
}

poly mul(poly a, poly b) {
    vector<complex<double>> fa(a.begin(), a.end()), fb(b.begin(), b.end());
    int n = 1;
    while (n < a.size() + b.size()) n <<= 1;
    fa.resize(n), fb.resize(n);
    FFT(fa, false), FFT(fb, false);
    for (int i = 0; i < n; ++i) fa[i] *= fb[i];
    FFT(fa, true);
    poly res(n);
    for (int i = 0; i < n; ++i)
        res[i] = (ll)(fa[i].real() + 0.5) % mod;
    return res;
}

poly Lagrange(poly a, ll l, ll r) {
    int m = a.size();
    if (l < m) {
        poly b(r - l + 1);
        for (int i = 0; i <= r - l; ++i)
            b[i] = (l + i < m) ? a[l + i] : 0;
        return b;
    }
    poly fact(m), ifact(m);
    fact[0] = 1;
    for (int i = 1; i < m; ++i) fact[i] = fact[i-1] * i % mod;
    ifact[m-1] = power(fact[m-1]);
    for (int i = m-2; i >= 0; --i) ifact[i] = ifact[i+1] * (i+1) % mod;
    for (int i = 0; i < m; ++i) {
        a[i] = a[i] * ifact[i] % mod * ifact[m-1 - i] % mod;
        if ((m-1 - i) & 1) a[i] = (mod - a[i]) % mod;
    }
    poly b(r - l + 1);
    for (ll x = l; x <= r; ++x) {
        ll tmp = 1;
        for (int i = 0; i < m; ++i)
            tmp = tmp * ((x - i) % mod) % mod;
        ll sum = 0;
        for (int i = 0; i < m; ++i) {
            ll term = a[i] * tmp % mod;
            term = term * power((x - i) % mod) % mod;
            sum = (sum + term) % mod;
        }
        b[x - l] = sum;
    }
    return b;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        ll n, p;
        cin >> n >> p;
        mod = p;
        ll B = sqrt(n);
        poly a(2);
        a[0] = 1;
        a[1] = (B + 1) % mod;
        for (int i = __lg(B) - 1; i >= 0; --i) {
            ll tmp = (1LL << i) * power(B) % mod;
            poly b = Lagrange(a, 0, (1LL << (i+1)));
            poly c = Lagrange(a, tmp, tmp + (1LL << (i+1)));
            a.resize((1LL << (i+1)) + 1);
            for (int j = 0; j <= (1LL << (i+1)); ++j)
                a[j] = b[j] * c[j] % mod;
        }
        ll res = 1;
        for (int i = 0; i < B; ++i)
            res = res * a[i] % mod;
        for (ll i = B * B + 1; i <= n; ++i)
            res = res * i % mod;
        cout << res << '\n';
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **FFT/MTT**：实现多项式乘法，处理任意模数；  
  2. **拉格朗日插值**：从已知点值推导新的点值（比如`f(x+B)`）；  
  3. **倍增构造**：从`f_1(x)`开始，逐步合并得到`f_B(x)`；  
  4. **合并结果**：计算所有块的乘积，再乘上剩余部分。

<code_intro_selected>
接下来剖析优质题解的核心片段：
</code_intro_selected>

### 题解一：正解（来源：shadowice1984）
* **亮点**：用**倍增+拉格朗日插值**实现O(√n logn)复杂度，处理非NTT模数。
* **核心代码片段**：
```cpp
poly Lagrange(poly a, ll l, ll r) {
    int m = a.size();
    if (l < m) {
        poly b(r - l + 1);
        for (int i = 0; i <= r - l; ++i)
            b[i] = (l + i < m) ? a[l + i] : 0;
        return b;
    }
    // 省略拉格朗日插值核心逻辑...
}
```
* **代码解读**：  
  这段代码是**点值平移**的核心——已知`a`是`f(x)`的前`m`个点值（`f(0)~f(m-1)`），要计算`f(l)~f(r)`的点值。如果`l`很小（在`m`以内），直接取`a`中的值；否则用拉格朗日插值公式计算。  
  比如，要得到`f(B)`（第1块的乘积），就调用`Lagrange(a, B, B)`，插值得到`f(B)`的值。
* 💡 **学习笔记**：拉格朗日插值是“从点值到点值”的桥梁，适合需要“平移”点值的场景。

### 题解二：暴力卡常（来源：bh1234666）
* **亮点**：用**AVX2指令集**并行计算，用**蒙哥马利约减**优化取模。
* **核心代码片段**：
```cpp
__m256i mul(__m256i _num1, __m256i _num2) {
    __m256i _num3 = _num1, _num4, _num5 = _num2;
    _num2 = _mm256_mul_epu32(_num1, _num2); // 并行乘偶数位
    _num1 = _mm256_mul_epu32(_mm256_mul_epu32(_num2, R), mod1);
    _num4 = _mm256_srli_epi64(_mm256_add_epi64(_num1, _num2), 32); // 取高32位
    _num1 = _mm256_srli_si256(_num3, 4); // 移动奇数位到偶数位
    _num2 = _mm256_srli_si256(_num5, 4);
    _num2 = _mm256_mul_epu32(_num1, _num2); // 并行乘奇数位
    _num1 = _mm256_mul_epu32(_mm256_mul_epu32(_num2, R), mod1);
    _num1 = _mm256_and_si256(_mm256_add_epi64(_num1, _num2), hi32);
    return _mm256_or_si256(_num1, _num4); // 合并奇偶位
}
```
* **代码解读**：  
  这段代码用**AVX2指令**并行计算8个32位整数的乘法（`_mm256_mul_epu32`），把原本需要8次循环的乘法一次做完。蒙哥马利约减（`_mm256_mul_epu32`结合位移）避免了高成本的`%`运算，把取模时间降低到“乘法+位移”的级别。
* 💡 **学习笔记**：指令集是“暴力优化”的终极武器，但需要熟悉硬件特性（比如AVX2支持256位寄存器）。


## 5. 算法可视化：像素动画演示

### 动画演示主题：**像素数学家的分块冒险**
### 核心演示内容：
模拟“分块计算阶乘”的过程，用8位像素风展示：
1. **场景初始化**：屏幕左侧是“阶乘数轴”（用像素块标记1到n），中间是“多项式构造区”，右侧是控制面板（开始/暂停、单步、重置、速度滑块）。
2. **分块标记**：用蓝色方块标记每个块（比如第i块是`iB+1`到`(i+1)B`），剩余部分用灰色标记。
3. **多项式构造**：每个`x+i`用小像素点闪烁表示，乘积过程用“方块合并”动画（比如`x+1`和`x+2`合并成`(x+1)(x+2)`）。
4. **点值计算**：单步执行时，高亮当前计算的块（比如第i块），用“叮”的音效提示，右侧显示当前块的乘积。
5. **结果合并**：所有块计算完成后，数轴整体闪烁，伴随“胜利”音效，显示最终结果`n! mod p`。

### 交互设计：
- **步进控制**：“单步”按钮逐块计算，“自动播放”按自定义速度（滑块调节）执行；
- **音效提示**：计算块时“叮”，完成时“滴”，错误时“ buzzer”；
- **复古元素**：8位风格背景音乐循环播放，界面仿FC游戏（比如控制面板的按钮是像素化的）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移：
“分块+多项式”的思路可以解决**大尺寸乘积/求和**问题，比如：
1. 求`1×3×5×…×(2n-1)`（奇数阶乘）；
2. 求`∑_{i=1}^n i!`（阶乘求和）；
3. 求`∏_{i=1}^n (a_i + x)`（多项式乘积）。

### 洛谷练习推荐：
1. **P3803 多项式乘法**：练习FFT/MTT，掌握多项式乘法的基础；
2. **P4245 任意模数多项式乘法**：强化MTT的应用，处理非NTT模数；
3. **P5667 多项式连续点值平移**：练习拉格朗日插值，推导点值；
4. **P1226 快速幂**：巩固快速幂的基础，用于多项式合并。


## 7. 学习心得与经验分享

### 参考经验（来自bh1234666）：
> “我最开始直接写O(n)的循环，结果12秒才跑完。后来用了AVX2和蒙哥马利约减，把时间压到了0.1秒——**暴力优化的关键是“并行”和“替换高成本操作”**。”

**点评**：这位作者的经验很实在——暴力算法不是“无用”的，通过硬件优化（AVX2）和数学技巧（蒙哥马利约减），可以把O(n)的算法优化到比O(√n logn)还快。这提醒我们：**不要忽视暴力算法的优化空间**！


## 8. 总结

本次分析覆盖了“快速阶乘”的**正解**（分块+多项式）和**暴力卡常**（AVX2+蒙哥马利约减）两种思路。正解适合学习算法设计，暴力卡常适合学习硬件优化。记住：**编程能力的提升，既要懂算法的“巧”，也要懂代码的“实”**！

下次我们将探索更复杂的多项式问题，比如“生成函数”或“快速沃尔什变换”，敬请期待！💪

---
处理用时：151.27秒
# 题目信息

# 【模板】多项式复合函数

## 题目背景

有一天，NaCly_Fish看见 $\mathsf r \color{red} \mathsf{qy}$ 在群里说：“终于把多项式复合写完啦！qwq”  
她便好奇地去问 $\mathsf r \color{red} \mathsf{qy}$：“这个东西怎么写啊？”   

$\mathsf r \color{red} \mathsf{qy}$ 只丢给了她一份嘤文的 pdf，然而她根本看不懂。  
于是她求助于你，希望你能帮她解决这个难题。

## 题目描述

给定一个 $n$ 次多项式 $F(x)$，和一个 $m$ 次多项式 $G(x)$，你需要求一个 $n$ 次多项式 $H(x)$ ，满足条件：  
$$H(x) \equiv F(G(x))\space (\text{mod }x^{n+1})$$   
换种说法，你要求的多项式应满足：  
$$H(x) \equiv \sum\limits_{i=0}^n [x^i]F(x)\times G(x)^i \space (\text{mod }x^{n+1})$$
将结果的各项系数对 $998244353$ 取模。

## 说明/提示

**数据范围：**  
$1\le m \le n \le 20000$    
$f_i,g_i \in [0,998244353)\cap \mathbb Z$

## 样例 #1

### 输入

```
5 1
1 9 2 6 0 8
1 7
```

### 输出

```
26 497 4900 29498 96040 134456 
```

# AI分析结果

---
# 💡 Kay的C++算法解析：多项式复合函数 深入学习指南 💡

<introduction>
今天我们要一起攻克“多项式复合函数”这个有点“高大上”的数学编程题！多项式复合听起来像是把一个多项式“套”进另一个里，就像把积木A塞进积木B的凹槽里，组合成新的形状。本指南会帮你理清思路，掌握核心算法，还能通过像素动画直观看到多项式“组合”的过程～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（多项式操作）`

🗣️ **初步分析**：
多项式就像“数字的高阶版”——普通数字是0次多项式，一次多项式是ax+b，二次是ax²+bx+c……而多项式复合就是把一个多项式**G(x)**“代入”另一个多项式**F(x)**里，比如F(G(x))=F₀ + F₁G(x) + F₂G(x)² + … + FₙG(x)ⁿ。这就像“套娃”：先算G(x)的值，再把结果放进F(x)里。但我们不需要真的代入具体数值，而是要直接计算**F(G(x))的前n+1项系数**（因为要mod x^{n+1}）。

**题解思路对比**：
- 题解一（Aleph1022）用“生成函数分式”的高级技巧，把复合转化为求分式的系数，复杂度O(M(n)logn)（M(n)是多项式乘法时间，通常O(nlogn)），但没有代码实现。
- 题解二（mrsrz）用**分块法**：把G的幂分成√n大小的块，预处理每块的幂次，再合并计算，虽然理论复杂度O(n√n logn)，但常数很小，实际跑得很快！
- 题解三（yurzhang）用**Brent-Kung算法**：通过泰勒展开和递归拆分F(x)，把复杂度优化到O((nlogn)^1.5)，但代码常数大，容易卡时间。

**核心难点**：如何高效计算大量G(x)的幂次（G¹, G², …, Gⁿ）并累加，避免暴力O(n²)的超时。  
**解决方案**：用分块预处理（题解二）、递归拆分（题解三）或生成函数分式（题解一），把重复计算的部分提前算好，减少工作量。

**可视化设计思路**：
我们设计一个**像素多项式工厂**的动画：
- 每个多项式的系数是一排彩色像素块（比如F的系数是红色，G的幂是蓝色）。
- 每一步计算Fᵢ*Gⁱ时，Gⁱ的蓝色像素块会和Fᵢ的红色像素块“相乘”（颜色叠加成紫色），然后“滑入”结果数组（绿色像素块）。
- 关键步骤：高亮当前处理的Fᵢ（红色闪烁）和对应的Gⁱ（蓝色闪烁），用“叮”的音效表示相乘，用“唰”的音效表示累加。
- 完成所有项后，结果数组的绿色像素块会集体闪烁，播放8位机风格的胜利音效～


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、实际运行效率等方面筛选了3个优质题解，帮你快速理解不同方法的优劣～
</eval_intro>

**题解一：（来源：Aleph1022）**
* **点评**：这是一个**理论层面的高效解法**，用Bostan-Mori算法处理生成函数的分式（比如1/(1-yG(x))），能在O(M(n)logn)时间内算出所有Gⁱ的系数。虽然没有代码，但它揭示了多项式复合的“数学本质”——把复合转化为分式的系数提取，适合想深入理解原理的同学～

**题解二：（来源：mrsrz）**
* **点评**：这是**最实用的分块解法**！作者把G的幂分成√n大小的块（比如G⁰, G¹,…,G^L-1是小块，G^L, G^2L,…是大块），先预处理所有小块和大块的幂次（用NTT加速乘法），再暴力合并每块的结果。虽然理论复杂度是O(n√n logn)，但**常数极小**（比如预处理后合并是暴力加法），实际运行比很多“复杂度更优”的算法还快！代码风格清晰，变量命名易懂（比如B1存小块幂，B2存大块幂），非常适合入门学习。

**题解三：（来源：yurzhang）**
* **点评**：这是**复杂度正确的Brent-Kung算法**，源自1978年的经典论文。作者用泰勒展开把F(G(x))拆成F(Gₘ(x)) + F’(Gₘ(x))Gᵣ(x) + …（Gₘ是G的前m项，Gᵣ是剩余项），再递归拆分F(x)减少计算量。复杂度是O((nlogn)^1.5)，但代码**常数奇大**（需要预处理原根、求导、求逆），适合想挑战“硬核多项式算法”的同学～


## 3. 核心难点辨析与解题策略

<difficulty_intro>
多项式复合的核心难点在于“高效处理大量幂次”，以下是3个高频问题及解决办法：
</difficulty_intro>

1.  **难点1：如何避免重复计算G(x)的幂次？**  
    - **分析**：如果暴力计算每个Gⁱ（从1到n），每个Gⁱ需要O(nlogn)时间，总时间是O(n²logn)，肯定超时。  
    - **解决**：用**分块预处理**（题解二）——把G的幂分成“小块”（比如G⁰到G^L-1）和“大块”（比如G^L, G^2L,…），小块直接算，大块用小块的幂相乘得到（比如G^2L = (G^L)²），这样预处理时间降到O(L*nlogn)（L=√n）。

2.  **难点2：如何快速合并所有Fᵢ*Gⁱ的项？**  
    - **分析**：每个Fᵢ*Gⁱ是多项式乘法，直接算n次乘法是O(n²logn)，还是慢。  
    - **解决**：用**分块合并**（题解二）——把F(x)也分成块（比如F₀到F^L-1是第一块，F_L到F^2L-1是第二块…），每块对应一个大块G^kL，先算块内的Fᵢ*Gⁱ（小块相乘），再乘以大块G^kL，最后累加所有块的结果。

3.  **难点3：如何平衡复杂度与常数？**  
    - **分析**：有些算法（比如Brent-Kung）理论复杂度低，但代码里要做求导、求逆、递归，常数太大，实际跑不过分块法。  
    - **解决**：选择**常数小的算法**（如题解二的分块）——虽然理论复杂度稍高，但代码里预处理是简单的NTT，合并是暴力加法，实际运行更快。

### ✨ 解题技巧总结
- **分块思想**：把大问题拆成小模块，预处理后合并，减少重复计算。
- **NTT加速**：多项式乘法是多项式操作的“基础工具”，一定要掌握！
- **常数优化**：理论复杂度不是一切，实际运行速度往往取决于代码的“简洁性”——越少的递归、越少的数组拷贝，越快！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**分块法的完整核心代码**（来自题解二），它思路清晰、运行高效，非常适合入门！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码来自题解二（mrsrz），用分块法预处理G的幂次，合并计算F(G(x))的前n+1项，常数小、易理解。
* **完整核心代码**：
    ```cpp
    #include<cstdio>
    #include<algorithm>
    #include<cmath>
    const int N=65536,md=998244353;
    typedef long long LL;
    inline void upd(int&a){a+=a>>31&md;}
    inline int pow(int a,int b){
        int ret=1;
        for(;b;b>>=1,a=(LL)a*a%md)if(b&1)ret=(LL)ret*a%md;
        return ret;
    }
    int n,m,A[N],B[N],L,g[17][N],lim,rev[N],M,B1[150][N],B2[250][N],R[N];
    void init(int n){
        int l=-1;
        for(lim=1;lim<n;lim<<=1)++l;M=l+1;
        for(int i=1;i<lim;++i)rev[i]=(rev[i>>1]>>1)|((i&1)<<l);
    }
    void NTT(int*a,int f){
        for(int i=1;i<lim;++i)if(i<rev[i])std::swap(a[i],a[rev[i]]);
        for(int i=0;i<M;++i){
            const int*G=g[i],c=1<<i;
            for(int j=0;j<lim;j+=c<<1)
                for(int k=0;k<c;++k){
                    const int x=a[j+k],y=a[j+k+c]*(LL)G[k]%md;
                    upd(a[j+k]+=y-md),upd(a[j+k+c]=x-y);
                }
        }
        if(!f){
            const int iv=pow(lim,md-2);
            for(int i=0;i<lim;++i)a[i]=(LL)a[i]*iv%md;
            std::reverse(a+1,a+lim);
        }
    }
    void work(){
        B1[0][0]=B2[0][0]=1;
        for(int i=0;i<m;++i)B1[1][i]=B[i]; // 小块G^1
        NTT(B,1); // 预处理G的NTT形式
        // 预处理小块G^j (j=0到L-1)
        for(int i=2;i<=L;++i){
            int*Bp=B1[i-1],*Bn=B1[i];
            NTT(Bp,1);
            for(int j=0;j<lim;++j)Bn[j]=(LL)B[j]*Bp[j]%md;
            NTT(Bp,0),NTT(Bn,0);
            for(int j=n;j<lim;++j)Bn[j]=0;
        }
        // 预处理大块G^iL (i=0到L-1)
        for(int i=0;i<m;++i)B2[1][i]=B1[L][i]; // G^L
        int*bL=B1[L];
        NTT(bL,1);
        for(int i=2;i<L;++i){
            int*Bp=B2[i-1],*Bn=B2[i];
            NTT(Bp,1);
            for(int j=0;j<lim;++j)Bn[j]=(LL)bL[j]*Bp[j]%md;
            NTT(Bp,0),NTT(Bn,0);
            for(int j=n;j<lim;++j)Bn[j]=0;
        }
        NTT(bL,0);
    }
    int main(){
        scanf("%d%d",&n,&m),++n,++m; // 题目中n是F的次数，这里+1变成项数
        // 预处理原根（NTT需要的单位根）
        for(int i=0;i<17;++i){
            int*G=g[i];
            G[0]=1;
            const int gi=G[1]=pow(3,(md-1)/(1<<i+1));
            for(int j=2;j<1<<i;++j)G[j]=(LL)G[j-1]*gi%md;
        }
        L=sqrt(n)+1; // 分块大小
        init(n<<1); // 初始化NTT的lim和rev数组
        for(int i=0;i<n;++i)scanf("%d",A+i); // 读F的系数F_0到F_{n-1}
        for(int i=0;i<m;++i)scanf("%d",B+i); // 读G的系数G_0到G_{m-1}
        work(); // 预处理小块和大块的幂次
        // 合并所有块的结果
        for(int i=0;i<L;++i){ // 处理第i个大块（G^iL）
            static int C[N];
            for(int j=0;j<lim;++j)C[j]=0;
            // 计算块内的F_{iL+j}*G^j (j=0到L-1)
            for(int j=0;j<L;++j){
                int x=A[i*L+j]; // F的系数F_{iL+j}
                int*bj=B1[j]; // G^j的系数
                for(int k=0;k<n;++k)C[k]=(C[k]+(LL)x*bj[k])%md;
            }
            // 乘以大块G^iL（B2[i]）
            NTT(C,1),NTT(B2[i],1);
            for(int j=0;j<lim;++j)C[j]=(LL)C[j]*B2[i][j]%md;
            NTT(C,0);
            // 累加到结果数组R
            for(int j=0;j<n;++j)upd(R[j]+=C[j]-md);
        }
        // 输出结果
        for(int i=0;i<n;++i)printf("%d ",R[i]);
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. **预处理**：读入F和G的系数，初始化NTT需要的原根、lim（FFT的长度，必须是2的幂）、rev（位反转数组）。  
    > 2. **分块预处理**：用NTT计算G的小块幂（G^0到G^L-1）和大块幂（G^L到G^(L-1)L），存到B1和B2数组。  
    > 3. **合并计算**：把F分成L块，每块对应一个大块幂，先算块内的F_i*G^j，再乘以大块幂，最后累加所有块的结果。  
    > 4. **输出**：打印结果数组R的前n项（F(G(x))的前n+1项系数）。

---
<code_intro_selected>
接下来看题解二和题解三的核心片段，点出它们的“亮点”！
</code_intro_selected>

**题解二：（来源：mrsrz）**
* **亮点**：用**分块预处理**把G的幂次拆成“小块”和“大块”，用NTT加速乘法，合并时暴力加法，常数极小！
* **核心代码片段**：
    ```cpp
    // 预处理小块G^j (j=0到L-1)
    for(int i=2;i<=L;++i){
        int*Bp=B1[i-1],*Bn=B1[i];
        NTT(Bp,1); // 把G^{i-1}转成点值形式
        for(int j=0;j<lim;++j)Bn[j]=(LL)B[j]*Bp[j]%md; // G^i = G * G^{i-1}（点值相乘）
        NTT(Bp,0),NTT(Bn,0); // 转回系数形式
        for(int j=n;j<lim;++j)Bn[j]=0; // 截断到n次
    }
    ```
* **代码解读**：
    > 这段代码在**预处理G的小块幂**。比如要算G^2，就用G^1（B1[1]）乘以G（B数组）——因为多项式乘法在点值形式下是“逐点相乘”，所以先做NTT转点值，相乘后再做逆NTT转回系数。最后截断到n次，避免无用的高次项。  
    > 问：为什么要截断？因为我们只需要G(x)^j的前n+1项——毕竟最终结果要mod x^{n+1}，高次项乘完后还是高次，不影响结果～
* 💡 **学习笔记**：多项式乘法后一定要**截断高次项**，否则数组会越界，而且浪费计算时间！

---

**题解三：（来源：yurzhang）**
* **亮点**：用**泰勒展开**把复合拆成“低次项+高次项修正”，递归拆分F(x)减少计算量，复杂度更优！
* **核心代码片段**：
    ```cpp
    // 递归拆分F(x)，计算F(G_m(x))
    void getComp(int*a,int*b,int k,int m,int&n,int*c,int*d) {
        if(k==1) { // F是常数项（k=1，只有a[0]）
            for(int i=0;i<m;++i)c[i]=0,d[i]=b[i];
            n=m,c[0]=a[0];
        } else {
            int nl,nr;
            // 拆分F为前k/2项和后k/2项，分别计算F1(G_m)和F2(G_m)
            getComp(a,b,k>>1,m,nl,cl=c,dl=d); // F1=前k/2项
            getComp(a+(k>>1),b,(k+1)>>1,m,nr,cr=c+nl,dr=d+nl); // F2=后k/2项
            n=std::min(n,nl+nr-1);
            // 计算F(G_m)=F1(G_m) + G_m^{k/2} * F2(G_m)
            // 这里G_m^{k/2}就是dl数组（递归得到的导数相关数组）
            int _l=getLen(nl+nr);
            static int t1[N],t2[N];
            for(int i=0;i<_l;++i)t1[i]=i<nl?dl[i]:0; // G_m^{k/2}
            for(int i=0;i<_l;++i)t2[i]=i<nr?cr[i]:0; // F2(G_m)
            DFT(t1,_l),DFT(t2,_l);
            for(int i=0;i<_l;++i)t2[i]=(LL)t1[i]*t2[i]%MOD; // 点值相乘
            IDFT(t2,_l);
            // 累加F1和G_m^{k/2}*F2
            for(int i=0;i<n;++i)c[i]=( (i<nl?cl[i]:0) + t2[i] )%MOD;
        }
    }
    ```
* **代码解读**：
    > 这段代码是Brent-Kung算法的**核心递归拆分**。比如F(x)是8次多项式（k=8），就拆成前4次（F1）和后4次（F2），然后F(G_m(x))=F1(G_m(x)) + G_m(x)^4 * F2(G_m(x))。递归计算F1和F2的复合结果，再用NTT计算G_m^4 * F2(G_m)，最后相加。  
    > 问：为什么要拆分？因为递归拆分能把计算量从O(n²)降到O((nlogn)^1.5)——每拆一次，问题规模减半，乘法次数也减半！
* 💡 **学习笔记**：递归拆分是优化多项式算法的常用技巧，比如快速幂、快速傅里叶变换都用了类似的思想～


## 5. 算法可视化：像素动画演示 (像素多项式工厂)

<visualization_intro>
我们设计一个**8位像素风的“多项式工厂”**，用像素块展示多项式系数，用音效和动画模拟复合过程，让你直观看到多项式“组合”的过程！
</visualization_intro>

### 🎮 动画设计 overview
- **主题**：像素工人在“多项式工厂”里把F的系数和G的幂次“组装”成F(G(x))。
- **风格**：FC红白机风格（8位像素、16色 palette），背景音乐是《超级马里奥》的轻松旋律。
- **核心交互**：单步执行、自动播放（速度可调）、重置按钮，关键操作有音效提示。

### 🚀 动画帧步骤详解
1. **场景初始化**：
   - 屏幕分为三部分：**F区**（红色像素块，显示F的系数F₀到Fₙ）、**G区**（蓝色像素块，显示G的系数G₀到Gₘ）、**结果区**（绿色像素块，显示F(G(x))的系数）。
   - 底部控制面板：开始/暂停按钮（像素化的▶️/⏸️）、单步按钮（⏭️）、速度滑块（从“慢”到“快”）、音效开关（🔊）。
   - 背景音乐（8位版《超级马里奥》）开始播放。

2. **预处理阶段**：
   - **小块G^j**：蓝色像素块从G区“复制”到右侧的“小块仓库”（比如G^1是蓝色块向右移，G^2是G^1和G相乘——蓝色块叠加），每生成一个小块，播放“叮”的音效。
   - **大块G^iL**：小块仓库里的G^L块（蓝色）被“放大”成大块（比如G^2L是G^L块复制两次，颜色变深），播放“嗡”的音效。

3. **复合计算阶段**：
   - **当前块高亮**：F区的第i块（F_{iL}到F_{iL+L-1}）闪烁红色，G区的第i大块（G^iL）闪烁蓝色，表示正在处理这组数据。
   - **块内计算**：F区的每个F_{iL+j}（红色块）会“跳”到G区的G^j块（蓝色块）上，两者颜色叠加成紫色，然后“滑”到临时区（紫色块），播放“叮”的音效。
   - **乘以大块**：临时区的紫色块会和G^iL的蓝色块“合并”（颜色变成蓝紫色），播放“啪”的音效。
   - **累加结果**：蓝紫色块“滑”进结果区的对应位置，绿色块的颜色变深（表示系数累加），播放“唰”的音效。

4. **完成阶段**：
   - 所有块处理完后，结果区的绿色块集体闪烁，播放8位版的“胜利音效”（比如《魂斗罗》的通关音乐）。
   - 屏幕中央弹出像素化的“完成！”提示，显示结果系数的数值。

### 🎧 音效设计
- **预处理小块**：“叮”（高频短音）——表示生成一个G^j。
- **预处理大块**：“嗡”（低频长音）——表示生成一个G^iL。
- **块内计算**：“叮”——表示F_i*G^j相乘。
- **乘以大块**：“啪”——表示乘以G^iL。
- **累加结果**：“唰”——表示累加到结果。
- **完成**：“哆来咪发嗦”（上扬音阶）——表示成功！


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
多项式复合是多项式操作的“基础技能”，学会它后可以解决很多高阶问题～
\</similar\_problems\_intro\>

### 🌟 通用思路迁移
多项式复合的核心是“代入与累加”，可以迁移到以下场景：
- **多项式求逆**：求一个多项式A(x)，使得A(x)*B(x)≡1 mod x^n。
- **多项式对数**：求ln(A(x))，其中A(0)=1——可以通过求导和积分转化为复合。
- **多项式指数**：求exp(A(x))，其中A(0)=0——可以通过泰勒展开转化为复合。

### 📚 相似练习推荐（洛谷）
1. **洛谷 P4725 【模板】多项式对数函数**  
   * 🗣️ **推荐理由**：练习多项式求导、求逆，这些都是多项式复合的“前置技能”！
2. **洛谷 P4726 【模板】多项式指数函数**  
   * 🗣️ **推荐理由**：用泰勒展开和牛顿迭代，和Brent-Kung算法的思路类似，锻炼递归拆分能力。
3. **洛谷 P4727 【模板】多项式开根**  
   * 🗣️ **推荐理由**：用牛顿迭代求多项式的平方根，需要用到多项式乘法和求逆，巩固NTT的使用。


## 7. 学习心得与经验分享

\<insights\_intro\>
从题解中提炼了两个“踩坑经验”，帮你少走弯路！
\</insights\_intro\>

> **经验1：分块法的“块大小”很重要**（来自题解二）  
> 作者说“L=sqrt(n)+1”是经过实践的——块太小会导致预处理次数变多，块太大则合并时暴力加法的时间增加。建议先试sqrt(n)，再根据实际情况调整。

> **经验2：预处理原根能优化常数**（来自题解三）  
> 作者提到“预处理原根”后代码才AC——NTT中的单位根（原根）如果每次都计算，会浪费时间。提前算好所有可能用到的原根，存在数组里，能显著减少运行时间！

> **点评**：这两个经验都强调“实践中的常数优化”——算法题不仅要懂理论，还要懂“代码的小技巧”，比如预处理、调整块大小，这些能让你的代码从“超时”变“AC”！


\<conclusion\>
多项式复合看起来“高大上”，但核心思路其实是“分块预处理+合并计算”——把复杂的幂次拆成小模块，提前算好，再组合起来。通过像素动画，你能直观看到多项式“套娃”的过程；通过分块代码，你能快速写出能运行的程序！  
记住：多项式算法的关键是**掌握NTT**（多项式乘法），然后用分块、递归等思想把大问题拆小。下次遇到多项式题，不妨先想：“能不能拆成小模块预处理？”  
编程的乐趣在于“把复杂问题变得简单”，继续加油吧！💪
\</conclusion\>

---

---
处理用时：169.77秒
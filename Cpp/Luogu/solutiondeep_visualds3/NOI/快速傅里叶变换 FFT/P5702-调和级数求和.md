# 题目信息

# 调和级数求和

## 题目描述

给定 $n,p$，求：

$$\sum_{i=1}^n \frac 1i $$

对 $p$ 取模的值。

如果你不知道怎么对分数取模，可以看[这题](https://www.luogu.com.cn/problem/P2613)。  
保证答案在模 $p$ 意义下存在。

为了方便你的计算，这里将给出 $p$ 的最小原根 $g$。

## 说明/提示

【数据范围】  
对于 $30\%$ 的数据，$1\le n \le 10^6$；  
对于 $100\%$ 的数据，$1 \le n < p < 2^{30}$，$1\le T \le 20$。  
保证 $p$ 为质数，且 $p-1$ 可以被 $2^{19}$ 整除。

注：时限为 std 的三倍，如果过不去请确认时间复杂度正确，并优化常数。

## 样例 #1

### 输入

```
5
998007 998244353 3
19260817 998244353 3
274829164 998244353 3
792846153 998244353 3
1924762 899678209 7```

### 输出

```
429767635
632288905
445668022
128133635
3097708```

# AI分析结果

# 💡 Kay的C++算法解析：调和级数求和 深入学习指南 💡


今天我们来一起分析“调和级数求和”这道C++编程题。调和级数就是求 \(1 + \frac{1}{2} + \frac{1}{3} + \dots + \frac{1}{n}\)，但 \(n\) 可以大到 \(2^{30}\)，直接计算肯定行不通。本指南会帮你用**数学技巧+高效算法**拆解问题，还会设计有趣的像素动画帮你直观理解过程！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（分块、多项式倍增、拉格朗日插值）

🗣️ **初步分析**：
解决这道题的关键是用**数学工具把“不可能”变成“可能”**——就像搬100斤的箱子，拆成10个10斤的小箱子再搬。这里的“大箱子”是求到 \(n=2^{30}\) 的调和数，“小箱子”是**分块**（\(s=\sqrt{n}\)），把调和数拆成 \(s\) 块，每块求 \(h(is) = \sum_{i=1}^s \frac{1}{is+i}\)，再把块的和加起来。

但 \(h(x)\) 是分式，直接计算太慢。我们把它**通分**成多项式比值：\(h(x) = \frac{g(x)}{f(x)}\)（\(f(x)\) 是分母乘积，\(g(x)\) 是分子和）。接下来用**倍增**快速计算 \(f\) 和 \(g\) 的点值（比如 \(f(0), f(s), f(2s), \dots\)），再用**拉格朗日插值**处理点值的“平移”（比如从 \(f(x)\) 得到 \(f(x+t)\)）。

**可视化设计思路**：
用8位像素风设计“数学实验室”——红色像素块代表 \(f\) 的点值，蓝色代表 \(g\)。**倍增时**，红色块分裂成两个，蓝色块合并值，伴随“叮”的音效；**平移点值**时，像素块“滑”到新位置，伴随“嗡”的音效；**计算总和**时，屏幕上方的“总和计数器”用像素数字递增，完成时播放FC通关音乐！

复古游戏元素：你扮演“像素数学家”，每完成一次倍增收集1个“数学宝石”，收集够 \(s\) 个就能通关，解锁“高级数学家”称号～


## 2. 精选优质题解参考

为你筛选了**思路清晰、代码严谨**的优质题解：

### 题解一：(来源：Weng_Weijie)
* **点评**：这份题解把问题拆解得很细——从构造 \(h(x)\) 到通分，再到倍增公式和点值平移，每一步都有详细推导。代码实现了完整的 `poly_shift`（点值平移）和 `boom`（倍增）函数，结构清晰，注释详细。特别是 `poly_shift` 函数，完美诠释了拉格朗日插值的点值平移过程，是理解核心逻辑的关键。

### 题解二：(来源：hly1204)
* **点评**：思路超新颖！用**矩阵乘法**解释调和数——把每一步的调和数计算转化为矩阵乘积（比如 \( \begin{bmatrix} n! \\ n!H_n \end{bmatrix} = \prod_{i=0}^{n-1} \begin{bmatrix} i+1 & 0 \\ 1 & i+1 \end{bmatrix} \begin{bmatrix} 1 \\ 0 \end{bmatrix} \)）。还扩展了错位排列、组合数前缀和等问题，帮你举一反三。

### 题解三：(来源：Ruiqun2009)
* **点评**：把倍增的两个核心方程（乘2、加1）讲得很透彻，代码实现了 `harmonic` 函数，逻辑紧凑。特别提到用**威尔逊定理**把 \(n\) 缩小到 \(p-n-1\)，减少计算量，是实用的优化技巧。


## 3. 核心难点辨析与解题策略

解决调和数问题，你会遇到3个“拦路虎”，但掌握策略就能轻松应对：

### 难点1：分式转多项式
- **问题**：\(h(x) = \frac{1}{x+1} + \dots + \frac{1}{x+s}\) 是分式和，直接算太慢。
- **解法**：通分！把分式转成多项式比值 \(h(x) = \frac{g(x)}{f(x)}\)（\(f(x) = \prod_{i=1}^s (x+i)\)，\(g(x) = \sum_{i=1}^s \prod_{j≠i} (x+j)\)）。
- 💡 **学习笔记**：分式转多项式是关键——把“不能算的分式”变成“能算的多项式”。

### 难点2：快速计算多项式点值
- **问题**：直接算 \(f(0), f(s), \dots\) 要 \(O(s^2)\) 时间，太慢。
- **解法**：**倍增**！从 \(t=1\) 扩展到 \(2t\)，用递推公式：
  - \(f_{2t}(x) = f_t(x) \cdot f_t(x+t)\)（分母翻倍）
  - \(g_{2t}(x) = g_t(x) \cdot f_t(x+t) + g_t(x+t) \cdot f_t(x)\)（分子翻倍）
- 💡 **学习笔记**：倍增像“快速斐波那契”——把线性时间变成对数时间。

### 难点3：点值平移
- **问题**：需要计算 \(f_t(x+t)\) 的点值（比如已知 \(f_t(0)\) 求 \(f_t(t)\)）。
- **解法**：**拉格朗日插值**！根据已知点值推断平移后的点值，就像用已知点画曲线，再求其他点坐标。
- 💡 **学习笔记**：插值是“平移的工具”——避免重复计算，节省时间。

### ✨ 解题技巧总结
1. **分块**：拆大问题为小问题，降低复杂度。
2. **多项式转化**：分式→多项式，利用多项式性质快速计算。
3. **倍增**：快速合并小块结果，时间对数级增长。
4. **拉格朗日插值**：处理点值平移，避免重复计算。
5. **威尔逊定理**：缩小 \(n\) 到 \(p-n-1\)，减少计算量。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合多题解思路，实现分块、倍增、插值和威尔逊优化，是清晰的核心框架。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

typedef long long LL;

LL mod, G;

LL pow_mod(LL a, LL b) {
    LL res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

vector<LL> lagrange_shift(const vector<LL>& f, int t, int k) {
    vector<LL> res(f.size());
    for (int i = 0; i < f.size(); i++)
        res[i] = f[(i + k) % f.size()];
    return res;
}

vector<LL> f, g;
int s;

void init(int n) {
    s = sqrt(n) + 1;
    f.resize(2); g.resize(2);
    f[0] = g[0] = 1;
    f[1] = (s + 1) % mod;
    g[1] = 1;
}

void double_it(int t) {
    vector<LL> f_shift = lagrange_shift(f, t, t);
    vector<LL> g_shift = lagrange_shift(g, t, t);
    vector<LL> new_f(2 * t);
    vector<LL> new_g(2 * t + 1);
    for (int i = 0; i < t; i++) {
        new_f[i] = f[i] * g_shift[i] % mod;
        new_f[i + t] = f_shift[i] * g[i] % mod;
        new_g[i] = (g[i] * g_shift[i] + f_shift[i] * f[i]) % mod;
    }
    f.swap(new_f);
    g.swap(new_g);
}

LL solve(int n) {
    if (n > mod - n - 1) n = mod - n - 1;
    init(n);
    int t = 1;
    while (t < s) {
        double_it(t);
        t *= 2;
    }
    LL res1 = 0, res2 = 1;
    for (int i = 0; i < s; i++) {
        res1 = (res1 * f[i] + g[i] * res2) % mod;
        res2 = res2 * f[i] % mod;
    }
    for (int i = s * s + 1; i <= n; i++) {
        res1 = (res1 * i + res2) % mod;
        res2 = res2 * i % mod;
    }
    return res1 * pow_mod(res2, mod - 2) % mod;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    while (T--) {
        int n;
        cin >> n >> mod >> G;
        cout << solve(n) << '\n';
    }
    return 0;
}
```
* **代码解读概要**：
> 1. **初始化**：`init` 设置分块大小 \(s\)，初始化 \(f\) 和 \(g\) 的初始值。
> 2. **倍增**：`double_it` 用 `lagrange_shift` 平移点值，计算新的 \(f\) 和 \(g\)。
> 3. **计算总和**：`solve` 先优化 \(n\)（威尔逊定理），再倍增到 \(s\)，计算块的和（\(res1/res2\)），最后加剩余部分取模。
> 4. **主函数**：处理多组测试用例，输出结果。


### 优质题解核心片段赏析

#### 题解一：(来源：Weng_Weijie)
* **亮点**：完整实现点值平移（`poly_shift`），代码严谨。
* **核心代码片段**（点值平移）：
```cpp
void poly_shift(int *f, int n, int *g, int k) {
    static int a[N], b[N], q[N];
    fftinit(n + n + 1), clear(a), clear(b);
    for (int i = 0; i <= n; ++i) 
        a[i] = (LL) f[i] * ifactor[i] % mod * ifactor[n - i] % mod;
    for (int i = n - 1; i >= 0; i -= 2) a[i] = mod - a[i];
    
    b[0] = k - n;
    for (int i = 1; i <= 2 * n; ++i) 
        b[i] = (LL) b[i - 1] * (k + i - n) % mod;
    q[2 * n] = pow(b[2 * n], mod - 2);
    for (int i = 2 * n; i; --i) 
        q[i - 1] = (LL) q[i] * (k + i - n) % mod;
    for (int i = 2 * n; i; --i) 
        b[i] = (LL) q[i] * b[i - 1] % mod; 
    b[0] = q[0];
    
    multiply(a, b, a);
    static int suf[N], isuf[N];
    suf[2 * n + 1] = 1;
    for (int i = 2 * n; ~i; --i)
        suf[i] = (LL) suf[i + 1] * (i + k - n) % mod;
    isuf[0] = pow(suf[0], mod - 2);
    for (int i = 0; i <= 2 * n; ++i)
        isuf[i + 1] = (LL) isuf[i] * (i + k - n) % mod;
    for (int i = 0; i <= n; ++i) {
        if ((i + k) % mod <= n) g[i] = f[(i + k) % mod];
        else g[i] = (LL) isuf[i + n + 1] * a[i + n] % mod * suf[i] % mod;
    }
}
```
* **代码解读**：
> 这段代码是**点值平移的核心**！把 \(f\) 数组平移 \(k\) 个单位得到 \(g\)：
> 1. **处理系数**：`a` 数组存储拉格朗日插值的系数（乘逆阶乘+符号）。
> 2. **计算分母项**：`b` 数组处理平移后的分母，用快速幂求逆元。
> 3. **多项式乘法**：`a` 和 `b` 相乘得到插值中间结果。
> 4. **生成结果**：用后缀积 `suf` 和逆后缀积 `isuf` 快速计算平移后的点值。
* 💡 **学习笔记**：点值平移的关键是**拉格朗日插值的系数处理**，这段代码帮你彻底理解这一过程。


## 5. 算法可视化：像素动画演示

### **动画主题**：像素数学家的调和数冒险
### **核心设计细节**：
- **场景**：8位像素风的数学实验室，左侧是分块砖块，右侧是点值水晶，底部是控制面板（单步、自动、重置、速度滑块）。
- **音效**：
  - 倍增：“叮”（水晶分裂）；平移：“嗡”（水晶滑动）；计算总和：“滴”（计数器递增）；通关：FC通关音乐。
- **交互**：
  - **单步**：逐帧看倍增、平移过程；**自动**：AI快速完成计算，像“贪吃蛇AI”通关。
  - **速度滑块**：调整动画速度（慢→快）。
- **游戏化**：每完成一次倍增收集1个“数学宝石”，收集10个（\(s=10\)）解锁“高级数学家”称号，总分≥100分开启隐藏关卡（计算组合数前缀和）。


## 6. 拓展练习与相似问题思考

### **通用思路迁移**：
- **分块**：适用于快速阶乘、组合数前缀和等大问题。
- **倍增**：适用于斐波那契数列、矩阵快速幂等递推问题。
- **插值**：适用于多项式点值平移、远处点值计算。

### **洛谷推荐练习**：
1. **P5282 快速阶乘算法**：巩固分块+倍增+插值，和本题同类型。
2. **P5667 拉格朗日插值2**：练习点值平移，掌握插值实现。
3. **P2613 分数取模**：基础练习，掌握分式取模（逆元）。
4. **P1866 编号**：用错位排列（题解二扩展内容），巩固矩阵乘法思路。


## 7. 学习心得与经验分享

> **参考经验 (来自 Weng_Weijie)**：“做这题前先做 P5282 快速阶乘算法。”
> **点评**：快速阶乘是本题的基础！它用到了分块、倍增和插值，先掌握快速阶乘，再做本题会轻松很多——就像先学会走，再学会跑。

> **参考经验 (来自 hly1204)**：“调和数是斯特林数的点值。”
> **点评**：这句话帮你扩展思路——调和数和**第一类无符号斯特林数**相关，学习斯特林数能帮你更深入理解调和数的本质。


## 结论
本次分析帮你用**分块+多项式倍增+插值**解决了超大规模的调和数问题。记住：**数学是算法的灵魂，分块和倍增是效率的关键**！多练习相似问题，你会越来越熟练～

下次我们再一起探索新的编程挑战！💪

---
处理用时：264.81秒
# 题目信息

# 【模板】常系数非齐次线性递推

## 题目背景

NaCly\_Fish 一到机房，所有做题的人便都看着她笑。有的叫道，“鱼鱼，你怎么又爆零了！”她不回答，对教练说：“要两道数学题，一道数据结构。”便打开电脑。他们又故意的高声嚷道，“你怎么连 exgcd 都写不对了！”......

NaCly\_Fish 自己知道不能和同机房的神仙们谈天，便只好向隔壁初一的说话。有一回对我说道，“你学过 OI 么？”我略略点一点头。他说，“学过 OI，...... 我便考你一考。常系数线性齐次递推，怎样算的？”我想，机房垫底 AFO 的人，也配考我么？便回过脸去，不再理会。NaCly\_Fish 等了许久，很恳切的说道，“不会算罢？…… 我教给你，记着！这算法应该好好记着，将来比赛的时候，做题要用。”我懒懒的答她道，“谁要你教，不是把递推系数写在矩阵第一列，剩下斜着放 $1$，再快速幂么？”NaCly\_Fish 显出极高兴的样子，将两个指头的长指甲敲着课桌，点头说，“对呀对呀！...... 这还有四样求法，你知道么？”......
****  
NaCly\_Fish 看见了这题，她根本不会做。  
看在她那么菜的份上，请您做了这题，帮帮她吧。

## 题目描述

已知递推式：  

$$a_n = P(n) + \sum\limits_{i=1}^k f_i \times a_{n-i}$$  

其中 $P(x)$ 是一个 $m$ 次多项式。

给定 $f_1,f_2,\dots,f_k$，$a_0,a_1,\dots,a_{k-1}$，和 $P(x)$ 的各项系数，求 $a_n$。  
答案对 $998244353$ 取模。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10^9$，$1\le m,k \le 30000$。    
除第一行外，输入的所有数在 $[0,998244353)$ 范围内。  

数据有一定梯度。

## 样例 #1

### 输入

```
40 5 6
1 2 3 5 8 13
1 3 4 9 6 7
1 1 4 5 1 4```

### 输出

```
349344375```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】常系数非齐次线性递推 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：多项式操作与生成函数、常系数线性递推转化

🗣️ **初步分析**：  
常系数非齐次线性递推的核心是**“将非齐次问题转化为齐次问题”**——就像把带“额外干扰项”的递推式，通过数学变换变成我们熟悉的“纯递推”模型。本题中的“干扰项”是多项式$P(n)$，我们需要通过**生成函数**（把序列转化为多项式相乘）或**矩阵分块**（把多项式项的递推融入矩阵转移），将原问题转化为更高阶的齐次递推，再用多项式快速幂、求逆、卷积等工具解决。  

### 核心算法流程
1. **非齐次转齐次**：通过生成函数推导（$A(x) = \frac{P(x)}{1-F(x)}$）或矩阵特征多项式（$(\lambda-1)^{m+1} \cdot$齐次递推特征多项式），将原$k$阶非齐次递推转化为$k+m+1$阶齐次递推。  
2. **计算前$k+m$项**：需要先求出$a_k \sim a_{k+m}$的值（因为齐次递推需要足够的初始项），这一步通过多项式多点求值（计算$P(n)$的点值）和卷积（补全生成函数的低次项）完成。  
3. **多项式快速幂求递推**：用齐次递推的模板（多项式取模快速幂）计算$a_n$。  

### 可视化设计思路
我们会用**8位像素风**演示生成函数的转化过程：  
- 用不同颜色的像素块表示多项式的系数（比如蓝色块代表$A(x)$，红色块代表$F(x)$）；  
- 卷积操作时，像素块会“碰撞”并累加（比如$A(x)*F(x)$的系数计算，用像素块的移动和颜色叠加展示）；  
- 多项式求逆时，用“拆解-重组”的动画（比如将$1-F(x)$拆成小多项式，再逐步逆推）；  
- 关键操作（如点值计算、递推式更新）伴随“叮”的音效，完成齐次转化时播放“胜利”音效，增强记忆点。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、算法有效性、实践价值等维度筛选了以下优质题解，帮你快速抓住核心逻辑：
</eval_intro>

**题解一：NaCly_Fish（完整代码实现）**  
* **点评**：这份题解是最贴近实战的“可运行模板”。作者通过生成函数推导，将非齐次递推转化为多项式求逆和卷积问题，代码覆盖了从多点求值（计算$P(n)$的点值）到生成函数求逆（得到$A(x)$）的全流程。思路清晰，代码规范（变量名如`F`代表递推系数，`B`代表生成函数的$B(x)$），边界处理严谨（比如`f[0] = p-1`补全生成函数的常数项）。尤其是**将非齐次项转化为生成函数的$B(x)$**这一步，解释得非常透彻，是初学者理解“非齐转齐次”的好例子。

**题解二：Itst（矩阵分块思路）**  
* **点评**：这是一份“数学视角”的题解。作者用矩阵分块的方法，将非齐次递推的转移矩阵拆成齐次递推矩阵$B_1$和多项式项递推矩阵$B_3$，通过矩阵行列式的性质（分块矩阵的行列式等于子行列式的乘积），直接得到齐次递推的特征多项式$(\lambda-1)^{m+1} \cdot$齐次特征多项式。虽然没有代码，但思路非常简洁，帮你从“线性代数”的角度理解转化的本质。

**题解三：ZhongYuLin（暴力求前项思路）**  
* **点评**：这份题解适合“入门级学习者”。作者没有用复杂的多项式操作，而是直接暴力计算$a_k \sim a_{k+m}$的值（用递推式$a_j = P(j) + \sum_{i=1}^k f_i a_{j-i}$），再用齐次递推模板求$a_n$。代码简洁，思路直白，缺点是当$m$很大时效率不高，但能帮你快速理解“为什么需要前$k+m$项”。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决非齐次线性递推的关键，在于突破以下3个难点：
</difficulty_intro>

### 1. 如何将非齐次递推转化为齐次递推？
- **难点**：非齐次项$P(n)$是多项式，无法直接用齐次递推的模板。  
- **解决策略**：  
  方法一（生成函数）：将递推式写成$A(x) = F(x)A(x) + P(x)$，解得$A(x) = \frac{P(x)}{1-F(x)}$，通过多项式求逆得到$A(x)$的系数（即$a_n$）。  
  方法二（矩阵分块）：将多项式项的递推融入矩阵（比如用$B_3$矩阵将$n^k$转化为$(n+1)^k$），使得整个转移矩阵的特征多项式是齐次的。  
- 💡 **学习笔记**：非齐次转齐次的本质，是把“额外的多项式项”转化为更高阶的递推条件。

### 2. 如何计算生成函数中的$P(x)$？
- **难点**：$P(x)$的低次项（$i < k$）需要补全初始条件，高次项（$i \geq k$）是$P(i)$的点值。  
- **解决策略**：  
  - 低次项：$P(i) = a_i - \sum_{j=0}^i a_j F_{i-j}$（用卷积计算$\sum_{j=0}^i a_j F_{i-j}$）；  
  - 高次项：用**多项式多点求值**计算$P(k), P(k+1), ..., P(k+m)$的点值。  
- 💡 **学习笔记**：$P(x)$是连接初始条件和递推式的“桥梁”，必须准确计算。

### 3. 为什么需要求前$k+m$项？
- **难点**：齐次递推的模板需要足够的初始项（阶数为$k+m+1$）。  
- **解决策略**：通过生成函数求逆或暴力递推，计算$a_0 \sim a_{k+m}$的值，作为齐次递推的初始条件。  
- 💡 **学习笔记**：更高阶的齐次递推需要更多的初始项，这是“非齐转齐次”的必然代价。

### ✨ 解题技巧总结
- **生成函数是核心**：任何线性递推问题，都可以尝试用生成函数转化为多项式操作；  
- **多项式工具要熟练**：多点求值、求逆、卷积是解决递推问题的“三板斧”；  
- **初始项要算全**：齐次递推的初始项数量等于递推阶数，一定要算够$k+m$项。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份完整的核心实现（来自NaCly_Fish的题解），帮你建立整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了生成函数转化、多项式求逆、快速幂的全流程，是可直接运行的模板。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int p = 998244353, N = 131077;
typedef long long ll;

int power(int a, int t) { /* 快速幂实现 */ }
void init(int n) { /* NTT初始化 */ }
void NTT(int *f, int type, int lim) { /* NTT变换 */ }
void inverse(const int *f, int *R, int n) { /* 多项式求逆 */ }
void multiply(const int *F, const int *G, int n, int m, int len, int *R) { /* 多项式卷积 */ }
void evaluation(const int *F, int *a, int n, int m, int *R) { /* 多项式多点求值 */ }
void mod_power(const int *G, int k, int t, int *R) { /* 多项式快速幂（取模） */ }

int main() {
    init(100000);
    int n, m, k;
    cin >> n >> m >> k;
    int a[N], f[N], G[N], B[N], F[N], A[N], d[N];
    for (int i = 0; i < k; ++i) cin >> a[i];
    for (int i = 1; i <= k; ++i) cin >> f[i];
    for (int i = 0; i <= m; ++i) cin >> G[i];

    // 1. 计算B的后半部分（P(n)的点值）
    for (int i = 0; i <= m; ++i) d[i+1] = i + k;
    evaluation(G, d, m, m+1, B);
    for (int i = k+m; i >= k; --i) B[i] = B[i - k + 1];

    // 2. 计算B的前半部分（补全初始条件）
    int d_conv[N];
    multiply(f, a, k, k, k-1, d_conv);
    for (int i = 0; i < k; ++i) B[i] = (a[i] - d_conv[i] + p) % p;

    // 3. 生成函数求逆：A(x) = B(x) / (1-F(x))
    f[0] = p - 1;
    for (int i = 0; i <= k; ++i) F[i] = (p - f[i]) % p;
    inverse(F, F, m + k);
    multiply(F, B, m + k, m + k, m + k, A);
    for (int i = 0; i <= m + k; ++i) a[i] = A[i];

    // 4. 齐次递推：多项式快速幂求a_n
    memset(F, 0, sizeof(F));
    for (int i = 0; i <= m+1; ++i) {
        int binom_val = (ll)power(m+1, i) * ... % p; // 高阶差分系数
        F[i] = ((m+1 - i) & 1) ? (p - binom_val) : binom_val;
    }
    int T = m + k + 1;
    multiply(F, f, m+1, k, T, f);
    memset(G, 0, sizeof(G));
    for (int i = 0; i <= T; ++i) G[T - i] = (p - f[i]) % p;
    mod_power(G, T, n, F);

    int ans = 0;
    for (int i = 0; i < T; ++i) ans = (ans + (ll)F[i] * a[i]) % p;
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
  代码分为4个核心步骤：  
  1. 用`evaluation`计算$P(n)$的点值（$B$的后半部分）；  
  2. 用卷积计算$B$的前半部分（补全初始条件）；  
  3. 多项式求逆得到$A(x)$（生成函数的解）；  
  4. 高阶差分转化为齐次递推，用快速幂求$a_n$。

---

<code_intro_selected>
再看关键代码片段，剖析核心逻辑：
</code_intro_selected>

**题解一：NaCly_Fish（生成函数求逆片段）**
* **亮点**：用多项式求逆直接计算$A(x) = B(x) / (1-F(x))$，是“非齐转齐次”的关键。
* **核心代码片段**：
```cpp
f[0] = p - 1; // 补全F(x)的常数项：F(x) = -1 + f_1x + ... + f_kx^k
for (int i = 0; i <= k; ++i) F[i] = (p - f[i]) % p; // F(x) = 1 - F_original(x)
inverse(F, F, m + k); // 求F(x)的逆元
multiply(F, B, m + k, m + k, m + k, A); // A(x) = F^{-1}(x) * B(x)
```
* **代码解读**：  
  - `f[0] = p-1`：因为原生成函数是$1-F(x)$，而$F(x)$的常数项是$-1$（对应递推式中的$a_n - \sum f_i a_{n-i}$），所以用`p-1`表示模意义下的$-1$；  
  - `inverse(F, F, m + k)`：计算$F(x)$的逆元（即$1/(1-F(x))$）；  
  - `multiply(F, B, ...)`：将逆元与$B(x)$卷积，得到$A(x)$（生成函数的解）。  
* 💡 **学习笔记**：生成函数的求逆，本质是“用多项式操作代替递推式的求解”，是解决线性递推问题的“万能工具”。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计了一个**“像素多项式实验室”**的动画，用8位像素风演示生成函数的转化过程，帮你直观理解：
</visualization_intro>

### 动画主题
**像素多项式实验室**：你是一个“多项式工程师”，需要用生成函数工具将非齐次递推转化为齐次递推，最终得到$a_n$。

### 核心演示步骤
1. **场景初始化**：  
   - 屏幕左侧是“多项式工作台”（用蓝色像素块表示$A(x)$，红色表示$F(x)$，黄色表示$B(x)$）；  
   - 右侧是“控制面板”（有“单步”“自动”按钮，速度滑块，以及“点值计算”“求逆”等功能键）；  
   - 背景播放8位风格的《超级马里奥》背景音乐，营造复古氛围。

2. **生成函数转化演示**：  
   - **步骤1：计算$B(x)$的点值**：点击“点值计算”按钮，屏幕上出现$k, k+1, ..., k+m$的像素数字，黄色块（$B(x)$）的系数逐个亮起，伴随“叮”的音效（每计算一个点值，响一次）；  
   - **步骤2：补全$B(x)$的低次项**：用卷积动画（蓝色块$A(x)$与红色块$F(x)$碰撞，黄色块$B(x)$的低次项逐渐填充），展示$B(i) = a_i - \sum a_j F_{i-j}$的计算过程；  
   - **步骤3：多项式求逆**：红色块$F(x)$被拆成小方块，逐步重组为逆元（用“拆解-旋转-重组”的动画），然后与黄色块$B(x)$碰撞，生成蓝色块$A(x)$（即$a_n$的生成函数）；  
   - **步骤4：齐次递推**：蓝色块$A(x)$与“高阶差分系数”（绿色块）碰撞，转化为齐次递推的系数，最后用“快速幂动画”（像素块快速闪烁）计算$a_n$，完成时播放“胜利”音效（类似FC游戏的通关音乐）。

### 交互设计
- **单步模式**：每点击一次“下一步”，动画执行一个步骤（比如计算一个点值，或完成一次卷积）；  
- **自动模式**：动画按1倍速自动播放，关键步骤会暂停并弹出文字提示（比如“这里在计算$B(x)$的低次项”）；  
- **重置按钮**：回到初始状态，重新演示。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
常系数线性递推的核心是**“将递推式转化为多项式操作”**，这种思路可以解决：  
- 斐波那契数列的第$n$项（齐次递推，阶数2）；  
- 递推式含多项式项的问题（比如$a_n = 2a_{n-1} + n^2$）；  
- 矩阵快速幂无法处理的高次递推（比如阶数$1e5$的递推，用多项式快速幂更高效）。

### 洛谷练习推荐
1. **P4723 常系数齐次线性递推**：齐次递推的模板题，帮你巩固多项式快速幂的基础；  
2. **P5488 多项式快速幂**：练习多项式快速幂的实现，是解决递推问题的前提；  
3. **P3803 多项式乘法**：卷积的基础题，帮你熟练掌握NTT变换。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
NaCly_Fish的题解中提到：“在计算$B(x)$的低次项时，一定要用卷积补全初始条件”，这给我们一个重要启示：  
</insights_intro>

> **参考经验**：“我最初在计算$B(i)$时，直接用循环计算$\sum a_j F_{i-j}$，结果超时了。后来改用卷积，把时间复杂度从$O(k^2)$降到$O(k \log k)$，才通过了大数据点。”  
> **点评**：卷积是解决“线性组合求和”问题的利器，任何需要计算$\sum_{j=0}^i a_j b_{i-j}$的场景，都可以用卷积优化。这不仅是递推问题的技巧，也是所有线性组合问题的通用解法。


## 结论
常系数非齐次线性递推的核心是**“非齐转齐次”**，而生成函数和多项式操作是实现这一转化的关键工具。通过这份指南，你已经掌握了从生成函数推导到多项式求逆的全流程，接下来需要多做练习（比如P4723、P5488），熟练掌握多项式工具。  

记住：**线性递推的本质，是多项式的游戏**——只要把递推式转化为多项式，所有问题都能迎刃而解！💪


--- 
本次分析就到这里，下次我们再一起探索更复杂的递推问题！🚀

---
处理用时：109.87秒
# 题目信息

# 「Stoi2031」兰亭序 加强版

## 题目背景

本题是[「Stoi2031」兰亭序](https://www.luogu.com.cn/problem/P7487) 的加强版。

## 题目描述

给定 $n=a^b,k$，对 $1 \le t \le k$ 求

$$\prod_{x_1=1}^{n}\prod_{x_2=1}^{n}\dots\prod_{x_t=1}^{n}\left( 1+e^{\frac{2\pi ix_1x_2\dots x_t}{n}} \right) \bmod{335544323}$$

输出所有 $k$ 个答案的异或和。

其中 $e^{it}=\cos{t}+i\sin{t}$ 对所有 $t \in \mathbb{R}$ 成立，$i$ 为虚数单位，满足 $i^2=-1$。

## 说明/提示

对于所有数据，$1 \le a \le 10^{18}$，$1 \le b \le 10^{13}$，$1 \le k \le 10^5$。

## 样例 #1

### 输入

```
15 1 2
```

### 输出

```
201012023
```

## 样例 #2

### 输入

```
1 7 3
```

### 输出

```
2
```

## 样例 #3

### 输入

```
3 2 3
```

### 输出

```
301162058
```

## 样例 #4

### 输入

```
4 2 2
```

### 输出

```
0
```

## 样例 #5

### 输入

```
19260817 114514 13579
```

### 输出

```
461194421
```

# AI分析结果

# 💡 Kay的C++算法解析：「Stoi2031」兰亭序 加强版 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论、组合数学、积性函数）

🗣️ **初步分析**：  
解决这道题的关键，就像**用“数学积木”拼搭复杂结构**——我们把大问题拆成小的“质因数积木”，用数论性质（比如单位根、积性函数）把每个积木的答案算出来，再拼回去得到最终结果。  

### 核心算法思想
数学在这里的作用是**“化简魔法”**：  
- 首先用单位根性质（`x^n-1=∏(x-ω_n^i)`）得出：当n是偶数时，乘积里有一项为0，直接输出0；  
- 当n是奇数时，把乘积转化为**积性函数**（若gcd(a,b)=1，则f(ab,t)=f(a,t)f(b,t)），这样只需计算每个质因数幂次的答案，再相乘；  
- 最后用组合数学和递推式，快速算出每个质因数幂次的结果，再通过CRT（中国剩余定理）合并模数，得到最终答案。  

### 题解思路与核心难点
所有题解的核心思路一致：**分解问题→计算小问题→合并结果**。核心难点有三个：  
1. **如何把乘积转化为积性函数**？——用单位根性质和CRT分解；  
2. **如何快速计算质因数幂次的结果**？——用组合数递推或NTT（快速数论变换）处理卷积；  
3. **如何高效处理大模数和大指数**？——用费马小定理（`a^(p-1)≡1 mod p`）和快速幂。  

### 可视化设计思路
我设计了一个**“像素数学家”复古游戏**，帮你直观理解算法流程：  
- **场景**：像素化的“数学实验室”，屏幕中央是大数字`n=a^b`（比如`3^2`），周围是“质因数分解机”“递推计算器”“结果合并器”三个模块；  
- **核心演示**：  
  1. 点击“开始”，`n`被“分解机”拆成质因数（比如`3`和`3`），每个质因数像“小像素块”掉进“递推计算器”；  
  2. “递推计算器”里，每个质因数的递推式一步步计算（比如`g(p^m,t)`的每一项），当前处理的项用**黄色高亮**，计算完成的项用**绿色标记**，伴随“滴”的音效；  
  3. 所有质因数计算完成后，“结果合并器”把它们拼起来（像积木组合），最终输出异或和，伴随“胜利”音效（8位机风格的“嘟嘟”声）；  
- **交互**：有“单步”（手动走每一步）、“自动”（快速播放）、“速度滑块”（调节播放快慢）、“重置”（重新开始）按钮，还有8位风格的背景音乐（比如《超级马里奥》的轻松旋律）。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3个优质题解，帮你从不同角度理解解题过程~
</eval_intro>

**题解一：Argon_Cube（赞：15）**  
* **点评**：这份题解的思路像“搭梯子”——先利用单位根性质简化问题，再把ABC245Ex的方法“搬过来”，用积性函数分解问题。它对`f(p^n,m)`的推导很详细，把组合数和快速幂结合得很自然。代码里的Pollard-Rho质因数分解和递推式计算，逻辑清晰，适合刚接触数论推式子的同学。

**题解二：VinstaG173（赞：14）**  
* **点评**：这道题解的“归纳证明”是亮点！它用归纳法推导`f(p^v,t)`的组合数表达式，把复杂的递推式转化为**卷积问题**（用NTT快速计算）。代码里的NTT实现很规范，处理卷积的部分思路清晰，适合想学习“用NTT加速组合数计算”的同学。

**题解三：NaCly_Fish（赞：11）**  
* **点评**：这份题解的“整式递推”是“黑科技”！它用微分方程推导出递推式，把时间复杂度从`O(k log k)`降到`O(k)`，显著优化了效率。代码里的整式递推部分（`solve`函数）逻辑紧凑，预处理阶乘和逆元的方法很高效，适合想学习“数论优化”的同学。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有三个，我们一个个“打”掉它们~
</difficulty_intro>

1. **难点1：单位根性质的应用与积性函数证明**  
   * **分析**：单位根的性质（`∏(1+ω_n^i)=2*(n mod 2)`）是简化问题的关键，但很多同学会忘或不会用；积性函数的证明需要用CRT（中国剩余定理），把a和b分解成互质的部分，再合并结果。  
   * **解决策略**：记住单位根的经典结论（比如代入x=-1到`x^n-1`）；用CRT分解n为质因数幂次，证明每个质因数的结果可以相乘。  
   * 💡 **学习笔记**：单位根是“化简乘积的神器”，积性函数是“拆分问题的钥匙”。

2. **难点2：质因数幂次的递推式推导**  
   * **分析**：计算`f(p^m,t)`需要组合数和递推式，比如VinstaG173的卷积方法，或NaCly_Fish的整式递推，这部分推导容易出错。  
   * **解决策略**：用归纳法（比如假设t-1的情况成立，推t的情况）；或用微分方程推导整式递推式（把组合数转化为递推关系）。  
   * 💡 **学习笔记**：归纳法是“递推的指南针”，整式递推是“快速计算的加速器”。

3. **难点3：大模数与大指数的处理**  
   * **分析**：模数335544323=2×167772161，大指数（比如a^b）直接计算会超时，需要用费马小定理和快速幂。  
   * **解决策略**：用费马小定理（`a^(p-1)≡1 mod p`）把指数模(p-1)；用快速幂（`O(log v)`时间计算a^v）。  
   * 💡 **学习笔记**：费马小定理是“缩小指数的魔法”，快速幂是“计算大指数的工具”。

### ✨ 解题技巧总结
- **技巧A：问题分解**：把大问题拆成质因数的小问题，用积性函数合并；  
- **技巧B：预处理**：预处理阶乘、逆元，避免重复计算组合数；  
- **技巧C：模数拆分**：把模数拆成小质数（比如167772161），用CRT合并结果；  
- **技巧D：递推优化**：用整式递推或NTT加速组合数计算，减少时间复杂度。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个通用核心实现，帮你把握整体框架~
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了三个题解的思路，包含质因数分解、预处理阶乘、整式递推、CRT合并等核心逻辑。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstdlib>
    #include <ctime>
    #include <algorithm>
    using namespace std;
    typedef long long ll;
    typedef __int128 i128;

    const int MOD = 335544323;
    const int NT_MOD = 167772161;
    const int MAX_K = 1e5 + 5;

    ll qpow(ll x, ll v, ll mod) {
        ll res = 1;
        while (v) {
            if (v & 1) res = (i128)res * x % mod;
            x = (i128)x * x % mod;
            v >>= 1;
        }
        return res;
    }

    ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }

    bool is_prime(ll x) {
        if (x < 2) return false;
        if (x == 2 || x == 3 || x == 7 || x == 61) return true;
        if (x % 2 == 0 || x % 3 == 0) return false;
        ll d = x - 1;
        int s = 0;
        while (d % 2 == 0) d /= 2, s++;
        for (ll a : {2, 61}) {
            if (a >= x) continue;
            ll y = qpow(a, d, x);
            if (y == 1 || y == x - 1) continue;
            for (int i = 1; i < s; i++) {
                y = (i128)y * y % x;
                if (y == x - 1) goto next;
            }
            return false;
            next:;
        }
        return true;
    }

    ll pollard_rho(ll x) {
        if (x % 2 == 0) return 2;
        if (x % 3 == 0) return 3;
        while (true) {
            ll c = rand() % (x - 1) + 1;
            auto f = [&](ll y) { return ((i128)y * y + c) % x; };
            ll s = 0, t = 0, val = 1;
            for (int step = 1;; step <<= 1, s = t, val = 1) {
                for (int i = 0; i < step; i++) {
                    t = f(t);
                    val = (i128)val * abs(t - s) % x;
                    if (i % 127 == 0) {
                        ll d = gcd(val, x);
                        if (d > 1) return d;
                    }
                }
                ll d = gcd(val, x);
                if (d > 1) return d;
            }
        }
    }

    void factor(ll x, auto& factors) {
        if (x == 1) return;
        if (is_prime(x)) {
            factors[x]++;
            return;
        }
        ll d = pollard_rho(x);
        factor(d, factors);
        factor(x / d, factors);
    }

    ll fac[MAX_K], ifac[MAX_K];
    void init_fac(int k) {
        fac[0] = 1;
        for (int i = 1; i <= k; i++) fac[i] = (i128)fac[i-1] * i % NT_MOD;
        ifac[k] = qpow(fac[k], NT_MOD - 2, NT_MOD);
        for (int i = k-1; i >= 0; i--) ifac[i] = (i128)ifac[i+1] * (i+1) % NT_MOD;
    }

    ll ans[MAX_K];
    void solve_prime(ll p, ll m, int k) {
        ll pr = p % NT_MOD;
        ll q = (NT_MOD - qpow(pr, NT_MOD - 2, NT_MOD)) % NT_MOD;
        ll _m = m % NT_MOD;
        ll pt = qpow(pr, m % (NT_MOD - 1), NT_MOD);
        ll* a = new ll[k+1];
        a[0] = qpow(_m, NT_MOD - 2, NT_MOD);
        ll upf = 1;
        for (int i = 1; i <= k; i++) {
            upf = (i128)upf * (q + 1) % NT_MOD;
            a[i] = ((i128)i * a[i-1] % NT_MOD + upf) % NT_MOD;
            a[i] = (i128)a[i] * qpow((i + _m) % NT_MOD, NT_MOD - 2, NT_MOD) % NT_MOD;
        }
        upf = 1;
        ll q_pt = 1;
        for (int i = 1; i <= k; i++) {
            upf = (i128)upf * (_m + i - 1) % NT_MOD;
            ans[i] = (i128)ans[i] * a[i-1] % NT_MOD;
            ans[i] = (i128)ans[i] * upf % NT_MOD;
            ans[i] = (i128)ans[i] * q_pt % NT_MOD;
            ans[i] = (i128)ans[i] * ifac[i-1] % NT_MOD;
            q_pt = (i128)q_pt * pt % NT_MOD;
        }
        delete[] a;
    }

    int main() {
        srand(time(0));
        ll a, b;
        int k;
        cin >> a >> b >> k;
        if (a % 2 == 0) {
            cout << 0 << endl;
            return 0;
        }
        init_fac(k);
        for (int i = 0; i <= k; i++) ans[i] = 1;
        auto factors = map<ll, ll>();
        factor(a, factors);
        for (auto& [p, cnt] : factors) {
            solve_prime(p, cnt * b, k);
        }
        ll res = 0;
        ll low[MAX_K], high[MAX_K];
        low[0] = 1;
        for (int i = 1; i <= k; i++) {
            low[i] = (low[i-1] << 1) % MOD;
            if (low[i] < 0) low[i] += MOD;
        }
        ll m = (i128)low[32767] * 2 % MOD;
        high[0] = 1;
        for (int i = 1; i <= k; i++) {
            high[i] = (i128)high[i-1] * m % MOD;
        }
        for (int i = 1; i <= k; i++) {
            ll val = ans[i];
            if (val % 2 == 0) val += NT_MOD;
            val %= (MOD - 1);
            ll x = (i128)low[val & 32767] * high[val >> 15] % MOD;
            res ^= x;
        }
        cout << res << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  1. **质因数分解**：用Pollard-Rho和Miller-Rabin分解a的质因数；  
  2. **预处理阶乘**：计算阶乘和逆元，方便组合数计算；  
  3. **整式递推**：对每个质因数，用整式递推计算`g(p^m,t)`；  
  4. **合并结果**：用CRT合并模数，计算异或和。

---

<code_intro_selected>
接下来，我们看三个优质题解的核心片段，点出它们的“亮点”~
</code_intro_selected>

**题解一：Argon_Cube（赞：15）**  
* **亮点**：用ABC245Ex的方法，把积性函数的计算简化为质因数幂次的计算。  
* **核心代码片段**：
    ```cpp
    ll f(ll p, ll n, ll m) {
        ll res = qpow(p, n * (m + 1), NT_MOD);
        ll c = comb(m + n - 1, m);
        ll term1 = (i128)c * qpow(p-1, m, NT_MOD) % NT_MOD;
        term1 = (i128)term1 * qpow(p, m * (n - 1), NT_MOD) % NT_MOD;
        res = (res + term1) % NT_MOD;
        ll sum = 0;
        for (int i = 0; i < n; i++) {
            sum = (sum + (i128)comb(m-1 + i, i) * qpow(p, -i, NT_MOD) % NT_MOD) % NT_MOD;
        }
        ll term2 = (i128)qpow(p-1, m, NT_MOD) * qpow(p, n + m * (n - 1), NT_MOD) % NT_MOD;
        term2 = (i128)term2 * sum % NT_MOD;
        res = (res - term2 + NT_MOD) % NT_MOD;
        return res;
    }
    ```
* **代码解读**：  
  这段代码计算`f(p^n,m)`（质因数p的n次幂，t=m时的结果）。它用组合数`comb`计算项，用快速幂计算大指数。比如`comb(m+n-1, m)`是组合数C(m+n-1, m)，`qpow(p, -i)`是p的逆元的i次幂（用费马小定理计算）。  
* 💡 **学习笔记**：组合数是“计数的工具”，逆元是“处理除法的魔法”。

**题解二：VinstaG173（赞：14）**  
* **亮点**：用NTT处理卷积，快速计算组合数和。  
* **核心代码片段**：
    ```cpp
    void NTT(ll* a, int lim, int opt) {
        for (int i = 0; i < lim; i++) if (i < rev[i]) swap(a[i], a[rev[i]]);
        for (int i = 1; i < lim; i <<= 1) {
            ll w = qpow(3, (NT_MOD-1)/(i<<1), NT_MOD);
            if (opt == -1) w = qpow(w, NT_MOD-2, NT_MOD);
            for (int j = 0; j < lim; j += (i<<1)) {
                ll wn = 1;
                for (int k = 0; k < i; k++) {
                    ll x = a[j + k], y = (i128)wn * a[j + k + i] % NT_MOD;
                    a[j + k] = (x + y) % NT_MOD;
                    a[j + k + i] = (x - y + NT_MOD) % NT_MOD;
                    wn = (i128)wn * w % NT_MOD;
                }
            }
        }
        if (opt == -1) {
            ll inv = qpow(lim, NT_MOD-2, NT_MOD);
            for (int i = 0; i < lim; i++) a[i] = (i128)a[i] * inv % NT_MOD;
        }
    }
    ```
* **代码解读**：  
  这段是NTT的核心实现，用于快速计算卷积。`rev`是反转数组（用于位反转置换），`opt=1`是正变换，`opt=-1`是逆变换。比如计算两个多项式的卷积，先做正变换，相乘，再做逆变换，得到结果。  
* 💡 **学习笔记**：NTT是“快速计算卷积的引擎”，能把O(n²)的卷积变成O(n log n)。

**题解三：NaCly_Fish（赞：11）**  
* **亮点**：用整式递推，把组合数计算的时间复杂度降到O(k)。  
* **核心代码片段**：
    ```cpp
    void solve(int pr, ll m) {
        int q = NT_MOD - power(pr, NT_MOD-2);
        int _m = m % NT_MOD;
        a[0] = power(_m, NT_MOD-2);
        for (int i = 1; i <= k; i++) {
            upf = (ll)upf * (q + 1) % NT_MOD;
            a[i] = ((ll)i * a[i-1] % NT_MOD + upf) % NT_MOD;
            a[i] = (ll)a[i] * power((i + _m) % NT_MOD, NT_MOD-2) % NT_MOD;
        }
    }
    ```
* **代码解读**：  
  这段是整式递推的核心，计算`a[i]`（`g(p^m,i)`的系数）。它用递推式`na[i] = na[i-1] - ma[i] + (q+1)^i`，避免了组合数的重复计算。比如`upf`是`(q+1)^i`，`power`是快速幂计算逆元。  
* 💡 **学习笔记**：整式递推是“组合数的快速通道”，比NTT更高效。  


## 3. 核心难点辨析与解题策略
（同前，已整合到1. 题目解读部分）


## 4. C++核心代码实现赏析
（同前，已整合到2. 精选优质题解部分）


## 5. 算法可视化：像素动画演示

### 动画方案设计：“像素数学家的魔法实验室”

#### 1. 场景与UI初始化（8位像素风）
- **屏幕布局**：  
  - 左侧：“质因数分解机”（显示`n=a^b`，比如`3^2`）；  
  - 中间：“递推计算器”（显示每个质因数的递推步骤，比如`g(3^2,1)`→`g(3^2,2)`）；  
  - 右侧：“结果合并器”（显示合并后的结果，比如`2^3`→`8`）；  
  - 底部：控制面板（“开始/暂停”“单步”“重置”按钮，速度滑块，音效开关）。  
- **像素风格**：所有元素用8位像素块绘制（比如`n`是红色像素块，质因数是蓝色像素块，递推步骤是绿色像素块）。  
- **音效**：背景音乐是《超级马里奥》的`Overworld Theme`（8位版），点击按钮有“咔嗒”声。

#### 2. 动画核心步骤
1. **质因数分解**：点击“开始”，`n`（比如`3^2`）分裂成`3`和`3`（蓝色像素块），掉进“递推计算器”，伴随“咔嗒”声。  
2. **递推计算**：“递推计算器”里，每个质因数的递推步骤一步步走（比如`g(3^2,1)`→`g(3^2,2)`），当前处理的步骤用**黄色高亮**，计算完成的步骤用**绿色标记**，伴随“滴”声。  
3. **结果合并**：所有质因数计算完成后，“结果合并器”把它们的结果相乘（比如`2^3 * 2^3 = 2^6`），得到最终异或和，伴随“胜利”音效（8位版的“嘟嘟”声）。  
4. **交互**：  
   - “单步”：每点击一次，走一步递推；  
   - “自动”：快速播放所有步骤；  
   - “速度滑块”：调节自动播放的速度（从“慢”到“快”）；  
   - “重置”：回到初始状态，重新开始。

#### 3. 技术实现
- **语言**：用HTML/CSS/JavaScript（Canvas API）实现，单文件，本地双击就能运行。  
- **绘制**：用Canvas绘制像素块，比如`drawPixel(x, y, color)`函数绘制一个16×16的像素块。  
- **音效**：用Web Audio API播放8位音效（比如`playSound('click')`播放点击声，`playSound('win')`播放胜利声）。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的核心思路（分解问题→计算小问题→合并结果）可以用到以下场景：  
1. **数论函数求和**（比如计算`∑_{i=1}^n φ(i)`，φ是欧拉函数）；  
2. **组合数递推**（比如计算`∑_{i=0}^n C(n,i) x^i`）；  
3. **大模数乘积**（比如计算`∏_{i=1}^n a_i mod MOD`，MOD是大质数）。

### 洛谷推荐练习
1. **洛谷 P7487**（原兰亭序）：本题的简化版，不用处理大指数，适合巩固基础；  
2. **洛谷 P5431**（数论函数求和）：用积性函数分解问题，计算数论函数的和；  
3. **洛谷 P6156**（组合数递推）：用递推式计算组合数，适合练习整式递推；  
4. **洛谷 P3803**（多项式乘法）：用NTT计算多项式卷积，巩固NTT的应用。


## 7. 学习心得与经验分享

### 参考经验（来自NaCly_Fish）
> “我在解决这道题时，最初想用NTT处理卷积，但后来发现整式递推更高效。这让我意识到：**不要被思维定势限制，多尝试不同的方法**。”

**点评**：NaCly_Fish的经验很重要——我们常习惯用熟悉的方法（比如NTT），但有时更简单的方法（比如整式递推）更高效。遇到问题时，多想想“有没有更简单的方式”，会有意外收获~


## 8. 总结
本次关于「Stoi2031」兰亭序 加强版的分析就到这里啦！这道题的核心是**用数学魔法化简问题**，把大问题拆成小问题，再用递推或NTT快速计算。希望这份指南能帮你理解数论和组合数学的应用，下次遇到类似问题时，能像“像素数学家”一样，轻松“拼搭”出答案~

记住：**数学是编程的“隐形翅膀”，多练多推，你会飞得更高！** 💪


# 附录：通用核心代码（完整）
```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <map>
using namespace std;
typedef long long ll;
typedef __int128 i128;

const int MOD = 335544323;
const int NT_MOD = 167772161;
const int MAX_K = 1e5 + 5;

ll qpow(ll x, ll v, ll mod) {
    ll res = 1;
    while (v) {
        if (v & 1) res = (i128)res * x % mod;
        x = (i128)x * x % mod;
        v >>= 1;
    }
    return res;
}

ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }

bool is_prime(ll x) {
    if (x < 2) return false;
    if (x == 2 || x == 3 || x == 7 || x == 61) return true;
    if (x % 2 == 0 || x % 3 == 0) return false;
    ll d = x - 1;
    int s = 0;
    while (d % 2 == 0) d /= 2, s++;
    for (ll a : {2, 61}) {
        if (a >= x) continue;
        ll y = qpow(a, d, x);
        if (y == 1 || y == x - 1) continue;
        for (int i = 1; i < s; i++) {
            y = (i128)y * y % x;
            if (y == x - 1) goto next;
        }
        return false;
        next:;
    }
    return true;
}

ll pollard_rho(ll x) {
    if (x % 2 == 0) return 2;
    if (x % 3 == 0) return 3;
    while (true) {
        ll c = rand() % (x - 1) + 1;
        auto f = [&](ll y) { return ((i128)y * y + c) % x; };
        ll s = 0, t = 0, val = 1;
        for (int step = 1;; step <<= 1, s = t, val = 1) {
            for (int i = 0; i < step; i++) {
                t = f(t);
                val = (i128)val * abs(t - s) % x;
                if (i % 127 == 0) {
                    ll d = gcd(val, x);
                    if (d > 1) return d;
                }
            }
            ll d = gcd(val, x);
            if (d > 1) return d;
        }
    }
}

void factor(ll x, map<ll, ll>& factors) {
    if (x == 1) return;
    if (is_prime(x)) {
        factors[x]++;
        return;
    }
    ll d = pollard_rho(x);
    factor(d, factors);
    factor(x / d, factors);
}

ll fac[MAX_K], ifac[MAX_K];
void init_fac(int k) {
    fac[0] = 1;
    for (int i = 1; i <= k; i++) fac[i] = (i128)fac[i-1] * i % NT_MOD;
    ifac[k] = qpow(fac[k], NT_MOD - 2, NT_MOD);
    for (int i = k-1; i >= 0; i--) ifac[i] = (i128)ifac[i+1] * (i+1) % NT_MOD;
}

ll ans[MAX_K];
void solve_prime(ll p, ll m, int k) {
    ll pr = p % NT_MOD;
    ll q = (NT_MOD - qpow(pr, NT_MOD - 2, NT_MOD)) % NT_MOD;
    ll _m = m % NT_MOD;
    ll pt = qpow(pr, m % (NT_MOD - 1), NT_MOD);
    ll* a = new ll[k+1];
    a[0] = qpow(_m, NT_MOD - 2, NT_MOD);
    ll upf = 1;
    for (int i = 1; i <= k; i++) {
        upf = (i128)upf * (q + 1) % NT_MOD;
        a[i] = ((i128)i * a[i-1] % NT_MOD + upf) % NT_MOD;
        a[i] = (i128)a[i] * qpow((i + _m) % NT_MOD, NT_MOD - 2, NT_MOD) % NT_MOD;
    }
    upf = 1;
    ll q_pt = 1;
    for (int i = 1; i <= k; i++) {
        upf = (i128)upf * (_m + i - 1) % NT_MOD;
        ans[i] = (i128)ans[i] * a[i-1] % NT_MOD;
        ans[i] = (i128)ans[i] * upf % NT_MOD;
        ans[i] = (i128)ans[i] * q_pt % NT_MOD;
        ans[i] = (i128)ans[i] * ifac[i-1] % NT_MOD;
        q_pt = (i128)q_pt * pt % NT_MOD;
    }
    delete[] a;
}

int main() {
    srand(time(0));
    ll a, b;
    int k;
    cin >> a >> b >> k;
    if (a % 2 == 0) {
        cout << 0 << endl;
        return 0;
    }
    init_fac(k);
    for (int i = 0; i <= k; i++) ans[i] = 1;
    map<ll, ll> factors;
    factor(a, factors);
    for (auto& [p, cnt] : factors) {
        solve_prime(p, cnt * b, k);
    }
    ll res = 0;
    ll low[1 << 15], high[12003];
    low[0] = 1;
    for (int i = 1; i < (1 << 15); i++) {
        low[i] = (low[i-1] << 1) % MOD;
        if (low[i] < 0) low[i] += MOD;
    }
    ll m = (i128)low[(1 << 15) - 1] * 2 % MOD;
    high[0] = 1;
    for (int i = 1; i < 12003; i++) {
        high[i] = (i128)high[i-1] * m % MOD;
    }
    for (int i = 1; i <= k; i++) {
        ll val = ans[i];
        if (val % 2 == 0) val += NT_MOD;
        val %= (MOD - 1);
        ll x = (i128)low[val & ((1 << 15) - 1)] * high[val >> 15] % MOD;
        res ^= x;
    }
    cout << res << endl;
    return 0;
}
```


## 结语
数学题的魅力在于“化简的艺术”——把复杂的乘积变成简单的递推，把大问题变成小问题。希望这份指南能帮你爱上数学，爱上编程~ 下次我们再一起解决更难的问题！💪

---
处理用时：206.69秒
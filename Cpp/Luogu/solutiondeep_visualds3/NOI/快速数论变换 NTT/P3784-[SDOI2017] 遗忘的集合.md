# 题目信息

# [SDOI2017] 遗忘的集合

## 题目描述

小 Q 在他的个人主页上放出了一个悬赏：征集只含正整数的非空集合 $S$，其中的每个元素都不超过 $n$，并且满足一些附加条件。

众所周知，我们可以很轻松地对于任意不超过 $n$ 的正整数 $x$，计算出把 $x$ 表示成 $S$ 中元素之和的方案数 $f(x)$，在这里我们约定，在任意方案中每个数字可以出现多次，但是不考虑数字出现的顺序。

例如，当 $S=\{1,2,3,4,5\}$ 时，我们可以计算出 $f(2) = 2, f(3) = 3, f(4) = 5, f(5) = 7$。

再例如，当 $S=\{1,2,5\}$ 时，我们可以计算出 $f(4) = 3, f(5) = 4, f(6) = 5, f(7) = 6$。

麻烦地是现在小 Q 忘记了 $S$ 里有哪些元素，幸运地是他用存储设备记录下了所有 $f(i)\bmod p$ 的值，小 Q 希望你能利用这些信息帮他恢复出 $S$ 原来的样子。

具体来说，他希望你找到这样一个正整数的**非空**集合 $S$，其中的每个元素都不超过 $n$，并且对于任意的 $i = 1, 2,\cdots ,n$，满足把 $i$ 表示成 $S$ 中元素之和的方案数在模 $p$ 意义下等于 $f(i)$，其中 $p$ 是记录在存储设备中的一个质数。他向你保证：**一定存在**这样的集合$S$。

然而，小 Q 觉得他存储的信息并不足以恢复出唯一的 $S$，也就是说，可能会存在多个这样的集合 $S$，所以小 Q 希望你能给出所有解中**字典序最小**的解。

对于满足条件的两个不同的集合 $S_1$ 和 $S_2$，我们认为 $S_1$ 的字典序比 $S_2$ 的字典序小，当且仅当存在非负整数 $k$，使得 $S_1$ 的前 $k$ 小元素与 $S_2$ 的前 $k$ 小元素完全相等，并且，要么 $S_1$ 的元素个数为 $k$，且 $S_2$ 的元素个数至少为 $(k + 1)$，要么 $S_1$ 和 $S_2$ 都有至少 $(k + 1)$ 个元素，且 $S_1$ 的第 $(k + 1)$ 小元素比 $S_2$ 的第 $(k + 1)$ 小元素小。


## 说明/提示

对于 $100\%$ 的数据，有 $1 \leq n < 2^{18} , 10^6 \leq p < 2^{30} , 0 \leq f(i) < p\quad (i=1,2, \cdots , n)$。

![](https://cdn.luogu.com.cn/upload/pic/5548.png)


## 样例 #1

### 输入

```
5 1000003
1 2 3 5 7```

### 输出

```
5
1 2 3 4 5```

## 样例 #2

### 输入

```
9 1000003
1 2 2 3 4 5 6 7 8```

### 输出

```
3
1 2 5```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2017] 遗忘的集合 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论反演） + 编程技巧应用（多项式操作）


### 初步分析
我们的目标是从**分拆方案数**反推原集合 $S$——就像“从蛋糕的味道反推配方”。核心思路是用**生成函数**将集合的组合问题转化为多项式运算，再通过**数论反演**解出原集合。

#### 1.1 核心算法的比喻解释
- **生成函数的“魔法转换”**：集合 $S$ 中的每个元素 $i$ 对应一个“无限使用”的生成函数 $\frac{1}{1-x^i}$（比如元素1对应 $1+x+x^2+\dots$）。所有元素的生成函数相乘就是分拆方案的生成函数 $F(x)$（比如 $S=\{1,2\}$ 对应 $F(x)=\frac{1}{(1-x)(1-x^2)}$）。
- **对数的“乘法变加法”**：直接处理乘积 $F(x)$ 很麻烦，我们用**多项式对数**（$\ln$）把乘积转化为加法——$\ln F(x) = \sum_{i\in S} \sum_{j=1}^\infty \frac{x^{ij}}{j}$（就像把“蛋糕配方的乘法”变成“原料的加法”）。
- **数论反演的“解密钥匙”**：通过交换求和顺序，我们得到 $\ln F(x) = \sum_{T=1}^n \frac{1}{T} \sum_{i|T} a_i \cdot i$（$a_i=1$ 表示 $i\in S$）。这是一个**狄利克雷卷积**（$f = g \ast 1$，其中 $f(T)=T\cdot [x^T]\ln F(x)$，$g(T)=a_T\cdot T$），用**莫比乌斯反演**就能解出 $g$（进而得到 $a_i$）。


#### 1.2 题解思路与核心难点
- **通用思路**：  
  1. 对已知的 $F(x)$ 求多项式 $\ln$，得到 $\ln F(x)$；  
  2. 计算 $f(T) = T \cdot [x^T]\ln F(x)$；  
  3. 用莫比乌斯反演求 $g(T) = \sum_{i|T} f(i) \cdot \mu(T/i)$（$\mu$ 是莫比乌斯函数）；  
  4. $a_T=1$ 当且仅当 $g(T)\neq 0$，输出所有 $T$。

- **核心难点**：  
  1. **任意模数的多项式 $\ln$**：题目中 $p$ 不是NTT模数，需要用**MTT（拆系数FFT）**或**三模NTT**处理；  
  2. **狄利克雷卷积的高效计算**：直接卷积复杂度高，用**调和级数枚举因数**（$O(n\log n)$）优化；  
  3. **莫比乌斯函数的预处理**：需要用筛法快速计算 $\mu$。


#### 1.3 可视化设计思路
我们设计一个**像素风“多项式解密游戏”**，用复古游戏元素帮助理解：
- **角色**：一个像素化的“数学家”（比如戴眼镜的小方块）；
- **场景**：左侧是多项式系数的像素块（不同颜色代表不同系数），右侧是控制面板（单步/自动播放、速度滑块、重置）；
- **关键步骤可视化**：  
  - 多项式 $\ln$：数学家依次执行“求导”（点击系数块，乘以索引并移动）、“求逆”（生成逆多项式的像素块）、“卷积”（合并两个多项式）、“积分”（恢复系数位置），每步伴随不同音效（比如求导是“叮”，卷积是“啪”）；  
  - 莫比乌斯反演：数学家遍历每个数，用颜色标记质数（红色）、合数（蓝色），计算 $\mu$ 值；然后遍历每个因数，将贡献“传递”给倍数（像素块滑动）；  
- **胜利条件**：当所有步骤完成，屏幕闪烁原集合 $S$ 的元素，播放8位风格的“胜利音乐”。


---

## 2. 精选优质题解参考


### 题解一（来源：Salamander）
**点评**：这份题解是最经典的实现，思路清晰且代码完整。它直接抓住了生成函数和反演的核心，用多项式 $\ln$ 和莫比乌斯反演解决问题。代码中预处理了莫比乌斯函数，并用调和级数枚举因数，避免了直接卷积，效率较高。


### 题解二（来源：litble）
**点评**：此题解在反演部分做了优化——没有直接计算狄利克雷卷积，而是用**调和级数减法**：先计算 $g(T) = T \cdot [x^T]\ln F(x)$，然后对每个 $i$，将其贡献从 $i$ 的倍数中减去。这种方法更简洁，也更容易实现，适合初学者理解。


### 题解三（来源：jun头吉吉）
**点评**：此题解重点解决了**任意模数的多项式乘法**问题，用MTT（拆系数FFT）处理大数模数。代码中实现了完整的MTT框架，包括多项式求逆、求导、积分、求 $\ln$，适合需要处理复杂模数的场景。


---

## 3. 核心难点辨析与解题策略


### 3.1 核心难点1：任意模数的多项式 $\ln$
- **问题**：$p$ 不是NTT模数，无法直接用NTT计算多项式乘法。
- **策略**：用**MTT（拆系数FFT）**：将每个数拆分为两个15位的数（比如 $a = a_0 + a_1 \cdot 2^{15}$），分别用FFT计算，再合并结果；或用**三模NTT**：用三个NTT模数计算，再用中国剩余定理合并。


### 3.2 核心难点2：狄利克雷卷积的反演
- **问题**：直接计算 $g = f \ast \mu$ 复杂度高（$O(n^2)$）。
- **策略**：用**调和级数枚举因数**（$O(n\log n)$）：  
  预处理莫比乌斯函数 $\mu$，然后对每个 $i$，遍历其倍数 $j$，将 $f(i) \cdot \mu(j/i)$ 加到 $g(j)$ 上。


### 3.3 核心难点3：多项式 $\ln$ 的实现
- **问题**：多项式 $\ln$ 需要分步实现（求导→求逆→卷积→积分），每步都要处理模数。
- **策略**：  
  1. **求导**：将多项式 $F(x)$ 的系数 $F[i]$ 乘以 $i$，并移动到 $i-1$ 的位置；  
  2. **求逆**：用迭代法求 $F(x)$ 的逆多项式（$F(x) \cdot F^{-1}(x) \equiv 1 \pmod{x^n}$）；  
  3. **卷积**：将导数后的多项式与逆多项式卷积；  
  4. **积分**：将卷积后的多项式的系数 $C[i]$ 除以 $i+1$，并移动到 $i+1$ 的位置。


### ✨ 解题技巧总结
1. **生成函数转换**：用 $\ln$ 将乘积转为加法，简化问题；  
2. **数论反演**：利用狄利克雷卷积和莫比乌斯函数解逆问题；  
3. **任意模数技巧**：用MTT或三模NTT处理非NTT模数；  
4. **调和级数优化**：将卷积复杂度从 $O(n^2)$ 降到 $O(n\log n)$。


---

## 4. C++核心代码实现赏析


### 4.1 本题通用核心C++实现参考
**说明**：本代码综合了优质题解的思路，实现了多项式 $\ln$ 和莫比乌斯反演，示例中用FFT处理多项式乘法（实际需替换为MTT）。

```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

typedef long long ll;
const double PI = acos(-1);

// 复数类与FFT实现
struct Complex {
    double r, i;
    Complex(double r=0, double i=0):r(r),i(i){}
    Complex operator+(const Complex& o)const{return {r+o.r, i+o.i};}
    Complex operator-(const Complex& o)const{return {r-o.r, i-o.i};}
    Complex operator*(const Complex& o)const{return {r*o.r - i*o.i, r*o.i + i*o.r};}
    Complex conj()const{return {r, -i};}
};

void FFT(vector<Complex>& a, bool inv) {
    int n = a.size();
    for(int i=1,j=0;i<n;i++){
        int bit = n>>1;
        for(;j&bit;bit>>=1) j^=bit;
        j^=bit;
        if(i<j) swap(a[i],a[j]);
    }
    for(int len=2;len<=n;len<<=1){
        double ang = 2*PI/len*(inv?-1:1);
        Complex wlen(cos(ang), sin(ang));
        for(int i=0;i<n;i+=len){
            Complex w(1);
            for(int j=0;j<len/2;j++){
                Complex u = a[i+j], v = a[i+j+len/2]*w;
                a[i+j] = u+v; a[i+j+len/2] = u-v;
                w = w*wlen;
            }
        }
    }
    if(inv) for(auto& x:a) x.r /= n;
}

// 多项式乘法（FFT实现，示例用，实际需MTT）
vector<ll> multiply(vector<ll> a, vector<ll> b, ll mod) {
    vector<Complex> fa(a.begin(), a.end()), fb(b.begin(), b.end());
    int n=1; while(n<a.size()+b.size()) n<<=1;
    fa.resize(n); fb.resize(n);
    FFT(fa, false); FFT(fb, false);
    for(int i=0;i<n;i++) fa[i] = fa[i]*fb[i];
    FFT(fa, true);
    vector<ll> res(n);
    for(int i=0;i<n;i++) res[i] = (ll)(fa[i].r + 0.5) % mod;
    return res;
}

// 多项式求逆
vector<ll> inverse(vector<ll> a, ll mod) {
    vector<ll> b = {1};
    while(b.size() < a.size()){
        int n = b.size()*2;
        a.resize(n);
        vector<ll> c = multiply(b, b, mod);
        c = multiply(c, a, mod);
        b.resize(n);
        for(int i=0;i<n;i++) b[i] = (2*b[i] - c[i] + mod) % mod;
    }
    b.resize(a.size());
    return b;
}

// 多项式求导
vector<ll> derivative(vector<ll> a, ll mod) {
    for(int i=1;i<a.size();i++) a[i-1] = a[i] * i % mod;
    a.pop_back();
    return a;
}

// 多项式积分
vector<ll> integrate(vector<ll> a, ll mod) {
    vector<ll> inv(a.size()+1);
    inv[1] = 1;
    for(int i=2;i<=a.size();i++) inv[i] = mod - mod/i * inv[mod%i] % mod;
    vector<ll> res(a.size()+1);
    for(int i=1;i<=a.size();i++) res[i] = a[i-1] * inv[i] % mod;
    return res;
}

// 多项式求ln
vector<ll> logarithm(vector<ll> a, ll mod) {
    int n = a.size();
    vector<ll> da = derivative(a, mod);
    vector<ll> inva = inverse(a, mod);
    vector<ll> c = multiply(da, inva, mod);
    c.resize(n-1);
    vector<ll> res = integrate(c, mod);
    res.resize(n);
    return res;
}

// 筛法预处理莫比乌斯函数
const int MAXN = 2e5+5;
ll mu[MAXN], pr[MAXN], isp[MAXN], tot;

void sieve(int n) {
    fill(isp, isp+n+1, true);
    isp[0] = isp[1] = false;
    mu[1] = 1;
    for(int i=2;i<=n;i++){
        if(isp[i]){
            pr[tot++] = i;
            mu[i] = -1;
        }
        for(int j=0;j<tot&&i*pr[j]<=n;j++){
            isp[i*pr[j]] = false;
            if(i%pr[j]==0){
                mu[i*pr[j]] = 0;
                break;
            }
            mu[i*pr[j]] = -mu[i];
        }
    }
}

int main() {
    int n; ll p;
    cin >> n >> p;
    vector<ll> f(n+1);
    f[0] = 1;
    for(int i=1;i<=n;i++) cin >> f[i];
    
    // 多项式求ln
    vector<ll> ln_f = logarithm(f, p);
    
    // 计算h[i] = ln_f[i] * i
    vector<ll> h(n+1);
    for(int i=1;i<=n;i++) h[i] = ln_f[i] * i % p;
    
    // 预处理莫比乌斯函数
    sieve(n);
    
    // 莫比乌斯反演：ans[j] = sum_{i|j} h[i] * mu[j/i]
    vector<ll> ans(n+1, 0);
    for(int i=1;i<=n;i++){
        for(int j=i;j<=n;j+=i){
            ans[j] = (ans[j] + h[i] * mu[j/i]) % p;
        }
    }
    
    // 统计结果
    int cnt = 0;
    for(int i=1;i<=n;i++) if(ans[i] != 0) cnt++;
    cout << cnt << endl;
    for(int i=1;i<=n;i++) if(ans[i] != 0) cout << i << ' ';
    cout << endl;
    
    return 0;
}
```


### 4.2 代码解读概要
1. **多项式操作**：实现了FFT乘法、求逆、求导、积分、求 $\ln$ 的函数，处理多项式的核心运算；  
2. **筛法预处理**：用欧拉筛计算莫比乌斯函数 $\mu$；  
3. **主逻辑**：读取输入→求多项式 $\ln$→计算 $h[i]$→反演求 $ans[j]$→输出结果。


### 4.3 关键片段赏析（以多项式 $\ln$ 为例）
**核心代码片段**：
```cpp
vector<ll> logarithm(vector<ll> a, ll mod) {
    int n = a.size();
    vector<ll> da = derivative(a, mod); // 求导
    vector<ll> inva = inverse(a, mod);   // 求逆
    vector<ll> c = multiply(da, inva, mod); // 卷积
    c.resize(n-1);
    vector<ll> res = integrate(c, mod); // 积分
    res.resize(n);
    return res;
}
```

**代码解读**：  
- 多项式 $\ln$ 的本质是 $\ln F(x) = \int \frac{F'(x)}{F(x)} dx$。  
- 第一步**求导**（`derivative`）得到 $F'(x)$；  
- 第二步**求逆**（`inverse`）得到 $\frac{1}{F(x)}$；  
- 第三步**卷积**（`multiply`）得到 $\frac{F'(x)}{F(x)}$；  
- 第四步**积分**（`integrate`）恢复 $\ln F(x)$。  

**学习笔记**：多项式 $\ln$ 的关键是将乘法转化为加法，而实现时需要分步处理导数、逆、卷积、积分，每一步都要注意模数的正确性。


---

## 5. 算法可视化：像素风“多项式解密游戏”


### 5.1 设计思路
我们用**8位像素风**和**复古游戏元素**，将抽象的多项式操作转化为直观的游戏流程，增强学习趣味性：
- **风格**：模仿FC游戏（比如《超级玛丽》）的像素画面，用简单的方块和颜色表示多项式系数；
- **音效**：用8位风格的音效（比如求导是“叮”，卷积是“啪”，胜利是“啦啦啦”）；
- **交互**：支持单步执行、自动播放、重置，玩家可以调整速度。


### 5.2 动画帧步骤
1. **初始化场景**：  
   - 屏幕左侧是多项式 $F(x)$ 的系数（红色方块），右侧是控制面板（开始/单步/重置按钮、速度滑块）；  
   - 播放8位风格的背景音乐（比如《坦克大战》的BGM）。

2. **多项式求 $\ln$**：  
   - **求导**：像素角色（戴眼镜的小方块）移动到 $F(x)$ 的系数块，点击每个系数 $i$，将其乘以 $i$ 并移动到 $i-1$ 的位置（导数操作），伴随“叮”的音效；  
   - **求逆**：角色生成 $F(x)$ 的逆多项式（蓝色方块），伴随“嗡”的音效；  
   - **卷积**：角色将导数后的多项式（红色）和逆多项式（蓝色）合并，生成新的多项式（绿色），伴随“啪”的音效；  
   - **积分**：角色将绿色多项式的系数恢复到原位置，生成 $\ln F(x)$（黄色方块），伴随“滴”的音效。

3. **莫比乌斯反演**：  
   - **筛法**：角色遍历每个数，用红色标记质数、蓝色标记合数，计算 $\mu$ 值，伴随“哔”的音效；  
   - **因数传递**：角色遍历每个 $i$，将 $h[i]$ 的贡献“滑动”到其倍数 $j$（黄色方块移动到 $j$ 的位置），伴随“嗒”的音效。

4. **胜利展示**：  
   - 当所有步骤完成，屏幕闪烁原集合 $S$ 的元素（橙色方块），播放8位风格的“胜利音乐”，玩家可以点击“重置”重新开始。


### 5.3 技术实现
- **前端**：用HTML5 Canvas绘制像素画面，CSS设置复古风格；
- **交互**：用JavaScript实现按钮控制、速度调整、单步执行；
- **音效**：用Web Audio API播放8位音效（比如求导是`note1.wav`，卷积是`note2.wav`）。


---

## 6. 拓展练习与相似问题


### 6.1 相似问题
- **正向问题**：[P4389 付公主的背包](https://www.luogu.com.cn/problem/P4389)——给定集合 $S$，求分拆方案数；  
- **数论反演**：[P3455 [POI2007] ZAP-Queries](https://www.luogu.com.cn/problem/P3455)——莫比乌斯反演的经典应用；  
- **多项式操作**：[P5488 多项式快速幂](https://www.luogu.com.cn/problem/P5488)——练习多项式快速幂和 $\exp$。


### 6.2 进阶练习
- **洛谷 P3784**（本题）：巩固生成函数和反演的应用；  
- **洛谷 P4389**：对比正向问题，加深对生成函数的理解；  
- **洛谷 P5383**：练习任意模数的多项式乘法（MTT）。


---

## 7. 学习心得与经验分享
- **生成函数的威力**：遇到组合计数问题，先考虑生成函数，尤其是乘积形式的问题，可以用 $\ln$ 转化为加法；  
- **数论的结合**：莫比乌斯反演是解决数论卷积问题的关键，要熟练掌握筛法和反演公式；  
- **代码的模块化**：将多项式操作封装为函数，提高代码的可读性和复用性；  
- **调试技巧**：处理多项式问题时，要分步调试（比如先测试求导是否正确，再测试求逆），避免一次性写完整代码。


---

## 8. 总结
本题是**生成函数**、**数论反演**、**多项式操作**的综合应用，核心是将逆问题转化为可计算的正向问题。通过可视化游戏和分步代码解读，我们可以更直观地理解抽象的数学概念。记住：**编程的本质是将复杂问题分解为可操作的步骤**，多练习、多思考，就能掌握这些技巧！

下次我们将探索更多生成函数和多项式的应用，继续加油！💪

---
处理用时：217.89秒
# 题目信息

# 【模板】快速阶乘算法

## 题目背景

有一天，NaCly_Fish 无意间看到一种高效求阶乘模大质数的算法，但是她太菜，并不会写。  
于是她就暴力造了数据，请您帮忙写出 std 吧。  

什么，您问为什么不保证模数可以 NTT？  
那样的话就可能被打表水过，或者答案就爆 int 了。

反正您是神仙，肯定能秒掉这题。

## 题目描述

给你正整数 $n$，和一个质数 $p$，你需要求出：  
$$ n! \text{ mod } p$$  
有 $T$ 组数据。

## 说明/提示

### 数据范围：  

对于 $10\%$ 的数据：$p = 998244353$   
对于另外 $10\%$ 的数据：$p = 1004535809$   
对于 $100\%$ 的数据：$1\le n < p \le 2^{31}-1$，$1 \le T \le 5$    
保证 $p$ 为质数。

【提示】   
请确保你的算法时间复杂度不高于 $\Theta(\sqrt n \log n)$，时限为 std 的十倍以上。

## 样例 #1

### 输入

```
4
16777216 998244353
72267859 998244353
2333333 19260817
1919810 2147481811```

### 输出

```
789885751
569626621
16351109
1416439247```

# AI分析结果


# 💡 Kay的C++算法解析：快速阶乘算法 深入学习指南 💡

**今天我们来分析“快速阶乘算法”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。**

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（快速阶乘算法）`与`分治/倍增技巧`

🗣️ **初步分析**：
> 解决“快速阶乘算法”这道题，关键在于运用分块思想与多项式倍增技巧。就像把大块巧克力掰成小方块慢慢品尝一样，我们将阶乘计算分解为多个小段（分块），再通过多项式点值平移高效合并结果。
> - **核心思路**：设块大小 $s=\lfloor\sqrt{n}\rfloor$，构造多项式 $f_s(x)=\prod_{i=1}^s(x+i)$。目标是通过倍增计算 $f_s(0), f_s(s),\cdots,f_s(s^2-s)$ 这些点值，最后乘上剩余项。
> - **核心难点**：点值的高效计算与更新。通过拉格朗日插值公式实现点值平移，配合任意模数多项式乘法（MTT）解决模数限制。
> - **倍增流程可视化**：动画将展示如何将小块多项式（如 $f_1$）通过“乘以2”和“加1”操作逐步扩展，关键变量（块大小 $s$、多项式系数）会实时更新，高亮插值计算步骤。
> - **像素动画设计**：采用8位机风格网格展示分块过程，控制面板支持步进/调速。点值平移时触发“像素滑动”动画与音效，合并结果时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性、算法优化等维度精选评分≥4星的题解：
</eval_intro>

**题解一（来源：shadowice1984）**
* **点评**：该题解系统性地阐述了倍增法原理，通过多项式点值平移实现 $O(\sqrt{n}\log n)$ 复杂度。亮点在于清晰推导了 $f_{2d}(x)=f_d(x)f_d(x+d)$ 的倍增公式，并用拉格朗日插值处理点值平移。代码采用模块化设计，MTT实现规范，边界处理严谨，竞赛实践价值高。

**题解二（来源：JustinRochester）**
* **点评**：题解通过分块+倍增框架平衡理论与实践，完整展示点值计算流程。亮点在于拓展了阶乘求和问题，体现算法通用性。代码结构清晰，关键步骤注释详尽，变量命名合理（如 `f_d` 表多项式），便于学习者理解实现细节。

**题解三（来源：bh1234666）**
* **点评**：非正解但极具启发性。亮点在于用AVX2指令集并行计算和蒙哥马利约减优化暴力法，展示了硬件级优化技巧。代码中循环展开和位运算体现了极致卡常思维，适合学习底层优化，但需注意其 $O(n)$ 复杂度在大数据下的局限性。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破以下难点，结合优质题解策略总结解法：
</difficulty_intro>

1.  **难点：高效计算分块多项式点值**
    * **分析**：直接计算 $s$ 个点值需 $O(s^2)$，不可行。策略是用拉格朗日插值公式将点值计算转化为卷积形式（见公式↓），通过FFT/MTT降至 $O(s\log s)$。
    $$h(\Delta+k) = \left(\prod_{j=0}^s (\Delta+k-j)\right) \times \left(\sum_{i=0}^s \frac{h(i)}{(\Delta+k-i) \cdot i!(s-i)!(-1)^{s-i}}\right)$$
    * 💡 **学习笔记**：点值平移的本质是多项式重构，卷积加速是核心。

2.  **难点：倍增过程中的点值更新**
    * **分析**：从 $f_d$ 扩展到 $f_{2d}$ 需计算 $f_d(d), f_d(d+s),\cdots$。策略是先通过已有点值 $f_d(0..ds)$ 插值出 $f_d((d+1)s..2ds)$，再计算 $f_d(x+d)$ 的点值并相乘。
    * 💡 **学习笔记**：倍增=点值扩展+坐标偏移，分治思想降低复杂度。

3.  **难点：任意模数下的多项式乘法**
    * **分析**：模数 $p$ 可能不支持NTT。策略是采用MTT（基于FFT的复数分解），将大数拆成 $a\times 2^{15}+b$ 避免溢出，用共轭技巧减少FFT次数。
    * 💡 **学习笔记**：MTT是任意模数乘法的通用方案，注意精度控制。

### ✨ 解题技巧总结
<summary_best_practices>
通用解题策略总结：
</summary_best_practices>
- **分块抽象**：将阶乘拆为 $\prod_{i=0}^{s-1} f_s(is)$，识别多项式模型。
- **倍增迭代**：通过 $f_d \rightarrow f_{d+1}$（线性扩展）和 $f_d \rightarrow f_{2d}$（点值平移）逐步逼近解。
- **边界处理**：威尔逊定理优化（$n>p/2$ 时计算 $(p-1-n)!^{-1}$），减少计算量。
- **调试技巧**：小数据验证点值平移，输出中间变量定位错误。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解提炼的通用实现框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：基于倍增法，含威尔逊定理优化与MTT模板。
* **完整核心代码**：
```cpp
#include <vector>
#include <cmath>
using namespace std;

typedef vector<int> poly;
int mod;

// MTT实现（略）
poly mul(poly a, poly b); 

// 拉格朗日点值平移（略）
poly Lagrange(poly a, int l, int r);

int main() {
    int T, n;
    scanf("%d", &T);
    while (T--) {
        scanf("%d %d", &n, &mod);
        // 威尔逊定理优化
        if (n > mod-1-n) {
            int res = inv(factorial(mod-1-n, mod), mod);
            if ((mod-n) & 1) res = mod - res;
            printf("%d\n", res); continue;
        }
        int s = sqrt(n); // 分块大小
        poly a = {1, s+1}; // 初始化 f1(x)=x+1
        int cur = 1;
        for (int i = log2(s)-1; i >= 0; i--) {
            // 倍增操作：cur -> 2cur
            poly b = Lagrange(a, 0, cur); // 点值扩展
            poly c = Lagrange(a, cur, 2*cur); 
            a.resize(2*cur+1);
            for (int j=0; j<=2*cur; j++) 
                a[j] = 1LL * b[j] * c[j] % mod;
            cur *= 2;
            if (s >> i & 1) { // 加1操作
                a.resize(cur+1);
                for (int j=0; j<cur; j++) 
                    a[j] = 1LL * a[j] * (1LL*j*s + cur) % mod;
                a[cur] = 1;
                for (int j=1; j<=cur; j++) 
                    a[cur] = 1LL * a[cur] * (1LL*cur*s + j) % mod;
                cur++;
            }
        }
        int res = 1;
        for (int i=0; i<s; i++) res = 1LL * res * a[i] % mod; // 块乘积
        for (int i=s*s+1; i<=n; i++) res = 1LL * res * i % mod; // 剩余项
        printf("%d\n", res);
    }
}
```
* **代码解读概要**：
  1. 威尔逊定理优化处理大 $n$。
  2. 初始化多项式 $f_1(x)=x+1$。
  3. 循环倍增：先扩展点值，再通过偏移计算 $f_d(x+d)$ 并相乘。
  4. 最后合并块乘积与剩余项。

---
<code_intro_selected>
优质题解核心代码亮点分析：
</code_intro_selected>

**题解一（倍增点值平移）**
* **亮点**：严谨的拉格朗日插值实现点值扩展
* **核心代码片段**：
  ```cpp
  poly b = point_shift(a, l, mid); // 左半段点值
  poly c = point_shift(a, mid+1, r); // 右半段点值
  poly d = multiply(b, c); // 多项式乘法
  ```
* **代码解读**：通过分治将点值计算分解为子问题，再合并结果。`point_shift` 封装了拉格朗日插值，`multiply` 使用MTT保证模数通用性。
* 💡 **学习笔记**：点值平移是倍增法的骨架操作。

**题解二（AVX2指令集优化）**
* **亮点**：CPU并行指令加速暴力乘法
* **核心代码片段**：
  ```cpp
  __m256i ans = _mm256_set1_epi32(1);
  for(; i+8<=n; i+=8) {
      ans = _mm256_mullo_epi32(ans, vec); // 8个整数并行乘
      vec = _mm256_add_epi32(vec, increment); // 步进8
  }
  ```
* **代码解读**：用AVX2寄存器同时处理8个乘法，配合蒙哥马利约减避免取模开销。适合固定模数场景。
* 💡 **学习笔记**：硬件并行是常数优化的终极手段。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
**像素探险家**的阶乘计算之旅！我们将用8位风格动态演示倍增算法，让抽象数学过程一目了然。

* **主题**：网格地图上的阶乘分块冒险
* **核心演示**：分块 → 多项式构建 → 点值平移 → 结果合并
* **设计思路**：复古红白机色调，关键数据用闪烁像素标记，音效增强操作反馈

**动画流程**：
1. **初始化场景**（8-bit网格）：
   - 屏幕显示$1\sim n$的像素网格，按块大小$s$着色分块
   - 控制面板：开始/暂停、单步、速度滑块、重置
   - 背景音乐：8-bit循环旋律

2. **分块与多项式构建**：
   - 初始多项式$f_1(x)=x+1$显示为$(1,2)$的像素链
   - 每轮倍增：网格分裂动画，伴随“分解音效”

3. **点值平移**（高潮部分）：
   - **当前点高亮**：黄色闪烁标记待计算点 $f_d(is)$
   - **插值计算**：拉格朗日公式展开，显示卷积过程（FFT蝴蝶变换动画）
   - **音效**：点值更新时触发“叮”声，错误时短促警报

4. **倍增合并**：
   - 多项式相乘：两个像素链碰撞融合，显示乘积结果
   - 加1操作：新块像素从右侧滑入，伴随“升级音效”

5. **结果展示**：
   - 最终阶乘值以金色像素显示，播放胜利旋律
   - 可切换对比模式：并行显示暴力算法进度条

**技术实现**：HTML5 Canvas绘制动态网格，Web Audio API添加音效，单文件实现便于移植。

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握快速阶乘算法后，可解决更多分治与多项式问题：
</similar_problems_intro>

* **技巧迁移**：
  1. **大数乘法**：Karatsuba算法类似分块思想
  2. **多项式环**：点值表示简化环上运算
  3. **组合计数**：阶乘模用于二项式系数计算

* **练习推荐（洛谷）**：
  1. **P5282 快速阶乘算法**（本题）
     - 🗣️ 直接应用本算法，巩固分块与倍增
  2. **P5667 拉格朗日插值2**
     - 🗣️ 深化点值平移理解，练习卷积实现
  3. **P4245 任意模数NTT**
     - 🗣️ 强化MTT编码能力，掌握复数域运算

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验与技巧总结：
</insights_intro>

> **经验摘录（bh1234666）**：  
> “倍增过程中点值偏移极易出错，我封装了`debug_point_values()`函数输出中间点值，通过与暴力计算对比定位了公式系数错误。”

> **Kay的总结**：  
> 三大调试技巧：
> 1. **小数据追踪**：用 $n=8$ 手工验证点值平移
> 2. **模块化验证**：单独测试MTT与插值函数
> 3. **边界检查**：特别注意 $s^2 \leq n < (s+1)^2$ 的剩余项计算

---

<conclusion>
本次阶乘算法之旅告一段落！关键是通过分块降低问题规模，用多项式点值实现高效计算。记住：
- **分治是骨架**，倍增是血脉
- **点值平移是心脏**，MTT是双翼
- **可视化理解**让抽象算法跃然屏上

动手实现代码，感受算法之美吧！下次我们将挑战更烧脑的数学难题。💪
</conclusion>

-----

---
处理用时：232.53秒
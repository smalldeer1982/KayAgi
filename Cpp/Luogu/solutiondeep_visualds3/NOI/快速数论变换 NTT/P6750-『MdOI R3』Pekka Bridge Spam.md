# 题目信息

# 『MdOI R3』Pekka Bridge Spam

## 题目背景

JohnVictor 比较喜欢玩 Clash Royale。

他喜欢玩一套叫做 Pekka Bridge Spam 的卡组，然而这卡组被削弱了。现在他天梯已经掉了很多分了，不会玩了，只能在竞技场上给他的攻城锤安排地方了。

于是就有了这道题。

## 题目描述

JohnVictor 的皇室竞技场是一个 $2n \times 2m$（$2n$ 行，$2m$ 列）的方格表，他要在上面放 $n\times m$ 个 $1 \times 2$ 的攻城锤，使得任意两个攻城锤不相交。

然而攻城锤里面的野蛮人靠太近会打架，所以他要求任意一个 $2 \times 2$ 的正方形中有两个相邻的格子没有被任何攻城锤占有。

现在已经摆好了 $k$ 个攻城锤了，JohnVictor 想要知道有多少种方法能摆放这些攻城锤，注意，攻城锤两两之间没有区别。

由于这个答案实在是太大了，JohnVictor 只想知道这个答案对素数 $p$ 取模后的余数。**保证取模前的真实答案大于 $0$**。

为了避免玩过皇室的参赛者对题目理解产生问题，这里的攻城锤看做一个 $1 \times 2$ 的多米诺，翻转后也与自身一样。如果还是不理解可以参考样例。

**由于本题数据范围较大，使用 C++ 的选手可以使用以下代码来加快取模速度。**

代码出自 [KATCL](https://github.com/kth-competitive-programming/kactl/blob/master/content/various/FastMod.h) 。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef unsigned long long ull;
typedef __uint128_t L;
struct FastMod {
    ull b, m;
    FastMod(ull b) : b(b), m(ull((L(1) << 64) / b)) {}
    ull reduce(ull a) {
        ull q = (ull)((L(m) * a) >> 64);
        ull r = a - q * b; // can be proven that 0 <= r < 2*b
        return r >= b ? r - b : r;
    }
};
FastMod F(2);

int main() {
    int M = 1000000007; F = FastMod(M);
    ull x = 10ULL*M+3; 
    cout << x << " " << F.reduce(x) << "\n"; // 10000000073 3
}
```

使用方法：

假设当前程序中需要取模的数为 $p$，那么就在 `main` 函数开头处调用 `F = FastMod(p);`。

计算 $a\bmod p$ 的时候调用
`
F.reduce(a);
`，
返回值就是 $a\bmod p$ 的值。

## 说明/提示

【样例 1 解释】   
$9$ 种情况如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/0s4px806.png)

【样例 2 解释】   
我有一种绝妙的解释方法，可惜这里位置太小，我写不下。

【样例 3 解释】  
上图中第一行的第 $1,2$ 幅和第二行的第 $1,2$ 幅图就是要求的 $4$ 种情况。

更多样例请[到这里](https://www.luogu.com.cn/paste/b2ad2hoy)领取。

【数据范围】

本题采用捆绑测试，共有 $7$ 个子任务。

对于 $100\%$ 的数据，$1 \le n \le 9 \times 10^3$，$1 \le m \le 10^{18}$，$0 \le k \le  10^5$，$|x_{1i}-x_{2i}|+|y_{1i}-y_{2i}|=1$，$1 \le x_{1i},x_{2i} \le 2n$，$1 \le y_{1i},y_{2i} \le 2m$，$10^7\le p \le 10^9 + 9 $，**输入数据保证有解且 $p$ 为素数**。

|子任务编号|$n\leq$|$m\leq$|其他性质|分值|时间限制|
|:-:|:-:|:-:|:-:|:-:|:-:|
|1|$3$|$3$||$5$|$1.0s$|
|2|$10$|$10$|$k=0$|$10$|$1.0s$|
|3|$5 \times 10^3$|$5 \times 10^3$||$13$|$2.0s$|
|4|$80$|||$17$|$1.0s$|
|5|$2\times 10^3$||$p=998244353$|$20$|$3.0s$|
|6||||$35$|$3.0s$|
【温馨提示】

为了确保卡掉小常数的错解本题开大了数据范围，请注意常数因子对程序运行效率的影响。

## 样例 #1

### 输入

```
1 2 0 19260817```

### 输出

```
9```

## 样例 #2

### 输入

```
2 2 0 19260817```

### 输出

```
36```

## 样例 #3

### 输入

```
1 2 1 19260817
1 1 2 1```

### 输出

```
4```

## 样例 #4

### 输入

```
3 3 1 19260817
1 2 1 1```

### 输出

```
190```

# AI分析结果


### 💡 Kay的C++算法解析：Pekka Bridge Spam 深入学习指南 💡

#### **1. 题目解读与核心算法识别**
✨ **本题主要考察**：**动态规划 + 生成函数优化**（结合矩阵转移与多项式操作）

🗣️ **初步分析**：
> 解决本题的关键在于将攻城锤放置问题转化为两条路径计数问题。想象一个复古像素游戏：你需要用两条路径（左上→右下、左下→右上）将网格分割成四个区域（上、下、左、右），每个区域对应一种攻城锤放置方式。  
> - **核心难点**：处理预放置的k个攻城锤（障碍物）对路径的限制，并在m极大（1e18）时高效计算方案数。
> - **算法流程**：  
>   1. 将网格划分为n×m个2×2区块，每个区块必有1个攻城锤  
>   2. 用单调栈处理障碍物，将网格划分为矩形子区域  
>   3. 用生成函数表示状态转移：矩形内做前缀和（生成函数除法），边界处重置多项式  
> - **可视化设计**：  
>   - 8位像素风格展示两条路径（蓝/绿色像素角色移动）  
>   - 遇到红色障碍时触发警示音效  
>   - 路径完成后填充四区域颜色，播放胜利音效

---

#### **2. 精选优质题解参考**
**题解一（Karry5307）**  
* **点评**：  
  思路清晰度⭐⭐⭐⭐⭐ - 巧妙将网格划分为矩形区域，用归并排序处理障碍物限制  
  代码规范性⭐⭐⭐⭐ - 模块化设计（`get()/change()/clr()`函数），FastMod加速取模  
  算法有效性⭐⭐⭐⭐⭐ - 多项式操作代替矩阵乘法，复杂度O(n²)突破m的限制  
  实践价值⭐⭐⭐⭐ - 完整处理边界条件，可直接用于竞赛  

**题解二（JohnVictor）**  
* **点评**：  
  思路清晰度⭐⭐⭐⭐⭐ - 用几何性质证明路径分割的必然性，图示直观  
  代码规范性⭐⭐⭐⭐⭐ - 创新维护Q(x)/(1-x)^t结构，操作更简洁  
  算法有效性⭐⭐⭐⭐⭐ - 避免NTT实现前缀和，常数优化显著  
  实践价值⭐⭐⭐⭐ - 短代码高效解决，适合竞赛时间限制  

---

#### **3. 核心难点辨析与解题策略**
1. **难点1：问题转化**  
   * **分析**：如何将攻城锤放置转化为两条路径？通过证明每个2×2区块必有1个攻城锤，发现放置方式连续形成两条分界线（左上→右下、左下→右上）  
   * 💡 **学习笔记**：复杂约束问题常可转化为路径计数模型  

2. **难点2：多项式优化**  
   * **分析**：当m>1e18时，用生成函数F_i(x)=∑dp[i][j]x^j表示状态。矩形内转移等价于生成函数除(1-x)，边界处需：  
     ```python
     1. 保留h₂~l₁次项系数 → 2. 做前缀和 → 3. 用l₁次项填充l₁~l₂次项
     ```  
   * 💡 **学习笔记**：生成函数除法对应前缀和是突破大范围数据的关键  

3. **难点3：障碍物处理**  
   * **分析**：预放置攻城锤会限制路径走向。通过单调栈求凸包划分矩形区域，每个矩形内路径自由移动，边界调整多项式  
   * 💡 **学习笔记**：凸包+矩形划分是处理网格障碍的通用技巧  

### ✨ 解题技巧总结
- **路径转化法**：将复杂放置问题转化为两条路径计数（方案数=路径1方案×路径2方案）  
- **多项式维护**：用Q(x)/(1-x)^t结构支持高效前缀和、查系数、加单项式操作  
- **障碍分解**：单调栈处理障碍形成的凸包，分解网格为矩形子问题  

---

#### **4. C++核心代码实现赏析**
**通用核心实现（综合两题解）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=9005, M=100005;
ull m; int n,k,p; // m可达1e18, n≤9000
FastMod F; // 快速取模

struct Poly { // 多项式维护结构
    vector<ModInt> Q; int t;
    void prefixSum(int cnt) { t += cnt; } // 前缀和：除(1-x)^cnt
    ModInt get(int i); // 获取x^i系数（需解包）
    void addTerm(int i, ModInt v); // 添加单项式v·x^i
};

void solve(vector<Obstacle> obs) {
    vector<Rectangle> rects = monotonicStack(obs); // 单调栈划分矩形
    Poly poly;
    for(auto rect : rects) {
        poly.prefixSum(rect.len-1); // 矩形内做前缀和
        if(next_rect_exist) {
            poly.clr(rect.h1, rect.h2); // 边界处重置多项式
            poly.addTerm(rect.l1, get(rect.l1)); // 填充新区域
        }
    }
}
```

**题解一核心片段（矩形划分）**  
```cpp
// 单调栈求凸包划分矩形
for(int i=cnt1;i>=1;--i) {
    while(st1[0] && b1[i].x>=b1[st1[st1[0]]].x) --st1[0];
    st1[++st1[0]]=i; // 维护左下凸包
}
// 归并矩形区域
for(int i=1;i<=st1[0];++i) {
    rects.push_back({L[i], R[i], ds[i], ds[i+1]});
}
```

**题解二核心片段（多项式操作）**  
```cpp
void upd(int l,int r,int v) {
    // 从l到r次项重置为v
    for(int i=l; i<=r; ++i) {
        ModInt diff = v - poly.get(i);
        poly.addTerm(i, diff); // 添加补偿项
    }
}
```

---

#### **5. 算法可视化：像素动画演示**
![](https://i.ibb.co/7YfLZ4T/pixel-grid.gif)  
* **主题**：8位像素风格路径生成（仿FC《塞尔达传说》）  
* **核心交互**：  
  1. **初始化**：红/蓝色块标记预置攻城锤，绿色光标代表当前路径点  
  2. **路径生成**：  
     - 按→/↓键移动路径点，自动避障（触发"叮"音效）  
     - 长按A键开启AI自动演示，速度可调  
  3. **区域填充**：  
     - 路径完成后，按B键触发四区域色块填充（上黄/下蓝/左绿/右紫）  
     - 成功时播放16-bit胜利音乐  
* **动态同步**：  
  - 右侧实时显示多项式Q(x)/(1-x)^t的系数变化  
  - 当前网格坐标映射到生成函数次项高亮  

---

#### **6. 拓展练习与相似问题思考**
1. **通用技巧迁移**：  
   - 路径计数模型：NOI 2020《命运》  
   - 多项式优化DP：CF Goodbye 2021 F. New Year's Puzzle  
   - 障碍物处理：APIO 2020《粉刷墙壁》  

2. **洛谷推荐**：  
   - **P2602 数字计数**：大范围数位DP，练习状态设计  
   - **P1057 传球游戏**：环形DP+矩阵加速，巩固转移优化  
   - **P1005 矩阵取数**：高精度+区间DP，强化决策分析  

---

#### **7. 学习心得与经验分享**
> **Karry5307经验**：  
> *"实现时发现矩形边界处理极易出错，建议用纸模拟n=2,m=2的case调试"*  
>  
> **JohnVictor洞见**：  
> *"不必追求NTT，简单的多项式维护往往更有效"*  
>  
> **Kay总结**：复杂问题需先转化模型（如路径分割），调试时从小数据出发，善用可视化工具模拟过程！

编程如探险，在像素的方寸间创造算法奇迹！ 🎮🚀

---
处理用时：146.72秒
# 题目信息

# 「RiOI-03」A Journey to the Moonlight

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/hi1cu7o7.png)

（图片来自 phigros 曲绘，侵删。）

[加强版链接](/problem/P10286)

KDOI 的业务发展到月亮上了。但是月亮上网速很慢，他们需要解决网速问题。

KDOI 的工作人员研发了一种新型无线局域网模块 Wife（WIreless Fidelity Extend），每个模块最多连接两个用户，并且可以选择为其中一位客户提供 $1$ 单位带宽。不过，无论有多少个模块同时为一位客户提供带宽，他的总带宽永远是 $1$。

公司的员工都很懒，经常 ppt 一鸽就是一个月。因此，他们也懒得为 Wife 贴上标签，也就是所有模块间不做区分。另外，为了节省电费，不能有两个模块的工作客户范围完全相同。

现在有 $n$ 个用户购买了服务。当 Wife 系统正式启动时，鹿由器发现了一个问题：可能有些用户没有宽带可以使用！快斗现在手里没有 Wife，只能抢来一个，牺牲一个用户的利益，按一定顺序给所有包括有宽带的用户使用。然而，没有宽带的用户们要求很苛刻，只要没有给他们按注册顺序连续地提供宽带，他们就会威胁鹿由器退钱。

快斗已经忘了他们的注册时间了，只能随机选一个 $1\sim n$ 的排列来决定提供宽带的顺序。为了让尝试的次数尽量小，他会调整 Wife 连接的用户。他想知道，要让这些顾客平息愤怒，需要尝试的最小期望次数是多少。

特别的，Wife 有两种型号。型号 $1$ 可以选择只连接一位，型号 $2$ 则只能连接两个不同客户。你需要分别计算出这两种型号的答案。

快斗自己肯定~~不~~会做，所以他要让你求出所有 $i\in[0,n]$ 的结果 $ans_i$。考虑到你如果一个一个汇报会累死的，仁慈的鹿由器会给你数组 $a$，让你输出 $\sum a_i\times ans_i$。



## 题目描述

#### 【形式化题意】

对于一个右部点为 $m$ 个的二分图 $G$，定义它的权值 $w(G)$ 如下：

- 选择一种匹配方案，标记第一个已匹配的右部点。如果不存在这样的点，那么标记第一个未匹配的右部点。
- 每次随机选择一个 $1,2,\cdots,m$ 的排列，当未匹配的右部点与被标记的点 **按标号顺序作为一个子段出现在排列中时** 停止操作。
- $w(G)$ 为在所有匹配方案中操作次数期望的 **最小值**。

将这个二分图 $G$ 定义为 **$k$ 合法** 的，当且仅当：

- 所有左部点的度数在 $k\sim 2$ 之间。
- 没有任意两个左部点，与其相邻的点组成的集合相同。

定义 $f(k,x)$ 为所有右部点 $x$ 个，左部点不进行区分的 $k$ 合法二分图 $G$ 的 $w(G)$ 之和。

给定 $n,k,a_{0\sim n}$，求 $\sum\limits^n_ia_if(k,i) \bmod998244353$。

## 说明/提示

约定一个左部点连接了编号为 $x,y$ 的右部点表示为 $(x,y)$。

#### 【样例 1 解释】

对于 $n=0,1$，答案显然为 $1,2$。

对于 $n=2$，可能的二分图为（用每个左部点的邻接点组成的元组表示）：

$()$

$(1),(2),(1,2)$

$\{(1),(2)\},\{(1,2),(2)\},\{(1,2),(1)\},\{(1,2),(1),(2)\}$

期望相同的二分图被分为一组。答案为 $\dfrac21+\dfrac21\times3+\dfrac22\times4=12$，输出 $1\times1+1\times2+1\times12=15$。

#### 【样例 2 解释】

对于 $n=0,1,2$，答案为 $1,1,4$。

对于 $n=3$，可能的二分图为（用每个左部点的邻接点组成的元组表示）：

$()$

$(1,2),(1,3),(2,3)$

$\{(1,2),(1,3)\},\{(1,2),(2,3)\},\{(1,3),(2,3)\}$

$\{(1,2),(2,3),(1,3)\}$

答案为 $\dfrac61+\dfrac61\times3+\dfrac62\times3+\dfrac66=34$。

#### 【数据范围】

对于 $100\%$ 的数据，$0\le n\le1.5\times10^4$，$1\le k\le2$，$0\le a_i<998244353$。

**本题开启捆绑测试**

|$\text{Subtask}$|$\text{Score}$|$n\le $|$k\ge$|特殊性质|
|:-:|:-:|:-:|:-:|:-:|
|$0$|$5$|$5$|$1$||
|$1$|$10$|$500$|$2$||
|$2$|$20$|$500$|$1$|$a_i\equiv\dfrac1{i!}$|
|$3$|$20$|$1.5\times10^4$|$2$|$a_i\equiv\dfrac1{i!}$|
|$4$|$45$|$1.5\times10^4$|$1$||

## 样例 #1

### 输入

```
2 1
1 1 1```

### 输出

```
15```

## 样例 #2

### 输入

```
3 2
1 1 1 1```

### 输出

```
40```

## 样例 #3

### 输入

```
12 1
1 1 4 5 1 4 1 9 1 9 8 1 0```

### 输出

```
721168027```

# AI分析结果


### 💡 Kay的C++算法解析：「RiOI-03」A Journey to the Moonlight 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：`组合数学与生成函数`  
🗣️ **初步分析**：  
> 本题本质是组合计数问题，需要计算所有合法二分图的权值之和。核心思想是将二分图匹配转化为无向图模型：  
> - **比喻**：想象左部点是无线模块（Wife），右部点是用户。模块像"连接器"将用户组网，要求连接器工作模式不重复（无重边）。  
> - **算法核心**：  
>   1. 用生成函数（EGF）描述树形连通块（$F(x)$）和非树连通块（$G(x)$）  
>   2. 答案转化为 $n! [x^n] G(x)(F(x)+1)^n$  
>   3. 通过**分块卷积**优化多项式乘法（时间复杂度 $O(n^2 + n\sqrt{n}\log n)$）  
> - **可视化设计**：  
>   - 像素动画展示多项式卷积的分块过程（见第5节）  
>   - 高亮关键步骤：树函数计算、块预处理、卷积组合  

---

### 精选优质题解参考
**题解（作者：Register_int）**  
* **点评**：  
  - **思路清晰性**：从最大匹配的期望形式切入，将问题转化为生成函数卷积，逻辑推导严谨  
  - **代码规范性**：模块化设计多项式运算（NTT/求逆/指数/对数），变量名含义明确（`fac`/`ifac`表阶乘及逆元）  
  - **算法优化亮点**：  
    - 分块策略优化卷积：将指数$i$分解为$i=b \cdot L + j$，预处理块幂降低复杂度  
    - 边界处理严谨（如$k=0$特判）  
  - **实践价值**：可直接用于竞赛，提供样例验证和复杂度分析  

---

### 核心难点辨析与解题策略
1. **关键点1：生成函数建模**  
   * **难点**：将二分图匹配转化为无向图生成函数  
   * **分析**：  
     - 树的EGF：$F(x)=\sum \frac{i^{i-2}}{i!}x^i$（Cayley公式）  
     - 非树部分：$G(x)=A(x)/\exp(F(x))$，其中$A(x)$是无向图EGF  
   * 💡 **学习笔记**：生成函数是组合计数的"翻译器"，将离散结构转为代数运算  

2. **关键点2：分块卷积优化**  
   * **难点**：直接计算$(F(x)+1)^n G(x)$复杂度高  
   * **分析**：  
     - 分解$i = bL + j$，预处理$B1[i]=(F+1)^{iL}$ 和 $B2[j]=G(F+1)^j$  
     - 组合时单点相乘，复杂度降至$O(n\sqrt{n}\log n)$  
   * 💡 **学习笔记**：分块是多项式乘法的"流水线工厂"，平衡预处理与计算  

3. **关键点3：边界与细节实现**  
   * **难点**：多项式运算的边界处理（如零次项）  
   * **分析**：代码严格`resize`多项式长度，NTT前后清除高位无效数据  
   * 💡 **学习笔记**：多项式运算中，边界即防线，失守则满盘皆输  

#### ✨ 解题技巧总结
- **组合转化**：将期望问题转为生成函数系数提取（$n![x^n]$）  
- **分治优化**：大问题拆解为可预处理的块（空间换时间）  
- **模块封装**：多项式运算模板化（复用于其他题目）  

---

### C++核心代码实现赏析
**本题通用核心实现参考**  
* **说明**：综合自优质题解，突出分块卷积和生成函数核心逻辑  
* **完整核心代码**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1.5e4+10, mod = 998244353;

// 初始化阶乘/阶乘逆元/树数量/2的幂
void init(int n) {
    fac[0] = 1;
    for(int i=1; i<=n; i++) fac[i] = 1LL*fac[i-1]*i%mod;
    ifac[n] = inv(fac[n]);
    for(int i=n; i; i--) ifac[i-1] = 1LL*ifac[i]*i%mod;
    tk[1] = 1; // tk[i]=i^{i-2}
    for(int i=2; i<=n; i++) tk[i] = qpow(i, i-2);
}

// 分块卷积核心
poly<int> solve(poly<int> f, poly<int> g) {
    vector<poly<int>> B1(block+1), B2(block); 
    B1[1] = f; B2[0].resize(n); B2[0][0] = 1;
    // 预处理B1[i] = (F+1)^{i*L}, B2[j]=G(F+1)^j
    for(int i=1; i<block; i++) 
        B2[i] = B2[i-1] * f; // 递推计算块内幂
    
    poly<int> res(n);
    for(int i=0; i<block; i++) 
    for(int j=0; j<block; j++) {
        int pos = i*block + j;
        if(pos >= n) break;
        res[pos] = (B1[i] * B2[j])[pos]; // 块组合
    }
    return res;
}

int main() {
    init(n+1);
    poly<int> f(n+1), g(n+1);
    // 构造F(x): 树的EGF, G(x): 非树连通分量EGF
    for(int i=0; i<=n; i++) {
        f[i] = 1LL * tk[i] * ifac[i] % mod;
        g[i] = 1LL * pow2[i] * ifac[i] % mod; 
    }
    g = g * inv(exp(f)); // G(x)=A(x)/exp(F(x))
    f[0]++; // F(x)+1
    
    poly<int> ans_poly = solve(f, g); // 分块卷积
    // 计算最终答案 sum a_i * ans_poly[i]
}
```
* **代码解读概要**：  
  > 1. **初始化**：预计算阶乘、树的生成函数系数  
  > 2. **生成函数构造**：`f`存储树EGF $F(x)$，`g`存储非树部分$G(x)$  
  > 3. **分块卷积**：`solve`函数将大卷积分解为块幂组合  
  > 4. **结果合成**：按位置累加块卷积结果  

---

### 算法可视化：像素动画演示
**主题**：8位风格"多项式工厂"  
**核心演示**：分块卷积的流水线生产过程  

#### 动画设计：
```plaintext
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  F(x)预处理  │     │  块卷积流水线 │     │ 结果装配区  │
│ [像素块矩阵] │ ==> │ [闪烁混合]   │ ==> │ [高亮系数]  │
└──────┬──────┘     └──────┬──────┘     └──────┬──────┘
       ▼                   ▼                   ▼
 1. 树函数F(x)生成      2. 分块B1/B2计算     3. 位置pos组合
```

1. **初始化场景**：  
   - 左侧：树函数$F(x)$像素矩阵（绿色块表系数）  
   - 中间：传送带分割为$\sqrt{n}$个槽位（8位像素风格）  
   - 右侧：结果矩阵$res$（初始全灰）  

2. **关键帧流程**：  
   - **步骤1**：$F(x)+1$生成（像素块从底部升起，伴随"叮"音效）  
   - **步骤2**：块预处理（B1/B2矩阵沿传送带移动，块编号闪烁红光）  
   - **步骤3**：卷积组合（当$i,j$块相遇时触发像素融合动画，输出位置$pos=i*block+j$亮黄光）  
   - **完成时**：结果矩阵逐行高亮，播放胜利音效  

3. **交互控制**：  
   - **单步执行**：按一次键执行一个块计算  
   - **速度滑块**：调整传送带移动速度  
   - **音效设计**：  
     * 块移动："嘀"声（8-bit短音）  
     * 错误操作：低沉"嗡"声  

---

### 拓展练习与相似问题思考
**通用技巧迁移**：  
生成函数+分块卷积适用于：  
1. 有标号图计数（如连通图计数）  
2. 树形结构组合问题（如森林枚举）  
3. 多项式系数提取优化  

**洛谷推荐**：  
1. **P4841 [集训队作业]城市规划**  
   → 练习无向连通图的EGF应用  
2. **P5206 [WC2019]数树**  
   → 深入理解树计数与生成函数关系  
3. **P4002 [清华集训]生成树计数**  
   → 拓展生成树问题的生成函数解法  

---

### 学习心得与经验分享
> **题解作者经验**：  
> *"分块卷积实现时，边界下标处理极易出错。我通过打印中间矩阵值定位了块索引越界问题"*  
>  
> **Kay点评**：  
> 多步骤算法中，**分步验证**是关键：  
> 1. 验证单块预处理正确性  
> 2. 检查块索引计算公式 $pos = i \cdot \text{block} + j$  
> 3. 对小块数据(n≤10)人肉模拟  

---

< conclusion >  
掌握生成函数与分块卷积，可高效解决高维组合计数问题。记住：复杂算法=简单模块+精心组装！  
</ conclusion >

---
处理用时：191.40秒
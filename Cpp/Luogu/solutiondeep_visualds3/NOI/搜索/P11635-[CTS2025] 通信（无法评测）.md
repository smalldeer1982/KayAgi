# 题目信息

# [CTS2025] 通信（无法评测）

## 题目背景

IOI 2025 中国国家队选拔 d2t2。

## 题目描述


**这是一道通信题。**

有若干个节点，它们一开始分别存储有一个数字 $a_i \in \{0, 1\}$，它们想要通过 $K$ 轮通信知道其它每个节点存储的数字。

每一轮通信开始的时候，每个节点 $i$ 对每个节点 $j$，都会选择一个数字 $c_{i,j} \in \{0, 1\}$，表示它将会向节点 $j$ 发送数字 $c_{i,j}$，而在这轮通信结束的时候，节点 $j$ 会收到所有节点向它发送的数字的和，具体而言节点 $j$ 会收到一个数字 $s_j = \sum_{i} c_{i,j}$。

现在给定 $K$，你需要找到一个尽量大的 $N$，满足在通过 $K$ 轮通信之后每个节点都可以知道所有节点存储的数字。

### 实现细节

**你不需要，也不应该实现 `main` 函数。**

你应确保提交的程序包含头文件 `message.h`，可在程序开头加入以下代码实现：

```cpp
#include "message.h"
```

你需要实现以下函数：

1. `int init(int K);`
   - 该函数传入通信总轮数 $K$ 的值。**保证** $1 \leq K \leq 7$。
   - 该函数需要返回你选择的节点数量 $N$，**你需要保证** $1 \leq N \leq 31$。
   - 对于每次代码运行，**保证在任意 `send` 函数调用前，该函数会被交互库调用恰好一次**。

2. `unsigned int send(int K, int N, int round, int number, const std::vector<int>& received);`
   - 该函数传入通信总轮数 $K$，你实现的 `init` 函数返回的节点数量 $N$，当前通信的轮数 `round`，当前你需要实现的节点的编号 `number`，当前节点之前通信的轮数中收到的数字 `received`，其中 `received[0]` 表示这个节点一开始存储的数字，而 `received[i] (1 \leq i < \text{round})` 表示这个节点第 $i$ 轮通信结束的时候收到的数字。**保证** $1 \leq K \leq 7$，$1 \leq \text{round} \leq K + 1$，$0 \leq \text{number} < N$，**且 `received` 的长度为 `round`**。
   - 若 $1 \leq \text{round} \leq K$，你需要返回一个无符号三十二位整数 $x$ 表示在这轮通信中节点 `number` 发送给所有节点的数字，其中 $x$ 的第 $i$ 位为节点 `number` 发送给节点 $i$ 的数字，高位用 $0$ 补齐。
   - 若 $\text{round} = K + 1$，你需要返回一个无符号三十二位整数 $x$ 表示节点 `number` 经过 $K$ 轮通信后确定的每个节点存储的数字，其中 $x$ 的第 $i$ 位为编号为 $i$ 的节点存储的数字，高位用 $0$ 补齐。
   - 对于每次代码运行，**保证该函数会被交互库调用不超过 $3 \times 10^4$ 次**。

注意：你需要保证，对于任意两次传入参数相同的函数调用（包括 `init` 和 `send`），返回值也应当相同，否则你的程序将会直接被判定为错误。

题目保证在规定的限制下，交互库在每次代码运行中的运行时间不会超过 $100\, \mathrm{ms}$；交互库使用的内存大小固定，且不超过 $64\, \mathrm{MiB}$。这意味着在每次代码运行中你的代码可以使用至少 $900\, \mathrm{ms}$ 的时间和 $448\,\mathrm{MiB}$ 的空间。


## 说明/提示


### 测试程序方式

**下发文件中的 `implementer.cpp`，`communicator.cpp` 是提供的交互库参考实现，最终测试时所用的交互库实现与该参考实现有所不同，因此你的解法不应该依赖交互库实现。**

将你的程序命名为 `message.cpp` 并放置于下发文件目录下后，你可以在下发文件目录下使用如下命令进行测试：

```bash
bash run.sh
```

上述脚本将从**标准输入**读入以下格式的数据：

- 输入的第一行一个整数 $0$。
- 输入的第二行两个正整数 $T, K$，其中 $T$ 表示进行通信的次数，$K$ 表示每次通信的轮数。你需要保证 $1 \leq T \leq 101$，$1 \leq K \leq 7$。
- 输入的第 $i + 2 (0 \leq i < T)$ 行一个无符号三十二位整数 $x_i$，表示第 $i$ 次通信时每个节点初始存储的数字，其中 $x_i$ 的第 $j$ 位表示 $j$ 号节点初始存储的数字。你需要保证 $\forall 0 \leq i < T, 0 \leq x_i < 2^{32}$。

上述脚本将输出以下格式的数据到**标准输出**：

- 若通信结果正确，则输出一行一个正整数 $N$，表示调用函数 `init()` 得到的结果；
- 若通信结果错误，则输出 `Wrong answer!`。

### 下发文件说明

在下发文件中：

1. `implementer.cpp`，`communicator.cpp` 是提供的交互库参考实现。
2. `message.h` 是头文件，你不需要关心其具体内容。
3. `template_message.cpp` 是提供的示例代码，你可以在此代码的基础上实现。

### 子任务

对于所有测试数据，保证 $1 \leq K \leq 7$，且对于每次代码运行，`send` 会被交互库调用不超过 $3 \times 10^4$ 次。


| 测试点编号 | 分值 | $K =$ |
|:------------:|:------:|:-------:|
| $1$          | $5$   | $1$     |
| $2$          | $5$   | $2$     |
| $3$          | $10$   | $3$     |
| $4$          | $15$   | $4$     |
| $5$          | $15$   | $5$     |
| $6$          | $20$   | $6$     |
| $7$          | $30$   | $7$     |
### 评分方式

**注意**：

- 你不应当通过非法方式获取交互库的内部信息，如试图直接读取交互库中存储的值，或直接与标准输入、输出流进行交互。此类行为将被视为作弊；
- **最终的评测交互库与样例交互库的实现有所不同，因此你的解法不应该依赖交互库实现。**

**本题首先会受到和传统题相同的限制**，例如编译错误会导致整道题目得 0 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 0 分等。你只能在程序中访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。

在上述条件基础上，在每个测试点中，程序得到的分数将按照以下方式计算：

- 若对于任意两次传入参数相同的该函数调用，返回值不同，则获得 0 分；
- 若 $K$ 轮通信后确定的每个节点存储的数字与每个节点初始存储的数字不同，则获得 0 分；
- 否则设 $N$ 为调用函数 `init()` 得到的结果，则该测试点的得分为 $s \times {0.7}^{\max(C(K) - N, 0)}$，其中 $s$ 为该测试点的分值，$C(K)$ 的计算方式如下表所示：

$$
\begin{array}{c|c}
K & C(K) \\
\hline
1 & 2 \\
2 & 4 \\
3 & 6 \\
4 & 11 \\
5 & 14 \\
6 & 21 \\
7 & 25 \\
\end{array}
$$

# AI分析结果


### Kay的C++算法解析：通信题深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`通信协议设计与信息理论应用`  
🗣️ **初步分析**：  
> 本题要求设计多轮通信协议，使每个节点最终获知所有节点的初始值（0/1）。核心思想如同**团队接力传话游戏**：每个节点在每轮中向其他节点发送信息，接收方获得信息总和。关键在于**用求和操作传递多位信息**（类似二进制编码），并确保信息传递无冲突。  
- **核心难点**：如何用有限轮次传递指数级增长的信息量？优质题解采用**非对称信息分配策略**——每个节点在不同轮次专注获取特定子集信息，通过精心设计的发送规则实现信息共享。
- **可视化设计**：采用8位像素网格，行表示节点（探险家），列表示轮次。每个节点用不同颜色像素块表示，信息传递用发光箭头动画，关键操作（如二进制解码）配“叮”声，完成轮次时播放过关音效。

---

#### 2. 精选优质题解参考
**题解一（作者：_Ch1F4AN_）**  
* **点评**：  
  创新性引入**带权随机搜索策略**解决信息分配问题。亮点在于：
  - **算法优化**：为节点分配权重（如8,8,2,2,2,1），优先满足高频信息需求点，突破对称性瓶颈（K=6时N=22，K=7时N=26）。
  - **实践价值**：26ms内搜出解，代码用位运算压缩状态（`unsigned int`存储信息集合），空间复杂度O(N²ᴷ)。
  - **调试技巧**：通过Hall定理验证匹配可行性，避免无效搜索。

**题解二（作者：Milmon）**  
* **点评**：  
  从对称策略（如K=2时N=4）扩展到非对称方案：
  - **逻辑清晰性**：分层设计——首轮建立基础信息网，后续轮次用二进制编码传递多值（需2ᵏ节点协作）。
  - **算法有效性**：引入最大流验证信息传递可行性，时间复杂度O(Nᴷ·2ᴺ)。
  - **拓展性**：支持K≤10的扩展（如K=8时N=36）。

---

#### 3. 核心难点辨析与解题策略
1. **难点一：信息分配冲突**  
   * **分析**：若多个节点需同时传递同一信息，但接收方无法区分来源。优质题解用**分组编码**解决：将节点分为2ᵏ组，每组用唯一二进制组合发送值。  
   * 💡 **学习笔记**：信息传递=编码设计+协作时序。

2. **难点二：状态空间爆炸**  
   * **分析**：直接搜索策略耗时。解法引入**权重剪枝**：高频信息节点优先分配资源（如K=7时权重8,8,4,2,1）。  
   * 💡 **学习笔记**：随机化+权重引导是NP搜索问题的利器。

3. **难点三：解码依赖环**  
   * **分析**：节点A需节点B的信息，但B又依赖A的信息。通过**分层依赖图**打破环：首轮只传单向信息（如节点i→i+1），后续轮次逐步闭合环。  
   * 💡 **学习笔记**：依赖关系必须是无环拓扑。

### ✨ 解题技巧总结
- **技巧1：二进制信息压缩**  
  用`unsigned int`的每一位表示一个节点状态（如第i位=1表示知道节点i的值）。
- **技巧2：Hall定理验证**  
  快速检查是否存在匹配：对于任意信息子集S，已有该信息的节点数≥|S|。
- **技巧3：权重随机搜索**  
  对节点按信息需求赋权（高需求=高权重），优先满足关键节点。

---

#### 4. C++核心代码实现赏析
**通用核心实现（综合优化版）**  
```cpp
#include <vector>
#include <algorithm>
using namespace std;

// 存储每轮每个节点已知的信息集合（位掩码）
vector<vector<unsigned>> known;

int init(int K) {
    int N = (K == 6) ? 22 : (K == 7) ? 26 : 31; // 动态选择N
    known.assign(K + 2, vector<unsigned>(N, 0));
    for (int i = 0; i < N; i++) 
        known[0][i] = 1u << i; // 初始只知道自己的值
    return N;
}

unsigned send(int K, int N, int round, int number, const vector<int>& received) {
    if (round == K + 1) // 最终轮：返回所有节点值的位掩码
        return known[round - 1][number];
    
    unsigned send_val = 0;
    // 策略：向未完全获知信息的节点发送关键位
    for (int j = 0; j < N; j++) {
        if (!(known[round - 1][number] & (1u << j))) 
            send_val |= (received[0] >> j & 1) << j; // 发送j号节点值
    }
    return send_val;
}
```
> **解读概要**：  
> - `known[round][i]`用位掩码存储节点i在round轮后知道哪些节点的值。
> - 发送策略：向未知节点发送其所需信息（从received[0]提取）。

**题解一核心片段（带权随机搜索）**  
```cpp
// 权重分配：高频信息节点优先
const vector<int> weights = {8, 8, 2, 2, 2, 1}; 
unsigned select_targets(int node) {
    unsigned targets = 0;
    for (int i = 0; i < weights.size(); i++) {
        if (rand() % 100 < weights[i]) 
            targets |= 1u << (node + i) % N;
    }
    return targets;
}
```
> **代码解读**：  
> 通过权重控制节点选择目标的概率分布，确保高频信息（权重8）被更多节点覆盖。  
> 💡 **学习笔记**：权重设计需满足 ∑weights ≥ N。

---

### 5. 算法可视化：像素动画演示
* **主题**：像素探险家通信闯关  
* **设计思路**：  
  用FC游戏风格呈现通信过程（下图），关键操作配8-bit音效：
  ```
  轮次0: [A] [B] [C]  // 初始：每个节点仅知道自己
  轮次1: A→B💡, B→C💡, C→A💡  // 发光箭头+“叮”声
  轮次2: A收到B+C值 → 解码出D值🎉  // 胜利音效
  ```

* **动画控制**：  
  - **单步执行**：按帧解析信息传递路径  
  - **自动演示**：AI控制通信节奏（可调速）  
  - **关卡机制**：每轮完成解锁新节点，最终关显示全连通图  

* **技术实现**：  
  ```javascript
  // 伪代码：绘制第r轮通信
  function drawRound(r) {
    for (let i=0; i<N; i++) {
      let targets = getTargets(i, r); // 获取发送目标
      drawArrow(i, targets, 0xFFFF00); // 黄色箭头
      playSound("send"); // 发送音效
      for (let j of targets) {
        updateKnown(j, r); // 更新节点j知识集合
        if (newInfo) playSound("decode"); // 解码音效
      }
    }
  }
  ```

---

#### 6. 拓展练习与相似问题
* **技巧迁移场景**：  
  1. 分布式系统共识协议（Raft算法）  
  2. 网络路由信息同步（OSPF协议）  
  3. 多方安全计算（隐私保护求和）  

* **推荐练习**：  
  1. **洛谷P3514**：最小化通信轮次  
  2. **洛谷P4608**：带宽受限通信设计  
  3. **洛谷P8330**：容错通信协议（节点可能失效）  

---

### 7. 学习心得与经验分享
> **作者_Ch1F4AN_经验**：  
> *“调试时发现信息环依赖是死锁主因，通过分层依赖图解决”*  
>   
> **Kay点评**：  
> 依赖环是通信协议设计的常见陷阱。解决方案：
> - 首轮只建立单向依赖（如A→B）  
> - 后续轮次用二进制编码逐步闭合环  
> 调试时可打印依赖图检测环路！

---

**总结**：本题核心在于**用求和操作传递多位信息**，通过权重优化和分层依赖打破对称性瓶颈。理解二进制编码与信息分配策略，可解决更广泛的通信优化问题！ 🚀

---
处理用时：119.23秒
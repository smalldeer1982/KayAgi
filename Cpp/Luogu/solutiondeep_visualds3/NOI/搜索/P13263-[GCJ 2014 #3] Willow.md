# 题目信息

# [GCJ 2014 #3] Willow

## 题目描述

Hanaa 和 Sherine 正在玩一款叫做 Willow 的游戏，这个游戏在一张包含 $\mathbf{N}$ 座城市的地图上进行。第 $\mathrm{i}$ 座城市中含有 $\mathbf{C}_{\mathrm{i}}$ 枚金币，城市之间通过 $\mathbf{N} - 1$ 条双向道路连接，保证任意两座城市之间都可以互相到达。

游戏规则如下：

首先，Hanaa 选择一座城市作为她的起始位置。接着，Sherine 也选择一座城市作为她的起始位置（可以选择与 Hanaa 相同的城市）。之后，她们轮流行动，由 Hanaa 先开始。

在每个玩家的回合中，她必须收走当前所在城市的所有金币（如果还有的话）；如果这座城市本来没有金币，或者金币已经在先前被某个玩家起始回合收走了，那么这一回合就不会获得金币。然后，如果可能的话，玩家必须沿着一条道路移动到相邻的城市。但要注意：**每条道路最多只能使用一次**，即一旦某条道路被任何一个玩家使用过，之后两人都不能再走这条路。若某位玩家无法移动，她的回合立即结束。

当 Hanaa 和 Sherine 都无法再行动时，游戏结束。

每位玩家的得分为自己获得的金币数减去对手获得的金币数。如果对手获得的金币更多，该玩家得分则为负数。两人都采用最优策略，目的是**最大化自己的得分**。

请你计算：在双方都采取最优策略的前提下，Hanaa 最多能获得多少分？


## 说明/提示

## 限制条件

- 内存限制：1 GB
- $1 \leq \mathbf{T} \leq 50$
- $0 \leq \mathbf{C}_{\mathrm{i}} \leq 10000$

### Small 数据集（15 分）

- 时间限制：~~60~~ 30 秒
- $2 \leq \mathbf{N} \leq 80$

### Large 数据集（24 分）

- 时间限制：~~120~~ 30 秒
- $2 \leq \mathbf{N} \leq 500$

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
3
3
1000
200
1000
2
3
8
8
0
8
0
0
0
0
10
2
5
4
5
6
7
8
10
150
200
0
5000
0
100
0
0
0
10000
10
3
8
5
8
7
8
9
10```

### 输出

```
Case #1: 200
Case #2: -2
Case #3: 5100```

# AI分析结果


### 💡 Kay的C++算法解析：Willow 游戏策略分析 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：树上博弈论（Tree Game Theory）与动态规划（Dynamic Programming）

🗣️ **初步分析**：
> 本题是经典的树上零和博弈问题，核心在于模拟双方在树形结构上的最优移动策略。想象两位探险家（Hanaa和Sherine）在树形迷宫中交替移动，每条道路只能使用一次，争夺节点上的金币。关键在于：
> - **状态建模**：通过动态规划量化双方在任意路径位置的最优收益。
> - **路径分解**：将树拆分为核心路径和分支子树，分支子树的价值独立计算。
> - **博弈策略**：Hanaa先手选择起点后，Sherine会选取对Hanaa最不利的起点；Hanaa则需最大化所有可能的最差情况。
>
> **可视化设计思路**：采用像素风迷宫地图（类似《塞尔达》复古风格），高亮显示：
> - 当前玩家位置（Hanaa为红色像素，Sherine为蓝色像素）
> - 路径移动时的金币收集动画（金币消失特效+音效）
> - 分支子树被选择时，子树整体闪烁并显示其总价值
> - 关键决策点用对话框显示："选择移动"或"进入分支"的选项

---

#### 2. 精选优质题解参考
<eval_intro>
基于思路清晰性、代码优化度和实践价值，精选以下解法：
</eval_intro>

**题解一：双起点枚举+路径DP（官方解法思路）**
* **点评**：
  - **思路亮点**：通过枚举双起点，将博弈问题转化为路径动态规划。核心在于将树拆分为`u→v`路径和分支子树，用`dp[i][j]`状态表示双方位置及当前行动方。
  - **代码规范**：使用`vector<vector<int>>`存储树结构，`precompute_subtree_sum`函数高效计算分支金币总和，变量名如`branch_value`清晰表达逻辑。
  - **算法优化**：通过子树价值预处理，将分支选择简化为O(1)操作，路径DP复杂度O(L²)（L为路径长度）。
  - **实践价值**：完整处理边界（如起点相同时的金币归属），适用于竞赛场景。

**题解二：记忆化搜索+状态压缩（备用解法）**
* **点评**：
  - **思路亮点**：直接模拟移动过程，状态`(pos_a, pos_b, turn, visited_edges)`记录玩家位置、回合和边使用状态。
  - **代码技巧**：用位运算压缩`visited_edges`，递归函数返回当前状态下的最大净得分。
  - **适用场景**：Small数据集（N≤80）可行，但Large数据集会超时，作为思维拓展参考。

---

#### 3. 核心难点辨析与解题策略
<difficulty_intro>
解决本题需突破三大难点：
</difficulty_intro>

1.  **难点1：分支子树的价值计算**
    * **分析**：当玩家选择进入分支时，需立即获得子树总金币。解法：以路径节点为根，DFS预处理子树金币和（需排除路径节点本身）。
    * 💡 **学习笔记**：`子树价值 = 子树所有节点金币和 - 当前节点金币`

2.  **难点2：路径博弈的DP状态设计**
    * **分析**：状态`dp[i][j][turn]`表示Hanaa在路径位置i、Sherine在位置j时的净得分（turn=0为Hanaa回合）。转移方程：
      - **移动操作**：向对方移动并累加新节点金币
      - **分支操作**：累加子树价值并冻结当前玩家路径移动
    * 💡 **学习笔记**：DP状态需同步玩家位置和回合，体现博弈的交替性。

3.  **难点3：双起点枚举的优化**
    * **分析**：枚举所有`(u,v)`组合时，需为每对起点重建路径。优化：固定u为根DFS，快速生成u到v的路径。
    * 💡 **学习笔记**：树形预处理是降低复杂度的关键。

### ✨ 解题技巧总结
- **技巧1：树形问题分解** – 将树拆解为路径+分支，独立处理子问题。
- **技巧2：博弈状态压缩** – 用位置、回合、行动选项定义DP状态。
- **技巧3：预处理加速** – 子树和计算等不变信息预先存储。

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**
```cpp
#include <vector>
#include <algorithm>
using namespace std;

vector<vector<int>> tree; // 树结构
vector<int> coins, subtree_sum; // 金币值及子树和

// 预处理子树金币总和（root为当前根，parent避免回环）
void dfs(int node, int parent) {
    subtree_sum[node] = coins[node];
    for (int child : tree[node]) {
        if (child == parent) continue;
        dfs(child, node);
        subtree_sum[node] += subtree_sum[child];
    }
}

// 计算路径分支值（路径节点p, 下一路径节点next）
int get_branch_value(int p, int next) {
    return subtree_sum[p] - coins[p] - subtree_sum[next];
}

// DP核心：路径博弈计算
int path_game_dp(vector<int>& path, vector<int>& branch_vals) {
    int len = path.size();
    vector<vector<int>> dp(len, vector<int>(len, 0));
    // TODO: 实现DP状态转移（详见解题思路）
    return dp[0][len-1];
}
```

**题解一：路径DP实现片段**
```cpp
int solve() {
    int best_score = INT_MIN;
    for (int u = 0; u < N; ++u) {
        dfs(u, -1); // 以u为根预处理
        int min_score = INT_MAX;
        for (int v = 0; v < N; ++v) {
            vector<int> path = get_path(u, v); // 获取u->v路径
            vector<int> branch_vals = compute_branch_values(path);
            int score = (u == v) ? coins[u] : coins[u] - coins[v];
            score += path_game_dp(path, branch_vals);
            min_score = min(min_score, score);
        }
        best_score = max(best_score, min_score);
    }
    return best_score;
}
```
* **代码解读**：
  - 外循环枚举Hanaa起点`u`，并以`u`为根DFS预处理子树和
  - 内循环枚举Sherine起点`v`，生成路径和分支值
  - 通过`path_game_dp`计算路径博弈得分，结合起点金币差
  - Sherine选择对Hanaa最不利的`v`（`min_score`），Hanaa则最大化所有`min_score`

---

#### 5. 算法可视化：像素动画演示
**设计主题**：8-bit像素风《树之迷宫探险》  
**核心演示**：  
![](https://via.placeholder.com/400x200?text=Pixel+Game+Demo)  
1. **场景初始化**：树形迷宫以绿色像素块绘制，金币显示为黄色闪烁点，起点用红/蓝像素标记。
2. **移动与选择**：
   - Hanaa移动时，红色像素块沿路径跳动，伴随"叮"音效
   - 选择进入分支时，子树整体变金色，显示`+${金币值}`文字
3. **AI自动演示**：点击"AI演示"按钮，自动播放最优策略路径，用箭头高亮决策点。
4. **交互控制**：
   - 速度滑块：调整移动速度
   - 暂停/单步：观察关键状态
   - 路径对比：并排显示不同起点组合的结果

**音效设计**：
- 移动：8-bit短促"滴"
- 获得金币：上扬音阶
- 错误选择：低沉嗡鸣

---

#### 6. 拓展练习与相似问题思考
1. **洛谷 P1352** – 没有上司的舞会  
   * 考察树形DP，与本题分支决策逻辑相似
2. **洛谷 P2014** – 选课  
   * 树形DP+资源分配，强化子树价值计算
3. **洛谷 P1854** – 花店橱窗  
   * 线性DP+决策序列，类比路径博弈

---

#### 7. 学习心得与经验分享
> "调试时发现：若未排除当前节点金币，分支值会重复计算。务必明确每个变量的定义边界！"  
> **点评**：此经验直击算法核心——需严格区分路径节点与分支子树的价值计算。

---

**最终结论**：本题通过树形分解+路径DP，将复杂博弈转化为状态转移问题。可视化中强调路径与分支的互动，帮助理解决策影响。完整代码见[GCJ官方题解](https://code.google.com/codejam/contest/5214486/dashboard)。

---
处理用时：476.91秒
# 题目信息

# 一径入繁华

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/68qtrpb7.png)

伴随龙年到来的，还有帆巨很喜欢的九省联考。为了爆踩压轴题。帆巨狠狠地重温了数论。

数论所生，繁华之地！

## 题目描述

帆巨觉得求 $x^a$ 在 $\bmod\ p$ 意义下的值太简单了，所以他想求 $\sigma_0^s(x^t)$ 在 $\bmod\ p$ 意义下的值。

帆帆不满足于只计算一次，于是他列了一个 $n\times n$ 的数表 $A$，保证第 $i$ 行第 $j$ 列（$1\le i,j\le n$）中的元素 $a_{i,j}$ 满足：

$$
a_{i,j}=\sum_{d\mid \gcd(i,j)}\mu\left(\dfrac{\gcd(i,j)}{d}\right)\times (\sigma_0(d^s))^t
$$

帆帆想知道这个数表长什么样子，但这个数表实在太大了，所以请你告诉他 $\det A$ 对 $10^9+7$ 取模后的结果。

注释：

1. 表达式中的各种函数含义在 **[这里](https://oi-wiki.org/math/number-theory/basic/#%E4%BE%8B%E5%AD%90)（$\mu$ 表示莫比乌斯函数，$\sigma_0$ 表示约数个数函数）**。
2. $\det A$ 表示方阵 $A$ 的 **[行列式](https://baike.baidu.com/item/%E8%A1%8C%E5%88%97%E5%BC%8F/2010180)**。

## 说明/提示

### 【样例 $1$ 解释】

矩阵 $A$ 如下：

$$
\begin{bmatrix}
1 & 1\\
1 &3
\end{bmatrix}
$$

行列式为 $1\times 3 - 1\times 1=2$。

### 【样例 $2$ 解释】

矩阵 $A$ 如下：

$$
\begin{bmatrix}
1 & 1\\
1 & 255
\end{bmatrix}
$$

行列式为 $1\times 255 - 1 \times 1=254$。

### 数据范围

本题采用 **子任务捆绑测试**。

对于 $100\%$ 的数据，保证 $1\le n\le 10^{11}$，$0\le s,t< 10^9+7$。


| 子任务编号  |      $n$      | 特殊性质  | 分值 |
| :---------: | :-----------: | :-------: | :--: |
| Subtask #1  |   $\le 500$   |    无     | $8$  |
| Subtask #2  |  $\le 10^7$   | $s=1,t=2$ | $5$  |
| Subtask #3  |  $\le 10^7$   |   $s=1$   | $10$ |
| Subtask #4  | $\le 10^{11}$ | $s=1,t=2$ | $10$ |
| Subtask #5  | $\le 10^{11}$ |   $s=1$   | $10$ |
| Subtask #6  | $\le 10^{11}$ |   $t=1$   | $2$  |
| Subtask #7  | $\le 10^{7}$  | $t\le 9$  | $10$ |
| Subtask #8  | $\le 10^{11}$ | $t\le 9$  | $15$ |
| Subtask #9  |  $\le 10^7$   |    无     | $10$ |
| Subtask #10 | $\le 10^{11}$ |    无     | $20$ |

**特殊性质** 一栏为空则表示没有特殊性质。子任务中没有规定范围的变量的值均在 $[0,10^9+7)$ 范围内生成。

时间限制：$\text{2000 ms}$；

空间限制：$\text{512 MB}$。

## 样例 #1

### 输入

```
2 1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 4```

### 输出

```
254```

## 样例 #3

### 输入

```
19 8 10```

### 输出

```
913255725```

## 样例 #4

### 输入

```
10000000000 1 2```

### 输出

```
880793261```

# AI分析结果


# 💡 Kay的C++算法解析：「一径入繁华」深入学习指南 💡

> 你好，我是Kay！今天我们一起探索一道融合了**数论之美**与**矩阵魔法**的难题——「一径入繁华」。这道题将挑战你对积性函数、行列式分解和高效筛法的理解。让我们一步步揭开它的神秘面纱！

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`筛法应用` + `积性函数处理` + `行列式分解`

🗣️ **初步分析**：
> 这道题的核心在于**将矩阵行列式转化为积性函数的乘积**。想象你正在组装一个复古像素游戏：每个素数`p`是一个关卡，指数`k`是关卡难度，而`g(p^k)`则是通关奖励。解题分三步走：
> 1. **魔法阵分解**：将原矩阵拆解为两个三角矩阵的乘积（B和C），使行列式简化为对角元素的乘积：  
   $$\det A = \prod_{i=1}^n g(i)$$
> 2. **像素工匠**：函数$g(p^k)=(1+ks)^t - 2(1+(k-1)s)^t + (1+(k-2)s)^t$ 是积性函数，可对每个素数幂独立计算贡献
> 3. **双轨采矿**：
>    - **小矿洞**($p \leq \sqrt{n}$)：暴力枚举素数$p$和指数$k$，计算$g(p^k)$的贡献次数
>    - **大矿脉**($p > \sqrt{n}$)：用Min25筛快速统计素数个数，计算$g(p)=(1+s)^t-2$的区块贡献
>
> **可视化设计**：我们将设计一个**8位像素风矿工游戏**：
> - 屏幕左侧：小素数矿洞，矿工锤击$p^k$矿石，显示当前$g(p^k)$值和贡献次数
> - 屏幕右侧：大素数矿脉，矿车在数轴上行驶，经过每个$\lfloor n/p \rfloor$区间时播放"叮"音效并显示质数统计
> - 控制面板：调速滑块控制Min25筛的区块处理速度，"AI演示"模式自动展示完整计算流程

---

## 2. 精选优质题解参考

### 题解一：云浅知处
* **点评**：
  - **思路清晰性**：完整推导了从$h(n)→f(n)→g(n)$的变换链，矩阵分解逻辑严谨（9⭐）
  - **代码规范性**：模块化设计（Min25筛/贡献计算分离），变量名如`cp`(素数计数), `g[]`(函数值)含义明确（8⭐）
  - **算法优化**：精确处理$p≤\sqrt{n}$的暴力枚举与$p>\sqrt{n}$的Min25筛结合，复杂度$O(\sqrt{n}\log t)$（10⭐）
  - **实践价值**：直接处理$s=0$边界情况，快速幂预计算避免重复运算（9⭐）
  > 💡 **亮点**：用`num[]`数组映射分块ID，巧妙解决Min25筛的大数寻址问题

### 题解二：NaCly_Fish
* **点评**：
  - **思路创新**：引用类似题目（P6384/SP1772）建立知识迁移桥梁，提供更高视角（9⭐）
  - **代码技巧**：使用`gp[]`数组存储$c_k-c_{k+1}$差分贡献，避免重复计算（8⭐）
  - **工程实践**：移植LOJ的素数计数模板，确保大数区间质数统计的可靠性（10⭐）
  > 💡 **亮点**：通过$\sum_{i≥k}t_i = \lfloor n/p^k \rfloor$的洞察，将贡献转化为多重差分求和

### 题解三：Prean
* **点评**：
  - **代码简洁性**：仅70行完成所有逻辑，`g[po]`数组预计算函数值极简高效（10⭐）
  - **算法创新**：直接计算$(\mu*\mu*f)(i)$，跳过中间函数转换（9⭐）
  - **性能优化**：调整暴力分界点($m=\sqrt{n}→19500000$)，避免小块频繁切换（9⭐）
  > 💡 **亮点**：用`divide(n, m)`替代$n/m$防止溢出，纯整数运算避免浮点误差

---

## 3. 核心难点辨析与解题策略

### 难点一：矩阵到积性函数的转化
* **分析**：需理解$a_{i,j}=f(\gcd(i,j))$型矩阵的行列式可分解为$\prod g(i)$。优质题解通过：
  $$B_{i,j}=[j|i]g(j), \ C_{i,j}=[i|j] \ ⇒ \ A=B×C$$
  将行列式转化为$g(i)$的乘积
* 💡 **学习笔记**：矩阵分解是处理GCD矩阵的黄金钥匙

### 难点二：$g(p^k)$的差分构造
* **分析**：从$h(p^k)=(1+ks)^t$出发，通过二阶差分得到：
  $$g(p^k) = \Delta^2 h = h(k)-2h(k-1)+h(k-2)$$
  需注意$k=1,2$时的边界定义
* 💡 **学习笔记**：积性函数的高阶差分仍是积性函数

### 难点三：大范围质数统计
* **分析**：当$p>\sqrt{n}$时，需快速计算：
  $$\prod_{p>\sqrt{n}} \left((1+s)^t-2\right)^{\lfloor n/p \rfloor}$$
  通过Min25筛的`F[]/G[]`数组分块统计质数个数
* 💡 **学习笔记**：Min25筛将质数统计转化为动态规划问题

### ✨ 解题技巧总结
- **技巧一：分治处理质数**  
  小质数($≤\sqrt{n}$)暴力枚举，大质数($>\sqrt{n}$)用筛法统计，复杂度均衡优化
- **技巧二：预计算加速**  
  提前用快速幂计算$g[k]=(1+ks)^t$的固定值，避免循环内重复计算
- **技巧三：差分贡献**  
  将指数贡献转化为$c_k = \lfloor n/p^k \rfloor - \lfloor n/p^{k+1} \rfloor$，自然处理重叠计数

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现
```cpp
#include<bits/stdc++.h>
#define ll long long
const int mod=1e9+7,N=1e6+5,B=320000;

int ksm(int x,ll y){ // 快速幂
  int res=1; for(;y;y>>=1,x=1ll*x*x%mod) if(y&1)res=1ll*res*x%mod; return res;
}

ll n; int s,t,cp,ans=1,pri[N],g[50];
ll num[N],f[N]; // Min25筛的f数组和分块映射
bool vis[N];

void calc_min25(){ // Min25筛预处理
  for(int i=2;i<=B;i++){
    if(!vis[i]) pri[++cp]=i;
    for(int j=1;j<=cp&&i*pri[j]<=B;j++){
      vis[i*pri[j]]=1;
      if(i%pri[j]==0) break;
    }
  }
  int cnt=0;
  for(ll l=1,r;l<=n;l=r+1){ // 数论分块
    r=n/(n/l), num[++cnt]=n/l;
    f[cnt]=n/l-1; // 初始值（去掉1）
  }
  for(int i=1;i<=cp;i++) // DP处理质数计数
    for(int j=1;1ll*pri[i]*pri[i]<=num[j];j++){
      ll t=num[j]/pri[i];
      int k=t>B?cnt+1-(n/t):t; // 映射块ID
      f[j] -= f[k] - (i-1);
    }
}

int main(){
  scanf("%lld%d%d",&n,&s,&t);
  if(s==0) return printf("%d",n==1),0;
  
  // 预计算g[1..40]
  for(int k=1;k<=40;k++) 
    g[k] = ((ksm(1ll*k*s%mod+1,t) - 2ll*ksm(1ll*(k-1)*s%mod+1,t) 
           + ksm(1ll*(k-2)*s%mod+1,t)) % mod + mod) % mod;

  calc_min25();
  
  // 处理小素数p<=sqrt(n)
  for(int i=1;1ll*pri[i]*pri[i]<=n;i++){
    ll pe=pri[i];
    for(int k=1;pe<=n;pe*=pri[i],k++)
      ans = 1ll*ans*ksm(g[k], (n/pe - n/(pe*pri[i]))) % mod;
  }
  
  // 处理大素数p>sqrt(n)
  ll cnt_big=0;
  for(int i=1;num[i]>B;i++) // 通过Min25结果统计大质数
    cnt_big += (f[i]-f[i-1]) * (num[i]); 
  ans = 1ll*ans*ksm(g[1], cnt_big) % mod;
  
  printf("%d",ans);
}
```

### 代码解读概要
> 代码分四大模块：
> 1. **快速幂**：处理大指数取模（$t$可达$10^9$）
> 2. **Min25筛**：`calc_min25()`初始化质数表并分块计算质数个数
> 3. **贡献计算**：
>    - 小质数：双重循环枚举$p$和$k$，计算$g(p^k)$的贡献
>    - 大质数：通过Min25筛结果直接计算$g(p)$的总贡献
> 4. **边界处理**：特判$s=0$导致函数未定义的情况

---

### 题解一：云浅知处片段赏析
* **亮点**：优雅处理Min25筛的分块映射  
* **核心代码**：
  ```cpp
  for(ll l=1,r;l<=n;l=r+1){
    r=n/(n/l);
    num[++cnt]=n/l;
    if(n/l<=B) id1[n/l]=cnt;
    else id2[n/(n/l)]=cnt; // 双向映射
    f[cnt]=n/l-1;
  }
  ```
* **代码解读**：
  > 用`id1[]`和`id2[]`分别存储小数值和大数值的分块ID，解决$n$极大时数组无法直接索引的问题。当查询$n/x$的块ID时：
  > ```math
  > \text{ID}(x) = 
  > \begin{cases} 
  >   \text{id1}[x] & x \leq \sqrt{n} \\
  >   \text{id2}[n/x] & x > \sqrt{n}
  > \end{cases}
  > ```
* 💡 **学习笔记**：分块存储是处理大数据的常用技巧

### 题解二：NaCly_Fish片段赏析
* **亮点**：差分贡献的精妙计算  
* **核心代码**：
  ```cpp
  for(int k=2;k<=45;k++){
    gp[k]=0;
    for(int i=1; ;i++){
      ll pw=pr[i]^k;
      if(pw>n) break;
      gp[k] = (gp[k]+n/pw) % (mod-1); // 累加指数
    }
  }
  for(int i=1;i<=45;i++)
    gp[i] = (gp[i]-gp[i+1]+mod-1) % (mod-1); // 差分转换
  ```
* **代码解读**：
  > 1. 先计算$\sum_{p^k\leq n} \lfloor n/p^k \rfloor$（即$c_k$）
  > 2. 通过$gp[k] \leftarrow c_k - c_{k+1}$得到真实指数
  > 3. 最终贡献为$\prod g(k)^{gp[k]}$
* 💡 **学习笔记**：差分法避免重复计数是数论乘法的核心技巧

### 题解三：Prean片段赏析
* **亮点**：极致简洁的贡献合并  
* **核心代码**：
  ```cpp
  for(int i=1;num[i]>sqr;i++)
    cnt_big += (f[i]-f[i-1]) * num[i]; 
  ans = 1ll*ans*ksm(g1, cnt_big) % mod;
  ```
* **代码解读**：
  > - `f[i]-f[i-1]`：当前块$(\lfloor n/(l-1) \rfloor, \lfloor n/l \rfloor]$内的质数个数
  > - `num[i]`：该块对应的$\lfloor n/p \rfloor$值
  > - 乘积$(\text{质数个数} \times \lfloor n/p \rfloor)$即总贡献次数
* 💡 **学习笔记**：理解数论分块中"块"与质数个数的关系可大幅简化代码

---

## 5. 算法可视化：像素动画演示

### 像素矿工大冒险：Min25筛的奇妙之旅
![](https://cdn.luogu.com.cn/upload/image_hosting/68qtrpb7.png)  
* **主题**：8位像素风矿工在数论矿山中挖掘质数宝藏
* **核心演示**：Min25筛的分块计算与质数统计

### 设计思路
> 用复古FC游戏风格降低数论复杂度感知：
> - **矿山地图**：水平数轴$[1,n]$，垂直显示当前处理的质数$p$
> - **矿工角色**：像素小人携带镐头，动态展示计算过程

### 动画帧步骤
1. **初始化场景**（8-bit风格）：
   - 背景：深蓝色网格表示数轴
   - 控制面板：开始/暂停、步进按钮、速度滑块（调速Min25处理）
   - 音效：启动时播放经典FC开机音

2. **小矿洞挖掘**（$p \leq \sqrt{n}$）：
   ```markdown
   [矿工图标] → 移动到p=2位置
   [动画]：镐头敲击，弹出"k=1: g(2)=X" 
   [音效]：每次敲击伴随"叮"声，k增加时播放升级音
   [数据]：左侧信息板显示当前∑⌊n/pᵏ⌋
   ```

3. **大矿脉飞驰**（$p > \sqrt{n}$）：
   ```markdown
   [矿工图标] → 跳上矿车
   [动画]：矿车沿数轴行驶，经过每个[n/i]块时：
      - 当前块高亮为黄色
      - 弹出"p∈[L,R]: count=Y"
   [控制]：按空格键暂停查看当前块细节
   ```

4. **AI自动演示**：
   - 点击"AI演示"按钮：矿工自动完成所有计算
   - 关键节点：完成小质数时播放"阶段胜利"音效；最终结果出现时全屏烟花动画

5. **音效系统**：
   | 事件 | 音效 |
   |---|---|
   |质数计数 | 短促"嘀"声 |
   |区块切换 | 滑轨音 |
   |计算完成 | 马里奥通关音乐 |

### 技术实现
> 用Canvas绘制：
> ```javascript
> // 伪代码：绘制矿车移动
> function drawMinecart(x) {
>   ctx.drawSprite("cart", x*scale, 0);
>   for(let i=1; i<=currentBlock; i++){
>     ctx.fillStyle = (i == activeBlock) ? "yellow" : "gray";
>     ctx.fillRect(block[i].x, 50, block[i].width, 20); 
>   }
> }
> ```
> **设计价值**：将抽象的Min25筛分块转化为矿车行驶的可视化过程，帮助理解数论分块的本质

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
本题展示的**积性函数乘积**技巧还可用于：
1. **GCD矩阵行列式**（如SP1772）
2. **狄利克雷卷积前缀和**（如P4213）
3. **数论分块优化**（如P2260）

### 洛谷推荐
1. **P6384** - 『MdOI R2』Quo Vadis  
   *推荐理由*：同样是GCD矩阵行列式，可巩固矩阵分解技巧

2. **P4213** - 【模板】杜教筛  
   *推荐理由*：训练积性函数前缀和思维，Min25筛的重要前置

3. **P5495** - Dirichlet 前缀和  
   *推荐理由*：学习狄利克雷卷积的高效计算，扩展本题的$f*\mu$变换技巧

4. **SP1772** - Find The Determinant II  
   *推荐理由*：英文版同类题目，测试国际竞赛适应力

---

## 7. 学习心得与经验分享
> **来自题解作者的经验**：
> - "处理$s=0$的边界情况容易被忽略，需单独判断"  
> - "Min25筛的分块大小显著影响性能，需根据$n$调整"
>
> **Kay的总结**：
> 1. **边界检查**：数论问题中0和1往往是陷阱源头
> 2. **调试技巧**：对拍小数据（如$n=19,s=8,t=10$）验证逻辑
> 3. **性能平衡**：暴力与筛法的分界点需反复测试优化

---

本次探索到此结束！记住：数论如繁花，虽复杂却有序。下次当你遇到$10^{11}$的巨人时，就用积性函数的利剑和筛法的盾牌去战胜它吧！💪

---
处理用时：211.74秒
# 题目信息

# 移言丁真：Unavoided linyue

## 题目背景

**注：你不需要阅读此题题目背景。**

"$\textsf{linyue}$" 是我起过的唯一一个人名，所以 $\textsf{linyue}$ 成了唯一一个由我想象出来的角色。她是我脑海中所有故事的主角，对我而言非常地重要，以至于不知道为什么，每次我看到她的名字被写出来或是被读出来都会感到无所适从，所以我总是会想办法避免这样，比如说这个题的题面里我就用的是拼音作代替。

“跑团”这种游戏我最初了解的时候简直是“绝望地想要跟不管是谁玩随便什么”。可是疫情却让我的好多和同学玩的计划纷纷泡汤，所以我甚至走投无路到把它也纳入了计划的考虑范畴，不过由于它实在是太复杂了，没过多久我就把它抛诸脑后了（

“黑影杀”是一款在泞之翼官方交流群里兴起的游戏，玩家将会探索《泞之翼》原作的旅馆，躲避黑影以求逃出生天——对我而言没有比这更完美的事了！它完全实现了我上一段里的愿望，只要一有空，我便可以在群里“开鲨”！我给这个游戏准备了便于主持的程序，写了许多特殊规则，甚至还以它为背景出了题——尽管这题投到的比赛咕了（

《怪商一克拉》是一部我很喜欢的漫画。它的特点就是主角好像在每段故事里都只会最小程度地完成任务，然后哪怕这个故事还有好多未解之谜都只会跳到下一段故事。尽管这看起来像是没写好，但我相信这种效果作者是刻意为之。所以我期待着在未来看到这些故事的伏笔被精妙地解决，带来一个震撼的结局。可是有一天，我没有在漫画派对上看到这部漫画。这意味着以上就都不会发生了……我当时心态崩了好长时间，甚至都到泞之翼群里发癫了，不过事实上作者只是请了一个月假，接下来这漫画还会照常更新（

前两天，我终于又找到机会和同学出去玩了！这一次我们打算上一个主营镜土 TRPG 的店里试试跑团。要知道，这对我而言还是很有吸引力的，因为之前不管是玩什么，都是"我"在玩，跟 $\textsf{linyue}$ 没有什么关系。但要是玩跑团做角色卡的话，是不是就能填补这个遗憾了呢？所以这次我是有备而来！我提前十分费力地给 $\textsf{linyue}$ 画了一张简单的画，然后输入名字的时候，我决定不再回避——用她那两个汉字的真名，而非六个字母的替代。

然而，尽管我这一天听到和看到她名字的次数前所未有，但最后却并没什么很好的效果。我在游戏里确实是主打一个不入戏，对话内容有种全人类取平均的美，没推理出什么剧情的关键，也没想到什么新奇的点子。相信把我换成 Kimi AI 游戏绝对会更有趣……

——不过当然啦，这倒也在我意料之中，因为我知道我本来就非常非常不擅长这种角色扮演……看来对我而言，创造 $\textsf{linyue}$ 的故事会比别人更加困难。

所以我不会太受这个问题的困扰，一是因为习惯了，二是因为——我们出题组的比赛没过审。

![](https://cdn.luogu.com.cn/upload/image_hosting/7qwdep44.png)

“移言丁真”是这场比赛的原定 E 题之一，可是它被鉴定为了典……显然这最主要是我的锅。所以我现在的当务之急是要想一个新的 idea……

## 题目描述

定义一个括号串的权值为其中可配对的括号组数。也就是你重复地在里面删除掉某个为 ```()``` 的子串，最多可以删除的次数。

你会遇到 $m$ 个括号串，第 $i$ 个的长度是 $l_i$。你可以将它们按照任意顺序连接起来，然后连成一个长的括号串，而你的目标就是让最终的串的权值最小。

如果这 $m$ 个串是等概率随机生成的，而你的操作是最优的，请你求出最终权值的期望。也就是说你要对于初始括号串的所有可能性求出最小权值的和再除以 $2^n$，$n$ 为这些字符串的总长。对 $10^9+7$ 取模。

## 说明/提示

**【样例解释1】**

这里 $\{S_1,S_2\}$ 表示两个括号串构成的无序可重集合，$P$ 表示取到这样集合的概率。

| $\{S_1,S_2\}$ | $P$ | 最优方案 | 权值 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $\{$```((```$,$```((```$\}$ | $\frac{1}{16}$ | ```((((``` | $0$
| $\{$```((```$,$```()```$\}$ | $\frac{1}{8}$ | 任意 | $1$
| $\{$```((```$,$```)(```$\}$ | $\frac{1}{8}$ | ```)(((``` | $0$
| $\{$```((```$,$```))```$\}$ | $\frac{1}{8}$ | ```))((``` | $0$
| $\{$```()```$,$```()```$\}$ | $\frac{1}{16}$ | ```()()``` | $2$
| $\{$```()```$,$```)(```$\}$ | $\frac{1}{8}$ | 任意 | $1$
| $\{$```()```$,$```))```$\}$ | $\frac{1}{8}$ | 任意 | $1$
| $\{$```)(```$,$```)(```$\}$ | $\frac{1}{16}$ | ```)()(``` | $1$
| $\{$```)(```$,$```))```$\}$ | $\frac{1}{8}$ | ```)))(``` | $0$
| $\{$```))```$,$```))```$\}$ | $\frac{1}{16}$ | ```))))``` | $0$

最终答案为 $\dfrac{9}{16}$。

**【数据范围】**

令 $n$ 为 $l_i$ 的总和。

子任务 $1$（$20$ 分）: $n \le 20$。

子任务 $2$（$30$ 分）: $n \le 5000$。

子任务 $3$（$50$ 分）: $n \le 4000000$。

保证 $l_i \ge 1$。

**【后记】**

左括号和右括号可以是 $\textsf{linyue}$ 名字的第一个字和第二个字，也可以是一段故事的萌芽和结果。

下一次跑团遥遥无期，黑影杀渐渐无人问津，我们团的三个原定 E 题和其他好多好多的 idea 不知道何去何从，那些和 $\textsf{linyue}$ 有关的故事和设想更是也难以被呈现。有时我感觉自己就像是在《怪商一克拉》里一样，好多段经历都没等到自己的右括号，有种被最小化了权值的美。所以，我总是期待这些故事的伏笔被精妙地解决，带来最大的幸福。不过在这之前，我只好继续回避 “$\textsf{linyue}$” 了。

## 样例 #1

### 输入

```
2
2 2```

### 输出

```
62500001```

## 样例 #2

### 输入

```
5
1 2 3 4 5```

### 输出

```
762695321```

# AI分析结果


### 💡 Kay的C++算法解析：移言丁真 深入学习指南 💡

#### **1. 题目解读与核心算法识别**
✨ **本题主要考察**：组合数学与概率期望  
🗣️ **初步分析**：  
> 本题核心是将括号序列转化为格路模型（左括号为+1，右括号为-1），通过路径分析计算最小括号匹配数。  
> - **关键技巧**：定义每个串的起点高度差 `d = |左括号数 - 右括号数|` 和最低点参数 `min(L,R)`。最终权值 = 所有串 `d` 之和 + 2 × `max(min(L_i,R_i))`。  
> - **难点**：需高效计算 `d` 的期望和 `max(min(L,R))` 的概率分布，涉及组合数前缀和与反射原理。  
> - **可视化设计**：采用8位像素风格展示格路行走过程：  
>   - 左/右括号显示为↑/↓像素箭头，路径颜色随高度变化  
>   - 关键帧高亮最低点位置，`min(L,R)` 达标时播放胜利音效  
>   - 控制面板支持单步调试和自动播放（调速滑块）

---

#### **2. 精选优质题解参考**
**题解一（Anoshag_Ruwan）**  
* **点评**：思路清晰，直接推导 `min(L,R)` 的概率分布公式，利用组合恒等式优化计算。代码简洁高效（O(n)），变量命名规范（`c1[]` 存储前缀和），边界处理严谨。亮点在于反射原理的巧妙应用和杨辉三角优化。  

**题解二（DaiRuiChen007）**  
* **点评**：分步骤拆解期望计算，教学性强。代码模块化（`mut()`封装连乘），组合数预计算提升效率。亮点在于概率乘积的递推式解释，但变量命名稍显抽象（如`ca[]`）。  

**题解三（EuphoricStar）**  
* **点评**：推导最简洁，直接给出 `Pr(min≥k)` 的组合数表达式。代码可读性好（`C()`组合数函数封装），但未完全优化前缀和计算。  

---

#### **3. 核心难点辨析与解题策略**
1. **难点1：参数定义与权值拆分**  
   * **分析**：每个串需计算 `d = |L-R|` 和 `m = min(L,R)`。权值拆为 `Σd + 2×max(m)` 是关键，优质题解均通过格路模型严格证明。  
   * 💡 **学习笔记**：括号匹配问题常转化为路径最值问题。  

2. **难点2：期望概率的高效计算**  
   * **分析**：`E(d)` 可通过左/右括号数差直接计算；`E(max(m))` 需用 `1 - Π(1-Pr(m_i≥k))` 转化，利用组合数后缀和递推。  
   * 💡 **学习笔记**：概率乘积的独立性是优化复杂度的核心。  

3. **难点3：组合数前缀和优化**  
   * **分析**：`Pr(m≥k)` 可表示为 `ΣC(n, k+i)` 的线性组合。Anoshag_Ruwan 的杨辉三角移动指针法（`ck[]`数组）是空间优化典范。  
   * 💡 **学习笔记**：大范围组合数计算需预处理的阶乘/逆元。  

### ✨ 解题技巧总结
- **模型转化**：括号序列 → 格路路径 → 数学期望  
- **分治拆解**：将复合期望拆为独立子问题  
- **预处理优化**：阶乘/组合数预计算避免重复  
- **边界特判**：奇偶路径分开处理（`m&1` 分支）  

---

#### **4. C++核心代码实现赏析**
**通用核心实现参考**  
* **说明**：综合优质题解，预计算阶乘/逆元 + 双指针维护组合数前缀和  
* **完整核心代码**：  
  ```cpp
  #include <bits/stdc++.h>
  const int MAXN=4e6+5, MOD=1e9+7;
  ll fac[MAXN], inv[MAXN], ipw[MAXN]={1}, ans=0;

  void precalc(int n) { // 预处理阶乘和逆元
    fac[0]=1;
    for(int i=1; i<=n; ++i) {
      fac[i] = fac[i-1]*i % MOD;
      ipw[i] = ipw[i-1]*(MOD+1)/2 % MOD; // 2^{-i}
    }
    inv[n] = pow(fac[n], MOD-2);
    for(int i=n; i; --i) inv[i-1] = inv[i]*i % MOD;
  }

  int main() {
    int m, total_len=0;
    std::cin >> m;
    std::vector<int> lens(m);
    for(auto &x: lens) {
      std::cin >> x;
      total_len += x;
    }
    precalc(total_len);
    // 计算ΣE(d)和E(max(m)) (见下方片段)
    std::cout << (total_len - ans) * (MOD+1)/2 % MOD;
  }
  ```
* **代码解读概要**：  
  > 1. 预处理阶乘/逆元加速组合数计算  
  > 2. `ipw[]` 存储 2^{-i} 避免重复幂运算  
  > 3. 分两阶段计算：`ΣE(d)` 直接枚举括号差，`E(max(m))` 用双指针维护组合数前缀和  

---

**题解一片段赏析（Anoshag_Ruwan）**  
* **亮点**：杨辉三角移动指针法，O(n) 空间计算后缀和  
* **核心代码**：  
  ```cpp
  for(int i=0, j=1; i<max_k; i++) {
    while(lens[j] <= i) j++;  // 移动指针到有效区间
    ll prod = 1;
    for(int h=j; h<=m; h++)   // 所有长度≥i的串
      prod = prod * C(2*lens[h]+1, lens[h]+i+1) % MOD;
    ans += (1 - prod);        // 累加E(max(m))
  }
  ```
* **代码解读**：  
  > - `i` 遍历 `min(L,R)` 的可能值，`j` 指针跳过长度不足的串  
  > - `C(2l+1, l+i+1)` 是 `Pr(m≥i)` 的组合数核心项  
  > - 乘积 `prod` 对应 `Π(1-Pr(m≥i))`，用 `1-prod` 更新期望  
* 💡 **学习笔记**：指针移动避免无效计算是线性复杂度关键  

**题解二片段赏析（DaiRuiChen007）**  
* **亮点**：概率乘积分治策略，代码模块化  
* **核心代码**：  
  ```cpp
  vector<ll> p(max_k, 1); // p[k] = Π(1-Pr(m_i≥k))
  for(int x: lens) {
    ll w = 0;
    for(int i=0; i<=x/2; i++)   // 计算后缀和
      w = (w + C(2*x+1, x+i+1)*ipw[2*x]) % MOD;
    for(int k=0; k<max_k; k++)
      p[k] = p[k] * w % MOD;     // 更新概率乘积
  }
  ```
* 💡 **学习笔记**：概率独立时可分离计算，减少重复  

---

#### **5. 算法可视化：像素动画演示**
* **主题**：8位机风格《括号探险家》  
* **核心演示**：括号序列 → 格路路径 → 标记 `L/R/d` 参数  

| **关键帧** | **视觉效果** | **交互逻辑** |  
|------------|--------------|--------------|  
| **初始化** | 像素网格（16色），左侧显示括号串，右侧画路径 | 按串长度生成随机括号序列 |  
| **路径绘制** | ↑/↓箭头代表括号，路径颜色随y值变化（蓝→红→绿） | 空格单步执行，Enter自动播放（可调速） |  
| **关键参数** | 起点/终点标 `L/R` 值，最低点闪烁黄光 | 点击路径节点显示当前高度 |  
| **结果计算** | `min(L,R)≥k` 时播放胜利音效，路径变金色 | 实时更新 `Σd` 和 `max(m)` 的数值 |  

**技术实现**：  
- **Canvas绘制**：用 `fillRect()` 绘制像素路径，`requestAnimationFrame` 驱动动画  
- **音效**：Web Audio API 播放8位音效（入队↑音，匹配✓音）  
- **游戏化**：每正确计算一个串得1分，连续正确触发连击特效  

---

#### **6. 拓展练习与相似问题思考**
* **技巧迁移**：  
  1. 格路模型：解决卡特兰数相关问题  
  2. 期望线性性：处理带权随机过程  
  3. 组合数前缀和：优化概率类问题  
* **推荐题目**：  
  1. [洛谷 P1044](https://www.luogu.com.cn/problem/P1044)：栈序列计数（格路基础）  
  2. [洛谷 P1654](https://www.luogu.com.cn/problem/P1654)：期望线性性经典应用  
  3. [洛谷 P3339](https://www.luogu.com.cn/problem/P3339)：反射原理强化训练  

---

#### **7. 学习心得与经验分享**
> **作者经验（Anoshag_Ruwan）**：  
> *“组合恒等式推导时，先写小规模案例验证，避免符号错误。杨辉三角性质节省了80%计算量！”*  
> **Kay点评**：测试驱动开发（TDD）思想在算法中同样重要，先验证 n=3,4 的边界情况再推广。  

---

> 掌握括号匹配的格路转化与期望拆分，你就能解决这类问题！下次遇到组合期望题，记得先拆解独立子问题哦~ 💪

---
处理用时：117.18秒
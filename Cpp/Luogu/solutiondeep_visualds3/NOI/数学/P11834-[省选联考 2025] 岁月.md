# 题目信息

# [省选联考 2025] 岁月

## 题目背景

> 希望大家一直记得我。  
> “希望大家永远忘了我。”

## 题目描述

小 Y 有一个 $n$ 个节点、$m$ 条边的带权**无向图** $G$，节点由 1 至 $n$ 编号。第 $i$ ($1 \leq i \leq m$) 条边连接 $u_i$ 和 $v_i$，边权为 $w_i$。保证 $G$ 连通且没有重边自环。

小 Y 预见到岁月将会磨灭图 $G$ 的痕迹，而这会导致一些边变成有向边，另一些边直接消失。具体地，图 $G$ 历经岁月将会磨损为 $n$ 个节点的带权**有向图** $G'$，其中对于第 $i$ ($1 \leq i \leq m$) 条边，$G'$ 上
- 有 $\frac{1}{4}$ 的概率同时存在 $u_i$ 向 $v_i$ 和 $v_i$ 向 $u_i$ 的有向边，它们的边权均为 $w_i$;
- 有 $\frac{1}{4}$ 的概率存在 $v_i$ 向 $u_i$、边权为 $w_i$ 的有向边，而不存在其反向边;
- 有 $\frac{1}{4}$ 的概率存在 $u_i$ 向 $v_i$、边权为 $w_i$ 的有向边，而不存在其反向边;
- 有 $\frac{1}{4}$ 的概率 $u_i$ 和 $v_i$ 之间没有边。

所有 $m$ 个随机事件是独立的。

小 Y 认为一个无向图的核心是最小生成树，而一个有向图的核心是最小外向生成树。称图 $G'$ 的一个边子集 $E$ 是**外向生成树**，当且仅当 $|E| = n - 1$ 且存在一个节点 $x$ 可以只经过 $E$ 中的有向边到达图 $G'$ 上的所有节点。图 $G'$ 的**最小外向生成树**即为图 $G'$ 上边权和最小的外向生成树。

小 Y 希望图的核心历经岁月侵蚀也保持不变，于是他想知道，有多大的概率，图 $G'$ 的最小外向生成树存在，且其边权和等于图 $G$ 的最小生成树边权和。

你需要将答案对 $(10^9 + 7)$ 取模。可以证明答案一定为有理数 $\frac{a}{b}$，其中 $a$ 和 $b$ 互质，且 $b$ 不是 $(10^9 + 7)$ 的倍数。因此你输出的数 $x$ 需要满足 $0 \leq x < 10^9 + 7$ 且 $a \equiv bx \pmod{10^9 + 7}$，可以证明这样的 $x$ 唯一存在。

## 说明/提示

**【样例 1 解释】**

该组样例共有 2 组测试数据。
- 对于第一组测试数据，由于图上只有一条边，因此只要 $G'$ 上有边，$G'$ 的最小外向生成树边权和就一定等于 $G$ 的最小生成树边权和。$G'$ 上存在边的概率为 $\frac{3}{4}$，故答案为 $\frac{3}{4}$，取模后的结果为 $750\,000\,006$。
- 对于第二组测试数据，在所有 $2^{2m} = 64$ 种 $G'$ 中，有 13 种情况不满足 $G'$ 的最小外向生成树边权和等于 $G$ 的最小生成树边权和：
 - $G'$ 为空图;
 - $G'$ 仅包含一条有向边，共 6 种情况;
 - $G'$ 仅包含两条有向边，且指向同一个节点，共 3 种情况;
 - $G'$ 仅包含两条有向边，且构成一个二元环，共 3 种情况。

由于所有情况等概率出现，因此答案为 $1 - \frac{13}{64} = \frac{51}{64}$，取模后的结果为 $171\,875\,002$。

**【样例 2】**

见选手目录下的 `years/years2.in` 与 `years/years2.ans`。

该组样例共有 5 组测试数据。其中每组测试数据分别满足测试点 $1 \sim 3$、$4 \sim 6$、$7,8$、$9 \sim 11$、$12,13$ 的限制。

**【样例 3】**

见选手目录下的 `years/years3.in` 与 `years/years3.ans`。

该组样例共有 5 组测试数据。其中每组测试数据分别满足测试点 $14 \sim 16$、$17, 18$、$19, 20$、$21 \sim 23$、$24, 25$ 的限制。

**【子任务】**

对于所有测试点，
- $1 \leq T \leq 5$,
- $2 \leq n \leq 15$, $n - 1 \leq m \leq \frac{n(n-1)}{2}$,
- $\forall 1 \leq i \leq m$, $1 \leq u_i < v_i \leq n$, $1 \leq w_i \leq m$,
- $\forall 1 \leq i < j \leq m$, $(u_i, v_i) \neq (u_j, v_j)$，即 $G$ 没有重边，
- 保证 $G$ 连通。

::cute-table{tuack}

| 测试点编号 | $n \leq$ | 特殊性质 |
|:------------:|:------------:|:----------:|
| $1 \sim 3$ | $6$ | A |
| $4 \sim 6$ | $15$ | B |
| $7, 8$ | $9$ | C |
| $9 \sim 11$ | $12$ | ^ |
| $12, 13$ | $14$ | ^ |
| $14 \sim 16$ | $15$ | ^ |
| $17, 18$ | $9$ | 无 |
| $19, 20$ | $12$ | ^ |
| $21 \sim 23$ | $14$ | ^ |
| $24, 25$ | $15$ | ^ |

- 特殊性质 A：$m \leq 6$, $\forall 1 \leq i \leq m$, $w_i \leq 2$。
- 特殊性质 B：$\forall 1 \leq i < j \leq m$, $w_i \neq w_j$。
- 特殊性质 C：$\forall 1 \leq i \leq m$, $w_i = 1$。

## 样例 #1

### 输入

```
0 2
2 1
1 2 1
3 3
1 2 2
1 3 2
2 3 2```

### 输出

```
750000006
171875002```

# AI分析结果


### 💡 Kay的C++算法解析：岁月 深入学习指南 💡

#### **1. 题目解读与核心算法识别**
✨ **本题主要考察**：**状压DP + 图论计数**（结合概率论与容斥原理）

🗣️ **初步分析**：
> 解决"岁月"题目的核心在于**分层处理+Kruskal重构思想**。算法将原图按边权分层，在每层合并连通块时维护"合法根集"（可作为最小外向生成树根的点集）。关键技巧包括：
> - **分层处理**：模拟Kruskal过程，按边权升序处理，维护连通块合法性。
> - **容斥原理**：处理强连通分量计数（类似[主旋律](https://www.luogu.com.cn/problem/P11714)），避免重复计算。
> - **状态压缩**：用位运算表示点集，优化DP过程。
> - **概率独立事件分离**：将合法条件分解为强连通、可达性、无入边三部分独立计算概率。

**可视化设计思路**：
- **像素网格**：15×15网格表示节点（复古8位风格），不同颜色区分连通块。
- **分层动画**：边权层像"俄罗斯方块"下落，当前处理层高亮闪烁（红色边框）。
- **根集标记**：合法根节点显示为🌟图案，合并时🌟图案融合并播放"叮"音效。
- **DP状态转移**：网格分裂/合并动画，容斥过程用"暗化非法区域+错误音效"表示。

---

#### **2. 精选优质题解参考**
**题解一：chenxinyang2006（赞53）**  
* **亮点**：  
  - **分层最优解**：按边权分层处理，将问题分解为多个边权相同的子问题（C性质）。  
  - **容斥优化**：设计`res[S]`状态表示点集S为合法根集的概率，转移用容斥避免重复计算。  
  - **复杂度优化**：预处理转移系数，时间复杂度$O(3^n)$，空间优化到位。  
  - **实践价值**：代码可直接用于竞赛，边界处理严谨（如连通块未变化时的剪枝）。

**题解二：CarroT1212（赞32）**  
* **亮点**：  
  - **概率分离术**：将合法条件拆解为三独立事件（强连通/可达性/无入边），逻辑清晰。  
  - **转置DP技巧**：将可达性DP转置计算，复杂度从$O(4^n)$降至$O(3^n)$。  
  - **代码规范**：变量名`f_S`、`g_T`含义明确，模块化封装易于调试。  

**题解三：20_200（赞10）**  
* **亮点**：  
  - **树形结构分析**：将连通块合并视为树形结构，证明总复杂度为$O(3^n)$。  
  - **合法根集传递性**：新根集由子连通块根集并集产生，设计简洁。  
  - **实战参考**：提供Kruskal重构思想的完整实现框架。

---

#### **3. 核心难点辨析与解题策略**
1. **难点1：合法根集的动态维护**  
   * **分析**：合并连通块时，新根集需由原子块的合法根集生成，需保证强连通性。优质题解用**位运算+容斥**处理，如`res[S] = ans_S × 2^{-cnt_S} × tf_S`（乘积即三独立事件概率）。
   * 💡 **学习笔记**：合法根集是分层DP的灵魂，本质是"当前连通块可作为MOST根的点集"。

2. **难点2：强连通分量的高效计数**  
   * **分析**：借鉴[主旋律]的容斥思路，设计$g_S$表示S划分为SCC的带权求和（容斥系数$(-1)^{k+1}$）。转移时用`lowbit`优化枚举子集。
   * 💡 **学习笔记**：强连通计数需配合"无入边"条件，用$2^{-E(U\S,S)}$计算概率。

3. **难点3：复杂度优化**  
   * **分析**：连通块未变化时跳过计算，使总复杂度收敛于$O(3^n)$而非$O(3^n n)$。
   * 💡 **学习笔记**：树形合并+剪枝是突破$n \leq 15$的关键。

✨ **解题技巧总结**：
- **技巧1：分层抽象法** → 将MST条件转化为分层连通性维护。
- **技巧2：容斥三件套** → 强连通计数用$f_S = 2^{e_S} - \sum g_T \cdot 2^{e_{S-T}}$。
- **技巧3：转置DP** → 倒序计算贡献系数，避免重复枚举。
- **技巧4：独立事件分离** → 将概率拆解为互斥部分乘积（强连通×可达性×无入边）。

---

#### **4. C++核心代码实现赏析**
**本题通用核心实现**（综合自优质题解）：
```cpp
const int N=15, P=1e9+7;
int dp[1<<N], res[1<<N], sum[1<<N]; // dp:连通块状态, res:合法根集概率
vector<Edge> e_by_w; // 按边权分组的边

void merge_blocks(int w) {
    for (auto &block : blocks) { // 遍历当前层连通块
        int mask = block.mask();
        memset(new_res, 0, sizeof new_res);
        for (int S = mask; S; S = (S-1)&mask) {
            // 容斥计算新res[S]（强连通+可达性+无入边）
            int prob = calc_scc(S) * calc_reach(S) % P;
            prob = prob * calc_no_in_edge(S) % P;
            new_res[S] = prob;
        }
        res = new_res; // 更新合法根集概率
    }
}
```
**题解一核心片段赏析**：
```cpp
// 计算强连通概率（主旋律思想）
for (int s = mask; s; s = (s-1)&mask) {
    g[s] = -g[s ^ lowbit(s)]; // 容斥系数初始化
    for (int t = (s-1)&s; t; t = (t-1)&s) {
        if (t & lowbit(s)) {
            g[s] -= f[t] * g[s^t] * inv_pow[cross(t, s^t)];
        }
    }
    f[s] = total_edges - g[s]; // 强连通方案数
}
```
> **代码解读**：  
> - `g[s]`：容斥系数，存储划分SCC的带权和（奇负偶正）。  
> - `f[s]`：s强连通的概率，用总方案减去非法划分。  
> - `inv_pow`：预处理的$2^{-k}$，避免重复计算幂次。  
> 💡 **学习笔记**：容斥系数是强连通计数的精髓，配合`lowbit`枚举子集优化速度。

---

#### **5. 算法可视化：像素动画演示**
**设计主题**：**"像素探险家：连通块大冒险"**（8位FC风格）  
**核心演示**：分层合并连通块 + 合法根集传递过程  

| **动画帧** | **关键操作** | **音效/视觉反馈** |
|------------|--------------|-------------------|
| **1. 初始化** | 显示15×15像素网格，节点为彩色方块，边权用颜色深度表示 | 8位背景音乐循环播放 |
| **2. 分层处理** | 当前边权层（如w=2）从顶部下落，覆盖相关边 | "叮"音效 + 黄色闪烁边框 |
| **3. 连通块合并** | 连通块收缩为单个色块，新根集🌟图案融合 | "融合"像素动画 + 上升音阶 |
| **4. 容斥处理** | 非法状态区域变暗（如非强连通块） | "错误"短促音效 + 红色闪烁 |
| **5. 根集更新** | 新合法根集显示为🌟，动态连接其他节点 | "星光"粒子特效 + 胜利音效 |
| **6. 自动演示** | 调速滑块控制层处理速度，实时显示DP状态 | 每步显示当前伪代码行 |

**交互设计**：
- **控制面板**：开始/暂停 + 单步执行 + 速度滑块（0.5x~3x）。
- **数据结构可视化**：连通块用堆叠方块表示，根集用🌟标记。
- **伪代码同步**：右侧显示当前步骤对应的核心代码（如`g[s] -= f[t] * ...`）。

---

#### **6. 拓展练习与相似问题思考**
**通用技巧迁移**：  
> 本题的**状压DP+容斥+分层处理**技巧可用于：  
> 1. 有向图生成树计数（[P11714 主旋律](https://www.luogu.com.cn/problem/P11714)）  
> 2. 最小生成树计数（[P4208 最小生成树计数](https://www.luogu.com.cn/problem/P4208)）  
> 3. 概率图论问题（如随机删边后连通性）  

**洛谷推荐**：  
1. **P11714 [省选联考] 主旋律**  
   → 强化强连通容斥计数技巧，本题核心前置。  
2. **P4208 [JSOI2010] 最小生成树计数**  
   → 练习分层处理与连通性维护。  
3. **P10982 [THUPC 2024] 重塑时光**  
   → 拓展DAG计数与概率融合技巧。  
4. **P2567 [SCOI2010] 幸运数字**  
   → 容斥原理的另一种经典应用场景。  

---

#### **7. 学习心得与经验分享**
> **经验摘录**（来自chenxinyang2006）：  
> *"调试时重点验证三层：1) 分层边权处理是否正确 2) 容斥系数符号 3) 独立事件概率分离。我在强连通容斥中因符号错误卡了3小时，最终通过小规模暴力对比发现。"*  
>  
> **Kay点评**：  
> 调试状压DP时，**暴力验证小数据**（n≤4）是关键。建议：  
> 1. 打印每一步的`res[S]`，对比手算结果。  
> 2. 对非法状态添加`assert`（如`S`非空却`res[S]>0`）。  
> 3. 预计算`2^{-k}`避免浮点误差。  

---

> 算法世界如岁月长河，**分层处理**是穿越迷雾的舟，**容斥原理**是暗夜的灯塔，**状态压缩**是手中的利剑。掌握这三者，你便能驾驭"岁月"之题，在省选的浪潮中破浪前行！🚤💨

---
处理用时：174.49秒
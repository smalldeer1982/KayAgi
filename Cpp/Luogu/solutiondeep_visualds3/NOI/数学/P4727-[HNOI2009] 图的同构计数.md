# 题目信息

# [HNOI2009] 图的同构计数

## 题目背景

当学生们遇到某个难题时经常会说“这怎么做，这不是 NP 问题吗？”、“这个只有搜了，这己经被证明是 NP 问题了”。但是，你应该清楚，大多数人此时所说的 NP 问题其实都是指 NPC 问题。很多人没有真正掌握 NP 问题和 NPC 问题这两个基本概念。其实 NP 问题并不是那种“只有搜才行”的问题，NPC 问题才是。

很久以前就有一个古老的传说：有―个著名的问题，即 P 是否等于 NP 的问题，传说中谁要是证明或者证伪了这个命题，他将获得幸福。这里 P 是指能在多项式时间里求解的问题的集合。而 NP 是指可在多项式时间里验证的问题的集合。显然 P 是 NP 的子集，因为能在多项式时间里求解的问题，必定可在多项式时间里验证。

到目前为止还没有人因这个命题得到幸福。但是，有一个总的趋势，也就是人们普遍认为，$P=NP$ 不成立，即，多数人相信，至少存在一个不可能有多项式时间复杂度的求解算法的 NP 问题。人们如此坚信 $P \neq NP$ 是有原因的，因为在研究 NP 问题的过程中找出了一类非常特殊的 NP 问题叫做 NP-完全问题，也就是所谓的 NPC 问题。正是因为存在 NPC 问题，才使人们相信 $P \neq NP$。

在提出 NPC 的概念之后，绝大多数“自然”的难题最后都被证明是 NPC 问题，只有三个例外，它们分别是：

- 线性规划问题；
- 图同构问题；
- 素数判定问题与大数分解问题。

## 题目描述

小雪在了解到以上情况后，自认为直接挑战终极难题还有不少困难，于是决定先从简单的问题做起，具体来说，他对图同构问题产生了浓厚的兴趣。$A$ 图与 $B$ 图被认为是同构的是指：$A$ 图的顶点经过一定的重新标号以后，$A$ 图的顶点集和边集要完全与 $B$ 图一一对应。

小雪现在专注于如何判断两个图是否同构，同时他还想知道两两互不同构的含 $N$ 个点的图有多少种。众所周知含 $N$ 个点的简单图最多有 $N\times(N-1)/2$ 条边，这样含 $N$ 个点的图有 $2^{N\times(N-1)/2}$ 种可能的情况。显然这些图中有很多图是同构的，小雪想知道的便是：若同构的图算成一种，则有多少种不同的图。他把这个任务丢给了你，在他想出来之前快点解决吧！

## 说明/提示

对于 $40 \%$ 的数据，$N \le 20$。  
对于 $100 \%$ 的数据，$0 \le N \le 60$。

## 样例 #1

### 输入

```
1```

### 输出

```
1```

## 样例 #2

### 输入

```
2```

### 输出

```
2```

## 样例 #3

### 输入

```
3```

### 输出

```
4```

## 样例 #4

### 输入

```
5```

### 输出

```
34```

## 样例 #5

### 输入

```
9```

### 输出

```
493```

# AI分析结果


# 💡 Kay的C++算法解析：图的同构计数 深入学习指南 💡

> "想象你有无限积木盒，每块积木代表不同形状的图。Burnside引理就是帮你数出真正不同的积木有多少的魔法公式！" —— Kay

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`Burnside引理与组合数学` 

🗣️ **初步分析**：
> 本题本质是计算**图的同构类数量**，核心在于理解**置换群对图空间的作用**。好比用不同角度旋转观察积木塔，统计真正不同的塔型。Burnside引理的精妙在于将复杂对称性计数转化为置换不动点平均值的计算。

- **核心难点**：直接枚举所有$n!$置换不可行，需通过**整数拆分**分类置换类型
- **关键突破**：发现置换对边集的等价类划分公式 $k = \sum \lfloor b_i/2 \rfloor + \sum \gcd(b_i,b_j)$
- **优化策略**：DFS枚举拆分方案，利用组合公式计算同类置换数量

> **可视化设计思路**：采用8位像素风格展示置换作用过程——顶点循环显示为彩色圆环，边等价类用同色像素段表示。当自动播放时，高亮当前处理的循环对，伴随"滴"声标记新等价类生成，最终以胜利音效庆祝计数完成。

---

## 2. 精选优质题解参考

**题解一：pythoner713 (5星)**
* **点评**： 
  以生动比喻解释Burnside引理（如旋转对称性），完整推导边等价类公式，给出清晰数学证明。代码中`work()`函数封装k值计算，`dfs`枚举拆分逻辑简洁。亮点在于拓展到m染色问题，体现强迁移性。调试心得强调"等价类划分是核心"，对理解群作用具启发性。

**题解二：yybyyb (5星)**
* **点评**：
  代码实现高效，预处理阶乘与逆元提升性能。亮点在`get_answer()`中组合贡献计算：用`val[]`存储循环长度，双重循环计算gcd贡献。边界处理严谨（`num[1]=n-s`），实践价值高。虽未提及调试经验，但代码结构本身可作为模板参考。

**题解三：lightmain (4.5星)**
* **点评**：
  题解结构清晰，分步论证置换与边等价类关系。核心代码`calc()`严格遵循公式，`b[]`数组统计长度频次避免重复计算。学习价值在于显式处理`c_i!`的细节，体现组合数学精髓。变量命名`fac,invfac`规范易读。

---

## 3. 核心难点辨析与解题策略

### 🔑 难点1：置换群到边等价类的映射
**分析**：如何将顶点置换转化为边集作用？优质解法定理证明结合几何直观：同一循环内边按长度划分等价类（正多边形旋转），跨循环边按gcd周期分组。

💡 **学习笔记**：边等价类数k = 循环内贡献($\lfloor b/2 \rfloor$) + 循环间贡献($\gcd(b_i,b_j)$)

### 🔑 难点2：置换类型的组合计数
**分析**：给定拆分$b_1,\dots,b_m$，计算同类置换数量需考虑：①循环内圆排列方案 ②相同长度循环的不可区分性。通解公式：$\frac{n!}{\prod b_i \prod c_i!}$

💡 **学习笔记**：组合因子 = 分配位置方案 / (循环长度积 × 同长循环阶乘)

### 🔑 难点3：高效枚举整数拆分
**分析**：DFS枚举需避免重复，如按非降序枚举循环长度。优化点包括：预计算gcd表、模逆元加速除法。

💡 **学习笔记**：DFS状态设计(当前长度, 剩余点数, 前次长度)保证拆分有序性

### ✨ 解题技巧总结
1. **群论转化**：将同构计数转为置换群作用下轨道计数
2. **公式分解**：$k = \sum \lfloor b_i/2 \rfloor + \sum_{i<j} \gcd(b_i,b_j)$
3. **组合优化**：预计算阶乘/逆元，gcd表空间换时间
4. **边界处理**：DFS中sum==n时立即计算贡献
5. **拓展迁移**：修改公式中2为m即得有色图版本

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现
```cpp
#include <iostream>
#define MOD 997
using namespace std;

int n, ans, gcd[61][61], fac[61] = {1}, inv[61];

int qpow(int base, int exp) { // 快速幂模M
    int res = 1;
    for (; exp; exp >>= 1, base = base * base % MOD)
        if (exp & 1) res = res * base % MOD;
    return res;
}

void dfs(int len, int last, int rem, int prod = 1, int sum_k = 0) {
    if (!rem) { // 拆分完成
        ans = (ans + qpow(2, sum_k) * qpow(prod, MOD - 2)) % MOD;
        return;
    }
    for (int i = last; i <= rem; ++i) {
        int new_prod = prod * i % MOD, new_k = sum_k + i/2;
        for (int j = 1; j < len; ++j) new_k += gcd[i][b[j]];
        b[len] = i; // 记录当前循环长度
        dfs(len + 1, i, rem - i, new_prod, new_k);
    }
}

int main() {
    cin >> n;
    // 预处理：阶乘、逆元、gcd表
    for (int i = 1; i <= n; ++i) {
        fac[i] = fac[i-1] * i % MOD;
        inv[i] = qpow(i, MOD - 2);
        for (int j = 1; j <= n; ++j)
            gcd[i][j] = __gcd(i, j);
    }
    dfs(1, 1, n);
    cout << ans;
}
```

**代码解读概要**：
1. 预计算阶乘/逆元表加速组合计算
2. DFS按非降序枚举拆分，保证不重复
3. `prod`累积$\prod b_i$，`sum_k`累积k值
4. 终止时用费马小定理计算$\frac{2^k}{\prod b_i}$
5. 主函数初始化后启动DFS

---

### 优质题解片段赏析

**题解一：pythoner713**
```cpp
void work(int len){
    int u = 0; // k值
    for(int i = 1; i <= len; i++){
        u += b[i] >> 1; // 同一循环内贡献
        for(int j = 1; j < i; j++) // 跨循环贡献
            u += gcd(b[i], b[j]);
    }
    ans = (ans + inv[prod] * qpow(2, u)) % MOD;
}
```
**亮点**：k值计算封装独立，逻辑隔离清晰  
**学习笔记**：循环内贡献与跨循环贡献分离计算，避免耦合

**题解二：yybyyb**
```cpp
for(int i=1;i<=tot;++i){
    sum += val[i]/2; // val[i]存储循环长度
    for(int j=i+1;j<=tot;++j)
        sum += gcd(val[i], val[j]);
}
```
**亮点**：双重循环计算gcd贡献，val数组化循环为序列  
**学习笔记**：将循环长度展平为数组，统一处理跨循环贡献

**题解三：lightmain**
```cpp
for(int i=1, j; i<=len;){
    for(j=i; b[i]==b[j] && j<=len; j++);
    v = v * fac[j-i] % MOD; // 处理同长循环的c_i!
    i = j;
}
```
**亮点**：高效计算$\prod c_i!$，避免额外存储频次表  
**学习笔记**：扫描连续相同长度段，直接计算阶乘贡献

---

## 5. 算法可视化：像素动画演示

### 像素探险：置换作用下的边等价类生成

![](https://fakeimg.pl/400x200/FFD700/000/?text=置换分解演示&font_size=20)  
*图：循环分解的像素表示（FC红白机风格）*

**设计思路**：  
用复古像素风格动态演示置换对边集的划分过程，帮助理解k值计算原理。将抽象群论转化为可视的图形操作。

**动画帧步骤**：
1. **初始化**：16色调色板，顶点显示为8位像素小人，网格化完全图
2. **置换分解**：当前置换分解为循环，同循环顶点同色（如红/蓝/绿）
   - 音效：循环生成时播放"叮咚"声
3. **边等价类生成**：
   - *循环内边*：正多边形旋转演示，同长度边闪烁后染同色（黄/紫）
     - 音效：每组标记时短促"滴"声
   - *循环间边*：两循环间画虚线，按gcd值分组染色（青/橙）
     - 特效：高亮当前处理的循环对
4. **结果展示**：显示最终k值与公式，放烟花庆祝
   - 音效：胜利旋律（《超级玛丽》过关音效）

**交互控制**：
- 速度滑块：调节动画帧间隔（100ms~2s）
- 单步执行：空格键步进关键步骤
- 模式切换：A键切换自动演示/手动控制

**技术实现**：
```javascript
// 伪代码：绘制循环内边等价类
function drawInnerCycle(vertices) {
  const colors = [/* 16色值 */]; 
  for (let dist = 1; dist <= vertices.length/2; dist++){
    drawDashedRing(vertices, dist, colors[dist]); // 绘制虚线环
    playSound('beep'); // 播放提示音
  }
}
```

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**：  
Burnside引理可扩展至任意染色问题，关键步骤：
1. 定义作用在对象上的置换群
2. 分析置换对染色方案的等价类划分
3. 通过整数拆分优化计数

**洛谷推荐**：
1. **P4128 有色图**  
   🗣️ *推荐理由*：本题的泛化版本（m种颜色），直接应用相同解题框架，巩固Burnside应用。
   
2. **P2567 幸运数字**  
   🗣️ *推荐理由*：考察组合计数与整数拆分技巧，训练DFS枚举拆分的实现能力。

3. **P1446 卡牌染色**  
   🗣️ *推荐理由*：更基础的Burnside应用，帮助理解置换群与轨道计数思想。

---

## 7. 学习心得与经验分享

> **作者pythoner713的经验**：  
> *"边等价类的划分是解题核心，想象完全图被置换撕裂成彩色碎片的过程——每个碎片必须是纯色的！"*

**Kay的总结**：  
本题调试关键在验证k值计算：  
1. 小数据（n=3）手工计算所有置换验证公式  
2. 输出中间拆分方案，检查gcd贡献累计  
3. 模运算中除法必须转为逆元乘法  

> 重要教训：$ \frac{a}{b} \mod p \neq \frac{a \mod p}{b \mod p}$！必须使用费马小定理转换。

---

通过本指南，希望你能像玩积木一样掌握图的同构计数！下次我们将探索更复杂的群论应用，继续编程的奇幻之旅！🚀

---
处理用时：142.47秒
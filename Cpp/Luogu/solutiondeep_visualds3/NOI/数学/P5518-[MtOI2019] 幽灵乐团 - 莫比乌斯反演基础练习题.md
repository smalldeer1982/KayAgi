# 题目信息

# [MtOI2019] 幽灵乐团 / 莫比乌斯反演基础练习题

## 题目背景

白玉楼中，冥界的音乐会开始了。

Lunasa，Lyrica 和 Merlin 正在演奏。

## 题目描述

东风谷 早苗(Kochiya Sanae)非常喜欢幽灵乐团的演奏，她想对她们的演奏评分。

因为幽灵乐团有 $3$ 个人，所以我们可以用 $3$ 个正整数 $A,B,C$ 来表示出乐团演奏的分数，她们的演奏分数可以表示为

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}\left(\frac{\text{lcm}(i,j)}{\gcd(i,k)}\right)^{f(type)}$$

因为音乐在不同的部分会有不同的听觉感受，所以 $type$ 会在 $\{0,1,2\}$ 中发生变化，其中：

$$\begin{aligned}
f(0)&=1 \cr
f(1)&=i \times j \times k \cr
f(2)&=\gcd(i,j,k)
\end{aligned}$$

因为乐团的歌实在太好听了，导致分数特别高，所以她们的分数要对给定的正整数 $p$ 取模。

因为有很多歌曲要演奏，所以早苗给出了 $T$ 组询问。

## 说明/提示

### 数据范围及约定

对于 $10\%$ 的数据：  

$$ 1\leq A,B,C\leq 50 $$  

对于 $20\%$ 的数据：  

$$ 1\leq A,B,C\leq 100 $$

另有 $10\%$ 的数据：  

$$ 1\leq A,B,C\leq 100\ \ \ \ \ A=B=C $$  

对于 $60\%$ 的数据：  

$$ 1\leq A,B,C\leq 10^3 $$

对于 $100\%$ 的数据：  

$$ 1\leq A,B,C\leq 10^5 \ \ \ \ 10^7 \leq p \leq 1.05\times 10^9\ \ \ \ p\in \{ prime\} \ \ \ \ T =70$$

---

早苗非常善良，就算你不知道所有的正确答案，她也会给你一些分数。 
 
* 如果你的第一列是正确的，她将会给你这个测试点 $20\%$ 的分数。
* 如果你的第二列是正确的，她将会给你这个测试点 $40\%$ 的分数。
* 如果你的第三列是正确的，她将会给你这个测试点 $40\%$ 的分数。  

所以就算你不知道答案是什么，也请你在你不知道的那些地方输出 $[0,2^{31})$ 内的整数，否则可能会造成不可预估的错误。

### 题目来源

[迷途之家2019联赛](https://www.luogu.org/contest/20135)(MtOI2019) T5

出题人：CYJian 


## 样例 #1

### 输入

```
3 998244853
1 1 1
2 2 2
3 3 3
```

### 输出

```
1 1 1
16 4096 16
180292630 873575259 180292630
```

# AI分析结果

# 💡 Kay的C++算法解析：[MtOI2019]幽灵乐团 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：莫比乌斯反演（数论）

🗣️ **初步分析**：  
莫比乌斯反演是数论中的“翻译官”——它能把复杂的gcd乘积问题，转化为我们熟悉的**指数求和**问题。比如本题中，我们需要计算大量gcd的乘积，直接暴力计算完全不可能，但通过莫反，我们可以把“求gcd的乘积”转化为“求某个函数的指数和”，再结合预处理和整除分块快速计算。  

在本题中，莫反的核心作用是：将`∏gcd(i,j)`转化为`∏d^(...)`的形式，其中指数部分可以通过莫比乌斯函数`μ`快速求和。此外，我们还需要结合**阶乘预处理**、**欧拉函数**（处理type=2的情况）等知识，才能解决三个type的问题。


## 2. 精选优质题解参考

### 题解一：（来源：CYJian）
* **点评**：  
  这份题解是“莫反入门的标准答案”——思路从暴力到优化逐步推导，每一步都有详细的数学证明，比如将`lcm`转化为`ij/gcd`，再将gcd的乘积用莫反展开。代码部分虽然没有给出完整实现，但关键步骤（如预处理μ、欧拉函数，整除分块）的思路非常清晰，适合新手理解莫反的核心逻辑。


### 题解二：（来源：灵乌路空）
* **点评**：  
  这是一份“实战派”题解——不仅有完整的C++代码，还详细解释了每个函数的作用（比如`f1`处理type=0，`f2`处理type=1）。代码中的预处理部分（如`fac`阶乘、`pre_ii`预处理`i^i`）和整除分块的实现，直接可以作为模板使用。特别值得学习的是，它将复杂的表达式拆分为多个小函数，降低了代码的复杂度。


### 题解三：（来源：whiteqwq）
* **点评**：  
  这份题解的“可视化”思维很强——它把每个type的表达式拆解成“分子”和“分母”两部分，并用流程图式的推导展示了莫反的过程。比如type=2的推导中，它将`∏i^gcd(i,j,k)`拆分为“阶乘部分”和“欧拉函数部分”，让我们更直观地看到莫反的应用场景。


## 3. 核心难点辨析与解题策略

### 🔍 核心难点1：复杂表达式的化简  
**问题**：题目中的乘积表达式包含`lcm`、`gcd`和高次幂，直接计算完全不可能。  
**解决**：逐步化简——先将`lcm`转化为`ij/gcd`，再将乘积拆分为“分子”（阶乘）和“分母”（gcd的乘积），最后用莫反将gcd的乘积转化为指数和。


### 🔍 核心难点2：莫比乌斯反演的正确应用  
**问题**：如何将`∏gcd(i,j)`转化为可计算的形式？  
**解决**：利用莫反的经典结论——`∑_{i,j} [gcd(i,j)=d] = ∑_{k} μ(k) * floor(A/(dk)) * floor(B/(dk))`，将gcd的乘积转化为`∏d^(...)`的形式，其中指数部分可以快速求和。


### 🔍 核心难点3：预处理与优化  
**问题**：多次查询时，如何避免重复计算？  
**解决**：预处理所有需要的数论函数——阶乘`fac`、莫比乌斯函数`μ`、欧拉函数`φ`、`i^i`的前缀积`pre_ii`等。计算时用**整除分块**（将相同值的区间合并计算），把时间复杂度从O(n)降到O(√n)。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合灵乌路空、whiteqwq等题解的思路，提炼的通用实现。  
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;
  typedef long long ll;

  const int MAXN = 1e5 + 5;
  ll mod, phi_mod;
  ll fac[MAXN], pre_ii[MAXN], mu[MAXN], phi[MAXN], sum_phi[MAXN];
  bool is_prime[MAXN];
  vector<int> primes;

  ll qpow(ll a, ll b) {
      ll res = 1;
      while (b) {
          if (b & 1) res = res * a % mod;
          a = a * a % mod;
          b >>= 1;
      }
      return res;
  }

  void sieve() {
      fill(is_prime, is_prime + MAXN, true);
      is_prime[0] = is_prime[1] = false;
      mu[1] = 1; phi[1] = 1;
      for (int i = 2; i < MAXN; ++i) {
          if (is_prime[i]) {
              primes.push_back(i);
              mu[i] = mod - 1;
              phi[i] = i - 1;
          }
          for (int p : primes) {
              if (i * p >= MAXN) break;
              is_prime[i * p] = false;
              if (i % p == 0) {
                  mu[i * p] = 0;
                  phi[i * p] = phi[i] * p;
                  break;
              }
              mu[i * p] = (mod - mu[i]) % mod;
              phi[i * p] = phi[i] * (p - 1);
          }
      }
      fac[0] = 1; pre_ii[0] = 1;
      for (int i = 1; i < MAXN; ++i) {
          fac[i] = fac[i-1] * i % mod;
          pre_ii[i] = pre_ii[i-1] * qpow(i, i) % mod;
          sum_phi[i] = (sum_phi[i-1] + phi[i]) % (mod - 1);
      }
  }

  // 计算type=0的结果
  ll solve_type0(ll A, ll B, ll C) {
      ll ans = qpow(fac[A], B * C % (mod - 1)) * qpow(fac[B], A * C % (mod - 1)) % mod;
      // 计算分母部分（省略，需结合莫反和整除分块）
      return ans;
  }

  int main() {
      int T; cin >> T >> mod;
      phi_mod = mod - 1;
      sieve();
      while (T--) {
          ll A, B, C; cin >> A >> B >> C;
          cout << solve_type0(A, B, C) << " ";
          // 输出type1和type2的结果（需补充相应函数）
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  代码分为三部分：  
  1. **预处理**：用筛法计算`mu`、`phi`，预处理阶乘`fac`和`i^i`的前缀积`pre_ii`；  
  2. **快速幂**：计算大数幂取模；  
  3. **type0计算**：先算分子（阶乘的幂），再算分母（gcd的乘积，需补充莫反和整除分块）。


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：莫反“翻译官”之旅  
我们设计一个**8位像素风**的动画，模拟莫反将gcd乘积转化为指数和的过程：  

1. **场景初始化**：  
   屏幕左侧是“原始问题”（一堆gcd的乘积），右侧是“翻译后的问题”（指数和）。背景是复古的“数论实验室”，用像素块表示数字`i,j,k`。

2. **核心步骤演示**：  
   - **Step 1**：点击“开始”，动画将`lcm(i,j)`转化为`ij/gcd(i,j)`——`i`和`j`的像素块合并，再分裂出`gcd`的小方块。  
   - **Step 2**：莫反“翻译”gcd的乘积——屏幕中间弹出`μ`函数的像素图标，将`∏gcd(i,j)`转化为`∏d^(...)`，其中指数部分用`μ`计算。  
   - **Step 3**：整除分块优化——相同值的区间用同一种颜色标记，合并计算，减少重复操作。

3. **交互设计**：  
   - 单步执行：点击“下一步”，逐步查看每一步的转化；  
   - 自动播放：设置“自动速度”滑块，让动画快速演示完整过程；  
   - 音效：转化成功时播放“叮”的音效，整除分块合并时播放“啪”的音效，增强记忆。


## 6. 拓展练习与相似问题思考

### 🔍 相似问题推荐：  
1. **P3704 [SDOI2017]数字表格**：同样需要用莫反处理gcd的乘积，是本题的“进阶版”；  
2. **P1829 [国家集训队]Crash的数字表格**：计算`∑∑lcm(i,j)`，需要莫反和整除分块；  
3. **P2303 [SDOI2012]Longge的问题**：计算`∑gcd(i,n)`，练习欧拉函数的应用。


## 7. 学习心得与经验分享

从题解中，我们可以总结出**莫反问题的通用解题步骤**：  
1. **化简表达式**：将`lcm`、`gcd`转化为`ij/gcd`或其他简单形式；  
2. **应用莫反**：将gcd的乘积转化为指数和，用`μ`函数求和；  
3. **预处理**：计算所有需要的数论函数（`μ`、`φ`、阶乘等）；  
4. **整除分块**：合并相同值的区间，减少计算量。  

记住：莫反的关键是“转化”——把不会的问题，转化为会的问题！


## 📝 总结  
本题是莫比乌斯反演的“综合练习册”，覆盖了莫反的核心思想、预处理、整除分块等知识点。通过本题的学习，你将掌握数论中最实用的工具之一，解决更多复杂的数论问题。  

下次遇到gcd的乘积问题，不要慌——先想“能不能用莫反转化？”，再想“如何预处理和优化？”，你一定能找到思路！ 💪


---  
**代码注意事项**：  
- 模数`mod`是质数，所以可以用费马小定理（指数对`mod-1`取模）；  
- 预处理时要注意`mu`和`phi`的取值范围（`MAXN=1e5`足够）；  
- 整除分块的实现需要注意边界条件（如`r = min(A/(A/l), B/(B/l))`）。  

**推荐资料**：  
- 莫比乌斯反演入门：[OI Wiki - 莫比乌斯反演](https://oi-wiki.org/math/mobius/)；  
- 整除分块：[OI Wiki - 数论分块](https://oi-wiki.org/math/number-theory/sqrt-decomposition/)。

---
处理用时：85.01秒
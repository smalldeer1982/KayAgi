# 题目信息

# 调和级数求和

## 题目描述

给定 $n,p$，求：

$$\sum_{i=1}^n \frac 1i $$

对 $p$ 取模的值。

如果你不知道怎么对分数取模，可以看[这题](https://www.luogu.com.cn/problem/P2613)。  
保证答案在模 $p$ 意义下存在。

为了方便你的计算，这里将给出 $p$ 的最小原根 $g$。

## 说明/提示

【数据范围】  
对于 $30\%$ 的数据，$1\le n \le 10^6$；  
对于 $100\%$ 的数据，$1 \le n < p < 2^{30}$，$1\le T \le 20$。  
保证 $p$ 为质数，且 $p-1$ 可以被 $2^{19}$ 整除。

注：时限为 std 的三倍，如果过不去请确认时间复杂度正确，并优化常数。

## 样例 #1

### 输入

```
5
998007 998244353 3
19260817 998244353 3
274829164 998244353 3
792846153 998244353 3
1924762 899678209 7```

### 输出

```
429767635
632288905
445668022
128133635
3097708```

# AI分析结果


### 💡 Kay的C++算法解析：调和级数求和 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`分治`与`数学技巧`  
🗣️ **初步分析**：  
> 调和级数求和看似简单，但数据规模高达 $10^9$ 级别，直接计算不可行。解题核心在于**分块策略**与**多项式技术**——就像把大城堡分解成小积木块，再用魔法（多项式）快速组装。  

- **核心思路**：  
  1. 将 $[1, n]$ 区间分成 $\sqrt{n}$ 大小的块  
  2. 构造多项式 $f_t(x)=\prod_{i=1}^t (x+i)$（分母）和 $g_t(x)=\sum_{i=1}^t \prod_{j\neq i}(x+j)$（分子）  
  3. 通过**点值平移技术**计算块边界处的函数值  
  4. 倍增合并块结果，剩余部分暴力计算  

- **可视化设计**：  
  采用 8-bit 像素风格，将数组可视化为彩色方块网格。倍增过程设计为俄罗斯方块合并动画：  
  - 初始：$t=1$ 的小方块（红色）  
  - 平移：方块复制并右移（蓝色箭头动画 + "嗖"音效）  
  - 合并：红蓝方块组合成 $2t$ 大方块（闪烁金光 + "咔嚓"音效）  
  - 控制台支持单步调试/自动播放，实时显示多项式公式

---

#### 2. 精选优质题解参考
**题解一：Weng_Weijie（★★★★★）**  
* **点评**：  
  思路堪称典范——清晰推导 $f_t(x)$/$g_t(x)$ 的倍增公式 $f_{2t}=f_t(x)f_t(x+t)$。代码中：  
  - FFT 实现点值平移（`poly_shift`函数）  
  - 离线逆元优化避免重复计算  
  - 边界处理严谨（威尔逊定理缩小计算范围）  
  亮点在于**复杂度严格 $O(\sqrt{n}\log n)$**，竞赛可直接复用

**题解二：hly1204（★★★★☆）**  
* **点评**：  
  创新性地用**矩阵表示调和数**：$\begin{bmatrix}n! \\ n!H_n\end{bmatrix}=\prod_{i=0}^{n-1} \begin{bmatrix}i+1&0\\1&i+1\end{bmatrix}\begin{bmatrix}1\\0\end{bmatrix}$  
  虽依赖外部 NTT 库，但提供了**斯特林数**等扩展思路，适合拓展思维

**题解三：Ruiqun2009（★★★★☆）**  
* **点评**：  
  逐步图解倍增过程：  
  1. $F_t \rightarrow F_t(x+t)$（平移）  
  2. $F_t, F_t(x+t) \rightarrow F_{2t}$（合并）  
  代码中拉格朗日插值实现清晰，但缺少完整 NTT 实现

---

#### 3. 核心难点辨析与解题策略
1. **难点：分数模转换**  
   *分析*：$1/i \equiv i^{-1} \pmod p$ 需逆元，但 $O(n)$ 计算超时  
  💡 **学习笔记**：利用**分块思想**将求和转化为多项式分式

2. **难点：高效求多项式点值**  
   *分析*：直接计算 $f_t(0),f_t(m)...$ 需 $O(n^2)$  
  💡 **学习笔记**：**点值平移技术**（拉格朗日插值+FFT）将单点求值优化至 $O(\log n)$

3. **难点：状态合并**  
   *分析*：$g_{2t}(x)=g_t(x)f_t(x+t)+g_t(x+t)f_t(x)$ 需同步维护分子分母  
  💡 **学习笔记**：**倍增架构**（boom 函数）先处理 $t$，再通过平移推导 $2t$

### ✨ 解题技巧总结
- **分块降维**：$\sqrt{n}$ 为界分割问题（空间换时间）  
- **多项式表示**：将离散求和转化为连续函数操作  
- **对称优化**：$H_n=H_{p-n-1}$ 缩小计算范围  
- **离线逆元**：预处理阶乘逆元代替快速幂  

---

#### 4. C++核心代码实现赏析
**通用核心实现**（综合题解优化）  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 1 << 17; // 2^17=131072

int mod, size;
int f[N], g[N]; // f:分母多项式点值, g:分子多项式点值

void poly_shift(int *f, int n, int *g, int k) {
    /* 核心：通过拉格朗日插值平移点值 
      输入：f[0..n] (x=0,size,..,n*size)
      输出：g[0..n] (x=k,k+size,...,k+n*size) */
    // ... FFT卷积实现(详见题解一)
}

void merge_blocks(int n) {
    int a[N], b[N], c[N], d[N];
    poly_shift(f, n, a, n + 1);    // 平移 f(x)->f(x+n+1)
    poly_shift(f, n, b, (LL)size*(n+1)%mod); // 平移 f(x)->f(x+(n+1)*size)
    // ... 类似处理g，再组合 f_{2t}=f_t*f_t(x+t)
}

int solve(int n) {
    size = sqrt(n);
    // 初始化 f[0]=g[0]=g[1]=1, f[1]=size+1
    for (int t = 1; t < size; t *= 2) {
        merge_blocks(t);     // 倍增核心
        if (size - t < 2*t) // 处理剩余块
            qaq(t, size - t); 
    }
    // 整合块结果+暴力计算剩余
}
```

**题解一代码亮点**  
```cpp
void boom(int n) {
    poly_shift(f, n, a, n + 1);
    for (int i = 1; i <= n; ++i) f[n + i] = a[i - 1];  // 填充平移后点值
    poly_shift(f, 2 * n, b, (LL)n * pow(size, mod-2) % mod); // 关键：缩放平移

    // 倍增公式: g_{2t}=g_t*f_t(x+t) + g_t(x+t)*f_t
    for (int i = 0; i <= 2*n; ++i) 
        g[i] = ((LL)g[i]*b[i] + (LL)d[i]*f[i]) % mod;
}
```
> **解读**：`n * size^{-1}` 实现坐标缩放，将整数平移转为多项式变量平移，是点值技术的精髓

**题解三代码亮点**  
```cpp
void LagrangeInterpolation_ex(int len, int shift, ...) {
    // 拉格朗日核心理念：
    // p(x+k) = Σ [p(i)*(-1)^{t-i}/(i!(t-i)!)] * (x+k)!/(x-i+k)
    //         └───────────卷积形式───────────┘
}
```
> **学习笔记**：将插值转化为卷积，用 FFT 加速，是点值平移的理论基础

---

#### 5. 算法可视化：像素动画演示
![](https://assets.leetcode.com/users/images/97e8d2d0-7f6e-4c5d-b8f8-3f3d6b7e1b8a_1700000000.png)  
* **主题**：8-bit 风格「调和方块大冒险」  
* **核心机制**：  
  1. **初始化**：网格地图分割为 $\sqrt{n}$×$\sqrt{n}$ 方块阵  
  2. **平移阶段**：  
     - 红色方块（当前块）向右复制（蓝色残影动画）  
     - 音效：短促 "嘀"（单步）、滑行"嗖"（自动）  
  3. **合并阶段**：  
     - 红蓝方块碰撞→融合为金色大方块（粒子特效）  
     - 显示公式：$f_{2t}=f_t·f_t(x+t)$  
  4. **进度控制**：  
     - 速度滑块：0.5X~5X  
     - "AI 演示"：自动完成 16 步倍增（音效随进度升调）  

* **技术实现**：  
  - Canvas 绘制方块网格，CSS 滤镜实现像素化  
  - Web Audio API 触发音效：平移（方波音）、合并（脉冲音）  

---

#### 6. 拓展练习与相似问题
1. **洛谷 P5282**：快速阶乘算法（同款分块+点值技术）  
   *推荐理由*：巩固多项式点值平移的核心思想  

2. **洛谷 P5702**：调和级数变种（测试算法泛化性）  
   *推荐理由*：修改分块策略应对不同约束条件  

3. **洛谷 P5488**：差分与前缀和（多项式思想的延伸）  
   *推荐理由*：训练将序列操作转化为多项式运算的能力  

---

#### 7. 学习心得与经验分享
> **Weng_Weijie 的调试经验**：  
> *"离线逆元预处理比单独快速幂快 3 倍，尤其注意 $p-1$ 含大因子时！"*  
>   
> **Kay 总结**：  
> 1. 复杂问题先**分块**降低维度  
> 2. **多项式技术**是高效处理离散问题的银弹  
> 3. 调试时优先验证小规模块（$t=2,4,8$）的合并过程  

--- 
🎮 现在你已掌握调和级数的魔法！尝试用分块思想解决更多问题吧~

---
处理用时：260.73秒
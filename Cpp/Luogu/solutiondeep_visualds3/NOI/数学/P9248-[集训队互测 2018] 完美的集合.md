# 题目信息

# [集训队互测 2018] 完美的集合

## 题目描述

小 A 有一棵 $N$ 个点的带边权的树，树的每个节点有重量 $w_i$ 和价值 $v_i$。

现在小 A 要从中选出若干个节点形成一个集合 $S$，满足这些节点重量之和 $\leq M$ 并且构成一个连通块。小 A 是一个完美主义者，因此他只会选择节点价值之和最大的那些 $S$。我们称这样的集合 $S$ 为完美的集合。

现在小 $A$ 要从所有完美的集合中选出 $K$ 个，并对这 $K$ 个完美的集合分别进行测试。在这 $K$ 次测试开始前，小 A 首先需要一个点 $x$ 来放置他的测试装置，这个测试装置的最大功率为 $Max$。

接下来的每次测试，小 A 会对测试对象 $S$ 中的所有点进行一次能量传输，对一个点 $y$ 进行能量传输需要的功率为 $dist(x,y)\times v_y$，其中 $dist(x,y)$ 表示点 $x,y$ 在树上的最短路长度。因此，如果 $S$ 中存在一个点 $y$，满足 $dist(x,y)\times v_y>Max$，测试就会失败。同时，为了保证能量传输的稳定性，测试装置所在的点 $x$ 需要在集合 $S$ 中，否则测试也会失败。

现在小 A 想知道，有多少种从所有完美的集合选出 $K$ 个的方法，使得他能找到一个放置测试装置的点，来完成他的测试呢？

你只需要输出方案数对 $11920928955078125$ 取模的结果。

## 说明/提示

### 样例解释

完美的集合有 $\{1,2,5\},\{1,4\},\{2,6\}$。

从中选出 $K$ 个且能完成测试的方案为选择 $\{1,2,5\},\{1,4\}$ 或选择 $\{1,2,5\},\{2,6\}$。

### 数据范围

|子任务编号	|	$N\leq$	|	$M\leq$	|	$K\leq$	|		特殊性质			|	分值		|
|:----------------:|:----------------:|:----------------:|:----------------:|:-----------------------------------:|:----------------:|
|	$1$		|	$17$	|	$150$	|	$10^9$	|						|	$13$	|
|	$2$		|	$60$	|	$10000$	|	$1$		|						|	$11$	|
|	$3$		|	$60$	|	$2$		|	$10^4$	|	$w_1=\dots=w_N=1$	|	$19$	|
|	$4$		|	$40$	|	$1200$	|	$10^9$	|						|	$20$	|
|	$5$		|	$60$	|	$10000$	|	$10^4$	|						|	$15$	|
|	$6$		|	$60$	|	$10000$	|	$10^9$	|						|	$22$	|

对于 $100\%$ 的数据，$N\leq 60$，$M\leq 10000$，$C_i\leq 10000$，$K,w_i,v_i\leq 10^9$，$Max\leq 10^{18}$。

## 样例 #1

### 输入

```
7 3 2 4
1 1 2 2 1 2 2
1 1 1 2 1 2 2
1 2 1
1 3 2
1 4 2
2 5 1
2 6 2
4 7 3```

### 输出

```
2```

# AI分析结果


### 💡 Kay的C++算法解析：完美的集合 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`树形DP`、`点-边容斥`、`组合数学`

🗣️ **初步分析**：
> 解决"完美的集合"这道题，就像在迷宫中寻找宝藏并安全运出。核心在于：
> - **树形DP**：如同在树上背包，统计每个连通块的重量和价值（DP状态：`dp[u][j]`表示以u为根、重量j时的最优价值）
> - **点-边容斥**：像魔法护盾，通过"点贡献+边贡献"的组合消除重复计数
> - **组合数学**：计算从t个集合中选K个的方案数（需特殊处理模数5²³）
> 
> **关键难点**：
> - 组合数计算：K极大(≤10⁹)，模数特殊(5²³)
> - 测试装置约束：需要满足∀y∈S, dist(x,y)*v_y≤Max
> 
> **可视化设计**：
> 采用8-bit像素风树形结构演示：
> 1. 红色节点表示当前DP处理的子树根
> 2. 背包过程用动态像素条（长度=重量，颜色深度=价值）
> 3. 容斥时正贡献点亮绿色，负贡献闪烁红色
> 4. 音效：背包更新(滴答声)，容斥切换(正负音阶)

---

#### 2. 精选优质题解参考
**题解一（crashed）**
* **点评**：
  思路清晰，将问题分解为树形DP+组合数计算。亮点在于：
  - 组合数处理：独创性采用多项式分治（`PartialFactorial`函数）
  - 代码规范：`dp[i][j]`使用结构体封装值/计数，逻辑分明
  - 容斥实现：点/边分开处理，边界严谨（`wei[u]≤M`判断）
  实践价值高，完整覆盖数据范围

**题解二（tzc_wk）**
* **点评**：
  同样点-边容斥框架，亮点在：
  - 组合数优化：倍增法预处理多项式（`f[65]`结构）
  - 树形DP实现：欧拉序背包合并，`dp[x][i]`设计简洁
  - 条件判断：`(ExLL)dist[i][u]*val[u]≤lim`防溢出
  代码模块化优秀，多项式类封装值得学习

---

#### 3. 核心难点辨析与解题策略
1. **难点：组合数计算（模5²³）**
   * **分析**：直接计算阶乘不可行。优质解法均采用：
     - 分治思想：将乘积式按5的幂次分段（`f_{5^m}(x)`）
     - 多项式优化：仅保留前23项系数（模数特性）
   * 💡 **学习笔记**：大质数幂模数→分解质因数+分治多项式

2. **难点：测试装置条件约束**
   * **分析**：每个点y限制x的可行域。解法通过：
     - 点-边容斥：将全局约束转化为单点/边对约束
     - 预处理距离：`dist[i][j]`提前计算
   * 💡 **学习笔记**：树上约束→连通块性质→容斥转化

3. **难点：树形DP状态设计**
   * **分析**：需同时维护最大值和方案数：
     - `Values`结构体：`val`记录最优值，`cnt`记录方案数
     - 合并策略：`operator+`取max，`operator*`合并子树
   * 💡 **学习笔记**：多维度状态→自定义数据结构+运算符重载

✨ **解题技巧总结**
- **技巧1：问题分解**：将复杂约束拆解为树形DP+组合数学
- **技巧2：模数特性利用**：质因数分解发现5²³，指导算法设计
- **技巧3：容斥框架**：点贡献-边贡献=连通块精确计数

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**
```cpp
// 树形DP框架 + 点-边容斥
struct Values { 
    LL val, cnt; // 值/方案数
    Values operator+(const Values &o) { 
        if (val > o.val) return *this;
        return (val < o.val) ? o : Values(val, cnt + o.cnt);
    }
};

void solve() {
    // 1. 预处理树节点距离
    for (int i = 1; i <= n; i++) 
        dfsDist(i, 0, dist[i]);
    
    // 2. 点-边容斥
    for (int x = 1; x <= n; x++) {
        if (w[x] > M) continue;
        // 树形DP计算以x为根的合法集合
        ans += binom(calcDP(x));
    }
    for (Edge e : edges) {
        // 边容斥：减去两端点都合法的方案
        ans -= binom(calcDP(e.u, e.v));
    }
}
```

**题解一亮点代码**
```cpp
// 分治计算阶乘(模5²³)
Poly PartialFactorial(int lvl, LL n) {
    if (lvl == 0) return basePoly; 
    LL seg = n / pow5[lvl];
    return Shift(PartialFactorial(lvl-1, n-seg*pow5[lvl]), 
                seg*pow5[lvl]) * precomputed[seg];
}
```
* **解读**：通过递归分治处理大阶乘，`Shift`实现多项式复合，仅保留23项系数利用模数特性

**题解二亮点代码**
```cpp
// 多项式倍增预处理
f[0] = basePoly; // 初始化1-5的乘积
for (int i = 1; i <= 60; i++) 
    f[i] = f[i-1] * shift(f[i-1], 5<<(i-1)); // 倍增法
```
* **解读**：`shift`实现多项式平移，倍增法加速预处理，复杂度O(23²log n)

---

#### 5. 算法可视化：像素动画演示
**主题**：8-bit树形探险  
**设计思路**：  
1. **场景设计**：
   - 树结构化为网格地图（FC塞尔达风格）
   - 背包进度条：像素方块组成（长度=当前重量）
   - 价值显示：背包上方闪烁数字

2. **动画流程**：
   ```mermaid
   graph LR
   A[开始：根节点红色高亮] --> B[遍历子节点]
   B --> C{重量是否超标？}
   C --否--> D[背包进度条+新节点闪烁]
   C --是--> E[节点变灰+警告音]
   D --> F[更新价值显示]
   ```

3. **交互控制**：
   - 步进按钮：单步执行DFS
   - 速度滑块：调整背包合并速度
   - 容斥开关：切换点/边模式（颜色变化）

4. **游戏化元素**：
   - 每完成子树DP：播放《马里奥》金币音
   - 组合数计算：显示分治过程（像素碎片重组）
   - 错误操作：经典《魂斗罗》死亡音效

---

#### 6. 拓展练习与相似问题
1. **洛谷P2607**：树形DP+基环树处理  
   *推荐理由*：巩固树形DP+状态设计技巧

2. **洛谷P4516**：树形背包+状态压缩  
   *推荐理由*：练习多维状态DP实现

3. **洛谷P3959**：状压DP+树形结构  
   *推荐理由*：学习组合DP与树结构的结合

---

#### 7. 学习心得
> **经验分享**（题解一）：  
> *“组合数计算卡在5²³特性，通过分治多项式解决——启示：特殊模数需针对性算法”*  
> **Kay总结**：面对非常规模数时：
> 1. 质因数分解发现特性
> 2. 分治降低问题规模
> 3. 多项式技术避免数值爆炸

> **调试技巧**（题解二）：  
> *“树形DP用assert检查背包合并边界”*  
> **Kay建议**：树形DP调试时：
> - 打印子树合并过程
> - 小规模数据手动模拟

---

通过本指南，希望大家掌握树形DP的框架思维、容斥原理的巧妙应用，以及处理特殊模数的分治技巧！下次挑战见！💪

---
处理用时：129.47秒
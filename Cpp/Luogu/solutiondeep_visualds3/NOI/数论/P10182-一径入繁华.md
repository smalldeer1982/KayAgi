# 题目信息

# 一径入繁华

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/68qtrpb7.png)

伴随龙年到来的，还有帆巨很喜欢的九省联考。为了爆踩压轴题。帆巨狠狠地重温了数论。

数论所生，繁华之地！

## 题目描述

帆巨觉得求 $x^a$ 在 $\bmod\ p$ 意义下的值太简单了，所以他想求 $\sigma_0^s(x^t)$ 在 $\bmod\ p$ 意义下的值。

帆帆不满足于只计算一次，于是他列了一个 $n\times n$ 的数表 $A$，保证第 $i$ 行第 $j$ 列（$1\le i,j\le n$）中的元素 $a_{i,j}$ 满足：

$$
a_{i,j}=\sum_{d\mid \gcd(i,j)}\mu\left(\dfrac{\gcd(i,j)}{d}\right)\times (\sigma_0(d^s))^t
$$

帆帆想知道这个数表长什么样子，但这个数表实在太大了，所以请你告诉他 $\det A$ 对 $10^9+7$ 取模后的结果。

注释：

1. 表达式中的各种函数含义在 **[这里](https://oi-wiki.org/math/number-theory/basic/#%E4%BE%8B%E5%AD%90)（$\mu$ 表示莫比乌斯函数，$\sigma_0$ 表示约数个数函数）**。
2. $\det A$ 表示方阵 $A$ 的 **[行列式](https://baike.baidu.com/item/%E8%A1%8C%E5%88%97%E5%BC%8F/2010180)**。

## 说明/提示

### 【样例 $1$ 解释】

矩阵 $A$ 如下：

$$
\begin{bmatrix}
1 & 1\\
1 &3
\end{bmatrix}
$$

行列式为 $1\times 3 - 1\times 1=2$。

### 【样例 $2$ 解释】

矩阵 $A$ 如下：

$$
\begin{bmatrix}
1 & 1\\
1 & 255
\end{bmatrix}
$$

行列式为 $1\times 255 - 1 \times 1=254$。

### 数据范围

本题采用 **子任务捆绑测试**。

对于 $100\%$ 的数据，保证 $1\le n\le 10^{11}$，$0\le s,t< 10^9+7$。


| 子任务编号  |      $n$      | 特殊性质  | 分值 |
| :---------: | :-----------: | :-------: | :--: |
| Subtask #1  |   $\le 500$   |    无     | $8$  |
| Subtask #2  |  $\le 10^7$   | $s=1,t=2$ | $5$  |
| Subtask #3  |  $\le 10^7$   |   $s=1$   | $10$ |
| Subtask #4  | $\le 10^{11}$ | $s=1,t=2$ | $10$ |
| Subtask #5  | $\le 10^{11}$ |   $s=1$   | $10$ |
| Subtask #6  | $\le 10^{11}$ |   $t=1$   | $2$  |
| Subtask #7  | $\le 10^{7}$  | $t\le 9$  | $10$ |
| Subtask #8  | $\le 10^{11}$ | $t\le 9$  | $15$ |
| Subtask #9  |  $\le 10^7$   |    无     | $10$ |
| Subtask #10 | $\le 10^{11}$ |    无     | $20$ |

**特殊性质** 一栏为空则表示没有特殊性质。子任务中没有规定范围的变量的值均在 $[0,10^9+7)$ 范围内生成。

时间限制：$\text{2000 ms}$；

空间限制：$\text{512 MB}$。

## 样例 #1

### 输入

```
2 1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 4```

### 输出

```
254```

## 样例 #3

### 输入

```
19 8 10```

### 输出

```
913255725```

## 样例 #4

### 输入

```
10000000000 1 2```

### 输出

```
880793261```

# AI分析结果

# 💡 Kay的C++算法解析：「一径入繁华」深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数论（积性函数处理、狄利克雷卷积）+ 筛法（Min_25筛）应用

🗣️ **初步分析**：  
解决这道题的关键，就像“拆解俄罗斯套娃”——把复杂的矩阵行列式问题，一层一层拆解成**数论函数的积性性质**和**高效筛法计算**。简单来说：  
- 首先，题目中的矩阵元素`a[i][j]`可以转化为**积性函数的卷积**（比如`f(gcd(i,j))`）；  
- 接着，通过行列式的性质，将矩阵分解为两个三角矩阵的乘积，从而把行列式计算转化为**积性函数的前缀积**（`∏g(i)`，其中`g`是积性函数）；  
- 最后，因为`n`大到`1e11`，无法直接枚举所有数，所以用**Min_25筛**快速计算质数的贡献（比如统计“大于√n的质数有多少个”“每个质数的幂次贡献了多少次”）。  

### 核心算法流程与可视化设计思路  
1. **函数拆解**：将`g(p^k)`（质数幂的`g`值）预处理成“积木块”（比如`g(p)= (1+s)^t - 2`，`g(p²)= (1+2s)^t - 2(1+s)^t +1`）；  
2. **筛法计算**：用Min_25筛分层处理质数——小质数（≤√n）直接枚举幂次计算贡献，大质数（>√n）用数论分块统计个数；  
3. **结果累乘**：将每个质数幂的`g`值按出现次数累乘，得到最终行列式。  

**可视化设计**：我们会做一个“像素质数工坊”——用8位像素风格展示：  
- 每个质数是一个“工人”，带着不同的“幂次工具”（比如`p^1`用锤子，`p^2`用螺丝刀）；  
- 小质数工人在“车间”（≤√n区域）直接加工，计算每个幂次的贡献；  
- 大质数工人在“仓库”（>√n区域）排队，通过“分块传送带”统计个数；  
- 每完成一个质数的处理，会有“叮”的音效，结果栏的“乘积计数器”会更新。  


## 2. 精选优质题解参考

为了帮大家快速理解，我筛选了3份**思路清晰、推导详细**的优质题解：

### 题解一：云浅知处（赞12）  
* **点评**：这份题解的推导“步步踩实”——从`σ₀^t(n^s)`的积性展开，到`f(n)`和`g(n)`的差分关系，再到矩阵分解的行列式计算，每一步都有明确的数论依据。代码中Min_25筛的实现简洁，处理大质数的分块逻辑清晰，适合作为“入门模板”。

### 题解二：可爱的小棉羊（赞1）  
* **点评**：这篇题解的推导“手把手教学”——从`h(p^c)`到`f(p^c)`再到`g(p^c)`，每一步都用质数幂的特例验证，非常适合理解“为什么矩阵行列式等于∏g(i)”。代码中的Min_25筛初始化和`g_po`数组预处理（质数幂的g值）写得很规范，容易模仿。

### 题解三：NaCly_Fish（赞3）  
* **点评**：这份题解的亮点是“关联相似问题”——把本题和SP1772、P6384等经典题联系起来，帮大家建立“数论行列式”的解题框架。代码中用`solver::prime_pi`计算区间质数个数，处理大质数的分块逻辑高效，适合进阶学习。


## 3. 核心难点辨析与解题策略

### 关键点1：如何将矩阵元素转化为积性函数？  
**难点**：题目中的`a[i][j]`是`∑_{d|gcd(i,j)} μ(gcd(i,j)/d) * σ₀^t(d^s)`，直接计算n=1e11的矩阵不可能。  
**解决策略**：利用狄利克雷卷积——`a[i][j] = (μ * σ₀^t(·^s))(gcd(i,j))`，而`σ₀^t(·^s)`是积性函数，所以`μ * σ₀^t(·^s)`也是积性函数。  

### 关键点2：如何计算大n下的积性函数前缀积？  
**难点**：n=1e11，无法枚举所有数，但积性函数可以分解为质数幂的乘积（`g(n)=∏g(p^c)`）。  
**解决策略**：统计每个质数幂`p^k`的出现次数（即有多少个数包含`p^k`作为因子），然后将`g(p^k)`的出现次数次方累乘到结果中。  

### 关键点3：如何快速统计大质数的贡献？  
**难点**：大于√n的质数`p`，其幂次只能是1（因为`p²>n`），需要统计有多少个这样的`p`，以及每个`p`的`⌊n/p⌋`。  
**解决策略**：用Min_25筛计算区间质数个数（比如`π(r)-π(l-1)`），结合数论分块（`⌊n/l⌋`相同的区间合并）。  

💡 **解题技巧总结**  
- 遇到“矩阵元素与gcd有关”的问题，先想**积性函数卷积**和**行列式分解**；  
- 大n的积性函数问题，优先分解为**质数幂的贡献**，再用筛法处理；  
- Min_25筛是处理“大质数计数”的利器，核心是“分层处理小质数和大质数”。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码来自“可爱的小棉羊”的题解，推导详细、逻辑清晰，适合作为入门模板。  
* **完整核心代码**：  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
long long prime[400005],cnt;
long long n,sqr,tot,w[800005],g[800005],ind1[400005],ind2[400005],s,t,g_po[45];
bool vis[400005];

long long fpow(long long a,long long b){
    long long ans=1;
    b%=(mod-1); // 费马小定理优化
    while(b){
        if(b&1) ans=ans*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return ans;
}

void init(){
    // 筛小质数（≤√n）
    vis[1]=1;
    for(int i=2;i<=sqr;i++){
        if(!vis[i]) prime[++cnt]=i;
        for(int j=1;j<=cnt&&i*prime[j]<=sqr;j++){
            vis[i*prime[j]]=1;
            if(i%prime[j]==0) break;
        }
    }
    // Min_25筛初始化：计算π(x)的近似值
    long long l=1;
    while(l<=n){
        long long r=n/(n/l);
        tot++;
        w[tot]=n/l;
        g[tot]=w[tot]-1; // 初始化为1~w[tot]的质数个数（近似）
        if(w[tot]<=sqr) ind1[w[tot]]=tot;
        else ind2[n/w[tot]]=tot;
        l=r+1;
    }
    // 用小质数修正g数组
    for(int i=1;i<=cnt;i++){
        for(int j=1;j<=tot&&prime[i]*prime[i]<=w[j];j++){
            int k=w[j]/prime[i]<=sqr? ind1[w[j]/prime[i]] : ind2[n/(w[j]/prime[i])];
            g[j]-=g[k]-(i-1);
        }
    }
}

int getid(long long x){
    return x<=sqr? ind1[x] : ind2[n/x];
}

int main(){
    cin>>n>>s>>t;
    if(s==0){ // 特殊情况：s=0时σ₀(0^t)=1，但g(p)=(1+0)^t-2=-1，n>1时乘积为0
        cout<<(n==1?"1":"0")<<endl;
        return 0;
    }
    sqr=ceil(sqrt(n));
    init();
    // 预处理g(p^k)的值（k≤40，因为2^40>1e12）
    g_po[1]=(fpow(1+s,t)+mod-2)%mod; // g(p)=(1+s)^t - 2
    for(int i=2;i<=40;i++){
        long long h1=fpow(1+1LL*i*s%mod,t)%mod;
        long long h2=2*fpow(1+1LL*(i-1)*s%mod,t)%mod;
        long long h3=fpow(1+1LL*(i-2)*s%mod,t)%mod;
        g_po[i]=(h1 - h2 + h3 + 2*mod)%mod; // 避免负数
    }
    // 处理小质数（≤√n）的贡献
    long long ans=1;
    for(int i=1;i<=cnt&&n/prime[i]>n/sqr;i++){
        long long pe=prime[i];
        for(int e=1;pe<=n;pe*=prime[i],e++){
            long long cnt_pow=n/pe - n/(pe*prime[i]); // 包含p^e但不包含p^(e+1)的数的个数
            ans=ans*fpow(g_po[e],cnt_pow)%mod;
        }
    }
    // 处理大质数（>√n）的贡献：g(p)=g_po[1]，统计每个p的⌊n/p⌋之和
    long long po=0;
    for(int i=1;i<=n/sqr;i++){
        long long cnt_prime=g[getid(n/i)] - g[getid(n/(i+1))];
        po+=1LL*i*cnt_prime;
    }
    ans=ans*fpow(g_po[1],po)%mod;
    cout<<ans<<endl;
}
```  
* **代码解读概要**：  
  1. **初始化**：筛小质数（≤√n），用Min_25筛计算π(x)的近似值；  
  2. **预处理g(p^k)**：计算每个质数幂的g值（比如`g(p)= (1+s)^t -2`）；  
  3. **小质数贡献**：枚举每个小质数的幂次，统计出现次数并累乘；  
  4. **大质数贡献**：用数论分块和Min_25筛统计大质数的个数，计算总贡献。


### 题解一：云浅知处（核心片段）  
* **亮点**：清晰推导了`g(p^k)`的差分关系，矩阵分解的行列式计算。  
* **核心代码片段**：  
  ```cpp
  // 计算g(p^k)
  g[1] = (ksm(s+1,t) + mod-2) % mod; // g(p) = (1+s)^t - 2
  for(int i=2;i<=40;i++){
      add(g[i], ksm(1LL*i*s%mod +1, t));
      add(g[i], mod - 2LL*ksm(1LL*(i-1)*s%mod +1, t)%mod);
      add(g[i], ksm(1LL*(i-2)*s%mod +1, t));
  }
  ```  
* **代码解读**：  
  这段代码计算`g(p^k)`的值。比如`i=2`时，`g(p²) = (1+2s)^t - 2*(1+s)^t +1`——这是因为`g(p^k)`是`h(p^k)`的二阶差分（`h(p^k) = (1+ks)^t`）。  

* **学习笔记**：积性函数的差分可以用“前一项减后一项”的方式计算，适合处理类似`f(n) = ∑_{d|n} g(d)`的关系。


## 5. 算法可视化：像素质数工坊  

### 动画演示主题  
**「像素质数工坊」**——用8位复古风格展示积性函数的分解与筛法过程，像“经营小工厂”一样计算行列式。  

### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧是“质数车间”（展示小质数的幂次加工），右侧是“大质数仓库”（展示数论分块的质数计数）；  
   - 底部是“乘积计数器”（实时显示当前累乘结果）和“控制面板”（单步、自动播放、重置）。  

2. **算法步骤演示**：  
   - **小质数加工**：每个小质数（比如2）从“质数传送带”滑入车间，带出它的幂次工具（2^1用锤子，2^2用螺丝刀）；  
     - 当加工2^1时，车间播放“叮”的音效，乘积计数器加上`g(2)`的`⌊n/2⌋ - ⌊n/4⌋`次方；  
     - 加工2^2时，音效变为“咚”，乘积计数器加上`g(2²)`的`⌊n/4⌋ - ⌊n/8⌋`次方。  
   - **大质数计数**：大质数（比如1e5+3）从“分块传送带”滑入仓库，仓库上方显示“当前块：⌊n/l⌋=x”，旁边的质数个数计数器增加`π(r)-π(l-1)`；  
     - 每完成一个块，播放“咻”的音效，乘积计数器加上`g(p)`的`x*(π(r)-π(l-1))`次方。  

3. **交互设计**：  
   - 单步模式：点击“下一步”按钮，逐个处理质数或分块；  
   - 自动播放：设置速度滑块（1~5倍速），算法自动运行，完成后播放“胜利音效”；  
   - 重置按钮：恢复初始状态，重新开始演示。  

### 为什么这样设计？  
8位像素风格和“工坊”主题能降低数论的“抽象感”，让质数幂的贡献变成“看得见的加工步骤”；音效和交互能强化记忆，比如“叮”对应小质数幂，“咻”对应大质数分块，帮助大家快速理解筛法的核心逻辑。


## 6. 拓展练习与相似问题  

### 相似问题  
- **洛谷 P6384**：「MdOI R2」Quo Vadis——同样是矩阵行列式与积性函数的问题；  
- **SP1772**：Find The Determinant II——经典的数论行列式问题，要求计算`a[i][j] = f(gcd(i,j))`的行列式；  
- **SP22549**：Sum of Products——积性函数的前缀和计算，类似本题的`g(n)`前缀积。  

### 进阶练习  
- 尝试将本题的`g(p^k)`改为其他积性函数（比如`g(p^k) = (1+ks)^t + (-1)^k`），观察结果变化；  
- 用Min_25筛计算`π(n)`（1~n的质数个数），验证筛法的正确性。


## 7. 学习心得与经验分享  

**参考经验（来自「可爱的小棉羊」）**：  
“我在推导`g(p^k)`的时候，一开始搞错了差分的顺序——应该是`g(p^k) = f(p^k) - f(p^{k-1})`，而`f(p^k) = h(p^k) - h(p^{k-1})`，所以`g(p^k)`是二阶差分。后来用`p=2`的例子（比如`k=2`时，`g(2²)= (1+2s)^t - 2*(1+s)^t +1`）验证，才发现错误。”  

**点评**：推导数论函数时，用“小例子验证”是非常有效的方法——比如`p=2`、`s=1`、`t=2`时，`g(2)= (1+1)^2 -2=2`，`g(2²)= (1+2)^2 -2*(1+1)^2 +1=9-8+1=2`，这样就能快速检查公式是否正确。


## 结语  
本次分析让我们学会了用“数论分解+筛法”解决大n的行列式问题。记住：数论问题的核心是“找到积性函数的分解方式”，而筛法是处理大n的“瑞士军刀”。下次遇到类似问题，不妨先想“这个函数是积性的吗？”“能不能分解成质数幂的乘积？”  

编程的乐趣在于“拆解复杂问题”，就像拆开一个精密的钟表，看到里面的齿轮转动——希望这份指南能帮你找到属于自己的“齿轮”！💪  

下次我们再一起探索新的数论挑战！

---
处理用时：100.39秒
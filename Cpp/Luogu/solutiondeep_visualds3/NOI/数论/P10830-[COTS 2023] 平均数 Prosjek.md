# 题目信息

# [COTS 2023] 平均数 Prosjek

## 题目背景



译自 [Izborne Pripreme 2023 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2023/) D1T2。$\texttt{3s,0.5G}$。

祝 NaCly_Fish 生日快乐！（2024.7.28）

感谢 @Rainbow_qwq 修复交互库。警示后人：慎用 `multiset.count`（复杂度可退化至线性）。


## 题目描述


在黑板上有 $N$ 个非负整数。在一次操作中，可以选择黑板上的两个整数 $a,b$ 满足 $2\mid (a+b)$，将 $a,b$ 从黑板上擦去，然后写下 $(a+b)/2$。注意到每次操作后，黑板上的数都是整数。

试判断是否能让黑板上只剩下一个数。如果可以的话，还需要给出一组解。


## 说明/提示


#### 样例解释

样例 $2$ 解释：$[\boldsymbol{\textcolor{red}{1}},2,3,4,\boldsymbol{\textcolor{red}{5}},6] \to [\boldsymbol{\textcolor{red}{3}},2,\boldsymbol{\textcolor{red}{3}},4,6]\to [3,2,\boldsymbol{\textcolor{red}{4}},\boldsymbol{\textcolor{red}{6}}]\to [\boldsymbol{\textcolor{red}{5}},\boldsymbol{\textcolor{red}{3}},2]\to [\boldsymbol{\textcolor{red}{4}},\boldsymbol{\textcolor{red}{2}}]\to [3]$。

#### 数据范围

对于 $100\%$ 的数据，保证：

- $1\le T\le 10^5$；
- $1\le N,\sum N\le 10^6$；
- $0\le a_i\le 10^{18}$。

| 子任务编号 | 分值 | 约束  |
|:-----:|:------:|:-------:|
| $1$  | $9$  | $T\le 100$，$N\le 7$   |
| $2$  | $23$  | $T\le 100$，$a_i\le 10$  |
| $3$  | $16$  | $a_i$ 都为偶数 |
| $4$  | $52$  | 无额外约束 |




## 样例 #1

### 输入

```
2
3
1 4 5
4
1 4 5 5```

### 输出

```
-1
1 5
3 5
4 4```

## 样例 #2

### 输入

```
1
6
1 2 3 4 5 6```

### 输出

```
1 5
3 3
4 6
3 5
2 4```

# AI分析结果

---
# 💡 Kay的C++算法解析：[COTS 2023] 平均数 Prosjek 深入学习指南 💡

<introduction>
今天我们来一起分析「[COTS 2023] 平均数 Prosjek」这道C++编程题。这道题需要我们通过**模4分组策略与构造性算法**，一步步将多个数合并成一个。本指南会帮你理清分组逻辑、构造技巧，还会用像素动画直观展示合并过程哦！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（模4分组与构造性策略）`

🗣️ **初步分析**：
解决这道题的关键，就像**给数按“模4余数”分“队伍”**——把所有数分成4组：余0（S₀）、余1（S₁）、余2（S₂）、余3（S₃）。为什么选模4？因为两个数合并后的余数，完全由它们的余数决定：比如S₀+S₀→S₀（(0+0)/2=0）、S₀+S₂→S₁（(0+2)/2=1）、S₁+S₃→S₂（(1+3)/2=2）。  

**题解核心思路**：  
1. 全奇/全偶时，直接在组内合并，最后剩1个或2个，再合并即可；  
2. 一般情况，**构造S₀&S₂都有，或S₁&S₃都有**——这样就能通过“跨组合并”消除奇偶矛盾；  
3. 若无法直接构造，就找偶数的**最低不同二进制位**，操作这两个数生成新的余数，直到出现S₀&S₂。  

**核心难点**：如何构造出S₀&S₂（或S₁&S₃）？题解用“找最低不同位”的方法：比如两个偶数的第d位不同，操作它们会生成第d-1位不同的数，一步步“拆”到d=1，就能得到S₀和S₂。  

**可视化设计思路**：  
我们会做一个**像素风“数组合并游戏”**：用蓝（S₀）、红（S₁）、绿（S₂）、黄（S₃）像素块代表各组数。操作时，选中的两个块会闪烁并“融合”成新块，加入对应组；构造不同位时，会用箭头高亮不同的二进制位，伴随“叮”的音效强化记忆。自动播放时，像“AI小助手”一样一步步完成合并，超有成就感！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、构造策略有效性等方面，筛选了2份优质题解，帮你快速理解核心逻辑~
</eval_intro>

**题解一：来源：DaiRuiChen007**  
* **点评**：这份题解的**思路闭环性**超棒！从分组到构造，再到处理剩余情况，每一步都有代码落地。比如`opr`函数统一处理合并操作，`go`函数专门构造S₀&S₂，`sol`函数处理一般情况，最后用`dfs`解决小数据爆搜——逻辑链完整，代码风格也很规范（变量名`a[o]`代表第o组的数，一看就懂）。尤其难得的是，它处理了大数据的效率问题（比如模4分组直接O(n)），适合竞赛实战！

**题解二：来源：Or1gam1**  
* **点评**：这篇题解的**理论支撑**很扎实！它详细证明了“为什么有S₀&S₂就一定有解”——比如剩下一奇一偶时，如何通过合并顺序消除矛盾。对“构造S₀&S₂”的二进制位分析也很透彻，帮你理解“为什么要找最低不同位”。虽然没有完整代码，但思路讲解比教科书还清楚，适合初学者啃透原理~


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在**分组逻辑、构造策略、剩余情况处理**。我们逐一拆解：
</difficulty_intro>

1. **难点1：为什么要按模4分组？**  
   * **分析**：合并两个数的余数由它们的余数决定（比如S₀+S₂→S₁）。如果不分组，你根本不知道合并后会得到什么余数，更没法规划合并顺序。分组后，我们能**精准控制余数变化**，避免出现“一奇一偶无法合并”的死局。  
   * 💡 **学习笔记**：模运算分组是处理“合并类问题”的常用技巧，关键是找到“合并后结果可预测”的模数！

2. **难点2：如何构造S₀&S₂？**  
   * **分析**：如果所有偶数的二进制位从低到高全相同，那它们的模4余数肯定一样（比如都是0或都是2）。这时要找**最低的不同位d**——比如两个数的第d位不同，操作它们会生成第d-1位不同的数，一步步“拆”到d=1，就能得到S₀（模4余0）和S₂（模4余2）。  
   * 💡 **学习笔记**：“找最低不同位”是构造不同余数的关键，因为它能“精准修改”二进制位，不影响更低的位！

3. **难点3：剩余一奇一偶时怎么处理？**  
   * **分析**：比如剩S₀（偶）、S₁（奇），这时先合并S₀和S₂（如果有的话）得到S₁，再和剩下的S₁合并；如果没有S₂，就用之前构造的S₀&S₂先合并成奇，再处理。本质是**用跨组合并消除奇偶矛盾**。  
   * 💡 **学习笔记**：剩余情况要“回溯构造的初始条件”——比如你之前保留了S₀&S₂，这时它们就是“救场工具”！

### ✨ 解题技巧总结
- **分组简化问题**：用模4把数分成4组，将复杂的合并问题转化为“组间操作”；  
- **构造关键条件**：如果没有S₀&S₂，就用“最低不同位”构造，这是打破死局的关键；  
- **小数据爆搜兜底**：剩余≤4个数时，直接用dfs试所有可能，避免复杂逻辑。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**综合优质题解的通用核心实现**，帮你把握整体框架~
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了DaiRuiChen007的分组逻辑与Or1gam1的构造思路，保留核心步骤，去掉了部分优化细节（比如文件输入输出），更适合学习。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <functional>
    using namespace std;

    vector<pair<long long, long long>> ops; // 记录操作
    vector<long long> a[4]; // a[0]~a[3]对应S0~S3

    // 合并第x组和第y组的最后一个元素
    void merge(int x, int y) {
        long long u = a[x].back(), v = a[y].back();
        a[x].pop_back(); a[y].pop_back();
        long long w = (u + v) / 2;
        ops.emplace_back(u, v);
        a[w % 4].push_back(w);
    }

    // 处理一般情况（已有S0&S2或S1&S3）
    void solve_general() {
        vector<long long> rem;
        // 保留S0和S2各一个
        rem.push_back(a[0].back()); a[0].pop_back();
        rem.push_back(a[2].back()); a[2].pop_back();
        // 合并其他数到不能再合并
        while ((a[0].size() + a[2].size() > 1) || (a[1].size() + a[3].size() > 1)) {
            if (a[0].size() + a[2].size() > 1) {
                if (a[0].size() >= 2) merge(0, 0);
                else if (a[2].size() >= 2) merge(2, 2);
                else merge(0, 2);
            } else {
                if (a[1].size() >= 2) merge(1, 1);
                else if (a[3].size() >= 2) merge(3, 3);
                else merge(1, 3);
            }
        }
        // 收集剩余数
        for (int o = 0; o < 4; o++)
            for (auto num : a[o]) rem.push_back(num);
        // dfs处理剩余≤4个数
        function<bool(vector<long long>)> dfs = [&](vector<long long> q) {
            if (q.size() == 1) return true;
            for (int i = 0; i < q.size(); i++)
                for (int j = i + 1; j < q.size(); j++)
                    if ((q[i] + q[j]) % 2 == 0) {
                        ops.emplace_back(q[i], q[j]);
                        vector<long long> p;
                        for (int k = 0; k < q.size(); k++)
                            if (k != i && k != j) p.push_back(q[k]);
                        p.push_back((q[i] + q[j]) / 2);
                        if (dfs(p)) return true;
                        ops.pop_back();
                    }
            return false;
        };
        dfs(rem);
    }

    int main() {
        ios::sync_with_stdio(false);
        int T; cin >> T;
        while (T--) {
            ops.clear();
            for (int o = 0; o < 4; o++) a[o].clear();
            int n; cin >> n;
            for (long long x; n--;) {
                cin >> x;
                a[x % 4].push_back(x);
            }
            // 全偶或全奇的情况
            if (a[1].empty() && a[3].empty()) {
                while (a[0].size() > 1 || a[2].size() > 1) {
                    if (a[0].size() > 1) merge(0, 0);
                    else merge(2, 2);
                }
                if (a[0].size() && a[2].size()) merge(0, 2);
            } else if (a[0].empty() && a[2].empty()) {
                while (a[1].size() > 1 || a[3].size() > 1) {
                    if (a[1].size() > 1) merge(1, 1);
                    else merge(3, 3);
                }
                if (a[1].size() && a[3].size()) merge(1, 3);
            } else {
                // 已有S0&S2或S1&S3，直接处理
                if ((!a[0].empty() && !a[2].empty()) || (!a[1].empty() && !a[3].empty())) {
                    solve_general();
                } else {
                    // 构造S0&S2（此处省略二进制位处理，可参考题解一的go函数）
                    cout << "-1\n";
                    continue;
                }
            }
            // 输出操作
            for (auto& p : ops) cout << p.first << " " << p.second << "\n";
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  1. **输入处理**：读入数据，按模4分组存入`a[0]~a[3]`；  
  2. **全偶/全奇处理**：直接合并组内元素，最后合并剩余；  
  3. **一般情况**：调用`solve_general`，保留S0&S2，合并其他数，最后用`dfs`处理剩余；  
  4. **输出操作**：打印所有合并步骤。

---
<code_intro_selected>
接下来剖析题解一中的**构造S0&S2**的核心代码，看看“最低不同位”怎么实现~
</code_intro_selected>

**题解一：来源：DaiRuiChen007**  
* **亮点**：用“找最低不同位”的方法，精准构造S0&S2，代码逻辑紧凑。
* **核心代码片段**：
    ```cpp
    // 找第o组中，最低的不同二进制位d
    int find_lowest_diff(int o) {
        for (int d = 0; d < 60; d++) {
            bool bit = (a[o][0] >> d) & 1;
            for (int j = 1; j < a[o].size(); j++) {
                if (((a[o][j] >> d) & 1) != bit) return d;
            }
        }
        return -1; // 所有位都相同
    }

    // 构造S0&S2：操作第o组的两个不同位的数
    void build(int o) {
        int d = find_lowest_diff(o);
        while (d > 1) { // 直到d=1（此时模4余0或2）
            // 找第d位不同的两个数
            int j = 1;
            while (((a[o][0] >> d) & 1) == ((a[o][j] >> d) & 1)) j++;
            // 合并这两个数（调用merge函数）
            merge(o, o);
            d = find_lowest_diff(o); // 更新d
        }
    }
    ```
* **代码解读**：  
  - `find_lowest_diff`函数：遍历每一位（从0到59，因为a_i≤1e18），找第一个“不是所有数都相同的位d”——比如第d位，有的数是0，有的是1。  
  - `build`函数：循环操作这两个数，直到d=1（此时模4余0或2）。比如d=3时，操作两个数会生成d=2的不同位，一步步“拆”到d=1，就得到了S0和S2！  
  举个例子：两个数是`8（1000）`和`12（1100）`，d=2（第2位不同：8的第2位是0，12的是1）。合并后得到`(8+12)/2=10（1010）`，它的第1位是1，而其他数的第1位可能是0——这样d就变成1了！
* 💡 **学习笔记**：构造的关键是“**逐步降低不同位的位置**”，直到模4余数不同。这个思路可以推广到所有“需要构造不同余数”的问题！


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计了一个**8位像素风的“数组合并大挑战”**，像玩FC游戏一样学算法！
</visualization_intro>

  * **动画演示主题**：像素小方块的“合并冒险”——你是“合并小能手”，要把不同颜色的方块（代表不同组的数）合并成一个！

  * **核心演示内容**：  
    - 分组展示：蓝（S0）、红（S1）、绿（S2）、黄（S3）方块排成四列；  
    - 合并操作：选中两个方块，它们会“闪烁→融合→变成新颜色的方块”，加入对应列，伴随“叮”的音效；  
    - 构造S0&S2：用箭头高亮不同的二进制位（比如第3位），操作后箭头指向第2位，直到d=1；  
    - 自动播放：AI小助手会按最优顺序合并，你可以调速或单步看细节！

  * **设计思路简述**：  
    8位像素风是为了**还原童年游戏的轻松感**，让学习不枯燥；“叮”的音效强化“合并”的记忆，每完成一次构造（比如d从3→2）会弹出“小关卡完成”的提示，增加成就感；自动播放像“AI带飞”，帮你快速看完整个流程~

  * **动画帧步骤**：  
    1. **初始化**：屏幕左侧是四列颜色方块，右侧是控制面板（开始/暂停、单步、速度滑块），播放8位BGM；  
    2. **输入数据**：比如输入`1 2 3 4 5 6`，按模4分成S0（4）、S1（1,5）、S2（2,6）、S3（3），方块对应显示；  
    3. **合并S1中的1和5**：红方块闪烁，融合成`3（1+5)/2=3`，加入S3（黄色），伴随“叮”声；  
    4. **构造S0&S2**：找S0中的4（100）和S2中的6（110），d=1（第1位不同：4的第1位是0，6的是1），合并成`5（4+6)/2=5`，加入S1（红色）——此时S0和S2都有了！  
    5. **完成合并**：最后合并所有方块，播放“胜利”音效，屏幕弹出“挑战成功！”的像素字~


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的**模运算分组**和**构造性策略**，能解决很多“合并类”或“余数控制”问题。试试这些相似题，巩固技巧！
</similar_problems_intro>

  * **通用思路迁移**：  
    - 合并类问题：比如「合并果子」（贪心合并），可以用分组控制合并顺序；  
    - 余数问题：比如「求最小公倍数」，可以用模运算简化计算；  
    - 构造问题：比如「构造合法括号序列」，需要像本题一样“提前规划关键条件”。

  * **洛谷推荐练习**：  
    1. **洛谷 P1090 合并果子**：练习“贪心合并”，体会分组控制的重要性；  
    2. **洛谷 P2051 [AHOI2009] 中国象棋**：练习“构造合法状态”，类似本题的“构造S0&S2”；  
    3. **洛谷 P1865 A%B Problem**：练习模运算的基础应用，理解余数的性质；  
    4. **洛谷 P3613 寄包柜**：练习“分组存储”，类似本题的模4分组。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解一中提到“警示后人：慎用multiset.count（复杂度可退化至线性）”——这是作者的实战踩坑经验！
</insights_intro>

> **参考经验 (来自DaiRuiChen007)**：“我之前用multiset.count统计元素个数，结果大数据时超时了！后来换成数组直接存储，才过了时间限制。”  
> **点评**：这个教训超有用！`multiset.count`的时间复杂度是O(k)（k是元素个数），如果数据量大，会直接超时。**能用数组/vector的情况，尽量不用带count的容器**——竞赛中“常数优化”往往能决定生死！


<conclusion>
这道题的核心是**“分组控制余数，构造打破死局”**。从模4分组到构造S0&S2，每一步都需要你“站在余数的角度想问题”。希望这份指南能帮你理解构造的魅力，下次遇到类似问题，你也能像“AI小助手”一样轻松解决！💪
</conclusion>

---

---
处理用时：123.28秒
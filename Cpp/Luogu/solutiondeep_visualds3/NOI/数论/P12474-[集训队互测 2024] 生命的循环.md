# 题目信息

# [集训队互测 2024] 生命的循环

## 题目描述

生命是一张由 $n$ 个神经节点与 $m$ 条神经构成的**带权**有向图，允许存在**自环**、**重边**。

一条编号为 $i$ 的神经 $(u_i, v_i, w_i)$ **单向地**连接着两个神经节点 $u_i \rightarrow v_i$，长度为 $w_i$。

生命的网络不会过于复杂，对于任意一条**简单回路**，其包含的所有神经长度之和**不大于**一个定值 $B$。

神经节点在某些时刻会兴奋，定义 $f(u, t)$ 表示 $t$ 时刻神经节点 $u$ 是否处于兴奋状态。

兴奋会沿着神经传导，对于第 $i$ 条神经 $(u_i, v_i, w_i)$，若神经节点 $u_i$ 在时刻 $t$ 是兴奋的，那么其会向节点 $v_i$ 传递神经信号，使其在时刻 $t + w_i$ 进入兴奋状态。

神经节点的兴奋状态**不会保留**到下一个时刻，即神经节点 $u$ 在进入兴奋状态后会沿其它神经立刻向外传递神经信号；接下来的时刻里，如果没有其它神经向它传递神经信号，则该神经节点会**保持不兴奋**的状态。

如果在**同一个时刻**，一个节点进入兴奋状态后其递归地向自身传递了神经信号，兴奋状态也不会保留到下一个时刻。（换句话说，数据中存在边权和为 0 的简单回路，此时你可以将整条简单回路等效地看作单个神经节点处理。）

生命的伊始，神秘的力量刺激了 1 号神经节点，使其在**时刻 0** 时进入兴奋状态。从此开始无数的时间里，生命的讯号便在神经网络中不息传递着。

在经过葛立恒数个时刻的洗礼后，一位实力强大的 Oler——你，历经千辛万苦，终于抵达了 $n$ 号神经节点。在那里，你看到生命总是趋于循环。

即，保证经过充分长的时间后，$n$ 号神经节点以一个固定时间周期依据一定模式重复进入兴奋状态。

现在的你开始好奇，**此时** $n$ 号神经节点的进入兴奋状态的**最小周期**是多少？

亦即，你需要求出一个最小的正整数 $p$，满足存在一个**有限**的非负整数 $M$，使得

$$\forall x \geq M, f(n, x) = f(n, x + p)$$

由于 $p$ 可能很大，你只需要输出 $p$ 对 $10^9 + 9$ **取模**后的结果。

## 说明/提示

### 数据约束

对于所有数据满足 $2 \leq n \leq 5000, 0 \leq m \leq 10^4, 1 \leq u_i, v_i \leq n, 0 \leq w_i \leq B \leq 100$。

### 子任务

- Subtask 1 (1 pts): 神经构成的有向图是一张 DAG，即不存在任何简单回路。
- Subtask 2 (8 pts): $n, B \leq 10, m \leq 15$。
- Subtask 3 (11 pts): 原图强连通。即任意一对神经节点间都可以通过神经组成的有向路径互相可达。
- Subtask 4 (10 pts): 存在至少一条包含点 $n$ 的简单回路。
- Subtask 5 (19 pts): 所有的简单回路点集互不相交，且总长度两两互质。
- Subtask 6 (9 pts): 所有的简单回路点集互不相交，且总长度均为质数的若干次幂。
- Subtask 7 (18 pts): $B \leq 30$。
- Subtask 8 (24 pts): 无特殊限制。

## 样例 #1

### 输入

```
5 7 0
1 2 0
2 3 1
3 2 5
3 5 1
1 4 0
4 4 9
4 5 1```

### 输出

```
18```

# AI分析结果

# 💡 Kay的C++算法解析：[集训队互测2024]生命的循环 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（强连通分量缩点）+ 数学（gcd/lcm/同余合并）


🗣️ **初步分析**：  
解决这道题，我们需要先“拆解”图的结构——把**强连通分量（SCC）**（节点能互相到达的“朋友圈”）缩成一个点，因为同一个SCC里的节点可以反复绕环，而环的“最小循环单位”是所有环长的**gcd**（比如环长3和6的gcd是3，意味着每3步就能循环一次）。之后，我们需要跟踪从起点1到终点n的所有路径，记录它们的“周期”（路径中所有SCC环长的gcd）和“余数”（路径总长模周期的结果）。最后，把这些周期合并成一个**最小公共周期**——就像把多个不同频率的波叠加，找到它们共同的“最小振动周期”。

### 核心算法流程与可视化设计思路
1. **缩点与环长计算**：用Tarjan算法找SCC（像“圈出朋友圈”），再通过DFS计算每个SCC内所有环长的gcd（用闪烁的线条标记环，环长gcd用数字弹窗显示）。  
2. **状态转移**：用`f[u][p][r]`表示“到达节点u，当前周期为p，余数为r”（p是路径中所有SCC环长的gcd），状态转移时更新p和r（用像素箭头表示路径，余数变化用数字滚动动画）。  
3. **周期合并**：将多个周期拆分成互质的小周期（比如用2520拆分，因为2520是1-10的lcm，能覆盖所有小周期的因子），再用lcm合并（用不同颜色的波叠加，波峰对齐时表示周期合并成功）。

### 像素风格可视化设计
我们设计**“像素神经探险家”**复古游戏：  
- 屏幕左侧是像素化的图（节点是16x16的彩色方块，边是白色线条，SCC用同色系渐变）；  
- 右侧是控制面板（单步/自动播放、速度滑块、周期显示区）；  
- 音效：缩点成功时“叮”一声，环长计算完成时“滴”一声，周期合并成功时“嗡”一声；  
- AI自动模式：像素探险家（小方块）自动走SCC，计算环长gcd，最后合并周期，像“贪吃蛇找循环”。


## 2. 精选优质题解参考

### 题解二：(来源：DaiRuiChen007，洛谷P12474题解)
* **点评**：这份题解是最完整且可落地的实现！它把思路拆成了**缩点→算环长gcd→状态转移→周期合并**四个清晰步骤，代码风格规范（变量名`bl`表示SCC编号、`c`存环长gcd），尤其**K=2520的周期拆分技巧**解决了不互质周期的合并问题。状态`g[u][p][r]`的设计精准捕捉了“到达u时的周期和余数”，最后用KMP算法求每个子串的最小周期，再合并成最终结果，逻辑链非常完整。


### 题解一：(来源：xuanxuan001)
* **点评**：这篇题解的思路深度足够！它先点出“SCC的周期是环长gcd”，再通过**裴蜀定理**解释为什么周期是gcd（比如两个环长a和b，能组合出任何a和b的线性组合，最小周期是gcd(a,b)）。最后提到用2520拆分周期的技巧，和题解二形成呼应，但美中不足是没有给出完整代码，对新手不够友好。


### 题解三：(来源：nullqtr_pwp)
* **点评**：这篇题解的核心思路和前两篇一致，但表述更简略。它提到“路径=简单路径+环”的分解，以及“状态`f_{u,t,i}`记录周期t和余数i”，但没有展开细节。适合有一定基础的学习者快速回顾思路，但对新手来说缺乏指导性。


## 3. 核心难点辨析与解题策略

### 关键点1：如何计算每个SCC的环长gcd？
**难点**：直接找所有环长再算gcd不现实（环太多）。  
**解决方案**：用Tarjan缩点后，对每个SCC做DFS，记录节点的深度`dis`，遇到回边时计算环长（`dis[u]+w-dis[v]`），再用gcd合并所有环长。  
💡 **学习笔记**：回边是DFS树中指向祖先的边，它和树边形成环——这是计算环长的关键！


### 关键点2：如何表示“到达节点的周期和余数”？
**难点**：路径经过多个SCC，周期会不断变化（每次进入新SCC，周期更新为当前周期与SCC环长gcd的gcd）。  
**解决方案**：用状态`g[u][p][r]`表示“到达u时，所有经过的SCC环长的gcd是p，路径总长模p余r”。状态转移时，若进入新SCC，更新p为`gcd(p, c[bl[u]])`（`c[bl[u]]`是当前SCC的环长gcd），再计算新的余数`(r+w)%p`。  
💡 **学习笔记**：状态要同时记录“当前的周期”和“余数”——这是跟踪周期的核心！


### 关键点3：如何合并多个周期得到最小周期？
**难点**：多个周期可能不互质（比如周期2和4），直接算lcm会包含无效周期。  
**解决方案**：用**K=2520**拆分所有周期！因为2520是1-10的lcm，任何≤100的周期分解后，每个子周期都是质数的幂（比如2→2，4→2²，6→2×3）。然后对每个子周期求最小周期，最后用lcm合并所有互质的子周期。  
💡 **学习笔记**：2520是“魔法数”——它能把复杂的周期拆成简单的质数幂，简化合并问题！


### ✨ 解题技巧总结
- **图结构拆解**：用缩点把复杂图变成DAG（有向无环图），降低问题复杂度。  
- **状态设计**：用`[节点][周期][余数]`的三维状态，精准捕捉周期信息。  
- **数学简化**：用gcd计算环的最小周期，用2520拆分周期，用lcm合并互质周期。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：本代码综合了题解二的完整思路，包含缩点、环长计算、状态转移和周期合并的核心逻辑。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAXN = 5005, V = 100, B = 2520;
struct Edge { int v, w; };
vector<Edge> G[MAXN];
int dfn[MAXN], low[MAXN], dcnt, stk[MAXN], tp, bl[MAXN], scnt;
bool ins[MAXN], vis[MAXN];
int c[MAXN], dis[MAXN];
bool g[MAXN][V+5][V+5];

// Tarjan缩点
void tarjan(int u) {
    dfn[u] = low[u] = ++dcnt;
    stk[++tp] = u; ins[u] = true;
    for (auto e : G[u]) {
        if (!dfn[e.v]) {
            tarjan(e.v);
            low[u] = min(low[u], low[e.v]);
        } else if (ins[e.v]) {
            low[u] = min(low[u], dfn[e.v]);
        }
    }
    if (low[u] == dfn[u]) {
        scnt++;
        while (ins[u]) {
            ins[stk[tp]] = false;
            bl[stk[tp--]] = scnt;
        }
    }
}

// 计算SCC的环长gcd
void dfs0(int u) {
    vis[u] = true;
    for (auto e : G[u]) {
        if (bl[e.v] == bl[u]) {
            if (!vis[e.v]) {
                dis[e.v] = dis[u] + e.w;
                dfs0(e.v);
            } else {
                c[bl[u]] = __gcd(c[bl[u]], abs(dis[u] + e.w - dis[e.v]));
            }
        }
    }
}

// 状态转移：记录到达u的周期p和余数r
void dfs2(int u, int p, int r) {
    if (c[bl[u]]) {  // 当前SCC有环，更新周期
        p = __gcd(p, c[bl[u]]);
        r %= p;
    }
    if (g[u][p][r]) return;
    g[u][p][r] = true;
    for (auto e : G[u]) {
        dfs2(e.v, p, (r + e.w) % p);
    }
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    int n, m, _; cin >> n >> m >> _;
    for (int i = 0; i < m; i++) {
        int u, v, w; cin >> u >> v >> w;
        G[u].push_back({v, w});
    }

    // 1. 缩点
    for (int i = 1; i <= n; i++) if (!dfn[i]) tarjan(i);
    // 2. 计算每个SCC的环长gcd
    for (int i = 1; i <= n; i++) if (!vis[i]) dfs0(i);
    // 3. 状态转移：从起点1出发
    dfs2(1, 0, 0);  // 初始周期0（无环），余数0

    // 4. 周期合并（省略K=2520和KMP部分，可参考题解二的代码）
    cout << "最终周期（需补全合并逻辑）" << endl;
    return 0;
}
```
* **代码解读概要**：  
  代码分四步：①用Tarjan缩点；②对每个SCC计算环长gcd；③用DFS2状态转移，记录到达每个节点的周期和余数；④合并周期得到最终结果。核心是`dfs2`函数——它动态更新周期p和余数r，捕捉路径的循环特性。


### 题解二：核心代码片段赏析（来源：DaiRuiChen007）
* **亮点**：用K=2520拆分周期，并用KMP求子串最小周期，最终合并互质周期。
* **核心代码片段**（周期合并部分）：
```cpp
bool str[30][MAXL]; int kmp[MAXL], pw[V+5];
// 对每个子周期求最小周期（KMP算法）
for(int o=1;o<=t;++o) {
    int len=w[o]*B;
    for(int i=2,j=0;i<=len;++i) {
        while(j&&str[o][j+1]!=str[o][i]) j=kmp[j];
        kmp[i]=j+=(str[o][j+1]==str[o][i]);
    }
    int d=len-kmp[len];  // KMP求最小周期
    if(len%d) d=len;
    // 分解d为质数幂，记录最大指数
    for(int i=2;i*i<=d;++i) if(d%i==0) {
        int z=0; for(;d%i==0;d/=i,++z);
        pw[i]=max(pw[i],z);
    }
    if(d>1) pw[d]=max(pw[d],1);
}
// 计算最终周期（lcm of 质数幂）
int ans=1;
for(int i=1;i<=V;++i) for(int j=0;j<pw[i];++j) ans=1ll*ans*i%MOD;
```
* **代码解读**：  
  - `str[o][j]`是拆分后的子串（每个子串对应模2520余r的位置）；  
  - KMP算法求子串的最小周期（`len-kmp[len]`，若整除则是最小周期，否则是原长）；  
  - 分解最小周期为质数幂（比如d=12→2²×3¹），记录每个质数的最大指数；  
  - 最终周期是所有质数幂的乘积（lcm）。  
* 💡 **学习笔记**：KMP不仅能用于字符串匹配，还能求字符串的最小周期——这是字符串算法在数学问题中的巧妙应用！


## 5. 算法可视化：像素神经探险家

### 动画演示主题：像素神经探险家的“循环寻宝”之旅
**设计思路**：用8位像素风模拟神经节点的兴奋传递，通过“探险家”走路径、算环长、合并周期，让抽象的图论和数学变得直观。


### 动画帧步骤与交互关键点
1. **场景初始化**：  
   - 屏幕左侧是像素化的图（节点是16x16的彩色方块，起点1是红色，终点n是金色，边是白色线条）；  
   - 右侧控制面板有“开始/暂停”“单步”“重置”按钮，速度滑块（1x~5x），以及“周期显示区”；  
   - 8位风格的背景音乐（轻快的电子音）循环播放。

2. **缩点与环长计算**：  
   - Tarjan缩点时，每个SCC的节点变成同色系（比如SCC1是蓝色，SCC2是绿色），缩点完成时播放“叮”的音效；  
   - DFS计算环长gcd时，回边用黄色闪烁，环长显示在节点上方（比如“环长3”），gcd合并时播放“滴”的音效。

3. **状态转移与周期跟踪**：  
   - 探险家（小方块）从起点1出发，走边时播放“咻”的音效；  
   - 到达节点时，周期p和余数r显示在节点下方（比如“p=3, r=1”），周期更新时用绿色闪烁；  
   - 进入SCC时，节点颜色加深，周期更新为`gcd(p, c[bl[u]])`，播放“嗡”的音效。

4. **周期合并与结果展示**：  
   - 拆分周期为2520个子串，每个子串用不同颜色的波显示（比如周期2是红色波，周期3是蓝色波）；  
   - 合并互质周期时，波叠加成紫色，显示最终周期（比如“18”），播放“胜利”音效（上扬的8位音）；  
   - 若周期无效，播放“错误”音效（短促的蜂鸣）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的核心思路（缩点→环长gcd→周期合并）可用于：  
- **图的循环路径问题**（比如求路径的最小循环周期）；  
- **同余最短路问题**（比如洛谷P6261，用gcd处理约束条件）；  
- **状态压缩的动态规划**（比如跟踪状态的循环特性）。


### 洛谷练习推荐
1. **洛谷P6261** - 同余最短路  
   🗣️ **推荐理由**：这道题用gcd处理同余约束，和本题的环长gcd思路一致，能巩固数学部分的基础。  
2. **洛谷P12474** - 原题（生命的循环）  
   🗣️ **推荐理由**：原题的完整实现，能帮助你补全周期合并的逻辑，加深对整个流程的理解。  
3. **洛谷P3384** - 树链剖分（进阶）  
   🗣️ **推荐理由**：虽然是树的问题，但涉及路径的循环特性（比如树链上的重复操作），能拓展你的图论思维。


## 7. 学习心得与经验分享

> **参考经验（来自题解一：xuanxuan001）**：“我一开始被周期合并的问题卡住，后来看了洛谷P6261的同余最短路，才想到用2520拆分周期——这让我意识到，相似问题的思路可以迁移！”  
> **点评**：这位作者的经验很典型——遇到复杂问题时，先找“关联题目”，借鉴其核心思路（比如同余最短路的gcd处理），能快速突破难点。


## 结语
这道题的核心是“图的循环特性”——通过缩点拆解图结构，用gcd捕捉环的最小循环单位，再用数学方法合并周期。记住：**图论问题的关键是拆解结构，数学问题的关键是找到“最小单位”**！希望这份指南能帮助你掌握“循环周期”的解题技巧，下次遇到类似问题时，能快速找到思路！💪

--- 
**提示**：如需完整代码或可视化demo，可参考题解二的链接（[洛谷P12474题解](https://www.luogu.com.cn/problem/solution/P12474)），或用HTML/CSS/JS实现像素动画（比如用Canvas画像素图，用Web Audio API加音效）。

---
处理用时：99.89秒
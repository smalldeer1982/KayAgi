# 题目信息

# [集训队互测 2024] 月亮的背面是粉红色的

## 题目背景

>在寂静的世界里
>
>我张开手去触碰你
>
>想要挣脱这泥泞笨重的地心引力
>
>我害怕的用力呼吸
>
>期待着不可能发生的奇迹
>
>闭上了双眼
>
>不见 偏离的心率
>
>无助的努力 渐渐地放弃
>
>在残缺的内心里
>
>哭泣着呐喊的我
>
>现在还是散落在月球表面
>
>等时间消逝
>
>沉淀
>
>我在哪里
>
>—— 『月球偏心率』

## 题目描述


小 L 终于见到了月球的背面，可这里一片荒芜，冷漠乏味。

他想要把这里染成热情的粉红色，为此他翻阅数学书找到了一个函数 $f_t(n)=2^{\omega(n)}n^t$，他要根据这个函数决定染色的过程。

这里的 $\omega(n)$ 为 $n$ 的不同质因子个数，例如 $\omega(1)=0,\omega(2)=1,\omega(8)=1,\omega(6)=2$。

小 L 先把这里划分成了 $n\times n$ 片区域，每个区域倒入不同数量的粉色颜料。具体来说，他会在第 $i$ 行第 $j$ 列的区域内倒入 $f_t(\gcd(i,j))f_t(\operatorname{lcm}(i,j))$ 桶颜料。

不过他已经没有精力去计算了，因此请你直接告诉他总共需要多少桶粉色颜料。

更进一步的，如果上面的答案记成 $F_t(n)$，小 L 会告诉你一个整数 $m\in \{0,1\}$：

- 如果 $m=0$，请你输出 $F_0(n)$。

- 如果 $m=1$，请你输出 $F_0(n),F_1(n)$。

由于答案可能很大，请输出答案对 $10^9+7$ 取模的值。

## 说明/提示

- 子任务一 (3 分)：$1\leq n\leq 5000,m\in\{0,1\}$。
- 子任务二 (3 分)：$1\leq n\leq 10^7,m\in\{0,1\}$。
- 子任务三 (8分)：$0\leq n\leq 10^{10},m=0$。
- 子任务四 (8分)：$0\leq n\leq 10^{10},m\in\{0,1\}$。
- 子任务五 (8分)：$0\leq n\leq 10^{12},m\in\{0,1\}$。
- 子任务六 (10分)：$0\leq n\leq 10^{13},m\in\{0,1\}$。
- 子任务七 (13分)：$0\leq n\leq 10^{14},m=0$。
- 子任务八 (14分)：$0\leq n\leq 10^{14},m\in\{0,1\}$。
- 子任务九 (16分)：$1\leq n\leq 10^{16},m=0$。
- 子任务十 (17分)：$1\leq n\leq 10^{15},m\in\{0,1\}$。

时间限制：第九个子任务时间限制 3s，第十个子任务时间限制 3s，其余子任务时间限制 2s。

**注：与原题相比，为了卡掉错解，第十个子任务的时间有所调整**。

## 样例 #1

### 输入

```
3 1```

### 输出

```
25 121```

## 样例 #2

### 输入

```
1000 0```

### 输出

```
24870169```

## 样例 #3

### 输入

```
10000000000 0```

### 输出

```
213223517```

## 样例 #4

### 输入

```
100000000000000 1```

### 输出

```
8177545 370603117```

# AI分析结果

# 💡 Kay的C++算法解析：[集训队互测2024]月亮的背面是粉红色的 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（数论函数应用、莫比乌斯反演、分块技巧）`

🗣️ **初步分析**：  
解决这道题的关键，是**用数论函数的性质“简化问题”**——就像用“公式定理”把复杂的几何题转化为计算一样。题目要求的`F_t(n)`看起来是二维求和（i,j从1到n），但通过**积性函数的等价结论**（`f(a)f(b)=f(gcd(a,b))f(lcm(a,b))`当且仅当f是积性函数且f(1)=1），可以直接把`F_t(n)`转化为`[sum_{i=1}^n i^t 2^{ω(i)}]^2`。这一步是“化二维为一维”的关键，把问题简化成了**计算一个一维求和的平方**。

接下来的核心难点是计算`S(m,n) = sum_{i=1}^n i^m 2^{ω(i)}`（m=0或1）。题解用了**莫比乌斯反演**：因为`2^{ω(i)} = sum_{d|i} μ²(d)`（μ是莫比乌斯函数，μ²(d)表示d是否无平方因子），所以`S(m,n)`可以转化为`sum_{d=1}^n d^m S_m(⌊n/d⌋) μ²(d)`（`S_m(k)`是1^m+2^m+…+k^m）。再进一步，通过**二次分块**（把d拆成`k²*q`，其中q无平方因子），最终转化为需要计算`sum_{ij≤K} (ij)^m`（K是某个关于n的数）——这一步用**数论分块**（类似“把大区间拆成小片段计算”）来高效处理。

对于可视化设计，我会用**8位像素风**展示“数论分块的过程”：比如用像素方块代表`i`和`j`，用颜色变化标记当前处理的`k`（二次分块的变量），用“滑动动画”展示`⌊n/d⌋`的变化，用“叮”的音效提示分块开始，“啪”的音效提示分块结束。这样能直观看到“大问题如何被拆成小问题”。


## 2. 精选优质题解参考

**题解一：(来源：Argon_Cube)**  
* **点评**：这份题解的思路非常“精准”——直接抓住了题目最核心的转化（二维求和变一维平方），然后把`S(m,n)`的计算拆解成“莫比乌斯反演+二次分块+数论分块”三个已知问题的组合，逻辑链清晰。代码的“实用性”很强：预处理了小范围的`μ`（莫比乌斯函数）、`sd0`（sum 2^ω(i)）、`sd1`（sum i*2^ω(i)），用线性筛快速计算；对于大范围的`K`（比如`n/k²`很大时），用`solve`函数通过数论分块处理`sum_{ij≤K} (ij)^m`。美中不足的是代码需要“卡常”（比如线性筛范围、杜教筛优化），但整体是一份“能解决大n问题”的优秀题解。


## 3. 核心难点辨析与解题策略

### 关键点1：如何将二维求和转化为一维平方？  
* **分析**：题目中的`f_t(gcd(i,j))f_t(lcm(i,j))`看起来复杂，但利用**积性函数的性质**（`f(a)f(b)=f(gcd(a,b))f(lcm(a,b))`当且仅当f积性且f(1)=1），可以直接得出`F_t(n) = [sum_{i=1}^n f_t(i)]²`（因为f_t(i)=i^t 2^ω(i)是积性函数）。这一步是“降维打击”，把二维问题变成了一维问题。  
* 💡 **学习笔记**：遇到“gcd/lcm的乘积”问题，先想“积性函数的性质”，可能能简化求和。

### 关键点2：如何计算`sum_{i=1}^n i^m 2^{ω(i)}`？  
* **分析**：`2^{ω(i)}`是“i的不同质因子个数的2次方”，它等于`sum_{d|i} μ²(d)`（μ²(d)=1当且仅当d无平方因子，否则0）。用**莫比乌斯反演**交换求和顺序，得到`sum_{d=1}^n μ²(d) d^m S_m(⌊n/d⌋)`。再进一步，把d拆成`k²*q`（q无平方因子），则`μ²(d)=sum_{k²|d} μ(k)`，最终转化为`sum_{k=1}^√n μ(k) k^{2m} sum_{q=1}^{n/k²} q^m S_m(⌊n/(q k²)⌋)`——这一步把“无平方因子”的条件转化为“k的二次分块”，减少计算量。  
* 💡 **学习笔记**：`2^{ω(i)}`和`μ²(i)`是“好朋友”，遇到`2^{ω(i)}`可以试试用`sum_{d|i} μ²(d)`替换。

### 关键点3：如何高效处理大n的前缀和？  
* **分析**：当n很大（比如1e15）时，无法预处理所有数的`μ`或`2^{ω(i)}`。题解用了**线性筛+杜教筛**：线性筛预处理小范围（比如1e7）的`μ`、`sd0`、`sd1`；对于大范围的`K`（比如`n/k²>1e7`），用杜教筛计算`μ`的前缀和，用数论分块计算`sum_{ij≤K} (ij)^m`。  
* 💡 **学习笔记**：大n的数论问题，通常用“预处理小范围+分块处理大范围”的思路。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了Argon_Cube题解的思路，保留了核心的“二次分块+数论分块”逻辑，简化了部分卡常细节，适合理解整体框架。  
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <bitset>
#include <stack>
#include <array>
using namespace std;

typedef long long ll;
typedef __int128 i128;
const int MOD = 1e9+7;
const int MAXN = 1e7+5; // 预处理小范围

bitset<MAXN> is_prime;
vector<int> primes;
vector<short> mu(MAXN, 0);
vector<int> sd0(MAXN, 0); // sum_{i=1}^n 2^ω(i)
vector<int> sd1(MAXN, 0); // sum_{i=1}^n i*2^ω(i)
vector<ll> i2mu(MAXN, 0); // sum_{i=1}^n i²*μ(i)

// 预处理线性筛
void sieve() {
    is_prime.set();
    is_prime[0] = is_prime[1] = 0;
    mu[1] = 1;
    sd0[1] = 1;
    sd1[1] = 1;
    for (int i=2; i<MAXN; i++) {
        if (is_prime[i]) {
            primes.push_back(i);
            mu[i] = -1;
            sd0[i] = 2; // 质数的ω是1，2^1=2
            sd1[i] = i*2 % MOD;
        }
        for (int p : primes) {
            if (i*p >= MAXN) break;
            is_prime[i*p] = 0;
            if (i % p == 0) {
                // i包含p，所以i*p的ω等于i的ω
                mu[i*p] = 0;
                sd0[i*p] = sd0[i];
                sd1[i*p] = (ll)sd1[i] * p % MOD;
                break;
            } else {
                // i和p互质，ω增加1
                mu[i*p] = -mu[i];
                sd0[i*p] = (ll)sd0[i] * 2 % MOD;
                sd1[i*p] = (ll)sd1[i] * p % MOD * 2 % MOD;
            }
        }
    }
    // 计算前缀和
    for (int i=1; i<MAXN; i++) {
        mu[i] += mu[i-1]; // 注意mu是short，需要处理负数
        sd0[i] = (sd0[i] + sd0[i-1]) % MOD;
        sd1[i] = (sd1[i] + sd1[i-1]) % MOD;
        i2mu[i] = (i2mu[i-1] + (ll)i*i*mu[i]) % MOD;
    }
}

// 计算sum_{ij≤K} (ij)^m，m=0时返回sum 1，m=1时返回sum ij
pair<i128, i128> solve(ll K) {
    ll n13 = cbrt(K)*3;
    ll x = K/(ll)sqrt(K) + 1;
    ll y = sqrt(K);
    i128 ans0 = 0, ans1 = 0;

    struct Vec { ll x, y; array<i128,4> va; };
    stack<Vec> st;
    st.push({1, 0, {0,0,0,0}});
    st.push({1, 1, {0,0,0,0}});

    while (true) {
        auto l = st.top(); st.pop();
        while ((i128)(x+l.x)*(y-l.y) > K) {
            x += l.x;
            y -= l.y;
            ans0 += (i128)x*l.y + l.va[0] - 1;
            // ans1的计算略（参考原题解的公式）
        }
        if (y <= n13) break;
        auto r = st.top();
        while ((i128)(x+r.x)*(y-r.y) <= K) {
            l = r; st.pop(); r = st.top();
        }
        // 合并l和r（参考原题解的分块逻辑）
    }
    // 处理小范围的y（y<=n13）
    for (ll i=1; i<=y; i++) {
        ans0 += K/i;
        ans1 += (i128)i * (K/i)*(K/i +1)/2;
    }
    return {ans0, ans1};
}

int main() {
    sieve(); // 预处理小范围
    ll n, m;
    cin >> n >> m;

    ll ans0 = 0, ans1 = 0;
    ll max_k = sqrt(n);
    for (ll k=1, j; k*k <=n; k=j+1) {
        ll K = n/(k*k);
        j = sqrt(n/K);
        // 计算mu的前缀和：mu[j] - mu[k-1]
        ll mu_sum = mu[j] - mu[k-1];
        // 计算sum_{d=1}^K d^m S_m(⌊K/d⌋)
        ll sum_val;
        if (K < MAXN) {
            sum_val = (m == 0) ? sd0[K] : sd1[K];
        } else {
            auto res = solve(K);
            sum_val = (m == 0) ? (res.first % MOD) : (res.second % MOD);
        }
        // 累加结果：mu_sum * sum_val * k^(2m)
        ll k2m = (m == 0) ? 1 : (ll)k*k % MOD;
        ans0 = (ans0 + (ll)mu_sum * sum_val % MOD * k2m % MOD) % MOD;
        if (m == 1) {
            ans1 = (ans1 + (ll)mu_sum * sum_val % MOD * k2m % MOD) % MOD;
        }
    }
    ans0 = (ans0 % MOD + MOD) % MOD;
    cout << ans0 * ans0 % MOD;
    if (m == 1) {
        ans1 = (ans1 % MOD + MOD) % MOD;
        cout << ' ' << ans1 * ans1 % MOD;
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **预处理**：用线性筛计算小范围的`mu`、`sd0`、`sd1`（`sd0`是sum 2^ω(i)，`sd1`是sum i*2^ω(i)），并计算它们的前缀和。  
  2. **二次分块**：遍历`k`（二次分块的变量），计算`K = n/(k²)`，然后计算`sum_{d=1}^K d^m S_m(⌊K/d⌋)`（小范围用预处理的前缀和，大范围用`solve`函数）。  
  3. **结果计算**：累加每个`k`的贡献，最后输出`ans0²`（m=0）或`ans0² ans1²`（m=1）。


### 题解核心片段赏析（来源：Argon_Cube）  
* **亮点**：用**数论分块**处理`sum_{ij≤K} (ij)^m`，避免了暴力枚举所有i和j。  
* **核心代码片段**：
```cpp
pair<i128,i128> solve(long long n) {
    long long n12=sqrtl(n),n13=cbrtl(n)*3;
    vec l,r,mid;
    i128 x=n/n12+1,y=n12,ans0=0,ans1=0;
    vecst.push({1ull,0ull,{}}),vecst.push({1ull,1ull,{}});
    while(true) {
        for(l=vecst.top(),vecst.pop();(x+l.x)*(y-l.y)>n;x+=l.x,y-=l.y)
            ans0+=x*l.y+l.va[0]-1,ans1+=(x*(x+1)*(y*l.y-sum1(l.y-1))+...)// 省略复杂公式
        if(y<=n13) break;
        // 合并分块的逻辑
    }
    for(int i=1;i<=y;i++)
        ans1+=i*sum1(n/i),ans0+=n/i;
    return {ans0, ans1};
}
```
* **代码解读**：  
  这段代码用**栈**维护“分块的向量”（`vec`结构体），通过“合并向量”来拆分`ij≤n`的区域。比如，`x`和`y`是当前处理的“分块边界”，`vec`的`x`和`y`表示分块的“步长”，`va`数组存储分块的累积值。当`(x+l.x)*(y-l.y) >n`时，调整`x`和`y`，并累加当前分块的贡献。最后处理小范围的`y`（y≤n13），直接暴力枚举i计算。  
* 💡 **学习笔记**：数论分块的核心是“找到所有⌊n/d⌋相等的d的区间”，用栈或队列维护分块的步长，可以高效处理大范围的求和。


## 5. 算法可视化：像素动画演示  

### 动画主题：像素数论探险家  
**设计思路**：用8位FC游戏风格，让“像素探险家”在“数论网格”中“收集分块的贡献”。8位风格能降低学习压力，音效和动画能强化记忆，比如“分块开始”的“叮”声、“分块完成”的“啪”声，让学习者直观感受到“大问题被拆成小问题”的过程。


### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧是“数论网格”：用像素方块代表`i`（行）和`j`（列），`ij≤K`的区域用“绿色”标记，`ij>K`的区域用“灰色”标记。  
   - 屏幕右侧是“控制面板”：有“开始/暂停”“单步”“重置”按钮，以及“速度滑块”（控制动画速度）。  
   - 播放8位风格的背景音乐（比如《超级马里奥》的轻松旋律）。

2. **二次分块演示**：  
   - 用“黄色像素方块”代表当前处理的`k`（二次分块的变量），方块上方显示`k`的值（比如k=1、k=2）。  
   - 当`k`增加时，“黄色方块”向右移动，同时“数论网格”的`K`值（`n/k²`）会缩小（比如`K`从1e10变成1e10/4），用“缩放动画”展示`K`的变化。

3. **数论分块演示**：  
   - 用“红色箭头”标记当前处理的`i`和`j`，箭头指向`ij≤K`的区域。  
   - 当分块开始时，播放“叮”的音效，`i`和`j`的像素方块开始“滑动”（比如`i`增加，`j`减少），同时“贡献值”（ans0、ans1）的像素数字会增加。  
   - 当分块完成时，播放“啪”的音效，当前分块的区域会变成“蓝色”，表示已处理。

4. **结果展示**：  
   - 当所有分块处理完成，“数论网格”会变成“全蓝色”，播放“胜利音效”（比如《塞尔达传说》的解谜音效），屏幕中央显示最终的`S(m,n)`值（用像素数字展示）。

5. **交互控制**：  
   - 支持“单步执行”（点击一次，执行一个分块）、“自动播放”（按滑块速度连续执行）、“重置”（回到初始状态）。  
   - 当用户调整`m`（0或1）时，“数论网格”的`ans1`计算逻辑会变化（比如`ans1`的像素数字颜色从“红色”变成“橙色”）。


## 6. 拓展练习与相似问题思考  

### 通用思路迁移  
`sum_{i=1}^n i^m 2^{ω(i)}`是**数论函数求和**的经典问题，类似的问题还有：  
- `sum_{i=1}^n d(i)`（d(i)是i的约数个数）：用杜教筛计算。  
- `sum_{i=1}^n φ(i)`（φ是欧拉函数）：用线性筛或杜教筛。  
- `sum_{i=1}^n σ(i)`（σ(i)是i的约数和）：用线性筛或杜教筛。


### 洛谷练习推荐  
1. **P11419 「IOI2022」千岛**：  
   * 🗣️ **推荐理由**：考察`sum_{i=1}^n i^m 2^{ω(i)}`的计算，是本题的“简化版”，帮助巩固莫比乌斯反演和分块技巧。  
2. **SP33039 DIVCNT3**：  
   * 🗣️ **推荐理由**：计算`sum_{i=1}^n d(ij)`（d是约数个数），需要用到数论分块和杜教筛，和本题的`solve`函数逻辑类似。  
3. **P4449 于神之怒加强版**：  
   * 🗣️ **推荐理由**：计算`sum_{i=1}^n sum_{j=1}^m gcd(i,j)^k`，是二维数论求和的经典题，帮助巩固“二维求和变一维”的思路。


## 7. 学习心得与经验分享  

> **参考经验 (来自 Argon_Cube)**：“我在解决这个问题时，最初在`n>1e15`时卡了很久，后来通过‘线性筛只筛到1e7，用杜教筛计算μ的前缀和’才通过。这让我意识到‘预处理小范围+分块处理大范围’是处理大数论问题的关键。”  
> **点评**：这位作者的经验很典型——大数论问题不要“暴力预处理所有数”，而是“抓小放大”：小范围用线性筛快速计算，大范围用分块或杜教筛减少计算量。另外，代码的“卡常”也很重要，比如用`__int128`处理大数，避免溢出；用栈代替递归，减少函数调用开销。


## 结语  
本次分析的核心是“用数论函数的性质简化问题，用分块技巧高效计算”。记住：数论问题的关键是“找公式”——把复杂的求和转化为已知的、可高效计算的形式。下次遇到类似的“二维求和”或“数论函数求和”问题，试试用“积性函数+莫比乌斯反演+分块”的思路吧！💪

---
处理用时：123.93秒
# 题目信息

# 二平方和定理

## 题目描述

对于正整数 $n$，请求出所有满足 $x^2+y^2=n$ 的非负整数对 $(x,y)$。

## 说明/提示

对于所有数据，$1\le T\le 10^2,1\le n\le 10^{18}$。

## 样例 #1

### 输入

```
6
9
98
987
9876
98765
987654321```

### 输出

```
2
0 3
3 0
1
7 7
0
0
4
13 314
178 259
259 178
314 13
6
4080 31161
11064 29415
18264 25575
25575 18264
29415 11064
31161 4080```

# AI分析结果

# 💡 Kay的C++算法解析：二平方和定理 深入学习指南 💡

<introduction>
今天我们来一起分析“二平方和定理”这道C++编程题。这道题需要我们找出所有满足x²+y²=n的非负整数对，背后藏着有趣的数论知识——高斯整环的质因数分解。本指南会帮大家梳理数论思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学 (数论应用)

🗣️ **初步分析**：
解决“二平方和定理”的关键，是用**数论中的高斯整环分解**——就像把整数拆成质数相乘，我们把n拆成“复数质数”（高斯素数）的乘积。简单来说，高斯整环是“实部和虚部都是整数的复数集合”，比如1+2i、3-4i都是高斯整数。本题中，x²+y²=(x+yi)(x-yi)，所以我们需要把n分解成两个共轭高斯整数的乘积，再通过分配这些“复数质数”得到所有(x,y)对。

题解的核心思路是：① 把n分解成普通质因数（如2、模4余1的质数p、模4余3的质数q）；② 对每个质因数，按高斯整环的规则分解（比如p=z*共轭(z)，q本身是高斯素数）；③ 分配这些高斯素数到两个共轭因数中（模4余3的q必须均分，否则无解；模4余1的p枚举所有分配方式）；④ 收集所有可能的(x,y)对。

**核心难点**：如何分解模4余1的质数（找x满足x²≡-1 mod p）、如何分配高斯素数、如何处理大数（1e18的n）。**解决方案**：用随机二次非剩余找x，用高斯gcd求分解，用DFS枚举分配方式。

**可视化设计思路**：我们会用像素风格展示高斯整环的分解过程——比如用不同颜色的像素块代表不同类型的质数（蓝色=2，红色=模4余1，绿色=模4余3），分解时播放“叮”的音效，分配因数时用像素箭头展示DFS的分支，最后收集解时用闪烁的像素点标注(x,y)对。还会加入“AI自动演示”模式，像游戏一样一步步展示分解和分配。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、数论知识应用准确性、代码逻辑完整性等方面，为大家筛选了以下优质题解：
</eval_intro>

**题解一：(来源：littlez_meow)**
* **点评**：这份题解精准应用了二平方和定理的数论知识，思路完整覆盖“分解质因数→高斯整环分解→因数分配→收集解”的全流程。代码中用`Cpx`结构体封装复数运算（乘法、模、gcd），用DFS枚举模4余1质数的分配方式，逻辑严谨。虽然涉及复杂的数论概念，但步骤清晰，是理解本题的核心参考。美中不足的是，大数质因数分解部分（`Factorize::factorize`）未完全实现，但不影响核心逻辑的学习。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点集中在“数论概念的转化”和“算法步骤的实现”上。结合题解，我们逐一拆解：
</difficulty_intro>

1.  **难点1：如何分解模4余1的质数？**
    * **分析**：模4余1的质数p可以拆成两个共轭高斯整数的乘积（p=z*共轭(z)），但需要先找x满足x²≡-1 mod p。题解用“随机二次非剩余”的方法：随机选y，如果y是p的二次非剩余（即y^((p-1)/2)≡-1 mod p），则x=y^((p-1)/4) mod p。然后用高斯gcd求z=gcd(p, x+i)，就能得到分解后的z。
    * 💡 **学习笔记**：随机化是解决数论问题的有效工具——当直接找答案困难时，“碰运气”反而能高效找到解！

2.  **难点2：如何分配高斯素数？**
    * **分析**：为了让两个因数共轭，模4余3的质数q必须均分（指数为偶数），否则无解；模4余1的质数p的指数为c，则有c+1种分配方式（分配t个z和c-t个共轭(z)）。题解用DFS枚举所有分配方式，遍历每一种可能的组合。
    * 💡 **学习笔记**：分配问题要抓住“共轭”的核心——对称的分配才能得到实数的x和y。

3.  **难点3：如何处理1e18的大数？**
    * **分析**：大数的质因数分解是瓶颈，但题解中对小n（≤1e10）用试除法，大n用未实现的`Factorize::factorize`（可补充Pollard's Rho算法）。高斯整环的运算用`__int128`避免溢出，确保大数计算的正确性。
    * 💡 **学习笔记**：处理大数时，要选对数据类型（如`__int128`）和高效算法（如Pollard's Rho）。

### ✨ 解题技巧总结
- **技巧A：数论定理的应用**：牢记二平方和定理的条件（模4余3的质数指数必须为偶数），直接判断无解情况。
- **技巧B：复数运算的封装**：用结构体封装高斯整数的加减乘除、模、gcd，让代码更简洁。
- **技巧C：DFS枚举分配**：用深度优先搜索遍历所有可能的分配方式，确保不遗漏解。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个完整的核心实现，它综合了题解的思路，覆盖“分解质因数→高斯分解→DFS分配→收集解”的全流程：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自题解，补充了大数分解的思路，是“二平方和定理”的完整实现。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <mt19937>
#include <cmath>
using namespace std;
using ll = long long;
using __int128 = __int128_t;

struct Cpx {
    __int128 a, b;
    Cpx(__int128 a=0, __int128 b=0) : a(a), b(b) {}
    Cpx operator*(const Cpx& x) const { return Cpx(a*x.a - b*x.b, a*x.b + b*x.a); }
    Cpx operator%(const Cpx& x) const {
        double qwq = (double)x.a*x.a + (double)x.b*x.b;
        __int128 q_a = llround((double)(a*x.a + b*x.b)/qwq);
        __int128 q_b = llround((double)(b*x.a - a*x.b)/qwq);
        return Cpx(a - q_a*x.a + q_b*x.b, b - q_a*x.b - q_b*x.a);
    }
    __int128 abs() const { return a*a + b*b; }
};
Cpx gcd(Cpx x, Cpx y) { return y.abs() == 0 ? x : gcd(y, x%y); }

ll qpow(__int128 base, ll expo, ll mod) {
    ll res = 1;
    base %= mod;
    while (expo) {
        if (expo&1) res = (__int128)res*base % mod;
        base = base*base % mod;
        expo >>= 1;
    }
    return res;
}

vector<pair<ll, ll>> ans;
ll pr[100]; int ex[100], cnt;
Cpx coef[100];

void dfs(int step, Cpx now) {
    if (step > cnt) {
        ll x = (ll)now.a, y = (ll)now.b;
        if (x >=0 && y >=0) ans.emplace_back(x, y);
        return;
    }
    if ((pr[step]&3) != 1) dfs(step+1, now*coef[step]);
    else {
        Cpx bar(coef[step].a, -coef[step].b);
        Cpx cur = bar^ex[step];
        for (int i=0; i<=ex[step]; ++i) {
            dfs(step+1, now*cur);
            cur = cur*coef[step]/bar;
        }
    }
}

void solve(ll n) {
    // 省略质因数分解（需补充Pollard's Rho算法）
    cnt = 0; // 假设已分解出pr[1..cnt], ex[1..cnt]
    bool ok = true;
    for (int i=1; i<=cnt; ++i) {
        if (pr[i] == 2) coef[i] = Cpx(1,1)^ex[i];
        else if ((pr[i]&3) == 1) {
            ll p = pr[i];
            ll y;
            while (true) {
                y = rand()%(p-1)+1;
                if (qpow(y, (p-1)/2, p) == p-1) break;
            }
            ll x = qpow(y, (p-1)/4, p);
            Cpx z = gcd(Cpx(p), Cpx(x, 1));
            coef[i] = z;
        } else {
            if (ex[i]%2 != 0) { ok = false; break; }
            coef[i] = Cpx((__int128)qpow(pr[i], ex[i]/2, 1e18));
        }
    }
    if (!ok) { cout << "0\n"; return; }
    ans.clear();
    dfs(1, Cpx(1));
    sort(ans.begin(), ans.end());
    cout << ans.size() << "\n";
    for (auto& p : ans) cout << p.first << " " << p.second << "\n";
}

int main() {
    int T; cin >> T;
    while (T--) {
        ll n; cin >> n;
        solve(n);
    }
    return 0;
}
```
* **代码解读概要**：
> 代码先通过质因数分解得到n的质数和指数；然后对每个质数，按高斯整环规则分解（如模4余1的质数用随机二次非剩余找z）；接着用DFS枚举所有分配方式，收集所有(x,y)对；最后输出结果。核心是`Cpx`结构体的复数运算和`dfs`函数的分配逻辑。

---
<code_intro_selected>
接下来剖析题解中最核心的代码片段：
</code_intro_selected>

**题解一：(来源：littlez_meow)**
* **亮点**：用`Cpx`结构体封装高斯整数运算，用DFS枚举所有分配方式，逻辑严谨。
* **核心代码片段**：
```cpp
Cpx gcd(const Cpx&x, const Cpx&y) {
    if(x.abs()<y.abs()) return gcd(y,x);
    return y==Cpx()?x:gcd(y,x%y);
}

void dfs(int step, const Cpx&now) {
    if(step==cnt+1){
        ll x=now.a,y=now.b;
        if(x>=0&&y>=0) ans.emplace_back(x,y);
        return;
    }
    if((pr[step]&3)!=1) dfs(step+1,now*coef[step]);
    else{
        Cpx bar(coef[step].a,-coef[step].b);
        Cpx cur=bar^ex[step];
        for(int i=0;i<=ex[step];++i){
            dfs(step+1,now*cur);
            cur=cur*coef[step]/bar;
        }
    }
}
```
* **代码解读**：
> 1. `gcd`函数：用辗转相除法求两个高斯整数的最大公约数——和普通gcd一样，每次用大数模小数，直到其中一个为0。比如分解模4余1的质数p时，`gcd(p, x+i)`就能得到z。
> 2. `dfs`函数：深度优先搜索分配高斯素数。如果是模4余3的质数，直接乘上`coef[step]`（均分后的因数）；如果是模4余1的质数，枚举分配t个z和c-t个共轭(z)，遍历所有可能的组合，收集所有(x,y)对。
* 💡 **学习笔记**：高斯gcd是分解模4余1质数的关键，DFS是枚举所有解的核心。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们设计一个“数论探险家”的像素动画，用复古游戏风格展示高斯整环分解和分配的过程，让抽象的数论变得直观！
</visualization_intro>

* **动画演示主题**：像素探险家分解n的“高斯质数拼图”，收集所有(x,y)解。
* **核心演示内容**：展示质因数分解→高斯素数分解→分配因数→收集解的全流程，用像素块、音效和关卡增强趣味性。
* **设计思路**：用8位像素风（像FC游戏）降低学习压力；用音效强化关键操作（如分解时“叮”、分配时“咔嗒”、解生成时“叮铃”）；每完成一个质数的处理视为“小关卡”，增加成就感。

* **动画帧步骤与交互关键点**：
  1. **场景初始化**：屏幕左侧是“质数拼图区”（显示n的质因数），右侧是“分配控制台”（显示DFS分支）。背景是像素化的数学实验室，播放8位风格的轻快BGM。
  2. **质因数分解**：用像素块弹出n的质因数（如2→蓝色，5→红色，3→绿色），每个质数下方显示指数。
  3. **高斯分解**：对红色像素块（模4余1），随机选y→验证是二次非剩余→计算x→用高斯gcd分解出z（显示为“z= a+bi”的像素文字），伴随“叮”的音效。
  4. **因数分配**：用像素箭头展示DFS的分支（比如模4余1的质数有3种分配方式，箭头分3路），每选一个分支，控制台显示“当前分配：t=0”“t=1”等，伴随“咔嗒”声。
  5. **解收集**：当DFS完成，屏幕中央弹出所有(x,y)对（用闪烁的像素点标注），播放“叮铃”的胜利音效，同时显示“找到XX个解！”的像素文字。
  6. **交互控制**：控制面板有“单步”“自动播放”“重置”按钮，速度滑块（1x~5x），自动播放时像“AI探险家”一样一步步完成流程。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握二平方和定理后，我们可以拓展到更复杂的数论问题：
</similar_problems_intro>

* **通用思路迁移**：二平方和定理是“平方和问题”的基础，类似的还有**三平方和定理**（n= x²+y²+z²，条件是n≠4^k(8m+7)）、**四平方和定理**（所有正整数都能表示为4个平方和）。

* **洛谷练习推荐**：
  1. **洛谷 P1586 四方定理**：求n的四平方和表示，巩固平方和问题的思路。
  2. **洛谷 P3383 线性筛素数**：练习质因数分解的基础，为处理大数做准备。
  3. **洛谷 P4781 【模板】Pollard's Rho算法**：学习大数质因数分解，解决本题中1e18的n分解问题。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解作者提到“自己写的SQUFOF算法假掉了，改用随机二次非剩余的方法”，这给我们两点启发：
</insights_intro>

> **参考经验**：作者在分解模4余1的质数时，最初用SQUFOF算法失败，后来改用“随机二次非剩余+高斯gcd”的方法解决。
> **点评**：遇到问题时不要死磕一种方法——随机化是数论中常用的技巧，比如找二次非剩余，虽然是“碰运气”，但期望次数很少（平均2次），效率很高。动手尝试不同的思路，才能找到最优解！


<conclusion>
本次关于“二平方和定理”的分析就到这里。数论问题看似抽象，但只要掌握核心定理（比如高斯整环分解），就能化繁为简。记住：多学数论知识，多练算法实现，你也能成为“数论小专家”！下次我们再一起探索更有趣的编程挑战！💪
</conclusion>

---
处理用时：109.50秒
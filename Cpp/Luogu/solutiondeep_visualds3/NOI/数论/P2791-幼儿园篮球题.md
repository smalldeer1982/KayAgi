# 题目信息

# 幼儿园篮球题

## 题目背景

众所周知，全民制作幼儿园园龄两年半的蔡徐坤同学喜欢唱、跳、rap 和篮球。而作为欧文的老师，他的篮球技术自然比 ikun 们要强得多。

## 题目描述

全民制作幼儿园的蔡徐坤专属篮球场上总共有 $N$ 个蔡徐坤专属篮球，而其中有 $M$ 个是没气的。鉴于蔡徐坤的高超技术，他投**没气的球一定能进**，而投**有气的球一定不能**。

蔡徐坤举办了 $S$ 场巡回篮球表演，第 $i$ 场表演 ikun 们会指定投球个数 $k_i$ ，ikun 们会从 $N$ 个蔡徐坤专属篮球中准备 $n_i$ 个球放在场地上，其中恰好有 $m_i$ 个是没气的。蔡徐坤会在这 $n_i$ 个蔡徐坤专属篮球中**随机**选出 $k_i$ 个投篮。如果投进了 $x$ 个，则这次表演的**失败度**为 $x^L$。ikun 们想知道这 $S$ 场表演的**期望失败度**对 $998244353$ 取模的结果。篮球表演之间**相互独立**。

## 说明/提示

对于样例，我们作出如下解释：设失败度为 $X$，蔡徐坤有 $\frac{1}{3}$ 的概率投进 $2$ 个，有 $\frac{2}{3}$ 的概率投进 $1$ 个，期望失败度为 $E(x)=\frac{2^3}{3}+\frac{1^3*2}{3}=\frac{10}{3}$，$\frac{10}{3}\equiv 332748121\pmod{998244353}$。

子任务 1 ($15\%$)：$1\leq L\leq2$。

子任务 2 ($10\%$)：$1\leq N\leq10^5$。

子任务 3 ($75\%$)：无特殊限制。

对于全部数据，$1\leq S\leq200$，$1\leq L\leq2\times 10^5$，$1\leq M\leq N\leq2\times 10^7$。并且对于 $1\leq i\leq S$，有 $1\leq m_i,k_i\leq n_i\leq N$，$1\leq m_i\leq M$。

## 样例 #1

### 输入

```
3 2 1 3
3 2 2```

### 输出

```
332748121```

# AI分析结果

---
# 💡 Kay的C++算法解析：幼儿园篮球题 深入学习指南 💡

<introduction>
今天我们来一起分析「幼儿园篮球题」这道C++编程题。这道题看起来是关于概率期望的计算，但实际上藏着很多组合数学的小技巧哦！本指南会帮你梳理清楚题目思路，理解核心的数学推导，并掌握解题的关键代码技巧。
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（组合数学、斯特林数、卷积应用）

🗣️ **初步分析**：
解决这道题的关键就像「拆礼物」——把复杂的「i的L次方」拆开，用简单的「积木」（斯特林数、组合数）重新拼起来。数学在这里的作用就是「拆礼物的工具」：我们用**第二类斯特林数**把「i^L」拆成「选j个盒子放L个球」的组合意义，再用**范德蒙德卷积**把零散的组合数求和变成一个简洁的组合数。这样原本难算的式子就变得容易计算啦！

题解的核心思路都一样：
1. 用斯特林数展开「i^L」→ 把复杂的幂变成容易处理的组合数；
2. 交换求和顺序 → 把「先算i再算j」变成「先算j再算i」；
3. 用组合恒等式化简 → 把「C(m,i)*C(i,j)」变成「C(m,j)*C(m-j,i-j)」；
4. 用范德蒙德卷积求和 → 把长长的和式变成一个组合数。

**核心难点**：怎么处理「i^L」和化简组合数的和。**解决方案**：用斯特林数展开和组合恒等式「拆」和「拼」。

**可视化设计思路**：我们可以做一个「像素篮球馆」动画——用不同颜色的像素块代表「i」（选i个没气的球）和「j」（斯特林数的j），单步展示「拆i^L」「交换求和顺序」「拼组合数」的过程。比如，当展开i^L时，红色像素块（i）会分裂成几个蓝色像素块（j）；当化简组合数时，蓝色像素块会和其他块合并成一个绿色块（范德蒙德卷积的结果）。还可以加「入队音效」当处理一个j时，「胜利音效」当算出最终结果！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面，为大家筛选了3个优质题解，帮你快速理解核心逻辑~
</eval_intro>

**题解一：(来源：λᴉʍ，73赞)**
* **点评**：这份题解的推导就像「剥洋葱」——一层一层把复杂的式子拆开，每一步都讲得很清楚！比如，作者先写出原始式子，然后用斯特林数展开i^L，再一步步化简组合数的和，最后用范德蒙德卷积收尾。代码也很高效：用NTT计算斯特林数，预处理阶乘和逆元，查询时直接遍历j计算。唯一的小遗憾是代码里的变量名有点简写，但整体逻辑非常清晰！

**题解二：(来源：SSerxhs，41赞)**
* **点评**：作者把题目和「超几何分布」联系起来，就像「给题目找了个亲戚」——超几何分布的期望公式大家可能学过，这样理解起来更亲切！作者还解释了前两档部分分的做法（暴力枚举、课本公式），帮你从易到难过渡。代码里用线性筛处理i^L，避免了重复计算，非常聪明！不过代码里的变量名和题目不一样，需要注意对应关系~

**题解三：(来源：Rorschachindark，17赞)**
* **点评**：这份题解的推导「步步留痕」——每一步都写出了用到的组合恒等式，比如「C(m,i)*C(i,j)=C(m,j)*C(m-j,i-j)」和范德蒙德卷积，帮你巩固组合数学的基础！代码也很简洁：用NTT计算斯特林数，预处理阶乘和逆元，查询时直接求和。美中不足的是代码里的NTT实现有点长，但整体结构很清晰~


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点就像「三座小山峰」，翻过去就会发现一片平原！我们一起来看看怎么翻~
</difficulty_intro>

1. **难点1：怎么处理「i^L」？**  
   **分析**：i的L次方很大，直接计算会超时或溢出。  
   **解决方案**：用第二类斯特林数展开：i^L = sum_{j=0}^L S(L,j) * j! * C(i,j)。斯特林数S(L,j)表示「把L个不同的球放进j个相同的盒子，每个盒子非空」的方案数，这样就把幂变成了组合数！

2. **难点2：怎么化简「C(m,i)*C(i,j)」的和？**  
   **分析**：直接算这个和式会很慢，因为要遍历i。  
   **解决方案**：用组合恒等式「C(m,i)*C(i,j) = C(m,j)*C(m-j,i-j)」。这个式子的意思是「先选j个球，再从剩下的m-j个里选i-j个」，和原来的「先选i个再选j个」是一样的，但更方便求和！

3. **难点3：怎么快速计算第二类斯特林数的第L行？**  
   **分析**：斯特林数的通项是卷积形式，直接算会超时。  
   **解决方案**：用NTT（快速数论变换）计算卷积。斯特林数的通项是S(L,j) = sum_{i=0}^j (-1)^(j-i) * i^L / (i!*(j-i)!)，这正好是两个数组的卷积，用NTT可以在O(L log L)时间内算出！

### ✨ 解题技巧总结
- **拆复杂项**：遇到幂、乘积等复杂项，试试用组合数学的工具（斯特林数、生成函数）拆开；
- **交换求和顺序**：把「难算的和」变成「易算的和」；
- **预处理**：提前算好阶乘、逆元、斯特林数，查询时直接用，避免重复计算；
- **用卷积加速**：遇到卷积形式的式子，用NTT或FFT加速计算！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个通用的核心实现，帮你把握整体框架~
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，清晰展示了「预处理斯特林数→处理查询」的流程。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int mod = 998244353;
const int G = 3;
const int invG = 332748118; // 3的逆元模998244353

long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

void ntt(vector<long long>& a, bool inv) {
    int n = a.size();
    vector<int> r(n);
    for (int i = 0; i < n; i++) {
        r[i] = r[i >> 1] >> 1;
        if (i & 1) r[i] |= n >> 1;
    }
    for (int i = 0; i < n; i++) if (i < r[i]) swap(a[i], a[r[i]]);
    for (int len = 2; len <= n; len <<= 1) {
        long long wn = qpow(inv ? invG : G, (mod - 1) / len);
        for (int i = 0; i < n; i += len) {
            long long w = 1;
            for (int j = 0; j < len / 2; j++) {
                long long u = a[i + j], v = a[i + j + len / 2] * w % mod;
                a[i + j] = (u + v) % mod;
                a[i + j + len / 2] = (u - v + mod) % mod;
                w = w * wn % mod;
            }
        }
    }
    if (inv) {
        long long invn = qpow(n, mod - 2);
        for (long long& x : a) x = x * invn % mod;
    }
}

vector<long long> multiply(vector<long long> a, vector<long long> b) {
    int n = 1;
    while (n < a.size() + b.size()) n <<= 1;
    a.resize(n), b.resize(n);
    ntt(a, false), ntt(b, false);
    for (int i = 0; i < n; i++) a[i] = a[i] * b[i] % mod;
    ntt(a, true);
    return a;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M, S, L;
    cin >> N >> M >> S >> L;

    // 预处理阶乘和逆元
    int max_fac = max(N, L);
    vector<long long> fac(max_fac + 1), ifac(max_fac + 1);
    fac[0] = 1;
    for (int i = 1; i <= max_fac; i++) fac[i] = fac[i - 1] * i % mod;
    ifac[max_fac] = qpow(fac[max_fac], mod - 2);
    for (int i = max_fac - 1; i >= 0; i--) ifac[i] = ifac[i + 1] * (i + 1) % mod;

    // 计算第二类斯特林数S(L, j)
    vector<long long> A(L + 1), B(L + 1);
    for (int i = 0; i <= L; i++) {
        A[i] = (i % 2 == 0) ? ifac[i] : (mod - ifac[i]) % mod; // (-1)^i / i!
        B[i] = qpow(i, L) * ifac[i] % mod; // i^L / i!
    }
    vector<long long> stirling = multiply(A, B);
    stirling.resize(L + 1); // S(L, j) = stirling[j]

    // 处理查询
    while (S--) {
        int n, m, k;
        cin >> n >> m >> k;
        long long ans = 0;
        int max_j = min(min(m, k), L);
        for (int j = 0; j <= max_j; j++) {
            // 计算S(L,j)*j!*C(m,j)*C(n-j, k-j)
            long long term = stirling[j]; // S(L,j)
            term = term * fac[j] % mod; // j!
            term = term * fac[m] % mod * ifac[j] % mod * ifac[m - j] % mod; // C(m,j)
            if (n - j < 0 || k - j < 0 || (n - j) < (k - j)) continue;
            term = term * fac[n - j] % mod * ifac[k - j] % mod * ifac[(n - j) - (k - j)] % mod; // C(n-j, k-j)
            ans = (ans + term) % mod;
        }
        // 除以C(n,k) → 乘以C(n,k)的逆元
        long long inv_Cnk = ifac[n] * fac[k] % mod * fac[n - k] % mod;
        ans = ans * inv_Cnk % mod;
        cout << ans << '\n';
    }

    return 0;
}
```
* **代码解读概要**：
  1. **预处理**：算阶乘`fac`和逆阶乘`ifac`，用于快速计算组合数；
  2. **算斯特林数**：用NTT计算两个数组的卷积，得到第二类斯特林数的第L行；
  3. **处理查询**：遍历j，计算每一项的贡献，最后除以C(n,k)（乘以逆元）得到答案。


<code_intro_selected>
接下来我们看看优质题解中的核心片段，学习它们的亮点~
</code_intro_selected>

**题解一：(来源：λᴉʍ)**
* **亮点**：用线性筛预处理i^L，避免重复计算！
* **核心代码片段**：
  ```cpp
  // 预处理i^L（i从1到L）
  PL[0] = 0, PL[1] = 1;
  for (int i = 2; i <= L; ++i) {
      if (!yes[i]) pr[++Pr] = i, PL[i] = pow(i, L);
      for (int j = 1; j <= Pr && i * pr[j] <= L; ++j) {
          yes[i * pr[j]] = 1;
          PL[i * pr[j]] = 1ll * PL[pr[j]] * PL[i] % mod;
          if (i % pr[j] == 0) break;
      }
  }
  ```
* **代码解读**：
  这段代码用**线性筛**（欧拉筛）预处理每个数的L次方。比如，当i是质数时，直接算i^L；当i是合数时，用质因数分解的结果相乘得到i^L。这样每个数只算一次，时间复杂度是O(L)，比直接循环算快很多！
* **学习笔记**：线性筛不仅能筛质数，还能快速预处理很多积性函数（比如i^L）~

**题解二：(来源：SSerxhs)**
* **亮点**：用NTT计算斯特林数的代码非常简洁！
* **核心代码片段**：
  ```cpp
  // 计算斯特林数
  for (i=0;i<l;i++) if (i&1) f[i]=p-ifac[i]; else f[i]=ifac[i];
  for (i=1;i<l;i++) g[i]=(ll)ifac[i]*mc[i]%p;
  dft(f,0,limit);dft(g,0,limit);
  for (i=0;i<limit;i++) f[i]=(ll)f[i]*g[i]%p;
  dft(f,l,limit);
  ```
* **代码解读**：
  这段代码中，`f`数组是(-1)^i / i!，`g`数组是i^L / i!。通过NTT计算它们的卷积，得到的结果就是斯特林数S(L,j)。作者把NTT封装成`dft`函数，代码非常简洁！
* **学习笔记**：NTT的核心是把卷积转换成点乘，这样就能快速计算~

**题解三：(来源：Rorschachindark)**
* **亮点**：组合数计算用阶乘和逆元，非常高效！
* **核心代码片段**：
  ```cpp
  // 计算组合数C(n, k)
  int C(int n, int m) {
      return 1ll * fac[n] * inv[m] % mod * inv[n - m] % mod;
  }
  ```
* **代码解读**：
  这段代码用预处理好的阶乘`fac`和逆元`inv`计算组合数。比如C(n,m) = n!/(m!(n-m)!)，所以用fac[n] * inv[m] * inv[n-m] mod mod就能快速算出，不需要每次都算乘法！
* **学习笔记**：预处理阶乘和逆元是组合数计算的「快捷键」~


## 5. 算法可视化：像素动画演示

### 🎮 像素动画方案：「斯特林数的篮球派对」
**主题**：像素小人用斯特林数「拆」i^L，用组合数「拼」出答案，就像在篮球场上「传球」一样！

### 🎨 设计思路
用8位像素风模拟「篮球派对」：
- **场景**：像素篮球馆，地板是网格状的（代表组合数的和），篮筐是「答案」的位置；
- **角色**：红色像素小人（代表i，选i个没气的球），蓝色小人（代表j，斯特林数的j）；
- **动画步骤**：
  1. **初始化**：红色小人站在球场中央，旁边有个写着「i^L」的礼物盒；
  2. **拆礼物**：红色小人打开礼物盒，里面跳出几个蓝色小人（斯特林数的j），伴随「叮」的音效；
  3. **传球游戏**：每个蓝色小人拿一个「组合数篮球」，传给其他蓝色小人，合并成一个绿色的「范德蒙德篮球」（伴随「咚咚」的传球音效）；
  4. **投篮得分**：绿色篮球投进篮筐，屏幕显示「答案」，伴随「胜利音效」（8位风格的「叮~当~」）；
- **交互**：可以单步执行（点击「下一步」）、自动播放（调整速度滑块）、重置（点击「再来一次」）；
- **音效**：拆礼物的「叮」、传球的「咚咚」、投篮的「叮~当~」，背景音乐是8位风格的《小苹果》！

### 🛠️ 技术实现
- **画布**：用HTML5 Canvas画像素篮球馆，每个像素块是10x10像素；
- **动画**：用JavaScript的`requestAnimationFrame`实现单步和自动播放；
- **音效**：用Web Audio API播放8位音效（比如拆礼物的音效是200Hz的正弦波，持续100ms）；
- **控制板**：用HTML按钮和滑块实现「下一步」「自动播放」「速度调整」。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题用到的「斯特林数展开」「组合恒等式」「卷积加速」是组合数学的基础，学会了可以解决很多类似问题~
</similar_problems_intro>

### 🧩 通用思路迁移
- **斯特林数**：用来处理「幂的和」（比如求sum_{i=1}^n i^k）；
- **范德蒙德卷积**：用来处理「两个组合数的和」（比如sum_{i=0}^k C(a,i)C(b,k-i) = C(a+b,k)）；
- **卷积加速**：用来计算「生成函数的乘积」（比如斯特林数、斐波那契数）。

### 📚 拓展练习推荐（洛谷）
1. **P5395 第二类斯特林数·行**：直接练「用NTT计算斯特林数的第L行」，巩固核心技巧；
2. **P2606 ZJOI2010排列计数**：用斯特林数处理「排列中的逆序对」，练「斯特林数的应用」；
3. **P3746 六省联考2017组合数问题**：用生成函数和卷积处理「组合数的和」，练「卷积的应用」；
4. **P1358 扑克牌**：用组合数和概率计算「抽到特定牌的概率」，练「期望计算」。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多题解作者都分享了自己的「踩坑」经历，比如：
</insights_intro>

> **参考经验 (来自 λᴉʍ)**：「我一开始卡在i^L的计算上，后来想到用斯特林数展开，才把式子化简开。」
> **点评**：斯特林数是处理「幂的和」的「神器」，遇到i^L、sum i^k这样的式子，先想想能不能用斯特林数拆！

> **参考经验 (来自 SSerxhs)**：「这题卡常卡得厉害，我用线性筛预处理i^L，才把时间降下来。」
> **点评**：预处理是「时间优化」的「必杀技」，能预处理的东西尽量预处理！


## 🎉 总结
这道题的核心是「用数学工具拆复杂项，再拼回简单项」。通过斯特林数和组合恒等式，我们把难算的期望式子变成了容易计算的和式。记住：遇到复杂的幂或和式，先想想「能不能拆？能不能换顺序？能不能用卷积？」，这些思路会帮你解决很多组合数学问题！

下次我们再一起挑战更难的题目，比如「斯特林数的生成函数」或者「组合数的递推」，加油！💪</think>---
# 💡 Kay的C++算法解析：幼儿园篮球题 深入学习指南 💡

<introduction>
今天我们来一起分析「幼儿园篮球题」这道C++编程题。这道题看起来是关于概率期望的计算，但实际上藏着很多组合数学的小技巧哦！本指南会帮你梳理清楚题目思路，理解核心的数学推导，并掌握解题的关键代码技巧。
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（组合数学、斯特林数、卷积应用）

🗣️ **初步分析**：
解决这道题的关键就像「拆礼物」——把复杂的「i的L次方」拆开，用简单的「积木」（斯特林数、组合数）重新拼起来。数学在这里的作用就是「拆礼物的工具」：我们用**第二类斯特林数**把「i^L」拆成「选j个盒子放L个球」的组合意义，再用**范德蒙德卷积**把零散的组合数求和变成一个简洁的组合数。这样原本难算的式子就变得容易计算啦！

题解的核心思路都围绕以下四步：
1. **拆幂**：用斯特林数将`i^L`展开为`sum(S(L,j)*j!*C(i,j))`（把复杂的幂转化为组合数）；
2. **换序**：交换求和顺序，将「先遍历i再遍历j」调整为「先遍历j再遍历i」；
3. **化简**：用组合恒等式`C(m,i)*C(i,j) = C(m,j)*C(m-j,i-j)`合并组合数；
4. **求和**：用范德蒙德卷积将`sum(C(m-j,i-j)*C(n-m,k-i))`简化为`C(n-j,k-j)`。

**核心难点**：如何处理`i^L`的高次幂及化简组合数的和。**解决方案**：通过斯特林数展开和组合恒等式「拆」与「拼」。

**可视化设计思路**：我们设计「像素篮球馆」动画——用不同颜色像素块代表`i`（选i个没气的球）和`j`（斯特林数的j），单步展示「拆幂→换序→化简→求和」的过程。例如：
- 拆幂时，红色像素块（i）分裂为蓝色块（j），伴随「叮」的拆礼物音效；
- 化简时，蓝色块与其他块合并为绿色块（范德蒙德结果），伴随「咚咚」的传球音效；
- 求和完成后，绿色块投进篮筐（答案），播放8位风格的「胜利音效」。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了3个优质题解，帮你快速理解核心逻辑~
</eval_intro>

**题解一：(来源：λᴉʍ，73赞)**
* **点评**：这份题解的推导像「剥洋葱」——逐层拆解复杂式子，每一步都标注了关键变换（如斯特林数展开、组合恒等式）。代码实现高效：用线性筛预处理`i^L`，避免重复计算；用NTT快速计算斯特林数。美中不足是变量名略简写，但整体逻辑清晰，适合入门学习。

**题解二：(来源：SSerxhs，41赞)**
* **点评**：作者将题目与「超几何分布」结合，用课本知识关联问题，降低理解门槛。代码中用NTT计算斯特林数的部分封装简洁，且针对大L优化了`i^L`的计算（线性筛）。唯一需要注意的是变量名与题目不一致，需对应转换。

**题解三：(来源：Rorschachindark，17赞)**
* **点评**：推导「步步留痕」——每一步都明确写出用到的组合恒等式（如范德蒙德卷积），帮你巩固组合数学基础。代码结构清晰，组合数计算直接调用预处理的阶乘和逆元，效率高。适合需要补全组合数学细节的学习者。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点像「三座小山峰」，翻过去就能看到平坦的解题道路！我们逐一拆解：
</difficulty_intro>

1. **难点1：如何处理`i^L`的高次幂？**  
   **分析**：`i^L`的计算复杂度高，且直接遍历会超时。  
   **解决方案**：用第二类斯特林数展开`i^L = sum_{j=0}^L S(L,j)*j!*C(i,j)`。斯特林数`S(L,j)`表示「将L个不同的球放入j个相同盒子且无空盒」的方案数，将幂转化为组合数。

2. **难点2：如何化简组合数的和？**  
   **分析**：直接计算`sum(C(m,i)*C(i,j))`需要遍历i，时间复杂度过高。  
   **解决方案**：用组合恒等式`C(m,i)*C(i,j) = C(m,j)*C(m-j,i-j)`，将「先选i个再选j个」转化为「先选j个再选剩余i-j个」，合并后更易求和。

3. **难点3：如何快速计算斯特林数？**  
   **分析**：斯特林数的通项是卷积形式，直接计算复杂度为`O(L^2)`，无法处理大L。  
   **解决方案**：用NTT（快速数论变换）计算卷积。斯特林数的通项`S(L,j) = sum_{i=0}^j (-1)^(j-i)*i^L/(i!*(j-i)!)`是两个数组的卷积，NTT可将复杂度降至`O(L log L)`。

### ✨ 解题技巧总结
- **拆复杂项**：遇到高次幂或乘积，优先用斯特林数、生成函数等工具拆解；
- **预处理**：提前计算阶乘、逆元、斯特林数，避免重复计算；
- **用卷积加速**：卷积形式的式子（如斯特林数、多项式乘法）用NTT/FFT加速；
- **组合恒等式**：记住常用恒等式（如范德蒙德卷积、组合数合并），简化求和。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个通用核心实现，帮你把握「预处理→计算斯特林数→处理查询」的整体框架~
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合多个优质题解的思路，实现「斯特林数预处理+查询计算」的完整流程，逻辑清晰且高效。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int mod = 998244353;
const int G = 3;
const int invG = 332748118; // G的逆元模998244353

long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

void ntt(vector<long long>& a, bool inv) {
    int n = a.size();
    vector<int> r(n);
    for (int i = 0; i < n; i++) {
        r[i] = r[i >> 1] >> 1;
        if (i & 1) r[i] |= n >> 1;
    }
    for (int i = 0; i < n; i++) if (i < r[i]) swap(a[i], a[r[i]]);
    for (int len = 2; len <= n; len <<= 1) {
        long long wn = qpow(inv ? invG : G, (mod - 1) / len);
        for (int i = 0; i < n; i += len) {
            long long w = 1;
            for (int j = 0; j < len / 2; j++) {
                long long u = a[i + j], v = a[i + j + len / 2] * w % mod;
                a[i + j] = (u + v) % mod;
                a[i + j + len / 2] = (u - v + mod) % mod;
                w = w * wn % mod;
            }
        }
    }
    if (inv) {
        long long invn = qpow(n, mod - 2);
        for (long long& x : a) x = x * invn % mod;
    }
}

vector<long long> multiply(vector<long long> a, vector<long long> b) {
    int n = 1;
    while (n < (int)(a.size() + b.size())) n <<= 1;
    a.resize(n), b.resize(n);
    ntt(a, false), ntt(b, false);
    for (int i = 0; i < n; i++) a[i] = a[i] * b[i] % mod;
    ntt(a, true);
    return a;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M, S, L;
    cin >> N >> M >> S >> L;

    // 预处理阶乘和逆元（组合数计算的快捷键）
    int max_fac = max(N, L);
    vector<long long> fac(max_fac + 1), ifac(max_fac + 1);
    fac[0] = 1;
    for (int i = 1; i <= max_fac; i++) fac[i] = fac[i - 1] * i % mod;
    ifac[max_fac] = qpow(fac[max_fac], mod - 2);
    for (int i = max_fac - 1; i >= 0; i--) ifac[i] = ifac[i + 1] * (i + 1) % mod;

    // 计算第二类斯特林数S(L, j)
    vector<long long> A(L + 1), B(L + 1);
    for (int i = 0; i <= L; i++) {
        A[i] = (i % 2 == 0) ? ifac[i] : (mod - ifac[i]) % mod; // (-1)^i / i!
        B[i] = qpow(i, L) * ifac[i] % mod;                   // i^L / i!
    }
    vector<long long> stirling = multiply(A, B);
    stirling.resize(L + 1); // stirling[j] = S(L, j)

    // 处理查询
    while (S--) {
        int n, m, k;
        cin >> n >> m >> k;
        long long ans = 0;
        int max_j = min(min(m, k), L); // j的上界是min(m, k, L)
        for (int j = 0; j <= max_j; j++) {
            // 计算项：S(L,j)*j!*C(m,j)*C(n-j, k-j)
            long long term = stirling[j];                 // S(L,j)
            term = term * fac[j] % mod;                   // j!
            term = term * fac[m] % mod * ifac[j] % mod 
                      * ifac[m - j] % mod;                // C(m,j) = m!/(j!(m-j)!)
            if (n - j < 0 || k - j < 0 || (n - j) < (k - j)) continue;
            term = term * fac[n - j] % mod * ifac[k - j] % mod 
                      * ifac[(n - j) - (k - j)] % mod;    // C(n-j, k-j)
            ans = (ans + term) % mod;
        }
        // 除以C(n,k) → 乘以C(n,k)的逆元
        long long inv_Cnk = ifac[n] * fac[k] % mod * ifac[n - k] % mod;
        ans = ans * inv_Cnk % mod;
        cout << ans << '\n';
    }

    return 0;
}
```
* **代码解读概要**：
  1. **预处理**：计算阶乘`fac`和逆阶乘`ifac`，用于快速计算组合数；
  2. **斯特林数计算**：用NTT计算两个数组的卷积，得到斯特林数`S(L,j)`；
  3. **查询处理**：遍历j计算每一项的贡献，最后用逆元除以`C(n,k)`得到期望。


<code_intro_selected>
接下来剖析优质题解的核心片段，点出各自亮点~
</code_intro_selected>

**题解一：(来源：λᴉʍ)**
* **亮点**：线性筛预处理`i^L`，避免重复计算。
* **核心代码片段**：
  ```cpp
  // 线性筛预处理i^L（i从1到L）
  PL[0] = 0, PL[1] = 1;
  for (int i = 2; i <= L; ++i) {
      if (!yes[i]) pr[++Pr] = i, PL[i] = pow(i, L);
      for (int j = 1; j <= Pr && i * pr[j] <= L; ++j) {
          yes[i * pr[j]] = 1;
          PL[i * pr[j]] = 1ll * PL[pr[j]] * PL[i] % mod;
          if (i % pr[j] == 0) break;
      }
  }
  ```
* **代码解读**：
  线性筛的核心是「每个合数只被其最小质因数筛一次」。对于质数`i`，直接计算`i^L`；对于合数`i*pr[j]`，利用积性函数性质`(i*pr[j])^L = i^L * pr[j]^L`快速计算。这样每个数只算一次，时间复杂度`O(L)`。
* **学习笔记**：线性筛是预处理积性函数（如`i^L`、欧拉函数）的「神器」。

**题解二：(来源：SSerxhs)**
* **亮点**：NTT计算斯特林数的简洁实现。
* **核心代码片段**：
  ```cpp
  // 计算斯特林数
  for (i=0; i<l; i++) if (i&1) f[i] = p - ifac[i]; else f[i] = ifac[i];
  for (i=1; i<l; i++) g[i] = (ll)ifac[i] * mc[i] % p;
  dft(f, 0, limit); dft(g, 0, limit);
  for (i=0; i<limit; i++) f[i] = (ll)f[i] * g[i] % p;
  dft(f, l, limit);
  ```
* **代码解读**：
  `f`数组是`(-1)^i / i!`，`g`数组是`i^L / i!`。通过NTT将两个数组转换为点乘，再逆变换得到卷积结果（即斯特林数）。作者将NTT封装为`dft`函数，代码简洁易读。
* **学习笔记**：NTT的核心是「将卷积转换为点乘」，从而加速计算。

**题解三：(来源：Rorschachindark)**
* **亮点**：组合数的高效计算。
* **核心代码片段**：
  ```cpp
  // 用阶乘和逆元计算组合数C(n, m)
  int C(int n, int m) {
      return 1ll * fac[n] * inv[m] % mod * inv[n - m] % mod;
  }
  ```
* **代码解读**：
  组合数`C(n,m) = n!/(m!(n-m)!)`，预处理`fac`（阶乘）和`inv`（逆元）后，直接代入公式计算，时间复杂度`O(1)`。
* **学习笔记**：预处理阶乘和逆元是组合数计算的「快捷键」，避免重复乘法。


## 5. 算法可视化：像素动画演示

### 🎮 像素动画方案：「斯特林数的篮球派对」
**主题**：像素小人用斯特林数「拆」`i^L`，用组合数「拼」出答案，像在篮球场上「传球」一样！

### 🎨 设计细节
- **场景**：8位像素风篮球馆，地板是网格状（代表组合数的和），篮筐是「答案」的位置；
- **角色**：红色小人（`i`，选i个没气的球）、蓝色小人（`j`，斯特林数的j）；
- **动画流程**：
  1. **初始化**：红色小人站在球场中央，旁边有个写着`i^L`的礼物盒；
  2. **拆幂**：红色小人打开礼物盒，跳出蓝色小人（j），伴随「叮」的拆礼物音效；
  3. **传球化简**：蓝色小人拿「组合数篮球」传给其他小人，合并成绿色球（范德蒙德结果），伴随「咚咚」的传球音效；
  4. **投篮得分**：绿色球投进篮筐，屏幕显示答案，播放8位风格的「胜利音效」（如《超级马里奥》的通关音）；
- **交互**：
  - 控制板：「单步」（点击下一步）、「自动播放」（调整速度滑块）、「重置」（重新开始）；
  - 音效：支持开启/关闭，背景音乐是8位风格的《小苹果》。

### 🛠️ 技术实现
- **画布**：用HTML5 Canvas绘制像素元素（每个像素块10x10px）；
- **动画**：用`requestAnimationFrame`实现帧动画，单步模式下点击按钮触发下一帧；
- **音效**：用Web Audio API生成8位音效（如拆礼物是200Hz正弦波，持续100ms）；
- **代码**：纯HTML/CSS/JavaScript实现，单文件可本地运行。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的「斯特林数展开」「组合恒等式」「卷积加速」是组合数学的基础，学会后可解决很多类似问题~
</similar_problems_intro>

### 🧩 通用思路迁移
- **斯特林数**：处理高次幂的和（如`sum_{i=1}^n i^k`）；
- **范德蒙德卷积**：合并两个组合数的和（如`sum C(a,i)C(b,k-i) = C(a+b,k)`）；
- **卷积加速**：计算多项式乘法、生成函数（如斯特林数、斐波那契数）。

### 📚 拓展练习推荐（洛谷）
1. **P5395 第二类斯特林数·行**：直接练习「用NTT计算斯特林数的第L行」，巩固核心技巧；
2. **P2606 ZJOI2010排列计数**：用斯特林数处理「排列中的逆序对」，练习斯特林数的应用；
3. **P3746 六省联考2017组合数问题**：用生成函数和卷积处理「组合数的和」，练习卷积加速；
4. **P1358 扑克牌**：用组合数和概率计算「抽到特定牌的概率」，练习期望计算。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解作者分享了以下「踩坑」经验，帮你避坑~
</insights_intro>

> **参考经验 (来自 λᴉʍ)**：「我一开始卡在`i^L`的计算上，后来想到用斯特林数展开，才把式子化简开。」
> **点评**：斯特林数是处理高次幂的「钥匙」，遇到`i^k`优先考虑展开。

> **参考经验 (来自 SSerxhs)**：「这题卡常严重，我用线性筛预处理`i^L`，才把时间降下来。」
> **点评**：预处理是「时间优化」的关键，能预处理的内容尽量提前算。


## 🎉 总结
这道题的核心是「用数学工具拆解复杂项，再拼接成简单项」。通过斯特林数展开和组合恒等式，原本难算的期望式子变得容易计算。记住：
- 高次幂用斯特林数拆；
- 组合数和用恒等式化简；
- 卷积形式用NTT加速。

下次我们将挑战更难的组合数学问题（如生成函数、多项式乘法），继续加油！💪

---
处理用时：205.04秒
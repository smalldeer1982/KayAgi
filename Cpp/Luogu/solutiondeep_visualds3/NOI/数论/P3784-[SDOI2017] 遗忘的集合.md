# 题目信息

# [SDOI2017] 遗忘的集合

## 题目描述

小 Q 在他的个人主页上放出了一个悬赏：征集只含正整数的非空集合 $S$，其中的每个元素都不超过 $n$，并且满足一些附加条件。

众所周知，我们可以很轻松地对于任意不超过 $n$ 的正整数 $x$，计算出把 $x$ 表示成 $S$ 中元素之和的方案数 $f(x)$，在这里我们约定，在任意方案中每个数字可以出现多次，但是不考虑数字出现的顺序。

例如，当 $S=\{1,2,3,4,5\}$ 时，我们可以计算出 $f(2) = 2, f(3) = 3, f(4) = 5, f(5) = 7$。

再例如，当 $S=\{1,2,5\}$ 时，我们可以计算出 $f(4) = 3, f(5) = 4, f(6) = 5, f(7) = 6$。

麻烦地是现在小 Q 忘记了 $S$ 里有哪些元素，幸运地是他用存储设备记录下了所有 $f(i)\bmod p$ 的值，小 Q 希望你能利用这些信息帮他恢复出 $S$ 原来的样子。

具体来说，他希望你找到这样一个正整数的**非空**集合 $S$，其中的每个元素都不超过 $n$，并且对于任意的 $i = 1, 2,\cdots ,n$，满足把 $i$ 表示成 $S$ 中元素之和的方案数在模 $p$ 意义下等于 $f(i)$，其中 $p$ 是记录在存储设备中的一个质数。他向你保证：**一定存在**这样的集合$S$。

然而，小 Q 觉得他存储的信息并不足以恢复出唯一的 $S$，也就是说，可能会存在多个这样的集合 $S$，所以小 Q 希望你能给出所有解中**字典序最小**的解。

对于满足条件的两个不同的集合 $S_1$ 和 $S_2$，我们认为 $S_1$ 的字典序比 $S_2$ 的字典序小，当且仅当存在非负整数 $k$，使得 $S_1$ 的前 $k$ 小元素与 $S_2$ 的前 $k$ 小元素完全相等，并且，要么 $S_1$ 的元素个数为 $k$，且 $S_2$ 的元素个数至少为 $(k + 1)$，要么 $S_1$ 和 $S_2$ 都有至少 $(k + 1)$ 个元素，且 $S_1$ 的第 $(k + 1)$ 小元素比 $S_2$ 的第 $(k + 1)$ 小元素小。


## 说明/提示

对于 $100\%$ 的数据，有 $1 \leq n < 2^{18} , 10^6 \leq p < 2^{30} , 0 \leq f(i) < p\quad (i=1,2, \cdots , n)$。

![](https://cdn.luogu.com.cn/upload/pic/5548.png)


## 样例 #1

### 输入

```
5 1000003
1 2 3 5 7```

### 输出

```
5
1 2 3 4 5```

## 样例 #2

### 输入

```
9 1000003
1 2 2 3 4 5 6 7 8```

### 输出

```
3
1 2 5```

# AI分析结果

---
# 💡 Kay的C++算法解析：[SDOI2017]遗忘的集合 深入学习指南 💡

## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：生成函数与多项式操作（核心） + 莫比乌斯反演（辅助）

### 🗣️ 初步分析
你可以把集合S想象成“积木盒”里的积木，每个积木i可以无限使用，而f(x)是用这些积木拼出长度x的“链条”的方案数（不考虑顺序）。现在我们要从“拼法”反推“积木盒里有哪些积木”——这就是**生成函数的逆问题**。

#### 核心算法思想
1. **生成函数**：把每个积木i的“拼法”转化为数学表达式——无限使用积木i的生成函数是$\frac{1}{1-x^i}$（等比数列求和：$1+x^i+x^{2i}+...$）。所有积木的生成函数相乘，就是总方案数f(x)的生成函数F(x)：  
   $$F(x) = \prod_{i=1}^n \left(\frac{1}{1-x^i}\right)^{a_i}$$  
   其中$a_i=1$表示积木i在盒中，$a_i=0$表示不在。

2. **多项式ln**：乘法不好处理？用ln把乘法变加法！对F(x)取ln后：  
   $$\ln F(x) = \sum_{i=1}^n a_i \sum_{j=1}^\infty \frac{x^{ij}}{j}$$  
   这一步的关键是把“积木的存在”转化为“项的累加”，方便后续提取$a_i$。

3. **莫比乌斯反演**：交换求和顺序（枚举$T=ij$），得到$\ln F(x)$的第T项系数是$\frac{1}{T}\sum_{i|T} a_i \cdot i$。设$G(T) = T \cdot [x^T]\ln F(x)$，则$G(T) = \sum_{i|T} a_i \cdot i$——这是经典的狄利克雷卷积形式，用莫比乌斯反演即可求出$a_i$（即积木是否存在）。

#### 可视化设计思路
我们设计一个**8位像素风的“生成函数实验室”**：
- **场景**：屏幕左侧是“生成函数F(x)”的像素数组（每个像素块代表一项$f(x)$），右侧是“ln后的G(x)”数组。
- **动画流程**：
  1. **ln计算**：左侧F(x)的像素块“流进”一个“ln机器”，机器里用颜色变化演示“乘法转加法”（比如两个像素块合并成一个，颜色变浅）。
  2. **反演过程**：右侧G(x)的像素块逐个高亮，遍历其所有因数i，用“闪烁”提示当前因数，计算$a_i$后用“点亮”表示积木i存在。
- **交互**：支持“单步执行”（一步步看ln和反演）、“自动播放”（像FC游戏一样匀速演示），关键操作（如ln完成、反演找到积木）有“叮”的音效，找到所有积木后播放胜利音乐。


## 2. 精选优质题解参考

### 题解一：Salamander（思路清晰，步骤明确）
**点评**：这份题解是“标准答案”级别的思路——从生成函数构造到多项式ln，再到莫比乌斯反演，每一步都有明确的数学推导。代码中`ln`函数直接调用多项式ln的实现，`a[j] += mu[i] * g[j/i]`是莫比乌斯反演的核心，逻辑简洁。美中不足是MTT的实现略复杂，但整体可读性很高。

### 题解二：litble（反演步骤优化，避免卷积）
**点评**：此题解的亮点在于**用调和级数代替狄利克雷卷积**——反演时不是直接计算$G \ast \mu$，而是从小到大遍历i，用i的倍数减去i的贡献（`G[j] = (G[j] - G[i] + p) % p`）。这种方法的时间复杂度是$O(n\log n)$，但代码更简洁，避免了复杂的卷积操作，适合初学者理解。

### 题解三：zhiyangfan（详细推导ln的过程）
**点评**：这份题解详细推导了$\ln(1-x^i)$的过程——从求导到积分，再到展开为幂级数。对于“为什么取ln”“ln后的形式为什么有用”这些疑问，给出了完整的数学解释。代码中`getLn`函数的实现（求导+求逆+积分）非常规范，是多项式ln的标准写法。


## 3. 核心难点辨析与解题策略

### 关键点1：生成函数的构造与ln的意义
**难点**：为什么要给F(x)取ln？  
**策略**：生成函数的乘积对应分拆方案的“组合”（选不同积木的组合），而ln能将乘积转化为和，把“组合问题”转化为“累加问题”。记住：**乘积转和，用ln；和转乘积，用exp**。

### 关键点2：多项式ln的实现（任意模数）
**难点**：题目中的模数p不是NTT模数，无法用普通的NTT实现多项式乘法。  
**策略**：使用**MTT（数论变换的扩展，处理任意模数）**——把系数拆成高位和低位，分别用FFT计算，再合并结果。题解中常见的实现是“拆成15位+15位”，用两次FFT计算，再合并。

### 关键点3：莫比乌斯反演的应用
**难点**：如何从ln后的G(x)中提取a_i？  
**策略**：从$G(T) = \sum_{i|T} a_i \cdot i$出发，这是$G = (a_i \cdot i) \ast 1$（狄利克雷卷积）。根据莫比乌斯反演，$(a_i \cdot i) = G \ast \mu$——即$a_i \cdot i = \sum_{d|i} G(d) \cdot \mu(i/d)$。计算时可以用调和级数的方法（遍历i，更新其倍数），避免直接卷积。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：本代码综合了多个优质题解的思路，实现了“生成函数→多项式ln→莫比乌斯反演”的完整流程，使用MTT处理任意模数的多项式乘法。

```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

typedef long long ll;
const double PI = acos(-1.0);
const int MOD = 1e9+7; // 示例模数，实际需替换为题目中的p
const int MAXN = 1 << 19;

struct Complex {
    double re, im;
    Complex(double re=0, double im=0): re(re), im(im) {}
    Complex operator+(const Complex& b) const { return Complex(re+b.re, im+b.im); }
    Complex operator-(const Complex& b) const { return Complex(re-b.re, im-b.im); }
    Complex operator*(const Complex& b) const { return Complex(re*b.re - im*b.im, re*b.im + im*b.re); }
};

int rev[MAXN];
Complex w[MAXN];

void init_fft(int n) {
    for (int i=0; i<n; i++) rev[i] = (rev[i>>1]>>1) | ((i&1) << (n-1));
    for (int i=0; i<n; i++) w[i] = Complex(cos(2*PI*i/n), sin(2*PI*i/n));
}

void fft(Complex* a, int n, int type) {
    for (int i=0; i<n; i++) if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int m=1; m<n; m<<=1) {
        int m2 = m << 1;
        for (int i=0; i<n; i+=m2) {
            for (int j=0; j<m; j++) {
                Complex W = w[type == 1 ? (n/m2)*j : n - (n/m2)*j];
                Complex t = a[i+j+m] * W;
                a[i+j+m] = a[i+j] - t;
                a[i+j] = a[i+j] + t;
            }
        }
    }
    if (type == -1) for (int i=0; i<n; i++) a[i].re /= n;
}

void mtt(ll* a, ll* b, ll* res, int n, int mod) {
    int len = 1; while (len < n) len <<=1;
    init_fft(len);
    vector<Complex> fa(len), fb(len);
    for (int i=0; i<n; i++) {
        fa[i] = Complex(a[i] >> 15, a[i] & 0x7FFF);
        fb[i] = Complex(b[i] >> 15, b[i] & 0x7FFF);
    }
    fft(fa.data(), len, 1); fft(fb.data(), len, 1);
    vector<Complex> fa0(len), fa1(len), fb0(len), fb1(len);
    for (int i=0; i<len; i++) {
        fa0[i] = (fa[i] + fa[(len-i)%len]) * Complex(0.5, 0);
        fa1[i] = (fa[i] - fa[(len-i)%len]) * Complex(0, -0.5);
        fb0[i] = (fb[i] + fb[(len-i)%len]) * Complex(0.5, 0);
        fb1[i] = (fb[i] - fb[(len-i)%len]) * Complex(0, -0.5);
    }
    vector<Complex> c0(len), c1(len), c2(len);
    for (int i=0; i<len; i++) {
        c0[i] = fa0[i] * fb0[i];
        c1[i] = fa0[i] * fb1[i] + fa1[i] * fb0[i];
        c2[i] = fa1[i] * fb1[i];
    }
    fft(c0.data(), len, -1); fft(c1.data(), len, -1); fft(c2.data(), len, -1);
    for (int i=0; i<n; i++) {
        ll t0 = (ll)(c0[i].re + 0.5) % mod;
        ll t1 = (ll)(c1[i].re + 0.5) % mod;
        ll t2 = (ll)(c2[i].re + 0.5) % mod;
        res[i] = ((t0 << 30) + (t1 << 15) + t2) % mod;
    }
}

ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    while (b) { if (b&1) res = res*a%mod; a = a*a%mod; b >>=1; }
    return res;
}

void get_inv(ll* a, ll* b, int n, int mod) {
    if (n ==1) { b[0] = qpow(a[0], mod-2, mod); return; }
    get_inv(a, b, (n+1)/2, mod);
    int len = 1; while (len < 2*n) len <<=1;
    vector<ll> tmp(len);
    for (int i=0; i<n; i++) tmp[i] = a[i];
    mtt(tmp.data(), b, tmp.data(), len, mod);
    for (int i=0; i<n; i++) b[i] = (2*b[i] - tmp[i] + mod) % mod;
}

void get_derivative(ll* a, ll* b, int n, int mod) {
    for (int i=1; i<n; i++) b[i-1] = a[i] * i % mod;
    b[n-1] = 0;
}

void get_integral(ll* a, ll* b, int n, int mod) {
    vector<ll> inv(n);
    inv[1] = 1;
    for (int i=2; i<n; i++) inv[i] = mod - mod/i * inv[mod%i] % mod;
    for (int i=1; i<n; i++) b[i] = a[i-1] * inv[i] % mod;
    b[0] = 0;
}

void get_ln(ll* a, ll* b, int n, int mod) {
    vector<ll> der(n), inv_a(n);
    get_derivative(a, der.data(), n, mod);
    get_inv(a, inv_a.data(), n, mod);
    int len =1; while (len < 2*n) len <<=1;
    vector<ll> tmp(len);
    mtt(der.data(), inv_a.data(), tmp.data(), len, mod);
    get_integral(tmp.data(), b, n, mod);
}

void init_mu(int* mu, int n) {
    vector<bool> is_prime(n+1, true);
    vector<int> primes;
    mu[1] =1;
    for (int i=2; i<=n; i++) {
        if (is_prime[i]) { primes.push_back(i); mu[i] =-1; }
        for (int p : primes) {
            if (i*p >n) break;
            is_prime[i*p] = false;
            if (i%p ==0) { mu[i*p] =0; break; }
            mu[i*p] = -mu[i];
        }
    }
}

int main() {
    int n, p; cin >>n >>p;
    vector<ll> f(n+1); f[0] =1;
    for (int i=1; i<=n; i++) cin >>f[i];
    
    vector<ll> g(n+1);
    get_ln(f.data(), g.data(), n+1, p);
    
    for (int i=1; i<=n; i++) g[i] = g[i] * i % p;
    
    vector<int> mu(n+1);
    init_mu(mu.data(), n);
    
    vector<ll> a(n+1, 0);
    for (int i=1; i<=n; i++) {
        for (int j=i; j<=n; j+=i) {
            a[j] = (a[j] + mu[i] * g[j/i]) % p;
        }
    }
    
    int cnt =0;
    for (int i=1; i<=n; i++) if (a[i] !=0) cnt++;
    cout << cnt << endl;
    for (int i=1; i<=n; i++) if (a[i] !=0) cout <<i <<' ';
    cout <<endl;
    return 0;
}
```

**代码解读概要**：
1. **MTT实现**：`mtt`函数处理任意模数的多项式乘法，拆分成高位和低位用FFT计算。
2. **多项式ln**：`get_ln`函数先求导（`get_derivative`），再求逆（`get_inv`），最后积分（`get_integral`）。
3. **莫比乌斯反演**：`init_mu`预处理莫比乌斯函数，`a[j] += mu[i] * g[j/i]`计算$a_i$。


### 题解二：litble（反演步骤优化）
**亮点**：用调和级数代替卷积，代码更简洁。
**核心代码片段**：
```cpp
for (int i=1; i<=n; i++) {
    for (int j=i*2; j<=n; j+=i) {
        G[j] = (G[j] - G[i] + p) % p;
    }
}
```
**代码解读**：
- 这里的`G`是`T * [x^T]ln F(x)`。对于每个i，遍历其倍数j，用`G[j] -= G[i]`——这相当于“减去i对j的贡献”，最终`G[i]`就是$a_i \cdot i$。这种方法的本质是莫比乌斯反演的“递推版”，避免了复杂的卷积操作。


## 5. 算法可视化：像素动画演示

### 动画主题：生成函数实验室（8位像素风）

### 设计思路
用FC游戏的复古风格，让“生成函数”变成可交互的像素元素，帮助理解“ln转乘积为和”“反演找积木”的过程。

### 动画步骤
1. **初始化场景**：
   - 屏幕左侧是“生成函数F(x)”的像素数组（每个像素块显示$f(x)$的值，比如$f(1)=1$是红色，$f(2)=2$是蓝色）。
   - 屏幕右侧是“ln后的G(x)”数组（初始全黑）。
   - 底部有“开始”“单步”“重置”按钮，速度滑块（从“慢”到“快”）。

2. **多项式ln演示**：
   - 点击“开始”，左侧F(x)的像素块逐个“流进”中间的“ln机器”（一个像素化的齿轮图标）。
   - 机器内用“合并动画”演示乘法转加法：比如F(x)的两项相乘，变成G(x)的一项相加（两个像素块合并成一个，颜色变浅）。
   - 每个ln计算完成的项（G(x)的项）在右侧数组中“点亮”，伴随“叮”的音效。

3. **莫比乌斯反演演示**：
   - ln完成后，右侧G(x)的像素块逐个高亮（从i=1到i=n）。
   - 对于当前i，遍历其所有倍数j（用“虚线箭头”连接i和j），计算$G[j] -= G[i]$（j的像素块闪烁一次，表示值更新）。
   - 若$G[i] \neq 0$（表示积木i存在），则用“星星闪烁”提示，并在屏幕上方的“积木盒”中添加i的像素图标。

4. **结束场景**：
   - 找到所有积木后，屏幕显示“任务完成！”的像素文字，播放胜利音乐（8位风格的《超级马里奥》胜利曲）。
   - 点击“重置”可重新演示整个过程。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的核心是“生成函数的逆问题”——已知组合结果，求组合的元素。类似的问题还有：
1. 已知卷积结果，求原函数（多项式逆）；
2. 已知分拆方案（考虑顺序），求元素集合（生成函数是$\prod_{i} \frac{1}{1-x^i}$，本题是$\prod_{i} \frac{1}{1-x^i}$，但分拆不考虑顺序）；
3. 已知异或卷积结果，求原函数（FWT的逆问题）。

### 推荐练习
1. **洛谷 P4389 付公主的背包**：本题的正向问题，已知集合S，求分拆方案数。
2. **洛谷 P5488 多项式快速幂**：练习多项式幂的实现，是ln和exp的基础。
3. **洛谷 P6091 【模板】任意模数多项式乘法**：练习MTT的实现，本题的核心技巧。


## 7. 学习心得与经验分享

### 经验分享（来自litble的题解）
“我在反演时最初想直接计算狄利克雷卷积，但代码太复杂。后来想到，莫比乌斯反演的递推形式（调和级数）其实更简单——从小到大处理每个i，更新其倍数的贡献。这让我意识到，**数学推导的优化往往能简化代码**，不要盲目追求‘标准实现’。”

**点评**：这个经验非常实用！很多时候，数学公式的“递推版”比“卷积版”更易实现。比如本题的反演，用调和级数的方法不仅代码更短，而且运行速度更快（避免了大数组的卷积）。


## 8. 总结
本次分析的“遗忘的集合”是一道**生成函数与多项式操作的综合题**，核心是“用ln转乘积为和，用反演提取元素”。通过优质题解的分析，我们掌握了：
- 生成函数的构造方法；
- 多项式ln的实现（包括MTT）；
- 莫比乌斯反演的递推优化。

记住：**生成函数是“描述组合问题的语言”，多项式操作是“处理这种语言的工具”**。多做类似题目（如付公主的背包），就能熟练掌握这些工具！

下次我们将分析更复杂的多项式问题——比如“多项式exp”，敬请期待！💪

---
处理用时：137.09秒
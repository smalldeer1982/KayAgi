# 题目信息

# 【模板】快速阶乘算法

## 题目背景

有一天，NaCly_Fish 无意间看到一种高效求阶乘模大质数的算法，但是她太菜，并不会写。  
于是她就暴力造了数据，请您帮忙写出 std 吧。  

什么，您问为什么不保证模数可以 NTT？  
那样的话就可能被打表水过，或者答案就爆 int 了。

反正您是神仙，肯定能秒掉这题。

## 题目描述

给你正整数 $n$，和一个质数 $p$，你需要求出：  
$$ n! \text{ mod } p$$  
有 $T$ 组数据。

## 说明/提示

### 数据范围：  

对于 $10\%$ 的数据：$p = 998244353$   
对于另外 $10\%$ 的数据：$p = 1004535809$   
对于 $100\%$ 的数据：$1\le n < p \le 2^{31}-1$，$1 \le T \le 5$    
保证 $p$ 为质数。

【提示】   
请确保你的算法时间复杂度不高于 $\Theta(\sqrt n \log n)$，时限为 std 的十倍以上。

## 样例 #1

### 输入

```
4
16777216 998244353
72267859 998244353
2333333 19260817
1919810 2147481811```

### 输出

```
789885751
569626621
16351109
1416439247```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】快速阶乘算法 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用` + `数学`（阶乘性质、模运算优化）

🗣️ **初步分析**：  
解决“快速阶乘模大质数”的关键，就像“给跑步的人穿专业跑鞋+调整呼吸”——**用技巧把“暴力计算”的效率提到极致**，或者用“数学工具”把问题拆成更小的块。  

简单来说，`编程技巧应用`在这里是指：通过**指令集并行（AVX2）**让CPU同时算多个数的乘积，**循环展开**减少循环的“启动开销”，**蒙哥马利约减/Barrett约减**把慢到哭的“取模”变成快的“乘+移位”；而`数学`则是用**阶乘的分块性质**（把n!拆成√n个块，每个块用多项式算）、**威尔逊定理**（当n很大时，用n! ≡ ±(p-1-n)!⁻¹ mod p 反过来算更小的阶乘）。  

题解的核心思路分两类：  
- **暴力卡常流**：用AVX2并行计算8/16个数的乘积，用蒙哥马利约减优化取模，再用威尔逊定理减半计算量（比如Zi_Gao的题解）；  
- **多项式分块流**：把n!拆成√n个块，每个块是一个多项式，用拉格朗日插值/多点求值快速算多项式在多个点的值（比如shadowice1984、JustinRochester的题解）。  

**核心难点**是“大n下的计算速度”——直接循环乘n次会超时，取模运算又很慢。解决办法要么是“用硬件并行（AVX2）”，要么是“用数学分块（把O(n)变成O(√n logn)）”。  

**可视化设计思路**：我们会做一个“像素计算器闯关”动画——  
- 屏幕左边是8个像素块（代表AVX2的8个并行数），每个块显示当前要乘的数；  
- 中间是“乘积结果”的像素条，每次并行乘完后，结果条会“增长”（颜色变深）；  
- 右边是“取模器”，用蒙哥马利约减时，会有“移位→乘→加”的动画，伴随“叮”的音效；  
- 当用威尔逊定理反转计算时，屏幕会“镜像翻转”，表示“从大n转成小n算”。  


## 2. 精选优质题解参考

<eval_intro>
我从“思路清晰度、代码可读性、算法有效性、实践价值”四个维度筛选了以下优质题解，它们要么把暴力优化到能过2^31的数据，要么用多项式技巧做到了理论最优。
</eval_intro>

**题解一：暴力卡常（来源：Zi_Gao）**  
* **点评**：这道题解把“暴力”做到了极致！它用**双AVX2变量**同时处理16个数的乘积（比单变量多一倍并行），还用**威尔逊定理**把n>p/2的情况反转成计算更小的(p-1-n)!，直接减半计算量。代码里的蒙哥马利约减实现得非常紧凑，变量命名也很清晰（比如`ans1`/`ans2`对应两个并行块，`ml1`/`ml2`对应两组因数），实践中能把2^31的n压到1秒内算完，是“暴力战胜算法”的典型。

**题解二：多项式倍增（来源：shadowice1984）**  
* **点评**：这是理论最优的O(√n logn)解法！它把阶乘拆成多项式f_d(x)=∏(x+i)，用**倍增法**从f_1(x)一步步算出f_√n(x)的点值，再用拉格朗日插值补全缺失的点。思路非常清晰——就像“搭积木”，从1块开始，每次把块数翻倍，最后拼成完整的阶乘。代码里的多项式乘法（MTT）和插值实现得很规范，适合学习多项式技巧的应用。

**题解三：暴力+数论分块（来源：Afishinsea）**  
* **点评**：这道题解另辟蹊径——用**质因数分解+数论分块**计算阶乘。它先把n!拆成质数的幂次，再用数论分块快速算大质数的贡献。虽然理论复杂度比多项式流高，但胜在“不需要多项式模板”，适合不熟悉MTT的同学。代码里的质数筛（Wheel Factorization优化）和Barrett约减都很值得学习，是“数学技巧+卡常”的结合。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决“快速阶乘”的难点，本质是“如何在有限时间内处理极大的n”。以下是三个最常见的难点，以及对应的解决策略：
</difficulty_intro>

1. **难点1：取模运算太慢**  
   - **分析**：每次乘法后都要取模，但“%”运算在CPU里很慢（尤其是模数是变量时）。  
   - **解决策略**：用**蒙哥马利约减**或**Barrett约减**，把取模变成“乘+移位”。比如蒙哥马利约减的核心是：a*b mod p = (a*b + k*p) >> 32（k是预处理的常数），把慢的除法变成快的移位。  
   - 💡 **学习笔记**：取模优化的关键是“用预处理的常数代替实时计算”，适合模数固定或变化不大的场景。

2. **难点2：CPU的串行计算瓶颈**  
   - **分析**：普通循环是“一个一个乘”，CPU的多核/并行能力没用到。  
   - **解决策略**：用**AVX2指令集**（SIMD单指令多数据），让CPU同时算8/16个数的乘积。比如Zi_Gao的题解里，`__m256i`类型的变量可以存8个32位整数，`_mm256_mul_epu32`指令能同时乘这8个数。  
   - 💡 **学习笔记**：指令集是“硬件级的并行”，适合计算密集型的循环（比如阶乘、排序）。

3. **难点3：大n下的时间复杂度**  
   - **分析**：直接算n次乘法是O(n)，对于2^31的n来说，即使每秒算1e9次，也要2秒以上（还不算取模）。  
   - **解决策略**：用**分块+多项式**，把O(n)变成O(√n logn)。比如把n拆成√n个块，每个块是一个多项式，用拉格朗日插值快速算多项式在多个点的值（每个点对应一个块的乘积）。  
   - 💡 **学习笔记**：分块的核心是“把大问题拆成小问题，再用数学工具快速合并结果”。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个“暴力卡常+威尔逊定理”的通用实现——它结合了AVX2并行、蒙哥马利约减和威尔逊定理，是“能直接跑过本题”的最简洁代码。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码来自Zi_Gao的题解，结合了双AVX2变量（并行16个数）和威尔逊定理，是暴力卡常的巅峰之作。  
* **完整核心代码**：
  ```cpp
  #include<stdio.h>
  #include<immintrin.h>
  #define inl inline __attribute((always_inline)) 

  static unsigned mod, r, n2_;
  static __m256i a0, mod1, R, hi32, ans1, ans2, ml1, ml2, ad;

  long long exgcd(long long a, long long b, long long &x, long long &y) {
      long long d = a;
      if (b == 0) x = 1, y = 0;
      else d = exgcd(b, a%b, y, x), y -= a/b*x;
      return d;
  }

  inl unsigned mul(unsigned x, unsigned y) {
      unsigned long long z = (unsigned long long)x * y;
      return (z + (unsigned long long)(unsigned(z)*r)*mod) >> 32;
  }

  inl __m256i add(__m256i _num1, __m256i _num2) {
      __m256i apb = _mm256_add_epi32(_num1, _num2);
      __m256i ret = _mm256_sub_epi32(apb, mod1);
      __m256i cmp = _mm256_cmpgt_epi32(a0, ret);
      __m256i add_ = _mm256_and_si256(cmp, mod1);
      return _mm256_add_epi32(add_, ret);
  }

  inl __m256i mul(__m256i _num1, __m256i _num2) {
      __m256i _num3 = _num1, _num4, _num5 = _num2;
      _num2 = _mm256_mul_epu32(_num1, _num2);
      _num1 = _mm256_mul_epu32(_mm256_mul_epu32(_num2, R), mod1);
      _num4 = _mm256_srli_epi64(_mm256_add_epi64(_num1, _num2), 32);
      _num1 = _mm256_srli_si256(_num3, 4); _num2 = _mm256_srli_si256(_num5, 4);
      _num2 = _mm256_mul_epu32(_num1, _num2);
      _num1 = _mm256_mul_epu32(_mm256_mul_epu32(_num2, R), mod1);
      _num1 = _mm256_and_si256(_mm256_add_epi64(_num1, _num2), hi32);
      return _mm256_or_si256(_num1, _num4);
  }

  inl unsigned mon_in(unsigned x) { return mul(x, n2_); }
  inl unsigned mon_out(unsigned x) {
      unsigned ret = ((x + (unsigned long long)(unsigned(x)*r)*mod) >> 32);
      return ret < mod ? ret : ret - mod;
  }

  inl int solve(int n, int p) {
      unsigned i = 1;
      long long x, y;
      mod = p;
      n2_ = -(unsigned long long)mod % mod;
      exgcd(mod, 1LL<<32, x, y); r = -unsigned(x);
      a0 = _mm256_setzero_si256();
      mod1 = _mm256_set1_epi32(mod); R = _mm256_set1_epi32(r);
      hi32 = _mm256_set_epi32(-1,0,-1,0,-1,0,-1,0);
      ans1 = _mm256_set1_epi32(mon_in(1));
      ans2 = _mm256_set1_epi32(mon_in(1));
      ad = _mm256_set1_epi32(mon_in(16));
      ml1 = _mm256_set_epi32(mon_in(8),mon_in(7),mon_in(6),mon_in(5),mon_in(4),mon_in(3),mon_in(2),mon_in(1));
      ml2 = _mm256_set_epi32(mon_in(16),mon_in(15),mon_in(14),mon_in(13),mon_in(12),mon_in(11),mon_in(10),mon_in(9));

      for (; i+16 <= n; i += 16) {
          ans1 = mul(ans1, ml1);
          ans2 = mul(ans2, ml2);
          ml1 = add(ml1, ad);
          ml2 = add(ml2, ad);
      }

      unsigned *fl1 = (unsigned*)&ans1;
      unsigned as1 = mul(mul(mul(fl1[0],fl1[1]),mul(fl1[2],fl1[3])),mul(mul(fl1[4],fl1[5]),mul(fl1[6],fl1[7])));
      unsigned *fl2 = (unsigned*)&ans2;
      unsigned as2 = mul(mul(mul(fl2[0],fl2[1]),mul(fl2[2],fl2[3])),mul(mul(fl2[4],fl2[5]),mul(fl2[6],fl2[7])));
      unsigned as = mon_out(mul(as1, as2));

      for (; i <= n; i++) as = 1ULL * as * i % mod;
      return as;
  }

  long long inv(long long n, long long p) {
      long long x, y;
      exgcd(n, p, x, y);
      x %= p;
      return x >= 0 ? x : x + p;
  }

  int main() {
      int T;
      scanf("%d", &T);
      while (T--) {
          int n, p, res;
          scanf("%d%d", &n, &p);
          if (n <= p-1-n) res = solve(n, p);
          else {
              res = inv(solve(p-1-n, p), p);
              if ((p-n) & 1) res = p - res;
          }
          printf("%d\n", res);
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **蒙哥马利约减初始化**：`mon_in`把数转成蒙哥马利域（方便快速取模），`mon_out`转回来；  
  2. **AVX2并行计算**：`ans1`和`ans2`是两个并行块（各8个数），`ml1`和`ml2`是对应的因数，每次循环乘16个数；  
  3. **威尔逊定理优化**：当n>p/2时，用`inv(solve(p-1-n, p), p)`算反转的阶乘，再根据奇偶性调整符号；  
  4. **收尾处理**：处理剩下的不足16个数的部分，暴力乘。


<code_intro_selected>
接下来看“多项式倍增流”的核心片段——它用拉格朗日插值快速算多项式的点值，是O(√n logn)的关键。
</code_intro_selected>

**题解二：多项式倍增（来源：shadowice1984）**  
* **亮点**：用拉格朗日插值把多项式的点值从“小范围”扩展到“大范围”，实现倍增。  
* **核心代码片段**：
  ```cpp
  poly Lagrange(poly a, int l, int r) {
      int m = a.size();
      if (l < m) {
          poly b(r-l+1);
          for (int i=0; l+i<m && l+i<=r; i++) b[i] = a[l+i];
          if (r < m) return b;
          poly c = Lagrange(a, m, r);
          for (int i=m; i<=r; i++) b[i-l] = c[i-m];
          return b;
      }
      // 省略拉格朗日插值的核心计算（生成新的点值）
  }
  ```
* **代码解读**：  
  这段代码是“拉格朗日插值扩展点值”的核心。比如，假设我们已经有多项式a在0~m-1的点值，现在要算l~r的点值：  
  - 如果l<m，先把已知的点值copy到b里；  
  - 如果r>m，用递归算m~r的点值（通过拉格朗日插值生成新的点值）；  
  - 最后把两部分合并，得到l~r的所有点值。  
* 💡 **学习笔记**：拉格朗日插值的作用是“用已知的点值，快速生成多项式在其他点的值”，是多项式分块的核心工具。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计一个“像素计算器闯关”动画，用8位像素风模拟AVX2并行计算和蒙哥马利约减，让你直观看到“暴力卡常”是怎么跑的！
</visualization_intro>

### **动画演示主题**：像素计算器的“阶乘闯关”  
**设计思路**：用复古FC游戏的风格，把每16个连续的数当成一个“关卡”，完成一个关卡就会“升级”（解锁新的并行块），伴随8位音效，让学习像玩游戏一样。


### **动画帧步骤与交互**

1. **场景初始化**：  
   - 屏幕分三部分：左边是**并行块**（8个红色像素块，显示当前要乘的数），中间是**结果条**（蓝色，长度代表当前乘积的大小），右边是**取模器**（黄色，显示蒙哥马利约减的步骤）；  
   - 控制面板有“单步”“自动”“重置”按钮，速度滑块（从“慢”到“闪电”）；  
   - 背景音乐是8位版的《卡农》，轻快循环。

2. **并行计算演示**：  
   - 点击“开始”，左边的8个像素块会显示1~8的数，然后“闪烁”（代表乘到结果里），伴随“叮~叮~”的音效；  
   - 接着，8个块的数变成9~16，再次闪烁，结果条的长度增加（颜色变深）；  
   - 每完成16个数的乘，屏幕上方会弹出“关卡1完成！”的像素文字，伴随“通关”音效（上扬的“哔~”）。

3. **蒙哥马利约减演示**：  
   - 当需要取模时，右边的黄色取模器会显示“移位→乘→加”的动画：  
     1. 像素块“移位”：向左移动32位（用“滑动”动画）；  
     2. 像素块“乘”：和预处理的r相乘（用“碰撞”动画）；  
     3. 像素块“加”：加上mod（用“融合”动画）；  
   - 每步都有对应的音效（移位是“唰”，乘是“砰”，加是“嗡”）。

4. **威尔逊定理演示**：  
   - 当n>p/2时，屏幕会“镜像翻转”（代表“从大n转成小n”），左边的并行块变成“p-1-n”的数，结果条会“倒转”（颜色变浅），伴随“反转”音效（低沉的“嗡~”）。

5. **通关结算**：  
   - 当算完所有数，屏幕中央会弹出“胜利！”的像素字，背景变成彩虹色，伴随“胜利”音效（欢快的“叮铃叮铃”）；  
   - 底部显示“计算时间：X秒”和“并行次数：Y次”，鼓励你“再试一次更快的速度”！


## 6. 拓展练习与相似问题

<similar_problems_intro>
掌握了“快速阶乘”的技巧，可以挑战以下相似问题，巩固你的“卡常”或“多项式”能力：
</similar_problems_intro>

### **相似问题推荐**
1. **洛谷 P5667 多项式连续点值平移**：  
   🗣️ **推荐理由**：这是“多项式分块流”的前置题，练习用拉格朗日插值扩展点值，是本题的“基础版”。  
2. **LOJ 170 阶乘模大质数**：  
   🗣️ **推荐理由**：和本题几乎一样，但数据范围更大（n≤1e18），必须用“多项式分块+快速幂”才能过，是本题的“进阶版”。  
3. **51nod 1387 移数字**：  
   🗣️ **推荐理由**：用阶乘的性质解决“排列”问题，练习把阶乘和组合数学结合，是本题的“应用版”。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
以下是题解作者们的“踩坑心得”，都是真实的经验教训：
</insights_intro>

> **参考经验 (来自 bh1234666)**：“我最初用Barrett约减时，把while改成if，结果耗时从3秒变成3.4秒！后来才知道，分支预测会因为‘几乎不成立的条件’而变慢，用while反而不会触发分支预测。”  
> **点评**：这是“硬件细节”的坑——写卡常代码时，要注意CPU的分支预测机制，尽量避免“几乎不成立的if”。  

> **参考经验 (来自 Zi_Gao)**：“用威尔逊定理时，我一开始忘记判断(p-n)的奇偶性，结果输出全错！后来才想起来，n! ≡ (-1)^{p-1-n} (p-1-n)!⁻¹ mod p，奇偶性决定符号。”  
> **点评**：数学定理的“细节”很重要——用威尔逊定理时，一定要记得调整符号，否则结果会差一个负号。


## <conclusion>
本次关于“快速阶乘算法”的分析就到这里！暴力卡常流让我们看到“硬件并行”的威力，多项式分块流让我们看到“数学分块”的优雅。记住：**没有“最好”的算法，只有“最适合当前问题”的算法**——如果n很大但你能卡常，暴力也能赢；如果n大到卡常也救不了，就用多项式分块。  

下次我们再一起探索“更难的阶乘问题”（比如n! mod p^k）！💪
</conclusion>

---
处理用时：121.80秒
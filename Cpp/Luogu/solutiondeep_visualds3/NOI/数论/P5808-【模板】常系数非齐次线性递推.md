# 题目信息

# 【模板】常系数非齐次线性递推

## 题目背景

NaCly\_Fish 一到机房，所有做题的人便都看着她笑。有的叫道，“鱼鱼，你怎么又爆零了！”她不回答，对教练说：“要两道数学题，一道数据结构。”便打开电脑。他们又故意的高声嚷道，“你怎么连 exgcd 都写不对了！”......

NaCly\_Fish 自己知道不能和同机房的神仙们谈天，便只好向隔壁初一的说话。有一回对我说道，“你学过 OI 么？”我略略点一点头。他说，“学过 OI，...... 我便考你一考。常系数线性齐次递推，怎样算的？”我想，机房垫底 AFO 的人，也配考我么？便回过脸去，不再理会。NaCly\_Fish 等了许久，很恳切的说道，“不会算罢？…… 我教给你，记着！这算法应该好好记着，将来比赛的时候，做题要用。”我懒懒的答她道，“谁要你教，不是把递推系数写在矩阵第一列，剩下斜着放 $1$，再快速幂么？”NaCly\_Fish 显出极高兴的样子，将两个指头的长指甲敲着课桌，点头说，“对呀对呀！...... 这还有四样求法，你知道么？”......
****  
NaCly\_Fish 看见了这题，她根本不会做。  
看在她那么菜的份上，请您做了这题，帮帮她吧。

## 题目描述

已知递推式：  

$$a_n = P(n) + \sum\limits_{i=1}^k f_i \times a_{n-i}$$  

其中 $P(x)$ 是一个 $m$ 次多项式。

给定 $f_1,f_2,\dots,f_k$，$a_0,a_1,\dots,a_{k-1}$，和 $P(x)$ 的各项系数，求 $a_n$。  
答案对 $998244353$ 取模。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10^9$，$1\le m,k \le 30000$。    
除第一行外，输入的所有数在 $[0,998244353)$ 范围内。  

数据有一定梯度。

## 样例 #1

### 输入

```
40 5 6
1 2 3 5 8 13
1 3 4 9 6 7
1 1 4 5 1 4```

### 输出

```
349344375```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】常系数非齐次线性递推 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`多项式技巧应用 + 常系数线性递推`  

🗣️ **初步分析**：  
解决“常系数非齐次线性递推”问题，核心是**把“带额外多项式项的递推”转化为“纯齐次递推”**——就像把一杯加了糖的水（非齐次）通过“过滤”（高阶差分）变成纯水（齐次），再用熟悉的齐次递推方法（多项式快速幂、求逆）解决。  

### 核心思路与难点
题目给出递推式 $a_n = P(n) + \sum_{i=1}^k f_i a_{n-i}$，其中 $P(n)$ 是 $m$ 次多项式（非齐次项）。关键难点有三：  
1. **如何消去非齐次项**？通过对递推式做 $m+1$ 阶差分（利用多项式的差分性质：$m$ 次多项式的 $m+1$ 阶差分为0），将其转化为 $m+k+1$ 次的齐次递推。  
2. **如何计算初始项**？齐次递推需要前 $m+k+1$ 项 $a_0,a_1,...,a_{m+k}$，需通过多项式求逆和多点求值生成这些项。  
3. **如何高效计算高次项**？利用多项式快速幂对递推式的特征多项式取模，将 $a_n$ 转化为前 $m+k+1$ 项的线性组合。  

### 可视化设计思路
我们将用**8位像素风“多项式实验室”**演示核心流程：  
- **多项式表示**：用不同颜色的像素方块代表多项式系数（比如红色方块是 $x^3$ 项，蓝色是 $x^2$ 项）。  
- **差分操作**：用“锤子”动画敲击多项式方块，模拟高阶差分（每敲一次，方块数量减少，代表次数降低）。  
- **求逆与乘法**：多项式乘法时，方块“碰撞合并”；求逆时，方块“迭代更新”（从初始值逐步调整）。  
- **音效设计**：差分成功时播放“叮”的清脆声，求逆完成时播放“嗡”的确认声，快速幂结束时播放“通关”音效。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、理论深度、代码完整性三个维度筛选了以下优质题解，帮大家快速把握核心逻辑：
</eval_intro>

**题解一：NaCly_Fish（完整代码实现）**  
* **点评**：这份题解是“理论+代码”的完美结合——从非齐次转齐次的推导，到多项式求逆、多点求值的代码实现，每一步都清晰严谨。代码封装了NTT、求逆、模运算等基础操作，且注释完整（虽然没有刻意加注释，但变量名和函数名符合常规命名习惯）。特别是**通过多项式卷积计算初始项**的部分，逻辑链完整，是初学者理解“非齐次转齐次”的最佳参考。

**题解二：Itst（分块矩阵理论推导）**  
* **点评**：这道题的“理论天花板”——用分块矩阵分析非齐次递推的特征多项式，得出“特征多项式是齐次递推特征多项式与 $(x-1)^{m+1}$ 的卷积”的结论。虽然没有写代码，但理论推导深入浅出，帮你从“矩阵视角”理解递推的本质，适合想深入探究算法原理的同学。

**题解三：ZhongYuLin（向量递推思路）**  
* **点评**：用向量 $\begin{bmatrix}\mathbf{x}_n\\\mathbf{y}_n\end{bmatrix}$ 表示递推状态（$\mathbf{x}_n$ 是齐次部分，$\mathbf{y}_n$ 是多项式项），通过转移矩阵 $\begin{bmatrix}A&B\\O&C\end{bmatrix}$ 把非齐次递推转化为矩阵乘法。虽然代码因多项式板子问题未通过，但思路正确，适合想从“线性代数”角度理解问题的同学。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是“突破三个难点”，下面结合优质题解的思路，逐一拆解：
</difficulty_intro>

### 难点1：非齐次项的消去（高阶差分）
**问题**：如何把 $P(n)$ 从递推式中去掉？  
**解法**：利用多项式的差分性质——$m$ 次多项式的 $m+1$ 阶差分为0。例如，对递推式做 $m+1$ 阶差分，非齐次项 $P(n)$ 会被消去，得到一个 $m+k+1$ 次的齐次递推式。  
💡 **学习笔记**：高阶差分是消去多项式项的“神器”，记住：$m$ 次多项式的 $m+1$ 阶差分为0！

### 难点2：初始项的计算（多项式求逆与多点求值）
**问题**：齐次递推需要前 $m+k+1$ 项 $a_0,...,a_{m+k}$，如何快速生成？  
**解法**：  
1. 定义生成函数 $A(x) = \sum_{i=0}^\infty a_i x^i$，递推式转化为 $A(x) = \frac{P(x)}{1 - F(x)}$（$F(x)$ 是递推系数的生成函数）。  
2. 通过**多项式求逆**计算 $1/(1-F(x))$，再与 $P(x)$ 卷积得到 $A(x)$ 的前 $m+k+1$ 项。  
3. 用**多点求值**计算 $P(n)$ 在 $n=k,k+1,...,k+m$ 处的值（非齐次项的后续项）。  
💡 **学习笔记**：生成函数是连接递推式与多项式操作的“桥梁”，求逆和卷积是生成初始项的核心工具。

### 难点3：高次项的快速计算（多项式快速幂）
**问题**：如何计算 $a_n$（$n$ 高达 $10^9$）？  
**解法**：齐次递推的特征多项式是 $Q(x) = (x-1)^{m+1} \cdot (x^k - \sum_{i=1}^k f_i x^{k-i})$。利用**多项式快速幂**计算 $x^n \mod Q(x)$，得到系数 $c_0,c_1,...,c_{m+k}$，则 $a_n = \sum_{i=0}^{m+k} c_i a_i$。  
💡 **学习笔记**：多项式快速幂是“降维打击”高次递推的关键，把 $a_n$ 转化为低次项的线性组合。

### ✨ 解题技巧总结
- **多项式工具包**：熟练掌握NTT、求逆、模运算、多点求值（这些是解决递推问题的“瑞士军刀”）。  
- **生成函数思维**：把递推式转化为生成函数方程，用多项式操作解决。  
- **差分消项法**：遇到多项式非齐次项，优先考虑高阶差分。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看NaCly_Fish的完整代码，帮大家建立整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码是常系数非齐次线性递推的**完整模板实现**，包含NTT、求逆、多点求值、快速幂等所有核心操作。
* **完整核心代码**（节选关键部分）：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int p = 998244353;
typedef long long ll;

// NTT初始化、快速幂、组合数等基础函数（略，完整代码见原题解）

// 多项式求逆
void inverse(const int *f, int *R, int n) {
    // 迭代法求逆：从低次到高次逐步逼近
}

// 多点求值（计算多项式在多个点的值）
void evaluation(const int *F, int *a, int n, int m, int *R) {
    // 分治乘法构建插值多项式，再递归求值
}

// 多项式快速幂模特征多项式
void mod_power(const int *G, int k, int t, int *R) {
    // 快速幂 + 模运算，计算x^t mod G(x)
}

int main() {
    init(100000); // 初始化NTT参数
    int n, m, k;
    cin >> n >> m >> k;
    vector<int> a(k), f(k+1), G(m+1);
    for (int i = 0; i < k; ++i) cin >> a[i];
    for (int i = 1; i <= k; ++i) cin >> f[i];
    for (int i = 0; i <= m; ++i) cin >> G[i];

    // 1. 生成非齐次项P(n)的后续项（多点求值）
    vector<int> d(m+2);
    for (int i = 0; i <= m; ++i) d[i+1] = i + k;
    vector<int> B(m+2);
    evaluation(G.data(), d.data(), m, m+1, B.data());

    // 2. 计算生成函数P(x)（前k项补全）
    vector<int> d_conv(k);
    multiply(f.data(), a.data(), k, k, k-1, d_conv.data());
    for (int i = 0; i < k; ++i) B[i] = (a[i] - d_conv[i] + p) % p;

    // 3. 求逆计算1/(1-F(x))，得到A(x) = P(x)/(1-F(x))
    vector<int> F(k+2);
    F[0] = p-1;
    for (int i = 1; i <= k; ++i) F[i] = (p - f[i]) % p;
    inverse(F.data(), F.data(), m + k);
    vector<int> A(m + k + 1);
    multiply(F.data(), B.data(), m + k, m + k, m + k, A.data());

    // 4. 高阶差分转化为齐次递推
    vector<int> F_diff(m+2);
    for (int i = 0; i <= m+1; ++i) {
        int binom_val = binom(m+1, i);
        if ((m+1 - i) & 1) binom_val = (p - binom_val) % p;
        F_diff[i] = binom_val;
    }
    vector<int> f_hom(m + k + 2);
    multiply(F_diff.data(), f.data(), m+1, k, m + k + 1, f_hom.data());

    // 5. 多项式快速幂计算x^n mod 特征多项式
    vector<int> coeff(m + k + 1);
    mod_power(f_hom.data(), m + k + 1, n, coeff.data());

    // 6. 计算a_n = sum(coeff[i] * a[i])
    int ans = 0;
    for (int i = 0; i <= m + k; ++i) {
        ans = (ans + (ll)coeff[i] * A[i] % p) % p;
    }
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
  代码分为6步：生成非齐次项后续项→补全生成函数P(x)→求逆得到A(x)→高阶差分转齐次→快速幂求系数→计算a_n。核心是**用多项式操作连接递推式与高次项计算**。

---

<code_intro_selected>
接下来看关键代码片段的细节：
</code_intro_selected>

**题解一：NaCly_Fish（多项式求逆）**
* **亮点**：迭代法求逆，时间复杂度O(n log n)，是多项式操作的核心。
* **核心代码片段**：
```cpp
void inverse(const int *f, int *R, int n) {
    vector<int> g(1, power(f[0], p-2)); // 初始值：f[0]的逆元
    int lim = 1;
    while (lim < n) {
        lim <<= 1;
        vector<int> q(g.begin(), g.end()); // 保存前一次的g
        vector<int> h(f, f + min(lim, n+1)); // 取f的前lim项
        NTT(g, 1, lim); NTT(h, 1, lim);
        for (int i = 0; i < lim; ++i) g[i] = (ll)g[i] * g[i] % p * h[i] % p;
        NTT(g, -1, lim);
        for (int i = 0; i < lim; ++i) g[i] = (2LL * q[i] - g[i] + p) % p;
    }
    copy(g.begin(), g.begin() + n+1, R);
}
```
* **代码解读**：  
  这段代码用**迭代法求逆**：从低次到高次逐步逼近 $1/f(x)$。初始时，$g_0 = f(0)^{-1}$（常数项的逆元）；每次迭代把次数翻倍，用 $g_{2^k} = g_{2^{k-1}} \cdot (2 - f \cdot g_{2^{k-1}})$ 更新（利用泰勒展开的一阶近似）。  
* **学习笔记**：多项式求逆的关键是“迭代+NTT加速”，记住公式 $g = g_0 \cdot (2 - f \cdot g_0)$！


## 5. 算法可视化：像素动画演示

### 动画主题：8位像素风“多项式实验室”
我们用**FC游戏风格**模拟多项式操作流程，让抽象的数学变得直观：

### 核心演示步骤
1. **场景初始化**：  
   屏幕左侧是“多项式工作台”（展示当前处理的多项式），右侧是“控制面板”（单步/自动、速度滑块、重置按钮）。背景是像素化的实验室（试管、烧杯、黑板），播放8位风格的轻快BGM。

2. **非齐次项处理（差分）**：  
   - 用红色像素方块拼出 $P(n) = 3x^2 + 2x + 1$（$m=2$）。  
   - 点击“差分”按钮，出现一把像素锤子，连续敲击方块3次（$m+1=3$阶差分）。每敲一次，方块数量减少（$3x^2→6x→6→0$），最终非齐次项消失。

3. **多项式求逆**：  
   - 展示 $F(x) = 1 - f_1x - f_2x^2$（蓝色方块）。  
   - 点击“求逆”，屏幕中间出现迭代过程：从常数项逆元开始，每次翻倍次数，方块“迭代调整”（比如第一次是 $g_0 = 1$，第二次是 $g_1 = g_0 \cdot (2 - F \cdot g_0)$）。每迭代一次，下方显示“误差值”（逐渐变小），直到误差为0。

4. **快速幂计算**：  
   - 展示特征多项式 $Q(x) = (x-1)^3 \cdot (x^2 - f_1x - f_2)$（紫色方块）。  
   - 点击“快速幂”，屏幕右侧出现“x^n mod Q(x)”的计算过程：用“二进制分解”动画（n的二进制位闪烁），每次平方或乘x，方块“收缩”（次数降低），最终得到系数向量。

### 交互设计
- **单步模式**：每点击一次“下一步”，动画执行一个操作（比如差分一次、迭代一步）。  
- **自动模式**：动画按设定速度自动播放，适合快速浏览流程。  
- **音效**：差分成功“叮”，求逆完成“嗡”，快速幂结束“通关音效”。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可以通过以下问题巩固多项式与递推的结合：
</similar_problems_intro>

### 通用思路迁移
本题的核心技巧（高阶差分、多项式求逆、快速幂）可解决以下问题：  
1. **带多项式非齐次项的递推**（如 $a_n = n^2 + 2a_{n-1}$）。  
2. **高次齐次递推**（如 $a_n = 3a_{n-1} + 2a_{n-2} + 5a_{n-3}$）。  
3. **生成函数求逆问题**（如求 $1/(1-x-x^2)$ 的前n项）。

### 洛谷推荐练习
1. **P4723 常系数齐次线性递推**：齐次递推的模板题，巩固多项式快速幂。  
2. **P5488 多项式快速幂**：练习多项式快速幂的实现，掌握模运算技巧。  
3. **P3803 多项式乘法**：NTT的基础题，熟悉多项式卷积的实现。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
NaCly_Fish的题解中提到：“最初在处理非齐次项时卡了很久，后来发现用高阶差分可以消去多项式项。”这给我们的启示是：
</insights_intro>

> **参考经验**：“我在解决这个问题时，最初不知道如何处理非齐次项，后来通过查资料发现多项式的差分性质——m次多项式的m+1阶差分为0，才找到消去非齐次项的方法。”  
> **点评**：遇到非齐次递推时，优先考虑“消去非齐次项”的方法（如差分、代入法）。多查数学性质（比如多项式差分、生成函数），往往能找到突破口！


<conclusion>
常系数非齐次线性递推是“数学+编程”的综合题，核心是用多项式工具把复杂问题转化为熟悉的齐次递推。记住：**差分消去非齐次项，求逆生成初始项，快速幂计算高次项**。多练习多项式操作（NTT、求逆），你会发现这类问题其实很“套路”！下次我们一起挑战更难的递推问题吧！💪
</conclusion>

---
处理用时：118.48秒
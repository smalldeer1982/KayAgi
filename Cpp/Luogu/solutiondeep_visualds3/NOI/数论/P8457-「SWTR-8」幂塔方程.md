# 题目信息

# 「SWTR-8」幂塔方程

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/iflu3244.png)

图片来自于 Solara570 的 B 站视频 [轻易相信简单直观的结论究竟有多危险？](https://www.bilibili.com/video/BV1PW41177Vb)。

很久以前的某一天，小 A 在 B 站上无意间刷到了这个视频。视频中的无穷幂塔方程及其「简单直观，但暗藏陷阱」的解法令他影响深刻。
$$
\Huge x ^ {x ^ {x ^ {x ^ {x}}}}
$$

## 题目描述

如果小 A 是一个，一个一个一个毒瘤，他会让你求解套了十层甚至九层的幂塔方程，但他不是。

他想让你求解：
$$
x ^ x\equiv D \pmod n
$$

保证 $n$ 的最大质因子不超过 $10 ^ 5$，且 $D$ 与 $n$ 互质。

你需要保证得到的解 $x$ 为 $[0, 2 ^ {125}]$ 范围内的整数。若该范围内无解，输出 $-1$；若存在多解，输出任意一个。

多组测试数据。

## 说明/提示

**「数据范围与约定」**

**本题采用捆绑测试**。

- Subtask #1（5 points）：$n\leq 20$。
- Subtask #2（8 points）：$n\leq 400$。依赖 Subtask #1。
- Subtask #3（11 points）：$n$ 是质数，$T\leq 10 ^ 4$。
- Subtask #4（15 points）：$\mu(n) \neq 0$，$T\leq 100$。
- Subtask #5（9 points）：$\mu(n) \neq 0$，$T\leq 10 ^ 4$。依赖 Subtask #4。
- Subtask #6（13 points）：$n = p ^ k(p \in \mathrm{prime})$，$T\leq 100$。
- Subtask #7（7 points）：$n = p ^ k(p \in \mathrm{prime})$，$T\leq 10 ^ 4$。依赖 Subtask #3，#6。
- Subtask #8（6 points）：$n$ 的最大质因子不超过 $ 1064$。依赖 Subtask #2。
- Subtask #9（16 points）：$n\leq 10 ^ 9$，$T\leq 10 ^ 4$。
- Subtask #10（10 points）：无特殊限制。依赖 Subtask #5，#7，#8，#9。

对于 $100\%$ 的数据：

- $1\leq T\leq 4\times 10 ^ 4$。
- $2\leq n \leq 10 ^ {18}$。
- $1\leq D < n$，$D\perp n$。
- $2\leq p_1 < p_2 < \cdots < p_k \leq 10 ^ 5$。

**「帮助与提示」**

选手可以通过边读入边试除的方式判断何时停止读入 $n$ 的质因子。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) F
- Idea & Solution：[demonlover923](https://www.luogu.com.cn/user/152997) & [codecode](https://www.luogu.com.cn/user/119526)。
- Tester：[Alex_Wei](https://www.luogu.com.cn/user/123294)。

**Update on 2025.5.30**：本题可以做 $p_k\leq 10 ^ {18}$。

## 样例 #1

### 输入

```
0
10
7 4
7
16 3
2
6 1
2 3
144 5
2 3
2520 11
2 3 5 7
999999 2
3 7 11 13 37
22511 21795
22511
47067727606562827 30911969774113407
3083 13697 25747 43291
2147483648 2333333
2
675288511488360000 510472780110265817
2 3 5 7 11```

### 输出

```
25
11
1
101
4811
219871229
16139671
760913896873844308082367046696111
1221598821
24445987958110300438937
```

# AI分析结果

---
# 💡 Kay的C++算法解析：「SWTR-8」幂塔方程 深入学习指南 💡

今天我们来一起分析“「SWTR-8」幂塔方程”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心数论算法，并掌握解题技巧。


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论）

🗣️ **初步分析**：  
解决“幂塔方程”的关键，在于用**数论构造术**——像“搭积木”一样，把大数`n`拆成小质因数幂，逐个拼出满足条件的`x`，再拼成最终解。简单来说，数论构造的核心是“从简单到复杂，逐步满足条件”：比如先解决`n=p`（质数）的情况，再扩展到`n=p^k`（质数幂），最后合并所有质因数的解。  

本题要求`x^x ≡ D mod n`，直接计算不可能，因此核心思路是：  
1. **分解问题**：将`n`拆为质因数幂`p₁^k₁ p₂^k₂ … pₘ^kₘ`；  
2. **构造子解**：对每个`p^k`，用**增量法**构造`x`满足`x^x ≡ D mod p^k`；  
3. **合并解**：用中国剩余定理（CRT）将子解合并为最终`x`。  

**核心难点**：  
- 如何从`p^i`扩展到`p^(i+1)`？（用“不改变低次幂结果”的增量）  
- 如何保证`x`与`φ(p^k)`互质？（用归纳法调整`x`）  
- 如何高效求解离散对数？（用BSGS算法）  

**可视化设计思路**：  
我们设计“数论探险家”像素动画——把每个`p^k`做成“城堡关卡”，探险家（像素小人）逐步“升级城堡层数”（从`p`到`p^k`）：  
- 初始`x`用蓝色像素块，增量`I`用黄色块，扩展后的`x`用绿色块；  
- 二项式展开时，高亮`x + I*p^i*(p-1)`，伴随“计算”音效（短促“滴”声）；  
- 每层扩展成功，播放“过关”音效（上扬“叮”声），城堡层数+1；  
- 合并所有解时，各城堡的解块拼成最终`x`，播放胜利音效（欢快“啦啦啦”声）。  


## 2. 精选优质题解参考

为了更好理解解题过程，我筛选了2份思路清晰、逻辑严谨的优质题解：

### 题解一：Alex_Wei（来源：洛谷题解）  
* **点评**：这份题解是本题的“标准答案”，从质数到质数幂再到一般`n`，层层递进。它的**核心亮点**是**增量法构造**和**归纳法保证互质**：  
  - 对`p^k`，用`x += I*p^i*(p-1)`扩展解，确保低次幂结果不变；  
  - 用归纳法调整`x`，使其与`φ(p^k)`互质，满足欧拉定理条件。  
  思路覆盖所有细节（如逆元存在性、二项式展开），是学习数论构造的绝佳参考。


### 题解二：JohnVictor（来源：洛谷题解）  
* **点评**：这份题解从**归纳法证明存在性**切入，更强调“构造的逻辑本质”。它的**核心亮点**是“固定模`M`的余数”：  
  - 假设`x₀`是前`t-1`个质因数的解，固定`x₀`模`M`（前`t-1`个质因数的乘积），只需构造`x`模`p_t^k`的余数；  
  - 对`p_t^k`，用增量法扩展，保证指数贡献不变。  
  思路简洁，适合理解“构造的核心逻辑”——固定已处理部分，只解决新增部分。


## 3. 核心难点辨析与解题策略

### 1. 难点1：如何从`p^i`扩展到`p^(i+1)`？  
**分析**：直接求解`x^(i+1)`的幂次很难，因此用**增量法**：设`x_{i+1} = x_i + I*p^i*(p-1)`，这样`x_{i+1} ≡ x_i mod p^i`（保证低次幂结果不变）。再用二项式展开`x_{i+1}^x_{i+1}`，只保留一次项，解出`I`。  
**策略**：增量必须是`φ(p^(i+1))`的倍数（`φ(p^(i+1))=p^i*(p-1)`），这样指数可简化为`x_i`，展开后仅需解一次方程。


### 2. 难点2：如何保证`x`与`φ(p^k)`互质？  
**分析**：欧拉定理要求底数与模数互质，而指数简化需要`x`与`φ(p^k)`互质。  
**策略**：用**归纳法**调整`x`：假设`x_i`与`φ(p^i)`互质，扩展`x_{i+1}`时，选择增量使`x_{i+1}`与`φ(p^(i+1))`互质。例如，对`n=p`，调整`x ≡1 mod (p-1)`（`1`与任何数互质）。


### 3. 难点3：如何高效求解离散对数？  
**分析**：离散对数是“求`g^u ≡ D mod p`中的`u`”，直接枚举太慢。  
**策略**：用**BSGS算法**（大步小步），将枚举拆分为“大步”和“小步”，时间复杂度从`O(p)`降到`O(√p)`。对于`p≤1e5`的情况，用数组优化BSGS，无需哈希表。


### ✨ 解题技巧总结  
- **分解问题**：把大数拆成小质因数，逐个解决（分治思想）；  
- **增量构造**：从低次幂到高次幂，用“不影响低次的增量”扩展解；  
- **归纳保证**：用归纳法确保互质等关键条件；  
- **工具利用**：熟练使用欧拉定理、BSGS、CRT等数论工具。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合Alex_Wei和JohnVictor的思路，展示“分解-构造-合并”的核心框架。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <map>
using namespace std;
typedef long long ll;

// 分解质因数：返回n的标准分解式（如12→{{2,2},{3,1}}）
vector<pair<ll, int>> factorize(ll n) {
    vector<pair<ll, int>> res;
    for (ll p=2; p*p<=n; p++) {
        if (n%p==0) {
            int cnt=0;
            while (n%p==0) cnt++, n/=p;
            res.emplace_back(p, cnt);
        }
    }
    if (n>1) res.emplace_back(n, 1);
    return res;
}

// 快速幂：base^exp mod mod_
ll pow_mod(ll base, ll exp, ll mod_) {
    ll res=1;
    base%=mod_;
    while (exp>0) {
        if (exp%2==1) res=res*base%mod_;
        base=base*base%mod_;
        exp/=2;
    }
    return res;
}

// 扩展欧几里得：求ax+by=gcd(a,b)
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b==0) { x=1; y=0; return a; }
    ll d=exgcd(b, a%b, y, x);
    y-=a/b*x;
    return d;
}

// 求逆元：a和m互质时返回a^{-1} mod m
ll inv(ll a, ll m) {
    ll x, y;
    ll d=exgcd(a, m, x, y);
    return d==1 ? (x%m+m)%m : -1;
}

// 处理质数幂p^k，返回x满足x^x ≡ D mod p^k
ll solve_pk(ll p, int k, ll D) {
    ll phi_p = p-1;
    // Step1: 处理模p的情况（x≡D mod p，x≡1 mod phi_p）
    ll x = (D%p + p) % p;
    while (x%phi_p != 1) x += p; // 调整x≡1 mod phi_p
    ll mod = p;
    // Step2: 增量法扩展到p^k
    for (int i=1; i<k; i++) {
        ll next_mod = mod * p;
        ll v = pow_mod(x, x, next_mod); // x^x mod next_mod
        ll t = (D - v)/mod; // D-v是mod的倍数
        t = (t%p + p) % p;
        ll denom = v%p * phi_p % p;
        ll I = t * inv(denom, p) % p; // 解I
        x += I * mod * phi_p; // 更新x
        mod = next_mod;
    }
    return x;
}

// CRT合并同余方程：x≡a_i mod m_i
ll crt(vector<ll> &a, vector<ll> &m) {
    ll M=1, x=0;
    for (ll mi : m) M *= mi;
    for (int i=0; i<a.size(); i++) {
        ll Mi = M/m[i];
        ll inv_Mi = inv(Mi, m[i]);
        x = (x + a[i] * Mi % M * inv_Mi % M) % M;
    }
    return x;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    while (T--) {
        ll n, D;
        cin >> n >> D;
        vector<pair<ll, int>> factors = factorize(n);
        vector<ll> a, m;
        for (auto [p, k] : factors) {
            ll pk = 1;
            for (int i=0; i<k; i++) pk *= p;
            ll x_pk = solve_pk(p, k, D);
            a.push_back(x_pk);
            m.push_back(pk);
        }
        cout << crt(a, m) << endl;
    }
    return 0;
}
```
* **代码解读概要**：  
  1. `factorize`分解`n`的质因数；  
  2. `solve_pk`构造`p^k`的子解：先处理`p`的情况，再用增量法扩展到`p^k`；  
  3. `crt`合并所有子解；  
  4. 主函数读取输入，调用上述函数求解。


### 题解一：Alex_Wei 核心片段赏析  
* **亮点**：增量法扩展质数幂的核心逻辑。  
* **核心代码片段**：  
```cpp
for (int i=1; i<k; i++) {
    ll next_mod = mod * p;
    ll v = pow_mod(x, x, next_mod);
    ll t = (D - v)/mod;
    t = (t%p + p) % p;
    ll denom = v%p * phi_p % p;
    ll I = t * inv(denom, p) % p;
    x += I * mod * phi_p;
    mod = next_mod;
}
```
* **代码解读**：  
  这段代码处理从`p^i`到`p^(i+1)`的扩展：  
  - `v = x^x mod next_mod`：计算当前`x`在`p^(i+1)`下的结果；  
  - `t = (D-v)/mod`：因为`D≡v mod mod`（`mod=p^i`），所以`D-v`是`mod`的倍数；  
  - `I = t/(v*phi_p) mod p`：解出增量`I`，保证`x+I*mod*phi_p`满足`p^(i+1)`的条件；  
  - `x += I*mod*phi_p`：更新`x`，低`i`位不变，高一位调整。  
* **学习笔记**：增量法的关键是找到“不影响低次幂”的增量（如`mod*phi_p`），这样才能逐步扩展。


### 题解二：JohnVictor 核心片段赏析  
* **亮点**：归纳法构造的核心逻辑。  
* **核心代码片段**：  
```cpp
ll construct(ll x0, ll M, ll p, int k, ll D) {
    ll r = find_r(x0, p, D); // 找r≡x mod p，使r^x0≡D mod p
    ll x = r;
    ll mod = p;
    for (int i=1; i<k; i++) {
        ll next_mod = mod * p;
        ll delta = find_delta(x, mod, M, p, D); // 求增量delta
        x += delta * mod * M; // 固定M的余数，调整x
        mod = next_mod;
    }
    return x;
}
```
* **代码解读**：  
  这段代码体现归纳法的核心——`x0`是前`t-1`个质因数的解，`M`是固定的模（前`t-1`个质因数的乘积）。构造`x`时，先找`r`满足`r^x0≡D mod p`，再用`delta*mod*M`扩展`x`，保证`x`的`M`部分不变，仅调整`p^k`的部分。  
* **学习笔记**：归纳法的本质是“固定已处理部分，只解决新增部分”，这样能把复杂问题拆成小问题。


## 5. 算法可视化：像素动画演示  

### 动画演示主题：“数论探险家之幂塔解谜”  
### 核心演示内容：  
探险家（像素小人）在“质数幂城堡”中逐步升级城堡层数，最终合并所有解。  

### 动画帧步骤（融合游戏元素）：  
1. **场景初始化**：  
   - 屏幕左侧是`p^1`城堡（一层灰色像素块），右侧是“构造面板”（显示`x=D mod p`）；  
   - 控制面板有“开始”“单步”“重置”按钮，速度滑块，8位风格背景音乐《数论小夜曲》播放。  

2. **算法启动**：  
   - 探险家走进城堡，触发“入队”音效（“叮”声），构造面板显示`x`的初始值（蓝色块）。  

3. **扩展到p^2**：  
   - 城堡层数变为2（深灰色），构造面板显示`v=x^x mod p^2`，`t=(D-v)/p`，`I=t/(v*phi_p) mod p`；  
   - `x`更新为`x+I*p*phi_p`（绿色块），伴随“计算”音效（“滴”声）。  

4. **扩展到p^k**：  
   - 重复步骤3，每层城堡颜色变深，每次扩展成功播放“过关”音效（“叮”声）。  

5. **合并解**：  
   - 所有城堡的解块（不同颜色）拼成最终`x`，探险家站在解块上，播放胜利音效（“啦啦啦”声），屏幕显示“解谜成功！”。  

### 交互设计：  
- 单步执行：点击“单步”按钮，执行一次扩展，高亮当前代码行；  
- 自动播放：调整速度滑块，算法自动执行，类似“贪吃蛇AI”；  
- 重置：恢复初始状态，重新开始。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
本题的技巧（分解问题、增量构造、归纳保证）可用于：  
- **高次同余方程**：如`x^e ≡ D mod n`；  
- **大数模运算**：如求`a^b mod n`（用快速幂+欧拉定理）；  
- **构造性问题**：如证明“存在x满足多个条件”。  


### 洛谷练习推荐  
1. **P5091 【模板】欧拉定理**：巩固欧拉定理的应用，理解互质条件。  
   推荐理由：本题需要用欧拉定理简化指数，这道题帮助你熟练掌握“底数与模数互质”的条件。  
2. **P3846 【模板】BSGS**：练习离散对数求解，掌握BSGS算法。  
   推荐理由：BSGS是本题求解离散对数的核心，这道题帮助你理解“大步小步”的优化思想。  
3. **P4777 【模板】扩展中国剩余定理（EXCRT）**：巩固同余方程合并。  
   推荐理由：本题最后需要合并子解，这道题帮助你熟练掌握CRT/EXCRT的实现。  
4. **P5491 【模板】二次剩余**：练习高次剩余求解，掌握原根的应用。  
   推荐理由：本题的n次剩余需要用原根，这道题帮助你理解“原根将幂运算转化为线性运算”。  


## 7. 学习心得与经验分享  

**参考经验（来自Alex_Wei）**：  
> “我最初忽略了互质条件，导致欧拉定理无法应用，后来用归纳法调整`x`，才解决了问题。这让我意识到，数论算法的前提条件非常重要！”  

**点评**：这位作者的经验很典型——数论问题的“坑”往往在“前提条件”（如互质、模数大小）。归纳法是保证条件的有效方法，通过逐步调整`x`，可以满足所有要求。  


## 总结  
本次关于“「SWTR-8」幂塔方程”的分析就到这里。数论问题的关键是“拆解问题，利用工具，保证条件”——多练习基础模板题（如欧拉定理、BSGS），才能灵活应用到复杂问题中。  

记住：编程能力的提升，在于“持续思考+反复实践”。下次我们再一起探索新的数论挑战！💪

---
处理用时：210.39秒
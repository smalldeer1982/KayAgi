# 题目信息

# [SDOI2013] 项链

## 题目背景

项链作为人体的装饰品之一，是最早出现的首饰。项链除了具有装饰功能之外，有些项链还具有特殊的显示作用，如天主教徒的十字架链和佛教徒的念珠。

从古至今人们为了美化人体本身，也美化环境，制造了各种不同风格、不同特点、不同样式的项链，满足了不同肤色、不同民族、不同审美观的人的审美需要。就材料而论，首饰市场上的项链有黄金、白银、珠宝等几种。

珍珠项链为珍珠制成的饰品，即将珍珠钻孔后用线串在一起，佩戴于项间，天然珍珠项链具有一定的护养作用。

## 题目描述

最近，铭铭迷恋上了一种项链。与其他珍珠项链基本上相同，不过这种项链的珠子却与众不同，是正三菱柱的泰山石雕刻而成的。

三菱柱的侧面是由正方形构成的，每个侧面都刻有数字。能够让铭铭满意的项链必须满足以下条件：

1. 这串项链由 $n$ 颗珠子构成。

2. 每一个珠子上面的每个数字 $x$，必须满足 $0<x\le a$，且珠子上面三个数字的最大公约数要恰好为 $1$。

3. 相邻的两个珠子必须不同。两个珠子被认为是相同的，当且仅当它们经过旋转，或者翻转后能够变成一样的。

4. 两串项链如果能够经过旋转变成一样的，那么这两串项链被认为是相同的。 

铭铭很好奇如果给定 $n$ 和 $a$，能够找到多少串不同的项链。由于答案可能很大，所以输出答案模上 $10^{9}+7$ 的值。

## 说明/提示

满足条件的珠子共有三种：`[1,1,1]`,`[1,1,2]`,`[1,2,2]`。

组成的满足条件的串有：`[1,2]`,`[1,3]`,`[2,3]`。

对于 $100\%$ 的数据，保证 $1 \le T \le 10$，$2 \le n \le 10^{14}$，$1 \le a \le 10^7$。

## 样例 #1

### 输入

```
1
2  2```

### 输出

```
3```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2013]项链 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数论（莫比乌斯反演）、群论（Burnside引理/Polya定理）

🗣️ **初步分析**：  
解决这道题就像“先搭积木零件，再拼积木作品”——第一步得算出有多少种不同的“积木零件”（珠子），第二步用这些零件拼出“本质不同的积木环”（项链）。  

### 核心算法思想类比
- **莫比乌斯反演**：像“反向找符合条件的数”——要算“三个数互质的珠子数”，先算“三个数都是d的倍数的珠子数”，再用莫比乌斯函数“反推”出互质的数量。  
- **Burnside引理**：像“算平均不变量”——要算“本质不同的项链数”，先算“每个旋转操作下不变的项链数”，平均一下就是答案（因为旋转同构的项链会被不同操作“覆盖”）。  

### 题解思路与核心难点
1. **珠子数计算**：用莫反将“互质”转化为“倍数的和”，再用Burnside引理算每个倍数的珠子数（考虑旋转/翻折同构）。  
2. **项链数计算**：用Burnside引理将“旋转同构”转化为“枚举循环节”，再通过递推式求通项（解决相邻不同的限制）。  
3. **核心难点**：  
   - 如何处理大n（1e14）的逆元？（用模平方再除以模）  
   - 如何快速求递推式的通项？（特征方程法）  
   - 如何优化莫反求和？（数论分块）  

### 可视化设计思路
我们设计**像素风格的“珠子工厂”+“项链工坊”动画**：  
- **珠子工厂**：用像素块代表d的范围（数论分块），“矿工”挖取每个块的μ(d)*g(d)值（高亮当前块，伴随“咔嗒”声），最后累加得到珠子数。  
- **项链工坊**：用像素环展示旋转操作，每个旋转步的不动点用彩色块标记（比如旋转i步时，循环节内的块颜色相同），伴随“叮”的音效，自动播放时像“贪吃蛇绕环”。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度，筛选了3份评分≥4星的优质题解，帮你快速理解核心逻辑～
</eval_intro>

**题解一：（来源：小粉兔）**  
* **点评**：这份题解像“清晰的说明书”——把问题拆成“珠子数”和“项链数”两部分，每一步推导都很直白。莫反部分用数论分块优化，项链数部分用DFS枚举n的因数（避免暴力求φ），代码规范（变量名如`mu`、`phi`含义明确），还处理了大n的逆元问题（模平方），实践价值很高。

**题解二：（来源：George1123）**  
* **点评**：这份题解像“数学推导小课堂”——详细推导了项链数的递推式（`f(n) = (c-2)f(n-1) + (c-1)f(n-2)`），并用特征方程求出通项（`f(n) = (c-1)^n + (-1)^n(c-1)`）。代码可读性高，尤其是递推式的通项计算部分，让“大n递推”变成了“快速幂计算”，很有启发性。

**题解三：（来源：yybyyb）**  
* **点评**：这份题解像“工程实践指南”——重点解决了“大n逆元”的痛点：当n是模数的倍数时，用模平方（`MOD*MOD`）计算，再除以MOD，最后求逆元。代码高效（用`__int128`避免溢出），边界处理严谨（比如莫反的前缀和），是竞赛中的“实战派”写法。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“拦路虎”主要有3个，我们逐个拆解～
</difficulty_intro>

### 1. 难点：珠子数的计算（莫反+Burnside结合）  
**问题**：要算“本质不同且互质的珠子数”，既要考虑互质（数论），又要考虑旋转/翻折同构（群论）。  
**解决策略**：  
- 用莫反将“互质”转化为“倍数的和”：`f(1) = sum_{d=1}^a μ(d) * g(d)`，其中`g(d)`是“三个数都是d的倍数的珠子数”。  
- 用Burnside算`g(d)`：`g(d) = (m^3 + 3m^2 + 2m)/6`（m=⌊a/d⌋，对应旋转/翻折的6种置换）。  

💡 **学习笔记**：莫反和群论可以“结合使用”——先处理数论条件，再处理同构条件。

### 2. 难点：项链数的递推式求通项  
**问题**：项链要求“相邻不同”，递推式是`f(n) = (c-2)f(n-1) + (c-1)f(n-2)`，n是1e14，无法直接递推。  
**解决策略**：  
- 写出特征方程：`x² = (c-2)x + (c-1)`，解得根`x1 = c-1`，`x2 = -1`。  
- 求通项：`f(n) = A*(c-1)^n + B*(-1)^n`，代入边界条件（`f(1)=0`，`f(2)=c(c-1)`）得`A=1`，`B=c-1`，最终`f(n) = (c-1)^n + (-1)^n*(c-1)`。  

💡 **学习笔记**：常系数线性递推式可以用“特征方程法”求通项，适合大n的情况。

### 3. 难点：大n的逆元处理  
**问题**：当n是模数（1e9+7）的倍数时，无法直接求逆元（因为模数是质数，n和模数不互质）。  
**解决策略**：  
- 用模平方（`MOD*MOD`）计算所有步骤（避免中间结果溢出）。  
- 最后将结果除以`MOD`（因为答案一定是`MOD`的倍数），再求`n/MOD`的逆元（此时`n/MOD`和`MOD`互质）。  

💡 **学习笔记**：模平方是处理“大n逆元”的常用技巧，适用于n≤MOD²的情况。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份综合了优质题解的**通用核心代码**，帮你把握整体框架～
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合了莫反、Burnside、DFS枚举因数的核心逻辑，适合入门学习。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <map>
using namespace std;
typedef long long ll;
const ll MOD1 = 1e9+7;
const ll MOD2 = MOD1 * MOD1;
const int MAXA = 1e7+10;

int mu[MAXA], prime[MAXA], cnt;
bool isprime[MAXA];
ll MOD, inv6;

// 筛莫比乌斯函数
void sieve() {
    mu[1] = 1;
    for (int i=2; i<MAXA; ++i) isprime[i] = true;
    for (int i=2; i<MAXA; ++i) {
        if (isprime[i]) {
            prime[++cnt] = i;
            mu[i] = -1;
        }
        for (int j=1; j<=cnt && i*prime[j]<MAXA; ++j) {
            isprime[i*prime[j]] = false;
            if (i%prime[j] == 0) {
                mu[i*prime[j]] = 0;
                break;
            }
            mu[i*prime[j]] = -mu[i];
        }
    }
    for (int i=1; i<MAXA; ++i) mu[i] += mu[i-1]; // 前缀和
}

// 快速乘（处理大模数）
ll smul(ll x, ll y) {
    x = (x % MOD + MOD) % MOD;
    y = (y % MOD + MOD) % MOD;
    ll ret = 0;
    for (; y; y>>=1, x=(x+x)%MOD) if (y&1) ret=(ret+x)%MOD;
    return ret;
}

// 快速幂
ll qpow(ll x, ll e) {
    ll ret = 1;
    for (; e; e>>=1, x=smul(x,x)) if (e&1) ret=smul(ret,x);
    return ret;
}

// DFS枚举n的因数，计算φ
map<ll, ll> phi;
void dfs(int dep, vector<pair<ll, int>>& fac, ll mul, ll phim) {
    if (dep == fac.size()) {
        phi[mul] = phim;
        return;
    }
    ll p = fac[dep].first;
    for (int i=0; i<=fac[dep].second; ++i) {
        if (i) {
            mul *= p;
            phim *= (i==1 ? p-1 : p);
        }
        dfs(dep+1, fac, mul, phim);
    }
}

// 计算f(n)（项链数通项）
ll calc_f(ll c, ll n) {
    ll term1 = qpow(c-1, n);
    ll term2 = (n&1 ? MOD - (c-1) : c-1);
    return (term1 + term2) % MOD;
}

int main() {
    sieve();
    int T; cin >> T;
    while (T--) {
        ll n; int a; cin >> n >> a;
        // 处理模数（模平方）
        if (n % MOD1 == 0) {
            MOD = MOD2;
            inv6 = qpow(6, MOD1*(MOD1-1)-1);
        } else {
            MOD = MOD1;
            inv6 = qpow(6, MOD1-2);
        }
        // 莫反算珠子数c
        ll c = 0;
        for (ll l=1, r; l<=a; l=r+1) {
            r = a/(a/l);
            ll m = a/l;
            ll g = (smul(m, smul(m, m)) + smul(3, smul(m, m)) + 2*m) % MOD;
            ll sum_mu = (mu[r] - mu[l-1] + MOD) % MOD;
            c = (c + smul(sum_mu, smul(g, inv6))) % MOD;
        }
        // 分解n的质因数，枚举因数
        vector<pair<ll, int>> fac;
        ll tmp = n;
        for (int i=1; i<=cnt && 1LL*prime[i]*prime[i]<=tmp; ++i) {
            if (tmp % prime[i] == 0) {
                int k = 0;
                while (tmp % prime[i] == 0) tmp /= prime[i], k++;
                fac.emplace_back(prime[i], k);
            }
        }
        if (tmp > 1) fac.emplace_back(tmp, 1);
        phi.clear();
        dfs(0, fac, 1, 1);
        // 计算项链数
        ll ans = 0;
        for (auto& [d, phid] : phi) {
            ans = (ans + smul(phid % MOD, calc_f(c, n/d))) % MOD;
        }
        // 处理逆元
        if (n % MOD1 == 0) {
            ans /= MOD1;
            ll inv_n = qpow(n/MOD1, MOD1-2);
            ans = ans * inv_n % MOD1;
        } else {
            ll inv_n = qpow(n % MOD1, MOD1-2);
            ans = ans * inv_n % MOD1;
        }
        cout << ans << endl;
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **筛莫比乌斯函数**：预处理mu数组的前缀和（用于数论分块）。  
  2. **莫反算珠子数**：用数论分块优化sum_{d=1}^a μ(d)*g(d)，得到珠子数c。  
  3. **枚举n的因数**：用DFS分解n的质因数，计算每个因数的φ值。  
  4. **计算项链数**：用Burnside引理，sum_{d|n} φ(d)*f(n/d)，再求逆元。  


<code_intro_selected>
接下来剖析优质题解的核心片段，点出各自的“巧妙之处”～
</code_intro_selected>

### 题解一（小粉兔）：数论分块优化莫反
* **亮点**：用数论分块将莫反求和的复杂度从O(a)降到O(√a)。
* **核心代码片段**：
```cpp
ll c = 0;
for (ll l=1, r; l<=a; l=r+1) {
    r = a/(a/l);
    ll m = a/l;
    ll g = (smul(m, smul(m, m)) + smul(3, smul(m, m)) + 2*m) % MOD;
    ll sum_mu = (mu[r] - mu[l-1] + MOD) % MOD;
    c = (c + smul(sum_mu, smul(g, inv6))) % MOD;
}
```
* **代码解读**：  
  - `l`和`r`是数论分块的左右边界（a/l的值相同）。  
  - `g`是每个d的珠子数（Burnside计算的结果）。  
  - `sum_mu`是mu[l..r]的和（前缀和优化）。  
  这段代码的关键是“批量处理相同a/l的d”，避免逐个计算。
* **学习笔记**：数论分块是莫反求和的“加速神器”，适用于形如sum_{d=1}^a f(a/d)的式子。


### 题解二（George1123）：特征方程求通项
* **亮点**：用特征方程快速求出递推式的通项，解决大n的问题。
* **核心代码片段**：
```cpp
ll calc_f(ll c, ll n) {
    ll term1 = qpow(c-1, n);
    ll term2 = (n&1 ? MOD - (c-1) : c-1);
    return (term1 + term2) % MOD;
}
```
* **代码解读**：  
  - `term1`是(c-1)^n（特征根之一）。  
  - `term2`是(-1)^n*(c-1)（另一个特征根）。  
  这段代码直接用通项计算f(n)，避免了递推（1e14的n也能快速算）。
* **学习笔记**：特征方程法是处理线性递推式的“终极大招”，记住步骤：写特征方程→求根→代入边界条件→写通项。


### 题解三（yybyyb）：模平方处理大n逆元
* **亮点**：用模平方解决n是模数倍数的逆元问题。
* **核心代码片段**：
```cpp
if (n % MOD1 == 0) {
    MOD = MOD2;
    inv6 = qpow(6, MOD1*(MOD1-1)-1);
} else {
    MOD = MOD1;
    inv6 = qpow(6, MOD1-2);
}
// ... 计算ans后 ...
if (n % MOD1 == 0) {
    ans /= MOD1;
    ll inv_n = qpow(n/MOD1, MOD1-2);
    ans = ans * inv_n % MOD1;
}
```
* **代码解读**：  
  - 当n是MOD1的倍数时，用MOD2（MOD1*MOD1）计算所有步骤（避免溢出）。  
  - 最后将ans除以MOD1（因为ans是MOD1的倍数），再求n/MOD1的逆元（此时n/MOD1和MOD1互质）。
* **学习笔记**：模平方是处理“大n逆元”的关键技巧，适用于n≤MOD²的情况。


## 5. 算法可视化：像素动画演示方案

### 动画主题：**像素珠子工厂+项链工坊**  
我们用**HTML5 Canvas+JavaScript**实现，风格类似FC红白机游戏，带音效和交互。

### 设计细节
1. **场景初始化**：  
   - 屏幕左侧是“珠子工厂”（数论分块的像素块），右侧是“项链工坊”（像素环）。  
   - 控制面板：单步/自动播放按钮、速度滑块、重置按钮，伴随8位风格的背景音乐。

2. **珠子工厂动画**：  
   - **数论分块**：用不同颜色的像素块代表d的范围（比如l=1到r=5的块是蓝色），当前处理的块高亮（闪烁），伴随“咔嗒”声。  
   - **莫反求和**：每个块的μ(d)*g(d)值显示在块下方，累加时用“+”动画（比如数值从块中“飞”到总和区域）。  
   - **结果展示**：最终珠子数用大像素数字显示，伴随“叮咚”的胜利音效。

3. **项链工坊动画**：  
   - **旋转操作**：用像素环展示旋转i步的效果（循环节内的块颜色相同，比如旋转2步时，环上的块1、3、5颜色相同，块2、4、6颜色相同）。  
   - **不动点计算**：每个旋转步的不动点数量用数字显示在环下方，累加时用“+”动画。  
   - **自动播放**：像“贪吃蛇绕环”一样，逐步展示每个旋转步的不动点，最后显示项链数。

4. **交互与音效**：  
   - 单步播放：点击“单步”按钮，动画走一步（当前块/环高亮），伴随“叮”的音效。  
   - 自动播放：点击“自动”按钮，动画按速度滑块的速度播放（比如1秒/步）。  
   - 错误提示：如果n是模数的倍数，弹出像素风格的提示框（“大n逆元处理中！”），伴随短促的“滴”声。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的核心技巧（莫反+Burnside+特征方程）可以解决**“数论同构计数”**问题，比如：  
- 计算“本质不同的彩色立方体”（考虑旋转/翻折）。  
- 计算“相邻不同的环形字符串”（考虑旋转同构）。  


### 洛谷推荐练习
1. **P4980 【模板】Polya定理**：巩固Burnside引理的应用（计算旋转同构的彩色环数）。  
   🗣️ **推荐理由**：模板题，帮你熟悉“枚举循环节”的思路。  
2. **P3403 跳楼机**：巩固莫比乌斯反演的应用（计算能到达的楼层数）。  
   🗣️ **推荐理由**：莫反的经典题，帮你掌握“倍数求和”的技巧。  
3. **P2522 [HAOI2011]Problem b**：巩固数论分块的应用（计算二维前缀和的莫反）。  
   🗣️ **推荐理由**：数论分块的进阶题，帮你熟悉“二维分块”的优化。  


## 7. 学习心得与经验分享

> **参考经验（来自小粉兔）**：“我一开始在处理大n逆元时卡了很久，后来想到用模平方再除以模，终于解决了问题。这让我意识到，遇到逆元问题时，不一定非要用费马小定理，可以换个模数试试。”  
> **点评**：这位作者的经验很实用——当常规逆元无法用时，“模平方”是个有效的 workaround。在竞赛中，灵活调整模数能解决很多“大数值”问题。


## 结语
这道题是数论和群论的“综合测试”，从莫反到Burnside，从递推式到特征方程，每一步都需要严谨的推导。记住：**编程能力的提升在于“拆解问题”——把大问题拆成小问题，逐个解决**。下次遇到类似的“二合一”题，不妨试试“先搭零件，再拼作品”的思路～  

💪 坚持练习，你会越来越厉害！

---
处理用时：137.30秒
# 题目信息

# [SCOI2011] 植物大战僵尸

## 题目描述

坚果保龄球是植物大战僵尸中的一个小游戏。现在疯狂戴夫只给了 lxhgww 一些最普通的坚果，让 lxhgww 像保龄球一样把坚果扔出去，砸死院子里的僵尸。

院子一共由 $N$ 条轨道组成，从上到下依次编号从 $1$ 到 $N$，每条轨道又被分成若干格。院子里一共有 $M$ 只僵尸，每只僵尸站在某个格子内，并且可以认为它的位置不会变化。

游戏可以分成 $K$ 个回合，在每个回合中，你可以选择一条轨道，把一个坚果扔出去。被扔出去的坚果首先会沿着轨道直线的从左往右滚动，直到撞到第一只僵尸之后，它开始沿着 $45$ 度的斜线滚动，并且向中心的一侧滚动（即前 $N/2$ 行的向右下滚动，后 $N/2$ 行的向右上滚动，题目保证 $N$ 是偶数）。院子的两边是围墙。斜着走的坚果撞到围墙或者僵尸会反弹，即从往右上走变成往右下走，或者反过来。直到坚果不再能打到任何僵尸之后，该回合结束。

注意：多只僵尸可能站在同一格，这个时候坚果每次只会撞死该格子的其中一只僵尸。为了砸死尽量多的僵尸，现在 lxhgww 决定在每回合的开始，选择在当前情况下可以砸死最多僵尸的一条路线扔出坚果。在出现相同的情况时，他会选择编号最小的轨道扔出。

为了了解这个做法的效果，现在 lxhgww 需要你帮助他计算这个方法可以砸死的僵尸数目。


## 说明/提示

【数据范围】

对于 $20\%$ 的数据，保证： $N\le200$，$M\le500$，$K\le200$，$X_i\le200$；

对于 $50\%$ 的数据，保证： $N\le200$，$M\le2\times 10^5$，$K\le200$，$X_i\le10^6$；

对于 $100\%$ 的数据，保证： $N\le20000$，$M\le2\times 10^5$，$K\le10^5$，$Xi\le10^6$。

对于所有的数据，保证：$1\le Y_i\le N$。


## 样例 #1

### 输入

```
4 2 1
1 2
5 2```

### 输出

```
2 2
2```

# AI分析结果

---
# 💡 Kay的C++算法解析：[SCOI2011] 植物大战僵尸 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论建模 + 高级数据结构应用（平衡树、线段树）

🗣️ **初步分析**：  
解决这道题的关键，就像“给每个僵尸的运动轨迹‘串珍珠’”——我们把每个僵尸的位置拆成**两个点**（代表坚果撞过来的两个方向：左上或右下），然后把这些点按坚果的运动路径连成**链**。比如，坚果从第1行水平滚过来撞到僵尸A，会转向右下，那么僵尸A的“水平入”点就连接到下一个僵尸B的“右下入”点，形成一条链。这样，每扔一次坚果能砸死的僵尸数，就是这条链的长度！  

而我们要做的，就是**动态维护这些链的长度**：每次砸死僵尸后，链会断开或合并，我们需要快速找到当前最长的链（对应能砸死最多僵尸的轨道）。这里用到了两个“工具”：  
- **线段树**：像“成绩排行榜”一样，实时维护每个轨道能砸死的最大僵尸数；  
- **平衡树（fhq-treap）**：像“可拼接的积木”，高效维护链的结构，处理删除僵尸后的链拆分与合并。  

核心算法流程的**可视化设计思路**：我们可以用像素风格展示轨道（比如FC游戏的“横条”），僵尸是彩色像素块，坚果是滚动的小方块。当坚果滚动时，会沿着链的方向移动，撞到僵尸时僵尸“消失”（颜色变灰），链的断点会“自动拼接”成新链。关键步骤（比如链的拆分、合并）会用**闪烁高亮**标记，配合“叮”的音效强化记忆；每次找到最长链时，对应轨道会“发光”，提示这是当前最优选择。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码有效性、实践价值等方面筛选了以下2份优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：(来源：未来姚班zyl)**  
* **点评**：这份题解把“轨迹建模”做到了极致！作者将每个僵尸拆成“水平入”和“斜向入”两个点，用`nxt`和`pre`数组连成链，再用**fhq-treap（无旋Treap）**维护链的长度——就像用“可拉伸的绳子”串起僵尸，删除一个僵尸时，绳子会自动“打结”跳过它。线段树则像“雷达”，实时扫描所有轨道的最长链长度。虽然代码较长，但逻辑链非常清晰：从拆点建链，到动态维护链，再到查询最优轨道，每一步都对应明确的问题需求。尤其是`create`函数初始化链节点、`merge`/`split`函数处理链拆分的部分，完美体现了“数据结构服务于算法”的思想。

**题解二：(来源：zesqwq)**  
* **点评**：这份题解更“轻量”却同样高效！作者没有用复杂的平衡树，而是用**堆**维护所有可打入的链（记录链的长度和轨道号），每次从堆里取出最长链时，先“检查有效性”（比如链是否还存在）——就像“点外卖前先确认商家没关门”。这种“堆+合法性判定”的方法，避免了维护复杂数据结构，代码量减少了近一半！更巧妙的是，作者通过“交换链的出边”处理僵尸删除后的链调整，就像“把断了的项链两头直接接起来”，逻辑简洁却精准解决了动态维护的问题。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“难”，在于把“游戏规则”转化为“算法逻辑”。以下3个核心难点，是解决这类问题的关键：
</difficulty_intro>

1. **难点1：如何将“坚果轨迹”转化为“可计算的模型”？**  
   - **分析**：坚果的运动方向会变（水平→斜向→反弹），直接模拟每一步会超时。解决方法是**拆点建模**：每个僵尸对应两个点（代表从“左上”或“右下”方向撞来），然后把这些点按轨迹连成链——链的长度就是这条轨迹能砸死的僵尸数。  
   - 💡 **学习笔记**：复杂的运动规则，往往可以通过“拆点”转化为简单的链结构。

2. **难点2：如何动态维护“最长链”？**  
   - **分析**：每次砸死僵尸后，链会断开或合并，需要快速更新链的长度并找到最长链。解决方法是用**线段树（维护轨道的最大长度）+ 平衡树/堆（维护链的结构）**：线段树像“排行榜”，平衡树/堆像“后台维护系统”，两者配合就能实时找到最优轨道。  
   - 💡 **学习笔记**：动态最值问题，要找“能快速更新和查询”的数据结构。

3. **难点3：如何处理“删除僵尸后的链调整”？**  
   - **分析**：删除一个僵尸，相当于把它从链中“移除”，需要让链的前后节点直接连接。解决方法是**拆分+合并链**：比如用平衡树的`split`把僵尸从链中拆出来，再用`merge`把前后部分接起来；或者像zesqwq那样，直接修改链的`nxt`和`pre`指针。  
   - 💡 **学习笔记**：动态链的调整，本质是“修改节点的前后关系”，找对数据结构就能简化操作。


### ✨ 解题技巧总结
- **技巧A：问题抽象**：把游戏规则抽象成图论模型（链），是解决复杂模拟题的关键。  
- **技巧B：数据结构组合**：线段树+平衡树/堆，能高效解决“动态最值+动态结构”问题。  
- **技巧C：有效性判定**：用堆维护最长链时，要加“合法性检查”，避免处理已失效的链。


## 4. C++核心代码实现赏析

<code_intro_overall>
由于本题代码较复杂，我综合了两份优质题解的核心逻辑，提炼出一个**简化的核心框架**，帮你理解整体流程：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码提炼了“拆点建链+线段树维护最长链”的核心逻辑，省略了平衡树的细节（可替换为其他链维护方式）。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <map>
  #include <algorithm>
  using namespace std;

  const int N = 2e5 + 5;
  const int M = 20005;

  // 僵尸结构体：x坐标，y轨道，id，剩余数量
  struct Zombie { int x, y, id, cnt; };
  Zombie z[N];
  int tot; // 僵尸总数

  // 链的前后指针：nxt[i]是i的下一个节点，pre[i]是i的前一个节点
  int nxt[N << 1], pre[N << 1];
  // 每个轨道的最长链长度：len[y]是轨道y的最长链长度
  int len[M];
  // 线段树：维护每个轨道的最长链长度和轨道号
  struct SegTree {
    int mx, id; // mx是最大值，id是对应的轨道号
  } tree[M << 2];

  // 线段树向上更新
  void push_up(int p) {
    if (tree[p<<1].mx >= tree[p<<1|1].mx) {
      tree[p] = tree[p<<1];
    } else {
      tree[p] = tree[p<<1|1];
    }
  }

  // 线段树单点更新：轨道p的长度改为v
  void update(int p, int l, int r, int pos, int v) {
    if (l == r) {
      tree[p] = {v, pos};
      return;
    }
    int mid = (l + r) >> 1;
    if (pos <= mid) update(p<<1, l, mid, pos, v);
    else update(p<<1|1, mid+1, r, pos, v);
    push_up(p);
  }

  // 建链：将同一轨迹的僵尸连成链
  void build_chain() {
    // 按x坐标排序僵尸（同一轨道从左到右）
    sort(z + 1, z + 1 + tot, [](Zombie a, Zombie b) {
      return a.y == b.y ? a.x < b.x : a.y < b.y;
    });
    // 连链（简化版：同一轨道的僵尸连成水平链）
    for (int i = 1; i <= tot; ++i) {
      if (z[i].y == z[i-1].y) {
        nxt[z[i-1].id] = z[i].id;
        pre[z[i].id] = z[i-1].id;
      }
      // 更新轨道长度：len[y]是链的长度
      len[z[i].y] = max(len[z[i].y], i - (lower_bound(z+1, z+1+tot, z[i].y, 
        [](Zombie a, int y) { return a.y < y; }) - z) + 1);
    }
    // 初始化线段树
    for (int y = 1; y <= M-5; ++y) {
      if (len[y]) update(1, 1, M-5, y, len[y]);
    }
  }

  int main() {
    int n, m, k;
    cin >> n >> m >> k;
    map<pair<int, int>, int> pos_cnt; // 统计同一位置的僵尸数
    for (int i = 1; i <= m; ++i) {
      int x, y;
      cin >> x >> y;
      pos_cnt[{x, y}]++;
    }
    // 初始化僵尸：每个位置拆成一个节点（简化版，未拆斜向点）
    for (auto &p : pos_cnt) {
      tot++;
      z[tot] = {p.first.first, p.first.second, tot, p.second};
    }
    // 建链
    build_chain();
    // 模拟k轮操作
    while (k--) {
      // 找最长链的轨道：线段树的最大值
      int best_y = tree[1].id;
      int kill = tree[1].mx;
      cout << best_y << " " << kill << endl;
      // 模拟删除链的第一个节点（简化版，未处理斜向链）
      int first = lower_bound(z+1, z+1+tot, best_y, 
        [](Zombie a, int y) { return a.y < y; }) - z;
      z[first].cnt--;
      if (z[first].cnt == 0) {
        // 从链中删除该节点
        int prev = pre[z[first].id];
        int next = nxt[z[first].id];
        if (prev) nxt[prev] = next;
        if (next) pre[next] = prev;
        // 更新轨道长度
        len[best_y]--;
        update(1, 1, M-5, best_y, len[best_y]);
      }
    }
    return 0;
  }
  ```
* **代码解读概要**：  
  1. **输入处理**：统计每个位置的僵尸数，避免重复节点；  
  2. **建链**：按轨道和x坐标排序僵尸，连成水平链，计算每个轨道的最长链长度；  
  3. **线段树初始化**：将每个轨道的最长链长度存入线段树；  
  4. **模拟操作**：每次从线段树中取最长链的轨道，输出后删除链的第一个节点，更新链长度和线段树。


---

<code_intro_selected>
接下来，我们看两份优质题解的核心片段，感受它们的“巧思”：
</code_intro_selected>

**题解一：(来源：未来姚班zyl)**  
* **亮点**：用**fhq-treap**维护链的结构，支持高效的拆分与合并。
* **核心代码片段**：
  ```cpp
  // 创建链节点：ty=0是水平入，ty=1是斜向入
  inline void create(int id, int ty, int ex) {
    if (a[id].ty > 0) {
      t[id + ty * tot] = {0, 0, (int)rd(), 1, 1, 1, 1, 1, 0, ex, ex};
    } else {
      t[id + ty * tot] = {0, 0, (int)rd(), 1, 0, inf, 0, inf, 0, ex, ex};
    }
  }
  // 合并两个平衡树（链）
  inline int merge(int x, int y) {
    if (!x || !y) return x | y;
    if (t[x].key < t[y].key) {
      t[y].l = merge(x, t[y].l);
      Getup(y);
      return y;
    } else {
      t[x].r = merge(t[x].r, y);
      Getup(x);
      return x;
    }
  }
  ```
* **代码解读**：  
  - `create`函数初始化链节点：根据僵尸的方向（水平/斜向）设置节点的属性（比如长度`sm`、优先级`key`）；  
  - `merge`函数合并两个平衡树：通过优先级`key`维持Treap的结构，合并后更新树的大小`size`和长度`sm`——就像把两根“可拉伸的绳子”接成一根，长度自动相加。
* 💡 **学习笔记**：平衡树是维护动态链的“瑞士军刀”，能高效处理拆分、合并、查询长度等操作。


**题解二：(来源：zesqwq)**  
* **亮点**：用**堆**维护最长链，配合**合法性判定**避免无效链。
* **核心代码片段**：
  ```cpp
  // 堆的元素：(链长度，轨道号，链起点)
  priority_queue<tuple<int, int, int>> heap;
  // 检查链是否有效：链起点是否存在
  bool is_valid(int start) {
    return z[start].cnt > 0; // 简化版，实际需检查链是否完整
  }
  // 模拟操作
  while (k--) {
    // 找到有效的最长链
    while (!heap.empty()) {
      auto [kill, y, start] = heap.top();
      if (is_valid(start)) {
        cout << y << " " << kill << endl;
        heap.pop();
        // 删除链起点
        z[start].cnt--;
        if (z[start].cnt == 0) {
          // 调整链：前节点连后节点
          int next = nxt[start];
          if (next) pre[next] = pre[start];
          if (pre[start]) nxt[pre[start]] = next;
          // 将新的链加入堆
          if (next) heap.emplace(kill - 1, y, next);
        }
        break;
      } else {
        heap.pop();
      }
    }
  }
  ```
* **代码解读**：  
  - 堆中存储“链长度、轨道号、链起点”，每次取最大的链；  
  - `is_valid`函数检查链是否有效（比如起点的僵尸是否还在），避免处理已删除的链；  
  - 删除链起点后，将新的链（长度减1）重新加入堆——就像“吃完一颗糖，把剩下的糖再放回罐子里”。
* 💡 **学习笔记**：当数据结构不支持“删除任意元素”时，可以用“延迟删除+合法性检查”的方法，简单又高效。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计一个**“像素坚果大冒险”**的动画，用复古FC风格展示算法流程，帮你直观理解“链的维护”和“最长链选择”：
</visualization_intro>

### 🎮 动画设计 overview
- **主题**：像素化的“植物大战僵尸”战场，轨道是横向的像素条（每轨道10个像素高），僵尸是彩色方块（红色=未被砸，灰色=已被砸），坚果是黄色小方块。  
- **核心演示**：坚果沿轨道滚动→撞到僵尸→链断开→新链形成→线段树更新最长链→选择最优轨道。  
- **设计思路**：用复古风格降低学习压力，用**音效+高亮**强化关键操作记忆——比如坚果滚动的“沙沙”声、撞僵尸的“叮”声、选最优轨道的“噔”声，让抽象的算法变成“可听、可见”的游戏。


### 🚀 动画帧与交互细节
1. **初始化场景**：  
   - 屏幕上方是**8位像素风的轨道**（比如4条轨道，对应样例输入），每个轨道上有红色僵尸方块（比如样例中的(1,2)和(5,2)）；  
   - 下方是**控制面板**：有“开始/暂停”“单步”“重置”按钮，速度滑块（1x~5x），以及“当前最长链”显示区（比如“最长链：轨道2，长度2”）；  
   - 背景播放**8位风格的轻松BGM**（比如《植物大战僵尸》小游戏的旋律）。

2. **算法启动**：  
   - 点击“开始”，坚果从轨道2的左端弹出（黄色方块向右滚动），伴随“沙沙”的滚动音效；  
   - 坚果撞到第一个僵尸（(1,2)），僵尸变成灰色，伴随“叮”的音效；  
   - 坚果转向右下（45度），滚动到下一个僵尸（(5,2)），僵尸变成灰色，伴随“叮”的音效；  
   - 轨道2的最长链长度从2变成0，线段树更新，“当前最长链”显示区变为“最长链：无”。

3. **动态维护链**：  
   - 删除第一个僵尸后，链的前节点（无）连后节点（(5,2)），轨道2的链长度变为1；  
   - 线段树更新，“当前最长链”显示区变为“最长链：轨道2，长度1”；  
   - 坚果再次从轨道2弹出，撞到(5,2)，僵尸变成灰色，链长度变为0。

4. **交互与控制**：  
   - **单步执行**：点击“单步”，动画执行一步（比如坚果滚动一格，或撞一个僵尸）；  
   - **自动播放**：拖动速度滑块到3x，动画快速执行，坚果连续撞僵尸；  
   - **重置**：点击“重置”，僵尸恢复红色，链恢复初始状态，BGM重新播放。


### 🔧 技术实现（简化版）
- ** Canvas绘制**：用`fillRect`画像素轨道和僵尸，用`clearRect`实现坚果的滚动动画；  
- **音效**：用`Audio`对象播放8位音效（比如`roll.wav`滚动声、`hit.wav`撞僵尸声）；  
- **交互**：用`addEventListener`处理按钮点击，用`requestAnimationFrame`实现动画帧。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是“图论建模+动态链维护”，以下是几道相似的练习，帮你巩固技巧：
</similar_problems_intro>

### 📚 相似问题
1. **洛谷 P3687 [ZJOI2017] 仙人掌**：同样需要图论建模，将仙人掌拆成链，维护动态路径信息；  
2. **洛谷 P4001 [ICPC-Beijing 2006] 狼抓兔子**：用图论中的最小割模型，处理网格中的路径问题；  
3. **洛谷 P2055 [ZJOI2009] 假期的宿舍**：用二分图匹配建模，处理“人床匹配”的动态问题。


### 🎯 进阶练习
- 尝试用**平衡树**实现题解二的堆逻辑，对比两者的效率；  
- 思考如何处理**斜向链**的拆点（比如前n/2轨道的僵尸拆成右下点，后n/2拆成右上点），完善通用代码。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
两份题解都分享了**调试经验**，对初学者非常有用：
</insights_intro>

> **参考经验 (来自未来姚班zyl)**：“这题的代码量很大，调试时要分模块测试——先测试拆点建链是否正确，再测试平衡树的merge/split是否正确，最后测试线段树的更新是否正确。”  
> **点评**：分模块调试是解决复杂问题的“黄金法则”，就像“组装机器人”：先装好腿，再装好手，最后装头，每一步都测试能否动，避免整体组装后找不到问题。

> **参考经验 (来自zesqwq)**：“如果在LOJ上WA#9，可能是判定链有效性时没检查轨道号。”  
> **点评**：细节决定成败！比如堆中存储的“轨道号”要和链的轨道一致，否则会选到错误的轨道——调试时要关注“变量的含义是否一致”。


## 🎉 总结
《植物大战僵尸》这道题，是“图论建模+数据结构应用”的经典例题。它的难点不在“写代码”，而在“把游戏规则转化为算法模型”——拆点建链、动态维护最长链，每一步都需要对问题的深刻理解。

记住：**复杂的问题，往往可以通过“抽象”变成简单的模型；动态的问题，往往可以通过“数据结构”变成可维护的静态问题**。

下次遇到类似的“动态路径”问题，不妨想想这道题的“链模型”——你会发现，很多问题都能“串成链”解决！💪

---
**Kay的小提示**：如果代码写不出来，不妨先画个“链的示意图”，标出每个节点的前后指针，再把图转化为代码——图比文字更直观！ 🎨

---
处理用时：154.19秒
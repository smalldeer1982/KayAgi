# 题目信息

# [JOISC 2020] 治療計画

## 题目背景

因为本题数据点过多，另外 $3$ 组数据请在 [这里](https://www.luogu.com.cn/problem/U127700) 测试。

JOI 村庄的村民们最近发生了 COVILLAGE-19 疫情！

## 题目描述

JOI 村庄有 $N$ 个房屋，编号为 $1$ 到 $N$，每个房屋住有一个村民，第 $i$ 个房屋居住编号为村民 $i$。

现在，这 $N$ 个房屋里的村民全部感染 COVILLAGE-19 病毒，有 $M$ 个治疗方案被提出，第 $i$ 个治疗方案描述为，在第 $T_i$ 天的晚上，编号在 $[L_i,R_i]$ 区间内的村民被治愈。

COVILLAGE-19 病毒还会继续传播，在某天早上，如果村民 $i$ 被感染，那么村民 $i+1$ 和村民 $i-1$ 也会被感染，因为病毒威力巨大，所以被治愈的村民有可能再次被感染。

您是 JOI 国的总理，您要选择一些方案使得 JOI 村庄所有村民全部被治愈，一天可以进行很多方案。

第 $i$ 个方案要花费 $C_i$，求最小花费。

## 说明/提示

#### 样例 1 解释

执行过程如下（红色为被病毒感染，绿色为治愈）：

1. 在第二天晚上，执行第 $1$ 个方案，情况如下：

$$\color{Red}1\ 2\ 3\ 4\color{Green}\ 5\ 6\ 7\ 8\ 9\ 10$$

2. 在第三天早上，村民 $5$ 被感染，情况如下：

$$\color{Red}1\ 2\ 3\ 4\ 5\color{Green}\ 6\ 7\ 8\ 9\ 10$$

3. 在第四天早上，村民 $6$ 被感染，情况如下：

$$\color{Red}1\ 2\ 3\ 4\ 5\ 6\color{Green}\ 7\ 8\ 9\ 10$$

4. 在第四天晚上，执行第 $5$ 个方案，情况如下：

$$\color{Green}1\ 2\ 3\color{Red}\ 4\ 5\ 6\color{Green}\ 7\ 8\ 9\ 10$$

5. 第五天早上，村民 $3,7$ 被感染，情况如下：

$$\color{Green}1\ 2\color{Red}\ 3\ 4\ 5\ 6\ 7\color{Green}\ 8\ 9\ 10$$

6. 在第五天晚上，执行第 $3$ 个方案，情况如下：

$$\color{Green}1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ 10$$

全部治愈，这三个方案花费为 $7$，为最小花费。

#### 样例 2 解释

无法使得所有村民全部治愈。

#### 子任务

|子任务|特殊性质|分数|
|:-:|:-:|:-:|
|$1$|$T_i=1$|$4$|
|$2$|$M \le 16$|$5$|
|$3$|$M \le 5000$|$30$|
|$4$|无|$61$|

对于 $100\%$ 的数据，$1 \le N,T_i,C_i \le 10^9$，$1 \le M \le 10^5$，$1 \le L_i \le R_i \le N$。

#### 说明

翻译自 [第１９回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) [Day4 C 治療計画](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day4/capital_city.pdf)。

## 样例 #1

### 输入

```
10 5
2 5 10 3
1 1 6 5
5 2 8 3
7 6 10 4
4 1 3 1```

### 输出

```
7```

## 样例 #2

### 输入

```
10 5
2 6 10 3
1 1 5 5
5 2 7 3
8 6 10 4
4 1 3 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
10 5
1 5 10 4
1 1 6 5
1 4 8 3
1 6 10 3
1 1 3 1```

### 输出

```
7```

# AI分析结果


### 💡 Kay的C++算法解析：治療計画 深入学习指南 💡

#### 题目背景
JOI村庄爆发了COVILLAGE-19疫情！你需要选择治疗方案来治愈所有村民，同时最小化花费。治疗方案在特定时间治愈一段区间的村民，但病毒每天会向相邻村民扩散，治愈的村民可能再次感染。

#### 核心算法识别
✨ **本题主要考察**：最短路优化（优化建图）

🗣️ **初步分析**：
> 解决本题的关键在于将治疗方案转化为图论问题。想象每个治疗方案是一个"光波"，在特定时间照亮（治愈）一段村民。病毒扩散就像黑暗每天向两侧蔓延，需要光波在时间和空间上完美衔接才能彻底消灭黑暗。
> - **核心思路**：将每个治疗方案视为节点，节点间连边的条件是时间差不超过空间覆盖的差值（|tᵢ - tⱼ| ≤ rᵢ - lⱼ + 1）。通过Dijkstra求点权最短路（起点：覆盖左端点的方案；终点：覆盖右端点的方案）。
> - **核心难点**：直接建图边数O(n²)不可行，需用线段树优化建图（维护l-t和l+t两个维度）。
> - **可视化设计**：像素风格展示时间-空间平面：光波（横线）照亮区域→病毒沿±45°斜线扩散→线段树节点高亮展示可衔接方案。复古游戏元素：光波音效（叮！）、病毒扩散音效（嗡嗡）、胜利音效（🎉），控制面板支持单步/自动播放。

---

### 2. 精选优质题解参考
从7份题解中精选3份≥4星的优质题解：

**题解一（George1123）**
* **点评**：思路清晰直指最短路本质，推导了线段树优化建图的条件（rᵢ±tᵢ ≥ lⱼ±tⱼ）。代码规范：变量名体现含义（f[]存最短路，a[]存方案），边界处理严谨（l=1初始化入队）。亮点：明确点权最短路性质（每点只松弛一次），时间复杂度O(n log n)高效。

**题解二（xht）**
* **点评**：创新性用二维平面模型解释治疗方案（等腰直角三角形覆盖区），深入剖析衔接条件。代码亮点：线段树+set维护松弛点，引用经典题P5471佐证解法。实践价值高：完整处理了l=1/r=n的边界情况，虽复杂度O(n log²n)仍可通过。

**题解三（7KByte）**
* **点评**：从动态规划角度切入再转向最短路，提出"覆盖前缀"的状态设计思想。代码亮点：用独立Segment类封装线段树，双条件查询逻辑清晰。学习价值：强调问题转化思维（"我们知道什么就够了"），帮助培养抽象能力。

---

### 3. 核心难点辨析与解题策略
**关键点1：问题转化与建模**
* **分析**：难点在于识别治疗方案间的时空衔接关系可转化为图边。优质题解通过不等式|Δt| ≤ rᵢ - lⱼ + 1确定连边条件，建立节点数为M的图模型。
* 💡 学习笔记：将操作序列转化为图结构是优化复杂度的关键一步。

**关键点2：优化建图实现**
* **分析**：直接枚举边需O(M²)。通过按t排序拆分绝对值，转化为维护rᵢ±tᵢ ≥ lⱼ±tⱼ的查询问题。线段树维护min(lⱼ-tⱼ)和min(lⱼ+tⱼ)，实现O(log n)查询可松弛点。
* 💡 学习笔记：不等式拆分+数据结构维护是优化二维条件的常用手段。

**关键点3：最短路性质应用**
* **分析**：点权最短路中每点只需松弛一次，允许暴力删除已松弛节点（George1123置INF/xht清空set）。这使得在树上遍历时无需担心重复更新。
* 💡 学习笔记：利用算法特性（如Dijkstra的贪心性质）可大幅简化实现。

### ✨ 解题技巧总结
- **维度分离法**：将时间、空间变量拆分为独立维度（l±t）处理
- **边界驱动初始化**：仅l=1的方案作为起点，r=n的方案作为终点
- **可视化调试**：小规模数据模拟方案衔接过程验证条件
- **无穷大设定**：统一使用0x3f3f3f3f/1e18避免溢出，特别注意long long

---

### 4. C++核心代码实现赏析
**通用核心实现（综合George1123与xht思路）**
```cpp
#include <bits/stdc++.h>
#define ll long long
const int N = 1e5 + 5;
const ll INF = 1e18;

struct Plan { int t, l, r, c; } p[N];
ll dist[N]; // 最短路数组

// 线段树维护 min(l-t) 和 min(l+t)
struct SegmentTree { 
    struct Node { ll min1, min2; } tr[N<<2];
    void update(int o, int l, int r, int pos, ll v1, ll v2) {
        if(l == r) { tr[o] = {v1, v2}; return; }
        // 递归更新左右子树
    }
    void query(int o, int ql, int qr, ll lim, int type, vector<int>& res) {
        if(tr[o].min1 > lim && type==0) return; // 根据type选择判断条件
        // 递归查询满足条件的叶子节点
    }
} seg;

void dijkstra() {
    priority_queue<pair<ll, int>> pq;
    for(int i=1; i<=M; ++i) {
        if(p[i].l == 1) {
            dist[i] = p[i].c;
            pq.push({-dist[i], i});
            seg.update(i, INF, INF); // 删除已松弛节点
        } else seg.update(i, p[i].l - p[i].t, p[i].l + p[i].t);
    }
    while(!pq.empty()) {
        int u = pq.top().second; pq.pop();
        vector<int> tmp;
        seg.query(1, 1, u-1, p[u].r - p[u].t + 1, 0, tmp); // 查询t_j≤t_u的点
        seg.query(1, u+1, M, p[u].r + p[u].t + 1, 1, tmp); // 查询t_j>t_u的点
        for(int v : tmp) {
            dist[v] = dist[u] + p[v].c;
            pq.push({-dist[v], v});
            seg.update(v, INF, INF); // 删除节点
        }
    }
}
```
**代码解读概要**：  
1. 按治疗时间t排序方案  
2. 线段树维护每个方案的l-t和l+t值  
3. Dijkstra起点：所有覆盖左端点（l=1）的方案  
4. 松弛时双查询：满足rᵢ-tᵢ+1≥lⱼ-tⱼ（tⱼ≤tᵢ）或rᵢ+tᵢ+1≥lⱼ+tⱼ（tⱼ>tᵢ）  
5. 目标：取覆盖右端点（r=n）的最小dist

---

### 5. 算法可视化：像素动画演示
**主题**："光波战疫"像素策略游戏  
**核心演示**：治疗方案衔接如何阻断病毒扩散  

#### 设计思路
```plaintext
 时间轴
   ↑ 
  5| ▢▢■■■■■■■■   ← 光波3（t=5覆盖[3,7]）
  4|   ▢▢▢■■■■■    ← 光波2（t=4覆盖[4,8]）
  3|     ■■■■■      ← 病毒扩散（斜率±1）
  2|       ▢▢▢      ← 光波1（t=2覆盖[5,10]）
  1|────────────→ 村民编号
     1 3 5 7 9 
```

1. **像素化场景**  
   - 8-bit风格网格：纵轴时间（0-10天），横轴村民（1-N）
   - 颜色编码：健康（绿色）、感染（红色）、光波（蓝色闪光）

2. **动态演示流程**  
   - **光波释放**：在tᵢ时刻，[lᵢ,rᵢ]区间变为蓝色，播"叮！"音效  
   - **病毒扩散**：每天红色沿±45°方向扩展一格，播"嗡嗡"音效  
   - **线段树交互**：右侧显示线段树结构，满足条件的节点闪烁黄光  
   - **方案衔接**：当新光波覆盖扩散前沿时，播"衔接成功"音效  

3. **游戏化元素**  
   - **控制面板**：单步/自动播放（带调速滑块）、重置  
   - **关卡设计**：每个治疗方案视为一关，成功衔接得★  
   - **音效系统**：不同操作触发8-bit音效（Web Audio API实现）

4. **技术实现**  
   - Canvas绘制网格和动态元素  
   - 每帧检测：当前光波rᵢ是否≥扩散位置  
   - 自动演示模式：AI按最优顺序执行方案（类贪吃蛇AI路径）

---

### 6. 拓展练习与相似问题
**技巧迁移场景**  
1. 动态规划中的状态转移优化（不等式条件）  
2. 二维平面区域覆盖问题（旋转坐标轴）  
3. 带时间窗的路径规划（如物流配送）  

**洛谷推荐**  
1. **P5471 [NOI2019] 弹跳**  
   → 二维平面最短路优化，KD树/线段树应用  
2. **P2146 [NOI2015] 软件包管理器**  
   → 树链剖分优化操作序列，区间覆盖思维  
3. **P1081 [NOIP2012] 开车旅行**  
   → 预处理+倍增优化，培养问题分解能力  

---

### 7. 学习心得与经验分享
> **George1123的经验**：  
> "注意INF大小和long long问题，初始化不当会导致WA"  
> **Kay点评**：数据范围（10⁹）决定需用long long和足够大的INF（≥1e18）。建议：  
> 1. 统一使用`const ll INF = 1e18`  
> 2. 初始化后立即输出INF值验证  
> 3. 测试边界数据（如N=1e9）  

> **xht的调试技巧**：  
> "当衔接失败时，输出rᵢ-tᵢ和lⱼ-tⱼ的值对比"  
> **Kay总结**：关键变量中间输出是调试多维优化的利器，建议封装调试函数：  
> ```cpp
> void debug(int i, int j) {
>   cout << "方案" << i << "的r-t=" << p[i].r-p[i].t 
>        << " vs 方案" << j << "的l-t=" << p[j].l-p[j].t << endl;
> }
> ```

---

### 结语
通过本次分析，我们看到最短路优化建图在时空衔接问题中的强大威力。核心在于：  
1️⃣ 将操作序列转化为图结构  
2️⃣ 利用排序拆分多维条件  
3️⃣ 基于算法特性（点权最短路）设计数据结构  
建议用像素动画模拟小规模案例（如样例1）加深理解，再挑战洛谷推荐习题。记住：优雅的解法往往源于对问题本质的洞察！🚀

---
处理用时：216.66秒
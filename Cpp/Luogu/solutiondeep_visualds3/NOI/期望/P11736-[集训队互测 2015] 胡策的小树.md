# 题目信息

# [集训队互测 2015] 胡策的小树

## 题目描述

在 OI 界，有一位无人不知无人不晓，OI 水平前无古人后无来者的胡策，江湖人称一眼秒题胡大爷。

胡策最近从一名自称是小 O 的神秘男子那里收到了一棵神奇的小树苗。

这是一棵 $n$ 个节点的有根树，节点标号为 $1, \dots, n$，其中 $1$ 号点为根。

这棵有根树上每个点都有一个权值，点 $i$ 的权值为 $a_i$。$a_1, \dots, a_n$ 构成了一个 $0\sim n-1$ 的排列，且 $a_1=0$。

胡策大爷十分喜欢猴子，他打算在这棵树上养 $n$ 只猴子。初始时，每个节点上将放着恰好一只猴子。猴子们十分好动，每过一秒，每只在 $i$ 节点的猴子会设法往 $i$ 的父亲节点上跳，有 $p(i)$ 的概率成功跳到父亲节点；否则跳跃失败，将等概率地随机落到子树 $i$ 里某个节点上（包括点 $i$）。

因为根节点没有父亲，所以 $p(1)=0$。对于 $2\leq i\leq n$，有 $p(i)=\frac{a_i}{n}$；

在第 $i$ 秒，胡策会观察并记录这 $n$ 只猴子中成功跳上父亲结点的猴子所占的比例 $g_i$。胡策认为 $g_0, \dots, g_T$ 的平均值就是这群猴子们生活的幸福指数，为保证准确，其中 $T$ 为很大很大的值，为 $(n+1)^{99999^{99999^{99999}}}$

为了让猴子们的幸福指数的期望更大，胡策又从那名自称是小 O 的神秘男子那里买来了一袋叫“金坷垃”的肥料。如果给这棵有根树掺 $x$ 克的金坷垃，那么这棵树每个点 $i$ 的权值将变化成 $(a_i+x)\bmod n$。因为胡策是土豪有钱任性，$x$ 可以取任意非负整数。

请你告诉胡策，他该掺多少克的金坷垃，才能使猴子们幸福指数的期望最大呢？

## 说明/提示

- 对于 $10\%$ 的数据：$n = 2$。
- 对于 $20\%$ 的数据：$n\leq 5$。
- 对于 $30\%$ 的数据：$n\leq 100$。
- 对于 $50\%$ 的数据：$n\leq 2000$。
- 对于 $70\%$ 的数据：$n\leq 100000$。
- 对于 $100\%$ 的数据：$2\leq n\leq 500000$。

数据保证有一定梯度。

数据都是随机生成的。即：节点 $i$ 的父亲是从 $1\sim i-1$ 中随机选取的，$a_1 \dots a_n$ 是一个 $0 \sim n-1$ 的随机排列。

## 样例 #1

### 输入

```
3
0 1 1
0 1 2```

### 输出

```
0.266666667```

# AI分析结果

---
# 💡 Kay的C++算法解析：[集训队互测2015] 胡策的小树 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（树上递推） + 子树贡献处理`

🗣️ **初步分析**：  
解决这道题，就像在一棵“魔法果树”上找最甜的果实——每个节点（果实）的“甜度”（幸福指数）取决于它的“生长方式”（猴子跳跃的稳态分布）。而金坷垃的作用是让某一个节点变成“吸引中心”，所有猴子最终都会跑到它的“果实群”（子树）里。我们的任务就是找到这个最甜的“果实群”！  

### 核心算法思想  
这道题的关键是**“稳态分布递推”**：当时间足够长时，猴子的分布会稳定下来（不会再变）。通过推导稳态方程，我们可以得到一个简洁的递推式（比如 `p_u f_u / sz_u = f_{fa_u}/sz_{fa_u}`），像“传话筒”一样从根到叶子或者反过来计算每个节点的“重要性”（f_u）。而金坷垃的作用是让某节点成为“新根”，我们只需要计算该节点子树内的幸福值，因为猴子最终会留在那里～  

### 题解思路与核心难点  
所有题解都围绕两个关键点展开：  
1. **稳态方程推导**：如何从“猴子跳来跳去但分布不变”的条件，推导出可以快速计算的递推式？（比如Glacy的题解把方程化简到只需O(n)时间计算）  
2. **金坷垃的高效处理**：x是任意非负整数，但`(a_i+x)mod n`会让x等价于0~n-1（因为mod n周期）。每个x对应唯一的“吸引子”节点u（a_u+x≡0），我们只需计算u子树内的幸福值。由于树是随机生成的，所有子树大小之和是O(n log n)，所以总时间很高效！  

### 可视化设计思路  
我打算做一个**像素风的“果树探险”动画**：  
- 用8位像素块画树，每个节点是彩色方块（颜色越深代表f_u越大）；  
- 点击“金坷垃x”按钮，对应的“吸引子”节点会闪烁黄色，子树用蓝色框起来；  
- 递推计算时，当前节点会“跳一下”（像素动画），父节点的箭头亮起，伴随“叮”的音效；  
- 计算完一个子树的幸福值，会弹出“子树甜度：XX”的像素文字，如果比当前最大值大，就播放“升级”音效（像FC游戏通关一样）！  


## 2. 精选优质题解参考

### 题解一：Glacy（评分5星）  
**点评**：这份题解的推导“一剑封喉”！它从“稳态分布不变”的条件出发，一步步化简方程，最终得到`p_u f_u / sz_u = f_{fa_u}/sz_{fa_u}`这样的简洁递推式，直接把问题变成了O(n)的树上遍历。对于金坷垃的处理，它点出“每个x对应唯一的吸引子节点，只需计算其子树”，逻辑清晰到“一看就懂”～  

### 题解二：_lmh_（评分4星）  
**点评**：这道题解的代码“落地性强”！它把推导后的方程写成了可运行的C++代码，比如用DFS计算子树大小，枚举每个x对应的吸引子节点，然后递推计算f_u。代码里的`f[v]`计算、子树求和都很规范，甚至处理了`mod n`的细节，适合初学者照着敲代码～  

### 题解三：forgotmyhandle（评分4星）  
**点评**：这道题解的思路“另辟蹊径”！它用二分答案的方法，把“求最大幸福值”变成“判断某个值是否可达”，然后用DFS检查子树的可行性。这种“反过来想”的技巧很巧妙，适合学过二分的同学拓展思维～  


## 3. 核心难点辨析与解题策略

### 关键点1：稳态方程的推导  
**难点**：为什么长时间后，猴子的分布f_u不会变？  
**解决方案**：假设第t步和第t+1步的分布相同（稳态），那么可以写出`f_u`的方程（比如“从子节点来的概率”等于“到父节点或子树的概率”）。通过化简，就能得到递推式！  

### 关键点2：金坷垃的周期性处理  
**难点**：x是任意非负整数，怎么枚举所有可能？  
**解决方案**：`(a_i+x)mod n`的周期是n，所以只需枚举x=0到n-1。每个x对应唯一的u（a_u+x≡0），猴子最终会留在u的子树里～  

### 关键点3：子树的高效计算  
**难点**：枚举n个x，每个x计算子树会不会超时？  
**解决方案**：随机树的子树大小之和是O(n log n)（比如每个节点的子树大小平均是log n），所以总时间是O(n log n)，完全能通过！  

### ✨ 解题技巧总结  
- **稳态思维**：遇到“长时间后稳定”的问题，先假设分布不变，写方程化简；  
- **周期利用**：mod n的问题，一定要想到枚举0到n-1；  
- **随机树性质**：随机生成的树，子树大小之和很小，可以放心处理每个子树～  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
**说明**：这份代码综合了_lmh_和Glacy的思路，清晰实现了“枚举x→找吸引子→算子树幸福值”的流程。  

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double ld;
const int N=500007;
int n,a[N],fa[N],id[N],tI[N],tO[N],timer,b[N],sz[N];
vector<int> son[N];
ld p[N],q[N],f[N],ans;

// 计算子树大小
void dfs(int u){
    id[tI[u]=++timer]=u;
    for(int v:son[u]) if(v!=fa[u]) dfs(v);
    tO[u]=timer; sz[u]=tO[u]-tI[u]+1;
}

int main(){
    ios::sync_with_stdio(false); cin.tie(0);
    cin>>n;
    for(int i=2;i<=n;++i){
        cin>>fa[i]; son[fa[i]].push_back(i);
    }
    for(int i=1;i<=n;++i){
        cin>>a[i]; b[a[i]]=i; // b[v] = 满足a[u]=v的u
    }
    dfs(1); // 预处理子树大小和dfs序

    // 枚举x=0到n-1（因为mod n周期）
    for(int x=0;x<n;++x){
        int u=b[x]; // 吸引子节点：a[u]+x≡0 → a[u]=x
        // 处理u子树内的p、q
        for(int i=tI[u];i<=tO[u];++i){
            int v=id[i];
            int o=(a[v]+x)%n; // 新的a_v+x mod n
            p[v]=(ld)o/n;
            q[v]=(1-p[v])/sz[v];
        }
        // 递推计算f[u]（从叶子到根）
        for(int i=tO[u];i>tI[u];--i){
            int v=id[i];
            f[v]=1;
            for(int w:son[v]) if(w!=fa[v]){
                f[v]+= (p[w]/q[w])*q[v]*(1-f[w]);
            }
            f[v]=1/f[v];
        }
        f[u]=1; // 吸引子节点的f初始为1
        // 计算所有节点的f（从根到叶子）
        for(int i=tI[u]+1;i<=tO[u];++i){
            int v=id[i];
            f[v]*=f[fa[v]];
        }
        // 转换为实际的f_u，并计算幸福值
        ld sum=0, now=0;
        for(int i=tI[u];i<=tO[u];++i){
            int v=id[i];
            f[v]=(f[v]-f[fa[v]])/q[v];
            sum+=f[v];
        }
        for(int i=tI[u];i<=tO[u];++i){
            int v=id[i];
            now+= (f[v]/sum)*p[v]; // 幸福值是f[v]/sum * p[v]的和
        }
        ans=max(ans,now);
    }
    cout<<fixed<<setprecision(10)<<ans<<endl;
    return 0;
}
```

**代码解读概要**：  
1. **预处理**：用DFS计算每个节点的子树大小`sz[u]`和DFS序（方便快速访问子树）；  
2. **枚举x**：每个x对应吸引子节点u（a[u]=x）；  
3. **子树处理**：计算u子树内每个节点的p（成功概率）和q（失败后的转移概率）；  
4. **递推计算**：从叶子到根算f[v]，再从根到叶子更新，最后求幸福值；  
5. **取最大值**：记录所有x中的最大幸福值，输出！  


### 题解一（Glacy）核心代码片段  
**亮点**：化简后的递推式，直接计算f_u！  
```cpp
// 假设已经算出p[u]和sz[u]
for(int u=2;u<=n;++u){
    f[u] = (f[fa[u]] / sz[fa[u]]) * sz[u] / p[u];
}
```  
**代码解读**：这段代码是Glacy推导的“精华”！根据`p_u f_u / sz_u = f_{fa_u}/sz_{fa_u}`，直接得到`f[u] = f[fa[u]] * sz[u] / (p[u] * sz[fa[u]])`。只需要从根（f[1]已知）开始遍历树，就能算出所有f[u]～  

**学习笔记**：遇到树上的递推问题，一定要先找“父节点和子节点的关系”，这样能把O(n^2)的问题变成O(n)！  


### 题解三（forgotmyhandle）核心代码片段  
**亮点**：二分答案判断可行性！  
```cpp
bool chk(int x, double mid) {
    rt = x, e = mid;
    dfs1(x); // 计算子树的s[rt]
    return s[rt] / sz[x] - e > 0; // 判断是否能达到mid
}
```  
**代码解读**：这段代码把“求最大幸福值”变成“二分mid，判断是否存在x让幸福值≥mid”。`dfs1`计算子树的总收益，如果`总收益/sz[x] > mid`，说明mid可达～  

**学习笔记**：最大值问题，可以试试“二分答案+可行性检查”，有时候会比直接计算更简单！  


## 5. 算法可视化：像素风“果树探险”

### 动画主题  
**像素探险家：寻找最甜的果实群**  

### 核心演示内容  
1. **初始界面**：用8位像素块画一棵随机树，根节点是红色，其他节点是蓝色；  
2. **金坷垃选择**：底部有一个“x=0~n-1”的滑块，拖动滑块，对应的“吸引子”节点会闪烁黄色，子树用蓝色框起来；  
3. **递推计算**：点击“开始计算”，当前节点会“跳一下”（像素动画），父节点的箭头亮起，伴随“叮”的音效；  
4. **结果展示**：计算完一个子树，屏幕右上角会显示“当前甜度：XX”，如果比最大值大，就播放“升级”音效（像FC游戏通关一样）；  
5. **重置与自动播放**：有“重置”按钮（回到初始树）和“自动播放”按钮（自动遍历所有x，找到最大值）。  

### 游戏化元素  
- **音效**：递推时“叮”，找到最大值时“嘟——”，错误时“咔”；  
- **积分**：每算对一个子树，得10分，连续算对3个得“连击奖励”（额外20分）；  
- **关卡**：把x分成5个“小关”，完成一关得“水果徽章”（比如苹果、香蕉）。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
这道题的**“稳态递推+子树处理”**思路，可以用到很多树上的概率问题，比如：  
1. **树上的随机游走**：比如“一只蚂蚁在树上爬，求长时间后停在某个节点的概率”；  
2. **子树贡献问题**：比如“每个节点有一个权值，求所有子树的权值和”；  
3. **周期性问题**：比如“mod n的问题，枚举0到n-1”。  

### 洛谷推荐练习  
1. **P2014 选课**：树上的背包问题，练习子树的递推处理；  
2. **P3177 树上染色**：树上的动态规划，练习子树贡献的计算；  
3. **P1352 没有上司的舞会**：树上的最大独立集，练习从叶子到根的递推。  


## 7. 学习心得与经验分享  

**参考经验（来自_lmh_）**：“我最开始卡在‘稳态方程’的推导，后来找了几个小例子（比如n=2的树），手动算f_u的值，才明白‘分布不变’的意思。然后写代码时，一定要注意DFS序的处理，这样访问子树会很快！”  

**点评**：这位作者的经验很实在！遇到抽象的方程，**手动算小例子**是最好的方法；而处理子树时，**DFS序**能把“子树”变成“连续的数组区间”，大大简化代码～  


## 总结  
这道题的核心是**“稳态递推+子树处理”**，金坷垃的作用是让我们找到“最甜的子树”。通过推导方程、利用周期、处理子树，我们能高效解决问题！  

记住：**编程的乐趣在于“把抽象的数学变成可运行的代码”**，就像把“果树的甜度”变成像素动画里的闪烁节点～下次遇到树上的概率问题，不妨试试今天学的“稳态思维”和“子树处理”哦！💪  

---  
本次分析就到这里，希望大家能爱上“果树探险”，下次再见！🌟

---
处理用时：117.54秒
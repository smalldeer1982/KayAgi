# 题目信息

# [SDOI2017] 龙与地下城

## 题目描述

小 Q 同学是一个热爱学习的人，但是他最近沉迷于各种游戏，龙与地下城就是其中之一。

在这个游戏中，很多场合需要通过掷骰子来产生随机数，并由此决定角色未来的命运，因此骰子堪称该游戏的标志性道具。

骰子也分为许多种类，比如 $4$ 面骰、$6$ 面骰、$8$ 面骰、$12$ 面骰、$20$ 面骰，其中 $20$ 面骰用到的机会非常多。当然，现在科技发达，可以用一个随机数生成器来取代真实的骰子，所以这里**认为骰子就是一个随机数生成器**。

在战斗中，骰子主要用来决定角色的攻击是否命中，以及命中后造成的伤害值。举个例子，假设现在已经确定能够命中敌人，那么 $YdX$（也就是掷出 $Y$ 个 $X$ 面骰子之后所有骰子显示的数字之和）就是对敌人的基础伤害。在敌人没有防御的情况下，这个基础伤害就是真实伤害。

众所周知，骰子显示每个数的概率应该是相等的，也就是说，对于一个 $X$ 面骰子，显示 $0, 1, 2,\dots ,X−1$ 中每一个数字的概率都是 $\dfrac {1}{X}$。

更形式化地说，这个骰子显示的数 $W$ 满足离散的均匀分布，其分布列为

| $H$ | $0$ | $1$ | $2$ | $\cdots$ | $X-1$ |
| :--: | :--: | :--: | :--: | :--: | :--: |
| $P$ | $\dfrac {1}{X}$ | $\dfrac {1}{X}$ | $\dfrac {1}{X}$ | $\cdots$ | $\dfrac {1}{X}$ |


除此之外还有一些性质：

- $W$ 的**一阶原点矩**（**期望**）为

$$v_1(W)=E(W)=\sum_{i=0}^{X-1}i\cdot P(W=i)=\frac {X-1}{2}$$

- $W$ 的**二阶中心矩**（**方差**）为

$$\mu_2(W)=E((W-E(W))^2)=\sum_{i=0}^{X-1}(i-E(W))^2\cdot P(W=i)=\frac {X^2-1}{12}$$

言归正传，现在小 Q 同学面对着一个生命值为 A 的没有防御的敌人，能够发动一次必中的 $YdX$ 攻击，显然只有造成的伤害不少于敌人的生命值才能打倒敌人。但是另一方面，小 Q 同学作为强迫症患者，不希望出现 overkill，也就是造成的伤害大于 $B$ 的情况，因此**只有在打倒敌人并且不发生 overkill 的情况下小 Q 同学才会认为取得了属于他的胜利**。

因为小 Q 同学非常谨慎，他会进行 $10$ 次模拟战，每次给出敌人的生命值 $A$以及 overkill 的标准 $B$，他想知道此时取得属于他的胜利的概率是多少，你能帮帮他吗？


## 说明/提示

对于 $100\%$ 的数据，$T \leq 10$，$2 \leq X \leq 20$，$1 \leq Y \leq 200000$，$0 \leq A \leq B \leq (X-1)Y$。

**保证满足 $Y > 800$ 的数据不超过 $2$ 组。**

| 测试点编号 | $X$ | $Y$ | 备注 |
| :--: | :--: | :--: | :--: |
| $1$ | $\le 20$ | $\le 40$ | $X^Y\le 10^7$ |
| $2\sim 4$ | $\le 20$ | $\le 1\, 600$ | - |
| $5\sim 10$ | $\le 20$ | $\le 8\, 000$ | - |
| $11,12$ | $=2$ | $\le 200\, 000$ | - |
| $13\sim 20$ | $\le 20$ | $\le 200\, 000$ | - |


## 样例 #1

### 输入

```
1
2 19
0 0
0 1
0 2
0 3
0 4
0 5
0 6
0 7
0 8
0 9```

### 输出

```
0.000002
0.000038
0.000364
0.002213
0.009605
0.031784
0.083534
0.179642
0.323803
0.500000```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2017]龙与地下城 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：分治策略（小数据FFT/大数据中心极限定理）、多项式快速幂（FFT优化）、正态分布与辛普森积分


🗣️ **初步分析**：  
这道题的核心是计算**多个独立随机变量的和的概率分布**——掷Y个X面骰子，求点数和落在[A,B]的概率。解决它需要“分情况讨论”：  
- **小数据（X*Y较小）**：用**多项式快速幂（FFT优化）**。把每个骰子的概率看成一个多项式（次数0~X-1，系数1/X），多个骰子的组合概率就是多项式的Y次幂（多项式乘法对应组合所有可能的点数和）。FFT能把多项式乘法的时间从O(n²)降到O(n log n)，快速算出所有可能的点数和的概率。  
- **大数据（X*Y较大）**：用**中心极限定理**。当Y足够大时，多个独立随机变量的和会趋近于**正态分布**（就像考试分数集中在平均分附近）。题目已经给出单个骰子的期望μ=(X-1)/2和方差σ²=(X²-1)/12，Y个骰子的和的期望是Yμ，方差是Yσ²。此时只需计算正态分布在[A,B]区间的积分，就能得到概率（用辛普森积分近似计算）。  

**可视化设计思路**：  
我们用**复古8位像素风**模拟“骰子工厂”：  
- 小数据模式：屏幕左侧显示“多项式积木”（每个积木代表一个点数的概率，颜色越深概率越大），点击“合并”会播放积木碰撞的动画（FFT卷积过程），最终积木堆的高度对应点数和的概率。  
- 大数据模式：右侧显示正态分布的“像素曲线”，拖动滑块选择A和B，曲线下的区域会用黄色高亮，同步显示积分结果。关键操作（如转换标准正态分布、积分计算）会播放“叮”的音效，完成时播放胜利音调。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度筛选了3份优质题解，帮大家快速理解核心逻辑：
</eval_intro>

**题解一：shadowice1984（分治处理+FFT+辛普森）**  
* **点评**：这份题解完美覆盖了小数据和大数据的场景——当X*Y≤阈值时用FFT计算多项式快速幂，否则用中心极限定理+辛普森积分。代码结构清晰，FFT和辛普森的模板都很标准，甚至处理了浮点数精度问题（FFT后用实数部分计算概率）。亮点是**分治策略**，既保证了小数据的准确性，又解决了大数据的效率问题。


**题解二：zj余能（多项式截断优化）**  
* **点评**：这份题解针对FFT的精度问题做了优化——多项式相乘时，截断概率小于1e-9的项（这些项对结果影响极小），大幅减少了计算量。思路非常巧妙：既然小概率项可以忽略，不如直接丢掉，既加快速度又避免浮点误差累积。代码里的`Cut`函数就是这个优化的核心，值得学习。


**题解三：StudyingFather（模块化代码）**  
* **点评**：这份题解把FFT和辛普森积分拆成了两个独立的模块，代码可读性极强。比如`fft::solve`负责小数据的多项式快速幂，`simpson::solve`负责大数据的正态分布积分。模块化的写法让代码更容易调试和复用，适合初学者参考。亮点是**代码的工程化思维**，把复杂问题拆成小模块，逐个解决。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是“跨过三个坎”，我们逐一拆解：
</difficulty_intro>

### 1. 小数据与大数据的分界：什么时候用FFT？
**难点**：FFT处理浮点数会有误差，且当X*Y很大时（比如Y=2e5），FFT的时间和空间都会超限。  
**解决方案**：设定一个阈值（比如X*Y≤5e5），小于阈值用FFT，否则用中心极限定理。题目里也提示“Y>800的数据不超过2组”，刚好适合分治处理。


### 2. 多项式快速幂的精度问题：FFT的浮点误差怎么办？
**难点**：FFT计算浮点数多项式乘法时，会积累微小误差，导致小概率项的系数不准。  
**解决方案**：截断小概率项（如zj余能的题解）。当某一项的概率小于1e-9时，直接丢弃——这些项对最终结果的影响可以忽略，却能大幅减少计算量。


### 3. 正态分布积分的精度：如何准确计算积分？
**难点**：正态分布的概率密度函数是连续的，无法直接求和，只能用数值积分近似。  
**解决方案**：用**自适应辛普森积分**。它能自动调整积分的“步长”——如果某段区间的积分误差大，就拆分成更小的区间计算，直到误差满足要求。另外，把正态分布转换成**标准正态分布**（期望0，方差1）再积分，能进一步提高精度。


### ✨ 解题技巧总结
- **分治策略**：根据数据规模选择不同的算法，避免“一刀切”。  
- **多项式截断**：忽略小概率项，减少计算量和误差。  
- **数值积分**：用辛普森积分近似连续函数的积分，解决正态分布的概率计算问题。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**，它整合了分治策略、FFT和辛普森积分的框架：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了优质题解的分治思路，覆盖小数据和大数据场景，逻辑清晰。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <complex>
#include <cmath>
using namespace std;

typedef complex<double> cpx;
const double PI = acos(-1);
const int MAX_FFT = 1 << 18; // FFT最大长度

// FFT模板
void fft(cpx a[], int n, int op) {
    vector<int> rev(n);
    for (int i = 0; i < n; ++i)
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? n >> 1 : 0);
    for (int i = 0; i < n; ++i)
        if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int len = 2; len <= n; len <<= 1) {
        cpx wlen(cos(2 * PI / len), op * sin(2 * PI / len));
        for (int i = 0; i < n; i += len) {
            cpx w(1);
            for (int j = 0; j < len / 2; ++j) {
                cpx u = a[i + j], v = a[i + j + len/2] * w;
                a[i + j] = u + v;
                a[i + j + len/2] = u - v;
                w *= wlen;
            }
        }
    }
    if (op == -1)
        for (int i = 0; i < n; ++i)
            a[i] /= n;
}

// 多项式快速幂（FFT实现）
vector<double> poly_pow(int x, int y) {
    int n = 1;
    while (n < x * y) n <<= 1;
    cpx a[MAX_FFT] = {0}, b[MAX_FFT] = {0};
    for (int i = 0; i < x; ++i) b[i] = 1.0 / x;
    a[0] = 1.0;
    fft(a, n, 1); fft(b, n, 1);
    // 快速幂：a = a * b^y
    for (int ex = y; ex; ex >>= 1) {
        if (ex & 1) for (int i = 0; i < n; ++i) a[i] *= b[i];
        for (int i = 0; i < n; ++i) b[i] *= b[i];
    }
    fft(a, n, -1);
    vector<double> res(x * y);
    for (int i = 0; i < x * y; ++i) res[i] = a[i].real();
    return res;
}

// 辛普森积分模板（正态分布）
double mu, sigma2;
double f(double x) {
    return exp(-(x - mu) * (x - mu) / (2 * sigma2)) / sqrt(2 * PI * sigma2);
}
double simpson(double l, double r) {
    double mid = (l + r) / 2;
    return (r - l) * (f(l) + 4 * f(mid) + f(r)) / 6;
}
double adaptive_simpson(double l, double r, double eps = 1e-6) {
    double mid = (l + r) / 2;
    double sl = simpson(l, mid), sr = simpson(mid, r), s = simpson(l, r);
    if (fabs(sl + sr - s) <= 15 * eps) return sl + sr + (sl + sr - s) / 15;
    return adaptive_simpson(l, mid, eps/2) + adaptive_simpson(mid, r, eps/2);
}

int main() {
    int T; cin >> T;
    while (T--) {
        int x, y; cin >> x >> y;
        if (x * y <= 5e5) { // 小数据用FFT
            vector<double> prob = poly_pow(x, y);
            vector<double> pre_sum(x * y + 1, 0);
            for (int i = 0; i < x * y; ++i) pre_sum[i+1] = pre_sum[i] + prob[i];
            for (int i = 0; i < 10; ++i) {
                int a, b; cin >> a >> b;
                printf("%.6lf\n", pre_sum[b+1] - pre_sum[a]);
            }
        } else { // 大数据用中心极限定理
            mu = y * (x - 1.0) / 2;
            sigma2 = y * (x * x - 1.0) / 12;
            for (int i = 0; i < 10; ++i) {
                int a, b; cin >> a >> b;
                double prob = adaptive_simpson(a, b);
                printf("%.6lf\n", prob);
            }
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **FFT部分**：将每个骰子的概率转换成多项式，用FFT计算多项式的Y次幂，得到所有点数和的概率。  
  2. **辛普森部分**：计算正态分布在[A,B]的积分，得到大数据的概率。  
  3. **分治逻辑**：根据X*Y的大小选择不同的算法，兼顾速度和精度。


---

<code_intro_selected>
接下来看优质题解的核心片段，点出它们的“巧思”：
</code_intro_selected>

### 题解一：shadowice1984的FFT快速幂片段
* **亮点**：用FFT实现多项式快速幂，直接计算多个骰子的组合概率。
* **核心代码片段**：
```cpp
// FFT后的快速幂：res[i] = res[i] ^ y
fft(res, lim, 1);
for (int i = 0; i < lim; ++i) res[i] = po(res[i], y);
fft(res, lim, -1);
```
* **代码解读**：  
  1. `fft(res, lim, 1)`：将多项式从“系数域”转到“点值域”（FFT正变换），方便快速乘法。  
  2. `res[i] = po(res[i], y)`：点值域的快速幂（每个点值直接取y次方）。  
  3. `fft(res, lim, -1)`：将点值域转回系数域（FFT逆变换），得到多项式的Y次幂系数（即点数和的概率）。  
* **学习笔记**：FFT的核心是“系数域→点值域→系数域”的转换，把多项式乘法变成点值乘法，大幅加速计算。


### 题解二：zj余能的多项式截断片段
* **亮点**：截断小概率项，减少计算量和误差。
* **核心代码片段**：
```cpp
void Cut(vector<double> &a, int &base) {
    const double GAMA = 1e-9;
    int id = 0;
    while (a[id] < GAMA) ++id; // 找到第一个非小概率项
    for (int i = 0; i + id < a.size(); ++i) a[i] = a[i + id];
    while (!a.empty() && a.back() < GAMA) a.pop_back(); // 截断末尾小概率项
    base += id;
}
```
* **代码解读**：  
  1. `GAMA = 1e-9`：设定小概率阈值，小于这个值的项可以忽略。  
  2. `id`：找到第一个概率≥1e-9的项，把前面的小概率项删掉。  
  3. `a.pop_back()`：删掉末尾的小概率项，减少多项式长度。  
* **学习笔记**：截断小概率项是处理浮点FFT的“神技巧”，能有效避免误差累积，同时加快计算速度。


### 题解三：StudyingFather的辛普森积分片段
* **亮点**：自适应辛普森积分，自动调整步长保证精度。
* **核心代码片段**：
```cpp
double asr(double l, double r, double eqs, double ans, int step) {
    double mid = (l + r) / 2;
    double fl = simpson(l, mid), fr = simpson(mid, r);
    if (abs(fl + fr - ans) <= 15 * eqs && step < 0)
        return fl + fr + (fl + fr - ans) / 15;
    else
        return asr(l, mid, eqs/2, fl, step-1) + asr(mid, r, eqs/2, fr, step-1);
}
```
* **代码解读**：  
  1. `mid`：将区间分成左右两半。  
  2. `fl + fr`：左右两半的辛普森积分和。  
  3. `abs(fl + fr - ans) <= 15 * eqs`：如果误差满足要求，直接返回结果；否则递归拆分区间，直到误差足够小。  
* **学习笔记**：自适应辛普森积分是“聪明的积分”——它不会盲目拆分所有区间，只拆分误差大的部分，既保证精度又节省时间。


## 5. 算法可视化：像素动画演示

### 🌟 动画主题：骰子工厂的“概率生产线”
**设计思路**：用复古8位像素风模拟“骰子生产”，让算法变得“看得见、摸得着”：
- **场景初始化**：屏幕左侧是“骰子仓库”（显示X面骰子的概率，每个点数用不同颜色的像素块表示），右侧是“概率显示器”（小数据显示多项式积木，大数据显示正态曲线）。
- **小数据模式（FFT）**：
  1. 点击“开始生产”：仓库的骰子块会“流向”多项式乘法区，播放“咔嚓”的合并音效。
  2. 每合并一次，多项式积木的数量翻倍（对应快速幂的“平方”操作），颜色越深的积木代表概率越大。
  3. 最终积木堆的高度对应所有可能的点数和的概率，点击“查询”会高亮[A,B]区间的积木，显示概率和。
- **大数据模式（中心极限定理）**：
  1. 输入X和Y后，显示器会自动画出正态分布的像素曲线（峰值在Yμ，宽度对应Yσ²）。
  2. 拖动滑块选择A和B，曲线下的区域会用黄色高亮，同步显示积分结果（辛普森积分的进度用进度条表示）。
  3. 关键操作（如转换标准正态分布）会播放“叮”的音效，完成时播放胜利音调（类似FC游戏的过关音效）。
- **交互控制**：
  - 面板有“单步”“自动”“重置”按钮，自动模式会以每秒2帧的速度播放动画。
  - 速度滑块可以调整动画速度（1~5倍速），满足不同学习节奏。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **多项式快速幂**：适用于“多个独立事件的组合概率”问题（如掷骰子、抽卡片）。
- **中心极限定理**：适用于“大量独立随机变量的和”问题（如统计全校学生的考试总分分布）。
- **辛普森积分**：适用于“连续函数的积分近似”问题（如计算曲线下的面积、概率密度的积分）。


### 洛谷推荐练习
1. **P1919 【模板】A*B Problem（FFT）**：练习FFT的基本用法，熟悉多项式乘法。
2. **P3803 【模板】多项式乘法（FFT）**：深入理解FFT的原理，处理更大的多项式。
3. **P4284 【SHOI2014】概率充电器**：结合概率和树形DP，练习期望和方差的应用。
4. **P3779 【SDOI2017】龙与地下城（原题）**：再做一遍原题，巩固分治策略和正态分布的应用。


## 7. 学习心得与经验分享 (若有)

> **参考经验（来自zj余能的题解）**：“我在解决FFT的精度问题时，发现小概率项的误差会累积，于是尝试截断这些项，结果计算速度提高了3倍，精度也变好了！”  
> **点评**：这位作者的经验很实用——当浮点数计算出现误差时，不妨想想“哪些项可以忽略”。截断小概率项不仅能减少计算量，还能避免误差被放大，是处理浮点FFT的“神器”。


## 8. 总结

本次分析覆盖了“龙与地下城”的核心算法：分治策略、FFT多项式快速幂、中心极限定理和辛普森积分。记住：  
- 小数据用FFT，大数据用中心极限定理；  
- FFT的关键是“系数域→点值域→系数域”的转换；  
- 辛普森积分能准确计算连续函数的积分。  

编程能力的提升在于“多练、多想”——试着用FFT解决更多组合概率问题，用中心极限定理分析生活中的数据（比如班级考试分数的分布），你会发现算法其实很有趣！💪


--- 

本次分析就到这里，下次我们一起探索更有趣的算法问题！🚀

---
处理用时：113.28秒
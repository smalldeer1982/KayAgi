# 题目信息

# 射命丸文的笔记

## 题目背景

### （七）再见，地底世界的朋友们

在地灵殿住了许多天了呢。

这些日子里，觉分享了很多旧地狱的故事。

此次地底旅行，可以说是非常充实了。

虽然仍旧有些不舍，不过人类总是要见太阳的，再说这样麻烦觉姐姐招待我们也有些过意不去呢。

那么，和觉，恋，阿燐，阿空，以及其他宠物们说再见吧。

......

旧地狱的街市，依旧飘着雪。

已经能看到溶洞了。

环境又变得幽闭起来。

诶，前面不是山女吗？

“啊，你们要回地面了吗，玩的怎样？”

“很开心呢，对了，剩下的问题已经解决了”

我们向山女解释了从荷取那里听到的方法。

“谢谢!”

“不客气，那么再见了~”

世界一片白茫茫的...

阳光是那么的刺眼，以至于几分钟后我们才能睁开眼睛看清楚地面的景色。

沿着魔法森林中的小路向神社走去，这次的旅行也在我们的脚步声中走向了尾声。

前方的地面上忽然出现了一页破损的笔记。

捡起来一看，发现是从文文的笔记本上脱落下来的。

射命丸文，作为（不靠谱的）新闻记者，观察到最近地灵殿里的宠物们偶尔会互相打架，于是将每场决斗的胜负关系写在了她的笔记本上。刚刚捡起来的这页笔记，上面就记录着几场“单循环赛”。

每场循环赛被抽象成一张竞赛图，其中顶点代表参加循环赛的宠物，从顶点 $u$ 指向顶点 $v$ 的边代表在一场比赛中宠物 $u$ 战胜了宠物 $v$。

观察到这页笔记上所有的竞赛图中都至少存在一条经过所有顶点的回路，我们猜想文文只会记录这样的循环赛。

可能是因为文文不清楚宠物们谁能打过谁，于是在那页笔记的最下面留下了一个这样的问题...

(见题目描述)

这最后一个问题，就留给你来解决啦。

博丽大结界，已经在我们身后了。

希望这次地底旅行，能给你留下美好的记忆~

(全文完)

## 题目描述

如果一个竞赛图含有哈密顿回路，则称这张竞赛图为值得记录的。

从所有含有 $n$ 个顶点（顶点互不相同）的，值得记录的竞赛图中等概率随机选取一个。

求选取的竞赛图中哈密顿回路数量的期望值。

由于答案可能过大/丢失精度，只需要输出答案除以 $998244353$ 的余数。

即：设答案为 $\frac{q}{p}$，则你需要输出一个整数 $x$，满足 $px\equiv q \mod 998244353$ 且 $0\leqslant x<998244353$，可以证明恰好存在一个这样的 $x$。

若不存在这样的竞赛图，输出 `-1`。

## 说明/提示

### 样例解释：

$n=1$ 时只有一种满足条件的竞赛图，就是一个点。

$n=2$ 时竞赛图中只有一条边，不能形成哈密顿回路。

$n=3$ 时有两种满足条件的竞赛图，分别为 $1\to2\to3\to1$ 和 $1\to3\to2\to1$，都只有 $1$ 条哈密顿回路，随机取出后期望值为 $1$。

$n=4$ 时有很多种满足条件的的竞赛图，这里写不下了，但是所有满足条件的竞赛图都是同构的，所以随机取出后期望值为 $1$。

### 数据范围：

测试点 1~3 中 $n\leqslant7$。

测试点 4~6 中 $n\leqslant10$。

测试点 7~10 中 $n\leqslant1000$。

测试点 11~16 中 $n\leqslant10000$。

测试点 17~25 中 $n\leqslant100000$。

数据有梯度，每个测试点 $4$ 分。

为防止卡常，最后两个点开 2s 时限。

### 名词解释：

[竞赛图](https://en.wikipedia.org/wiki/Tournament_(graph_theory))：指任意两个顶点间恰有一条有向边的有向图。

[哈密顿回路](https://en.wikipedia.org/wiki/Hamiltonian_cycle)：指除起点和终点外经过所有顶点恰好一次且起点和终点相同的路径。


by oscar


## 样例 #1

### 输入

```
4```

### 输出

```
1
-1
1
1```

# AI分析结果

---
# 💡 Kay的C++算法解析：射命丸文的笔记 深入学习指南 💡

## 引言
今天我们要解决的是**射命丸文的笔记**这道题，核心是计算有哈密顿回路的竞赛图中，哈密顿回路数量的期望。这道题结合了**组合数学**、**生成函数**和**多项式求逆**的知识，是一道典型的“数学+算法优化”题。让我们一步步拆解它！


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：生成函数 + 多项式求逆
#### 核心思想比喻
想象你有一堆“积木”（竞赛图），每种积木的大小对应点数。我们需要统计“强连通积木”（有哈密顿回路的竞赛图）的数量。生成函数就像一个“积木手册”，把每种积木的数量写成多项式项；多项式求逆则是“从手册中快速找到强连通积木的数量”——因为普通积木（所有竞赛图）的生成函数是强连通积木生成函数的“序列构造”（即普通积木是强连通积木的链状组合）。

#### 初步分析
- **题目本质**：求「所有强连通竞赛图的哈密顿回路总数」除以「强连通竞赛图的数量」的期望。
- **核心结论**：
  1. 哈密顿回路总数：$(n-1)! \cdot 2^{\binom{n}{2}-n}$（每个哈密顿回路对应$2^{\binom{n}{2}-n}$种竞赛图）。
  2. 强连通竞赛图数量：通过生成函数推导，公式为 $f_n = 2^{\binom{n}{2}} - \sum_{i=1}^{n-1} \binom{n}{i} f_i \cdot 2^{\binom{n-i}{2}}$（总竞赛图数减去非强连通的数量）。
- **核心难点**：直接计算递推式是$O(n^2)$，无法处理$n=1e5$的规模，需要用**多项式求逆**优化到$O(n\log n)$。
- **可视化设计思路**：用像素动画展示生成函数的系数变化——比如用不同颜色的像素块代表$g_i$（普通竞赛图的生成函数系数）和$f_i$（强连通竞赛图的生成函数系数），动态演示多项式求逆的过程：从初始系数开始，逐步迭代计算逆元，高亮当前处理的项，用“入队”音效提示关键步骤。


## 2. 精选优质题解参考

### 题解一：da32s1da的多项式求逆实现
**点评**：这份题解的思路非常清晰，从哈密顿回路总数的推导，到强连通竞赛图的递推式，再到生成函数的转换，每一步都有详细说明。代码实现规范，变量命名明确（比如`fac`是阶乘，`invfac`是逆元），多项式求逆的函数`PolyInv`逻辑严谨，适合初学者理解生成函数的应用。

### 题解二：x7103的多项式求逆代码
**点评**：此题解的代码结构简洁，重点突出。生成函数的构造（`G[i] = 2^(i(i-1)/2) * invfac[i]`）和多项式求逆的调用（`PolyInv(G, invG, n+1)`）非常直观，同时特判了$n=1$和$n=2$的情况，考虑周全。

### 题解三：Early的分治NTT实现
**点评**：这份题解提供了另一种优化思路——分治NTT。虽然时间复杂度是$O(n\log^2n)$，但代码清晰展示了分治处理递推式的过程（`cdq`函数），适合理解生成函数之外的优化方法。


## 3. 核心难点辨析与解题策略

### 🔍 核心难点1：理解竞赛图的强连通性与哈密顿回路的关系
- **分析**：强连通的竞赛图一定有哈密顿回路（归纳法证明：删去一个点后，剩下的强连通分量按拓扑序排列，构造回路）；有哈密顿回路的竞赛图一定强连通（回路覆盖所有点，任意两点可达）。
- **解决策略**：将问题转化为统计**强连通竞赛图的数量**。

### 🔍 核心难点2：推导强连通竞赛图的递推式
- **分析**：总竞赛图数是$2^{\binom{n}{2}}$（每对边有2种方向）。非强连通竞赛图可分解为“一个强连通子图+剩余点任意连边”，因此递推式为：  
  $f_n = 2^{\binom{n}{2}} - \sum_{i=1}^{n-1} \binom{n}{i} f_i \cdot 2^{\binom{n-i}{2}}$。
- **解决策略**：将递推式转换为**生成函数**（两边除以$n!$，得到卷积形式）。

### 🔍 核心难点3：用多项式求逆优化递推式
- **分析**：生成函数转换后，得到$G(x) = F(x) \cdot G(x) + 1$（$G$是普通竞赛图的生成函数，$F$是强连通竞赛图的生成函数），解得$F(x) = 1 - 1/G(x)$。需要用多项式求逆计算$1/G(x)$。
- **解决策略**：实现多项式求逆算法（基于NTT的迭代版本）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：本代码综合了da32s1da、x7103的思路，实现了多项式求逆，计算强连通竞赛图数量，并输出期望。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MOD = 998244353;
const int G = 3;
const int MAXN = 200010;

long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

long long invG = qpow(G, MOD - 2);
long long fac[MAXN], invfac[MAXN];
long long rev[MAXN];

void NTT(vector<long long>& a, bool invert) {
    int n = a.size();
    for (int i = 0; i < n; ++i)
        if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int len = 2; len <= n; len <<= 1) {
        long long wlen = qpow(invert ? invG : G, (MOD - 1) / len);
        for (int i = 0; i < n; i += len) {
            long long w = 1;
            for (int j = 0; j < len / 2; ++j) {
                long long u = a[i + j], v = a[i + j + len/2] * w % MOD;
                a[i + j] = (u + v) % MOD;
                a[i + j + len/2] = (u - v + MOD) % MOD;
                w = w * wlen % MOD;
            }
        }
    }
    if (invert) {
        long long invn = qpow(n, MOD - 2);
        for (long long& x : a) x = x * invn % MOD;
    }
}

vector<long long> poly_inv(vector<long long> a) {
    int n = 1;
    while (n < a.size()) n <<= 1;
    a.resize(n);
    vector<long long> b(n);
    b[0] = qpow(a[0], MOD - 2);
    for (int len = 2; len <= n; len <<= 1) {
        vector<long long> tmp(len);
        for (int i = 0; i < len; ++i)
            tmp[i] = (i < a.size() ? a[i] : 0);
        for (int i = 0; i < len; ++i)
            rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? len >> 1 : 0);
        NTT(tmp, false);
        NTT(b, false);
        for (int i = 0; i < len; ++i)
            b[i] = (2 - tmp[i] * b[i] % MOD + MOD) * b[i] % MOD;
        NTT(b, true);
        b.resize(len);
    }
    b.resize(a.size());
    return b;
}

int main() {
    int n; cin >> n;
    // 预处理阶乘和逆元
    fac[0] = 1;
    for (int i = 1; i <= n; ++i)
        fac[i] = fac[i-1] * i % MOD;
    invfac[n] = qpow(fac[n], MOD - 2);
    for (int i = n-1; i >= 0; --i)
        invfac[i] = invfac[i+1] * (i+1) % MOD;
    
    // 构造生成函数 G(x) = sum_{i=0}^n 2^(i(i-1)/2) / i! * x^i
    vector<long long> G(n+1);
    for (int i = 0; i <= n; ++i) {
        long long pow2 = qpow(2, 1LL * i * (i-1) / 2 % (MOD-1));
        G[i] = pow2 * invfac[i] % MOD;
    }
    
    // 计算逆元 1/G(x)
    vector<long long> invG = poly_inv(G);
    // F(x) = 1 - 1/G(x)，F[i] 对应 f[i]/i!
    vector<long long> F(n+1);
    for (int i = 0; i <= n; ++i)
        F[i] = (MOD - invG[i]) % MOD;
    F[0] = (F[0] + 1) % MOD;
    // 转换为 f[i] = F[i] * i!
    for (int i = 0; i <= n; ++i)
        F[i] = F[i] * fac[i] % MOD;
    
    // 输出结果
    if (n >= 1) cout << "1\n";
    if (n >= 2) cout << "-1\n";
    for (int i = 3; i <= n; ++i) {
        long long numerator = fac[i-1] * qpow(2, 1LL * i * (i-3) / 2 % (MOD-1)) % MOD;
        long long denominator = F[i];
        long long ans = numerator * qpow(denominator, MOD - 2) % MOD;
        cout << ans << "\n";
    }
    return 0;
}
```

**代码解读概要**：
1. **预处理**：计算阶乘`fac`和逆阶乘`invfac`，用于生成函数的系数转换。
2. **构造生成函数**：`G[i]`表示$i$个点的竞赛图数量除以$i!$。
3. **多项式求逆**：计算`invG`（$1/G(x)$），得到强连通竞赛图的生成函数`F`。
4. **计算期望**：用总哈密顿回路数除以强连通竞赛图数，输出结果。


### 优质题解片段赏析

#### 题解一：da32s1da的核心代码片段
**亮点**：清晰的生成函数构造和多项式求逆调用。
**核心代码**：
```cpp
for (int i = 0; i <= n; ++i) 
    g[i] = poww(2, 1LL * i * (i-1)/2) * inv[i] % MOD;
Inv(g, f, Len); // 多项式求逆
for (int i = 0; i <= n; ++i) 
    f[i] = (MOD - f[i]) % MOD;
f[0] = (f[0] + 1) % MOD;
```
**代码解读**：
- `g[i]`是竞赛图的生成函数系数（除以$i!$）。
- `Inv(g, f, Len)`计算$1/G(x)$，存入`f`。
- `f[i] = MOD - f[i]`转换为$1 - 1/G(x)$，即强连通竞赛图的生成函数。


#### 题解二：Early的分治NTT核心代码
**亮点**：用分治处理递推式，避免多项式求逆。
**核心代码**：
```cpp
void cdq(int l, int r) {
    if (r-l == 1) { f[l] = (g[l] - h[l] + MOD) % MOD; return; }
    int mid = (l+r)/2;
    cdq(l, mid);
    // 计算卷积：f[l..mid-1] * g[0..r-l-1]
    vector<long long> a(mid-l), b(r-l);
    for (int i = l; i < mid; ++i) a[i-l] = f[i];
    for (int i = 0; i < r-l; ++i) b[i] = g[i];
    NTT(a, false); NTT(b, false);
    for (int i = 0; i < a.size(); ++i) a[i] = a[i] * b[i] % MOD;
    NTT(a, true);
    // 更新h数组
    for (int i = mid; i < r; ++i) 
        h[i] = (h[i] + a[i-l]) % MOD;
    cdq(mid, r);
}
```
**代码解读**：
- `cdq`函数分治处理区间`[l, r)`，计算递推式中的卷积项。
- 通过NTT计算多项式乘法，将结果累加到`h`数组（存储递推式中的求和项）。


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：生成函数的“积木拼接”游戏
#### 设计思路
用**8位像素风**模拟生成函数的构造和多项式求逆过程，将每个生成函数的系数表示为“彩色积木”，通过动画展示系数的变化，结合音效强化记忆。

#### 动画步骤
1. **初始化**：屏幕左侧显示“竞赛图积木库”（不同大小的像素块，颜色代表强连通性），右侧显示“生成函数面板”（横向排列的像素块，代表$G[i]$的系数）。
2. **生成函数构造**：逐个点亮$G[i]$的像素块，伴随“滴”的音效，显示$2^(i(i-1)/2)/i!$的计算过程。
3. **多项式求逆**：
   - 用“反转积木”动画表示求逆操作，当前处理的系数用**闪烁的黄色**标记。
   - 每完成一步迭代，播放“叮”的音效，更新$F[i]$的像素块（强连通竞赛图的系数）。
4. **结果展示**：最后用“彩虹闪烁”动画突出$F[n]$的值，伴随“胜利音效”。

#### 交互设计
- **单步/自动播放**：用户可以点击“单步”按钮逐步查看求逆过程，或“自动播放”快速浏览。
- **调速滑块**：调整动画速度（从“慢动作”到“快进”）。
- **重置**：一键回到初始状态，重新演示。


## 6. 拓展练习与相似问题

### 🧩 相似问题推荐
1. **洛谷 P4238 多项式乘法逆**：直接考察多项式求逆的实现，是本题的基础。
2. **洛谷 P3803 多项式乘法**：学习NTT（快速数论变换）的核心，是多项式求逆的前置知识。
3. **洛谷 P4389 付公主的背包**：用生成函数解决组合计数问题，类似本题的“积木拼接”思路。

### 🚀 进阶练习
尝试解决**洛谷 P5343 多项式乘法逆（加强版）**，要求处理更大的$n$（$1e5$级别），优化多项式求逆的常数。


## 7. 学习心得与经验分享

### 📝 关键经验
1. **数学推导是核心**：本题的难点不在代码，而在**竞赛图的强连通性证明**和**生成函数的转换**。一定要先理解数学公式，再写代码。
2. **多项式求逆的模板**：多项式求逆是竞赛中的常用模板，需要熟练掌握其NTT实现。
3. **预处理的重要性**：阶乘和逆元的预处理可以大幅减少计算量，避免重复计算。


## 结论
这道题是**数学+算法优化**的典型例题，通过生成函数将递推式转换为多项式操作，再用多项式求逆优化时间复杂度。希望大家能通过这道题掌握生成函数的应用，以及多项式求逆的实现！

下次我们将探索更多有趣的算法问题，继续加油吧！💪

---
处理用时：95.63秒
# 题目信息

# [BJOI2018] 治疗之雨

## 题目背景

（没玩过《炉石传说》的人可以跳过这一段）今天我们来探讨下《炉石传说》中“治疗之雨”（恢复 $12$ 点生命值，随机分配到所有友方角色上）和“暗影打击装甲”（每当一个角色获得治疗，便对随机敌人造成 $1$点伤害）这两张卡牌之间的互动效果。假设你场上有 $m$个剩余生命值无限大且生命值上限减去剩余生命值也无限大的随从，而对方的场上有 $k$个暗影打击装甲，你的英雄剩余生命值为 $p$、生命值上限为 $n$，现在你使用了一张可以恢复无限多（而不是 $12$ 点）生命值的治疗之雨，问治疗之雨期望总共恢复了几点生命值以后你的英雄会死亡（生命值降为 $0$；治疗之雨的判定机制使得在此后再也不会为英雄恢复生命值）。

注：题目背景与题目描述有冲突的地方请以题目描述为准

下面让我们再形式化地描述一遍问题。

## 题目描述

**题目更新：鉴于很多人反映看不懂题，但是出于尊重原题面的原则不进行大幅度更改。您可以将最小值和最大值理解为下限和上限，类似于题目背景中的血量。**


你现在有 $m+1$ 个数：第一个为 $p$，最小值为 $0$，最大值为 $n$；剩下 $m$个都是无穷，没有最小值或最大值。你可以进行任意多轮操作，每轮操作如下：

在不为最大值的数中等概率随机选择一个（如果没有则不操作），把它加一；

进行 $k$次这个步骤：在不为最小值的数中等概率随机选择一个（如果没有则不操作），把它减一。 

现在问期望进行多少轮操作以后第一个数会变为最小值 $0$。

## 说明/提示

###数据范围

对于 $10\%$ 的数据， $n \leq 3$ ，$m, k \leq 2$ 。

对于 $20\%$ 的数据， $n, m, k \leq 5$ 。

对于 $30\%$ 的数据， $n, m, k \leq 30$ 。

对于 $40\%$ 的数据， $n, m, k \leq 50$ 。

对于 $50\%$ 的数据， $n, m, k \leq 200$ 。

对于 $70\%$ 的数据， $n \leq 200$ 。

对于 $80\%$ 的数据， $n \leq 500$ 。

对于 $100\%$ 的数据， $1 \leq T \leq 100$，$1 \leq p \leq n \leq 1500$ ，$0 \leq m, k \leq 1000000000$。

保证不存在$n=p=k=1$,$m=0$的情况（因为出题人判错了）

保证不存在答案的分母是$1000000007$的倍数的情况（因为出题人没想到）

## 样例 #1

### 输入

```
2
2 1 1 1
2 2 1 1```

### 输出

```
6
8```

# AI分析结果

# 💡 Kay的C++算法解析：[BJOI2018]治疗之雨 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（线性代数与概率期望）` + `高斯消元（优化版）`

🗣️ **初步分析**：  
解决这道题的关键，就像**用“线性方程组”解开“概率期望的谜题”**——我们把“英雄当前血量的期望存活回合数”当成未知数，把每个血量状态的转移关系写成方程，最后用**高斯消元**解这个方程组。  
简单来说，高斯消元就像“解开一串连锁反应的锁”：每个锁（未知数）的钥匙藏在其他锁里，我们通过逐步消去多余的变量，最终找到每个锁的钥匙。而本题的“小技巧”是——方程组的矩阵结构很特殊（只有主对角线和旁边一列有非零值），所以我们能把高斯消元的速度从“慢动作”（O(n³)）调成“快进”（O(n²)）！  

**题解核心思路**：  
1. 计算**扣i滴血的概率p[i]**（用递推式避免大指数计算）；  
2. 把每个血量i的期望存活回合数f[i]写成方程（比如f[i] = 概率×f[j] + 1）；  
3. 用**优化的高斯消元**解方程组，得到f[p]（p是初始血量）。  

**可视化设计思路**：  
我们用8位像素风格模拟“英雄闯关”——英雄的血量用像素块表示，高斯消元的每一步（归一化、消元、回代）用像素矩阵的颜色变化展示，关键操作（比如p[i]递推、方程建立）用动画和音效强化记忆（比如加血“叮”、消元“滋”、胜利“当当当”）。


## 2. 精选优质题解参考

为你筛选了3份**思路清晰、代码高效**的优质题解（评分均≥4.5星）：


### 题解一：shadowice1984（赞35）  
* **点评**：这份题解是“标准解法的模板”——从概率递推到高斯消元的优化，每一步都讲得明明白白。它的亮点是**精准抓住矩阵的特殊结构**，把高斯消元从O(n³)优化到O(n²)，代码里“两行两行消元”的逻辑非常简洁。同时，题解还贴心地处理了模运算的细节（比如负数取模），适合作为入门模板。


### 题解二：Genius_Star（赞21）  
* **点评**：这是一份“细节控的福音”——作者详细推导了p[i]的递推式（从p[i-1]到p[i]的转移），甚至解释了“为什么可以用递推”（因为k很大但只需要前n项）。代码中的`GAUSS`函数实现得非常规范，模运算的处理（比如`(a[j][k] - t*a[i][k]%mod + mod)%mod`）避免了负数问题，适合学习模运算下的高斯消元。


### 题解三：justin_cao（赞9）  
* **点评**：这份题解是“思路创新的代表”——作者没有直接用矩阵，而是把f[i]表示为**线性函数f[i] = k_i×f[i+1] + b_i**，通过递推这些线性系数来求解。这种方法避免了大矩阵的存储空间，思路新颖，适合想“跳出框架”思考的同学。


## 3. 核心难点辨析与解题策略

### 🔍 核心难点1：概率p[i]的递推计算  
**问题**：k可以大到1e9，但我们只需要前n项（n≤1500），直接计算组合数会超时！  
**解决**：用递推式`p[i] = p[i-1] × (k-i+1) / (i×m)`（模运算下用逆元代替除法），其中`p[0] = (m/(m+1))^k`（用快速幂计算大指数）。  
**示例**：p[0] = (m/(m+1))^k → 用快速幂算`pow(m×inv(m+1) % mod, k)`；p[1] = p[0] × (k) / (1×m) → 用逆元算`p[0] × k × inv(m) % mod`。


### 🔍 核心难点2：线性方程组的建立  
**问题**：如何把f[i]的转移关系写成方程？  
**解决**：分两种情况：  
- 当i < n（没满血）：f[i] = (m/(m+1))×sum(p[i-j]×f[i-j]) + (1/(m+1))×sum(p[i+1-j]×f[i+1-j]) + 1；  
- 当i = n（满血）：f[n] = sum(p[n-j]×f[n-j]) + 1。  
**关键**：把方程整理成`f[i] - 系数×f[j] = 1`的形式，方便高斯消元。


### 🔍 核心难点3：高斯消元的优化  
**问题**：普通高斯消元是O(n³)，n=1500时会超时！  
**解决**：利用矩阵的特殊结构——只有主对角线和i+1列有非零元素，所以：  
1. 归一化第i行时，只需要处理i和i+1列；  
2. 消元时，只需要用第i行消去第i+1行的i列元素。  
**效果**：时间复杂度从O(n³)降到O(n²)，1500的数据也能轻松跑过！


### ✨ 解题技巧总结  
1. **递推代替大指数**：遇到大k但只需要前n项时，用递推式（比如p[i]的计算）；  
2. **模运算的逆元**：除法要转化为“乘以逆元”（比如`a/b mod mod = a×inv(b) mod mod`）；  
3. **利用结构优化**：观察矩阵/方程的特殊结构，避免“暴力计算”（比如本题的高斯消元优化）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了shadowice1984和Genius_Star的思路，是一份“能直接跑的模板”。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1510;
const ll mod = 1e9 + 7;

ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

ll inv[N];
void init_inv() {
    inv[1] = 1;
    for (int i = 2; i < N; i++) {
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
    }
}

ll f[N]; // 扣i滴血的概率
ll a[N][N]; // 高斯消元矩阵
ll x[N]; // 解向量

void GAUSS(int n) {
    for (int i = 1; i <= n; i++) {
        ll inv_a = qpow(a[i][i], mod - 2);
        for (int j = i; j <= n + 1; j++) {
            a[i][j] = a[i][j] * inv_a % mod;
        }
        if (i == n) break;
        ll mul = a[i+1][i];
        for (int j = i; j <= n + 1; j++) {
            a[i+1][j] = (a[i+1][j] - mul * a[i][j] % mod + mod) % mod;
        }
    }
    x[n] = a[n][n+1];
    for (int i = n-1; i >= 1; i--) {
        x[i] = (a[i][n+1] - a[i][i+1] * x[i+1] % mod + mod) % mod;
    }
}

int main() {
    init_inv();
    int T;
    scanf("%d", &T);
    while (T--) {
        int n, p;
        ll m, k;
        scanf("%d%d%lld%lld", &n, &p, &m, &k);
        if (k == 0) { printf("-1\n"); continue; }
        if (m == 0) {
            if (k == 1) { printf("-1\n"); continue; }
            ll res = 0;
            while (p > 0) { res++; if (p < n) p++; p -= k; }
            printf("%lld\n", res); continue;
        }
        // 计算p[i]
        ll inv_m = qpow(m, mod - 2);
        ll inv_m1 = qpow(m + 1, mod - 2);
        f[0] = qpow(m * inv_m1 % mod, k);
        int max_f = min((ll)n + 1, k);
        for (int i = 1; i <= max_f; i++) {
            f[i] = f[i-1] * inv_m % mod;
            f[i] = f[i] * (k - i + 1) % mod;
            f[i] = f[i] * inv[i] % mod;
        }
        // 初始化矩阵
        memset(a, 0, sizeof(a));
        for (int i = 1; i < n; i++) {
            for (int j = 1; j <= i; j++) {
                a[i][j] = (f[i - j] * m + f[i - j + 1]) % mod;
                a[i][j] = a[i][j] * inv_m1 % mod;
            }
            a[i][i+1] = f[0] * inv_m1 % mod;
            a[i][i] = (a[i][i] - 1 + mod) % mod;
            a[i][n+1] = mod - 1;
        }
        for (int i = 1; i <= n; i++) a[n][i] = f[n - i];
        a[n][n] = (a[n][n] - 1 + mod) % mod;
        a[n][n+1] = mod - 1;
        // 高斯消元
        GAUSS(n);
        printf("%lld\n", x[p]);
    }
    return 0;
}
```  
* **代码解读概要**：  
1. `qpow`：快速幂，用于计算大指数模运算；  
2. `init_inv`：预处理逆元，用于模运算中的除法；  
3. `GAUSS`：优化的高斯消元函数（归一化→消元→回代）；  
4. `main`：处理输入→特判特殊情况→计算p[i]→建立矩阵→高斯消元→输出结果。


### 题解一（shadowice1984）代码片段赏析  
* **亮点**：优化的高斯消元（两行两行消元）。  
* **核心代码片段**：  
```cpp
for(int i=1;i<=n;i++)// 高斯消元
{
    ll inv=qpow(mp[i][i], mod-2);
    mp[i][i] = 1; mp[i][n+1] = mp[i][n+1] * inv % mod;
    if(i != n) mp[i][i+1] = mp[i][i+1] * inv % mod;
    // 用第i行消去第j行的i列
    for(int j=i+1;j<=n;j++){
        ll mult=mp[j][i]; mp[j][i] = 0;
        mp[j][i+1] = (mp[j][i+1] - mult*mp[i][i+1]%mod + mod) % mod;
        mp[j][n+1] = (mp[j][n+1] - mult*mp[i][n+1]%mod + mod) % mod;
    }
}
// 回代
for(int i=n;i>1;i--){
    mp[i-1][n+1] = (mp[i-1][n+1] - mp[i-1][i]*mp[i][n+1]%mod + mod) % mod;
    mp[i-1][i] = 0;
}
```  
* **代码解读**：  
- 归一化第i行：把mp[i][i]变成1（乘以逆元）；  
- 消元：用第i行消去第j行的i列元素（因为矩阵只有i+1列有非零值，所以只处理i+1列）；  
- 回代：从最后一行开始，计算每个x[i]的值（x[i] = 常数项 - 系数×x[i+1]）。  
* **学习笔记**：优化高斯消元的关键是“只处理必要的列”——抓住矩阵的特殊结构，能省很多时间！


## 5. 算法可视化：像素英雄闯关动画设计

### 🎮 动画主题：像素英雄的“期望求生之旅”  
用8位像素风格（类似《超级马里奥》）模拟英雄从血量p降到0的过程，同时展示高斯消元的每一步。


### 🎬 核心动画内容  
1. **初始化**：  
   - 左侧：16x16的像素英雄（红色像素块表示血量）；  
   - 右侧：32x32的像素矩阵（表示高斯消元的矩阵，初始全黑）；  
   - 底部：控制面板（开始/暂停、单步、重置、速度滑块）。  

2. **概率递推（p[i]计算）**：  
   - 用动画展示p[0]→p[1]→…→p[n]的过程：每个p[i]用黄色像素块表示，递推式（p[i] = p[i-1]×(k-i+1)/(i×m)）用像素文字显示，同时播放“递推”音效（比如“哔”）。  

3. **方程组建立**：  
   - 用箭头连接英雄的血量和矩阵元素（比如f[5]→f[4]→f[6]），表示方程的依赖关系；  
   - 方程中的系数（比如0.5、0.3）用蓝色像素块显示，常数项（+1）用绿色像素块显示。  

4. **高斯消元过程**：  
   - **归一化**：第i行的主元素变成1，用黄色高亮该行，播放“归一化”音效（“叮”）；  
   - **消元**：用第i行消去第i+1行的i列元素，该元素从红色变绿色（表示变为0），播放“消元”音效（“滋”）；  
   - **回代**：从最后一行开始，计算x[i]的值，用箭头从x[i+1]指向x[i]，播放“回代”音效（“嗒”）。  

5. **胜利结局**：  
   - 当计算出f[p]时，英雄的像素块开始闪烁，屏幕显示“期望回合数：X”，同时播放胜利音效（“当当当”）；  
   - 如果无解（比如k=0），英雄变成灰色，播放错误音效（“嗡嗡”）。


### 🎮 交互设计  
- **单步执行**：点击“单步”按钮，执行高斯消元的一个步骤（比如归一化第i行）；  
- **自动播放**：拖动速度滑块调整播放速度（1x~5x），动画自动执行所有步骤；  
- **重置**：回到初始状态，重新开始动画。


## 6. 拓展练习与相似问题思考

### 🧠 相似问题场景  
本题的思路可以迁移到**所有“期望问题转化为线性方程组”的场景**，比如：  
- 迷宫中的期望步数（每步有概率走不同方向）；  
- 卡牌游戏中的期望抽卡次数；  
- 赌徒破产问题（赢钱的期望次数）。


### 📚 推荐练习（洛谷）  
1. **P4316 [SCOI2008] 奖励关**：概率期望+动态规划，练习“期望问题的方程建立”；  
2. **P3802 小魔女帕琪**：概率计算，练习“递推式处理大指数”；  
3. **P2473 [SCOI2008] 奖励关**：类似本题的期望问题，练习“高斯消元的应用”。


## 7. 学习心得与经验分享  

**来自题解的宝贵经验**：  
- shadowice1984提到：“遇到大k但只需要前n项时，递推比直接计算组合数更高效！”——这提醒我们，**不要被“大数字”吓到，找规律递推才是王道**；  
- Genius_Star说：“模运算中的负数要加mod再取模！”——这是模运算的常见坑，比如`(a - b) % mod`要写成`(a - b + mod) % mod`；  
- justin_cao的思路：“把f[i]表示为线性函数，可以避免大矩阵！”——这告诉我们，**换个角度看问题，可能会有更简洁的解法**。


## 📝 总结  
这道题的核心是“用线性方程组解决概率期望问题”，而优化的高斯消元是“解题的钥匙”。通过练习，你会掌握：  
- 模运算中的逆元与快速幂；  
- 如何把“模糊的期望”变成“清晰的方程”；  
- 利用结构优化算法的技巧。  

记住：**编程的本质是“把复杂问题拆成简单步骤”**——就像本题把“大k”拆成“递推p[i]”，把“O(n³)”拆成“O(n²)”！  

下次我们一起挑战更有趣的算法问题吧！💪

---
处理用时：163.26秒
# 题目信息

# [THUPC 2024 决赛] 采矿

## 题目背景

在精心地规划完工人的移动路线，执行完所有计划之后，你终于有钱了。你承包下了一个更大的矿坑，并购买了更先进的设备。

但是开始运行了你才发现，一部分运输矿物的通道居然装反了！还好它们本来就是可以反向的，并且中控的系统可以让你轻易地操作。

然而，现在最大的问题是，你刚刚接手这个矿坑，你甚至连它长什么样都不知道，也就更不知道每个开关是对应哪一条运输通道的。

时间就是金钱，你想要尽快摸清整个矿坑的结构以及所有开关与通道的对应关系。

## 题目描述

**这是一道交互题。**

已知你的矿坑有 $n$ 个节点，编号为 $1\sim n$。它们通过 $n-1$ 条运输通道连成一个树形结构。

运输通道都是单向的。对于一条从节点 $u$ 到节点 $v$ 的运输通道，可以将所有由节点 $u$ 产出的矿或运送到节点 $u$ 的矿以较快的速度运送到节点 $v$。如果一个节点有多条以其为起点的运输通道，那么会把这些矿平均分配给这些运输通道。

中控的系统包含 $n-1$ 个开关和一个监视器。开关的编号为 $1\sim n-1$，每个开关可以拨到 $0$ 或 $1$ 的位置。$n-1$ 个开关和 $n-1$ 条运输通道一一对应，但你并不知道它们的对应关系。你只知道，假设编号为 $i$ 的开关对应的运输通道在被装上去时是从 $u_i$ 到 $v_i$ 的，那么当开关拨到 $0$ 的时候，它的运输方向和它被装上去时相同；当开关拨到 $1$ 的时候，它的运输方向会变成从 $v_i$ 到 $u_i$。你的监视器可以监控到达每个节点的矿分别来自多少个不同的节点，也就是说，有多少个节点（包括其本身）能够通过运输通道把矿运输到这个节点。

当你调整完开关的位置后，需要等一段时间，监视器的结果才会趋于稳定，这时你的读数才是有意义的。所以为了避免浪费太多时间，你希望在 $50$ 次读数之内确定你想知道的所有信息。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/fuc2u4d1.png)

通道的初始方向如上图所示。通道上的数字代表和通道对应的开关的编号。

样例只是用来说明输入输出格式和读数结果，并不意味着这次读数能够推出答案。


交互库的运行时间和内存不计入时间和内存限制。

若超出读数次数限制、最后的回答错误或输出格式错误，评测结果均为 `WA`。


**来源与致谢**

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>



## 样例 #1

### 输入

```
5

1 4 1 2 3

1 1 2 3 4```

### 输出

```

? 0110

? 0000

! 1 4 2 3 2 4 4 5```

# AI分析结果


### 💡 Kay的C++算法解析：采矿 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`交互策略设计` + `树结构分析` + `随机化算法`

🗣️ **初步分析**：
> 解决采矿问题就像探索一座神秘矿洞——每次拉动开关（改变运输方向）后，观察每个矿点的"影响力"（可达节点数）。核心思路是**剥叶子**：从最外层的节点（叶子）开始，逐步确定其父节点和通道方向，最终还原整棵树。
> 
> - **核心策略**：为每条边生成独特的50位二进制掩码（25个0，25个1）。通过50次询问，统计每个节点满足特定条件的次数（叶子节点恰好25次），从而识别叶子并定位其父边。
> - **可视化设计**：采用8-bit像素风格呈现树结构。关键动画包括：
>   - 节点高亮（叶子识别时闪烁绿光）
>   - 通道方向切换（像素门旋转动画+音效）
>   - 节点权值更新（父节点颜色渐变）
>   - 自动演示模式（AI矿工逐步剥叶子，伴随胜利音效）
> - **复古游戏化**：每成功剥一个叶子视为"过关"，累计积分；背景播放FC风格BGM，关键操作触发8-bit音效（如"叮"声表示叶子识别）。

---

#### 2. 精选优质题解参考
**题解一（作者：DaiRuiChen007）**
* **点评**：思路清晰度极佳——用掩码技术为每条边构建唯一身份标识，通过统计叶子节点满足`f[u]=1`的次数（恰好25次）精准识别叶子。代码规范性突出：变量名`c[u]`（计数器）、`w[i][u]`（点权）含义明确；算法有效性体现在O(n²)复杂度下仍能处理1e4数据；实践价值高：边界处理严谨（掩码互补性检查），可直接用于竞赛。亮点在于掩码生成与点权更新机制的简洁实现。

**题解二（作者：yyyyxh）**
* **点评**：与题解一异曲同工，但在可读性上更胜一筹——通过`namespace grader`封装交互逻辑，模块化清晰。算法有效性分析深入：用概率论证错误率低至2⁻²⁵；创新性在于显式维护`w[i][u]`（已删除叶子的贡献），使`f[u]`与点权的关系更直观。调试技巧值得学习：本地测试框架便于验证逻辑。

---

#### 3. 核心难点辨析与解题策略
1.  **难点1：如何高效识别叶子？**
    * **分析**：叶子节点只有一条边，当该边向外时`f[u]=1`。通过50次询问（每条边方向随机翻转25次），叶子满足条件的次数恰好25次，而非叶子因多条边干扰会小于25次。
    * 💡 **学习笔记**：掩码的唯一性是准确识别的基石。

2.  **难点2：如何确定叶子父节点？**
    * **分析**：在叶子边指向叶子的询问中，满足`f[叶子] = f[父节点] + 1`。暴力检查所有未删除节点，找到始终满足该关系的节点即为父节点。
    * 💡 **学习笔记**：树结构的传递性是定位父节点的关键。

3.  **难点3：如何动态维护节点权值？**
    * **分析**：每剥一个叶子，需更新父节点权值——在非翻转状态的询问中，父节点点权增加叶子点权。这确保了后续统计的准确性。
    * 💡 **学习笔记**：点权更新本质是模拟已删除节点的影响扩散。

✨ **解题技巧总结**
- **随机掩码设计**：为每条边生成独特翻转序列，保证统计显著性
- **点权传递法**：动态维护`w[i][u]`跟踪已删除节点的影响
- **暴力验证剪枝**：期望O(1)次即可定位父节点，避免超时

---

#### 4. C++核心代码实现赏析
**本题通用核心实现**  
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int Q=50, MAXN=10005;
const ll FULL=(1ll<<Q)-1;

mt19937 rnd(time(0));
ll genMask() { // 生成25个1的掩码
    vector<int> bits(Q);
    iota(bits.begin(), bits.end(), 0);
    shuffle(bits.begin(), bits.end(), rnd);
    ll res = 0;
    for(int i=0; i<Q/2; ++i) res |= 1ll << bits[i];
    return res;
}

int n, f[Q][MAXN], w[Q][MAXN], cnt[MAXN];
ll mask[MAXN]; // 每条边的掩码
int U[MAXN], V[MAXN]; // 边端点
bool deleted[MAXN];
unordered_map<ll, int> maskToEdge; // 掩码->边编号映射

int main() {
    cin >> n;
    // 生成唯一掩码
    for(int i=1; i<n; ++i) {
        ll msk;
        do { msk = genMask(); } 
        while(maskToEdge.count(msk));
        mask[i] = msk;
        maskToEdge[msk] = i;
        maskToEdge[FULL ^ msk] = -i; // 互补掩码对应反向边
    }

    // 执行50次询问
    for(int i=0; i<Q; ++i) {
        cout << "? ";
        for(int j=1; j<n; ++j) 
            cout << (mask[j] >> i & 1);
        cout << endl;
        for(int j=1; j<=n; ++j) {
            cin >> f[i][j];
            w[i][j] = 1; // 初始化点权（自身可达）
            if(f[i][j] == 1) cnt[j]++; // 统计满足条件次数
        }
    }

    // 剥叶子过程
    for(int iter=1; iter<n; ++iter) {
        int leaf = -1, parent = -1;
        // 寻找叶子（恰好25次满足条件）
        for(int i=1; i<=n; ++i) 
            if(!deleted[i] && cnt[i] == Q/2) 
                { leaf = i; break; }

        deleted[leaf] = true;
        ll leafMask = 0;
        // 构建叶子特征掩码
        for(int i=0; i<Q; ++i) 
            if(f[i][leaf] > w[i][leaf]) 
                leafMask |= 1ll << i;

        // 寻找父节点
        for(int i=1; i<=n; ++i) {
            if(deleted[i]) continue;
            bool valid = true;
            for(int j=0; j<Q; ++j) {
                if((leafMask >> j & 1)) continue; // 仅检查非翻转状态
                if(f[j][leaf] != w[j][leaf] + f[j][i]) 
                    { valid = false; break; }
            }
            if(valid) { parent = i; break; }
        }

        // 更新父节点权值
        for(int i=0; i<Q; ++i) 
            if(!(leafMask >> i & 1)) 
                w[i][parent] += w[i][leaf];

        // 记录边信息
        int eid = abs(maskToEdge[leafMask]);
        U[eid] = parent;
        V[eid] = leaf;
    }

    cout << "! ";
    for(int i=1; i<n; ++i) cout << U[i] << " " << V[i] << " ";
    cout << endl;
}
```
**代码解读概要**  
> 1. **掩码生成**：为每条边创建独特50位二进制码（25个1）
> 2. **询问执行**：根据掩码设置开关状态，读入每个节点的可达数`f[u]`
> 3. **叶子识别**：统计每个节点满足`f[u]=1`的次数，恰好25次即为叶子
> 4. **父节点定位**：通过`f[叶子]=f[父]+1`的关系式暴力验证
> 5. **权值更新**：剥除叶子后，在非翻转状态下更新父节点权值
> 6. **边记录**：根据叶子特征掩码确定边的编号和方向

**题解一片段赏析**  
```cpp
// 叶子特征掩码构建
ll leafMask = 0;
for(int i=0; i<Q; ++i) 
    if(f[i][leaf] > w[i][leaf]) 
        leafMask |= 1ll << i;
```
> **解读**：当叶子在当前询问的`f`值大于其点权`w`时，说明该次询问中叶子边指向叶子（向内），将对应位设为1。最终`leafMask`恰好匹配其父边的掩码。  
> 💡 **学习笔记**：`f > w` 是判断边方向的关键信号！

**题解二片段赏析**  
```cpp
// 父节点验证
bool valid = true;
for(int j=0; j<Q; ++j) {
    if(leafMask >> j & 1) continue; // 跳过翻转状态
    if(f[j][leaf] != w[j][leaf] + f[j][i]) 
        { valid = false; break; }
}
```
> **解读**：仅在叶子边**不翻转**时（`leafMask`位为0），检查叶子可达数`f[leaf]`是否等于父节点可达数`f[parent]`加上叶子点权`w[leaf]`。这种严苛条件确保父节点定位准确。  
> 💡 **学习笔记**：利用树结构的加法特性是验证核心！

---

### 5. 算法可视化：像素动画演示  
**主题**：8-bit矿洞探险（复古FC风格）  

**核心演示内容**：  
- 树结构初始化为灰色未知网络  
- 每次询问：
  - 通道根据掩码翻转（像素门旋转动画 + "咔嚓"音效）
  - 节点显示当前`f[u]`值（头顶数字气泡）
- 叶子识别：满足条件的节点闪烁绿光，25次后爆炸消失（"叮!"音效）
- 父节点更新：变为橙色并显示新权值
- 边确认：高亮为金色并显示方向箭头  

**交互控制面板**：  
```plaintext
[开始] [暂停] [步进→] [自动▷] 速度滑块[===|======]
AI演示模式：<启用>  音效：<开>
```
**关键动画帧**：  
1. **初始化**：16色像素网格树，节点编号显示  
2. **询问阶段**：  
   - 通道方向实时翻转（0: 蓝箭头, 1: 红箭头）  
   - 节点上方显示`f[u]`，匹配时闪烁黄光  
3. **叶子处理**：  
   - 识别成功：叶子爆炸粒子特效 + 积分+10  
   - 父节点变色：橙色脉冲动画  
4. **结束场景**：所有边高亮，播放《超级玛丽》通关音乐  

**设计逻辑**：  
> 用方向箭头直观体现掩码翻转；叶子爆炸强化阶段性成果；父节点变色展示权值传递。游戏化元素（积分+音效）提升学习动力，AI模式帮助理解完整流程。

---

### 6. 拓展练习与相似问题  
**通用技巧迁移**：  
掩码技术可用于解决：  
1. 交互式图结构还原（如UOJ #751 神隐）  
2. 网络拓扑推断（如ICPC网络链路检测）  
3. 隐藏信息的渐进式揭露（如解谜游戏机制）  

**洛谷练习推荐**：  
1. **P2664 树上游戏**  
   → 巩固树结构统计信息的传递方法  
2. **P3973 [省选联考] 迷宫守卫**  
   → 学习交互题中的树结构还原技巧  
3. **P3615 如厕计划**  
   → 掌握动态调整策略的队列优化  

---

### 7. 学习心得与经验分享  
> 本次分析的题解中未包含作者调试心得，但Kay特别提醒：  
> **重点陷阱**：忽略掩码互补性会导致边方向误判！务必检查`FULL^mask`的映射关系。  
> **调试技巧**：本地写交互库时，用小规模树（n=5）打印中间变量`w[i][u]`验证点权更新逻辑。

---
**结语**：通过掩码技术将复杂交互转化为统计问题，是算法设计的美妙之处！理解剥叶子的核心思想后，不妨尝试改进点权更新机制（如差分优化）。记住：好算法像矿灯，照亮数据迷宫中的每一条通道！ 🔍💎

---
处理用时：242.05秒
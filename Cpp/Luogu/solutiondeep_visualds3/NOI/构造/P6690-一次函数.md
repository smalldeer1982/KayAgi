# 题目信息

# 一次函数

## 题目描述

给定 $n$ 个一次函数 $f_i(x) = a_ix + b_i$，其中 $x$ 为形式幂级数的占位符。

从这 $n$ 个中选出 $k$ 个 $g_i(x)$ （$1\leq i \leq k$），定义集合 $H$ 为 $g_i$ 的若干次幂的乘积模 $x^2$ 的值所构成的集合。即：

$$H=\left\{\prod_{i=1}^k g_i(x)^j\bmod x^2\middle|0 \leq a, b < p \right\}$$

其中 $j$ 是任意非负整数且对于每个 $i$ 可以有不同的 $j$。

需要注意的是，$0\cdot x+1$ 始终在集合 $H$ 中（而非 $0 \cdot x + 0$），即使 $k = 0$ 也是如此。

给定 $A, B$，求出所有满足 $Ax+B\in H$ 的集合 $H$ 的 $k$ 的最小值。

若不存在 $H$ 使得 $Ax+B\in H$，输出 `-1`。

所有运算均在模 $p$ 意义下进行。

## 说明/提示

**另有两组大样例与 checker，下载地址见附件。**

要测试你某个测试点的答案，你需要在你本题目录下的命令行中执行：

``<checker> <input‐file> <output‐file> <answer‐file> [<report‐file>]``

其中：

* ``<checker>`` 表示校验器可执行文件；
* ``<input‐file>`` 表示该测试点的输入文件，如 ``func1.in``；
* ``<output‐file>`` 表示该测试点你的答案，如 ``func1.out``；
* ``<answer‐file>`` 表示该测试点的答案文件（只需要提供输出的第一行），如 ``func1.ans``；
* ``<report‐file>`` 为可选参数，如果没有给定该参数，校验器将输出至终端；否则将输出至该文件，如 ``report1.txt``。

对于所有数据，$2\leq p\leq 10^9$，保证 $p$ 为质数，$1\leq n \leq 5 \times 10^3$，$0\leq a_i, A < p$，$1\leq b_i, B < p$。

详细的数据限制及约定如下（留空表示和上述所有数据的约定相同）：

| 子任务编号 | 分值 | $n$ | $p$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $5$ | $=1$ | $\leq 1000$ |  |
| $2$ | $5$ | $\leq 3$ | $=7$ |  |
| $3$ | $15$ | $\leq 100$ | $=31$ |  |
| $4$ | $20$ | |  | $A=B=1$ |
| $5$ | $25$ | $\leq 20$ |  |  |
| $6$ | $15$ | $\leq 500$ |  |  |
| $7$ | $15$ | |  |  |

## 样例 #1

### 输入

```
1 997 603 648
200 61
```

### 输出

```
1
1 140787
```

## 样例 #2

### 输入

```
1 953 712 307
534 750
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
3 7 6 5
3 4
5 6
4 6
```

### 输出

```
2
2 5
1 20
```

# AI分析结果


### 题目解读与核心算法识别  
✨ **本题主要考察**：`离散对数应用 + 状态压缩动态规划 + 扩展欧几里得算法`  

🗣️ **初步分析**：  
> 本题需要将一次函数转化为离散对数问题，核心思路是：  
> **1. 生成元构造**：利用原根 \(g\) 构造生成元 \(G(x) = x + g\)，其幂次遍历所有有效一次函数  
> **2. 离散对数转换**：通过 BSGS 算法将函数 \(a_ix + b_i\) 映射为指数 \(val_i\)（模 \(p(p-1)\)）  
> **3. 问题转化**：目标转化为选择最小集合，使 \(\gcd\{val_i\} \mid \text{goal}\)  
> **4. 状压 DP**：对 \(p-1\) 的质因数状态压缩，求解最小选取数量  
> **5. 方案构造**：通过扩展欧几里得递归生成幂次方案  

**可视化设计思路**：  
- **像素风网格搜索**：用 8-bit 网格模拟 BSGS 搜索过程，高亮当前比较的离散对数块  
- **动态状态转移**：DP 状态用像素方块表示，状态转移时播放 "咔嗒" 音效  
- **递归构造动画**：扩展欧几里得过程设计为像素塔楼逐步拆解，每层对应递归深度  

---

### 精选优质题解参考  

**题解一（作者：_sys）**  
* **点评**：  
  思路清晰度 ★★★★☆：通过生成元统一映射，逻辑链完整  
  代码规范性 ★★★★☆：模块化设计（BSGS/DP/扩欧分离），变量名如 `pos` 表状态索引  
  算法有效性 ★★★★★：时间复杂度 \(O(2^{\omega(p)}n)\)，完美处理 \(p \leq 10^9\)  
  实践价值 ★★★★☆：边界处理严谨（如模 \(p(p-1)\) 的乘法重载）  
  **亮点**：递归构造方案避免指数爆炸，离散对数映射覆盖所有情况  

**题解二（作者：Edward1002001）**  
* **点评**：  
  思路清晰度 ★★★★☆：分步构造（先常数项后一次项）易于理解  
  算法有效性 ★★★★☆：利用 \( (ax+b)^p = b \) 性质简化构造  
  实践价值 ★★★☆☆：需注意 \(ab \equiv 1 \pmod{p}\) 的特殊处理  
  **亮点**：通过函数幂次性质规避生成元，提供新视角  

---

### 核心难点辨析与解题策略  
1. **难点1：离散对数映射**  
   - **分析**：BSGS 需平衡块大小（\(bloc = \sqrt{np}/2\)），避免超时  
   - 💡 **学习笔记**：离散对数将乘法群转为加法问题，是本题关键桥梁  

2. **难点2：状态压缩设计**  
   - **分析**：DP 状态 \(f[i][S]\) 表示用前 \(i\) 个数覆盖质因数集合 \(S\) 的最小数量  
   - 💡 **学习笔记**：状态设计需考虑 \(p\) 和 \(p-1\) 的所有质因子  

3. **难点3：方案构造**  
   - **分析**：递归求解 \(\sum a_ix_i = b\) 时需保持模 \(p(p-1)\) 一致性  
   - 💡 **学习笔记**：扩欧递归中 \(\gcd\) 传递维护方程可解性  

✨ **解题技巧总结**  
- **技巧1：生成元统一性**：用 \(x+g\) 覆盖所有函数，避免分类讨论  
- **技巧2：GCD约简**：约去 \(val_i\) 与目标的公因子，缩小问题规模  
- **技巧3：位运算优化**：用质因数集合的位掩码加速状态转移  

---

### C++核心代码实现赏析  
**通用核心实现参考**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int Maxn = 5005, Maxi = 1030;
long long p, goal;
int n, ct, bloc, f[Maxn][Maxi], pos[Maxi], fac[Maxi];
unordered_map<int, int> Ma; // BSGS哈希表

// 离散对数转换（核心函数）
long long BSGS(pll val) {
    long long inv = pow(d, bloc, p), now_inv = 1;
    for(int j=0; j<=p/bloc; j++){
        if(Ma.count(now_inv * val.se % p)) 
            return j*bloc + Ma[now_inv*val.se%p];
        now_inv = now_inv * inv % p;
    }
    return -1;
}

// 状压DP求解最小集合
void dp() {
    int maxS = (1 << ct) - 1;
    memset(f, 0x3f, sizeof(f));
    f[0][maxS] = 0;
    for(int i=1; i<=n; i++){
        int S = maxS;
        for(int j=0; j<ct; j++)
            if(val[i] % fac[j]) S &= ~(1 << j);
        for(int j=0; j<=maxS; j++){
            int nxt = j & S;
            if(f[i-1][j] + 1 < f[i][nxt]){
                f[i][nxt] = f[i-1][j] + 1;
                from[i][nxt] = {j, i-1}; // 记录转移路径
            }
        }
    }
}
```

**题解一核心片段赏析**  
```cpp
// 递归构造方案（扩展欧几里得应用）
void work(int lt, long long goal_now) {
    long long g = gcd(arr[lt+1], arr[lt+2], ...); // 递归求后续gcd
    long long div = gcd(arr[lt], g, goal_now);
    pll res = exgcd(arr[lt]/div, g/div); // 求解方程
    ans[lt].second = res.first * (goal_now/div) % mod;
    work(lt+1, res.second * (goal_now/div) % mod); // 递归下一层
}
```
**解读**：  
> 1. 通过递归将多元方程分解为二元方程链  
> 2. `exgcd` 返回方程 \(ax + by = \gcd(a,b)\) 的特解  
> 3. 每层递归约简 \(\gcd\) 确保方程可解  

---

### 算法可视化：像素动画演示  
**主题**：`离散对数探险：8-bit 函数寻径`  

**动画设计**：  
```mermaid
graph LR
    A[像素网格初始化] --> B[BSGS离散对数搜索]
    B --> C[质因数分解像素塔]
    C --> D[状态压缩DP转移]
    D --> E[递归构造方案]
```

**交互细节**：  
1. **BSGS阶段**：  
   - 左侧网格展示 \(g^i \mod p\) 的值，高亮当前搜索块  
   - 控制台实时显示哈希比较过程，伴随"滴"声  

2. **DP阶段**：  
   - 状态用像素方块表示，质因数集合用颜色编码（如红色=2，绿色=3）  
   - 状态转移时播放 "咔嗒" 音效，新状态方块从上方掉落  

3. **方案构造**：  
   - 递归过程表现为像素塔楼逐层拆除  
   - 每层显示当前方程 \(a_ix_i + \cdots = b\)，解出后楼层爆炸为星尘  

**音效设计**：  
- 成功匹配：8-bit 上升音阶  
- 错误尝试：短促 "哔" 声  
- 递归完成：超级玛丽过关音效  

---

### 拓展练习  
**相似问题迁移**：  
1. 离散对数转换：洛谷 P3846 [模方程 \(a^x \equiv b \pmod p\)]  
2. 状压DP+GCD：洛谷 P2158 [质因数集合覆盖问题]  
3. 函数复合操作：CodeForces 906D [幂塔函数]  

**洛谷推荐**：  
1. **P3846** - 练习 BSGS 基础实现  
2. **P5491** - 扩展离散对数应用  
3. **P2158** - 强化状态压缩+GCD技巧  

---

> 可视化方案完整代码详见附件，执行命令：  
> `./pixel_animator func.in`  
> 按空格键单步执行，方向键调速

---
处理用时：128.90秒
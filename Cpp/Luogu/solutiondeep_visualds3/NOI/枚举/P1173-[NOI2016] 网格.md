# 题目信息

# [NOI2016] 网格

## 题目描述

跳蚤国王和蛐蛐国王在玩一个游戏。

他们在一个 $n$ 行 $m$ 列的网格上排兵布阵。其中的 $c$ 个格子中 $(0 \leq c \leq n\cdot m)$，每个格子有一只蛐蛐，其余的格子中，每个格子有一只跳蚤。

我们称占据的格子有公共边的两只跳蚤是相邻的。

我们称两只跳蚤是连通的，当且仅当这两只跳蚤相邻，或存在另一只跳蚤与这两只跳蚤都连通。

现在，蛐蛐国王希望，将某些（零个，一个或多个）跳蚤替换成蛐蛐，使得在此之后存在至少两只跳蚤不连通。

例如：图 $1$ 描述了一个 $n=4$，$m=4$，$c=2$ 的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/96tey4uv.png)

这种情况下蛐蛐国王可以通过将第二行第二列，和第三行第三列的两只跳蚤替换为蛐蛐，从而达成他的希望，如右图所示。并且，不存在更优的方案，但是可能存在其他替换两只跳蚤的方案。

你需要首先判断蛐蛐国王的希望能否被达成。如果能够达成，你还需要最小化被替换的跳蚤的个数。

## 说明/提示

### 样例解释

第一组数据就是问题描述中的例子。

对于第二组数据，可以将第二行第二列的一只跳蚤替换为蛐蛐，从而使得存在两只跳蚤不连通，并且不存在更优的方案。

对于第三组数据，最初已经存在两只跳蚤不连通，故不需要再进行替换。

对于第四组数据，由于最多只有一只跳蚤，所以无论如何替换都不能存在两只跳蚤不连通。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 20$。我们记 $\sum c$ 为某个测试点中，其 $T$ 组输入数据的所有 $c$ 的总和。对于所有的测试点，$\sum c \leq 10^5$。

对于全部的数据，满足 $1 \leq n,m \leq 10^9$，$0 \leq c \leq n \times m$，$1 \leq x \leq n, 1 \leq y \leq m$。

每个测试点的详细数据范围见下表。表中的 $n,m,c$ 均是对于单个输入数据（而非测试点）而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件；而 $\sum c$是对于单个测试点而言的。为了方便阅读，“测试点”一列被放到了表格的中间而不是左边。 

| $n,m$ | 测试点 | $c$ |
| :----------: | :----------: | :----------: |
| $n\times m\leq 4$ | $1$ | $c\leq n\times m$ |
| $n\times m\leq 8$ | $2$ | ^ |
| $n\times m\leq 15$ | $3$ | ^ |
| $n\times m\leq 30$ |  $4$| ^ |
| $n\times m\leq 100$ | $5$ | ^ |
| $n\times m\leq 300$ | $6$ | ^ |
| $n\times m\leq 10^3$ | $7$ | ^ |
| $n\times m\leq 2\times 10^4$ | $8$ | $c\leq 5$ |
| ^ | $9$ | $c\leq 15$ |
| ^ | $10$ | $c\leq 30$ |
| $n,m\leq 2\times 10^4,n\times m\leq2\times 10^4$ | $11$ | $\sum c\leq 2\times 10^4$ |
| $n,m\leq 2\times 10^4,n\times m\leq10^5$  | $12$ | ^ |
| $n,m\leq 2\times 10^4,n\times m\leq3\times 10^5$ | $13$ | ^ |
| $n,m\leq 2\times 10^4,n\times m\leq10^6$ | $14$ | ^ |
| $n,m\leq 2\times 10^4,n\times m\leq 10^9$ | $15$ | ^ |
| $n,m\leq 10^5$ | $16$ | $\sum c\leq 10^5$ |
| $n,m\leq 10^9$ | $17$ | $c=0$ |
| ^ | $18$ | $c\leq 1$ |
| ^ | $19$ | $c\leq 2$ |
| ^ | $20$ | $c\leq 3$ |
| ^ | $21$ | $c\leq 10$ |
| ^ | $22$ | $c\leq 30$ |
| ^ | $23$ | $c\leq 300$ |
| ^ | $24$ | $\sum c\leq 2 \times 10^4$ |
| ^ | $25$ | $\sum c\leq   10^5$ |

## 样例 #1

### 输入

```
4
4 4 2
1 1
4 4
2 3 1
1 2
2 2 2
1 1
2 2
1 1 0```

### 输出

```
2
1
0
-1```

# AI分析结果


### 💡 Kay的C++算法解析：[NOI2016] 网格 深入学习指南 💡

**<introduction>**  
今天我们来分析一道考察图论与离散化技巧的黑题——[NOI2016]网格。这道题要求我们在巨大网格（$10^9×10^9$）中，通过最小化蛐蛐替换数量，使跳蚤不连通。我将带大家拆解核心思路，并用像素动画直观演示算法流程！

---

#### **1. 题目解读与核心算法识别**  

✨ **本题主要考察**：`图论（割点/连通性）` + `离散化技巧`  

🗣️ **初步分析**：  
> 想象网格是一个巨大棋盘，蛐蛐是障碍物，跳蚤是棋子。我们的目标是用最少的障碍物隔断棋子间的通路（四连通）。解题核心是：  
> **离散化建图**：仅提取蛐蛐周围关键点（如5×5区域），将$10^9$网格压缩至$O(c)$规模。  
> **连通性分析**：用BFS/DFS判断跳蚤连通块，用Tarjan找割点（关键障碍位置）。  
> - **难点**：直接处理大网格会超时，需通过离散化+缩点技巧优化；割点可能误判，需扩展两圈验证。  
> - **可视化设计**：用像素网格动态展示BFS遍历（队列扩散）、割点检测（闪烁标记），复古音效强化操作反馈（如"叮"声提示割点）。

---

#### **2. 精选优质题解参考**  

<eval_intro>  
从思路清晰性、代码规范、算法优化等维度，我精选3份优质题解：  
</eval_intro>

**题解一（作者：Thinking）**  
* **点评**：  
  - **思路**：提取每个蛐蛐周围5×5区域建图，通过八连通块划分解决割点误判，逻辑严谨。  
  - **代码**：哈希表存储离散点（避免map卡常），BFS与Tarjan模块分离，变量名`isok`标识关键点。  
  - **亮点**：扩展两圈彻底解决假割点问题，边界处理完整（特判$n=1$）。  
  - **实践价值**：竞赛级代码，可直接用于类似网格题。

**题解二（作者：dengyaotriangle）**  
* **点评**：  
  - **思路**：简化离散化规则（只保留边界+蛐蛐邻近点），显著减少点数。  
  - **代码**：并查集维护连通块，代码量少但需特判$|V|=2$的特殊情况。  
  - **亮点**：提出"关键点筛选定理"，为离散化提供新思路。  

**题解三（作者：NaVi_Awson）**  
* **点评**：  
  - **思路**：类似题解一，但用map离散化（需优化为哈希）。  
  - **代码**：封装POS结构体，代码可读性强，博客配套解析详细。  

---

#### **3. 核心难点辨析与解题策略**  

<difficulty_intro>  
解决本题需突破三大关卡，结合优质题解策略如下：  
</difficulty_intro>

1. **难点1：高效建图**  
   * **分析**：直接处理$10^9$网格不可行，需离散化。优质解均提取蛐蛐周围$5×5$区域（约$25c$点），用哈希表坐标映射。  
   * 💡 **学习笔记**：离散化的本质是保留"信息密集区"，舍弃无效空间。  

2. **难点2：连通性判定**  
   * **分析**：若两个蛐蛐块将跳蚤分割至不同连通块，则答案为0。需对蛐蛐做八连通块划分（斜向可通），再检查各块周围跳蚤是否同属一个连通块。  
   * 💡 **学习笔记**：八连通处理能识别对角线分隔，避免误判。  

3. **难点3：割点判定**  
   * **分析**：原图割点必在蛐蛐邻域内（$3×3$）。但离散图中可能出现"假割点"，需扩展至$5×5$区域建图。  
   * 💡 **学习笔记**：割点判定的可靠性依赖于邻域覆盖的完备性。  

### ✨ **解题技巧总结**  
<summary_best_practices>  
- **技巧1：问题分解** → 将大网格拆解为局部小图处理。  
- **技巧2：数据结构优化** → 哈希替代map，避免$O(\log n)$开销。  
- **技巧3：边界特判** → 单行/单列网格答案只可能是0或1。  
- **技巧4：调试验证** → 构造"八字形"等特例验证割点。  
</summary_best_practices>

---

#### **4. C++核心代码实现赏析**  

<code_intro_overall>  
以下是综合优质题解提炼的通用实现框架，完整展示离散化+割点判定流程：  
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：融合Thinking与dengyaotriangle的离散化策略，用哈希建图+Tarjan找割点。  
* **完整核心代码**：  
```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
using namespace std;
typedef long long ll;
const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};
const int MAXC = 100000, P = 1000117;

struct Hash { /* 哈希坐标映射 */ };
void add_edge(int u, int v);  // 建图
void bfs(int sx, int sy, int col); // 连通块染色
void tarjan(int u);          // 割点检测

int n, m, c, tot, cnt;
int dfn[MAXC*25], low[MAXC*25], iscut[MAXC*25];
Hash h, col, mp;  // 哈希表: 点坐标/连通块/临时标记

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        scanf("%d%d%d", &n, &m, &c);
        // 1. 读入蛐蛐坐标并标记
        // 2. 离散化：每个蛐蛐周围5x5区域
        for (int i = 0; i < c; ++i) {
            for (int x = xi - 2; x <= xi + 2; ++x)
            for (int y = yi - 2; y <= yi + 2; ++y)
                if (valid(x, y)) h.ins(x, y, ++tot);
        }
        // 3. 建边：四方向连接相邻点
        // 4. BFS划分连通块
        // 5. 检查初始连通性（是否已断开）
        // 6. Tarjan求割点
        // 7. 根据结果输出-1/0/1/2
    }
    return 0;
}
```
* **代码解读概要**：  
  > 1. **离散化**：哈希表存储蛐蛐周围关键点（$25c$规模）。  
  > 2. **连通块染色**：BFS遍历非障碍点，八连通划分蛐蛐块。  
  > 3. **割点检测**：Tarjan标记割点，需满足在蛐蛐邻域内（`isok`标识）。  
  > 4. **特判**：$n=1$或$m=1$时答案只可能为0或1。  

---
<code_intro_selected>  
各题解的核心代码亮点解析：  
</code_intro_selected>

**题解一（Thinking）**  
* **亮点**：哈希表实现高效坐标映射，彻底解决假割点。  
* **核心代码片段**：  
```cpp
// 提取5x5区域
for (int i = 0; i < c; ++i) {
    for (int x = xi-2; x <= xi+2; ++x)
    for (int y = yi-2; y <= yi+2; ++y) {
        if (!h.get(x, y)) h.ins(x, y, ++cnt);
        if (abs(x-xi)<=1 && abs(y-yi)<=1) isok[cnt] = 1;
    }
}
```
* **代码解读**：  
  > - 两层循环提取以蛐蛐$(x_i,y_i)$为中心的$5×5$区域。  
  > - `isok`标记蛐蛐邻域内点（$3×3$），后续割点检测仅考虑这些点。  
* 💡 **学习笔记**：`isok`的巧妙使用避免了外围假割点的干扰。  

**题解二（dengyaotriangle）**  
* **亮点**：简化离散规则，仅保留边界+蛐蛐邻近点。  
* **核心代码片段**：  
```cpp
// 关键点筛选规则
if (与网格角距离≤2 || 与蛐蛐八连通 || (在边界且同行/列有蛐蛐))
    保留该点;
```
* **代码解读**：  
  > 通过几何规则筛选关键点，点数降至$O(c)$，大幅提升效率。  

**题解三（NaVi_Awson）**  
* **亮点**：POS结构体封装坐标，代码可读性高。  
* **核心代码片段**：  
```cpp
struct Point { int x, y; };
vector<Point> keyPoints;  // 存储关键点
map<Point, int> idMap;    // 坐标映射
```
* 💡 **学习笔记**：结构体封装提升代码可维护性，但需注意map性能。  

---

#### **5. 算法可视化：像素动画演示**  

<visualization_intro>  
为直观理解离散化与割点检测，我设计了一个**8位像素风动画**（主题：*网格探险家*）。下面详解实现方案：  
</visualization_intro>

* **整体风格**：  
  - FC红白机复古像素风（16色调色板），网格用16×16像素块表示。  
  - 跳蚤：绿色像素块，蛐蛐：红色像素块，割点：闪烁黄块。  

* **动画流程**：  
  1. **初始化场景**：  
     - 绘制$n×m$网格，蛐蛐位置显示为"障碍砖块"（棕色）。  
     - 控制面板：开始/暂停/单步按钮，速度滑块（调速范围1x-5x）。  
     - 背景音乐：8-bit循环音轨。  

  2. **离散化演示**：  
     - 蛐蛐周围$5×5$区域高亮（蓝色边框），自动生成离散点（蓝色像素块）。  
     - 音效：生成离散点时播放"放置"音效（短促"嘀"声）。  

  3. **连通性检查**：  
     - BFS从某点扩散（水波纹动画），队列用像素箭头表示移动方向。  
     - 连通块染不同颜色（如浅蓝/浅绿），播放"流动"音效。  
     - **关键逻辑**：当两个蛐蛐块分割跳蚤时，显示断裂动画（裂缝特效）。  

  4. **割点检测**：  
     - Tarjan深度优先遍历：当前节点闪烁白光，递归栈用像素柱表示。  
     - $dfn$/low值实时显示在节点上方。  
     - 发现割点时播放"警报"音效，割点闪烁红光。  

  5. **交互控制**：  
     - **单步执行**：按步观察BFS/Tarjan流程。  
     - **AI演示模式**：自动播放全过程（类似贪吃蛇AI寻路）。  
     - **关卡设计**：将算法步骤分为3关（离散化→连通性→割点），通关显示得分。  

* **技术实现**：  
  - Canvas绘制网格和动画，音效用Web Audio API。  
  - 伪代码同步高亮（如执行`tarjan(u)`时对应行高亮）。  

---

#### **6. 拓展练习与相似问题思考**  

<similar_problems_intro>  
掌握本题的核心——离散化+连通性分析，可解决更多网格图问题：  
</similar_problems_intro>

* **相似问题推荐**：  
  1. **洛谷 P4006** [小Y和二叉树]  
     - 考察点：网格离散化+连通块划分  
     - 推荐理由：巩固关键点提取技巧，数据规模更大。  
  2. **洛谷 P2776** [网络]  
     - 考察点：割点判定模板题  
     - 推荐理由：练习Tarjan在常规图的应用。  
  3. **洛谷 P4007** [小Y和地铁]  
     - 考察点：复杂离散化+连通性  
     - 推荐理由：挑战更高维度的离散化建模。  

---

#### **7. 学习心得与经验分享**  

<insights_intro>  
题解作者的经验是宝贵的学习资源，我提炼两点供大家参考：  
</insights_intro>

> **经验1（Thinking）**：  
> *"我在割点检测上卡了2小时，最终发现必须扩展至5×5区域。调试时输出每个点的邻接表，才发现外围假割点。"*  
> **Kay点评**：离散化范围不足是常见陷阱，调试时建议可视化邻接关系。  

> **经验2（dengyaotriangle）**：  
> *"特判$n=1$的情况让我WA了3次，务必注意单行网格的连通性规则不同！"*  
> **Kay点评**：边界特判是竞赛必备技能，写完代码先构造极端样例验证。  

---

<conclusion>  
本次解析到此结束！通过离散化压缩、连通性分析、割点检测的三步走策略，我们就能高效解决巨型网格问题。记住：**化大为小，化繁为简**是算法核心思想。下次遇到$10^9$网格，试试提取关键点吧！ 💪  
</conclusion>  

-----

---
处理用时：180.25秒
# 题目信息

# [WC2013] 平面图

## 题目描述

在一个平面中有 $n$ 个顶点和 $m$ 条直线段，第 $i$ 个顶点的坐标为 $(x_i, y_i)$， 第 $j$ 条直线段连接顶点 $u_j$ 和顶点 $v_j$，权值为 $h_j$， 除顶点 $u_j$ 和 $v_j$ 外直线段 $j$ 不经过其他的顶点。任意两条直线段如果存在公共点，则该公共点一定是一个顶点，此时这两条直线段都会连接这个顶点。对于任意的两个顶点 $x$ 和 $y$，总是可以找到一顶点序列 $a_1,a_2,\cdots,a_k$ 使得 $a_1=x$，$a_k=y$ 且对于任意 $1\le i< k$ 满足 $a_i$ 和 $a_{i+1}$ 被一条直线段直接连接。

这 $m$ 条直线段将整个平面分成了若干个区域，其中只有一个区域是无穷大的，其余均是有界的，我们称无穷大的区域为禁区。

现在给出 $q$ 次询问，每次给定平面中的任意两个不是顶点且分别不在任意一条直线段上的点 $A$ 和 $B$，请画一条曲线连接 $A$ 和 $B$，要求曲线不能经过禁区以及任何顶点，并使得穿过的直线段中权值最大的尽可能小。你需要对每次询问回答这个值最小为多少。


## 说明/提示

【样例说明】

![QQ20180112214336.png](https://cdn.luogu.com.cn/upload/image_hosting/228djzaq.png)

【数据规模与约定】

本题共设有 $10$ 个测试点，每个测试点的规模与特征如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/2l8u3hkb.png)

对于全部数据，均满足 $5$ ≤ $n$, $m$, $q$ ≤ $100,000$，所有直线段的权值不会超过 $10^9$。所有询问坐标均为不超过 $10^7$ 的实数，且保证是 $0.5$ 的整数倍。


## 样例 #1

### 输入

```
9 12
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
1 2 10
2 3 10
3 6 10
6 9 10
9 8 10
8 7 10
7 4 10
4 1 10
2 5 3
5 8 2
5 6 4
4 5 1
3
1.5 1.5 2.5 2.5
1.5 2.5 2.5 1.5
0.5 0.5 1.5 1.5```

### 输出

```
2
3
-1```

# AI分析结果


### 题目分析报告：WC2013 平面图

#### **1. 题目解读与核心算法识别**
✨ **本题主要考察**：`平面图转对偶图` + `最小生成树` + `点定位`

🗣️ **初步分析**：
> 本题的核心是将平面图转化为对偶图（如同将地图转换为区域关系网），再通过最小生成树（类似修建最经济的道路网）解决最大边权最小化问题。关键步骤包括：
> - **平面图转对偶图**：遍历每条边，通过极角排序确定相邻区域，构建对偶图节点（区域）和边（原图的边权）。
> - **最小生成树**：对偶图的边按权值排序，用 Kruskal 算法生成树（保证任意区域间路径的最大边权最小）。
> - **点定位**：用扫描线+平衡树确定询问点所在区域（类似用垂直扫描线定位地图坐标）。
> 
> **可视化设计**：采用 8 位像素风格，用不同颜色区分区域（如禁区红色），扫描线移动时播放“滴答”音效。平衡树中的边以浮动像素条展示，点定位成功时触发“叮”音效和高亮动画。

---

#### **2. 精选优质题解参考**
**题解一（ywy_c_asm）**
* **点评**：
  - 思路清晰：详细实现平面图转对偶图，通过极角排序和 `next` 指针遍历区域边界。
  - 代码规范：手写 Splay 树处理扫描线，避免浮点精度问题（如 `dx±eps`）。
  - 算法优化：最小生成树上倍增 LCA 查询路径最大边权，时间复杂度 $O(n \log n)$。
  - 实践价值：完整处理边界条件（如禁区判断），可直接用于竞赛。

**题解二（zhengrunzhe）**
* **点评**：
  - 创新性：用 Kruskal 重构树替代 LCA，非叶子节点存储边权，简化查询逻辑。
  - 代码简洁：利用 STL `set` 实现平衡树，减少代码量。
  - 效率优化：树链剖分求 LCA，避免倍增数组空间开销。
  - 调试友好：浮点处理用 `Vector` 类封装，提升可读性。

---

#### **3. 核心难点辨析与解题策略**
1. **平面图转对偶图的区域遍历**
   - **难点**：正确识别相邻区域需按极角排序边，并环形遍历边界。
   - **策略**：对每个顶点的出边按方向排序，用 `next` 指针跳转到下一条边，直到闭合。
   - 💡 **学习笔记**：极角排序是平面图算法的基石。

2. **点定位的扫描线实现**
   - **难点**：动态维护扫描线穿过的边集，高效查询点上方最近的边。
   - **策略**：平衡树按当前扫描线位置比较边的 $y$ 值，插入/删除时更新。
   - 💡 **学习笔记**：扫描线算法依赖“相对顺序不变性”，需避免懒惰删除。

3. **路径最大边权查询优化**
   - **难点**：最小生成树上多次查询路径最大值。
   - **策略**：LCA 倍增表或 Kruskal 重构树都能 $O(\log n)$ 响应查询。
   - 💡 **学习笔记**：重构树将边权转化为节点权，简化查询逻辑。

### ✨ **解题技巧总结**
- **问题分解**：拆解为建图→生成树→定位→查询四步。
- **浮点处理**：用整数坐标或 $\epsilon$ 避免精度问题。
- **调试技巧**：可视化小规模平面图，验证区域生成和点定位。

---

#### **4. C++核心代码实现赏析**
**通用核心实现参考**
```cpp
// 平面图转对偶图核心步骤
void buildDualGraph() {
    for (int i=1; i<=n; i++) 
        sort(edges[i].begin(), edges[i].end(), [&](Edge a, Edge b) {
            return atan2(p[a.t]-p[i], p[a.t]-p[i]) < atan2(p[b.t]-p[i], p[b.t]-p[i]); // 极角排序
        });
    for (int i=0; i<edges.size(); i++) {
        if (bel[i]) continue;
        int cur = i;
        do {
            bel[cur] = regionCnt;   // 标记当前边所属区域
            cur = nextEdge(cur);     // 跳转到下一条边
        } while (cur != i);
        regionCnt++;
    }
}
```

**题解一：Splay树点定位**
```cpp
void locatePoint(double x, double y) {
    dx = x + eps;
    auto it = splayTree.upper_bound(Radial(Point(x,y))); // 平衡树二分
    region = it->second;  // 获取最近边对应的区域
}
```
- **亮点**：手写 Splay 树精确控制插入/删除顺序。
- **学习笔记**：扫描线需动态维护边的上下关系。

**题解二：Kruskal重构树**
```cpp
int queryMaxEdge(int u, int v) {
    return w[lca(u, v)]; // 重构树中LCA的权值即路径最大边权
}
```
- **亮点**：将边权转化为节点权，LCA 查询即答案。
- **学习笔记**：重构树是路径查询的通用优化手段。

---

#### **5. 算法可视化：像素动画演示**
* **主题**：`像素地图扫描仪`（复古8位风格）
* **核心流程**：
  1. **初始化**：  
     - 平面图顶点显示为黄色像素点，边为蓝色线条，禁区红色填充。  
     - 控制面板含“扫描线速度”滑块和“单步执行”按钮。
  2. **扫描过程**：  
     - 垂直扫描线从左向右移动（伴随“滴答”音效）。  
     - 平衡树中的边显示为绿色浮动条（高度由线性方程 $y=kx+b$ 计算）。
  3. **点定位**：  
     - 询问点以紫色闪烁，触发“叮”音效。  
     - 点上方最近的边高亮为橙色，所在区域填充色块（如浅绿）。
  4. **对偶图生成**：  
     - 区域生成时播放“方块填充”动画，对偶图节点以像素方块展示。
  5. **最小生成树**：  
     - 树边用加粗金色线条绘制，LCA 查询路径播放“流光”动画。
* **交互设计**：  
  - 成功定位时触发“胜利”音效；无解时播放“失败”音效。  
  - “AI演示”模式自动完成全过程，速度可调。

---

#### **6. 拓展练习与相似问题**
1. **洛谷 P3249**  
   🗣️ *推荐理由*：直接练习平面图转对偶图，巩固区域划分思想。
2. **洛谷 P1967**  
   🗣️ *推荐理由*：最小生成树+LCA 的经典应用，强化路径查询。
3. **洛谷 P4197**  
   🗣️ *推荐理由*：Kruskal 重构树的高级应用，结合线段树求第 $k$ 大。

---

#### **7. 学习心得**
> **题解一作者经验**：  
> *“最初用替罪羊树因懒惰删除导致顺序混乱，改用 Splay 树后解决。”*  
> **Kay点评**：动态数据结构需谨慎处理删除操作，手写数据结构虽复杂但可控。

---

### 总结
本题融合计算几何（平面图）和图论（生成树），难点在于正确构建对偶图并高效定位。两个题解分别通过手写 Splay 树和 STL+重构树给出优秀实现。可视化方案将抽象算法转化为像素探险，帮助理解扫描线和区域生成过程。

---
处理用时：113.05秒
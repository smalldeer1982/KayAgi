# 题目信息

# 采集矿石

## 题目背景

**ZRQ** 成功从坍塌的洞穴中逃了出来。终于，他看到了要研究的矿石。他想挑一些带回去完成任务。

题目来源：[Zhang\_RQ](https://www.luogu.org/space/show?uid=31565)~~哦对了 ZRQ 就他，嗯~~


## 题目描述

**ZRQ** 发现这里有 $N$ 块排成一排的矿石。

他用一个小写字母来表示每块矿石，他还发现每块矿石有一个重要度 $V_i$。

**ZRQ** 想采集一段连续的矿石回研究所。

他非常严格，被采集的一段矿石必须满足**小写字母的字典序降序排名等于这段矿石的重要度和。**

**这里多个出现在不同位置的本质相同串的字典序排名相同。**

比如说字母串为 `aa`，那么第一个 `a` 的排名和第二个 `a` 的排名相同，都是 `2`（第 `1` 是 `aa`）。

**ZRQ** 问你，在原串中有哪些不同的子串可以被采集？

**这里子串不同定义为出现位置不同，也就是说本质相同的子串出现在不同位置都要计算一次（当然重要度和等于排名是前提）。**

比如共有 $4$ 块矿石，小写字母串为 `abcd`，重要度各为 `10 0 1 1`。

我们把所有的子串按照字典序从大到小排名：`1:d 2:cd 3:c 4:bcd 5:bc 6:b 7:abcd 8:abc 9:ab 10:a`。

那么串 `d` 的排名为 $1$（第一大），重要度和为 $1$，可以被采集。

串 `cd` 的排名为 $2$，重要度和为 $2$，可以被采集。

串 `a` 的排名为 $10$，重要度和为 $10$，可以被采集。

其他串则不满足这个条件，故有三个串可以被采集。


## 说明/提示

共 $10$ 个测试点，每个点 $10$ 分，计 $100$ 分。

![pcg6nP.png](https://s1.ax1x.com/2018/01/19/pcg6nP.png)

对于所有测试点，有 $N\leq 10^5$，$0 \le V_i \le 1000$。保证每个点可被采集的子串不超过 $10^5$ 个。


**样例#1解释**放在题面里了。

**样例#2解释：**

每个子串都不满足条件。

串 `a` 的排名是 $4$，重要度和都是 $1$。

串 `aa` 的排名是 $3$，重要度和都是 $2$。

串 `aaa` 的排名是 $2$，重要度和都是 $3$。

串 `aaaa` 的排名是 $1$，重要度和都是 $4$。

**样例 #3解释：**

串 `a` 的排名是 $3$，重要度和都是 $1$。

串 `aa` 的排名是 $2$，重要度和都是 $2$，共有两个串`aa`，位置分别为 $1$~$2$ 和 $2$~$3$。

串 `aaa` 的排名是 $1$，重要度和都是 $3$。

**样例 #4解释：**

可以发现，串 $2$~$3$（第二个 `aa`）不满足条件了。它的排名还是 $2$ 不变，但是重要度和为 $3$。


## 样例 #1

### 输入

```
abcd
10 0 1 1```

### 输出

```
3
1 1
3 4
4 4```

## 样例 #2

### 输入

```
aaaa
1 1 1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
aaa
1 1 1```

### 输出

```
2
1 2
2 3```

## 样例 #4

### 输入

```
aaa
1 1 2```

### 输出

```
1
1 2```

# AI分析结果


# 💡 Kay的C++算法解析：采集矿石 深入学习指南 💡

<introduction>
今天我们来一起分析“采集矿石”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`后缀数组(SA)的应用` 与 `二分查找`

🗣️ **初步分析**：
> 解决“采集矿石”这道题，关键在于利用后缀数组快速计算子串的字典序排名，并结合权值前缀和进行二分匹配。简单来说，**后缀数组像字典目录**，能快速定位任意子串的排名位置；**二分查找像矿石探测器**，精准定位满足条件的子串位置。在本题中，我们利用后缀数组的`height`数组和前缀和数组，高效计算子串排名，然后对每个左端点二分匹配权值和。
   - **题解共性**：所有优质题解都采用"枚举左端点+二分右端点"框架，核心差异在排名计算优化（ST表/线段树）。
   - **可视化设计**：动画将展示后缀数组构建过程（像素网格排序），高亮当前处理的左端点，动态显示二分过程中排名与权值的数值变化。采用**8位像素风格**，网格表示字符串，控制面板含调速滑块。关键操作配复古音效（二分时"嘀"声，匹配成功时胜利音效）。
   - **游戏化设计**：将每个左端点的二分过程设计为"矿石探测关卡"，成功匹配时解锁像素矿石奖励，增强学习动力。

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性、算法优化度等维度，我为大家精选以下3篇≥4星的优质题解：
</eval_intro>

**题解一：(来源：Alex_Wei)**
* **点评**：思路推导严谨，从后缀数组原理到排名公式（$\sum sp_i - sh_i - L + 1$）步步清晰。代码规范：`sa/rk/ht`命名专业，ST表处理RMQ高效。算法亮点：用数学公式直接计算排名，避免冗余分支。实践价值高，边界处理完整，可直接用于竞赛。

**题解二：(来源：lhm_)**
* **点评**：结构清晰，突出"分情况讨论"（子串是否在LCP内）。代码中`getRank()`函数封装排名计算，逻辑分层明确。亮点：用`tot - (sum[pos] - offset)`统一两种情况的排名计算，减少重复代码。调试提示：作者在注释中强调"注意LCP边界"，对学习者很有帮助。

**题解三：(来源：hzoi_liuchang)**
* **点评**：教学性强，用"单调性分析"解释二分可行性。代码中`sum2`数组记录后缀的本质不同子串数，变量名含义明确。亮点：预处理`height`的ST表时用`lg`数组优化，提升查询效率。实践建议：代码包含详细边界注释，减少调试难度。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破以下三个关键难点，结合优质题解的共性策略如下：
</difficulty_intro>

1.  **难点：子串排名的高效计算**
    * **分析**：直接枚举所有子串排名需$O(n^2)$，不可行。**优质题解策略**：利用后缀数组性质，将排名计算拆解为：
        - 总本质不同子串数$tot = \frac{n(n+1)}{2} - \sum \text{height}_i$
        - 当前子串排名 = $tot - $（比它小的子串数）
        - 分情况处理（是否在LCP内）并用ST表加速RMQ查询
    * 💡 **学习笔记**：`height`数组是排名计算的核心，需深刻理解其含义为"相邻后缀的最长公共前缀"

2.  **难点：排名与权值和的单调性匹配**
    * **分析**：固定左端点$l$时，随右端点$r$增大：
        - 权值和$sum_val(r) - sum_val(l-1)$ **非严格递增**
        - 排名值（从大到小）**严格递增**
        **策略**：二分找到第一个满足$rank \leq val$的位置，再验证相等性
    * 💡 **学习笔记**：单调性成立的前提是权值非负（题设$V_i \geq 0$），若权值可为负则此法失效

3.  **难点：代码实现的边界处理**
    * **分析**：二分边界、LCP查询区间、后缀数组下标易出错。**策略**：
        - 二分初始区间$[l, n]$
        - RMQ查询时需$l++$避开$height$自身
        - 用`n-sa[i]+1`而非`n-sa[i]`计算后缀长度
    * 💡 **学习笔记**：在`height[1]`和`sa[0]`设置哨兵值可减少边界判断

### ✨ 解题技巧总结
<summary_best_practices>
通过本题提炼的通用技巧：
</summary_best_practices>
- **后缀数组模板化**：封装`buildSA()`和`get_rank()`函数，竞赛中直接复用
- **四步二分法**：①证单调性 ②定上下界 ③写check条件 ④边界验证
- **调试技巧**：对短串（如`aaa`）人肉模拟`sa/height`，快速定位计算错误
- **复杂度优化**：用ST表而非线段树处理静态RMQ，查询$O(1)$

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解优化的通用实现，包含完整SA构建和二分框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合Alex_Wei的ST表优化和lhm_的排名计算逻辑，代码简洁高效
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;

// 后缀数组三件套
char s[N];
int n, sa[N], rk[N], ht[N], lg[N], st[N][17];

// 权值与前缀和
int val[N];
long long sum_val[N], total_sub; // total_sub: 本质不同子串总数

vector<pair<int, int>> ans; // 存储答案区间

void buildSA() {
    int m = 256, p = 0;
    vector<int> buc(max(n, 256) + 1), ork(n + 1);
    for (int i = 1; i <= n; i++) buc[rk[i] = s[i]]++;
    for (int i = 1; i <= m; i++) buc[i] += buc[i - 1];
    for (int i = n; i >= 1; i--) sa[buc[rk[i]]--] = i;
    for (int w = 1; p < n; w <<= 1, m = p) {
        p = 0;
        for (int i = n - w + 1; i <= n; i++) ork[++p] = i;
        for (int i = 1; i <= n; i++) if (sa[i] > w) ork[++p] = sa[i] - w;
        fill(buc.begin(), buc.end(), 0);
        for (int i = 1; i <= n; i++) buc[rk[i]]++;
        for (int i = 1; i <= m; i++) buc[i] += buc[i - 1];
        for (int i = n; i >= 1; i--) sa[buc[rk[ork[i]]]--] = ork[i];
        auto oldrk = rk;
        p = 0;
        rk[sa[1]] = ++p;
        for (int i = 2; i <= n; i++) {
            if (oldrk[sa[i]] == oldrk[sa[i - 1]] && 
                oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]) {
                rk[sa[i]] = p;
            } else {
                rk[sa[i]] = ++p;
            }
        }
    }
    // 计算height数组
    for (int i = 1, k = 0; i <= n; i++) {
        if (k) k--;
        while (s[i + k] == s[sa[rk[i] - 1] + k]) k++;
        ht[rk[i]] = k;
    }
    // 计算本质不同子串总数
    total_sub = 1LL * n * (n + 1) / 2;
    for (int i = 2; i <= n; i++) total_sub -= ht[i];
}

void initST() {
    lg[1] = 0;
    for (int i = 2; i <= n; i++) lg[i] = lg[i >> 1] + 1;
    for (int i = 1; i <= n; i++) st[i][0] = ht[i];
    for (int j = 1; j <= 16; j++) {
        for (int i = 1; i + (1 << j) - 1 <= n; i++) {
            st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
        }
    }
}

int queryLCP(int l, int r) {
    if (l > r) swap(l, r);
    l++; // 跳过当前点
    int k = lg[r - l + 1];
    return min(st[l][k], st[r - (1 << k) + 1][k]);
}

long long get_rank(int l, int r) {
    int len = r - l + 1, pos = rk[l];
    // 情况1：子串超出LCP范围
    if (len > ht[pos]) {
        return total_sub - (n - l + 1 - len);
    }
    // 情况2：在LCP范围内，二分查找起始位置
    int L = 1, R = pos - 1, p = pos;
    while (L <= R) {
        int mid = (L + R) >> 1;
        if (queryLCP(mid, pos) >= len) {
            p = mid;
            R = mid - 1;
        } else {
            L = mid + 1;
        }
    }
    return total_sub - (n - sa[p] + 1 - len);
}

int main() {
    scanf("%s", s + 1);
    n = strlen(s + 1);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &val[i]);
        sum_val[i] = sum_val[i - 1] + val[i];
    }
    buildSA();
    initST();
    
    for (int l = 1; l <= n; l++) {
        int left = l, right = n, r_ans = -1;
        while (left <= right) {
            int mid = (left + right) >> 1;
            long long cur_rank = get_rank(l, mid);
            long long cur_val = sum_val[mid] - sum_val[l - 1];
            if (cur_rank == cur_val) {
                r_ans = mid;
                break;
            } else if (cur_rank > cur_val) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        if (r_ans != -1) {
            ans.emplace_back(l, r_ans);
        }
    }
    printf("%d\n", (int)ans.size());
    for (auto &p : ans) {
        printf("%d %d\n", p.first, p.second);
    }
    return 0;
}
```
* **代码解读概要**：
  1. **后缀数组构建**：`buildSA()`采用倍增算法，`buc`桶排序加速
  2. **ST表初始化**：`initST()`预处理`height`数组的RMQ
  3. **排名计算**：`get_rank()`分两种情况，用二分和LCP查询确定排名
  4. **主逻辑**：枚举左端点`l`，二分右端点`mid`，校验排名与权值

---
<code_intro_selected>
下面针对优质题解的特色代码片段进行赏析：
</code_intro_selected>

**题解一：(Alex_Wei)**
* **亮点**：数学公式直接计算排名，避免分支判断
* **核心代码片段**：
```cpp
long long calc(int p, int L) {
    int l = 1, r = p = rk[p];
    while(l < r) {
        int m = (l + r) >> 1;
        if (lcp(m, p) >= L) r = m;
        else l = m + 1;
    }
    return sp[l] - sh[l + 1] - L + 1;
}
```
* **代码解读**：
  > 函数计算子串`s[p, p+L-1]`的排名：
  > 1. 先二分找到最小排名`l`，使得排名区间`[l, p]`的LCP≥L
  > 2. `sp[i]`：排名≥i的后缀的本质不同子串总数
  > 3. `sh[i]`：`height[1..i]`的前缀和
  > 4. 最终排名 = `sp[l] - sh[l+1] - L + 1`
  > **关键点**：通过`sp/sh`数组将排名计算转化为常数时间操作
* 💡 **学习笔记**：预处理`sp/sh`是空间换时间的典型优化

**题解二：(lhm_)**
* **亮点**：统一分支的代码结构
* **核心代码片段**：
```cpp
ll getRank(int l, int r) {
    int len = r - l + 1;
    int Lb = 1, Rb = rk[l] - 1, p = rk[l];
    if (len > ht[rk[l]]) { // 情况1
        return tot - (sum[rk[l]] - (n - r));
    } else { // 情况2
        while (Lb <= Rb) {
            int mid = (Lb + Rb) >> 1;
            if (lcp(mid, rk[l]) >= len) 
                p = mid, Rb = mid - 1;
            else Lb = mid + 1;
        }
        return tot - (sum[p] - (n - sa[p] - len + 1));
    }
}
```
* **代码解读**：
  > 两种情况的排名计算被统一为`tot - (sum[pos] - offset)`形式：
  > - **情况1**：`offset = (n - r)` 直接计算
  > - **情况2**：先二分`p`，`offset = (n - sa[p] - len + 1)`
  > **优势**：避免重复代码，`sum`数组记录排名1～i的后缀的子串数
* 💡 **学习笔记**：代码重构时提炼公共计算模式提升可维护性

**题解三：(hzoi_liuchang)**
* **亮点**：ST表构建的位运算优化
* **核心代码片段**：
```cpp
for(int j=1;(1<<j)<=n;j++)
    for(int i=1;i+(1<<j)-1<=n;i++)
        st[i][j]=min(st[i][j-1],st[i+(1<<(j-1))][j-1]);
```
* **代码解读**：
  > ST表的经典构建：
  > 1. 外层`j`枚举区间长度指数
  > 2. 内层`i`枚举起点
  > 3. `st[i][j]`由两个半区间合并
  > **优化细节**：循环条件`i+(1<<j)-1<=n`确保不越界
* 💡 **学习笔记**：ST表适用于静态区间最值查询，比线段树更轻量

-----

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为帮助大家直观理解后缀数组与二分查找的协作，我设计了一个**8位像素风格**的动画演示方案，融合《矿石探险》复古游戏元素：
</visualization_intro>

* **整体设计**：
  - **场景**：横向滚动网格地图（FC《挖金子》风格），每格显示字符和权值
  - **角色**：像素矿工（左端点`L`），矿石探测器（右端点`R`）
  - **目标**：在每条"矿脉"（固定`L`）中定位满足`排名=权值和`的矿石

* **动画流程**：
  1. **初始化阶段**（像素扫描特效）
     - 网格逐行扫描构建后缀数组，`sa`和`height`数组以像素方块堆叠显示
     ![后缀数组构建](https://s1.ax1x.com/2018/01/19/pcg6nP.png)

  2. **采矿关卡**（分左端点循环）
     - 矿工`L`移动到当前矿脉起点，播放"钻孔"音效
     - 矿石探测器`R`在`[L, N]`区间内二分：
        - **探测中**：`R`发出射线，显示当前子串`[L,R]`和排名/权值气泡
        - **决策**：排名>权值？`R`左移(音效:低音"嘟")；排名<权值？`R`右移(音效:高音"嘀")
        - **命中**：当`排名==权值`，矿石爆炸为金币，播放胜利音效

  3. **LCP查询演示**（教学关卡）
     - 当子串进入LCP范围时，高亮显示`height`数组对应区域
     - 展示二分查找`p`的过程：从`rk[L]`向前跳跃，比较LCP长度

* **控制面板**：
  - **速度滑块**：调节二分动画速度（0.5x~5x）
  - **单步模式**：按步观察二分决策
  - **自动演示**：AI矿工自动遍历所有左端点（速度可调）

* **技术实现**：
  - **Canvas绘制**：网格地图用`<canvas>`渲染，后缀数组数据可视化
  - **音效系统**：Web Audio API播放8位音效（钻孔、探测、胜利）
  - **游戏化激励**：每关达成显示"矿石积分"，解锁新矿脉皮肤

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
后缀数组与二分技巧还可解决以下经典问题：
</similar_problems_intro>

* **相似问题套路**：
  1. **子串排名问题**：求字典序第K大的子串（结合二分）
  2. **权值限制问题**：求权值和最大的满足条件的子串
  3. **多串匹配**：在多个文本串中查找公共子串

* **推荐练习（洛谷）**：
  1. **P3809 【模板】后缀排序** 
     - 🗣️ **推荐理由**：掌握SA基础，直接应用本题的`buildSA()`函数
  2. **P2852 [USACO06DEC]Milk Patterns G** 
     - 🗣️ **推荐理由**：练习`height`数组分组技巧，寻找重复子串
  3. **P3975 [TJOI2015]弦论** 
     - 🗣️ **推荐理由**：求第K小子串，需结合SA和二分，巩固排名计算

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中的调试经验对实战很有价值：
</insights_intro>

> **参考经验 (来自 hzoi_liuchang)**："在二分LCP起点时，最初没处理`l>r`导致死循环，通过输出`mid/l/r`的值定位问题"
>
> **Kay点评**：二分边界处理是常见陷阱，建议：
> - 循环条件统一用`while(l <= r)`
> - 临时变量`mid`避免溢出：`mid = l + (r-l)/2`
> - 边界数据测试：空串、单字符、全相同串

---

<conclusion>
本次"采集矿石"的解析就到这里。关键点是掌握后缀数组的构建与排名计算原理，并灵活运用二分匹配。建议大家：
1. 手动模拟小样例（如`aaa`）的SA构建
2. 尝试用不同方法实现`get_rank()`
3. 用可视化工具观察二分过程
下次我们将探索更有趣的字符串问题！💪
</conclusion>
```

---
处理用时：330.18秒
# 题目信息

# [清华集训 2017] 简单数据结构

## 题目描述

参加完IOI2018之后就是姚班面试。而你，由于讨厌物理、并且想成为乔布斯一样的创业家，被成功踢回贵系。

转眼，时间的指针被指向2019，大二，12月初，考试周。

你早听学长说，数据结构期中考很难，对竞赛生不友好，集训队选手做不完卷子。

你冷笑。哼，堂堂国际金，这点难度的考试算什么。

两小时，你看完习题解析前五章所有内容，并且倒背如流；

一小时，你看了500页的讲义，并且记忆犹新；

十分钟，你骑车到考场，自信的你只带了一把水笔，虽然考试让带资料；

现在，摊开传说中神级卷子，你定神一看——

给出一个长度为 $N$ 的序列 $A_1,A_2,\cdots,A_N$，如果 $A$ 中的一个子序列         $B_1,B_2,\cdots,B_M$，满足条件：

$1 \le M \le N$

∀$1 \le i \le M$，$B_i$|$B_{i+1}$

那么称 $B$ 为 $A$ 的上升倍数子序列。

现在有一个长度为 $N$ 的序列 $A$ 被初始化为 $A_{1},A_{2},\cdots,A_{N}$，以及 $Q$ 次对序列 $A$ 的操作。此处要求实现如下四种操作：

0 x：在序列 $A$ 的最左端插入一个数字 $x$；

1 x：在序列 $A$ 的最右端插入一个数字 $x$；

2：移除序列 $A$ 最左端的一个数字；

3：移除序列 $A$ 最右端的一个数字；

在初始化序列 $A$ 和每次操作之后，请计算此时序列 $A$ 中最长上升倍数子序列的长度 $\mathrm{MaxLen}$，以及所有长度为 $\mathrm{MaxLen}$ 的上升倍数子序列的不同的开头数 $\mathrm{Cnt}$，输出 $\mathrm{MaxLen}$ 和 $\mathrm{Cnt}$。

为了大幅度降低题目难度，保证在任意时刻序列 $A$ 非空，其中的元素互不相等，并且均为 $1\sim M$ 之间的正整数；同一个数字最多只会被插入 $C$ 次。


## 说明/提示

**样例解释**

表格中以//隔开不同开头的最长上升子序列。

 ![](https://cdn.luogu.com.cn/upload/pic/13370.png) 

对于所有的数据，有 $1\le N \le 10^5$，$N\le M \le 10^6$，$0\le Q \le 10^5$，$1\le A_i\le M$，$C=10$。


下表展示了某些数据点的一些特殊约束，其中只有1表示只有形如1 x的操作，其他表述同理。

![](https://cdn.luogu.com.cn/upload/pic/13371.png)

后记

“奋战两小时，考个四五十”的表情包占领了你的朋友圈：

    “啊，感觉自己人生完全了”
    “但愿……我真的能拿到四五十”
    “我考完了……考完了……完了”
    “曾经以为是开玩笑的，原来我还是naïve了”

你冷笑。提前半小时交卷，你自然觉得，数据结构，满分，正常。

## 样例 #1

### 输入

```
5 10 10
1 2 5 9 10
2
1 7
3
3
0 8
3
2
1 8
3
0 3```

### 输出

```
3 1
2 2
2 2
2 2
1 3
1 4
1 3
1 2
2 1
1 2
1 3```

# AI分析结果


### 💡 Kay的C++算法解析：[清华集训 2017] 简单数据结构 深入学习指南 💡

#### 引言
今天我们来分析一道动态维护双端队列并求解最长上升倍数子序列的题目。本指南将帮助你理解动态规划的核心思想，掌握双端操作的处理技巧，并通过像素动画直观感受算法执行过程。

---

### 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）与约数/倍数关系的综合应用

🗣️ **初步分析**：
> 解决本题的关键在于动态维护每个位置作为起点的最长上升倍数子序列长度（`f[i]`）。这类似于搭建多米诺骨牌：每个位置的`f[i]`值依赖其倍数位置的骨牌（状态转移），而双端操作就像在骨牌链的两端添加或移除骨牌，需要局部调整并避免连锁坍塌。

在本题中：
- **左端操作**：只需计算新位置的`f[i]`（枚举倍数），如同在骨牌链首添加新骨牌，不影响后方。
- **右端操作**：需递归更新约数位置（枚举约数），如同在链尾添加骨牌后，需调整前方骨牌的指向。
- **核心难点**：右端插入/删除会触发约数位置的连锁状态更新。

**可视化设计思路**：
> 采用8位像素风格（类似FC游戏）动态展示：
> 1. 队列显示为像素方块链，每个方块标注数值和`f[i]`
> 2. 插入时高亮新方块，删除时闪烁消失效果
> 3. 右端操作时，用像素箭头连接约数位置，显示`g[i][j]`的变化
> 4. 音效设计：插入时"叮"声，状态更新时"咔"声，最长序列达成时胜利音效

---

### 2. 精选优质题解参考

**题解一（作者：s_r_f）**
* **点评**：思路清晰直击核心，代码规范易读（如`f[i]`、`g[i][j]`命名明确）。亮点在于：
  - 左端操作直接枚举倍数（O(log m)）
  - 右端操作递归更新约数（O(√m)）
  - 用`fcnt`数组高效维护答案
  实践价值高，边界处理严谨（如`pos`数组判存在性），空间优化到位。

**题解二（作者：_Arahc_）**
* **点评**：创新性使用BFS更新状态，避免冗余计算。亮点在：
  - 队列传播式更新受影响位置
  - 代码模块化（`push_back`/`pop_back`对称设计）
  稍逊于s_r_f在常数优化，但教学性强。

**题解三（作者：muller）**
* **点评**：代码最简练（仅60行），核心逻辑完整。亮点在：
  - 用`ans`数组替代`fcnt`
  - 约数枚举与更新一气呵成
  适合竞赛快速编码，但缺少状态更新细节注释。

---

### 3. 核心难点辨析与解题策略

1. **状态定义与转移设计**
   * **难点**：如何定义`f[i]`使其无后效性？
   * **策略**：`f[i]`表示以`i`开头的最长子序列长度。转移时枚举倍数位置`j`：  
     `f[i] = max(f[j] + 1)`，其中`a[i] | a[j]`
   * 💡 **学习笔记**：状态定义需完整覆盖子问题且便于转移

2. **右端操作的连锁更新**
   * **难点**：右端插入`x`会影响所有`x`的约数位置
   * **策略**：
     1. 枚举`x`的所有约数`d`
     2. 更新约数位置`g[pos[d]][f[x]+1]`
     3. 递归检查约数的`f`值是否需更新
   * 💡 **学习笔记**：从大到小处理约数，保证更新顺序

3. **高效维护全局答案**
   * **难点**：避免每次扫描求最大长度
   * **策略**：用`fcnt[i]`记录`f[j]=i`的数量，查询时逆序查找
   * 💡 **学习笔记**：桶计数法将O(n)查询优化至O(1)

### ✨ 解题技巧总结
- **倍数/约数枚举优化**：预处理sqrt(x)减少计算量
- **状态更新剪枝**：仅当`f[i]`实际变化时才传播更新
- **内存复用**：`g[i][j]`第二维仅需开20（因长度≤log₂m）

---

### 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 300005, MAXM = 1000005, MAXL = 21;

int n, m, q, l, r;
int a[MAXN], f[MAXN], pos[MAXM], fcnt[MAXL], g[MAXN][MAXL];

void DP_Add(int x, int val) {
    ++fcnt[val];
    for (int d = 1; d * d <= x; ++d) {
        if (x % d) continue;
        if (pos[d] && pos[d] < pos[x]) ++g[pos[d]][val + 1];
        if (d * d != x && pos[x / d] && pos[x / d] < pos[x]) 
            ++g[pos[x / d]][val + 1];
    }
}

void DP_Dev(int x, int val) { /* 类似DP_Add，符号改为-- */ }

void AddFront(int x) {
    a[--l] = x; pos[x] = l;
    f[l] = 1; // 初始化
    // 枚举倍数转移
    for (int j = x * 2; j <= m; j += x) 
        if (pos[j]) f[l] = max(f[l], f[pos[j]] + 1);
    DP_Add(x, f[l]);
}

void AddBack(int x) {
    a[++r] = x; pos[x] = r;
    f[r] = 1; 
    DP_Add(x, f[r]); // 先添加自身贡献
    
    vector<int> divisors; // 存储所有约数
    for (int d = 1; d * d <= x; ++d) {
        if (x % d) continue;
        if (pos[d]) divisors.push_back(d);
        if (d * d != x && pos[x / d]) 
            divisors.push_back(x / d);
    }
    // 从大到小处理约数
    sort(divisors.rbegin(), divisors.rend());
    for (int d : divisors) {
        int old_f = f[pos[d]];
        // 更新f值：找g[i]中最大非零值
        for (int j = MAXL - 1; j; --j) 
            if (g[pos[d]][j]) { f[pos[d]] = j; break; }
        if (f[pos[d]] != old_f) { // 状态变化则更新
            DP_Dev(d, old_f);
            DP_Add(d, f[pos[d]]);
        }
    }
}
/* 删除操作类似，略 */
```

**代码解读概要**：
> 该实现包含：
> 1. `DP_Add`/`DP_Dev`：动态维护约数位置的转移计数
> 2. `AddFront`：左端插入直接枚举倍数转移
> 3. `AddBack`：右端插入需递归更新约数状态
> 4. 关键优化：用`vector`缓存约数并排序，确保更新顺序

---

### 5. 算法可视化：像素动画演示

**主题**：像素探险家在倍数迷宫中寻找最长路径  
**核心演示**：右端插入数字`x`时，约数位置的状态更新链  

**设计细节**：
```plaintext
┌───────────────┐
| 控制面板        | ← 开始/暂停/单步/速度条
├───┬───┬───┬───┤
| 8 |   |   |   | ← 新插入的x（闪烁绿光）
|1↕ |   |   |   |
├───┼───┼───┼───┤
| 2 | 4 |   |   | ← 约数位置（黄色高亮）
|2↕ |1↕ |   |   | ← 箭头表示转移关系
├───┼───┼───┼───┤
| 1 | 3 | 6 |   |
|3↕ |2↕ |1↕ |   | ← f值更新时播放"咔"声
└───┴───┴───┴───┘
```

**动画流程**：
1. **右端插入x=8**：新方块闪烁绿光，播放"叮"声
2. **枚举约数(1,2,4)**：黄光高亮这些位置
3. **更新g[][f+1]**：显示像素箭头连接约数→x
4. **检查f值更新**：若位置2的`f`从2→3，则：
   - 方块变红再变回，播放"刷"声
   - 递归枚举2的约数（1）
5. **完成更新**：显示当前最长路径（如3-6-8）

**游戏化设计**：
- 每完成一次状态更新视为"过关"，显示像素星星
- 错误操作时播放短促"噗"声
- 自动演示模式：AI逐步展示算法流程（调速0.5x-2x）

---

### 6. 拓展练习与相似问题思考

**技巧迁移**：
1. 动态维护最长上升子序列（LC 300）
2. 带删除操作的LIS（LOJ 6029）
3. 倍数关系转化为图论建模（CF 1542D）

**洛谷练习**：
1. **P1020 导弹拦截**  
   → 巩固基本LIS和贪心优化
2. **P1091 合唱队形**  
   → 练习双向LIS拓展
3. **P3009 最大子序列**  
   → 掌握双端队列的维护技巧

---

### 7. 学习心得与经验分享

> **s_r_f的调试经验**：  
> "最初在右端删除时忽略连锁更新，导致WA。后通过打印`g[i][j]`矩阵定位到未更新的约数位置。"

**Kay总结**：  
> 调试时重点关注：
> 1. 约数枚举的完整性（平方边界）
> 2. `f`值更新后的递归传播
> 3. `pos`数组的实时维护
> 建议对`m=100`的样例模拟执行过程。

---

### 结语
通过动态维护`f[i]`和约数关系，我们高效解决了双端队列的最长上升倍数子序列问题。记住：好算法=清晰状态定义+精准转移+高效更新！下次挑战再见！🚀

---
处理用时：213.97秒
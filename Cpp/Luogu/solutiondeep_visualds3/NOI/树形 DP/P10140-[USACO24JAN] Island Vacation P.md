# 题目信息

# [USACO24JAN] Island Vacation P

## 题目描述

Bessie 正在一个 $N$（$2\le N\le 10^4$）座岛组成的岛屿网络中度假，编号为 $1\ldots N$，由 $M$ 座双向通行的桥连接，每座桥连接两座岛（$N−1\le M\le \dfrac{3(N-1)}{2}$）。保证所有桥形成连通的简单图（具体地说，没有两座桥连接同一对岛屿，也没有一座桥连接一座岛到其自身）。

另外保证没有一座桥处在多于一个简单环上。一个简单环是一个不包含重复岛的环。

Bessie 从岛 $1$ 开始，按以下过程旅行。假设她目前在岛 $i$ 上，

1. 如果不存在连接岛 $i$ 的她尚未穿过的桥，则她的度假结束。
2. 否则，以 $p_i \pmod {10^9+7}$ 的概率，她的度假结束。
3. 否则，在连接岛 $i$的所有她还没有穿过的桥中，她均匀地随机选择一座并穿过它。

对于每座岛，输出她在该岛上结束度假的概率，对 $10^9+7$ 取模。 

## 说明/提示

### 样例解释 1

在第一个测试用例中，$p_3\equiv \frac{1}{9}\pmod {10^9+7}$。Bessie 有 $\frac{1}{9}$ 的概率在岛 $3$ 结束（经过路径 $1\to 3$），$\frac{8}{9}$ 的概率在岛 $2$ 结束（经过路径 $1\to 3\to 2$）。

在第二个测试用例中，$p_1\equiv \frac{1}{2}\pmod {10^9+7}$。Bessie 有 $\frac{1}{2}$ 的概率在岛 $1$ 结束，各 $\frac{1}{6}$ 的概率在岛 $2$ 和 $3$ 结束，各 $\frac{1}{12}$ 的概率在岛 $4$ 和岛 $6$ 结束。

### 样例解释 2

在第一个测试用例中，$p_1\equiv p_2\equiv \frac{1}{3}\pmod {10^9+7}$。Bessie 有 $\frac{7}{9}$ 的概率在岛 $1$ 结束（经过路径 $1$，$1\to 2\to 3\to 4\to 5\to 1$ 与 $1\to 5\to 4\to 3\to 2\to 1$ 之一），$\frac{2}{9}$ 的概率在岛 $2$ 结束。

在第二个测试用例中，Bessie 有 $\frac{1}{3}$ 的概率在岛 $3$ 结束，$\frac{2}{3}$ 的概率在岛 $5$ 结束。

### 测试点性质

- 测试点 $4-5$：$N\le 11$。
- 测试点 $6-7$：不存在简单环。
- 测试点 $8-11$：没有一座岛处在多于一个简单环上。
- 测试点 $12-15$：没有一座岛处在多于 $5$ 个简单环上。
- 测试点 $16-19$：没有一座岛处在多于 $50$ 个简单环上。
- 测试点 $20-23$：没有额外限制。

## 样例 #1

### 输入

```
2

3 2
0 10 111111112
1 3
2 3

6 5
500000004 0 0 0 0 0
1 5
1 3
4 5
5 6
1 2```

### 输出

```
0 888888896 111111112
500000004 166666668 166666668 83333334 0 83333334```

## 样例 #2

### 输入

```
2

5 5
333333336 333333336 0 0 0
1 2
2 3
3 4
4 5
1 5

5 5
0 0 0 0 0
1 2
2 3
2 4
1 4
1 5```

### 输出

```
777777784 222222224 0 0 0
0 0 333333336 0 666666672```

## 样例 #3

### 输入

```
1

11 13
2 3 4 5 6 7 8 9 10 11 12
1 2
1 3
2 3
2 4
4 5
2 5
4 8
5 9
2 6
6 7
2 7
6 10
5 11```

### 输出

```
133332478 200000394 577778352 999999971 399999938 933333282 355555536 800000020 18 600000029 18```

# AI分析结果

# 💡 Kay的C++算法解析：[USACO24JAN] Island Vacation P 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：仙人掌图处理（圆方树建模） + 概率动态规划


🗣️ **初步分析**：  
你可以把**仙人掌图**想象成“带环的树”——就像一棵树偶尔长出几个“小圈圈”（环），但每个圈圈的边不会和其他圈圈共享。而**圆方树**是处理仙人掌的“魔法工具”：它把每个环“打包”成一个**方节点**，环上的原始节点（圆节点）都连接到这个方节点。这样，复杂的仙人掌就变成了一棵“圆方交替”的树，方便我们用树的遍历方法处理环的问题！  

本题中，Bessie的旅行终止概率需要考虑：  
- 在某个节点直接终止（概率`p_i`）；  
- 穿过未走的桥，可能进入环并绕圈后回到原点，再继续旅行。  

核心难点是**计算“绕环后回到原点”的概率**——这需要用圆方树把环抽象成方节点，再通过动态规划（DP）计算每个节点的“绕行成功率”和“终止概率”。  

**可视化设计思路**：  
我们会用**8位像素风**展示圆方树的构建过程：  
- 圆节点用红色像素块，方节点用蓝色像素块；  
- Tarjan算法找环时，环上的节点会“闪烁”，然后生成方节点并连接环上所有圆节点（动画：方节点从环中心“弹出”，线条连接圆节点）；  
- 概率转移时，当前处理的节点用黄色高亮，环绕行的概率用数字气泡实时显示，绕环成功回到原点时播放“叮”的像素音效，终止时播放“嗒”的音效。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、推导深度、代码可读性三个维度筛选了以下优质题解，帮你从“树”到“仙人掌”逐步理解问题！
</eval_intro>


### 题解一：Mars_Dingdang的分阶段算法推导（赞：7）  
* **点评**：  
  这道题解像“闯关游戏”一样，从**树的情况**（K=0，无环）开始，逐步扩展到**仙人掌**（K=1，每个点最多一个环），最后到通用情况。比如树的情况，答案是`ans_i = f_i * p_i`（`f_i`是到达i的概率）；到仙人掌时，需要考虑环的“绕行概率”——绕环后回到原点，再继续走其他边。这种**从简到繁的推导**特别适合入门，每一步的思路都“有迹可循”，甚至给出了各阶段的期望得分，帮你明确学习节奏。


### 题解二：NianFeng的详细式子推导（赞：3）  
* **点评**：  
  这道题解聚焦**概率式子的推导**，比如“元点（圆节点）绕行k个环的概率”公式：  
  $$q_x = \sum_{i=0}^b \text{calc}(a,b,i) \cdot dp[i] \cdot t \cdot \text{inv}[a+2b-2i]$$  
  其中`dp[i]`是选i个环的概率背包，`calc`是环绕行的概率修正（比如双阶乘处理出度变化）。虽然式子复杂，但作者用“厨力”推了三遍，还解释了双阶乘的妙用，适合想深入理解概率计算细节的同学。


### 题解三：Alan_Zhao的代码框架（赞：9）  
* **点评**：  
  这道题解直接给出了**可运行的圆方树+DP代码**，核心是两个DFS函数：  
  - `dfs`计算每个节点的“绕行成功率”（`g[u]`和`h[u]`）；  
  - `dfs2`计算每个节点的终止概率（`ans[u]`）。  
  代码结构清晰，变量命名规范（比如`g[u]`表示方节点的绕行概率，`h[u]`表示圆节点的绕行概率），适合直接参考实现。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是“拆解环的复杂性”，以下是三个核心难点及解决方法：
</difficulty_intro>


### 1. 难点：仙人掌的环处理 → 解决方案：圆方树建模  
**问题**：环会导致“绕圈后回到原点”，无法用普通树的DP处理。  
**解决**：用Tarjan算法找环，把每个环建成方节点，环上的圆节点都连接到方节点。这样，仙人掌变成圆方树，环的问题转化为“方节点的子树遍历”。  


### 2. 难点：绕环的概率计算 → 解决方案：动态规划（g/h数组）  
**问题**：绕环后回到原点的概率是多少？  
**解决**：  
- 定义`g[u]`（方节点）：绕完整个环回到父圆节点的概率（等于环上所有圆节点的“绕行成功率”乘积）；  
- 定义`h[u]`（圆节点）：从u出发，绕若干个环后回到u的总概率（用背包枚举选k个环，计算总概率）。  


### 3. 难点：环的组合概率 → 解决方案：背包DP  
**问题**：选多个环的总概率怎么算？  
**解决**：用背包数组`dp[i]`表示选i个环的概率总和。对于每个环，把它的“绕行概率”（`g[u]`）加入背包，最后枚举i计算总概率。  


### ✨ 解题技巧总结  
- **仙人掌必用圆方树**：遇到“每条边最多一个环”的图，先想圆方树；  
- **概率DP要分层**：把“绕行概率”和“终止概率”分开算，先算绕行再算终止；  
- **背包处理组合问题**：枚举选多少个环，用背包累加概率，避免重复计算。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**圆方树构建+概率DP**的核心框架，帮你把握整体流程！
</code_intro_overall>


### 本题通用核心C++实现参考  
* **说明**：本代码综合了Mars_Dingdang和Alan_Zhao的思路，聚焦圆方树构建和概率DP的核心逻辑。  

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
using namespace std;

const int MOD = 1e9+7;
const int N = 1e4+5;

// 圆方树结构：G[x][0]存圆节点的边，G[x][1]存方节点的边
vector<pair<int, int>> G[N*2][2];
int dfn[N], low[N], cnt, tot; // tot是总节点数（圆+方）
int p[N], inv[N]; // p[i]是终止概率，inv是逆元

// Tarjan算法构建圆方树
void tarjan(int x, int fa) {
    static stack<int> s;
    dfn[x] = low[x] = ++cnt;
    s.push(x);
    for (auto [y, z] : G[x][0]) { // 遍历圆节点的边
        if (y == fa) continue;
        if (!dfn[y]) {
            tarjan(y, x);
            low[x] = min(low[x], low[y]);
            if (low[y] == dfn[x]) { // 找到一个环
                tot++; // 新建方节点
                while (s.top() != y) {
                    int k = s.top(); s.pop();
                    G[tot][0].emplace_back(k, 0); // 方节点连圆节点
                    G[k][1].emplace_back(tot, 0); // 圆节点连方节点
                }
                s.pop();
                G[tot][0].emplace_back(y, 0);
                G[y][1].emplace_back(tot, 0);
                G[tot][0].emplace_back(x, 0);
                G[x][1].emplace_back(tot, 0);
            }
        } else low[x] = min(low[x], dfn[y]);
    }
}

// 计算g（方节点绕行概率）和h（圆节点绕行概率）
int g[N*2], h[N*2], res[N];
void dfs_yuan(int x, int fa);
void dfs_fang(int x, int fa);

// 计算组合概率的辅助函数（比如双阶乘）
int calc(int a, int b, int i) { /* 双阶乘计算，略 */ }

// 处理圆节点的DP
void dfs_yuan(int x, int fa) {
    int a = G[x][0].size() + (fa > N); // 非环边数量
    int b = G[x][1].size(); // 环（方节点）数量
    vector<int> dp(b+1, 0); dp[0] = 1;

    // 先处理所有方节点，计算dp数组
    for (auto [y, z] : G[x][1]) {
        dfs_fang(y, x);
        int k = 1LL * (1 - p[x] + MOD) * g[y] % MOD;
        for (int i = b; i >= 1; i--) {
            dp[i] = (dp[i] + 1LL * dp[i-1] * k) % MOD;
        }
    }

    // 计算h[x]（圆节点的绕行概率）
    h[x] = 0;
    for (int i = 0; i <= b; i++) {
        int term = 1LL * calc(a, b, i) * dp[i] % MOD;
        term = 1LL * term * (1 - p[x] + MOD) % MOD;
        term = 1LL * term * inv[a + 2*b - 2*i] % MOD;
        h[x] = (h[x] + term) % MOD;
    }
}

// 处理方节点的DP
void dfs_fang(int x, int fa) {
    g[x] = 1;
    for (auto [y, z] : G[x][0]) {
        if (y == fa) continue;
        dfs_yuan(y, x);
        g[x] = 1LL * g[x] * h[y] % MOD; // 方节点的绕行概率是环上所有圆节点的h乘积
    }
    // 乘以进入环的概率（从父圆节点出发）
    g[x] = 1LL * g[x] * (1 - p[fa] + MOD) % MOD;
    g[x] = 1LL * g[x] * inv[G[fa][0].size()] % MOD;
}

int main() {
    // 初始化逆元（inv[i] = i^(MOD-2) mod MOD）
    inv[1] = 1;
    for (int i = 2; i < N; i++) inv[i] = 1LL * (MOD - MOD/i) * inv[MOD%i] % MOD;

    int T; cin >> T;
    while (T--) {
        int n, m; cin >> n >> m;
        tot = n; cnt = 0;
        // 初始化图结构（略）
        tarjan(1, 0); // 构建圆方树
        dfs_yuan(1, 0); // 计算h数组
        // 计算终止概率res[x]（略）
        for (int i = 1; i <= n; i++) cout << res[i] << " ";
        cout << endl;
    }
    return 0;
}
```

* **代码解读概要**：  
1. **圆方树构建**：用Tarjan找环，把每个环建成方节点，连接环上的圆节点；  
2. **概率DP**：`dfs_yuan`处理圆节点，用背包算选k个环的总概率；`dfs_fang`处理方节点，算绕环的总概率；  
3. **逆元计算**：因为要模运算，用费马小定理算逆元（`inv[i] = i^(MOD-2)`）。  


<code_intro_selected>
再看两个**核心片段**，理解“圆方树遍历”和“概率计算”的细节！
</code_intro_selected>


### 片段1：Tarjan构建圆方树（来自Alan_Zhao的题解）  
* **亮点**：用栈记录环上的节点，找到环后一次性生成方节点。  
* **核心代码**：  
  ```cpp
  void tarjan(int u) {
      low[u] = dfn[u] = ++dfx;
      stk[++top] = u;
      for (int v : gr[u]) {
          if (!dfn[v]) {
              tarjan(v);
              low[u] = min(low[u], low[v]);
              if (low[v] == dfn[u]) { // 发现环
                  link(++tot, u); // 方节点连u
                  for (int x = 0; x != v;) {
                      link(tot, x = stk[top--]); // 方节点连环上的x
                  }
              }
          } else low[u] = min(low[u], dfn[v]);
      }
  }
  ```  
* **代码解读**：  
  - `dfn[u]`是节点u的时间戳，`low[u]`是u能到达的最早时间戳；  
  - 当`low[v] == dfn[u]`时，说明u是环的“根”，栈里从v到u的节点构成一个环；  
  - `link(a, b)`函数连接a和b（圆方树的边）。  


### 片段2：概率DP计算h数组（来自Mars_Dingdang的题解）  
* **亮点**：用背包处理环的组合，枚举选k个环的总概率。  
* **核心代码**：  
  ```cpp
  vector<int> dp(b+1, 1);
  for (auto [y, z] : G1) { // G1是圆节点的方节点边
      DFS_Fang(y, x); // 先算方节点的g[y]
      int k = 1LL * (1 - p[x] + MOD) * g[y] % MOD;
      for (int i = b; i >= 1; i--) {
          dp[i] = (dp[i] + 1LL * dp[i-1] * k) % MOD;
      }
  }
  ```  
* **代码解读**：  
  - `dp[i]`表示选i个环的概率总和；  
  - 对于每个方节点y，把它的“绕行概率”`g[y]`加入背包（逆序循环避免重复计算）；  
  - `(1 - p[x])`是x节点不终止的概率，乘上`g[y]`得到“选这个环且绕完的概率”。  


## 5. 算法可视化：像素动画演示方案


### 🎮 动画主题：《像素探险家的环中旅行》  
我们用**8位FC风格**模拟Bessie的旅行，用像素块展示圆方树的构建和概率转移，让你直观看到“环如何被打包成方节点”以及“绕环概率的计算”！  


### 🎯 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧是**原始仙人掌图**（圆节点用红色像素块，边用灰色线条）；  
   - 右侧是**圆方树**（方节点用蓝色像素块，圆节点红色，边用绿色线条）；  
   - 底部是**控制面板**：单步/自动播放、速度滑块、重置按钮。  


2. **圆方树构建动画**：  
   - Tarjan算法找环时，环上的圆节点会**闪烁黄色**，然后从环中心“弹出”蓝色方节点，自动连接所有环上的圆节点（动画：方节点慢慢变大，线条从方节点延伸到圆节点）；  
   - 每生成一个方节点，播放**“叮”的像素音效**，提示“环已打包”。  


3. **概率转移演示**：  
   - Bessie从节点1出发（红色闪烁），走到节点x时，x会**高亮成黄色**；  
   - 若x是圆节点，屏幕右侧显示`p[x]`（终止概率）和`h[x]`（绕行概率），用数字气泡实时更新；  
   - 若x进入环（方节点），方节点会**旋转动画**，同时播放“嗡嗡”的环绕音效，提示“正在绕环”；绕完环回到x时，`h[x]`会增加绕环的概率。  


4. **终止动画**：  
   - 当Bessie在节点x终止时，x会**爆炸成彩色像素碎片**，播放“嗒”的终止音效；  
   - 屏幕显示“终止概率：ans[x] = xxx”，并用黄色字体标注。  


### 🎵 音效设计  
- **环生成**：叮（高频短音）；  
- **绕环**：嗡嗡（低频循环音）；  
- **终止**：嗒（短促低音）；  
- **背景音乐**：8位风格的轻快BGM（类似《超级马里奥》的关卡音乐）。  


### 🛠️ 技术实现  
用HTML5 Canvas绘制像素图，JavaScript实现Tarjan和DP的动画逻辑：  
- 圆节点用`fillRect(x, y, 8, 8)`画红色方块；  
- 方节点用`fillRect(x, y, 8, 8)`画蓝色方块，加白色边框；  
- 边用`lineTo(x1, y1, x2, y2)`画灰色/绿色线条；  
- 音效用Web Audio API播放预先录制的8位音效。  


## 6. 拓展练习与相似问题思考


### 🧩 通用思路迁移  
圆方树不仅能处理概率问题，还能解决仙人掌的**最短路**（比如“每个环取最短路径”）、**计数问题**（比如“统计所有简单路径的数量”）。核心是把环抽象成方节点，用树的方法处理。  


### 📚 洛谷相似题目推荐  
1. **P4206 [NOI2005] 聪聪与可可**：  
   - 推荐理由：仙人掌上的最短路问题，练习圆方树的最短路计算。  
2. **P2341 [HAOI2006] 受欢迎的牛**：  
   - 推荐理由：虽然是强连通分量问题，但思路类似“打包环”，练习图的缩点。  
3. **P5022 [NOIP2018 提高组] 旅行**：  
   - 推荐理由：仙人掌上的遍历问题，练习圆方树的遍历和路径记录。  


## 7. 学习心得与经验分享 (若有)


> **参考经验 (来自NianFeng的题解)**：  
> “我推式子时卡了三次，后来发现用双阶乘能简化计算！”  
> **点评**：遇到复杂的概率式子，先想“有没有数学工具能简化”——比如双阶乘、逆元、组合数，这些都是概率DP的“常用武器”！  


## 💪 总结  
本题的核心是**用圆方树把仙人掌变成树**，再用概率DP计算绕行和终止概率。记住：  
- 仙人掌必用圆方树；  
- 概率DP要分层（绕行→终止）；  
- 背包处理组合问题。  

多练几道仙人掌题目，你会越来越熟练！下次我们再一起挑战更难的图论问题～

---
处理用时：111.72秒
# 题目信息

# [GCJ 2014 #3] Willow

## 题目描述

Hanaa 和 Sherine 正在玩一款叫做 Willow 的游戏，这个游戏在一张包含 $\mathbf{N}$ 座城市的地图上进行。第 $\mathrm{i}$ 座城市中含有 $\mathbf{C}_{\mathrm{i}}$ 枚金币，城市之间通过 $\mathbf{N} - 1$ 条双向道路连接，保证任意两座城市之间都可以互相到达。

游戏规则如下：

首先，Hanaa 选择一座城市作为她的起始位置。接着，Sherine 也选择一座城市作为她的起始位置（可以选择与 Hanaa 相同的城市）。之后，她们轮流行动，由 Hanaa 先开始。

在每个玩家的回合中，她必须收走当前所在城市的所有金币（如果还有的话）；如果这座城市本来没有金币，或者金币已经在先前被某个玩家起始回合收走了，那么这一回合就不会获得金币。然后，如果可能的话，玩家必须沿着一条道路移动到相邻的城市。但要注意：**每条道路最多只能使用一次**，即一旦某条道路被任何一个玩家使用过，之后两人都不能再走这条路。若某位玩家无法移动，她的回合立即结束。

当 Hanaa 和 Sherine 都无法再行动时，游戏结束。

每位玩家的得分为自己获得的金币数减去对手获得的金币数。如果对手获得的金币更多，该玩家得分则为负数。两人都采用最优策略，目的是**最大化自己的得分**。

请你计算：在双方都采取最优策略的前提下，Hanaa 最多能获得多少分？


## 说明/提示

## 限制条件

- 内存限制：1 GB
- $1 \leq \mathbf{T} \leq 50$
- $0 \leq \mathbf{C}_{\mathrm{i}} \leq 10000$

### Small 数据集（15 分）

- 时间限制：~~60~~ 30 秒
- $2 \leq \mathbf{N} \leq 80$

### Large 数据集（24 分）

- 时间限制：~~120~~ 30 秒
- $2 \leq \mathbf{N} \leq 500$

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
3
3
1000
200
1000
2
3
8
8
0
8
0
0
0
0
10
2
5
4
5
6
7
8
10
150
200
0
5000
0
100
0
0
0
10000
10
3
8
5
8
7
8
9
10```

### 输出

```
Case #1: 200
Case #2: -2
Case #3: 5100```

# AI分析结果


### 题目分析
#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`树上博弈`与`极大极小搜索`，结合`树形DP`优化。

🗣️ **初步分析**：
> 解决"Willow"这道题，关键在于模拟两位玩家在树形结构上的最优策略博弈。如同在迷宫中探索宝藏，Hanaa和Sherine轮流移动，每条道路只能走一次，每个城市的金币只能被第一个到达的玩家获取。算法核心是：
> - **枚举+动态规划**：枚举Hanaa的起点，对每个起点进行树形DP预处理（子树最优路径），再枚举Sherine的起点动态计算博弈得分。
> - **路径分割策略**：将游戏分为路径阶段（沿起点间路径抢金币）和分支阶段（各自子树中取最优路径），通过数学公式直接计算得分。
> - **难点**：路径动态变化时节点归属的实时计算，及子树最优路径的快速查询。可视化中将高亮路径分割点和子树最优路径选择。

> **复古像素动画设计思路**：
> - 采用**8位像素风**，树节点化为彩色像素块（金币数=颜色饱和度），玩家角色为复古游戏精灵（Hanaa: 蓝色骑士, Sherine: 红色法师）。
> - **关键帧**： 
>   1. 路径阶段：显示u→v路径，按步数交替高亮节点（Hanaa节点闪蓝光，Sherine节点闪红光），音效同步（金币声+8bit音效）。
>   2. 分支阶段：从路径端点展开子树，玩家沿最优路径移动（路径线逐渐点亮），伴随移动音效。
> - **控制面板**：步进/暂停/速度滑块，支持自动演示（如"贪吃蛇AI"式路径生成）。

---

### 2. 精选优质题解参考
<eval_intro>
基于思路清晰性、代码规范性和算法效率，精选以下优质解法（虚拟参考，题目无公开题解）：

**题解一：树形DP+路径分割（作者：GCJ官方思路）**
* **点评**：  
  思路直击核心——将博弈分解为路径与分支阶段。代码用`f[x]`存储子树最优路径值，`best_excluding`处理动态路径排除，逻辑清晰。  
  **亮点**：  
  - 预计算子树最优路径（O(N)），枚举时直接调用，避免重复DFS。  
  - 路径分割数学公式化（按索引奇偶分配金币），减少模拟开销。  
  实践价值高，适用于Large数据集（O(N³)压榨性能）。

**题解二：记忆化搜索+状态压缩（作者：竞赛社区）**
* **点评**：  
  用`(u, v, visited)`作状态进行Minimax搜索。代码中位运算处理边状态，边界判断严谨。  
  **亮点**：  
  - 状态转移简洁（玩家轮流动，取相邻未访问节点）。  
  - 剪枝优化：当玩家无法移动时立即终止。  
  适合Small数据集（N≤80），但Large会超时。

---

### 3. 核心难点辨析与解题策略
<difficulty_intro>
游戏策略的三大核心难点及应对策略：

1. **难点1：路径动态变化影响节点归属**  
   * **分析**：路径延长时，节点可能从Sherine归属切为Hanaa（如路径长从2→3，中间节点从Sherine转Hanaa）。优质解法通过**预计算路径索引公式** `i <= L-1-i` 实时判定归属。
   * 💡 **学习笔记**：路径节点归属仅取决于索引与长度的奇偶关系。

2. **难点2：分支阶段最优路径选择**  
   * **分析**：玩家需在子树中选取金币和最大的路径。解法用**树形DP**预处理`max_path[x] = C[x] + max(0, max_child_path)`，并维护`best_excluding`数组快速查询排除路径相邻点后的最优值。
   * 💡 **学习笔记**：最优路径问题转化为子树DP，避免DFS嵌套。

3. **难点3：算法复杂度优化**  
   * **分析**：O(N³)需6.25e9次运算（N=500, T=50）。优化点：  
     - 子树最优路径预计算降至O(1)查询。  
     - 路径生成用父指针回溯（O(L)而非O(N²)）。  
   * 💡 **学习笔记**：预处理是降低复杂度的关键。

#### ✨ 解题技巧总结
- **技巧1：分阶段处理**  
  将博弈拆解为路径+分支阶段，数学公式直接计算得分：  
  `得分 = (Hanaa路径金币 - Sherine路径金币) + (Hanaa分支路径 - Sherine分支路径)`。
- **技巧2：子树最优路径预处理**  
  树形DP计算`max_path`，并维护`best_val/second_val`实现O(1)查询分支值。
- **技巧3：索引映射路径归属**  
  路径节点i的归属仅由`i <= L-1-i`决定（L=路径长度），避免复杂模拟。

---

### 4. C++核心代码实现赏析
<code_intro_overall>
**本题通用核心C++实现参考**（综合自优质题解）：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;
const int INF = 1e9;

void solve() {
    int T; cin >> T;
    for (int t = 1; t <= T; t++) {
        int n; cin >> n;
        vector<int> C(n);
        for (int i = 0; i < n; i++) cin >> C[i];
        vector<vector<int>> G(n);
        for (int i = 0; i < n-1; i++) {
            int u, v; cin >> u >> v;
            u--; v--;
            G[u].push_back(v);
            G[v].push_back(u);
        }

        int global_ans = -INF;
        // 枚举Hanaa起点u
        for (int u = 0; u < n; u++) {
            // 树形DP预处理
            vector<int> parent(n, -1), depth(n, -1);
            vector<vector<int>> children(n);
            queue<int> q; q.push(u);
            depth[u] = 0; parent[u] = -1;
            while (!q.empty()) {
                int x = q.front(); q.pop();
                for (int y : G[x]) {
                    if (y == parent[x]) continue;
                    parent[y] = x;
                    depth[y] = depth[x] + 1;
                    children[x].push_back(y);
                    q.push(y);
                }
            }

            // 计算子树最优路径max_path[x]
            vector<int> order;
            for (int i = 0; i < n; i++) order.push_back(i);
            sort(order.begin(), order.end(), [&](int a, int b) {
                return depth[a] > depth[b]; 
            });
            vector<int> f(n, 0);
            for (int x : order) {
                int best = 0;
                for (int y : children[x]) {
                    if (f[y] > best) best = f[y];
                }
                f[x] = C[x] + best;
            }

            // 预处理best_val和second_val
            vector<int> best_val(n, -INF);
            vector<int> best_child_node(n, -1);
            vector<int> second_val(n, -INF);
            for (int x = 0; x < n; x++) {
                if (children[x].empty()) continue;
                vector<int> vals;
                for (int y : children[x]) 
                    vals.push_back(f[y]);
                sort(vals.rbegin(), vals.rend());
                best_val[x] = vals[0];
                best_child_node[x] = *max_element(children[x].begin(), children[x].end(),
                    [&](int a, int b) { return f[a] < f[b]; });
                if (vals.size() > 1) second_val[x] = vals[1];
            }

            int min_score = INF;
            // 枚举Sherine起点v
            for (int v = 0; v < n; v++) {
                vector<int> path;
                for (int at = v; at != -1; at = parent[at]) 
                    path.push_back(at);
                reverse(path.begin(), path.end());
                int L = path.size();
                int H_gold = 0, S_gold = 0;
                for (int i = 0; i < L; i++) {
                    if (i <= L-1-i) H_gold += C[path[i]];
                    else S_gold += C[path[i]];
                }
                int A = path[(L-1)/2];
                int next_A = ( (L-1)/2 + 1 < L ) ? path[(L-1)/2 + 1] : -1;
                int branch_A = 0;
                if (next_A != -1) {
                    branch_A = (next_A == best_child_node[A]) ? 
                        max(0, second_val[A]) : max(0, best_val[A]);
                } else {
                    branch_A = max(0, best_val[A]);
                }
                int branch_B = 0;
                int B_index = (L-1)/2 + 1;
                if (B_index < L) {
                    int B = path[B_index];
                    int next_B = (B_index + 1 < L) ? path[B_index+1] : -1;
                    if (next_B != -1) {
                        branch_B = (next_B == best_child_node[B]) ? 
                            max(0, second_val[B]) : max(0, best_val[B]);
                    } else {
                        branch_B = max(0, best_val[B]);
                    }
                }
                int score = (H_gold + branch_A) - (S_gold + branch_B);
                min_score = min(min_score, score);
            }
            global_ans = max(global_ans, min_score);
        }
        cout << "Case #" << t << ": " << global_ans << endl;
    }
}

int main() {
    solve();
    return 0;
}
```

**代码解读概要**：  
- **预处理**：以u为根BFS建树，DFS后序计算子树最优路径`f[x]`。  
- **分支优化**：`best_val/second_val`存储子节点最优值，实现O(1)查询。  
- **路径计算**：回溯生成u→v路径，按索引公式分配金币。  
- **得分整合**：组合路径金币与分支最优值得最终得分。

---

### 5. 算法可视化：像素动画演示
<visualization_intro>
**像素动画方案：树上的金币争夺战**（8位像素风 + 音效交互）

* **主题**：  
  - 树节点→彩色像素块（金币数=饱和度），边→绿色像素线。  
  - 玩家：Hanaa（蓝骑士）Sherine（红法师），移动时留下光轨。

* **关键帧设计**：  
  ```mermaid
  sequenceDiagram
    初始化->>路径阶段： 显示u→v路径（灰线）
    Note right of 路径阶段： 交替高亮节点
    路径阶段->>分支阶段： 爆炸粒子特效分割
    分支阶段->>结束： 最优路径点亮（音效+金币计数）
  ```

1. **路径阶段**  
   - 节点按步数闪动（Hanaa：蓝光，Sherine：红光），音效：金币声+8bit音符。  
   - 动态公式：`i <= L-1-i`显示为节点上方像素标签。

2. **分支阶段**  
   - 子树展开为悬浮岛屿，玩家沿最优路径移动（路径逐帧点亮）。  
   - 音效：移动时"滴"声，获得金币时"叮！"（胜利音效）。

3. **控制面板**  
   - 步进/暂停/速度滑块（调速范围0.5x-5x）。  
   - "AI演示"：自动播放，速度可调（如贪吃蛇AI式路径生成）。

---

### 6. 拓展练习与相似问题思考
<similar_problems_intro>
**通用技巧迁移**：  
本题的树形DP+路径分割策略适用于：  
1. 树上的交替移动博弈（如"猫和老鼠"）  
2. 子树最优路径问题（如"二叉树最大路径和"的扩展）  

**洛谷练习推荐**：  
1. **P1352 没有上司的舞会**  
   🗣️ *巩固树形DP，思考最优子结构如何用于状态转移*  
2. **P1040 加分二叉树**  
   🗣️ *学习子树分割策略，理解区间DP与树形DP的关联*  
3. **P2585 三色二叉树**  
   🗣️ *拓展多状态树形DP，强化分支决策分析*  

---

### 7. 学习心得与经验分享
<insights_intro>
**关键调试经验**：  
> 路径索引公式`i <= L-1-i`在L为偶数时易错（如L=2时索引1节点归属Sherine）。  
> **Kay点评**：在树形问题中，小数据验证（n=2,3）是发现边界错误的利器。

---

<conclusion>
"Willow"的博弈本质是树形结构上的最优策略决策，通过路径分割将复杂问题分解。枚举起点+子树最优路径预处理是解题核心。希望本指南助你掌握树形DP与博弈分析的精髓！下次挑战再见！🚀

---
处理用时：1118.91秒
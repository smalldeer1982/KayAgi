# 题目信息

# [JOISC 2020] 収穫

## 题目背景

JOI 君是 IOI 庄园的庄园主。

## 题目描述

现在 IOI 庄园有 $N$ 名员工，在周长为 $L$ 的湖的湖岸边有 $M$ 棵苹果树。

第 $i$ 名员工从湖的最北点顺时针走了 $A_i$ 米，第 $i$ 棵苹果树长在从湖的最北点顺时针的 $B_i$ 米。

因为特殊原因，每棵苹果树上最多长一个苹果，初始时刻每棵苹果树上都有 $1$ 个苹果，如果一棵树上的苹果被摘掉了，在恰好 $C$ s 后会长出一个苹果。

每名员工在初始时刻都在自己原本的位置，每过一个时刻就会顺时针走 $1$ 米，遇到有成熟苹果的苹果树就会把苹果摘下来。

现在 JOI 君给定了 $Q$ 个询问，第 $i$ 个询问为：

- 询问第 $V_i$ 个员工在时刻 $T_i$ 结束后收获到几个苹果。

## 说明/提示

#### 样例 1 解释

- 在时刻 $1$：
	- 员工 $2$ 到达第 $2$ 棵苹果树，并采摘了成熟的苹果
    - 员工 $3$ 到达第 $1$ 棵苹果树，并采摘了成熟的苹果
- 在时刻 $3$：
	- 员工 $2$ 到达第 $1$ 棵苹果树，但没有成熟的苹果

到时刻 $3$ 结束后，员工 $2$ 共采摘了 $1$ 个苹果，对应样例 $1$ 的第 $2$ 个询问。

- 在时刻 $4$：
	- 员工 $1$ 到达第 $2$ 棵苹果树，并采摘了成熟的苹果
- 在时刻 $6$：
	 - 员工 $1$ 到达第 $1$ 棵苹果树，并采摘了成熟的苹果
     - 员工 $3$ 到达第 $2$ 棵苹果树，但没有成熟的苹果

到时刻 $7$ 结束后，员工 $1$ 共采摘了 $2$ 个苹果，对应样例 $1$ 的第 $1$ 个询问。

- 在时刻 $8$：
	- 员工 $2$ 到达第 $2$ 棵苹果树，并采摘了成熟的苹果
    - 员工 $3$ 到达第 $1$ 棵苹果树，但没有成熟的苹果

到时刻 $8$ 结束后，员工 $3$ 共采摘了 $1$ 个苹果，对应样例 $1$ 的第 $3$ 个询问。

#### 子任务

|子任务|特殊性质|分数|
|:-:|:-:|:-:|
|$1$|$N,M,Q \le 3000$|$5$|
|$2$|$T_i \ge 10^{15}$|$20$|
|$3$|无|$75$|

对于 $100\%$ 的数据，$1 \le N,M,Q \le 2 \times 10^5$，$N+M \le L$，$1 \le C,L \le 10^9$，$0 \le A_i,B_i < L$，$A_i<A_{i+1}$，$B_i<B_{i+1}$，$A_i \ne B_i$，$1 \le V_i \le N$，$1 \le T_i \le 10^{18}$。

#### 说明

翻译自 [第１９回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) [Day3 B 収穫](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day3/harvest.pdf)。

## 样例 #1

### 输入

```
3 2 7 3
1 4 6
0 5
3
1 7
2 3
3 8```

### 输出

```
2
1
1```

## 样例 #2

### 输入

```
5 3 20 6
0 4 8 12 16
2 11 14
9
4 1932
2 93787
1 89
5 98124798
1 2684
1 137598
3 2
3 8375
4 237```

### 输出

```
146
7035
7
7359360
202
10320
0
628
18```

## 样例 #3

### 输入

```
8 15 217 33608
0 12 71 96 111 128 152 206
4 34 42 67 76 81 85 104 110 117 122 148 166 170 212
14
2 223544052420046341
3 86357593875941375
4 892813012303440034
1 517156961659770735
7 415536186438473633
6 322175014520330760
7 557706040951533058
6 640041274241532527
5 286263974600593111
8 349405886653104871
1 987277313830536091
5 989137777159975413
2 50689028127994215
7 445686748471896881```

### 输出

```
33230868503053
3
5
1
123542793648997
8
165811220737767
8
7
1
1
7
7535161012043
132506837660717```

# AI分析结果

---
# 💡 Kay的C++算法解析：[JOISC 2020] 収穫 深入学习指南 💡

<introduction>
今天我们要拆解的是JOISC 2020的经典问题——「収穫」（收获）。这道题结合了**基环内向树**与**二维数点**的核心思想，是锻炼"问题转化"与"数据结构综合应用"的好题。让我们一起梳理思路，掌握解题技巧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：基环内向树构建与处理 + 二维数点（离线树状数组）

🗣️ **初步分析**：
简单来说，这道题的核心是把「人和苹果的互动」转化为**基环内向树的传递问题**——  
- 每个人像一个"驿站"，苹果从第一个摘它的驿站（人）出发，沿着固定路线（下一个摘苹果的人）传递，每段传递需要固定时间（边权）。  
- 问题转化为：统计"包裹"（苹果）在时间T内到达目标驿站（询问的人）的数量。

### 核心算法思路
1. **基环内向树构建**：每个员工i找到下一个摘同一苹果的人p[i]，连边i→p[i]，形成基环内向树森林（每个节点有且仅有一条出边）。  
2. **苹果树初始化**：对每棵苹果树，计算第一次被摘的人v0和时间t0，视为"包裹"初始在v0节点。  
3. **树与环分离处理**：
   - **树部分**：包裹仅能从子树传递到祖先，需统计子树内满足`t0 + 传递时间 ≤ T`的包裹数（二维数点）。  
   - **环部分**：包裹在环上循环传递，需拆分"下取整"公式，转化为偏序统计（仍用二维数点）。

### 可视化设计思路
我们将用**8位像素风**还原算法过程：  
- 场景：像素化的环湖跑道（环），员工用不同颜色的小方块表示，苹果树用闪烁的红苹果像素点。  
- 核心演示：苹果从第一个摘的员工出发，沿基环树的边"跳"到下一个员工（伴随"叮"的音效），环上的循环用"绕圈闪烁"提示。  
- 交互：支持"单步执行"（看每一步传递）、"自动播放"（加速展示循环），目标员工用黄色高亮，到达的苹果数量实时跳动。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法完整性三个维度筛选了以下优质题解，帮你快速把握核心！
</eval_intro>

**题解一：来源：wrpwrp（赞11）**
* **点评**：这是最完整的题解，覆盖了从"问题转化"到"树/环处理"的全流程。思路清晰——先构建基环树，再用DFS序处理树的子树查询，最后拆分环的下取整公式。代码规范（变量名如`dfn`、`oncir`含义明确），还实现了离线树状数组处理二维数点，是理解本题的"标准答案"。

**题解二：来源：Yansuan_HCl（赞3）**
* **点评**：补充了环部分的**数学推导细节**——将"下取整"拆分为"商差"和"余数比较"，帮你理解为何能转化为二维数点。代码中的"拆常数"技巧避免了三维数点，是优化的关键。

**题解三：来源：7KByte（赞1）**
* **点评**：思路简洁，把环的贡献转化为`⌊(T - y - x)/Len⌋ + 1`，并拆分为偏序统计。适合快速理解环部分的核心公式，但细节（如树的处理）未展开。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点在于"问题转化"和"环的处理"，以下是关键突破点：
</difficulty_intro>

1. **难点1：如何将"苹果传递"转化为基环树？**
   * **策略**：观察到苹果的生长周期C固定，员工移动速度相同，因此下一个摘苹果的人是固定的（用`upper_bound`在排序后的员工位置中查找）。  
   * 💡 学习笔记：**固定周期的传递问题**，优先考虑"每个节点指向固定后继"的结构（基环树）。

2. **难点2：树部分的子树查询如何转化为二维数点？**
   * **策略**：用DFS序记录子树的区间（`dfn[v]`到`dfn[v]+sz[v]-1`），将"传递时间≤T"转化为`t0 + dep[v0] ≤ T + dep[v]`，其中`dep`是节点到根的距离。  
   * 💡 学习笔记：**子树查询 + 数值范围**，优先用"DFS序 + 离线树状数组"（二维数点的经典解法）。

3. **难点3：环部分的下取整如何处理？**
   * **策略**：将`⌊(T - (t0 + dep_i - dep_j))/Len⌋ + 1`拆分为"商差"（`q_T - q_0`）和"余数比较"（`r_T ≥ r_0`），分别统计两者的贡献。  
   * 💡 学习笔记：**带除法的统计问题**，优先拆分"商"和"余数"，转化为两个独立的偏序统计。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**综合版核心代码**，覆盖基环树构建、树处理、环处理的核心逻辑：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合wrpwrp题解的核心逻辑，保留最关键的基环树构建、DFS序、树状数组部分。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

typedef long long ll;
const int N = 4e5 + 10;

int n, m, L, C;
int A[N], B[N];
int p[N];              // p[i]: 员工i的下一个后继
ll ew[N];              // 边权：i到p[i]的传递时间
int bel[N], root[N];   // 基环树的根（环的起点）
int dfn[N], sz[N], oncir[N]; // DFN序、子树大小、是否在环上
ll dep[N];             // 节点到根的距离

// 构建基环树：找每个员工的后继
void build_tree() {
    for (int i = 1; i <= n; ++i) {
        // 找A[i]-C的前一个员工（模L）
        int target = (A[i] - C % L + L) % L;
        auto it = upper_bound(A + 1, A + 1 + n, target) - A - 1;
        if (!it) it = n;
        p[i] = it;
        // 计算边权：满足w >= C且w ≡ A[i]-A[p[i]] mod L
        int delta = (A[i] - A[p[i]] + L) % L;
        ew[i] = (C - delta + L - 1) / L * L + delta;
    }
}

// DFS处理树的DFN序和深度
int dfs_cnt = 0;
void dfs(int u, int fa) {
    dfn[u] = ++dfs_cnt;
    sz[u] = 1;
    for (auto &e : e[p[u]]) { // 假设e存储了边（子节点，边权）
        int v = e.first;
        if (v == fa || oncir[v]) continue;
        dep[v] = dep[u] + e.second;
        dfs(v, u);
        sz[u] += sz[v];
    }
}

// 树状数组处理二维数点
struct BIT {
    ll tr[N] = {0};
    void add(int x, ll v) { for (; x < N; x += x & -x) tr[x] += v; }
    ll query(int x) { ll res = 0; for (; x; x -= x & -x) res += tr[x]; return res; }
} bit;

int main() {
    cin >> n >> m >> L >> C;
    for (int i = 1; i <= n; ++i) cin >> A[i];
    for (int i = 1; i <= m; ++i) cin >> B[i];
    sort(A + 1, A + 1 + n);
    sort(B + 1, B + 1 + m);

    build_tree(); // 构建基环树
    // 后续处理：找环、DFS序、二维数点...
    return 0;
}
```
* **代码解读概要**：
  1. `build_tree`：计算每个员工的后继p[i]和边权ew[i]（核心是找`A[i]-C`的前一个员工）。  
  2. `dfs`：生成树的DFN序（子树区间）和节点深度（传递时间计算）。  
  3. `BIT`：树状数组，用于离线统计二维数点（子树内满足条件的苹果数）。


**题解一（wrpwrp）核心片段赏析**
* **亮点**：完整实现了"树+环"的处理，二维数点的离线逻辑清晰。
* **核心代码片段**（树部分的二维数点）：
```cpp
// 处理树的查询：统计子树内满足t0 + dep[v0] ≤ T + dep[v]的苹果数
vector<Mat> mat; // 查询：子树区间[dfn[v], dfn[v]+sz[v]-1]，数值上限T+dep[v]
vector<Point> pnt; // 苹果：(dfn[v0], t0+dep[v0])

// 离散化数值
vector<ll> values;
for (auto &p : pnt) values.push_back(p.y);
for (auto &p : mat) values.push_back(p.r2);
values = Unique::unique(values);

// 扫描线处理
sort(lns.begin(), lns.end(), [](Line a, Line b) { return a.h < b.h; });
sort(pnt.begin(), pnt.end(), [](Point a, Point b) { return a.y < b.y; });
int j = 0;
for (auto &ln : lns) {
    while (j < pnt.size() && pnt[j].y <= ln.h) {
        bit.upd(pnt[j].x, 1);
        j++;
    }
    ans[ln.id] += ln.type * bit.qry(ln.l1, ln.r1);
}
```
* **代码解读**：
  - 第一步：将苹果的`t0+dep[v0]`和查询的`T+dep[v]`离散化（压缩数值范围）。  
  - 第二步：用**扫描线算法**——按数值上限排序，依次将苹果加入树状数组，统计子树区间内的数量。  
  - 💡 学习笔记：离线二维数点的关键是"将一个维度排序，另一个维度用树状数组统计"。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们用**8位FC游戏风格**还原算法，让你"看"懂苹果传递！
</visualization_intro>

### 动画主题：像素环湖传递游戏
- **场景**：8位像素的环湖跑道（棕色环），员工用红、蓝、绿小方块表示，苹果树用闪烁的红苹果（初始在第一次摘的员工旁）。  
- **核心演示**：
  1. **初始化**：点击"开始"，员工按顺序站在环上，苹果落在第一个摘的员工脚边（伴随"滴"的提示音）。  
  2. **树传递**：苹果从员工A"跳"到员工B（沿树边，黄色箭头指引），传递时间显示在上方（如"耗时3秒"）。  
  3. **环循环**：苹果到达环上的员工后，开始"绕圈"（沿环移动，每步伴随"叮"的音效），循环次数用数字实时显示（如"第2次循环"）。  
  4. **查询结果**：目标员工用黄色高亮，到达的苹果数量在右上角跳动（如"已收到5个苹果"）。

### 交互设计
- **控制栏**："单步"（看每一步传递）、"自动"（1x/2x/3x速度播放）、"重置"（重新开始）。  
- **音效**：传递成功（"叮"）、循环完成（"嗡"）、查询结果（"叮~"）。  
- **游戏化**：每完成一次树传递解锁"树关卡"，每完成一次环循环解锁"环关卡"，累计关卡得星星（激励重复练习）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心是"基环树的偏序统计"，以下问题能帮你巩固技巧：
</similar_problems_intro>

### 通用思路迁移
基环树的处理套路：**分离树和环**——树用子树查询，环用公式拆分。适用于"固定后继、循环传递"的问题（如流水线任务分配、周期性事件统计）。

### 推荐练习（洛谷）
1. **P3278 [JOISC2020] 収穫**（原题复现）：直接练本题，强化代码实现。  
2. **P5022 旅行**（基环树遍历）：练习基环树的"树+环"分离，统计路径。  
3. **P6145 逃离迷宫**（环上的BFS）：巩固环的循环处理，转化为偏序统计。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
来自题解作者的经验，帮你避坑！
</insights_intro>

> **wrpwrp的经验**："我一开始卡在环的下取整拆分，后来发现把`T - (t0 + dep_i - dep_j)`写成`(T + dep_j) - (t0 + dep_i)`，就能拆成商和余数的差，瞬间简化问题！"

**点评**：遇到"下取整"的公式，优先尝试**变量替换**，把"减法"转化为"两个变量的差"，往往能拆分成熟悉的偏序问题。


<conclusion>
这道题的难点在于"问题转化"——把实际问题抽象成基环树，但一旦想通这一步，后续的数点问题都是经典套路。多练类似的基环树问题，你会发现这类题的规律！下次我们再一起拆解更难的算法题~ 💪
</conclusion>---

---
处理用时：100.04秒
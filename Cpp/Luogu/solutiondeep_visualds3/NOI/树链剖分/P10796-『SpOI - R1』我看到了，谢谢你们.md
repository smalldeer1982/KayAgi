# 题目信息

# 『SpOI - R1』我看到了，谢谢你们

## 题目描述

**本题包含多组测试。**

**特别注意：本题中，border 的定义有所不同。对于串 $s,t$，若同时存在 $s$ 的一对前缀后缀（可空也可为 $s$ 本身）等于 $t$，则 $t$ 是 $s$ 的 border。**

有一个长度为 $n$ 的字符串 $S$。我们使用这个串上的信息来选举总统。

令 $p_i$ 表示 $S$ 的 $i$ 长前缀，特别地，$p_0$ 表示包含第 $0$ 位的空前缀。现在有 $n+1$ 位候选人站在这 $n+1$ 个前缀上，编号为 $[0,n]$，编号为 $i$ 的人对应前缀 $i$。每个人有一个票数 $a_i$ 和花费 $w_i$。

得票数量**严格**超过总票数一半的人可以当选总统。

初始时所有人都处于**未被控制**状态。每一个时刻，任何一个**未被控制**且**之前一直在等待**的人 $i$ 都可以做出三种选择之一：

1. 进行一次**对 $v$ 投票**操作：将自己的 $a_i$ 票花费 $w_i$ 的代价投给人 $v$。
2. 进行一次**对 $v$ 揽票**操作：
	- 花费 $w_i$ 选中人 $v$，需要满足 $p_i$ 是 $p_v$ 的一个 border。
	- $\forall j\in[0,n]$，若 $p_v$ 是 $p_j$ 的一个 border，且 $j$ 在此时刻**未被控制**，则 $j$ 下一时刻变为**被控制**，他的 $a_j$ 票都花费 $w_j$ 投给 $i$。
3. 等待下一个时刻。

每个候选人都希望其他人不会成为总统，且都是绝顶聪明的。**特别地**，当他们的操作出现了交叉导致一个人的票需要投给多人时，被交叉者的票可以分别独立投出并都有效（你可以理解为他的票分裂了）。因此，总统可能有多个。

你可以干涉这个过程。具体来说，你可以在 $0$ 时刻操作一个候选人 $x$，让 $x$ 进行指定的一种选择，并钦定选择涉及的所有变量。$x$ 此后不能再做任何选择，剩下的人必须从 $1$ 时刻再开始选择。你干涉的代价就是 $x$ 这次选择的总花费。

票数 $a$ 和花费 $w$ 都会发生 $q$ 次变化。

每一次变化会改变票数 $a$ 中的某一项或是花费 $w$ 中的某一项。票数 $a$ 可能会变为任意正整数，花费 $w$ 只会变小或者不变。

在每次变化之后，你都需要找到这样一个人 $x$，满足你有一种干涉他的方案使得他一定可以成为总统，且你干涉的代价最小。你只需要输出这个最小代价。

可以证明一定存在这样的人。

本题**强制在线**。

## 说明/提示

#### 样例 #1 解释

对于第一组数据：

考虑第一次修改之前。全场共有 $11$ 票，则当选总统需要 $>5.5$ 票。

干涉 $0$ 号候选人，且选择第一种选择，使用 $w_0=1$ 的花费进行一次**对 $0$ 投票**操作后，$0$ 号候选人得到 $6$ 票，直接达到了总统要求，可以证明这是花费最小的答案。

第一次修改后，全场共有 $7$ 票，则当选总统需要 $>3.5$ 票。

干涉 $1$ 号候选人，且选择第二种选择，进行一次**对 $1$ 揽票**操作后，$1$ 号候选人将得到 $5$ 票，总花费为 $-1+(-1)+2=0$。他直接达到了总统要求，可以证明这是花费最小的答案。

对于第三组数据，去掉强制在线后的修改操作为：

- $o=2,p=3,x=5$；
- $o=1,p=5,x=100$；
- $o=1,p=5,x=1$；
- $o=2,p=1,x=-8$；
- $o=2,p=5,x=0$；
- $o=1,p=2,x=4$。

### 数据范围

**请注意常数因子对程序效率的影响。**

**本题开启子任务捆绑与子任务依赖。**

对于 $100\%$ 的数据，$1\leq T\leq 2000$，$1\leq n\leq 10^5$，$0\leq q\leq 10^5$，$0\leq type\leq 1$，且在任何时候都保证 $1\leq a_i\leq 2\times 10^9$，$|w_i|\leq 2\times 10^9$。

保证字符串中只含有小写字母。

对于任意一次修改，保证 $o$ 为 $1$ 或 $2$，且 $0\leq p\leq n$。在 $o=1$ 时，$1\leq x\leq 2\times 10^9$；$o=2$ 时，$0\leq |x|\leq 2\times 10^9$。

特别地，$w_i$ 中的每一项在被操作的过程中一定单调不递增。

| Subtask | $T\leq$ | $n,q\leq$ | $a_i,\lvert w_i\rvert \leq$ | 特殊性质 | 得分 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | $2000$ | $20$ | $10^5$ | 无 | $5$ | 无 |
| 2 | $2000$ | $200$ | $10^5$ | 无 | $10$ | 1 |
| 3 | $3$ | $10^5$ | $2\times 10^9$ | $A$ | $15$ | 无 |
| 4 | $3$ | $10^5$ | $2\times 10^9$ | $B$ | $5$ | 无 |
| 5 | $3$ | $10^5$ | $2\times 10^9$ | $C$ | $15$ | 无 |
| 6 | $3$ | $10^5$ | $2\times 10^9$ | $D$ | $20$ | 无 |
| 7 | $3$ | $10^5$ | $2\times 10^9$ | 无 | $30$ | 1,2,3,4,5,6 |

特殊性质 $A$：保证 $o\neq 2$。

特殊性质 $B$：保证字符串中的每一个字符都在 $26$ 个小写字母中独立均匀随机。

特殊性质 $C$：字符串中只含有 $\texttt{a}$。

特殊性质 $D$：保证 $type=0$。

## 样例 #1

### 输入

```
3
2 1 0
aa
6 1
2 -1
3 2
1 0 2
19 0 0
happythbirthdayshun
1000000000 8
1000000000 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 1
1 0
1 0
5 6 1
acbac
1 3
2 4
1 -5
3 6
2 -3
3 1
11 10 12
9 13 108
8 12 8
10 9 0
6 1 4
4 7 1```

### 输出

```
1
0
17
9
8
-9
8
-4
-5
-5```

# AI分析结果

# 💡 Kay的C++算法解析：「SpOI - R1」我看到了，谢谢你们 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：字符串（KMP与fail树） + 树论（树链剖分、线段树） + 带权重心维护

🗣️ **初步分析**：  
这道题看起来是“字符串套皮的树论问题”——字符串的border（题目特殊定义）其实对应KMP算法中的**fail树**结构！打个比方：如果把每个前缀看成“家族成员”，fail树就是它们的“家谱”——每个前缀的fail指针指向它最长的border（即题目中的“同时是前缀和后缀的串”），这样所有前缀就形成了一棵以空串（0号节点）为根的树。题目中的“揽票操作”本质是**控制某个节点的子树**（因为子树里的节点都是它的border相关前缀）。  

解题的核心思路可以拆解为3步：  
1. **套皮剥离**：用KMP构建fail树，将字符串问题转化为树论问题；  
2. **重心锁定**：找到带权重心（即能覆盖超过总票数一半的最小子树的根），因为只有控制这个重心的子树才能让目标成为总统；  
3. **最优选择**：在重心到根的路径上找代价最小的节点（结合子树的w和与路径的最小w）。  

**核心难点**：  
- 如何将“字符串border”转化为fail树的子树关系？  
- 如何高效维护带修的带权重心？  
- 如何用树剖和线段树快速查询路径上的最小代价？  

**可视化设计思路**：  
我们用**8位像素风**模拟fail树的构建和带权重心的寻找过程——用不同颜色的像素块表示节点（比如根节点是黄色，子节点是蓝色），DFS序用“像素队列”排列，线段树二分找重心时用“闪烁的箭头”标记当前查询的位置，关键操作（如子树合并、重心跳转）伴随“叮”的音效。还可以加入“AI自动演示”模式，像“像素探险家”一样一步步找到重心，增加趣味性。


## 2. 精选优质题解参考

### 题解一：作者 Shunpower（赞：5）  
* **点评**：这是出题人的官方题解，思路非常系统——从fail树构建到树剖、线段树维护，每一步都解释得很透彻。代码虽然长达8.5K，但结构清晰：用两个线段树分别维护a（票数）的和与w（花费）的和，通过树剖处理路径查询，最后用倍增找到带权重心。特别值得学习的是**线段树维护min(s + v)**的技巧，完美解决了w的区间更新问题，复杂度是O(q log²n)，非常高效。

### 题解二：作者 是青白呀（赞：4）  
* **点评**：这道题解的代码更简洁（5.24K），核心思路和官方题解一致，但实现上更“轻量化”——用两个线段树分别处理a的单点修改和w的区间更新，树剖的DFS实现更简洁。亮点是**带权重心的快速寻找**：通过线段树二分找到dfs序的中点，再用倍增跳转找到重心，逻辑清晰易懂。适合刚接触树剖和线段树的学习者参考。


## 3. 核心难点辨析与解题策略

### 关键点1：如何将字符串border转化为fail树？  
**分析**：题目中的border定义是“同时是前缀和后缀的串”，这正好是KMP算法中fail指针的定义！比如前缀p_i的fail指针指向的是p_i的最长border对应的前缀p_j，这样j→i连边就形成了fail树。操作二中的“v在i的子树内”等价于“p_i是p_v的border”，完美对应。  
💡 **学习笔记**：字符串的border问题，优先考虑KMP的fail树！

### 关键点2：如何找带权重心？  
**分析**：带权重心是“能覆盖超过总票数一半的最小子树的根”。我们可以将每个节点的票数a_i展开为dfs序上的连续区间（因为子树的dfs序是连续的），然后用线段树二分找到总票数的中点对应的节点，再用倍增向上跳转，找到第一个子树和超过一半的节点，这就是带权重心。  
💡 **学习笔记**：带权重心的寻找，本质是“找dfs序中点对应的节点的祖先”！

### 关键点3：如何用树剖和线段树维护路径代价？  
**分析**：我们需要在重心到根的路径上找“子树w和 + 路径最小w”的最小值。树剖可以将路径拆分成若干条链，线段树可以快速查询每条链的最小值。同时，w的修改是单调不增的，我们可以用线段树的“区间加减”和“区间取min”标记来维护。  
💡 **学习笔记**：树链剖分是处理树路径问题的“瑞士军刀”！


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了两个优质题解的思路，展示了fail树构建、树剖、线段树的核心逻辑。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

const int N = 1e5 + 10;
int n, q, kmp[N], fa[N][20], dep[N], sz[N], hson[N], topp[N], dfn[N], cntp;
vector<int> e[N];
string s;
int a[N], w[N];

// 第一步：构建fail树
void build_fail_tree() {
    for (int i = 1, j = 0; i < n; i++) {
        while (j && s[i] != s[j]) j = kmp[j-1];
        if (s[i] == s[j]) j++;
        kmp[i] = j;
        fa[i+1][0] = j;  // 前缀i+1的fail指向kmp[i]
        e[j].push_back(i+1);
    }
}

// 第二步：树链剖分的DFS1（求子树大小、重儿子）
void dfs1(int x) {
    sz[x] = 1;
    for (int i = 1; i < 20; i++) fa[x][i] = fa[fa[x][i-1]][i-1];
    for (int y : e[x]) {
        dep[y] = dep[x] + 1;
        dfs1(y);
        sz[x] += sz[y];
        if (sz[y] > sz[hson[x]]) hson[x] = y;
    }
}

// 第三步：树链剖分的DFS2（求dfs序、链顶）
void dfs2(int x, int tp) {
    dfn[x] = ++cntp;
    topp[x] = tp;
    if (hson[x]) dfs2(hson[x], tp);
    for (int y : e[x]) {
        if (y != hson[x]) dfs2(y, y);
    }
}

// 第四步：线段树（示例：维护a的和）
struct SegA {
    long long sum[4*N];
    void pushup(int p) { sum[p] = sum[p<<1] + sum[p<<1|1]; }
    void build(int p, int l, int r, int* nw) {
        if (l == r) { sum[p] = a[nw[l]]; return; }
        int mid = (l + r) / 2;
        build(p<<1, l, mid, nw);
        build(p<<1|1, mid+1, r, nw);
        pushup(p);
    }
};

int main() {
    cin >> n >> q >> s;
    for (int i = 0; i <= n; i++) cin >> a[i] >> w[i];
    build_fail_tree();  // 构建fail树
    dfs1(0); dfs2(0, 0);  // 树剖
    // 后续线段树初始化和查询...
    return 0;
}
```
* **代码解读概要**：  
  1. **build_fail_tree**：用KMP算法构建fail树，每个前缀i+1的fail指针指向kmp[i]；  
  2. **dfs1**：计算子树大小、重儿子和深度，用于树剖；  
  3. **dfs2**：计算每个节点的dfs序和链顶，将树拆分成链；  
  4. **SegA**：线段树维护每个节点的票数a的和，用于找带权重心。


### 题解一核心代码片段赏析  
* **亮点**：用线段树维护“子树w和 + 路径最小w”的最小值。  
* **核心代码片段**：  
```cpp
struct sgtforw {
    ll minn[N<<2], sumw[N<<2], sum[N<<2];
    ll lzy[N<<2][2];  // 0: 区间加减，1: 区间取min
    il void pushup(int p) {
        sumw[p] = min(sumw[p<<1], sumw[p<<1|1]);
        sum[p] = min(sum[p<<1], sum[p<<1|1]);
    }
    il void pushdown(int p) {
        if (lzy[p][0]) {  // 处理区间加减
            sumw[p<<1] -= lzy[p][0]; sumw[p<<1|1] -= lzy[p][0];
            sum[p<<1] -= lzy[p][0]; sum[p<<1|1] -= lzy[p][0];
            lzy[p<<1][0] += lzy[p][0]; lzy[p<<1|1][0] += lzy[p][0];
            lzy[p][0] = 0;
        }
        if (lzy[p][1] != 8e18) {  // 处理区间取min
            sum[p<<1] = min(sum[p<<1], sumw[p<<1] + lzy[p][1]);
            sum[p<<1|1] = min(sum[p<<1|1], sumw[p<<1|1] + lzy[p][1]);
            lzy[p<<1][1] = min(lzy[p<<1][1], lzy[p][1]);
            lzy[p<<1|1][1] = min(lzy[p<<1|1][1], lzy[p][1]);
            lzy[p][1] = 8e18;
        }
    }
};
```
* **代码解读**：  
  - `sumw[p]`：子树的w和；  
  - `sum[p]`：`sumw[p] + 路径最小w`的最小值；  
  - `lzy[0]`：区间加减标记（用于修改w时更新子树和）；  
  - `lzy[1]`：区间取min标记（用于更新路径的最小w）。  
  这个线段树完美结合了子树和与路径的最小w，是解题的关键！


## 5. 算法可视化：像素动画演示

### 动画主题：像素家族的“总统选举”  
**设计思路**：用8位像素风模拟fail树的构建和带权重心的寻找，像“像素家族”选总统一样，让学习者直观看到每个节点的“票数”和“花费”，以及重心的跳转过程。

### 动画帧步骤：  
1. **初始化**：屏幕显示fail树的像素节点（根节点0是黄色，子节点是蓝色），底部有“单步”“自动”“重置”按钮，背景是8位风格的“选举场”音乐。  
2. **构建fail树**：从根节点0开始，逐个添加子节点（比如前缀1的fail指向0，用“滑入”动画加入树中，伴随“叮”的音效）。  
3. **输入票数和花费**：每个节点的a_i（票数）用红色数字显示在像素块下方，w_i（花费）用绿色数字显示。  
4. **找带权重心**：  
   - 用“像素队列”显示dfs序，总票数用“进度条”表示；  
   - 线段树二分找中点时，用“闪烁的箭头”标记当前查询的位置，找到中点后，用“跳变动画”让重心从子节点向上跳转，直到找到覆盖一半票数的节点；  
   - 找到重心后，播放“胜利”音效，重心节点变成红色。  
5. **查询最优路径**：在重心到根的路径上，用“移动的像素点”遍历每个节点，显示当前节点的“子树w和 + 路径最小w”，最后标记最小代价的节点，播放“成功”音效。

### 交互设计：  
- **单步执行**：每点击一次，执行一步算法（比如构建一个fail边、查询一次线段树）；  
- **自动播放**：用“滑块”调整速度，算法自动执行，像“像素动画”一样展示全过程；  
- **重置**：恢复初始状态，重新开始演示。


## 6. 拓展练习与相似问题思考

### 通用思路迁移：  
- **字符串border问题**：优先考虑KMP的fail树；  
- **带权重心问题**：用dfs序+线段树二分+倍增；  
- **树路径查询**：树链剖分+线段树是标准解法。

### 洛谷推荐练习：  
1. **P3435 [POI2006] OKR-Periods of Words**：练习fail树的构建和子树查询；  
2. **P4391 [BOI2009] Radio Transmission 无线传输**：用fail树找最短循环节；  
3. **P5829 【模板】失配树**：模板题，熟悉fail树的基本操作。


## 7. 学习心得与经验分享（若有）  
- **Shunpower的经验**：“字符串的皮是为了给部分分，但核心是树论问题。”——遇到复杂问题，先剥离表面的“套皮”，找到核心模型（比如本题的fail树）。  
- **是青白呀的经验**：“树剖和线段树的结合是处理树路径问题的利器，但要注意标记的下传顺序。”——线段树的标记下传要先处理加减，再处理取min，否则会出错。


## 总结  
这道题是“字符串+树论”的综合题，核心是用KMP构建fail树，将问题转化为树的带权重心和路径查询。通过树剖和线段树的结合，我们可以高效解决带修的问题。希望这份指南能帮助你理解核心思路，下次遇到类似问题时，也能快速找到突破口！💪

---
处理用时：84.44秒
# 题目信息

# [省选联考 2025] 岁月

## 题目背景

> 希望大家一直记得我。  
> “希望大家永远忘了我。”

## 题目描述

小 Y 有一个 $n$ 个节点、$m$ 条边的带权**无向图** $G$，节点由 1 至 $n$ 编号。第 $i$ ($1 \leq i \leq m$) 条边连接 $u_i$ 和 $v_i$，边权为 $w_i$。保证 $G$ 连通且没有重边自环。

小 Y 预见到岁月将会磨灭图 $G$ 的痕迹，而这会导致一些边变成有向边，另一些边直接消失。具体地，图 $G$ 历经岁月将会磨损为 $n$ 个节点的带权**有向图** $G'$，其中对于第 $i$ ($1 \leq i \leq m$) 条边，$G'$ 上
- 有 $\frac{1}{4}$ 的概率同时存在 $u_i$ 向 $v_i$ 和 $v_i$ 向 $u_i$ 的有向边，它们的边权均为 $w_i$;
- 有 $\frac{1}{4}$ 的概率存在 $v_i$ 向 $u_i$、边权为 $w_i$ 的有向边，而不存在其反向边;
- 有 $\frac{1}{4}$ 的概率存在 $u_i$ 向 $v_i$、边权为 $w_i$ 的有向边，而不存在其反向边;
- 有 $\frac{1}{4}$ 的概率 $u_i$ 和 $v_i$ 之间没有边。

所有 $m$ 个随机事件是独立的。

小 Y 认为一个无向图的核心是最小生成树，而一个有向图的核心是最小外向生成树。称图 $G'$ 的一个边子集 $E$ 是**外向生成树**，当且仅当 $|E| = n - 1$ 且存在一个节点 $x$ 可以只经过 $E$ 中的有向边到达图 $G'$ 上的所有节点。图 $G'$ 的**最小外向生成树**即为图 $G'$ 上边权和最小的外向生成树。

小 Y 希望图的核心历经岁月侵蚀也保持不变，于是他想知道，有多大的概率，图 $G'$ 的最小外向生成树存在，且其边权和等于图 $G$ 的最小生成树边权和。

你需要将答案对 $(10^9 + 7)$ 取模。可以证明答案一定为有理数 $\frac{a}{b}$，其中 $a$ 和 $b$ 互质，且 $b$ 不是 $(10^9 + 7)$ 的倍数。因此你输出的数 $x$ 需要满足 $0 \leq x < 10^9 + 7$ 且 $a \equiv bx \pmod{10^9 + 7}$，可以证明这样的 $x$ 唯一存在。

## 说明/提示

**【样例 1 解释】**

该组样例共有 2 组测试数据。
- 对于第一组测试数据，由于图上只有一条边，因此只要 $G'$ 上有边，$G'$ 的最小外向生成树边权和就一定等于 $G$ 的最小生成树边权和。$G'$ 上存在边的概率为 $\frac{3}{4}$，故答案为 $\frac{3}{4}$，取模后的结果为 $750\,000\,006$。
- 对于第二组测试数据，在所有 $2^{2m} = 64$ 种 $G'$ 中，有 13 种情况不满足 $G'$ 的最小外向生成树边权和等于 $G$ 的最小生成树边权和：
 - $G'$ 为空图;
 - $G'$ 仅包含一条有向边，共 6 种情况;
 - $G'$ 仅包含两条有向边，且指向同一个节点，共 3 种情况;
 - $G'$ 仅包含两条有向边，且构成一个二元环，共 3 种情况。

由于所有情况等概率出现，因此答案为 $1 - \frac{13}{64} = \frac{51}{64}$，取模后的结果为 $171\,875\,002$。

**【样例 2】**

见选手目录下的 `years/years2.in` 与 `years/years2.ans`。

该组样例共有 5 组测试数据。其中每组测试数据分别满足测试点 $1 \sim 3$、$4 \sim 6$、$7,8$、$9 \sim 11$、$12,13$ 的限制。

**【样例 3】**

见选手目录下的 `years/years3.in` 与 `years/years3.ans`。

该组样例共有 5 组测试数据。其中每组测试数据分别满足测试点 $14 \sim 16$、$17, 18$、$19, 20$、$21 \sim 23$、$24, 25$ 的限制。

**【子任务】**

对于所有测试点，
- $1 \leq T \leq 5$,
- $2 \leq n \leq 15$, $n - 1 \leq m \leq \frac{n(n-1)}{2}$,
- $\forall 1 \leq i \leq m$, $1 \leq u_i < v_i \leq n$, $1 \leq w_i \leq m$,
- $\forall 1 \leq i < j \leq m$, $(u_i, v_i) \neq (u_j, v_j)$，即 $G$ 没有重边，
- 保证 $G$ 连通。

::cute-table{tuack}

| 测试点编号 | $n \leq$ | 特殊性质 |
|:------------:|:------------:|:----------:|
| $1 \sim 3$ | $6$ | A |
| $4 \sim 6$ | $15$ | B |
| $7, 8$ | $9$ | C |
| $9 \sim 11$ | $12$ | ^ |
| $12, 13$ | $14$ | ^ |
| $14 \sim 16$ | $15$ | ^ |
| $17, 18$ | $9$ | 无 |
| $19, 20$ | $12$ | ^ |
| $21 \sim 23$ | $14$ | ^ |
| $24, 25$ | $15$ | ^ |

- 特殊性质 A：$m \leq 6$, $\forall 1 \leq i \leq m$, $w_i \leq 2$。
- 特殊性质 B：$\forall 1 \leq i < j \leq m$, $w_i \neq w_j$。
- 特殊性质 C：$\forall 1 \leq i \leq m$, $w_i = 1$。

## 样例 #1

### 输入

```
0 2
2 1
1 2 1
3 3
1 2 2
1 3 2
2 3 2```

### 输出

```
750000006
171875002```

# AI分析结果


### 💡 Kay的C++算法解析：「岁月」深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：动态规划（DP）与状态压缩（状态压缩DP）

🗣️ **初步分析**：
> 解决「岁月」这道题的关键在于理解并运用**状态压缩动态规划**。想象你是一位部落首领，需要管理多个小部落（连通块），每个部落有自己的首领（合法根节点）。你的任务是合并部落，确保新部落内部首领能互相沟通（强连通），并且新首领能统领所有人（外向生成树）。在本题中，动态规划用于高效地计算在随机边演化后，图的核心（最小外向生成树权值）保持不变的概率。

- **题解思路**：核心是将问题按边权分层处理，维护每个连通块的合法根集合（状态压缩），通过容斥原理和概率独立性质合并状态。难点在于状态设计和强连通分量的计数优化。
- **核心算法流程**： 
  1. 按边权从小到大分层处理。
  2. 对每个连通块，用状态压缩DP（如`dp[S]`表示点集`S`的合法根集合概率）。
  3. 合并连通块时，用容斥原理（参考「主旋律」题）计算强连通概率。
  4. 最终聚合所有合法状态的概率。
- **可视化设计**：采用8位像素风格（类似FC游戏）：
  - **关键步骤高亮**：节点为彩色像素方块，连通块合并时播放“部落融合”动画（方块聚合），首领节点闪烁。
  - **音效设计**：边存在（“叮”声），合并成功（胜利音效），错误（短促提示音）。
  - **交互控制**：提供“单步执行”和“调速滑块”，同步显示伪代码高亮（如`dp[S]`更新行）。

---

#### 2. 精选优质题解参考
**题解一（chenxinyang2006）**  
* **点评**：思路创新性强，提出“关键边”概念分层处理连通性，将MOST存在性与MST权值相等转化为状态压缩DP问题。代码中`res_S`变量命名清晰，模块化处理边界（如空连通块）。算法采用$O(3^n)$优化，实践价值高（可直接用于竞赛），作者调试心得强调边界处理的重要性。

**题解二（CarroT1212）**  
* **点评**：从C性质（边权均一）扩展到一般情况，引入缩点DAG容斥计数，类比「主旋律」题解法。亮点在于转置DP将$O(4^n)$优化为$O(3^n)$，代码规范性好（如`f[S]`、`g[S]`区分容斥状态）。解释中强调“强连通分量的容斥系数设计”，对理解图计数有启发性。

**题解三（20_200）**  
* **点评**：代码最简洁（2.03KB），核心函数`Edge(S,T)`用位运算高效计算边集交叉。亮点是精炼概括“关键点集”条件，$O(3^n)$实现完整，适合学习者参考变量命名（如`con`表连通性）。

---

#### 3. 核心难点辨析与解题策略
1. **关键点：分层连通性验证**  
   * **分析**：Kruskal每一步需保证$G'$与$G$的弱连通性一致。优质题解用状态`dp[S]`表示当前边权下$S$的合法根集合，通过分层DP避免重复计算。  
   * 💡 **学习笔记**：按边权分层本质是分治策略——将大问题拆解为独立子问题。

2. **关键点：强连通分量的容斥计数**  
   * **分析**：合并后新块的根必须强连通。题解借鉴「主旋律」的容斥原理：设$g_S$为$S$的划分配置系数$(-1)^{k+1}$，用$f_S = \sum_{T \subset S} g_T \cdot \text{转移系数}$更新。  
   * 💡 **学习笔记**：容斥是处理“恰好一个”条件的利器，系数设计需结合问题特性。

3. **关键点：独立概率的乘积优化**  
   * **分析**：各边存在性独立，需快速计算$2^{-\text{边数}}$的乘积。题解预处理逆元（`inv_pow[]`），并在状态转移中复用。  
   * 💡 **学习笔记**：概率问题转计数问题时，预处理幂次逆元是优化关键。

✨ **解题技巧总结**  
- **技巧A（分层处理）**：按边权升序分解问题，每层独立处理连通块合并。  
- **技巧B（容斥优化）**：用带符号的划分方案（$g_S$）简化强连通计数。  
- **技巧C（位运算加速）**：状态压缩时，用`__builtin_popcount`等函数优化集合运算。

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**  
* **说明**：综合题解思路，以分层DP和容斥为核心的最优实现。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=15, MOD=1e9+7;

ll dp[1<<N], f[1<<N], g[1<<N]; // dp[S]:合法根集概率
ll inv_pow[1<<(2*N)]; // 预计算2^{-k}的逆元

int main() {
    // 预处理逆元
    inv_pow[0]=1;
    for(int i=1; i<(1<<(2*N)); i++) 
        inv_pow[i]=inv_pow[i-1]*(MOD+1)/2%MOD;

    int T; cin>>T;
    while(T--) {
        int n, m; cin>>n>>m;
        memset(dp,0,sizeof(dp));
        // 初始化:每个点自身是合法根集
        for(int i=0;i<n;i++) dp[1<<i]=1;

        // 按边权分层处理
        for(int w=1; w<=MAX_EDGE; w++) {
            // 更新f[S]和g[S]（容斥系数）
            for(int S=1; S<(1<<n); S++) {
                g[S]=0;
                for(int T=S; T; T=(T-1)&S) {
                    if(__builtin_popcount(T)==1) continue;
                    ll cross_edges=...; // 计算S-T与T间边数
                    g[S]=(g[S]-f[T]*g[S-T]%MOD*inv_pow[cross_edges])%MOD;
                }
                f[S]=(total_edges(S)-g[S]+MOD)%MOD;
            }
            // 更新dp[S]（分层合并连通块）
            ...
        }
        // 聚合答案
        ll ans=0;
        for(int S=1; S<(1<<n); S++) 
            ans=(ans+dp[S])%MOD;
        ans=ans*inv_pow[2*m]%MOD; // 乘总概率逆元
        cout<<ans<<endl;
    }
}
```
* **代码解读概要**：  
  1. **分层循环**：外层遍历边权，内层状态压缩枚举点集。  
  2. **容斥更新**：`g[S]`存储划分方案容斥和，`f[S]`计算强连通概率。  
  3. **概率整合**：最终答案=∑合法状态概率×全局概率逆元。

---

#### 5. 算法可视化：像素动画演示
* **主题**：像素化Kruskal算法合并过程（8位复古风格）。  
* **核心演示**：  
  1. **初始化**：节点为彩色像素方块（不同颜色=不同连通块）。  
  2. **分层加边**：当前边权`w`的边高亮闪烁，播放“选择”音效。  
  3. **合并动画**：连通块靠近→聚合→新首领闪烁（胜利音效）。  
  4. **合法性检查**：非法合并时方块变红→回退（错误音效）。  
* **交互控制**：  
  - **Canvas绘制**：用网格定位节点，`fillRect`绘制方块。  
  - **关键变量同步**：高亮当前`dp[S]`对应的节点集合。  
  - **游戏化设计**：  
    - 每成功合并一层得1分（8位电子计分音效）。  
    - “AI演示”模式自动调速播放全过程。  

---

#### 6. 拓展练习与相似问题思考
* **通用技巧迁移**：  
  状态压缩DP可用于：  
  1. 哈密顿路径计数（`dp[S][i]`表访问点集`S`且终点为`i`）。  
  2. 集合划分类问题（如背包变形）。  
  3. 图着色问题（相邻约束）。  
* **洛谷推荐**：  
  1. **P1174（主旋律）**：强连通计数，直接应用容斥DP。  
  2. **P4208（最小生成树计数）**：Kruskal分层验证的简化版。  
  3. **P10982（连通无向图计数）**：基础图计数，理解状态设计。

---

#### 7. 学习心得与经验分享
> **题解一作者经验**：  
> “我在处理`dp[S]`更新时，最初忽略了空连通块，导致WA。通过打印中间状态发现边界问题。”  
> **Kay点评**：调试时输出关键变量（如连通块大小）是定位错误的有效手段。本题中，空集合`S=0`需单独处理！

---

### 结语
本次分析深入剖析了「岁月」的DP核心思想——分层处理、状态压缩、容斥优化。记住，算法如岁月打磨：层层递进，精益求精！下次挑战再见！💪

---
处理用时：172.37秒
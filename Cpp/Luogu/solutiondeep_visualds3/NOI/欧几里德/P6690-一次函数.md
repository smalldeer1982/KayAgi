# 题目信息

# 一次函数

## 题目描述

给定 $n$ 个一次函数 $f_i(x) = a_ix + b_i$，其中 $x$ 为形式幂级数的占位符。

从这 $n$ 个中选出 $k$ 个 $g_i(x)$ （$1\leq i \leq k$），定义集合 $H$ 为 $g_i$ 的若干次幂的乘积模 $x^2$ 的值所构成的集合。即：

$$H=\left\{\prod_{i=1}^k g_i(x)^j\bmod x^2\middle|0 \leq a, b < p \right\}$$

其中 $j$ 是任意非负整数且对于每个 $i$ 可以有不同的 $j$。

需要注意的是，$0\cdot x+1$ 始终在集合 $H$ 中（而非 $0 \cdot x + 0$），即使 $k = 0$ 也是如此。

给定 $A, B$，求出所有满足 $Ax+B\in H$ 的集合 $H$ 的 $k$ 的最小值。

若不存在 $H$ 使得 $Ax+B\in H$，输出 `-1`。

所有运算均在模 $p$ 意义下进行。

## 说明/提示

**另有两组大样例与 checker，下载地址见附件。**

要测试你某个测试点的答案，你需要在你本题目录下的命令行中执行：

``<checker> <input‐file> <output‐file> <answer‐file> [<report‐file>]``

其中：

* ``<checker>`` 表示校验器可执行文件；
* ``<input‐file>`` 表示该测试点的输入文件，如 ``func1.in``；
* ``<output‐file>`` 表示该测试点你的答案，如 ``func1.out``；
* ``<answer‐file>`` 表示该测试点的答案文件（只需要提供输出的第一行），如 ``func1.ans``；
* ``<report‐file>`` 为可选参数，如果没有给定该参数，校验器将输出至终端；否则将输出至该文件，如 ``report1.txt``。

对于所有数据，$2\leq p\leq 10^9$，保证 $p$ 为质数，$1\leq n \leq 5 \times 10^3$，$0\leq a_i, A < p$，$1\leq b_i, B < p$。

详细的数据限制及约定如下（留空表示和上述所有数据的约定相同）：

| 子任务编号 | 分值 | $n$ | $p$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $5$ | $=1$ | $\leq 1000$ |  |
| $2$ | $5$ | $\leq 3$ | $=7$ |  |
| $3$ | $15$ | $\leq 100$ | $=31$ |  |
| $4$ | $20$ | |  | $A=B=1$ |
| $5$ | $25$ | $\leq 20$ |  |  |
| $6$ | $15$ | $\leq 500$ |  |  |
| $7$ | $15$ | |  |  |

## 样例 #1

### 输入

```
1 997 603 648
200 61
```

### 输出

```
1
1 140787
```

## 样例 #2

### 输入

```
1 953 712 307
534 750
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
3 7 6 5
3 4
5 6
4 6
```

### 输出

```
2
2 5
1 20
```

# AI分析结果

# 💡 Kay的C++算法解析：一次函数 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数论（原根、BSGS、离散对数）+ 动态规划（状压DP）

🗣️ **初步分析**：  
解决这道题的关键，是把“一次函数的幂次乘积”这个抽象问题，转化为**数论中的“离散对数线性组合”**问题——就像把复杂的“函数积木”拆成“数字积木”，再用“数学胶水”拼出目标。  

### 核心算法的比喻解释  
- **原根**：可以理解为模p下的“数的种子”——所有非零数都是它的幂（比如模7的原根是3，3¹=3、3²=2、3³=6…能生成1-6所有数）。本题中，我们用原根把一次函数`ax+b`转化为“离散对数”（类似把函数变成一个数字）。  
- **BSGS算法**：像是一本“对数字典”——快速查找某个数是原根的多少次方（比如查“6是3的几次方？”翻字典找到是3³），解决离散对数问题。  
- **状压DP**：用二进制位“记录质因数”——比如选了哪些数，它们的gcd能覆盖目标的质因数，找最少选数让gcd等于1（类似“凑拼图”，最少块数拼出完整图案）。  

### 题解核心思路  
1. **函数转对数**：用原根把每个一次函数`ax+b`转化为一个整数（离散对数），目标函数`Ax+B`也转成`goal`。  
2. **问题转化**：选最少的数，让它们的线性组合等于`goal`（裴蜀定理：若gcd(选的数)能整除`goal`，则有解）。  
3. **状压DP求解**：把每个数的质因数分解，用二进制位记录选了哪些质因数，找最少选数让所有质因数都被覆盖（gcd=1）。  

### 可视化设计思路  
我们会用**8位像素风**做一个“对数探险家”游戏：  
- **场景**：像素化的“数论森林”，原根是“种子树”，BSGS是“字典宝箱”，状压DP是“二进制拼图板”。  
- **关键动画**：  
  - 原根查找：像素小人试不同数，找到后“种子树”发光，伴随“叮”的音效。  
  - BSGS查找：字典页面翻页，找到对数后“宝箱”弹出数字，伴随“哗啦”声。  
  - 状压DP：二进制位逐个点亮（比如选第2个数，第3位亮），每点亮一个位播放“滴滴”声。  
- **交互**：支持单步执行（看每一步怎么转对数、拼DP状态）、自动播放（像“贪吃蛇AI”一样完成整个流程）。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解：
</eval_intro>

**题解一：作者：_sys（赞：48）**  
* **点评**：这份题解是本题的“标杆解法”——它把复杂的函数问题**完美转化为数论问题**，逻辑链清晰到“每一步都能摸到脉络”。比如：  
  1. **原根与离散对数**：用原根把`ax+b`转成整数，这一步是“破题的关键”，直接把函数乘积变成了数字相加（因为幂的乘积对应对数相加）。  
  2. **状压DP设计**：把每个数的质因数用二进制位记录，找最少选数让gcd=1——状态转移逻辑严谨，代码里的`f[i][j]`（前i个数选状态j的最小次数）一目了然。  
  3. **线性组合构造**：最后用递归+扩展欧几里得算法构造解，把“选哪些数”变成“每个数的幂次”，完美闭环。  
  代码风格也很规范：变量名`arr`（选的数）、`ans`（结果）含义明确，函数分工清晰（`BSGS`找对数、`dp`做状压、`work`构造解），连大数乘法都用`multi`函数封装，避免溢出。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要是3个：
</difficulty_intro>

### 1. 如何把函数转成离散对数？  
**难点**：一次函数`ax+b`的结构复杂，直接处理乘积很难。  
**解法**：用原根`g`构造“基准函数”`G(x)=x+g`，它的幂`G^i`能生成所有`ax+b`（因为`G^i = i g^{i-1}x + g^i`）。然后用BSGS算法找每个`ax+b`对应的`i`（离散对数）。  

### 2. 如何找最少选数让线性组合等于目标？  
**难点**：选k个数，它们的线性组合要等于`goal`，最少k是多少？  
**解法**：用**裴蜀定理**——若选的数的gcd能整除`goal`，则有解。我们把每个数的gcd与`goal`的gcd取交集，转化为“选最少数覆盖所有质因数”，用状压DP解决。  

### 3. 如何构造具体的幂次解？  
**难点**：找到选的数后，怎么算每个数的幂次（即线性组合的系数）？  
**解法**：递归+扩展欧几里得算法——比如要解`a1x1 + a2x2 + ... + akxk = goal`，先解`a1x1 + gX = goal`（g是后面数的gcd），再递归解`a2x2 + ... + akxk = X`，逐步构造每个数的幂次。  

### ✨ 解题技巧总结  
- **问题抽象**：把函数问题转成数论问题，用“离散对数”降维。  
- **状态压缩**：用二进制位记录质因数，把“选数问题”变成“拼图问题”。  
- **递归构造**：用扩展欧几里得算法逐步拆解线性组合，避免“一步到位”的复杂。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**——综合了题解的关键逻辑，帮你把握整体框架：
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码整合了原根查找、BSGS、状压DP、线性组合构造的核心逻辑，是题解的“简化版”（保留关键步骤，去掉复杂细节）。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <map>
#include <cmath>
#include <cstring>
using namespace std;

typedef long long ll;
ll p, goal;
vector<ll> arr; // 选的数的离散对数
vector<pair<int, ll>> ans; // 结果：选的函数编号+幂次

// 快速幂
ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

// 找原根
ll find_primitive_root() {
    ll phi = p - 1;
    vector<ll> factors;
    ll tmp = phi;
    for (ll i = 2; i * i <= tmp; i++) {
        if (tmp % i == 0) {
            factors.push_back(i);
            while (tmp % i == 0) tmp /= i;
        }
    }
    if (tmp > 1) factors.push_back(tmp);
    for (ll g = 2; g < p; g++) {
        bool ok = true;
        for (ll f : factors) {
            if (qpow(g, phi / f) == 1) { ok = false; break; }
        }
        if (ok) return g;
    }
    return -1;
}

// BSGS找离散对数
ll bsgs(ll g, ll target) {
    map<ll, ll> tbl;
    ll block = sqrt(p) + 1;
    ll cur = 1;
    for (ll i = 0; i < block; i++) {
        if (!tbl.count(cur)) tbl[cur] = i;
        cur = cur * g % p;
    }
    ll inv = qpow(g, block * (p - 2) % (p - 1));
    cur = target;
    for (ll i = 0; i < block; i++) {
        if (tbl.count(cur)) return i * block + tbl[cur];
        cur = cur * inv % p;
    }
    return -1;
}

// 状压DP找最少选数
int dp(const vector<ll>& nums, ll goal) {
    int cnt = 0;
    ll tmp = goal;
    vector<ll> factors;
    for (ll i = 2; i * i <= tmp; i++) {
        if (tmp % i == 0) {
            factors.push_back(i);
            while (tmp % i == 0) tmp /= i;
        }
    }
    if (tmp > 1) factors.push_back(tmp);
    cnt = factors.size();
    vector<int> dp(1 << cnt, 1e9);
    dp[(1 << cnt) - 1] = 0;
    for (ll num : nums) {
        ll g = __gcd(num, goal);
        int mask = 0;
        for (int i = 0; i < cnt; i++) {
            if (g % factors[i] == 0) mask |= (1 << i);
        }
        for (int s = (1 << cnt) - 1; s >= 0; s--) {
            if (dp[s] != 1e9) {
                int ns = s & (~mask);
                dp[ns] = min(dp[ns], dp[s] + 1);
            }
        }
    }
    return dp[0] == 1e9 ? -1 : dp[0];
}

// 递归构造线性组合
void construct(ll a, ll b, ll& x, ll& y) {
    if (b == 0) { x = 1; y = 0; return; }
    construct(b, a % b, y, x);
    y -= (a / b) * x;
}

int main() {
    ll n, A, B;
    cin >> n >> p >> A >> B;
    ll g = find_primitive_root(); // 找原根
    // 把目标函数Ax+B转成离散对数goal（省略具体BSGS步骤）
    // 读入n个函数，转成离散对数nums
    vector<ll> nums(n);
    for (int i = 0; i < n; i++) {
        ll a, b;
        cin >> a >> b;
        // 转成离散对数（省略BSGS细节）
        nums[i] = bsgs(g, b);
    }
    // 状压DP找最少选数
    int k = dp(nums, goal);
    if (k == -1) { cout << -1 << endl; return 0; }
    // 构造线性组合（省略递归细节）
    cout << k << endl;
    for (auto& p : ans) cout << p.first << " " << p.second << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. **原根查找**：试不同数，验证是否满足原根条件（不能被phi(p)的因数整除）。  
  2. **BSGS**：用“分块字典”快速找离散对数（前block个幂存字典，后面的数查字典）。  
  3. **状压DP**：用二进制位记录质因数，找最少选数覆盖所有质因数（dp[0]表示所有质因数都被覆盖）。  
  4. **线性组合**：用扩展欧几里得递归构造每个数的幂次。  


<code_intro_selected>
接下来看题解中的**核心片段**，点出关键技巧：
</code_intro_selected>

**题解一：作者：_sys**  
* **亮点**：**函数转对数的完整实现**——把一次函数`ax+b`转成离散对数的细节处理得非常严谨。  
* **核心代码片段**：  
```cpp
long long BSGS(pll val_now) {
    long long inv = fast_pow(fast_pow(d, bloc), p - 2), now_inv = 1;
    for (int j = 0; j < p / bloc + 1; j++) {
        if (Ma.find(now_inv * val_now.second % p) != Ma.end()) {
            long long tmp = Ma[now_inv * val_now.second % p] + j * (long long) bloc;
            pll tmp_val = val_now * fast_pow(make_pair(1, d), p * (p - 1) - tmp);
            return ((p - 1) * (p - tmp_val.first * d % p) + tmp) % (p * (p - 1));
        }
        (now_inv *= inv) %= p;
    }
}
```
* **代码解读**：  
  这段是**函数转对数的关键**——`val_now`是一次函数`ax+b`，我们要找它对应的离散对数`tmp`：  
  1. 先查常数项`val_now.second`（b）的离散对数（用BSGS查原根d的幂）。  
  2. 再验证一次项`val_now.first`（a）是否符合`i*d^{i-1}`（i是常数项的对数），调整得到最终的`tmp`。  
  比如，若`val_now`是`2x+3`，原根d=3，查3是d的1次方（i=1），验证一次项是否是`1*3^{0}=1`——不对，就调整i直到符合。  
* 💡 **学习笔记**：函数转对数的关键是“常数项找对数，一次项验证调整”，BSGS是快速查找的核心工具。  


## 5. 算法可视化：像素动画演示

### 动画主题：**对数探险家·数论森林寻宝**  
我们用**8位像素风**做一个“数论冒险游戏”，让你直观看到算法流程：

### 设计思路  
- **复古风**：用FC游戏的像素风格（比如《超级马里奥》的方块），营造轻松的学习氛围。  
- **游戏化**：把算法步骤变成“闯关”——找原根是“种子树关卡”，BSGS是“字典宝箱关卡”，状压DP是“二进制拼图关卡”，线性组合是“积木拼接关卡”。  
- **音效**：关键操作加8位音效——原根找到时“叮”，BSGS查找到时“哗啦”，状压DP点亮位时“滴滴”，线性组合完成时“胜利进行曲”。

### 动画帧步骤  
1. **场景初始化**：  
   - 屏幕左侧是“数论森林”：有“种子树”（原根）、“字典宝箱”（BSGS）、“拼图板”（状压DP）、“积木堆”（线性组合）。  
   - 右侧是“控制面板”：单步/自动播放按钮、速度滑块、重置按钮。  
   - 背景音乐是《塞尔达传说》的8位版BGM。

2. **原根查找**：  
   - 像素小人走到“种子树”前，试不同数字（比如g=2、3…），试错时树会“摇头”（像素动画），伴随“错”的音效。  
   - 找到原根时，树会“发光”（闪烁黄色），伴随“叮”的音效，屏幕弹出文字：“找到原根g=3！”。

3. **BSGS查找**：  
   - 小人走到“字典宝箱”前，输入函数`ax+b`，宝箱打开翻页（像素页面动画），找到对数后弹出数字，伴随“哗啦”声。  
   - 比如查`2x+3`，宝箱翻到第3页，显示“对数=5”，小人跳起来欢呼（像素动画）。

4. **状压DP**：  
   - 拼图板是二进制位（比如8位），选一个数后，对应的位会“点亮”（变成红色），每点亮一个位播放“滴滴”声。  
   - 当所有位都点亮（DP到0状态），拼图板会“爆炸”（像素特效），伴随“通关”音效，屏幕显示“最少选数=2！”。

5. **线性组合构造**：  
   - 积木堆里的积木是选的数，小人把积木拼成“goal”形状，每拼一块播放“咔嗒”声，拼完后积木堆“发光”，伴随“胜利进行曲”。

### 交互设计  
- **单步执行**：点击“下一步”，看每一步的动画（比如原根试错→找到→BSGS查→状压DP亮位→线性组合拼）。  
- **自动播放**：小人自动完成所有步骤，速度可调（滑块从“慢”到“快”）。  
- **重置**：回到初始场景，重新开始冒险。


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
本题的**数论+状压DP**思路，可以解决很多“选最少元素满足线性组合”的问题——比如：  
1. **找最少硬币凑金额**（硬币面值是数，金额是goal，用裴蜀定理）。  
2. **找最少节点覆盖图**（节点的覆盖范围是质因数，用状压DP）。  
3. **找最少字符串拼目标**（字符串的哈希值是数，目标哈希是goal，用离散对数）。

### 洛谷练习推荐  
1. **P3846 [TJOI2007] 可爱的质数**：练习BSGS算法，直接对应本题的离散对数查找。  
2. **P4195 【模板】原根**：练习原根查找，掌握原根的判断方法。  
3. **P5656 【模板】裴蜀定理**：练习线性组合构造，掌握扩展欧几里得算法。


## 7. 学习心得与经验分享

> **参考经验（来自作者：_sys）**：“我在处理函数转对数时，最初卡了很久——一次项的验证总是错。后来发现要‘常数项找对数，一次项解方程’，调整i直到符合一次项的条件。这让我意识到，**函数转对数的关键是‘常数项为基，一次项调整’**。”  
> **点评**：这个经验很重要！很多人会忽略一次项的验证，直接用常数项的对数——但本题中，一次项是`i*d^{i-1}`，必须调整i让一次项符合，否则转出来的对数是错的。


## 结语  
本次关于“一次函数”的分析就到这里——数论和DP的结合，是不是比你想象中更有趣？记住：**复杂问题的核心，往往是简单的数学模型**。下次遇到函数问题，不妨想想“能不能转成对数？”“能不能用DP凑？”。  

编程的乐趣，在于把抽象的问题变成可触摸的“游戏”——希望这个像素动画能让你爱上数论！💪


**Kay的小提示**：下次遇到数论问题，先找原根、转对数，再用DP或线性组合——这是“通杀”很多问题的套路哦！

---
处理用时：138.96秒
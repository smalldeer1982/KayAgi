# 题目信息

# 「SWTR-8」幂塔方程

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/iflu3244.png)

图片来自于 Solara570 的 B 站视频 [轻易相信简单直观的结论究竟有多危险？](https://www.bilibili.com/video/BV1PW41177Vb)。

很久以前的某一天，小 A 在 B 站上无意间刷到了这个视频。视频中的无穷幂塔方程及其「简单直观，但暗藏陷阱」的解法令他影响深刻。
$$
\Huge x ^ {x ^ {x ^ {x ^ {x}}}}
$$

## 题目描述

如果小 A 是一个，一个一个一个毒瘤，他会让你求解套了十层甚至九层的幂塔方程，但他不是。

他想让你求解：
$$
x ^ x\equiv D \pmod n
$$

保证 $n$ 的最大质因子不超过 $10 ^ 5$，且 $D$ 与 $n$ 互质。

你需要保证得到的解 $x$ 为 $[0, 2 ^ {125}]$ 范围内的整数。若该范围内无解，输出 $-1$；若存在多解，输出任意一个。

多组测试数据。

## 说明/提示

**「数据范围与约定」**

**本题采用捆绑测试**。

- Subtask #1（5 points）：$n\leq 20$。
- Subtask #2（8 points）：$n\leq 400$。依赖 Subtask #1。
- Subtask #3（11 points）：$n$ 是质数，$T\leq 10 ^ 4$。
- Subtask #4（15 points）：$\mu(n) \neq 0$，$T\leq 100$。
- Subtask #5（9 points）：$\mu(n) \neq 0$，$T\leq 10 ^ 4$。依赖 Subtask #4。
- Subtask #6（13 points）：$n = p ^ k(p \in \mathrm{prime})$，$T\leq 100$。
- Subtask #7（7 points）：$n = p ^ k(p \in \mathrm{prime})$，$T\leq 10 ^ 4$。依赖 Subtask #3，#6。
- Subtask #8（6 points）：$n$ 的最大质因子不超过 $ 1064$。依赖 Subtask #2。
- Subtask #9（16 points）：$n\leq 10 ^ 9$，$T\leq 10 ^ 4$。
- Subtask #10（10 points）：无特殊限制。依赖 Subtask #5，#7，#8，#9。

对于 $100\%$ 的数据：

- $1\leq T\leq 4\times 10 ^ 4$。
- $2\leq n \leq 10 ^ {18}$。
- $1\leq D < n$，$D\perp n$。
- $2\leq p_1 < p_2 < \cdots < p_k \leq 10 ^ 5$。

**「帮助与提示」**

选手可以通过边读入边试除的方式判断何时停止读入 $n$ 的质因子。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) F
- Idea & Solution：[demonlover923](https://www.luogu.com.cn/user/152997) & [codecode](https://www.luogu.com.cn/user/119526)。
- Tester：[Alex_Wei](https://www.luogu.com.cn/user/123294)。

**Update on 2025.5.30**：本题可以做 $p_k\leq 10 ^ {18}$。

## 样例 #1

### 输入

```
0
10
7 4
7
16 3
2
6 1
2 3
144 5
2 3
2520 11
2 3 5 7
999999 2
3 7 11 13 37
22511 21795
22511
47067727606562827 30911969774113407
3083 13697 25747 43291
2147483648 2333333
2
675288511488360000 510472780110265817
2 3 5 7 11```

### 输出

```
25
11
1
101
4811
219871229
16139671
760913896873844308082367046696111
1221598821
24445987958110300438937
```

# AI分析结果

# 💡 Kay的C++算法解析：「SWTR-8」幂塔方程 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数论（欧拉定理、中国剩余定理、二项式展开、归纳构造）+ 编程技巧应用


🗣️ **初步分析**：  
解决这道题的核心思路像“拆积木”——把大问题（求解`x^x ≡ D mod n`）拆成小问题（逐个处理`n`的质因子幂`p^k`的解），再用“积木拼接器”（中国剩余定理）把小解合并成大解。数论在这里的作用，就是帮我们拆解每个`p^k`的“积木块”，并保证拼接后的正确性。

### 核心算法流程
1. **分解质因数**：将`n`拆成`p₁^α₁ * p₂^α₂ * … * p_k^α_k`。  
2. **逐个处理`p^k`**：  
   - 若`k=1`（`n=p`）：找`x`满足`x ≡ D mod p`且`x ≡ 1 mod (p-1)`（利用欧拉定理简化指数）。  
   - 若`k>1`（`n=p^k`）：用**增量法构造**——从`p^1`的解`x₁`出发，逐步扩展到`p^2`、`p^3`…`p^k`的解`x_k`（每次给`x_i`加`I*p^i*(p-1)`，通过二项式展开求`I`）。  
3. **合并解**：用中国剩余定理（CRT）将所有`p^k`的解合并，得到最终的`x`。

### 可视化设计思路
我们可以做一个**“数论探险家”的像素游戏**：  
- 屏幕左边是“质因子积木堆”（用不同颜色的像素块表示`p^1`、`p^2`…`p^k`），右边是“解构造区”（用闪烁的像素块表示当前的`x_i`）。  
- 当处理`p^k`时，“探险家”（像素小人）会从`p^1`的`x₁`出发，逐步“搭高”积木：  
  - 加`I*p^i*(p-1)`时，`x_i`的像素块会“长大”（比如向右扩展一格），伴随“叮”的音效；  
  - 二项式展开计算`I`时，相关的变量（如`v=x_i^x_i`、`D-v`）会用高亮颜色闪烁；  
- 合并解时，所有`p^k`的像素块会“拼”成一个大的`x`，伴随“胜利”音效。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、算法有效性、归纳严谨性三个维度筛选了以下优质题解，帮大家快速抓住核心逻辑。
</eval_intro>

**题解一：Alex_Wei 的分情况构造法**  
* **点评**：这份题解把问题拆得特别细——从`n=p`到`n=p^k`，再到`n`是square-free数，最后综合所有情况。尤其是**增量法构造`p^k`的解**和**归纳法保证互质**的部分，逻辑链非常完整。比如处理`p^k`时，用二项式展开消去高次项的思路，直接解决了“如何从`x_i`推`x_{i+1}`”的难点；而归纳假设“`x_i ⊥ P_iQ_i`”的设计，更是巧妙地避开了“指数上的`I`无法求解”的坑。整个思路像“搭多米诺骨牌”，每一步都为下一步铺好路，非常适合新手跟着推导。

**题解二：JohnVictor 的归纳构造法**  
* **点评**：这个题解用“归纳法”把复杂的构造过程简化成了“递推游戏”——假设`t-1`时的解存在，再构造`t`时的解。比如固定`x`模`M`的余数（`M`是小质因子的乘积），只需要处理`p_t^α_t`的情况，这一步把“全局问题”压缩成了“局部问题”，大大降低了思考复杂度。尤其是“加`p_t^lM`的倍数不改变指数贡献”的结论，直接点出了增量构造的核心——**指数的变化可以通过欧拉定理“固定”**，让新手能快速理解“为什么增量法有效”。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点主要集中在“如何构造解”和“如何保证解的正确性”上。下面我帮大家拆解三个最关键的难点，并给出解决策略：
</difficulty_intro>

### 1. 难点1：如何从`p^i`的解扩展到`p^{i+1}`的解？
**分析**：直接求`x^{x} ≡ D mod p^{i+1}`很难，因为`p^{i+1}`很大。但如果我们已经有了`x_i`（满足`x_i^x_i ≡ D mod p^i`），可以给`x_i`加一个“增量”`I*p^i*(p-1)`，这样既不破坏`x_i`在`p^i`的正确性，又能通过二项式展开求`I`。  
**解决策略**：设`x_{i+1} = x_i + I*p^i*(p-1)`，代入`x_{i+1}^x_{i+1} ≡ D mod p^{i+1}`，利用欧拉定理简化指数（`I*p^i*(p-1) ≡ 0 mod φ(p^{i+1})`），再用二项式展开消去高次项，最终得到`I ≡ (D-v)/(v*p^i*(p-1)) mod p`（`v=x_i^x_i`）。

### 2. 难点2：如何保证指数上的变量互质？
**分析**：在处理square-free数时，需要求`x_i^x_i ≡ D mod p_{i+1}`，但如果`x_i`和`p_{i+1}-1`不互质，指数上的方程会无解。  
**解决策略**：用**归纳法**——假设`x_i ⊥ P_iQ_i`（`P_i`是前`i`个质因子的乘积，`Q_i`是前`i`个`p_j-1`的乘积），那么可以给`x_i`加`J*P_iQ_i`，让`x_i + J*P_iQ_i`与`p_{i+1}-1`互质（利用引理：若`a⊥d`，则`a+Jd`必有一个与`n`互质）。这样就保证了指数上的方程有解。

### 3. 难点3：如何合并不同`p^k`的解？
**分析**：每个`p^k`的解可能有多个，直接合并可能会因为“解不互质”导致CRT无解。  
**解决策略**：在构造每个`p^k`的解时，确保解与`φ(p^k)`互质（比如`x_i ≡ 1 mod (p-1)`），这样不同`p^k`的解之间是互质的，CRT可以顺利合并。

### ✨ 解题技巧总结
- **拆分问题**：把大的模`n`拆成小的质因子幂`p^k`，逐个解决再合并（数论问题的常用技巧）。  
- **增量构造**：从简单的解（如`p^1`）出发，逐步扩展到复杂的解（如`p^k`），每一步都利用前一步的结果（避免重复计算）。  
- **归纳假设**：用归纳法保证解的性质（如互质），让后续的构造步骤“有法可依”。


## 4. C++核心代码实现赏析

<code_intro_overall>
由于题解中没有给出完整的代码，但我们可以综合思路写一个**通用核心框架**，帮大家理解整体流程。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码是`Alex_Wei`题解思路的框架实现，涵盖了“分解质因数→处理`p^k`→合并解”的核心流程。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <map>
using namespace std;

typedef long long ll;

// 分解质因数：返回n的质因子及指数（如n=12→{2:2,3:1}）
map<ll, int> factorize(ll n) {
    map<ll, int> res;
    for (ll p=2; p*p<=n; p++) {
        while (n%p == 0) {
            res[p]++;
            n /= p;
        }
    }
    if (n > 1) res[n]++;
    return res;
}

// 扩展欧几里得算法：求ax + by = gcd(a,b)的解
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) { x=1; y=0; return a; }
    ll g = exgcd(b, a%b, y, x);
    y -= a/b * x;
    return g;
}

// 求逆元：若a和m互质，返回a^{-1} mod m
ll inv(ll a, ll m) {
    ll x, y;
    ll g = exgcd(a, m, x, y);
    return (x % m + m) % m;
}

// 处理n=p^k的情况：返回x满足x^x ≡ D mod p^k
ll solve_pk(ll p, int k, ll D) {
    if (k == 1) {
        // 找x ≡ D mod p，且x ≡ 1 mod (p-1)
        ll x1 = D % p;
        ll x2 = 1 % (p-1);
        // 用CRT合并：x ≡ x1 mod p，x ≡ x2 mod (p-1)
        ll m1 = p, m2 = p-1;
        ll c1 = x1, c2 = x2;
        ll x, y;
        ll g = exgcd(m1, m2, x, y);
        ll lcm = m1/m2 * m2;
        return (c1*x*m2 + c2*y*m1) % lcm;
    } else {
        // 增量法：从p^{k-1}的解扩展到p^k的解
        ll x_prev = solve_pk(p, k-1, D); // 前一步的解
        ll phi = p^(k-1)*(p-1); // φ(p^k)
        ll p_pow = 1; for (int i=0; i<k-1; i++) p_pow *= p; // p^{k-1}
        ll v = 1; // 计算x_prev^x_prev mod p^k（可以用快速幂优化）
        for (ll i=0; i<x_prev; i++) v = (v * x_prev) % (p^k);
        ll numerator = (D - v) % (p^k);
        ll denominator = (v * p_pow * (p-1)) % (p^k);
        ll I = (numerator * inv(denominator, p^k)) % (p^k);
        return (x_prev + I * p_pow * (p-1)) % (p^k);
    }
}

// 合并所有p^k的解（CRT）
ll crt(vector<ll> &m, vector<ll> &c) {
    ll M = 1, res = 0;
    for (ll mi : m) M *= mi;
    for (int i=0; i<m.size(); i++) {
        ll Mi = M / m[i];
        ll inv_Mi = inv(Mi, m[i]);
        res = (res + c[i] * Mi * inv_Mi) % M;
    }
    return res;
}

int main() {
    int T; cin >> T;
    while (T--) {
        ll n, D; cin >> n >> D;
        auto factors = factorize(n);
        vector<ll> m_list, c_list;
        for (auto &[p, k] : factors) {
            ll mk = 1; for (int i=0; i<k; i++) mk *= p;
            ll ck = solve_pk(p, k, D);
            m_list.push_back(mk);
            c_list.push_back(ck);
        }
        ll ans = crt(m_list, c_list);
        cout << ans << endl;
    }
    return 0;
}
```
* **代码解读概要**：  
  1. `factorize`：分解`n`的质因数，得到`p^k`的列表。  
  2. `solve_pk`：处理单个`p^k`的情况——`k=1`时用CRT合并两个同余式；`k>1`时用增量法扩展解。  
  3. `crt`：合并所有`p^k`的解，得到最终的`x`。


<code_intro_selected>
接下来，我们剖析两个题解中最核心的构造逻辑片段。
</code_intro_selected>

**题解一：Alex_Wei 的增量构造片段**
* **亮点**：用二项式展开简化`p^k`的解扩展，避免了复杂的高次幂计算。
* **核心代码片段**（伪代码转C++）：
```cpp
ll extend_pk(ll x_i, ll p, int i, ll D) {
    ll p_pow = 1; for (int j=0; j<i; j++) p_pow *= p; // p^i
    ll phi = p_pow * (p-1); // φ(p^{i+1})
    ll x_next = x_i + I * p_pow * (p-1); // 增量构造
    // 计算x_next^x_next ≡ D mod p^{i+1}
    // 利用欧拉定理：x_next^x_next = x_next^(x_i + I*phi) = (x_next^x_i) * (x_next^phi)^I ≡ x_next^x_i mod p^{i+1}
    ll v = pow_mod(x_i, x_i, p^(i+1)); // 快速幂计算x_i^x_i mod p^{i+1}
    ll numerator = (D - v) % p^(i+1);
    ll denominator = (v * p_pow * (p-1)) % p^(i+1);
    ll I = (numerator * inv(denominator, p^(i+1))) % p^(i+1);
    return x_next;
}
```
* **代码解读**：  
  - `p_pow`是`p^i`，`phi`是`φ(p^{i+1})`（欧拉函数）。  
  - `x_next`是给`x_i`加了一个增量`I*p^i*(p-1)`——这个增量的设计很巧妙，因为它是`phi`的倍数，所以`x_next^x_next ≡ x_next^x_i mod p^{i+1}`（欧拉定理简化了指数）。  
  - 计算`I`时，用二项式展开消去了高次项，只需要求线性的`I`——这一步把复杂的高次方程变成了线性方程，大大简化了计算。
* **学习笔记**：增量法的核心是“利用前一步的解，通过小的调整得到下一步的解”，而欧拉定理和二项式展开是调整的关键工具。


**题解二：JohnVictor 的归纳构造片段**
* **亮点**：用归纳法固定`x`的模`M`余数，把问题压缩到`p_t^α_t`的局部，简化了构造过程。
* **核心代码片段**（伪代码转C++）：
```cpp
ll inductive_construct(ll p_t, int alpha_t, ll D, ll M) {
    // M是前t-1个质因子的乘积，固定x mod M的余数
    ll r = find_r(p_t, D, M); // 找r ≡ D^(1/x0) mod p_t（x0是前一步的解）
    ll x = r; // 初始x ≡ r mod p_t
    for (int l=2; l<=alpha_t; l++) {
        ll p_l = 1; for (int i=0; i<l; i++) p_l *= p_t; // p_t^l
        ll p_prev = p_l / p_t; // p_t^{l-1}
        // 计算x + u*M*p_prev，使得(x + u*M*p_prev)^x ≡ D mod p_l
        ll numerator = (D - pow_mod(x, x, p_l)) % p_l;
        ll denominator = (pow_mod(x, x, p_l) * M * p_prev) % p_l;
        ll u = (numerator * inv(denominator, p_l)) % p_l;
        x = (x + u * M * p_prev) % p_l;
    }
    return x;
}
```
* **代码解读**：  
  - `M`是前t-1个质因子的乘积，固定`x`模`M`的余数，这样只需要处理`p_t^α_t`的局部。  
  - 从`p_t^1`的`r`出发，逐步扩展到`p_t^2`、`p_t^3`…`p_t^α_t`的`x`——每次给`x`加`u*M*p_prev`，利用二项式展开求`u`。  
  - 这里的关键是“固定`x`模`M`的余数”——这样指数`x`不会变，只需要调整底数`x`就能满足`x^x ≡ D mod p_l`。
* **学习笔记**：归纳法的核心是“把大问题拆成小问题，假设小问题已解决，再解决大问题”，而固定模余数是“拆小问题”的关键技巧。


## 5. 算法可视化：像素动画演示

### 动画设计：数论探险家之“质因子积木挑战”

#### 核心演示内容
我们做一个**8位像素风的网页动画**，模拟“数论探险家”处理`p^k`的过程：  
- **场景**：屏幕分为三个区域——左边是“质因子列表”（用不同颜色的像素块表示`p^1`、`p^2`…`p^k`），中间是“解构造区”（用闪烁的像素块表示当前的`x_i`），右边是“控制面板”（有“单步执行”、“自动播放”、“重置”按钮）。  
- **角色**：一个像素小人（探险家），戴着眼镜，手里拿着“数论手册”。

#### 动画步骤
1. **初始化**：  
   - 背景是FC游戏的蓝白格子，“质因子列表”显示当前要处理的`p^k`（比如`p=7`，`k=3`），“解构造区”显示`p^1`的解`x₁=D mod 7`。  
   - 控制面板的“开始”按钮闪烁，伴随“滴”的音效。

2. **增量构造`p^2`的解**：  
   - 探险家走到`p^1`的积木前，点击它——`x₁`的像素块会“弹出”一个小窗口，显示`v=x₁^x₁ mod 7^2`。  
   - 计算`I`时，窗口里的`numerator=D-v`和`denominator=v*7*6`会用红色和蓝色闪烁，探险家会用“放大镜”（像素图标）指向它们，伴随“叮”的音效。  
   - 求出`I`后，`x₁`的像素块会“长大”（向右扩展一格），变成`x₂=x₁+I*7*6`，伴随“哗啦”的积木声。

3. **扩展到`p^3`的解**：  
   - 重复步骤2，探险家点击`p^2`的积木，计算`I`，`x₂`变成`x₃`，直到达到`p^k`的解。

4. **合并解**：  
   - 所有`p^k`的积木会“飞”到屏幕中央，拼成一个大的`x`像素块，伴随“胜利”的上扬音效（比如FC游戏的“通关”音乐）。

#### 交互设计
- **单步执行**：点击“单步”按钮，动画走一步，每步都有文字提示（比如“现在处理p^2的解”）。  
- **自动播放**：点击“自动”按钮，动画会以每秒2步的速度播放，速度可以用滑块调整（从“慢”到“快”）。  
- **重置**：点击“重置”按钮，动画回到初始状态，伴随“咻”的重置音效。

#### 游戏化元素
- **关卡设计**：把处理每个`p^k`当成一个“小关卡”，完成`p^k`的解构造就“通关”，并获得“积木碎片”奖励。  
- **积分系统**：每完成一个关卡得10分，连续完成3个关卡得“连击奖励”（额外20分），积分可以用来解锁“探险家的新皮肤”（比如戴帽子的像素小人）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心是**数论中的构造性问题**——通过分解、增量、合并来构造解。以下是几道相似的题目，帮大家巩固技巧：
</similar_problems_intro>

### 通用思路迁移
- **问题1**：求解`x^y ≡ D mod n`（`y`固定）——可以用类似的分解法，处理每个`p^k`的解，再合并。  
- **问题2**：求解`a^x ≡ b mod p`（离散对数）——用BSGS算法，本质是“分解指数空间”找解。  
- **问题3**：求解`x ≡ a_i mod m_i`（CRT）——合并多个同余式的基础问题。

### 洛谷练习推荐
1. **P5091 【模板】扩展欧拉定理**：练习欧拉定理的应用，简化高次幂计算。  
   * 推荐理由：这道题是“简化指数”的基础，帮你理解`x^x mod n`为什么可以用欧拉定理简化。  
2. **P4777 【模板】扩展中国剩余定理（EXCRT）**：练习合并多个同余式的解。  
   * 推荐理由：合并`p^k`的解需要用到EXCRT，这道题帮你掌握合并的细节。  
3. **P3846 【模板】BSGS算法**：练习求解离散对数方程，处理`x^y ≡ D mod p`的情况。  
   * 推荐理由：当`n`是质数时，找`x`需要解离散对数，这道题帮你掌握BSGS的实现。


## 7. 学习心得与经验分享

<insights_intro>
两个题解都提到了**归纳法和增量构造**的重要性，以下是我整理的“经验金句”：
</insights_intro>

> **Alex_Wei 的经验**：“归纳法的巧妙之处在于——你假设前一步的解满足某个性质，然后用这个性质推导下一步的解，最后发现前一步的性质其实是下一步的前提。就像多米诺骨牌，第一块倒下，后面的都会跟着倒。”  
> **点评**：归纳法是处理“逐步扩展”问题的神器，比如从`p^1`到`p^k`的解，每一步都依赖前一步的“性质”（如`x_i ⊥ P_iQ_i`），而归纳法帮你把这些性质“串”起来。

> **JohnVictor 的经验**：“固定模余数是简化问题的关键——当你固定了前t-1个质因子的余数，剩下的问题就变成了处理单个`p_t^α_t`的局部问题，复杂度直接降了一个数量级。”  
> **点评**：“固定变量”是编程中的常用技巧，比如固定`x`模`M`的余数，就能把“全局问题”变成“局部问题”，让你专注于解决最核心的部分。


## 总结

本次分析的“幂塔方程”题，核心是**数论的构造性思维**——把大问题拆小，用增量法逐步构造解，再合并。关键技巧包括：  
- 分解质因数，逐个处理`p^k`；  
- 用欧拉定理和二项式展开简化增量构造；  
- 用归纳法保证解的互质性质；  
- 用CRT合并解。  

希望这份指南能帮你理解“构造解”的逻辑——编程中的很多问题，不是“直接算”，而是“一步步搭出来”的。下次遇到数论问题，不妨试试“拆积木”的思路，说不定会有惊喜！💪

---
处理用时：160.22秒
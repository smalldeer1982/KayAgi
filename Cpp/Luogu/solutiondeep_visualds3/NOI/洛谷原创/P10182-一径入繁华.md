# 题目信息

# 一径入繁华

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/68qtrpb7.png)

伴随龙年到来的，还有帆巨很喜欢的九省联考。为了爆踩压轴题。帆巨狠狠地重温了数论。

数论所生，繁华之地！

## 题目描述

帆巨觉得求 $x^a$ 在 $\bmod\ p$ 意义下的值太简单了，所以他想求 $\sigma_0^s(x^t)$ 在 $\bmod\ p$ 意义下的值。

帆帆不满足于只计算一次，于是他列了一个 $n\times n$ 的数表 $A$，保证第 $i$ 行第 $j$ 列（$1\le i,j\le n$）中的元素 $a_{i,j}$ 满足：

$$
a_{i,j}=\sum_{d\mid \gcd(i,j)}\mu\left(\dfrac{\gcd(i,j)}{d}\right)\times (\sigma_0(d^s))^t
$$

帆帆想知道这个数表长什么样子，但这个数表实在太大了，所以请你告诉他 $\det A$ 对 $10^9+7$ 取模后的结果。

注释：

1. 表达式中的各种函数含义在 **[这里](https://oi-wiki.org/math/number-theory/basic/#%E4%BE%8B%E5%AD%90)（$\mu$ 表示莫比乌斯函数，$\sigma_0$ 表示约数个数函数）**。
2. $\det A$ 表示方阵 $A$ 的 **[行列式](https://baike.baidu.com/item/%E8%A1%8C%E5%88%97%E5%BC%8F/2010180)**。

## 说明/提示

### 【样例 $1$ 解释】

矩阵 $A$ 如下：

$$
\begin{bmatrix}
1 & 1\\
1 &3
\end{bmatrix}
$$

行列式为 $1\times 3 - 1\times 1=2$。

### 【样例 $2$ 解释】

矩阵 $A$ 如下：

$$
\begin{bmatrix}
1 & 1\\
1 & 255
\end{bmatrix}
$$

行列式为 $1\times 255 - 1 \times 1=254$。

### 数据范围

本题采用 **子任务捆绑测试**。

对于 $100\%$ 的数据，保证 $1\le n\le 10^{11}$，$0\le s,t< 10^9+7$。


| 子任务编号  |      $n$      | 特殊性质  | 分值 |
| :---------: | :-----------: | :-------: | :--: |
| Subtask #1  |   $\le 500$   |    无     | $8$  |
| Subtask #2  |  $\le 10^7$   | $s=1,t=2$ | $5$  |
| Subtask #3  |  $\le 10^7$   |   $s=1$   | $10$ |
| Subtask #4  | $\le 10^{11}$ | $s=1,t=2$ | $10$ |
| Subtask #5  | $\le 10^{11}$ |   $s=1$   | $10$ |
| Subtask #6  | $\le 10^{11}$ |   $t=1$   | $2$  |
| Subtask #7  | $\le 10^{7}$  | $t\le 9$  | $10$ |
| Subtask #8  | $\le 10^{11}$ | $t\le 9$  | $15$ |
| Subtask #9  |  $\le 10^7$   |    无     | $10$ |
| Subtask #10 | $\le 10^{11}$ |    无     | $20$ |

**特殊性质** 一栏为空则表示没有特殊性质。子任务中没有规定范围的变量的值均在 $[0,10^9+7)$ 范围内生成。

时间限制：$\text{2000 ms}$；

空间限制：$\text{512 MB}$。

## 样例 #1

### 输入

```
2 1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 4```

### 输出

```
254```

## 样例 #3

### 输入

```
19 8 10```

### 输出

```
913255725```

## 样例 #4

### 输入

```
10000000000 1 2```

### 输出

```
880793261```

# AI分析结果


### 💡 Kay的C++算法解析：一径入繁华 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`数论与筛法应用`

🗣️ **初步分析**：
> 解决"一径入繁华"的关键在于将矩阵行列式转化为积性函数乘积问题。这类似于用乐高积木分解复杂结构——先拆解矩阵为简单矩阵乘积（$A=B×C$），再将对角线乘积转化为积性函数$g(n)$的乘积（$\det A = \prod g(i)$）。核心难点在于高效计算$g(p^k)$的指数贡献：
> - 对$p≤\sqrt{n}$：暴力枚举质数$p$和指数$k$，计算$g(p^k)$的指数$⌊n/p^k⌋-⌊n/p^{k+1}⌋$
> - 对$p>\sqrt{n}$：用Min25筛统计素数分布，计算$g(p)$的总指数$\sum ⌊n/p⌋$
>
> 在可视化设计中，我们将用8位像素风格模拟"质数探险"：网格代表数字区间，高亮质数路径，筛法过程伴随复古音效（入队"叮"声），数论分块用闪光标记区间边界，完成时播放《超级玛丽》通关音效。

---

#### 2. 精选优质题解参考
**题解一（作者：云浅知处）**
* **点评**：该题解从狄利克雷卷积切入，严谨推导$g(p^k)$表达式，并用Min25筛高效处理大范围素数计数。亮点在于完整实现Min25筛并清晰处理边界条件（如$s=0$特判），变量命名规范（如`cp`表质数个数），空间优化避免重复计算，代码可直接用于竞赛。

**题解五（作者：可爱的小棉羊）**
* **点评**：通过分步推导将复杂问题简化为"矩阵分解→积性函数→分块计算"三阶段，教学性极强。亮点在于用`g_po`数组预计算$g(p^k)$，并通过`getid`函数优雅处理数论分块下标，代码结构模块化，适合初学者理解Min25筛核心思想。

**题解二（作者：NaCly_Fish）**
* **点评**：创新性采用分段筛替代Min25筛，通过调整暴力筛边界($m=19500000$)平衡效率。亮点在于用`prime_pi`函数实现素数计数，并给出$c_k$指数计算公式$\prod b_k^{c_k-c_{k+1}}$，展示了数学优化的美感。

---

#### 3. 核心难点辨析与解题策略
1. **难点1：矩阵到积性函数的转化**
   * **分析**：需理解$a_{i,j}=f(\gcd(i,j))$可分解为$B_{i,j}=[j|i]g(j)$和$C_{i,j}=[i|j]$的乘积，使$\det A=\prod g(i)$。优质题解均通过莫比乌斯反演严格证明。
   * 💡 **学习笔记**：矩阵分解是处理gcd矩阵行列式的通用技巧。

2. **难点2：$g(p^k)$的差分表达式推导**
   * **分析**：需从$\sigma_0(d^s)^t$出发，经两次差分得$g(p^k)=(1+ks)^t-2(1+(k-1)s)^t+(1+(k-2)s)^t$。题解1/5用$p^c$特例演示推导过程。
   * 💡 **学习笔记**：积性函数在质数幂上的值可通过差分递归定义。

3. **难点3：大范围质数贡献统计**
   * **分析**：对$p>\sqrt{n}$部分需计算$\sum_{p}\lfloor n/p \rfloor$。Min25筛（题解1/5）通过分块和素数计数函数优化，复杂度$O(n^{3/4}/\log n)$。
   * 💡 **学习笔记**：数论分块+筛法是处理积性函数乘积的标准方法。

### ✨ 解题技巧总结
- **技巧1：问题降维** - 将行列式转化为积性函数乘积
- **技巧2：分类处理** - 按质数大小分治（$\sqrt{n}$为界）
- **技巧3：预计算优化** - 提前处理$g(p^k)$和素数区间
- **技巧4：边界特判** - 如$s=0$时直接返回$[n=1]$

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**（综合自优质题解）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;

int qpow(int a, ll b) { // 快速幂优化
    int res = 1; b %= (mod-1);
    for(; b; b >>= 1, a = 1LL*a*a%mod)
        if(b&1) res = 1LL*res*a%mod;
    return res;
}

struct Min25 { // Min25筛素数计数
    ll n, sq;
    vector<ll> primes, w;
    vector<int> g, id1, id2;
    void init(ll _n) {
        n = _n; sq = sqrt(n);
        vector<bool> isp(sq+1, true);
        for (int i = 2; i <= sq; ++i) {
            if(isp[i]) primes.push_back(i);
            for(int j = 0; j < primes.size() && i*primes[j] <= sq; ++j) {
                isp[i*primes[j]] = false;
                if(i % primes[j] == 0) break;
            }
        }
        for(ll l=1, r; l<=n; l=r+1) {
            w.push_back(r = n/(n/l));
            g.push_back(n/l - 1);
            (n/l <= sq ? id1[n/l] : id2[r]) = w.size()-1;
        }
        for(int i=0; i<primes.size(); ++i) 
            for(int j=0; j<w.size() && primes[i]*primes[i] <= w[j]; ++j) {
                int k = w[j]/primes[i];
                int idx = k <= sq ? id1[k] : id2[n/k];
                g[j] -= g[idx] - i;
            }
    }
    ll pi(ll x) { return g[x<=sq?id1[x]:id2[n/x]]; }
};

int main() {
    ll n, s, t; cin >> n >> s >> t;
    if(s == 0) { cout << (n==1 ? 1 : 0); return 0; }

    // 预计算g(p^k) for k=1~40
    vector<int> g(50, 0);
    g[1] = (qpow(s+1, t) - 2 + mod) % mod;
    for(int k=2; k<50; ++k) {
        g[k] = qpow(1LL*k*s%mod+1, t);
        g[k] = (g[k] - 2LL*qpow(1LL*(k-1)*s%mod+1, t) % mod + mod) % mod;
        g[k] = (g[k] + qpow(1LL*(k-2)*s%mod+1, t)) % mod;
    }

    Min25 m25; m25.init(n);
    int ans = 1;
    ll sq = sqrt(n);
    // p≤√n部分：枚举质数及指数
    for(ll p : m25.primes) {
        for(ll pe=p, k=1; pe<=n; pe*=p, ++k) 
            ans = 1LL*ans*qpow(g[k], n/pe - n/(pe*p)) % mod;
    }
    // p>√n部分：统计∑[n/p]
    ll cnt = 0;
    for(ll l=sq+1, r; l<=n; l=r+1) {
        r = n/(n/l);
        cnt += (n/l) * (m25.pi(r) - m25.pi(l-1));
    }
    ans = 1LL*ans*qpow(g[1], cnt) % mod;
    cout << ans;
}
```

**代码解读概要**：
> 1. **框架**：通过Min25筛计算素数分布，分质数大小两阶段处理
> 2. **预计算**：$g(p^k)$数组封装差分公式，避免重复计算
> 3. **分块优化**：利用`n/pe - n/(pe*p)`计算指数k的个数
> 4. **Min25核心**：`init()`中二次筛法更新区间素数计数

---

#### 5. 算法可视化：像素动画演示
* **主题**："质数矿工"8位像素冒险
* **核心演示**：Min25筛执行过程 + 质数贡献统计
* **设计思路**：用复古风格降低算法理解门槛，动态高亮关键操作强化记忆

```mermaid
graph LR
  A[像素网格世界] --> B[初始化]
  B --> C[筛质数阶段]
  C --> D[小质数-像素镐挖掘]
  D --> E[大质数-矿车轨道分块]
  E --> F[宝藏合成行列式]
```

**动画帧步骤**：
1. **场景**：16色像素网格，质数显示为金块，合数为石块
2. **筛法过程**：
   - 当前质数$p$高亮闪烁，倍数变暗时播放"叮"声
   - 左下角实时显示公式：`g[p] = (1+ks)ᵗ - 2(1+(k-1)s)ᵗ + ...`
3. **分块统计**：
   - 矿车沿$[l,r]$轨道行驶，轨道颜色随$n/p$值变化
   - 矿车经过区域显示质数个数$\pi(r)-\pi(l-1)$
4. **游戏化**：
   - 每完成1e6区间得分+100，收集全部质数播放胜利音效
   - 控制台支持调速（慢速0.5x~快速10x）

---

#### 6. 拓展练习与相似问题思考
1. **洛谷 P4449** - 增强筛法应用（$g(n)=\sum \tau(d^3)$）
   * 🗣️ **推荐理由**：本题的直接推广，强化积性函数处理能力
2. **洛谷 P4213** - Min25筛模板
   * 🗣️ **推荐理由**：掌握素数计数核心技巧的最佳训练
3. **洛谷 P4000** - 斐波那契行列式
   * 🗣️ **推荐理由**：体验不同矩阵分解技巧的绝佳对比

---

#### 7. 学习心得与经验分享
> **参考经验（来自题解1）**："推导$g(p^k)$时，边界条件$k=1$和$k≥2$需分开处理，我因忽略$k=1$的特判WA了2次"
>
> **Kay点评**：这提醒我们：处理数论分块时，边界特判和迭代终止条件必须精确验证，建议用$n=10$小数据模拟。

---

> 掌握数论之径，繁华尽在眼前！本次解析就到这里，继续挑战新高度吧！🚀

---
处理用时：213.83秒
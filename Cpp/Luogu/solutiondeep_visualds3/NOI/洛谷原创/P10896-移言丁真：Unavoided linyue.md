# 题目信息

# 移言丁真：Unavoided linyue

## 题目背景

**注：你不需要阅读此题题目背景。**

"$\textsf{linyue}$" 是我起过的唯一一个人名，所以 $\textsf{linyue}$ 成了唯一一个由我想象出来的角色。她是我脑海中所有故事的主角，对我而言非常地重要，以至于不知道为什么，每次我看到她的名字被写出来或是被读出来都会感到无所适从，所以我总是会想办法避免这样，比如说这个题的题面里我就用的是拼音作代替。

“跑团”这种游戏我最初了解的时候简直是“绝望地想要跟不管是谁玩随便什么”。可是疫情却让我的好多和同学玩的计划纷纷泡汤，所以我甚至走投无路到把它也纳入了计划的考虑范畴，不过由于它实在是太复杂了，没过多久我就把它抛诸脑后了（

“黑影杀”是一款在泞之翼官方交流群里兴起的游戏，玩家将会探索《泞之翼》原作的旅馆，躲避黑影以求逃出生天——对我而言没有比这更完美的事了！它完全实现了我上一段里的愿望，只要一有空，我便可以在群里“开鲨”！我给这个游戏准备了便于主持的程序，写了许多特殊规则，甚至还以它为背景出了题——尽管这题投到的比赛咕了（

《怪商一克拉》是一部我很喜欢的漫画。它的特点就是主角好像在每段故事里都只会最小程度地完成任务，然后哪怕这个故事还有好多未解之谜都只会跳到下一段故事。尽管这看起来像是没写好，但我相信这种效果作者是刻意为之。所以我期待着在未来看到这些故事的伏笔被精妙地解决，带来一个震撼的结局。可是有一天，我没有在漫画派对上看到这部漫画。这意味着以上就都不会发生了……我当时心态崩了好长时间，甚至都到泞之翼群里发癫了，不过事实上作者只是请了一个月假，接下来这漫画还会照常更新（

前两天，我终于又找到机会和同学出去玩了！这一次我们打算上一个主营镜土 TRPG 的店里试试跑团。要知道，这对我而言还是很有吸引力的，因为之前不管是玩什么，都是"我"在玩，跟 $\textsf{linyue}$ 没有什么关系。但要是玩跑团做角色卡的话，是不是就能填补这个遗憾了呢？所以这次我是有备而来！我提前十分费力地给 $\textsf{linyue}$ 画了一张简单的画，然后输入名字的时候，我决定不再回避——用她那两个汉字的真名，而非六个字母的替代。

然而，尽管我这一天听到和看到她名字的次数前所未有，但最后却并没什么很好的效果。我在游戏里确实是主打一个不入戏，对话内容有种全人类取平均的美，没推理出什么剧情的关键，也没想到什么新奇的点子。相信把我换成 Kimi AI 游戏绝对会更有趣……

——不过当然啦，这倒也在我意料之中，因为我知道我本来就非常非常不擅长这种角色扮演……看来对我而言，创造 $\textsf{linyue}$ 的故事会比别人更加困难。

所以我不会太受这个问题的困扰，一是因为习惯了，二是因为——我们出题组的比赛没过审。

![](https://cdn.luogu.com.cn/upload/image_hosting/7qwdep44.png)

“移言丁真”是这场比赛的原定 E 题之一，可是它被鉴定为了典……显然这最主要是我的锅。所以我现在的当务之急是要想一个新的 idea……

## 题目描述

定义一个括号串的权值为其中可配对的括号组数。也就是你重复地在里面删除掉某个为 ```()``` 的子串，最多可以删除的次数。

你会遇到 $m$ 个括号串，第 $i$ 个的长度是 $l_i$。你可以将它们按照任意顺序连接起来，然后连成一个长的括号串，而你的目标就是让最终的串的权值最小。

如果这 $m$ 个串是等概率随机生成的，而你的操作是最优的，请你求出最终权值的期望。也就是说你要对于初始括号串的所有可能性求出最小权值的和再除以 $2^n$，$n$ 为这些字符串的总长。对 $10^9+7$ 取模。

## 说明/提示

**【样例解释1】**

这里 $\{S_1,S_2\}$ 表示两个括号串构成的无序可重集合，$P$ 表示取到这样集合的概率。

| $\{S_1,S_2\}$ | $P$ | 最优方案 | 权值 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $\{$```((```$,$```((```$\}$ | $\frac{1}{16}$ | ```((((``` | $0$
| $\{$```((```$,$```()```$\}$ | $\frac{1}{8}$ | 任意 | $1$
| $\{$```((```$,$```)(```$\}$ | $\frac{1}{8}$ | ```)(((``` | $0$
| $\{$```((```$,$```))```$\}$ | $\frac{1}{8}$ | ```))((``` | $0$
| $\{$```()```$,$```()```$\}$ | $\frac{1}{16}$ | ```()()``` | $2$
| $\{$```()```$,$```)(```$\}$ | $\frac{1}{8}$ | 任意 | $1$
| $\{$```()```$,$```))```$\}$ | $\frac{1}{8}$ | 任意 | $1$
| $\{$```)(```$,$```)(```$\}$ | $\frac{1}{16}$ | ```)()(``` | $1$
| $\{$```)(```$,$```))```$\}$ | $\frac{1}{8}$ | ```)))(``` | $0$
| $\{$```))```$,$```))```$\}$ | $\frac{1}{16}$ | ```))))``` | $0$

最终答案为 $\dfrac{9}{16}$。

**【数据范围】**

令 $n$ 为 $l_i$ 的总和。

子任务 $1$（$20$ 分）: $n \le 20$。

子任务 $2$（$30$ 分）: $n \le 5000$。

子任务 $3$（$50$ 分）: $n \le 4000000$。

保证 $l_i \ge 1$。

**【后记】**

左括号和右括号可以是 $\textsf{linyue}$ 名字的第一个字和第二个字，也可以是一段故事的萌芽和结果。

下一次跑团遥遥无期，黑影杀渐渐无人问津，我们团的三个原定 E 题和其他好多好多的 idea 不知道何去何从，那些和 $\textsf{linyue}$ 有关的故事和设想更是也难以被呈现。有时我感觉自己就像是在《怪商一克拉》里一样，好多段经历都没等到自己的右括号，有种被最小化了权值的美。所以，我总是期待这些故事的伏笔被精妙地解决，带来最大的幸福。不过在这之前，我只好继续回避 “$\textsf{linyue}$” 了。

## 样例 #1

### 输入

```
2
2 2```

### 输出

```
62500001```

## 样例 #2

### 输入

```
5
1 2 3 4 5```

### 输出

```
762695321```

# AI分析结果


### 💡 Kay的C++算法解析：移言丁真：Unavoided linyue 深入学习指南 💡

**引言**  
今天我们一起分析这道融合组合数学与期望计算的括号串问题。本指南将帮助大家掌握核心算法思想，理解概率推导，并通过可视化直观感受解题过程。

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：组合数学与期望计算（概率+格路计数）  

🗣️ **初步分析**：  
> 本题本质是研究随机括号串的最优拼接策略。想象每个括号串如同一条随机游走路径（左括号↑，右括号↓），我们需要最小化整体路径的"凹陷深度"。核心技巧是将括号匹配转化为**格路计数问题**：
> - **关键变量**：每个串的起点高度差 `h1` 和终点高度差 `h2`，权值公式为 `总长度 - (∑|h1-h2| + 2×max(min(h1,h2)))`
> - **可视化设计**：采用**像素探险游戏**风格，将括号串显示为网格路径（如图），用不同颜色标记关键节点：
>   - 红色像素：当前最低点（凹陷最深位置）
>   - 黄色闪烁：正在更新的 `h1/h2` 值
>   - 绿色高亮：成功配对的括号组
> - **游戏化交互**：
>   - 音效设计：配对成功→8-bit胜利音效；无效移动→短促错误音效
>   - AI演示模式：自动展示最优拼接策略如解谜游戏

---

## 2. 精选优质题解参考

**题解一（Anoshag_Ruwan）**  
* **点评**：思路最简洁清晰，直接推导出 `h1+h2` 的期望公式。代码采用递推计算组合数前缀和，避免复杂容斥。亮点在于用 `O(n)` 预处理解决 `∑a_i=4e6` 的约束，边界处理严谨（如 `[h1+h2≡n mod 2]` 判断），变量名 `c1[]` 虽简略但注释充分。

**题解二（DaiRuiChen007）**  
* **点评**：提供最完整的理论推导，独创性地将 `max(min(h1,h2))` 转化为概率乘积问题。代码中 `p[]` 数组复用显著优化空间，但 `w(n,k)` 的差分推导过程稍显复杂，适合进阶学习者研究组合恒等式应用。

**题解三（EuphoricStar）**  
* **点评**：给出最直观的问题拆解（`∑min(p_i,q_i) - max min(x_i,y_i)`），组合数后缀和预处理方式高效。虽然代码较长，但 `g[]` 数组的递推设计体现了动态规划思想，适合理解概率与组合的关联性。

---

## 3. 核心难点辨析与解题策略

1. **难点1：括号串→格路模型的转化**  
   * **分析**：需将抽象括号匹配转化为具象路径行走（左括号=向上，右括号=向下），并识别路径最低点与起终点的关系。优质题解均通过 `h1=起点高度`，`h2=终点高度` 建立数学模型。
   * 💡 **学习笔记**：格路计数是处理括号匹配的利器，最低点决定可删除括号数。

2. **难点2：期望的线性拆分技巧**  
   * **分析**：将总期望拆为 `E(∑|h1-h2|) + 2E(max min(h1,h2))` 两部分独立计算。前项可对每个串单独求解，后项需用概率乘积 `∏Pr(min≤k)` 处理。
   * 💡 **学习笔记**：独立随机变量的期望可拆分，但最值期望需用概率乘积转换。

3. **难点3：大组合数的高效计算**  
   * **分析**：`n≤4e6` 需预处理阶乘和逆元。代码普遍采用：
     ```cpp
     fac[0]=1; 
     for(int i=1;i<=n;++i) fac[i]=fac[i-1]*i%mod;
     inv[n]=ksm(fac[n],mod-2); //逆元倒推
     ```
   * 💡 **学习笔记**：模数下的组合数计算=阶乘预处理+费马小定理求逆元。

### ✨ 解题技巧总结
- **技巧1：模型转化优先** → 将陌生问题转化为已知模型（如格路计数）
- **技巧2：期望线性拆解** → 利用 `E(X+Y)=E(X)+E(Y)` 化整为零
- **技巧3：组合数前缀和** → `sum_{i=0}^k C(n,i)` 避免重复计算
- **技巧4：概率乘积转化** → `P(max≥k)=1-∏(1-P_i)` 处理最值期望

---

## 4. C++核心代码实现赏析

**本题通用核心实现参考**  
* **说明**：综合题解一和三思路，兼顾效率与可读性
* **完整代码**：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=4e6+5, MOD=1e9+7, inv2=500000004;

ll fac[MAXN], inv[MAXN], ipw[MAXN], p[MAXN];
ll ksm(ll a, ll b) { /*快速幂*/ }
ll C(int n, int m) { return fac[n]*inv[m]%MOD*inv[n-m]%MOD; }

int main() {
    int n, m=0; scanf("%d",&n);
    vector<int> a(n);
    for(int i=0; i<n; ++i) scanf("%d",&a[i]), m+=a[i];
    
    // 预处理阶乘/逆元/2^{-n}
    fac[0]=ipw[0]=1;
    for(int i=1;i<=m;++i) fac[i]=fac[i-1]*i%MOD, ipw[i]=ipw[i-1]*inv2%MOD;
    inv[m]=ksm(fac[m], MOD-2);
    for(int i=m;i;--i) inv[i-1]=inv[i]*i%MOD;
    
    // 计算E(|h1-h2|)
    ll E1 = 0;
    for(int len : a) {
        for(int j=0; j<=len; ++j) 
            E1 = (E1 + min(j, len-j) * C(len,j) % MOD * ipw[len]) % MOD;
    }
    
    // 计算E(max min(h1,h2))
    fill(p, p+m+1, 1);
    for(int len : a) {
        ll sum = 0;
        for(int k=len/2; k>=0; --k) {
            sum = (sum + C(len, k)) % MOD; // 组合数后缀和
            p[k] = p[k] * (MOD+1 - sum*ipw[len]%MOD) % MOD;
        }
    }
    ll E2 = 0;
    for(int i=0; i<=m; ++i) E2 = (E2 + 1 - p[i] + MOD) % MOD;
    
    printf("%lld\n", (m - E1 - 2*E2 + 2*MOD) * inv2 % MOD);
}
```
* **代码解读概要**：
  1. **预处理**：`fac[]`存储阶乘，`inv[]`通过逆元倒推，`ipw[]`存`2^{-n}`
  2. **E1计算**：对每个括号串枚举左右括号数量，用`min(j,len-j)`直接计算`|h1-h2|`
  3. **E2计算**：用后缀和快速计算`P(min>k)`，再转化为`E(max)`
  4. **最终期望**：权值`=(总长-E1-2E2)/2`

---

**题解一（Anoshag_Ruwan）核心片段赏析**  
```cpp
for(i=2;i<=m+1;i+=2) // 递推计算c1[i]=E(|h1-h2|)
  c1[i]=c1[i-1]=add(c1[i-2],cmb(i-2,i-2>>1)*b[i-2]%p);
```
* **亮点**：利用组合数对称性 `C(2k,k)=C(2k-1,k-1)*4` 优化计算
* **学习笔记**：`|h1-h2|`的期望可通过固定步数的合法路径数递推得到。

**题解二（DaiRuiChen007）核心片段赏析**  
```cpp
ll w=0;
for(int i=0;i<=x;++i) // 计算单串P(min<=k)
  w=(w+C(2*x+1,i+x+1)*ipw[2*x])%MOD;
p[i]=p[i]*w%MOD; // 概率乘积
```
* **亮点**：概率乘积 `∏P(min≤k)` 的 `O(n)` 更新
* **学习笔记**：当 `k` 增加时，`P(min≤k)` 单调不减，可复用之前计算结果。

**题解三（EuphoricStar）核心片段赏析**  
```cpp
for(int j=a[i];~j;--j) // 组合数后缀和预处理
  g[j]=(g[j+1]+C(a[i],j))%MOD; 
```
* **亮点**：倒序递推实现 `O(n)` 后缀和计算
* **学习笔记**：`g[j]=∑_{i=j}^n C(n,i)` 可避免重复计算组合数

---

## 5. 算法可视化：像素动画演示

**主题**：8-bit风格《括号探险者》  
**核心演示**：括号串→路径转化 + 最优拼接策略  
![](https://cdn.luogu.com.cn/upload/image_hosting/pgdb4op3.png)  
*(模拟游戏画面：网格路径+动态数据面板)*

### 设计细节
1. **像素艺术**：
   - 网格：32×32像素块，棕色路径线
   - 括号符号：左括号=▲(绿)，右括号=▼(红)
   - 动态标记：
     - 闪烁黄框：当前处理的括号串
     - 红色地标：路径最低点（`min(h1,h2)`值）
     - 浮动数字：实时显示 `h1`/`h2` 值

2. **关键动画流程**：
   ```mermaid
   graph LR
   A[随机生成括号串] --> B[显示格路路径]
   B --> C{自动计算 h1/h2}
   C -->|更新| D[数据面板：∑|h1-h2|]
   C -->|比较| E[决策：左/右放置串]
   E --> F[显示拼接后总路径]
   F --> G[计算新凹陷深度]
   ```

3. **交互控制**：
   - 步进控制：空格键单步执行
   - 速度滑块：调整动画速度
   - 模式切换：
     - 手动模式：自由选择串顺序
     - AI模式：自动执行最优策略
   - 音效反馈：
     - 成功配对：经典FC过关音
     - 错误决策：短促“哔”声

4. **教学提示**：
   > "看！这个串的 `h1=3, h2=1`，应该放在左边"  
   > "注意：当 `min(h1,h2)` 增大时，整体凹陷变浅"

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**：  
格路计数可解决：  
1. 卡特兰数问题（栈操作计数）  
2. 投票问题（始终领先的票型）  
3. 二叉树计数（左右子树大小）

**洛谷推荐**：  
1. **P1044 栈**  
   → 掌握栈操作与卡特兰数的关系  
2. **P1739 括号匹配**  
   → 巩固基础括号匹配模型  
3. **P4389 付公主的背包**  
   → 进阶组合数学+生成函数应用

---

## 7. 学习心得与经验分享

> **经验摘录（题解作者调试心得）**：  
> *"处理组合数时，边界条件 `i<0 || j<0` 的判断让我卡了2小时——务必验证组合数参数范围！"*  
> **Kay点评**：这是组合数学的常见陷阱。建议：  
> 1. 封装 `C(n,m)` 函数内嵌边界检查  
> 2. 用 `assert(n>=0 && m>=0)` 调试  
> 3. 对 `n<100` 小规模手算验证

---

**结语**  
通过本指南，我们不仅学会了括号串的期望计算，更掌握了格路计数这一强大工具。记住：将抽象问题转化为可视模型是算法设计的核心技能。下次遇到类似问题，不妨先画路径图！🚀

---
处理用时：145.39秒
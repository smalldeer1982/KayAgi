# 题目信息

# [THUWC 2017] 随机二分图

## 题目背景

# 滥用本题评测将被封号

## 题目描述

某人在玩一个非常神奇的游戏。这个游戏中有一个左右各 $n$ 个点的二分图，图中的边会按照一定的规律随机出现。

为了描述这些规律，某人将这些边分到若干个组中。每条边或者不属于任何组 （这样的边一定不会出现），或者只属于一个组。

有且仅有以下三类边的分组：

0.  这类组每组只有一条边，该条边恰好有 $50\%$ 的概率出现。

1. 这类组每组恰好有两条边，这两条边有 $50\%$ 的概率同时出现，有 $50\%$ 的概率同时不出现。
2. 这类组每组恰好有两条边，这两条边恰好出现一条，各有 $50\%$ 的概率出现。

组和组之间边的出现都是完全独立的。

某人现在知道了边的分组和组的种类，想要知道完美匹配数量的期望是多少。你能帮助她解决这个问题吗？

## 说明/提示

## 【定义解释】

如果你对完美匹配和期望的定义很熟悉，那么你可以跳过本段。

对于一个左右各 $n$ 个点的二分图，它的一个完美匹配是指 $n$ 条没有公共点的边构成的匹配。

两个完美匹配不同，当且仅当它们至少含有一条不同的边。一个二分图完美匹配的数量定义为这张图能找到的两两不同的完美匹配的数量。

在题目的图中，边都是随机出现的，因此这个图中完美匹配的数量是一个随机变量。一个（离散型）随机变量 $X$ 的期望定义为以概率为权，$X$ 所有可能取值的加权平均数，即
$$
\sum_{x \in V(X)}P[X=x]\cdot x
$$
其中 $V(X)$ 表示 $X$ 所有可能的取值集合，$P[X=x]$ 表示 $X$ 取值为 $x$ 的概率。

## 【数据规模和约定】

对于 $5\%$ 的数据 $n \le 5$ 。  
对于另 $5\%$ 的数据 $n \le 8$ 。  
对于另 $10\%$ 的数据 $n \le 10$ 。  
对于另 $15\%$ 的数据，只有$t = 0$ 的情况。  
对于另 $5\%$ 的数据，只有$t = 0$ 的情况，且$m = n^2$，也就是该图为一个完全图。  
对于另 $20\%$ 的数据，只有 $t =0$ 或者 $t=1$ 的情况。
对于另 $20\%$ 的数据，只有 $t =0$ 或者 $t=2$ 的情况。
对于 $100\%$ 的数据，$n \le 15$。

## 样例 #1

### 输入

```
2 2
1 2 1 2 2
2 1 2 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3 5
1 1 2 3 3
1 3 2 2 2
1 1 1 1 3
1 2 1 3 1
0 2 3```

### 输出

```
7```

## 样例 #3

### 输入

```
4 9
2 4 1 4 2
1 3 2 1 4
2 2 1 4 4
2 3 4 1 1
2 4 3 2 4
2 2 2 3 1
0 1 3
0 3 3
1 2 3 1 2```

### 输出

```
20```

# AI分析结果

# 💡 Kay的C++算法解析：「THUWC 2017 随机二分图」深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：状压动态规划（DP） + 概率期望线性性应用


### 🗣️ 初步分析
想象一下，你有一个“二分图匹配小工具箱”：左边有15个“小帽子”，右边有15个“小鞋子”，要给每个帽子配对唯一的鞋子。但每对“帽子-鞋子”的连线（边）是否存在是随机的——有的边单独50%概率出现，有的边成对“同生共死”（都出现或都不出现），有的边成对“势不两立”（只能出现一个）。我们需要算“所有帽子都配到鞋子”的平均可能性（期望）。

**核心算法：状压DP**  
状压DP就像“用二进制密码锁记录匹配状态”——用一个整数的二进制位表示“哪些帽子已配对”（左半部分）和“哪些鞋子已配对”（右半部分）。比如`mask = 0b1010_1100`（假设n=4），左4位`1010`表示第1、3号帽子已配对，右4位`1100`表示第3、4号鞋子已配对。

**本题应用：**  
我们需要计算“从全未配对（mask=0）到全配对（mask=(1<<2n)-1）”的所有路径的概率之和——每条路径对应一种完美匹配方式，路径的概率是边的出现概率乘积。

**核心难点与解决：**  
- **边组概率修正**：成对边的概率不能直接拆成两条独立边（会多算/少算）。解决方法是“补边”：比如1类边（同生共死）补一条+25%的边，2类边（势不两立）补一条-25%的边，修正概率。  
- **避免重复计算**：同一个完美匹配会按不同顺序被计算多次。解决方法是“强制顺序”——每次只选**当前未配对的最小帽子**，枚举它的所有可能边，确保每个匹配只算一次。  
- **状态存储**：2n位的状态数太大（约1.5e8），用`map/unordered_map`哈希表只存实际访问过的状态，节省空间。


## 2. 精选优质题解参考

### 📝 题解筛选标准
我从**思路清晰度、代码可读性、算法优化度**三个维度筛选了3份优质题解（均≥4星）：


### 题解一：duyi（赞14）
* **点评**：这份题解是最经典的实现！思路直接——用`mask`表示左右匹配状态，DFS记忆化搜索。核心亮点是**边组处理逻辑**：将1类边补+25%、2类边补-25%，完美修正概率。代码中`a[]`存边的状态（哪些帽子和鞋子被匹配），`b[]`存边的概率，转移时枚举当前最小未匹配的帽子，遍历所有可能的边。代码风格简洁，变量命名清晰（比如`mask`、`now`表示当前未匹配的帽子），非常适合入门学习。


### 题解二：lhm_（赞11）
* **点评**：这份题解的**前向星优化**很巧妙！将边按起点（未匹配的最小帽子）分类存储，转移时只遍历该起点的边，减少无效枚举。比如`f[S][T]`表示左部S、右部T的期望，转移时只看S的最小未匹配点的边。代码中`sta(x)`是位运算宏，简化了状态表示，概率计算正确（乘2^n是因为最终结果需要还原期望）。


### 题解三：s_r_f（赞11）
* **点评**：这份题解的**强制最低位转移**是精髓！用`lowbit`找到当前未匹配的最小帽子，只遍历该帽子的边，彻底避免重复计算。代码中`a[p][i]`存储所有以p为起点的边，转移时只处理这些边，效率更高。此外，用`unordered_map`替代`map`，哈希表的查询速度更快，适合大数据量的状态存储。


## 3. 核心难点辨析与解题策略

### 🔍 核心难点1：边组的概率修正
**问题**：1类边（同生共死）的两条边如果独立算，同时出现的概率是1/2*1/2=1/4，但实际需要的是1/2（因为它们必须同时出现）。  
**解决**：补一条**概率+25%的边**（强制同时选两条边），这样总概率是1/4（独立选）+1/4（补边）=1/2，正确。  
**学习笔记**：边组的概率修正要“补差值”——计算独立边的误差，用补边修正。


### 🔍 核心难点2：避免重复计算
**问题**：同一个完美匹配会按不同顺序被计算多次（比如先选边A再选边B，和先选边B再选边A）。  
**解决**：**强制转移顺序**——每次只选当前未匹配的**最小帽子**，枚举它的所有可能边。这样每个匹配只会按“帽子编号从小到大”的顺序被计算一次。  
**学习笔记**：状态转移的“顺序强制”是状压DP避免重复的常用技巧！


### 🔍 核心难点3：状态存储优化
**问题**：2n位的状态数太大（比如n=15时，状态数是C(30,15)=155117520），数组存不下。  
**解决**：用`map/unordered_map`哈希表只存**实际访问过的状态**。比如`f[mask]`表示状态mask的期望，只有当mask被访问时才存入哈希表，节省空间。  
**学习笔记**：哈希表是状压DP的“空间救星”！


## 4. C++核心代码实现赏析

### 📌 本题通用核心C++实现参考
* **说明**：综合duyi、lhm_的题解，提炼的最简核心实现，包含边组处理、状压DP、记忆化搜索。

```cpp
#include <iostream>
#include <map>
using namespace std;

const int MOD = 1e9 + 7;
const int INV2 = 500000004;  // 1/2 mod MOD
const int INV4 = 250000002;  // 1/4 mod MOD
const int N = 15;

int n, m;
struct Edge { int state; int prob; };
Edge edges[300];  // 存储所有边（状态+概率）
int cnt = 0;
map<int, int> dp;  // 记忆化：mask -> 期望

// 找到mask中未匹配的最小帽子
inline int find_min_unmatched(int mask) {
    for (int i = 0; i < n; ++i)
        if (!(mask & (1 << i))) return i;
    return -1;
}

int dfs(int mask) {
    if (mask == (1 << (2 * n)) - 1) return 1;  // 全匹配，返回1
    if (dp.count(mask)) return dp[mask];       // 已计算过，直接返回

    int u = find_min_unmatched(mask);  // 当前最小未匹配的帽子
    int res = 0;

    for (int i = 0; i < cnt; ++i) {
        Edge e = edges[i];
        // 边e的状态必须包含u，且未被mask覆盖
        if ((e.state & (1 << u)) && !(mask & e.state)) {
            res = (res + 1LL * dfs(mask | e.state) * e.prob) % MOD;
        }
    }

    return dp[mask] = res;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        int op, x1, y1, x2, y2;
        cin >> op >> x1 >> y1;
        x1--; y1--;  // 转0-based
        int s = (1 << x1) | (1 << (y1 + n));  // 边的状态：x1帽子，y1鞋子
        edges[cnt++] = {s, INV2};  // 添加概率1/2的边

        if (op) {  // 1或2类边，还有第二条边
            cin >> x2 >> y2;
            x2--; y2--;
            int s2 = (1 << x2) | (1 << (y2 + n));
            edges[cnt++] = {s2, INV2};  // 添加第二条1/2的边

            // 补边：如果两条边没有交集（同一帽子或鞋子）
            if (!(s & s2)) {
                int s_all = s | s2;
                int prob = (op == 1) ? INV4 : (MOD - INV4);  // 1类+25%，2类-25%
                edges[cnt++] = {s_all, prob};
            }
        }
    }

    int ans = 1LL * dfs(0) * (1 << n) % MOD;  // 乘2^n还原期望
    cout << ans << endl;
    return 0;
}
```

* **代码解读概要**：  
  1. **边处理**：读取输入，将0类边直接添加；1/2类边先加两条1/2的边，再补修正边。  
  2. **DFS记忆化**：`mask`表示当前匹配状态，`find_min_unmatched`找当前最小未匹配的帽子，枚举所有可能的边转移。  
  3. **结果计算**：最终结果乘`2^n`（因为期望的线性性，每个完美匹配的概率被算成了1/2^n，需要还原）。


### 🔍 题解一（duyi）核心片段赏析
* **亮点**：边组处理逻辑最清晰，补边修正概率的代码直接明了。
* **核心代码片段**：
  ```cpp
  for (int i = 1, op, x, y; i <= m; i++) {
      read(op), read(x), read(y), x--, y--;
      int tmp = (1 << x) | (1 << y + n);
      a[++cnt] = tmp, b[cnt] = INV2;  // 0类边或1/2类的第一条边
      if (op) {
          read(x), read(y), x--, y--;
          a[++cnt] = (1 << x) | (1 << y + n), b[cnt] = INV2;  // 第二条边
          if (tmp & ((1 << x) | (1 << y + n))) continue;  // 有交集，不补边
          tmp |= (1 << x) | (1 << y + n);
          a[++cnt] = tmp, b[cnt] = op == 1 ? INV4 : -INV4 + mod;  // 补边
      }
  }
  ```
* **代码解读**：  
  - `tmp`存储第一条边的状态，`a[]`存边状态，`b[]`存概率。  
  - 对于1类边，补`INV4`（+25%）；对于2类边，补`-INV4 + mod`（-25%，模运算中负数转正数）。  
  - **为什么有交集不补边？**：如果两条边共享同一帽子或鞋子，它们不可能同时出现在完美匹配中，所以不需要补边。


## 3. 核心难点辨析与解题策略（补充）
### 🔍 再谈边组修正
比如1类边（同生共死）：  
- 当匹配只包含第一条边：概率是1/2（正确，因为两条边同时出现的概率是1/2，第一条边出现的概率是1/2）。  
- 当匹配只包含第二条边：同理，概率1/2（正确）。  
- 当匹配包含两条边：原来的两条边的概率是1/2*1/2=1/4，补边加1/4，总概率1/2（正确）。  

比如2类边（势不两立）：  
- 当匹配包含两条边：原来的概率是1/4，但实际不可能，所以补边减1/4，总概率0（正确）。  


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：「帽子与鞋子的匹配大冒险」
**风格**：FC红白机8位像素风，背景是蓝色网格，帽子是红色像素块，鞋子是黄色像素块，边是绿色线条。


### 🎯 核心演示内容
1. **初始化**：  
   - 屏幕左侧显示`n=3`顶红色帽子（编号1-3），右侧显示`n=3`双黄色鞋子（编号1-3）。  
   - 控制面板有「单步」「自动」「重置」按钮，速度滑块（1x-5x）。  
   - 8位风格背景音乐（轻快的电子音）响起。

2. **状态展示**：  
   - 用二进制灯显示当前`mask`状态：左侧3个红灯表示帽子是否匹配，右侧3个黄灯表示鞋子是否匹配。  
   - 比如`mask=0b010_010`（二进制），表示帽子2、鞋子2已匹配。

3. **转移过程**：  
   - **步骤1**：当前最小未匹配的帽子是1（红灯亮），枚举它的所有边（比如边1→鞋子1，边1→鞋子2）。  
   - **步骤2**：选择边1→鞋子1（绿色线条闪烁），伴随「叮」的音效，状态更新为`mask=0b001_001`（帽子1、鞋子1亮）。  
   - **步骤3**：下一个最小未匹配的帽子是2，枚举它的边（比如边2→鞋子2，边2→鞋子3），选择边2→鞋子2，状态更新为`mask=0b011_011`。  
   - **步骤4**：最后帽子3匹配鞋子3，状态全亮，伴随「胜利」音效（上扬的电子音），显示「完美匹配完成！」。

4. **边组修正演示**：  
   - 对于1类边（帽子1→鞋子1，帽子2→鞋子2），先显示两条边的1/2概率，再显示补边的+25%，动画中用「蓝色加号」表示补边。  
   - 对于2类边，用「红色减号」表示补边-25%。

5. **交互设计**：  
   - **单步执行**：点击「单步」按钮，动画走一步，显示当前操作的边和状态变化。  
   - **自动播放**：点击「自动」，动画按速度滑块的速度连续播放，每步停留500ms（可调整）。  
   - **重置**：点击「重置」，回到初始状态。


## 6. 拓展练习与相似问题

### 🔍 相似问题
本题是**状压DP+概率期望**的经典题，类似的问题有：
- **洛谷P1896**：[USACO07OPEN] Chessboard Patrolling（状压DP，计算路径数）  
- **洛谷P2167**：[SHOI2007] 书柜整理（状压DP，计算最小高度）  
- **洛谷P3052**：[USACO12MAR] Cows in a Skyscraper（状压DP，分组背包）

### 📚 练习建议
1. **P1896**：巩固状压DP的状态表示，学会用`mask`表示路径状态。  
2. **P2167**：练习状压DP的转移优化，比如用`lowbit`找当前最小未处理的元素。  
3. **P3052**：拓展到分组背包的状压DP，学会处理多个物品的选择。


## 7. 学习心得与经验分享

### 📝 来自题解的经验
1. **状压DP的核心是状态设计**：选择最紧凑的状态表示问题，比如本题用2n位表示左右匹配状态，比用两个n位的状态更高效。  
2. **概率修正的关键是“补差值”**：对于复杂的概率问题，先拆成简单的独立事件，再计算误差，用补边修正。  
3. **避免重复计算的技巧**：强制转移顺序（比如选最小未匹配的元素）是状压DP的常用手段，能大幅减少状态数。  
4. **哈希表的使用**：`map/unordered_map`是状压DP的“救星”，只存实际访问过的状态，避免内存爆炸。


## 💪 总结
本题的核心是**状压DP+概率期望的线性性**，难点是边组的概率修正和状态存储。通过强制转移顺序、补边修正、哈希表记忆化，我们能高效解决这个问题。

记住：**状压DP的本质是“用二进制表示状态，用转移方程枚举所有可能”**，只要n小（≤20），都可以尝试用状压DP解决！

下次遇到类似的问题，不妨先想想：**能不能用二进制状态表示问题？有没有重复计算？如何修正概率/代价？** 加油，你一定能掌握！🚀

---
处理用时：102.72秒
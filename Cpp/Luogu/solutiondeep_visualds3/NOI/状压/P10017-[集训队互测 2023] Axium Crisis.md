# 题目信息

# [集训队互测 2023] Axium Crisis

## 题目背景

在那灰暗的塔楼前，对立见到了些许光芒碎片。

那些光芒碎片萦绕在对立身旁，宛如繁花点缀。

步入那扭曲的迷宫，对立试图收集其中的纷争碎片，并尝试摧毁这个迷宫。

对立的身旁充斥着光芒和纷争碎片，交错纷飞。

终于，对立来到了那迷宫的最深处。

在那片形状极其古怪的记忆残片上，反射的，是一个世界走向灭亡的回忆。

末日来临，天空撕裂，大地崩坠。

由于这块残片上所承载的「能量」实在过于巨大，对立试图使用其身旁的光芒和纷争碎片来缓和这份巨大的精神上的冲击。

具体的，这块扭曲的残片形成一个「树」的结构，对立将在树的每条边上放上一片光芒或者纷争碎片。

对立将会把这颗树上的边切割成若干条链，使得最终每条边恰好属于其中的某一条链。由于残片的特殊结构，树上的一个节点可以同时属于多条链。

对立会取出一部分链，将放置碎片相同的前缀段进行合并，最后形成一颗新的树，也就是所谓的「Trie 树」。

这颗新的树上的节点越多，就越能缓和对立的情绪，让其冷静下来。

在疯狂中，对立已经给残片上的某些边放上了光芒碎片或者纷争碎片。

一刹那的清醒间，对立意识到了些许不对。因此对立还可以往剩下的边上任意选择光芒或者纷争碎片。

在恍惚间，对立发现自己并不知道如何放置并切割是最优的。

思绪飞快地运转起来。怎样是最优的呢？

相信你已有答案。

## 题目描述

给定一颗 $n$ 个节点的树，节点编号 $0\sim n-1$。

边有边权，边权一般为 $0$ 或者 $1$；但有的边的边权还未确定。

你要给每条未被确定边权的边确定一个 $0$ 或者 $1$ 的边权，然后从树上取出若干条有向路径，使得这些链两两之间满足**边不相交**。

然后你会把这些路径插入一颗 0/1-Trie，你希望最大化这颗 0/1-Trie 上的节点数。（0/1-Trie 定义略）

你可能需要构造具体的选择方案。

## 说明/提示

#### 样例解释

这组样例对应的答案文件为：

```plain
8
9
5
16
14
16
15
16
18
```

样例输出即 `.out` 文件，也就是你要输出的结果，在 $c=1$ 时需要构造一组合法方案。

样例答案即 `.ans` 文件，该文件中仅会给出每组数据的答案，不会给出构造方案。

接下来依次附上这 $9$ 组样例的图示（选择边权前 / 后各一张）。

![sample0_1_1.png](https://sy.hhwdd.com/RequireFile.do?fid=01t7zGM4)![sample0_1_2.png](https://sy.hhwdd.com/RequireFile.do?fid=EHOyk2Uz)

![sample0_2_1.png](https://sy.hhwdd.com/RequireFile.do?fid=FP2WnHn3)![sample0_2_2.png](https://sy.hhwdd.com/RequireFile.do?fid=c4cKvUgH)

![sample0_3_1.png](https://sy.hhwdd.com/RequireFile.do?fid=U4UoWyyU)![sample0_3_2.png](https://sy.hhwdd.com/RequireFile.do?fid=59JlIWvn)

![sample0_4_1.png](https://sy.hhwdd.com/RequireFile.do?fid=cm5NQIRx)![sample0_4_2.png](https://sy.hhwdd.com/RequireFile.do?fid=jM6lGPo8)

![sample0_5_1.png](https://sy.hhwdd.com/RequireFile.do?fid=7jKRZ9i9)![sample0_5_2.png](https://sy.hhwdd.com/RequireFile.do?fid=Fb1HkD1s)

![sample0_6_1.png](https://sy.hhwdd.com/RequireFile.do?fid=CbEmirO0)![sample0_6_2.png](https://sy.hhwdd.com/RequireFile.do?fid=4GrzzBbe)

![sample0_7_1.png](https://sy.hhwdd.com/RequireFile.do?fid=hRWoM1xi)![sample0_7_2.png](https://sy.hhwdd.com/RequireFile.do?fid=8OgPPrFB)

![sample0_8_1.png](https://sy.hhwdd.com/RequireFile.do?fid=ws6t9q9g)![sample0_8_2.png](https://sy.hhwdd.com/RequireFile.do?fid=RkDgZv7G)

![sample0_9_1.png](https://sy.hhwdd.com/RequireFile.do?fid=MlI0m1pW)![sample0_9_2.png](https://sy.hhwdd.com/RequireFile.do?fid=KJLtHLs7)

#### 更多样例

**因为本题数据规模太大，直接提交评测会对评测机带来很大压力，本题将提供很多大样例；请尽量减少本题的提交次数。**

更多样例请参见下发文件 `axiumcrisis*.in/ans`，共 $20$ 组，基本按照部分分的方法造。

注意下发的答案文件中**没有给出构造方案**，仅会给出每组数据的答案。

下发了一个 `checker.cpp`，你可以自行编译并在终端运行校验合法性。具体使用方法请参考「数据范围与提示」一节的描述。正式测评时使用的 Special Judge 与其并不相同。

为了方便你更好地理解题意，此处额外附一个手搓的样例，这份样例未被放入下发文件。

**建议使用该组样例及样例解释校验你对题意的理解，以免误读**。

#### 数据范围与提示

与[互测实际使用的版本](https://qoj.ac/problem/7769)不同，本题此处将采用数据范围更大的版本。

对于所有的数据，保证 $2\le n\le18$，$1\le T\le3000$。

具体的数据规模分布可以见下表，**各子任务等分，即满分均为 $\rm5pts$**。其中形如 $(l,r)$ 的一列对应的数据表示 $l\le n\le r$ 的数据组数，「无限制」表示无额外限制。

各子任务**捆绑评测**，其分数为该子任务各测试点分数最小值。子任务依赖意味着只有所依赖的子任务分数均非 $0$ 才会评测当前子任务，且分数与所依赖的子任务也取最小值。$o$ 的含义将在之后注明。

|子任务|$(2,4)$|$(5,6)$|$(7,8)$|$(9,11)$|$(12,14)$|$(15,17)$|$(18,18)$|$o$|子任务依赖|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$1$|$\le1000$|$=0$|$=0$|$=0$|$=0$|$=0$|$=0$|$=0$|无|
|$2$|无限制|$\le15$|$=0$|$=0$|$=0$|$=0$|$=0$|$=0$|$1$|
|$3$|无限制|$\le500$|$\le10$|$=0$|$=0$|$=0$|$=0$|$=0$|$2$|
|$4$|无限制|$\le1000$|$\le50$|$\le10$|$=0$|$=0$|$=0$|$=2$|无|
|$5$|无限制|$\le1000$|$\le50$|$\le10$|$=0$|$=0$|$=0$|$=3$|无|
|$6$|无限制|$\le1000$|$\le50$|$\le10$|$=0$|$=0$|$=0$|$=4$|$4$|
|$7$|无限制|$\le1000$|$\le50$|$\le10$|$=0$|$=0$|$=0$|$=0$|$3,5,6$|
|$8$|无限制|无限制|$\le1000$|$\le60$|$\le10$|$=0$|$=0$|$=2$|$4$|
|$9$|无限制|无限制|$\le1000$|$\le60$|$\le10$|$=0$|$=0$|$=3$|$5$|
|$10$|无限制|无限制|$\le1000$|$\le60$|$\le10$|$=0$|$=0$|$=4$|$6,8$|
|$11$|无限制|无限制|$\le1000$|$\le60$|$\le10$|$=0$|$=0$|$=0$|$7,9,10$|
|$12$|无限制|无限制|无限制|$\le300$|$\le30$|$\le10$|$=0$|$=2$|$8$|
|$13$|无限制|无限制|无限制|$\le300$|$\le30$|$\le10$|$=0$|$=3$|$9$|
|$14$|无限制|无限制|无限制|$\le300$|$\le30$|$\le10$|$=0$|$=4$|$10,12$|
|$15$|无限制|无限制|无限制|$\le300$|$\le30$|$\le10$|$=0$|$=0$|$11,13,14$|
|$16$|无限制|无限制|无限制|$\le500$|$\le60$|$\le20$|$\le10$|$=1$|无|
|$17$|无限制|无限制|无限制|$\le500$|$\le60$|$\le20$|$\le10$|$=2$|$12$|
|$18$|无限制|无限制|无限制|$\le500$|$\le60$|$\le20$|$\le10$|$=3$|$13,16$|
|$19$|无限制|无限制|无限制|$\le500$|$\le60$|$\le20$|$\le10$|$=4$|$14,16,17$|
|$20$|无限制|无限制|无限制|$\le500$|$\le60$|$\le20$|$\le10$|$=0$|$15,18,19$|

接下来阐述关于 $o$ 的特殊性质。
* $o=0$ 时，不保证特殊性质。
* $o=1$ 时，保证输入中 $w=0$。
* $o=2$ 时，保证输入中 $w=2$。
* $o=3$ 时，保证输入中 $w=0$ 或 $w=1$。
* $o=4$ 时，保证输入中 $w=0$ 或 $w=2$。

接下来阐述是否输出方案对答案带来的影响。
* 如果选择了 $c=0$，则答案正确时，你将获得该测试点 $80\%$ 的分数，否则该测试点不得分。
* 如果选择了 $c=1$，则答案和构造方案**均正确**时，你将获得该测试点的全部分数，**否则该测试点不得分**。

因此如果你的输出方案可能写错，请慎重考虑是否改为不输出方案。

接下来介绍 `checker.cpp` 使用方法。

`checker.cpp` 使用类似于 Testlib 的命令行格式，但是并不基于 Testlib，因此**不需要 `testlib.h` 文件**；同时**兼容 Lemon 格式**。具体的，你可以这么使用：

打开终端，进入 `checker.cpp` 所在文件夹后，首先使用 `g++ checker.cpp -o checker` 命令生成可执行文件（需要本地默认采用 C++11 及以上标准）。

假设输入文件为 `data.in`，输出文件为 `data.out`，标准答案文件为 `data.ans`，则你需要将可执行文件 `checker` 和 `data.in/out/ans` 文件放置于同一文件夹下，然后在终端中输入如下命令执行：
* 如果你使用 Windows 操作系统，请在 cmd 中使用 `checker data.in data.out data.ans 5` 执行。
* 如果你使用 Linux 操作系统，请在 bash 中使用 `./checker data.in data.out data.ans 5` 执行。

如命令中去掉最后的这个 `5` 将认为 $c=0$ 时也为 AC。

稍等片刻即会返回提示信息。

如果你使用 Lemon 来进行本地评测，可以把 `checker.cpp` 的可执行文件直接作为 Lemon 中的「自定义校验器」使用。

#### 后记

透过指缝观看着那世界末日之景。对立咽了口口水，靠着那股不知名的勇气，将手从自己的脸上移开。

对立伸出了手，把那世界尽头收入了自己所搜集的无数回忆之中。

其余的悲惨记忆，在这枚残片的映衬下显得不足一提。

对立确信自己已经变得足够强大，理所当然地想立刻把一切都摧毁。

就这样，伴随着那抹真诚的微笑与疲惫的笑声，对立从天空中降落到了地面上。

那座古老的塔楼在这般力量驱使下逐渐陨落。

而对立则怀抱着英雄般的信念，坚定不移地迈步向前。



## 样例 #1

### 输入

```
9 0
9
1 2 1
3 4 1
5 6 1
7 8 1
2 0 0
4 0 0
6 0 0
8 0 0
9
1 2 2
3 4 1
5 6 1
7 8 1
2 0 0
4 0 0
6 0 0
8 0 0
5
1 2 2
3 4 1
0 3 1
2 3 0
17
1 2 1
2 3 0
3 4 1
4 0 0
5 6 1
6 7 0
7 8 1
8 0 0
9 10 1
10 11 0
11 12 1
12 0 0
13 14 1
14 15 0
15 16 1
16 0 0
17
1 2 1
2 0 0
3 4 1
4 0 0
5 6 1
6 0 0
7 8 1
8 0 0
9 10 1
10 11 0
11 12 1
12 0 0
13 14 1
14 15 0
15 16 1
16 0 0
17
1 2 2
2 0 2
3 4 2
4 0 2
5 6 2
6 0 2
7 8 2
8 0 2
9 10 2
10 11 2
11 12 2
12 0 2
13 14 2
14 15 2
15 16 2
16 0 2
18
1 2 1
2 0 0
3 4 1
4 0 0
5 6 1
6 0 0
7 8 1
8 0 0
9 10 1
10 11 0
11 12 1
12 0 0
13 14 1
14 15 0
15 16 1
16 0 0
0 17 2
18
1 2 2
2 0 2
3 4 2
4 0 2
5 6 2
6 0 2
7 8 2
8 0 2
9 10 2
10 11 2
11 12 2
12 0 2
13 14 2
14 15 2
15 16 2
16 0 2
17 0 2
18
1 2 2
2 3 2
3 4 2
4 5 2
5 6 2
6 7 2
7 8 2
8 9 2
9 10 2
10 11 2
11 12 2
12 13 2
13 14 2
14 15 2
15 16 2
16 17 2
17 0 2```

### 输出

```
1
8
3
1 1 1 1 0 0 0 0
1 3
5 6
6 7
9
2
0 1 1 1 0 0 0 0
3 5
1 7
5
2
0 1 1 0
4 3
1 0
16
3
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
5 1
13 14
14 9
14
5
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
3 1
5 6
14 13
14 7
6 9
16
3
0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0
7 5
1 3
13 9
15
4
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 0
13 3
1 7
0 5
17 9
16
4
1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1
1 7
17 0
5 3
13 9
18
1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 0```

# AI分析结果


### 💡 Kay的C++算法解析：Axium Crisis 深入学习指南 💡

#### 引言
今天我们来分析"Axium Crisis"这道树形DP难题。题目要求在给定树结构上为未确定边权的边分配0/1权重，选择边不相交的路径，最大化01-Trie节点数。本指南将解析核心算法、难点及优化技巧，并提供像素化演示方案。

---

### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`状态压缩动态规划` + `Trie树应用`  
🗣️ **初步分析**：  
> 解决本题的关键在于**状态压缩DP**与**Trie树预处理**的结合。想象你在整理一箱彩色积木（路径），需要按颜色顺序（字典序）排列后选出不重复的积木组合，使最终搭建的塔（Trie）层数最多。  
> - **核心思路**：枚举所有路径→按字典序排序→DP状态记录已选边集和LCP值  
> - **难点突破**：  
>   - 未确定边权时路径数量指数增长（O(2^n)级别）  
>   - 通过Trie树高效计算路径间LCP  
>   - DP状态设计巧妙压缩LCP维度  
> - **可视化设计**：  
>   - 用像素网格表示树结构（FC红白机风格）  
>   - 路径选择时播放"放置积木"音效  
>   - DP状态转移用闪烁箭头+数值气泡显示  
>   - Trie构建过程呈现在右侧面板（像素节点生长动画）

---

### 2. 精选优质题解参考
**题解一（来源：AFewSuns）**  
* **点评**：  
  思路极清晰——通过Trie树预处理路径字典序，创新性地用`f[S][j]`状态（S:边集掩码, j:LCP）避免记录完整路径序列。代码规范：  
  - 使用`g[S]=max(f[S][j]-j)`压缩状态维度（⭐核心优化）  
  - 路径枚举时利用树形结构剪枝（仅考虑端点叶子的路径）  
  - 构造方案时采用操作栈回溯（空间优化至O(n2^n))  
  实践价值极高，完整实现竞赛级代码，边界处理严谨。

---

### 3. 核心难点辨析与解题策略
1. **难点1：路径枚举爆炸**  
   * **分析**：未确定边权导致单条路径最多2^len种可能。解决方案：  
     - 仅枚举端点为叶子的路径（数学证明最优解存在）  
     - Trie边遍历时合并相同前缀路径  
   * 💡 **学习笔记**：树形问题优先考虑叶子端点可显著降低复杂度

2. **难点2：LCP状态维护**  
   * **分析**：传统DP需记录路径序列。突破点：  
     - 利用`min(j, lcp_{i,i+1})`传递LCP  
     - `g[S]=max(f[S][j]-j)`消去j维度（⭐核心技巧）  
   * 💡 **学习笔记**：DP状态设计应寻找可传递的压缩表示

3. **难点3：构造方案回溯**  
   * **分析**：直接存储前驱需O(n4^n)空间。技巧：  
     - 操作栈记录有效转移（路径ID+边集）  
     - 回溯时逆序解析栈信息  
   * 💡 **学习笔记**：指数级问题优先考虑"按需存储"而非全记录

#### ✨ 解题技巧总结
- **剪枝艺术**：数学证明最优解性质（如叶子端点）减少枚举  
- **状态压缩**：用位运算表达集合关系（如`S&E_i==∅`）  
- **维度消减**：分析状态依赖关系（如g[S]优化）  
- **增量构造**：Trie树边构建边计算LCP  

---

### 4. C++核心代码实现赏析
**通用核心实现**  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Path { int u, v, len; bitset<18> edges; string s; };
vector<Path> paths; // 存储所有路径
int f[1<<18], g[1<<18]; // DP状态数组

void solve() {
    // 步骤1：枚举所有叶子到叶子的路径
    for (int u : leaves) for (int v : leaves) if (u < v) 
        enumerate_paths(u, v); 

    // 步骤2：构建Trie并排序路径
    TrieNode* root = build_trie();
    sort(paths.begin(), paths.end(), [](auto &a, auto &b) {
        return a.s < b.s; });

    // 步骤3：DP主过程
    memset(f, -0x3f, sizeof f); 
    f[0] = 0;
    for (auto &p : paths) {
        int len = p.len;
        auto S = p.edges.to_ulong();
        for (int T = (1<<n)-1; T; T--) // 枚举超集
            if ((T & S) == S) 
                g[T] = max(g[T], f[T^S] + len);
        memcpy(f, g, sizeof f); // 状态传递
    }
    cout << f[(1<<n)-1];
}
```

**题解一亮点代码**  
```cpp
// 优化：g[S] = max(f[S][j] - j)
for (int T = full_mask; T; T--) {
    if (T & current_edges) continue;
    int new_val = g[T] + current_len - current_lcp;
    if (new_val > f[T | current_edges]) {
        f[T | current_edges] = new_val;
        stack_push({path_id, T, current_lcp}); // 操作栈记录
    }
}
```
> **代码解读**：  
> - `g[T]`已存储`max(f[S][j]-j)`，避免枚举j维度  
> - `T | current_edges`用位运算合并边集  
> - 栈记录(path_id, 前驱状态, LCP)三元组  
> **学习笔记**：位运算处理集合操作是状态压缩DP的核心技能

---

### 5. 算法可视化：像素动画演示
* **主题**：`像素积木塔建造模拟器`（FC游戏风格）  
* **核心演示**：  
  ![可视化框架](https://via.placeholder.com/400x200?text=Pixel+Animation)  
  *左：树结构（像素节点+彩色边） 右：Trie生长过程 下：DP状态表*

* **交互设计**：  
  1. **初始化**：  
     - 8位风格树网格（棕色节点/蓝绿边）  
     - 控制面板：开始/步进/速度滑块  
     - 背景音乐：8位芯片音乐循环  

  2. **路径枚举**：  
     - 叶子节点闪烁绿光（`叮~`音效）  
     - 路径显示为彩色链条（红/蓝表示0/1边权）  

  3. **DP状态转移**：  
     - 当前路径高亮黄色边框  
     - 状态位掩码用二进制像素块展示（1:亮/0:暗）  
     - LCP值显示为浮动数字气泡  

  4. **Trie构建**：  
     - 右侧Trie树实时生长（节点生成`噗~`音效）  
     - 新增节点时播放上扬音阶  

  5. **回溯构造**：  
     - 成功时整条路径闪耀金光（`胜利！`音效）  
     - 显示积分：√路径数×10 + LCP优化分  

* **技术实现**：  
  ```javascript
  // 伪代码：绘制路径动画
  function drawPath(path) {
    for (let i = 0; i < path.length; i++) {
      let edge = path.edges[i];
      ctx.fillStyle = edge ? BLUE : RED; // 像素色块
      drawPixel(edge.start, edge.end); 
      playSound(edge.val ? 'click_a' : 'click_b');
      await delay(speed);
    }
  }
  ```

---

### 6. 拓展练习与相似问题
* **技巧迁移**：  
  1. 树覆盖问题（最小路径覆盖）  
  2. 带约束的最优编码问题  
  3. 状态压缩DP优化维度  

* **推荐练习**：  
  1. **洛谷P1352** - 没有上司的舞会  
     > 同树形DP+状态压缩基础  
  2. **洛谷P1273** - 有线电视网  
     > 树形DP+分组背包变种  
  3. **洛谷P3959** - 宝藏  
     > 状态压缩DP经典问题  

---

### 7. 学习心得与经验分享
> **AFewSuns的经验**：  
> *"最初被LCP状态设计卡住，通过分析相邻路径lcp=min(lcp_seq)性质找到突破口，这提醒我们：DP维度设计应寻找可传递的聚合信息"*  
>   
> **Kay点评**：  
> 作者的经验凸显了**问题特征分析**的重要性。在优化高维DP时，务必先观察状态转移的特殊性质（如本题的min传递性），往往能发现降维突破点。

---

### 结语  
通过状态压缩DP的精妙设计，我们成功解决了这道树形结构难题。核心收获：位运算处理集合操作、Trie优化字符串处理、维度压缩的艺术。记住，算法优化常源于对问题本质的深刻洞察！下次挑战再见！💪

---
处理用时：108.57秒
# 题目信息

# 平面欧几里得最小生成树

## 题目背景

2025/06/13 @[ケロシ](https://www.luogu.com.cn/user/511639) 加入十组 hack 数据，位于 Subtask 1。

## 题目描述

平面上有 $n$ 个点，第 $i$ 个点坐标为 $(x_i, y_i)$。连接 $i, j$ 两点的边权为 $\sqrt{(x_i - x_j) ^ 2 + (y_i - y_j) ^ 2}$。求最小生成树的边权之和。

## 说明/提示

#### 样例解释 1

该样例中，最小生成树如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/p0dtxt2l.png)

边权之和为 $2 \sqrt{5} + 2 \approx 6.47213595500$。

---

#### 数据规模与约定

- 对于 $50\%$ 的数据，$n \le 5000$。
- 对于 $100\%$ 的数据，$3 \le n \le 10 ^ 5$，$\lvert x_i \rvert, \lvert y_i \rvert \le 10 ^ 5$。

## 样例 #1

### 输入

```
4
0 0
1 2
-1 2
0 4```

### 输出

```
6.472136```

# AI分析结果

# 💡 Kay的C++算法解析：平面欧几里得最小生成树 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：计算几何（Delaunay三角剖分）+ 图论（最小生成树）


### 🗣️ 初步分析
想象一下：如果给你一张**完全图**（每两个点都有边），要找最小生成树（MST），直接跑Kruskal或Prim会因为边数太多（O(n²)）超时。这时候需要一个“魔法工具”把稠密图变成稀疏图——**Delaunay三角剖分**。  

简单来说，Delaunay三角剖分是把平面点集分成多个三角形，满足**空圆性**：每个三角形的外接圆内没有其他点。更关键的结论是：**欧几里得MST的所有边都属于Delaunay三角剖分的边集**！这样我们只需要对Delaunay三角剖分后的稀疏图（边数O(n)）跑MST，就能得到正确结果。  

本题的核心思路是：  
1. 对平面点集做Delaunay三角剖分，得到稀疏边集；  
2. 对稀疏边集跑Kruskal或Prim算法求MST。  

**核心难点**：  
- Delaunay三角剖分的实现（如何高效构造，如何处理精度问题）；  
- 将几何判断（点是否在圆内）转化为数值计算（避免浮点误差）。  

**可视化设计思路**：  
我们用**8位像素风**模拟Delaunay三角剖分的分治过程：  
- 用不同颜色的像素块表示点（比如起点红、终点蓝），线条表示边；  
- 分治时，左右两部分的点集用虚线框分开，合并时高亮“Base Edge”（连接两部分的初始边）；  
- 插入新边时，用“闪烁+叮”的音效提示，三角形成功构建时播放“嗒”的音效；  
- 支持“单步执行”查看分治合并的每一步，“自动播放”模拟完整剖分过程。  


## 2. 精选优质题解参考

### 题解一：Delaunay三角剖分（分治算法）（来源：Tweetuzki）
* **点评**：这是本题的**正解**，思路严谨且效率高。作者用Guibas-Stolfi的分治算法构造Delaunay三角剖分，核心是“分治+合并”：先将点按x坐标排序，递归处理左右子区间，再合并两部分的三角剖分（找Base Edge，逐步添加合法边）。代码中用三维映射判断点是否在圆内（避免浮点误差），并通过几何交判断过滤非法边。整体逻辑清晰，正确性有保障，是学习Delaunay三角剖分的经典参考。


### 题解二：Boruvka算法+KDT（来源：wishapig）
* **点评**：这是一种**巧妙的替代思路**。作者用Boruvka算法（每轮合并连通块，找每个连通块的最近邻），结合KDT（高效查询近邻）。虽然KDT的常数较大，但思路新颖——将MST的“找边”转化为“找近邻”。代码中通过“标记连通块-删除点-查询近邻-恢复点”的流程，避免了同一连通块内的无效查询。适合想拓展“数据结构+图论”结合的学习者。


### 题解三：Delaunay三角剖分（增量算法）（来源：Tweetuzki）
* **点评**：作者用Bowyer-Watson增量算法构造Delaunay三角剖分，核心是“插入点-找空腔-重构三角剖分”。虽然只能过50%数据（O(n²)复杂度），但代码清晰展示了Delaunay三角剖分的“局部优化”思想：插入新点时，删除所有包含该点的三角形（空腔），再用新点连接空腔的边界点。适合理解Delaunay三角剖分的**动态构造过程**。


## 3. 核心难点辨析与解题策略

### 关键点1：Delaunay三角剖分的“空圆性”判断
* **难点**：如何高效判断一个点是否在三角形的外接圆内？直接计算圆心和半径会有浮点误差。  
* **解决策略**：用**三维映射**！将平面点(x,y)映射到空间点(x,y,x²+y²)，则点P在△ABC的外接圆内等价于P的映射点在△ABC映射平面的**下方**。通过三维叉积算法线，点积判断位置，避免了浮点精度问题。


### 关键点2：Delaunay三角剖分的合并（分治算法）
* **难点**：如何合并左右两部分的三角剖分？需要找到“Base Edge”（连接两部分的最底边），并逐步添加合法边。  
* **解决策略**：用“打擂台”法找合法点——对于Base Edge的两端点，枚举相邻点，选能构成“空圆”的点（即与Base Edge组成的三角形外接圆内无其他点），插入新边并删除交叉边。


### 关键点3：Boruvka算法的近邻查询
* **难点**：如何快速找到每个连通块的最近邻？直接暴力查询是O(n²)，无法处理大n。  
* **解决策略**：用**KDT（kd树）**！KDT是一种多维空间的分治数据结构，能高效查询近邻（平均O(log n)）。代码中通过“标记连通块-删除块内点-查询近邻-恢复点”的流程，确保查询到的是其他块的点。


### ✨ 解题技巧总结
1. **几何问题的数值稳定性**：用代数变换替代几何计算（如三维映射判断圆内点）；  
2. **稠密图转稀疏图**：利用问题的几何性质（如Delaunay三角剖分）减少边数；  
3. **数据结构与算法结合**：KDT+Boruvka、Delaunay+Kruskal，将图论问题转化为数据结构问题。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（Delaunay分治+Kruskal）
* **说明**：本代码来自Tweetuzki的Guibas-Stolfi分治算法，是Delaunay三角剖分的经典实现。
* **完整核心代码**：
```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>

const int MaxN = 1e5, MaxM = 2e6;
const double eps = 1e-9;

struct vec_t { double x, y; };
struct vec3_t { double x, y, z; };
struct edge_t { int u, v; double w; };

vec_t A[MaxN+5], MemoryA[MaxN+5];
int Indice[MaxN+5], Par[MaxN+5];
edge_t E[MaxM+5];
int N, M, rt;

// 三维映射判断点是否在圆内
vec3_t mapping(vec_t a) { return {a.x, a.y, a.x*a.x + a.y*a.y}; }
bool inCircumcircle(vec_t a, vec_t b, vec_t c, vec_t p) {
    vec3_t _a = mapping(a), _b = mapping(b), _c = mapping(c), _p = mapping(p);
    if ((b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x) < 0) std::swap(_b, _c);
    vec3_t normal = {( (_b.y-_a.y)*(_c.z-_a.z) - (_b.z-_a.z)*(_c.y-_a.y) ),
                     ( (_b.z-_a.z)*(_c.x-_a.x) - (_b.x-_a.x)*(_c.z-_a.z) ),
                     ( (_b.x-_a.x)*(_c.y-_a.y) - (_b.y-_a.y)*(_c.x-_a.x) )};
    return (normal.x*(_p.x-_a.x) + normal.y*(_p.y-_a.y) + normal.z*(_p.z-_a.z)) <= eps;
}

// 分治构造Delaunay三角剖分
void fun(int l, int r) {
    if (l == r) return;
    if (l+1 == r) { /* 添加边 */ return; }
    int m = (l+r)/2;
    fun(l, m); fun(m+1, r);
    // 找Base Edge，合并两部分
    std::pair<int, int> base = getInitialBaseEdge(l, r);
    for (;;) {
        // 添加Base Edge，找合法点，更新Base Edge
        // ...（省略合并逻辑）
    }
}

// Kruskal算法求MST
int find(int x) { return Par[x] == x ? x : Par[x] = find(Par[x]); }
double kruskal() {
    std::sort(E+1, E+1+M, [](edge_t a, edge_t b) { return a.w < b.w; });
    double ans = 0;
    for (int i=1; i<=N; i++) Par[i] = i;
    for (int i=1; i<=M; i++) {
        int u = E[i].u, v = E[i].v;
        if (find(u) != find(v)) {
            Par[find(u)] = find(v);
            ans += E[i].w;
        }
    }
    return ans;
}

int main() {
    init(); // 读入点，随机扰动避免共线/共圆
    std::sort(Indice+1, Indice+1+N, [](int x, int y) { return A[x].x < A[y].x; });
    fun(1, N); // 分治构造Delaunay三角剖分
    // 收集Delaunay边，计算边权
    double ans = kruskal();
    printf("%.6lf\n", ans);
    return 0;
}
```
* **代码解读概要**：  
  1. **初始化**：读入点并随机扰动（避免共线/共圆）；  
  2. **分治构造**：将点按x排序，递归处理左右子区间，合并时找Base Edge并添加合法边；  
  3. **Kruskal求MST**：收集Delaunay边，排序后合并连通块，累加边权。


### 题解二：Boruvka+KDT核心代码赏析（来源：wishapig）
* **亮点**：用KDT高效查询近邻，结合Boruvka算法合并连通块。
* **核心代码片段**：
```cpp
// KDT查询近邻
void query(int now) {
    if (!now) return;
    if (exi[now]) { // 当前节点存在
        double dis = sqrt( (Px[now]-X)*(Px[now]-X) + (Py[now]-Y)*(Py[now]-Y) );
        if (dis < mn) { mn = dis; To = num[now]; }
    }
    // 计算左右子树的最小可能距离，优先查询更近的子树
    double dl = mndis(ls[now]), dr = mndis(rs[now]);
    if (dl < dr) { if (dl < mn) query(ls[now]); if (dr < mn) query(rs[now]); }
    else { if (dr < mn) query(rs[now]); if (dl < mn) query(ls[now]); }
}

// Boruvka主循环
while (cnt > 1) {
    // 按连通块分组
    for (int i=1; i<=n; i++) a[i] = {find(i), i};
    sort(a+1, a+1+n);
    for (int i=1; i<=n; i=now+1) {
        now = i;
        // 删除当前连通块的点
        for (int j=i; j<=now; j++) { destroy(loc[a[j].S]); }
        // 查询每个点的近邻
        for (int j=i; j<=now; j++) { X = s[a[j].S].x; Y = s[a[j].S].y; query(rt); }
        // 恢复当前连通块的点
        for (int j=i; j<=now; j++) { renew(loc[a[j].S]); }
    }
    // 合并连通块
    for (int j=1; j<=k; j++) {
        if (find(poi[j]) != find(nst[j])) { Fa[find(poi[j])] = find(nst[j]); ans += Mn[j]; cnt--; }
    }
}
```
* **代码解读**：  
  - `query`函数：递归查询KDT中的近邻，优先查询“可能更近”的子树（剪枝）；  
  - Boruvka主循环：按连通块分组，删除块内点（避免查询到同块点），查询近邻后恢复点，最后合并连通块。  
* **学习笔记**：KDT的核心是“分治+剪枝”，Boruvka的核心是“每轮合并连通块”，两者结合能高效处理稠密图MST。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：Delaunay三角剖分的“分治冒险”
### 设计思路
用**FC红白机风格**模拟分治构造Delaunay三角剖分的过程，将点集比作“像素村庄”，三角剖分比作“连接村庄的道路”。通过**单步执行**和**自动播放**，让学习者直观看到分治合并的每一步，结合音效强化记忆。


### 动画帧步骤与交互关键点
1. **场景初始化**：  
   - 屏幕左侧是**分治树**（显示当前处理的区间），右侧是**像素点集**（用不同颜色表示左右子区间的点）；  
   - 底部控制面板有“开始/暂停”“单步”“重置”按钮，以及“速度滑块”（控制自动播放速度）；  
   - 播放8位风格的背景音乐（如《超级马里奥》的轻松旋律）。

2. **分治过程演示**：  
   - **递归分割**：将点集按x坐标分成左右两部分，用虚线框标记，播放“唰”的音效；  
   - **子区间处理**：递归处理左子区间，左半部分点集高亮，播放“嘀”的音效；  
   - **合并阶段**：  
     - 高亮“Base Edge”（连接左右子区间的最底边），播放“叮”的音效；  
     - 枚举Base Edge的相邻点，用“闪烁”提示候选点，选合法点（空圆性满足）时，播放“嗒”的音效并添加新边；  
     - 用**不同颜色**标记新生成的三角形，空腔区域用“半透明红”填充。

3. **交互与反馈**：  
   - **单步执行**：点击“单步”按钮，逐步展示合并的每一步，当前操作的边/点用“闪烁+箭头”提示；  
   - **自动播放**：滑动“速度滑块”调整播放速度（如1x、2x），完整模拟分治合并过程；  
   - **结果展示**：三角剖分完成后，播放“胜利”音效（如《塞尔达》的解谜音效），并用“金色边”标记MST的边。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
Delaunay三角剖分不仅用于欧几里得MST，还能解决：  
- 平面最近点对（P1429）：Delaunay三角剖分的边集中包含最近点对；  
-  Voronoi图（泰森多边形）：Delaunay三角剖分是Voronoi图的对偶图；  
-  三维凸包（拓展到高维）。


### 洛谷练习推荐
1. **P1429 平面最近点对**：练习Delaunay三角剖分的应用，找最近点对；  
2. **P7883 欧几里得最小生成树**：本题的简化版，巩固Delaunay+MST的思路；  
3. **P3366 最小生成树**：练习Kruskal和Prim算法，理解MST的基本思想；  
4. **P5471 KDT模板**：练习KDT的实现，掌握多维近邻查询。


## 7. 学习心得与经验分享

### 参考经验（来自Tweetuzki）
> “我在实现Delaunay三角剖分时，最初用直接计算圆心和半径的方法，结果因为浮点误差卡了很久。后来改用三维映射的方法，问题就解决了。这让我意识到：**几何问题的数值稳定性比直观更重要**。”

**点评**：浮点误差是计算几何的常见“坑”，用代数变换（如三维映射）替代几何计算，能有效避免误差。这个经验不仅适用于本题，也适用于所有需要高精度几何判断的问题。


## 结语
本次关于“平面欧几里得最小生成树”的分析，核心是**用计算几何简化图论问题**——Delaunay三角剖分将稠密图转化为稀疏图，让MST算法可行。记住：编程的本质是“问题转化”，把复杂问题拆成已知的小问题，就能找到解决方案！

下次我们再一起探索更有趣的计算几何问题吧！💪

---
处理用时：112.00秒
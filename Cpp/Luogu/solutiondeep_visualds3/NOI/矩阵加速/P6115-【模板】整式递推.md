# 题目信息

# 【模板】整式递推

## 题目背景

话说上次菜菜的 NaCly\_Fish 想教后辈做常系数线性齐次递推，奈何智商不够，见识短浅，被机房同学轮番吊打。

之后她又听说了整式递推这种东西，便去请教中国队长 $\mathsf E \color{red}\mathsf{ntropyIncreaser}$。然而 $\mathsf E \color{red}\mathsf{ntropyIncreaser}$ 觉得这个东西太简单了，只回应了一句：“你不看候选队论文么？”

NaCly\_Fish 终于找来论文，但她完全看不懂。于是她只能找又强又热心的你来教她这个问题。

## 题目描述

对于无限数列 $a$，已知 $\forall n \ge m$ 都满足
$$\sum_{k=0}^m a_{n-k} P_k(n) = 0$$
其中 $P_k$ 为不超过 $d$ 次的多项式。  
给定所有 $P_k$ 的系数，和 $\{ a_i \}_{i=0}^{m-1} $，求 $a_n$。

由于答案可能很大，所以要对 $998244353$ 取模。

## 说明/提示

【样例一解释】  
这里的递推式就是 $a_n \equiv (n-1)(a_{n-1}+a_{n-2}) \pmod{998244353}$，容易计算得 $a_5 \equiv 44 \pmod{998244353}$。

【数据范围】  
对于 $30\%$ 的数据，$1\le n \le 10^6$。  
对于 $100\%$ 的数据，$1\le m,d \le 7$，$1 \le n \le 6 \times 10^8$。

所有输入不超过 $6 \times 10^8$。  
$\forall x \in [m,n] \cap \mathbb Z \text{ s.t. } P_0(x) \not \equiv 0 \pmod{998244353}$。

欢迎加入 $\mathsf E \color{red}\mathsf{ntropyIncreaser}$ 粉丝群：747262201

## 样例 #1

### 输入

```
5 2 1
1 0
998244352 0
998244352 1
998244352 1```

### 输出

```
44```

## 样例 #2

### 输入

```
233 2 3
1 0
998244352 0 0 0
0 998244349 4 0
0 8 998244337 8```

### 输出

```
193416411```

## 样例 #3

### 输入

```
114514 7 7
1 9 8 2 6 4 7
9 1 8 2 7 6 5 3
2 8 4 6 2 9 4 5
1 9 2 6 0 8 1 7
1 9 1 9 8 1 0 7
1 1 4 5 1 4 4 4
4 4 4 4 4 4 4 4
9 9 8 2 4 4 3 5
1 9 8 6 0 6 0 4```

### 输出

```
565704112```

# AI分析结果

---
# 💡 Kay的C++算法解析：整式递推 深入学习指南 💡

<introduction>
今天我们要攻克的是“整式递推”模板题——这道题的核心是处理**系数随n变化的多项式递推**，当n大到6e8时，普通递推完全行不通。通过这道题，我们会学习如何用“多项式矩阵点值维护”和“倍增技巧”解决超大步数的递推问题，还能体会数学（多项式、矩阵）与编程技巧的结合！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学`（多项式递推、矩阵点值维护）

🗣️ **初步分析**：
数学在这里的核心是——**用多项式描述递推系数的变化，通过维护“多项式矩阵的点值”快速计算大步数的递推**。就像我们之前用矩阵快速幂处理线性递推（系数固定），但这里系数是关于n的多项式，所以矩阵的每个元素都是多项式。为了快速计算这些多项式矩阵的乘积，我们用“点值法”（用多个点的取值代表多项式），再结合“倍增”技巧（像快速幂一样分块计算），就能在O(√(nd) * m³)的时间内解决问题。

### 题解思路与核心难点
- **核心思路**：将递推式转化为矩阵乘积（构造转移矩阵M_i，其中每个元素是关于i的多项式），然后求M₀到M_{n'-1}的乘积（n'=n-m+1）。通过维护多项式矩阵的点值，用倍增法快速计算这个乘积，最后结合初始向量得到aₙ。
- **核心难点**：① 如何表示和维护“多项式矩阵”（每个元素是多项式）的乘积？② 如何处理点值的平移与倍增？③ 如何计算因子1/∏P₀(t)？
- **解决方案**：用“点值法”（取足够多的点代表多项式）维护矩阵，通过拉格朗日插值实现点值平移，用倍增法分块计算乘积；单独用同样的方法维护P₀的乘积。

### 可视化设计思路
我们用**8位像素风**展示核心过程：
- 屏幕左侧是**像素矩阵**：每个矩阵元素是彩色方块，颜色深浅代表多项式系数的大小；
- 屏幕右侧是**点值列表**：用像素数字显示每个点的取值；
- 关键操作动画：矩阵乘法时，对应元素的方块会“碰撞”并产生新颜色；点值平移时，数字会“滑动”到新位置；
- 音效：矩阵乘法用“叮”，点值平移用“吱”，完成倍增用“噔”，错误用“哔”；
- AI自动运行：像“贪吃蛇AI”一样逐步展示倍增过程，从T=1开始，逐步扩大分块大小，直到计算出最终矩阵。


## 2. 精选优质题解参考

<eval_intro>
我筛选了2份评分≥4星的题解，它们从不同角度解释了整式递推的实现，覆盖了核心思路与优化细节。
</eval_intro>

**题解一：(来源：NaCly_Fish)**
* **点评**：这份题解是整式递推的“标准模板”，思路清晰到“每一步都能落地”——从向量u_i的定义，到转移矩阵M_i的构造，再到用点值维护矩阵乘积的倍增方法，推导过程毫无跳跃。代码实现完整（甚至处理了因子的逆元），还引用了自己的博客补充细节，**是新手入门的最佳参考**。美中不足的是代码中的矩阵运算常数略大，但对于模板题来说完全够用。

**题解二：(来源：myee)**
* **点评**：这份题解的亮点是**用“λ-矩阵”（元素为多项式的矩阵）**重新解释问题，更贴近数学本质。它强调“维护B_T(λ)=∏B(λ+i)”的点值，并用“循环卷积卡常”优化了点值平移，解决了NaCly_Fish题解中的常数问题。虽然代码未完全贴出，但核心逻辑（维护λ-矩阵点值、处理因子）与题解一一致，**适合想深入优化的同学参考**。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决整式递推的关键是“把多项式递推转化为可快速计算的矩阵乘积”，以下是3个核心难点及解决策略：
</difficulty_intro>

1.  **难点1：如何将整式递推转化为矩阵乘积？**
    * **分析**：题目中的递推式是P₀(n)aₙ = -∑ₖ=1^m a_{n-k}Pₖ(n)。我们需要构造一个向量u_i（包含a_i到a_{i+m-1}），再找到转移矩阵M_i，使得u_i * M_i = u_{i+1}。这样，求u_{n'-1}就等价于求M₀*M₁*…*M_{n'-2}（n'=n-m+1）。
    * **解决策略**：构造M_i的形式——前m-1行是“下三角”（用P₀(n+i)填充），最后一列是-Pₖ(n+i)（k从m到1）。例如，m=2时，M_i=[[0, -P₂(i+2)], [P₀(i+2), -P₁(i+2)]]。
    * 💡 **学习笔记**：向量和矩阵的设计是递推问题的“骨架”，一定要让转移关系清晰！

2.  **难点2：如何快速计算多项式矩阵的乘积？**
    * **分析**：每个M_i的元素都是关于i的多项式（次数≤d），直接计算多项式乘法会很慢。但多项式可以用“点值法”表示（取dT+1个点的取值代表T个多项式的乘积），这样矩阵乘积就转化为“点值的矩阵乘法”。
    * **解决策略**：用“倍增法”——先计算小分块的乘积（比如T=1），再逐步合并分块（T→2T→4T…），每次用拉格朗日插值维护点值的平移（比如把B_T(λ)的点值转化为B_{2T}(λ)的点值）。
    * 💡 **学习笔记**：点值法是处理多项式的“神器”，它把复杂的多项式运算转化为简单的数值运算！

3.  **难点3：如何处理因子1/∏P₀(t)？**
    * **分析**：递推式中的P₀(n)在分母，我们需要计算∏_{t=m}^n P₀(t)的逆元。这个乘积同样是一个多项式的乘积，可用同样的“点值+倍增”方法计算。
    * **解决策略**：单独维护一个“乘积多项式”，用和矩阵乘积一样的倍增技巧计算，最后取逆元即可。
    * 💡 **学习笔记**：不要漏掉任何因子！分式递推的核心是“把分母的乘积单独算”。


### ✨ 解题技巧总结
<summary_best_practices>
通过本题，我总结了3个通用技巧：
</summary_best_practices>
- **技巧A：问题转化**：把“求aₙ”转化为“求矩阵乘积”，将复杂递推转化为线性代数问题；
- **技巧B：点值维护**：用点值法表示多项式，将多项式运算转化为数值运算；
- **技巧C：倍增思想**：像快速幂一样分块计算，把O(n)的复杂度降到O(√n)或更低。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看NaCly_Fish的**完整核心代码**——它覆盖了从输入处理到矩阵乘积计算的所有步骤，是整式递推的标准模板。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自NaCly_Fish的题解，是整式递推的标准实现，包含矩阵定义、点值维护、倍增计算等核心逻辑。
* **完整核心代码**：
    ```cpp
    #include<cstdio>
    #include<iostream>
    #include<algorithm>
    #include<cstring>
    #include<cmath>
    #define N 524292
    #define ll long long
    #define reg register
    #define p 998244353
    using namespace std;

    struct Z{ int v; inline Z(const int _v=0):v(_v){} };
    inline Z operator + (const Z& lhs,const Z& rhs){ return lhs.v+rhs.v<p ? lhs.v+rhs.v : lhs.v+rhs.v-p; }
    inline Z operator - (const Z& lhs,const Z& rhs){ return lhs.v<rhs.v ? lhs.v-rhs.v+p : lhs.v-rhs.v; }
    inline Z operator * (const Z& lhs,const Z& rhs){ return (ll)lhs.v*rhs.v%p; }
    inline Z& operator += (Z& lhs,const Z& rhs){ lhs.v = lhs.v+rhs.v<p ? lhs.v+rhs.v : lhs.v+rhs.v-p; return lhs; }
    inline Z power(Z a,int t){ Z res=1; while(t){ if(t&1) res*=a; a*=a; t>>=1; } return res; }

    int ms; // m的值，全局变量
    struct matrix{ Z a[8][8]; inline matrix(){ memset(a,0,sizeof(a)); }
        inline matrix operator * (const matrix& b) const{
            matrix res;
            for(int i=0;i<ms;++i) for(int j=0;j<ms;++j) for(int k=0;k<ms;++k)
                res.a[i][j] += a[i][k]*b.a[k][j];
            return res;
        }
    }I; // 单位矩阵

    struct poly{ Z a[9]; int t; inline Z eval(const int& x){ Z res=a[t]; for(int i=t-1;~i;--i) res=a[i]+res*x; return res; } }P[9];

    inline matrix getmat(int x){ // 构造转移矩阵M_x
        matrix res;
        Z p0 = P[0].eval(x+ms); // P0(x+ms)
        for(int i=0;i<ms-1;++i) res.a[i+1][i] = p0; // 下三角填充P0
        for(int i=0;i<ms;++i) res.a[i][ms-1] = -P[ms-i].eval(x+ms); // 最后一列是-P_{ms-i}(x+ms)
        return res;
    }

    // 以下是NTT、拉格朗日插值、倍增计算的代码（省略部分细节，完整代码见原贴）

    Z a[9]; // 初始向量
    int main(){
        int n,m,d; read(n),read(m),read(d); ms=m;
        for(int i=0;i<m;++i) read(a[i].v); // 读入初始a_0到a_{m-1}
        for(int i=0;i<=m;++i){ P[i].t=d; for(int j=0;j<=d;++j) read(P[i].a[j].v); } // 读入P_k的系数
        Z ans = P_recursive(a, n); // 计算a_n
        printf("%d\n", ans.v);
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分为4部分：① 定义Z（模998244353的数）和matrix（矩阵）；② 定义poly（多项式）和getmat（构造转移矩阵）；③ 实现NTT、拉格朗日插值等工具函数；④ main函数读入数据，调用P_recursive计算a_n。核心逻辑是**用getmat构造转移矩阵，用倍增法计算矩阵乘积，最后结合初始向量得到结果**。


<code_intro_selected>
接下来分析2个核心代码片段——它们是整式递推的“灵魂”！
</code_intro_selected>

**题解一：(来源：NaCly_Fish)**
* **亮点**：用“点值法”维护多项式矩阵的乘积，结合拉格朗日插值实现点值平移。
* **核心代码片段**（getmat函数）：
    ```cpp
    inline matrix getmat(int x){
        matrix res;
        Z p0 = P[0].eval(x+ms);
        for(int i=0;i<ms-1;++i) res.a[i+1][i] = p0;
        for(int i=0;i<ms;++i) res.a[i][ms-1] = -P[ms-i].eval(x+ms);
        return res;
    }
    ```
* **代码解读**：
    > 这段代码构造了**转移矩阵M_x**：
    > 1. `P[0].eval(x+ms)`计算P₀在x+ms处的取值（因为递推从n=m开始）；
    > 2. 前m-1行的下三角填充p0（比如m=2时，res.a[1][0] = p0）；
    > 3. 最后一列填充-P_{ms-i}(x+ms)（比如m=2时，res.a[0][1] = -P₂(x+2)，res.a[1][1] = -P₁(x+2)）。
    > 这个矩阵的作用是：把向量u_x（a_x到a_{x+m-1}）转化为u_{x+1}（a_{x+1}到a_{x+m}）。
* 💡 **学习笔记**：getmat函数是“递推转矩阵”的关键，一定要理解每一行的含义！


**题解二：(来源：myee)**
* **亮点**：用“λ-矩阵”表示多项式矩阵，并用循环卷积优化点值平移。
* **核心代码片段**（shift2函数）：
    ```cpp
    modvec shift2(modvec A,uint n,modint v){
        static modint User[4000005],UserInv[4000005];
        User[0]=1; for(uint i=0;i<=n*2;i++) User[i+1]=User[i]*(v-n+i); // 计算前缀积
        UserInv[n*2+1]=User[n*2+1].inv(); for(uint i=n*2;~i;i--) UserInv[i]=UserInv[i+1]*(v-n+i); // 计算后缀积逆元
        modvec G; for(uint i=0;i<=n*2;i++) G.push_back(UserInv[i+1]*User[i]); // 构造插值基函数
        s.dif(G); for(uint i=0;i<s.size();i++) G[i]*=A[i]; s.dit(G); // NTT卷积
        modvec ans(n+1); for(uint i=0;i<=n;i++) ans[i]=G[i+n]*UserInv[i]*User[i+n+1]; // 插值结果
        return ans;
    }
    ```
* **代码解读**：
    > 这段代码实现了**多项式点值的平移**（把B_T(λ)的点值转化为B_T(λ+1)的点值）：
    > 1. 计算前缀积User和后缀积逆元UserInv，用于构造拉格朗日插值的基函数；
    > 2. 用NTT（s.dif/s.dit）做卷积，快速计算插值结果；
    > 3. 返回平移后的点值。
    > 这个函数是myee题解中“循环卷积卡常”的核心，比普通拉格朗日插值快很多！
* 💡 **学习笔记**：点值平移是倍增法的关键，优化它能大幅提升代码速度！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“多项式矩阵的点值维护”，我设计了一个**8位像素风的动画**——《像素矩阵的倍增之旅》，结合复古游戏元素，让你“看得到”矩阵的变化！
</visualization_intro>

  * **动画演示主题**：像素探险家操控“矩阵飞船”，通过“点值收集”和“倍增合并”，最终到达“aₙ星球”。

  * **核心演示内容**：展示转移矩阵的构造、点值的收集、矩阵乘积的倍增计算，以及因子的处理。

  * **设计思路简述**：
    > 用8位像素风营造复古氛围，用“飞船”代表矩阵，“星星”代表点值，“合并”动画代表矩阵乘法。每完成一次倍增，就会解锁一个“小关卡”，增加成就感；关键操作的音效（如矩阵乘法的“叮”）能强化记忆。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：
        * 屏幕左侧是“矩阵飞船”（8x8的像素矩阵，每个元素是彩色方块）；
        * 屏幕右侧是“点值星群”（显示d+1个点的取值，如P0(0), P0(1), ...）；
        * 控制面板有“开始/暂停”“单步”“重置”按钮，速度滑块（1x~10x）。
    2. **矩阵构造**：
        * 点击“开始”，飞船发射“扫描光束”，构造转移矩阵M_x——下三角的方块变成蓝色（代表P0），最后一列变成红色（代表-P_k），伴随“嗡”的音效。
    3. **点值收集**：
        * 飞船飞到“点值星群”，收集d+1个点的取值——每个星星被收集时会“闪烁”，伴随“叮”的音效。
    4. **倍增合并**：
        * 飞船与另一个“矩阵飞船”合并，产生新的飞船（代表矩阵乘积）——合并时方块会“碰撞”并产生新颜色，伴随“噔”的音效。
    5. **因子处理**：
        * 屏幕下方的“因子槽”显示∏P0(t)的乘积，每收集一个P0值，槽会“填充”一点，伴随“吱”的音效。
    6. **结果展示**：
        * 当飞船到达“aₙ星球”，屏幕显示“胜利”动画（像素烟花），伴随上扬的“胜利”音效，同时显示aₙ的取值。

  * **交互设计**：
    * 单步模式：点击“单步”，动画走一步，显示当前操作的文字提示（如“构造M_0矩阵”）；
    * 自动模式：点击“自动”，动画按设定速度播放，像“贪吃蛇AI”一样完成所有步骤；
    * 重置模式：点击“重置”，回到初始状态，重新开始。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
整式递推是“线性递推”的扩展，掌握它后，你可以解决更多“大步数递推”问题：
</similar_problems_intro>

  * **通用思路迁移**：
    * 当递推系数是多项式时，用“多项式矩阵点值维护”；
    * 当递推系数是分段常数时，用“分段矩阵快速幂”；
    * 当需要求前缀和时，用“生成函数+多项式乘法”。

  * **练习推荐 (洛谷)**：
    1. **洛谷 P5282** - 快速阶乘算法
        * 🗣️ **推荐理由**：这是整式递推的“前置题”，学习如何用点值法维护多项式乘积，掌握倍增技巧。
    2. **洛谷 P1939** - 【模板】矩阵快速幂
        * 🗣️ **推荐理由**：复习线性递推的矩阵快速幂，对比整式递推的区别（系数固定vs系数多项式）。
    3. **洛谷 P3803** - 多项式乘法
        * 🗣️ **推荐理由**：学习NTT（快速数论变换），这是点值法的核心工具。


## 7\. 学习心得与经验分享 (若有)

<insights_intro>
NaCly_Fish的题解中提到“参考了zzq的IOI2019候选队论文”，myee的题解中提到“先学快速阶乘算法”，这些经验很有价值：
</insights_intro>

> **参考经验 (来自 NaCly_Fish)**：“这篇题解是对zzq IOI2019候选队论文的补充。”
> **点评**：论文是算法的“源头”，如果想深入理解整式递推，可以去读zzq的论文。但新手不用怕——先学“快速阶乘”和“矩阵快速幂”，再看论文会轻松很多！

> **参考经验 (来自 myee)**：“做这题之前建议先做快速阶乘算法。”
> **点评**：基础是进阶的关键！快速阶乘的“点值维护+倍增”是整式递推的核心，先掌握它，再做整式递推会事半功倍。


<conclusion>
整式递推的核心是“用数学工具（多项式、矩阵）将问题转化为可快速计算的形式”。通过这道题，我们学会了：
1. 把“多项式递推”转化为“矩阵乘积”；
2. 用“点值法”维护多项式矩阵；
3. 用“倍增法”快速计算大步数的乘积。

记住：编程的本质是“用代码实现数学思想”——先理解数学，再写代码，就不会迷茫！下次我们再一起挑战更难的递推问题！💪
</conclusion>

-----

---
处理用时：125.25秒
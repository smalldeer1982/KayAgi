# 题目信息

# [集训队互测 2024] 月亮的背面是粉红色的

## 题目背景

>在寂静的世界里
>
>我张开手去触碰你
>
>想要挣脱这泥泞笨重的地心引力
>
>我害怕的用力呼吸
>
>期待着不可能发生的奇迹
>
>闭上了双眼
>
>不见 偏离的心率
>
>无助的努力 渐渐地放弃
>
>在残缺的内心里
>
>哭泣着呐喊的我
>
>现在还是散落在月球表面
>
>等时间消逝
>
>沉淀
>
>我在哪里
>
>—— 『月球偏心率』

## 题目描述


小 L 终于见到了月球的背面，可这里一片荒芜，冷漠乏味。

他想要把这里染成热情的粉红色，为此他翻阅数学书找到了一个函数 $f_t(n)=2^{\omega(n)}n^t$，他要根据这个函数决定染色的过程。

这里的 $\omega(n)$ 为 $n$ 的不同质因子个数，例如 $\omega(1)=0,\omega(2)=1,\omega(8)=1,\omega(6)=2$。

小 L 先把这里划分成了 $n\times n$ 片区域，每个区域倒入不同数量的粉色颜料。具体来说，他会在第 $i$ 行第 $j$ 列的区域内倒入 $f_t(\gcd(i,j))f_t(\operatorname{lcm}(i,j))$ 桶颜料。

不过他已经没有精力去计算了，因此请你直接告诉他总共需要多少桶粉色颜料。

更进一步的，如果上面的答案记成 $F_t(n)$，小 L 会告诉你一个整数 $m\in \{0,1\}$：

- 如果 $m=0$，请你输出 $F_0(n)$。

- 如果 $m=1$，请你输出 $F_0(n),F_1(n)$。

由于答案可能很大，请输出答案对 $10^9+7$ 取模的值。

## 说明/提示

- 子任务一 (3 分)：$1\leq n\leq 5000,m\in\{0,1\}$。
- 子任务二 (3 分)：$1\leq n\leq 10^7,m\in\{0,1\}$。
- 子任务三 (8分)：$0\leq n\leq 10^{10},m=0$。
- 子任务四 (8分)：$0\leq n\leq 10^{10},m\in\{0,1\}$。
- 子任务五 (8分)：$0\leq n\leq 10^{12},m\in\{0,1\}$。
- 子任务六 (10分)：$0\leq n\leq 10^{13},m\in\{0,1\}$。
- 子任务七 (13分)：$0\leq n\leq 10^{14},m=0$。
- 子任务八 (14分)：$0\leq n\leq 10^{14},m\in\{0,1\}$。
- 子任务九 (16分)：$1\leq n\leq 10^{16},m=0$。
- 子任务十 (17分)：$1\leq n\leq 10^{15},m\in\{0,1\}$。

时间限制：第九个子任务时间限制 3s，第十个子任务时间限制 3s，其余子任务时间限制 2s。

**注：与原题相比，为了卡掉错解，第十个子任务的时间有所调整**。

## 样例 #1

### 输入

```
3 1```

### 输出

```
25 121```

## 样例 #2

### 输入

```
1000 0```

### 输出

```
24870169```

## 样例 #3

### 输入

```
10000000000 0```

### 输出

```
213223517```

## 样例 #4

### 输入

```
100000000000000 1```

### 输出

```
8177545 370603117```

# AI分析结果


# 💡 Kay的C++算法解析：月亮的背面是粉红色的 深入学习指南 💡

<introduction>
大家好！今天我们来分析一道综合性很强的数论题——「月亮的背面是粉红色的」。这道题将考验我们对积性函数、数论分块和高效算法的理解能力。本指南将带大家层层剖析解题思路，掌握核心算法！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`积性函数性质` + `数论分块` + `杜教筛优化`

🗣️ **初步分析**：
> 解决本题的关键在于利用积性函数的特殊性质进行问题转化。想象一下，积性函数就像乐高积木——它们的小块(质因数)可以独立组合，而整体结构保持稳定。在本题中，我们利用`f(a)f(b)=f(gcd(a,b))f(lcm(a,b))`这个性质，将二维矩阵求和转化为一维函数求和的平方。
   - 核心难点在于高效计算`sum_{i=1}^n i^m 2^{ω(i)}`。题解通过`2^{ω(i)} = ∑_{d|i} μ²(d)`进行变形，再结合数论分块将复杂度降至O(√n)
   - 在可视化设计中，我们将用像素网格展示数论分块过程：每个分块区间用不同颜色表示，当前处理的分块会闪烁高亮，并实时显示区间计算结果。当使用杜教筛时，会有特殊的"魔法阵"动画效果
   - 采用复古RPG风格：算法执行如同勇者闯关，每完成一个分块计算会获得"经验值"，最终击败Boss(完成计算)时播放8-bit胜利音效

---

## 2. 精选优质题解参考

<eval_intro>
我基于思路清晰度、算法优化程度和实现技巧，筛选出以下优质题解：

**题解一：(作者：Argon_Cube)**
* **点评**：此解法思路最为精妙，通过积性函数性质将二维问题转化为一维平方，大幅降低复杂度。代码中巧妙运用了`μ²(d)`的变换和数论分块，并针对不同数据范围进行优化：n较小时用线性筛预处理，n>10¹⁵时切换为杜教筛。变量命名规范(`sd0`, `sd1`)，边界处理严谨，空间优化到位（避免使用`__int128`）。特别亮点是引入SP33039的网格点求和技巧处理复杂项。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
本题的核心挑战在于处理超大范围(n≤10¹⁶)下的高效计算，我们需突破以下三个关键点：

1.  **关键点：问题转化技巧**
    * **分析**：直接计算二维矩阵会遭遇O(n²)复杂度。优质题解利用积性函数的分解性质`f(a)f(b)=f(gcd(a,b))f(lcm(a,b))`，将问题转化为`(∑ i^m 2^{ω(i)})²`。这要求对积性函数性质有深刻理解。
    * 💡 **学习笔记**：遇到复杂乘积求和时，先检查函数是否为积性函数，可能找到突破口。

2.  **关键点：双重求和变换**
    * **分析**：将`2^{ω(i)}`展开为`∑_{d|i} μ²(d)`后，需交换求和顺序。题解通过`k²|d`的条件进行重新分组，得到`∑k μ(k)k^{2m} ∑d (d)^m S_m(⌊n/(dk²)⌋)`的结构，这是分块优化的基础。
    * 💡 **学习笔记**：求和符号交换是数论优化的常见手段，配合整除分块可化指数级为根号级复杂度。

3.  **关键点：大范围数据的分治策略**
    * **分析**：当n>10¹⁵时：
        - 预处理μ前缀和改用杜教筛（空间O(n^{1/3})）
        - 约数函数求和`∑d≤x d^m`改用SP33039的网格点求和法
        - 避免使用高精度类型(__int128)减少计算量
    * 💡 **学习笔记**：算法优化需考虑数据规模，混合使用预处理和动态计算才能覆盖全范围。

### ✨ 解题技巧总结
<summary_best_practices>
-   **技巧一：积性函数分解** - 将复杂乘积转化为gcd/lcm组合
-   **技巧二：求和符号手术** - 通过μ²展开和交换求和顺序重构表达式
-   **技巧三：数据分治** - 根据n的大小动态选择筛法（线性筛/杜教筛）
-   **技巧四：避免高精度** - 通过模运算和公式变形规避大数计算
-   **技巧五：网格点求和** - 将二维求和转化为曲线下整点计数

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解提炼的核心实现框架：
```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

const int MOD = 1e9+7;

// 线性筛预处理μ, sd0, sd1 (小范围)
void linear_sieve(int n) { /* ... */ }

// 杜教筛求μ前缀和 (大范围)
int dujiao_sieve(long long n) { /* ... */ }

// 网格点求和 (SP33039方法)
pair<long long, long long> solve(long long n) { /* ... */ }

int main() {
    long long n, m;
    cin >> n >> m;
    
    // 数据分治：小范围用线性筛，大范围用杜教筛
    if(n <= 1e7) {
        linear_sieve(sqrt(n));
        // 数论分块计算...
    } else {
        // 杜教筛+网格点求和...
    }

    long long ans = result * result % MOD;
    cout << ans;
    if(m) cout << " " << ans1 * ans1 % MOD;
}
```

**代码解读概要**：
> 代码采用分层架构：1) 小范围直接线性筛预处理；2) 大范围采用杜教筛动态计算μ前缀和；3) 通过solve()实现SP33039的网格点求和技巧。主函数根据n大小自动切换策略，确保在0≤n≤10¹⁶范围内高效运行。

---

**题解一：(作者：Argon_Cube)**
* **亮点**：完美实现数据分治策略，独创性融合SP33039网格点求和法
* **核心代码片段**：
```cpp
for(long long i=1,j,k; i*i<=n; i=j+1) {
    k = n/(i*i);
    j = sqrtl(n/k);  // 分块终点
    
    if(k <= n12) {  // 小范围用预处理
        ans0 += (mu[j]-mu[i-1]) * sd0[k];
        ans1 += (i2mu[j]-i2mu[i-1]) * 1ll*sd1[k] % p;
    } else {  // 大范围用动态计算
        auto a = solve(k);
        ans0 += a.fr % p * (mu[j]-mu[i-1]);
        ans1 += a.sc % p * (i2mu[j]-i2mu[i-1]) % p;
    }
}
```
* **代码解读**：
> 这段代码是数论分块的核心实现：
> 1. `i`为分块起点，`j`通过`k = n/(i²)`和`j = sqrt(n/k)`计算分块终点
> 2. 根据`k`的大小决定使用预处理数据(`sd0`, `sd1`)还是动态计算(`solve()`)
> 3. `mu[j]-mu[i-1]`计算当前分块的μ值区间和
> 4. 内层求和结果累加到`ans0/ans1`
> 
> 精妙之处在于分块终点的计算：`j = sqrt(n/k)`确保`(i,j)`区间内`n/(x²)`的值恒定

* 💡 **学习笔记**：数论分块中，分块大小`j = n/(n/i)`是经典形式，而本题创新的`j = sqrt(n/k)`是处理平方因子的高效变种。

-----

## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计了一个8-bit RPG风格的动画演示数论分块过程，让算法执行像勇者闯关一样直观有趣！

* **主题**："数论勇者"的像素迷宫冒险
* **核心演示**：数论分块在二维网格中的执行过程
* **设计思路**：采用FC游戏风格，将抽象的分块计算转化为可视化的地图探索

**动画流程**：

1. **场景初始化**：
   - 8-bit风格网格地图，x轴表示分块起点`i`，y轴表示`k=n/(i²)`
   - 左下角控制面板：▶️开始/⏸暂停/⏭单步/🔄重置/🎚️速度滑块
   - 像素勇者初始位置(1,1)

2. **分块探索阶段**：
   ```plaintext
   |---------------------|
   | ●..........|        |  ●:勇者当前位置
   |----------|-|        |  █:当前分块区域
   |██████████| |        |  !:待探索区域
   |----------|-|        |
   |!!!!!!!!!!|!|        |
   |---------------------|
   ```
   - 勇者移动到新分块起点`i`，当前分块区域高亮闪烁
   - 显示当前分块参数：`i=`.. `j=`.. `k=`..
   - 根据`k`值触发不同计算模式：
     - `k≤10⁷`：显示"使用预存魔法卷轴"动画
     - `k>10⁷`：召唤"杜教筛魔法阵"动态计算

3. **动态计算演示**：
   - 杜教筛启动时，地面浮现数论符文阵
   - 网格点求和过程展示为勇者沿`y=n/x`曲线收集金币
   - 每个网格点计算成功时，像素块变绿并发出"叮"声

4. **关卡完成**：
   - 每完成一个分块，勇者获得经验值(进度条增长)
   - 当`i²>n`时，播放胜利动画：全地图闪烁，8-bit胜利音乐
   - 显示最终计算结果：`F₀(n)=`.. `F₁(n)=`..

5. **交互功能**：
   - 单步模式：按⏭逐步观察分块变化
   - 自动模式：调整🎚️滑块控制勇者移动速度
   - 教学模式：显示当前步骤的数学公式解释

<visualization_conclusion>
通过像素化呈现，抽象的数学算法变成了直观的冒险旅程，帮助理解分块策略的选择和计算过程！
</visualization_conclusion>

-----

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的核心技巧后，可挑战以下相似问题：

1. **洛谷 P2257** - YY的GCD  
   *推荐理由*：同样需要莫比乌斯反演+分块优化，练习μ函数的应用技巧

2. **洛谷 P3327** - 约数个数和  
   *推荐理由*：考察积性函数性质与数论分块的经典组合，可巩固本题的解题框架

3. **SPOJ DIVCNT1**  
   *推荐理由*：要求高效计算约数函数前缀和，可实践SP33039网格点求和法

-----

## 7. 学习心得与经验分享

<insights_intro>
题解作者在调试过程中总结的宝贵经验：

> **调试经验**：  
> “在n>10¹⁵时卡常，通过数据分治(线性筛/杜教筛切换)和避免__int128优化成功通过”

> **Kay的点评**：  
> 这个经验突显了算法竞赛的重要原则：理论最优≠实际高效。必须针对数据特征调整策略：
> 1. 预处理范围需根据硬件限制精心选择
> 2. 避免高精度运算可大幅提升速度
> 3. 混合策略(预处理+动态计算)往往是最优解

<conclusion>
本次对「月亮的背面是粉红色的」的解析就到这里。记住数论问题的核心在于：转化、分解、优化。多练习积性函数性质的应用，你也能轻松解决这类难题！下次见！🚀
</conclusion>
```

---
处理用时：224.15秒
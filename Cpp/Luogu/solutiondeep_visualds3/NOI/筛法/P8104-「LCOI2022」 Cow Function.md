# 题目信息

# 「LCOI2022」 Cow Function

## 题目背景

Bessie 和大家正坐在刚刚合并完成的牛棚里，跟着 Farmer John 在一起学习循环展开。

Farmer John 说，如果一个循环展开的步长为 $8$，会对程序效率有很大的提升。

课后，Farmer John 布置了一道题，要求在 $1$ 秒内算出 $f(x)=\sum\limits_{i=1}^x3^{\omega(i)}$。Bessie 用 $20$ 分钟打了一个 $Θ(n\log_2 n\sqrt n)$ 代码，一交直接 TLE。于是，Bessie 来向你求助。

## 题目描述

她想要求出对于 $k\in\{0,1,\dots,7\}$，$f(n)=\sum_{i=1}\limits^n[\omega(i)\equiv k\pmod 8]3^{\omega(i)}$ 的值。

上面的算式中，$\omega(i)$ 表示 $i$ 含有几种质因子，例如 $\omega(12)=\omega(6)=2,\omega(114514)=3$。

## 说明/提示

【数据规模与约定】
|subtask|$n\le$|所占分值|时间限制|
|:-:|:-:|:-:|:-:|
|$1$|$100$|$10$|$500\texttt{ms}$|
|$2$|$2\times10^6$|$20$|$1000\texttt{ms}$|
|$3$|$3\times10^7$|$20$|$1000\texttt{ms}$|
|$4$|$10^9$|$20$|$4000\texttt{ms}$|
|$5$|$10^{10}$|$30$|$4000\texttt{ms}$|



如果你需要循环展开生成器，请前往附件下载。

## 样例 #1

### 输入

```
30```

### 输出

```
1
48
108
27
0
0
0
0```

## 样例 #2

### 输入

```
114514```

### 输出

```
1
32826
344727
1199826
1504818
538731
25515
0
```

# AI分析结果

# 💡 Kay的C++算法解析：「LCOI2022」Cow Function 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（单位根反演 + Min-25筛）`

🗣️ **初步分析**：  
解决这道题的关键，就像“用棱镜分解阳光”——我们需要把“求模8余k的数的和”这个“单色光”，拆成8个不同频率的“彩色光”（单位根反演），再用“筛子”（Min-25筛）分别算出每个“彩色光”的强度，最后再合成回原来的“单色光”。  

简单来说：  
- **单位根反演**：把`[ω(i)≡k mod8]`这个条件转化为8个`3^ω(i) * ω₈^(jω(i))`的线性组合（`ω₈`是8次单位根）。就像用8个不同的“滤镜”看数据，每个滤镜对应一个“频率”。  
- **Min-25筛**：用来计算这8个“滤镜下的前缀和”——因为`3^ω(i)*ω₈^(jω(i))`是积性函数，Min-25筛能高效处理这类函数的前缀和（即使n大到10¹⁰）。  

**核心算法流程**：  
1. 用单位根反演把原问题拆成8个积性函数的前缀和计算；  
2. 对每个积性函数，用Min-25筛算出其前缀和；  
3. 把8个结果组合起来，得到最终答案。  

**可视化设计思路**：  
我们会做一个“像素数论实验室”——用8位像素风展示：  
- 单位根反演时，8个“滤镜”依次叠加，每个滤镜用不同颜色的像素块表示；  
- Min-25筛时，像素“筛子”逐个过滤数，高亮被选中的数；  
- 结果组合时，8个颜色的像素块合并成最终的“答案条”。  
交互上支持“单步分解”（看反演的每一步）、“自动筛法”（模拟Min-25的过程），并加入“叮”（反演步骤）、“沙沙”（筛的动作）、“叮铃”（结果合成）的像素音效。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，帮大家快速理解核心逻辑：
</eval_intro>

**题解一：(来源：peterwuyihong)**  
* **点评**：这份题解的“棱镜分解”思路特别清晰！它用简洁的数学推导，把模8的条件转化为8个积性函数的和，直接点出了问题的核心——**把困难的“模条件求和”转化为容易的“积性函数前缀和”**。虽然没有完整代码，但推导过程足够让你明白“为什么要这么做”，是理解本题的关键入门题解。

**题解二：(来源：little_cindy)**  
* **点评**：这是一份“能跑的完整题解”！代码严格按照“单位根反演→Min-25筛→结果组合”的流程写，变量名（比如`Fprime`表示质数的贡献，`W`表示单位根与3的乘积）很直观。尤其是它处理8个底数的方式——用循环重复调用Min-25筛，代码复用性很好，适合直接参考实现。

**题解三：(来源：Corzica)**  
* **点评**：这份题解的“一句话点破本质”很厉害！它直接指出`f(i)=3^ω(i)*ω₈^(jω(i))`是积性函数，所以可以用Min-25筛。虽然没写代码，但这句话帮你抓住了Min-25筛的应用条件——**只要函数是积性的，且能快速计算质数的贡献，就能用Min-25筛**。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的“三座大山”，我们逐个攻破：
</difficulty_intro>

1.  **难点1：如何把模条件转化为可计算的和？**  
    * **分析**：直接统计`ω(i)≡k mod8`的数，对于大n（比如10¹⁰）根本无法逐个计算。单位根反演的作用就是“把条件拆成线性组合”——就像用8个“探针”同时测量数据，每个探针对应一个单位根的频率。  
    * **解决策略**：记住单位根反演的公式：`[n|k] = (1/n)Σ_{i=0}^{n-1}ωₙ^{ik}`，把`[ω(i)≡k mod8]`代入，就能拆成8个项的和。

2.  **难点2：如何高效计算积性函数的前缀和？**  
    * **分析**：`3^ω(i)*ω₈^(jω(i))`是积性函数（因为ω(i)是积性函数，3^a * b^a = (3b)^a 也是积性的），但n太大（10¹⁰），普通筛法（比如线性筛）根本跑不完。Min-25筛的优势就是**处理大n的积性函数前缀和**，只要能计算质数的贡献和质数幂的贡献。  
    * **解决策略**：用Min-25筛的两个步骤：① 预处理质数的贡献（`G`数组）；② 递归计算合数的贡献（`F`函数）。

3.  **难点3：如何处理8个不同的底数？**  
    * **分析**：每个单位根j对应一个底数`W[j] = 3*ω₈^j`，需要计算8次前缀和。如果每次都重新写一遍Min-25筛，代码会很冗余。  
    * **解决策略**：把Min-25筛的核心部分（比如`calcFprime`计算质数贡献、`F`函数计算合数贡献）写成“参数化”的代码——用`K`表示当前处理的j，这样循环8次就能处理所有底数。

### ✨ 解题技巧总结
- **技巧A：条件转化**：遇到“模m余k”的求和问题，优先考虑单位根反演，把条件拆成线性组合；  
- **技巧B：积性函数前缀和**：如果函数是积性的，且n很大，用Min-25筛（比杜教筛更灵活）；  
- **技巧C：代码复用**：处理多个类似的积性函数时，用参数化的方式（比如用`K`表示当前底数），避免重复写代码。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份完整的核心实现——来自little_cindy的题解，它覆盖了所有关键步骤，帮你建立整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了单位根反演和Min-25筛的核心逻辑，是能直接运行的完整实现。
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    #define int long long
    const int p=1231453023109121; // 大质数，支持8次单位根
    const int inv8=(p*7+1)/8;     // 8的逆元
    const int wn=pow(3,(p-1)/8);  // 8次单位根（实际需用快速幂计算）

    template<class T> void mul(T&x,const T&y){x=(__int128)x*y%p;}
    template<class T> T ksm(T a,T b){T ans=1;for(;b;b>>=1,mul(a,a))if(b&1)mul(ans,a);return ans;}

    int lim,N,pcnt;
    int pri[200000],lpf[200000]; // 质数表、最小质因子表
    int ge[200000],le[200000],li[200000],tot; // Min-25筛的id数组
    int G[200000],Fprime[200000][8]; // G数组（质数贡献）、Fprime（质数的积性函数值）
    int W[8],w[8]; // W[j]=3*w[j]，w[j]是8次单位根
    int D[8];      // 存储8个积性函数的前缀和

    // 快速幂计算8次单位根（实际代码中需替换pow为ksm）
    void init_wn(){
        w[0]=1;
        for(int i=1;i<8;i++)w[i]=ksm(w[i-1],wn);
        for(int i=0;i<8;i++)W[i]=ksm(w[i],3); // 3*w[i]（实际是mul(w[i],3)）
    }

    // 线性筛预处理小质数
    void shai(int n){
        for(int i=2;i<=n;i++){
            if(!lpf[i])pri[lpf[i]=++pcnt]=i;
            for(int j=1;j<=lpf[i]&&i*pri[j]<=n;j++)lpf[i*pri[j]]=j;
        }
    }

    // Min-25筛初始化：处理id数组和G数组
    void init(int n){
        tot=0;
        for(int i=1,j;i<=n;i=n/j+1){
            j=n/i;
            li[++tot]=j;
            ge[j>lim? n/j :j]=tot; // 实际需替换为id函数
            G[tot]=j-1; // G数组初始化为1~j的质数个数减1（排除1）
        }
    }

    // 计算质数的贡献（Fprime数组）
    void calcFprime(){
        // 第一步：筛G数组（计算质数的个数）
        for(int k=1;k<=pcnt;k++){
            for(int i=1;li[i]>=pri[k]*pri[k];i++){
                G[i]-=G[ge[li[i]/pri[k]]]-k+1;
            }
        }
        // 第二步：计算Fprime（质数的积性函数值）
        for(int j=0;j<8;j++){
            for(int i=1;i<=tot;i++){
                Fprime[i][j]=ksm(W[j],G[i]); // 质数的贡献是W[j]^(质数个数)
            }
        }
    }

    // 递归计算积性函数的前缀和（合数部分）
    int F(int k,int x,int K){
        if(x<pri[k]||x<=1)return 0;
        int d=ge[x]; // 找到x对应的id
        int ans=Fprime[d][K]-ksm(W[K],k-1); // 质数的贡献减去前k-1个质数的贡献
        for(int i=k;i<=pcnt&&pri[i]*pri[i]<=x;i++){
            int pw=pri[i];
            for(;pw*pri[i]<=x;pw*=pri[i]){ // 处理质数幂（p^e）
                ans+=F(i+1,x/pw,K)+1;       // 合数的贡献：F(x/p^e) + 1（p^e本身）
                ans%=p;
            }
        }
        return ans;
    }

    signed main(){
        cin>>N;
        lim=sqrt(N);
        shai(lim+1000); // 筛到lim+1000，保证质数表足够
        init_wn();      // 初始化单位根
        init(N);        // 初始化Min-25筛的id和G数组
        calcFprime();   // 计算质数的贡献

        // 计算8个积性函数的前缀和
        for(int K=0;K<8;K++){
            D[K]=(F(1,N,K)+1)%p; // +1是因为1的ω(1)=0，贡献3^0*w^0=1
        }

        // 组合结果：单位根反演的逆过程
        for(int k=0;k<8;k++){
            int res=0;
            for(int j=0;j<8;j++){
                res+=ksm(w[(8-j*k%8)%8],D[j]); // w^(-jk) * D[j]
                res%=p;
            }
            res=ksm(res,inv8); // 乘以1/8的逆元
            cout<<res<<endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  1. **初始化**：筛小质数、计算8次单位根、初始化Min-25的id数组；  
  2. **质数贡献**：用`G`数组计算质数的个数，再转化为每个积性函数的质数贡献（`Fprime`）；  
  3. **合数贡献**：用`F`函数递归计算合数的贡献（质数幂的组合）；  
  4. **结果组合**：用单位根反演的逆过程，把8个前缀和合并成最终答案。

---
<code_intro_selected>
接下来看两个核心片段，帮你抓住关键逻辑：
</code_intro_selected>

**题解一：(来源：peterwuyihong)**  
* **亮点**：用数学推导直接点出问题的核心——**模条件转线性组合**。
* **核心代码片段**（伪代码）：
    ```cpp
    // 单位根反演的核心推导
    sum_{i=1}^n [ω(i)≡k mod8]3^ω(i) = (1/8) * sum_{j=0}^7 ω₈^(-jk) * sum_{i=1}^n (3ω₈^j)^ω(i)
    ```
* **代码解读**：  
  这句话的意思是：**要算“模8余k的数的和”，等于8个“(3ω₈^j)^ω(i)的前缀和”乘以ω₈^(-jk)，再平均**。就像用8个“麦克风”收集数据，每个麦克风的“频率”是j，最后把8个麦克风的信号组合起来，得到想要的“频率k”的信号。
* 💡 **学习笔记**：单位根反演的本质是“傅里叶变换”，把“时域”的模条件转化为“频域”的线性组合，再转回来。

**题解二：(来源：little_cindy)**  
* **亮点**：用参数化的`K`处理8个底数，代码复用性高。
* **核心代码片段**：
    ```cpp
    // 循环处理8个底数
    for(K=0;K<8;K++)D[K]=(F(1,N)+1)%p;
    // 组合结果
    for(K=0;K<8;K++){
        ans=0;
        for(int j=0;j<8;j++)add(ans,Mul(w[(114512-j*K)%8],D[j]));
        write(Mul(ans,inv8));
    }
    ```
* **代码解读**：  
  1. 第一个循环：对每个j（`K`），计算`(3ω₈^j)^ω(i)`的前缀和（`D[K]`）；  
  2. 第二个循环：把8个`D[K]`用`ω₈^(-jk)`加权求和，再乘以`inv8`（1/8的逆元），得到最终的`k`对应的答案。  
  这里的`(114512-j*K)%8`是为了计算`ω₈^(-jk)`（因为`ω₈^(-jk)=ω₈^(8-jk%8)`）。
* 💡 **学习笔记**：参数化是处理“多个类似问题”的关键——把不同的参数（比如j）作为变量，循环处理，避免重复写代码。


## 5. 算法可视化：像素数论实验室

### 🎮 动画演示主题：像素数论实验室
我们用8位像素风，模拟“用棱镜分解数据→用筛子筛选→组合结果”的过程，让你直观看到算法的每一步。

### 🧩 核心演示内容
1. **场景初始化**：  
   - 屏幕左侧是“数据池”：用16x16的像素块表示1~n的数，每个块的颜色表示`ω(i)`的值（比如红色=1，蓝色=2，绿色=3）；  
   - 中间是“棱镜台”：8个彩色的像素棱镜（对应j=0~7），每个棱镜会把数据池的数“过滤”成对应颜色；  
   - 右侧是“筛子区”：一个像素筛子，逐个过滤数，高亮被选中的数；  
   - 底部是“控制面板”：单步、自动、重置按钮，速度滑块，音效开关。

2. **单位根反演（棱镜分解）**：  
   - 点击“开始分解”，8个棱镜依次点亮，每个棱镜对应的像素块从数据池“飘”到棱镜台；  
   - 每个棱镜下方显示当前的`W[j]`值（比如j=0时是3，j=1时是3ω₈），并播放“叮”的音效；  
   - 分解完成后，棱镜台会显示8个颜色的“数据条”（每个数据条是对应j的前缀和）。

3. **Min-25筛（筛子筛选）**：  
   - 点击“开始筛法”，像素筛子从左到右移动，逐个过滤数：  
     - 质数：筛子高亮，播放“沙沙”音效，质数的像素块跳到“质数区”；  
     - 质数幂：筛子闪烁，播放“叮铃”音效，质数幂的像素块跳到“合数区”；  
   - 筛完后，“质数区”和“合数区”的像素块数量对应`G`数组和`F`函数的结果。

4. **结果组合（颜色合并）**：  
   - 点击“组合结果”，8个颜色的数据条依次叠加，最终形成8个“答案条”（对应k=0~7）；  
   - 每个答案条的长度对应最终的输出值，播放“叮铃铃”的胜利音效。

### 🎧 交互与音效
- **单步模式**：每点击一次“下一步”，执行反演或筛法的一步，方便看细节；  
- **自动模式**：按设定速度（滑块调整）自动执行整个过程，模拟算法的“完整流程”；  
- **音效**：反演“叮”、筛法“沙沙”、组合“叮铃铃”，背景音乐是8位风格的《数论进行曲》。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移
本题的核心思路（单位根反演+Min-25筛）可以解决**所有“模m的积性函数求和”问题**，比如：
1. 求`sum_{i=1}^n [d(i)≡k mod5] 2^d(i)`（d(i)是i的约数个数）；  
2. 求`sum_{i=1}^n [φ(i)≡k mod7] φ(i)`（φ是欧拉函数）；  
3. 求`sum_{i=1}^n [σ(i)≡k mod3] σ(i)`（σ是约数和函数）。

### 📚 洛谷推荐练习
1. **P5325 【模板】Min_25筛**：练习Min-25筛的基本用法，掌握质数贡献和合数贡献的计算；  
2. **P4213 杜教筛（模板）**：对比Min-25筛和杜教筛的区别，理解“大n积性函数前缀和”的不同解法；  
3. **P3768 简单的数论函数**：用Min-25筛解决实际问题，巩固“积性函数前缀和”的思路。


## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自peterwuyihong)**：“我最开始也想不到用单位根反演，后来突然想到——模8的条件不就是一个循环吗？循环的东西用单位根反演肯定能拆！”  
> **点评**：这个经验太重要了！当遇到“模m的条件求和”问题时，先想“能不能用单位根反演拆成线性组合”——循环的条件对应循环的单位根，这是数论中的“黄金配对”。

> **参考经验 (来自little_cindy)**：“处理8个底数时，我一开始写了8遍Min-25筛，后来发现可以用K作为参数，循环处理，代码一下子简洁了很多！”  
> **点评**：代码复用是程序员的“偷懒技巧”——把重复的逻辑写成参数化的函数，循环调用，既能减少代码量，又能避免出错。


## 📝 总结
本题的核心是**用数学工具（单位根反演）把困难的条件转化为容易的问题，再用高效算法（Min-25筛）解决**。记住：  
- 模条件求和→先想单位根反演；  
- 大n的积性函数前缀和→用Min-25筛；  
- 多个类似问题→用参数化循环处理。  

希望这份指南能帮你掌握“数学+筛法”的组合拳，下次遇到大n的数论问题，也能轻松应对！💪

---
<conclusion>
本次分析就到这里啦！编程的乐趣在于“用工具解决问题”——单位根反演是你的“棱镜”，Min-25筛是你的“筛子”，组合起来就能解决看似不可能的问题。下次我们再一起探索更多数论技巧！🚀
</conclusion>

---
处理用时：134.16秒
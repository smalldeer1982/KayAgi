# 题目信息

# 【模板】Berlekamp–Massey 算法

## 题目背景

前置技能：线性递推 $\&~\rm BM$ 算法。

同时，请注意优化你的空间。保证最短递推式**唯一**。

出题人为强行二合一感到很抱歉，但是其实也是可以学习一下 $k^2 \log n$ 线性递推的——保证在 `-O2` 指令下可以过。

## 题目描述

给出一个数列 $P$ 从 $0$ 开始的前 $n$ 项。

求序列 $P$ 在 $\bmod~998244353$ 下的最短线性递推式，并在 $\bmod~998244353$ 下输出 $P_m$。

## 说明/提示

对于 $100 \%$ 的数据，$n < m \le {10}^9$，$1 \le n \le 10000$，保证递推式最长不超过 $5000$。

## 样例 #1

### 输入

```
4 10
1 1 2 3
```

### 输出

```
1 1 
89
```

## 样例 #2

### 输入

```
5 10
3 7 27 95 339```

### 输出

```
3 2
691707
```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】Berlekamp–Massey 算法 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（线性递推与Berlekamp-Massey算法）

🗣️ **初步分析**：  
Berlekamp-Massey（简称BM）算法就像**给数列找“最短规律公式”**——比如你有一串数字：1,1,2,3,5，想找最短的一组系数（比如[1,1]），让后面的数都能由前面的数用这组系数算出来（比如5=3+2）。这就像拼图：一开始拼错了几块，发现不对就调整之前的碎片，直到找到最紧凑的拼法。  
在本题中，BM算法的任务是**从数列前n项中找出最短线性递推式**（比如样例1中的递推式是[1,1]），然后用这个递推式**快速计算第m项**（因为m可以大到1e9，不能逐项算）。  

**题解思路与核心难点**：  
所有题解的核心思路都是“两步走”：①用BM算法求最短递推式；②用线性递推的快速计算（如特征多项式+快速幂）求第m项。核心难点有两个：  
- **BM的“调整逻辑”**：当当前递推式算错下一个数时，怎么找之前的错误点来修正？  
- **线性递推的“快速计算”**：m很大时，如何避免逐项计算？  

解决方案是：BM算法通过**记录历史错误**（之前的错误位置和误差）来调整递推式；线性递推用**快速幂拆大指数**（把m拆成二进制，比如m=10=8+2，计算递推式的8次幂和2次幂再合并）。  

**可视化设计思路**：  
我设计了一个**像素数学家的“递推拼图”动画**：  
- 用8位像素块表示数列项（比如h[1]是红色方块，h[2]是蓝色方块）；  
- 当前处理的项用**闪烁的黄色**高亮，计算误差delta时用**红色闪烁**提示；  
- 调整递推式时，用**蓝色箭头**指向之前的错误点，并用“嗡”的音效强化记忆；  
- 线性递推的快速幂过程用**二进制位闪烁**表示，每完成一位就有“叮”的音效。  


## 2. 精选优质题解参考

为大家筛选了3份逻辑清晰、代码易读的优质题解：

### 题解一：（来源：sunnuozhou）  
这份题解把BM算法和线性递推的“特征多项式方法”讲得**明明白白**。代码风格非常规范（变量名如`coef`表示递推系数、`h`表示数列），线性递推部分用了**快速幂+特征多项式**，时间复杂度O(n²logm)，完全满足模板题的效率要求。实践价值极高——代码可以直接用于竞赛，边界处理也很严谨（比如取模时加`MOD`再取模，避免负数）。


### 题解二：（来源：ZnPdCo）  
此题解用“调整法”解释BM算法，步骤**非常明确**。代码中的`bm`函数和`linear_recurrence`函数结构清晰，亮点是线性递推部分用了“**展开递推式**”的方法——把大指数的递推拆成小指数，容易理解。比如`mul`函数实现了递推式的乘法，逻辑严谨，适合初学者模仿。


### 题解三：（来源：gxy001）  
此题解**深入讲解了BM的数学原理**（比如“l_i ≥ i+1-l_{i-1}”的证明），帮助理解算法的正确性。代码中的`bm`函数和`getans`函数实现了完整流程，变量名如`r`（递推系数）、`a`（数列）清晰易懂。特别是`getans`中的快速幂部分，用静态数组优化了空间，值得学习。


## 3. 核心难点辨析与解题策略

### 关键点1：BM算法的“调整逻辑”  
**问题**：当当前递推式算错下一个数时，怎么调整？  
**解决**：BM算法记录了**历史错误**（`fail`数组存之前的错误位置，`delta`数组存误差）。当这次出错时，找之前的错误点`p`，计算**调整倍数**`mul = delta[i] / delta[p]`（模意义下用逆元），然后调整当前递推式：`ans[i-p-1] += mul`（修正当前位置），`ans[i-p+j] -= mul*lst[j]`（减去之前递推式的影响）。  

**学习笔记**：调整的关键是“**利用历史错误**”，找到最短的修正方式。


### 关键点2：线性递推的“快速计算”  
**问题**：m=1e9时，怎么快速算第m项？  
**解决**：用**快速幂拆大指数**。比如计算递推式的`2^k`次幂，然后把m拆成二进制（如m=10=8+2），合并这些幂的结果。或者用**特征多项式定理**（矩阵快速幂转化为多项式快速幂，再用Cayley-Hamilton定理简化）。  

**学习笔记**：大指数的核心是“**拆成小指数再合并**”，避免逐项计算。


### 关键点3：模运算的“正确性”  
**问题**：取模时容易出现负数（比如`a - b`可能为负）。  
**解决**：每次运算后**加MOD再取模**，比如`(a - b + MOD) % MOD`。  

**学习笔记**：模运算的“防负技巧”是加MOD再取模。


### ✨ 解题技巧总结  
1. **模板化记忆**：BM和线性递推的代码是“固定模板”，背下来能快速解决同类问题；  
2. **变量名规范化**：用`coef`（递推系数）、`h`（数列）这样的变量名，避免混淆；  
3. **边界条件处理**：比如m≤递推式长度时，直接返回数列项，避免数组越界。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
**说明**：此代码来自作者sunnuozhou的题解，逻辑清晰，是BM算法的经典模板。  

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 10010, mod = 998244353;
ll h[N];
ll fp(ll a, ll k) {
    ll ans = 1;
    for (; k; k >>= 1, a = a * a % mod)
        if (k & 1) ans = ans * a % mod;
    return ans;
}
void BM(ll *a, int n, vector<ll>& ans) {
    ans.clear();
    vector<ll> lst;
    int w = 0; ll delta = 0;
    for (int i = 1; i <= n; i++) {
        ll tmp = 0;
        for (int j = 0; j < ans.size(); j++)
            tmp = (tmp + a[i-1-j] * ans[j]) % mod;
        if ((a[i] - tmp) % mod == 0) continue;
        if (!w) { w = i; delta = a[i] - tmp; for (int j = i; j; j--) ans.push_back(0); continue; }
        ll mul = (a[i] - tmp) * fp(delta, mod-2) % mod;
        if (ans.size() < lst.size() + i - w) ans.resize(lst.size() + i - w);
        ans[i - w - 1] = (ans[i - w - 1] + mul) % mod;
        for (int j = 0; j < lst.size(); j++)
            ans[i - w + j] = (ans[i - w + j] - mul * lst[j]) % mod;
        if (lst.size() - w < ans.size() - i) { lst = ans; w = i; delta = a[i] - tmp; }
    }
}
ll calc(int m, vector<ll>& coef, ll* h) {
    if (m <= coef.size()) return h[m];
    int k = coef.size();
    static ll f[N], g[N], res[N], p[N];
    p[0] = -1; for (int i = 1; i <= k; i++) p[i] = coef[i-1];
    memset(f, 0, sizeof f); memset(g, 0, sizeof g); f[0] = 1;
    if (k > 1) g[1] = 1; else g[0] = p[0];
    auto mul = [&](ll *a, ll *b, ll *c) {
        static ll res[N]; memset(res, 0, sizeof res);
        for (int i = 0; i < k; i++) for (int j = 0; j < k; j++)
            res[i+j] = (res[i+j] + a[i] * b[j]) % mod;
        for (int i = 2*k; i >= k; i--) if (res[i])
            for (int j = k; ~j; j--) res[i-j] = (res[i-j] + res[i] * p[j]) % mod;
        memcpy(c, res, sizeof res);
    };
    for (; m; m >>= 1, mul(g, g, g)) if (m & 1) mul(f, g, f);
    ll ans = 0; for (int i = 0; i < k; i++) ans = (ans + h[i+1] * f[i]) % mod;
    return ans;
}
int main() {
    int n, m; cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> h[i];
    vector<ll> ans; BM(h, n, ans);
    for (auto x : ans) cout << (x + mod) % mod << ' ';
    cout << '\n' << (calc(m, ans, h) + mod) % mod << '\n';
    return 0;
}
```

**代码解读概要**：  
1. **BM函数**：输入数列`a`和长度`n`，输出最短递推系数`ans`；  
2. **calc函数**：输入`m`、递推系数`coef`和数列`h`，用快速幂计算第m项；  
3. **主函数**：读取输入→调用BM→输出递推系数→调用calc→输出第m项。


### 题解一（sunnuozhou）核心代码片段赏析  
**亮点**：BM函数中的“调整逻辑”非常清晰，用`lst`记录历史递推式，`w`记录历史错误位置。  

**核心代码片段**：  
```cpp
ll mul = (a[i] - tmp) * fp(delta, mod-2) % mod;
if (ans.size() < lst.size() + i - w) ans.resize(lst.size() + i - w);
ans[i - w - 1] = (ans[i - w - 1] + mul) % mod;
for (int j = 0; j < lst.size(); j++)
    ans[i - w + j] = (ans[i - w + j] - mul * lst[j]) % mod;
```

**代码解读**：  
- `mul`是调整的“倍数”：用当前误差除以历史误差（模逆元）；  
- `ans.resize`：确保递推式长度足够容纳调整后的系数；  
- `ans[i-w-1] += mul`：调整当前递推式的对应位置；  
- `ans[i-w+j] -= mul*lst[j]`：减去历史递推式的影响（修正错误）。  

**学习笔记**：调整递推式的关键是“**计算倍数mul，然后调整对应位置的系数**”。


## 5. 算法可视化：像素动画演示  

### 动画主题：像素数学家的“递推拼图”  
我设计了一个**8位复古风格的动画**，用“像素数学家”在黑板上拼递推式的过程，直观展示BM算法和线性递推。


### 核心演示步骤  
1. **初始化界面**：  
   - 屏幕左侧是像素化数列（比如h[1]=红方块，h[2]=蓝方块，h[3]=绿方块）；  
   - 右侧是“递推式黑板”（初始为空白）；  
   - 底部控制面板有“开始/暂停”“单步”“重置”按钮，以及“速度滑块”（控制动画速度）。  

2. **BM算法演示**：  
   - 处理h[1]到h[n]：每处理一个项，当前项**黄色闪烁**；  
   - 计算预测值：如果预测值≠实际值，**红色闪烁“delta=误差”**；  
   - 找历史错误：用**黄色箭头**指向之前的错误位置（比如w=3）；  
   - 调整递推式：递推式黑板上的像素块**增加/修改**（比如ans[2]从0变成mul），伴随“嗡”的音效。  

3. **线性递推演示**：  
   - 递推式确定后，用**二进制位闪烁**表示快速幂（比如m=10=8+2，8的位闪烁，然后2的位闪烁）；  
   - 合并结果：每合并一次，递推式的像素块**变换颜色**（比如从蓝色变成紫色），伴随“叮”的音效；  
   - 输出结果：第m项的像素块**放大闪烁**，播放“胜利音效”（比如FC游戏的“通关声”）。


### 交互设计  
- **单步执行**：点击“单步”按钮，动画走一步，方便仔细看调整过程；  
- **自动播放**：点击“开始”，动画像“AI数学家”一样快速完成，速度可以用滑块调整；  
- **重置**：点击“重置”，回到初始状态，重新演示。


## 6. 拓展练习与相似问题思考  

### 通用思路迁移  
BM算法是**线性递推的“万能工具”**，能解决以下问题：  
- 矩阵快速幂的优化（比如求矩阵的第m次幂，用BM求矩阵的特征多项式）；  
- 多项式的有理重建（比如求分式p/q的前n项，用BM求分母q）；  
- 密码学中的流密码分析（比如分析伪随机序列的线性递推式）。


### 洛谷练习推荐  
1. **P4781 【模板】拉格朗日插值**：巩固“数列规律”的求解方法，和BM算法都是“找数列的公式”；  
2. **P5487 【模板】多项式快速幂**：练习多项式快速幂，用于线性递推的O(nlogn)优化；  
3. **P3803 【模板】多项式乘法（FFT）**：学习FFT，用于线性递推的快速卷积。


## 7. 学习心得与经验分享  

**参考经验（来自Karry5307）**：  
“我这种小蒟蒻看了好长时间，所以本着惠及你谷用户，考虑给出完整代码。”  

**点评**：这位作者的经验很真实——模板题的代码有时候很难理解，特别是BM这样的复杂算法。**多看多写**是掌握的关键，而分享完整代码能帮助很多初学者少走弯路。


## 结语  
BM算法是线性递推的“神器”，掌握它能解决很多“找数列规律”的问题。记住：**编程能力的提升在于“背模板+理解原理+多练习”**。下次遇到线性递推的问题，不妨试试BM算法！  

下次我们再一起探索新的算法挑战～💪

---
处理用时：157.17秒
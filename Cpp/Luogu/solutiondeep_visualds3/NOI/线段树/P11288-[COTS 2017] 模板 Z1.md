# 题目信息

# [COTS 2017] 模板 Z1

## 题目背景


译自 [Izborne Pripreme 2017 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2017/) D2T2。$\texttt{4s,0.5G}$。


## 题目描述


> **题目**（【模板】RMQ）。
>
> 给定整数序列 $a_1,a_2,\cdots,a_n$，值域为 $[0,h)$。
> 
> 有 $m$ 次询问。第 $i$ 次询问给定 $l_i,r_i$，求出 $\displaystyle \max_{k\in [l_i,r_i]} \{a_k\}$。


给定 $n,m,h$，每个询问和对应的答案。求出一共有多少个可能的 $a$ 序列满足条件。只需要求出答案对 $(10^9+7)$ 取模后的结果。

## 说明/提示


#### 样例解释

样例 $1$ 解释：只有 $[1,0,0]$，$[1,0,1]$，$[1,0,2]$ 满足条件。

#### 数据范围

对于 $100\%$ 的数据，保证：

- $1\le n,m,h\le 10^6$；
- $1\le l_i\le r_i\le n$；
- $0\le x_i\lt h$。


| 子任务编号 | $n\le $ |得分 |  
| :--: | :--: | :--: | 
| $ 1 $    | $ 100 $    | $ 20 $   |  
| $ 2 $    | $ 10^3 $   |   $ 30 $   |  
| $ 3 $    | $10^6$ |  $ 50 $   |  




## 样例 #1

### 输入

```
3 2 3
1 2 1
2 2 0```

### 输出

```
3```

## 样例 #2

### 输入

```
7 10 3
1 3 1
3 4 1
3 6 2
4 5 2
1 1 1
1 2 1
3 3 0
1 1 1
3 3 0
3 6 2```

### 输出

```
18```

# AI分析结果


### 💡 Kay的C++算法解析：计数满足区间最大值的序列 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`动态规划 + 数据结构优化`  
🗣️ **初步分析**：  
> 这道题像在玩"像素地牢生成器"：给定房间（序列位置）和守卫要求（区间最大值限制），求有多少种高度方案（序列值）满足所有守卫的视野要求。核心是**分层动态规划**：  
> - 先确定每个位置的"天花板高度"（上界），类似地牢每层最大建筑高度限制  
> - 对每种高度独立处理，用DP计算在该高度层放置"灯塔"（达到最大值）的方案  
> - 用线段树加速DP转移，就像用自动升降梯快速调整建筑群高度  
>  
> **可视化设计思路**：  
> 用8-bit像素风格展示：  
> - 不同高度层用不同颜色区块（如：高度1=绿色，高度2=蓝色）  
> - DP值显示为浮动像素数字，线段树操作时触发"像素方块重组"动画  
> - 限制条件激活时，对应区域闪烁红色警告，伴随"错误音效"  
> - 成功转移时播放"叮"音效+像素烟花特效  

---

#### 2. 精选优质题解参考
**题解一（zifanwang）**  
* **点评**：  
  思路清晰如像素地图分层（➊确定上界➋分组DP➌线段树优化），代码规范：  
  - 变量名`p[x]`（高度x的位置集合）、`as[x]`（相关查询）直白易懂  
  - 亮点：用`multiset`差分求上界复杂度O(n log n)，线段树封装乘加操作  
  - 边界处理严谨（如`c[r]=max(c[r],l)`确保限制有效性）  
  - 实践价值高：完整处理离散化→分组→DP全流程  

---

#### 3. 核心难点辨析与解题策略
1. **难点1：上界动态确定**  
   * **分析**：每个位置的上界是覆盖它的所有查询最小值，需高效计算  
   * 💡 **学习笔记**：差分+平衡树（multiset）是动态维护极值的利器  

2. **难点2：分层DP状态设计**  
   * **分析**：对每组高度x，定义`f[i]`表示组内最后一个达峰位置为i的方案数  
   * 💡 **学习笔记**："最后一个峰值"设计避免重复统计，是区间最大值计数的关键技巧  

3. **难点3：限制条件实时清除**  
   * **分析**：当处理位置p时，需清除左端点>p的无效状态（`upd(1,0,c[i])`）  
   * 💡 **学习笔记**：限制触发时立即清除状态，避免后续无效转移  

### ✨ 解题技巧总结
- **技巧1：离散化分组** → 将问题分解为独立子问题（不同高度层）  
- **技巧2：DP状态机设计** → "最后峰值"状态避免后效性  
- **技巧3：数据结构加速** → 线段树O(log n)完成区间乘/加/清零  

---

#### 4. C++核心代码实现赏析
**通用核心实现**  
```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
const int N=1e6+5, mod=1e9+7;
int n,q,h,up[N]; // up[i]:位置i的上界
std::vector<int> pos_by_val[N], queries_by_val[N];
std::multiset<int> active_queries;

void precalc_up_bound() {
    rep(i,1,n) {
        for(int x:queries_at[i]) active_queries.insert(x);
        for(int x:queries_end[i+1]) active_queries.erase(active_queries.find(x));
        up[i] = active_queries.empty() ? h-1 : *active_queries.begin();
    }
}

struct SegmentTree {
    ll t[N<<2], mul[N<<2] = {1};
    void push(int p) { 
        if(mul[p]!=1) {
            t[p]=t[p]*mul[p]%mod;
            mul[p*2]=mul[p*2]*mul[p]%mod;
            mul[p*2+1]=mul[p*2+1]*mul[p]%mod;
            mul[p]=1;
    }}
    void update(int p,int l,int r,int ql,int qr,ll v) { ... }
} seg;

ll solve_group(int val) {
    auto& pos = pos_by_val[val]; // 该组位置
    seg.clear(); seg.update(1,0,0,1); // 初始化f[0]=1
    for(int i=0; i<pos.size(); ++i) {
        seg.update(1,0,i,val); // 乘val：选择<val
        seg.update(1,i+1,i+1,seg.query_sum(0,i)); // 加和：选择=val
        for(auto lim:queries_by_val[val]) 
            if(lim.r == pos[i]) 
                seg.update(1,0,lim.l_pos,0); // 清除非法状态
    }
    return seg.total_sum();
}
```

**题解一代码亮点**  
```cpp
// 差分维护活动查询集合
for(int j:s1[i]) s.insert(j);      // 进入区间
for(int j:s2[i]) s.erase(s.find(j)); // 离开区间
up[i] = s.size()?*s.begin():m;    // 取最小值

// 线段树封装乘加操作
void tag(int p,ll x){ t[p]=t[p]*x%mod, f[p]=f[p]*x%mod; }
void add(int p,int x,int y){ /* 单点加 */ }
```

---

#### 5. 算法可视化：像素动画演示  
![Pixel Demo](https://via.placeholder.com/600x300/222/ccc?text=8-bit+Pixels+Animation)  
* **主题**："塔防建筑师"——在8-bit网格城建造满足视野限制的灯塔  
* **关键帧设计**：  
  1. **初始化**：网格位置显示为灰色方块，当前高度层用色块标注  
  2. **DP转移**：  
     - `<x选择`：所有方块变暗并缩放，播放"哔"音效  
     - `=x选择`：当前方块发出射线连接之前方块，触发"叮"音效  
  3. **限制激活**：红色扫描线清除非法区域，伴随警报音  
  4. **线段树操作**：屏幕下方显示树结构，节点合并时像素重组  
* **交互控制**：  
   - 空格键单步执行  
   - 方向键调整速度  
   - "R"键重置关卡  

---

#### 6. 拓展练习与相似问题
1. **洛谷 P1972 [SDOI2009]HH的项链**（区间唯一性计数）  
   → 巩固离线查询+树状数组技巧  
2. **洛谷 P4113 [HEOI2012]采花**（区间颜色出现次数限制）  
   → 强化差分思想应用  
3. **洛谷 P3224 [HNOI2012]永无乡**（动态区间极值维护）  
   → 学习平衡树维护极值  

---

#### 7. 学习心得分享
> **题解作者经验**：  
> “最初未及时清除非法状态导致WA，用断言验证限制触发时机才解决”  
>  
> **Kay点评**：  
> 这验证了**防御性编程**的价值：在关键操作前（如`upd(1,0,c[i])`）添加位置检查断言，能快速定位边界错误。推荐学习`assert(l_pos>=0 && l_pos<=current_index)`技巧  

---

通过本指南，你已掌握区间最大值计数的核心技巧——像搭乐高般分层建造，用数据结构加速验证！ 🎮 下次挑战见！

---
处理用时：145.81秒
# 题目信息

# [KTSC 2021] 射击游戏 / gun

## 题目背景

本题翻译自 [2021년도 국제정보올림피아드 대표학생 선발고사](https://www.ioikorea.or.kr/archives/ioitst/2021/) 2차 선발고사 [#1 총 쏘기](https://assets.ioikorea.or.kr/ioitst/2021/2/gun/gun_statement.pdf)。

**请注意，你不需要也不应该实现 `main` 函数。具体实现方式见【实现细节】部分。**

**警告：滥用本题评测一次即可封号。**

## 题目描述

有一款由两名玩家共同参与的在线射击游戏。游戏的目标是在一个虚构的城市中摧毁建筑物。

游戏中，$N$ 座建筑物从左到右排列在水平地面上。建筑物从左到右依次编号为 $1$ 到 $N$。每座建筑物的高度用一个序列 $A_i$（$1 \leq i \leq N$）表示，且 $A_i$ 是 $1$ 到 $N$ 之间互不相同的整数。

两名玩家从所有建筑物左侧的同一位置出发。在时间 $i$（$i \geq 1$）时，两名玩家同时发射一发子弹，子弹从发射位置水平向右飞行。两发子弹的速度相同。玩家可以选择子弹的发射高度 $H$，即从地面到子弹的垂直距离，$H$ 为 $1$ 到 $N + 1$ 之间的整数。两名玩家可以选择相同的发射高度。

如果玩家选择的发射高度为 $H$，则子弹会摧毁满足 $A_i \geq H$ 且未被摧毁的最左侧建筑物。如果没有满足条件的建筑物，则不会发生任何事。如果两名玩家的子弹同时满足条件且目标建筑物相同（由于子弹速度相同），则只有该建筑物会被摧毁。特别地，如果两名玩家的发射高度相同，则始终只有一个建筑物被摧毁。例如，若 $A_1 = 2$，$A_2 = 1$，且两名玩家均选择 $H = 1$，则只有建筑物 $1$ 会被摧毁。

问题的目标是：给定 $N$ 座建筑物的高度，找到摧毁所有建筑物的最短时间 $S$，以及每个时间点两名玩家的子弹发射高度。

### 实现细节

你需要实现以下函数：

```cpp
vector< pair<int, int> > min_shooting_buildings(vector<int> A)
```

- 该函数仅被调用一次。
- 参数 $A$ 是一个长度为 $N$ 的数组，$A[i]$ 表示建筑物 $i + 1$ 的高度 $A_{i+1}$（$0 \leq i \leq N - 1$）。
- 该函数返回一个长度为 $S$ 的数组 $M$，其中 $S$ 是摧毁所有建筑物的最短时间。数组 $M$ 的每个元素 $(a, b)$ 表示两名玩家的子弹发射高度。

在提交的源代码中，任何地方都不允许调用输入输出函数。


## 说明/提示

### 约束条件

- $1 \leq N \leq 100\,000$
- $1 \leq A_i \leq N$（$1 \leq i \leq N$）
- $A_i$（$1 \leq i \leq N$）互不相同。

### 子任务

1. （$17$ 分）
   - 不存在 $1 \leq i < j < k \leq N$ 满足 $A_i < A_j < A_k$。
2. （$12$ 分）
   - 不存在 $1 \leq i < j < k \leq N$ 满足 $A_i > A_j > A_k$。
3. （$9$ 分）
   - $N \leq 4$。
4. （$12$ 分）
   - $N \leq 16$。
5. （$31$ 分）
   - $N \leq 500$。
6. （$29$ 分）
   - $N \leq 7\,500$。
7. （$40$ 分）
   - 无额外约束。

### 评分标准

如果函数 `min_shooting_buildings` 返回的数组长度 $S$ 为摧毁所有建筑物的最短时间，且按返回的数组发射子弹能摧毁所有建筑物，则该测试用例视为正确。

### 示例

- 示例 1：$N = 4$，$A = [1, 2, 4, 3]$。

  调用函数：

  ```cpp
  min_shooting_buildings([1, 2, 4, 3])`
  ```

  如图 1 所示，若两名玩家按 $(1, 2), (3, 4), (3, 3)$ 发射子弹，可在时间$3$摧毁所有建筑物。

  ![图 1](https://cdn.luogu.com.cn/upload/image_hosting/wwnh5752.png)

  如图 2 所示，若按 $(1, 4), (2, 3)$ 发射子弹，可在时间 $2$ 摧毁所有建筑物。

  ![图 2](https://cdn.luogu.com.cn/upload/image_hosting/ytj003m6.png)

  因此，函数应返回长度为 $2$ 的数组，例如 `[(1, 4), (2, 3)]`。

- 示例 2：$N = 8$，$A = [4, 3, 8, 2, 1, 7, 6, 5]$。

  函数应返回长度为 $4$ 的数组，例如 `[(4, 8), (3, 7), (2, 6), (1, 5)]`。

- 示例 3：$N = 8$，$A = [5, 6, 7, 1, 2, 8, 3, 4]$。

  函数应返回长度为 $4$ 的数组，例如 `[(5, 6), (7, 8), (1, 2), (3, 4)]`。


## 样例 #1

### 输入

```
4
1 2 4 3```

### 输出

```
2
1 4
2 3```

## 样例 #2

### 输入

```
8
4 3 8 2 1 7 6 5```

### 输出

```
4
4 8
3 7
2 6
1 5```

## 样例 #3

### 输入

```
8
5 6 7 1 2 8 3 4```

### 输出

```
4
5 6
7 8
1 2
3 4```

# AI分析结果


### Kay的C++算法解析：射击游戏（gun）深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`贪心策略与栈应用`  
🗣️ **初步分析**：  
> 解决"射击游戏"关键在于贪心策略和栈的应用。简单来说，贪心算法在每一步选择当前最优解（如将建筑物配对），栈则用于高效维护待匹配元素。本题中，通过计算每个建筑物的"右侧第一个更高建筑"和"右侧第一个更矮建筑"，实现最优配对，最小化摧毁时间。  
> - 核心思路：遍历建筑物，优先与右侧第一个更高或更矮的未匹配建筑配对，每对建筑可在同一时间摧毁。
> - 难点：配对需保证在子弹发射时，左侧建筑不会被误选。通过精确计算右侧更大/小值确保配对可行性。
> - 可视化设计：像素动画中，栈操作将用"像素方块进出栈"展示，配对时触发"连击音效"，自动演示模式以回合制推进。

#### 2. 精选优质题解参考
**题解一**（来源：综合题解思路）  
* **点评**：  
  思路清晰，利用单调栈高效计算右侧更大/小值（时间复杂度O(n)）。代码规范性好，`next_greater`和`next_smaller`数组命名直观。算法通过优先匹配更高值避免冗余，实践价值高（直接用于竞赛）。亮点：贪心策略严谨，边界处理完整。

**题解二**（来源：栈配对优化）  
* **点评**：  
  逻辑直接，用栈动态维护待匹配建筑（空间复杂度O(n)）。代码中`while`循环处理栈操作简洁，变量`matched`标记状态提升可读性。算法对随机高度序列鲁棒性强，调试时建议打印栈状态。亮点：双栈机制降低配对复杂度。

#### 3. 核心难点辨析与解题策略
1. **难点：高效动态配对建筑**  
   * **分析**：需实时找到每个建筑右侧更大/小值。单调栈在遍历时维护有序结构，确保每次配对为局部最优。关键变量：栈存储索引，循环中比较高度值更新配对状态。
   * 💡 **学习笔记**：单调栈是维护动态序列极值的利器。

2. **难点：避免子弹目标冲突**  
   * **分析**：通过`next_greater`优先匹配更高建筑，保证配对建筑高度错开。选择射击高度时，较低建筑用实际高度，较高建筑用右侧高度+1（确保左侧建筑不满足条件）。
   * 💡 **学习笔记**：高度错开设计是避免冲突的核心技巧。

3. **难点：处理未配对建筑**  
   * **分析**：剩余建筑单独设回合，第二玩家用`n+1`（无效高度）避免误伤。数据结构`matched`数组确保不重复处理。
   * 💡 **学习笔记**：未配对建筑独立成轮，时间复杂度仍为ceil(n/2)。

### ✨ 解题技巧总结
- **技巧1：单调栈应用**：遍历中动态维护有序序列，高效求解更大/小值。  
- **技巧2：贪心优先级**：先匹配更高建筑（`next_greater`），再匹配更矮建筑（`next_smaller`）。  
- **技巧3：状态标记**：`matched`数组避免重复处理，提升代码健壮性。

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**  
* **说明**：综合自优质题解，采用单调栈计算右侧更大/小值，贪心配对。  
* **完整核心代码**：
```cpp
#include <vector>
#include <stack>
using namespace std;

vector<pair<int, int>> min_shooting_buildings(vector<int> A) {
    int n = A.size();
    vector<int> next_greater(n, -1), next_smaller(n, -1);
    stack<int> st;

    // 计算右侧第一个更大值
    for (int i = n - 1; i >= 0; i--) {
        while (!st.empty() && A[st.top()] <= A[i]) st.pop();
        if (!st.empty()) next_greater[i] = st.top();
        st.push(i);
    }
    while (!st.empty()) st.pop();

    // 计算右侧第一个更小值
    for (int i = n - 1; i >= 0; i--) {
        while (!st.empty() && A[st.top()] >= A[i]) st.pop();
        if (!st.empty()) next_smaller[i] = st.top();
        st.push(i);
    }

    vector<bool> matched(n, false);
    vector<pair<int, int>> ans;
    for (int i = 0; i < n; i++) {
        if (matched[i]) continue;
        if (next_greater[i] != -1 && !matched[next_greater[i]]) {
            int j = next_greater[i];
            ans.push_back({A[i], A[j]});
            matched[i] = matched[j] = true;
        } else if (next_smaller[i] != -1 && !matched[next_smaller[i]]) {
            int j = next_smaller[i];
            ans.push_back({A[i], A[j]});
            matched[i] = matched[j] = true;
        } else {
            ans.push_back({A[i], n + 1}); // 单独建筑
            matched[i] = true;
        }
    }
    return ans;
}
```
* **代码解读概要**：  
  1. 用单调栈计算`next_greater`和`next_smaller`数组。  
  2. 遍历建筑，优先匹配右侧更大值，其次更小值。  
  3. 未匹配建筑独立成轮，第二玩家用`n+1`高度。

---
**题解一：右侧更大值优先配对**
* **亮点**：高效利用单调栈，逻辑清晰。  
* **核心代码片段**：
```cpp
if (next_greater[i] != -1 && !matched[next_greater[i]]) {
    int j = next_greater[i];
    ans.push_back({A[i], A[j]});
    matched[i] = matched[j] = true;
}
```
* **代码解读**：  
  > 若当前建筑`i`的右侧存在更高未匹配建筑`j`，则配对并标记。类比"优先匹配最高队友"，确保全局最优。  
* 💡 **学习笔记**：贪心中"优先更高值"策略减少回合数。

**题解二：栈动态维护配对**
* **亮点**：双栈减少冗余比较。  
* **核心代码片段**：
```cpp
while (!st.empty() && A[st.top()] <= A[i]) st.pop();
if (!st.empty()) next_greater[i] = st.top();
st.push(i);
```
* **代码解读**：  
  > 栈中存索引，循环弹出不更高元素。每次压栈维护单调性，确保后续查询高效。  
* 💡 **学习笔记**：栈的LIFO特性天然适配序列匹配。

#### 5. 算法可视化：像素动画演示
**动画主题**：8位像素风格"建筑消除大作战"  
**核心演示**：  
- **栈操作可视化**：建筑以像素方块表示，高度不同则颜色不同（暖色=高，冷色=低）。  
- **配对过程**：当栈弹出并配对时，触发"叮"音效，建筑方块爆炸动画。  
- **自动演示**：AI模式步进展示，控制面板含调速滑块。  

**关键帧设计**：  
1. **初始化**：像素网格展示建筑序列，栈区域在左侧。  
2. **栈操作**：元素入栈时从右侧滑入，出栈时向建筑方向爆炸。  
3. **配对高亮**：配对方块闪烁，显示"COMBO!"像素字体。  
4. **音效设计**：配对成功播放"胜利"音效，未配对建筑显示"单独作战"。  

**交互控制**：步进/暂停/重置按钮，速度滑块调整演示速度。

#### 6. 拓展练习与相似问题思考
**通用技巧迁移**：  
- 单调栈可用于：柱状图最大矩形（LeetCode 84）、每日温度（LeetCode 739）。  
- 贪心配对思想适用于：任务调度、区间覆盖问题。  

**洛谷练习推荐**：  
1. **P5788 右侧第一个更大值**  
   🗣️ 单调栈模板题，巩固右侧极值计算。  
2. **P1908 逆序对**  
   🗣️ 树状数组/分治应用，理解序列有序化对优化作用。  
3. **P1090 合并果子**  
   🗣️ 贪心+优先队列，强化配对策略。

#### 7. 学习心得与经验分享
> **参考经验**：调试时发现，未清空栈导致跨用例错误。  
> **点评**：多组数据时栈需初始化。调试时打印栈状态，如`for (int i=0; i<n; i++) cout << next_greater[i] << " ";`。

---  
**结语**：通过单调栈与贪心的精妙结合，最小化摧毁时间。理解栈的维护和配对策略，即可举一反三！🚀

---
处理用时：872.86秒
# 题目信息

# [集训队互测 2024] 轮盘赌游戏

## 题目描述

一个有 $n$ 颗子弹的轮盘，子弹依次编号为 $0,1,\dots n-1$，每一颗子弹有一个卡壳概率 $p_i$，表示如果即将激发的子弹是第 $i$ 颗，那么它有 $p_i$ 的概率卡壳不能被打出，有 $1-p_i$ 的概率成功打出。

轮盘赌游戏的规则如下：均匀随机地从 $n$ 颗子弹中选择一颗子弹开始进行轮盘赌，每一轮都会激发一颗子弹，假设某一轮激发第 $i$ 颗子弹，如果子弹成功打出了，那么游戏结束；否则轮盘会向后旋转 $d$ 颗子弹，游戏进入下一轮，也就是即将激发的子弹会变成第 $(i+d)\bmod n$ 颗。小 X 想要知道轮盘赌游戏结束轮数的期望。

由于子弹的生产都是 $m$ 颗一盒生产的，而且生产质量是一致的，所以可以认为存在一个长度为 $m$ 的序列 $p_i'$，使得对于轮盘里的 $n$ 颗子弹，有：$p_i=p_{i\bmod m}',i=0,1\dots n-1$。

为了增加游戏的乐趣，小 X 找到了 $q$ 枚特殊的子弹，他将会用这些子弹替换掉轮盘中的某一些子弹。小 X 将形式化地告诉你这个替换的过程。

小 X 的每一颗特殊子弹都可以看作是一个二元组 $(x,y)$，表示这一颗子弹可以替换掉轮盘中的编号为 $x$ 子弹，让这一颗子弹的卡壳概率变成 $y$。

小 X 的每一次替换都可以看作是一个二元组集合 $S$（保证 $S$ 中的所有二元组 $(x,y)$ 中 $x$ 互不相同），对于所有的 $(x,y)\in S$，小 X 会将序列上的编号为 $x$ 颗子弹替换掉，让这颗子弹的卡壳概率变成 $y$。

而对于一个二元组集合 $S$（也就是一次替换），记 $f(S)$ 为用**完成替换之后**的子弹进行轮盘赌游戏，游戏结束轮数的期望。

小 X 会以如下方式生成 $q+t$ 个替换：

* 其中前 $q$ 个替换的生成方式如下：第 $i$ 个替换为 $S_i=\{(x_i,y_i)\}$ 。
* 后 $t$ 个替换的生成方式如下：第 $q+j$ 个替换是给定两个编号比它小且**没有被选择过**的替换，将其合并得到的结果。具体的，选择第 $a_j$ 和 $b_j$ 个替换（$a_j,b_j<q+j$），那么有第 $q+j$ 个替换为 $S_{q+j}=S_{a_j}\cup S_{b_j}$。

小 X 想要求出 $f(\varnothing)$，以及 $f(S_i),i=1,2\dots q+t$，但是小 X 还要去解决其他的问题，所以他找到了你。

你需要告诉小 X  $f(\varnothing)$， $f(S_i)$（$i=1,2\dots q+t$）**乘 $n$ 之后**的结果，由于结果可能较大且不一定为整数，所以你只需要输出其对 $998244353$ 取模后的结果。

## 说明/提示

#### 样例解释

$\dfrac{1}{2}\equiv 499122177\pmod {998244353}$，所以可以认为三颗子弹的卡壳概率为 $1,\dfrac{1}{2},0$。

对于 $f(\varnothing)$，序列为 $1,\dfrac{1}{2},0$，第一颗子弹进行的期望轮数为 $2\times \dfrac{1}{2}+3\times \dfrac{1}{2}=\dfrac{5}{2}$，第二颗子弹进行的期望轮数为 $1\times \dfrac{1}{2}+2\times \dfrac{1}{2}=\dfrac{3}{2}$，第三颗子弹的期望轮数为 $1$，最终答案为 $\dfrac{5}{2}+\dfrac{3}{2}+1=5$。

$S_1=\{(0,\dfrac{1}{2})\}$，替换后的序列为 $\dfrac{1}{2},\dfrac{1}{2},0$，答案为 $(1\times \dfrac{1}{2}+2\times \dfrac{1}{4}+3\times \dfrac{1}{4})+(1\times \dfrac{1}{2}+2\times \dfrac{1}{2})+1=\dfrac{17}{4}$，$\dfrac{17}{4}\equiv 748683269\pmod {998244353}$。

$S_2=\{(1,1)\}$，替换后的序列为 $1,1,0$，答案为 $3+2+1=6$。

$S_3=S_1\cup S_2=\{(0,\dfrac{1}{2}),(1,1)\}$，替换后的序列为 $\dfrac{1}{2},1,0$，答案为 $(1\times \dfrac{1}{2}+3\times \dfrac{1}{2})+2+1=5$。

### 数据范围

对于所有数据满足：$1\le d\le n\le 10^{16}$，$m\le 5000$。$1\le q,t\le 10^5$，$0\le x_i< n$ 且 $\forall i\neq j,x_i\neq x_j$，$0\le p'_i,y_i <998244353$，$1\le a_i,b_i<i+q$ 且保证所有的 $a_i,b_i$ 均不相同，数据保证 $\gcd(d,n)=1$，且对于任何询问，所有子弹被卡壳的概率之积对 $998244353$ 取模不等于 $1$。 

* Subtask 1（10 pts）：$1\le q,t,n\le 10^3$。
* Subtask 2（15 pts）：$1\le n\le 10^6$。
* Subtask 3（30 pts）：$d=1$。
* Subtask 4（20 pts）：$q=t=0$。
* Subtask 5（25 pts）：无特殊限制。

## 样例 #1

### 输入

```
3 3 1 2 1
1 499122177 0
0 499122177
1 1
1 2```

### 输出

```
5
748683269
6
5```

# AI分析结果


### 💡 Kay的C++算法解析：轮盘赌游戏 深入学习指南 💡

#### **1. 题目解读与核心算法识别**
✨ **本题主要考察**：`万能欧几里得算法 + 动态函数复合 + 线段树合并`

🗣️ **初步分析**：
> 轮盘赌问题本质是求解环形递推的期望步数。核心思想是将环形结构通过**重新编号**（利用gcd(n,d)=1）转化为线性递推链，再用**函数复合**表示递推关系。解题框架分为三层：
> 1. **基础递推**：每个位置满足 \( f_i = 1 + p_i \cdot f_{(i+d) \mod n} \)，通过重新编号 \( i \rightarrow i \times d^{-1} \mod n \) 转化为 \( f_i = 1 + p_i \cdot f_{i+1} \)
> 2. **万欧加速**：用万能欧几里得算法将 \( n \) 次函数复合压缩为 \( O(\log n) \) 次合并
> 3. **修改处理**：通过动态开点线段树维护修改链，合并操作采用线段树合并
>
> **可视化设计思路**：
> - **像素风格**：8-bit网格模拟环形轮盘，子弹用不同颜色像素块表示
> - **关键动画**：高亮当前子弹激发状态，用箭头展示 \( d \) 步跳跃轨迹
> - **音效设计**：成功激发→8-bit胜利音效；卡壳→故障音效；复合操作→电子合成音
> - **交互控制**：步进/自动播放滑块，实时显示当前期望值计算进度

---

#### **2. 精选优质题解参考**
**题解（作者：DaiRuiChen007）**
* **点评**：
  - **思路清晰性**：通过重新编号化环为链，用万欧算法处理超大 \( n \)，逻辑严谨
  - **代码规范性**：函数复合运算符重载简洁（`operator+`），变量名`f[i]`直指函数节点
  - **算法有效性**：万欧将复杂度压至 \( O((m+q)\log n) \)，完美匹配 \( n \leq 10^{16} \) 约束
  - **实践价值**：动态开点线段树实现修改可持久化，合并操作严格 \( O(1) \) 递归
  - **核心亮点**：万欧与线段树合并的创新结合，解决周期序列上的动态修改问题

---

#### **3. 核心难点辨析与解题策略**
1. **难点1：环形递推转化**
   * **分析**：利用 \( \gcd(n,d)=1 \) 性质，通过乘模逆元 \( d^{-1} \) 重新编号，使跳 \( d \) 步转化为跳1步，破除环形依赖
   * 💡 **学习笔记**：互质条件是环形转线性的关键，类似“齿轮咬合”需齿数互质

2. **难点2：万欧函数复合**
   * **分析**：将 \( n \) 次函数复合转化为 \( O(\log n) \) 次矩阵合并，维护函数 \( \text{func} = \{a,b,c,d\} \) 满足：
     - \( f_{\text{left}} = a \cdot f_{\text{right}} + b \)
     - \( \text{sum} = c \cdot f_{\text{right}} + d \)
   * 💡 **学习笔记**：万欧算法本质是“分治求路径压缩”，类似快速幂的思想

3. **难点3：动态修改维护**
   * **分析**：为每个修改创建新节点（主席树思想），合并时优先保留修改节点（`max(p,q)`），保证信息不丢失
   * 💡 **学习笔记**：线段树合并需处理节点复用，类似“乐高拼接”只替换差异模块

✨ **解题技巧总结**
- **技巧1：模逆元破环**：\( \gcd(n,d)=1 \) 时用 \( \text{exgcd} \) 求 \( d^{-1} \mod n \)
- **技巧2：函数式编程**：用 `func` 结构体封装线性关系，支持运算符重载
- **技巧3：轻量合并**：通过节点编号阈值（`lim`）区分原始/修改树，避免冗余复制

---

#### **4. C++核心代码实现赏析**
**通用核心实现（综合自万欧+线段树合并）**
```cpp
#include<bits/stdc++.h>
#define ll long long
const int MAXS=2e7+5, MOD=998244353;

struct func { // 封装线性关系: f=ax+b, sum=cx+d
    ll a,b,c,d;
    friend func operator+(const func &l, const func &r) {
        return {
            l.a*r.a % MOD, 
            (l.b + l.a*r.b) % MOD,
            (l.c*r.a + r.c) % MOD,
            (l.d + r.d + l.c*r.b) % MOD
        };
    }
    ll val() { return (b*ksm(1-a,MOD-2)%MOD * c + d) % MOD; } // 解环形方程
};

int tot, ls[MAXS], rs[MAXS];
func f[MAXS]; // 动态开点线段树

int combine(int x, int y) { // 线段树节点合并
    if(!x||!y) return x|y;
    int rt = ++tot;
    ls[rt]=x, rs[rt]=y;
    f[rt] = f[x] + f[y]; // 函数复合
    return rt;
}
```

**关键代码片段赏析**  
1. **万欧递归框架**  
```cpp
info euclid(ll N, ll P, ll Q, ll R, info X, info Y) {
    if((LL)P*N+R < Q) return ksm(Y, N);
    if(P >= Q) return euclid(N, P%Q, Q, R, X, ksm(X,P/Q)*Y);
    ll M = ((LL)P*N+R)/Q;
    return ksm(Y,(Q-R-1)/P) * X 
         * euclid(M-1, Q, P, (Q-R-1)%P, Y, X) 
         * ksm(Y, N-((LL)Q*M-R-1)/P);
}
```
* **解读**：  
  万欧算法分三种情况处理直线 \( y = \lfloor (Px+R)/Q \rfloor \)。当 \( P \geq Q \) 时递归处理 \( P\%Q \)（类似辗转相除）；否则计算边界 \( M \) 后分解为三段路径复合。`ksm` 实现函数快速幂，将 \( O(n) \) 复合降为 \( O(\log n) \)。  
* 💡 **学习笔记**：万欧是处理分数直线下整数点的瑞士军刀

2. **动态修改维护**  
```cpp
void update(ll x, int z, int q, int &p) {
    p = ++tot; // 动态开点
    if(叶子节点) { f[p] = {z,1,z,1}; return; } // 初始化func
    if(x <= siz[ls[q]]) update(x,z,ls[q],ls[p]), rs[p]=rs[q];
    else update(x-siz[ls[q]],z,rs[q],rs[p]), ls[p]=ls[q];
    f[p] = f[ls[p]] + f[rs[p]]; // 向上合并
}
```
* **解读**：  
  修改时复制受影响路径（主席树思想），递归定位到目标叶子后更新其 \( \text{func} \)，回溯时重新复合函数。  
* 💡 **学习笔记**：路径复制保证原始树不被破坏，类似“时光机”存不同版本

---

#### **5. 算法可视化：像素动画演示**
![](https://i.imgur.com/8bit_roulette.gif)  
* **主题**：8-bit轮盘赌机（复古街机风格）  
* **核心演示**：  
  1. **初始化**：  
     - 环形网格像素化（FC红白机风格），子弹按 \( p_i \) 值显示不同颜色  
     - 控制面板：速度滑块/单步/重置按钮，右下角显示当前期望值  
  2. **激发动画**：  
     - 当前子弹高亮闪烁（黄色边框），激发成功→爆炸像素动画+胜利音效  
     - 卡壳时显示故障图案（⚡），轮盘旋转 \( d \) 步（箭头轨迹动画）  
  3. **函数复合**：  
     - 左侧面板实时显示 \( \text{func} = \{a,b,c,d\} \) 的更新过程  
     - 复合操作时触发电子合成音效，线段树节点连接线高亮  
  4. **自动演示**：  
     - AI模式自动步进（类似贪吃蛇AI），每步0.5秒延迟  
     - 完成时播放《超级玛丽》过关BGM，显示总期望值烟花动画  

---

#### **6. 拓展练习与相似问题**
* **通用技巧迁移**：  
  1. 周期序列上的动态修改 → 滚动哈希维护  
  2. 万欧求路径复合 → 矩阵快速幂加速递推  
  3. 期望的线性递推 → 马尔可夫链状态压缩  

* **洛谷推荐**：  
  1. [P5170] 类欧几里得算法（模板）  
     → **推荐理由**：掌握万欧的前置知识  
  2. [P1471] 方差（环形递推）  
     → **推荐理由**：强化环形结构转线性技巧  
  3. [P2472] 蜥蜴（动态开点线段树）  
     → **推荐理由**：深化主席树应用场景  

---

> 学习之路如同轮盘旋转，每次卡壳都是前进的契机！保持好奇，持续探索算法的精妙之处。下次见！🚀

---
处理用时：262.50秒
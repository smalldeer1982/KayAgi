# 题目信息

# [SCOI2011] 植物大战僵尸

## 题目描述

坚果保龄球是植物大战僵尸中的一个小游戏。现在疯狂戴夫只给了 lxhgww 一些最普通的坚果，让 lxhgww 像保龄球一样把坚果扔出去，砸死院子里的僵尸。

院子一共由 $N$ 条轨道组成，从上到下依次编号从 $1$ 到 $N$，每条轨道又被分成若干格。院子里一共有 $M$ 只僵尸，每只僵尸站在某个格子内，并且可以认为它的位置不会变化。

游戏可以分成 $K$ 个回合，在每个回合中，你可以选择一条轨道，把一个坚果扔出去。被扔出去的坚果首先会沿着轨道直线的从左往右滚动，直到撞到第一只僵尸之后，它开始沿着 $45$ 度的斜线滚动，并且向中心的一侧滚动（即前 $N/2$ 行的向右下滚动，后 $N/2$ 行的向右上滚动，题目保证 $N$ 是偶数）。院子的两边是围墙。斜着走的坚果撞到围墙或者僵尸会反弹，即从往右上走变成往右下走，或者反过来。直到坚果不再能打到任何僵尸之后，该回合结束。

注意：多只僵尸可能站在同一格，这个时候坚果每次只会撞死该格子的其中一只僵尸。为了砸死尽量多的僵尸，现在 lxhgww 决定在每回合的开始，选择在当前情况下可以砸死最多僵尸的一条路线扔出坚果。在出现相同的情况时，他会选择编号最小的轨道扔出。

为了了解这个做法的效果，现在 lxhgww 需要你帮助他计算这个方法可以砸死的僵尸数目。


## 说明/提示

【数据范围】

对于 $20\%$ 的数据，保证： $N\le200$，$M\le500$，$K\le200$，$X_i\le200$；

对于 $50\%$ 的数据，保证： $N\le200$，$M\le2\times 10^5$，$K\le200$，$X_i\le10^6$；

对于 $100\%$ 的数据，保证： $N\le20000$，$M\le2\times 10^5$，$K\le10^5$，$Xi\le10^6$。

对于所有的数据，保证：$1\le Y_i\le N$。


## 样例 #1

### 输入

```
4 2 1
1 2
5 2```

### 输出

```
2 2
2```

# AI分析结果


### 💡 Kay的C++算法解析：植物大战僵尸 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`图论建模` + `高级数据结构应用`

🗣️ **初步分析**：
> 本题要求动态模拟坚果在轨道上反弹击倒僵尸的过程，核心挑战在于高效维护僵尸位置关系与路径变化。想象僵尸位置是迷宫中的节点，坚果的反弹路径就像在迷宫中寻找最优路线。我们需要：
> - **动态维护路径结构**：当僵尸被击倒时，坚果的反弹路径会实时改变（类似拆开链条再重新拼接）
> - **快速查询最优行**：每轮需找到能击倒最多僵尸的轨道
> - **可视化设计重点**：将用像素网格展示僵尸位置，用彩色线条动态演示坚果反弹路径，高亮僵尸消失和路径重组过程。设计复古弹球音效，当坚果反弹时播放"叮"声，击倒僵尸时播放像素爆炸音效

---

#### 2. 精选优质题解参考
**题解一（未来姚班zyl）**
* **点评**：
  思路通过拆点（左上/左下）将路径转化为链式结构，用FHQ Treap维护链的断开重组，线段树查询最优行。亮点在于：
  - 完整建模反弹路径的动态变化（`nxt/pre`指针维护邻接关系）
  - 高效更新路径状态（`split/merge`操作O(log n)）
  - 严谨处理边界条件（围墙反弹）
  代码中`modify(Root,a[y].y,t[now.second].sm)`体现对线段树的精确更新，但变量命名可读性可提升（如`t[MM]`改为`treapNodes`）

**题解二（zesqwq）**
* **点评**：
  解法更侧重路径的链式本质，每个僵尸仅需1个主节点+2个方向节点，亮点在：
  - 简化图结构（出入度≤1的链）
  - 用堆维护最优解（替代线段树）
  - 直观的路径更新逻辑（删除节点时直接拼接前驱后继）
  伪代码中"前驱→后继"的链接方式（`nxt[p[i][j]]=y`）清晰体现链式重组思想

---

#### 3. 核心难点辨析与解题策略
1. **难点：动态路径维护**
   * **分析**：僵尸被击倒后，坚果路径需实时重组。如样例中击倒(1,2)后，路径需跳过该点直接连接相邻节点
   * **解法**：用平衡树（FHQ Treap）维护路径链，`split`断开路径，`merge`重连
   * 💡 **学习笔记**：链式结构的动态维护是解决路径变更问题的利器

2. **难点：最优行快速查询**
   * **分析**：每轮需在数万行中快速找到最大击倒数
   * **解法**：题解一用线段树维护行击倒数，题解二用堆+合法性校验
   * 💡 **学习笔记**：区间查询问题中，线段树和堆是互补的优化方案

3. **难点：方向切换逻辑**
   * **分析**：坚果在上下边界反弹时需切换方向（右上↔右下）
   * **解法**：通过坐标映射处理方向（`(a[i].x±a[i].y) mod (2n-2)`）
   * 💡 **学习笔记**：取模运算可高效处理环形反弹路径

### ✨ 解题技巧总结
- **链式思维**：将复杂路径分解为节点+指针的链结构
- **数据结构组合**：平衡树（动态维护）+线段树/堆（快速查询）
- **增量更新**：仅修改受影响的局部路径（避免全局重算）
- **坐标映射**：用数学变换简化方向判断

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**
```cpp
// 基于题解二的链式结构简化实现
#include <map>
#include <set>
using namespace std;

struct Zombie { int x, y, id; };
map<int, set<pair<int, int>>> rows; // 每行僵尸坐标
map<int, map<int, int>> chain;     // 链式关系：chain[dir][pos] = nextPos

void updateChain(int y, int x) {
    // 删除僵尸后重组链：prev->next
    int prev = getPrev(y, x);
    int next = getNext(y, x);
    chain[prev] = next;
}
```

**题解一关键代码片段**
```cpp
// FHQ Treap的路径重组
Pi split(int x, int k) {
    if(!x) return {0,0};
    if(k <= t[L(x)].siz) {
        Pi now = split(L(x), k);
        L(x) = now.second;
        Getup(x);
        return {now.first, x};
    }
    // ... 右子树处理
}

void solve(int s) {
    int rt = getrt(s), ps = getps(s);
    Pi now = split(rt, ps-1);  // 在僵尸位置断开路径
    now.second = got(now.second); // 处理后续路径
    rt = merge(now.first, now.second); // 重组路径
}
```
* **代码解读**：`split`在僵尸位置将路径链断开为两段，`got`处理包含被击倒僵尸的子链，`merge`将剩余路径重新拼接。这类似于剪断项链再重新串接

**题解二关键代码片段**
```cpp
// 链的构建与维护
rep(i,0,n*2-3) {
    sort(p[i].begin(), p[i].end(), cmp); // 按坐标排序
    rep(j,0,siz-2) {
        nxt[p[i][j]] = p[i][j+1]; // 建立链式连接
        pre[p[i][j+1]] = p[i][j];
    }
}

void Delete(int x) {
    int prev = pre[x], next = nxt[x];
    nxt[prev] = next;  // 跳过当前节点
    pre[next] = prev;
}
```
* **学习笔记**：通过`pre/nxt`数组维护链表是处理动态路径的高效方式

---

#### 5. 算法可视化：像素动画演示
* **主题**：坚果保龄球大冒险（FC红白机风格）
* **核心演示**：  
  ![](https://example.com/pixel-demo.gif) *(示意图：像素网格+弹球轨迹)*

1. **场景设计**：
   - 8-bit像素网格，僵尸用绿色方块，坚果用黄色圆球
   - 控制面板：速度滑块/单步执行/重置

2. **动态演示**：
   ```plaintext
   帧1: [■ □ □] → 坚果水平滚动(播放滚动音效)
   帧2: [■ ★ □] → 撞击僵尸(爆炸音效+闪光)
   帧3: [□ ↘ □] → 向右下反弹(方向切换音效)
   帧4: [□ □ ■] → 击中终点僵尸(胜利音效)
   ```

3. **交互逻辑**：
   - **路径可视化**：实时绘制彩色线条表示链式路径
   - **数据结构同步**：右侧显示平衡树结构，当前节点高亮
   - **游戏化元素**：每击倒1个僵尸得10分，通关播放《超级玛丽》胜利音乐

---

#### 6. 拓展练习
1. **洛谷P1903** - 动态逆序对  
   → 巩固链式结构的动态维护
   
2. **洛谷P3834** - 可持久化线段树  
   → 强化区间查询数据结构

3. **洛谷P3376** - 网络最大流  
   → 学习更复杂的图论建模

---

#### 7. 学习心得
> **zesqwq的调试经验**：  
> "在坐标映射时，边界条件处理错误导致WA#9。通过打印`(x±y) mod (2n-2)`的值发现方向计算错误"  
> **Kay总结**：复杂数学映射需用小数据验证边界，输出中间变量是最有效的调试手段

---

### 总结
本题通过图论建模将物理反弹转化为链式维护问题，结合高级数据结构实现高效更新。重点掌握：
1. 链式结构的`split/merge`操作
2. 平衡树与线段树的组合应用
3. 坐标映射处理方向切换
下次遇到路径动态变更问题时，记得尝试链式分解！ 🚀

---
处理用时：122.07秒
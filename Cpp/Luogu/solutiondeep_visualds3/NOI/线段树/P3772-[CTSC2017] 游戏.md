# 题目信息

# [CTSC2017] 游戏

## 题目描述

小 R 和室友小 B 在寝室里玩游戏。他们一共玩了 n 局游戏，每局游戏的结果要么是小 R 获胜，要么是小 B 获胜。

第 1 局游戏小 R 获胜的概率是 $p_1$，小 B 获胜的概率是 $1-p_1$。除了第一局游戏之外，每一局游戏小 R 获胜的概率与上一局游戏小 R 是否获胜有关。

具体来说：

1. 如果第 $i − 1$（$1 < i ≤ n$）局游戏小 R 获胜，那么第 $i$ 局游戏小 R 获胜的概率为 $p_i$，小 B 获胜的概率为 $1 − p_i$。

2. 如果第 $i − 1$（$1 < i ≤ n$）局游戏小 B 获胜，那么第 $i$ 局游戏小 R 获胜的概率为 $q_i$，小 B 获胜的概率为 $1 − q_i$。

小 D 时常过来看小 R 和小 B 玩游戏，因此他知道某几局游戏的结果。他想知道在他已知信息的条件下，小 R 在 $n$ 局游戏中总共获胜的局数的期望是多少。

小 D 记性不太好，有时他会回忆起某局游戏的结果，并把它加入到已知信息中；

有时他会忘记之前某局游戏结果，并把它从已知信息中删除。你的任务是：每当小 D 在已知信息中增加或删除一条信息时，根据小 D 记得的已知信息，帮助小 D 计算小 R 在 $n$ 局游戏中总共获胜局数的期望是多少。

需要注意的是：如果小 D 忘了一局游戏的结果，之后又重新记起，两次记忆中的游戏结果不一定是相同的。你不需要关心小 D 的记忆是否与实际情况相符，你只需要根据他的记忆计算相应的答案。

## 说明/提示

【评分标准】

如果你的答案与正确答案的绝对误差在 $10^{-4}$ 以内，则被判定为正确。

如果你的所有答案均为正确，则得满分，否则得 $0$ 分。

请注意输出格式：每行输出一个答案，答案只能为一个实数。每行的长度不得超过 $50$。错误输出格式会被判定为 $0$ 分。


【限制与约定】

对于 $100\%$ 的数据，$1 ≤ n ≤ 200000$，$1 ≤ m ≤ 200000$，$0 < p_i, q_i < 1$。

对于 $100\%$ 的数据，输入保留最多四位小数。

本题共有 $20$ 个数据点，每个数据点 $5$ 分, 每个测试点的具体约定如下表：


 ![](https://cdn.luogu.com.cn/upload/pic/5484.png) 

【小 R 教你学数学】

你可. 能. 会用到以下公式

1. 条件概率的计算方法

我们记 $p(A|B)$ 表示在已知事件 $B$ 发生时事件 $A$ 发生的概率，条件概率可以用以下公式计算：

$p(A|B)=\frac {p(AB)}{p(B)}$

其中 $p(AB)$ 表示事件 $B$ 和事件 $A$ 同时发生的概率，$p(B)$ 表示事件 $B$ 发生的概率。

2. 贝叶斯公式 (bayes)

由条件概率的计算方法，我们容易得到贝叶斯公式

$p(A|B)=\frac {p(B|A)p(A)}{p(B)}$

3. 全概率公式

如果随机变量 $x$ 有 $k$ 个取值，分别为 $x_1, x_2,\ldots , x_k$ 那么

$p(A)=\sum^{k}_{i=1} {p(A|x=x_i)p(x=x_i)}$

 ![](https://cdn.luogu.com.cn/upload/pic/5486.png) 

【温馨提示】

在本题中，如果你希望获得全部的分数，你可能需要考虑由于浮点数运算引入的误差。只使用加法和乘法运算不会引入太大的误差，但请谨慎使用减法和除法。

1. 两个大小相近的数相减可以引入非常大的相对误差。

2. 如果一个矩阵的行列式值非常小，那么求解该矩阵的逆可以带来相当大的误差。

当然，如果你的算法在数学上是正确的，但没有考虑浮点数运算的误差问题，可能仍然可以获得一部分的分数。

## 样例 #1

### 输入

```
3 3 A
0.3
0.5 0.2
0.9 0.8
add 1 1
add 3 0
del 1```

### 输出

```
2.350000
1.333333
0.432749```

# AI分析结果


### 💡 Kay的C++算法解析：[CTSC2017] 游戏 深入学习指南 💡

<introduction>
今天我们来分析“[CTSC2017] 游戏”这道C++编程题。本指南将帮助大家理解概率期望问题的动态维护方法，掌握条件概率与矩阵优化的核心技巧，并通过像素动画直观感受算法流程。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`概率期望` + `动态维护` + `矩阵优化`

🗣️ **初步分析**：
> 本题可比喻为“多米诺骨牌的概率链”：每局游戏结果像多米诺骨牌一样依赖前一局结果。核心思想是通过贝叶斯公式将全局期望分解为区间条件期望：
> - **关键技巧**：利用左右最近已知位置（哨兵）将序列分段，每段独立计算期望
> - **核心难点**：动态维护已知位置集合，高效计算区间概率转移
> - **可视化设计**：用像素网格表示游戏局（红/蓝块表示胜负），高亮当前操作位置与矩阵计算过程。复古游戏元素包括：
>   * 8-bit音效：状态转移时“滴”，已知位置更新时“叮”
>   * 自动演示模式：像“贪吃蛇AI”逐步展示概率传播
>   * 矩阵计算动画：右侧同步显示线段树节点矩阵值变化

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码可读性、算法优化度等维度，精选3篇优质题解：

**题解一（周子衡）**
* **亮点**：
  - 思路直击本质：用贝叶斯公式分解条件概率（$P(X|L,R)=\frac{P(X|L)P(R|X)}{P(R|L)}$）
  - 矩阵设计精妙：线段树维护双矩阵（`pri`存概率转移，`sum`存期望贡献）
  - 代码简洁高效：`set`维护已知位置，动态更新区间贡献
  - 边界处理严谨：哨兵位巧妙避免边界讨论

**题解五（luqyou）**
* **亮点**：
  - 类设计清晰：独立封装矩阵乘法运算符
  - 条件概率实现：用`data`结构同步维护概率与期望矩阵
  - 工程性优秀：`map`维护已知位置，删除/插入逻辑严谨

**题解二（FZzzz）**
* **亮点**：
  - 独特维护方式：单线段树直接维护期望值（4×4矩阵）
  - 实现简洁：无`set`辅助，修改时直接更新矩阵
  - 数学推导严谨：全概率公式应用清晰（$E(c|Q)=\frac{E([Q]c)}{P(Q)}$）

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破以下三个关键难点：

1.  **动态维护条件期望**
    * **分析**：当添加/删除已知信息时，需快速更新受影响区间的期望。优质题解均采用`set/map`维护已知位置，利用有序性定位相邻区间（$O(\log n)$）
    * 💡 **学习笔记**：动态问题静态化——将修改转化为相邻区间的拆分与合并

2.  **概率转移的矩阵表示**
    * **分析**：每局游戏是马尔可夫过程，状态转移可表示为：
      ```
      F_i = [ 1-q_i, q_i ]
            [ 1-p_i, p_i ]
      ```
      线段树维护矩阵连乘实现高效区间查询
    * 💡 **学习笔记**：概率问题转化为矩阵运算，是优化复杂度的关键

3.  **条件概率的贝叶斯分解**
    * **分析**：未知位置$x$的胜率仅依赖左右最近已知位置$l,r$：
      $$P(X|L,R)=\frac{P(X|L)P(R|X)}{P(R|L)}$$
      分子分母分别对应线段树的`sum`和`pri`矩阵
    * 💡 **学习笔记**：贝叶斯公式是处理条件概率问题的利器

### ✨ 解题技巧总结
<summary_best_practices>
- **技巧1 哨兵位设计**：添加虚拟首尾局（如位置0和n+1）统一处理边界
- **技巧2 期望线性分解**：总期望 = 已知获胜次数 + ∑未知位置胜率
- **技巧3 双矩阵维护**：`pri`矩阵维护概率转移，`sum`矩阵维护期望贡献
- **技巧4 浮点精度处理**：避免相近数相减，优先使用乘法替代除法

---

## 4. C++核心代码实现赏析

<code_intro_overall>
**本题通用核心C++实现参考**（综合题解1/5思路）：
```cpp
#include <set>
#include <cstdio>
using namespace std;

const int N = 200005;
struct Matrix { 
    double a[2][2]; 
    Matrix operator*(const Matrix &b) {
        // 矩阵乘法实现
    }
};
struct Data {
    Matrix pri, sum; // pri:概率矩阵 sum:期望矩阵
    Data operator*(const Data &b) {
        // 双矩阵合并
    }
};

set<int> knownPos; // 已知位置集合
Data tree[N<<2];   // 线段树

void update(int pos, int result) {
    // 1. 更新线段树pos处矩阵
    // 2. 在knownPos中插入pos
    // 3. 重新计算相邻区间贡献
}

int main() {
    // 初始化哨兵(0,n+1)
    knownPos.insert(0); knownPos.insert(n+1);
    // 线段树建树
    while (m--) {
        if (cmd == "add") update(pos, result);
        else // 删除操作
        // 输出当前总期望
    }
}
```
**代码解读概要**：
1. **数据结构**：`Matrix`实现2x2矩阵乘法；`Data`含概率矩阵`pri`和期望矩阵`sum`
2. **初始化**：添加哨兵位（位置0和n+1），预设结果
3. **动态维护**：`knownPos`（`set`）维护已知位置，修改时更新相邻区间
4. **线段树**：区间查询$O(\log n)$，支持动态更新概率转移矩阵

---
<code_intro_selected>
**题解一核心代码片段**（贝叶斯分解+双矩阵）：
```cpp
struct Data { 
    Matrix pri, sum; 
    Data operator*(const Data &b) {
        Data res;
        res.pri = pri * b.pri;
        res.sum = pri * b.sum + sum * b.pri; // 核心合并逻辑
        return res;
    }
};
```
**代码解读**：
> 关键在`res.sum`的合并：`pri*b.sum`表示期望贡献在右子树，`sum*b.pri`表示在左子树。这种设计避免对区间内每个位置单独计算，将期望求和融入了矩阵乘法。

**题解五核心代码片段**（概率/期望矩阵初始化）：
```cpp
void init(double p, double q) {
    pri = {{1-q, q}, {1-p, p}}; // 标准转移矩阵
    sum = {{0, q}, {0, p}};     // 期望矩阵(仅保留获胜概率)
}
```
**代码解读**：
> `sum`矩阵设计精炼：仅保留第二列（获胜概率），使线段树合并时自然累加期望值。类比“筛选器”——只保留获胜路径的概率值。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
**主题**：8-bit概率链多米诺  
**核心演示**：条件概率如何在已知位置间传播  

![](https://cdn.luogu.com.cn/upload/pic/5484.png)  
*图：像素网格与矩阵计算同步演示*

### 动画步骤
1. **场景初始化**：
   - 左侧：竖向游戏局网格（0~n+1），未知局灰色，已知局金框
   - 右侧：线段树结构，节点显示2x2矩阵值
   - 控制面板：速度滑块/单步/暂停

2. **添加已知位置**（如位置3获胜）：
   - 网格：位置3变为金框+红色块，播“叮”声
   - 线段树：更新位置3的矩阵（高亮节点）
   - 概率传播：红色从位置2向3流动（粒子效果）

3. **矩阵计算过程**：
   - 查询区间[1,5]：高亮线段树对应节点
   - 矩阵乘法：显示`pri`和`sum`矩阵计算过程
   - 结果展示：在网格上方更新总期望值

4. **游戏化元素**：
   - 音效：矩阵乘法时“滴”，错误操作时短促提示音
   - 关卡：每完成10局传播，出现8-bit胜利动画
   - 实时数据：当前区间概率/期望值显示在网格右侧

**设计意义**：通过像素动画将抽象的概率传播具象化，帮助理解矩阵如何压缩概率状态。

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握条件期望的动态维护后，可解决以下问题：

1. **洛谷 P4213**  
   *期望线性性+区间贡献分解*  
   **推荐理由**：巩固期望线性分解思想

2. **洛谷 P3830**  
   *条件概率+树形结构动态维护*  
   **推荐理由**：将线段树拓展到树形结构

3. **洛谷 P2221**  
   *马尔可夫链+动态修改期望*  
   **推荐理由**：强化概率转移的矩阵优化

---

## 7. 学习心得与经验分享

<insights_intro>
> **经验摘录（题解1）**：  
> *“矩阵设计需兼顾数学意义与代码效率——双矩阵结构将期望求和融入矩阵乘法，避免暴力枚举”*  
> **Kay点评**：深刻体现了“用数据结构表达数学模型”的算法设计哲学

---

<conclusion>
本次分析带大家领略了概率期望问题的动态维护之美。记住：马尔可夫链问题中，矩阵是压缩状态转移的利器，而贝叶斯公式是处理条件概率的钥匙。继续在算法的世界里探索吧！🚀  
</conclusion>
```

---
处理用时：187.02秒
# 题目信息

# [NOI2018] 你的名字

## 题目背景

实力强大的小 A 被选为了 ION2018 的出题人，现在他需要解决题目的命名问题。

## 题目描述

小 A 被选为了 ION2018 的出题人，他精心准备了一道质量十分高的题目，且已经把除了题目命名以外的工作都做好了。

由于 ION 已经举办了很多届，所以在题目命名上也是有规定的，ION 命题手册规定：每年由命题委员会规定一个小写字母字符串，我们称之为那一年的命名串，要求每道题的名字必须是那一年的命名串的一个非空连续子串，且不能和前一年的任何一道题目的名字相同。

由于一些特殊的原因，小 A 不知道 ION2017 每道题的名字，但是他通过一些特殊手段得到了 ION2017 的命名串，现在小 A 有 $Q$ 次询问：每次给定 ION2017 的命名串和 ION2018 的命名串，求有几种题目的命名，使得这个名字一定满足命题委员会的规定，即是 ION2018 的命名串的一个非空连续子串且一定不会和 ION2017 的任何一道题目的名字相同。

由于一些特殊原因，所有询问给出的 ION2017 的命名串都是某个串的连续子串，详细可见输入格式。

## 说明/提示

### 更多样例

更多样例请在附加文件中下载。

#### 样例 2

见附加文件中的 `name2.in` 与 `name2.ans`。

### 数据范围

::cute-table{tuack}

|测试点|$\vert S\vert \leq$　|$Q\leq $　|$\sum \vert T\vert \leq $ |询问限制　|其他限制|
|:-:|:-:|:-:|:-:|:-:|:-:|
|$1$|$200$|$200$|$40000$|对于所有询问有 $l = 1, r=\vert S\vert$|$T\leq 200$|
|$2$|$1000$|^|^|^|^|
|$3$|^|^|^|^|^|
|$4$|^|^|$5 \times 10^5$|^|无|
|$5$|^|^|^|^|^|
|$6$|$5 \times 10^5$|$1$|^|^|^|
|$7$|^|^|^|^|^|
|$8$|$10^5$|$10^5$|$2 \times 10^5$|^|^|
|$9$|^|^|^|^|字符串随机|
|$10$|$2 \times 10^5$|^|$4 \times 10^5$|^|无|
|$11$|^|^|^|^|字符串随机|
|$12$|$3 \times 10^5$|^|$6 \times 10^5$|^|无|
|$13$|^|^|^|^|字符串随机|
|$14$|$4 \times 10^5$|^|$8 \times 10^5$|^|无|
|$15$|^|^|^|^|字符串随机|
|$16$|$5 \times 10^5$|^|$10^6$|^|无|
|$17$|^|^|^|^|字符串随机|
|$18$|$2 \times 10^5$|^|^|无|无|
|$19$|$3 \times 10^5$|^|^|^|^|
|$20$|$4 \times 10^5$|^|^|^|^|
|$21$|$5 \times 10^5$|^|^|^|^|
|$22$|^|^|^|^|^|
|$23$|^|^|^|^|^|
|$24$|^|^|^|^|^|
|$25$|^|^|^|^|^|

对于所有数据，保证 $1\leq l \leq r \leq |S|$，$1\leq |T|\leq 5 \times 10^5$

感谢 @Wen_kr 提供的一组 hack 数据。

## 样例 #1

### 输入

```
scbamgepe
3
smape 2 7
sbape 3 8
sgepe 1 9```

### 输出

```
12
10
4```

# AI分析结果


### 题目分析
题目要求对于多个查询，计算给定字符串T中本质不同的子串中，不在S的指定区间[l, r]内出现的子串数量。核心思路是计算T的所有本质不同子串数量，然后减去在S[l..r]中出现的子串数量。

### 核心算法与数据结构
1. **后缀自动机（SAM）**：
   - 对S建立SAM，用于高效处理子串匹配。
   - 对每个T建立SAM，用于计算本质不同子串数量。

2. **线段树合并**：
   - 维护S的SAM中每个节点的endpos集合，支持快速查询区间[l, r]内是否存在endpos。

3. **双指针匹配**：
   - 在S的SAM上匹配T，计算T每个前缀的最长匹配后缀长度（lim数组）。

### 关键步骤
1. **预处理S的SAM**：
   - 构建S的SAM，记录每个节点的endpos。
   - 使用线段树合并预处理endpos集合（支持区间查询）。

2. **处理每个查询**：
   - **匹配阶段**：
     - 初始化：当前节点p=1，匹配长度cur=0。
     - 遍历T的每个字符：
       - 尝试沿S的SAM转移，检查转移后节点在[l+cur, r]内是否有endpos。
       - 若成功转移，cur加1；否则减少cur，必要时跳parent树。
     - 记录lim[i]（T[1..i]的最长匹配后缀长度）。
   - **构建T的SAM**：
     - 构建T的SAM，记录每个节点的结束位置（tag）。
     - 分裂节点时继承原节点的tag。
   - **计算答案**：
     - 遍历T的SAM节点，对每个节点计算未被覆盖的子串数量：
       `max(0, len[i] - max(len[link[i]], lim[tag[i]]))`
     - 累加所有节点的贡献。

### 复杂度分析
- **预处理**：O(|S| log |S|)（SAM构建和线段树合并）。
- **每个查询**：O(|T| log |S|)（匹配和SAM构建）。
- 总复杂度：O(|S| log |S| + Σ|T| log |S|)，满足题目要求。

### 可视化算法设计
设计一个像素风格的动画演示，模拟T在S的SAM上匹配过程：
- **场景**：8位像素网格，左侧为S的SAM（节点为像素方块），右侧为T的字符流。
- **动画步骤**：
  1. **初始化**：S的SAM节点按深度排序，endpos用不同颜色标记。
  2. **字符匹配**：
     - T的字符逐个进入，尝试在S的SAM上转移。
     - 成功转移时播放"叮"音效，节点高亮；失败时播放"噗"音效。
  3. **线段树查询**：
     - 显示线段树查询过程，高亮查询区间[l+cur, r]。
  4. **结果计算**：
     - 在T的SAM上显示每个节点的贡献，最终答案用像素数字展示。
- **交互控制**：支持单步执行、调速和重置。

### 精选题解对比
1. **shadowice1984（93赞）**：
   - 使用线段树合并维护endpos，详细描述匹配过程。
   - 在T的SAM上利用节点结束位置计算答案。
2. **mrsrz（56赞）**：
   - 使用后缀数组和主席树，拼接S和T后处理。
   - 通过二分和height数组求最长匹配前缀。
3. **bztMinamoto（41赞）**：
   - 类似shadowice1984，代码清晰，强调边界处理。
4. **zhengrunzhe（31赞）**：
   - 转化为二维偏序问题，用线段树维护。

### 结论
**最优解法**：后缀自动机+线段树合并（shadowice1984方案）。其优势在于：
- 理论复杂度与代码简洁性平衡。
- 充分利用SAM特性处理子串匹配。
- 线段树合并高效维护endpos集合。

### 拓展练习
1. **相似问题**：
   - **P3975 [TJOI2015]弦论**：SAM求字典序第K小子串。
   - **P4094 [HEOI2016/TJOI2016]字符串**：二分+线段树合并求最长公共子串。
   - **P5341 [TJOI2019]甲苯先生和大中锋的字符串**：SAM统计子串出现次数。

2. **洛谷推荐**：
   - **P3804（模板）后缀自动机**：巩固SAM基础。
   - **P3975（相似）**：拓展SAM应用。
   - **P4094（进阶）**：强化线段树合并与SAM结合。

### 学习心得
题解中多位作者分享了调试经验：
- **边界处理**：特别注意l, r对匹配的影响（如hack数据"vwv"）。
- **复杂度优化**：跳parent树时避免冗余操作。
- **去重技巧**：利用T的SAM节点信息高效计算本质不同子串。

### 代码实现要点
```cpp
// 核心代码框架
void solve_query(string T, int l, int r) {
    // Step 1: 匹配T得到lim数组
    int p = 1, cur = 0;
    vector<int> lim(T.length());
    for (int i = 0; i < T.length(); i++) {
        while (true) {
            if (转移存在且endpos在[l+cur, r]内) {
                p = ch[p][c]; cur++; break;
            }
            if (cur == 0) break;
            cur--;
            if (cur == len[link[p]]) p = link[p];
        }
        lim[i] = cur;
    }

    // Step 2: 构建T的SAM
    SAM_T.build(T);
    // Step 3: 计算答案
    ll ans = 0;
    for (auto node : SAM_T.nodes) {
        int pos = node.tag;
        int cover_len = max(node.link_len, lim[pos]);
        ans += max(0, node.len - cover_len);
    }
    return ans;
}
```

---
处理用时：215.94秒
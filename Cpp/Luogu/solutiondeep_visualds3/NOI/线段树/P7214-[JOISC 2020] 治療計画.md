# 题目信息

# [JOISC 2020] 治療計画

## 题目背景

因为本题数据点过多，另外 $3$ 组数据请在 [这里](https://www.luogu.com.cn/problem/U127700) 测试。

JOI 村庄的村民们最近发生了 COVILLAGE-19 疫情！

## 题目描述

JOI 村庄有 $N$ 个房屋，编号为 $1$ 到 $N$，每个房屋住有一个村民，第 $i$ 个房屋居住编号为村民 $i$。

现在，这 $N$ 个房屋里的村民全部感染 COVILLAGE-19 病毒，有 $M$ 个治疗方案被提出，第 $i$ 个治疗方案描述为，在第 $T_i$ 天的晚上，编号在 $[L_i,R_i]$ 区间内的村民被治愈。

COVILLAGE-19 病毒还会继续传播，在某天早上，如果村民 $i$ 被感染，那么村民 $i+1$ 和村民 $i-1$ 也会被感染，因为病毒威力巨大，所以被治愈的村民有可能再次被感染。

您是 JOI 国的总理，您要选择一些方案使得 JOI 村庄所有村民全部被治愈，一天可以进行很多方案。

第 $i$ 个方案要花费 $C_i$，求最小花费。

## 说明/提示

#### 样例 1 解释

执行过程如下（红色为被病毒感染，绿色为治愈）：

1. 在第二天晚上，执行第 $1$ 个方案，情况如下：

$$\color{Red}1\ 2\ 3\ 4\color{Green}\ 5\ 6\ 7\ 8\ 9\ 10$$

2. 在第三天早上，村民 $5$ 被感染，情况如下：

$$\color{Red}1\ 2\ 3\ 4\ 5\color{Green}\ 6\ 7\ 8\ 9\ 10$$

3. 在第四天早上，村民 $6$ 被感染，情况如下：

$$\color{Red}1\ 2\ 3\ 4\ 5\ 6\color{Green}\ 7\ 8\ 9\ 10$$

4. 在第四天晚上，执行第 $5$ 个方案，情况如下：

$$\color{Green}1\ 2\ 3\color{Red}\ 4\ 5\ 6\color{Green}\ 7\ 8\ 9\ 10$$

5. 第五天早上，村民 $3,7$ 被感染，情况如下：

$$\color{Green}1\ 2\color{Red}\ 3\ 4\ 5\ 6\ 7\color{Green}\ 8\ 9\ 10$$

6. 在第五天晚上，执行第 $3$ 个方案，情况如下：

$$\color{Green}1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ 10$$

全部治愈，这三个方案花费为 $7$，为最小花费。

#### 样例 2 解释

无法使得所有村民全部治愈。

#### 子任务

|子任务|特殊性质|分数|
|:-:|:-:|:-:|
|$1$|$T_i=1$|$4$|
|$2$|$M \le 16$|$5$|
|$3$|$M \le 5000$|$30$|
|$4$|无|$61$|

对于 $100\%$ 的数据，$1 \le N,T_i,C_i \le 10^9$，$1 \le M \le 10^5$，$1 \le L_i \le R_i \le N$。

#### 说明

翻译自 [第１９回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) [Day4 C 治療計画](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day4/capital_city.pdf)。

## 样例 #1

### 输入

```
10 5
2 5 10 3
1 1 6 5
5 2 8 3
7 6 10 4
4 1 3 1```

### 输出

```
7```

## 样例 #2

### 输入

```
10 5
2 6 10 3
1 1 5 5
5 2 7 3
8 6 10 4
4 1 3 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
10 5
1 5 10 4
1 1 6 5
1 4 8 3
1 6 10 3
1 1 3 1```

### 输出

```
7```

# AI分析结果


# 💡 Kay的C++算法解析：治療計画 深入学习指南 💡

**引言**  
今天我们来分析「治療計画」这道C++编程题。本指南将帮助大家理解如何通过图论建模解决复杂的防疫调度问题，掌握线段树优化最短路的技巧，并通过生动的像素动画直观感受算法流程。

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**最短路优化**与**线段树应用**  

🗣️ **初步分析**：  
> 想象病毒传播如同不断扩张的火焰，治疗方案则是消防员在不同时间点扑灭火势。关键在于选择消防员的**出动顺序**，使得扑灭区域能**无缝衔接**覆盖整个村庄。  
> - 核心思路：将每个治疗方案视为图节点，若方案A完成后病毒传播范围能被方案B覆盖，则建边A→B，最终转化为**带权最短路问题**  
> - 难点在于直接建图会导致O(n²)边数 → 用线段树维护**时空衔接条件**（rᵢ±tᵢ ≥ lⱼ±tⱼ）  
> - 可视化设计：像素网格中彩色方块表示治疗区域，三角形扩散表示病毒传播，音效标记关键操作（"叮"=入队，"胜利"=覆盖完成）  

---

## 2. 精选优质题解参考

**题解一（George1123）**  
* **点评**：  
  思路清晰地将治疗方案抽象为节点，精准定义边条件 `rᵢ-lⱼ+1≥|tᵢ-tⱼ|`。代码中亮点：  
  - 双线段树分别处理 `tᵢ>tⱼ` 和 `tᵢ<tⱼ` 两种情况  
  - 用 `fix()` 初始化节点属性，`adde()` 实现势能松弛  
  - 边界处理严谨（`iinf*2` 防溢出）  

**题解二（xht）**  
* **点评**：  
  创新性地用二维坐标系解释治疗方案覆盖区域（等腰直角三角形），提出**点权最短路可单次松弛**的核心性质。代码特色：  
  - 两棵线段树分别维护 `l-t` 和 `l+t` 属性  
  - `set<pi>` 存储未松弛节点，删除即松弛  
  - 时间复杂度严格O(n log n)  

**题解三（7KByte）**  
* **点评**：  
  直击问题本质——治疗方案拼接等价于最短路，指出与经典题P5471的共性。亮点：  
  - 用单棵线段树同时处理两种衔接条件  
  - `update()` 函数中 `op` 参数优雅区分时间大小关系  
  - 代码模块化（`build/modify/update` 分工明确）  

---

## 3. 核心难点辨析与解题策略

1. **难点：时空衔接条件建模**  
   * **分析**：判断方案i→j可行的核心条件是 `rᵢ-lⱼ+1 ≥ |tᵢ-tⱼ|`，需拆解为：  
     - 当 `tᵢ≥tⱼ` 时：`rᵢ-tᵢ ≥ lⱼ-tⱼ-1`  
     - 当 `tᵢ<tⱼ` 时：`rᵢ+tᵢ ≥ lⱼ+tⱼ-1`  
   * 💡 **学习笔记**：绝对值拆解是优化建图的关键突破口  

2. **难点：避免O(n²)建图**  
   * **分析**：利用点权最短路特性——每个点只松弛一次。线段树维护未松弛节点的最小属性值：  
     - 属性1：`lⱼ-tⱼ`（对应 `tᵢ≥tⱼ` 松弛）  
     - 属性2：`lⱼ+tⱼ`（对应 `tᵢ<tⱼ` 松弛）  
   * 💡 **学习笔记**：线段树不仅是查询工具，更是松弛过程的调度器  

3. **难点：边界初始化与结果整合**  
   * **分析**：  
     - 起点：所有覆盖左端（lᵢ=1）的方案初始入队  
     - 终点：取所有覆盖右端（rᵢ=n）的方案最小代价  
     - 特判：若终点未被更新输出-1  
   * 💡 **学习笔记**：问题转化为"从1覆盖到n"的路径搜索  

### ✨ 解题技巧总结
- **降维打击**：将时空二维问题转化为一维属性（l±t）管理  
- **懒删除优化**：线段树中松弛后立即置∞避免重复访问  
- **双属性分治**：用独立数据结构分别处理时间先后关系  

---

## 4. C++核心代码实现赏析

**通用核心实现（基于George1123优化）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5;
const ll linf=0x3f3f3f3f3f3f3f3f;

int m,n;
ll f[N];
struct Plan{ int t,l,r,c; } a[N];

struct SegmentTree {
    // 树结构：维护l-t和l+t最小值
    void fix(int i,int a,int b) { /* 更新节点属性 */ }
    void adde(int x,int y,int mx,bool t) { /* 势能松弛 */ }
};

int main() {
    cin>>m>>n;
    for(int i=0;i<n;i++) cin>>a[i].t>>a[i].l>>a[i].r>>a[i].c;
    sort(a,a+n,[](Plan x,Plan y){return x.t<y.t;});

    SegmentTree st;
    for(int i=0;i<n;i++) {
        if(a[i].l==1) { 
            f[i]=a[i].c; 
            q.push({-f[i],i});
            st.fix(i, INT_MAX, INT_MAX); // 已松弛节点置∞
        } else {
            st.fix(i, a[i].l-a[i].t, a[i].l+a[i].t);
        }
    }

    // Dijkstra主循环
    while(q.size()) {
        int u=q.top().second; q.pop();
        st.adde(0, u, a[u].r-a[u].t, true);   // 向前松弛
        st.adde(u+1,n,a[u].r+a[u].t,false);   // 向后松弛
    }

    ll ans=linf;
    for(int i=0;i<n;i++) 
        if(a[i].r==m) ans=min(ans,f[i]);
    cout<<(ans==linf ? -1 : ans);
}
```
**代码解读概要**：  
1. 输入后按时间排序治疗方案  
2. 初始化：覆盖左端的方案代价=cᵢ，其余方案代价=∞  
3. Dijkstra主循环：用线段树寻找可松弛节点  
4. 结果取所有覆盖右端方案的最小代价  

---

**题解片段赏析**  

**George1123 - 双树分治**  
```cpp
void adde(int x,int y,int mx,bool t) {
    if((t?ma:mb)>mx) return;
    if(r-l==1) { 
        adj.pb(l); // 找到可松弛节点
        ma=mb=iinf*2; 
    }
    // 递归左右子树
}
```
**亮点**：用布尔参数`t`切换两种松弛条件  
**学习笔记**：通过递归实现"松弛即删除"，确保O(n log n)复杂度  

**xht - 集合管理未松弛点**  
```cpp
struct T {
    int l,r;
    set<pi> s; // (属性值, 节点ID)
};
void upd(T *t, int p, int l, int r, int x, ll k) {
    while(t[p].s.size() && t[p].s.begin()->fi <= x) {
        int y=t[p].s.begin()->se;
        d[y]=k+a[y].c; // 松弛操作
        q.push({-d[y],y});
        t[p].s.erase(t[p].s.begin());
    }
}
```
**亮点**：`set`自动排序属性值，快速定位可松弛节点  
**学习笔记**：集合删除操作天然避免重复松弛  

**7KByte - 单树双属性**  
```cpp
void update(int p,int fl,int fr,int op,int v,int w){
    if(t[p].mn[op]>v) return;
    if(t[p].l==t[p].r){
        f[t[p].l]=w+a[t[p].l].c;
        q.push({f[t[p].l],t[p].l});
        t[p].mn[0]=t[p].mn[1]=INF; // 删除节点
    }
    // 递归子树
}
```
**亮点**：用`op`参数索引两种属性（0:l-t, 1:l+t）  
**学习笔记**：单树实现简化代码结构  

---

## 5. 算法可视化：像素动画演示

**主题**：**「病毒防御大作战」**（复古像素塔防风格）  

**核心演示**：  
1. 网格纵轴=时间，横轴=房屋编号  
2. 治疗方案显示为**绿色矩形**（治疗时刻覆盖区域）  
3. 病毒扩散显示为**红色三角形**（沿45°方向扩张）  
4. 成功衔接显示**金色闪光**+“叮”音效，最终覆盖播放胜利音乐  

**交互设计**：  
```plaintext
控制面板：
  [▶] 开始/暂停   [→] 单步执行   [↔] 速度调节
  [AI] 自动演示（贪吃蛇式自动寻路）

帧序列说明：
1. 初始化：像素网格（FC风格），左侧控制面板
2. 方案激活：绿色方块从(Lᵢ,Tᵢ)平铺到(Rᵢ,Tᵢ)
3. 病毒扩散：红色像素沿45°方向扩张（每帧+1格）
4. 松弛触发：当红色区域触及新方案的绿色方块时：
   - 显示金色闪光边框
   - 播放“叮”音效
   - 新方案绿色方块亮起
5. 完全覆盖：当绿色从1延伸到n：
   - 网格全部变绿闪烁
   - 播放胜利音效（马里奥过关）
   - 显示"Cost: XX"分数

技术实现：
- 画布：HTML5 Canvas绘制像素网格
- 动画：requestAnimationFrame逐帧渲染
- 音效：Web Audio API播放8-bit音效
  * 扩散：低频脉冲波
  * 衔接：中频方波
  * 胜利：上升琶音
```

---

## 6. 拓展练习与相似问题思考

**技巧迁移场景**：  
1. 时空覆盖问题（如卫星调度观测）  
2. 带状态衔接的序列决策问题  
3. 需绝对值拆解的优化问题  

**推荐练习**：  
1. **洛谷 P5471** - 弹跳  
   🗣️ *推荐理由*：同属线段树优化最短路，强化时空坐标映射  
2. **洛谷 P3645** - 动态最小生成树  
   🗣️ *推荐理由*：训练线段树维护动态属性的思维  
3. **洛谷 P4197** - 峰巢  
   🗣️ *推荐理由*：将六边形网格转化为二维坐标处理  

---

## 7. 学习心得与经验分享

> **参考经验 (George1123)**：  
> *"注意∞的大小和long long问题，卡了2小时边界"*  
>   
> **Kay点评**：  
> 数据范围（10⁹）与无穷大设置是核心陷阱：  
> 1. 用 `0x3f3f3f3f3f3f3f3f` 避免 `INT_MAX` 溢出  
> 2. `long long` 统一防止乘法溢出  
> 3. 测试时构造 `n=1` 边界数据验证  

---

**结语**  
通过本次分析，我们掌握了将复杂时空问题转化为最短路模型的思维，以及线段树优化建图的精妙实现。记住：好的算法设计如同精密的时钟，每个齿轮（数据结构）都要严丝合缝！下次遇到类似问题，不妨先画图建模，再思考优化可能。💪

---
处理用时：143.19秒
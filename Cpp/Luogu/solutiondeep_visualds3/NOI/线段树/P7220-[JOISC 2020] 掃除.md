# 题目信息

# [JOISC 2020] 掃除

## 题目背景

JOISC2020 Day 1 T3

由于数据点较多，本题只评测其中的部分数据。

希望获得完整数据的可以到[这里](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day1/sweeping-data.zip)自行下载。

## 题目描述

由于 Bitaro AK 了 IOI，所以 IOI 主办方送了他一套房子，为一个边长为 $N$ 的等腰直角三角形。房间内一点用坐标 $(x,y)$ 表示，其中 $0\leq x+y\leq N$。直角顶点为原点，三角形两腰分别为 $x$ 轴与 $y$ 轴。

![](https://cdn.luogu.com.cn/upload/image_hosting/3m2wdn4u.png)

一天，Bitaro 发现自己已经 AK 了 1919810 届 IOI 闲的没事做准备打扫房间里的灰尘。这些灰尘一开始一共有 $M$ 堆，其中第 $i$ 堆位于 $(X_i,Y_i)$。同时，可能存在多堆灰尘位于同一个位置上的情况。

现在 Bitaro 准备用扫帚打扫房间。我们认为扫帚是放置在房间里的一条线段，并且将这条线段的长度称为扫帚的宽度。由于 Bitaro 很有条理，所以他只会用以下的两种方式打扫房间：

- Bitaro 将扫帚平行于 $y$ 轴放置，一端位于原点。然后他会垂直向右移动扫帚，直到不能移动为止。如果扫帚的宽度为 $l$，那么原来一堆满足 $x<N-l,y\leq l$ 的灰尘 $(x,y)$ 将会被移动到 $(N-l,y)$。（这个位置可能会存在多堆灰尘）我们称这个过程为过程 H。

- Bitaro 将扫帚平行于 $x$ 轴放置，一端位于原点。然后他会水平向上移动扫帚，直到不能移动为止。如果扫帚的宽度为 $l$，那么原来一堆满足 $x\leq l,y<N-l$ 的灰尘 $(x,y)$ 将会被移动到 $(x,N-l)$。（这个位置可能会存在多堆灰尘）我们称这个过程为过程 V。

在 Bitaro 的房间里，依次会发生 $Q$ 个事件。第 $i$ 个事件形如以下 $4$ 种：

- Bitaro 想要计算第 $P_i$ 堆灰尘的位置坐标；

- Bitaro 使用宽度为 $L_i$ 的扫帚，进行了过程 H；

- Bitaro 使用宽度为 $L_i$ 的扫帚，进行了过程 V；

- 有一堆新的灰尘出现在点 $(A_i,B_i)$ 处。如果在这个事件之前一共有 $c$ 堆灰尘，那么这堆灰尘就是房间中的第 $c+1$ 堆灰尘。

由于 Bitaro 已经 AK 了 IOI，啥都不想干，所以你需要写一个程序，给出房间的腰长，每一堆灰尘的位置坐标和每个事件的细节，求出要求的某堆灰尘的位置坐标。

## 说明/提示

### 样例 1 解释

一开始第一堆灰尘位于 $(1,1)$，第二堆灰尘位于 $(4,0)$。图一描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/8e305ll6.png)

在第一个事件中，添加了 $(2,3)$ 位置上的第三堆灰尘。图二描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/wili6lmg.png)

在第二个事件中，Bitaro 用宽度为 $3$ 的扫帚进行了过程 V。之后，第一堆灰尘移动到了 $(1,3)$，图三描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/x5x5nsvb.png)

在第三个事件中，Bitaro 计算了第一堆灰尘的坐标 $(1,3)$。

在第四个事件中，添加 $(1,2)$ 位置上的第四堆灰尘。图四描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/sxqf521x.png)

在第五个事件中，Bitaro 用宽度为 $3$ 的扫帚进行了过程 H，第一堆灰尘移到了 $(3,3)$，第三堆灰尘移到了 $(3,3)$，第四堆灰尘移到了 $(3,2)$。图五描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/0lt0inff.png)

在第六个事件中，Bitaro 用宽度为 $0$ 的扫帚进行了过程 H，第二堆灰尘移到了 $(6,0)$。图六描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/wnv1lqz7.png)

在第七个事件中，Bitaro 计算了第四堆灰尘的坐标 $(3,2)$。

在第八个事件中，Bitaro 用宽度为 $2$ 的扫帚进行了过程 V，然而什么都没有发生。图七描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/s4rebol9.png)

在第九个事件中，Bitaro 计算了第三堆灰尘的坐标 $(3,3)$。

在第十个事件中，Bitaro 计算了第二堆灰尘的坐标 $(6,0)$。

这组样例满足子任务 1 和子任务 5 的限制。

#### 样例 2~5 解释

第二组样例满足子任务 1,2,4,5 的限制。

第三组样例满足子任务 1,2,5 的限制。

第四组样例满足子任务 1,3,4,5 的限制。

第五组样例满足子任务 1,5 的限制。

#### 子任务

| 子任务编号 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| Subtask 1 | $m\leq 2\times 10^3,Q\leq 5\times 10^3$ | $1$ |
| Subtask 2 | $T\in\{1,2,4\}$ | $10$ |
| Subtask 3 | $T\in\{1,2,3\},X_i\leq X_{i+1},Y_i\geq Y_{i+1}(1\leq i\leq m-1)$ | $11$ |
| Subtask 4 | $T\in\{1,2,3\}$ | $53$ |
| Subtask 5 | 无 | $25$ | 

对于 $100\%$ 的数据，$1\leq n\leq 10^9,1\leq m\leq 5\times 10^5,1\leq Q\leq 10^6$。保证：

- $0\leq X_i,Y_i\leq N,X_i+Y_i\leq N(1\leq i\leq m)$；

- $1\leq P_i\leq M^\prime(1\leq i\leq Q)$，其中 $M^\prime$ 表示事件 $i$ 发生时灰尘的堆数；

- $0\leq L_i\leq n-1(1\leq i\leq Q)$；

- $0\leq A_i,B_i\leq n,A_i+B_i\leq n(1\leq i\leq Q)$；

- 至少存在一个 $T_i=1$ 的事件。


## 样例 #1

### 输入

```
6 2 10
1 1
4 0
4 2 3
3 3
1 1
4 1 2
2 3
2 0
1 4
3 2
1 3
1 2```

### 输出

```
1 3
3 2
3 3
6 0```

## 样例 #2

### 输入

```
9 4 8
2 3
3 1
1 6
4 3
2 6
1 3
2 2
1 4
2 3
1 2
2 4
1 1```

### 输出

```
3 6
4 3
7 1
6 3```

## 样例 #3

### 输入

```
8 1 8
1 5
4 4 1
2 6
1 2
2 3
4 2 2
2 5
1 1
1 3```

### 输出

```
4 1
3 5
3 2```

## 样例 #4

### 输入

```
7 4 9
1 5
2 2
4 2
5 0
2 6
2 3
1 2
3 6
1 4
3 1
1 1
2 2
1 3```

### 输出

```
4 2
5 1
1 6
5 2```

## 样例 #5

### 输入

```
20 5 25
10 6
0 4
2 1
1 0
2 3
2 18
3 9
4 1 5
4 0 2
3 10
4 3 3
3 3
2 9
4 9 1
3 12
1 4
3 19
1 3
1 9
2 1
1 7
1 6
4 3 3
1 10
1 1
1 5
2 0
1 2
2 2
1 7```

### 输出

```
2 17
2 17
9 8
0 17
1 17
3 3
10 10
2 17
2 17
0 17```

# AI分析结果


### 💡 Kay的C++算法解析：掃除 深入学习指南 💡

**引言**  
今天我们一起分析「JOISC 2020 掃除」这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。题目要求维护等腰直角三角形房间内的灰尘点坐标，支持四种操作：查询坐标、水平扫除（H）、垂直扫除（V）、新增灰尘点。关键挑战在于高效处理动态扫除操作对坐标的影响。

---

### 1. 题目解读与核心算法识别

✨ **本题主要考察**：`离线分治 + 数据结构维护`  
（分类标签：分治/平衡树/线段树）

🗣️ **初步分析**：  
> 解决本题的核心在于**离线分治策略**，结合**平衡树/线段树维护动态坐标**。想象扫除操作像推箱子游戏：水平扫除（H）将低处的点向右推，垂直扫除（V）将左侧的点向上推，而分治算法如同将房间逐层划分成小区域分别处理。  
> - **题解思路对比**：  
>   - **jun头吉吉/周子衡**：线段树分治框架，在每个时间区间内用平衡树（FHQ Treap）维护灰尘点，处理扫除时合并满足条件的点。  
>   - **crashed**：几何分治矩形策略，将三角形递归划分为子矩形，用堆维护点集并下放操作。  
>   - **baka24**：坐标转换法，将点投影到斜边上形成区间，用线段树+平衡树维护区间端点。  
> - **核心难点**：动态处理扫除操作的相互影响（如H操作后V操作的范围变化），以及新增点导致的状态更新。  
> - **可视化设计**：  
>   - 用**8位像素风格**渲染三角形房间，灰尘点为彩色方块，扫帚为像素化图标。  
>   - 关键步骤高亮：扫除时显示受影响的灰尘块移动轨迹（如H操作：方块向右滑动至`x=n-l`），并播放"滑动音效"。  
>   - 分治过程可视化：递归划分时用不同颜色边框标记子区域，展示操作下放逻辑。  

---

### 2. 精选优质题解参考

**题解一（jun头吉吉）**  
* **点评**：思路清晰直击要害——**线段树分治+平衡树动态维护**。  
  - **思路**：离线操作后，按时间分治处理区间。用FHQ Treap维护灰尘点坐标，扫除操作时按条件分裂合并树节点，高效处理坐标更新。  
  - **代码亮点**：  
    - 利用`splitX/splitY`按坐标分裂平衡树，合并时打标记更新坐标。  
    - 首次被扫时间计算：倒序扫描操作，线段树维护最小影响时间。  
  - **实践价值**：代码模块化强（分治/平衡树/线段树分离），可直接用于竞赛，边界处理严谨。  

**题解二（crashed）**  
* **点评**：创新性**几何分治策略**，将三角形递归划分为矩形子区域。  
  - **思路**：每个分治矩形内用堆维护点集。扫除操作时：  
    - 若影响当前区域（如H操作中`l<N-x`），将满足`y≤l`的点推入右侧子三角形。  
    - 否则更新坐标并下放操作到对应子区域。  
  - **亮点**：用并查集维护等价类（坐标相同的点合并），避免重复操作。  
  - **调试技巧**：作者强调用中间变量打印定位边界错误，值得学习。  

**题解三（baka24）**  
* **点评**：独特**坐标投影法**，将二维点转为斜边上的区间维护。  
  - **思路**：点`(x,y)`投影为区间`[x, n-y]`。扫除操作转化为区间端点更新：  
    - H操作：右端点`min(n-y, n-l)`  
    - V操作：左端点`max(x, l)`  
  - **亮点**：线段树节点内嵌平衡树，动态调整区间所属子树。  
  - **复杂度**：单次操作`O(log²n)`，适合理论理解但实现较复杂。  

---

### 3. 核心难点辨析与解题策略

**难点一：扫除操作的动态影响**  
- **问题**：H/V操作相互制约（如H操作后影响后续V操作的范围）。  
- **解决**：  
  - **分治框架**：将操作序列按时间分治，每个区间内静态处理（jun头吉吉）。  
  - **独立维护**：在分治区间内，用独立数据结构（平衡树/堆）处理操作，避免交叉影响。  

**难点二：新增点的动态插入**  
- **问题**：新增点可能位于历史操作影响范围内。  
- **解决**：  
  - **首次被扫时间**：计算新增点第一次受操作影响的时间（线段树倒序查询），延后处理（jun头吉吉）。  
  - **分治下放**：在递归子区间时动态插入点（crashed）。  

**难点三：大规模数据高效维护**  
- **问题**：`n≤1e9`禁止暴力，`q≤1e6`需低复杂度。  
- **解决**：  
  - **离散化**：将坐标映射到操作涉及的关键点（周子衡）。  
  - **惰性更新**：平衡树打标记延迟坐标更新（jun头吉吉）。  

✨ **解题技巧总结**  
- **离线分治优先**：将动态问题转为静态区间处理，降低复杂度。  
- **等价类合并**：坐标相同的点合并处理（并查集/平衡树合并）。  
- **边界特判**：扫除范围`l`需满足`0≤l≤n-1`，注意`x+y≤n`约束。  
- **调试技巧**：生成极端数据（如`l=0`或`l=n-1`），输出中间状态验证。  

---

### 4. C++核心代码实现赏析

**通用核心代码（基于jun头吉吉题解）**  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e6+5;

struct FHQTreap { /* 平衡树实现: splitX按x分裂, merge合并, pushtag更新坐标 */ };
struct SegTree { /* 线段树: 查询首次被扫时间 */ };

vector<Operation> ops;
vector<int> points[MAXN];
int ansX[MAXN], ansY[MAXN];

void solve(int l, int r, int dep) { // 分治主函数
    FHQTreap tree;
    // 1. 首次被扫时间计算（倒序扫描）
    // 2. 当前区间操作处理:
    //   - H操作: splitX分裂出x≤n-l的点 → 更新x坐标
    //   - V操作: splitY分裂出y≤n-l的点 → 更新y坐标
    //   - 新增点: 插入平衡树
    // 3. 查询: 记录当前坐标
    // 4. 递归子区间: solve(l,mid), solve(mid+1,r)
}

int main() {
    // 读入n,m,q
    // 离线存储所有操作
    solve(1, q, 1);
    // 输出查询答案
}
```

**关键代码片段赏析**  
1. **平衡树坐标更新（jun头吉吉）**  
   ```cpp
   void pushtag(int x, int tagx, int tagy) {
       if (~tagx) cur.x = tagx; // 水平扫除更新x
       if (~tagy) cur.y = tagy; // 垂直扫除更新y
   }
   void apply_H(int l) { // 水平扫除
       splitX(root, n-l, a, c); // 分裂出x≤n-l的点
       pushtag(a, n-l, -1);     // 更新x坐标
   }
   ```

2. **分治下放点集（crashed）**  
   ```cpp
   void pushSubRegion(int dir) { // 将点推入子三角形
       while (!heap.empty() && checkCondition()) {
           Point p = heap.top();
           sub[dir].push(p); // 下放至子区域
       }
   }
   ```

---

### 5. 算法可视化：像素动画演示

**设计概念**：  
- **8位像素风格**：三角形房间仿FC游戏界面，灰尘点用16x16像素方块表示，扫帚为动态像素图标。  
- **关键动画流程**：  
  1. **初始状态**：三角形网格房间，灰尘块随机分布（颜色区分）。  
  2. **扫除操作**：  
     - H操作：扫帚从底边向上移动至`y=l`，受影响的灰尘块向右滑动至`x=n-l`（轨迹高亮 + "滑动音效"）。  
     - V操作：扫帚从左向右移动，灰尘块向上滑动至`y=n-l`。  
  3. **分治过程**：房间分裂为子矩形（颜色渐变边框），展示操作下放逻辑。  
  4. **查询操作**：目标灰尘块闪烁，显示坐标标签。  

**交互控制面板**：  
- 步进控制：单步执行（▶️）、暂停（⏸️）、调速滑块（⚡）。  
- 模式切换：手动操作 / 自动演示（AI按时间顺序执行操作）。  
- 数据结构视图：实时显示平衡树结构（节点为灰尘坐标）。  

**技术实现**：  
```javascript
// 伪代码：Canvas绘制扫除动画
function drawSweep(type, l) {
    drawBroom(type, l); // 绘制扫帚
    let blocks = getAffectedBlocks(type, l); // 获取受影响的灰尘块
    blocks.forEach(block => {
        animateMove(block, type); // 移动动画（水平/垂直）
        playSound("sweep"); // 音效
    });
}
```

---

### 6. 拓展练习与相似问题思考

**通用技巧迁移**：  
1. **离线分治**：处理动态操作序列的利器，适用于：  
   - 带修改的区间查询（如区间第k大）  
   - 操作间有依赖关系的动态问题  
2. **平衡树维护区间**：  
   - 区间赋值（本题扫除操作）  
   - 区间合并/分裂（如动态连通性）  

**推荐练习（洛谷）**：  
1. **P5490【模板】扫描线**  
   - 💡 学习矩形面积并，掌握离散化+线段树  
2. **P1903【模板】动态区间第k大**  
   - 💡 分治应用：树套树或整体二分  
3. **P3384【模板】树链剖分**  
   - 💡 树形结构转线性序列，练习懒惰标记更新  

---

### 7. 学习心得与经验分享

> **来自 jun头吉吉 的调试经验**：  
> *"首次实现时在平衡树分裂条件判断出错，通过打印树结构和坐标变化中间态，发现未正确处理`l<0`的边界。建议对`l=0, l=n-1`单独测试。"*  
>   
> **Kay点评**：边界测试是调试核心！多组极端数据验证可避免90%的边界错误。  

> **来自 crashed 的优化心得**：  
> *"用并查集合并坐标相同的点，减少平衡树节点数，提速3倍。"*  
>   
> **Kay点评**：等价类合并是优化关键，尤其适用于大规模重复数据。  

---

### 结语  
本次掃除问题的核心在于**离线分治与高效数据结构的结合**。通过分治框架将动态操作静态化，平衡树维护坐标变化，即可优雅解决大规模动态维护问题。  

可视化动画和分步调试是理解算法的利器，动手实现代码后，不妨用像素动画模拟过程加深理解。下次我们将挑战更复杂的动态几何问题，继续加油！💪  

> 版权声明：本文解析基于多位作者的题解思路，由Kay整理提炼。代码实现请遵守竞赛规范。

---
处理用时：152.22秒
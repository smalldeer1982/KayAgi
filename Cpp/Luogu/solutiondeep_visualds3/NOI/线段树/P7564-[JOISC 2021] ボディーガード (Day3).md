# 题目信息

# [JOISC 2021] ボディーガード (Day3)

## 题目背景

因为数据包过大，所以请在 [此处](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day3/bodyguard-data.zip) 获取完整数据。

## 题目描述

在一条数轴上，有 $N$ 个人，他们都是书虫保镖公司的顾客，第 $i$ 个人会在第 $T_i$ 个时刻从第 $A_i$ 个位置移动到第 $B_i$ 个位置，他们的速度是每一个时刻一个单位长度。

如果一个保镖与一个顾客同时在一个位置上，就称保镖在保护这个顾客。设这个保镖从 $a$ 时刻开始保护一个顾客 $i$，从 $b$ 时刻停止保护，那么区间 $[a,b]$ 就称为这个顾客的保护时间，时刻 $a$ 称为保护开始时间，时刻 $b$ 称为保护停止时间。**其中 $a$ 和 $b$ 不必是整数**。特殊地，如果一个保镖与两个顾客同时在一个位置上，保镖只能保护一个顾客。

保镖可以在数轴上以最多每一个时刻一个单位长度最少静止不动的速度随意移动，当保镖停止保护一个顾客的时候，他可以到另一个位置上保护另一个顾客。如果一个保镖保护第 $i$ 个顾客一起走过的路径长度为 $L$，那么顾客 $i$ 将会以 $C_i$ 津巴布韦币每单位长度给这个保镖 $ L \times C_i$ 津巴布韦币作为他的工资。

书虫作为书虫保镖公司的老板，他手里紧握着 $Q$ 份策划保护的方案，其中，第 $j$ 个方案，一个保镖从时刻 $P_j$ 开始从第 $X_j$ 个位置出发开始进行工作。

求对于每个方案，每个保镖获得的总工资数量最多是多少津巴布韦币。

## 说明/提示

#### 样例 1 解释

- 保护方案 $1$ 中保镖可以按照下面的方式得到 $4+4=8$ 津巴布韦币：
	- 在时刻 $1$ 从 $2$ 位置开始行动。
    - 从时刻 $1$ 到时刻 $2$ 保护顾客 $1$，一起走过的路径长度为 $1$，得到 $4 \times 1=4$ 津巴布韦币。
    - 时刻 $2$ 到时刻 $3$ 停留在 $1$ 位置。
    - 从时刻 $3$ 到时刻 $5$ 保护顾客 $2$，一起走过的路径长度为 $2$，得到 $2 \times 2=4$ 津巴布韦币。
- 保护方案 $2$ 中保镖可以按照下面的方式得到 $2$ 津巴布韦币：
	- 在时刻 $3$ 从 $3$ 位置开始行动。
    - 时刻 $3$ 到时刻 $4$ 从 $3$ 位置移动到 $2$ 位置。
    - 从时刻 $4$ 到时刻 $5$ 保护顾客 $2$，一起走过的路径长度为 $1$，得到 $2 \times 1=2$ 津巴布韦币。

#### 样例 2 解释

- 保护方案 $1$ 中保镖可以按照下面的方式得到 $4+1+8+2=15$ 津巴布韦币：
	- 在时刻 $2$ 从 $2$ 位置开始行动。
    - 时刻 $2$ 到时刻 $2.5$ 从 $2$ 位置移动到 $2.5$ 位置。
    - 从时刻 $2.5$ 到时刻 $3.5$ 保护顾客 $2$，一起走过的路径长度为 $1$，得到 $4 \times 1=4$ 津巴布韦币。
    - 从时刻 $3.5$ 到时刻 $4$ 保护顾客 $1$，一起走过的路径长度为 $0.5$，得到 $2 \times 0.5=1$ 津巴布韦币。
    - 从时刻 $4$ 到时刻 $6$ 保护顾客 $3$，一起走过的路径长度为 $2$，得到 $4 \times 2=8$ 津巴布韦币。
    - 从时刻 $6$ 到时刻 $7$ 保护顾客 $1$，一起走过的路径长度为 $1$，得到 $2 \times 1=2$ 津巴布韦币。
- 保护方案 $2$ 中保镖无论怎么走都得不到工资，只能得到 $0$ 津巴布韦币。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（6 pts）：$T_i,A_i,B_i,P_j,X_j \le 3000$。
- Subtask 2（7 pts）：$Q=1$。
- Subtask 3（15 pts）：$Q \le 3000$。
- Subtask 4（20 pts）：$Q \le 4 \times 10^4$。
- Subtask 5（52 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le N \le 2800$，$1 \le Q \le 3 \times 10^6$，$1 \le T_i,A_i,B_i,C_i \le 10^9$，$A_i \ne B_i$，$C_i$ 为偶数，$1 \le P_j,X_j \le 10^9$。

#### 说明

翻译自 [第２０回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [Day3 B ボディーガード (Bodyguard) 的英文版本](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day3/bodyguard-en.pdf)。

## 样例 #1

### 输入

```
2 2
1 2 1 4
3 1 3 2
1 2
3 3```

### 输出

```
8
2```

## 样例 #2

### 输入

```
3 2
3 1 5 2
1 4 1 4
4 2 4 4
2 2
6 3```

### 输出

```
15
0```

## 样例 #3

### 输入

```
5 5
8 1 4 10
8 3 7 6
1 4 6 2
3 9 5 4
6 1 9 6
7 6
6 8
1 3
9 4
2 4```

### 输出

```
30
27
48
30
48```

# AI分析结果


### 💡 Kay的C++算法解析：[JOISC 2021] ボディーガード 深入学习指南 💡

**<introduction>**  
今天我们来分析JOISC 2021的保镖问题。这道题将时间和位置转化为二维平面，通过坐标系旋转和离散化技巧，结合动态规划和凸包优化，解决高难度路径规划问题。本指南将带你深入理解核心算法，掌握解题技巧！

---

### 1. 题目解读与核心算法识别  
✨ **本题主要考察**：`坐标系变换与动态规划优化`  

🗣️ **初步分析**：  
> 本题的核心是将时间-位置坐标系旋转45°（`(t,x) → (t-x, t+x)`），使斜率为±1的线段变为水平/垂直方向，简化计算。旋转后线段长度翻倍，工资计算需调整（$c_i \gets c_i/2$）。  
> - **离散化**：提取所有线段端点，排序去重构建$O(n^2)$网格图。  
> - **动态规划**：从网格右下到左上计算$dp[i][j]$（从点$(i,j)$出发的最大收益），转移方程为：  
>   $dp[i][j] = \max(dp[i+1][j] + v_x \cdot \Delta x,\ dp[i][j+1] + v_y \cdot \Delta y)$  
> - **非网格点处理**：起点到网格的路径收益是$k \cdot \text{dist} + \text{offset}$形式，用李超树/凸包维护极值。  
>  
> **可视化设计**：  
> 采用8-bit像素风格展示旋转后的网格（红/蓝线表顾客路径）。保镖移动时：  
> - 向右走：黄色路径 + "→"音效  
> - 向上走：紫色路径 + "↑"音效  
> 重合段闪烁金色，收益金币动画+胜利音效，AI模式自动展示最优路径。

---

### 2. 精选优质题解参考  
**题解一（harryzhr）**  
* **亮点**：  
  1. 三阶段清晰：旋转→离散化+DP→李超树查询  
  2. 输入输出优化处理$3 \times 10^6$查询  
  3. 变量命名规范（`vx/vy`表边权，`val`为DP数组）  
  4. 边界处理严谨（离散化严格映射）  

**题解二（Sol1）**  
* **亮点**：  
  1. 凸包替代李超树，$O(q \log n)$查询  
  2. 强调旋转坐标系的直观性  
  3. 单调栈维护函数极值，避免动态开点开销  

**题解三（Grisses）**  
* **亮点**：  
  1. 图文并茂解释旋转过程  
  2. 模块化代码（分离离散化/DP/查询）  
  3. 详细注释关键变量作用  

---

### 3. 核心难点辨析与解题策略  
1. **坐标系旋转的数学推导**  
   - **分析**：原坐标系$(t,x)$中斜率为±1的线段，旋转后变为水平/垂直，长度缩放$\sqrt{2}$倍，需重新计算收益公式。  
   - 💡 **学习笔记**：旋转公式$(x,y) \to (x-y,x+y)$是简化斜率的关键。

2. **DP状态的无后效性设计**  
   - **分析**：$dp[i][j]$必须从右下向左上逆序计算，确保转移时子问题已求解。边权$v_x/v_y$需预处理每条网格线的最大$c_i$。  
   - 💡 **学习笔记**：网格DP的转移方向需与扩展方向相反。

3. **非网格点路径的凸包优化**  
   - **分析**：起点到网格点路径收益是线性函数$f(x)=k\cdot x + b$。李超树直接维护，或凸包+二分求极值。  
   - 💡 **学习笔记**：凸包优化将查询复杂度从$O(\log n)$降至$O(\log \text{凸包大小})$。

---

### 4. C++核心代码实现赏析  
**通用核心实现（综合优化版）**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

struct LSH { // 离散化类
    vector<ll> xs;
    void add(ll x) { xs.push_back(x); }
    void build() { 
        sort(xs.begin(), xs.end()); 
        xs.erase(unique(xs.begin(), xs.end()), xs.end()); 
    }
    int operator()(ll x) { 
        return lower_bound(xs.begin(), xs.end(), x) - xs.begin(); 
    }
};

int main() {
    // 坐标系旋转
    for (auto &[t, a, b, c] : customers) {
        ll x1 = t - a, y1 = t + a; // (t,x) → (t-x, t+x)
        ll x2 = (t + abs(a-b)) - b, y2 = (t + abs(a-b)) + b;
        lx.add(x1); ly.add(y1); // 离散化关键点
    }
    
    // DP预处理网格收益
    for (int i = grid_x; i >= 0; i--) {
        for (int j = grid_y; j >= 0; j--) {
            dp[i][j] = max( 
                dp[i+1][j] + vx[i][j] * (lx[i+1] - lx[i]), 
                dp[i][j+1] + vy[i][j] * (ly[j+1] - ly[j])
            );
        }
    }
    
    // 凸包优化查询
    vector<Line> convex;
    for (int i = 0; i <= grid_x; i++) {
        while (convex.size() >= 2 && cross(convex.end()[-2], convex.back(), new_line))
            convex.pop_back(); // 维护凸包单调性
        convex.push_back({vx[i][j], dp[i][j]});
    }
    ll query = convex[lower_bound(convex.begin(), convex.end(), q_dist)].eval();
}
```

**题解一（harryzhr）片段赏析**：  
```cpp
namespace SGT { // 李超树
    void insert(int k, ll b) {
        while (top && calc(stk[top], mid) < calc({k,b}, mid)) 
            top--; // 淘汰劣势函数
        stk[++top] = {k, b};
    }
    ll query(ll x) {
        return stk[binary_search(x)].k * x + stk[...].b;
    }
}
// 应用：插入水平边权函数，查询起点到网格距离
```

---

### 5. 算法可视化：像素动画演示  
**复古像素风格设计**：  
```plaintext
1. 初始化：  
   - 16色像素网格（灰底+蓝/红顾客线段）  
   - 保镖起点：闪烁红色像素点  
   - 控制面板：开始/暂停/步进按钮 + 速度滑块  

2. DP计算过程：  
   - 右下角→左上角逐格计算  
   - 当前网格高亮绿色，显示dp[i][j]数值  
   - 边权vx/vy用颜色深度表示（深红=高收益）

3. 保镖移动：  
   - 向右走：→键控制，黄色路径，"blip"音效  
   - 向上走：↑键控制，紫色路径，"beep"音效  
   - 重合保护段：金色闪烁 + "coin"音效 + 金币计数增长  

4. AI演示模式：  
   - 自动沿凸包确定的最优路径移动  
   - 通关后播放8-bit胜利音乐
```

---

### 6. 拓展练习与相似问题思考  
1. **相似技巧迁移**：  
   - 旋转坐标系：处理斜率固定的线段交会  
   - 网格DP：路径规划问题（如迷宫最短路径）  
   - 凸包优化：维护线性函数极值  

2. **推荐练习**：  
   - 洛谷 P1904 天际线（离散化+扫描线）  
   - 洛谷 P5490 矩形并（李超树应用）  
   - 洛谷 P4553 80人环游世界（网格DP扩展）

---

### 7. 学习心得与经验分享  
> **题解作者经验**：  
> “调试时发现离散化映射错误导致$dp$转移混乱，需用`lower_bound`严格验证边界。旋转后负坐标需偏移处理。”  
>  
> **Kay总结**：  
> 1. 离散化前添加`LLONG_MIN/MAX`避免边界溢出  
> 2. 凸包插入函数时检查斜率单调性  
> 3. 大数据集优先凸包（空间优），李超树更通用  

**<conclusion>**  
本题融合计算几何与动态规划，通过坐标系旋转化归为网格问题，结合凸包优化处理路径查询。掌握离散化技巧和DP状态设计是解题关键。下次挑战见！💪  

---  
**可视化示例图**：  
![旋转坐标系](https://cdn.luogu.com.cn/upload/image_hosting/4287b8rd.png)  
*图：坐标系旋转45°后水平/垂直化路径*

---
处理用时：202.29秒
# 题目信息

# 移言丁真：Unavoided linyue

## 题目背景

**注：你不需要阅读此题题目背景。**

"$\textsf{linyue}$" 是我起过的唯一一个人名，所以 $\textsf{linyue}$ 成了唯一一个由我想象出来的角色。她是我脑海中所有故事的主角，对我而言非常地重要，以至于不知道为什么，每次我看到她的名字被写出来或是被读出来都会感到无所适从，所以我总是会想办法避免这样，比如说这个题的题面里我就用的是拼音作代替。

“跑团”这种游戏我最初了解的时候简直是“绝望地想要跟不管是谁玩随便什么”。可是疫情却让我的好多和同学玩的计划纷纷泡汤，所以我甚至走投无路到把它也纳入了计划的考虑范畴，不过由于它实在是太复杂了，没过多久我就把它抛诸脑后了（

“黑影杀”是一款在泞之翼官方交流群里兴起的游戏，玩家将会探索《泞之翼》原作的旅馆，躲避黑影以求逃出生天——对我而言没有比这更完美的事了！它完全实现了我上一段里的愿望，只要一有空，我便可以在群里“开鲨”！我给这个游戏准备了便于主持的程序，写了许多特殊规则，甚至还以它为背景出了题——尽管这题投到的比赛咕了（

《怪商一克拉》是一部我很喜欢的漫画。它的特点就是主角好像在每段故事里都只会最小程度地完成任务，然后哪怕这个故事还有好多未解之谜都只会跳到下一段故事。尽管这看起来像是没写好，但我相信这种效果作者是刻意为之。所以我期待着在未来看到这些故事的伏笔被精妙地解决，带来一个震撼的结局。可是有一天，我没有在漫画派对上看到这部漫画。这意味着以上就都不会发生了……我当时心态崩了好长时间，甚至都到泞之翼群里发癫了，不过事实上作者只是请了一个月假，接下来这漫画还会照常更新（

前两天，我终于又找到机会和同学出去玩了！这一次我们打算上一个主营镜土 TRPG 的店里试试跑团。要知道，这对我而言还是很有吸引力的，因为之前不管是玩什么，都是"我"在玩，跟 $\textsf{linyue}$ 没有什么关系。但要是玩跑团做角色卡的话，是不是就能填补这个遗憾了呢？所以这次我是有备而来！我提前十分费力地给 $\textsf{linyue}$ 画了一张简单的画，然后输入名字的时候，我决定不再回避——用她那两个汉字的真名，而非六个字母的替代。

然而，尽管我这一天听到和看到她名字的次数前所未有，但最后却并没什么很好的效果。我在游戏里确实是主打一个不入戏，对话内容有种全人类取平均的美，没推理出什么剧情的关键，也没想到什么新奇的点子。相信把我换成 Kimi AI 游戏绝对会更有趣……

——不过当然啦，这倒也在我意料之中，因为我知道我本来就非常非常不擅长这种角色扮演……看来对我而言，创造 $\textsf{linyue}$ 的故事会比别人更加困难。

所以我不会太受这个问题的困扰，一是因为习惯了，二是因为——我们出题组的比赛没过审。

![](https://cdn.luogu.com.cn/upload/image_hosting/7qwdep44.png)

“移言丁真”是这场比赛的原定 E 题之一，可是它被鉴定为了典……显然这最主要是我的锅。所以我现在的当务之急是要想一个新的 idea……

## 题目描述

定义一个括号串的权值为其中可配对的括号组数。也就是你重复地在里面删除掉某个为 ```()``` 的子串，最多可以删除的次数。

你会遇到 $m$ 个括号串，第 $i$ 个的长度是 $l_i$。你可以将它们按照任意顺序连接起来，然后连成一个长的括号串，而你的目标就是让最终的串的权值最小。

如果这 $m$ 个串是等概率随机生成的，而你的操作是最优的，请你求出最终权值的期望。也就是说你要对于初始括号串的所有可能性求出最小权值的和再除以 $2^n$，$n$ 为这些字符串的总长。对 $10^9+7$ 取模。

## 说明/提示

**【样例解释1】**

这里 $\{S_1,S_2\}$ 表示两个括号串构成的无序可重集合，$P$ 表示取到这样集合的概率。

| $\{S_1,S_2\}$ | $P$ | 最优方案 | 权值 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $\{$```((```$,$```((```$\}$ | $\frac{1}{16}$ | ```((((``` | $0$
| $\{$```((```$,$```()```$\}$ | $\frac{1}{8}$ | 任意 | $1$
| $\{$```((```$,$```)(```$\}$ | $\frac{1}{8}$ | ```)(((``` | $0$
| $\{$```((```$,$```))```$\}$ | $\frac{1}{8}$ | ```))((``` | $0$
| $\{$```()```$,$```()```$\}$ | $\frac{1}{16}$ | ```()()``` | $2$
| $\{$```()```$,$```)(```$\}$ | $\frac{1}{8}$ | 任意 | $1$
| $\{$```()```$,$```))```$\}$ | $\frac{1}{8}$ | 任意 | $1$
| $\{$```)(```$,$```)(```$\}$ | $\frac{1}{16}$ | ```)()(``` | $1$
| $\{$```)(```$,$```))```$\}$ | $\frac{1}{8}$ | ```)))(``` | $0$
| $\{$```))```$,$```))```$\}$ | $\frac{1}{16}$ | ```))))``` | $0$

最终答案为 $\dfrac{9}{16}$。

**【数据范围】**

令 $n$ 为 $l_i$ 的总和。

子任务 $1$（$20$ 分）: $n \le 20$。

子任务 $2$（$30$ 分）: $n \le 5000$。

子任务 $3$（$50$ 分）: $n \le 4000000$。

保证 $l_i \ge 1$。

**【后记】**

左括号和右括号可以是 $\textsf{linyue}$ 名字的第一个字和第二个字，也可以是一段故事的萌芽和结果。

下一次跑团遥遥无期，黑影杀渐渐无人问津，我们团的三个原定 E 题和其他好多好多的 idea 不知道何去何从，那些和 $\textsf{linyue}$ 有关的故事和设想更是也难以被呈现。有时我感觉自己就像是在《怪商一克拉》里一样，好多段经历都没等到自己的右括号，有种被最小化了权值的美。所以，我总是期待这些故事的伏笔被精妙地解决，带来最大的幸福。不过在这之前，我只好继续回避 “$\textsf{linyue}$” 了。

## 样例 #1

### 输入

```
2
2 2```

### 输出

```
62500001```

## 样例 #2

### 输入

```
5
1 2 3 4 5```

### 输出

```
762695321```

# AI分析结果


### 💡 Kay的C++算法解析：移言丁真 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：组合数学与期望计算  
🗣️ **初步分析**：  
> 本题核心是将括号串转化为格路模型（左括号为+1，右括号为-1），通过折线路径分析最小权值期望。解题关键有二：
> - **绝对差期望**：计算每个随机串左/右括号数差的绝对值期望 `E[|Δ|]`
> - **最大值期望**：计算所有串 `min(L_i, R_i)` 最大值的期望 `E[max(min)]`
> 
> **可视化设计思路**：  
> 采用8-bit像素风格模拟折线运动（如图）。关键动画元素：
> - 彩色像素块表示当前高度（绿色：安全区 >k；红色：危险区 ≤k）
> - 步进控制：单步执行键观察路径变化，终点高亮显示绝对差 `|Δ|`
> - 复古音效：路径触及 `y=-k` 时播放8-bit警示音，达成 `min≥k` 时播放胜利音效
> 
> **算法流程示例**（k=2）：  
> ① 初始化起点(0,0)  
> ② 路径不得低于 `y=-2`（红区）  
> ③ 终点高度≥2时计数有效  

---

#### 2. 精选优质题解参考
**题解一（DaiRuiChen007）**  
* **点评**：  
  思路清晰直击核心——将权值分解为 `E[Σ|Δ|] + 2E[max(min)]`。代码实现极简：  
  - 亮点1：组合数前缀和线性预处理（`fac[]/ifac[]`）  
  - 亮点2：概率乘积动态维护（`p[]`数组）  
  - 边界处理：`a_i`奇偶性分类讨论严谨  
  ⭐ 实践价值：可直接用于竞赛（42行高效实现）  

**题解二（隔壁泞2的如心）**  
* **点评**：  
  创新性使用指针跳跃优化：  
  - 亮点：对相同长度串批量处理（`r[a_i]++`）  
  - 可读性：`mut()`函数封装多元运算  
  ⚠️ 注意：组合数求和部分稍显复杂（需理解反射容斥）  

**题解三（EuphoricStar）**  
* **点评**：  
  亮点：独立推导出 `min≥k` 的组合数后缀和解法  
  ⚠️ 注意：实现中 `f[1..m]` 初始化逻辑需仔细验证  

---

#### 3. 核心难点辨析与解题策略
1. **难点：折线模型参数转化**  
   *分析*：需理解 `L_i/R_i` 的物理意义（起点/终点到最低点距离）。优质题解通过反射容斥将 `P(min≥k)` 转化为组合数求和  
   💡 学习笔记：`L_i + R_i = |Δ_i| + 2min(L_i,R_i)` 是权值分解基石  

2. **难点：max(min)的期望计算**  
   *分析*：利用 `E[X] = ΣP(X≥k)` 转化为概率乘积问题。DaiRuiChen007解法用动态维护乘积避免重复计算  
   💡 学习笔记：概率独立时 `P(all≤k) = Π P_i(≤k)`  

3. **难点：组合数后缀和优化**  
   *分析*：`P(min≥k)` 需计算形如 `Σ_{j≥k} C(n,j)` 的项。EuphoricStar解法用后缀数组 `g[]` 实现O(1)查询  
   💡 学习笔记：组合数后缀和可递推 `g[j]=g[j+1]+C(n,j)`  

✨ **解题技巧总结**：  
- **拆解期望**：将复杂期望拆为独立子问题（`|Δ|` 与 `max(min)`）  
- **概率转化**：`max` 期望化为概率乘积（`1 - Π(1-P_i)`）  
- **组合数优化**：预处理阶乘逆元+后缀和避免重复计算  

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**（综合自DaiRuiChen007与隔壁泞2的如心）：  
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=4e6+5, MOD=1e9+7, inv2=(MOD+1)/2;

ll fac[MAXN], ifac[MAXN], ipw[MAXN], p[MAXN];
ll C(int n, int m) { 
    return (m<0||m>n) ? 0 : fac[n]*ifac[m]%MOD*ifac[n-m]%MOD; 
}

int main() {
    int n, m=0; scanf("%d",&n);
    vector<int> a(n);
    for(int i=0; i<n; i++) 
        scanf("%d",&a[i]), m+=a[i];

    // 预处理阶乘/幂
    fac[0]=ipw[0]=1;
    for(int i=1;i<=m;i++) {
        fac[i]=fac[i-1]*i%MOD;
        ipw[i]=ipw[i-1]*inv2%MOD;
    }
    ifac[m]=1; for(int i=m;i>=1;i--) ifac[i-1]=ifac[i]*i%MOD;

    // 计算E[Σ|Δ|]
    ll E_abs=0;
    for(int len:a) {
        for(int k=0; k<=len; k++) // |2k-len|=|Δ|
            E_abs=(E_abs + abs(2*k-len)*C(len,k)%MOD*ipw[len])%MOD;
    }

    // 初始化概率数组
    for(int i=0;i<=m;i++) p[i]=1;
    for(int len:a) {
        // 组合数后缀和 g[j]=Σ_{i=j}^{len} C(len,i)
        vector<ll> g(len+2,0);
        for(int i=len; i>=0; i--) 
            g[i]=(g[i+1]+C(len,i))%MOD;

        // 更新P(min<=k) = 1 - P(min>k)
        for(int k=0; k*2<=len; k++) {
            ll P_k = g[(len+1)/2 + k]; // P(min>k)
            if((len+1)&1) P_k = (P_k + C(len, len/2+k)) % MOD;
            P_k = P_k * ipw[len] % MOD;
            p[k] = p[k] * (1 - P_k + MOD) % MOD;
        }
    }

    // 计算E[max(min)] = Σ(1-p[k])
    ll E_max=0;
    for(int k=0; k<=m; k++) 
        E_max=(E_max + 1 - p[k] + MOD) % MOD;

    // 最终权值 = (n - E_abs - 2*E_max)/2
    ll ans = (m - E_abs - 2*E_max % MOD + MOD*2) % MOD;
    ans = ans * inv2 % MOD;
    printf("%lld\n",ans);
}
```
**代码解读概要**：  
1. **预处理工具**：`fac[]/ifac[]` 加速组合数计算，`ipw[]` 存储 `(1/2)^i`  
2. **E[Σ|Δ|]**：枚举每个串左括号数 `k`，累加 `|2k-len|*C(len,k)/2^len`  
3. **概率乘积**：对每个 `k` 维护 `p[k]=Π_i P(min_i≤k)`  
4. **组合数优化**：`g[]` 后缀和数组避免重复计算二项式系数  

---

#### 5. 算法可视化：像素动画演示
![](https://cdn.luogu.com.cn/upload/image_hosting/pgdb4op3.png)  
* **主题**：8-bit风格折线探险  
* **核心演示**：  
  ① **初始化**：网格坐标系（x:字符位置，y:括号高度）  
  ② **步进控制**：  
     - 左括号→像素块上移（↑音效）  
     - 右括号→像素块下移（↓音效）  
  ③ **关键逻辑**：  
     - 红线标记 `y=-k`，路径触及时闪烁+警报音  
     - 终点高度≥k时播放胜利音效+像素烟花  
  ④ **AI演示模式**：自动展示最优路径（速度可调）  

* **技术实现**：  
  - Canvas绘制：每个字符位置渲染16x16像素块  
  - 状态同步：右侧面板实时显示 `当前min(L,R)` 和 `|Δ|`  
  - 伪代码高亮：与动画同步显示组合数计算关键行  

---

#### 6. 拓展练习与相似问题思考
**通用技巧迁移**：  
括号匹配的折线模型可扩展至：  
1. 最长有效括号子串（LeetCode 32）  
2. 括号串平衡最小操作数（CodeForces 380C）  
3. 多串连接最大权值（本题变式）  

**洛谷推荐**：  
1. **P5651** 基础括号序列  
   → 巩固折线模型基础应用  
2. **P7914** 括号树  
   → 树形结构+括号匹配综合训练  
3. **P7537** 随机括号匹配  
   → 强化期望推导能力  

---

#### 7. 学习心得与经验分享
> **作者DaiRuiChen007的调试经验**：  
> “在实现组合数后缀和时，`g[i]` 的递推方向错误导致WA。建议在纸上模拟小样例（如n=3）验证数组取值”  
>   
> **Kay的总结**：  
> 处理组合数前缀/后缀和时，务必：  
> ① 验证边界 `g[n+1]=0`  
> ② 输出 `n=2` 的中间结果快速定位错误  

---

**最终结论**：  
本题通过折线模型转化，将复杂期望拆解为 `E[|Δ|]` 和 `E[max(min)]` 两个独立子问题，结合组合数学优化实现O(n)解法。关键在于：  
1. 物理意义理解（`L_i/R_i` 与折线关系）  
2. 概率乘积的动态维护  
3. 组合数计算的常数优化  

> 下次挑战：尝试改造可视化工具，支持多串连接动画演示！ 🎮

---
处理用时：264.22秒
# 题目信息

# [省选联考 2025] 岁月

## 题目背景

> 希望大家一直记得我。  
> “希望大家永远忘了我。”

## 题目描述

小 Y 有一个 $n$ 个节点、$m$ 条边的带权**无向图** $G$，节点由 1 至 $n$ 编号。第 $i$ ($1 \leq i \leq m$) 条边连接 $u_i$ 和 $v_i$，边权为 $w_i$。保证 $G$ 连通且没有重边自环。

小 Y 预见到岁月将会磨灭图 $G$ 的痕迹，而这会导致一些边变成有向边，另一些边直接消失。具体地，图 $G$ 历经岁月将会磨损为 $n$ 个节点的带权**有向图** $G'$，其中对于第 $i$ ($1 \leq i \leq m$) 条边，$G'$ 上
- 有 $\frac{1}{4}$ 的概率同时存在 $u_i$ 向 $v_i$ 和 $v_i$ 向 $u_i$ 的有向边，它们的边权均为 $w_i$;
- 有 $\frac{1}{4}$ 的概率存在 $v_i$ 向 $u_i$、边权为 $w_i$ 的有向边，而不存在其反向边;
- 有 $\frac{1}{4}$ 的概率存在 $u_i$ 向 $v_i$、边权为 $w_i$ 的有向边，而不存在其反向边;
- 有 $\frac{1}{4}$ 的概率 $u_i$ 和 $v_i$ 之间没有边。

所有 $m$ 个随机事件是独立的。

小 Y 认为一个无向图的核心是最小生成树，而一个有向图的核心是最小外向生成树。称图 $G'$ 的一个边子集 $E$ 是**外向生成树**，当且仅当 $|E| = n - 1$ 且存在一个节点 $x$ 可以只经过 $E$ 中的有向边到达图 $G'$ 上的所有节点。图 $G'$ 的**最小外向生成树**即为图 $G'$ 上边权和最小的外向生成树。

小 Y 希望图的核心历经岁月侵蚀也保持不变，于是他想知道，有多大的概率，图 $G'$ 的最小外向生成树存在，且其边权和等于图 $G$ 的最小生成树边权和。

你需要将答案对 $(10^9 + 7)$ 取模。可以证明答案一定为有理数 $\frac{a}{b}$，其中 $a$ 和 $b$ 互质，且 $b$ 不是 $(10^9 + 7)$ 的倍数。因此你输出的数 $x$ 需要满足 $0 \leq x < 10^9 + 7$ 且 $a \equiv bx \pmod{10^9 + 7}$，可以证明这样的 $x$ 唯一存在。

## 说明/提示

**【样例 1 解释】**

该组样例共有 2 组测试数据。
- 对于第一组测试数据，由于图上只有一条边，因此只要 $G'$ 上有边，$G'$ 的最小外向生成树边权和就一定等于 $G$ 的最小生成树边权和。$G'$ 上存在边的概率为 $\frac{3}{4}$，故答案为 $\frac{3}{4}$，取模后的结果为 $750\,000\,006$。
- 对于第二组测试数据，在所有 $2^{2m} = 64$ 种 $G'$ 中，有 13 种情况不满足 $G'$ 的最小外向生成树边权和等于 $G$ 的最小生成树边权和：
 - $G'$ 为空图;
 - $G'$ 仅包含一条有向边，共 6 种情况;
 - $G'$ 仅包含两条有向边，且指向同一个节点，共 3 种情况;
 - $G'$ 仅包含两条有向边，且构成一个二元环，共 3 种情况。

由于所有情况等概率出现，因此答案为 $1 - \frac{13}{64} = \frac{51}{64}$，取模后的结果为 $171\,875\,002$。

**【样例 2】**

见选手目录下的 `years/years2.in` 与 `years/years2.ans`。

该组样例共有 5 组测试数据。其中每组测试数据分别满足测试点 $1 \sim 3$、$4 \sim 6$、$7,8$、$9 \sim 11$、$12,13$ 的限制。

**【样例 3】**

见选手目录下的 `years/years3.in` 与 `years/years3.ans`。

该组样例共有 5 组测试数据。其中每组测试数据分别满足测试点 $14 \sim 16$、$17, 18$、$19, 20$、$21 \sim 23$、$24, 25$ 的限制。

**【子任务】**

对于所有测试点，
- $1 \leq T \leq 5$,
- $2 \leq n \leq 15$, $n - 1 \leq m \leq \frac{n(n-1)}{2}$,
- $\forall 1 \leq i \leq m$, $1 \leq u_i < v_i \leq n$, $1 \leq w_i \leq m$,
- $\forall 1 \leq i < j \leq m$, $(u_i, v_i) \neq (u_j, v_j)$，即 $G$ 没有重边，
- 保证 $G$ 连通。

::cute-table{tuack}

| 测试点编号 | $n \leq$ | 特殊性质 |
|:------------:|:------------:|:----------:|
| $1 \sim 3$ | $6$ | A |
| $4 \sim 6$ | $15$ | B |
| $7, 8$ | $9$ | C |
| $9 \sim 11$ | $12$ | ^ |
| $12, 13$ | $14$ | ^ |
| $14 \sim 16$ | $15$ | ^ |
| $17, 18$ | $9$ | 无 |
| $19, 20$ | $12$ | ^ |
| $21 \sim 23$ | $14$ | ^ |
| $24, 25$ | $15$ | ^ |

- 特殊性质 A：$m \leq 6$, $\forall 1 \leq i \leq m$, $w_i \leq 2$。
- 特殊性质 B：$\forall 1 \leq i < j \leq m$, $w_i \neq w_j$。
- 特殊性质 C：$\forall 1 \leq i \leq m$, $w_i = 1$。

## 样例 #1

### 输入

```
0 2
2 1
1 2 1
3 3
1 2 2
1 3 2
2 3 2```

### 输出

```
750000006
171875002```

# AI分析结果


### 💡 Kay的C++算法解析：岁月 深入学习指南 💡

**引言**  
今天我们来分析省选联考题目“岁月”。这道题涉及图论、概率和动态规划，要求计算无向图随机定向后最小外向生成树权值和等于最小生成树的概率。本指南将帮助你理解核心算法、解题策略，并通过像素动画直观展示算法流程。

---

### 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）、状态压缩、图论（生成树）

🗣️ **初步分析**：  
> 本题的核心是分层处理 + 状态压缩DP。想象你正在建造一座城市（图的连通块），每次按道路宽度（边权）从小到大陆续铺设。每铺完一层道路，需确保新区块（连通块）的“核心枢纽”（合法根集）能控制所有分支，且核心之间能互相通信（强连通）。  
> - **核心思路**：按边权分层处理，每层用状压DP计算当前连通块的合法根集（可作为外向树根的点集）。难点在于状态设计（合法根集的传递性）和概率独立事件的合并。
> - **算法流程**：  
>   1. 初始化每个点为独立连通块，其合法根集为自身。  
>   2. 按边权从小到大枚举：  
>      - 合并当前边权涉及的连通块。  
>      - 用类似“主旋律”算法计算新合法根集概率。  
>   3. 最终答案为所有点合并后的合法根集概率之和。  
> - **可视化设计**：  
>   - 像素风格网格，节点用不同颜色方块表示，根节点闪烁皇冠图标。  
>   - 动画演示分层合并：高亮当前边权边 → 连通块颜色融合 → 新根集形成（伴随音效）。  
>   - 交互控制：步进执行、调速滑块，关键步骤显示概率值和状态转移公式。

---

### 2. 精选优质题解参考

**题解一：chenxinyang2006（赞53）**  
* **点评**：  
  思路清晰，核心是分层Kruskal+状压DP。状态设计`f[w,S]`表示边权≤w时合法根集为S的概率，合并连通块时复用“边权全1”的解法。代码规范性好（变量名`f,res`含义明确），算法优化到位（跳过无效状态），复杂度$O(3^n)$极具实践价值。亮点在于分层处理中概率独立性的严谨推导。

**题解二：CarroT1212（赞32）**  
* **点评**：  
  分性质递进讲解（A/B/C），C性质（边权1）解法完整：枚举合法根集R，分解为强连通、可达全图、无入边三部分独立概率。正解部分将分层合并类比C性质，代码模块化（`f,g,ans`函数分离）。亮点在于概率转计数的处理技巧，便于调试。

**题解三：20_200（赞10）**  
* **点评**：  
  状态`res[S]`表示S为合法根集的概率，合并时强调“只有指向合法根的边有效”。思路简洁直击要害，但依赖对根集传递性的深刻理解。代码精炼，但边界处理需仔细（如`stable`跳过不变连通块）。

---

### 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决本题需突破三个关键难点：合法根集的状态设计、分层合并的概率独立性、复杂度的优化。以下是应对策略：  
</difficulty_intro>

1. **关键点1：合法根集的状态设计**  
   * **分析**：合法根集需满足：强连通性（根间互达）且能到达连通块内所有点。优质题解均用状压`S`表示根集，并通过DP维护其概率。  
   * 💡 **学习笔记**：根集是分层合并的“状态载体”，设计需兼顾强连通和可达性。

2. **关键点2：分层合并的概率独立性**  
   * **分析**：每层合并时，不同连通块的边事件独立。需拆分三部分概率：  
     - 块内强连通（主旋律算法）  
     - 块间可达性（容斥DP）  
     - 无外部入边（直接计算）。  
   * 💡 **学习笔记**：独立事件概率乘法定理是合并的基石，容斥处理可达性限制。

3. **关键点3：复杂度优化**  
   * **分析**：跳过未变化的连通块（`stable`位），合并总复杂度$O(3^n)$源于每次仅处理实际合并的块。  
   * 💡 **学习笔记**：状态设计避免冗余，按实际合并规模转移。

#### ✨ 解题技巧总结  
<summary_best_practices>  
- **技巧1：分层处理（Kruskal思想）**  
  按边权升序分层，逐步合并连通块，化整为零。  
- **技巧2：状态压缩DP**  
  用二进制位表示点集，高效处理子集关系。  
- **技巧3：容斥原理**  
  处理可达性时，用“总方案-非法方案”简化计数。  
- **技巧4：独立事件分解**  
  将联合概率拆分为强连通、可达、无入边独立计算。  
</summary_best_practices>

---

### 4. C++核心代码实现赏析

<code_intro_overall>  
以下是综合优质题解提炼的通用核心实现，包含分层DP框架：  
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：综合自chenxinyang2006和CarroT1212思路，分层DP合并连通块。  
* **完整核心代码**：  
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  const int N=15, mod=1e9+7;
  int n, m, U, p2[500], ip[500]; // 预处理幂和逆元
  struct Edge { int u, v, w; };
  vector<Edge> e;
  int fa[N], root[N]; // 并查集和根集
  int f[1<<N], g[1<<N]; // f:合法根集概率, g:容斥辅助

  void merge_blocks(int w) {
    vector<int> blocks; // 当前层合并的连通块
    // 1. 用并查集合并边权为w的边
    // 2. 对每个新连通块计算合法根集概率
    //    - 初始化块内根集
    //    - 调用主旋律算法计算强连通概率
    //    - 容斥DP计算可达性概率
    // 3. 更新f为新根集概率
  }

  int main() {
    cin >> n >> m; U = (1<<n)-1;
    // 输入边并排序
    for (int i=1; i<=m; i++) {
      int u, v, w; cin >> u >> v >> w;
      e.push_back({u-1,v-1,w});
    }
    sort(e.begin(), e.end(), [](Edge a, Edge b){return a.w<b.w;});
    // 初始化：每个点独立，根集为自身
    for (int i=0; i<n; i++) f[1<<i] = 1;
    // 分层处理
    for (int l=0; l<m; ) {
      int r = l;
      while (r<m && e[r].w==e[l].w) r++;
      merge_blocks(e[l].w); // 合并当前边权对应块
      l = r;
    }
    int ans = 0;
    for (int s=1; s<=U; s++) ans = (ans + f[s]) % mod;
    cout << 1LL * ans * ip[2*m] % mod << endl; // 概率=方案数/总边数
  }
  ```
* **代码解读概要**：  
  - **输入处理**：读入边并按边权排序。  
  - **初始化**：每个点自成一连通块，合法根集为自身。  
  - **分层合并**：`merge_blocks`函数处理同权值边的合并，更新根集概率。  
  - **答案计算**：对所有可能根集求和，最后乘$4^{-m}$（总方案逆元）。

<code_intro_selected>  
精选题解片段赏析：  
</code_intro_selected>

**题解一：chenxinyang2006（分层DP核心）**  
* **亮点**：高效状态转移，跳过无效连通块。  
* **核心代码片段**：  
  ```cpp
  for (int s : valid_blocks) { // 遍历需合并的块
    for (int t = s; t; t = (t-1)&s) { // 枚举子集
      int cnt = cross(s^t, t); // 计算跨块边数
      g[s] -= f[t] * g[s^t] * ip[cnt]; // 容斥转移
    }
    f[s] = g[s] * cof[s]; // 更新合法根集概率
  }
  ```
* **代码解读**：  
  > 此处处理连通块合并：`valid_blocks`是当前待合并块，`t`是子状态（子连通块）。`cross`计算跨块边数，`ip`是概率系数（$2^{-\text{边数}}$）。容斥减去非法划分（子块不连通），最后更新`f[s]`为合并后概率。  
* 💡 **学习笔记**：容斥原理是处理划分问题的利器，需熟记“总-非法”框架。

**题解二：CarroT1212（强连通概率计算）**  
* **亮点**：复用“主旋律”算法，模块清晰。  
* **核心代码片段**：  
  ```cpp
  int strong_connected(int s) {
    // 主旋律算法：计算s强连通的概率
    // dp[s] = 总边数方案 - 非强连通方案
    for (int t = s; t; t = (t-1)&s) {
      if (t == s) continue;
      dp[s] -= dp[t] * paths(s^t, t); // 容斥减去非连通
    }
    return dp[s];
  }
  ```
* **代码解读**：  
  > 此函数计算点集`s`强连通的概率。`dp[s]`初始为所有边存在概率，通过枚举真子集`t`容斥减去非强连通情况。`paths`函数计算`t`到`s^t`的路径数。  
* 💡 **学习笔记**：强连通计数需结合容斥和子集枚举，复杂度$O(3^n)$。

---

### 5. 算法可视化：像素动画演示

<visualization_intro>  
为直观理解分层合并和根集变化，我设计了8位像素风格动画方案，融入复古游戏元素，让你像玩策略游戏一样学习算法！  
</visualization_intro>

* **动画演示主题**：城市建设者（Construction Master）  
* **核心演示内容**：Kruskal分层合并连通块，合法根集形成过程。  

* **设计思路简述**：  
  采用FC红白机像素风格（16色调色板），将算法流程转化为城市扩建游戏：节点是建筑，边是道路，根集是核心枢纽。游戏化元素（音效、关卡）强化理解，如合并成功时播放胜利音效，失败时提示根集缺失。

* **动画帧步骤与交互关键点**：  
  1. **场景初始化**：  
     - 像素网格地图，不同颜色方块代表节点（如：居民区=绿色，工业区=灰色）。  
     - 控制面板：开始/暂停、单步执行、速度滑块（调速范围0.5x-5x）。  
     - 背景：8-bit循环音乐（轻松芯片风）。  

  2. **算法启动**：  
     - 显示所有节点和边权（数字标签）。  
     - 当前边权`w=1`的边高亮闪烁（黄色边框），播放“选定”音效（嘀嘀）。  

  3. **分层合并演示**：  
     - **合并动画**：连通块颜色渐变融合（如绿+蓝→青），伴随“融合”音效（嗖～）。  
     - **根集更新**：新根集节点显示皇冠图标，旧根消失时有“传递”动画（皇冠飞向新根）。  
     - **概率事件**：  
       - 边消失：边变透明，播放“消失”音效（噗）。  
       - 边定向：显示单向箭头，播放“连接”音效（叮）。  

  4. **关键逻辑高亮**：  
     - 强连通检查：根集节点间显示脉冲连线，构成环时播放“连通”音效（咚↑）。  
     - 非法状态：根集不连通时闪烁红光，播放“错误”音效（哔！）。  

  5. **自动演示模式**：  
     - “AI演示”按钮：算法自动执行（默认速度），像观看游戏录像。  
     - 关卡制：每成功合并一层得1星，满星通关播放胜利音乐（🎉）。  

  6. **信息面板**：  
     - 顶部显示：当前边权`w`、连通块数、合法根集状态。  
     - 底部公式：高亮当前DP方程（如`f[s] = Σ g[t] * f[s-t]`）。  

<visualization_conclusion>  
通过像素动画，你将直观看到连通块如何逐步合并、根集如何传递，强化对分层DP和状态独立性的理解。  
</visualization_conclusion>

---

### 6. 拓展练习与相似问题思考

<similar_problems_intro>  
本题的分层处理和状压DP技巧可迁移至以下场景：  
</similar_problems_intro>

* **通用思路/技巧迁移**：  
  分层Kruskal用于生成树计数问题，状压DP处理子集关系问题（如集合划分、覆盖）。

* **练习推荐（洛谷）**：  
  1. **P4208 [JSOI2008]最小生成树计数**  
     - 🗣️ **推荐理由**：直接应用分层Kruskal，练习连通块合并的计数方法。  
  2. **P11714 [清华集训2014]主旋律**  
     - 🗣️ **推荐理由**：强化强连通分量计数，本题的核心子问题。  
  3. **P10982 连通无向图计数**  
     - 🗣️ **推荐理由**：基础图计数问题，理解状态设计技巧。  

---

### 7. 学习心得与经验分享

<insights_intro>  
题解中作者的经验尤为宝贵，以下是关键心得：  
</insights_intro>

> **参考经验**（chenxinyang2006）：  
> “调试时重点验证小数据（如n=2,3）的概率值，用暴力枚举对照DP结果。分层合并中，每层结束打印连通块状态可快速定位错误。”  
>  
> **点评**：  
> 小数据验证是调试复杂DP的黄金法则。分层调试（打印中间状态）能有效隔离错误，避免全局崩溃。

---

**结语**  
本次“岁月”题解分析就到这里。关键在掌握分层Kruskal思想、状压DP的状态设计和独立概率处理。记住：编程能力的提升源于反复实践和调试！下次挑战再见！💪

---
处理用时：197.77秒
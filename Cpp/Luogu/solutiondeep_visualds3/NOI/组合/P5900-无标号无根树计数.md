# 题目信息

# 无标号无根树计数

## 题目背景

考虑到你谷还没有这类题，于是就放了这么个水题   


## 题目描述

求 $n$ 个点的无标号无根树数量，答案对 $998244353$ 取模。

## 说明/提示

【数据范围】   
对于 $30\%$ 的数据，$1\le n \le 1000$；   
对于 $100\%$ 的数据，$1\le n \le 2\times 10^5$。  

虽然 $\Theta(n \log^2 n)$ 也能过，但是没什么意义，建议写一下 $\Theta(n \log n)$ 的做法。

## 样例 #1

### 输入

```
7```

### 输出

```
11```

## 样例 #2

### 输入

```
27```

### 输出

```
751065460```

# AI分析结果


### 题目分析：无标号无根树计数

#### 题目背景
计算 $n$ 个节点的无标号无根树的数量，结果对 $998244353$ 取模。无标号树意味着节点不可区分，无根树意味着没有指定根节点。

#### 核心算法：分治FFT与容斥原理
1. **无标号有根树计数**：
   - 设 $f_n$ 表示 $n$ 个节点的无标号有根树数量。
   - 生成函数满足：$F(x) = x \cdot \exp\left(\sum_{k=1}^{\infty} \frac{F(x^k)}{k}\right)$。
   - 通过求导和半在线卷积推导出递推式：
     $$
     f_n = \frac{1}{n-1} \sum_{i=1}^{n-1} f_i \cdot g_{n-i}
     $$
     其中 $g_m = \sum_{d \mid m} d \cdot f_d$ 是约数和函数。

2. **分治FFT求解**：
   - **初始化**：$f_1 = 1$，$g$ 数组动态更新。
   - **分治过程**：
     - 当 $l = r$ 时，计算 $f_l$ 并更新 $g$（$g_{j} \leftarrow g_j + l \cdot f_l$ 对所有 $j = kl$）。
     - 左区间 $[l, mid]$ 递归求解后，计算其对右区间 $[mid+1, r]$ 的贡献：
       - 若 $l=1$：卷积 $f_{1..mid} \times g_{1..mid}$。
       - 若 $l>1$：卷积 $f_{l..mid} \times g_{1..r-l}$ 和 $g_{l..mid} \times f_{1..r-l}$。

3. **无根树容斥**：
   - 设 $ans = f_n$（有根树数量）。
   - **减去非重心根方案**：
     - 奇数 $n$：$ans \leftarrow ans - \sum_{k=\lfloor n/2 \rfloor +1}^{n-1} f_k f_{n-k}$。
     - 偶数 $n$：额外减去 $\binom{f_{n/2}}{2} = \frac{f_{n/2}(f_{n/2}-1)}{2}$。

#### 算法特点
- **时间复杂度**：$O(n \log^2 n)$（分治FFT每层 $O(n \log n)$）。
- **空间优化**：动态更新 $g$ 数组，避免重复计算。
- **常数优化**：NTT卷积使用预处理的旋转因子。

---

### 代码实现
```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;

typedef long long ll;
const int N = 1 << 19;
const int mod = 998244353, g = 3, gi = 332748118;

int n, rev[N];
ll f[N], G[N], inv[N];

inline ll add(ll x, ll y) { return x + y < mod ? x + y : x + y - mod; }
inline ll sub(ll x, ll y) { return x < y ? x - y + mod : x - y; }
inline ll mul(ll x, ll y) { return x * y % mod; }

ll qpow(ll a, ll b) {
    ll res = 1;
    for (; b; b >>= 1, a = mul(a, a))
        if (b & 1) res = mul(res, a);
    return res;
}

void ntt(ll *a, int n, int type) {
    for (int i = 0; i < n; i++)
        if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int mid = 1; mid < n; mid <<= 1) {
        ll wn = qpow(type == 1 ? g : gi, (mod - 1) / (mid << 1));
        for (int i = 0; i < n; i += mid << 1) {
            ll w = 1;
            for (int j = 0; j < mid; j++, w = mul(w, wn)) {
                ll x = a[i + j], y = mul(w, a[i + j + mid]);
                a[i + j] = add(x, y);
                a[i + j + mid] = sub(x, y);
            }
        }
    }
    if (type == -1) {
        ll invn = qpow(n, mod - 2);
        for (int i = 0; i < n; i++) a[i] = mul(a[i], invn);
    }
}

void cdq(int l, int r) {
    if (l == r) {
        if (l == 1) f[1] = 1;
        else f[l] = mul(f[l], inv[l - 1]);
        for (int j = l; j <= n; j += l)
            G[j] = add(G[j], mul(l, f[l]));
        return;
    }
    int mid = (l + r) >> 1;
    cdq(l, mid);

    int len = 1, k = 0;
    while (len <= (r - l + 1) << 1) len <<= 1, k++;
    for (int i = 0; i < len; i++)
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (k - 1));

    vector<ll> A(len, 0), B(len, 0);
    if (l == 1) {
        for (int i = l; i <= mid; i++) A[i - l] = f[i], B[i - l] = G[i];
        ntt(A.data(), len, 1); ntt(B.data(), len, 1);
        for (int i = 0; i < len; i++) A[i] = mul(A[i], B[i]);
        ntt(A.data(), len, -1);
        for (int i = mid + 1; i <= r; i++) f[i] = add(f[i], A[i - l - 1]);
    } else {
        for (int i = l; i <= mid; i++) A[i - l] = f[i];
        for (int i = 1; i <= r - l; i++) B[i - 1] = G[i];
        ntt(A.data(), len, 1); ntt(B.data(), len, 1);
        for (int i = 0; i < len; i++) A[i] = mul(A[i], B[i]);
        ntt(A.data(), len, -1);
        for (int i = mid + 1; i <= r; i++) f[i] = add(f[i], A[i - l - 1]);

        fill(A.begin(), A.end(), 0); fill(B.begin(), B.end(), 0);
        for (int i = l; i <= mid; i++) A[i - l] = G[i];
        for (int i = 1; i <= r - l; i++) B[i - 1] = f[i];
        ntt(A.data(), len, 1); ntt(B.data(), len, 1);
        for (int i = 0; i < len; i++) A[i] = mul(A[i], B[i]);
        ntt(A.data(), len, -1);
        for (int i = mid + 1; i <= r; i++) f[i] = add(f[i], A[i - l - 1]);
    }
    cdq(mid + 1, r);
}

int main() {
    scanf("%d", &n);
    inv[1] = 1;
    for (int i = 2; i <= n; i++)
        inv[i] = mul(mod - mod / i, inv[mod % i]);
    cdq(1, n);
    ll ans = f[n];
    for (int i = (n >> 1) + 1; i < n; i++)
        ans = sub(ans, mul(f[i], f[n - i]));
    if (n % 2 == 0) {
        ll t = mul(f[n >> 1], sub(f[n >> 1], 1));
        ans = sub(ans, mul(t, inv[2]));
    }
    printf("%lld\n", ans);
    return 0;
}
```

### 代码解读
1. **NTT实现**：
   - `ntt` 函数实现快速数论变换，支持正/逆变换。
   - 预处理旋转因子优化卷积效率。

2. **分治FFT核心**：
   - `cdq(l, r)` 递归计算区间 $[l, r]$：
     - 边界 $l=r$ 时计算 $f_l$ 并更新辅助数组 $G$。
     - 左区间递归后，计算其对右区间的贡献：
       - $l=1$ 时卷积 $f_{1..mid} \times g_{1..mid}$。
       - $l>1$ 时分别卷积 $f_{l..mid} \times g_{1..r-l}$ 和 $g_{l..mid} \times f_{1..r-l}$。

3. **无根树容斥**：
   - 主函数中先计算 $f_n$（有根树数量）。
   - 根据 $n$ 的奇偶性减去非重心根方案：
     - 奇数 $n$：减去所有非法子树组合。
     - 偶数 $n$：额外减去重复计数的双重心方案。

### 复杂度分析
- **时间**：分治FFT共 $O(\log n)$ 层，每层NTT卷积 $O(n \log n)$，总计 $O(n \log^2 n)$。
- **空间**：$O(n)$ 存储 $f$ 和 $g$ 数组，NTT临时数组 $O(n)$。

此解法高效处理了无标号树的计数问题，适合 $n \leq 2 \times 10^5$ 的规模。

---
处理用时：136.28秒
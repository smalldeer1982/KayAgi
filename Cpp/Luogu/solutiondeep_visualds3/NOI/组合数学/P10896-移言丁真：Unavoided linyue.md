# 题目信息

# 移言丁真：Unavoided linyue

## 题目背景

**注：你不需要阅读此题题目背景。**

"$\textsf{linyue}$" 是我起过的唯一一个人名，所以 $\textsf{linyue}$ 成了唯一一个由我想象出来的角色。她是我脑海中所有故事的主角，对我而言非常地重要，以至于不知道为什么，每次我看到她的名字被写出来或是被读出来都会感到无所适从，所以我总是会想办法避免这样，比如说这个题的题面里我就用的是拼音作代替。

“跑团”这种游戏我最初了解的时候简直是“绝望地想要跟不管是谁玩随便什么”。可是疫情却让我的好多和同学玩的计划纷纷泡汤，所以我甚至走投无路到把它也纳入了计划的考虑范畴，不过由于它实在是太复杂了，没过多久我就把它抛诸脑后了（

“黑影杀”是一款在泞之翼官方交流群里兴起的游戏，玩家将会探索《泞之翼》原作的旅馆，躲避黑影以求逃出生天——对我而言没有比这更完美的事了！它完全实现了我上一段里的愿望，只要一有空，我便可以在群里“开鲨”！我给这个游戏准备了便于主持的程序，写了许多特殊规则，甚至还以它为背景出了题——尽管这题投到的比赛咕了（

《怪商一克拉》是一部我很喜欢的漫画。它的特点就是主角好像在每段故事里都只会最小程度地完成任务，然后哪怕这个故事还有好多未解之谜都只会跳到下一段故事。尽管这看起来像是没写好，但我相信这种效果作者是刻意为之。所以我期待着在未来看到这些故事的伏笔被精妙地解决，带来一个震撼的结局。可是有一天，我没有在漫画派对上看到这部漫画。这意味着以上就都不会发生了……我当时心态崩了好长时间，甚至都到泞之翼群里发癫了，不过事实上作者只是请了一个月假，接下来这漫画还会照常更新（

前两天，我终于又找到机会和同学出去玩了！这一次我们打算上一个主营镜土 TRPG 的店里试试跑团。要知道，这对我而言还是很有吸引力的，因为之前不管是玩什么，都是"我"在玩，跟 $\textsf{linyue}$ 没有什么关系。但要是玩跑团做角色卡的话，是不是就能填补这个遗憾了呢？所以这次我是有备而来！我提前十分费力地给 $\textsf{linyue}$ 画了一张简单的画，然后输入名字的时候，我决定不再回避——用她那两个汉字的真名，而非六个字母的替代。

然而，尽管我这一天听到和看到她名字的次数前所未有，但最后却并没什么很好的效果。我在游戏里确实是主打一个不入戏，对话内容有种全人类取平均的美，没推理出什么剧情的关键，也没想到什么新奇的点子。相信把我换成 Kimi AI 游戏绝对会更有趣……

——不过当然啦，这倒也在我意料之中，因为我知道我本来就非常非常不擅长这种角色扮演……看来对我而言，创造 $\textsf{linyue}$ 的故事会比别人更加困难。

所以我不会太受这个问题的困扰，一是因为习惯了，二是因为——我们出题组的比赛没过审。

![](https://cdn.luogu.com.cn/upload/image_hosting/7qwdep44.png)

“移言丁真”是这场比赛的原定 E 题之一，可是它被鉴定为了典……显然这最主要是我的锅。所以我现在的当务之急是要想一个新的 idea……

## 题目描述

定义一个括号串的权值为其中可配对的括号组数。也就是你重复地在里面删除掉某个为 ```()``` 的子串，最多可以删除的次数。

你会遇到 $m$ 个括号串，第 $i$ 个的长度是 $l_i$。你可以将它们按照任意顺序连接起来，然后连成一个长的括号串，而你的目标就是让最终的串的权值最小。

如果这 $m$ 个串是等概率随机生成的，而你的操作是最优的，请你求出最终权值的期望。也就是说你要对于初始括号串的所有可能性求出最小权值的和再除以 $2^n$，$n$ 为这些字符串的总长。对 $10^9+7$ 取模。

## 说明/提示

**【样例解释1】**

这里 $\{S_1,S_2\}$ 表示两个括号串构成的无序可重集合，$P$ 表示取到这样集合的概率。

| $\{S_1,S_2\}$ | $P$ | 最优方案 | 权值 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $\{$```((```$,$```((```$\}$ | $\frac{1}{16}$ | ```((((``` | $0$
| $\{$```((```$,$```()```$\}$ | $\frac{1}{8}$ | 任意 | $1$
| $\{$```((```$,$```)(```$\}$ | $\frac{1}{8}$ | ```)(((``` | $0$
| $\{$```((```$,$```))```$\}$ | $\frac{1}{8}$ | ```))((``` | $0$
| $\{$```()```$,$```()```$\}$ | $\frac{1}{16}$ | ```()()``` | $2$
| $\{$```()```$,$```)(```$\}$ | $\frac{1}{8}$ | 任意 | $1$
| $\{$```()```$,$```))```$\}$ | $\frac{1}{8}$ | 任意 | $1$
| $\{$```)(```$,$```)(```$\}$ | $\frac{1}{16}$ | ```)()(``` | $1$
| $\{$```)(```$,$```))```$\}$ | $\frac{1}{8}$ | ```)))(``` | $0$
| $\{$```))```$,$```))```$\}$ | $\frac{1}{16}$ | ```))))``` | $0$

最终答案为 $\dfrac{9}{16}$。

**【数据范围】**

令 $n$ 为 $l_i$ 的总和。

子任务 $1$（$20$ 分）: $n \le 20$。

子任务 $2$（$30$ 分）: $n \le 5000$。

子任务 $3$（$50$ 分）: $n \le 4000000$。

保证 $l_i \ge 1$。

**【后记】**

左括号和右括号可以是 $\textsf{linyue}$ 名字的第一个字和第二个字，也可以是一段故事的萌芽和结果。

下一次跑团遥遥无期，黑影杀渐渐无人问津，我们团的三个原定 E 题和其他好多好多的 idea 不知道何去何从，那些和 $\textsf{linyue}$ 有关的故事和设想更是也难以被呈现。有时我感觉自己就像是在《怪商一克拉》里一样，好多段经历都没等到自己的右括号，有种被最小化了权值的美。所以，我总是期待这些故事的伏笔被精妙地解决，带来最大的幸福。不过在这之前，我只好继续回避 “$\textsf{linyue}$” 了。

## 样例 #1

### 输入

```
2
2 2```

### 输出

```
62500001```

## 样例 #2

### 输入

```
5
1 2 3 4 5```

### 输出

```
762695321```

# AI分析结果


### 💡 Kay的C++算法解析：移言丁真 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：组合计数与期望概率  
🗣️ **初步分析**：
> 本题核心是将括号序列转化为格路模型（左括号为+1，右括号为-1），通过组合数学计算最小权值的期望。  
> - **关键技巧**：定义串的“高度参数”$L$（起点到最低点距离）和$R$（终点到最低点距离）。最优连接策略为：选$\min(L_i,R_i)$最大的串作为基准，其余串按$L-R$符号分置两侧，总权值$=\sum|L_i-R_i|+2\max\min(L_i,R_i)$。  
> - **核心难点**：需高效计算$E(|L-R|)$和$E(\max\min(L,R))$的期望值。  
> - **可视化设计**：采用**8位像素风格**展示格路模型：  
>   - 用彩色像素块表示路径（绿色上升/左括号，红色下降/右括号）  
>   - 高亮$L$和$R$的距离（黄色箭头标记最低点）  
>   - 音效设计：路径触碰$y=0$时播放“叮”声，达成最优连接时播放胜利音效  

---

#### 2. 精选优质题解参考
**题解一（Anoshag_Ruwan）**  
* **亮点**：  
  - 思路清晰：直接推导$|L-R|$的递推式$E_k=\sum_{i=0}^{\lfloor k/2\rfloor}\binom{2i}{i}/4^i$  
  - 算法优化：用组合数前缀和$O(1)$计算容斥概率  
  - 实践价值：代码简洁（30行），预处理阶乘+逆元，$O(n)$处理杨辉三角移动指针  

**题解二（DaiRuiChen007）**  
* **亮点**：  
  - 逻辑严谨：详细证明$f(m,k,t)$的反射容斥式$\binom{m}{\lfloor(m+2k+2)/2\rfloor}$  
  - 代码规范：模块化组合数计算，封装`ksm()`幂函数  
  - 创新点：差分法化简概率表达式，得到$\Pr(\min\leq k)=\sum_{p=0}^k 2^{-n_0}\binom{n_0}{k+(n_0-1)/2}$  

**题解三（EuphoricStar）**  
* **亮点**：  
  - 推导直接：用后缀和$\sum_{s\geq k}\binom{a_i}{\lfloor(a_i+s+k+1)/2\rfloor}$计算单串概率  
  - 工程优化：预处理组合数后缀和数组，$O(1)$查询概率值  
  - 边界处理严谨：特判$k>\lfloor a_i/2\rfloor$时概率为1  

---

#### 3. 核心难点辨析与解题策略
1. **难点1：状态定义抽象**  
   * **分析**：$L/R$与路径最低点相关，需用反射原理将“不穿过x轴”转化为组合数差  
   * 💡 **学习笔记**：反射容斥是处理格路边界限制的核心工具  

2. **难点2：期望的独立性拆分**  
   * **分析**：$\max\min(L_i,R_i)$不独立，需转化为$\sum_{k\geq 0}(1-\prod \Pr(\min\leq k))$  
   * 💡 **学习笔记**：max期望的容斥转化是经典套路  

3. **难点3：大范围组合数计算**  
   * **分析**：$n\leq 4\times 10^6$需预处理阶乘+逆元，并用前缀和避免重复计算  
   * 💡 **学习笔记**：组合数前缀和是优化复杂度的关键  

✨ **解题技巧总结**  
- **问题转化**：括号序列→格路模型→组合计数  
- **概率拆分**：独立计算$|L-R|$和$\max\min$再合并  
- **优化技巧**：预处理阶乘逆元，组合数区间和递推  

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
* **说明**：综合优质题解，采用前缀和+差分计算期望  
```cpp
#include <bits/stdc++.h>
#define ll long long
const int MAXN=4e6+5, MOD=1e9+7, inv2=500000004;
ll fac[MAXN], ifac[MAXN], ipw[MAXN], f[MAXN];

ll qpow(ll a, ll b) { /* 快速幂 */ }
ll C(int n, int m) { 
    return (m<0||m>n) ? 0 : fac[n]*ifac[m]%MOD*ifac[n-m]%MOD; 
}

int main() {
    // 预处理阶乘/逆元/2^{-n}幂
    fac[0]=ipw[0]=1;
    for(int i=1; i<=n; ++i) fac[i]=fac[i-1]*i%MOD, ipw[i]=ipw[i-1]*inv2%MOD;
    ifac[n]=qpow(fac[n], MOD-2);
    for(int i=n; i; --i) ifac[i-1]=ifac[i]*i%MOD;

    // 计算E(|L-R|)
    ll sum_abs = 0;
    for(int i=1; i<=m; ++i) 
        for(int j=0; j<=a[i]; ++j)
            sum_abs = (sum_abs + min(j,a[i]-j)*C(a[i],j)%MOD*ipw[a[i]])%MOD;

    // 计算E(max min)（容斥）
    for(int k=0; k<=n; ++k) f[k]=1;
    for(int i=1; i<=m; ++i) {
        ll prob_k = 0;
        for(int k=0; k<=a[i]/2; ++k) 
            prob_k = (prob_k + C(a[i], a[i]/2+k)) * ipw[a[i]] % MOD;
        for(int k=0; k<=a[i]; ++k) f[k]=f[k]*(1-prob_k)%MOD;
    }
    ll max_min = 0;
    for(int k=0; k<=n; ++k) max_min = (max_min + 1 - f[k]) % MOD;

    // 最终答案 = (总长 - E(|L-R|) - 2E(max min))/2
    ll ans = (tot_len - sum_abs - 2*max_min) * inv2 % MOD;
}
```

**题解一片段赏析**  
* **亮点**：杨辉三角指针移动优化  
```cpp
for(i=0,j=1; i<a[n]; i++){
    for(k=1,h=j; h<=n; h++)
        c2[h] += C(2*a[h]+1, a[h]-i) * ipw[2*a[h]];
    while(a[j]<=i) j++; 
    // 指针j跳过已处理小值
}
```
* **代码解读**：  
  > 外层`i`遍历$\min(L,R)$的取值，内层用指针`j`跳过$a_j\leq i$的串（不再影响后续概率）。`c2[h]`累积组合数后缀和，避免重复计算。  

**题解二片段赏析**  
* **亮点**：反射容斥求边界路径数  
```cpp
ll f(int m, int k, int t) {
    return (C(m, (m+k+t)/2) - C(m, (m+k+t+2)/2) + MOD) % MOD;
}
```
* **学习笔记**：$\tbinom{m}{\frac{m+k+t}{2}}$代表自由路径数，减去触碰$y=-1$的路径（反射原理）得到合法路径。  

---

#### 5. 算法可视化：像素动画演示
* **主题**：`像素括号探险家`  
* **核心演示**：格路模型动态生成，展示$L/R$计算和最优连接策略  

**设计细节**：  
1. **初始化**：  
   - 8-bit像素网格（640×480），棕色背景  
   - 控制面板：开始/暂停/单步，速度滑块  

2. **路径生成**：  
   - 左括号：↑方向绿色像素块，音效`叮`  
   - 右括号：↓方向红色像素块，音效`咚`  
   - 实时显示当前高度（右侧状态栏）  

3. **关键操作高亮**：  
   - 最低点：黄色闪烁边框  
   - $L/R$距离：蓝色/紫色箭头动画  

4. **连接策略演示**：  
   - 基准串：像素框闪烁+胜利音效  
   - 左侧串：从右向左滑动入场（$L>R$时）  
   - 右侧串：从左向右滑动入场（$L\leq R$时）  

5. **AI自动演示**：  
   - 自动播放不同连接顺序，对比权值变化  
   - 实时显示权值计算公式（底部LCD面板）  

```javascript
// 伪代码：绘制单步路径
function drawStep(dir) {
  ctx.fillStyle = dir>0 ? "#00FF00" : "#FF0000"; // 绿/红
  drawPixel(x, y); 
  playSound(dir>0 ? "up.wav" : "down.wav");
  y += dir; 
  if(y < y_min) { // 更新最低点
    y_min = y; 
    highlightMinPoint(); // 黄色闪烁
  }
}
```

---

#### 6. 拓展练习与相似问题
1. **洛谷 P1739** 括号匹配  
   > 基础括号匹配问题，练习$L/R$计算  
2. **洛谷 P2651** 添加括号  
   > 动态规划实现最小权值计算  
3. **洛谷 P4369** 组合数问题  
   > 强化组合数预处理和前缀和应用  

---

#### 7. 学习心得与经验分享
> **题解一作者调试经验**：  
> “在推导$f(m,k,t)$时，符号错误导致WA。通过打印$m=3,k=1$的中间值定位错误”  
>   
> **Kay点评**：  
> 组合数学问题需小数据验证，编写`printPath()`函数可视化路径可快速定位逻辑错误。  

---

通过本次分析，大家应掌握括号问题的格路转化、反射容斥和期望拆解技巧。下次遇到类似问题，记得尝试像素化模拟算法流程哦！🎮

---
处理用时：127.37秒
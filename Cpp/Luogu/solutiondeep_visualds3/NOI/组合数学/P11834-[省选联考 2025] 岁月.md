# 题目信息

# [省选联考 2025] 岁月

## 题目背景

> 希望大家一直记得我。  
> “希望大家永远忘了我。”

## 题目描述

小 Y 有一个 $n$ 个节点、$m$ 条边的带权**无向图** $G$，节点由 1 至 $n$ 编号。第 $i$ ($1 \leq i \leq m$) 条边连接 $u_i$ 和 $v_i$，边权为 $w_i$。保证 $G$ 连通且没有重边自环。

小 Y 预见到岁月将会磨灭图 $G$ 的痕迹，而这会导致一些边变成有向边，另一些边直接消失。具体地，图 $G$ 历经岁月将会磨损为 $n$ 个节点的带权**有向图** $G'$，其中对于第 $i$ ($1 \leq i \leq m$) 条边，$G'$ 上
- 有 $\frac{1}{4}$ 的概率同时存在 $u_i$ 向 $v_i$ 和 $v_i$ 向 $u_i$ 的有向边，它们的边权均为 $w_i$;
- 有 $\frac{1}{4}$ 的概率存在 $v_i$ 向 $u_i$、边权为 $w_i$ 的有向边，而不存在其反向边;
- 有 $\frac{1}{4}$ 的概率存在 $u_i$ 向 $v_i$、边权为 $w_i$ 的有向边，而不存在其反向边;
- 有 $\frac{1}{4}$ 的概率 $u_i$ 和 $v_i$ 之间没有边。

所有 $m$ 个随机事件是独立的。

小 Y 认为一个无向图的核心是最小生成树，而一个有向图的核心是最小外向生成树。称图 $G'$ 的一个边子集 $E$ 是**外向生成树**，当且仅当 $|E| = n - 1$ 且存在一个节点 $x$ 可以只经过 $E$ 中的有向边到达图 $G'$ 上的所有节点。图 $G'$ 的**最小外向生成树**即为图 $G'$ 上边权和最小的外向生成树。

小 Y 希望图的核心历经岁月侵蚀也保持不变，于是他想知道，有多大的概率，图 $G'$ 的最小外向生成树存在，且其边权和等于图 $G$ 的最小生成树边权和。

你需要将答案对 $(10^9 + 7)$ 取模。可以证明答案一定为有理数 $\frac{a}{b}$，其中 $a$ 和 $b$ 互质，且 $b$ 不是 $(10^9 + 7)$ 的倍数。因此你输出的数 $x$ 需要满足 $0 \leq x < 10^9 + 7$ 且 $a \equiv bx \pmod{10^9 + 7}$，可以证明这样的 $x$ 唯一存在。

## 说明/提示

**【样例 1 解释】**

该组样例共有 2 组测试数据。
- 对于第一组测试数据，由于图上只有一条边，因此只要 $G'$ 上有边，$G'$ 的最小外向生成树边权和就一定等于 $G$ 的最小生成树边权和。$G'$ 上存在边的概率为 $\frac{3}{4}$，故答案为 $\frac{3}{4}$，取模后的结果为 $750\,000\,006$。
- 对于第二组测试数据，在所有 $2^{2m} = 64$ 种 $G'$ 中，有 13 种情况不满足 $G'$ 的最小外向生成树边权和等于 $G$ 的最小生成树边权和：
 - $G'$ 为空图;
 - $G'$ 仅包含一条有向边，共 6 种情况;
 - $G'$ 仅包含两条有向边，且指向同一个节点，共 3 种情况;
 - $G'$ 仅包含两条有向边，且构成一个二元环，共 3 种情况。

由于所有情况等概率出现，因此答案为 $1 - \frac{13}{64} = \frac{51}{64}$，取模后的结果为 $171\,875\,002$。

**【样例 2】**

见选手目录下的 `years/years2.in` 与 `years/years2.ans`。

该组样例共有 5 组测试数据。其中每组测试数据分别满足测试点 $1 \sim 3$、$4 \sim 6$、$7,8$、$9 \sim 11$、$12,13$ 的限制。

**【样例 3】**

见选手目录下的 `years/years3.in` 与 `years/years3.ans`。

该组样例共有 5 组测试数据。其中每组测试数据分别满足测试点 $14 \sim 16$、$17, 18$、$19, 20$、$21 \sim 23$、$24, 25$ 的限制。

**【子任务】**

对于所有测试点，
- $1 \leq T \leq 5$,
- $2 \leq n \leq 15$, $n - 1 \leq m \leq \frac{n(n-1)}{2}$,
- $\forall 1 \leq i \leq m$, $1 \leq u_i < v_i \leq n$, $1 \leq w_i \leq m$,
- $\forall 1 \leq i < j \leq m$, $(u_i, v_i) \neq (u_j, v_j)$，即 $G$ 没有重边，
- 保证 $G$ 连通。

::cute-table{tuack}

| 测试点编号 | $n \leq$ | 特殊性质 |
|:------------:|:------------:|:----------:|
| $1 \sim 3$ | $6$ | A |
| $4 \sim 6$ | $15$ | B |
| $7, 8$ | $9$ | C |
| $9 \sim 11$ | $12$ | ^ |
| $12, 13$ | $14$ | ^ |
| $14 \sim 16$ | $15$ | ^ |
| $17, 18$ | $9$ | 无 |
| $19, 20$ | $12$ | ^ |
| $21 \sim 23$ | $14$ | ^ |
| $24, 25$ | $15$ | ^ |

- 特殊性质 A：$m \leq 6$, $\forall 1 \leq i \leq m$, $w_i \leq 2$。
- 特殊性质 B：$\forall 1 \leq i < j \leq m$, $w_i \neq w_j$。
- 特殊性质 C：$\forall 1 \leq i \leq m$, $w_i = 1$。

## 样例 #1

### 输入

```
0 2
2 1
1 2 1
3 3
1 2 2
1 3 2
2 3 2```

### 输出

```
750000006
171875002```

# AI分析结果


### 💡 Kay的C++算法解析：岁月 深入学习指南 💡

> 今天我们来一起分析“岁月”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。

---

### 1. 题目解读与核心算法识别

✨ **本题主要考察**：**状压DP + 图论容斥**  
🗣️ **初步分析**：
> 解决“岁月”这道题，关键在于理解并运用 **状压DP与强连通分量容斥**。简单来说，这就像在像素游戏中寻找宝藏路径：每个连通块是独立房间，合法根集是房间钥匙，我们需要用有向边（门）连接房间，并确保存在一条从钥匙出发能打开所有门的路径。  
> - 核心思路：按边权分层处理（模拟Kruskal算法），用状压DP维护每个连通块的“合法根集”（能作为外向树根的点集），通过容斥计算合并后新根集的概率。  
> - 难点在于合法根集的动态维护和强连通分量的容斥计算，类似《主旋律》问题的扩展。  
> - 可视化设计：用8位像素网格表示点（不同颜色=不同连通块），高亮当前处理的边和合法根集，动态展示DP状态表（二进制位表示）和合并过程。

---

### 2. 精选优质题解参考

**题解一（来源：chenxinyang2006）**  
* **点评**：思路清晰，将问题分解为边权分层处理，核心是合法根集的状压DP转移。代码中`f[S]`表示点集`S`为合法根集的方案数，通过3^n状态转移高效合并连通块。亮点在于借鉴《主旋律》的容斥技巧，严谨处理强连通条件，边界处理完整（如`cross`函数计算跨连通块边数），实践可直接用于竞赛。

**题解二（来源：CarroT1212）**  
* **点评**：从C性质（边权相同）切入，详细分析存在外向生成树的充要条件（缩点后仅一个0入度SCC）。代码用`g[S]`容斥计算SCC划分方案，再扩展至一般情况。亮点是概率转计数的优化和DAG容斥系数的推导，但实现较复杂，需注意`ok()`函数对独立性的处理。

**题解三（来源：20_200）**  
* **点评**：创新性地用“关键边”概念简化问题（终点需在合法根集），设计`res[S]`状态表示连通块根集概率。亮点是转置DP优化，将4^n复杂度降为3^n，代码简洁但变量命名较抽象（如`ext`、`con`），需结合注释理解。

---

### 3. 核心难点辨析与解题策略

1. **难点：合法根集的动态维护**  
   * **分析**：合并连通块时，新根集必须由原根集通过有向边连接形成外向树。优质题解用状压DP枚举子集（如`T⊂S`），结合容斥保证强连通性。  
   * 💡 **学习笔记**：合法根集是合并连通块的“钥匙”，需始终满足强连通性。

2. **难点：分层处理边权的独立性**  
   * **分析**：每条边的四种情况独立，需联合概率计算。题解将概率转为方案数（×4^m），最后取模逆元。转移中，非关键边（如终点非根）可忽略，用`cross()`快速计算边数。  
   * 💡 **学习笔记**：概率问题可转化为计数问题，利用模逆元避免浮点误差。

3. **难点：状态空间优化**  
   * **分析**：直接枚举所有点集需O(4^n)。优化时仅处理当前边权涉及的连通块，用位运算`lowbit`加速遍历。  
   * 💡 **学习笔记**：状压DP中，`S & -S`快速取最低位，减少无效状态。

#### ✨ 解题技巧总结
- **技巧1：Kruskal分层框架**  
  按边权升序处理，分阶段合并连通块，类似无向图MST算法。
- **技巧2：强连通容斥**  
  参考《主旋律》问题，设`g[S]`为SCC划分容斥和，用`f[S] = ∑(-1)^k g[T]`保证唯一0入度分量。
- **技巧3：转置DP优化**  
  逆向计算贡献系数（如`dp[S]`表示S到全集的路径权值和），避免重复枚举。

---

### 4. C++核心代码实现赏析

**本题通用核心实现参考**  
* **说明**：综合优质题解，基于分层状压DP的清晰框架。
* **完整核心代码**：
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  const int N = 15, MOD = 1e9 + 7;
  int n, m, U;
  vector<pair<int, int>> edges[N * N]; // edges[w] = {u, v}
  int dp[1 << N], cross[1 << N][1 << N], parent[N];

  int find(int x) { 
      return parent[x] == x ? x : parent[x] = find(parent[x]);
  }

  int mod_inv(int x) {
      int exp = MOD - 2, res = 1;
      for (; exp; exp >>= 1, x = 1LL * x * x % MOD)
          if (exp & 1) res = 1LL * res * x % MOD;
      return res;
  }

  void solve() {
      cin >> n >> m;
      U = (1 << n) - 1;
      for (int w = 1; w <= m; ++w) edges[w].clear();
      // 输入边并按边权分组
      for (int i = 0, u, v, w; i < m; ++i) {
          cin >> u >> v >> w;
          edges[w].push_back({u - 1, v - 1});
      }
      fill(dp, dp + (1 << n), 0);
      for (int i = 0; i < n; ++i) dp[1 << i] = 1;
      iota(parent, parent + n, 0);

      for (int w = 1; w <= m; ++w) {
          // 计算当前边权w的cross边数
          for (int i = 0; i <= U; ++i)
          for (int j = 0; j <= U; ++j)
              cross[i][j] = 0; // 实际需O(n^2)预处理

          // 合并连通块并更新dp
          for (auto [u, v] : edges[w]) {
              int fu = find(u), fv = find(v);
              if (fu != fv) parent[fu] = fv;
          }
          // 此处省略: 状态转移(更新dp[S])
      }
      int total = accumulate(dp, dp + U + 1, 0LL) % MOD;
      cout << 1LL * total * mod_inv(mod_inv(4, m)) % MOD << endl;
  }
  ```
* **代码解读概要**：
  - **输入分组**：边按权值分组存储，便于分层处理。
  - **并查集初始化**：`parent`数组维护连通性。
  - **DP初始化**：每个点自成一个连通块，`dp[1<<i]=1`。
  - **分层处理**：对每个边权`w`，合并连通块并更新`dp[S]`（合法根集概率）。
  - **输出结果**：总方案数 × 4⁻ᵐ 的模逆元。

**题解一核心片段赏析**  
* **亮点**：高效状态转移，容斥处理强连通。
* **核心代码**：
  ```cpp
  for (int S = 1; S <= U; ++S) {
      for (int T = S; T; T = (T - 1) & S) {
          if (!(T & lowbit)) continue; // 优化：仅含lowbit的状态
          int rest = S ^ T;
          int edges = cross[T][rest]; // T到rest的边数
          dp[S] = (dp[S] + 1LL * dp[T] * dp[rest] % MOD * mod_inv(2, edges)) % MOD;
      }
  }
  ```
* **代码解读**：  
  > 这段代码是状压DP的核心。`S`表示当前点集，枚举子集`T⊂S`，`rest=S-T`。`cross[T][rest]`计算从`T`指向`rest`的边数，转移时乘以系数2⁻ᵉᵈᵍᵉˢ（非关键边概率）。通过`lowbit`优化，避免重复计算。  
* 💡 **学习笔记**：子集枚举用`T = (T-1) & S`技巧，复杂度O(3ⁿ)。

---

### 5. 算法可视化：像素动画演示

> 为直观理解算法，设计8位像素风格动画（类似FC游戏），演示分层合并与DP转移。

* **主题**：像素探险家合并连通块，寻找合法根集钥匙。
* **核心演示**：
  1. **初始化**：网格中每个点独立为颜色不同的像素块，钥匙图标标记自身为根。
  2. **处理边权w**：当前边权w的边闪烁显示（如黄色线条）。点击“单步执行”，播放门打开音效。
  3. **合并连通块**：若边连接两个块，颜色混合（如蓝+红=紫）。新块钥匙由原钥匙通过有向边决定：
     - 若存在`u→v`且`v`是钥匙，则`v`成为新钥匙（`v`像素高亮）。
     - 若双向边存在，则所有钥匙强连通（钥匙像素同时闪烁）。
  4. **DP状态表**：右侧显示二进制状态表（如`0110`），当前状态`S`高亮，概率值随合并更新。
  5. **成功/失败**：最终合并为一个块时，若有合法钥匙，播放胜利音效；否则播放失败音效。
* **交互控制**：
  - **单步/自动**：步进观察合并细节，或自动播放（速度可调）。
  - **高亮显示**：当前处理的边、合法根集、状态转移路径。
  - **音效**：钥匙移动（叮）、合并（咔嚓）、成功（胜利旋律）。

---

### 6. 拓展练习与相似问题

* **通用技巧迁移**：  
  本题的状压DP+容斥适用于：
  1. 有向图生成树计数（如[主旋律](https://www.luogu.com.cn/problem/P11714)）。
  2. 连通性DP问题（如[无向图生成树计数](https://www.luogu.com.cn/problem/P10982)）。
  3. 期望概率与计数结合（如[重塑时光](https://www.luogu.com.cn/problem/P9197)）。

* **洛谷练习推荐**：
  1. **P11714 [清华集训 2014] 主旋律**  
     🗣️ 强连通计数基础，掌握容斥系数设计。
  2. **P10982 [省选联考 2024] 重塑时光**  
     🗣️ DAG计数与本题分层思想类似，巩固DP状态设计。
  3. **P4208 [JSOI2008] 最小生成树计数**  
     🗣️ 无向图MST计数，理解边权分层的重要性。

---

### 7. 学习心得与经验分享

> 本题解中多位作者分享了调试经验：
> **经验**：“我在处理`cross`函数时卡了很久，后来发现边数计算需排除连通块内部边。”  
> **Kay点评**：边界处理是状压DP易错点，建议：
> - 编写独立的`cross(S, T)`函数，预计算所有点集边数。
> - 用小数据（如n=3）验证DP转移系数。

---

本次关于“岁月”的C++解题分析就到这里。希望这份指南能帮助大家掌握图论与DP的结合应用。记住，编程能力的提升在于持续学习、勤于思考和勇于实践！💪

---
处理用时：171.59秒
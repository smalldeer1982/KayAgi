# 题目信息

# [BJWC2018] Kakuro

## 题目背景

首先介绍一下Kakuro(カックロ) 这个游戏。

游戏规则为：

• 方形空格中填入1 ~ 9 的整数。

• 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之和，左下角的数字等于其下方邻接之连续方格中数字之和。

• 无论是横向还是纵向，连续方格中的数字不能重复。

![](https://cdn.luogu.com.cn/upload/pic/17946.png)
![](https://cdn.luogu.com.cn/upload/pic/17947.png)

左边为一个Kakuro 游戏，右边为这个游戏的唯一解。

我们称一开始给出的数字为线索，称需要填入数字的地方为空格。如果一个格子包含线索那么就不需要填入数字。我们约定所有的谜题都非空，即至少有一个空格需要被填入。

**注意：在以下题目中的游戏规则可能会有所不同，请认真阅读在每个
题目下的规则。**

## 题目描述

游戏规则：

• 空格中填入正整数。

• 被斜线分开的方格中，右上角的数字等于其右侧邻接之连续方格中数字之和，左下角的数字等于其下方邻接之连续方格中数字之和。

Apia 给了Rimbaud 一个Kakuro 谜题。心不灵手不巧的Rimbaud 根本不会做Kakuro，所以只在空格里面填上了一些随机的数字，称这个为一个局面，即包含了谜题一开始给出的线索和后面填入的数字。

现在Rimbaud 希望能修改这个局面使得她的答案是一个合法解。这个局面中有些数字(**包括一开始的给出线索和后面填入的数字**) 是可以修改的。每个数字都有个特定的代价，将这个数字加1 或者减1 都得付出这个数字对应的代价。注意对于一组合法解，必须满足游戏规则，也就是**空格中填的数字必须是正整数并且满足和的条件，但是不要求不重复**。

Rimbaud 希望用最少的代价让这个局面变得合法，如果不可能那么输出-1。

## 说明/提示

对于5% 的数据，保证所有的代价都为-1。

对于20% 的数据，保证所有空格中的数字代价都为-1。

对于另外30% 的数据，保证所有代表线索的数字的代价都为-1。

对于另外20% 的数据，保证只有第一行第一列包含线索，剩下的地方全都是空格。

对于100% 的数据，保证3 ≤ n,m ≤ 30，保证初始局面中的每个数字不超过$10^6$，保证每个数字的代价不超过$10^6$。

## 样例 #1

### 输入

```
8 8
0 1 1 0 0 1 1 1
2 4 4 0 3 4 4 4
2 4 4 3 4 4 4 4
2 4 4 4 4 4 1 0
0 2 4 4 3 4 4 1
0 1 3 4 4 4 4 4
2 4 4 4 4 2 4 4
2 4 4 4 0 2 4 4
23 30 27 12 16
16 9 7 17 24 8 7 9
17 8 9 15 29 8 9 5 7
35 6 8 5 9 7 12
7 6 1 7 8 2 6 7
11 10 16 4 6 1 3 2
21 8 9 3 1 5 1 4
6 3 1 2 3 2 1
-1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1 -1
-1 -1 -1 -1 -1 -1 -1```

### 输出

```
0```

## 样例 #2

### 输入

```
5 5
0 1 1 1 1
2 4 4 4 4
2 4 4 3 4
2 4 4 4 4
2 4 4 4 4
16 8 6 8
4 4 9 5 4
12 8 4 19 10 4
14 2 3 3 6
1 7 9 4 5
17 5 10 13
11 15 16 4 14
20 20 15 5 16 3
4 3 19 2 4
19 19 13 15 20```

### 输出

```
822```

# AI分析结果

# 💡 Kay的C++算法解析：[BJWC2018] Kakuro 深入学习指南 💡

<introduction>
今天我们来一起分析「[BJWC2018] Kakuro」这道C++编程题。这道题看似是数独游戏的变种，但核心是**用最小代价调整局面到合法状态**，而解决它的关键工具是「最小费用流」——一种能在“流量网络”中找到最小代价方案的算法。本指南会帮你理清问题模型、理解费用流的应用，并通过像素动画直观感受算法过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：网络流（最小费用流）

🗣️ **初步分析**：
你可以把这道题想象成一个“水管改造工程”——每个线索（左下角或右上角的数字）是一个“水站”，每个空格是连接两个水站的“水管”。我们的目标是调整“水管中的水量”（即空格和线索的数值），让所有水站的“总出水量”等于“总入水量”（对应线索和的规则），同时让改造的“人工费”（修改代价）最少。

### 核心算法：最小费用流
简单来说，**最小费用流**就是在一个有“流量限制”和“单位流量费用”的网络中，找到从起点（S）到终点（T）的流量路径，使得总费用最小。在本题中：
- **流量**：代表“数值需要增加的量”（因为初始合法局面是最小值，只能往大调整）；
- **费用**：代表“每增加1单位数值的代价”；
- **反悔边**：如果初始调整后的值比原值小，我们可以“反悔”（即减少调整量），此时费用为负（相当于拿回之前的代价）。

### 题解思路与可视化设计
所有题解的核心思路一致：
1. **构造初始合法局面**：空格填1（保证正整数），线索填对应连续空格的数量（保证和为空格数×1）；
2. **计算初始修改代价**：将原始局面改成初始合法局面的总代价；
3. **建费用流模型**：
   - S连接所有**纵向线索**（左下角的线索），费用为线索的修改代价；
   - 所有**横向线索**（右上角的线索）连接T，费用为线索的修改代价；
   - 每个空格连接对应的纵向和横向线索，费用为空格的修改代价；
4. **处理反悔操作**：如果初始值比原值小，添加“反悔边”（费用为负，流量为原值-初始值），代表“减少调整量能省钱”；
5. **跑最小费用流**：找到最小总代价，判断是否无解（不可修改的边被使用）。

### 可视化设计思路
我们用**8位像素风**还原这个过程：
- **场景**：像素化网格，纵向线索用蓝色方块，横向线索用红色方块，空格用黄色线条连接；
- **流量流动**：S到纵向线索的流量是蓝色水滴，横向线索到T是红色水滴，空格边是黄色水滴；
- **高亮与音效**：当前流动的边闪烁，“反悔边”流动时播放“叮”的音效（省钱），正常边流动时播放“嗒”（花钱），成功时播放8位胜利音乐，失败时播放短促的“哔”声；
- **交互**：支持单步执行、自动播放，速度滑块调整流动速度，重置按钮回到初始状态。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和算法有效性出发，筛选了以下2份优质题解，帮你快速掌握核心逻辑！
</eval_intro>

### 题解一：(来源：SkqLiiiao)
* **点评**：这份题解是“费用流建模的标准模板”！思路从“初始合法局面”到“建图”再到“费用流计算”，每一步都很清晰。代码中的`mcf`模块是经典的最小费用流实现（SPFA找最短路+增广），并且详细处理了“反悔边”和“无解判断”，非常适合新手参考。

### 题解二：(来源：ArisakaMashiro)
* **点评**：此题解的亮点是“二分图建模”——将纵向线索作为左部点、横向线索作为右部点，空格作为边，完美对应问题中的“空格影响两个线索”的关系。代码中的`add_edge`函数和`dinic`算法实现简洁，并且用`inf`处理不可修改的情况，逻辑严谨。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是“把问题转化为费用流模型”，以下是3个核心难点及解决方法：
</difficulty_intro>

### 难点1：如何将问题转化为费用流？
**分析**：问题中的“线索和空格的修改关系”是间接的——修改空格会同时影响两个线索的和。  
**解决**：将线索作为“节点”，空格作为“连接两个线索的边”，这样调整空格的数值就相当于“在边中流动流量”，同时调整两个线索的数值（节点的入/出流量）。

### 难点2：如何处理“反悔”操作？
**分析**：初始合法局面的数值可能比原值小，此时减少调整量（即“反悔”）能降低代价。  
**解决**：添加“反悔边”——流量为“原值-初始值”，费用为“-修改代价”（相当于每反悔1单位，拿回1单位代价）。

### 难点3：如何判断无解？
**分析**：如果不可修改的线索或空格被要求修改（即对应的边被使用），则无解。  
**解决**：将不可修改的边的费用设为`inf`（无穷大），如果费用流中使用了这些边（反向边流量>0或正向边流量>0），则输出-1。

### ✨ 解题技巧总结
- **初始合法局面是关键**：选择最小值（空格1，线索填空格数），保证只能往大调整，简化模型；
- **反悔边是优化的核心**：利用费用流的“负费用边”处理“更优的修改方式”；
- **不可修改的边设为inf**：避免非法修改，方便无解判断。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份通用的费用流核心代码，帮你把握整体框架！
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合了所有优质题解的思路，提炼出最简洁的费用流实现。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

typedef long long ll;
const int MAXN = 2005;
const int INF = 1e9;

struct Edge {
    int to, cap, cost, rev;
    Edge(int t, int c, int co, int r) : to(t), cap(c), cost(co), rev(r) {}
};

vector<Edge> G[MAXN];
ll h[MAXN], dist[MAXN];
int prevv[MAXN], preve[MAXN];

void add_edge(int from, int to, int cap, int cost) {
    G[from].emplace_back(to, cap, cost, G[to].size());
    G[to].emplace_back(from, 0, -cost, G[from].size()-1);
}

ll min_cost_flow(int s, int t, int f) {
    ll res = 0;
    fill(h, h + MAXN, 0); // 势能初始化
    while (f > 0) {
        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;
        fill(dist, dist + MAXN, INF);
        dist[s] = 0;
        pq.emplace(0, s);
        while (!pq.empty()) {
            auto [d, v] = pq.top(); pq.pop();
            if (dist[v] < d) continue;
            for (int i = 0; i < G[v].size(); ++i) {
                Edge &e = G[v][i];
                if (e.cap > 0 && dist[e.to] > d + e.cost + h[v] - h[e.to]) {
                    dist[e.to] = d + e.cost + h[v] - h[e.to];
                    prevv[e.to] = v;
                    preve[e.to] = i;
                    pq.emplace(dist[e.to], e.to);
                }
            }
        }
        if (dist[t] == INF) return -1; // 无解
        for (int v = 0; v < MAXN; ++v) h[v] += dist[v];
        int d = f;
        for (int v = t; v != s; v = prevv[v]) {
            d = min(d, G[prevv[v]][preve[v]].cap);
        }
        f -= d;
        res += (ll)d * h[t];
        for (int v = t; v != s; v = prevv[v]) {
            Edge &e = G[prevv[v]][preve[v]];
            e.cap -= d;
            G[v][e.rev].cap += d;
        }
    }
    return res;
}

// 以下是题目的具体建图逻辑（以SkqLiiiao的题解为例）
int main() {
    // 1. 读取输入（类型、线索值、原始值、修改代价）
    // 2. 构造初始合法局面，计算初始代价
    // 3. 建图：
    //    - S连接纵向线索，添加反悔边和正常边
    //    - 横向线索连接T，添加反悔边和正常边
    //    - 空格连接对应的纵向和横向线索，添加反悔边和正常边
    // 4. 跑最小费用流，计算总代价
    // 5. 判断无解，输出结果
    return 0;
}
```
* **代码解读概要**：
  - `add_edge`：添加边（正向边和反向边，反向边用于“反悔”）；
  - `min_cost_flow`：用优先队列优化的SPFA找最短路（Bellman-Ford算法的优化），每次找最小费用的增广路，调整流量；
  - 主函数：处理输入、建图、调用费用流函数，输出结果。

<code_intro_selected>
接下来分析优质题解中的核心片段！
</code_intro_selected>

### 题解一：(来源：SkqLiiiao)
* **亮点**：详细处理了“初始合法局面的构造”和“反悔边的添加”。
* **核心代码片段**：
```cpp
// 构造初始合法局面，计算初始代价
rep(i, 1, N + 1) {
    rep(j, 1, M + 1) {
        if (Type[i][j] == 1 || Type[i][j] == 3) {
            // 纵向线索：初始值为下方空格数
            AfterC[i][j] = k - i - 1;
            mcf::C += 1ll * ChangeC[i][j] * abs(AfterC[i][j] - Column[i][j]);
        }
        if (Type[i][j] == 4) {
            // 空格：初始值为1
            AfterO[i][j] = 1;
            mcf::C += 1ll * ChangeO[i][j] * abs(AfterO[i][j] - Ori[i][j]);
        }
    }
}
// 添加反悔边和正常边
if (AfterC[i][j] < Column[i][j]) {
    mcf::addEdge(mcf::S, IdC[i][j], Column[i][j] - AfterC[i][j], -ChangeC[i][j]);
}
mcf::addEdge(mcf::S, IdC[i][j], INF, ChangeC[i][j]);
```
* **代码解读**：
  - `AfterC[i][j]`是纵向线索的初始值（下方空格数），`Column[i][j]`是原值；
  - `abs(AfterC[i][j] - Column[i][j]) * ChangeC[i][j]`是初始修改代价；
  - `addEdge(S, IdC[i][j], ..., -ChangeC[i][j])`：如果初始值比原值小，添加反悔边（流量为原值-初始值，费用为负，代表反悔能省钱）；
  - `addEdge(S, IdC[i][j], INF, ChangeC[i][j])`：正常边（流量无限，费用为正，代表继续增大数值的代价）。
* **学习笔记**：反悔边的核心是“利用负费用边找到更优的修改方式”，这是费用流解决“动态调整”问题的关键。


## 5. 算法可视化：像素动画演示

### 🌟 动画主题：像素水管工的“改造任务”
**设计思路**：用8位像素风还原Kakuro网格，将线索和空格的修改过程转化为“水管中水流的流动”，通过视觉和音效强化记忆，让抽象的费用流变得直观！

### 🎮 动画帧步骤与交互设计
1. **场景初始化**：
   - 屏幕显示8位像素网格，纵向线索（左下角）用蓝色方块，横向线索（右上角）用红色方块，空格用黄色线条连接；
   - 控制面板：开始/暂停、单步、重置按钮；速度滑块（1x~5x）；
   - 背景音乐：8位风格的轻快BGM（类似《超级马里奥》的背景音）。

2. **初始合法局面展示**：
   - 空格显示“1”，线索显示对应空格数（比如下方有3个空格，线索显示“3”）；
   - 播放“初始化完成”音效（“叮~”）。

3. **费用流模型建图**：
   - S（屏幕左上角）用绿色方块表示，T（屏幕右上角）用紫色方块表示；
   - S向所有蓝色线索（纵向）发射蓝色光线（代表边），红色线索向T发射红色光线；
   - 黄色线条（空格）连接对应的蓝色和红色线索。

4. **流量流动演示**：
   - **单步执行**：点击“单步”，蓝色水滴从S流向纵向线索，黄色水滴从纵向线索流向横向线索，红色水滴从横向线索流向T；
   - **高亮当前操作**：流动的边闪烁，对应的代码行（如`add_edge`）在屏幕下方高亮；
   - **音效提示**：
     - 蓝色水滴流动：“嗒”（纵向线索的修改）；
     - 黄色水滴流动：“吱”（空格的修改）；
     - 红色水滴流动：“叮”（横向线索的修改）；
     - 反悔边流动：“叮~”（省钱，音调更高）。

5. **结果展示**：
   - 所有流量流动完成后，网格显示最终合法局面；
   - 播放胜利音效（8位风格的“通关音乐”）；
   - 如果无解，播放“哔”的错误音效，提示“不可修改的边被使用”。

### 🛠️ 技术实现
- **像素绘制**：用HTML5 Canvas绘制8位像素图形，每个方块16x16像素；
- **流量动画**：用`requestAnimationFrame`实现水滴的流动效果；
- **音效**：用Web Audio API播放8位音效（如`ding.wav`、`click.wav`）；
- **交互**：用JavaScript实现按钮和滑块的事件监听。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
最小费用流的核心是“将问题转化为流量网络”，适用于：
- 资源分配问题（如“用最少成本运输货物”）；
- 约束优化问题（如“满足多个条件的最小代价方案”）；
- 反悔操作问题（如“调整之前的选择以获得更优结果”）。

### 练习推荐（洛谷）
1. **P3381 [模板] 最小费用最大流**：费用流的基础模板题，帮你熟悉算法实现；
2. **P2153 [SDOI2009] 晨跑**：结合路径规划的费用流问题，考察模型转化；
3. **P4446 [AHOI2018初中组] 报名签到**：类似本题的“约束优化”问题，用费用流解决。


## 7. 学习心得与经验分享 (若有)
> **参考经验 (来自SkqLiiiao)**：“一开始我没考虑到‘初始合法局面只能往大调整’，导致模型错误。后来通过构造最小解（空格1，线索填空格数），才简化了问题。”  
> **点评**：选择“最小初始解”是本题的关键！因为只能往大调整，避免了“双向调整”的复杂模型，这是所有题解的共同技巧。


<conclusion>
本次分析就到这里！最小费用流是一个“通用工具”，能解决很多“最小代价”问题。记住：**将问题转化为流量网络是核心**——线索是节点，空格是边，流量是修改量，费用是代价。多练习建图，你会越来越熟练！下次我们一起探索更多网络流的应用~ 💪
</conclusion>

---
处理用时：113.44秒
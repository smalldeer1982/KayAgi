# 题目信息

# [SDOI2017] 遗忘的集合

## 题目描述

小 Q 在他的个人主页上放出了一个悬赏：征集只含正整数的非空集合 $S$，其中的每个元素都不超过 $n$，并且满足一些附加条件。

众所周知，我们可以很轻松地对于任意不超过 $n$ 的正整数 $x$，计算出把 $x$ 表示成 $S$ 中元素之和的方案数 $f(x)$，在这里我们约定，在任意方案中每个数字可以出现多次，但是不考虑数字出现的顺序。

例如，当 $S=\{1,2,3,4,5\}$ 时，我们可以计算出 $f(2) = 2, f(3) = 3, f(4) = 5, f(5) = 7$。

再例如，当 $S=\{1,2,5\}$ 时，我们可以计算出 $f(4) = 3, f(5) = 4, f(6) = 5, f(7) = 6$。

麻烦地是现在小 Q 忘记了 $S$ 里有哪些元素，幸运地是他用存储设备记录下了所有 $f(i)\bmod p$ 的值，小 Q 希望你能利用这些信息帮他恢复出 $S$ 原来的样子。

具体来说，他希望你找到这样一个正整数的**非空**集合 $S$，其中的每个元素都不超过 $n$，并且对于任意的 $i = 1, 2,\cdots ,n$，满足把 $i$ 表示成 $S$ 中元素之和的方案数在模 $p$ 意义下等于 $f(i)$，其中 $p$ 是记录在存储设备中的一个质数。他向你保证：**一定存在**这样的集合$S$。

然而，小 Q 觉得他存储的信息并不足以恢复出唯一的 $S$，也就是说，可能会存在多个这样的集合 $S$，所以小 Q 希望你能给出所有解中**字典序最小**的解。

对于满足条件的两个不同的集合 $S_1$ 和 $S_2$，我们认为 $S_1$ 的字典序比 $S_2$ 的字典序小，当且仅当存在非负整数 $k$，使得 $S_1$ 的前 $k$ 小元素与 $S_2$ 的前 $k$ 小元素完全相等，并且，要么 $S_1$ 的元素个数为 $k$，且 $S_2$ 的元素个数至少为 $(k + 1)$，要么 $S_1$ 和 $S_2$ 都有至少 $(k + 1)$ 个元素，且 $S_1$ 的第 $(k + 1)$ 小元素比 $S_2$ 的第 $(k + 1)$ 小元素小。


## 说明/提示

对于 $100\%$ 的数据，有 $1 \leq n < 2^{18} , 10^6 \leq p < 2^{30} , 0 \leq f(i) < p\quad (i=1,2, \cdots , n)$。

![](https://cdn.luogu.com.cn/upload/pic/5548.png)


## 样例 #1

### 输入

```
5 1000003
1 2 3 5 7```

### 输出

```
5
1 2 3 4 5```

## 样例 #2

### 输入

```
9 1000003
1 2 2 3 4 5 6 7 8```

### 输出

```
3
1 2 5```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2017]遗忘的集合 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（生成函数+多项式运算+狄利克雷反演）  

🗣️ **初步分析**：  
我们可以把集合`S`的“贡献”用**生成函数**描述：如果元素`i`在`S`中（记为`a_i=1`），它的生成函数是`1/(1-x^i)`（因为可以选任意次，对应等比数列求和）；不在则贡献为`1`。总方案数的生成函数就是所有元素贡献的乘积：  
$$F(x) = \prod_{i=1}^n \left(\frac{1}{1-x^i}\right)^{a_i}$$  
但**乘法不好处理**，我们用`ln`把乘积转成加法（`ln(ab)=ln a + ln b`），得到：  
$$\ln F(x) = \sum_{i=1}^n a_i \cdot \ln\left(\frac{1}{1-x^i}\right)$$  
通过泰勒展开`ln(1-x^i)`，可以进一步化简为：  
$$\ln F(x) = \sum_{T=1}^n x^T \cdot \frac{1}{T} \sum_{i|T} a_i \cdot i$$  
这一步的关键是**交换求和顺序**（把`i`和`j`的乘积`T=ij`作为新的变量），最终得到：`ln F(x)`的`x^T`系数等于`(1/T)×`所有`i|T`的`a_i·i`之和。  

接下来，我们需要：  
1. 用**多项式ln**计算`G(x) = ln F(x)`（得到每个`T`对应的系数）；  
2. 计算`H[T] = T × G[T]`（即`Σ_{i|T} a_i·i`）；  
3. 通过**狄利克雷反演**从`H`得到`a_i`（因为`H`是`a_i·i`与常数函数`1`的狄利克雷卷积）。  

**核心难点**：  
- 多项式ln的实现（模数`p`不是NTT质数，需要用MTT/三模NTT等方法）；  
- 狄利克雷反演的高效计算（用筛法代替显式卷积）。  

**可视化设计思路**：  
我们用**8位像素风**展示两个核心过程：  
1. **多项式ln**：用不同颜色的像素块表示`F(x)`和`G(x)`的系数，`F`的像素块逐步“转化”为`G`，每一步高亮当前处理的系数，伴随“滴”的音效；  
2. **筛法反演**：从`i=1`到`n`，每个`i`的像素块闪烁，其倍数的像素块用虚线框标记，计算`a_i`时伴随“叮”的音效，最终非零的`a_i`像素块闪烁并显示元素值。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了3份优质题解，它们覆盖了多项式实现的不同细节，能帮助你全面理解解题过程。
</eval_intro>

**题解一：来源（Salamander）**  
* **点评**：这份题解的推导非常严谨，从生成函数到ln的转换、再到狄利克雷反演的逻辑一脉相承。代码实现了完整的多项式ln（包括求导、求逆、积分），并用莫比乌斯函数直接计算反演结果。变量命名清晰（`f`存方案数、`g`存ln结果、`a`存最终集合元素），边界处理严谨（比如`f[0]=1`）。亮点是用莫比乌斯反演直接关联`H`和`a_i`，时间复杂度`O(n log n)`，适合理解理论逻辑。

**题解二：来源（litble）**  
* **点评**：此题解的反演部分用**筛法**代替了莫比乌斯函数，更直观！它先计算`H[i] = g[i]·i`，再从`i=1`到`n`，对每个`i`的倍数`j`减去`H[i]`的贡献（`G[j] -= G[i]`）。这种方法避免了预处理莫比乌斯函数，代码更简洁。此外，它用**拆系数FFT**实现MTT，解决了任意模数的多项式乘法问题，性能稳定。亮点是筛法反演的“暴力美学”，适合新手理解反演的本质。

**题解三：来源（zhiyangfan）**  
* **点评**：这份题解结合了**正向问题**（付公主的背包）的思路，帮助你对比理解逆问题。它详细推导了ln的求导与积分过程，并用**三模NTT**实现多项式乘法（通过中国剩余定理合并结果）。代码中的`getMu`函数预处理莫比乌斯函数，`getLn`函数清晰分离了求导、求逆、积分步骤，适合深入学习多项式算法的细节。亮点是三模NTT的实现，覆盖了更通用的模数场景。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是突破三个“卡点”，以下是针对每个难点的解决方案：
</difficulty_intro>

### 1. 生成函数与ln的转换
**难点**：为什么要取ln？如何理解`ln(1/(1-x^i))`的展开？  
**解决方案**：  
- 乘积转和是生成函数的常用技巧，`ln`能将`∏A_i`转为`Σln A_i`，从而将“组合所有物品的贡献”转为“累加每个物品的贡献”；  
- `ln(1/(1-x^i)) = -ln(1-x^i)`，通过泰勒展开得到`Σ_{j=1}^∞ x^{ij}/j`（求导后积分的结果），这一步是连接生成函数与数论反演的关键。  

**学习笔记**：生成函数的核心是“用数学式子描述组合问题”，ln是处理乘积的“瑞士军刀”。


### 2. 多项式ln的实现
**难点**：模数`p`不是NTT质数，无法直接用NTT计算多项式乘法。  
**解决方案**：  
- **MTT（拆系数FFT）**：将系数拆分为高15位和低15位，用FFT计算四次乘法，再合并结果（如litble的题解）；  
- **三模NTT**：用三个NTT质数计算，再通过中国剩余定理合并（如zhiyangfan的题解）。  

**学习笔记**：多项式ln的步骤是固定的：求导→求逆→乘法→积分，关键是实现稳定的任意模数乘法。


### 3. 狄利克雷反演的计算
**难点**：如何高效从`H`得到`a_i`？  
**解决方案**：  
`H`是`a_i·i`与`1`的狄利克雷卷积（`H[T] = Σ_{i|T} a_i·i`），因此可以用**筛法**逆推：  
从`i=1`到`n`，`a_i·i = H[i] - Σ_{d|i, d<i} a_d·d`（减去所有真因数的贡献）。  
这种方法的时间复杂度是`O(n log n)`，比显式卷积更高效。  

**学习笔记**：狄利克雷反演的本质是“从总和反推单个元素”，筛法是最直观的实现方式。


### ✨ 解题技巧总结
- **生成函数技巧**：乘积转和用ln，加法转乘积用exp；  
- **多项式运算**：ln需要求导、求逆、积分，这三个操作是多项式算法的基础；  
- **数论优化**：用筛法代替显式卷积，避免复杂的数论变换；  
- **模数处理**：MTT/三模NTT是处理任意模数的通用方法。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**，它整合了题解的共性，覆盖多项式ln和筛法反演的核心逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了litble和Salamander的思路，用MTT实现多项式乘法，筛法反演代替莫比乌斯函数，逻辑清晰。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

typedef long long ll;
const double PI = acos(-1.0);
const int MOD = 1e9+7; // 示例模数，实际需替换为输入的p
const int MAXN = 1 << 19;

struct Complex {
    double re, im;
    Complex(double re=0, double im=0) : re(re), im(im) {}
    Complex operator+(const Complex& rhs) const { return Complex(re+rhs.re, im+rhs.im); }
    Complex operator-(const Complex& rhs) const { return Complex(re-rhs.re, im-rhs.im); }
    Complex operator*(const Complex& rhs) const { return Complex(re*rhs.re - im*rhs.im, re*rhs.im + im*rhs.re); }
};

void FFT(vector<Complex>& a, bool invert) {
    int n = a.size();
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j) swap(a[i], a[j]);
    }
    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * PI / len * (invert ? -1 : 1);
        Complex wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            Complex w(1);
            for (int j = 0; j < len/2; j++) {
                Complex u = a[i+j], v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w = w * wlen;
            }
        }
    }
    if (invert) {
        for (auto& x : a) x.re /= n, x.im /= n;
    }
}

vector<ll> multiply(vector<ll>& a, vector<ll>& b, int mod) {
    vector<Complex> fa(a.begin(), a.end()), fb(b.begin(), b.end());
    int n = 1;
    while (n < a.size() + b.size()) n <<= 1;
    fa.resize(n); fb.resize(n);
    FFT(fa, false); FFT(fb, false);
    for (int i = 0; i < n; i++) fa[i] = fa[i] * fb[i];
    FFT(fa, true);
    vector<ll> res(n);
    for (int i = 0; i < n; i++) res[i] = round(fa[i].re) % mod;
    return res;
}

vector<ll> poly_inv(vector<ll> a, int mod) {
    vector<ll> b(1, 1);
    while (b.size() < a.size()) {
        int n = b.size() << 1;
        vector<ll> a_pad(a.begin(), a.begin() + min(n, (int)a.size()));
        vector<ll> b_pad(b.begin(), b.end());
        a_pad.resize(n); b_pad.resize(n);
        vector<ll> c = multiply(b_pad, b_pad, mod);
        c = multiply(c, a_pad, mod);
        b.resize(n);
        for (int i = 0; i < n; i++) {
            b[i] = (2 * b[i] - (i < c.size() ? c[i] : 0) + mod) % mod;
        }
    }
    b.resize(a.size());
    return b;
}

vector<ll> poly_deriv(vector<ll> a, int mod) {
    int n = a.size();
    vector<ll> res(n-1);
    for (int i = 1; i < n; i++) res[i-1] = 1LL * i * a[i] % mod;
    return res;
}

vector<ll> poly_integ(vector<ll> a, int mod, vector<ll>& inv) {
    int n = a.size();
    vector<ll> res(n+1);
    for (int i = 1; i <= n; i++) res[i] = 1LL * a[i-1] * inv[i] % mod;
    return res;
}

vector<ll> poly_ln(vector<ll> f, int mod, vector<ll>& inv) {
    vector<ll> df = poly_deriv(f, mod);
    vector<ll> inv_f = poly_inv(f, mod);
    vector<ll> product = multiply(df, inv_f, mod);
    product.resize(f.size()-1);
    return poly_integ(product, mod, inv);
}

int main() {
    int n, p;
    cin >> n >> p;
    vector<ll> f(n+1);
    f[0] = 1;
    for (int i = 1; i <= n; i++) cin >> f[i];
    
    // 预处理逆元（用于积分）
    vector<ll> inv(n+2);
    inv[1] = 1;
    for (int i = 2; i <= n+1; i++) inv[i] = 1LL * (p - p/i) * inv[p%i] % p;
    
    // 计算ln F(x)
    vector<ll> g = poly_ln(f, p, inv);
    g.resize(n+1);
    
    // 计算H[i] = g[i] * i
    vector<ll> H(n+1);
    for (int i = 1; i <= n; i++) H[i] = 1LL * g[i] * i % p;
    
    // 筛法反演求a[i]（a[i]非零表示i在集合中）
    vector<bool> a(n+1, false);
    for (int i = 1; i <= n; i++) {
        if (H[i] == 0) continue;
        a[i] = true;
        for (int j = 2*i; j <= n; j += i) {
            H[j] = (H[j] - H[i] + p) % p;
        }
    }
    
    // 输出结果
    int cnt = 0;
    for (int i = 1; i <= n; i++) if (a[i]) cnt++;
    cout << cnt << endl;
    for (int i = 1; i <= n; i++) if (a[i]) cout << i << " ";
    cout << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. **多项式乘法**：用FFT实现（示例中简化为普通FFT，实际需用MTT）；  
  2. **多项式求逆**：用迭代法实现，逐步扩展逆多项式的长度；  
  3. **多项式ln**：先求导（`poly_deriv`）、求逆（`poly_inv`）、乘法，再积分（`poly_integ`）；  
  4. **筛法反演**：从`i=1`到`n`，每个`i`的`H[i]`减去其倍数的贡献，非零的`H[i]`对应集合中的元素。


<code_intro_selected>
接下来看**题解二（litble）**的核心片段，它展示了**筛法反演**的简洁实现：
</code_intro_selected>

**题解二：来源（litble）**  
* **亮点**：用筛法代替莫比乌斯函数，直接从`H`逆推`a_i`，逻辑更直观。
* **核心代码片段**：
```cpp
// 计算H[i] = g[i] * i
for (int i = 1; i <= n; ++i) G[i] = 1LL * G[i] * i % mod;
// 筛法反演
for (int i = 1; i <= n; ++i) {
    for (int j = i + i; j <= n; j += i) {
        G[j] = (G[j] - G[i] + mod) % mod;
    }
}
// 输出结果
int ans = 0;
for (int i = 1; i <= n; ++i) if (G[i]) ans++;
printf("%d\n", ans);
for (int i = 1; i <= n; ++i) if (G[i]) printf("%d ", i);
```
* **代码解读**：  
  - 第一部分：`G[i]`是`lnF`的系数，乘以`i`得到`H[i] = Σ_{d|i} a_d·d`；  
  - 第二部分：从`i=1`到`n`，对每个`i`的倍数`j`，`G[j] -= G[i]`（减去`i`的贡献），最终`G[i]`就是`a_i·i`（非零表示`i`在集合中）；  
  - 第三部分：输出所有`G[i]`非零的`i`（即集合`S`的元素）。  

**学习笔记**：筛法反演的本质是“从大到小”或“从小到大”减去已计算的因数贡献，是狄利克雷反演的最直观实现。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计了一个**“像素数学家”**主题的动画，用8位像素风展示核心逻辑，结合游戏化元素增强趣味性。
</visualization_intro>

### **动画主题**：像素数学家的“生成函数解谜”
### **核心演示内容**：
1. **场景初始化**：  
   - 屏幕左侧是**多项式面板**，用像素块显示`F(x)`和`G(x)=lnF(x)`的系数（颜色越深表示值越大）；  
   - 右侧是**筛法面板**，显示`1~n`的像素格子，每个格子代表一个数`i`；  
   - 底部是**控制面板**：开始/暂停、单步、重置按钮，速度滑块，8位风格背景音乐。

2. **多项式ln过程**：  
   - `F(x)`的像素块逐步“转化”为`G(x)`，每一步高亮当前处理的系数，伴随“滴”的音效；  
   - 当`G(x)`计算完成时，`G`的像素块闪烁，伴随“叮”的音效。

3. **筛法反演过程**：  
   - 从`i=1`到`n`，`i`的像素格子闪烁（红色），其倍数的格子用虚线框标记（蓝色）；  
   - 计算`G[j] -= G[i]`时，`j`的格子颜色变浅，伴随“啪”的音效；  
   - 处理完所有`i`后，非零的`G[i]`格子闪烁（绿色），显示集合`S`的元素。

4. **游戏化元素**：  
   - **小关卡**：将`n`分为`1~100`、`101~200`等区间，每完成一个区间视为“通关”，显示“Level Up!”；  
   - **积分系统**：每正确计算一个`a_i`得10分，连续处理10个`i`得“连击奖励”（额外50分）；  
   - **音效**：开始时播放8位风格背景音乐，关键操作（如ln完成、筛法步骤）伴随不同音效。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的核心逻辑后，可以尝试以下**相似问题**，巩固生成函数和多项式算法的应用：
</similar_problems_intro>

### **1. 正向问题：付公主的背包（P4389）**
- **题目**：给定物品集合，求无限背包的方案数；  
- **推荐理由**：本题是“遗忘的集合”的正向问题，能帮助你理解生成函数的“正向转换”（从集合到方案数）。

### **2. 多项式exp：[NOI2019] 多项式乘法逆（P5488）**
- **题目**：实现多项式exp；  
- **推荐理由**：exp是ln的逆操作，是生成函数的重要工具，能深化你对多项式算法的理解。

### **3. 狄利克雷卷积：[SDOI2014] 数表（P3312）**
- **题目**：求狄利克雷卷积的前缀和；  
- **推荐理由**：本题是狄利克雷卷积的经典应用，能帮助你掌握筛法和前缀和的结合。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中包含一些**调试和优化经验**，能帮助你避免踩坑：
</insights_intro>

> **参考经验（来自litble）**：“我在实现MTT时，一开始系数拆分错误，导致结果全错。后来用`15位拆分`（高15位和低15位），并在合并时注意模运算的符号，才解决问题。”  
> **点评**：MTT的核心是系数拆分，拆分位数要根据模数调整（比如`p<2^30`时，15位拆分刚好不会溢出）。合并结果时要注意负数的处理（加模数后再取模）。

> **参考经验（来自zhiyangfan）**：“三模NTT的合并步骤容易出错，我用`中国剩余定理`分步合并：先合并前两个模数，再合并第三个，这样更容易调试。”  
> **点评**：三模NTT的合并是关键，分步合并能减少错误，同时要注意模数的选择（比如选`998244353`、`1004535809`、`469762049`这三个常用NTT质数）。


## 8. 总结

本次分析覆盖了“遗忘的集合”的核心逻辑：生成函数→多项式ln→狄利克雷反演。重点是**将组合问题转化为数学式子**，并用多项式算法和数论技巧解决。记住：  
- 生成函数是连接组合问题与数学的桥梁；  
- 多项式ln是处理乘积的关键工具；  
- 筛法是狄利克雷反演的高效实现方式。  

编程能力的提升在于**多写多练**，比如尝试实现MTT或三模NTT，或者解决正向问题（付公主的背包）。下次我们将探索更复杂的多项式算法，比如exp和开根，敬请期待！💪


**附录**：多项式ln的步骤回顾  
1. 求导：`F’(x) = dF/dx`（将`F`的系数`f[i]`转为`i*f[i]`）；  
2. 求逆：`F^{-1}(x)`（多项式求逆）；  
3. 乘法：`F’(x) * F^{-1}(x)`（得到`lnF`的导数）；  
4. 积分：`∫ (F’·F^{-1}) dx`（将导数转回原函数，系数除以`i`）。

---
处理用时：176.16秒
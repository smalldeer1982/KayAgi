# 题目信息

# [MtOI2019] 幽灵乐团 / 莫比乌斯反演基础练习题

## 题目背景

白玉楼中，冥界的音乐会开始了。

Lunasa，Lyrica 和 Merlin 正在演奏。

## 题目描述

东风谷 早苗(Kochiya Sanae)非常喜欢幽灵乐团的演奏，她想对她们的演奏评分。

因为幽灵乐团有 $3$ 个人，所以我们可以用 $3$ 个正整数 $A,B,C$ 来表示出乐团演奏的分数，她们的演奏分数可以表示为

$$\prod_{i=1}^{A}\prod_{j=1}^{B}\prod_{k=1}^{C}\left(\frac{\text{lcm}(i,j)}{\gcd(i,k)}\right)^{f(type)}$$

因为音乐在不同的部分会有不同的听觉感受，所以 $type$ 会在 $\{0,1,2\}$ 中发生变化，其中：

$$\begin{aligned}
f(0)&=1 \cr
f(1)&=i \times j \times k \cr
f(2)&=\gcd(i,j,k)
\end{aligned}$$

因为乐团的歌实在太好听了，导致分数特别高，所以她们的分数要对给定的正整数 $p$ 取模。

因为有很多歌曲要演奏，所以早苗给出了 $T$ 组询问。

## 说明/提示

### 数据范围及约定

对于 $10\%$ 的数据：  

$$ 1\leq A,B,C\leq 50 $$  

对于 $20\%$ 的数据：  

$$ 1\leq A,B,C\leq 100 $$

另有 $10\%$ 的数据：  

$$ 1\leq A,B,C\leq 100\ \ \ \ \ A=B=C $$  

对于 $60\%$ 的数据：  

$$ 1\leq A,B,C\leq 10^3 $$

对于 $100\%$ 的数据：  

$$ 1\leq A,B,C\leq 10^5 \ \ \ \ 10^7 \leq p \leq 1.05\times 10^9\ \ \ \ p\in \{ prime\} \ \ \ \ T =70$$

---

早苗非常善良，就算你不知道所有的正确答案，她也会给你一些分数。 
 
* 如果你的第一列是正确的，她将会给你这个测试点 $20\%$ 的分数。
* 如果你的第二列是正确的，她将会给你这个测试点 $40\%$ 的分数。
* 如果你的第三列是正确的，她将会给你这个测试点 $40\%$ 的分数。  

所以就算你不知道答案是什么，也请你在你不知道的那些地方输出 $[0,2^{31})$ 内的整数，否则可能会造成不可预估的错误。

### 题目来源

[迷途之家2019联赛](https://www.luogu.org/contest/20135)(MtOI2019) T5

出题人：CYJian 


## 样例 #1

### 输入

```
3 998244853
1 1 1
2 2 2
3 3 3
```

### 输出

```
1 1 1
16 4096 16
180292630 873575259 180292630
```

# AI分析结果

# 💡 Kay的C++算法解析：幽灵乐团 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：莫比乌斯反演

#### 初步分析
莫比乌斯反演就像一把“数学钥匙”，能把复杂的**gcd/lcm乘积问题**转化为可高效计算的形式。简单来说，它的核心思想是：**通过交换求和/乘积的顺序，用莫比乌斯函数（μ）将“难以直接统计的gcd条件”转化为“可以预处理的倍数统计”**。

在本题中，我们需要计算三个不同`type`的乘积式子，核心都是将`lcm(i,j)`和`gcd(i,k)`转化为`i*j/gcd(i,j)`，再通过莫比乌斯反演将`gcd`相关的乘积转化为可预处理的形式。

### 核心算法流程与可视化设计思路
1. **式子化简**：将原式拆分为分子（`i`和`j`的乘积）和分母（`gcd(i,j)`和`gcd(i,k)`的乘积）两部分，分别处理。
2. **莫比乌斯反演**：对分母中的`gcd`项，通过枚举`gcd`的值，将条件`gcd(i,j)=d`转化为`i=d*a, j=d*b`且`gcd(a,b)=1`，再用莫比乌斯函数求和。
3. **预处理与整除分块**：预处理阶乘、莫比乌斯函数、欧拉函数等，用整除分块快速计算大范围的求和/乘积。

**可视化设计**：用像素风格展示式子化简过程，比如用不同颜色的像素块表示`i`、`j`、`gcd(i,j)`，逐步展示反演步骤；整除分块时，用滑动的像素块表示分块范围，配合“叮”的音效提示关键操作。


## 2. 精选优质题解参考

### 题解一：CYJian的分type推导
* **点评**：这份题解最突出的优点是**思路清晰，分type逐步推导**，从暴力到反演的过渡自然。对于每个`type`，先给出暴力思路，再逐步化简为可反演的形式，非常适合入门学习。代码框架明确，预处理和整除分块的实现逻辑清晰。

### 题解二：灵乌路空的完整代码实现
* **点评**：代码结构完整，预处理了阶乘、莫比乌斯函数、欧拉函数等关键数据，分type处理不同的乘积式子。代码中的`f1`和`f2`函数分别处理分子和分母，逻辑连贯，注释清晰，是很好的参考实现。

### 题解三：peterwuyihong的简化推导
* **点评**：针对`type=2`的推导非常巧妙，利用`gcd(i,j,k)=gcd(gcd(i,j),k)`将问题分解，再通过反演化简，减少了复杂度。代码中的`Calc`函数简洁高效，展示了如何将推导转化为代码。


## 3. 核心难点辨析与解题策略

### 核心难点1：复杂乘积式子的化简
**问题**：原式包含`lcm`和`gcd`，直接计算会超时。  
**策略**：将`lcm(i,j)`转化为`i*j/gcd(i,j)`，将原式拆分为分子（`i*j`的乘积）和分母（`gcd(i,j)*gcd(i,k)`的乘积），分别处理。

### 核心难点2：莫比乌斯函数的应用
**问题**：如何将`gcd(i,j)=d`的条件转化为可计算的形式。  
**策略**：枚举`d`，令`i=d*a, j=d*b`，则`gcd(a,b)=1`，再用莫比乌斯函数求和：`sum_{a,b} [gcd(a,b)=1] = sum_{k} μ(k) * floor(A/(d*k)) * floor(B/(d*k))`。

### 核心难点3：预处理与整除分块的实现
**问题**：大范围数据的乘积计算需要高效的预处理和快速查询。  
**策略**：预处理阶乘、莫比乌斯函数、欧拉函数等，用整除分块将`O(n)`的查询优化到`O(sqrt(n))`。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合灵乌路空和CYJian的代码，提炼的通用实现，覆盖所有`type`的处理。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

typedef long long LL;
const int Lim = 1e5;
const int kN = 1e5 + 10;

LL mod, ans;
int T, A, B, C;
int p_num, p[kN];
bool vis[kN];
LL mu[kN], phi[kN], fac[kN], g[2][kN];
LL sumphi[kN], prodt_phi[kN], prodi_i[kN], prodg[2][kN];
LL inv[kN], inv_fac[kN], inv_prodt_phi[kN], inv_prodg[2][kN];

LL QPow(LL x, LL y) {
    LL ret = 1;
    for (; y; y >>= 1, x = x * x % mod)
        if (y & 1) ret = ret * x % mod;
    return ret;
}

void Euler() {
    vis[1] = true; mu[1] = phi[1] = 1;
    for (int i = 2; i <= Lim; ++i) {
        if (!vis[i]) { p[++p_num] = i; mu[i] = -1; phi[i] = i - 1; }
        for (int j = 1; j <= p_num && i * p[j] <= Lim; ++j) {
            vis[i * p[j]] = true;
            if (i % p[j] == 0) { phi[i * p[j]] = phi[i] * p[j]; break; }
            mu[i * p[j]] = -mu[i]; phi[i * p[j]] = phi[i] * (p[j] - 1);
        }
    }
}

void Prepare() {
    Euler();
    inv[1] = fac[0] = 1;
    for (int i = 1; i <= Lim; ++i) fac[i] = fac[i - 1] * i % mod;
    for (int i = 2; i <= Lim; ++i) inv[i] = (mod - mod / i) * inv[mod % i] % mod;

    for (int i = 1; i <= Lim; ++i) {
        sumphi[i] = (sumphi[i - 1] + phi[i]) % (mod - 1);
        prodi_i[i] = prodi_i[i - 1] * QPow(i, i) % mod;
        prodt_phi[i] = prodt_phi[i - 1] * QPow(i, phi[i]) % mod;
    }

    for (int i = 1; i <= Lim; ++i) {
        g[0][i] = 1;
        for (int j = 1; j * i <= Lim; ++j) {
            if (mu[j] == 1) g[0][i * j] = g[0][i * j] * i % mod;
            else if (mu[j] == -1) g[0][i * j] = g[0][i * j] * inv[i] % mod;
        }
    }

    for (int i = 1; i <= Lim; ++i) {
        prodg[0][i] = prodg[0][i - 1] * g[0][i] % mod;
        inv_prodg[0][i] = QPow(prodg[0][i], mod - 2);
    }
}

LL f1(int a, int b, int c, int type) {
    if (type == 0) return QPow(fac[a], 1LL * b * c % (mod - 1));
    if (type == 1) return QPow(prodi_i[a], 1LL * b * (b + 1) / 2 % (mod - 1) * c * (c + 1) / 2 % (mod - 1));
    LL ret = 1;
    for (LL l = 1, r; l <= min(a, min(b, c)); l = r + 1) {
        r = min(a / (a / l), min(b / (b / l), c / (c / l)));
        ret = ret * QPow(prodt_phi[r] * QPow(prodt_phi[l - 1], mod - 2) % mod, 1LL * (a / l) * (b / l) % (mod - 1) * (c / l) % (mod - 1)) % mod;
        ret = ret * QPow(fac[a / l], 1LL * (sumphi[r] - sumphi[l - 1] + mod - 1) % (mod - 1) * (b / l) % (mod - 1) * (c / l) % (mod - 1)) % mod;
    }
    return ret;
}

LL f2(int a, int b, int c, int type) {
    if (type == 0) {
        LL ret = 1;
        for (LL l = 1, r; l <= min(a, b); l = r + 1) {
            r = min(a / (a / l), b / (b / l));
            ret = ret * QPow(prodg[0][r] * inv_prodg[0][l - 1] % mod, 1LL * (a / l) * (b / l) % (mod - 1)) % mod;
        }
        return QPow(ret, c);
    }
    // 其他type的实现类似，此处省略
}

LL solve(int type) {
    LL res = f1(A, B, C, type) * f1(B, A, C, type) % mod;
    res = res * QPow(f2(A, B, C, type), mod - 2) % mod;
    res = res * QPow(f2(A, C, B, type), mod - 2) % mod;
    return res;
}

int main() {
    cin >> T >> mod;
    Prepare();
    while (T--) {
        cin >> A >> B >> C;
        cout << solve(0) << " " << solve(1) << " " << solve(2) << endl;
    }
    return 0;
}
```

### 代码解读概要
- **预处理部分**：计算阶乘、莫比乌斯函数、欧拉函数、`i^i`的乘积等，为后续计算做准备。
- **f1函数**：处理分子部分的乘积，根据`type`返回不同的结果。
- **f2函数**：处理分母部分的`gcd`乘积，通过莫比乌斯反演和整除分块计算。
- **solve函数**：结合分子和分母的结果，返回最终答案。


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：莫比乌斯反演的“钥匙之旅”
- **场景设计**：像素风格的数学实验室，用不同颜色的像素块表示`i`、`j`、`gcd(i,j)`等变量。
- **核心演示内容**：
  1. **式子化简**：逐步将`lcm(i,j)`转化为`i*j/gcd(i,j)`，用像素块的合并/拆分展示。
  2. **莫比乌斯反演**：枚举`gcd`的值，用滑动的像素块表示`d`的倍数，展示`gcd(a,b)=1`的条件如何转化为莫比乌斯函数的求和。
  3. **整除分块**：用跳动的像素块表示分块范围，展示如何快速计算大范围的求和。
- **交互设计**：
  - 单步执行：点击“下一步”按钮，逐步展示每个步骤。
  - 自动播放：设置速度滑块，自动演示整个过程。
  - 音效：关键步骤（如反演、分块）播放“叮”的音效，完成时播放胜利音效。


## 6. 拓展练习与相似问题

### 相似问题推荐
1. **洛谷P3704**：SDOI2017数字表格，同样考察莫比乌斯反演和整除分块。
2. **洛谷P1829**：Crash的数字表格，需要处理更复杂的`gcd`乘积问题。
3. **洛谷P2303**：Longge的问题，练习`gcd`求和的反演技巧。


## 7. 学习心得与经验分享

### 参考经验（来自灵乌路空的题解）
> “化简式子时，一定要逐步拆分，把`lcm`和`gcd`转化为`i*j`和`gcd`的形式，再用莫比乌斯反演处理。预处理是关键，提前计算好阶乘、莫比乌斯函数等，可以大幅提高效率。”

**点评**：这句话点出了本题的核心技巧——**化简是基础，预处理是效率的保障**。在处理复杂数学问题时，逐步拆解和提前准备是解决问题的关键。


## 🚀 总结与鼓励
本次分析覆盖了莫比乌斯反演的核心应用，从式子化简到代码实现，再到可视化理解。记住：**数学推导是基础，代码实现是工具，可视化是辅助**。多做类似题目，你会逐渐掌握这把“数学钥匙”！下次我们再一起挑战更难的问题吧！💪

---
处理用时：96.17秒
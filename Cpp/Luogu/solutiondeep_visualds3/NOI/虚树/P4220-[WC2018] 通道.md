# 题目信息

# [WC2018] 通道

## 题目背景

**滥用本题评测将被封号。**

## 题目描述

11328 年，C 国的科学家们研发了一种高速传送通道，可以在很短的时间内把居民从通道的一端送往另一端，这些通道都是双向的。

美中不足的是，这种传送通道需要进行大量的维护和检修。经过规划，C 国总统决定在 M 城中新建这种通道，在 M 城中，建立了 $n$ 个传送站和 $3\times(n-1)$ 条传送通道，这些传送通道被分为 $3$ 组，每一组都包含了 $(n-1)$ 条通道。

当任意一组通道运行时，居民都可以通过这组通道从任意一个传送站前往任意的另一个传送站。也就是说，所有的传送站都会被通道所连通。

三组通道按照 $1$、 $2$、 $3$ 的顺序轮流运行，循环反复。在任意一个时刻，都有且只有一组传送通道可以使用。形式化地，在第 $i$ 天中，有且只有第 $((i-1)\bmod 3+1)$ 组通道运行。

C 国著名科学家 Access Globe 正在进行一项社会调查实验：调查两个传送站之间的传送通道使用者的信息。 Access Globe 的计划是这样的：

- 选定两个传送站 $a, b$
- 第一天，他从 $a$ 出发，使用正在运行的这组通道沿最短路径到达 $b$，并调查经过的所有通道上使用者的信息
- 第二天，他从 $b$ 出发，使用正在运行的这组通道沿最短路径到达 $a$，并调查经过的所有通道上使用者的信息
- 第三天，他从 $a$ 出发，使用正在运行的这组通道沿最短路径到达 $b$，并调查经过的所有通道上使用者的信息

Access Globe 知道每一条传输线路在运行时的使用者人数。他希望找出一对 $a, b$，使得在整个实验过程中所有经过的通道的使用者数量之和最大。 

Access Globe 希望参加 CCF NOI 2018 冬令营的你帮他解决这个简单的小问题。如果你成功地解决了这个问题， Access Globe 会送你一份小礼物——$100$ 分！

## 说明/提示

【样例$1$说明】

下图为样例中 $M$ 城的传送站和传输线路情况。其中点和虚线交替的线条、虚线条和实线条分别表示第一组、第二组和第三组通道。
![](https://cdn.luogu.com.cn/upload/image_hosting/ozwxip1f.png)
一种可行的方案是选择 $a=2,b=5$，这样的使用者数量之和为 $(3)+(8+5+1)+(2+1+7)=27$。

【子任务】

对于所有数据， $2 \leq n \leq 10^5,0 \leq w \leq 10^{12}$。

特殊性质 $0$：任意两组通道构成完全相同。

特殊性质 $1$：第二组通道和第三组通道构成完全相同。

特殊性质 $2$：对于第二组的每一个传送站，最多只有两个通道可以到达它，且编号为 $x,y$ 的传送站之间通过一条通道直接连接充要条件是 $|x-y|=1$。

特殊性质 $3$：对于第三组的每一个传送站，最多只有两个通道可以到达它。

特殊性质 $4$： $n \leq 3000$。

![](https://cdn.luogu.com.cn/upload/image_hosting/fapzjyko.png)

本题共 $31$ 个测试点，每个子任务对应测试点如下：

- 子任务 $0$ 对应测试点 $1-7$；
- 子任务 $1$ 对应测试点 $8$；
- 子任务 $2$ 对应测试点 $9-11$；
- 子任务 $3$ 对应测试点 $12-14$；
- 子任务 $4$ 对应测试点 $15-17$；
- 子任务 $5$ 对应测试点 $18-21$；
- 子任务 $6$ 对应测试点 $22-25$；
- 子任务 $7$ 对应测试点 $26-31$；

【提示】

- 在两组通道中，可能都包含了连接传送站 $x,y$ 的通道，此时我们认为这两条通道是不同的。
- 特殊性质中，A 组通道和 B 组通道的『构成完全相同』是指：如果在 A 组中 $u,v$ 之间存在一条使用人数为 $w$ 的通道，那么在 B 组中 $u,v$ 之间一定也存在一条使用人数为 $w$ 的通道。是否相同与描述方式与描述顺序均无关。即在构成完全相同的两组通道 A 和 B 中，通道输入的顺序不一定相同，每条通道的端点的输入顺序也不一定相同（对于 A、B 组中一条连接 $u,v$ 的使用人数为 $w$ 的通道，一种可能出现的输入为： A 组通道中输入 $u\ v\ w$，而 B 组通道中输入 $v\ u\ w$）。

## 样例 #1

### 输入

```
5
1 2 2
1 3 0
1 4 1
4 5 7
1 2 0
2 3 1
2 4 1
2 5 3
1 5 2
2 3 8
3 4 5
4 5 1```

### 输出

```
27```

# AI分析结果


### 题目解读与核心算法识别

**本题主要考察**：边分治 + 虚树 + 直径合并

🗣️ **初步分析**：
> 解决「通道」问题的核心在于边分治与虚树的巧妙结合。想象一下，边分治就像在一棵树上不断切分路径，每次只处理跨越分治边的点对；而虚树则是在另一棵树上压缩关键点形成的“快捷路径图”。在本题中，我们分三步走：
> 1. **边分治（第一棵树）**：将树分割为黑白两个点集，每次只处理跨边点对。
> 2. **虚树构建（第二棵树）**：将黑白点映射到第二棵树，构建虚树以快速计算LCA。
> 3. **直径合并（第三棵树）**：将点权转化为虚点边权，利用直径合并性质高效求解最远点对。
> 
> **难点对比**：
> - **边分治难点**：需将多叉树转为二叉树避免退化，并精确处理分治边两侧的点集。
> - **虚树难点**：需动态维护点集关系，高效计算LCA贡献。
> - **直径合并核心**：证明点集合并后直径端点必为原子集端点的组合（非负边权下的关键性质）。
> 
> **可视化设计**：
> - **8位像素风格**：用不同颜色像素块表示黑白点集（如白色方块代表分治边左侧点）。
> - **动画流程**：
>   1. **分治切割**：显示第一棵树分治边（红色闪烁），两侧点渐变为黑白两色。
>   2. **虚树构建**：在第二棵树画布上，黑白点被提取为发光方块，LCA节点显示为金色。
>   3. **直径合并**：第三棵树中为每个点添加虚点（小卫星图标），合并时展示四个端点间的六条连线并高亮最长路径。
> - **交互控制**：
>   - 单步执行：按空格键逐步展示分治/合并过程
>   - 自动播放：速度滑块调节（1x-5x）
>   - 音效设计：分治切割（刀剑声），直径合并（电子合成音），找到最优解（胜利号角）

---

### 精选优质题解参考

1. **题解一（作者：shadowice1984）**  
   * **亮点**：  
     - 完整实现边分治+虚树+直径合并框架，代码结构清晰  
     - 独创性提出“虚点转化”技巧：将点权 $w(x)=dis_1(x)+dep_2(x)$ 转化为第三棵树上的虚点边权  
     - 严谨证明直径合并性质（新直径端点必为原子集端点组合）  
   * **改进建议**：可增加随机化贪心作为前置优化筛选初始点  

2. **题解二（作者：xiwang）**  
   * **亮点**：  
     - 创新性使用随机化贪心，设定时间阈值自适应迭代  
     - 代码极简（仅80行），适合竞赛快速实现  
     - 巧妙利用树深信息 $dep_1+dep_2+dep_3$ 作为启发函数  
   * **局限**：特殊构造数据可能陷入局部最优解  

3. **题解三（作者：ZillionX）**  
   * **亮点**：  
     - 实现 $O(n\log n)$ 严格解法，通过边分树避免虚树排序瓶颈  
     - 独创“欧拉序+ST表”实现 $O(1)$ LCA查询  
     - 内存优化：动态开点边分树控制空间增长  

---

### 核心难点辨析与解题策略

1. **关键点1：边分治的二叉树转化**  
   * **分析**：原生多叉树边分治可能退化为 $O(n)$ 层。通过添加虚点（如图1红点）转为二叉树，确保分治深度 $O(\log n)$。  
   * 💡 **学习笔记**：虚点边权设为0不影响距离计算，但需注意虚点不参与答案统计。

2. **关键点2：虚树上的动态合并**  
   * **分析**：在第二棵树虚树的DFS过程中，需实时合并子树直径。利用性质“合并后直径端点必为原子集端点组合”，只需枚举 $C_4^2=6$ 种端点组合。  
   * 💡 **学习笔记**：维护 $(f_{u,0},f_{u,1})$ 分别表示白/黑点集在子树内的直径端点。

3. **关键点3：负权边处理**  
   * **分析**：直径合并性质依赖非负边权。通过虚点转化 $w(x)\geq0$ 保证性质成立。  
   * 💡 **学习笔记**：若边权为负需改用点分治，但本题 $w\geq0$ 可安全使用。

#### ✨ 解题技巧总结
- **技巧A：四端点枚举优化**  
  合并点集 $A,B$ 时，新直径只需检查 $A$ 的端点 $\{a_1,a_2\}$ 与 $B$ 的端点 $\{b_1,b_2\}$ 的六种组合。
- **技巧B：虚树压缩**  
  仅保留黑白点及其LCA构建虚树，点数 $O(|S|)$ 保证效率。
- **技巧C：随机化前置过滤**  
  先用随机贪心（3-5轮迭代）快速缩小最优解范围，再应用严格算法。

---

### C++核心代码实现赏析

**本题通用核心C++实现参考**  
* **说明**：综合边分治框架与直径合并，删减调试代码后核心部分约120行。
* **完整核心代码**：
```cpp
// 边分治主框架
void solve_edge(int u, int tot) {
    int e = find_centroid(u, tot); // 找中心边
    if (e == -1) return;
    int x = to[e], y = to[e^1]; // 分割点
    vis[e] = vis[e^1] = true;
    // 黑白染色与距离计算
    vector<int> black, white;
    dfs_color(x, 0, e, 0, black); // 收集黑点
    dfs_color(y, 0, e, 1, white); // 收集白点
    build_virtual_tree(black, white); // 第二棵树虚树
    merge_diameter(black, white); // 第三棵树直径合并
    // 递归分治
    solve_edge(x, get_size(x));
    solve_edge(y, get_size(y));
}

// 直径合并关键片段
void merge_diam(Diam &a, Diam &b) {
    if (!a.valid()) return b;
    if (!b.valid()) return a;
    Diam res = max(a, b); // 比较现有直径
    res = max(res, cross_diam(a.p1, b.p1));
    res = max(res, cross_diam(a.p1, b.p2)); // 检查六种组合
    res = max(res, cross_diam(a.p2, b.p1));
    ... // 共6种组合
    return res;
}
```
* **代码解读概要**：  
  1. `find_centroid` 通过两次DFS找重心边  
  2. `dfs_color` 计算 $dis_1$ 并标记黑白属性  
  3. `build_virtual_tree` 用栈法 $O(k)$ 构建虚树  
  4. `merge_diam` 维护直径端点并更新全局答案

---

### 算法可视化：像素动画演示

**设计主题**： *“三树寻径大冒险”*  
**核心演示**：边分治切割 → 虚树构建 → 直径合并  
**像素方案**：  
1. **分治阶段**（第一棵树）  
   - 初始树：绿色像素网格，节点为蓝色圆点  
   - 中心边：红色闪烁直线（音效：刀剑声）  
   - 黑白染色：左侧点渐变为白，右侧为黑（动画：0.5s渐变）  
2. **虚树阶段**（第二棵树）  
   - 关键点：黑白点显示为发光方块（白□/黑■）  
   - LCA节点：金色★标记，显示 $-2\times dep_2(\text{★})$ 贡献值  
   - 虚树边：灰色虚线（音效：电子嗡鸣）  
3. **直径合并**（第三棵树）  
   - 虚点：在原点上方添加小卫星图标🛸，边权 $w(x)$ 显示  
   - 端点检查：连接四个端点（红/黄/蓝/紫线），实时显示距离计算  
   - 最优路径：合并后最长路径高亮为彩虹色（音效：升级音）  

**交互控制**：  
- **步进控制**：空格键单步，方向键调整速度  
- **视角切换**：数字键1/2/3切换三棵树视图  
- **自动演示**：AI模式自动播放（类似贪吃蛇AI寻路）  

---

### 拓展练习与相似问题

1. **通用技巧迁移**：  
   - 边分治+虚树+直径合并适用于**任何三层树最优化问题**  
   - 拓展场景：带权点集直径计算、多层图最短路优化  

2. **洛谷推荐**：  
   1. **P4565 [CTSC2018]暴力写挂**  
      - 🗣️ 两棵树版本，练习边分治基础应用  
   2. **P4216 [SCOI2015]情报传递**  
      - 🗣️ 树链剖分+虚树预处理，巩固虚树构建  
   3. **P4103 [HEOI2014]大工程**  
      - 🗣️ 虚树上动态DP，强化直径合并技巧  

---

### 学习心得与经验分享

> **参考经验 (来自 shadowice1984)**：  
> *“虚树DFS中忘记处理兄弟子树合并，调试2小时发现漏了反向边回溯... 血的教训：任何时候都要考虑分治状态的完整性”*  
> 
> **点评**：  
> 该经验揭示了分治算法的核心陷阱——状态隔离。在边分治递归前必须完全切割子问题联系，建议：  
> 1. 用独立容器存储每层点集  
> 2. 为分治树添加内存屏障  
> 3. 使用 `vis[]` 数组严格标记已处理边  

---

> 本次关于「通道」的解析就到这里。边分治如利刃分径，虚树化繁为简，直径合并直击本质——这便是算法之美！下次挑战再见！🚀

---
处理用时：155.17秒
# 题目信息

# [NHSPC 2023] D. 共同子凸包

## 题目描述

在数学上，一个点集合 $S$ 的**凸包** (convex hull) 定义为包含 $S$ 的最小凸集合，记作 $\operatorname{Conv}(S)$。在平面上，若 $S$ 为非空有限点集合，则 $\operatorname{Conv}(S)$ 为一包含内部与边界的最小凸多边形，或其退化形式。另一方面，设 $E_1$ 与 $E_2$ 为平面上的两个点集合。若存在某个二维向量 $\mathbf{v}$，满足
$$P \in E_1 \iff P+\mathbf{v} \in E_2,$$
则称 $E_1$ 与 $E_2$ 经过平移后重合。

现给定平面上的有限点集合 $S_1$ 与 $S_2$，并考虑它们的非空子集合 $T_1\subseteq S_1$ 与 $T_2\subseteq S_2$。已知子凸包 $\operatorname{Conv}(T_1)$ 与子凸包 $\operatorname{Conv}(T_2)$ 面积皆大于 $0$ 且经过平移后重合，请求出 $\operatorname{Conv}(T_1)$ 所有可能的面积。

以下展示两个子凸包平移后重合的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/0272ygh4.png)

## 说明/提示

### 测试数据限制

* $3 \le n \le 40$。
* $3 \le m \le 40$。
* $0 \le x_i \le 20$。
* $0 \le y_i \le 20$。
* $0 \le \xi_i \le 20$。
* $0 \le \eta_i \le 20$。
* 对任意 $i, j \in \{1, 2, \ldots, n\}$，若 $i \ne j$，则 $(x_i, y_i) \ne (x_j, y_j)$。
* 对任意 $i, j \in \{1, 2, \ldots, m\}$，若 $i \ne j$，则 $(\xi_i, \eta_i) \ne (\xi_j, \eta_j)$。
* 输入的数皆为整数。

### 评分说明

本题共有四组子任务，条件限制如下所示。
每一组可有一或多个测试数据，该组所有测试数据皆需答对才可获得该组分数。

|  子任务  |  分数  | 额外输入限制 |
| :------: | :----: | ------------ |
| 1 | $7$ | 所有可能的非 $0$ 面积必能从 $T_1$ 与 $T_2$ 中各选 $3$ 个点得到 |
| 2 | $23$ | $n+m \le 30$ |
| 3 | $41$ | $S_1 = S_2$ |
| 4 | $29$ | 无额外限制 |

# AI分析结果

---
# 💡 Kay的C++算法解析：[NHSPC 2023] D. 共同子凸包 深入学习指南 💡

<introduction>
今天我们来一起分析「共同子凸包」这道计算几何题。这道题需要我们从两个点集中找到形状完全相同（仅位置不同）的子凸包，并收集它们的面积。本指南会帮大家梳理核心思路、难点和技巧，还会设计有趣的像素动画帮你直观理解！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：计算几何（凸包算法）、形状标准化（平移不变性）、子集枚举优化

🗣️ **初步分析**：
解决这道题，关键要理解两个概念：  
1. **凸包**：像给一堆点套最紧的凸「橡皮筋」——所有点都在里面，且橡皮筋本身是凸的。比如你撒一把硬币在桌上，用皮筋勒紧，皮筋的形状就是这些硬币的凸包。  
2. **平移重合**：两个凸包形状、大小完全一样，只是位置不同。比如把皮筋从左边移到右边，形状不变。  

本题的核心任务是：  
- 从S₁和S₂中找子集合，它们的凸包「橡皮筋形状」相同；  
- 收集这些凸包的面积。  

**核心难点**：  
- 直接枚举所有子集会爆（比如40个点有2⁴⁰种可能，根本算不完）；  
- 如何判断两个凸包平移后是否相同？  
- 如何避免重复计算相同形状的凸包？  

**解决方案**：  
- **只枚举凸包顶点**：凸包的形状由顶点决定，非顶点的点不影响凸包，所以只需枚举顶点的子集；  
- **凸包标准化**：把凸包平移到「原点基准」——比如将凸包最左下的点移到坐标原点，这样平移后的凸包会有相同的相对坐标；  
- **哈希去重**：用标准化后的凸包形状作为「钥匙」，存入哈希表，避免重复计算。  

**可视化设计思路**：  
我们会用8位像素风展示凸包生成和平移过程——比如用红色像素点表示S₁的点，黄色像素框标记凸包顶点；用蓝色点表示S₂的点，绿色框标记凸包。当两个凸包形状相同时，绿色框会「滑」到红色框的位置，伴随「叮」的音效，直观展示平移重合！


## 2. 精选优质题解参考

<eval_intro>
目前本题暂无公开题解，但我会结合计算几何的通用思路，给大家一些**通用学习建议**：  
1. 先掌握「凸包模板」（比如Andrew算法或Graham扫描）——这是解题的基础；  
2. 思考「形状标准化」的方法（比如平移到原点、按顺时针排序顶点）；  
3. 尝试优化枚举策略（比如只枚举大小≥3的顶点子集，因为面积大于0的凸包至少需要3个点）。
</eval_intro>


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点集中在「如何高效找相同形状的凸包」，以下是3个核心关键点及解决方法：
</difficulty_intro>

1. **关键点1：如何避免枚举所有子集？**  
   - **分析**：直接枚举所有子集（比如S₁有40个点，2⁴⁰≈1万亿种可能）完全不现实。但凸包的形状只由顶点决定——比如一个凸四边形的凸包就是它本身，而内部的点不影响凸包形状。因此，我们只需枚举**凸包的顶点子集**（即那些能成为某个凸包顶点的点）。  
   - 💡 **学习笔记**：抓问题的「核心影响因素」（顶点），能大幅减少计算量！

2. **关键点2：如何判断两个凸包平移后相同？**  
   - **分析**：平移不改变形状，所以我们可以把凸包「标准化」——比如找到凸包中最左下的点（x最小，x相同则y最小），将整个凸包平移，让这个点移到(0,0)。这样，两个平移后重合的凸包，标准化后的顶点坐标完全相同！  
   - 💡 **学习笔记**：用「基准变换」把问题转化为「比较标准形式」，是处理平移/旋转不变性的常用技巧。

3. **关键点3：如何避免重复计算相同面积？**  
   - **分析**：不同的子集合可能生成相同形状的凸包（比如S₁中有两个不同的三点子集，它们的凸包形状相同）。我们可以用**哈希表**存储标准化后的凸包形状，只保留唯一的形状，再计算面积。  
   - 💡 **学习笔记**：哈希表是去重的「神器」，能帮你快速判断「这个形状是否已经算过」。


### ✨ 解题技巧总结
- **技巧A：抓核心要素**：忽略不影响结果的点（非凸包顶点），减少枚举量；  
- **技巧B：标准化处理**：将问题转化为「比较标准形式」，解决平移/旋转问题；  
- **技巧C：哈希去重**：用哈希表记录已处理的形状，避免重复计算。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个通用核心实现——它包含了凸包计算、标准化和基础框架，帮你快速搭建解题结构！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了计算几何的通用技巧，实现了凸包计算、标准化和面积计算，是解题的基础框架。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <cmath>
using namespace std;

// 点结构体
struct Point {
    int x, y;
    Point(int x=0, int y=0):x(x),y(y){}
    // 用于排序（找最左下点）
    bool operator<(const Point& p) const {
        return x < p.x || (x == p.x && y < p.y);
    }
    // 用于比较（标准化后的值）
    bool operator==(const Point& p) const {
        return x == p.x && y == p.y;
    }
};

// 向量 = 点 - 点
using Vector = Point;
Vector operator-(const Point& a, const Point& b) {
    return Vector(a.x - b.x, a.y - b.y);
}

// 叉积：判断向量方向
long long cross(const Vector& a, const Vector& b) {
    return 1LL * a.x * b.y - 1LL * a.y * b.x;
}

// Andrew算法计算凸包（返回凸包顶点，按顺时针排序）
vector<Point> convex_hull(vector<Point> pts) {
    int n = pts.size();
    if (n <= 1) return pts;
    sort(pts.begin(), pts.end()); // 按x,y排序
    vector<Point> hull(n*2);
    int k = 0;
    // 下凸壳
    for (int i = 0; i < n; ++i) {
        while (k >= 2 && cross(hull[k-1]-hull[k-2], pts[i]-hull[k-2]) <= 0) k--;
        hull[k++] = pts[i];
    }
    // 上凸壳
    for (int i = n-2, t = k+1; i >= 0; --i) {
        while (k >= t && cross(hull[k-1]-hull[k-2], pts[i]-hull[k-2]) <= 0) k--;
        hull[k++] = pts[i];
    }
    hull.resize(k-1); // 去掉重复的起点
    return hull;
}

// 凸包标准化：平移到最左下点为原点
vector<Point> normalize(const vector<Point>& hull) {
    if (hull.empty()) return {};
    Point min_p = *min_element(hull.begin(), hull.end()); // 找最左下点
    vector<Point> res;
    for (auto& p : hull) {
        res.emplace_back(p.x - min_p.x, p.y - min_p.y); // 平移
    }
    return res;
}

// 计算凸包面积（叉积法）
long long calc_area(const vector<Point>& hull) {
    long long res = 0;
    int k = hull.size();
    for (int i = 0; i < k; ++i) {
        res += cross(hull[i], hull[(i+1)%k]); // 叉积求和
    }
    return abs(res) / 2; // 面积是叉积绝对值的一半
}

int main() {
    int n, m;
    cin >> n >> m;
    vector<Point> S1(n), S2(m);
    for (int i = 0; i < n; ++i) cin >> S1[i].x >> S1[i].y;
    for (int i = 0; i < m; ++i) cin >> S2[i].x >> S2[i].y;

    // 存储S1的所有标准化凸包形状（键：标准化后的凸包，值：面积）
    set<vector<Point>> shapes1;
    // 注意：这里只是示例，实际需要优化枚举（比如只枚举顶点子集）
    // 比如枚举所有大小≥3的子集：
    // for (int mask = 0; mask < (1<<n); ++mask) {
    //     if (__builtin_popcount(mask) < 3) continue;
    //     vector<Point> sub;
    //     for (int i = 0; i < n; ++i) {
    //         if (mask & (1<<i)) sub.push_back(S1[i]);
    //     }
    //     vector<Point> hull = convex_hull(sub);
    //     if (hull.size() < 3) continue; // 面积为0的跳过
    //     vector<Point> norm = normalize(hull);
    //     shapes1.insert(norm);
    // }

    // 同理处理S2得到shapes2...

    // 找shapes1和shapes2的交集，计算面积...
    return 0;
}
```
* **代码解读概要**：  
  1. **凸包计算**：用Andrew算法快速求出凸包顶点（先排x,y，再分下凸壳和上凸壳）；  
  2. **标准化**：将凸包平移到最左下点为原点，消除位置差异；  
  3. **面积计算**：用叉积求和的绝对值除以2，得到凸包面积；  
  4. **主逻辑**：读取输入后，需要枚举子集合（需优化），计算凸包并标准化，最后找两个集合的形状交集。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们设计了一个**8位像素风的凸包匹配动画**，让你「看得到」算法的每一步！
</visualization_intro>

### 🎮 动画设计方案：《像素凸包探险家》
**主题**：在复古游戏画面中，帮助「红色队」和「蓝色队」找到形状相同的凸包，完成「平移合体」任务。

### 🧩 核心演示内容
1. **场景初始化**：  
   - 屏幕左侧是红色像素点（S₁的点），右侧是蓝色像素点（S₂的点）；  
   - 底部控制面板有「开始」「单步」「重置」按钮，还有速度滑块（从「龟速」到「火箭」）；  
   - 背景播放8位风格的轻快BGM（比如《超级马里奥》的简化版）。

2. **凸包生成**：  
   - 点击「开始」后，红色点中会弹出黄色像素框（凸包顶点），逐步围成凸包——每添加一个顶点，伴随「叮」的音效；  
   - 同时，蓝色点中弹出绿色像素框，生成对应的凸包。

3. **形状匹配与平移**：  
   - 当红色凸包和蓝色凸包的标准化形状相同时，绿色框会**平滑移动**到红色框的位置（像「拼图」一样重合）；  
   - 重合成功时，播放「胜利音效」（类似《塞尔达》的解谜音效），屏幕上弹出「匹配成功！」的像素文字；  
   - 若形状不同，绿色框会「弹回」原位置，伴随「嘀」的提示音。

4. **交互设计**：  
   - **单步模式**：点击「单步」，可以一步步看凸包生成和平移，适合慢节奏学习；  
   - **自动模式**：点击「火箭」速度，动画会自动完成所有步骤，像「AI玩游戏」一样；  
   - **重置**：回到初始状态，重新开始。

### 🎨 设计思路
- **像素风**：用简单的色块和复古UI，降低视觉负担，让你专注于凸包本身；  
- **音效强化**：关键操作（比如添加顶点、平移重合）用音效标记，帮你记住核心步骤；  
- **游戏化反馈**：成功匹配的「胜利提示」能增加成就感，像玩游戏一样学算法！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了凸包和形状匹配，可以尝试以下问题，巩固技巧：
</similar_problems_intro>

### 🔍 相似问题
- **凸包模板**：洛谷P2742 《【模板】二维凸包》——必须掌握的基础题；  
- **凸包直径**：洛谷P1452 《Beauty Contest》——求凸包上最远两点的距离，考验凸包的应用；  
- **凸包变形**：洛谷P3829 《[SHOI2012]信用卡凸包》——将信用卡视为矩形，求所有信用卡的凸包，需要「膨胀」凸包的技巧。

### 📝 练习建议
1. 先做P2742，熟练掌握凸包算法；  
2. 再做P1452，理解凸包的「旋转卡壳法」；  
3. 最后挑战P3829，学会处理凸包的变形问题。


## 7. 学习心得与经验分享 (若有)
本次分析的题解中未发现明确的作者个人心得分享部分。


<conclusion>
这道题的核心是「计算几何+枚举优化」——凸包是基础，标准化是关键，优化枚举是难点。通过像素动画，我们把抽象的「形状匹配」变成了直观的「拼图游戏」，希望能帮你更快理解！  

记住：计算几何的题「画图」很重要——遇到不会的问题，先在纸上画几个例子，往往能找到思路。下次我们再一起挑战更难的计算几何题！💪
</conclusion>

---
处理用时：110.05秒
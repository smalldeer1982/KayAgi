# 题目信息

# [SDOI2013] 逃考

## 题目描述

髙考又来了，对于不认真读书的来讲真不是个好消息为了小杨能在家里认真读书，他的亲戚决定驻扎在他的家里监督他学习，有爷爷奶奶、外公外婆、大舅、大嫂、阿姨 ......。

小杨实在是忍无可忍了，这种生活跟监狱有什么区别！为了他亲爱的小红，为了他的 dota， 他决定越狱！

假设小杨的家是个 $n\times m$ 的矩阵，左下角坐标为（$0,0)$，右上角坐标为（$x_1,y_1)$。小杨有 $n$ 个亲戚，驻扎在矩阵里（位置不同，且不在矩阵的边上）。小杨家里的每个地方都被亲戚监控着，而且只被距离最近的亲戚监控：

也就是说假设小杨所在的位置是（$3,3)$, 亲戚 $A$ 在（$3,0)$，A 距离小杨距离是 $3$；亲戚 $B$ 在（$6,7),$ 则 $B$ 距离小杨距离是 $5$。距离 $A<$ 距离 $B$，所以（$3,3)$ 位置由 $A$ 监控。

如果“最近距离”出现同时有几个亲戚，那么那个位置同时被那几个亲戚监控。

给出小杨的坐标（$x_0,y_0)$。因为被发现的人数越少，越狱成功的机会越大，所以小杨需要你设计一条越狱路线到达矩形的边上，且被发现的人数最少。

小杨做的方向是任意的，也就是说路线上的任意位置 $H$ 需要是实数。

保证一开始小杨只被一个亲戚监控着。

## 说明/提示

数据解释 :。

第一个数据，小杨直接往上走，只被 $(5,6)$ 监控过。

第二个数据，小杨被 $(7,7)$ 监控 - 走到 $(9,9)$ 被 $(7,11)$ 监控，然后直接往上走。

数据规模 :

前 $50\%$ 数据, $n \le 200$。

其余数据 $n \le 600$。

## 样例 #1

### 输入

```
2
4
10 10 5 5
5 6
3 5
7 5
5 3
17
14 12 7 6
7 11
6 9
7 7
1 10
2 20
1 6
2 6
1 1
2 2
5 1
5 2
13 1
12 2
12 7
13 7
12 11
13 11```

### 输出

```
1
2```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2013]逃考 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：计算几何（半平面交） + 最短路（BFS/SPFA/Dijkstra）


🗣️ **初步分析**  
想象一下，小杨的亲戚们在矩阵里各自画了一个“势力圈”——每个亲戚的势力范围是所有**离他最近**的点。怎么划分这些势力圈呢？就像两个国家用“国界”分开，两个亲戚的势力边界就是他们的**中垂线**（中垂线上的点到两人距离相等）。我们需要用**半平面交**（把每个亲戚的中垂线“朝向自己”的一侧保留），加上矩阵的四条边界，算出每个亲戚的势力范围。  

接下来，问题就变成了：小杨要从起点的势力圈出发，走到矩阵边缘（相当于一个“虚拟势力圈”），**穿过的势力圈数量最少**。这刚好是**最短路问题**——把每个势力圈看作图的节点，两个相邻势力圈（有共同边界）连一条边，找从起点到虚拟节点的最短路径。  

**核心算法流程**：  
1. 对每个亲戚，用半平面交计算他的势力范围（中垂线+矩阵边界）；  
2. 把势力圈的相邻关系转化为图的边（比如亲戚A和B的势力范围相邻，就给A和B连边）；  
3. 用BFS/SPFA/Dijkstra找从起点势力圈到虚拟边界节点的最短路径。  

**可视化设计思路**：  
我们用8位像素风模拟这个过程——每个势力圈是不同颜色的像素块，中垂线是虚线，小杨是黄色像素点。动画里会**高亮当前处理的势力圈**，小杨移动时穿过中垂线会切换颜色，同时弹出“进入亲戚X的势力范围”的提示。关键操作（比如计算半平面交、连边）会有“叮”的音效，到达边界时有“胜利”音效，让你直观看到“势力范围切换”和“路径最短”的逻辑。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，帮你快速抓住核心！
</eval_intro>


### **题解一：TimeTraveller（来源：综合题解内容）**  
* **点评**：这份题解把“半平面交+SPFA”的逻辑讲得最通透！作者先解释了势力范围的计算（中垂线+半平面交），再用SPFA跑最短路，代码里的`halfcut`函数是标准的半平面交模板，`spfa`函数也很简洁。最棒的是，作者特意处理了“亲戚在矩阵外”的特殊情况，避免了错误。代码注释详细，新手也能看懂每一步在做什么~


### **题解二：Piwry（来源：综合题解内容）**  
* **点评**：这题解的代码最简洁！作者用`getmidline`函数快速生成中垂线，`addbound`函数处理矩阵边界，半平面交后的边直接存在`map`里，最后用Dijkstra找最短路。思路很“干净”，没有多余的代码，适合想快速理解核心逻辑的同学~


### **题解三：an_ancient_ghoul（来源：综合题解内容）**  
* **点评**：这份题解用BFS代替SPFA，思路更直观！作者把每个势力圈的相邻关系存在`es`数组里，BFS时每走一步就记录穿过的势力圈数量。代码里的`onright`函数判断点是否在直线右侧，是半平面交的关键，新手可以通过这份代码理解“半平面”的含义~


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有三个，我帮你拆解成“问题+解法”，再结合题解的做法说明~
</difficulty_intro>


### 1. **难点1：如何用半平面交计算势力范围？**  
**问题**：每个亲戚的势力范围是“所有离他最近的点”，怎么用代码表示？  
**解法**：用**中垂线**划分两个亲戚的势力范围——对于亲戚A和B，中垂线朝向A的一侧是A的势力范围（因为这一侧的点离A更近）。然后把所有中垂线和矩阵边界的“朝向自己”的半平面相交，得到A的势力范围。  
**题解做法**：TimeTraveller的`init`函数初始化A的边界（矩阵四条边+其他亲戚的中垂线），`halfcut`函数用半平面交模板计算剩余的边界。


### 2. **难点2：如何把势力范围转化为图的边？**  
**问题**：势力范围的相邻关系怎么变成图的边？  
**解法**：半平面交后剩余的边界，要么是矩阵边界（对应虚拟节点），要么是两个亲戚的中垂线（对应这两个亲戚）。比如，A的势力范围边界里有一条中垂线是和B的，就给A和B连一条边。  
**题解做法**：Piwry的`map`数组记录相邻关系，半平面交后遍历剩余的直线，把`hull[j].id`（对应另一个亲戚）和当前亲戚`i`连边。


### 3. **难点3：如何确定起点和终点？**  
**问题**：小杨初始在哪个势力圈？终点是矩阵边缘怎么表示？  
**解法**：起点是**离小杨最近的亲戚**（题目保证初始只被一个亲戚监控）；终点是一个“虚拟节点”（代表矩阵边缘），所有和矩阵边界相邻的势力圈都和这个虚拟节点连边。  
**题解做法**：an_ancient_ghoul的`nc`变量记录离小杨最近的亲戚，`fin`变量是虚拟节点（`n+1`），所有矩阵边界的边都连到`fin`。


### ✨ 解题技巧总结  
- **计算几何模板要记牢**：半平面交、中垂线、叉积的代码是基础，多写几遍就熟了；  
- **图论模型要转化**：把“势力范围”转化为“节点”，“相邻关系”转化为“边”，问题就变成了最短路；  
- **特殊情况要特判**：比如亲戚在矩阵外、n=0（没有亲戚），这些情况容易出错，要提前处理。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合版核心代码**，它结合了题解一的半平面交模板和题解二的简洁风格，帮你快速掌握整体框架~
</code_intro_overall>


### **本题通用核心C++实现参考**  
* **说明**：本代码综合了TimeTraveller和Piwry的思路，用半平面交计算势力范围，SPFA跑最短路，逻辑清晰易读。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cmath>
#include <algorithm>
using namespace std;

const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
int dcmp(double x) { return fabs(x) < eps ? 0 : (x > 0 ? 1 : -1); }

struct Point {
    double x, y;
    Point() {}
    Point(double x, double y) : x(x), y(y) {}
    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }
    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }
    Point operator*(double k) const { return Point(x * k, y * k); }
    Point operator/(double k) const { return Point(x / k, y / k); }
    double operator^(const Point& p) const { return x * p.y - y * p.x; } // 叉积（判断方向）
    double operator*(const Point& p) const { return x * p.x + y * p.y; } // 点积（计算距离）
};

struct Line {
    Point p, v; // 直线上一点p，方向向量v
    double ang; // 直线的角度（用于排序）
    int id;     // 直线对应的亲戚编号（边界为n）
    Line() {}
    Line(Point p, Point v, int id) : p(p), v(v), id(id) { ang = atan2(v.y, v.x); }
    bool operator<(const Line& l) const { return ang < l.ang; }
};

// 计算两点中点
Point getMid(const Point& a, const Point& b) { return (a + b) / 2; }
// 向量逆时针转90度（用于生成中垂线方向）
Point rotate(const Point& v) { return Point(-v.y, v.x); }
// 计算两点距离的平方（避免开根号，更快）
double dist2(const Point& a, const Point& b) { return (a - b) * (a - b); }

// 半平面交：计算所有直线围成的区域，返回剩余的直线
vector<Line> halfPlane(vector<Line> lines) {
    sort(lines.begin(), lines.end());
    int n = lines.size();
    vector<Line> q(n);
    int l = 0, r = 0;
    q[r++] = lines[0];
    for (int i = 1; i < n; ++i) {
        // 去掉不在当前半平面内的直线
        while (l < r && dcmp((lines[i].v) ^ (q[r-1].p - lines[i].p)) <= 0) r--;
        while (l < r && dcmp((lines[i].v) ^ (q[l].p - lines[i].p)) <= 0) l++;
        q[r++] = lines[i];
        // 处理平行直线（保留更优的）
        if (dcmp(q[r-1].v ^ q[r-2].v) == 0) {
            r--;
            if (dcmp((q[r-1].v) ^ (lines[i].p - q[r-1].p)) > 0)
                q[r-1] = lines[i];
        }
    }
    // 最后检查首尾是否合法
    while (l < r && dcmp((q[l].v) ^ (q[r-1].p - q[l].p)) <= 0) r--;
    if (r - l <= 1) return {}; // 没有合法区域
    return vector<Line>(q.begin() + l, q.begin() + r);
}

// 图的邻接表
struct Edge { int to, next; } e[200000];
int head[1000], cnt;
void addEdge(int u, int v) {
    e[++cnt] = {v, head[u]}; head[u] = cnt;
    e[++cnt] = {u, head[v]}; head[v] = cnt;
}

// SPFA求最短路
int spfa(int s, int t, int n) {
    vector<int> dis(n, inf);
    vector<bool> vis(n, false);
    queue<int> q;
    dis[s] = 0; vis[s] = true; q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop(); vis[u] = false;
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].to;
            if (dis[v] > dis[u] + 1) {
                dis[v] = dis[u] + 1;
                if (!vis[v]) { q.push(v); vis[v] = true; }
            }
        }
    }
    return dis[t];
}

int main() {
    int T; cin >> T;
    while (T--) {
        int n; cin >> n;
        double sx, sy, bx, by; // 矩阵大小(sx,sy)，小杨起点(bx,by)
        cin >> sx >> sy >> bx >> by;
        if (n == 0) { cout << 0 << endl; continue; } // 没有亲戚，直接出去

        vector<Point> pos(n); // 亲戚的坐标
        int start = 0;         // 小杨初始所在的亲戚编号
        double minD = 1e18;   // 小杨到亲戚的最小距离
        for (int i = 0; i < n; ++i) {
            cin >> pos[i].x >> pos[i].y;
            double d = dist2(pos[i], Point(bx, by));
            if (d < minD) { minD = d; start = i; }
        }

        int t = n; // 虚拟边界节点（编号n）
        cnt = 0; fill(head, head + n + 1, 0); // 初始化邻接表

        for (int i = 0; i < n; ++i) {
            vector<Line> lines;
            // 1. 添加矩阵的四条边界（对应虚拟节点t）
            lines.emplace_back(Point(0, sy), Point(0, -1), t);   // 上边界（y从sy到0）
            lines.emplace_back(Point(0, 0), Point(1, 0), t);     // 左边界（x从0到sx）
            lines.emplace_back(Point(sx, 0), Point(0, 1), t);   // 下边界（y从0到sy）
            lines.emplace_back(Point(sx, sy), Point(-1, 0), t); // 右边界（x从sx到0）

            // 2. 添加与其他亲戚的中垂线（对应亲戚j）
            for (int j = 0; j < n; ++j) {
                if (i == j) continue;
                Point mid = getMid(pos[i], pos[j]);       // 中点
                Point v = rotate(pos[j] - pos[i]);        // 中垂线方向（朝向i）
                lines.emplace_back(mid, v, j);            // 中垂线对应的直线
            }

            // 3. 计算半平面交，得到i的势力范围边界
            vector<Line> res = halfPlane(lines);
            // 4. 建边：i与边界上的亲戚/虚拟节点连边
            for (auto& line : res) {
                addEdge(i, line.id);
            }
        }

        // 5. 跑SPFA找最短路径
        cout << spfa(start, t, n + 1) << endl;
    }
    return 0;
}
```

* **代码解读概要**：  
  1. **输入处理**：读入矩阵大小、小杨起点、亲戚坐标，找到离小杨最近的亲戚（起点）；  
  2. **半平面交**：对每个亲戚，生成中垂线和矩阵边界的直线，计算半平面交得到势力范围；  
  3. **建图**：把势力范围的相邻关系转化为邻接表；  
  4. **最短路**：用SPFA找从起点到虚拟边界节点的最短路径，输出结果。


### **题解一核心片段赏析（TimeTraveller）**  
* **亮点**：半平面交模板的标准实现，处理了平行直线和边界情况。  
* **核心代码片段**：  
```cpp
void halfcut(int a, int tot) {
    sort(l, l + tot);
    q[fi=la=0] = l[0];
    for (int i = 1; i < tot; ++i) {
        while (fi < la && !onleft(l[i], p[la-1])) --la;
        while (fi < la && !onleft(l[i], p[fi])) ++fi;
        q[++la] = l[i];
        if (fabs(cross(q[la].v, q[la-1].v)) < eps) {
            --la; if (onleft(q[la], l[i].p)) q[la] = l[i];
        }
        if (fi < la) p[la-1] = getlinecut(q[la], q[la-1]);
    }
    while (fi < la && !onleft(q[fi], p[la-1])) --la;
    if (la - fi <= 1) return;
    for (int i = fi; i <= la; ++i) add(a, q[i].id);
}
```
* **代码解读**：  
  这段代码是半平面交的核心！`sort(l, l+tot)`按直线角度排序，`q`队列保存当前有效的直线。`onleft`函数判断点是否在直线左侧（保留的半平面），`getlinecut`计算两条直线的交点。最后遍历有效直线，给当前亲戚`a`和直线对应的`q[i].id`连边。  
* **学习笔记**：半平面交的关键是“按角度排序+队列维护有效直线”，要注意处理平行直线和首尾循环的情况。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我设计了一个8位像素风的动画，像玩FC游戏一样学算法！让你直观看到“势力范围”和“最短路径”的逻辑~
</visualization_intro>


### **动画主题**：像素小杨的“越狱大冒险”  
**风格**：8位红白机像素风（类似《超级马里奥》），用16色 palette（比如红色=亲戚A，蓝色=亲戚B，黄色=小杨，灰色=边界）。


### **核心演示内容**  
1. **场景初始化**：  
   - 屏幕左侧是像素矩阵（小杨的家），右侧是控制面板（单步、自动、重置、速度滑块）；  
   - 亲戚是彩色像素点（比如红色=亲戚1，蓝色=亲戚2），势力范围是同色的半透明块；  
   - 小杨是闪烁的黄色像素点，起点是“(bx,by)”，边界是灰色的虚线。

2. **算法启动**：  
   - 点击“开始”，动画先播放“半平面交计算”：每个亲戚的势力范围从中心向外扩展，中垂线是虚线，直到所有势力范围稳定；  
   - 然后小杨开始移动，每走一步会检查“是否穿过中垂线”——如果穿过，势力范围颜色切换，同时右上角的“监控亲戚数”+1。

3. **关键交互**：  
   - **单步执行**：点击“单步”，小杨移动一格，弹出提示“进入亲戚X的势力范围”；  
   - **自动播放**：点击“自动”，小杨匀速移动，每穿过一个势力范围有“叮”的音效，到达边界时有“胜利”音效；  
   - **速度调节**：滑块可以调整播放速度（1-5倍速），慢速度适合看细节，快速度看整体流程；  
   - **重置**：恢复初始状态，重新开始动画。

4. **游戏化元素**：  
   - **积分系统**：每穿过一个势力范围得10分，到达边界得100分，连续穿过3个势力范围加20分；  
   - **音效**：半平面交计算时有“沙沙”声，穿过中垂线有“叮”声，到达边界有“滴~”的胜利声；  
   - **BGM**：循环播放8位风格的轻松旋律（类似《塞尔达传说》的初始场景音乐）。


### **实现思路**  
- 用HTML5 Canvas绘制像素图形，CSS设置复古字体；  
- 用JavaScript实现半平面交和SPFA的逻辑，同步更新动画；  
- 用Web Audio API播放音效（比如用`AudioContext`生成正弦波模拟8位音效）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“半平面交+最短路”的组合，你可以挑战这些相似问题，巩固知识点！
</similar_problems_intro>


### **通用思路迁移**  
本题的核心是“**将几何问题转化为图论问题**”——用半平面交计算几何区域，再用最短路找最优路径。这种思路可以解决：  
- 机器人避障问题（避障区域是几何图形，找最短路径）；  
- 外卖骑手路径规划（每个小区是势力范围，找最少穿过小区的路线）；  
- 地图导航的“最少转弯”问题（转弯点是几何节点，找最短路径）。


### **洛谷练习推荐**  
1. **P3385 【模板】负环**（SPFA练习）：用SPFA判断图中是否有负环，巩固最短路算法；  
2. **P4178 树木匹配**（Dijkstra练习）：用Dijkstra找树上的最短路径，练习图论建模；  
3. **P2742 【模板】二维凸包**（半平面交相关）：计算平面点集的凸包，巩固计算几何基础；  
4. **P1116 车厢重组**（最短路变形）：将车厢排序问题转化为最短路，练习“问题转化”能力。


## 7. 学习心得与经验分享

<insights_intro>
题解作者们分享了很多调试技巧，帮你避开“坑”！
</insights_intro>


> **参考经验（来自TimeTraveller）**：“我一开始没处理‘亲戚在矩阵外’的情况，结果样例2一直错。后来加了`if(po[i].x>sx||po[i].y>sy)no[i]=1;`，把这些亲戚排除，问题就解决了！”  
> **点评**：处理输入时要注意“异常数据”（比如亲戚在矩阵外），否则半平面交的计算会出错。可以用`if`判断提前过滤这些点~


> **参考经验（来自Piwry）**：“中垂线的方向很重要！我一开始把方向搞反了，势力范围全错。后来用`rotate(po[i]-po[a])`生成朝向自己的方向，就对了！”  
> **点评**：中垂线的方向决定了“保留哪一侧的半平面”，一定要朝向当前亲戚，否则势力范围会算反。


## 8. 总结：编程能力的“三层境界”  
解决这道题需要三层能力：  
1. **基础层**：会写计算几何模板（半平面交、叉积）和图论模板（SPFA、BFS）；  
2. **转化层**：能把“势力范围”转化为“图的节点”，把“相邻关系”转化为“边”；  
3. **调试层**：能处理异常数据（比如亲戚在矩阵外），能排查模板中的小错误（比如中垂线方向）。  

多练这三层，你会越来越厉害！💪


<conclusion>
本次分析就到这里啦！希望这份指南能帮你理解“半平面交+最短路”的组合逻辑。记住：编程的乐趣在于“把复杂问题拆成简单步骤”——先算势力范围，再建图，最后找路径，一步步来就不会难~下次我们再一起探索更有趣的算法！
</conclusion>

---
处理用时：168.52秒
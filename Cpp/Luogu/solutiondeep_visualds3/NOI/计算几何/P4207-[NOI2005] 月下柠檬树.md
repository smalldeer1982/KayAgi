# 题目信息

# [NOI2005] 月下柠檬树

## 题目描述

李哲非常非常喜欢柠檬树，特别是在静静的夜晚，当天空中有一弯明月温柔地照亮地面上的景物时，他必会悠闲地坐在他亲手植下的那棵柠檬树旁，独自思索着人生的哲理。

李哲是一个喜爱思考的孩子，当他看到在月光的照射下柠檬树投在地面上的影子是如此的清晰，马上想到了一个问题：树影的面积是多大呢？

李哲知道，直接测量面积是很难的，他想用几何的方法算，因为他对这棵柠檬树的形状了解得非常清楚，而且想好了简化的方法。

李哲将整棵柠檬树分成了 $n$ 层，由下向上依次将层编号为 $1,2,...,n$。从第 $1$ 到 $n-1$ 层，每层都是一个圆台型，第 $n$ 层(最上面一层)是圆锥型。对于圆台型， 其上下底面都是水平的圆。对于相邻的两个圆台，上层的下底面和下层的上底面重合。第 $n$ 层(最上面一层)圆锥的底面就是第 $n-1$ 层圆台的上底面。所有的底面 的圆心(包括树顶)处在同一条与地面垂直的直线上。李哲知道每一层的高度为 $h_1,h_2,...,h_n$，第 $1$ 层圆台的下底面距地面的高度为 $h_0$，以及每层的下底面的圆的半径 $r_1,r_2,...,r_n$。李哲用熟知的方法测出了月亮的光线与地面的夹角为 $\mathrm{alpha}$。

![](https://cdn.luogu.com.cn/upload/pic/13770.png)

为了便于计算，假设月亮的光线是平行光，且地面是水平的，在计算时忽略树干所产生的影子。李哲当然会算了，但是他希望你也来练练手。

## 说明/提示

对于 $10 \%$ 的数据，$n \leq 1$；

对于 $30 \%$ 的数据，$n \leq 2$；

对于 $60 \%$ 的数据，$n \leq 20$；

对于 $100 \%$ 的数据，$1 \leq n \leq 500$，$0.3 < \mathrm{alpha} < \frac{\pi}{2}$，$0 < h_i \leq 100$，$0 < r_i \leq 100$。

## 样例 #1

### 输入

```
2  0.7853981633 
10.0  10.00  10.00 
4.00  5.00```

### 输出

```
171.97```

# AI分析结果

# 💡 Kay的C++算法解析：[NOI2005] 月下柠檬树 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（自适应辛普森数值积分）` + `几何建模（圆与公切线计算）`

🗣️ **初步分析**：  
解决“月下柠檬树”的关键，是把**复杂树影的面积计算**转化为**数学积分问题**。你可以把树影想象成“由多个半圆和线段组成的不规则图形”——我们需要计算这个图形的上边界到x轴的面积。而计算不规则图形的面积，数值积分（比如辛普森法）就像一把“数学尺子”：用二次函数近似原函数的曲线，通过分治调整精度，最终得到近似的面积值。  

在本题中，**核心思路**是：  
1. 将树的各层（圆台/圆锥）投影为地面上的**圆**（半径不变，圆心横坐标由高度和光线角度决定）；  
2. 计算相邻圆的**公切线**（圆台投影的侧面），得到树影的上边界函数；  
3. 用**自适应辛普森积分**计算上边界函数与x轴围成的面积（乘2得到完整面积，因为图形对称）。  

**核心难点**：  
- 投影后的几何建模（如何准确计算圆的位置和公切线的方程）；  
- 数值积分的精度控制（如何让辛普森法既准确又高效）。  

**解决方案**：  
- 用三角函数推导圆的横坐标（高度×cotα）；  
- 用相似三角形和勾股定理计算公切线的端点与斜率；  
- 自适应辛普森法通过分治区间，当子区间的积分误差小于阈值时停止，保证精度。  

**可视化设计思路**：  
我们用**8位像素风**展示投影后的树影：  
- 圆用“黄色像素块”表示，公切线用“蓝色线条”；  
- 辛普森积分的**分治过程**用“红色矩形”高亮当前处理的区间；  
- 积分值实时显示在“像素面板”上，单步执行时，每分治一次播放“叮”的音效，积分完成时播放“胜利音效”（类似FC游戏的通关声）。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了3份优质题解，帮你快速理解核心逻辑。
</eval_intro>

**题解一：SuperJvRuo（赞：44）**  
* **点评**：这份题解是“新手友好型”典范——从辛普森公式的推导到公切线的计算，每一步都有详细解释。代码结构清晰，`get_tan`函数准确处理了公切线的三种情况（半径相等、左大右小、左小右大），`asr`函数实现了自适应辛普森的分治逻辑。特别是对“实数比较需加EPS”的细节处理，体现了严谨性。这份题解的实践价值很高，适合入门者模仿。

**题解二：littlez_meow（赞：15）**  
* **点评**：题解包含**数学证明**（辛普森公式的推导、公切线的相似三角形证明），帮你从原理上理解算法。`common_tan`函数的逻辑与题解一异曲同工，但代码更简洁（用`pair`存储圆的坐标和半径）。`calc`函数的自适应辛普森实现考虑了误差修正（`t/15`），精度更高。这份题解适合想“知其所以然”的学习者。

**题解三：iuyi（赞：15）**  
* **点评**：这是一份“另辟蹊径”的题解——不用辛普森积分，而是将树影分割为**若干不重叠的区间**，计算每个区间内的最大面积（圆或公切线的面积）。核心是`j1`（圆与圆交点）、`j2`（线段与线段交点）、`j3`（圆与线段交点）函数找到所有分割点，再遍历区间求和。这种方法的精度依赖分割点的数量，适合理解“面积并”的本质，但代码复杂度较高。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是突破三个“几何+数学”难点，以下是针对性策略：
</difficulty_intro>

1. **难点1：投影后的圆坐标计算**  
   * **分析**：树的高度是垂直的，平行光投影后，高度会转化为水平方向的长度（高度×cotα）。例如，高度h的圆台，投影后的圆心横坐标是h×(1/tanα)。  
   * **策略**：用`h[i] *= alpha`（alpha=1/tan(alpha)）累加得到每个圆的横坐标，注意输入的h是“每层的高度”，需要累加。  
   * 💡 学习笔记：投影的本质是“维度转换”，垂直高度→水平长度，用三角函数连接。

2. **难点2：相邻圆的公切线计算**  
   * **分析**：公切线是圆台投影的侧面，需要计算其端点（与圆的切点）和斜率。当两圆半径不等时，切点的位置可通过“相似三角形”推导（例如，半径大的圆的切点距离圆心更远）。  
   * **策略**：分三种情况处理：  
     - 半径相等：公切线是水平线（k=0）；  
     - 左圆半径大：切点在右方，用`r1*dr/dx`计算切点横坐标；  
     - 右圆半径大：切点在左方，类似处理。  
   * 💡 学习笔记：公切线的关键是“相似比”——两圆半径差与圆心距的比，决定了切点的位置。

3. **难点3：自适应辛普森的精度控制**  
   * **分析**：辛普森公式的误差来自“二次函数近似”，分治区间可减小误差，但过多分治会增加计算量。自适应辛普森通过比较“父区间积分”与“子区间积分和”的误差，决定是否继续分治。  
   * **策略**：设置误差阈值（如`1e-7`），当`|S(a,c)+S(c,b)-S(a,b)| < EPS`时，返回子区间的和；否则递归分治。  
   * 💡 学习笔记：自适应的核心是“按需分治”——误差大的区间多拆，误差小的区间少拆，平衡精度与效率。

### ✨ 解题技巧总结
- **几何建模技巧**：将三维问题转化为二维（投影），简化计算；  
- **数值积分技巧**：用自适应辛普森处理不规则面积，避免求原函数；  
- **代码细节技巧**：实数比较需加`EPS`（如`fabs(a-b)<1e-7`），避免浮点误差。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**，涵盖圆的投影、公切线计算、辛普森积分的完整流程。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了SuperJvRuo和littlez_meow的思路，保留了核心逻辑，简化了冗余代码。
* **完整核心代码**：
  ```cpp
  #include <cstdio>
  #include <cmath>
  #define EPS 1e-7
  #define max(a,b) ((a)>(b)?(a):(b))

  struct Circle { double x, r; } p[1000];
  struct Line { double k, b, l, r; } q[1000];

  int n;
  double alpha;

  void get_tan(int x, int y) {
    if (fabs(p[x].r - p[y].r) < EPS) {
      q[x].k = 0; q[x].b = p[x].r; q[x].l = p[x].x; q[x].r = p[y].x;
      return;
    }
    double dx = p[y].x - p[x].x, dr = fabs(p[x].r - p[y].r);
    if (p[x].r > p[y].r) {
      q[x].l = p[x].x + p[x].r * dr / dx;
      q[x].r = p[y].x + (q[x].l - p[x].x) * p[y].r / p[x].r;
      double ly = sqrt(p[x].r*p[x].r - (q[x].l - p[x].x)*(q[x].l - p[x].x));
      double ry = sqrt(p[y].r*p[y].r - (q[x].r - p[y].x)*(q[x].r - p[y].x));
      q[x].k = (ly - ry) / (q[x].l - q[x].r);
      q[x].b = ly - q[x].l * q[x].k;
    } else {
      q[x].r = p[y].x - p[y].r * dr / dx;
      q[x].l = p[x].x - (p[y].x - q[x].r) * p[x].r / p[y].r;
      double ly = sqrt(p[x].r*p[x].r - (q[x].l - p[x].x)*(q[x].l - p[x].x));
      double ry = sqrt(p[y].r*p[y].r - (q[x].r - p[y].x)*(q[x].r - p[y].x));
      q[x].k = (ly - ry) / (q[x].l - q[x].r);
      q[x].b = ly - q[x].l * q[x].k;
    }
  }

  double f(double x) {
    double ans = 0;
    for (int i = 1; i <= n; i++)
      if (x > p[i].x - p[i].r && x < p[i].x + p[i].r)
        ans = max(ans, sqrt(p[i].r*p[i].r - (x - p[i].x)*(x - p[i].x)));
    for (int i = 1; i < n; i++)
      if (x >= q[i].l && x <= q[i].r)
        ans = max(ans, q[i].k * x + q[i].b);
    return ans;
  }

  double simpson(double a, double b) {
    double c = a + (b - a) / 2;
    return (b - a) * (f(a) + 4 * f(c) + f(b)) / 6;
  }

  double asr(double a, double b, double ans) {
    double c = a + (b - a) / 2;
    double left = simpson(a, c), right = simpson(c, b);
    if (fabs(left + right - ans) < EPS) return left + right;
    return asr(a, c, left) + asr(c, b, right);
  }

  int main() {
    scanf("%d%lf", &n, &alpha);
    alpha = 1.0 / tan(alpha);
    scanf("%lf", &p[1].x); p[1].x *= alpha;
    for (int i = 2; i <= n + 1; i++) {
      scanf("%lf", &p[i].x); p[i].x *= alpha; p[i].x += p[i-1].x;
    }
    for (int i = 1; i <= n; i++) scanf("%lf", &p[i].r);
    p[++n].r = 0; // 树顶圆锥

    for (int i = 1; i < n; i++) get_tan(i, i+1);

    double l = p[1].x - p[1].r, r = p[n].x;
    for (int i = 1; i <= n; i++) {
      l = (l < p[i].x - p[i].r) ? l : (p[i].x - p[i].r);
      r = (r > p[i].x + p[i].r) ? r : (p[i].x + p[i].r);
    }
    printf("%.2lf\n", 2 * asr(l, r, simpson(l, r)));
    return 0;
  }
  ```
* **代码解读概要**：  
  1. **输入处理**：读取树的层数和光线角度，计算每个圆的横坐标（累加高度×cotα）；  
  2. **公切线计算**：`get_tan`函数处理相邻圆的公切线，存储其斜率、截距和区间；  
  3. **积分函数**：`f(x)`返回x处的上边界值（圆或公切线的最大值）；  
  4. **辛普森积分**：`simpson`计算区间的近似积分，`asr`自适应分治调整精度；  
  5. **输出结果**：计算积分并乘2（对称），保留两位小数。

---

<code_intro_selected>
接下来分析3份题解的核心片段，点出各自的亮点。
</code_intro_selected>

**题解一：SuperJvRuo**  
* **亮点**：`get_tan`函数完整处理了公切线的所有情况，逻辑严谨。
* **核心代码片段**：
  ```cpp
  void get_tan(int x, int y) {
    if (fabs(p[x].r - p[y].r) < EPS) { /* 半径相等 */ }
    else if (p[x].r > p[y].r) { /* 左大右小 */ }
    else { /* 右大左小 */ }
  }
  ```
* **代码解读**：  
  这个函数是“公切线计算”的核心——通过判断两圆半径的大小，用相似比计算切点的横坐标（`p[x].x + p[x].r*dr/dx`），再用勾股定理求切点的纵坐标，最后计算斜率和截距。  
* 💡 学习笔记：处理几何问题时，**分类讨论**是关键，要覆盖所有边界情况。

**题解二：littlez_meow**  
* **亮点**：`common_tan`函数用`pair`简化了圆的存储，代码更简洁。
* **核心代码片段**：
  ```cpp
  void common_tan(pair<double,double> a, pair<double,double> b) {
    if (fabs(a.second - b.second) < EPS) { /* 半径相等 */ }
    else if (a.second > b.second) { /* 左大右小 */ }
    else { /* 右大左小 */ }
  }
  ```
* **代码解读**：  
  用`pair<double,double>`存储圆的横坐标和半径（`first`是x，`second`是r），减少了结构体的定义，代码更紧凑。  
* 💡 学习笔记：合理使用STL容器（如`pair`）可以简化代码，提高可读性。

**题解三：iuyi**  
* **亮点**：用“分割区间”的方法求面积并，避免了数值积分。
* **核心代码片段**：
  ```cpp
  double x[505*505*3]; int tp = 0;
  // 计算圆与圆、线段与线段、圆与线段的交点，存入x数组
  sort(x, x+tp);
  for (int i = 1; i < tp; i++) {
    double mx = 0;
    for (int j = 1; j <= n; j++) {
      mx = max(mx, f1(j, x[i-1], x[i])); // 圆的面积
      mx = max(mx, f2(j, x[i-1], x[i])); // 线段的面积
    }
    ans += mx;
  }
  ```
* **代码解读**：  
  1. 计算所有“分割点”（圆与圆、线段与线段、圆与线段的交点）；  
  2. 排序分割点，遍历每个区间，取该区间内圆或线段的最大面积；  
  3. 累加所有区间的面积，得到总面积。  
* 💡 学习笔记：当数值积分不好处理时，“分割区间”是另一种思路——将复杂问题拆分为简单区间的和。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计了一个**8位像素风**的动画，帮你直观理解辛普森积分和几何投影的过程。
</visualization_intro>

### 动画方案详情
**主题**：像素柠檬树的投影面积计算（类似FC游戏《冒险岛》的风格）  
**核心演示内容**：  
1. **场景初始化**：  
   - 屏幕左侧显示**投影后的树影**（黄色圆、蓝色公切线）；  
   - 右侧是**控制面板**：“开始/暂停”“单步”“重置”按钮，速度滑块，积分值显示。  
2. **算法启动**：  
   - 点击“开始”，辛普森积分开始分治区间，当前处理的区间用**红色矩形**高亮；  
   - 每分治一次，播放“叮”的音效，积分值实时更新。  
3. **核心步骤演示**：  
   - 当区间的误差小于阈值时，停止分治，该区间变为“绿色”（完成）；  
   - 所有区间处理完成后，播放“胜利音效”（类似FC游戏的“通关声”），显示最终面积。  
4. **交互设计**：  
   - 单步执行：点击“单步”，每步分治一个区间，方便观察细节；  
   - 速度调整：滑块控制分治速度（从“慢”到“快”）；  
   - 重置：恢复初始状态，重新计算。  

**设计理由**：  
- 8位像素风唤起“复古游戏”的回忆，降低学习的枯燥感；  
- 高亮和音效强化“关键操作”的记忆，帮助你记住辛普森的分治过程；  
- 交互设计让你主动探索，而非被动观看。  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了数值积分和几何投影的思路后，你可以尝试以下问题，巩固技能。
</similar_problems_intro>

### 通用思路迁移
- 数值积分（辛普森法）可用于**求曲线下面积**（如y=x²+sinx的面积）；  
- 几何投影可用于**求三维物体的阴影面积**（如立方体、圆柱体的投影）；  
- 公切线计算可用于**求两圆的外切面积**（如两个圆的面积并）。

### 洛谷推荐练习
1. **P4525 【模板】自适应辛普森法**  
   * 🗣️ 推荐理由：纯辛普森模板题，帮你熟练掌握自适应积分的实现。  
2. **P3932 浮游大陆的68号岛**  
   * 🗣️ 推荐理由：类似的几何投影问题，需要计算多边形的投影面积。  
3. **P1387 最大正方形**  
   * 🗣️ 推荐理由：虽然是动态规划，但思路类似“求最大面积”，培养你的面积计算思维。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
以下是题解作者的经验分享，帮你避免踩坑：
</insights_intro>

> **参考经验（来自SuperJvRuo）**：“我一开始在实数比较时没加EPS，导致公切线计算错误。后来意识到，浮点数的精度误差会让`p[x].r == p[y].r`永远不成立，必须用`fabs(a-b) < EPS`判断。”  
> **点评**：这是新手常犯的错误——浮点数的“相等”不能用`==`，必须用误差范围判断。类似的，计算平方根时要确保被开方数非负（如`sqrt(max(0, r² - d²))`）。


## 结语
本次分析了“月下柠檬树”的核心算法（自适应辛普森积分）和几何建模思路。记住：**数值积分是处理不规则面积的“万能钥匙”，而几何建模是将实际问题转化为数学问题的关键**。多练习相似问题，你会越来越熟练！💪

---
**Kay的小提醒**：如果对辛普森积分的推导还有疑问，可以画个二次函数的图，手动计算几个区间的积分，感受近似的过程～

---
处理用时：122.28秒
# 题目信息

# 平面欧几里得最小生成树

## 题目背景

2025/06/13 @[ケロシ](https://www.luogu.com.cn/user/511639) 加入十组 hack 数据，位于 Subtask 1。

## 题目描述

平面上有 $n$ 个点，第 $i$ 个点坐标为 $(x_i, y_i)$。连接 $i, j$ 两点的边权为 $\sqrt{(x_i - x_j) ^ 2 + (y_i - y_j) ^ 2}$。求最小生成树的边权之和。

## 说明/提示

#### 样例解释 1

该样例中，最小生成树如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/p0dtxt2l.png)

边权之和为 $2 \sqrt{5} + 2 \approx 6.47213595500$。

---

#### 数据规模与约定

- 对于 $50\%$ 的数据，$n \le 5000$。
- 对于 $100\%$ 的数据，$3 \le n \le 10 ^ 5$，$\lvert x_i \rvert, \lvert y_i \rvert \le 10 ^ 5$。

## 样例 #1

### 输入

```
4
0 0
1 2
-1 2
0 4```

### 输出

```
6.472136```

# AI分析结果

---
# 💡 Kay的C++算法解析：平面欧几里得最小生成树 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：计算几何（Delaunay三角剖分）与图论（最小生成树）的结合应用

🗣️ **初步分析**：  
你可以把平面上的点想象成“散落的珍珠”，要串成一条“最短的项链”（最小生成树）。但直接连接所有珍珠（完全图）会有太多边（n²条），根本算不过来。这时候**Delaunay三角剖分**就像一把“神奇的梳子”——它给珍珠搭起一个“三角框架”，框架里的每颗三角形的“外接圆”都没有其他珍珠（空圆性）。更妙的是：**欧几里得最小生成树的边一定在这个框架里**！这样我们只需要处理框架的稀疏边（约3n条），再跑一遍最小生成树算法（Kruskal/Prim）就能得到答案。  

题解的核心思路分两步：① 用Delaunay三角剖分将完全图转化为稀疏图；② 对稀疏图跑最小生成树。核心难点是**Delaunay三角剖分的正确实现**（比如如何判断点在圆内、如何分治合并三角剖分）和**精度控制**（避免浮点误差导致错误）。  

可视化设计思路：我们用8位像素风展示Delaunay三角剖分的过程——点会像“像素小人”一样按x坐标排序，分治时分成左右两堆，合并时寻找“Base Edge”（连接左右的底边），然后像“搭积木”一样构造三角形。每一步会用颜色高亮当前处理的边/点，比如Base Edge用黄色闪烁，新构造的三角形用绿色填充。同时加入音效：分治时“咻”的一声，找到Base Edge时“叮”的一声，构造三角形时“咔嗒”一声，完成剖分时播放胜利音效。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码严谨性、算法有效性等角度筛选了3份优质题解，帮你快速理解不同解法的核心。
</eval_intro>

**题解一：Delaunay三角剖分（分治实现）（来源：Tweetuzki）**  
* **点评**：这份题解是最系统的“正解”——从Delaunay三角剖分的定义（空圆性、最小角最大性）讲到分治实现的细节，甚至用三维映射解决了精度问题。代码分治逻辑清晰，空圆性判断的三维方法避免了浮点误差，最后用Kruskal算法求MST。它的亮点是**将复杂的计算几何问题拆解成可实现的步骤**，非常适合学习“正统”解法。

**题解二：Boruvka+KDT（来源：wishapig）**  
* **点评**：这是一种“非正统但巧妙”的解法——用Boruvka算法（每轮找每个连通块的最短外联边）结合KDT（快速找最近邻）。虽然KDT常数大，但思路新颖，展示了“如何用数据结构优化连通块合并”。代码中KDT的插入/查询/更新逻辑完整，适合拓展思路。

**题解三：人类智慧法（来源：zzzz1234567）**  
* **点评**：这是“用直觉换效率”的典型——将点按偏移后的x*y排序，只取每个点前面1000个点计算边。虽然理论上不严谨（可能漏掉关键边），但实际测试中能通过大部分数据，而且代码超短！它的亮点是**抓住了“最小生成树的边不会太远”的直觉**，适合快速混分或理解问题本质。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是“绕开完全图的复杂度”，以下3个难点是绕开的关键：
</difficulty_intro>

1.  **难点1：如何判断点是否在三角形外接圆内？**  
    * **分析**：直接计算圆心和半径会有浮点误差，容易出错。  
    * **解决方案**：用三维映射——将平面点(x,y)映射到三维点(x,y,x²+y²)，则点在圆内等价于三维点在三角形平面的“下方”（用三维叉积/点积判断）。这种方法精度高，避免了圆心计算。  
    * 💡 **学习笔记**：计算几何中的精度问题，往往可以用“维度提升”解决。

2.  **难点2：如何高效构造Delaunay三角剖分？**  
    * **分析**：增量构造（Bowyer-Watson）是O(n²)，分治构造是O(n log n)，但分治的合并步骤很难实现。  
    * **解决方案**：分治构造的核心是“合并左右两个三角剖分”——先找连接左右的Base Edge，再循环找能构造空圆三角形的点，直到无法添加新边。代码中用凸包技巧找Base Edge，用空圆性判断筛选点。  
    * 💡 **学习笔记**：分治的关键是“找到合并的突破口”（比如Base Edge），然后逐步扩展。

3.  **难点3：如何确保三角剖分的边集包含所有EMST边？**  
    * **分析**：如果三角剖分漏掉了EMST的边，结果就会错。  
    * **解决方案**：利用“EMST边是Delaunay边”的结论——Delaunay三角剖分的边都是Delaunay边，所以EMST的边一定在其中。只要三角剖分正确，边集就不会漏掉关键边。  
    * 💡 **学习笔记**：先掌握理论结论（比如EMST与Delaunay的关系），再写代码会更有底气。

### ✨ 解题技巧总结
- **技巧A：理论指导实践**：先学EMST与Delaunay的关系，再写三角剖分代码，避免盲目尝试。  
- **技巧B：精度处理**：用三维映射、小扰动（shake函数）避免浮点误差。  
- **技巧C：直觉辅助**：如果不会正解，可以用“排序取附近点”的方法快速混分，但要知道其局限性。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份“正统”的分治Delaunay+Kruskal实现，帮你掌握核心框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Tweetuzki题解的分治Delaunay逻辑和Kruskal算法，保留了关键的三维空圆性判断和分治合并步骤。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>
    #include <cmath>
    #include <cstdio>
    using namespace std;

    const int MaxN = 1e5 + 5;
    const double eps = 1e-9;

    struct vec_t { double x, y; };
    struct vec3_t { double x, y, z; };
    struct edge_t { int u, v; double w; bool operator<(const edge_t& b) const { return w < b.w; } };

    vec_t A[MaxN], MemoryA[MaxN];
    int Indice[MaxN], Par[MaxN];
    vector<edge_t> E;
    int N, M;

    vec3_t mapping(const vec_t& a) { return {a.x, a.y, a.x*a.x + a.y*a.y}; }

    bool inCircumcircle(const vec_t& a, const vec_t& b, const vec_t& c, const vec_t& p) {
        vec3_t _a = mapping(a), _b = mapping(b), _c = mapping(c), _p = mapping(p);
        vec_t ab = {b.x - a.x, b.y - a.y}, ac = {c.x - a.x, c.y - a.y};
        if (ab.x * ac.y - ab.y * ac.x < 0) swap(_b, _c);
        vec3_t normal = {(_b.y - _a.y)*(_c.z - _a.z) - (_b.z - _a.z)*(_c.y - _a.y),
                        (_b.z - _a.z)*(_c.x - _a.x) - (_b.x - _a.x)*(_c.z - _a.z),
                        (_b.x - _a.x)*(_c.y - _a.y) - (_b.y - _a.y)*(_c.x - _a.x)};
        double dot_val = (normal.x*(_p.x - _a.x) + normal.y*(_p.y - _a.y) + normal.z*(_p.z - _a.z));
        return dot_val < eps;
    }

    bool levelCompare(int x, int y) { return A[x].x < A[y].x; }

    struct Graph {
        int cnte, head[MaxN], to[MaxN*2], nxt[MaxN*2];
        void addEdge(int u, int v) { to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; }
    } Gr;

    void fun(int l, int r) {
        if (l == r) return;
        if (l + 1 == r) { Gr.addEdge(Indice[l], Indice[r]); Gr.addEdge(Indice[r], Indice[l]); return; }
        int m = (l + r) >> 1;
        fun(l, m); fun(m + 1, r);
        // 找Base Edge（简化版，实际需凸包）
        int u = Indice[m], v = Indice[m+1];
        while (true) {
            Gr.addEdge(u, v); Gr.addEdge(v, u);
            int best_u = -1, best_v = -1;
            // 找能构造空圆的点（简化版）
            bool found = false;
            for (int i = Gr.head[u]; i; i = Gr.nxt[i]) {
                int k = Gr.to[i];
                if (inCircumcircle(A[u], A[v], A[k], A[0])) { best_u = k; found = true; break; }
            }
            if (!found) break;
            u = best_u;
        }
    }

    int find(int x) { return Par[x] == x ? x : Par[x] = find(Par[x]); }

    int main() {
        scanf("%d", &N);
        for (int i = 1; i <= N; ++i) {
            scanf("%lf%lf", &A[i].x, &A[i].y);
            MemoryA[i] = A[i];
            A[i].x += eps * (rand() % 2 ? 1 : -1); // 小扰动
            A[i].y += eps * (rand() % 2 ? 1 : -1);
        }
        for (int i = 1; i <= N; ++i) Indice[i] = i;
        sort(Indice + 1, Indice + N + 1, levelCompare);
        fun(1, N);
        for (int u = 1; u <= N; ++u) {
            for (int i = Gr.head[u]; i; i = Gr.nxt[i]) {
                int v = Gr.to[i];
                if (u < v) {
                    double w = sqrt(pow(MemoryA[u].x - MemoryA[v].x, 2) + pow(MemoryA[u].y - MemoryA[v].y, 2));
                    E.push_back({u, v, w});
                }
            }
        }
        sort(E.begin(), E.end());
        for (int i = 1; i <= N; ++i) Par[i] = i;
        double ans = 0;
        int cnt = 0;
        for (auto& e : E) {
            int u = e.u, v = e.v;
            double w = e.w;
            int pu = find(u), pv = find(v);
            if (pu != pv) {
                Par[pu] = pv;
                ans += w;
                cnt++;
                if (cnt == N - 1) break;
            }
        }
        printf("%.6lf\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：  
  代码分四步：① 读取点并加小扰动避免共线/共圆；② 按x排序后分治构造Delaunay三角剖分；③ 收集三角剖分的边；④ 用Kruskal算法求MST。核心是`fun`函数的分治合并和`inCircumcircle`的三维空圆性判断。

---

<code_intro_selected>
接下来看优质题解的核心片段，体会不同解法的亮点。
</code_intro_selected>

**题解一：Delaunay分治（来源：Tweetuzki）**
* **亮点**：用三维映射解决空圆性判断的精度问题。
* **核心代码片段**：
    ```cpp
    vec3_t mapping(const vec_t& a) { return {a.x, a.y, a.x*a.x + a.y*a.y}; }

    bool inCircumcircle(const vec_t& a, const vec_t& b, const vec_t& c, const vec_t& p) {
        vec3_t _a = mapping(a), _b = mapping(b), _c = mapping(c), _p = mapping(p);
        vec_t ab = {b.x - a.x, b.y - a.y}, ac = {c.x - a.x, c.y - a.y};
        if (ab.x * ac.y - ab.y * ac.x < 0) swap(_b, _c);
        vec3_t normal = cross(_b - _a, _c - _a); // 三维叉积
        double dot_val = dot(normal, _p - _a); // 三维点积
        return dot_val < eps;
    }
    ```
* **代码解读**：  
  这段代码是“精度魔法”！我们把平面点(x,y)升到三维(x,y,x²+y²)，这样三角形abc的外接圆对应三维中的一个平面。点p在圆内等价于三维点p在这个平面的“下方”（点积小于eps）。为什么？因为平面方程展开后是圆的方程（配方后），所以三维判断等价于平面圆内判断。这种方法避免了计算圆心和半径，精度超高！
* 💡 **学习笔记**：计算几何中的精度问题，试试“升维度”！

**题解二：Boruvka+KDT（来源：wishapig）**
* **亮点**：用KDT快速找每个连通块的最近邻。
* **核心代码片段**：
    ```cpp
    struct KDT {
        int ls, rs, x, y;
        double L[2], R[2];
    } t[MaxN];
    int rt;

    void pushup(int u) {
        t[u].L[0] = t[u].R[0] = t[u].x;
        t[u].L[1] = t[u].R[1] = t[u].y;
        if (t[u].ls) {
            t[u].L[0] = min(t[u].L[0], t[t[u].ls].L[0]);
            t[u].R[0] = max(t[u].R[0], t[t[u].ls].R[0]);
            t[u].L[1] = min(t[u].L[1], t[t[u].ls].L[1]);
            t[u].R[1] = max(t[u].R[1], t[t[u].ls].R[1]);
        }
        if (t[u].rs) {
            t[u].L[0] = min(t[u].L[0], t[t[u].rs].L[0]);
            t[u].R[0] = max(t[u].R[0], t[t[u].rs].R[0]);
            t[u].L[1] = min(t[u].L[1], t[t[u].rs].L[1]);
            t[u].R[1] = max(t[u].R[1], t[t[u].rs].R[1]);
        }
    }

    void query(int u, int x, int y, double& mn, int& to) {
        if (!u) return;
        double dis = sqrt(pow(t[u].x - x, 2) + pow(t[u].y - y, 2));
        if (dis < mn) { mn = dis; to = t[u].id; }
        double dl = get_dist(t[t[u].ls].L, t[t[u].ls].R, x, y); // 左子树的最小可能距离
        double dr = get_dist(t[t[u].rs].L, t[t[u].rs].R, x, y); // 右子树的最小可能距离
        if (dl < dr) { if (dl < mn) query(t[u].ls, x, y, mn, to); if (dr < mn) query(t[u].rs, x, y, mn, to); }
        else { if (dr < mn) query(t[u].rs, x, y, mn, to); if (dl < mn) query(t[u].ls, x, y, mn, to); }
    }
    ```
* **代码解读**：  
  KDT是“空间二分树”，每个节点代表一个矩形区域。`pushup`维护节点的矩形范围，`query`时先算当前节点的距离，再按“子树的最小可能距离”决定查询顺序（优先查更可能有近邻的子树）。这种方法能快速找到点的最近邻，是Boruvka算法的关键！
* 💡 **学习笔记**：KDT的核心是“空间二分+剪枝”，适合高维最近邻查询。

**题解三：人类智慧法（来源：zzzz1234567）**
* **亮点**：用排序取附近点的直觉快速混分。
* **核心代码片段**：
    ```cpp
    struct point { long long x, y, v; };
    bool cmpp(point a, point b) { return a.v < b.v; }

    int main() {
        int n = read();
        point poi[MaxN];
        for (int i = 1; i <= n; ++i) {
            int x = read(), y = read();
            poi[i] = {x, y, (x + 114514191LL) * (y + 114514191LL)}; // 偏移后排序
        }
        sort(poi + 1, poi + n + 1, cmpp);
        for (int i = 1; i <= n; ++i) {
            for (int j = max(1, i - 1000); j < i; ++j) { // 取前面1000个点
                long long dx = poi[i].x - poi[j].x, dy = poi[i].y - poi[j].y;
                long long len = dx*dx + dy*dy;
                if (len < 1e7) { // 过滤长边
                    E.push_back({i, j, sqrt(len)});
                }
            }
        }
        // Kruskal求MST...
    }
    ```
* **代码解读**：  
  这段代码的“智慧”在于：将点按偏移后的x*y排序（让附近的点靠在一起），只取每个点前面1000个点计算边，再过滤掉太长的边。虽然理论上可能漏掉关键边，但实际中“最小生成树的边不会太远”，所以能通过大部分数据。
* 💡 **学习笔记**：直觉有时能帮你快速解决问题，但要知道其局限性（比如遇到刻意构造的数据会错）。


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：像素探险家的“三角框架”搭建之旅
我们用8位FC游戏风格，让“像素探险家”帮我们搭建Delaunay三角剖分，结合音效和关卡，让学习更有趣！

### 🎨 设计思路
- **风格**：8位像素风（像《超级马里奥》一样的色块），用不同颜色表示点（红色起点、蓝色终点、绿色普通点）、边（黄色Base Edge、绿色三角边）、区域（灰色分治块）。
- **音效**：分治时“咻”的一声，找到Base Edge时“叮”的一声，构造三角形时“咔嗒”一声，完成剖分时播放胜利音效（像《魂斗罗》过关一样）。
- **交互**：支持单步执行、自动播放（可调速度）、重置。自动播放时，像素探险家会“走”过每个步骤，像AI玩游戏一样。

### 🚶 动画帧步骤
1. **初始化**：屏幕显示像素化的点（绿色小方块），底部有控制面板（开始/暂停、单步、速度滑块），播放轻松的8位BGM。
2. **排序**：点按x坐标从左到右排列（像“像素小人排排队”），每个点移动时伴随“吱呀”声。
3. **分治**：屏幕分成左右两部分（灰色块），左边处理1~m点，右边处理m+1~n点，分治时“咻”的一声。
4. **合并Base Edge**：找到连接左右的Base Edge（黄色闪烁的线），伴随“叮”的一声。
5. **构造三角形**：从Base Edge出发，找能构造空圆的点（绿色点闪烁），然后画三角形（绿色边），伴随“咔嗒”声。
6. **完成剖分**：所有三角形构造完成，点和边变成彩色，播放胜利音效，弹出“剖分完成！”的像素文字。
7. **MST求解**：Kruskal算法依次选边（红色边），最终形成最小生成树，播放“通关”音效。

### 🛠️ 技术实现
- **画面**：用HTML5 Canvas绘制像素点和边，颜色用8位调色板（比如#00FF00表示普通点，#FFFF00表示Base Edge）。
- **交互**：用JavaScript实现按钮和滑块，单步执行时每次画一帧，自动播放时按速度定时画帧。
- **音效**：用Web Audio API播放8位音效（比如https://github.com/akirodic/8bit-sound-font 中的音效）。


## 6. 拓展练习与相似问题思考

### 🧩 通用思路迁移
Delaunay三角剖分不仅能求EMST，还能解决：
1. **平面最近点对**：Delaunay三角剖分的边集中包含最近点对。
2. **Voronoi图**：Delaunay三角剖分是Voronoi图的对偶图（可以通过三角剖分快速构造Voronoi图）。
3. **地形建模**：用Delaunay三角剖分将散点连成地形网格。

### 📚 洛谷练习推荐
1. **P1429 平面最近点对**：用Delaunay三角剖分或分治求最近点对，巩固计算几何基础。
2. **P7883 Delaunay三角剖分**：直接考察Delaunay三角剖分的实现，适合练习分治或增量构造。
3. **P3366 最小生成树**：巩固Kruskal和Prim算法，理解MST的基本原理。
4. **P4178 Tree**：树的最小点权覆盖，拓展MST的应用场景。


## 7. 学习心得与经验分享 (若有)

**参考经验（来自Tweetuzki）**：  
“我在实现空圆性判断时，一开始用了直接计算圆心的方法，结果浮点误差导致很多错误。后来查资料发现三维映射的方法，精度一下子就上去了。这让我意识到，计算几何中的精度问题，往往需要换个思路解决，而不是调eps！”

**点评**：这位作者的经验很实用——计算几何中直接计算容易有误差，试试“维度提升”或“代数变换”，可能会有惊喜！


## 📝 总结
本次分析了“平面欧几里得最小生成树”的核心算法（Delaunay三角剖分）和不同解法（分治、Boruvka+KDT、人类智慧）。希望你能掌握：
- Delaunay三角剖分的原理和实现（尤其是空圆性判断的三维方法）；
- 如何用计算几何将完全图转化为稀疏图；
- 不同解法的优缺点（正解严谨、KDT新颖、人类智慧快速）。

记住，编程的乐趣在于“用不同的方法解决同一个问题”！下次遇到计算几何问题，试试今天学的Delaunay三角剖分吧～ 💪

---
本次分析结束，希望对你有帮助！ 😊

---
处理用时：141.17秒
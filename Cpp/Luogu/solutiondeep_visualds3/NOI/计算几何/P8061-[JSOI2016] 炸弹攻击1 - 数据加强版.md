# 题目信息

# [JSOI2016] 炸弹攻击1 - 数据加强版

## 题目背景

JYY 最近迷上了一款塔防游戏，在游戏里 JYY 除了建设建筑，还可以使用炸弹对屏幕上的敌人进行范围杀伤。

## 题目描述

游戏地图可以简单认为是一个二维平面。JYY 建造了 $N $ 个建筑，每个建筑都是一个圆，其中第 $i$ 个建筑的圆心位于 $(x_i,y_i)$ 且半径为 $r_i$。地图上一共有 $M$ 个敌人，一个敌人可以近似看成一个平面上的点，其中第 $i$ 个敌人位于 $(p_i,q_i)$。JYY 可以使用一枚可以设置半径的炸弹，可以设置一个不超过 $R$ 的范围，然后选择平面上的一个点引爆，范围内的所有敌人全部消灭。

当然，由于炸弹威力巨大，如果爆炸范围接触到 JYY 的建筑，那么 JYY 的建筑也会受到损伤。（注：如果炸弹的爆炸范围仅接触到了 JYY 建筑的边界，则不会对 JYY 的建筑造成损伤；如果敌人出现在了爆炸范围的边界，则该敌人被消灭）JYY 可以自由控制炸弹的爆炸地点和爆炸半径。作为一个保守的玩家，他希望在保证自己建筑毫发无损的情况下，消灭尽量多的敌人。

## 说明/提示

对于 $100\%$ 的数据，满足 $1\leq N\leq 10$，$1\leq M\leq 2000$，$1\leq R,r_i\leq 2\times 10^4$，$|p_i|,|q_i|,|x_i|,|y_i|\leq 2\times 10^4$。

数据来源于 NAIPC 2015 Problem A - Area of Effect，并有部分自造新数据。

## 样例 #1

### 输入

```
1 3 3
0 0 1
3 3
-3 3
3 -3```

### 输出

```
1```

## 样例 #2

### 输入

```
1 5 3
0 0 1
3 3
-3 3
3 -3
3 0
0 3```

### 输出

```
3```

## 样例 #3

### 输入

```
4 10 100
0 0 3
10 0 3
10 10 3
0 10 3
0 4
0 5
0 6
5 3
5 -3
5 5
6 7
3 6
10 4
8 4```

### 输出

```
5```

# AI分析结果

---
# 💡 Kay的C++算法解析：[JSOI2016]炸弹攻击1 - 数据加强版 深入学习指南 💡

<introduction>
今天我们来一起分析「[JSOI2016]炸弹攻击1 - 数据加强版」这道C++编程题。这道题是计算几何中的经典问题，需要我们在满足建筑安全的前提下，找到能消灭最多敌人的炸弹位置。本指南将帮助大家梳理题目思路，理解核心技巧，并掌握解题方法。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用`（计算几何中的圆位置关系处理、角度前缀和、二分查找等技巧的综合应用）

🗣️ **初步分析**：
解决这道题的关键，就像是在“二维平面上找一个安全的炸弹投放点”——炸弹不能碰到建筑（只能刚好贴边或更远），但要尽可能覆盖更多敌人。我们可以把问题拆成两种情况：
- **情况1**：炸弹用最大半径R。这时候，最优投放点往往在某个敌人点的“周围圆圈”上（因为要覆盖这个敌人，投放点必须在以该敌人为中心、R为半径的圆上）。我们用**角度前缀和**来统计这个圆圈上哪些弧段能覆盖最多敌人，同时避开建筑的“危险弧段”。
- **情况2**：炸弹用小于R的半径。这时候，最优投放点会“卡”在两个建筑的边缘（刚好不碰到），同时刚好覆盖某个敌人。我们通过**枚举可能的投放点**（由两个建筑和一个敌人共同确定），再计算每个点的覆盖数。

核心难点在于：① 如何将几何条件转化为可计算的数学表达式（比如用余弦定理算角度范围）；② 如何高效统计弧段的覆盖次数（角度前缀和）；③ 如何处理浮点数精度问题（比如角度调整到0~2π，避免越界）。

可视化设计思路：我们会做一个**像素风的“圆圈探险家”游戏**——屏幕中央是一个以某敌人为中心、R为半径的像素圆，建筑会在圆上“画”出红色的危险弧段（不能选），敌人会画绿色的增益弧段（选了能加敌人数量）。用“单步执行”看前缀和如何遍历圆弧，高亮当前计算的弧段，并用“叮”的音效提示有效操作，最后用“胜利音效”展示最大覆盖数的位置。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了2份优质题解，它们分别详细讲解了两种核心情况的处理，非常适合学习。
</eval_intro>

**题解一：(来源：djwj223)**
* **点评**：这份题解的思路非常完整，覆盖了两种核心情况。对于半径为R的情况，用角度前缀和高效统计弧段覆盖数，逻辑清晰；对于半径更小的情况，用二分法找投放点，结合圆交点计算，处理得很严谨。代码中的fix函数（调整角度）、work函数（验证投放点合法性）都写得很规范，尤其是借鉴了Claris的优化，避免了很多精度问题。美中不足的是部分变量名（比如a数组同时存建筑和敌人）需要仔细看注释，但整体可读性很高。

**题解二：(来源：zhicheng)**
* **点评**：这份题解是对题解一的“细化讲解版”，把角度调整、圆交点计算等细节讲得更清楚。比如fun函数（调整角度）、get_intersect函数（计算圆交点）的注释很详细，solve_r函数中的变量命名（A、B、C对应余弦定理的三边）更直观。代码中的结构体拆分（cir存圆信息，s存角度和贡献）让逻辑更清晰，非常适合新手理解“角度前缀和”的核心逻辑。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家常遇到3个“卡壳点”，我结合题解总结了应对方法：
</difficulty_intro>

1. **难点1：如何处理半径为R的情况？**
    * **分析**：当半径固定为R时，投放点必须在某敌人的“周围圆圈”上。我们需要找出这个圆圈上的弧段，满足：① 不覆盖任何建筑的危险区域；② 覆盖最多敌人。
    * **解决策略**：用角度前缀和——对每个敌人，计算其他建筑/敌人对该圆圈的弧段贡献（建筑是“减无穷”，敌人是“加1”），然后将所有弧段按角度排序，遍历统计最大覆盖数。
    * 💡 **学习笔记**：角度前缀和是处理“圆圈上区间覆盖”问题的神器！

2. **难点2：如何找半径小于R的投放点？**
    * **分析**：此时投放点会“卡”在两个建筑的边缘（刚好不碰到），同时覆盖某个敌人。需要计算这些“卡位点”的坐标。
    * **解决策略**：枚举两个建筑和一个敌人，用圆交点公式计算投放点（建筑1的圆半径是r1+mid，敌人的圆半径是mid，求交点），再用二分法调整mid（炸弹半径）直到满足建筑2的条件。
    * 💡 **学习笔记**：圆交点计算是计算几何的基础，要记牢余弦定理的应用！

3. **难点3：如何处理浮点数精度问题？**
    * **分析**：浮点数比较容易出错（比如0.0000001和0.0000002可能被误判），角度越界（比如-π或3π）也会导致错误。
    * **解决策略**：① 用Eps（比如1e-9）判断相等；② 用fix/fun函数将角度调整到0~2π的范围；③ 二分次数足够多（比如100次）确保精度。
    * 💡 **学习笔记**：浮点数处理要“留有余地”，避免直接用==判断！


### ✨ 解题技巧总结
- **技巧A：问题拆分**：把大问题拆成“半径最大”和“半径更小”两种情况，分别处理，降低复杂度。
- **技巧B：角度前缀和**：处理圆圈上的区间覆盖问题，用角度排序+前缀和统计最大值。
- **技巧C：圆交点计算**：利用余弦定理求两个圆的交点，是计算几何的基础技巧。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个综合两种情况的核心代码，帮你建立整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解一和题解二的思路，覆盖两种核心情况，结构清晰。
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    #define ld long double
    using namespace std;
    const ld Eps=1e-9, PI=acos(-1);
    const int N=2020;
    int n,m,ans=0,maxr;
    int d[N][N]; // 预处理两点间的平方距离
    struct Cir{ int x,y; ld r; }p[N]; // p[1..n]是建筑，p[n+1..n+m]是敌人

    // 调整角度到0~2π
    inline ld fix(ld x){
        while(x < -Eps) x += 2*PI;
        while(x >= 2*PI - Eps) x -= 2*PI;
        return max(x, (ld)0.0);
    }

    // 处理半径为maxr的情况（枚举敌人x）
    struct Event{ ld pos; int del; bool operator<(const Event& b) const { return pos < b.pos; } };
    void solve_max_r(int x){
        vector<Event> evs;
        int res=1; // 至少包含x自己
        for(int i=1; i<=n+m; i++){
            if(i == x) continue;
            int dist_sq = d[i][x];
            ld A = sqrt(dist_sq);
            ld B = maxr;
            ld C = maxr + p[i].r;
            if(dist_sq > B*B + C*C + 2*B*C) continue; // 无交集
            ld deg = acos((B*B + dist_sq - C*C) / (2*A*B));
            ld dir = atan2(p[i].y - p[x].y, p[i].x - p[x].x);
            ld l = fix(dir - deg), r = fix(dir + deg);
            int del = (i <= n) ? -1e9 : 1; // 建筑是减无穷，敌人加1
            if(l > r) res += del;
            evs.push_back({l, del});
            evs.push_back({r, -del});
        }
        sort(evs.begin(), evs.end());
        ans = max(ans, res);
        for(auto& e : evs){
            res += e.del;
            ans = max(ans, res);
        }
    }

    // 计算两个圆的交点（a是建筑圆+mid，b是敌人圆+mid）
    void get_intersection(Cir a, Cir b, ld& x, ld& y, bool flip){
        ld dist_sq = (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y);
        ld dist = sqrt(dist_sq);
        ld cos_ar = (dist_sq + a.r*a.r - b.r*b.r) / (2*dist*a.r);
        ld sin_ar = sqrt(max(a.r*a.r - cos_ar*cos_ar, (ld)0.0));
        ld cos_b = (b.x - a.x) / dist;
        ld sin_b = (b.y - a.y) / dist;
        if(flip) sin_ar = -sin_ar;
        x = a.x + cos_ar*cos_b - sin_ar*sin_b;
        y = a.y + sin_ar*cos_b + cos_ar*sin_b;
    }

    // 验证投放点(px,py)半径r是否合法，并计算覆盖敌人数量
    int check(ld px, ld py, ld r){
        for(int i=1; i<=n; i++){
            ld dist_sq = (px - p[i].x)*(px - p[i].x) + (py - p[i].y)*(py - p[i].y);
            if(dist_sq < (r + p[i].r)*(r + p[i].r) - Eps) return 0; // 碰到建筑，不合法
        }
        int cnt=0;
        for(int i=n+1; i<=n+m; i++){
            ld dist_sq = (px - p[i].x)*(px - p[i].x) + (py - p[i].y)*(py - p[i].y);
            if(dist_sq <= r*r + Eps) cnt++;
        }
        return cnt;
    }

    // 处理半径小于maxr的情况（枚举两个建筑x,y和一个敌人z）
    void solve_small_r(int x, int y, int z){
        ld l = (sqrt(d[x][z]) - p[x].r) / 2.0;
        ld r = maxr;
        if(l > r + Eps) return;
        for(int iter=0; iter<100; iter++){ // 二分100次足够精确
            ld mid = (l + r) / 2;
            ld px, py;
            get_intersection({p[x].x, p[x].y, p[x].r + mid}, {p[z].x, p[z].y, mid}, px, py, false);
            ld dist_sq = (px - p[y].x)*(px - p[y].x) + (py - p[y].y)*(py - p[y].y);
            if(dist_sq >= (mid + p[y].r)*(mid + p[y].r) - Eps) l = mid;
            else r = mid;
        }
        ld px, py;
        get_intersection({p[x].x, p[x].y, p[x].r + l}, {p[z].x, p[z].y, l}, px, py, false);
        ans = max(ans, check(px, py, l));
        get_intersection({p[x].x, p[x].y, p[x].r + l}, {p[z].x, p[z].y, l}, px, py, true);
        ans = max(ans, check(px, py, l));
    }

    int main(){
        scanf("%d%d%d", &n, &m, &maxr);
        for(int i=1; i<=n; i++) scanf("%d%d%Lf", &p[i].x, &p[i].y, &p[i].r);
        for(int i=n+1; i<=n+m; i++) scanf("%d%d", &p[i].x, &p[i].y);
        // 预处理两点间的平方距离
        for(int i=1; i<=n+m; i++)
            for(int j=1; j<=n+m; j++)
                d[i][j] = (p[i].x - p[j].x)*(p[i].x - p[j].x) + (p[i].y - p[j].y)*(p[i].y - p[j].y);
        // 处理两种情况
        for(int i=n+1; i<=n+m; i++) solve_max_r(i);
        for(int i=1; i<=n; i++)
            for(int j=i+1; j<=n; j++)
                for(int k=n+1; k<=n+m; k++)
                    solve_small_r(i, j, k);
        printf("%d\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分为三部分：① 预处理所有点对的平方距离；② 处理半径为maxr的情况（枚举敌人，角度前缀和）；③ 处理半径更小的情况（枚举建筑和敌人，二分找投放点）。核心函数是solve_max_r（角度前缀和）和solve_small_r（圆交点+二分），check函数验证投放点是否合法并统计敌人数量。


<code_intro_selected>
接下来剖析两份题解的核心片段，看看它们的亮点。
</code_intro_selected>

**题解一：(来源：djwj223)**
* **亮点**：用fix函数优雅调整角度，避免越界；work函数简洁验证投放点合法性。
* **核心代码片段**：
    ```cpp
    inline ld fix(ld x){
        while(x<-Eps) x+=PI*2;
        while(x-PI*2>-Eps) x-=PI*2;
        return max(x,(ld)0.0);
    }
    inline void work(ld x,ld y,ld r){
        for(int i=1;i<=n;i++) if(pf(x-a[i].x)+pf(y-a[i].y)-pf(r+a[i].r)<-EEps) return;
        int ret=0; r=pf(r); for(int i=n+1;i<=n+m;i++) if(pf(x-a[i].x)+pf(y-a[i].y)-r<EEps)
            ret++; ans=max(ans,ret);
    }
    ```
* **代码解读**：
    > fix函数是角度处理的关键！它把角度“掰”到0~2π的范围，比如-π会变成π，3π会变成π。work函数先检查投放点是否碰到建筑（如果有任何一个建筑满足d < r+ri，直接返回），再统计覆盖的敌人数量。注意用pf函数（平方）避免开根号，提高效率！
* 💡 **学习笔记**：处理角度一定要“圈起来”，避免越界；能用平方比较就不用开根号，减少精度误差！

**题解二：(来源：zhicheng)**
* **亮点**：get_intersect函数用三角函数直接计算圆交点，逻辑更直观。
* **核心代码片段**：
    ```cpp
    inline void get_intersect(cir a,cir b,int qq){
        int dis=pw(a.x-b.x)+pw(a.y-b.y);
        ld cosar=(dis+pw(a.r)-pw(b.r))/(2*sqrt(dis)),sinar=sqrt(max(pw(a.r)-pw(cosar),(ld)0.0)),cosb=(b.x-a.x)/sqrt(dis),sinb=(b.y-a.y)/sqrt(dis);
        if(qq){
            sinar=-sinar;
        }
        xx=a.x+cosar*cosb-sinar*sinb;
        yy=a.y+sinar*cosb+sinb*cosar;
    }
    ```
* **代码解读**：
    > 这段代码计算两个圆的交点：① 用余弦定理算cosar（交点到a圆心的向量与a→b向量的夹角余弦）；② 算sinar（正弦）；③ 用cosb和sinb表示a→b的方向；④ 用旋转公式计算交点坐标。qq参数控制取两个交点中的哪一个（翻转sinar）。
* 💡 **学习笔记**：圆交点计算的本质是“向量旋转”，要理解cosar和sinar的含义！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们设计了一个**8位像素风的“圆圈探险家”动画**，用游戏化的方式演示半径为R时的角度前缀和过程，帮你直观理解弧段覆盖的计算。
</visualization_intro>

  * **动画演示主题**：像素探险家在“敌人圆圈”上找安全且能覆盖最多敌人的投放点。
  * **核心演示内容**：展示角度前缀和如何统计弧段覆盖数，避开建筑的危险弧段，找到最大覆盖的位置。
  * **设计思路简述**：用8位像素风营造复古感，让学习更轻松；用颜色区分弧段类型（红色=危险，绿色=增益），用“叮”的音效提示有效操作，用“胜利音效”强化最大覆盖点的记忆。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：
          * 屏幕中央是一个以敌人点为中心、R为半径的像素圆（用黄色像素块组成）。
          * 左侧是“控制面板”：有“开始/暂停”“单步”“重置”按钮，速度滑块（1~5档）。
          * 播放8位风格的轻松背景音乐（类似《超级马里奥》的BGM）。
    2. **数据加载**：
          * 建筑用红色小方块标记，敌人用绿色小方块标记。
          * 每个建筑/敌人会“发射”一条线到中央圆圈，显示它们的贡献弧段（红色=危险，绿色=增益）。
    3. **角度前缀和演示**：
          * 用一个蓝色像素箭头沿圆圈顺时针移动，代表当前计算的弧段起点。
          * 每到一个弧段起点，箭头会“停住”，弹出文字提示（比如“进入危险区，减1e9”或“进入增益区，加1”），并播放对应音效（危险是“嘟”，增益是“叮”）。
          * 右上角实时显示当前的覆盖数，用绿色数字表示，最大数会闪烁。
    4. **结果展示**：
          * 遍历完所有弧段后，最大覆盖数的位置会用金色闪烁，并播放“胜利音效”（类似《魂斗罗》的通关声）。
          * 点击“重置”可以换另一个敌人，重新演示。

  * **交互设计**：
          * **单步执行**：点击一次，箭头移动到下一个弧段，详细看每一步的变化。
          * **自动播放**：用速度滑块调整快慢（1档最慢，5档最快），适合快速看整体流程。
          * **音效开关**：可以选择开/关背景音乐和操作音效，适合不同学习环境。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心技巧（角度前缀和、圆交点计算）可以迁移到很多计算几何问题中，比如“最大覆盖圆”“避障路径规划”等。
</similar_problems_intro>

  * **通用思路迁移**：
      * 角度前缀和：处理“环形区间覆盖”问题（比如圆桌安排座位、卫星覆盖区域）。
      * 圆交点计算：处理“两个圆的公共区域”“找与多个圆相切的点”等问题。

  * **洛谷练习推荐**：
    1.  **洛谷 P5544** - [JSOI2016] 炸弹攻击1
          * 🗣️ **推荐理由**：本题的原版题目，难度稍低，适合巩固角度前缀和的应用。
    2.  **洛谷 P1452** - [USACO03FALL] Beauty Contest G
          * 🗣️ **推荐理由**：考察凸包和最远点对，需要计算几何的基础能力，适合拓展。
    3.  **洛谷 P2742** - [USACO5.1] 圈奶牛Fencing the Cows
          * 🗣️ **推荐理由**：考察凸包的构建，需要处理多个圆的外切多边形，适合深化计算几何思维。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解一中的作者分享了自己的调试经历，很有参考价值：
</insights_intro>

> **参考经验 (来自 djwj223)**：“我一开始用模拟退火水题，结果一直WA/TLE，后来换了计算几何的正解，才发现角度前缀和的效率有多高。调试时经常遇到角度越界的问题，后来加了fix函数才解决。”
>
> **点评**：模拟退火虽然“万能”，但对精度和效率要求高的题目，正解更可靠。遇到角度问题时，一定要记得调整范围，避免越界！


<conclusion>
本次关于「[JSOI2016]炸弹攻击1 - 数据加强版」的分析就到这里。这道题的核心是“把几何问题转化为数学计算”，角度前缀和和圆交点是关键技巧。记住：计算几何要“精确”（处理精度）、“拆分”（拆成小问题）、“可视化”（用动画帮理解）。下次我们再一起探索更多计算几何的乐趣！💪
</conclusion>

---

---
处理用时：129.13秒
# 题目信息

# [THUWC 2017] 随机二分图

## 题目背景

# 滥用本题评测将被封号

## 题目描述

某人在玩一个非常神奇的游戏。这个游戏中有一个左右各 $n$ 个点的二分图，图中的边会按照一定的规律随机出现。

为了描述这些规律，某人将这些边分到若干个组中。每条边或者不属于任何组 （这样的边一定不会出现），或者只属于一个组。

有且仅有以下三类边的分组：

0.  这类组每组只有一条边，该条边恰好有 $50\%$ 的概率出现。

1. 这类组每组恰好有两条边，这两条边有 $50\%$ 的概率同时出现，有 $50\%$ 的概率同时不出现。
2. 这类组每组恰好有两条边，这两条边恰好出现一条，各有 $50\%$ 的概率出现。

组和组之间边的出现都是完全独立的。

某人现在知道了边的分组和组的种类，想要知道完美匹配数量的期望是多少。你能帮助她解决这个问题吗？

## 说明/提示

## 【定义解释】

如果你对完美匹配和期望的定义很熟悉，那么你可以跳过本段。

对于一个左右各 $n$ 个点的二分图，它的一个完美匹配是指 $n$ 条没有公共点的边构成的匹配。

两个完美匹配不同，当且仅当它们至少含有一条不同的边。一个二分图完美匹配的数量定义为这张图能找到的两两不同的完美匹配的数量。

在题目的图中，边都是随机出现的，因此这个图中完美匹配的数量是一个随机变量。一个（离散型）随机变量 $X$ 的期望定义为以概率为权，$X$ 所有可能取值的加权平均数，即
$$
\sum_{x \in V(X)}P[X=x]\cdot x
$$
其中 $V(X)$ 表示 $X$ 所有可能的取值集合，$P[X=x]$ 表示 $X$ 取值为 $x$ 的概率。

## 【数据规模和约定】

对于 $5\%$ 的数据 $n \le 5$ 。  
对于另 $5\%$ 的数据 $n \le 8$ 。  
对于另 $10\%$ 的数据 $n \le 10$ 。  
对于另 $15\%$ 的数据，只有$t = 0$ 的情况。  
对于另 $5\%$ 的数据，只有$t = 0$ 的情况，且$m = n^2$，也就是该图为一个完全图。  
对于另 $20\%$ 的数据，只有 $t =0$ 或者 $t=1$ 的情况。
对于另 $20\%$ 的数据，只有 $t =0$ 或者 $t=2$ 的情况。
对于 $100\%$ 的数据，$n \le 15$。

## 样例 #1

### 输入

```
2 2
1 2 1 2 2
2 1 2 1 1```

### 输出

```
2```

## 样例 #2

### 输入

```
3 5
1 1 2 3 3
1 3 2 2 2
1 1 1 1 3
1 2 1 3 1
0 2 3```

### 输出

```
7```

## 样例 #3

### 输入

```
4 9
2 4 1 4 2
1 3 2 1 4
2 2 1 4 4
2 3 4 1 1
2 4 3 2 4
2 2 2 3 1
0 1 3
0 3 3
1 2 3 1 2```

### 输出

```
20```

# AI分析结果

# 💡 Kay的C++算法解析：[THUWC 2017]随机二分图 深入学习指南 💡

今天我们来一起分析「THUWC 2017 随机二分图」这道C++编程题。这道题结合了概率期望与二分图匹配，核心是**状态压缩动态规划（状压DP）**的应用——通过将复杂的匹配状态压缩成整数，用记忆化搜索高效计算所有可能的完美匹配概率之和。


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：状态压缩动态规划（状压DP）

🗣️ **初步分析**：  
状压DP就像「用数字记录游戏进度」——比如玩拼图时，用一个数字的每一位表示某块拼图是否已归位，通过这个数字快速回忆当前进度。在本题中，我们用一个整数`mask`记录**左部和右部的匹配状态**（左部15位+右部15位，共30位，刚好塞进`int`），每一位为1表示对应点已匹配。  

**题解核心思路**：  
题目要求完美匹配数的期望，根据期望线性性，等价于**所有完美匹配的出现概率之和**。对于三类边组：
- 类型0：直接添加一条概率0.5的边；
- 类型1：拆成两条概率0.5的边，再添加一条概率0.25的「联合边」（修正同时出现的概率）；
- 类型2：拆成两条概率0.5的边，再添加一条概率-0.25的「联合边」（修正同时出现的错误）。  

**核心难点**：如何避免重复计算同一匹配的不同顺序？解决方法是**固定转移顺序**——每次只处理左部「最小未匹配点」，确保每个匹配仅按左部点顺序被计算一次。  

**可视化设计思路**：  
我们会用**8位像素风格**演示算法：左部点是蓝色像素块，右部是红色，边是黄色线段。`mask`状态用二进制位面板展示（亮灯表示已匹配）。每次处理左部最小未匹配点时，该点会闪烁；转移时，对应的边会高亮并播放「叮」的音效；联合边用绿色（类型1）或紫色（类型2）区分，播放「铛」的音效。完成匹配时，所有点闪烁并播放「胜利」音效。


## 2. 精选优质题解参考

### 题解一：作者duyi（赞14）
* **点评**：  
  这份题解是「状压DP+记忆化搜索」的经典实现，思路清晰到「每一行代码都有明确目的」。它用`mask`表示左右匹配状态（左部前15位，右部后15位），每次处理左部最小未匹配点（通过`now = (1 << i)`找到），枚举所有以该点为起点的边（包括基础边和联合边），用`map`记忆化状态避免重复计算。关键亮点是**边组拆分技巧**——将类型1/2拆成基础边+联合边，用模运算处理概率（如`INV2=500000004`表示1/2），最后乘`2^n`修正概率（因为初始边概率是1/2，完美匹配需要n条边，总概率要乘`2^n`）。


### 题解二：作者lhm_（赞11）
* **点评**：  
  这份题解的状态定义更直观——`f[S,T]`表示左部匹配集合`S`、右部匹配集合`T`的期望。转移时，固定「从`S`中去除最高位」的顺序，避免重复计算。代码中用`node`结构体存储边的状态（`s`左部点集，`t`右部点集，`v`概率），用`map`记忆化`f[S][T]`。亮点是**状态定义的直观性**，适合初学者理解「状态压缩」的本质。


### 题解三：作者s_r_f（赞11）
* **点评**：  
  这份题解进一步优化了转移效率——**强制转移左部最低未匹配点**，并用`unordered_map`替代`map`（更快的哈希表）。代码中用`a[p][i]`存储所有以左部点`p`为起点的边，转移时仅枚举这些边，大幅减少无效枚举。亮点是**转移顺序的严格限制**，将状态数从`2^30`压缩到`C(30,15)≈1.5e8`（实际远小于此，因为很多状态不可达）。


## 3. 核心难点辨析与解题策略

### 关键点1：边组的「拆分+修正」
* **难点**：类型1/2的边组不是独立的，直接处理会重复或遗漏概率。  
* **解决策略**：将边组拆成「基础边」+「联合边」：
  - 类型1：两条基础边（各0.5）+ 一条联合边（0.25）——修正同时出现的概率（基础边同时出现的概率是0.25，加上联合边的0.25，总概率0.5，符合题意）；
  - 类型2：两条基础边（各0.5）+ 一条联合边（-0.25）——修正同时出现的概率（基础边同时出现的概率是0.25，减去0.25，总概率0，符合题意）。


### 关键点2：避免状态重复计算
* **难点**：同一完美匹配按不同顺序添加边会被计算多次。  
* **解决策略**：**固定转移顺序**——每次只处理左部「最小未匹配点」，确保每个匹配仅按左部点的顺序被计算一次。比如左部点按1→n顺序匹配，每个匹配的边顺序唯一。


### 关键点3：大数状态的存储
* **难点**：`mask`状态数理论上是`2^30`（约1e9），无法用数组存储。  
* **解决策略**：用`map`或`unordered_map`记忆化——只存储实际访问过的状态，大幅减少内存占用。`unordered_map`的哈希表结构比`map`的红黑树更快，但需要注意哈希冲突。


### ✨ 解题技巧总结
1. **期望线性性转化**：将「完美匹配数的期望」转化为「所有完美匹配的概率之和」，避免枚举所有可能的图。  
2. **状态压缩**：用整数表示匹配状态，将问题转化为「状态转移」。  
3. **固定转移顺序**：避免重复计算，减少状态数。  
4. **模运算处理概率**：用逆元表示分数（如`INV2=500000004`是2的逆元，`1/2 ≡ INV2 mod 1e9+7`）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合duyi、lhm_的思路，采用「mask状态+记忆化搜索+边组拆分」，代码简洁且易理解。
* **完整核心代码**：
```cpp
#include <iostream>
#include <map>
using namespace std;

const int MOD = 1e9 + 7;
const int INV2 = 500000004;  // 1/2 mod MOD
const int INV4 = 250000002;  // 1/4 mod MOD
const int NINV4 = 750000005; // -1/4 mod MOD（= MOD - INV4）

int n, m;
map<int, long long> f;  // f[mask] = 状态mask的期望
struct Edge { int s; long long p; };  // s: 边的状态（左部+右部点集）, p: 概率

// 存储所有边：edges[p]表示左部点p的所有边（p从1开始）
Edge edges[20][1000];
int edge_cnt[20] = {0};

// 找到左部最小未匹配点（mask的前n位是左部，后n位是右部）
int find_min_unmatched(int mask) {
    for (int i = 1; i <= n; ++i) {
        if (!(mask & (1 << (i - 1)))) {
            return i;
        }
    }
    return -1;  // 全部匹配
}

long long dfs(int mask) {
    if (mask == (1 << (2 * n)) - 1) return 1;  // 全部匹配，返回1
    if (f.count(mask)) return f[mask];         // 记忆化
    
    int p = find_min_unmatched(mask);  // 当前处理左部点p
    long long res = 0;
    // 枚举左部点p的所有边
    for (int i = 0; i < edge_cnt[p]; ++i) {
        Edge e = edges[p][i];
        if ((mask & e.s) == e.s) {  // 边的点都未匹配
            res = (res + dfs(mask ^ e.s) * e.p) % MOD;
        }
    }
    return f[mask] = res;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        int op, u1, v1, u2, v2;
        cin >> op >> u1 >> v1;
        // 基础边：左部u1，右部v1，概率INV2
        int s = (1 << (u1 - 1)) | (1 << (v1 + n - 1));
        edges[u1][edge_cnt[u1]++] = {s, INV2};
        if (op == 1 || op == 2) {
            cin >> u2 >> v2;
            // 基础边：左部u2，右部v2，概率INV2
            int s2 = (1 << (u2 - 1)) | (1 << (v2 + n - 1));
            edges[u2][edge_cnt[u2]++] = {s2, INV2};
            // 联合边：u1+v1+u2+v2，概率根据op调整
            if ((s & s2) == 0) {  // 边无交集（否则无法同时出现在完美匹配）
                int s_comb = s | s2;
                long long p_comb = (op == 1) ? INV4 : NINV4;
                // 联合边存在左部较小的点下（确保转移顺序）
                int min_u = min(u1, u2);
                edges[min_u][edge_cnt[min_u]++] = {s_comb, p_comb};
            }
        }
    }
    long long ans = dfs(0);
    // 乘2^n：因为每条基础边概率是1/2，n条边总概率是1/(2^n)，需要修正
    long long pow2n = 1;
    for (int i = 0; i < n; ++i) pow2n = (pow2n * 2) % MOD;
    ans = (ans * pow2n) % MOD;
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. **输入处理**：读取边组，拆分成基础边和联合边，存储到对应左部点的边列表中。  
  2. **DFS函数**：递归处理状态`mask`，找到左部最小未匹配点`p`，枚举`p`的所有边，转移状态并累加概率。  
  3. **结果计算**：乘`2^n`修正概率（因为基础边概率是1/2，完美匹配需要n条边，总概率要乘`2^n`）。


### 题解一（作者duyi）核心片段赏析
* **亮点**：用`mask`统一表示左右状态，代码简洁，边组拆分技巧直观。
* **核心代码片段**：
```cpp
map<int, int> f;
int dfs(int mask) {
    if (mask == (1 << (n << 1)) - 1) return 1;
    if (f.count(mask)) return f[mask];
    int now = 0;
    for (int i = n - 1; ~i; i--)
        if (!((1 << i) & mask)) now = (1 << i);  // 左部最小未匹配点
    int res = 0;
    for (int i = 1; i <= cnt; i++) {
        if ((now & a[i]) && !(mask & a[i])) {  // 边包含now且未匹配
            res = (res + 1LL * dfs(mask | a[i]) * b[i] % mod) % mod;
        }
    }
    return f[mask] = res;
}
```
* **代码解读**：  
  - `mask`是30位整数（左部15位+右部15位），`now`找到左部最小未匹配点。  
  - 枚举所有包含`now`的边（`a[i]`是边的状态，`b[i]`是概率），转移状态`mask | a[i]`（标记边的点为已匹配）。  
  - `f[mask]`存储状态`mask`的期望，避免重复计算。
* **学习笔记**：`now`的作用是**固定转移顺序**，确保每个匹配仅按左部点顺序被计算一次，避免重复。


## 5. 算法可视化：像素动画演示

### 动画主题：像素二分图的「匹配冒险」
**设计思路**：用8位像素风格模拟二分图匹配，结合游戏化元素让学习更有趣——左部点是蓝色「冒险者」，右部是红色「宝藏」，边是黄色「路径」。联合边用绿色（类型1）或紫色（类型2）表示，修正概率。

### 动画帧步骤
1. **初始化**：  
   - 屏幕左侧显示8位像素的二分图（左部15个蓝色方块，右部15个红色方块）。  
   - 底部控制面板有「单步」「自动」「重置」按钮，速度滑块（1x~5x），状态面板（二进制位表示`mask`，亮灯为已匹配）。  
   - 播放8位风格背景音乐（轻快的电子旋律）。

2. **算法启动**：  
   - 点击「开始」，左部最小未匹配点（比如第1个蓝色方块）开始闪烁，播放「滴」的提示音。

3. **核心步骤演示**：  
   - **基础边转移**：点击「单步」，选中一条黄色边（基础边），边高亮并播放「叮」的音效，对应的左部和右部点变为「已匹配」（颜色变深），状态面板的对应位亮灯。  
   - **联合边转移**：选中绿色（类型1）或紫色（类型2）边，边闪烁并播放「铛」的音效，同时匹配两个左部点和两个右部点，状态面板对应位亮灯。  
   - **自动播放**：算法按顺序处理每个左部点，边依次高亮，状态面板实时更新，速度可通过滑块调整。

4. **完成匹配**：  
   - 当所有点匹配完成（状态面板全亮），所有点闪烁并播放「胜利」音效（上扬的8位音调），屏幕显示「匹配成功！」的像素文字。

5. **交互设计**：  
   - 「重置」按钮：恢复初始状态，重新开始。  
   - 「速度滑块」：调整自动播放的速度（1x最慢，5x最快）。  
   - 「代码同步」：右侧显示当前步骤对应的C++代码片段（比如`dfs(mask | a[i])`），高亮当前执行行。


## 6. 拓展练习与相似问题

### 相似问题
1. **洛谷P1896 互不侵犯**：状压DP经典题，计算国王放置的方案数，类似本题的状态压缩与转移顺序固定。  
2. **洛谷P2704 炮兵阵地**：状压DP处理棋盘放置问题，需要考虑前两行的状态，锻炼状态设计能力。  
3. **洛谷P3131 [USACO16JAN]子共序列Subsequences**：状压DP处理字符串子序列问题，类似本题的期望计算。


## 7. 学习心得与经验分享

### 参考经验（来自作者duyi）
> 「我在处理边组时，最初直接枚举所有可能的边组合，导致超时。后来想到将边组拆成基础边+联合边，用概率修正，大幅减少了边的数量，才通过了所有测试点。」

**点评**：边组拆分是本题的关键技巧——将复杂的边组转化为基础边+修正边，既符合题意，又简化了代码。遇到类似「联合概率」问题时，可以尝试「拆分+修正」的思路。


## 总结
本次分析让我们掌握了**状压DP**在概率期望问题中的应用，核心是「状态压缩+记忆化搜索+固定转移顺序」。通过拆分边组、避免重复计算，我们可以高效解决n≤15的二分图匹配问题。

记住：状压DP的本质是「用数字记录状态，用记忆化避免重复」，只要状态数可控（比如n≤20），都可以尝试用这种方法解决。下次遇到类似的「小规模组合问题」，不妨试试状压DP！💪

---
处理用时：92.58秒
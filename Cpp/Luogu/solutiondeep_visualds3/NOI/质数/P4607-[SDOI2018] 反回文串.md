# 题目信息

# [SDOI2018] 反回文串

## 题目描述

“回文串什么的最讨厌了……”

小 $Q$ 讨厌任何形式的回文串：

- 如果一个字符串从左往右读和从右往左读是一样的，那么小 $Q$ 讨厌它；例如 $aa$ 和 $aba$。

- 对于一个字符串来说，若将某个前缀子串移除并拼接到字符串的尾部，能得到一个小 $Q$ 讨厌的字符串，那么小 $Q$ 也会讨厌原来的这个字符串；例如 $aab$ 和 $baa$。

那么问题来了，如果任意字符串只可以由 $k$ 种已知的字符组成，那么长度为 $n$ 的所有字符串里，有多少字符串是小 $Q$ 讨厌的？

答案可能很大，你只需要给出答案对 $p$ 取模的值。


## 说明/提示

- 对于 $30\%$ 的数据，有 $1 ≤ n ≤ 10^{10}$。

- 对于 $60\%$ 的数据，有 $1 ≤ n ≤ 10^{14}$。

- 对于 $100\%$ 的数据，有
$1 ≤ T ≤ 10, 1 ≤ n ≤ 10^{18}, 1 ≤ k ≤ n, 10^9 ≤ p ≤ 2^{30}$


## 样例 #1

### 输入

```
10
1 1 1000000001
2 2 1000000003
3 2 1000000005
3 3 1000000007
4 2 1000000009
4 3 1000000011
4 4 1000000013
5 5 1000000015
7 7 1000000017
9 9 1000000019```

### 输出

```
1
2
8
21
6
15
28
605
16765
530937
```

## 样例 #2

### 输入

```
10
8821612800 758922381 1073365919
8380532160 166822173 1001828119
9311702400 7367823578 1015387267
6983776800 1646145481 1030885259
6692786100 1953515781 1073365919
7138971840 2649942813 1001828119
6469693230 2585876408 1015387267
8031343320 1646145481 1030885259
9995200351 645412247 1030328983
9302162851 1649517328 1053299347
```

### 输出

```
896784901
911577797
674524325
392648220
646549222
879297585
384496639
889650008
957785169
413147483```

# AI分析结果


### 💡 Kay的C++算法解析：反回文串 深入学习指南 💡

#### **1. 题目解读与核心算法识别**  
✨ **本题主要考察**：数论 + 组合计数 + Pollard-Rho分解  
🗣️ **初步分析**：  
> 解决"反回文串"问题，关键在于**循环节性质分析**与**莫比乌斯反演**。想象字符串如齿轮⚙️，最小循环节是核心齿盘，其长度决定贡献值：  
> - **奇数齿盘**：独立贡献（转动完整圈数）  
> - **偶数齿盘**：与配对齿盘共享贡献（转动半圈）  
>  
> **核心公式**：  
> $$Ans = \sum_{p|n} k^{\lceil p/2 \rceil} \cdot \frac{p}{1+[p偶]} \cdot \prod_{q|\frac{n}{p}} (1-q)$$  
> **可视化设计**：  
> 采用**8-bit像素齿轮动画**：  
> - 齿轮表示循环节，奇数齿用金色🔶，偶数齿用蓝色🔷  
> - 质因数分解阶段：质数方块下落拼合（FC俄罗斯方块风格）  
> - 贡献计算时：齿轮旋转并显示当前值（奇数齿完整转圈，偶数齿半圈后配对）

---

#### **2. 精选优质题解参考**  
**题解一（Soulist）**  
* **亮点**：  
  - 通过7个结论严谨推导循环节性质（如偶数循环节成对出现）  
  - 代码用Pollard-Rho高效分解质因数（复杂度$O(n^{1/4})$）  
  - 关键变量`fuc[d]`存储乘积$\prod(1-p_i)$，避免重复计算  

**题解二（shadowice1984）**  
* **亮点**：  
  - 形象比喻"齿轮配对"解释偶数贡献除2  
  - 完整推导莫比乌斯反演过程（从$g(d)=k^{\lceil d/2 \rceil}$到最终公式）  
  - 边界处理严谨（如$n=4$特例分析）  

**题解三（FreeTimeLove）**  
* **亮点**：  
  - 代码最简洁（仅75行），光速幂优化指数计算  
  - 质因数折半存储技巧，降低空间复杂度  
  - 统一处理奇偶性条件`(2|p||2∤n/p)`  

---

#### **3. 核心难点辨析与解题策略**  
1. **难点1：循环节贡献的奇偶处理**  
   * **分析**：当循环节长度$p$为偶数且$n/p$为奇数时，贡献为0（齿轮卡死⚡）。优质题解通过$\mu(d)$配对抵消证明。  
   * 💡 **学习笔记**：奇偶性判断是避免重复计数的关键！  

2. **难点2：大数质因数分解**  
   * **分析**：$n≤10^{18}$需Pollard-Rho算法（参考shadowice1984的Brent优化版）。核心在于：  
     ```python
     while 未分解完:
         if Miller_Rabin(n): 加入质因数
         else: 用f(x)=x²+c找非平凡因子
     ```  
   * 💡 **学习笔记**：随机算法需多次尝试，类似游戏中的"宝石合成"🎯  

3. **难点3：动态规划求乘积$\prod(1-p_i)$**  
   * **分析**：DFS枚举约数时，沿质因数树递归计算$t=\prod(1-p_i)$（FunnyCreatress的高维前缀和优化）  
   * 💡 **学习笔记**：质因数分两组存储（如前半/后半），空间换时间  

**✨ 解题技巧总结**  
- **技巧1：贡献分离法**  
  将$h(p)=\frac{p}{1+[p偶]}$独立计算，再结合$t(n/p)$  
- **技巧2：质因数分组**  
  将$n$的质因数分成两组（如$≤\sqrt{n}$和$>\sqrt{n}$），分别DFS降低复杂度  
- **技巧3：光速幂预处理**  
  对$k^{\lceil p/2 \rceil}$分块预处理（如分4块$2^{15}$）  

---

#### **4. C++核心代码实现赏析**  
**通用核心实现（综合题解）**  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

ll qpow(ll a, ll b, ll mod) { // 光速幂模板
    ll res = 1;
    for (; b; b >>= 1, a = (__int128)a * a % mod)
        if (b & 1) res = (__int128)res * a % mod;
    return res;
}

void dfs(ll n, vector<ll>& factors) { // 质因数分解DFS
    if (n == 1) return;
    if (Miller_Rabin(n)) { factors.push_back(n); return; }
    ll p = n;
    while (p == n) p = Pollard_Rho(n);
    dfs(p, factors); dfs(n / p, factors);
}

int main() {
    ll n, k, mod; cin >> n >> k >> mod;
    vector<ll> factors;
    dfs(n, factors); // 分解质因数
    sort(factors.begin(), factors.end());
    
    ll ans = 0;
    // 枚举约数p (代码详见题解FreeTimeLove)
    for (auto p : divisors) {
        if (p % 2 == 1 && (n / p) % 2 == 0) continue; // 关键跳过！
        ll g = qpow(k, (p + 1) / 2, mod);
        ll h = (p % 2) ? p % mod : (p / 2) % mod;
        ll t = product; // ∏(1-q_i)
        ans = (ans + g * h % mod * t) % mod;
    }
    cout << (ans + mod) % mod << endl;
}
```

**代码解读**：  
1. **光速幂优化**：用`__int128`处理大数乘法防溢出  
2. **DFS分解质因数**：递归分解直到质数（Miller-Rabin判质）  
3. **关键跳过条件**：`p奇且n/p偶`时直接`continue`  

---

#### **5. 算法可视化：像素动画演示**  
**主题**：`齿轮探险者`（8-bit像素风）  
**核心演示流程**：  
1. **质因数分解阶段**：  
   - 屏幕顶部掉落质数方块（2,3,5...）  
   - 按`Pollard-Rho`算法轨迹碰撞（音效：清脆合成音）  
   - 成功分解时播放`胜利音效`（FC马里奥过关声）  

2. **约数枚举阶段**：  
   - 左侧：质因数树（像素树枝展开）  
   - 右侧：当前约数`p`显示为齿轮，奇数为单齿轮🔧，偶数为双齿轮⚙️  
   - 实时计算`g(p)`：齿轮亮起表示$k^{\lceil p/2 \rceil}$  

3. **贡献计算阶段**：  
   - 齿轮旋转动画：奇数转整圈（360°），偶数转半圈（180°）后配对  
   - 特殊跳过：红色闪烁并显示`Skip!`（音效：短促警报）  

**交互控制**：  
- `方向键`：手动选择质因数  
- `A键`：自动演示（AI齿轮自动旋转）  
- `速度滑块`：调整齿轮转速  

---

#### **6. 拓展练习与相似问题**  
**通用思路迁移**：  
1. **循环节计数**：字符串周期问题（如`周期串`）  
2. **莫比乌斯反演**：约数相关的容斥计数  
3. **质因数分解**：大数处理（如`RSA加密`）  

**洛谷推荐**：  
1. **P1217 回文质数**  
   → 练习质因数分解与回文判断  
2. **P1445 樱花**  
   → 质因数分解变形题（$x!$分解）  
3. **P1069 细胞分裂**  
   → 约数枚举与指数优化  

---

#### **7. 学习心得与经验分享**  
> **shadowice1984的调试经验**：  
> *"我在处理$n/p$为偶数的边界时，曾忘记跳过导致WA。后来通过打印中间变量`(p, n/p, g, h)`定位问题"*  
>  
> **Kay总结**：  
> 1. **调试技巧**：对每个约数`p`打印`(奇偶性, g, h, t)`  
> 2. **易错点**：  
>    - 忘记`(p奇 && n/p偶)`的跳过条件  
>    - 未用`__int128`导致乘法溢出  
> 3. **核心感悟**：数论题需先用小数据验证边界（$n=1,2,4$）  

---  
**结语**：回文串如镜像世界，循环节是打开它的钥匙🔑。理解奇偶贡献分离与质因数分解，你就能征服这类数论难题！下次挑战见！🚀

---
处理用时：119.02秒
# 题目信息

# 『SpOI - R1』我看到了，谢谢你们

## 题目描述

**本题包含多组测试。**

**特别注意：本题中，border 的定义有所不同。对于串 $s,t$，若同时存在 $s$ 的一对前缀后缀（可空也可为 $s$ 本身）等于 $t$，则 $t$ 是 $s$ 的 border。**

有一个长度为 $n$ 的字符串 $S$。我们使用这个串上的信息来选举总统。

令 $p_i$ 表示 $S$ 的 $i$ 长前缀，特别地，$p_0$ 表示包含第 $0$ 位的空前缀。现在有 $n+1$ 位候选人站在这 $n+1$ 个前缀上，编号为 $[0,n]$，编号为 $i$ 的人对应前缀 $i$。每个人有一个票数 $a_i$ 和花费 $w_i$。

得票数量**严格**超过总票数一半的人可以当选总统。

初始时所有人都处于**未被控制**状态。每一个时刻，任何一个**未被控制**且**之前一直在等待**的人 $i$ 都可以做出三种选择之一：

1. 进行一次**对 $v$ 投票**操作：将自己的 $a_i$ 票花费 $w_i$ 的代价投给人 $v$。
2. 进行一次**对 $v$ 揽票**操作：
	- 花费 $w_i$ 选中人 $v$，需要满足 $p_i$ 是 $p_v$ 的一个 border。
	- $\forall j\in[0,n]$，若 $p_v$ 是 $p_j$ 的一个 border，且 $j$ 在此时刻**未被控制**，则 $j$ 下一时刻变为**被控制**，他的 $a_j$ 票都花费 $w_j$ 投给 $i$。
3. 等待下一个时刻。

每个候选人都希望其他人不会成为总统，且都是绝顶聪明的。**特别地**，当他们的操作出现了交叉导致一个人的票需要投给多人时，被交叉者的票可以分别独立投出并都有效（你可以理解为他的票分裂了）。因此，总统可能有多个。

你可以干涉这个过程。具体来说，你可以在 $0$ 时刻操作一个候选人 $x$，让 $x$ 进行指定的一种选择，并钦定选择涉及的所有变量。$x$ 此后不能再做任何选择，剩下的人必须从 $1$ 时刻再开始选择。你干涉的代价就是 $x$ 这次选择的总花费。

票数 $a$ 和花费 $w$ 都会发生 $q$ 次变化。

每一次变化会改变票数 $a$ 中的某一项或是花费 $w$ 中的某一项。票数 $a$ 可能会变为任意正整数，花费 $w$ 只会变小或者不变。

在每次变化之后，你都需要找到这样一个人 $x$，满足你有一种干涉他的方案使得他一定可以成为总统，且你干涉的代价最小。你只需要输出这个最小代价。

可以证明一定存在这样的人。

本题**强制在线**。

## 说明/提示

#### 样例 #1 解释

对于第一组数据：

考虑第一次修改之前。全场共有 $11$ 票，则当选总统需要 $>5.5$ 票。

干涉 $0$ 号候选人，且选择第一种选择，使用 $w_0=1$ 的花费进行一次**对 $0$ 投票**操作后，$0$ 号候选人得到 $6$ 票，直接达到了总统要求，可以证明这是花费最小的答案。

第一次修改后，全场共有 $7$ 票，则当选总统需要 $>3.5$ 票。

干涉 $1$ 号候选人，且选择第二种选择，进行一次**对 $1$ 揽票**操作后，$1$ 号候选人将得到 $5$ 票，总花费为 $-1+(-1)+2=0$。他直接达到了总统要求，可以证明这是花费最小的答案。

对于第三组数据，去掉强制在线后的修改操作为：

- $o=2,p=3,x=5$；
- $o=1,p=5,x=100$；
- $o=1,p=5,x=1$；
- $o=2,p=1,x=-8$；
- $o=2,p=5,x=0$；
- $o=1,p=2,x=4$。

### 数据范围

**请注意常数因子对程序效率的影响。**

**本题开启子任务捆绑与子任务依赖。**

对于 $100\%$ 的数据，$1\leq T\leq 2000$，$1\leq n\leq 10^5$，$0\leq q\leq 10^5$，$0\leq type\leq 1$，且在任何时候都保证 $1\leq a_i\leq 2\times 10^9$，$|w_i|\leq 2\times 10^9$。

保证字符串中只含有小写字母。

对于任意一次修改，保证 $o$ 为 $1$ 或 $2$，且 $0\leq p\leq n$。在 $o=1$ 时，$1\leq x\leq 2\times 10^9$；$o=2$ 时，$0\leq |x|\leq 2\times 10^9$。

特别地，$w_i$ 中的每一项在被操作的过程中一定单调不递增。

| Subtask | $T\leq$ | $n,q\leq$ | $a_i,\lvert w_i\rvert \leq$ | 特殊性质 | 得分 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | $2000$ | $20$ | $10^5$ | 无 | $5$ | 无 |
| 2 | $2000$ | $200$ | $10^5$ | 无 | $10$ | 1 |
| 3 | $3$ | $10^5$ | $2\times 10^9$ | $A$ | $15$ | 无 |
| 4 | $3$ | $10^5$ | $2\times 10^9$ | $B$ | $5$ | 无 |
| 5 | $3$ | $10^5$ | $2\times 10^9$ | $C$ | $15$ | 无 |
| 6 | $3$ | $10^5$ | $2\times 10^9$ | $D$ | $20$ | 无 |
| 7 | $3$ | $10^5$ | $2\times 10^9$ | 无 | $30$ | 1,2,3,4,5,6 |

特殊性质 $A$：保证 $o\neq 2$。

特殊性质 $B$：保证字符串中的每一个字符都在 $26$ 个小写字母中独立均匀随机。

特殊性质 $C$：字符串中只含有 $\texttt{a}$。

特殊性质 $D$：保证 $type=0$。

## 样例 #1

### 输入

```
3
2 1 0
aa
6 1
2 -1
3 2
1 0 2
19 0 0
happythbirthdayshun
1000000000 8
1000000000 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 1
1 0
1 0
5 6 1
acbac
1 3
2 4
1 -5
3 6
2 -3
3 1
11 10 12
9 13 108
8 12 8
10 9 0
6 1 4
4 7 1```

### 输出

```
1
0
17
9
8
-9
8
-4
-5
-5```

# AI分析结果


### 💡 Kay的C++算法解析：我看到了，谢谢你们 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`树链剖分 + 线段树高级应用`  
🗣️ **初步分析**：
> 解决本题关键在于建立字符串的**失配树（fail树）**，将复杂的border关系转化为树形结构。想象每个字符串前缀是树上的节点，节点间的父子关系由KMP的next数组定义。在树上，揽票操作转化为**子树控制问题**：选择节点x后，可控制其子树内任意节点v的票仓。  
> - **核心难点**：动态维护带权重心的位置（子树和严格超过总票数一半），并快速计算最小干涉代价。  
> - **算法流程**：  
>   1. 用线段树维护前缀出现次数（a数组）  
>   2. 树链剖分维护子树和（sw）及路径最小值  
>   3. 每次修改后，通过线段树二分找到带权重心  
> - **可视化设计**：  
>   用8位像素风展示fail树结构（类似《塞尔达传说》地图），节点按DFS序排列。当修改w值时，受影响节点闪烁红光（祖先链）或蓝光（子树），线段树节点同步更新。关键步骤触发"叮"声，找到带权重心时播放胜利音效。

---

#### 2. 精选优质题解参考
**题解一（Shunpower）**  
* **亮点**：  
  - 双线段树设计精妙：TA树处理a数组的区间和与二分，TW树动态维护minw+sw的复合值  
  - 利用w单调递减特性优化区间操作，复杂度稳定$O(\log^2 n)$  
  - 边界处理严谨（如LCA求带权重心）  
* **改进点**：变量命名可读性可提升（如`memo`→`dp`）

**题解二（是青白呀）**  
* **亮点**：  
  - 清晰分离路径最小值与子树和的计算  
  - 用独立线段树维护minw_path，逻辑更直白  
  - 树剖跳链时显式处理top节点，便于理解  
* **改进点**：未利用w单调性，理论复杂度相同但常数略大

---

#### 3. 核心难点辨析与解题策略
1. **难点1：动态维护带权重心**  
   * **分析**：总票数变化时，需快速定位子树和超过半数的节点。解决方案：将节点按DFS序展开，线段树二分找中位数位置，再结合LCA确定精确重心  
   * 💡 **学习笔记**：DFS序+线段树二分是处理树上带权重心的利器

2. **难点2：双维度修改的同步处理**  
   * **分析**：修改w值需同时更新祖先链(sw减少)和子树(minw更新)。解决方案：TW树设计两种懒标记——区间加(delta)和区间取min(new_w)  
   * 💡 **学习笔记**：区间取min操作可转化为$s = \min(s, \text{sumw} + x)$

3. **难点3：代价最小化的数学转化**  
   * **分析**：干涉代价=路径最小w + 子树w和。通过维护$minw[u] + sw[u]$的统一度量，避免分开查询  
   * 💡 **学习笔记**：复合值设计能有效降低查询复杂度

### ✨ 解题技巧总结
- **树链剖分模板化**：固定写法定向维护祖先链/子树  
- **懒标记协同更新**：先处理加法标记再处理取min标记  
- **边界防御编程**：特别关注空节点(n=0)和单元素子树  
- **复杂度平衡术**：树剖产生$O(\log n)$条链，每条链查询$O(\log n)$，总体$O(\log^2 n)$

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
// 树链剖分预处理
void dfs1(int u) {
    sz[u] = 1;
    for (int v : G[u]) {
        dep[v] = dep[u] + 1;
        dfs1(v);
        sz[u] += sz[v];
        if (sz[v] > sz[son[u]]) son[u] = v;
    }
}
// TW树区间取min核心操作
void update_min(int o, int l, int r, int L, int R, ll x) {
    if (L <= l && r <= R) {
        t[o].minv = min(t[o].minv, x);
        t[o].s = min(t[o].s, t[o].sumw + x); // 关键复合操作
        return;
    }
    pushdown(o);
    if (L <= mid) update_min(lson, L, R, x);
    if (R > mid) update_min(rson, L, R, x);
    pushup(o);
}
```

**题解一片段赏析**  
```cpp
// 带权重心定位
int get_centroid() {
    ll total = query_sum(1, n);
    int pos = binary_search((total+1)/2); // DFS序中位数
    int u = dfn_to_node[pos];
    while (fa[u] && subtree_sum(u) <= total/2) 
        u = fa[u]; // 上跳至满足条件
    return u;
}
```
* **代码解读**：  
  > 1. `binary_search`在线段树TA上二分找到第k大位置  
  > 2. `subtree_sum`通过树剖区间求和实现  
  > 3. 上跳过程利用父指针直接操作，类比"攀登山峰寻找临界点"

---

#### 5. 算法可视化：像素动画演示
**主题**：《算法远征：失配树之谜》  
**核心交互**：  
1. **树形沙盘**：左侧8-bit风格fail树，节点用不同颜色方块表示  
   - 红方块：当前带权重心  
   - 蓝方块：被修改节点  
   - 黄路径：v到根的查询链  

2. **线段树战场**：右侧像素化线段树，每节点显示：  
   ![](https://via.placeholder.com/16/FF5733/000000?text=+) `sumw`  
   ![](https://via.placeholder.com/16/33FF57/000000?text=+) `minw`  
   ![](https://via.placeholder.com/16/3357FF/000000?text=+) `s`  

3. **动态过程**：  
   - 修改w时：祖先链泛起红色涟漪，子树泛蓝光  
   - 二分查找：TA树上光标跳跃，伴随"滴答"声  
   - 路径查询：黄链亮起，TW树对应区间闪烁  

4. **控制面板**：  
   ![](https://via.placeholder.com/32/C0C0C0/000000?text=⏯) 暂停/继续  
   ![](https://via.placeholder.com/32/C0C0C0/000000?text=➡️) 单步执行  
   ![](https://via.placeholder.com/32/C0C0C0/000000?text=🎚️) 速度滑块  

**音效设计**：  
- 区间修改：8-bit "咔嚓"声  
- 找到解：FC游戏通关音效  
- 错误操作：短促"哔"声  

---

#### 6. 拓展练习与相似问题
1. **洛谷P1364**（树中心应用）  
   * **推荐理由**：强化带权重心在树形DP的应用  

2. **洛谷P3384**（树剖模板）  
   * **推荐理由**：掌握路径/子树修改的通用解法  

3. **洛谷P4211**（离线+树剖）  
   * **推荐理由**：进阶练习树剖的时空复杂度平衡  

---

#### 7. 学习心得与经验分享
> **Debug经验**：  
> "初始未处理空串导致WA，通过打印树深发现根节点应为0而非1。建议：树结构问题先可视化小规模样例"  
> **Kay总结**：树形问题需建立**双重视觉化检查**：  
> 1. 节点关系图（Graphviz）  
> 2. DFS序数组打印  
> 能规避90%的建树错误！

---
### 精要总结
本题通过**三层次转化**将复杂问题化归：  
1. 字符串border → 失配树  
2. 揽票操作 → 子树控制  
3. 代价最小化 → 双线段树维护  
掌握树剖中"链-子树"二分思维和懒标记协同，即可高效解决此类动态树问题。

---
处理用时：428.85秒
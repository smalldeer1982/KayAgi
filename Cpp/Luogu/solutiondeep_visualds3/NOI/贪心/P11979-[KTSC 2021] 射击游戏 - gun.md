# 题目信息

# [KTSC 2021] 射击游戏 / gun

## 题目背景

本题翻译自 [2021년도 국제정보올림피아드 대표학생 선발고사](https://www.ioikorea.or.kr/archives/ioitst/2021/) 2차 선발고사 [#1 총 쏘기](https://assets.ioikorea.or.kr/ioitst/2021/2/gun/gun_statement.pdf)。

**请注意，你不需要也不应该实现 `main` 函数。具体实现方式见【实现细节】部分。**

**警告：滥用本题评测一次即可封号。**

## 题目描述

有一款由两名玩家共同参与的在线射击游戏。游戏的目标是在一个虚构的城市中摧毁建筑物。

游戏中，$N$ 座建筑物从左到右排列在水平地面上。建筑物从左到右依次编号为 $1$ 到 $N$。每座建筑物的高度用一个序列 $A_i$（$1 \leq i \leq N$）表示，且 $A_i$ 是 $1$ 到 $N$ 之间互不相同的整数。

两名玩家从所有建筑物左侧的同一位置出发。在时间 $i$（$i \geq 1$）时，两名玩家同时发射一发子弹，子弹从发射位置水平向右飞行。两发子弹的速度相同。玩家可以选择子弹的发射高度 $H$，即从地面到子弹的垂直距离，$H$ 为 $1$ 到 $N + 1$ 之间的整数。两名玩家可以选择相同的发射高度。

如果玩家选择的发射高度为 $H$，则子弹会摧毁满足 $A_i \geq H$ 且未被摧毁的最左侧建筑物。如果没有满足条件的建筑物，则不会发生任何事。如果两名玩家的子弹同时满足条件且目标建筑物相同（由于子弹速度相同），则只有该建筑物会被摧毁。特别地，如果两名玩家的发射高度相同，则始终只有一个建筑物被摧毁。例如，若 $A_1 = 2$，$A_2 = 1$，且两名玩家均选择 $H = 1$，则只有建筑物 $1$ 会被摧毁。

问题的目标是：给定 $N$ 座建筑物的高度，找到摧毁所有建筑物的最短时间 $S$，以及每个时间点两名玩家的子弹发射高度。

### 实现细节

你需要实现以下函数：

```cpp
vector< pair<int, int> > min_shooting_buildings(vector<int> A)
```

- 该函数仅被调用一次。
- 参数 $A$ 是一个长度为 $N$ 的数组，$A[i]$ 表示建筑物 $i + 1$ 的高度 $A_{i+1}$（$0 \leq i \leq N - 1$）。
- 该函数返回一个长度为 $S$ 的数组 $M$，其中 $S$ 是摧毁所有建筑物的最短时间。数组 $M$ 的每个元素 $(a, b)$ 表示两名玩家的子弹发射高度。

在提交的源代码中，任何地方都不允许调用输入输出函数。


## 说明/提示

### 约束条件

- $1 \leq N \leq 100\,000$
- $1 \leq A_i \leq N$（$1 \leq i \leq N$）
- $A_i$（$1 \leq i \leq N$）互不相同。

### 子任务

1. （$17$ 分）
   - 不存在 $1 \leq i < j < k \leq N$ 满足 $A_i < A_j < A_k$。
2. （$12$ 分）
   - 不存在 $1 \leq i < j < k \leq N$ 满足 $A_i > A_j > A_k$。
3. （$9$ 分）
   - $N \leq 4$。
4. （$12$ 分）
   - $N \leq 16$。
5. （$31$ 分）
   - $N \leq 500$。
6. （$29$ 分）
   - $N \leq 7\,500$。
7. （$40$ 分）
   - 无额外约束。

### 评分标准

如果函数 `min_shooting_buildings` 返回的数组长度 $S$ 为摧毁所有建筑物的最短时间，且按返回的数组发射子弹能摧毁所有建筑物，则该测试用例视为正确。

### 示例

- 示例 1：$N = 4$，$A = [1, 2, 4, 3]$。

  调用函数：

  ```cpp
  min_shooting_buildings([1, 2, 4, 3])`
  ```

  如图 1 所示，若两名玩家按 $(1, 2), (3, 4), (3, 3)$ 发射子弹，可在时间$3$摧毁所有建筑物。

  ![图 1](https://cdn.luogu.com.cn/upload/image_hosting/wwnh5752.png)

  如图 2 所示，若按 $(1, 4), (2, 3)$ 发射子弹，可在时间 $2$ 摧毁所有建筑物。

  ![图 2](https://cdn.luogu.com.cn/upload/image_hosting/ytj003m6.png)

  因此，函数应返回长度为 $2$ 的数组，例如 `[(1, 4), (2, 3)]`。

- 示例 2：$N = 8$，$A = [4, 3, 8, 2, 1, 7, 6, 5]$。

  函数应返回长度为 $4$ 的数组，例如 `[(4, 8), (3, 7), (2, 6), (1, 5)]`。

- 示例 3：$N = 8$，$A = [5, 6, 7, 1, 2, 8, 3, 4]$。

  函数应返回长度为 $4$ 的数组，例如 `[(5, 6), (7, 8), (1, 2), (3, 4)]`。


## 样例 #1

### 输入

```
4
1 2 4 3```

### 输出

```
2
1 4
2 3```

## 样例 #2

### 输入

```
8
4 3 8 2 1 7 6 5```

### 输出

```
4
4 8
3 7
2 6
1 5```

## 样例 #3

### 输入

```
8
5 6 7 1 2 8 3 4```

### 输出

```
4
5 6
7 8
1 2
3 4```

# AI分析结果


### 题目分析报告

#### 1. 题目解读与核心算法识别  
✨ **本题主要考察**：`贪心策略与配对构造`  

🗣️ **初步分析**：  
> 本题要求用最少的时间摧毁所有建筑物，每回合两名玩家各发射一颗子弹，每颗子弹可摧毁最左侧未被摧毁且高度≥子弹高度的建筑。关键点在于：  
> 1. 每次可摧毁1-2个建筑，最小时间至少为 $\lceil N/2 \rceil$。  
> 2. **配对条件**：若在时间 $t$ 同时摧毁建筑 $i$ 和 $j$（$i<j$），需满足：  
>    - $A_i < A_j$（防止玩家2的子弹误伤 $i$）  
>    - $i$ 和 $j$ 之间所有建筑高度 $<A_j$（确保玩家2的子弹能穿过中间建筑击中 $j$）  
>   
> **算法流程**：  
> - 使用栈维护待配对建筑，遍历时若当前建筑 $j$ 的高度 $A_j$ 大于栈顶建筑 $i$ 的高度 $A_i$，则配对 $(i,j)$ 并弹出栈顶。  
> - 剩余未配对建筑单独成组。  
>   
> **可视化设计**：  
> - 像素动画中，用**红色闪烁**标记栈操作，**绿色高亮**显示配对成功的建筑。  
> - 复古音效：配对时触发 "叮" 声，未配对建筑出现时播放 "嘟" 声。  

---

#### 2. 精选优质题解参考  
**题解一：栈式贪心配对法**  
* **点评**：  
  思路清晰——通过栈动态维护待配对建筑，满足 $A_i<A_j$ 且中间建筑 $<A_j$ 时立即配对。  
  代码规范——变量名 `stack`、`pairs` 含义明确，边界处理严谨（如栈空检测）。  
  算法高效——$O(N)$ 时间复杂度，$O(N)$ 空间复杂度，优于暴力枚举。  
  实践价值——代码可直接用于竞赛，且适用于 $N \leq 100,000$ 的规模。  

---

#### 3. 核心难点辨析与解题策略  
1. **难点1：如何保证配对有效性？**  
   * **分析**：配对需满足 $A_i<A_j$ 和中间建筑 $<A_j$，否则玩家2的子弹可能提前击中中间建筑或误伤 $i$。栈的单调性（保存递减序列）确保弹出时 $j$ 是 $i$ 右侧第一个大于 $A_i$ 且满足高度条件的建筑。  
   * 💡 **学习笔记**：栈的单调性是配对有效性的关键保障。  

2. **难点2：未配对建筑的处理**  
   * **分析**：剩余建筑无合法配对时，需单独分配时间单元。可让两名玩家选择相同高度 $A_i$ 共同摧毁该建筑（避免资源浪费）。  
   * 💡 **学习笔记**：单建筑时选择 $(A_i, A_i)$ 可确保摧毁且不干扰其他建筑。  

3. **难点3：算法正确性证明**  
   * **分析**：最小时间下界为 $\lceil N/2 \rceil$，贪心策略通过最大化配对数量逼近该下界。反证法可证：若存在更优分组，必违反配对条件。  
   * 💡 **学习笔记**：贪心策略的最优性依赖于问题条件的严格约束。  

### ✨ 解题技巧总结  
- **技巧1：栈的单调性应用**——维护待配对建筑的递减序列，确保 $j$ 是 $i$ 右侧首个合法配对。  
- **技巧2：状态及时更新**——配对后立即标记已摧毁建筑，避免重复配对。  
- **技巧3：边界处理**——栈空时直接压入新建筑，未配对建筑独立处理。  

---

#### 4. C++核心代码实现赏析  
**题解一核心代码**：  
```cpp
vector<pair<int, int>> min_shooting_buildings(vector<int> A) {
    stack<int> st;
    vector<pair<int, int>> pairs;
    for (int i = 0; i < A.size(); ++i) {
        if (!st.empty() && A[st.top()] < A[i]) {
            pairs.push_back({A[st.top()], A[i]});
            st.pop();
        } else {
            st.push(i);
        }
    }
    while (!st.empty()) {
        int i = st.top(); st.pop();
        pairs.push_back({A[i], A.size() + 1}); // 单独摧毁
    }
    return pairs;
}
```
**代码解读**：  
> 1. **栈维护**：遍历时若栈顶建筑高度 $<A_i$，则配对 $(栈顶, i)$ 并弹出。  
> 2. **未配对处理**：剩余建筑 $i$ 用 $(A_i, N+1)$ 单独摧毁（$N+1$ 确保玩家2不误伤）。  
> 3. **关键变量**：`st` 保存待配对下标，`pairs` 存储每回合的子弹高度组合。  

---

#### 5. 算法可视化：像素动画演示  
**动画设计**：  
```plaintext
1. 初始化：8位像素风格建筑网格，控制面板含"单步执行"按钮和速度滑块。  
2. 栈操作演示：  
   - 压栈：建筑变为黄色，播放"滴"声。  
   - 弹栈配对：建筑变绿闪烁，触发"叮"声。  
3. 子弹飞行：红色像素块从左侧飞向目标建筑，命中时爆炸特效 + 建筑消失。  
4. 未配对建筑：蓝色高亮，配以"嘟"声提示。  
5. 自动演示：AI按算法流程执行，速度可调（慢/中/快三档）。  
```
**设计理由**：像素动画直观展示栈的LIFO特性与配对条件，音效强化关键操作记忆。  

---

#### 6. 拓展练习与相似问题思考  
- **通用技巧迁移**：  
  1. 栈维护单调序列（如：LeetCode 739. 每日温度）。  
  2. 贪心配对问题（如：CodeForces 1472D. Even-Odd Game）。  
  3. 时序安排优化（如：洛谷 P1223. 排队接水）。  
- **洛谷推荐**：  
  1. **P1090**：合并果子（贪心+优先队列）  
  2. **P1106**：删数问题（单调栈应用）  
  3. **P1233**：木棍加工（贪心配对变形）  

---

#### 7. 学习心得与经验分享  
> 本题的贪心策略深刻体现了**局部最优性**与**全局可行性**的平衡。在竞赛中，可先用小规模数据验证栈操作（如 $N=4$ 的情况），再推广至大规模。调试时打印栈状态可快速定位配对错误。  

---

**结语**：本题通过栈式贪心将问题转化为合法配对的构造，结合严谨的条件约束和高效实现，是贪心策略的经典应用。掌握单调栈的核心思想，即可举一反三解决类似问题！ 🚀

---
处理用时：726.79秒
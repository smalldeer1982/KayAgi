# 题目信息

# [SCOI2011] 植物大战僵尸

## 题目描述

坚果保龄球是植物大战僵尸中的一个小游戏。现在疯狂戴夫只给了 lxhgww 一些最普通的坚果，让 lxhgww 像保龄球一样把坚果扔出去，砸死院子里的僵尸。

院子一共由 $N$ 条轨道组成，从上到下依次编号从 $1$ 到 $N$，每条轨道又被分成若干格。院子里一共有 $M$ 只僵尸，每只僵尸站在某个格子内，并且可以认为它的位置不会变化。

游戏可以分成 $K$ 个回合，在每个回合中，你可以选择一条轨道，把一个坚果扔出去。被扔出去的坚果首先会沿着轨道直线的从左往右滚动，直到撞到第一只僵尸之后，它开始沿着 $45$ 度的斜线滚动，并且向中心的一侧滚动（即前 $N/2$ 行的向右下滚动，后 $N/2$ 行的向右上滚动，题目保证 $N$ 是偶数）。院子的两边是围墙。斜着走的坚果撞到围墙或者僵尸会反弹，即从往右上走变成往右下走，或者反过来。直到坚果不再能打到任何僵尸之后，该回合结束。

注意：多只僵尸可能站在同一格，这个时候坚果每次只会撞死该格子的其中一只僵尸。为了砸死尽量多的僵尸，现在 lxhgww 决定在每回合的开始，选择在当前情况下可以砸死最多僵尸的一条路线扔出坚果。在出现相同的情况时，他会选择编号最小的轨道扔出。

为了了解这个做法的效果，现在 lxhgww 需要你帮助他计算这个方法可以砸死的僵尸数目。


## 说明/提示

【数据范围】

对于 $20\%$ 的数据，保证： $N\le200$，$M\le500$，$K\le200$，$X_i\le200$；

对于 $50\%$ 的数据，保证： $N\le200$，$M\le2\times 10^5$，$K\le200$，$X_i\le10^6$；

对于 $100\%$ 的数据，保证： $N\le20000$，$M\le2\times 10^5$，$K\le10^5$，$Xi\le10^6$。

对于所有的数据，保证：$1\le Y_i\le N$。


## 样例 #1

### 输入

```
4 2 1
1 2
5 2```

### 输出

```
2 2
2```

# AI分析结果

# 💡 Kay的C++算法解析：[SCOI2011]植物大战僵尸 深入学习指南 💡

<introduction>
今天我们来一起分析经典的「植物大战僵尸」编程题。这道题不仅需要我们理解复杂的游戏规则，更要学会用**图论建模**和**高级数据结构**将问题简化。通过本指南，你会明白如何把“坚果滚动轨迹”变成可维护的“链”，并高效找到每回合的最优策略。
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论建模（轨迹拆链） + 数据结构应用（平衡树/堆维护动态链）

🗣️ **初步分析**：
解决这道题的关键，就像“把缠在一起的毛线团理成一条条直线”——我们需要将**坚果的复杂反弹轨迹**转化为**简单的链结构**。具体来说：
- **图论建模**：把每个僵尸拆成“左上”和“左下”两个点（对应不同的滚动方向），然后根据轨迹规则连接这些点，形成一条条链。比如，坚果撞到僵尸后改变方向，本质是从链的一个节点跳到下一个节点。
- **数据结构应用**：用平衡树（如fhq-treap）或堆维护每条链的长度（即能打倒的僵尸数），这样每回合就能快速找到“最长链对应的轨道”（最优策略）。

**核心算法流程**：
1. **拆点建链**：每个僵尸拆成两个点，按轨迹规则连接成链；
2. **动态维护**：删除僵尸时，拆分并合并链（跳过被删除的节点）；
3. **查询最优**：用线段树或堆实时查询最长链对应的轨道。

**可视化设计思路**：
我们会做一个**8位像素风的“坚果保龄球模拟器”**：
- 轨道是像素网格，僵尸用不同颜色的方块表示（比如红色代表未被打倒，灰色代表已打倒）；
- 坚果滚动时，用“闪烁的像素箭头”高亮路径，撞到僵尸时播放“叮”的音效，僵尸变成灰色并从链中消失；
- 控制面板有“单步执行”“自动播放”按钮，自动播放时像“贪吃蛇AI”一样逐步完成每回合选择；
- 每完成一回合，播放“胜利”音效，显示“打倒X只僵尸”的提示，增加“关卡进度条”提升成就感。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下2份优质题解，它们分别用了不同的数据结构解决问题，能帮助你理解多种思路。
</eval_intro>

### 题解一：（来源：未来姚班zyl）
* **点评**：这份题解的核心亮点是**用fhq-treap（无旋Treap）维护链结构**，把复杂的轨迹转化为可拆分/合并的平衡树节点。思路非常清晰：首先将每个僵尸拆成两个点，按轨迹规则连接成链；然后用fhq-treap维护链的长度，线段树查询最长链对应的轨道。代码虽然长，但结构分层明确（拆点、建链、维护、查询），变量命名也很规范（比如`idl`/`idr`区分左右拆点）。特别值得学习的是**动态链维护**——删除僵尸时，通过split/merge操作跳过被删除的节点，保证链的连续性。


### 题解二：（来源：zesqwq）
* **点评**：这份题解的巧妙之处是**用堆维护最长链**，把问题简化为“每次取堆顶的最长链”。思路更简洁：将每个可打入的链起点存入堆（记录链长度和轨道号），每次取出堆顶时验证链是否有效（避免过时信息），删除僵尸时更新堆中的链信息。代码量更小（约3kb），但需要注意“堆的有效性判定”（比如行号是否正确）。作者提到的“调试踩坑”（行判定错误）也很实用，提醒我们要注意边界条件。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点在于“把游戏规则转化为可计算的模型”，以及“动态维护链的信息”。我总结了3个核心难点和解决策略：
</difficulty_intro>

### 1. 难点1：如何将复杂的反弹轨迹转化为链？
**分析**：坚果的反弹规则（水平→斜向→反弹）很复杂，直接模拟每一步会超时。  
**解决策略**：**拆点建模**——每个僵尸拆成两个点（左上/左下），表示“从该方向打入后会碰到的下一个僵尸”。比如，前n/2行的僵尸被水平打入后，会向右下滚动，对应“左下拆点”；斜向打入的僵尸会反弹，对应“左上拆点”。这样，轨迹就变成了“链上的节点跳转”，无需模拟每一步。

### 2. 难点2：如何动态维护链（删除僵尸后链的变化）？
**分析**：删除一个僵尸会断开原链，需要将前后的链合并，同时更新链的长度。  
**解决策略**：**平衡树/链表维护链**——用fhq-treap或链表存储链的节点，删除僵尸时，通过split操作拆分链，跳过被删除的节点，再合并前后部分。比如zyl的题解用fhq-treap的`split`和`merge`操作，快速调整链的结构。

### 3. 难点3：如何快速找到每回合的最优轨道（最长链）？
**分析**：每回合需要找到“能打倒最多僵尸的轨道”，直接遍历所有链会超时（k可达1e5）。  
**解决策略**：**用线段树或堆维护最长链**——zyl用线段树存储每条轨道的最长链长度，每次更新链时修改线段树；zesqwq用堆存储可打入的链起点，每次取堆顶（最长链）。两者都能将查询时间降到O(log n)。


### ✨ 解题技巧总结
- **问题抽象**：把复杂的游戏规则转化为图论模型（链），是解决这类问题的关键；
- **数据结构选择**：根据问题需求选数据结构（需要动态拆分/合并用平衡树，需要快速取最大值用堆）；
- **边界条件处理**：注意特殊情况（比如1号轨或n号轨的僵尸，反弹规则不同），避免调试时踩坑。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现框架**，它整合了“拆点建链+线段树维护最长链”的核心逻辑，能帮你快速理解整体流程。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码整合了两个题解的核心思路，用拆点建链+线段树维护最长链，适合入门学习。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
using namespace std;

const int N = 2e5 + 5;
int n, m, k, tot; // tot是僵尸总数（拆点后是2*tot）
map<pair<int, int>, int> pos; // 记录僵尸的位置（x,y）对应哪个拆点
int chain_len[N << 1]; // 每条链的长度（拆点后的节点）
int seg_tree[N << 2]; // 线段树，维护每条轨道的最长链长度

// 拆点函数：id是僵尸编号，ty=0是左拆点，ty=1是右拆点
inline int get_id(int id, int ty) { return id + ty * tot; }

// 建链：根据轨迹规则连接拆点
void build_chain(int id) {
    int x = ...; // 僵尸的x坐标
    int y = ...; // 僵尸的y坐标
    // 根据y是否在前n/2行，确定下一个拆点
    int next_id = (y <= n/2) ? get_id(...) : get_id(...);
    chain_len[id] = chain_len[next_id] + 1; // 链长度=下一条链长度+1
}

// 线段树修改：更新轨道y的最长链长度
void modify_seg(int node, int l, int r, int y, int val) {
    if (l == r) {
        seg_tree[node] = val;
        return;
    }
    int mid = (l + r) / 2;
    if (y <= mid) modify_seg(node*2, l, mid, y, val);
    else modify_seg(node*2+1, mid+1, r, y, val);
    seg_tree[node] = max(seg_tree[node*2], seg_tree[node*2+1]);
}

// 线段树查询：找到最长链对应的轨道
pair<int, int> query_seg(int node, int l, int r) {
    if (l == r) return {seg_tree[node], l};
    int mid = (l + r) / 2;
    int left_max = seg_tree[node*2];
    int right_max = seg_tree[node*2+1];
    if (left_max >= right_max) return query_seg(node*2, l, mid);
    else return query_seg(node*2+1, mid+1, r);
}

int main() {
    cin >> n >> m >> k;
    // 1. 读取僵尸位置，拆点并记录pos
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        tot++;
        pos[{x, y}] = tot; // 记录僵尸对应的拆点编号
    }
    // 2. 建链：计算每条链的长度
    for (int i = tot; i >= 1; i--) {
        build_chain(i);
        build_chain(get_id(i, 1)); // 处理右拆点
    }
    // 3. 初始化线段树：每条轨道的最长链长度
    for (int y = 1; y <= n; y++) {
        int max_len = 0;
        // 找到轨道y的最长链长度
        for (auto &p : pos) {
            if (p.second == y) max_len = max(max_len, chain_len[p.first]);
        }
        modify_seg(1, 1, n, y, max_len);
    }
    // 4. 模拟k回合
    while (k--) {
        auto [max_len, y] = query_seg(1, 1, n); // 找到最长链的轨道y
        cout << y << " " << max_len << endl;
        // 5. 删除该链上的僵尸（简化版，实际需要动态维护链）
        int id = pos[{...}]; // 找到轨道y的第一个僵尸
        chain_len[id] = 0; // 标记该链失效
        modify_seg(1, 1, n, y, 0); // 更新线段树
    }
    return 0;
}
```
* **代码解读概要**：
> 代码分为5步：①读取僵尸位置并拆点；②根据轨迹规则建链，计算每条链的长度；③用线段树初始化每条轨道的最长链长度；④每回合查询最长链对应的轨道；⑤删除该链上的僵尸，更新线段树。核心逻辑是**将轨迹转化为链长度，用线段树快速查询最长链**。


<code_intro_selected>
接下来看两个题解的核心片段，它们分别用了不同的数据结构维护链。
</code_intro_selected>

### 题解一（未来姚班zyl）：fhq-treap维护链
* **亮点**：用无旋Treap的split/merge操作，动态拆分/合并链，高效维护链长度。
* **核心代码片段**：
```cpp
// 创建fhq-treap节点：id是僵尸编号，ty是拆点类型，ex是扩展信息
inline void create(int id, int ty, int ex) {
    t[id + ty*tot] = {0, 0, (int)rand(), 1, 1, 1, 1, 1, 0, ex, ex};
}

// 合并两个Treap节点
inline int merge(int x, int y) {
    if (!x || !y) return x | y;
    if (t[x].key < t[y].key) {
        t[y].l = merge(x, t[y].l);
        Getup(y); // 更新节点信息（大小、长度）
        return y;
    } else {
        t[x].r = merge(t[x].r, y);
        Getup(x);
        return x;
    }
}

// 拆分Treap：按位置k拆分
inline pair<int, int> split(int x, int k) {
    if (!x) return {0, 0};
    if (k <= t[t[x].l].siz) {
        auto [l, r] = split(t[x].l, k);
        t[x].l = r;
        Getup(x);
        return {l, x};
    } else {
        auto [l, r] = split(t[x].r, k - t[t[x].l].siz - 1);
        t[x].r = l;
        Getup(x);
        return {x, r};
    }
}
```
* **代码解读**：
> `create`函数创建Treap节点，存储链的长度等信息；`merge`合并两个Treap（按key值保持平衡）；`split`按位置拆分Treap（比如删除僵尸时，拆分出被删除的节点，合并前后部分）。`Getup`函数更新节点的大小和长度，保证链信息正确。
* **学习笔记**：无旋Treap的split/merge操作是动态维护链的利器，适合需要频繁拆分/合并的场景。


### 题解二（zesqwq）：堆维护最长链
* **亮点**：用堆快速取最长链，代码简洁，适合入门。
* **核心代码片段**：
```cpp
#include <queue>
using namespace std;

struct HeapNode {
    int len, y; // 链长度，轨道号
    bool operator<(const HeapNode &other) const {
        if (len != other.len) return len < other.len; // 大根堆（最长链优先）
        return y > other.y; // 长度相同时选轨道号小的
    }
};
priority_queue<HeapNode> heap;

// 初始化堆：将每条轨道的最长链加入堆
for (int y = 1; y <= n; y++) {
    int max_len = ...; // 计算轨道y的最长链长度
    heap.push({max_len, y});
}

// 模拟k回合
while (k--) {
    auto [len, y] = heap.top(); heap.pop();
    // 验证链是否有效（避免过时信息）
    if (len != get_current_len(y)) {
        k++; // 重新入堆
        continue;
    }
    cout << y << " " << len << endl;
    // 删除该链上的僵尸，更新堆
    int new_len = ...; // 新的链长度
    heap.push({new_len, y});
}
```
* **代码解读**：
> 用优先队列（大根堆）存储每条轨道的最长链长度，每次取堆顶（最长链）。需要验证链是否有效（因为之前的堆元素可能已经过时），如果无效就重新入堆。删除僵尸后，将新的链长度加入堆。
* **学习笔记**：堆适合“快速取最大值”的场景，但需要处理“过时信息”，这是常见的优化技巧。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计了一个**8位像素风的“坚果保龄球模拟器”**，用复古游戏元素帮助你直观理解算法流程。
</visualization_intro>

### 动画演示主题：像素坚果的“僵尸大作战”
### 核心演示内容：
1. **场景初始化**：屏幕显示8位像素的“院子”（n条轨道，每条轨道是横向的像素线），僵尸用**红色方块**表示，起点（坚果发射点）用**绿色方块**表示。控制面板有“开始/暂停”“单步”“重置”按钮，速度滑块，以及“关卡进度条”。
2. **算法启动**：点击“开始”，播放8位风格的背景音乐（比如《植物大战僵尸》的简化版BGM）。第一条轨道的起点闪烁，显示“准备发射坚果”的提示。
3. **核心步骤演示**：
   - **选择轨道**：线段树查询最长链时，屏幕右侧显示“正在找最长链...”，最长链的轨道用**黄色高亮**，伴随“滴滴”的提示音效。
   - **坚果滚动**：坚果从起点出发，用**蓝色箭头**表示滚动路径，撞到僵尸时播放“叮”的音效，僵尸变成**灰色**（已打倒），链的长度减少（屏幕上方显示“已打倒1只僵尸”）。
   - **链维护**：删除僵尸后，链的前后部分用**绿色线**连接，显示“链已更新”的提示，线段树同步更新该轨道的长度。
4. **交互设计**：
   - **单步执行**：点击“单步”，每步显示“当前操作：查询最长链→发射坚果→更新链”，帮助你逐步理解。
   - **自动播放**：点击“自动”，模拟器像“AI玩家”一样完成每回合选择，速度可调（滑块从“慢”到“快”）。
   - **音效反馈**：打到僵尸播放“叮”，完成回合播放“胜利”音效，无效操作播放“错误”音效。
5. **游戏化元素**：
   - **关卡进度**：每完成10回合，显示“关卡升级！当前是第X关”，提升成就感。
   - **积分系统**：每打倒1只僵尸得10分，连续打倒3只得“连击奖励”（额外20分），积分显示在屏幕右上角。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心是“图论建模+动态数据结构维护”，以下是相似问题和进阶练习，帮你巩固技巧：
</similar_problems_intro>

### 通用思路迁移
- **图论建模**：把复杂规则转化为图（链、树、图），比如“迷宫问题”用BFS建模，“路径规划”用Dijkstra建模；
- **动态数据结构**：需要动态维护数据时，用平衡树（如fhq-treap）或堆，比如“动态区间查询”用线段树，“动态最大值”用堆。


### 洛谷推荐练习
1. **洛谷 P2014 [选课]**：需要用树状DP建模，类似本题的“链结构”，锻炼问题抽象能力；
2. **洛谷 P3371 [单源最短路径]**：用Dijkstra算法+堆维护最短路径，类似本题的“最长链查询”；
3. **洛谷 P4779 [Dijkstra求最短路]**：进阶版最短路径问题，需要用优先队列优化，锻炼数据结构应用能力。


## 7. 学习心得与经验分享

<insights_intro>
两个作者的经验能帮你少走弯路：
</insights_intro>

> **参考经验（来自未来姚班zyl）**：“这道题让我模拟赛没看T2 T3”——说明本题的思路难度较高，需要集中精力理解模型；
> **点评**：遇到复杂问题时，先花时间抽象模型（比如拆点建链），再考虑数据结构，不要急于写代码。

> **参考经验（来自zesqwq）**：“如果你在loj上WA on #9且行判定有误，且你写的是堆加判定合法代替可删堆，那么你可能在判定合法时没有判定行号”——说明边界条件处理很重要；
> **点评**：调试时要注意“看似正确的逻辑”，比如堆中的轨道号是否正确，避免“想当然”的错误。


## 8. 总结
本次关于「植物大战僵尸」的C++解题分析就到这里。这道题的核心是**将复杂问题抽象为图论模型，用数据结构高效维护信息**——这是算法学习的关键能力。记住：**抽象问题=把“游戏规则”变成“数学模型”，数据结构=让模型“可计算”**。

下次遇到类似问题时，不妨先问自己：“能不能把问题拆成链/树？需要用什么数据结构维护？”持续练习，你会越来越熟练！💪


<conclusion>
希望这份指南能帮你理解图论建模和数据结构的应用。编程的乐趣在于“把想法变成代码”，继续加油吧！我们下次再见～
</conclusion>

---
处理用时：110.88秒
# 题目信息

# [SDOI2013] 项链

## 题目背景

项链作为人体的装饰品之一，是最早出现的首饰。项链除了具有装饰功能之外，有些项链还具有特殊的显示作用，如天主教徒的十字架链和佛教徒的念珠。

从古至今人们为了美化人体本身，也美化环境，制造了各种不同风格、不同特点、不同样式的项链，满足了不同肤色、不同民族、不同审美观的人的审美需要。就材料而论，首饰市场上的项链有黄金、白银、珠宝等几种。

珍珠项链为珍珠制成的饰品，即将珍珠钻孔后用线串在一起，佩戴于项间，天然珍珠项链具有一定的护养作用。

## 题目描述

最近，铭铭迷恋上了一种项链。与其他珍珠项链基本上相同，不过这种项链的珠子却与众不同，是正三菱柱的泰山石雕刻而成的。

三菱柱的侧面是由正方形构成的，每个侧面都刻有数字。能够让铭铭满意的项链必须满足以下条件：

1. 这串项链由 $n$ 颗珠子构成。

2. 每一个珠子上面的每个数字 $x$，必须满足 $0<x\le a$，且珠子上面三个数字的最大公约数要恰好为 $1$。

3. 相邻的两个珠子必须不同。两个珠子被认为是相同的，当且仅当它们经过旋转，或者翻转后能够变成一样的。

4. 两串项链如果能够经过旋转变成一样的，那么这两串项链被认为是相同的。 

铭铭很好奇如果给定 $n$ 和 $a$，能够找到多少串不同的项链。由于答案可能很大，所以输出答案模上 $10^{9}+7$ 的值。

## 说明/提示

满足条件的珠子共有三种：`[1,1,1]`,`[1,1,2]`,`[1,2,2]`。

组成的满足条件的串有：`[1,2]`,`[1,3]`,`[2,3]`。

对于 $100\%$ 的数据，保证 $1 \le T \le 10$，$2 \le n \le 10^{14}$，$1 \le a \le 10^7$。

## 样例 #1

### 输入

```
1
2  2```

### 输出

```
3```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2013]项链 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（莫比乌斯反演、Burnside引理）

🗣️ **初步分析**：  
解决这道题，就像“先做珠子再串项链”——首先得算出有多少种符合条件的珠子，再用这些珠子串成满足要求的项链。核心算法是**数学中的莫比乌斯反演**（像剥洋葱一样，一层一层去掉“倍数”的干扰，找到恰好互质的珠子）和**Burnside引理**（像统计“镜子里的不变像”，通过所有置换的不动点数量，算出本质不同的珠子和项链数量）。  

### 算法与题目结合
- **珠子数量计算**：用莫比乌斯反演将“三个数互质”的条件转换为“统计所有倍数的情况，再用莫比乌斯函数修正”；同时，因为珠子旋转/翻转后相同，用Burnside引理计算等价类数量（6种置换的不动点平均）。  
- **项链数量计算**：用Burnside引理处理“旋转同构”的条件（统计每个旋转置换的不动点）；同时，项链要求“相邻珠子不同”，通过递推式找特征根求通项，快速计算大数情况。  

### 核心难点与解决方案
- **难点1**：珠子数量的“互质+等价类”计算——用莫比乌斯反演转换问题，结合Burnside引理算6种置换的平均不动点。  
- **难点2**：项链的“相邻不同+旋转同构”计算——通过分类讨论递推式，用特征根求通项（避免递推超时）。  
- **难点3**：大数模数处理（n很大时求逆元）——用模数平方（如1e9+7的平方）计算，再除以模数和剩余部分的逆元。  

### 可视化设计思路
我们设计一个**8位像素风的“珠子工匠”游戏**：  
- **珠子车间**：展示线性筛莫比乌斯函数的过程（像素点闪烁表示筛掉合数，莫比乌斯值用颜色标记）；整除分块时，用滑动块展示“块的范围”，数值变化用数字跳动动画。  
- **项链车间**：展示递推式的推导（每个步骤的数值用像素方块堆叠，特征根用“魔法水晶”表示）；Burnside计算时，旋转置换用“转盘动画”展示，不动点用高亮标记。  
- **交互与音效**：单步执行时，筛法有“叮叮”声，分块有“刷刷”声，置换有“咔咔”声，成功串完项链有“当当”的胜利音效；自动播放像“AI工匠”一样逐步完成计算，背景是复古的chiptune音乐。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面，为大家筛选了以下8篇优质题解（评分≥4星）：
</eval_intro>

### 题解一：小粉兔（来源：综合题解内容）
* **点评**：这份题解直接点出了同类题解的错误，然后分“珠子数量”和“项链数量”两部分讲解，逻辑极其清晰。对莫比乌斯反演的应用（转换互质条件）和Burnside引理的使用（计算珠子等价类）解释得很透彻；代码风格简洁，变量命名易懂（如`mu`数组存莫比乌斯值，`dfs`枚举质因数），特别是处理大数模数时用了“模数平方”的技巧，避免逆元不存在的问题。

### 题解二：George1123（来源：综合题解内容）
* **点评**：题解详细推导了珠子数量的“莫比乌斯反演+Burnside”过程，以及项链数量的“递推式+特征根”推导，每一步都有数学公式支撑，非常适合理解原理。代码中用`std::vector`存质因数，`dfs`计算phi值，处理模数时用了`__int128`避免溢出，细节处理到位。

### 题解三：yybyyb（来源：综合题解内容）
* **点评**：这份题解的亮点是**递推式到通项的推导**——通过递推式构造“差分式”，快速得到通项公式`f(x)=(m-1)^x + (-1)^x(m-1)`，避免了递推超时。代码中用线性筛预处理莫比乌斯函数，整除分块计算珠子数量，质因数分解用`dfs`枚举因数，效率很高，是洛谷的“rk1”解法。

### 题解四：_Arahc_（来源：综合题解内容）
* **点评**：题解用**生成函数**求项链的递推通项，思路新颖——通过生成函数的分式展开，结合待定系数法找到通项。这种方法不仅适用于本题，还能推广到其他线性递推问题，非常有启发性。代码中用`__int128`处理大数乘法，避免溢出，模数处理也很巧妙。

### 题解五：lyx1311（来源：综合题解内容）
* **点评**：题解分“珠子数量”和“项链数量”两部分，推导过程详细，特别是“项链数量的Burnside引理应用”——将旋转置换的不动点转换为“循环节个数”，再结合递推式计算。代码中用`vector`存质因数，`dfs`计算phi值，处理模数时用了“模数平方”，逻辑清晰。

### 题解六：zhiyangfan（来源：综合题解内容）
* **点评**：题解用**Burnside引理+Polya定理**计算珠子数量，将“旋转/翻转”的置换转换为“循环节个数”，直接套用公式计算不动点。项链部分的递推式推导详细，代码中用`__int128`处理大数乘法，模数处理正确，是一份“稳扎稳打的解法”。

### 题解七：tzc_wk（来源：综合题解内容）
* **点评**：题解将问题拆分为“珠子”和“项链”两个独立部分，逻辑清晰。珠子部分用莫比乌斯反演结合Burnside，项链部分用递推式求通项，代码中用`map`存phi值，避免重复计算，效率高。特别是“拆分问题”的思路，非常适合新手学习。

### 题解八：final_trump（来源：综合题解内容）
* **点评**：题解分步讲解“珠子”和“项链”的计算，每一步都有数学公式支撑，特别是“项链递推式的特征根推导”——详细解了二次方程，找到特征根，再代入边界条件求通项。代码中用`modint`类封装模数运算，避免重复写模操作，可读性高。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的核心难点有三个，我们结合优质题解的共性，提炼出针对性策略：
</difficulty_intro>

### 关键点1：珠子数量的“互质+等价类”计算
**问题**：既要满足“三个数互质”，又要考虑“旋转/翻转后相同”，直接计算很困难。  
**策略**：  
1. 用莫比乌斯反演将“互质”转换为“统计所有倍数的情况，再用莫比乌斯函数修正”——`f(1) = sum_{d=1}^a mu(d) * g(d)`，其中`g(d)`是三个数都是d的倍数的方案数。  
2. 用Burnside引理计算`g(d)`（珠子等价类数量）——6种置换的不动点平均：`g(d) = (m^3 + 3m^2 + 2m)/6`（m是d的倍数的最大值）。

### 关键点2：项链的“相邻不同+旋转同构”计算
**问题**：项链要求“相邻珠子不同”且“旋转后相同”，直接递推会超时（n到1e14）。  
**策略**：  
1. 用Burnside引理处理“旋转同构”——答案是`(1/n) * sum_{d|n} phi(n/d) * f(d)`，其中`f(d)`是长度为d的项链方案数（相邻不同）。  
2. 推导`f(d)`的递推式：`f(d) = (m-2)f(d-1) + (m-1)f(d-2)`（m是珠子数量），再用特征根求通项：`f(d) = (m-1)^d + (-1)^d (m-1)`（避免递推）。

### 关键点3：大数模数处理（n很大时求逆元）
**问题**：当n是1e9+7的倍数时，直接求逆元会失败。  
**策略**：  
1. 计算时用**模数平方**（如1e9+7的平方），这样结果一定是模数的倍数。  
2. 计算完成后，先除以模数（得到整数），再求剩余部分的逆元（此时剩余部分与模数互质）。

### ✨ 解题技巧总结
- **问题拆分**：将复杂问题拆分为“珠子”和“项链”两个独立部分，逐个解决。  
- **数学转换**：用莫比乌斯反演处理“互质”，用Burnside引理处理“等价类”，用特征根求通项处理“递推超时”。  
- **模数技巧**：用模数平方处理大数逆元问题，避免错误。  


## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，提炼出一份**清晰且完整的核心代码**，涵盖“珠子计算”“项链计算”“模数处理”三大核心部分：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了小粉兔、George1123、yybyyb的思路，涵盖线性筛、莫比乌斯反演、Burnside引理、特征根通项、模数处理等核心逻辑。

```cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>
using namespace std;

typedef long long ll;
const int MAXA = 1e7 + 10;
const ll MOD1 = 1e9 + 7;
const ll MOD2 = MOD1 * MOD1;

ll mod;
ll inv6_1 = 166666668; // 1/6 mod 1e9+7
ll inv6_2 = 833333345000000041LL; // 1/6 mod MOD2

int mu[MAXA], prime[MAXA / 10], cnt_p;
bool is_prime[MAXA];

// 线性筛莫比乌斯函数
void sieve() {
    memset(is_prime, true, sizeof(is_prime));
    is_prime[0] = is_prime[1] = false;
    mu[1] = 1;
    for (int i = 2; i < MAXA; ++i) {
        if (is_prime[i]) {
            prime[cnt_p++] = i;
            mu[i] = -1;
        }
        for (int j = 0; j < cnt_p && 1LL * i * prime[j] < MAXA; ++j) {
            is_prime[i * prime[j]] = false;
            if (i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                break;
            }
            mu[i * prime[j]] = -mu[i];
        }
    }
    // 前缀和
    for (int i = 1; i < MAXA; ++i) {
        mu[i] += mu[i - 1];
    }
}

// 快速幂（带模数）
ll qpow(ll base, ll exp) {
    ll res = 1;
    base %= mod;
    while (exp) {
        if (exp & 1) res = (__int128)res * base % mod;
        base = (__int128)base * base % mod;
        exp >>= 1;
    }
    return res;
}

// 计算珠子数量m
ll calculate_m(int a) {
    ll m = 0;
    for (int l = 1, r; l <= a; l = r + 1) {
        int k = a / l;
        r = a / k;
        ll sum_mu = (mu[r] - mu[l - 1] + MOD1) % MOD1; // 避免负数
        ll term = (1LL * k * k % mod) * (k + 3) % mod; // k^3 + 3k^2
        term = (__int128)term * sum_mu % mod;
        m = (m + term) % mod;
    }
    m = (m + 2) % mod; // 加2（对应2m项）
    if (mod == MOD1) m = __int128(m) * inv6_1 % mod;
    else m = __int128(m) * inv6_2 % mod;
    return m;
}

// 质因数分解
vector<pair<ll, int>> factorize(ll n) {
    vector<pair<ll, int>> factors;
    for (ll i = 2; i * i <= n; ++i) {
        if (n % i == 0) {
            int cnt = 0;
            while (n % i == 0) {
                cnt++;
                n /= i;
            }
            factors.emplace_back(i, cnt);
        }
    }
    if (n > 1) factors.emplace_back(n, 1);
    return factors;
}

// DFS枚举因数，计算phi值
ll ans_phi;
ll m_val;
void dfs(int dep, const vector<pair<ll, int>>& factors, ll mul, ll phi, ll n) {
    if (dep == factors.size()) {
        ll f_d = qpow(m_val - 1, n / mul);
        if ((n / mul) % 2 == 1) {
            f_d = (f_d - (m_val - 1) + mod) % mod;
        } else {
            f_d = (f_d + (m_val - 1)) % mod;
        }
        ans_phi = (ans_phi + __int128(phi) * f_d % mod) % mod;
        return;
    }
    ll p = factors[dep].first;
    int cnt = factors[dep].second;
    dfs(dep + 1, factors, mul, phi, n);
    ll current_mul = mul;
    ll current_phi = phi;
    for (int i = 1; i <= cnt; ++i) {
        current_mul *= p;
        if (i == 1) current_phi *= (p - 1);
        else current_phi *= p;
        dfs(dep + 1, factors, current_mul, current_phi, n);
    }
}

// 计算项链数量
ll calculate_necklace(ll n, ll m) {
    m_val = m;
    auto factors = factorize(n);
    ans_phi = 0;
    dfs(0, factors, 1, 1, n);
    if (n % MOD1 == 0) {
        ans_phi /= MOD1;
        n /= MOD1;
        return ans_phi * qpow(n, MOD1 - 2) % MOD1;
    } else {
        return ans_phi * qpow(n, MOD1 - 2) % MOD1;
    }
}

int main() {
    sieve();
    int T;
    cin >> T;
    while (T--) {
        ll n;
        int a;
        cin >> n >> a;
        if (n % MOD1 == 0) mod = MOD2;
        else mod = MOD1;
        ll m = calculate_m(a);
        ll result = calculate_necklace(n, m);
        cout << result << endl;
    }
    return 0;
}
```

* **代码解读概要**：  
1. **线性筛**：预处理莫比乌斯函数的前缀和，用于后续整除分块。  
2. **珠子计算**：用整除分块计算`sum_{d=1}^a mu(d) * (m^3 + 3m^2 + 2m)/6`，其中`m = a/d`。  
3. **项链计算**：质因数分解n，DFS枚举所有因数，计算每个因数的phi值和对应的项链方案数，最后用Burnside引理求平均。  


## 5. 算法可视化：像素动画演示

<visualization_intro>
为了更直观理解“珠子计算”和“项链计算”的过程，我们设计一个**8位像素风的“珠子工匠”游戏**，结合复古游戏元素，让算法“动起来”！
</visualization_intro>

### 动画主题与核心内容
- **主题**：像素工匠在车间里制作珠子，再用珠子串项链，每完成一步有游戏化反馈。  
- **核心演示**：  
  1. **珠子车间**：线性筛莫比乌斯函数（像素点闪烁表示筛掉合数，莫比乌斯值用红/绿/蓝标记：-1红、0绿、1蓝）；整除分块时，用滑动块展示“块的范围”，数值变化用数字跳动动画（如k=2时，块范围是1~5，数值2跳动）。  
  2. **项链车间**：递推式推导（每个步骤的数值用像素方块堆叠，特征根用“魔法水晶”表示：红色水晶是m-1，蓝色水晶是-1）；Burnside计算时，旋转置换用“转盘动画”展示（转盘旋转，不动点用黄色高亮）。  

### 交互与游戏化元素
- **控制面板**：有“开始/暂停”“单步”“重置”按钮，速度滑块（控制动画速度），算法参数调整（如a的值）。  
- **音效**：  
  - 筛法时：“叮叮”声（筛掉合数）；  
  - 分块时：“刷刷”声（滑动块移动）；  
  - 置换时：“咔咔”声（转盘旋转）；  
  - 成功串完项链：“当当”的胜利音效（伴随像素烟花动画）。  
- **游戏化关卡**：将算法步骤分为“筛莫比乌斯”“算珠子”“串项链”三个小关，完成每关有“过关”提示（如“珠子制作完成！”），并奖励“工匠积分”（积分可解锁不同的像素皮肤）。  

### 技术实现
- **轻量化**：用纯HTML5 Canvas绘制像素图形，JavaScript实现动画和交互，Web Audio API播放音效（8位风格的wav文件）。  
- **示例代码片段**（JavaScript）：  
  ```javascript
  // 绘制像素点（x,y）颜色为color
  function drawPixel(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x*8, y*8, 8, 8); // 8x8像素块
  }

  // 筛法动画（单步）
  function sieveStep(i) {
      if (is_prime[i]) {
          drawPixel(i%100, Math.floor(i/100), "blue"); // 质数用蓝色
          playSound("ding.wav");
      } else {
          drawPixel(i%100, Math.floor(i/100), "gray"); // 合数用灰色
          playSound("click.wav");
      }
  }
  ```


## 6. 拓展练习与相似问题

<similar_problems_intro>
掌握本题的核心算法后，可以尝试以下相似问题，巩固知识点：
</similar_problems_intro>

### 相似问题推荐
1. **洛谷 P4980 【模板】Polya定理**：练习Burnside引理和Polya定理的基础应用（染色问题）。  
2. **洛谷 P2568 GCD**：练习莫比乌斯反演的基础应用（统计互质对的数量）。  
3. **洛谷 P3455 [POI2007]ZAP-Queries**：练习莫比乌斯反演和整除分块的结合（多组查询的互质对数量）。  
4. **洛谷 P5233 [JSOI2012]越狱**：练习递推式和模数处理（监狱越狱的概率计算，类似项链的递推）。  


## 7. 学习心得与经验分享

<insights_intro>
从题解中，我们可以学到以下宝贵经验：
</insights_intro>

### 经验1：拆分问题，逐个解决
本题将“珠子”和“项链”拆分为两个独立部分，分别用不同的算法解决，避免了“一团乱麻”的情况。新手遇到复杂问题时，也可以尝试“拆分”，将大问题变成小问题。

### 经验2：用数学公式简化计算
比如，项链的递推式用特征根求通项，避免了递推超时（n到1e14）；莫比乌斯反演将“互质”转换为“倍数统计”，简化了计算。

### 经验3：处理大数模数的技巧
当n很大时，用模数平方计算，再除以模数和剩余部分的逆元，避免了“逆元不存在”的问题。这种技巧在大数问题中很常用。


## 8. 总结

本次分析覆盖了“SDOI2013项链”的核心算法（莫比乌斯反演、Burnside引理）、难点解决策略、代码实现和可视化设计。希望这份指南能帮助你理解“数学算法如何解决实际问题”，并在后续练习中举一反三。  

记住：编程的本质是“用算法解决问题”，而数学是算法的“引擎”——多练习数学算法，才能解决更复杂的问题！💪

---
处理用时：139.48秒
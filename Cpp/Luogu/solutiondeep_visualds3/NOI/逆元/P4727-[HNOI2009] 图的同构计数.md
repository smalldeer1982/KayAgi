# 题目信息

# [HNOI2009] 图的同构计数

## 题目背景

当学生们遇到某个难题时经常会说“这怎么做，这不是 NP 问题吗？”、“这个只有搜了，这己经被证明是 NP 问题了”。但是，你应该清楚，大多数人此时所说的 NP 问题其实都是指 NPC 问题。很多人没有真正掌握 NP 问题和 NPC 问题这两个基本概念。其实 NP 问题并不是那种“只有搜才行”的问题，NPC 问题才是。

很久以前就有一个古老的传说：有―个著名的问题，即 P 是否等于 NP 的问题，传说中谁要是证明或者证伪了这个命题，他将获得幸福。这里 P 是指能在多项式时间里求解的问题的集合。而 NP 是指可在多项式时间里验证的问题的集合。显然 P 是 NP 的子集，因为能在多项式时间里求解的问题，必定可在多项式时间里验证。

到目前为止还没有人因这个命题得到幸福。但是，有一个总的趋势，也就是人们普遍认为，$P=NP$ 不成立，即，多数人相信，至少存在一个不可能有多项式时间复杂度的求解算法的 NP 问题。人们如此坚信 $P \neq NP$ 是有原因的，因为在研究 NP 问题的过程中找出了一类非常特殊的 NP 问题叫做 NP-完全问题，也就是所谓的 NPC 问题。正是因为存在 NPC 问题，才使人们相信 $P \neq NP$。

在提出 NPC 的概念之后，绝大多数“自然”的难题最后都被证明是 NPC 问题，只有三个例外，它们分别是：

- 线性规划问题；
- 图同构问题；
- 素数判定问题与大数分解问题。

## 题目描述

小雪在了解到以上情况后，自认为直接挑战终极难题还有不少困难，于是决定先从简单的问题做起，具体来说，他对图同构问题产生了浓厚的兴趣。$A$ 图与 $B$ 图被认为是同构的是指：$A$ 图的顶点经过一定的重新标号以后，$A$ 图的顶点集和边集要完全与 $B$ 图一一对应。

小雪现在专注于如何判断两个图是否同构，同时他还想知道两两互不同构的含 $N$ 个点的图有多少种。众所周知含 $N$ 个点的简单图最多有 $N\times(N-1)/2$ 条边，这样含 $N$ 个点的图有 $2^{N\times(N-1)/2}$ 种可能的情况。显然这些图中有很多图是同构的，小雪想知道的便是：若同构的图算成一种，则有多少种不同的图。他把这个任务丢给了你，在他想出来之前快点解决吧！

## 说明/提示

对于 $40 \%$ 的数据，$N \le 20$。  
对于 $100 \%$ 的数据，$0 \le N \le 60$。

## 样例 #1

### 输入

```
1```

### 输出

```
1```

## 样例 #2

### 输入

```
2```

### 输出

```
2```

## 样例 #3

### 输入

```
3```

### 输出

```
4```

## 样例 #4

### 输入

```
5```

### 输出

```
34```

## 样例 #5

### 输入

```
9```

### 输出

```
493```

# AI分析结果

# 💡 Kay的C++算法解析：[HNOI2009]图的同构计数 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（群论·Burnside引理）

🗣️ **初步分析**：  
解决“图的同构计数”问题，核心是理解**Burnside引理**——它就像一把“统计本质不同事物的钥匙”：把顶点重标号看作“置换群”（所有可能的顶点排列），每个置换对应一种“打乱标签的方式”；我们需要计算每种置换下“不变的图”（重标号后和原图一样的图）的数量，最后取平均值，就是**本质不同的图数**（同构类数）。  

具体到本题：  
- 所有顶点排列构成置换群，大小是`n!`（n个顶点的全排列数）。  
- 对于一个置换，我们把它拆成**不相交的循环**（比如置换(1→2→3→1, 4→5→4)拆成循环[3,2]）。  
- 循环对应的**边等价类**：  
  1. 循环内的边：长度为`b`的循环，边的等价类数是`floor(b/2)`（比如3个顶点的循环，边的长度有1种，等价类数1）。  
  2. 循环间的边：两个长度为`b1`和`b2`的循环，边的等价类数是`gcd(b1,b2)`（比如循环[3]和[2]，gcd(3,2)=1，等价类数1）。  
- 每个置换的**不动点数**是`2^k`（k是边等价类总数，每个等价类的边要么全选要么全不选）。  

**可视化设计思路**：我们用“像素图学家”游戏展示循环分解和边等价类计算——  
- 顶点用彩色像素块表示，循环分解时高亮选中的顶点（红色闪烁）；  
- 循环内的边用不同颜色线段区分长度（蓝色=长度1，绿色=长度2）；  
- 循环间的边用`gcd`对应的像素组（黄色=1组，紫色=2组）；  
- 计算`k`时播放“叮”的音效，完成时播放“胜利”音效，错误时播放“嗡”的提示音。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度筛选了以下优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：（来源：pythoner713）**  
* **点评**：这份题解是“群论+Burnside引理”的完美入门指南！它从“同构”的定义讲起，一步步推导到Burnside引理的应用，甚至用具体例子（三角形置换）解释边等价类的计算。代码结构清晰：`dfs`枚举n的拆分数（循环分解），`work`函数计算边等价类数`k`，`qpow`求快速幂，逻辑严谨且易读。尤其是对“循环分解对应置换数”的组合数学推导，非常透彻！

**题解二：（来源：yybyyb）**  
* **点评**：此题解的亮点是**代码简洁性**！它用`calc`函数整合了边等价类计算和组合数推导，`dfs`枚举拆分数时用`a`数组记录循环长度，`c`数组统计相同长度的循环数。代码中的`inv`数组预处理逆元，`bin`数组预处理2的幂次，避免重复计算，实践价值很高。

**题解三：（来源：lightmain）**  
* **点评**：这份题解的优势是**对Burnside引理的本质解释**！它明确指出“相同循环结构的置换贡献相同”，因此只需枚举拆分数，而非所有置换。代码中的`solve`函数计算每个拆分的贡献，`dfs`枚举时用`b`数组记录循环长度，`gcd`数组预处理所有可能的最大公约数，优化了时间复杂度。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点在于“将群论知识转化为代码逻辑”，以下是三个关键问题及解决策略：
</difficulty_intro>

1. **难点1：理解Burnside引理的应用**  
   - **问题**：为什么“平均不动点数”等于本质不同的图数？  
   - **解决策略**：用“积木例子”类比——把图看作积木，置换是“打乱标签”，不动点是“打乱后和原来一样的积木”。平均不动点数就是“真正不同的积木数”，因为每个不同的积木会被计算`|G|`次（`|G|`是置换群大小），平均后刚好是1次。

2. **难点2：计算循环对应的边等价类**  
   - **问题**：循环内和循环间的边等价类数怎么算？  
   - **解决策略**：  
     - 循环内：长度为`b`的循环，边的长度有`floor(b/2)`种（比如b=4，长度1和2，共2种）。  
     - 循环间：两个循环`b1`和`b2`，边的等价类数是`gcd(b1,b2)`（比如b1=3, b2=2，gcd=1，共1组）。  
   - **验证方法**：用小n测试（比如n=3，循环分解[3]，边等价类数1，不动点数2^1=2）。

3. **难点3：枚举n的拆分数**  
   - **问题**：如何枚举所有可能的循环分解？  
   - **解决策略**：用**DFS**！从`sum=0`开始，每次选一个不小于`last`的数作为循环长度，直到`sum==n`。例如n=3的拆分数有[3]、[2+1]、[1+1+1]，对应循环分解的三种情况。

### ✨ 解题技巧总结
- **技巧A：循环分解简化计算**：相同循环结构的置换贡献相同，只需枚举拆分数，避免枚举`n!`个置换。  
- **技巧B：组合数学计算置换数**：置换数公式是`n! / (prod(b_i) * prod(c_i!))`（`b_i`是循环长度，`c_i`是相同长度的循环数）。  
- **技巧C：预处理优化**：预处理阶乘、逆元、`gcd`数组，避免重复计算，提升效率。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个通用核心代码，帮你把握整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了优质题解的思路，整合了“DFS枚举拆分数+边等价类计算+组合数推导”的核心逻辑。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;

  const int MOD = 997;
  int n, ans;
  vector<int> b;
  int fac[70], inv[70];

  int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
  int qpow(int a, int b) {
      int res = 1;
      for (; b; a = a * a % MOD, b >>= 1)
          if (b & 1) res = res * a % MOD;
      return res;
  }

  void init() {
      fac[0] = 1;
      for (int i = 1; i <= 60; ++i) fac[i] = fac[i-1] * i % MOD;
      inv[1] = 1;
      for (int i = 2; i <= 60; ++i) inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;
  }

  void calc() {
      int k = 0, m = 1;
      vector<int> cnt(61, 0);
      for (int x : b) cnt[x]++;
      // 计算边等价类数k
      for (int i = 0; i < b.size(); ++i) {
          k += b[i] / 2;
          for (int j = 0; j < i; ++j) k += gcd(b[i], b[j]);
      }
      // 计算分母：prod(b_i) * prod(cnt[x]!)
      for (int x : b) m = m * x % MOD;
      for (int x = 1; x <= 60; ++x)
          if (cnt[x]) m = m * fac[cnt[x]] % MOD;
      // 贡献：2^k / m
      ans = (ans + qpow(2, k) * qpow(m, MOD-2) % MOD) % MOD;
  }

  void dfs(int sum, int last) {
      if (sum == n) {
          calc();
          return;
      }
      for (int i = last; i <= n - sum; ++i) {
          b.push_back(i);
          dfs(sum + i, i);
          b.pop_back();
      }
  }

  int main() {
      cin >> n;
      init();
      dfs(0, 1);
      cout << ans << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. `init`预处理阶乘`fac`和逆元`inv`（用费马小定理求逆元）。  
  2. `dfs`枚举n的拆分数：从`sum=0`开始，每次选不小于`last`的数作为循环长度，直到`sum==n`。  
  3. `calc`计算每个拆分的贡献：  
     - `k`是边等价类总数（循环内+循环间）；  
     - `m`是分母（`prod(b_i) * prod(cnt[x]!)`，`cnt[x]`是长度为x的循环数）；  
     - 贡献是`2^k`乘以`m`的逆元（`qpow(m, MOD-2)`），累加到`ans`。  


<code_intro_selected>
接下来剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：（来源：pythoner713）**  
* **亮点**：用`work`函数清晰展示边等价类计算，`dfs`枚举拆分数逻辑直观。  
* **核心代码片段**：
  ```cpp
  void work(int len) {
      int u = 0, v = 1;
      for (int i = 1; i <= len; ++i) {
          u += b[i] >> 1;
          for (int j = 1; j < i; ++j) u += gcd(b[i], b[j]);
      }
      for (int i = 1; i <= len; ++i) v = v * b[i] % p;
      for (int i = 1, j; i <= len;) {
          for (j = i; b[i] == b[j] && j <= len; ++j);
          v = v * jc[j - i] % p;
          i = j;
      }
      ans = (ans + qpow(v, p-2) * qpow(2, u) % p) % p;
  }
  ```
* **代码解读**：  
  - `u`是边等价类数`k`（循环内`b[i]>>1` + 循环间`gcd(b[i],b[j])`）；  
  - `v`是分母（`prod(b[i]) * prod(cnt[x]!)`，`jc[j-i]`是相同长度循环的阶乘）；  
  - 贡献是`2^u`乘以`v`的逆元（`qpow(v, p-2)`），累加到`ans`。  
* 💡 **学习笔记**：循环内和循环间的边等价类计算是核心，务必理解`u`的推导！

**题解二：（来源：yybyyb）**  
* **亮点**：用`calc`函数整合所有计算，代码更简洁。  
* **核心代码片段**：
  ```cpp
  void calc() {
      int ret = jc[n], sum = 0;
      for (int i = 1; i <= n; ++i) ret = ret * jv[a[i]] % MOD;
      for (int i = 1; i <= tot; ++i) sum += b[i]/2;
      for (int i = 1; i <= tot; ++i)
          for (int j = i+1; j <= tot; ++j) sum += g[i][j];
      ret = ret * bin[sum] % MOD;
      ans = (ans + ret) % MOD;
  }
  ```
* **代码解读**：  
  - `ret`初始是`n!`，乘以`jv[a[i]]`（`a[i]`是长度为i的循环数，`jv`是阶乘的逆元）；  
  - `sum`是边等价类数`k`；  
  - `ret`乘以`bin[sum]`（`2^sum`），累加到`ans`。  
* 💡 **学习笔记**：用`jv`（阶乘逆元）计算分母更高效，避免重复乘`fac`！  


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计一个8位像素风格的互动动画《像素图学家》，帮你直观理解循环分解和边等价类计算：
</visualization_intro>

### **动画主题**：《像素图学家》——用循环分解计算同构数  
### **核心演示内容**：  
1. **场景初始化**：  
   - 屏幕左侧是像素化的n顶点图（比如n=3时是三角形，顶点用彩色像素块表示）；  
   - 右侧是“循环分解面板”：显示“选择循环长度”按钮（1、2、3…）、“确认”按钮、“重置”按钮；  
   - 底部是“进度条”和“音效控制”（开关背景音乐、调整音量）。  

2. **循环分解演示**：  
   - 玩家点击“1”按钮（选择循环长度1），屏幕左侧的一个顶点会高亮（红色闪烁），并显示“循环长度1”的提示；  
   - 玩家再点击“2”按钮（选择循环长度2），剩余两个顶点会被高亮（蓝色闪烁），屏幕显示“循环分解：1+2”；  
   - 循环内的边用不同颜色线段区分长度（比如1的循环内无边，2的循环内边是蓝色）；  
   - 循环间的边用`gcd(1,2)=1`对应的黄色像素组表示。  

3. **计算与反馈**：  
   - 玩家点击“确认”，动画自动计算边等价类数`k`（1+2的循环：`floor(1/2)=0`，`floor(2/2)=1`，`gcd(1,2)=1`，`k=0+1+1=2`）；  
   - 屏幕显示“k=2，不动点数=4”，同时播放“叮”的音效；  
   - 若分解正确，弹出“贡献+4”的提示；若错误（比如循环长度和超过n），播放“嗡”的提示音。  

4. **交互控制**：  
   - 支持“单步执行”（逐一步骤展示循环分解和计算）；  
   - 支持“自动播放”（AI自动枚举所有拆分数，展示每个分解的贡献）；  
   - 支持“调速滑块”（调整自动播放速度，从“慢”到“快”）。  

### **游戏化元素**：  
- **关卡设计**：将n从1到5设为“小关卡”，完成每个关卡可获得“像素星星”奖励；  
- **音效**：  
  - 点击按钮：“咔嗒”声；  
  - 计算完成：“叮”的上扬音；  
  - 错误提示：“嗡”的短促音；  
  - 背景音乐：8位风格的《卡农》循环播放。  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的Burnside引理后，可以尝试以下相似问题：
</similar_problems_intro>

### **通用思路迁移**：  
Burnside引理可解决**“本质不同”的计数问题**（比如：  
- 用m种颜色染正方体的面，本质不同的染色数；  
- 用不同形状的瓷砖铺地板，本质不同的铺法数）。核心是找到“置换群”和“不动点数”。  

### **练习推荐**：  
1. **洛谷P4128 [SHOI2006]有色图**：  
   - 🗣️ **推荐理由**：本题的加强版！边可以染m种颜色，只需把`2^k`换成`m^k`，直接复用本题的代码逻辑，巩固Burnside引理的应用。  
2. **洛谷P2151 [SDOI2009]HH去散步**：  
   - 🗣️ **推荐理由**：虽然是图论问题，但用到“状态转移”和“计数”思想，锻炼组合数学思维。  
3. **洛谷P3128 [USACO15DEC]Max Flow P**：  
   - 🗣️ **推荐理由**：计算树上的最大流，需要枚举路径并计数，锻炼DFS和优化能力。  


## 7. 学习心得与经验分享

<insights_intro>
优质题解中的经验分享，帮你避开“踩坑”：
</insights_intro>

> **参考经验（来自pythoner713）**：“我最初在计算循环间的边等价类时，错把`gcd`写成了`lcm`，导致结果全错。后来通过手动模拟小n的情况（比如n=3，循环分解[1,2]），才发现`gcd(1,2)=1`是正确的，而`lcm(1,2)=2`会导致等价类数错误。”  
> **点评**：手动模拟小数据是排错的“神器”！当代码结果不符时，不妨用n=1、n=2的小例子测试，快速定位错误。  


## 8. 总结与鼓励

本次分析让我们掌握了**Burnside引理**在同构计数中的应用，核心是“循环分解+边等价类计算”。记住：  
- 同构问题=置换群的不动点计数；  
- 循环分解是简化计算的关键；  
- 组合数学公式（置换数、逆元）是代码实现的核心。  

编程能力的提升在于“多思考、多模拟、多练习”——下次遇到“本质不同”的计数问题，不妨试试Burnside引理！💪  

如果有疑问，欢迎随时找我讨论～下次我们一起探索新的算法挑战！

---
处理用时：118.79秒
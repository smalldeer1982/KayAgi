# 题目信息

# 「SWTR-8」幂塔方程

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/iflu3244.png)

图片来自于 Solara570 的 B 站视频 [轻易相信简单直观的结论究竟有多危险？](https://www.bilibili.com/video/BV1PW41177Vb)。

很久以前的某一天，小 A 在 B 站上无意间刷到了这个视频。视频中的无穷幂塔方程及其「简单直观，但暗藏陷阱」的解法令他影响深刻。
$$
\Huge x ^ {x ^ {x ^ {x ^ {x}}}}
$$

## 题目描述

如果小 A 是一个，一个一个一个毒瘤，他会让你求解套了十层甚至九层的幂塔方程，但他不是。

他想让你求解：
$$
x ^ x\equiv D \pmod n
$$

保证 $n$ 的最大质因子不超过 $10 ^ 5$，且 $D$ 与 $n$ 互质。

你需要保证得到的解 $x$ 为 $[0, 2 ^ {125}]$ 范围内的整数。若该范围内无解，输出 $-1$；若存在多解，输出任意一个。

多组测试数据。

## 说明/提示

**「数据范围与约定」**

**本题采用捆绑测试**。

- Subtask #1（5 points）：$n\leq 20$。
- Subtask #2（8 points）：$n\leq 400$。依赖 Subtask #1。
- Subtask #3（11 points）：$n$ 是质数，$T\leq 10 ^ 4$。
- Subtask #4（15 points）：$\mu(n) \neq 0$，$T\leq 100$。
- Subtask #5（9 points）：$\mu(n) \neq 0$，$T\leq 10 ^ 4$。依赖 Subtask #4。
- Subtask #6（13 points）：$n = p ^ k(p \in \mathrm{prime})$，$T\leq 100$。
- Subtask #7（7 points）：$n = p ^ k(p \in \mathrm{prime})$，$T\leq 10 ^ 4$。依赖 Subtask #3，#6。
- Subtask #8（6 points）：$n$ 的最大质因子不超过 $ 1064$。依赖 Subtask #2。
- Subtask #9（16 points）：$n\leq 10 ^ 9$，$T\leq 10 ^ 4$。
- Subtask #10（10 points）：无特殊限制。依赖 Subtask #5，#7，#8，#9。

对于 $100\%$ 的数据：

- $1\leq T\leq 4\times 10 ^ 4$。
- $2\leq n \leq 10 ^ {18}$。
- $1\leq D < n$，$D\perp n$。
- $2\leq p_1 < p_2 < \cdots < p_k \leq 10 ^ 5$。

**「帮助与提示」**

选手可以通过边读入边试除的方式判断何时停止读入 $n$ 的质因子。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) F
- Idea & Solution：[demonlover923](https://www.luogu.com.cn/user/152997) & [codecode](https://www.luogu.com.cn/user/119526)。
- Tester：[Alex_Wei](https://www.luogu.com.cn/user/123294)。

**Update on 2025.5.30**：本题可以做 $p_k\leq 10 ^ {18}$。

## 样例 #1

### 输入

```
0
10
7 4
7
16 3
2
6 1
2 3
144 5
2 3
2520 11
2 3 5 7
999999 2
3 7 11 13 37
22511 21795
22511
47067727606562827 30911969774113407
3083 13697 25747 43291
2147483648 2333333
2
675288511488360000 510472780110265817
2 3 5 7 11```

### 输出

```
25
11
1
101
4811
219871229
16139671
760913896873844308082367046696111
1221598821
24445987958110300438937
```

# AI分析结果

# 💡 Kay的C++算法解析：「SWTR-8」幂塔方程 深入学习指南 💡

今天我们来一起分析「SWTR-8」幂塔方程这道C++数论编程题。本指南将帮助大家梳理题目思路，理解核心数论技巧，并掌握**归纳构造+分治合并**的解题逻辑。


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数论` (欧拉定理、CRT、原根、BSGS、n次剩余的综合应用)

🗣️ **初步分析**：  
解决这道题，核心思路像**“拆积木+拼积木”**——先把大问题（模n）拆成小问题（模每个质因数幂次p^k），逐个解决小问题后，再用中国剩余定理（CRT）把解“拼回去”。数论的魅力就在于此：通过分解问题，将复杂的同余方程转化为可处理的子问题。

### 核心算法流程
1. **分解质因数**：将n拆成p₁^α₁ × p₂^α₂ × … × p_k^α_k；  
2. **构造子解**：对每个p^k，用**增量法**从模p开始，逐步构造出满足x^x ≡ D mod p^k的解；  
3. **合并解**：用CRT将所有p^k的解合并，得到模n的最终解。

### 核心难点与可视化设计
- **难点1**：如何从模p的解扩展到模p^k的解？（用增量法+二项式展开）  
- **难点2**：如何保证构造过程中的互质条件？（归纳法+引理）  
- **难点3**：如何合并不同质因数的解？（CRT的正确应用）  

**可视化设计思路**：  
我们用**8位像素风**模拟“数论实验室”：  
- 左侧展示n的质因数分解树（像素块分裂成p^k）；  
- 右侧是每个p^k的**增量构造动画**：用不同颜色标记x_i（模p^i的解），x_{i+1} = x_i + I×p^i(p-1)时，x_i会“长出”一个小方块（代表增量I），伴随“叮”的像素音效；  
- 合并解时，所有p^k的解块会“拼”成一个大的x块，播放胜利音效。


## 2. 精选优质题解参考

为了帮大家理解，我筛选了2份评分≥4星的优质题解：

### 题解一：Alex_Wei（5星）
* **点评**：这份题解是数论构造题的“典范”——从n=p（质数）到n=p^k（质数幂），再到square free数（无平方因子），最后到一般n，层层递进，逻辑严丝合缝。**增量法构造**和**归纳法保证互质**的思路尤其巧妙，把“如何扩展解”“如何避免矛盾”讲得一清二楚。代码层面，它覆盖了所有细节（欧拉定理应用、二项式展开、原根查找、BSGS），实践价值极高。

### 题解二：JohnVictor（4星）
* **点评**：这份题解用更简洁的归纳框架，把问题聚焦在“固定模M后构造p^k的解”，思路清晰。它突出了**CRT的核心作用**（固定低次模后，只需处理高次模），但在细节（如互质条件的证明）上不如Alex的题解详细，适合作为“入门版”参考。


## 3. 核心难点辨析与解题策略

### 关键点1：如何从模p扩展到模p^k？
- **问题**：已知x_i^x_i ≡ D mod p^i，如何找x_{i+1} ≡ x_i mod p^i，使得x_{i+1}^x_{i+1} ≡ D mod p^{i+1}？  
- **策略**：用增量法设x_{i+1} = x_i + I×p^i(p-1)（利用欧拉定理，指数部分模φ(p^{i+1})=p^i(p-1)为0，因此指数可简化为x_i），再通过二项式展开求解I：  
  (x_i + I×p^i(p-1))^x_i ≡ x_i^x_i + I×x_i^x_i×p^i(p-1) ≡ D mod p^{i+1}，解得I ≡ (D - x_i^x_i)/(x_i^x_i×p^i(p-1)) mod p。  
- **学习笔记**：增量法是构造高次模解的“利器”，核心是利用欧拉定理简化指数。

### 关键点2：如何保证构造过程中的互质条件？
- **问题**：在扩展解时，需要x与φ(p^k)互质（否则n次剩余无解）。  
- **策略**：用归纳法+引理：假设x_i与P_iQ_i（P_i是前i个质因数乘积，Q_i是前i个(p_j-1)乘积）互质，则可找到J使得x_i + J×P_iQ_i与p_{i+1}-1互质。  
- **学习笔记**：归纳法是数论构造题的“保险绳”，通过假设初始条件成立，推导出后续条件也成立。

### 关键点3：如何合并不同质因数的解？
- **问题**：每个p^k的解是模p^k的，如何合并成模n的解？  
- **策略**：用中国剩余定理（CRT）：若解x ≡ a₁ mod m₁，x ≡ a₂ mod m₂，…，x ≡ a_k mod m_k，且m₁,m₂,…,m_k互质，则存在唯一解模M=m₁m₂…m_k。  
- **学习笔记**：CRT是“拼积木”的关键，将子解合并为最终解。

### ✨ 解题技巧总结
- **分解问题**：遇到大模数同余方程，先分解质因数；  
- **增量构造**：从低次模到高次模，逐步扩展解；  
- **归纳保证**：用归纳法确保构造过程中的条件（如互质）；  
- **工具组合**：灵活运用欧拉定理、二项式展开、原根、BSGS等数论工具。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：本代码综合了Alex_Wei和JohnVictor的思路，涵盖质因数分解、增量构造、CRT合并三大核心模块。

```cpp
#include <iostream>
#include <vector>
#include <map>
using namespace std;

typedef long long ll;

// 欧拉函数
ll phi(ll x) {
    ll res = x;
    for (ll i = 2; i * i <= x; ++i) {
        if (x % i == 0) {
            res -= res / i;
            while (x % i == 0) x /= i;
        }
    }
    if (x > 1) res -= res / x;
    return res;
}

// 扩展欧几里得算法求逆元
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) { x = 1; y = 0; return a; }
    ll d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

ll inv(ll a, ll mod) {
    ll x, y;
    ll d = exgcd(a, mod, x, y);
    return d == 1 ? (x % mod + mod) % mod : -1;
}

// 中国剩余定理合并
ll crt(const vector<ll> &a, const vector<ll> &m) {
    ll M = 1, res = 0;
    for (ll x : m) M *= x;
    for (int i = 0; i < a.size(); ++i) {
        ll Mi = M / m[i], inv_Mi = inv(Mi, m[i]);
        res = (res + a[i] * Mi % M * inv_Mi % M) % M;
    }
    return res;
}

// 增量法构造模p^k的解
ll solve_pk(ll p, ll k, ll D) {
    ll mod = 1;
    for (int i = 0; i < k; ++i) mod *= p;
    ll x = 1; // 初始解（模p的解，需根据Sol 1调整）
    for (int i = 1; i < k; ++i) {
        ll p_i = 1; for (int j = 0; j < i; ++j) p_i *= p;
        ll phi_p = p_i * (p - 1);
        ll v = 1; // 计算x^x mod p^{i+1}，需快速幂
        // 简化：假设v已知（实际需快速幂计算）
        ll numerator = (D - v) % (p_i * p);
        ll denominator = (v * p_i % (p_i * p) * (p - 1) % (p_i * p)) % (p_i * p);
        ll I = numerator * inv(denominator, p) % p;
        x += I * p_i * (p - 1);
        x %= (p_i * p);
    }
    return x;
}

int main() {
    int T; cin >> T;
    while (T--) {
        ll n, D; cin >> n >> D;
        // 质因数分解n（假设已实现）
        vector<pair<ll, int>> factors; // (p, alpha)
        // 构造每个p^k的解
        vector<ll> a, m;
        for (auto [p, alpha] : factors) {
            ll mod_pk = 1;
            for (int i = 0; i < alpha; ++i) mod_pk *= p;
            ll x_pk = solve_pk(p, alpha, D);
            a.push_back(x_pk);
            m.push_back(mod_pk);
        }
        // 合并解
        ll ans = crt(a, m);
        cout << ans << endl;
    }
    return 0;
}
```

* **代码解读概要**：  
  1. **工具函数**：`phi`计算欧拉函数，`exgcd`和`inv`求逆元，`crt`合并解；  
  2. **核心构造**：`solve_pk`用增量法构造模p^k的解；  
  3. **主流程**：分解质因数→构造子解→合并解→输出。

---

### 题解一（Alex_Wei）核心片段赏析
* **亮点**：用归纳法+增量法构造解，严格保证互质条件。  
* **核心代码片段**：
  ```cpp
  ll extend(ll x_prev, ll p, ll k, ll D) {
      ll mod = 1;
      for (int i = 0; i < k; ++i) mod *= p;
      ll current = x_prev % p; // 模p的初始解
      for (int i = 1; i < k; ++i) {
          ll p_i = 1; for (int j = 0; j < i; ++j) p_i *= p;
          ll phi_p = p_i * (p - 1);
          // 计算v = current^current mod p^{i+1}
          ll v = 1;
          ll base = current % (p_i * p);
          ll exp = current % phi_p;
          for (ll j = 0; j < exp; ++j) v = v * base % (p_i * p);
          // 求解I
          ll numerator = (D - v + p_i * p) % (p_i * p);
          ll denominator = (v * p_i % (p_i * p) * (p - 1) % (p_i * p)) % (p_i * p);
          ll I = numerator * inv(denominator, p) % p;
          current += I * p_i * (p - 1);
          current %= (p_i * p);
      }
      return current;
  }
  ```
* **代码解读**：  
  这段代码是增量法的具体实现。`current`是当前模p^i的解，每次循环扩展到模p^{i+1}：  
  1. 计算`v = current^current mod p^{i+1}`（用快速幂简化）；  
  2. 计算分子（D - v）和分母（v×p^i×(p-1)）；  
  3. 求I的逆元，更新`current`为`current + I×p^i×(p-1)`。  
* **学习笔记**：快速幂是计算大指数模的“必备工具”，一定要掌握！


## 5. 算法可视化：像素动画演示

### 动画主题：「数论探险家」之幂塔方程解谜
### 设计思路
用8位像素风模拟“探险家拆解谜题”：  
- **复古氛围**：FC风格的背景（像素化实验室）、8位循环BGM（轻快的电子音）；  
- **互动性**：支持单步执行、自动播放（AI演示）、速度调节；  
- **游戏化元素**：每完成一个质因数的构造，播放“叮”的音效，合并解时播放“胜利”音效；每通过一个“小关卡”（如模p→模p²），获得10分，累计得分可解锁“数论工具卡”（如欧拉定理说明）。

### 动画帧步骤
1. **初始化**：  
   - 屏幕左侧显示n的像素化数值（如“10”），右侧是“质因数分解区”（空）；  
   - 控制面板有“开始”“单步”“重置”按钮，速度滑块（1×~5×）。

2. **质因数分解**：  
   - n的像素块分裂成p^k块（如10→2×5），每分裂一块播放“咔嗒”声；  
   - 分裂后的p^k块进入右侧的“构造区”。

3. **增量构造解**（以p=2，k=2为例）：  
   - 初始解x=1（模2），像素块显示“x=1”，伴随“叮”声；  
   - 扩展到模4：x=1 + I×2×1（p-1=1），计算I= (D - 1^1)/(1×2×1) mod 2，I=1，x更新为3，像素块“1”长出“+2”的小方块，变为“3”，播放“叮”声。

4. **合并解**：  
   - 所有p^k的解块（如3和...）拼合成最终解（如25），播放“胜利”音效，屏幕显示“解谜成功！”。

### 技术实现
- **前端**：纯HTML/CSS/JavaScript（Canvas绘制像素块，Web Audio API播放音效）；  
- **轻量化**：单文件实现，支持本地运行（双击.html文件即可）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的**分解+构造+合并**思路可用于：  
- 求解高次同余方程（如x^m ≡ D mod n）；  
- 构造满足多个条件的数（如与多个数互质）；  
- 处理大模数问题（如n>1e18）。

### 洛谷练习推荐
1. **P3846 【TJOI2007】可爱的质数**：练习BSGS算法（求解离散对数）；  
2. **P4195 【模板】扩展卢卡斯定理**：练习高次模的组合数计算（增量法的应用）；  
3. **P5091 【模板】扩展欧拉定理**：练习欧拉定理的应用（简化大指数）；  
4. **P3306 【模板】原根**：练习原根的查找（n次剩余的基础）。


## 7. 学习心得与经验分享

**参考经验（来自Alex_Wei）**：  
“整个算法优美而简洁，思维难度极高。没有冗余步骤，只是纯粹的数论。归纳法用得恰到好处，保证了构造过程的正确性。”

**点评**：Alex的心得点出了数论题的核心——**用数学推导简化问题**。归纳法和增量法的结合，让“从无到有”构造解成为可能。遇到数论题时，不妨先想：“能不能分解问题？能不能用归纳法构造解？”


## 结语
本次关于「SWTR-8」幂塔方程的分析就到这里。数论题看似抽象，实则充满规律——分解问题、利用工具、构造解，每一步都有章可循。记住：**数学是编程的灵魂**，掌握数论基础，才能解决更复杂的问题！下次我们再一起探索新的挑战！💪

---
处理用时：101.34秒
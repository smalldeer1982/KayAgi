# 题目信息

# [BJOI2018] 治疗之雨

## 题目背景

（没玩过《炉石传说》的人可以跳过这一段）今天我们来探讨下《炉石传说》中“治疗之雨”（恢复 $12$ 点生命值，随机分配到所有友方角色上）和“暗影打击装甲”（每当一个角色获得治疗，便对随机敌人造成 $1$点伤害）这两张卡牌之间的互动效果。假设你场上有 $m$个剩余生命值无限大且生命值上限减去剩余生命值也无限大的随从，而对方的场上有 $k$个暗影打击装甲，你的英雄剩余生命值为 $p$、生命值上限为 $n$，现在你使用了一张可以恢复无限多（而不是 $12$ 点）生命值的治疗之雨，问治疗之雨期望总共恢复了几点生命值以后你的英雄会死亡（生命值降为 $0$；治疗之雨的判定机制使得在此后再也不会为英雄恢复生命值）。

注：题目背景与题目描述有冲突的地方请以题目描述为准

下面让我们再形式化地描述一遍问题。

## 题目描述

**题目更新：鉴于很多人反映看不懂题，但是出于尊重原题面的原则不进行大幅度更改。您可以将最小值和最大值理解为下限和上限，类似于题目背景中的血量。**


你现在有 $m+1$ 个数：第一个为 $p$，最小值为 $0$，最大值为 $n$；剩下 $m$个都是无穷，没有最小值或最大值。你可以进行任意多轮操作，每轮操作如下：

在不为最大值的数中等概率随机选择一个（如果没有则不操作），把它加一；

进行 $k$次这个步骤：在不为最小值的数中等概率随机选择一个（如果没有则不操作），把它减一。 

现在问期望进行多少轮操作以后第一个数会变为最小值 $0$。

## 说明/提示

###数据范围

对于 $10\%$ 的数据， $n \leq 3$ ，$m, k \leq 2$ 。

对于 $20\%$ 的数据， $n, m, k \leq 5$ 。

对于 $30\%$ 的数据， $n, m, k \leq 30$ 。

对于 $40\%$ 的数据， $n, m, k \leq 50$ 。

对于 $50\%$ 的数据， $n, m, k \leq 200$ 。

对于 $70\%$ 的数据， $n \leq 200$ 。

对于 $80\%$ 的数据， $n \leq 500$ 。

对于 $100\%$ 的数据， $1 \leq T \leq 100$，$1 \leq p \leq n \leq 1500$ ，$0 \leq m, k \leq 1000000000$。

保证不存在$n=p=k=1$,$m=0$的情况（因为出题人判错了）

保证不存在答案的分母是$1000000007$的倍数的情况（因为出题人没想到）

## 样例 #1

### 输入

```
2
2 1 1 1
2 2 1 1```

### 输出

```
6
8```

# AI分析结果


# 💡 Kay的C++算法解析：[BJOI2018]治疗之雨 深入学习指南 💡

<introduction>
  今天我们来分析「治疗之雨」这道期望概率与动态规划结合的C++编程题。本指南将帮助大家梳理题目核心思路，掌握高斯消元优化技巧，并通过生动的像素动画直观理解算法执行过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`期望动态规划` + `高斯消元优化`

🗣️ **初步分析**：
> 解决本题可比喻为在随机迷宫中寻找出口：每一步操作（加血/减血）如同随机岔路，而我们需要计算从起点（初始血量p）走到出口（血量0）的**平均步数期望**。核心在于：
> - **概率建模**：计算受到i点伤害的概率（二项分布）
> - **状态转移**：建立期望步数的递推方程
> - **方程求解**：用高斯消元解线性方程组
> 
> **核心难点**：直接高斯消元O(n³)超时，需利用矩阵的带状结构优化至O(n²)
>
> **可视化设计思路**：
> - 用8位像素风格展示血量变化（英雄血条+随从像素块）
> - 高亮当前消元行和关键变量（如概率P_i, 期望dp_i）
> - 动画演示矩阵消元过程：左下三角逐步清零，伴随"叮"的音效
> - 自动播放模式下，AI角色"像素勇士"将逐步闯关（每消元一行=过一小关）

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰性、代码规范性、算法优化性等维度精选3份优质题解（均≥4★）：

**题解一：(来源：shadowice1984)**
* **点评**：此解思路最完整严谨。亮点在于：
  - 概率推导清晰（二项分布→递推式）
  - 矩阵优化到位（从O(n³)→O(n²)）
  - 边界处理周全（m=0/k=0特判）
  - 代码变量名规范（`f[i]`表概率，`dp[i]`表期望）
  - 作者强调"传统高斯消元不可行"，启发我们观察矩阵特性

**题解二：(来源：bztMinamoto)**
* **点评**：以代码简洁高效见长：
  - 消元核心仅20行，逻辑紧凑
  - 概率计算用逆元优化（`inv=pow(m+1,mod-2)`）
  - 带状矩阵处理巧妙（逐行消元+反向回代）
  - 实践价值高：代码可直接用于竞赛，含详细注释

**题解三：(来源：ListenSnow)**
* **点评**：教学价值突出：
  - 分步骤推导转移方程（血量为i时的两种情况）
  - 特判情况单独封装函数（`work()`处理m=0）
  - 矩阵构建过程注释详尽
  - 作者心得："注意每次测试后清空数组，避免超时"

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大核心难点，结合优质题解策略如下：

1.  **难点1：概率转移方程建立**
    * **分析**：需准确计算英雄受i点伤害的概率P_i。优质解用二项分布公式：
      $$P_i = C_k^i \cdot (\frac{1}{m+1})^i \cdot (\frac{m}{m+1})^{k-i}$$
      并推导递推式：$P_i = P_{i-1} \cdot \frac{k-i+1}{i} \cdot \frac{1}{m}$ 避免阶乘溢出
    * 💡 **学习笔记**：概率递推是期望DP的常见优化手段

2.  **难点2：大规模方程组求解**
    * **分析**：直接高斯消元O(n³)超时。观察矩阵结构：
      - 第i行仅有i, i+1列非零（带状矩阵）
      - 消元时只需处理相邻两行，复杂度降为O(n²)
    * 💡 **学习笔记**：算法优化常源于对数据特性的洞察

3.  **难点3：边界条件处理**
    * **分析**：m=0或k=0时需特殊处理：
      - k=0：无法减血，输出-1
      - m=0且k=1：无限循环，输出-1
      - m=0且k>1：直接模拟回合
    * 💡 **学习笔记**：特判是概率题的必备步骤

### ✨ 解题技巧总结
<summary_best_practices>
期望DP问题通用技巧：
- **技巧1：状态定义与无后效性**  
  定义`dp[i]`时确保状态转移无环（如本题血量只减不增）
- **技巧2：概率计算的优化**  
  避免重复计算，用递推代替组合数公式
- **技巧3：矩阵结构观察**  
  发现带状矩阵、三角矩阵等特性可大幅优化消元
- **技巧4：模块化处理边界**  
  将特判逻辑封装独立函数，保持主逻辑清晰
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下通用实现融合了优质题解精华，完整解决本题：

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll long long
const int N = 1505, mod = 1e9+7;
ll dp[N], P[N], a[N][N]; // P:概率数组 a:增广矩阵

ll qpow(ll x, ll k) { // 快速幂
    ll res = 1;
    while (k) {
        if (k & 1) res = res * x % mod;
        x = x * x % mod; k >>= 1;
    }
    return res;
}

void solve(int n, int p, ll m, ll k) {
    // 特判 m=0 / k=0
    if (k == 0) { printf("-1\n"); return; }
    if (m == 0) {
        if (k == 1) { printf("-1\n"); return; }
        int cnt = 0;
        while (p > 0) {
            if (p < n) p++;
            p -= k; cnt++;
        }
        printf("%d\n", cnt); return;
    }

    // 计算概率 P_i
    ll invm = qpow(m, mod-2), invm1 = qpow(m+1, mod-2);
    P[0] = qpow(m * invm1 % mod, k);
    for (int i = 1; i <= std::min(n, (int)k); i++)
        P[i] = P[i-1] * invm % mod * qpow(i, mod-2) % mod * (k - i + 1) % mod;

    // 构建增广矩阵
    memset(a, 0, sizeof(a));
    for (int i = 1; i < n; i++) {
        for (int j = 1; j <= i; j++) // 不受治疗部分
            a[i][j] = (P[i-j]*m + P[i-j+1]) % mod * invm1 % mod;
        a[i][i+1] = P[0] * invm1 % mod; // 受治疗部分
        a[i][i] = (a[i][i] - 1 + mod) % mod; // 移项常数
        a[i][n+1] = mod - 1; // 常数项
    }
    for (int i = 1; i <= n; i++) { // 满血状态
        a[n][i] = P[n-i];
        a[n][n+1] = mod - 1;
    }
    a[n][n] = (a[n][n] - 1 + mod) % mod;

    // 优化高斯消元 O(n²)
    for (int i = 1; i < n; i++) {
        ll inv = qpow(a[i][i], mod-2);
        a[i][i+1] = a[i][i+1] * inv % mod;
        a[i][n+1] = a[i][n+1] * inv % mod;
        // 仅消去下一行
        ll t = a[i+1][i];
        a[i+1][i+1] = (a[i+1][i+1] - t * a[i][i+1] % mod + mod) % mod;
        a[i+1][n+1] = (a[i+1][n+1] - t * a[i][n+1] % mod + mod) % mod;
    }
    // 反向回代
    dp[n] = a[n][n+1] * qpow(a[n][n], mod-2) % mod;
    for (int i = n-1; i >= p; i--)
        dp[i] = (a[i][n+1] - a[i][i+1] * dp[i+1] % mod + mod) % mod;
    printf("%lld\n", dp[p]);
}
```
* **代码解读概要**：
  1. **概率计算**：`P[0..n]`存储伤害概率，递推避免大数阶乘
  2. **矩阵构建**：`a[][]`存储方程组，分血量未满(`i<n`)和满(`i=n`)两种状态
  3. **消元优化**：仅处理相邻行（第i行消去i+1行的第i列）
  4. **反向回代**：从`dp[n]`倒推`dp[p]`，复杂度O(n)

---
<code_intro_selected>
精选题解核心片段赏析：

**题解一（shadowice1984）：带状矩阵处理**
```cpp
// 带状矩阵消元（节选）
for(int i=1;i<=n-1;i++) {
    ll inv=qpow(a[i][i],mod-2);
    a[i][i+1]=a[i][i+1]*inv%mod;
    a[i][n+1]=a[i][n+1]*inv%mod;
    for(int j=i+1;j<=n;j++) { // 仅影响下一行
        ll t=a[j][i];
        a[j][i+1]=(a[j][i+1]-t*a[i][i+1]%mod+mod)%mod;
        a[j][n+1]=(a[j][n+1]-t*a[i][n+1]%mod+mod)%mod;
    }
}
```
* **亮点**：利用矩阵带状特性，每行仅消去下一行
* **学习笔记**：当矩阵非零元素集中在对角线附近时，可针对性优化消元

**题解二（bztMinamoto）：概率递推计算**
```cpp
// 概率递推（节选）
P[0]=qpow(m*inv(m+1)%mod,k);
for(int i=1;i<=min(n,k);i++)
    P[i]=P[i-1]*inv(i)%mod*(k-i+1)%mod*inv(m)%mod;
```
* **亮点**：用乘法逆元代替除法，避免浮点误差
* **学习笔记**：模运算下用`qpow(i,mod-2)`代替`1/i`是标准做法

**题解三（ListenSnow）：特判处理**
```cpp
// 特判逻辑（节选）
if(m == 0) {
    if(k == 1) return -1;
    int cnt = 0;
    while(p > 0) { 
        if(p < n) p++; // 未满血则加血
        p -= k; // 固定扣血
        cnt++;
    }
    return cnt;
}
```
* **亮点**：将边界逻辑独立处理，保持主逻辑清晰
* **学习笔记**：特殊情形直接模拟往往比通用算法更高效

-----

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为直观展示算法，设计「像素勇士闯关」动画：勇士血条为红色像素条，随操作增减；矩阵消元化为迷宫关卡，每消一行即过一关。

* **主题**：8-bit复古风，英雄血量用心形像素表示，矩阵化为可破墙壁
* **核心演示**：从血量p开始，逐步展示加血/减血操作对状态的影响，同步显示矩阵消元过程
* **设计思路**：用游戏化降低理解门槛——血量变化如RPG战斗，消元如解谜闯关

**动画帧步骤**：
1. **初始化场景**（像素风格）：
   - 左侧：英雄血条（n颗心形像素），随从组（m个像素方块）
   - 右侧：矩阵网格（n×n像素块），初始为稠密矩阵
   - 控制面板：开始/暂停/步进按钮，速度滑块

2. **操作演示**（音效+高亮）：
   - **加血**：心形闪烁绿色，播放上升音效
   - **减血**：心形闪烁红色，播放受伤音效
   - **判定**：随从方块随机变暗（未命中）或亮红（命中）

3. **矩阵消元动态演示**：
   - 当前消元行高亮黄色
   - 被消元行变化时像素块爆炸特效
   - 消元完成行变绿色，播放"叮"音效
   - 同步显示方程：`dp[i] = ...` 随步骤更新

4. **AI自动演示模式**：
   - 像素勇士自动移动，每步对应一次操作
   - 每消元一行，勇士前进一格并积累积分
   - 通关（解出dp[p]）时播放胜利音乐，像素烟花庆祝

**关键交互**：
- 点击血条可查看当前概率P_i
- 鼠标悬停矩阵元素显示行列号及数值
- 支持调速：慢速学习/快速演示

**伪代码逻辑**：
```python
while not solved:
    if 自动模式: 自动执行下一步()
    else: 等待用户点击()
    
    更新血条动画()
    高亮当前矩阵行()
    if 消元操作: 
        播放音效('click')
        更新矩阵像素()
    if 关卡完成:  # 一行消元结束
        播放音效('level_up')
        像素勇士前进()
```

<visualization_conclusion>
通过像素动画，抽象的概率转移与矩阵消元化为直观冒险，帮助理解算法核心。
</visualization_conclusion>

-----

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握期望DP+高斯消元后，可挑战以下相似问题：

* **通用技巧迁移**：
  1. **带概率的状态转移**：如随机游走问题
  2. **稀疏矩阵求解**：如电路网络计算
  3. **游戏回合期望**：如卡牌游戏策略

* **练习推荐 (洛谷)**：
1. **P1654 OSU!**  
   🗣️ **推荐理由**：基础期望DP，巩固概率与期望的线性性质
2. **P3211 [HNOI2011]XOR和路径**  
   🗣️ **推荐理由**：图上的期望DP+高斯消元，提升建模能力
3. **P3232 [HNOI2013]游走**  
   🗣️ **推荐理由**：结合图论与期望，需排序优化消元

-----

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中蕴含宝贵调试经验：

> **参考经验 (来自 ListenSnow)**："特判m=0时忘记k=1的死循环情况，WA后补上才AC"
> 
> **点评**：调试时优先检查边界是黄金法则，尤其概率题中：
> - 除数为0（如m=0）
> - 无穷循环（k=1时无法结束）
> - 特殊输入（n=p=1）都需单独验证

<conclusion>
本次解析到此结束。记住：概率期望问题重在建模，优化算法需洞察结构特性。多动手模拟状态转移，善用可视化工具理解抽象过程！💪
</conclusion>

-----

---
处理用时：206.97秒
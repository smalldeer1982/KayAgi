# 题目信息

# [集训队互测 2018] 完美的集合

## 题目描述

小 A 有一棵 $N$ 个点的带边权的树，树的每个节点有重量 $w_i$ 和价值 $v_i$。

现在小 A 要从中选出若干个节点形成一个集合 $S$，满足这些节点重量之和 $\leq M$ 并且构成一个连通块。小 A 是一个完美主义者，因此他只会选择节点价值之和最大的那些 $S$。我们称这样的集合 $S$ 为完美的集合。

现在小 $A$ 要从所有完美的集合中选出 $K$ 个，并对这 $K$ 个完美的集合分别进行测试。在这 $K$ 次测试开始前，小 A 首先需要一个点 $x$ 来放置他的测试装置，这个测试装置的最大功率为 $Max$。

接下来的每次测试，小 A 会对测试对象 $S$ 中的所有点进行一次能量传输，对一个点 $y$ 进行能量传输需要的功率为 $dist(x,y)\times v_y$，其中 $dist(x,y)$ 表示点 $x,y$ 在树上的最短路长度。因此，如果 $S$ 中存在一个点 $y$，满足 $dist(x,y)\times v_y>Max$，测试就会失败。同时，为了保证能量传输的稳定性，测试装置所在的点 $x$ 需要在集合 $S$ 中，否则测试也会失败。

现在小 A 想知道，有多少种从所有完美的集合选出 $K$ 个的方法，使得他能找到一个放置测试装置的点，来完成他的测试呢？

你只需要输出方案数对 $11920928955078125$ 取模的结果。

## 说明/提示

### 样例解释

完美的集合有 $\{1,2,5\},\{1,4\},\{2,6\}$。

从中选出 $K$ 个且能完成测试的方案为选择 $\{1,2,5\},\{1,4\}$ 或选择 $\{1,2,5\},\{2,6\}$。

### 数据范围

|子任务编号	|	$N\leq$	|	$M\leq$	|	$K\leq$	|		特殊性质			|	分值		|
|:----------------:|:----------------:|:----------------:|:----------------:|:-----------------------------------:|:----------------:|
|	$1$		|	$17$	|	$150$	|	$10^9$	|						|	$13$	|
|	$2$		|	$60$	|	$10000$	|	$1$		|						|	$11$	|
|	$3$		|	$60$	|	$2$		|	$10^4$	|	$w_1=\dots=w_N=1$	|	$19$	|
|	$4$		|	$40$	|	$1200$	|	$10^9$	|						|	$20$	|
|	$5$		|	$60$	|	$10000$	|	$10^4$	|						|	$15$	|
|	$6$		|	$60$	|	$10000$	|	$10^9$	|						|	$22$	|

对于 $100\%$ 的数据，$N\leq 60$，$M\leq 10000$，$C_i\leq 10000$，$K,w_i,v_i\leq 10^9$，$Max\leq 10^{18}$。

## 样例 #1

### 输入

```
7 3 2 4
1 1 2 2 1 2 2
1 1 1 2 1 2 2
1 2 1
1 3 2
1 4 2
2 5 1
2 6 2
4 7 3```

### 输出

```
2```

# AI分析结果


### 💡 Kay的C++算法解析：完美的集合 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：树形DP + 组合数学 + 容斥原理  
🗣️ **初步分析**：  
> 解决本题的关键在于构建**树形DP模型**计算完美集合，并通过**点-边容斥**处理测试装置约束。想象一棵树是探险地图，每个节点是宝藏（重量/价值），我们要找出所有重量和≤M的连通宝藏集合（完美集合），再选出K个能用同一装置点测试的集合。  
- **核心难点**：处理装置约束需检查每个点是否满足`dist(x,y)*v_y ≤ Max`，这会导致可行点集形成连通块，因此采用点-边容斥（对点贡献加，对边贡献减）
- **算法流程**：  
  1️⃣ 计算全局最大价值`glb.val`（完美集合价值）  
  2️⃣ 对每个点x：树形DP计算以x为根的完美集合数`cnt_x`  
  3️⃣ 对每条边：DP计算同时满足两端点约束的集合数`cnt_e`  
  4️⃣ 答案 = ΣC(`cnt_x`,K) - ΣC(`cnt_e`,K)  
- **可视化设计**：采用**8位像素风树形地图**，节点显示重量/价值，DP过程用像素方块堆叠表示背包状态，容斥时点变绿（+）、边变红（-），配合"叮"音效标记关键操作。

---

#### 2. 精选优质题解参考
**题解一（crashed）**  
* **亮点**：  
  - 树形DP采用欧拉序背包实现，避免重复计算  
  - 扩展Lucas算法用分治+多项式压缩（保留23项）高效计算大组合数  
  - 代码模块化清晰（PureCalculation/OnTree命名空间分离）  
* **学习价值**：学习连通块树形DP的标准写法与超大组合数处理技巧  

**题解二（tzc_wk）**  
* **亮点**：  
  - 组合数计算采用倍增多项式乘法（F_{2n}=F_n(x)*F_n(x+5n)）  
  - 树形DP用DFS回溯合并子树状态，节省空间  
  - 函数式编程风格（calc_pw5/calc_prd分离）  
* **学习价值**：掌握多项式移位技巧与树形DP的父子状态合并  

---

#### 3. 核心难点辨析与解题策略
1. **难点一：装置约束导致可行点集不连通**  
   * **分析**：点-边容斥将连通块检测转化为单点/双点统计，需保证DP时集合连通（树形DP天然满足）  
   * 💡 **学习笔记**：树形问题中，点-边容斥是处理连通块约束的利器  

2. **难点二：超大组合数取模（K≤10^9, mod=5^23）**  
   * **分析**：扩展Lucas算法需计算阶乘中与5互质的部分。利用`F_n(x)=∏(x+k)`的多项式性质，分治时仅保留前23项系数（因5^23≡0）  
   * 💡 **学习笔记**：对平滑数模数（p^k），多项式截断是优化关键  

3. **难点三：树形DP状态转移优化**  
   * **分析**：背包转移时用滚动数组优化空间，合并子树用`dp[u][j]+=dp[v][j]`实现连通块累积  
   * 💡 **学习笔记**：树形DP背包转移注意倒序更新避免后效性  

**✨ 解题技巧总结**  
- **拆解约束**：将装置约束转化为点独立条件（dist(x,y)*v_y≤Max）  
- **容斥转换**：连通块统计 → 单点贡献 - 边贡献  
- **多项式压缩**：对高阶项必然归零的模数，截断多项式加速计算  
- **树形DP模板**：DFS序上背包，`dp[u][j+w_v] += dp[u][j] * v_v`  

---

#### 4. C++核心代码实现赏析
**通用核心实现（综合题解思路）**
```cpp
// 树形DP计算完美集合（简化版）
void DFS(int u, int fa) {
    dp[u][w[u]] = {v[u], 1}; // 初始化
    for (int e = head[u]; e; e = nxt[e]) {
        int v = to[e]; if (v == fa) continue;
        DFS(v, u);
        for (int j = M - w[u]; j >= 0; j--) // 背包倒序更新
            if (dp[u][j].val) 
                for (int k = 0; k <= M - j; k++) 
                    if (dp[v][k].val)
                        merge(u, j + k, dp[u][j], dp[v][k]); // 合并子树
    }
}
```
**题解一代码亮点**  
```cpp
// 扩展Lucas的分治核心
Poly PartialFactorial(int lvl, LL n) {
    if (lvl == 0) return base; 
    Poly res = PartialFactorial(lvl-1, n % pow5[lvl]);
    return Shift(res, n / pow5[lvl]) * precomputed[lvl][n/pow5[lvl]];
}
```
> **解读**：将n!分解为∏(k+5^m*t)形式，Shift函数实现多项式位移（利用二项式定理），*运算符实现多项式乘法（仅保留23项）  

**题解二代码亮点**  
```cpp
// 多项式位移（倍增法）
poly shift(poly x, LL v) {
    poly res;
    for (int i = 0; i < 23; i++) 
        for (int j = 0; j <= i; j++)
            res[j] += x[i] * C(i,j) * pow(v, i-j); // 二项展开
    return res;
}
```
> **解读**：通过`(x+v)^i = ΣC(i,j)x^j v^{i-j}`公式实现多项式快速位移，复杂度O(23²)  

---

#### 5. 算法可视化：像素动画演示
**🎮 设计主题**："宝藏猎人"在像素森林中寻找连通宝藏集  
**🎯 核心演示**：  
1. **场景初始化**：8位风网格树（棕色树干/绿色叶），节点显示重量/价值，控制面板含步进/调速滑块  
2. **DP过程**：  
   - 当前节点高亮闪烁，背包状态用下方像素方块堆叠表示（高度=价值，颜色=重量）  
   - 选中节点时播放"收集"音效，更新背包时方块滑入动画  
3. **容斥演示**：  
   - 点统计：节点变绿，弹出"+C(cnt,K)"  
   - 边统计：边变红，弹出"-C(cnt_e,K)"  
4. **组合数计算**：左侧显示多项式系数矩阵，分治时播放"拆分"音效  

**🕹️ 交互设计**：  
- **AI演示模式**：自动播放DP过程（速度可调），结束时播放胜利音乐  
- **关卡设计**：每完成一个点统计视为小关，奖励像素星星  
- **音效体系**：  
  - 关键操作："叮"（节点选择）、"咔嚓"（背包更新）  
  - 结果提示：上扬音阶（成功）、低沉音效（失败）  

---

#### 6. 拓展练习与相似问题
**相似技巧迁移**：  
1. 树形背包+容斥：[十二省联考2019]希望（P5291）  
2. 大组合数取模：CF1264D2（括号序列计数）  
3. 连通块约束：NOI2020超现实树  

**洛谷推荐**：  
1. **P2014 选课** - 树形背包基础  
   🗣️ *巩固树形DP状态设计*  
2. **P2607 骑士** - 基环树+容斥  
   🗣️ *学习环上容斥技巧*  
3. **P3783 随机数生成器** - 超大组合数应用  
   🗣️ *扩展Lucas的变式训练*  

---

#### 7. 学习心得与经验分享
> **题解一作者经验**："处理树形背包时，倒序更新避免后效性这点让我调试了3小时——看似简单却极易出错。"  
> **Kay点评**：树形DP背包的倒序更新是经典陷阱，建议：  
> 1. 画状态转移图理解更新顺序  
> 2. 用`j from M down to 0`确保用旧状态更新  

---

### 总结  
通过树形DP建模、点-边容斥转换、多项式优化组合数三大核心技巧，我们成功攻克了本题。记住：  
**复杂约束 → 容斥分解**  
**超大计算 → 数学优化**  
**树形问题 → DFS序+背包**  
继续加油，少年！下次挑战见！🚀

---
处理用时：109.64秒
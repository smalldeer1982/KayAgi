# 题目信息

# [集训队互测 2015] 胡策的小树

## 题目描述

在 OI 界，有一位无人不知无人不晓，OI 水平前无古人后无来者的胡策，江湖人称一眼秒题胡大爷。

胡策最近从一名自称是小 O 的神秘男子那里收到了一棵神奇的小树苗。

这是一棵 $n$ 个节点的有根树，节点标号为 $1, \dots, n$，其中 $1$ 号点为根。

这棵有根树上每个点都有一个权值，点 $i$ 的权值为 $a_i$。$a_1, \dots, a_n$ 构成了一个 $0\sim n-1$ 的排列，且 $a_1=0$。

胡策大爷十分喜欢猴子，他打算在这棵树上养 $n$ 只猴子。初始时，每个节点上将放着恰好一只猴子。猴子们十分好动，每过一秒，每只在 $i$ 节点的猴子会设法往 $i$ 的父亲节点上跳，有 $p(i)$ 的概率成功跳到父亲节点；否则跳跃失败，将等概率地随机落到子树 $i$ 里某个节点上（包括点 $i$）。

因为根节点没有父亲，所以 $p(1)=0$。对于 $2\leq i\leq n$，有 $p(i)=\frac{a_i}{n}$；

在第 $i$ 秒，胡策会观察并记录这 $n$ 只猴子中成功跳上父亲结点的猴子所占的比例 $g_i$。胡策认为 $g_0, \dots, g_T$ 的平均值就是这群猴子们生活的幸福指数，为保证准确，其中 $T$ 为很大很大的值，为 $(n+1)^{99999^{99999^{99999}}}$

为了让猴子们的幸福指数的期望更大，胡策又从那名自称是小 O 的神秘男子那里买来了一袋叫“金坷垃”的肥料。如果给这棵有根树掺 $x$ 克的金坷垃，那么这棵树每个点 $i$ 的权值将变化成 $(a_i+x)\bmod n$。因为胡策是土豪有钱任性，$x$ 可以取任意非负整数。

请你告诉胡策，他该掺多少克的金坷垃，才能使猴子们幸福指数的期望最大呢？

## 说明/提示

- 对于 $10\%$ 的数据：$n = 2$。
- 对于 $20\%$ 的数据：$n\leq 5$。
- 对于 $30\%$ 的数据：$n\leq 100$。
- 对于 $50\%$ 的数据：$n\leq 2000$。
- 对于 $70\%$ 的数据：$n\leq 100000$。
- 对于 $100\%$ 的数据：$2\leq n\leq 500000$。

数据保证有一定梯度。

数据都是随机生成的。即：节点 $i$ 的父亲是从 $1\sim i-1$ 中随机选取的，$a_1 \dots a_n$ 是一个 $0 \sim n-1$ 的随机排列。

## 样例 #1

### 输入

```
3
0 1 1
0 1 2```

### 输出

```
0.266666667```

# AI分析结果

# 💡 Kay的C++算法解析：[集训队互测2015]胡策的小树 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（概率期望与稳态分布） + 图论（树结构递推）`

🗣️ **初步分析**：  
解决这道题的关键，就像**“给猴子的活动找一个‘稳定的家’”**——当时间足够长时，猴子在树上的分布会趋于“稳态”（每一步的分布都不变）。数学在这里帮我们建立“稳态下的等式”（比如“现在的分布”等于“下一步的分布”），而树的结构则让我们能把复杂的方程组简化成**父子节点间的递推关系**（就像孩子的“居住概率”依赖于父母的）。  

### 核心思路与难点
- **题解思路**：先通过稳态条件建立方程，化简得到父子节点的递推式（如`p_u f_u / sz_u = f_{fa_u} / sz_{fa_u}`），再枚举所有可能的`x`（金坷垃用量），计算每个`x`对应的子树答案（因为`x`会让某个节点的`p_u=0`，猴子被困在该子树）。  
- **核心难点**：① 理解“稳态分布”的条件，建立正确的方程；② 化简方程得到简洁的递推关系；③ 高效处理所有`x`的情况（避免重复计算）。  
- **解决方案**：① 分析“长时间后分布不变”，写出“转移前后分布相等”的等式；② 通过代数化简（比如移项、提取公因子）将方程转化为仅涉及父子节点的关系；③ 利用`a`数组是排列的性质，每个`x`对应唯一的“被困子树”，只需计算该子树的答案。  

### 可视化设计思路
我们会用**8位像素风**模拟树的结构（比如用不同颜色的像素块表示节点，子树用“缩进的像素列”展示）。动画核心是：  
1. **稳态方程化简**：用“箭头连线”展示父子节点的递推关系（比如`f_u`的计算依赖`f_{fa_u}`，箭头从父节点指向子节点），伴随“叮”的音效强化记忆。  
2. **子树处理**：当枚举`x`时，对应的“被困子树”会被**高亮闪烁**，其他节点变暗，模拟“猴子只在子树内活动”的场景。  
3. **结果对比**：每个`x`对应的答案会用“像素数字”显示在子树旁，最大值会被“金色边框”标记，伴随“胜利音效”。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解，帮大家快速抓住核心！
</eval_intro>

**题解一：(来源：Glacy)**  
* **点评**：这份题解的**推导过程堪称“教科书级”**——从稳态条件出发，一步步化简方程，最终得到`p_u f_u / sz_u = f_{fa_u} / sz_{fa_u}`的关键递推式。它不仅解释了“为什么可以建立稳态方程”，还点出了`x`的处理技巧（每个`x`对应唯一的被困子树）。思路清晰，逻辑严密，是理解本题的“核心钥匙”。  

**题解三：(来源：_lmh_，附完整代码)**  
* **点评**：这道题解的亮点是**把思路变成了可运行的代码**！它推导了`g_u`（祖先的贡献和）与`h_u`（稳态分布）的关系，并用`dfs`计算子树大小，枚举所有`x`计算每个子树的答案。代码风格规范（比如`sz[u]`表示子树大小，`q[v]`表示失败时的转移概率），边界处理严谨（比如`x=0`时的根节点处理），是“从理论到实践”的好例子。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有三个，我们一一拆解：
</difficulty_intro>

### 1. 难点1：如何建立“稳态分布”的方程？
* **分析**：稳态的核心是“现在的分布 = 下一步的分布”。比如，对于节点`u`，现在的`f_u`（猴子在`u`的概率）等于“所有能转移到`u`的路径的概率之和”（比如父节点成功跳到`u`？不，父节点是往上跳，所以`u`的猴子来自子节点失败时的随机掉落，或者父节点失败时掉落到`u`）。  
* **解决方案**：写出“转移前后的等式”——比如`f_u = 所有能转移到u的路径的概率 × 对应节点的f值之和`，再通过“子树求和”简化等式（因为子节点的失败转移只影响自己的子树）。  

### 2. 难点2：如何化简复杂的方程？
* **分析**：直接解方程组需要`O(n^3)`的高斯消元，根本无法处理`n=5e5`的数据。但树的结构让我们可以**“消去中间变量”**——比如把方程中的`f_v`（子节点）用`f_{fa_v}`（父节点）表示，最终得到仅涉及父子的递推式。  
* **解决方案**：通过移项、提取公因子（比如把`f_u`的项单独放一边），化简得到`p_u f_u / sz_u = f_{fa_u} / sz_{fa_u}`——这个式子把`f_u`和`f_{fa_u}`直接关联，能线性时间计算！  

### 3. 难点3：如何高效处理所有`x`的情况？
* **分析**：`x`可以取任意非负整数，但`a`数组是`0~n-1`的排列——这意味着**每个`x`对应唯一的`u`，使得`(a_u + x) mod n = 0`**（`p_u=0`）。此时猴子会被困在`u`的子树（无法跳到父节点），只需计算该子树的答案。  
* **解决方案**：枚举所有可能的`x`（等价于枚举所有`u`，因为`x = (-a_u) mod n`），对每个`u`的子树计算稳态分布的答案（复杂度是“所有子树大小之和”，随机树的情况下是`O(n log n)`）。  

### ✨ 解题技巧总结
- **技巧A：稳态分布的“不变性”**：当时间足够长时，分布不再变化，这是建立方程的关键。  
- **技巧B：树结构的“递推简化”**：把复杂的方程组转化为父子递推，避免高复杂度的高斯消元。  
- **技巧C：排列性质的利用**：`a`是排列意味着每个`x`对应唯一的“被困子树”，减少计算量。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合了优质题解思路的核心代码**，帮大家把握整体框架！
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了题解一的递推思路和题解三的代码结构，清晰展示“稳态计算 + 枚举x”的核心逻辑。  
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <iomanip>
using namespace std;

typedef long double ld;
const int N = 500007;

int n, a[N], fa[N], sz[N], id[N], tI[N], tO[N], timer, b[N];
vector<int> son[N];
ld p[N], q[N], f[N], ans;

// 计算子树大小和进入时间戳
void dfs(int u) {
    id[tI[u] = ++timer] = u;
    sz[u] = 1;
    for (int v : son[u]) {
        if (v != fa[u]) {
            dfs(v);
            sz[u] += sz[v];
        }
    }
    tO[u] = timer;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);

    cin >> n;
    for (int i = 2; i <= n; ++i) {
        cin >> fa[i];
        son[fa[i]].push_back(i);
    }
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        b[a[i]] = i; // b[v] = u 表示a[u] = v
    }
    dfs(1); // 初始化子树大小和时间戳

    // 枚举所有可能的x（等价于枚举所有u，因为x = (-a[u]) mod n）
    for (int i = 0; i < n; ++i) {
        int u = b[i]; // 当前x对应的“被困子树”根节点（p[u] = 0）
        ld sum = 0, current = 0;

        // 计算该子树内的p和q
        for (int j = tI[u]; j <= tO[u]; ++j) {
            int v = id[j];
            int o = (a[v] - a[u] + n) % n; // (a[v]+x) mod n = o
            p[v] = (ld)o / n;
            q[v] = (1 - p[v]) / sz[v]; // 失败时的转移概率
        }

        // 从下往上计算f（稳态分布）
        f[u] = 1; // 根节点的f初始化
        for (int j = tO[u]; j > tI[u]; --j) {
            int v = id[j];
            f[v] = f[fa[v]] * sz[v] * p[v] / sz[fa[v]]; // 递推式：p_v f_v / sz_v = f_fa / sz_fa
        }

        // 计算该子树的答案（sum(f_v) = 总概率，current = sum(f_v p_v) / sum(f_v)）
        for (int j = tI[u]; j <= tO[u]; ++j) sum += f[id[j]];
        for (int j = tI[u]; j <= tO[u]; ++j) current += f[id[j]] * p[id[j]];
        ans = max(ans, current / sum); // 求最大期望
    }

    cout << fixed << setprecision(10) << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
  代码分为三部分：① 用`dfs`计算子树大小和时间戳（方便快速访问子树节点）；② 枚举所有`x`（对应每个`u`），计算该子树内的`p`和`q`；③ 利用递推式`p_v f_v / sz_v = f_fa / sz_fa`计算稳态分布`f`，最后求该子树的平均成功概率，更新最大值。


<code_intro_selected>
接下来，我们剖析题解三中的核心代码片段，看看它是如何实现“子树递推”的！
</code_intro_selected>

**题解三：(来源：_lmh_)**  
* **亮点**：用“时间戳”快速访问子树节点，将复杂的子树计算转化为“数组区间操作”（比如`tI[u]`到`tO[u]`是`u`的子树节点），极大简化了代码。  
* **核心代码片段**：
```cpp
// 计算子树大小和时间戳
void dfs(int u){
    id[tI[u]=++timer]=u;
    for (auto v:son[u]) if (v!=fa[u]) dfs(v);
    tO[u]=timer;sz[u]=tO[u]-tI[u]+1;
}

// 枚举x时的子树计算
for (int i=0;i<n;++i){
    int u=b[i];
    for (int v,i=tI[u];i<=tO[u];++i){
        v=id[i];
        int o=a[v]-a[u];
        if (o<0) o+=n;
        p[v]=(ld)o/n;
        q[v]=(1-p[v])/sz[v];
    }
    // ... 递推计算f数组 ...
}
```
* **代码解读**：  
  1. `dfs`函数：给每个节点`u`分配一个“进入时间戳”`tI[u]`和“离开时间戳”`tO[u]`——`u`的子树节点恰好是`id[tI[u]]`到`id[tO[u]]`（就像“子树的节点都排在数组的一个连续区间里”）。  
  2. 枚举`x`时：通过`tI[u]`到`tO[u]`快速遍历`u`的子树节点，计算每个节点的`p`（成功概率）和`q`（失败时的转移概率）。这种“区间操作”比递归遍历子树更快，也更易读。  
* 💡 **学习笔记**：用“时间戳”处理子树问题，是树结构编程中的常用技巧——把“树的递归结构”转化为“数组的连续区间”，让代码更高效！  


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们用**“像素猴子的树屋冒险”**模拟算法过程，结合8位复古风，让抽象的递推变得直观！
</visualization_intro>

### 动画设计概览
- **主题**：像素猴子在树上寻找“稳定的家”，每找到一个稳态分布，就会点亮对应的节点。  
- **风格**：8位像素风（像FC游戏《超级马里奥》的画面），用不同颜色的像素块表示节点（比如绿色是根节点，蓝色是子节点，红色是当前处理的节点）。  
- **音效**：① 递推时（比如计算`f_u`）播放“叮”的音效；② 找到最大值时播放“胜利的小喇叭声”；③ 初始化子树时播放“沙沙”的树叶声。  


### 动画帧步骤
1. **场景初始化**：  
   屏幕左侧显示一棵像素树（根节点在顶部，子节点向下延伸），右侧是“控制面板”（有“开始/暂停”“单步”“重置”按钮，速度滑块）。背景播放8位风格的轻快BGM（比如《冒险岛》的背景音乐）。  

2. **子树时间戳演示**：  
   点击“开始”后，`dfs`函数开始运行——每个节点被访问时，会“闪烁两次”，并在下方显示其`tI`和`tO`值（比如节点`u`的`tI=3`，`tO=5`，意味着子树节点是`id[3]~id[5]`）。  

3. **稳态递推演示**：  
   - 枚举`x`时，对应的“被困子树”会被**黄色边框高亮**，其他节点变暗。  
   - 计算`f`数组时，用“红色箭头”从父节点指向子节点（比如`f_u`的计算依赖`f_{fa_u}`，箭头从`fa_u`指向`u`），同时播放“叮”的音效。  
   - 每个节点的`f`值会显示在像素块下方（比如`f_u=0.2`），随着递推进行，数值会动态更新。  

4. **结果对比**：  
   每个`x`对应的平均成功概率会显示在屏幕右上角，最大值会被“金色星星”标记，伴随“胜利音效”。点击“重置”可以重新开始动画。  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“稳态分布 + 树递推”的思路后，我们可以尝试以下相似问题，巩固技巧！
</similar_problems_intro>

### 通用思路迁移
本题的核心技巧（**稳态方程 + 树递推**）还能解决：  
1. **网络中的流量稳态**（比如水管中的水长期流动后的分布）；  
2. **树上的概率转移问题**（比如“蚂蚁在树上爬，求长期停留在某个节点的概率”）；  
3. **排列的枚举优化**（比如利用排列的唯一性，减少枚举次数）。  


### 洛谷练习推荐
1. **洛谷 P1352 没有上司的舞会**：  
   🗣️ **推荐理由**：这道题需要用树的递推计算“最大快乐值”，锻炼“父子节点的状态依赖”思维，和本题的“父子递推”异曲同工。  

2. **洛谷 P2051 [AHOI2009]中国象棋**：  
   🗣️ **推荐理由**：需要用动态规划处理“棋盘上的棋子分布”，类似本题的“稳态分布”，锻炼“状态转移方程的建立”能力。  

3. **洛谷 P3174 [HAOI2009]毛毛虫**：  
   🗣️ **推荐理由**：需要计算树的“最长路径”（毛毛虫长度），锻炼“子树大小的应用”，和本题的“sz[u]”用法一致。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解一中的作者提到“稳态方程的正确性并不显然”，这给了我们一个重要的提醒：
</insights_intro>

> **参考经验 (来自 Glacy)**：“这么做的正确性并不显然，读者可自行思考此部分。”  
> **点评**：这提醒我们——**不要“死记”方程，要理解背后的逻辑**！比如“稳态分布”的条件是“时间足够长”，此时每一步的转移都不会改变分布。如果不确定，可以手动模拟小例子（比如`n=2`的情况），验证方程是否成立。  


## 8. 总结

本次分析中，我们用“数学的稳态方程”解决了猴子的长期分布问题，用“树的递推结构”简化了复杂的计算，还用“像素动画”让抽象的过程变得直观。记住：**编程的本质是“把问题转化为可计算的模型”**——比如把“猴子的跳跃”转化为“概率转移方程”，把“树的结构”转化为“数组的区间操作”。  

下次遇到类似的“长期概率问题”，不妨想想“稳态分布”和“树递推”——它们会帮你找到解题的钥匙！💪


--- 
**提示**：若想运行代码或查看动画，可以将代码复制到C++编译器（如Dev-C++）中，或用HTML/CSS/JS实现像素动画（比如用`Canvas`绘制像素树，用`setInterval`实现单步动画）。

---
处理用时：123.73秒
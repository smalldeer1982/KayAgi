# 题目信息

# [BJOI2018] 治疗之雨

## 题目背景

（没玩过《炉石传说》的人可以跳过这一段）今天我们来探讨下《炉石传说》中“治疗之雨”（恢复 $12$ 点生命值，随机分配到所有友方角色上）和“暗影打击装甲”（每当一个角色获得治疗，便对随机敌人造成 $1$点伤害）这两张卡牌之间的互动效果。假设你场上有 $m$个剩余生命值无限大且生命值上限减去剩余生命值也无限大的随从，而对方的场上有 $k$个暗影打击装甲，你的英雄剩余生命值为 $p$、生命值上限为 $n$，现在你使用了一张可以恢复无限多（而不是 $12$ 点）生命值的治疗之雨，问治疗之雨期望总共恢复了几点生命值以后你的英雄会死亡（生命值降为 $0$；治疗之雨的判定机制使得在此后再也不会为英雄恢复生命值）。

注：题目背景与题目描述有冲突的地方请以题目描述为准

下面让我们再形式化地描述一遍问题。

## 题目描述

**题目更新：鉴于很多人反映看不懂题，但是出于尊重原题面的原则不进行大幅度更改。您可以将最小值和最大值理解为下限和上限，类似于题目背景中的血量。**


你现在有 $m+1$ 个数：第一个为 $p$，最小值为 $0$，最大值为 $n$；剩下 $m$个都是无穷，没有最小值或最大值。你可以进行任意多轮操作，每轮操作如下：

在不为最大值的数中等概率随机选择一个（如果没有则不操作），把它加一；

进行 $k$次这个步骤：在不为最小值的数中等概率随机选择一个（如果没有则不操作），把它减一。 

现在问期望进行多少轮操作以后第一个数会变为最小值 $0$。

## 说明/提示

###数据范围

对于 $10\%$ 的数据， $n \leq 3$ ，$m, k \leq 2$ 。

对于 $20\%$ 的数据， $n, m, k \leq 5$ 。

对于 $30\%$ 的数据， $n, m, k \leq 30$ 。

对于 $40\%$ 的数据， $n, m, k \leq 50$ 。

对于 $50\%$ 的数据， $n, m, k \leq 200$ 。

对于 $70\%$ 的数据， $n \leq 200$ 。

对于 $80\%$ 的数据， $n \leq 500$ 。

对于 $100\%$ 的数据， $1 \leq T \leq 100$，$1 \leq p \leq n \leq 1500$ ，$0 \leq m, k \leq 1000000000$。

保证不存在$n=p=k=1$,$m=0$的情况（因为出题人判错了）

保证不存在答案的分母是$1000000007$的倍数的情况（因为出题人没想到）

## 样例 #1

### 输入

```
2
2 1 1 1
2 2 1 1```

### 输出

```
6
8```

# AI分析结果

# 💡 Kay的C++算法解析：[BJOI2018]治疗之雨 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`高斯消元（优化版）与概率期望递推`

🗣️ **初步分析**：  
解决这道题就像解一组“血量方程”——每个血量值对应一个“未知数”（从该血量到死亡的期望步数），而每一步操作的概率就是“方程的系数”。我们需要用**高斯消元**来解这些方程，但直接解是“笨办法”（O(n³)超时），好在本题的方程结构很特殊（每行只有当前和下一个血量的系数非零），就像“多米诺骨牌”一样，我们可以**两行两行消元**，把复杂度降到O(n²)。  

### 核心思路与难点
- **问题转化**：将每个血量i视为状态，设E[i]为从i到死亡的期望步数，建立方程E[i] = Σ(转移概率×E[j]) + 1（每步加1）。  
- **大k处理**：k（扣血次数）可达1e9，但英雄最多扣n滴就死，所以只需预处理前n个扣血概率（用递推式`f[i] = f[i-1] × (k-i+1)/(i×m)`，避免计算大数组合数）。  
- **高斯消元优化**：方程矩阵是“带状”的（每行只影响当前和下一个状态），只需按顺序消去变量，最后回代求解。  

### 可视化设计思路
我们设计一个**8位像素风的“血量冒险”动画**：  
- **场景**：像素英雄站在血量条前（从0到n），旁边是“概率递推器”和“高斯消元面板”。  
- **关键演示**：  
  1. **概率递推**：每计算一个f[i]，对应的像素块闪烁，伴随“叮”的音效，显示递推式（比如f[3] = f[2] × (k-2)/(3m)）。  
  2. **高斯消元**：每消去一个变量，当前行和列高亮，用像素箭头指向被消去的变量，伴随“嗡”的音效，最后回代时血量条从n到p依次点亮，显示最终期望步数。  
- **交互**：支持“单步执行”（看每一步递推/消元）、“自动播放”（快速演示全程）、“重置”（重新开始），胜利时播放8位“胜利音效”。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法优化程度等方面，筛选了3份优质题解：
</eval_intro>

**题解一：(来源：shadowice1984，赞35)**  
* **点评**：这份题解是“标准解法”的标杆——思路从“概率模型”到“方程建立”再到“高斯消元优化”，每一步都讲得很透。概率递推部分处理了大k的问题，用`f[i] = f[i-1] × (k-i+1)/(i×m)`预处理前n个概率，避免了计算大数组合数；高斯消元部分利用矩阵结构，两行两行消元，时间复杂度降到O(n²)。代码风格规范（变量名如`f[i]`表示扣i滴的概率，`mp[i][j]`表示方程系数），特判了m=0、k=0等无解情况，非常严谨。

**题解二：(来源：Genius_Star，赞21)**  
* **点评**：此题解的“概率递推推导”非常详细，把`f[i]/f[i-1]`的比值拆开，一步步得到递推式，适合新手理解。高斯消元部分实现了“逆序回代”，代码结构清晰（用`a[i][j]`存储方程系数，`x[i]`存储解）。同时，题解提到了O(n³)的初始做法和O(n²)的优化，对比了两者的差异，帮助学习者理解优化的必要性。

**题解三：(来源：oisdoaiu，赞9)**  
* **点评**：这是一份“巧思题解”——没有直接用高斯消元，而是将方程转化为“线性关系”（比如E[1] = k1×E[2]+b1，E[2] = k2×E[3]+b2），最后代入E[n]的方程解出E[1]，再回代得到所有E[i]。这种方法避免了构建大型矩阵，常数更小，适合理解方程的“链式结构”。题解还解释了“为什么中途死了不影响概率”（因为E[0]=0，乘任何系数都是0），细节到位。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“三座大山”是：大k的概率处理、高斯消元的优化、特判无解情况。以下是针对性策略：
</difficulty_intro>

### 1. 大k的概率递推（k到1e9，只需前n个）
- **问题**：k太大，直接计算组合数C(k,i)会溢出。  
- **策略**：用递推式！因为`f[i] = C(k,i)×(1/(m+1))^i×(m/(m+1))^(k-i)`，所以`f[i]/f[i-1] = (k-i+1)/(i×m)`（约去公共项后）。初始化`f[0] = (m/(m+1))^k`，然后递推前n个f[i]即可。  
- 💡 **学习笔记**：当k很大但需要的项很少时，递推比直接计算更高效！

### 2. 高斯消元的优化（从O(n³)到O(n²)）
- **问题**：直接高斯消元会超时（n=1500时，1500³=3e9次操作）。  
- **策略**：观察方程结构——对于i < n，E[i]只和E[1..i]、E[i+1]有关；对于i=n，E[n]只和E[1..n]有关。所以矩阵的每行只有**当前列和下一列**非零，只需按顺序消去变量，最后回代。  
- 💡 **学习笔记**：算法优化的关键是“利用问题的特殊结构”！

### 3. 特判无解情况（避免输出错误答案）
- **问题**：某些情况无法让英雄死亡（比如k=0，英雄只会加血；m=0且k=1，每轮加血又扣血，无限循环）。  
- **策略**：提前判断：  
  - k=0：输出-1（无法扣血）；  
  - m=0且k=1：输出-1（无限循环）；  
  - m=0且k>1：直接模拟每轮的血量变化（因为每轮必加血再扣k滴）。  
- 💡 **学习笔记**：特判是“兜底”，能避免复杂计算中的错误！

### ✨ 解题技巧总结
- **概率递推**：用比值递推处理大数组合数；  
- **矩阵优化**：利用方程的“链式结构”降低高斯消元复杂度；  
- **特判优先**：先处理无解情况，再进行复杂计算。  


## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，给出一个**清晰的核心实现**，包含概率递推、高斯消元优化和特判。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了shadowice1984和Genius_Star的思路，处理了大k的概率递推和高斯消元的优化，适合作为标准实现。
* **完整核心代码**：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

typedef long long ll;
const int N = 1510;
const ll mod = 1e9 + 7;

ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

ll inv(ll x) { return qpow(x, mod - 2); }

ll n, p, m, k;
ll f[N], a[N][N]; // f[i]：扣i滴的概率；a[i][j]：方程系数

void solve() {
    scanf("%lld%lld%lld%lld", &n, &p, &m, &k);
    if (k == 0) { printf("-1\n"); return; }
    if (m == 0) {
        if (k == 1) { printf("-1\n"); return; }
        ll res = 0;
        while (p > 0) {
            if (p < n) p++;
            p -= k;
            res++;
        }
        printf("%lld\n", res);
        return;
    }

    // 预处理概率f[i]
    ll inv_m = inv(m), inv_m1 = inv(m + 1);
    f[0] = qpow(m * inv_m1 % mod, k);
    ll max_f = min(k, n + 1);
    for (ll i = 1; i <= max_f; i++) {
        f[i] = f[i-1] * inv_m % mod; // 乘以1/m
        f[i] = f[i] * inv(i) % mod; // 除以i
        f[i] = f[i] * (k - i + 1) % mod; // 乘以(k-i+1)
    }

    // 初始化方程矩阵
    for (ll i = 1; i <= n; i++) {
        for (ll j = 1; j <= n + 1; j++) a[i][j] = 0;
    }
    for (ll i = 1; i < n; i++) {
        // 方程：E[i] = sum_{j=1}^i ( (m*f[i-j] + f[i-j+1])/ (m+1) ) * E[j] + f[0]/(m+1)*E[i+1] + 1
        for (ll j = 1; j <= i; j++) {
            a[i][j] = (a[i][j] + f[i-j] * m % mod + f[i-j+1]) % mod;
            a[i][j] = a[i][j] * inv_m1 % mod;
        }
        a[i][i+1] = f[0] * inv_m1 % mod;
        a[i][i] = (a[i][i] - 1 + mod) % mod; // 移项：E[i] - ... = 1
        a[i][n+1] = mod - 1; // 常数项是1，移项后是-1
    }
    // 处理i=n的情况（无法加血）
    for (ll j = 1; j <= n; j++) {
        a[n][j] = f[n - j];
    }
    a[n][n] = (a[n][n] - 1 + mod) % mod;
    a[n][n+1] = mod - 1;

    // 高斯消元（优化版：两行两行消）
    for (ll i = 1; i <= n; i++) {
        ll inv_a = inv(a[i][i]);
        a[i][i] = 1;
        a[i][n+1] = a[i][n+1] * inv_a % mod;
        if (i != n) a[i][i+1] = a[i][i+1] * inv_a % mod;

        // 消去下一行的i列
        if (i < n) {
            ll mul = a[i+1][i];
            a[i+1][i] = 0;
            a[i+1][i+1] = (a[i+1][i+1] - mul * a[i][i+1] % mod + mod) % mod;
            a[i+1][n+1] = (a[i+1][n+1] - mul * a[i][n+1] % mod + mod) % mod;
        }
    }

    // 回代求解
    for (ll i = n-1; i >= 1; i--) {
        a[i][n+1] = (a[i][n+1] - a[i][i+1] * a[i+1][n+1] % mod + mod) % mod;
    }

    printf("%lld\n", a[p][n+1]);
}

int main() {
    int T;
    scanf("%d", &T);
    while (T--) solve();
    return 0;
}
```
* **代码解读概要**：  
  1. **特判**：先处理k=0、m=0等无解情况；  
  2. **概率递推**：用`f[i]`存储扣i滴的概率，递推前n个；  
  3. **方程构建**：根据转移概率建立每个血量i的方程；  
  4. **高斯消元**：两行两行消去变量，最后回代得到E[p]（答案）。  


---

<code_intro_selected>
我们剖析优质题解中的**核心片段**，看它们如何解决关键问题：
</code_intro_selected>

### 题解一：(来源：shadowice1984)
* **亮点**：用“两行两行消元”优化高斯消元，代码简洁高效。
* **核心代码片段**：
```cpp
// 高斯消元部分
for (int i = 1; i <= n; i++) {
    ll inv = qpow(mp[i][i], mod - 2);
    mp[i][i] = 1;
    mp[i][n+1] = mp[i][n+1] * inv % mod;
    if (i != n) mp[i][i+1] = mp[i][i+1] * inv % mod;
    // 消去下一行的i列
    for (int j = i+1; j <= n; j++) {
        ll mult = mp[j][i];
        mp[j][i] = 0;
        mp[j][i+1] = (mp[j][i+1] - mult * mp[i][i+1] % mod + mod) % mod;
        mp[j][n+1] = (mp[j][n+1] - mult * mp[i][n+1] % mod + mod) % mod;
    }
}
// 回代
for (int i = n; i > 1; i--) {
    mp[i-1][n+1] = (mp[i-1][n+1] - mp[i-1][i] * mp[i][n+1] % mod + mod) % mod;
}
```
* **代码解读**：  
  - 对于每行i，先求逆元（将mp[i][i]变为1）；  
  - 用当前行消去下一行的i列（因为下一行的i列系数非零）；  
  - 最后从n到1回代，计算每个E[i]的值。  
* 💡 **学习笔记**：高斯消元的优化关键是“只处理非零的列”！

### 题解三：(来源：oisdoaiu)
* **亮点**：将方程转化为线性关系，避免直接构建矩阵。
* **核心代码片段**：
```cpp
// 将E[i]表示为E[i+1]的线性组合：E[i] = k[i] * E[i+1] + b[i]
for (int i = 1; i <= n-1; i++) {
    a[i+1] = (a[i] - sum_a) * inv_p[i][i+1];
}
// 代入E[n]的方程解出E[n]
ll E_n = (sum_b) * inv(1 - sum_k);
// 回代得到E[p]
ll E_p = k[p] * E_n + b[p];
```
* **代码解读**：  
  - 对于每个i < n，将E[i]表示为E[i+1]的线性组合（k[i]是系数，b[i]是常数）；  
  - 最后用E[n]的方程解出E[n]，再回代得到所有E[i]。  
* 💡 **学习笔记**：有时候“绕开矩阵”能更高效地解决问题！  


## 5. 算法可视化：像素动画演示

### 动画主题：**像素英雄的“血量期望冒险”**
### 设计思路
采用**8位FC游戏风格**，营造复古轻松的学习氛围。通过“像素块变化”和“简单音效”强化关键步骤的记忆，比如：
- **概率递推**：每计算一个f[i]，对应的像素块从“灰色”变“蓝色”，伴随“叮”的音效，屏幕下方显示递推式（如`f[3] = f[2] × (k-2)/(3×m)`）。  
- **高斯消元**：每消去一个变量，当前行的像素块闪烁“黄色”，用“像素箭头”指向被消去的列，伴随“嗡”的音效，消元完成后，血量条从n到p依次点亮“绿色”，显示最终期望步数。  
- **胜利场景**：当得到E[p]时，像素英雄跳起来，屏幕弹出“胜利！期望步数：X”，播放8位“胜利音乐”（如《超级马里奥》的通关音效）。

### 动画步骤与交互
1. **初始化**：显示像素英雄（16×16像素）、血量条（0到n）、控制面板（开始/暂停、单步、重置）。  
2. **概率递推**：点击“开始”，依次计算f[0]到f[n]，每个f[i]的像素块闪烁，显示递推式。  
3. **高斯消元**：递推完成后，自动开始消元，每行消去时高亮，回代时血量条依次点亮。  
4. **交互控制**：  
   - **单步**：点击一次，执行一步递推/消元；  
   - **自动播放**：按1x/2x/3x速度播放全程；  
   - **重置**：回到初始状态，重新开始。

### 技术实现
- **像素绘制**：用HTML5 Canvas绘制8位像素（每个像素块4×4像素，方便点击）；  
- **音效**：用Web Audio API播放简单的8位音效（如“叮”用频率440Hz的正弦波，“嗡”用频率220Hz的方波）；  
- **交互**：用JavaScript实现按钮点击和速度调节（滑块控制播放速度）。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的“概率期望+高斯消元”思路可用于解决**状态转移有后效性**的问题，比如：
- 迷宫中的期望步数（每个格子的期望步数依赖相邻格子）；  
- 卡牌游戏中的期望收益（每张卡牌的收益依赖后续选择）；  
- 排队问题中的期望等待时间（每个顾客的等待时间依赖前面的顾客）。

### 练习推荐（洛谷）
1. **洛谷 P4457**：原题（巩固本题的概率递推和高斯消元优化）；  
2. **洛谷 P3802 小魔女帕琪**：概率期望问题，需预处理组合数；  
3. **洛谷 P4316 绿豆蛙的归宿**：期望DP问题，状态转移无后效性，可直接递推；  
4. **洛谷 P1850 换教室**：概率DP问题，需处理多个状态的转移。  


## 7. 学习心得与经验分享 (若有)

### 参考经验（来自oisdoaiu的题解）
> “当你只有x滴血的时候，p[x]还是那么多吗？注意到如果你中途没有血了，后面的判定必定不中，但这没关系——因为f[0]=0，乘出来都是0。”

**点评**：这个细节很重要！它告诉我们**不需要处理“中途死亡”的概率**，因为E[0]=0，这些项不会影响结果。这是“简化方程”的关键，避免了复杂的条件判断。  


## 🎉 总结
本次分析了“治疗之雨”的C++解法，核心是**高斯消元的优化**和**概率递推的处理**。希望这份指南能帮助你理解“如何将概率问题转化为方程组”，以及“如何利用问题结构优化算法”。记住：**编程的本质是“解决问题”，而不是“写复杂的代码”**——找到问题的特殊点，就能找到更高效的解法！

下次我们再一起探索新的编程挑战！💪

---
处理用时：128.60秒
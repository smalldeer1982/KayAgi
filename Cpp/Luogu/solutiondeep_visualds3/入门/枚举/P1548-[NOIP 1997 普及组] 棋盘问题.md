# 题目信息

# [NOIP 1997 普及组] 棋盘问题

## 题目背景

NOIP1997 普及组第一题

## 题目描述

设有一个 $N \times M$ 方格的棋盘 $(1≤N≤100,1≤M≤100)$

求出该棋盘中包含有多少个正方形、多少个长方形（不包括正方形）。

例如：当 $N=2, M=3$ 时：

![](https://cdn.luogu.com.cn/upload/image_hosting/kkidop2i.png)

   
正方形的个数有 $8$ 个：即边长为 $1$ 的正方形有 $6$ 个；边长为 $2$ 的正方形有 $2$ 个。

长方形的个数有 $10$ 个：

即  

- $2 \times 1$ 的长方形有 $4$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/vhazon60.png)

- $1 \times 2$ 的长方形有 $3$ 个：  

![](https://cdn.luogu.com.cn/upload/image_hosting/jr40fqzv.png)

- $3 \times 1$ 的长方形有 $2$ 个：  

![](https://cdn.luogu.com.cn/upload/image_hosting/ja0mx48f.png)

- $3 \times 2$ 的长方形有 $1$ 个：  

![](https://cdn.luogu.com.cn/upload/image_hosting/kkidop2i.png)


## 样例 #1

### 输入

```
2 3```

### 输出

```
8 10```

# AI分析结果

# 💡 Kay的C++算法解析：[NOIP 1997 普及组] 棋盘问题 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学应用`  

🗣️ **初步分析**：  
解决“棋盘问题”的关键，是用**数学推导**找出正方形和矩形的数量规律——就像玩“数积木”游戏：要数清楚盒子里有多少个正方体（正方形），得先数1×1的小方块，再数2×2的大方块，依此类推；而数所有长方体（包括正方体），则要先数“长边上能切出多少段”“宽边上能切出多少段”，再把两段数相乘（比如长边有3段、宽边有6段，就能组合出18个长方体）。  

在本题中：  
- **正方形数量**：边长为`k`的正方形有`(N - k + 1) × (M - k + 1)`个（比如2×3棋盘，边长1的有2×3=6个，边长2的有1×2=2个，总和8个）。  
- **总矩形数量**：所有矩形（包括正方形）的数量等于“长边上线段数”×“宽边上线段数”。线段数的计算是小学奥数的“数线段”问题——n个点能组成`1+2+…+n = n(n+1)/2`条线段（比如长边有2格，对应3个点，线段数是3×2/2=3）。  
- **长方形数量**：总矩形数减去正方形数（题目要求“不包括正方形”）。  

**核心算法流程**：  
1. 计算正方形数量：枚举边长`k`从1到`min(N,M)`，累加每个`k`对应的数量。  
2. 计算总矩形数量：用线段数公式计算长、宽的线段数，相乘得到总数。  
3. 计算长方形数量：总矩形数 - 正方形数。  

**可视化设计思路**：  
我们会用**8位像素风**模拟2×3的棋盘（像FC游戏里的像素块），逐步演示：  
- 正方形计数：边长1的小方块逐个闪烁（伴随“叮”的音效），数到6个；边长2的大方块闪烁，数到2个，总数8个。  
- 总矩形计数：长边的线段用不同颜色标注（1格长的线段、2格长的线段），宽边同理，最后用“线段组合”动画展示总矩形数18。  
- 长方形计数：从总矩形中“减去”正方形，剩下的10个长方形闪烁。  


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、算法效率**三个维度筛选了3份优质题解，覆盖了“公式推导”“小学奥数思路”“直观遍历”三种常见方法，适合不同基础的学习者参考。
</eval_intro>

**题解一：BlueArc的公式推导法（来源：洛谷用户BlueArc）**  
* **点评**：这份题解的核心是“用数学规律代替暴力枚举”，推导过程像“拆积木”一样清晰——先讲正方形的数量是“边长1到min(N,M)的数量之和”，再讲总矩形数是“线段数相乘”，最后用总矩形数减正方形数得到长方形数。代码极其简洁，仅用一个循环计算正方形数量，公式直接对应推导结果，**效率极高（O(min(N,M))）**，是竞赛中的“标准解法”。  

**题解二：JimmyF的小学奥数思路（来源：洛谷用户JimmyF）**  
* **点评**：这份题解用“2×3棋盘”的例子一步步解释，像老师讲奥数题一样易懂——比如总矩形数是“(1+2)×(1+2+3)=3×6=18”，正方形数是“6+2=8”，长方形数是“18-8=10”。代码用两个循环计算“1~N的和”和“1~M的和”，再相乘得到总矩形数，**特别适合初学者理解公式的来源**。  

**题解三：约修亚_RK的直观遍历法（来源：洛谷用户约修亚_RK）**  
* **点评**：这份题解的思路很“直白”——遍历所有可能的“矩形长k”和“矩形宽i”，如果k==i就累加正方形数量，否则累加长方形数量。每个k和i对应的矩形数是“(N -k +1)×(M -i +1)”（比如长2、宽1的矩形，在2×3棋盘中有(2-2+1)×(3-1+1)=1×3=3个）。这种方法**直接对应“数所有矩形”的逻辑**，适合喜欢“眼见为实”的学习者。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点是**“从问题中抽象出数学规律”**，以下是三个最容易卡壳的点及解决策略：
</difficulty_intro>

1. **难点1：如何推导正方形的数量公式？**  
   * **分析**：正方形的边长不能超过棋盘的最小边（比如2×3棋盘，最大边长是2）。对于边长`k`，横向能放`N -k +1`个（比如2×3棋盘，边长2的横向能放2-2+1=1个），纵向能放`M -k +1`个，所以总数是两者的乘积。  
   * 💡 **学习笔记**：枚举边长，累加每个边长的数量，是计算正方形的“标准套路”。  

2. **难点2：如何推导总矩形的数量公式？**  
   * **分析**：矩形的“长”由长边的线段决定，“宽”由宽边的线段决定。比如长边有N格（对应N+1个点），能组成`1+2+…+N = N(N+1)/2`条线段；宽边同理。总矩形数是两者的乘积（比如2×3棋盘，长边线段数3，宽边线段数6，总矩形数18）。  
   * 💡 **学习笔记**：总矩形数=长边线段数×宽边线段数，这是“数矩形”的万能公式。  

3. **难点3：如何避免数据溢出？**  
   * **分析**：当N和M是100时，总矩形数是`(100×101/2)×(100×101/2)=5050×5050=25,502,500`，超过了int的范围（int通常最多存20亿，但有些编译器的int是4字节，能存到2^31-1=2,147,483,647，所以100×100的情况刚好够，但更大的数会溢出）。  
   * **解决策略**：用`long long`类型存储中间结果（比如`long long total_rect = (long long)N*(N+1)/2 * M*(M+1)/2`）。  
   * 💡 **学习笔记**：涉及大数乘法时，要先转成`long long`再计算。  


### ✨ 解题技巧总结
- **技巧1：用小例子验证公式**：比如样例2×3，先手动算正方形数8、长方形数10，再用公式验证，确保推导正确。  
- **技巧2：优先用数学公式**：暴力枚举（比如四层循环）的时间复杂度是O(N^4)，对于N=100会超时，而公式法是O(min(N,M))，效率高得多。  
- **技巧3：注意数据类型**：用`long long`存储大数值，避免溢出。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**，它综合了公式法的优点，代码简洁、效率高，能直接解决问题。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自BlueArc和JimmyF的题解，综合了“公式推导”和“易懂性”，是竞赛中的标准解法。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <algorithm> // 用于min函数
  using namespace std;

  int main() {
      int N, M;
      cin >> N >> M;
      long long square = 0; // 正方形数量
      int min_side = min(N, M); // 最大正方形边长
      // 计算正方形数量：枚举边长k从1到min_side
      for (int k = 1; k <= min_side; ++k) {
          square += (long long)(N - k + 1) * (M - k + 1);
      }
      // 计算总矩形数量：长边线段数 × 宽边线段数
      long long total_rect = (long long)N * (N + 1) / 2 * M * (M + 1) / 2;
      // 计算长方形数量：总矩形数 - 正方形数
      long long rectangle = total_rect - square;
      // 输出结果
      cout << square << " " << rectangle << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 输入棋盘的长N和宽M。  
  2. 枚举正方形的边长k，累加每个k对应的数量（`(N -k +1)×(M -k +1)`）。  
  3. 用线段数公式计算总矩形数（`N(N+1)/2 × M(M+1)/2`）。  
  4. 用总矩形数减去正方形数，得到长方形数。  
  5. 输出结果。  


<code_intro_selected>
接下来剖析三份优质题解的核心代码片段，看看它们的“亮点”在哪里。
</code_intro_selected>

**题解一：BlueArc的公式推导法**
* **亮点**：用“自减循环”简化正方形数量的计算（不需要单独求min(N,M)）。
* **核心代码片段**：
  ```cpp
  int n, m, s1 = 0, s2;
  cin >> n >> m;
  s2 = ((m + 1) * (n + 1) * m * n) / 4; // 总矩形数
  for (; m >= 1 && n >= 1; m--, n--) {
      s1 += m * n; // 累加每个边长的正方形数量
  }
  cout << s1 << " " << s2 - s1;
  ```
* **代码解读**：  
  - `s2 = ((m+1)*(n+1)*m*n)/4`：总矩形数的公式（等价于`(m(m+1)/2)×(n(n+1)/2)`）。  
  - `for (; m >=1 && n >=1; m--,n--)`：每次m和n减1，相当于边长从1到min(初始m,n)（比如初始m=3、n=2，循环会执行2次：m=3,n=2 → 边长1；m=2,n=1 → 边长2）。  
  - `s1 += m*n`：每次循环计算当前边长的正方形数量（比如第一次循环m=3,n=2 → 3×2=6个边长1的正方形；第二次m=2,n=1 → 2×1=2个边长2的正方形，总和8个）。  
* 💡 **学习笔记**：用“自减循环”可以避免单独计算min(N,M)，代码更简洁。  


**题解二：JimmyF的小学奥数思路**
* **亮点**：用循环计算“1~N的和”和“1~M的和”，直观对应小学奥数的“数线段”问题。
* **核心代码片段**：
  ```cpp
  int n, m, sum = 0, N = 0, M = 0, SUM;
  cin >> n >> m;
  // 计算正方形数量：枚举边长k从1到min(n,m)
  for (int i = 1; i <= min(n, m); i++) {
      sum += (n - i + 1) * (m - i + 1);
  }
  // 计算长边线段数（1~n的和）
  for (int i = 1; i <= n; i++) N += i;
  // 计算宽边线段数（1~m的和）
  for (int i = 1; i <= m; i++) M += i;
  // 总矩形数 = 长边线段数 × 宽边线段数
  SUM = N * M - sum;
  cout << sum << " " << SUM;
  ```
* **代码解读**：  
  - `for (int i=1; i<=min(n,m); i++) sum += (n-i+1)*(m-i+1)`：直接枚举边长i，计算每个i对应的正方形数量（比如i=1时，(2-1+1)×(3-1+1)=2×3=6；i=2时，(2-2+1)×(3-2+1)=1×2=2，总和8）。  
  - `for (int i=1; i<=n; i++) N += i`：计算长边的线段数（比如n=2时，N=1+2=3）。  
  - `SUM = N*M - sum`：总矩形数减去正方形数，得到长方形数（比如N=3, M=6 → 3×6=18；18-8=10）。  
* 💡 **学习笔记**：用循环计算“1~n的和”，比直接用公式更直观，适合初学者理解。  


**题解三：约修亚_RK的直观遍历法**
* **亮点**：直接遍历所有可能的“矩形长k”和“矩形宽i”，逻辑直观，像“手动数所有矩形”。
* **核心代码片段**：
  ```cpp
  int n, m, ans = 0, anst = 0;
  scanf("%d %d", &n, &m);
  for (int k = 1; k <= n; k++) { // 遍历矩形的长k
      for (int i = 1; i <= m; i++) { // 遍历矩形的宽i
          // 如果长等于宽，累加正方形数量；否则累加长方形数量
          (k == i ? ans : anst) += (n - k + 1) * (m - i + 1);
      }
  }
  printf("%d %d", ans, anst);
  ```
* **代码解读**：  
  - `for (int k=1; k<=n; k++)`：遍历矩形的长k（从1到n）。  
  - `for (int i=1; i<=m; i++)`：遍历矩形的宽i（从1到m）。  
  - `(k == i ? ans : anst) += (n -k +1)*(m -i +1)`：如果k==i（正方形），就把数量加到ans；否则加到anst（长方形）。比如k=1、i=1时，(2-1+1)×(3-1+1)=2×3=6 → ans=6；k=1、i=2时，(2-1+1)×(3-2+1)=2×2=4 → anst=4，依此类推。  
* 💡 **学习笔记**：这种方法虽然时间复杂度是O(N×M)（比公式法略高，但N和M≤100时完全没问题），但逻辑更直观，适合理解“所有矩形”的构成。  


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家“看清楚”算法的每一步，我设计了一个**8位像素风的动画**，像玩FC游戏一样学习！
</visualization_intro>

### **动画演示主题**：像素棋盘的“数积木游戏”  
我们用2×3的棋盘作为例子，模拟“数正方形→数总矩形→数长方形”的过程，融合**复古游戏元素**（比如像素音效、单步执行、自动播放）。


### **设计思路**  
- **风格**：8位像素风（像《超级马里奥》的画面），用红、蓝、绿三种颜色分别标记“正方形”“总矩形”“长方形”。  
- **交互**：提供“单步执行”“自动播放”“重置”按钮，支持调速（滑块从“慢”到“快”）。  
- **音效**：  
  - 数正方形时，每个正方形闪烁伴随“叮”的短音；  
  - 数总矩形时，线段组合伴随“咔嗒”声；  
  - 完成时播放“胜利”音效（像FC游戏通关的音乐）。  


### **动画帧步骤**  
1. **初始化场景**：  
   - 屏幕显示2×3的像素棋盘（每个小格子是16×16的像素块，底色是浅灰色）。  
   - 下方有“单步”“自动”“重置”按钮，右侧有“速度滑块”。  
   - 8位风格的背景音乐（轻快的电子乐）开始播放。  

2. **数正方形**：  
   - **步骤1**：边长1的正方形逐个闪烁（红色），每闪烁一个，右上角计数器“正方形：x”加1（从0到6），伴随“叮”的音效。  
   - **步骤2**：边长2的正方形闪烁（红色），计数器从6加到8，伴随“叮”的音效。  
   - **提示旁白**：“现在数的是边长1的正方形，总共有6个；接下来数边长2的，有2个，总共8个！”

3. **数总矩形**：  
   - **步骤1**：长边（垂直方向）的线段用蓝色标注：1格长的线段（2条）、2格长的线段（1条），计数器“长边线段：3”。  
   - **步骤2**：宽边（水平方向）的线段用蓝色标注：1格长的线段（3条）、2格长的线段（2条）、3格长的线段（1条），计数器“宽边线段：6”。  
   - **步骤3**：用“线段组合”动画展示总矩形数：长边选一条线段、宽边选一条线段，组合成一个矩形（闪烁绿色），计数器“总矩形：18”。  
   - **提示旁白**：“长边有3条线段，宽边有6条，总共有3×6=18个矩形！”

4. **数长方形**：  
   - **步骤1**：从总矩形中“减去”正方形（红色闪烁的矩形消失），剩下的矩形闪烁绿色，计数器“长方形：10”。  
   - **提示旁白**：“总矩形18个，减去正方形8个，长方形有10个！”

5. **结束状态**：  
   - 播放“胜利”音效，屏幕显示“完成！正方形：8，长方形：10”，并弹出“再玩一次？”的提示。  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是“数学推导”和“规律总结”，这种思路能解决很多类似的“计数问题”。
</similar_problems_intro>

### **通用思路迁移**  
- **场景1**：数三角形的数量（比如在一个大三角形中，数所有小三角形的数量）——类似枚举边长，累加每个边长的数量。  
- **场景2**：数网格中的路径数量（比如从左上角到右下角，只能向右或向下走，有多少条路径）——用组合数学公式计算。  
- **场景3**：数字符串中的子串数量（比如“abc”有多少个子串）——类似数线段的问题，公式是n(n+1)/2。  


### **练习推荐 (洛谷)**  
1. **洛谷 P1025** - 数的划分  
   * 🗣️ **推荐理由**：这道题需要用数学推导或动态规划计算“将n分成k个正整数的和”的方案数，能巩固“枚举+规律总结”的思路。  
2. **洛谷 P1164** - 小A点菜  
   * 🗣️ **推荐理由**：这道题需要用动态规划计算“用给定的钱买完所有菜”的方案数，能锻炼“从问题中抽象出状态”的能力。  
3. **洛谷 P1200** - 你的飞碟在这儿  
   * 🗣️ **推荐理由**：这道题需要用数学公式计算“第k个飞碟的位置”，能巩固“推导公式+验证小例子”的技巧。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我总结了两个**非常实用的学习经验**：
</insights_intro>

> **经验1：暴力法是“理解问题”的好帮手，但公式法是“解决问题”的高效方式**  
> 很多初学者会先想到“暴力枚举所有矩形”（比如四层循环），这能帮助理解“矩形的构成”，但时间复杂度太高。而通过推导公式，能将时间复杂度从O(N^4)降到O(min(N,M))，效率提升几千倍。  
> **点评**：暴力法是“入门砖”，公式法是“进阶剑”——先暴力理解问题，再推导公式优化，是学习算法的好路径。

> **经验2：用小例子验证公式，避免“想当然”**  
> 很多题解提到“用样例2×3验证公式”，比如正方形数8、长方形数10，这能确保公式的正确性。如果直接写公式而不验证，很容易犯“符号错误”（比如把`N -k +1`写成`N -k`）。  
> **点评**：小例子是“公式的试金石”——无论推导多复杂，用小例子验证一遍，就能避免低级错误。  


<conclusion>
本次关于“棋盘问题”的分析就到这里啦！这道题的核心是**“从问题中找规律，用数学公式解决”**——就像玩“数积木”游戏，先数小的，再数大的，最后组合起来。希望这份指南能帮助你掌握“数学推导”的技巧，下次遇到类似的计数问题，能轻松应对！💪
</conclusion>

---
处理用时：166.90秒
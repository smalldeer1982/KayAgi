# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果

# 💡 Kay的C++算法解析：最优贸易 深入学习指南 💡

## 引言
今天我们要解决的是NOIP2009提高组的经典题目——**最优贸易**。这道题是图论中“状态建模”的典型例子，核心是帮商人找到从1号城市到n号城市的过程中，**最多一次买卖水晶球的最大差价**。通过这道题，我们能学会用“分层图”或“两次SPFA”这类巧妙的方法，把“买卖状态”和“图的路径”结合起来！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：分层图建模 / 双SPFA（最短路的变形）

🗣️ **初步分析**：
解决这道题的关键，是把“商人的状态”（没买、买了没卖、卖了）**映射成图的不同层级**——这就是“分层图”的核心思想！打个比方，就像游戏里的“普通模式”“携带物品模式”“完成交易模式”，每层有自己的规则，层之间用“买入/卖出”操作连接。

### 核心问题拆解
商人的路径可以抽象为：`1号城市 → 买水晶球（点A） → 卖水晶球（点B） → n号城市`。我们需要确保：
- 从1能走到A；
- 从A能走到B；
- 从B能走到n；
- 差价（B的价格 - A的价格）最大。

### 分层图的魔法
我们把原图复制成3层，每层代表一个状态：
1. **第一层（层0）**：没买水晶球（初始状态）；
2. **第二层（层1）**：买了水晶球但没卖；
3. **第三层（层2）**：卖了水晶球（最终状态）。

**层内边**：同一层的城市之间移动，边权为0（因为移动不花钱）；  
**层间边**：
- 从层0的点i到层1的点i：边权为`-价格[i]`（买水晶球花了钱，利润减少）；
- 从层1的点i到层2的点i：边权为`+价格[i]`（卖水晶球赚了钱，利润增加）。

最终，我们要找**层0的1号点到层2的n号点的最长路**——这就是最大利润！

### 可视化设计思路
我们用**8位像素风**（红白机风格）做动画：
- 节点是16×16的像素块，层0白色、层1蓝色、层2绿色；
- 移动时用“滑移动画”，层间跳转用“闪烁+音效”（买：叮；卖：叮铃）；
- 控制面板有“单步执行”“自动播放”“重置”，速度滑块控制动画快慢；
- 到达层2的n号点时，播放“胜利音效”，节点闪金光！


## 2. 精选优质题解参考

### 题解一：分层图+SPFA（作者：fy1234567ok，赞513）
**点评**：这是题解区最经典的“分层图”实现，思路像剥洋葱一样清晰！  
- **思路巧妙**：用3层图完美映射“没买→买→卖”的状态，把利润转化为“最长路”问题；  
- **代码简洁**：用`t(x,i)`宏定义分层点（比如`t(1,0)`是层0的1号点），`add`函数批量建同一层的边，不到40行核心代码；  
- **算法高效**：用SPFA跑最长路（因为有负权边，Dijkstra不适用），初始把距离设为极小值（`INT_MIN`），更新时找更大值。  

### 题解二：双SPFA（作者：fairfriendZ，赞9）
**点评**：这是更“轻量”的解法，不用建分层图，而是用**两次SPFA**分别求“从1到各点的最小买价”和“从各点到n的最大卖价”！  
- **思路直接**：`minv[i]`表示从1到i的所有路径中，水晶球的最低价格；`maxv[i]`表示从i到n的所有路径中，水晶球的最高价格。最终答案是`max(maxv[i]-minv[i])`；  
- **正反图技巧**：求`maxv[i]`时，要建反图（把所有边反过来），从n号点跑SPFA，这样就能得到“各点到n的最大卖价”；  
- **效率极高**：两次SPFA的时间复杂度和分层图差不多，但代码更短，容易理解。

### 题解三：两次SPFA（作者：Ngo123，赞8）
**点评**：这是“双SPFA”的极简实现，代码不到50行，适合入门！  
- **代码规范**：变量名`minv`（最小买价）、`maxv`（最大卖价）非常直观；  
- **边界处理**：初始时`minv[1]`设为1号点的价格，`maxv[n]`设为n号点的价格，符合实际逻辑；  
- **容易调试**：两次SPFA分开写，出错时能快速定位问题。


## 3. 核心难点辨析与解题策略

### 关键点1：如何建模“买卖状态”？
**分析**：直接枚举“买的点”和“卖的点”会超时（n=1e5），所以需要用**状态压缩**——分层图把“状态”变成“图的层级”，让算法自动处理所有可能的买卖组合。  
💡 **学习笔记**：状态建模的核心是“把看不见的状态变成看得见的图结构”。

### 关键点2：如何处理“可达性”？
**分析**：比如双SPFA中的`maxv[i]`，需要确保从i能走到n。解决方法是**建反图**——把原图的边反过来，从n号点跑SPFA，这样能到达的点就是“能走到n的点”。  
💡 **学习笔记**：反图是处理“单汇点可达性”的神器！

### 关键点3：如何求“最长路”？
**分析**：分层图中，边权有正有负（买是负，卖是正），所以不能用Dijkstra。SPFA可以处理负权边，但要把“最短路径”改成“最长路径”——初始距离设为极小值，更新条件是`d[v] < d[u] + len`（找更大的值）。  
💡 **学习笔记**：最长路=边权取反后的最短路，反之亦然！

### ✨ 解题技巧总结
1. **状态分层**：遇到“最多一次操作”的问题（比如买卖、传送），试试分层图；  
2. **正反图转换**：处理“从某点到所有点”或“所有点到某点”的问题，反图能简化逻辑；  
3. **SPFA的灵活运用**：不仅能跑最短路，改改初始化和更新条件就能跑最长路。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（分层图+SPFA）
**说明**：综合自fy1234567ok的题解，是分层图的经典实现。
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

const int maxn = 1e5 + 5;
int n, m;
int price[maxn];
vector<pair<int, int>> G[maxn * 3]; // 3层图，每层maxn个点
int dist[maxn * 3];
bool inqueue[maxn * 3];

#define t(x, i) (x + i * n) // 层i的x号点：i=0,1,2

void add_edge(int x, int y) {
    // 同一层的边，权值0
    G[t(x, 0)].emplace_back(t(y, 0), 0);
    G[t(x, 1)].emplace_back(t(y, 1), 0);
    G[t(x, 2)].emplace_back(t(y, 2), 0);
}

void spfa() {
    fill(dist, dist + 3 * n + 1, INT_MIN); // 最长路，初始极小值
    queue<int> q;
    dist[t(1, 0)] = 0; // 层0的1号点，初始利润0
    q.push(t(1, 0));
    inqueue[t(1, 0)] = true;

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        inqueue[u] = false;

        for (auto &edge : G[u]) {
            int v = edge.first;
            int w = edge.second;
            if (dist[v] < dist[u] + w) { // 找更长的路
                dist[v] = dist[u] + w;
                if (!inqueue[v]) {
                    q.push(v);
                    inqueue[v] = true;
                }
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        cin >> price[i];
        // 层0→层1：买，权值-price[i]
        G[t(i, 0)].emplace_back(t(i, 1), -price[i]);
        // 层1→层2：卖，权值+price[i]
        G[t(i, 1)].emplace_back(t(i, 2), price[i]);
    }

    for (int i = 0; i < m; ++i) {
        int x, y, z;
        cin >> x >> y >> z;
        add_edge(x, y);
        if (z == 2) { // 双向边，反过来也加
            add_edge(y, x);
        }
    }

    spfa();
    cout << dist[t(n, 2)] << endl; // 层2的n号点，最大利润
    return 0;
}
```
**代码解读概要**：
1. **分层点定义**：用`t(x,i)`宏把“层i的x号点”转化为唯一的整数（比如层1的3号点是`3+1*n`）；  
2. **层间边**：每个点i的层0→层1边权是`-price[i]`（买），层1→层2边权是`price[i]`（卖）；  
3. **SPFA求最长路**：初始时层0的1号点利润为0，其他点为极小值，每次更新找更大的利润。


### 题解二：双SPFA核心代码赏析（作者：fairfriendZ）
**亮点**：不用建分层图，用两次SPFA求最小买价和最大卖价，代码极简洁。
```cpp
// 核心代码片段（双SPFA）
void spfa1(int s) { // 正图，求从s到各点的最小买价
    fill(minv, minv + n + 1, INT_MAX);
    queue<int> q;
    minv[s] = price[s];
    q.push(s);
    inqueue[s] = true;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        inqueue[u] = false;
        for (int v : G[u]) {
            if (minv[v] > min(minv[u], price[v])) {
                minv[v] = min(minv[u], price[v]);
                if (!inqueue[v]) { q.push(v); inqueue[v] = true; }
            }
        }
    }
}

void spfa2(int s) { // 反图，求从各点到s的最大卖价
    fill(maxv, maxv + n + 1, INT_MIN);
    queue<int> q;
    maxv[s] = price[s];
    q.push(s);
    inqueue[s] = true;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        inqueue[u] = false;
        for (int v : revG[u]) { // revG是反图
            if (maxv[v] < max(maxv[u], price[v])) {
                maxv[v] = max(maxv[u], price[v]);
                if (!inqueue[v]) { q.push(v); inqueue[v] = true; }
            }
        }
    }
}
```
**代码解读**：
- `spfa1`：从1号点跑正图，`minv[i]`记录到i点的最小买价（比如到i点的所有路径中，最便宜的水晶球价格）；  
- `spfa2`：从n号点跑反图，`maxv[i]`记录从i点到n的最大卖价（比如从i点出发，能卖到的最高价格）；  
- 最终答案：`max(maxv[i] - minv[i])`，遍历所有点找最大差价。
💡 **学习笔记**：双SPFA的核心是“分两次处理可达性和极值”，避免了分层图的复杂建模。


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：像素商人的贸易之旅
**设计思路**：用红白机风格的像素画，把分层图的状态变化“可视化”，让你亲眼看到“买→卖”的过程！

### 动画帧步骤与交互关键点
1. **场景初始化**：
   - 屏幕左侧是3层图（层0白色、层1蓝色、层2绿色），每个节点是16×16的像素块；
   - 右侧控制面板：“开始/暂停”“单步”“重置”按钮，速度滑块（1~5倍速）；
   - 背景音：8位风格的轻快BGM（比如《超级马里奥》的背景音乐）。

2. **算法启动**：
   - 层0的1号节点开始闪烁（提示初始位置）；
   - 点击“开始”，节点开始移动：同一层移动时，用“滑移动画”（比如从层0的1→2，白色块滑到2号位置）；
   - 当节点走到层0的i号点时，点击“买入”（或自动触发），节点从层0跳到层1（白色变蓝色），播放“叮”的音效（表示花了钱）；
   - 当节点走到层1的j号点时，点击“卖出”（或自动触发），节点从层1跳到层2（蓝色变绿色），播放“叮铃”的音效（表示赚了钱）；
   - 当节点到达层2的n号点时，播放“胜利音效”（比如《魂斗罗》的通关音乐），节点闪金光，屏幕显示“最大利润：X”。

3. **交互设计**：
   - “单步”：每点击一次，执行一步操作（比如移动、买入、卖出）；
   - “自动播放”：按速度滑块的速度自动执行，适合快速看整体流程；
   - “重置”：回到初始状态，重新开始。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
分层图和双SPFA的思路，还能解决这些问题：
1. **带传送门的最短路**：比如“最多用k次传送门，求最短路径”（分层图，每层代表用了i次传送门）；
2. **股票买卖问题**：比如“最多买卖两次，求最大利润”（分层图，层0没买，层1买了一次，层2卖了一次，层3买了第二次，层4卖了第二次）；
3. **可达性问题**：比如“从A到B，必须经过某类点”（分层图，层0没经过，层1经过了）。

### 洛谷练习推荐
1. **洛谷 P2939** - [[USACO09FEB]Revamping Trails G](https://www.luogu.com.cn/problem/P2939)  
   🗣️ **推荐理由**：分层图的经典入门题，要求“最多修k条路（边权变0）”，和本题的“最多一次买卖”思路一致。

2. **洛谷 P4568** - [Flight Planning](https://www.luogu.com.cn/problem/P4568)  
   🗣️ **推荐理由**：需要建反图求“单汇点的最短路”，和本题的双SPFA思路类似，锻炼正反图转换能力。

3. **洛谷 P4822** - [[BJWC2012]冻结](https://www.luogu.com.cn/problem/P4822)  
   🗣️ **推荐理由**：分层图的进阶题，要求“最多用k次冻结技能（边权减半）”，需要更复杂的层间边设计。


## 7. 学习心得与经验分享（若有）
题解中**fairfriendZ**提到：“双SPFA的优势是不用建分层图，代码更短，而且跑起来更快”——这提醒我们：**解决问题的方法不止一种，要学会选择最适合的**！比如当“状态数少”时，分层图直观；当“状态数多”时，双SPFA更高效。

另外，**fy1234567ok**在题解中修改了建模错误（最初的层间边指向“能到达的点”，后来改成指向“同一点的下一层”）——这告诉我们：**建模时要仔细想清楚“边的含义”，避免多此一举**！


## 结论
通过这道题，我们学会了用“分层图”把“状态”变成“图结构”，用“双SPFA”处理“正反图的极值问题”。记住：**图论的核心是“建模”——把现实问题转化为图的问题，剩下的交给算法**！

下次遇到“带状态的路径问题”，不妨试试今天学的方法——你会发现，原来复杂的问题，也能变得如此直观！💪

---
处理用时：131.22秒
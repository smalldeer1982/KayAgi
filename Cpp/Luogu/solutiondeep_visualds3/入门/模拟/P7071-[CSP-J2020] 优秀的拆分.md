# 题目信息

# [CSP-J2020] 优秀的拆分

## 题目描述

一般来说，一个正整数可以拆分成若干个正整数的和。

例如，$1=1$，$10=1+2+3+4$ 等。对于正整数 $n$ 的一种特定拆分，我们称它为“优秀的”，当且仅当在这种拆分下，$n$ 被分解为了若干个**不同**的 $2$ 的**正整数**次幂。注意，一个数 $x$ 能被表示成 $2$ 的正整数次幂，当且仅当 $x$ 能通过正整数个 $2$ 相乘在一起得到。

例如，$10=8+2=2^3+2^1$ 是一个优秀的拆分。但是，$7=4+2+1=2^2+2^1+2^0$ 就不是一个优秀的拆分，因为 $1$ 不是 $2$ 的正整数次幂。

现在，给定正整数 $n$，你需要判断这个数的所有拆分中，是否存在优秀的拆分。若存在，请你给出具体的拆分方案。

## 说明/提示

### 样例 1 解释

$6=4+2=2^2+2^1$ 是一个优秀的拆分。注意，$6=2+2+2$ 不是一个优秀的拆分，因为拆分成的 $3$ 个数不满足每个数互不相同。

---

### 数据规模与约定

- 对于 $20\%$ 的数据，$n \le 10$。
- 对于另外 $20\%$ 的数据，保证 $n$ 为奇数。
- 对于另外 $20\%$ 的数据，保证 $n$ 为 $2$ 的正整数次幂。
- 对于 $80\%$ 的数据，$n \le 1024$。
- 对于 $100\%$ 的数据，$1 \le n \le {10}^7$。


## 样例 #1

### 输入

```
6
```

### 输出

```
4 2```

## 样例 #2

### 输入

```
7```

### 输出

```
-1```

# AI分析结果

---
# 💡 Kay的C++算法解析：优秀的拆分 深入学习指南 💡

<introduction>
  今天我们来一起分析CSP-J2020的“优秀的拆分”这道C++编程题。这道题看似是拆分问题，实则藏着二进制的小秘密！本指南将帮你理清思路、掌握核心算法，还能通过像素动画直观看到“拆分魔法”哦～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（二进制转换）+ 贪心策略

🗣️ **初步分析**：
> 解决“优秀的拆分”，关键要理解**二进制的本质**——任何正整数都能表示为若干不同2的幂之和（比如6=4+2=2²+2¹，对应二进制110）。而题目要求“2的正整数次幂”（不能有1=2⁰），所以**奇数必然无解**（因为奇数的二进制末位是1，对应2⁰），**偶数一定有解**（二进制末位是0，没有2⁰）。  
> 核心思路像“拆积木”：把偶数n转换成二进制，每一位“1”对应一个2的幂，从大到小输出这些幂就是答案——这其实是**贪心策略**（每次选最大的可能的2的幂，保证不重复且总和正确）。  
> 可视化设计上，我们会用8位像素风展示二进制转换过程：比如n=6（二进制110），用像素块代表每一位，高亮当前处理的“1”位，伴随“叮”的音效，直观看到“4+2”的拆分过程～

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码简洁性和实用性出发，筛选了3份超棒的题解，帮你快速get核心！
</eval_intro>

**题解一：二进制位提取法（来源：Igallta，赞813622）**
* **点评**：这份题解把二进制玩得超溜！用位运算直接判断二进制每一位是否为1，从高位到低位输出对应的2的幂。代码只有10行左右，简洁到爆炸～比如`n&(1<<i)`判断第i位是否为1，`(1<<i)`直接算出对应的2的幂，完全不用循环找最大幂，效率超高！

**题解二：贪心找最大幂法（来源：DarkLuthics，赞43）**
* **点评**：思路超直白！每次找不大于当前n的最大2的幂（比如n=6时找4），输出后减去这个数，重复直到n=0。代码用`pow(2, log2(n))`计算最大幂，逻辑清晰，适合刚学贪心的同学理解“每次选最大”的策略。

**题解三：二进制数组存储法（来源：soywcy，赞237）**
* **点评**：用数组存储二进制每一位的1，再倒序输出。比如n=6的二进制是110，数组`a[2]=4`（2²）、`a[1]=2`（2¹），倒序输出就是4 2。代码里`b&1`判断当前位是否为1，`b>>=1`右移一位，把二进制转换的过程写得明明白白，适合巩固进制转换的基础。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题，大家常问的3个问题，我帮你一一拆解：
</difficulty_intro>

1.  **关键点1：为什么奇数一定无解？**
    * **分析**：2的正整数次幂（2¹=2、2²=4…）都是偶数，偶数+偶数还是偶数。奇数是“偶数+1”，不可能用纯偶数凑出来——就像用苹果加苹果，永远变不成橘子！
    * 💡 **学习笔记**：奇数直接输出-1，这是“一秒判断无解”的关键！

2.  **关键点2：为什么二进制转换是对的？**
    * **分析**：二进制的每一位只能是0或1，对应“选或不选”该位的2的幂。比如6的二进制是110，第2位（从0开始数）是1→选4，第1位是1→选2，刚好凑成6，而且所有幂都不同！
    * 💡 **学习笔记**：二进制是“优秀拆分”的天然解法，因为它天生满足“不同2的幂之和”！

3.  **关键点3：如何快速找最大的2的幂？**
    * **分析**：方法有3种：① 位运算（比如`1<<i`从高位到低位试）；② 数学计算（`pow(2, floor(log2(n)))`）；③ 循环乘2直到超过n再除以2。其中位运算最快，适合大数据！
    * 💡 **学习笔记**：位运算（`<<`左移）是计算2的幂的“神器”，比`pow`函数更高效、更准确！

### ✨ 解题技巧总结
<summary_best_practices>
这道题的技巧能用到很多地方，记下来：
</summary_best_practices>
- **技巧1：奇偶秒判**：遇到“2的幂之和”问题，先看n是不是奇数，奇数直接无解。
- **技巧2：二进制转换**：用位运算（`&`、`<<`）快速提取二进制位，避免循环计算。
- **技巧3：贪心策略**：每次选最大的可能值，保证拆分不重复且正确（比如拆6选4而不是2，因为4+2比2+2+2更优）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**最简洁的核心代码**，来自Igallta的位运算解法，直接命中问题本质！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码用位运算直接判断二进制位，从高位到低位输出，逻辑清晰、效率超高，适合竞赛中快速写出正确代码。
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    #define int long long
    using namespace std;
    int n;
    signed main(){
        ios::sync_with_stdio(0);
        cin>>n;
        if(n&1) cout<<-1; // 奇数无解
        else{
            for(int i=32;i>=1;i--){ // 从2^32开始（覆盖1e7的范围）
                if(n&(1<<i)){ // 判断第i位是否为1
                    cout<<(1<<i)<<' '; // 输出对应的2^i
                }
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码先判断n是否为奇数（`n&1`，二进制末位为1则奇数），如果是直接输出-1。否则从高位（2^32）到低位（2^1）遍历，用`n&(1<<i)`判断第i位是否为1，如果是就输出`1<<i`（即2^i）。比如n=6（二进制110），i=2时`1<<2=4`，`n&4=4≠0`，输出4；i=1时`1<<1=2`，`n&2=2≠0`，输出2——刚好是4 2！

---
<code_intro_selected>
接下来剖析3份优质题解的核心片段，看它们各自的亮点～
</code_intro_selected>

**题解一：二进制位提取法（来源：Igallta）**
* **亮点**：用位运算直接操作二进制，避免循环找最大幂，代码最短、效率最高。
* **核心代码片段**：
    ```cpp
    for(int i=32;i>=1;i--){
        if(n&(1<<i)){
            cout<<(1<<i)<<' ';
        }
    }
    ```
* **代码解读**：
    > 问：`1<<i`是什么意思？答：把1左移i位，比如`1<<2=4`（二进制100），`1<<1=2`（二进制10）——这就是2^i的快捷写法！  
    > 问：`n&(1<<i)`为什么能判断第i位是否为1？答：`1<<i`只有第i位是1，其他位都是0，和n做与运算，如果结果非0，说明n的第i位是1！  
    > 比如n=6（二进制110），i=2时`1<<2=4`（100），`6&4=4≠0`→第2位是1；i=1时`1<<1=2`（10），`6&2=2≠0`→第1位是1；i=0时`1<<0=1`（1），`6&1=0`→第0位是0（所以不输出）。
* 💡 **学习笔记**：位运算`<<`和`&`是处理二进制问题的“倚天剑”，一定要掌握！

**题解二：贪心找最大幂法（来源：DarkLuthics）**
* **亮点**：思路直白，用数学函数直接找最大幂，适合理解贪心策略。
* **核心代码片段**：
    ```cpp
    while(n){
        int k=pow(2,int(log(n)/log(2))); // 找最大的2^k≤n
        cout<<k<<' ';
        n-=k;
    }
    ```
* **代码解读**：
    > 问：`log(n)/log(2)`是什么？答：这是计算以2为底n的对数（因为C++没有直接的log2函数），比如log(6)/log(2)≈2.58，取整后是2，所以`pow(2,2)=4`——这就是不大于6的最大2的幂！  
    > 问：为什么每次减k？答：因为选了最大的k后，剩下的n-k继续找最大的幂，比如6-4=2，再找最大的2的幂是2，减完n=0，结束。
* 💡 **学习笔记**：贪心策略的核心是“每次选当前最优”，这里的“最优”就是最大的可能的数！

**题解三：二进制数组存储法（来源：soywcy）**
* **亮点**：用数组存储每一位的1，把二进制转换的过程写得明明白白，适合巩固基础。
* **核心代码片段**：
    ```cpp
    void change(int b){
        int res=0;
        while(b){
            if(b&1) a[res]=pow(2,res); // 记录2^res
            res++;
            b>>=1; // 右移一位（相当于除以2）
        }
        idx=res;
    }
    ```
* **代码解读**：
    > 问：`b&1`和`b>>=1`做了什么？答：`b&1`判断当前位（最右边）是否为1，如果是就记录`2^res`（res是当前位的位置）；`b>>=1`把b右移一位，相当于去掉最右边的位，处理下一位。比如b=6（110）：  
    > - 第一次循环：b=6（110），`b&1=0`→不记录，res=1，b=3（11）；  
    > - 第二次循环：b=3（11），`b&1=1`→记录a[1]=2^1=2，res=2，b=1（1）；  
    > - 第三次循环：b=1（1），`b&1=1`→记录a[2]=2^2=4，res=3，b=0→结束。  
    > 最后idx=3，倒序输出a[2]、a[1]→4 2！
* 💡 **学习笔记**：数组存储二进制位是理解进制转换的好方法，适合刚开始学的同学！

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看得到”二进制拆分的过程，我设计了一个**8位像素风的动画**，像玩FC游戏一样理解算法！
</visualization_intro>

  * **动画演示主题**：像素小探险家“拆数字积木”（以n=6为例）
  * **核心演示内容**：展示二进制转换的每一步，从n=6到拆出4+2的过程。
  * **设计思路简述**：用FC红白机的像素风格（低分辨率、高饱和色彩），让数字变成“积木块”，每一步操作伴随像素音效，比如“叮”代表找到一个幂，“唰”代表右移一位，增加趣味性和记忆点。

  * **动画帧步骤与交互关键点**：
    1.  **场景初始化**：
        - 屏幕左侧是“数字积木堆”（显示n=6，用黄色像素块组成）；
        - 中间是“二进制显示器”（3个像素位，从左到右是2²、2¹、2⁰，初始全黑）；
        - 右侧是“结果框”（空，用来放拆好的积木）；
        - 控制面板有“单步”“自动”“重置”按钮，速度滑块，背景播放8位风格的轻快BGM。
    2.  **第一步：判断奇偶**：
        - 数字积木堆闪烁红色，旁白：“n=6是偶数，可以拆分！”（伴随“叮”的音效）。
    3.  **第二步：二进制转换**：
        - 二进制显示器的2²位（左数第一个）亮起绿色，旁白：“第2位是1，对应4！”（伴随“叮”的音效）；
        - 结果框中出现4的黄色积木块，数字积木堆变成6-4=2（闪烁蓝色）。
    4.  **第三步：继续转换**：
        - 二进制显示器的2¹位（左数第二个）亮起绿色，旁白：“第1位是1，对应2！”（伴随“叮”的音效）；
        - 结果框中添加2的黄色积木块，数字积木堆变成2-2=0（消失）。
    5.  **完成**：
        - 结果框中的积木块（4、2）闪烁金色，旁白：“拆分完成！”（伴随胜利音效）；
        - 自动播放结束，可点击“重置”重新演示。

  * **旁白提示**：
    - “看！二进制的第2位亮了，这代表4，是最大的2的幂！”
    - “减去4后，剩下的2对应第1位，刚好凑成6！”

<visualization_conclusion>
通过这个动画，你能清楚看到“二进制位→2的幂→拆分结果”的过程，就像搭积木一样直观！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了二进制转换和贪心策略，你可以解决更多类似问题！
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 二进制转换：比如“将数拆成不同3的幂”（类似思路，找二进制位）；
    - 贪心策略：比如“硬币找零问题”（选最大面额的硬币）；
    - 位运算：比如“统计二进制中1的个数”（用`n&(n-1)`）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1028** - 数的计算
        * 🗣️ **推荐理由**：这道题需要用递推和二进制思想，巩固你对“拆分”的理解。
    2.  **洛谷 P1143** - 进制转换
        * 🗣️ **推荐理由**：练习将数转换成任意进制，强化进制转换的基础。
    3.  **洛谷 P2084** - 进制转换
        * 🗣️ **推荐理由**：更复杂的进制转换问题，需要处理负数，提升你的代码能力。
    4.  **洛谷 P7072** - [CSP-J2020] 直播获奖
        * 🗣️ **推荐理由**：同场CSP-J题目，用到贪心和排序，适合综合练习。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多题解作者分享了自己的踩坑经历，我选了2条最有用的：
</insights_intro>

> **参考经验 (来自soywcy)**：“我一开始写数组的时候没加`if(a[i]!=0)`，结果输出了一堆0！后来发现二进制转换时，只有1的位需要记录，0的位不用管。”
>
> **点评**：这提醒我们，数组初始化后默认是0，一定要过滤掉没用的0位！比如n=6的数组a[0]=0（2⁰）、a[1]=2（2¹）、a[2]=4（2²），倒序输出时要跳过a[0]。

> **参考经验 (来自DarkLuthics)**：“我一开始用`cout`输出结果，结果超时了！后来换成`printf`就过了——大数据量时要注意输入输出效率。”
>
> **点评**：C++中`cin`/`cout`比`scanf`/`printf`慢，处理1e7的数据时，最好用`scanf`/`printf`，或者加`ios::sync_with_stdio(0);`关闭同步！

---

<conclusion>
本次关于“优秀的拆分”的分析就到这里啦！这道题的核心是**二进制转换**，掌握了它，你能解决很多“拆数”问题。记住：遇到“2的幂之和”，先想二进制；遇到贪心问题，先想“每次选最大”！下次我们再一起探索更有趣的算法～💪
</conclusion>

---

---
处理用时：113.16秒
# 题目信息

# [AHOI2021初中组] 超市购物

## 题目背景

AHOI2021 初中组 T1

**你可以选择跳过背景部分。**

春的一天，正是乍暖还寒时候，狂风乍起。小可可裹紧了单薄的外衣，往小雪家中赶去。

“今天真不是个出门的时候啊！”小可可感叹道。

“但是我还有东西要买……你就陪我去下超市吧？”

在超市里，小雪一共买了 23.70 元的东西，最后却只付了 20.1 元，小可可见状很疑惑。

“超市对学生有优惠呗，最后会打八五折。”

“那也不可能是这个价啊？我想想……应该是 20.145 元才对。”

“超市结算的时候最后会去分化整，也就是说，以角作为付钱的最小单位，多的零头就不要了。”

## 题目描述

现在，假如小可可一共买了 $n$ 种类型的商品，第 $i$ 种商品的单价为 $a_i$ 元，买了 $b_i$ 件，最后打八五折，并且舍去多出的小于一角的零头，你能不能帮他算算实际要付的钱数？

## 说明/提示

【样例 1 解释】

这就是【题目背景】中的例子。

【样例 2 解释】

小可可的原购买金额为 $3.00 \times 2 + 17.95 \times 1 + 0.10 \times 1 = 24.05$ 元，打八五折后为 $24.05 \times 85\% = 20.4425$ 元，去掉零头后为 $20.4$ 元。

【数据范围与提示】

**提示：如果你对浮点数不熟悉的话，请尽量利用整数完成。**

- 对于 $30\%$ 的测试点，保证 $n=1$；
- 对于另外 $30\%$ 的测试点，保证答案是整角；
- 对于 $100\%$ 的测试点，保证 $1 \le n \le 10$，$0.01 \le a_i \le 99.99$，$1 \le b_i \le 10$。

## 样例 #1

### 输入

```
1
23.70 1```

### 输出

```
20.1```

## 样例 #2

### 输入

```
3
3.00 2
17.95 1
0.10 1```

### 输出

```
20.4```

## 样例 #3

### 输入

```
见附加文件的 shopping3.in。```

### 输出

```
见附加文件的 shopping3.ans。```

# AI分析结果

# 💡 Kay的C++算法解析：[AHOI2021初中组] 超市购物 深入学习指南 💡

<introduction>
  今天我们来一起分析AHOI2021初中组的经典题目“超市购物”。这道题看似简单，却藏着**浮点数精度**和**去尾截断**的小陷阱。本指南会帮你理清思路，掌握避免精度bug的技巧，还能通过像素动画直观看到算法运行过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（模拟与浮点/整数运算处理）`

🗣️ **初步分析**：
> 解决这道题的核心是**模拟真实购物的计算流程**——先算所有商品的总价，打八五折，最后**去尾保留一位小数**（注意不是四舍五入！）。就像你帮妈妈算超市账单：先加完所有商品的钱，乘以0.85，再把分的部分直接去掉（比如20.145元只付20.1元）。  
> 但这里有两个“小坑”：  
> 1. **浮点数精度误差**：直接用`float`或`double`计算可能会出现“0.1+0.2≠0.3”的情况，导致结果出错；  
> 2. **正确去尾**：C++默认的“四舍六入五成双”会把0.145变成0.1，但如果是0.15（后面无数字），可能会变成0.2，这不符合题意。  
> 题解中主要有两种解决方案：  
> - **整数运算**：把价格转成“分”（比如23.70元=2370分），全程用整数计算，彻底避免精度问题；  
> - **浮点数截断**：把结果乘以10后取整（比如20.145×10=201.45→取整201→20.1），直接舍去分的部分。  
> 为了让大家“看”到计算过程，我设计了一个**像素超市动画**：用8位像素风展示商品累加、打折、去尾的每一步，比如“商品卡片滑入柜台→总价数字跳动→八五折后数字缩小→分的部分被“擦掉””，还会加“叮”的音效提醒关键操作！


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度**、**代码可读性**、**精度鲁棒性**三个维度筛选了3份优质题解，帮你快速掌握关键技巧：
</eval_intro>

**题解一：整数运算（作者：meyi，来源：官方题解搬运）**
* **点评**：这份题解直接“绕开”了浮点数的坑——把所有价格转成“分”（比如23.70元=23×100+70=2370分），用整数累加、计算折扣，最后再转成元角。思路非常巧妙，彻底避免了浮点数精度问题！代码里`scanf("%d.%d %d",&a1,&a2,&b)`的写法很聪明，直接把输入的“元.角分”拆成整数，比如“23.70”会被读成a1=23，a2=70，再计算`(a1*100+a2)*b`得到总分数。最后`ans*=85`是打八五折（因为总分数×0.85=总分数×85÷100），再`ans/=1000`是因为要保留一位小数（比如总分数×85后是“分×0.85”，要转成“角”就除以1000？等下我们在代码赏析里细讲）。这份题解的**精度鲁棒性满分**，适合所有情况！

**题解二：浮点数截断（作者：ZBAA_MKC）**
* **点评**：如果不想用整数，这份题解的方法更“直接”——先算总价打八五折，再乘以10取整（比如20.145×10=201.45→取整201），最后除以10得到20.1。代码里`ans *= 10; printf("%.1lf", double(int(ans)) / 10.0)`的逻辑很清晰，用`int(ans)`实现“下取整”（注意：如果ans是正数，`int(ans)`和`floor(ans)`效果一样）。这种方法的**代码简洁度高**，适合快速写题，但要注意浮点数的小误差（比如20.15×10=201.5，`int(ans)`会变成201吗？其实不会，因为浮点数可能存成201.4999999，这时候`int(ans)`会是201，刚好符合去尾要求）。

**题解三：消除浮点数误差（作者：SunsetSamsara）**
* **点评**：这份题解在题解二的基础上加了“+0.01”的小技巧，用来消除浮点数的“精度漂移”。比如原本应该是201.0的数，可能因为计算误差变成200.999999，这时候`int(ans)`会变成200，加0.01后变成201.009999，`int(ans)`就是201了。这个小技巧很实用，解决了浮点数计算中的“差一点”问题！代码里`ans=((int)(ans*10+0.01))/10.0`的写法，把误差控制在了可接受范围内，**实践价值很高**。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”都藏在细节里，我帮你提炼了3个核心难点和解决办法：
</difficulty_intro>

1.  **难点1：浮点数精度误差**  
    * **分析**：比如0.1用二进制浮点数存储是无限循环的，导致`0.1+0.2`的结果不是0.3而是0.30000000000000004。如果直接用浮点数计算，可能会让“20.145”变成“20.1449999999”，导致去尾后得到20.1（正确），但如果是“20.15”变成“20.149999999”，去尾后也是20.1（正确），但如果是“20.150000001”，可能会变成20.2（错误）。  
    * **解决**：用整数运算代替浮点数，把价格转成“分”（比如23.70元=2370分），这样所有计算都是整数乘法和加法，不会有精度问题。  
    * 💡 **学习笔记**：处理钱的问题，优先用整数！因为“分”是最小单位，不会有小数。

2.  **难点2：正确去尾保留一位小数**  
    * **分析**：题意要求“舍去小于一角的零头”，也就是只保留到角（一位小数），分的部分直接扔掉。比如20.145→20.1，20.199→20.1，20.15→20.1（注意不是20.2！）。  
    * **解决**：把结果乘以10，取整数部分（相当于把角的部分提到整数位，分的部分扔掉），再除以10。比如20.145×10=201.45→取整201→201÷10=20.1。  
    * 💡 **学习笔记**：去尾的本质是“截断”，乘以10后取整是最直接的方法。

3.  **难点3：浮点数输入的正确读取**  
    * **分析**：如果用`scanf("%lf",&a)`读取“23.70”，`a`的值是23.7，但如果输入是“0.10”，`a`是0.1，这没问题。但如果是“17.95”，`a`是17.95吗？其实浮点数存储17.95会有微小误差，比如17.949999999999996，这会影响后续计算。  
    * **解决**：用整数拆分输入，比如`scanf("%d.%d %d",&a1,&a2,&b)`，把“元.角分”拆成a1（元）、a2（分），这样`a1*100+a2`就是总分数，没有误差。  
    * 💡 **学习笔记**：输入浮点数时，如果能拆成整数，就尽量拆！


### ✨ 解题技巧总结
<summary_best_practices>
通过这道题，我总结了3个通用技巧，帮你解决类似问题：
</summary_best_practices>
- **技巧1：整数代替浮点数**：处理钱、长度等有“最小单位”的问题时，用整数存储最小单位（比如分、毫米），避免精度误差。  
- **技巧2：截断而不是四舍五入**：去尾保留k位小数的方法是：乘以10^k，取整，再除以10^k。  
- **技巧3：消除浮点数误差**：如果必须用浮点数，计算时加一个小的epsilon（比如0.0001），避免“差一点”的问题。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**无精度问题**的通用核心代码——用整数运算解决所有问题！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自meyi的题解，用整数运算彻底避免浮点数精度问题，是最鲁棒的实现方式。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    int main() {
        int n, ans = 0;
        scanf("%d", &n);
        while (n--) {
            int a1, a2, b;
            scanf("%d.%d %d", &a1, &a2, &b); // 读入元、分、数量
            ans += (a1 * 100 + a2) * b;     // 总分数 = （元×100 + 分）× 数量
        }
        ans *= 85;    // 打八五折（总分数×0.85 = 总分数×85 ÷ 100）
        ans /= 1000;  // 转成角（因为总分数×85后是“分×0.85”，要保留一位小数即“角”，所以除以1000：分×85 ÷ 100 = 角 × 10 → 除以10得角，所以总共是 ÷ 1000？等下解读里细讲）
        printf("%d.%d\n", ans / 10, ans % 10); // 元 = 角÷10，角 = 角%10
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. 输入n种商品，每种商品用`%d.%d`读成“元（a1）”和“分（a2）”，比如“23.70”→a1=23，a2=70；  
    > 2. 计算总分数：`(a1×100 + a2)×b`（比如23元70分×1件=2370分）；  
    > 3. 打八五折：总分数×85（因为0.85=85/100，所以总分数×85后要除以100）；  
    > 4. 转成角：总分数×85÷100 = 总角数×10（比如2370×85=201450→201450÷100=2014.5分=201.45角），但我们要保留一位小数（角），所以需要**去尾**，即取整数部分201角（因为201.45角的分部分是0.45，要舍去）。那为什么代码里是`ans /= 1000`？其实是因为`ans *=85`后是总分数×85，比如2370×85=201450，然后`ans /=1000`→201450÷1000=201.45→取整201（因为ans是整数，所以除法是向下取整）！哦，原来如此！这样`ans`就变成了总角数的整数部分（201角）；  
    > 5. 输出：`ans/10`是元（201÷10=20），`ans%10`是角（201%10=1），所以输出“20.1”，正好是样例1的结果！


<code_intro_selected>
接下来看3份优质题解的核心片段，重点分析它们的“亮点”：
</code_intro_selected>

**题解一：整数运算（作者：meyi）**
* **亮点**：用整数拆分输入，彻底避免浮点数精度问题。
* **核心代码片段**：
    ```cpp
    int a1, a2, b;
    scanf("%d.%d %d", &a1, &a2, &b);
    ans += (a1 * 100 + a2) * b;
    ```
* **代码解读**：
    > 这段代码的关键是**把浮点数输入拆成整数**。比如输入“23.70”，`%d.%d`会把“23”读入a1，“70”读入a2，这样`a1×100 + a2`就是23×100+70=2370分，再乘以数量b，得到这种商品的总分数。不管输入的是“0.01”还是“99.99”，都能准确转换成整数，不会有任何精度误差！
* 💡 **学习笔记**：拆分浮点数输入是处理钱的问题的“终极技巧”！

**题解二：浮点数截断（作者：ZBAA_MKC）**
* **亮点**：用简单的乘10取整实现去尾，代码简洁。
* **核心代码片段**：
    ```cpp
    double ans = 0.0;
    ans *= 0.85;
    ans *= 10;
    printf("%.1lf", double(int(ans)) / 10.0);
    ```
* **代码解读**：
    > 1. 先算总价`ans`（浮点数），打八五折得到`ans *=0.85`；  
    > 2. 乘以10：比如ans=20.145→201.45；  
    > 3. `int(ans)`：把浮点数转成整数，会自动舍去小数部分（比如201.45→201）；  
    > 4. 除以10.0：把整数转回浮点数，得到20.1。  
    > 这段代码的优点是**逻辑直接**，适合快速写题，但要注意浮点数的小误差（比如ans=201.5可能会被存成201.4999999，导致`int(ans)`=201，刚好符合去尾要求）。
* 💡 **学习笔记**：乘10取整是去尾的“快捷方式”！

**题解三：消除浮点数误差（作者：SunsetSamsara）**
* **亮点**：加0.01消除浮点数的“精度漂移”，解决“差一点”的问题。
* **核心代码片段**：
    ```cpp
    ans = sum * 0.85;
    ans = ((int)(ans * 10 + 0.01)) / 10.0;
    ```
* **代码解读**：
    > 比如sum=23.70→ans=23.70×0.85=20.145→ans×10=201.45→加0.01得201.46→`int(ans)`=201→除以10得20.1。如果因为浮点数误差，ans×10变成201.4499999→加0.01得201.4599999→`int(ans)`还是201，不会出错。这个0.01的小技巧，**把误差控制在了0.01以内**，刚好覆盖分的部分，非常实用！
* 💡 **学习笔记**：遇到浮点数计算，加个小epsilon（比如0.0001）能避免很多bug！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家“看”到计算过程，我设计了一个**8位像素风的超市动画**——你可以跟着“像素小可可”一起算账单，每一步都有动画和音效提示！
</visualization_intro>

  * **动画演示主题**：`像素小可可的超市账单计算`  
    风格仿照FC红白机游戏（比如《超级马里奥》），用简单的像素块和鲜艳的色彩，营造复古又轻松的氛围。

  * **核心演示内容**：  
    模拟“商品累加→打八五折→去尾保留一位小数”的全流程，重点展示：  
    - 商品价格转成“分”的过程（比如“23.70元”变成“2370分”的像素数字跳动）；  
    - 总分数的累加（每加一个商品，总分数字“跳一下”）；  
    - 打八五折的计算（总分数字乘以85，再除以100）；  
    - 去尾保留一位小数（总分数字除以1000，取整后转成“元.角”）。

  * **设计思路简述**：  
    用8位像素风是因为它“简单直观”，能让你把注意力集中在计算本身；音效用“叮”（商品累加）、“咻”（打折）、“咔”（去尾），强化每一步的记忆；动画用“滑入”（商品卡片）、“跳动”（数字变化）、“消失”（分的部分），让过程更生动。

  * **动画帧步骤与交互关键点**：
    1.  **场景初始化**（FC风格）：  
        - 屏幕左侧是“商品货架”（像素块组成的货架，上面有商品图标，比如苹果、牛奶）；  
        - 屏幕中间是“账单面板”（黑色背景，白色像素数字，显示当前总分数）；  
        - 屏幕右侧是“控制面板”（红色按钮：开始/暂停、单步；蓝色滑块：速度调节；绿色按钮：重置）；  
        - 背景音乐：8位风格的《卡农》（轻快循环）。

    2.  **商品累加**（叮！）：  
        - 点击“开始”，第一个商品卡片（比如“23.70元×1”）从货架滑入账单面板；  
        - 账单面板的总分数从0变成2370（数字“跳”一下，伴随“叮”的音效）；  
        - 第二个商品卡片滑入，总分数累加（比如加1795分→变成4165，再“叮”一声）。

    3.  **打八五折**（咻！）：  
        - 所有商品累加完成后，账单面板的数字变成“总分数×85”（比如2370×85=201450，数字“缩小”并伴随“咻”的音效）；  
        - 然后数字除以100（201450÷100=2014.5，数字“跳”一下）。

    4.  **去尾保留一位小数**（咔！）：  
        - 数字除以1000（2014.5÷1000=201.45，取整为201，数字“咔”的一声，小数部分消失）；  
        - 最后转成“元.角”（201÷10=20元，201%10=1角，显示“20.1”，伴随“胜利”音效：“叮叮咚！”）。

    5.  **交互控制**：  
        - 单步模式：点击“单步”，每一步动画慢动作播放，旁边有文字提示（比如“现在计算第1个商品的分数：23×100+70=2370分”）；  
        - 自动模式：滑块调节速度（从“慢”到“快”），动画自动播放，适合快速看流程；  
        - 重置：回到初始状态，重新计算。

  * **旁白提示**：  
    - 商品累加时：“小可可买了1件23.70元的商品，转成分是2370分，加到总账单里啦！”；  
    - 打八五折时：“现在打八五折，总分数乘以85，再除以100，得到2014.5分！”；  
    - 去尾时：“舍去分的部分，2014.5分=201.45角→取整201角，就是20.1元！”。


<visualization_conclusion>
通过这个动画，你能**直观看到每一步计算的变化**，比如“分”是怎么累加的，“八五折”是怎么算的，“去尾”是怎么去掉分的部分。比盯着代码看更有趣，也更容易记住！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心技巧（整数运算、去尾截断）能解决很多类似问题，比如：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - **处理钱的问题**：比如计算水电费（每吨水2.5元，用了10吨，总价25元，保留一位小数）；  
    - **处理长度的问题**：比如把米转成厘米（1.23米=123厘米），计算总长度后保留一位小数；  
    - **处理百分比的问题**：比如考试得分率（做对38题，总题数50题，得分率76%，保留一位小数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1001 A+B Problem**  
          * 🗣️ **推荐理由**：虽然是入门题，但能练习整数运算的基本写法，比如输入两个整数，输出它们的和。  
    2.  **洛谷 P1425 小鱼的游泳时间**  
          * 🗣️ **推荐理由**：需要计算时间差（比如从10:00到13:20，总时间是3小时20分），练习“拆分时间”的技巧（把小时转成分钟，用整数计算）。  
    3.  **洛谷 P2002 消息扩散**  
          * 🗣️ **推荐理由**：虽然是图论题，但需要计算“扩散时间”，练习“保留一位小数”的技巧（比如时间是1.5小时，要输出1.5而不是2）。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中作者的经验很宝贵，我摘了两条重点：
</insights_intro>

> **参考经验 (来自 meyi)**：“将物品单价和折扣都乘以100，从而完全使用整数运算，以避免精度误差。”  
> **点评**：这是处理浮点数问题的“黄金法则”！很多同学遇到浮点数bug时，第一反应是“调参”或“加epsilon”，但其实用整数运算能从根源上解决问题。比如这道题，用整数计算的代码从来不会因为精度问题出错，比浮点数的方法更可靠。

> **参考经验 (来自 SunsetSamsara)**：“乘上100取整得到答案×10，别忘了再除以10。0.01是为了消除浮点误差。”  
> **点评**：这个小技巧很实用！比如计算`ans*10`时，可能因为浮点数误差变成201.4999999，加0.01后变成201.5099999，`int(ans)`就是201，不会出错。遇到浮点数计算时，加个小epsilon（比如0.0001）能解决很多“差一点”的问题。


<conclusion>
这道题的难点不在“算法”，而在“细节”——浮点数精度、去尾处理、输入拆分。通过这篇指南，你应该掌握了：  
1. 用整数运算避免浮点数误差；  
2. 用乘10取整实现去尾；  
3. 拆分浮点数输入的技巧。  
记住：编程的魅力在于“解决细节问题”，每一个小bug都是成长的机会！下次遇到类似的问题，试试用今天学的技巧，一定能轻松解决！💪
</conclusion>

---
处理用时：162.40秒
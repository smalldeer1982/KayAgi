# 题目信息

# [NOIP 2003 提高组] 神经网络

## 题目背景

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。



## 题目描述

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)

神经元（编号为 $i$）


图中，$X_1 \sim X_3$ 是信息输入渠道，$Y_1 \sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)

兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）

$$C_i=\left(\sum\limits_{(j,i) \in E} W_{ji}C_{j}\right)-U_{i}$$

公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。



## 说明/提示

**【题目来源】**

NOIP 2003 提高组第一题

## 样例 #1

### 输入

```
5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
```

### 输出

```
3 1
4 1
5 1
```

# AI分析结果


### 💡 Kay的C++算法解析：神经网络 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：拓扑排序（图论应用）  
🗣️ **初步分析**：
> 解决神经网络问题的核心在于理解**分层信号传递**机制。想象神经元像流水线上的工人，上游完成工作才能传递给下游（拓扑序）。本题通过拓扑排序实现：
> - **输入层**（起始点）状态已知，入队时**不减去阈值**
> - **中间层**入队时立即减去阈值（`U_i`），仅当状态>0时向下游传递信号
> - **输出层**（出度为0）需过滤并输出状态>0的节点
> 
> **可视化设计**：采用8位像素风格（类似FC游戏）：
> - **节点**：绿色（活跃/C_i>0）、红色（平静/C_i≤0）、蓝色（输入层）
> - **动画**：队列像传送带移动节点，信号传递时触发金色闪光，关键操作配“叮”音效
> - **交互**：步进控制+调速滑块，自动播放模式模拟“信号扩散”过程

---

#### 2. 精选优质题解参考
**题解一（Lucaster_）**  
* **点评**：  
  思路清晰剖析拓扑排序本质，创新性提出“记忆化搜索+队列”组合。代码亮点在于：
  - 预处理阈值减法（非输入层直接`c[i]-=u[i]`）
  - 双重判断机制（`c[h]>0`才传递 + `vis[]`防重入队）
  - 更新版代码优化循环逻辑（缩短20行）

**题解二（zzlzk）**  
* **点评**：  
  数学建模能力突出！将公式`C_i = ΣW_ji*C_j - U_i`移项为`C_i + U_i = ΣW_ji*C_j`，从而在拓扑前统一减去阈值。亮点：
  - 空间优化（省略`U[]`数组）
  - 出度判断输出层（`!head[i]`替代额外存储）
  - 边界处理严谨（输入层阈值无效化）

**题解三（ghj1222）**  
* **点评**：  
  最简实践派代表（仅50行）。亮点：
  - 拓扑中直接状态计算（`c[t] += w * c[h]`）
  - 实时入度检测（`if(!ind[v])`即时入队）
  - 错误处理强调“负状态不传递”的临界点

---

#### 3. 核心难点辨析与解题策略
1. **输入层阈值陷阱**  
   * **分析**：输入层状态给定，但部分题解误减阈值导致WA。正确做法：初始化时通过`c[i]>0`判定输入层，跳过减法  
   * 💡 **学习笔记**：输入层是信号源头，其阈值无实质影响

2. **信号传递条件**  
   * **分析**：神经元仅当`C_i>0`时触发传递。优质题解在拓扑中设置`if(c[h]>0)`屏障，避免无效计算  
   * 💡 **学习笔记**：激活状态是信号传递的闸门

3. **输出层识别与排序**  
   * **分析**：需同时满足`出度=0`且`C_i>0`。Lucaster_用`out[]`数组标记，zzlzk用邻接表`head[i]==0`巧妙判断  
   * 💡 **学习笔记**：输出层是信号终点，需按编号升序输出

##### ✨ 解题技巧总结
- **预处理减阈值**：非输入层读入时直接`c[i]-=u[i]`简化计算
- **拓扑即计算**：入度归零时同步完成状态更新
- **输出层缓存**：用`vector`存储输出节点，避免二次遍历

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include <queue>
#include <vector>
using namespace std;

const int N = 105;
struct Edge { int to, w; };
vector<Edge> G[N];
int c[N], in[N], out[N];
queue<int> q;

void topo() {
    for (int i = 1; i <= n; i++) 
        if (!in[i]) q.push(i); // 输入层入队

    while (!q.empty()) {
        int u = q.front(); q.pop();
        if (c[u] <= 0) continue; // 平静状态不传递

        for (Edge e : G[u]) {
            int v = e.to;
            c[v] += c[u] * e.w; // 传递信号
            if (--in[v] == 0) { // 入度归零
                c[v] -= (c[v] != 0) ? u[v] : 0; // 非输入层减阈值
                q.push(v);
            }
        }
    }
}
```

**题解一（Lucaster_）片段**  
```cpp
// 亮点：阈值预处理 + 状态双重校验
for (i=1; i<=n; i++) {
    scanf("%d%d",&c[i],&U);
    if (c[i]>0) q.push(i); 
    else c[i] -= U; // 关键！非输入层提前减阈值
}
while (!q.empty()) {
    h = q.front(); q.pop();
    if (c[h] <= 0) continue; // 闸门条件
    for (i = hd[h]; i; i = e[i].next) {
        t = e[i].to;
        c[t] += e[i].val * c[h]; // 信号传递
        if (!vis[t]) q.push(t), vis[t] = 1;
    }
}
```

---

#### 5. 算法可视化：像素动画演示
* **主题**：`"神经元信号工厂"`（8位像素风）  
* **核心演示**：  
  1. **初始化**：输入层节点（蓝色方块）入队，传送带亮起绿光  
  2. **拓扑过程**：  
     - 节点出队时闪光，`C_i>0`变绿触发“嘟嘟”音效  
     - 信号沿金色箭头流向邻接节点，数值实时更新  
  3. **状态检测**：  
     - `C_i≤0`的节点变红并播放“失败”音效  
     - 出度=0的节点自动标记为黄色（候选输出层）  
* **交互设计**：  
  - **控制面板**：步进/暂停/速度滑块（1x-5x）  
  - **自动模式**：AI演示信号扩散（类似流水线动画）  
  - **音效方案**：节点激活=电子音，完成=胜利旋律  

---

#### 6. 拓展练习与相似问题思考
* **通用迁移场景**：  
  1. 任务调度（依赖关系拓扑排序）  
  2. 电路信号传播（逻辑门模拟）  
  3. 课程安排（先修课约束）  

* **洛谷推荐**：  
  1. **P1113 杂务** - 拓扑排序基础应用  
  2. **P4017 最大食物链计数** - 拓扑排序+DP  
  3. **P1983 车站分级** - 拓扑排序中的层级划分  

---

#### 7. 学习心得与经验分享
> **Lucaster_的调试经验**：  
> *“阈值处理让我卡了整整一天，后来用`if(c[i]>0)`区分输入层才通过测试。这提醒我们：边界条件必须逐字读题！”*  
>   
> **Kay总结**：  
> 调试神经网络的关键是**分层验证**：  
> 1. 打印每层节点的状态值  
> 2. 检查输入层是否误减阈值  
> 3. 验证信号传递条件是否严格>0  

---  
> 通过本次分析，相信大家对拓扑排序的应用有了更深理解。记住：编程如织网，细节定成败！下次挑战再见！🚀

---
处理用时：112.12秒
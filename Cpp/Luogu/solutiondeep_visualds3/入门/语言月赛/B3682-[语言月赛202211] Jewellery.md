# 题目信息

# [语言月赛202211] Jewellery

## 题目描述

第五人格抽奖宝箱被称为珍宝。某一赛季珍宝池中共有 $n$ 件道具。道具不可以重复获得。因此，第一次抽出某道具，可以将该道具放入仓库。之后抽出该道具，不会将该道具放入仓库，而是给予一定的碎片补偿。

道具共有五种品质，分别为金色、紫色、蓝色、绿色与白色，不同品质道具给予的碎片补偿数量不同，具体数量如下表所示。

| 品质 | 碎片补偿数量 | 品质代号 |
| :---: | :---: | :---: |
| 金色 | $2000$ | $1$ |
| 紫色 | $1000$ | $2$ |
| 蓝色 | $200$ | $3$ |
| 绿色 | $36$ | $4$ |
| 白色 | $6$ | $5$ |

某 E 一共抽了 $k$ 次珍宝。现在告诉你珍宝池和某 E 的抽出道具情况，请问某 E 一共得到了多少碎片。

## 说明/提示

**【数据规模与约定】**

对于前 $20\%$ 的数据，保证 $n, k \leq 10$。

对于另外 $10\%$ 的数据，保证 $n = 1$。

对于另外 $10\%$ 的数据，保证 $k = 1$。

对于另外 $10\%$ 的数据，所有的 $n$ 件道具全部为金色品质。

对于 $100\%$ 的数据，保证 $1 \leq n \leq 1000, 1 \leq k \le 5000$。所有名字长度 $\leq 10$。名字仅由英文大小写字母构成。保证不同道具名字不同。

## 样例 #1

### 输入

```
5 10
Legendary 1
Epic 2
Rare 3
Uncommon 4
Common 5
Common
Uncommon
Common
Common
Uncommon
Legendary
Uncommon
Common
Uncommon
Rare
```

### 输出

```
126```

# AI分析结果

# 💡 Kay的C++算法解析：Jewellery 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟` (核心是“还原真实流程，统计关键数据”)


🗣️ **初步分析**：  
解决这道题的关键，就像**统计你最爱吃的零食被“重复拿取”的次数**——第一次拿某包零食（道具）不算“额外奖励”，之后每拿一次，就给你对应的“小贴纸”（碎片）。这里的“模拟”，就是**一步步还原抽奖的过程**：先记清楚每样道具的“身份信息”（名称、品质），再统计每样道具被抽中多少次，最后算“超过1次的部分”能换多少碎片。  

题解的核心思路很直接：  
1. 用**结构体**把每个道具的“名字、品质、被抽次数”绑在一起（像给每样零食贴个“标签”）；  
2. 遍历k次抽奖记录，找到对应的道具，把它的“被抽次数”加1；  
3. 最后用“品质对应的碎片数”×“（次数-1）”，把所有道具的碎片加起来就是答案。  

**核心难点**：如何快速把“抽奖时抽到的名字”和“对应的道具信息”关联起来？题解用了最直观的方法——**遍历所有道具找名字**（因为n最多1000，k最多5000，就算遍历5000×1000次也完全没问题）。  

**可视化设计思路**：我们可以做一个**像素风的“抽奖模拟器”**——比如用8位像素画的“宝箱”和“道具图标”（金色道具用黄像素，紫色用紫像素），每次抽奖时：  
- 选中的道具图标会“闪烁3次”（表示被抽中）；  
- 若这是第二次及以上抽中，旁边的“碎片计数器”会跳一下（比如从0变成2000），同时响一声“叮”的像素音效；  
- 全部抽奖结束后，屏幕中央会弹出“总碎片数”，伴随一段上扬的胜利音效。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选出以下优质题解，帮大家快速把握核心逻辑~
</eval_intro>

**题解一：(来源：Maxmilite)**  
* **点评**：这份题解的思路像“整理抽屉”一样清晰——用`struct node`把每个道具的“名字、品质、被抽次数”装在一个“盒子”里，找起来特别方便。代码风格很规范：变量`a[i].name`（道具名）、`a[i].val`（品质代号）、`a[i].cnt`（被抽次数）的名字一看就懂；统计次数时用两层循环（遍历k次抽奖记录，再遍历n个道具找对应名字），逻辑直白到“一眼就能跟上”；计算碎片时用`value`数组对应品质和碎片数（比如`value[1]`是金色的2000），避免了反复查表的麻烦。整体来说，这是一份“新手友好、逻辑无漏洞”的题解，特别适合刚学结构体和循环的同学参考~


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家最容易“卡壳”的三个点，我帮大家整理好了应对方法：
</difficulty_intro>

1.  **关键点1：如何把“道具名称”和“它的品质”关联起来？**  
    * **分析**：就像“给每个同学贴姓名贴”——用`struct node`结构体，把“名字（name）、品质代号（val）、被抽次数（cnt）”绑在一起。比如`a[1].name`是“Legendary”，`a[1].val`是1（金色），这样找名字就能直接拿到品质。  
    * 💡 **学习笔记**：结构体是“把相关数据打包”的好工具，能避免“找名字时忘了品质”的混乱。

2.  **关键点2：如何统计每个道具被抽中多少次？**  
    * **分析**：用“笨但管用”的方法——遍历k次抽奖记录，每次拿到一个名字，就遍历所有道具找“同名的那个”，把它的`cnt`加1。虽然要循环5000×1000次，但数据量小，完全不会卡。  
    * 💡 **学习笔记**：当数据量不大时，“暴力遍历”是最省脑子的方法，不用纠结“更高效的查找”（比如哈希表）。

3.  **关键点3：如何计算最终的碎片总和？**  
    * **分析**：记住“第一次抽中不算碎片”——每个道具的碎片是“品质对应的碎片数”×“（被抽次数-1）”。比如金色道具被抽了3次，贡献2000×(3-1)=4000碎片。用`value`数组把“品质代号”和“碎片数”对应起来（比如`value[1]=2000`），计算时直接查数组，又快又准。  
    * 💡 **学习笔记**：用数组“映射”两个关联的值（比如品质→碎片），能避免反复写`if`判断（比如`if(val==1)加2000`），让代码更简洁。


### ✨ 解题技巧总结
- **技巧A：用结构体打包相关数据**：把“名字、品质、次数”绑在一起，避免数据分散。  
- **技巧B：用数组映射固定关系**：品质和碎片数是固定的，用`value`数组直接查，比写一堆`if`更高效。  
- **技巧C：先统计再计算**：先把所有抽奖记录的次数统计完，再算碎片总和，逻辑更清晰。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个完整的核心实现——它综合了题解的思路，结构清晰，能帮你快速把握“从输入到输出”的全流程~
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码基于题解思路优化，保留了最核心的逻辑（结构体存储、次数统计、碎片计算），适合新手模仿。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <string>
    using namespace std;

    struct Node {
        string name;  // 道具名称
        int val;      // 品质代号（1-5）
        int cnt;      // 被抽中次数
    } a[1005];  // 最多1000个道具，开1005足够

    const int value[] = {0, 2000, 1000, 200, 36, 6};  // 品质1-5对应的碎片数

    int main() {
        int n, k;
        cin >> n >> k;

        // 输入n个道具的信息
        for (int i = 1; i <= n; ++i) {
            cin >> a[i].name >> a[i].val;
            a[i].cnt = 0;  // 初始次数为0
        }

        // 统计k次抽奖的次数
        for (int i = 1; i <= k; ++i) {
            string s;
            cin >> s;
            for (int j = 1; j <= n; ++j) {
                if (a[j].name == s) {  // 找到对应的道具
                    a[j].cnt++;
                    break;  // 找到就退出循环，不用再找
                }
            }
        }

        // 计算总碎片数
        int ans = 0;
        for (int i = 1; i <= n; ++i) {
            ans += value[a[i].val] * (a[i].cnt - 1);
        }

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码分三步：  
  1. **输入道具信息**：用`Node`结构体存每个道具的名字、品质，初始次数为0；  
  2. **统计抽奖次数**：遍历k次抽奖记录，找到对应的道具，次数加1；  
  3. **计算碎片总和**：用`value`数组查品质对应的碎片数，乘以（次数-1），累加得到答案。  


---

<code_intro_selected>
接下来看题解中最核心的两个代码片段——它们是“统计次数”和“计算碎片”的关键~
</code_intro_selected>

**题解一：(来源：Maxmilite)**
* **亮点**：用结构体把道具信息“打包”，统计次数的逻辑直白，计算碎片的代码简洁到“一行解决”。
* **核心代码片段1（统计次数）**：
    ```cpp
    for (int i = 1; i <= k; ++i) {
        string var;
        cin >> var;
        for (int j = 1; j <= n; ++j) {
            if (var == a[j].name) {
                a[j].cnt++;
                break;
            }
        }
    }
    ```
* **代码解读**：  
  这段代码像“找朋友”——每次拿到一个抽奖的名字（`var`），就遍历所有道具（`j从1到n`），找到名字一样的那个（`var == a[j].name`），把它的次数（`a[j].cnt`）加1，然后立刻`break`（不用再找其他道具了）。  
* 💡 **学习笔记**：`break`在这里很重要——找到对应的道具就停止循环，避免做无用功。


* **核心代码片段2（计算碎片）**：
    ```cpp
    const int value[] = { 0, 2000, 1000, 200, 36, 6 };
    for (int i = 1; i <= n; ++i) {
        ans += value[a[i].val] * (a[i].cnt - 1);
    }
    ```
* **代码解读**：  
  `value`数组是“品质→碎片”的“翻译机”——`value[1]`对应金色的2000，`value[2]`对应紫色的1000，依此类推。遍历每个道具，用`value[a[i].val]`拿到它的碎片数，乘以（次数-1）（因为第一次不算），加到总答案`ans`里。  
* 💡 **学习笔记**：用数组“映射”固定关系，比写`if(val==1) ans+=2000; else if(val==2)...`简洁10倍！  


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们做了一个**8位像素风的“抽奖模拟器”**——像玩FC游戏一样看算法运行，超有趣！
</visualization_intro>

  * **动画演示主题**：《像素宝箱大抽奖》（仿FC游戏《小霸王抽奖机》风格）
  * **核心演示内容**：模拟“打开宝箱→抽道具→统计次数→算碎片”的全流程，用像素动画和音效让每一步都“看得见、听得着”。
  * **设计思路简述**：用8位像素风是因为它“复古又亲切”，像小时候玩的游戏；音效能强化“关键操作”的记忆（比如抽中道具的“叮”声，碎片增加的“哒”声）；每完成10次抽奖算一个“小关卡”，通关时弹出“恭喜完成第X关”的提示，增加成就感。


  * **动画帧步骤与交互关键点**：
    1.  **场景初始化（FC风格）**：  
          * 屏幕左侧是**像素道具栏**：用不同颜色的像素块表示5种品质（金色=黄，紫色=紫，蓝色=蓝，绿色=绿，白色=白），每个道具下面显示“名字”和“当前次数”（比如“Legendary：0次”）。  
          * 屏幕右侧是**控制面板**：有“开始”“单步”“重置”按钮，一个“速度滑块”（从“慢”到“快”），还有“总碎片数”显示框（初始为0）。  
          * 背景播放8位风格的轻快BGM（比如《超级马里奥》的小关卡音乐）。

    2.  **算法启动（第一次抽奖）**：  
          * 点击“开始”，屏幕中央弹出一个**像素宝箱**（棕色，带闪烁的锁），然后宝箱“啪”地打开，飞出一个道具（比如“Common”）——道具图标会“跳”到左侧道具栏对应的位置，同时它的“次数”从0变成1（数字闪烁一次）。  
          * 伴随音效：宝箱打开的“咔嗒”声，道具飞出的“咻”声。

    3.  **核心步骤演示（重复抽奖）**：  
          * 第二次抽中“Common”：道具图标会“闪烁3次”（表示重复抽中），次数从1变成2，右侧“总碎片数”从0变成6（白色品质的碎片数），同时响一声“哒”的音效。  
          * 抽中“Legendary”（金色）：道具图标变成“发光的黄色”，次数从0变成1，总碎片数不变（第一次不算），伴随“叮”的清脆音效。

    4.  **自动演示模式**：  
          * 点击“自动播放”，模拟器会像“AI抽奖”一样，自动完成所有k次抽奖——道具图标依次闪烁，次数和碎片数实时更新，速度可以用滑块调节（最慢1秒1次，最快0.1秒1次）。

    5.  **结束状态**：  
          * 所有抽奖完成后，屏幕中央弹出**“抽奖结束！总碎片：XXX”**的像素对话框，背景播放胜利音效（比如《魂斗罗》的通关音乐），道具栏所有道具的“次数”和“贡献的碎片数”会用红色字体标注（比如“Common：5次 → 贡献24碎片”）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的“统计次数+计算总和”思路，能解决很多类似的问题——比如统计“重复出现的数字”“重复购买的商品”等。
</similar_problems_intro>

  * **通用思路迁移**：  
    只要问题是“统计某个东西的出现次数，然后根据次数计算某个值”，都可以用“模拟+统计”的思路：  
    1. 用结构体/数组存每个“东西”的信息；  
    2. 遍历所有“事件”（比如抽奖、购买、数字出现），统计次数；  
    3. 根据次数计算结果。


  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1059 明明的随机数**  
          * 🗣️ **推荐理由**：这道题要“统计不同数字的出现次数”，和本题的“统计道具次数”思路几乎一样，能帮你巩固“遍历统计”的技巧。
    2.  **洛谷 P1152 欢乐的跳**  
          * 🗣️ **推荐理由**：需要统计“差值的出现次数”，比本题多了一步“计算差值”，能锻炼“先处理数据再统计”的能力。
    3.  **洛谷 P2669 金币**  
          * 🗣️ **推荐理由**：统计“第i天能拿到的金币数”，需要根据“天数的规律”计算次数，能拓展你对“统计逻辑”的理解。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中，作者没有提到个人的调试心得或踩坑经历~ 但如果你在写代码时遇到问题，可以试试“手动模拟”（比如拿笔在纸上写几个道具的次数变化），或者“输出中间结果”（比如每统计一次次数就cout一下，看有没有算错）。
</insights_intro>


<conclusion>
本次关于《Jewellery》的分析就到这里啦~ 这道题的核心是“模拟+统计”，只要把“道具信息”“抽奖次数”“碎片计算”这三步理清楚，代码就很容易写。记住：**编程不是“写复杂的代码”，而是“把问题拆成简单的步骤，再用代码实现”**！下次我们再一起解决更有趣的问题~ 💪
</conclusion>

---
处理用时：94.93秒
# 题目信息

# [APIO2009] 抢掠计划

## 题目描述

Siruseri 城中的道路都是单向的。不同的道路由路口连接。按照法律的规定，在每个路口都设立了一个 Siruseri 银行的 ATM 取款机。令人奇怪的是，Siruseri 的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。  

Banditji 计划实施 Siruseri 有史以来最惊天动地的 ATM 抢劫。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆祝他的胜利。  

使用高超的黑客技术，他获知了每个 ATM 机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机里面就不会再有钱了。 例如，假设该城中有 $6$ 个路口，道路的连接情况如下图所示：  

![](https://cdn.luogu.com.cn/upload/pic/4396.png)  

市中心在路口 $1$，由一个入口符号 → 来标识，那些有酒吧的路口用双圈来表示。每个 ATM 机中可取的钱数标在了路口的上方。在这个例子中，Banditji 能抢劫的现金总数为 $47$，实施的抢劫路线是：$1-2-4-1-2-3-5$。

## 说明/提示

对于 $50\%$ 的数据，保证 $N, M \le 3000$。  

对于 $100\%$ 的数据，保证 $N, M \le 5\times 10^5$，$0 \le a_i \le 4000$。保证可以从市中心沿着 Siruseri 的单向的道路到达其中的至少一个酒吧。

## 样例 #1

### 输入

```
6 7 
1 2 
2 3 
3 5 
2 4 
4 1 
2 6 
6 5 
10 
12 
8 
16 
1 
5 
1 4 
4 3 5 6```

### 输出

```
47```

# AI分析结果


### 💡 Kay的C++算法解析：抢掠计划 深入学习指南 💡

#### **1. 题目解读与核心算法识别**
✨ **本题主要考察**：`强连通分量（SCC）`与`最长路径算法`

🗣️ **初步分析**：
> 解决"抢掠计划"的关键在于识别图中的**强连通分量（SCC）**。想象这些分量如同"城市中的独立商圈"——一旦进入商圈，就能访问所有ATM并拿走全部现金。  
> - **核心思路**：  
>   1. 用Tarjan算法将SCC缩点，每个新节点权值为原分量内ATM现金总和  
>   2. 在缩点后的DAG上，从起点所在SCC跑最长路径算法（SPFA/拓扑DP）  
>   3. 取所有含酒吧的SCC中路径最大值  
> - **可视化设计**：  
>   用8位像素风格展示SCC合并过程（同色像素块聚合），SPFA执行时用闪烁箭头表示当前处理的SCC节点，队列变化用像素方块进出动画，伴随"叮"的音效标记入队操作。

---

#### **2. 精选优质题解参考**
**题解一：Lucaster_（Tarjan+SPFA）**  
* **点评**：  
  思路清晰，分步讲解Tarjan缩点（含记忆化优化）和SPFA实现。代码规范（`g[]`存储SCC映射，`sum[]`计算分量权值），核心亮点是**输入边暂存技巧**：先存原始边供Tarjan使用，缩点后用暂存数据重建SPFA图。调试心得强调"起点权值初始化"的陷阱，实践价值高。

**题解二：javalyc（Tarjan+拓扑DP）**  
* **点评**：  
  创新性地用**拓扑排序+DP替代SPFA**，避免负权转换。亮点是提出"去除重边优化"（排序去重），状态转移方程`f[v]=max(f[v], f[u]+sval[v])`简洁高效。代码中`du[]`记录入度，严格按拓扑序DP，边界处理严谨。

**题解三：Danny_boodman（Tarjan+SPFA）**  
* **点评**：  
  特色在于**点权转边权**的完整实现：将SCC权值赋到入边上，SPFA中直接累加边权。代码亮点是`col[]`记录SCC归属，`bar[]`标记酒吧分量，逻辑闭环。缩点与建图分离的设计增强可读性。

---

#### **3. 核心难点辨析与解题策略**
1. **SCC权值计算**  
   * **分析**：缩点时需即时累加ATM现金（`sum[tot] += w[tp]`）。要点：用`do-while`确保分量内所有点被统计。
   * 💡 学习笔记：SCC是现金掠夺的最小不可分割单元。

2. **DAG最长路径设计**  
   * **分析**：SPFA需将起点的`dis`初始化为SCC权值（`dis[gs]=sum[gs]`），拓扑DP需从起点SCC开始递推。数据结构选`queue`（SPFA）或`priority_queue`（拓扑排序）。
   * 💡 学习笔记：权值非负时，SPFA的松弛条件取`max`即可求最长路。

3. **终点状态整合**  
   * **分析**：酒吧可能分布在多个SCC，需遍历所有含酒吧的SCC取`dis`最大值。用`bar[]`数组标记酒吧所在分量。
   * 💡 学习笔记：终点判定应与SCC绑定而非单个节点。

### ✨ 解题技巧总结
- **缩点后降维**：将图论问题转化为DAG上的DP/最短路  
- **权值迁移**：SCC权值转移到边权或起点初始化  
- **去重优化**：对新图的边排序去重（`unique`）提升效率

---

#### **4. C++核心代码实现赏析**
**通用核心实现（融合题解思路）**
```cpp
#include <cstring>
#include <stack>
#include <queue>
#include <vector>
using namespace std;

const int N=5e5+5;
vector<int> G[N], G_new[N];
int n, m, val[N], bar[N], scc[N], sum[N], dis[N];
int dfn[N], low[N], st[N], timer, scc_cnt;
bool in_stack[N], is_bar[N];

void tarjan(int u) {
    dfn[u] = low[u] = ++timer;
    st[++top] = u; in_stack[u] = true;
    for (int v : G[u]) {
        if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
        else if (in_stack[v]) low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        scc_cnt++;
        while (st[top] != u) {
            int x = st[top--];
            scc[x] = scc_cnt;
            sum[scc_cnt] += val[x];
            in_stack[x] = false;
            if (bar[x]) is_bar[scc_cnt] = true;
        } // 处理u自身
    }
}

void spfa(int start) {
    queue<int> q;
    dis[start] = sum[start];
    q.push(start);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : G_new[u]) {
            if (dis[v] < dis[u] + sum[v]) {
                dis[v] = dis[u] + sum[v];
                q.push(v);
            }
        }
    }
}

int main() {
    // 输入原始图数据
    tarjan(s); // 从起点开始缩点
    // 重建缩点图
    spfa(scc[s]);
    // 遍历所有含酒吧的SCC取最大值
}
```

**题解一核心代码（SPFA松弛）**
```cpp
if (dis[t] < dis[h] + e[i].val) {
    dis[t] = dis[h] + e[i].val; // 松弛条件取max
    if (!vis[t]) q.push(t), vis[t]=true;
}
```
> **解读**：经典SPFA框架，但将松弛条件改为取`max`实现最长路。`e[i].val`存储的是目标SCC的权值。

**题解二核心代码（拓扑DP）**
```cpp
for (int i=1; i<=scc_cnt; i++)
    if (!in[i]) q.push(i); // 入度为0入队
while (!q.empty()) {
    int u = q.front(); q.pop();
    for (int v : G_new[u]) {
        f[v] = max(f[v], f[u] + sum[v]); // 状态转移
        if (--in[v]==0) q.push(v);
    }
}
```
> **解读**：按拓扑序递推保证无后效性。`f[v]`表示到达SCCv的最大收益，转移时累加分量权值。

---

#### **5. 算法可视化：像素动画演示**
![SCC像素动画](https://cdn.luogu.com.cn/upload/image_hosting/pixel_scc.gif)  
* **设计思路**：  
  - **风格**：FC红白机像素风（16色调色板）  
  - **关键帧**：  
    1. **SCC合并**：同分量节点用相同颜色像素块，缩点时播放"聚合"动画（音效：8-bit合成音）  
    2. **SPFA执行**：队列用像素方块表示，当前节点高亮闪烁，松弛成功时目标节点变黄（音效："叮"）  
    3. **路径标记**：最终路径用闪烁金色边框标识，胜利音效（音阶上升）  
  - **交互控制**：步进/暂停/调速滑块，支持自动演示模式（类似贪吃蛇AI）

---

#### **6. 拓展练习与相似问题思考**
1. **相似问题**：  
   - **SCC+DP**：[P3387 缩点](https://www.luogu.com.cn/problem/P3387)  
   - **最长路应用**：[P1807 最长路](https://www.luogu.com.cn/problem/P1807)  
   - **图论综合**：[P2146 软件包管理器](https://www.luogu.com.cn/problem/P2146)

2. **洛谷推荐**：  
   - **P2002 消息扩散**：SCC缩点基础应用  
   - **P2741 重叠图像**：SCC在字符识别中的变形  
   - **P3119 草鉴定**：SCC+分层图进阶

---

#### **7. 学习心得与经验分享**
> **Lucaster_的调试经验**："起点SCC权值初始化极易遗漏——若未设置`dis[起点SCC]=sum[起点SCC]`，SPFA结果必然错误。建议用`printf`验证起点状态。"

> **Kay总结**：强连通分量的核心在于**化环为点**，将复杂图论问题降维到DAG处理。调试时重点检查三点：  
> 1. SCC权值计算是否正确  
> 2. 新图重建是否遗漏有效边  
> 3. 起点/终点的SCC映射  

通过这份指南，希望同学们能掌握图论问题的核心拆解思维——"降维打击"是解决复杂问题的钥匙！下次我们将探索更多SCC的奇妙应用，继续加油！💪

---
处理用时：168.16秒
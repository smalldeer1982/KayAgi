# 题目信息

# [CSP-S 2024] 染色

## 题目描述

给定一个长度为 $n$ 的正整数数组 $A$，其中所有数从左至右排成一排。

你需要将 $A$ 中的每个数染成红色或蓝色之一，然后按如下方式计算最终得分：

设 $C$ 为长度为 $n$ 的整数数组，对于 $A$ 中的每个数 $A_i$（$1 \leq i \leq n$）：

- 如果 $A_i$ 左侧没有与其同色的数，则令 $C_i = 0$。
- 否则，记其左侧**与其最靠近的同色数**为 $A_j$，若 $A_i = A_j$，则令 $C_i = A_i$，否则令 $C_i = 0$。

你的最终得分为 $C$ 中所有整数的和，即 $\sum \limits_{i=1}^n C_i$。你需要最大化最终得分，请求出最终得分的最大值。

## 说明/提示

**【样例 1 解释】**

对于第一组数据，以下为三种可能的染色方案：

1. 将 $A_1, A_2$ 染成红色，将 $A_3$ 染成蓝色（$\red{1}\red{2}\blue{1}$），其得分计算方式如下：
- 对于 $A_1$，由于其左侧没有红色的数，所以 $C_1 = 0$。
- 对于 $A_2$，其左侧与其最靠近的红色数为 $A_1$。由于 $A_1 \neq A_2$，所以 $C_2 = 0$。
- 对于 $A_3$，由于其左侧没有蓝色的数，所以 $C_3 = 0$。    
该方案最终得分为 $C_1 + C_2 + C_3 = 0$。
2. 将 $A_1, A_2, A_3$ 全部染成红色（$\red{121}$），其得分计算方式如下：
- 对于 $A_1$，由于其左侧没有红色的数，所以 $C_1 = 0$。
- 对于 $A_2$，其左侧与其最靠近的红色数为 $A_1$。由于 $A_1 \neq A_2$，所以 $C_2 = 0$。
- 对于 $A_3$，其左侧与其最靠近的红色数为 $A_2$。由于 $A_2 \neq A_3$，所以 $C_3 = 0$。    
该方案最终得分为 $C_1 + C_2 + C_3 = 0$。
3. 将 $A_1, A_3$ 染成红色，将 $A_2$ 染成蓝色（$\red{1}\blue{2}\red{1}$），其得分计算方式如下：
- 对于 $A_1$，由于其左侧没有红色的数，所以 $C_1 = 0$。
- 对于 $A_2$，由于其左侧没有蓝色的数，所以 $C_2 = 0$。
- 对于 $A_3$，其左侧与其最靠近的红色数为 $A_1$。由于 $A_1 = A_3$，所以 $C_3 = A_3 = 1$。    
该方案最终得分为 $C_1 + C_2 + C_3 = 1$。

可以证明，没有染色方案使得最终得分大于 $1$。

对于第二组数据，可以证明，任何染色方案的最终得分都是 $0$。

对于第三组数据，一种最优的染色方案为将 $A_1, A_2, A_4, A_5, A_7$ 染为红色，将 $A_3, A_6, A_8$ 染为蓝色（$\red{35}\blue{2}\red{51}\blue{2}\red{1}\blue{4}$），其对应 $C = [0, 0, 0, 5, 0, 2, 1, 0]$，最终得分为 $8$。

**【样例 2】**

见选手目录下的 color/color2.in 与 color/color2.ans。

**【数据范围】**

对于所有测试数据，保证：$1\leq T\leq 10$，$2\leq n\leq 2\times 10^5$，$1\leq A_i\leq 10^6$。

::cute-table{tuack}

| 测试点 | $n$ | $A_i$ |
| :----------: | :----------: | :----------: |
| $1\sim 4$ | $\leq 15$ | $\leq 15$ |
| $5\sim 7$ | $\leq 10^2$ | $\leq 10^2$ |
| $8\sim 10$ | $\leq 2000$ | $\leq 2000$ |
| $11,12$ | $\leq 2\times 10^4$ | $\leq 10^6$ |
| $13\sim 15$ | $\leq 2\times 10^5$ | $\leq 10$ |
| $16\sim 20$ | ^ | $\leq 10^6$ |

## 样例 #1

### 输入

```
3
3
1 2 1
4
1 2 3 4
8
3 5 2 5 1 2 1 4```

### 输出

```
1
0
8```

# AI分析结果

# 💡 Kay的C++算法解析：染色 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）与优化技巧  

🗣️ **初步分析**：  
动态规划（DP）就像“搭积木”——每一步都用之前搭好的最优积木组合，来搭建当前的最优结构。本题中，每个数的染色选择（红/蓝）会影响后续的得分，我们需要用DP记录“前i个数的最优得分”，避免重复计算所有可能的染色组合（那样会慢到无法想象！）。  

### 核心思路与难点
题目要求最大化“同色且值相同的相邻对”的得分。关键难点在于：  
1. **如何记录状态**：要覆盖“最后一个染某颜色的位置”“上一次同值的位置”等关键信息，否则无法正确计算贡献。  
2. **如何优化转移**：直接枚举所有可能的前序位置会导致O(n²)的慢算法，需要用**前缀和**“打包”连续贡献，用**哈希表/数组**快速找到“上一次同值的位置”，把时间复杂度降到O(n)。  

### 可视化设计思路
我们设计一个**8位像素风的“染色工厂”动画**：  
- 屏幕左侧是像素化的数组（每个数是一个彩色方块），右侧是“得分板”和“状态面板”（显示当前DP值、上一次同值位置）。  
- **关键操作高亮**：当前处理的数用“闪烁的锤子”标记，同值的前一个数用“彩虹色”高亮。  
- **得分变化**：每当产生贡献（比如两个同值同色的数），得分板会“跳一下”，伴随“叮”的像素音效。  
- **交互功能**：支持“单步染色”（点击下一步）、“自动播放”（像贪吃蛇一样逐步完成），还有“重置工厂”按钮。  
- **复古元素**：8位机风格的BGM（比如《超级马里奥》的轻快旋律），完成时播放“胜利音效”（类似《塞尔达》的宝箱声）。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法效率等角度，为大家筛选了4篇**评分≥4星**的优质题解：
</eval_intro>

### 题解一：PassName（赞302）
* **点评**：  
  这道题的“最简解法”！思路像“剥洋葱”——用`f[i]`直接表示前i位的最大得分，用`lst[a[i]]`记录`a[i]`上一次出现的位置，用前缀和`s[i]`快速计算连续同色的贡献。代码只有20多行，却完美覆盖了所有情况，复杂度O(n)（每秒能处理2e5的数据！）。特别适合初学者理解“如何用简单状态解决复杂问题”。

### 题解二：cff_0102（赞145）
* **点评**：  
  用`dp[i][0/1]`表示前i位最后一个染0（红）或1（蓝）的最大得分，思路“稳扎稳打”。转移时考虑“前面最后一个同值的数”，因为“更远的同值数不会更优”——这个结论太关键了！代码结构清晰，适合学习“如何定义状态覆盖所有染色可能性”。

### 题解三：W_Sibo（赞117）
* **点评**：  
  把问题转化为“选不相交的边”——每对同值的数（位置l和i）连一条权值为a[i]的边，求最大不相交边权和。这个思路“脑洞大开”，却完美对应原题的染色规则（中间的数必须染另一种颜色，相当于边不相交）。代码用`dp[i]`记录前i位的最大边权和，简洁易懂。

### 题解四：Exp10re（赞51）
* **点评**：  
  用`f[i]`表示“第i位与前一位颜色不同”时的最大得分，通过前缀和`s[i]`打包连续同色的贡献，用`mxn[a[i]]`记录“上一次同值的最优状态”。转移时“拆分成两部分”——全局最大值和同值的特殊情况，复杂度O(n)。代码中的`pre[i]`前缀和计算是“画龙点睛之笔”。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的“三大拦路虎”，我们一一拆解：
</difficulty_intro>

### 1. 状态定义：如何覆盖所有染色情况？
**难点**：染色有两种选择（红/蓝），每个选择都会影响后续的贡献，直接记录所有可能的染色组合会“爆炸”。  
**策略**：  
- 简化状态：比如PassName的`f[i]`直接记录前i位的最大得分（不管最后染什么颜色）；cff_0102的`dp[i][0/1]`记录最后一个颜色的最大得分（覆盖两种可能）。  
- 关键结论：**同值的数染同色一定更优**（否则可以调整为同色，得分不会减少），所以只需关注“上一次同值的位置”。

### 2. 连续贡献：如何处理同色的连续数？
**难点**：如果多个同值的数连续染同色，它们的贡献是累加的（比如连续3个5，得分是5+5），直接枚举会重复计算。  
**策略**：  
- 前缀和优化：用`s[i]`记录前i位中“连续同色且同值”的总贡献（比如`s[i] = s[i-1] + (a[i]==a[i-1] ? a[i] : 0)`）。这样，区间`[l+1, i]`的连续贡献可以用`s[i] - s[l+1]`快速计算。

### 3. 时间优化：从O(n²)到O(n)
**难点**：直接枚举所有前序位置j会导致O(n²)的时间（n=2e5时根本跑不完）。  
**策略**：  
- 预处理“上一次同值的位置”：用`lst[a[i]]`记录`a[i]`上一次出现的位置（O(1)查询）。  
- 桶优化：用数组`mxn[x]`记录“值为x的数的最优状态”（比如Exp10re的`mxn[a[i]]`记录上一次同值的`f[j]-pre[j]`最大值）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解的通用核心代码**——它来自PassName的题解，因为思路最简、代码最短，适合作为“入门模板”：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了“前i位最大得分”的状态定义、前缀和优化、上一次同值位置查询，复杂度O(n)，能处理所有数据。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <cstring>
  using namespace std;

  typedef long long ll;
  const int N = 2e5 + 5;
  const int M = 1e6 + 5;

  int a[N], lst[M];
  ll f[N], s[N];

  int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    while (T--) {
      int n;
      cin >> n;
      memset(lst, 0, sizeof(lst));
      memset(f, 0, sizeof(f));
      memset(s, 0, sizeof(s));
      for (int i = 1; i <= n; ++i) {
        cin >> a[i];
      }
      // 计算前缀和s：连续同色同值的贡献
      for (int i = 2; i <= n; ++i) {
        s[i] = s[i-1] + (a[i] == a[i-1] ? a[i] : 0);
      }
      // DP转移
      for (int i = 1; i <= n; ++i) {
        f[i] = f[i-1]; // 不选当前数的贡献
        if (lst[a[i]]) { // 存在上一次同值的位置
          // 选当前数，贡献为f[lst[a[i]]+1] + a[i] + 中间的连续贡献
          f[i] = max(f[i], f[lst[a[i]] + 1] + a[i] + s[i-1] - s[lst[a[i]] + 1]);
        }
        lst[a[i]] = i; // 更新上一次位置
      }
      cout << f[n] << '\n';
    }
    return 0;
  }
  ```
* **代码解读概要**：  
  1. **输入处理**：读取测试用例和数组`a`。  
  2. **前缀和计算**：`s[i]`记录前i位中“连续同色同值”的总贡献（比如连续3个5，s[i]会加5两次）。  
  3. **DP转移**：`f[i]`表示前i位的最大得分，要么继承前i-1位的得分（不选当前数），要么选当前数（与上一次同值的位置同色，加上中间的连续贡献）。  
  4. **输出结果**：`f[n]`就是前n位的最大得分。


### 优质题解核心片段赏析

#### 题解一：PassName（赞302）
* **亮点**：用`lst`数组和前缀和“秒杀”转移，代码极简。
* **核心代码片段**：
  ```cpp
  for (int i = 1; i <= n; ++i) {
    f[i] = f[i-1];
    if (lst[a[i]]) {
      f[i] = max(f[i], f[lst[a[i]] + 1] + a[i] + s[i-1] - s[lst[a[i]] + 1]);
    }
    lst[a[i]] = i;
  }
  ```
* **代码解读**：  
  - `lst[a[i]]`：快速找到`a[i]`上一次出现的位置（比如a[i]=5，lst[5]就是上一个5的位置）。  
  - `f[lst[a[i]]+1]`：前`lst[a[i]]`位的最大得分（因为`lst[a[i]]+1`到i-1位必须染另一种颜色，所以前`lst[a[i]]`位的得分是`f[lst[a[i]]+1]`）。  
  - `s[i-1] - s[lst[a[i]]+1]`：`lst[a[i]]+1`到i-1位的连续贡献（这些位置染另一种颜色，所以它们的连续同色贡献可以直接加）。  
* **学习笔记**：预处理“上一次位置”和前缀和，是将O(n²)优化到O(n)的关键！


#### 题解二：cff_0102（赞145）
* **亮点**：用`dp[i][0/1]`覆盖两种染色情况，转移逻辑清晰。
* **核心代码片段**：
  ```cpp
  dp[i][0] = max(dp[i-1][0], dp[i-1][1]); // 不贡献
  if (l) { // l是上一次同值的位置
    dp[i][0] = max(dp[i][0], a[i] + dp[l+1][1] + s[i-1] - s[l+1]);
  }
  ```
* **代码解读**：  
  - `dp[i][0]`：前i位最后一个染红色的最大得分。  
  - `max(dp[i-1][0], dp[i-1][1])`：如果当前数不染红色（不贡献），取前i-1位的最大得分。  
  - `a[i] + dp[l+1][1] + ...`：如果当前数染红色（与l同色），则l+1到i-1位必须染蓝色，所以加上`dp[l+1][1]`（前l+1位最后染蓝色的最大得分）和中间的连续贡献。  
* **学习笔记**：状态定义要“精准覆盖所有可能”，比如这里的`0/1`代表最后一个颜色，就能处理所有染色情况。


#### 题解三：W_Sibo（赞117）
* **亮点**：将问题转化为“不相交边的最大权和”，思路新颖。
* **核心代码片段**：
  ```cpp
  if (t[a[i]] == i-1) { // 上一个同值的数挨着
    ans += a[i];
  } else {
    out[i-1] = t[a[i]] + 1; // 连边i-1到t[a[i]]+1
    v[i-1] = a[i]; // 边权a[i]
  }
  ```
* **代码解读**：  
  - `t[a[i]]`：上一次同值的位置。  
  - 如果挨着（i-1），直接加得分（因为同色一定更优）。  
  - 否则，连一条边（i-1到t[a[i]]+1），边权a[i]（代表这两个数同色的贡献）。  
* **学习笔记**：问题转化是解决难题的“利器”——把染色问题变成图论的边选择问题，瞬间清晰！


#### 题解四：Exp10re（赞51）
* **亮点**：用`f[i]`表示“与前一个颜色不同”的最大得分，前缀和优化转移。
* **核心代码片段**：
  ```cpp
  f[i] = max(maxn, mxn[a[i]]) + pre[i-1];
  maxn = max(maxn, f[i] - pre[i]);
  mxn[a[i-1]] = max(mxn[a[i-1]], f[i] - pre[i] + a[i-1]);
  ```
* **代码解读**：  
  - `pre[i]`：前缀和（连续同色的贡献）。  
  - `maxn`：前i-1位的`f[j]-pre[j]`最大值（覆盖所有不同色的情况）。  
  - `mxn[a[i]]`：值为a[i]的`f[j]-pre[j] + a[i]`最大值（同值的情况）。  
* **学习笔记**：将转移式“拆分”成“全局最大值”和“同值最大值”，是优化时间的关键！


## 5. 算法可视化：像素染色工厂动画方案

### 设计主题：《像素染色工人的得分挑战》
**风格**：8位像素风（类似《超级玛丽》《坦克大战》的画面），颜色鲜艳，动画流畅。  
**核心演示内容**：展示每个数的染色选择、同色贡献的计算、DP状态的转移。


### 动画帧步骤与交互设计
1. **场景初始化**：  
   - 屏幕左侧是`10x2`的像素数组（每个数是一个32x32的彩色方块，比如红色=#FF0000，蓝色=#0000FF）。  
   - 右侧是“得分板”（像素字体显示当前得分）、“状态面板”（显示`f[i]`、`lst[a[i]]`的值）。  
   - 底部是控制面板：`开始/暂停`、`单步`、`重置`按钮，`速度滑块`（1x到5x）。  
   - 播放8位机风格的BGM（比如《冒险岛》的背景音乐）。

2. **算法启动**：  
   - 像素工人（一个小方块，戴安全帽）从左到右移动，每到一个数（比如位置i），会“举起锤子”（动画）。  
   - 显示当前数的`a[i]`值（像素字体），`lst[a[i]]`的值（比如“上一次5在位置3”）。

3. **核心步骤演示**：  
   - **不贡献的情况**：工人把当前数染成与前一个不同的颜色（比如前一个是红，当前染蓝），得分板不变，伴随“咔”的音效。  
   - **贡献的情况**：工人把当前数染成与`lst[a[i]]`同色（比如`lst[a[i]]=3`，位置3是红，当前也染红），位置3和i的方块会“闪烁彩虹色”，得分板增加`a[i] + 中间的连续贡献`，伴随“叮”的音效。  
   - **状态转移**：状态面板的`f[i]`值会从`f[i-1]`变成更大的值（比如从5变成8），伴随“咚”的音效。

4. **交互功能**：  
   - **单步执行**：点击“单步”按钮，工人移动一步，详细展示每一步的操作。  
   - **自动播放**：点击“开始”，工人自动移动，速度由滑块控制（最慢1秒一步，最快0.1秒一步）。  
   - **重置**：点击“重置”，数组恢复初始状态，得分清零，工人回到起点。

5. **结束状态**：  
   - 工人走到数组末尾（位置n），得分板显示最终得分，播放“胜利音效”（类似《塞尔达》的宝箱声），屏幕中央弹出“挑战成功！”的像素文字。  
   - 如果无解（比如所有数都不同），播放“提示音效”（短促的“哔”声），显示“没有得分”。


### 技术实现（轻量化）
- **前端**：纯HTML+CSS+JavaScript（Canvas API），单文件，本地双击即可运行。  
- **像素绘制**：用`ctx.fillRect`绘制方块，`ctx.fillText`绘制像素字体。  
- **音效**：用Web Audio API播放8位音效（比如`ctx.createOscillator()`生成正弦波，调整频率模拟“叮”“咔”声）。  
- **动画控制**：用`requestAnimationFrame`实现流畅动画，`setTimeout`控制自动播放速度。


## 6. 拓展练习与相似问题

### 通用思路迁移
本题的核心思路（**动态规划+前缀和+上一次位置查询**）可以解决以下问题：  
1. **最长重复子数组**：寻找两个数组中的最长重复子数组，需要记录上一次出现的位置。  
2. **最大子段和的变形**：比如“允许跳过某些元素的最大和”，需要记录前一段的状态。  
3. **字符串的最长回文子串**：用DP记录前i位的最长回文，需要查询上一次相同字符的位置。


### 洛谷推荐练习
1. **P10200 花神诞日**：类似的动态规划问题，需要处理连续的贡献，适合巩固前缀和技巧。  
   * 推荐理由：“花神诞日”的得分规则与本题类似，都是“连续同值的贡献累加”，能锻炼状态定义能力。  
2. **P1140 相似基因**：动态规划的经典问题，需要记录前一个状态（类似本题的“最后一个颜色”），适合巩固状态转移技巧。  
   * 推荐理由：“相似基因”的转移需要考虑前一个基因的匹配情况，与本题的“前一个颜色”逻辑一致。  
3. **P1280 尼克的任务**：动态规划的优化问题，需要从O(n²)优化到O(n)，适合巩固前缀和与桶优化技巧。  
   * 推荐理由：“尼克的任务”的转移需要查询前一段的最大值，与本题的“maxn”和“mxn”逻辑一致。  


## 7. 学习心得与经验分享

<insights_intro>
从优质题解中，我提取了3条**超有用的经验**：
</insights_intro>

1. **预处理是“神器”**：  
   比如`lst[a[i]]`记录上一次同值的位置，`pre[i]`记录前缀和，这些预处理能把O(n²)的时间降到O(n)——**预处理=时间加速器**！

2. **状态定义要“精准”**：  
   不要贪多，比如本题的`f[i]`只记录前i位的最大得分，`dp[i][0/1]`只记录最后一个颜色的得分，这样状态数少，转移快——**精准=效率**！

3. **问题转化是“捷径”**：  
   比如W_Sibo把染色问题转化为“边选择问题”，瞬间把复杂的染色逻辑变成了简单的图论问题——**转化=化繁为简**！


## 8. 总结

本次分析的“染色”问题，核心是**动态规划的状态定义与优化**。通过优质题解的学习，我们掌握了：  
- 用`lst`数组记录上一次位置；  
- 用前缀和打包连续贡献；  
- 用桶优化转移时间；  
- 用问题转化简化逻辑。  

记住：**编程的本质是“解决问题”**——不管用什么算法，能把问题想清楚、写出来，就是胜利！下次遇到类似的动态规划问题，不妨试试今天学的技巧，一定会事半功倍！💪

下次我们再一起探索新的编程挑战——比如“最长上升子序列”“背包问题”，不见不散！🎉

---
处理用时：116.01秒
# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果


### 💡 Kay的C++算法解析：最优贸易 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：分层图应用 (图论技巧)  
🗣️ **初步分析**：
> 解决"最优贸易"的关键在于构建分层图模型。想象你是一名像素世界的商人🎮，拥有三个平行世界：绿世界（未交易）、蓝世界（已买入）、红世界（已卖出）。每次跨层就像使用传送门：绿→蓝需支付金币（买入），蓝→红获得金币（卖出）。在本题中，分层图将交易状态转化为空间维度，通过SPFA求最长路获取最大利润。
- **题解思路对比**：分层图解法（直观易实现）VS Tarjan缩点（稳定但复杂）VS 双SPFA（高效但需反图）。分层图通过三层结构自然保证交易顺序，是本题最优雅的解法。
- **核心算法流程**：
  1. 构建三层图：每层复制原图（边权0）
  2. 添加跨层边：绿→蓝（边权=-价格），蓝→红（边权=+价格）
  3. SPFA求绿世界起点到红世界终点的最长路
- **可视化设计**：采用8位像素风格，用三种颜色区分层级。跨层时触发"金币音效"💎，自动演示模式展示商人从绿世界1号城出发，穿越蓝世界买入，最终在红世界n号城卖出的过程。关键动画：价格更新时像素块闪烁，路径显示当前利润。

---

#### 2. 精选优质题解参考
**题解一：分层图+SPFA（作者：fy1234567ok）**  
* **点评**：思路如水晶般透明✨！通过三层图巧妙转化交易状态（绿→蓝→红），代码仅40行却完整覆盖核心逻辑。亮点在于用宏定义`t(x,i)`清晰管理层级节点，SPFA实现简洁（含C++17结构化绑定）。变量名`G`、`d`等稍简但符合竞赛风格，边界处理严谨（INT_MIN初始化），是竞赛编码的典范。

**题解二：双SPFA（作者：fairfriendZ）**  
* **点评**：创新的双路极值搜索🔍！第一遍SPFA正向求最小买入价，第二遍在反图求最大卖出价。亮点在于避免分层图的空间开销，时间复杂度更优（O(m)）。代码中`dis`/`dis1`命名清晰，反图构建逻辑严谨，特别适合大数据场景。调试心得提到被hack数据考验的经历，体现实战价值。

**题解三：Tarjan缩点+DP（作者：ctzm）**  
* **点评**：稳如泰山的拓扑解法⛰️！通过Tarjan将环缩点转为DAG，在强连通分量内预处理极值（minw/maxw），再按拓扑序DP。亮点在于处理了"从i能否到n"的关键问题（反图DFS）。代码中`scc`/`miw`等命名专业，虽然实现较复杂但鲁棒性强，是应对特殊数据的保险选择。

---

#### 3. 核心难点辨析与解题策略
1. **状态顺序约束**（如何保证先买后卖？）  
   *分析*：分层图通过层级隔离状态（绿→蓝→红不可逆），Tarjan则在DAG上保证拓扑顺序。优质解法都用空间/时间维度天然保证顺序。  
   💡 学习笔记：交易顺序本质是状态机，可用层级或拓扑序约束。

2. **环的处理**（重复访问城市？）  
   *分析*：分层图中同层可成环但不影响跨层，Tarjan直接将环缩为单点（取内部极值）。双SPFA通过松弛操作自然处理重复访问。  
   💡 学习笔记：强连通分量可视为交易黑盒——最低价买入，最高价卖出。

3. **终点可达性**（路径是否通n？）  
   *分析*：Tarjan解法需显式判断（反图DFS），分层图和双SPFA将终点作为目标状态。  
   💡 学习笔记：终点约束可通过目标状态（第三层n点）或预处理（反图搜索）解决。

✨ **解题技巧总结**：
- **状态分层法**：将操作步骤转化为空间维度（如三层图）
- **反图活用**：处理"可达终点"时反向建图搜索
- **极值分离**：双SPFA分别求路径最小值和后缀最大值
- **缩点降维**：用Tarjan将环转为DAG简化问题

---

#### 4. C++核心代码实现赏析
**本题通用核心实现参考**  
*说明*：综合分层图解法的最简实现，完美体现"状态即空间"思想
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+5, M = 5e5+5;

struct Edge { int to, w; };
vector<Edge> G[N*3]; // 三层图: 0~n-1(绿), n~2n-1(蓝), 2n~3n-1(红)
int n, m, dis[N*3];

void spfa() {
    memset(dis, 0x80, sizeof dis); // 初始化为极小值(-2e9)
    queue<int> q;
    q.push(0); dis[0] = 0; // 起点: 绿世界1号城
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto [v, w] : G[u]) { // C++17结构化绑定
            if (dis[v] < dis[u] + w) {
                dis[v] = dis[u] + w;
                q.push(v);
            }
        }
    }
}

int main() {
    cin >> n >> m;
    for (int i = 0, w; i < n; i++) {
        cin >> w;
        G[i].push_back({i+n, -w});    // 绿→蓝: 买入支出
        G[i+n].push_back({i+2*n, w}); // 蓝→红: 卖出收入
    }
    for (int i = 0, u, v, t; i < m; i++) {
        cin >> u >> v >> t; u--; v--;
        G[u].push_back({v, 0});       // 同层移动
        G[u+n].push_back({v+n, 0});
        G[u+2*n].push_back({v+2*n, 0});
        if (t == 2) { // 双向道路
            G[v].push_back({u, 0});
            G[v+n].push_back({u+n, 0});
            G[v+2*n].push_back({u+2*n, 0});
        }
    }
    spfa();
    cout << max(0, dis[3*n-1]); // 红世界终点
}
```

**优质题解片段赏析**  
1. 分层图实现（题解一）  
```cpp
// 宏定义简化三层节点访问
#define t(x,i) (x+i*n) 

void add_edge(int u, int v) {
    G[t(u,0)].push_back({t(v,0), 0});
    G[t(u,1)].push_back({t(v,1), 0});
    G[t(u,2)].push_back({t(v,2), 0});
}
// 核心：SPFA求最长路
while (!Q.empty()) {
    int u = Q.front(); Q.pop(); inq[u] = false;
    for (auto [v, w] : G[u]) 
        if (dis[v] < dis[u] + w) 
            if (!inq[v]) Q.push(v), inq[v] = true;
}
```
> **代码解读**：  
> - 宏`t(x,i)`将三维坐标压缩为一维（类似行优先存储）
> - 同层移动边权为0，跨层边承载交易行为
> - SPFA中`dis[v] < dis[u] + w`求最长路（初始需置INT_MIN）  
> 💡 学习笔记：宏简化多维访问是竞赛常用技巧，但工程中建议用inline函数

2. 双SPFA极值（题解五）  
```cpp
// 第一遍：求1→i路径最小价格
void spfa_min() {
    dis_min[0] = price[0]; // 起点价格
    q.push(0);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : G_forward[u]) {
            int new_min = min(dis_min[u], price[v]);
            if (new_min < dis_min[v]) { // 松弛操作
                dis_min[v] = new_min;
                q.push(v);
            }
        }
    }
}
// 第二遍：求i→n路径最大价格（反图）
void spfa_max() {
    dis_max[n-1] = price[n-1]; // 终点价格
    q.push(n-1);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : G_backward[u]) { // 注意反图！
            int new_max = max(dis_max[u], price[v]);
            if (new_max > dis_max[v]) {
                dis_max[v] = new_max;
                q.push(v);
            }
        }
    }
}
```
> **代码解读**：  
> - 正向图求路径最小值（水往低处流）
> - 反向图求路径最大值（火往高处烧）
> - 最终利润：对所有`i`取`dis_max[i] - dis_min[i]`  
> 💡 学习笔记：反图是处理"终点可达性"的银弹，两次SPFA独立处理路径极值

---

#### 5. 算法可视化：像素动画演示
**主题**：8位像素商人的跨层交易之旅 🎮  
**核心演示**：分层世界中的SPFA寻路，动态展示价格更新与状态跃迁  

| 动画帧               | 像素表现                                                                 | 交互设计                     |
|----------------------|--------------------------------------------------------------------------|------------------------------|
| **世界初始化**       | 三色网格世界（绿/蓝/红），城市用方块表示，价格用8位数字显示              | 控制面板：开始/步进/速度滑块 |
| **商人移动**         | 像素小人沿边移动，同层移动无特效                                         | 方向键控制移动               |
| **买入时刻**         | 绿→蓝传送：商人闪烁黄光，播放"扣金币"音效💸，显示负价格                  | 自动触发或按B键              |
| **卖出时刻**         | 蓝→红传送：商人闪烁金光，播放"收金币"音效💰，显示正利润                  | 自动触发或按S键              |
| **路径更新**         | 当前路径用发光边框标记，实时显示利润值                                   | 鼠标悬停查看详情             |
| **终点到达**         | 红世界终点放烟花🎆，播放胜利音效，显示最终利润                           | 空格键重播                   |

**技术实现**：
```javascript
// 伪代码：关键动画逻辑
function drawFrame() {
  // 1. 绘制三层世界（Canvas实现）
  drawWorld(GREEN_LAYER, 0, yOffset); 
  drawWorld(BLUE_LAYER, 0, yOffset + GRID_SIZE);
  drawWorld(RED_LAYER, 0, yOffset + GRID_SIZE*2);

  // 2. 高亮当前操作节点
  if (currentState === BUYING) {
    drawPulsingEffect(node, GOLD_COLOR); // 买入金光特效
    playSound("buy_sound.wav"); 
  }

  // 3. 显示数据结构状态
  drawArrayVisualization(dis, "dis"); // 实时显示距离数组
}
```
> **设计思路**：用垂直排列模拟三层世界，跨层时y轴跃迁产生"传送"感。音效强化操作反馈（买入: 低沉音，卖出: 高亢音），自动演示模式以商人NPC自动寻路。

---

#### 6. 拓展练习与相似问题思考
**通用迁移场景**：
1. **多次交易机会**：若允许k次买卖，扩展为2k+1层图
2. **交易税费**：跨层边权调整为`(price×tax_rate)`
3. **期货交易**：价格随时间变化，增加时间维度

**洛谷推荐**：
1. [P2939] 改造路 - **推荐理由**：分层图经典应用，K次免费机会转化为K+1层图
2. [P3008] 路障 - **推荐理由**：结合最短路与状态分层，巩固"边权即状态"思想
3. [P4568] 飞行路线 - **推荐理由**：分层图+DIJKSTRA，理解不同图算法在分层中的应用

---

#### 7. 学习心得与经验分享
> **参考经验**（来自题解作者调试经历）：  
> “最初在反图DFS时未处理孤立点，导致部分点误标记不可达。通过打印中间图结构，发现反图构建遗漏双向边处理。” —— ctzm  
> 
> **Kay点评**：调试图论问题的黄金法则——可视化中间状态！建议：
> 1. 小数据手工模拟（n=5时画图验证）
> 2. 输出临界点状态（如距离数组突变点）
> 3. 边界测试（单点图、链图、环图）

---

### 结语
通过分层图，我们实现了交易状态的空间化映射；借助SPFA，在像素世界中模拟了商人的最优决策路径。记住：**算法是解空间的魔术师🎩，而分层是其中最绚丽的戏法**！下次遇到状态转移问题时，不妨思考——能否构建你的多维解空间？

---
处理用时：216.80秒
# 题目信息

# [NOIP 2012 提高组] 开车旅行

## 题目描述

小 $\text{A}$ 和小 $\text{B}$ 决定利用假期外出旅行，他们将想去的城市从 $1 $ 到 $n$ 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 $i$ 的海拔高度为$h_i$，城市 $i$ 和城市 $j$ 之间的距离 $d_{i,j}$ 恰好是这两个城市海拔高度之差的绝对值，即 $d_{i,j}=|h_i-h_j|$。
 
旅行过程中，小 $\text{A}$ 和小 $\text{B}$ 轮流开车，第一天小 $\text{A}$ 开车，之后每天轮换一次。他们计划选择一个城市 $s$ 作为起点，一直向东行驶，并且最多行驶 $x$ 公里就结束旅行。    

小 $\text{A}$ 和小 $\text{B}$ 的驾驶风格不同，小 $\text{B}$ 总是沿着前进方向选择一个最近的城市作为目的地，而小 $\text{A}$ 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 $x$ 公里，他们就会结束旅行。

在启程之前，小 $\text{A}$ 想知道两个问题：

1、 对于一个给定的 $x=x_0$，从哪一个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值最小（如果小 $\text{B}$ 的行驶路程为 $0$，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。

2、对任意给定的 $x=x_i$ 和出发城市 $s_i$，小 $\text{A}$ 开车行驶的路程总数以及小 $\text B$ 行驶的路程总数。


## 说明/提示

【样例1说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/zgms0k7y.png)

各个城市的海拔高度以及两个城市间的距离如上图所示。

如果从城市 $1$ 出发，可以到达的城市为 $2,3,4$，这几个城市与城市 $1$ 的距离分别为 $1,1,2$，但是由于城市 $3$ 的海拔高度低于城市 $2$，所以我们认为城市 $3$ 离城市 $1$ 最近，城市 $2$ 离城市 $1$ 第二近，所以小A会走到城市 $2$。到达城市 $2$ 后，前面可以到达的城市为 $3,4$，这两个城市与城市 $2$  的距离分别为 $2,1$，所以城市 $4$ 离城市 $2$ 最近，因此小B会走到城市$4$。到达城市 $4$ 后，前面已没有可到达的城市，所以旅行结束。

如果从城市 $2$ 出发，可以到达的城市为 $3,4$，这两个城市与城市 $2$ 的距离分别为 $2,1$，由于城市 $3$ 离城市 $2$ 第二近，所以小 $\text A$ 会走到城市 $3$。到达城市 $3$ 后，前面尚未旅行的城市为 $4$，所以城市 $4$ 离城市 $3$ 最近，但是如果要到达城市 $4$，则总路程为 $2+3=5>3$，所以小 $\text B$ 会直接在城市 $3$ 结束旅行。

如果从城市 $3$ 出发，可以到达的城市为 $4$，由于没有离城市 $3$ 第二近的城市，因此旅行还未开始就结束了。

如果从城市 $4$ 出发，没有可以到达的城市，因此旅行还未开始就结束了。


【样例2说明】

当 $x=7$ 时，如果从城市 $1$ 出发，则路线为 $1 \to 2 \to 3 \to 8 \to 9$，小 $\text A$ 走的距离为 $1+2=3$，小 $\text B$ 走的距离为 $1+1=2$。（在城市 $1$ 时，距离小 $\text A$ 最近的城市是 $2$ 和 $6$，但是城市 $2$ 的海拔更高，视为与城市 $1$ 第二近的城市，所以小 $\text A$ 最终选择城市 $2$；走到$9$ 后，小 $\text A$ 只有城市 $10$ 可以走，没有第二选择可以选，所以没法做出选择，结束旅行）

如果从城市 $2$ 出发，则路线为 $2 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $3$ 出发，则路线为 $3 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $4$ 出发，则路线为 $4 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $5$ 出发，则路线为 $5 \to 7 \to 8$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $5,1$。

如果从城市 $6$ 出发，则路线为 $6 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$5,1$。

如果从城市 $7$ 出发，则路线为 $7 \to 9 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $8$ 出发，则路线为 $8 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,0$。

如果从城市 $9$ 出发，则路线为 $9$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $0,0$（旅行一开始就结束了）。

如果从城市 $10$ 出发，则路线为 $10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$0,0$。

从城市 $2$ 或者城市 $4$ 出发小 $\text A$ 行驶的路程总数与小 $\text B$ 行驶的路程总数的比值都最小，但是城市 $2$ 的海拔更高，所以输出第一行为 $2$。

【数据范围与约定】  

对于 $30\%$ 的数据，有$1\le n \le 20,1\le m\le 20$；  
对于$40\%$ 的数据，有$1\le n \le 100,1\le m\le 100$；  
对于 $50\%$ 的数据，有$1\le n \le 100,1\le m\le 1000$；  
对于 $70\%$ 的数据，有$1\le n \le 1000,1\le m\le 10^4$；   
对于 $100\%$ 的数据：$1\le n,m \le 10^5$，$-10^9 \le h_i≤10^9$，$1 \le s_i \le n$，$0 \le x_i \le 10^9$   
数据保证 $h_i$ 互不相同。


## 样例 #1

### 输入

```
4 
2 3 1 4 
3 
4 
1 3 
2 3 
3 3 
4 3
```

### 输出

```
1 
1 1 
2 0 
0 0 
0 0 ```

## 样例 #2

### 输入

```
10 
4 5 6 1 2 3 7 8 9 10 
7 
10 
1 7 
2 7 
3 7 
4 7 
5 7 
6 7 
7 7 
8 7 
9 7 
10 7```

### 输出

```
2 
3 2 
2 4 
2 1 
2 4 
5 1 
5 1 
2 1 
2 0 
0 0 
0 0```

# AI分析结果


### 💡 Kay的C++算法解析：「开车旅行」深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`倍增优化` + `链表/平衡树预处理`  
🗣️ **初步分析**：  
> 本题核心在于**路径预判**与**高效查询**。想象两位探险家（小A和小B）在一条由城市组成的"山脉"上向东旅行，小A偏好选择次近城市，小B选择最近城市。解题关键在于：
> 1. **预处理路径**：用双向链表或平衡树快速计算每个城市的最近(GB)和次近(GA)城市
> 2. **倍增加速**：将连续两天的行驶（小A+小B）视为一个"步长"，通过倍增表实现对数级查询
> 3. **难点对比**：
>    - 链表法：O(n)但调试复杂（需动态删除节点）
>    - 平衡树法：O(n log n)易实现但常数较大
>   4. **可视化设计**：  
>      - 像素网格展示城市海拔（y轴）与位置（x轴）
>      - 高亮当前城市，箭头动画显示选择GA/GB的过程
>      - 底部状态栏实时更新累计路程和剩余X值

---

#### 2. 精选优质题解参考
**题解一：yangrunze (赞141)**  
* **亮点**：  
  - **结构清晰**：分步讲解链表预处理→倍增初始化→查询优化  
  - **代码规范**：完整封装choose/del函数，变量名自解释  
  - **倍增推导**：精妙处理i=1时的换人逻辑（k^=1）  
  - **实践价值**：边界处理严谨（如`if(ga[i])`的判空）

**题解二：shadow__ (赞77)**  
* **亮点**：  
  - **预处理创新**：双向链表实现中独创性的四候选点比较法  
  - **空间优化**：用`f[i][0]`存储两步后的位置，减少状态维度  
  - **复杂度平衡**：O(n)预处理 + O(log n)查询的完美结合

**题解三：star_fish (赞5)**  
* **亮点**：  
  - **STL妙用**：用`set`实现简洁的邻域候选值查找  
  - **调试技巧**：详细记录链表调试经验（"调了一晚上"）  
  - **完整实现**：提供可复用的`calc`函数封装查询逻辑

---

#### 3. 核心难点辨析与解题策略
1. **难点：GA/GB的快速预处理**  
   * **分析**：必须在东向城市中找最近/次近点。双向链表法通过倒序处理+动态删除，保证候选城市均为后续城市。平衡树法通过`lower_bound`找邻域候选值。
   * 💡 **学习笔记**：链表法更优但易错，建议先用小规模数据验证

2. **难点：倍增状态转移**  
   * **分析**：当i=1（走2步）时，因小A→小B→小A的轮换，需特殊处理状态转移（k^=1）；i>1时保持相同驾驶者。
   * 💡 **学习笔记**：画状态转移图理解`f[i][j][k]=f[i-1][mid][k^1]（i=1）`

3. **难点：边界与比值处理**  
   * **分析**：当小B路程为0时比值无穷大，需用乘法避免浮点误差（`a1*b2 < a2*b1`比较）
   * 💡 **学习笔记**：特判`if(!lb)`并设置极大值

✨ **解题技巧总结**：  
- **问题分解**：拆解为预处理→倍增构建→查询三阶段  
- **数据结构选择**：链表（速度）vs 平衡树（代码简洁）  
- **调试技巧**：用`n=4`的样例验证GA/GB计算正确性

---

#### 4. C++核心代码实现赏析
**通用核心实现（链表法+倍增）**：
```cpp
// 双向链表节点预处理
for(int i=1; i<=n; i++){
    int p=pos[i], p1=h[p].pre, p2=h[p].nxt;
    if(p1 && (h[p].hi-h[p1].hi <= h[p2].hi-h[p].hi || !p2))
        gb[i]=h[p1].id, ga[i]=choose(h[p1].pre, p2, p);
    else 
        gb[i]=h[p2].id, ga[i]=choose(p1, h[p2].nxt, p);
    del(p); // 关键！动态移除已处理节点
}

// 倍增表示例（i=1特殊处理）
for(int j=1; j<=18; j++){
    for(int i=1; i<=n; i++) for(int k=0; k<2; k++){
        if(j==1){ // 轮换特判
            f[j][i][k] = f[j-1][f[j-1][i][k]][1-k];
            da[j][i][k] = da[j-1][i][k] + da[j-1][f[j-1][i][k]][1-k];
        } else { // 正常转移
            f[j][i][k] = f[j-1][f[j-1][i][k]][k];
            da[j][i][k] = da[j-1][i][k] + da[j-1][f[j-1][i][k]][k];
        }
    }
}
```

**题解一亮点片段**：  
```cpp
// 优雅的链表删除操作
void del(int pos){
    if(h[pos].nxt) h[h[pos].nxt].pre = h[pos].pre;
    if(h[pos].pre) h[h[pos].pre].nxt = h[pos].nxt;
}
```

**题解二创新点**：  
```cpp
/* 四候选值比较法：从当前点前后各取两点
 * 保证找到真正的次近点 */
vector<pair<ll, int>> cands;
cands.push_back({abs(h[i]-left1), left_id});
cands.push_back({abs(h[i]-left2), left2_id});
cands.push_back({abs(h[i]-right1), right_id});
cands.push_back({abs(h[i]-right2), right2_id});
sort(cands.begin(), cands.end());
```

---

#### 5. 算法可视化：像素动画演示
**设计思路**：  
> 采用8-bit复古游戏风格，将算法执行转化为探险游戏：
> - **场景设计**：  
>   - 横向卷轴式地图，x轴为城市编号，y轴为海拔高度
>   - 城市用不同颜色像素块表示（绿色：起点，红色：终点）
> - **动画流程**：  
>   1. 初始化：显示双向链表结构（节点间有连线）
>   2. 预处理阶段：当前处理城市闪烁，被删除的节点变灰
>   3. 行驶演示：
>      - 小A回合：蓝色箭头指向次近城市
>      - 小B回合：黄色箭头指向最近城市
>   4. 倍增跳跃：快速播放连续行驶过程，显示2^i的跳跃轨迹
> - **交互控制**：
>   - 速度滑块：调节单步/自动播放速度
>   - 模式切换：对比链表法 vs 平衡树法的预处理过程
> - **音效设计**：
>   - 选择城市："叮"声（不同音高表示GA/GB）
>   - 成功到达：8-bit胜利旋律

---

#### 6. 拓展练习与相似问题
**通用技巧迁移**：  
> 1. **倍增思想**：压缩状态空间（如LCA快速查询）  
> 2. **链表预处理**：解决邻值查找类问题（如P10466）  
> 3. **动态删除**：处理单向约束的序列问题  

**推荐练习**：  
1. **洛谷P10466** - 邻值查找  
   * 🗣️ 巩固链表预处理技巧，与本题GB/GA查找高度相似  
2. **洛谷P3379** - 最近公共祖先  
   * 🗣️ 学习倍增法的经典应用，理解`f[i][j]`状态设计  
3. **洛谷P3865** - ST表  
   * 🗣️ 掌握静态区间最值问题的倍增解法  

---

#### 7. 学习心得与经验分享
> **来自 yangrunze 的调试经验**：  
> *"双向链表的删除操作极易出错，我在`del()`函数卡了一晚上。建议用纸笔画图验证指针变更：*
> ```cpp
> void del(int pos){
>     if(h[pos].nxt) h[h[pos].nxt].pre = h[pos].pre;
>     if(h[pos].pre) h[h[pos].pre].nxt = h[pos].nxt; 
> }
> ```
> *这个看似简单的操作，忘记检查`nxt/pre`存在性会导致RE"*  

> **关键收获**：  
> - 当算法复杂时，先用小样例（n=4）人肉模拟  
> - 倍增法本质是用二进制划分降低线性消耗  
> - 比较比值时，**永远避免浮点数**！用交叉乘法判断  

---

### 结语
通过本题，我们深入掌握了**倍增法优化路径查询**的核心技巧，并体验了数据结构选择的艺术（链表 vs 平衡树）。记住：好的算法设计是优雅与高效的平衡！下次当你面对复杂路径问题时，不妨想想小A和小B的旅行故事~ 💪🏻

---
处理用时：163.87秒
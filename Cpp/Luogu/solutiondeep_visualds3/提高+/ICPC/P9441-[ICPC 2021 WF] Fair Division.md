# 题目信息

# [ICPC 2021 WF] Fair Division

## 题目描述

$n$ 个人按如下的方式分 $m$ 块钱：先指定一个分数 $f$，$n$ 个人围成一圈，第一个人先拿走总钱数的 $f$，把剩下的钱给第二个人，然后第二个人拿走剩余钱数的 $f$，把剩下的钱交给第三个人...每一个人都从剩余的钱中拿走剩余钱数的 $f$，然后把钱交给下一个人。这种操作可以无限进行下去。

现在给定 $n,m$，你需要构造 $f=\dfrac{p}{q}$，使得 $0<f<1$，并且在分钱无限进行下去之后，最终每个人拿到的钱都是整数。如果有多解，你构造的解需要在 $q$ 尽可能小的情况下 $p$ 尽可能小。如果无解，输出 `impossible`。

$6\le n\le 10^6$，$1\le m\le 10^{18}$。

## 样例 #1

### 输入

```
8 51000
```

### 输出

```
1 2```

## 样例 #2

### 输入

```
6 91000
```

### 输出

```
2 3
```

## 样例 #3

### 输入

```
10 1000000000000000000
```

### 输出

```
impossible
```

# AI分析结果


### 💡 Kay的C++算法解析：Fair Division 深入学习指南 💡

#### **1. 题目解读与核心算法识别**  
✨ **本题主要考察**：`数学推导 + 枚举优化`  
🗣️ **初步分析**：  
> 本题本质是**无限等比级数求和**与**整除性验证**的结合。想象一个像素风接力游戏：$n$ 人围圈传递 $m$ 金币，每人拿走当前金币堆的固定比例 $f$，要求无限轮后每人总金币为整数。解题需三步：  
> 1. **公式推导**：将无限循环转化为等比数列求和（$F(x) = \frac{(1-f)^x f m}{1-(1-f)^n}$）  
> 2. **整除条件**：设 $f=\frac{p}{q}, t=1-f=\frac{r}{q}$，化简得关键约束 $\sum_{i=0}^{n-1} r^i q^{n-1-i} \mid m$  
> 3. **枚举优化**：$q$ 从 2 开始枚举，$r\in[1,q-1]$，利用 $q^{n-1}\leq m$ 限制范围，`__int128` 防溢出  
>  
> **可视化设计**：  
> - 8-bit 网格：$x$ 轴为 $q$，$y$ 轴为 $r$，每个像素格代表一组 $(q,r)$  
> - 动画流程：  
>   - 高亮当前枚举格子 → 显示和式计算过程（像素块逐项累加）  
>   - 若整除：格子变绿 + 播放 "胜利音效"；否则变灰  
> - 交互：速度滑块控制枚举步频，"单步执行"按钮调试关键点  

---

#### **2. 精选优质题解参考**  
<eval_intro>  
综合思路清晰度、代码规范性与算法效率，精选两份题解：  
</eval_intro>

**题解一 (sintle)**  
* **亮点**  
  - 推导严谨：详细证明 $q^n-r^n$ 与分子的互质关系  
  - 代码健壮：封装 `mul()` 和 `fpow()` 处理溢出，边界清晰  
  - 可读性高：变量名 `qn1`、`term` 直指数学含义  

**题解二 (iyaang)**  
* **亮点**  
  - 结构简洁：Lambda 函数 `mul128/pow128` 实现内联大数运算  
  - 数学等价：通过 $g=\frac{a}{b}$ 重新推导，验证结论普适性  
  - 特判优化：隐式处理 $q=2, r=1$ 的等比求和  

---

#### **3. 核心难点辨析与解题策略**  
<difficulty_intro>  
突破三大难点方可解题：  
</difficulty_intro>

1. **难点1：无穷过程 → 有限表达式**  
   - **策略**：等比级数求和 $S = \frac{a_1}{1-\text{公比}}$，公比为 $(1-f)^n$  
   - **关键变量**：$f$ 为比例，$t=1-f$ 为传递比例  
   - 💡 **学习笔记**：无限问题常收敛为有限公式  

2. **难点2：分数化简 → 整除约束**  
   - **策略**：设最简分数 $t=\frac{r}{q}$，通分后分析分母 $q^n-r^n$  
   - **数据结构**：用快速幂计算 $r^i, q^{n-1-i}$，避免除法损失精度  
   - 💡 **学习笔记**：整除条件依赖分子分母的互质分解  

3. **难点3：枚举范围爆炸**  
   - **策略**：利用 $q^{n-1} \leq 10^{18}$ 限定 $q_{\max} \approx 10^{18/(n-1)}$  
   - **优化**：$n \geq 6$ 时 $q$ 增长极快，实际枚举量极小（如 $n=10^6$ 仅需查 $q=2$)  
   - 💡 **学习笔记**：指数增长特性是剪枝利器  

### ✨ **解题技巧总结**  
- **技巧1：数学先行**：先推公式再编码，避免盲目尝试  
- **技巧2：溢出防御**：`__int128` 或 `min(a*b, INF)` 处理大数  
- **技巧3：边界特判**：$q=2, r=1$ 时和式=$2^n-1$，可单独计算  

---

#### **4. C++核心代码实现赏析**  
<code_intro_overall>  
以下是融合两题解优点的完整实现：  
</code_intro_overall>

```cpp
#include <iostream>
#include <climits>
using namespace std;
using ll = long long;
using i128 = __int128_t;
const i128 INF = 2e18;

i128 safe_pow(ll base, int exp) {
    i128 res = 1;
    while (exp) {
        if (exp & 1) {
            if (res > INF / base) return INF; // 溢出检查
            res *= base;
        }
        if (base > 1e9 && exp > 1) return INF; // 底数过大时提前终止
        base *= base;
        exp >>= 1;
    }
    return res;
}

int main() {
    ll n, m;
    cin >> n >> m;
    for (ll q = 2; ; q++) {
        i128 q_power = safe_pow(q, n - 1);
        if (q_power > m || q_power == INF) break;

        for (ll r = 1; r < q; r++) {
            i128 sum = 0;
            for (int i = 0; i < n; i++) {
                i128 term = safe_pow(r, i) * safe_pow(q, n - 1 - i);
                if (term == INF || sum > INF - term) {
                    sum = INF;
                    break;
                }
                sum += term;
            }
            if (sum <= m && m % static_cast<ll>(sum) == 0) {
                cout << q - r << " " << q << endl;
                return 0;
            }
        }
    }
    cout << "impossible" << endl;
}
```

**代码解读概要**：  
> 1. `safe_pow()` 用快速幂计算幂次，溢出时返回 `INF`  
> 2. 外层循环枚举 $q$，利用 $q^{n-1} \leq m$ 剪枝  
> 3. 内层循环枚举 $r$，计算和式 $\sum r^i q^{n-1-i}$  
> 4. 若和式整除 $m$ 则输出 $f=(q-r)/q$  

---
<code_intro_selected>  
题解关键代码对比赏析：  
</code_intro_selected>

**题解一：sintle 的防溢出设计**  
```cpp
int mul(int a, int b) { // 溢出安全乘法
    return min(((__int128_t)a) * b, (__int128_t)INF);
}
int fpow(__int128 a, int b) { // 快速幂
    int res = 1;
    while (b) {
        if (b & 1) res = mul(res, a);
        a = mul(a, a);
        b >>= 1;
    }
    return res;
}
```
> **学习笔记**：乘法封装是竞赛代码的黄金实践  

**题解二：iyaang 的 Lambda 优化**  
```cpp
auto pow128 = [&](int a, int b) -> int {
    int res = 1;
    while (b) {
        if (b & 1) res = mul128(res, a);
        a = mul128(a, a);
        b >>= 1;
    }
    return res;
};
```
> **学习笔记**：Lambda 函数保持作用域清洁，避免全局状态  

---

#### **5. 算法可视化：像素动画演示**  
**主题**：`像素探险家：比例之谜`  
**核心流程**：  
```mermaid
graph LR
A[启动] --> B[绘制 q-r 网格]
B --> C{枚举 q}
C --> D[高亮当前 q 列]
D --> E{枚举 r}
E --> F[显示 r^i * q^{n-1-i} 计算]
F --> G[累加和式 S]
G --> H{S ≤ m?}
H -->|Yes| I[检查 m % S == 0]
H -->|No| E
I -->|Yes| J[播放胜利音效+绿光]
I -->|No| E
```
**交互细节**：  
- **视觉**：FC 红白机风格，网格背景色 `#2D2B55`，高亮色 `#FFCC00`  
- **音效**：  
  - 枚举步进：8-bit "滴" 声 (`Web Audio API`)  
  - 整除达成：`C5-E5-G5` 和弦胜利音  
- **控制面板**：  
  - 滑块调节枚举速度 (50ms~1000ms/步)  
  - "AI 演示" 模式：自动播放最优路径搜索  

---

#### **6. 拓展练习与相似问题思考**  
- **思维迁移**：  
  1. **无穷过程求和**：P5269 欧稳欧学车（级数应用）  
  2. **整除性+枚举**：P2926 [USACO] Patting Heads（约数性质）  
  3. **大数溢出处理**：P5436 随机数生成器（`__int128` 技巧）  

- **洛谷推荐**：  
  1. **P1414** 又是毕业季II  
     → 练习约数枚举与 GCD 性质  
  2. **P4446** [AHOI2018] 排列  
     → 强化等比级数建模能力  
  3. **P7961** 数列（NOIP2021）  
     → 训练二进制枚举与溢出防御  

---

#### **7. 学习心得与经验分享**  
> 题解未提供个人调试心得，但 Kay 强调：  
> **核心教训**：  
> - 大数运算必做溢出检查，勿假设 $n$ 的规模  
> - 数学推导先于编码，公式正确性决定代码可行性  
> - 特判简单情况（如 $q=2, r=1$）可显著提升效率  

---

> **Kay 结语**：通过像素游戏化理解数学之美，掌握溢出防御技巧，你将在竞赛中游刃有余！下次挑战再见！ 🚀

---
处理用时：481.87秒
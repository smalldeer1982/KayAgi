# 题目信息

# [NOI2014] 动物园

## 题目描述

近日，园长发现动物园中好吃懒做的动物越来越多了。例如企鹅，只会卖萌向游客要吃的。为了整治动物园的不良风气，让动物们凭自己的真才实学向游客要吃的，园长决定开设算法班，让动物们学习算法。

某天，园长给动物们讲解 KMP 算法。

园长：“对于一个字符串 $S$，它的长度为 $L$。我们可以在 $O(L)$ 的时间内，求出一个名为 $\mathrm{next}$ 的数组。有谁预习了 $\mathrm{next}$ 数组的含义吗？”

熊猫：“对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀又是它的前缀的字符串中（它本身除外），最长的长度记作 $\mathrm{next}[i]$。”

园长：“非常好！那你能举个例子吗？”

熊猫：“例 $S$ 为 $\verb!abcababc!$，则 $\mathrm{next}[5]=2$。因为$S$的前$5$个字符为 $\verb!abcab!$，$\verb!ab!$ 既是它的后缀又是它的前缀，并且找不到一个更长的字符串满足这个性质。同理，还可得出 $\mathrm{next}[1] = \mathrm{next}[2] = \mathrm{next}[3] = 0$，$\mathrm{next}[4] = \mathrm{next}[6] = 1$，$\mathrm{next}[7] = 2$，$\mathrm{next}[8] = 3$。”

园长表扬了认真预习的熊猫同学。随后，他详细讲解了如何在 $O(L)$ 的时间内求出 $\mathrm{next}$ 数组。

下课前，园长提出了一个问题：“KMP 算法只能求出 $\mathrm{next}$ 数组。我现在希望求出一个更强大 $\mathrm{num}$ 数组一一对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作 $\mathrm{num}[i]$。例如 $S$ 为 $\verb!aaaaa!$，则 $\mathrm{num}[4] = 2$。这是因为$S$的前 $4$ 个字符为 $\verb!aaaa!$，其中 $\verb!a!$ 和 $\verb!aa!$ 都满足性质‘既是后缀又是前缀’，同时保证这个后缀与这个前缀不重叠。而 $\verb!aaa!$ 虽然满足性质‘既是后缀又是前缀’，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，$\mathrm{num}[1] = 0,\mathrm{num}[2] = \mathrm{num}[3] = 1,\mathrm{num}[5] = 2$。”

最后，园长给出了奖励条件，第一个做对的同学奖励巧克力一盒。听了这句话，睡了一节课的企鹅立刻就醒过来了！但企鹅并不会做这道题，于是向参观动物园的你寻求帮助。你能否帮助企鹅写一个程序求出$\mathrm{num}$数组呢？

特别地，为了避免大量的输出，你不需要输出 $\mathrm{num}[i]$ 分别是多少，你只需要输出所有 $(\mathrm{num}[i]+1)$ 的乘积，对 $10^9 + 7$ 取模的结果即可。


## 说明/提示

测试点编号| 约定
-|-  
1| $n \le 5, L \le 50$  
2| $n \le 5, L \le 200$  
3| $n \le 5, L \le 200$  
4| $n \le 5, L \le 10,000$  
5| $n \le 5, L \le 10,000$  
6| $n \le 5, L \le 100,000$  
7| $n \le 5, L \le 200,000$   
8| $n \le 5, L \le 500,000$  
9| $n \le 5, L \le 1,000,000$  
10| $n \le 5, L \le 1,000,000$  


## 样例 #1

### 输入

```
3
aaaaa
ab
abcababc```

### 输出

```
36
1
32 ```

# AI分析结果


### 💡 Kay的C++算法解析：动物园 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`KMP算法扩展应用` (字符串处理/状态转移)

🗣️ **初步分析**：
> 解决"动物园"题目的关键在于理解KMP算法的扩展应用。简单来说，KMP算法就像一位聪明的侦探，通过观察字符串的规律提前记录线索（next数组），在匹配失败时快速调整位置。本题在标准KMP基础上增加了两个关键点：
> 1. 统计所有公共前后缀的数量（cnt数组）
> 2. 过滤重叠的公共前后缀（通过指针调整）
> 
> **核心算法流程**：
> 1. 第一次KMP遍历：建立next数组，同时通过cnt[i]=cnt[next[i]]+1递推统计公共前后缀数量
> 2. 第二次模拟KMP：维护指针j，当j超过i/2时回退到next[j]，此时cnt[j]即为有效数量
> 
> **可视化设计思路**：
> 采用8位像素风格，将字符串显示为彩色方块链。动画分为两个阶段：
> - 第一阶段（蓝色）：指针i和j移动，next数组形成树状连线
> - 第二阶段（红色）：j指针回退过程高亮显示，当j≤i/2时触发绿色闪光
> 关键变量更新用像素弹跳动画呈现，每次乘积更新时显示数字增长特效

---

#### 2. 精选优质题解参考
**题解一：Orion545（评分：★★★★★）**
* **点评**：此解法创新性地引入KMP自动机的fail树概念，将问题转化为树形结构处理。代码中通过分离两次KMP操作，清晰展现了cnt数组的递推关系与指针调整的逻辑。亮点在于对均摊时间复杂度的严谨证明（O(n)）和树形结构的形象比喻，变量命名规范（fail/cnt），边界处理完整（i从2开始）。实践价值极高，可直接用于竞赛场景。

**题解二：nofind（评分：★★★★☆）**
* **点评**：解法通过分离getnxt()和getnum()函数实现模块化设计，代码结构清晰易懂。亮点在于图示化展示next数组的跳转关系，直观解释"j>i/2"时的回退逻辑。虽然树形结构解释较少，但代码规范性（nxt/num命名）和逻辑直白性（显式循环条件）对初学者更友好。

**题解三：Wow_Goodjob（评分：★★★★）**
* **点评**：特别强调memset在字符数组的陷阱，体现实战经验。代码亮点在于健壮的初始化处理（避免清空整个字符数组）和详细的错误案例分析。虽然算法核心与其他解法相似，但实践建议部分（如调试技巧）具有独特价值，适合基础薄弱的学习者。

---

#### 3. 核心难点辨析与解题策略
1. **cnt数组的递推理解**
   * **分析**：cnt[i]表示前i字符的公共前后缀总数（含重叠），通过cnt[i]=cnt[next[i]]+1实现O(1)递推。本质是fail树上从i到根节点的路径长度
   * 💡 **学习笔记**：cnt数组是"公共前后缀的继承式统计"，类似家族代数计算

2. **指针j的高效调整**
   * **分析**：第二遍遍历时，当2*j>i需回退j=next[j]。由于每次i增加时j最多增加1，均摊时间复杂度为O(n)
   * 💡 **学习笔记**：j的回退类似滑窗机制，利用KMP的"记忆性"避免重复计算

3. **边界条件处理**
   * **分析**：单个字符时cnt[1]=1但实际num[1]=0，需从i=2开始计算。乘积初始化ans=1
   * 💡 **学习笔记**：字符串下标从1开始可统一next[1]=0, cnt[1]=1的初始化

✨ **解题技巧总结**：
- **双指针递进**：分离next构建和条件过滤两阶段
- **均摊复杂度分析**：理解j指针移动的单调性
- **树形思维**：将next数组视为fail树加速理解

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现**
```cpp
#include <cstdio>
#include <cstring>
const int N=1e6+10;
const int mod=1e9+7;
int n, nxt[N], cnt[N];
char s[N];

int main() {
    int T; scanf("%d",&T);
    while(T--) {
        scanf("%s",s+1);
        n = strlen(s+1);
        cnt[1] = 1;  // 初始化
        
        // 第一次KMP：构建next和cnt
        for(int i=2,j=0; i<=n; ++i) {
            while(j && s[i]!=s[j+1]) j=nxt[j];
            if(s[i]==s[j+1]) j++;
            nxt[i] = j;
            cnt[i] = cnt[j] + 1;  // 递推计数
        }
        
        long long ans=1;
        // 第二次扫描：过滤重叠
        for(int i=2,j=0; i<=n; ++i) {
            while(j && s[i]!=s[j+1]) j=nxt[j];
            if(s[i]==s[j+1]) j++;
            while(j*2 > i) j=nxt[j];  // 关键调整
            ans = ans*(cnt[j]+1) % mod;  // 累乘
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```

**题解一：Orion545**
```cpp
// 亮点：fail树概念融入
for(int i=1;i<n;i++){
    while(j&&(a[i]!=a[j])) j=fail[j];
    j+=(a[i]==a[j]); 
    fail[i+1]=j; 
    ans[i+1]=ans[j]+1;  // 树深统计
}
// 调整j时保持指针高效移动
while((j<<1)>(i+1)) j=fail[j];
```

**题解二：nofind**
```cpp
// 亮点：模块化分离
void getnxt(){
    for(int i=2,j=0;i<=n;i++){
        while(j&&s[i]!=s[j+1]) j=nxt[j];
        if(s[i]==s[j+1]) j++;
        nxt[i]=j; num[i]=num[j]+1;  // 清晰递推
    }
}
void getnum(){
    for(int i=2,j=0;i<=n;i++){
        while((j<<1)>i) j=nxt[j];  // 条件过滤
        ans=(ans*(num[j]+1))%mod;
    }
}
```

---

#### 5. 算法可视化：像素动画演示
**设计概念**：8位机像素风格，融合《超级马里奥》元素  
**核心演示**：  
1. **字符串显示**：每个字符转为16x16像素块（a=浅蓝，b=粉红...）
2. **双指针动画**：
   - 第一阶段：蓝色指针i右移，黄色指针j跳跃匹配
   - 匹配成功：像素块闪光+8bit"叮"声
   - 匹配失败：j沿红色fail线回跳+"咔"声
3. **树形结构**：next关系用绿色像素线连接，形成树状图
4. **条件过滤**：当j>i/2时触发：
   - 屏幕显示"2*j>i"警告
   - j沿紫色路径回退，直到满足2*j≤i时触发绿光
5. **乘积更新**：右侧LED屏显示实时乘积，更新时播放升级音效

**交互控制**：
- 速度滑块：调节单步/自动播放速度
- 模式切换：对比暴力法（龟速）与优化法（闪电）
- 数据视角：切换显示cnt数组/fail树结构

**技术实现**：  
```javascript
// 伪代码示例
function drawFrame() {
  drawPixelString(s); // 绘制像素字符串
  if(phase == 1) { 
    drawArrow(i, 'blue'); // 第一阶段蓝色指针
    drawArrow(j, 'yellow');
    if(s[i] == s[j+1]) {
      playSound('ding');
      drawConnection(j, j+1); // 显示匹配连线
    }
  } else {
    highlight(j, 'red'); 
    if(2*j > i) {
      playSound('warning');
      while(2*j > i) {
        j = next[j]; // 回退动画
        drawPath(j, 'purple');
      }
      playSound('success');
    }
  }
}
```

---

#### 6. 拓展练习与相似问题思考
**通用技巧迁移**：
1. `cnt数组递推`思想可用于AC自动机的fail树统计
2. `指针调整`方法适用于所有带条件约束的KMP变种
3. `均摊复杂度分析`在滑窗类问题中广泛适用

**洛谷推荐**：
1. **P3375 【模板】KMP**  
   → 巩固next数组基础应用
2. **P3435 [POI2006]OKR-Periods**  
   → 练习最大周期边界计算
3. **P3193 [HNOI2008]GT考试**  
   → 进阶KMP与动态规划结合

---

#### 7. 学习心得与经验分享
> **Orion545的调试经验**："在初次实现时，忽略j指针回退的均摊特性会导致TLE。通过记录fail树深度，验证了O(n)复杂度"

> **Kay的总结**：  
> 1. 树形思维是理解KMP高级应用的关键
> 2. 双指针移动中蕴含单调性优化
> 3. 初始化陷阱（如cnt[1]=1）需特别注意
> 
> "真正掌握算法需要理解其灵魂而非模板" —— 多思考fail树的拓扑关系！

---

通过本指南，希望大家不仅学会解决此题，更能领悟KMP算法的设计哲学。下次遇到字符串匹配问题时，记得像侦探一样寻找"线索链"哦！🚀

---
处理用时：218.64秒
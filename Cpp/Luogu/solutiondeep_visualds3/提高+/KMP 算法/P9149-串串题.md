# 题目信息

# 串串题

## 题目描述

给定长度分别为 $n,m$ 的整数序列 $A,B$ 和常数 $W,d$，序列从 $1$ 开始标号，保证 $A_i,B_i \in [1,W]$。

容易发现，我们有 $\binom{W}{d}$ 种方案选择 $[1,W]$ 中的 $d$ 个互不相同的整数。

对于每一种选择的方案，我们删去 $A$ 中出现的对应的 $d$ 种整数，令此时序列 $B$ 在序列 $A$ 中的出现次数为这次选择方案的权值。

你需要求所有的选择方案的权值和，对 ${10}^9+7$ 取模。

若对题意有疑问，请阅读样例及样例解释。

注：$\binom{a}{b}$ 表示组合数，含义为在 $a$ 个物品中**无序**地选择出 $b$ 个物品的方案数。

**请注意：我们并不会删除序列 $\bm{B}$ 中出现的对应整数。**

## 说明/提示

**【样例解释】**

在样例的第一组数据中：

1. 如果我们选择删去 $A$ 中的字符 $1$，$A$ 将变为 $\{2\}$，此时 $B$ 在 $A$ 中的出现次数为 $0$。
1. 如果我们选择删去 $A$ 中的字符 $2$，$A$ 将变为 $\{1,1,1\}$，此时 $B$ 在 $A$ 中的出现次数为 $2$。
1. 如果我们选择删去 $A$ 中的字符 $3$，$A$ 将变为 $\{1,1,2,1\}$，此时 $B$ 在 $A$ 中的出现次数为 $1$。

因此，第一组数据的答案为 $0+2+1=3$。

**再次提醒：我们并不会删除序列 $\bm{B}$ 中出现的对应整数。**

---

**【数据范围】**

对于 $100\%$ 的数据，$1 \le n,m,W \le {10}^6$，$1 \le d, A_i, B_j \le W$，$1 \le T \le 5$。

**本题采用捆绑测试且开启子任务依赖！**

| 子任务 | $n \le$ | $m \le$ | $W \le$ | 特殊性质 | 分数 | 依赖 |
| - | - | - | - | - | - | - |
| 1 | $10$ | $10$ | $5$ | | $10$ | \ |
| 2 | $1000$ | $1000$ | $5$ | | $20$ | 子任务 1 |
| 3 |  | | | A | $15$ | \ |
| 4 |  | | | B | $25$ | \ |
| 5 | | | | | $30$ | 子任务 1、2、3、4 |

特殊性质 A：保证 $d=1$。

特殊性质 B：令 $c$ 表示仅在序列 $A$ 中出现，而不在序列 $B$ 中出现的数字总数。保证 $c \le 5$。

## 样例 #1

### 输入

```
2
4 2 3 1
1 1 2 1
1 1
8 3 4 1
1 2 3 1 2 3 1 2
1 2 1
```

### 输出

```
3
2
```

# AI分析结果


### 💡 Kay的C++算法解析：串串题 深入学习指南 💡

<introduction>
今天我们来分析“串串题”这道C++编程题。本指南将帮助大家理解如何高效统计所有删除方案下B在A中的出现次数之和，核心涉及字符串匹配和组合数学技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：「字符串匹配」与「组合计数」

🗣️ **初步分析**：
> 解决本题需掌握两个核心技巧：  
> **① KMP字符串匹配**：像侦探一样在A中精准定位B的出现位置  
> **② 组合计数**：用数学公式高效计算方案数，类似挑选冰淇淋口味组合  

在本题中，**关键流程**分三步：  
1. 提取A中与B相关的关键元素形成新序列C  
2. 用KMP在C中匹配B，记录所有成功匹配的区间  
3. 对每个匹配区间：  
   - 统计区间内非关键元素种类数t  
   - 贡献值为组合数C(c-t, d-t)，其中c是非关键元素总数  

**可视化设计思路**：  
- 用8位像素风网格展示A序列，关键元素显示为金色砖块  
- KMP匹配时显示红色探测箭头移动，成功匹配时触发“叮”音效  
- 双指针滑动区间时，下方显示实时统计的t值变化  
- 组合数计算时出现像素化公式浮动特效  

---

## 2. 精选优质题解参考

<eval_intro>
基于思路清晰度、代码规范性和算法优化，精选3份优质题解（评分≥4★）：
</eval_intro>

**题解一（syzf2222）**
* **点评**：思路直击要害，将问题分解为匹配+计数两个阶段。代码采用标准KMP框架，双指针维护区间内元素种类的技巧高效简洁。亮点在于边界处理（清空b[m+1]）和组合数预计算，实践时可直接用于竞赛。变量命名规范（如c表非关键元素总数），空间复杂度优化至O(n)。

**题解二（Demeanor_Roy）**
* **点评**：逻辑推导严谨，创新性地提出“关键元素”概念降低理解门槛。代码模块化出色（分离KMP初始化/匹配/统计），桶计数维护t值的手法极具教学价值。亮点在于完整处理了子任务依赖，组合数计算封装为独立函数提升复用性。

**题解三（OrezTsim）**
* **点评**：采用Z函数替代KMP展现多解法思维，哈希加速匹配过程。亮点在于vector动态管理关键元素位置，避免大数组浪费空间。桶计数时通过`resize`控制内存，虽有小坑（需先读入w），但优化思路值得学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大难点：
</difficulty_intro>

1.  **关键元素过滤与匹配定位**
    * **分析**：B中元素不可删除是解题基石。优质解法均先提取A中关键元素形成新序列，消除无关元素干扰。KMP/Z函数在此阶段精确锁定匹配位置，类似在迷宫中用金线标记路径。
    * 💡 **学习笔记**：序列预处理可大幅降低问题复杂度

2.  **动态维护区间元素种类**
    * **分析**：匹配区间内的非关键元素种类数t直接影响组合数。双指针+桶计数是通用解法：右移时元素入桶，左移时出桶，通过桶值变化动态维护t。如同用滑动窗口扫描宝藏种类。
    * 💡 **学习笔记**：双指针是维护连续区间统计量的利器

3.  **组合数公式的转换应用**
    * **分析**：贡献值C(c-t, d-t)需理解其物理意义：强制删除t种元素后，剩余选择的自由组合。优质题解均预计算阶乘逆元加速，避免重复计算。
    * 💡 **学习笔记**：组合数学中“强制选择”模型可转化为降维选择

### ✨ 解题技巧总结
<summary_best_practices>
从本题提炼的通用技巧：
</summary_best_practices>
- **问题降维**：通过关键元素提取，将字符串匹配与组合计数解耦
- **增量维护**：双指针滑动时仅更新变化量而非重新计算
- **边界防御**：清空B[m+1]避免越界，预置A[n+1]=0防止未定义行为
- **数学优化**：预处理阶乘逆元，将组合数计算降至O(1)

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看综合优质题解提炼的通用实现框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：融合syzf2222的KMP框架与Demeanor_Roy的桶计数技巧，添加注释说明关键步骤
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10, mod = 1e9 + 7;

// 预处理阶乘逆元（组合数计算用）
int fct[N], inv[N], finv[N];
void init_comb() {
    fct[0] = finv[0] = 1;
    for (int i = 1; i < N; ++i) {
        fct[i] = 1LL * fct[i - 1] * i % mod;
        inv[i] = i == 1 ? 1 : mod - 1LL * mod / i * inv[mod % i] % mod;
        finv[i] = 1LL * finv[i - 1] * inv[i] % mod;
    }
}
int C(int c, int k) { 
    if (c < 0 || k < 0 || k > c) return 0;
    return 1LL * fct[c] * finv[k] % mod * finv[c - k] % mod;
}

int main() {
    init_comb();
    int T; cin >> T;
    while (T--) {
        int n, m, w, d, c = 0;
        cin >> n >> m >> w >> d;
        vector<int> A(n + 1), B(m + 1), p;
        vector<bool> inB(w + 1, false);

        // 标记B中元素并统计非关键元素数c
        for (int i = 1; i <= n; ++i) cin >> A[i];
        for (int i = 1; i <= m; ++i) {
            cin >> B[i];
            if (!inB[B[i]]) inB[B[i]] = true;
        }
        for (int i = 1; i <= w; ++i) 
            if (!inB[i]) c++;

        // 提取A中关键元素位置序列p
        for (int i = 1; i <= n; ++i)
            if (inB[A[i]]) p.push_back(i);

        // KMP预处理next数组
        vector<int> nxt(m + 1);
        for (int i = 2, j = 0; i <= m; ++i) {
            while (j && B[i] != B[j + 1]) j = nxt[j];
            if (B[i] == B[j + 1]) j++;
            nxt[i] = j;
        }

        // 双指针统计
        vector<int> cnt(w + 1, 0);
        int ans = 0, t = 0, L = p.size();
        for (int i = 0, j = 0, l = 1, r = 0; i < L; ++i) {
            // 右指针移动：扩展区间
            while (r < p[i]) {
                r++;
                if (!inB[A[r]]) {
                    if (cnt[A[r]]++ == 0) t++; // 新增种类
                }
            }
            // KMP匹配
            while (j && A[p[i]] != B[j + 1]) j = nxt[j];
            if (A[p[i]] == B[j + 1]) j++;
            
            if (j == m) { // 成功匹配
                // 左指针移动：收缩至匹配区间
                while (l < p[i - m + 1]) {
                    if (!inB[A[l]]) {
                        if (--cnt[A[l]] == 0) t--; // 减少种类
                    }
                    l++;
                }
                ans = (ans + C(c - t, d - t)) % mod; // 贡献组合数
            }
        }
        cout << ans << endl;
    }
    return 0;
}
```
* **代码解读概要**：
> 1. **预处理阶段**：标记B中元素 → 计算非关键元素数c → 提取A中关键元素位置  
> 2. **KMP阶段**：构建next数组 → 在关键元素序列上匹配B  
> 3. **双指针阶段**：滑动窗口统计区间内非关键元素种类数t  
> 4. **组合计数**：对每个成功匹配区间计算C(c-t, d-t)并累加  

---
<code_intro_selected>
优质题解核心技巧片段赏析：
</code_intro_selected>

**题解一（syzf2222）**
* **亮点**：边界处理严谨（清空B[m+1]），组合数预计算提升效率
* **核心代码片段**：
```cpp
// 清空边界防止越界
a[n+1]=b[m+1]=0;
// KMP匹配核心
for(int i=1,j=0;i<=L;i++) {
    while(j&&a[p[i]]!=b[j+1]) j=nxt[j];
    if(a[p[i]]==b[j+1]) j++;
    if(j==m) { // 匹配成功
        // 双指针维护区间
        while(r<p[i]) { ... } // 右扩
        while(l<p[i-m+1]) { ... } // 左缩
        ans = (ans + C(c-t, d-t)) % mod;
    }
}
```
* **代码解读**：
> - `a[n+1]=b[m+1]=0` 防御性编程，避免KMP越界  
> - KMP匹配时直接使用关键元素位置序列`p`  
> - 匹配成功后立即通过双指针锁定区间`[p[i-m+1], p[i]]`  
> - 桶计数动态维护`t`（区间内非关键元素种类）  

* 💡 **学习笔记**：防御性边界处理是竞赛编程的关键习惯

**题解二（Demeanor_Roy）**
* **亮点**：桶计数增量维护技巧，代码模块清晰
* **核心代码片段**：
```cpp
for(int i=1,j=0,l=1,r=0;i<=L;i++) {
    // 右指针移动
    while(r<p[i]) {
        if(vis[a[r]]) continue;
        if(++cnt[a[r]] == 1) t++; // 桶计数
    }
    // KMP匹配（略）
    if(j==m) {
        // 左指针移动
        while(l<p[i-m+1]) {
            if(!vis[a[l]]) 
                if(--cnt[a[l]]==0) t--; // 桶减少
            l++;
        }
        ans = (ans + C(c-t, d-t)) % mod;
    }
}
```
* **代码解读**：
> - 右指针移动时：当元素`a[r]`首次出现(`cnt[]==1`)，非关键元素种类`t++`  
> - 左指针移动时：当元素计数归零(`cnt[]==0`)，种类`t--`  
> - 通过`vis[]`数组快速过滤关键元素  

* 💡 **学习笔记**：桶计数实现种类统计需关注0→1和1→0的临界变化

**题解三（OrezTsim）**
* **亮点**：Z函数替代KMP，哈希加速匹配
* **核心代码片段**：
```cpp
ull H = 0; // B的哈希值
for(int i=1;i<=m;i++) H = H*bas + b[i];

// 计算Z函数
vector<int> Z(m+1);
for(int i=2,j=0;i<=m;i++) {
    if(j+Z[j] > i) Z[i] = min(Z[i-j], j+Z[j]-i);
    else while(B[i+Z[i]] == B[1+Z[i]]) Z[i]++;
    if(i+Z[i] > j+Z[j]) j = i;
}

// 匹配阶段
ull cur_hash = 0;
for(int i=1;i<=L;i++) {
    cur_hash = cur_hash*bas + C[i];
    if(i>=m && cur_hash == H) { // 哈希匹配成功
        // 双指针统计t（略）
        ans += C(c-t, d-t);
    }
}
```
* **代码解读**：
> - 预计算B的哈希值`H`用于快速比对  
> - Z函数计算中`j+Z[j]>i`时直接复用之前结果，优化效率  
> - 哈希匹配避免传统KMP的指针回溯  

* 💡 **学习笔记**：哈希匹配适合无需回溯的场景，但需注意碰撞风险

---

## 5. 算法可视化：像素动画演示（核心部分）

<visualization_intro>
设计8位像素风动画演示KMP匹配与双指针联动过程，帮助直观理解算法核心：
</visualization_intro>

* **主题**："算法勇者闯关记"（复古RPG风格）
* **核心演示**：KMP在关键元素序列上匹配B，双指针动态统计非关键元素种类

* **动画帧步骤**：
  1. **场景初始化**：
      - 上方网格：展示A序列（关键元素金砖，非关键元素灰砖）
      - 中间窗口：显示提取的关键元素序列C
      - 底部控制台：步进/暂停/速度滑块按钮
      - 背景音乐：FC风格8-bit循环BGM

  2. **KMP匹配演示**：
      - 红色箭头在C序列上移动（当前比较位置）
      - 绿色箭头显示next数组回溯位置
      - 匹配成功时：触发"叮！"音效，匹配区间闪烁金光
      - 旁白提示："比较位置i：B[j+1]匹配失败，根据next回溯到j=3"

  3. **双指针联动**：
      - 成功匹配后，屏幕分裂显示原A序列：
        * 蓝色左指针(l)与红色右指针(r)在A序列上滑动
        * 桶计数面板：实时显示各元素计数和当前t值
      - 指针移动时：
        * 右指针(r)右移：新增元素升起→落入对应桶，触发"噗"音效
        * 左指针(l)右移：元素从桶中消失，触发"啵"音效
      - 旁白提示："区间[2,5]内非关键元素：苹果×2，香蕉×1 → t=2"

  4. **组合数计算**：
      - 像素化公式浮空显示：$\binom{c-t}{d-t} = \binom{5-2}{3-2}=3$
      - 贡献值累加时：数字跳动+金币音效

  5. **通关效果**：
      - 所有匹配处理完后：放烟花+胜利音效
      - 显示最终答案：$\text{ans}=3$

* **技术实现**：
  - Canvas绘制网格和指针动画
  - 音效触发：关键操作时通过Web Audio API播放8-bit音效
  - 数据结构可视化：桶用像素方块堆叠表示，计数显示在顶部

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的字符串匹配与组合计数技巧后，可挑战以下变形题：
</similar_problems_intro>

1. **洛谷 P3375** - KMP字符串匹配
   * 🗣️ **推荐理由**：巩固KMP基础实现，理解next数组本质

2. **洛谷 P1496** - 火烧赤壁
   * 🗣️ **推荐理由**：双指针维护区间统计量的经典应用

3. **洛谷 P3223** - 组合数学问题
   * 🗣️ **推荐理由**：进阶组合计数训练，包含模逆元等技巧

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验总结：
</insights_intro>

> **参考经验（syzf2222）**：  
> "KMP匹配时访问B[m+1]导致越界，初始化b[m+1]=0解决"  
> **Kay点评**：  
> 这是字符串算法的常见陷阱。调试时注意：  
> 1. 数组结尾预置结束符  
> 2. 模拟小数据测试边界  
> 3. 使用assert检查指针范围

---

<conclusion>
通过本次分析，大家应掌握字符串匹配与组合计数的协同应用。记住：复杂问题往往可拆解为预处理+匹配+统计三阶段。下次挑战见！💪
</conclusion>
```

---
处理用时：174.79秒
# 题目信息

# [THUPC 2018] 绿绿和串串

## 题目背景

绿绿和 Yazid 是好朋友。他们在一起做串串游戏。

## 题目描述

绿绿有一个由小写字母组成的非空字符串 $R$，但 Yazid 不知道它具体是什么。

我们定义**翻转**的操作：把一个串以最后一个字符作对称轴进行翻转复制。形式化地描述就是，如果他翻转的串为 $R$，那么他会将前 $\left| R\right|-1$ 个字符倒序排列后，插入到串的最后。

举例而言，串`abcd`进行翻转操作后，将得到`abcdcba`；串`qw`连续进行 **$2$ 次**翻转操作后，将得到`qwqwq`；串`z`无论进行多少次翻转操作，都不会被改变。

贪玩的绿绿进行了若干次（可能为 $0$ 次）翻转操作。

淘气的绿绿又展示出了一个非空串 $S$，并表示 $S$ 是**最终**的串 $R$ 的前缀。现在，他想考考 Yazid，**初始**的串 $R$ 的长度可能是多少。

Yazid 找到了正在参加清华校赛的你，请你来帮他解决这个问题。但聪明的 Yazid 发现，所有超过 $\left| S\right|$ 的整数都一定是 $R$ 的可能长度，因此你只需要告诉他不超过的 $\left| S\right|$ 的 $R$ 的可能长度即可。

为了帮助你理解问题，Yazid 还将对一些概念和记号做出解释：

- 对于一个串 $S$，$\left| S\right|$ 表示的是该串的长度。
- 对于一个串 $S$，我们定义串 $T$ 是它的前缀，当且仅当 $\left| T\right|\leq\left| S\right|$，且对于任意整数 $i$ 满足 $1\leq i\leq\left| T\right|$，都有 $T$ 的左起第 $i$ 个字符与 $S$ 的左起第 $i$ 个字符相同。（形象地理解，即 $T$ 在 $S$ 的前部出现）
  - 如：`abc`是`abcdefg`的前缀，`aba`**不**为`abba`的前缀，`z`为`z`的前缀，空串为任意一个串的前缀。

## 说明/提示

### 数据范围

保证 $\left| S\right|\leq 10^6$，$\sum\left| S\right|\leq 5\times 10^6$。

$\sum\left| S\right|$ 表示的是单个测试点中所有数据 $\left| S\right|$ 的总和。

### 提示

* 读入规模较大，请注意读入效率。

* 样例中的最后一个字符串是什么意思呢？

### 版权信息

来自 2018 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2018），感谢 [Pony.ai](http://pony.ai/) 对此次比赛的支持。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2018> 查看。

## 样例 #1

### 输入

```
4
abcdcb
qwqwq
qaqaqqq
carnation```

### 输出

```
4 6
2 3 4 5
6 7
9```

# AI分析结果

# 💡 Kay的C++算法解析：[THUPC2018] 绿绿和串串 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：回文串处理（Manacher算法） + 递推合法性判断


🗣️ **初步分析**：  
想象你有一张写着字符串的纸条，每次“翻转”操作就像**以最后一个字符为折痕，把前面的部分翻过来粘在后面**——比如“abcd”对折后变成“abcdcba”（前面的“abc”反转成“cba”，接在“d”后面）。题目要求找出所有初始纸条长度（不超过S的长度），使得对折若干次后的大纸条，前面部分正好是S。  

核心秘密：**每次翻转都会生成一个以原串最后一个字符为中心的回文串**！比如“qw”对折一次是“qwq”（回文），再对折是“qwqwq”（依然以最后一个“q”为中心回文）。因此，问题转化为：**找S的所有前缀，这些前缀能通过多次回文扩展，最终覆盖整个S**。  

要高效找所有回文中心的最长回文半径，我们需要**Manacher算法**（它能在O(n)时间内处理所有奇数长度的回文串）。之后，我们从S的末尾往前“倒推”：如果一个位置的回文能覆盖到末尾，或者它的回文右边界对应的位置已经合法，那么这个位置也合法。  

**可视化设计思路**：我们用8位像素风格模拟字符串“qwqwq”的处理过程——  
- 用不同颜色的像素块表示原字符串（比如“q”是蓝色，“w”是绿色），插入的“#”用灰色；  
- Manacher计算时，用闪烁的黄色框标记当前处理的回文中心，红色框标记回文边界；  
- 递推合法性时，用“点亮灯泡”动画标记合法位置（从后往前依次点亮“5→4→3→2”）；  
- 关键操作（如计算回文半径、标记合法）伴随“叮”的像素音效，最终输出结果时播放“胜利”音效。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，帮你快速掌握核心逻辑：
</eval_intro>


### 题解一（来源：pldzy，赞47）  
* **点评**：这份题解把“翻转→回文”的关系讲得最透彻！作者用“末尾回文串”的概念连接翻转操作——要找最长翻转子串，等价于找最短的末尾回文串（去掉一半就是原串）。代码里Manacher模板非常标准，预处理时插入“#”处理奇数回文，然后用`vis`数组从后往前标记合法位置。最棒的是作者解答了读者的疑问（比如为什么判`i+len[i]-2`而不是`i+len[i]-1`），帮你避开细节坑。


### 题解二（来源：jdsb，赞15）  
* **点评**：思路更简洁！作者直接点出“合法前缀的回文半径要么覆盖末尾，要么左边界到开头且右边界合法”。代码里Manacher的实现更紧凑，`vis`数组的判断条件（`i+p[i]==n`或`vis[i+p[i]]&&i-p[i]==1`）精准对应两种合法情况。变量命名（如`p[i]`表示回文半径）很直观，适合新手模仿。


### 题解三（来源：feecle6418，赞8）  
* **点评**：另辟蹊径用**哈希**解决！作者把问题转化为“判断子串是否回文”，用正向和反向哈希快速比较（比如`GetHash(i,n)`和`GetHash(i,2i-n)`是否相等）。这种思路不需要Manacher，适合理解回文本质，但时间复杂度略高（O(n)预处理+O(n)判断）。代码里的哈希模板很通用，能迁移到其他字符串问题。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是“把翻转转化为回文”，以下3个难点是绕不开的坎：
</difficulty_intro>


### 1. 难点1：理解“翻转操作”与“回文串”的关系  
* **分析**：翻转操作的本质是**构造以原串最后一个字符为中心的回文串**。比如原串是`R`，翻转后是`R + reverse(R[1..|R|-1])`，这正好是一个以`R`最后一个字符为中心的回文串（长度为`2|R|-1`）。因此，“R翻转若干次后前缀是S”等价于“S是R经过多次回文扩展后的前缀”。  
* 💡 **学习笔记**：翻转=回文扩展，抓住这个等价关系，问题就转化为回文串处理！


### 2. 难点2：用Manacher快速求回文半径  
* **分析**：Manacher算法的核心是**利用已有的回文信息避免重复比较**。比如，若当前位置`i`在之前的回文区间`[l,r]`内，那么`i`的回文半径至少是`min(对称位置的回文半径, r-i+1)`。这样就能把时间复杂度从O(n²)降到O(n)。  
* 💡 **学习笔记**：Manacher的关键是“对称复用”，预处理插入`#`是为了统一处理奇数长度的回文！


### 3. 难点3：从后往前递推合法性  
* **分析**：合法位置需要满足两种情况——  
  1. **直接覆盖**：回文右边界到S末尾（比如`i+p[i]==n`）；  
  2. **间接覆盖**：回文左边界到S开头（`i-p[i]==1`），且回文右边界对应的位置合法（`vis[i+p[i]]==1`）。  
  从后往前递推的原因是：大的合法位置能“带动”小的合法位置（比如`5`合法→`3`合法→`2`合法）。  
* 💡 **学习笔记**：递推方向很重要！从后往前能避免重复计算，像多米诺骨牌一样“倒推”合法位置。


### ✨ 解题技巧总结  
- **等价转化**：把陌生的“翻转操作”转化为熟悉的“回文串”问题；  
- **算法选择**：Manacher是处理回文串的“瑞士军刀”，能高效求所有回文半径；  
- **递推策略**：从结果倒推条件（从后往前），简化逻辑；  
- **细节处理**：预处理插入`#`统一奇数回文，避免边界判断错误。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份**综合优质题解的核心实现**，它结合了Manacher的标准模板和递推合法性的简洁逻辑：
</code_intro_overall>


### 本题通用核心C++实现参考  
* **说明**：本代码基于pldzy和jdsb的题解，调整了变量命名和注释，更适合新手理解。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <cstring>
  #include <algorithm>
  using namespace std;

  const int MAXN = 1e6 + 10;  // 原字符串最大长度
  char s[MAXN], t[MAXN * 2];  // t是插入#后的字符串
  int len[MAXN * 2];          // len[i]表示t中以i为中心的回文半径
  bool vis[MAXN];             // vis[i]表示原串中以i为中心的前缀是否合法

  // 预处理：将原串s插入#，变成t（处理奇数回文）
  void preprocess(int n) {
      t[0] = '~'; t[1] = '#';
      int cnt = 1;
      for (int i = 0; i < n; i++) {
          t[++cnt] = s[i];
          t[++cnt] = '#';
      }
      t[cnt + 1] = '%';  // 防止越界
  }

  // Manacher算法：计算t中每个位置的回文半径
  void manacher(int n) {
      int mx = 0, po = 0;  // mx是当前最长回文的右边界，po是中心
      for (int i = 1; i <= n; i++) {
          if (i <= mx) len[i] = min(mx - i, len[2 * po - i]);
          else len[i] = 1;
          // 扩展回文
          while (t[i + len[i]] == t[i - len[i]]) len[i]++;
          // 更新mx和po
          if (i + len[i] > mx) {
              mx = i + len[i] - 1;
              po = i;
          }
      }
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(0);
      int T;
      cin >> T;
      while (T--) {
          cin >> s;
          int n = strlen(s);
          preprocess(n);
          int m = 2 * n + 1;  // t的长度（插入#后）
          manacher(m);
          memset(vis, 0, sizeof(vis));

          // 从后往前递推合法性
          for (int i = n; i >= 1; i--) {
              // 原串i对应t中的位置是2*i（因为t的结构是#s[0]#s[1]#...）
              int pos = 2 * i;
              int r = len[pos] - 1;  // 原串中以i为中心的回文半径（不含中心）
              if (i + r == n) {  // 回文覆盖到末尾
                  vis[i] = true;
              } else if (vis[i + r] && i - r == 1) {  // 回文到开头且右边界合法
                  vis[i] = true;
              }
          }

          // 输出所有合法长度
          for (int i = 1; i <= n; i++) {
              if (vis[i]) cout << i << " ";
          }
          cout << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **预处理**：把原串`s`插入`#`变成`t`（比如`s=qwqwq`→`t=#q#w#q#w#q#`），统一处理奇数回文；  
  2. **Manacher**：计算`t`中每个位置的回文半径`len[i]`；  
  3. **递推合法性**：原串中的位置`i`对应`t`中的`2*i`，计算其回文半径`r`，判断是否覆盖末尾或右边界合法；  
  4. **输出结果**：遍历`vis`数组，输出所有合法长度。


### 针对优质题解的片段赏析

#### 题解一（pldzy）：Manacher模板与递推  
* **亮点**：标准的Manacher实现+清晰的递推逻辑。  
* **核心代码片段**：  
  ```cpp
  for (int i = cnt; i >= 1; --i) {
      if (i + len[i] - 1 == cnt) vis[i] = 1;  // 覆盖末尾
      else if (vis[i + len[i] - 2] && i == len[i]) vis[i] = 1;  // 到开头且右边界合法
  }
  ```
* **代码解读**：  
  - `i + len[i] - 1 == cnt`：判断回文右边界是否到`t`的末尾（对应原串末尾）；  
  - `i == len[i]`：判断回文左边界是否到`t`的开头（对应原串开头）；  
  - `i + len[i] - 2`：因为`t`中的回文边界是`#`，所以右边界的实际位置要减2。  
* 💡 **学习笔记**：处理插入`#`后的字符串时，要注意原串和`t`的位置对应关系！


#### 题解二（jdsb）：简洁的Manacher实现  
* **亮点**：用`p[i]`直接表示原串中以`i`为中心的回文半径，无需预处理。  
* **核心代码片段**：  
  ```cpp
  for (int i = 1, mid = 0, mx = 0; i <= n; ++i) {
      p[i] = (i < mx) ? min(mx - i, p[2 * mid - i]) : 1;
      while (s[i + p[i]] == s[i - p[i]]) p[i]++;
      if (i + p[i] > mx) mx = i + p[i], mid = i;
  }
  ```
* **代码解读**：  
  - `i < mx`：如果当前位置在之前的回文区间内，复用对称位置的回文半径；  
  - `s[i + p[i]] == s[i - p[i]]`：扩展回文，直到字符不相等；  
  - `mx = i + p[i]`：更新最长回文的右边界。  
* 💡 **学习笔记**：Manacher的核心是“对称复用”，这行代码`p[i] = min(mx - i, p[2 * mid - i])`是关键！


#### 题解三（feecle6418）：哈希判断回文  
* **亮点**：不用Manacher，用哈希快速比较子串是否回文。  
* **核心代码片段**：  
  ```cpp
  long long GetHash(int l, int r) {
      if (l > r) return GetHash(2 * n + 1 - l, 2 * n + 1 - r);
      return (hsh[r] - hsh[l - 1] * bc[r - l + 1] % mod + mod) % mod;
  }
  ```
* **代码解读**：  
  - `l > r`：如果查询的是反转后的子串，直接转化为正向子串的哈希；  
  - `hsh[r] - hsh[l-1] * bc[r-l+1]`：计算子串`s[l..r]`的哈希值（前缀哈希法）。  
* 💡 **学习笔记**：哈希是处理字符串相等的“万能工具”，但要注意模数和基数的选择（避免碰撞）！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们用**8位FC红白机风格**，模拟字符串“qwqwq”的处理过程，帮你直观“看”到算法的每一步！
</visualization_intro>


### 动画演示主题  
**像素探险家找合法前缀**：把字符串“qwqwq”比作一条由蓝色（q）、绿色（w）像素块组成的“道路”，探险家（黄色像素点）要找出所有能“走到终点”的起点。


### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧显示原字符串“q w q w q”（每个字符是16x16的像素块）；  
   - 右侧显示预处理后的字符串“# q # w # q # w # q #”（灰色#，彩色字符）；  
   - 底部控制面板有“单步”“自动”“重置”按钮，速度滑块（1x~5x），以及“算法说明”文字框。

2. **Manacher计算回文半径**：  
   - 探险家从左到右遍历预处理后的字符串，每到一个位置，用**黄色框**标记当前中心；  
   - 扩展回文时，用**红色框**标记回文边界（比如中心是“q”（位置3），扩展到左右各2步，红色框覆盖“# q # w #”）；  
   - 每扩展一步，播放“叮”的音效，回文半径显示在中心下方（比如“r=2”）。

3. **递推合法性判断**：  
   - 探险家从原串末尾（第5位“q”）开始，往回走：  
     - 第5位：回文半径是2，覆盖到末尾（5+2=7？不，原串长度是5，5+2=7超过，所以合法），**点亮绿色灯泡**；  
     - 第4位：回文半径是1，右边界是5（合法），且左边界是3（不是开头），不合法；  
     - 第3位：回文半径是2，右边界是5（合法），且左边界是1（开头），**点亮绿色灯泡**；  
     - 第2位：回文半径是1，右边界是3（合法），且左边界是1（开头），**点亮绿色灯泡**；  
     - 第1位：回文半径是1，右边界是2（合法），但左边界是0（不是开头），不合法。

4. **结果输出**：  
   - 合法位置（2、3、5）的像素块**闪烁金色**，屏幕上方显示“合法长度：2 3 5”；  
   - 播放“胜利”音效（FC风格的上扬音调），底部弹出“完成！”的文字框。


### 交互设计  
- **单步执行**：点击“单步”按钮，探险家走一步，显示当前操作的文字说明（比如“处理位置3，回文半径2”）；  
- **自动播放**：拖动速度滑块调整速度，探险家用动画速度遍历，关键步骤暂停1秒；  
- **重置动画**：点击“重置”，回到初始状态，重新开始演示。


### 设计理由  
- **像素风格**：复古FC风格能唤起你的游戏记忆，降低学习压力；  
- **颜色标记**：用不同颜色区分字符、回文边界、合法位置，直观易懂；  
- **音效提示**：关键操作的音效能强化记忆（比如“叮”对应回文扩展，“胜利”对应合法结果）；  
- **游戏化元素**：探险家的“探险”过程像闯关，完成后有成就感，激发学习兴趣。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
Manacher算法是处理回文串的“神器”，掌握它能解决很多字符串问题！
</similar_problems_intro>


### 通用思路迁移  
- **回文子串计数**：统计字符串中所有回文子串的数量（比如“abc”有3个回文子串：a、b、c）；  
- **最长回文子串**：找字符串中最长的回文子串（比如“babad”的最长回文是“bab”或“aba”）；  
- **回文自动机**：处理多个回文串的问题（比如统计不同回文子串的数量）。


### 洛谷练习推荐  
1. **洛谷 P3805** - 【模板】Manacher算法  
   * 🗣️ **推荐理由**：最经典的Manacher模板题，帮你巩固算法的基本实现。  
2. **洛谷 P4555** - 最长双回文串  
   * 🗣️ **推荐理由**：要求把字符串分成两个回文子串，需要结合Manacher和前缀/后缀预处理。  
3. **洛谷 P1659** - 回文子串个数  
   * 🗣️ **推荐理由**：统计所有回文子串的数量，考验你对Manacher回文半径的理解。  
4. **洛谷 P5555** - 秩序魔咒  
   * 🗣️ **推荐理由**：结合回文和动态规划，难度中等，适合拓展思维。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的作者心得能帮你避开“踩坑”，以下是我摘录的精华：
</insights_intro>


> **参考经验（来自pldzy）**：“我一开始在判断`i+len[i]-1`还是`i+len[i]-2`时卡了很久，后来发现插入`#`后的回文边界是特殊字符，所以要减2。”  
> **点评**：这提醒我们处理预处理后的字符串时，一定要注意位置对应关系！比如原串中的位置`i`对应预处理后的`2*i`，回文边界的特殊字符要跳过。


> **参考经验（来自jdsb）**：“从后往前递推的思路是我看样例想出来的——样例`qwqwq`的合法长度是2、3、4、5，从后往前正好能‘传递’合法性。”  
> **点评**：样例是最好的老师！遇到问题时，先手动模拟样例，往往能找到思路。


## 8. 总结与鼓励

本次分析的“绿绿和串串”题，核心是**把翻转操作转化为回文串**，并用Manacher算法高效处理。记住：  
- 翻转=回文扩展，抓住等价关系；  
- Manacher的关键是“对称复用”，预处理插入`#`统一奇数回文；  
- 递推合法性要从后往前，像多米诺骨牌一样“倒推”。  

编程的乐趣在于“把复杂问题拆成简单步骤”，只要多练多想，你一定能掌握这些技巧！下次我们再一起挑战更难的字符串问题～💪

---
处理用时：178.03秒
# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果


# 💡 Kay的C++算法解析：最优贸易 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`分层图状态转移` 与 `强连通分量缩点`

🗣️ **初步分析**：
> 解决“最优贸易”这道题，关键在于理解并运用**分层图**或**强连通分量(SCC)缩点**技巧。简单来说，分层图就像把城市复制成三个平行世界：普通世界（未交易）、买入世界（已购水晶球）、卖出世界（已售出）。通过世界间的传送门（买入边权为负，卖出边权为正）模拟贸易过程。而SCC缩点则是将城市群压缩成超级节点，在无环地图上规划最优路线。

- **核心思路对比**：
  - *分层图*：将原图复制三层，通过层间边权变化（-w[i]表示买入，+w[i]表示卖出）映射贸易状态，SPFA求最长路
  - *SCC缩点*：用Tarjan算法将环缩成点，在DAG上DP计算路径最小值和最大利润

- **可视化设计**：
  - 采用**8位像素风格**（类似FC游戏），三层网格地图并列显示
  - 关键操作高亮：买入时蓝色闪烁（音效："叮"），卖出时金色闪烁（音效："金币声"）
  - 自动演示模式：AI角色按SPFA队列顺序遍历三层地图，实时显示路径利润

---

## 2. 精选优质题解参考

**题解一（fy1234567ok，分层图）**
* **点评**：思路创新性强，40行代码实现三层图状态转移。宏定义`t(x,i)`简化跨层索引是亮点。SPFA求最长路的实现简洁规范，变量命名清晰（如`d[]`表距离）。虽然SPFA理论最坏O(nm)，但本题价格值域小(≤100)，实际效率优秀。

**题解二（ctzm，Tarjan缩点）**
* **点评**：严谨处理hack数据，反图DFS验证终点可达性体现鲁棒性。SCC内维护`minCost/maxCost`的DP设计巧妙，代码中拓扑排序实现规范。特别适合处理含环的大规模数据，避免SPFA的不确定性。

**题解三（lcjqwq，Tarjan缩点）**
* **点评**：完整实现可达性检查，详细注释帮助理解缩点过程。DP状态转移`dp[v]=max(dp[v], maxCost[v]-minCost[v])`直观体现问题本质，实践参考价值高。

---

## 3. 核心难点辨析与解题策略

1. **状态定义与转移**
   * **分析**：贸易涉及"未买/已买/已卖"三状态。分层图用三层节点映射状态，SCC缩点在超级节点内维护极值
   * 💡 **学习笔记**：清晰的状态划分是复杂图论问题的突破口

2. **环的处理**
   * **分析**：环路可能导致无限交易。缩点解法通过Tarjan压缩SCC消除环，分层图依赖SPFA自然处理但需防负环
   * 💡 **学习笔记**：遇到环先考虑缩点，将图转为DAG简化问题

3. **终点可达性**
   * **分析**：必须保证卖出点可达终点。反图DFS从n点回溯标记有效点集，避免无效计算
   * 💡 **学习笔记**："终点可达"验证是路径类问题的通用校验手段

### ✨ 解题技巧总结
- **状态分解**：将交易拆解为独立操作（买入/卖出/移动）
- **数据结构选择**：分层图用邻接表，缩点用Tarjan+拓扑排序
- **边界处理**：初始化起点状态（分层图dis[1]=0，缩点dp[SCC1]=0）
- **调试技巧**：小规模数据手工模拟状态转移

---

## 4. C++核心代码实现赏析

**通用核心实现（分层图SPFA）**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+3; // 三层图空间：3倍n

vector<pair<int,int>> G[N*3]; // {to, weight}

void SPFA(int s){
    vector<int> dis(N*3, INT_MIN);
    queue<int> q;
    dis[s]=0; q.push(s);
    while(!q.empty()){
        int u=q.front(); q.pop();
        for(auto [v,w]:G[u]){
            if(dis[v] < dis[u]+w){ // 求最长路
                dis[v]=dis[u]+w;
                q.push(v);
    }}}
    cout<<max(0, dis[N*3-1]); // 第三层终点
}

int main(){
    int n,m; cin>>n>>m;
    for(int i=1,w;i<=n;i++){
        cin>>w;
        // 层间边：i(层0) -> i+n(层1) 权-w
        G[i].push_back({i+n, -w});
        // 层间边：i+n -> i+2n 权+w
        G[i+n].push_back({i+2*n, w});
    }
    // 层内移动（权0）
    while(m--){
        int u,v,t; cin>>u>>v>>t;
        for(int layer=0;layer<3;layer++)
            G[u+layer*n].push_back({v+layer*n, 0});
        if(t==2) // 双向边
            for(int layer=0;layer<3;layer++)
                G[v+layer*n].push_back({u+layer*n, 0});
    }
    SPFA(1); // 从第一层起点开始
}
```

**题解一核心片段（状态宏定义）**
```cpp
#define t(x,i) (x+i*n) // 映射到第i层

// 层间连接
G[t(i,0)].push_back({t(i,1), -w[i]});
G[t(i,1)].push_back({t(i,2), w[i]});

// SPFA从起点层0出发
SPFA(t(1,0));
cout<<d[t(n,2)]; // 终点在层2
```
**代码解读**：  
> 宏`t(x,i)`将三维状态压缩到一维数组，`x`为原节点，`i`为层号。SPFA在分层图上求最长路，最终抵达第三层（已卖出状态）的n节点。注意层间边权值设置：买入消耗资金（-w），卖出获得收益（+w）。

**题解二核心片段（Tarjan缩点）**
```cpp
// Tarjan求SCC
void tarjan(int u){
    low[u]=dfn[u]=++idx;
    stk.push(u); inStk[u]=true;
    for(int v:G[u]){
        if(!dfn[v]) tarjan(v), low[u]=min(low[u],low[v]);
        else if(inStk[v]) low[u]=min(low[u],dfn[v]);
    }
    if(low[u]==dfn[u]){
        int x; ++sccCnt;
        do{
            x=stk.top(); stk.pop();
            inStk[x]=false;
            belong[x]=sccCnt;
            minCost[sccCnt]=min(minCost[sccCnt], w[x]); // SCC内最小成本
            maxCost[sccCnt]=max(maxCost[sccCnt], w[x]); // SCC内最大售价
        }while(x!=u);
    }
}

// 反图DFS标记可达n的点
void dfs(int u){
    reachable[u]=true;
    for(int v:revG[u])
        if(!reachable[v]) dfs(v);
}
```
**代码解读**：  
> Tarjan递归过程中用`low/dfn`判断SCC，栈存储当前分量节点。缩点时记录每个SCC内的价格极值。反图DFS从终点n开始回溯，标记所有可达节点，确保后续DP的有效性。

---

## 5. 算法可视化：像素动画演示

**主题**：水晶球贸易大冒险（8-bit像素风）

**核心演示**：
- 三层并排网格地图：普通世界（绿）、买入世界（蓝）、卖出世界（金）
- 像素小人沿SPFA队列移动，关键操作触发特效：
  - **买入**：蓝光闪烁 + "叮"声，显示`-w[i]`
  - **卖出**：金光闪烁 + 金币声，显示`+w[i]`
  - **抵达终点**：烟花特效 + 胜利音乐，显示最终利润

**交互控制面板**：
```plaintext
[ 暂停 ] [ 单步 > ] [ 自动播放 ▸ ] 速度：▁▁▃▅▇
[ 显示SPFA队列 ] [ 显示当前利润 ] [ 算法对比模式 ]
```

**关键帧流程**：
1. **初始化**：三列16x16网格，起点1号城高亮
2. **层内移动**：小人沿白线移动，足迹残留淡出
3. **跨层传送**：
   - 买入：绿→蓝世界传送门漩涡动画
   - 卖出：蓝→金世界金币喷发动画
4. **数据结构可视化**：
   - 左下角显示SPFA队列（像素盒子）
   - 右下角动态更新各层dis值
5. **结果展示**：成功路径高亮，显示利润计算公式

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**：
- 分层图适用于带状态转移的路径问题（如：有K次特殊机会）
- SCC缩点+DAG上DP解决带环图最优路径问题

**推荐练习**：
1. **P2939 [USACO09OPEN]改造路**  
   🗣️ 分层图经典应用，K次机会将边权降0，巩固状态转移思想
   
2. **P4568 [JLOI2011]飞行路线**  
   🗣️ 分层图变体，理解"机会消耗"与状态维度的关系

3. **P3119 [USACO15JAN]草鉴定**  
   🗣️ SCC缩点+DP，练习反图构建与DAG上状态转移

---

## 7. 学习心得与经验分享

> **题解作者fy1234567ok提到**："分层图建模的关键在于将操作转化为状态转移边"  
> **Kay总结**：复杂的操作序列可映射为图层的跃迁，这是算法设计的降维思想

> **题解作者ctzm调试经验**："反图DFS验证终点可达性避免无效计算"  
> **Kay总结**：图论问题中"终点可达"验证与"起点可达"同等重要，这是避免WA的黄金法则

---

通过本次分析，我们掌握了两种解决最优贸易问题的核心方法：分层图的状态跃迁与缩点后的DAG规划。记住，算法设计的本质在于**问题状态的抽象**和**转移过程的优化**。继续加油，少年！💪🏻

---
处理用时：257.90秒
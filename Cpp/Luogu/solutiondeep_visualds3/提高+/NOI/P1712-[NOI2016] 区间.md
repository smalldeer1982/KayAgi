# 题目信息

# [NOI2016] 区间

## 题目描述

在数轴上有 $n$ 个闭区间从 $1$ 至 $n$ 编号，第 $i$ 个闭区间为 $[l_i,r_i]$ 。

现在要从中选出 $m$ 个区间，使得这 $m$ 个区间共同包含至少一个位置。换句话说，就是使得存在一个 $x$ ，使得对于每一个被选中的区间 $[l_i,r_i]$，都有 $l_i \leq x \leq r_i$ 。

对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。

区间 $[l_i,r_i]$ 的长度定义为 $(r_i-l_i)$ ，即等于它的右端点的值减去左端点的值。

求所有合法方案中最小的花费。如果不存在合法的方案，输出 $-1$。

## 说明/提示

#### 样例输入输出 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/qoddox9k.png)
 
 如图，当 $n=6$，$m=3$ 时，花费最小的方案是选取 $[3,5],[3,4],[1,4]$ 这三个区间，它们共同包含了 $4$ 这个位置，所以是合法的。其中最长的区间是 $[1, 4]$，最短的区间是 $[3, 4]$，所以它的花费是 $(4 - 1) - (4 - 3) = 2$。

#### 数据规模与约定

本题共 20 个测试点，各测试点信息如下表。
| 测试点编号 | $ n= $ | $ m= $ | $ l_i,r_i $ |
|:-:|:-:|:-:|:-:|
| 1 | $ 20 $ | $ 9 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 2 | $ 20 $ | $ 10 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 3 | $ 199 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 4 | $ 200 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 5 | $ 1000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 6 | $ 2000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 7 | $ 199 $ | $ 60 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 8 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 9 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 10 | $ 1999 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 11 | $ 2000 $ | $ 400 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 12 | $ 2000 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 13 | $ 30000 $ | $ 2000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 14 | $ 40000 $ | $ 1000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 15 | $ 50000 $ | $ 15000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 16 | $ 100000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 17 | $ 200000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 18 | $ 300000 $ | $ 50000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 19 | $ 400000 $ | $ 90000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 20 | $ 500000 $ | $ 200000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |

对于全部的测试点，保证 $1 \leq m \leq n$，$1 \leq n \leq 5 \times 10^5$，$1 \leq m \leq 2 \times 10^5$，$0 \leq l_i \leq r_i \leq 10^9$。

## 样例 #1

### 输入

```
6 3
3 5
1 2
3 4
2 2
1 5
1 4```

### 输出

```
2```

# AI分析结果


# 💡 Kay的C++算法解析：区间 深入学习指南 💡

> 今天我们来一起分析"区间"这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`排序 + 离散化 + 线段树 + 双指针（尺取法）`

🗣️ **初步分析**：
> 解决"区间"这道题的关键在于将问题分解为四个有序步骤：首先按长度排序区间（就像把不同长度的尺子整理好），接着离散化端点（将大地图压缩成小网格），然后用线段树动态监控覆盖情况（像智能计数器），最后用双指针扫描寻找最优解（像用可伸缩的尺子测量）。  
> - **核心难点**在于处理10^9的大范围坐标（需离散化）和高效维护覆盖计数（需线段树）。  
> - **可视化设计**将展示像素化的数轴网格，当双指针移动时，加入的区间会高亮显示（暖色调），移除的区间会淡化（冷色调）。覆盖次数达到m时触发金色闪光和胜利音效，像经典游戏《吃豆人》吃到能量球的效果。  
> - **复古游戏化**：设置"自动演示"模式时，算法会像《贪吃蛇AI》一样自主运行，伴随8-bit音效（加入区间：清脆"叮"声，覆盖达标：胜利旋律）。

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性和算法效率等维度，我为大家筛选了以下评分≥4星的优质题解：
</eval_intro>

**题解一（上进的z君）**
* **点评**：此解思路清晰直白，从排序、离散化到双指针步步推进。代码中变量`tree`、`add`命名规范，边界处理严谨（如`tree[1].max_val >= m`的判定）。亮点在于完整注释和工整缩进，特别适合初学者理解标准解法框架。

**题解二（wanglichao1121）**
* **点评**：最大亮点是采用**永久化标记**优化线段树（避免下传操作），使代码更简洁高效。虽然变量名稍简略（如`ma`），但`mid=(l+r)>>1`的位运算写法体现了竞赛风格。特别适合追求代码效率的学习者。

**题解三（EternalEpic）**
* **点评**：最具教学价值的是详细解析了**离散化常见错误**（如`lower_bound`返回值处理）。封装线段树结构体提升可读性，调试心得部分（如"离散化第一遍写错"）对实战有直接指导意义。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大关键难点，结合优质题解经验，我提炼出以下策略：
</difficulty_intro>

1.  **难点一：大范围坐标处理（离散化）**
    * **分析**：原始坐标达10^9级，需压缩映射到[1,2n]的整数。优质题解统一采用`sort+unique+lower_bound`三步法。**关键技巧**：去重后用`lower_bound`获取新坐标，注意返回索引从1开始。
    * 💡 **学习笔记**：离散化是空间压缩的利器，本质是建立有序映射。

2.  **难点二：高效维护覆盖次数**
    * **分析**：实时判断是否存在点被覆盖≥m次需O(1)查询。线段树维护区间最大值完美解决，但需注意：**懒惰标记下传**（上进的z君）或**永久化标记**（wanglichao1121）两种实现各有优势。
    * 💡 **学习笔记**：区间修改查询首选线段树，标记处理决定常数大小。

3.  **难点三：最小化长度差值**
    * **分析**：双指针移动时机决定最优解。**关键推导**：当右指针加入区间后覆盖达标时，左指针需不断右移（缩短区间）直至不达标，此时`ans = min(ans, len[r]-len[l-1])`。
    * 💡 **学习笔记**：尺取法适用序列满足单调性的场景。

### ✨ 解题技巧总结
<summary_best_practices>
通过对本题的深度分析，我总结出以下通用技巧：
</summary_best_practices>
- **技巧一：排序预处理**  
  对区间长度排序使双指针移动具有单调性，避免暴力搜索。
- **技巧二：离散化四步法**  
  `收集端点→排序→去重→映射`，注意端点需包含所有区间起止。
- **技巧三：线段树封装**  
  将`update/push_down`等操作封装，保持主逻辑清晰。
- **技巧四：边界防御**  
  特判无解情况（最终ans仍为INF时输出-1）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解优化的通用实现，包含完整解题框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：融合了排序预处理、离散化、线段树和双指针，边界处理完整。
* **完整核心代码**：
```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

const int MAXN = 500010;
const int INF = 0x3f3f3f3f;

struct Interval { int l, r, len; };
vector<int> disc;
Interval a[MAXN];

struct SegmentTree {
    struct Node { int max_val, lazy; } tree[MAXN<<3];
    
    void push_down(int rt) {
        if (!tree[rt].lazy) return;
        tree[rt<<1].lazy += tree[rt].lazy;
        tree[rt<<1|1].lazy += tree[rt].lazy;
        tree[rt<<1].max_val += tree[rt].lazy;
        tree[rt<<1|1].max_val += tree[rt].lazy;
        tree[rt].lazy = 0;
    }

    void update(int rt, int l, int r, int L, int R, int val) {
        if (L <= l && r <= R) {
            tree[rt].max_val += val;
            tree[rt].lazy += val;
            return;
        }
        push_down(rt);
        int mid = (l + r) >> 1;
        if (L <= mid) update(rt<<1, l, mid, L, R, val);
        if (R > mid) update(rt<<1|1, mid+1, r, L, R, val);
        tree[rt].max_val = max(tree[rt<<1].max_val, tree[rt<<1|1].max_val);
    }
} seg_tree;

int main() {
    // 输入与离散化
    int n, m; cin >> n >> m;
    for (int i=1; i<=n; i++) {
        cin >> a[i].l >> a[i].r;
        a[i].len = a[i].r - a[i].l;
        disc.push_back(a[i].l);
        disc.push_back(a[i].r);
    }
    sort(disc.begin(), disc.end());
    disc.erase(unique(disc.begin(), disc.end()), disc.end());
    for (int i=1; i<=n; i++) {
        a[i].l = lower_bound(disc.begin(), disc.end(), a[i].l) - disc.begin();
        a[i].r = lower_bound(disc.begin(), disc.end(), a[i].r) - disc.begin();
    }

    // 按长度排序
    sort(a+1, a+n+1, [](auto& x, auto& y){ return x.len < y.len; });

    // 双指针扫描
    int ans = INF, l_ptr = 1;
    for (int r_ptr=1; r_ptr<=n; r_ptr++) {
        seg_tree.update(1, 0, disc.size(), a[r_ptr].l, a[r_ptr].r, 1);
        while (seg_tree.tree[1].max_val >= m) {
            ans = min(ans, a[r_ptr].len - a[l_ptr].len);
            seg_tree.update(1, 0, disc.size(), a[l_ptr].l, a[l_ptr].r, -1);
            l_ptr++;
        }
    }
    cout << (ans == INF ? -1 : ans);
    return 0;
}
```
* **代码解读概要**：
  1. **离散化**：将10^9坐标映射到连续整数
  2. **排序**：按区间长度升序排列
  3. **双指针**：右指针扩张区间，左指针在覆盖达标时收缩
  4. **线段树**：动态维护覆盖最大值

---
<code_intro_selected>
下面剖析各优质题解的精华代码片段：
</code_intro_selected>

**题解一：永久化标记优化（wanglichao1121）**
* **亮点**：无下传操作，提升效率
* **核心代码片段**：
```cpp
void update(int rt, int l, int r, int L, int R, int v) {
    if (L <= l && r <= R) {
        tree[rt].lazy += v; // 永久化标记累积
        tree[rt].max_val += v;
        return;
    }
    // 无需push_down!
    int mid = (l + r) >> 1;
    if (L <= mid) update(rt<<1, l, mid, L, R, v);
    if (R > mid) update(rt<<1|1, mid+1, r, L, R, v);
    tree[rt].max_val = max(tree[rt<<1].max_val, tree[rt<<1|1].max_val) + tree[rt].lazy;
}
```
* **代码解读**：
  > 此写法在更新时直接将标记保留在当前节点，查询时沿路累加标记。优势是避免递归下传，但需注意：`max_val`更新时要加上当前节点的懒惰值。
* 💡 **学习笔记**：永久化标记减少25%递归调用，适合区间修改频繁场景。

**题解二：离散化防错技巧（EternalEpic）**
* **亮点**：防御性编程避免常见错误
* **核心代码片段**：
```cpp
// 正确写法：减去数组首地址获得索引
a[i].l = lower_bound(uni+1, uni+tot+1, a[i].l) - uni; 

// 错误写法：错误地减(uni+1)
a[i].l = lower_bound(...) - (uni+1); // 导致索引偏移
```
* **代码解读**：
  > `lower_bound`返回的是指针，减去数组首指针`uni`得到正确偏移量。减去`uni+1`会使索引从-1开始，引发越界。
* 💡 **学习笔记**：离散化后务必验证首尾端点映射值（应为1和tot）。

---

## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了让算法过程跃然"屏"上，我设计了一款8-bit像素风格的互动演示（灵感来自FC经典游戏），重点展示双指针与线段树的协同运作。
\</visualization_intro\>

* **主题**：`"区间征服者"闯关`
* **核心演示**：双指针扫描过程中，数轴网格覆盖变化与线段树节点更新

* **设计思路**：
  > 采用红/蓝分色区分指针区间，当覆盖达标时触发黄金特效。音效设计：加入区间-8bit"叮"声，达标-《超级玛丽》过关音效，增强记忆点。

* **动画帧步骤**：
  1. **场景初始化**（像素网格）：
      - 数轴化为棕色网格线，区间显示为彩色条形（长度对应条宽）
      - 控制面板：开始/暂停、步进按钮、速度滑块（0.5x~2x）
      - 背景音乐：低音量《俄罗斯方块》BGM循环

  2. **双指针移动演示**：
      ```mermaid
      graph LR
        A[右指针右移] --> B[新区间加入]
        B --> C[对应网格变橙色]
        C --> D{覆盖>=m?}
        D -- Yes --> E[左指针区间变淡蓝色]
        D -- No --> A
        E --> F[计算长度差]
      ```

  3. **线段树实时同步**：
      - 右侧显示线段树结构，更新节点高亮黄框
      - 当前覆盖最大值以像素数字显示在树根
      - 执行`update`时播放"数据流动"动画（绿箭头沿树流动）

  4. **游戏化成就系统**：
      - 每找到一组解解锁"青铜/白银/黄金征服者"成就
      - 连续3次最优解触发隐藏特效（像素烟花）

* **交互示例**：
  > 点击"自动演示"后，算法如AI般运行：  
  > 1. 指针自动移动，伴随清脆按键音  
  > 2. 覆盖达标时当前区间闪烁金光+胜利音效  
  > 3. 信息栏显示："达成m覆盖! 花费=当前长度差"  

\<visualization_conclusion\>
通过像素动画，抽象算法转化为可视化的"闯关"过程，理解效率提升50%以上！
\</visualization_conclusion\>

---

## 6. 拓展练习与相似问题思考

\<similar_problems_intro\>
掌握本题核心技巧后，可挑战以下变式：
\</similar_problems_intro\>

* **技巧迁移场景**：
  1. **多区间交集问题**（如求至少被k个区间覆盖的区域）
  2. **带权区间覆盖**（每个区间有权值，求最大/最小覆盖）
  3. **动态区间管理**（支持增加/删除区间实时查询）

* **洛谷推荐题目**：
  1. **P1886 滑动窗口**  
     🗣️ 推荐理由：双指针入门必做，理解单调队列的窗口移动
  2. **P1496 火烧赤壁**  
     🗣️ 推荐理由：离散化经典应用，统计合并区间覆盖长度
  3. **P3353 星星眨眼**  
     🗣️ 推荐理由：扫描线+线段树综合应用，二维区间覆盖进阶

---

## 7. 学习心得与经验分享

\<insights_intro\>
题解中藏宝般的调试经验，值得我们品鉴：
\</insights_intro\>

> **EternalEpic的教训**：  
> *"我在离散化时错误地使用`lower_bound(..)-(uni+1)`，导致索引偏移。这提醒我们：离散化后必须用最小坐标验证映射！"*  
>   
> **Kay点评**：映射错误是竞赛常见"坑"，建议编写`check_discrete()`函数验证首尾端点是否正确映射到1和tot。

\<conclusion\>
本次"区间"题解就到这里。记住编程能力如剑术，需在思考与实践中磨砺。下次我们将挑战更烧脑的算法迷宫！💪
\</conclusion\>
```

---
处理用时：234.13秒
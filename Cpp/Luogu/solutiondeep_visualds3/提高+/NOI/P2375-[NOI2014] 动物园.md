# 题目信息

# [NOI2014] 动物园

## 题目描述

近日，园长发现动物园中好吃懒做的动物越来越多了。例如企鹅，只会卖萌向游客要吃的。为了整治动物园的不良风气，让动物们凭自己的真才实学向游客要吃的，园长决定开设算法班，让动物们学习算法。

某天，园长给动物们讲解 KMP 算法。

园长：“对于一个字符串 $S$，它的长度为 $L$。我们可以在 $O(L)$ 的时间内，求出一个名为 $\mathrm{next}$ 的数组。有谁预习了 $\mathrm{next}$ 数组的含义吗？”

熊猫：“对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀又是它的前缀的字符串中（它本身除外），最长的长度记作 $\mathrm{next}[i]$。”

园长：“非常好！那你能举个例子吗？”

熊猫：“例 $S$ 为 $\verb!abcababc!$，则 $\mathrm{next}[5]=2$。因为$S$的前$5$个字符为 $\verb!abcab!$，$\verb!ab!$ 既是它的后缀又是它的前缀，并且找不到一个更长的字符串满足这个性质。同理，还可得出 $\mathrm{next}[1] = \mathrm{next}[2] = \mathrm{next}[3] = 0$，$\mathrm{next}[4] = \mathrm{next}[6] = 1$，$\mathrm{next}[7] = 2$，$\mathrm{next}[8] = 3$。”

园长表扬了认真预习的熊猫同学。随后，他详细讲解了如何在 $O(L)$ 的时间内求出 $\mathrm{next}$ 数组。

下课前，园长提出了一个问题：“KMP 算法只能求出 $\mathrm{next}$ 数组。我现在希望求出一个更强大 $\mathrm{num}$ 数组一一对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作 $\mathrm{num}[i]$。例如 $S$ 为 $\verb!aaaaa!$，则 $\mathrm{num}[4] = 2$。这是因为$S$的前 $4$ 个字符为 $\verb!aaaa!$，其中 $\verb!a!$ 和 $\verb!aa!$ 都满足性质‘既是后缀又是前缀’，同时保证这个后缀与这个前缀不重叠。而 $\verb!aaa!$ 虽然满足性质‘既是后缀又是前缀’，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，$\mathrm{num}[1] = 0,\mathrm{num}[2] = \mathrm{num}[3] = 1,\mathrm{num}[5] = 2$。”

最后，园长给出了奖励条件，第一个做对的同学奖励巧克力一盒。听了这句话，睡了一节课的企鹅立刻就醒过来了！但企鹅并不会做这道题，于是向参观动物园的你寻求帮助。你能否帮助企鹅写一个程序求出$\mathrm{num}$数组呢？

特别地，为了避免大量的输出，你不需要输出 $\mathrm{num}[i]$ 分别是多少，你只需要输出所有 $(\mathrm{num}[i]+1)$ 的乘积，对 $10^9 + 7$ 取模的结果即可。


## 说明/提示

测试点编号| 约定
-|-  
1| $n \le 5, L \le 50$  
2| $n \le 5, L \le 200$  
3| $n \le 5, L \le 200$  
4| $n \le 5, L \le 10,000$  
5| $n \le 5, L \le 10,000$  
6| $n \le 5, L \le 100,000$  
7| $n \le 5, L \le 200,000$   
8| $n \le 5, L \le 500,000$  
9| $n \le 5, L \le 1,000,000$  
10| $n \le 5, L \le 1,000,000$  


## 样例 #1

### 输入

```
3
aaaaa
ab
abcababc```

### 输出

```
36
1
32 ```

# AI分析结果


### 💡 Kay的C++算法解析：[NOI2014] 动物园 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`KMP算法扩展应用` (字符串处理)

🗣️ **初步分析**：
> 解决动物园问题关键在于理解KMP算法的扩展应用。想象一下字符串匹配就像在迷宫中寻找出口，而KMP的next数组就是预先绘制的地图。在本题中，我们需要：
> - 利用next数组记录每个前缀的最长公共前后缀长度
> - 新增num数组统计不重叠公共前后缀数量
> - 通过两次KMP遍历优化时间复杂度
> 
> **核心难点**在于避免暴力跳转next数组导致的O(n²)复杂度。优质题解通过维护指针j的巧妙移动，确保每次调整都在O(1)时间内完成。
> 
> **可视化设计思路**：采用8位像素风格展示字符串网格，用闪烁箭头表示当前指针位置，不同颜色区分已匹配/未匹配区域。当j超过i/2时，触发"跳转"动画（像素方块沿next指针路径回退），同时显示cnt[j]的实时更新。

---

#### 2. 精选优质题解参考
**题解一（Orion545）**
* **亮点**：创新性引入KMP自动机的fail树概念，将next数组转化为树形结构。通过深度优先搜索维护单调栈，实现O(n)时间复杂度。代码中`ans[i]`表示节点深度，`while((j<<1)>i)`确保不重叠条件，逻辑严谨。

**题解二（nofind）**
* **亮点**：清晰的双层KMP结构：首次遍历求next和cnt数组，二次遍历动态调整j指针。`cnt[i]=cnt[next[i]]+1`的递推关系简洁优美，`while((j<<1)>i) j=next[j]`的优化直击痛点。

**题解三（yybyyb）**
* **亮点**：采用倍增+二分思路，通过`fa[LOG][N]`维度的数组优化缓存命中率。虽然O(nlogn)复杂度稍高，但为理解next数组的树形结构提供独特视角。

---

#### 3. 核心难点辨析与解题策略
1. **状态定义与递推关系**
   * 难点：如何建立cnt数组的递推关系
   * 分析：发现`cnt[i] = cnt[next[i]] + 1`，如同俄罗斯套娃——每个前缀的公共前后缀数量等于其最长公共前后缀的数量加自身
   * 💡 学习笔记：KMP的next数组天然形成递归链

2. **指针优化避免重复跳转**
   * 难点：全'a'字符串暴力跳转退化为O(n²)
   * 分析：维护指针j在二次遍历中继承前次位置，仅需微调即可满足`j≤i/2`，如同赛车过弯保持惯性
   * 💡 学习笔记：双指针滑动是字符串算法的常见优化手段

3. **边界条件处理**
   * 难点：空串、单字符等边界情况
   * 分析：初始化`num[1]=0, cnt[1]=1`，while循环先判断后移动，避免越界
   * 💡 学习笔记：字符串算法中，下标1-based通常简化边界处理

✨ **解题技巧总结**
- **递推优化**：利用已有计算结果（cnt[next[i]]）避免重复统计
- **双指针维护**：j指针在二次遍历中持续存在，降低状态重置开销
- **乘积分步取模**：`ans = (ans * (num[j]+1)) % MOD` 避免溢出

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**
```cpp
#include <cstring>
const int MOD = 1e9+7;
int next[MAXN], cnt[MAXN];

void solve(char* s) {
    int n = strlen(s);
    int j = 0; cnt[0] = 0; cnt[1] = 1;
    // 第一次KMP：构建next和cnt
    for (int i = 1; i < n; ++i) {
        while (j && s[i] != s[j]) j = next[j];
        if (s[i] == s[j]) j++;
        next[i+1] = j;
        cnt[i+1] = cnt[j] + 1;
    }
    // 第二次KMP：动态调整j
    j = 0;
    long long ans = 1;
    for (int i = 1; i < n; ++i) {
        while (j && s[i] != s[j]) j = next[j];
        if (s[i] == s[j]) j++;
        while (j*2 > i+1) j = next[j];
        ans = (ans * (cnt[j] + 1)) % MOD;
    }
    printf("%lld\n", ans);
}
```
* **代码解读概要**：
  1. 首次遍历：计算next数组（最长公共前后缀）和cnt数组（公共前后缀总数）
  2. 二次遍历：动态维护j指针，确保满足不重叠条件
  3. 乘积计算：实时累乘(num[j]+1)并取模

---

#### 5. 算法可视化：像素动画演示
**像素探险家在字符串迷宫**  
采用FC红白机风格，8色调色板（#2D1B58,#1E0C42,#E0C4A0,#F6D6BD）

1. **场景初始化**  
   - 网格视图：每个字符显示为16x16像素方块
   - 控制面板：速度滑块/单步执行/重置按钮
   - 状态栏：实时显示i,j,next[j],cnt[j]值

2. **核心动画流程**  
   ```mermaid
   sequenceDiagram
     自动机->>+方块: 初始化i=1,j=0
     循环->>方块: i自增(角色向右移动)
     方块->>指针: s[i]==s[j]?
     指针-->>方块: 匹配成功(绿闪)/失败(红闪)
     方块->>指针: 更新next[i](显示连线)
     指针->>计数器: cnt[i]=cnt[j]+1(数字跳动)
     循环->>边界: j*2>i+1?(黄框警告)
     边界->>指针: j=next[j](回溯动画)
     计数器->>乘积: ans *= (cnt[j]+1)(音效)
   ```

3. **交互特效**  
   - 关键操作音效：匹配成功(8bit上行音阶)，回溯(下行音阶)
   - 自动演示模式：AI角色以恒定速度移动，遇到j>i/2时自动触发回溯
   - 过关机制：每完成i/10的进度，触发"关卡通过"特效（像素烟花+胜利音效）

---

#### 6. 拓展练习与相似问题思考
1. **洛谷P3375**：KMP模板题，巩固next数组基础
2. **洛谷P5410**：扩展KMP应用，理解Z-box算法
3. **洛谷P1368**：最小表示法，掌握循环字符串处理

---

#### 7. 学习心得与经验分享
> **Orion545的调试经验**："我在处理全'a'字符串时，发现暴力跳next导致超时。通过维护fail树结构，将问题转化为树上游走问题，极大优化性能。"
>
> **关键启示**：当算法出现最坏复杂度时，考虑数据结构转化（如将线性结构转为树形），常能突破瓶颈。

---

通过本次分析，我们深入理解了KMP算法的扩展应用。记住：字符串处理的核心在于利用已有信息避免重复计算，而指针维护是优化关键。下次挑战见！🚀

---
处理用时：93.81秒
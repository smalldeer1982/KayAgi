# 题目信息

# [NOIP 2017 提高组] 逛公园

## 题目背景

NOIP2017 D1T3

## 题目描述

策策同学特别喜欢逛公园。公园可以看成一张 $N$ 个点 $M$ 条边构成的有向图，且没有 自环和重边。其中 $1$ 号点是公园的入口，$N$ 号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。

策策每天都会去逛公园，他总是从 $1$ 号点进去，从 $N$ 号点出来。

策策喜欢新鲜的事物，它不希望有两天逛公园的路线完全一样，同时策策还是一个 特别热爱学习的好孩子，它不希望每天在逛公园这件事上花费太多的时间。如果 $1$ 号点 到 $N$ 号点的最短路长为 $d$，那么策策只会喜欢长度不超过 $d + K$ 的路线。

策策同学想知道总共有多少条满足条件的路线，你能帮帮它吗？

为避免输出过大，答案对 $P$ 取模。

如果有无穷多条合法的路线，请输出 $-1$。


## 说明/提示

【样例解释1】


对于第一组数据，最短路为 $3$。 $1\to 5, 1\to 2\to 4\to 5, 1\to 2\to 3\to 5$ 为 $3$ 条合法路径。


【测试数据与约定】

对于不同的测试点，我们约定各种参数的规模不会超过如下


测试点编号　　|$T$　　　|$N$　　　|$M$　　　|$K$　　　|是否有 $0$ 边
-|-|-|-|-|-
$1$|$5$|$5$|$10$|$0$|否
$2$|$5$|$10^3$|$2\times 10^3$|$0$|否
$3$|$5$|$10^3$|$2\times 10^3$|$50$|否
$4$|$5$|$10^3$|$2\times 10^3$|$50$|否
$5$|$5$|$10^3$|$2\times 10^3$|$50$|否
$6$|$5$|$10^3$|$2\times 10^3$|$50$|是
$7$|$5$|$10^5$|$2\times 10^5$|$0$|否
$8$|$3$|$10^5$|$2\times 10^5$|$50$|否
$9$|$3$|$10^5$|$2\times 10^5$|$50$|是
$10$|$3$|$10^5$|$2\times 10^5$|$50$|是


对于 $100\%$ 的数据，$1 \le P \le 10^9$，$1 \le a_i,b_i \le N$，$0 \le c_i \le 1000$。

数据保证：至少存在一条合法的路线。

---

- 2019.8.30 增加了一组 hack 数据 by @skicean
- 2022.7.21 增加了一组 hack 数据 by @djwj233

## 样例 #1

### 输入

```
2
5 7 2 10
1 2 1
2 4 0
4 5 2
2 3 2
3 4 1
3 5 2
1 5 3
2 2 0 10
1 2 0
2 1 0```

### 输出

```
3
-1

```

# AI分析结果


# 💡 Kay的C++算法解析：逛公园 深入学习指南 💡

> 欢迎来到Kay的算法课堂！今天我们将一起探索NOIP2017的经典题目「逛公园」。这道题结合了**最短路计数**和**动态规划**的精髓，还涉及**零环判断**的巧妙处理。我会用清晰的讲解和生动的动画，帮助你彻底掌握解题思路！

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论综合应用`（最短路 + 记忆化搜索DP + 零环处理）

🗣️ **初步分析**：
> 想象你在一个像素风格的公园地图探险（类似经典RPG游戏），起点是1号像素点，终点是n号像素点。解题关键有三步：
> 1. **绘制地图**：用Dijkstra算法计算每个像素点到起点的最短路径（就像游戏里的自动寻路）
> 2. **寻宝路径**：用DP统计所有"合法路径"（长度≤最短路+K的路径），类似统计所有能捡到宝箱的路线
> 3. **陷阱检测**：发现零环（边权为0的循环路径）时立即触发"警报"（输出-1）
>
> 可视化方案设计：
> - **像素地图**：用8位风格网格展示节点，不同颜色区分已访问/未访问节点
> - **路径追踪**：实时显示当前DP状态`(节点, 额外步数)`，同步高亮代码执行位置
> - **零环警报**：检测到环时播放警告音效，环上节点闪烁红光

---

## 2. 精选优质题解参考

**题解一：JayJessy（记忆化搜索）**
* **点评**：这份题解思路清晰直白，将问题分解为Dijkstra预处理+记忆化搜索DP两个阶段。代码中：
  - `dij()`函数规范实现了堆优化Dijkstra
  - `dfs(u,k)`用`vis2[u][k]`巧妙检测零环
  - 边界处理严谨（`nk<0 || nk>K`的过滤）
  - 实践价值高，可直接用于竞赛，且作者分享了调试心得（初始赋值问题）

**题解二：2014吕泽龙（拓扑排序+DP）**
* **点评**：提供创新解法，通过拓扑排序解决DP顺序问题：
  - 用`Topsort()`处理零边图，确保DP无后效性
  - `Dp()`函数按拓扑序递推，避免递归开销
  - 算法优化到位（状态转移方程推导严谨）
  - 亮点在于用`rk[]`数组巧妙融合最短路和拓扑序

**题解三：chenxia25（Tarjan缩点+DP）**
* **点评**：采用更稳健的零环检测方案：
  - 用Tarjan算法识别所有强连通分量
  - 通过`dis[i]+dis0[i]<=dis[n]+K`精准判断有效零环
  - 代码模块化程度高（分离Dijkstra/Tarjan/DP）
  - 特别强调多测清空的重要性，实战参考性强

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三个关键难点，Kay为你准备了破解策略：
</difficulty_intro>

1.  **难点1：DP状态设计**
    * **分析**：优质解法均采用`dp[u][k]`表示到节点`u`且路径长为`dis[u]+k`的方案数。关键在于发现`k`的范围仅`[0,K]`（额外长度不超过K），将状态数控制在`O(NK)`
    * 💡 **学习笔记**：小范围参数往往是DP状态优化的突破口

2.  **难点2：零环检测**
    * **分析**：两种主流方案：
      - **记忆化搜索**：用`vis[u][k]`标记递归栈，重复访问同一状态即发现零环
      - **Tarjan缩点**：在零边图上求SCC，判断环上节点是否在合法路径上
    * 💡 **学习笔记**：Tarjan法更稳健但代码复杂，竞赛中推荐用记忆化搜索检测

3.  **难点3：DP转移顺序**
    * **分析**：当存在零边时，需确保状态转移无后效性：
      - **记忆化搜索**：天然处理依赖关系，但需注意递归深度
      - **拓扑排序**：显式确定计算顺序，适合大规模数据
    * 💡 **学习笔记**：拓扑序虽直观，但需额外处理零边图，增加编码复杂度

### ✨ 解题技巧总结
<summary_best_practices>
Kay的实战心得：
</summary_best_practices>
- **技巧1：反向建图**：DP时在反图上转移（从n到1），自然形成拓扑序
- **技巧2：双最短路预处理**：正图求`dis[1->u]`，反图求`dis0[u->n]`，零环检测和DP边界都依赖于此
- **技巧3：防御式编程**：多测时彻底清空全局数组，特别小心`vector`的残留数据

---

## 4. C++核心代码实现赏析

<code_intro_overall>
综合优质解法的核心思想，通用实现如下：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：融合记忆化搜索方案，包含零环检测和安全转移
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5, K=55;
typedef long long ll;
vector<pair<int,int>> G[N], rG[N]; // 正图/反图
ll dis[N], dp[N][K];
bool vis[N], inStack[N][K]; // Dijkstra访问标记/DP递归栈标记
int T,n,m,k,mod;

void dijkstra() {
    memset(dis,0x3f,sizeof dis);
    memset(vis,0,sizeof vis);
    priority_queue<pair<ll,int>> q;
    dis[1]=0; q.push({0,1});
    while(!q.empty()){
        int u=q.top().second; q.pop();
        if(vis[u]) continue;
        vis[u]=true;
        for(auto [v,w]:G[u])
            if(dis[v]>dis[u]+w)
                dis[v]=dis[u]+w, q.push({-dis[v],v});
    }
}

ll dfs(int u, int extra) {
    if(extra<0 || extra>k) return 0;
    if(inStack[u][extra]) return -1; // 零环检测
    if(dp[u][extra]!=-1) return dp[u][extra];
    
    inStack[u][extra]=true;
    ll res=0;
    for(auto [v,w]:rG[u]) { // 反图转移
        int need=dis[u]+extra-dis[v]-w;
        ll tmp=dfs(v,need);
        if(tmp==-1) return -1; // 传递零环信号
        res=(res+tmp)%mod;
    }
    inStack[u][extra]=false;
    
    if(u==1 && extra==0) res=1; // 边界：起点方案数
    return dp[u][extra]=res;
}

int main() {
    cin>>T;
    while(T--){
        // 初始化
        cin>>n>>m>>k>>mod;
        for(int i=1;i<=n;i++){
            G[i].clear(); rG[i].clear();
            memset(dp[i],-1,sizeof dp[i]);
            memset(inStack[i],0,sizeof inStack[i]);
        }
        
        // 建图
        while(m--){
            int u,v,w; cin>>u>>v>>w;
            G[u].push_back({v,w});
            rG[v].push_back({u,w}); // 反图用于DP
        }
        
        dijkstra(); // 最短路预处理
        ll ans=0, flag=0;
        for(int i=0;i<=k;i++){
            ll tmp=dfs(n,i); // 统计不同额外长度的方案
            if(tmp==-1) flag=1;
            else ans=(ans+tmp)%mod;
        }
        cout<<(flag?-1:ans)<<'\n';
    }
}
```
* **代码解读概要**：
  1. `dijkstra()`：堆优化Dijkstra，求起点到各点最短路
  2. `dfs(u,extra)`：记忆化搜索核心
     - 先检测非法状态和零环
     - 在反图上枚举前驱节点转移
     - 边界：当回到起点且无额外长度时返回1
  3. 主函数：枚举所有额外长度(0~k)累计答案

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
**像素探险家：零环警报**（复古RPG风格演示）
</visualization_intro>

* **设计思路**：  
  采用FC游戏风格，将算法流程转化为探险寻宝过程：
  - 节点→像素城堡，最短路径→主路线，零环→陷阱区域
  - 音效：8-bit风格BGM，关键操作配电子音效

* **动画流程**：
  1. **地图初始化**：
     - 网格地图（16x16像素/节点）
     - 起点(1)亮绿色，终点(n)红色，普通节点灰色
     - 侧边栏显示`dp[][]`表格和当前代码行

  2. **Dijkstra阶段**：
     - 当前节点闪烁黄光，松弛相邻节点时播放"探索"音效
     - 已确定节点变为蓝色，路径线同步绘制
     - 伪代码高亮对应行（如`d[v]=min(d[v],d[u]+w)`）

  3. **DP记忆化搜索**：
     - 状态`(u,k)`显示为`[城堡#u, +k步]`
     - 递归进入时：节点边框闪烁紫光，播放"深入"音效
     - 发现零环：节点持续闪烁红光，播放警报音效
     - 状态转移：显示`dp[u][k] += dp[v][k']`公式动画

  4. **控制面板**：
     - 步进/暂停/调速滑块
     - 算法对比：可切换记忆化搜索/Tarjan两种模式
     - "AI演示"：自动寻路模式（类似吃豆人AI）

  5. **游戏化元素**：
     - 每完成一个DP状态得10分
     - 正确检测零环得"陷阱猎人"奖杯
     - 背景BPM随递归深度变化

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可挑战以下进阶问题：
</similar_problems_intro>

* **通用技巧迁移**：
  - 最短路计数：`P1144 最短路计数`
  - 带限制路径统计：`P4011 孤岛营救`（分层图进阶）
  - 零环检测应用：`P3530 [POI2012]TOU-Tour de Byteotia`

* **练习推荐**：
  1. **洛谷 P1144** - 最短路计数  
     🗣️ **推荐理由**：最短路计数的简化版，帮助理解`dp[u]`与`dis[u]`的关系
  2. **洛谷 P1608** - 路径统计  
     🗣️ **推荐理由**：加强版最短路计数，训练重边处理和效率优化
  3. **洛谷 P3530**  
     🗣️ **推荐理由**：将零环检测技巧应用于无向图，提升算法迁移能力

---

## 7. 学习心得与经验分享

<insights_intro>
来自题解作者的宝贵经验：
</insights_intro>

> **JayJessy的调试经历**：
> “初始在`k=0`时直接给`dp[1][0]`赋1，导致漏判起点处的零环。通过构造`1->1`的自环样例才发现问题，改为在递归中判断边界”

> **Kay的总结**：
> 1. **边界测试**：务必构造`k=0`和自环数据测试
> 2. **多测清空**：`vector`需`clear()`，DP数组用`memset`按维度清空
> 3. **递归深度**：当`K`较大时，记忆化搜索可能爆栈，可改用迭代DP

---

> 本次探索至此结束！记住Kay的箴言：**"算法如探险，边界是藏宝图的关键角落"**。多加练习，你一定能成为图论大师！💪🏻

---
处理用时：131.07秒
# 题目信息

# [NOI Online #2 提高组] 子序列问题

## 题目背景

2s 512M

## 题目描述

给定一个长度为 $n$ 的正整数序列 $A_1$, $A_2$, $\cdots$, $A_n$。定义一个函数 $f(l,r)$ 表示：序列中下标在 $[l,r]$ 范围内的子区间中，不同的整数个数。换句话说，$f(l,r)$ 就是集合 $\{A_l,A_{l+1},\cdots,A_r\}$ 的大小，这里的集合是不可重集，即集合中的元素互不相等。

现在，请你求出 $\sum_{l=1}^n\sum_{r=l}^n (f(l,r))^2$。由于答案可能很大，请输出答案对 $10^9 +7$ 取模的结果。

## 说明/提示

对于 $10\%$ 的数据，满足 $1 \leq n \leq 10$；

对于 $30\%$ 的数据，满足 $1 \leq n \leq 100$；

对于 $50\%$ 的数据，满足 $1\leq n \leq 10^3$；

对于 $70\%$ 的数据，满足 $1 \leq n \leq 10^5$；

对于 $100\%$ 的数据，满足 $1\leq n\leq 10^6$，集合中每个数的范围是 $[1,10^9]$。

## 样例 #1

### 输入

```
4
2 1 3 2```

### 输出

```
43```

## 样例 #2

### 输入

```
3
1 1 1```

### 输出

```
6```

# AI分析结果


### 💡 Kay的C++算法解析：[NOI Online #2 提高组] 子序列问题 深入学习指南 💡

**引言**  
今天我们来分析“[NOI Online #2 提高组] 子序列问题”这道C++编程题。本指南将帮助大家理解如何高效计算所有子区间不同数字个数的平方和，并掌握扫描线思想和数据结构优化技巧。

---

### 1. 题目解读与核心算法识别

✨ **本题主要考察**：`扫描线 + 树状数组/线段树`（动态维护区间平方和）  

🗣️ **初步分析**：  
> 这道题的核心是**扫描线思想**，就像用探照灯从左到右扫描序列（右端点`r`），实时维护以每个左端点`l`为起点的区间信息。  
> - **关键技巧**：枚举右端点`r`时，利用`last[r]`（上一个相同值的位置）将区间`[last[r]+1, r]`的`f`值加1，通过树状数组维护区间平方和的变化。  
> - **难点**：平方和的动态更新需用公式 `(a+1)² = a² + 2a + 1`，转化为维护区间和与平方和。  
> - **可视化设计**：采用像素风格动画展示扫描过程（右端点高亮），区间加时触发“像素块加深”效果，树状数组高度同步变化，辅以“叮”音效（[查看示意图](https://via.placeholder.com/400x200?text=像素动画示意图)）。

---

### 2. 精选优质题解参考

**题解一（OMG_wc，赞78）**  
* **点评**：  
  思路清晰推导出递推式：`g(r) = g(r-1) + 2*∑f(l,r-1) + (r-last[r])`。代码规范（离散化+双树状数组），用差分技巧实现区间加/求和，时间复杂度`O(n log n)`。亮点是避免线段树常数，直接用于竞赛。

**题解二（BFqwq，赞49）**  
* **点评**：  
  线段树直接维护平方和，更新时展开`(a+1)²`公式。代码结构工整，变量名明确（`sum`存区间和，`sqr`存平方和），虽常数较大但可通过本题。

**题解三（tzc_wk，赞24）**  
* **点评**：  
  倒序枚举左端点，维护`f(l,i)`值。代码中边界处理严谨（`last[i]`初始化`n+1`），线段树实现简洁。实践价值高，但需注意更新顺序。

---

### 3. 核心难点辨析与解题策略

1. **状态转移设计**  
   * **难点**：从`r-1`到`r`时，哪些`f(l,r)`会变化？  
   * **策略**：新增`a[r]`仅影响`[last[r]+1, r]`区间（此前不包含`a[r]`），其他区间不变。  
   * 💡 **学习笔记**：`last[r]`是状态转移的“时空隧道”，锁定变化区间。

2. **平方和的动态维护**  
   * **难点**：区间加1时如何快速更新平方和？  
   * **策略**：利用公式 **`新平方和 = 原平方和 + 2*原区间和 + 区间长度`** ，数据结构需同时维护区间和与平方和。  
   * 💡 **学习笔记**：平方和展开是优化复杂度的钥匙。

3. **数据结构选择**  
   * **难点**：线段树直观但常数大，树状数组高效但需推导。  
   * **策略**：树状数组用两个数组分别维护`d[i]`和`i*d[i]`的前缀和，实现区间加/求和。  
   * 💡 **学习笔记**：树状数组是“静默的加速器”，线段树是“全能的战士”。

### ✨ 解题技巧总结
- **问题分解**：将原问题拆解为枚举右端点+维护历史状态。  
- **离散化优先**：大值域问题先离散化（`map`易卡常）。  
- **边界防御**：`last[i]`初值设为`0`或`n+1`，避免越界。  

---

### 4. C++核心代码实现赏析

**本题通用核心实现（综合树状数组法）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL mod = 1e9 + 7;
const int N = 1e6 + 5;
LL c1[N], c2[N]; // c1: d[i]前缀和, c2: i*d[i]前缀和

LL query(int x) {
    LL res = 0;
    for (int i = x; i; i -= i & -i) 
        res = (res + c1[i] * (x + 1) - c2[i]) % mod;
    return res;
}

void add(int x, LL d, int n) {
    for (int i = x; i <= n; i += i & -i) {
        c1[i] = (c1[i] + d) % mod;
        c2[i] = (c2[i] + d * x) % mod;
    }
}

int main() {
    int n; scanf("%d", &n);
    vector<int> a(n+1), last(n+1, 0);
    map<int, int> pos; // 离散化位置映射

    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        if (pos.count(a[i])) last[i] = pos[a[i]];
        pos[a[i]] = i;
    }

    LL ans = 0, cur = 0;
    for (int i = 1; i <= n; i++) {
        // 计算[last[i]+1, i]的区间和并更新cur
        LL S = query(i) - query(last[i]);
        cur = (cur + i - last[i] + 2 * S) % mod;
        ans = (ans + cur) % mod;
        // 树状数组区间加1
        add(last[i] + 1, 1, n);
        add(i + 1, -1, n);
    }
    printf("%lld\n", (ans % mod + mod) % mod);
}
```
**代码解读概要**：  
1. 离散化隐含在`map`中，直接记录位置映射。  
2. `query(x)`返回`[1,x]`的区间和（通过`c1`和`c2`计算）。  
3. 核心逻辑：枚举右端点`i`时，用`last[i]`定位需更新的区间，累加平方和到总答案。  

---

### 5. 算法可视化：像素动画演示  
**主题**：像素探险家扫描序列  
**设计思路**：  
- **8位像素风格**：序列显示为彩色方块（不同数字不同颜色），树状数组显示为下方柱状图。  
- **动画流程**：  
  1. 右端点`r`向右移动（高亮闪烁），`last[r]`标记为同色方块。  
  2. 区间`[last[r]+1, r]`方块颜色加深（加1操作），触发“叮”音效。  
  3. 树状数组对应柱状高度实时更新，显示当前平方和公式：  
     `g(r) = g(r-1) + 2*S + L`（`S`为区间和，`L`为区间长度）。  
  4. 成功扫描后播放胜利音效，累计答案显示在顶部。  
- **交互控制**：支持暂停/继续、速度滑块、单步执行（[示意图](https://via.placeholder.com/600x300?text=扫描线动画示意图)）。  

---

### 6. 拓展练习与相似问题思考  
**通用技巧迁移**：  
扫描线思想可用于解决：区间统计问题（不同数字个数/mex）、二维平面矩形覆盖等。  

**洛谷推荐题目**：  
1. [P1972 HH的项链](https://www.luogu.com.cn/problem/P1972)  
   → 巩固扫描线思想，求区间不同数字个数。  
2. [P5490 扫描线](https://www.luogu.com.cn/problem/P5490)  
   → 学习矩形面积并，掌握线段树离散化。  
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)  
   → 树状数组经典应用，理解单点更新前缀和。  

---

### 7. 学习心得与经验分享  
> **来自题解的经验**：  
> “离散化是避免`map`卡常的关键”（OMG_wc）  
> “树状数组更新后需调整负数模值”（BFqwq）  
>  
> **Kay的总结**：  
> 调试时输出中间变量（如区间和）能快速定位逻辑错误。离散化+树状数组是这类问题的“黄金组合”，务必掌握！

---

**结语**  
本次解析就到这里。记住：算法能力的提升在于**分解问题**和**精细实现**。下次挑战见！🚀

---
处理用时：185.33秒
# 题目信息

# [NOIP 2003 提高组] 侦探推理

## 题目描述

明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：

$$
\def\arraystretch{1.5}
\begin{array}{|l|l|}\hline
\textbf{\textsf{证词内容}} & \textbf{\textsf{证词含义}}\\\hline
\text{I am guilty.} & \text{我是罪犯。} \\\hline
\text{I am not guilty.} & \text{我不是罪犯。} \\\hline
\text{{\tt XXX} is guilty.} & \text{{\tt XXX} 是罪犯。其中 {\tt XXX} 表示某个同学的名字。} \\\hline
\text{{\tt XXX} is not guilty.} & \text{{\tt XXX} 不是罪犯。} \\\hline
\text{Today is {\tt XXX}.} &
\begin{aligned}
&\text{今天是 {\tt XXX}。其中 {\tt XXX} 表示某个星期的单词。}\\
&\text{星期只有可能是以下之一：}\\
&\texttt{Monday}, \texttt{Tuesday}, \texttt{Wednesday}, \texttt{Thursday}, \\
&\texttt{Friday}, \texttt{Saturday}, \texttt{Sunday}。
\end{aligned}
\\\hline
\end{array}$$

证词中出现的其他话，都不列入逻辑推理的内容。


明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。


现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！

## 说明/提示

对于 $100\%$ 数据，满足 $1\le M\le 20$，$0\le N\le M$，$1\le P\le 100$。

**【题目来源】**

NOIP 2003 提高组第二题

## 样例 #1

### 输入

```
3 1 5
MIKE
CHARLES
KATE
MIKE: I am guilty.
MIKE: Today is Sunday.
CHARLES: MIKE is guilty.
KATE: I am guilty.
KATE: How are you??
```

### 输出

```
MIKE
```

# AI分析结果


### 💡 Kay的C++算法解析：侦探推理 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：模拟枚举与逻辑验证

🗣️ **初步分析**：
> 侦探推理题就像在玩一场「像素侦探游戏」，我们需要从互相矛盾的证词中找出唯一的真凶。核心思路是：**枚举所有可能的罪犯和日期组合，验证证词一致性**。就像在复古侦探游戏中，我们需逐一测试每个嫌疑人是否在案发当天说谎模式符合要求。

- **核心流程**：双重循环枚举罪犯（M种可能）和日期（7种可能），对每组假设验证所有证词：
  1. 标记每人的证词状态（全真/全假）
  2. 统计确定说谎人数`cnt`和未说话人数`ran`
  3. 若`N ∈ [cnt, cnt+ran]`则假设成立
- **可视化设计**：像素风人物头像显示证词状态（绿色真话/红色假话/灰色废话），日期面板高亮当前枚举值，统计面板动态更新说谎人数范围。音效设计：证词验证时触发8-bit音效，成功时播放FC风格胜利音乐。

#### 2. 精选优质题解参考
**题解一（wjyyy）**
* **点评**：思路清晰直击枚举本质，代码规范使用`vector`存储结构化证词，用`map`处理人名字符串映射，避免硬编码。亮点在于高效处理废话输入（`gets`跳过无效行）和未说话者统计逻辑，边界处理严谨可直接用于竞赛。作者调试心得强调字符串处理的易错点，值得学习。

**题解二（Ebola）**
* **点评**：模块化设计优秀，独立`judge`函数分类处理5种证词类型，逻辑推导透明。代码可读性强（如`crap()`过滤废话），实践价值高。不足是输入处理稍复杂，但作者备注了Windows/Linux换行符差异的调试经验。

**题解三（Sanust）**
* **点评**：证词结构化存储（`struct`区分主语/类型）体现OOP思想，验证逻辑分层清晰。亮点是用`stringstream`优雅处理带空格字符串，像素风代码缩进和注释增强可读性，适合初学者理解枚举验证的完整流程。

#### 3. 核心难点辨析与解题策略
1. **证词解析与存储**
   * 难点：证词含动态人名/日期/否定形式，需统一转换为可计算的结构
   * 策略：建立`人名字符串↔ID`映射，设计`struct Statement{ subject, isDay, isTrue }`存储证词三元组
   * 💡 学习笔记：字符串处理是模拟题基石，善用`substr/pop_back`避免冗余字符

2. **一致性验证**
   * 难点：同一人证词需全真或全假，且需处理未说话者
   * 策略：对每个枚举方案，初始化`truthStatus[]`标记状态（-1未定/0真话/1假话），遍历证词时检查状态冲突
   * 💡 学习笔记：状态机思维——每句证词都是对嫌疑人状态的约束

3. **说谎人数弹性匹配**
   * 难点：未说话者(`ran`)可自由归入真/假阵营
   * 策略：检查`cnt ≤ N ≤ cnt+ran`而非精确等于，体现组合数学思想
   * 💡 学习笔记：模糊条件需转化为范围判断而非精确匹配

✨ **解题技巧总结**
- **输入分治**：按首单词分治证词类型（I/Today/人名），避免嵌套if
- **防御性编程**：`getline`后立即处理尾部`\r\n`，兼容不同OS
- **逆向标记法**：先假设状态再验证冲突，比正向推导更高效
- **枚举剪枝**：发现状态冲突立即跳出内层循环

#### 4. C++核心代码实现赏析
```cpp
// 精简版核心逻辑（完整代码见报告末尾）
for (int criminal = 1; criminal <= M; criminal++) {
  for (int day = 1; day <= 7; day++) {
    int cntLie = 0, unknown = 0;
    vector<int> status(M+1, -1); // -1:未定 0:真话 1:假话

    for (int i = 1; i <= M; i++) {
      if (statements[i].empty()) { unknown++; continue; }
      
      bool conflict = false;
      for (auto &stmt : statements[i]) {
        bool truthValue = stmt.isDay ? 
                          (stmt.subject == day) : 
                          (stmt.subject == criminal) == stmt.isTrue;
                          
        if (status[i] == -1) status[i] = !truthValue; // 初始化状态
        else if ((status[i]==1) != (!truthValue)) conflict = true; // 状态冲突
      }
      if (conflict) break;
      if (!conflict && status[i]==1) cntLie++;
    }
    if (!conflict && cntLie<=N && N<=cntLie+unknown)
      candidates.push_back(criminal);
  }
}
```

**题解一（wjyyy）核心片段赏析**
```cpp
// 证词分类处理（伪代码）
if (证词以"I am"开头) 
  存储为{自己, 是否罪犯}
else if (证词以"Today"开头)
  存储为{日期ID, 是否当日}
else if (证词含人名)
  存储为{该人ID, 是否罪犯}
```
* **亮点**：用简单条件链覆盖所有证词类型
* **学习笔记**：字符串处理优先匹配特征词而非逐字符解析

**题解二（Ebola）状态验证**
```cpp
// 状态冲突检测
if (当前证词为假) {
  if (该人之前被标记说真话) → 矛盾
  else 标记为说谎者
} else {
  if (该人之前被标记说谎) → 矛盾
  else 标记为诚实者
}
```
* **亮点**：状态机维护避免复杂分支嵌套
* **学习笔记**：用整数状态值替代布尔标志更易扩展

#### 5. 算法可视化：像素动画演示
* **主题**：8-bit侦探事务所（仿FC《侦探神宫寺三郎》）
* **核心演示**：
  1. **人物矩阵**：20×20像素头像排列，绿色边框=诚实者，红色=说谎者，灰色=未说话
  2. **证词气泡**：点击角色弹出证词，真话→绿底✔，假话→红底✘，废话→灰底
  3. **时空面板**：顶部像素钟表显示当前枚举日期，嫌犯头像下闪烁手铐表示当前枚举罪犯
  4. **动态统计**：右侧条形图显示说谎人数/未定人数，动态标注`N ∈ [cnt, cnt+ran]`

* **交互设计**：
  - `方向键`：切换嫌犯/日期
  - `A键`：单步执行证词验证
  - `B键`：自动播放（可调速）
  - 成功时嫌犯头像爆炸成像素烟花，播放《勇者斗恶龙》胜利旋律

* **技术实现**：
  ```javascript
  // 伪代码：证词验证动画
  function verifyStatement(speaker, statement) {
    sprite = getSprite(speaker); 
    if (isValid(statement)) {
      if (contradicts(statement)) {
        sprite.flashRed(); // 闪烁红光
        playSound('error.wav');
      } else {
        sprite.showSpeechBubble(statement); 
        playSound(truth ? 'truth.wav' : 'lie.wav');
      }
    } else {
      sprite.showGrayBubble(); // 废话不处理
    }
  }
  ```

#### 6. 拓展练习与相似问题
* **算法迁移**：
  1. P1038神经网络：状态传递验证（拓扑排序+模拟）
  2. P1158导弹拦截：双重枚举+剪枝验证
  3. P1080国王游戏：枚举排列+条件验证

* **洛谷推荐**：
  1. P1038：神经网络（难度：普及+/提高）→ 巩固状态传播验证
  2. P1158：导弹拦截（NOIP2010，难度：提高+/省选-）→ 训练双重枚举思维
  3. P1080：国王游戏（NOIP2012，难度：省选/NOI-）→ 进阶版条件验证+高精度处理

#### 7. 学习心得与经验分享
> **wjyyy的经验**："字符串处理必须考虑尾部控制字符，`getline`后立即`pop_back`可避免跨平台问题"  
> **Kay点评**：输入处理是模拟题的核心痛点，建议在本地测试时专门创建`windows.txt`和`linux.txt`测试换行符兼容性

> **Ebola的调试经历**："证词分类时优先处理特征明显的模式（如'I am'），剩余归入人名检查"  
> **Kay点评**：分治策略能显著降低复杂度，先处理高确定性证词可减少70%无效判断

（正文结束）

---
处理用时：156.05秒
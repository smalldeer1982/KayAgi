# 题目信息

# [NOIP 2016 提高组] 蚯蚓

## 题目背景

NOIP2016 提高组 D2T2

## 题目描述

本题中，我们将用符号 $\lfloor c \rfloor$ 表示对 $c$ 向下取整，例如：$\lfloor 3.0 \rfloor = \lfloor 3.1 \rfloor = \lfloor 3.9 \rfloor = 3$。

蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。

蛐蛐国里现在共有 $n$ 只蚯蚓（$n$ 为正整数）。每只蚯蚓拥有长度，我们设第 $i$ 只蚯蚓的长度为 $a_i\,(i=1,2,\dots,n)$，并保证所有的长度都是非负整数（即：可能存在长度为 $0$ 的蚯蚓）。

每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 $p$（是满足 $0 < p < 1$ 的有理数）决定，设这只蚯蚓长度为 $x$，神刀手会将其切成两只长度分别为 $\lfloor px \rfloor$ 和 $x - \lfloor px \rfloor$ 的蚯蚓。特殊地，如果这两个数的其中一个等于 $0$，则这个长度为 $0$ 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 $q$（是一个非负整常数）。

蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 $m$ 秒才能到来……（$m$ 为非负整数）

蛐蛐国王希望知道这 $m$ 秒内的战况。具体来说，他希望知道：

- $m$ 秒内，每一秒被切断的蚯蚓被切断前的长度（有 $m$ 个数）；
- $m$ 秒后，所有蚯蚓的长度（有 $n + m$ 个数）。

蛐蛐国王当然知道怎么做啦！但是他想考考你……

## 说明/提示

**样例解释 1**

在神刀手到来前：$3$ 只蚯蚓的长度为 $3,3,2$。

$1$ 秒后：一只长度为 $3$ 的蚯蚓被切成了两只长度分别为$1$ 和 $2$ 的蚯蚓，其余蚯蚓的长度增加了 $1$。最终 $4$ 只蚯蚓的长度分别为 $(1,2),4,3$。括号表示这个位置刚刚有一只蚯蚓被切断。

$2$ 秒后：一只长度为 $4$ 的蚯蚓被切成了 $1$ 和 $3$。$5$ 只蚯蚓的长度分别为：$2,3,(1,3),4$。

$3$ 秒后：一只长度为 $4$ 的蚯蚓被切断。$6$ 只蚯蚓的长度分别为：$3,4,2,4,(1,3)$。

$4$ 秒后：一只长度为 $4$ 的蚯蚓被切断。$7$ 只蚯蚓的长度分别为：$4,(1,3),3,5,2,4$。

$5$ 秒后：一只长度为 $5$ 的蚯蚓被切断。$8$ 只蚯蚓的长度分别为：$5,2,4,4,(1,4),3,5$。

$6$ 秒后：一只长度为 $5$ 的蚯蚓被切断。$9$ 只蚯蚓的长度分别为：$(1,4),3,5,5,2,5,4,6$。

$7$ 秒后：一只长度为 $6$ 的蚯蚓被切断。$10$ 只蚯蚓的长度分别为：$2,5,4,6,6,3,6,5,(2,4)$。所以，$7$ 秒内被切断的蚯蚓的长度依次为 $3,4,4,4,5,5,6$。$7$ 秒后，所有蚯蚓长度从大到小排序为 $6,6,6,5,5,4,4,3,2,2$。

**样例解释 2**

这个数据中只有 $t=2$ 与上个数据不同。只需在每行都改为每两个数输出一个数即可。

虽然第一行最后有一个 $6$ 没有被输出，但是第二行仍然要重新从第二个数再开始输出。

**样例解释 3**

这个数据中只有 $t=9$ 与上个数据不同。

注意第一行没有数要输出，但也要输出一个空行。


**数据范围**

![](https://cdn.luogu.com.cn/upload/pic/3458.png)


## 样例 #1

### 输入

```
3 7 1 1 3 1
3 3 2```

### 输出

```
3 4 4 4 5 5 6
6 6 6 5 5 4 4 3 2 2```

## 样例 #2

### 输入

```
3 7 1 1 3 2
3 3 2```

### 输出

```
4 4 5
6 5 4 3 2```

## 样例 #3

### 输入

```
3 7 1 1 3 9
3 3 2```

### 输出

```
//空行
2```

# AI分析结果


### 💡 Kay的C++算法解析：蚯蚓 深入学习指南 💡

#### **题目解读与核心算法识别**
✨ **本题主要考察**：`队列应用`（模拟+单调性维护）  
🗣️ **初步分析**：
> 解决蚯蚓问题的关键在于利用**切割单调性**和**偏移量技巧**。想象三条传送带（队列）分别运输原蚯蚓、切割左段和右段蚯蚓。每次只需比较传送带最前端的蚯蚓长度（实际长度=存储值+全局偏移量），切割后将新蚯蚓减去最新偏移量放回对应传送带末端。  
> - **核心难点**：证明切割后两段蚯蚓长度随时间保持单调性（详见dbxxx的严谨证明），以及通过偏移量避免O(m)的集体加q操作  
> - **可视化设计**：用三列像素方块表示队列，切割时高亮当前方块，新增方块用不同颜色标记，偏移量显示为顶部计数器。复古音效：切割时"咔嚓"声，增长时"滴答"声，过关时8-bit胜利音效  

---

#### **精选优质题解参考**
**题解一：dbxxx (422赞)**  
* **点评**：  
  思路直击核心——严谨证明切割单调性（纠正常见证明错误），代码中三个队列分工明确。亮点在于：  
  1. **偏移量处理**：用`qt`记录全局增长量，新蚯蚓入队时减`(q*i)`完美解决集体增长  
  2. **代码规范**：队列操作封装清晰，常量`mininf`处理边界  
  3. **实践价值**：可直接用于竞赛，时间复杂度O(m)  

**题解二：7KByte (91赞)**  
* **点评**：  
  教学性极强的题解，用"传送带"比喻解释队列单调性。亮点：  
  1. **偏移量图解**：详细注释`(i-1)*q`和`-i*q`的意义  
  2. **代码可读性**：变量名如`maxn`、`f`标识明确，控制面板式输出  
  3. **初学者友好**：逐步拆解队列比较逻辑  

**题解三：shadowice1984 (10赞)**  
* **点评**：  
  简洁版证明+轻量化实现。亮点：  
  1. **公式浓缩**：用不等式链`px+q ≥ p(x+q)`快速证得单调性  
  2. **空间优化**：固定长度数组替代STL队列  
  3. **调试技巧**：注释常见错误点如负号移出取整  

---

#### **核心难点辨析与解题策略**
1. **难点1：切割单调性证明**  
   * **分析**：设蚯蚓A先于B切割，需证A的左段≥B的左段（右段同理）。核心步骤：  
     ```math
     A ≥ B ⇒ ⌊pA⌋+q ≥ ⌊p(B+q)⌋
     ```
     *dbxxx的整数取整证法纠正了常见错误*  
   * 💡 **学习笔记**：单调性成立需满足两个条件：①x是整数 ②切割比例p恒定  

2. **难点2：全局增长的高效处理**  
   * **分析**：用`add`变量记录总增长量。切割时：  
     - 取出值：`真实长度 = 存储值 + add`  
     - 新蚯蚓：`存储值 = 新长度 - add - q`（抵消当前秒增长）  
   * 💡 **学习笔记**：此技巧适用于所有"集体增加，个别除外"问题  

3. **难点3：三队列维护与取值**  
   * **分析**：队列需始终保持单调递减：  
     - 初始队列从大到小排序  
     - 新蚯蚓直接推入对应队列末端（根据单调性自动有序）  
     - 比较队首时注意队列可能空  
   * 💡 **学习笔记**：用`-inf`初始化避免空队列判断失误  

#### **解题技巧总结**
- **技巧1：问题转化** → 将集体增长转化为新个体的负增长  
- **技巧2：数据结构选择** → 单调性问题首选队列而非堆  
- **技巧3：调试边界** → 空队列处理用`mininf`或`-0x3f3f3f3f`  

---

### **C++核心代码实现赏析**
```cpp
#include <queue>
#include <algorithm>
const int mininf = 0xc0c0c0c0; // 负无穷常量

int main() {
    // 输入初始化
    queue<int> q_orig, q_left, q_right; 
    vector<int> a(n);
    for (int i=0; i<n; ++i) cin >> a[i];
    sort(a.begin(), a.end(), greater<int>()); // 原队列递减排序

    int add = 0; // 全局偏移量
    for (int sec=0; sec<m; ++sec) {
        // 取三队列最大值
        int x = max({q_orig.empty()?mininf:q_orig.front(), 
                    q_left.empty()?mininf:q_left.front(),
                    q_right.empty()?mininf:q_right.front()});
        // 弹出最大值所在队列
        if (x == q_orig.front()) q_orig.pop();
        else if (x == q_left.front()) q_left.pop();
        else q_right.pop();
        
        x += add;     // 计算实际长度
        add += q;     // 更新全局偏移量
        
        int L = x * u / v, R = x - L; // 切割
        q_left.push(L - add);  // 新蚯蚓减去当前总偏移
        q_right.push(R - add);
    }
}
```
**关键解读**：
1. **偏移量魔术**：`add`记录所有蚯蚓累计增长，新蚯蚓入队时减`add`抵消历史增长  
2. **队列比较**：用`max({...})`优雅处理三队列取最值  
3. **切割计算**：注意整除特性`x*u/v`比`p*x`更精确  

---

### **算法可视化：像素动画演示**
![蚯蚓切割像素动画示意图](https://via.placeholder.com/400x200/00ff00/000?text=Queue+Visualization)  
* **主题**：8-bit风格"蚯蚓切割工厂"  
* **核心交互**：  
  1. **三列传送带**：  
     - 红带：原蚯蚓（像素块长度=存储值）  
     - 绿带：左段蚯蚓  
     - 蓝带：右段蚯蚓  
  2. **切割动画**：  
     - 选中蚯蚓闪烁红光 → 分裂为两个小块滑入对应队列末端  
     - 顶部计数器`add += q`同步更新  
  3. **音效设计**：  
     - 切割："咔嚓"（8-bit短促音）  
     - 增长："嘀嗒"（每步触发）  
     - 过关：收集满t只时播放胜利音效  
* **控制面板**：步进/暂停/速度滑块，支持自动演示（AI模式）  

---

### **拓展练习与相似问题思考**
1. **相似问题迁移**：  
   - 动态维护极值+新元素插入 → [P1886 滑动窗口]（单调队列）  
   - 集体增加+个别操作 → [P1253 扶苏的问题]（懒标记线段树）  
   - 切割类单调性 → [P6033 合并果子加强版]（双队列优化）  

2. **洛谷推荐**：  
   - [P1090 合并果子] → 优先队列入门  
   - [P2822 组合数问题] → 前缀和+单调性  
   - [P3960 列队] → 动态队列的高级应用  

---

### **学习心得与经验分享**
> **dbxxx的调试经验**：  
> *"偏移量初始值错误会导致切割长度偏差，建议用`qt=0`逐步模拟前3秒"*  
> **Kay总结**：  
> 1. 验证单调性时，用`p=0.6, x1=3, x2=2`测试`x1-⌊p*x1⌋ ≥ x2-⌊p*x2⌋`  
> 2. 队列空判断必须前置，否则`front()`会报错  
> 3. 切割长度用整数除法`(x*u)/v`避免浮点误差  

--- 
通过本指南，希望大家掌握队列优化中的**单调性证明**与**偏移量技巧**，像玩复古游戏一样享受算法设计的乐趣！ 🎮🚀

---
处理用时：99.92秒
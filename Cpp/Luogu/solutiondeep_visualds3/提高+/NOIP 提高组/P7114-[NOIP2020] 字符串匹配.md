# 题目信息

# [NOIP2020] 字符串匹配

## 题目描述

小 C 学习完了字符串匹配的相关内容，现在他正在做一道习题。

对于一个字符串 $S$，题目要求他找到 $S$ 的所有具有下列形式的拆分方案数：

$S = ABC$，$S = ABABC$，$S = ABAB \ldots ABC$，其中 $A$，$B$，$C$ 均是非空字符串，且 $A$ 中出现奇数次的字符数量不超过 $C$ 中出现奇数次的字符数量。

更具体地，我们可以定义 $AB$ 表示两个字符串 $A$，$B$ 相连接，例如 $A = \texttt{aab}$，$B = \texttt{ab}$，则 $AB = \texttt{aabab}$。

并递归地定义 $A^1=A$，$A^n = A^{n - 1} A$（$n \ge 2$ 且为正整数）。例如 $A = \texttt{abb}$，则 $A^3=\texttt{abbabbabb}$。

则小 C 的习题是求 $S = {(AB)}^iC$ 的方案数，其中 $F(A) \le F(C)$，$F(S)$ 表示字符串 $S$ 中出现奇数次的字符的数量。两种方案不同当且仅当拆分出的 $A$、$B$、$C$ 中有至少一个字符串不同。

小 C 并不会做这道题，只好向你求助，请你帮帮他。

## 说明/提示

**【样例 #1 解释】**

对于第一组数据，所有的方案为

1. $A=\texttt{n}$，$B=\texttt{nr}$，$C=\texttt{nnr}$。
2. $A=\texttt{n}$，$B=\texttt{nrn}$，$C=\texttt{nr}$。
3. $A=\texttt{n}$，$B=\texttt{nrnn}$，$C=\texttt{r}$。
4. $A=\texttt{nn}$，$B=\texttt{r}$，$C=\texttt{nnr}$。
5. $A=\texttt{nn}$，$B=\texttt{rn}$，$C=\texttt{nr}$。
6. $A=\texttt{nn}$，$B=\texttt{rnn}$，$C=\texttt{r}$。
7. $A=\texttt{nnr}$，$B=\texttt{n}$，$C=\texttt{nr}$。
8. $A=\texttt{nnr}$，$B=\texttt{nn}$，$C=\texttt{r}$。

**【数据范围】**

| 测试点编号 | $\lvert S \rvert \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 4$ | $10$ | 无 |
| $5 \sim 8$ | $100$ | 无 |
| $9 \sim 12$ | $1000$ | 无 |
| $13 \sim 14$ | $2^{15}$ | $S$ 中只包含一种字符 |
| $15 \sim 17$ | $2^{16}$ | $S$ 中只包含两种字符 |
| $18 \sim 21$ | $2^{17}$ | 无 |
| $22 \sim 25$ | $2^{20}$ | 无 |

对于所有测试点，保证 $1 \le T \le 5$，$1 \le |S| \le 2^{20}$。 

## 样例 #1

### 输入

```
3
nnrnnr
zzzaab
mmlmmlo
```

### 输出

```
8
9
16
```

## 样例 #2

### 输入

```
5
kkkkkkkkkkkkkkkkkkkk
lllllllllllllrrlllrr
cccccccccccccxcxxxcc
ccccccccccccccaababa
ggggggggggggggbaabab
```

### 输出

```
156
138
138
147
194
```

## 样例 #3

### 输入

```
见附件中的 string/string3.in```

### 输出

```
见附件中的 string/string3.ans```

## 样例 #4

### 输入

```
见附件中的 string/string4.in```

### 输出

```
见附件中的 string/string4.ans```

# AI分析结果


### 题目分析
我们需要解决字符串匹配问题：将字符串 $S$ 拆分为 $(AB)^i C$ 的形式，其中 $A, B, C$ 非空，且 $F(A) \leq F(C)$，$F(S)$ 表示字符串 $S$ 中出现奇数次的字符的数量。目标是计算满足条件的方案数。

### 算法选择
采用高效且清晰的解法：
1. **预处理扩展 KMP（Z 函数）**：快速计算子串的循环节。
2. **预处理前缀和后缀的 $F$ 值**：$pre[i]$ 表示 $S[1..i]$ 的 $F$ 值，$suf[i]$ 表示 $S[i..n]$ 的 $F$ 值。
3. **树状数组维护**：动态维护 $F$ 值的前缀和，支持高效查询满足 $F(A) \leq F(C)$ 的 $A$ 的数量。
4. **枚举 $AB$ 长度**：计算最大重复次数，利用奇偶分类统计贡献。

### 算法步骤
1. **预处理 Z 函数**：
   - $Z[i]$ 表示后缀 $S[i..n]$ 与 $S$ 的最长公共前缀长度。
   - 使用扩展 KMP 算法在 $O(n)$ 时间内完成。

2. **预处理 $F$ 值**：
   - $pre[i]$：从左到右遍历，维护字符计数数组，动态计算前缀 $F$ 值。
   - $suf[i]$：从右到左遍历，维护字符计数数组，动态计算后缀 $F$ 值。
   - 计算整个字符串的 $F$ 值 $F_{\text{all}}$。

3. **树状数组维护**：
   - 值域为 $[0, 26]$，树状数组大小为 27。
   - 支持单点增加和前缀和查询。

4. **枚举 $AB$ 长度 $i$（从 2 到 $n-1$）**：
   - **加入新的 $A$**：将长度为 $i-1$ 的前缀的 $F$ 值（$pre[i-1]$）加入树状数组。
   - **计算最大重复次数 $k$**：
     - $k = \min\left(\left\lfloor \frac{Z[i+1]}{i} \right\rfloor + 1, \left\lfloor \frac{n-1}{i} \right\rfloor\right)$。
   - **奇偶分类**：
     - 奇数次重复（$1, 3, \dots$）：次数 $k_{\text{odd}} = \left\lceil \frac{k}{2} \right\rceil$，$F(C_{\text{odd}}) = suf[k \cdot i + 1]$。
     - 偶数次重复（$2, 4, \dots$）：次数 $k_{\text{even}} = \left\lfloor \frac{k}{2} \right\rfloor$，$F(C_{\text{even}}) = F_{\text{all}}$。
   - **查询贡献**：
     - $cnt_{\text{odd}} = \text{query}(F(C_{\text{odd}}))$。
     - $cnt_{\text{even}} = \text{query}(F(C_{\text{even}}))$。
   - **累加答案**：$ans \gets ans + k_{\text{odd}} \cdot cnt_{\text{odd}} + k_{\text{even}} \cdot cnt_{\text{even}}$。

5. **输出答案**。

### 复杂度分析
- **时间复杂度**：$O(T \cdot n)$，其中 $T$ 为数据组数，$n$ 为字符串长度。Z 函数预处理 $O(n)$，枚举 $AB$ 长度 $O(n)$，树状数组操作 $O(1)$（值域固定）。
- **空间复杂度**：$O(n)$。

### 代码实现
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

typedef long long LL;
const int MAXN = (1 << 20) + 5;

int T, n;
char s[MAXN];
int Z[MAXN], pre[MAXN], suf[MAXN], F_all;
int tree[30];  // 树状数组，值域[0,26]

inline void add(int x, int val) {
    x++;
    while (x <= 27) {
        tree[x] += val;
        x += x & -x;
    }
}

inline int query(int x) {
    x++;
    int res = 0;
    while (x) {
        res += tree[x];
        x -= x & -x;
    }
    return res;
}

void getZ() {
    Z[1] = n;
    int l = 0, r = 0;
    for (int i = 2; i <= n; i++) {
        if (i <= r) 
            Z[i] = min(Z[i - l + 1], r - i + 1);
        else 
            Z[i] = 0;
        while (i + Z[i] <= n && s[Z[i] + 1] == s[i + Z[i]]) 
            Z[i]++;
        if (i + Z[i] - 1 > r) {
            l = i;
            r = i + Z[i] - 1;
        }
    }
}

void getPreSuf() {
    int cnt[26] = {0};
    // 计算前缀F值
    pre[0] = 0;
    for (int i = 1; i <= n; i++) {
        int c = s[i] - 'a';
        cnt[c] ^= 1;
        pre[i] = pre[i - 1] + (cnt[c] ? 1 : -1);
    }
    F_all = pre[n];  // 整个字符串的F值
    // 计算后缀F值
    memset(cnt, 0, sizeof(cnt));
    suf[n + 1] = 0;
    for (int i = n; i >= 1; i--) {
        int c = s[i] - 'a';
        cnt[c] ^= 1;
        suf[i] = suf[i + 1] + (cnt[c] ? 1 : -1);
    }
}

int main() {
    scanf("%d", &T);
    while (T--) {
        scanf("%s", s + 1);
        n = strlen(s + 1);
        // 初始化
        memset(Z, 0, sizeof(Z));
        memset(pre, 0, sizeof(pre));
        memset(suf, 0, sizeof(suf));
        memset(tree, 0, sizeof(tree));
        getZ();
        getPreSuf();
        LL ans = 0;
        // 枚举AB长度i（从2到n-1）
        for (int i = 2; i <= n - 1; i++) {
            // 加入长度为i-1的A的F值
            add(pre[i - 1], 1);
            // 计算最大重复次数k
            int k = min(Z[i + 1] / i + 1, (n - 1) / i);
            int k_odd = (k + 1) / 2;   // 奇数次重复次数
            int k_even = k / 2;        // 偶数次重复次数
            // 计算两种C的F值
            int F_odd = suf[k * i + 1];
            int F_even = F_all;
            // 查询树状数组
            int cnt_odd = query(F_odd);
            int cnt_even = query(F_even);
            // 累加贡献
            ans += (LL)k_odd * cnt_odd + (LL)k_even * cnt_even;
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```

### 注意事项
1. **多组数据初始化**：每组数据开始前需清空相关数组。
2. **边界处理**：$AB$ 长度 $i$ 从 2 开始，确保 $A$ 和 $B$ 非空；$C$ 至少一个字符，故 $i \leq n-1$。
3. **树状数组下标**：$F$ 值范围 $[0, 26]$，树状数组下标需 $+1$ 避免 0。
4. **重复次数计算**：利用 Z 函数高效计算最大重复次数 $k$，注意取最小值避免越界。

此算法高效且易于实现，能够满足题目要求。

---
处理用时：229.35秒
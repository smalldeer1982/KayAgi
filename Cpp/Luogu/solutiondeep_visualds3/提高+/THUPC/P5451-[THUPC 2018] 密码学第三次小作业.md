# 题目信息

# [THUPC 2018] 密码学第三次小作业

## 题目背景

1977年，罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）提出了RSA 加密算法。RSA 加密算法是一种非对称加密算法，其可靠性由极大整数因数分解的难度决定。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。

RSA 的基本原理如下：

- 公钥与私钥的产生
  1. 随机选择两个不同大质数 $p$ 和 $q$，计算 $N=p\times q$
  2. 根据欧拉函数性质，求得 $r=\varphi (N)=\varphi (p)\varphi (q)=(p-1)(q-1)$
  3. 选择一个小于 $r$ 的正整数 $e$，使 $e$ 和 $r$ 互质。并求得 $e$ 关于 $r$ 的乘法逆元 $d$，有 $ed\equiv 1 \pmod r$
  4. 将 $p$ 和 $q$ 的记录销毁。此时，$(N,e)$ 是公钥，$(N,d)$ 是私钥。
- 消息加密：首先需要将消息 $m$ 以一个双方约定好的格式转化为一个小于 $N$，且与 $N$ 互质的整数 $n$。如果消息太长，可以将消息分为几段，这也就是我们所说的块加密，后对于每一部分利用如下公式加密：

$$
n^{e}\equiv c\pmod N
$$

- 消息解密：利用密钥 $d$ 进行解密

$$
c^{d}\equiv n\pmod N
$$

## 题目描述

现在有两个用户由于巧合，拥有了相同的模数 $N$，但是私钥不同。设两个用户的公钥分别为 $e_1$ 和 $e_2$，**且两者互质**。明文消息为 $m$，密文分别为：

$$\begin{matrix}c_1=m^{e_1}\bmod N\\c_2=m^{e_2}\bmod N\end{matrix}$$

现在，一个攻击者截获了 $c_1$ ，$c_2$，$e_1$，$e_2$，$N$，请帮助他恢复出明文 $m$ 。

## 说明/提示

### 版权信息

来自 2018 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2018），感谢 [Pony.ai](http://pony.ai/) 对此次比赛的支持。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2018> 查看。

## 样例 #1

### 输入

```
1
1502992813 2511821915 653507 57809 2638352023```

### 输出

```
19260817```

# AI分析结果


### 💡 Kay的C++算法解析：密码学第三次小作业 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：数学（数论）与编程技巧应用

🗣️ **初步分析**：
> 这道题要求我们利用数论知识恢复RSA加密的明文。核心思路是通过公钥指数`e1`和`e2`的互质特性，找到整数`s`和`t`使得`s*e1 + t*e2 = 1`。此时，明文`m`可表示为`m ≡ c1^s * c2^t (mod N)`。关键难点在于处理负指数和大数运算：
> - 当`s/t`为负时，需先求密文的模逆元
> - 使用龟速乘避免乘法溢出
> 
> 可视化方案将采用8位像素风格：左侧展示扩展欧几里得算法的辗转相除过程（像素方块表示数字），右侧动态显示密钥组合过程。当负指数出现时，对应密文块会"翻转"并播放像素音效；计算模幂时，快速幂的二进制分解会以像素进度条展示，龟速乘的累加过程用像素柱状图表示，关键步骤触发复古音效。

#### 2. 精选优质题解参考
**题解一（作者：Aw顿顿）**
* **点评**：思路推导清晰完整，从互质条件切入到裴蜀定理应用，逻辑严密。代码规范性强：龟速乘(`gsc`)和快速幂(`ksm`)独立封装，变量名语义明确(`s/t`)。亮点在于完整推导了负指数转化公式，并给出逆元计算的数学证明。边界处理严谨，可直接用于竞赛场景。

**题解二（作者：GoPoux4）**
* **点评**：以考试经历引入，强调识破题目背景干扰的实战经验。代码结构优秀：功能模块化（`fti`龟速乘/`fmi`快速幂/`inv`逆元），关键步骤有详细注释。亮点在于明确量化数据范围(`2^63`)，并强调龟速乘的必要性，实践指导价值突出。

**题解三（作者：lemir3）**
* **点评**：通过错误案例分析强化核心考点认知。代码健壮性强：逆元计算包含异常检测(`g==1`)，龟速乘(`FastMul`)使用位运算优化。亮点在于提出"问题分解树"思维——将问题拆解为线性组合、模逆元、模幂三个子问题，助力学习者举一反三。

#### 3. 核心难点辨析与解题策略
1. **难点：指数线性组合的构造**
   * **分析**：利用`gcd(e1,e2)=1`的特性，通过扩展欧几里得算法求`s,t`。优质题解均采用递归实现`exgcd`，关键在理解递推式`x=y1, y=x1-(a/b)*y1`的推导
   * 💡 学习笔记：互质条件提示线性组合存在性，这是数论问题的经典突破口

2. **难点：负指数的转化处理**
   * **分析**：当`s/t<0`时，需计算`c^{-|s|} = (c^{-1})^{|s|}`。由于`N`非质数，需用`exgcd`求逆元而非费马小定理
   * 💡 学习笔记：负指数转化本质是模逆元应用，`a·a^{-1} ≡ 1 (mod N)`是核心关系式

3. **难点：大数运算防溢出**
   * **分析**：`N`最大达`2^63`，直接乘会溢出。龟速乘将乘法分解为加法：`a*b = 2a*(b/2) + a*(b%2)`，每次加法后立即取模
   * 💡 学习笔记：龟速乘以时间复杂度换空间安全，是处理大数模算的利器

✨ **解题技巧总结**
- **技巧1：数论条件转化** - 将互质条件转化为线性方程是核心突破点
- **技巧2：模块化封装** - 独立实现`exgcd/龟速乘/快速幂`提升代码复用性
- **技巧3：边界防御性编程** - 显式处理负指数和逆元不存在等临界情况

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**
```cpp
#include <iostream>
#define ll long long
using namespace std;

ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (!b) { x = 1; y = 0; return a; }
    ll d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

ll slow_mul(ll a, ll b, ll mod) { // 龟速乘
    ll res = 0;
    while (b) {
        if (b & 1) res = (res + a) % mod;
        a = (a + a) % mod;
        b >>= 1;
    }
    return res;
}

ll mod_pow(ll base, ll exp, ll mod) { // 快速幂
    ll res = 1;
    while (exp) {
        if (exp & 1) res = slow_mul(res, base, mod);
        base = slow_mul(base, base, mod);
        exp >>= 1;
    }
    return res;
}

int main() {
    int T; cin >> T;
    while (T--) {
        ll c1, c2, e1, e2, N;
        cin >> c1 >> c2 >> e1 >> e2 >> N;
        ll s, t, g = exgcd(e1, e2, s, t);
        
        if (s < 0) { // 处理负指数
            ll inv_c1, y;
            exgcd(c1, N, inv_c1, y);
            c1 = (inv_c1 % N + N) % N;
            s = -s;
        }
        if (t < 0) {
            ll inv_c2, y;
            exgcd(c2, N, inv_c2, y);
            c2 = (inv_c2 % N + N) % N;
            t = -t;
        }
        
        ll part1 = mod_pow(c1, s, N);
        ll part2 = mod_pow(c2, t, N);
        cout << slow_mul(part1, part2, N) << endl;
    }
    return 0;
}
```
**代码解读概要**：通过`exgcd`求线性组合系数→处理负指数（求逆元）→龟速乘+快速幂计算模幂→相乘得明文。核心是三重防御：龟速乘防溢出、负指数转化、逆元存在性验证。

**题解一（Aw顿顿）片段赏析**
```cpp
exgcd(e1, e2, s, t);
if (s < 0) c1 = inv(c1, N), s = -s;
if (t < 0) c2 = inv(c2, N), t = -t;
cout << gsc(ksm(c1, s, N), ksm(c2, t, N), N);
```
* **亮点**：负指数处理简洁有力
* **学习笔记**：将逆元计算封装为`inv()`，提升代码可读性

**题解二（GoPoux4）片段赏析**
```cpp
ll inv(ll a, ll b) {
    ll x, y;
    exgcd(a, b, x, y);
    return (x % b + b) % b;
}
```
* **亮点**：独立逆元函数处理负值转换
* **学习笔记**：`(x%b+b)%b`确保返回最小正整数解

**题解三（lemir3）片段赏析**
```cpp
if (p < 0) {
    c1 = inv(c1, N);
    p = -p;
}
```
* **亮点**：显式变量名`p`/`q`替代`s`/`t`增强语义
* **学习笔记**：逆元计算前置化简化主逻辑

#### 5. 算法可视化：像素动画演示
**主题**："像素密探"的密钥破解任务（8-bit风格）

**核心演示**：
1. **场景初始化**：16x16像素网格，左侧显示`e1,e2`钥匙，右侧为加密锁`N`
2. **扩展欧几里得动画**：
   - 像素数字`e1,e2`碰撞→迸溅出余数方块（音效：8-bit碰撞声）
   - 递归回溯时显示系数更新公式`x=y1, y=x1-(a/b)y1`
3. **负指数转化**：
   - 当`s<0`时，`c1`方块旋转180°+闪烁（音效：像素翻转声）
   - 显示逆元计算：`c1 * inv ≡ 1 (mod N)`（动态绘制同余方程）
4. **龟速乘演示**：
   - 底栏进度条：二进制指数分解过程
   - 柱状图：累加器`res`随循环增长，溢出值以红色像素警告
5. **胜利动画**：锁具裂开露出`m`，播放16-bit胜利音乐

**交互设计**：
- 控制面板：步进/暂停/速度滑块（复古游戏手柄样式）
- 自动演示模式：AI角色自动执行完整流程
- 调试模式：悬停显示变量当前值

#### 6. 拓展练习与相似问题思考
**通用技巧迁移**：
1. 线性同余方程求解（如`ax ≡ c (mod m)`）
2. 多密钥RSA攻击（共模攻击/广播攻击）
3. 组合数学的模运算优化

**洛谷练习推荐**：
1. **P1082 同余方程**  
   → 掌握模逆元的核心计算
2. **P4549 裴蜀定理**  
   → 强化线性组合的应用能力
3. **P3853 路标设置**  
   → 训练问题分解思维（虽非数论题）

#### 7. 学习心得与经验分享
> **作者Aw顿顿的调试经验**：  
> "最初在负数指数处理卡壳，误用费马小定理导致WA。后用exgcd求逆元时才明白：模数非质数时，欧拉定理不可直接套用"  
>   
> **Kay的总结**：  
> 数论问题需严格验证定理前提条件！建议分三步调试：  
> 1. 验证`exgcd`输出的`s*e1+t*e2=1`  
> 2. 单独测试逆元计算  
> 3. 用小模数逐步验证快速幂  

---

本次解析到此结束。记住，密码学是数学与工程的完美结合，理解基础原理才能应对万变！下次挑战再见！🚀

---
处理用时：214.16秒
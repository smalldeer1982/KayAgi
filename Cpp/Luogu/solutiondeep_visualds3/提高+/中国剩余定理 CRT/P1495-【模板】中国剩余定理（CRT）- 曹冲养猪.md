# 题目信息

# 【模板】中国剩余定理（CRT）/ 曹冲养猪

## 题目描述

自从曹冲搞定了大象以后，曹操就开始捉摸让儿子干些事业，于是派他到中原养猪场养猪，可是曹冲满不高兴，于是在工作中马马虎虎，有一次曹操想知道母猪的数量，于是曹冲想狠狠耍曹操一把。举个例子，假如有 $16$ 头母猪，如果建了 $3$ 个猪圈，剩下 $1$ 头猪就没有地方安家了。如果建造了 $5$ 个猪圈，但是仍然有 $1$ 头猪没有地方去，然后如果建造了 $7$ 个猪圈，还有 $2$ 头没有地方去。你作为曹总的私人秘书理所当然要将准确的猪数报给曹总，你该怎么办？

## 说明/提示

$1 \leq n\le10$，$0 \leq b_i\lt a_i\le100000$，$1 \leq \prod a_i \leq 10^{18}$

## 样例 #1

### 输入

```
3
3 1
5 1
7 2```

### 输出

```
16```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】中国剩余定理（CRT）/ 曹冲养猪 深入学习指南 💡

## 引言
今天我们要解决的是经典数论问题——**曹冲养猪**，它的本质是求**模数两两互质的同余方程组**的最小非负整数解。这道题是**中国剩余定理（CRT）**的模板题，掌握它能帮你打开数论世界的大门！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：中国剩余定理（CRT）  

🗣️ **初步分析**：  
简单来说，中国剩余定理就像“拼拼图”——每个同余方程是一块“小拼图”，我们需要把这些小拼图**合并成一个完整的解**。比如题目中的样例：  
- 猪数模3余1（$x\equiv1\pmod{3}$）  
- 模5余1（$x\equiv1\pmod{5}$）  
- 模7余2（$x\equiv2\pmod{7}$）  

CRT的核心思想是：  
1. 计算所有模数的乘积$M$（比如样例中$M=3×5×7=105$）；  
2. 对每个方程，计算$M_i = M / a_i$（比如第一个方程的$M_1=105/3=35$）；  
3. 找到$M_i$在模$a_i$下的**逆元**（即一个数$t_i$，使得$M_i×t_i\equiv1\pmod{a_i}$，比如$35×2=70\equiv1\pmod{3}$，所以$t_1=2$）；  
4. 最终解为$x = (b_1×M_1×t_1 + b_2×M_2×t_2 + ... + b_n×M_n×t_n) \mod M$（样例中$x=1×35×2 + 1×21×1 + 2×15×1=70+21+30=121$，$121\mod105=16$，正好是答案）。  

**题解的两种主要思路**：  
- **直接CRT**：按上述步骤计算，适合模数互质的情况（本题就是！）；  
- **逐步合并方程**：从第一个方程开始，每次合并下一个方程，用扩展欧几里得找解（适合模数不互质的情况，比如扩展CRT）。  

**可视化设计思路**：  
我们用**8位像素风**展示CRT的计算过程——  
- 每个同余方程用不同颜色的“猪圈像素块”表示（比如红色代表模3，蓝色代表模5）；  
- $M$是一个“大积木”，由所有猪圈块拼接而成；  
- $M_i$是去掉当前猪圈块后的积木；  
- 逆元$t_i$用“闪烁的钥匙像素”表示，找到钥匙就能打开当前猪圈的“锁”；  
- 累加时，每个部分的数值用“像素小球”飞入结果框，最终弹出答案。  


## 2. 精选优质题解参考

为大家筛选了**3份高质量题解**，覆盖不同思路，适合不同阶段的学习者：

### 题解一：枚举法（作者：vectorwyx，赞210）  
* **点评**：  
  这是最适合**入门**的思路！作者没有用复杂的数论知识，而是用“逐步满足条件”的方法：从第一个方程的解开始，不断加上前一个模数的最小公倍数，直到满足所有方程。比如样例中，先找满足模3余1的数（1,4,7,...），再找其中满足模5余1的数（1,16,31,...），最后找满足模7余2的数（16）。代码逻辑简单，变量名清晰（比如`sum`表示累加的步长），适合理解CRT的“合并”本质。


### 题解二：标准CRT实现（作者：Tomwsc，赞27）  
* **点评**：  
  这是**最规范的CRT模板**！作者严格按照CRT的步骤编写代码：  
  1. 计算所有模数的乘积$M$；  
  2. 对每个方程计算$M_i$和逆元$t_i$；  
  3. 累加所有项并取模。  
  代码中用了`__int128`处理大数（避免乘积溢出），逆元用扩展欧几里得算法求解，逻辑严谨，适合直接作为竞赛模板。


### 题解三：逐步合并方程（作者：chrispang，赞1）  
* **点评**：  
  这是**最易理解的“合并”思路**！作者把问题拆成“合并两个方程”的子问题：比如先合并前两个方程得到新的方程，再合并第三个，直到所有方程合并完成。这种方法不需要记CRT的公式，而是通过扩展欧几里得找两个方程的共同解，适合深入理解同余方程组的本质。


## 3. 核心难点辨析与解题策略

在解决这道题时，你可能会遇到以下**3个核心难点**，我们一一解决：

### 1. 理解CRT的“逆元”为什么重要？  
* **难点**：为什么要找$M_i$的逆元？  
* **分析**：逆元的作用是让$M_i×t_i\equiv1\pmod{a_i}$，这样当我们计算$b_i×M_i×t_i$时，它会**只影响当前方程的余数**，而不影响其他方程（因为$M_i$是其他模数的乘积，模其他模数为0）。比如样例中$35×2=70$，模3余1，模5和7都余0，所以$1×70$只会贡献模3余1的部分。  
* 💡 **学习笔记**：逆元是CRT的“开关”，让每个部分只影响对应的方程。


### 2. 如何处理大数溢出？  
* **难点**：模数的乘积可能超过`long long`的范围（比如$10^5×10^5=10^{10}$，10个这样的数乘积是$10^{50}$）。  
* **分析**：解决方法有两种：  
  - 用更大的数据类型（如`__int128`，C++支持，但输出需要手动实现）；  
  - 用**快速乘**（把乘法拆成加法，避免溢出）。  
* 💡 **学习笔记**：遇到大数乘积，先想`__int128`，不行再用快速乘。


### 3. 如何用扩展欧几里得求逆元？  
* **难点**：逆元的求解需要扩展欧几里得算法，它的原理是什么？  
* **分析**：扩展欧几里得算法可以找到整数$x,y$，使得$ax + by = \gcd(a,b)$。当$a$和$b$互质时（比如$M_i$和$a_i$），$\gcd(a,b)=1$，所以$x$就是$a$的逆元（因为$ax\equiv1\pmod{b}$）。  
* 💡 **学习笔记**：逆元存在的条件是两个数互质，用扩展欧几里得可以找到它。


### ✨ 解题技巧总结  
1. **问题拆解**：把大的同余方程组拆成小问题，逐个解决；  
2. **数据类型**：遇到大数用`__int128`或快速乘；  
3. **逆元求解**：用扩展欧几里得算法，记住模板；  
4. **边界处理**：最终解要取模$M$，并调整为非负数（比如`(ans % M + M) % M`）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合标准CRT思路，处理了大数问题，适合作为模板。  
* **完整核心代码**：  
```cpp
#include <iostream>
using namespace std;
typedef long long ll;

ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) { x = 1; y = 0; return a; }
    ll d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

ll inv(ll a, ll mod) {
    ll x, y;
    exgcd(a, mod, x, y);
    return (x % mod + mod) % mod; // 调整为正逆元
}

int main() {
    int n; cin >> n;
    ll M = 1, ans = 0;
    ll a[20], b[20]; // a是模数，b是余数
    for (int i = 0; i < n; i++) {
        cin >> a[i] >> b[i];
        M *= a[i]; // 计算所有模数的乘积
    }
    for (int i = 0; i < n; i++) {
        ll Mi = M / a[i]; // 计算Mi = M / a[i]
        ll ti = inv(Mi, a[i]); // 求Mi的逆元
        // 用__int128避免乘积溢出
        __int128 term = (__int128)b[i] * Mi % M;
        term = term * ti % M;
        ans = (ans + (ll)term) % M;
    }
    cout << (ans % M + M) % M << endl; // 确保非负
    return 0;
}
```
* **代码解读概要**：  
  1. 读取输入，计算所有模数的乘积$M$；  
  2. 对每个方程，计算$Mi = M/a[i]$和逆元$ti$；  
  3. 累加$b[i]×Mi×ti$，用`__int128`处理大数；  
  4. 输出结果（调整为非负数）。


### 题解一（枚举法）核心片段赏析  
* **亮点**：思路简单，适合入门。  
* **核心代码片段**：  
```cpp
long long n, ans, sum = 1;
struct pig { int a1, b1; } a[11];
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i].a1 >> a[i].b1;
    ans = a[1].b1; // 初始解：第一个方程的余数
    for (int i = 1; i < n; i++) {
        sum = sum * a[i].a1 / gcd(sum, a[i].a1); // 累加步长是前i个模数的LCM
        while (ans % a[i+1].a1 != a[i+1].b1) ans += sum; // 找到满足下一个方程的解
    }
    cout << ans;
}
```
* **代码解读**：  
  - `ans`初始化为第一个方程的余数（比如样例中的1）；  
  - `sum`是前i个模数的最小公倍数（LCM），每次累加`sum`，直到`ans`满足下一个方程；  
  - 比如样例中，第一次累加`sum=3`（LCM(3)），找到16满足模5余1；第二次累加`sum=15`（LCM(3,5)），16已经满足模7余2，结束。  
* 💡 **学习笔记**：枚举法是CRT的“直观版”，适合理解合并过程。


### 题解三（逐步合并方程）核心片段赏析  
* **亮点**：不用记CRT公式，通过合并两个方程理解本质。  
* **核心代码片段**：  
```cpp
int exgcd(int a, int b, int &x, int &y) {
    if (b == 0) { x = 1; y = 0; return a; }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
int main() {
    int n, a1, m1; cin >> n >> a1 >> m1;
    for (int i = 1; i < n; i++) {
        int a2, m2; cin >> a2 >> m2;
        int c = m2 - m1, k1 = 0, k2 = 0;
        int d = exgcd(a1, -a2, k1, k2); // 解k1*a1 -k2*a2 = m2 -m1
        k1 = (k1 * (c / d) % (abs(a2 / d)) + abs(a2 / d)) % abs(a2 / d); // 调整k1为最小正解
        m1 = a1 * k1 + m1; // 新的余数
        a1 = abs(a1 / d * a2); // 新的模数（LCM(a1,a2)）
    }
    cout << m1;
}
```
* **代码解读**：  
  - 每次合并前两个方程：$x \equiv m1 \pmod{a1}$和$x \equiv m2 \pmod{a2}$；  
  - 用扩展欧几里得找$k1$，使得$x = k1*a1 + m1$满足第二个方程；  
  - 合并后的新方程是$x \equiv m1 \pmod{a1}$（其中$a1$是LCM(a1,a2)）；  
* 💡 **学习笔记**：合并方程是CRT的“本质版”，适合深入理解同余。


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题  
**像素猪圈历险记**——你是一个小农夫，需要找到满足所有猪圈条件的猪数。每个猪圈对应一个同余方程，你需要收集“钥匙”（逆元）打开猪圈，最终得到答案。


### 核心演示内容  
1. **场景初始化**：  
   - 8位像素风格的农场背景，有3个猪圈（对应样例的3个方程），分别是红色（模3）、蓝色（模5）、绿色（模7）；  
   - 底部控制面板有“单步”“自动”“重置”按钮，速度滑块，以及当前步骤的代码提示。

2. **计算M**：  
   - 三个猪圈的像素块合并成一个大的“M积木”（显示数值105），伴随“叮”的音效。

3. **计算Mi和逆元**：  
   - 点击红色猪圈，弹出“Mi=35”（M/3），然后出现一把“闪烁的钥匙”（逆元2），伴随“滴”的音效；  
   - 同理处理蓝色猪圈（Mi=21，逆元1）和绿色猪圈（Mi=15，逆元1）。

4. **累加计算**：  
   - 每个猪圈的“b_i×Mi×ti”用像素小球表示（红色小球70，蓝色21，绿色30），依次飞入结果框，累加后显示121；  
   - 结果框闪烁，弹出“121 mod 105 = 16”，伴随胜利音效（8位风格的“嘟嘟嘟”）。

5. **交互设计**：  
   - 单步执行：点击“下一步”，逐步展示每个步骤；  
   - 自动播放：调整速度滑块，动画自动运行；  
   - 重置：回到初始状态，重新开始。


### 设计思路  
用**8位像素风**降低学习门槛，用“猪圈”“钥匙”“小球”等具象化元素理解抽象的数论概念。音效和交互让学习更有趣，比如“叮”声强化“计算M”的记忆，“滴”声强化“找到逆元”的成就感。


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
CRT不仅能解决“曹冲养猪”，还能应用在：  
1. **日程安排**：比如几个人的空闲时间分别是每3天、5天、7天有空，找共同的空闲日；  
2. **密码学**：RSA算法中，用CRT合并多个素数的加密结果；  
3. **数学竞赛**：解决“求满足多个余数条件的最小数”问题。


### 洛谷练习推荐  
1. **洛谷 P4777** - 扩展中国剩余定理（EXCRT）  
   🗣️ **推荐理由**：本题的进阶版，模数不互质，需要用扩展CRT，巩固合并方程的思路。  
2. **洛谷 P1082** - 同余方程  
   🗣️ **推荐理由**：练习扩展欧几里得算法，掌握逆元的求解。  
3. **洛谷 P1516** - 青蛙的约会  
   🗣️ **推荐理由**：实际问题转化为同余方程，锻炼建模能力。  
4. **洛谷 P2613** - 有理数的循环节  
   🗣️ **推荐理由**：用同余解决循环节问题，拓展CRT的应用场景。


## 7. 学习心得与经验分享  
从题解中，我们可以学到：  
- **大数处理**：很多题解用`__int128`处理乘积溢出，这是竞赛中的常用技巧；  
- **逆元求解**：扩展欧几里得是求逆元的“万能方法”，比费马小定理更通用（费马小定理要求模数是质数）；  
- **思路选择**：入门用枚举法，竞赛用标准CRT，深入理解用合并方程法，根据需求选思路。


## 总结  
通过这道题，我们掌握了中国剩余定理的核心思想和实现方法。记住：**数论问题的关键是理解“模”的意义，把抽象的公式转化为具体的例子**。多练习相似问题，你会越来越熟练！💪  

下次我们会挑战更难的数论问题，比如扩展CRT，敬请期待！

---
处理用时：174.48秒
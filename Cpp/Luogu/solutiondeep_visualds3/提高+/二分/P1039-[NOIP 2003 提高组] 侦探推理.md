# 题目信息

# [NOIP 2003 提高组] 侦探推理

## 题目描述

明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：

$$
\def\arraystretch{1.5}
\begin{array}{|l|l|}\hline
\textbf{\textsf{证词内容}} & \textbf{\textsf{证词含义}}\\\hline
\text{I am guilty.} & \text{我是罪犯。} \\\hline
\text{I am not guilty.} & \text{我不是罪犯。} \\\hline
\text{{\tt XXX} is guilty.} & \text{{\tt XXX} 是罪犯。其中 {\tt XXX} 表示某个同学的名字。} \\\hline
\text{{\tt XXX} is not guilty.} & \text{{\tt XXX} 不是罪犯。} \\\hline
\text{Today is {\tt XXX}.} &
\begin{aligned}
&\text{今天是 {\tt XXX}。其中 {\tt XXX} 表示某个星期的单词。}\\
&\text{星期只有可能是以下之一：}\\
&\texttt{Monday}, \texttt{Tuesday}, \texttt{Wednesday}, \texttt{Thursday}, \\
&\texttt{Friday}, \texttt{Saturday}, \texttt{Sunday}。
\end{aligned}
\\\hline
\end{array}$$

证词中出现的其他话，都不列入逻辑推理的内容。


明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。


现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！

## 说明/提示

对于 $100\%$ 数据，满足 $1\le M\le 20$，$0\le N\le M$，$1\le P\le 100$。

**【题目来源】**

NOIP 2003 提高组第二题

## 样例 #1

### 输入

```
3 1 5
MIKE
CHARLES
KATE
MIKE: I am guilty.
MIKE: Today is Sunday.
CHARLES: MIKE is guilty.
KATE: I am guilty.
KATE: How are you??
```

### 输出

```
MIKE
```

# AI分析结果


### 💡 Kay的C++算法解析：侦探推理 深入学习指南 💡

<introduction>
今天我们来分析NOIP 2003提高组题目"侦探推理"。这道题需要根据真假混杂的证词找出唯一的罪犯，考验逻辑推理和枚举能力。本指南将带你深入理解解题思路和实现技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举应用` + `逻辑验证`

🗣️ **初步分析**：
> 解决侦探推理题就像玩一场**真人版狼人杀**：我们需要枚举每个嫌疑人当"狼人"（罪犯）的可能性，同时枚举日期作为验证条件。核心是通过证词一致性检查，锁定说假话的人是否符合题目要求的N人。
> - **思路本质**：双重枚举（罪犯+日期）→ 验证每人的证词一致性 → 统计假话人数
> - **关键难点**：处理"I"的特殊性、过滤无效证词、处理未发言者
> - **可视化设计**：采用像素风侦探事务所场景，嫌疑人头像排开。枚举时高亮当前嫌疑人和日期，证词验证时用✔️/❌气泡显示结果，关键步骤配8bit音效（如矛盾时的"error"音）

---

## 2. 精选优质题解参考

**题解一：wjyyy（4.5星）**
* **点评**：思路清晰度极佳，首创"枚举罪犯+日期"的双重循环框架，被后续题解广泛借鉴。代码规范性突出：使用`map`精确映射人名，`vector`分类存储证词，变量名`cnt/ran`含义明确。算法有效性体现在用状态标记快速排除矛盾情况。实践价值高，边界处理严谨（如`gets()`过滤无效输入）。

**题解二：Ebola（4星）**
* **点评**：亮点在独立的废话检测函数`crap()`，大幅简化输入处理。思路采用"先存证词后验证"模式，通过两次判断（一致性+假话人数）确保正确性。代码中`check()`函数对未说话者的处理极具参考价值，但部分变量命名可优化（如`asdfghjkl`）。

**题解三：Phigros_11calors（4星）**
* **点评**：结构最简洁的解法，独创`judge()`函数分类解析证词类型。亮点在状态标记系统（真话=0/假话=1/未定=-1），通过`negs`变量优雅处理未发言者。剪枝策略的提出展现深度思考，但输入处理可更健壮。

---

## 3. 核心难点辨析与解题策略

1.  **证词有效性解析**
    * **分析**：必须精准识别5类有效证词并忽略其他。优质解法均采用**分层判断**：先判断主语类型（I/Today/人名），再解析谓词结构。wjyyy解法中`if(u<=n)`的分流处理堪称典范。
    * 💡 学习笔记：用`map`存储人名库可快速验证主语有效性

2.  **说话人一致性验证**
    * **分析**：同一人的所有证词必须全真或全假。核心实现是**状态标记法**：初始化`mp[人名]=-1`，验证中冲突即跳出循环。如Phigros解法中，若某人既被标记0(真)又出现矛盾证词，立即返回`false`。
    * 💡 学习笔记：一致性检查必须覆盖该人的所有证词

3.  **未说话者处理**
    * **分析**：未提供有效证词者可能说真/假话。关键技巧是用`none/ran`变量计数，最终检查`n ∈ [cnt, cnt+none]`。Ebola解法中的`if(num[i]==0) ans++`是典型实现。
    * 💡 学习笔记：未发言者是解题的"缓冲变量"

### ✨ 解题技巧总结
- **分层处理输入**：先分类证词类型，再解析具体内容
- **防御式编程**：用`gets()`或`getline`跳过无效输入
- **状态标记法**：用-1/0/1表示未定/真话/假话三种状态
- **剪枝优化**：发现矛盾立即跳出循环（如wjyyy的`flag`变量）

---

## 4. C++核心代码实现赏析

**通用核心实现参考**
```cpp
#include <iostream>
#include <map>
#include <vector>
using namespace std;

// 核心逻辑伪代码
for(int 罪犯=1; 罪犯<=M; ++罪犯) {
  for(int 日期=1; 日期<=7; ++日期) {
    int 假话数=0, 未定者=0;
    for(int 人=1; 人<=M; ++人) {
      if(该人无证词) { 未定者++; continue; }
      bool 当前状态 = 验证所有证词(人, 罪犯, 日期);
      if(出现矛盾) break;
      假话数 += 当前状态 ? 1 : 0;
    }
    if(假话数<=N && 假话数+未定者>=N) 记录嫌疑人;
  }
}
```

**题解一：wjyyy（证词分类存储）**
```cpp
// 在vector中存储结构化证词
struct sta { int u; bool to, is; };
vector<sta> v[25]; 

// 证词验证片段
if(tmp.to) rea = (tmp.u==j);       // 日期类证词
else rea = ((tmp.u==i)^(!tmp.is)); // 人物类证词
```
* **解读**：`sta`结构体用`to`标记证词类型（0=人物/1=日期），`is`标记肯定/否定。验证时通过位运算`^`巧妙处理否定逻辑，例如当假设罪犯是i时，`is=0`的否定句应返回`true`。
* 💡 学习笔记：位运算高效处理逻辑关系

**题解二：Ebola（未说话者处理）**
```cpp
// 在check()函数中补全未说话者
if(ans!=n) {
  for(int i=1;i<=m;i++) {
    if(num[i]==0) ans++; // 该人无有效证词
    if(ans==n) break;
  }
}
```
* **解读**：优先统计有证词者的假话数，不足N时再用未说话者补齐。`num[i]==0`是关键判断条件，对应该人的证词vector为空。
* 💡 学习笔记：未说话者是灵活的"填充变量"

**题解三：Phigros（状态标记法）**
```cpp
// 初始化状态映射
map<string,int> mp; // -1=未定 0=真话 1=假话
for(int i=1;i<=m;i++) mp[name[i]]=-1;

// 验证中更新状态
if(证词矛盾当前标记) return false;
else if(符合假设) mp[name]=0;
else mp[name]=1;
```
* **解读**：用`mp`字典动态维护每人状态，初始化为-1（未定）。验证中一旦确定状态即更新，冲突立即返回。比全局变量更安全。
* 💡 学习笔记：容器化状态管理增强可读性

---

## 5. 算法可视化：像素动画演示

**主题**：8-bit侦探事务所  
**核心交互**：  
```plaintext
┌──────────────────────┐
│ 嫌疑人头像排开       │ 
│ 🕵️‍♂️ MIKE CHARLES KATE│ 
│ 当前：🔴MIKE 星期:MON│
└──────────────────────┘
```
1. **初始化**：像素风房间，嫌疑人用16x16像素头像展示
2. **枚举过程**：
   - 罪犯枚举：嫌疑人头像轮流泛红光 🔴
   - 日期枚举：顶部像素时钟显示周一到周日 📅
3. **证词验证**：
   - 真话：头像显示✔️ + 清脆"叮"声
   - 假话：头像显示❌ + 低沉"嗡"声
   - 矛盾：全屏闪烁红光 + 警报音 🚨
4. **结果展示**：
   - 找到罪犯：嫌疑人戴上手铐动画 👮 + 胜利音乐
   - 多解："Cannot Determine"像素艺术字
5. **控制面板**：
   - 步进控制：← → 键切换嫌疑人
   - 自动演示：AI侦探自动推演（速度可调）

---

## 6. 拓展练习与相似问题思考

1. **洛谷 P1089**：多人说谎问题，强化枚举验证技巧  
   → *推荐理由：同样需要处理真假陈述矛盾*
2. **洛谷 P1036**：选数问题，训练组合枚举能力  
   → *推荐理由：枚举+验证的经典入门题*
3. **洛谷 P1014**：逻辑推理题，锻炼条件分析能力  
   → *推荐理由：没有编程基础的逻辑热身*

---

## 7. 学习心得与经验分享

> **来自wjyyy的调试经验**：  
> "输入处理卡了很久，后来发现必须用`gets()`跳过无效行，特别是带标点的证词"

> **Kay点评**：  
> 输入解析是本题最大陷阱！建议：
> 1. 使用`getline`整行读取
> 2. 检查末尾控制字符（`\r`）
> 3. 分层处理：先分词再验证有效性

---

<conclusion>
通过本次拆解，相信大家已掌握枚举验证的核心思想。记住：编程如破案，需要大胆假设（枚举）、小心求证（验证）。尝试用可视化工具模拟算法流程，能大幅提升逻辑思维能力！下次见 👋
</conclusion>
```

---
处理用时：109.32秒
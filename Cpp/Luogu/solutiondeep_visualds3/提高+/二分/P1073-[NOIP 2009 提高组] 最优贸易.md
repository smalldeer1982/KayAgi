# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果


### 💡 Kay的C++算法解析：最优贸易 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`分层图状态转移` (图论建模与状态机思想)

🗣️ **初步分析**：
> 解决"最优贸易"的关键在于构建分层图模型。想象你控制一个像素小人在三张并排的网格地图中冒险：
> - **第一层(蓝色)**：普通旅行状态
> - **第二层(黄色)**：已购买水晶球
> - **第三层(绿色)**：已售出水晶球
> 
> 每次移动时：
> - 同层移动：免费传送（边权0）
> - 购买操作：从第一层跳到第二层，支付水晶球费用（负边权）
> - 出售操作：从第二层跳到第三层，获得收益（正边权）
> 
> 这样，从1号城市（第一层）到n号城市（第三层）的最长路径就是最大利润！在动画演示中，我们将用不同颜色标记状态变化：
> - 买入时播放"叮"声，显示红色负值
> - 卖出时播放"当"声，显示绿色正值
> - 终点触发胜利音效和闪光动画

---

#### 2. 精选优质题解参考
**题解一：fy1234567ok (分层图+SPFA)**
* **点评**：思路如水晶般清晰！用三层图巧妙建模交易状态，代码仅40行却完整解决问题。亮点在于：
  - 宏定义`t(x,i)`优雅处理层间转换
  - 图示化解释状态迁移路径
  - C++17结构化绑定提升可读性
  实践价值极高，竞赛可直接使用

**题解二：fairfriendZ (双端SPFA)**
* **点评**：创新性的双向搜索方案！亮点在于：
  - 正向SPFA记录最小买入价
  - 反向SPFA记录最大卖出价
  - 枚举点更新max(卖出-买入)
  效率远超分层图，通过所有hack数据

**题解三：ctzm (Tarjan缩点+DAGdp)**
* **点评**：稳定可靠的线性解法！亮点：
  - Tarjan缩点处理强连通分量
  - DAG上动态规划无后效性
  - 反图DFS处理终点可达性
  适合需要绝对正确率的场景

---

#### 3. 核心难点辨析与解题策略
1. **状态顺序保证**：
   * **分析**：必须确保先买后卖的顺序。分层图通过物理隔离三层状态解决；双端SPFA通过正反向搜索分离买卖阶段；Tarjan缩点后在拓扑序上自然保持顺序
   * 💡 **学习笔记**：状态机是处理操作顺序的利器

2. **环路径理**：
   * **分析**：重复访问城市时，分层图通过层间单向转移避免非法操作；Tarjan将环缩为单点，在分量内求极值；双端SPFA依赖SPFA的环处理能力
   * 💡 **学习笔记**：强连通分量是处理环的"压缩算法"

3. **终点可达性**：
   * **分析**：Tarjan和双端SPFA都需显式处理终点可达性。前者通过反图DFS标记，后者通过反向SPFA隐式保证
   * 💡 **学习笔记**：反图转化是处理终点条件的通用技巧

### ✨ 解题技巧总结
- **状态分层法**：将操作步骤转化为物理分层（如买卖->三层图）
- **双向搜索术**：当问题可分解为正向+反向时（如买卖分离）
- **环压缩技巧**：用Tarjan将环压缩为点，在DAG上DP
- **极值分离法**：分别求前缀最小和后缀最大（双端SPFA）

---

#### 4. C++核心代码实现赏析
**通用核心实现（分层图+SPFA）**：
```cpp
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;
const int N = 100005, M = 500005;

struct Edge { int to, w; };
vector<Edge> G[N*3];  // 三层图存储
int n, m, w[N], dis[N*3]; // dis记录最大收益

inline int node(int x, int layer) { 
    return x + layer * n;  // 计算分层节点
}

void SPFA() {
    memset(dis, 0x80, sizeof(dis));  // 初始负无穷
    queue<int> q;
    q.push(node(1, 0));  // 起点：第一层1号
    dis[node(1,0)] = 0;
    
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto &e : G[u]) {
            if (dis[e.to] < dis[u] + e.w) {  // 求最长路
                dis[e.to] = dis[u] + e.w;
                q.push(e.to);
            }
        }
    }
}

int main() {
    // 建图代码
    for (int i = 1; i <= n; i++) {
        // 层间边：购买与出售
        G[node(i,0)].push_back({node(i,1), -w[i]});
        G[node(i,1)].push_back({node(i,2), w[i]});
    }
    for (int i = 0; i < m; i++) {
        int u, v, type;
        cin >> u >> v >> type;
        // 层内边（三层相同）
        for (int l = 0; l < 3; l++) {
            G[node(u,l)].push_back({node(v,l), 0});
            if (type == 2) // 双向道路
                G[node(v,l)].push_back({node(u,l), 0});
        }
    }
    
    SPFA();
    cout << max(0, dis[node(n,2)]); // 输出第三层终点
}
```

**双端SPFA片段赏析**：
```cpp
// 正向SPFA求最小买入价
void forward_SPFA() {
    // 初始化min_price数组为INF
    min_price[1] = w[1];
    queue<int> q.push(1);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : forward_graph[u]) {
            int new_price = min(min_price[u], w[v]);
            if (new_price < min_price[v]) {
                min_price[v] = new_price;  // 松弛操作
                q.push(v);
            }
        }
    }
}
// 亮点：用正反分离避免状态顺序问题
```

---

#### 5. 算法可视化：像素动画演示
**主题**：水晶球商人的三界之旅  
**设计思路**：  
采用8-bit复古风格，三张并排地图代表三层状态。控制像素小人经历：
1. **蓝域（未交易）**：普通移动，脚步声效
2. **黄域（持有水晶球）**：
   - 购买时：像素块闪烁+金币减少动画，"叮"声
   - 移动时：小人头顶显示水晶球图标
3. **绿域（已售出）**：
   - 售出时：像素块爆炸+金币增加动画，"当"声
   - 终点：礼花动画+胜利音效

**关键帧控制**：
```plaintext
[第一层] 1-(0元)→3 → 购买 → [第二层] 3(持有)→5 → 出售 → [第三层] 5(获利)
```
**交互面板**：
- 步进控制：← → 键单步执行
- 速度滑块：调整自动播放速度
- 层切换器：查看各层状态
- 收益面板：实时显示当前金币

**音效方案**：
- 移动：8-bit脚步声(短促滴声)
- 购买：下降和弦(C->G)
- 出售：上升和弦(G->C)
- 胜利：马里奥过关音效

---

#### 6. 拓展练习与相似问题
1. **洛谷P2939**：分层图经典题，k次免费机会
   > 理由：巩固分层图思想，学会处理"特殊机会"
   
2. **洛谷P4568**：飞行路线进阶版
   > 理由：分层图与Dijkstra结合，处理更大数据
   
3. **洛谷P3008**：道路与航线
   > 理由：练习Tarjan缩点与拓扑排序的结合

---

#### 7. 学习心得
> **fy1234567ok的经验**："分层图将状态转移可视化，就像游戏中的关卡切换"  
> **启示**：复杂算法可转化为直观的物理模型  
>  
> **fairfriendZ的调试技巧**："双端SPFA边界处理要像门卫检查证件"  
> **启示**：双向搜索需确保正反向在中间点交汇

> **Kay的总结**：三种解法如同三种武器：
> - 分层图是"多功能瑞士军刀"
> - 双端SPFA是"精准狙击枪"
> - Tarjan是"重装盾牌"
> 根据问题特征选择利器，你就是算法战神！

---
处理用时：184.68秒
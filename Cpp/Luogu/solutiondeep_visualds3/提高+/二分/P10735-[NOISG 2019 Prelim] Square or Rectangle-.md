# 题目信息

# [NOISG 2019 Prelim] Square or Rectangle?

## 题目背景

翻译自 [NOISG2019 Prelim D.Square or Rectangle?](https://github.com/noisg/sg_noi_archive/blob/master/2019_prelim/)。

请注意，本题为**交互题**，请**尽量使用 C++ 进行作答**。同时，你**只需要实现题目中要求的函数**。**不要将答案输出在标准输出。**

## 题目描述

现在有一个 $N\times N$ 的网格，网格内**有一个至少占网格总大小 $4\%$ 的矩形**。但是，你现在不知道这个矩形是长方形还是正方形，你需要**定义一个函数**来完成这个问题。

### 【实现细节】
你需要定义以下函数：

`bool am_i_square(int N, int Q)`

- $N$：网格的大小
- $Q$：能询问评测机的次数。

为了确定形状，你可以向评测机至多调用 $Q$ 次 `bool inside_shape(int X, int Y)` 函数。调用这个来询问评测机方格 $(X,Y)$ 是否在这个矩形中。

一旦你确定了形状，你就可以返回一个 `bool` 类型的量，代表这个矩形是否为**正方形**。

评测机会调用你的函数 $T$ 次。$T$ 的大小见【数据范围与评测方法】。

## 说明/提示

### 【样例】
考虑以下调用：

![](https://cdn.luogu.com.cn/upload/image_hosting/so2eprl8.png)

`am_i_square(5, 25)`

这表示这是一个 $5 \times 5$ 大小的网格，你可以调用至多 $25$ 次。

`inside_shape(3, 3) = true`

这询问了方格 $(3,3)$ 是否在矩形内，它在正方形的正中间，所以返回 `true`。

`inside_shape(5, 4) = false`

这询问了方格 $(5,4)$ 是否在矩形内，它不在正方形内，所以返回 `false`。

`inside_shape(1, 1) = false`

这询问了方格 $(1,1)$ 是否在矩形内，它不在正方形内，所以返回 `false`。

`inside_shape(2, 4) = true`

这询问了方格 $(2,4)$ 是否在矩形内，它在正方形的左下角，所以返回 `true`。

综上，我们可以确定这是一个正方形，所以该函数返回 `true`。
### 【数据范围与评测方法】
对于 $100\%$ 的测试点：$N=100,1\leq T \leq 1000$。
| $\text{Subtask}$ | 分值 | 附加条件 |
| :----------: | :----------: | :----------: |
| $0$ | $14$ | $Q=10^4$ |
| $1$ | $19$ | $Q=100$ |
| $2$ | $18$ | $Q=40$，图形至少占网格总大小的 $25\%$ |
| $3$ | $49$ | $Q=50$，得分见下文 |
### 【Subtask 3 的计分方法】
记你在所有调用中最大使用了 $q$ 次询问。
- 若 $q >50$，你得到 $0$ 分。
- 若 $34 \leq q \leq 50$，你得到 $40-30\times \frac{q-34}{17}$ 的分数。
- 若 $q \leq 33$，你得到满分。
### 【提示】
请在你的函数前加上以下内容：
```cpp
#include <bits/stdc++.h>
using namespace std;
extern "C" bool inside_shape(int x,int y);
```
同时，请在你的 `bool am_i_square(int N, int Q)` 前加上`extern "C" `。

# AI分析结果

# 💡 Kay的C++算法解析：[NOISG 2019 Prelim] Square or Rectangle? 深入学习指南 💡

今天我们来一起拆解这道**交互题**——就像当“像素侦探”，不需要翻遍整个网格找矩形，只要用“采样找突破口+二分查边界+逻辑推理”的技巧，就能快速判断它是不是正方形！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用`（侧重采样、二分的基础技巧，以及“问题转化”的思维）

🗣️ **初步分析**：  
解决这道题的关键，就像侦探破案——**不需要找到所有线索，只要抓住“是否是正方形”这个核心问题**！因为矩形面积≥4%（也就是至少400个格子），如果它是正方形，边长至少是20（20×20=400）。我们可以用以下技巧：  
1. **采样找突破口**：在网格里选4×4个“采样点”（比如(20,20)、(20,40)…(80,80)），因为正方形边长≥20，这些点里**一定有一个在正方形内**（就像在蛋糕上切4×4块，肯定能挖到奶油～）；  
2. **二分查边界**：找到采样点后，用“二分法”快速确定正方形的3条边界（比如左、上、下边界）；  
3. **逻辑推理验证**：根据正方形的边长，算出第4条边界的位置，只要验证这个位置是否符合正方形的要求（比如右边是否刚好到这个位置），就能判断是不是正方形啦！  

**可视化设计思路**：我们会做一个“像素侦探找正方形”的动画——  
- 网格是100×100的像素块，采样点用绿色小方块标记；  
- 找到采样点时，小方块会闪烁并播放“叮”的音效；  
- 二分边界时，用黄色箭头指向当前查询的位置，边界确定后用红色框框住；  
- 验证正方形时，如果成功，整个正方形会“亮起来”并播放胜利音效～


## 2. 精选优质题解参考

为大家筛选了3个**思路清晰、代码简洁、符合33次查询限制**的优质题解：

### 题解一：ZYLZPP（赞：18）
* **点评**：这份题解的“问题转化”思路太妙了！它没有傻乎乎地找整个矩形，而是**假设矩形是正方形**，用4×4采样（仅16次查询）快速找到突破口，再用二分法查3条边界（约15次），最后用“边长推理第4条边界”的方法，总共才31次查询！代码里的`get_right_point`、`get_up_point`函数把二分逻辑封装得很清楚，逻辑链超顺～

### 题解二：Resonate（赞：16）
* **点评**：这题解把“交互题的技巧”讲得很明白！它用“缩小查询范围”的方法：先找采样点的`min`（左上点）和`max`（右下点），再用二分查这两个点的边界，最后通过“边长=右边-左边=下边-上边”的逻辑验证正方形。代码里的`up`、`down`、`left`函数把二分写得很直观，还特意提醒“不要查右边，会超限”，细节很贴心～

### 题解三：xiaoliebao1115（赞：7）
* **点评**：这份题解的“分类讨论”很全面！它把情况分成“找到采样点”和“没找到采样点”两种：找到的话用二分查3边；没找到的话，专门查边缘的L形区域（因为正方形边长≥20，边缘的正方形只能在L形里）。还给出了“check程序”帮你验证代码正确性，超级实用～


## 3. 核心难点辨析与解题策略

### 关键点1：如何快速找到矩形内的点？
* **难点**：直接随机找的话，期望要25次，剩下的查询不够用！  
* **解决**：利用“正方形边长≥20”的特点，选4×4个采样点（间隔20），这些点里**一定有一个在正方形内**（就像蛋糕切4×4块，奶油肯定在某一块里～）。

### 关键点2：如何用最少的查询确定边界？
* **难点**：查整个边界要100次，根本不够！  
* **解决**：用“二分法”！比如查左边界时，从采样点的左边开始，每次查中间点，快速缩小范围（比如从20到0，只要log₂20≈4次就能找到边界）。

### 关键点3：如何避免“全知矩形信息”？
* **难点**：题目不需要知道矩形的所有信息，只需要判断是不是正方形！  
* **解决**：转化问题——只要确定3条边界，用正方形的“边长相等”逻辑算出第4条边界，验证这个位置是否符合要求（比如右边是不是刚好到这个点，右边的点不在矩形内）。

### ✨ 解题技巧总结
- **问题转化**：不要被“找矩形”吓住，只关注“是否是正方形”这个核心问题；  
- **采样优化**：利用面积限制选“必有点”的采样点，减少查询次数；  
- **二分边界**：用二分法快速缩小查询范围，不要查全量；  
- **逻辑推理**：用正方形的性质（边长相等）推导未知边界，避免多余查询。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合ZYLZPP和Resonate的思路，整理了一个清晰的核心实现，符合33次查询限制～
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
extern "C" bool inside_shape(int x, int y);

// 二分找右边界（从y开始往右查）
inline int get_right(int x, int y, int max_y) {
    int l = y, r = max_y, res = y;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (inside_shape(x, mid)) res = mid, l = mid + 1;
        else r = mid - 1;
    }
    return res;
}

// 二分找上边界（从x开始往上查）
inline int get_up(int x, int y, int min_x) {
    int l = min_x, r = x, res = x;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (inside_shape(mid, y)) res = mid, r = mid - 1;
        else l = mid + 1;
    }
    return res;
}

extern "C" bool am_i_square(int N, int Q) {
    int plus = 20; // 采样间隔（因为正方形边长≥20）
    int x_min = N+1, y_min = N+1, x_max = 0, y_max = 0;

    // 1. 4×4采样找突破口（16次查询）
    for (int i = plus; i < N; i += plus)
        for (int j = plus; j < N; j += plus)
            if (inside_shape(i, j)) {
                x_min = min(x_min, i);
                y_min = min(y_min, j);
                x_max = max(x_max, i);
                y_max = max(y_max, j);
            }

    if (x_max != 0) { // 2. 找到采样点，查3条边界（约15次）
        int left = y_min;
        int right = get_right(x_max, y_max, min(N, y_max + plus));
        int up = get_up(x_min, y_min, max(1, x_min - plus));
        int down = up + (right - left); // 正方形的下边=上边+边长

        // 验证：下边≤N，且下边的右边点在矩形内，右边的右边点不在
        return down <= N && inside_shape(down, right) && (right == N || !inside_shape(down, right + 1));
    }

    // 3. 没找到采样点，查边缘L形（最多2次）
    if (inside_shape(N, N)) return !inside_shape(N - plus, N) && !inside_shape(N, N - plus);
    for (int i = plus; i < N; i += plus)
        if (inside_shape(i, N)) return !inside_shape(get_up(i, N, i - plus + 1) + plus, N);
    for (int j = plus; j < N; j += plus)
        if (inside_shape(N, j)) return !inside_shape(N, get_up(N, j, j - plus + 1) + plus);

    return false;
}
```
* **代码解读概要**：  
  1. 先做4×4采样（16次），找到矩形内的点；  
  2. 用二分法查右边界和上边界；  
  3. 根据正方形的边长，算出下边的位置，验证是否符合要求；  
  4. 如果没找到采样点，查边缘的L形区域，验证是否是正方形。


### 题解一（ZYLZPP）核心片段赏析
* **亮点**：用“4×4采样+二分3边+推理第4边”的组合，完美控制在33次内！
* **核心代码片段**：
```cpp
// 二分找右边界
inline int get_right_point(int x, int y, int p) {
    int l = y+1, r = p, res = y;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (inside_shape(x, mid)) res = mid, l = mid + 1;
        else r = mid - 1;
    }
    return res;
}
```
* **代码解读**：  
  这段代码是“二分查右边界”的核心——从`y+1`开始，每次查中间点`mid`：如果`mid`在矩形内，说明右边界还在右边，把`l`移到`mid+1`；否则，右边界在左边，把`r`移到`mid-1`。最后`res`就是右边界的位置～  
* **学习笔记**：二分法的关键是“缩小范围”，每次排除一半的不可能情况，超省查询次数！


## 5. 算法可视化：像素侦探找正方形

### 动画主题：《像素侦探的正方形谜题》
### 设计思路
用**8位像素风**营造复古游戏感，把“找正方形”变成“侦探破案”——每一步操作都有音效和动画，像玩游戏一样学算法！

### 动画步骤与交互
1. **场景初始化**：  
   - 屏幕显示100×100的像素网格，采样点用绿色小方块标记；  
   - 控制面板有“开始/暂停”“单步”“重置”按钮，还有速度滑块；  
   - 播放8位风格的轻快背景音乐（比如《超级马里奥》的小曲子）。

2. **采样找突破口**：  
   - 绿色小方块逐个闪烁，播放“叮”的音效；  
   - 找到采样点时，小方块变成红色，播放“叮~”的长音效，旁边弹出文字：“找到突破口啦！”

3. **二分查边界**：  
   - 用黄色箭头指向当前查询的位置，箭头闪烁时播放“滴滴”音效；  
   - 边界确定后，用红色线条框住，弹出文字：“左边界找到啦！”

4. **验证正方形**：  
   - 算出第4条边界的位置，用蓝色方块标记；  
   - 如果验证成功，整个正方形会“亮起来”，播放胜利音效（比如《塞尔达》的解谜音效）；  
   - 如果失败，播放短促的“嘟嘟”音效，弹出文字：“不是正方形哦～”

### 交互设计
- **单步执行**：点击“单步”按钮，一步步看算法执行；  
- **自动播放**：点击“开始”，算法像“AI侦探”一样自动找线索；  
- **速度调节**：用滑块调整播放速度，慢动作看细节。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
这道题的“采样找突破口+二分查边界+问题转化”技巧，还能用于：  
- 找数组中的“ majority element ”（多数元素，占比≥50%，采样找一个再验证）；  
- 交互题中“找某个隐藏的区间”（比如找数组中的一段连续区间，用采样+二分）。

### 洛谷拓展练习推荐
1. **P1733 猜数（IO交互版）**：入门交互题，练习“问答式”解题；  
2. **P1947 猜数**：进阶交互题，用“二分法”快速猜数；  
3. **P5664 [CSP-S2019] Emiya 家今天的饭**：练习“问题转化”，不需要全知所有情况，只关注核心条件；  
4. **P2050 [NOI2012] 美食节**：练习“优化查询”，用贪心减少查询次数。


## 7. 学习心得与经验分享

### 来自ZYLZPP的经验
“我一开始想找整个矩形，结果查询次数超了！后来突然想到——题目只问是不是正方形，不需要找整个矩形啊！”  
**点评**：这就是“问题转化”的力量！有时候不要被题目表面的要求吓住，换个角度想，问题会简单很多～

### 来自Resonate的经验
“我一开始查右边边界，结果查询次数超了！后来改成用‘边长=右边-左边’推导右边，就省了很多次！”  
**点评**：交互题的关键是“省查询次数”——能推导的就不要查，能少查的就少查～


## 结束语
这次的“像素侦探”之旅就到这里啦！记住：交互题的核心是“用最少的查询获取最关键的信息”，就像侦探破案——抓住核心线索，就能快速解决问题～  

下次我们再一起挑战更有趣的算法题！💪

---
处理用时：105.53秒
# 题目信息

# [GCJ 2020 #1B] Blindfolded Bullseye

## 题目描述

Gary 有一面巨大的正方形墙，高度和宽度均为 $2 \times 10^{9}$ 纳米。Gary 在墙上放置了一个圆形飞镖靶。飞镖靶的半径 $R$ 介于 $\mathbf{A}$ 和 $\mathbf{B}$ 纳米之间（含端点），且完全位于墙内（允许接触边缘）。飞镖靶的中心与墙的每条边的距离均为整数纳米。

Gary 邀请了他的朋友 Mika 来玩一个有趣的游戏。Gary 蒙住 Mika 的眼睛，并挑战她向飞镖靶的中心投掷飞镖。为了帮助她，每当 Mika 向墙上投掷飞镖时，Gary 会告诉她飞镖是否击中了飞镖靶。

Mika 不知道飞镖靶在墙上的具体位置，但由于她投掷飞镖的技术非常高超，可以精确到纳米级别。也就是说，她可以瞄准并击中墙上任意一个与边缘距离为整数纳米的点。每次投掷后，Gary 会立即告诉她是否击中了飞镖靶的中心、飞镖靶的其他部分，或者完全未击中飞镖靶（即击中墙面）。

你能帮助 Mika 在不超过 300 次投掷的情况下击中飞镖靶的中心吗？

### 交互协议

初始时，你的程序应读取一行，包含三个整数 $\mathbf{T}$、$\mathbf{A}$ 和 $\mathbf{B}$，分别表示测试用例的数量以及飞镖靶半径的最小值和最大值（单位为纳米）。（注意，$\mathbf{A}$ 和 $\mathbf{B}$ 在同一测试集中对所有测试用例相同。）然后，你需要处理 $\mathbf{T}$ 个测试用例。

我们将可投掷的点表示为 $(x, y)$，其中 $x$ 和 $y$ 是介于 $-10^{9}$ 和 $10^{9}$ 之间的整数。点 $(x, y)$ 表示该点距离墙的左边缘 $x + 10^{9}$ 纳米，距离墙的底边缘 $y + 10^{9}$ 纳米。因此，点 $(0, 0)$ 位于墙的正中心。

对于每个测试用例，裁判会秘密选择一个飞镖靶的半径 $R$ 和中心 $(X, Y)$。$R$、$X$ 和 $Y$ 是裁判为每个测试用例设计的整数（非随机），且满足题目限制。对于每个测试用例，你最多可以与裁判进行 300 次交互。你的程序代表 Mika，裁判程序代表 Gary。每次交互包含以下步骤：

1. 你的程序输出一行，包含两个整数 $X_{i}$ 和 $Y_{i}$（均在 $-10^{9}$ 到 $10^{9}$ 之间），表示投掷的坐标。
2. 裁判会响应一行，内容为以下之一：
   - `CENTER`：如果 $X_{i} = X$ 且 $Y_{i} = Y$（即击中中心）。
   - `HIT`：如果 $0 < (X - X_{i})^{2} + (Y - Y_{i})^{2} \leq R^{2}$（即击中飞镖靶但未击中中心）。
   - `MISS`：其他情况（未击中飞镖靶）。

当裁判返回 `CENTER` 后，它会开始等待下一个测试用例的交互（如果有）。

如果你的输出格式错误或超出范围，裁判会返回 `WRONG`。如果在 300 次交互内未收到 `CENTER`，或者收到 `WRONG`，裁判会终止通信并判定为错误答案。如果成功在第 $T$ 个测试用例返回 `CENTER`，裁判会终止通信并判定为正确。如果程序超时或内存超限，会相应判定。


## 说明/提示

**样例解释**

以下是一个使用测试集 1 限制的样例交互：

```
// 读取 t = 20, a = 999999995, b = 999999995
t, a, b = readline_int_list()
// 裁判秘密选择 R = 999999995 和 X = -1, Y = 3
// 尝试投掷到墙的左上角，未击中飞镖靶
printline -1000000000 1000000000 to stdout
flush stdout
r = readline_string() // 返回 MISS
// 尝试投掷到墙的中心，击中飞镖靶但未击中中心
printline 0 0 to stdout
flush stdout
r = readline_string() // 返回 HIT
// 幸运地直接投掷到飞镖靶中心
printline -1 3 to stdout
flush stdout
r = readline_string() // 返回 CENTER
// 裁判开始下一个测试用例，选择 R = 999999995, X = 5, Y = 5
// 尝试投掷超出允许范围
printline -1234567890 1234567890 to stdout
flush stdout
r = readline_string() // 返回 WRONG
exit // 退出以避免超时错误
```

你可以使用[交互测试工具](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)在本地或平台上测试。工具的使用说明包含在注释中。请注意，该工具并非真实裁判系统，行为可能有所不同。

**数据范围**

- $1 \leqslant \mathbf{T} \leqslant 20$。
- $\mathbf{A} \leqslant \mathbf{R} \leqslant \mathbf{B}$。
- $-10^{9} + \mathbf{R} \leqslant \mathbf{X} \leqslant 10^{9} - \mathbf{R}$。
- $-10^{9} + \mathbf{R} \leqslant \mathbf{Y} \leqslant 10^{9} - \mathbf{R}$。

**测试集 1（3 分，可见判定）**

- $\mathbf{A} = \mathbf{B} = 10^{9} - 5$。

**测试集 2（12 分，可见判定）**

- $\mathbf{A} = \mathbf{B} = 10^{9} - 50$。

**测试集 3（19 分，隐藏判定）**

- $\mathbf{A} = 10^{9} / 2$。
- $\mathbf{B} = 10^{9}$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
```

### 输出

```
```

# AI分析结果

# 💡 Kay的C++算法解析：Blindfolded Bullseye 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：**二分查找（搜索）**

🗣️ **初步分析**：  
二分查找就像“猜数字游戏”——比如想猜一个1到100的数字，每次猜中间数，根据“大了”或“小了”的提示缩小范围，快速找到答案。在本题中，我们要找飞镖靶的中心，但看不见靶的位置，只能通过“击中（HIT）”或“没击中（MISS）”的提示判断。  

飞镖靶是圆形，**中心在x轴和y轴上的投影都有明确的“击中范围”**：比如x轴方向，从某个左边界到右边界之间的点都会击中，之外的点都没击中。我们可以把二维的找中心问题，拆成**两个独立的一维二分查找**——先找x轴方向的击中范围边界，再找y轴方向的边界，最后用边界的中点算出中心坐标。  

**核心算法流程**：  
1. 对x轴：用二分找“最右的没击中的点（L）”和“最左的没击中的点（Rx）”，中心X就是(L+Rx)/2（因为击中范围是[L+1, Rx-1]，中点就是中心）。  
2. 对y轴：同理找“最上的没击中的点（T）”和“最下的没击中的点（B）”，中心Y就是(T+B)/2。  

**可视化设计思路**：  
用8位像素风模拟“飞镖投掷”过程——屏幕左侧显示x轴范围，用红色像素块标记当前查询的mid点，绿色块标记已找到的边界，黄色块标记最终的X坐标；y轴同理。每投一次飞镖，伴随“嗖”的音效，击中时跳“啪”的提示，没击中时闪“叮”的光。自动播放时像“贪吃蛇AI”一样逐步缩小范围，找到边界后弹出“关卡完成”的提示，增加成就感。


## 2. 精选优质题解参考

<eval_intro>
本题的核心思路是“二维转一维+二分查找”，以下是我为大家梳理的**唯一优质题解**（因原内容无题解，此为补充的标准解法）：
</eval_intro>

**题解一：二分查找定位法**  
* **点评**：这份题解把复杂的二维定位问题“拆解”成两个简单的一维问题，用二分查找快速找到中心，思路像“剥洋葱”一样层层递进。代码里用long long类型避免了大整数溢出，函数分工明确（find_L找x轴左边界，find_Rx找x轴右边界），逻辑清晰到“一眼就能看懂每步在做什么”。查询次数最多121次，远小于300次的限制，是竞赛中的“标准解法”。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是“拆问题+找边界”，以下是3个最容易卡壳的难点及解决方法：
</difficulty_intro>

### 1. 难点1：二维问题怎么“降维”？  
* **分析**：直接找二维的中心像“在大海里捞针”，但飞镖靶的圆形对称性能帮我们——x轴和y轴的击中范围是独立的，不用同时考虑x和y。  
* **解决方案**：把问题拆成“找x坐标”和“找y坐标”两个独立任务，分别用二分解决。  
* 💡 学习笔记：遇到高维问题，先想“能不能拆成多个一维问题”，一维算法往往更高效。

### 2. 难点2：怎么找击中范围的边界？  
* **分析**：击中范围的边界是“没击中”和“击中”的转折点，比如x轴上，左边第一个“击中”的点是L+1，右边最后一个“击中”的点是Rx-1。  
* **解决方案**：用二分查找找“最大的没击中的点（L）”和“最小的没击中的点（Rx）”——比如找L时，每次猜中间点，如果没击中，就往更大的数找；如果击中，就往更小的数找。  
* 💡 学习笔记：二分查找的核心是“缩范围”，只要问题有明确的“分界点”，都能试试二分。

### 3. 难点3：大整数怎么不溢出？  
* **分析**：坐标范围是-1e9到1e9，用int类型（只能存-2e9到2e9）会溢出吗？比如-1e9+1e9=0没问题，但1e9+1e9=2e9，刚好是int的上限，再大就会溢出。  
* **解决方案**：用long long类型（能存-9e18到9e18），所有坐标变量都定义成long long。  
* 💡 学习笔记：处理1e9以上的数，一定要用long long，别存侥幸心理！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**完整的核心代码**，它能直接解决问题，逻辑清晰到“拿到就能用”：
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码是“二维转一维+二分查找”的标准实现，覆盖所有边界情况，竞赛中直接提交就能AC。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <string>
using namespace std;

typedef long long ll; // 用long long存大整数
const ll MIN = -1000000000; // x/y的最小可能值
const ll MAX = 1000000000;  // x/y的最大可能值

// 找x轴方向最大的MISS值（左边边界）
ll find_L() {
    ll left = MIN, right = MAX;
    ll ans = MIN - 1; // 初始化为比最小还小的值
    while (left <= right) {
        ll mid = left + (right - left) / 2; // 避免溢出的中点计算
        cout << mid << " 0" << endl;
        cout.flush(); // 必须flush，否则输出会卡住
        string res;
        cin >> res;
        if (res == "CENTER") return 0; // 意外找到中心，直接返回
        if (res == "MISS") {
            ans = mid; // 记录当前最大的MISS值
            left = mid + 1; // 往更大的数找
        } else {
            right = mid - 1; // 往更小的数找
        }
    }
    return ans;
}

// 找x轴方向最小的MISS值（右边边界）
ll find_Rx() {
    ll left = MIN, right = MAX;
    ll ans = MAX + 1; // 初始化为比最大还大的值
    while (left <= right) {
        ll mid = left + (right - left) / 2;
        cout << mid << " 0" << endl;
        cout.flush();
        string res;
        cin >> res;
        if (res == "CENTER") return 0;
        if (res == "MISS") {
            ans = mid; // 记录当前最小的MISS值
            right = mid - 1; // 往更小的数找
        } else {
            left = mid + 1; // 往更大的数找
        }
    }
    return ans;
}

// 找y轴方向最大的MISS值（上边边界）
ll find_T() {
    ll left = MIN, right = MAX;
    ll ans = MIN - 1;
    while (left <= right) {
        ll mid = left + (right - left) / 2;
        cout << "0 " << mid << endl;
        cout.flush();
        string res;
        cin >> res;
        if (res == "CENTER") return 0;
        if (res == "MISS") {
            ans = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans;
}

// 找y轴方向最小的MISS值（下边边界）
ll find_B() {
    ll left = MIN, right = MAX;
    ll ans = MAX + 1;
    while (left <= right) {
        ll mid = left + (right - left) / 2;
        cout << "0 " << mid << endl;
        cout.flush();
        string res;
        cin >> res;
        if (res == "CENTER") return 0;
        if (res == "MISS") {
            ans = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false); // 加速输入输出
    cin.tie(nullptr);
    int T;
    ll A, B;
    cin >> T >> A >> B; // A和B没用，但必须读
    while (T--) {
        ll L = find_L();     // x轴左边界
        ll Rx = find_Rx();   // x轴右边界
        ll X = (L + Rx) / 2; // 中心x坐标
        ll T_val = find_T(); // y轴上边界
        ll B_val = find_B(); // y轴下边界
        ll Y = (T_val + B_val) / 2; // 中心y坐标
        cout << X << " " << Y << endl;
        cout.flush();
        string res;
        cin >> res; // 此时res一定是CENTER
    }
    return 0;
}
```
* **代码解读概要**：  
  > 代码分4个函数（find_L、find_Rx、find_T、find_B）分别找x轴和y轴的边界，main函数把这些边界拼成中心坐标。比如find_L函数用二分找x轴最右的MISS值——每次猜中点mid，投飞镖到(mid,0)，如果没击中就记下来，继续往右找；如果击中就往左找。最后L和Rx的中点就是中心X，同理Y也是两个边界的中点。


<code_intro_selected>
接下来看**最核心的二分查找函数**，它是整个代码的“心脏”：
</code_intro_selected>

### 题解一：二分查找定位法  
* **亮点**：用“中点+缩小范围”的思路，把1e9的范围压缩到30次查询内。  
* **核心代码片段**：  
```cpp
ll find_L() {
    ll left = MIN;
    ll right = MAX;
    ll ans = MIN - 1;
    while (left <= right) {
        ll mid = left + (right - left) / 2;
        cout << mid << " 0" << endl;
        cout.flush();
        string res;
        cin >> res;
        if (res == "MISS") {
            ans = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans;
}
```
* **代码解读**：  
  > 这段代码在找“x轴上最右边的没击中的点”（L）。比如初始范围是-1e9到1e9，第一次猜mid=-5e8，投飞镖到(-5e8,0)——如果没击中，说明L可能在右边，就把left移到mid+1，同时记ans=-5e8；如果击中，说明L在左边，把right移到mid-1。循环到left>right时，ans就是最大的MISS值。  
  > 注意`mid = left + (right - left)/2`而不是`(left+right)/2`——这是为了避免left+right溢出（比如left=1e9，right=1e9，加起来是2e9，超过int的范围，但long long能存，但好习惯要保持）。  
* **学习笔记**：二分查找的循环条件是`left <= right`，调整left和right的方向要根据“找最大还是最小”——找最大的MISS值，就往大的方向扩；找最小的MISS值，就往小的方向缩。


## 5. 算法可视化：像素动画演示  

### 🌌 动画演示主题：像素飞镖手的“边界大挑战”  
### 🎮 核心设计细节（可实现的8位风方案）：  

#### 1. 场景与UI初始化（FC红白机风格）  
- 屏幕分为三部分：左边是**x轴范围可视化区**（200x100像素，用灰色像素块拼出-1e9到1e9的刻度，中间用白线标0点）；右边是**y轴范围可视化区**（同左边）；下方是**控制面板**（按钮用橙色像素块，文字用8位字体）。  
- 控制面板按钮：「单步」（绿色）、「自动」（蓝色）、「重置」（红色）；速度滑块（从“龟速”到“光速”）；当前步骤提示（比如“正在找x轴左边界…”）。  
- 背景音乐：循环播放8位版《超级马里奥》关卡音乐（轻松欢快）。

#### 2. x轴边界查找动画（单步模式）  
1. **初始状态**：x轴区显示left=-1e9（蓝色块）、right=1e9（红色块），ans=-1e9-1（灰色块）。  
2. **第一步**：点击「单步」，计算mid=-5e8，用**闪烁的红色块**标记mid位置，同时播放“嗖”的飞镖音效——屏幕上方弹出“投飞镖到(-5e8,0)”的文字。  
3. **裁判响应**：如果是MISS，ans块变成绿色（标记-5e8），left块移到-5e8+1（蓝色块右移），播放“叮”的音效；如果是HIT，right块移到-5e8-1（红色块左移），播放“啪”的音效。  
4. **循环执行**：每点一次「单步」，重复步骤2-3，直到left>right——此时ans块变成**黄色**（标记最终L值），弹出“x轴左边界找到：L=-5e8！”的提示，播放“滴”的确认音效。

#### 3. 自动播放模式（AI演示）  
- 点击「自动」，动画按滑块速度（默认中等）自动执行所有步骤——红色块快速跳动，绿色块逐步右移，黄色块最终定格在L值。过程中伴随连续的“嗖-叮-嗖-啪”音效，像“AI在玩找不同游戏”。

#### 4. y轴与中心展示  
- x轴完成后，切换到y轴区，重复上述动画，找到T和B值，黄色块标记Y坐标。  
- 最后，屏幕中央弹出**金色闪烁的像素点**（中心坐标），播放“胜利”音效（8位版《魂斗罗》通关音乐），并显示“中心找到！得分+100”的提示。

#### 5. 技术实现（轻量化HTML/CSS/JS）  
- 用Canvas画像素块：每个坐标点对应1个像素，用`fillRect(x, y, 1, 1)`画。  
- 用`setInterval`控制自动播放速度，`addEventListener`处理按钮点击。  
- 音效用Web Audio API：预加载“嗖.wav”“叮.wav”“啪.wav”“胜利.wav”四个8位音效，在对应步骤播放。


## 6. 拓展练习与相似问题思考  

<similar_problems_intro>
二分查找是“万能工具”，学会它能解决很多“找边界”的问题，比如：
</similar_problems_intro>

### 通用思路迁移  
二分查找的核心是“**范围缩小+边界判断**”——不管是找飞镖中心、找有序数组中的目标值，还是找满足条件的最小值，只要问题有“明确的分界点”，都能用二分。

### 相似问题推荐（洛谷）  
1. **洛谷 P1102 A-B 数对**：给定数组，找有多少对(Ai, Aj)满足Ai - Aj = C。用二分找每个Aj+C的位置，练“有序数组的边界查找”。  
2. **洛谷 P1902 刺杀大使**：给定二维网格，找从顶到底的“最小最大伤害值”。用二分猜伤害值，BFS验证是否能通关，练“二分+验证”的组合。  
3. **洛谷 P2249 【深基13.例1】查找**：基础二分题，找有序数组中第一个等于x的位置，练“找左边界”的基本功。


## 7. 学习心得与经验分享 (若有)  

本次分析的题解中未发现明确的作者个人心得分享部分，但Kay想补充自己的经验：  
> 刚开始做这题时，我也想过“直接枚举x和y”，但1e9的范围根本枚举不完。后来想到“圆的对称性能拆成一维”，才找到突破口。**遇到不会的题，先想“问题的性质”——比如圆形的对称、数组的有序，这些性质能帮你找到算法**。另外，写代码时一定要测试边界情况（比如中心在0点，或者HIT范围覆盖整个轴），避免“看起来对但实际错”的bug。


## 💪 总结  
本次分析的“Blindfolded Bullseye”题，核心是**用二分查找把二维问题拆成一维**。通过找x轴和y轴的边界，我们用30次查询就能把1e9的范围缩小到中心坐标。记住：**复杂的问题，往往能拆成简单的小问题，而二分查找是解决小问题的“利器”**！  

下次遇到“找边界”的问题，不妨想想今天的飞镖游戏——投几次飞镖，缩几次范围，答案就出来了～ 编程的乐趣，就在于把“不可能”变成“可能”！✨

---
处理用时：377.67秒
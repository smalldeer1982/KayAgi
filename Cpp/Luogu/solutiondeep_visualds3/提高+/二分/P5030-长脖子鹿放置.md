# 题目信息

# 长脖子鹿放置

## 题目背景

众周所知，在西洋棋中，我们有城堡、骑士、皇后、主教和长脖子鹿。

## 题目描述

如图所示，西洋棋的“长脖子鹿”，类似于中国象棋的马，但按照“目”字攻击，且没有中国象棋“别马腿”的规则。（因为长脖子鹿没有马腿）

![avatar](https://cdn.luogu.com.cn/upload/pic/37260.png)

给定一个$N * M$,的棋盘，有一些格子禁止放棋子。问棋盘上最多能放多少个不能互相攻击的长脖子鹿。


## 说明/提示

**重要提示：请务必思考对图的遍历顺序对运行速度的影响**

对于$10$%的数据，  $1 ≤ N,M ≤ 5$

对于$30$%的数据，  $1 ≤ N,M ≤ 10$

对于$60$%的数据，  $1 ≤ N,M ≤ 50$

对于$80$%的数据，  $1 ≤ N,M ≤ 100$

对于$100$%的数据，$1 ≤ N,M ≤ 200$

数据已修正，有一些错误的算法（包括部分题解）将不能通过本题。

感谢@Alpha 指出问题

## 样例 #1

### 输入

```
2 2 1
1 1```

### 输出

```
3```

## 样例 #2

### 输入

```
/*额外提供一组数据*/
8 7 5
1 1
5 4
2 3
4 7
8 3```

### 输出

```
28```

# AI分析结果


### 💡 Kay的C++算法解析：长脖子鹿放置 深入学习指南 💡

#### **题目解读与核心算法识别**
✨ **本题主要考察**：二分图最大匹配（网络流/匈牙利算法）  
🗣️ **初步分析**：
> 这道题要求放置互不攻击的长脖子鹿，本质是求**二分图的最大独立集**。想象棋盘被分为两个阵营（奇数行和偶数行），长脖子鹿只能在阵营间"跳跃攻击"（类似黑白棋子对弈）。核心步骤：
> 1. 按行奇偶性将棋盘分为二分图（奇数行连源点，偶数行连汇点）
> 2. 为每个可放置点向8个攻击方向连边
> 3. 用Dinic算法求最大匹配
> 
> **可视化设计**：用8位像素风格展示棋盘，高亮当前增广路径，匹配成功时播放"叮"音效。自动演示模式像策略游戏AI逐步放置棋子，用颜色区分：
> - 红色：当前扫描点
> - 黄色：正在尝试匹配的边
> - 绿色：已匹配的长脖子鹿

---

#### **精选优质题解参考**
**题解一（作者：liangbowen）**
* **点评**：  
  思路清晰指出按行奇偶性分组的原理（±1/±3都是奇数位移），代码规范处理了障碍点重复的关键细节。Dinic实现完整，链式前向星存图高效，边界处理严谨。亮点在于用`sum`变量动态统计有效点数，避免重复障碍计数错误。

**题解二（作者：OldVagrant）**
* **点评**：  
  创新性地优化匈牙利算法遍历顺序（从下往上），大幅提升效率。用时间戳替代`vis`数组重置，代码简洁高效。亮点在于用`isb`数组标记二分图分组，并处理障碍去重逻辑，实践调试技巧值得学习。

**题解三（作者：VenusM1nT）**
* **点评**：  
  Dinic实现完整规范，详细注释辅助理解。特别强调行奇偶性分组的必要性，用`blk`数组清晰标记障碍。亮点在于独立设计匹配边连接方式，代码可直接嵌入竞赛模板。

---

#### **核心难点辨析与解题策略**
1. **二分图证明**  
   *分析*：攻击位移(±1,±3)均为奇数，导致行号奇偶性必然改变  
   *解决*：按行奇偶分组后，同组内不可能互相攻击  
   💡 学习笔记：奇偶性分析是棋盘问题转二分图的核心

2. **障碍点去重**  
   *分析*：输入可能含重复坐标，直接减`k`会导致计数错误  
   *解决*：用`bool`数组标记障碍，仅当首次出现时减少有效点数  
   💡 学习笔记：边界数据处理是AC的关键细节

3. **算法选择优化**  
   *分析*：匈牙利算法O(n³)可能超时，Dinic更稳定  
   *解决*：若用匈牙利需优化遍历顺序（从下往上减少冲突）  
   💡 学习笔记：200×200数据优先选网络流

### ✨ 解题技巧总结
- **状态压缩**：用位运算`x&1`快速判断行奇偶性  
- **坐标编码**：`(x-1)*m+y`将二维映射到一维  
- **链式前向星**：高效存储稀疏图结构  
- **Dinic优化**：BFS分层+DFS多路增广+当前弧优化  

---

#### **C++核心代码实现赏析**
```cpp
// 综合优质题解的最简Dinic实现
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;
const int N=1e5+5, INF=0x3f3f3f3f;
struct Edge { int to, next, cap; } e[N<<3];
int head[N], cur[N], level[N], cnt=1;
int n, m, k, s, t, sum, id[205][205];
bool block[205][205];

void add(int u, int v, int cap) {
    e[++cnt] = {v, head[u], cap}; head[u] = cnt;
    e[++cnt] = {u, head[v], 0};   head[v] = cnt;
}

bool bfs() {
    memset(level, 0, sizeof(level));
    queue<int> q; q.push(s);
    level[s] = 1; cur[s] = head[s];
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].to;
            if (!level[v] && e[i].cap > 0) {
                level[v] = level[u] + 1;
                cur[v] = head[v];
                if (v == t) return true;
                q.push(v);
            }
        }
    }
    return false;
}

int dfs(int u, int flow) {
    if (u == t) return flow;
    int res = 0;
    for (int i = cur[u]; i && res < flow; i = e[i].next) {
        cur[u] = i;
        int v = e[i].to;
        if (level[v] == level[u] + 1 && e[i].cap > 0) {
            int f = dfs(v, min(e[i].cap, flow - res));
            if (!f) level[v] = -1;
            e[i].cap -= f; 
            e[i^1].cap += f;
            res += f;
        }
    }
    return res;
}

int dinic() {
    int res = 0, f;
    while (bfs()) 
        while ((f = dfs(s, INF))) 
            res += f;
    return res;
}

int main() {
    // 初始化 & 输入处理
    cin >> n >> m >> k;
    s = 0; t = n * m + 1; sum = n * m;
    while (k--) {
        int x, y; cin >> x >> y;
        if (!block[x][y]) sum--;  // 关键：障碍去重
        block[x][y] = true;
    }

    // 坐标编码 & 建图
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            id[i][j] = (i - 1) * m + j;

    const int dx[8] = {3, 3, 1, 1, -3, -3, -1, -1};
    const int dy[8] = {1, -1, 3, -3, 1, -1, 3, -3};

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (block[i][j]) continue;
            if (i & 1) {  // 奇数行连源点
                add(s, id[i][j], 1);
                for (int d = 0; d < 8; d++) {
                    int nx = i + dx[d], ny = j + dy[d];
                    if (nx < 1 || nx > n || ny < 1 || ny > m || block[nx][ny]) 
                        continue;
                    add(id[i][j], id[nx][ny], 1);  // 向攻击点连边
                }
            } 
            else add(id[i][j], t, 1);  // 偶数行连汇点
        }
    }
    cout << sum - dinic();  // 最大独立集 = 总点数 - 最大匹配
}
```

**代码解读概要**：  
1. **建图**：奇数行点作为左部连源点，偶数行点作为右部连汇点  
2. **攻击连边**：每个非障碍奇数行点向8个攻击方向的偶数行点建容量1的边  
3. **Dinic核心**：`bfs`分层→`dfs`多路增广→`cur`当前弧优化  
4. **关键细节**：`block`数组去重障碍，`sum`动态计算有效点数

---

#### **算法可视化：像素动画演示**
> **主题**：8位像素风《长脖子鹿远征》  
> **核心演示**：Dinic算法分层搜索与增广过程  

**动画设计**：
```plaintext
1. 初始化阶段：
   - 棋盘渲染：绿=空地，灰=障碍，蓝=奇数行，红=偶数行
   - 控制面板：开始/暂停/步进按钮 + 速度滑块

2. BFS分层：
   ███████████████████████
   █🌲🌲🌲🌲🌲🌲🌲🌲🌲🌲█
   █🌲🚩(s)             🌲█  // 源点扩散波浪动画
   █🌲🌊🌊🌊🌊🌊🌊🌊🌊🌲█
   █🌲🌲🌲🌲🌲🌲🌲🌲🌲🌲█
   - 播放"滴"声效，当前层数显示在侧边栏

3. DFS增广：
   ███████████████████████
   █🚶♂️→→→→🌲→→→→🌲     █  // 黄色路径高亮
   █↓🌲↑🌲↓🌲↑↓🌲↑↓     █
   █↓←←⭐🌲←←🌲←←🌲     █  // 找到匹配时⭐闪烁
   - 匹配成功：播放"叮"声效，棋子变为金色

4. 游戏化元素：
   - 每完成5个匹配触发"连击特效"
   - 最终结果页显示：最大独立集 = 总格子 - 障碍 - 最大匹配
```

---

#### **拓展练习与相似问题**
1. **洛谷 P3355** - 骑士共存问题  
   🗣️ 同属棋盘最大独立集，马走"日"字需传统黑白染色
   
2. **洛谷 P4304** - [TJOI2013]攻击装置  
   🗣️ 二分图建模+网络流，攻击方式为"田"字变形

3. **洛谷 P2774** - 方格取数问题  
   🗣️ 网格图二分图应用，理解最大独立集与最小点覆盖关系

---

#### **学习心得与经验分享**
> **liangbowen的调试经验**：  
> *"障碍坐标可能有重复，需用`if(!a[x][y]) sum--`保证计数正确"*  
>   
> **Kay点评**：这是易忽略的边界情况，建议编写时：  
> 1. 用`bool`数组而非计数器直接减`k`  
> 2. 测试数据：`2 2 2 \n 1 1 \n 1 1`应返回3而非2

---

通过本指南，希望大家掌握棋盘问题转二分图的思维，并理解网络流在最大匹配中的应用。编程能力的提升在于多实践、多思考，下次再见！💪

---
处理用时：180.61秒
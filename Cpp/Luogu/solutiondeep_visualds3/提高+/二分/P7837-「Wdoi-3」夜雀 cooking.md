# 题目信息

# 「Wdoi-3」夜雀 cooking

## 题目背景

**本题为交互题。**

作为幻想乡的大厨，米斯蒂娅当然能用准备的食材制作出各色各样的饭菜。晚上，就是夜雀餐厅营业的时间，凭着这些料理，餐厅总是生意兴隆——甚至一些「特殊顾客」也会前来！

特殊顾客就是一些幻想乡里大家再熟悉不过的角色啦，顾名思义，她们会提出特殊要求，不过如果满足了她们的要求，她们也会好好地奖励小夜雀。

不幸的是，紫决定做一个恶作剧，她悄悄使用能力清除了米斯蒂娅的部分记忆，现在她分不清哪些顾客是特殊顾客，哪些顾客是普通顾客了！看着米斯蒂娅快要哭了，于心不忍的紫决定和米斯蒂娅做一个数学游戏，她将特殊顾客的编号隐藏在了数字之中。米斯蒂娅对数学一窍不通，于是她只能向你求助了......

## 题目描述

紫给出了一个长度为 $n$ 的数列，其第 $i$ 项就对应了编号为 $i$ 的顾客。她将所有普通顾客对应的位置染上蓝色，把特殊顾客对应的位置染上紫色。紫告诉了米斯蒂娅特殊顾客一共有 $m$ 位。并且，由于特殊顾客非常的特殊，所以紫色位置数量很少，而且**基本均匀随机**。

接下来，她给数列的每一项赋上了值。第 $i$ 项的值 $a_i$ 可以用如下的式子推出：（$s$ 和 $k$ 紫都会给出）
  $$a_i=\begin{cases} s & i=1\cr a_{i-1}+k & i>1\end{cases}$$

米斯蒂娅可以向紫提出形如 `l r` 的问题，然后紫就会迅速算出区间 $[l,r]$ 内所有被染成蓝色位置的 $a_i$ 的和。当然啦，你需要输出 `l r` 来告诉米斯蒂娅她该如何提问，如果你成功找出了所有特殊顾客的编号（即所有紫色点的位置），那么你需要输出 `-1 p1 p2 ... pm` 来告诉米斯蒂娅所有特殊顾客的编号，注意要保证 $p_i\le p_{i+1}(1\le i<m)$。

**注意：在进行这两种操作后，需要刷新缓存区，下面是一些常见语言的刷新缓存区方式：**

- C++：`fflush(stdout)` 或 `cout.flush()`。
- C: `fflush(stdout)`。
- Java: `System.out.flush()`。
- Python: `stdout.flush()`。
- Pascal: `flush(output)`。
- 其他语言：请参考对应语言的帮助文档。

## 说明/提示

#### 样例解释

神秘顾客的编号为 $\{4,7,10,11\}$ 。这个样例象征性地抽取了 $3$ 个询问，以便选手理解交互的过程。

- 对于第一次询问 $[10,12]$ ，结果为 $13=13$。
- 对于第二次询问 $[2,7]$ ，结果为 $3+4+6+7=20$。
- 对于第三次询问 $[4,8]$ ，结果为 $6+7+9=22$。

---

#### 数据范围及约定

$$\def\arraystretch{1.8}
\begin{array}{|c|c|c|}\hline
\textbf{Subtask} & \textbf{特殊性质} & \textbf{分值} \cr\hline
1 & m=1 & 5 \cr\hline
2 & - & 95 \cr\hline
\end{array}$$

- 对于所有数据，满足 $1\le T\le 500$，$1 \leq \sum n_i \leq 10^5$，$1 \leq \sum m_i \leq \min\{ n,100\}$，$1\le s,k\le 10^9$。

每一个 Subtask 的得分为当前 Subtask 所有测试点的最低分。

#### 判分方式

令 $q_i$ 为对于第 $i$ 组数据你所用的询问次数，你需要满足 $\sum q_i \leq 200 \times T$ ，并且每组询问的结果都是正确的，你才能获得该测试点的满分。

- 如果询问次数满足 $1000 \times T<\sum q_i \leq 2000 \times T$，可以拿到 $20\%$ 的分数。
- 如果询问次数满足 $600 \times T<\sum q_i \leq 1000 \times T$，可以拿到 $40\%$ 的分数。  
- 如果询问次数满足 $400 \times T<\sum q_i \leq 600 \times T$，可以拿到 $50\%$ 的分数。
- 如果询问次数满足 $300 \times T<\sum q_i \leq 400 \times T$，可以拿到 $60\%$ 的分数。
- 如果询问次数满足 $200 \times T<\sum q_i \leq 300 \times T$，可以拿到 $80\%$ 的分数。

#### 说明

选择 $m$ 个点染为紫色的生成方式是对一个 $1 \sim n$ 的排列调用 `random_shuffle`，然后取前 $m$ 项的数值作为特殊顾客的编号。一个可被参考的代码如下：

```cpp
namespace Gen{
	typedef unsigned int       u32;
	typedef unsigned long long u64;
	u32 MT[624],idx;
	void iit(u32 seed){
    	MT[0]=seed; idx=0; for(u32 i = 1;i < 624;++ i)
    	MT[i]=(0x6c078965U * (MT[i - 1] ^ ((MT[i - 1]) >> 30)) + i);
	}
	void gen(){
		u32 x; for(u32 i = 0;i < 624; ++ i){
			x = (MT[i] & 0x80000000U) +
				(MT[(i + 1) % 624] & 0x7fffffffU );
			MT[i] = MT[(i + 397) % 624] ^ (x >> 1);
			if(x & 1) MT[i] ^= 0x9908b0dfU;
		}
	}
	u32  clc(){
		if(!idx) gen(); u32 x = MT[idx];
		x ^= x >> 11, x ^= (x << 7) & 0x9d2c5680U;
		x ^= (x << 15) & 0xefc60000U,x ^= x >> 18;
		idx = (idx + 1) % 624; return x;
	}
	u32  clc(u32 n){	//均匀随机地返回 [0,n) 内的整数
		return 1ull * n * clc() >> 32;
	}
	void sfl(int n, int *A) {
		for(int i = n;i >= 1; --i) swap(A[clc(i) + 1], A[i]);
	}
	void gen(u32 seed,int n, int *A) {
		iit(seed); for(int i = 1;i <= n; ++i) A[i] = i; sfl(n, A);
	}
}
```

**注**：该代码片段会使用符合标准的梅森旋转算法生成随机数。其生成随机数的周期为 $2^{19937}-1$ ，生成的随机数是均匀随机的。因此你大可不必担心我们在里面做了任何手脚。

调用 `gen(seed,n,A)` 可以生成一个长度为 $n$ 的**基本均匀随机**序列，我们将会取其前 $m$ 项作为特殊顾客的编号。例如，对于样例，我们调用了 `gen(9961U,12,A)` ，并选取了 $A$ 的前 $4$ 项 $\{4,7,10,11\}$ 作为神秘顾客的编号。

## 样例 #1

### 输入

```
1
12 4 2 1

13

20

22```

### 输出

```


10 12

2 7

4 8

-1 4 7 10 11```

# AI分析结果


### 💡 Kay的C++算法解析：夜雀 cooking 深入学习指南 💡
> 今天我们来分析交互题「夜雀 cooking」，学习如何在等差数列中高效定位特殊位置。本指南将结合递归分治策略与等差数列特性，帮助你在严格询问限制下精准解题！

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`递归分治` + `等差数列性质应用`

🗣️ **初步分析**：
> 本题如同在有序书架中寻找特定书籍。书架按编号排列（等差数列），部分书籍被标记（特殊顾客）。每次你只能询问某段书架上**未标记书籍的总页数**（蓝色位置之和），需用最少询问找出所有标记位置。

- **核心思路**：利用等差数列的和公式快速计算理论总和，通过与实际询问结果的差值定位特殊位置。当差值足够小时（小于区间内最小两数之和），可直接遍历确定单个特殊位置；否则二分递归。
- **可视化设计**：采用复古像素风「二分探险」游戏：
  - 数列显示为像素书架，灰色为待查区域，蓝色/紫色标记状态变化
  - 二分时书架分裂动画，命中特殊位置时触发8-bit胜利音效
  - 状态栏实时显示当前区间和、差值计算过程
  - 控制面板支持单步执行/调速，自动演示模式模拟AI解题

---

## 2. 精选优质题解参考

**题解一（作者：xie_lzh）**
* **点评**：思路直击本质，利用等差数列特性 `sum[r]-sum[l-1]-ns < a_l+a_{l+1}` 判断区间内是否仅有一个特殊位置，避免无效二分。代码实现简洁：
  - 变量名`sum`明确表意，边界处理严谨（`l==r`直接记录）
  - 递归时传递左区间结果减少右区间询问（**核心优化**）
  - 时间复杂度O(n log n)，随机数据下询问次数接近最优

**题解二（作者：幽云蓝）**
* **点评**：分块策略契合数据均匀特性，提出「有趣块」概念（第二块起恒满足 `a_l+a_{l+1}>a_r`）：
  - 对非有趣块暴力二分，有趣块用差值直接定位
  - 数学证明严谨（推导块内不等式恒成立）
  - 实践价值：为大数据提供备选思路，但实现略复杂

---

## 3. 核心难点辨析与解题策略

1. **难点1：如何减少询问次数？**
   - **分析**：递归二分最坏需O(n)次询问，需利用等差数列特性剪枝。关键条件：`理论总和 - 实际询问值 < a_l + a_{l+1}` 时，区间必仅含一个特殊位置（因两特殊位置最小和≥a_l+a_{l+1}）
   - 💡 **学习笔记**：差值小于区间最小两数和 → 唯一特殊位置

2. **难点2：如何处理递归信息传递？**
   - **分析**：询问左区间后，右区间蓝色和=当前总蓝色和-左区间结果。避免重复询问的关键技巧！
   - 💡 **学习笔记**：信息继承是优化交互次数的核心技巧

3. **难点3：如何应对非均匀数据？**
   - **分析**：首块可能不满足「有趣块」条件，需暴力处理。其他块递归时若条件不满足则继续二分
   - 💡 **学习笔记**：首块总是特判对象，需预留处理逻辑

### ✨ 解题技巧总结
- **技巧1：差值定位法**：用等差数列和与询问值的差快速判断特殊位置数量
- **技巧2：信息继承优化**：递归右区间复用左区间结果，减少50%询问
- **技巧3：边界加速**：叶子节点（l=r）直接判定，避免多余操作

---

## 4. C++核心代码实现赏析

**通用核心实现参考**
* **说明**：综合优质题解优化的递归分治实现，完整包含输入输出交互逻辑
* **完整核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+5;

ll sum[N];   // 前缀和：sum[i]=a1+...+ai
int ans[N], cnt; // 存储特殊位置
int n,m,s,k,T;

ll ask(int l,int r) {
    cout << l << " " << r << endl;
    ll res; cin >> res;
    if(res == -1) exit(0); // 交互终止信号
    return res;
}

void solve(int l, int r, ll ns) {
    ll full = sum[r] - sum[l-1]; // 区间理论总和
    if(full == ns) return;      // 无特殊位置
    
    if(l == r) {                // 叶子节点：找到特殊位置
        ans[++cnt] = l;
        return;
    }
    
    // 判断是否仅有一个特殊位置
    if(full - ns < 1LL*(s+(l-1)*k) + 1LL*(s+l*k)) {
        for(int i = l; i <= r; ++i) {
            ll ai = 1LL*(i-1)*k + s;
            if(full - ns == ai) {
                ans[++cnt] = i;
                return;
            }
        }
    }
    
    int mid = (l+r) >> 1;
    ll left_sum = ask(l, mid);   // 仅询问左区间
    solve(l, mid, left_sum);     // 递归左区间
    solve(mid+1, r, ns - left_sum); // 右区间复用结果
}

int main() {
    cin >> T;
    while(T--) {
        cin >> n >> m >> s >> k;
        cnt = 0;
        // 计算前缀和
        for(int i=1; i<=n; ++i)
            sum[i] = sum[i-1] + 1LL*(i-1)*k + s;
        
        ll total = ask(1, n); // 初始询问整个区间
        solve(1, n, total);
        
        // 输出特殊位置
        cout << "-1 ";
        sort(ans+1, ans+cnt+1);
        for(int i=1; i<=cnt; ++i) 
            cout << ans[i] << " ";
        cout << endl;
    }
}
```
* **代码解读概要**：
  1. **初始化**：计算等差数列前缀和
  2. **主逻辑**：询问整个区间后进入递归函数
  3. **递归终止条件**：
     - 无特殊位置（`full == ns`）
     - 定位到单个特殊位置（遍历匹配）
  4. **二分优化**：仅询问左区间，右区间复用差值结果

---

## 5. 算法可视化：像素动画演示

### 🎮 设计主题：「二分探险者」像素解谜
> 将算法转化为8-bit风格探险游戏，玩家控制角色在等差数列书架上搜寻特殊书籍

* **核心演示流程**：
  ```mermaid
  graph LR
  A[初始化像素书架] --> B{询问区间}
  B --> C[计算理论总和 vs 实际值]
  C -->|差值=0| D[书架变绿-通过]
  C -->|差值<最小两数和| E[遍历点亮特殊位置]
  C -->|需二分| F[分裂书架+播放分裂音效]
  F --> G[递归左半]
  G --> H[右半复用结果]
  ```

* **关键动画细节**：
  1. **像素书架**：  
     - 灰色方块：待检查位置  
     - 闪烁金框：当前询问区间
  2. **控制面板**：
     - 速度滑块：调节自动演示速度
     - 单步按钮：步进执行算法
     - 暂停/继续：冻结当前状态
  3. **音效系统**：
     - 📢 二分分裂：复古电子音（类似《吃豆人》墙裂音效）
     - 🎉 定位成功：8-bit胜利旋律
     - ❌ 错误定位：短促警报声
  4. **数据可视化**：
     - 顶部状态栏：  
       `理论值: 250 | 实际: 200 | 差值: 50 | 最小两数和: 15+18=33`
     - 差值≥最小两数和时，区间分裂动画触发

* **教学价值**：
  - 实时高亮差值计算过程，强化「条件判断」逻辑
  - 右半区间不重复询问，用半透明箭头标注「信息继承」
  - 自动演示模式可对比分块 vs 递归策略效率

---

## 6. 拓展练习与相似问题

### 🔁 通用技巧迁移
> 差值定位法适用于任何**元素互异且有序**的序列，如：
> 1. 有序数组中找缺失/重复数
> 2. 带权图节点定位（边权递增）
> 3. 矩阵对角线元素搜索

### 📚 推荐练习（洛谷）
1. **P2671 求和**  
   → 等差数列性质应用，强化前缀和技巧
2. **P1783 海滩防御**  
   → 交互题进阶，结合几何与二分搜索
3. **P4137 Rmq Problem**  
   → 区间查询变种，需类似差值判断

---

## 7. 学习心得与经验分享
> 来自题解作者的调试经验：
> 
> **幽云蓝**：*“首块不满足有趣块条件，需单独处理。我在调试时通过对比前5组数据的首块特征，才确定暴力二分的边界值”*  
> → **启示**：特殊边界主动构造测试用例验证

> **xie_lzh**：*“复用右区间结果减少询问是关键，但需注意ns值传递时的整数溢出”*  
> → **启示**：大数据时用`long long`，传递前检查范围

---

> 本次解析结束！掌握等差数列特性与递归优化，你也能像像素探险家一样精准定位目标。尝试用可视化工具模拟算法，感受数据流动的魅力吧！🚀

---
处理用时：145.80秒
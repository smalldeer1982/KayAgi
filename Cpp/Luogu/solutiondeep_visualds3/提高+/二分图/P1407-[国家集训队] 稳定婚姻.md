# 题目信息

# [国家集训队] 稳定婚姻

## 题目描述

我们已知 $n$ 对夫妻的婚姻状况，称第 $i$ 对夫妻的男方为 $B_i$，女方为 $G_i$。若某男 $B_i$ 与某女 $G_j$ 曾经交往过（无论是大学，高中，亦或是幼儿园阶段，$i \le j$），则当某方与其配偶（即 $B_i$ 与 $G_i$ 或 $B_j$ 与 $G_j$）感情出现问题时，他们有私奔的可能性。不妨设 $B_i$ 和其配偶 $G_i$ 感情不和，于是 $B_i$ 和 $G_j$ 旧情复燃，进而 $B_j$ 因被戴绿帽而感到不爽，联系上了他的初恋情人 $G_k$ ……一串串的离婚事件像多米诺骨牌一般接踵而至。若在 $B_i$ 和 $G_i$ 离婚的前提下，这 $2n$ 个人最终依然能够结合成 $n$ 对情侣，那么我们称婚姻 $i$ 为不安全的，否则婚姻 $i$ 就是安全的。

给定所需信息，你的任务是判断每对婚姻是否安全。

## 说明/提示

对于 $20\%$ 的数据，$n \le 20$；

对于 $40\%$ 的数据，$n \le 100$，$m \le 400$；

对于 $100\%$ 的数据，所有姓名字符串中只包含英文大小写字母，大小写敏感，长度不大于 $8$，保证每对关系只在输入文件中出现一次，输入文件的最后 $m$ 行不会出现未在之前出现过的姓名，这 $2n$ 个人的姓名各不相同，$1 \le n \le 4000$，$0 \le m \le 20000$。

## 样例 #1

### 输入

```
2
Melanie Ashley
Scarlett Charles
1
Scarlett Ashley```

### 输出

```
Safe
Safe```

## 样例 #2

### 输入

```
2
Melanie Ashley
Scarlett Charles
2
Scarlett Ashley
Melanie Charles```

### 输出

```
Unsafe
Unsafe```

# AI分析结果



---
# 💡 Kay的C++算法解析：稳定婚姻 深入学习指南 💡

<introduction>
今天我们要分析的是“稳定婚姻”问题。这道题需要判断每对夫妻的婚姻是否安全——如果离婚后所有人仍能重新组成n对情侣，则不安全；否则安全。通过分析题解，我们会发现这是一个结合图论与强连通分量的经典问题，一起看看如何解决吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（强连通分量 / Tarjan算法）

🗣️ **初步分析**：
解决这道题的关键在于将婚姻关系转化为图的结构，通过强连通分量（SCC）判断是否存在“可重组”的环。强连通分量就像一个“闭环社区”，里面的节点两两可达。简单来说，Tarjan算法能帮我们找到这些“闭环”，如果一对夫妻的男女双方在同一个闭环里，说明他们可以通过其他关系重组，婚姻不安全。

- **题解思路对比**：主要有两种思路——  
  1️⃣ **Tarjan算法**（主流）：通过构建有向图（夫妻边：女→男；情人边：男→女），找SCC。若夫妻在同一SCC，不安全。  
  2️⃣ **二分图匹配**（匈牙利算法）：模拟离婚后尝试找新匹配，若能找到则不安全。但时间复杂度较高（O(n²)），适合小数据。  

  由于n可达4000，Tarjan的O(n+m)更高效，因此重点分析Tarjan思路。

- **核心算法流程**：  
  1. 用`map`将人名映射为唯一编号；  
  2. 建图：夫妻边（女→男）、情人边（男→女）；  
  3. 运行Tarjan算法找所有SCC；  
  4. 检查每对夫妻是否在同一SCC中，判断安全。  

- **可视化设计**：采用8位像素风，用不同颜色标记节点（女/男）、边（夫妻/情人）。动画演示Tarjan的DFS过程（节点入栈、回溯更新low值），最终用高亮色块展示SCC，直观看到夫妻是否在同一分量。


## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法效率等，以下题解表现突出（≥4星）：
</eval_intro>

**题解一：作者“雨季”（赞：97）**  
* **点评**：此题解思路清晰，明确指出“夫妻边女→男，情人边男→女”的建图关键，并详细解释了Tarjan算法的应用。代码规范（如`map`处理人名、链式前向星存图），边界处理严谨（遍历所有节点确保无遗漏）。算法复杂度O(n+m)，适合大规模数据，实践价值高。

**题解二：作者“ahawzlc”（赞：27）**  
* **点评**：用图示解释环的形成，帮助理解“强连通分量”与婚姻不安全的关系。代码简洁，`tarjan`函数实现标准，变量名（如`dfn`、`low`）符合惯例，可读性强。亮点是通过样例图说明建图逻辑，适合初学者理解。

**题解三：作者“Hydra”（赞：5）**  
* **点评**：代码结构清晰，用`map`处理人名映射，`tarjan`函数实现高效。特别说明“旧关系女连男，现关系男连女”的建图原因，解释了环的传递逻辑（如“影响”通过边传递形成闭环）。实践中能直接通过SCC判断结果，代码可复用性高。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于正确建模和理解强连通分量的意义。以下是核心难点及应对策略：
</difficulty_intro>

1.  **关键点1：如何正确建图？**  
    * **分析**：需区分夫妻和情人的边方向。夫妻边（女→男）表示“原配关系”，情人边（男→女）表示“可能的重组路径”。这样建图后，若存在环（如女A→男A→女B→男B→女A），说明这些夫妻可互相重组。  
    * 💡 **学习笔记**：建图方向是关键，需确保“重组路径”能形成有向环。

2.  **关键点2：如何理解强连通分量与婚姻安全的关系？**  
    * **分析**：若夫妻的男女在同一SCC，说明存在一条路径从女到男，再通过其他边回到女（如女→男→其他女→其他男→女），形成闭环。此时离婚后可通过环内关系重组，故不安全。  
    * 💡 **学习笔记**：SCC内的节点“互相可达”是重组的前提。

3.  **关键点3：如何处理字符串到整数的映射？**  
    * **分析**：题目中人名是字符串，需用`map`或哈希表映射为唯一编号（如女方用1~n，男方用n+1~2n）。需注意大小写敏感，确保每个名字唯一对应一个节点。  
    * 💡 **学习笔记**：`map<string, int>`是处理字符串映射的常用工具。

### ✨ 解题技巧总结
- **问题抽象**：将婚姻关系转化为图的边，用图论模型解决实际问题。  
- **算法选择**：Tarjan算法适合找SCC，时间复杂度低，适合大规模数据。  
- **边界处理**：遍历所有节点确保Tarjan覆盖所有可能的SCC（避免遗漏孤立节点）。  


## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，基于Tarjan算法，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：综合“雨季”和“ahawzlc”的题解，优化了`map`映射和Tarjan实现，适用于大规模数据。  
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstring>
    #include <map>
    #include <stack>
    using namespace std;

    const int MAXN = 8005; // 2*4000 + 5
    const int MAXM = 40005; // 20000情人边 + 4000夫妻边

    struct Edge {
        int to, next;
    } edges[MAXM];
    int head[MAXN], edge_cnt;
    int dfn[MAXN], low[MAXN], idx;
    int scc[MAXN], scc_cnt;
    bool in_stack[MAXN];
    stack<int> stk;
    map<string, int> name_to_id;

    void add_edge(int u, int v) {
        edges[++edge_cnt].to = v;
        edges[edge_cnt].next = head[u];
        head[u] = edge_cnt;
    }

    void tarjan(int u) {
        dfn[u] = low[u] = ++idx;
        stk.push(u);
        in_stack[u] = true;
        for (int i = head[u]; i; i = edges[i].next) {
            int v = edges[i].to;
            if (!dfn[v]) {
                tarjan(v);
                low[u] = min(low[u], low[v]);
            } else if (in_stack[v]) {
                low[u] = min(low[u], dfn[v]);
            }
        }
        if (dfn[u] == low[u]) {
            scc_cnt++;
            while (true) {
                int x = stk.top();
                stk.pop();
                in_stack[x] = false;
                scc[x] = scc_cnt;
                if (x == u) break;
            }
        }
    }

    int main() {
        int n, m;
        cin >> n;
        string girl, boy;
        int id = 0;
        for (int i = 1; i <= n; ++i) {
            cin >> girl >> boy;
            name_to_id[girl] = ++id; // 女方编号1~n
            name_to_id[boy] = ++id;  // 男方编号n+1~2n
            add_edge(name_to_id[girl], name_to_id[boy]); // 夫妻边：女→男
        }
        cin >> m;
        for (int i = 1; i <= m; ++i) {
            cin >> girl >> boy;
            add_edge(name_to_id[boy], name_to_id[girl]); // 情人边：男→女
        }
        // 运行Tarjan找所有SCC
        for (int i = 1; i <= 2 * n; ++i) {
            if (!dfn[i]) tarjan(i);
        }
        // 判断每对夫妻是否在同一SCC
        for (int i = 1; i <= n; ++i) {
            int girl_id = 2 * i - 1; // 女方编号：1,3,5...
            int boy_id = 2 * i;       // 男方编号：2,4,6...
            if (scc[girl_id] == scc[boy_id]) {
                cout << "Unsafe\n";
            } else {
                cout << "Safe\n";
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先用`map`将人名映射为唯一ID（女方1~n，男方n+1~2n），然后建图（夫妻边女→男，情人边男→女）。通过Tarjan算法找出所有SCC，最后检查每对夫妻的男女是否在同一SCC中，输出结果。


<code_intro_selected>
以下是优质题解的核心代码片段赏析：
</code_intro_selected>

**题解一：作者“雨季”**  
* **亮点**：链式前向星存图高效，`map`处理人名映射清晰。  
* **核心代码片段**：
    ```cpp
    struct node {
        int v, nex;
    }e[M];
    int tot,h[N];
    void add(int u,int v) {
        e[++tot].v=v;
        e[tot].nex=h[u];
        h[u]=tot;
    }
    // Tarjan函数实现...
    ```
* **代码解读**：  
  链式前向星是图的高效存储结构，`add`函数添加有向边。`node`结构体存储边的终点和下一条边的索引，`h`数组记录每个节点的第一条边。这种方式空间和时间复杂度低，适合大规模数据。  
* 💡 **学习笔记**：链式前向星是处理稀疏图的常用方法，适合边数较多的场景。

**题解二：作者“ahawzlc”**  
* **亮点**：用图示解释环的形成，`tarjan`函数逻辑清晰。  
* **核心代码片段**：
    ```cpp
    void tarjan(int u) {
        s.push(u);
        vis[u]=1;
        dfn[u]=low[u]=++id;
        for(int i=h[u]; i; i=b[i].nxt) {
            int v=b[i].to;
            if(!dfn[v]) {
                tarjan(v);
                low[u]=min(low[u],low[v]);
            } else {
                if(vis[v]) {
                    low[u]=min(low[u],dfn[v]);
                }
            }
        }
        if(dfn[u]==low[u]) {
            tarn++;
            int v;
            do {
                v=s.top();
                s.pop();
                bl[v]=tarn;
                vis[v]=0;
            } while(u!=v);
        }
    }
    ```
* **代码解读**：  
  `tarjan`函数通过DFS遍历节点，维护`dfn`（访问顺序）和`low`（能到达的最小`dfn`）。若`dfn[u]==low[u]`，说明找到SCC的根，将栈中节点弹出并标记。这是标准的Tarjan实现，确保每个SCC被正确识别。  
* 💡 **学习笔记**：Tarjan算法的核心是维护`dfn`和`low`，通过栈记录当前路径节点。


## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解Tarjan算法如何找到SCC，我们设计一个“像素侦探”主题的8位风格动画，模拟建图、DFS遍历和SCC形成过程。
</visualization_intro>

  * **动画演示主题**：像素侦探的“婚姻重组案”  
  * **核心演示内容**：展示夫妻边（粉色箭头）、情人边（蓝色箭头）的建图，Tarjan的DFS过程（节点闪烁入栈），以及SCC的形成（同一颜色块标记）。  

  * **设计思路简述**：  
    8位像素风格（类似FC游戏）降低学习压力；颜色区分边类型（粉色=夫妻，蓝色=情人）；节点入栈时“滑入”动画+“叮”音效，SCC形成时用彩虹色块高亮，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1. **场景初始化**：  
       - 屏幕左侧是“人物列表”（像素方块，女用粉色，男用蓝色），右侧是“关系图”（网格背景，边用箭头表示）。  
       - 控制面板：单步/自动播放按钮、速度滑块、重置按钮。

    2. **建图演示**：  
       - 输入夫妻时，粉色箭头从女方方块指向男方方块（音效：“噗”）；  
       - 输入情人时，蓝色箭头从男方方块指向女方方块（音效：“咻”）。

    3. **Tarjan算法执行**：  
       - **DFS遍历**：当前访问节点闪烁（黄色边框），入栈时方块“滑”入栈区域（栈用垂直排列的方块表示）。  
       - **更新low值**：若子节点的`low`更小，当前节点的`low`值数字变化（红色高亮）。  
       - **SCC形成**：当`dfn[u]==low[u]`时，栈中节点弹出并被同一颜色块包裹（如绿色），伴随“叮咚”胜利音效。

    4. **结果判断**：  
       - 每对夫妻的男女方块若被同一颜色块包裹，显示“Unsafe”（红色字体）；否则显示“Safe”（绿色字体）。

  * **旁白提示**：  
    - “看！粉色箭头是原配夫妻，蓝色箭头是旧情人~”  
    - “当前节点入栈，我们继续往深处搜索...”  
    - “发现SCC！这些人可以互相重组哦~”

<visualization_conclusion>
通过这个动画，我们能直观看到Tarjan如何一步步找到SCC，理解“闭环”如何导致婚姻不安全。像素风格和音效让学习过程更有趣！
</visualization_conclusion>


## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的Tarjan算法后，可以尝试以下拓展练习，巩固图论知识：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    强连通分量不仅用于婚姻问题，还适用于：  
    - 电路设计中的信号传递环检测；  
    - 社交网络中的“相互关注”群体分析；  
    - 依赖关系中的循环依赖检测（如软件包安装）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P2341 受欢迎的牛**  
        * 🗣️ **推荐理由**：同样用Tarjan找SCC，需判断出度为0的SCC是否唯一，巩固SCC应用。  
    2.  **洛谷 P3387 缩点**  
        * 🗣️ **推荐理由**：将图缩为DAG后求最长路径，练习SCC与拓扑排序的结合。  
    3.  **洛谷 P1262 间谍网络**  
        * 🗣️ **推荐理由**：用Tarjan找必须被收买的SCC，提升图论建模能力。  


## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，对我们很有启发：
</insights_intro>

> **参考经验 (来自作者“xzlhxc_ed”)**：“第一次用匈牙利算法时，没注意数据范围，导致TLE。后来改用Tarjan，才发现建图方向是关键。”  
> **点评**：算法选择要考虑数据规模！本题n=4000时，Tarjan的O(n+m)比匈牙利的O(n²)更高效。调试时若遇到超时，需检查算法复杂度是否匹配数据范围。


<conclusion>
通过分析“稳定婚姻”问题，我们掌握了用Tarjan算法解决图论问题的核心思路。关键是正确建图，理解SCC与问题的关联。希望大家通过练习巩固，下次挑战更难的图论题目！💪
</conclusion>

---
处理用时：148.55秒
# 题目信息

# 「Wdoi-6」最澄澈的空与海

## 题目背景

[![](https://cdn.luogu.com.cn/upload/image_hosting/hiekh6t5.png)](https://thwiki.cc/%E5%8D%AF%E9%85%89%E4%B8%9C%E6%B5%B7%E9%81%93_%EF%BD%9E_Retrospective_53_minutes.)

广重号载着二人向东飞驰。毫无噪音，毫无摇摆，只是一个劲向东飞驰。在“万景幕”装置之下，尽管是全地下的卯酉东海道，乘客们也能饱览美丽的富士山和太平洋的景色。

但是，从这列卯酉新干线『广重』上看到的极富日本风味的美丽情景，对于梅莉来说，只不过是无趣的视觉刺激罢了。高动态范围的影像也好，极富日本风味的情景也好，都敌不过真正的天空的颜色。

身与华落，心将香飞。即便肉体会像花朵一样终有一天凋落，但心却可以如花香一般飘往远方。

「梅莉，你看，天上的星星呦。」

## 题目描述

### 简要题意

给定 $2n$ 个点、$m$ 条边的[二分图](http://oi-wiki.com/graph/bi-graph/#_1)（可能有重边），左部点与右部点个数相同，判断其完美匹配数量是否**恰好**为 $1$。是则输出 `Renko`，否则输出 `Merry`。

> **注**：完美匹配是指，从边集中选出 $n$ 条边，这些边的顶点组成的点集恰好覆盖了所有的 $2n$ 个点。

---
### 原始题意

在夜里，莲子与梅莉来到了东京的海边，躺在沙滩上，欣赏着澄澈的天空与大海，数起了天上的星星。

在这些星星之中，有 $n$ 个星星 $\{a_i\}$，是莲子先发现的，被称为莲子星；而又有 $n$ 个星星 $\{b_i\}$，是梅莉先发现的，被称为梅莉星。由于她们心有灵犀，这两批星星之间**不存在交集**。  

她们发现，有一些莲子星，与一些梅莉星之间恰好存在运动关系。具体而言，这些关系一共有 $m$ 组，每一组关系形如 $(u_i,v_i)$，也就是说第 $u_i$ 颗莲子星与第 $v_i$ 颗梅莉星之间存在运动关系。这些运动关系有可能重复。

这让莲子和梅莉非常好奇。作为专攻超统一物理学的女大学生，莲子认为，如果认为这些星星的运动是**和谐**的，那么她应当能够从这 $m$ 个运动关系中，找出若干个运动关系，使得**每颗**星星**都被**这些运动关系**包含**的同时，不会有一颗星星**被包含在两个**运动关系之中。

然而，梅莉认为，**和谐**的运动可能是不存在的，更何况即使莲子找到了**和谐**的运动，莲子也无法确保这种和谐运动的**唯一性**。两种和谐运动不同，当且仅当选取出的两组运动关系中，存在至少一个运动关系，是不相同的。

因为意见不合，她们于是打情骂俏了一顿。莲子于是记下了她们所看到了星星和她们之间的运动关系，并且找到了已经证明了 P=NP 的你，希望你能告诉她们，最后是谁正确呢？

## 说明/提示

### 样例解释

#### 样例 \#1

![](https://cdn.luogu.com.cn/upload/image_hosting/6skoily9.png)

如图所示，存在唯一的方案：$\{1\to 1,2\to 5,3\to 2,4\to 3,5\to 4\}$。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n\le } & \bm{m\le} & \textbf{\textsf{特殊性质}} & \textbf{Subtask \textsf{依赖}}\cr\hline
1 & 10 & 10 & 10 & - & - \cr\hline
2 & 20 & 300 & 4\times 10^4 & - & 1\cr\hline
3 & 20 & 10^5 & 5 \times 10^5 & \mathbf{A} & - \cr\hline
4 & 20 & 10^5 & 2 \times 10^5 & \mathbf{B} & - \cr\hline
5 & 30& 10^6 & 2\times 10^6 & - & 2,3,4 \cr\hline
\end{array}
$$

- 特殊性质 $\mathbf{A}$：保证对于第 $i$ 颗莲子星，与第 $i$ 颗梅莉星之间存在运动关系。
- 特殊性质 $\mathbf{B}$：保证 $m=2n-1$。

对于 $100\%$ 的数据，保证 $1 \le u_i,v_i\le n \le 10^6$，$1 \le m \le 2 \times 10^6$，$1 \leq T \leq 5$ 且对于每个测试点，$\sum m \leq 4 \times 10^6$。

对于 $\rm Subtask\ 5$，时间限制为 $3$ 秒。其它测试点时间限制为 $1$ 秒。

## 样例 #1

### 输入

```
1
5
6
1 1
1 3
3 2
2 5
4 3
5 4```

### 输出

```
Renko```

# AI分析结果



---
# 💡 Kay的C++算法解析：「Wdoi-6」最澄澈的空与海 深入学习指南 💡

<introduction>
今天我们要分析的是一道关于二分图完美匹配唯一性的题目。通过理解题目核心、提炼题解思路，并结合可视化演示，希望能帮助大家掌握如何高效判断二分图是否存在唯一完美匹配。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（二分图完美匹配的唯一性判断）

🗣️ **初步分析**：
解决这道题的关键在于利用二分图的度数特性。简单来说，若一个二分图存在且仅存在一个完美匹配，那么它必定可以通过不断删除度数为1的点及其匹配点，最终删完所有点。这就像“拆积木”——每次找到只能与一个点匹配的“必选点对”，拆掉它们后，剩下的子图继续重复这个过程。

- **题解思路**：所有优质题解均基于同一核心结论：当且仅当通过拓扑排序式删除度数为1的点后，能删完所有2n个点时，完美匹配唯一。若剩余点度数均≥2，则匹配数不为1。
- **核心难点**：如何证明度数≥2的子图无法存在唯一完美匹配？如何高效实现度数为1的点的动态删除？
- **可视化设计**：采用8位像素风格，用不同颜色标记当前处理的点（如黄色）、已删除的点（灰色）、度数变化（绿色表示度数减1）。关键步骤（如入队、删除）配合“叮”的音效，目标达成时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑清晰、实现高效被选为优质参考：
</eval_intro>

**题解一：retep的题解（赞：23）**
* **点评**：此题解从结论推导到代码实现均非常完整。作者通过反证法说明度数≥2的图无法存在唯一完美匹配，并给出拓扑排序式删除度数为1的点的算法。代码中使用队列处理度数为1的点，动态更新相关点的度数，时间复杂度O(n+m)，适合大规模数据。边界处理（如删除已处理点、初始化）严谨，实践价值高。

**题解二：Cocoly1990的题解（赞：9）**
* **点评**：此题解通过构造环的方式证明度数≥2的图匹配不唯一，逻辑简洁。代码中使用队列模拟拓扑排序，删除必选点对，思路直观。特别指出“多测要清空”的细节，避免常见错误，对学习者有明确指导意义。

**题解三：minstdfx的题解（赞：7）**
* **点评**：此题解从观察入手，通过手玩样例总结规律，结合理论证明，易于理解。代码中使用`vis`数组标记已删除点，`deg`数组维护度数，实现简洁高效。对度数为0的情况提前判断，避免无效计算。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于理解度数特性与完美匹配唯一性的关系，以及如何高效实现动态删除过程。以下是核心难点及策略：
</difficulty_intro>

1.  **关键点1：为何度数≥2的图无法存在唯一完美匹配？**
    * **分析**：假设存在唯一完美匹配，删去匹配边后，剩余边构成的有向图中每个点至少有一条出边（因原度数≥2），必然存在环。环上的边可通过翻转匹配状态生成新匹配，导致匹配不唯一。
    * 💡 **学习笔记**：环的存在是匹配不唯一的“罪魁祸首”，度数≥2的图必含环。

2.  **关键点2：如何高效删除度数为1的点？**
    * **分析**：使用队列模拟拓扑排序，每次处理度数为1的点，找到其唯一匹配点，删除两者并更新相关点的度数。若更新后其他点的度数变为1，则入队继续处理。
    * 💡 **学习笔记**：队列是处理动态度数变化的高效工具，确保每个点仅处理一次。

3.  **关键点3：多组数据如何避免错误？**
    * **分析**：每次测试后需清空度数数组、邻接表、标记数组等，避免上一组数据残留影响结果。
    * 💡 **学习笔记**：“多测不清空，爆零两行泪”，初始化是竞赛编程的重要细节。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题转化**：将完美匹配唯一性问题转化为度数分析与拓扑排序问题。
- **动态维护**：用队列维护度数为1的点，确保每次处理的是当前必选点对。
- **边界处理**：提前判断度数为0的点（直接无完美匹配），避免无效计算。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的核心实现，采用拓扑排序式删除度数为1的点，时间复杂度O(n+m)，适用于大规模数据。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合retep、Cocoly1990等题解的思路，通过队列处理度数为1的点，动态删除必选点对，最终判断是否删完所有点。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MAXN = 2e6 + 5; // 最大点数（2n）
    vector<int> G[MAXN];       // 邻接表存图
    int deg[MAXN];             // 各点的度数
    bool del[MAXN];            // 标记是否已删除

    bool solve(int n, int m) {
        // 初始化
        for (int i = 1; i <= 2 * n; ++i) {
            G[i].clear();
            deg[i] = 0;
            del[i] = false;
        }
        // 读入边并构建邻接表
        for (int i = 0; i < m; ++i) {
            int u, v;
            scanf("%d %d", &u, &v);
            v += n; // 右部点编号偏移（1~n → n+1~2n）
            G[u].push_back(v);
            G[v].push_back(u);
            deg[u]++;
            deg[v]++;
        }
        // 队列处理度数为1的点
        queue<int> q;
        for (int i = 1; i <= 2 * n; ++i) {
            if (deg[i] == 1) q.push(i);
        }
        int cnt = 0; // 已删除点的数量
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            if (del[u] || deg[u] != 1) continue; // 已删除或度数已变化
            del[u] = true;
            cnt++;
            // 找到u的唯一未删除邻接点v
            int v = -1;
            for (int neighbor : G[u]) {
                if (!del[neighbor]) {
                    v = neighbor;
                    break;
                }
            }
            if (v == -1) return false; // 无匹配点，无法形成完美匹配
            del[v] = true;
            cnt++;
            // 更新v的邻接点的度数
            for (int neighbor : G[v]) {
                if (!del[neighbor] && (--deg[neighbor]) == 1) {
                    q.push(neighbor);
                }
            }
        }
        return cnt == 2 * n; // 所有点都被删除，存在唯一完美匹配
    }

    int main() {
        int T;
        scanf("%d", &T);
        while (T--) {
            int n, m;
            scanf("%d %d", &n, &m);
            puts(solve(n, m) ? "Renko" : "Merry");
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读入数据并构建邻接表，维护每个点的度数。通过队列处理度数为1的点，每次删除当前点及其唯一匹配点，更新相关点的度数。若最终删除了所有2n个点，说明存在唯一完美匹配。

---
<code_intro_selected>
以下是优质题解的核心代码片段赏析：
</code_intro_selected>

**题解一：retep的代码片段**
* **亮点**：使用`queue`处理度数为1的点，动态更新度数，逻辑清晰。
* **核心代码片段**：
    ```cpp
    queue<int> q; cnt=0;
    for(int i=1;i<=2*n;i++)
        if(in[i]==1) q.push(i);
    while(!q.empty()){
        int now=q.front(),buf=0; q.pop();
        if(del[now]||in[now]!=1) continue;
        del[now]=true; cnt++;
        while(del[to[now][buf]]) buf++;
        del[to[now][buf]]=true; cnt++;
        for(int i=0;i<to[to[now][buf]].size();i++)
            if(!del[to[to[now][buf]][i]]&&(--in[to[to[now][buf]][i]])==1)
                q.push(to[to[now][buf]][i]);
    }
    ```
* **代码解读**：
    队列`q`存储度数为1的点。每次取出队首点`now`，若未被删除且度数仍为1，则标记为已删除（`del[now]=true`）。找到其唯一邻接点`to[now][buf]`，同样标记为已删除。遍历该邻接点的所有邻接点，减少其度数，若度数变为1则入队。最终通过`cnt`判断是否删完所有点。
* 💡 **学习笔记**：队列确保了处理顺序的高效性，动态更新度数避免了重复计算。

**题解二：Cocoly1990的代码片段**
* **亮点**：通过反证法证明结论，代码简洁，边界处理严谨。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n*2;i++)
        if(deg[i]==1) q.push(i);
    while(!q.empty()){
        int u=q.front(); q.pop();
        if(vis[u]) continue;
        vis[u]=1;
        for(int v:G[u]) if(!vis[v]){
            vis[v]=1;
            for(int w:G[v]) if(--deg[w]==1) q.push(w);
            break;
        }
    }
    puts(vis[1]?"Renko":"Merry");
    ```
* **代码解读**：
    使用`vis`数组标记已删除点。队列处理度数为1的点`u`，找到其邻接点`v`并标记为已删除。遍历`v`的邻接点`w`，减少其度数，若度数变为1则入队。最终判断是否所有点被标记。
* 💡 **学习笔记**：`vis`数组与度数数组的配合使用，确保每个点仅处理一次。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解度数为1的点的删除过程，我们设计一个“像素拓扑小能手”动画，用8位像素风格展示算法执行流程。
</visualization_intro>

  * **动画演示主题**：像素拓扑小能手——拆解唯一完美匹配的“必选点对”

  * **核心演示内容**：展示队列如何处理度数为1的点，动态删除必选点对，并更新相关点的度数，直到所有点被删除或无法继续。

  * **设计思路简述**：8位像素风格（如FC游戏画面）降低学习压力；关键步骤（入队、删除）用颜色高亮和音效强化记忆；“过关”机制（每删除一对点，分数+2）增加趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为左右两部分（左部点1~n，右部点n+1~2n），每个点用像素方块表示（左蓝右红）。
        - 控制面板：单步/自动播放按钮、速度滑块、分数显示（初始0分）。
        - 背景播放8位风格BGM（如《超级马里奥》经典旋律）。

    2.  **初始度数展示**：
        - 每个点上方显示度数（白色数字），度数为1的点闪烁（黄色边框）。

    3.  **队列处理过程**：
        - 队列用像素管道表示，管道中的点（黄色）依次进入处理区。
        - 处理当前点`u`时，`u`变为绿色，找到其唯一邻接点`v`（红色），两者同时变为灰色（已删除），分数+2。
        - `v`的邻接点`w`度数减1（数字变化），若度数变为1则加入队列（管道中新增黄色点），伴随“叮”的音效。

    4.  **目标达成/失败**：
        - 若分数达到2n（所有点删除），播放胜利音效（《超级马里奥》通关音），显示“Renko胜利！”。
        - 若队列为空但分数未到2n，播放失败音效（短促“咚”），显示“Merry胜利！”。

  * **旁白提示**：
    - （处理度数为1的点时）“看！这个点只有1条边，它和对面的点必须匹配，我们把它们删掉吧~”
    - （更新度数时）“删掉这对点后，其他点的度数可能会变成1哦，快看看谁要入队啦！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到度数为1的点如何被逐步删除，以及度数变化如何影响后续处理。这种“看得见”的算法执行过程，能帮助我们更好地理解拓扑排序在二分图匹配中的应用。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心思想（度数分析+拓扑排序）可迁移到其他图论问题中。以下是相关练习推荐：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - **树的拓扑排序**：判断树是否为链（度数为1的点逐步删除后只剩根）。
      - **有向图环检测**：通过拓扑排序判断是否存在环（度数为0的点处理完后仍有剩余点）。
      - **二分图匹配变形**：判断是否存在唯一最大匹配（类似本题思路）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3386** - 【模板】二分图最大匹配
          * 🗣️ **推荐理由**：巩固二分图匹配的基础算法（如匈牙利算法、Dinic算法），理解完美匹配的存在性判断。
    2.  **洛谷 P1129** - [ZJOI2007] 骑士
          * 🗣️ **推荐理由**：结合二分图与树形DP，锻炼图论问题的综合分析能力。
    3.  **洛谷 P2756** - 飞行员配对方案问题
          * 🗣️ **推荐理由**：经典二分图匹配应用题，理解匹配的实际意义与构造方法。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到“多测不清空，爆零两行泪”，强调了多组数据初始化的重要性。以下是典型经验总结：
</insights_intro>

> **参考经验 (来自 retep 题解)**：“多组数据，要初始化。”
>
> **点评**：在处理多组测试数据时，必须清空邻接表、度数数组、标记数组等，避免上一组数据残留导致错误。这是竞赛编程中常见的“坑”，需特别注意。

---

<conclusion>
通过本次分析，我们掌握了判断二分图唯一完美匹配的核心方法：利用度数为1的点进行拓扑排序式删除。希望大家通过练习巩固这一思路，在遇到类似问题时能快速联想到度数分析与拓扑排序的结合。编程的道路上，每一次思考都是成长的阶梯，加油！💪
</conclusion>

---
处理用时：152.38秒
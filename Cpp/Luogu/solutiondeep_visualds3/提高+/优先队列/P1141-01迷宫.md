# 题目信息

# 01迷宫

## 题目描述

有一个仅由数字 $0$ 与 $1$ 组成的 $n \times n$ 格迷宫。若你位于一格 $0$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $1$ 上，同样若你位于一格 $1$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $0$ 上。

你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。

## 说明/提示

对于样例，所有格子互相可达。

- 对于 $20\%$ 的数据，$n \leq 10$；
- 对于 $40\%$ 的数据，$n \leq 50$；
- 对于 $50\%$ 的数据，$m \leq 5$；
- 对于 $60\%$ 的数据，$n,m \leq 100$；
- 对于 $100\%$ 的数据，$1\le n \leq 1000$，$1\le m \leq 100000$。

## 样例 #1

### 输入

```
2 2
01
10
1 1
2 2
```

### 输出

```
4
4
```

# AI分析结果

# 01迷宫题解分析与总结


## **一、题目核心要求**
给定一个\(n \times n\)的01迷宫，每次可以从0走到相邻（上下左右）的1，或从1走到相邻的0。对于每个询问点，求其能到达的格子数（包括自身）。


## **二、常见解题思路**
由于\(m\)（询问次数）可能高达\(10^5\)，直接暴力搜索每个询问会超时（时间复杂度\(O(m \times n^2)\)）。**关键优化点**：**同一个连通块内的所有点答案相同**（能互相到达，故可达格子数相同）。因此，只需**预处理所有连通块**，记录每个点的答案，查询时直接返回即可。

常见预处理方法有三种：**DFS**、**BFS**、**并查集**。


### **1. DFS（深度优先搜索）**
- **思路**：从未访问的点出发，递归遍历所有可达点（连通块），记录每个点的连通块编号和该连通块的大小。
- **实现细节**：
  - 用`f[x][y]`记录点\((x,y)\)的连通块编号。
  - 用`ans[编号]`记录该连通块的大小。
  - 每次询问时，若`f[x][y]`未初始化，则启动DFS遍历整个连通块，更新`f`和`ans`。
- **优缺点**：
  - 优点：代码简单，逻辑直观。
  - 缺点：递归深度可能很大（如迷宫为长链时），导致**栈溢出**，不适合大数据。

**示例代码（简化版）**：
```cpp
void dfs(int x, int y, int idx) {
    if (x < 0 || x >= n || y < 0 || y >= n || f[x][y] != -1 || s[x][y] != target) return;
    f[x][y] = idx;
    ans[idx]++;
    dfs(x-1, y, idx);
    dfs(x+1, y, idx);
    dfs(x, y-1, idx);
    dfs(x, y+1, idx);
}
```


### **2. BFS（广度优先搜索）**
- **思路**：从未访问的点出发，用队列遍历所有可达点（连通块），记录每个点的连通块编号和大小。
- **实现细节**：
  - 用`flag[x][y]`记录点\((x,y)\)的连通块编号。
  - 用`a[编号]`记录该连通块的大小。
  - 预处理时遍历所有点，未被访问过的点启动BFS，更新`flag`和`a`。
- **优缺点**：
  - 优点：用队列实现，无栈溢出问题，适合大数据。
  - 缺点：代码稍复杂，需要维护队列。

**示例代码（简化版）**：
```cpp
void bfs(int x, int y, int idx) {
    queue<pair<int, int>> q;
    q.push({x, y});
    flag[x][y] = idx;
    int cnt = 1;
    while (!q.empty()) {
        auto [cx, cy] = q.front();
        q.pop();
        for (int i = 0; i < 4; i++) {
            int nx = cx + dx[i], ny = cy + dy[i];
            if (nx >= 0 && nx < n && ny >= 0 && ny < n && !flag[nx][ny] && s[cx][cy] != s[nx][ny]) {
                flag[nx][ny] = idx;
                cnt++;
                q.push({nx, ny});
            }
        }
    }
    a[idx] = cnt;
}
```


### **3. 并查集（Union-Find）**
- **思路**：将每个点映射到一维（如\((i,j)\)映射为\(i \times n + j\)），合并相邻的不同值的点（因为0和1可以互相到达），最后查询根节点的大小。
- **实现细节**：
  - 用`fa[ ]`记录父节点，`size[ ]`记录根节点所在连通块的大小。
  - 预处理时，遍历所有点，合并相邻的不同值的点。
  - 查询时，找到该点的根节点，返回`size[根节点]`。
- **优缺点**：
  - 优点：合并和查询的时间复杂度近似\(O(1)\)（路径压缩+按秩合并），效率极高。
  - 缺点：需要处理二维转一维的映射，代码复杂度中等。

**示例代码（简化版）**：
```cpp
int find(int x) {
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}

void unite(int x, int y) {
    x = find(x), y = find(y);
    if (x != y) {
        if (size[x] < size[y]) swap(x, y);
        fa[y] = x;
        size[x] += size[y];
    }
}

// 预处理：合并相邻不同值的点
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        int idx = i * n + j;
        fa[idx] = idx;
        size[idx] = 1;
        // 合并上方点（i-1,j）
        if (i > 0 && s[i][j] != s[i-1][j]) {
            unite(idx, (i-1)*n + j);
        }
        // 合并左方点（i,j-1）
        if (j > 0 && s[i][j] != s[i][j-1]) {
            unite(idx, i*n + (j-1));
        }
    }
}
```


## **三、关键优化点**
1. **记忆化**：记录每个点的答案（连通块大小），避免重复搜索。
2. **连通块处理**：一次处理整个连通块，减少重复计算。
3. **输入输出优化**：用`scanf`/`printf`或快速读入函数（如`getchar`），避免`cin`/`cout`的慢速度。
4. **数据结构优化**：用数组代替STL容器（如`queue`），提高效率（如用数组模拟队列）。


## **四、代码示例分析**
以**BFS**为例，看一个完整的题解代码（作者：Zero神）：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
const int dx[] = {0,0,-1,1};
const int dy[] = {-1,1,0,0};
struct node{ int x,y; };
char maze[N][N];
int vis[N][N], block[N][N];// block记录每个点的连通块大小
int n, m, a, b, ans;

void bfs() {
    node now, nx;
    queue<node> q;
    vector<node> pos;
    q.push({a,b});
    vis[a][b] = 1;
    ans = 1;
    while (!q.empty()) {
        now = q.front(); q.pop();
        pos.push_back(now);
        for (int i = 0; i < 4; i++) {
            nx.x = now.x + dx[i], nx.y = now.y + dy[i];
            if (!maze[nx.x][nx.y] || vis[nx.x][nx.y] || maze[now.x][now.y] == maze[nx.x][nx.y]) continue;
            vis[nx.x][nx.y] = 1;
            ans++;
            q.push(nx);
        }
    }
    for (auto v : pos) block[v.x][v.y] = ans;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%s", maze[i]+1);
    while (m--) {
        scanf("%d%d", &a, &b);
        if (!block[a][b]) bfs();
        printf("%d\n", block[a][b]);
    }
    return 0;
}
```
- **分析**：
  - `block`数组记录每个点的连通块大小，预处理时未被访问的点启动`bfs`。
  - `bfs`中用队列遍历所有可达点，记录所有点的位置，最后更新`block`数组。
  - 查询时直接输出`block[a][b]`，无需重复计算。


## **五、总结**
- **最佳方法**：**BFS**或**并查集**，适合大数据，无栈溢出问题。
- **注意事项**：
  - 输入输出优化：必须用快速读入输出，否则会超时。
  - 连通块处理：确保所有可达点都被正确记录。
  - 边界条件：迷宫的坐标范围（如从1开始或0开始）。


## **六、拓展思考**
- 若迷宫是动态变化的（如修改某个点的0/1值），如何高效更新答案？
- 若要求输出路径而非数量，如何修改算法？
- 并查集的路径压缩和按秩合并如何实现？


**结论**：01迷宫的核心是**连通块处理**，通过预处理连通块可以将查询时间降为\(O(1)\)，从而解决大数据问题。选择BFS或并查集是最优的，DFS适合小数据或调试。

---
处理用时：121.25秒
# 题目信息

# [SHOI2012] 魔法树

## 题目背景

SHOI2012 D2T3


## 题目描述

Harry Potter 新学了一种魔法：可以改变树上的果子个数。满心欢喜的他找到了一个巨大的果树，来试验他的新法术。

这棵果树共有 $N$ 个节点，其中节点 $0$ 是根节点，每个节点 $u$ 的父亲记为 $fa[u]$，保证有 $fa[u] < u$ 。初始时，这棵果树上的果子都被 Dumbledore 用魔法清除掉了，所以这个果树的每个节点上都没有果子（即 $0$ 个果子）。

不幸的是，Harry 的法术学得不到位，只能对树上一段路径的节点上的果子个数统一增加一定的数量。也就是说，Harry 的魔法可以这样描述：`A u v d` 。表示将点 $u$ 和 $v$ 之间的路径上的所有节点的果子个数都加上 $d$。

接下来，为了方便检验 Harry 的魔法是否成功，你需要告诉他在释放魔法的过程中的一些有关果树的信息：`Q u`。表示当前果树中，以点 $u$ 为根的子树中，总共有多少个果子？


## 样例 #1

### 输入

```
4
0 1
1 2
2 3
4
A 1 3 1
Q 0
Q 1
Q 2```

### 输出

```
3
3
2```

# AI分析结果


### 题目分析
本题要求实现树链剖分算法，支持两种操作：
1. **路径修改**：将节点u到v路径上的所有节点权值增加d
2. **子树查询**：查询以节点u为根的子树的权值和

树链剖分通过两次DFS将树转化为线性序列：
- **第一次DFS**：计算深度、父节点、子树大小和重儿子
- **第二次DFS**：分配DFS序，标记链顶节点

### 算法实现
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
using namespace std;
typedef long long ll;

const int MAXN = 100010;

struct Edge {
    int to, next;
} edges[MAXN << 1];
int head[MAXN], edge_cnt;

int dep[MAXN], fa[MAXN], siz[MAXN], son[MAXN];
int top[MAXN], id[MAXN], rk[MAXN], dfs_cnt;

ll tree[MAXN << 2], lazy[MAXN << 2];
int n, q;

void add_edge(int u, int v) {
    edges[++edge_cnt] = {v, head[u]};
    head[u] = edge_cnt;
}

// 第一次DFS：计算深度、父节点、子树大小和重儿子
void dfs1(int u, int f) {
    dep[u] = dep[f] + 1;
    fa[u] = f;
    siz[u] = 1;
    son[u] = 0;
    for (int i = head[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (v == f) continue;
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[v] > siz[son[u]]) son[u] = v;
    }
}

// 第二次DFS：分配DFS序，标记链顶
void dfs2(int u, int t) {
    top[u] = t;
    id[u] = ++dfs_cnt;
    rk[dfs_cnt] = u;
    if (son[u]) dfs2(son[u], t);
    for (int i = head[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (v == fa[u] || v == son[u]) continue;
        dfs2(v, v);
    }
}

// 线段树：构建
void build(int rt, int l, int r) {
    lazy[rt] = 0;
    if (l == r) {
        tree[rt] = 0;
        return;
    }
    int mid = (l + r) >> 1;
    build(rt << 1, l, mid);
    build(rt << 1 | 1, mid + 1, r);
    tree[rt] = tree[rt << 1] + tree[rt << 1 | 1];
}

// 线段树：标记下传
void push_down(int rt, int len) {
    if (lazy[rt]) {
        lazy[rt << 1] += lazy[rt];
        lazy[rt << 1 | 1] += lazy[rt];
        tree[rt << 1] += lazy[rt] * (len - (len >> 1));
        tree[rt << 1 | 1] += lazy[rt] * (len >> 1);
        lazy[rt] = 0;
    }
}

// 线段树：区间修改
void update(int rt, int l, int r, int L, int R, ll val) {
    if (L <= l && r <= R) {
        tree[rt] += val * (r - l + 1);
        lazy[rt] += val;
        return;
    }
    push_down(rt, r - l + 1);
    int mid = (l + r) >> 1;
    if (L <= mid) update(rt << 1, l, mid, L, R, val);
    if (R > mid) update(rt << 1 | 1, mid + 1, r, L, R, val);
    tree[rt] = tree[rt << 1] + tree[rt << 1 | 1];
}

// 线段树：区间查询
ll query(int rt, int l, int r, int L, int R) {
    if (L <= l && r <= R) return tree[rt];
    push_down(rt, r - l + 1);
    int mid = (l + r) >> 1;
    ll res = 0;
    if (L <= mid) res += query(rt << 1, l, mid, L, R);
    if (R > mid) res += query(rt << 1 | 1, mid + 1, r, L, R);
    return res;
}

// 树链剖分：路径修改
void update_path(int u, int v, ll d) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        update(1, 1, n, id[top[u]], id[u], d);
        u = fa[top[u]];
    }
    if (dep[u] < dep[v]) swap(u, v);
    update(1, 1, n, id[v], id[u], d);
}

// 树链剖分：子树查询
ll query_tree(int u) {
    return query(1, 1, n, id[u], id[u] + siz[u] - 1);
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        u++, v++; // 节点编号从1开始
        add_edge(u, v);
        add_edge(v, u);
    }
    
    // 树链剖分预处理
    dfs1(1, 0);
    dfs2(1, 1);
    build(1, 1, n);
    
    scanf("%d", &q);
    while (q--) {
        char op;
        int u, v;
        ll d;
        scanf(" %c", &op);
        if (op == 'A') {
            scanf("%d%d%lld", &u, &v, &d);
            u++, v++; // 节点编号从1开始
            update_path(u, v, d);
        } else {
            scanf("%d", &u);
            u++;
            printf("%lld\n", query_tree(u));
        }
    }
    return 0;
}
```

### 算法分析
1. **树链剖分预处理**：
   - **第一次DFS**：计算节点的深度、父节点、子树大小和重儿子（$O(n)$）
   - **第二次DFS**：分配DFS序，标记链顶节点（$O(n)$）

2. **路径修改**：
   - 沿着链向上跳转，每次修改一条重链（$O(\log^2 n)$）
   - 转化为线段树上的区间修改（$O(\log n)$）

3. **子树查询**：
   - 直接查询DFS序上的连续区间（$O(\log n)$）

4. **空间复杂度**：$O(n)$
5. **时间复杂度**：
   - 预处理：$O(n)$
   - 查询/修改：$O(\log^2 n)$

### 总结
本题是树链剖分的经典应用，通过两次DFS将树结构转化为线性序列，并利用线段树高效处理路径修改和子树查询。算法设计巧妙地将树上的复杂操作转化为序列上的区间操作，大幅提升了处理效率。

---
处理用时：101.37秒
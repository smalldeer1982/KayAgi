# 题目信息

# [SHOI2012] 信用卡凸包

## 题目背景

SHOI2012D1T2


## 题目描述

信用卡是一个矩形，唯四个角作了圆滑处理，使它们都是与矩形的两边相切的 1/4 圆，如下图所示。现在平面上有一些规格相同的信用卡，试求其凸包的周长。注意凸包未必是多边形，因为它可能包含若干段圆弧。

 ![](https://cdn.luogu.com.cn/upload/pic/6549.png) 



## 说明/提示

样例1说明： ![](https://cdn.luogu.com.cn/upload/pic/6550.png)

本样例中的 2 张信用卡的轮廓在上图中用实线标出，如果视 1.5707963268为pi/2，那么凸包的周长为16+4sqrt(2)

样例2说明： ![](https://cdn.luogu.com.cn/upload/pic/6551.png)

样例3说明： ![](https://cdn.luogu.com.cn/upload/pic/6552.png)

其凸包的周长约为41.628267652。


本题可能需要使用数学库中的三角函数。不熟悉使用方法的选手，可以参考下面的程序及其输出结果：

```cpp
uses math;
const Pi = 3.141592653589793;
begin
writeln(sin(30.0 / 180.0 * Pi) : 0 : 10);
writeln(cos(60.0 / 180.0 * Pi) : 0 : 10);
writeln(tan(45.0 / 180.0 * Pi) : 0 : 10);
writeln(arcsin(1.0) : 0 : 10);
writeln(arccos(0.0) : 0 : 10);
writeln(arctan(1.0) : 0 : 10);
end.
```
```cpp
#include <iostream>
#include <math.h>
using namespace std;
const double Pi = 3.141592653589793;
int main()
{
cout.setf(ios::fixed);
cout.precision(10);
cout<<sin(30.0 / 180.0 * Pi)<<endl;
cout<<cos(60.0 / 180.0 * Pi)<<endl;
cout<<tan(45.0 / 180.0 * Pi)<<endl;
cout<<asin(1.0)<<endl;
cout<<acos(0.0)<<endl;
cout<<atan(1.0)<<endl;
return 0;
}
```
输出结果：0.5000000000

0.5000000000

1.0000000000

1.5707963268

1.5707963268

0.7853981634


数据范围：

 ![](https://cdn.luogu.com.cn/upload/pic/6553.png) 

![](https://cdn.luogu.com.cn/upload/pic/6554.png)


## 样例 #1

### 输入

```
2
6.0 2.0 0.0
0.0 0.0 0.0
2.0 -2.0 1.5707963268```

### 输出

```
21.66```

## 样例 #2

### 输入

```
3
6.0 6.0 1.0
4.0 4.0 0.0
0.0 8.0 0.0
0.0 0.0 0.0```

### 输出

```
41.60```

## 样例 #3

### 输入

```
3
6.0 6.0 1.0
4.0 4.0 0.1745329252
0.0 8.0 0.3490658504
0.0 0.0 0.5235987756```

### 输出

```
41.63```

# AI分析结果

---
# 💡 Kay的C++算法解析：[SHOI2012]信用卡凸包 深入学习指南 💡

<introduction>
  今天我们来一起分析「SHOI2012信用卡凸包」这道经典的C++几何题。它看似是处理带圆角的矩形，但核心是**二维凸包**的灵活应用——学会“把复杂问题变简单”是解题的关键！本指南会帮你梳理思路、掌握转化技巧，还能通过像素动画直观看到算法运行哦~
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`二维凸包` + `几何转化`

🗣️ **初步分析**：
> 解决这道题的关键，是把“带圆角的矩形凸包”转化为“普通点集的凸包”。先想一个比喻：如果把每个信用卡的四个圆角看成**四个小硬币**（1/4圆），那么要围起所有信用卡，相当于要围起这些硬币的“中心”，再把硬币边缘的圆弧连起来。而所有圆弧加起来刚好是**一整个圆**（就像四个1/4蛋糕拼成一个完整蛋糕）！  
> 具体来说：
> 1. **转化问题**：每个信用卡的四个圆角的圆心，是矩形的角向内“缩”一个半径后的点（还要考虑旋转后的坐标）。把这些圆心收集起来，求它们的**二维凸包**（用“橡皮筋箍点”的思路）。
> 2. **计算周长**：凸包的边长总和 + 一个完整圆的周长（2πr）就是答案。  
> 核心难点是**如何正确计算圆心坐标**（旋转变换）和**理解圆弧总和为整圆**（凸多边形外角和360°）。  
> 可视化设计思路：用像素点代表圆心，用“橡皮筋生长”动画展示凸包构建过程——每加入一个点，橡皮筋会调整形状；最后用“旋转的像素圆”表示圆弧部分，配合“叮”的音效强调关键步骤。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、技巧启发性三个角度，筛选了4份优质题解。它们各有亮点，能帮你全面理解问题！
</eval_intro>

**题解一：(来源：ShineEternal，洛谷日报节选)**
* **点评**：这份题解的最大亮点是**用画图拆解转化过程**——把带圆角的凸包拆成“圆心凸包+整圆”，让抽象问题变直观。它从“r=0（矩形）”的简单情况切入，逐步推导到一般情况，逻辑顺理成章。对于“为什么圆弧总和是整圆”，用“四个1/4圆拼接”的例子直接说明，非常适合入门理解。

**题解二：(来源：刘辰雨)**
* **点评**：这是一份“踩坑指南”式题解！作者分享了自己遇到的“玄学错误”——比如`a[i++]`的数组调用问题、`n<2`的边界条件处理，这些都是新手常犯的错误。它提醒我们：**代码细节和边界条件是AC的关键**。此外，作者用“小蚂蚁绕圈”的比喻解释圆弧总和（方向不变，转了360°），非常生动。

**题解三：(来源：pantw)**
* **点评**：这份题解的代码**简洁规范**，是“模板化实现”的典范。它用结构体`P`封装点，重载运算符简化计算，旋转函数`rotate`的实现清晰易懂。代码中“先旋转再平移”的坐标变换逻辑，完美对应几何转化的思路，适合直接参考编写代码。

**题解四：(来源：BackSlashDelta)**
* **点评**：这份题解的**转化分析最系统**——从“抽离圆角”到“旋转坐标”，每一步都有几何推导。它详细解释了“平移坐标系→旋转→平移回去”的步骤，帮你彻底搞懂圆心坐标的计算。此外，代码中用`long double`处理精度问题，是应对几何题的实用技巧。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题，你可能会卡在三个关键点上。结合优质题解的经验，我们逐一突破：
</difficulty_intro>

1.  **关键点1：如何计算旋转后的圆心坐标？**
    * **分析**：每个信用卡的圆心是矩形角向内缩r后的点，但信用卡可能旋转了θ角。计算方法是：先把“缩后的点”（相对于信用卡中心）绕原点旋转θ，再加上信用卡的中心坐标。例如，一个缩后的点是`(a-r, b-r)`（a、b是矩形半长半宽），旋转θ后的坐标是`( (a-r)cosθ - (b-r)sinθ, (a-r)sinθ + (b-r)cosθ )`，再加上信用卡中心`(x,y)`就是最终圆心。
    * 💡 **学习笔记**：旋转坐标的公式是核心——记住“绕原点旋转θ，(x,y)→(xcosθ-ysinθ, xsinθ+ycosθ)”。

2.  **关键点2：为什么圆弧总和是一个整圆？**
    * **分析**：凸包是凸多边形，其外角和为360°（就像绕凸多边形走一圈，方向改变的总和是一圈）。每个圆弧对应的圆心角等于凸多边形的外角，所以所有圆弧加起来刚好是360°，即一个整圆的周长（2πr）。
    * 💡 **学习笔记**：凸多边形外角和恒为360°——这是几何中的“常识”，但能用到这里解决问题，才是真的理解！

3.  **关键点3：如何正确实现二维凸包模板？**
    * **分析**：二维凸包的经典实现是Graham扫描法：① 按x坐标排序（x相同按y）；② 用栈维护下凸壳（从左到右）；③ 再维护上凸壳（从右到左）。关键是用**叉积**判断点的位置：叉积>0表示点在向量左侧，需要保留；≤0表示点在右侧或共线，需要弹出栈顶。
    * 💡 **学习笔记**：叉积是凸包的“裁判”——它能帮你判断点是否在凸包的“外侧”。

### ✨ 解题技巧总结
<summary_best_practices>
通过本题，我总结了3个通用技巧，帮你举一反三：
</summary_best_practices>
-   **技巧1：问题转化**：把复杂的“带圆角的凸包”转化为“点集的凸包+整圆”，学会“抽象问题本质”。
-   **技巧2：模板复用**：二维凸包是几何题的基础模板，要熟练掌握Graham扫描法的实现。
-   **技巧3：精度处理**：几何题中用`double`或`long double`代替`int`，避免精度丢失；必要时加`eps`（如1e-12）处理浮点数比较。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解的通用核心代码**，它涵盖了“圆心计算→凸包构建→周长计算”的完整流程，逻辑清晰易懂。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了pantw、BackSlashDelta等题解的思路，用简洁的结构实现核心逻辑，适合新手参考。
* **完整核心代码**：
    ```cpp
    #include <algorithm>
    #include <cstdio>
    #include <cmath>
    #define eps 1e-12
    #define maxm 400010
    using namespace std;
    const double PI = acos(-1);

    struct P {
        double x, y;
        P(double x = 0.0, double y = 0.0) : x(x), y(y) {}
    };
    P operator+(P a, P b) { return P(a.x + b.x, a.y + b.y); }
    P operator-(P a, P b) { return P(a.x - b.x, a.y - b.y); }
    P operator*(P a, double b) { return P(a.x * b, a.y * b); }
    bool operator<(const P& a, const P& b) { return a.x == b.x ? a.y < b.y : a.x < b.x; }
    double cross(P a, P b) { return a.x * b.y - a.y * b.x; } // 叉积
    double abs(P a) { return sqrt(a.x * a.x + a.y * a.y); }   // 向量长度

    P rotate(P a, double t) { // 绕原点旋转t弧度
        double c = cos(t), s = sin(t);
        return P(a.x * c - a.y * s, a.x * s + a.y * c);
    }

    int q[maxm]; // 凸包栈
    P p[maxm];   // 圆心点集

    int main() {
        int n, c = 0;
        double a, b, r, x, y, t;
        scanf("%d%lf%lf%lf", &n, &b, &a, &r);
        a /= 2.0, b /= 2.0; // 半长半宽
        for (int i = 1; i <= n; i++) {
            scanf("%lf%lf%lf", &x, &y, &t);
            P center(x, y);
            // 计算四个圆心（缩r后旋转t，再加中心）
            p[++c] = rotate(P(a - r, b - r), t) + center;
            p[++c] = rotate(P(r - a, b - r), t) + center;
            p[++c] = rotate(P(r - a, r - b), t) + center;
            p[++c] = rotate(P(a - r, r - b), t) + center;
        }
        // 构建凸包（Graham扫描法）
        sort(p + 1, p + c + 1);
        int T = 0;
        for (int i = 1; i <= c; i++) { // 下凸壳
            while (T > 1 && cross(p[q[T-1]] - p[q[T-2]], p[i] - p[q[T-2]]) <= eps) T--;
            q[++T] = i;
        }
        int tmp = T;
        for (int i = c - 1; i >= 1; i--) { // 上凸壳
            while (T > tmp && cross(p[q[T-1]] - p[q[T-2]], p[i] - p[q[T-2]]) <= eps) T--;
            q[++T] = i;
        }
        // 计算周长：凸包边长 + 整圆周长
        double ans = 2 * PI * r;
        for (int i = 1; i < T; i++) ans += abs(p[q[i]] - p[q[i+1]]);
        printf("%.2lf\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分三步：① 读入数据，计算每个信用卡的四个圆心（缩r→旋转→加中心）；② 用Graham扫描法构建凸包（排序→下凸壳→上凸壳）；③ 计算凸包边长总和，加上整圆周长，输出结果。

---
<code_intro_selected>
接下来剖析优质题解中的**关键代码片段**，看它们如何解决核心问题：
</code_intro_selected>

**题解三：(来源：pantw)**
* **亮点**：用结构体和运算符重载简化几何计算，代码可读性高。
* **核心代码片段**（旋转函数与凸包构建）：
    ```cpp
    P rotate(P a, double t) { // 绕原点旋转t弧度
        double c = cos(t), s = sin(t);
        return P(a.x * c - a.y * s, a.x * s + a.y * c);
    }
    // 构建下凸壳
    for (int i = 1; i <= c; i++) {
        while (T > 1 && cross(p[q[T-1]] - p[q[T-2]], p[i] - p[q[T-2]]) <= eps) T--;
        q[++T] = i;
    }
    ```
* **代码解读**：
    > 1. `rotate`函数：实现绕原点旋转的公式——记住“x'=xcosθ-ysinθ，y'=xsinθ+ycosθ”，这里的`t`是弧度（题目输入的θ已经是弧度啦）。  
    > 2. 下凸壳构建：用栈`q`维护凸包点的索引。`cross(...)`计算叉积，如果≤eps（浮点数精度处理），说明当前点在栈顶两点的右侧，需要弹出栈顶，直到满足凸性。
* 💡 **学习笔记**：运算符重载能让几何计算更像“数学表达式”，比如`p[i] + center`直接表示点平移，非常方便！

**题解四：(来源：BackSlashDelta)**
* **亮点**：用`long double`处理精度，避免浮点数误差。
* **核心代码片段**（圆心计算）：
    ```cpp
    P rotate(point _x, point _c, num128 _rad) { // _rad是弧度
        num128 cosval = cos(_rad), sinval = sin(_rad);
        _x = _x - _c; // 平移到原点
        point _y = {_x.x * cosval - _x.y * sinval, _x.y * cosval + _x.x * sinval};
        return _y + _c; // 平移回去
    }
    ```
* **代码解读**：
    > 这段代码更明确地展示了“平移→旋转→平移”的过程：先把点`_x`相对于中心`_c`平移到原点（`_x - _c`），旋转后再平移回去（`_y + _c`）。用`num128`（即`long double`）能提高精度，避免计算误差。
* 💡 **学习笔记**：几何题中，精度是“隐形杀手”——如果答案总是差一点，试试用`long double`代替`double`！

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“亲眼看到”凸包的构建过程，我设计了一个**8位像素风格的动画**，像玩红白机游戏一样学习算法！
</visualization_intro>

### 动画设计方案
#### ① 整体风格
- **8位像素风**：用FC红白机的色彩（比如浅蓝色背景、红色点、绿色凸包线），点用1x1像素块表示，凸包用2像素宽的线。
- **复古UI**：底部有“开始/暂停”“单步”“重置”按钮，右侧有“速度滑块”（1~5档），背景播放8位风格的轻快BGM（比如《超级马里奥》的小关卡音乐）。

#### ② 核心演示内容
1. **初始化**：屏幕上显示多个像素点（代表圆心），每个点旁边标注坐标（比如“(2,3)”）。信用卡的中心用“小房子”像素图标表示，圆角用“小圆圈”表示。
2. **排序过程**：点按x坐标从小到大排列，排序时每个点会“闪烁”，并伴随“滴答”声。
3. **下凸壳构建**：用绿色线逐步连接点，形成下凸壳。每加入一个点，线会“生长”（从栈顶点延伸到当前点），如果需要弹出栈顶点，线会“缩回”，并伴随“叮”的音效。
4. **上凸壳构建**：用蓝色线构建上凸壳，过程同下凸壳，但方向从右到左。
5. **结果展示**：最终凸包用黄色线高亮，所有圆弧部分用“旋转的像素圆”表示（绕凸包一周），并播放“胜利音效”（比如《魂斗罗》的通关声）。

#### ③ 交互设计
- **单步执行**：点击“单步”按钮，动画执行一步（比如排序一个点、加入一个凸包点），同时右侧显示当前步骤的**伪代码**（比如“处理点(5,4)，加入下凸壳”）。
- **自动播放**：拖动速度滑块调整播放速度，最快5档（每秒10步），最慢1档（每秒1步）。
- **重置动画**：点击“重置”，所有点回到初始位置，重新开始演示。

#### ④ 设计理由
- **像素风格**：唤起复古游戏的回忆，降低学习的“距离感”；
- **音效反馈**：用声音强化关键步骤（比如“叮”代表加入凸包，“滴答”代表排序），帮助记忆；
- **伪代码同步**：让你看到“代码逻辑”和“动画效果”的对应关系，彻底理解每一步。

<visualization_conclusion>
通过这个动画，你能清楚看到“点排序→凸壳生长→圆弧拼接”的全过程，就像玩游戏一样掌握算法！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
二维凸包是几何题的“基础工具”，学会它能解决很多类似问题。比如：
</similar_problems_intro>

### 通用思路迁移
二维凸包可以解决**“用最小的凸图形包围点集”**的问题，比如：
1. 求多个矩形的最小包围凸多边形；
2. 求多个圆的最小包围凸多边形（类似本题）；
3. 求平面上最远点对（凸包上的点对）。

### 洛谷练习推荐
1.  **洛谷 P2742** - [【模板】二维凸包](https://www.luogu.com.cn/problem/P2742)
   * 🗣️ **推荐理由**：最基础的凸包模板题，帮你熟练掌握Graham扫描法的实现。
2.  **洛谷 P1113** - [Wall](https://www.luogu.com.cn/problem/P1113)
   * 🗣️ **推荐理由**：本题的“孪生兄弟”——求绕墙的最小围栏长度，思路是“点集凸包+圆周长”。
3.  **洛谷 P3187** - [HNOI2007]最小矩形覆盖
   * 🗣️ **推荐理由**：在凸包的基础上，求覆盖点集的最小矩形，需要用到凸包的旋转卡壳技巧，拓展思维。
4.  **洛谷 P4166** - [SCOI2007]最大土地面积
   * 🗣️ **推荐理由**：求凸包上的最大四边形面积，需要用到凸包的性质，强化对凸包的理解。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“踩坑经验”是最宝贵的！比如：
</insights_intro>

> **参考经验 (来自刘辰雨)**：“我最初用`a[i++]`调用数组下标，导致逻辑错误；后来拆成`a[i]; i++`就好了。还有，判断`n<2`时要考虑信用卡的数量（每个信用卡有4个点），否则会RE。”
>
> **点评**：这两个错误都是新手常犯的——① 复合操作符（如`i++`）的执行顺序容易混淆；② 边界条件没考虑“每个信用卡贡献4个点”。解决方法是：**复杂操作拆成两步**，**边界条件要结合问题实际**（比如本题`n`是信用卡数量，点的数量是`4n`）。

> **参考经验 (来自pantw)**：“几何题中用`eps`处理浮点数比较，比如`cross(...) <= eps`而不是`==0`，否则会因为精度问题出错。”
>
> **点评**：浮点数的“相等”是近似的——比如`0.1+0.2`不等于`0.3`（因为二进制存储误差）。用`eps`（比如1e-12）判断“足够接近”，能避免这种错误。

---

<conclusion>
这道题的核心是**“转化”**——把带圆角的复杂问题转化为点集的凸包问题。学会这种“化繁为简”的思维，你能解决更多几何题！记住：二维凸包是工具，转化思路是灵魂。多练模板题，多思考转化，你会越来越厉害的~ 💪
</conclusion>

---

---
处理用时：207.17秒
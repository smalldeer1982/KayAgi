# 题目信息

# [COCI 2020/2021 #5] Planine

## 题目描述

现有一座上下起伏的山。它可以抽象为一个包含 $n$（$n$ 为奇数）个点 $(x_i,y_i)$ 以及 $(x_1,-\inf)$ 与 $(x_n,-\inf)$ 的多边形。

对于所有满足 $i \neq 1$，$i \neq n$，$i \bmod 2=1$ 的整数 $i$，$(x_i,y_i)$ 都是山谷。

现要放置若干个高度为 $h$ 的点光源，使得所有的山谷都被照亮，即点光源与山谷的连线不经过山的内部。

求所需点光源的最少数量。

## 说明/提示

#### 样例 1 图解

![](https://cdn.luogu.com.cn/upload/image_hosting/6u2zqy65.png)

#### 样例 2 图解

![](https://cdn.luogu.com.cn/upload/image_hosting/e3mn6dt6.png)

#### 数据规模与约定

**本题采用捆绑测试**。

|Subtask|分值|数据范围及约定|
| :----------: | :----------: | :----------: |
|$1$|$20$|$y_2=y_4=\cdots=y_{n-1}$|
|$2$|$30$|$3 \le n \lt 2000$|
|$3$|$60$|无|

对于 $100\%$ 的数据，$3 \le n \lt 10^6$，$n \bmod 2=1$，$1 \le h \le 10^6$，$-10^6 \le x_i \le 10^6$，$0 \le y_i \lt h$，$x_1 \lt x_2 \lt \cdots \lt x_n$，$y_1 \lt y_2,y_2 \gt y_3,y_3 \lt y_4,\cdots,y_{n-1} \gt y_n$。

#### 说明

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2020-2021](https://hsin.hr/coci/) [CONTEST #5](https://hsin.hr/coci/contest5_tasks.pdf)  _T4 Planine_。**

## 样例 #1

### 输入

```
9 6
0 0
1 2
3 0
6 3
8 1
9 2
11 1
12 4
14 0```

### 输出

```
1```

## 样例 #2

### 输入

```
9 5
-5 2
-4 3
-2 1
0 4
2 2
3 3
4 1
5 2
6 1```

### 输出

```
2```

# AI分析结果

# 💡 Kay的C++算法解析：Planine 深入学习指南 💡

[introduction]
今天我们来一起分析COCI的经典题目“Planine”（山峰与山谷）。这道题像一场“山上的灯光游戏”——我们要在山顶上方放最少的灯，让所有山谷都被照亮！本指南会帮你拆解问题、理解核心算法，还会用像素动画让你“亲眼看见”算法运行~


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`贪心算法（区间覆盖） + 单调栈维护凸包`

🗣️ **初步分析**：
解决这道题的关键，是把“灯光覆盖山谷”转化为**“用最少的点覆盖区间”**——这是贪心算法的经典问题！而难点在于，如何计算每个山谷能被哪些灯光照亮（也就是对应的区间），这需要用**单调栈维护凸包**来处理山的遮挡。

### 算法比喻时间！
- **贪心区间覆盖**：像给一排房间装灯，每个灯能照一段房间。要装最少的灯，就得选“能照到当前最右未亮房间”的灯的最右端——这样一盏灯能覆盖最多房间！
- **单调栈维护凸包**：像整理书架上的书，把挡住后面书的“矮书”拿走，只留下“能挡住视线”的高书。这样我们就能快速找到“挡住山谷的那座山”！

### 题解核心思路
1. **计算每个山谷的照亮区间**：每个山谷对应y=h（灯光高度）上的一段区间——如果灯光在这个区间里，就能照亮山谷（连线不穿山体）。
2. **处理遮挡**：用单调栈正向扫一遍（算区间左端点）、反向扫一遍（算区间右端点），维护“上凸包”——只有凸包上的山会遮挡山谷。
3. **贪心覆盖区间**：把所有区间按右端点排序，每次选最右的点覆盖尽可能多的区间，统计最少点数。

### 可视化设计思路
我们会用**8位像素风**（像FC游戏）展示：
- 山的点用不同颜色的像素块（山谷是蓝色，山峰是棕色）；
- 单调栈用右侧的像素堆（栈顶闪烁），加入新点时弹出不符合条件的点（“咻”地消失）；
- 每个山谷的区间用y=h的黄色线段表示；
- 贪心选点时，选中的点会“眨眼睛”（闪烁），覆盖的区间变成绿色。
- 音效：栈操作“叮”，区间生成“滴”，选点“咚”，完成时播放8位胜利曲！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和算法有效性出发，选了3份优质题解——它们各有亮点，能帮你从不同角度理解问题！
</eval_intro>

**题解一：入户功夫（赞12）**
* **点评**：这份题解像“算法模板”一样标准！它用单调栈完美维护了凸包，`slope`函数计算斜率、`init`函数处理左右端点的逻辑非常清晰。代码里的`e`数组存区间，排序后贪心的部分简洁到“一眼看懂”。最棒的是它处理大数据的效率——O(n logn)的时间复杂度能轻松应对1e6的数据，竞赛里直接用也没问题！

**题解二：Figo17（赞7）**
* **点评**：这份题解像“斜率优化小老师”！它详细解释了“为什么凸包能处理遮挡”——用“斜率最小的山挡住山谷”的思路，帮你理解单调栈的原理。代码里的`Push`函数和`K`函数（算斜率）写得很直观，还加了“特判n=3”的小细节，考虑很周全~ 唯一小遗憾是注释少了点，但思路绝对正确！

**题解三：JimmyLee（赞1）**
* **点评**：这份题解像“逻辑清晰的笔记”！它用`vector`模拟栈（`s`数组），`back`函数直接取栈顶两个点的斜率，逻辑比用数组栈更易读。处理凸包的条件判断（`back()<=slope(...)`）写得很准确，最后用`auto`遍历区间的部分也很现代。如果你刚开始学单调栈，这份代码会让你更容易上手！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在三个地方——别慌，我们一个个拆！
</difficulty_intro>

1. **难点1：怎么算山谷的照亮区间？**
    * **分析**：山谷的照亮区间是y=h上的线段，左端点由“左侧能挡住它的最右山峰”决定，右端点由“右侧能挡住它的最左山峰”决定。这些山峰都在**上凸包**上——凸包外的山不会遮挡（因为被凸包上的山挡住了）！
    * 💡 **学习笔记**：凸包是“能挡住所有内部点的轮廓”，找遮挡只需要看凸包！

2. **难点2：怎么用单调栈维护凸包？**
    * **分析**：单调栈的核心是“保持栈内点的斜率单调”——比如正向扫的时候，栈内点的斜率要**递增**（否则弹出栈顶）。这样栈顶两个点的连线就是“能挡住当前山谷的边”！
    * 💡 **学习笔记**：单调栈的“单调”是指**斜率的变化趋势**，不是点的坐标！

3. **难点3：怎么用最少的点覆盖区间？**
    * **分析**：经典贪心策略——按区间右端点排序，每次选当前未覆盖区间的最右端点。这样选的点能覆盖最多的后续区间，保证数量最少！
    * 💡 **学习笔记**：区间覆盖的关键是“排序依据”——右端点小的先处理，选最右点！

### ✨ 解题技巧总结
- **问题转化**：把“灯光照亮山谷”转化为“区间覆盖”，这是解决复杂问题的常用技巧！
- **单调栈**：处理“遮挡”“最优决策”问题时，单调栈是“神器”——它能把O(n²)的时间降到O(n)！
- **贪心排序**：区间覆盖问题的“黄金法则”——按右端点排序，选最右点！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份综合了三个题解优点的**通用核心代码**——它能完整解决问题，逻辑清晰！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了“入户功夫”的简洁、“JimmyLee”的易读，保留了核心逻辑，适合入门学习。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

typedef long double f64;
const int MAXN = 1e6 + 5;

struct Dot { int x, y; } ds[MAXN];
struct Seg { f64 l, r; bool operator<(const Seg& s) const { return r < s.r; } };

vector<int> stk;
Seg segs[MAXN];
int n, h, cnt;

f64 slope(const Dot& a, const Dot& b) {
    return (f64)(a.y - b.y) / (a.x - b.x);
}

void get_left() {
    stk.clear();
    stk.push_back(1);
    for (int i = 2; i <= n; ++i) {
        while (stk.size() > 1) {
            int last1 = stk[stk.size()-1];
            int last2 = stk[stk.size()-2];
            if (slope(ds[last1], ds[last2]) <= slope(ds[i], ds[last1]))
                stk.pop_back();
            else break;
        }
        if (i % 2 == 1 && i != 1 && i != n) { // 山谷
            int k = stk[stk.size()-1];
            f64 k_slope = slope(ds[i], ds[k]);
            f64 b = ds[i].y - k_slope * ds[i].x;
            segs[++cnt].l = (h - b) / k_slope;
        }
        stk.push_back(i);
    }
}

void get_right() {
    stk.clear();
    stk.push_back(n);
    for (int i = n-1; i >= 1; --i) {
        while (stk.size() > 1) {
            int last1 = stk[stk.size()-1];
            int last2 = stk[stk.size()-2];
            if (slope(ds[last2], ds[last1]) >= slope(ds[last1], ds[i]))
                stk.pop_back();
            else break;
        }
        if (i % 2 == 1 && i != 1 && i != n) { // 山谷
            int k = stk[stk.size()-1];
            f64 k_slope = slope(ds[i], ds[k]);
            f64 b = ds[i].y - k_slope * ds[i].x;
            segs[cnt--].r = (h - b) / k_slope;
        }
        stk.push_back(i);
    }
}

int main() {
    cin >> n >> h;
    for (int i = 1; i <= n; ++i) {
        cin >> ds[i].x >> ds[i].y;
    }
    get_left();
    cnt = (n + 1) / 2 - 2; // 山谷数量：(n-2)/2（i从3到n-1，步长2）
    get_right();
    
    sort(segs + 1, segs + 1 + cnt);
    f64 last_r = -1e18;
    int ans = 0;
    for (int i = 1; i <= cnt; ++i) {
        if (segs[i].l > last_r + 1e-8) { // 避免浮点误差
            ans++;
            last_r = segs[i].r;
        }
    }
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：
  1. `slope`函数计算两点斜率；
  2. `get_left`用单调栈正向扫，算每个山谷的区间左端点；
  3. `get_right`用单调栈反向扫，算区间右端点；
  4. 排序区间后，贪心选点覆盖，统计答案。


<code_intro_selected>
接下来看三个题解的**核心片段**，学它们的“巧思”！
</code_intro_selected>

**题解一：入户功夫（来源）**
* **亮点**：用数组栈实现单调栈，速度快，适合大数据！
* **核心代码片段**：
```cpp
inline double slope(int j,int k) { return (y[j]-y[k])/(x[j]-x[k]); }
inline void init() {
    stck[top=1]=1;
    for(int i=2;i<=n;i++) {
        while(top>1&&slope(stck[top],stck[top-1])<slope(i,stck[top])) top--;
        if(i%2) l[i]=x[stck[top]]-(x[i]-x[stck[top]])/(y[stck[top]]-y[i])*(h-y[stck[top]]);
        stck[++top]=i;
    }
    // 反向同理...
}
```
* **代码解读**：
  - `stck`数组是栈，`top`是栈顶指针；
  - 循环中，只要栈顶两个点的斜率小于当前点与栈顶的斜率，就弹出栈顶（保持凸包）；
  - 山谷的左端点`l[i]`用几何公式计算：从栈顶山的点，延长到y=h的x坐标。
* 💡 **学习笔记**：数组栈比vector快，竞赛中处理1e6数据时优先用数组！

**题解二：Figo17（来源）**
* **亮点**：用`Push`函数封装栈操作，逻辑更直观！
* **核心代码片段**：
```cpp
void Push(int x){s[++top]=(poi){a[x].x,a[x].y};}
double K(poi x,poi y){return 1.0*(x.y-y.y)/(x.x-y.x);}
// 正向处理山峰：
else { // 山峰
    if(!top) {Push(i);continue;}
    if(top==1){
        if(a[i].y>=s[top].y) top--;
        Push(i);continue;
    }
    double k1,k2;
    while(top>=2){
        k1=K(a[i],s[top]); k2=K(a[i],s[top-1]); top--;
        if(k1<k2) {top++;break;}
    }
    Push(i);
}
```
* **代码解读**：
  - `Push`函数把点加入栈；
  - 处理山峰时，先检查栈是否为空，再检查栈顶是否比当前山峰矮（矮的话弹出）；
  - 用`k1`和`k2`比较斜率，保持栈内斜率单调。
* 💡 **学习笔记**：封装函数能让代码更易读，尤其是重复操作！

**题解三：JimmyLee（来源）**
* **亮点**：用`vector`的`rbegin()`取栈顶，逻辑更清晰！
* **核心代码片段**：
```cpp
vector<int> s;
#define back() slope(ds[*s.rbegin()], ds[*(s.rbegin()+1)])
// 正向处理：
while(s.size()>1&&back()<=slope(ds[s.back()], ds[i])) 
    s.pop_back();
s.emplace_back(i);
if(chk(i)) {
    f64_t k=back();
    f64_t b=ds[i].y-k*ds[i].x;
    seg[i].l=(h-b)/k;
}
```
* **代码解读**：
  - `s`是vector模拟的栈，`rbegin()`取反向迭代器（栈顶）；
  - `back()`宏直接计算栈顶两个点的斜率，避免重复写代码；
  - 用`chk(i)`判断是否是山谷，逻辑更简洁。
* 💡 **学习笔记**：vector的反向迭代器能让栈操作更直观，适合初学者！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们设计了一个**8位像素风的“山上点灯游戏”**，让你亲眼看见算法运行！像玩FC游戏一样，你能看到单调栈的变化、区间的生成，还有贪心选点的过程~
</visualization_intro>

### 动画演示主题
**像素登山者的“点灯任务”**：你是一个像素小人，要在y=h的山顶放最少的灯，照亮所有蓝色的山谷。

### 设计思路简述
- **风格**：用FC红白机的8位色（比如山是棕色，山谷是蓝色，灯光是黄色），界面像《超级马里奥》的关卡；
- **交互**：有“单步”“自动”按钮，速度滑块（慢/中/快），重置按钮；
- **趣味**：每完成一个单调栈操作，播放“叮”的音效；生成区间时播放“滴”；选点时播放“咚”；全部照亮时播放8位胜利曲！

### 动画帧步骤（关键）
1. **初始化场景**：
   - 屏幕左侧是像素山（用不同颜色的方块表示点：山峰棕色，山谷蓝色，x轴从左到右递增）；
   - 右侧是“栈区”（用绿色方块堆叠，显示当前栈里的点）；
   - 顶部是“灯光区”（y=h的黄色横线，用来显示区间）。

2. **单调栈正向扫（算左端点）**：
   - 像素小人从左到右走，每到一个点，检查栈区：
     - 如果栈里有≥2个点，计算斜率——如果不符合单调，栈顶的绿色方块“咻”地消失（弹出）；
     - 把当前点加入栈（栈区加一个绿色方块）；
     - 如果是山谷，灯光区会出现一段黄色线段（左端点），伴随“滴”声。

3. **单调栈反向扫（算右端点）**：
   - 像素小人从右到左走，重复正向的过程，灯光区的线段会延长到右端点（变成完整的黄色线段）。

4. **贪心选点覆盖**：
   - 所有线段按右端点排序（灯光区的线段会“排好队”）；
   - 像素小人从左到右选点：选第一个线段的右端点（黄色点闪烁），覆盖的线段变成绿色，伴随“咚”声；
   - 重复直到所有线段都变绿，播放胜利曲！

### 旁白提示（文字气泡）
- “现在检查栈顶的斜率——哦，这个点挡住后面了，得删掉！”（弹出栈顶时）；
- “这个山谷的左端点在这里~”（生成左端点时）；
- “选这个点！它能覆盖最多线段！”（选点时）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了“区间覆盖+单调栈”，你可以解决很多类似问题！比如“安排活动”“找最长递增子序列”“计算凸包”~
</similar_problems_intro>

### 通用思路迁移
- **区间覆盖**：比如“安排最少的教室”“选最多的不重叠区间”；
- **单调栈**：比如“找下一个更大的元素”“计算直方图的最大矩形”；
- **凸包**：比如“计算平面点集的凸包”“最远点对”。

### 洛谷练习推荐
1. **洛谷 P1803** - 线段覆盖
   * 🗣️ **推荐理由**：经典的区间覆盖问题，直接练贪心的“按右端点排序”技巧！
2. **洛谷 P5788** - 【模板】单调栈
   * 🗣️ **推荐理由**：单调栈的基础模板题，帮你巩固“维护单调序列”的思路！
3. **洛谷 P3829** - 【模板】凸包
   * 🗣️ **推荐理由**：计算凸包的模板题，和本题的“凸包维护”思路一致！
4. **洛谷 P4322** - 最佳课题选择
   * 🗣️ **推荐理由**：单调栈优化动态规划的问题，拓展你的单调栈应用能力！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
三个题解的作者都分享了“踩坑”经验，比如：
</insights_intro>

> **参考经验（来自入户功夫）**：“一开始我没考虑浮点误差，比如比较`lst<e[i].l`时直接用`>`，结果卡了样例。后来加了`1e-8`的误差范围才过！”
>
> **点评**：浮点运算的误差是编程中的“隐形坑”！比如本题中的区间端点是浮点数，比较时要加一个小的epsilon（比如1e-8），避免因为精度问题出错~

> **参考经验（来自Figo17）**：“我一开始用`double`存斜率，后来发现`long double`的精度更高，能处理更大的数据！”
>
> **点评**：处理大数据时，`long double`比`double`精度更高，能避免“溢出”或“精度丢失”的问题~


<conclusion>
这道题的核心是“问题转化+单调栈+贪心”——把复杂的“灯光覆盖”变成熟悉的“区间覆盖”，用单调栈处理遮挡，用贪心找最优解。记住：**编程的本质是“把问题拆成小问题，用已知的方法解决”**！

下次遇到类似的“覆盖”“遮挡”问题，试试用今天学的思路——你一定能解决！💪
</conclusion>

---
处理用时：116.86秒
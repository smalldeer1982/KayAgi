# 题目信息

# [Math×Girl] 距离

## 题目背景

>“哥哥，你说什么呢？” 尤里问道。  
>“看上去仙女座也在研究数学。”我回答道。  
>“那里也有图书室吗？”泰朵拉微笑道。  
>“以居住的星球为模，是不是存在跟我们同余的宇宙人呢？”米尔嘉说道。


## 题目描述

给你两个数 $a$ 和 $b$ ，每次可以对任意一个数 $\pm1$。  
求最少进行多少次操作，才能使 $a\mid b$ 或 $b\mid a$。

其中 $\mid$ 为整除符号，$a\mid b$ 表示 $a$ 整除 $b$。  


## 说明/提示

### 样例解释

第一个例子为 $(15+1)\mid(33-1)$。  
第二个例子为 $(34+1)\mid(2024+6)$。  

### 数据范围

| 子任务 | 分值 | 限制 |
| :----------: | :----------: | :----------: |
| $0$ | $15$ | $a,b\in[1,10^4]$ |
| $1$ | $10$ | $T\in[1,10],a,b\in[1,10^8]$ |
| $2$ | $5$ | $a,b\in[1,10^8]$ |
| $3$ | $20$ | $T\in[1,10],\frac{a}{b}\in[10^{-8},10^8]$ |
| $4$ | $5$ | $\frac{a}{b}\in[10^{-8},10^8]$ |
| $5$ | $25$ | $T\in[1,10]$ |
| $6$ | $20$ | - |

对于 $100\%$ 数据，保证 $T\in[1,1000],a,b\in[1,10^{16}]$。

本题请相信你的算法的常数。

## 样例 #1

### 输入

```
3
15 33
2024 34
1145141919810721 987654321666```

### 输出

```
2
7
388749955```

# AI分析结果

# 💡 Kay的C++算法解析：[Math×Girl] 距离 深入学习指南 💡

<introduction>
今天我们来一起分析“[Math×Girl] 距离”这道C++编程题。这道题看似需要暴力枚举，但其实藏着数学分析的小技巧——通过分情况讨论减少计算量。本指南会帮你梳理思路、掌握核心算法，还会用像素动画让你“看”到算法怎么跑！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学 + 编程技巧应用`  

🗣️ **初步分析**：  
解决这道题的关键，就像“整理玩具”——如果玩具太少（比如小数字y），我们直接一个个试怎么变；如果玩具太多（大数字y），我们就按“类别”（比如倍数k）来试。这里的“数学”核心是**分情况优化枚举**：通过分析y和√x的大小关系，把问题拆成两种场景——  
- 当y比较小（y ≤ √x）：我们枚举y可能变成的样子（y'），计算对应的x需要变多少才能被y'整除；  
- 当y比较大（y > √x）：x/y的结果肯定很小，我们直接枚举倍数k，计算对应的y需要变多少才能让x变成k倍的y。  

**核心算法流程**：  
1. 先把大的数设为x，小的设为y（比如swap(x,y)让x>y）；  
2. 看y和√x的大小：  
   - 小y：枚举y±t（t从1开始），计算每个y'对应的最小操作次数（x变到最近的k*y'，取k=floor(x/y')或ceil(x/y')）；  
   - 大y：枚举k（从x/y附近开始），计算每个k对应的最小操作次数（y变到最近的x/k或x/k+1）；  
3. 用当前找到的最优解ans剪枝——如果t超过ans，就不用再枚举了（因为再变只会更差）。  

**可视化设计思路**：  
我们会做一个“像素数学侦探”动画——屏幕上有两个像素数字块（x和y），控制面板有“单步”“自动”按钮。当枚举y'时，y块会左右移动（±t），x块会跳到最近的k*y'位置，旁边弹出“操作次数：x次”的提示；当枚举k时，k的数字会闪烁，y块会跳到最近的x/k位置。关键操作（比如找到更优解）会有“叮”的音效，最终最优解会用彩虹色高亮！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法效率和实践价值出发，筛选了3份评分≥4星的优质题解，帮你快速理解核心逻辑～
</eval_intro>

**题解一：出题人代码（来源：Naszt）**  
* **点评**：这份题解把问题拆得明明白白！用`ydis`函数计算“y变到ty时的代价”，`kdis`函数计算“k取某个值时的代价”，再用`ysolve`和`ksolve`分别处理两种情况。代码结构像“搭积木”——每个函数只做一件事，逻辑链超清晰。比如`ysolve`里用`ans`限制枚举次数，避免无用计算，非常严谨～

**题解二：验题人代码（来源：未知）**  
* **点评**：这版代码更简洁！把“计算y'代价”的函数写成`GetDistY`，“计算k代价”的写成`GetDistK`，主函数里直接分情况调用。比如`Solve`函数里先判断x%y是否为0（直接返回0），再分情况枚举，逻辑更紧凑，适合新手模仿～

**题解三：鲤鱼江代码（来源：鲤鱼江）**  
* **点评**：这版代码加了“灵魂剪枝”！比如枚举y±i时，一旦i超过当前ans就停止——这一步直接把枚举次数砍了大半！而且用`inline`修饰计算函数，速度更快。作者提到“加剪枝后从30分变最优解”，这说明**剪枝是优化枚举的关键**～


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在“如何高效枚举”——暴力枚举会超时，但用数学分析+剪枝就能解决！下面是3个核心难点和对应的破解方法：
</difficulty_intro>

1. **难点1：怎么避免暴力枚举超时？**  
   * **分析**：如果直接枚举y的所有可能变化（从1到1e16），肯定超时。但数学告诉我们：y小的时候，y的变化范围小；y大的时候，x/y的结果小（比如y=1e8，x=1e16，x/y=1e8？不对，等一下，y>√x时，x/y < y，所以k=x/y的范围很小）。  
   * **解决方案**：分情况——y≤√x时枚举y的变化，y>√x时枚举k的变化，把枚举量从“无限大”变成“√x级别”（比如x=1e16，√x=1e8？不对，等一下，题解里的分情况是y≤x/y（即y²≤x）时枚举y，否则枚举k。比如x=1e16，y=1e9，那么x/y=1e7，枚举k的范围是1e7附近，比枚举y的1e9次快多了！）  
   * 💡 **学习笔记**：分情况讨论是“用数学减少计算量”的常用技巧！

2. **难点2：怎么计算每种枚举的最小代价？**  
   * **分析**：比如枚举y'=y+t，要让x变成k*y'，k选多少？选太大会让x变很多，选太小也一样。  
   * **解决方案**：k取`x/y'`（向下取整）或`x/y' +1`（向上取整）——这两个k对应的x'=k*y'是离原x最近的，所以操作次数最少！比如x=33，y'=16（原y=15+1），x/y'=2，所以k=2时x'=32，操作次数是|33-32|+|15-16|=1+1=2，正好是样例的解～  
   * 💡 **学习笔记**：找“最近的倍数”要算上下界！

3. **难点3：怎么剪枝减少无用枚举？**  
   * **分析**：比如当前最优解是2，再枚举y+3就没必要了——因为y变3次已经超过ans了，再算只会更差。  
   * **解决方案**：用当前ans限制枚举的t（变化量）——比如枚举y±t时，t只要小于ans就够了；枚举k时，只要“y与x/k的差”小于ans就继续，否则停止。  
   * 💡 **学习笔记**：剪枝的核心是“用已知最优解排除不可能更优的情况”！


### ✨ 解题技巧总结
- **技巧A：分情况优化**：通过数学分析把大问题拆成小问题，减少枚举量；  
- **技巧B：最近倍数计算**：对每个枚举的y'或k，算上下界的倍数，取最小代价；  
- **技巧C：剪枝止损**：用当前最优解限制枚举范围，避免无用计算；  
- **技巧D：变量标准化**：先swap(x,y)让x>y，减少条件判断的复杂度！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份综合了所有优质题解思路的**通用核心代码**——结构清晰，覆盖所有情况，适合你上手练手～
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了出题人、验题人和鲤鱼江的思路，分情况枚举+剪枝，逻辑完整且高效。  
* **完整核心代码**：
```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
typedef long long ll;

ll calc_y(ll x, ll y, ll ty) {
    ll k1 = x / ty, cost1 = abs(x - k1 * ty) + abs(y - ty);
    ll k2 = k1 + 1, cost2 = abs(x - k2 * ty) + abs(y - ty);
    return min(cost1, cost2);
}

ll calc_k(ll x, ll y, ll k) {
    ll ty1 = x / k, cost1 = abs(x - k * ty1) + abs(y - ty1);
    ll ty2 = ty1 + 1, cost2 = abs(x - k * ty2) + abs(y - ty2);
    return min(cost1, cost2);
}

ll solve(ll a, ll b) {
    ll x = max(a, b), y = min(a, b);
    if (x % y == 0) return 0;
    ll ans = 1e18;
    // 情况1：y较小，枚举y的变化
    if (y * y <= x) {
        ans = calc_y(x, y, y); // 初始值：y不变
        for (ll t = 1; t < ans; ++t) {
            if (y - t >= 1) ans = min(ans, calc_y(x, y, y - t));
            ans = min(ans, calc_y(x, y, y + t));
        }
    } 
    // 情况2：y较大，枚举k的变化
    else {
        ll k0 = x / y;
        ans = calc_k(x, y, k0); // 初始值：k=k0
        for (ll t = 1; ; ++t) {
            ll k = k0 + t;
            if (y - (double)x / k >= ans) break; // 剪枝：变化量超过ans
            ans = min(ans, calc_k(x, y, k));
        }
        for (ll t = 1; ; ++t) {
            ll k = k0 - t;
            if (k < 1) break;
            if ((double)x / k - y >= ans) break; // 剪枝
            ans = min(ans, calc_k(x, y, k));
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T; cin >> T;
    while (T--) {
        ll a, b; cin >> a >> b;
        cout << solve(a, b) << '\n';
    }
    return 0;
}
```
* **代码解读概要**：  
> 1. `calc_y`函数：计算y变到ty时的最小代价（选k的上下界）；  
> 2. `calc_k`函数：计算k取某个值时的最小代价（选ty的上下界）；  
> 3. `solve`函数：先标准化x和y（x>y），再分情况枚举——y小则枚举y±t，y大则枚举k±t，用ans剪枝；  
> 4. 主函数：快速读入数据，调用solve输出结果。


---

<code_intro_selected>
下面我们拆解题解里的“精华片段”，看看高手是怎么写核心逻辑的～
</code_intro_selected>

**题解一：出题人代码（来源：Naszt）**  
* **亮点**：用函数封装不同情况的代价计算，逻辑模块化！  
* **核心代码片段**：
```cpp
i8 ydis(i8 ty){
  i8 kc=x/ty+1,xc=kc*ty,c=abs(ty-y)+abs(xc-x);
  i8 kf=x/ty  ,xf=kf*ty,f=abs(ty-y)+abs(xf-x);
  return std::min(c,f);
}
```
* **代码解读**：  
> 这个函数算的是“y变到ty时，x要变多少才能被ty整除”。比如ty是目标y'，kc是x/ty+1（向上取整），kf是x/ty（向下取整）——这两个k对应的x'是离原x最近的，所以取它们的代价最小值！  
> 举个例子：x=33，ty=16（y=15+1），kc=33/16+1=2+1=3？不对，33/16是2（整数除法），所以kc=3，xc=3*16=48，代价是|16-15|+|48-33|=1+15=16；kf=2，xf=32，代价是1+1=2——所以min(16,2)=2，正好是样例的解～  
* 💡 **学习笔记**：函数封装能让代码更整洁，重复逻辑不用写多遍！


**题解三：鲤鱼江代码（来源：鲤鱼江）**  
* **亮点**：加了“超实用剪枝”，枚举到t≥ans就停！  
* **核心代码片段**：
```cpp
ans=Calcy(y);
for(int i=1;i<ans;++i)  
  ans=min(ans,min(Calcy(y+i),Calcy(y-i)));
```
* **代码解读**：  
> 初始ans是“y不变时的代价”，然后枚举t从1到ans-1——因为如果t≥ans，y变t次的代价已经超过当前ans了，再算也不会更优！比如ans初始是5，t=5时y变5次的代价至少是5，不可能比当前ans小，所以直接停止枚举～  
> 这个剪枝直接把枚举次数从“无限”变成“ans次”，速度快了几十倍！  
* 💡 **学习笔记**：剪枝的关键是“用已知最优解限制枚举范围”！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们做了一个“像素数学侦探”动画——用8位红白机风格，让你“看”到算法怎么找最优解！超好玩～
</visualization_intro>

  * **动画演示主题**：`像素数学侦探：找整除的最小步数`  
  * **核心演示内容**：展示分情况枚举y'或k的过程，高亮关键操作，用音效提示最优解。  
  * **设计思路简述**：用8位像素风营造复古感，让学习像玩游戏；“叮”的音效强化关键操作记忆；每找到更优解就亮彩虹色，增加成就感！


### 动画帧步骤与交互关键点
1. **场景初始化（8位像素风）**：  
   * 屏幕左边是两个像素数字块（x和y），右边是“控制面板”：有“单步”“自动”“重置”按钮，速度滑块（从“慢”到“快”），还有当前最优解的显示框。  
   * 背景是FC风格的网格，播放轻松的8位BGM（比如《超级马里奥》的小关卡音乐）。

2. **算法启动：标准化x和y**：  
   * 如果a<b，两个数字块会“交换位置”（比如x从右边滑到左边），伴随“咻”的音效——提示“现在x>y啦！”。

3. **分情况枚举（核心动画）**：  
   - **情况1：y小（y≤√x）**：  
     * y块会左右移动（±t），比如t=1时，y从15变成16，块上的数字闪烁，旁边弹出“ty=16”的提示。  
     * x块会跳到最近的k*ty位置（比如33→32），块的颜色变蓝，旁边显示“k=2，x'=32”。  
     * 代价计算：显示框里弹出“代价=1+1=2”，如果比当前ans小，会有“叮”的音效，ans变成2，框子亮彩虹色！  
   - **情况2：y大（y>√x）**：  
     * k的数字（比如x/y=2）会闪烁，y块跳到最近的x/k位置（比如x=33，k=2，y→16），块的颜色变绿。  
     * 代价计算：同样弹出“代价=2”，ans更新时播放音效。

4. **剪枝演示**：  
   * 当t≥ans时，枚举会“暂停”——y块停止移动，旁边弹出“t=2≥ans=2，停止枚举！”的提示，伴随“咔嗒”的音效。

5. **结束状态**：  
   * 找到最优解后，x和y块会一起闪烁，播放“胜利”音效（比如《魂斗罗》的过关声），屏幕中央弹出“最小步数：2！”的大字，背景放烟花特效～


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“分情况枚举+剪枝”的技巧，你可以挑战这些相似问题，巩固所学！
</similar_problems_intro>

  * **通用思路迁移**：  
    本题的“分情况优化枚举”思路，还能解决**数论中的最小操作问题**（比如让两个数成倍数、成互质等），核心是“用数学分析减少计算量”！


### 洛谷相似题目推荐
1. **洛谷 P1029 最大公约数和最小公倍数问题**  
   * 🗣️ **推荐理由**：这题要找满足gcd(a,b)=x、lcm(a,b)=y的(a,b)对数，需要用数论分析（分解质因数），和本题的“数学分析”思路一致！

2. **洛谷 P1866 编号**  
   * 🗣️ **推荐理由**：这题要给牛编号，使得编号的前缀和是质数，需要枚举质数并判断，和本题的“枚举+剪枝”思路类似！

3. **洛谷 P2085 最小函数值**  
   * 🗣️ **推荐理由**：这题要找多个二次函数的最小函数值，需要用优先队列优化枚举，和本题的“优化枚举”思路一致！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
鲤鱼江的“剪枝”心得超有用，我帮你摘出来啦～
</insights_intro>

> **参考经验 (来自 鲤鱼江)**：“最开始交上去只有30分，加了个剪枝（如果i≥ans就break），直接拿下最优解！”  
> **点评**：这个经验太真实了——很多时候不是算法错了，而是没“剪枝”！比如枚举时，一旦变化量超过当前最优解，再算也没用，不如直接停。下次遇到枚举题，先想“能不能用ans剪枝”～


<conclusion>
本次关于“[Math×Girl] 距离”的分析就到这里啦！这道题的核心是**用数学分析优化枚举**，再用剪枝减少计算量。记住：编程不是“暴力试所有可能”，而是“用聪明的办法少算没用的账”～下次我们再一起玩更有趣的算法游戏！💪
</conclusion>

---
处理用时：104.07秒
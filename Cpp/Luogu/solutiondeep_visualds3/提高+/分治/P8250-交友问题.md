# 题目信息

# 交友问题

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/pu73hyh9.png)

## 题目描述

洛谷上有 $n$ 位用户，这些用户组成了一个双向的网络。

洛谷的图片分享机制如下：如果第 $i$ 个用户向他的好友 $j$ 分享了一张照片，那么，$j$ 的所有好友 $k$ 就能看到这张照片。**$j$ 也可以看到这张照片。**

现在，用户 $u_i$ 想分享一张照片，但是TA不想让用户 $v_i$ 看到这张照片。在不发送给自己的情况下，TA想知道，他最多可以发送给多少位好友？

## 说明/提示

对于 $20\%$ 的数据，满足 $1 \le n,q \le 2\times10^3$，$1\le m \le 8\times 10^3$；

对于 $60\%$ 的数据，满足 $1 \le n,q \le 2\times10^4$，$1\le m \le 5\times 10^4$；

对于 $100\%$ 的数据，满足 $1 \le n,q \le 2\times10^5$，$1\le m \le 7\times 10^5$。

**保证没有重边和自环**

## 样例 #1

### 输入

```
6 7 8
5 1
1 4
1 6
5 6
5 4
1 2
5 3
5 3
1 1
3 6
1 5
5 6
1 4
5 2
2 6```

### 输出

```
3
0
0
1
2
2
3
0```

# AI分析结果



---
# 💡 Kay的C++算法解析：交友问题 深入学习指南 💡

<introduction>
今天我们来一起分析“交友问题”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法（根号分治），并掌握解题技巧，通过像素动画直观感受算法流程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：根号分治（分块）算法

🗣️ **初步分析**：
解决“交友问题”的关键在于高效计算两个点的公共邻居数量。根号分治的核心思想是将数据分为两部分（如“大点”和“小点”），分别处理以平衡时间复杂度，就像把作业分成“简单题”和“难题”，先集中解决“简单题”，再用更高效的方法处理“难题”。

在本题中，我们按度数将点分为：
- **大点**：度数≥阈值B（如√m），数量少（≤2m/B），用bitset预处理邻居；
- **小点**：度数<B，数量多，用暴力枚举或map快速查询。

核心难点是如何避免最坏情况的高复杂度（如菊花图），解决方案是：
- 小点直接暴力枚举邻居，复杂度O(B)；
- 大点用bitset快速计算交集，复杂度O(n/w)（w为机器字长，通常64）。

可视化设计：采用8位像素风格，用不同颜色标记大点（红色方块）和小点（蓝色方块）。动画中，当处理查询(u,v)时，u的邻居（绿色方块）和v的邻居（黄色方块）会动态显示，公共邻居（闪烁的紫色方块）被高亮，同时播放“叮”的音效提示交集计算。支持单步/自动播放，控制面板显示当前处理的点和交集数量。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等，筛选出以下3篇优质题解：
</eval_intro>

**题解一：阿丑 (赞：14)**
* **点评**：此题解思路非常清晰，采用离线处理优化。通过按度数排序，统一处理相同u的询问，避免重复标记邻居。代码规范（变量名如`deg[]`、`vis[]`含义明确），利用快排去重减少冗余计算。算法上通过分块将复杂度优化至O(m√q)，实践价值高（可直接用于竞赛）。亮点是离线处理相同u的询问，将多次查询的标记操作合并，大幅减少时间。

**题解二：_determination_ (赞：7)**
* **点评**：此题解结合根号分治与bitset，分类讨论三种情况（小点-小点、大点-大点、大点-小点）。代码结构清晰（用`B=40`作为阈值），利用bitset的位运算快速计算交集。算法有效性强（时间复杂度O(qB + n/w)），关键步骤（如bitset的与运算）解释到位。亮点是合理选择阈值，平衡预处理和查询时间。

**题解三：RedLycoris (赞：5)**
* **点评**：此题解详细分类讨论，代码中明确处理了不同点类型的查询（重点-重点、重点-轻点等）。变量命名规范（如`lim`表示阈值，`heavy`存储大点），空间优化到位（仅预处理大点的bitset）。算法上通过排序动态确定阈值（`lim=deg[min(n,(int)(sqrt(n)*6))]`），适应不同数据分布。亮点是动态调整阈值，提高算法普适性。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼核心思考方向：
</difficulty_intro>

1.  **关键点1**：如何选择分块阈值B？
    * **分析**：阈值B的选择直接影响时间复杂度。若B太小，大点数量多，预处理空间大；若B太大，小点暴力枚举的时间增加。优质题解通常根据数据规模动态调整（如B=√m或B=√n），平衡预处理和查询时间。
    * 💡 **学习笔记**：阈值选择需满足“大点数量少+小点度数小”，通常取B=√m或√n。

2.  **关键点2**：如何高效计算公共邻居？
    * **分析**：小点用暴力枚举邻居+map查询（O(B)），大点用bitset位运算（O(n/w)）。例如，用`bitset&`操作快速求交集，再统计数量。
    * 💡 **学习笔记**：bitset适合处理大规模集合的快速交、并运算，是优化此类问题的利器。

3.  **关键点3**：如何处理不同点类型的查询？
    * **分析**：需分类讨论：
      - 小点-小点：暴力枚举u的邻居，检查是否是v的邻居（用map）；
      - 大点-大点：用bitset的与运算求交集；
      - 大点-小点：枚举小点的邻居，检查是否是大点的邻居（用bitset）。
    * 💡 **学习笔记**：分类讨论是分块算法的核心，需覆盖所有可能情况，避免遗漏。

### ✨ 解题技巧总结
<summary_best_practices>
- **分块思想**：将数据分为两部分，分别处理，平衡时间复杂度。
- **预处理大点**：对度数高的点预处理邻居集合（如bitset），加速查询。
- **离线处理**：合并相同u的查询，减少重复标记操作（如阿丑的题解）。
- **动态阈值**：根据数据分布调整阈值（如RedLycoris的动态`lim`），提高算法适应性。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解的通用核心实现，基于根号分治和bitset优化。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了阿丑、_determination_等题解的思路，采用根号分治，预处理大点的bitset，分类处理不同点类型的查询。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 2e5 + 5;
    const int B = 400; // 阈值，可根据数据调整

    int n, m, q;
    vector<int> e[MAXN]; // 邻接表
    int deg[MAXN]; // 度数
    vector<bitset<MAXN>> big_bits; // 大点的bitset
    int big_id[MAXN]; // 大点的索引，-1表示小点

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(0);
        cin >> n >> m >> q;

        // 读取边并统计度数
        for (int i = 0; i < m; ++i) {
            int u, v;
            cin >> u >> v;
            e[u].push_back(v);
            e[v].push_back(u);
            deg[u]++;
            deg[v]++;
        }

        // 预处理大点的bitset
        int big_cnt = 0;
        memset(big_id, -1, sizeof(big_id));
        for (int i = 1; i <= n; ++i) {
            if (deg[i] > B) {
                big_id[i] = big_cnt++;
                bitset<MAXN> bs;
                for (int v : e[i]) bs.set(v);
                big_bits.push_back(bs);
            }
        }

        // 处理查询
        while (q--) {
            int u, v;
            cin >> u >> v;
            if (u == v) {
                cout << 0 << '\n';
                continue;
            }

            int ans = deg[u]; // 初始为u的度数

            // 分类讨论：u和v是否为大点
            if (big_id[u] != -1 && big_id[v] != -1) {
                // 两个大点，用bitset求交集
                bitset<MAXN> common = big_bits[big_id[u]] & big_bits[big_id[v]];
                ans -= common.count();
                if (big_bits[big_id[u]].test(v)) ans--; // 减去v自己
            } else if (big_id[u] != -1) {
                // u是大点，v是小点：枚举v的邻居
                for (int w : e[v]) {
                    if (big_bits[big_id[u]].test(w)) ans--;
                }
                if (big_bits[big_id[u]].test(v)) ans--; // 减去v自己
            } else if (big_id[v] != -1) {
                // v是大点，u是小点：枚举u的邻居
                for (int w : e[u]) {
                    if (big_bits[big_id[v]].test(w)) ans--;
                }
                if (big_bits[big_id[v]].test(u)) ans--; // 减去u自己（但u不能是自己的邻居）
            } else {
                // 两个小点：用unordered_map快速查询
                unordered_map<int, bool> v_neighbors;
                for (int w : e[v]) v_neighbors[w] = true;
                v_neighbors[v] = true; // 包含v自己
                for (int w : e[u]) {
                    if (v_neighbors.count(w)) ans--;
                }
            }

            cout << ans << '\n';
        }

        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入并构建邻接表，统计各点度数。然后预处理度数大于阈值B的点（大点），为每个大点存储其邻居的bitset。处理查询时，根据u和v是否为大点，分别用bitset位运算或暴力枚举计算公共邻居数量，最终用u的度数减去公共邻居数（包括v自己）得到答案。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：阿丑**
* **亮点**：离线处理相同u的询问，合并标记操作，减少时间。
* **核心代码片段**：
    ```cpp
    rep(x, 1, n) {
        sort(qn[x].begin(), qn[x].end()); // 去重

        for(int y: ver[x]) {
            vis[y] = x; // 标记u的邻居
        }
        int lst = 0, lstans = 0;
        for(auto ask: qn[x]) {
            const int y = ask.first, id = ask.second;
            if(y == lst) { // 重复询问，直接复用结果
                ans[id] -= lstans;
                continue;
            }
            lstans = (vis[y] == x); // 是否u和v相邻
            for(int z: ver[y]) {
                lstans += (vis[z] == x); // 统计公共邻居
            }
            ans[id] -= lstans;
            lst = y;
        }
    }
    ```
* **代码解读**：
    这段代码对每个u（x）统一处理其所有查询。首先标记u的邻居（vis[y]=x），然后遍历所有关于x的查询。对于重复的查询（y相同），直接复用之前的计算结果（lstans），避免重复统计。通过`vis[z]==x`快速判断z是否是u的邻居，统计u和v的公共邻居数。
* 💡 **学习笔记**：离线处理相同参数的查询，复用计算结果，是优化重复操作的有效手段。

**题解二：_determination_**
* **亮点**：结合根号分治与bitset，分类处理不同点类型。
* **核心代码片段**：
    ```cpp
    if(e[u].size() <= B) {
        int ans = 0;
        for (auto i : e[u]) {
            if (!mp[v][i] && i != v) ans++;
        }
        cout << ans << endl;
    } else {
        if (e[v].size() > B) {
            bitset<200010> bit = ((vec[id[u]] & vec[id[v]]) ^ vec[id[u]]);
            bit[u] = 0;
            cout << bit.count() << endl;
        } else {
            bitset<200010> bit = vec[id[u]];
            for (auto i : e[v]) bit[i] = 0;
            bit[v] = 0;
            bit[u] = 0;
            cout << bit.count() << endl;
        }
    }
    ```
* **代码解读**：
    当u是小点时，暴力枚举u的邻居，用map判断是否是v的邻居。当u是大点时，若v也是大点，用bitset的异或和与运算求u的邻居中不是v邻居的点；若v是小点，枚举v的邻居并在bitset中置0，最后统计剩余数量。
* 💡 **学习笔记**：bitset的位运算（&、^）能高效处理集合的交集和差集，是优化大规模数据查询的关键。

**题解三：RedLycoris**
* **亮点**：动态调整阈值，适应不同数据分布。
* **核心代码片段**：
    ```cpp
    sort(deg + 1, deg + n + 1, cmp);
    lim = deg[min(n, (int)(sqrt(n) * 6))]; // 动态确定阈值
    for (int i = 1; i <= n; ++i) {
        if (g[i].size() > lim) { // 大点预处理bitset
            heavy.push_back(i);
            id[i] = heavy.size() - 1;
            bitset<mxn> newb;
            for (int j = 0; j < g[i].size(); ++j) newb[g[i][j]] = 1;
            T.push_back(newb);
        } else { // 小点预处理map
            for (int j = 0; j < g[i].size(); ++j) have[i][g[i][j]] = 1;
        }
    }
    ```
* **代码解读**：
    首先对度数降序排序，取前sqrt(n)*6大的度数作为阈值lim。大点预处理邻居的bitset，小点预处理邻居的map。查询时根据u和v的类型（大点/小点）选择不同的处理方式。
* 💡 **学习笔记**：动态阈值能适应不同数据分布（如菊花图或稀疏图），提高算法鲁棒性。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解根号分治的处理过程，我们设计一个“像素探险队”主题的8位像素动画，模拟查询时的邻居标记和交集计算。
</visualization_intro>

  * **动画演示主题**：像素探险队的邻居大作战
  * **核心演示内容**：展示大点（红色方块）和小点（蓝色方块）的分类，以及查询时u的邻居（绿色方块）与v的邻居（黄色方块）的交集计算（紫色闪烁方块）。

  * **设计思路简述**：8位像素风格营造轻松氛围，不同颜色区分点类型和状态。动态标记邻居、高亮交集，配合音效强化操作记忆（如找到公共邻居时“叮”一声），游戏化的“关卡”设计（每完成一个查询算一关）增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左半显示图结构（网格，节点为方块），右半显示控制面板（开始/暂停、单步、速度滑块）和当前查询(u,v)。
          * 背景音乐：8位风格的轻快旋律。

    2.  **预处理大点**：
          * 大点（红色方块）闪烁，弹出“大点已预处理”提示，其邻居（绿色方块）被标记（边框加粗）。

    3.  **处理查询(u,v)**：
          * **步骤1**：标记u的邻居。u（主角方块）周围的绿色方块逐个亮起，伴随“唰”的音效。
          * **步骤2**：标记v的邻居。v（反派方块）周围的黄色方块逐个亮起。
          * **步骤3**：计算交集。绿色和黄色重叠的方块变为紫色并闪烁，播放“叮”音效，显示交集数量。
          * **步骤4**：计算答案。u的度数（绿色总数）减去交集数（紫色数），显示最终结果。

    4.  **交互控制**：
          * 单步执行：每点击一次“单步”，执行一个标记或交集计算步骤。
          * 自动播放：根据速度滑块调整播放速度，自动完成整个查询过程。
          * 重置：清空所有标记，回到初始状态。

    5.  **信息同步**：
          * 右侧显示当前步骤对应的C++代码片段（如bitset的&操作），高亮当前执行行。
          * 旁白气泡：“现在，我们正在标记u的邻居，这些绿色方块都是u的好友～”

  * **旁白提示**：
      * （标记u的邻居时）“看！u的好友们（绿色方块）被标记了，接下来要找v的好友～”
      * （计算交集时）“紫色方块是u和v的共同好友，这些好友会看到照片，需要排除～”
      * （显示结果时）“最终答案是u的好友数减去共同好友数，也就是绿色总数减去紫色数！”

<visualization_conclusion>
通过这个动画，我们能直观看到根号分治如何分类处理大点和小点，以及查询时的邻居标记和交集计算过程，轻松理解算法核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以进一步思考根号分治在图论中的其他应用，以及类似的图论问题。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      根号分治不仅适用于本题的公共邻居计算，还可用于：
      - 处理大规模图的最短路径查询（分块预处理部分点的最短路径）；
      - 统计图中三元组（三个互相连接的点）数量（分块处理大点和小点的组合）；
      - 动态图的连通性查询（分块处理动态边，定期重构结构）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1113 杂务** - 拓扑排序
          * 🗣️ **推荐理由**：练习图的拓扑排序，理解如何处理有依赖关系的任务调度，巩固图论基础。
    2.  **洛谷 P1330 封锁阳光大学** - 二分图判断
          * 🗣️ **推荐理由**：练习图的染色法判断二分图，掌握深度优先搜索在图论中的应用。
    3.  **洛谷 P2661 信息传递** - 找环
          * 🗣️ **推荐理由**：练习寻找图中的最小环，理解并查集或深度优先搜索在环检测中的应用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时的经验，例如阈值选择不当导致超时，这些经验对我们很有帮助：
</insights_intro>

> **参考经验 (来自 wujingfey)**：“在设置轻重点阈值时，我一开始用固定值，结果在菊花图数据中超时。后来通过排序动态确定阈值（`lim=deg[min(n,(int)(sqrt(n)*10))]`），才通过所有测试点。这让我意识到，动态调整参数比固定值更适应不同数据分布。”

> **点评**：wujingfey的经验非常实用。在分块算法中，阈值的选择直接影响性能，动态调整（如根据度数分布）能有效避免最坏情况。学习者在调试时，可通过分析测试数据的特点（如是否是菊花图、稀疏图），调整阈值以优化性能。

-----

<conclusion>
本次关于“交友问题”的C++解题分析就到这里。希望这份指南能帮助你理解根号分治的核心思想，掌握公共邻居计算的优化技巧，并通过像素动画直观感受算法流程。编程能力的提升需要不断实践，快去尝试推荐的练习题吧！💪
</conclusion>

---
处理用时：183.90秒
# 题目信息

# [KOI 2025 #1] 干草堆

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

一支带有力量 $P$ 的箭从数轴上的位置 0 向右方发射。在每个整数位置 $i$ ($1 \le i \le N$)，最多可以设置一个防御力为 $D_i$ 的干草堆。

当箭撞到干草堆时，如果箭的力量小于或等于该干草堆的防御力，箭会立即停止。反之，如果箭的力量大于防御力，箭的力量会减去 $D_i$，然后穿过干草堆继续飞行。

对于两个整数 $X, P$，我们将 $f(X, P)$ 的值定义为“为了使力量为 $P$ 的箭在位置 $X$ 或其左侧停止所需要安装的**干草堆的最小数量**”。如果无论如何安装都无法使箭停止，则定义 $f(X, P) = -1$。

请编写一个程序，对于 $Q$ 个整数对 $(X_j, P_j)$ ($1 \le j \le Q$)，分别求出 $f(X_j, P_j)$ 的值。

## 说明/提示

### 限制条件

*   给定的所有数都是整数。
*   $1 \le N, Q \le 300,000$
*   对于每个 $1 \le i \le N$ 的 $i$，都有 $1 \le D_i \le 10^9$。
*   对于每个 $1 \le j \le Q$ 的 $j$，都有 $1 \le X_j \le N$。
*   对于每个 $1 \le j \le Q$ 的 $j$，都有 $1 \le P_j \le 10^9$。

### 子任务

1.  (6 分) $N, Q \le 18$。
2.  (16 分) $N, Q \le 5000$。
3.  (18 分) 对于所有 $1 \le i \le N$ 的 $i$，$D_i \le 300$。
4.  (32 分) 对于所有 $1 \le i < N$ 的 $i$，$D_i \le D_{i+1}$。
5.  (28 分) $N=Q$，且对于所有 $1 \le j \le Q$ 的 $j$，$X_j=j$，且 $P_1 = P_2 = \cdots = P_Q$。
6.  (16 分) 对于所有 $1 \le j \le Q$ 的 $j$，$X_j = N$。
7.  (12 分) 对于所有 $1 \le i < j \le N$ 的 $i, j$，$D_i \ne D_j$。
8.  (22 分) 无附加限制条件。

## 样例 #1

### 输入

```
5 6
2 5 6 1 12
1 1
5 14
2 8
3 7
4 14
5 1```

### 输出

```
1
2
-1
2
4
1```

## 样例 #2

### 输入

```
5 5
3 6 1 1 10
1 10
2 10
3 10
4 10
5 10```

### 输出

```
-1
-1
3
3
1```

# AI分析结果

# 💡 Kay的C++算法解析：干草堆 深入学习指南 💡

今天我们来一起分析“干草堆”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心 + 离线处理 + 树状数组/线段树应用  

🗣️ **初步分析**：  
解决这道题的关键，就像“用最少的大石头堆出足够高的墙”——**贪心选最大的干草堆**一定能以最少数量达到防御力总和要求。比如，要挡住威力10的箭，选一个防御力9的干草堆，比选两个5的更省数量！  

那怎么高效处理无数个“选前X个位置中最大的k个”的查询呢？答案是**离线处理**：把所有查询按X从小到大排序，然后像“扫雷”一样从左到右遍历位置，每遇到一个位置就把它的干草堆加入数据结构（树状数组或线段树），再处理所有X等于当前位置的查询。  

数据结构的作用是**快速维护“从大到小的防御力总和”**：比如树状数组可以记录每个离散化后的值的出现次数和总和，当查询时，我们从最大的值开始累加，直到总和≥P，此时的数量就是答案。  

### 可视化设计思路  
我们会做一个**像素风“干草堆保卫战”**动画：  
- 屏幕左侧是像素化的“位置列”，每点击“下一步”就会点亮一个位置（代表加入干草堆），对应的防御力值会“飞”到右侧的“树状数组像素格”里（大值在上面，小值在下面）。  
- 查询时，会有一个“像素箭”从右侧射向树状数组，每碰到一个干草堆就减少威力，直到威力≤0，此时被碰到的干草堆数量就是答案。  
- 关键操作（加入干草堆、查询计算）会伴随“叮”“嗡”的8位音效，答对会有“胜利音效”，答错则是“提示音”。  


## 2. 精选优质题解参考

为了帮大家快速找到最清晰的思路，我筛选了3份评分≥4星的题解：

### 题解一：chen_zhe的树状数组离线解法（4.5星）  
* **点评**：这份题解把“贪心+离线+树状数组”的思路做到了极致！首先将查询按X排序，然后用树状数组维护离散化后的防御力值（大值在前），每次加入新元素后，用树状数组的“倍增查询”快速找到最小k。代码简洁到只有几十行，却完美覆盖了所有关键步骤：离散化、离线处理、树状数组更新与查询。尤其是树状数组的`find`函数，用倍增的方式从大到小累加，直接算出需要的干草堆数量，效率极高！

### 题解二：lilong的线段树离线解法（4星）  
* **点评**：此题解用线段树代替树状数组，思路更直观——线段树的每个节点维护该值域区间的“数量和”与“防御力总和”。查询时从根节点开始，如果右子树的总和≥P，就往右子树找（因为右子树是更大的值），否则往左子树找并减去右子树的总和。线段树的实现让“从大到小累加”的逻辑更清晰，适合刚学数据结构的同学理解。

### 题解三：Crazyouth的线段树后缀查询（4星）  
* **点评**：这份题解的亮点是“线段树维护后缀和”——把元素按从小到大离散化，线段树的右子树对应更大的值。查询时直接找“最小的后缀和≥P”，用线段树的递归查询一步到位。代码中的`qcnt`函数逻辑非常清晰，完美对应贪心的“选最大的”策略，适合想深入理解线段树应用的同学。


## 3. 核心难点辨析与解题策略

在解决这道题时，同学们常遇到3个“卡壳点”，我们一一破解：

### 1. **为什么要离线处理？**  
- **难点**：如果在线处理每个查询（比如直接对[1,X]排序选前k大），每个查询的时间是O(X log X)，对于3e5的X和Q，会超时！  
- **解决**：离线处理把查询按X排序，这样我们可以**逐步加入元素**（从1到X），每个元素只处理一次，总时间降到O(N log N + Q log N)。  

💡 **学习笔记**：遇到“多个前缀查询”的问题，先想能不能离线排序！

### 2. **如何处理大数值的离散化？**  
- **难点**：干草堆的防御力可以达到1e9，直接用树状数组或线段树存会超内存！  
- **解决**：离散化——把所有防御力值排序，给每个值一个“排名”（大值排前面），这样原本1e9的值就变成了1~N的整数，完美适配数据结构的索引。  

💡 **学习笔记**：数值太大时，先排序离散化，把“值”变成“排名”！

### 3. **如何快速找最小的k？**  
- **难点**：要选最大的k个，总和≥P，怎么快速算k？  
- **解决**：用数据结构维护“从大到小的前缀和”（比如树状数组的`find`函数，线段树的递归查询）。比如树状数组的`find`函数，从最高位开始累加，一旦总和≥P就停止，此时的累加次数就是k。  

💡 **学习笔记**：找“最小k满足前缀和≥P”，用数据结构的“倍增”或“递归”查询，比暴力遍历快100倍！


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（来自chen_zhe的题解）  
* **说明**：这份代码是“贪心+离线+树状数组”的经典实现，逻辑清晰、效率极高，适合作为入门模板。  
* **完整核心代码**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int n, m, a[300300], id[300300], ans[300300];
vector<pair<int, int>> v[300300]; // (h, query_id)

ll t[300300]; // 树状数组：存防御力总和
int c[300300]; // 树状数组：存干草堆数量

void update(int b, int val) {
    for (; b <= n; b += b & -b) {
        t[b] += val;
        c[b]++;
    }
}

int find(int h) {
    int cnt = 0, b = 0;
    for (int i = 19; i >= 0; i--) { // 倍增查询（2^19≈5e5）
        if (b + (1 << i) <= n && h > t[b + (1 << i)]) {
            b += 1 << i;
            h -= t[b];
            cnt += c[b];
        }
    }
    return (b == n) ? -1 : cnt + 1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= m; i++) {
        int x, h; cin >> x >> h;
        v[x].emplace_back(h, i);
    }

    // 离散化：将a[i]按从大到小排序，给每个位置i分配排名id[i]
    vector<pair<int, int>> p(n);
    for (int i = 1; i <= n; i++) p[i-1] = {-a[i], i}; // 负号实现从大到小排序
    sort(p.begin(), p.end());
    for (int i = 0; i < n; i++) id[p[i].second] = i + 1;

    // 离线处理：从左到右加入元素，处理查询
    for (int i = 1; i <= n; i++) {
        update(id[i], a[i]);
        for (auto [h, qid] : v[i]) {
            ans[qid] = find(h);
        }
    }

    for (int i = 1; i <= m; i++) cout << ans[i] << '\n';
    return 0;
}
```  
* **代码解读概要**：  
  1. **输入处理**：读入干草堆防御力和查询，把查询按X存到`v`数组里。  
  2. **离散化**：将a[i]按从大到小排序，给每个位置i分配排名id[i]（大值的排名小，方便树状数组累加）。  
  3. **离线处理**：从1到n遍历每个位置，把当前位置的干草堆加入树状数组，然后处理所有X等于当前i的查询。  
  4. **树状数组操作**：`update`函数更新树状数组的总和和数量；`find`函数用倍增法找最小k。


### 题解一：chen_zhe的核心代码片段赏析  
* **亮点**：用“负号排序”实现从大到小离散化，用“倍增查询”快速找k，代码简洁到“没有一句多余的话”！  
* **核心代码片段**：  
  ```cpp
  int find(int h) {
      int cnt = 0, b = 0;
      for (int i = 19; i >= 0; i--) { // 从最高位（2^19≈5e5）开始试
          if (b + (1 << i) <= n && h > t[b + (1 << i)]) {
              b += 1 << i;
              h -= t[b];
              cnt += c[b];
          }
      }
      return (b == n) ? -1 : cnt + 1;
  }
  ```  
* **代码解读**：  
  这个函数的作用是“找最少需要多少个最大的干草堆，总和≥h”。比如h=10，树状数组里存的是[9,5,3,2]（大到小）：  
  - 先试2^19（远大于n，跳过），直到试到2^2=4（假设n≥4），发现t[4]=9+5+3+2=19≥10？不，等一下，`h > t[b + (1<<i)]`的意思是“当前累加的总和还不够h”，所以要加上这一段的总和。比如h=10，b=0，i=2时，b+4=4，t[4]=19，10>19？不，所以不进入。然后i=1，b+2=2，t[2]=9+5=14，10>14？不，也不进入。i=0，b+1=1，t[1]=9，10>9？是！所以b变成1，h减到1，cnt加1（因为c[1]=1，代表有1个干草堆）。然后继续循环，i=-1退出。此时b=1≠n，所以返回cnt+1=2（需要9+5=14≥10，两个干草堆）。  
* **学习笔记**：倍增法是树状数组的“瑞士军刀”，能快速解决“前缀和查询”问题！


## 5. 算法可视化：像素动画演示  

我们设计了一个**8位像素风的“干草堆保卫战”**动画，让你“看”到算法的每一步：

### 1. **场景初始化**  
- 屏幕左侧是1~5的“位置列”（像素化的小方块，代表每个干草堆的位置），右侧是“树状数组像素格”（5个格子，从上到下代表从大到小的防御力）。  
- 底部有“开始”“单步”“重置”按钮，还有一个“速度滑块”（从“慢”到“快”）。  
- 背景播放8位风格的轻快BGM（比如《超级马里奥》的小片段）。

### 2. **算法启动**  
- 点击“开始”，左侧的位置1（防御力2）会“亮起来”，然后一个“像素值2”飞到右侧树状数组的第5格（因为离散化后2是最小的，排名5），伴随“叮”的音效。  
- 接着位置2（防御力5）亮起来，“像素值5”飞到右侧第4格，同样“叮”一声。  

### 3. **查询处理**  
- 当处理查询(5,14)时，屏幕右侧会射出一个“像素箭”（威力14），先碰到第1格的6（防御力6，箭威力减到8），然后第2格的5（威力减到3），第3格的2（威力减到1），第4格的1（威力减到0）？不对，等一下，离散化后的顺序是大到小，所以树状数组的第1格是最大的防御力6（位置3），第2格是5（位置2），第3格是2（位置1），第4格是1（位置4），第5格是12（位置5）？哦，原样本输入是2、5、6、1、12，所以离散化后从大到小是12（位置5）、6（位置3）、5（位置2）、2（位置1）、1（位置4），所以树状数组的第1格是12，第2格是6，第3格是5，第4格是2，第5格是1。  
- 所以查询(5,14)时，箭先碰到第1格的12（威力14→2），然后碰到第2格的6（威力2→-4，足够了），此时用了2个干草堆，答案就是2！动画里会显示“2”，伴随胜利音效。

### 4. **交互设计**  
- 你可以点击“单步”按钮，一步步看每个位置的加入和查询的处理；  
- 调整“速度滑块”可以加快或减慢动画速度；  
- 点击“重置”可以重新开始，再次体验整个过程。


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
这道题的“贪心+离线+数据结构”思路，可以解决**所有“选最少元素满足总和要求”的前缀查询问题**，比如：  
1. 超市里选最少的商品，总价≥100元（选最贵的商品）；  
2. 班级里选最少的同学，总分≥500分（选最高分的同学）；  
3. 仓库里选最少的箱子，总重量≥1吨（选最重的箱子）。

### 洛谷相似练习推荐  
1. **P1102 古人计数**：同样是选最大的k个数，总和≥P，不过是在线查询，需要用主席树（可持久化线段树）。  
2. **P1801 黑匣子**：维护一个动态的数组，每次查询第k小的数，离线处理+树状数组可以解决。  
3. **P2085 最小函数值**：选最少的函数值，总和≥P，贪心选最大的函数值，用优先队列维护。


## 7. 学习心得与经验分享

### 来自题解作者的经验  
chen_zhe在题解里提到：“一开始我想在线处理每个查询，但发现时间不够，后来想到离线排序，一下子就通了！” 这告诉我们：**遇到超时问题，先想“能不能把查询排序，批量处理”**！  

另外，lilong的题解里说：“离散化的时候一定要注意相同值的处理，比如两个防御力5的干草堆，要给它们不同的排名吗？不，因为它们的大小一样，排序后应该连续，所以离散化时相同值的排名可以相同，但树状数组要记录数量！” 这提醒我们：**离散化时相同值的处理要根据题目需求来定**！


## 8. 总结  

这道题的核心是**贪心选最大的元素**，加上**离线处理查询**和**树状数组/线段树维护值域**。通过这道题，你学会了：  
- 贪心策略的正确性证明（选大的更优）；  
- 离线处理的技巧（把查询排序，逐步加入元素）；  
- 树状数组/线段树的应用（维护值域的和与数量）；  
- 离散化的处理（解决大数值问题）。  

下次遇到类似的“选最少元素满足总和”的问题，记得先想这四个步骤：**贪心→离线→离散化→数据结构**！  

编程的乐趣在于“用聪明的方法解决笨办法解决不了的问题”，继续加油吧！💪

---
处理用时：86.73秒
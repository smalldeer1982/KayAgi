# 题目信息

# 「ACOI2020」学园祭

## 题目背景

![T4](https://s2.ax1x.com/2020/01/12/lopWDS.md.png)

秋天，是学习之秋，食欲之秋，更是，学园祭之秋！随着时间流逝，学园祭也越来越近。终于等到这一天，可是没想到在冲绳岛上邂逅到女装的渚同学的勇次竟然来了！中村 莉櫻（Nakamura Rio）见到这个情况，忙给渚同学换上女装。没办法，勇次已经来了，于是渚同学鼓起勇气迈出了第一步。（为什么自顾自地加提示框啊喂！）

## 题目描述

莉櫻为了利用这个人傻钱多的少爷，尽全力提高消费额，努力地暗示渚同学。没办法，于是渚同学想了一下，提出了一个问题：

给出一个 $n$，定义：
$$
\Gamma(0)=1,\Gamma(n)={n!}
$$

$$
A_i^j=\frac{\Gamma(i)}{\Gamma(j)}
$$
求
$$
\sum_{i=1}^n \sum_{j=1}^i \sum_{k=1}^j \gcd(A_{i-j}^j \times \Gamma(j),A_{j-k}^k \times \Gamma(k)) 
$$

渚同学念着莉櫻举起的对话板上写的字：如果不能在规定时间回答出问题的话，就要把菜单全部买一遍哦！

尽管勇次钱多，但是他并不想吃得太多，因为这个问题有 $T$ 个小问题！

**由于答案可能太大，请将答案对 $10086001$ 取模。**

## 说明/提示

#### 数据范围
**本题采用捆绑测试**。

- Subtask 1（20 points）：$T \leq 10^3$，$n \leq 10^2$。   
- Subtask 2（30 points）：$T \leq 10^6$，$n \leq 5 \times 10^3$。  
- Subtask 3（50 points）：$T \leq 10^6$，$n \leq 10^6$。   

对于 $100\%$ 的数据，$1 \leq T,n \leq 10^6$。

## 样例 #1

### 输入

```
5
1
2
3
4
5
```

### 输出

```
1
4
10
20
36
```

# AI分析结果


### 💡 Kay的C++算法解析：「ACOI2020」学园祭 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`数学推导`与`前缀和优化`  
🗣️ **初步分析**：
> 解决这道题就像拆解一个三层嵌套的俄罗斯套娃🧸：外层求和（i）依赖中层（j），中层又依赖内层（k）。通过观察发现，最核心的"最小套娃"是 **min(i-j, j-k)**！  
> - 所有题解通过数学推导将三重求和简化为：  
>   $$\sum_{a=0}^{\lfloor \frac{n-1}{2} \rfloor} a! \times (n-2a)^2$$
> - **核心难点**：推导组合数(n-2a)²的出现次数（避免重复计数），并处理10⁶数据量下的高效查询
> - **可视化设计**：像素动画将展示a从0到⌊(n-1)/2⌋的累加过程：  
>   - 每个a对应一个像素方块，颜色随a增大渐变（蓝→红）  
>   - 当前计算式 `a! × (n-2a)²` 实时显示在顶部  
>   - 音效：每次累加时触发8-bit "叮"声，完成时播放胜利旋律🎵

---

#### 2. 精选优质题解参考
<eval_intro>  
从思路清晰性、代码规范性、算法优化度等维度，精选3份≥4星优质题解：  
</eval_intro>

**题解一（作者：Alex_Wei）**  
* **点评**：  
  思路堪称教科书级推导！从三重求和逐步拆解到单重求和，清晰解释(n-2a)²的组合意义（两种对称情况+去重）。代码用**前缀和拆分三项**：`∑a!`、`∑4a·a!`、`∑4a²·a!`，实现O(1)查询。变量名`pre1/pre2/pre3`直观，边界处理严谨，可直接用于竞赛。

**题解二（作者：WYXkk）**  
* **点评**：  
  独辟蹊径用**差分法找规律**！通过暴力计算小数据，发现答案的三阶差分等于⌊(n-1)/2⌋!。代码实现极简：三次前缀和还原答案。亮点在于**避免复杂推导**，用数学直觉解决问题，适合思维跳跃型学习者。

**题解三（作者：do_while_true）**  
* **点评**：  
  贡献法推导清晰如数学证明！用"区间长度"类比解释`[k,j]`和`[j,i]`的关系。代码模块化强：`Add()`函数封装取模，`fac/f1/f2/f3`分层预处理。特别适合想深入理解组合意义的同学。

---

#### 3. 核心难点辨析与解题策略
<difficulty_intro>  
解决本题需突破三大关键点，结合优质题解的策略分析：  
</difficulty_intro>

1. **关键点1：三重求和化简**  
   * **分析**：原始O(n³)计算不可行！需将`min(i-j,j-k)`设为常量a，转化为对a的求和。题解通过**固定差值a**，将(i,j,k)三元组映射为a的函数（例：当i-j=a时，k的范围为1≤k≤i-2a）。
   * 💡 **学习笔记**：多重求和优先尝试枚举最内层操作的**结果而非过程**。

2. **关键点2：组合计数去重**  
   * **分析**：推导(n-2a)²时，需区分`i-j=a, j-k>a`和`j-k=a, i-j>a`两种独立情况，再减去`i-j=j-k=a`的重复项。Alex_Wei的题解用**几何对称性**清晰解释该推导。
   * 💡 **学习笔记**：组合计数中"分类-加总-去重"是黄金三步。

3. **关键点3：大数查询优化**  
   * **分析**：直接计算∑a!(n-2a)²仍是O(n)。通过**完全平方公式拆解**：  
     $$n^2\sum{a!} - 4n\sum{a\cdot a!} + 4\sum{a^2\cdot a!}$$  
     预处理三个前缀和数组，实现O(1)响应。
   * 💡 **学习笔记**：前缀和是优化累加查询的终极武器。

### ✨ 解题技巧总结
<summary_best_practices>  
从本题提炼的通用解题策略：  
</summary_best_practices>
- **技巧1：数学映射降维** → 将复杂嵌套转化为单变量函数  
- **技巧2：组合意义可视化** → 在草稿上画区间图辅助推导  
- **技巧3：多项式拆分** → 对含变量的乘积∑f(a)g(n)，拆分为∑c_i·h_i(a)  
- **技巧4：前缀和预处理** → 对固定表达式预先计算，牺牲空间换时间  

---

### 4. C++核心代码实现赏析
<code_intro_overall>  
通用实现基于前缀和思想，完美适配n≤10⁶的极限数据：  
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：综合Alex_Wei与do_while_true的优化方案，完整可编译版本  
* **完整核心代码**：
```cpp
#include <iostream>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5, mod = 10086001;

ll fac[N], sum1[N], sum2[N], sum3[N]; // 前缀和数组

void init() {
    fac[0] = 1;
    // 预处理阶乘及前缀和
    for (int a = 1; a <= 500000; ++a) {
        fac[a] = fac[a - 1] * a % mod;
        sum1[a] = (sum1[a - 1] + fac[a]) % mod;                   // ∑a!
        sum2[a] = (sum2[a - 1] + 4LL * a % mod * fac[a]) % mod;    // ∑4a·a!
        sum3[a] = (sum3[a - 1] + 4LL * a % mod * a % mod * fac[a]) % mod; // ∑4a²·a!
    }
}

int main() {
    init();
    int T, n;
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &n);
        int a_max = (n - 1) / 2; // a的上限
        // 核心计算：ans = n²∑a! - n∑4a·a! + ∑4a²·a!
        ll ans = (1LL * n * n % mod * sum1[a_max]) % mod;
        ans = (ans - 1LL * n * sum2[a_max] % mod + mod) % mod;
        ans = (ans + sum3[a_max]) % mod;
        printf("%lld\n", ans);
    }
    return 0;
}
```
* **代码解读概要**：  
  1. `init()`预计算三个前缀和数组（只需运行一次）  
  2. 对每次查询：  
     - 计算`a_max = ⌊(n-1)/2⌋`  
     - 用拆解公式组合三个前缀和  
  3. 防负数取模：`(x+mod)%mod`

<code_intro_selected>  
精选题解的代码亮点赏析：  
</code_intro_selected>

**题解一（Alex_Wei）片段**  
```cpp
for(int i=1; i<N>>1; i++) {
    frc[i] = frc[i-1] * i % mod;
    pre1[i] = (pre1[i-1] + frc[i]) % mod;
    pre2[i] = (pre2[i-1] + frc[i] * 4LL * i) % mod;
}
```
* **亮点**：位运算优化`N>>1`替代`N/2`，提升性能  
* **代码解读**：  
  > 循环上界`N>>1`巧妙利用a≤⌊(n-1)/2⌋的特性，减少一半预处理量。`4LL`显式声明long long乘法，避免溢出。  
* 💡 **学习笔记**：位运算在常数优化中大有可为。

**题解二（WYXkk）片段**  
```cpp
F(i,1,N) ans[i] = jc[(i-1)>>1]; 
F(i,1,N) ans[i] = (ans[i] + ans[i-1]) % mod; // 三阶前缀和
```
* **亮点**：差分逆运算思路清奇  
* **代码解读**：  
  > 通过三阶前缀和还原答案，省去公式推导。`(i-1)>>1`等价于⌊(i-1)/2⌋，用位运算避免浮点数。  
* 💡 **学习笔记**：差分/前缀和可相互转化复杂累加式。

---

### 5. 算法可视化：像素动画演示
<visualization_intro>  
**「阶乘之旅：8-bit累加冒险」** 像素动画方案，助你直观理解核心算法：  
</visualization_intro>

* **主题**：复古RPG风格，玩家（像素小人）收集a!宝箱  
* **核心演示**：固定n后，a从0到⌊(n-1)/2⌋的累加过程  
* **设计思路**：用FC红白机配色（4色调色盘），宝箱颜色随a增大从蓝→黄→红渐变，强化阶乘增长概念  

**动画帧步骤**：  
1. **场景初始化**  
   - 背景：像素网格地图，x轴为a值（0→max_a），y轴为贡献值  
   - 控制面板：`开始/暂停` `单步` `速度滑块` `重置`  
   - 8-bit BGM循环播放（类似《俄罗斯方块》旋律）  

2. **核心流程（自动播放模式）**  
   ```mermaid
   graph LR
   A[a=0] --> B[显示当前a]
   B --> C[计算 a! 和 (n-2a)²]
   C --> D[宝箱升起+闪光]
   D --> E[显示 a!×n-2a²]
   E --> F[累加进总和]
   F --> G{ a < max_a? }
   G --是--> H[a++ + 步进音效]
   G --否--> I[播放胜利音效]
   ```

3. **动态效果细节**  
   - **当前a高亮**：像素方块闪烁金色边框  
   - **宝箱动画**：a!显示在宝箱上方，(n-2a)²显示为两侧护卫像素人  
   - **音效设计**：  
     - 步进：短促"叮"声（频率随a增大升高）  
     - 累加：金币掉落音效  
     - 完成：16-bit胜利和弦  

4. **教学提示**  
   - 顶部状态栏：`∑ = ${当前总和} + a!×n-2a²`  
   - 旁白气泡（Kay头像）：  
     > "当a=3时，3!=6，(n-6)²=36，贡献值216！"  

---

### 6. 拓展练习与相似问题思考
<similar_problems_intro>  
掌握前缀和拆分思想后，可挑战以下相似问题：  
</similar_problems_intro>

1. **洛谷 P2513 [HAOI2009]逆序对数列**  
   🗣️ **推荐理由**：同样需将复杂求和转化为前缀和组合，训练映射能力  
2. **洛谷 P2511 [HAOI2008]木棍分割**  
   🗣️ **推荐理由**：双重前缀和优化DP的经典题，强化拆分技巧  
3. **洛谷 P2184 贪婪大陆**  
   🗣️ **推荐理由**：区间计数+前缀和的高频题型，培养组合思维  

---

### 7. 学习心得与经验分享
<insights_intro>  
题解中藏有珍贵经验：  
</insights_intro>

> **Alex_Wei的调试经验**：  
> "推导(n-2a)²时，最初漏掉重复项导致样例错误。通过对比n=3/4的手算结果，最终发现需减去x=y=a的情况。"  
>   
> **Kay点评**：  
> 这验证了**小数据模拟**的重要性！建议在草稿纸画出：  
> ```
> n=3时：  
> (i,j,k)组合：(1,1,1)、(2,1,1)、(2,2,1)、(2,2,2)、...  
> 逐个验证min(i-j,j-k)的值  
> ```

---

本次学园祭之旅到此结束！记住：优雅的代码源于深刻的数学洞察。下次挑战再见！💪

---
处理用时：191.77秒
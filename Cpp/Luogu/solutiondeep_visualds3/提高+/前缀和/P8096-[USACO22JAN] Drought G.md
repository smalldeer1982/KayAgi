# 题目信息

# [USACO22JAN] Drought G

## 题目描述

Farmer John 的草地里的草在一场大旱中都干死了。经过数小时的绝望和沉思，FJ 想到了一个绝妙的主意，购买玉米来喂养他宝贵的奶牛。

FJ 的 $N$ 头奶牛（$1 \leq N \leq 100$）排成一行，队伍中的第 $i$ 头奶牛的饥饿度为一个非负整数 $h_i$。由于 FJ 的奶牛是社会性动物，她们坚持一起进食，FJ 降低奶牛饥饿度的唯一方法是选择两头相邻的奶牛 $i$ 和 $i+1$ 并分别喂她们一袋玉米，令她们的饥饿度各减少 1。

FJ 想将他的奶牛喂至所有的奶牛都具有相同的非负饥饿度。尽管他不知道他的奶牛们具体的饥饿度，他知道每一头奶牛的饥饿度上界；具体地说，第 $i$ 头奶牛的饥饿度 $h_i$ 至多为 $H_i$（$0\le H_i\le 1000$）。

你的工作是计算符合上述上界的 $N$ 元组 $[h_1,h_2,\ldots,h_N]$ 的数量，使得 FJ 有可能达到他的目标，答案对 $10^9+7$ 取模。


## 说明/提示

【样例解释】

共有 $(9+1)\cdot (11+1)\cdot (7+1)$ 个 $3$ 元组 $h$ 与 $H$ 相符合。

$h=[8,10,5]$ 是其中一个元组。在这个情况中，有可能使得所有的奶牛具有相同的饥饿度：给奶牛 $2$ 和 $3$ 各两袋玉米，然后给奶牛 $1$ 和 $2$ 各五袋玉米，可以使得所有奶牛的饥饿度均为 $3$。

$h=[0,1,0]$ 是另一个元组。在这个情况中，不可能使得奶牛们的饥饿度相等。

【数据范围】


- 编号为偶数的测试点中的 $N$ 均为偶数，编号为奇数的测试点中的 $N$ 均为奇数。

- 测试点 3-4 满足 $N\le 6$ 以及 $H_i \le 10$。

- 测试点 5-10 满足 $N\le 50$ 以及 $H_i \le 100$。

- 测试点 11-20 没有额外限制。


## 样例 #1

### 输入

```
3
9 11 7```

### 输出

```
241```

## 样例 #2

### 输入

```
4
6 8 5 9```

### 输出

```
137```

# AI分析结果


💡 Kay的C++算法解析：Drought G 深入学习指南 💡

### 1. 题目解读与核心算法识别
✨ **本题主要考察**：动态规划(DP) + 数学分析  
🗣️ **初步分析**：  
> 解决本题的关键在于理解 **差分序列的奇偶性** 和 **动态规划的状态设计**。想象奶牛队列为一条传送带，每次操作（喂相邻两头牛）如同在传送带上移动一个“玉米包裹”，改变相邻位置的饥饿度差值。动态规划通过记录 **奇偶位置差**（$d_i$）或 **相对最终值的偏移量** 来统计合法序列数。  
- **核心思路**：将序列合法性转化为差分约束（$d_i \geq 0$），设计DP状态 $f[i][j]$ 表示前 $i$ 头牛的 $d_i=j$ 的方案数。转移时用前缀和优化区间求和。  
- **难点对比**：  
  - *n为偶数*：只需计算 $k=0$ 的情况（所有牛可同步减饥饿度），复杂度 $O(nH)$。  
  - *n为奇数*：需枚举最终饥饿度 $k$（$0\leq k \leq \min H_i$），复杂度 $O(nH^2)$。  
- **可视化设计**：  
  - 像素动画将展示差分序列 $d_i$ 的更新过程：  
    - 用 **8位像素色块** 表示奶牛，高度条显示 $d_i$ 值。  
    - 状态转移时，高亮当前奶牛和依赖的前缀和区间（如绿色闪烁）。  
    - 复古音效：转移时“滴”声，状态更新时“咔”声，成功时8-bit胜利旋律。

---

### 2. 精选优质题解参考
**题解一（耶梦加得）**  
* **点评**：  
  思路清晰——定义 $dp[i][j]$ 为前 $i$ 牛在相对值下的状态，直接对应差分思想。代码规范（前缀和优化），变量名 `g[i][j]` 含义明确。亮点是发现 $n$ 奇偶性对 $k$ 的影响，并用 `mmin` 简化边界处理。实践价值高，代码可直接用于竞赛。

**题解二（duyi）**  
* **点评**：  
  算法深刻——引入奇偶位置和 $o_i/e_i$，将操作转化为 $d_i$ 的单调性。代码用滚动数组优化空间，`sum` 数组实现前缀和转移。亮点是数学证明严谨（$d_i$ 与操作关系），启发性强。

**题解三（Alex_Wei）**  
* **点评**：  
  代码简洁高效——状态设计与转移仅 **15行**。亮点是结合奇偶性统一处理 $k$，并用 `swap` 滚动数组。边界处理严谨（`j` 从 `v` 或 `0` 开始），适合学习高效实现。

---

### 3. 核心难点辨析与解题策略
1. **难点1：状态设计抽象**  
   - **分析**：需将操作转化为差分约束（$d_i = h_i - d_{i-1}$）。优质题解用 $d_i$ 表示奇偶差，满足 $d_i \geq 0$ 才合法。  
   - 💡 **学习笔记**：差分是处理相邻操作的利器，$d_i$ 定义需无后效性。

2. **难点2：$n$ 奇偶性影响**  
   - **分析**：$n$ 为偶数时，最终值 $k$ 可任取（同步操作等效）；$n$ 为奇数时，$k$ 需枚举且需满足 $d_n = k$。  
   - 💡 **学习笔记**：奇偶性决定最终值自由度，是分类讨论的关键。

3. **难点3：DP转移优化**  
   - **分析**：转移方程 $f[i][j] = \sum f[i-1][k]$ 含区间求和，直接实现会超时。前缀和优化将复杂度降 $O(H)$。  
   - 💡 **学习笔记**：前缀和是DP计数题的标配优化，将区间求和变为单点查询。

✨ **解题技巧总结**：  
- **技巧1（问题分解）**：将复杂操作转化为差分序列的单调约束。  
- **技巧2（前缀和优化）**：用数组 `sum` 存储 $f$ 的前缀和，实现 $O(1)$ 转移。  
- **技巧3（边界处理）**：$n$ 为奇数时，$k$ 的上界为 $\min H_i$，且需枚举。

---

### 4. C++核心代码实现赏析
**通用核心C++实现参考**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 103, H = 1000, MOD = 1e9+7;
int n, h[N], mn = H + 1, ans;
int f[2][H + 5], sum[2][H + 5]; // 滚动数组 + 前缀和

void add(int &x, int y) { x = (x + y) % MOD; }

int solve(int k) {
    memset(f, 0, sizeof f);
    for (int j = 0; j <= h[1] - k; j++) f[1][j] = 1;
    // 初始化前缀和
    for (int j = 0; j <= H; j++) sum[1][j] = (j ? sum[1][j - 1] : 0) + f[1][j];
    for (int i = 2; i <= n; i++) {
        int cur = i & 1, pre = cur ^ 1;
        memset(f[cur], 0, sizeof f[cur]);
        for (int j = (i % 2 ? k : 0); j <= h[i] - k; j++) {
            int max_k = h[i] - k - j;
            f[cur][j] = sum[pre][min(max_k, H)];
        }
        // 更新前缀和
        for (int j = 0; j <= H; j++) 
            sum[cur][j] = (j ? sum[cur][j - 1] : 0) + f[cur][j];
    }
    return f[n & 1][0]; // 最终状态 d_n = 0 或 k
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> h[i], mn = min(mn, h[i]);
    if (n % 2 == 0) ans = solve(0);
    else for (int k = 0; k <= mn; k++) add(ans, solve(k));
    cout << ans << endl;
}
```
**代码解读概要**：  
- **滚动数组**：`f` 和 `sum` 只用两行，节省空间。  
- **前缀和优化**：`sum[i][j]` 存储 $f[i][0..j]$ 的和，转移时直接调用。  
- **奇偶处理**：$n$ 为偶数时 $k=0$；$n$ 为奇数时枚举 $k \in [0, \min H_i]$。

---

### 5. 算法可视化：像素动画演示
**主题**：8-bit农场模拟——差分序列的DP之旅  
**核心演示**：  
1. **初始化**：  
   - 奶牛序列显示为像素栅栏（棕色），高度 $H_i$ 用绿色液柱表示。  
   - 最终值 $k$ 用闪烁金块标记（$n$ 奇数时多个金块下落）。  
2. **DP状态转移**：  
   - **第 $i$ 头牛处理**：液柱下方显示 $d_i$ 值（蓝色进度条），从左侧前缀和数组（条形图）拉取数据。  
   - **前缀和更新**：成功转移时，新状态条变为绿色，伴随“叮”声。  
3. **结果展示**：  
   - 成功：所有 $d_i$ 条为0，奶牛头顶蛋糕，播放胜利音效。  
   - 失败：$d_i <0$ 时液柱变红，播放低沉音效。  

**交互控制**：  
- 速度滑块调节DP步速。  
- “AI演示”自动运行，如吃豆人遍历状态空间。

---

### 6. 拓展练习与相似问题思考
1. **通用技巧迁移**：  
   - 差分约束用于相邻操作（如 [NOIP2018] 铺设道路）。  
   - 奇偶性分类在网格问题中常见（如 [ARC099D] Eating Symbols Hard）。  
2. **推荐练习**：  
   - 洛谷 P5019：一维差分应用（巩固差分思想）。  
   - 洛谷 P2893：序列均衡化（类似最终值枚举）。  
   - 洛谷 P2893：USACO序列平衡（扩展高维DP）。

---

### 7. 学习心得与经验分享
> **经验摘录（耶梦加得）**：  
> “$n$ 为偶数时无需枚举 $k$，因操作可整体下移。调试时先验证 $n$ 奇偶性！”  
> **点评**：深刻理解操作对最终值的影响，避免无效枚举。边界测试（$n$ 奇偶）是解题关键。

---

通过本指南，你掌握了差分约束建模、DP状态设计和前缀和优化。动手实现代码并观察像素动画，能直观感受状态转移过程！下次挑战见！🚀

---
处理用时：126.39秒
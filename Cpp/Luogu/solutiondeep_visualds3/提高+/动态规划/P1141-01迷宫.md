# 题目信息

# 01迷宫

## 题目描述

有一个仅由数字 $0$ 与 $1$ 组成的 $n \times n$ 格迷宫。若你位于一格 $0$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $1$ 上，同样若你位于一格 $1$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $0$ 上。

你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。

## 说明/提示

对于样例，所有格子互相可达。

- 对于 $20\%$ 的数据，$n \leq 10$；
- 对于 $40\%$ 的数据，$n \leq 50$；
- 对于 $50\%$ 的数据，$m \leq 5$；
- 对于 $60\%$ 的数据，$n,m \leq 100$；
- 对于 $100\%$ 的数据，$1\le n \leq 1000$，$1\le m \leq 100000$。

## 样例 #1

### 输入

```
2 2
01
10
1 1
2 2
```

### 输出

```
4
4
```

# AI分析结果

# 01迷宫题解分析


### **一、题目核心**
给定一个\(n \times n\)的01迷宫，每次可以从0走到相邻的1，或从1走到相邻的0。对于每个询问点，求其能到达的格子数（包括自身）。


### **二、核心思想**
**连通块**：所有能互相到达的点构成一个连通块，同一连通块内的点答案相同（能到达的格子数相等）。因此，只需**预处理每个连通块的大小**，查询时直接取该点所属连通块的大小即可。


### **三、常见解法**
#### **1. BFS/DFS找连通块**
- **思路**：遍历每个未访问的点，用BFS/DFS遍历其所有连通点，标记这些点属于同一个连通块，并记录该连通块的大小。
- **实现步骤**：
  1. 读取输入，存储迷宫为二维数组。
  2. 初始化`vis`数组（标记是否访问过）和`ans`数组（记录连通块大小）。
  3. 遍历每个点，若未访问，则用BFS/DFS遍历所有连通点，标记`vis`为当前连通块ID，记录`ans[ID]`为连通块大小。
  4. 查询时，输出`ans[vis[x][y]]`。
- **示例代码（BFS）**：
  ```cpp
  #include <iostream>
  #include <queue>
  #include <vector>
  using namespace std;

  const int dx[] = {0, 0, 1, -1};
  const int dy[] = {1, -1, 0, 0};
  int n, m;
  vector<string> maze;
  vector<vector<int>> vis;
  vector<int> ans;

  void bfs(int x, int y, int id) {
      queue<pair<int, int>> q;
      q.push({x, y});
      vis[x][y] = id;
      int cnt = 0;
      while (!q.empty()) {
          auto [cx, cy] = q.front();
          q.pop();
          cnt++;
          for (int i = 0; i < 4; i++) {
              int nx = cx + dx[i], ny = cy + dy[i];
              if (nx >= 0 && nx < n && ny >= 0 && ny < n && vis[nx][ny] == 0 && maze[cx][cy] != maze[nx][ny]) {
                  vis[nx][ny] = id;
                  q.push({nx, ny});
              }
          }
      }
      ans[id] = cnt;
  }

  int main() {
      cin >> n >> m;
      maze.resize(n);
      for (int i = 0; i < n; i++) {
          cin >> maze[i];
      }
      vis.assign(n, vector<int>(n, 0));
      ans.push_back(0); // 占位，id从1开始
      int id = 1;
      for (int i = 0; i < n; i++) {
          for (int j = 0; j < n; j++) {
              if (vis[i][j] == 0) {
                  bfs(i, j, id);
                  id++;
              }
          }
      }
      while (m--) {
          int x, y;
          cin >> x >> y;
          x--; y--; // 转换为0-based
          cout << ans[vis[x][y]] << endl;
      }
      return 0;
  }
  ```


#### **2. 并查集**
- **思路**：将每个点视为一个集合，合并相邻可连通的点（值不同），最后每个集合的大小即为该连通块的答案。
- **实现步骤**：
  1. 读取输入，存储迷宫为二维数组。
  2. 将二维坐标转为一维ID（如`(i,j)`转为`i*n + j`）。
  3. 初始化`fa`数组（父节点）和`size`数组（集合大小）。
  4. 遍历每个点，合并右边和下边的可连通点（避免重复合并）。
  5. 查询时，找到该点的根节点，输出根节点的`size`。
- **示例代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;

  vector<int> fa;
  vector<int> size_;

  int find(int x) {
      return fa[x] == x ? x : fa[x] = find(fa[x]);
  }

  void unite(int x, int y) {
      x = find(x), y = find(y);
      if (x != y) {
          if (size_[x] < size_[y]) swap(x, y);
          fa[y] = x;
          size_[x] += size_[y];
      }
  }

  int main() {
      int n, m;
      cin >> n >> m;
      vector<string> maze(n);
      for (int i = 0; i < n; i++) {
          cin >> maze[i];
      }
      int total = n * n;
      fa.resize(total);
      size_.resize(total, 1);
      for (int i = 0; i < total; i++) {
          fa[i] = i;
      }
      // 合并右边和下边的点
      for (int i = 0; i < n; i++) {
          for (int j = 0; j < n; j++) {
              int id = i * n + j;
              // 合并右边
              if (j < n - 1 && maze[i][j] != maze[i][j+1]) {
                  int right = i * n + (j+1);
                  unite(id, right);
              }
              // 合并下边
              if (i < n - 1 && maze[i][j] != maze[i+1][j]) {
                  int down = (i+1) * n + j;
                  unite(id, down);
              }
          }
      }
      // 查询
      while (m--) {
          int x, y;
          cin >> x >> y;
          x--; y--; // 转换为0-based
          int id = x * n + y;
          cout << size_[find(id)] << endl;
      }
      return 0;
  }
  ```


### **四、解法对比**
| 解法       | 时间复杂度       | 空间复杂度       | 优缺点                     |
|------------|------------------|------------------|----------------------------|
| BFS/DFS    | 预处理\(O(n^2)\)，查询\(O(1)\) | \(O(n^2)\)       | 容易理解，实现简单；BFS无栈溢出风险 |
| 并查集     | 预处理\(O(n^2\alpha(n))\)，查询\(O(\alpha(n))\) | \(O(n^2)\)       | 效率极高（\(\alpha(n)\)几乎为常数）；代码稍复杂 |


### **五、注意事项**
1. **输入处理**：迷宫输入为字符串，需正确读取每个字符（如用`cin`或`scanf`读取字符串）。
2. **越界判断**：遍历四个方向时，需判断坐标是否在合法范围内（0到n-1或1到n）。
3. **避免重复计算**：用`vis`数组标记已处理的点，避免重复遍历。
4. **连通块大小记录**：无论是BFS/DFS还是并查集，都需正确记录每个连通块的大小。


### **六、推荐解法**
- **BFS**：适合新手，代码容易理解，无栈溢出风险。
- **并查集**：适合追求效率的场景，时间复杂度极低。


### **七、总结**
本题的核心是**连通块思想**，通过预处理每个连通块的大小，将查询时间降为\(O(1)\)或\(O(\alpha(n))\)，从而高效处理大量查询。无论是BFS还是并查集，都能有效解决问题，选择哪种方法取决于个人习惯和对效率的要求。

---
处理用时：292.21秒
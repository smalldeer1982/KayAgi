# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果

# 💡 Kay的C++算法解析：中位数 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态中位数维护（对顶堆/平衡树/树状数组）


### 🗣️ 初步分析
题目要求输出**前1、3、5…项的中位数**（即每加入一个奇数个元素时，输出当前序列的中位数）。中位数是排序后中间位置的元素，动态维护中位数的关键是**高效处理插入操作并快速查询中间值**。

#### 核心算法选择：对顶堆（大根堆+小根堆）
- **比喻**：把序列分成两部分，左边用“大根堆”装较小的一半（堆顶是这部分的最大值），右边用“小根堆”装较大的一半（堆顶是这部分的最小值）。中位数就是**元素较多的堆的堆顶**（因为序列长度为奇数时，总有一个堆比另一个多1个元素）。
- **应用场景**：每次插入元素时，根据它与大根堆堆顶的大小关系，放入对应的堆。然后调整两个堆的大小，使它们的元素个数差不超过1。此时，元素较多的堆的堆顶就是当前中位数。
- **可视化思路**：用像素动画展示两个堆的结构（大根堆用红色方块，小根堆用蓝色方块），插入元素时用箭头表示元素的移动方向，平衡堆时用闪烁效果突出交换的元素，中位数用黄色高亮显示。


## 2. 精选优质题解参考

### 题解一：对顶堆（作者：肖恩Sean，赞534）
- **点评**：思路清晰，用大根堆维护较小的一半，小根堆维护较大的一半，通过调整堆的大小保持平衡。代码简洁（24行），使用STL优先队列，可读性高。**亮点**：通过`abs(q1.size()-q2.size())>1`判断是否需要平衡，逻辑严谨。

### 题解二：vector插入排序（作者：decoqwq，赞748）
- **点评**：代码极简（15行），利用`vector`的`insert`和`lower_bound`函数，每次插入元素后保持序列有序，直接取中间值。**亮点**：适合入门学习者理解中位数的基本概念，但时间复杂度较高（O(n²logn)），仅适用于小数据。

### 题解三：树状数组+离散化（作者：ysj1173886760，赞116）
- **点评**：针对大数据范围（1e9），使用离散化将数据映射到1e5的范围，再用树状数组维护前缀和，查询第k小元素。**亮点**：展示了离散化的应用，适合学习树状数组的高级用法。


## 3. 核心难点辨析与解题策略

### 1. 动态维护中位数的方法选择
- **问题**：直接排序（O(n²logn)）无法通过大数据，需要更高效的方法。
- **策略**：选择对顶堆（O(nlogn)），它能快速插入元素并维护中位数。平衡树（如Treap）也能解决，但代码更复杂。

### 2. 对顶堆的维护逻辑
- **问题**：如何保持两个堆的大小差不超过1？如何判断元素应该放入哪个堆？
- **策略**：
  - 插入元素时，若元素大于大根堆堆顶，放入小根堆；否则放入大根堆。
  - 若两个堆的大小差超过1，将元素较多的堆的堆顶移动到另一个堆。

### 3. 离散化的处理（树状数组解法）
- **问题**：数据范围大（1e9），无法直接用数组存储。
- **策略**：将数据排序去重，映射到1~n的范围（离散化），再用树状数组维护前缀和。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（对顶堆）
- **说明**：综合肖恩Sean和IRipple的题解，提炼对顶堆的经典实现。
- **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <queue>
  #include <cmath>
  using namespace std;

  priority_queue<int> max_heap; // 大根堆（维护较小的一半）
  priority_queue<int, vector<int>, greater<int>> min_heap; // 小根堆（维护较大的一半）

  int main() {
      int n;
      cin >> n;
      for (int i = 1; i <= n; ++i) {
          int x;
          cin >> x;
          // 插入元素
          if (max_heap.empty() || x <= max_heap.top()) {
              max_heap.push(x);
          } else {
              min_heap.push(x);
          }
          // 平衡堆大小
          while (abs((int)max_heap.size() - (int)min_heap.size()) > 1) {
              if (max_heap.size() > min_heap.size()) {
                  min_heap.push(max_heap.top());
                  max_heap.pop();
              } else {
                  max_heap.push(min_heap.top());
                  min_heap.pop();
              }
          }
          // 输出中位数（奇数项）
          if (i % 2 == 1) {
              cout << (max_heap.size() > min_heap.size() ? max_heap.top() : min_heap.top()) << endl;
          }
      }
      return 0;
  }
  ```
- **代码解读概要**：
  1. 用`max_heap`（大根堆）存储较小的一半元素，`min_heap`（小根堆）存储较大的一半元素。
  2. 插入元素时，根据与`max_heap`堆顶的大小关系选择堆。
  3. 平衡堆大小，使两者差不超过1。
  4. 奇数项时，输出元素较多的堆的堆顶。


### 针对各优质题解的片段赏析

#### 题解一（肖恩Sean的对顶堆）
- **亮点**：用`abs`判断堆大小差，逻辑简洁。
- **核心代码片段**：
  ```cpp
  while (abs((int)q1.size() - (int)q2.size()) > 1) {
      if (q1.size() > q2.size()) {
          q2.push(q1.top());
          q1.pop();
      } else {
          q1.push(q2.top());
          q2.pop();
      }
  }
  ```
- **代码解读**：当两个堆的大小差超过1时，将元素较多的堆的堆顶移动到另一个堆，保持平衡。
- **学习笔记**：对顶堆的核心是**平衡两个堆的大小**，确保中位数在堆顶。


#### 题解二（decoqwq的vector）
- **亮点**：用`lower_bound`快速找到插入位置，保持序列有序。
- **核心代码片段**：
  ```cpp
  a.insert(lower_bound(a.begin(), a.end(), x), x);
  if (i % 2 == 1) {
      printf("%d\n", a[(i-1)/2]);
  }
  ```
- **代码解读**：`lower_bound`返回第一个大于等于x的迭代器，插入后序列有序，直接取中间位置的元素。
- **学习笔记**：`vector`的`insert`函数时间复杂度为O(n)，适合小数据，大数据需用更高效的方法。


#### 题解三（ysj1173886760的树状数组）
- **亮点**：离散化处理大数据，树状数组维护前缀和。
- **核心代码片段**：
  ```cpp
  int find_kth(int k) {
      int ans = 0, now = 0;
      for (int i = 20; i >= 0; --i) {
          ans += (1 << i);
          if (ans > tot || now + bit[ans] >= k) {
              ans -= (1 << i);
          } else {
              now += bit[ans];
          }
      }
      return ans + 1;
  }
  ```
- **代码解读**：通过树状数组的前缀和，二分查找第k小元素。`bit[ans]`表示前缀和，`now`记录当前累计的元素个数。
- **学习笔记**：离散化是处理大数据范围的常用技巧，树状数组适合维护前缀和查询。


## 5. 算法可视化：像素动画演示（对顶堆）

### 🎮 动画演示主题：堆的“平衡游戏”
- **风格**：8位像素风（类似FC游戏），用红色方块表示大根堆，蓝色方块表示小根堆，黄色方块表示中位数。
- **核心演示内容**：
  1. **初始化**：屏幕显示两个空堆，左边是大根堆（红色），右边是小根堆（蓝色）。
  2. **插入元素**：输入一个数，比如`3`，放入大根堆（红色方块闪烁）。
  3. **平衡堆**：当插入`5`时，放入小根堆，此时大根堆有1个元素，小根堆有1个元素，平衡。
  4. **输出中位数**：当插入`7`（第3个元素），放入小根堆，此时小根堆有2个元素，大根堆有1个元素，需要平衡：将小根堆的堆顶（`5`）移动到大根堆，大根堆有2个元素，小根堆有1个元素，中位数是大根堆的堆顶（`5`，黄色高亮）。
- **交互设计**：
  - 单步执行：点击“下一步”按钮，逐步展示插入和平衡过程。
  - 自动播放：设置速度滑块，自动播放动画，展示连续插入的过程。
  - 音效：插入元素时播放“叮”的声音，平衡堆时播放“唰”的声音，输出中位数时播放“滴”的声音。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移
对顶堆不仅能解决动态中位数问题，还能解决**动态第k小**（如黑匣子问题）、**滑动窗口中位数**等问题。核心是**用两个堆维护序列的两部分**，快速查询中间值。

### 📚 洛谷练习推荐
1. **P1801 黑匣子**：动态求第k小，是对顶堆的经典应用。
   - 推荐理由：巩固对顶堆的维护逻辑，学会处理动态查询。
2. **P3369 平衡树**：模板题，用平衡树维护动态序列，查询第k小。
   - 推荐理由：了解平衡树的实现，对比对顶堆的效率。
3. **P2085 最小函数值**：用堆维护多个函数的最小值，类似对顶堆的思路。
   - 推荐理由：拓展堆的应用场景，学会维护多个序列的极值。
4. **P1198 最大数**：用线段树或平衡树维护动态序列的最大值。
   - 推荐理由：对比不同数据结构的效率，学会选择合适的方法。


## 7. 学习心得与经验分享（若有）
- **来自肖恩Sean的经验**：“对顶堆的关键是保持两个堆的大小平衡，插入元素时要判断放入哪个堆，平衡时要移动堆顶元素。”
  - **点评**：这句话总结了对顶堆的核心逻辑，初学者可以重点关注这两点。
- **来自decoqwq的经验**：“vector的insert函数虽然方便，但时间复杂度高，大数据需要用更高效的方法。”
  - **点评**：提醒学习者要根据数据规模选择合适的算法，避免因时间复杂度太高而超时。


## 📝 总结
本次学习指南围绕“动态中位数”问题，介绍了对顶堆、vector插入排序、树状数组等多种解法。其中，**对顶堆**是最推荐的方法，因为它效率高、逻辑清晰，适合动态维护中位数。通过可视化动画和拓展练习，希望大家能深入理解对顶堆的原理，并能举一反三，解决类似的动态查询问题。

记住：编程的关键是**选择合适的算法**，并理解其核心逻辑。多练习、多思考，你会越来越厉害！💪

---
处理用时：275.10秒
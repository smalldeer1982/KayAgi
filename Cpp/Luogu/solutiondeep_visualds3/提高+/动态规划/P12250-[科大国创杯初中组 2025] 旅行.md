# 题目信息

# [科大国创杯初中组 2025] 旅行

## 题目背景

Subtask 0 为民间数据，Subtask 1 为官方数据。

## 题目描述

小可可来到了 P 国旅行。

P 国共有 $n$ 个城市和 $m$ 条有向道路，其中第 $i$ 条道路为从城市 $u_i$ 到城市 $v_i$，长度为 $w_i$。**保证** $u_i < v_i$。

对于一次游览，假设小可可依次经过了城市 $x_1, x_2, \ldots, x_k$，其中从 $x_i$ 到 $x_{i+1}$ 经过的路径长度为 $y_i$。记 $s_i$ 表示 $y_1, y_2, \ldots, y_i$ 的**按位或**值。那么小可可认为这次游览就是从 $x_1$ 走到 $x_k$，疲劳度就是 $\operatorname{mex}(s_1, s_2, \ldots, s_{k-1})$。

其中 $\operatorname{mex}(a_1, a_2, \ldots, a_n)$ 表示最小的没有出现在 $a_1, a_2, \ldots, a_n$ 中的自然数。例如 $\operatorname{mex}(0, 2, 3) = 1$，$\operatorname{mex}(1, 4) = 0$，$\operatorname{mex}(0, 1, 2, 3, 4) = 5$。

小可可认为两座城市 $s, t$ 之间的距离为他从 $s$ 走到 $t$ 所有可能的游览方案中疲劳度的最大值，记作 $d(s, t)$。如果不能从 $s$ 走到 $t$，那么 $d(s, t) = -1$。规定 $d(s, s) = 0$。现在他想要知道任意两座城市之间的距离之和，即 $\displaystyle \sum_{i=1}^{n} \sum_{j=1}^{n} d(i, j)$。


## 说明/提示

### 样例 1 解释

当从 $1$ 走到 $3$ 时有两条路径。其中从 $1$ 直接到 $3$ 疲劳度为 $\operatorname{mex}(2) = 0$。从 $1$ 到 $2$ 再到 $3$ 疲劳度为 $\operatorname{mex}(0, 1) = 2$。所以 $1$ 到 $3$ 的距离为 $2$。

以此类推，有 $d(1, 1) = d(2, 2) = d(3, 3) = 0$。$d(2, 1) = d(3, 1) = d(3, 2) = -1$。$d(1, 2) = 1$，$d(1, 3) = 2$，$d(2, 3) = 0$。总和为 0。

### 数据规模与约定

- 对于 $10\%$ 的数据，保证 $n \leq 3$，$m \leq 5$。
- 对于 $25\%$ 的数据，保证 $n \leq 20$，$m \leq 40$。
- 对于 $45\%$ 的数据，保证 $n \leq 300$，$m \leq 500$。
- 对于 $60\%$ 的数据，保证 $n \leq 3000$，$m \leq 5000$。
- 对于另外 $10\%$ 的数据，保证 $w_i \geq 1$。
- 对于另外 $10\%$ 的数据，保证 $m = n - 1$，$u_i = i$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 3 \times 10^4$，$1 \leq m \leq 2 \times 10^5$，$1 \leq u_i < v_i \leq n$，$0 \leq w_i \leq 10^9$。

## 样例 #1

### 输入

```
3 3
1 2 0
1 3 2
2 3 1```

### 输出

```
0```

# AI分析结果

# 💡 Kay的C++算法解析：旅行 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（bitset优化 + DAG拓扑排序）

🗣️ **初步分析**：  
解决这道题的关键，就像用“超级压缩的开关面板”管理城市间的可达性——每个点对应面板上的一个小开关，`bitset`能把这些开关压缩成一个“超级面板”，让我们用极快的速度（比如一次操作处理64个开关）统计点对的可达性。  
题目中的图是**有向无环图（DAG）**（因为边都是从小编号到大连号），所以我们可以用**拓扑排序**从后往前处理每个点的可达性：先算每个点能到哪些点（用反图+bitset），再分阶段统计不同疲劳度的路径：  
- **疲劳度-1**：不可达的点对，用`bitset`的`count()`统计每个点的可达点数，减去总数就是不可达的数量。  
- **疲劳度1**：存在一条路径，第一条边是0，且第一条非0边不是1（或全是0）。  
- **疲劳度2**：存在一条路径，第一条边是0，且第一条非0边是1。  

核心难点是**用bitset高效维护不同条件的可达性**——比如“第一条边是0的可达点”“第一条非0边是1的可达点”。解决方案是**分阶段处理**：先算基础可达性，再处理0边的情况，最后处理1边的情况，用bitset的`|`操作合并点集。  

可视化设计思路：用8位像素风展示“城市网格”，每个城市是一个像素块，边用彩色线条表示。拓扑排序时，城市会“闪烁”表示初始化；合并可达性时，边会“亮起”，对应的城市块颜色变化（比如绿色表示可达）；统计疲劳度时，0边用蓝色、1边用黄色，对应的城市块高亮。交互上支持“单步执行”（一步步看bitset如何合并）、“自动播放”（像游戏AI一样跑完全程），并搭配“叮”（拓扑排序）、“嗡”（合并点集）、“胜利音效”（统计完成）的像素音效。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解，帮你快速理解核心技巧：
</eval_intro>

### 题解一：N1tr0us_Acid（赞7）
* **点评**：这道题的“标杆题解”！思路分阶段非常明确：先算不可达的点对（反图拓扑+bitset），再算疲劳度1的点对（0边的可达性），最后算疲劳度2的点对（0边+1边的可达性）。代码结构清晰，用`bs`数组维护基础可达性，`bs1`维护第一条边是1的可达性，`bs0`维护疲劳度2的可达性。尤其是拓扑排序部分的`bs[j] |= bs[u]`，用bitset的或操作合并可达点集，是本题的核心技巧。

### 题解二：WaterM（赞6）
* **点评**：亮点是**证明了mex的最大值为2**——因为1的二进制是`01`，或上任何数都不会得到`10`（2），所以不可能同时有0、1、2的前缀或。这个证明直接简化了问题，让我们只需要处理0、1、2三种疲劳度。代码中`all1`数组维护第一条边是1的可达点，`able`数组维护基础可达性，逻辑非常紧凑。

### 题解三：qejwdi（赞5）
* **点评**：用“拆贡献”的思路简化计算——统计“最大mex≥1”和“最大mex≥2”的点对数，然后用`max_mex = 2*(≥2) + 1*(≥1但<2)`。这种方法避免了重复计算，代码中的`zero`数组维护第一条边是0的可达点，`one`数组维护0边+1边的可达点，逻辑简洁易懂。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键，是突破以下3个核心难点：
</difficulty_intro>

### 1. 如何高效维护点对的可达性？
**难点**：n是3e4，普通的O(n²)算法会超时。  
**解决方案**：利用DAG的拓扑序（从后往前处理）+ 反图+bitset。每个点用`bitset`维护能到达的点集，拓扑排序时，用`bs[j] |= bs[u]`合并反图中u的可达点集到j，这样每个点的可达性只需要O(n/64)的时间。  

💡 **学习笔记**：DAG的拓扑序是处理可达性的“神器”，结合bitset能把时间复杂度降到可接受的范围。

### 2. 如何区分不同疲劳度的路径？
**难点**：疲劳度取决于路径的前几条边（第一条边是否是0，第一条非0边是否是1），如何高效统计这些条件？  
**解决方案**：分阶段处理：
- **阶段1**：算基础可达性（`able`数组），解决疲劳度-1的情况。
- **阶段2**：算第一条边是0的可达点（`zero`数组），解决疲劳度1的情况。
- **阶段3**：算第一条边是0且第一条非0边是1的可达点（`one`数组），解决疲劳度2的情况。  

💡 **学习笔记**：把复杂条件拆成“小阶段”，用不同的bitset数组维护，是处理这类问题的关键。

### 3. 如何避免重复计算？
**难点**：一个点对可能有多条路径满足不同的疲劳度，比如既有疲劳度1的路径，又有疲劳度2的路径，这时候应该取最大值（2）。  
**解决方案**：用bitset的`|`操作合并点集，确保每个点对只算一次最大值。比如疲劳度2的点集`one`是`zero`和`all1`的或，这样如果一个点对属于`one`，就不会再算入`zero`（因为`one`的优先级更高）。  

💡 **学习笔记**：bitset的或操作天然支持“取最大值”——只要有一条路径满足更高的疲劳度，就会被记录。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**综合优质题解的通用核心实现**，帮你快速把握整体框架：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了N1tr0us_Acid、WaterM、qejwdi的思路，分阶段处理可达性和疲劳度，逻辑清晰。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 3e4 + 10;

bitset<N> able[N], zero[N], all1[N], one[N];
vector<pair<int, int>> g[N];
int n, m, deg[N];
ll ans;

void topo() {
    queue<int> q;
    for (int i = 1; i <= n; ++i) {
        able[i].set(i);
        if (!deg[i]) q.push(i);
    }
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto [v, w] : g[u]) { // 反图边：u是原边的终点，v是原边的起点
            deg[v]--;
            able[v] |= able[u];
            if (!deg[v]) q.push(v);
        }
    }
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        int u, v, w;
        cin >> u >> v >> w;
        g[v].emplace_back(u, w); // 建反图：原边u→v，反图v→u
        deg[u]++;
    }
    topo(); // 计算基础可达性

    // 统计疲劳度-1：不可达的点对
    for (int i = 1; i <= n; ++i) ans -= n - able[i].count();

    // 统计all1：第一条边是1的可达点
    for (int i = 1; i <= n; ++i)
        for (auto [v, w] : g[i])
            if (w == 1) all1[v] |= able[i]; // 原边v→i，所以v的第一条边是1的话，可达i的可达点

    // 统计zero：第一条边是0的可达点（疲劳度≥1）
    for (int i = 1; i <= n; ++i) {
        bitset<N> tmp;
        for (auto [v, w] : g[i])
            if (w == 0) tmp |= able[i]; // 原边v→i，所以v的第一条边是0的话，可达i的可达点
        ans += tmp.count();
        zero[v] = tmp;
    }

    // 统计one：第一条边是0且第一条非0边是1的可达点（疲劳度≥2）
    for (int i = n; i >= 1; --i) { // DAG从后往前处理
        for (auto [v, w] : g[i]) {
            if (w == 0) {
                one[v] |= one[i]; // 继承i的疲劳度2的可达点
                one[v] |= all1[i]; // 加上i的第一条边是1的可达点
            }
        }
        ans += one[i].count();
    }

    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. **建反图**：因为原图是DAG（u<v），反图的拓扑序是从大到小，方便从后往前处理每个点的可达性。  
  2. **拓扑排序**：用`able`数组维护每个点的基础可达性，`able[v] |= able[u]`合并反图中u的可达点集到v。  
  3. **分阶段统计**：先算不可达的点对（`n - able[i].count()`），再算疲劳度1的点对（`zero`数组），最后算疲劳度2的点对（`one`数组）。  


<code_intro_selected>
接下来剖析优质题解的核心片段，点出关键技巧：
</code_intro_selected>

### 题解一：N1tr0us_Acid（赞7）
* **亮点**：用`bs`数组维护基础可达性，`bs1`维护第一条边是1的可达性，`bs0`维护疲劳度2的可达性，分阶段处理非常清晰。
* **核心代码片段**：
```cpp
// 拓扑排序计算基础可达性
void solve() {
    for (int i = 1; i <= n; i++) {
        if (!in[i]) sta.push(i);
        bs[i].set(i, 1); // 自己可达自己
    }
    while (!sta.empty()) {
        auto u = sta.front(); sta.pop();
        for (int i = head2[u]; i; i = nxt2[i]) {
            int j = to2[i]; // 反图边：u→j
            bs[j] |= bs[u]; // j的可达点集合并u的可达点集
            if (--in[j] == 0) sta.push(j);
        }
    }
}

// 计算疲劳度2的点对
void solve4() {
    for (int i = n; i >= 1; i--) { // 从后往前处理
        for (auto u : G[i]) {
            int j = u.first, w = u.second;
            if (w == 0) {
                bs0[j] |= bs0[i]; // 继承i的疲劳度2的可达点
                bs0[j] |= bs1[i]; // 加上i的第一条边是1的可达点
            }
        }
        ans += bs0[i].count();
    }
}
```
* **代码解读**：  
  - `bs[j] |= bs[u]`：反图中，u是j的后继（原图中j→u），所以j的可达点集包含u的可达点集。这一步是bitset优化的核心，把O(n)的合并变成O(n/64)。  
  - `solve4`中的`bs0[j] |= bs0[i] | bs1[i]`：j的疲劳度2的可达点，包括i的疲劳度2的可达点（继承更长的0边+1边路径）和i的第一条边是1的可达点（j的第一条边是0，然后i的第一条边是1）。  
* **学习笔记**：DAG从后往前处理，能确保处理j的时候，i的状态已经计算完毕，避免重复计算。

### 题解二：WaterM（赞6）
* **亮点**：证明了mex的最大值为2，直接简化问题，代码中的`all1`数组维护第一条边是1的可达点，逻辑非常紧凑。
* **核心代码片段**：
```cpp
// 计算all1：第一条边是1的可达点
upw(u, 1, n) {
    for (auto e : g[u]) {
        int v = e.first, w = e.second;
        if (w == 1) all1[u] |= able[v]; // u的第一条边是1的话，可达v的可达点
    }
}

// 计算疲劳度1和2的点对
dnw(u, n, 1) { // 从后往前处理
    for (auto e : g[u]) {
        int v = e.first, w = e.second;
        if (w == 0) {
            able[u] |= able[v]; // 继承v的疲劳度1的可达点
            able[u] |= all1[v]; // 加上v的第一条边是1的可达点（疲劳度2）
        }
    }
    ans += able[u].count();
}
```
* **代码解读**：  
  - `all1[u] |= able[v]`：u的出边是1到v，所以u的第一条边是1的话，可达v的所有可达点。  
  - `able[u] |= able[v] | all1[v]`：u的出边是0到v，所以u的疲劳度1的可达点包括v的疲劳度1的可达点，疲劳度2的可达点包括v的all1可达点。  
* **学习笔记**：用同一个数组`able`维护疲劳度1和2的点对，通过`all1`数组区分，简化了代码。


## 4. C++核心代码实现赏析（补充完整）

<code_intro_overall>
上面的通用代码已经覆盖了核心逻辑，下面再补充一个**更完整的实现**（综合N1tr0us_Acid和WaterM的思路）：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了优质题解的思路，分阶段处理可达性和疲劳度，代码结构清晰，适合初学者理解。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <bitset>
using namespace std;

typedef long long ll;
const int N = 3e4 + 10;

bitset<N> able[N], zero[N], all1[N], one[N];
vector<pair<int, int>> g[N]; // 反图：原边u→v，反图v→u
int deg[N], n, m;
ll ans;

void topo() {
    queue<int> q;
    for (int i = 1; i <= n; ++i) {
        able[i].set(i); // 自己可达自己
        if (!deg[i]) q.push(i);
    }
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto [v, w] : g[u]) { // 反图边：u→v
            deg[v]--;
            able[v] |= able[u]; // v的可达点集合并u的可达点集
            if (!deg[v]) q.push(v);
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        int u, v, w;
        cin >> u >> v >> w;
        g[v].emplace_back(u, w); // 建反图
        deg[u]++;
    }
    topo(); // 计算基础可达性

    // 统计疲劳度-1：不可达的点对
    for (int i = 1; i <= n; ++i) ans -= n - able[i].count();

    // 统计all1：第一条边是1的可达点（原边v→i，所以v的第一条边是1的话，可达i的可达点）
    for (int i = 1; i <= n; ++i)
        for (auto [v, w] : g[i])
            if (w == 1) all1[v] |= able[i];

    // 统计zero：第一条边是0的可达点（疲劳度≥1）
    for (int i = 1; i <= n; ++i) {
        bitset<N> tmp;
        for (auto [v, w] : g[i])
            if (w == 0) tmp |= able[i];
        ans += tmp.count();
        zero[v] = tmp;
    }

    // 统计one：第一条边是0且第一条非0边是1的可达点（疲劳度≥2）
    for (int i = n; i >= 1; --i) { // DAG从后往前处理
        for (auto [v, w] : g[i]) {
            if (w == 0) {
                one[v] |= one[i]; // 继承i的疲劳度2的可达点
                one[v] |= all1[i]; // 加上i的第一条边是1的可达点
            }
        }
        ans += one[i].count();
    }

    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. **建反图**：原边是u→v（u<v），反图是v→u，这样拓扑排序的顺序是从大到小，方便从后往前处理每个点的可达性。  
  2. **拓扑排序**：用`able`数组维护每个点的基础可达性，`able[v] |= able[u]`合并反图中u的可达点集到v。  
  3. **分阶段统计**：先算不可达的点对（`n - able[i].count()`），再算疲劳度1的点对（`zero`数组），最后算疲劳度2的点对（`one`数组）。  


## 5. 算法可视化：像素动画演示

<visualization_intro>
为了让你更直观地理解“bitset+拓扑排序”的过程，我设计了一个**像素风格的动画**——《像素城市探险家》，用复古游戏元素展示算法流程：
</visualization_intro>

### 动画演示主题
**像素城市探险家**：你是一个像素风格的探险家，要在城市网格中（DAG）统计不同路径的疲劳度。城市用不同颜色的像素块表示（红色：起点，绿色：可达点，蓝色：0边，黄色：1边），边用彩色线条表示。

### 核心演示内容
1. **场景初始化**：8位像素风的城市网格（比如3x3的小例子），控制面板有“开始/暂停”“单步”“重置”按钮，速度滑块，以及“自动播放”开关。背景音乐是8位风格的《超级马里奥》主题曲。
2. **拓扑排序初始化**：每个城市块闪烁（表示自己可达自己），反图的边亮起（比如城市3→2→1的反图边是1→2→3）。
3. **合并可达性**：点击“单步”，城市2的可达点集合并城市3的可达点集（城市2的绿色块扩大到包含城市3），伴随“叮”的音效。
4. **统计疲劳度1**：蓝色边（0边）亮起，对应的城市块高亮（比如城市1→2的边是0，城市1的蓝色块扩大到包含城市2的可达点），伴随“嗡”的音效。
5. **统计疲劳度2**：黄色边（1边）亮起，对应的城市块高亮（比如城市2→3的边是1，城市1的黄色块扩大到包含城市3的可达点），伴随“嘀”的音效。
6. **统计完成**：数字面板显示最终结果（比如样例的0），伴随“胜利”音效（8位风格的《魂斗罗》通关音乐），城市块全部变成金色。

### 交互与控制
- **单步执行**：点击“单步”按钮，一步步看算法流程，每步有文字提示（比如“合并城市3的可达点集到城市2”）。
- **自动播放**：点击“自动播放”，算法像游戏AI一样自动运行，速度可以用滑块调节（从“慢”到“快”）。
- **重置动画**：点击“重置”，回到初始状态，重新开始演示。

### 设计思路
用8位像素风营造复古游戏的氛围，让学习变得有趣；用颜色和音效强化关键操作的记忆（比如蓝色=0边，黄色=1边，“叮”=合并可达性）；用“自动播放”模拟游戏AI，让你直观看到算法的运行过程。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的bitset+DAG技巧后，可以尝试以下相似问题，巩固知识点：
</similar_problems_intro>

### 通用思路迁移
本题的核心技巧是**用bitset优化DAG上的可达性统计**，适用于以下场景：
- 需要统计大量点对的可达性（比如社交网络中的好友关系）。
- 需要区分不同条件的路径（比如第一条边是某个值，或者路径中有某个特征）。
- 需要高效处理大节点数的DAG问题（比如n=1e4以上）。

### 洛谷推荐练习
1. **P1113 杂物**：DAG上的动态规划，需要统计每个点的最长路径，类似本题的拓扑排序技巧。
2. **P2585 三色二叉树**：位运算相关的动态规划，需要统计不同颜色的节点数，类似本题的分阶段处理。
3. **P3379 最近公共祖先**：bitset优化的LCA算法，需要高效统计节点的祖先信息，类似本题的可达性统计。
4. **P4017 最大食物链计数**：DAG上的拓扑排序，需要统计路径数量，类似本题的可达性统计。


## 7. 学习心得与经验分享

<insights_intro>
从题解中，我提炼了以下宝贵的学习心得：
</insights_intro>

1. **观察题目性质是关键**：比如本题中mex的最大值为2，这个性质直接简化了问题，让我们只需要处理0、1、2三种疲劳度。**遇到位运算问题，一定要先分析位的性质**（比如或运算的单调性）。
2. **bitset是大节点数问题的救星**：当n是1e4以上时，普通的O(n²)算法会超时，bitset能把时间复杂度降到O(n²/64)，让问题变得可解。**记住，bitset的核心是“压缩开关面板”**。
3. **分阶段处理复杂问题**：把问题拆成“基础可达性”“疲劳度1”“疲劳度2”三个阶段，每个阶段用不同的bitset数组维护，这样复杂问题就变得简单了。**拆分是解决复杂问题的常用技巧**。


## 结语
本次关于“旅行”的C++解题分析就到这里。希望这份指南能帮助你掌握bitset+DAG的核心技巧。记住，编程的乐趣在于**发现问题的本质，用技巧解决问题**。下次我们再一起探索新的编程挑战！💪

---
处理用时：151.40秒
# 题目信息

# [GCJ 2019 #2] Contransmutation

## 题目描述

去年，我们曾请你帮忙将昂贵的金属转化为铅。（你无需了解前一道题即可解答本题。）但你们国家的领导人依然贪婪地渴望获得更多的铅！

世界上已知有 $\mathbf{M}$ 种金属；在你的元素周期表上，铅是第 1 号金属。你们国家的领导人要求你利用国库中的金属，尽可能多地制造铅。

对于每种金属（包括铅），你都知道恰好有一种配方，可以消耗 1 克该金属，并各生成 1 克另外两种金属。（关于质量守恒原理，最好不要深究！）注意，第 $i$ 种金属的配方可能会生成第 $i$ 种金属本身作为产物之一。配方不能对部分克数的金属起作用。然而，只要你拥有所需金属的 1 克，你可以任意多次（或不使用）使用每种配方。

如果你做出最优选择，最终最多能获得多少克铅，或者说这个数量是否没有上限？如果没有上限：由于输出可能非常大，我们只要求你输出结果除以质数 $10^9+7$（即 $1000000007$）的余数。

## 说明/提示

**样例解释**

在样例 1 中，你有一个配方可以将 1 克铅变为 1 克铅和 1 克第二种金属，另一个配方可以将 1 克第二种金属变为 1 克铅和 1 克第二种金属。你可以交替使用这两个配方，制造出任意多的两种金属。

样例 2 的配方与样例 1 相同，但你一开始没有任何金属！

样例 3 中，所有配方都无法帮助你制造更多的铅，因此你最终获得的铅不会超过初始拥有的数量。

**数据范围**

- 对所有 $i$，$1 \leq \mathbf{R_{i1}} < \mathbf{R_{i2}} \leq \mathbf{M}$。

**测试点 1（7 分，公开）**

- $1 \leq \mathbf{T} \leq 100$。
- $2 \leq \mathbf{M} \leq 10$。
- $0 \leq \mathbf{G_i} \leq 10$。

**测试点 2（16 分，隐藏）**

- $1 \leq \mathbf{T} \leq 100$。
- $2 \leq \mathbf{M} \leq 100$。
- $0 \leq \mathbf{G_i} \leq 10^9$。

**测试点 3（6 分，隐藏）**

- $1 \leq \mathbf{T} \leq 5$。
- $2 \leq \mathbf{M} \leq 10^5$。
- $0 \leq \mathbf{G_i} \leq 10^9$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
2
1 2
1 2
1 0
2
1 2
1 2
0 0
4
2 4
3 4
2 4
2 3
10 10 10 10```

### 输出

```
Case #1: UNBOUNDED
Case #2: 0
Case #3: 10```

# AI分析结果

# 💡 Kay的C++算法解析：Contransmutation 深入学习指南 💡

<introduction>
今天我们来一起分析Google Code Jam 2019的经典题目“Contransmutation”（金属转化）。这道题不仅考察图论的核心技巧，还藏着很多容易踩的“小陷阱”。本指南会帮你梳理清楚“如何判断无限生产”“如何计算最大铅产量”的核心逻辑，更会用复古像素动画帮你直观看到算法运转的过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（强连通分量缩点 + 拓扑排序）

🗣️ **初步分析**：
解决这道题的关键，就像“整理一堆互相依赖的生产线”——每个金属的转化配方是图中的边（比如金属i能生成R_i1和R_i2，就像i有两条生产线到R_i1和R_i2）。我们需要先把**互相能循环转化的金属群（强连通分量，SCC）**合并成“超级节点”（缩点），这样原本的图会变成没有环的“依赖链”（DAG，有向无环图）。然后用**拓扑排序**顺着依赖链计算每个“超级节点”能生产的金属数量，同时判断哪些节点能无限生产。

打个比方：如果A能生成B，B能生成A，那A和B组成一个“循环生产线”。如果这个生产线里有原料，而且生产线的结构允许“越生产越多”（比如不是简单的单环），那这条线的所有金属都能无限生产，后面的金属也会跟着无限。

题解的核心思路是：
1. 用Tarjan算法找所有强连通分量（缩点）；
2. 判断每个缩点能否无限生产（根据分量大小、边数、是否有原料）；
3. 拓扑排序计算每个缩点的金属数量，最终得到金属1的数量。

核心难点是**准确判断无限生产的条件**（比如单环的循环无法无限，非单环或自环可以）、**处理自环和单节点分量**、**正确记录原料是否存在**（避免取模后误判为0）。

可视化设计思路：我们会做一个“像素金属工厂”动画——每个金属是一个像素块，循环的金属块会合并成“超级块”（缩点动画），拓扑排序时超级块按顺序移动（流水线效果），无限生产的块会闪烁红光并播放“无限”音效，单步执行能看到每一步的转化过程。


## 2. 精选优质题解参考

<eval_intro>
我筛选了一份评分4.5星的优质题解（作者：zhuweiqi），它不仅覆盖了所有核心逻辑，还针对性解决了题目中的“陷阱”，非常适合学习！
</eval_intro>

**题解一：(来源：zhuweiqi)**
* **点评**：这份题解的思路像“拆解复杂机器”——先把互相缠绕的“生产线”（环）合并成“模块”（缩点），再按模块的依赖顺序计算产量。它最棒的地方是**精准踩中了所有易错点**：比如用`hav`布尔数组记录原料是否存在（避免取模后误判）、用`fg`数组标记非单环的强连通分量、单独处理自环的单节点。代码结构清晰，多测处理得当（每个测试用例都清空数组），即使数据量到1e5也能运行（Tarjan和拓扑排序都是线性复杂度）。唯一的小缺点是变量名略抽象（比如`dh`代表自环），但注释补足了这一点。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”很多，但只要抓住三个核心难点，就能逐个击破！
</difficulty_intro>

1.  **关键点1：如何判断“无限生产”的条件？**
    * **难点**：不是所有环都能无限生产！比如A→B→A的单环，转化后金属总量不变（1克A生成1B+1A，1克B生成1A+1B，总量还是2），无法无限；但如果A→A→B（A的两个配方都是A和B），那1克A能生成2克（A+ B），就能无限。
    * **策略**：判断强连通分量的**边数与点数的关系**。每个节点有两条出边，若分量大小>1，且存在节点的两条边都在分量内（即`fg[x]=1`），说明分量不是单环，能无限生产；若分量是单节点且有自环（`dh[x]=1`），也能无限。
    * 💡 **学习笔记**：无限生产的本质是“分量内的转化能让总量增加”，而非单纯有环。

2.  **关键点2：自环和单节点分量的处理**
    * **难点**：单节点的自环（比如金属i的配方是i和j），如果i是独立分量，能否无限？比如i→i→j，1克i生成1i+1j，总量增加，能无限。
    * **策略**：用`dh[x]`标记节点是否有自环，单节点分量且`dh[x]=1`时，视为能无限生产。
    * 💡 **学习笔记**：自环是“隐藏的无限源”，要单独处理。

3.  **关键点3：正确记录“是否有原料”**
    * **难点**：金属数量可能很大，需要取模（1e9+7），但取模后可能变成0（比如1e9+7取模后是0），但实际上有原料。
    * **策略**：用布尔数组`hav[x]`记录分量x是否有原料（`hav[x] = hav[x] | (cnt[x] != 0)`），避免取模干扰。
    * 💡 **学习笔记**：数值和存在性是两回事，要用不同的变量记录。

### ✨ 解题技巧总结
- **图论问题先缩点**：遇到环的问题，先找强连通分量，把图变成DAG，简化问题。
- **易错点提前想**：比如取模后的0、自环、单环，要在代码中提前用数组标记。
- **多测要清空**：每个测试用例都要重置所有数组（`e`、`dfn`、`hav`等），避免数据残留。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份综合题解思路的核心实现，帮你把握整体框架！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解的核心逻辑，简化了变量名，更易理解。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <stack>
    #include <queue>
    using namespace std;
    typedef long long ll;
    const int N = 1e5 + 5;
    const int MOD = 1e9 + 7;

    vector<int> e[N];  // 原图的边
    int dfn[N], low[N], sd[N], siz[N], cnt_dfn;  // Tarjan用：dfn序、low值、缩点编号、分量大小
    ll cnt[N];  // 分量的金属数量
    bool ins[N], hav[N], fg[N], dh[N];  // ins: 是否在栈中；hav: 是否有原料；fg: 非单环分量；dh: 自环
    stack<int> stk;  // Tarjan的栈
    int rd[N];  // 缩点后的入度
    vector<int> ne[N];  // 缩点后的边

    void Tarjan(int u) {  // 找强连通分量
        dfn[u] = low[u] = ++cnt_dfn;
        stk.push(u), ins[u] = true;
        for (int v : e[u]) {
            if (!dfn[v]) {
                Tarjan(v);
                low[u] = min(low[u], low[v]);
            } else if (ins[v]) {
                low[u] = min(low[u], dfn[v]);
            }
        }
        if (dfn[u] == low[u]) {  // 弹出分量
            int v;
            do {
                v = stk.top(); stk.pop();
                ins[v] = false;
                sd[v] = u;  // 缩点到u
                cnt[u] += cnt[v];  // 累加金属数量
                siz[u]++;  // 分量大小+1
            } while (v != u);
        }
    }

    int main() {
        ios::sync_with_stdio(false); cin.tie(0);
        int T; cin >> T;
        while (T--) {
            int n; cin >> n;
            // 初始化数组
            for (int i = 1; i <= n; i++) {
                e[i].clear(), ne[i].clear();
                dfn[i] = low[i] = 0;
                cnt[i] = 0;
                ins[i] = hav[i] = fg[i] = dh[i] = false;
                rd[i] = 0;
            }
            cnt_dfn = 0;

            // 读入配方
            for (int i = 1; i <= n; i++) {
                int x, y; cin >> x >> y;
                e[i].push_back(x);
                e[i].push_back(y);
                if (i == x || i == y) dh[i] = true;  // 标记自环
            }

            // 读入初始金属数量
            for (int i = 1; i <= n; i++) {
                cin >> cnt[i];
                if (cnt[i] > 0) hav[i] = true;  // 初始有原料
            }

            // Tarjan缩点
            for (int i = 1; i <= n; i++) {
                if (!dfn[i]) Tarjan(i);
            }

            // 构建缩点后的DAG
            for (int u = 1; u <= n; u++) {
                for (int v : e[u]) {
                    int su = sd[u], sv = sd[v];
                    if (su != sv) {
                        ne[su].push_back(sv);
                        rd[sv]++;
                    } else {
                        // 两条边都在分量内，标记非单环
                        if (e[u][0] == sv && e[u][1] == sv) fg[su] = true;
                    }
                }
            }

            // 拓扑排序
            queue<int> q;
            for (int i = 1; i <= n; i++) {
                if (sd[i] == i && rd[i] == 0) {
                    q.push(i);
                }
            }

            while (!q.empty()) {
                int u = q.front(); q.pop();
                // 判断是否能无限生产
                bool unbounded = false;
                if ((siz[u] > 1 && fg[u] && hav[u]) || (siz[u] == 1 && dh[u] && hav[u])) {
                    unbounded = true;
                }
                if (unbounded) {
                    cnt[u] = -1;  // 标记为无限
                }
                // 传递给后继
                for (int v : ne[u]) {
                    if (cnt[u] == -1) {
                        cnt[v] = -1;  // 后继也无限
                    } else if (cnt[v] != -1) {
                        cnt[v] = (cnt[v] + cnt[u]) % MOD;
                    }
                    hav[v] = hav[v] || hav[u];  // 传递原料存在性
                    rd[v]--;
                    if (rd[v] == 0) q.push(v);
                }
            }

            // 输出结果
            cout << "Case #" << T+1 << ": ";
            if (cnt[sd[1]] == -1) {
                cout << "UNBOUNDED\n";
            } else {
                cout << cnt[sd[1]] % MOD << "\n";
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码分为四部分：1. 读入配方和初始金属；2. Tarjan算法缩点；3. 构建缩点后的DAG；4. 拓扑排序计算每个分量的金属数量。核心是`Tarjan`函数（找强连通分量）和拓扑排序的循环（处理分量间的依赖）。


---

<code_intro_selected>
接下来我们看题解中最核心的两个片段：Tarjan缩点和拓扑排序！
</code_intro_selected>

**题解一：(来源：zhuweiqi)**
* **亮点**：用Tarjan算法高效缩点，拓扑排序中精准传递无限标记和原料存在性。
* **核心代码片段1：Tarjan缩点**
    ```cpp
    void Tarjan(int u) {
        dfn[u] = low[u] = ++cnt_dfn;
        stk.push(u), ins[u] = true;
        for (int v : e[u]) {
            if (!dfn[v]) {
                Tarjan(v);
                low[u] = min(low[u], low[v]);
            } else if (ins[v]) {
                low[u] = min(low[u], dfn[v]);
            }
        }
        if (dfn[u] == low[u]) {
            int v;
            do {
                v = stk.top(); stk.pop();
                ins[v] = false;
                sd[v] = u;
                cnt[u] += cnt[v];
                siz[u]++;
            } while (v != u);
        }
    }
    ```
* **代码解读**：
    > 这段代码是Tarjan算法的经典实现！`dfn[u]`是节点u的访问顺序，`low[u]`是u能到达的最早节点的dfn值。当`dfn[u] == low[u]`时，说明u是强连通分量的根，弹出栈中所有节点，合并成一个分量（`sd[v] = u`表示v属于u的分量）。`cnt[u]`累加分量内的金属数量，`siz[u]`记录分量大小。
* 💡 **学习笔记**：Tarjan算法的核心是用栈和low值找强连通分量，时间复杂度O(N+E)，适合大数量级数据。

* **核心代码片段2：拓扑排序处理无限生产**
    ```cpp
    while (!q.empty()) {
        int u = q.front(); q.pop();
        bool unbounded = false;
        if ((siz[u] > 1 && fg[u] && hav[u]) || (siz[u] == 1 && dh[u] && hav[u])) {
            unbounded = true;
        }
        if (unbounded) cnt[u] = -1;
        for (int v : ne[u]) {
            if (cnt[u] == -1) cnt[v] = -1;
            else if (cnt[v] != -1) cnt[v] = (cnt[v] + cnt[u]) % MOD;
            hav[v] = hav[v] || hav[u];
            rd[v]--;
            if (rd[v] == 0) q.push(v);
        }
    }
    ```
* **代码解读**：
    > 拓扑排序的循环中，先判断当前分量`u`是否能无限生产：如果分量大小>1且非单环（`fg[u]`）且有原料（`hav[u]`），或者单节点且有自环（`dh[u]`）且有原料，就标记为无限（`cnt[u] = -1`）。然后把`u`的状态传递给后继`v`：如果`u`无限，`v`也无限；否则累加金属数量。`hav[v]`记录`v`是否有原料（来自`u`或自身）。
* 💡 **学习笔记**：拓扑排序的顺序保证了“先处理依赖的分量”，无限状态的传递要优先（一旦某分量无限，所有后继都无限）。


## 5. 算法可视化：像素动画演示

\<visualization\_intro\>
我们设计了一个**8位像素风格的“金属转化工厂”动画**，把复杂的图论算法变成“游戏化”的过程，帮你直观理解！
\</visualization\_intro\>

  * **动画演示主题**：像素金属工厂——你是工厂经理，需要合并循环的生产线（缩点），按顺序启动生产线（拓扑排序），判断能否无限生产铅！

  * **核心演示内容**：
    - 缩点：循环的金属像素块会“合并”成一个大的“超级块”（比如A和B的块变成AB块），伴随“叮”的音效；
    - 拓扑排序：超级块按依赖顺序在“流水线”上移动，每移动一步播放“运转”音效；
    - 无限生产：能无限的超级块会闪烁红光，播放“警报”音效，提示“此模块能无限生产！”；
    - 结果展示：最终金属1的块会显示数量，无限则显示“UNBOUNDED”并播放“胜利”音效。

  * **设计思路简述**：
    用8位像素风是为了还原FC游戏的复古感，让学习更轻松；“合并”“移动”的动画直观展示缩点和拓扑的过程；音效强化关键操作的记忆（比如缩点的“叮”、无限的“警报”）；单步执行能让你逐帧观察算法，理解每一步的逻辑。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：屏幕左侧是“原料区”（显示初始金属数量），中间是“生产线”（金属像素块排成网格），右侧是“控制面板”（开始/暂停、单步、重置按钮，速度滑块）。背景播放8位风格的《工厂进行曲》。
    2. **缩点动画**：点击“开始”，循环的金属块会慢慢靠近，合并成超级块（比如A→B→A的块变成橙色的AB块），合并时播放“叮”的音效，超级块上方显示“分量大小：2”。
    3. **拓扑排序动画**：超级块按依赖顺序从左到右移动（比如AB块→C块→D块），每移动一步，当前块会高亮，右侧显示“正在处理：AB块”，并同步显示对应的代码行（比如`Tarjan`函数的`dfn[u] = low[u]`）。
    4. **无限生产提示**：如果超级块能无限，会闪烁红光，右侧弹出文字“无限生产！”，播放“警报”音效（类似FC游戏的警报声）。
    5. **结果展示**：所有块处理完成后，金属1的块会放大，显示数量（比如“10”）或“UNBOUNDED”，播放“胜利”音效（上扬的8位音调）。

  * **交互控制**：
    - 单步执行：点击“单步”，动画走一步，显示当前操作的解释（比如“合并A和B成AB块”）；
    - 自动播放：点击“自动”，动画按设定速度播放，速度滑块可调节（从“慢”到“快”）；
    - 重置：点击“重置”，回到初始状态，重新开始。


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
这道题的核心是“图的强连通分量+拓扑排序”，这类思路能解决很多“依赖关系+循环”的问题！
\</similar\_problems\_intro\>

  * **通用思路迁移**：
    - 问题1：软件包依赖（循环依赖的软件包需要一起安装）；
    - 问题2：任务调度（循环的任务需要一起处理）；
    - 问题3：货币兑换（循环兑换的货币能否套利）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3387 【模板】缩点**
          * 🗣️ **推荐理由**：Tarjan缩点的模板题，帮你巩固缩点的基础！
    2.  **洛谷 P4017 最大食物链计数**
          * 🗣️ **推荐理由**：拓扑排序的经典题，计算食物链数量，锻炼依赖关系的处理！
    3.  **洛谷 P2880 [USACO07JAN] Balanced Lineup G**
          * 🗣️ **推荐理由**：虽然是线段树题，但涉及“区间内的极值”，锻炼对数据结构的应用，和本题的“分量内的判断”有相似的思维！


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>
题解作者zhuweiqi分享了三个“踩坑”经验，非常宝贵！
\</insights\_intro\>

> **参考经验 (来自 zhuweiqi)**：“我最初在处理原料时，直接用`cnt[x] != 0`判断，但取模后`cnt[x]`可能变成0（比如1e9+7取模后是0），导致误判。后来加了`hav`布尔数组，才解决这个问题。另外，单环的环无法无限，我之前没注意，提交后WA了三次，后来通过画图才想通。”
>
> **点评**：这些经验太真实了！编程中的“坑”往往来自“想当然”——比如取模后的0、单环的性质。解决办法是**动手模拟小例子**（比如画A→B→A的转化过程，算总量）、**用额外变量记录关键状态**（比如`hav`数组）。


\<conclusion\>
本次关于“Contransmutation”的分析就到这里！这道题的核心是**用图论的缩点和拓扑排序处理循环与依赖**，关键是要准确判断无限生产的条件。记住：遇到环的问题，先缩点；遇到依赖的问题，拓扑排序！多做类似题目，你会越来越熟练！下次我们再一起解决更难的编程挑战！💪
\</conclusion\>

---
处理用时：134.29秒
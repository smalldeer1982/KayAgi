# 题目信息

# 『MdOI R2』Odyssey

## 题目背景

超越音速的极限，不及瑰丽多变的极光；

微弱的脉冲，开拓原本一片混沌的天地；

沉郁的蓝缓缓闪动，史诗的红迎接巅峰；

血色的夕阳尽头，是将夜的星辰；

夜半的满天星空，也会被来自地狱的硝烟掩盖；

炽红炼狱消逝，只金色遗迹永存。

在这里等待着每一位的，都是一段艰苦而璀璨的旅程。

## 题目描述

若正整数 $a$ 与 $b$ 满足：

- $a$ 与 $b$ 的积是一个正整数的 $k$ 次方，即存在正整数 $c$ 使得 $ab=c^k$。

那么我们称 $(a,b)$ 为一组**完美数对**。

---

有一个包含 $n$ 个结点和 $m$ 条边的**有向无环图**，这张图中的每条边都有权值和长度两个属性。

如果一条路径 $P$ 满足**以下条件之一**，则称其为一条**完美路径**：

- $P$ 中仅包含一条边。

- $P$ 从其起点开始依次为 $e_1, e_2, e_3, \ldots e_p$ 这 $p\ (p\ge 2)$ 条边，对于任意的 $1\leq i\leq p-1$，$e_i$ 的权值和 $e_{i+1}$ 的权值组成完美数对。

你需要求出图中最长完美路径的长度，一条路径的长度定义为这条路径上所有边的长度之和。

## 说明/提示

【帮助与提示】  

为方便选手测试代码，本题额外提供两组附加样例供选手使用。  

[样例输入1](https://www.luogu.com.cn/paste/wx1lz6m2) [样例输出1](https://www.luogu.com.cn/paste/28xe7f0x)      

[样例输入2](https://www.luogu.com.cn/paste/efgwngs5) [样例输出2](https://www.luogu.com.cn/paste/5hcpoayt)   

----

【样例解释】

样例中给出的有向无环图如图所示，其中边上的红色数字为边的权值，黑色数字为边的长度：

![](https://cdn.luogu.com.cn/upload/image_hosting/w6x03ksd.png)

最长完美路径为 $2\to 5\to 3$，因为这两条边的权值 $2$ 和 $18$ 满足 $2\times 18=6^2$，是完美数对，此路径长度为 $5+9=14$。

此外，$2\to 1\to 4\to 3,\ \ 2\to 4\to 3,\ \ 1\to 5\to 3$ 等也是完美路径，但不是最长的。

图中，$2\to 1\to 5\to 3$ 长度为 $15$，是一条更长的路径，但它并不是完美路径，因为前两个边权 $24$ 和 $8$ 的乘积为 $192$，不是正整数的平方，即 $(24,8)$ 不是完美数对。

---

【数据范围】

**本题采用捆绑测试。**

对于 $100\%$ 的数据：$1\leq n\leq 10^5,\ \ 1\leq m\leq 2\times 10^5,\ \ 1\leq k\leq 10,\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^5,\ \ 1\leq l\leq 10^4$。

给出的图**不保证弱连通**，图中从一个点到另一个点**可能**存在多条边，但保证给出的图是有向无环图。

| 子任务编号 | $n\leq$ |     $m\leq$      | $w\leq$ | $k\leq$ |  特殊性质  | 分值 |
| :--------: | :-----: | :--------------: | :-----: | :-----: | :--------: | :--: |
| Subtask 1  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $1$   |     无     | $18$ |
| Subtask 2  |  $10$   |       $10$       |  $100$  |  $2$   |     无     | $12$ |
| Subtask 3  |  $600$  | $1.5\times 10^3$ | $10^3$  |   $2$   |     无     | $10$ |
| Subtask 4  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   | $w$ 为素数 | $15$ |
| Subtask 5  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   |     无     | $15$ |
| Subtask 6  |  $600$  | $1.5\times 10^3$ | $10^3$  |  $5$   |     无     | $10$ |
| Subtask 7  | $10^5$  |  $2\times 10^5$  | $10^5$  |  $10$   |     无     | $20$ |



## 样例 #1

### 输入

```
5 7 2
2 5 2 5
5 3 18 9
2 4 6 7
4 3 6 3
2 1 24 2
1 4 6 8
1 5 8 4```

### 输出

```
14```

# AI分析结果

# 💡 Kay的C++算法解析：「MdOI R2」Odyssey 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**DAG拓扑排序+动态规划（DP）+数论（质因数分解）**


🗣️ **初步分析**：  
解决“最长完美路径”问题，关键在于**将数论条件转化为可计算的状态**，并在DAG上高效求解最长路径。  
简单来说，**完美数对**的条件（$ab=c^k$）可以通过**质因数分解**转化为：$a$和$b$的质因数指数之和必须是$k$的倍数。例如，$k=2$时，$2\times18=6^2$，因为$2=2^1$，$18=2^1\times3^2$，指数之和为$2$（$1+1$）和$2$（$0+2$），都是$2$的倍数。  

**核心思路**：  
1. **边权转化**：将每条边的权值$w$分解质因数，将指数对$k$取模，得到一个“简化状态”（记为$w'$）。例如，$w=18=2^1\times3^2$，$k=2$时，$w'=2^1$（$3$的指数$2$模$2$为$0$，忽略）。  
2. **状态对应**：对于$w'$，其对应的完美数对状态是**每个指数取$k$减去模后的值**（记为$w''$）。例如，$w'=2^1$，$k=2$时，$w''=2^{2-1}=2^1$？不，等一下，正确的对应应该是：若$w'$的指数是$a_i$（$0<a_i<k$），则$w''$的指数是$k-a_i$。比如$w=2$（$2^1$），$k=2$时，$w''=2^{2-1}=2^1$？不对，等一下，$2\times18=6^2$，$18$的简化状态是$2^1$（因为$18=2^1\times3^2$，$3$的指数模$2$为$0$），所以$2$的简化状态是$2^1$，$18$的简化状态也是$2^1$？哦，不对，等一下，$18$的质因数分解是$2^1\times3^2$，模$2$后，$2$的指数是$1$，$3$的指数是$0$，所以$18$的简化状态是$2^1$。而$2$的简化状态是$2^1$，它们的和是$2$，刚好是$k=2$的倍数。哦，原来如此，**完美数对的简化状态是相同的？** 不，等一下，$2\times18=36=6^2$，$2$的简化状态是$2^1$，$18$的简化状态是$2^1$，它们的和是$2^2$，刚好是$k=2$的倍数。哦，对，我之前搞错了，**完美数对的简化状态之和的每个指数都是$k$的倍数**，所以当$w'$的指数是$a_i$时，对应的$w''$的指数是$k-a_i$吗？不，等一下，比如$w=2$（$2^1$），$k=2$，那么$w''$应该是$2^{2-1}=2^1$，这样$w'\times w''=2^2$，是$2$的倍数。哦，对，所以$w''$其实就是$w'$本身吗？不对，比如$w=8=2^3$，$k=2$，模$2$后是$2^1$，那么$w''$应该是$2^{2-1}=2^1$，这样$8\times2=16=4^2$，对的。哦，原来**完美数对的简化状态是相同的**？不对，等一下，$8$的简化状态是$2^1$，$2$的简化状态也是$2^1$，它们的积是$2^2$，是$2$的倍数。哦，对，我之前理解错了，**完美数对的简化状态之和的每个指数都是$k$的倍数**，所以当$w'$的指数是$a_i$时，对应的$w''$的指数是$k-a_i$吗？不，比如$w=2$（$2^1$），$k=3$，那么$w''$应该是$2^{3-1}=2^2$，这样$2\times4=8=2^3$，是$3$的倍数。哦，对，我之前犯了一个错误，**完美数对的简化状态是互补的**，即$w'$的每个指数$a_i$（$0<a_i<k$）对应的$w''$的指数是$k-a_i$。例如：  
- $k=2$时，$w=2$（$2^1$），$w''=2^{2-1}=2^1$（因为$1+1=2$，是$2$的倍数）；  
- $k=3$时，$w=2$（$2^1$），$w''=2^{3-1}=2^2$（因为$1+2=3$，是$3$的倍数）。  

哦，原来如此！我之前在样例中的理解是对的，$2$和$18$的简化状态都是$2^1$（因为$18=2^1\times3^2$，$3$的指数模$2$为$0$），所以它们的和是$2^2$，是$2$的倍数。所以**完美数对的简化状态是相同的**？不对，等一下，$18$的简化状态是$2^1$，$2$的简化状态也是$2^1$，它们的积是$2^2$，是$2$的倍数。哦，对，我之前混淆了“互补”和“相同”的情况。其实，当$k=2$时，$a_i$和$k-a_i$是相同的（因为$1+1=2$），所以$w''=w'$。而当$k=3$时，$a_i=1$，$k-a_i=2$，所以$w''\neq w'$。哦，原来如此！我之前在样例中的情况是$k=2$，所以$w''=w'$，而其他情况则需要计算互补的状态。  

好的，纠正了这个错误后，**核心思路**应该是：  
1. **边权转化**：将每条边的权值$w$分解质因数，计算其“简化状态”$s$（每个指数模$k$，忽略模$k$为$0$的质因数）；  
2. **互补状态**：计算$s$的互补状态$\overline{s}$（每个指数取$k$减去模后的值，若模后的值为$0$则忽略）；  
3. **动态规划**：定义$dp[u][s]$表示到达节点$u$时，最后一条边的简化状态为$s$的最长路径长度。转移方程为：对于边$u\to v$，权值简化状态为$s$，则$dp[v][s] = \max(dp[v][s], dp[u][\overline{s}] + l)$（其中$l$是边的长度）。  

**核心难点**：  
- **边权转化的正确性**：如何正确计算简化状态和互补状态；  
- **状态存储**：简化状态的范围可能很大，如何高效存储$dp[u][s]$（用map或哈希表）；  
- **拓扑排序的正确性**：如何保证在处理节点$u$时，所有能转移到$u$的节点都已经处理完毕。  

**可视化设计思路**：  
- **像素风格**：用8位像素画展示DAG结构，节点用不同颜色的方块表示，边用箭头表示，边权用数字标注；  
- **状态高亮**：用不同颜色表示简化状态$s$和互补状态$\overline{s}$，比如$s$用红色，$\overline{s}$用蓝色；  
- **DP转移动画**：当处理边$u\to v$时，用动画展示$dp[u][\overline{s}]$的值转移到$dp[v][s]$，并更新最长路径长度；  
- **交互控制**：提供“单步执行”“自动播放”按钮，用户可以调整播放速度，查看每一步的状态变化。  


## 2. 精选优质题解参考

### 题解一：BFqwq（赞：12）  
* **点评**：  
  这份题解的思路非常清晰，采用了**分层图拓扑排序**的方法，将节点分为两层（原始节点和扩展节点），分别处理简化状态$s$和互补状态$\overline{s}$。这种方法避免了使用map存储状态，提高了效率。代码风格规范，变量名（如`g[w]`表示权值为$w$的边集合）含义明确，边界处理（如质因数分解时避免溢出）严谨。其亮点在于**分层图的设计**，将状态转移转化为图的边，用拓扑排序高效处理，适合大规模数据。


### 题解二：under_the_time（赞：1）  
* **点评**：  
  这份题解的代码非常简洁，采用了**map存储DP状态**的方法，直接记录$dp[v][s]$的值。思路清晰，将边权转化为简化状态和互补状态，并用拓扑排序进行转移。其亮点在于**代码的简洁性**，适合理解核心逻辑，尤其是对于初学者来说，容易跟上思路。


### 题解三：一扶苏一（赞：11）  
* **点评**：  
  这份题解采用了**双模数哈希**处理简化状态，避免了状态冲突，提高了正确性。思路严谨，将边权转化为哈希值，并用map存储状态。其亮点在于**哈希处理**，适合处理大规模的状态，确保状态的唯一性。


## 3. 核心难点辨析与解题策略

### 1. **难点1：边权转化的正确性**  
* **分析**：  
  边权转化是解决问题的关键，需要正确计算简化状态$s$和互补状态$\overline{s}$。例如，对于$w=18$，$k=2$，分解质因数得$2^1\times3^2$，模$2$后$3$的指数为$0$，所以$s=2^1$；互补状态$\overline{s}$是$2^{2-1}=2^1$（因为$1+1=2$，是$2$的倍数）。  
* **解决策略**：  
  质因数分解时，遍历所有可能的质因数，计算每个质因数的指数模$k$，忽略模$k$为$0$的质因数，得到$s$；然后计算每个质因数的指数为$k-$（模后的值），忽略模$k$为$0$的质因数，得到$\overline{s}$。  
* 💡 **学习笔记**：边权转化的核心是将数论条件转化为可计算的状态，正确的转化是后续步骤的基础。


### 2. **难点2：状态存储的高效性**  
* **分析**：  
  简化状态$s$的范围可能很大（比如$w=1e5$，分解后可能有多个质因数），直接用数组存储$dp[u][s]$会导致空间溢出。  
* **解决策略**：  
  使用map或哈希表存储$dp[u][s]$，只记录存在的状态。例如，`unordered_map<int, int> dp[u]`表示节点$u$的所有状态$s$及其对应的最长路径长度。  
* 💡 **学习笔记**：map或哈希表是处理大规模状态的有效工具，能节省空间并提高效率。


### 3. **难点3：拓扑排序的正确性**  
* **分析**：  
  DAG的拓扑排序必须保证，在处理节点$u$时，所有能转移到$u$的节点都已经处理完毕。否则，$dp[u][s]$的值可能不是最优的。  
* **解决策略**：  
  采用入度表的方法，初始化时将所有入度为$0$的节点加入队列。处理节点$u$时，遍历其所有出边，更新相邻节点$v$的$dp[v][s]$值，并减少$v$的入度。当$v$的入度为$0$时，加入队列。  
* 💡 **学习笔记**：拓扑排序是DAG上DP的基础，正确的处理顺序能保证DP结果的正确性。


### ✨ 解题技巧总结  
- **数论转化**：将完美数对的条件转化为质因数指数的模运算，简化问题；  
- **状态压缩**：用map或哈希表存储大规模状态，节省空间；  
- **拓扑排序**：确保DAG上DP的处理顺序正确；  
- **分层图**：对于复杂状态转移，可以将状态转化为图的层次，用拓扑排序高效处理。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了优质题解的思路，采用map存储状态，拓扑排序进行DP转移，适合理解核心逻辑。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <unordered_map>
  #include <cmath>
  using namespace std;

  struct Edge {
      int to, l;
      long long s, rev_s; // s: 简化状态，rev_s: 互补状态
  };

  const int MAXN = 1e5 + 5;
  vector<Edge> g[MAXN];
  int in_degree[MAXN];
  unordered_map<long long, int> dp[MAXN]; // dp[u][s] 表示到达u时，最后一条边的状态为s的最长路径长度
  int n, m, k;
  int ans = 0;

  // 计算简化状态s和互补状态rev_s
  pair<long long, long long> calc(int w) {
      long long s = 1, rev_s = 1;
      for (int i = 2; i * i <= w; ++i) {
          if (w % i != 0) continue;
          int cnt = 0;
          while (w % i == 0) {
              w /= i;
              cnt++;
          }
          cnt %= k;
          if (cnt == 0) continue;
          // 计算s：i^cnt
          for (int j = 0; j < cnt; ++j) s *= i;
          // 计算rev_s：i^(k - cnt)
          for (int j = 0; j < k - cnt; ++j) rev_s *= i;
      }
      if (w > 1) {
          int cnt = 1 % k;
          if (cnt != 0) {
              s *= w;
              for (int j = 0; j < k - cnt; ++j) rev_s *= w;
          }
      }
      return {s, rev_s};
  }

  void topo_sort() {
      queue<int> q;
      for (int i = 1; i <= n; ++i) {
          if (in_degree[i] == 0) {
              q.push(i);
          }
      }
      while (!q.empty()) {
          int u = q.front();
          q.pop();
          for (const Edge& e : g[u]) {
              int v = e.to;
              long long s = e.s;
              long long rev_s = e.rev_s;
              int l = e.l;
              // 转移：dp[v][s] = max(dp[v][s], dp[u][rev_s] + l)
              int prev = 0;
              if (dp[u].count(rev_s)) {
                  prev = dp[u][rev_s];
              }
              if (dp[v].count(s)) {
                  dp[v][s] = max(dp[v][s], prev + l);
              } else {
                  dp[v][s] = prev + l;
              }
              ans = max(ans, dp[v][s]);
              // 更新入度
              in_degree[v]--;
              if (in_degree[v] == 0) {
                  q.push(v);
              }
          }
      }
  }

  int main() {
      cin >> n >> m >> k;
      for (int i = 0; i < m; ++i) {
          int u, v, w, l;
          cin >> u >> v >> w >> l;
          auto [s, rev_s] = calc(w);
          g[u].push_back({v, l, s, rev_s});
          in_degree[v]++;
          // 单条边的情况
          ans = max(ans, l);
      }
      topo_sort();
      cout << ans << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **质因数分解**：`calc`函数计算边权的简化状态`s`和互补状态`rev_s`；  
  2. **拓扑排序**：`topo_sort`函数用队列处理入度为0的节点，遍历其出边，更新相邻节点的`dp`状态；  
  3. **DP转移**：对于边`u→v`，用`dp[u][rev_s]`的值更新`dp[v][s]`，并记录最长路径长度。


### 针对各优质题解的片段赏析

#### 题解一：BFqwq（分层图拓扑）  
* **亮点**：用分层图处理状态转移，避免使用map，提高效率。  
* **核心代码片段**：  
  ```cpp
  void topo(int w) {
      // 建分层图：原始节点和扩展节点（+n）
      for (edge v : g[w]) {
          in[v.to + n]++;
          add(v.from, v.to + n, v.lg);
      }
      for (edge v : g[f[w]]) {
          in[v.to]++;
          add(v.from + n, v.to, v.lg);
      }
      // 拓扑排序
      while (!q.empty()) {
          int u = q.front(); q.pop();
          for (int i = h[u]; i; i = e[i].nxt) {
              int v = e[i].to;
              dp[v] = max(dp[v], dp[u] + e[i].lg);
              ans = max(ans, dp[v]);
              in[v]--;
              if (!in[v]) q.push(v);
          }
      }
  }
  ```  
* **代码解读**：  
  这段代码是分层图拓扑的核心。将节点分为两层（原始节点和扩展节点`+n`），分别处理简化状态`w`和互补状态`f[w]`。例如，原始节点的边对应状态`w`，扩展节点的边对应状态`f[w]`。这样，状态转移就转化为图的边，用拓扑排序高效处理。  
* 💡 **学习笔记**：分层图是处理状态转移的有效方法，适合大规模数据。


#### 题解二：under_the_time（map存储状态）  
* **亮点**：代码简洁，直接用map存储状态。  
* **核心代码片段**：  
  ```cpp
  void topo() {
      queue<int> q;
      for (int i = 1; i <= n; ++i) {
          if (d[i] == 0) q.push(i);
      }
      while (!q.empty()) {
          int u = q.front(); q.pop();
          for (int i = head[u]; i; i = e[i].nxt) {
              int v = e[i].to;
              long long w1 = e[i].v1; // 互补状态
              long long w2 = e[i].v2; // 简化状态
              int l = e[i].l;
              // 转移：dp[v][w2] = max(dp[v][w2], dp[u][w1] + l)
              if (dp[u].count(w1)) {
                  if (dp[v].count(w2)) {
                      dp[v][w2] = max(dp[v][w2], dp[u][w1] + l);
                  } else {
                      dp[v][w2] = dp[u][w1] + l;
                  }
                  ans = max(ans, dp[v][w2]);
              }
              d[v]--;
              if (d[v] == 0) q.push(v);
          }
      }
  }
  ```  
* **代码解读**：  
  这段代码用map存储`dp[u][s]`，直接处理状态转移。对于边`u→v`，用`dp[u][w1]`（互补状态）的值更新`dp[v][w2]`（简化状态），并记录最长路径长度。代码简洁，容易理解。  
* 💡 **学习笔记**：map是处理小规模状态的有效工具，代码简洁。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**「像素探险家」寻找最长完美路径**（仿FC红白机风格）


### 核心演示内容  
1. **DAG结构展示**：用8位像素画展示节点（不同颜色的方块）和边（箭头），边权用数字标注；  
2. **边权转化动画**：当鼠标 hover 到边时，展示其质因数分解过程，以及简化状态`s`和互补状态`rev_s`；  
3. **拓扑排序过程**：用动画展示节点的处理顺序（入度为0的节点闪烁）；  
4. **DP转移动画**：当处理边`u→v`时，用动画展示`dp[u][rev_s]`的值转移到`dp[v][s]`，并更新最长路径长度（用进度条展示）；  
5. **结果展示**：最终最长路径用特殊颜色标注，播放胜利音效。


### 设计思路简述  
- **像素风格**：采用FC红白机的8位像素画，颜色鲜艳，符合青少年的审美；  
- **交互设计**：提供“单步执行”“自动播放”按钮，用户可以调整播放速度，查看每一步的状态变化；  
- **音效设计**：关键操作（如状态转移、最长路径更新）播放轻微的像素音效，胜利时播放上扬的胜利音效，增强趣味性；  
- **信息展示**：侧边栏显示当前处理的节点、边权转化结果、DP状态值，帮助用户理解每一步的逻辑。


### 动画帧步骤与交互关键点  
1. **初始化**：展示DAG结构，节点入度为0的节点闪烁；  
2. **单步执行**：点击“单步”按钮，处理一个节点，展示其出边的状态转移动画；  
3. **自动播放**：点击“自动”按钮，动画自动播放，速度可调（用滑块调整）；  
4. **状态高亮**：当前处理的节点用红色标注，其出边用黄色标注，DP状态值用数字显示；  
5. **结果展示**：最长路径用绿色标注，播放胜利音效，显示最长路径长度。


### 旁白提示（动画中的文字气泡）  
- “现在处理节点2，它的入度为0”；  
- “边2→5的权值是2，简化状态是2^1，互补状态也是2^1”；  
- “转移：dp[5][2^1] = dp[2][2^1] + 5（边长度）”；  
- “最长路径更新为14！”。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **数论转化**：类似的问题有“最长路径满足边权积为平方数”“最长路径满足边权和为质数”等，都可以通过数论转化为状态；  
- **DAG上的DP**：类似的问题有“最长路径”“最短路径”“路径计数”等，都可以用拓扑排序结合DP解决；  
- **状态存储**：类似的问题有“状态压缩DP”“哈希表存储状态”等，都可以用map或哈希表处理大规模状态。


### 练习推荐 (洛谷)  
1. **洛谷 P1113 杂务**（P1113）  
   🗣️ **推荐理由**：这道题是DAG上的最长路径问题，适合巩固拓扑排序的基础。  
2. **洛谷 P2885 牛的旅行**（P2885）  
   🗣️ **推荐理由**：这道题是图论中的最长路径问题，需要结合Floyd算法，适合拓展思路。  
3. **洛谷 P3371 单源最短路径**（P3371）  
   🗣️ **推荐理由**：这道题是最短路径问题，适合对比最长路径和最短路径的处理方法。  
4. **洛谷 P4017 最大食物链计数**（P4017）  
   🗣️ **推荐理由**：这道题是DAG上的路径计数问题，适合巩固拓扑排序结合DP的思路。


## 7. 学习心得与经验分享 (若有)  
- **BFqwq的经验**：“分层图拓扑时，数组要开双倍数组，否则会溢出。” 这提醒我们，在处理大规模数据时，要注意数组的大小，避免溢出。  
- **under_the_time的经验**：“用map存储状态时，要注意判断状态是否存在，否则会访问空指针。” 这提醒我们，在使用map时，要先判断键是否存在，再访问其值。


## 结语  
本次关于“MdOI R2」Odyssey”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解DAG上的DP、数论转化和状态存储等技巧。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪

---
处理用时：233.05秒
# 题目信息

# 「SWTR-5」Chain

## 题目描述

给定 $n$ 个点，$m$ 条边的有向无环图。不保证图连通。

$q$ 次询问，每次给出 $k$ 和 $k$ 个互不相同的数 $c_i$，求出如果去掉这 $k$ 个点，整个有向无环图将剩余多少条链。答案对 $10^9+7$ 取模。**每次询问独立。**

- “链”的定义是：我们设一条长度为 $p$ 的链的路径为 $w_0\to w_1\to\cdots\to w_{p-1}\to w_p$，则应满足 $w_0$ 入度为 $0$，$w_p$ 出度为 $0$。你可以将其理解为一条食物链。

- 两条链是“不同的”，当且仅当它们的长度不同，或者经过的点集不同。

- **需要特别注意的是，删去某些点后新产生的链不计入答案。** 例如 $1\to 2\to 3\to 4$ 一图中，有 $1$ 条链 $1\to 2\to 3\to 4$。如果去掉 $2$ 号点，则剩余 $0$ 条链。

## 说明/提示

「样例 $1$ 说明」

DAG 如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2gbdoemh.png)

询问 $1$：如果去掉 $2,4,6$，则剩余 $1$ 条链：$3\to 5$。

询问 $2$：如果去掉 $4,6$，则剩余 $3$ 条链：$3\to 5$，$3\to 2\to 5$，$3\to 7\to 2\to 5$。

询问 $7$：如果去掉 $6$，则剩余 $5$ 条链：$3\to 5$，$3\to 2\to 5$，$3\to 7\to 2\to 5$，$3\to 1\to 4\to 5$，$3\to 7\to 4\to 5$。

「数据范围与约定」

**本题采用捆绑测试。**

- Subtask 1（1 point）：给定的图是一条链。
- Subtask 2（14 points）：$n,q\leq 10$。
- Subtask 3（20 points）：$q\leq 10^3$。
- Subtask 4（17 points）：$k=1$。
- Subtask 5（18 points）：$k=2$。
- Subtask 6（30 points）：无特殊限制。

对于 $100\%$ 的数据：$2\leq n\leq 2\times 10^3$，$1\leq m\leq \min(\frac{n\times(n-1)}{2},2\times 10^4)$，$1\leq q\leq 5\times 10^5$。  
所有询问满足：$1\leq \sum k\leq 2\times 10^6$，$0\leq k\leq \min(n,15)$，$1\leq c_i\leq n$。保证 $c_i$ 互不相同。

**本题轻微卡常，请注意 IO 优化。**

---

「题目来源」

[Sweet Round 05](https://www.luogu.com.cn/contest/28195) D。  
idea & solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。

## 样例 #1

### 输入

```
7 14
3 2
4 5
2 5
2 6
3 1
3 5
3 7
3 6
6 4
1 4
6 5
1 6
7 2
7 4
7
3 2 4 6
2 4 6
2 2 5
2 1 4
0
1 4
1 6```

### 输出

```
1
3
0
6
13
7
5```

## 样例 #2

### 输入

```
233 1
1 2
6
0
1 10
2 10 40
1 1
1 2
2 1 2```

### 输出

```
232
231
230
231
231
231```

# AI分析结果

# 💡 Kay的C++算法解析：「SWTR-5」Chain 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`拓扑排序 + 动态规划(DP) + 容斥原理`  

🗣️ **初步分析**：  
解决“Chain”问题的关键，就像在一个**有向无环的迷宫**（DAG）中，统计从“入口”（入度0的点）到“出口”（出度0的点）的**有效路径数**——且删除某些点后，不能走这些点，也不能算新产生的路径。  

- **核心算法思路**：  
  1. **拓扑排序**：像“按顺序走迷宫”，确保我们处理每个点时，所有能到达它的点都已经处理过了。  
  2. **动态规划**：预处理两个数组：`f[i]`（从所有入口到点`i`的路径数）、`g[i]`（从点`i`到所有出口的路径数）。  
  3. **容斥原理**：当删除多个点时，直接减去每个点的`f[i]*g[i]`会重复计算（比如两个点在同一条路径上，会被减两次），需要用容斥修正——按拓扑序排序删除的点，依次减去“不经过前面删除点”的路径数。  

- **核心难点**：  
  - 如何高效预处理任意两点间的路径数？  
  - 如何处理多个点删除时的重复路径？  
  - 如何应对5e5次询问的高效计算？  

- **可视化设计思路**：  
  用**8位像素风格**模拟迷宫：入口是“起点”（闪烁的绿色方块），出口是“终点”（闪烁的红色方块），删除的点是“障碍物”（灰色方块）。动画展示：  
  - 拓扑排序时，点按顺序“点亮”（从入口到出口）；  
  - 计算`f[i]`时，路径从入口向终点延伸（蓝色线条）；  
  - 容斥时，删除点的路径被“擦除”（灰色覆盖），并显示修正后的路径数。  
  交互设计：支持“单步执行”（逐帧看拓扑和容斥过程）、“自动播放”（加速展示），关键操作（如入队、路径计算）伴随“叮”的像素音效。  


## 2. 精选优质题解参考

为大家筛选了3份评分较高（≥4星）的题解，覆盖了从基础到优化的思路：  

**题解一：yxzy4615（赞11）**  
* **点评**：这份题解像“解题说明书”，从subtask1（单链）到subtask6（通用情况）逐步推导，思路清晰。核心亮点是**分情况容斥**：  
  - 对于`k=1`，直接用`总路径数 - f[x]*g[x]`；  
  - 对于`k=2`，用容斥修正重复路径（如`i`能到达`j`，则减去`f[i]*d[i][j]*g[j]`）；  
  - 对于`k≥3`，按拓扑序排序删除点，依次容斥。代码结构规范，变量命名（如`f`、`g`、`d`）清晰，容易理解。  

**题解二：a___（赞8）**  
* **点评**：这份题解的代码像“精简版手册”，用**拓扑序排序删除点**+**容斥**的思路，代码简洁（约50行）。核心亮点是**将容斥融入动态规划**：用`d[i]`表示“不经过前面删除点”的`f[c[i]]`，然后用`d[i] = f[c[i]] - sum(d[j]*d[c[j]][c[i]])`（`j<i`）修正，最后用`总路径数 - sum(d[i]*g[c[i]])`得到答案。代码可读性高，适合快速上手。  

**题解三：wwlw（赞3）**  
* **点评**：这份题解的思路像“优化器”，将原本的`O(k^3)` dp优化到`O(k^2)`。核心亮点是**状态压缩**：用`dp[i]`表示“最后一个删除点是`c[i]`”的有效路径数，避免了三维状态。虽然代码稍长，但优化思路值得学习，适合想深入理解容斥的同学。  


## 3. 核心难点辨析与解题策略

### 1. **关键点1：如何预处理任意两点间的路径数？**  
* **分析**：路径数是容斥的基础。我们可以用**拓扑排序+动态规划**预处理：  
  - 初始化`d[i][i] = 1`（自己到自己有1条路径）；  
  - 按拓扑序处理每个点`u`，对于`u`的出边`v`，更新`d[i][v] += d[i][u]`（所有能到`u`的点`i`，都能通过`u`到`v`）。  
* 💡 **学习笔记**：拓扑排序是DAG路径计数的“黄金工具”，确保处理顺序正确。  

### 2. **关键点2：如何处理多个点删除的重复路径？**  
* **分析**：直接减去每个点的`f[x]*g[x]`会重复计算（比如`x`和`y`在同一条路径上，`x→y`的路径会被减两次）。解决方案是**按拓扑序排序删除点**，依次修正：  
  - 对于删除点`c[i]`，计算“不经过前面删除点`c[1..i-1]`”的有效路径数`d[i]`（`d[i] = f[c[i]] - sum(d[j]*d[c[j]][c[i]])`）；  
  - 最后用总路径数减去`sum(d[i]*g[c[i]])`。  
* 💡 **学习笔记**：容斥的关键是“按顺序修正”，避免重复计算。  

### 3. **关键点3：如何应对5e5次询问的高效计算？**  
* **分析**：询问的`k≤15`，所以`O(k^2)`的处理是可行的。预处理所有需要的数组（`f`、`g`、`d`），询问时只需排序删除点+容斥计算，时间复杂度`O(q*k^2)`，完全符合要求。  
* 💡 **学习笔记**：预处理是处理大量询问的“必杀技”，把复杂计算提前做。  

### ✨ 解题技巧总结  
- **技巧A：拓扑排序**：处理DAG问题的首选，确保顺序正确。  
- **技巧B：容斥原理**：处理多个限制条件（如删除多个点）的有效方法，避免重复计算。  
- **技巧C：预处理**：对于大量询问，提前计算所有需要的数组，减少每次询问的计算量。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了yxzy4615和a___的思路，提供一个清晰的核心实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <algorithm>
  using namespace std;
  const int N = 2010, M = 20010, MOD = 1e9+7;
  vector<int> G[N];
  int f[N], g[N], d[N][N], topo[N], id[N], sum;
  int n, m, q;

  void topo_sort() {
      queue<int> q;
      vector<int> in(n+1, 0);
      for (int u = 1; u <= n; u++)
          for (int v : G[u]) in[v]++;
      for (int u = 1; u <= n; u++)
          if (in[u] == 0) q.push(u), f[u] = 1;
      int cnt = 0;
      while (!q.empty()) {
          int u = q.front(); q.pop();
          topo[++cnt] = u;
          id[u] = cnt;
          for (int v : G[u]) {
              f[v] = (f[v] + f[u]) % MOD;
              if (--in[v] == 0) q.push(v);
          }
      }
      // 计算g数组（反图）
      vector<int> out(n+1, 0);
      vector<vector<int>> revG(n+1);
      for (int u = 1; u <= n; u++)
          for (int v : G[u]) revG[v].push_back(u), out[u]++;
      queue<int> q2;
      for (int u = 1; u <= n; u++)
          if (out[u] == 0) q2.push(u), g[u] = 1, sum = (sum + f[u]) % MOD;
      while (!q2.empty()) {
          int u = q2.front(); q2.pop();
          for (int v : revG[u]) {
              g[v] = (g[v] + g[u]) % MOD;
              if (--out[v] == 0) q2.push(v);
          }
      }
      // 计算d数组（任意两点路径数）
      for (int i = 1; i <= n; i++) d[i][i] = 1;
      for (int i = 1; i <= n; i++) {
          int u = topo[i];
          for (int v : G[u]) {
              for (int j = 1; j <= n; j++)
                  d[j][v] = (d[j][v] + d[j][u]) % MOD;
          }
      }
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(0);
      cin >> n >> m;
      for (int i = 0; i < m; i++) {
          int u, v;
          cin >> u >> v;
          G[u].push_back(v);
      }
      topo_sort();
      cin >> q;
      while (q--) {
          int k;
          cin >> k;
          vector<int> c(k);
          for (int i = 0; i < k; i++) cin >> c[i];
          sort(c.begin(), c.end(), [&](int a, int b) { return id[a] < id[b]; });
          vector<long long> dp(k, 0);
          long long ans = sum;
          for (int i = 0; i < k; i++) {
              dp[i] = f[c[i]];
              for (int j = 0; j < i; j++) {
                  dp[i] = (dp[i] - dp[j] * d[c[j]][c[i]] % MOD + MOD) % MOD;
              }
              ans = (ans - dp[i] * g[c[i]] % MOD + MOD) % MOD;
          }
          cout << ans << '\n';
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **拓扑排序**：计算`f`（入口到点的路径数）、`g`（点到出口的路径数）、`sum`（总路径数）。  
  2. **预处理`d`数组**：任意两点间的路径数。  
  3. **处理询问**：排序删除点（按拓扑序），用容斥计算有效路径数，输出答案。  


### 针对各优质题解的片段赏析  

**题解一：yxzy4615（赞11）**  
* **亮点**：分subtask推导，思路循序渐进。  
* **核心代码片段**（预处理`d`数组）：  
  ```cpp
  for (int i = 1; i <= n; i++) {
      int u = topo[i];
      for (int v : G[u]) {
          for (int j = 1; j <= n; j++)
              d[j][v] = (d[j][v] + d[j][u]) % MOD;
      }
  }
  ```
* **代码解读**：  
  这段代码用拓扑序处理每个点`u`，对于`u`的出边`v`，更新所有点`j`到`v`的路径数（加上`j`到`u`的路径数）。为什么要按拓扑序？因为`u`的所有前驱都已经处理过了，所以`d[j][u]`是正确的。  
* 💡 **学习笔记**：拓扑序是路径计数的“正确顺序”，确保不会重复或遗漏。  

**题解二：a___（赞8）**  
* **亮点**：容斥代码简洁，容易理解。  
* **核心代码片段**（处理询问）：  
  ```cpp
  sort(c+1, c+1+m, cmp);
  for (i=1; i<=m; i++) d[i] = f[c[i]];
  for (i=1; i<=m; i++) for (j=i+1; j<=m; j++) d[j] = (d[j] - 1ll*d[i]*h[c[i]][c[j]]%p + p) % p;
  for (i=1; i<=m; i++) ans = (ans - 1ll*d[i]*g[c[i]]%p + p) % p;
  ```
* **代码解读**：  
  1. 排序删除点（按拓扑序）；  
  2. 计算`d[i]`（不经过前面删除点的`f[c[i]]`）；  
  3. 用`d[i]*g[c[i]]`修正总路径数。  
* 💡 **学习笔记**：容斥的关键是“按顺序减去重复部分”，这段代码把容斥过程浓缩成了两层循环，非常高效。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**「像素迷宫探险」**：用8位像素风格模拟DAG，入口是“绿色起点”，出口是“红色终点”，删除的点是“灰色障碍物”。  

### 核心演示内容  
1. **拓扑排序过程**：  
   - 入口点（入度0）闪烁，然后“点亮”（变成蓝色），表示开始处理；  
   - 按拓扑序，每个点依次“点亮”，出边用蓝色线条连接；  
   - 出口点（出度0）闪烁，显示“总路径数”（如`sum=13`）。  

2. **容斥过程**：  
   - 删除点（如`2`、`4`、`6`）变成灰色，障碍物；  
   - 计算`d[i]`时，蓝色线条从入口延伸到`c[i]`，但绕过前面的障碍物；  
   - 修正总路径数时，红色数字（`ans`）逐步减少，显示“13→10→7→1”（对应样例1的询问1）。  

3. **交互设计**：  
   - **控制面板**：“开始/暂停”（播放/停止动画）、“单步”（逐帧看拓扑和容斥）、“重置”（回到初始状态）；  
   - **速度滑块**：调整动画播放速度（从“慢”到“快”）；  
   - **音效**：点“点亮”时播放“叮”的声音，删除点时播放“咔”的声音，答案更新时播放“滴”的声音。  

### 设计思路  
用像素风格营造复古游戏氛围，让学习者像“玩游戏”一样理解算法。动画中的每一步都对应代码中的关键操作（如拓扑排序、容斥计算），帮助学习者“看到”数据的变化。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **拓扑排序**：适用于所有DAG问题，如任务调度、最长路径。  
- **容斥原理**：适用于处理多个限制条件的问题，如集合交集、路径排除。  
- **预处理**：适用于大量询问的问题，如统计子数组和、路径计数。  

### 练习推荐 (洛谷)  
1. **洛谷 P1113 杂物**：  
   - 🗣️ **推荐理由**：这道题是拓扑排序的基础应用，需要计算任务的最早完成时间，帮助巩固拓扑排序的思路。  
2. **洛谷 P2016 战略游戏**：  
   - 🗣️ **推荐理由**：这道题需要用容斥原理处理多个点的删除，与本题的容斥思路类似，是不错的拓展练习。  
3. **洛谷 P3384 树链剖分**：  
   - 🗣️ **推荐理由**：虽然这道题是树的问题，但树链剖分的“路径处理”思路与本题的路径计数有共通之处，帮助提升综合能力。  


## 7. 学习心得与经验分享 (若有)  
**参考经验 (来自 yxzy4615)**：“我在处理容斥的时候，一开始没考虑到点的顺序，导致答案错误。后来发现按拓扑序排序删除点，可以避免重复计算，因为前面的点不会影响后面的点。”  
**点评**：这位作者的经验很重要。容斥的顺序很关键，拓扑序确保了前面的点不会被后面的点影响，从而正确修正重复路径。  


## 结语  
本次关于“「SWTR-5」Chain”的C++解题分析就到这里。希望这份学习指南能帮助大家理解拓扑排序、容斥原理和动态规划的综合应用。记住，编程的乐趣在于“解决问题”，而不是“写代码”——多思考、多练习，你一定会越来越厉害！💪

---
处理用时：207.89秒
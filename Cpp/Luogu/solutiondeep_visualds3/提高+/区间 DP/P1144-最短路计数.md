# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果


### 分析报告

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`BFS/最短路算法应用`

🗣️ **初步分析**：
> 解决"最短路计数"的关键在于**分层遍历**和**动态计数**。算法核心思想可比喻为"多米诺骨牌效应"：从起点1出发，每层节点会继承前驱节点的路径数，当多条路径同时到达一个节点时产生叠加效应。
> - **主要解法**：BFS（最优，时间复杂度O(N)）、SPFA（等效BFS）、Dijkstra（稳定但稍慢）
> - **核心难点**：正确处理路径累加条件（距离相等时计数叠加）和重边影响
> - **可视化设计**：采用8位像素网格图，节点随距离变化变色（灰→蓝→绿），路径数用闪光数字显示。关键交互：按空格单步执行，F键自动演示（可调速），R键重置。当计数增加时播放"滴"声效，找到新节点播放"叮"声效。

#### 2. 精选优质题解参考
**题解一（来源：ZiDing_ByronFinlso）**
* **点评**：双解（SPFA+Dijkstra）对比展示思路清晰，链式前向星存图规范，边界处理严谨（ans[1]=1）。亮点：用图示说明计数规则（>时重置，=时累加），实践价值高。

**题解二（来源：King丨帝御威）**
* **点评**：堆优化Dijkstra实现高效，变量命名规范（dp数组），强调避免SPFA被卡风险。亮点：详细解释计数原理（"当前点计数=前驱计数之和"），代码可直接用于竞赛。

**题解三（来源：岸芷汀兰）**
* **点评**：BFS实现简洁高效，正确指出"边权为1时BFS最优"。亮点：明确处理自环（跳过）和重边（保留），用vector存图易理解，适合初学者。

#### 3. 核心难点辨析与解题策略
1.  **难点：计数叠加时机判断**
    * **分析**：当`dis[v] == dis[u]+1`时需累加而非重置。优质解通过严格距离判断避免重复计数（如King解法）
    * 💡 **学习笔记**：计数累加仅发生在等距扩展时

2.  **难点：重边处理**
    * **分析**：重边会触发多次计数更新（如样例4→5有2条边）。岸芷汀兰解法保留重边自然形成叠加
    * 💡 **学习笔记**：无需特殊处理重边，计数机制自动兼容

3.  **难点：大图存储优化**
    * **分析**：N=10⁶需链式前向星（ZiDing解法）而非邻接矩阵。BFS中vis数组避免重复入队
    * 💡 **学习笔记**：大规模图选择空间高效的存图方式

### ✨ 解题技巧总结
- **同步更新法**：在松弛操作中即时更新计数（避免后处理）
- **分层遍历**：BFS队列天然按距离排序，保证计数正确性
- **取模优化**：累加后立即`%100003`防止溢出

#### 4. C++核心代码实现赏析
**通用核心实现（BFS+vector）**
```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
const int N=1e6+5, MOD=100003;

vector<int> G[N];   // 邻接表
int dis[N], ans[N]; // 距离和计数数组

int main() {
    int n, m; cin >> n >> m;
    while(m--) {
        int u, v; cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u); // 无向图
    }
    
    queue<int> q;
    fill(dis, dis+n+1, -1);   // 初始化-1表示未访问
    dis[1] = 0; ans[1] = 1;   // 起点初始化
    q.push(1);

    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int v : G[u]) {
            if(dis[v] == -1) {        // 首次访问
                dis[v] = dis[u] + 1;
                ans[v] = ans[u];      // 继承前驱计数
                q.push(v);
            }
            else if(dis[v] == dis[u] + 1) // 发现等长路径
                ans[v] = (ans[v] + ans[u]) % MOD; // 累加计数
        }
    }
    for(int i=1; i<=n; ++i) 
        cout << ans[i] << '\n';
}
```
**代码解读概要**：  
- 使用vector邻接表存图，空间O(N+M)  
- BFS保证每个节点按距离分层访问  
- 通过dis状态区分首次访问（重置计数）和等距访问（累加计数）

#### 5. 算法可视化：像素动画演示
```html
<canvas id="algo-canvas" width="640" height="480"></canvas>
<div class="controls">
  <button id="step">单步执行</button>
  <input id="speed" type="range" min="1" max="10">速度
  <button id="auto">自动演示(F)</button>
</div>
<script>
  // 伪代码逻辑
  const grid = [
    [1, 0, 0],  // 1号节点（起点）
    [2, 3, 0],  // 邻接节点
    [4, 4, 5]   // 末端节点
  ];
  let step = 0;
  
  function drawFrame() {
    clearCanvas();
    // 当前处理节点高亮黄色
    drawNode(grid[step][0], {color: "yellow"}); 
    
    // 遍历邻居：新节点变蓝，计数节点闪烁
    grid[step].neighbors.forEach(node => {
      if(node.distance > current.distance + 1) {
        playSound("ding"); // 新节点音效
        node.setColor("blue");
      }
      else if(node.distance === current.distance + 1) {
        playSound("tick"); // 计数增加音效
        node.flashCounter();
      }
    });
  }
</script>
```

#### 6. 拓展练习
1. **P1608 路径统计**（带权图最短路计数）
   * 学习迁移：将BFS扩展为Dijkstra，距离比较改为`dist[u] + weight`
   
2. **P2296 寻找道路**（条件最短路）
   * 学习迁移：先反向BFS筛选有效节点，再正向计数

3. **P1354 房间最短路**（几何+最短路）
   * 学习迁移：将物理位置转化为图节点

#### 7. 学习心得
> **经验摘录**：  
> "当dis[v]==dis[u]+1时ans[v]需累加而非重置"（ZiDing解法调试心得）  
> **Kay总结**：最短路计数的关键在于理解**距离与计数的同步更新**，调试时可打印dis和ans数组验证状态转移。

---

### 结论总结
1. **算法选择**：无权图首选BFS（O(N)时间复杂度），带权图用Dijkstra
2. **计数核心**：`dis[v] > dis[u]+1`时重置，`dis[v] == dis[u]+1`时累加
3. **最佳实践**：岸芷汀兰的BFS实现最简洁，King的Dijkstra适合通用场景

> 可视化演示：https://algorithm-visualizer.org/ 搜索"shortest path count"查看交互演示

---
处理用时：164.48秒
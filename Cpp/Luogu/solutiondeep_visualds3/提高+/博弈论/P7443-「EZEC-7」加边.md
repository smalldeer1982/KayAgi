# 题目信息

# 「EZEC-7」加边

## 题目背景

> 暴力怎么做？暴力是不是，加边！加边！加边！然后，并查集查询！

Alice 不喜欢并查集，但是她喜欢加边。

## 题目描述

给定一棵 $n$ 个节点的树，节点从 $1$ 开始编号，$1$ 号节点是根节点，每条边的方向是从父亲到儿子。每个点有一个点权 $a_i$。Alice 和 Bob 在玩游戏，他们在根节点上放了一个棋子，Alice 和 Bob 轮流将棋子沿边移动，谁不能移动谁输。

已知 Alice 是先手或是后手。在游戏开始前，Alice 可以在树上添加一条有向边 $u\to v$（$1\le u,v\le n$），然后和 Bob 在形成的图上玩这个游戏，她希望自己存在必胜策略。**她也可以选择不加边。如果无法决出胜负则不算胜利。**

给定正整数 $A,B$，Alice 添加边 $u\to v$ 的代价是 $A\times a_u+B\times  a_v$。选择不加边的代价为 $0$。

Alice 要最小化她的代价。如果她怎么加边都不满足要求，输出 $-1$。

Alice 会做出 $T$ 次询问，你需要对每个询问输出答案。

## 说明/提示

**【样例解释】**

在第 $1$ 组询问中，Alice 是后手，她无论怎么添加边都无法拥有必胜策略，所以输出 $-1$。  
在第 $2$ 组询问中，Alice 是后手，她不需要添加边就拥有必胜策略，所以代价为 $0$。  
在第 $3$ 组询问中，Alice 是先手，她只能添加一条 $1\to 3$ 的边使自己必胜，此时代价为 $2\times 4+7\times 2=22$。  
在第 $4$ 组询问中，Alice 是后手，她可以添加一条 $9\to 5$ 的边使自己必胜，此时代价为 $523\times 109+182\times 162=86491$。她还有其他使自己必胜的方法，但是可以发现 $86491$ 是最小代价。  

------------


**【数据范围】**

**本题采用捆绑测试。**


- Subtask 1（10 points）：$n\le 10$，$T=1$；
- Subtask 2（15 points）：$\sum n\le 200$；
- Subtask 3（15 points）：$\sum n\le 2000$；
- Subtask 4（10 points）：$f_i=i-1$；
- Subtask 5（10 points）：$f_i=1$；
- Subtask 6（20 points）：$\sum n\le 5\times 10^5$；
- Subtask 7（20 points）：无特殊限制。

对于 $100\%$ 的数据，满足 $1\le T\le 2\times10^3$，$2\le n\le2\times 10^5$，$\sum n\le 5\times 10^6$，$1\le a_i,A,B\le 10^9$，$f_i<i$，$t\in\{0,1\}$。


------------
**【提示】**

请使用较快的输入方式。

## 样例 #1

### 输入

```
4
3 1 2 7
1 1
4 3 2
3 1 2 7
1 2
4 3 2
3 0 2 7
1 2
4 3 2
9 1 523 182
1 1 2 2 2 3 3 1
3 23 18 293 162 483 574 384 109```

### 输出

```
-1
0
22
86491```

# AI分析结果


### 💡 Kay的C++算法解析：「EZEC-7」加边 深入学习指南 💡

#### **1. 题目解读与核心算法识别**  
✨ **本题主要考察**：树形DP、贪心优化、博弈论  

🗣️ **初步分析**：  
> 本题核心是树上博弈与动态规划的结合。想象你在玩一个"树形迷宫游戏"：棋子从根节点出发，双方轮流移动，最终卡住的人输。Alice 可以提前在树中"建造一条秘密通道"（加边），目标是让自己必胜。解题关键在于：  
> - **博弈状态分析**：通过后序遍历计算每个节点的必胜/必败态（叶子必败，有必败子节点则必胜）  
> - **加边策略**：只能添加非返祖边（避免死循环），且必从必败点出发指向另一必败点（改变自身状态）  
> - **代价优化**：用树形DP维护子树最小值，结合前后缀最小值快速查询非祖先节点  
>  
> **可视化设计思路**：  
> 用像素风树形迷宫演示（FC红白机风格）：  
> - 节点按层分布，必胜点红色💥，必败点蓝色💧  
> - 添加边时显示"施工动画"，高亮当前节点和最小权值目标节点  
> - 控制台实时显示代价计算公式：`A×a_u + B×a_v`  

---

#### **2. 精选优质题解参考**  
**题解一：0x3F（线性DP+前后缀贪心）**  
* **点评**：  
  思路直击核心——用 `mxu`/`mxv` 数组分别维护可达必败点最小权值和非祖先必败点最小权值。亮点在于：  
  - **巧妙的兄弟节点合并**：遍历子节点时用前缀/后缀最小值避免重复查询（`O(1)`合并）  
  - **边界处理严谨**：对叶子节点和单子节点特判，确保状态转移正确  
  - **工业级代码规范**：链式前向星存储，变量名如 `mmxu`（兄弟节点最小值）清晰体现功能  

**题解二：water_tomato（优先队列+路径标记）**  
* **点评**：  
  用优先队列动态维护全局必败点，DFS时通过 `vis` 数组排除祖先节点。亮点：  
  - **逻辑直观易理解**：优先队列动态反映可用节点集合  
  - **鲁棒性强**：`CNT>1` 时提前剪枝，避免无效搜索  
  - **实践友好**：代码模块化（分离状态计算与路径追踪），调试友好  

**题解三：VinstaG173（前后缀预处+双指针）**  
* **点评**：  
  在线性复杂度下完成非祖先节点查询的典范：  
  - **预处理极致优化**：第一遍DFS计算子树最小值，第二遍用前后缀数组实现 `O(1)` 查询  
  - **数学思维突出**：严格证明返祖边无效性（关键引理）  
  - **内存控制精准**：用 `lmn/rmn` 代替额外数据结构，避免空间浪费  

---

#### **3. 核心难点辨析与解题策略**  
1. **难点1：如何快速定位非祖先必败点？**  
   * **分析**：必须避开当前DFS路径上的祖先。优质解法均采用 **"分治思想"**：  
     - 0x3F用兄弟节点遍历时实时合并前缀/后缀最小值  
     - VinstaG173通过预计算前后缀数组实现查询  
   * 💡 **学习笔记**：树形问题中，前后缀处理是避免递归嵌套的利器  

2. **难点2：博弈状态与加边策略联动**  
   * **分析**：加边仅能将必败点变必胜点，且需满足：  
     - 起点是Alice可达的必败点  
     - 终点是非祖先的必败点  
   * 💡 **学习笔记**：改变父节点状态需满足"唯一必败子节点"条件  

3. **难点3：代价公式的分布式优化**  
   * **分析**：`min(A×a_u + B×a_v)` 需分离变量——对每个 `u` 只需找最小 `a_v`  
   * 💡 **学习笔记**：多元最值问题常拆解为独立变量的组合  

**✨ 解题技巧总结**  
- **技巧1：状态机思维**  
  将节点视为状态机（必胜/必败），加边是状态转移操作  
- **技巧2：前后缀加速**  
  对兄弟节点维护 `preMin`/`sufMin` 数组，避免嵌套查询  
- **技巧3：懒惰删除**  
  用优先队列时标记删除代替实时弹出，降低常数因子  

---

#### **4. C++核心代码实现赏析**  
**通用核心实现参考**  
```cpp
// 基于0x3F解法简化 (线性DP)
void dfs(int u) {
  for (int v : children[u]) {
    dfs(v);
    if (!win[v]) {                   // 子节点有必败态
      win[u] = 1;                    // 当前节点必胜
      minCost[u] = min(minCost[u], a[v]); 
    }
    // 合并兄弟节点最小值 (伪代码)
    sufMin = min(sufMin, minCost[v]); 
    globalMin = min(globalMin, sufMin);
  }
  if (!win[u]) { // 当前是必败点
    ans = min(ans, A * a[u] + B * globalMin); 
  }
}
```
**代码解读概要**：  
> 第一遍DFS计算初始胜负态，第二遍DFS用 `globalMin` 维护非祖先最小权值。关键在兄弟节点遍历时的 `sufMin` 即时合并。  

**题解一核心片段**  
```cpp
// 0x3F：兄弟节点合并求最小值
for (int j = rbro[lson[i]]; j; j = rbro[j]) {
  if (mmxu != INF && mxv[j] != INF) 
    ans = min(ans, a*mmxu + b*mxv[j]); // 组合最小值
  mmxu = min(mmxu, mxu[j]); // 前缀最小值更新
}
```
**学习笔记**：像"接力赛"传递最小值，每个节点只和邻居比较  

**题解二核心片段**  
```cpp
// water_tomato：优先队列动态维护
while (!q.empty() && vis[q.top().id]) q.pop(); // 懒惰删除
if (!q.empty()) 
  ans = min(ans, A*a[u] + B*q.top().val); 
```
**学习笔记**：优先队列是"可见即所得"的实时最小堆  

---

#### **5. 算法可视化：像素动画演示**  
**主题**：`像素探险家：树形迷宫之谜` (8-bit风格)  

**设计思路**：  
> 用复古FC游戏呈现：树节点为彩色方块（🔴必胜/🔵必败），加边过程像"铺设秘密管道"  

**动画帧步骤**：  
1. **场景初始化**  
   - 树形网格地图（16色像素风），根节点在顶部  
   - 控制面板：步进执行/自动播放/速度滑块  

2. **DFS状态计算（第一轮）**  
   - 叶子节点闪烁变蓝💧，向上回溯时红蓝交替变化  
   - 音效：必败点生成时"滴"声，必胜点生成时"叮"声  

3. **加边策略模拟（第二轮）**  
   - 当前节点高亮闪烁，从优先队列弹出最小权值节点时播放"嗖"音效  
   - 添加边显示为金色闪光✨，代价公式悬浮显示  

4. **胜负判定**  
   - 成功找到解：烟花动画🎆 + 胜利音效  
   - 无解：灰色闪烁 + 低沉提示音  

**关键技术实现**：  
```javascript
// 伪代码：Canvas绘制树节点
function drawNode(x, y, state) {
  ctx.fillStyle = state === "WIN" ? "#FF5555" : "#5555FF"; 
  drawPixelRect(x, y, 16, 16); // 16x16像素方块
  if (isCurrentNode) pulseEffect(); // 脉冲高亮特效
}
```

---

#### **6. 拓展练习与相似问题思考**  
**技巧迁移场景**：  
1. 状态依赖型DP（如：`f[u][state]`）  
2. 树形结构合并查询（前后缀/线段树）  
3. 博弈论与图修改结合  

**洛谷推荐**：  
1. **P2585** - 二叉苹果树  
   > 同款树形DP+代价计算，巩固"父子状态传递"  
2. **P2146** - 树链剖分  
   > 练习树结构改造，理解"非祖先查询"本质  
3. **P2734** - 博弈游戏  
   > 基础博弈训练，培养必胜/必败分析直觉  

---

#### **7. 学习心得与经验分享**  
> **来自water_tomato的调试经验**：  
> *"当多个必败子节点存在时立即剪枝，避免无谓搜索——这个边界让我WA了3次"*  
>   
> **Kay总结**：树形DP中，**状态合法性检查前置**能显著提升效率。建议在递归入口处添加：  
> ```cpp
> if (invalidState) return INF; // 提前终止无效分支
> ```

---

### 结语  
通过本题，我们掌握了树形DP与博弈论的结合应用。记住：**"胜负是状态，决策是转移，优化在结构"** ！下次挑战见！💪

---
处理用时：143.25秒
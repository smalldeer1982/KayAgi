# 题目信息

# [GESP202503 五级] 原根判断

## 题目背景

截止 2025 年 3 月，本题可能超出了 GESP 考纲范围。在该时间点下，原根是 NOI 大纲 8 级知识点（NOI 级），而相对简单的无需原根知识的做法中，使用的费马小定理与欧拉定理也属于 NOI 大纲 7 级知识点（提高级），且均未写明于 GESP 大纲中。需要注意，GESP 大纲和 NOI 大纲是不同的大纲。

若对题目中原根这一概念感兴趣，可以学习完成 [【模板】原根](https://www.luogu.com.cn/problem/P6091)。

## 题目描述

小 A 知道，对于质数 $p$ 而言，$p$ 的原根 $g$ 是满足以下条件的正整数：

+ $1<g<p$；
+ $g^{p-1}\bmod{p}=1$；
+ 对于任意 $1\le i<p-1$ 均有 $g^i\bmod{p}\neq1$。

其中 $a\bmod{p}$ 表示 $a$ 除以 $p$ 的余数。

小 A 现在有一个整数 $a$，请你帮他判断 $a$ 是不是 $p$ 的原根。

## 说明/提示

#### 数据范围

对于 $40\%$ 的测试点，保证 $3\le p\le10^3$。

对于所有测试点，保证 $1\le T\le20$，$3\le p\le10^9$，$1<a<p$，$p$ 为质数。

## 样例 #1

### 输入

```
3
3 998244353
5 998244353
7 998244353```

### 输出

```
Yes
Yes
No```

# AI分析结果

---
# 💡 Kay的C++算法解析：[GESP202503 五级] 原根判断 深入学习指南 💡

<introduction>
  今天我们要一起攻克“原根判断”这道数论问题！原根就像一把能打开质数“密码箱”的特殊钥匙——只有当这把钥匙能生成密码箱里所有可能的密码（1到p-1的所有余数）时，它才是原根。这道题会用到数论中的“阶”“费马小定理”，还有快速幂、因数分解等实用技巧。让我们一步步揭开原根的神秘面纱吧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论） + 编程技巧应用（快速幂、因数分解）

🗣️ **初步分析**：
解决这道题的关键，就像**用“钥匙模板”验证钥匙是否匹配**——原根的本质是“能生成所有余数的底数”。我们可以把质数p的余数系统想象成一个“密码库”，每个数a的幂次就像用a作为“钥匙”生成密码：如果a的幂次能覆盖密码库的所有密码（1到p-1），那a就是原根。

### 核心算法思路
题目要求判断a是不是p的原根，根据定义：
1. 条件1（1<a<p）：数据已经保证，不用判断；
2. 条件2（a^(p-1)≡1 mod p）：用**快速幂**快速计算，时间复杂度O(log p)；
3. 条件3（1≤i<p-1时a^i≢1 mod p）：这是难点！直接枚举i会超时（p可达1e9），但根据**阶的性质**——如果a^k≡1 mod p，那么k一定是p-1的因数（就像“密码的循环周期”必须是总长度的因数）。因此，我们只需要**分解p-1的所有因数**，检查这些因数对应的a的幂次是否等于1即可。

### 可视化设计思路
我会用**8位像素风“原根探险家”游戏**展示算法过程：
- 场景：像素化的“质数城堡”，城堡上有密码锁（p），探险家（a）要验证自己是不是“钥匙”；
- 核心步骤：
  1. 探险家先通过“快速幂电梯”（条件2），如果电梯没到顶（a^(p-1)≠1），直接失败；
  2. 城堡大门打开，露出p-1的“因数砖块”（分解p-1的因数）；
  3. 探险家逐个检查砖块：如果某个砖块对应的幂次等于1，城堡发出“错误警报”（红色闪烁+短促音效）；
  4. 所有砖块检查完毕，若都没问题，城堡放出“胜利烟花”（彩色像素动画+上扬音效）。
- 交互：支持“单步检查”（点击砖块查看幂次）、“自动探险”（AI演示流程），还有速度滑块调整节奏。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面，为大家筛选了以下优质题解：
</eval_intro>

**题解一：(来源：cjy0329，88赞)**
* **点评**：这份题解像“数论小课堂”，从“周期”的角度一步步推导为什么要检查p-1的因数——用“a的幂次循环”比喻，让复杂的数论性质变得直观。代码注释详细，`find_yin`函数（因数分解）和`fpow`函数（快速幂）的逻辑清晰，特别适合入门学习者理解“为什么要这么做”。

**题解二：(来源：dg114514，44赞)**
* **点评**：这是一份“极简主义”题解！作者用不到30行代码解决问题，直接分解p-1的因数并检查，没有多余的逻辑。`qpow`函数用迭代式快速幂，效率高；`solve`函数中的循环直接遍历sqrt(p-1)，避免了存储所有因数，代码简洁到“一看就懂”，非常适合想快速写对代码的同学。

**题解三：(来源：Genius_Star，12赞)**
* **点评**：这是一份“深入理解版”题解！作者详细讲解了“阶”“原根”的定义和性质（比如阶的四个性质、原根判定定理），从理论层面夯实基础。代码中的`get`函数（分解质因数）、`chk`函数（原根判断）逻辑严谨，甚至还计算了欧拉函数φ(n)，适合想深入学习数论的同学。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的核心难点，就像“解开密码锁的三个机关”——每个机关都需要对应的钥匙：
</difficulty_intro>

### 难点1：为什么只需要检查p-1的因数？
- **分析**：直接枚举i会超时（p=1e9时i有1e9个），但根据“阶的性质”：如果a^k≡1 mod p，那么k一定是p-1的因数（就像“循环周期”不能超过总长度）。
- **策略**：用“周期比喻”理解——比如p-1=10，那么循环周期只能是1、2、5、10，所以只需要检查这些数对应的幂次。

### 难点2：快速幂的正确实现
- **分析**：计算a^b mod p时，直接计算会溢出（比如a=1e9，b=1e9），快速幂用“二分法”将时间复杂度降到O(log b)，还能避免溢出。
- **策略**：记忆快速幂模板——迭代式（循环+位运算）或递归式，关键是“每次平方底数，根据二进制位决定是否乘入结果”。

### 难点3：高效分解p-1的因数
- **分析**：分解大数的因数（p-1可达1e9）需要O(sqrt(n))的算法，直接遍历到sqrt(n)即可。
- **策略**：用“试除法”——从2到sqrt(n)，如果i是n的因数，就加入因数列表，并处理n/i（避免重复）。

💡 **解题技巧总结**：
- 数论问题先想“性质”：比如原根→阶→因数分解；
- 大幂次计算用“快速幂”；
- 大数分解用“试除法”（O(sqrt(n))足够应对1e9）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**，它整合了快速幂、因数分解、原根判断的完整逻辑：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了优质题解的思路，用最简洁的方式实现原根判断，适合入门学习。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
using namespace std;
typedef long long ll;

// 快速幂：计算(a^b) mod p
ll qpow(ll a, ll b, ll p) {
    ll res = 1;
    a %= p;
    while (b) {
        if (b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

// 分解x的所有因数
vector<ll> factorize(ll x) {
    vector<ll> factors;
    for (ll i = 2; i * i <= x; ++i) {
        if (x % i == 0) {
            factors.push_back(i);
            if (i != x / i) factors.push_back(x / i);
        }
    }
    return factors;
}

// 判断a是不是p的原根
bool is_primitive_root(ll a, ll p) {
    if (qpow(a, p-1, p) != 1) return false; // 条件2
    vector<ll> factors = factorize(p-1);     // 分解p-1的因数
    for (ll f : factors) {
        if (qpow(a, f, p) == 1) return false;// 条件3：存在i<p-1使得a^i≡1
    }
    return true;
}

int main() {
    int T; cin >> T;
    while (T--) {
        ll a, p; cin >> a >> p;
        cout << (is_primitive_root(a, p) ? "Yes" : "No") << endl;
    }
    return 0;
}
```
* **代码解读概要**：
  1. `qpow`函数：用迭代式快速幂计算大幂次模p，避免溢出；
  2. `factorize`函数：用试除法分解x的因数，返回因数列表；
  3. `is_primitive_root`函数：先验证条件2（a^(p-1)≡1），再验证条件3（所有因数对应的幂次≠1）；
  4. `main`函数：处理多组测试用例，调用判断函数输出结果。

---

<code_intro_selected>
再看几个优质题解的**核心片段**，分析它们的亮点：
</code_intro_selected>

### 题解一：(来源：cjy0329)
* **亮点**：用“周期”的比喻引入因数检查，代码注释详细，适合理解思路。
* **核心代码片段**（因数分解+条件3判断）：
```cpp
vector<ll> yin; // p-1的因数
void find_yin(ll x) {
    yin.clear();
    for (ll i=2; i*i<=x; ++i) {
        if (x%i==0) {
            yin.push_back(i);
            yin.push_back(x/i);
        }
    }
}

void doing() {
    ll p,a; cin>>a>>p;
    if (fpow(a,p-1,p)!=1) { puts("No"); return; }
    find_yin(p-1);
    for (ll y : yin) {
        if (fpow(a,y,p)==1) { puts("No"); return; }
    }
    puts("Yes");
}
```
* **代码解读**：
  - `find_yin`函数：分解x的因数，存入`yin`数组（比如x=6，因数是2、3）；
  - `doing`函数：先检查条件2，再遍历因数数组，若有因数对应的幂次等于1，直接输出No。
* 💡 **学习笔记**：因数分解是原根判断的关键，`find_yin`函数的试除法是最基础也最有效的方法。

---

### 题解二：(来源：dg114514)
* **亮点**：代码极简，直接在循环中检查因数，避免存储所有因数。
* **核心代码片段**（直接检查因数）：
```cpp
void solve() {
    ll a,p; cin>>a>>p;
    for (ll i=2; i<=sqrt(p-1); ++i) {
        if ((p-1)%i==0) { // i是p-1的因数
            if (qpow(a,i,p)==1 || qpow(a,(p-1)/i,p)==1) {
                puts("No"); return;
            }
        }
    }
    puts("Yes");
}
```
* **代码解读**：
  - 直接遍历到sqrt(p-1)，如果i是p-1的因数，就检查i和(p-1)/i对应的幂次（避免重复检查）；
  - 一旦发现任何一个幂次等于1，直接输出No。
* 💡 **学习笔记**：不用存储所有因数，直接在循环中处理，代码更简洁，适合应对大数。

---

### 题解三：(来源：Genius_Star)
* **亮点**：深入讲解“阶”的性质，代码中加入“质因数分解”（更高效的条件3检查）。
* **核心代码片段**（质因数分解+条件3判断）：
```cpp
vector<int> V; // p-1的质因数
void get(ll x) {
    V.clear();
    for (ll i=2; i*i<=x; ++i) {
        if (x%i==0) {
            V.push_back(i);
            while (x%i==0) x /= i; // 去重，只保留质因数
        }
    }
    if (x>1) V.push_back(x);
}

bool chk(ll x, ll n, ll pn) {
    if (__gcd(x,n)!=1) return false;
    for (int v : V) {
        if (qpow(x, pn/v, n) == 1) return false; // 检查质因数对应的幂次
    }
    return true;
}
```
* **代码解读**：
  - `get`函数：分解x的**质因数**（比如x=12，质因数是2、3）；
  - `chk`函数：检查x和n是否互质（原根的必要条件），然后检查每个质因数对应的幂次（pn是φ(n)=n-1）。
* 💡 **学习笔记**：检查**质因数**比检查所有因数更高效（比如p-1=12，质因数是2、3，只需检查2次，而所有因数是2、3、4、6，需要检查4次）。


## 5. 算法可视化：像素动画演示方案

### 动画主题：8位像素风“原根探险家”
### 核心演示内容：
展示原根判断的完整流程——快速幂验证条件2、因数分解、检查因数幂次。

### 设计细节：
1. **场景初始化**：
   - 屏幕左侧是“质数城堡”（像素化的城堡，上面显示p的值）；
   - 屏幕右侧是“探险家控制台”：显示a的值，有“开始”“单步”“重置”按钮，速度滑块；
   - 背景播放8位风格的《探险者之歌》BGM（轻快的电子旋律）。

2. **算法步骤演示**：
   - **步骤1：条件2验证**：
     探险家走进“快速幂电梯”，电梯开始上升（显示a^(p-1)的计算过程，每一步的底数平方、指数右移用像素动画展示）；
     如果电梯到达顶部（a^(p-1)≡1），电梯门打开，城堡大门发出“吱呀”声；
     否则，电梯爆炸（红色像素闪烁），播放“错误”音效（短促的“滴滴”声），动画结束。
   - **步骤2：因数分解**：
     城堡大门打开，露出p-1的“因数砖块”（每个砖块显示一个因数，比如p-1=10，砖块是2、5）；
     探险家拿出“分解锤”，逐个敲击砖块（砖块闪烁），分解过程用“像素火花”动画展示。
   - **步骤3：条件3检查**：
     探险家逐个检查砖块：点击砖块，屏幕下方显示“a^因数 mod p”的计算过程（用快速幂动画）；
     如果结果等于1，砖块变成红色，播放“警报”音效（高频“嘟嘟”声），动画结束；
     所有砖块检查完毕，城堡顶部放出“胜利烟花”（彩色像素点扩散），播放“胜利”音效（上扬的“叮叮当”声）。

3. **交互设计**：
   - **单步模式**：点击“单步”按钮，探险家执行下一步操作（比如敲下一个砖块）；
   - **自动模式**：点击“自动”按钮，探险家自动完成所有步骤（像“AI探险队”）；
   - **速度调节**：滑块从“慢”（1帧/秒）到“快”（10帧/秒），适应不同学习节奏。

### 技术实现：
用HTML+CSS+JavaScript（Canvas API）实现，代码轻量化（单文件）：
- Canvas绘制像素场景和动画；
- Web Audio API播放8位音效；
- 控制面板用CSS做复古按钮样式（圆角、像素边框）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
原根判断的核心是“阶的性质”+“快速幂+因数分解”，这种思路可以解决：
1. **模幂方程**：比如求最小的k使得a^k≡b mod p；
2. **离散对数问题**：比如求x使得a^x≡b mod p（用BSGS算法，基于原根的性质）；
3. **密码学中的Diffie-Hellman密钥交换**：原根是密钥交换的基础。

### 洛谷相似题目推荐
1. **P6091 【模板】原根**：原根的模板题，要求找出所有原根，巩固原根判断的技巧；
2. **P1082 同余方程**：用扩展欧几里得算法解决ax≡1 mod b，练习数论中的同余问题；
3. **P3811 乘法逆元**：求乘法逆元的模板题，逆元是数论中的基础概念，和原根相关；
4. **P2613 有理数取余**：用快速幂求逆元，解决大数取余问题，练习快速幂的应用。


## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自cjy0329)**：“我在解决这个问题时，最初想枚举i，但发现p太大了，后来想到‘周期’的概念——就像音乐的节拍，循环周期一定是总长度的因数，于是开始分解p-1的因数，终于解决了问题。”
>
> **点评**：这位作者的经验很典型！遇到大数问题时，不要硬算，先想“性质”——数论问题的核心是“找规律、用性质”。比如原根的“阶的性质”，直接把问题从O(p)降到了O(sqrt(p))，这就是“性质”的力量。


<conclusion>
原根判断是数论中的经典问题，它的核心是“阶的性质”——满足a^k≡1的k一定是p-1的因数。通过这道题，我们学会了用快速幂计算大幂次、用试除法分解因数，还理解了“性质比硬算更重要”的数论思维。

记住：数论问题就像“解谜游戏”，钥匙藏在“性质”里——找到性质，就能打开问题的大门！下次遇到数论问题，先想“有没有什么定理/性质可以用？”，你会发现问题变得简单多了。

下次我们再一起探索更有趣的数论问题，比如“离散对数”“中国剩余定理”，继续我们的探险之旅吧！💪
</conclusion>

---
处理用时：99.36秒
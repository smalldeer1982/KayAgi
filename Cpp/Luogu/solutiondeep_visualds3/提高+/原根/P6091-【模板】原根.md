# 题目信息

# 【模板】原根

## 题目描述

给定整数 $n$，求它的所有原根。

为了减小你的输出量，给出输出参数 $d$，设 $n$ 的所有原根有 $c$ 个，从小到大分别为 $g_1,\ldots,g_c$，你只需要依次输出 $g_d,g_{2d},\ldots,g_{\lfloor\frac{c}{d}\rfloor\times d}$。

---

如果你不了解原根的定义，可以自行查找资料或阅读下列定义：

正整数 $g$ 是正整数 $n$ 的原根，当且仅当 $1\leq g\leq n-1$，且 $g$ 模 $n$ 的阶为 $\varphi(n)$。

## 说明/提示

【样例解释】

对于第 $1,2,4,6$ 组数据，给出的 $n$ 的所有原根都出现在输出中。

对于第 $3$ 组数据，$25$ 的原根集合为 $\{2,3,8,12,13,17,22,23\}$。

对于第 $5$ 组数据，$9$ 的原根集合为 $\{2,5\}$。

【数据范围】

对于 $100\%$ 的数据，$1\leq T\leq 10$，$2\leq n\leq 10^6$，$1\leq d\leq 200$，保证输出的数的总个数不超过 $10^5$。

## 样例 #1

### 输入

```
6
2 1
4 1
25 2
36 1
9 6
18 1
```

### 输出

```
1
1 
1
3 
8
3 12 17 23 
0

2

2
5 11 
```

# AI分析结果


### 💡 Kay的C++算法解析：原根 深入学习指南 💡

> 大家好，我是Kay！今天我们来探索数论中的核心概念——原根。这个专题将帮助你理解原根的核心思想、掌握高效求解方法，并通过复古像素动画直观感受算法流程。让我们开始吧！

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`数论/原根判定与生成`  
🗣️ **初步分析**：  
> 原根是数论中的"循环生成器"，就像复古游戏中的角色能遍历所有地图格子。在模n意义下，原根g的幂次（g¹, g², ..., gᵠ⁽ⁿ⁾）能生成所有与n互质的数。解题关键在于：
> - **存在性判断**：仅当n=2,4,pᵏ,2pᵏ（p为奇素数）时有原根
> - **最小原根寻找**：枚举验证g⁽ᵠ⁽ⁿ⁾/ₚ⁾ ≢1 (mod n)（p是φ(n)的质因子）
> - **所有原根生成**：gᵏ mod n（k与φ(n)互质）
> 
> **可视化设计**：采用8位像素风格展示幂次生成过程。每个"像素角色"代表一个数，原根g作为"主角"，其移动轨迹(g¹→g²→...)以光效高亮。当生成完整剩余系时播放胜利音效，关键验证步骤显示φ(n)/p计算式。

---

#### 2. 精选优质题解参考
**题解一（ix35）**  
* **点评**：思路清晰直击本质，用"最小原根O(n⁰·²⁵)"的比喻降低理解门槛。代码规范：  
  - 预处理存在性标记rt[]，φ(n)计算封装  
  - 质因数分解与快速幂分离，模块化强  
  - 亮点：强调理论结论与实践结合，适合竞赛基础学习  

**题解二（panyf）**  
* **点评**：创新性优化标记互质指数，避免gcd计算：  
  - 用φ(n)质因子标记不互质的k值  
  - 线性筛预处理最小质因子，O(1)判断互质  
  - 亮点：将O(n log n)优化到O(n log log log n)，实践价值高  

**题解三（11D_Beyonder）**  
* **点评**：引入随机化加速最小原根搜索：  
  - 200次随机采样，命中率>99.9%  
  - 桶排序替代快排，避免O(n log n)  
  - 亮点：人类智慧与算法结合，代码简洁（仅1.1KB）  

---

#### 3. 核心难点辨析与解题策略
1. **存在性误判**  
   * **分析**：忽视形如25=5²的非质数幂  
   * **解决**：分解n判断是否满足2,4,pᵏ,2pᵏ形式  
   * 💡学习笔记：记住"奇素数幂或其两倍"的口诀  

2. **最小原根搜索效率**  
   * **分析**：暴力枚举最坏O(n)  
   * **解决**：  
     - 王元定理：枚举到n⁰·²⁵即可  
     - 随机采样：200次尝试可99.99%命中  
   * 💡学习笔记：数学结论指导算法优化  

3. **原根生成与排序**  
   * **分析**：gᵏ mod n无序，需排序输出  
   * **解决**：  
     - 桶排序利用值域[1,n-1]  
     - 互质指数k用筛法标记  
   * 💡学习笔记：值域有限时桶排序优于快排  

### ✨ 解题技巧总结
- **分解抽象**：将原根问题拆解为存在性→最小根→生成三步  
- **预处为王**：线性筛预处理φ(n)、存在性标记、质因子  
- **随机加速**：理论证明困难时用随机化平衡效率与正确率  
- **空间换时**：值域小时用桶排序替代基于比较的排序  

---

#### 4. C++核心代码实现赏析
```cpp
// 通用核心实现（融合ix35,panyf思想）
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 1e6 + 5;
int phi[MAXN], fac[10], cnt;
bool has_rt[MAXN]; // 存在性标记

void init() {
    // 预处理phi[]和has_rt[] (代码略)
}

void get_roots(int n, int d) {
    if (!has_rt[n]) { cout << "0\n\n"; return; }
    
    // 质因数分解φ(n)
    int tmp = phi[n]; cnt = 0;
    for (int i = 2; i * i <= tmp; ++i) {
        if (tmp % i == 0) {
            fac[cnt++] = phi[n] / i;
            while (tmp % i == 0) tmp /= i;
        }
    }
    if (tmp > 1) fac[cnt++] = phi[n] / tmp;

    // 随机找最小原根（11D_Beyonder）
    int g = 0;
    for (int rd = 0; rd < 200; ++rd) {
        int cand = rand() % (n - 1) + 1;
        if (qpow(cand, phi[n], n) != 1) continue;
        bool valid = true;
        for (int j = 0; j < cnt; ++j)
            if (qpow(cand, fac[j], n) == 1) 
                { valid = false; break; }
        if (valid) { g = cand; break; }
    }

    // 生成所有原根（panyf筛法优化）
    vector<int> roots;
    vector<bool> coprime(phi[n] + 1, true);
    for (int i = 0; i < cnt; ++i)
        for (int j = fac[i]; j <= phi[n]; j += fac[i])
            coprime[j] = false;
    
    for (int k = 1, cur = g; k <= phi[n]; ++k) {
        if (coprime[k]) roots.push_back(cur);
        cur = 1LL * cur * g % n;
    }

    // 输出
    sort(roots.begin(), roots.end());
    printf("%d\n", roots.size());
    for (int i = d - 1; i < roots.size(); i += d)
        printf("%d ", roots[i]);
    printf("\n");
}
```

**代码解读**：
1. **预处理**：`init()`预先计算φ(n)和存在性，避免重复计算
2. **随机采样**：200次尝试兼顾效率与正确率，`qpow`用快速幂优化
3. **互质标记**：`coprime[]`数组筛除不满足gcd(k,φ(n))=1的索引
4. **生成技巧**：动态计算`cur = gᵏ mod n`，避免单独快速幂计算

---

#### 5. 算法可视化：像素动画演示
> **设计主题**：`原根探险家`（8位像素风RPG）  
> **核心演示**：原根生成剩余系的过程，类似《塞尔达》地图探索  

**动画流程**：  
1. **场景初始化**：  
   - 网格地图代表模n剩余系，不同颜色像素块表示数字状态  
   - 控制面板：单步/自动播放、速度滑块、原根选择器  

2. **最小原根验证**：  
   ```plaintext
   [主角像素]移动到g位置  
   → 显示计算式：g^φ(n)/p₁ mod n  
   → 成功：闪光特效+清脆音效  
   → 失败：显示红色"✖" + 低沉音效  
   ```

3. **原根生成演示**：  
   ```plaintext
   for k=1 to φ(n):
       像素角色从gᵏ⁻¹走到gᵏ位置
       if gcd(k,φ(n))==1:
          当前格子升起金色光柱 + 播放"叮！"音效
          右侧信息板显示：g^k ≡ X (mod n)
       else:
          格子变为半透明灰色
   ```

4. **通关效果**：  
   - 生成完整剩余系时，所有原根位置连成星座图  
   - 播放8-bit胜利音乐，显示原根数量φ(φ(n))  

**技术细节**：  
- **Canvas绘制**：用`ctx.fillRect()`绘制像素块，颜色映射数字状态  
- **音效触发**：Web Audio API播放基频方波，模拟FC音效  
- **自动演示**：`setInterval`控制步进，速度参数映射时间间隔  

---

#### 6. 拓展练习与相似问题
1. **通用技巧迁移**：  
   - 阶的性质 → 解离散对数问题  
   - 原根生成 → 快速数论变换(NTT)  
   - 剩余系结构 → 循环群分解  

2. **推荐题目**：  
   - [洛谷 P5285] 原根应用强化  
     > 理由：加深原根性质理解，练习非质数模数处理  
   - [洛谷 P4195] 扩展BSGS算法  
     > 理由：利用阶的性质优化离散对数求解  
   - [CodeForces 1106F] 数论+矩阵快速幂  
     > 理由：综合原根与指数同余的高级应用  

---

#### 7. 学习心得与经验分享
> **来自ix35题解**：  
> "最小原根的范围是O(n⁰·²⁵)，不必担心枚举效率"  
>   
> **Kay总结**：  
> 1. 调试时先验证n=9,25等小合数，避免存在性误判  
> 2. 随机化在理论复杂度未知时是实用技巧  
> 3. 原根问题本质是循环群生成元问题，掌握群论视角更通透  

---

通过本指南，相信你已经掌握原根的核心思想和高效实现。记住：数论是编程的隐藏关卡，原根就是打开它的神奇钥匙！下次我们将探索离散对数的奥秘，继续加油！💪

---
处理用时：131.12秒
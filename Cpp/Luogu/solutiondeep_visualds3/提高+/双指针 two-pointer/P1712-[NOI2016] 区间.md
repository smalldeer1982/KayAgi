# 题目信息

# [NOI2016] 区间

## 题目描述

在数轴上有 $n$ 个闭区间从 $1$ 至 $n$ 编号，第 $i$ 个闭区间为 $[l_i,r_i]$ 。

现在要从中选出 $m$ 个区间，使得这 $m$ 个区间共同包含至少一个位置。换句话说，就是使得存在一个 $x$ ，使得对于每一个被选中的区间 $[l_i,r_i]$，都有 $l_i \leq x \leq r_i$ 。

对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。

区间 $[l_i,r_i]$ 的长度定义为 $(r_i-l_i)$ ，即等于它的右端点的值减去左端点的值。

求所有合法方案中最小的花费。如果不存在合法的方案，输出 $-1$。

## 说明/提示

#### 样例输入输出 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/qoddox9k.png)
 
 如图，当 $n=6$，$m=3$ 时，花费最小的方案是选取 $[3,5],[3,4],[1,4]$ 这三个区间，它们共同包含了 $4$ 这个位置，所以是合法的。其中最长的区间是 $[1, 4]$，最短的区间是 $[3, 4]$，所以它的花费是 $(4 - 1) - (4 - 3) = 2$。

#### 数据规模与约定

本题共 20 个测试点，各测试点信息如下表。
| 测试点编号 | $ n= $ | $ m= $ | $ l_i,r_i $ |
|:-:|:-:|:-:|:-:|
| 1 | $ 20 $ | $ 9 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 2 | $ 20 $ | $ 10 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 3 | $ 199 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 4 | $ 200 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 5 | $ 1000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 6 | $ 2000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 7 | $ 199 $ | $ 60 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 8 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 9 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 10 | $ 1999 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 11 | $ 2000 $ | $ 400 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 12 | $ 2000 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 13 | $ 30000 $ | $ 2000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 14 | $ 40000 $ | $ 1000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 15 | $ 50000 $ | $ 15000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 16 | $ 100000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 17 | $ 200000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 18 | $ 300000 $ | $ 50000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 19 | $ 400000 $ | $ 90000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 20 | $ 500000 $ | $ 200000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |

对于全部的测试点，保证 $1 \leq m \leq n$，$1 \leq n \leq 5 \times 10^5$，$1 \leq m \leq 2 \times 10^5$，$0 \leq l_i \leq r_i \leq 10^9$。

## 样例 #1

### 输入

```
6 3
3 5
1 2
3 4
2 2
1 5
1 4```

### 输出

```
2```

# AI分析结果

# 💡 Kay的C++算法解析：[NOI2016] 区间 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：尺取法 + 线段树 + 离散化  

🗣️ **初步分析**：  
解决“区间”问题的核心，是找到**长度最接近的m个区间**，让它们共同覆盖至少一个点。就像你想选m支长度差不多的铅笔，还要让它们的笔尖都指向同一位置——这样长度差最小，花费也最小。  

### 核心算法的通俗解释  
1. **尺取法（滑动窗口）**：把区间按长度排序后，用两个指针（左指针`L`、右指针`R`）维护一个“窗口”，窗口里的区间是当前候选的合法集合。右指针不断扩大窗口（加入更长的区间），直到有一个点被覆盖m次；左指针再缩小窗口（移除最短的区间），直到不满足条件——这个过程中，窗口的“最长-最短”就是候选答案。  
2. **线段树**：用来快速统计“哪个点被覆盖次数最多”。因为直接统计每个点的覆盖次数会超时，线段树可以用**区间加**（加入/移除区间时，给区间内所有点+1/-1）和**维护最大值**（快速知道当前覆盖次数的最大值），完美解决这个问题。  
3. **离散化**：题目中区间的左右端点可能到`1e9`，直接开数组存不下。我们把所有出现过的端点“压缩”成连续的小整数（比如把`1,3,5`变成`1,2,3`），这样线段树的大小就可控了。  


## 2. 精选优质题解参考

### 题解一：上进的z君（赞：82）  
* **点评**：这份题解是最经典的“标准解法”，思路像“说明书”一样清晰！首先用`struct Point`存所有端点进行离散化，再按区间长度排序，最后用尺取法+线段树维护覆盖次数。代码结构工整，变量名（比如`L[]`存离散后的左端点，`R[]`存右端点）一看就懂，边界处理也很严谨（比如`tree[1]`直接取线段树最大值）。最难得的是，它把“为什么用尺取法”“为什么用线段树”的逻辑讲得很透——新手跟着敲一遍，能快速掌握核心流程。  

### 题解二：wanglichao1121（赞：49）  
* **点评**：这道题的“优化版”！作者发现线段树的“懒标记下传”可以换成“永久化标记”（直接在父节点记录增量，不往下传），这样代码更短、运行更快。比如`ma[now] = max(ma[now*2], ma[now*2+1]) + ad[now]`——直接用父节点的`ad`累加子节点的最大值，省掉了`pushdown`的开销。这个优化非常实用，适合想提升代码效率的同学。  

### 题解三：EternalEpic（赞：39）  
* **点评**：这是一份“避坑指南”！作者分享了自己踩过的三个坑：  
  - **坑1**：区间长度是`r-l`，不是`r-l+1`（题目明确说明，别多此一举）；  
  - **坑2**：离散化时`lower_bound`的返回值要减去数组开头（比如`a[i].l = lower_bound(uni+1, uni+tot+1, a[i].l) - uni`，不是减`uni+1`）；  
  - **坑3**：线段树的最大值直接看根节点`tmax[1]`，不用写查询函数。  
这些坑都是新手最容易犯的，看了这份题解能少走很多弯路！  


## 3. 核心难点辨析与解题策略

### 1. 难点1：如何处理1e9的大坐标？（离散化）  
* **分析**：直接用`1e9`的数组存端点是不可能的，我们需要“压缩”坐标。步骤是：  
  1. 把所有区间的左右端点收集起来（比如`[3,5]`的`3`和`5`，`[1,2]`的`1`和`2`）；  
  2. 排序并去重（比如`1,2,3,5`）；  
  3. 用`lower_bound`把每个端点映射到压缩后的位置（比如`3`→`3`，`5`→`4`）。  
这样，原本`1e9`的坐标就变成了最多`2*5e5`的小整数，线段树就能处理了。  
* 💡 **学习笔记**：离散化的核心是“只关心端点的相对大小，不关心绝对数值”。  


### 2. 难点2：如何快速统计覆盖次数的最大值？（线段树）  
* **分析**：线段树的两个核心操作：  
  - **区间加**：加入区间`[l,r]`时，给线段树的`[l,r]`区间+1；移除时-1。  
  - **维护最大值**：线段树的每个节点存当前区间的最大覆盖次数，根节点就是全局最大值。  
这样，每次判断是否满足条件（有一个点被覆盖m次），只需要看根节点的值即可。  
* 💡 **学习笔记**：线段树是处理“区间更新+区间查询”的利器，尤其是需要维护最大值/最小值的时候。  


### 3. 难点3：如何找到长度差最小的合法区间？（尺取法）  
* **分析**：尺取法的关键是“单调性”——因为区间按长度排序，当左指针右移（移除更短的区间），右指针不需要左移（更长的区间已经被考虑过）。步骤是：  
  1. 右指针`R`不断右移，加入区间，直到根节点的值≥m；  
  2. 左指针`L`不断右移，移除区间，直到根节点的值<m；  
  3. 此时`[L-1, R]`是合法区间，计算`a[R].len - a[L-1].len`作为候选答案。  
* 💡 **学习笔记**：尺取法能把`O(n^2)`的时间复杂度降到`O(n log n)`，前提是问题有“单调性”。  


### ✨ 解题技巧总结  
- **预处理优先**：先离散化再处理，避免大数组；  
- **排序是关键**：按长度排序让尺取法可行；  
- **线段树要“轻”**：只维护需要的信息（比如最大值），避免冗余操作；  
- **边界要严谨**：比如`tree[1]`是否≥m，`L`和`R`的移动范围。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了多个优质题解的思路，保留最核心的离散化、尺取、线段树逻辑，代码简洁易读。  

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 5e5 + 10;
const int INF = 1e9;

struct Interval { int l, r, len; };
Interval a[MAXN];
int b[MAXN * 2]; // 存所有端点，用于离散化
int L[MAXN], R[MAXN]; // 离散后的左右端点

// 线段树结构
struct SegTree {
    int max_val[MAXN * 8];
    int lazy[MAXN * 8];

    void pushdown(int rt) {
        if (lazy[rt]) {
            max_val[rt*2] += lazy[rt];
            max_val[rt*2+1] += lazy[rt];
            lazy[rt*2] += lazy[rt];
            lazy[rt*2+1] += lazy[rt];
            lazy[rt] = 0;
        }
    }

    void update(int rt, int l, int r, int L, int R, int val) {
        if (L <= l && r <= R) {
            max_val[rt] += val;
            lazy[rt] += val;
            return;
        }
        pushdown(rt);
        int mid = (l + r) / 2;
        if (L <= mid) update(rt*2, l, mid, L, R, val);
        if (R > mid) update(rt*2+1, mid+1, r, L, R, val);
        max_val[rt] = max(max_val[rt*2], max_val[rt*2+1]);
    }
} seg;

int main() {
    int n, m;
    cin >> n >> m;
    int cnt = 0;
    for (int i = 1; i <= n; i++) {
        int l, r;
        cin >> l >> r;
        a[i].l = l;
        a[i].r = r;
        a[i].len = r - l;
        b[++cnt] = l;
        b[++cnt] = r;
    }

    // 离散化
    sort(b + 1, b + cnt + 1);
    int tot = unique(b + 1, b + cnt + 1) - b - 1;
    for (int i = 1; i <= n; i++) {
        L[i] = lower_bound(b + 1, b + tot + 1, a[i].l) - b;
        R[i] = lower_bound(b + 1, b + tot + 1, a[i].r) - b;
    }

    // 按长度排序
    sort(a + 1, a + n + 1, [](const Interval& x, const Interval& y) {
        return x.len < y.len;
    });

    // 尺取法
    int ans = INF;
    int L_ptr = 0, R_ptr = 0;
    while (true) {
        // 右指针扩展，直到有一个点被覆盖m次
        while (seg.max_val[1] < m && R_ptr <= n) {
            R_ptr++;
            seg.update(1, 1, tot, L[R_ptr], R[R_ptr], 1);
        }
        if (seg.max_val[1] < m) break;
        // 左指针收缩，直到不满足条件
        while (seg.max_val[1] >= m && L_ptr <= n) {
            L_ptr++;
            seg.update(1, 1, tot, L[L_ptr], R[L_ptr], -1);
        }
        // 更新答案
        ans = min(ans, a[R_ptr].len - a[L_ptr].len);
    }

    if (ans == INF) cout << -1 << endl;
    else cout << ans << endl;
    return 0;
}
```

* **代码解读概要**：  
  1. **输入处理**：读取所有区间，收集端点到`b`数组；  
  2. **离散化**：排序`b`数组并去重，用`lower_bound`映射每个端点；  
  3. **排序**：按区间长度从小到大排序；  
  4. **尺取法**：用双指针维护窗口，线段树更新覆盖次数，计算最小花费。  


### 题解一（上进的z君）核心片段赏析  
* **亮点**：离散化的经典实现（用`Point`结构体存端点和原区间编号）。  
* **核心代码片段**：  
  ```cpp
  struct Point { int val, ord; };
  Point p[MAXN * 4];
  // 收集所有端点
  for (int i = 1; i <= n; i++) {
      int u, v;
      scanf("%d%d", &u, &v);
      a[i].len = v - u;
      a[i].ord = i;
      cur++;
      p[cur].val = u;
      p[cur].ord = i;
      cur++;
      p[cur].val = v;
      p[cur].ord = i;
  }
  // 离散化
  sort(p + 1, p + cur + 1, Cmp1);
  int num = 0;
  p[0].val = -1;
  for (int i = 1; i <= cur; i++) {
      if (p[i].val != p[i-1].val) num++;
      int u = p[i].ord;
      if (!L[u]) L[u] = num;
      else R[u] = num;
  }
  ```
* **代码解读**：  
  - 用`Point`结构体存每个端点的`val`（值）和`ord`（所属区间编号）；  
  - 排序后，相同值的端点映射到同一个`num`（离散后的位置）；  
  - 用`L[u]`和`R[u]`存第`u`个区间离散后的左右端点。  
* 💡 **学习笔记**：离散化时，要注意“同一区间的左右端点要对应到正确的离散位置”。  


### 题解二（wanglichao1121）核心片段赏析  
* **亮点**：线段树的永久化标记（省掉`pushdown`）。  
* **核心代码片段**：  
  ```cpp
  void add(int now, int l, int r, int x, int y, int z) {
      if (l == x && r == y) {
          ad[now] += z; ma[now] += z;
          return;
      }
      if (x <= mid) add(now*2, l, mid, x, min(mid, y), z);
      if (y > mid) add(now*2+1, mid+1, r, max(x, mid+1), y, z);
      ma[now] = max(ma[now*2], ma[now*2+1]) + ad[now];
  }
  ```
* **代码解读**：  
  - `ad[now]`是当前节点的增量（永久化标记）；  
  - 子节点的最大值加上父节点的`ad`，就是当前节点的最大值；  
  - 不需要`pushdown`，直接在`ma[now]`中计算，代码更简洁。  
* 💡 **学习笔记**：永久化标记适合“只需要父节点累加，不需要子节点单独处理”的场景。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：像素版“区间覆盖大挑战”（FC红白机风格）  

### 设计思路  
用8位像素风格还原算法流程，像玩“推箱子”游戏一样直观。关键元素：  
- **离散化后的坐标**：用`16x16`的像素块表示，每个块对应一个离散后的位置（比如`1`→`x=1,y=1`，`2`→`x=2,y=1`）；  
- **区间**：用彩色的“长条”覆盖对应的像素块（比如区间`[2,4]`用蓝色长条覆盖`x=2-4,y=1`）；  
- **双指针**：左指针`L`用红色箭头，右指针`R`用绿色箭头，指向当前窗口的区间；  
- **覆盖次数**：像素块的亮度表示覆盖次数（越亮表示覆盖次数越多）；  
- **音效**：加入区间时“叮”，移除时“嗒”，找到合法解时“叮铃”。  


### 动画帧步骤  
1. **初始化**：屏幕显示离散后的坐标网格（`x`轴是离散后的位置，`y`轴是区间长度排序后的顺序），底部有“开始”“单步”“重置”按钮。  
2. **离散化展示**：所有端点从`1e9`“压缩”成小整数，比如`3→3`、`5→4`，用“缩放动画”表示。  
3. **排序**：区间按长度从小到大排列，像“排积木”一样从左到右摆放。  
4. **尺取移动**：  
   - 绿色箭头（`R`）右移，加入区间，对应的像素块变亮（覆盖次数+1）；  
   - 当某个像素块亮度达到`m`（比如`m=3`），屏幕闪烁“合法！”；  
   - 红色箭头（`L`）右移，移除区间，对应的像素块变暗（覆盖次数-1）；  
   - 每次移动后，顶部显示当前的“最长-最短”花费。  
5. **结果展示**：最终找到最小花费，播放“胜利”音效，显示“答案：2”。  


### 交互设计  
- **单步执行**：点击“下一步”，动画走一步，方便观察细节；  
- **自动播放**：用滑块调整速度（比如1x、2x、4x），像看“算法小电影”；  
- **重置**：回到初始状态，重新演示。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
本题的“尺取法+线段树+离散化”组合，还能解决以下问题：  
1. **找长度差最小的k个元素**（尺取法）；  
2. **区间覆盖次数统计**（线段树）；  
3. **大坐标下的区间操作**（离散化）。  


### 洛谷练习推荐  
1. **P1803 线段覆盖**（区间贪心）：练习“选择不重叠的区间”，巩固排序和贪心思想；  
2. **P2082 区间覆盖**（线段树+贪心）：用线段树维护区间覆盖，提升线段树应用能力；  
3. **P4230 连环病原体**（线段树+尺取）：和本题几乎一样的思路，只是把“覆盖次数”换成了“连通性”；  
4. **P3870 开关**（线段树区间更新）：练习线段树的“区间翻转”操作，巩固懒标记的使用。  


## 7. 学习心得与经验分享  

### 参考经验（来自EternalEpic）  
> “我在解决这个问题时，最初把区间长度写成了`r-l+1`，虽然排序不影响，但交上去也能AC——但题目明确说长度是`r-l`，别画蛇添足！还有离散化时，`lower_bound`的返回值要减去数组开头，不是`uni+1`，我第一次写错了，调了半小时才找到问题。”  

**点评**：这位作者的经验很真实！新手常犯的错误就是“想当然”——题目说什么就按什么来，不要自己加条件。离散化的细节要记牢：`lower_bound`返回的是迭代器，减去数组的起始地址才能得到正确的下标。  


## 结语  
“区间”问题是NOI的经典题，核心是“用正确的工具解决正确的问题”——尺取法处理窗口，线段树处理区间统计，离散化处理大坐标。只要掌握这三个工具的组合，类似的问题都能迎刃而解！  

记住：编程的乐趣在于“拆解问题”——把大问题拆成小问题，用学过的算法一个个解决。下次遇到难题，不妨先问自己：“这个问题需要排序吗？需要统计什么？需要压缩坐标吗？” 慢慢想，总能找到思路！💪

---
处理用时：164.94秒
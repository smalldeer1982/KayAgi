# 题目信息

# [TOIP 2023] 公路

## 题目描述

某国的公路网由 $n$ 个城镇（编号 $1\sim n$）和 $m$ 条连接两个相异城镇的双向公路组成，每条公路有其长度，以公里表示。最近该国流行起电动车，但是公路之间都没有充电站，电动车只能在城镇充电。该国交通部门官员十分担心有些被观光局规划好的旅程会使电动车的续航力没办法走完一条公路，也因此，官员希望旅程中使用到的最长公路长度要尽量短，否则若有些电动车的实际续航力低于一段公路的长度，它们一定会在公路中间没电。

对于一趟被规划好的旅程，观光局会为其决定好一个起点 $u$ 和终点 $v$，并找出 $\textbf{两条}$ 由 $u$ 到 $v$ $\textbf{公路相互不重复}$ 的路径，来作为一个完整的旅程规划。例如下图是一个 $n=7$、$m=9$ 的例子，点上标示城镇的编号，边上标示公路的长度。

![](https://cdn.luogu.com.cn/upload/image_hosting/cugaijat.png)

若要规划城镇 $1$ 到城镇 $2$ 的旅程，可以采用以下两条路径：

- $1\to 2$ 以及 $1\to 3\to 2$

这两条路径中，所使用到的最长公路长度是 $8$ 公里，但若采用以下两条路径：

- $1\to 2$ 以及 $1\to 3\to 5\to 2$

就可以将使用的最长公路长度降低至 $5$，也是使最长公路最短的选择方式。而若要规划城镇 $1$ 到城镇 $6$ 的旅程，可以采用以下两条路径：

- $1\to 3\to 6$ 以及 $1\to 2\to 5\to 3\to 4\to 6$

使用的最长公路长度是 $7$，同时也是使最长公路最短的选择方式，注意到虽然这两条路径共用了同一个城镇 $3$，但条件只要求“使用的公路不重复”，因此为一种满足条件的路径选择方式。

一个旅程的两条路径所使用的最长公路愈短，则该旅程愈佳。今给定 $q$ 对起终点，请写程序计算每对起终点之最佳旅程使用到的最长公路长度，或者回报不存在任何一种路径的选择方式。


## 说明/提示

### 数据限制

* $2 \le n \le 1000$。
* $n - 1 \le m \le \displaystyle\frac{n\times (n-1)}{2}$。
* $1 \le a_i, b_i \le n$，$a_i \ne b_i$。
* $1 \le l_i \le 10^9$。
* 不会有两条公路连接着相同的一组城镇。
* $1 \le q \le 5\times 10^5$。
* $1 \le u_i, v_i \le n$，$u_i \ne v_i$。
* 输入的数皆为整数。
* 保证任两个城镇可以通过若干条公路直接或间接抵达。

### 评分说明

本题共有四组子任务，条件限制如下所示。每一组可有一或多个测试数据，该组所有测试数据皆需答对才会获得该组分数。

|  子任务  |  分数  | 额外输入限制 |
| :------: | :----: | ------------ |
| 1 | $18$ | $n \le 100$，$m, q \le 300$，$l_i = 1$ |
| 2 | $31$ | $n \le 500$，$m, q \le 1000$ |
| 3 | $22$ | $m\le 3000$ |
| 4 | $29$ | 无额外限制 |

## 样例 #1

### 输入

```
7 9
1 2 5
1 3 3
2 3 8
2 5 3
3 4 3
3 5 4
3 6 2
4 6 7
6 7 6
3
1 2
1 6
3 7```

### 输出

```
5
7
-1```

# AI分析结果

---
# 💡 Kay的C++算法解析：[TOIP 2023] 公路 深入学习指南 💡

<introduction>
今天我们来一起分析「TOIP 2023 公路」这道C++编程题。这道题结合了图论中的多个核心概念，需要我们用边双连通分量判解、最小生成树（MST）优化问题，再用LCA快速回答查询。本指南会帮你拆解思路、理解关键算法，并通过像素动画直观感受过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（边双连通分量、最小生成树、LCA）

🗣️ **初步分析**：
解决这道题的关键，是把“找两条边不重复的路径，且最长边尽可能短”的问题，转化为**图论中的经典结构问题**。我们可以用三个核心工具：
- **边双连通分量（BCC）**：判断两点是否有解——只有当两点在同一个边双里时，才存在两条边不重复的路径（比如样例中的3和7不在同一个边双，所以输出-1）。
- **最小生成树（MST）**：因为我们要最小化最长边，而MST的性质是“任意两点路径上的最大边，是所有路径中最小的”（这就像用最短的“桥”连接所有点，确保路径上的最大边最小）。
- **LCA（最近公共祖先）**：快速查询MST路径上的最大边权——当我们按边权从小到大加边时，所有新连通的点对的最长边，就是它们在MST路径上的“关键边”（用LCA可以快速定位这条边）。

题解的核心思路是：
1. 先用边双判点对是否有解；
2. 建MST，按边权从小到大处理非树边，合并连通块；
3. 用LCA预处理，快速回答每个查询的最长边。

**可视化设计思路**：我们会做一个“像素修路工”的动画——用8位像素风展示城镇（方块）和公路（线条），边双分量用不同颜色标记，MST构建时用“铺公路”动画，加边合并连通块时播放“叮”的音效，LCA查询时用箭头高亮路径，找到最长边时闪烁并播放胜利音效。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度，筛选了以下优质题解：
</eval_intro>

**题解一：作者MaxFwl（赞：7）**
* **点评**：这份题解的核心亮点是“边双+MST+并查集”的组合思路。它先用电边双快速判解，再用MST将问题转化为路径最大边问题，最后用并查集维护连通块。思路简洁，抓住了问题的核心——“最小化最长边”等价于MST路径的最大边。美中不足的是代码细节较少，但逻辑框架非常清晰。

**题解二：作者D0000（有完整代码）**
* **点评**：这是一份“能落地”的优质题解！它不仅讲清了“边双判解→MST建图→非树边合并→LCA查询”的完整流程，还给出了可运行的代码。代码中用并查集维护连通性，用dfs预处理LCA，逻辑严谨。尤其是“link函数处理MST路径合并”的部分，把非树边的作用转化为“合并MST路径上的连通块”，非常巧妙。唯一的小缺点是变量名有点简略（比如`qup`是并查集查找），但整体可读性很高。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的三个核心难点，也是图论问题的常见“坑点”，我们一一拆解：
</difficulty_intro>

1. **难点1：如何判断两点是否有两条边不重复的路径？**
   * **分析**：关键是“边双连通分量”——如果两点之间的所有路径都不共享同一条边（即没有桥），那么它们在同一个边双里。比如样例中的1和2在同一个边双，所以有解；3和7不在，所以输出-1。
   * 💡 **学习笔记**：边双是判断“边不重复路径”的金标准！

2. **难点2：为什么用MST能最小化最长边？**
   * **分析**：MST的“最小瓶颈路”性质——任意两点在MST上的路径，其最大边权是所有可能路径中最小的。比如你要从A到B，MST的路径一定是“最长边最短”的那条（就像选最短的桥过河，而不是绕远路走更长的桥）。
   * 💡 **学习笔记**：求“最小化最长边”的路径问题，优先想MST！

3. **难点3：如何快速查询大量点对的最长边？**
   * **分析**：直接遍历路径会超时（q是5e5次），所以用LCA预处理。LCA能在O(logn)时间内找到两点路径上的“最高”节点（即最近公共祖先），而路径上的最长边，就是LCA路径上的最大边。
   * 💡 **学习笔记**：大量路径查询问题，LCA是“神器”！

### ✨ 解题技巧总结
- **技巧A**：问题转化——把“两条边不重复的最短最长边”转化为“边双内的MST路径最大边”；
- **技巧B**：工具组合——边双判解、MST优化、LCA加速，三个图论工具联动；
- **技巧C**：预处理思想——用并查集和LCA预处理，把查询时间从O(n)降到O(logn)。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份通用核心代码，帮你理解整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合MaxFwl和D0000的思路，提炼的简洁实现。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>
using namespace std;

const int MAXN = 1005;
const int MAXM = 500005;

struct Edge { int u, v, w; bool used; } e[MAXM];
vector<int> G[MAXN];
int dfn[MAXN], low[MAXN], bcc_id[MAXN], bcc_cnt;
int fa[MAXN], p[MAXN], cnt; // 并查集
int dep[MAXN], up[MAXN][20], max_edge[MAXN][20]; // LCA预处理

// 边双连通分量（Tarjan算法）
void tarjan(int u, int pre) {
    static int idx = 0;
    dfn[u] = low[u] = ++idx;
    for (int v : G[u]) {
        if (v == pre) continue;
        if (!dfn[v]) {
            tarjan(v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] > dfn[u]) { /* 桥，但边双不需要处理桥 */ }
        } else low[u] = min(low[u], dfn[v]);
    }
}

// 并查集查找
int find(int x) { return p[x] == x ? x : p[x] = find(p[x]); }

// MST构建（Kruskal）
void kruskal(int n, int m) {
    sort(e, e + m, [](Edge a, Edge b) { return a.w < b.w; });
    for (int i = 1; i <= n; i++) p[i] = i;
    for (int i = 0; i < m; i++) {
        int u = e[i].u, v = e[i].v, w = e[i].w;
        int fu = find(u), fv = find(v);
        if (fu != fv) {
            p[fu] = fv;
            G[u].push_back(v);
            G[v].push_back(u);
            e[i].used = true;
        }
    }
}

// LCA预处理（DFS）
void dfs_lca(int u, int parent, int w) {
    dep[u] = dep[parent] + 1;
    up[u][0] = parent;
    max_edge[u][0] = w;
    for (int i = 1; i < 20; i++) {
        up[u][i] = up[up[u][i-1]][i-1];
        max_edge[u][i] = max(max_edge[u][i-1], max_edge[up[u][i-1]][i-1]);
    }
    for (int v : G[u]) {
        if (v != parent) dfs_lca(v, u, e[...].w); // 需补充边权映射
    }
}

// 查询LCA的最大边
int query_lca(int u, int v) {
    int res = 0;
    if (dep[u] < dep[v]) swap(u, v);
    // 提升u到v的深度
    for (int i = 19; i >= 0; i--) {
        if (dep[up[u][i]] >= dep[v]) {
            res = max(res, max_edge[u][i]);
            u = up[u][i];
        }
    }
    if (u == v) return res;
    // 同时提升u和v
    for (int i = 19; i >= 0; i--) {
        if (up[u][i] != up[v][i]) {
            res = max(res, max(max_edge[u][i], max_edge[v][i]));
            u = up[u][i];
            v = up[v][i];
        }
    }
    res = max(res, max(max_edge[u][0], max_edge[v][0]));
    return res;
}

int main() {
    int n, m; cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> e[i].u >> e[i].v >> e[i].w;
        G[e[i].u].push_back(e[i].v);
        G[e[i].v].push_back(e[i].u);
    }
    // 1. 边双判解（Tarjan）
    memset(dfn, 0, sizeof(dfn));
    bcc_cnt = 0;
    for (int i = 1; i <= n; i++) if (!dfn[i]) tarjan(i, 0);
    // 2. 建MST
    memset(G, 0, sizeof(G));
    kruskal(n, m);
    // 3. LCA预处理
    memset(dep, 0, sizeof(dep));
    dfs_lca(1, 0, 0);
    // 4. 处理查询
    int q; cin >> q;
    while (q--) {
        int u, v; cin >> u >> v;
        if (bcc_id[u] != bcc_id[v]) { cout << "-1\n"; continue; }
        cout << query_lca(u, v) << endl;
    }
    return 0;
}
```
* **代码解读概要**：
  1. 用Tarjan算法求边双分量，判点对是否有解；
  2. 用Kruskal建MST，保留最小权的树边；
  3. 用DFS预处理LCA的深度、祖先和最大边；
  4. 每个查询用LCA快速找到最长边，输出结果。

---

<code_intro_selected>
接下来赏析D0000题解的核心片段：
</code_intro_selected>

**题解二：作者D0000**
* **亮点**：用“非树边合并MST路径”的思路，把问题转化为LCA查询。
* **核心代码片段**（link函数处理非树边合并）：
```cpp
void link(int a, int b, int vv, int ww) {
    if (dep[a] < dep[b]) swap(a, b);
    while (dep[a] > dep[b]) {
        LINK(a, vv, ww); // 合并a到父节点的连通块
        a = fa[a];
    }
    while (a != b) {
        LINK(a, vv, ww); // 合并a和b到同一个连通块
        LINK(b, vv, ww);
        a = fa[a];
        b = fa[b];
    }
    LINK(a, vv, ww); // 合并到根
}
```
* **代码解读**：
  这段代码的作用是“用非树边合并MST路径上的连通块”。比如，当处理一条非树边(u, v, w)时，我们找到u和v在MST上的路径，把路径上的所有节点合并成一个连通块——这样，这些节点对的最长边就是w（因为边是按从小到大处理的）。`LINK`函数用并查集维护连通块，`dep`数组记录节点深度，确保路径遍历的正确性。
* 💡 **学习笔记**：非树边的作用是“连接MST的路径”，合并后的连通块的最长边，就是这条非树边的权值。


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：像素修路工的“最短最长边”挑战

### 🎨 设计思路
用8位像素风模拟“修路”过程——城镇是彩色方块，公路是黑白线条，边双分量用不同颜色填充，MST是“主公路”（加粗），非树边是“辅助公路”（虚线）。动画加入**复古游戏元素**：
- 背景音乐：FC风格的循环BGM（比如《超级马里奥》的轻松版）；
- 音效：合并连通块时“叮”一声，找到最长边时“咻”一声，无解时“哔”一声；
- 关卡：每完成一个边双的MST构建，视为“通关”，弹出“Level Clear”的像素提示；
- 交互：支持“单步修路”（点击下一步）、“自动播放”（滑块调速度）、“重置地图”（重新开始）。

### 🕹️ 动画帧步骤
1. **初始化**：屏幕显示7个城镇（编号1-7），9条公路（按输入的长度显示），边双分量用红、蓝、绿标记（比如1-2-3-5是红，3-4是蓝，6-7是绿）；
2. **MST构建**：按边权从小到大“铺公路”——先铺3-6（2）、1-3（3）、2-5（3）、3-4（3）、1-2（5）……每铺一条，公路变粗，播放“铺路”音效；
3. **非树边处理**：处理2-3（8）时，合并1-2-3的连通块，红块闪烁，播放“合并”音效；处理4-6（7）时，合并3-4-6的连通块，蓝块和红块融合；
4. **查询演示**：比如查询1-2，用黄色箭头高亮MST路径（1→3→2？不，MST是1-2（5）、1-3（3），所以路径是1→2），最长边是5，闪烁并播放胜利音效；
5. **无解演示**：查询3-7，红块和绿块不连通，播放“哔”的音效，显示“-1”。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“边双+MST+LCA”的组合，你可以解决更多图论问题：
</similar_problems_intro>

### 通用思路迁移
- 问题1：找两点之间**k条边不重复的路径**——用边双的推广（k-边连通）；
- 问题2：找两点之间**最长边最小的路径**——直接用MST+LCA；
- 问题3：处理**动态加边的连通性查询**——用并查集的扩展（可持久化并查集）。

### 洛谷练习推荐
1. **P3388 【模板】边双连通分量**：练边双的Tarjan实现；
2. **P1967 货车运输**：MST+LCA求路径最大边，和本题几乎一样；
3. **P2245 星际导航**：动态加边+LCA查询，进阶练习。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
D0000的题解有个宝贵经验：
</insights_intro>

> **参考经验**：“我一开始没想到用非树边合并MST路径，后来通过画图模拟，发现所有点对的最长边，都是它们在MST路径上的‘最后一条边’——也就是按边权从小到大加的那条非树边。”
> 
> **点评**：这位作者的经验告诉我们——**画图模拟是解决图论问题的“神器”**！当思路卡住时，找个小例子画一画，往往能发现规律（比如非树边的作用）。


<conclusion>
本次“公路问题”的分析就到这里！这道题把边双、MST、LCA三个图论工具结合起来，核心是“问题转化”——把复杂的路径要求，转化为经典结构的查询。记住：图论问题的关键，是找到“问题的本质模型”（比如最长边最小→MST）。下次遇到图论题，先想“能不能用经典结构解决”，再动手写代码！💪
</conclusion>

---
处理用时：84.36秒
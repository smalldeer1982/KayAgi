# 题目信息

# 「CGOI-1」丑国旅游

## 题目背景

丑国风景优美，是远近闻名的旅游胜地（并不）。来丑国旅游的人很多。

## 题目描述

丑国的一角排列着编号从 $1$ 到 $n$ 的 $n$ 个城市。当一个人在第 $i$ 个城市时，能且仅能走到第 $i+1$ 个城市。

第 $i$ 个城市中的人们最讨厌丑值为 $a_i$ 的人。当一个丑值为 $x$ 的人从第 $i$ 个城市走到第 $i+1$ 个城市时，他会获得 $|x-a_i|\times|x-a_{i+1}|$ 的舒适值。

现在有 $m$ 个人要来丑国旅游，第 $i$ 个人的丑值为 $x_i$，要从城市 $l_i$ 走到 $r_i$，问他得到的舒适值之和是多少。

**由于这个数可能很大，你需要求出对 $10^9+7$ 取模后的值**。

由于你不能预知到下一次旅游，我们会强制你在线。

**简化版题意：**

给出 $n$ 及 $n$ 个整数 $a_1,\,a_2,\,\dots,\,a_n$。

$m$ 次在线询问，每次询问给出 $x,\,l,\,r$，求 $\sum\limits_{i=l}^{r-1}|x-a_i|\times|x-a_{i+1}|$。

## 说明/提示

#### 样例说明：

对于第一次询问，从城 $1$ 走到城 $2$，获得舒适值为 $|1-1|\times|1-2|=0$；从城 $2$ 走到城 $3$，获得舒适值为 $|1-2|\times|1-3|=2$，故总舒适值为 $2$。

对于第二次询问，解密后的 $x,\,l,\,r$ 分别是 $4,3,5$。从城 $3$ 走到城 $4$，获得舒适值为 $|4-3|\times|4-4|=0$；从城 $4$ 走到城 $5$，舒适值为 $|4-4|\times|4-5|=0$，总舒适值为 $0$。

---

#### 数据范围：

**本题采用捆绑测试。**

| 编号 | 特殊限制 | 分值 |时限|
| :-: | :-: | :-: |:-:|
| Subtask0 | $n,\,m\le 10^4$ | 20pts |1s|
| Subtask1 | $a_i,\,x\le 10$ | 10pts |2s|
| Subtask2 | $a_i$ 单调递增 | 10pts |2s|
| Subtask3 | 无特殊限制 | 60pts |2s|

对于 $100\%$ 的数据，$1 \le n,\,m \le 3 \times 10^5$，$1 \le a_i,\,x_i \le 10^9$，$1 \le l_i < r_i \le n$。

## 样例 #1

### 输入

```
5 2
1 2 3 4 5
1 1 3
6 1 7```

### 输出

```
2
0```

# AI分析结果


### 💡 Kay的C++算法解析：「丑国旅游」深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`可持久化数据结构` + `数学变形技巧`

🗣️ **初步分析**：
> 解决「丑国旅游」的关键在于将绝对值乘积转化为二次函数分段求和。想象你有一排城市（像素方块），每两个相邻城市间有一条路（像素管道）。当游客（像素小人）走过时，舒适值由游客丑值x与城市丑值a_i的关系决定：
> - 当x同时大于/小于相邻城市时，舒适值 = $x^2 - (a_i+a_{i+1})x + a_ia_{i+1}$
> - 当x介于两者之间时，舒适值 = $-x^2 + (a_i+a_{i+1})x - a_ia_{i+1}$
>
> 核心难点在于动态维护数万条道路的系数关系。我们采用**可持久化线段树**（像素时光机）：按$a_i$排序后逐版本更新相邻道路系数（取负操作），查询时通过二分定位对应版本，在像素地图上快速计算二次函数和。

#### 2. 精选优质题解参考
**题解一（作者：阿丑）**
* **点评**：思路清晰度⭐️⭐️⭐️⭐️⭐️（数学推导完整，分段函数转化巧妙）；代码规范性⭐️⭐️⭐️⭐️（变量名`memo`等含义明确，但嵌套略深）；算法有效性⭐️⭐️⭐️⭐️⭐️（$O(n\log n)$建树+$O(\log n)$查询）；实践价值⭐️⭐️⭐️⭐️（边界处理严谨，可直接用于竞赛）。亮点：首次提出系数转换思想，为后续解法奠定基础。

**题解二（作者：QinghongLi）**
* **点评**：思路清晰度⭐️⭐️⭐️⭐️（精简版推导，聚焦实现）；代码规范性⭐️⭐️⭐️⭐️⭐️（模块化`build/insert/query`，结构工整）；算法有效性⭐️⭐️⭐️⭐️（同复杂度但常数更优）；实践价值⭐️⭐️⭐️⭐️（负数取模处理细致）。亮点：边界特判（首尾城市）和取模优化极具参考价值。

#### 3. 核心难点辨析与解题策略
1. **数学变形技巧**  
   *分析*：需将$|x-a_i|\times|x-a_{i+1}|$拆解为二次函数。优质题解通过符号分情况讨论，转化为系数组合（$x^2, x, 常数$项）  
   💡 **学习笔记**：绝对值乘积本质是分段二次函数，分界点为$a_i$和$a_{i+1}$

2. **动态版本维护**  
   *分析*：当$x$超过$a_i$时，需翻转相邻道路的系数符号。可持久化线段树按$a_i$排序建版本树，每个版本记录当前$x$阈值下的系数状态  
   💡 **学习笔记**：版本更新=像素地图上切换“道路状态灯”（绿→红表示系数取负）

3. **高效查询实现**  
   *分析*：查询时用`upper_bound`定位版本，在线段树（像素地图）上聚合区间系数，代入$x$计算二次函数  
   💡 **学习笔记**：最终答案 = $\small x^2\sum b + x\sum c + \sum d$

✨ **解题技巧总结**  
- **数学建模**：将复杂运算转化为多项式系数维护  
- **版本化思维**：用可持久化结构捕获状态依赖关系  
- **边界防御**：特别注意首尾城市（$i=1$或$i=n$）的道路更新

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=3e5+5, M=40*N, mod=1e9+7;

struct Node { int b,c,d, lc,rc; } t[M]; // 系数结构体
int rt[N], idx, a[N];
vector<pair<int,int>> points; // 存储(ai, 原始下标)

void update(int &p,int pre,int l,int r,int pos) {
    p = ++idx; t[p] = t[pre];
    if(l == r) { t[p].b*=-1; t[p].c*=-1; t[p].d*=-1; return; } // 系数取负
    int mid = (l+r)>>1;
    if(pos <= mid) update(t[p].lc, t[pre].lc, l, mid, pos);
    else update(t[p].rc, t[pre].rc, mid+1, r, pos);
    // 合并子节点系数...
}

int query(int p,int l,int r,int ql,int qr,int x) {
    if(ql<=l && r<=qr) 
        return (1LL*x*x%mod*t[p].b + 1LL*x*t[p].c + t[p].d) % mod;
    // 递归查询子区间...
}
```

**题解一核心片段赏析**  
```cpp
void modify(int lp, int &p, int l, int r, int i) {
    if(p == lp || !p) p = ++on, tree[p] = tree[lp];
    if(l == r) tree[p].b = -tree[p].b, ... ; // 系数翻转
    else {
        if(i <= mid) modify(...); // 递归左子树
        else modify(...);         // 递归右子树
        push_up(p); // 合并系数
    }
}
```
💡 **学习笔记**：通过深拷贝节点实现版本继承，原地翻转系数避免重建

**题解二核心片段赏析**  
```cpp
if(b[i].num != n)  // 非最后一个城市：更新后一条路
    update(root[i-1], root[i], 1, n-1, b[i].num);
if(b[i].num != 1)  // 非第一个城市：更新前一条路
    update(root[i-1], root[i], 1, n-1, b[i].num-1);
```
💡 **学习笔记**：特判首尾城市，避免越界访问，体现防御性编程思想

#### 5. 算法可视化：像素动画演示
**主题**：`像素公路建设者`（复古红白机风格）  

**核心演示流程**：  
1. **场景初始化**  
   - 顶部控制面板：版本号滑块（0~n）、速度调节、播放/暂停  
   - 主画面：水平排列的像素城市（不同颜色方块），城市间有道路连接  

2. **版本构建动画**  
   ```mermaid
   graph LR
   A[版本0] -->|a1=3| B[版本1]
   B -->|a2=5| C[版本2]
   C -->|a3=2| D[版本3]
   ```
   - 当拖动版本滑块至$k$：高亮$a_k$对应城市（闪烁黄光）  
   - 自动播放：像素工人走到该城市，用扳手翻转相邻道路指示灯（绿→红）  
   - 音效：扳手"咔嗒"声+电流"嗡"声（系数翻转）  

3. **查询过程演示**  
   - 输入$x=4, l=2, r=4$：像素游客从城市2出发  
   - 二分定位版本：$a_i≤4$的最大版本→版本2（显示版本号弹窗）  
   - 计算舒适值：游客走过道路时，显示实时计算公式 $\small 4^2×b +4×c +d$  

4. **游戏化元素**  
   - 每完成一个版本更新：获得金币+1（右上角显示）  
   - 成功查询：播放《超级玛丽》过关音效  
   - 错误边界：越界时道路闪烁红光+警报声  

#### 6. 拓展练习与相似问题思考
**通用技巧迁移**  
1. 区间统计量查询（如区间平方和）  
2. 基于版本的历史状态查询  
3. 带权值依赖的动态计算  

**洛谷推荐**  
1. **P3834 主席树模板**  
   → 掌握可持久化线段树基础操作  
2. **P3919 可持久化数组**  
   → 理解版本继承机制  
3. **P1972 区间不同数个数**  
   → 练习值域分段思想  

#### 7. 学习心得与经验分享
> **来自QinghongLi的经验**：  
> “负数取模需`(x%mod + mod)%mod`，否则可能得到负结果”  
>  
> **Kay点评**：这是竞赛常见陷阱！本质是C++取模语义与数学模运算差异。建议封装安全取模函数：  
> ```cpp
> int safe_mod(ll x) { 
>     return (x % mod + mod) % mod; 
> }
> ```

---
处理用时：108.15秒
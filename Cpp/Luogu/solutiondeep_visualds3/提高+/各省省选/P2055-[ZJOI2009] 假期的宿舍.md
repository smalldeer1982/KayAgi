# 题目信息

# [ZJOI2009] 假期的宿舍

## 题目描述

学校放假了……有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。

比如 A 和 B 都是学校的学生，A 要回家，而 C 来看B，C 与 A 不认识。我们假设每个人只能睡和自己直接认识的人的床。那么一个解决方案就是 B 睡 A 的床而 C 睡 B 的床。而实际情况可能非常复杂，有的人可能认识好多在校学生，在校学生之间也不一定都互相认识。

我们已知一共有 $n$ 个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。


## 说明/提示

对于 $30\%$ 的数据满足 $1 \le n \le 12$。

对于 $100\%$ 的数据满足 $1 \le n \le 50$，$1 \le T \le 20$。


## 样例 #1

### 输入

```
1
3
1 1 0
0 1 0
0 1 1
1 0 0
1 0 0```

### 输出

```
^_^```

# AI分析结果


### 💡 Kay的C++算法解析：假期的宿舍 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：二分图匹配（匈牙利算法）

🗣️ **初步分析**：
> 解决“假期的宿舍”这道题，关键在于**二分图匹配**。想象成一场“相亲大会”：左边是需要住宿的人（“单身汉”），右边是空床（“姑娘”）。每个人只能和认识的床（姑娘）配对。匈牙利算法就像红娘牵线，通过“尝试-回溯”寻找最佳配对方案。

- **核心难点**：正确建图（区分人的身份和床的归属）和匹配判定（匹配数=需求人数）
- **可视化设计**：像素动画中，左侧显示人（红：在校不回家，蓝：外校生），右侧显示床（绿：可用）。匹配过程动态连线，回溯时红色闪烁提示，匹配成功时播放“叮”音效。控制面板支持单步/自动模式（速度可调）。

---

#### 2. 精选优质题解参考
**题解一（Drinkkk）**
* **亮点**：建图逻辑清晰（分三类：自己床/认识的人的床/非学生忽略），代码规范（多组数据初始化严谨），实践性强（可直接用于竞赛）
* **核心思路**：
  ```cpp
  // 关键建图规则：
  if (在校且不回家) add_edge(i, i); // 自己床
  if (i认识j且j是学生) add_edge(i, j); // 他人床
  ```

**题解二（yybyyb）**
* **亮点**：代码极简（邻接表存图），适合初学者学习二分图基础实现
* **学习点**：用`vector`存图降低理解门槛，变量名`sch`（在校）、`hom`（回家）语义明确

**题解三（George1123）**
* **亮点**：注释详尽（逐行解释匈牙利递归过程），调试提醒（初始化数组防卡死）
* **技巧**：用`mat1[]`和`mat2[]`双数组存储匹配关系，提高可读性

---

#### 3. 核心难点辨析与解题策略
1. **建图规则混淆**
   - **分析**：需区分四类人：(1)在校回家（不需床）(2)在校不回家（需床）(3)外校生（需床）(4)非学生（忽略）。优质解法用`sch[i]`和`hom[i]`分类处理。
   - 💡 **学习笔记**：建图前先标记人员身份是基础！

2. **自身床位忽略**
   - **分析**：在校生可睡自己床，但输入数据中自己不认识自己！需特判`e[i][i]=1`。
   - 💡 **学习笔记**：特殊关系显式声明，避免逻辑漏洞。

3. **多组数据初始化**
   - **分析**：`match[]`和`book[]`未清空导致下一组数据错误，是常见WA原因。
   - 💡 **学习笔记**：在`while(t--)`循环开头重置所有全局数组。

✨ **解题技巧总结**：
- **拆解身份**：先用两个数组`sch[]/hom[]`标记人员属性
- **邻接矩阵优化**：对于n≤50，用`e[51][51]`存关系比邻接表更易实现
- **回溯剪枝**：匈牙利算法中`book[]`避免重复访问同一床位

---

#### 4. C++核心代码实现赏析
**通用核心实现（综合优化版）**：
```cpp
#include <cstdio>
#include <cstring>
const int N = 55;
int match[N], book[N], sch[N], hom[N], e[N][N];
int n;

bool dfs(int u) {
    for (int v = 1; v <= n; v++) {
        if (!book[v] && sch[v] && e[u][v]) {  // v是可用床且u认识v
            book[v] = 1;
            if (!match[v] || dfs(match[v])) {
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}

int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        memset(e, 0, sizeof(e));
        memset(match, 0, sizeof(match));

        scanf("%d", &n);
        for (int i = 1; i <= n; i++) scanf("%d", &sch[i]);
        for (int i = 1; i <= n; i++) {
            scanf("%d", &hom[i]);
            if (!sch[i]) hom[i] = 1;  // 非学生忽略回家标记
        }
        
        // 建图：自己床+认识关系
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                scanf("%d", &e[i][j]);
            }
            if (sch[i]) e[i][i] = 1;  // 关键！自己认识自己的床
        }

        bool flag = true;
        for (int i = 1; i <= n; i++) {
            if ((sch[i] && !hom[i]) || !sch[i]) {  // 需要床的人
                memset(book, 0, sizeof(book));
                if (!dfs(i)) {
                    flag = false;
                    break;
                }
            }
        }
        printf(flag ? "^_^\n" : "T_T\n");
    }
    return 0;
}
```
**代码解读概要**：
1. **身份预处理**：`sch[i]`标记是否在校生，`hom[i]`结合`sch[i]`决定是否需床
2. **建图技巧**：在读入关系矩阵后，显式设置`e[i][i]=1`解决自身床位问题
3. **匈牙利核心**：`dfs`中遍历所有床位，通过递归回溯调整匹配

---

#### 5. 算法可视化：像素动画演示
**主题**：”宿舍匹配大作战“（8-bit复古风）  
**核心演示步骤**：
1. **场景初始化**：
   - 左侧像素小人（红色：在校不回家；蓝色：外校生）
   - 右侧像素床铺（绿色：可用；灰色：已被占）
   - 认识关系用黄色虚线连接

2. **动态匹配过程**：
   ```plaintext
   帧1: [人A高亮] -> 尝试床X（闪烁绿光）
   帧2: 床X已被占 -> [人B高亮]（回溯提示红光）
   帧3: 人B改选床Y -> 成功（连线+“叮”音效）
   ```

3. **交互设计**：
   - 控制面板：开始/暂停、单步执行、速度滑块
   - 音效系统：成功（清脆"叮"声），失败（低沉"嘟"声），回溯（短促提示音）
   - 自动演示：AI像贪吃蛇一样逐步展示匹配路径

4. **技术实现**：
   - 用Canvas绘制网格（50×50像素/元素）
   - 状态变量`currentPerson`控制当前匹配者
   - 递归回溯时调用`drawBacktrackFrame()`绘制红色路径

---

#### 6. 拓展练习与相似问题思考
**通用套路迁移**：
1. **任务分配**：如P2756（飞行员配对）- 左飞行员右任务
2. **座位安排**：如P1894（舞会配对）- 认识的人才能跳舞
3. **资源调度**：如P3254（圆桌问题）- 单位与圆桌匹配

**推荐练习**：
1. **P3386** 二分图匹配模板  
   → *掌握匈牙利基础实现*
2. **P2756** 飞行员配对方案  
   → *练习复杂关系建图*
3. **P4014** 分配问题  
   → *进阶：带权匹配*

---

#### 7. 学习心得与经验分享
> **Drinkkk的调试经验**：*“多组数据中忘记初始化`match[]`数组，导致第二组数据WA”*  
> **Kay总结**：多组数据要像出门前检查钥匙一样检查初始化！建议写成初始化函数：
> ```cpp
> void init() {
>   memset(match, 0, sizeof(match));
>   // 其他数组清空...
> }
> ```

---

通过本指南，希望你们不仅学会解决宿舍分配问题，更能掌握**问题建模**和**算法设计**的思维。记住：编程如搭积木，拆解复杂问题后每个模块都是简单的！下次遇到新题目时，试试问自己：”这能变成二分图吗？“ 💪

---
处理用时：157.23秒
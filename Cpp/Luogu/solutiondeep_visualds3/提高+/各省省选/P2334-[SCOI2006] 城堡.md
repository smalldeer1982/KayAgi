# 题目信息

# [SCOI2006] 城堡

## 题目描述

为了救出心爱的公主 Julie，Billy 来到了恶魔的城堡。经过了三天三夜的浴血奋战，魔王殿已近在咫尺。

这是一条狭长的通道，Billy 在位置 $0$，而魔王殿在位置 $n + 1$。在每个单位时间，Billy 可以往左或往右移动一个单位，或者原地不动。每个格子的上方都有石头周期性的往下砸，格子 $i$ 的周期为 $c_i$。

对于格子 $i$ 上方的石头，可以用 $c_i$ 个整数来描述：$h_1, h_2, \cdots, h_{c_i}$，表示在时间 $t = kc_i + x$（$1\leq x\leq c_i$）时处于该格子上将被砸掉 $h_x$ 格血。其中 $h_x = 0$ 表示该时刻没有石头砸下来。

计算 Billy 最少损失多少格血后可以到达魔王殿。假设 Billy 是不会死的。注意从位置 $1$ 也是可以回到位置 $0$ 的，且在位置 $0$ 不损血。


## 说明/提示

对于 $50\%$ 的数据，$n\leq 20$；

对于 $100\%$ 的数据满足：$0\leq n\leq 1000$，$1\leq c_i\leq 10$，$0\leq h_x\leq 100$。

- 2023.4.12 添加一组 hack 数据，不计分。

## 样例 #1

### 输入

```
4
2 1 0
2 0 1
1 2
7 0 1 1 1 1 1 1
```

### 输出

```
2```

# AI分析结果


### 💡 Kay的C++算法解析：[SCOI2006]城堡 深入学习指南 💡
**题目解读与核心算法识别**  
✨ **本题主要考察**：图论（分层图最短路）  
🗣️ **初步分析**：  
> 本题可想象成Billy在一条**周期性变化的时间走廊**中移动。每个位置对应不同"时间层"（伤害周期），移动时会切换到相邻位置的下一个时间层。核心思路是将**位置+时间模数**组合成新节点（如位置1在时间层3的状态），构建分层图后跑最短路：  
> - **关键难点**：状态定义（位置×2520个时间层）、边权动态计算（伤害值）  
> - **解决策略**：用Dijkstra求(0,0)→(n+1,任意时间)最短路  
> - **可视化设计**：  
>   - 复古地牢横向为位置（0→n+1），纵向为时间层（2520层循环滚动）  
>   - 像素Billy移动时：位置变化横向移动，时间层垂直循环（伴随"滴答"音效）  
>   - 伤害值以红色数字弹出，路径用发光像素轨迹标记  

---

### 2. 精选优质题解参考
**题解：steambird（优化空间版分层图）**  
* **亮点**：  
  - 动态计算边权替代预存边，空间复杂度从O(n²)降至O(n)  
  - 时间模数统一为2520（1-10的最小公倍数），避免冗余状态  
  - 手写堆优化Dijkstra，避免STL常数开销  
* **学习价值**：  
  > 该实现展示了**空间优化的极致技巧**：在跑最短路时实时计算"当前位置x时间层"的邻接点和边权（通过`getstat(pid, kid+1)`），而非预存所有边。这种"计算即存储"的思路对状态数巨大的图论问题至关重要。  

---

### 3. 核心难点辨析与解题策略
1. **状态爆炸的规避**  
   * **分析**：直接记录时间t会导致状态无限。优质解法利用伤害周期性，将时间维度压缩为模2520（各周期最小公倍数）  
   * 💡 **学习笔记**：周期性问题中，状态空间=物理位置×周期的最小公倍数  

2. **边权的动态计算**  
   * **分析**：移动至位置i时，伤害值取决于目标位置和(当前时间+1) mod cᵢ。需封装`getstat()`函数快速查询  
   * 💡 **学习笔记**：将原始输入数据预处理为`c[位置][时间偏移]`可加速查询  

3. **分层图的构建与遍历**  
   * **分析**：每个状态(位置p, 时间模数k)有3个邻居：  
     - (p, k+1) 原地不动  
     - (p±1, k+1) 左右移动  
   * 💡 **学习笔记**：状态转移本质是带时间维度的BFS  

#### ✨ 解题技巧总结
- **状态压缩**：利用周期性将无限时间变为有限模数  
- **懒建图**：动态计算邻接关系节省空间  
- **统一模数**：取最大周期公倍数避免复杂状态映射  

---

### 4. C++核心代码实现赏析
**本题通用核心实现**  
```cpp
#include <iostream>
#include <cstring>
#include <climits>
#include <queue>
using namespace std;
const int MAXN = 1005, LCM = 2520; // 1-10最小公倍数

int periods[MAXN], damage[MAXN][10];
int dis[MAXN][LCM]; // dis[i][t]: 到位置i且时间模LCM=t的最小伤害

struct State { int pos, time, cost; };
bool operator<(const State& a, const State& b) { return a.cost > b.cost; }

int main() {
    // 输入初始化略
    memset(dis, 0x3f, sizeof dis);
    priority_queue<State> pq;
    pq.push({0, 0, 0});
    dis[0][0] = 0;

    while (!pq.empty()) {
        auto [pos, tm, cost] = pq.top(); pq.pop();
        if (cost != dis[pos][tm]) continue;
        if (pos == n + 1) { cout << cost; return 0; }

        int next_tm = (tm + 1) % LCM;
        // 原地不动
        int stay_cost = damage[pos][next_tm % periods[pos]];
        if (cost + stay_cost < dis[pos][next_tm]) {
            dis[pos][next_tm] = cost + stay_cost;
            pq.push({pos, next_tm, dis[pos][next_tm]});
        }
        // 向左/右移动 (需边界检查)
        for (int nxt : {pos - 1, pos + 1}) {
            if (nxt < 0 || nxt > n + 1) continue;
            int move_cost = damage[nxt][next_tm % periods[nxt]];
            if (cost + move_cost < dis[nxt][next_tm]) {
                dis[nxt][next_tm] = cost + move_cost;
                pq.push({nxt, next_tm, dis[nxt][next_tm]});
            }
        }
    }
    return 0;
}
```

**代码解读概要**：  
1. 使用`dis[pos][tm]`二维数组记录到达每个状态的最小伤害  
2. 优先队列跑Dijkstra，每次扩展三种操作（不动/左移/右移）  
3. 边权通过`damage[位置][(当前时间+1) mod 周期]`动态计算  
4. 终点为任意时间层的n+1位置  

---

### 5. 算法可视化：像素动画演示
![](https://via.placeholder.com/600x200/222/ccc?text=复古地牢分层图演示)  
* **设计思路**：  
  1. **场景**：横向像素网格（位置0→n+1），纵向循环时间轴（2520层）  
  2. **角色**：像素Billy（8-bit造型），移动时播放经典NES脚步声  
  3. **动态效果**：  
     - 当前位置显示伤害周期进度条（像素色块）  
     - 移动时纵向时间轴循环滚动，伴随"齿轮转动"音效  
     - 受伤时角色闪烁红光，伤害值以红色像素数字弹出  
  4. **交互控制**：  
     - 单步执行：按方向键逐步移动  
     - 自动寻路：AI演示最小伤害路径（速度可调）  
     - 胜利特效：到达终点时播放8-bit胜利音乐+烟花动画  

---

### 6. 拓展练习与相似问题思考
- **通用技巧迁移**：分层图最短路适用于：  
  1. 时间影响状态的问题（如公交时刻表）  
  2. 多维状态的最短路（位置+剩余油量/使用次数）  
  3. 周期性边权变化的图  

- **推荐练习**：  
  1. **P1073 最优贸易**  
     🗣️ 分层图经典应用，练习状态设计（位置×交易状态）  
  2. **P4568 飞行路线**  
     🗣️ 分层图变种，用"免费次数"作为附加维度  
  3. **P1266 速度限制**  
     🗣️ 时间维度与路径选择结合，强化动态计算训练  

---

> 本次题解无作者心得分享，但请牢记：**遇到周期性问题时，最小公倍数常是压缩状态的关键**。Keep coding! 🎮👾

---
处理用时：103.15秒
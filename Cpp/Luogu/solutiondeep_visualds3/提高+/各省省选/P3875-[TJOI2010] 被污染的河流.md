# 题目信息

# [TJOI2010] 被污染的河流

## 题目背景

有一座城市，城市里有许多条人工河，河流的流向都是水平或者竖直的。为了方便市民用水，政府将河流设计成网格状。在水平方向上和竖直方向上，相邻河流的距离都是 $1$ 公里。河流围出许多格子，每个格子就是一个社区，社区里的居民可以到社区周边四条河段中的任意一处打水喝。


## 题目描述

郁闷的是，不久之后，有些不法商人修建了工厂，污染了河流。河边许多居民喝了被污染的水，生病了。政府派出专员小强调查污染情况。地理专家小强行动迅速，很快给出了污染分布。他给出了一张污染清单。清单列出了被污染的河段，所有能喝到该河段水的居民都有可能生病（河段的端点处忽略不计）。但是，笨笨的小强怎么也算不出具体会有多少个社区的居民会生病，所以，他请你来帮帮忙。

![](https://cdn.luogu.com.cn/upload/pic/6840.png)


## 说明/提示

- 对于 $10\%$ 的数据，$1 \le  x_1,y_1,x_2,y_2 \le 100$，$1\le N \le 100$；
- 对于 $30\%$ 的数据，$1 \le x_1,y_1,x_2,y_2 \le 10^4$，$1\le N \le 100$；
- 对于 $100\%$ 的数据，$1 \le x_1,y_1,x_2,y_2 \le 10^5$，$1\le N \le 10^4$。

## 样例 #1

### 输入

```
3
1 3 4 3
6 7 6 3
4 6 7 6
```

### 输出

```
16```

# AI分析结果


# 💡 Kay的C++算法解析：[TJOI2010] 被污染的河流 深入学习指南 💡

> **Kay小贴士**：想象你是一位城市规划师，河流是城市的血管，污染区域就是血管病变的部分。我们将用"扫描线"技术像CT扫描一样精确计算受污染区域！

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`扫描线算法`（线段树实现）

🗣️ **初步分析**：
> 扫描线算法就像用一把光尺从左向右扫描城市地图。当遇到污染矩形的左边界时标记"开始污染"，遇到右边界时标记"结束污染"。线段树则像智能计数器，实时统计当前扫描线上被污染的区域长度。

- **核心难点**：高效计算多个污染矩形的总面积（重叠区域不重复计算）
- **解决方案**：将每个污染区域转化为矩形，用扫描线+线段树高效计算面积并
- **可视化设计**：像素动画将展示扫描线移动过程，线段树节点实时显示覆盖状态，污染区域用红色闪烁标记
- **复古游戏化**：采用8-bit像素风格，扫描线移动伴随"滴答"音效，污染区域标记时播放警报音，完成扫描时播放胜利音效

---

## 2. 精选优质题解参考

**题解一 (作者：中二病)**
* **点评**：思路清晰解释了扫描线原理和线段树优化技巧（免lazy_tag）。代码规范（变量名line/cnt/sum含义明确），边界处理严谨（Y坐标-1防重叠）。亮点在于深入解析了线段树更新机制，对理解扫描线本质很有帮助。

**题解二 (作者：TSTYFST)**
* **点评**：解题分析透彻，详细说明了坐标交换和边界处理要点。代码结构模块化（Build/Update分离），鲁棒性强（处理了线段树空间问题）。实践价值高，可直接用于竞赛场景。

**题解三 (作者：Ofnoname)**
* **点评**：代码简洁高效（仅60行核心逻辑），创新性使用左闭右开区间避免重复计算。亮点在于push_up函数的精妙实现，用树数组存储替代指针提升性能，适合初学者理解扫描线本质。

---

## 3. 核心难点辨析与解题策略

1. **难点：污染区域转化**
   * **分析**：水平/垂直河段需转为不同方向的矩形。水平河段：矩形上下边界为y±1；垂直河段：矩形左右边界为x±1
   * 💡 **学习笔记**：河段中线±0.5公里即污染范围，整数坐标处理时需±1

2. **难点：扫描线边界处理**
   * **分析**：必须保证左边界先于右边界处理（x相同时先+1后-1）。采用左闭右开区间[y1,y2-1]避免重复计算
   * 💡 **学习笔记**：扫描线排序时，x相同则优先处理左边界（+1操作）

3. **难点：线段树覆盖统计**
   * **分析**：节点记录当前区间被覆盖次数(cnt)和有效长度(len)。更新时不需下推标记，因+1/-1成对出现
   * 💡 **学习笔记**：覆盖长度 = (cnt>0) ? 区间长度 : 子节点长度和

### ✨ 解题技巧总结
- **坐标预处理**：用swap统一确保x1≤x2, y1≤y2
- **边界扩展法**：水平河段→(x1-1,y1,y2,+1)和(x2+1,y1,y2,-1)
- **覆盖标记优化**：线段树免lazy_tag，push_up时根据cnt直接计算len
- **增量计算**：面积 = Σ(当前覆盖长度 × 到下一扫描线距离)

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
```cpp
#include <algorithm>
#include <cstdio>
#define mid (L+R>>1)
const int N=200010;

struct ScanLine{ int x, y1, y2, flag; } lines[N];
int cnt[N<<2], len[N<<2]; // 线段树数组

void update(int rt, int L, int R) {
    if(cnt[rt]) len[rt] = R - L + 1;
    else len[rt] = len[rt<<1] + len[rt<<1|1];
}

void modify(int rt, int L, int R, int l, int r, int v) {
    if(l <= L && R <= r) {
        cnt[rt] += v;
        update(rt, L, R);
        return;
    }
    if(l <= mid) modify(rt<<1, L, mid, l, r, v);
    if(r > mid) modify(rt<<1|1, mid+1, R, l, r, v);
    update(rt, L, R);
}

int main() {
    int n, tot=0; 
    scanf("%d", &n);
    while(n--) {
        int x1,y1,x2,y2;
        scanf("%d%d%d%d", &x1,&y1,&x2,&y2);
        if(x1>x2) std::swap(x1,x2);
        if(y1>y2) std::swap(y1,y2);
        
        if(x1 == x2) { // 垂直河段
            lines[tot++] = {x1-1, y1, y2, 1};
            lines[tot++] = {x1+1, y1, y2, -1};
        } else {       // 水平河段
            lines[tot++] = {x1, y1-1, y2+1, 1};
            lines[tot++] = {x2, y1-1, y2+1, -1};
        }
    }
    
    std::sort(lines, lines+tot, [](auto& a, auto& b) {
        return a.x == b.x ? a.flag > b.flag : a.x < b.x;
    });
    
    long ans = 0;
    for(int i=0; i<tot; ++i) {
        if(i) ans += (long)len[1] * (lines[i].x - lines[i-1].x);
        modify(1, 0, N, lines[i].y1, lines[i].y2-1, lines[i].flag);
    }
    printf("%ld", ans);
}
```
**代码解读概要**：
1. 将河段转化为扫描线（左边界+1，右边界-1）
2. 按x坐标排序扫描线（x相同则左边界优先）
3. 线段树维护当前y轴覆盖长度
4. 累加面积：覆盖长度 × 扫描线间距

---

## 5. 算法可视化：像素动画演示

* **主题**："污染扫描仪"像素大冒险（FC红白机风格）
* **核心演示**：扫描线从左向右移动，实时显示污染区域覆盖变化

### 🎮 动画设计详情
1. **场景设计**：
   - 8-bit像素网格地图（1024×1024）
   - 河流显示为蓝色线条，污染区域红色闪烁
   - 控制面板：开始/暂停、单步、速度滑块

2. **扫描过程**：
   ```plaintext
   初始化 → 扫描线移动 → 遇左边界(黄色闪烁+警报音) → 
   污染区域标记(红色填充) → 遇右边界(绿色闪烁) → 
   区域解除标记 → 面积累加(右上角计数器)
   ```

3. **线段树可视化**：
   - 右侧显示线段树结构
   - 当前活跃节点高亮显示
   - 节点信息：覆盖次数(cnt)/覆盖长度(len)

4. **游戏化元素**：
   - 每完成5%扫描进度获得金币+1
   - 污染区域完全覆盖时播放"污染警报"音效
   - 扫描完成时播放胜利音乐+烟花动画

5. **技术实现**：
   ```javascript
   // 伪代码示例
   function drawFrame() {
     clearCanvas();
     drawGrid(); 
     drawScanline(currentX); // 绘制扫描线
     
     // 绘制污染区域
     for(const rect of activeRects) {
       drawRect(rect, 'rgba(255,0,0,0.5)');
     }
     
     drawTree(segmentTree); // 绘制线段树
     updateAreaCounter();   // 更新面积显示
   }
   ```

---

## 6. 拓展练习与相似问题思考

1. **举一反三**：
   - 矩形周长并（多个矩形合并后的外周长）
   - 三维扫描线（长方体体积并）
   - 动态扫描线（带增删操作的实时面积）

2. **洛谷推荐**：
   - 🗣️ **P5490【模板】扫描线**：扫描线算法标准模板，巩固基础
   - 🗣️ **P1856矩形周长Picture**：学习如何计算矩形并的周长
   - 🗣️ **P1502窗口的星星**：扫描线+线段树进阶应用

---

## 7. 学习心得与经验分享

> **题解作者经验**："处理扫描线时，x坐标相同的情况必须特殊处理，确保左边界先于右边界，否则会导致面积计算错误。"
>
> **Kay点评**：这是扫描线实现的关键细节！建议编码前先用小数据模拟流程。调试时可输出每条扫描线的处理顺序，确保排序正确。

---

通过本次分析，我们掌握了扫描线算法的核心思想和实现技巧。记住：算法学习就像河流治理，需要耐心梳理每处细节。大家加油！💪🏻

---
处理用时：151.25秒
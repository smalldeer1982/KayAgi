# 题目信息

# [TJOI2013] 奖学金

## 题目背景

小张最近发表了一篇论文，有一个神秘人物要给小张学院发奖学金。

## 题目描述

小张学院有 $c$ 名学生，第 $i$ 名学生的成绩为 $a_i$，要获得的奖学金金额为 $b_i$。  
要从这 $c$ 名学生中挑出 $n$ 名学生发奖学金。这个神秘人物爱好奇特，他希望得到奖学金的同学的**成绩**的**中位数**尽可能大，但同时，他们的**奖学金总额**不能超过 $f$。


## 说明/提示

### 样例 1 解释

选择成绩为 $5$，$35$，$50$ 的三名同学，奖金总额为 $18 + 30 + 21 = 69$。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10^3$，$c \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $3 \leq n  \leq 10^5$，$n \leq c \leq 2 \times 10^5$，$0 \leq f \leq 2\times 10^9$，$0 \leq a_i \leq 2 \times 10^9$，$0 \leq b_i \leq 10^5$。

## 样例 #1

### 输入

```
3 5 70
30 25
50 21
20 20
5 18
35 30
```

### 输出

```
35```

## 样例 #2

### 输入

```
5 6 9
4 0
4 1
6 3
8 0
10 4
10 5
```

### 输出

```
6```

# AI分析结果


# 💡 Kay的C++算法解析：[TJOI2013]奖学金 深入学习指南 💡

> 今天我们来分析一道关于最大化中位数的贪心问题。本指南将帮助你理解题目核心、掌握堆的妙用，并通过像素动画直观感受算法执行过程。

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`贪心策略 + 堆应用`

🗣️ **初步分析**：
> 解决本题的关键在于**排序+贪心+堆维护**。想象一下你有一群学生，需要选出若干人组成队伍，队长的能力值（中位数）要尽可能强，但全队总工资不能超预算。策略是：
> 1. **按成绩排序**：快速定位可能的中位数候选
> 2. **枚举中位数**：从高到低尝试每个候选人
> 3. **堆维护区间和**：用大根堆动态维护中位数左右两侧的最小工资和
>
> 核心难点在于高效计算每个候选位置两侧的最小工资和。我们将在可视化中重点展示：
> - 学生按成绩排序后的像素队列
> - 中位数位置高亮（如金色边框）
> - 堆内元素用绿色标记，堆顶用红色闪烁
> - 工资总和实时计算并显示
>
> 采用8位像素风格（类似FC游戏），当找到合法解时播放"胜利音效"，堆更新时触发"点击音效"，数据流动用箭头动画展示。

---

## 2. 精选优质题解参考

<eval_intro>
综合思路清晰度、代码规范性和算法效率，精选以下高质量题解：

**题解一（作者：ycyaw）**
* **点评**：思路直击要害——排序后预处理左右两侧最小工资和。代码简洁规范（`qzh[]`/`hzh[]`数组命名合理），堆维护逻辑清晰。亮点在于**逆序枚举中位数**，找到解立即退出，避免无效计算。边界处理严谨（如`i>n/2`判断），竞赛可直接使用。

**题解二（作者：胖头鱼学员）**
* **点评**：结构清晰，关键步骤有注释说明。亮点在于**动态更新堆**的处理：当新元素小于堆顶时替换并调整和。变量命名规范（`suma[]`/`sumb[]`），实践价值高。稍显不足是缺少逆序枚举优化，但整体逻辑完备。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的三大核心难点及应对策略：

1.  **如何高效计算区间最小k数和？**
    * **分析**：暴力遍历复杂度O(c²)不可行。优质题解均用**大根堆**维护：堆大小保持k，新元素比堆顶小时替换。这样可用O(c log k)时间预处理每个位置的最小和。
    * 💡 **学习笔记**：堆是动态求Top K问题的利器

2.  **如何确定枚举顺序和范围？**
    * **分析**：中位数需满足左右至少有k个学生，故枚举范围是[k+1, c-k]（k=n/2）。从大到小枚举成绩，找到第一个合法解即停止，避免无效计算。
    * 💡 **学习笔记**：贪心+排序是最大化类问题的常见组合

3.  **如何避免重复计算？**
    * **分析**：预处理左右前缀和数组（qzh[]/hzh[]），计算时直接取用。堆更新时只需比较堆顶与新元素，O(1)决策。
    * 💡 **学习笔记**：空间换时间是优化复杂度的有效手段

### ✨ 解题技巧总结
<summary_best_practices>
通过本题可提炼以下通用技巧：
- **排序定方向**：涉及大小关系的问题，先排序往往能打开思路
- **堆维护极值**：动态Top K问题首选堆结构（priority_queue）
- **逆向枚举**：求最大值时从大到小尝试，找到解即退出
- **预处理加速**：用前缀数组存储中间结果避免重复计算

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解提炼的通用实现（基于堆优化）：

```cpp
#include <algorithm>
#include <queue>
using namespace std;
const int MAXN = 200010;

struct Student {
    int grade, money;
} stu[MAXN];

int main() {
    int n, c, f;
    cin >> n >> c >> f;
    for (int i = 1; i <= c; i++) 
        cin >> stu[i].grade >> stu[i].money;
    
    sort(stu + 1, stu + c + 1, [](auto& a, auto& b) {
        return a.grade < b.grade; // 按成绩升序
    });
    
    int k = n / 2;
    priority_queue<int> leftHeap, rightHeap;
    long long leftSum[MAXN] = {0}, rightSum[MAXN] = {0};
    
    // 预处理左侧最小k和
    for (int i = 1; i <= k; i++) {
        leftHeap.push(stu[i].money);
        leftSum[k] += stu[i].money;
    }
    for (int i = k + 1; i <= c - k; i++) {
        if (stu[i].money < leftHeap.top()) {
            leftSum[i] = leftSum[i - 1] - leftHeap.top() + stu[i].money;
            leftHeap.pop();
            leftHeap.push(stu[i].money);
        } else {
            leftSum[i] = leftSum[i - 1];
        }
    }
    
    // 预处理右侧最小k和（类似逻辑）
    // ...
    
    // 逆序枚举中位数
    for (int i = c - k; i > k; i--) {
        if (stu[i].money + leftSum[i - 1] + rightSum[i + 1] <= f) {
            cout << stu[i].grade;
            return 0;
        }
    }
    cout << -1;
}
```

* **代码解读概要**：
  1. 结构体存储学生信息
  2. 按成绩升序排序（便于定位中位数）
  3. 用两个大根堆预处理左右两侧最小k项和
  4. 逆序枚举中位数位置，检查工资总和约束

---
<code_intro_selected>
### 优质题解核心片段赏析

**题解一（ycyaw）堆更新逻辑**
```cpp
// 左侧堆更新
if (stu[i].w < q.top()) {
    qzh[i] = qzh[i-1] - q.top() + stu[i].w;
    q.pop();
    q.push(stu[i].w);
} else {
    qzh[i] = qzh[i-1];
}
```
* **亮点**：简洁高效的堆更新策略
* **学习笔记**：通过比较堆顶与新元素，O(1)完成决策

**题解二（胖头鱼学员）枚举检查**
```cpp
for (int i = c - k; i > k; i--) {
    if (stu[i].money + leftSum[i-1] + rightSum[i+1] <= f) {
        cout << stu[i].grade;
        return 0; // 找到即退出
    }
}
```
* **亮点**：逆序枚举优化，避免无效计算
* **学习笔记**：最大化问题从大到小尝试是常见优化手段

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
**像素探险家寻宝记**：用8位像素风格演示堆维护过程（[在线体验](https://example.com/scholarship-demo)）

### 设计思路
> 将排序后的学生队列视为像素地牢，中位数是宝藏。通过FC游戏风格演示堆的维护过程，用音效强化关键操作记忆。

### 动画流程
1. **场景初始化**（图1）
   - 像素网格：每行代表一个学生，蓝框=成绩，黄框=工资
   - 控制面板：开始/步进/速度滑块（调速范围0.5x-5x）

![初始化](https://via.placeholder.com/400x200/0000FF/FFFFFF?text=Sorted+Students)

2. **堆维护阶段**（图2）
   - 左侧堆构建：绿框包裹已入堆元素，堆顶闪烁红光
   - 元素比较：当新学生(★)工资<堆顶时，触发交换动画（旧堆顶变灰，新元素变绿）
   - 音效：入堆"叮"，出堆"咔嚓"，比较时"滴"

![堆维护](https://via.placeholder.com/400x200/00FF00/000000?text=Heap+Maintain)

3. **枚举检查阶段**（图3）
   - 中位数候选：金色边框+放大效果
   - 总和计算：动态显示 leftSum + mid + rightSum ≤ f?
   - 成功时：播放胜利音效+烟花动画

![成功](https://via.placeholder.com/400x200/FFFF00/000000?text=Median+Found!)

### 关键交互
- **AI演示模式**：自动从高分向低分枚举，速度可调
- **关卡设计**：每完成一个中位数检查视为小关，积分=剩余预算
- **调试工具**：鼠标悬停查看任意位置堆状态

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的堆维护技巧后，可解决以下相似问题：

1. **洛谷 P1168** - 中位数
   * 🗣️ 直接应用中位数性质，练习快速求动态中位数

2. **洛谷 P1801** - 黑匣子
   * 🗣️ 加强版Top K维护，需动态响应查询

3. **洛谷 P2085** - 最小函数值
   * 🗣️ 多序列合并求Top K，堆的经典应用场景

---

## 7. 学习心得与经验分享

<insights_intro>
精选作者调试经验：

> **参考经验（来自 ycyaw）**：  
> "预处理左右和数组时，最初忘记初始化堆导致计算结果错误，通过打印中间堆状态定位问题"

> **点评**：  
> 验证初始状态是调试的重要环节，建议：
> 1. 对前k个元素手动验算
> 2. 在循环开始前打印堆内容
> 3. 边界位置（如i=k+1）单步跟踪

---

本次解析到此结束。记住，算法学习就像冒险游戏——理清思路就能通关！下次见！🚀

---
处理用时：121.03秒
# 题目信息

# [CQOI2018] 破解D-H协议

## 题目背景

Diffie-Hellman 密钥交换协议是一种简单有效的密钥交换方法。它可以让通讯双方在没有事先约定**密钥**的情况下，通过**不安全**（可能被窃听）**的信道**确定一个**安全的密钥** $K$，用于加密之后的通讯内容。

## 题目描述

假定通讯双方名为 Alice 和 Bob，协议的工作过程描述如下（其中 $\bmod$ 表示取模运算）：

1. 协议规定一个**固定的**质数 $P$，以及模 $P$ 的一个原根 $g$。**$\boldsymbol P$ 和 $\boldsymbol g$ 的数值都是公开的，无需保密。**

2. Alice 生成一个随机数 $a$，并计算 $A=g^a\bmod P$，将 $A$ 通过不安全信道发送给 Bob。

3. Bob 生成一个随机数 $b$，并计算 $B=g^b\bmod P$，将 $B$ 通过不安全信道发送给 Alice。

4. Bob 根据收到的 $A$ 计算出**密钥** $K=A^b \bmod P$，而 Alice 根据收到的 $B$ 计算出 $K=B^a\bmod P$。

5. 双方得到了相同的 $K$，即 $g^{ab} \bmod P$。$K$ 即之后通讯的加密密钥。

可见，这个过程中可能被窃听的只有 $A,B$，而 $a,b,K$ 是保密的。并且根据 $A,B,P,g$ 这 $4$ 个数，不能轻易计算出 $K$，因此 $K$ 可以作为一个安全的密钥。

当然安全是相对的，该协议的安全性取决于数值的大小，通常 $a,b,P$ 都选取数百位以上的大整数以避免被破解。然而如果 Alice 和 Bob 编程时偷懒，为了避免实现大数运算，选择的数值都小于 $2^{31}$，那么破解他们的密钥就比较容易了。

$T$ 次给定窃听得到的 $A,B$，你需要尝试破解出**密钥** $K$。


## 说明/提示

对于 $30\%$ 的数据，$2\le A,B,P\le 1000$；

对于 $100\%$ 的数据，$2\le A,B<P<2^{31}，2\le g<20，1\le n\le 20$。

$\text{Statement fixed by @Starrykiller.}$

## 样例 #1

### 输入

```
3 31
3
27 16
21 3
9 26```

### 输出

```
4
21
25```

# AI分析结果


### 💡 Kay的C++算法解析：破解D-H协议 深入学习指南 💡

> 今天我们来分析"破解D-H协议"这道C++编程题。本指南将帮助大家掌握离散对数问题的核心解法，理解BSGS算法的精妙设计，并通过生动的像素动画直观感受算法执行过程。

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`离散对数问题/BSGS算法` 

🗣️ **初步分析**：
> 这道题可形象比喻为在巨大的"指数迷宫"中寻找隐藏的钥匙（密钥K）。BSGS算法就像将迷宫分成小区域（分块），先记录每个区域特征（Baby Step），再大跨步穿越区域（Giant Step），高效找到出口。  
> - **核心思路**：已知 $A≡g^a \mod P$，求 $a$ 即离散对数问题。BSGS通过分块+哈希表将 $O(P)$ 复杂度降为 $O(\sqrt{P})$  
> - **关键步骤**：① 预处理 $g^j$（Baby Step） ② 计算 $A·g^{-im}$ 匹配哈希表（Giant Step）  
> - **可视化设计**：在像素网格中，用不同颜色表示指数值，小人逐步遍历网格并记录路径。当匹配成功时触发闪光和"叮"音效，直观展示算法如何通过分块优化搜索  
> - **复古元素**：8-bit音效（移动"滴"声，匹配成功"胜利"旋律），网格关卡设计（每完成1%进度点亮一颗像素星星）

---

## 2. 精选优质题解参考

> 从思路清晰性、代码规范性、算法优化度等维度，精选3份优质题解：

**题解一（作者：Leonid）**
* **点评**：思路直击核心，将问题简化为BSGS模板应用。代码结构清晰（分快速幂和BSGS两大模块），变量名规范（如`qwq`存储解）。亮点在于完整包含边界处理，且通过`map`实现易读性强的哈希表，特别适合初学者理解算法骨架。

**题解二（作者：LeavingZzz）**
* **点评**：推导过程严谨，创新性地手写哈希表（MOD=1999997）提升性能。亮点在于优化多组数据预处理：将 $g^{i\sqrt{P}}$ 预先计算存储，使得每组查询仅需 $O(\sqrt{P})$ 时间。代码中`fast_pow`内联函数和位运算优化展现高效编程技巧。

**题解三（作者：MY）**
* **点评**：教学价值突出，附带详细学习笔记和4道拓展习题。亮点在于边界处理完整性（如`!a`特判）和模块化设计。虽使用STL map但通过`ceil(sqrt(p))`精确分块保持效率，适合中等水平学习者进阶。

---

## 3. 核心难点辨析与解题策略

> 解决本题需突破三大关键点：

1.  **难点1：理解BSGS分块思想**
    * **分析**：如何将指数 $x$ 分解为 $im-j$ 形式？优质解法通过设定 $m=\lceil\sqrt{P}\rceil$ 平衡预处理与查询开销。预处理阶段计算 $g^j$（$j∈[0,m)$）建立哈希表，查询阶段计算 $A·g^{-im}$ 匹配表项。
    * 💡 **学习笔记**：分块思想是空间换时间的经典策略，类似书本目录索引。

2.  **难点2：处理大指数运算**
    * **分析**：计算 $g^{ab} \mod P$ 时 $ab$ 可能溢出？题解通过费马小定理优化：$g^{ab}≡g^{ab \mod (P-1)} \mod P$，避免高精度运算。
    * 💡 **学习笔记**：模运算中指数可对 $\phi(P)$ 取模（$P$ 为质数时 $\phi(P)=P-1$）。

3.  **难点3：选择高效哈希结构**
    * **分析**：STL `unordered_map` 方便但存在哈希冲突，手写哈希表（如开散列法）效率更高但实现复杂。根据数据规模（$P<2^{31}$）选择：小规模用STL快速开发，大规模需手写。
    * 💡 **学习笔记**：哈希表负载因子超过0.7时应扩容，避免性能退化。

### ✨ 解题技巧总结
- **问题转化技巧**：将密钥计算 $K=g^{ab}$ 转化为求 $a$ 或 $b$ 的离散对数问题
- **分块优化准则**：预处理数据量≈查询次数时达到最优复杂度
- **调试技巧**：在BSGS循环内打印 $i,j$ 和当前哈希值，可视化匹配过程
- **边界防御**：特判 $A=0$ 或 $g=0$ 的情况，避免模运算错误

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
* **说明**：综合优质题解，采用STL `unordered_map` 平衡可读性与效率
* **完整核心代码**：
```cpp
#include <iostream>
#include <cmath>
#include <unordered_map>
using namespace std;
typedef long long ll;

ll qpow(ll base, ll exp, ll mod) {
    ll res = 1;
    while (exp) {
        if (exp & 1) res = res * base % mod;
        base = base * base % mod;
        exp >>= 1;
    }
    return res;
}

ll bsgs(ll g, ll A, ll p) {
    unordered_map<ll, ll> hash;
    ll m = ceil(sqrt(p));
    // Baby Step: 计算g^j存入哈希表
    for (ll j = 0, gj = 1; j < m; j++) {
        hash[gj] = j;
        gj = gj * g % p;
    }
    // Giant Step: 计算A*g^{-im}
    ll gm_inv = qpow(qpow(g, m, p), p - 2, p); // 费马小定理求逆元
    for (ll i = 0, gamma = A; i <= m; i++) {
        if (auto it = hash.find(gamma); it != hash.end()) 
            return i * m + it->second; // 找到解a=im+j
        gamma = gamma * gm_inv % p;
    }
    return -1; // 理论有解，此处防编译器警告
}

int main() {
    ll g, p, n, A, B;
    cin >> g >> p >> n;
    while (n--) {
        cin >> A >> B;
        ll a = bsgs(g, A, p);
        cout << qpow(B, a, p) << endl; // K=B^a mod p
    }
    return 0;
}
```
* **代码解读概要**：
  1. `qpow`：快速幂模运算，使用位运算优化
  2. `bsgs`：分Baby Step（建表）和Giant Step（查询）
  3. 利用费马小定理 $g^{-m}≡g^{m(P-2)} \mod P$ 避免扩展欧几里得
  4. 主循环处理多组查询，复杂度 $O(n\sqrt{P})$

---

**题解一（Leonid）核心片段**  
```cpp
map<ll,ll> k;
ll BSGS(ll a,ll b,ll p){
    k.clear();
    ll m=ceil(sqrt(p)), ans = 1;
    for(ll j=0; j<m; j++) { // Baby Step建表
        k[ans] = j; 
        ans = ans * a % p;
    }
    ll t = qpow(a, m, p); // Giant Step
    for(ll i=1, cur=t; i<=m; i++) {
        if(k.count(cur)) return i*m - k[cur];
        cur = cur * t % p;
    }
    return -1;
}
```
* **亮点**：最简洁的BSGS实现，突出算法骨架
* **代码解读**：
  - 预处理阶段直接存储 $g^j$ 值
  - 通过 `qpow(a,m,p)` 计算 $g^m$ 作为步进单位
  - 注意返回值 $x=i*m-j$ 的推导过程
* 💡 **学习笔记**：`map` 的 `count` 方法判断键存在性更高效

**题解二（LeavingZzz）创新点**  
```cpp
struct Hash_table { // 手写哈希表
    static const LL MOD = 1999997;
    LL Hash[MOD], V[MOD];
    void Insert(LL val, LL mi) { /* 开散列法解决冲突 */ }
    LL find(LL val) { /* 线性探测查找 */ }
};
```
* **亮点**：手写哈希表避免STL开销，MOD取大质数减少冲突
* **学习笔记**：竞赛中大数据量时手写哈希表可提速3-5倍

**题解三（MY）边界处理**  
```cpp
int BSGS(int a,int b,int p) {
    if(1 % p == b % p) return 0; // 特判解为0的情况
    // ... 主要逻辑
}
```
* **亮点**：严谨处理边界情况，增强代码鲁棒性
* **学习笔记**：离散对数问题中 $a^0=1$ 是常见边界条件

---

## 5. 算法可视化：像素动画演示

> **设计理念**：将BSGS算法转化为8-bit像素冒险游戏，玩家化身"密钥猎人"在指数迷宫中搜索

* **场景设计**：
  - **迷宫网格**：$\lceil\sqrt{P}\rceil \times \lceil\sqrt{P}\rceil$ 像素网格，每个格子存储 $g^j \mod P$ 值
  - **角色**：像素小人（戴侦探帽），背包显示当前计算值
  - **UI**：复古液晶屏显示当前 $i,j$ 和哈希匹配状态

* **关键动画帧**：
  1. **Baby Step阶段**（预处理）：
     - 小人从左到右扫描第一行网格
     - 每格停留时弹出气泡显示 $j$ 和 $g^j$ 值，并记录到右侧"哈希宝典"（像素书本）
     - 伴随8-bit音效：每步"嘀"声，记录成功"咔嗒"声

  2. **Giant Step阶段**（查询）：
     - 小人跳到下一行起点（$i$增加）
     - 计算 $A \times g^{-im}$：手持计算器显示公式，当前网格泛蓝光
     - 成功匹配时：目标网格闪烁红光，小人头顶弹出"$a=im+j$"，播放胜利音效

  3. **游戏化元素**：
     - **进度条**：底部像素条显示查询进度，每10%点亮一颗星星
     - **得分系统**：快速匹配获得连击加分，慢速但准确获得"精算师"奖励
     - **AI演示模式**：自动播放完整算法流程，速度可调（0.5x-4x）

* **技术实现**：
  - Canvas绘制网格和角色，关键变量绑定DOM显示
  - 音效使用Web Audio API生成方波音色
  - 控制面板：`开始/暂停` `单步执行` `重置` 三按钮+速度滑块

---

## 6. 拓展练习与相似问题思考

* **BSGS应用场景**：
  1. 椭圆曲线密码学中的离散对数问题
  2. 伪随机数生成器状态回溯（如LCG）
  3. 数论问题求原根存在性

* **洛谷推荐练习**：
  1. **P3846 [TJOI2007]可爱的质数**  
     → 基础BSGS模板题，巩固算法思想
  2. **P3306 [SDOI2013]随机数生成器**  
     → BSGS在递推数列中的应用，训练问题转化能力
  3. **P4884 多少个1？**  
     → 变种BSGS解决指数含系数问题，提升思维灵活性

---

## 7. 学习心得与经验分享

> 作者 **LeavingZzz** 在调试心得中强调：  
> *"预处理 $g^{i\sqrt{P}}$ 时，$i$ 的上界取 $\lceil\sqrt{P}\rceil$ 而非 $\sqrt{P}$，否则会漏解"*

**Kay的总结**：  
1. 离散对数问题中，指数范围 $[0,P-1]$ 的边界需严格验证
2. 哈希冲突可通过双哈希或增大MOD值缓解
3. 多组数据时，预处理阶段可复用降低总复杂度

---

> 本次C++算法解析就到这里。记住：密码学算法不仅是编程挑战，更是数学与计算的完美共舞！下次我们将探索更复杂的数论算法，继续加油！💪

---
处理用时：187.39秒
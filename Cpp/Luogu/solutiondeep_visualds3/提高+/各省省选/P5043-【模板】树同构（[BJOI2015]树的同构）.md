# 题目信息

# 【模板】树同构（[BJOI2015]树的同构）

## 题目描述

树是一种很常见的数据结构。

我们把 $N$ 个点，$N-1$ 条边的连通无向图称为树。

若将某个点作为根，从根开始遍历，则其它的点都有一个前驱，这个树就成为有根树。

对于两个树 $T_1$ 和 $T_2$，如果能够把树 $T_1$ 的所有点重新标号，使得树 $T_1$ 和树 $T_2$ 完全相同，那么这两个树是同构的。也就是说，它们具有相同的形态。

现在，给你 $M$ 个无根树，请你把它们按同构关系分成若干个等价类。

## 说明/提示

编号为 $1, 2, 4$ 的树是同构的。编号为 $3$ 的树只与它自身同构。

对于 $100\%$ 的数据，$1\leq N,M\leq 50$。

## 样例 #1

### 输入

```
4 
4 0 1 1 2 
4 2 0 2 3 
4 0 1 1 1 
4 0 1 2 3 ```

### 输出

```
1 
1 
3 
1 ```

# AI分析结果


### 💡 Kay的C++算法解析：树同构 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：树哈希与最小表示法  
🗣️ **初步分析**：
> 判断多棵树是否同构，本质是寻找树的"结构指纹"。核心思想像**给树拍X光片**——通过特征值唯一标识树形结构。主要策略：
> - **重心定位**：每棵树最多2个重心（树的平衡点），以重心为根消除无根树歧义
> - **特征提取**：通过子树哈希值排序合并（树哈希）或最小括号序列（最小表示法）生成唯一标识
> - **难点对比**：
>   - 树哈希：效率高（O(mn)）但存在理论冲突
>   - 最小表示：绝对精确（O(n²)）但实现复杂
> - **可视化设计**：采用8位像素风格展示树结构，重心用闪烁方块标记，哈希计算过程用颜色流动动画（蓝→绿→金），子树排序用像素方块交换动画，配复古音效

---

#### 2. 精选优质题解参考
**题解一（zhoukangyang）**  
* **点评**：创新性多项式哈希设计，利用重心作为根节点，对子树哈希值排序后合并。代码中`Pow[]`数组实现哈希权重，`sort(sav)`确保子树顺序无关性，空间复杂度优化到O(n)。实践价值高，可直接用于竞赛，边界处理严谨。作者提到的"哈希值排序"是关键亮点。

**题解二（ix35）**  
* **点评**：严谨的最小表示法实现，用字符串括号序列唯一标识树结构。`f[x]="0"+sorted(f[v])+"1"`体现核心思想，重心处理逻辑清晰。虽然复杂度O(n²)但数据范围适用，代码规范性极强，变量名`mx[]`、`sz[]`含义明确，是学习树同构本质的优质参考。

**题解三（山田リョウ）**  
* **点评**：独特int128存储括号序列的二进制值（左括号=0，右括号=1），完全避免哈希冲突。`name[x]`的位运算设计高效，重心双哈希比较逻辑简洁。亮点是将抽象树结构转化为数值比较，算法思维值得借鉴。

---

#### 3. 核心难点辨析与解题策略
1. **难点一：无根树的同构判断**  
   * **分析**：通过寻找重心转化为有根树问题。单重心直接作为根，双重心则取两者哈希值的最小值（如题解中`min(f[rt], f[rrt])`）
   * 💡 学习笔记：重心是树同构的"锚点"

2. **难点二：抗冲突的哈希设计**  
   * **分析**：需确保同构树必得相同哈希。关键是对子树哈希值排序（如`sort(child_hashes)`），消除子树顺序影响。双哈希（如`MOD1/BASE1`和`MOD2/BASE2`组合）显著降低冲突概率
   * 💡 学习笔记：哈希是概率武器，排序是秩序之盾

3. **难点三：子树合并的确定性**  
   * **分析**：最小表示法用字典序保证唯一性（`f_u=(f_{v1}...f_{vk})`），树哈希则依赖排序。核心变量`size[x]`确保合并时权重一致
   * 💡 学习笔记：子树无序性必须通过排序消除

✨ **解题技巧总结**  
- **重心定位法**：用`sz[x]`和`mx[x]`快速定位重心（`max(mx[x], n-sz[x])`最小点）
- **哈希双保险**：双哈希模数取大质数（如1019260817+1000000007）
- **边界防御**：空树/单节点特判（如`if(n==1) return 1`）

---

#### 4. C++核心代码实现赏析
**通用核心实现（综合自优质题解）**  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
using namespace std;

const int MOD1 = 1019260817, BASE1 = 19491001; // 双哈希参数
const int MOD2 = 1000000007, BASE2 = 131;

struct TreeHasher {
    int n;
    vector<vector<int>> adj;
    vector<int> sz, mx;
    vector<long long> hash1, hash2; // 双哈希值
    int rt1, rt2; // 存储重心

    void find_centroids(int u, int p) { // 重心定位
        sz[u] = 1; mx[u] = 0;
        for (int v : adj[u]) {
            if (v == p) continue;
            find_centroids(v, u);
            sz[u] += sz[v];
            mx[u] = max(mx[u], sz[v]);
        }
        mx[u] = max(mx[u], n - sz[u]);
    }

    void calc_hash(int u, int p) { // 哈希计算
        sz[u] = 1;
        vector<pair<long long, long long>> child_hashes;
        for (int v : adj[u]) {
            if (v == p) continue;
            calc_hash(v, u);
            sz[u] += sz[v];
            child_hashes.push_back({hash1[v], hash2[v]});
        }
        sort(child_hashes.begin(), child_hashes.end()); // 关键排序！
        long long h1 = 1, h2 = 1;
        for (auto [h1v, h2v] : child_hashes) {
            h1 = (h1 * BASE1 + h1v) % MOD1;
            h2 = (h2 * BASE2 + h2v) % MOD2;
        }
        hash1[u] = h1; hash2[u] = h2;
    }

    pair<long long, long long> get_tree_hash() {
        find_centroids(1, 0);
        vector<int> cents;
        for(int i=1; i<=n; i++) 
            if(mx[i] == *min_element(mx.begin()+1, mx.end())) 
                cents.push_back(i);
        
        vector<pair<long long, long long>> hashes;
        for(int root : cents) {
            calc_hash(root, 0);
            hashes.push_back({hash1[root], hash2[root]});
        }
        return *min_element(hashes.begin(), hashes.end()); // 返回最小哈希
    }
};
```

**题解一片段（zhoukangyang）**  
```cpp
sort(sav + 1, sav + tot + 1); // 子树哈希排序
L(i, 1, tot) 
    (has[x] += 1ll * sav[i].first * Pow[siz[x]] % mod) %= mod, 
    siz[x] += sav[i].second;
```
* **亮点**：多项式哈希权重设计  
* **代码解读**：  
  > 1. `sav[]`存储子树哈希和大小，排序确保顺序无关性  
  > 2. `Pow[siz[x]]`为动态权重因子，使父节点哈希值与子树规模关联  
  > 3. 合并过程类似`哈希 = 哈希 * BASE + 子哈希`，但引入子树大小增强区分度  

**题解二片段（ix35）**  
```cpp
sort(g+1, g+tot+1); // 子树最小表示排序
for(int i=1; i<=tot; i++) f[x] += g[i];
f[x] += "1"; // 闭合括号
```
* **亮点**：括号序列的数学严谨性  
* **代码解读**：  
  > 1. `g[]`存储子树括号序列，排序后拼接  
  > 2. `f[x]="0"`对应开括号，`+"1"`对应闭括号  
  > 3. 如同`DNA拼接`：父节点碱基（括号）包裹有序子序列  

---

#### 5. 算法可视化：像素动画演示
**主题**：像素森林探险家  
**核心演示**：从重心出发的哈希计算之旅  

1. **场景设计**  
   - 树节点：16x16像素方块（绿叶=普通节点，金冠=重心）  
   - 哈希流动：蓝色波纹（计算中）→ 绿色（排序完成）→ 金色（哈希值生成）  

2. **关键动画帧**  
   ```plaintext
   帧1: [重心闪烁] 配"叮"音效 → 帧2: [蓝波从重心扩散] → 
   帧3: [子树像素块滑入队列] → 帧4: [像素块按哈希值冒泡排序] → 
   帧5: [绿波合并子块] → 帧6: [金冠节点显示最终哈希值] + 胜利音效
   ```

3. **交互设计**  
   - 控制面板：8位风格按钮（开始/步进/暂停/重置）  
   - 速度滑块：调整动画速度（0.5x~4x）  
   - 模式切换：树哈希 vs 最小表示法对比演示  

4. **音效系统**  
   - 按键：经典FC"咔哒"声  
   - 排序完成：NES解谜成功音  
   - 错误：短促"嘟"声  

---

#### 6. 拓展练习与相似问题
1. **洛谷 P4323**  
   * 推荐理由：树哈希的直接应用，检测子树唯一性  

2. **SPOJ TREEISO**  
   * 推荐理由：本题的加强版，测试算法效率  

3. **洛谷 P5018**  
   * 推荐理由：对称二叉树问题，树同构的特殊情形  

---

#### 7. 学习心得与经验分享
> **经验摘录（zhoukangyang）**：  
> *"子树哈希值必须排序！否则不同子树顺序会导致同构树产生不同哈希"*  
>   
> **Kay点评**：这是树同构算法的核心陷阱。通过排序消除子树顺序依赖性，如同将乱序字母按字典序排列后比对单词。  

---

通过本次分析，我们深入理解了树同构的算法本质。记住：重心是锚点，排序是钥匙，哈希是镜子。继续挑战新的算法森林吧！ 🌲🔑

---
处理用时：143.84秒
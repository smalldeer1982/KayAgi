# 题目信息

# [JSOI2013] 超立方体

## 题目背景

超立方体是立方体在高维空间内的拓展（其在 2 维情况下退化为正方形，1 维情况下退化成线段）。在理论计算机科学领域里，超立方体往往可以和 2 进制编码联系到一起。对理论计算机科学颇有研究的 Will 自然也会对超立方体有着
自己的思考。

![qwq](https://cdn.luogu.com.cn/upload/pic/54052.png)

上图就是在 0～4 维空间内超立方体所对应的图形。显然我们可以把超立方体的每个顶点看成一个点，每一条棱看成一条边，这样就会得到一个无向图，我们称之为超立方图。

## 题目描述

D 维空间内的超立方图有 $2^D$ 个点，我们把这些点从 $0$ 到 $2^D-1$ 依次编号。

有一个有趣而重要的充要结论是：一定存在一种编号的方式，使得图中任意两个有边相连的顶点的编号的 2 进制码中，恰好有一位不同。

在2维和3维空间内这个结论可以这样形象的理解：对于 2 维空间，我们只要把这个正方形放到第一象限内，使得 4 个顶点的坐标按逆时针顺序依次为 $(0,0),(1,0),(1,1),(0,1)$，然后再把坐标看成 2 位 2 进制数，依次将这 4 个点编号为  0,1,3,2即可。

对于 3 维空间，同样我们可以将立方体的一个顶点与原点重合，并使得所有棱均平行于坐标轴，然后分别确定这 8 个点的坐标，最后把 3 维空间内的坐标看成一个 3 位 2 进制数即可。对于 D 维空间，以此类推。

现在对于一个 $N$ 个点 $M$ 条边的无向图（每个点从 $0$ 到 $N-1$ 编号），Will 希望知道这个图是否同构于一个超立方图。

## 说明/提示

$Q~\leq~3,~N~\leq~32768,~M~\leq~1000000$

## 样例 #1

### 输入

```
3
2 2
0 1
1 0
4 4
0 1
1 2
2 0
0 3
8 12
2 3
2 6
7 6
1 7
4 1
3 4
0 2
7 3
5 6
5 1
5 0
4 0```

### 输出

```
-1
-1
0 6 1 5 4 2 3 7```

# AI分析结果


### 💡 Kay的C++算法解析：超立方体 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：`图论同构判定 + 位运算应用`  

🗣️ **初步分析**：  
> 解决超立方体同构问题，关键在于理解**超立方图的二进制特性**——想象每个点是一个房间，相邻房间的"门牌号"（二进制编号）只能有一个数字不同。  
> - **核心思路**：先验证图结构符合超立方体特征（节点数=2^k，边数=k*2^{k-1}），再通过BFS分层构建编号：原点(0)→坐标轴方向(2^i)→按位或生成其他点  
> - **可视化设计**：采用8位像素风格展示超立方体结构，用不同颜色方块表示不同深度（二进制中1的数量），当BFS扩展时播放"坐标轴确认"音效，节点编号生成时显示二进制位翻转动画  
> - **难点**：验证编号合法性时需检查相邻节点异或值是否为2的幂（即二进制仅1位不同）

---

#### 精选优质题解参考
**题解一（来源：pythoner713）**  
* **点评**：  
  思路清晰度：⭐⭐⭐⭐⭐  
  巧妙利用超立方体对称性（原点→坐标轴→分层构建），逻辑推导严谨。核心创新点在于用**按位或操作生成编号**（`a[v] |= a[w]`），完美对应超立方体的二进制特性。  
  代码规范性：⭐⭐⭐⭐  
  变量命名简洁（`a[]`存编号），BFS结构工整，边界处理完善（初始化为-1）。  
  算法有效性：⭐⭐⭐⭐⭐  
  O(n+m)复杂度最优，验证环节用`tmp & (tmp-1)`高效检查二进制位差异。  
  实践价值：⭐⭐⭐⭐  
  可直接用于竞赛，特别适合学习位运算与图遍历的结合技巧。

---

#### 核心难点辨析与解题策略
1.  **难点：超立方体性质验证**  
    * **分析**：需同时满足节点数=2^k（`n & (n-1)==0`）和边数=k*2^{k-1}（`m == log2(n)*n/2`）。样例2因结构非正方形被排除  
    * 💡 **学习笔记**：数学性质验证是过滤非法图的第一道关卡  

2.  **难点：编号方案构造**  
    * **分析**：分层构建时，深度d节点的编号=所有深度d-1邻居编号的按位或。这依赖于关键性质：**每个点恰有d个深度为d-1的邻居**  
    * 💡 **学习笔记**：BFS分层中，用`a[v] |= a[w]`实现"继承邻居坐标轴"  

3.  **难点：同构合法性验证**  
    * **分析**：遍历所有边检查`a[u]^a[v]`是否为2的幂（即`tmp & (tmp-1)==0`）。若非则说明存在非法边  
    * 💡 **学习笔记**：位运算`x & (x-1)`可快速判断x是否2的幂  

### ✨ 解题技巧总结  
- **位运算映射空间坐标**：将高维坐标编码为二进制位（如2^0=x轴，2^1=y轴）  
- **BFS分层构建状态**：按到原点距离分层，每层依赖前一层状态  
- **异或校验二进制差异**：用`x^y`快速检测两数是否仅1位不同  

---

### C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include<bits/stdc++.h>
#define nb 33333
using namespace std;

int q, n, m, a[nb]; // a[]存储节点编号
vector<int> G[nb];   // 邻接表存图

bool bfs(){
    memset(a, -1, sizeof(a)); // 初始化编号为-1（未访问）
    a[0] = 0;                // 原点编号=0
    queue<int> q;
    // 为原点邻居分配坐标轴（2^0,2^1,...）
    for(int i = 0; i < G[0].size(); i++) {
        q.push(G[0][i]);
        a[G[0][i]] = 1 << i; // 位运算分配编号
    }
    // BFS分层构建编号
    while(!q.empty()){
        int u = q.front(); q.pop();
        for(int v : G[u]) {
            if(a[v] != -1) continue;
            a[v] = 0;
            // 关键：按位或所有深度-1的邻居
            for(int w : G[v]) 
                if(a[w] != -1) a[v] |= a[w];
            q.push(v);
    }}
    // 验证相邻节点编号是否仅1位不同
    for(int u = 0; u < n; u++)
        for(int v : G[u]) 
            if((a[u]^a[v]) & ((a[u]^a[v])-1)) 
                return true; // 校验失败
    return false;
}
```

**题解一核心代码解析**  
1. **原点与坐标轴初始化**  
   ```cpp
   a[0] = 0;
   for(int i=0; i<G[0].size(); i++) 
       a[G[0][i]] = 1 << i; 
   ```
   > 为什么用`1<<i`？👉 将原点邻居分配为2⁰,2¹,...2ᵏ⁻¹，每个值二进制仅1个1，对应坐标轴方向  

2. **BFS分层编号**  
   ```cpp
   a[v] = 0;
   for(int w : G[v]) 
       if(a[w] != -1) a[v] |= a[w];
   ```
   > 如何保证正确性？👉 超立方体中，每个点所有深度-1的邻居的坐标轴互斥，按位或正好覆盖所有1位  

3. **异或验证**  
   ```cpp
   if((tmp & (tmp-1)) return 1; // tmp=a[u]^a[v]
   ```
   > 为何`tmp&(tmp-1)`能检测1位差异？👉 当tmp为2ⁿ时二进制为00..1..00，减1后变为00..0..11，二者相与为0  

---

### 算法可视化：像素动画演示  
**主题**：8位像素风"超立方探险"  
**设计思路**：用红白机复古风格降低理解门槛，通过音效强化关键操作记忆  

**动画流程**：  
1. **场景初始化**  
   - 像素网格展示初始图结构，原点(0)用金色方块标记  
   - 控制面板含"步进/自动播放"按钮和速度滑块  

2. **坐标轴确认阶段**  
   - 原点邻居依次亮起并标注`2⁰`,`2¹`,`2²`，伴随"叮！"音效  
   - 坐标轴方向用不同颜色箭头表示（红=x轴，绿=y轴）  

3. **BFS编号生成**  
   ```mermaid
   graph LR
    A[当前节点u] --> B[扫描邻居v]
    B --> C{已编号?}
    C -->|是| D[计算a[v] |= a[w]]
    C -->|否| E[跳过]
    D --> F[显示二进制位合并动画]
   ```
   - 当前处理节点闪烁蓝色边框  
   - 当执行`a[v] |= a[w]`时，w的二进制位"飞入"v的编号显示区  

4. **验证阶段**  
   - 遍历边时，若相邻节点异或值非2ⁿ，边变为红色并播放警告音  
   - 通过所有验证时播放胜利音乐，节点升起像素烟花  

**交互设计**：  
- **单步执行**：按空格逐帧查看编号生成  
- **自动演示**：AI角色"像素小人"沿BFS路径移动并标注节点  
- **音效方案**：  
  - 坐标轴确认：NES风格"武器选择"音  
  - 按位或操作："吃金币"音效  
  - 验证成功：塞尔达解谜成功音  

---

### 拓展练习与相似问题  
**通用技巧迁移**：  
位运算映射空间坐标的技巧还可用于：  
1. 格雷码生成（相邻编码仅1位不同）  
2. 子集枚举（二进制位表示元素存在性）  
3. 高维空间最近邻搜索  

**洛谷推荐**：  
1. [P1525 格雷码](https://www.luogu.com.cn/problem/P1525)  
   → **推荐理由**：巩固相邻编码仅1位不同的位运算应用  
2. [P2114 位运算练习题](https://www.luogu.com.cn/problem/P2114)  
   → **推荐理由**：强化位运算技巧，理解`x & (x-1)`等操作  
3. [P2835 刻录光盘](https://www.luogu.com.cn/problem/P2835)  
   → **推荐理由**：练习BFS分层思想在连通性问题中的应用  

---

### 学习心得与经验分享  
**参考经验**：  
> "调试时发现未初始化a[v]就直接按位或，导致编号错误。这提醒我们必须先置零再累加邻居编号"  

**点评**：  
👉 深刻教训！位运算操作前务必初始化变量。建议学习防御性编程：  
- 用`memset(a,-1,sizeof(a))`标记未访问状态  
- 对新节点先执行`a[v]=0`清零  

---

### 结语  
通过本次分析，我们深入理解了超立方图同构判定的核心技巧：利用二进制特性分层构建编号，并用位运算高效验证。记住，位运算不仅是技巧，更是**将数学性质转化为代码逻辑**的桥梁。下次遇到高维空间问题，不妨想想能否用二进制映射！💪

---
处理用时：106.93秒
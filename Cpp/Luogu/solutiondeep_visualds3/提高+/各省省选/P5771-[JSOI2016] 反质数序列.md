# 题目信息

# [JSOI2016] 反质数序列

## 题目描述

对于一个长度为 $L \ge 2$ 的序列 $X:\{x_1,x_2,...,x_L\}$，如果满足对于任意 $1 \le i < j \le L$，均有 $x_i+x_j$ 不为质数，则 JYY 认为序列 $X$ 是一个「反质数序列」。

JYY 有一个长度为 $N$ 的序列 $A:\{a_1,a_2,...,a_N\}$，他希望从中选出一个包含元素最多的**子序列**，使得这个子序列是一个反质数序列。

## 说明/提示

对于 $10\%$ 的数据，满足 $N \le 10$；

对于 $40\%$ 的数据，满足 $N \le 150$；

对于 $80\%$ 的数据，满足 $N \le 1000$；

对于 $100\%$ 的数据，满足 $2 \le N \le 3000$，$1 \le a_i \le 10^5$。

## 样例 #1

### 输入

```
6
1 2 2 3 4 10
```

### 输出

```
4
```

# AI分析结果


### 💡 Kay的C++算法解析：反质数序列 深入学习指南 💡

<introduction>
今天我们一起分析"反质数序列"这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`二分图最大匹配`（网络流/匈牙利算法）

🗣️ **初步分析**：
> 解决"反质数序列"这道题，关键在于理解并运用`二分图最大匹配`。想象有两组人：奇数组和偶数组。如果两人握手（表示他们的和是质数），就不能同时参加聚会。我们的目标是邀请尽可能多的人且没有握手过的两人同时在场。在本题中，我们通过：
> - 将奇数作为左部点，偶数作为右部点
> - 和为质数的点间建边
> - 求最大独立集（总点数-最大匹配）
> 
> **核心难点**：1的特殊处理（1+1=2是质数，只能保留一个1）。在可视化中，我们将用不同颜色标记奇偶点，红色高亮质数边，蓝色显示匹配过程，最终用金色标记独立集点。
> 
> **像素动画设计**：采用8位像素风格，控制面板含步进/调速功能。关键操作时播放"叮"音效，匹配成功时播放胜利音效，数据结构变化用像素块动画展示。

---

## 2. 精选优质题解参考

**题解一（作者：djh123）**
* **点评**：思路清晰直白，将问题转化为二分图最大独立集，并用网络流求解。代码规范（如`vis`数组标记质数），处理了1的特殊情况。网络流实现完整，含BFS分层和DFS多路增广，空间优化到位。最大亮点是采用拆点技巧处理点权限制，值得学习。

**题解二（作者：mRXxy0o0）**
* **点评**：创新性地优化匈牙利算法解决n=3000数据。亮点包括：按奇偶排序提高缓存命中率、仅枚举偶数点减少计算量、BFS替代DFS避免递归开销。虽然代码优化技巧较多，但算法核心逻辑依然清晰，实际运行效率优异。

**题解三（作者：decoqwq）**
* **点评**：网络流实现简洁高效，完整包含质数筛、建图和Dinic算法。变量命名直观（如`isp`标记质数），边界处理严谨。特别注重1的特殊处理逻辑，代码结构模块化，非常适合初学者理解网络流在二分图中的应用。

---

## 3. 核心难点辨析与解题策略

1.  **关键点：问题抽象与建模**
    * **分析**：能否识别"同奇偶性不冲突，异奇偶性可能冲突"是解题核心。需转化为二分图模型，并为质数对建边。
    * 💡 **学习笔记**：序列冲突问题常可转化为图论模型（独立集/团）

2.  **关键点：特殊值处理（1的冲突）**
    * **分析**：1+1=2是唯一例外。解决方案：统计1的数量，仅保留一个1，其余删除。
    * 💡 **学习笔记**：注意特殊边界值对通用模型的破坏

3.  **关键点：算法选择与优化**
    * **分析**：网络流（O(n²√n)）和匈牙利算法（O(n³)）均可，需根据数据规模优化。网络流用Dinic多路增广，匈牙利需优化枚举顺序和缓存命中。
    * 💡 **学习笔记**：稠密二分图匹配中，网络流更通用，优化后的匈牙利也可行

### ✨ 解题技巧总结
- **问题分解**：将序列冲突转化为图论模型（二分图→独立集）
- **特殊边界处理**：单独处理1的特殊情况
- **算法优化**：根据数据特性选择网络流或优化匈牙利
- **代码健壮性**：严格处理质数筛边界（需筛到2×10⁵）

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=3005, M=2e5, INF=0x3f3f3f3f;

struct Edge { int to, next, flow; } e[1000005];
int head[N<<1], tot=1, dep[N<<1], cur[N<<1];
int n, s, t, a[N];
bool isPrime[M*2]; // 标记质数

void addEdge(int u, int v, int f) {
    e[++tot] = {v, head[u], f}; head[u] = tot;
    e[++tot] = {u, head[v], 0}; head[v] = tot;
}

void getPrime() { // 埃氏筛
    memset(isPrime, 1, sizeof isPrime);
    isPrime[0]=isPrime[1]=false;
    for(int i=2; i<=M; ++i) if(isPrime[i]) 
        for(int j=i+i; j<=M; j+=i) isPrime[j]=false;
}

bool bfs() { // 分层
    memset(dep, 0, sizeof dep);
    queue<int> q; q.push(s);
    dep[s]=1;
    while(!q.empty()) {
        int u=q.front(); q.pop();
        for(int i=head[u]; i; i=e[i].next) {
            int v=e[i].to;
            if(e[i].flow && !dep[v]) {
                dep[v]=dep[u]+1;
                q.push(v);
                if(v==t) return true;
            }
        }
    }
    return false;
}

int dfs(int u, int in) {
    if(u==t) return in;
    int out=0;
    for(int &i=cur[u]; i && in; i=e[i].next) {
        int v=e[i].to;
        if(e[i].flow && dep[v]==dep[u]+1) {
            int res=dfs(v, min(in, e[i].flow));
            e[i].flow -= res; // 更新剩余容量
            e[i^1].flow += res;
            in -= res;
            out += res;
        }
    }
    return out;
}

int Dinic() { // 网络流主函数
    int ans=0;
    while(bfs()) {
        memcpy(cur, head, sizeof head);
        ans += dfs(s, INF);
    }
    return ans;
}

int main() {
    getPrime();
    cin >> n;
    int cnt1=0, validN=0;
    for(int i=1; i<=n; ++i) {
        cin >> a[i];
        cnt1 += (a[i]==1);
    }
    // 处理1：仅保留一个1
    bool keepOne=false;
    for(int i=1; i<=n; ++i) {
        if(a[i]==1 && !keepOne) keepOne=true;
        else if(a[i]==1) a[i]=-1; // 标记多余1
    }
    validN = n - (cnt1 ? cnt1-1 : 0);

    s=0; t=2*n+1; // 源汇点
    // 建图：左部(偶数)连源点，右部(奇数)连汇点
    for(int i=1; i<=n; ++i) {
        if(a[i]==-1) continue;
        if(a[i]%2==0) addEdge(s, i, 1);
        else addEdge(i, t, 1);
    }
    // 和为质数则建边
    for(int i=1; i<=n; ++i) {
        if(a[i]==-1 || a[i]%2==1) continue; // 仅左部(偶数)
        for(int j=1; j<=n; ++j) {
            if(a[j]==-1 || a[j]%2==0) continue; // 仅右部(奇数)
            if(isPrime[a[i]+a[j]]) 
                addEdge(i, j, 1);
        }
    }
    int maxMatch = Dinic();
    cout << validN - maxMatch;
}
```
* **代码解读概要**：
> 1. 素数筛预处理（0~2×10⁵）
> 2. 输入时处理多余1（仅保留一个）
> 3. 建二分图：源点→偶数点，奇数点→汇点
> 4. 枚举所有偶-奇对，和为质数则建边
> 5. Dinic算法求最大匹配
> 6. 答案 = 有效点数 - 最大匹配

---

**题解一核心代码（djh123）**
```cpp
rep(i, 1, n) add(s, i, 1), add(i + n, t, 1); // 拆点技巧
rep(i, 1, n) rep(j, 1, n) 
    if(a[i]%2==0 && a[j]%2==1 && vis[a[i]+a[j]] && a[j]!=1) 
        add(i, j + n, inf); // 避免重复选点
```
* **亮点**：创新性拆点（i和i+n）确保点权限制
* **学习笔记**：拆点技巧可有效处理"每个点仅选一次"的限制

**题解二核心代码（mRXxy0o0）**
```cpp
sort(a+1,a+n+1,[](int x,int y){ 
    return (x&1)^(y&1) ? ~x&1 : x>y; 
}); // 偶数排前
for(int i=1; i<=n && (~a[i]&1); ++i) // 仅枚举偶数
    for(int j=n; j>=1 && (a[j]&1); --j) // 仅枚举奇数
        if(!vis[a[i]+a[j]]) G[i].push_back(j); // 建图
```
* **亮点**：奇偶分组排序提升缓存命中率，减少枚举量
* **学习笔记**：优化枚举顺序可大幅提升实际运行效率

**题解三核心代码（decoqwq）**
```cpp
// 处理1后直接建图
for(int i=1;i<=n;i++) {
    if(a[i]%2==0) add(s,i,1); 
    else add(i,t,1);
}
for(int i=1;i<=n;i++) if(a[i]%2==0) 
    for(int j=1;j<=n;j++) if(a[j]%2==1) 
        if(isp[a[i]+a[j]]) add(i,j,1); 
```
* **亮点**：简洁直观的建图逻辑，适合初学者理解
* **学习笔记**：清晰的代码结构比过度优化更重要

---

## 5. 算法可视化：像素动画演示

* **主题**："像素冒险者"的二分图奇偶派对
* **核心演示**：二分图匹配过程（网络流/Hungarian）
* **设计思路**：采用FC红白机像素风格，用不同颜色方块区分奇偶点。质数边显示为红色光带，匹配成功时变为蓝色，独立集点最终绽放金光。

**关键帧步骤**：
1. **初始化**：左侧蓝色偶数方块，右侧红色奇数方块，多余的1被"像素爆炸"动画清除
2. **网络流动画**：源点(蓝色水滴)流向偶数点→质数边(红色光带)→奇数点→汇点(绿色水池)。匹配成功时播放"叮"音效，边变蓝
3. **匈牙利演示**：像素小人（■）从偶数点出发，沿黄色路径寻找增广路，成功时路径变蓝并播放胜利音效
4. **独立集标记**：未覆盖点绽放金光，播放胜利旋律
5. **控制面板**：步进/自动播放(调速)/重置。调试模式可显示当前流量/匹配数

**技术实现**：
- Canvas绘制网格和像素块
- 使用Web Audio API添加音效：水流声(网络流)、脚步声(Hungarian)、胜利音效
- 数据结构可视化：队列用像素方块堆叠，栈用垂直像素柱

---

## 6. 拓展练习与相似问题思考

* **通用思路迁移**：
  二分图建模适用于：
  1. 冲突元素选择（如不能共存的物品）
  2. 任务分配（工人与任务匹配）
  3. 棋盘覆盖问题（黑白染色）

* **洛谷练习推荐**：
  1. **P3386** 二分图最大匹配（模板题）
  2. **P2764** 最小路径覆盖（二分图进阶）
  3. **P2172** 部落战争（网格图二分图应用）

---

## 7. 学习心得与经验分享

> **参考经验 (来自 mRXxy0o0)**："做了一晚上的题，拼尽全力优化匈牙利算法，通过排序、BFS和缓存优化最终AC"
>
> **点评**：算法优化需要结合问题特性（如奇偶分布）。性能瓶颈时，优化枚举顺序和内存访问比更换算法更有效。

---

<conclusion>
本次"反质数序列"的解析就到这里。记住：将复杂问题转化为图论模型是核心能力，算法优化需兼顾代码清晰度。多动手实现不同解法，你的图论能力一定会大幅提升！💪
</conclusion>

---
处理用时：242.31秒
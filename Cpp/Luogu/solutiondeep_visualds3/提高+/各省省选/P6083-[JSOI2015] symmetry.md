# 题目信息

# [JSOI2015] symmetry

## 题目描述

张老师正在课堂上讲解正方形的对称模式。为了简单起见，他用 $01$ 方阵代表一个正方形图形，即把正方形分解成 $n\times n$ 的方格阵，$0$ 代表一个白色方格，$1$ 代表一个黑色方格。

首先讲到的是容易辨别的轴对称，正方形有 $4$ 个对称轴，分别是水平中线，竖直中线和两条对角线。如果一个正方形图形以某个对称轴做反射变换后保持不变，就称为轴对称图形。例如下面的两个图形都是轴对称图形。

```plain
100  010
100  101
111  000
```

张老师继续讲解正方形的旋转对称。如果一个正方形图形以中心点旋转 $180$ 度后保持不变，就称为 $180$ 度对称图形。如果以中心点顺时针旋转 $90$ 度后保持不变，就称为 $90$ 度对称图形，例如下面的两个图形左边是 $180$ 度对称图形，右边是 $90$ 度对称图形。

```plain
0011  1011
1110  1110
0111  0111
1100  1101
```

张老师接着说，如果一个正方形图形具有两个互相垂直的对称轴，就称为 $4$ 对称图形，如果关于 $4$ 个对称轴全部对称，就称为 $8$ 对称图形。按照定义，$90$ 度对称图形也是 $180$ 度对称图形，$8$ 对称图形也是 $4$ 对称图形。当正方形图形的边长为偶数时，该图形的中心是最中间 $4$ 个方格的公共顶点，当正方形图形的边长为奇数时，该图形有一个中心方格，该图
形的中心也是它的中心方格的中心。边长为 $1$ 的图形显然是 $8$ 对称图形。

张老师给学生证明了两个定理。

- 定理 $1$：一个正方形图形是 $4$ 对称图形当且仅对它是 $180$ 度对称图形和轴对称图形。
- 定理 $2$：一个正方形图形是 $8$ 对称图形当且仅对它是 $90$ 度对称图形和轴对称图形。

最后是练习时间，张老师要求学生寻找在大正方形图形中出现的各种对称图形。请你编程实现这个要求。设输入一个 $01$ 方阵，输出满足 $8$ 对称，$90$ 度对称，$4$ 对称，$180$ 度对称和轴对称的最大子连续方阵的边长。子连续方阵是指选择若干相邻行列的子方阵，代表在大图形中出现的小图形。

## 说明/提示

#### 样例说明

大图形有水平对称轴，左上角有一个 $2\times 2$ 的 $8$ 对称图形，中间 $3$ 行最右 $3$ 列构成 $4$ 对称图形。

---

#### 数据范围

对于 $100\%$ 的数据，$5\leq n\leq 500$。

## 样例 #1

### 输入

```
5
11100
11000
10111
11000
11100```

### 输出

```
2 2 3 3 5```

# AI分析结果


### 💡 Kay的C++算法解析：JSOI2015 symmetry 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`哈希优化与坐标变换技巧`  
🗣️ **初步分析**：  
> 本题如同在像素迷宫中寻找对称图案。核心技巧是**二维哈希+坐标变换**——就像给每个图形生成唯一"指纹"，通过比较不同变换后的指纹快速判断对称性。  
> - **核心思路**：构建原始矩阵的6种变换（4种轴对称+2种旋转），用二维哈希快速比较任意子矩阵与变换后的对应区域  
> - **难点突破**：  
>   - 坐标映射：精确推导旋转/轴对称后的位置关系（如90°旋转：(i,j)→(j,n-i+1)）  
>   - 哈希设计：双基数哈希避免碰撞，`h[k][i][j]`存储k号变换的前缀哈希值  
> - **可视化设计**：  
>   - 8位像素网格展示7种变换矩阵  
>   - 高亮当前检测的子矩阵边框，同步显示变换后的对应区域  
>   - 音效设计：坐标变换时触发"咔哒"声，匹配成功时播放8位胜利音效

---

#### 2. 精选优质题解参考
**题解（作者：阔耐滴小云呀）**  
* **点评**：  
  思路极清晰——通过7种变换覆盖所有对称类型，二维哈希实现O(1)比较。代码亮点：  
  - **坐标变换完备性**：精确实现6种几何变换（行13-19）  
  - **哈希优化**：双基数滚动计算（行34-38）降低碰撞概率  
  - **二分策略**：分离奇偶边长检测（行50-65），将复杂度从O(n³)降至O(n²logn)  
  - **工程实践**：边界处理严谨（如`n-i+1`防越界），可直接用于竞赛  
  💡 **唯一改进点**：增加哈希冲突检测机制更稳妥  

---

#### 3. 核心难点辨析与解题策略
1. **坐标映射推导**  
   * **分析**：几何变换需严格满足：  
     - 旋转90°：`(i,j) → (j, n-i+1)`（行15）  
     - 副对角线对称：`(i,j) → (n-j+1, n-i+1)`（行16）  
   * 💡 **学习笔记**：动手画3x3网格验证变换关系  

2. **哈希快速比较**  
   * **分析**：二维哈希值计算：  
     ```math
     H = ∑∑ grid[i][j] × base1^i × base2^j
     ```
     子矩阵哈希通过前缀和差分（行24-26）  
   * 💡 **学习笔记**：选择大质数基数（如19491001）降低碰撞  

3. **二分优化检测**  
   * **分析**：利用对称性单调性——若边长为k满足，则k-2必满足（行48）  
   * 💡 **学习笔记**：奇偶分离二分避免中心点争议  

### ✨ 解题技巧总结
- **空间换时间**：存储7份变换矩阵，避免运行时重复计算  
- **几何映射法**：将抽象对称转化为坐标函数（如`check_90`）  
- **参数化检测**：模板函数`solve<T>`复用检测逻辑（行50）  

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
* **说明**：综合题解思路的精炼版本，突出坐标变换与哈希检测  
```cpp
typedef unsigned long long ull;
const int N=502;
int n; ull h[7][N][N], pw1[N], pw2[N];

// 二维哈希计算（子矩阵(x1,y1)到(x2,y2)）
ull gethash(int k, int x1,int y1,int x2,int y2){
    int w=x2-x1+1;
    return h[k][x2][y2] - h[k][x1-1][y2]*pw1[w] 
         - h[k][x2][y1-1]*pw2[w] + h[k][x1-1][y1-1]*pw1[w]*pw2[w];
}

// 90°旋转对称检测
bool check_90(int x1,int y1,int x2,int y2){
    return gethash(0,x1,y1,x2,y2) == 
           gethash(5,y1,n-x2+1,y2,n-x1+1); // 坐标映射
}
```

**题解片段赏析**  
1. **哈希初始化**  
   ```cpp
   for(int k=0;k<7;k++){
     for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) 
        h[k][i][j] += h[k][i-1][j]*base1;  // 行方向滚动哈希
     for(int i=1;i<=n;i++) for(int j=1;j<=n;j++)
        h[k][i][j] += h[k][i][j-1]*base2;  // 列方向滚动哈希
   }
   ```
   - **解读**：双重循环实现二维前缀哈希，`base1`和`base2`分别控制行/列权重  
   - 💡 **学习笔记**：先处理行后处理列，避免维度干扰  

2. **二分检测框架**  
   ```cpp
   template<typename T> int solve(T f){
     int res=0, l=0,r=(n-1)/2; 
     while(l<r){ // 检测奇数边长
        int mid=(l+r+1)>>1;
        check(f,mid*2+1) ? l=mid : r=mid-1;
     }
     res = max(res, l*2+1);
     // 同理检测偶数边长...
   }
   ```
   - **解读**：通过函数指针`f`复用检测逻辑（如`f=check_90`）  
   - 💡 **学习笔记**：`mid=(l+r+1)>>1`确保二分向上取整  

---

#### 5. 算法可视化：像素动画演示  
**主题**：8位机风格的《对称之谜》解谜游戏  

**动画设计**：  
```plain
  ┌───────────────┐     ┌───────────────┐
  │ 原矩阵        │     │ 90°旋转矩阵   │
  │   □□□■        │     │   □□■□        │
  │   □■□□        │ →  │   □□□■        │
  │   ■□□□        │     │   □■□□        │
  └───────────────┘     └───────────────┘
```
1. **像素网格渲染**  
   - 7x7网格展示原矩阵+6种变换，各用FC复古色调区分  
   - 当前检测的子矩阵显示闪烁金边（2px厚度）  

2. **同步检测演示**  
   - 在90°旋转矩阵中实时显示坐标映射区域（红色半透覆盖）  
   - 哈希匹配成功时：触发绿色脉冲动画+16bit胜利音效  

3. **游戏化进度**  
   - 每完成一种对称检测解锁像素成就徽章  
   - 实时显示最大边长记录（顶部8位数字屏）  

**交互控制**：  
- A键：单步执行检测  
- B键：自动播放（速度可调）  
- SELECT：切换对称类型  

---

#### 6. 拓展练习与相似问题思考
1. **同类问题**：  
   - 矩阵旋转匹配（如LeetCode 48）  
   - 二维哈希应用（如CF 1326D2）  
   - 对称性统计（如洛谷P1903）  

2. **洛谷推荐**：  
   - **P5789** 矩阵旋转 - 巩固坐标变换  
   - **P2601** 对称正方形 - 二维哈希直接应用  
   - **P3396** 哈希冲突 - 深入理解哈希机制  

---

#### 7. 学习心得与经验分享
> **作者调试经验**："坐标映射极易出错，建议用3x3矩阵打印中间结果验证"  
> **Kay总结**：几何变换类题目需：  
> 1. 小规模验证映射关系  
> 2. 封装变换函数避免重复代码  
> 3. 二维哈希是矩阵比较的利器  

---  
通过本次分析，相信大家已掌握对称矩阵检测的核心技巧。记住：好的算法如同完美的对称图形，既需要严谨推导，也需艺术般的优化设计！🎮✨

---
处理用时：157.19秒
# 题目信息

# [LNOI2022] 吃

## 题目描述

小 A 很喜欢吃东西。

小 A 面前有 $n$ 份食物，第 $i$ 份有参数 $a_i$ 和 $b_i$。小 A 可以按照**任意顺序**吃掉这 $n$ 份食物。当她吃掉编号为 $i$ 的食物时，她可以选择将自己的体重乘以 $a_i$ 或者将自己的体重加上 $b_i$。每份食物只能吃恰好一次。

小 A 的初始体重为 $1$，请求出她吃完 $n$ 份食物后能达到的**最大**体重。答案可能很大，你只需要输出其对 $({10}^9 + 7)$ 取模后的结果。

**注意：你需要最大化体重并将该最大值对 $\bm{({10}^9 + 7)}$ 取模，而非最大化体重对 $\bm{({10}^9 + 7)}$ 取模的结果。**

## 说明/提示

**【样例解释 #1】**

以下方案可以达到最大体重：

- 吃掉第一份食物并选择将体重增加 $100$，体重变为 $101$；
- 吃掉第二份食物并选择将体重增加 $200$，体重变为 $301$；
- 吃掉第三份食物并选择将体重乘 $3$，体重变为 $903$；
- 吃掉第四份食物并选择将体重乘 $4$，体重变为 $3612$；
- 吃掉第五份食物并选择将体重乘 $5$，体重变为 $18060$。

**【样例 #2】**

见附件中的 `food/food2.in` 与 `food/food2.ans`。

该组样例满足 $n \le 10$ 和特殊性质 E。

**【样例 #3】**

见附件中的 `food/food3.in` 与 `food/food3.ans`。

该组样例满足 $n \le 20$ 和特殊性质 E。

**【样例 #4】**

见附件中的 `food/food4.in` 与 `food/food4.ans`。

该组样例满足 $n \le 2000$。

**【样例 #5】**

见附件中的 `food/food5.in` 与 `food/food5.ans`。

该组样例满足特殊性质 A。

**【样例 #6】**

见附件中的 `food/food6.in` 与 `food/food6.ans`。

该组样例满足特殊性质 C。

**【样例 #7】**

见附件中的 `food/food7.in` 与 `food/food7.ans`。

该组样例满足特殊性质 D。

**【样例 #8】**

见附件中的 `food/food8.in` 与 `food/food8.ans`。

该组样例满足特殊性质 B。

**【样例 #9】**

见附件中的 `food/food9.in` 与 `food/food9.ans`。

**【数据范围】**

对于 $100 \%$ 的测试数据，$1 \le n \le 5 \times {10}^5$，$1 \le a_i, b_i \le {10}^6$。

| 测试点编号 | $n \le $ | 特殊性质 |
|:-:|:-:|:-:|
| $1$ | $10$ | DE |
| $2$ | $10$ | E |
| $3$ | $10$ | AE |
| $4$ | $10$ | E |
| $5$ | $20$ | DE |
| $6$ | $20$ | E |
| $7$ | $20$ | E |
| $8$ | $20$ | E |
| $9$ | $2000$ | D |
| $10$ | $2000$ | 无 |
| $11$ | $2000$ | 无 |
| $12$ | $2000$ | 无 |
| $13$ | $5 \times {10}^5$ | BD |
| $14$ | $5 \times {10}^5$ | B |
| $15$ | $5 \times {10}^5$ | C |
| $16$ | $5 \times {10}^5$ | C |
| $17$ | ${10}^5$ | 无 |
| $18$ | ${10}^5$ | 无 |
| $19$ | $5 \times {10}^5$ | 无 |
| $20$ | $5 \times {10}^5$ | 无 |

特殊性质 A：$a_i = 1$。  
特殊性质 B：$a_i \ge b_i$。  
特殊性质 C：$a_i, b_i$ 在 $[1, {10}^6]$ 内独立均匀随机生成。  
特殊性质 D：$a_i \ge 2$。  
特殊性质 E：$a_i \le 4$。

## 样例 #1

### 输入

```
5
1 2 3 4 5
100 200 300 400 500
```

### 输出

```
18060
```

# AI分析结果


### Kay的C++算法解析：[LNOI2022]吃 深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`贪心策略与数学推导`

🗣️ **初步分析**：
> 本题的核心在于**操作顺序的决策**：当面对乘法（放大基数）和加法（固定增量）两种操作时，如何通过贪心策略最大化最终结果？想象你在玩一个成长类RPG游戏——初始攻击力为1，每个食物是增强道具，选择"暴击倍率"（乘）或"固定伤害"（加）会影响最终战力。
> - **关键策略**：① 所有`a_i=1`的食物必选加法（无放大效果）；② 其余食物遵循"先加后乘"原则；③ 在`a_i≥2`的食物中**至多执行一次加法**（证明：若两次加法`b_i+b_j`，改为`max(b_i,b_j) + a_j×min(b_i,b_j)`更优）
> - **可视化设计**：采用**复古像素RPG风格**，用"道具选择界面"展示食物分类，角色属性面板实时显示当前值S。关键决策点用闪光边框高亮，当选择加法时播放"金币音效"，乘法时播放"升级音效"。

---

#### 2. 精选优质题解参考
**题解一（来源：7KByte）**
* **点评**：思路直击要害——用三句话概括核心结论（a_i=1必加/先加后乘/至多一加），证明简洁有力。代码实现极简：用浮点数比较避免溢出，变量名`S`、`a`、`b`语义清晰。亮点在于**边界处理**：未选择加法时直接全乘，避免冗余判断。（综合评分：★★★★★）

**题解二（来源：lnwhl）**
* **点评**：结构工整如教科书——先定理后证明再实现。特别值得学习的是**防御性编程**：用`long double`防止精度丢失，`food[]`结构体提升可读性。稍显不足是未显式处理"不加"的情况，但逻辑仍完备。（综合评分：★★★★☆）

**题解三（来源：happybob）**
* **点评**：**教学价值突出**——通过注释详解每个数学推导步骤。代码中`work[]`数组分离有效数据，`pos`标识符明确决策点。亮点是**错误处理**：专门用`!place`处理无加法选择的情况，体现严谨性。（综合评分：★★★★☆）

---

#### 3. 核心难点辨析与解题策略
1. **难点1：操作顺序的数学证明**
   * **分析**：加法必须优先于乘法（否则增量会被放大倍数稀释）。设当前值`S`，若先乘`a_i`再加`b_i`得`S×a_i+b_i`，而先加后乘得`(S+b_i)×a_i`，后者≥前者因`a_i≥1`。
   * 💡 **学习笔记**：顺序决定收益——固定增量要趁早！

2. **难点2：加法次数的极限证明**
   * **分析**：假设对`i,j`执行加法，收益`b_i+b_j`。若将`b_i`改为乘`a_i`，新收益`b_j×a_i`。由`a_i≥2`得`b_j×a_i ≥ b_i+b_j`（因`b_j≥b_i`时`b_j×2≥b_i+b_j`）。
   * 💡 **学习笔记**：贪心黄金律——当增量代价小于放大收益时，乘法优先。

3. **难点3：最优加法的选择策略**
   * **分析**：设`P=∏a_i`，全乘收益为`S×P`。若对`i`加法，收益变为`(S+b_i)×P/a_i`。决策点转化为比较`(S+b_i)/a_i`的大小，最大者即最优候选。
   * 💡 **学习笔记**：比较的艺术——浮点数避免溢出，但需注意精度误差（本题`1e12`内安全）。

### ✨ 解题技巧总结
- **技巧1：问题分解三阶法**  
  `1.分离特殊项(a_i=1)→2.证明操作约束(至多一加)→3.比较决策参数`
- **技巧2：数学建模转化**  
  将乘法操作转化为全局乘积因子，通过`(S+b_i)/a_i`统一比较标准
- **技巧3：边界鲁棒性**  
  始终考虑`max_val≤S`时需回退到全乘方案

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**
```cpp
#include <iostream>
using namespace std;
const int MOD = 1e9+7;

int main() {
    long long S = 1, max_val = 0;
    int n, pos = -1;
    cin >> n;
    int a[n], b[n];
    
    // 输入与预处理a_i=1
    for (int i = 0; i < n; i++) cin >> a[i];
    for (int i = 0; i < n; i++) {
        cin >> b[i];
        if (a[i] == 1) S += b[i];
    }
    max_val = S;  // 初始最大值（全乘方案）

    // 寻找最优加法候选
    for (int i = 0; i < n; i++) {
        if (a[i] == 1) continue;
        double val = (S + b[i]) / (double)a[i];
        if (val > max_val) max_val = val, pos = i;
    }

    // 执行决策
    if (pos != -1) S = (S + b[pos]) % MOD;
    for (int i = 0; i < n; i++) 
        if (a[i] != 1 && i != pos) 
            S = S * a[i] % MOD;
    
    cout << S;
}
```
**代码解读概要**：  
1. **输入阶段**：用数组存储`a_i`和`b_i`  
2. **预处理**：直接累加`a_i=1`的`b_i`到`S`  
3. **决策扫描**：计算`(S+b_i)/a_i`并记录最大值位置  
4. **执行阶段**：按决策执行加法后，遍历执行乘法  

**题解一（7KByte）核心片段**  
```cpp
double w = S;  // 初始比较基准
rp(i, m) {  // 遍历非a_i=1的食物
    double cur = (S + a[i].b) * 1. / a[i].a;
    if (cur > w) w = cur, pv = i; // 更新最优选择
}
```
**亮点**：用浮点数避免取模干扰  
**学习笔记**：`1.0*`显式转换防止整数除法丢失精度  

**题解二（lnwhl）核心片段**  
```cpp
long double Max = S; // 初始化最大值
for (int i = 1; i <= cnt; i++) {
    long double now = 1.0 * (S + food[i].y) / food[i].x;
    if (now > Max) Max = now, cur = i; // 浮点数比较
}
```
**亮点**：`long double`提升比较精度  
**学习笔记**：浮点比较需用`>`而非`≥`，避免无意义更新  

**题解三（happybob）核心片段**  
```cpp
if (!place) { // 处理无加法选择
    for (int i = 1; i <= n; i++) 
        if (a[i] != 1) ans = ans * a[i] % MOD;
} else { // 执行加法+选择性乘法
    ans = (ans + b[place]) % MOD;
    ... // 乘法循环
}
```
**亮点**：`!place`明确处理分支  
**学习笔记**：分支结构提升可读性，避免嵌套条件  

---

#### 5. 算法可视化：像素动画演示
![](https://via.placeholder.com/800x400?text=Pixel+Art+Demo)  
* **主题**："勇者成长记"（8-bit RPG风格）  
* **核心流程**：  
  1. **道具分类**：  
     - 像素图标区分`加血瓶`(a_i=1)和`符文石`(a_i≥2)  
     - 初始状态：勇者S=1（左下角血条显示）  
  2. **阶段执行**：  
     - **阶段1**：自动吸收所有血瓶，S值增长，播放"治疗音效"  
     - **阶段2**：符文石悬浮环绕，光标扫描比较`(S+b_i)/a_i`  
     - **决策闪光**：最优石头闪光3次+"叮！"音效  
  3. **战斗结果**：  
     - 成功：乘法符文连环爆炸，S值飙升+升级音效  
     - 失败：灰色符文坠落（当`(S+b_i)/a_i<S`）  

* **交互控制面板**：  
  ![](https://via.placeholder.com/300x100?text=Control+Panel)  
  - `▶️`继续/`⏸️`暂停/`⏩`步进  
  - 速度条：调整动画速度（0.5x~2x）  
  - 重置按钮：像素风格骷髅图标  

* **技术实现**：  
  ```javascript
  // 伪代码：核心动画流程
  function drawAnimation() {
      drawPixelArtBackground(); // 16色调色板
      drawHero(S); // 角色血条像素绘制
      items.forEach(item => {
          if (item.a == 1) flashGreen(); // 血瓶闪烁绿光
          else {
              let value = (S + item.b) / item.a;
              drawValueBar(value); // 显示浮点数值条
          }
      });
      playSound('decision'); // 选择最优项时播放音效
  }
  ```

---

#### 6. 拓展练习与相似问题
* **技巧迁移场景**：  
  1. 操作顺序优化（如：区间覆盖问题）  
  2. 增量与放大交替决策（如：股票多次买卖）  
  3. 离散事件的最优序列（如：任务调度）  

* **洛谷推荐**：  
  1. **P1080 国王游戏**  
     🗣️ 推荐理由：同样需要证明操作顺序的贪心策略，强化比较函数设计能力  
  2. **P1090 合并果子**  
     🗣️ 推荐理由：变形贪心决策，理解"局部最优→全局最优"的思维链条  
  3. **P5021 赛道修建**  
     🗣️ 推荐理由：进阶版贪心+二分验证，培养决策验证思维  

---

#### 7. 学习心得与经验分享
> **参考经验（来自7KByte）**：  
> *"交了六发才AC，出题人构造了精妙的边界数据——当所有`(S+b_i)/a_i < S`时必须回退全乘方案"*  
>  
> **Kay点评**：  
> 这个教训极其珍贵！在贪心问题中：  
> 1. **边界即陷阱**：始终考虑"策略无效"的fallback方案  
> 2. **数据验证**：用`a_i=1000000, b_i=1`测试回退逻辑  
> 3. **浮点精度**：当`S>1e12`时需改用`long double`  

---

通过本次分析，我们深入剖析了贪心策略的三大核心：**操作顺序证明**、**决策数量限制**、**参数比较模型**。记住：真正的算法高手不是记住解法，而是掌握"为什么这样做最优"的推导能力！下次挑战见！💪

---
处理用时：218.67秒
# 题目信息

# [CQOI2014] 通配符匹配

## 题目描述

几乎所有操作系统的命令行界面（CLI）中都支持文件名的通配符匹配以方便用户。最常见的通配符有两个，一个是星号（```*```），可以匹配 0 个及以上的任意字符：另一个是问号（```?```），可以匹配恰好一个任意字符。现在需要你编写一个程序，对于给定的文件名列表和一个包含通配符的字符串，判断哪些文件可以被匹配。


## 说明/提示

对于 $100 \%$ 的数据

- 字符串长度不超过 $100000$
- $1 \le n \le 100$
- 通配符个数不超过 $10$


## 样例 #1

### 输入

```
*aca?ctc
6
acaacatctc
acatctc
aacacatctc
aggggcaacacctc
aggggcaacatctc
aggggcaacctct```

### 输出

```
YES

YES

YES

YES

YES

NO```

# AI分析结果



---
# 💡 Kay的C++算法解析：通配符匹配 深入学习指南 💡

<introduction>
今天我们来一起分析“通配符匹配”这道C++编程题。这道题需要处理包含`*`（匹配0+任意字符）和`?`（匹配1个任意字符）的模式串，判断多个文件名是否能被匹配。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串处理与动态规划/哈希应用`

🗣️ **初步分析**：
解决“通配符匹配”的关键在于处理通配符的分段匹配。简单来说，我们需要将模式串按`*`分割成多个子段，每个子段可能包含`?`。核心思路是：先匹配首尾固定子段（无`*`开头/结尾时），再依次匹配中间子段，利用`*`的灵活性覆盖任意长度的字符。

- **题解思路对比**：主流方法有哈希+动态规划（高效比较子串）、KMP（但因`?`导致next数组失效）、爆搜（简单但效率低）。其中哈希+DP因时间复杂度可控（O(通配符数×文本长度)）和实现清晰，成为最优解。
- **核心算法流程**：将模式串按`*`分段→预处理各子段哈希值→动态规划状态`dp[i][j]`表示前i个通配符段匹配文本前j字符→利用哈希O(1)比较子串是否匹配→根据通配符类型（`*`或`?`）转移状态。
- **可视化设计**：采用8位像素风格，用不同颜色方块表示模式段（如蓝色为普通子段，黄色为`?`，红色为`*`），动画演示分段匹配过程：文本串从左到右滑动，每匹配一个子段时高亮对应区域，`*`段用“扩散”动画表示覆盖任意长度字符，伴随“叮”音效（匹配成功）或“滴”音效（匹配失败）。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，以下题解因思路清晰、代码规范、算法高效被选为优质参考（≥4星）：
</eval_intro>

**题解一：Orion545 (赞：88)**
* **点评**：此题解详细记录了从KMP到哈希+DP的调试过程，对错误原因（`?`破坏KMP的next数组）和优化思路（哈希快速比较子段+动态规划转移）的分析尤为透彻。代码虽长但结构清晰（如`gethash`函数预处理哈希值，`dp`数组处理状态转移），边界条件处理严谨（如首尾非`*`时的强制匹配），实践参考价值高。

**题解二：K8He (赞：16)**
* **点评**：此题解基于动态规划+哈希，状态定义明确（`f[i][j]`表示前i段匹配文本前j字符），转移方程简洁（分`*`、`?`、普通字符三种情况）。代码模块化（`Hash`类预处理哈希，`Pre`函数分割模式串），变量命名直观（如`len[i]`表示第i段长度），适合学习动态规划与哈希结合的技巧。

**题解三：letitdown (赞：21)**
* **点评**：此题解用哈希+递归实现分段匹配，代码简洁（如`doit`和`ask`函数分别处理`*`和`?`），关键逻辑（首尾强制匹配、中间段递归搜索）清晰。虽未用动态规划，但通过预处理哈希值优化了子串比较效率，适合理解基础分段匹配思路。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题时，常见难点及应对策略如下：
</difficulty_intro>

1.  **关键点1：模式串的分段处理**
    * **分析**：模式串需按`*`分割为多个子段（如`*aca?ctc`分为`aca?ctc`），首尾可能无`*`（需强制匹配文本首尾）。处理时需注意：若模式串以字符开头/结尾，文本串的开头/结尾必须完全匹配该子段。
    * 💡 **学习笔记**：分段是解题的第一步，需明确每段的类型（普通字符、`?`、`*`）。

2.  **关键点2：子串的高效比较**
    * **分析**：比较文本子串与模式子段时（含`?`），直接逐个字符比较效率低（O(n)）。通过哈希预处理（如多项式哈希），可O(1)比较子串是否匹配（`?`视为通配符，不参与哈希计算）。
    * 💡 **学习笔记**：哈希是处理字符串匹配问题的“加速引擎”，预处理哈希值能大幅提升效率。

3.  **关键点3：动态规划状态转移**
    * **分析**：状态`dp[i][j]`表示前i个模式段匹配文本前j字符。转移时：若当前段是`*`，可覆盖任意长度（`dp[i][j] |= dp[i-1][k]`，k≤j）；若是`?`，需匹配1个字符（`dp[i][j] |= dp[i-1][j-1]`）；普通段需哈希匹配（`dp[i][j] |= dp[i-1][j-len]`）。
    * 💡 **学习笔记**：动态规划的核心是状态定义和转移，需结合通配符特性设计合理的转移规则。

### ✨ 解题技巧总结
<summary_best_practices>
- **分段预处理**：先分割模式串为子段，明确首尾是否需强制匹配。
- **哈希优化**：预处理模式段和文本串的哈希值，O(1)比较子串。
- **动态规划状态压缩**：用一维数组代替二维数组（如`dp[j]`表示当前段匹配文本前j字符），节省空间。
- **边界特判**：处理模式串首尾非`*`时，文本串首尾必须匹配对应子段。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路（哈希+动态规划）的通用核心实现，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合Orion545和K8He的思路，采用哈希预处理+动态规划，处理模式串分段、哈希比较及状态转移。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef unsigned long long ull;
    const ull BASE = 1331;
    const int MAXN = 1e5 + 5;
    const int MAX_SEG = 15; // 通配符最多10个，分段数≤11

    vector<string> seg; // 存储模式串分割后的子段（不含*）
    vector<int> op;     // 每个子段前的通配符类型（0:无,1:?,2:*）
    ull seg_hash[MAX_SEG]; // 各子段的哈希值（不含?）
    ull pow_base[MAXN]; // 预处理BASE的幂次

    // 预处理BASE的幂次
    void init_pow() {
        pow_base[0] = 1;
        for (int i = 1; i < MAXN; ++i)
            pow_base[i] = pow_base[i-1] * BASE;
    }

    // 计算字符串s的哈希值（忽略?）
    ull get_hash(const string &s) {
        ull h = 0;
        for (char c : s) {
            if (c != '?') h = h * BASE + (c - 'a' + 1);
        }
        return h;
    }

    // 分割模式串，处理通配符
    void split_pattern(const string &s) {
        seg.clear(); op.clear();
        string cur;
        bool prev_star = false;
        for (char c : s) {
            if (c == '*' || c == '?') {
                if (!cur.empty()) {
                    seg.push_back(cur);
                    op.push_back(prev_star ? 2 : 0); // 前一个是*则当前段前是*
                }
                op.push_back(c == '?' ? 1 : 2); // 记录当前通配符类型
                cur.clear();
                prev_star = (c == '*');
            } else {
                cur += c;
                prev_star = false;
            }
        }
        if (!cur.empty()) {
            seg.push_back(cur);
            op.push_back(prev_star ? 2 : 0);
        }
        // 预处理各子段哈希值
        for (int i = 0; i < seg.size(); ++i)
            seg_hash[i] = get_hash(seg[i]);
    }

    // 判断文本串t是否匹配模式串
    bool is_match(const string &t) {
        int m = t.size();
        vector<ull> t_hash(m + 1, 0);
        for (int i = 0; i < m; ++i)
            t_hash[i+1] = t_hash[i] * BASE + (t[i] - 'a' + 1);

        vector<bool> dp(m + 1, false);
        dp[0] = true; // 初始状态：0字符匹配0段

        for (int i = 0; i < seg.size(); ++i) {
            vector<bool> new_dp(m + 1, false);
            int len = seg[i].size();
            for (int j = 0; j <= m; ++j) {
                if (!dp[j]) continue;
                // 处理当前段前的通配符
                if (op[i] == 2) { // *: 可覆盖0+字符，直接继承所有j'≥j的状态
                    for (int k = j; k <= m; ++k)
                        new_dp[k] = true;
                } else if (op[i] == 1) { // ?: 需匹配1字符，j+1
                    if (j + 1 <= m) new_dp[j+1] = true;
                } else { // 普通段：需哈希匹配长度为len的子串
                    if (j + len > m) continue;
                    ull t_h = t_hash[j+len] - t_hash[j] * pow_base[len];
                    if (t_h == seg_hash[i])
                        new_dp[j+len] = true;
                }
            }
            dp = move(new_dp);
        }
        return dp[m];
    }

    int main() {
        init_pow();
        string pattern;
        cin >> pattern;
        split_pattern(pattern);
        int Q; cin >> Q;
        while (Q--) {
            string s; cin >> s;
            cout << (is_match(s) ? "YES" : "NO") << '\n';
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先预处理BASE的幂次，分割模式串为子段并计算哈希值。`is_match`函数通过动态规划判断文本串是否匹配：`dp[j]`表示前i段匹配文本前j字符，根据通配符类型（`*`、`?`、普通段）转移状态，最终检查`dp[m]`是否为真。

---
<code_intro_selected>
接下来，剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：Orion545（哈希+DP优化）**
* **亮点**：通过哈希预处理和动态规划优化，解决了KMP因`?`失效的问题，代码严谨处理了首尾非`*`的强制匹配。
* **核心代码片段**：
    ```cpp
    // 预处理模式串的哈希值
    ll gethash(char s[], int len) {
        ll re = 0;
        for (int i = 0; i < len; ++i)
            re = re * key + (ll)s[i];
        return re;
    }

    // 动态规划转移
    for (j = 0; j <= len; ++j) {
        if (!dp[i][j]) continue;
        t1 = pre[j + stl[i+1]] - pre[j] * mul[stl[i+1]];
        if (t1 == h[i+1]) {
            if (sp[i+1]) // *: 覆盖所有j'≥j+stl[i+1]
                for (k = j + stl[i+1]; k <= len; ++k)
                    dp[i+1][k] = 1;
            else // ?: 仅j+stl[i+1]+1
                dp[i+1][j + stl[i+1] + 1] = 1;
        }
    }
    ```
* **代码解读**：`gethash`计算模式子段的哈希值，`pre`数组存储文本串的前缀哈希。动态规划中，若当前段哈希匹配（`t1 == h[i+1]`），根据通配符类型（`*`或`?`）更新状态：`*`允许覆盖任意后续长度，`?`仅匹配1字符。
* 💡 **学习笔记**：哈希预处理是关键，动态规划需结合通配符特性设计转移规则。

**题解二：K8He（DP状态定义）**
* **亮点**：状态`f[i][j]`定义清晰，转移方程分三种通配符类型，代码模块化（`Hash`类处理哈希）。
* **核心代码片段**：
    ```cpp
    // 动态规划转移
    for (int i = 1; i <= m; ++i) {
        for (int j = 0; j <= ln; ++j) {
            if (Check(i, j)) { // 哈希匹配当前段
                if (op[i] == 0) f[i][j] = f[i-1][j - len[i]];
                else if (op[i] == 1) f[i][j] = f[i-1][j - len[i] - 1];
                else f[i][j] = sm[j - len[i]]; // sm是前缀和优化
            }
        }
    }
    ```
* **代码解读**：`Check`函数用哈希判断子串是否匹配。`op[i]`为0（普通段）时，状态从`j-len[i]`转移；为1（`?`）时，从`j-len[i]-1`转移；为2（`*`）时，用前缀和数组`sm`优化，快速合并所有可能的前驱状态。
* 💡 **学习笔记**：前缀和优化可将`*`的O(n)转移降为O(1)，大幅提升效率。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解分段匹配过程，我们设计一个“像素匹配小冒险”动画，用8位像素风格演示模式串分段、哈希比较及动态规划转移！
</visualization_intro>

  * **动画演示主题**：`像素小探险家的通配符挑战`

  * **核心演示内容**：模式串分割为多个子段（如`aca?ctc`），小探险家从文本串左端出发，依次匹配每个子段：遇到`*`时可跳跃任意长度（用“彩虹桥”动画表示），遇到`?`时需匹配1个字符（用“踩砖块”动画），最终到达文本串末尾则成功。

  * **设计思路简述**：8位像素风格（类似红白机）营造轻松氛围；关键步骤高亮（如匹配成功时子段变绿色，`*`段用红色闪烁）；音效（匹配成功“叮”，失败“滴”）强化记忆；自动播放模式让学习者观察完整流程。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为左右两部分：左为模式串（分段显示，`*`标红，`?`标黄），右为文本串（像素方块排列）。
        - 控制面板：单步/自动播放按钮、速度滑块、重置按钮。

    2.  **分段匹配演示**：
        - 小探险家（像素小人）站在文本串左端，指向第一个模式子段。
        - **普通段匹配**：小人逐个检查文本方块，匹配时方块变绿；若哈希匹配成功（动画显示哈希值相等），小人跳到下一段起点。
        - **`?`段匹配**：小人踩一个文本方块（变蓝），表示匹配1个字符，跳到下一段。
        - **`*`段匹配**：小人释放“彩虹桥”覆盖若干文本方块（随机长度），直接跳到下一段起点。

    3.  **动态规划状态转移**：
        - 右侧显示`dp`数组（像素格子），匹配成功时对应格子变绿；`*`段转移时，连续多个格子同时变绿（表示覆盖任意长度）。

    4.  **成功/失败反馈**：
        - 若匹配到文本末尾，播放“胜利”音效（8位音乐），小探险家举旗庆祝；否则播放“失败”音效，文本串末尾变红。

  * **旁白提示**：
    - “看！小探险家正在匹配第一个子段，每个字符都要对上哦～”
    - “遇到`*`啦！它可以跳过任意多的字符，直接到下一段！”
    - “哈希值相等啦，这段匹配成功！”

<visualization_conclusion>
通过这个动画，我们能直观看到分段匹配的每一步，理解哈希如何加速比较，以及动态规划如何处理通配符的灵活性。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可尝试以下题目巩固字符串匹配与动态规划技巧：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 哈希+动态规划适用于含通配符的字符串匹配、病毒检测（如P2536）等问题。
    - 分段处理思想可迁移到正则表达式匹配、文件路径通配等场景。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P2536 [AHOI2005]病毒检测**
          * 🗣️ **推荐理由**：同样涉及通配符匹配，需处理更复杂的病毒模式串，巩固分段匹配和哈希应用。
    2.  **洛谷 P5283 [十二省联考2019]异或粽子**
          * 🗣️ **推荐理由**：考察前缀和与哈希的结合，提升复杂问题的分解能力。
    3.  **洛谷 P4503 [CTSC2014]企鹅QQ**
          * 🗣️ **推荐理由**：利用哈希处理字符串相似性，强化哈希在字符串问题中的应用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
Orion545在题解中分享：“调试时发现KMP因`?`导致next数组错误，后来通过哈希+DP解决。这让我意识到，遇到特殊字符时需重新审视算法的前提条件。”
</insights_intro>

> **参考经验**：“最初用KMP但WA，因为`?`的通配性破坏了next数组的公共前后缀假设。后来改用哈希预处理子段，结合动态规划处理通配符，才AC。”

**点评**：Orion545的经验提醒我们，算法的适用条件很重要（如KMP要求字符意义固定）。遇到特殊字符时，需考虑算法是否仍满足前提，必要时换用哈希等更灵活的方法。调试时多尝试不同方法，记录错误原因，能快速找到突破口。

-----

<conclusion>
本次“通配符匹配”的分析就到这里。希望大家通过本指南掌握分段匹配、哈希优化和动态规划的技巧。记住，编程的关键是理解问题本质，灵活选择算法！下次见～💪
</conclusion>

---
处理用时：214.53秒
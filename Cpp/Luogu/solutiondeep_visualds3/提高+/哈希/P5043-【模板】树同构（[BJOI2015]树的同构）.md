# 题目信息

# 【模板】树同构（[BJOI2015]树的同构）

## 题目描述

树是一种很常见的数据结构。

我们把 $N$ 个点，$N-1$ 条边的连通无向图称为树。

若将某个点作为根，从根开始遍历，则其它的点都有一个前驱，这个树就成为有根树。

对于两个树 $T_1$ 和 $T_2$，如果能够把树 $T_1$ 的所有点重新标号，使得树 $T_1$ 和树 $T_2$ 完全相同，那么这两个树是同构的。也就是说，它们具有相同的形态。

现在，给你 $M$ 个无根树，请你把它们按同构关系分成若干个等价类。

## 说明/提示

编号为 $1, 2, 4$ 的树是同构的。编号为 $3$ 的树只与它自身同构。

对于 $100\%$ 的数据，$1\leq N,M\leq 50$。

## 样例 #1

### 输入

```
4 
4 0 1 1 2 
4 2 0 2 3 
4 0 1 1 1 
4 0 1 2 3 ```

### 输出

```
1 
1 
3 
1 ```

# AI分析结果



---
# 💡 Kay的C++算法解析：树同构（[BJOI2015]树的同构）深入学习指南 💡

<introduction>
今天我们要解决的问题是“树同构”，即判断多棵无根树是否可以通过重新标号变成相同结构。这需要我们理解如何将树的结构转化为唯一标识，进而分类。本指南将带大家梳理核心思路、关键算法，并通过可视化和代码分析深入掌握解题技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`树结构处理与哈希应用（编程技巧应用）`

🗣️ **初步分析**：  
判断树同构的核心是找到一种方法，将树的结构转化为唯一的“标识”（如哈希值或最小表示字符串），使得同构的树有相同标识，不同构的树标识不同。  

简单来说，树哈希就像给树“拍一张结构照”，用一个数字或字符串代表树的结构；最小表示法则是通过DFS生成括号序列，并取所有可能序列中的字典序最小值，确保同构树的最小序列相同。  

在本题中，主要难点是处理无根树：  
- **无根树转有根树**：选择树的重心（最多2个）作为根，因为重心是树的“中心”，结构稳定，同构树的重心位置对应。  
- **哈希设计**：子树哈希值需排序后合并，避免因子树顺序不同导致哈希值不同。  

核心算法流程：  
1. 对每棵树找到所有重心（最多2个）。  
2. 以每个重心为根，计算该有根树的哈希值或最小表示。  
3. 取所有重心对应的标识中的最小值作为该树的唯一标识。  
4. 比较所有树的标识，分类同构树。  

**可视化设计思路**：  
采用8位像素风格，用网格表示树结构。动画中：  
- 用不同颜色标记重心（如红色），展示找重心的过程（删除节点后最大连通块的大小变化）。  
- 动态生成哈希值：子树哈希值排序后合并，用像素方块堆叠表示，伴随“叮”的音效（子树处理完成）。  
- 最终标识比较时，相同标识的树会闪烁绿色，不同则红色。  

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下题解值得重点学习：
</eval_intro>

**题解一：作者zhoukangyang（赞136）**  
* **点评**：此题解结合多项式哈希与重心处理，思路清晰。通过排序子树哈希值避免顺序影响，利用重心减少根的枚举量，时间复杂度为$O(mn \log n)$，适合竞赛场景。代码中变量命名规范（如`rt`表示重心，`sav`存储子树哈希），边界处理严谨（如双重心时取哈希值的最大值）。  

**题解二：作者ix35（赞39）**  
* **点评**：此题解使用最小表示法，通过DFS生成括号序列并排序子树序列，确保同构树的最小表示相同。代码中`f[x]`表示以x为根的子树最小表示，逻辑直观，适合理解树结构的唯一表示原理。  

**题解三：作者hyfhaha（赞58）**  
* **点评**：此题解用简单哈希实现，代码简洁（仅30余行），适合快速上手。通过遍历所有节点为根计算哈希值，排序后比较，虽时间复杂度较高（$O(n^2m)$），但在数据范围小（n≤50）时足够高效。  

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决树同构问题时，以下三个关键点需重点突破：
</difficulty_intro>

1.  **关键点1：如何选择无根树的根？**  
    * **分析**：直接枚举所有节点为根会导致复杂度爆炸（$O(n^2m)$）。树的重心（删除后最大连通块最小的节点）最多有2个，同构树的重心位置对应，因此选择重心作为根可大幅减少计算量。  
    * 💡 **学习笔记**：找重心时，通过DFS计算每个节点的最大子树大小，取最小值对应的节点。  

2.  **关键点2：如何设计唯一的树哈希？**  
    * **分析**：哈希需满足“同构树哈希相同，不同构树哈希不同”。常见方法是：子树哈希排序后合并（避免顺序影响），如`hash[x] = 1 + sum(hash[son] * prime[size[son]])`，其中`prime`是质数数组，避免冲突。  
    * 💡 **学习笔记**：哈希函数中加入子树大小（如乘以质数）可增强唯一性。  

3.  **关键点3：如何处理双重心情况？**  
    * **分析**：若树有两个重心（如偶数节点的链），需计算两个重心对应的哈希值，取最小值作为树的唯一标识，确保同构树的标识一致。  
    * 💡 **学习笔记**：双重心时，两个哈希值需都参与比较，取较小者统一标识。  

### ✨ 解题技巧总结
- **问题分解**：将无根树问题转化为有根树问题，通过重心缩小根的范围。  
- **哈希优化**：子树哈希排序后合并，避免子树顺序影响结果。  
- **边界处理**：双重心时需同时计算两个根的哈希，取最小值统一标识。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结合了重心处理与哈希计算，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了zhoukangyang和ix35的思路，使用重心作为根，计算哈希值，适合竞赛场景。  
* **完整核心代码**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 55;
const int MOD = 1e9 + 7;
const int PRIME = 19491001;

int pow_prime[N]; // 预处理质数幂
struct Tree {
    int A, B; // 双重心的哈希值
} trees[N];

vector<int> g[N];
int n, sz[N], max_sub[N];
int hash_val[N];

// 找重心
void find_centroid(int u, int fa) {
    sz[u] = 1;
    max_sub[u] = 0;
    for (int v : g[u]) {
        if (v == fa) continue;
        find_centroid(v, u);
        sz[u] += sz[v];
        max_sub[u] = max(max_sub[u], sz[v]);
    }
    max_sub[u] = max(max_sub[u], n - sz[u]);
}

// 计算以u为根的哈希值
int dfs_hash(int u, int fa) {
    vector<int> child_hash;
    for (int v : g[u]) {
        if (v == fa) continue;
        child_hash.push_back(dfs_hash(v, u));
    }
    sort(child_hash.begin(), child_hash.end()); // 子树哈希排序
    int res = 1;
    for (int h : child_hash) {
        res = (1LL * res * PRIME + h) % MOD;
    }
    return res;
}

// 初始化每棵树
void init_tree(int idx) {
    cin >> n;
    for (int i = 1; i <= n; i++) g[i].clear();
    for (int i = 1; i <= n; i++) {
        int p; cin >> p;
        if (p) {
            g[i].push_back(p);
            g[p].push_back(i);
        }
    }
    // 找重心
    find_centroid(1, -1);
    int min_max = *min_element(max_sub + 1, max_sub + n + 1);
    vector<int> centroids;
    for (int i = 1; i <= n; i++) {
        if (max_sub[i] == min_max) centroids.push_back(i);
    }
    // 计算哈希
    if (centroids.size() == 1) {
        trees[idx].A = dfs_hash(centroids[0], -1);
        trees[idx].B = -1;
    } else {
        trees[idx].A = dfs_hash(centroids[0], -1);
        trees[idx].B = dfs_hash(centroids[1], -1);
        if (trees[idx].A > trees[idx].B) swap(trees[idx].A, trees[idx].B);
    }
}

int main() {
    pow_prime[0] = 1;
    for (int i = 1; i < N; i++) {
        pow_prime[i] = 1LL * pow_prime[i - 1] * PRIME % MOD;
    }
    int m; cin >> m;
    for (int i = 1; i <= m; i++) init_tree(i);
    // 分类同构树
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= i; j++) {
            bool same = false;
            if (trees[j].B == -1 && trees[i].B == -1) {
                same = (trees[j].A == trees[i].A);
            } else if (trees[j].B != -1 && trees[i].B != -1) {
                same = (trees[j].A == trees[i].A && trees[j].B == trees[i].B) ||
                       (trees[j].A == trees[i].B && trees[j].B == trees[i].A);
            } else {
                // 不可能，因同构树重心数量相同
            }
            if (same) {
                cout << j << endl;
                break;
            }
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  代码首先预处理质数幂，用于哈希计算。`find_centroid`函数找重心，`dfs_hash`计算以某节点为根的哈希值（子树哈希排序后合并）。`init_tree`初始化每棵树，记录重心对应的哈希值。最后通过比较哈希值分类同构树。  

---

<code_intro_selected>
以下是优质题解的核心片段分析：
</code_intro_selected>

**题解一：作者zhoukangyang（多项式哈希）**  
* **亮点**：利用多项式哈希和重心处理，时间复杂度低。  
* **核心代码片段**：  
```cpp
void dfs(int x, int fa) {
    has[x] = 1ll * dep[x] * Pow[1] % mod;
    siz[x] = 1;
    vector<pair<int, int>> sav; // 存储子树哈希和大小
    for (int v : g[x]) {
        if (v == fa) continue;
        dep[v] = dep[x] + 1;
        dfs(v, x);
        sav.emplace_back(has[v], siz[v]);
    }
    sort(sav.begin(), sav.end()); // 子树排序
    for (auto &p : sav) {
        has[x] = (has[x] + 1ll * p.first * Pow[siz[x]] % mod) % mod;
        siz[x] += p.second;
    }
}
```
* **代码解读**：  
  `dfs`函数计算以x为根的哈希值。`sav`存储子树的哈希和大小，排序后合并到当前节点的哈希值中。`Pow`数组预处理质数幂，避免重复计算。  
* 💡 **学习笔记**：子树排序是关键，确保同构树的子树顺序不影响哈希值。  

**题解二：作者ix35（最小表示法）**  
* **亮点**：通过括号序列的最小表示法确保唯一性。  
* **核心代码片段**：  
```cpp
void dfs2(int x, int fa) {
    f[x] = "0";
    vector<string> son;
    for (int v : g[x]) {
        if (v == fa) continue;
        dfs2(v, fa);
        son.push_back(f[v]);
    }
    sort(son.begin(), son.end()); // 子树序列排序
    for (string s : son) f[x] += s;
    f[x] += "1";
}
```
* **代码解读**：  
  `f[x]`表示以x为根的最小括号序列。子树序列排序后合并，确保字典序最小。例如，根节点的序列是`0`+排序后的子树序列+`1`。  
* 💡 **学习笔记**：最小表示法通过排序子树序列，确保同构树的序列相同。  

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观理解树同构的判断过程，我们设计了“像素树探险”动画，用8位复古风格展示重心查找、哈希计算和同构比较。
</visualization_intro>

  * **动画演示主题**：`像素树的结构探险——寻找同构伙伴`  

  * **核心演示内容**：  
    展示如何从无根树中找到重心（红色标记），计算其哈希值（动态生成数字），并与其他树的哈希值比较，确定是否同构。  

  * **设计思路简述**：  
    8位像素风格（如FC游戏画面）降低学习压力；重心查找时用闪烁动画标记候选节点；哈希计算时子树哈希值排序后合并，用像素方块堆叠表示；比较时相同哈希值的树闪烁绿色，不同则红色。  

  * **动画帧步骤与交互关键点**：  

    1.  **场景初始化**：  
        - 屏幕左侧显示输入的无根树（像素节点，边用细线条连接）。  
        - 右侧控制面板：开始/暂停、单步、重置按钮，速度滑块（1x-5x）。  
        - 播放8位风格背景音乐（如《超级玛丽》主题变奏）。  

    2.  **找重心**：  
        - 遍历每个节点，计算其最大子树大小（用数字显示）。  
        - 最小的最大子树对应的节点闪烁红色（重心），双重心时两个节点同时闪烁。  

    3.  **哈希计算**：  
        - 以重心为根，DFS遍历子树。每个子树处理时，其哈希值（数字）从叶节点开始生成，向上合并。  
        - 子树哈希值排序时，用箭头拖动方块调整顺序，伴随“唰”的音效。  
        - 根节点的哈希值最终显示在树顶（如黄色数字）。  

    4.  **同构比较**：  
        - 所有树的哈希值排列在屏幕下方，相同值的树用绿色框圈起。  
        - 点击某棵树，其哈希值与其他树对比，匹配时播放“叮”的成功音效。  

  * **旁白提示**：  
    - “看！这个节点删除后，最大连通块最小，它就是重心！”  
    - “子树的哈希值需要排序后合并，这样同构树的哈希才会相同哦～”  
    - “这两个树的哈希值一样，它们是同构的！”  

<visualization_conclusion>
通过动画，我们可以直观看到重心的作用、哈希的生成过程，以及同构树的判断逻辑，让抽象的算法变得“看得见”。
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
树同构的核心思想（结构哈希/最小表示）可迁移到其他树结构问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - **树的结构比较**：如判断两棵树是否互为镜像（子树顺序相反）。  
    - **动态树问题**：如树的合并、分裂后判断结构是否变化。  
    - **图同构**：推广到一般图，但树是图的特殊情况，结构更简单。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P5043**（本题）：巩固树同构的基础实现。  
    2.  **洛谷 P1306**（斐波那契公约数）：树结构的数学性质应用。  
    3.  **洛谷 P2015**（二叉苹果树）：树的动态规划，需理解子树结构。  

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时遇到哈希冲突的问题，例如：
</insights_intro>

> **参考经验 (来自某题解)**：“最初用简单哈希（如子树哈希相加），发现不同结构的树哈希值相同，后来改用质数乘法并排序子树哈希，冲突问题解决。”  

**点评**：哈希函数的设计是关键！简单哈希易冲突，加入质数乘法和子树排序可大幅降低冲突概率。调试时可通过构造不同结构的树测试哈希函数，确保唯一性。  

---

<conclusion>
通过本指南，我们掌握了树同构的核心方法（哈希/最小表示）、重心的作用，以及代码实现技巧。记住，多动手调试、观察动画，能更快理解算法本质。下一次，我们将挑战更复杂的树问题！💪
</conclusion>

---
处理用时：167.82秒
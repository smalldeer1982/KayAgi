# 题目信息

# [JSOI2015] symmetry

## 题目描述

张老师正在课堂上讲解正方形的对称模式。为了简单起见，他用 $01$ 方阵代表一个正方形图形，即把正方形分解成 $n\times n$ 的方格阵，$0$ 代表一个白色方格，$1$ 代表一个黑色方格。

首先讲到的是容易辨别的轴对称，正方形有 $4$ 个对称轴，分别是水平中线，竖直中线和两条对角线。如果一个正方形图形以某个对称轴做反射变换后保持不变，就称为轴对称图形。例如下面的两个图形都是轴对称图形。

```plain
100  010
100  101
111  000
```

张老师继续讲解正方形的旋转对称。如果一个正方形图形以中心点旋转 $180$ 度后保持不变，就称为 $180$ 度对称图形。如果以中心点顺时针旋转 $90$ 度后保持不变，就称为 $90$ 度对称图形，例如下面的两个图形左边是 $180$ 度对称图形，右边是 $90$ 度对称图形。

```plain
0011  1011
1110  1110
0111  0111
1100  1101
```

张老师接着说，如果一个正方形图形具有两个互相垂直的对称轴，就称为 $4$ 对称图形，如果关于 $4$ 个对称轴全部对称，就称为 $8$ 对称图形。按照定义，$90$ 度对称图形也是 $180$ 度对称图形，$8$ 对称图形也是 $4$ 对称图形。当正方形图形的边长为偶数时，该图形的中心是最中间 $4$ 个方格的公共顶点，当正方形图形的边长为奇数时，该图形有一个中心方格，该图
形的中心也是它的中心方格的中心。边长为 $1$ 的图形显然是 $8$ 对称图形。

张老师给学生证明了两个定理。

- 定理 $1$：一个正方形图形是 $4$ 对称图形当且仅对它是 $180$ 度对称图形和轴对称图形。
- 定理 $2$：一个正方形图形是 $8$ 对称图形当且仅对它是 $90$ 度对称图形和轴对称图形。

最后是练习时间，张老师要求学生寻找在大正方形图形中出现的各种对称图形。请你编程实现这个要求。设输入一个 $01$ 方阵，输出满足 $8$ 对称，$90$ 度对称，$4$ 对称，$180$ 度对称和轴对称的最大子连续方阵的边长。子连续方阵是指选择若干相邻行列的子方阵，代表在大图形中出现的小图形。

## 说明/提示

#### 样例说明

大图形有水平对称轴，左上角有一个 $2\times 2$ 的 $8$ 对称图形，中间 $3$ 行最右 $3$ 列构成 $4$ 对称图形。

---

#### 数据范围

对于 $100\%$ 的数据，$5\leq n\leq 500$。

## 样例 #1

### 输入

```
5
11100
11000
10111
11000
11100```

### 输出

```
2 2 3 3 5```

# AI分析结果



---
# 💡 Kay的C++算法解析：[JSOI2015] symmetry 深入学习指南 💡

<introduction>
今天我们来一起分析“[JSOI2015] symmetry”这道C++编程题。题目要求我们在一个大的01方阵中，找到满足8对称、90度对称、4对称、180度对称和轴对称的最大子正方形。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（二维哈希预处理 + 二分查找优化）`

🗣️ **初步分析**：
解决这道题的关键在于高效判断子正方形是否满足各种对称条件。我们可以把对称问题转化为“原矩阵的子矩阵与变换后的矩阵的对应子矩阵是否相同”。这里用到两个核心技巧：
- **二维哈希预处理**：就像给每个子矩阵发一张“身份证”（哈希值），通过比较哈希值，能快速判断两个子矩阵是否相等，避免逐元素比较的低效。
- **二分查找优化**：因为如果边长为k的子矩阵满足条件，那么所有边长≤k的子矩阵也可能满足（类似“大的满足则小的一定满足”），所以用二分法可以快速找到最大可能的边长，避免暴力枚举所有边长的O(n³)复杂度。

题解的核心思路是：先预处理原矩阵的7种变换（4种轴对称、旋转90度、180度）的哈希矩阵，然后对每种对称类型，用二分法找最大边长。核心难点在于正确预处理所有变换的哈希，以及处理奇数和偶数边长的二分逻辑。

可视化设计上，我们可以用8位像素风格的网格展示原矩阵和7种变换后的矩阵。当判断一个子矩阵是否对称时，用不同颜色高亮原矩阵和对应变换矩阵的子区域，哈希匹配成功时播放“叮”的音效；二分查找过程用进度条动态缩小范围，直观展示“找最大”的过程。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，本题解在思路清晰度、代码规范性、算法有效性等方面表现优异（5星），以下是详细点评：
</eval_intro>

**题解一：来源：阔耐滴小云呀**
* **点评**：此题解思路非常清晰！作者首先想到用二维哈希预处理7种变换后的矩阵，将对称判断转化为哈希值比较，这一步大大降低了时间复杂度。代码结构工整，变量命名（如`h[k][i][j]`表示第k种变换的哈希矩阵）直观易懂。关键函数`check_90`、`check_180`等逻辑明确，直接通过哈希比较实现对称判断。算法上，用二分法分别处理奇数和偶数边长的优化，将复杂度从O(n³)降到O(n² log n)，非常高效。从实践角度看，代码边界处理严谨（如`i - x + 1`的起始坐标计算），可直接用于竞赛场景，是一份高质量的题解。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个核心难点。结合题解的思路，我为大家提炼了关键策略：
</difficulty_intro>

1.  **关键点1**：如何预处理所有对称变换后的矩阵？
    * **分析**：题目涉及4种轴对称（水平/竖直中线、两条对角线）、旋转90度、180度共7种变换。需要为每种变换生成对应的矩阵，并计算其二维哈希。例如，水平轴对称变换需要将原矩阵的列反转（`h[1][i][n-j+1] = h[0][i][j]`），旋转90度需要行列交换并调整坐标（`h[5][j][n-i+1] = h[0][i][j]`）。
    * 💡 **学习笔记**：预处理时要仔细推导每种变换的坐标映射关系，避免坐标错误。

2.  **关键点2**：如何高效判断子矩阵是否对称？
    * **分析**：通过二维哈希，我们可以在O(1)时间内获取任意子矩阵的哈希值。例如，判断是否180度对称，只需比较原矩阵子矩阵的哈希值与旋转180度后的对应子矩阵的哈希值是否相等（`gethash(0,...) == gethash(6,...)`）。
    * 💡 **学习笔记**：哈希的本质是“快速比较”，预处理时要确保所有变换的哈希计算正确。

3.  **关键点3**：如何通过二分法处理奇数和偶数边长？
    * **分析**：奇数和偶数边长的子矩阵中心不同（奇数有中心格，偶数无），需分别二分。例如，奇数边长的最大可能值是`(n-1)/2`，偶数是`n/2`。每次二分时，判断是否存在当前边长的子矩阵满足条件，若存在则尝试更大的边长。
    * 💡 **学习笔记**：二分法的关键是确定“可行区间”和“单调性”，本题中“大的边长可行则小的一定可行”满足单调性。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题转化**：将对称判断转化为哈希值比较，避免逐元素检查。
- **预处理先行**：所有变换的哈希矩阵预处理完成后，后续判断只需O(1)时间。
- **分奇偶处理**：奇数和偶数边长的子矩阵中心不同，需分别二分，避免遗漏。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合题解思路的通用核心C++实现，代码结构清晰，逻辑完整，适合直接学习和参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码来自题解的完整实现，因其逻辑清晰、哈希预处理和二分优化高效，选为代表。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #define rg register
    typedef unsigned long long ull;
    const int _ = 502;
    const ull base1 = 19491001, base2 = 19260817;
    int n; ull pw1[_], pw2[_], h[7][_][_];

    inline ull gethash(int k, int x1, int y1, int x2, int y2) {
        int w = x2 - x1 + 1;
        return h[k][x2][y2] - h[k][x1 - 1][y2] * pw1[w] - h[k][x2][y1 - 1] * pw2[w] + h[k][x1 - 1][y1 - 1] * pw1[w] * pw2[w];
    }

    // 各种对称判断函数（省略具体实现，与题解一致）

    template < class T > inline int solve(T f) {
        int res = 0, l, r, mid;
        // 处理奇数边长
        l = 0, r = (n - 1) >> 1;
        while (l < r) {
            mid = (l + r + 1) >> 1;
            if (check(f, mid << 1 | 1)) l = mid; else r = mid - 1;
        }
        res = (l << 1 | 1);
        // 处理偶数边长
        l = 1, r = n >> 1;
        while (l < r) {
            mid = (l + r + 1) >> 1;
            if (check(f, mid << 1)) l = mid; else r = mid - 1;
        }
        return res > (l << 1) ? res : (l << 1);
    }

    int main() {
        scanf("%d", &n);
        // 预处理原矩阵和7种变换的哈希（与题解一致）
        // 计算基数幂（与题解一致）
        // 计算二维哈希（与题解一致）
        printf("%d %d %d %d %d\n", solve(check_8), solve(check_90), solve(check_4), solve(check_180), solve(check_diag));
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入矩阵，并生成7种变换后的矩阵。通过预处理基数幂`pw1`和`pw2`，计算每个变换矩阵的二维哈希值（类似二维前缀和的方式）。`gethash`函数快速获取子矩阵的哈希值。`solve`函数通过二分法分别处理奇数和偶数边长，调用`check`函数判断是否存在当前边长的子矩阵满足对称条件，最终输出各类型的最大边长。

---
<code_intro_selected>
接下来，我们剖析题解中最能体现核心逻辑的代码片段：
</code_intro_selected>

**题解一：来源：阔耐滴小云呀**
* **亮点**：巧妙利用二维哈希预处理和二分优化，将复杂度从O(n³)降到O(n² log n)，代码结构清晰，变量命名直观。
* **核心代码片段**：
    ```cpp
    // 预处理7种变换的矩阵
    for (rg int i = 1; i <= n; ++i)
        for (rg int j = 1; j <= n; ++j) {
            scanf("%1d", &h[0][i][j]);
            h[1][i][n - j + 1] = h[0][i][j]; // 水平轴对称
            h[2][n - i + 1][j] = h[0][i][j]; // 竖直轴对称
            h[3][j][i] = h[0][i][j]; // 主对角线对称
            h[4][n - j + 1][n - i + 1] = h[0][i][j]; // 副对角线对称
            h[5][j][n - i + 1] = h[0][i][j]; // 旋转90度
            h[6][n - i + 1][n - j + 1] = h[0][i][j]; // 旋转180度
        }
    ```
* **代码解读**：
    这段代码是预处理的核心！`h[0]`存储原矩阵，`h[1]~h[6]`分别对应7种变换后的矩阵。例如，水平轴对称（左右翻转）的坐标是`(i, n-j+1)`，即第j列变为第`n-j+1`列；旋转90度的坐标是`(j, n-i+1)`，即原矩阵的(i,j)变为新矩阵的(j, n-i+1)。这些坐标映射需要仔细推导，确保变换后的矩阵正确。
* 💡 **学习笔记**：预处理变换矩阵时，一定要根据对称/旋转的定义，正确计算每个位置的坐标映射。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解哈希预处理和二分查找的过程，我设计了一个“像素对称实验室”动画，用8位复古风格展示算法运行！
</visualization_intro>

  * **动画演示主题**：`像素对称实验室——寻找最大对称子矩阵`

  * **核心演示内容**：展示原矩阵和7种变换矩阵的生成过程，以及二分查找如何快速找到最大边长的子矩阵。

  * **设计思路简述**：8位像素风格（类似FC游戏）营造轻松氛围，用不同颜色区分原矩阵和变换矩阵；哈希匹配时的“叮”音效强化操作记忆；二分查找的进度条动态缩小范围，让学习者直观看到“找最大”的过程。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为左右两部分：左边是原矩阵（像素方块，0为白色，1为黑色），右边是7个变换矩阵的缩略图（用不同边框颜色区分）。
        - 控制面板有“开始”“单步”“重置”按钮，速度滑块（1-5倍速）。

    2.  **预处理哈希矩阵**：
        - 原矩阵的每个像素方块（i,j）向7个变换矩阵的对应位置（如h[1]的(i, n-j+1)）发射像素光效，伴随“唰”的音效，展示变换过程。
        - 哈希值计算时，每个矩阵的哈希值在底部滚动显示（类似老式计算器数字）。

    3.  **二分查找演示（以8对称为例）**：
        - 初始进度条显示边长范围[1, n]，中间指针指向mid。
        - 点击“单步”，程序扫描所有mid边长的子矩阵：每个子矩阵在原矩阵和旋转90度、轴对称矩阵的对应位置高亮（红色边框），同时比较哈希值。
        - 若找到匹配的子矩阵，进度条左边界移到mid（尝试更大边长），播放“叮”音效；否则右边界移到mid-1，播放“噗”音效。
        - 最终进度条锁定最大边长，该子矩阵用金色边框高亮，播放胜利音效。

    4.  **交互彩蛋**：
        - 鼠标悬停在变换矩阵上，显示变换名称（如“水平轴对称”）。
        - 可手动输入边长，点击“验证”按钮，程序会高亮所有该边长的对称子矩阵。

  * **旁白提示**：
    - “看！原矩阵的(i,j)像素变换到水平轴对称矩阵的(i, n-j+1)位置啦～”
    - “现在在检查边长为mid的子矩阵是否8对称，红色边框的是正在比较的区域哦！”
    - “找到啦！这个子矩阵的哈希值和旋转90度、轴对称后的哈希值完全一样，所以它是8对称的！”

<visualization_conclusion>
通过这个动画，我们不仅能“看”到哈希预处理如何快速生成变换矩阵，还能直观理解二分查找如何高效缩小边长范围。像素风格和音效让学习过程更有趣！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心思想（哈希预处理+二分查找）可以迁移到许多对称或子矩阵问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 二维哈希可用于快速比较任意子矩阵，适用于判断回文子矩阵、最大全1子矩阵等问题。
      - 二分查找适用于“找最大/最小满足条件的值”的场景，如最大正方形面积、最小覆盖半径等。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1365** - `WJMZBMR打osu! / Easy`  
        * 🗣️ **推荐理由**：练习二维哈希的基础应用，判断回文子串/子矩阵的变形问题。
    2.  **洛谷 P1044** - `栈`  
        * 🗣️ **推荐理由**：虽然不直接涉及哈希，但二分法的思想（找最大/最小）在此类组合问题中同样重要。
    3.  **洛谷 P2213** - `[USACO14MAR]Watering the Fields S`  
        * 🗣️ **推荐理由**：练习二分答案的思路，与本题的二分查找逻辑类似。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。
</insights_intro>

---

<conclusion>
本次关于“[JSOI2015] symmetry”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握二维哈希和二分查找的技巧，理解对称问题的处理思路。记住，多动手调试、观察哈希值的变化，能更快掌握这类问题！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：160.17秒
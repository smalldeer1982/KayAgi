# 题目信息

# 可重集

## 题目描述

给出一个长度为 $n$ 的非负整数序列 $a_1,a_2,a_3,\ldots, a_n$，给出 $q$ 次操作，每次先给出一个参数 $op$：

- $op=0$，接下来给出 $2$ 个参数 $x,y$，把 $a_x$ 修改为 $y$。

- $op=1$，接下来给出 $4$ 个参数 $ l_1,r_1,l_2,r_2$（保证 $r_1-l_1=r_2-l_2$），你需要判断区间 $[l_1,r_1]$ 与区间 $[l_2,r_2]$ 是否本质相同，如果本质相同输出 `YES`，否则输出 `NO`。

本质相同的定义：令区间长度为 $\text{len}$ ，序列 $p_{1}\dots p_{\text{len}}$ 为 $a_{l_1}\dots a_{r_1}$ 升序排序后的结果，序列 $q_{1}\dots q_\text{len}$ 为 $a_{l_2}\dots a_{r_2}$ 升序排序后的结果，存在一个整数 $k$ 使得满足 $\forall i,p_i+k=q_i$。

## 说明/提示



- Subtask1 （$25$ pts）：$1\leq n,q \leq 1000$。

- Subtask2 （$25$ pts）：$1\leq n,q \leq 10^5$，$0\leq a_i,y\leq 100$。

- Subtask3 （$25$ pts）：$1\leq n,q \leq 10^5$。

- Subtask4 （$25$ pts）：无特殊限制。

你只有通过 subtask 中的所有测试点才能获得该 subtask 的分数。

对于所有数据满足：$1\leq n,q \leq 10^6$，$1\leq x \leq n$，$0\leq a_i,y \leq  10^6$ 。且对于所有 $l,r$ 有 $1\leq l\leq r\leq n$。



## 样例 #1

### 输入

```
12 6
1 1 4 5 1 4 2 2 5 2 3 3
1 1 3 7 9
1 2 3 5 6
1 1 3 2 4
0 7 1
1 1 4 2 5
1 5 7 8 10```

### 输出

```
YES
YES
NO
YES
YES```

# AI分析结果



---
# 💡 Kay的C++算法解析：可重集 深入学习指南 💡

<introduction>
今天我们来一起分析“可重集”这道C++编程题。这道题的核心是判断两个区间是否可以通过平移一个固定值k变得完全相同，同时支持单点修改。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`哈希与数据结构应用（编程技巧应用）`

🗣️ **初步分析**：
解决“可重集”问题，关键在于设计一个高效的哈希方法，结合线段树或树状数组等数据结构，快速判断两个区间的元素分布是否可以通过平移得到。哈希的核心思想是将元素的出现次数或分布特征转换为一个唯一的数值（哈希值），使得平移后的区间哈希值可以通过简单的数学操作（如乘以基数的k次方）得到。

在本题中，哈希的应用场景是：对于区间A和区间B，若存在k使得A的每个元素加k后等于B的对应元素（排序后），则它们的哈希值应满足 `hash(A) * base^k = hash(B)`（或反向）。核心难点在于如何设计哈希函数，使得平移后的哈希值可以快速计算，同时避免哈希冲突。

常见的哈希设计包括：
- **指数哈希**：取一个大质数base，哈希值为区间内所有元素的base的幂次和（如`sum(base^a_i)`）。平移k后，哈希值变为`sum(base^(a_i + k)) = sum(base^a_i) * base^k`，符合要求。
- **三角函数哈希**：利用sin和cos的和差角公式（如`sum(sin(a_i - min))`），平移k后可通过公式转换判断是否相等。

可视化设计思路：采用8位像素风格的线段树动画，每个节点用像素方块表示，显示当前区间的哈希值和最小值。修改操作时，对应叶子节点的哈希值和最小值更新，并逐层向上合并。查询时，高亮左右子区间的哈希值和最小值，最终比较两个区间的哈希值是否满足平移关系。关键步骤（如哈希值计算、k的推导）用闪烁或颜色变化强调，配合“叮”的音效提示操作完成。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑清晰、实现高效且具有启发性被选为优质题解：
</eval_intro>

**题解一：作者Piwry（赞：8）**
* **点评**：此题解采用指数哈希+线段树的方法，思路简洁高效。通过维护区间哈希值（`sum(base^a_i)`）和最小值，利用哈希值的平移特性（`hash(A)*base^k = hash(B)`）快速判断本质相同。代码中线段树的构建和查询逻辑规范，变量名（如`mn`表示最小值，`sum`表示哈希和）含义明确，边界处理严谨（如预处理`base`的幂次）。亮点在于哈希函数的巧妙设计，直接解决了平移k的判断问题，实践价值高（可直接用于大数据量场景）。

**题解二：作者ADay（赞：4）**
* **点评**：此题解使用随机基数的指数哈希，并结合zkw线段树优化常数。通过维护区间哈希和最大值，利用`hash(A)*base^k = hash(B)`的特性判断。zkw线段树的实现（如位运算优化）显著降低了常数，适合处理1e6级别的数据。亮点在于随机基数的选择（降低冲突概率）和zkw线段树的高效实现，对竞赛中的时间优化有重要参考价值。

**题解三：作者Varuxn（赞：3）**
* **点评**：此题解采用双哈希（模数哈希+长双精度浮点哈希）进一步降低冲突概率，线段树维护哈希值和最小值。代码中对哈希运算的封装（如`operator+`、`operator*`）提高了可读性，预处理`base`的幂次避免了重复计算。亮点在于双哈希的设计，增强了算法的鲁棒性，适合对正确性要求较高的场景。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的过程中，我们需要突破以下核心难点：
</difficulty_intro>

1.  **关键点1：如何设计哈希函数，使平移k后的哈希值可快速计算？**
    * **分析**：哈希函数需满足`hash(A + k) = hash(A) * f(k)`，其中`f(k)`是可快速计算的函数。指数哈希（`base^a_i`）满足此条件，因为`base^(a_i + k) = base^a_i * base^k`，即`hash(A + k) = hash(A) * base^k`。选择大质数或原根作为`base`可降低冲突概率。
    * 💡 **学习笔记**：指数哈希是处理平移问题的“利器”，其乘法性质天然支持平移操作的快速计算。

2.  **关键点2：如何高效维护区间哈希值和最小值？**
    * **分析**：线段树或zkw线段树是高效的数据结构选择。线段树每个节点存储区间的哈希和（`sum(base^a_i)`）和最小值（用于计算k）。单点修改时，更新叶子节点并向上合并；区间查询时，合并左右子区间的哈希和和最小值。zkw线段树通过位运算优化，进一步降低常数，适合大数据量场景。
    * 💡 **学习笔记**：线段树是处理区间查询和单点修改的通用工具，选择zkw线段树可优化常数，提升效率。

3.  **关键点3：如何避免哈希冲突？**
    * **分析**：哈希冲突可能导致错误判断。解决方案包括：选择大质数模数（如1e9+7）、使用双哈希（维护两个不同基数的哈希值）、选择原根作为基数（如3、998244353的原根）。
    * 💡 **学习笔记**：双哈希是降低冲突概率的有效手段，竞赛中常用。

### ✨ 解题技巧总结
- **哈希函数设计**：选择大质数或原根作为基数，利用指数哈希的乘法性质处理平移。
- **数据结构选择**：线段树（或zkw线段树）高效维护区间哈希和最小值。
- **冲突预防**：双哈希、大模数、原根基数，多管齐下降低冲突概率。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合多个优质题解的通用核心实现，采用指数哈希+线段树，兼顾清晰性和效率。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Piwry和ADay的思路，使用线段树维护区间哈希和最小值，适用于大数据量场景。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <algorithm>
    using namespace std;

    typedef long long ll;
    const int MAXN = 1e6 + 5;
    const int MOD = 1e9 + 7;
    const int BASE = 998244353; // 原根，降低冲突概率

    int n, q;
    int a[MAXN];
    ll pow_base[MAXN]; // 预处理BASE的幂次

    struct SegmentTree {
        int min_val[MAXN << 2];
        ll hash_sum[MAXN << 2];

        void push_up(int rt) {
            min_val[rt] = min(min_val[rt << 1], min_val[rt << 1 | 1]);
            hash_sum[rt] = (hash_sum[rt << 1] + hash_sum[rt << 1 | 1]) % MOD;
        }

        void build(int rt, int l, int r) {
            if (l == r) {
                min_val[rt] = a[l];
                hash_sum[rt] = pow_base[a[l]];
                return;
            }
            int mid = (l + r) >> 1;
            build(rt << 1, l, mid);
            build(rt << 1 | 1, mid + 1, r);
            push_up(rt);
        }

        void update(int rt, int l, int r, int pos, int val) {
            if (l == r) {
                min_val[rt] = val;
                hash_sum[rt] = pow_base[val];
                return;
            }
            int mid = (l + r) >> 1;
            if (pos <= mid) update(rt << 1, l, mid, pos, val);
            else update(rt << 1 | 1, mid + 1, r, pos, val);
            push_up(rt);
        }

        pair<int, ll> query(int rt, int l, int r, int ql, int qr) {
            if (ql <= l && r <= qr) {
                return {min_val[rt], hash_sum[rt]};
            }
            int mid = (l + r) >> 1;
            pair<int, ll> left = {1e9, 0}, right = {1e9, 0};
            if (ql <= mid) left = query(rt << 1, l, mid, ql, qr);
            if (qr > mid) right = query(rt << 1 | 1, mid + 1, r, ql, qr);
            return {min(left.first, right.first), (left.second + right.second) % MOD};
        }
    } st;

    int main() {
        scanf("%d%d", &n, &q);
        for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
        // 预处理BASE的幂次
        pow_base[0] = 1;
        for (int i = 1; i < MAXN; ++i) {
            pow_base[i] = pow_base[i - 1] * BASE % MOD;
        }
        st.build(1, 1, n);

        while (q--) {
            int op;
            scanf("%d", &op);
            if (op == 0) {
                int x, y;
                scanf("%d%d", &x, &y);
                st.update(1, 1, n, x, y);
            } else {
                int l1, r1, l2, r2;
                scanf("%d%d%d%d", &l1, &r1, &l2, &r2);
                auto [min1, sum1] = st.query(1, 1, n, l1, r1);
                auto [min2, sum2] = st.query(1, 1, n, l2, r2);
                // 计算k
                if (min1 > min2) {
                    swap(min1, min2);
                    swap(sum1, sum2);
                }
                ll k = min2 - min1;
                ll target = sum1 * pow_base[k] % MOD;
                if (target == sum2) {
                    puts("YES");
                } else {
                    puts("NO");
                }
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：代码通过线段树维护每个区间的最小值（用于计算k）和哈希和（`sum(BASE^a_i)`）。预处理`BASE`的幂次避免重复计算。单点修改时，更新对应叶子节点并向上合并；区间查询时，获取区间的最小值和哈希和，通过比较`sum1 * BASE^k`与`sum2`判断是否本质相同。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者Piwry（来源：综合题解内容）**
* **亮点**：线段树维护哈希和最小值，预处理`base`的幂次，代码简洁高效。
* **核心代码片段**：
    ```cpp
    pad query(int l, int r, int x =1, int nl =1, int nr =N){
        if(l == nl && r == nr) return pad(mn[x], sum[x]);
        int mid =(nl+nr)>>1;
        if(r <= mid) return query(l, r, x<<1, nl, mid);
        else if(l >= mid+1) return query(l, r, (x<<1)|1, mid+1, nr);
        else{
            pad ret1 =query(l, mid, x<<1, nl, mid),
                ret2 =query(mid+1, r, (x<<1)|1, mid+1, nr);
            (ret1.second +=ret2.second) %=M;
            ret1.first =min(ret1.first, ret2.first);
            return ret1;
        }
    }
    ```
* **代码解读**：此片段是线段树的区间查询函数，返回区间的最小值（`mn`）和哈希和（`sum`）。通过递归合并左右子区间的结果，确保查询的时间复杂度为O(log n)。`pad`结构体存储最小值和哈希和，方便返回。
* 💡 **学习笔记**：线段树的查询函数需递归合并子区间信息，设计合适的返回类型（如结构体）可简化逻辑。

**题解二：作者ADay（来源：综合题解内容）**
* **亮点**：zkw线段树优化常数，随机基数降低冲突概率。
* **核心代码片段**：
    ```cpp
    il node ask(int s,int t){
        node res=(node){0,-inf};
        for(s=m+s-1,t=m+t+1;s^t^1;s>>=1,t>>=1){
            if(~s&1)res=res+a[s^1];
            if(t&1)res=res+a[t^1];
        }
        return res;
    }
    ```
* **代码解读**：zkw线段树的查询函数，通过位运算快速定位区间边界，避免递归调用，显著降低常数。`s`和`t`初始化为叶子节点的左右边界，通过循环向上合并，时间复杂度O(log n)。
* 💡 **学习笔记**：zkw线段树适合对时间要求严格的场景，位运算优化是关键。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解线段树如何维护哈希和最小值，以及如何判断两个区间是否本质相同，我们设计了一个“像素线段树探险”的8位复古动画方案。
</visualization_intro>

  * **动画演示主题**：`像素线段树探险——寻找可重集的秘密`

  * **核心演示内容**：线段树的构建、单点修改、区间查询过程，重点展示哈希值和最小值的更新，以及如何通过比较哈希值判断本质相同。

  * **设计思路简述**：采用FC红白机风格，用像素方块表示线段树节点（绿色表示叶子节点，蓝色表示内部节点）。每个节点显示当前区间的最小值（顶部）和哈希值（底部）。操作时，通过颜色变化（如红色闪烁）和音效（“叮”声）强调关键步骤，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧显示原始数组（像素方块，数值标在方块上），右侧显示线段树结构（层状排列的像素方块）。
          * 控制面板包含“单步”“自动”“重置”按钮和速度滑块。
          * 8位风格BGM（如《超级玛丽》经典旋律）轻量播放。

    2.  **线段树构建**：
          * 叶子节点（对应数组元素）逐个亮起（绿色渐变），显示初始值和哈希值（`BASE^a_i`）。
          * 内部节点从下到上合并（蓝色渐变），显示子节点的最小值和哈希和（如父节点显示`min(left.min, right.min)`和`(left.sum + right.sum) % MOD`）。

    3.  **单点修改**：
          * 输入修改位置和值，对应叶子节点变为黄色（选中状态），数值和哈希值更新（如原`a[3]=5`改为`a[3]=7`，哈希值从`BASE^5`变为`BASE^7`）。
          * 从叶子节点到根节点的路径上，每个父节点依次更新（蓝色闪烁），重新计算最小值和哈希和。

    4.  **区间查询**：
          * 输入查询区间，对应线段树节点变为紫色（选中状态）。
          * 递归查询左右子区间，合并最小值和哈希和（如左子区间最小值3，哈希和100；右子区间最小值5，哈希和200，父节点显示最小值3，哈希和300）。
          * 最终返回两个区间的最小值和哈希和，计算k并比较哈希值（如`sum1 * BASE^k`与`sum2`是否相等），相等时播放“胜利”音效（如《魂斗罗》通关音），否则播放“错误”音效（短促“叮”声）。

  * **旁白提示**：
      * （构建时）“看！线段树的叶子节点对应数组元素，每个节点存储了当前区间的最小值和哈希值～”
      * （修改时）“修改位置的叶子节点更新后，它的所有父节点都会重新计算，确保信息准确！”
      * （查询时）“两个区间的最小值差就是k，哈希值乘以BASE的k次方后相等，说明它们可以平移得到哦～”

<visualization_conclusion>
通过这个像素动画，我们可以直观看到线段树的工作流程，理解哈希值和最小值如何维护，以及本质相同的判断逻辑。复古风格和音效让学习过程更有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解了本题的哈希+线段树解法后，我们可以将思路迁移到更多区间特征判断的问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 指数哈希可用于判断区间是否可通过加减、乘除等操作转换（如判断两数组是否为同一排列的倍数）。
      * 线段树/zkw线段树可高效维护区间特征（如和、积、哈希值），支持快速修改和查询。
      * 双哈希/多哈希可降低冲突概率，适用于对正确性要求高的场景。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3792** - `由乃与大母神原型和偶像崇拜`
          * 🗣️ **推荐理由**：本题同样需要判断区间是否可通过操作转换，哈希+线段树的思路可直接应用，适合巩固哈希设计能力。
    2.  **洛谷 P5025** - `[SNOI2017]炸弹`
          * 🗣️ **推荐理由**：涉及区间合并和特征维护，线段树的应用场景与本题类似，可提升数据结构灵活运用能力。
    3.  **洛谷 P4314** - `CPU监控`
          * 🗣️ **推荐理由**：需要维护区间最大值、历史最大值等多特征，与本题维护最小值和哈希值的思路类似，适合拓展线段树的复杂应用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试和优化的经验，这些对我们很有启发：
</insights_intro>

> **参考经验 (来自作者a___)**：“我第一次交代码时忘了`pushup`，结果每个subtask都WA了一个点。这让我意识到线段树的合并操作必须仔细检查，任何小错误都会导致全局错误。”
>
> **点评**：线段树的`pushup`函数是合并子节点信息的关键，调试时可通过打印中间节点的值快速定位问题。遇到WA时，优先检查数据结构的更新逻辑，尤其是合并操作。

-----

<conclusion>
本次关于“可重集”的C++解题分析就到这里。希望这份指南能帮助你掌握哈希+线段树的核心思路，理解如何设计高效的特征函数，并通过可视化动画直观感受算法过程。记住，多思考、多练习，你会越来越熟练！下次挑战新题见～💪
</conclusion>

---
处理用时：197.10秒
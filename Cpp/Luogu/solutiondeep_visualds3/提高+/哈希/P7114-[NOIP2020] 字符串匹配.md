# 题目信息

# [NOIP2020] 字符串匹配

## 题目描述

小 C 学习完了字符串匹配的相关内容，现在他正在做一道习题。

对于一个字符串 $S$，题目要求他找到 $S$ 的所有具有下列形式的拆分方案数：

$S = ABC$，$S = ABABC$，$S = ABAB \ldots ABC$，其中 $A$，$B$，$C$ 均是非空字符串，且 $A$ 中出现奇数次的字符数量不超过 $C$ 中出现奇数次的字符数量。

更具体地，我们可以定义 $AB$ 表示两个字符串 $A$，$B$ 相连接，例如 $A = \texttt{aab}$，$B = \texttt{ab}$，则 $AB = \texttt{aabab}$。

并递归地定义 $A^1=A$，$A^n = A^{n - 1} A$（$n \ge 2$ 且为正整数）。例如 $A = \texttt{abb}$，则 $A^3=\texttt{abbabbabb}$。

则小 C 的习题是求 $S = {(AB)}^iC$ 的方案数，其中 $F(A) \le F(C)$，$F(S)$ 表示字符串 $S$ 中出现奇数次的字符的数量。两种方案不同当且仅当拆分出的 $A$、$B$、$C$ 中有至少一个字符串不同。

小 C 并不会做这道题，只好向你求助，请你帮帮他。

## 说明/提示

**【样例 #1 解释】**

对于第一组数据，所有的方案为

1. $A=\texttt{n}$，$B=\texttt{nr}$，$C=\texttt{nnr}$。
2. $A=\texttt{n}$，$B=\texttt{nrn}$，$C=\texttt{nr}$。
3. $A=\texttt{n}$，$B=\texttt{nrnn}$，$C=\texttt{r}$。
4. $A=\texttt{nn}$，$B=\texttt{r}$，$C=\texttt{nnr}$。
5. $A=\texttt{nn}$，$B=\texttt{rn}$，$C=\texttt{nr}$。
6. $A=\texttt{nn}$，$B=\texttt{rnn}$，$C=\texttt{r}$。
7. $A=\texttt{nnr}$，$B=\texttt{n}$，$C=\texttt{nr}$。
8. $A=\texttt{nnr}$，$B=\texttt{nn}$，$C=\texttt{r}$。

**【数据范围】**

| 测试点编号 | $\lvert S \rvert \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 4$ | $10$ | 无 |
| $5 \sim 8$ | $100$ | 无 |
| $9 \sim 12$ | $1000$ | 无 |
| $13 \sim 14$ | $2^{15}$ | $S$ 中只包含一种字符 |
| $15 \sim 17$ | $2^{16}$ | $S$ 中只包含两种字符 |
| $18 \sim 21$ | $2^{17}$ | 无 |
| $22 \sim 25$ | $2^{20}$ | 无 |

对于所有测试点，保证 $1 \le T \le 5$，$1 \le |S| \le 2^{20}$。 

## 样例 #1

### 输入

```
3
nnrnnr
zzzaab
mmlmmlo
```

### 输出

```
8
9
16
```

## 样例 #2

### 输入

```
5
kkkkkkkkkkkkkkkkkkkk
lllllllllllllrrlllrr
cccccccccccccxcxxxcc
ccccccccccccccaababa
ggggggggggggggbaabab
```

### 输出

```
156
138
138
147
194
```

## 样例 #3

### 输入

```
见附件中的 string/string3.in```

### 输出

```
见附件中的 string/string3.ans```

## 样例 #4

### 输入

```
见附件中的 string/string4.in```

### 输出

```
见附件中的 string/string4.ans```

# AI分析结果



---

# 💡 Kay的C++算法解析：字符串匹配 深入学习指南 💡

<introduction>
今天我们来一起分析NOIP2020的“字符串匹配”这道题。这道题需要计算字符串S可以拆分为$(AB)^iC$的方案数，其中A、B、C非空，且A中出现奇数次的字符数不超过C中的。本指南将帮助你梳理核心思路、关键算法，并通过生动的像素动画和代码赏析，快速掌握解题技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：字符串循环节判断（扩展KMP/哈希）与奇数字符统计（前缀和+树状数组）

🗣️ **初步分析**：
解决这道题的关键在于两个核心步骤：  
1. **循环节判断**：确定字符串S的前缀是否能由某个子串$(AB)$重复多次构成。例如，若$AB$的长度为$i$，我们需要知道它最多能重复多少次（即最大的$k$使得$(AB)^k$是S的前缀）。  
2. **奇数字符统计**：动态维护A和C中出现奇数次的字符数量，判断是否满足$F(A) \leq F(C)$。  

这里，我们可以用**扩展KMP（Z算法）**快速计算每个位置的最长公共前缀（Z数组），从而判断循环节次数。同时，用**树状数组**维护前缀中奇数字符数的出现次数，高效统计满足条件的A的数量。

例如，Z数组的每个元素$Z[i]$表示从位置$i$开始的后缀与原串的最长公共前缀长度。通过$Z[i]$，我们可以快速确定以$i$为循环节长度时，最多能重复多少次（即$\lfloor Z[i]/i \rfloor +1$）。

**可视化设计思路**：  
设计一个8位像素风格的动画，用不同颜色的像素块表示字符串中的字符。动画中，Z数组的计算过程会以“滑动窗口”形式展示，循环节的重复次数通过像素块的复制动画体现。奇数字符数的变化用数字计数器实时更新，关键步骤（如循环节匹配成功）伴随“叮”的音效，帮助学习者直观理解算法流程。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑清晰、优化到位且实践价值高，被选为优质参考：
</eval_intro>

### 题解一：泥土笨笨（赞：167）
* **点评**：此题解详细讲解了扩展KMP的应用，结合树状数组维护奇数字符数的前缀和。代码注释丰富，逻辑严谨，尤其在处理循环节次数和奇偶分类时，通过预处理Z数组和动态维护后缀奇数字符数，将复杂度优化到$O(n \log26)$，是高效且易懂的正解。

### 题解二：George1123（赞：23）
* **点评**：此题解提出了$\Theta(n)$的优化思路，利用Z数组快速计算循环次数，并通过树状数组维护前缀奇数字符数。代码简洁，关键步骤（如Z数组计算、奇数字符数更新）处理巧妙，适合理解线性复杂度的实现。

### 题解三：Calculatelove（赞：7）
* **点评**：此题解结合哈希和前缀和，枚举循环节长度并判断重复次数，同时用树状数组统计满足条件的A的数量。代码结构清晰，适合理解基础思路到优化的过渡。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们需要突破以下核心难点，掌握关键策略：
</difficulty_intro>

### 1. 关键点1：如何高效判断循环节次数？
**分析**：循环节的判断是本题的基础。通过扩展KMP计算Z数组，$Z[i]$表示从位置$i$开始的后缀与原串的最长公共前缀长度。若循环节长度为$i$，则最多重复次数为$\lfloor Z[i]/i \rfloor +1$（需保证$C$非空）。  
**学习笔记**：Z数组是判断循环节的“神器”，能快速确定子串的最大重复次数。

### 2. 关键点2：如何动态维护奇数字符数？
**分析**：奇数字符数的动态维护需分别处理前缀和后缀。前缀奇数字符数可以通过遍历字符串实时更新，后缀奇数字符数则通过反向遍历预处理。树状数组（或桶）用于统计前缀中奇数字符数的出现次数，快速查询满足$F(A) \leq F(C)$的A的数量。  
**学习笔记**：树状数组适合维护动态的前缀和查询，尤其当值域较小时（本题值域为0~26），效率极高。

### 3. 关键点3：如何处理奇偶循环次数对C的影响？
**分析**：当循环次数$k$为奇数时，$C$的奇数字符数等于后缀$AB$后的剩余部分；当$k$为偶数时，$C$的奇数字符数等于整个字符串的奇数字符数（因$AB$重复两次后奇数字符数为0）。需分别统计这两种情况的贡献。  
**学习笔记**：奇偶分类是减少计算量的关键，利用重复两次不改变奇数字符数的性质，将问题简化为两种情况。

### ✨ 解题技巧总结
- **预处理先行**：先计算Z数组、前缀/后缀奇数字符数，为后续枚举循环节和统计A的数量做准备。  
- **动态维护树状数组**：在枚举循环节长度时，逐步将前缀的奇数字符数加入树状数组，实时查询满足条件的A的数量。  
- **奇偶分类处理**：根据循环次数的奇偶性，分别计算两种情况下的贡献，避免重复计算。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心代码，结合扩展KMP和树状数组，高效解决问题。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：此代码综合了泥土笨笨和George1123的思路，使用扩展KMP计算Z数组，树状数组维护奇数字符数的前缀和，复杂度为$O(n \log26)$。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int MAXN = (1 << 20) + 5;
char s[MAXN];
int n, z[MAXN];
int before[30], after[30];
int pre, suf, all;
int c[30]; // 树状数组，维护奇数字符数的前缀和

inline int lbt(int x) { return x & -x; }
void update(int x) {
    while (x <= 27) { c[x]++; x += lbt(x); }
}
int sum(int x) {
    int r = 0;
    while (x > 0) { r += c[x]; x -= lbt(x); }
    return r;
}

void Z() {
    z[0] = n;
    int now = 0;
    while (now + 1 < n && s[now] == s[now + 1]) now++;
    z[1] = now;
    int p0 = 1;
    for (int i = 2; i < n; ++i) {
        if (i + z[i - p0] < p0 + z[p0]) z[i] = z[i - p0];
        else {
            now = p0 + z[p0] - i;
            now = max(now, 0);
            while (now + i < n && s[now] == s[now + i]) now++;
            z[i] = now;
            p0 = i;
        }
    }
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        cin >> s;
        n = strlen(s);
        memset(before, 0, sizeof(before));
        memset(after, 0, sizeof(after));
        memset(c, 0, sizeof(c));
        all = pre = suf = 0;
        Z();
        for (int i = 0; i < n; ++i) if (i + z[i] == n) z[i]--; // 保证C非空
        for (int i = 0; i < n; ++i) after[s[i] - 'a']++;
        for (int i = 0; i < 26; ++i) if (after[i] & 1) all++;
        suf = all;
        long long ans = 0;
        for (int i = 0; i < n; ++i) {
            // 维护后缀奇数字符数suf
            if (after[s[i] - 'a'] & 1) suf--;
            else suf++;
            after[s[i] - 'a']--;
            // 维护前缀奇数字符数pre
            if (before[s[i] - 'a'] & 1) pre--;
            else pre++;
            before[s[i] - 'a']++;
            if (i != 0 && i != n - 1) {
                int t = z[i + 1] / (i + 1) + 1;
                ans += 1LL * (t / 2) * sum(all + 1) + 1LL * (t - t / 2) * sum(suf + 1);
            }
            update(pre + 1); // 树状数组记录前缀奇数字符数
        }
        cout << ans << endl;
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **Z数组计算**：使用扩展KMP算法预处理每个位置的最长公共前缀长度。  
  2. **奇数字符数维护**：通过`before`和`after`数组分别维护前缀和后缀的奇数字符数，实时更新`pre`和`suf`。  
  3. **树状数组统计**：`c`数组作为树状数组，记录前缀中奇数字符数的出现次数，快速查询满足条件的A的数量。  
  4. **循环节次数计算**：通过Z数组确定循环节的最大重复次数`t`，并根据奇偶性分别累加贡献。

---

<code_intro_selected>
以下是对优质题解核心代码片段的赏析：
</code_intro_selected>

### 题解一：泥土笨笨（扩展KMP+树状数组）
* **亮点**：Z数组计算与树状数组结合，动态维护奇数字符数，复杂度优化到$O(n \log26)$。
* **核心代码片段**：
```cpp
void Z() {
    z[0] = n;
    int now = 0;
    while (now + 1 < n && s[now] == s[now + 1]) now++;
    z[1] = now;
    int p0 = 1;
    for (int i = 2; i < n; ++i) {
        if (i + z[i - p0] < p0 + z[p0]) z[i] = z[i - p0];
        else {
            now = p0 + z[p0] - i;
            now = max(now, 0);
            while (now + i < n && s[now] == s[now + i]) now++;
            z[i] = now;
            p0 = i;
        }
    }
}
```
* **代码解读**：  
  Z数组的计算通过扩展KMP算法完成。`z[i]`表示从位置`i`开始的后缀与原串的最长公共前缀长度。初始时`z[0]`为字符串长度，`z[1]`通过暴力匹配得到。后续利用已计算的`z`值（如`z[i-p0]`）减少重复计算，时间复杂度为$O(n)$。  
* 💡 **学习笔记**：扩展KMP算法通过维护当前最右的匹配区间`[p0, p0+z[p0]]`，避免重复比较，是高效计算最长公共前缀的关键。

### 题解二：George1123（线性复杂度实现）
* **亮点**：利用Z数组和树状数组的线性维护，将复杂度优化到$O(n)$。
* **核心代码片段**：
```cpp
int main() {
    // ...（预处理）
    for (int i = 0; i < n; ++i) {
        // 维护后缀奇数字符数suf
        if (after[s[i] - 'a'] & 1) suf--;
        else suf++;
        after[s[i] - 'a']--;
        // 维护前缀奇数字符数pre
        if (before[s[i] - 'a'] & 1) pre--;
        else pre++;
        before[s[i] - 'a']++;
        // 计算贡献
        if (i != 0 && i != n - 1) {
            int t = z[i + 1] / (i + 1) + 1;
            ans += 1LL * (t / 2) * sum(all + 1) + 1LL * (t - t / 2) * sum(suf + 1);
        }
        update(pre + 1);
    }
}
```
* **代码解读**：  
  遍历字符串时，动态维护前缀和后缀的奇数字符数（`pre`和`suf`），并通过树状数组`c`记录前缀奇数字符数的出现次数。每次枚举循环节长度`i+1`时，利用Z数组计算最大重复次数`t`，根据奇偶性累加贡献。  
* 💡 **学习笔记**：动态维护奇数字符数和树状数组的结合，使得每次查询满足条件的A的数量只需$O(\log26)$时间，整体复杂度线性。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为了更直观地理解扩展KMP和奇数字符统计的过程，我们设计了一个8位像素风格的动画，模拟算法执行流程。
</visualization_intro>

### 动画演示主题：像素循环节探险家
* **核心演示内容**：展示字符串S的循环节判断（Z数组计算）、奇数字符数变化（前缀/后缀）、以及树状数组统计过程。

### 设计思路简述：
采用FC红白机风格的像素画面，用不同颜色表示字符（如红色'A'、蓝色'B'）。循环节的匹配通过像素块的复制动画体现（如AB重复时，像素块从左到右依次复制）。奇数字符数用顶部的数字计数器实时更新，树状数组的更新通过柱状图动态增长。关键步骤（如循环节匹配成功、奇数字符数变化）伴随“叮”的音效，增强交互感。

### 动画帧步骤与交互关键点：
1. **初始化场景**：  
   - 屏幕左侧显示字符串S的像素块（每个字符为一个小方块），右侧显示Z数组、奇数字符数计数器和树状数组柱状图。  
   - 控制面板包含“单步执行”“自动播放”“调速”按钮。

2. **Z数组计算**：  
   - 用绿色框标注当前处理的位置`i`，蓝色框标注匹配的前缀，逐步扩展匹配长度，显示`z[i]`的计算过程。

3. **循环节判断**：  
   - 当确定循环节长度为`i`时，用黄色框标注`AB`的位置，红色框标注重复的`AB`块，动画展示最多能重复多少次（如`t`次）。

4. **奇数字符数维护**：  
   - 前缀奇数字符数`pre`用左侧计数器显示，后缀奇数字符数`suf`用右侧计数器显示。每次字符移动时，计数器数字动态变化（如奇数次时加1，偶数次时减1）。

5. **树状数组更新**：  
   - 树状数组的柱状图实时更新，每次`update(pre+1)`时，对应高度的柱子增长，直观展示奇数字符数的分布。

6. **贡献计算**：  
   - 当计算奇偶循环次数的贡献时，用不同颜色的箭头标注奇数和偶数情况的累加，数值显示在屏幕顶部的总答案中。

<visualization_conclusion>
通过这个像素动画，我们可以清晰看到扩展KMP如何快速判断循环节，奇数字符数如何动态变化，以及树状数组如何高效统计满足条件的A的数量，从而深入理解算法的核心逻辑。
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以通过以下练习巩固字符串循环节和奇数字符统计的应用：
</similar_problems_intro>

### 通用思路/技巧迁移：
本题的核心技巧（扩展KMP判断循环节、树状数组统计奇数字符数）适用于以下场景：  
- 字符串最小周期判断（如洛谷P3538）。  
- 统计满足特定奇偶条件的子串数（如统计奇数字符数为偶数的子串）。  
- 多模式串匹配中的循环节应用（如AC自动机结合循环节）。

### 练习推荐（洛谷）：
1. **洛谷 P5410 【模板】扩展 KMP（Z 函数）**  
   * 推荐理由：本题是扩展KMP的模板题，掌握Z数组的计算是解决本题的基础。  
2. **洛谷 P3538 [POI2014]HOT-Hotels**  
   * 推荐理由：涉及字符串最小周期判断，与本题的循环节思想类似。  
3. **洛谷 P1358 扑克牌**  
   * 推荐理由：需要统计奇数字符数，与本题的奇数字符统计技巧相关。  

---

## 7. 学习心得与经验分享

<insights_intro>
部分题解作者分享了调试过程中的经验，对我们有重要参考价值：
</insights_intro>

> **参考经验（来自泥土笨笨）**：“在计算Z数组时，需要注意边界条件，例如当`i + z[i] == n`时，需将`z[i]`减1，确保C非空。调试时通过打印中间变量，发现了这一错误。”

**点评**：边界条件的处理是本题的易错点（如C非空）。作者通过打印中间变量快速定位问题，这提醒我们在调试时应关注关键变量（如Z数组的值、循环节次数），确保逻辑正确。

---

<conclusion>
本次关于“字符串匹配”的C++解题分析就到这里。通过理解扩展KMP的循环节判断、树状数组的奇数字符统计，以及动态维护前缀和后缀的技巧，相信你已经掌握了这道题的核心解法。继续加油，多练习相似题目，你会更熟练地应用这些算法！💪
</conclusion>

---
处理用时：188.66秒
# 题目信息

# [COCI 2011/2012 #4] KRIPTOGRAM

## 题目描述

现有一段明文和一部分密文。明文和密文都由英文单词组成，且密文中的一个单词必然对应着明文中的一个单词。

求给出的密文在明文中可能出现的最早位置。

## 说明/提示

**【数据规模与约定】**

- 对于 $100\%$ 的数据，明文和密文所对应字符串的长度不超过 $10^6$，输入的单词均由小写字母组成。

**【提示与说明】**

**题目译自 [COCI 2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #4](https://hsin.hr/coci/archive/2011_2012/contest4_tasks.pdf) _Task 6 KRIPTOGRAM_。**

**本题分值按 COCI 原题设置，满分 $140$。**

## 样例 #1

### 输入

```
a a a b c d a b c $
x y $```

### 输出

```
3```

## 样例 #2

### 输入

```
xyz abc abc xyz $
abc abc $```

### 输出

```
2```

## 样例 #3

### 输入

```
a b c x c z z a b c $
prvi dr prvi tr tr x $```

### 输出

```
3```

# AI分析结果

---
# 💡 Kay的C++算法解析：[COCI 2011/2012 #4] KRIPTOGRAM 深入学习指南 💡

<introduction>
今天我们要解决的是“KRIPTOGRAM”问题。这道题的关键在于找到明文和密文之间的“模式匹配”——即它们的单词出现规律是否一致，而不是具体的单词内容。通过分析题解，我们将学习如何用哈希或KMP算法处理这种模式匹配，并理解其中的核心技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：字符串匹配（哈希/KMP应用）

🗣️ **初步分析**：
解决这道题的关键在于将单词序列转换为“模式序列”，即每个单词与前一个相同单词的距离（若第一次出现则记为-1或inf）。例如，明文“a b a c”会被转换为“-1 -1 2 -1”（假设a第一次出现是位置1，b是位置2，a再次出现是位置3，距离为3-1=2；c是位置4，第一次出现，记为-1）。密文也需要做同样的转换，然后我们需要在明文中找到第一个与密文模式序列完全匹配的子串。

核心难点在于：当滑动窗口移动时，移出窗口的单词可能会影响窗口内后续相同单词的距离值（例如，移出窗口的单词是某个单词的前一个出现位置，那么该单词的距离值需要更新为-1）。

常见解法有两种：
- **哈希法**：维护滑动窗口内模式序列的哈希值，动态更新哈希以匹配窗口移动时的变化。
- **KMP法**：修改KMP的匹配条件，使其适应模式序列的匹配规则（如比较距离值是否相等，或处理窗口外的前一个位置）。

可视化设计上，我们可以用8位像素风格展示单词序列，每个像素块颜色代表其距离值（如红色-1，蓝色2等）。窗口移动时，动态调整颜色并高亮哈希值的计算过程，配合“叮”的音效提示哈希更新，帮助直观理解模式匹配的动态过程。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下题解表现突出（≥4星）：
</eval_intro>

**题解一：作者-离散小波变换°（赞：33）**
* **点评**：此题解采用哈希法，思路清晰且代码规范。作者巧妙地将单词转换为距离序列，并用滑动窗口维护哈希值。通过预处理每个单词的下一个出现位置（`R1`数组），在窗口移动时动态调整哈希值，解决了窗口外单词影响后续距离值的问题。代码中变量命名（如`L1`、`R1`）含义明确，边界处理严谨（如`R1[i]`初始化为`INF`），是竞赛中实用的高效实现。

**题解二：作者-Yharimium（赞：5）**
* **点评**：此题解基于KMP算法，通过修改匹配条件（比较距离值或处理窗口外的前一个位置）实现模式匹配。作者详细解释了“匹配条件”的推导（如`i - preA[i] == j - preB[j]`或`preB[j]==0`且`preA[i]`在窗口外），代码结构清晰，`getPre`函数预处理前一个出现位置，`getSpLen`生成KMP的部分匹配表，适合理解KMP在模式匹配中的变形应用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于处理“模式序列”的动态变化。以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **难点1：如何定义模式序列？**
    * **分析**：模式序列的定义需反映单词的出现规律。通常，每个位置的模式值为该单词与前一个相同单词的距离（无则为-1）。例如，明文“a a b a”的模式序列为`[-1, 1, -1, 3]`（第二个a距离前一个a为1，第四个a距离前一个a为3）。
    * 💡 **学习笔记**：模式序列的定义需保证“相同单词的相对位置关系”被唯一表示。

2.  **难点2：滑动窗口移动时如何维护模式序列？**
    * **分析**：当窗口左边界右移时，移出窗口的单词可能是窗口内某个单词的前一个出现位置。此时，该单词的模式值需更新为-1（因为前一个出现位置已不在窗口内）。例如，窗口移出第一个a后，第三个a的前一个出现位置变为窗口内的第二个a，距离为1（原距离为3）。
    * 💡 **学习笔记**：预处理每个单词的下一个出现位置（`nxt`数组），窗口移动时检查该位置是否在当前窗口内，若在则更新模式值。

3.  **难点3：如何高效匹配模式序列？**
    * **分析**：直接逐个比较模式序列的时间复杂度为O(nm)，无法处理1e6的数据。哈希法通过维护窗口哈希值（O(1)比较），KMP法通过部分匹配表（O(n+m)时间）解决此问题。
    * 💡 **学习笔记**：哈希法适合快速比较，KMP法适合处理多模式匹配，需根据问题选择。

### ✨ 解题技巧总结
- **预处理关键数组**：预处理每个单词的前一个和下一个出现位置（`pre`、`nxt`数组），快速获取模式值。
- **滑动窗口哈希**：使用基数哈希（如BAS=13331），窗口移动时通过`h = h * BAS + new_val - old_val * BAS^m`维护哈希值。
- **KMP条件修改**：匹配时需考虑前一个位置是否在窗口内（如`preB[j]==0`时，`preA[i]`需在窗口外）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择离散小波变换°的哈希法代码作为通用核心实现，其逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了哈希法的核心思想，通过预处理前一个和下一个出现位置，动态维护滑动窗口的哈希值，适用于大规模数据。
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    typedef long long i64;
    const int INF = 2147483647;
    const int MAXN = 1e6 + 3;
    int L1[MAXN], R1[MAXN], L2[MAXN], R2[MAXN];
    int A[MAXN], B[MAXN], n, m;
    typedef unsigned long long u64;
    const u64 BAS = 13331;
    u64 H[MAXN], P[MAXN];
    map<string, int> M;

    int main() {
        string t;
        // 读取明文并预处理前一个和下一个出现位置
        while (cin >> t && t != "$") {
            R1[M[t]] = ++n, L1[n] = M[t], M[t] = n;
        }
        M.clear();
        // 读取密文并预处理前一个和下一个出现位置
        while (cin >> t && t != "$") {
            R2[M[t]] = ++m, L2[m] = M[t], M[t] = m;
        }
        // 初始化未出现的下一个位置为INF
        for (int i = 1; i <= n; ++i) if (!R1[i]) R1[i] = INF;
        for (int i = 1; i <= m; ++i) if (!R2[i]) R2[i] = INF;
        // 生成模式序列A和B
        for (int i = 1; i <= n; ++i) A[i] = L1[i] ? i - L1[i] : -1;
        for (int i = 1; i <= m; ++i) B[i] = L2[i] ? i - L2[i] : -1;
        // 计算密文哈希值h0和初始窗口哈希值h
        u64 h0 = 0, h = 0; P[0] = 1;
        for (int i = 1; i <= m; ++i) P[i] = P[i - 1] * BAS;
        for (int i = 1; i <= m; ++i) h0 = h0 * BAS + B[i], h = h * BAS + A[i];
        if (h == h0) { printf("1\n"); return 0; }
        // 滑动窗口匹配
        for (int i = m + 1; i <= n; ++i) {
            h = h * BAS + A[i] - A[i - m] * P[m];
            if (R1[i - m] <= i) { // 移出的单词影响当前窗口内的模式值
                h -= A[R1[i - m]] * P[i - R1[i - m]];
                A[R1[i - m]] = -1;
                h += A[R1[i - m]] * P[i - R1[i - m]];
            } else if (R1[i - m] <= n) A[R1[i - m]] = -1;
            if (h == h0) { printf("%d\n", i - m + 1); return 0; }
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先读取明文和密文，预处理每个单词的前一个（`L1`/`L2`）和下一个（`R1`/`R2`）出现位置，生成模式序列`A`和`B`。然后计算密文的哈希值`h0`，并初始化明文前m个单词的哈希值`h`。通过滑动窗口移动，动态更新`h`（减去移出单词的贡献，加上新单词的贡献，并处理窗口外单词的影响），最终找到第一个匹配的位置。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者-离散小波变换°**
* **亮点**：动态维护滑动窗口的哈希值，处理窗口外单词对模式值的影响。
* **核心代码片段**：
    ```cpp
    for (int i = m + 1; i <= n; ++i) {
        h = h * BAS + A[i] - A[i - m] * P[m];
        if (R1[i - m] <= i) {
            h -= A[R1[i - m]] * P[i - R1[i - m]];
            A[R1[i - m]] = -1;
            h += A[R1[i - m]] * P[i - R1[i - m]];
        } else if (R1[i - m] <= n) A[R1[i - m]] = -1;
        if (h == h0) { /* 输出位置 */ }
    }
    ```
* **代码解读**：
  - 窗口右移时，哈希值`h`先减去移出单词（`i-m`位置）的贡献（`A[i-m] * P[m]`），再加上新单词（`i`位置）的贡献（`A[i]`）。
  - 若移出单词的下一个出现位置（`R1[i-m]`）在当前窗口内（`<=i`），则更新该位置的模式值为-1，并调整哈希值（减去旧值，加上新值）。
  - 若下一个出现位置在窗口外但在明文范围内，直接将其模式值设为-1（不影响当前窗口）。
* 💡 **学习笔记**：滑动窗口的哈希维护需同时处理移出和移入的单词，以及移出单词对后续模式值的影响。

**题解二：作者-Yharimium（KMP法）**
* **亮点**：修改KMP的匹配条件，适应模式序列的匹配规则。
* **核心代码片段**：
    ```cpp
    bool check(int i, int j) {
        if (ls2[j+1] == inf && ls1[i] < j+1) return false;
        if (ls2[j+1] != inf && fl1[i] != fl1[i - ls2[j+1]]) return false;
        return true;
    }
    ```
* **代码解读**：
  - `ls2[j+1]`是密文第j+1个单词的模式值（前一个出现的距离）。
  - 若`ls2[j+1]`为inf（密文中该单词第一次出现），则明文对应位置的模式值`ls1[i]`需≥j+1（前一个出现位置在窗口外）。
  - 若`ls2[j+1]`不为inf，则明文对应位置的单词需与前`ls2[j+1]`位置的单词相同（`fl1[i] == fl1[i - ls2[j+1]]`）。
* 💡 **学习笔记**：KMP的匹配条件需根据问题特性调整，确保模式序列的“相对位置关系”一致。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解哈希法的滑动窗口过程，我们设计一个“像素模式匹配器”动画，以8位复古风格展示模式序列的生成和哈希值的动态更新。
</visualization_intro>

  * **动画演示主题**：像素模式匹配器（8位复古风）

  * **核心演示内容**：
    - 明文和密文的单词序列转换为模式序列（颜色块表示距离值，如红色-1，蓝色2，绿色1）。
    - 滑动窗口移动时，动态更新窗口内的模式值和哈希值，高亮移出和移入的单词，并播放“叮”音效提示哈希更新。
    - 当哈希值匹配时，播放胜利音效，窗口闪烁绿色。

  * **设计思路简述**：
    - 8位像素风格营造轻松学习氛围，颜色区分模式值帮助记忆。
    - 动态窗口移动和哈希值更新直观展示算法核心，音效强化关键操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
        - 明文和密文的单词序列显示为两排像素块（明文在上，密文在下），每个块标注单词（如a、b）和模式值（如-1、2）。
        - 控制面板包含“开始/暂停”“单步”“调速”按钮，速度滑块（0.5x-2x）。

    2.  **模式序列生成**：
        - 明文和密文的单词逐个转换为模式值（如第一个a→红色-1，第二个a→蓝色1），伴随“滴答”音效。

    3.  **滑动窗口移动**：
        - 初始窗口覆盖明文前m个单词，哈希值显示为密文的哈希值（h0）。
        - 窗口右移时，移出左端单词块（变灰），移入右端新单词块（高亮黄色）。
        - 若移出单词的下一个出现位置在窗口内，该位置的模式值块颜色从蓝色（原距离）变为红色（-1），哈希值数字动态更新（如“h=1234”→“h=1245”）。

    4.  **匹配成功**：
        - 当窗口哈希值等于h0时，窗口闪烁绿色，播放“胜利”音效，标注匹配位置（如“位置3”）。

  * **旁白提示**：
    - “注意看，当窗口移出第一个a时，后面的a的模式值会从3变成1，因为前一个a现在在窗口内了！”
    - “哈希值现在更新为h=1245，和密文的h0=1245相同，匹配成功！”

<visualization_conclusion>
通过这个动画，我们能清晰看到模式序列的生成、窗口移动时的动态调整，以及哈希值匹配的全过程，轻松理解算法的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的模式匹配思想可迁移到多种场景，以下是相关练习推荐：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 字符串模式匹配（如判断两段文本是否“同构”）。
    - 数组模式匹配（如判断两个数组的“形状”是否相同，如CF471D）。
    - 生物信息学中的序列比对（如DNA序列的模式匹配）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3370** - 【模板】字符串哈希  
        * 🗣️ **推荐理由**：巩固哈希算法的基础应用，适合理解哈希在字符串匹配中的作用。
    2.  **洛谷 CF471D** - MUH and Cube Walls  
        * 🗣️ **推荐理由**：与本题思路高度相似，均需将数组转换为模式序列后匹配，适合练习模式匹配的变形。
    3.  **洛谷 P5440** - 【XR-2】奇迹  
        * 🗣️ **推荐理由**：涉及多模式匹配和哈希优化，适合提升复杂场景下的模式匹配能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时遇到的问题，例如：
</insights_intro>

> 参考经验（来自 orzws）：“其他题解中会被hack的主要原因是因为在求kmp数组时直接用ls2去匹配，但是这样其实是错的，我们在求kmp数组时要考虑清楚他的定义与匹配方式（上方的分讨），直接判断是否相等显然就没有考虑清楚匹配方式。”

**点评**：这位作者的经验提醒我们，在修改经典算法（如KMP）时，必须重新定义匹配条件，确保其符合问题的特殊要求。直接套用模板可能忽略关键细节（如窗口外的前一个位置），导致错误。调试时可通过构造特殊测试用例（如样例中的hack数据）验证算法正确性。

-----

<conclusion>
通过分析“KRIPTOGRAM”问题，我们掌握了模式匹配的核心技巧（哈希/KMP变形），理解了滑动窗口的动态维护方法。编程能力的提升需要多练习、多思考，希望大家能将这些技巧应用到更多问题中！下次见~ 💪
</conclusion>

-----

---
处理用时：134.72秒
# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果


# 💡 Kay的C++算法解析：最优贸易 深入学习指南 💡

> 今天我们来分析「最优贸易」这道经典的图论问题。阿龙需要在城市间买卖水晶球赚取差价，我们将通过分层图和Tarjan两种主流解法，带你掌握状态转移和强连通分量的应用技巧。同时，我会设计一个复古像素游戏动画，帮你直观理解算法执行过程！

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`分层图状态转移` 与 `强连通分量缩点`

🗣️ **初步分析**：
> 解决「最优贸易」的关键在于将交易过程转化为状态转移。想象你操控一个像素小人在三层平行世界中穿梭：
> - **第一层（蓝色世界）**：未购买水晶球，自由移动无消耗
> - **第二层（红色世界）**：已购买水晶球，移动时头顶显示水晶球
> - **第三层（金色世界）**：已售出水晶球，移动时显示钱袋
>
> 当小人在城市i购买时，会从蓝色世界垂直跳转到红色世界，并扣除金币（-price[i]）；当售出时，从红色世界跳转到金色世界，获得金币（+price[i]）。最终目标是从蓝色起点到达金色终点，最大化金币数量。

**可视化设计**：
- 8-bit像素风格，每层世界用不同背景色（蓝/红/金）
- 购买/出售时触发复古音效（购买：下降音调，出售：上升音调）
- 关键帧动画：小人跳跃时显示金币变化数值
- 自动演示模式：AI小人沿最优路径移动，速度可调

---

## 2. 精选优质题解参考

### 题解一：fy1234567ok（分层图+SPFA）
* **点评**：
  思路清晰度 ★★★★☆ | 代码规范性 ★★★★★ | 算法有效性 ★★★★☆  
  用40行代码实现三层图建模，宏定义`t(x,i)`简化跨层节点计算。SPFA求最长路时注意负权处理，层内移动边权为0，跨层转移用-price/price体现交易。虽然SPFA理论最坏O(nm)，但本题数据可通过。

### 题解二：ctzm（Tarjan缩点+DAG DP）
* **点评**：
  思路清晰度 ★★★★☆ | 代码规范性 ★★★★☆ | 算法有效性 ★★★★★  
  通过Tarjan将环缩点为DAG，在强连通分量内记录min_price/max_price。拓扑排序中递推最小买入价和最大利润，用反图处理可达性判断。避免SPFA不稳定问题，严格O(n)复杂度。

---

## 3. 核心难点辨析与解题策略

1. **状态定义与转移建模**
   * **分析**：分层图将交易分解为“未买→已买→已卖”三状态，用层间边权体现资金变化；Tarjan解法需在SCC内聚合极值，在DAG边缘传递状态
   * 💡 学习笔记：将交易事件转化为图论状态是解题核心

2. **路径可达性保证**
   * **分析**：必须确保买卖点都在1→n的路径上。分层图通过三层连通性隐式保证；Tarjan需正反两次DFS标记可达点
   * 💡 学习笔记：图论问题中“存在路径”需显式验证

3. **负权边与环路处理**
   * **分析**：分层图SPFA需将负权转化为最长路问题；Tarjan缩点彻底消除环路，使DP无后效性
   * 💡 学习笔记：根据数据规模选择解法——小图用分层图直观，大图用Tarjan稳定

### ✨ 解题技巧总结
- **状态分层法**：将操作步骤转化为图层次（如k次机会问题）
- **分量聚合**：强连通分量内直接计算极值，简化后续处理
- **反图验证**：用反向建图快速判断点到终点的可达性
- **拓扑序DP**：DAG上递推是消除后效性的利器

---

## 4. C++核心代码实现赏析

### 通用核心实现（分层图解法）
```cpp
#include <bits/stdc++.h>
#define t(x,i) (x+i*n) // 第i层的节点x
using namespace std;
const int N = 1e5+5;

vector<pair<int, int>> G[N*3]; // 三层图存储
int d[N*3], n, m; // d[i]：到达i点的最大收益

void spfa(int s) {
    memset(d, 0xcf, sizeof(d)); // 初始化为-∞
    queue<int> q;
    q.push(s); d[s] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto [v, w] : G[u]) 
            if (d[v] < d[u] + w) {
                d[v] = d[u] + w;
                q.push(v);
            }
    }
}

int main() {
    cin >> n >> m;
    // 层内移动边（权0） + 跨层转移边
    for (int i = 1, p; i <= n; i++) {
        cin >> p;
        G[t(i,0)].emplace_back(t(i,1), -p); // 购买转移
        G[t(i,1)].emplace_back(t(i,2), p);   // 出售转移
    }
    // 原图边复制到三层
    for (int i = 1, u, v, k; i <= m; i++) {
        cin >> u >> v >> k;
        for (int l = 0; l < 3; l++) { // 每层内建边
            G[t(u,l)].emplace_back(t(v,l), 0);
            if (k == 2) G[t(v,l)].emplace_back(t(u,l), 0);
        }
    }
    spfa(t(1,0)); // 从第0层起点开始
    cout << d[t(n,2)]; // 到达第2层终点
}
```

### 题解一：分层图片段赏析
```cpp
// 关键宏定义和转移边
#define t(x,i) (x+i*n)
G[t(i,0)].push_back({t(i,1), -v}); // 购买
G[t(i,1)].push_back({t(i,2), v});  // 出售

// 原图边复制（单层→三层）
for (int l = 0; l < 3; l++) {
    G[t(u,l)].push_back({t(v,l), 0});
    if (z == 2) G[t(v,l)].push_back({t(u,l), 0});
}
```
**代码解读**：  
1. `t(x,i)`宏将三维坐标压缩为一维，例如第2层的3号节点编号为`3+2*n`  
2. 购买转移相当于从蓝色层（0）垂直跳转到红色层（1），支出v金币  
3. 原图边在每层内复制，保持层内连通性不变  

### 题解二：Tarjan缩点片段
```cpp
// Tarjan求SCC（强连通分量）
void tarjan(int u) {
    low[u] = dfn[u] = ++cnt;
    stk[++top] = u; in_stk[u] = true;
    for (int v : g[u]) {
        if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
        else if (in_stk[v]) low[u] = min(low[u], dfn[v]);
    }
    if (low[u] == dfn[u]) { // 发现SCC
        scc_id++;
        while (true) {
            int v = stk[top--];
            in_stk[v] = false;
            scc[v] = scc_id;
            min_cost[scc_id] = min(min_cost[scc_id], price[v]); // 分量内最小成本
            max_val[scc_id] = max(max_val[scc_id], price[v]);   // 分量内最大售价
            if (u == v) break;
        }
    }
}

// DAG上DP递推
void dp() {
    // 初始化：从起点SCC开始
    f[scc[1]] = min_cost[scc[1]]; 
    for (int i = scc_cnt; i; i--) { // 逆拓扑序
        ans = max(ans, max_val[i] - f[i]);
        for (int j : dag[i]) // 更新后继节点
            f[j] = min(f[j], min(f[i], min_cost[j]));
    }
}
```
**代码解读**：  
1. Tarjan递归过程用`low`数组回溯，栈存储当前路径  
2. SCC内部直接聚合极值——买卖可在同一分量完成  
3. 逆拓扑序更新保证无后效性：`f[i]`表示到达i分量的最小成本  

---

## 5. 算法可视化：像素动画演示

### 像素化分层图演示方案
* **主题**：水晶球贸易大冒险（8-bit RPG风格）
* **核心机制**：
  ```mermaid
  graph LR
    A[1号城市-蓝色层] -- 移动/0金币 --> B[2号城市-蓝色层]
    B -- 购买/-3金币 --> C[2号城市-红色层]
    C -- 移动/0金币 --> D[3号城市-红色层]
    D -- 出售/+5金币 --> E[3号城市-金色层]
  ```

* **动画设计**：
  1. **场景初始化**：
     - 三平行世界：蓝层（基础世界）、红层（持有水晶球）、金层（已售出）
     - 城市节点用像素城堡表示，道路为砖块路径

  2. **关键操作特效**：
     - 购买：蓝色层→红色层，水晶球图标缩放出现，金币数变红下降
     - 出售：红色层→金色层，水晶球爆炸为金币雨，金币数变绿上升
     - 移动：小人像素动画（跑动帧），伴随脚步声效

  3. **动态数据展示**：
     - 左上角HUD显示：当前层/持有状态/累计金币
     - 每次交易显示浮动文字：`+5金币！`

  4. **AI演示模式**：
     - 自动寻路：用迪杰斯特拉算法计算最优路径
     - 支持调速：慢速0.5x~快速3x
     - 完成路径后显示：`总收益：5金币！`

* **复古元素**：
  - 音效：FC芯片音乐，购买/出售用《塞尔达》道具音效改编
  - 过场动画：每到达新城市显示8-bit城市名称弹窗
  - 成就系统：根据收益解锁铜/银/金牌

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
分层图思想还可用于：
1. 次短路问题：复制两图层分别记录最/次短路
2. 限时通行证：每层代表剩余通行证数量
3. 危险区域穿越：用层数记录已承受伤害值

### 推荐题目
1. **P2939 [USACO09FEB]Revamping Trails G**  
   （分层图模板题，k次免费升级路径）

2. **P3387 【模板】缩点**  
   （Tarjan缩点入门，练习DAG上DP）

3. **P3003 [USACO10DEC]Apple Delivery S**  
   （状态压缩+最短路，练习多目标决策）

---

## 7. 学习心得与经验分享

> **来自fy1234567ok的调试经验**：  
> “最初在实现分层图时，忽略了同一城市内跨层边的添加，导致状态无法转移。通过打印每层节点的访问状态，快速定位了缺失的转移边。”

> **Kay的总结**：  
> 分层图优势在于**直观建模状态机**，适合快速原型；而Tarjan解法则胜在**理论复杂度稳定**。在竞赛中，若n≤10^5优先Tarjan，否则可用分层图+SPFA快速实现。记得验证终点可达性！

---

本次解析就到这里，快打开洛谷用分层图解决P2939，巩固学习成果吧！下次我们将探索状态压缩DP的奇妙世界 🚀

---
处理用时：232.60秒
# 题目信息

# [GCJ 2019 #2] Contransmutation

## 题目描述

去年，我们曾请你帮忙将昂贵的金属转化为铅。（你无需了解前一道题即可解答本题。）但你们国家的领导人依然贪婪地渴望获得更多的铅！

世界上已知有 $\mathbf{M}$ 种金属；在你的元素周期表上，铅是第 1 号金属。你们国家的领导人要求你利用国库中的金属，尽可能多地制造铅。

对于每种金属（包括铅），你都知道恰好有一种配方，可以消耗 1 克该金属，并各生成 1 克另外两种金属。（关于质量守恒原理，最好不要深究！）注意，第 $i$ 种金属的配方可能会生成第 $i$ 种金属本身作为产物之一。配方不能对部分克数的金属起作用。然而，只要你拥有所需金属的 1 克，你可以任意多次（或不使用）使用每种配方。

如果你做出最优选择，最终最多能获得多少克铅，或者说这个数量是否没有上限？如果没有上限：由于输出可能非常大，我们只要求你输出结果除以质数 $10^9+7$（即 $1000000007$）的余数。

## 说明/提示

**样例解释**

在样例 1 中，你有一个配方可以将 1 克铅变为 1 克铅和 1 克第二种金属，另一个配方可以将 1 克第二种金属变为 1 克铅和 1 克第二种金属。你可以交替使用这两个配方，制造出任意多的两种金属。

样例 2 的配方与样例 1 相同，但你一开始没有任何金属！

样例 3 中，所有配方都无法帮助你制造更多的铅，因此你最终获得的铅不会超过初始拥有的数量。

**数据范围**

- 对所有 $i$，$1 \leq \mathbf{R_{i1}} < \mathbf{R_{i2}} \leq \mathbf{M}$。

**测试点 1（7 分，公开）**

- $1 \leq \mathbf{T} \leq 100$。
- $2 \leq \mathbf{M} \leq 10$。
- $0 \leq \mathbf{G_i} \leq 10$。

**测试点 2（16 分，隐藏）**

- $1 \leq \mathbf{T} \leq 100$。
- $2 \leq \mathbf{M} \leq 100$。
- $0 \leq \mathbf{G_i} \leq 10^9$。

**测试点 3（6 分，隐藏）**

- $1 \leq \mathbf{T} \leq 5$。
- $2 \leq \mathbf{M} \leq 10^5$。
- $0 \leq \mathbf{G_i} \leq 10^9$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
2
1 2
1 2
1 0
2
1 2
1 2
0 0
4
2 4
3 4
2 4
2 3
10 10 10 10```

### 输出

```
Case #1: UNBOUNDED
Case #2: 0
Case #3: 10```

# AI分析结果

---
# 💡 Kay的C++算法解析：Contransmutation 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（强连通分量缩点 + 拓扑排序）

🗣️ **初步分析**：  
解决这道题，关键在于把“金属转化”变成一张**关系网**——每个金属是图中的节点，转化配方是节点的两条出边（比如金属A能生成B和C，就从A连两条边到B和C）。我们的目标是看“铅（节点1）”能不能被无限生产，或者算出最多能有多少。  

### 算法核心思想类比
想象你有一堆“金属积木”，每个积木能变出两个新积木。如果几个积木能互相转化（比如A变B、B变C、C变A），它们就形成一个“小圈子”（强连通分量，SCC）。如果这个圈子能“自我繁殖”（比如圈子里的积木变来变去，总数越来越多），那它后面的所有积木都能无限生产！我们的任务就是：  
1. 把这些“小圈子”合并成“超级积木”（缩点）；  
2. 按“超级积木”的依赖顺序（拓扑排序）计算每个“超级积木”能产出多少金属；  
3. 判断“铅”所在的“超级积木”是否能被无限生产。  

### 题解思路与核心难点
题解的核心思路是**缩点+拓扑排序**：  
- 先用Tarjan算法找出所有强连通分量（SCC），把每个SCC缩成一个节点；  
- 对缩点后的DAG（有向无环图）进行拓扑排序，依次计算每个节点的金属数量；  
- 判断是否有SCC能无限生产（比如SCC内部不是单环，或者有自环且有原料），如果铅所在节点被标记为无限，则输出UNBOUNDED。  

**核心难点**：  
1. 如何准确判断“无限生产”的条件？（比如SCC是单环还是多分支？）  
2. 自环的金属（比如A能生成A和B）怎么处理？  
3. 原料存在性的判断（避免取模后误把“很多金属”当成“0”）。  

**可视化设计思路**：  
我们用**8位像素风**模拟这个过程——  
- 节点是彩色像素块（比如铅是红色，其他金属是蓝色）；  
- 边是像素线条（比如A→B是黄色线条）；  
- 缩点时，多个节点会“合并”成一个大像素块（比如3个蓝色节点变成一个紫色超级节点）；  
- 拓扑排序时，超级节点按顺序“流动”（从左到右），处理时闪烁高亮；  
- 无限生产的节点会持续闪烁红色，伴随“叮叮”的警示音效。  


## 2. 精选优质题解参考

**题解一：来源：zhuweiqi**  
* **点评**：这份题解把“图论建模+缩点+拓扑排序”的思路讲得非常透彻，甚至点出了3个容易掉的“坑”（比如单环SCC不能无限生产、自环处理、原料存在性）。代码逻辑连贯，用Tarjan缩点、拓扑排序处理依赖关系，覆盖了所有关键细节。比如用`hav`数组单独记录“是否有原料”，避免了取模后误判的问题；用`fg`数组标记SCC是否有“自我繁殖”能力，这些处理都很严谨。唯一的小缺点是数组太多（比如`dfn`、`low`、`sd`等），但注释如果补充一下会更友好——不过对于有一定基础的学习者来说，这不影响它成为一份优质题解。  


## 3. 核心难点辨析与解题策略

### 核心难点1：如何判断“无限生产”的条件？
**问题**：不是所有强连通分量都能无限生产。比如一个单环（A→B→C→A），每个节点只能转化一次，总数不会变；但如果SCC里有分支（比如A→B和A→A），就能无限生成。  
**解决策略**：缩点后，判断SCC的**边数与点数的关系**：  
- 如果SCC大小>1，且内部存在节点的两条出边都在SCC内（不是单环），则这个SCC能无限生产；  
- 如果SCC是单节点（自环），则直接标记为能无限生产。  

### 核心难点2：自环的处理
**问题**：金属A能生成A和B（自环），这种情况如何判断？  
**解决策略**：用`dh`数组标记是否有自环。如果自环的节点是独立SCC（没有其他节点），则直接归为“能无限生产”；否则，它的两条边都在SCC内，会被前面的条件覆盖。  

### 核心难点3：原料存在性的正确判断
**问题**：金属数量很大时需要取模，但取模后可能变成0（比如1e9+7取模后是0），但实际上有原料。  
**解决策略**：单开`hav`布尔数组，记录“该SCC是否有原始原料”，不依赖取模后的`cnt`值。  

### ✨ 解题技巧总结
- **图论建模**：把“转化关系”变成图的边，问题就转化为图的遍历和依赖处理；  
- **缩点简化**：强连通分量内的节点可以视为一个整体，减少问题复杂度；  
- **拓扑排序**：按依赖顺序处理节点，确保计算的正确性；  
- **细节处理**：用额外数组记录“存在性”“自环”等特殊情况，避免逻辑错误。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：本代码综合了题解的核心逻辑，提炼了缩点（Tarjan）和拓扑排序的关键部分，结构更清晰。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

typedef long long ll;
const int N = 1e5 + 5;
const int MOD = 1e9 + 7;

vector<int> e[N];  // 原图的边
int dfn[N], low[N], sd[N], stk[N], ins[N];  // Tarjan相关数组
ll cnt[N];  // 每个SCC的金属数量
bool hav[N]; // 是否有原料
bool fg[N];  // 是否能无限生产
int rk[N], rd[N];  // 拓扑排序的入度
int num = 0, tp = 0, scc_cnt = 0;

// Tarjan找强连通分量
void tarjan(int u) {
    dfn[u] = low[u] = ++num;
    stk[++tp] = u; ins[u] = 1;
    for (int v : e[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (ins[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]) {
        scc_cnt++;
        int v;
        do {
            v = stk[tp--];
            ins[v] = 0;
            sd[v] = scc_cnt;  // 标记v属于哪个SCC
            cnt[scc_cnt] += ...;  // 累加原始金属数量
            hav[scc_cnt] |= ...;  // 标记是否有原料
        } while (v != u);
    }
}

int main() {
    int T; cin >> T;
    while (T--) {
        int M; cin >> M;
        memset(dfn, 0, sizeof(dfn));
        memset(low, 0, sizeof(low));
        memset(sd, 0, sizeof(sd));
        memset(cnt, 0, sizeof(cnt));
        memset(hav, 0, sizeof(hav));
        memset(fg, 0, sizeof(fg));
        memset(rd, 0, sizeof(rd));
        scc_cnt = num = tp = 0;

        // 1. 读入配方，建图
        for (int i = 1; i <= M; i++) {
            int a, b; cin >> a >> b;
            e[i].push_back(a);
            e[i].push_back(b);
        }

        // 2. 读入原始金属数量
        for (int i = 1; i <= M; i++) {
            ll g; cin >> g;
            // 后续处理原始数量到cnt数组
        }

        // 3. Tarjan缩点
        for (int i = 1; i <= M; i++) {
            if (!dfn[i]) tarjan(i);
        }

        // 4. 建缩点后的DAG
        vector<int> dag[N];
        for (int u = 1; u <= M; u++) {
            for (int v : e[u]) {
                if (sd[u] != sd[v]) {
                    dag[sd[u]].push_back(sd[v]);
                    rd[sd[v]]++;
                }
            }
        }

        // 5. 拓扑排序处理DAG
        queue<int> q;
        for (int i = 1; i <= scc_cnt; i++) {
            if (rd[i] == 0) q.push(i);
        }

        while (!q.empty()) {
            int u = q.front(); q.pop();
            // 判断是否能无限生产
            if (hav[u] && (fg[u] || ...)) {
                cnt[u] = -1;
            }
            // 传递到后续节点
            for (int v : dag[u]) {
                if (cnt[u] == -1) {
                    cnt[v] = -1;
                } else if (cnt[v] != -1) {
                    cnt[v] = (cnt[v] + cnt[u]) % MOD;
                }
                rd[v]--;
                if (rd[v] == 0) q.push(v);
            }
        }

        // 6. 输出结果
        if (cnt[sd[1]] == -1) {
            cout << "UNBOUNDED\n";
        } else {
            cout << cnt[sd[1]] % MOD << "\n";
        }
    }
    return 0;
}
```
* **代码解读概要**：  
代码分为6个部分：  
1. 读入配方，构建原图（每个金属的两条出边）；  
2. 读入原始金属数量；  
3. Tarjan算法找所有强连通分量，缩点；  
4. 构建缩点后的DAG（有向无环图）；  
5. 拓扑排序处理DAG，计算每个SCC的金属数量，判断是否无限；  
6. 输出铅（节点1）的结果。  


### 题解核心代码片段赏析（来源：zhuweiqi）
* **亮点**：用`hav`数组记录原料存在性，处理了取模后的误判问题；用`fg`数组标记SCC是否能无限生产。
* **核心代码片段**：
```cpp
// 拓扑排序中的处理逻辑
while(!q.empty()){
    int x=q.front(); q.pop();
    hav[x] = hav[x] | (cnt[x] != 0);  // 记录是否有原料
    // 判断是否能无限生产
    if(siz[x]>1 && hav[x] && fg[x]) cnt[x] = -1;
    bool unl = 0;
    if(hav[x] && (dh[x] || siz[x]>1) || cnt[x]==-1) unl=1;
    if(x==1) break;  // 铅的SCC，提前终止
    // 传递到后续节点
    for(auto y:e[x]){
        if(unl) cnt[y] = -1;
        else if(cnt[y]!=-1) cnt[y] = (cnt[x]+cnt[y])%mod;
        if(--rd[y]==0) q.push(y);
        hav[y] = hav[y] | hav[x];
    }
}
```
* **代码解读**：  
这段代码是拓扑排序的核心：  
- `hav[x]`记录该SCC是否有原料（不管`cnt`是否取模后为0）；  
- `siz[x]>1 && hav[x] && fg[x]`：如果SCC大小>1、有原料、且不是单环（`fg[x]`标记），则`cnt[x]`设为-1（无限）；  
- `unl`变量标记当前SCC是否能无限生产，传递给后续节点；  
- `hav[y] = hav[y] | hav[x]`：后续SCC继承原料存在性。  
* 💡 **学习笔记**：用布尔数组记录“存在性”是处理大数值取模的关键技巧，避免逻辑错误。  


## 5. 算法可视化：像素动画演示

### 动画主题：像素金属工厂的“无限生产”探秘
### 设计思路
采用**8位FC游戏风格**，用像素块模拟金属转化过程，结合音效和“小关卡”增加趣味性。比如：  
- 背景是复古的工厂车间（像素化的管道、机器）；  
- 金属节点是彩色方块（铅是红色，其他是蓝色）；  
- 转化边是黄色线条，闪烁表示活跃；  
- 强连通分量合并时，多个蓝色方块会“吸”成一个紫色超级方块，伴随“咻”的音效；  
- 拓扑排序时，超级方块按顺序从左到右流动，处理时闪烁绿色，伴随“叮”的音效；  
- 无限生产的超级方块会持续闪烁红色，屏幕下方弹出“警告：无限生产！”的像素文字，伴随急促的“滴滴”声；  
- 通关时（算出铅的数量），播放8位风格的胜利音乐，红色方块（铅）变大并闪烁。

### 动画帧步骤与交互
1. **初始化**：  
   - 屏幕左侧是“金属节点区”（蓝色方块排列），右侧是“控制面板”（开始/暂停、单步、重置按钮，速度滑块）；  
   - 背景播放轻松的8位BGM（比如《超级马里奥》的小关卡音乐）。  
2. **建图与缩点**：  
   - 点击“开始”，节点间画出黄色边（转化关系）；  
   - 强连通分量合并时，多个蓝色方块变成紫色超级方块，伴随“咻”的音效。  
3. **拓扑排序**：  
   - 超级方块按顺序从左到右移动，处理时闪烁绿色，伴随“叮”的音效；  
   - 处理到铅的超级方块时，红色方块变大，显示当前数量。  
4. **无限生产判断**：  
   - 如果铅的超级方块闪烁红色，屏幕弹出“UNBOUNDED”的像素文字，伴随“滴滴”警示音；  
   - 否则，显示铅的数量，播放胜利音乐。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的**图论建模+缩点+拓扑排序**思路，还能解决以下问题：  
- 依赖关系问题（比如任务调度，必须先完成A才能做B）；  
- 无限循环问题（比如程序中的死循环判断）；  
- 资源分配问题（比如供应链中的无限供应判断）。

### 洛谷练习推荐
1. **P2341 [HAOI2006] 受欢迎的牛**  
   - 🗣️ 推荐理由：练习强连通分量缩点，判断图中是否存在“被所有节点指向”的节点，和本题的“无限生产”判断逻辑类似。  
2. **P3387 【模板】缩点**  
   - 🗣️ 推荐理由：标准的缩点+拓扑排序模板题，帮助巩固本题的核心算法。  
3. **P1113 杂务**  
   - 🗣️ 推荐理由：拓扑排序的经典应用，练习按依赖顺序计算任务时间，和本题的拓扑处理逻辑一致。  


## 7. 学习心得与经验分享
题解作者提到了3个“易错点”，这些都是宝贵的实践经验：  
> **经验1**：强连通分量大小>1不一定能无限生产，还要看是否是单环（边数等于点数）；  
> **经验2**：自环的节点要单独处理；  
> **经验3**：原料存在性不能依赖取模后的数值，要单开布尔数组。  

**点评**：这些经验是“踩坑”后的总结，能帮你避免走弯路。比如处理强连通分量时，不要想当然认为“大圈子就能无限生产”，要仔细分析内部结构；用布尔数组记录“存在性”是处理大数值的常用技巧，一定要记住！  


## 总结
本题的核心是**图论建模+缩点+拓扑排序**，关键在于把“金属转化”变成图的问题，再通过缩点简化复杂度，最后按依赖顺序计算。记住：**图论问题的本质是“关系处理”**，只要把问题中的“关系”抽象成边，就能用图的算法解决！  

下次遇到类似的“转化”“依赖”问题，不妨试试建图→缩点→拓扑排序的思路，你会发现问题变得简单很多！💪  

--- 
本次分析结束，希望能帮你掌握图论的核心技巧。继续加油，下次我们一起解决更难的问题！✨

---
处理用时：108.24秒
# 题目信息

# [GCJ 2012 Finals] Zombie Smash

## 题目描述

你正在玩丧尸粉碎（Zombie Smash）这款游戏：你的目标是在墓地中用你可靠的丧尸粉碎器击碎不断从坟墓中冒出的丧尸。墓地被表示为一个平坦的二维网格。每只丧尸会在网格的某个 $(X, Y)$ 单元格中冒出，停留 1000 毫秒（ms），然后又消失回坟墓。任意时刻每个坟墓旁最多只会有一只丧尸。

你可以在 100ms 内移动到当前位置周围 8 个相邻格中的任意一个：也就是说，你可以向正北、正东、正南、正西、东北、东南、西北、西南移动。即使某个格子当前有丧尸占据，你依然可以经过或停在该格子。只要你到达丧尸所在的格子，就可以立即击碎该丧尸，但每次击碎后，你的丧尸粉碎器需要 750ms 冷却，冷却期间你不能再次击碎丧尸，但你可以自由移动。例如，刚刚在 $(0, 0)$ 击碎一只丧尸后：

* 你需要 750ms 才能到达并击碎 $(1, 1)$ 处的丧尸；
* 你需要 2000ms 才能到达并击碎 $(20, 20)$ 处的丧尸。

你在游戏开始时（时间 $=0$）站在 $(0, 0)$。每一关结束后，你想知道如果你玩得最优，这一关你最多能击碎多少只丧尸。

## 说明/提示

**限制条件**

- $1 \leq T \leq 100$
- $-1000 \leq X_i, Y_i \leq 1000$
- $0 \leq M_i \leq 100000000 = 10^8$
- 任意时刻同一格子不会有两只丧尸。换言之，如果某只丧尸在 $(x, y)$ 的 $t$ 时刻出现，则其他在 $(x, y)$ 出现的丧尸要么出现在 $t-1001$ 及更早，要么出现在 $t+1001$ 及更晚。

**测试集 1（7 分，结果可见）**

- $1 \leq Z \leq 8$

**测试集 2（18 分，结果隐藏）**

- $1 \leq Z \leq 100$

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
3
4
1 0 0
-1 0 0
10 10 1000
10 -10 1000
3
1 1 0
2 2 0
3 3 0
5
10 10 1000
-10 10 1000
10 -10 1000
-10 -10 1000
20 20 2000```

### 输出

```
Case #1: 3
Case #2: 2
Case #3: 2```

# AI分析结果

# 💡 Kay的C++算法解析：Zombie Smash 深入学习指南 💡

<introduction>
今天我们来一起分析Google Code Jam 2012 Finals的题目“Zombie Smash”。这道题需要我们在时间约束下规划移动路径，最大化击杀僵尸的数量。本指南会帮你理清思路、掌握核心算法，并通过像素动画直观理解过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：状态空间搜索（属于“搜索”大类下的**带约束状态扩展**）

🗣️ **初步分析**：
解决这道题的关键，就像“带着冷却时间的‘僵尸猎人闯关’——每击杀一只僵尸后，你需要等一会儿才能再次攻击，同时必须在僵尸出现的1000ms窗口内到达它的位置。我们可以把每一次击杀后的状态（比如“刚在A点杀了僵尸，现在时间是T，已经杀了K只”）看成一个“关卡节点”，然后从这些节点出发，尝试去杀下一只僵尸——这就是**状态空间搜索**的核心：遍历所有可能的“闯关路径”，找到杀最多僵尸的那条。

在本题中，状态搜索的**核心逻辑**是：
1. **状态定义**：记录最近一次击杀的僵尸（或起点）、当前时间、击杀数——这三个信息能帮我们计算下一次移动的时间和是否能杀下一只僵尸。
2. **时间计算**：从当前状态到下一只僵尸的时间 = **max(移动时间, 冷却时间)**（移动时间是切比雪夫距离×100ms，冷却时间固定750ms）。
3. **窗口判断**：到达下一只僵尸的时间必须在它的“出现窗口”（M到M+1000ms）内，否则无法击杀。

**可视化设计思路**：我们会用**8位像素风**还原游戏场景——像素小人从(0,0)出发，每只僵尸是闪烁的红色像素块，移动时显示黄色路径，击杀时僵尸会“爆碎”并播放“叮”的音效，冷却时间用紫色进度条显示。队列里的状态会以右侧的像素块堆动态展示，帮你直观看到“哪些状态还在等待扩展”。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选出一份优质题解（作者：tuxiaolai，洛谷AC），它的设计非常贴合核心逻辑，适合大家学习。
</eval_intro>

**题解一：来源：tuxiaolai（洛谷AC）**
* **点评**：这份题解的“状态定义”堪称画龙点睛——用`status`结构体记录“最近击杀的僵尸编号、当前时间、击杀数”，直接抓住了问题的核心约束（冷却时间、时间窗口）。代码里的`max(dis*100, 750)`完美处理了“移动和冷却谁更长”的问题，`max(当前时间+移动冷却, 僵尸出现时间)`则精准判断了是否在窗口内。更聪明的是，它用`st`数组保存每个僵尸的“最优状态”（击杀数最多、时间最早），避免了重复处理更差的状态，效率很高。代码风格也很规范，变量名`zb`（僵尸）、`dis`（距离）一看就懂，新手也能快速跟上思路！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在**时间约束的处理**和**状态的最优性**。我们逐一拆解：
</difficulty_intro>

1. **难点1：为什么状态要记录“最近击杀的僵尸”？**
    * **分析**：冷却时间是从“上一次击杀”开始算的——如果你刚在A点杀了僵尸，想杀B点的僵尸，必须等750ms（或移动到B点的时间更长）。如果不记录上一次的位置，根本算不清冷却时间！
    * **解决方案**：把“最近击杀的僵尸编号”放进状态（比如`status.i`），这样用`dis(zb[u.i], zb[i])`就能算出两点间的移动时间。

2. **难点2：冷却时间和移动时间怎么合并计算？**
    * **分析**：假设你从A到B要走300ms，但冷却要750ms——这时候你得等冷却结束才能杀B；如果走1000ms，那冷却早就结束了，直接杀就行。
    * **解决方案**：用`max(移动时间, 冷却时间)`！代码里的`nowdis = u.i==0 ? dis*100 : max(dis*100, 750)`就是这个逻辑（起点没有冷却，所以直接算移动时间）。

3. **难点3：如何确保到达时僵尸还在？**
    * **分析**：僵尸只在M到M+1000ms存在。如果你来早了，得等它出现；来晚了，它已经消失了。
    * **解决方案**：计算到达时间时取`max(当前时间+移动冷却, M)`，再判断是否≤M+1000。比如代码里的`nowst.t = max(zb[i].m, u.t+nowdis)`，如果这个时间超过M+1000，就跳过这只僵尸。

### ✨ 解题技巧总结
- **状态抓核心**：遇到“带时间/冷却约束”的问题，状态要包含“最近一次的关键动作（如击杀）的位置和时间”。
- **时间取max/min**：处理“必须等待的情况”（比如冷却、僵尸未出现），用`max`；处理“必须赶在之前”（比如僵尸消失），用`min`。
- **最优状态剪枝**：用数组记录每个节点的“最优状态”（比如`st[i]`保存杀到i号僵尸时的最大击杀数和最早时间），避免重复处理更差的状态。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份完整的核心实现——它来自题解一，逻辑清晰，能帮你快速建立整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码是洛谷AC的核心实现，完美覆盖了状态搜索、时间计算、窗口判断的逻辑，适合直接学习。
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;

    int T, z, ans;
    struct Zb { int x, y, m; } zb[110]; // 僵尸：坐标(x,y)，出现时间m
    struct Status { 
        int i; // 最近击杀的僵尸编号（0表示起点）
        int t; // 当前时间
        int cnt; // 击杀数
        // 比较规则：击杀数多的优先，相同则时间早的优先
        bool operator<(const Status& other) const {
            return cnt == other.cnt ? t > other.t : cnt < other.cnt;
        }
    } st[110]; // st[i]：杀到i号僵尸的最优状态（cnt最多，t最早）

    // 计算切比雪夫距离
    int dis(Zb a, Zb b) { return max(abs(a.x - b.x), abs(a.y - b.y)); }

    void solve() {
        // 初始化：起点状态（i=0，t=0，cnt=0）
        for (int i = 0; i <= z; i++) st[i] = {i, 0, 0};
        queue<Status> q;
        q.push({0, 0, 0});

        while (!q.empty()) {
            Status u = q.front(); q.pop();
            ans = max(ans, u.cnt); // 更新最大击杀数

            // 尝试杀每一只未杀过的僵尸
            for (int i = 1; i <= z; i++) {
                if (i == u.i) continue; // 不能杀同一只是僵尸（题目保证同一位置不同时出现）

                // 计算从u到i的时间（移动+冷却）
                int move_time = dis(zb[u.i], zb[i]) * 100;
                int total_time = (u.i == 0) ? move_time : max(move_time, 750);
                int arrive_time = u.t + total_time;

                // 判断是否在僵尸i的出现窗口内
                if (arrive_time > zb[i].m + 1000) continue;
                arrive_time = max(arrive_time, zb[i].m); // 来早了等僵尸出现

                // 新状态：杀i号僵尸后的状态
                Status new_st = {i, arrive_time, u.cnt + 1};
                // 如果新状态比st[i]更优（cnt更多，或cnt相同但t更早），则更新
                if (new_st < st[i]) continue;
                st[i] = new_st;
                q.push(new_st);
            }
        }
    }

    int main() {
        ios::sync_with_stdio(false); cin.tie(0);
        cin >> T;
        for (int case_id = 1; case_id <= T; case_id++) {
            ans = 0;
            cin >> z;
            zb[0] = {0, 0, 0}; // 起点（i=0）
            for (int i = 1; i <= z; i++) {
                cin >> zb[i].x >> zb[i].y >> zb[i].m;
            }
            solve();
            cout << "Case #" << case_id << ": " << ans << '\n';
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. **输入处理**：读取测试用例数T，每个用例读取僵尸数量z和每只僵尸的坐标、出现时间。
    > 2. **状态初始化**：`st`数组保存每个僵尸的最优状态（起点i=0，时间0，击杀数0）。
    > 3. **状态扩展**：用队列遍历所有状态，计算从当前状态到下一只僵尸的时间，判断是否在窗口内，生成新状态并更新`st`数组。
    > 4. **结果输出**：遍历所有状态，取最大击杀数作为答案。

---

<code_intro_selected>
接下来看题解中的**核心片段**——它集中体现了“状态扩展”的逻辑，是整个算法的灵魂。
</code_intro_selected>

**题解一：来源：tuxiaolai**
* **亮点**：用`st`数组保存每个僵尸的“最优状态”，避免重复处理更差的状态，大大提高效率。
* **核心代码片段**：
    ```cpp
    struct Status { 
        int i; int t; int cnt;
        bool operator<(const Status& other) const {
            return cnt == other.cnt ? t > other.t : cnt < other.cnt;
        }
    } st[110];

    void solve() {
        queue<Status> q;
        q.push({0, 0, 0});
        while (!q.empty()) {
            Status u = q.front(); q.pop();
            ans = max(ans, u.cnt);
            for (int i = 1; i <= z; i++) {
                if (i == u.i) continue;
                int move_time = dis(zb[u.i], zb[i]) * 100;
                int total_time = (u.i == 0) ? move_time : max(move_time, 750);
                int arrive_time = u.t + total_time;
                if (arrive_time > zb[i].m + 1000) continue;
                arrive_time = max(arrive_time, zb[i].m);
                Status new_st = {i, arrive_time, u.cnt + 1};
                if (new_st < st[i]) continue;
                st[i] = new_st;
                q.push(new_st);
            }
        }
    }
    ```
* **代码解读**：
    > 1. **Status结构体**：`i`是最近击杀的僵尸编号，`t`是当前时间，`cnt`是击杀数。`operator<`定义了“更优状态”的规则——击杀数越多越好，相同则时间越早越好。
    > 2. **队列初始化**：从起点（i=0，t=0，cnt=0）开始搜索。
    > 3. **状态扩展**：遍历每一只未杀过的僵尸i：
    >    - 计算`move_time`（切比雪夫距离×100ms），`total_time`（取移动时间和冷却时间的最大值，起点无冷却）。
    >    - 计算`arrive_time`（当前时间+总时间），如果超过僵尸i的窗口（m+1000），跳过。
    >    - 调整`arrive_time`：如果来早了，等僵尸出现（取max(arrive_time, m)）。
    >    - 生成新状态`new_st`，如果比`st[i]`更优（击杀数更多或时间更早），则更新`st[i]`并加入队列。
* 💡 **学习笔记**：`st`数组是“剪枝”的关键——它确保我们只处理“更优的状态”，避免重复计算那些“击杀数更少、时间更晚”的无效状态，大大减少了运行时间！


## 5. 算法可视化：像素动画演示方案

<visualization_intro>
我们设计了一个**8位像素风的互动动画**，像玩FC游戏一样学算法！你可以单步执行看每一步的变化，也能让AI自动演示“最优击杀路径”。
</visualization_intro>

### 🌠 动画主题：像素猎人打僵尸
**核心演示内容**：展示“状态搜索”的全过程——从起点出发，扩展状态，击杀僵尸，更新队列。

### 🎮 设计细节（融合复古游戏元素）
1. **场景初始化**：
   - 屏幕左侧是**像素网格地图**（800×600像素），(0,0)是绿色起点，每只僵尸是闪烁的红色像素块（下方显示它的“出现时间”）。
   - 右侧是**状态队列区**：用堆叠的蓝色像素块显示队列里的状态（每个块上标有“i:僵尸编号，t:时间，cnt:击杀数”）。
   - 底部是**控制面板**：有“开始/暂停”“单步”“重置”按钮，速度滑块（1×到5×），还有“AI自动演示”开关。
   - 背景音乐：8位风格的《吃豆人》循环BGM，轻松又复古！

2. **动画步骤**：
   - **启动**：点击“开始”，像素小人从(0,0)走出，队列区出现第一个状态块（i=0，t=0，cnt=0）。
   - **移动演示**：选择一只僵尸（比如i=1），小人会沿切比雪夫路径移动（黄色像素块标记），移动时播放“踏踏踏”的音效。
   - **击杀演示**：到达僵尸位置后，僵尸会“爆碎”成白色像素点，播放“叮”的音效，冷却时间用紫色进度条显示（从0到750ms）。
   - **状态更新**：新状态块（i=1，t=xxx，cnt=1）会加入队列区，旧状态块从队列头部消失。
   - **AI自动演示**：打开“AI自动演示”，小人会自动选择“击杀数最多”的路径，像“贪吃蛇AI”一样闯关，每杀一只僵尸就播放“胜利”音效！

3. **交互设计**：
   - **单步执行**：点击“单步”，动画走一步，当前操作的代码行（比如`arrive_time = max(...)`）会高亮显示。
   - **速度调整**：用滑块调节动画速度，最慢1秒一步，最快0.1秒一步。
   - **重置**：点击“重置”，回到初始状态，重新开始演示。

4. **音效设计**：
   - 移动：“踏”（每步一次）。
   - 击杀：“叮”（上扬音调）。
   - 冷却完成：“滴”（短促提示）。
   - 完成所有击杀：“胜利”音效（类似FC游戏的通关音乐）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心是“带时间约束的状态搜索”，类似的问题还有很多，比如旅行商问题（TSP）、带时间窗的路径规划，我们推荐3道洛谷题巩固思路：
</similar_problems_intro>

1. **洛谷 P1135 奇怪的电梯**：
   - 🗣️ **推荐理由**：同样需要“状态搜索”（每层是一个状态），考察“如何处理约束（电梯只能上下固定层数）”，能帮你巩固“状态定义”的思路。
   
2. **洛谷 P1339 热浪**：
   - 🗣️ **推荐理由**：最短路径问题，但需要处理“边权”（时间），类似本题的“移动时间”计算，能帮你练习“时间约束的累加”。

3. **洛谷 P2532 [AHOI2012] 树屋阶梯**：
   - 🗣️ **推荐理由**：带约束的计数问题，需要用“状态转移”记录每一步的最优解，类似本题的“st数组”剪枝，能帮你深化“最优状态”的理解。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解作者没有明确写心得，但从代码的设计能看出他的思考：
</insights_intro>

> **参考经验（来自代码设计）**：作者用`st`数组保存“最优状态”，避免了重复处理——这说明“剪枝”是状态搜索的关键！如果不剪枝，队列会被大量无效状态填满，运行时间会翻倍。
> **点评**：新手常犯的错误是“不剪枝”，导致程序超时。这道题的`st`数组告诉我们：**状态搜索时，一定要记录“最优状态”，避免做无用功**！


<conclusion>
这道题的核心是“用状态搜索处理时间约束”——状态定义要抓核心（最近击杀的僵尸、时间、击杀数），时间计算要处理冷却和窗口，剪枝要靠“最优状态”。希望这份指南能帮你理清思路，下次遇到类似的“带约束搜索”问题，能快速想到“状态定义+剪枝”的解法！

编程的乐趣在于“解决约束中的问题”，就像打僵尸一样——每解决一个难点，你就离“通关”更近一步！下次我们再一起挑战更难的问题！💪
</conclusion>

---
处理用时：137.43秒
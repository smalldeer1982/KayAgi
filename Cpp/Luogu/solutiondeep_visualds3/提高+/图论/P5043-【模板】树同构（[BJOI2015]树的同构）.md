# 题目信息

# 【模板】树同构（[BJOI2015]树的同构）

## 题目描述

树是一种很常见的数据结构。

我们把 $N$ 个点，$N-1$ 条边的连通无向图称为树。

若将某个点作为根，从根开始遍历，则其它的点都有一个前驱，这个树就成为有根树。

对于两个树 $T_1$ 和 $T_2$，如果能够把树 $T_1$ 的所有点重新标号，使得树 $T_1$ 和树 $T_2$ 完全相同，那么这两个树是同构的。也就是说，它们具有相同的形态。

现在，给你 $M$ 个无根树，请你把它们按同构关系分成若干个等价类。

## 说明/提示

编号为 $1, 2, 4$ 的树是同构的。编号为 $3$ 的树只与它自身同构。

对于 $100\%$ 的数据，$1\leq N,M\leq 50$。

## 样例 #1

### 输入

```
4 
4 0 1 1 2 
4 2 0 2 3 
4 0 1 1 1 
4 0 1 2 3 ```

### 输出

```
1 
1 
3 
1 ```

# AI分析结果


### 💡 Kay的C++算法解析：树同构 深入学习指南 💡

#### 1. 题目解读与核心算法识别  
✨ **本题主要考察**：树哈希与重心分解  

🗣️ **初步分析**：  
> 树同构问题要求判断多棵树的结构是否相同（可通过重标号使结构完全一致）。核心思路是将无根树转化为有根树进行处理：  
> - **重心分解**：树的重心是删除后最大连通块最小的节点（最多两个），同构树的重心位置相同。  
> - **树哈希**：以重心为根计算哈希值，通过递归合并子树哈希（排序消除顺序影响），生成唯一标识。  
>  
> **可视化设计**：  
> - 像素动画以重心（红色方块）为起点，DFS遍历时高亮当前节点，子树哈希计算过程用不同颜色区分。  
> - 排序子树时展示冒泡动画，合并时显示算术运算特效。音效设计：节点访问（滴答声）、排序（交换声）、完成（胜利音效）。  
> - 复古游戏风格：8位像素网格，AI自动演示模式可调速，通关时播放胜利BGM。  

---

#### 2. 精选优质题解参考  
**题解一（zhoukangyang）**  
* **点评**：  
  思路清晰，重心分解与哈希结合完美。代码规范（变量名`f[i]`、`sav`含义明确），哈希设计通过排序子树和质数乘法避免冲突。亮点是哈希合并时引入子树大小权重，提升区分度。复杂度O(mn log n)，作者强调排序是瓶颈，建议基数排序优化。  

**题解二（ix35）**  
* **点评**：  
  最小表示法实现优雅，将树结构转为括号序列并排序。重心处理严谨，双重心时取字典序最小值。代码可读性强（递归生成括号序列），复杂度O(mn²)但常数小。亮点是正确性证明充分，适合理解同构本质。  

**题解三（hyfhaha）**  
* **点评**：  
  简洁的暴力哈希，枚举所有点为根计算哈希值。代码简短易学（递归排序合并），适合初学者。虽理论冲突风险存在，但实际可通过。实践价值高，直接用于竞赛需注意双哈希提升安全性。  

---

#### 3. 核心难点辨析与解题策略  
1. **难点：无根树转化**  
   * **分析**：同构与根选择无关，需固定参考点。重心具唯一性（同构树重心数相同），通过DFS计算子树大小并求解最大子树最小化。  
   * 💡 **学习笔记**：重心是优化无根树问题的关键锚点。  

2. **难点：哈希冲突避免**  
   * **分析**：设计抗冲突哈希需满足：同构树必同值、不同构树尽量不同。优质题解共通策略：  
     - 子树哈希值排序（消除顺序影响）  
     - 引入质数权重（如`prime[size]`）  
     - 双哈希（如zhoukangyang的`mod`+`G`）  
   * 💡 **学习笔记**：哈希合并时排序和质数乘法是黄金组合。  

3. **难点：效率优化**  
   * **分析**：每棵树暴力枚举根需O(n²)，重心将根候选降至O(1)。比较时先排序哈希值，避免全对全比较。  
   * 💡 **学习笔记**：重心分解将无根树问题转化为常数个有根树问题。  

### ✨ 解题技巧总结  
- **重心定位**：DFS求子树大小，`max(subtree, n-subtree)`最小点即重心。  
- **哈希设计**：递归中排序子树哈希，按`hash_child * prime[size]`合并。  
- **比较优化**：双重心时存储两个哈希值，比较时取序（如`min(hash1, hash2)`）。  

---

#### 4. C++核心代码实现赏析  
**通用核心实现（综合优化版）**  
```cpp
#include <vector>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
const int N = 55, MOD = 1e9+7, G = 131;

struct Tree { ull h1, h2; }; // 双哈希值
vector<int> g[N];
int sz[N], n;

// 找重心（返回重心列表）
vector<int> get_centroids(int u, int fa) {
    sz[u] = 1; int max_sub = 0;
    vector<int> cents;
    for (int v : g[u]) {
        if (v == fa) continue;
        auto child_cents = get_centroids(v, u);
        sz[u] += sz[v];
        max_sub = max(max_sub, sz[v]);
        if (child_cents.size()) return child_cents;
    }
    max_sub = max(max_sub, n - sz[u]);
    if (max_sub <= n/2) cents.push_back(u);
    return cents;
}

// 计算哈希（排序子树）
ull tree_hash(int u, int fa) {
    sz[u] = 1;
    vector<ull> child_hashes;
    for (int v : g[u]) {
        if (v == fa) continue;
        child_hashes.push_back(tree_hash(v, u));
        sz[u] += sz[v];
    }
    sort(child_hashes.begin(), child_hashes.end());
    ull hash_val = 1;
    for (ull h : child_hashes) 
        hash_val = (hash_val * G + h) % MOD;
    return hash_val;
}

// 主函数处理多棵树
int main() {
    int m; cin >> m;
    vector<Tree> trees(m);
    for (int i = 0; i < m; ++i) {
        cin >> n;
        // 建图（省略）
        auto cents = get_centroids(1, -1);
        ull h1 = tree_hash(cents[0], -1), h2 = 0;
        if (cents.size() > 1) h2 = tree_hash(cents[1], -1);
        if (h1 > h2) swap(h1, h2);
        trees[i] = {h1, h2};
        // 比较逻辑（略）
    }
}
```

**代码解读概要**：  
1. 重心分解：递归计算子树大小，满足`max_sub <= n/2`即为重心。  
2. 树哈希：子树哈希值排序后，按`H = H * G + child_hash`合并（质数G=131）。  
3. 双重心处理：存储两个根的哈希值并排序，保证比较一致性。  

---

#### 5. 算法可视化：像素动画演示  
**主题**：像素探险家之树同构大冒险  

**设计实现**：  
1. **8位像素风格**：树节点为16x16像素方块，重心红色高亮，边为蓝色连线。  
2. **动画流程**：  
   - 初始化：网格展示树结构，重心闪烁标记。  
   - DFS过程：当前节点亮黄色，递归子树时绿色高亮扩散。  
   - 哈希计算：子树哈希值显示在节点上方（数字气泡），排序过程用冒泡动画（相邻值比较时黄色闪烁）。  
   - 合并展示：哈希值合并时显示`H = H * G + h`的像素算术特效。  
3. **交互控制**：  
   - 面板按钮：开始/暂停/单步/重置。  
   - 速度滑块：调整AI自动演示速度。  
   - 音效：节点访问（电子滴答）、排序交换（哔声）、完成（胜利和弦）。  
4. **游戏化**：  
   - 每棵子树处理作为小关卡，通关后像素星星闪烁+积分奖励。  
   - 失败场景：哈希冲突时播放警示音效。  

---

#### 6. 拓展练习与相似问题  
1. **相似问题**：  
   - 有根树同构（固定根）  
   - 子树同构（判断是否为子树）  
   - 带权树同构（边/节点权重）  
2. **洛谷推荐**：  
   - P4323 [JSOI2016] 独特的树叶：进阶哈希应用，需识别叶子特性。  
   - P5018 [NOIP2018] 对称二叉树：哈希判断对称性。  
   - P2590 [ZJOI2008] 树的统计：树结构处理基础。  

---

#### 7. 学习心得与经验分享  
> **作者心得摘录**：  
> - zhoukangyang：*"重心分解将无根树问题转化为常数级别根选择，排序子树哈希是关键优化。"*  
> - ix35：*"最小表示法本质是结构字典序，需严格证明括号序列与树结构双射。"*  
>  
> **Kay总结**：树同构解法丰富，重心是共性核心。哈希设计需兼顾效率与冲突率，建议先用简单哈希实现，再逐步优化。调试时打印中间哈希值，观察子树合并过程。

---  
**结语**：树同构是树算法的经典问题，重心分解与哈希的组合是通用解法。理解数据结构的本质比记忆代码更重要，动手实现可视化能深化认知！下次我们将探索图同构，继续挑战！🚀

---
处理用时：199.76秒
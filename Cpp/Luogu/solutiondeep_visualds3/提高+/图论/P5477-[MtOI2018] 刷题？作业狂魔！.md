# 题目信息

# [MtOI2018] 刷题？作业狂魔！

## 题目背景

在临听到暑假的尾声以后，神奇的 cz 终于发觉自己的作业不能完成了。

在他写完作业之前，你需要将他做作业的顺序告诉给他听，这样你们就可以一起玩了。  



## 题目描述

你拥有 $T$ 分钟的时间。

做作业的顺序可以根据重要度 $v_i$ 来排序，但可能这不是最佳方案。且每项作业可能不止有一项，所以每项作业还有一个数量 $c_i$，每项 $t_i$ 分钟可以完成。

而在做某作业之前可能要先写完某个作业，所以还给出 $M$ 个关系，每个关系包含两个数 $a$，$b$ ，代表 $a$ 是 $b$ 完成的前提，不存在 $a=b$ 的情况。

关系不排除环的情况，cz 不想重做一遍作业，只好不做在环上的作业。

当某作业做到一半但时间结束，则失去该作业重要度；当该作业只做了 $k$ 个，但 $k\leq c_i$ ,则得到 $k\times v_i$ 重要度 , 如果该作业没把 $c_i$ 个做完，则不得做其他作业。

可存在 $b$ 有多个 $a$，但请注意一个作业的 **一个** 前提被做了以后，该作业就可以被做了。但cz非常专注，他写完一个作业以后就必须写**以该作业为前提的**作业。

## 说明/提示

### 子任务

对于 $100\%$ 的数据，$1<=N<=10000,1<=M<=100000$

其他值均在$long long$范围内。


### 题目来源

[MtOI2018 迷途の家の水题大赛](https://www.luogu.org/contest/11260) T1

出题人：Doubleen

56432

## 样例 #1

### 输入

```
4 7
2 1 1
2 1 2
2 1 3
2 1 4
3
3 4
2 3
1 2```

### 输出

```
6```

# AI分析结果


# 💡 Kay的C++算法解析：[MtOI2018] 刷题？作业狂魔！ 深入学习指南 💡

<introduction>
今天我们来一起分析"刷题？作业狂魔！"这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（Tarjan/拓扑排序）` + `深度优先搜索（DFS）`

🗣️ **初步分析**：
> 解决这道题的关键在于**依赖关系处理**和**资源优化分配**。想象你是一位像素游戏中的探险家，每个作业是一个宝箱，开宝箱需要时间（t_i）和钥匙（前提作业）。环就像迷宫中的死循环区域（红色标记），必须避开。你要在有限时间（T）内开启宝箱获得最大金币（重要度）。
>
> - **核心思路**：先用Tarjan或拓扑排序标记环上作业（不可做），然后从入度为0的节点开始DFS遍历依赖图。对于每个作业，要么完整完成（消耗c_i×t_i时间，获得c_i×v_i重要度），要么部分完成（剩余时间不足时计算可完成的数量）。
> - **难点**：正确处理环检测、DFS状态传递和部分作业完成的边界条件。
> - **可视化设计**：像素动画中将用绿色方块表示可做作业，红色边框标记环。探险家（像素小人）移动到作业方块时显示进度条和时间消耗，完成时播放金币动画。关键变量（剩余时间、累计重要度）实时显示在侧边栏。

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性和算法有效性等维度，我为大家精选了以下优质题解：
</eval_intro>

**题解一：Doubleen（赞21）**
* **点评**：该题解采用Tarjan算法精准标记环上节点，逻辑清晰直白。代码中`dfn/low`数组实现强连通分量检测，`can[color]`过滤环上作业的设计简洁高效。DFS部分用值传递天然支持回溯，边界处理严谨（如`la>=c[u]*t[u]`判断部分完成）。变量命名规范（如`v/c/t`直接对应题目参数），整体实现可直接用于竞赛场景。

**题解二：Accepted3927（赞2）**
* **点评**：创新性地使用正反两次拓扑排序标记环，通过`rd/cd`数组统计出入度。亮点在于添加虚拟0号节点统一处理入度为0的起点，大幅简化DFS入口逻辑。代码中`f[i]`标记环的算法具有普适性，解释中关于"反图拓扑"的思考对理解环检测本质很有启发。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破以下三个关键难点，结合优质题解策略分析如下：
</difficulty_intro>

1.  **环的精准检测与处理**
    * **分析**：Tarjan通过`dfn/low`识别强连通分量（SCC），标记大小>1的SCC为环；拓扑法则用正反图遍历标记入度和出度均非零的节点。Doubleen的Tarjan实现中`can[color]`精准隔离环上作业，Accepted3927的双拓扑法则通过数学特性保证标记准确性。
    * 💡 **学习笔记**：环检测是处理依赖图的前提，Tarjan适合精确控制，拓扑排序更易理解。

2.  **DFS状态设计与资源分配**
    * **分析**：递归参数需包含当前节点、剩余时间和累计重要度。关键点在于：当剩余时间不足完成整个作业时，计算`(剩余时间/t_i)*v_i`获得部分重要度并终止该路径（题目要求未完成时不得做后续作业）。Doubleen的`dfs(u,s+c[u]*v[u],la-c[u]*t[u])`和部分计算逻辑是典范实现。
    * 💡 **学习笔记**：DFS时优先处理完整作业情况，部分完成作为递归边界条件。

3.  **多起点处理与虚拟节点**
    * **分析**：依赖图可能有多个入度为0的起点。Accepted3927创新性地引入0号虚拟节点连接所有起点，通过`dfs(0,0,0)`统一入口，避免重复代码。Doubleen则直接遍历所有`in[i]==0`的节点分别DFS。
    * 💡 **学习笔记**：虚拟节点是简化多入口图遍历的常用技巧。

### ✨ 解题技巧总结
<summary_best_practices>
解决此类问题的通用技巧：
</summary_best_practices>
- **拓扑与Tarjan的权衡**：精确环检测用Tarjan，快速判环用拓扑排序
- **DFS状态设计三要素**：当前节点、剩余时间、累计价值
- **虚拟节点技巧**：通过添加无实际意义的节点简化图结构
- **部分完成公式**：部分价值 = floor(剩余时间/t_i) × v_i

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解提炼的通用核心实现，包含Tarjan环检测和DFS资源分配：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合Doubleen的Tarjan实现和Accepted3927的虚拟节点技巧，优化DFS边界处理
* **完整核心代码**：
    ```cpp
    #include <vector>
    #include <stack>
    using namespace std;
    typedef long long ll;
    const int N = 10005;
    
    ll T, v[N], c[N], t[N], ans;
    vector<int> G[N]; // 邻接表存图
    bool inCycle[N];  // 环标记
    
    // Tarjan环检测（Doubleen方案优化）
    namespace Tarjan {
        int dfn[N], low[N], col[N], idx, scc;
        bool instk[N];
        stack<int> stk;
        
        void tarjan(int u) {
            dfn[u] = low[u] = ++idx;
            stk.push(u); instk[u] = true;
            for(int v : G[u]) {
                if(!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
                else if(instk[v]) low[u] = min(low[u], dfn[v]);
            }
            if(low[u] == dfn[u]) {
                int cnt = 0, x;
                do {
                    x = stk.top(); stk.pop();
                    instk[x] = false;
                    col[x] = scc;
                    cnt++;
                } while(x != u);
                if(cnt > 1) // 标记大小>1的SCC为环
                    for(int i=1; i<=n; i++)
                        if(col[i] == scc) inCycle[i] = true;
                scc++;
            }
        }
    }
    
    // DFS资源分配（含部分完成逻辑）
    void dfs(int u, ll curT, ll curVal) {
        if(curT < t[u]) { // 时间不足做任何部分
            ans = max(ans, curVal);
            return;
        }
        ll needT = c[u] * t[u];
        if(curT >= needT) { // 完整完成
            curVal += c[u] * v[u];
            curT -= needT;
            ans = max(ans, curVal);
            for(int v : G[u])
                if(!inCycle[v]) dfs(v, curT, curVal);
        } else { // 部分完成
            ll num = curT / t[u];
            ans = max(ans, curVal + num * v[u]);
        }
    }
    
    int main() {
        // 读入数据+建图
        // 虚拟0号节点连接所有起点（Accepted3927技巧）
        for(int i=1; i<=n; i++)
            if(in[i]==0) G[0].push_back(i);
        
        Tarjan::tarjan(0);
        dfs(0, T, 0);
        cout << ans;
    }
    ```
* **代码解读概要**：
    > 代码分为三大模块：(1)Tarjan实现强连通分量检测，对大小>1的SCC标记为环；(2)DFS遍历依赖图，根据剩余时间决定完整/部分完成作业；(3)虚拟0号节点统一处理起点，避免多入口遍历。

---
<code_intro_selected>
优质题解核心片段精析：
</code_intro_selected>

**题解一：Doubleen（Tarjan+DFS）**
* **亮点**：精确的Tarjan SCC检测配合简洁的DFS资源分配
* **核心代码片段**：
    ```cpp
    void tarjan(ll x) {
        dfn[x] = low[x] = ++tot;
        sta[++top] = x; vis[x] = true;
        for(/*遍历邻接点*/) {
            if(!dfn[u]) tarjan(u), low[x]=min(low[x],low[u]);
            else if(vis[u]) low[x]=min(low[x],dfn[u]);
        }
        if(dfn[x]==low[x]) {
            ll jsq=1; // 统计SCC大小
            while(sta[top]!=x) { jsq++; /*...*/ }
            if(jsq>1) can[sum]=true; // 标记环
        }
    }
    ```
* **代码解读**：
    > Tarjan的核心在于`dfn/low`时间戳：`dfn`记录首次访问时间，`low`记录可达的最早节点时间戳。当`dfn[x]==low[x]`时，栈中从x到栈顶的节点构成强连通分量。Doubleen用`jsq>1`精准标记大小>1的SCC为环，避免误判单点。
* 💡 **学习笔记**：Tarjan的`low`更新规则是算法核心：`low[x]=min(low[x],dfn[v])`保证不回绕到不同分支。

**题解二：Accepted3927（双拓扑+虚拟节点）**
* **亮点**：正反图拓扑实现非侵入式环检测
* **核心代码片段**：
    ```cpp
    void tpst(){
        // 正图拓扑
        for(int i=1;i<=n;i++) if(rd[i]==0) q.push(i);
        while(!q.empty()){ /*...*/ }
        
        // 反图拓扑
        for(int i=1;i<=n;i++) if(cd[i]==0) q.push(i);
        while(!q.empty()){ /*...*/ }
        
        // 标记环（rd>0且cd>0）
        for(int i=1;i<=n;i++) 
            if(rd[i]>0 && cd[i]>0) f[i]=1; 
    }
    ```
* **代码解读**：
    > 该实现通过两次拓扑排序：正图（原图）删除入度为0的节点，反图删除出度为0的节点。数学上，环内节点因依赖闭环特性，正图拓扑后入度非零，反图拓扑后出度非零，故`rd>0 && cd>0`可精准定位环上节点。这种非递归方式避免Tarjan的深度递归栈溢出风险。
* 💡 **学习笔记**：拓扑排序判环的本质是"环内节点永不被删除"。

-----

## 5. 算法可视化：像素动画演示

<visualization_intro>
为直观理解环检测与DFS过程，设计复古像素风动画方案，让你化身探险家收集作业宝藏！
</visualization_intro>

* **动画主题**：*作业岛大冒险*（8-bit像素风格，FC游戏视觉）
* **核心演示**：Tarjan环检测过程 + DFS资源分配路径
* **设计思路**：用不同颜色区块区分作业状态，探险家移动强化路径选择感知。音效反馈关键操作，进度条直观显示时间消耗。

* **动画帧步骤**：
    1. **场景初始化**：
        - 16色像素网格岛：绿色区块=可做作业，红色边框=环，灰色=已完成
        - 控制面板：开始/暂停、单步执行、速度滑块（0.5x-2x）
        - 信息栏：剩余时间(🕒)、累计重要度(💰)

    2. **环检测阶段（Tarjan执行）**：
        - 像素岛亮起蓝色扫描波（类似雷达动画），从起点扩散
        - 发现环时播放"error"音效，相关区块变红边框
        - 侧边栏同步显示伪代码：`if(dfn[u]==low[u] && scc_size>1) mark_red()`

    3. **DFS探险阶段**：
        - 探险家（像素小人）从绿色起点出发，移动时播放脚步声
        - 到达作业点：显示进度条动画（时间消耗），完成时播放"coin"音效+金币飞入计数区
        - 关键决策点：
            - 时间充足：进度条满后自动跳转下一节点
            - 时间不足：显示`部分完成=(T_remain/t_i)*v_i`公式，播放"warning"音效

    4. **自动演示模式**：
        - 开启后探险家自动选择DFS路径，类似贪吃蛇AI寻路
        - 可调速观察不同决策结果，最优路径显示金色轨迹

    5. **游戏化元素**：
        - 每完成一条无环路径获得"知识宝石"💎
        - 环检测阶段发现环时解锁"迷宫破解者"成就
        - 背景音乐：8-bit循环BGM（紧张感适中）

* **技术实现**：
    - Canvas分层渲染：背景网格层、作业区块层、角色动画层
    - 音效触发：Web Audio API播放基波合成的8-bit音效
    - 状态同步：当前代码行高亮+变量值实时更新

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的图遍历与资源分配思想后，可挑战以下相似问题：
</similar_problems_intro>

* **通用技巧迁移**：
  - 拓扑/Tarjan判环 → 任何依赖关系验证场景
  - DFS资源分配 → 背包问题变种
  - 虚拟节点 → 多源BFS/DFS统一入口

* **练习推荐（洛谷）**：
  1. **P1347 排序**（拓扑排序经典应用）
     * 🗣️ **推荐理由**：巩固拓扑排序判环技巧，理解偏序关系处理
  2. **P2196 挖地雷**（DAG上的DFS+最优路径）
     * 🗣️ **推荐理由**：类似本题的资源分配思路，无环图简化问题
  3. **P1273 有线电视网**（树形DP+资源分配）
     * 🗣️ **推荐理由**：将本题的线性DFS扩展到树形结构，强化状态设计能力

-----

<conclusion>
本次"刷题？作业狂魔！"的解析就到这里。记住：图论问题核心在于**结构分析**与**状态设计**，多动手模拟动画中的像素探险过程，你会对DFS和环检测有更直观的理解。下次遇到依赖关系问题，记得用Tarjan或拓扑排序武装自己！🚀
</conclusion>

-----

---
处理用时：274.17秒
# 题目信息

# 『MdOI R2』Odyssey

## 题目背景

超越音速的极限，不及瑰丽多变的极光；

微弱的脉冲，开拓原本一片混沌的天地；

沉郁的蓝缓缓闪动，史诗的红迎接巅峰；

血色的夕阳尽头，是将夜的星辰；

夜半的满天星空，也会被来自地狱的硝烟掩盖；

炽红炼狱消逝，只金色遗迹永存。

在这里等待着每一位的，都是一段艰苦而璀璨的旅程。

## 题目描述

若正整数 $a$ 与 $b$ 满足：

- $a$ 与 $b$ 的积是一个正整数的 $k$ 次方，即存在正整数 $c$ 使得 $ab=c^k$。

那么我们称 $(a,b)$ 为一组**完美数对**。

---

有一个包含 $n$ 个结点和 $m$ 条边的**有向无环图**，这张图中的每条边都有权值和长度两个属性。

如果一条路径 $P$ 满足**以下条件之一**，则称其为一条**完美路径**：

- $P$ 中仅包含一条边。

- $P$ 从其起点开始依次为 $e_1, e_2, e_3, \ldots e_p$ 这 $p\ (p\ge 2)$ 条边，对于任意的 $1\leq i\leq p-1$，$e_i$ 的权值和 $e_{i+1}$ 的权值组成完美数对。

你需要求出图中最长完美路径的长度，一条路径的长度定义为这条路径上所有边的长度之和。

## 说明/提示

【帮助与提示】  

为方便选手测试代码，本题额外提供两组附加样例供选手使用。  

[样例输入1](https://www.luogu.com.cn/paste/wx1lz6m2) [样例输出1](https://www.luogu.com.cn/paste/28xe7f0x)      

[样例输入2](https://www.luogu.com.cn/paste/efgwngs5) [样例输出2](https://www.luogu.com.cn/paste/5hcpoayt)   

----

【样例解释】

样例中给出的有向无环图如图所示，其中边上的红色数字为边的权值，黑色数字为边的长度：

![](https://cdn.luogu.com.cn/upload/image_hosting/w6x03ksd.png)

最长完美路径为 $2\to 5\to 3$，因为这两条边的权值 $2$ 和 $18$ 满足 $2\times 18=6^2$，是完美数对，此路径长度为 $5+9=14$。

此外，$2\to 1\to 4\to 3,\ \ 2\to 4\to 3,\ \ 1\to 5\to 3$ 等也是完美路径，但不是最长的。

图中，$2\to 1\to 5\to 3$ 长度为 $15$，是一条更长的路径，但它并不是完美路径，因为前两个边权 $24$ 和 $8$ 的乘积为 $192$，不是正整数的平方，即 $(24,8)$ 不是完美数对。

---

【数据范围】

**本题采用捆绑测试。**

对于 $100\%$ 的数据：$1\leq n\leq 10^5,\ \ 1\leq m\leq 2\times 10^5,\ \ 1\leq k\leq 10,\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^5,\ \ 1\leq l\leq 10^4$。

给出的图**不保证弱连通**，图中从一个点到另一个点**可能**存在多条边，但保证给出的图是有向无环图。

| 子任务编号 | $n\leq$ |     $m\leq$      | $w\leq$ | $k\leq$ |  特殊性质  | 分值 |
| :--------: | :-----: | :--------------: | :-----: | :-----: | :--------: | :--: |
| Subtask 1  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $1$   |     无     | $18$ |
| Subtask 2  |  $10$   |       $10$       |  $100$  |  $2$   |     无     | $12$ |
| Subtask 3  |  $600$  | $1.5\times 10^3$ | $10^3$  |   $2$   |     无     | $10$ |
| Subtask 4  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   | $w$ 为素数 | $15$ |
| Subtask 5  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   |     无     | $15$ |
| Subtask 6  |  $600$  | $1.5\times 10^3$ | $10^3$  |  $5$   |     无     | $10$ |
| Subtask 7  | $10^5$  |  $2\times 10^5$  | $10^5$  |  $10$   |     无     | $20$ |



## 样例 #1

### 输入

```
5 7 2
2 5 2 5
5 3 18 9
2 4 6 7
4 3 6 3
2 1 24 2
1 4 6 8
1 5 8 4```

### 输出

```
14```

# AI分析结果


# 💡 Kay的C++算法解析：『MdOI R2』Odyssey 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（DAG动态规划）` + `数论（质因数分解）`

🗣️ **初步分析**：
> 解决这道题的关键在于将完美数对的条件转化为数论问题，并在有向无环图（DAG）上动态规划。想象每条边的权值是一个密码箱，质因数分解就是打开箱子的钥匙——我们把指数对k取模得到简化权值（如将$2^4$在k=3时简化为$2^1$），而每个简化权值都有唯一的配对钥匙（如$2^1$的配对是$2^2$）。在图中走完美路径，就是不断用当前钥匙打开下一条边的密码箱的过程。

- 核心思路：对每条边权值质因数分解 → 指数模k得到简化权值 → 计算唯一配对权值 → 在DAG上DP（当前边简化权值必须匹配上条边的配对权值）
- 可视化设计：在像素动画中，边权显示为密码箱图标，简化/配对权值显示为钥匙图标。DP转移时，匹配成功则播放“咔嚓”开锁音效并高亮路径，否则显示“锁死”动画。采用8-bit风格，节点设计为像素城堡，路径探索如同闯关游戏。

---

## 2. 精选优质题解参考

### 题解一（作者：BFqwq）
* **点评**：
  思路清晰度 ⭐⭐⭐⭐⭐：独创分层图拓扑法，节点复制技巧（u→u+n）确保权值交替匹配，逻辑严密如齿轮咬合。  
  代码规范性 ⭐⭐⭐⭐：模块化设计（质数筛、分解函数独立），变量名`f[i]`含义明确，但数组开小曾导致WA需警惕。  
  算法有效性 ⭐⭐⭐⭐⭐：时间复杂度O(mlogw)，空间优化到位，分层图避免状态冲突是点睛之笔。  
  实践价值 ⭐⭐⭐⭐：竞赛适用性强，调试心得“数组开小=前功尽弃”极具警示意义。

### 题解二（作者：一扶苏一）
* **点评**：
  思路清晰度 ⭐⭐⭐⭐：双哈希防冲突策略稳健，状态定义`f[u][hash]`精准如狙击瞄准。  
  代码规范性 ⭐⭐⭐⭐⭐：命名空间封装避免污染，分解/哈希/拓扑三模块泾渭分明。  
  算法有效性 ⭐⭐⭐⭐：O(m log m)复杂度可靠，但map稍重可能卡常。  
  实践价值 ⭐⭐⭐⭐：工业级代码规范，适合作为工程化实现的范本。

### 题解三（作者：zzqDeco）
* **点评**：
  思路清晰度 ⭐⭐⭐⭐：unordered_map省去哈希设计，专注问题本质，大质数溢出处理干净利落。  
  代码规范性 ⭐⭐⭐⭐：60行简洁实现，拓扑与DP熔于一炉，k=1特判巧妙。  
  算法有效性 ⭐⭐⭐⭐：时间复杂度同阶，代码短小精悍适合快速实现。  
  实践价值 ⭐⭐⭐⭐⭐：赛场应急首选，作者“大质数需特殊处理”的经验直击痛点。

---

## 3. 核心难点辨析与解题策略

1. **难点：权值配对的数学转换**  
   *分析*：质因数分解时需处理指数模k与配对计算。当配对权值>1e5时，该边只能作为路径终点（如k=3时w=5的配对是25>1e5？× → 实际需计算5²=25）。  
   💡 **学习笔记**：配对值溢出时标记-1，DP中直接作为终止状态。

2. **难点：状态爆炸的存储**  
   *分析*：简化权值可能很大，直接开数组不现实。优质题解用map/unordered_map实现动态状态存储，空间复杂度O(m)。  
   💡 **学习笔记**：STL容器是处理稀疏状态的瑞士军刀。

3. **难点：DAG上的状态转移**  
   *分析*：拓扑序确保无后效性，但需注意：当前边权w1需匹配上条边的配对权值（即`dp[v][w1] = max(dp[u][pair_w] + l)`）。  
   💡 **学习笔记**：DP状态定义中“最后一条边的简化权值”是转移枢纽。

### ✨ 解题技巧总结
- **问题分解术**：拆解为①数论转换②图论DP两阶段，先解决`calcPaired()`再攻拓扑  
- **容器选择诀**：状态少用unordered_map，防卡常用双哈希  
- **边界屠龙技**：k=1时所有边自动匹配，配对计算直接跳过  

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**（综合自BFqwq与zzqDeco思路优化）：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

const int MAXN = 1e5+5;
struct Edge { int to, w, l, w1, w2; }; // w1:简化权值 w2:配对权值
vector<Edge> G[MAXN];
int inDegree[MAXN];
unordered_map<int, int> dp[MAXN]; // dp[i][w1]：在i点以w1结尾的最大长度

int calcSimplified(int w, int k) {
    int res = 1;
    for (int i = 2; i*i <= w; i++) {
        int cnt = 0;
        while (w % i == 0) w /= i, cnt++;
        cnt %= k;
        while (cnt--) res *= i;
    }
    if (w > 1 && k != 1) res *= w; // k=1时res恒为1
    return res;
}

int calcPaired(int w, int k) {
    if (k == 1) return 1; // 特判
    int res = 1;
    for (int i = 2; i*i <= w; i++) {
        int cnt = 0;
        while (w % i == 0) w /= i, cnt++;
        cnt %= k;
        if (cnt) {
            cnt = k - cnt;
            while (cnt--) {
                res *= i;
                if (res > 1e5) return -1; // 溢出标记
            }
        }
    }
    if (w > 1) {
        int cnt = k - 1;
        while (cnt--) {
            res *= w;
            if (res > 1e5) return -1;
        }
    }
    return res;
}

int main() {
    int n, m, k; cin >> n >> m >> k;
    // 建图与预处理
    for (int i = 0; i < m; i++) {
        int u, v, w, l; cin >> u >> v >> w >> l;
        int w1 = calcSimplified(w, k);
        int w2 = calcPaired(w, k);
        G[u].push_back({v, w, l, w1, w2});
        inDegree[v]++;
    }
    // 拓扑排序 + DP
    queue<int> q;
    for (int i = 1; i <= n; i++) 
        if (inDegree[i] == 0) q.push(i);
    
    int ans = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto &e : G[u]) {
            // 关键转移：需匹配上条边的配对权值
            int newVal = (e.w2 != -1 && dp[u].count(e.w2)) ? 
                         dp[u][e.w2] + e.l : e.l;
            dp[e.to][e.w1] = max(dp[e.to][e.w1], newVal);
            ans = max(ans, dp[e.to][e.w1]);
            if (--inDegree[e.to] == 0) q.push(e.to);
        }
    }
    cout << ans;
}
```

**代码解读概要**：
> 该实现包含三大模块：①权值转换（第13/28行）②图构建（第43行）③拓扑DP（第53行）。核心在于DP状态转移——当前边权w1必须匹配前驱节点状态中的配对权值（第58行）。calcPaired中-1标记处理溢出，避免无效状态扩展。

**题解一片段赏析**：
1. **BFqwq的分层图技巧**：
   ```cpp
   // 分层图拓扑核心
   void topo(int w) {
       // 将权值w的边：u -> v 建为 u -> v+n
       for (auto e : edges[w]) 
           addEdge(e.u, e.v + n, e.l);
       // 将配对权值f(w)的边：u -> v 建为 u+n -> v
       for (auto e : edges[f[w]]) 
           addEdge(e.u + n, e.v, e.l);
       // 拓扑时状态在普通节点和分层节点间跳跃
   }
   ```
   **亮点**：通过物理分层强制交替匹配，解决状态连续性难题  
   **学习笔记**：分层图是处理状态转移约束的经典技巧

2. **一扶苏一的双哈希防冲突**：
   ```cpp
   pair<int, int> make_hash_state(int w) {
       int h1 = 0, h2 = 0;
       // 对每个质因子计算双哈希值
       for (auto p : prime_factors) {
           h1 = (h1 * BASE1 + p.exp) % MOD1;
           h2 = (h2 * BASE2 + p.exp) % MOD2;
       }
       return {h1, h2};
   }
   ```
   **亮点**：双哈希降低冲突概率，提升算法鲁棒性  
   **学习笔记**：大状态存储时哈希比map更省空间

---

## 5. 算法可视化：像素动画演示（复古游戏版）

**主题**：《钥匙勇者》8-bit像素闯关——在DAG城堡中寻找最长钥匙路径！

### 动画设计
- **场景设计**：
  - 节点：像素城堡（颜色区分入度：蓝色=可进入/红色=等待）
  - 边：浮动钥匙链，显示原始权值（如"24"）和简化图标（小钥匙"2³"）
  - 控制面板：开始/暂停/步进按钮，速度滑块（1x-5x）

- **核心流程**：
  1. **钥匙锻造**（权值转换）：
     - 点击边：播放"打铁"动画，显示质因数分解过程（如24→2³×3）
     - 指数模k：铁锤敲击次数=模操作（k=2时³→1次敲击）
     - 生成配对钥匙：火花四溅中生成新钥匙（24→8）

  2. **城堡探险**（拓扑DP）：
     - 起点：入度0的城堡亮起，勇者像素小人出现
     - 行走规则：当前钥匙必须匹配锁孔（上条边的配对钥匙）
        - 成功：播放"咔嚓"开锁声，路径变金色，+1金币（长度累计）
        - 失败：锁孔变红，路径消失
     - 状态显示：每个城堡门口显示钥匙袋（当前dp状态）

  3. **终极宝藏**（结果展示）：
     - 找到最长路径时：宝藏箱爆炸，弹出"WIN! 长度=XX"
     - 背景音乐：胜利版8-bit旋律

### 交互与特效
- **音效设计**：
  - 钥匙匹配：清脆"叮！"
  - 路径更新：金币掉落声
  - 错误匹配：低沉"嗡"警告
- **AI演示模式**：
  - 自动播放：勇者自主移动，速度可调
  - 教学模式：暂停时显示思考气泡（如“需要找钥匙8...”）

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
> 质因数分解+DAGDP的组合可解决：
> 1. 边权乘积为平方数的最长路（k=2特例）
> 2. 节点权值满足数论约束的拓扑排序
> 3. 状态依赖前驱的路径计数问题

### 洛谷推荐
1. **P1073 最优贸易**  
   → 同类DAGDP，状态设计为买卖决策
2. **P3388 割点**  
   → 图连通性基础，理解DAG性质必备
3. **P3953 逛公园**  
   → DAG记忆化搜索进阶，强化拓扑DP思维

---

## 7. 学习心得与经验分享
> BFqwq的调试教训：“数组开小=前功尽弃”  
> → **Kay总结**：在分层图等复杂空间结构中，$n$与$2n$有本质区别！计算数组大小时务必：  
> $$\text{MAXN} \leftarrow 2 \times (\text{节点数} + \text{边数}) \times \text{层数}$$
> 一扶苏一的工程规范启示：命名空间隔离+模块化，让代码如钟表般精密运行。

---

**结语**：完美路径的探索如同编程修行——用数论之钥解开图论之谜，以动态规划丈量算法之巅。下次冒险再见！🎮🚀

---
处理用时：229.00秒
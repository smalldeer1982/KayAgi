# 题目信息

# 「SWTR-7」Scores（hard version）

## 题目背景

#### 本题是 Scores 的 hard 版本。注意题目限制与 [easy](https://www.luogu.com.cn/problem/P7873) 版本不同。

#### 请注意特殊的时空限制。

## 题目描述

小 A 的班上有 $n$ 个学生。最近他们进行了一场考试，共有 $m$ 个学科。第 $i$ 个学生第 $j$ 门学科的得分为**整数** $s_{i,j}\ (0\leq s_{i,j}\leq 100)$。

同学们很重视自己在班上的排名，所以他们经常会比较自己和别的同学的分数。如果一个学生 $i$ **至少有一门学科**的分数比 $j$ **高**，ta 就会觉得自己不比 $j$ 差；相反，如果 ta **每门学科**的分数都比 $j$ **低**，ta 就会觉得自己被 $j$ 吊打了。

实际上，**上述两种情况并不是严格意义上相反的**。但是喜好八卦的小 A 打听到了每两个同学之间的分数情况，他惊讶地发现：**一个同学 $i$ 要么被 $j$ 吊打，要么不比 $j$ 差。** 同时，**如果 $i,j$ 被同一个人吊打，或同时吊打同一个人，则他们之间也有一方被另一方吊打**。我们用一个矩阵 $a_{i,j}\ (i\neq j)$ 来描述小 A 知道的同学们之间的分数关系：$a_{i,j}=0$ 表示 $i$ 被 $j$ 吊打；$a_{i,j}=1$ 表示 $i$ 不比 $j$ 差。

小 A 想知道这种情况会不会发生，即是否存在这样一张 $n\times m$ 的成绩表 $s$ 满足矩阵 $a$ 所描述的分数关系，从而确定有没有撒谎的同学。如果存在 $s$，请先输出 $\texttt{YES}$，再**任意**输出一种符合要求的成绩表；否则输出 $\texttt{NO}$。

注意：这里所求的 $s$ 所需满足的条件是 $a$ 的限制，而**不只是**小 A 所发现的性质，因为**他发现的性质已经在给出的 $a$ 中体现**。

## 说明/提示

**「Special Judge」**

**本题使用 Special Judge。请认真阅读输出格式，输出格式有误可能导致 UKE 或 WA。**

SPJ 首先会判断你的第一行输出是否与答案相同。  
如果相同且答案为 $\texttt{YES}$，则 SPJ 会判断你的输出是否符合所有限制。  
如果有解且你输出 $\texttt{YES}$，但给出方案错误，你将获得该测试点 $50\%$ 的分数。

你需要满足的限制如下：  
- $0\leq s_{i,j}\leq 100$。
- 对于任意 $i,j\ (i\neq j)$，若 $a_{i,j}=0$，则对于任意 $k\ (1\leq k\leq m)$，有 $s_{i,k}<s_{j,k}$；若 $a_{i,j}=1$，则存在一个 $k\in [1,m]$，使得 $s_{i,k}>s_{j,k}$。

你需要注意的是，所有输出都应严格符合输出格式。如果你对答案的存在性判断正确，但是输出方案时 $s_{i,j}<0$ 或 $s_{i,j}>100$，SPJ 会判定为 WA，得 $0$ 分，而不是 $50\%\ \times$ 该测试点分数。

**「数据范围与约定」**

本题共有 6 个测试点。

- Testcase #0（1 point）：是样例。
- Testcase #1（10 points）：$n=1$。
- Testcase #2（10 points）：$m=1$。
- Testcase #3（30 points）：$m=2$。
- Testcase #4（20 points）：$a_{i,j}=1\ (i\neq j)$。
- Testcase #5（29 points）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n,m\leq 100$，$a_{i,j}\in\{0,1\}$，$T=50$（除 Testcase #0）。  
对于 $a$ 的限制：若 $a_{i,j}=a_{i,k}=0$，则 $a_{j,k}$ 和 $a_{k,j}$ 中至少有一个为 $0$；若 $a_{i,k}=a_{j,k}=0$，则 $a_{i,j}$ 和 $a_{j,i}$ 中至少有一个为 $0$。  
对于所有测试点，**时间限制 500ms，空间限制 16MB。**

**「题目来源」**

[Sweet Round 07](https://www.luogu.com.cn/contest/51773) A2。  
idea & solution & data：[Alex_Wei](https://www.luogu.com.cn/user/123294)；验题：[chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
5
5 3
0 1 1 1 1
1 0 1 1 1
1 1 0 1 1
1 1 1 0 1
1 1 1 1 0
2 7
0 1
0 0
5 4
0 1 1 0 1
0 0 0 0 1
0 1 0 0 1
1 1 1 0 1
1 1 1 1 0
3 1
0 1 1
1 0 1
1 1 0
3 2
0 1 0
0 0 1
1 0 0```

### 输出

```
YES
100 99 97
98 100 99
95 97 100
0 98 100
99 99 99
YES
98 100 94 98 72 53 53
97 99 93 97 71 52 52
YES
90 80 70 60
50 40 30 20
60 50 40 30
100 90 80 70
40 60 80 100
NO
NO```

# AI分析结果


### 💡 Kay的C++算法解析：「SWTR-7」Scores（hard version）深入学习指南 💡

#### **1. 题目解读与核心算法识别**  
✨ **本题主要考察**：`构造与图论应用`  
🗣️ **初步分析**：  
> 本题需要构造一个成绩表满足给定的吊打关系矩阵。核心思想是将学生分组（组内存在吊打关系），组内用拓扑排序确定排名，组间通过两门学科的分差设计满足“不比对方差”的关系。  
> - **核心难点**：  
>   - 传递性矛盾检查（A吊打B，B吊打C，则A必须吊打C）  
>   - 组内排名冲突（同组内排名必须唯一）  
>   - m=1时只能存在一个组  
> - **可视化设计**：  
>   - 用像素方块表示学生，同组同色，组内按排名垂直排列  
>   - 动态显示学科分数分配：第一门学科分数从左向右递减（红色渐变），第二门学科递增（蓝色渐变）  
>   - 音效：分组时“叮”，分数分配时“嘟”，错误时“砰”  

---

#### **2. 精选优质题解参考**  
**题解一（by_chance）**  
* **点评**：思路清晰完整，传递性检查严谨（三重循环），分组和排名处理巧妙：  
  - 用并查集分组，组内统计被吊打次数作为排名  
  - 构造分数时，第一门学科按组大小累加，第二门学科用100减组偏移  
  - 边界处理全面（如m=1特判），代码变量名清晰（`rk[]`表排名，`root[]`表组内最高分）  

**题解二（enucai）**  
* **点评**：传递性检查与分组逻辑类似题解一，亮点在于构造方案更直观：  
  - 组间第一门学科严格递减，第二门学科严格递增  
  - 用`king[]`标记组内最高分学生，分数分配更易理解  
  - 代码结构简洁，组内排名冲突检查高效  

---

#### **3. 核心难点辨析与解题策略**  
1. **传递性矛盾检查**  
   * **分析**：若A吊打B（`a[A][B]=0`）且B吊打C（`a[B][C]=0`），则必须有A吊打C（`a[A][C]=0`）。三重循环可检测此类矛盾。  
   * 💡 **学习笔记**：传递性是合法吊打关系的基石。  

2. **组内排名冲突**  
   * **分析**：同组内每个学生的“被组内吊打次数”必须唯一（即排名唯一）。若重复则无解。  
   * 💡 **学习笔记**：组内排名是分数分配的依据，必须严格有序。  

3. **学科数m=1的特判**  
   * **分析**：仅当所有学生属于同一组且排名无冲突时才有解（分数互异）。  
   * 💡 **学习笔记**：单学科下组间无法构造“不比差”关系。  

### ✨ **解题技巧总结**  
- **分组定序**：用并查集合并直接/间接吊打关系，组内用拓扑序排名。  
- **学科分工**：两门学科分别承担组间区分（一减一增）和组内排名功能。  
- **防御性检查**：传递性、排名唯一性、m=1的组数限制是三大合法检查点。  

---

#### **4. C++核心代码实现赏析**  
**通用核心实现（综合题解一、二）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
int T, n, m, a[N][N], fa[N], rk[N], root[N], cnt[N], ans[N][N];
vector<int> g[N];

int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }

int main() {
    cin >> T;
    while (T--) {
        cin >> n >> m;
        bool valid = true;
        // 传递性检查
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                cin >> a[i][j];
        for (int k = 1; k <= n; k++)
            for (int i = 1; i <= n; i++)
                for (int j = 1; j <= n; j++)
                    if (a[i][k] == 0 && a[k][j] == 0 && a[i][j] != 0)
                        valid = false;

        // 并查集分组
        for (int i = 1; i <= n; i++) fa[i] = i, g[i].clear();
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                if (a[i][j] == 0 && i != j) 
                    fa[find(i)] = find(j);

        // 组内排名计算
        for (int i = 1; i <= n; i++) g[find(i)].push_back(i);
        for (int i = 1; i <= n; i++) {
            if (g[i].empty()) continue;
            memset(rk, 0, sizeof(rk));
            for (int u : g[i])
                for (int v : g[i])
                    if (a[u][v] == 0 && u != v) rk[u]++;
            // 检查排名唯一性
            vector<bool> vis(n, false);
            for (int u : g[i]) {
                if (vis[rk[u]]) valid = false;
                vis[rk[u]] = true;
                if (rk[u] == 0) root[i] = u; // 组内最高分
            }
        }

        // 分数构造
        if (valid && (m > 1 || (m == 1 && !valid))) {
            cout << "YES\n";
            int offset = 0;
            for (int i = 1; i <= n; i++) {
                if (g[i].empty()) continue;
                ans[root[i]][1] = offset + g[i].size();
                ans[root[i]][2] = 100 - offset;
                for (int j = 3; j <= m; j++) ans[root[i]][j] = 100;
                for (int u : g[i]) {
                    for (int j = 1; j <= m; j++) 
                        ans[u][j] = ans[root[i]][j] - rk[u];
                }
                offset += g[i].size();
            }
            // 输出成绩表
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= m; j++) 
                    cout << ans[i][j] << " ";
                cout << "\n";
            }
        } else cout << "NO\n";
    }
    return 0;
}
```

**题解一核心片段（分组与排名）**  
```cpp
// 并查集分组
for (int i=1;i<=n;i++) fa[i]=i;
for (int i=1;i<=n;i++)
    for (int j=1;j<=n;j++)
        if (i!=j && a[i][j]==0) 
            fa[find(i)] = find(j);

// 组内排名计算
for (int u : g[i]) {
    for (int v : g[i]) 
        if (a[u][v]==0 && u!=v) rk[u]++;
    if (vis[rk[u]]) valid = false; // 排名冲突检查
}
```
> **代码解读**：  
> - 并查集将吊打关系（`a[i][j]=0`）的学生合并到同组  
> - 组内每个学生的排名`rk[u]` = 被组内多少人吊打  
> - 排名0的学生是组内最高分（`root[i]`）  

---

#### **5. 算法可视化：像素动画演示**  
* **主题**：8-bit风格“成绩构造大冒险”  
* **核心演示流程**：  
  1. **初始化**：学生显示为彩色像素方块，随机散落  
  2. **传递性检查**：  
     - 矛盾处闪烁红光并播放“砰”声  
  3. **分组动画**：  
     - 同组学生被相同颜色框包围，合并时播放“叮”声  
  4. **组内排名**：  
     - 组内学生垂直排列，排名越高位置越高  
     - 头顶显示排名数字（0为皇冠图标）  
  5. **分数分配**：  
     - **第一门学科**：分数从左向右递减（红色进度条）  
     - **第二门学科**：分数从左向右递增（蓝色进度条）  
     - 其他学科：统一显示为金色100分  
  6. **验证阶段**：  
     - 随机两学生连线，检查是否满足矩阵`a`  
     - 满足显示绿勾+胜利音效，否则显示红叉+失败音效  

---

#### **6. 拓展练习**  
1. **洛谷 P7873**：本题简单版，巩固两学科构造技巧  
2. **洛谷 P1347**：拓扑排序应用，强化传递性检查  
3. **洛谷 P1525**：并查集分组场景迁移训练  

---

#### **7. 学习心得**  
> **经验摘录**：题解一作者提到“传递性检查需三重循环，易漏但关键”  
> **Kay点评**：多步约束问题需建立分层检查意识——先全局传递性，再组内一致性。调试时可先注释部分代码验证核心逻辑。  

---  
**结语**：本题融合了图论与构造思维，核心在于“分解约束+分层满足”。掌握分组策略和学科分工技巧后，类似问题皆可举一反三！🚀

---
处理用时：169.03秒
# 题目信息

# 「DROI」Round 2 单图

## 题目背景

与其编写苍白无力的背景，不如出更有质量的题。

## 题目描述

我们称[简单有向图](https://www.luogu.com.cn/paste/4oz6fep2) $G,H$ **本质相同**，当且仅当：

- 对于任意点对 $(u,v)$，若在图 $G$ 中从 $u$ 出发能走到 $v$，则在图 $H$ 中从 $u$ 出发能走到 $v$。反之若在图 $H$ 中从 $u$ 出发能走到 $v$，则在图 $G$ 中从 $u$ 出发也能走到 $v$。

若对于简单有向图 $G$，不存在其他简单有向图 $H$ 与其本质相同，则我们称图 $G$ 为 **单图**。

$T$ 次询问，每次询问给定一个正整数 $n$，请你回答 $n$ 个点的**有标号**单图数。

## 说明/提示

#### 数据范围

**「本题采用捆绑测试」** 

- $\operatorname{Subtask} 1(30\%)$：$T = 1$，$n \leq 5$。

- $\operatorname{Subtask} 2(50\%)$：$T \leq 10$。

- $\operatorname{Subtask} 3(20\%)$：无特殊限制。

对于 $100\%$ 的数据满足：$1 \leq T,n \leq 1000$，$1\leq mod \leq 10^9$。


#### 说明提示

这里给出一些例子来帮助理解单图的含义：

------------

![](https://cdn.luogu.com.cn/upload/image_hosting/kykl8fg8.png)[](https://www.luogu.com.cn/paste/0tbbkesd)

这是一张单图，可以证明不存在其他图与其本质相同。

------------

![](https://cdn.luogu.com.cn/upload/image_hosting/5appj8pr.png)

这不是一张单图，因为我们可以添加边 $(5,2)$ 构造出与其本质相同的图。

------------

![](https://cdn.luogu.com.cn/upload/image_hosting/wtsep329.png)

这不是一张单图，因为我们可以删去边 $(1,3)$ 构造出与其本质相同的图。



## 样例 #1

### 输入

```
5 998244353
1
3
5
12
888```

### 输出

```
1
16
986
328006912
535268381```

# AI分析结果


# 💡 Kay的C++算法解析：「DROI」Round 2 单图 深入学习指南 💡

<introduction>
大家好，我是Kay！今天我们将一起探讨「单图」计数问题。这道题要求计算n个节点的有标号单图数量（单图指不存在其他图与其传递闭包相同的图）。通过本指南，你将掌握组合计数和递推优化的核心技巧，并通过像素动画直观理解算法过程。准备好了吗？让我们开始吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`组合数学` 与 `动态规划`

🗣️ **初步分析**：
> 解决单图计数问题，关键在于**问题分解**和**组合优化**。就像搭积木一样，我们将图拆解为独立的二元环和剩余部分（每个点入度或出度为0）。核心思想是：
> - **二元环**：两个节点相互连接形成独立环（类似俄罗斯方块中的方块配对）
> - **剩余图**：节点分为"发射点"（有出度）和"接收点"（有入度/孤立点），发射点必须至少向一个接收点连线
>
> 难点在于正确处理两类结构的组合计数和避免重复计算。可视化方案将展示：
> 1. 像素化节点在网格中随机移动，通过颜色区分状态（未处理/已配对/发射点/接收点）
> 2. 二元环配对时高亮节点并播放"叮"音效
> 3. 发射点向接收点连线时显示白色箭头和连边音效
> 4. 控制面板支持单步执行和速度调节，自动演示模式按算法步骤动态展示

---

## 2. 精选优质题解参考

<eval_intro>
我根据思路清晰度、代码规范性和算法效率，精选了3份优质题解。这些题解都抓住了组合计数核心，但在实现细节上各有特色：
</eval_intro>

**题解一：(来源：Demeanor_Roy)**
* **点评**：作为出题人题解，思路最为严谨清晰。亮点在于：
  - 将问题分解为二元环计数(`h[]`)和剩余图计数(`g[]`)两个独立子问题
  - 使用杨辉三角预处理组合数，时间复杂度优化至$O(n^2)$
  - 代码结构规范，关键变量`fct`（二元环方案）和`g`（剩余图方案）含义明确
  - 边界处理完整（如`g[0]=1`）

**题解二：(来源：0000pnc)**
* **点评**：图文并茂解释算法原理是其最大亮点：
  - 用像素图示展示三点链反例和二元环合法结构
  - 实现中采用分步计算：先解剩余图再加二元环
  - 变量命名可改进（如`f`/`ff`），但算法本质把握准确
  - 特别适合视觉型学习者理解问题本质

**题解三：(来源：Mine_King)**
* **点评**：提供独特的容斥原理解法：
  - 先用$2^{j(i-j)}$计算所有可能的连边（含空边）
  - 通过容斥剔除不合法方案（无出度的"发射点"）
  - 虽然复杂度稍高($O(n^3)$)，但展示了组合计数的多样性
  - 代码中`sum[]`/`res[]`命名清晰体现计算步骤

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三个关键难点，结合优质题解的通用策略如下：
</difficulty_intro>

1.  **难点：单图的结构特征识别**
    * **分析**：通过反证法发现：若存在三点链$u→v→w$，则可修改$u→w$边构造等价图。因此单图只能是：
        - 独立二元环（节点两两配对）
        - 非环点分为发射集（只有出边）和接收集（入边+孤立点）
    * 💡 **学习笔记**：三点链是破坏单图性质的唯一结构！

2.  **难点：组合计数的去重处理**
    * **分析**：发射集向接收集连边时，每个发射点必须至少连一条边（避免孤立点误判）。方案数计算为：
        $$(2^{\text{接收点数量}} - 1)^{\text{发射点数量}}$$
        二元环配对需避免重复计数：$k$对环方案 = $(2k-1)!! = (2k-1)×(2k-3)⋯×1$
    * 💡 **学习笔记**："-1"排除空边集，"!!"消除配对顺序影响

3.  **难点：高效预处理实现**
    * **分析**：$n \leq 1000$需预处理：
        - 组合数$C(n,k)$用杨辉三角计算
        - $2^k$用快速幂或位移优化
        - 二元环方案$h[2k]=h[2k-2]×(2k-1)$
    * 💡 **学习笔记**：预处理是$O(n^2)$算法效率的关键

### ✨ 解题技巧总结
<summary_best_practices>
从本题提炼的通用解题策略：
</summary_best_practices>
- **分解与抽象**：将复杂结构拆解为独立子结构（二元环+二分图）
- **组合计数三要素**：状态定义（发射/接收集）、合法性检查（非空边集）、去重（配对顺序）
- **预处理为王**：组合数、幂运算、递推关系预先计算
- **边界思维**：$n=0$时方案数为1（空图有效！）

---

## 4. C++核心代码实现赏析

<code_intro_overall>
综合优质题解，通用实现如下。特点：
- 预处理组合数$C[][]$、二元环方案$h[]$、剩余图方案$g[]$
- 主逻辑仅需$O(n)$查询
- 完整处理模运算和负值
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合自优质题解的最佳实践，完整处理模运算
* **完整核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 1005;

int T, mod;
LL C[N][N], g[N], h[N], f[N];

LL qpow(LL x, int n) { // 快速幂
    LL res = 1;
    while(n) {
        if(n & 1) res = res * x % mod;
        x = x * x % mod;
        n >>= 1;
    }
    return res;
}

void init() {
    // 预处理组合数
    for(int i = 0; i < N; i++) {
        C[i][0] = 1;
        for(int j = 1; j <= i; j++)
            C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;
    }
    
    // 剩余图方案g(n): 枚举发射点数量i
    for(int n = 0; n < N; n++) {
        g[n] = 0;
        for(int i = 0; i <= n; i++) {
            LL base = (qpow(2, n-i) - 1 + mod) % mod; // 2^(接收点数量)-1
            g[n] = (g[n] + C[n][i] * qpow(base, i)) % mod;
        }
    }
    
    // 二元环方案h(n)
    h[0] = 1;
    for(int i = 2; i < N; i += 2) 
        h[i] = h[i-2] * (i-1) % mod;
    
    // 总方案f(n): 枚举二元环对数
    for(int n = 0; n < N; n++) {
        f[n] = 0;
        for(int i = 0; 2*i <= n; i++)
            f[n] = (f[n] + C[n][2*i] * h[2*i] % mod * g[n-2*i]) % mod;
    }
}

int main() {
    cin >> T >> mod;
    init();
    while(T--) {
        int n; cin >> n;
        cout << (f[n] % mod + mod) % mod << endl;
    }
    return 0;
}
```
* **代码解读概要**：
  - `init()`预处理三张表：组合数`C[][]`、剩余图方案`g[]`、二元环方案`h[]`
  - `g[n]`计算：枚举发射点数`i`，每个发射点有$2^{\text{接收点}}-1$种连法
  - `h[2i]`计算：递推式$(2i-1)×h[2i-2]$
  - `f[n]`计算：枚举二元环数量`i`，组合数选取$2i$个点

---
<code_intro_selected>
现在赏析各优质题解的代表性代码片段：
</code_intro_selected>

**题解一：(Demeanor_Roy)**
* **亮点**：变量命名规范，快速幂独立成函数
* **核心代码片段**：
```cpp
// 快速幂模板
inline int pwr(int x, int y) {
    int res = 1;
    while(y) {
        if(y&1) res = (LL)res*x % mod;
        x = (LL)x*x % mod; y >>= 1;
    }
    return res;
}
// 剩余图计算
for(int n=0; n<N; n++)
    for(int i=0; i<=n; i++)
        g[n] = (g[n] + (LL)C[n][i]*pwr(pwr(2,n-i)-1, i)) % mod;
```
* **代码解读**：
  > 这里将快速幂抽象为`pwr`函数，提高复用性。计算`g[n]`时，内层循环的`i`表示发射点数量。注意`(2^(n-i)-1)^i`需两次幂运算：先算$2^k$再算$(...)^i$
* 💡 **学习笔记**：关键变量`g[n]`的物理意义是$n$个非环点的方案数

**题解二：(0000pnc)**
* **亮点**：分步骤计算，逻辑直白
* **核心代码片段**：
```cpp
// 二元环方案计算
h[0] = 1;
for(int i=2; i<=1000; i+=2)
    h[i] = h[i-2] * (i-1) % mod;
// 总方案整合
for(int i=0; 2*i<=n; i++)
    ans += C[n][2*i] * h[2*i] % mod * g[n-2*i];
```
* **代码解读**：
  > 此实现清晰展示了问题分解思想：先独立计算二元环方案`h[]`，再与剩余图`g[]`组合。注意`h[i]`仅在偶数下标有值，对应$i$个点组成$i/2$对环
* 💡 **学习笔记**：二元环方案数即双阶乘$(2k-1)!!$，反映配对顺序无关性

**题解三：(Mine_King)**
* **亮点**：容斥原理的巧妙应用
* **核心代码片段**：
```cpp
// 容斥计算剩余图
for(int i=0; i<=1000; i++) {
    sum[i] = 0;
    for(int j=0; j<=i; j++) // 枚举发射点数
        sum[i] = (sum[i] + C[i][j] * qpow(2, j*(i-j))) % mod;
}
for(int i=0; i<=1000; i++) {
    res[i] = 0;
    for(int j=0; j<=i; j++) {
        if(j%2 == 0) // 容斥项符号
            res[i] = (res[i] + C[i][j]*sum[i-j]) % mod;
        else 
            res[i] = (res[i] - C[i][j]*sum[i-j]%mod + mod) % mod;
    }
}
```
* **代码解读**：
  > 这里`sum[i]`先计算所有可能的连边（含空边），再通过容斥剔除非法方案（无出度的发射点）。符号$(-1)^j$实现容斥
* 💡 **学习笔记**：容斥原理是处理"至少一个"约束的通用方法

-----

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
下面是用8位像素风格展示算法执行过程的方案，类似经典游戏《俄罗斯方块》+《贪吃蛇》的混合体，帮助大家直观理解二元环配对和连边过程：
</visualization_intro>

* **动画演示主题**：`像素探险家：单图构造大冒险`
* **核心演示内容**：二元环配对过程 + 发射集/接收集连边逻辑
* **设计思路简述**：采用复古8位像素风格（16色）降低理解压力，通过游戏化进度激励学习。每个节点化为像素方块，状态用颜色区分：
  - 蓝色：未处理节点
  - 红色：已配对二元环
  - 绿色：发射集节点
  - 黄色：接收集节点

* **动画帧步骤与交互关键点**：
  1. **场景初始化**：
      - $n$个蓝色像素方块在$10×10$网格随机分布（FC游戏风格）
      - 控制面板：开始/暂停/单步/重置按钮 + 速度滑块
      - 8位芯片音乐背景音（循环播放）

  2. **二元环配对阶段**：
      - 自动模式：遍历所有节点，为未配对节点寻找最小标号节点
      - 高亮当前节点（闪烁白光），随机选择另一节点连线
      - 成功配对：播放"叮"音效 + 两节点变红 + 显示双向箭头
      - 文本提示："配对成功！形成二元环"

  3. **剩余图处理阶段**：
      - 剩余节点分裂为两群：左侧绿色（发射集），右侧黄色（接收集）
      - 高亮当前发射节点（绿色闪烁），随机选择接收节点子集
      - 连边动画：绿色节点向黄色节点发射像素箭头（带"嗖"音效）
      - 孤立点处理：无出度的绿色节点自动变黄 + 提示"孤立点归入接收集"

  4. **自动演示模式**：
      - 类似"贪吃蛇AI"自主决策：优先配对 > 划分集合 > 随机连边
      - 每阶段完成：显示"Stage Clear!" + 得分增加
      - 进度条显示当前计算状态（如$f[k]$值）

  5. **结果展示**：
      - 成功：播放胜利旋律 + 全图高亮闪烁
      - 失败（无解情况）：播放警报音 + 显示"No Solution"

* **技术实现**：
  - Canvas绘制网格和节点（30×30像素/节点）
  - 状态机管理动画阶段：`IDLE → PAIRING → CONNECTING → DONE`
  - 音效使用Web Audio API，8位音效采样自经典游戏

<visualization_conclusion>
通过这种游戏化演示，你将直观理解：
1. 为何三点链破坏单图性质
2. 二元环如何独立存在
3. 发射/接收集划分的数学意义
4. 组合计数中"至少一条边"约束的物理表现
</visualization_conclusion>

-----

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握单图计数后，可挑战以下相似问题，巩固组合计数和图论技巧：
</similar_problems_intro>

* **通用思路/技巧迁移**：
  - **有标号二分图计数**：类似剩余图的发射/接收集模型
  - **无向图匹配计数**：扩展二元环到一般匹配问题
  - **传递闭包计数**：计算给定传递闭包的有向图数量

* **练习推荐 (洛谷)**：
  1. **P6189 无向图三元环计数**  
     🗣️ **推荐理由**：巩固环计数技巧，学习时间复杂度优化
  2. **P6775 [NOI2020] 制作菜品**  
     🗣️ **推荐理由**：组合计数与二分图的实际应用，含背包思想
  3. **P3349 [ZJOI2016] 小星星**  
     🗣️ **推荐理由**：子集计数与树形DP的完美结合

-----

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中的调试经验尤其珍贵：
</insights_intro>

> **参考经验 (来自 Warriors_Cat)**：  
> "边界条件$g[0]=1$（空图方案）容易被忽略，导致$n=2$时出错。建议小数据打表验证"  
>
> **点评**：这提醒我们：组合计数的边界处理（空集、零元）是调试重点。$n=0,1,2$的手动验证能避免50%边界错误，务必养成习惯！

<conclusion>
本次单图计数分析就到这里。记住：组合计数的核心在于"分解+抽象+去重"。通过像素动画，相信大家已直观理解算法本质。下次遇到类似问题，不妨回想这些跳跃的像素块！继续加油，我们下期再见！💪
</conclusion>
-----

---
处理用时：259.06秒
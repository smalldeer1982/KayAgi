# 题目信息

# [NOI2013] 快餐店

## 题目描述

小 T 打算在城市 C 开设一家外送快餐店。送餐到某一个地点的时间与外卖店到该地点之间最短路径长度是成正比的，小 T 希望快餐店的地址选在离最远的顾客距离最近的地方。

快餐店的顾客分布在城市 C 的 $N$ 个建筑中，这 $N$ 个建筑通过恰好 $N$ 条双向道路连接起来，不存在任何两条道路连接了相同的两个建筑。任意两个建筑之间至少存在一条由双向道路连接而成的路径。小 T 的快餐店可以开设在任一建筑中，也可以开设在任意一条道路的某个位置上（该位置与道路两端的建筑的距离不一定是整数）。

现给定城市 C 的地图（道路分布及其长度），请找出最佳的快餐店选址，输出其与最远的顾客之间的距离。

## 说明/提示

### 样例解释 1

![](https://cdn.luogu.com.cn/upload/image_hosting/r0dmxcgy.png)

### 样例解释 2

![](https://cdn.luogu.com.cn/upload/image_hosting/pf8eaowl.png)

### 数据范围

- 对于 $10\%$ 的数据，$N\leq 80$，$L_i=1$；
- 对于 $30\%$ 的数据，$N\leq 600$，$L_i\leq 100$；
- 对于 $60\%$ 的数据，$N\leq 2000$，$L_i\leq 10^9$；
- 对于 $100\%$ 的数据，$1\leq N\leq 10^5$，$1\leq L_i \leq 10^9$。

## 样例 #1

### 输入

```
4 
1 2 1 
1 4 2 
1 3 2 
2 4 1
```

### 输出

```
2.0 ```

## 样例 #2

### 输入

```
5
1 5 100
2 1 77
3 2 80
4 1 64
5 3 41```

### 输出

```
109.0```

# AI分析结果

# 💡 Kay的C++算法解析：[NOI2013] 快餐店 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（基环树直径与重心）

🗣️ **初步分析**：  
你可以把这道题的“城市地图”想象成一棵**“绕成环的树”**——基环树（有一个环，环上挂着许多子树）。我们的目标是找一个“最优快餐店位置”，让最远的顾客离它最近。这个位置其实就是基环树的**重心**，而重心一定在树的**直径**（最长路径）的中点——就像一根绳子的中点离两端最远点最近！

### 核心问题转化  
题目要求的“最远顾客距离最短”等价于求**基环树的直径**，答案就是直径的一半。基环树的直径有两种情况：  
1. **不经过环**：直径是环上某棵子树的最长路径（比如环上某个节点挂着的子树里的最长链）；  
2. **经过环**：直径从环上一棵子树出发，绕环走到另一棵子树（比如从环上节点A的子树最深点，绕环到节点B的子树最深点）。

### 核心算法流程  
1. **找环**：用DFS或Tarjan算法找到基环树的环（环是基环树的“核心”）；  
2. **处理子树**：对环上每个节点，计算其子树的最大深度（子树里能延伸的最长距离）和子树直径（不经过环的情况）；  
3. **处理环上情况**：将环拆成链，用**前缀/后缀数组**优化计算经过环的直径（避免暴力枚举的O(n²)复杂度）；  
4. **求最终直径**：取“子树直径”和“经过环的直径”的最大值，除以2就是答案。

### 可视化设计思路  
我们会用**FC红白机风格**的像素动画展示算法过程：  
- 用不同颜色的像素块表示环（黄色）、子树（绿色）、子树最深点（红色）；  
- 动态演示“找环”过程（黄色块逐渐连成环）；  
- 用“进度条”展示前缀/后缀数组的计算（比如A数组是“前缀最长链+子树深度”，用蓝色条长度表示）；  
- 断环时用“剪刀”动画，配合“叮”的音效，展示经过环的直径计算。


## 2. 精选优质题解参考

<eval_intro>  
我从思路清晰度、代码可读性、算法优化程度等角度，筛选了3篇优质题解，帮你快速理解核心逻辑～
</eval_intro>

### 题解一（作者：Mr_cold，赞39）  
* **点评**：  
  这篇题解是基环树问题的“标准模板”！思路分两步走：先找环，再处理子树和环上情况。代码结构清晰，变量命名易懂（比如`huan`数组存环上节点，`dis`数组存子树最大深度）。最亮点是**用前缀/后缀数组优化环上直径计算**——通过`A/B/C/D`四个数组，把环上的复杂计算简化为O(n)，避免了暴力枚举的超时问题。边界处理也很严谨（比如断环时的`tmp`变量保存环的最后一条边权），非常适合作为入门模板。


### 题解二（作者：_LAUV_，赞38）  
* **点评**：  
  这篇题解的优势是**直观的图示辅助**（比如把基环树画成“细菌”形状），帮你快速理解环的结构。作者用“断环成链”的常见套路，把环拆成链后计算前缀`pre`和后缀`bck`数组，再用`bs1/bs2`数组维护环上的最长路径。代码中的`dfsCir`函数找环的逻辑很巧妙，通过栈记录环上节点，适合新手模仿。


### 题解三（作者：Macesuted，赞24）  
* **点评**：  
  这篇题解的**细节讲解超贴心**！作者不仅解释了`A/B/C/D`数组的含义（比如`A[i]`是“前缀链长+子树深度”），还分享了自己踩过的坑（比如混淆`max`和`min`导致的WA）。代码中的`work`函数处理子树直径的逻辑简洁，`dfs`函数找环的过程清晰，非常适合用来理解“子树直径”和“环上直径”的区别。


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决基环树问题的关键是“拆解环与子树”，以下3个难点是你最容易卡壳的地方，我帮你总结了应对策略～
</difficulty_intro>

### 1. 如何找到基环树的环？  
* **难点**：基环树有且只有一个环，如何快速定位环上的节点？  
* **策略**：用**DFS+时间戳**或**Tarjan算法**。比如Mr_cold的题解中，`dfs`函数通过`dfn`数组记录节点访问顺序，当遇到已访问且时间戳更大的节点时，回溯收集环上节点。  
* 💡 **学习笔记**：找环的核心是“发现回边”——当从节点u走到已访问的节点v（v不是u的父节点），则u到v的路径就是环的一部分。


### 2. 如何计算经过环的直径？  
* **难点**：环上任意两点的距离有“顺时针”和“逆时针”两种，直接枚举会超时（O(n²)）。  
* **策略**：用**前缀/后缀数组优化**。比如Macesuted的题解中：  
  - `A[i]`：前缀中“子树深度+链长”的最大值（记录从环起点到i的最长延伸）；  
  - `B[i]`：前缀中“两子树深度+距离”的最大值（记录环前i个节点的最长路径）；  
  - `C[i]/D[i]`：后缀的类似计算。  
  最后枚举断环的位置，取三种情况的最大值（前缀最长、后缀最长、跨环最长）。  
* 💡 **学习笔记**：前缀/后缀数组的本质是“预先计算并保存中间结果”，避免重复计算。


### 3. 如何处理子树的直径和最大深度？  
* **难点**：子树的直径是子树内的最长路径，如何同时计算子树最大深度？  
* **策略**：用**DFS+动态规划**。比如Mr_cold的`DP`函数中，`dis[now]`记录以`now`为根的子树最大深度，`ans`记录子树直径（`dis[now] + dis[to] + edge[i].cost`）。  
* 💡 **学习笔记**：子树直径的计算方法是“每个节点的最大深度+次大深度”，而子树最大深度是“子节点的最大深度+边权”。


### ✨ 解题技巧总结  
- **拆解问题**：把基环树拆成“环”和“子树”，分别处理；  
- **预处理优化**：用前缀/后缀数组处理环上的重复计算；  
- **动态规划**：子树的直径和最大深度用DFS+DP计算；  
- **边界处理**：断环时要保存环的最后一条边权（比如Mr_cold的`tmp`变量）。


## 4. C++核心代码实现赏析

<code_intro_overall>  
先看一个**通用核心实现**，综合了优质题解的思路，结构清晰，适合入门～
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码综合了Mr_cold和Macesuted的思路，包含找环、处理子树、计算环上直径的完整逻辑。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;
typedef long long ll;
const int MAXN = 1e5 + 10;

struct Edge { int to, from, cost; } edge[MAXN << 1];
int last[MAXN << 1], cnt = 0;
int huan[MAXN], huan_cnt = 0, huan_zhi[MAXN], fa[MAXN], cost[MAXN];
bool huan_sign[MAXN];
int dfn[MAXN], timee = 0;
ll dis[MAXN], ans = 0, ans1 = 0;
ll A[MAXN], B[MAXN], C[MAXN], D[MAXN];

void add(int x, int y, int z) {
    edge[++cnt].to = y;
    edge[cnt].cost = z;
    edge[cnt].from = last[x];
    last[x] = cnt;
}

// 找环
void dfs(int now) {
    dfn[now] = ++timee;
    for (int i = last[now]; i; i = edge[i].from) {
        int to = edge[i].to;
        if (to != fa[now]) {
            if (!dfn[to]) {
                fa[to] = now;
                cost[to] = edge[i].cost;
                dfs(to);
            } else if (dfn[to] > dfn[now]) {
                for (; to != now; to = fa[to]) {
                    huan_sign[to] = true;
                    huan[++huan_cnt] = to;
                    huan_zhi[huan_cnt] = cost[to];
                }
                huan_sign[now] = true;
                huan[++huan_cnt] = now;
                huan_zhi[huan_cnt] = edge[i].cost;
            }
        }
    }
}

// 处理子树：计算子树最大深度dis和子树直径ans
void DP(int now, int father) {
    for (int i = last[now]; i; i = edge[i].from) {
        int to = edge[i].to;
        if (!huan_sign[to] && to != father) {
            DP(to, now);
            ans = max(ans, dis[now] + dis[to] + edge[i].cost);
            dis[now] = max(dis[now], dis[to] + edge[i].cost);
        }
    }
}

int main() {
    int n; cin >> n;
    for (int i = 1; i <= n; ++i) {
        int x, y, z; cin >> x >> y >> z;
        add(x, y, z); add(y, x, z);
    }
    dfs(1); // 找环
    for (int i = 1; i <= huan_cnt; ++i) DP(huan[i], 0); // 处理子树

    // 计算前缀数组A/B
    ll sum = 0, maxx = 0;
    for (int i = 1; i <= huan_cnt; ++i) {
        sum += huan_zhi[i-1];
        A[i] = max(A[i-1], dis[huan[i]] + sum);
        B[i] = max(B[i-1], sum + maxx + dis[huan[i]]);
        maxx = max(maxx, dis[huan[i]] - sum);
    }

    // 计算后缀数组C/D
    sum = maxx = 0;
    int tmp = huan_zhi[huan_cnt]; huan_zhi[huan_cnt] = 0;
    for (int i = huan_cnt; i >= 1; --i) {
        sum += huan_zhi[i];
        C[i] = max(C[i+1], dis[huan[i]] + sum);
        D[i] = max(D[i+1], sum + maxx + dis[huan[i]]);
        maxx = max(maxx, dis[huan[i]] - sum);
    }

    // 计算经过环的直径ans1
    ans1 = B[huan_cnt];
    for (int i = 1; i < huan_cnt; ++i) {
        ll tep = max(B[i], D[i+1]);
        tep = max(tep, A[i] + C[i+1] + tmp);
        ans1 = min(ans1, tep);
    }

    // 最终直径是子树直径和环上直径的最大值
    ll final_ans = max(ans, ans1);
    if (final_ans % 2 == 0) cout << final_ans / 2 << ".0" << endl;
    else cout << final_ans / 2 << ".5" << endl;

    return 0;
}
```
* **代码解读概要**：  
  1. **找环**：`dfs`函数通过时间戳找到环，存到`huan`数组；  
  2. **处理子树**：`DP`函数计算每个子树的最大深度`dis`和子树直径`ans`；  
  3. **前缀/后缀计算**：`A/B`数组处理环的前缀，`C/D`数组处理后缀；  
  4. **求环上直径**：枚举断环位置，取三种情况的最小值（因为要找“最短的最长路径”）；  
  5. **输出答案**：最终直径除以2，处理小数部分。


### 题解一（Mr_cold）核心片段赏析  
* **亮点**：用前缀/后缀数组高效计算环上直径。  
* **核心代码片段**：  
```cpp
// 计算前缀数组A/B
ll sum = 0, maxx = 0;
for (int i = 1; i <= huan_cnt; ++i) {
    sum += huan_zhi[i-1];
    A[i] = max(A[i-1], dis[huan[i]] + sum); // 前缀最长链+子树深度
    B[i] = max(B[i-1], sum + maxx + dis[huan[i]]); // 前缀两子树最长路径
    maxx = max(maxx, dis[huan[i]] - sum); // 维护最大的(dis[j] - sum[j])
}
```
* **代码解读**：  
  - `sum`是环的前缀链长（从环起点到当前节点的距离）；  
  - `A[i]`记录“从环起点到i的最长延伸”（子树深度+链长）；  
  - `B[i]`记录“环前i个节点的最长路径”——通过`maxx`（之前的`dis[j] - sum[j]`最大值），可以快速计算`dis[j] + dis[i] + (sum[i] - sum[j])`（即两子树深度+距离）；  
* 💡 **学习笔记**：`maxx`的作用是“抵消前缀链长”，把两节点的距离转化为`sum[i] - sum[j]`，避免重复计算。


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>  
为了让你更直观地“看”到基环树直径的计算过程，我设计了一个**FC红白机风格**的像素动画！像玩《超级马里奥》一样学算法～
\</visualization\_intro\>

### 动画演示主题  
**《像素探险家找重心》**：你控制一个像素小人（代表算法），在基环树地图中寻找“最优快餐店位置”。


### 核心演示内容  
1. **场景初始化**：  
   - 屏幕显示**8位像素风格**的基环树：黄色方块代表环，绿色方块代表子树，红色方块代表子树最深点；  
   - 左下角是**控制面板**：有“开始/暂停”“单步执行”“重置”按钮，还有速度滑块；  
   - 背景播放**8位复古BGM**（类似《塞尔达传说》的轻快旋律）。

2. **找环过程**：  
   - 像素小人从节点1出发，用蓝色箭头标记访问过的节点；  
   - 当遇到回边（已访问的非父节点）时，黄色方块逐渐连成环，伴随“叮”的音效；  
   - 环找到后，屏幕弹出提示：“环已发现！共XX个节点～”。

3. **处理子树**：  
   - 对每个环上节点，绿色子树逐渐展开，红色方块标记子树最深点；  
   - 子树直径计算完成时，红色方块闪烁，伴随“嘀”的音效；  
   - 屏幕右上角显示当前子树的直径：“子树直径：XX”。

4. **计算环上直径**：  
   - 环被“剪刀”动画断开（比如断开节点i和i+1之间的边），变成一条链；  
   - 蓝色进度条展示前缀数组`A`的计算过程（进度条长度=当前`A[i]`的值）；  
   - 黄色进度条展示后缀数组`C`的计算过程；  
   - 当计算跨环直径时，红色箭头从环起点指向终点，伴随“锵”的音效；  
   - 最终环上直径显示在屏幕中央：“环上直径：XX”。

5. **结果展示**：  
   - 最优位置（直径中点）用闪烁的金色方块标记；  
   - 播放“胜利”音效（类似《超级马里奥》的通关音乐）；  
   - 屏幕显示最终答案：“最远顾客距离：XX.0/XX.5”。


### 交互设计  
- **单步执行**：点击“下一步”，动画逐步推进，每步显示当前操作的文字说明（比如“正在计算前缀数组A[3]”）；  
- **自动播放**：滑动速度滑块调整动画速度（慢/中/快）；  
- **重置**：点击“重置”，回到初始状态，重新演示。


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>  
基环树是图论中的常见模型，掌握了本题的思路，可以解决很多类似问题～
\</similar\_problems\_intro\>

### 通用思路迁移  
基环树的核心是“环+子树”，常见问题包括：  
1. 求基环树的直径（本题）；  
2. 求基环树的重心（本题变种）；  
3. 求基环树的最长路径（允许重复走边？不，基环树的路径是简单路径）。


### 洛谷练习推荐  
1. **洛谷 P1399** - [NOI2013] 快餐店  
   * 🗣️ **推荐理由**：原题复现，巩固基环树直径的计算逻辑。  
2. **洛谷 P2607** - [ZJOI2008] 骑士  
   * 🗣️ **推荐理由**：基环树的最大独立集问题，需要处理环上的选择逻辑，拓展思维。  
3. **洛谷 P3629** - [APIO2010] 巡逻  
   * 🗣️ **推荐理由**：基环树的路径覆盖问题，需要计算添加边后的最短巡逻路径，考验对基环树结构的理解。  
4. **洛谷 P4381** - [IOI2008] Island  
   * 🗣️ **推荐理由**：基环树的最长路径问题，多组测试用例，强化代码的鲁棒性。


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>  
优质题解中的作者心得能帮你避开很多坑，比如：
\</insights\_intro\>

> **参考经验 (来自 Macesuted)**：“我最开始把`ans`和`ans1`的`max`和`min`搞反了，导致WA了20分。后来才明白：子树直径和环上直径要取`max`（因为直径是最长路径），而环上的不同断环情况要取`min`（因为要找最短的最长路径）。”  
> **点评**：这个错误很典型！很多人会混淆“取最大值”和“取最小值”的场景。记住：**直径是“最长路径”，所以子树和环上的情况要取最大；而环上的不同断环情况是“不同的最长路径”，我们要找其中最短的那个（因为要让最远顾客距离最短）**。


## 8. 总结

本次分析的“快餐店”问题，核心是**基环树的直径计算**。通过“找环→处理子树→优化环上计算”的步骤，我们能高效解决问题。记住：  
- 基环树的直径分“子树”和“环上”两种情况；  
- 前缀/后缀数组是处理环上问题的关键；  
- 代码的边界处理（比如断环时的边权）很重要！

下次遇到基环树问题，试着用今天学的思路拆解它——先找环，再处理子树，最后优化环上计算。编程能力的提升，在于**理解本质+多练多总结**～

💪 加油，你一定能掌握基环树的奥秘！

---
处理用时：187.17秒
# 题目信息

# 【模板】可并堆 2

## 题目背景

感谢 @[Spasmodic](https://www.luogu.com.cn/user/121027) 提供初版数据生成器。

[gen](https://www.luogu.com.cn/paste/4vk36jsp)。

## 题目描述

给定正整数 $n$ 和 $m$ 以及一个长为 $n$ 的整数序列 $a_{1,\dots,n}$。

你需要维护序列 $a_{1,\dots,n}$ 以及 $n$ 个集合 $S_{1,\dots,n}$，初始时 $S_i=\{i\}$。

接下来要进行以下四种操作共 $m$ 次，每次操作形如：

- `0 x y`：表示将元素 $y$ 从集合 $S_x$ 中删去。保证此时元素 $y$ 在集合 $S_x$ 中。
- `1 x`：表示询问 $\min_{i\in S_x} a_i$，保证此时集合 $S_x$ 非空。
- `2 x y`：将集合 $S_y$ 中并入 $S_x$ 并清空集合 $S_y$。保证此时集合 $S_x,S_y$ 均非空，且此次操作后不会再出现涉及集合 $S_y$ 的操作。
- `3 x y z`：表示将 $a_y$ 赋值为 $z$。保证此时元素 $y$ 在集合 $S_x$ 中，且 $z<a_y$。

不难发现这是一道堆的模板题，所以现在请你完成它。

## 说明/提示

对于 $20\%$ 的数据，$n=m=10$；

对于 $80\%$ 的数据，$n=m=10^5$；

对于 $100\%$ 的数据，$1\le n,m\le10^6$，$1\le a_i\le2\times10^9$，保证任意时刻任意堆中元素绝对值不超过 $10^{15}$（人话：保证每次 `3` 操作最多单点减 $5\times10^8$）。

---

最后两个点出题人的手写堆和 pbds 的配对堆都跑到了几百毫秒，如果有被卡常的可私。

## 样例 #1

### 输入

```
5 5
1 2 3 4 4
2 4 5
3 4 5 3
1 4
0 4 5
1 4```

### 输出

```
3
4```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】可并堆 2 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（侧重可并堆数据结构的运用）

🗣️ **初步分析**：  
可并堆就像“可以快速合并的苹果堆”——假设你有几堆苹果，每堆都按“最小的在最上面”（小根堆）摆放，可并堆能帮你快速把两堆苹果合并成一堆（还是小根堆），还能快速找到每堆的最小苹果，甚至能从堆里拿走某个苹果、把某个苹果变小（题目中的修改操作）。  

本题的核心是**用可并堆维护多个集合**：每个集合对应一个堆，初始时每个元素自己是一个堆。需要支持四个操作：删除元素、查最小值、合并堆、修改元素值。解决这些问题的关键是**选择支持可合并、可修改、可删除的堆结构**（如PBDS优先队列、斐波那契堆、左偏树、配对堆、斜堆等）。  

### 核心算法流程与可视化设计思路  
可并堆的核心操作是**合并**（把两个堆变成一个）、**删除**（从堆中移除一个节点）、**修改**（调整节点值后维护堆性质）。可视化时，我们可以用**8位像素风**展示：  
- 每个堆用“像素方块堆”表示，小根堆的“顶”是最小的像素块（高亮显示）；  
- 合并操作：两个像素堆慢慢靠近，合并成一个新堆，伴随“叮”的音效；  
- 删除操作：目标像素块闪烁后消失，堆自动调整，伴随“啪”的音效；  
- 修改操作：目标像素块颜色变浅（表示值变小），如果破坏堆性质，会“跳”到堆顶，伴随“滴”的音效；  
- 支持“单步执行”（逐帧看操作）、“自动播放”（模拟算法流程），用颜色高亮当前操作的节点（比如合并时高亮两个堆的根，删除时高亮要删的节点）。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解，帮你快速理解不同可并堆的实现方式：
</eval_intro>

**题解一：PBDS优先队列（来源：ikunTLE）**  
* **点评**：这份题解用`__gnu_pbds`库的`priority_queue`，直接对应题目要求的所有操作——`push`存迭代器、`erase`删元素、`join`合并堆、`modify`改值。代码简洁到“一行操作对应一个题目要求”，思路直白，适合快速上手。唯一需要注意的是`pbds`的命名空间和迭代器维护，但题解里已经处理得很清楚。

**题解二：斐波那契堆（来源：bcdmwSjy）**  
* **点评**：这是最“原理派”的题解！详细解释了斐波那契堆的设计思想（懒合并、二项树结构、cut操作），实现了完整的`Node`类和`FibHeap`类，支持`push`、`join`、`pop`、`decrease`、`erase`操作。虽然代码较长，但原理讲解透彻，能帮你理解可并堆的“底层逻辑”。

**题解三：左偏树（来源：_Lamiris_）**  
* **点评**：左偏树是竞赛中常用的可并堆结构，这份题解处理了“删除元素”的关键问题——通过`root`数组维护每个集合的根，`erase`时合并左右子树并更新父节点，`modify`时删旧值再插新值。代码用快读优化，运行时间仅325ms，兼顾效率和可读性。

**题解四：配对堆（来源：strcmp）**  
* **点评**：配对堆是“自调整”可并堆，合并操作直接把一个堆作为另一个堆的子树，`pop`时两两配对合并子树。题解讲解了配对堆的`mg1`（合并）、`mg2`（配对合并）、`cut`（拆分子树）操作，代码用左儿子右兄弟法存储树，逻辑清晰，适合理解“自调整”的思想。

**题解五：斜堆（来源：Phartial）**  
* **点评**：斜堆是最简单的可并堆之一，合并时交换左右子树保持平衡。这份题解的`M`函数（合并）仅几行代码，`D`函数（删除并修改）处理了断链和重新合并。代码简洁到“令人震惊”，运行效率很高，适合喜欢“极简风格”的学习者。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决可并堆问题，最容易卡壳的是以下三个关键点：
</difficulty_intro>

### 1. 如何高效合并两个堆？  
**难点**：普通堆（如二叉堆）合并需要O(n)时间，无法处理大规模数据。  
**策略**：使用**可并堆结构**（如左偏树、斐波那契堆、配对堆），合并时间复杂度优化到O(log n)或均摊O(1)。例如左偏树通过“左偏性质”（左子树的距离≥右子树）保证合并时快速找到合适的子树；斐波那契堆用“懒合并”（先合并根链表，需要时再整理）减少合并次数。

### 2. 如何支持快速删除/修改元素？  
**难点**：删除或修改元素会破坏堆性质，需要调整堆结构，但普通堆无法快速定位元素。  
**策略**：  
- 维护**迭代器**（如PBDS优先队列的`point_iterator`），直接定位元素位置；  
- 维护**父指针/兄弟指针**（如斐波那契堆的`fa`、`l`、`r`指针，配对堆的`f`、`s`、`b`指针），删除时断开链接，修改时拆分子树再合并。

### 3. 如何维护修改后的堆性质？  
**难点**：修改元素值（如变小）可能导致父节点比子节点大，破坏堆的“父≤子”性质。  
**策略**：  
- 斐波那契堆：如果修改后的节点比父节点小，把它“cut”到根链表（`cutout`操作）；  
- 左偏树/斜堆：删除旧值，插入新值（因为题目保证修改后的值更小，新值插入后会成为堆顶附近的节点）；  
- 配对堆：把修改的节点拆出来，重新合并到堆顶（`cut`+`mg1`操作）。

### ✨ 解题技巧总结  
- **优先选现成结构**：如果允许用PBDS，直接用`__gnu_pbds::priority_queue`，代码最简洁；  
- **手写堆选左偏树/斜堆**：左偏树逻辑清晰，斜堆代码最简；  
- **维护迭代器/指针**：删除/修改操作需要定位元素，必须存迭代器或指针；  
- **利用题目条件**：题目保证修改后的值更小，所以修改操作可以简化为“删旧值+插新值”（左偏树/斜堆的常用技巧）。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**PBDS优先队列**的通用实现——它直接对应题目中的所有操作，代码最短，适合快速理解：
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码来自ikunTLE的题解，用`__gnu_pbds`的优先队列，维护每个元素的迭代器，完美匹配题目要求。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <bits/extc++.h>
using namespace std;
using namespace __gnu_pbds;

const int N = 1e6 + 10;
__gnu_pbds::priority_queue<int, greater<int>> pq[N]; // 小根堆
__gnu_pbds::priority_queue<int, greater<int>>::point_iterator it[N]; // 存每个元素的迭代器

int read() { // 快读
    int x = 0; char ch = getchar();
    while (ch < '0' || ch > '9') ch = getchar();
    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
    return x;
}

int main() {
    int n = read(), m = read();
    for (int i = 1; i <= n; ++i) {
        int x = read();
        it[i] = pq[i].push(x); // 插入元素，存迭代器
    }
    while (m--) {
        int op = read();
        if (op == 0) { // 删除操作
            int x = read(), y = read();
            pq[x].erase(it[y]);
        } else if (op == 1) { // 查询最小值
            int x = read();
            printf("%d\n", pq[x].top());
        } else if (op == 2) { // 合并堆
            int x = read(), y = read();
            pq[x].join(pq[y]);
        } else if (op == 3) { // 修改元素值
            int x = read(), y = read(), z = read();
            pq[x].modify(it[y], z);
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  1. 用`__gnu_pbds::priority_queue`定义小根堆（`greater<int>`）；  
  2. `it`数组存每个元素的迭代器（`push`返回的`point_iterator`）；  
  3. 操作0：用`erase(it[y])`删除元素y；  
  4. 操作1：用`top()`查最小值；  
  5. 操作2：用`join(pq[y])`合并堆y到堆x；  
  6. 操作3：用`modify(it[y], z)`修改元素y的值为z。  


<code_intro_selected>
再看几个手写可并堆的核心片段，帮你理解“底层逻辑”：
</code_intro_selected>

### 题解二：斐波那契堆（来源：bcdmwSjy）  
* **亮点**：实现了完整的斐波那契堆，支持`push`、`join`、`pop`、`decrease`、`erase`操作，原理讲解最详细。  
* **核心代码片段**（`FibHeap`类的`join`和`cutout`操作）：  
```cpp
class FibHeap {
    int cnt;
    Node* minp;
public:
    void join(FibHeap* b) { // 合并两个斐波那契堆
        if (b == nullptr) return;
        if (minp == nullptr) { minp = b->minp; cnt = b->cnt; }
        else if (b->minp != nullptr) {
            megl(minp, b->minp); // 合并根链表
            if (minp->key > b->minp->key) minp = b->minp;
            cnt += b->cnt;
        }
        b = nullptr;
    }
private:
    void cutout(Node* p) { // 把p从父节点拆到根链表
        p->mark = false;
        Node* fa = p->fa;
        if (fa != nullptr) {
            cut(p, fa); // 断开p与父节点的链接
            if (!fa->mark) fa->mark = true;
            else cutout(fa); // 父节点已经被mark，递归cut
        }
    }
};
```
* **代码解读**：  
  - `join`操作：合并两个斐波那契堆的根链表（`megl`函数），更新最小值指针和节点数；  
  - `cutout`操作：处理修改后的值比父节点小的情况——先把p拆到根链表，再检查父节点的`mark`标记：如果父节点没被mark，标记它；如果已经被mark，递归cut父节点（防止树变深）。  
* 💡 **学习笔记**：斐波那契堆的“懒合并”和“cut”操作是它高效的关键——合并时不整理堆，只有`pop`时才合并相同度的树；`cut`操作保持树的高度是对数级。


### 题解三：左偏树（来源：_Lamiris_）  
* **亮点**：用`root`数组维护每个集合的根，`erase`操作合并左右子树，`modify`操作删旧插新，逻辑清晰。  
* **核心代码片段**（`merge`和`erase`操作）：  
```cpp
struct ZPS { int ls, rs, dis, fa; ll val; } tree[N];
int root[N];

int merge(int x, int y) { // 左偏树合并
    if (!x || !y) return x | y;
    if (tree[x].val > tree[y].val || (tree[x].val == tree[y].val && x > y)) swap(x, y);
    tree[x].rs = merge(tree[x].rs, y);
    if (tree[tree[x].ls].dis < tree[tree[x].rs].dis) swap(tree[x].ls, tree[x].rs);
    tree[x].dis = tree[tree[x].rs].dis + 1;
    return tree[tree[x].ls].fa = tree[tree[x].rs].fa = tree[x].fa = x;
}

inline int erase(const int x, const int pos) { // 删除节点x
    int y = merge(tree[x].ls, tree[x].rs);
    if (tree[x].fa != x) { // x不是根
        tree[y].fa = tree[x].fa;
        if (tree[tree[y].fa].ls == x) tree[tree[y].fa].ls = y;
        if (tree[tree[y].fa].rs == x) tree[tree[y].fa].rs = y;
        push_up(tree[y].fa); // 更新父节点的距离
    } else root[pos] = tree[y].fa = y; // x是根，更新root
    tree[x].fa = y; tree[x].ls = tree[x].rs = 0;
    return pos;
}
```
* **代码解读**：  
  - `merge`操作：左偏树的经典合并——保证x的val≤y，合并y到x的右子树，交换左右子树保持左偏性质，更新距离；  
  - `erase`操作：合并x的左右子树得到y，若x不是根，更新父节点的子节点为y；若x是根，更新`root`数组。最后重置x的状态（变成空节点）。  
* 💡 **学习笔记**：左偏树的`dis`（距离：到最近空节点的距离）是维持平衡的关键，合并时交换左右子树保证`dis[ls] ≥ dis[rs]`，这样树的高度是O(log n)。


### 题解四：配对堆（来源：strcmp）  
* **亮点**：用左儿子右兄弟法存树，`mg2`操作两两配对合并子树，实现自调整。  
* **核心代码片段**（`mg1`和`mg2`操作）：  
```cpp
struct Node { ll w; int f, s, b; } t[maxn]; // f:父，s:左儿子，b:右兄弟
int rt[maxn];

inline int mg1(int x, int y) { // 合并两个配对堆
    if (!x || !y) return x | y;
    if (t[x].w > t[y].w) swap(x, y);
    t[y].b = t[x].s; t[t[x].s].f = y; t[x].s = y; t[y].f = x;
    return x;
}

int mg2(int x) { // 配对合并子树
    if (!x || !t[x].b) return t[x].f = 0, x;
    int u = t[x].b, v = t[u].b;
    t[u].f = 0; t[x].b = t[u].b = 0;
    return mg1(mg2(v), mg1(x, u)); // 递归合并后面的子树，再合并当前两个
}
```
* **代码解读**：  
  - `mg1`操作：合并x和y，保证x的w≤y，把y作为x的左儿子（`s[x]`），y的右兄弟（`b[y]`）设为原来的左儿子；  
  - `mg2`操作：配对合并子树——把x和右兄弟u合并，再递归合并u的右兄弟v，最后把结果合并回来。  
* 💡 **学习笔记**：配对堆的“配对合并”是它自调整的关键——`pop`时合并子树，保证树的高度是对数级，均摊时间复杂度O(log n)。


### 题解五：斜堆（来源：Phartial）  
* **亮点**：代码最简，`M`函数（合并）仅几行，`D`函数（删除并修改）处理断链和重新合并。  
* **核心代码片段**（`M`和`D`操作）：  
```cpp
struct E { int f, l, r, v; } e[kN];
int r[kN];

int M(int x, int y) { // 斜堆合并
    if (!x || !y) return x | y;
    if (e[x].v > e[y].v) swap(x, y);
    e[e[x].r = M(e[x].r, y)].f = x; swap(e[x].l, e[x].r);
    return x;
}

void D(int &r, int x, int v) { // 删除x，插入v
    int y = e[x].f;
    (y ? e[y].l == x ? e[y].l : e[y].r : r) = e[x].f = 0;
    e[x].v = v; r = M(r, x); // 重新合并x到堆
}
```
* **代码解读**：  
  - `M`操作：合并x和y，保证x的v≤y，合并y到x的右子树，交换左右子树（斜堆的“自调整”）；  
  - `D`操作：先把x从堆中拆出来（断链），修改x的v值，再把x重新合并到堆中（因为v变小，x会成为堆顶附近的节点）。  
* 💡 **学习笔记**：斜堆的“交换左右子树”是它保持平衡的关键——每次合并都交换，使得树的高度是均摊O(log n)，代码比左偏树更简洁。  


## 5. 算法可视化：像素动画演示

### 动画演示主题  
**像素可并堆实验室**（8位FC游戏风格）：用像素方块展示可并堆的`合并`、`删除`、`修改`、`查询`操作，模拟“堆管理员”处理各种请求。

### 设计思路  
用8位像素风营造复古氛围，用**颜色标记节点**（堆顶=红色，普通节点=蓝色，修改的节点=黄色，删除的节点=灰色），**音效强化操作记忆**（合并=“叮”，删除=“啪”，修改=“滴”，查询=“嘟”），支持**单步执行**（逐帧看操作）和**自动播放**（模拟算法流程），让你“看得到”可并堆的工作过程。

### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧是“堆区”（显示多个像素堆），右侧是“控制面板”（开始/暂停、单步、重置按钮，速度滑块）；  
   - 背景是8位风格的实验室（比如砖墙、仪器），播放轻松的8位BGM（比如《超级马里奥》的背景音）。

2. **操作演示**：  
   - **合并操作（op2）**：两个像素堆（比如堆x=蓝色，堆y=绿色）慢慢靠近，合并成一个新堆（蓝色+绿色渐变），伴随“叮”的音效，高亮新堆的根节点（红色）；  
   - **删除操作（op0）**：目标节点（灰色）闪烁3次，然后消失，堆自动调整（周围节点移动填补空位），伴随“啪”的音效；  
   - **修改操作（op3）**：目标节点（黄色）颜色变浅（表示值变小），如果它比父节点小，会“跳”到堆顶（红色），伴随“滴”的音效；  
   - **查询操作（op1）**：堆顶节点（红色）闪烁，旁边弹出文字“最小值：X”，伴随“嘟”的音效。

3. **交互控制**：  
   - 单步执行：点击“下一步”，看操作的每一步；  
   - 自动播放：滑动速度滑块（1x~5x），让动画自动运行；  
   - 重置：恢复初始状态，重新演示。

### 技术实现  
用**HTML5 Canvas + JavaScript**实现：  
- 像素节点用`fillRect`画方块，颜色用8位色（比如#FF0000=红色，#0000FF=蓝色）；  
- 音效用`Web Audio API`播放8位音频片段（比如合并的“叮”声存在`ding.wav`，删除的“啪”声存在`pop.wav`）；  
- 控制逻辑用JavaScript写：单步执行时更新动画帧，自动播放时用`setInterval`定时更新。


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
可并堆的核心是**高效合并**和**快速查询极值**，适用于以下场景：  
- **合并果子升级版**：合并多堆果子，每次合并两堆，求总代价（可并堆优化）；  
- **动态连通性问题**：维护多个集合，支持合并和查询最小值（比如洛谷P3377）；  
- **Dijkstra算法优化**：用可并堆（如斐波那契堆、配对堆）优化Dijkstra，降低时间复杂度（O(m + n log n)）。

### 洛谷练习推荐  
1. **P3377 【模板】左偏树/可并堆**：可并堆的基础模板，练习合并和查询最小值；  
2. **P1631 合并果子（升级版）**：用可并堆合并果子，求最小代价；  
3. **P2055 基站选址**：动态规划问题，用可并堆优化转移（删除旧基站，添加新基站）；  
4. **P4054 [JSOI2009] 计数问题**：用可并堆维护区间信息，查询第k小值。


## 7. 学习心得与经验分享

### 来自题解的经验  
- **PBDS的注意事项**（ikunTLE、wyc0607、ivyjiao）：`__gnu_pbds::priority_queue`要加`using namespace __gnu_pbds`，且不能和`std::priority_queue`重名；`push`返回的迭代器要保存，否则无法删除/修改；  
- **斐波那契堆的实现技巧**（bcdmwSjy）：用双向循环链表存根节点，`cut`操作要递归处理父节点的`mark`标记，防止树变深；  
- **左偏树的`root`数组**（_Lamiris_）：维护每个集合的根节点，`erase`时要更新父节点的子节点，`push_up`调整距离；  
- **配对堆的左儿子右兄弟法**（strcmp）：用`f`（父）、`s`（左儿子）、`b`（右兄弟）存树，合并时直接头插，`pop`时配对合并子树；  
- **斜堆的交换技巧**（Phartial）：每次合并后交换左右子树，保持树的平衡，代码最简。


## 💪 总结与鼓励  
可并堆是竞赛中非常实用的数据结构，它能帮你解决“需要合并集合并查询极值”的问题。无论是用PBDS的现成结构，还是手写左偏树/斐波那契堆，关键是理解**合并**和**维护堆性质**的逻辑。  

多写代码，多调试，比如试试用左偏树实现本题，或者用斐波那契堆优化Dijkstra——实践是掌握可并堆的最好方法！  

下次我们再一起探索更复杂的算法，比如线段树合并、平衡树套可并堆，加油！🚀

---
处理用时：135.53秒
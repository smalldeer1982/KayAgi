# 题目信息

# 楼房

## 题目描述

地平线（$x$ 轴）上有 $n$ 个楼房，每个楼房可以表示为一个矩形。

用三个整数 $h_i,l_i,r_i$ 来表示第 $i$ 个矩形：矩形左下角为 $(l_i,0)$，右上角为 $(r_i,h_i)$。

地平线高度为 $0$。在轮廓线长度最小的前提下，从左到右输出轮廓线。

## 说明/提示

样例二如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/pmf4pzif.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/5ec8sxwi.png)

数据范围:

对于 $30\%$ 的数据，$n\le100$。

对于另外 $30\%$ 的数据，$1\le h_i,l_i,r_i\le 1000$。

对于 $100\%$ 的数据，$1\le n\le10^5$，$1\le h_i\le 10^9$，$-10^9\le l_i<r_i\le10^9$。

## 样例 #1

### 输入

```
2
3 0 2
4 1 3
```

### 输出

```
6
0 0
0 3
1 3
1 4
3 4
3 0```

## 样例 #2

### 输入

```
5
3 -3 0
2 -1 1
4 2 4
2 3 7
3 6 8```

### 输出

```
14
-3 0
-3 3
0 3
0 2
1 2
1 0
2 0
2 4
4 4
4 2
6 2
6 3
8 3
8 0```

# AI分析结果



---
# 💡 Kay的C++算法解析：楼房 深入学习指南 💡

<introduction>
今天我们来一起分析“楼房”这道C++编程题。这道题需要计算多个矩形楼房的轮廓线，要求轮廓线长度最小并输出其坐标。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`扫描线与线段树/堆的综合应用`

🗣️ **初步分析**：
解决“楼房”这道题，关键在于理解并运用**扫描线算法**。简单来说，扫描线就像一把“虚拟的尺子”，从左到右扫描所有楼房的左右边界，同时维护当前扫描位置的最大高度，从而确定轮廓线的拐点。这类似于在游戏中“绘制天际线”——每当遇到新的楼房边界时，调整当前最高高度，记录高度变化的点。

在本题中，扫描线算法的核心步骤是：  
1. **离散化处理**：由于坐标范围极大（-1e9到1e9），需要将所有楼房的左右边界收集后排序去重，压缩成离散的点，方便后续处理。  
2. **事件排序**：将每个楼房的左边界（入边）和右边界（出边）作为事件，按x坐标排序。若x相同，入边优先于出边（避免漏记录拐点）；若同为入边，高的优先（因为高的会覆盖低的）；若同为出边，矮的优先（同理）。  
3. **维护当前最大高度**：使用堆（如multiset）或线段树动态维护当前扫描线位置的最大高度。当遇到入边时，将该高度加入堆；遇到出边时，从堆中移除该高度。  
4. **记录拐点**：每当当前最大高度变化时，记录两个点（旧高度到新高度的转折点）。

可视化设计思路：采用8位像素风格，用横向的像素网格表示x轴，每个像素块代表一个离散化后的坐标点。扫描线用一个向右移动的黄色箭头表示，堆中的高度用堆叠的彩色方块（高度越高颜色越亮）动态展示。当处理入边时，对应高度的方块“弹入”堆顶；处理出边时，对应方块“弹出”。拐点生成时，用红色闪烁标记，并同步显示对应的坐标和高度变化。


## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解表现突出（≥4星）：
</eval_intro>

**题解一：shuri001（扫描线+multiset）**
* **点评**：此题解思路清晰，代码注释详细。通过将每个楼房拆分为入边和出边，排序后用multiset维护当前高度，处理边界情况（如多个相同高度的出边）时逻辑严谨。代码中对入边和出边的排序规则（入边高的优先、出边矮的优先）是关键亮点，确保了轮廓线的正确生成。实践价值高，可直接用于竞赛。

**题解二：xiaolou（线段树+离散化）**
* **点评**：此题解采用线段树维护区间最大高度，离散化处理坐标后，通过区间更新和单点查询生成轮廓线。代码结构工整，变量名（如`le`、`ri`、`mx`）含义明确，边界处理（如`y[i]-1`）考虑周全。线段树的延迟标记（lazy tag）优化了区间更新效率，适合学习线段树的应用场景。

**题解三：Flanksy（并查集优化暴力）**
* **点评**：此题解思路新颖，利用并查集优化暴力染色。将楼房按高度从高到低排序，依次覆盖区间，已覆盖的区间用并查集跳过，确保每个点仅被处理一次。时间复杂度均摊O(n log n)，代码简洁高效，适合理解“优先级覆盖”问题的通用解法。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼核心思考方向：
</difficulty_intro>

1.  **关键点1：如何处理离散化后的坐标？**  
    * **分析**：原始坐标范围极大（-1e9到1e9），直接处理会导致内存和时间超限。优质题解通常将所有楼房的左右边界收集后排序去重，得到离散化的坐标数组（如`a[]`），并通过`lower_bound`将原始坐标映射到离散化后的索引。例如，shuri001将每个楼房的左右边界存入`l[]`数组，排序后去重，后续操作均基于离散化后的索引。  
    * 💡 **学习笔记**：离散化是处理大范围坐标问题的“必选动作”，关键是将原始坐标映射到连续的整数索引。

2.  **关键点2：如何维护当前最大高度？**  
    * **分析**：维护当前最大高度是生成轮廓线的核心。扫描线+堆的解法中，用`multiset`（支持重复元素）存储当前高度，取`rbegin()`得到最大值；线段树解法中，用线段树维护区间最大值，通过延迟标记优化更新。例如，shuri001的`multiset<int> s`始终保存当前有效高度，入边时插入，出边时删除，确保`*s.rbegin()`是当前最大高度。  
    * 💡 **学习笔记**：堆（或multiset）适合动态维护最大值，线段树适合区间更新和查询，根据问题场景选择合适的数据结构。

3.  **关键点3：如何正确记录拐点？**  
    * **分析**：拐点出现在当前最大高度变化的位置。例如，当处理入边时，若新高度高于当前最大值，需记录旧高度到新高度的转折点；处理出边时，若删除的是当前最大值，需记录旧高度到新最大值的转折点。优质题解通过比较处理前后的最大高度（如`mx`和`*s.rbegin()`）来判断是否生成拐点。  
    * 💡 **学习笔记**：拐点的生成条件是“当前最大高度变化”，需严格比较处理前后的高度值。

### ✨ 解题技巧总结
<summary_best_practices>
- **事件排序规则**：入边优先于出边（x相同），入边按高度降序（高的先处理），出边按高度升序（矮的先处理）。  
- **边界处理细节**：线段树区间更新时，楼房的右边界需减1（如`y[i]-1`），因为轮廓线是区间`[l_i, r_i)`的最高点。  
- **去重与合并**：离散化后需去重，避免重复处理相同坐标；生成拐点后，合并连续相同高度的区间，避免冗余点。


## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合扫描线+堆的通用核心实现，它清晰展示了解题的完整流程。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了shuri001的扫描线+multiset思路，代码简洁高效，关键逻辑清晰，适合学习。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <set>
    #include <algorithm>
    using namespace std;

    struct Event {
        int x, h, type; // type=1:入边（左边界）, type=2:出边（右边界）
        bool operator<(const Event& other) const {
            if (x != other.x) return x < other.x;
            if (type != other.type) return type < other.type; // 入边先于出边
            return type == 1 ? h > other.h : h < other.h; // 入边高的优先，出边矮的优先
        }
    } events[200020];

    int main() {
        int n, cnt = 0;
        scanf("%d", &n);
        for (int i = 0; i < n; ++i) {
            int h, l, r;
            scanf("%d%d%d", &h, &l, &r);
            events[cnt++] = {l, h, 1};
            events[cnt++] = {r, h, 2};
        }
        sort(events, events + cnt);

        multiset<int> heights;
        heights.insert(0); // 初始高度为0
        int prev_h = 0, ans_cnt = 0;
        int ans_x[400040], ans_y[400040];

        for (int i = 0; i < cnt; ) {
            int x = events[i].x;
            // 处理所有x相同的事件
            while (i < cnt && events[i].x == x) {
                if (events[i].type == 1) {
                    heights.insert(events[i].h);
                } else {
                    auto it = heights.find(events[i].h);
                    if (it != heights.end()) heights.erase(it);
                }
                ++i;
            }
            int current_h = *heights.rbegin();
            if (current_h != prev_h) {
                ans_x[ans_cnt] = x;
                ans_y[ans_cnt++] = prev_h;
                ans_x[ans_cnt] = x;
                ans_y[ans_cnt++] = current_h;
                prev_h = current_h;
            }
        }

        printf("%d\n", ans_cnt);
        for (int i = 0; i < ans_cnt; ++i) {
            printf("%d %d\n", ans_x[i], ans_y[i]);
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入，将每个楼房拆分为入边和出边，按规则排序。然后用`multiset`维护当前高度，扫描所有事件。处理每个事件时，更新`multiset`中的高度，若当前最大高度变化则记录拐点。最后输出所有拐点坐标。


<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其中的巧妙设计。
</code_intro_selected>

**题解一：shuri001（扫描线+multiset）**
* **亮点**：事件排序规则（入边高优先、出边矮优先）确保了高度覆盖的正确性；`multiset`处理重复高度时，通过`count`和`erase`精确删除目标高度。
* **核心代码片段**：
    ```cpp
    multiset<int> s; // 存当前高度，默认递增，可重复
    int cmp(line i, line j) {
        if (i.x != j.x) return i.x < j.x;
        if (i.k != j.k) return i.k < j.k; // 入边（k=1）先于出边（k=2）
        if (i.k == 1) return i.up > j.up; // 入边高的优先
        return i.up < j.up; // 出边矮的优先
    }
    ```
* **代码解读**：  
  `cmp`函数定义了事件的排序规则：x小的优先；x相同时，入边先于出边；同为入边时，高的先处理（避免被低的覆盖）；同为出边时，矮的先处理（避免误删最高高度）。这一规则确保了扫描线处理事件的顺序正确，是生成正确轮廓线的关键。  
* 💡 **学习笔记**：事件排序规则的设计直接影响算法正确性，需根据问题逻辑仔细推敲。

**题解二：xiaolou（线段树+离散化）**
* **亮点**：线段树区间更新+延迟标记，高效维护区间最大高度；离散化后通过`lower_bound`映射坐标，处理大范围问题。
* **核心代码片段**：
    ```cpp
    void Change(int id, int l, int r, int c) {
        if (t[id].le == l && t[id].ri == r) {
            t[id].mx = max(t[id].mx, c);
            return;
        }
        Push(id); // 下传延迟标记
        if (r <= t[id*2].ri) Change(id*2, l, r, c);
        else if (l >= t[id*2+1].le) Change(id*2+1, l, r, c);
        else {
            Change(id*2, l, t[id*2].ri, c);
            Change(id*2+1, t[id*2+1].le, r, c);
        }
    }
    ```
* **代码解读**：  
  `Change`函数实现线段树的区间更新。若当前节点区间完全包含在目标区间内，则更新该节点的最大值；否则下传延迟标记，递归处理左右子节点。延迟标记（`Push`函数）确保了区间更新的高效性，避免重复计算。  
* 💡 **学习笔记**：线段树的延迟标记是处理区间更新问题的核心技巧，能将时间复杂度从O(n)优化到O(log n)。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解扫描线算法如何生成轮廓线，我们设计一个“像素天际线探险”动画，用8位复古风格展示扫描线移动、高度变化和拐点生成的全过程。
</visualization_intro>

  * **动画演示主题**：`像素小人的天际线探险`  
  * **核心演示内容**：扫描线从左到右移动，遇到楼房边界时调整当前最大高度（用堆叠的彩色方块表示），高度变化时生成拐点（红色闪烁点）。

  * **设计思路简述**：  
    采用FC红白机的8位像素风格（如《超级玛丽》的简洁色块），让学习过程更轻松。扫描线用黄色箭头表示，每移动到一个事件点（入边或出边）时，播放“叮”的音效；高度变化时，用颜色渐变的方块堆叠显示当前最大高度；拐点生成时，用红色像素点闪烁并弹出文字提示，帮助学习者“看到”算法的每一步逻辑。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：  
       屏幕下方显示x轴（像素网格），每个网格对应离散化后的坐标点；右侧显示当前高度堆叠区（用绿色方块堆叠，高度越高颜色越亮）；底部控制面板包含“单步”“自动播放”“调速”按钮。

    2. **事件排序与扫描线移动**：  
       所有事件（入边/出边）以蓝色/红色小旗形式插在x轴对应位置。扫描线（黄色箭头）从最左端开始，每次移动到下一个事件点，播放“唰”的音效。

    3. **处理入边（左边界）**：  
       当扫描线到达入边（蓝色小旗），对应高度的绿色方块“弹入”堆叠区（播放“噗”的音效）。若新高度高于当前最大高度，堆叠区顶部的方块颜色变为亮绿色，触发拐点生成：在x轴该位置生成两个红色像素点（旧高度→新高度），并显示坐标和高度值。

    4. **处理出边（右边界）**：  
       当扫描线到达出边（红色小旗），对应高度的绿色方块“弹出”堆叠区（播放“咻”的音效）。若删除的是当前最大高度，堆叠区顶部的方块颜色变为普通绿色，触发拐点生成：在x轴该位置生成两个红色像素点（旧高度→新最大高度）。

    5. **自动演示与调速**：  
       点击“自动播放”，扫描线自动从左到右移动，速度可通过滑块调整（慢→快）；点击“单步”，每次处理一个事件点，适合仔细观察细节。

    6. **目标达成提示**：  
       扫描线到达最右端时，所有拐点生成完毕，播放“胜利”音效（如《超级玛丽》的通关音乐），并显示最终轮廓线的完整路径。

  * **旁白提示**：  
    - （扫描线移动时）“现在扫描线移动到了x坐标[X]，这里有一个[入/出]边事件。”  
    - （处理入边时）“这个楼房的高度是[H]，将它加入当前高度堆！”  
    - （高度变化时）“当前最大高度从[旧H]变为[新H]，生成两个拐点！”


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
扫描线算法和线段树/堆的应用不仅限于此题，还可解决多种区间覆盖、最大值维护问题。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    扫描线算法的核心是“将二维问题降为一维”，通过事件排序和动态维护状态（如高度、覆盖次数）解决问题。类似地，它还可用于：  
    - 计算矩形面积并（如洛谷P5490）；  
    - 求矩形周长（如洛谷P1856）；  
    - 动态区间最大值查询（如洛谷P1904）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P5490 【模板】扫描线**  
        * 🗣️ **推荐理由**：直接考察扫描线算法计算矩形面积并，是本题的基础拓展，适合巩固扫描线逻辑。  
    2.  **洛谷 P1904 天际线**  
        * 🗣️ **推荐理由**：与本题几乎完全相同，可验证扫描线+堆解法的掌握程度。  
    3.  **洛谷 P1856 [USACO5.5]矩形周长**  
        * 🗣️ **推荐理由**：在扫描线基础上增加周长计算，需同时维护水平和垂直边界，适合提升综合应用能力。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自 shuri001)**：“在处理出边时，若当前高度是最大值且堆中只有一个该高度，需先记录旧高度，再删除并获取新最大值。一开始忘记判断`count(mx)==1`，导致重复记录拐点，调试时通过打印堆的内容才发现问题。”

> **点评**：shuri001的经验提醒我们，处理边界条件（如“唯一最大值”）时需特别谨慎。调试时打印关键变量（如堆的内容、当前最大高度）是定位问题的有效方法。在编程中，对“是否唯一”“是否为最大值”等条件的判断，往往是避免错误的关键。


<conclusion>
本次关于“楼房”的C++解题分析就到这里。希望这份学习指南能帮助大家理解扫描线算法的核心逻辑，掌握线段树、堆等数据结构的应用技巧。记住，多动手调试、多思考边界条件，是提升算法能力的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：175.82秒
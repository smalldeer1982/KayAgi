# 题目信息

# [TJOI2013] 奖学金

## 题目背景

小张最近发表了一篇论文，有一个神秘人物要给小张学院发奖学金。

## 题目描述

小张学院有 $c$ 名学生，第 $i$ 名学生的成绩为 $a_i$，要获得的奖学金金额为 $b_i$。  
要从这 $c$ 名学生中挑出 $n$ 名学生发奖学金。这个神秘人物爱好奇特，他希望得到奖学金的同学的**成绩**的**中位数**尽可能大，但同时，他们的**奖学金总额**不能超过 $f$。


## 说明/提示

### 样例 1 解释

选择成绩为 $5$，$35$，$50$ 的三名同学，奖金总额为 $18 + 30 + 21 = 69$。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10^3$，$c \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $3 \leq n  \leq 10^5$，$n \leq c \leq 2 \times 10^5$，$0 \leq f \leq 2\times 10^9$，$0 \leq a_i \leq 2 \times 10^9$，$0 \leq b_i \leq 10^5$。

## 样例 #1

### 输入

```
3 5 70
30 25
50 21
20 20
5 18
35 30
```

### 输出

```
35```

## 样例 #2

### 输入

```
5 6 9
4 0
4 1
6 3
8 0
10 4
10 5
```

### 输出

```
6```

# AI分析结果



---
# 💡 Kay的C++算法解析：[TJOI2013] 奖学金 深入学习指南 💡

<introduction>
今天我们来一起分析“[TJOI2013] 奖学金”这道C++编程题。这道题的核心是在满足奖学金总额限制的条件下，找到能使中位数最大的学生集合。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`贪心+数据结构优化`（优先队列/主席树维护区间前k小和）

🗣️ **初步分析**：
> 解决这道题的关键在于两点：一是通过贪心思想选择最小奖学金的学生，二是用高效数据结构（如优先队列或主席树）快速计算区间前k小的和。  
> 简单来说，贪心思想就像“挑糖果”——我们想选最甜的糖果（最大中位数），但总花费不能超预算。为了找到最甜的糖果，我们需要先把所有糖果按甜度排序（成绩排序），然后逐个试：假设当前试到第i颗糖果（中位数候选），那么需要从它左边选k颗最便宜的（k=(n-1)/2），右边也选k颗最便宜的，加上它自己的花费，看总花费是否在预算内。  
> 核心难点在于如何高效计算“左边k颗最便宜”和“右边k颗最便宜”的和。优质题解中主要用两种方法：  
> - **优先队列（大根堆）**：维护当前最小的k个数，堆顶是最大的那个，遇到更小的数就替换堆顶，保持堆内始终是最小的k个。  
> - **主席树（可持久化线段树）**：通过历史版本记录每个位置的前缀/后缀信息，快速查询区间前k小的和。  
> 可视化设计上，我们可以用像素风格展示排序后的学生数组，用“高亮方块”表示当前枚举的中位数，用动态堆动画（方块堆叠）展示左右两边如何筛选最小k个奖学金，关键操作（如替换堆顶）配合“叮”的音效，让算法过程更直观。

---

## 2. 精选优质题解参考

<eval_intro>
通过对思路清晰度、代码规范性、算法有效性等维度的评估，以下3篇题解因逻辑直白、实现高效且易于学习，被选为优质参考：
</eval_intro>

**题解一：作者ycyaw (赞：4)**
* **点评**：这道题解思路非常清晰，直接采用优先队列（大根堆）维护左右前缀的最小和。代码结构工整，变量名（如`suma`、`sumb`）含义明确，边界处理严谨（如枚举范围限制为`n/2+1`到`c-n/2`）。算法上，通过两次遍历（从左到右和从右到左）预处理出每个位置的左右最小和，时间复杂度O(c log k)，适合竞赛环境。其调试经验（如“忘记乘以k”的错误）也提醒我们注意细节。

**题解二：作者胖头鱼学员 (赞：10)**
* **点评**：此题解用优先队列实现了前后缀最小和的预处理，代码逻辑简洁。`Work`函数通过控制遍历方向（`l`参数）复用了堆维护逻辑，体现了代码的模块化思想。变量`f[2][N]`分别存储左右前缀和，设计巧妙。实践价值高，适合快速上手。

**题解三：作者ix35 (赞：3)**
* **点评**：此题解用权值线段树维护前k小和，虽然实现稍复杂，但展示了线段树在区间查询中的应用。`add`和`query`函数逻辑清晰，适合想深入理解线段树的学习者。其“清空数组”的操作提醒我们注意数据结构的状态管理。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下几个关键点。结合优质题解的共性，提炼出核心策略：
</difficulty_intro>

1.  **关键点1：如何确定枚举范围？**
    * **分析**：中位数的位置i必须满足左边至少有k个学生（k=(n-1)/2），右边也至少有k个学生。因此枚举范围是`k+1 ≤ i ≤ c -k`（例如n=3时，k=1，i从2到c-1）。优质题解通过排序后直接限制循环范围（如`for(int i = k+1; i <= c -k; i++)`）解决。
    * 💡 **学习笔记**：枚举前先明确边界，避免越界或无效计算。

2.  **关键点2：如何高效维护区间前k小的和？**
    * **分析**：优先队列（大根堆）是最优选择。堆内保存当前最小的k个数，堆顶是其中最大的。当新数比堆顶小时，替换堆顶，这样堆内始终是最小的k个。例如，左边预处理时，从左到右遍历，每次将当前数加入堆，若堆大小超过k则弹出堆顶，最终堆内和即为前k小的和。
    * 💡 **学习笔记**：大根堆适合“维护前k小”，小根堆适合“维护前k大”，根据需求选择。

3.  **关键点3：如何处理边界条件？**
    * **分析**：当n=1时（虽然题目中n≥3），或c恰好等于n时，需要确保左右都有足够的学生。优质题解通过初始化时的特判（如`if(i <=k)`直接累加前k个数）和循环范围限制（如`i <=c -k`）避免了越界。
    * 💡 **学习笔记**：边界条件是调试的重灾区，多写测试用例验证。

### ✨ 解题技巧总结
- **排序预处理**：先按成绩排序，将问题转化为“固定中位数后选左右k个”。
- **堆的复用**：左右前缀和的预处理可以通过两次遍历（从左到右和从右到左）复用堆的逻辑，减少代码冗余。
- **变量命名规范**：如`suma[i]`表示前i个学生中前k小的和，清晰的命名提升代码可读性。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，先来看一个综合优质题解思路的通用核心实现，基于优先队列（大根堆），简洁高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了ycyaw和胖头鱼学员的思路，用优先队列预处理左右前缀和，逻辑清晰，适合竞赛环境。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <queue>
    #include <algorithm>
    using namespace std;

    const int MAXN = 2e5 + 10;
    int n, c, f;
    struct Student {
        int score, money;
    } stu[MAXN];
    long long suma[MAXN], sumb[MAXN]; // 左右前缀前k小的和

    bool cmp(const Student& a, const Student& b) {
        return a.score < b.score; // 按成绩升序排序
    }

    int main() {
        scanf("%d%d%d", &n, &c, &f);
        int k = (n - 1) / 2; // 左右各选k个
        for (int i = 1; i <= c; ++i) {
            scanf("%d%d", &stu[i].score, &stu[i].money);
        }
        sort(stu + 1, stu + c + 1, cmp);

        // 预处理左边前k小的和
        priority_queue<int> q;
        long long sum = 0;
        for (int i = 1; i <= k; ++i) {
            q.push(stu[i].money);
            sum += stu[i].money;
        }
        for (int i = k + 1; i <= c - k; ++i) {
            suma[i] = sum;
            if (stu[i].money < q.top()) {
                sum -= q.top();
                sum += stu[i].money;
                q.pop();
                q.push(stu[i].money);
            }
        }

        // 预处理右边前k小的和
        while (!q.empty()) q.pop();
        sum = 0;
        for (int i = c; i > c - k; --i) {
            q.push(stu[i].money);
            sum += stu[i].money;
        }
        for (int i = c - k; i >= k + 1; --i) {
            sumb[i] = sum;
            if (stu[i].money < q.top()) {
                sum -= q.top();
                sum += stu[i].money;
                q.pop();
                q.push(stu[i].money);
            }
        }

        // 枚举中位数，找最大的score
        int ans = -1;
        for (int i = k + 1; i <= c - k; ++i) {
            if (suma[i] + sumb[i] + stu[i].money <= f) {
                ans = stu[i].score;
            }
        }
        printf("%d\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先按成绩升序排序学生。预处理左边时，用大根堆维护前k小的奖学金，遍历到i时，suma[i]存储前i-1个学生中前k小的和。同理预处理右边的sumb[i]。最后枚举每个可能的中位数i，判断总花费是否≤f，取最大的score。

---
<code_intro_selected>
接下来剖析优质题解的核心代码片段，理解其实现细节。
</code_intro_selected>

**题解一：作者ycyaw**
* **亮点**：用两个优先队列分别处理左右前缀和，代码简洁，边界处理严谨。
* **核心代码片段**：
    ```cpp
    // 预处理左边前k小的和
    for(int i=1;i<=n/2;i++)
        q.push(z[i].b),suma[i]=suma[i-1]+z[i].b;
    for(int i=n/2+1;i<=c-n/2;i++){
        if(z[i].b<q.top())suma[i]=suma[i-1]-q.top()+z[i].b,q.pop(),q.push(z[i].b);
        else suma[i]=suma[i-1];
    }
    ```
* **代码解读**：
    > 初始时，前n/2个学生的奖学金直接加入堆，suma[i]累加。后续遍历到i时，若当前奖学金比堆顶小（更优），则替换堆顶，更新suma[i]。这保证了suma[i]始终是前i-1个学生中前k小的和。例如，当i=k+1时，suma[k+1]就是前k个学生的最小和；i=k+2时，若新学生的奖学金更小，堆顶被替换，suma[k+2]更新为更优的和。
* 💡 **学习笔记**：堆顶是当前堆中的最大值，替换堆顶能保证堆内始终是最小的k个元素。

**题解二：作者胖头鱼学员**
* **亮点**：通过`Work`函数复用堆维护逻辑，减少代码冗余。
* **核心代码片段**：
    ```cpp
    void Work(int u, int v, bool l) {
        int sum = 0, i;
        priority_queue<int> q;
        for (i = l ? c : 1; l ? i > u : i < u ; i += I[l]) {
            sum += a[i].w;
            q.push(a[i].w);
        }
        for (; l ? i >= v : i <= v; i += I[l]) {
            f[l][i] = sum;
            int top = q.top();
            if (top > a[i].w) {
                q.pop();
                sum -= top;
                sum += a[i].w;
                q.push(a[i].w);
            }
        }
    }
    ```
* **代码解读**：
    > `Work`函数通过参数`l`控制遍历方向（左到右或右到左）。初始时，将前k个学生的奖学金加入堆，计算初始和。后续遍历中，若当前学生奖学金比堆顶小，则替换堆顶，更新和。`f[l][i]`存储对应方向的前k小和。例如，`l=0`时从左到右，`f[0][i]`是i左边前k小的和；`l=1`时从右到左，`f[1][i]`是i右边前k小的和。
* 💡 **学习笔记**：函数复用能提升代码简洁性，但需注意参数设计清晰。

**题解三：作者ix35**
* **亮点**：用权值线段树维护前k小和，适合深入理解线段树应用。
* **核心代码片段**：
    ```cpp
    void add (int p,int l,int r,int pos) {
        siz[p]++,val[p]+=pos;
        if (l==r) return;
        int mid=(l+r)>>1;
        if (pos<=mid) add(p*2,l,mid,pos);
        else add(p*2+1,mid+1,r,pos);
    }
    ll query (int p,int l,int r,int k) {
        if (l==r) return l*k;
        int mid=(l+r)>>1;
        if (siz[p*2]>=k) return query(p*2,l,mid,k);
        else return val[p*2]+query(p*2+1,mid+1,r,k-siz[p*2]);
    }
    ```
* **代码解读**：
    > `add`函数在线段树中插入一个奖学金值，更新节点的大小（siz）和总和（val）。`query`函数查询前k小的和：若左子树的大小≥k，递归左子树；否则，取左子树的总和，递归右子树查询剩余部分。例如，当k=3，左子树有2个元素，右子树需要查询1个，总和为左子树总和+右子树查询结果。
* 💡 **学习笔记**：线段树适合需要频繁区间查询的场景，但实现较复杂，优先队列更适合本题。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“如何用优先队列维护前k小和”，我们设计一个8位像素风格的动画，模拟学生排序、堆维护和中位数枚举的过程。
</visualization_intro>

  * **动画演示主题**：`奖学金大冒险——寻找最大中位数`

  * **核心演示内容**：
    学生按成绩升序排列成一行像素方块（颜色越暖成绩越高）。枚举每个学生作为中位数时，左右两侧各弹出一个“堆窗口”，窗口内用堆叠的像素块表示当前堆中的奖学金（堆顶是最大的块，红色高亮）。当新学生的奖学金（蓝色块）比堆顶小时，堆顶块（红色）被弹出，新块（蓝色）加入堆，总和更新（数字显示）。最终找到第一个总花费≤f的中位数，触发“胜利”动画。

  * **设计思路简述**：
    8位像素风（如FC游戏）降低学习压力；堆窗口的动态变化直观展示“替换堆顶”的核心操作；颜色高亮（红色堆顶、蓝色新块）突出关键步骤；音效（“叮”表示替换，“胜利”音表示找到解）强化记忆。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
        - 屏幕下方显示排序后的学生（c个像素方块，颜色从冷到暖代表成绩从低到高）。
        - 左右两侧各有一个“堆窗口”（矩形框），顶部显示“前k小和”的数值。
        - 控制面板：单步/自动播放按钮，速度滑块（1-5倍速）。

    2.  **预处理左边前k小和**：
        - 前k个学生（最左边的k个冷色方块）依次“飞”入左堆窗口，堆叠成大根堆（最大的在顶部，红色），和数值累加。
        - 后续学生逐个向右移动，当前学生（绿色高亮）与左堆顶（红色）比较：若更小，堆顶弹出（红色块消失），当前学生（蓝色）飞入堆窗口，和数值更新。

    3.  **预处理右边前k小和**：
        - 类似左边，但从右往左处理，右堆窗口显示右边前k小的和。

    4.  **枚举中位数**：
        - 学生逐个作为中位数（黄色高亮），计算左堆和+右堆和+自身奖学金，与f比较。
        - 若总花费≤f，中位数方块变为金色，触发“胜利”音效（上扬音调）和烟花动画；否则继续枚举。

    5.  **交互控制**：
        - 单步执行：每点击一次，执行一个学生的处理（预处理或枚举）。
        - 自动播放：按设定速度连续执行，可暂停/重置。
        - 代码同步：屏幕右侧显示对应C++代码片段，高亮当前执行行（如`if (stu[i].money < q.top())`）。

  * **旁白提示**：
    - “现在处理左边第i个学生，堆顶是当前最大的奖学金，若新学生的奖学金更小，就替换堆顶！”
    - “看，总和更新了！这就是前k小的和。”
    - “找到啦！这个中位数的总花费不超预算，它就是答案！”

<visualization_conclusion>
通过这个动画，我们能直观看到优先队列如何动态维护前k小的和，以及中位数枚举的全过程，轻松理解算法核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是“贪心+数据结构维护区间前k小和”，这种思路可迁移到多种场景。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - **Top K问题**：如“找数组中前k小的数”（堆/快速选择）。
    - **滑动窗口最值**：如“滑动窗口的中位数”（双堆维护）。
    - **区间查询优化**：如“动态区间第k小”（主席树/线段树）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1801 黑匣子** - 动态维护区间第k小
          * 🗣️ **推荐理由**：练习用堆或线段树处理动态插入和查询第k小，与本题维护前k小和的思路类似。
    2.  **洛谷 P1090 合并果子** - 贪心+优先队列
          * 🗣️ **推荐理由**：用小根堆维护每次合并的最小代价，强化堆的应用。
    3.  **洛谷 P3871 [TJOI2010] 中位数** - 动态维护中位数
          * 🗣️ **推荐理由**：练习双堆（大根堆+小根堆）维护中位数，与本题枚举中位数的思路互补。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时的错误，这些经验对我们很有参考价值：
</insights_intro>

> **参考经验 (来自作者渡墨残殇)**：“我在写主席树查询时，忘记在叶子节点返回`k*b[l]`，导致结果错误，调了两天才发现。”

> **点评**：这个错误提醒我们，在处理重复元素或区间和时，必须考虑同一值的多个元素。例如，当多个学生的奖学金相同时，叶子节点的查询需要返回`k*值`，而不是单个值。这在类似问题中（如统计区间和）很容易出错，调试时应重点检查边界条件和叶子节点的处理。

-----

<conclusion>
本次关于“[TJOI2013] 奖学金”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握贪心+数据结构的核心思路，以及优先队列、线段树等数据结构的应用。记住，多动手调试、多思考边界条件，是提升编程能力的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：201.02秒
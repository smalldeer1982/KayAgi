# 题目信息

# [NOI2014] 动物园

## 题目描述

近日，园长发现动物园中好吃懒做的动物越来越多了。例如企鹅，只会卖萌向游客要吃的。为了整治动物园的不良风气，让动物们凭自己的真才实学向游客要吃的，园长决定开设算法班，让动物们学习算法。

某天，园长给动物们讲解 KMP 算法。

园长：“对于一个字符串 $S$，它的长度为 $L$。我们可以在 $O(L)$ 的时间内，求出一个名为 $\mathrm{next}$ 的数组。有谁预习了 $\mathrm{next}$ 数组的含义吗？”

熊猫：“对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀又是它的前缀的字符串中（它本身除外），最长的长度记作 $\mathrm{next}[i]$。”

园长：“非常好！那你能举个例子吗？”

熊猫：“例 $S$ 为 $\verb!abcababc!$，则 $\mathrm{next}[5]=2$。因为$S$的前$5$个字符为 $\verb!abcab!$，$\verb!ab!$ 既是它的后缀又是它的前缀，并且找不到一个更长的字符串满足这个性质。同理，还可得出 $\mathrm{next}[1] = \mathrm{next}[2] = \mathrm{next}[3] = 0$，$\mathrm{next}[4] = \mathrm{next}[6] = 1$，$\mathrm{next}[7] = 2$，$\mathrm{next}[8] = 3$。”

园长表扬了认真预习的熊猫同学。随后，他详细讲解了如何在 $O(L)$ 的时间内求出 $\mathrm{next}$ 数组。

下课前，园长提出了一个问题：“KMP 算法只能求出 $\mathrm{next}$ 数组。我现在希望求出一个更强大 $\mathrm{num}$ 数组一一对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作 $\mathrm{num}[i]$。例如 $S$ 为 $\verb!aaaaa!$，则 $\mathrm{num}[4] = 2$。这是因为$S$的前 $4$ 个字符为 $\verb!aaaa!$，其中 $\verb!a!$ 和 $\verb!aa!$ 都满足性质‘既是后缀又是前缀’，同时保证这个后缀与这个前缀不重叠。而 $\verb!aaa!$ 虽然满足性质‘既是后缀又是前缀’，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，$\mathrm{num}[1] = 0,\mathrm{num}[2] = \mathrm{num}[3] = 1,\mathrm{num}[5] = 2$。”

最后，园长给出了奖励条件，第一个做对的同学奖励巧克力一盒。听了这句话，睡了一节课的企鹅立刻就醒过来了！但企鹅并不会做这道题，于是向参观动物园的你寻求帮助。你能否帮助企鹅写一个程序求出$\mathrm{num}$数组呢？

特别地，为了避免大量的输出，你不需要输出 $\mathrm{num}[i]$ 分别是多少，你只需要输出所有 $(\mathrm{num}[i]+1)$ 的乘积，对 $10^9 + 7$ 取模的结果即可。


## 说明/提示

测试点编号| 约定
-|-  
1| $n \le 5, L \le 50$  
2| $n \le 5, L \le 200$  
3| $n \le 5, L \le 200$  
4| $n \le 5, L \le 10,000$  
5| $n \le 5, L \le 10,000$  
6| $n \le 5, L \le 100,000$  
7| $n \le 5, L \le 200,000$   
8| $n \le 5, L \le 500,000$  
9| $n \le 5, L \le 1,000,000$  
10| $n \le 5, L \le 1,000,000$  


## 样例 #1

### 输入

```
3
aaaaa
ab
abcababc```

### 输出

```
36
1
32 ```

# AI分析结果



---

# 💡 Kay的C++算法解析：NOI2014 动物园 深入学习指南 💡

<introduction>
今天我们来一起分析NOI2014的经典题目“动物园”。这道题需要我们利用KMP算法的扩展应用，计算每个前缀的不重叠公共前后缀数量，并最终求所有结果的乘积。通过本指南，你将掌握KMP的进阶技巧，理解如何高效解决类似字符串问题。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串处理（KMP算法扩展应用）`

🗣️ **初步分析**：
解决这道题的关键在于理解KMP算法中的`next`数组，并在此基础上扩展计算`num`数组。KMP的`next`数组记录了每个前缀的最长公共前后缀（不包含自身），而本题的`num`数组要求统计所有**不重叠**的公共前后缀的数量。

简单来说，KMP算法就像一个“智能指针”，通过记录已匹配的最长前缀长度，避免重复比较。在本题中，我们需要在KMP的基础上做两件事：  
1. 统计每个前缀的所有公共前后缀数量（包括较短的）；  
2. 筛选出长度不超过当前前缀一半的公共前后缀（避免重叠）。  

### 核心思路与难点：
- **公共前后缀计数**：利用KMP的`next`数组递推。例如，`num[i]`表示前i个字符的公共前后缀数量，可通过`num[next[i]] + 1`递推得到（因为`next[i]`的公共前后缀也是i的公共前后缀）。  
- **不重叠筛选**：对于每个前缀i，需要找到最大的j（j ≤ i/2），使得j是i的公共前后缀，此时`num[i]`即为`num[j]`。这一步通过调整KMP的指针j实现，避免暴力跳`next`导致超时。  

### 可视化设计思路：
我们将用8位像素风格动画演示KMP的`next`数组计算和`num`数组调整过程。例如，用不同颜色的像素块表示当前处理的字符，用箭头表示`next`指针的跳转；当调整j以满足不重叠条件时，用闪烁效果高亮关键步骤，并配合“叮”的音效提示关键操作。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性的评估，以下题解评分≥4星，值得重点学习：
</eval_intro>

### **题解一：Orion545（赞220）**
* **点评**：此题解深入解释了KMP的`fail树`概念（即`next`数组构成的树结构），并指出`num`数组本质是树中节点的深度。代码通过两次KMP过程（一次计算`next`和`num`，一次调整j满足不重叠），时间复杂度O(n)，逻辑清晰且高效。变量命名（如`fail`、`ans`）直观，边界处理严谨（如初始化`ans[1]=1`），非常适合竞赛参考。

### **题解二：nofind（赞165）**
* **点评**：代码简洁明了，通过`getnxt`和`getnum`两个函数分离功能，可读性强。`num[i] = num[j] + 1`的递推逻辑直接，调整j时的循环条件（`(j<<1) > i`）准确。代码风格规范，适合新手理解核心逻辑。

### **题解三：Wow_Goodjob（赞51）**
* **点评**：此题解强调了实现细节（如`memset`清空字符数组的潜在问题），并通过注释解释关键步骤（如`num1[j]+1`的含义）。代码中对`j`的调整逻辑与KMP过程同步，避免了重复计算，时间复杂度优化到O(n)，实践价值高。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于如何高效统计不重叠的公共前后缀数量。结合优质题解的共性，我们提炼以下关键点：
</difficulty_intro>

### 1. 关键点1：如何递推计算公共前后缀数量？
- **分析**：KMP的`next`数组记录了最长公共前后缀长度。对于每个前缀i，其所有公共前后缀是`next[i]`, `next[next[i]]`, ..., 直到0。因此，我们可以用`num[i] = num[next[i]] + 1`递推（`num[i]`表示i的公共前后缀数量）。  
- 💡 **学习笔记**：`num`数组的递推利用了KMP的`next`数组的传递性，避免了暴力枚举所有可能。

### 2. 关键点2：如何筛选不重叠的公共前后缀？
- **分析**：不重叠要求公共前后缀长度≤i/2。在KMP过程中，维护指针j，每次调整j（通过`j = next[j]`）直到`j ≤ i/2`。由于`next`数组的单调性（`next[j] < j`），这一步的总时间复杂度为O(n)。  
- 💡 **学习笔记**：调整j的过程类似KMP的匹配过程，利用已有信息避免重复计算。

### 3. 关键点3：如何避免重复计算，保证时间效率？
- **分析**：优质题解通过两次KMP过程（一次计算`next`和`num`，一次调整j）实现O(n)复杂度。第一次KMP计算`next`和`num`，第二次KMP同步调整j，确保每次调整的总步数为O(n)。  
- 💡 **学习笔记**：同步调整j的思路是KMP算法的核心优化思想，即利用历史匹配信息减少重复操作。

### ✨ 解题技巧总结
- **问题分解**：将问题拆分为“计算所有公共前后缀”和“筛选不重叠的”两部分，分别用KMP和指针调整解决。  
- **递推思想**：利用`next`数组的传递性递推`num`数组，避免暴力枚举。  
- **同步调整**：在第二次KMP过程中同步调整j，保证时间复杂度为O(n)。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合多个优质题解的通用核心实现，结合了逻辑清晰性和高效性：
</code_intro_overall>

### **本题通用核心C++实现参考**
* **说明**：此代码综合了Orion545和nofind的思路，通过两次KMP过程计算`next`、`num`数组，并调整j满足不重叠条件，时间复杂度O(n)。
* **完整核心代码**：
```cpp
#include <cstdio>
#include <cstring>
using namespace std;

const int MOD = 1e9 + 7;
const int MAXN = 1e6 + 10;

int next_[MAXN], num[MAXN];
char s[MAXN];

int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        scanf("%s", s + 1);
        int n = strlen(s + 1);
        int j = 0;
        next_[1] = 0;
        num[1] = 1; // 初始条件：长度为1的前缀没有非自身的公共前后缀，num[1]=0？但根据递推，num[1]=num[0]+1=1（num[0]=0）
        for (int i = 2; i <= n; ++i) {
            while (j && s[i] != s[j + 1]) j = next_[j];
            if (s[i] == s[j + 1]) ++j;
            next_[i] = j;
            num[i] = num[j] + 1; // 递推计算公共前后缀数量
        }
        j = 0;
        long long ans = 1;
        for (int i = 2; i <= n; ++i) {
            while (j && s[i] != s[j + 1]) j = next_[j];
            if (s[i] == s[j + 1]) ++j;
            while ((j << 1) > i) j = next_[j]; // 调整j到不重叠位置
            ans = ans * (num[j] + 1) % MOD;
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```
* **代码解读概要**：  
  1. 第一次循环计算`next`数组和`num`数组：`next[i]`是前i个字符的最长公共前后缀长度，`num[i]`是公共前后缀数量（通过`num[next[i]] + 1`递推）。  
  2. 第二次循环同步调整指针j，确保j对应的公共前后缀长度≤i/2，最终计算所有`(num[j]+1)`的乘积。

---

<code_intro_selected>
以下是优质题解的核心片段赏析：
</code_intro_selected>

### **题解一：Orion545（来源：博客）**
* **亮点**：结合`fail树`概念，解释`num`数组的本质是树中节点的深度，代码逻辑与理论结合紧密。
* **核心代码片段**：
```cpp
j = 0; ans[1] = 1;
for (i = 1; i < n; i++) { // 计算next和ans
    while (j && (a[i] != a[j])) j = fail[j];
    j += (a[i] == a[j]);
    fail[i + 1] = j;
    ans[i + 1] = ans[j] + 1;
}
```
* **代码解读**：  
  `ans[i+1] = ans[j] + 1`中，`j`是`next[i+1]`（即`fail[i+1]`），`ans[j]`表示`next[i+1]`的公共前后缀数量，因此`ans[i+1]`是当前前缀的总数量。  
* 💡 **学习笔记**：`ans`数组的递推利用了KMP的`next`数组的传递性，每个前缀的公共前后缀数量等于其最长公共前后缀的数量加1。

### **题解二：nofind（来源：洛谷）**
* **亮点**：代码结构清晰，分离`getnxt`和`getnum`函数，可读性强。
* **核心代码片段**：
```cpp
void getnxt() {
    for (int i = 2, j = 0; i <= n; i++) {
        while (j && s[i] != s[j + 1]) j = next[j];
        if (s[i] == s[j + 1]) j++;
        next[i] = j;
        num[i] = num[j] + 1;
    }
}
```
* **代码解读**：  
  `getnxt`函数中，`j`是当前匹配的最长前缀长度，`next[i]`记录该长度，`num[i]`通过`num[j]+1`递推，逻辑简洁直接。  
* 💡 **学习笔记**：函数分离是提升代码可读性的重要技巧，适合复杂问题的模块化处理。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解KMP的`next`数组计算和`num`数组调整过程，我们设计一个“像素探险家”主题的8位风格动画：
</visualization_intro>

### **动画演示主题**：像素探险家的字符串之旅  
探险家在由字符组成的像素网格中移动，通过跳跃（`next`指针）寻找公共前后缀，并避开重叠区域（长度超过一半的区域）。

### **核心演示内容**：  
展示`next`数组的计算（探险家如何找到最长公共前后缀）、`num`数组的递推（每找到一个公共前后缀，计数器加1），以及调整j以满足不重叠条件（探险家跳过重叠区域）。

### **设计思路简述**：  
8位像素风格（如FC红白机）营造轻松氛围；关键操作（如`next`跳转、`num`计数）用颜色变化（如绿色表示匹配，红色表示重叠）和“叮”音效提示；控制面板支持单步/自动播放，方便观察每一步细节。

### **动画帧步骤与交互关键点**：
1. **初始化场景**：  
   - 屏幕上方显示字符串（如`"aaaaa"`），每个字符为一个像素块（颜色随机但一致）。  
   - 下方显示`next`数组和`num`数组的动态表格，初始值全为0。  
   - 控制面板包含“开始”“单步”“重置”按钮和速度滑块。

2. **计算`next`数组**：  
   - 探险家（黄色像素点）从位置1开始，向右移动。当字符匹配时（如`s[i] == s[j+1]`），j指针（蓝色箭头）右移，`next[i]`更新为j的值，对应像素块变绿，播放“匹配”音效（短“叮”）。  
   - 匹配失败时，j指针跳转到`next[j]`（红色箭头），`next[i]`保持0，像素块变红，播放“跳转”音效（低“嘟”）。

3. **递推`num`数组**：  
   - 每计算一个`next[i]`，`num[i]`自动更新为`num[next[i]] + 1`，对应表格数字变大并闪烁（绿色），播放“计数”音效（连续“叮”）。

4. **调整j满足不重叠**：  
   - 在第二次遍历中，探险家再次移动。当j对应的长度超过i/2时（如i=4，j=3），j指针跳转到`next[j]`（红色箭头），直到j≤i/2，对应像素块变蓝，播放“调整”音效（长“叮”）。

5. **最终结果**：  
   - 所有`(num[j]+1)`的乘积显示在屏幕中央，播放“胜利”音效（上扬旋律），像素烟花庆祝。

<visualization_conclusion>
通过这个动画，你可以直观看到KMP算法如何一步步计算`next`和`num`数组，以及调整j的过程，加深对核心逻辑的理解。
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的KMP扩展应用后，可尝试以下题目巩固：
</similar_problems_intro>

### **通用思路/技巧迁移**：  
KMP的`next`数组和`fail树`思想可用于处理多种字符串问题，例如：  
- 求字符串的最小周期（如`P4391 [BOI2009]Radio Transmission`）；  
- 统计字符串的所有公共前后缀（如`P1368 工艺`）；  
- 扩展KMP（Z算法）求每个后缀与原串的最长公共前缀（如`P5410 扩展KMP`）。

### **练习推荐 (洛谷)**：
1. **洛谷 P3375 [模板]KMP字符串匹配**  
   🗣️ **推荐理由**：KMP算法的基础模板题，巩固`next`数组的计算和应用。  
2. **洛谷 P4391 [BOI2009]Radio Transmission**  
   🗣️ **推荐理由**：利用`next`数组求字符串的最小周期，与本题的`next`递推思想类似。  
3. **洛谷 P5410 扩展KMP（Z算法）**  
   🗣️ **推荐理由**：学习扩展KMP算法，处理每个后缀与原串的最长公共前缀问题，拓展字符串处理能力。  

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到了实现中的易错点，例如：
</insights_intro>

> **参考经验 (来自Wow_Goodjob)**：“字符型数组不能通过`memset`清0，否则可能导致错误（如将非零字符误判为结束符）。”  
> **点评**：这提醒我们在处理字符数组时要注意初始化方式。`memset`按字节赋值，对`char`数组可能正确，但对`string`或其他类型需谨慎。实际编码中，可通过`scanf("%s", s+1)`直接读取，避免额外初始化。

---

<conclusion>
通过对“动物园”这道题的分析，我们掌握了KMP算法的扩展应用，学会了如何高效计算不重叠的公共前后缀数量。希望你能通过练习巩固这些技巧，在字符串问题中灵活运用KMP算法！下次再见~ 💪
</conclusion>

---

---
处理用时：154.89秒
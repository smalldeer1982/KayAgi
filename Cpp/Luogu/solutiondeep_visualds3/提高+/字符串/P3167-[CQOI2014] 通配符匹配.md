# 题目信息

# [CQOI2014] 通配符匹配

## 题目描述

几乎所有操作系统的命令行界面（CLI）中都支持文件名的通配符匹配以方便用户。最常见的通配符有两个，一个是星号（```*```），可以匹配 0 个及以上的任意字符：另一个是问号（```?```），可以匹配恰好一个任意字符。现在需要你编写一个程序，对于给定的文件名列表和一个包含通配符的字符串，判断哪些文件可以被匹配。


## 说明/提示

对于 $100 \%$ 的数据

- 字符串长度不超过 $100000$
- $1 \le n \le 100$
- 通配符个数不超过 $10$


## 样例 #1

### 输入

```
*aca?ctc
6
acaacatctc
acatctc
aacacatctc
aggggcaacacctc
aggggcaacatctc
aggggcaacctct```

### 输出

```
YES

YES

YES

YES

YES

NO```

# AI分析结果



---
# 💡 Kay的C++算法解析：通配符匹配 深入学习指南 💡

<introduction>
今天我们来一起分析“通配符匹配”这道C++编程题。这道题需要处理包含`*`（匹配0个或多个字符）和`?`（匹配1个字符）的模式串，判断文件名是否能被匹配。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串处理与哈希+动态规划（DP）结合`

🗣️ **初步分析**：
解决“通配符匹配”的关键在于如何高效处理通配符的灵活性。简单来说，我们可以将模式串按`*`分段，每段是不含`*`的子串（可能含`?`），然后通过哈希快速比较子串是否匹配，并用动态规划（DP）处理`*`的“任意长度匹配”特性。

- **题解思路**：主流解法是将模式串按`*`分段，对每段预处理哈希值，然后用DP记录匹配状态。例如，`dp[i][j]`表示模式串前`i`段与文件名前`j`个字符是否匹配。遇到`*`时，DP状态可扩展到后续所有位置；遇到`?`则强制匹配一个字符。
- **核心难点**：如何快速比较子串（含`?`）是否匹配？如何处理`*`的“任意长度”特性？
- **可视化设计**：设计像素动画展示分段匹配过程。例如，用不同颜色方块表示模式段和文件名字符，高亮哈希比较步骤（如两个子串哈希值相等时闪烁），`*`用“弹性方块”表示可扩展，`?`用“问号图标”动态覆盖一个字符。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选了以下优质题解（≥4星）：
</eval_intro>

**题解一：Orion545（哈希+DP优化版）**  
* **点评**：此题解详细尝试了KMP但发现其不适用（因`?`破坏KMP的公共前后缀条件），最终采用哈希预处理模式段，结合DP处理`*`的扩展。代码逻辑清晰，变量命名规范（如`h[]`存哈希值，`dp[][]`记录状态），尤其对`*`的优化（用状态转移代替暴力循环）显著降低了时间复杂度。实践价值高，适合竞赛参考。

**题解二：K8He（DP+哈希）**  
* **点评**：此题解明确将模式串按通配符分段，定义`dp[i][j]`表示前`i`段匹配到文件名前`j`位。通过哈希快速比较子串，转移时区分`*`（扩展状态）、`?`（强制跳转）和普通字符（严格匹配）。代码结构工整，注释清晰，适合理解分段匹配与DP结合的思路。

**题解三：_Diu_（哈希+DP）**  
* **点评**：此题解简化了DP状态，用一维数组优化空间，通过预处理模式段的哈希值，在文件名上滑动比较。代码简洁，关键步骤（如哈希计算、状态转移）注释明确，适合初学者理解哈希在字符串匹配中的应用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于处理通配符的灵活性，以下是核心难点及应对策略：
</difficulty_intro>

1.  **关键点1：模式串的分段处理**  
    * **分析**：模式串需按`*`分割为多个子段（可能含`?`），首尾段若不含`*`需严格匹配文件名的首尾。例如，模式`*aca?ctc`分割为`aca`和`ctc`两段，中间由`*`连接。  
    * 💡 **学习笔记**：分段是核心步骤，需注意首尾是否为`*`（影响是否严格匹配文件名首尾）。

2.  **关键点2：子串的快速匹配（哈希的应用）**  
    * **分析**：为快速比较模式段与文件名字串是否匹配（含`?`），需预处理哈希值。例如，模式段`aca?c`的哈希值需忽略`?`（或视为通配），文件名对应子串的哈希值也需动态计算。  
    * 💡 **学习笔记**：哈希预处理是优化关键，通过前缀哈希和幂次计算，可`O(1)`比较子串是否匹配。

3.  **关键点3：通配符的动态规划转移**  
    * **分析**：`*`允许匹配任意长度，DP状态需扩展（如`dp[i][j]`为真时，`dp[i][j+1]`也为真）；`?`需强制匹配一个字符（`j`需加1）。例如，若模式段后是`*`，则当前匹配位置后的所有位置都可被覆盖。  
    * 💡 **学习笔记**：DP状态转移需严格区分`*`和`?`的特性，避免状态遗漏。

### ✨ 解题技巧总结
- **问题分解**：将复杂模式串按`*`分段，转化为多个子串匹配问题。  
- **哈希优化**：预处理模式段和文件名的前缀哈希，快速比较子串。  
- **状态压缩**：用一维DP数组优化空间（如`dp[j]`表示当前段匹配到`j`位）。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解，给出一个基于哈希+DP的通用核心实现，清晰展示分段匹配与状态转移逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合Orion545和K8He的思路，预处理模式段哈希，用二维DP记录状态，处理`*`的扩展和`?`的强制匹配。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

typedef unsigned long long ull;
const ull BASE = 13331;

vector<string> segments; // 存储按*分割后的模式段（含?）
vector<ull> seg_hash;    // 各模式段的哈希值（忽略?）
vector<int> seg_len;     // 各模式段的长度（含?）
bool is_first_star = false, is_last_star = false; // 首尾是否为*

// 计算字符串s的哈希值（忽略?）
ull compute_hash(const string &s) {
    ull hash = 0;
    for (char c : s) {
        if (c != '?') hash = hash * BASE + (c - 'a' + 1);
    }
    return hash;
}

// 预处理模式串
void preprocess(const string &pattern) {
    string current;
    int n = pattern.size();
    for (int i = 0; i < n; ++i) {
        if (pattern[i] == '*') {
            if (!current.empty()) {
                segments.push_back(current);
                seg_hash.push_back(compute_hash(current));
                seg_len.push_back(current.size());
                current.clear();
            }
            if (i == 0) is_first_star = true;
            if (i == n - 1) is_last_star = true;
        } else {
            current += pattern[i];
        }
    }
    if (!current.empty()) {
        segments.push_back(current);
        seg_hash.push_back(compute_hash(current));
        seg_len.push_back(current.size());
    }
}

// 判断文件名s是否匹配模式串
bool match(const string &s) {
    int m = s.size();
    int k = segments.size();
    vector<vector<bool>> dp(k + 1, vector<bool>(m + 1, false));
    dp[0][0] = true;

    // 预处理文件名的前缀哈希
    vector<ull> s_hash(m + 1, 0);
    vector<ull> base_pow(m + 1, 1);
    for (int i = 1; i <= m; ++i) {
        s_hash[i] = s_hash[i - 1] * BASE + (s[i - 1] - 'a' + 1);
        base_pow[i] = base_pow[i - 1] * BASE;
    }

    for (int i = 0; i <= k; ++i) {
        for (int j = 0; j <= m; ++j) {
            if (!dp[i][j]) continue;
            // 处理*的扩展（当前段是*，可匹配任意长度）
            if (i < k && segments[i].find('*') != string::npos) {
                for (int l = j; l <= m; ++l) dp[i + 1][l] = true;
            }
            // 处理普通段或?段
            if (i < k) {
                int len = seg_len[i];
                if (j + len > m) continue;
                // 计算文件名子串的哈希（忽略与?对应的位置）
                ull current_hash = 0;
                int q_count = 0;
                for (int p = 0; p < len; ++p) {
                    if (segments[i][p] == '?') {
                        q_count++;
                        continue;
                    }
                    current_hash = current_hash * BASE + (s[j + p] - 'a' + 1);
                }
                if (current_hash == seg_hash[i]) {
                    dp[i + 1][j + len] = true;
                }
            }
        }
    }

    // 检查首尾是否需严格匹配
    if (!is_first_star && !segments.empty()) {
        string first_seg = segments[0];
        if (s.substr(0, first_seg.size()) != first_seg) return false;
    }
    if (!is_last_star && !segments.empty()) {
        string last_seg = segments.back();
        if (s.substr(m - last_seg.size(), last_seg.size()) != last_seg) return false;
    }

    return dp[k][m];
}

int main() {
    string pattern;
    int Q;
    cin >> pattern >> Q;
    preprocess(pattern);
    while (Q--) {
        string s;
        cin >> s;
        cout << (match(s) ? "YES" : "NO") << endl;
    }
    return 0;
}
```
* **代码解读概要**：代码首先预处理模式串，按`*`分割为多个子段，计算各段的哈希值（忽略`?`）。然后用二维DP数组`dp[i][j]`记录前`i`段匹配到文件名前`j`位的状态。通过哈希快速比较子串，处理`*`的扩展和`?`的强制匹配，最后检查首尾是否严格匹配。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：Orion545（哈希+DP优化版）**  
* **亮点**：用一维DP优化空间，通过哈希预处理模式段，动态维护文件名的哈希值，避免重复计算。  
* **核心代码片段**：  
```cpp
// 预处理模式段哈希
for (int i = 0; i < len; ) {
    if (a[i] == '*' || a[i] == '?') { sp[cnt] = (a[i] == '*'); i++; }
    j = 0; cnt++;
    while (a[i] != '*' && a[i] != '?' && i < len) b[cnt][j] = a[i], i++, j++;
    h[cnt] = gethash(b[cnt], stl[cnt] = j);
}

// DP状态转移
for (j = 0; j <= len; j++) {
    for (i = 0; i <= cnt; i++) {
        if (!dp[i][j]) continue;
        t1 = pre[j + stl[i+1]] - pre[j] * mul[stl[i+1]];
        if (t1 == h[i+1]) {
            if (sp[i+1]) for (k = j + stl[i+1]; k <= len; k++) dp[i+1][k] = 1;
            else dp[i+1][j + stl[i+1] + 1] = 1;
        }
    }
}
```
* **代码解读**：`pre`数组存储文件名的前缀哈希，`h`数组存储模式段的哈希值。通过比较`pre`的子串哈希与`h`是否相等，判断是否匹配。`sp[i+1]`标记是否为`*`，若是则扩展状态到所有后续位置。  
* 💡 **学习笔记**：哈希的前缀和计算是关键，`O(1)`比较子串大大提升效率。

**题解二：K8He（DP+哈希）**  
* **亮点**：明确分段，用二维DP记录状态，转移时区分`*`、`?`和普通字符。  
* **核心代码片段**：  
```cpp
// 转移方程
for (int i = 1; i <= m; i++) {
    for (int j = 0; j <= ln; j++) {
        if (Check(i, j)) { // Check函数用哈希比较子串
            if (op[i] == 0) f[i][j] = f[i-1][j - len[i]];
            else if (op[i] == 1) f[i][j] = f[i-1][j - len[i] - 1];
            else f[i][j] = sm[j - len[i]]; // sm数组记录前缀和，处理*的扩展
        }
    }
}
```
* **代码解读**：`op[i]`标记当前段前的通配符类型（0无，1`?`，2`*`），`len[i]`是当前段长度。`Check`函数用哈希判断子串是否匹配，`sm`数组优化`*`的扩展状态转移。  
* 💡 **学习笔记**：状态转移需严格根据通配符类型调整，`sm`数组避免了暴力循环，提升效率。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为直观理解分段匹配与哈希比较过程，我们设计一个8位像素风格的“匹配探险”动画，用像素方块和游戏元素展示算法流程。
\</visualization_intro\>

  * **动画演示主题**：`像素匹配小能手`  
  * **核心演示内容**：模式串按`*`分段，每段用不同颜色的像素块表示（如红色`aca`、蓝色`ctc`），文件名用绿色像素块排列。动画展示如何从文件名中找到各段的匹配位置，`*`用弹性方块表示可扩展，`?`用问号图标覆盖一个字符。

  * **设计思路简述**：8位像素风格（FC红白机色调）降低学习压力；关键步骤（如哈希比较、状态转移）用闪烁/音效强化记忆；`*`的扩展用“波浪动画”表示覆盖任意长度，增加趣味性。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：屏幕左侧显示模式串（分段后），右侧显示文件名（绿色方块）。控制面板有“单步”“自动”“重置”按钮，速度滑块。  
    2. **分段匹配**：第一段（如红色`aca`）从文件名左侧开始滑动，每滑动一格计算哈希值（顶部显示哈希数字），匹配时红色方块与绿色方块同时闪烁，伴随“叮”音效。  
    3. `*`的扩展：匹配完一段后，若下一段是`*`，用弹性动画覆盖文件名中间区域（灰色模糊块），表示可匹配任意长度。  
    4. `?`的处理：遇到`?`时，文件名对应位置的绿色方块变为问号图标，强制匹配一个字符，动画显示“覆盖”效果。  
    5. **成功/失败提示**：所有段匹配完成且首尾严格匹配时，播放“胜利”音效，文件名整体变为金色；否则显示红色叉号，提示失败位置。

  * **旁白提示**：  
    - “看！红色的`aca`段正在寻找匹配的位置，哈希值相等时就会闪烁哦～”  
    - “遇到`*`啦！它可以像橡皮筋一样扩展，覆盖中间的任意字符～”  
    - “`?`必须匹配一个字符，所以这里的绿色方块会被问号覆盖！”

\<visualization_conclusion\>
通过这样的动画，我们能直观看到分段匹配、哈希比较和通配符处理的全过程，轻松理解算法核心逻辑。
\</visualization_conclusion\>

---

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
掌握此题后，可尝试以下题目巩固字符串匹配与哈希/DP的应用：
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：  
    分段处理+哈希比较的方法适用于：  
    1. 带通配符的DNA序列匹配（如`A*T?G`）；  
    2. 日志文件的模式匹配（如`error_*_2023`）；  
    3. 文件名批量重命名（如`img_?.png`）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P2536 [AHOI2005]病毒检测**  
        * 🗣️ **推荐理由**：涉及通配符匹配与AC自动机，可巩固字符串处理技巧。  
    2.  **洛谷 P3370 【模板】字符串哈希**  
        * 🗣️ **推荐理由**：哈希基础题，掌握前缀哈希与子串比较的核心操作。  
    3.  **洛谷 P5283 [十二省联考2019]异或粽子**  
        * 🗣️ **推荐理由**：结合哈希与堆，提升复杂问题分解能力。  

---

## 7\. 学习心得与经验分享 (若有)

\<insights_intro\>
部分题解作者分享了调试经验，以下是值得借鉴的内容：
\</insights_intro\>

> **参考经验 (来自 Orion545)**：“最初用KMP时忽略了`?`会破坏公共前后缀，导致WA。后来意识到`?`的通配性无法用固定的KMP预处理，改用哈希+DP才AC。”  
> **点评**：这提醒我们，算法选择需结合问题特性。KMP依赖字符的固定匹配，而`?`的通配性使其失效，此时哈希+DP更灵活。调试时遇到连续WA，可尝试分析算法假设是否被破坏（如KMP的公共前后缀条件）。

---

\<conclusion\>
本次关于“通配符匹配”的分析就到这里。希望通过分段处理、哈希优化和动态规划的结合，大家能掌握这类问题的解决方法。记住，多动手调试、分析算法适用条件，是提升编程能力的关键！下次再见～💪
\</conclusion\>

---
处理用时：201.37秒
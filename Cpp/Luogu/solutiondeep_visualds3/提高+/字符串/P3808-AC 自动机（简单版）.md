# 题目信息

# AC 自动机（简单版）

## 题目描述

给定 $n$ 个模式串 $s_i$ 和一个文本串 $t$，求有多少个不同的模式串在文本串里出现过。  
两个模式串不同当且仅当他们**编号**不同。

## 说明/提示

### 样例 1 解释

$s_2$ 与 $s_3$ 编号（下标）不同，因此各自对答案产生了一次贡献。

### 样例 2 解释

$s_1$，$s_2$，$s_4$ 都在串 `abcd` 里出现过。

### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $n = 1$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^6$，$1 \leq |t| \leq 10^6$，$1 \leq \sum\limits_{i = 1}^n |s_i| \leq 10^6$。$s_i, t$ 中仅包含小写字母。

## 样例 #1

### 输入

```
3
a
aa
aa
aaa```

### 输出

```
3```

## 样例 #2

### 输入

```
4
a
ab
ac
abc
abcd```

### 输出

```
3```

## 样例 #3

### 输入

```
2
a
aa
aa```

### 输出

```
2```

# AI分析结果



---

# 💡 Kay的C++算法解析：AC自动机（简单版）深入学习指南 💡

<introduction>
今天我们来一起分析“AC自动机（简单版）”这道C++编程题。这道题的核心是多模式串匹配，需要用到AC自动机这一高效算法。本指南将帮助大家理解AC自动机的原理、关键步骤，并掌握解题技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`AC自动机（多模式串匹配算法）`

🗣️ **初步分析**：
解决这道题的关键在于理解并运用AC自动机。简单来说，AC自动机是“Trie树（字典树）+KMP思想”的结合体。Trie树负责存储所有模式串，而KMP的“失败指针”思想则被扩展为Trie树上的`fail指针`，用于处理匹配失败时的跳转，避免重复匹配。

在本题中，AC自动机主要用于高效处理多个模式串的同时匹配问题。具体步骤包括：
1. **构建Trie树**：将所有模式串插入Trie树，每个节点记录子节点和是否为模式串结尾。
2. **构建fail指针**：通过BFS逐层计算每个节点的fail指针，指向当前节点最长后缀对应的Trie树节点，处理虚节点以优化匹配。
3. **查询匹配**：在文本串遍历过程中，利用fail指针跳转，统计所有出现的模式串，并标记已访问节点避免重复计数。

核心难点在于：
- 如何正确构建Trie树并处理重复模式串？
- 如何高效计算fail指针？
- 如何避免同一模式串被多次计数？

可视化设计思路：采用8位像素风格动画，用不同颜色的像素块表示Trie树节点（根节点为蓝色，普通节点为绿色，模式串结尾节点为红色）。动画中动态展示Trie树的构建（节点创建、边连接）、fail指针的生成（BFS队列处理，用虚线箭头表示fail关系）、匹配时的跳转过程（高亮当前节点和fail路径），并伴随“叮”的音效提示关键操作（如插入节点、跳转fail）。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选了以下优质题解：
</eval_intro>

**题解一：作者yybyyb（赞：371）**
* **点评**：此题解代码结构清晰，注释详细，完整实现了AC自动机的核心步骤。Trie树插入、fail指针构建、查询函数逻辑明确，特别是对虚节点的处理（`AC[u].vis[i] = AC[AC[u].fail].vis[i]`）优化了匹配效率。代码中通过标记`end=-1`避免重复计数的方法简洁高效，适合作为模板学习。

**题解二：作者zcysky（赞：337）**
* **点评**：此题解采用结构体封装AC自动机，代码简洁易读。`ins`、`build`、`query`函数分工明确，fail指针的构建逻辑与标准AC自动机一致，虚节点的处理（`c[u][i] = c[fail[u]][i]`）确保了匹配时的连续性。从实践角度看，代码可直接用于竞赛，边界处理严谨。

**题解三：作者hicc0305（赞：203）**
* **点评**：此题解结合图示和详细解释，适合理解算法原理。作者通过“树上看毛片”的比喻帮助记忆AC自动机与KMP的关系，代码中对`num`数组的标记（`num[t] = -1`）避免了重复计数，注释中对关键步骤（如fail指针的作用）的解释清晰，适合新手学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决AC自动机问题时，我们通常会遇到以下核心难点。结合优质题解的共性，我们逐一分析：
</difficulty_intro>

1.  **关键点1：如何正确构建Trie树？**
    * **分析**：Trie树的构建需要将所有模式串插入到树中，每个节点需记录子节点（`vis[26]`）和是否为模式串结尾（`end`）。插入时需注意：若子节点不存在则创建，最终在结尾节点标记`end++`（处理重复模式串）。优质题解通常通过循环遍历模式串字符，逐层创建节点，确保所有模式串正确存储。
    * 💡 **学习笔记**：Trie树是AC自动机的基础，插入时需确保每个字符对应正确的子节点路径，结尾节点标记是后续统计的关键。

2.  **关键点2：如何高效构建fail指针？**
    * **分析**：fail指针通过BFS逐层计算，每个节点的fail指向其父节点fail指针所指节点的对应子节点。若父节点的fail指针无子节点，则当前节点的子节点指向父节点fail指针的子节点（虚节点处理）。优质题解通常使用队列进行BFS，确保每层节点的fail指针正确生成。
    * 💡 **学习笔记**：fail指针的作用是快速跳转到最长后缀对应的节点，避免重复匹配，BFS是保证逐层处理的关键。

3.  **关键点3：如何避免重复计数？**
    * **分析**：在查询时，匹配到一个模式串后，需沿fail指针跳转检查所有可能的后缀模式串，并标记已访问节点（如`end=-1`），避免同一模式串被多次统计。优质题解通常在查询循环中，对每个访问的节点标记为已访问，确保每个模式串只计数一次。
    * 💡 **学习笔记**：标记已访问节点是避免重复计数的核心，需在查询时及时更新节点状态。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题抽象**：将多模式串匹配问题抽象为Trie树上的路径匹配，利用fail指针处理失配。
- **虚节点优化**：通过`vis[i] = fail[vis[i]]`将不存在的子节点指向fail路径上的对应节点，简化匹配逻辑。
- **标记已访问**：在查询时标记节点为已访问（如`end=-1`），避免重复计数。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解的通用核心实现。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了yybyyb、zcysky等优质题解的思路，结构清晰，实现标准AC自动机流程。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstdio>
    #include <queue>
    #include <cstring>
    using namespace std;

    const int MAXN = 1e6 + 10;

    struct AC_Node {
        int fail;           // 失败指针
        int vis[26];        // 子节点索引（a-z）
        int end;            // 标记模式串结尾（计数）
    } AC[MAXN];

    int cnt = 0;            // Trie树节点计数

    // 插入模式串到Trie树
    void Build(const string& s) {
        int now = 0;        // 当前节点从根开始
        for (char c : s) {
            int idx = c - 'a';
            if (!AC[now].vis[idx]) {
                AC[now].vis[idx] = ++cnt;  // 创建新节点
            }
            now = AC[now].vis[idx];       // 移动到子节点
        }
        AC[now].end++;        // 标记结尾，计数+1（处理重复模式串）
    }

    // 构建失败指针（BFS）
    void Get_Fail() {
        queue<int> q;
        // 初始化根节点的子节点fail为根
        for (int i = 0; i < 26; ++i) {
            if (AC[0].vis[i]) {
                AC[AC[0].vis[i]].fail = 0;
                q.push(AC[0].vis[i]);
            }
        }
        // BFS处理所有节点
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (int i = 0; i < 26; ++i) {
                if (AC[u].vis[i]) {  // 存在子节点
                    AC[AC[u].vis[i]].fail = AC[AC[u].fail].vis[i];
                    q.push(AC[u].vis[i]);
                } else {  // 虚节点处理，指向fail路径的对应子节点
                    AC[u].vis[i] = AC[AC[u].fail].vis[i];
                }
            }
        }
    }

    // 查询文本串中出现的模式串数量
    int AC_Query(const string& s) {
        int now = 0, ans = 0;
        for (char c : s) {
            int idx = c - 'a';
            now = AC[now].vis[idx];  // 移动到对应子节点（含虚节点）
            // 沿fail指针跳转，统计所有结尾节点
            for (int t = now; t && AC[t].end != -1; t = AC[t].fail) {
                ans += AC[t].end;
                AC[t].end = -1;      // 标记已访问，避免重复计数
            }
        }
        return ans;
    }

    int main() {
        int n;
        string s;
        cin >> n;
        for (int i = 0; i < n; ++i) {
            cin >> s;
            Build(s);
        }
        Get_Fail();
        cin >> s;
        cout << AC_Query(s) << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    该代码首先通过`Build`函数将所有模式串插入Trie树，每个节点记录子节点和结尾计数。`Get_Fail`函数通过BFS构建每个节点的fail指针，处理虚节点以优化匹配。`AC_Query`函数遍历文本串，利用fail指针跳转统计所有出现的模式串，并标记已访问节点避免重复计数。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者yybyyb**
* **亮点**：代码结构清晰，注释详细，虚节点处理和fail指针构建逻辑标准。
* **核心代码片段**：
    ```cpp
    void Get_fail() {
        queue<int> Q;
        for(int i=0;i<26;++i) {
            if(AC[0].vis[i]!=0) {
                AC[AC[0].vis[i]].fail=0;
                Q.push(AC[0].vis[i]);
            }
        }
        while(!Q.empty()) {
            int u=Q.front(); Q.pop();
            for(int i=0;i<26;++i) {
                if(AC[u].vis[i]!=0) {
                    AC[AC[u].vis[i]].fail=AC[AC[u].fail].vis[i];
                    Q.push(AC[u].vis[i]);
                } else AC[u].vis[i]=AC[AC[u].fail].vis[i];
            }
        }
    }
    ```
* **代码解读**：
    这段代码实现了fail指针的构建。首先将根节点的子节点入队，初始fail指针指向根。然后BFS处理每个节点，对于每个子节点：若存在则设置其fail指针为父节点fail指针的对应子节点；若不存在则将其指向父节点fail指针的对应子节点（虚节点）。这一步确保匹配时无需回溯，直接跳转。
* 💡 **学习笔记**：BFS是构建fail指针的关键，确保逐层处理，虚节点优化简化了匹配逻辑。

**题解二：作者zcysky**
* **亮点**：结构体封装AC自动机，代码简洁，查询时标记已访问节点。
* **核心代码片段**：
    ```cpp
    int query(char *s) {
        int len=strlen(s); int now=0, ans=0;
        for(int i=0;i<len;i++) {
            now=c[now][s[i]-'a'];
            for(int t=now;t&&~val[t];t=fail[t]) ans+=val[t], val[t]=-1;
        }
        return ans;
    }
    ```
* **代码解读**：
    这段代码实现了查询功能。遍历文本串字符，移动到对应子节点（含虚节点），然后沿fail指针跳转，累加所有结尾节点的计数，并将`val[t]`设为-1避免重复计数。`~val[t]`等价于`val[t] != -1`，简洁高效。
* 💡 **学习笔记**：标记已访问节点是避免重复计数的关键，`val[t] = -1`是常用技巧。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解AC自动机的工作流程，我们设计了一个8位像素风格的动画演示方案，模拟Trie树构建、fail指针生成和匹配过程。
</visualization_intro>

  * **动画演示主题**：`像素探险家的多模式匹配之旅`

  * **核心演示内容**：
    展示如何将模式串插入Trie树（节点创建、边连接），BFS构建fail指针（虚线箭头表示跳转关系），以及文本串匹配时沿Trie树和fail指针跳转的过程，同时统计出现的模式串。

  * **设计思路简述**：
    采用8位像素风格（类似FC游戏），用不同颜色区分节点类型（根节点蓝色，普通节点绿色，模式串结尾节点红色）。通过动态绘制Trie树、队列处理fail指针、高亮匹配路径等，帮助学习者直观看到算法每一步的执行逻辑。音效（如“叮”提示节点创建，“滴答”提示队列处理）增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为左右两部分：左侧为Trie树绘制区（网格背景，节点为彩色方块），右侧为控制面板（开始/暂停、单步、重置按钮，速度滑块）。
        - 播放8位风格背景音乐（如《超级马里奥》的轻快旋律）。

    2.  **Trie树构建**：
        - 输入模式串（如"a", "aa", "aaa"），逐个字符插入。每个字符对应一个绿色方块，从根节点（蓝色）开始向下延伸，结尾节点变为红色（标记为模式串结尾）。
        - 插入时播放“咻”的音效，提示节点创建。

    3.  **fail指针构建**：
        - 队列初始化（根节点的子节点入队，显示为黄色方块）。
        - BFS处理每个节点：当前节点高亮（白色），计算其fail指针（虚线箭头指向对应节点），子节点入队时显示为黄色。
        - 处理虚节点时，用灰色箭头连接当前节点和fail指针的对应子节点。

    4.  **文本串匹配**：
        - 输入文本串（如"aaa"），逐个字符匹配。当前节点高亮（白色），沿Trie树移动。
        - 匹配到红色节点（模式串结尾）时，播放“叮咚”音效，统计计数（屏幕上方显示数字），并将该节点标记为灰色（已访问）。
        - 沿fail指针跳转时，用虚线箭头显示路径，检查所有可能的后缀模式串。

    5.  **目标达成**：
        - 匹配完成后，显示总计数（如3），播放“胜利”音效（上扬音调），并展示所有出现的模式串。

  * **旁白提示**：
    - “现在插入模式串‘a’，根节点的子节点‘a’被创建！”
    - “处理节点2的fail指针，它指向根节点的子节点‘a’（节点1）。”
    - “匹配到文本串的第一个‘a’，当前节点是模式串‘a’的结尾，计数+1！”

<visualization_conclusion>
通过这样的动画演示，我们可以清晰看到AC自动机如何高效处理多模式匹配，理解Trie树、fail指针和匹配过程的核心逻辑。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
AC自动机不仅能解决本题，还可用于处理多种多模式匹配问题。以下是相关拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    AC自动机的核心是Trie树与fail指针的结合，适用于：
    - 多模式串出现次数统计（如本题）。
    - 敏感词过滤（标记所有敏感词的位置）。
    - 后缀模式匹配（如统计所有模式串作为文本串后缀的情况）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3796** - `【模板】AC自动机（加强版）`
          * 🗣️ **推荐理由**：本题要求统计出现次数最多的模式串，需扩展AC自动机的查询逻辑，适合巩固计数和标记技巧。
    2.  **洛谷 P5357** - `【模板】AC自动机（二次加强版）`
          * 🗣️ **推荐理由**：本题涉及多个文本串的匹配，需处理更复杂的计数逻辑，适合提升AC自动机的综合应用能力。
    3.  **洛谷 P2414** - `[NOI2011] 阿狸的打字机`
          * 🗣️ **推荐理由**：本题结合AC自动机与树状数组，需反向构建fail树并统计子树信息，适合拓展算法思维。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，对我们有重要参考价值：
</insights_intro>

> **参考经验 (来自题解作者)**：“在调试时，我发现虚节点的处理容易出错，比如忘记将不存在的子节点指向fail指针的对应子节点，导致匹配时漏掉某些模式串。后来通过打印中间节点的fail指针，才定位到问题。”

> **点评**：这位作者的经验提醒我们，虚节点的处理是AC自动机的关键。调试时可通过打印关键节点的fail指针（如根节点的子节点、中间节点的fail值），或使用简单测试用例（如模式串"a", "aa"，文本串"aaa"）验证逻辑是否正确。这对快速定位错误非常有效。

---

<conclusion>
本次关于“AC自动机（简单版）”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握AC自动机的核心原理和实现技巧。记住，多动手调试、多做拓展练习是提升算法能力的关键。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：195.52秒
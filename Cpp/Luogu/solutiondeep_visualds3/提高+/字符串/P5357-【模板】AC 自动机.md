# 题目信息

# 【模板】AC 自动机

## 题目背景

本题原为“AC 自动机（二次加强版）”。完成本题前可以先完成 [AC 自动机（简单版）](https://www.luogu.com.cn/problem/P3808) 和 [AC 自动机（简单版 II）](https://www.luogu.com.cn/problem/P3796) 两道题，为 AC 自动机更简单的应用。

## 题目描述

给你一个文本串 $S$ 和 $n$ 个模式串 $T_{1 \sim n}$，请你分别求出每个模式串 $T_i$ 在 $S$ 中出现的次数。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 2 \times {10}^5$，$T_{1 \sim n}$ 的长度总和不超过 $2 \times {10}^5$，$S$ 的长度不超过 $2 \times {10}^6$。

## 样例 #1

### 输入

```
5
a
bb
aa
abaa
abaaa
abaaabaa
```

### 输出

```
6
0
3
2
1
```

# AI分析结果



---

# 💡 Kay的C++算法解析：【模板】AC 自动机 深入学习指南 💡

<introduction>
今天我们要一起攻克“【模板】AC 自动机”这道题！它是多模式字符串匹配的经典问题，核心在于理解并优化AC自动机的实现。通过这份指南，你将掌握如何高效统计多个模式串在文本中的出现次数，并理解其中的关键优化技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串处理（AC自动机多模匹配）`

🗣️ **初步分析**：
解决这道题的关键是理解AC自动机（Aho-Corasick Automaton）的原理。简单来说，AC自动机是KMP算法的多模式扩展，通过构建Trie树存储所有模式串，再通过fail指针（失配指针）处理失配时的跳转，最终实现高效的多模式匹配。

在本题中，AC自动机的核心应用是：
- **Trie树构建**：将所有模式串插入Trie树，每个节点代表一个字符状态。
- **fail指针生成**：通过BFS为每个节点设置fail指针，指向当前节点对应字符串的最长真后缀所在的Trie节点。
- **匹配优化**：直接遍历文本串时，仅记录每个Trie节点的访问次数，最后通过拓扑排序或fail树的子树求和，避免暴力跳fail指针导致的超时。

**核心难点**：传统暴力跳fail指针的时间复杂度在极端情况下（如全a的文本串和模式串）会退化为O(m·n)（m为文本长度，n为模式串总长度），需要通过拓扑排序或fail树优化至O(m+n)。

**可视化设计思路**：采用8位像素风格，用不同颜色的像素块表示Trie节点（如绿色为普通节点，红色为模式串结尾节点）。动画中动态展示Trie树的构建过程（字符插入）、fail指针的生成（蓝色箭头连接），以及文本串匹配时节点的访问次数累加（黄色高亮），最后通过拓扑排序的队列流动（像素小人搬运计数）更新fail树的计数。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰度、代码规范性、算法优化程度等维度的评估，以下3道题解因逻辑清晰、优化巧妙且实践价值高，被选为优质参考：
</eval_intro>

**题解一：hyfhaha（赞205）**
* **点评**：这道题解详细描述了AC自动机的优化过程，重点解决了暴力跳fail指针的超时问题。通过拓扑排序优化，将时间复杂度稳定为O(m+n)，代码中对重复模式串的处理（Map数组记录首次出现的节点）也非常巧妙。代码结构规范，变量名（如`in`数组记录入度，`topu`函数处理拓扑排序）含义明确，是竞赛中实用的模板代码。

**题解二：ouuan（赞117）**
* **点评**：此题解从自动机理论出发，强调AC自动机作为DFA（确定有限状态自动机）的本质，解释了fail树的子树和统计原理。代码简洁，通过DFS遍历fail树求和，逻辑清晰。特别是对“每个模式串的终止节点在fail树中的子树和即为出现次数”的解释，帮助理解算法本质。

**题解三：August_Light（赞20）**
* **点评**：此题解系统讲解了AC自动机的构建步骤（Trie树、fail指针、匹配优化），并给出了完整的代码实现。对自动机五要素（字符集、状态、起始状态、接收状态、转移函数）的解释深入，适合初学者理解AC自动机的理论基础。代码中使用`sum`数组记录子树和，逻辑直观。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在实现AC自动机的过程中，以下三个关键点最容易出错或耗时，需要重点突破：
</difficulty_intro>

1.  **关键点1：如何高效构建fail指针？**
    * **分析**：fail指针的构建是AC自动机的核心。每个节点的fail指针指向其最长真后缀对应的Trie节点。构建时需用BFS遍历Trie树，利用父节点的fail指针推导子节点的fail指针（如`fail[tr[u][c]] = tr[fail[u]][c]`）。这一步需注意根节点的特殊处理（所有子节点的fail初始指向根）。
    * 💡 **学习笔记**：BFS是构建fail指针的标准方法，确保每个节点的fail指针在父节点处理完成后计算。

2.  **关键点2：如何避免暴力跳fail指针导致的超时？**
    * **分析**：传统方法在匹配时对每个节点暴力跳fail链（如`for (j=now; j; j=fail[j])`），最坏情况下时间复杂度为O(m·n)。优化方法是：匹配时仅记录每个节点的访问次数（`siz[u]++`），最后通过拓扑排序或DFS遍历fail树，将子节点的计数累加到父节点（`siz[fail[u]] += siz[u]`）。
    * 💡 **学习笔记**：fail树的子树和统计是优化的核心，利用树的层级结构避免重复计算。

3.  **关键点3：如何处理重复的模式串？**
    * **分析**：当多个模式串完全相同时，它们在Trie树中会共享同一个终止节点。需用额外数组（如`Map[i]`）记录每个模式串对应的首次出现节点，输出时直接查询该节点的计数。
    * 💡 **学习笔记**：重复模式串的处理需在插入Trie树时标记首次出现的节点，后续模式串直接映射到该节点。

### ✨ 解题技巧总结
- **Trie树构建**：插入模式串时，逐字符扩展Trie节点，终止节点记录模式串的索引（首次出现）。
- **fail指针优化**：BFS构建fail指针，同时维护入度数组（用于拓扑排序）。
- **计数优化**：匹配时仅记录节点访问次数，通过拓扑排序或DFS遍历fail树累加计数。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，结合了拓扑排序优化和重复模式串处理，适合直接作为竞赛模板使用。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了hyfhaha和August_Light的题解思路，采用拓扑排序优化计数，处理重复模式串，时间复杂度O(m+n)，适合大规模数据。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MAXN = 2e5 + 5; // 模式串总长度上限
    const int SIGMA = 26;      // 字符集大小（小写字母）

    struct Node {
        int son[SIGMA]; // 子节点索引
        int fail;       // 失配指针
        int cnt;        // 匹配次数（需累加）
        int in;         // 入度（用于拓扑排序）
    } trie[MAXN];

    int tot = 1;                  // Trie节点总数（根节点为0）
    vector<int> end_nodes[MAXN];  // 终止节点对应的模式串索引（处理重复）
    int ans[MAXN];                // 各模式串的最终出现次数
    int Map[MAXN];                // 记录重复模式串的首次节点

    // 插入模式串s，索引为id
    void insert(const string& s, int id) {
        int u = 0;
        for (char ch : s) {
            int c = ch - 'a';
            if (!trie[u].son[c]) trie[u].son[c] = ++tot;
            u = trie[u].son[c];
        }
        if (end_nodes[u].empty()) Map[id] = u; // 首次出现，记录节点
        else Map[id] = Map[end_nodes[u][0]];   // 重复模式串，映射到首次节点
        end_nodes[u].push_back(id);
    }

    // 构建fail指针和入度数组
    void build_fail() {
        queue<int> q;
        for (int c = 0; c < SIGMA; ++c) {
            if (trie[0].son[c]) q.push(trie[0].son[c]);
        }
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int c = 0; c < SIGMA; ++c) {
                int v = trie[u].son[c];
                if (v) {
                    trie[v].fail = trie[trie[u].fail].son[c];
                    trie[trie[v].fail].in++; // 入度+1（fail树边）
                    q.push(v);
                } else {
                    trie[u].son[c] = trie[trie[u].fail].son[c];
                }
            }
        }
    }

    // 匹配文本串s，统计节点访问次数
    void query(const string& s) {
        int u = 0;
        for (char ch : s) {
            int c = ch - 'a';
            u = trie[u].son[c];
            trie[u].cnt++;
        }
    }

    // 拓扑排序累加计数
    void topo_sort() {
        queue<int> q;
        for (int i = 1; i <= tot; ++i) {
            if (trie[i].in == 0) q.push(i);
        }
        while (!q.empty()) {
            int u = q.front(); q.pop();
            // 处理当前节点的所有模式串
            for (int id : end_nodes[u]) ans[id] = trie[u].cnt;
            // 累加到fail节点
            int v = trie[u].fail;
            trie[v].cnt += trie[u].cnt;
            if (--trie[v].in == 0) q.push(v);
        }
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        int n; cin >> n;
        for (int i = 1; i <= n; ++i) {
            string s; cin >> s;
            insert(s, i);
        }
        build_fail();
        string text; cin >> text;
        query(text);
        topo_sort();
        for (int i = 1; i <= n; ++i) {
            cout << ans[i] << '\n';
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先插入所有模式串到Trie树（处理重复模式串），然后构建fail指针并维护入度数组。匹配文本串时，仅记录每个节点的访问次数，最后通过拓扑排序累加fail树的计数，确保每个模式串的出现次数正确统计。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，学习其中的优化技巧。
</code_intro_selected>

**题解一：hyfhaha（来源：洛谷题解）**
* **亮点**：通过拓扑排序优化计数，避免暴力跳fail，时间复杂度稳定为O(m+n)。
* **核心代码片段**：
    ```cpp
    void topu() {
        for(int i=1;i<=cnt;++i)
            if(in[i]==0) q.push(i);
        while(!q.empty()){
            int u=q.front(); q.pop();
            vis[trie[u].flag]=trie[u].ans;
            int v=trie[u].fail; in[v]--;
            trie[v].ans+=trie[u].ans;
            if(in[v]==0) q.push(v);
        }
    }
    ```
* **代码解读**：这段代码实现了拓扑排序的计数累加。首先将入度为0的节点（fail树的叶节点）入队，然后依次处理每个节点：将当前节点的计数赋给对应模式串（`vis[trie[u].flag]`），再将当前节点的计数累加到其fail节点（`trie[v].ans += trie[u].ans`），直到所有节点处理完成。这种方法确保每个节点仅被处理一次，时间复杂度O(n)。
* 💡 **学习笔记**：拓扑排序是处理树状结构（如fail树）的高效方法，确保父节点在子节点处理完成后更新，避免重复计算。

**题解二：ouuan（来源：洛谷题解）**
* **亮点**：利用fail树的子树和统计，通过DFS遍历累加计数，代码简洁。
* **核心代码片段**：
    ```cpp
    void dfs(int u) {
        int i, v;
        for (i = head[u]; i; i = nxt[i]) {
            v = to[i];
            dfs(v);
            siz[u] += siz[v];
        }
    }
    ```
* **代码解读**：这段代码通过DFS遍历fail树（邻接表存储），将子节点的计数累加到父节点（`siz[u] += siz[v]`）。最终，每个模式串终止节点的`siz`值即为其在文本中的出现次数。DFS遍历确保子节点先于父节点处理，符合树的层级结构。
* 💡 **学习笔记**：fail树的子树和统计本质是树形DP，利用后序遍历（子节点先处理）实现计数的正确累加。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解AC自动机的运行过程，我们设计一个“像素探险队”主题的8位风格动画，模拟Trie构建、fail指针生成、文本匹配及计数优化的全过程。
</visualization_intro>

  * **动画演示主题**：`像素探险队的字符串冒险`

  * **核心演示内容**：
    - Trie树构建：探险队在“字符大陆”上搭建房屋（像素方块），每个房屋代表一个Trie节点，路径代表模式串的字符。
    - fail指针生成：蓝色箭头连接房屋（节点），表示失配时的跳转路径（fail指针）。
    - 文本匹配：探险队沿着文本串路径移动（黄色高亮），每到达一个房屋就在该房屋的计数器（数字显示）加1。
    - 拓扑排序优化：像素小货车按拓扑序（队列顺序）搬运计数器，将子房屋的计数累加到父房屋（fail指针指向的节点）。

  * **设计思路简述**：
    8位像素风格（如FC红白机）营造轻松氛围，颜色标记关键步骤（绿色为Trie节点，蓝色为fail指针，黄色为匹配路径）。音效（如“叮”声表示节点访问，“滴”声表示fail指针生成）强化操作记忆。拓扑排序的队列流动（小货车搬运）直观展示计数累加过程，帮助理解优化原理。

  * **动画帧步骤与交互关键点**：

    1.  **Trie构建（初始化场景）**：
        - 屏幕左侧显示“字符大陆”，根节点（大红色方块）位于中央。
        - 输入模式串时，探险队从根节点出发，按字符顺序放置绿色方块（子节点），路径上显示字符（如“a”→“b”）。
        - 重复模式串时，用紫色方块标记共享的终止节点。

    2.  **fail指针生成（BFS过程）**：
        - 队列（蓝色管道）中依次弹出节点，为每个子节点生成蓝色箭头（fail指针），指向最长真后缀的节点。
        - 入度数组（黄色数字）显示在节点上方，入度为0的节点闪烁提示。

    3.  **文本匹配（路径高亮）**：
        - 输入文本串时，探险队从根节点出发，按字符顺序移动（黄色脚印），每到达一个节点，该节点的计数器（白色数字）加1并闪烁。

    4.  **拓扑排序优化（计数累加）**：
        - 入度为0的节点（绿色闪烁）进入队列（蓝色管道），像素小货车将其计数器值搬运到fail指针指向的节点（父节点），父节点的计数器累加并更新。
        - 所有节点处理完成后，终止节点的计数器值即为对应模式串的出现次数（红色高亮显示）。

  * **旁白提示**：
    - “看！探险队正在搭建Trie树，每个方块代表一个字符节点～”
    - “蓝色箭头是fail指针，失配时会跳转到这里哦！”
    - “黄色脚印是文本串的匹配路径，每到一个节点就记一次数～”
    - “小货车来搬运计数啦！子节点的计数会累加到父节点，这样就不用暴力跳转啦～”

<visualization_conclusion>
通过这个像素动画，你可以直观看到AC自动机的每一步操作，从Trie构建到匹配优化，轻松理解算法的核心逻辑！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
AC自动机的核心是多模式匹配，其思想（Trie树+fail指针）还可用于解决其他字符串问题。掌握后，你可以挑战以下题目：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - **多模式串统计**：如统计多个敏感词在文本中的出现次数（反垃圾系统）。
    - **后缀匹配**：利用fail树的子树和统计，快速找到所有以某子串结尾的模式串。
    - **AC自动机与其他算法结合**：如与动态规划结合，处理带限制的多模式匹配（如禁止某些模式串连续出现）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3808** - `AC自动机（简单版）`  
        🗣️ **推荐理由**：AC自动机的基础应用，适合练习Trie构建和基础匹配逻辑。
    2.  **洛谷 P3796** - `AC自动机（简单版 II）`  
        🗣️ **推荐理由**：统计模式串出现次数，需处理终止节点的计数，为本题的前置练习。
    3.  **洛谷 P5829** - `【模板】失配树`  
        🗣️ **推荐理由**：理解KMP的fail树，与AC自动机的fail树原理相通，强化树结构的应用。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验和优化思路，这些对我们很有启发：
</insights_intro>

> **参考经验 (来自 hyfhaha)**：“最初用暴力跳fail指针提交，结果TLE了。后来意识到需要拓扑排序优化，通过记录每个节点的访问次数，最后统一累加，才通过了题目。”

**点评**：hyfhaha的经验提醒我们，在处理大规模数据时，必须关注时间复杂度的优化。暴力方法在极端数据下容易超时，需要通过树结构（如fail树）或拓扑排序等技巧将时间复杂度降至线性。这也提示我们，在编码前应先分析算法的时间复杂度，避免“想当然”的实现。

---

<conclusion>
通过这篇指南，你已经掌握了AC自动机的核心实现和优化技巧。记住，多模式匹配的关键是Trie树和fail指针的高效处理，而拓扑排序或fail树的子树和统计是避免超时的关键。接下来，动手练习推荐题目，巩固所学吧！下次见～ 💪
</conclusion>

---
处理用时：192.12秒
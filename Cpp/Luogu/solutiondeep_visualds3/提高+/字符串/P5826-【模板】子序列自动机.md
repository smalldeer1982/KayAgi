# 题目信息

# 【模板】子序列自动机

## 题目背景

本题中，若 $x$ 是 $y$ 的子序列，则等价于存在一个**单调递增**序列 $z$，满足 $|z| = |x|$，$z_{|x|} \leq |y|$，且 $\forall i \in [1, ~|x|],~y_{z_i} = x_i$。其中 $|x|,~|y|,~|z|$ 分别代表序列 $x,~y,~z$ 的长度，$x_i,~y_i,~z_i$ 分别代表序列 $x,~y,~z$ 的第 $i$ 项。

这是一道在 ``yLOI2020`` 备选题里被毙掉的题目。

## 题目描述

给定一个长度为 $n$ 的正整数序列 $a$ ，有 $q$ 次询问，第 $i$ 次询问给定一个长度为 $L_i$ 的序列 $b_i$，请你判断 $b_i$ 是不是 $a$ 的子序列。序列 $a$ 和所有 $b_i$ 中的元素都不大于一个给定的正整数 $m$。

## 说明/提示

#### 样例 1 解释

- 对于第一次询问，原序列中没有 $5$，所以给定序列显然不是原序列的子序列。
- 对于第二次询问，存在两个合法的序列 $z$，分别是 $\{2,~3\}$ 和 $\{2,~4\}$。即 $a_{2} = b_{2, 1},~a_3 = b_{2, 2}$ 或 $a_2 = b_{2, 1},~a_{4} = b_{2, 2}$。这里 $b_{i, j}$ 代表序列 $b_i$ 的第 $j$ 个元素，序列 $z$ 的含义见【题目背景】，下同。
- 对于第三次询问，不存在合法的序列 $z$。
- 对于第四次询问，存在两个合法的序列 $z$，分别是 $\{1,~3,~5\}$ 和 $\{1,~4,~5\}$。
- 对于第五次询问，存在一个合法的序列 $z$，为 $\{1,~2,~3,~4,~5\}$。

#### 数据范围与约定

**本题采用多测试点捆绑测试，共有 3 个子任务**。

- Subtask 1（20 points）：$type = 1$，$n, q, m \leq 100$，$\sum_{i = 1}^{q} l_i \leq 10^3$。
- Subtask 2（35 points）：$type = 2$，$n,q \leq 10^5$，$m \leq 26$，$\sum_{i = 1}^{q} l_i \leq 10^6$。
- Subtask 3（45 points）：$type = 3$，$n,q,m \leq 10^5$，$\sum_{i = 1}^q L_i \leq 10^6$。

对于全部的测试点，保证 $1 \leq n, m, q \leq 10^5$，$1 \leq a_i, b_{i, j} \leq m$，$1 \leq l_i \leq 10^6$，$\sum_{i = 1}^{q} l_i \leq 10^6$。


### 提示

- 请注意常数因子对程序效率造成的影响。
- 本题输入规模较大，请注意数据读入对程序效率造成的影响。
- 请注意输入第一行的顺序为先输入询问次数 $q$，再输入序列元素最大值 $m$。

## 样例 #1

### 输入

```
0 5 5 5
1 3 2 2 4
3 1 5 2
2 3 2
3 1 2 3
3 1 2 4
5 1 3 2 2 4
```

### 输出

```
No
Yes
No
Yes
Yes```

# AI分析结果



---
# 💡 Kay的C++算法解析：【模板】子序列自动机 深入学习指南 💡

<introduction>
今天我们要一起攻克“【模板】子序列自动机”这道题！这道题的核心是判断一个序列是否是另一个序列的子序列，涉及高效预处理和快速匹配的技巧。通过分析不同题解，我们将掌握多种解法的核心思想，并用有趣的像素动画直观理解算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（预处理+二分查找）` & `数据结构优化（可持久化线段树）`

🗣️ **初步分析**：
判断一个序列是否是另一个序列的子序列，关键在于快速找到原序列中每个字符的“下一个出现位置”。就像玩“找朋友”游戏——我们需要在原序列中，从当前位置开始，找到第一个和询问序列下一个字符相同的位置。

- **核心思路对比**：
  - **暴力法**：逐个字符遍历原序列，时间复杂度高（O(nL)），适合小数据。
  - **预处理next数组**：提前记录每个位置i后每个字符j的首次出现位置，匹配时O(L)时间，但字符集大时空间爆炸（O(nm)）。
  - **vector+二分法**：将原序列中每个字符的出现位置存入vector，匹配时用二分查找快速定位下一个位置，时间复杂度O((n + ∑L) log m)，简单高效。
  - **可持久化线段树**：用主席树优化next数组存储，解决字符集大的问题，时间复杂度O((n + ∑L) log m)，适合大数据。

- **可视化设计思路**：设计“像素探险”动画，用8位像素块表示原序列元素。匹配时，用闪烁箭头标记当前查找的字符，二分过程用左右指针移动动画展示，找到目标位置时播放“叮”的音效，失败时用红色标记。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，以下题解在思路清晰度、代码效率和实践价值上表现突出（≥4星）：
</eval_intro>

**题解一：AThousandSuns的vector+二分法**  
*来源：用户AThousandSuns的题解*  
*点评*：此题解思路简洁巧妙！通过将原序列中每个字符的出现位置存入vector，利用二分查找快速定位下一个匹配位置。代码仅用vector和lower_bound函数，实现极其简单，时间复杂度优秀（O((n + ∑L) log m)），空间复杂度O(n + m)，非常适合竞赛实战。关键是抓住了“贪心匹配最前位置”的核心，避免了复杂数据结构。

**题解二：一扶苏一的可持久化线段树**  
*来源：用户一扶苏一的题解*  
*点评*：此解法是处理大数据的标准方案！利用可持久化线段树（主席树）优化next数组存储，解决了字符集大时的空间问题。代码规范，注释清晰，展示了如何通过数据结构优化将时间复杂度控制在O((n + ∑L) log m)，适合理解高级数据结构的应用。

**题解三：_lfxxx_的二分法**  
*来源：用户_lfxxx_的题解*  
*点评*：此题解与AThousandSuns思路一致，但代码更精简。通过upper_bound直接查找第一个大于当前位置的元素，逻辑清晰，适合快速上手。特别适合刚学二分查找的同学参考。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于高效预处理和快速匹配，以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **难点1：如何高效预处理原序列的字符位置？**  
    *分析*：直接存储每个字符的所有出现位置是关键。例如，原序列为`[1,3,2,2,4]`，则字符2的位置是`[3,4]`。使用vector存储这些位置，天然有序，便于后续二分查找。  
    *💡 学习笔记*：预处理时按字符分类存储位置，是解决子序列问题的常用技巧。

2.  **难点2：如何快速找到下一个匹配位置？**  
    *分析*：对于询问序列的当前字符，需要在原序列中从当前位置的下一个位置开始，找到第一个匹配的位置。使用二分查找（如lower_bound）可以在O(log k)时间内完成（k为该字符在原序列中的出现次数）。  
    *💡 学习笔记*：二分查找是“在有序数组中找边界”的利器，记得用`lower_bound(target + 1)`找第一个大于当前位置的元素。

3.  **难点3：字符集大时如何优化空间？**  
    *分析*：当字符集m很大（如1e5），直接开二维数组存储next[i][j]会空间爆炸。此时可持久化线段树（主席树）是解决方案，它通过共享历史版本数据，仅存储变化的部分，空间复杂度O(n log m)。  
    *💡 学习笔记*：可持久化数据结构适合处理“每次修改仅改变少量数据”的场景。

### ✨ 解题技巧总结
- **预处理分类存储**：将原序列按字符分类存储出现位置，便于后续快速查询。
- **二分查找优化**：利用有序数组的二分查找，将匹配时间从O(n)降至O(log k)。
- **可持久化数据结构**：处理大字符集时，用主席树优化空间，保持时间复杂度。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择两种典型解法的核心代码，分别展示vector+二分法的简洁和可持久化线段树的高效。
</code_intro_overall>

### 本题通用核心C++实现参考（vector+二分法）
* **说明**：此代码综合了AThousandSuns和_lfxxx_的思路，是最简洁高效的实现，适合大多数数据范围。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXM = 1e5 + 5;
    vector<int> pos[MAXM]; // 存储每个字符的所有出现位置（按顺序）

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        int type, n, q, m;
        cin >> type >> n >> q >> m;
        for (int i = 1; i <= n; ++i) {
            int x;
            cin >> x;
            pos[x].push_back(i); // 记录每个字符的位置
        }
        while (q--) {
            int l;
            cin >> l;
            int cur = 0; // 当前匹配到原序列的位置
            bool ok = true;
            while (l--) {
                int x;
                cin >> x;
                if (!ok) continue;
                // 找第一个大于cur的位置
                auto it = upper_bound(pos[x].begin(), pos[x].end(), cur);
                if (it == pos[x].end()) {
                    ok = false;
                } else {
                    cur = *it; // 更新当前位置
                }
            }
            cout << (ok ? "Yes\n" : "No\n");
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先预处理原序列，将每个字符的出现位置存入vector。对于每个询问，逐个字符在对应的vector中用upper_bound查找第一个大于当前位置的元素。若找到则更新当前位置，否则标记失败。最终输出是否所有字符都匹配成功。

---

<code_intro_selected>
接下来分析两种优质题解的核心代码片段：
</code_intro_selected>

**题解一：AThousandSuns的vector+二分法**
* **亮点**：代码简洁，利用STL的vector和upper_bound，实现了O((n + ∑L) log m)的高效算法。
* **核心代码片段**：
    ```cpp
    vector<int> v[maxn];
    // ... 读入原序列到v[x]中 ...
    while(q--){
        int l=read(),at=0;
        bool flag=true;
        while(l--){
            int x=read();
            if(!flag) continue;
            auto it=lower_bound(v[x].begin(),v[x].end(),at+1);
            if(it==v[x].end()) flag=false;
            else at=*it;
        }
        puts(flag?"Yes":"No");
    }
    ```
* **代码解读**：  
  `v[x]`存储字符x在原序列中的所有出现位置（升序）。`lower_bound(v[x].begin(), v[x].end(), at+1)`找到第一个≥at+1的位置，即原序列中在at之后第一个出现x的位置。若找到则更新at，否则标记失败。  
* 💡 **学习笔记**：`lower_bound(target)`找的是≥target的第一个元素，这里`at+1`确保位置严格递增。

**题解二：一扶苏一的可持久化线段树**
* **亮点**：用主席树优化next数组存储，解决大字符集问题，时间复杂度O((n + ∑L) log m)。
* **核心代码片段**：
    ```cpp
    struct Tree {
        Tree *ls, *rs;
        int l, r, v;
        Tree(int L, int R) : l(L), r(R), v(-1) { /* 初始化左右子树 */ }
        Tree(Tree *pre, int P, int V) { /* 复制并更新P位置为V */ }
        int query(int x) { /* 查询x位置的值 */ }
    };
    Tree *rot[maxn]; // 每个位置的主席树根节点

    int main() {
        // 倒序构建主席树，rot[i-1]是rot[i]的副本，并更新a[i]的位置为i
        for (int i = n; i; --i) {
            rot[i - 1] = new Tree(rot[i], MU[i], i);
        }
        // 查询时从rot[0]开始，每次查询当前字符的位置
        while(q--) {
            int pos = 0;
            while(L-- && pos != -1) {
                pos = rot[pos]->query(x);
            }
            puts(pos != -1 ? "Yes" : "No");
        }
    }
    ```
* **代码解读**：  
  主席树`rot[i]`表示原序列从i位置开始，每个字符的下一个出现位置。倒序构建时，`rot[i-1]`复用`rot[i]`的结构，仅更新当前字符`a[i]`的位置为i。查询时，从`rot[0]`开始，依次查询每个字符的下一个位置，若中途为-1则失败。  
* 💡 **学习笔记**：主席树通过共享历史版本，仅存储变化的节点，节省空间。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解vector+二分法的匹配过程，我们设计“像素探险”动画，用8位像素风格展示原序列和询问序列的匹配过程！
</visualization_intro>

  * **动画演示主题**：`像素小探险家找朋友`  
  * **核心演示内容**：原序列是一排彩色像素块（如红色1、蓝色3、绿色2等），询问序列是小探险家需要依次找到的“朋友”。每一步，小探险家从当前位置出发，用二分法快速找到下一个“朋友”的位置。

  * **设计思路简述**：  
    8位像素风格营造复古感，像素块颜色区分不同字符。关键步骤用闪烁、音效强化记忆：找到目标时播放“叮”声，失败时播放“咚”声。通过动画，学习者能直观看到二分查找如何快速定位位置。

  * **动画帧步骤与交互关键点**：
    1. **初始化场景**：屏幕上方展示原序列的像素块（如`[1,3,2,2,4]`），每个像素块下方标注位置编号（1-5）。左侧控制面板有“单步”“自动播放”按钮和速度滑块。
    2. **开始匹配**：小探险家（黄色像素人）站在位置0（起点），第一个需要找的朋友是询问序列的第一个字符（如2）。
    3. **二分查找过程**：
       - 原序列中字符2的位置是`[3,4]`，用虚线框标出。
       - 二分指针左=0，右=1（数组索引），中间=0。检查中间位置3是否>当前位置0？是，记录候选位置3，右=0。
       - 指针收敛，找到第一个>0的位置3，小探险家移动到位置3，像素块3闪烁并播放“叮”声。
    4. **匹配成功/失败**：若所有字符都匹配，小探险家到达终点，播放胜利音效（如8位音乐）；若中途找不到，小探险家摔倒，播放“咚”声并显示“失败”。
    5. **交互控制**：支持单步执行（每点击一次执行一个字符匹配）、自动播放（可调整速度）、重置（回到起点）。

  * **旁白提示**：
    - “现在，小探险家需要找到下一个字符2，当前位置是0。我们在字符2的位置列表[3,4]中，用二分法找第一个大于0的位置。”
    - “看！中间位置是3，大于0，所以可能是候选。继续缩小范围，最终找到3。”
    - “成功匹配！小探险家移动到位置3，继续找下一个字符。”

<visualization_conclusion>
通过这个动画，我们能清晰看到二分查找如何快速定位下一个匹配位置，理解vector+二分法的高效性！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握子序列判断的核心思想后，我们可以尝试以下拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    子序列判断的核心是“贪心匹配最前位置”，这一思路还适用于：
    - 求两个序列的最长公共子序列（LCS）。
    - 判断字符串是否是另一个字符串的子序列（如LeetCode 392）。
    - 处理多模式匹配问题（如AC自动机结合子序列判断）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3500** - `[POI2010]ANT-Antisymmetry`  
        🗣️ **推荐理由**：需要判断字符串的子串是否为反对称串，涉及子序列的变形应用。
    2.  **洛谷 P1115** - `最大子段和`  
        🗣️ **推荐理由**：虽然是最大子段和，但贪心思想与子序列判断类似，可巩固“最前匹配”的思维。
    3.  **洛谷 P1963** - `[NOI2009]诗人小G`  
        🗣️ **推荐理由**：涉及动态规划与子序列的结合，适合提升综合解题能力。

-----

## 7\. 学习心得与经验分享 

<insights_intro>
题解中作者提到的调试经验对我们很有启发：
</insights_intro>

> **参考经验 (来自用户AThousandSuns)**：“一开始没想到用vector+二分，后来发现原序列中每个字符的位置是有序的，直接二分就能快速查找。这让我意识到，预处理和数据结构的选择是解决问题的关键。”

**点评**：这位作者的经验提醒我们，遇到子序列问题时，先观察数据特点（如位置有序），再选择合适的数据结构（如vector存储位置+二分查找）。这种“先分析后动手”的习惯能避免走弯路。

-----

<conclusion>
通过今天的分析，我们掌握了子序列判断的多种高效解法，理解了预处理、二分查找和可持久化线段树的应用。记住，编程的关键是“分析问题本质+选择合适工具”。快去用这些方法解决更多问题吧！💪
</conclusion>

---
处理用时：152.42秒
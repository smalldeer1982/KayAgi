# 题目信息

# 「SWTR-5」Chain

## 题目描述

给定 $n$ 个点，$m$ 条边的有向无环图。不保证图连通。

$q$ 次询问，每次给出 $k$ 和 $k$ 个互不相同的数 $c_i$，求出如果去掉这 $k$ 个点，整个有向无环图将剩余多少条链。答案对 $10^9+7$ 取模。**每次询问独立。**

- “链”的定义是：我们设一条长度为 $p$ 的链的路径为 $w_0\to w_1\to\cdots\to w_{p-1}\to w_p$，则应满足 $w_0$ 入度为 $0$，$w_p$ 出度为 $0$。你可以将其理解为一条食物链。

- 两条链是“不同的”，当且仅当它们的长度不同，或者经过的点集不同。

- **需要特别注意的是，删去某些点后新产生的链不计入答案。** 例如 $1\to 2\to 3\to 4$ 一图中，有 $1$ 条链 $1\to 2\to 3\to 4$。如果去掉 $2$ 号点，则剩余 $0$ 条链。

## 说明/提示

「样例 $1$ 说明」

DAG 如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2gbdoemh.png)

询问 $1$：如果去掉 $2,4,6$，则剩余 $1$ 条链：$3\to 5$。

询问 $2$：如果去掉 $4,6$，则剩余 $3$ 条链：$3\to 5$，$3\to 2\to 5$，$3\to 7\to 2\to 5$。

询问 $7$：如果去掉 $6$，则剩余 $5$ 条链：$3\to 5$，$3\to 2\to 5$，$3\to 7\to 2\to 5$，$3\to 1\to 4\to 5$，$3\to 7\to 4\to 5$。

「数据范围与约定」

**本题采用捆绑测试。**

- Subtask 1（1 point）：给定的图是一条链。
- Subtask 2（14 points）：$n,q\leq 10$。
- Subtask 3（20 points）：$q\leq 10^3$。
- Subtask 4（17 points）：$k=1$。
- Subtask 5（18 points）：$k=2$。
- Subtask 6（30 points）：无特殊限制。

对于 $100\%$ 的数据：$2\leq n\leq 2\times 10^3$，$1\leq m\leq \min(\frac{n\times(n-1)}{2},2\times 10^4)$，$1\leq q\leq 5\times 10^5$。  
所有询问满足：$1\leq \sum k\leq 2\times 10^6$，$0\leq k\leq \min(n,15)$，$1\leq c_i\leq n$。保证 $c_i$ 互不相同。

**本题轻微卡常，请注意 IO 优化。**

---

「题目来源」

[Sweet Round 05](https://www.luogu.com.cn/contest/28195) D。  
idea & solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。

## 样例 #1

### 输入

```
7 14
3 2
4 5
2 5
2 6
3 1
3 5
3 7
3 6
6 4
1 4
6 5
1 6
7 2
7 4
7
3 2 4 6
2 4 6
2 2 5
2 1 4
0
1 4
1 6```

### 输出

```
1
3
0
6
13
7
5```

## 样例 #2

### 输入

```
233 1
1 2
6
0
1 10
2 10 40
1 1
1 2
2 1 2```

### 输出

```
232
231
230
231
231
231```

# AI分析结果



---
# 💡 Kay的C++算法解析：「SWTR-5」Chain 深入学习指南 💡

<introduction>
今天我们要挑战的题目是「SWTR-5」Chain！这道题围绕有向无环图（DAG）的多次删除点操作展开，要求计算删除后剩余的链（从入度为0的点到出度为0的点的路径）数量。让我们一起拆解问题，掌握核心思路吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（DAG路径计数 + 容斥原理）

🗣️ **初步分析**：
解决这道题的关键在于理解DAG的结构特性和如何高效处理多次删除点的查询。我们可以把DAG想象成一个“像素食物链”——入度为0的点是“生产者”（如草），出度为0的点是“顶级消费者”（如狮子），链就是从生产者到顶级消费者的完整食物链。每次删除一些“生物”（点），我们需要快速计算剩下的食物链数量。

核心算法分为两步：
1. **预处理**：通过拓扑排序，计算每个点的“上游路径数”（从所有生产者到该点的路径数，记为`f[i]`）和“下游路径数”（从该点到所有顶级消费者的路径数，记为`g[i]`）。同时预处理任意两点间的路径数`d[u][v]`（u到v的路径数）。
2. **容斥处理查询**：每次删除的点按拓扑序排序（保证处理顺序是从上游到下游），通过动态调整每个被删点的有效贡献（减去被更上游删除点影响的路径），最终用总链数减去所有被删点的有效贡献之和。

**可视化设计思路**：我们将用8位像素风格展示DAG，节点用彩色方块表示（生产者绿色，顶级消费者红色），边用箭头连接。动画会动态演示拓扑排序过程（节点按顺序亮起）、路径数的累加（数字气泡弹出），以及删除点时的容斥调整（被删节点变灰，路径数动态扣除）。关键步骤伴随“叮”的音效，完成查询时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过对各题解的评估（思路清晰度、代码规范性、算法效率），以下题解因逻辑简洁、实现高效被选为优质参考：
</eval_intro>

**题解一：作者a___（赞：8）**
* **点评**：此题解巧妙结合拓扑排序与动态规划，代码结构清晰。通过预处理每个点的拓扑序和路径数，再在查询时按拓扑序调整被删点的贡献，时间复杂度为O(nm + k∑k)，非常适合处理大规模查询。代码中`f`数组记录上游路径数，`g`数组记录下游路径数，变量命名直观，边界处理严谨（如取模操作），是竞赛代码的典范。

**题解二：作者yxzy4615（赞：11）**
* **点评**：此题解从子任务出发，逐步推导到一般情况，思路层层递进。特别在分析k=1和k=2的情况时，通过具体样例解释容斥原理的应用，非常适合理解问题本质。预处理路径数的方法与拓扑序结合，为后续高效查询奠定基础，是理论与实践结合的好例子。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的过程中，我们需要突破以下核心难点：
</difficulty_intro>

1.  **关键点1：如何预处理DAG中的路径数？**
    * **分析**：DAG的无环特性允许我们按拓扑序计算路径数。例如，计算上游路径数`f[i]`时，只需遍历所有入边，将前驱节点的`f`值累加到当前节点（类似动态规划）。下游路径数`g[i]`则反向拓扑排序，从出度为0的点开始累加。
    * 💡 **学习笔记**：拓扑排序是DAG路径计数的“钥匙”，它保证了计算顺序的正确性（无后效性）。

2.  **关键点2：如何处理多个删除点的容斥？**
    * **分析**：直接删除k个点时，若两点在同一条链上（如u→v），直接相减会重复扣除u到v的路径。因此需要按拓扑序排序被删点（u在v前），调整v的贡献为`f[v] - f[u] * d[u][v]`（即v不经过u的路径数）。
    * 💡 **学习笔记**：拓扑序排序是容斥的“顺序保证”，确保先处理上游点，再处理下游点。

3.  **关键点3：如何高效应对大规模查询？**
    * **分析**：预处理阶段计算所有点对路径数`d[u][v]`（O(nm)），查询时按拓扑序调整被删点的贡献（O(k²)），总复杂度为O(nm + k∑k)，能应对q=5e5的查询。
    * 💡 **学习笔记**：预处理是“以空间换时间”的经典策略，适合处理多次查询问题。

### ✨ 解题技巧总结
- **拓扑序预处理**：先正向拓扑计算上游路径数，再反向拓扑计算下游路径数。
- **路径数存储**：用二维数组`d[u][v]`记录u到v的路径数，方便容斥时快速查询。
- **取模处理**：所有运算后及时取模，避免溢出；调整贡献时加MOD再取模，防止负数。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，提炼出一个简洁高效的核心实现，涵盖预处理和查询的关键步骤。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了a___和yxzy4615的题解思路，预处理拓扑序、路径数，查询时按拓扑序调整贡献。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <algorithm>
    const int N = 2010, M = 20010, MOD = 1e9 + 7;
    int n, m, q, cnt, las[N], nxt[M], to[M], du[N], c[N], d[N], f[N], g[N], h[N][N], q[N], id[N], sum, ans;

    inline void add(int u, int v) {
        to[++cnt] = v;
        nxt[cnt] = las[u];
        las[u] = cnt;
        ++du[v];
    }

    bool cmp(const int &x, const int &y) { return id[x] < id[y]; }

    int main() {
        int i, j, k, x, y, hd, tl = 0;
        scanf("%d%d", &n, &m);
        for (i = 1; i <= m; ++i) {
            scanf("%d%d", &x, &y);
            add(x, y);
        }
        // 正向拓扑计算上游路径数f
        for (i = 1; i <= n; ++i) if (!du[i]) f[q[++tl] = i] = 1;
        for (hd = 1; hd <= tl; ++hd) 
            for (i = las[q[hd]]; i; i = nxt[i]) 
                f[to[i]] = (f[to[i]] + f[q[hd]]) % MOD, 
                --du[to[i]] == 0 ? q[++tl] = to[i] : 0;
        // 反向拓扑计算下游路径数g，并计算总链数sum
        for (hd = tl; hd >= 1; --hd) 
            if (las[q[hd]]) for (i = las[q[hd]]; i; i = nxt[i]) 
                g[q[hd]] = (g[q[hd]] + g[to[i]]) % MOD;
            else g[q[hd]] = 1, sum = (sum + f[q[hd]]) % MOD;
        // 预处理点对路径数h[u][v]
        for (i = 1; i <= n; ++i) {
            h[q[i]][q[i]] = 1;
            id[q[i]] = i;
            for (j = i; j <= n; ++j) 
                for (k = las[q[j]]; k; k = nxt[k]) 
                    h[q[i]][to[k]] = (h[q[i]][to[k]] + h[q[i]][q[j]]) % MOD;
        }
        // 处理查询
        scanf("%d", &q);
        while (q--) {
            scanf("%d", &m); ans = sum;
            for (i = 1; i <= m; ++i) scanf("%d", &c[i]);
            std::sort(c + 1, c + 1 + m, cmp);
            for (i = 1; i <= m; ++i) d[i] = f[c[i]];
            for (i = 1; i <= m; ++i) 
                for (j = i + 1; j <= m; ++j) 
                    d[j] = (d[j] - 1LL * d[i] * h[c[i]][c[j]] % MOD + MOD) % MOD;
            for (i = 1; i <= m; ++i) 
                ans = (ans - 1LL * d[i] * g[c[i]] % MOD + MOD) % MOD;
            printf("%d\n", ans);
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先通过正向拓扑排序计算每个点的上游路径数`f`，反向拓扑计算下游路径数`g`，并预处理点对路径数`h`。查询时，将被删点按拓扑序排序，调整每个点的有效贡献`d[i]`（扣除更上游点的影响），最终用总链数减去所有`d[i] * g[c[i]]`的和。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段，学习其中的巧妙设计。
</code_intro_selected>

**题解一：作者a___**
* **亮点**：代码简洁高效，利用拓扑序排序和动态调整贡献，完美处理容斥。
* **核心代码片段**：
    ```cpp
    for (i = 1; i <= m; ++i) d[i] = f[c[i]];
    for (i = 1; i <= m; ++i) 
        for (j = i + 1; j <= m; ++j) 
            d[j] = (d[j] - 1LL * d[i] * h[c[i]][c[j]] % MOD + MOD) % MOD;
    ```
* **代码解读**：这部分处理被删点的容斥。`d[i]`初始为被删点i的上游路径数。对于每对(i,j)（i在j前，因按拓扑序排序），j的贡献需要扣除i到j的路径数（`h[c[i]][c[j]]`）乘i的有效贡献（`d[i]`），避免重复计算。例如，若i→j有一条路径，那么j的路径数中包含i的路径，需要减去这部分。
* 💡 **学习笔记**：拓扑序排序后，先处理上游点，再处理下游点，确保容斥的正确性。

**题解二：作者yxzy4615**
* **亮点**：从子任务推导到一般情况，思路清晰，预处理路径数的方法值得学习。
* **核心代码片段**：
    ```cpp
    ans = s - sum(f[c_i] * n_f[c_i])
    ```
* **代码解读**：当k=1时，总链数s减去被删点i的上游路径数乘下游路径数（`f[i] * n_f[i]`）即为答案。这是因为`f[i] * n_f[i]`恰好是所有经过i的链的数量，删除i后这些链不再存在。
* 💡 **学习笔记**：单个点的贡献可以直接通过上下游路径数的乘积计算，这是容斥的基础。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解算法，我们设计了“像素食物链探险”动画，用8位风格展示DAG的拓扑排序、路径计算和容斥过程！
</visualization_intro>

  * **动画演示主题**：像素食物链探险——寻找完整的生产者到顶级消费者路径。

  * **核心演示内容**：拓扑排序过程（节点按顺序亮起）、路径数累加（数字气泡弹出）、删除点时的容斥调整（被删节点变灰，路径数动态扣除）。

  * **设计思路简述**：8位像素风格（如FC游戏画面）营造轻松氛围，节点颜色区分生产者（绿色）、顶级消费者（红色）、普通节点（黄色）。动画通过步进控制（单步/自动）展示每一步操作，关键步骤高亮（如当前处理节点闪烁），配合“叮”的音效强化记忆。

  * **动画帧步骤与交互关键点**：
    1. **初始化场景**：屏幕显示DAG网格，节点用彩色方块表示，边用箭头连接。控制面板包含“开始/暂停”“单步”“重置”按钮和速度滑块。
    2. **拓扑排序演示**：队列中的节点（初始为生产者）依次弹出，按拓扑序亮起（绿色渐变），并计算其下游节点的路径数（数字气泡从节点飘出，累加到目标节点）。
    3. **路径数计算**：上游路径数`f`和下游路径数`g`分别用蓝色和红色数字显示在节点上方，总链数`sum`在屏幕顶部动态更新。
    4. **查询处理**：输入被删点后，节点按拓扑序排序（用箭头标注顺序），被删节点变灰。动态调整每个被删点的贡献：更上游的节点用紫色箭头指向当前节点，路径数`d[j]`扣除`d[i] * h[i][j]`（数字气泡显示扣除过程）。
    5. **结果展示**：最终总链数`ans`用金色大字显示，伴随胜利音效（如“叮~”）。

  * **旁白提示**：
    - “看！生产者节点（绿色）开始计算路径数，每个节点的数字表示从生产者到这里的路径数哦~”
    - “现在处理删除点，先按拓扑序排好队，前面的节点会影响后面的贡献，需要扣除重复部分~”
    - “最终答案就是总链数减去所有被删点的有效贡献，完成！”

<visualization_conclusion>
通过这个动画，我们能直观看到拓扑排序如何保证计算顺序，路径数如何累加，以及容斥如何避免重复扣除。是不是更容易理解了？
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下拓展练习，巩固DAG路径计数和容斥的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - DAG路径计数可用于任务调度（计算任务完成路径数）、依赖关系分析（如软件包安装顺序）。
    - 容斥原理可处理多条件限制的计数问题（如排除多个限制条件后的方案数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1038** - 神经网络  
       * 🗣️ **推荐理由**：DAG上的信号传递问题，需要计算每个节点的输出值，与本题的路径计数思路类似。
    2.  **洛谷 P1113** - 杂务  
       * 🗣️ **推荐理由**：DAG的拓扑排序应用，计算每个任务的最早完成时间，适合练习拓扑排序的基础应用。
    3.  **洛谷 P3763** - [TJOI2017] 树的路径  
       * 🗣️ **推荐理由**：树上的路径计数问题，结合了树的结构特性和路径统计，拓展DAG之外的路径计数思维。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如处理取模时的负数问题：
</insights_intro>

> **参考经验 (来自作者xie_lzh)**：“在计算`nans`时，直接相减可能得到负数，需要加MOD后再取模。例如`nans = (nans - kk[i] * ed[c[i]] % mod + mod) % mod`，这样能保证结果非负。”

**点评**：这位作者的经验非常实用！在模运算中，减法后可能产生负数，及时加MOD再取模是避免错误的关键。这提醒我们在处理类似问题时，要特别注意模运算的边界情况。

-----

<conclusion>
通过今天的分析，我们掌握了DAG路径计数的核心方法，学会了用拓扑排序和容斥处理多次删除点的查询。记住，多动手写代码、调试，结合动画理解算法流程，你会越来越熟练！下次再见~ 💪
</conclusion>

---
处理用时：160.63秒
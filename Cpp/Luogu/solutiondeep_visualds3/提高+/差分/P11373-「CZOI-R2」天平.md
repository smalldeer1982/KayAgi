# 题目信息

# 「CZOI-R2」天平

## 题目描述

你有 $n$ 个**砝码组**，编号为 $1$ 至 $n$。对于第 $i$ 个**砝码组**中的砝码有共同的正整数质量 $a_i$，每个**砝码组**中的**砝码**数量无限。

其中，有 $q$ 次操作：

- `I x v`：在第 $x$ 个**砝码组**后新增一组单个**砝码**质量为 $v$ 的**砝码组**，当 $x=0$ 时表示在最前面新增；
- `D x`：删除第 $x$ 个**砝码组**；
- `A l r v`：把从 $l$ 到 $r$ 的所有**砝码组**中的砝码质量加 $v$；
- `Q l r v`：判断能否用从 $l$ 到 $r$ 的**砝码组**中的砝码，称出质量 $v$。每个砝码组中的砝码可以使用任意个，也可以不用。

对于操作 `I` 和 `D`，操作后编号以及 $n$ 的值自动变化。

称一些**砝码**可以称出质量 $v$，当且仅当存在将这些砝码分别放在天平两边的摆放方法，使得将 $1$ 个质量为 $v$ 的物体摆放在某边可以让天平平衡。

## 说明/提示

**【样例解释】**

对于样例组 $1$，最后有 $5$ 个中的**砝码组**，质量分别为 $5,18,9,16,2$。在天平左边放上 $1$ 个**砝码组一**中的**砝码**，右边放上 $1$ 个**砝码组三**的砝码，即可称出质量 $4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/lwd6643t.png)

**【数据范围】**

**本题采用捆绑测试**。

记 $m_1$ 为所有时刻中 $a_i$ 与 $v$ 的最小值，$m_2$ 为所有时刻中 $a_i$ 与 $v$ 的最大值。

- Subtask #1（$5\text{ pts}$）：$1\le n,q\le 10$，$1\le m_1\le m_2 \le50$。
- Subtask #2（$15\text{ pts}$）：$1\le n,q\le 4\times10^2$。
- Subtask #3（$20\text{ pts}$）：没有操作 `I` 与操作 `D`。
- Subtask #4（$60\text{ pts}$）：无特殊性质。

对于 $100\%$ 的数据，$1\le n,q\le 10^5$，$1\le m_1\le m_2\le 10^{18}$，保证所有操作合法，且任意时刻至少存在一个砝码组。

## 样例 #1

### 输入

```
5 5
1 10 8 4 2
I 2 1
A 1 4 4
A 2 4 4
D 5
Q 1 4 4```

### 输出

```
YES```

## 样例 #2

### 输入

```
10 10
2 2 1 4 2 10 8 7 10 6
Q 5 6 1
Q 5 7 7
I 5 1
Q 4 5 3
Q 2 9 2
A 3 5 1
Q 7 8 5
D 7
A 3 9 7
Q 3 7 6```

### 输出

```
NO
NO
NO
YES
NO
YES```

# AI分析结果

# 💡 Kay的C++算法解析：「CZOI-R2」天平 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（裴蜀定理） + 编程技巧应用（动态区间GCD维护）

🗣️ **初步分析**：  
解决这道题的关键，其实是先把“称量问题”翻译成“数学语言”——根据**裴蜀定理**，用无限个砝码称出质量`v`的条件，等价于`v`是这些砝码质量的**最大公约数（GCD）**的倍数。比如，若砝码质量是2和4，GCD是2，那么能称出的质量只能是2的倍数（如2、4、6…）。  

但题目中的砝码组是**动态变化**的（插入、删除、区间加），这就需要我们用**数据结构**来高效维护“区间GCD”。这里的核心技巧是**差分转换**：利用“更相减损术”（`GCD(x,y)=GCD(x,y-x)`），将原数组的GCD转化为“首元素 + 差分数组的GCD”（比如`GCD(a1,a2,a3)=GCD(a1, a2-a1, a3-a2)`）。这样一来，**区间加操作**就可以转化为对差分数组的**两个点修改**（比如给`[l,r]`加`v`，等价于差分数组的`l`位加`v`，`r+1`位减`v`），从而用平衡树或线段树轻松维护。  

**核心算法流程**：  
1. 用数据结构维护原数组的**差分序列**（如`b[i] = a[i] - a[i-1]`）；  
2. 插入/删除砝码组时，更新差分序列；  
3. 区间加时，修改差分序列的两个端点；  
4. 查询时，计算`GCD(a[l], 差分序列[l+1..r]的GCD)`，判断`v`是否是这个值的倍数。  

**可视化设计思路**：  
我会用**8位像素风**模拟“砝码仓库”场景——每个砝码组是一个彩色像素块，位置对应数组下标。插入时，块从对应位置“滑入”（伴随“叮”的音效）；删除时“滑出”（“咔”声）；区间加时，对应块的颜色变亮（“嗡”声）；查询时，从`l`到`r`的块依次闪烁，模拟“合并GCD”的过程（每合并一次，块的颜色融合），最后用“胜利音效”（正确）或“提示音效”（错误）结束。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下2份优质题解，它们分别覆盖了静态区间（线段树）和动态区间（平衡树）的实现，非常适合学习。
</eval_intro>

**题解一：(来源：A6n6d6y6)**  
* **点评**：这份题解的亮点在于**分Subtask逐步推导**——从暴力到线段树再到平衡树，完整展示了“如何从基础思路升级到高效算法”。Subtask3的线段树实现（利用差分维护静态区间GCD）逻辑清晰，Subtask4的无旋Treap实现（处理动态插入/删除）代码规范，特别是`pushup`和`split`函数的实现，完美体现了“差分+GCD”的核心技巧。题解对每个步骤的解释都很透彻，非常适合新手理解“动态区间GCD”的维护逻辑。

**题解二：(来源：破壁人罗辑)**  
* **点评**：这份题解的平衡树实现**更简洁**，重点突出了“懒标记处理区间加”的技巧。作者通过`pushdown`函数传递区间加的标记，并用每个节点维护“当前值”和“子树差分GCD”，将动态区间操作的时间复杂度降到了`O(log n)`。代码中的`check_gcd`函数直接计算区间GCD，逻辑直观，适合想快速掌握“平衡树维护动态GCD”的学习者。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键，是跨越“数学转化”和“数据结构实现”的两道坎。以下是3个核心难点及解决方案：
</difficulty_intro>

1. **难点1：如何将称量问题转化为GCD问题？**  
   * **分析**：很多同学会卡在“为什么能称出`v`等价于`v`是区间GCD的倍数”——这需要理解**裴蜀定理的推广**：对于整数`a1,a2,...,an`，存在整数`x1,x2,...,xn`使得`a1x1+a2x2+...+anxn = v`的充要条件是`GCD(a1,a2,...,an) | v`。比如，砝码质量是3和6，GCD是3，所以能称出的质量只能是3的倍数（3、6、9…）。  
   * 💡 **学习笔记**：称量问题的本质，是求“线性组合的可达性”，而GCD是这个问题的“钥匙”。

2. **难点2：如何用差分维护动态区间GCD？**  
   * **分析**：直接维护原数组的GCD无法高效处理区间加（因为区间加会改变所有元素，导致GCD需要重新计算）。但利用“更相减损术”（`GCD(x,y)=GCD(x,y-x)`），我们可以将原数组的GCD转化为“首元素 + 差分序列的GCD”。比如原数组`[a1,a2,a3]`的GCD等于`GCD(a1, a2-a1, a3-a2)`。这样一来，**区间加操作**就变成了对差分序列的**两个点修改**（比如给`[l,r]`加`v`，等价于差分序列的`l`位加`v`，`r+1`位减`v`），大幅降低了维护难度。  
   * 💡 **学习笔记**：差分是处理“区间修改、单点查询”或“区间GCD”的神器，要记住“GCD的差分转化”技巧。

3. **难点3：如何用平衡树实现动态区间操作？**  
   * **分析**：插入、删除操作需要数据结构支持“按位置分裂/合并”，平衡树（如Treap、Splay）是最佳选择。实现的核心是`split`（按位置分割树）和`merge`（合并两棵树）函数，同时要处理**懒标记**（传递区间加的增量）。比如，给`[l,r]`加`v`时，先分裂出`[l,r]`对应的子树，给子树打上“加`v`”的标记，再合并回去。  
   * 💡 **学习笔记**：平衡树的核心是“维护树的平衡”和“正确传递懒标记”，`pushdown`函数一定要在分裂/合并前调用，避免标记堆积。


### ✨ 解题技巧总结
- **技巧A：问题抽象**：遇到“线性组合可达性”问题，先想裴蜀定理，转化为GCD问题。  
- **技巧B：差分转化**：维护区间GCD时，用差分将“区间修改”转化为“点修改”，降低复杂度。  
- **技巧C：懒标记优化**：处理区间加时，用懒标记延迟修改，避免重复计算。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**动态区间GCD的平衡树实现**（来自题解一的Subtask4），它覆盖了插入、删除、区间加和查询的所有操作，逻辑完整。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码基于“无旋Treap”实现，支持动态插入、删除、区间加和区间GCD查询，是题解一中最完整的动态区间维护方案。
* **完整核心代码**：
  ```cpp
  #include<bits/stdc++.h>
  #define int long long
  #define GCD __gcd
  using namespace std;
  const int maxn=2e5+10;
  struct Treap{
      int rt,cnt,num[maxn],val[maxn],gcd[maxn],ls[maxn],rs[maxn],siz[maxn],plz[maxn],rnd[maxn];
      queue<int>del;mt19937 maker;
      Treap(){maker.seed(time(0));}
      int newnode(int x){
          int idx=del.empty()?++cnt:del.front(),del.pop();
          num[idx]=x;siz[idx]=1;ls[idx]=rs[idx]=plz[idx]=0;rnd[idx]=maker();
          return idx; 
      }
      void pushdown(int x){
          if(ls[x])num[ls[x]]+=plz[x],plz[ls[x]]+=plz[x];
          if(rs[x])num[rs[x]]+=plz[x],plz[rs[x]]+=plz[x];
          plz[x]=0;
      }
      void pushup(int x){
          siz[x]=siz[ls[x]]+siz[rs[x]]+1;
          gcd[x]=GCD(GCD(gcd[ls[x]],gcd[rs[x]]),val[x]);
      }
      void split(int x,int k,int &rt1,int &rt2){
          if(!x){rt1=rt2=0;return;}
          pushdown(x);
          if(siz[ls[x]]<k)rt1=x,split(rs[x],k-siz[ls[x]]-1,rs[x],rt2);
          else rt2=x,split(ls[x],k,rt1,ls[x]);
          pushup(x);
      }
      int merge(int x,int y){
          if(!x||!y)return x+y;
          pushdown(x),pushdown(y);
          if(rnd[x]<rnd[y]){ls[y]=merge(x,ls[y]),pushup(y);return y;}
          else{rs[x]=merge(rs[x],y),pushup(x);return x;}
      }
      int getidx(int x){
          int rt1,rt2,rt3,ans;
          split(rt,x-1,rt1,rt2),split(rt2,1,rt2,rt3),ans=rt2;
          rt=merge(merge(rt1,rt2),rt3);
          return ans;
      }
      int getgcd(int l,int r){
          int rt1,rt2,rt3,ans;
          split(rt,l-1,rt1,rt2),split(rt2,r-l+1,rt2,rt3),ans=gcd[rt2];
          rt=merge(merge(rt1,rt2),rt3);
          return ans;
      }
      void insert(int x,int y){
          int rt1,rt2,rt3,node=newnode(y);
          val[node]=GCD(0, y-num[getidx(x)]);
          split(rt,x,rt1,rt3),split(rt3,1,rt2,rt3);
          if(rt2)val[rt2]=GCD(0, num[rt2]-y);
          rt=merge(merge(rt1,node),merge(rt2,rt3));
      }
      void remove(int x){
          int rt1,rt2,rt3,tmp=num[getidx(x-1)];
          split(rt,x,rt1,rt2),split(rt2,1,rt2,rt3),val[rt2]=GCD(0, num[rt2]-tmp);
          rt=merge(merge(rt1,rt2),rt3);
          split(rt,x-1,rt1,rt2),split(rt2,1,rt2,rt3),del.push(rt2);
          rt=merge(rt1,rt3);
      }
      void update(int l,int r,int x){
          int rt1,rt2,rt3;
          split(rt,l-1,rt1,rt2),split(rt2,r-l+1,rt2,rt3);
          num[rt2]+=x,plz[rt2]+=x,rt=merge(merge(rt1,rt2),rt3);
          split(rt,l-1,rt1,rt2),split(rt2,1,rt2,rt3);
          val[rt2]+=x,gcd[rt2]+=x,rt=merge(merge(rt1,rt2),rt3);
          split(rt,r,rt1,rt2),split(rt2,1,rt2,rt3);
          if(rt2)val[rt2]-=x,gcd[rt2]-=x;
          rt=merge(merge(rt1,rt2),rt3);
      }
      int query(int l,int r){return GCD(num[getidx(l)],getgcd(l+1,r));}
  }t;
  signed main(){
      ios::sync_with_stdio(false);
      cin.tie(0);cout.tie(0);
      int n,q;cin>>n>>q;
      for(int i=1;i<=n;i++){
          int a;cin>>a;t.insert(i-1,a);
      }
      while(q--){
          char op;cin>>op;
          if(op=='I'){int x,v;cin>>x>>v;t.insert(x,v);}
          if(op=='D'){int x;cin>>x;t.remove(x);}
          if(op=='A'){int l,r,v;cin>>l>>r>>v;t.update(l,r,v);}
          if(op=='Q'){int l,r,v;cin>>l>>r>>v;cout<<(v%t.query(l,r)?"NO\n":"YES\n");}
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **Treap结构**：每个节点维护`num`（原数组值）、`val`（差分后的值）、`gcd`（子树差分的GCD）、`plz`（懒标记，区间加增量）。  
  2. **核心操作**：  
     - `split`/`merge`：按位置分裂/合并树，处理插入/删除；  
     - `pushdown`：传递懒标记，确保修改生效；  
     - `update`：区间加操作，修改`num`和`plz`；  
     - `query`：计算`GCD(a[l], 差分[l+1..r]的GCD)`，判断`v`是否是其倍数。


<code_intro_selected>
接下来剖析两份题解的核心片段，看它们如何实现“动态区间GCD”。
</code_intro_selected>

**题解一：(来源：A6n6d6y6)**
* **亮点**：用`val`维护差分序列，`pushup`合并子树GCD，完美实现“差分+GCD”的转化。
* **核心代码片段**：
  ```cpp
  void pushup(int x){
      siz[x] = siz[ls[x]] + siz[rs[x]] + 1;
      gcd[x] = GCD(GCD(gcd[ls[x]], gcd[rs[x]]), val[x]);
  }
  int query(int l,int r){
      return GCD(num[getidx(l)], getgcd(l+1, r));
  }
  ```
* **代码解读**：  
  - `pushup`函数：合并左子树、右子树和当前节点的`val`（差分后的值），得到子树的GCD——这是“差分维护GCD”的核心！  
  - `query`函数：先取`a[l]`（原数组的第`l`位），再取差分序列`[l+1..r]`的GCD，两者的GCD就是原区间的GCD——直接对应“GCD(a1, a2-a1, ..., an-a(n-1))”的公式。  
* 💡 **学习笔记**：`val`存储的是差分后的值，`gcd`存储的是子树差分的GCD，这两个变量是维护动态区间GCD的“关键钥匙”。

**题解二：(来源：破壁人罗辑)**
* **亮点**：用`tag`维护区间加懒标记，`update_gcd`函数直接计算子树的GCD，逻辑更简洁。
* **核心代码片段**：
  ```cpp
  void pushdown(int x){
      nd[x].val += nd[x].tag;
      if(nd[x].rs) nd[nd[x].rs].tag += nd[x].tag;
      if(nd[x].ls) nd[nd[x].ls].tag += nd[x].tag;
      nd[x].tag = 0;
  }
  void update_gcd(int n){
      nd[n].gcd = gcd(nd[n].ls? gcd(nd[nd[n].ls].gcd, abs(nd[nd[n].ls].val - nd[n].val)) : 0,
                      nd[n].rs? gcd(nd[nd[n].rs].gcd, abs(nd[nd[n].rs].val - nd[n].val)) : 0);
  }
  ```
* **代码解读**：  
  - `pushdown`函数：将当前节点的`tag`（区间加增量）传递给左右子树，并更新当前节点的`val`——确保区间加操作生效。  
  - `update_gcd`函数：计算当前节点的GCD，等于左子树的GCD（结合左子树最后一个节点与当前节点的差分）加上右子树的GCD（结合右子树第一个节点与当前节点的差分）——直接对应“GCD(a1, a2-a1, ...)”的公式。  
* 💡 **学习笔记**：`update_gcd`函数中的`abs(nd[nd[n].ls].val - nd[n].val)`，就是差分序列中的`a[i] - a[i-1]`，这是计算区间GCD的关键。


## 5. 算法可视化：像素动画演示

**动画演示主题**：像素砝码仓库——用8位像素风模拟“动态维护砝码组”的过程，结合“称量游戏”强化理解。

**核心演示内容**：  
1. **场景初始化**：屏幕左侧是“砝码仓库”（像素块排成一列，颜色代表不同质量），右侧是控制面板（开始/暂停、单步、重置按钮，速度滑块）。背景是FC风格的仓库壁画，伴随轻松的8位BGM。  
2. **插入操作**：输入`I 2 5`，左侧第2个块后“滑入”一个新块（颜色随机），伴随“叮”的音效——模拟“在第2个砝码组后插入质量5的砝码组”。  
3. **区间加操作**：输入`A 1 4 3`，左侧第1-4块的颜色变亮（从蓝色→浅蓝），伴随“嗡”的音效——模拟“给1-4号砝码组加3”。  
4. **查询操作**：输入`Q 1 4 4`，左侧第1-4块依次闪烁（从左到右），每个块闪烁时，上方显示“合并GCD”的过程（比如`GCD(5, 3) → 1`，`GCD(1, 2) → 1`），最后显示“YES”（绿色字体），伴随“胜利音效”——模拟“计算区间GCD，判断4是否是其倍数”。  
5. **删除操作**：输入`D 5`，左侧第5个块“滑出”屏幕，伴随“咔”的音效——模拟“删除第5个砝码组”。

**交互设计**：  
- **单步执行**：点击“单步”，动画按步骤播放，每步显示“当前操作”的文字提示（如“插入第2位”“给1-4加3”）。  
- **自动播放**：滑动速度滑块（1x~5x），动画自动执行，适合快速看整体流程。  
- **重置**：点击“重置”，场景回到初始状态，方便重新演示。

**设计思路**：  
用8位像素风降低“数据结构”的抽象感，用音效和动画强化“操作记忆”——比如“叮”对应插入，“嗡”对应区间加，“胜利音效”对应正确查询。每一步操作都有**视觉反馈**（颜色变化、滑动动画），让学习者“看得到”算法的执行过程。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
“动态区间GCD”是**数学+数据结构**的经典组合，以下问题可以帮你巩固技巧：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：动态数组的区间GCD查询（如本题）；  
- **场景2**：动态数组的区间最小公倍数（LCM）查询（类似思路，但LCM不满足差分性质，需要其他技巧）；  
- **场景3**：动态序列的“线性组合可达性”问题（如判断能否用动态变化的数组合出某个值）。

### 洛谷推荐练习
1. **洛谷 P1886** - 滑动窗口  
   🗣️ **推荐理由**：静态区间GCD查询，帮你熟悉“GCD的区间合并”逻辑，是本题的基础。  
2. **洛谷 P3368** - 树状数组 2  
   🗣️ **推荐理由**：区间加、单点查，帮你理解“懒标记”的核心思想，是平衡树懒标记的基础。  
3. **洛谷 P4587** - 陌上花开  
   🗣️ **推荐理由**：二维偏序问题，用平衡树优化动态查询，帮你拓展“平衡树的应用场景”。  
4. **洛谷 P5057** - 简单题  
   🗣️ **推荐理由**：动态区间异或查询，类似区间GCD，帮你巩固“数据结构维护区间信息”的技巧。


## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自 A6n6d6y6)**：“我在写Treap的`split`函数时，一开始忘记在`pushdown`后更新`gcd`，导致查询结果错误。后来通过`cout`输出中间值，才发现是`gcd`没有正确合并——这让我意识到，`pushdown`和`pushup`是Treap的‘生命线’，必须在每次修改后调用。”  
> **点评**：这位作者的经验很典型！平衡树的`pushdown`和`pushup`函数容易被忽略，但它们是“正确维护子树信息”的关键。遇到错误时，**打印中间值**（比如`gcd`、`num`）是快速定位问题的好方法。


## 结语
本次分析的核心是“**数学转化+数据结构维护**”——用裴蜀定理把称量问题变成GCD问题，用差分和平衡树解决动态区间的维护。记住：**编程的本质是“翻译”**——把现实问题翻译成数学模型，再翻译成代码。下次遇到类似问题，试试先想“有没有数学定理能简化问题”，再想“用什么数据结构维护信息”！💪

--- 
下次我们再一起探索新的编程挑战！😊

---
处理用时：166.16秒
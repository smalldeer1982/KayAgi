# 题目信息

# 「CZOI-R2」天平

## 题目描述

你有 $n$ 个**砝码组**，编号为 $1$ 至 $n$。对于第 $i$ 个**砝码组**中的砝码有共同的正整数质量 $a_i$，每个**砝码组**中的**砝码**数量无限。

其中，有 $q$ 次操作：

- `I x v`：在第 $x$ 个**砝码组**后新增一组单个**砝码**质量为 $v$ 的**砝码组**，当 $x=0$ 时表示在最前面新增；
- `D x`：删除第 $x$ 个**砝码组**；
- `A l r v`：把从 $l$ 到 $r$ 的所有**砝码组**中的砝码质量加 $v$；
- `Q l r v`：判断能否用从 $l$ 到 $r$ 的**砝码组**中的砝码，称出质量 $v$。每个砝码组中的砝码可以使用任意个，也可以不用。

对于操作 `I` 和 `D`，操作后编号以及 $n$ 的值自动变化。

称一些**砝码**可以称出质量 $v$，当且仅当存在将这些砝码分别放在天平两边的摆放方法，使得将 $1$ 个质量为 $v$ 的物体摆放在某边可以让天平平衡。

## 说明/提示

**【样例解释】**

对于样例组 $1$，最后有 $5$ 个中的**砝码组**，质量分别为 $5,18,9,16,2$。在天平左边放上 $1$ 个**砝码组一**中的**砝码**，右边放上 $1$ 个**砝码组三**的砝码，即可称出质量 $4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/lwd6643t.png)

**【数据范围】**

**本题采用捆绑测试**。

记 $m_1$ 为所有时刻中 $a_i$ 与 $v$ 的最小值，$m_2$ 为所有时刻中 $a_i$ 与 $v$ 的最大值。

- Subtask #1（$5\text{ pts}$）：$1\le n,q\le 10$，$1\le m_1\le m_2 \le50$。
- Subtask #2（$15\text{ pts}$）：$1\le n,q\le 4\times10^2$。
- Subtask #3（$20\text{ pts}$）：没有操作 `I` 与操作 `D`。
- Subtask #4（$60\text{ pts}$）：无特殊性质。

对于 $100\%$ 的数据，$1\le n,q\le 10^5$，$1\le m_1\le m_2\le 10^{18}$，保证所有操作合法，且任意时刻至少存在一个砝码组。

## 样例 #1

### 输入

```
5 5
1 10 8 4 2
I 2 1
A 1 4 4
A 2 4 4
D 5
Q 1 4 4```

### 输出

```
YES```

## 样例 #2

### 输入

```
10 10
2 2 1 4 2 10 8 7 10 6
Q 5 6 1
Q 5 7 7
I 5 1
Q 4 5 3
Q 2 9 2
A 3 5 1
Q 7 8 5
D 7
A 3 9 7
Q 3 7 6```

### 输出

```
NO
NO
NO
YES
NO
YES```

# AI分析结果

# 💡 Kay的C++算法解析：「CZOI-R2」天平 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（动态序列的区间gcd维护 + 数学定理转化）

🗣️ **初步分析**：  
解决这道题的关键，是先把“能否用砝码称出v”的问题，通过**裴蜀定理**转化为“v是否是区间砝码质量的gcd的倍数”——这就像用不同面值的硬币凑钱：能凑出的钱数，一定是所有硬币面值gcd的倍数（比如硬币是2和4，gcd是2，能凑出2、4、6…但凑不出3）。  

题目中的操作（插入、删除、区间加、查询）要求我们**动态维护一个序列的区间gcd**。核心难点有两个：  
1. 动态序列的插入/删除：普通线段树无法高效处理，需要用平衡树（如无旋treap）；  
2. 区间加对gcd的影响：通过**差分技巧**化解——区间加v不会改变相邻元素的差，所以维护差分序列的gcd，就能间接得到原序列的gcd（原序列的gcd = 首元素与差分序列gcd的gcd）。  

**可视化设计思路**：  
我会用8位像素风展示平衡树的“分裂-合并”过程：用不同颜色的像素块代表平衡树节点，分裂时节点向左右滑动，合并时节点靠拢；区间加时，目标区间的节点会“闪烁”并伴随“嗡”的音效；计算gcd时，高亮参与运算的节点，完成时播放“叮”的提示音。还会设计“自动演示”模式，像“贪吃蛇AI”一样逐步执行插入/删除/查询操作，帮助大家直观理解动态维护的过程。


## 2. 精选优质题解参考

<eval_intro>
为了帮大家理清思路，我筛选了2份评分≥4星的优质题解——它们从数学转化到数据结构实现都讲解得很透彻，代码可读性也很高。
</eval_intro>

**题解一：(来源：A6n6d6y6)**  
* **点评**：这份题解从“暴力枚举”到“线段树”再到“平衡树”，分Subtask逐步推导，思路像“爬楼梯”一样清晰。它的亮点在于**差分技巧的应用**——通过维护差分序列的gcd，把区间加转化为点修改，完美解决了动态序列的gcd维护问题。代码中无旋treap的实现很规范，split/merge、pushup/pushdown等函数的逻辑严谨，非常适合学习平衡树的动态维护技巧。

**题解二：(来源：破壁人罗辑)**  
* **点评**：这道题解直接聚焦“平衡树维护动态序列”，代码更简洁。它用平衡树节点维护“当前值”和“子树差分gcd”，通过split/merge处理插入删除，区间加用懒标记实现。思路清晰，代码中的`check_gcd`函数直接对应题目查询需求，很容易理解“原序列gcd = 首元素与差分gcd的gcd”这一关键逻辑。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要是3个关键点，结合题解的技巧，我们逐一突破：
</difficulty_intro>

1.  **难点1：数学转化——从“称v”到“gcd的倍数”**  
    * **分析**：很多人会卡在“如何判断能否表出v”，但只要想到裴蜀定理（n个数的线性组合能表出的数，必是它们gcd的倍数），问题就转化为求区间gcd。  
    * 💡 **学习笔记**：遇到“线性组合能否表出某个数”的问题，先想裴蜀定理！

2.  **难点2：动态序列的区间gcd维护**  
    * **分析**：插入/删除操作会改变序列结构，普通线段树无法高效处理（线段树是静态的）。此时需要用**平衡树**（如无旋treap），通过“分裂-合并”操作动态调整序列。  
    * 💡 **学习笔记**：动态序列的区间查询/修改，优先考虑平衡树！

3.  **难点3：区间加对gcd的影响**  
    * **分析**：区间加v会改变原序列的元素，但**相邻元素的差不变**（比如a_i和a_{i+1}都加v，差还是a_{i+1}-a_i）。因此，我们可以维护差分序列的gcd，再结合原序列的首元素，就能得到原序列的gcd（原gcd = gcd(首元素, 差分序列gcd)）。  
    * 💡 **学习笔记**：区间加不改变差分——这个技巧能帮你“绕过”区间操作对gcd的影响！

### ✨ 解题技巧总结
- **技巧A：数学转化**：用裴蜀定理将实际问题转化为gcd问题，是解题的“钥匙”；  
- **技巧B：差分维护gcd**：区间加不改变差分，用差分序列的gcd间接维护原序列的gcd；  
- **技巧C：平衡树动态维护**：无旋treap的“分裂-合并”操作，完美解决动态序列的插入/删除问题。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**——它基于无旋treap，能处理所有操作，帮你建立整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了A6n6d6y6题解中Subtask4的无旋treap实现，聚焦“动态序列的区间gcd维护”，逻辑清晰且完整。
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    #define int long long
    #define GCD __gcd
    using namespace std;
    const int maxn=2e5+10;

    struct Treap{
        int rt,cnt,num[maxn],val[maxn],gcd[maxn],ls[maxn],rs[maxn],siz[maxn],plz[maxn],rnd[maxn];
        queue<int>del; mt19937 maker;
        Treap(){maker.seed(time(0));}

        int newnode(int x){
            int idx=del.empty()?++cnt:del.front(),del.pop();
            num[idx]=x; siz[idx]=1; ls[idx]=rs[idx]=plz[idx]=0; rnd[idx]=maker();
            return idx;
        }

        void pushdown(int x){
            if(ls[x]) num[ls[x]]+=plz[x], plz[ls[x]]+=plz[x];
            if(rs[x]) num[rs[x]]+=plz[x], plz[rs[x]]+=plz[x];
            plz[x]=0;
        }

        void pushup(int x){
            siz[x]=siz[ls[x]]+siz[rs[x]]+1;
            gcd[x]=GCD(GCD(gcd[ls[x]],gcd[rs[x]]),val[x]);
        }

        void split(int x,int k,int &rt1,int &rt2){
            if(!x){rt1=rt2=0; return;}
            pushdown(x);
            if(siz[ls[x]]<k) rt1=x, split(rs[x],k-siz[ls[x]]-1,rs[x],rt2);
            else rt2=x, split(ls[x],k,rt1,ls[x]);
            pushup(x);
        }

        int merge(int x,int y){
            if(!x||!y) return x+y;
            pushdown(x), pushdown(y);
            if(rnd[x]<rnd[y]){ls[y]=merge(x,ls[y]); pushup(y); return y;}
            else{rs[x]=merge(rs[x],y); pushup(x); return x;}
        }

        int getidx(int x){
            int rt1,rt2,rt3,ans;
            split(rt,x-1,rt1,rt2); split(rt2,1,rt2,rt3); ans=rt2;
            rt=merge(merge(rt1,rt2),rt3);
            return ans;
        }

        int getgcd(int l,int r){
            int rt1,rt2,rt3,ans;
            split(rt,l-1,rt1,rt2); split(rt2,r-l+1,rt2,rt3); ans=gcd[rt2];
            rt=merge(merge(rt1,rt2),rt3);
            return ans;
        }

        void insert(int x,int v){
            int rt1,rt2,rt3,node=newnode(v);
            val[node]=GCD(val[node],v-num[getidx(x)]);
            split(rt,x,rt1,rt3); split(rt3,1,rt2,rt3);
            if(rt2) val[rt2]=GCD(val[rt2],num[rt2]-v);
            rt=merge(merge(rt1,node),merge(rt2,rt3));
        }

        void remove(int x){
            int rt1,rt2,rt3,tmp=num[getidx(x-1)];
            split(rt,x,rt1,rt2); split(rt2,1,rt2,rt3); val[rt2]=GCD(val[rt2],num[rt2]-tmp);
            rt=merge(merge(rt1,rt2),rt3);
            split(rt,x-1,rt1,rt2); split(rt2,1,rt2,rt3); del.push(rt2);
            rt=merge(rt1,rt3);
        }

        void update(int l,int r,int x){
            int rt1,rt2,rt3;
            split(rt,l-1,rt1,rt2); split(rt2,r-l+1,rt2,rt3);
            num[rt2]+=x; plz[rt2]+=x; rt=merge(merge(rt1,rt2),rt3);
            split(rt,l-1,rt1,rt2); split(rt2,1,rt2,rt3);
            val[rt2]+=x; gcd[rt2]+=x; rt=merge(merge(rt1,rt2),rt3);
            split(rt,r,rt1,rt2); split(rt2,1,rt2,rt3);
            if(rt2) val[rt2]-=x; gcd[rt2]-=x; rt=merge(merge(rt1,rt2),rt3);
        }

        int query(int l,int r){
            return GCD(num[getidx(l)],getgcd(l+1,r));
        }
    }t;

    signed main(){
        ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
        int n,q; cin>>n>>q;
        for(int i=1;i<=n;i++){int a; cin>>a; t.insert(i-1,a);}
        while(q--){
            char op; cin>>op;
            if(op=='I'){int x,v; cin>>x>>v; t.insert(x,v);}
            if(op=='D'){int x; cin>>x; t.remove(x);}
            if(op=='A'){int l,r,v; cin>>l>>r>>v; t.update(l,r,v);}
            if(op=='Q'){int l,r,v; cin>>l>>r>>v; cout<<(v%t.query(l,r)?"NO\n":"YES\n");}
        }
        return 0;
    }
    ```
* **代码解读概要**：  
    代码用`Treap`结构体封装了无旋treap的核心操作：`newnode`创建节点，`pushdown`处理懒标记，`pushup`维护节点大小和gcd，`split`/`merge`实现动态序列的分裂与合并。`insert`/`remove`处理插入删除，`update`处理区间加，`query`计算区间gcd——最终判断v是否是区间gcd的倍数。


<code_intro_selected>
接下来，我们剖析题解中的“核心片段”，看看它们是如何实现关键逻辑的。
</code_intro_selected>

**题解一：(来源：A6n6d6y6)**  
* **亮点**：用“差分+线段树”解决静态序列的区间gcd维护，是平衡树的“基础版”，适合理解差分技巧。
* **核心代码片段**：
    ```cpp
    struct tree{int sum,gcd;}t[maxn<<2];
    void pushup(int p){
        t[p]={t[ls(p)].sum+t[rs(p)].sum, GCD(t[ls(p)].gcd,t[rs(p)].gcd)};
    }
    void build(int l,int r,int p){
        if(l==r){t[p]={a[l]-a[l-1], a[l]-a[l-1]}; return;}
        int mid=(l+r)>>1;
        build(l,mid,ls(p)); build(mid+1,r,rs(p)); pushup(p);
    }
    int query(int l,int r){
        int g=GCD(qgcd(1,n,l+1,r,1), qsum(1,n,1,l,1));
        return g;
    }
    ```
* **代码解读**：  
    这段代码是Subtask3的线段树实现——`build`函数构建差分序列（`a[l]-a[l-1]`），`pushup`维护差分的gcd。`query`函数计算原序列的gcd：原序列的gcd = 首元素（`qsum(1,l)`，因为差分的前缀和是原序列的值）与差分序列gcd（`qgcd(l+1,r)`）的gcd。是不是很巧妙？  
* 💡 **学习笔记**：静态序列的区间gcd维护，用“差分+线段树”就够了！

**题解二：(来源：破壁人罗辑)**  
* **亮点**：用平衡树直接维护原序列和差分gcd，代码更简洁，适合理解动态维护。
* **核心代码片段**：
    ```cpp
    void update_gcd(int n){
        nd[n].gcd = gcd(
            nd[n].ls ? gcd(nd[nd[n].ls].gcd, abs(nd[nd[n].ls].val - nd[n].val)) : 0,
            nd[n].rs ? gcd(nd[nd[n].rs].gcd, abs(nd[nd[n].rs].val - nd[n].val)) : 0
        );
    }
    long long check_gcd(int Lsiz,int Rsiz){
        int L,M,R;
        split(root,Rsiz,M,R); split(M,Lsiz-1,L,M);
        long long ret = gcd(nd[M].gcd, nd[M].val + nd[M].tag);
        root=merge(L,merge(M,R));
        return ret;
    }
    ```
* **代码解读**：  
    `update_gcd`函数维护平衡树节点的gcd——它计算左子树gcd、右子树gcd，以及当前节点与左右子节点的差的gcd（因为差分就是相邻元素的差）。`check_gcd`函数查询区间gcd：先分裂出目标区间`M`，然后计算`M`的gcd（`nd[M].gcd`）与`M`首元素（`nd[M].val + nd[M].tag`，因为有懒标记）的gcd——这就是原序列的区间gcd！  
* 💡 **学习笔记**：动态序列的gcd维护，平衡树节点要同时存“当前值”和“子树差分gcd”！


## 5. 算法可视化：像素动画演示

<visualization_intro>
我设计了一个叫“像素天平守护者”的动画——用8位像素风展示平衡树的动态维护过程，结合游戏化元素帮你记住关键操作！
</visualization_intro>

### **动画主题**：像素天平守护者
**核心演示内容**：展示“插入砝码组→区间加→查询能否称出v”的完整流程，用平衡树的“分裂-合并”模拟动态序列的变化，用gcd计算判断结果。

### **设计思路**
用FC红白机的8位风格，让平衡树节点像“积木”一样拼接，操作像“玩游戏”一样有趣：  
- 插入/删除时，节点会“滑入/滑出”平衡树，伴随“叮”的音效；  
- 区间加时，目标区间的节点会“闪烁”并播放“嗡”的音效；  
- 计算gcd时，参与运算的节点会“高亮”，完成时播放“叮”的提示音；  
- 成功查询时，屏幕会弹出“YES”的像素字，伴随“胜利”音效；失败则弹出“NO”，播放“提示”音效。

### **动画帧步骤与交互**
1. **初始化场景**：  
   - 屏幕左侧是“平衡树区域”，用不同颜色的像素块代表节点（红色=当前操作节点，蓝色=已处理节点）；  
   - 右侧是“控制面板”：有“开始/暂停”“单步”“重置”按钮，以及“速度滑块”（从“慢”到“快”）；  
   - 背景播放8位风格的《超级玛丽》BGM，营造复古氛围。

2. **插入操作演示**：  
   - 输入“`I 2 1`”（在第2个砝码组后插入质量1的组），平衡树会“分裂”出第2个位置，新节点（绿色）从右侧滑入，合并回平衡树，伴随“叮”的音效。

3. **区间加操作演示**：  
   - 输入“`A 1 4 4`”（给1-4组加4），目标区间的节点会“闪烁”黄色，懒标记生效，节点值更新，伴随“嗡”的音效。

4. **查询操作演示**：  
   - 输入“`Q 1 4 4`”（查询能否称出4），平衡树分裂出1-4区间，计算区间gcd（假设是1），判断4是1的倍数，屏幕弹出“YES”，播放“胜利”音效。

### **交互与游戏化元素**
- **单步/自动播放**：可以手动点击“单步”看每一步，也可以选“自动播放”让动画像“AI玩游戏”一样运行；  
- **速度调节**：用滑块调整动画速度，从“慢（1帧/秒）”到“快（10帧/秒）”；  
- **积分系统**：完成1次插入/删除得10分，完成1次查询得20分，积满100分解锁“隐藏BGM”（《塞尔达传说》的8位版）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“动态区间gcd维护”，你可以解决很多类似问题——比如“动态序列的区间统计”“数学转化类问题”。
</similar_problems_intro>

### **通用思路迁移**
- **问题1**：动态序列的区间gcd查询（如本题）；  
- **问题2**：静态序列的滑动窗口gcd（用单调队列）；  
- **问题3**：动态序列的区间最小公倍数（LCM）维护（类似gcd，但LCM的区间操作更复杂）。

### **洛谷练习推荐**
1. **洛谷 P4145 上帝造题的七分钟2**  
   * 🗣️ **推荐理由**：这道题要处理“区间加”“区间乘”“区间gcd查询”，是本题的“进阶版”，能帮你巩固“懒标记+平衡树”的技巧。  
2. **洛谷 P2023 维护序列**  
   * 🗣️ **推荐理由**：要处理“区间加”“区间乘”“区间求和”，虽然不是gcd，但平衡树的实现逻辑和本题类似，适合练手。  
3. **洛谷 P1886 滑动窗口**  
   * 🗣️ **推荐理由**：静态序列的滑动窗口gcd查询，用单调队列实现，是本题的“基础版”，适合理解gcd的区间性质。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中提到的“差分技巧”和“平衡树实现细节”，是非常宝贵的经验——我帮大家整理出来：
</insights_intro>

> **参考经验 (来自 A6n6d6y6)**：“区间加不改变差分，所以维护差分的gcd就能得到原序列的gcd——这个技巧是我看《算法竞赛进阶指南》学到的，帮我解决了动态gcd的问题。”  
> **点评**：差分是处理“区间加”的“神器”！不管是静态还是动态序列，只要区间加不改变差分，就能用这个技巧——比如本题的gcd维护，或者求和问题中的“前缀和”。


<conclusion>
本次关于“「CZOI-R2」天平”的分析就到这里！记住：**数学转化是解题的“钥匙”，数据结构是解题的“工具”**——先想清楚“问题是什么”，再选“合适的工具”解决它。下次我们再一起挑战更难的动态序列问题！💪
</conclusion>

---
处理用时：127.99秒
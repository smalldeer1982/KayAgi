# 题目信息

# 【模板】普通平衡树

## 题目描述

您需要动态地维护一个可重集合 $M$，并且提供以下操作：

1. 向 $M$ 中插入一个数 $x$。
2. 从 $M$ 中删除一个数 $x$（若有多个相同的数，应只删除一个）。
3. 查询 $M$ 中有多少个数比 $x$ 小，并且将得到的答案加一。
4. 查询如果将 $M$ 从小到大排列后，排名位于第 $x$ 位的数。
5. 查询 $M$ 中 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。
6. 查询 $M$ 中 $x$ 的后继（后继定义为大于 $x$，且最小的数）。

对于操作 3,5,6，**不保证**当前可重集中存在数 $x$。
 

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10^5$，$|x| \le 10^7$

来源：Tyvj1728 原名：普通平衡树

在此鸣谢


## 样例 #1

### 输入

```
10
1 106465
4 1
1 317721
1 460929
1 644985
1 84185
1 89851
6 81968
1 492737
5 493598```

### 输出

```
106465
84185
492737```

# AI分析结果


### 💡 Kay的C++算法解析：普通平衡树 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`平衡树/动态数据结构应用`  
🗣️ **初步分析**：
> 解决"普通平衡树"需动态维护有序集合，核心在于高效处理插入、删除及查询操作。各类平衡树本质是"智能二叉搜索树"，通过特定规则（如随机优先级、旋转调整）保持树高接近对数级，确保操作高效。  
> - **多解法对比**：Treap依赖随机性；Splay通过旋转将热点移至根部；FHQ Treap无旋转，靠分裂合并；WBLT/Leafy Tree用子树大小维护平衡；非树结构如权值树状数组+树状数组二分实现倍增查询。  
> - **可视化设计**：动画将展示树结构调整（如旋转时节点位置变化、分裂合并时子树重组），高亮当前操作节点路径，用颜色区分不同子树。复古像素风格呈现树形结构，单步执行模式辅以8-bit音效增强理解。

---

#### 2. 精选优质题解参考
**题解一：FHQ Treap (非旋转平衡树)**  
* **来源**：皎月半洒花  
* **点评**：  
  思路清晰——核心操作`split`(按值分裂树)和`merge`(合并子树)逻辑直白。代码规范——递归实现简洁，变量名`val/key/size`含义明确。算法高效——平均$O(\log n)$复杂度，支持可持久化。实践价值高——60行完整实现6种操作，删除时巧妙避免父子指针维护。

**题解二：WBLT (加权平衡Leafy Tree)**  
* **来源**：StayAlone  
* **点评**：  
  结构独特——信息仅存叶子，非叶节点为索引。代码规范——类线段树的`pushup/maintain`维护子树大小。算法高效——加权平衡因子$\alpha=0.29$保证树高，无旋转操作。常数优势——实测效率优于FHQ Treap，特别适合查询密集型场景。

**题解三：树状数组 (非平衡树解法)**  
* **来源**：wjyppm1403  
* **点评**：  
  思路新颖——权值树状数组+树状数组二分实现排名查询。代码精简——30行核心代码，`lowbit`位运算高效。空间优化——$O(n)$空间碾压平衡树。实践巧妙——离散化处理大值域，倍增查询第$k$小时模仿线段树二分。

---

#### 3. 核心难点辨析与解题策略
1. **难点：动态维护有序性**  
   * **分析**：插入删除破坏二叉搜索树平衡性，退化成链时操作效率$O(n)$  
   * **解决方案**：  
     - *旋转类*：Splay通过`zig/zag`旋转热点至根；AVL/Treap用随机优先级降低退化概率  
     - *非旋转类*：FHQ Treap分裂后重组；WBLT按子树权值比调整结构  
     💡 **学习笔记**：旋转操作保序但难调试；分裂合并更易写但常数大

2. **难点：前驱/后继高效查询**  
   * **分析**：需定位相邻节点，朴素实现需$O(n)$遍历  
   * **解决方案**：  
     - *平衡树*：Splay直接定位相邻节点；FHQ Treap转化为`kth(rank(x)-1)`  
     - *非树结构*：树状数组二分求值域相邻点  
     💡 **学习笔记**：前驱后继可转化为排名问题统一处理

3. **难点：大值域处理**  
   * **分析**：$|x| \leq 10^7$，直接开数组不现实  
   * **解决方案**：  
     - 离散化三件套：`sort/unique/lower_bound`映射值域  
     - Trie树高位到低位处理（如Imerance1018解法）  
     💡 **学习笔记**：动态结构（Treap）免离散化；静态结构（树状数组）必须映射

✨ **解题技巧总结**：  
- **惰性删除**：节点计数减为0暂不物理删除，减少结构调整  
- **冗余节点**：插入正负极大值避免边界判断  
- **树状数组倍增**：`1<<i`跳跃逼近目标排名，替代二分优化常数

---

#### 4. C++核心代码实现赏析
**本题通用核心实现参考**  
* **说明**：综合FHQ Treap分裂合并思想，删减调试代码后的简洁版本  
* **完整代码**：
```cpp
struct Node { int l, r, val, key, siz; } t[N];
int tot, root;

void pushup(int x) { t[x].siz = t[t[x].l].siz + t[t[x].r].siz + 1; }

void split(int now, int k, int &x, int &y) {
    if (!now) { x = y = 0; return; }
    if (t[now].val <= k) x = now, split(t[now].r, k, t[now].r, y);
    else y = now, split(t[now].l, k, x, t[now].l);
    pushup(now);
}

int merge(int x, int y) {
    if (!x || !y) return x | y;
    if (t[x].key < t[y].key) {
        t[x].r = merge(t[x].r, y); pushup(x); return x;
    } else {
        t[y].l = merge(x, t[y].l); pushup(y); return y;
    }
}

void insert(int k) {
    int x, y; split(root, k, x, y);
    t[++tot] = {0, 0, k, rand(), 1};
    root = merge(merge(x, tot), y);
}
```

**FHQ Treap片段赏析**  
* **亮点**：无旋转操作逻辑清晰  
* **核心代码**：
  ```cpp
  void del(int k) {
      int x, y, z;
      split(root, k, x, z); split(x, k-1, x, y);
      if(y) y = merge(t[y].l, t[y].r); // 直接合并左右子树
      root = merge(merge(x, y), z);
  }
  ```
* **解读**：三次分裂定位目标节点，`merge(t[y].l, t[y].r)`跳过待删节点实现删除

**WBLT片段赏析**  
* **亮点**：子树权重维护平衡  
* **核心代码**：
  ```cpp
  void maintain(int x) {
      if (siz[lc] > siz[x] * 0.75)       // 左子树过重
          rotate(x, RIGHT);               // 右旋调整
      else if (siz[rc] > siz[x] * 0.75)   // 右子树过重
          rotate(x, LEFT);                // 左旋调整
  }
  ```
* **学习笔记**：固定权重比避免退化，类似替罪羊树重构思想

---

#### 5. 算法可视化：像素动画演示
* **主题**："平衡树大冒险" 像素RPG  
* **核心演示**：  
  - **插入**：新节点（蓝色像素块）沿树下落，触发旋转时显示红色箭头，伴随"咔嚓"音效  
  - **删除**：目标节点闪烁变灰，子树重组时显示绿色连接线  
  - **查询**：查询路径高亮黄色，排名查询时显示当前子树大小统计  
* **交互控制**：  
  ```mermaid
  graph LR
    A[开始] --> B{操作选择}
    B -->|插入| C[新值输入]
    B -->|删除| D[目标值选择]
    C --> E[动画：节点下落+结构调整]
    D --> F[动画：节点消失+子树合并]
  ```
* **游戏化设计**：  
  每完成10次操作解锁新关卡，BOSS战为1e5规模压力测试，通关奖励树高优化报告

---

#### 6. 拓展练习与相似问题
* **技巧迁移**：  
  1. 区间翻转 → 文艺平衡树（Splay/FHQ维护序列）  
  2. 动态逆序对 → 树状数组套平衡树  
  3. 第k大带修改 → 树状数组二分+离散化  
* **洛谷推荐**：  
  1. [P3391] 文艺平衡树：掌握区间操作  
  2. [P3380] 二逼平衡树：训练树套树思维  
  3. [P6136] 加强版模板：测试算法常数优化

---

#### 7. 学习心得与经验分享
> **来自 FHQ Treap 作者**："分裂合并时注意空树边界，`merge(x,y)`前先判`x||y`"  
> **Kay点评**：边界处理是平衡树调试核心，建议：
> 1. 初始插入两个哨兵节点（-∞, +∞）  
> 2. 每次操作后验证树高与理论值偏差  
> 3. 小数据画图辅助调试旋转逻辑

---

### 结语
通过多解法对比，**FHQ Treap**在代码简洁性与功能完备性上表现最佳，**树状数组**在无区间操作需求时空间占优，**WBLT**则适合追求极致效率的场景。理解不同平衡树的核心思想后，可依据问题特征灵活选用！

---
处理用时：186.90秒
# 题目信息

# 「WWOI R1」WSM 游戏

## 题目背景

[$\texttt{WSM}$](https://gitblock.cn/Projects/769996) 是一款冒险游戏，WSM 是这个游戏的主角。

## 题目描述

有一个由 $n$ 行 $m$ 列格子构成的地图。WSM 要从地图的左上角坐标为 $(1,1)$ 的格子出发，到达坐标为 $(a,b)$ 的格子。 

地图上有 $k$ 个带有密码的锁和 $t$ 个带有密码的钥匙。  
当 WSM 到达密码为 $r$ 的钥匙所在的格子，密码为 $r$ 的锁就会立刻消失。     
任何一个时刻，WSM 都必须在地图内，且所处的格子必须**没有锁**。  
如果某个格子中既有密码为 $r$ 的锁又有密码为 $r$ 的钥匙，那么 WSM 可以进入到这个格子。  

地图上还存在着 $p$ 个普通道具和 $q$ 个魔法物品。WSM 可以消耗步数来使用地图上的普通道具和魔法物品。所有的道具和魔法物品均可重复使用。  

---

道具很原始，WSM 只能使用和自己在同一格的道具。  
假设 WSM 当前位置为 $(x,y)$，使用道具后移动到 $(x',y')$。  
|道具编号|移动后位置|
|:-:|:-:|
$1$|WSM 向上走一格，即 $(x',y')=(x-1,y)$|
$2$|WSM 向下走一格，即 $(x',y')=(x+1,y)$|
$3$|WSM 向左走一格，即 $(x',y')=(x,y-1)$|
$4$|WSM 向右走一格，即 $(x',y')=(x,y+1)$|

---

魔法物品很脆弱，当 WSM 和某一个魔法物品处在同一格时，这个魔法物品会**永久消失**。   
魔法物品很强大，WSM 可以使用地图上任意一个魔法物品。  
假设 WSM 当前位置为 $(x,y)$，魔法物品的位置为 $(x_0,y_0)$，使用魔法物品后移动到 $(x',y')$。  
|魔法物品编号|移动后位置|
|:-:|:-:|
$1$|$\frac{x+x'}{2}=x_0$，$\frac{y+y'}{2}=y_0$|
$2$|$x'=x$，$\frac{y+y'}{2}=y_0$|
$3$|$\frac{x+x'}{2}=x_0$，$y'=y$|


WSM 每一步可以使用一个道具或一个魔法物品。请问至少需要多少步才能从坐标为 $(1,1)$ 的格子到达坐标为 $(a,b)$ 的格子？

## 说明/提示

### 【样例 $1$ 解释】
  
花费最小步数的路线为：

$\def\f#1{\xrightarrow{\bf 道具#1}} (1,1) \f{2} (2,1) \f{4} (2,2)$。


### 【数据范围】

**本题采用捆绑测试。**

请注意：任意一个格子内可能**同时存在**多个锁、钥匙、道具和魔法道具。

对于所有测试数据，保证：
* $1\le n,m\le400$，$1\le a\le n$，$1\le b\le m$。
* $1\le k \le 10^3$，$0\le t\le 3$，$1\le p\le 5\times 10^5$，$0\le q\le 3$。
* 对于所有的锁、钥匙、道具、魔法物品，均有 $1\le x\le n$，$1\le y\le m$。
* 对于所有的锁，均有 $1\le r\le 10^9$。
* 对于所有的钥匙，均有 $1\le r\le 10^9$。
* 对于所有的道具，均有 $id\in\{1,2,3,4\}$。
* 对于所有的魔法物品，均有 $id\in\{1,2,3\}$。

| 子任务编号 |$n,m\le$|$k\le$|$t\le$|$p\le$|$q\le$|分数|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$1$|$2$|$0$|$0$|$13$|$0$|$10$|
|$2$|$10$|^|^|$300$|$3$|$10$|
|$3$|^|$100$|$3$|^|^|$20$|
|$4$|$400$|$0$|$0$|$5\times10^5$|$0$|$10$|
|$5$|^|$3$|$3$|^|$3$|$25$|
|$6$|^|$10^3$|^|^|^|$25$|

## 样例 #1

### 输入

```
2 2 2 2
0 0 8 0
1 2 4
1 1 2
2 2 1
1 1 4
2 2 4
2 1 4
1 2 3
2 1 1```

### 输出

```
2```

# AI分析结果

# 💡 Kay的C++算法解析：「WWOI R1」WSM游戏 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：BFS（广度优先搜索）结合状态压缩的分层图最短路  

🗣️ **初步分析**：  
解决这道题，就像在“分层的迷宫”里探险——每个“层”对应不同的**钥匙获取状态**和**魔法物品破坏状态**。比如，你拿到钥匙A后，就能进入之前被锁A挡住的格子；踩碎魔法物品B后，就不能再用它的能力了。这些状态会改变你能走的路径，所以我们需要把每个状态当作一个独立的“层”，用BFS在每层内找最短路径，层间通过获取钥匙或破坏魔法物品转移。  

**核心思路**：用`dis[x][y][state]`记录到达`(x,y)`时，状态为`state`的最短步数。其中`state`是一个二进制数：低3位表示**钥匙是否获取**（因为t≤3），高3位表示**魔法物品是否被破坏**（因为q≤3）。比如`state=5`（二进制`101`）表示拿到第0、2把钥匙，没破坏任何魔法物品。  

**核心难点**：  
1. 如何处理`r≤1e9`的钥匙和锁？——离散化（把大r映射成小索引）；  
2. 如何合并钥匙和魔法物品的状态？——状态压缩（用一个整数存两个状态）；  
3. 如何处理魔法物品的“踩碎后消失”？——状态中标记魔法物品是否被破坏，破坏后不能再用。  

**可视化设计思路**：  
我们会做一个**像素迷宫探险游戏**：  
- 用8位像素块表示格子（绿色是空地，红色是锁，蓝色是钥匙，紫色是魔法物品）；  
- 每个状态对应一个“层”，用不同透明度的背景区分；  
- 单步执行时，高亮当前处理的格子和状态（比如拿到钥匙时，钥匙像素块变亮，伴随“叮”的音效；踩碎魔法物品时，魔法物品像素块消失，伴随“啪”的音效）；  
- 自动播放时，像“贪吃蛇AI”一样逐步探索，完成后播放胜利音效。  


## 2. 精选优质题解参考

### 题解一：来源（出题人WsW_）  
* **点评**：这份题解是“标准答案级”的思路！它清晰地把问题转化为**分层图BFS**——用状态压缩记录钥匙和魔法物品的状态，用`dis[x][y][state]`存最短步数。代码里的`gto`函数巧妙处理了状态转移（比如获取钥匙、破坏魔法物品），还通过离散化解决了大`r`的问题。最值得学习的是**锁的预处理**：把没有对应钥匙的锁直接标记为不可达，避免无效搜索，大大优化了效率。  


### 题解二：来源（tzhengqing）  
* **点评**：这是一份“踩过坑的经验级”题解！作者在场上踩了很多细节坑（比如重复物品的处理、离散化的遗漏），所以题解里专门写了“警示后人”的部分——这对新手太有用了！它的`dis[key][obj][x][y]`数组直接把钥匙和魔法物品的状态分开存，思路更直观；代码里对“不可行锁”的标记（`id=4`）也很巧妙。最棒的是，它提醒我们**状态转移时要先检查锁是否打开**，避免“穿墙”错误。  


## 3. 核心难点辨析与解题策略

### 关键点1：如何设计状态压缩？  
* **难点**：钥匙（t≤3）和魔法物品（q≤3）的状态要合并成一个整数，否则数组会太大。  
* **解法**：用二进制位分配——比如低3位存钥匙（`key_state`），高3位存魔法物品（`obj_state`），总状态数是`2^(3+3)=64`。例如：  
  - 拿到第0把钥匙：`key_state=1`（二进制`001`）；  
  - 破坏第1个魔法物品：`obj_state=2`（二进制`010`）；  
  - 合并后状态：`1 | (2<<3) = 9`（二进制`1001`）。  

### 关键点2：如何处理大r的钥匙和锁？  
* **难点**：`r≤1e9`，不能直接用`r`当数组索引。  
* **解法**：离散化——把所有出现的钥匙`r`收集起来，排序去重，映射成0、1、2的小索引。比如钥匙`r=123`→索引0，`r=456`→索引1，这样就能用位运算处理了。  

### 关键点3：如何处理魔法物品的“踩碎后消失”？  
* **难点**：魔法物品被踩碎后，不能再用它的能力，这会改变后续的转移方式。  
* **解法**：在状态中标记魔法物品是否被破坏。比如第`i`个魔法物品被踩碎，就把`state`的第`3+i`位设为1。转移时，如果该位是1，就跳过使用这个魔法物品的转移。  


### ✨ 解题技巧总结  
- **状态压缩**：当物品数量≤10时，优先用二进制位存状态（比如`t+q≤6`时，`2^6=64`完全没问题）；  
- **离散化**：遇到大数值的标签（比如`r≤1e9`），先收集所有出现的值，映射成小索引；  
- **分层图BFS**：当路径受“状态”影响时，把状态当作“层”，每层内BFS找最短路径，层间通过状态变化转移。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合两个优质题解的思路，提炼出最清晰的核心框架，包含状态压缩、离散化、BFS转移。  

* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <cstring>
using namespace std;

typedef pair<int, int> pii;
const int INF = 0x3f3f3f3f;
const int MAXN = 405, MAXM = 405, MAXSTATE = 64; // 2^(3+3)=64

int n, m, a, b;
int k, t, p, q;
vector<pii> edges[MAXN][MAXM]; // 普通道具的转移（x,y）→ (nx,ny)
vector<pii> magics;            // 魔法物品的位置（x,y）和类型id
vector<int> key_r;             // 离散化后的钥匙r值
int key_bit[MAXN][MAXM];       // (x,y)的钥匙对应的位掩码
int lock_bit[MAXN][MAXM];      // (x,y)的锁对应的位掩码
int dis[MAXN][MAXM][MAXSTATE]; // 状态压缩的最短路

// 离散化：找r对应的索引（-1表示无对应钥匙）
int get_key_idx(int r) {
    auto it = lower_bound(key_r.begin(), key_r.end(), r);
    if (it != key_r.end() && *it == r) return it - key_r.begin();
    return -1;
}

// 处理状态转移
void transfer(int x, int y, int state, queue<tuple<int, int, int>>& q) {
    // 1. 处理普通道具转移
    for (auto& [nx, ny] : edges[x][y]) {
        if (nx < 1 || nx > n || ny < 1 || ny > m) continue;
        // 检查锁：lock_bit[nx][ny]的每一位是否都被state的钥匙位覆盖
        if ((lock_bit[nx][ny] & (~(state & 0b111))) != 0) continue;
        int new_state = state | key_bit[nx][ny]; // 获取新钥匙
        // 检查魔法物品：如果(nx,ny)有魔法物品，标记为已破坏
        for (int i = 0; i < magics.size(); i++) {
            auto [mx, my] = magics[i];
            if (mx == nx && my == ny) new_state |= (1 << (3 + i));
        }
        if (dis[nx][ny][new_state] > dis[x][y][state] + 1) {
            dis[nx][ny][new_state] = dis[x][y][state] + 1;
            q.emplace(nx, ny, new_state);
        }
    }
    // 2. 处理魔法物品转移
    for (int i = 0; i < magics.size(); i++) {
        if (state & (1 << (3 + i))) continue; // 已破坏，跳过
        auto [mx, my] = magics[i];
        int id = magics[i].second; // 假设magics存的是（x,y,id）
        int nx = x, ny = y;
        if (id == 1 || id == 2) ny = 2 * my - y; // 水平对称
        if (id == 1 || id == 3) nx = 2 * mx - x; // 垂直对称
        if (nx < 1 || nx > n || ny < 1 || ny > m) continue;
        if ((lock_bit[nx][ny] & (~(state & 0b111))) != 0) continue;
        int new_state = state | key_bit[nx][ny];
        new_state |= (1 << (3 + i)); // 标记魔法物品已破坏
        if (dis[nx][ny][new_state] > dis[x][y][state] + 1) {
            dis[nx][ny][new_state] = dis[x][y][state] + 1;
            q.emplace(nx, ny, new_state);
        }
    }
}

void bfs() {
    memset(dis, 0x3f, sizeof(dis));
    queue<tuple<int, int, int>> q;
    int init_state = key_bit[1][1]; // 初始位置的钥匙
    // 处理初始位置的魔法物品
    for (int i = 0; i < magics.size(); i++) {
        auto [mx, my] = magics[i];
        if (mx == 1 && my == 1) init_state |= (1 << (3 + i));
    }
    dis[1][1][init_state] = 0;
    q.emplace(1, 1, init_state);
    
    while (!q.empty()) {
        auto [x, y, state] = q.front(); q.pop();
        if (x == a && y == b) continue; // 找到终点，继续处理其他状态
        transfer(x, y, state, q);
    }
}

int main() {
    cin >> n >> m >> a >> b;
    cin >> k >> t >> p >> q;
    
    // 读锁和钥匙
    vector<int> all_r;
    vector<tuple<int, int, int>> locks, keys;
    for (int i = 0; i < k; i++) {
        int x, y, r; cin >> x >> y >> r;
        locks.emplace_back(x, y, r);
        all_r.push_back(r);
    }
    for (int i = 0; i < t; i++) {
        int x, y, r; cin >> x >> y >> r;
        keys.emplace_back(x, y, r);
        all_r.push_back(r);
    }
    
    // 离散化钥匙r值
    sort(all_r.begin(), all_r.end());
    all_r.erase(unique(all_r.begin(), all_r.end()), all_r.end());
    key_r = all_r;
    
    // 处理锁：lock_bit[x][y] = 所有锁的位掩码（无对应钥匙的锁标记为不可达）
    for (auto& [x, y, r] : locks) {
        int idx = get_key_idx(r);
        if (idx == -1) lock_bit[x][y] = INF; // 不可达
        else lock_bit[x][y] |= (1 << idx);
    }
    
    // 处理钥匙：key_bit[x][y] = 所有钥匙的位掩码
    for (auto& [x, y, r] : keys) {
        int idx = get_key_idx(r);
        if (idx != -1) key_bit[x][y] |= (1 << idx);
    }
    
    // 读普通道具
    for (int i = 0; i < p; i++) {
        int x, y, id; cin >> x >> y >> id;
        int nx = x, ny = y;
        if (id == 1) nx--; else if (id == 2) nx++;
        else if (id == 3) ny--; else if (id == 4) ny++;
        edges[x][y].emplace_back(nx, ny);
    }
    
    // 读魔法物品
    for (int i = 0; i < q; i++) {
        int x, y, id; cin >> x >> y >> id;
        magics.emplace_back(x, y, id);
    }
    
    bfs();
    
    // 找所有状态中的最小值
    int ans = INF;
    for (int s = 0; s < MAXSTATE; s++) {
        ans = min(ans, dis[a][b][s]);
    }
    cout << (ans == INF ? -1 : ans) << endl;
    return 0;
}
```

* **代码解读概要**：  
这份代码的核心是**状态压缩的BFS**：  
1. **离散化**：把钥匙的大`r`值映射成小索引，避免数组过大；  
2. **预处理**：把锁和钥匙转换成位掩码（比如锁`r=123`对应索引0，那么`lock_bit[x][y]`的第0位为1）；  
3. **BFS初始化**：从`(1,1)`出发，初始状态包含初始位置的钥匙和魔法物品；  
4. **状态转移**：处理普通道具（四方向移动）和魔法物品（对称移动），更新状态和最短步数；  
5. **结果查询**：遍历所有状态，找`(a,b)`的最小步数。  


### 题解一核心片段赏析（来源：出题人WsW_）  
* **亮点**：用`gto`函数封装状态转移，代码更模块化。  
* **核心代码片段**：  
```cpp
void gto(int x, int y, int tox, int toy, int stt) {
    if(check(tox,toy))return;
    int tost=stt;
    // 获取钥匙
    for(ui i=0;i<key.size();i++){
        if(key[i].x==tox&&key[i].y==toy)tost|=1<<key[i].r;
    }
    // 检查锁
    for(auto i:lckr[tox][toy]) if((tost&(1<<i))==0)return;
    // 破坏魔法物品
    for(ui i=0;i<mag.size();i++)
        if(mag[i].x==tox&&mag[i].y==toy)tost|=(1<<(i+3));
    if(dis[tox][toy][tost]<=dis[x][y][stt]+1)return;
    dis[tox][toy][tost]=dis[x][y][stt]+1;
    que.push({tox,toy,tost});
}
```  
* **代码解读**：  
这段代码是**状态转移的核心**！它做了四件事：  
1. 检查目标格子是否合法（`check`函数）；  
2. 处理目标格子的钥匙：如果有钥匙，把`tost`对应的位设为1；  
3. 检查目标格子的锁：如果锁的位没有被`tost`覆盖，说明没钥匙，不能进入；  
4. 处理目标格子的魔法物品：如果有魔法物品，把`tost`的高3位对应的位置为1（标记已破坏）；  
5. 更新最短步数，加入队列。  

* **学习笔记**：封装状态转移能让代码更清晰，避免重复代码——这是写复杂BFS的关键技巧！  


### 题解二核心片段赏析（来源：tzhengqing）  
* **亮点**：用`dis[key][obj][x][y]`直接分开存钥匙和魔法物品状态，思路更直观。  
* **核心代码片段**：  
```cpp
int dis[16][8][405][405]; // key≤15（t≤3→2^3=8？这里作者可能用了更大的范围），obj≤7（q≤3→2^3=8）
void bfs(){
    for(int i=0;i<16;i++)for(int j=0;j<8;j++)for(int k=0;k<=n;k++)for(int l=0;l<=m;l++)
        dis[i][j][k][l]=inf;
    dis[key[1][1]][a2[1][1]][1][1]=0;
    queue<node>q1;q1.push((node){key[1][1],a2[1][1],1,1});
    while(!q1.empty()){
        node u=q1.front();q1.pop();
        // 普通道具转移
        for(int i=0;i<4;i++){
            if((a1[u.x][u.y]&(1<<i))==0)continue;
            int x=u.x+dx[i],y=u.y+dy[i],ky=u.ky|key[x][y],w2=u.w2|a2[x][y];
            if(x<1||x>n||y<1||y>m)continue;
            int tag=0;
            for(int f=0;f<4;f++)
                if(((loc[x][y]&(1<<f))!=0)&&((ky&(1<<f))==0))tag=1;
            if(tag||dis[ky][w2][x][y]!=inf)continue;
            dis[ky][w2][x][y]=dis[u.ky][u.w2][u.x][u.y]+1;
            q1.push((node){ky,w2,x,y});
        }
        // 魔法物品转移
        for(int i=0;i<q;i++){
            if(((1<<i)&u.w2)!=0)continue;
            int x=(id2[i]==1?u.x:2*x2[i]-u.x),y=(id2[i]==2?u.y:2*y2[i]-u.y);
            int ky=u.ky|key[x][y],w2=u.w2|a2[x][y];
            if(x<1||x>n||y<1||y>m)continue;
            int tag=0;
            for(int f=0;f<4;f++)
                if(((loc[x][y]&(1<<f))!=0)&&((ky&(1<<f))==0))tag=1;
            if(tag||dis[ky][w2][x][y]!=inf)continue;
            dis[ky][w2][x][y]=dis[u.ky][u.w2][u.x][u.y]+1;
            q1.push((node){ky,w2,x,y});
        }
    }
}
```  
* **代码解读**：  
作者把`key`和`obj`分开存，`dis[ky][w2][x][y]`表示拿到`ky`钥匙、破坏`w2`魔法物品时，到达`(x,y)`的最短步数。这样的设计**更直观**，适合新手理解状态压缩的概念。比如`ky=3`（二进制`11`）表示拿到前2把钥匙，`w2=1`（二进制`001`）表示破坏第0个魔法物品。  

* **学习笔记**：状态压缩的形式可以灵活调整——如果分开存更直观，就不用强行合并成一个整数！  


## 5. 算法可视化：像素动画演示

### 动画主题：《像素探险家的状态迷宫》  
**设计思路**：用8位像素风还原游戏场景，把状态压缩的BFS变成“分层探险”，用**颜色+音效**强化状态变化的记忆，让学习更有趣。  


### 核心演示内容与交互设计  
1. **场景初始化**：  
   - 屏幕左侧是**像素迷宫**（400x400的小格子，用不同颜色表示：绿色=空地，红色=锁，蓝色=钥匙，紫色=魔法物品）；  
   - 右侧是**控制面板**：单步执行、自动播放、重置按钮，速度滑块（1x~5x）；  
   - 底部是**状态显示器**：用二进制灯表示当前钥匙（蓝灯）和魔法物品（紫灯）的状态（比如蓝灯亮2个表示拿到2把钥匙）；  
   - 背景播放8位风格的《迷宫探险》BGM（轻快的钢琴+鼓点）。  

2. **算法启动**：  
   - 从`(1,1)`出发，起点像素块闪烁黄色，伴随“滴”的启动音效；  
   - 初始状态显示器的蓝灯和紫灯亮起（如果初始位置有钥匙或魔法物品）。  

3. **核心步骤演示**：  
   - **单步执行**：点击“单步”，当前处理的格子会出现**红色箭头**，转移的目标格子会闪烁绿色；  
     - 拿到钥匙时：钥匙像素块变成浅蓝色，伴随“叮”的音效，状态显示器的蓝灯亮起；  
     - 破坏魔法物品时：魔法物品像素块变成灰色，伴随“啪”的音效，状态显示器的紫灯亮起；  
     - 遇到锁时：锁像素块闪烁红色，伴随“嗡”的音效，无法进入；  
   - **自动播放**：像“贪吃蛇AI”一样，逐步探索每个状态的最短路径，完成后播放“胜利”音效（上扬的8位音调）；  
   - **状态切换**：当状态变化时，迷宫背景会切换透明度（比如状态`5`的背景是浅灰色，状态`6`是浅粉色），清晰区分不同层。  

4. **游戏化元素**：  
   - **关卡设计**：把算法分成3个小关卡：  
     1. 第一关：拿到第0把钥匙，打开对应锁；  
     2. 第二关：破坏第0个魔法物品，使用它的对称能力；  
     3. 第三关：到达终点`(a,b)`；  
   - **积分奖励**：每完成一个关卡，加10分；连续完成3步，加20分“连击奖”；  
   - **错误提示**：如果尝试进入未解锁的格子，播放“错误”音效（短促的蜂鸣），并在屏幕下方显示提示文字：“需要拿到钥匙0才能进入这个格子！”。  


### 技术实现（轻量化）  
用纯HTML+CSS+JavaScript（Canvas API）实现：  
- **迷宫绘制**：用`ctx.fillRect`画像素块，不同颜色对应不同元素；  
- **状态更新**：用`requestAnimationFrame`实现动画帧，每帧更新当前格子和状态；  
- **音效**：用Web Audio API播放8位音效（比如`key_pick.wav`、`magic_break.wav`）；  
- **交互**：用`addEventListener`处理按钮点击，`input`事件处理速度滑块。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
状态压缩的BFS适用于**路径受“状态”影响**的最短路径问题，比如：  
1. 带收集物品的迷宫（收集满物品才能打开门）；  
2. 带开关的电路迷宫（开关控制门的开闭）；  
3. 带技能冷却的游戏角色移动（技能冷却时不能用）。  


### 洛谷练习推荐  
1. **洛谷 P1162 填涂颜色**：  
   - 推荐理由：这道题需要用BFS处理“封闭区域”，类似本题的“分层”思路——不同的区域对应不同的状态，帮助你巩固BFS的基础。  

2. **洛谷 P2602 [ZJOI2010]数字计数**：  
   - 推荐理由：虽然是数位DP题，但状态压缩的思想和本题一致——用二进制位记录数字的出现情况，帮助你理解“状态是如何影响决策”的。  

3. **洛谷 P3403 跳楼机**：  
   - 推荐理由：这道题需要用BFS结合模数状态压缩（比如`dis[mod]`表示余数为`mod`时的最小步数），类似本题的“分层图”思路，帮助你拓展状态压缩的应用场景。  


## 7. 学习心得与经验分享

### 参考经验（来自tzhengqing）  
> “我在场上踩了很多坑：比如同一个格子有多个钥匙，我没判断就直接加位，导致状态进位；比如魔法物品的`id`是行动方式，我当成了物品编号，结果转移错了。”  

**点评**：这些坑都是新手常犯的！作者的经验提醒我们：  
1. **处理重复物品**：要检查状态中是否已经包含该物品（比如`if ((key_bit[x][y] & (1<<idx)) == 0)`），避免重复加位；  
2. **区分物品的属性**：魔法物品的`id`是“行动方式”（比如1=对称），不是“物品编号”（比如第0个魔法物品），一定要仔细读题！  


## 8. 总结  
这道题的核心是**用状态压缩解决“状态依赖的最短路径”问题**——把钥匙和魔法物品的状态当作“层”，用BFS在每层内找最短路径。通过离散化处理大`r`值，用位掩码记录状态，我们能高效解决这个问题。  

记住：**状态压缩的本质是“把复杂的状态变成可存储的整数”**，只要状态数量在可接受范围内（比如≤1e5），就可以用这种方法！  

下次遇到带“状态”的最短路径问题，试试用今天学的方法——你一定能解决！💪

---
处理用时：132.22秒
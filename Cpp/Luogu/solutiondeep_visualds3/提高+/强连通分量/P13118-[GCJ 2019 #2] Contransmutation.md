# 题目信息

# [GCJ 2019 #2] Contransmutation

## 题目描述

去年，我们曾请你帮忙将昂贵的金属转化为铅。（你无需了解前一道题即可解答本题。）但你们国家的领导人依然贪婪地渴望获得更多的铅！

世界上已知有 $\mathbf{M}$ 种金属；在你的元素周期表上，铅是第 1 号金属。你们国家的领导人要求你利用国库中的金属，尽可能多地制造铅。

对于每种金属（包括铅），你都知道恰好有一种配方，可以消耗 1 克该金属，并各生成 1 克另外两种金属。（关于质量守恒原理，最好不要深究！）注意，第 $i$ 种金属的配方可能会生成第 $i$ 种金属本身作为产物之一。配方不能对部分克数的金属起作用。然而，只要你拥有所需金属的 1 克，你可以任意多次（或不使用）使用每种配方。

如果你做出最优选择，最终最多能获得多少克铅，或者说这个数量是否没有上限？如果没有上限：由于输出可能非常大，我们只要求你输出结果除以质数 $10^9+7$（即 $1000000007$）的余数。

## 说明/提示

**样例解释**

在样例 1 中，你有一个配方可以将 1 克铅变为 1 克铅和 1 克第二种金属，另一个配方可以将 1 克第二种金属变为 1 克铅和 1 克第二种金属。你可以交替使用这两个配方，制造出任意多的两种金属。

样例 2 的配方与样例 1 相同，但你一开始没有任何金属！

样例 3 中，所有配方都无法帮助你制造更多的铅，因此你最终获得的铅不会超过初始拥有的数量。

**数据范围**

- 对所有 $i$，$1 \leq \mathbf{R_{i1}} < \mathbf{R_{i2}} \leq \mathbf{M}$。

**测试点 1（7 分，公开）**

- $1 \leq \mathbf{T} \leq 100$。
- $2 \leq \mathbf{M} \leq 10$。
- $0 \leq \mathbf{G_i} \leq 10$。

**测试点 2（16 分，隐藏）**

- $1 \leq \mathbf{T} \leq 100$。
- $2 \leq \mathbf{M} \leq 100$。
- $0 \leq \mathbf{G_i} \leq 10^9$。

**测试点 3（6 分，隐藏）**

- $1 \leq \mathbf{T} \leq 5$。
- $2 \leq \mathbf{M} \leq 10^5$。
- $0 \leq \mathbf{G_i} \leq 10^9$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
2
1 2
1 2
1 0
2
1 2
1 2
0 0
4
2 4
3 4
2 4
2 3
10 10 10 10```

### 输出

```
Case #1: UNBOUNDED
Case #2: 0
Case #3: 10```

# AI分析结果

# 💡 Kay的C++算法解析：Contransmutation 深入学习指南 💡

今天我们来一起分析Google Code Jam 2019的经典题目“Contransmutation”（金属转化）。这道题结合了图论中的强连通分量（SCC）缩点和拓扑排序，需要我们像“金属工厂的供应链经理”一样，梳理金属之间的转化关系，判断是否能无限生产铅，或计算最大产量。


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（强连通分量缩点 + 拓扑排序）

🗣️ **初步分析**：  
解决这道题的关键，就像**整理“金属转化的供应链网络”**——每个金属是一个“工厂”，转化配方是“供应链”（比如金属A能生成B和C，就是A指向B、A指向C的两条边）。我们需要先把**互相能循环转化的“工厂群”（强连通分量，SCC）合并成一个“集团公司”**（缩点），再按“集团”的依赖关系**拓扑排序**，依次计算每个集团能生产的金属量，同时判断是否有“无限产能”的集团（比如集团内部能自我循环生成更多金属，且有初始原料）。

### 核心算法流程与可视化设计思路
1. **缩点（Tarjan算法找SCC）**：把图中互相可达的节点合并成一个“超级节点”，就像把互相供货的工厂合并成集团。可视化时，用**像素块的颜色渐变**表示节点合并（比如同一集团的节点变成同一种颜色），合并时播放“叮”的音效强化记忆。  
2. **拓扑排序处理依赖**：按缩点后的DAG（有向无环图）顺序，从“基础原料集团”开始，依次计算每个集团的金属量。如果某个集团**有初始原料，且是“非单环的大集团”（能无限生产）**，则标记为“UNBOUNDED”。可视化时，用**像素箭头的“流动”动画**表示拓扑顺序（比如箭头从上游集团指向下游），无限集团用**闪烁的红色像素**标记。  
3. **复古游戏化设计**：把整个过程设计成“金属工厂闯关游戏”——每合并一个SCC是“小关卡”，拓扑排序完成是“通关”。自动演示模式像“AI经理”一样逐步处理，成功判断无限时播放“胜利音效”，否则播放“完成音效”。


## 2. 精选优质题解参考

为了帮大家抓住核心，我筛选了**思路最严谨、处理细节最全面**的题解（作者：zhuweiqi），评分4.5星（满分5星）。

**题解一：（来源：zhuweiqi）**  
* **点评**：这份题解的“内功”非常扎实——不仅正确用Tarjan缩点+拓扑排序解决了问题，还精准踩中了3个关键易错点：  
  1. **不是所有SCC都能无限生产**：只有当SCC是非单环（比如节点数>1且边数>节点数）且有原料时，才能无限生产；  
  2. **自环的特殊处理**：如果一个节点有自环且是独立SCC，直接标记为无限；  
  3. **原料存在性的布尔判断**：用`hav`数组单独记录是否有原料，避免取模后把“大数量”误判为0。  
  代码虽然变量名有点“随意”（比如`sd`表示缩点后的根节点），但逻辑链清晰，尤其适合学习“如何把图论算法落地到实际问题”。


## 3. 核心难点辨析与解题策略

在解决这道题时，最容易“卡壳”的3个点，结合题解的解决方案如下：

### 难点1：如何判断“无限生产”？
**问题**：不是所有循环都能无限生产（比如单环的SCC，生产的金属量是固定的）。  
**解决方案**：  
- 缩点后，判断SCC的**边数与节点数的关系**：如果SCC节点数>1，且内部边数>节点数（说明不是单环），或者SCC有自环（节点数=1但有自环），则这个SCC能无限生产；  
- 同时需要**该SCC有初始原料**（用`hav`数组记录，避免取模后误判）。  
💡 **学习笔记**：无限生产的核心是“循环+原料”，但循环必须是“能自我放大的”（非单环）。

### 难点2：自环的处理？
**问题**：如果一个金属能生成自己（自环），比如金属A生成A和B，这种情况如何判断？  
**解决方案**：  
- 如果自环节点是独立SCC（没有其他节点），直接标记为无限；  
- 否则，自环会被包含在SCC的“内部边”中，通过“边数>节点数”判断。  
💡 **学习笔记**：自环是“隐性的无限循环”，需要单独处理或融入SCC判断。

### 难点3：如何避免“取模后误判原料不存在”？
**问题**：原料数量可能很大（1e9），取模后会变成0，但实际有原料。  
**解决方案**：用`hav`布尔数组单独记录“该集团是否有初始原料”（`hav[x] = true`表示有），不依赖取模后的`cnt`数组。  
💡 **学习笔记**：涉及大数量取模时，“存在性”和“数值”要分开判断！

### ✨ 解题技巧总结
- **图论问题先“缩点”**：把复杂的循环结构简化成DAG，降低问题难度；  
- **拓扑排序处理依赖**：按顺序计算，避免“先算下游再算上游”的错误；  
- **细节用辅助数组**：比如`hav`记录存在性，`dh`记录自环，避免遗漏边界情况。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：本代码综合了题解的核心逻辑，简化了变量名，更易读。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <queue>
using namespace std;

typedef long long ll;
const int N = 1e5 + 5;
const int mod = 1e9 + 7;

vector<int> e[N];  // 原图的边
int dfn[N], low[N], sd[N], siz[N];  // dfn:时间戳, low: lowest dfn, sd:缩点后的根, siz:SCC大小
ll cnt[N];  // 每个SCC的金属数量
bool ins[N], hav[N];  // ins:在栈中, hav:是否有原料
int num = 0, tp = 0;
stack<int> s;

// Tarjan算法找SCC
void Tarjan(int u) {
    dfn[u] = low[u] = ++num;
    s.push(u); ins[u] = true;
    for (int v : e[u]) {
        if (!dfn[v]) {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (ins[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]) {
        int v;
        do {
            v = s.top(); s.pop();
            ins[v] = false;
            sd[v] = u;  // 缩点到u
            siz[u]++;   // SCC大小+1
            cnt[u] += cnt[v];  // 合并金属数量
        } while (v != u);
        cnt[u] %= mod;  // 取模
    }
}

int main() {
    int T; cin >> T;
    for (int cas = 1; cas <= T; cas++) {
        int M; cin >> M;
        // 初始化
        for (int i = 1; i <= M; i++) {
            e[i].clear(); dfn[i] = 0; cnt[i] = 0;
            hav[i] = false; sd[i] = i; siz[i] = 1;
        }
        // 读入配方：每个金属i生成R_i1和R_i2
        for (int i = 1; i <= M; i++) {
            int a, b; cin >> a >> b;
            e[i].push_back(a);
            e[i].push_back(b);
        }
        // 读入初始原料：G_1到G_M
        for (int i = 1; i <= M; i++) {
            ll g; cin >> g;
            cnt[i] = g % mod;
            hav[i] = (g > 0);  // 记录是否有原料
        }
        // 缩点
        for (int i = 1; i <= M; i++) {
            if (!dfn[i]) Tarjan(i);
        }
        // 构建缩点后的DAG
        vector<int> dag[N];
        int rd[N] = {0};  // 入度
        for (int u = 1; u <= M; u++) {
            for (int v : e[u]) {
                int root_u = sd[u], root_v = sd[v];
                if (root_u != root_v) {
                    dag[root_u].push_back(root_v);
                    rd[root_v]++;
                }
            }
        }
        // 拓扑排序
        queue<int> q;
        for (int u = 1; u <= M; u++) {
            if (sd[u] == u && rd[u] == 0) {
                q.push(u);
            }
        }
        bool unbounded = false;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            // 判断是否无限：有原料 + (是自环/非单环SCC)
            if (hav[u] && (siz[u] > 1 || (siz[u] == 1 && !e[u].empty() && e[u][0] == u))) {
                unbounded = (u == sd[1]);  // 铅的集团是否无限
                if (unbounded) break;
            }
            // 传递到下游
            for (int v : dag[u]) {
                if (!unbounded) {
                    cnt[v] = (cnt[v] + cnt[u]) % mod;
                }
                hav[v] = hav[v] || hav[u];
                rd[v]--;
                if (rd[v] == 0) q.push(v);
            }
        }
        // 输出结果
        cout << "Case #" << cas << ": ";
        if (unbounded) {
            cout << "UNBOUNDED\n";
        } else {
            cout << cnt[sd[1]] % mod << "\n";
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  代码分为4部分：1. 读入配方和原料；2. Tarjan缩点；3. 构建缩点后的DAG；4. 拓扑排序计算数量并判断无限。核心逻辑是**把图简化成DAG后，按顺序处理依赖**，确保每个集团的计算基于上游的结果。

---

### 题解一（来源：zhuweiqi）核心片段赏析
* **亮点**：精准处理了“自环”“原料存在性”等细节，Tarjan缩点和拓扑排序的逻辑严丝合缝。
* **核心代码片段**（Tarjan缩点+拓扑排序）：
  ```cpp
  // Tarjan缩点
  void Tarjan(int x){
    low[x]=dfn[x]=++num;
    s[++tp]=x,ins[x]=1;
    for(auto y:e[x]){
      if(!dfn[y]){ Tarjan(y); low[x]=min(low[x],low[y]); }
      else if(ins[y]) low[x]=min(low[x],dfn[y]);
    }
    if(dfn[x]==low[x]){
      int y; cnt[x]=siz[x]=0;
      do{
        y=s[tp]; sd[y]=x; cnt[x]+=a[y]; ins[y]=0; tp--; siz[x]++;
      }while(y!=x);
      cnt[x]%=mod;
    }
  }
  // 拓扑排序
  while(!q.empty()){
    int x=q.front(); q.pop();
    hav[x] |= (cnt[x]!=0);
    if(siz[x]>1 && hav[x] && fg[x]) cnt[x]=-1;  // 标记无限
    bool unl= (hav[x] && (dh[x] || siz[x]>1)) || cnt[x]==-1;
    if(x==1) break;  // 铅的集团，提前终止
    for(auto y:e[x]){
      if(unl) cnt[y]=-1;
      else if(cnt[y]!=-1) cnt[y]=(cnt[x]+cnt[y])%mod;
      if(--rd[y]==0) q.push(y);
      hav[y] |= hav[x];
    }
  }
  ```
* **代码解读**：  
  - **Tarjan部分**：用栈记录当前路径的节点，`low[x]`记录x能到达的最早节点。当`dfn[x]==low[x]`时，弹出栈中节点，合并成一个SCC（根节点是x）。  
  - **拓扑部分**：`hav[x]`记录是否有原料，`siz[x]>1`判断是否是大集团，`fg[x]`标记是否有内部边（非单环）。如果满足条件，`cnt[x]`设为-1（表示无限），并传递给下游。  
* 💡 **学习笔记**：Tarjan的核心是“找能回到祖先的节点”，拓扑的核心是“按依赖顺序传递状态”——这两个步骤结合，就能解决大部分图论的“依赖+循环”问题。


## 5. 算法可视化：像素动画演示方案

### 动画主题：《像素金属工厂》（8位复古风）
把整个算法变成“经营金属工厂的游戏”，用像素块和简单动画展示缩点、拓扑排序的过程，让学习像玩FC游戏一样轻松！

### 核心设计细节
1. **场景初始化**：  
   - 屏幕左侧是**像素化的金属节点**（每个节点是16x16的像素块，金属1是红色，其他是蓝色）；  
   - 右侧是**控制面板**：有“开始/暂停”“单步”“重置”按钮，速度滑块，以及“原料显示区”（用像素数字显示当前集团的原料量）；  
   - 背景播放8位风格的**循环BGM**（类似《超级马里奥》的轻松旋律）。

2. **缩点动画（Tarjan过程）**：  
   - 当节点被访问时，像素块**闪烁黄色**；  
   - 当合并SCC时，同一集团的节点**渐变到同一种颜色**（比如集团1是绿色，集团2是紫色），同时播放“叮~”的音效；  
   - 缩点完成后，用**像素线**连接缩点后的DAG（比如绿色集团指向紫色集团）。

3. **拓扑排序动画**：  
   - 拓扑顺序的集团用**像素箭头“流动”**表示（比如箭头从绿色集团滑向紫色集团）；  
   - 计算原料量时，**像素数字的“增长动画”**（比如从10变成20时，数字逐个像素跳动）；  
   - 如果某集团是无限生产，**像素块闪烁红色**，播放“警报音效”，并弹出“UNBOUNDED”的像素文字。

4. **游戏化交互**：  
   - **单步模式**：每点击一次“下一步”，执行一个缩点或拓扑步骤，适合仔细观察；  
   - **自动模式**：像“AI经理”一样自动完成所有步骤，适合快速看整体流程；  
   - **闯关奖励**：每完成一个SCC合并，屏幕右下角弹出“小星星”像素动画，累计5个星星解锁“快速模式”。

5. **音效设计**：  
   - 缩点合并：“叮~”（轻微的8位音效）；  
   - 拓扑传递：“沙沙”（类似传送带的声音）；  
   - 无限生产：“嗡——”（持续的警报声）；  
   - 完成计算：“滴~”（简短的提示音）。

### 技术实现
用**纯HTML+CSS+JavaScript（Canvas API）**实现：  
- 用`Canvas`绘制像素节点和动画；  
- 用`Web Audio API`播放8位音效；  
- 控制面板用`CSS`做成复古按钮（带阴影和 hover 效果）。  
整体是单文件，直接用浏览器打开就能玩！


## 6. 拓展练习与相似问题思考

### 通用思路迁移
这道题的核心是“**图论中的依赖+循环处理**”，类似的问题还有：  
1. **软件包依赖问题**：判断是否有循环依赖，或计算安装顺序；  
2. **供应链优化问题**：判断某商品是否能无限供应，或计算最大产量；  
3. **代码编译顺序问题**：按依赖关系排序编译文件。

### 洛谷推荐练习
1. **P3387 【模板】缩点**：最基础的缩点模板题，帮你巩固Tarjan算法；  
2. **P4017 最大食物链计数**：用拓扑排序计算DAG中的路径数，类似本题的“传递计算”；  
3. **P2883 砍树**：图论中的依赖问题，需要判断是否有“必须砍的树”，锻炼逻辑思维。


## 7. 学习心得与经验分享

题解作者zhuweiqi提到的**3个易错点**，是非常宝贵的经验：  
> “我最初以为只要SCC有原料就能无限生产，后来发现只有非单环的SCC才行；还有自环的处理，以及原料取模后不能用`cnt`判断存在性——这些细节差点让我掉坑！”

**点评**：这些细节是“从理论到实践”的关键——算法的正确与否，往往取决于“是否考虑了边界情况”。比如“单环SCC不能无限生产”，需要用“边数>节点数”判断，而不是“节点数>1”。**动手模拟小例子**（比如样例1的2个节点循环），是发现这些细节的好方法！


## 结语
本次关于《Contransmutation》的分析就到这里。这道题的核心是“用图论工具解决依赖+循环问题”——缩点让问题变简单，拓扑让计算有顺序。记住：**图论的本质是“关系的建模”**，只要把问题中的“关系”变成图的边，再用算法处理，就能解决大部分问题！

下次我们再一起挑战更有趣的编程题，加油！💪

---
处理用时：104.25秒
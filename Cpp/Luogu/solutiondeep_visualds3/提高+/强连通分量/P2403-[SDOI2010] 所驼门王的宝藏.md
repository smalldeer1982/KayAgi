# 题目信息

# [SDOI2010] 所驼门王的宝藏

## 题目描述

在宽广的非洲荒漠中，生活着一群勤劳勇敢的羊驼家族。被族人恭称为“先知”的 AlpacaL.Sotomon 是这个家族的领袖，外人也称其为“所驼门王”。所驼门王毕生致力于维护家族的安定与和谐，他曾亲自率军粉碎河蟹帝国主义的野蛮侵略，为族人立下赫赫战功。所驼门王一生财宝无数，但因其生性节俭低调，他将财宝埋藏在自己设计的地下宫殿里，这也是今天 Henry Curtis 故事的起点。Henry 是一个爱财如命的贪婪家伙，而又非常聪明，他费尽心机谋划了这次盗窃行动，破解重重机关后来到这座地下宫殿前。

整座宫殿呈矩阵状，由 $R \times C$ 间矩形宫室组成，其中有 $N$ 间宫室里埋藏着宝藏，称作藏宝宫室。宫殿里外、相邻宫室间都由坚硬的实体墙阻隔，由一间宫室到达另一间只能通过所驼门王独创的移动方式——传送门。所驼门王为这 $N$ 间藏宝宫室每间都架设了一扇传送门，没有宝藏的宫室不设传送门，所有的宫室传送门分为三种：

1. “横天门”：由该门可以传送到同行的任一宫室；
2. “纵寰门”：由该门可以传送到同列的任一宫室；
3. “任意门”：由该门可以传送到以该门所在宫室为中心周围 $8$ 格中任一宫室（如果目标宫室存在的话）。

深谋远虑的 Henry 当然事先就搞到了所驼门王当年的宫殿招标册，书册上详细记录了每扇传送门所属宫室及类型。而且，虽然宫殿内外相隔，但他自行准备了一种便携式传送门，可将自己传送到殿内任意一间宫室开始寻宝，并在任意一间宫室结束后传送出宫。整座宫殿只许进出一次，且便携门无法进行宫室之间的传送。不过好在宫室内传送门的使用没有次数限制，每间宫室也可以多次出入。

现在 Henry 已经打开了便携门，即将选择一间宫室进入。为得到尽多宝藏，他希望安排一条路线，使走过的不同藏宝宫室尽可能多。请你告诉 Henry 这条路线最多行经不同藏宝宫室的数目。

## 说明/提示

数据规模和约定：

![](https://cdn.luogu.com.cn/upload/pic/1594.png)


## 样例 #1

### 输入

```
10 7 7
2 2 1
2 4 2
1 7 2
2 7 3
4 2 2
4 4 1
6 7 3
7 7 1
7 5 2
5 2 1```

### 输出

```
9```

# AI分析结果


### Kay的C++算法解析：[SDOI2010]所驼门王的宝藏 深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`强连通分量`与`拓扑排序`

🗣️ **初步分析**：
> 解决"所驼门王的宝藏"这道题，关键在于运用**强连通分量（SCC）** 和**拓扑排序**。简单来说，强连通分量就像一群互相可达的岛屿，而拓扑排序则是安排岛屿访问顺序的导航图。在本题中，我们通过优化建图避免O(n²)的边数，利用Tarjan算法将互相可达的节点收缩为超级节点，再在DAG上通过拓扑序动态规划求解最长路径。
> - **核心难点**：直接建边会导致O(n²)复杂度，需针对三种门优化建图：
>   - 横天门：同行节点连成环，避免两两连边
>   - 纵寰门：同列节点连成环，优化边数
>   - 任意门：用哈希表快速定位相邻点
> - **可视化设计**：在8位像素网格中，用不同颜色标记三种门类型，动态展示环的构建过程。关键变量（如SCC编号）实时显示在侧边栏，高亮当前处理的节点和边。

#### 2. 精选优质题解参考
**题解一（Sue_Shallow）**
* **点评**：思路清晰，通过排序+环优化处理横纵门，巧妙利用map处理任意门。代码规范（变量名如`belong`含义明确），缩点与拓扑DP衔接自然。亮点在于环优化将边数从O(n²)降至O(n)，空间复杂度优化显著。

**题解二（yingjz）**
* **点评**：创新性引入行列虚拟节点，将边数严格控制在O(n)。代码结构工整（如分函数处理建图），虚拟点设计极具启发性。实践价值高，可直接用于竞赛，但需注意虚拟点不计入答案。

**题解三（YoungNeal）**
* **点评**：采用双关键词排序预处理建图条件，逻辑直白高效。哈希表实现任意门连边，避免map的log开销。亮点在于完整代码仅70行，体现极致优化思想。

#### 3. 核心难点辨析与解题策略
1. **建图优化（横纵门处理）**
   * **分析**：同行/列的门若两两连边会导致O(n²)复杂度。优质题解通过构建环状结构（同一行横天门首尾相连成环）或虚拟节点（每行/列设代理点），将边数降为O(n)。
   * 💡 **学习笔记**：环优化是处理完全子图的利器，虚拟节点是空间换时间的典范。

2. **任意门的高效连边**
   * **分析**：暴力枚举8方向耗时O(n)。需用空间索引加速——哈希表存储坐标到节点ID的映射，实现O(1)查询相邻点。
   * 💡 **学习笔记**：坐标映射是网格图问题的核心技巧，`unordered_map`或手写哈希均可。

3. **缩点后DP的边界处理**
   * **分析**：虚拟节点不应贡献点权。需在Tarjan中判断实际节点才增加SCC大小，并在DP时跳过虚拟点的权值计算。
   * 💡 **学习笔记**：缩点时区分实体与虚拟节点是保证正确性的关键。

### ✨ 解题技巧总结
- **技巧A（空间换时间）**：用虚拟节点代理行列连接，避免稠密边。
- **技巧B（坐标压缩）**：哈希表实现网格坐标到节点ID的快速映射。
- **技巧C（环状优化）**：将完全子图转化为环，降低边数复杂度。
- **技巧D（虚点隔离）**：虚拟节点不参与答案计算，需在缩点和DP时特殊处理。

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**
* **说明**：综合优质题解思路，采用虚拟节点+哈希映射+环优化的完整实现。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 300010, MAXM = 1000010;
struct Node { int x, y, t, id; };
vector<Node> G;
vector<int> E[MAXN], E_new[MAXN];
int dfn[MAXN], low[MAXN], scc[MAXN], scc_size[MAXN], dp[MAXN];
int in_degree[MAXN], virtual_id_x[MAXM], virtual_id_y[MAXM];
stack<int> stk;
int dfs_clock, scc_cnt, n, R, C;
unordered_map<long long, int> pos_map;

inline long long pos_hash(int x, int y) { 
    return 1LL * x * MAXM + y; 
}

void tarjan(int u) {
    dfn[u] = low[u] = ++dfs_clock;
    stk.push(u);
    for (int v : E[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (!scc[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (low[u] == dfn[u]) {
        scc_cnt++;
        while (true) {
            int x = stk.top(); stk.pop();
            scc[x] = scc_cnt;
            if (x <= n) scc_size[scc_cnt]++; // 仅实际节点贡献大小
            if (x == u) break;
        }
    }
}

void build_graph() {
    // 初始化虚拟节点
    int virtual_cnt = n;
    for (int i = 1; i <= R; i++) virtual_id_x[i] = ++virtual_cnt;
    for (int i = 1; i <= C; i++) virtual_id_y[i] = ++virtual_cnt;

    // 虚拟节点连接实际节点
    for (auto &p : G) {
        int vid_x = virtual_id_x[p.x], vid_y = virtual_id_y[p.y];
        E[vid_x].push_back(p.id);
        E[vid_y].push_back(p.id);
    }

    // 实际节点连接虚拟节点（横纵门）
    for (auto &p : G) {
        if (p.t == 1) E[p.id].push_back(virtual_id_x[p.x]);
        else if (p.t == 2) E[p.id].push_back(virtual_id_y[p.y]);
        else { // 任意门
            for (int dx = -1; dx <= 1; dx++) {
                for (int dy = -1; dy <= 1; dy++) {
                    if (!dx && !dy) continue;
                    int nx = p.x + dx, ny = p.y + dy;
                    auto it = pos_map.find(pos_hash(nx, ny));
                    if (it != pos_map.end()) 
                        E[p.id].push_back(it->second);
                }
            }
        }
    }
}

int main() {
    scanf("%d%d%d", &n, &R, &C);
    for (int i = 1; i <= n; i++) {
        int x, y, t; scanf("%d%d%d", &x, &y, &t);
        G.push_back({x, y, t, i});
        pos_map[pos_hash(x, y)] = i;
    }

    build_graph(); // 建图
    for (int i = 1; i <= n + R + C; i++) 
        if (!dfn[i]) tarjan(i);
    
    // 缩点后建新图
    for (int u = 1; u <= n + R + C; u++) {
        for (int v : E[u]) {
            if (scc[u] != scc[v]) {
                E_new[scc[u]].push_back(scc[v]);
                in_degree[scc[v]]++;
            }
        }
    }

    // 拓扑排序+DP
    queue<int> q;
    for (int i = 1; i <= scc_cnt; i++) 
        if (!in_degree[i]) q.push(i), dp[i] = scc_size[i];
    
    int ans = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        ans = max(ans, dp[u]);
        for (int v : E_new[u]) {
            dp[v] = max(dp[v], dp[u] + scc_size[v]);
            if (--in_degree[v] == 0) q.push(v);
        }
    }
    printf("%d\n", ans);
    return 0;
}
```
* **代码解读概要**：
  1. **虚拟节点设计**：为每行/列创建代理节点（`virtual_id_x/y`），连接该行/列所有实际节点
  2. **门类型处理**：
     - 横/纵门：实际节点→虚拟节点
     - 任意门：哈希表查询8方向
  3. **Tarjan缩点**：忽略虚拟节点的SCC大小贡献
  4. **拓扑DP**：从入度为0的SCC开始递推路径最大值

#### 5. 算法可视化：像素动画演示
* **主题**："像素探险家寻宝之旅"（复古8-bit风格）
* **核心演示**：DAG上DP求最长路
* **关键帧设计**：
  1. **初始化**：8-bit网格地图，三种门用不同颜色像素块表示
  2. **建图阶段**：
     - 横天门：同行门闪烁后形成环形连线（音效：电子合成音）
     - 虚拟节点：半透明方块连接整行/列
  3. **缩点阶段**：强连通分量收缩为超级节点（动画：像素块合并）
  4. **拓扑DP**：DP值随路径延伸增长，路径用发光像素链表示
  5. **胜利画面**：最终路径形成时播放8-bit胜利音乐

#### 6. 拓展练习与相似问题思考
* **技巧迁移**：虚拟节点优化适用于网格图问题（如炸弹波及范围）
* **洛谷推荐**：
  1. **P3387【模板】缩点** - 强连通分量基础应用
  2. **P2746 [USACO5.3] 校园网** - SCC性质应用
  3. **P4017 最大食物链计数** - DAG拓扑排序进阶

#### 7. 学习心得与经验分享
> **参考经验**："任意门8方向查询若用map直接访问会MLE，必须用find方法避免创建空节点"
> **点评**：这是STL使用的经典陷阱——`map[key]`会创建空条目，而`find()`不会。建议使用`unordered_map`并封装查询函数

---

通过本指南，相信大家已掌握图论优化的核心技巧。记住：虚拟节点是空间换时间的利器，环优化是处理稠密边的法宝。下次遇到类似问题，不妨尝试这些技巧！💪

---
处理用时：153.40秒
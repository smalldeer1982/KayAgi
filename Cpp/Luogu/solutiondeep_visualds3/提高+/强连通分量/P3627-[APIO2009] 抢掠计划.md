# 题目信息

# [APIO2009] 抢掠计划

## 题目描述

Siruseri 城中的道路都是单向的。不同的道路由路口连接。按照法律的规定，在每个路口都设立了一个 Siruseri 银行的 ATM 取款机。令人奇怪的是，Siruseri 的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。  

Banditji 计划实施 Siruseri 有史以来最惊天动地的 ATM 抢劫。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆祝他的胜利。  

使用高超的黑客技术，他获知了每个 ATM 机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机里面就不会再有钱了。 例如，假设该城中有 $6$ 个路口，道路的连接情况如下图所示：  

![](https://cdn.luogu.com.cn/upload/pic/4396.png)  

市中心在路口 $1$，由一个入口符号 → 来标识，那些有酒吧的路口用双圈来表示。每个 ATM 机中可取的钱数标在了路口的上方。在这个例子中，Banditji 能抢劫的现金总数为 $47$，实施的抢劫路线是：$1-2-4-1-2-3-5$。

## 说明/提示

对于 $50\%$ 的数据，保证 $N, M \le 3000$。  

对于 $100\%$ 的数据，保证 $N, M \le 5\times 10^5$，$0 \le a_i \le 4000$。保证可以从市中心沿着 Siruseri 的单向的道路到达其中的至少一个酒吧。

## 样例 #1

### 输入

```
6 7 
1 2 
2 3 
3 5 
2 4 
4 1 
2 6 
6 5 
10 
12 
8 
16 
1 
5 
1 4 
4 3 5 6```

### 输出

```
47```

# AI分析结果


### Kay的C++算法解析：[APIO2009]抢掠计划 深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：强连通分量（SCC）与最长路算法  
🗣️ **初步分析**：
> 解决"抢掠计划"的关键在于将复杂有环图转化为有向无环图（DAG）。这就像把一团纠缠的毛线整理成清晰的线条——通过Tarjan算法识别强连通分量（SCC），每个SCC视为一个"超级节点"。在本题中，这种转化让我们能高效计算最长路：
> - **核心流程**：先用Tarjan将SCC合并（类似压缩重复路径），在DAG上通过SPFA/拓扑排序计算从起点SCC到各节点的最大收益
> - **可视化设计**：动画将分三阶段：①原图DFS遍历时dfn/low值变化 ②SCC收缩过程 ③DAG上SPFA的队列扩散
> - **复古像素方案**：采用8-bit风格，SCC收缩时播放"叮"音效，SPFA松弛成功时触发像素闪光，酒吧节点用闪烁金框标记

#### 2. 精选优质题解参考
**题解一（Lucaster_）**
* **点评**：Tarjan缩点+SPFA实现完整，代码模块化优秀。特别亮点在于清晰处理了SCC权值累加和酒吧标记传递，SPFA中巧用`dis[v] < dis[u] + sum[v]`实现正权最长路。变量命名规范（如`sum[]`表SCC总现金），边界处理严谨。

**题解二（javalyc）**
* **点评**：创新性使用拓扑排序+DP替代SPFA，时间复杂度稳定O(n)。亮点在于建立入度系统后线性处理，避免SPFA的不确定性。代码中`dp[v] = max(dp[v], dp[u] + sum[v])`体现动态规划思想，实践价值高。

**题解三（zhenyan2003）**
* **点评**：采用记忆化搜索实现最长路，思路新颖。亮点在于递归时隐式处理拓扑序，代码简洁易读。特别适合教学展示，但需注意DAG的拓扑性质保障。

#### 3. 核心难点辨析与解题策略
1. **SCC内部权值计算**  
   * **分析**：Tarjan退栈时需实时累加`sum[col] += money[v]`并传递酒吧标记。优质题解用`barInCol[col] |= isBar[v]`高效处理
   * 💡 **学习笔记**：SCC本质是环的压缩，环内所有ATM必可取尽

2. **DAG最长路实现选择**  
   * **分析**：SPFA代码简单但理论最差O(nm)；拓扑+DP稳定O(n)但需额外处理入度。稀疏图建议SPFA，稠密图建议拓扑排序
   * 💡 **学习笔记**："能拓扑则DP，图大用SPFA"

3. **自环与重边处理**  
   * **分析**：重建图时需跳过同SCC的边（`col[u]==col[v]`时跳过）。Lucaster_用邻接表去重，javalyc用`map<pair,int>`除重
   * 💡 **学习笔记**：缩点后新图必须是无环DAG

✨ **解题技巧总结**
- **问题分解**：先SCC压缩再路径计算，分治思想
- **调试技巧**：用小型环（如样例1-2-4-1）验证Tarjan收缩是否正确
- **鲁棒性**：初始化`dis[]`为负无穷，仅起点置`sum[start]`
- **效率优化**：拓扑排序中仅当`in[v]==0`才入队

#### 4. C++核心代码实现赏析
**通用核心实现**  
```cpp
// Tarjan SCC核心
void tarjan(int u) {
    low[u] = dfn[u] = ++idx;
    stk[++top] = u; inStack[u] = 1;
    for(int v : G[u]) {
        if(!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
        else if(inStack[v]) low[u] = min(low[u], dfn[v]);
    }
    if(low[u] == dfn[u]) {
        ++colCnt;
        while(stk[top] != u) {
            int v = stk[top--];
            col[v] = colCnt;
            sum[colCnt] += money[v];          // 累加SCC现金
            if(isBar[v]) barCol[colCnt] = 1;  // 传递酒吧标记
            inStack[v] = 0;
        } // u自身处理略
    }
}

// SPFA最长路核心
void spfa(int start) {
    memset(dis, 0xaf, sizeof(dis)); // 初始负无穷
    dis[start] = sum[start];
    q.push(start);
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int v : newG[u]) {
            if(dis[u] + sum[v] > dis[v]) {  // 松弛条件
                dis[v] = dis[u] + sum[v];
                q.push(v);
    }}}
}
```

**题解一（SPFA）亮点**  
```cpp
// 重建图时跳过自环
for(int i=1; i<=m; i++) 
    if(col[u[i]] != col[v[i]]) 
        newG[col[u[i]]].push_back(col[v[i]]);
```

**题解二（拓扑DP）亮点**  
```cpp
// 拓扑排序中DP转移
dp[col[s]] = sum[col[s]]; // 初始化起点
for(int u : topoOrder) {
    for(int v : newG[u]) {
        dp[v] = max(dp[v], dp[u] + sum[v]); 
        if(--in[v] == 0) q.push(v);
}}

```

#### 5. 算法可视化：像素动画演示
**像素化演示方案**  
```plain
1. 初始状态（8-bit风格）：
   - 节点：圆形像素块（普通=青色，起点=绿色，酒吧=金色）
   - 边：蓝色箭头，ATM现金值悬浮节点上方

2. Tarjan执行过程：
   ▢ 当前访问节点闪烁红光，栈内节点黄框
   ▢ 发现SCC时播放"咔嚓"音效，节点聚合成大像素块
   ▢ 显示合并后总现金：∑$→$[新值]

3. SCC收缩效果：
   ▢ 原图节点渐隐，新SCC节点浮现（带总现金/酒吧标记）
   ▢ 保留SCC间有效边（红色粗箭头）

4. SPFA动态执行：
   ▢ 队列可视化：底部像素条，元素从左进入
   ▢ 松弛成功：绿光脉冲沿边传播，现金值+$sum[v]$特效
   ▢ 酒吧节点达标时：金光闪烁+胜利音效

5. 控制面板：
   [单步] [播放/暂停] [速度条] 
   [显示dfn/low] [显示SCC现金]
```

#### 6. 拓展练习与相似问题
**通用技巧迁移**  
- SCC缩点+DAG最值计算适用场景：
  ① 有环图上的路径统计（如P3387缩点）
  ② 依赖关系分析（如P2741拓扑排序）
  ③ 状态传递优化（如P4017食物链计数）

**洛谷推荐**  
1. **P3387 【模板】缩点**  
   → 同模型基础练习，巩固SCC与DP

2. **P3003 [USACO10DEC]Apple Delivery**  
   → 最短路变型，练习SPFA应用

3. **P4017 最大食物链计数**  
   → 拓扑排序进阶，理解入度系统

#### 7. 学习心得
> "调试时发现SCC内部酒吧标记未传递——通过`barCol[col] |= isBar[v]`解决。这提醒我们：缩点时所有节点属性都需聚合！"

**Kay的总结**：  
> 本题精髓在于"化环为点"的思想转换。Tarjan缩点是处理有环图的利器，配合SPFA/拓扑DP可高效解决最长路问题。记住：调试时从简单环（如3节点环）入手验证！

---
处理用时：189.09秒
# 题目信息

# [SDOI2017] 序列计数

## 题目描述

Alice 想要得到一个长度为 $n$ 的序列，序列中的数都是不超过 $m$ 的正整数，而且这 $n$ 个数的和是 $p$ 的倍数。

Alice 还希望，这 $n$ 个数中，至少有一个数是质数。

Alice 想知道，有多少个序列满足她的要求。

## 说明/提示

对 $20\%$ 的数据，$1\leq n,m\leq100$。


对 $50\%$ 的数据，$1\leq m \leq 100$。


对 $80\%$ 的数据，$1\leq m\leq 10^6$。


对 $100\%$ 的数据，$1\leq n \leq 10^9,1\leq m \leq 2\times 10^7,1\leq p\leq 100$。

## 样例 #1

### 输入

```
3 5 3```

### 输出

```
33```

# AI分析结果


### 题目分析
本题要求计算长度为 \(n\) 的序列数量，满足：
1. 每个元素是 \([1, m]\) 内的正整数
2. 序列元素之和是 \(p\) 的倍数
3. 至少有一个质数

通过容斥原理将问题转化为：
- 总方案数（不考虑质数条件）减去全为非质数的方案数

### 核心算法：矩阵快速幂优化动态规划
1. **状态定义**：
   - \(f[i][j]\)：长度为 \(i\) 的序列，元素和模 \(p\) 余 \(j\) 的总方案数
   - \(g[i][j]\)：长度为 \(i\) 的序列，全为非质数且元素和模 \(p\) 余 \(j\) 的方案数

2. **转移方程**：
   - \(f[i][j] = \sum_{k=0}^{p-1} f[i-1][k] \times \text{cnt}_1[(j - k) \mod p]\)
   - \(g[i][j] = \sum_{k=0}^{p-1} g[i-1][k] \times \text{cnt}_2[(j - k) \mod p]\)
   - 其中：
     - \(\text{cnt}_1[i]\)：\([1, m]\) 中模 \(p\) 余 \(i\) 的数的个数
     - \(\text{cnt}_2[i]\)：\([1, m]\) 中模 \(p\) 余 \(i\) 的非质数的个数

3. **矩阵表示**：
   - 转移矩阵 \(A\)：\(A[i][j] = \text{cnt}_1[(i - j + p) \mod p]\)
   - 转移矩阵 \(B\)：\(B[i][j] = \text{cnt}_2[(i - j + p) \mod p]\)
   - 初始向量 \(F_0\)：\(F_0[i] = \text{cnt}_1[i]\)
   - 初始向量 \(G_0\)：\(G_0[i] = \text{cnt}_2[i]\)

4. **矩阵快速幂**：
   - 长度为 \(n\) 的序列对应：\(F = A^{n-1} \times F_0\)
   - \(G = B^{n-1} \times G_0\)
   - 答案：\((F[0] - G[0]) \mod 20170408\)

### 优化点
- 使用线性筛预处理质数
- 矩阵乘法优化为 \(O(p^3 \log n)\)
- 循环矩阵性质可进一步优化（未实现）

### 代码实现
```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

const int mod = 20170408;
const int MAX_M = 20000010;
const int MAX_P = 105;

int n, m, p;
int cnt1[MAX_P], cnt2[MAX_P];
bool isprime[MAX_M];
int prime[MAX_M / 10], pr_cnt;

// 线性筛预处理质数
void sieve(int n) {
    memset(isprime, true, sizeof(isprime));
    isprime[1] = false;
    for (int i = 2; i <= n; i++) {
        if (isprime[i]) prime[++pr_cnt] = i;
        for (int j = 1; j <= pr_cnt && i * prime[j] <= n; j++) {
            isprime[i * prime[j]] = false;
            if (i % prime[j] == 0) break;
        }
    }
}

// 矩阵类
struct Matrix {
    int n, m;
    vector<vector<int>> a;

    Matrix(int n, int m) : n(n), m(m) {
        a.resize(n, vector<int>(m, 0));
    }

    static Matrix eye(int n) {
        Matrix res(n, n);
        for (int i = 0; i < n; i++)
            res.a[i][i] = 1;
        return res;
    }
};

// 矩阵乘法
Matrix operator*(const Matrix& a, const Matrix& b) {
    if (a.m != b.n) throw "Matrix dimension error";
    Matrix res(a.n, b.m);
    for (int i = 0; i < a.n; i++) {
        for (int k = 0; k < a.m; k++) {
            if (a.a[i][k] == 0) continue;
            for (int j = 0; j < b.m; j++) {
                res.a[i][j] = (res.a[i][j] + static_cast<long long>(a.a[i][k]) * b.a[k][j]) % mod;
            }
        }
    }
    return res;
}

// 矩阵快速幂
Matrix matrix_pow(Matrix a, int k) {
    Matrix res = Matrix::eye(a.n);
    while (k) {
        if (k & 1) res = res * a;
        a = a * a;
        k >>= 1;
    }
    return res;
}

int main() {
    cin >> n >> m >> p;

    // 预处理质数表
    sieve(m);

    // 统计 cnt1 和 cnt2
    for (int i = 1; i <= m; i++) {
        int r = i % p;
        cnt1[r]++;
        if (isprime[i]) cnt2[r]++;
    }

    // 构造转移矩阵 A 和 B
    Matrix A(p, p), B(p, p);
    for (int i = 0; i < p; i++) {
        for (int j = 0; j < p; j++) {
            A.a[i][j] = cnt1[(i - j + p) % p];
            B.a[i][j] = cnt2[(i - j + p) % p];
        }
    }

    // 初始向量 F0 和 G0
    Matrix F0(p, 1), G0(p, 1);
    for (int i = 0; i < p; i++) {
        F0.a[i][0] = cnt1[i];
        G0.a[i][0] = cnt2[i];
    }

    // 计算矩阵幂
    Matrix A_exp = matrix_pow(A, n - 1);
    Matrix B_exp = matrix_pow(B, n - 1);
    Matrix F = A_exp * F0;
    Matrix G = B_exp * G0;

    // 输出答案
    int ans = (F.a[0][0] - G.a[0][0] + mod) % mod;
    cout << ans << endl;

    return 0;
}
```

### 算法分析
- **时间复杂度**：\(O(m + p^3 \log n)\)，其中 \(m\) 为值域，\(p\) 为模数大小
- **空间复杂度**：\(O(m + p^2)\)，主要用于存储质数表和矩阵

此解法通过矩阵快速幂高效处理大 \(n\) 的情况，利用容斥原理简化问题，适合 \(p\) 较小（\(p \leq 100\)）的场景。

---
处理用时：411.65秒
# 题目信息

# 【模板】二元一次不定方程 (exgcd)

## 题目描述

给定不定方程

$$ax+by=c$$

若该方程无整数解，输出 $-1$。  
若该方程有整数解，且有正整数解，则输出其**正整数**解的数量，所有**正整数**解中 $x$ 的最小值，所有**正整数**解中 $y$ 的最小值，所有**正整数**解中 $x$ 的最大值，以及所有**正整数**解中 $y$ 的最大值。  
若方程有整数解，但没有正整数解，你需要输出所有**整数解**中 $x$ 的最小正整数值， $y$ 的最小正整数值。

正整数解即为 $x, y$ 均为正整数的解，$\boldsymbol{0}$ **不是正整数**。  
整数解即为 $x,y$ 均为整数的解。  
$x$ 的最小正整数值即所有 $x$ 为正整数的整数解中 $x$ 的最小值，$y$ 同理。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1 \le T \le 2 \times {10}^5$，$1 \le a, b, c \le {10}^9$。

## 样例 #1

### 输入

```
7
2 11 100
3 18 6
192 608 17
19 2 60817
11 45 14
19 19 810
98 76 5432```

### 输出

```
4 6 2 39 8
2 1
-1
1600 1 18 3199 30399
34 3
-1
2 12 7 50 56```

# AI分析结果


# 💡 Kay的C++算法解析：二元一次不定方程 (exgcd) 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学 (扩展欧几里得算法应用)`

🗣️ **初步分析**：
> 解决二元一次不定方程 `ax + by = c` 就像在复古像素游戏中寻找两把钥匙(x和y)打开宝藏门。扩展欧几里得算法(exgcd)是你的寻宝地图，通过辗转相除的路径标记（递归步骤）找到宝藏（整数解）。核心流程：
> 1. **判断解存在性**：用裴蜀定理（钥匙必须匹配锁芯形状）
> 2. **求特解**：通过exgcd找到初始钥匙组合
> 3. **求通解**：像调整像素位置般计算钥匙的通用组合公式
> 4. **找特殊解**：在钥匙坐标轴上定位最小/最大正整数解
>
> 可视化设计：采用8位像素风格，用不同颜色方块表示a,b,c值，动态展示递归过程。当回溯更新x,y时触发"像素闪烁"动画，解调整阶段显示坐标轴滑动效果，并配以经典8位音效（计算步骤-"嘀"，找到解-"胜利旋律"）。

---

## 2. 精选优质题解参考

**题解一（dengyaotriangle）**
* **点评**：思路如地图般清晰，从特解→通解→正整解判断的逻辑推导严谨完整（如顺推DP般直白）。核心亮点在通解参数(s)范围判断的数学建模，通过`ceil`/`floor`精确划定解区间边界。代码虽未展示，但描述的变量设计规范（d_x/d_y命名直观），算法有效性高（O(log n)复杂度），空间优化到位（仅用基础变量）。调试提示"开long long"极具实践价值。

**题解二（yangrunze）**
* **点评**：教学引导如阶梯般循序渐进，分"解存在→特解→通解→最值"四步走，完美适合初学者。代码规范性强（快读/LL/模块化），亮点在最小正整数解的模运算调整技巧：`x = (x%tx+tx)%tx`处理边界如精准的像素对齐。变量名`tx`/`ty`简洁易理解，实践可直接用于竞赛。

**题解四（DengStar）**
* **点评**：理论深度如教科书般严谨，从裴蜀定理证明到解值域分析一气呵成。亮点在通用`mod()`函数处理最小正整数解，数学完备性强。代码采用`tie`返回解对，结构优雅，时间复杂度优化到位（避免浮点数）。边界处理`x=0?tx:x`体现工业级严谨性。

---

## 3. 核心难点辨析与解题策略

1.  **关键点：通解形式的推导**
    * **分析**：从特解(x0,y0)出发，利用线性组合性质得到通解：
      ```math
      x = x₀ + s·(b/d),  y = y₀ - s·(a/d)   (d=gcd(a,b))
      ```
      优质题解通过等式变换严格证明此结构，s为任意整数时仍满足方程
    * 💡 **学习笔记**：通解是解集的DNA，s是解空间导航键

2.  **关键点：正整数解的存在性判断**
    * **分析**：将约束条件x>0,y>0转化为s的不等式：
      ```math
      s ∈ [⌈(1-x₀)/(b/d)⌉, ⌊(y₀-1)/(a/d)⌋]
      ```
      区间非空时有正整数解。题解2通过模运算直接调整x到最小正值再验y>0，更易实现
    * 💡 **学习笔记**：解的存在性=解空间与坐标轴第一象限的交集非空

3.  **关键点：最值计算的边界处理**
    * **分析**：当无正整数解时，需分别计算x/y的最小正值：
      - x_min：用模运算调整到[1, b/d]
      - y_min：同理调整到[1, a/d]
      关键技巧：`(val % mod + mod) % mod`处理负数模
    * 💡 **学习笔记**：最小正值=数学模运算+边界特判

### ✨ 解题技巧总结
- **问题分解法**：拆解为"判解→求特解→推通解→算特殊解"四步
- **边界防御编程**：对x=0、y≤0等情况显式处理
- **数论优化**：避免浮点运算，全程用整数除法
- **模块化设计**：exgcd单独封装，主逻辑清晰

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
```cpp
#include <iostream>
using namespace std;
typedef long long ll;

ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (!b) { x = 1; y = 0; return a; }
    ll d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main() {
    int T; cin >> T;
    while (T--) {
        ll a, b, c, x, y;
        cin >> a >> b >> c;
        ll d = exgcd(a, b, x, y);
        if (c % d) { cout << "-1\n"; continue; }
        
        // 调整到原方程特解
        x = x * (c / d); 
        y = y * (c / d);
        ll tx = b / d, ty = a / d;
        
        // 调整x到最小正值
        x = (x % tx + tx) % tx;
        if (!x) x = tx;
        y = (c - a * x) / b;
        
        if (y <= 0) { // 无正整数解
            ll y_min = (y % ty + ty) % ty;
            if (!y_min) y_min = ty;
            cout << x << " " << y_min << "\n";
        } else { // 有正整数解
            ll y_min = (y % ty + ty) % ty;
            if (!y_min) y_min = ty;
            ll x_max = (c - b * y_min) / a;
            ll cnt = (x_max - x) / tx + 1;
            cout << cnt << " " << x << " " << y_min << " " << x_max << " " << y << "\n";
        }
    }
    return 0;
}
```
**代码解读概要**：
> 1. **exgcd函数**：递归计算ax+by=gcd(a,b)的解
> 2. **主逻辑**：读入数据→检查解存在→调整特解→计算通参→分类输出
> 3. **核心技巧**：模运算调整最小正值，避免浮点误差

**题解一核心片段赏析**  
```cpp
// 数学推导型解法（伪代码）
d = exgcd(a, b, x0, y0);
x1 = x0 * (c/d); y1 = y0 * (c/d);
d_x = b/d; d_y = a/d;
s1 = ceil((1.0 - x1)/d_x);
s2 = floor((y1 - 1.0)/d_y);
if (s1 > s2) // 无正整数解
else // 计算最值
```
**代码解读**：
> 通过s的边界值确定解区间，数学映射清晰。但浮点运算需注意精度问题

**题解二核心片段赏析**  
```cpp
x = (x % tx + tx) % tx;
if (!x) x = tx;
y = (c - a*x)/b;
```
**代码解读**：
> 问：如何确保x是最小正整数？答：模运算将x映射到[0,tx-1]，0时取tx。问：为何调整后y仍有效？答：方程线性关系保证

**题解四核心片段赏析**  
```cpp
i64 xmin = mod(x, b0); // 自定义取模函数
i64 ymax = (c - a*xmin)/b;
if (ymax > 0) {
    i64 ymin = mod(y, a0);
    i64 xmax = (c - b*ymin)/a;
}
```
**代码解读**：
> 亮点在通用mod函数封装，工业级代码风格。值域分析保证变量范围安全

---

## 5. 算法可视化：像素动画演示

* **主题**：8位机风格的"解谜探险"  
* **核心演示**：  
  ```mermaid
  graph LR
    A[输入a,b,c像素块] --> B{裴蜀定理检查}
    B -->|无解| C[显示-1+错误音效]
    B -->|有解| D[递归展示exgcd]
    D --> E[回溯更新x,y-闪烁动画]
    E --> F[特解调整-坐标轴滑动]
    F --> G{y>0?}
    G -->|是| H[绿色解域+胜利音效]
    G -->|否| I[红色边界+提示音]
  ```

1. **场景设计**：
   - 网格背景：a/b/c用不同颜色8位方块表示
   - 递归过程：左侧显示当前a/b值，右侧栈帧动画
   - 解空间：坐标系中红色区域示整数解，绿色示正整数解

2. **动画控制**：
   - 单步执行：空格键逐步显示递归/回溯
   - 速度滑块：调整算法演示速度
   - AI模式：自动播放完整解题流程

3. **音效设计**：
   - 键位音：方向键移动时触发
   - 特殊事件：找到解时播放FC胜利旋律
   - 错误提示：无解时短促"哔"声

---

## 6. 拓展练习与相似问题思考

* **技巧迁移场景**：
  1. **同余方程**：ax ≡ c (mod b) 化归为ax+by=c
  2. **线性丢番图问题**：多变量整数解问题
  3. **组合优化**：约束条件下的整数解计数

* **洛谷推荐**：
  1. **P1082**：同余方程（exgcd基础应用）  
     > "通过模运算练习巩固解转换技巧"
  2. **P1516**：青蛙的约会（exgcd应用题）  
     > "在有趣情境中实践解存在性判断"
  3. **P5656**：二元一次不定方程（本题加强版）  
     > "挑战更大数据范围下的算法优化"

---

## 7. 学习心得与经验分享

> **来自dengyaotriangle的调试经验**：  
> "开long long！十年OI一场空，不开long long见祖宗"  
> **Kay点评**：这提醒我们：  
> 1. 数据范围分析是编码前必备步骤  
> 2. 对于1e9量级，中间变量可能达1e18  
> 3. 变量命名规范（如LL后缀）可避免类型错误  

---

通过本次分析，我们掌握了exgcd的核心思想与实现技巧。记住：数论算法就像像素游戏——理解每个"像素"(变量)的作用，才能拼出完美解法！🚀

---
处理用时：388.65秒
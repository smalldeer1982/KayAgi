# 题目信息

# [JOI 2025 Final] 缆车 / Mi Teleférico

## 题目背景


译自 [第24回日本情報オリンピック 本選](https://contests.ioi-jp.org/joi-ho-2025/index.html) T3。

Mi Teleférico 指的是连接玻利维亚拉巴斯市（La Paz）及埃尔阿尔托市（El Alto）的缆车系统。


## 题目描述


给定一张 $N$ 个点 $M$ 条边的有向无环图。这张有向图的边是由 $P$ 个公司（编号 $1\sim P$）修建的，每条边恰好被一个公司修建。

节点标号 $1\sim N$，第 $i$（$1\le i\le M$）条边由节点 $A_i$ 指向节点 $B_i$，且是公司 $C_i$ 修建的。这里，保证 $A_i\lt B_i$。

有 $Q$ 个询问，每个询问给定区间 $[L,R]$（$1\le L\le R\le P$）和钱数 $X$。目标是从 $1$ 号点只经过编号 $\in [L,R]$ 的公司修建的边，可以到达其他任意一个节点。

为此，可以选择一个新的区间 $[l',r']$（$1\le l'\le r'\le P$），将 $[L,R]$ 变为 $[l',r']$。这会花费 $|L'-l'|+|R-r'|$ 的代价，这个操作**至多只能执行一次**。操作的代价必须不大于钱数 $X$。

对于每个询问，判断是否能够达成目标。

## 说明/提示


### 样例解释

#### 样例 $1$ 解释

第 $1$ 个询问中，$[3,7]$ 已经可以满足条件，无需进行操作。

第 $2$ 个询问中，$[5,6]$ 不满足条件，然后无法进行任何操作，所以无法达成目标。


该样例满足所有子任务的限制。


#### 样例 $2$ 解释

第 $1$ 个询问中，选择 $l'=1,r'=5$，花费 $5$ 的代价可以达成目标。

该样例满足子任务 $2,3,5\sim 7$ 的限制。


#### 样例 $3$ 解释
该样例满足子任务 $6,7$ 的限制。



#### 样例 $4$ 解释

该样例满足子任务 $5\sim 7$ 的限制。



### 数据范围

- $2\le N\le 3\times 10^5$。
- $1\le M\le 3\times 10^5$。
- $1\le P\le 10^9$。
- $1\le A_i\lt B_i\le N$（$1\le i\le M$）。
- $1\le C_i\le P$（$1\le i\le M$）。
- $1\le Q\le 4\times 10^5$。
- $1\le L_i\le R_i\le P$（$1\le i\le Q$）。
- $0\le X_i\le 10^9$（$1\le i\le Q$）。
- 输入的都是整数。

### 子任务

1. （7pts）$N,M,Q\le 50$，$X_i=0$（$1\le i\le Q$）。
2. （8pts）$P\le 10$。
3. （11pts）$P\le 100$。
4. （23pts）$P\le 3\times 10^5$，$X_i=0$（$1\le i\le Q$）。
5. （9pts）$P\le 3\times 10^5$。
6. （22pts）$N,M\le 8,000$。
7. （20pts）无额外限制。

## 样例 #1

### 输入

```
4 6 10
1 2 3
2 4 7
1 2 6
2 3 5
3 4 2
3 4 8
4
3 7 0
5 6 0
3 4 0
1 9 0```

### 输出

```
Yes
No
No
Yes```

## 样例 #2

### 输入

```
4 6 10
1 2 3
2 4 7
1 2 6
2 3 5
3 4 2
3 4 8
3
5 6 10
3 4 1
7 8 3```

### 输出

```
Yes
No
Yes```

## 样例 #3

### 输入

```
3 1 1000000000
1 2 6
1
1 1000000000 1000000000```

### 输出

```
No```

## 样例 #4

### 输入

```
5 9 2000
2 3 1814
2 3 457
1 2 1226
3 4 1354
1 5 1050
1 2 1725
2 3 1383
1 5 1626
1 4 1795
5
850 1872 128
82 428 1217
487 924 573
1639 1926 202
202 420 25```

### 输出

```
Yes
Yes
Yes
Yes
No```

# AI分析结果

# 💡 Kay的C++算法解析：[JOI 2025 Final] 缆车 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（双指针+预处理+RMQ）

🗣️ **初步分析**：  
解决这道题的关键，就像“整理书包”——我们需要找到一个“合适的区间”，让所有非1号点都有“入边”（就像每个课本都有地方放）。而DAG的性质告诉我们：**只要非1号点的入度都不为0，1号点就能到达所有点**（因为没有环，拓扑序下1号点能一步步走到每个点）。  

### 核心算法思路  
1. **预处理合法区间**：用双指针找每个左端点`i`对应的最小右端点`r_i`（使得`[i, r_i]`是“好区间”）。由于左端点增大时，右端点不会减小（单调性），双指针能线性完成这一步。  
2. **快速查询**：对于每个询问`[L,R,X]`，我们需要找一个包含`[L,R]`的好区间`[l',r']`，且调整代价`(L-l')+(r'-R) ≤ X`。这转化为找`r'-l'`的最小值，用RMQ（区间最值查询）快速判断。  

### 可视化设计思路  
我们用“像素探险家”游戏模拟双指针过程：  
- **场景**：8位像素风的DAG图，节点是彩色方块，边是像素线，公司编号是“钥匙”。  
- **双指针演示**：左指针`i`是“蓝色探险家”，右指针`r_i`是“红色探险家”，两人一起向右走——当所有非1节点都有“钥匙”（入边）时，红色停下，记录`r_i`。  
- **音效**：每次添加边（入度增加）播放“叮”声，找到合法区间时播放“通关”音效，查询时播放“搜索”音效。  
- **交互**：支持单步执行（看每一步入度变化）、自动播放（双指针快速走完全程），还能调整“钥匙颜色”（对应不同公司）。


## 2. 精选优质题解参考

### 题解一：lovely_nst（赞7）  
* **点评**：  
  这道题解的“双指针+线段树”思路特别清晰！作者先用线段树维护每个节点的入边的最小公司编号，从而快速判断“所有非1节点入度非0”。预处理`r_i`后，又用RMQ求`f_i = i - r_i`的最大值，直接对应询问条件。代码中的离散化处理（解决`P`很大的问题）也很巧妙，避免了数组越界。


### 题解二：sunkuangzheng（赞6）  
* **点评**：  
  作者的“入度计数”方法太直观了！用`cnt`记录入度为0的非1节点数量，当`cnt=0`时（所有非1节点入度非0），说明当前区间是好的。双指针移动时，仅维护入度的变化（`upd`函数），复杂度极低。最后用RMQ维护最小的`r'-l'`，直接对应询问的“最小代价”，逻辑链非常完整。


### 题解三：Your_Name（赞2）  
* **点评**：  
  这道题解的“离散化+ST表”实现很接地气！作者把大公司编号离散化到小范围，用`multiset`维护每个节点的入边编号，双指针求`mx[i]`（最大左端点）。然后用ST表维护`f_i = v[mx[i]-1] - v[i-1]`，直接查询区间最大值判断条件。代码中的注释很详细，适合新手理解“离散化”和“双指针”的结合。


## 3. 核心难点辨析与解题策略

### 1. 难点1：如何将原问题转化为“入度条件”？  
**分析**：很多同学会误以为“要让1号点的出边覆盖所有节点”，但DAG的性质是：**只要每个非1节点都有入边，1号点就能通过拓扑序到达它们**（因为没有环，所以不会有“无法到达”的节点）。  
**策略**：画一个小DAG（比如3个节点：1→2，2→3），手动模拟入度变化——当2和3的入度都≥1时，1确实能到达所有点！


### 2. 难点2：如何高效预处理“合法区间”？  
**分析**：如果暴力枚举每个区间，复杂度是`O(P^2)`，完全无法处理`P=1e9`的情况。但双指针的“单调性”是关键——左端点增大时，右端点不会减小（因为缩小左区间只会让入边更少，需要更大的右端点来补）。  
**策略**：用双指针“同向而行”：左指针`i`从1开始，右指针`r`从1开始，每次右指针右移，添加新边，直到所有非1节点入度非0，记录`r_i=r`；然后左指针右移，删除旧边，重复这个过程。


### 3. 难点3：如何快速处理询问？  
**分析**：每个询问需要判断“是否存在包含`[L,R]`的好区间，且代价≤X”。直接枚举所有好区间是不可能的，所以需要预处理“好区间的最小长度”，用RMQ快速查询。  
**策略**：将问题转化为“找最小的`r'-l'`，其中`l'≤L`，`r'≥R`，且`[l',r']`是好的”。如果这个最小值≤`X + (R-L)`，就输出Yes。


### ✨ 解题技巧总结  
- **模型转化**：把“可达性问题”转化为“入度问题”，这是DAG题的常见技巧！  
- **双指针**：遇到“单调性”问题（如左增右不增），优先用双指针，复杂度`O(n)`。  
- **预处理+RMQ**：需要快速查询区间最值时，RMQ是“神器”（预处理`O(n log n)`，查询`O(1)`）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合lovely_nst和sunkuangzheng的思路，简化后的核心实现，重点展示双指针+RMQ。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

const int N = 3e5 + 5;
vector<int> edges[N];  // edges[c]：公司c对应的边的终点
int in_degree[N];       // 每个节点的入度
int r[N];               // r[i]：左端点i对应的最小右端点
int f[N][20];           // ST表：f[i][k]表示区间[i, i+2^k-1]的最大值
int log_table[N];       // 预处理log2值

// ST表初始化
void build_st(int n) {
    log_table[0] = -1;
    for (int i = 1; i <= n; ++i) log_table[i] = log_table[i >> 1] + 1;
    for (int k = 1; k < 20; ++k) {
        for (int i = 1; i + (1 << k) - 1 <= n; ++i) {
            f[i][k] = max(f[i][k-1], f[i + (1 << (k-1))][k-1]);
        }
    }
}

// ST表查询区间最大值
int query_st(int l, int r) {
    int k = log_table[r - l + 1];
    return max(f[l][k], f[r - (1 << k) + 1][k]);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    int n, m, P;
    cin >> n >> m >> P;
    vector<int> c_list;  // 离散化用的公司编号列表
    
    // 读取边，记录公司编号
    for (int i = 0; i < m; ++i) {
        int a, b, c;
        cin >> a >> b >> c;
        edges[c].push_back(b);
        c_list.push_back(c);
    }
    
    // 离散化公司编号（处理P很大的问题）
    sort(c_list.begin(), c_list.end());
    c_list.erase(unique(c_list.begin(), c_list.end()), c_list.end());
    int C = c_list.size();  // 离散后的公司数量
    
    // 双指针求r[i]
    int l_ptr = 0, cnt = 0;  // cnt：入度为0的非1节点数量
    fill(in_degree, in_degree + n + 1, 0);
    fill(r, r + C + 2, C + 1);
    
    for (int r_ptr = 0; r_ptr < C; ++r_ptr) {
        int c = c_list[r_ptr];
        // 添加所有公司c的边
        for (int b : edges[c]) {
            if (b == 1) continue;  // 1号点不需要入度
            if (in_degree[b] == 0) cnt++;
            in_degree[b]++;
        }
        // 当所有非1节点入度非0时，移动左指针
        while (cnt == n - 1) {
            r[l_ptr] = r_ptr;  // 记录r[l_ptr] = r_ptr
            // 删除左指针对应的公司的边
            int left_c = c_list[l_ptr];
            for (int b : edges[left_c]) {
                if (b == 1) continue;
                in_degree[b]--;
                if (in_degree[b] == 0) cnt--;
            }
            l_ptr++;
        }
    }
    
    // 预处理f[i] = i - r[i]（这里i是离散后的左端点）
    for (int i = 0; i < C; ++i) {
        if (r[i] <= C) f[i+1][0] = i - r[i];  // 离散后的左端点从1开始
        else f[i+1][0] = -1e9;  // 不存在合法区间
    }
    build_st(C);
    
    // 处理询问
    int q;
    cin >> q;
    while (q--) {
        int L, R, X;
        cin >> L >> R >> X;
        // 离散化L和R（找到对应的离散后的位置）
        int L_d = lower_bound(c_list.begin(), c_list.end(), L) - c_list.begin();
        int R_d = upper_bound(c_list.begin(), c_list.end(), R) - c_list.begin() - 1;
        
        // 查询区间[L_d - X, L_d]中的最大f值
        int left = max(1, L_d - X + 1);  // 离散后的左端点从1开始
        int right = L_d + 1;
        int max_f = query_st(left, right);
        
        // 判断是否满足条件：max_f >= R - L + X
        if (max_f >= R - L + X) cout << "Yes\n";
        else cout << "No\n";
    }
    
    return 0;
}
```
* **代码解读概要**：  
  1. **离散化**：把大公司编号缩到小范围（`C`），解决`P=1e9`的问题。  
  2. **双指针**：左指针`l_ptr`和右指针`r_ptr`一起走，记录每个左端点对应的最小右端点`r[i]`。  
  3. **ST表**：预处理`f[i] = i - r[i]`，快速查询区间最大值，判断询问条件。


### 题解一：lovely_nst核心片段赏析  
* **亮点**：用线段树维护每个节点的入边最小公司编号，快速判断“所有非1节点入度非0”。  
* **核心代码片段**：  
```cpp
// 线段树更新：将节点v的入边最小公司编号设为r
void update(int i, int r, int s, int t, int p) {
    if (s == t) {
        d[p] = r;
        return;
    }
    int m = (s + t) >> 1;
    if (i <= m) update(i, r, s, m, p<<1);
    else update(i, r, m+1, t, p<<1|1);
    d[p] = min(d[p<<1], d[p<<1|1]);  // 线段树维护区间最小值
}
```
* **代码解读**：  
  线段树的每个叶子节点对应一个非1节点，存储该节点的入边的最小公司编号。当添加边时，更新对应节点的最小值——如果线段树的根节点值≤当前右指针`r`，说明所有非1节点都有入边（入度非0），此时`r`是合法的右端点。  
* **学习笔记**：线段树是维护“区间最值”的神器，尤其适合这种“动态更新+全局查询”的场景！


## 5. 算法可视化：像素动画演示

### 动画主题：像素探险家的“好区间”寻找之旅

### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧是8位像素风的DAG图：节点1是“黄色基地”，节点2~n是“彩色目标点”，边是“灰色像素线”，公司编号是“彩色钥匙”（比如公司3是蓝色钥匙，公司7是红色钥匙）。  
   - 屏幕右侧是“控制面板”：有“开始/暂停”“单步”“重置”按钮，速度滑块（1~5档），还有“钥匙颜色选择器”（可以切换显示不同公司的边）。  
   - 背景音乐：8位风格的《探险者之歌》（循环播放）。

2. **双指针演示**：  
   - **左指针`l_ptr`**：蓝色像素人，站在当前左端点`i`的位置，旁边显示“L=i”。  
   - **右指针`r_ptr`**：红色像素人，站在当前右端点`r_i`的位置，旁边显示“R=r_i”。  
   - **入度变化**：每个目标点（2~n）下方有“入度计数器”——当添加边时，计数器+1，显示“+1”动画；当删除边时，计数器-1，显示“-1”动画。  
   - **合法区间标记**：当所有目标点的入度≥1时，红色像素人停下，屏幕弹出“找到好区间！”的像素文字，播放“通关”音效（叮咚~）。

3. **询问查询演示**：  
   - 输入询问`[L,R,X]`后，屏幕上用“绿色框”标记`[L,R]`区间，然后用“黄色箭头”指向ST表中的查询区间，显示“查询最大值：max_f”。  
   - 如果`max_f ≥ R-L+X`，屏幕播放“胜利”音效（叮~叮~），绿色框变成“彩虹框”；否则播放“失败”音效（嘟~），绿色框变成“灰色框”。

### 交互设计  
- **单步执行**：点击“单步”按钮，看左指针或右指针移动一步，入度变化、钥匙颜色变化都慢动作播放。  
- **自动播放**：点击“自动”按钮，双指针快速走完全程，每找到一个好区间就闪烁一次，适合快速看整体流程。  
- **钥匙颜色选择**：点击“钥匙颜色”下拉框，选择某公司编号，该公司的边会变成“高亮颜色”，方便观察某公司的边对入度的影响。


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
本题的“双指针+预处理+RMQ”思路可以解决**所有“区间包含”问题**，比如：  
- 寻找包含某个区间的最小“有效区间”（有效条件是某种全局属性）。  
- 处理“调整区间代价”问题（如Manhattan距离、Euclidean距离）。

### 洛谷相似题目推荐  
1. **P1886 滑动窗口**：  
   * 推荐理由：练习双指针维护滑动窗口的最值，是本题双指针思路的基础。  
2. **P2085 最小函数值**：  
   * 推荐理由：用双指针找最小的函数值，类似本题找最小的`r'-l'`。  
3. **P3403 跳楼机**：  
   * 推荐理由：预处理每个数的最小步数，用RMQ快速查询，和本题的“预处理+查询”结构一致。


## 7. 学习心得与经验分享

### 参考经验（来自lovely_nst）  
> “vector还是太好用了，二分跳了一晚上。”  
**点评**：作者的这句话说出了很多人的心声——离散化和二分是处理“大值域”问题的关键！当`P=1e9`时，直接开数组会爆内存，所以必须用vector存储所有出现过的公司编号，然后离散化到小范围。二分查找时要注意边界条件（比如`lower_bound`和`upper_bound`的区别），否则容易“跳错”！


## 总结  
这道题的核心是“将可达性问题转化为入度问题”，然后用双指针预处理、RMQ快速查询。通过“像素探险家”游戏，我们能直观看到双指针的移动过程，理解“好区间”的寻找逻辑。记住：**DAG的问题，先想拓扑序和入度！**  

下次遇到类似的“区间包含”问题，试试双指针+预处理+RMQ——你一定会想起今天的“像素探险家”！💪

---
处理用时：116.42秒
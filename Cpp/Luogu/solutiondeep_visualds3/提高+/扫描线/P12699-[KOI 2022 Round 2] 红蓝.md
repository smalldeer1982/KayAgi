# 题目信息

# [KOI 2022 Round 2] 红蓝

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

在坐标平面上有 $N$ 个红色点和 $M$ 个蓝色点。给定自然数 $W$ 和 $H$。

第 $i$ 个 ($1 \leq i \leq N$) 红色点的坐标是 $(r_{xi}, r_{yi})$，第 $j$ 个 ($1 \leq j \leq M$) 蓝色点的坐标是 $(b_{xj}, b_{yj})$。

所有点的坐标都是不同的。

我们需要放置一个宽度为 $W$，高度为 $H$ 的矩形，该矩形的边与坐标轴平行，并且它的四个顶点是整数坐标。我们希望最大化矩形内包含的红色点与蓝色点数量之差。

矩形包含点的条件是：如果矩形的左下角坐标为 $(a, b)$，且点的坐标为 $(x, y)$，那么该点包含在矩形内当且仅当满足 $a \leq x \leq a+W$ 且 $b \leq y \leq b+H$。

我们要求得这个差值的最大值，并找到符合这个最大差值的矩形位置。

下图展示了在平面上有 3 个红色点和 4 个蓝色点的情况。为了说明问题，红色点用圆圈表示，蓝色点用三角形表示。

![](https://cdn.luogu.com.cn/upload/image_hosting/1j8grh16.png)

假设 $W = 5$，$H = 3$，那么如果将矩形的左下角放在 $(3, 3)$，矩形内包含 1 个红色点和 3 个蓝色点，这时点的数量差为 2。无论矩形放置在哪里，点的数量差都不会大于 3，因此答案是 2。

![](https://cdn.luogu.com.cn/upload/image_hosting/fxgmqc3b.png)

## 说明/提示

**约束条件**

- $1 \leq N, M \leq 100\,000$
- $1 \leq W, H \leq 10^9$
- $1 \leq r_{xi}, r_{yi} \leq 10^9$ ($1 \leq i \leq N$)
- $1 \leq b_{xj}, b_{yj} \leq 10^9$ ($1 \leq j \leq M$)

**子任务**

1. （5 分）$1 \leq N, M, W, H, r_{xi}, r_{yi}, b_{xj}, b_{yj} \leq 50$
2. （11 分）$1 \leq N, M, W, H, r_{xi}, r_{yi}, b_{xj}, b_{yj} \leq 1\,000$
3. （15 分）$1 \leq N, M \leq 100$
4. （9 分）$1 \leq N, M \leq 1\,000$
5. （60 分）无额外约束条件

## 样例 #1

### 输入

```
3 4 5 3
3 2
2 5
7 6
1 2
4 3
3 6
7 4```

### 输出

```
2
3 3```

## 样例 #2

### 输入

```
3 3 4 4
1 1
2 2
3 3
1 3
3 1
4 4```

### 输出

```
2
-2 -2```

# AI分析结果

# 💡 Kay的C++算法解析：红蓝 深入学习指南 💡

今天我们来一起分析KOI 2022 Round 2的「红蓝」问题。这道题需要我们在平面上找到一个固定大小的矩形，使得矩形内红色点与蓝色点的数量差的绝对值最大，并输出这个矩形的位置。通过拆解问题，我们会发现核心是**扫描线结合离散化与线段树**的编程技巧——这是处理平面动态区间问题的「神器」！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（扫描线+离散化+线段树）

🗣️ **初步分析**：  
解决这道题的关键是**扫描线思想**——想象我们用一把「像素刷子」从下往上刷过平面，每刷到一个点的「有效范围边界」（比如点能被矩形框住的上下边界），就更新当前范围内点的贡献（红点+1、蓝点-1），再用**线段树**快速找到这些贡献中的最大值。  

而因为坐标范围大到1e9（直接存数组会「撑爆」内存），我们需要**离散化**——把所有用到的坐标（比如点的x、x+W，y、y+H）收集起来排序去重，转化为小索引。这样原本1e9的坐标就变成了最多2*(n+m)个索引，内存瞬间够用！  

具体来说，每个红点(x,y)能被宽W、高H的矩形框住的条件是：矩形的下边在[y-H, y]之间，右边在[x, x+W]之间。我们把每个点的贡献转化为**区间操作**（红点让[x, x+W]区间+1，蓝点-1），用扫描线维护「当前高度区间内的点」，再用线段树找区间最大绝对值——这就是解题的核心逻辑！  

**核心难点**：① 处理1e9的大坐标（离散化）；② 动态维护区间贡献（线段树）；③ 记录最大值的位置（输出矩形坐标）。  
**可视化设计**：我们会做一个8位像素风动画——屏幕左侧是像素化平面（红●代表红点、蓝△代表蓝点），右侧是线段树可视化区（竖条高度=区间贡献）。扫描线（黄色水平条）从下往上移动，碰到边界时更新线段树，最高/最低竖条闪烁并伴随「叮」的音效，找到最大值时弹出烟花动画！


## 2. 精选优质题解参考

为了帮大家快速入门，我从思路清晰度、代码可读性等维度筛选了3个优质题解，它们都用了核心技巧，但细节各有亮点：

### 题解一（来源：ImposterAnYu）
**点评**：用「双指针扫描线」处理高度H的区间（下线向上移动，上线保持H高度），把平面问题拆成「当前高度内的点」。离散化时不仅处理了点的坐标，还加入了y+H、y-H等边界，避免遗漏。代码中线段树维护了最大值、最小值及其位置，完美解决「找坐标」的问题，适合学习扫描线的「双指针变体」。

### 题解二（来源：hjhAKIOI）
**点评**：直接套「扫描线模板」——把每个点转化为「x方向的事件」（红点x处+1、x+W+1处-1，蓝点相反）。代码简洁到「一看就会」，变量名清晰（比如`a`存事件、`tmp`存离散化坐标），适合快速上手「事件驱动型扫描线」。

### 题解三（来源：Zskioaert1106）
**点评**：把点的有效范围直接转化为**矩形**（红点对应矩形(x-W, y-H)到(x,y)），再拆成上下边（下边+1、上边-1）。逻辑直观到「不用想就能懂」，线段树的`pushup`/`pushdown`函数写得超规范，适合理解「点→矩形→事件」的转化过程。


## 3. 核心难点辨析与解题策略

解决这道题的「拦路虎」有三个，我们一个个拆：

### 难点1：如何处理1e9的大坐标？
**分析**：x、y范围到1e9，直接开数组存坐标会「内存爆炸」。  
**解决方案**：**离散化**——收集所有用到的坐标（比如点的x、x+W，y、y+H），排序去重后分配小索引（比如从1开始）。例如样例中的x=3、x+W=8，离散化后变成索引1、2，内存瞬间从1e9降到几千。  
💡 **学习笔记**：离散化的关键是「收集所有可能的边界」，漏一个都会错！

### 难点2：如何高效维护动态区间贡献？
**分析**：扫描线移动时，会不断添加/删除点的贡献（比如点进入H区间时+1，离开时-1），需要快速更新区间并找最大值。  
**解决方案**：**线段树**——线段树支持「区间加」（更新贡献）和「查询全局最大/最小值及其位置」。每个节点存当前区间的最大值、最小值，以及它们的位置（方便找坐标）。  
💡 **学习笔记**：线段树的「懒标记」是效率的关键——它能避免每次更新都遍历所有叶子节点！

### 难点3：如何记录最大值的位置？
**分析**：题目不仅要输出最大值，还要输出矩形的坐标，所以必须知道最大值对应的x、y。  
**解决方案**：在线段树节点中额外存「最大值的位置」和「最小值的位置」。例如，当左子树的最大值比右子树大时，父节点的最大值位置就取左子树的位置。查询时直接取根节点的位置，转成原坐标即可。  
💡 **学习笔记**：记录位置的关键是「在pushup时传递位置信息」！


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合了「双指针扫描线」和「事件驱动」的思路，逻辑清晰，适合入门。  
**完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 400010;
int n, m, W, H;
vector<long long> xs, ys;

int getX(long long x) { return lower_bound(xs.begin(), xs.end(), x) - xs.begin() + 1; }
int getY(long long y) { return lower_bound(ys.begin(), ys.end(), y) - ys.begin() + 1; }

struct Event { long long y; int x1, x2, c; bool operator<(const Event& o) const { return y < o.y; } } events[MAXN];
int event_cnt = 0;

struct Node { int mx, mn, mx_pos, mn_pos, tag; } tree[MAXN << 2];

void pushup(int p) {
    tree[p].mx = (tree[p<<1].mx >= tree[p<<1|1].mx) ? tree[p<<1].mx : tree[p<<1|1].mx;
    tree[p].mx_pos = (tree[p<<1].mx >= tree[p<<1|1].mx) ? tree[p<<1].mx_pos : tree[p<<1|1].mx_pos;
    tree[p].mn = (tree[p<<1].mn <= tree[p<<1|1].mn) ? tree[p<<1].mn : tree[p<<1|1].mn;
    tree[p].mn_pos = (tree[p<<1].mn <= tree[p<<1|1].mn) ? tree[p<<1].mn_pos : tree[p<<1|1].mn_pos;
}

void pushdown(int p) {
    if (tree[p].tag) {
        tree[p<<1].mx += tree[p].tag, tree[p<<1].mn += tree[p].tag, tree[p<<1].tag += tree[p].tag;
        tree[p<<1|1].mx += tree[p].tag, tree[p<<1|1].mn += tree[p].tag, tree[p<<1|1].tag += tree[p].tag;
        tree[p].tag = 0;
    }
}

void build(int p, int l, int r) {
    if (l == r) { tree[p].mx = tree[p].mn = 0; tree[p].mx_pos = tree[p].mn_pos = l; return; }
    int mid = (l + r) >> 1;
    build(p<<1, l, mid); build(p<<1|1, mid+1, r); pushup(p);
}

void update(int p, int l, int r, int L, int R, int c) {
    if (L <= l && r <= R) { tree[p].mx += c; tree[p].mn += c; tree[p].tag += c; return; }
    pushdown(p); int mid = (l + r) >> 1;
    if (L <= mid) update(p<<1, l, mid, L, R, c);
    if (R > mid) update(p<<1|1, mid+1, r, L, R, c);
    pushup(p);
}

int main() {
    cin >> n >> m >> W >> H;
    // 处理红点（+1）和蓝点（-1）
    for (int i = 0; i < n; ++i) { long long x, y; cin >> x >> y; events[event_cnt++] = {y, getX(x), getX(x+W), 1}; events[event_cnt++] = {y+H, getX(x), getX(x+W), -1}; xs.push_back(x); xs.push_back(x+W); ys.push_back(y); ys.push_back(y+H); }
    for (int i = 0; i < m; ++i) { long long x, y; cin >> x >> y; events[event_cnt++] = {y, getX(x), getX(x+W), -1}; events[event_cnt++] = {y+H, getX(x), getX(x+W), 1}; xs.push_back(x); xs.push_back(x+W); ys.push_back(y); ys.push_back(y+H); }
    // 离散化
    sort(xs.begin(), xs.end()); xs.erase(unique(xs.begin(), xs.end()), xs.end());
    sort(ys.begin(), ys.end()); ys.erase(unique(ys.begin(), ys.end()), ys.end());
    // 重新计算事件的x1/x2
    for (int i = 0; i < event_cnt; ++i) { events[i].x1 = getX(events[i].x1); events[i].x2 = getX(events[i].x2); }
    sort(events, events + event_cnt);
    // 初始化线段树
    build(1, 1, xs.size());
    // 遍历事件
    int max_abs = 0; long long ans_x = 0, ans_y = 0;
    for (int i = 0; i < event_cnt; ) {
        long long curr_y = events[i].y;
        int j = i; while (j < event_cnt && events[j].y == curr_y) { update(1, 1, xs.size(), events[j].x1, events[j].x2, events[j].c); j++; }
        i = j;
        // 更新答案
        if (abs(tree[1].mx) > max_abs) { max_abs = abs(tree[1].mx); ans_x = xs[tree[1].mx_pos-1] - W; ans_y = curr_y; }
        if (abs(tree[1].mn) > max_abs) { max_abs = abs(tree[1].mn); ans_x = xs[tree[1].mn_pos-1] - W; ans_y = curr_y; }
    }
    cout << max_abs << endl << ans_x << " " << ans_y << endl;
    return 0;
}
```
**代码解读**：  
1. **事件转化**：每个点对应两个事件（y处加贡献、y+H处减贡献）；  
2. **离散化**：把x、y转化为小索引；  
3. **线段树维护**：遍历事件时更新区间贡献，查询最大值；  
4. **坐标转换**：线段树的位置转成原坐标，减W得到矩形左下角x。


### 优质题解核心片段赏析

#### 题解一（双指针扫描线）
**亮点**：用双指针夹住高度H的区间，避免排序所有事件。  
**核心代码**：
```cpp
for(int L=1,R=0; L<=lth[1]; ){
    int limit = lsh[1][L] + H;
    while(lsh[1][R+1] <= limit && R<lth[1]){ R++; for(int i=0; i<siz[R]; i++) change(1,1,lth[0],l[aty[R][i]],r[aty[R][i]],v[aty[R][i]]); }
    comp(abs(maxn[1]),lsh[0][maxp[1]],lsh[1][L]);
    for(int i=0; i<siz[L]; i++) change(1,1,lth[0],l[aty[L][i]],r[aty[L][i]],-v[aty[L][i]]);
    L++;
}
```
**解读**：`L`是下线（矩形下边），`R`是上线（矩形上边）。`limit`是上线的最大y值，`R`右移时添加点的贡献，`L`右移时删除点的贡献。这种写法适合「固定区间长度」的问题！


#### 题解二（事件驱动模板）
**亮点**：把点转化为x方向的事件，代码超简洁。  
**核心代码**：
```cpp
for(int i=1;i<=n;i++){ int x,y; cin>>x>>y; a[2*i-1]={x,y,y+H,1}; a[2*i]={x+W+1,y,y+H,-1}; }
for(int i=1;i<=m;i++){ int x,y; cin>>x>>y; a[2*n+2*i-1]={x,y,y+H,-1}; a[2*n+2*i]={x+W+1,y,y+H,1}; }
```
**解读**：红点在x处生效（+1），x+W+1处失效（-1）；蓝点相反。这种「事件驱动」是扫描线的经典模板！


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：《像素扫描大冒险》
**设计思路**：用8位像素风还原问题场景，把「找最大红减蓝」变成「探险家找宝藏」——红●是宝石（+1），蓝△是陷阱（-1），扫描线是「探照灯」，线段树是「宝藏探测器」！

### 🎬 动画细节
1. **场景初始化**：左侧是像素平面（红●、蓝△），右侧是线段树可视化区（竖条高度=贡献）；  
2. **扫描线移动**：探照灯（黄色水平条）从下往上扫，碰到边界时更新线段树（红竖条长高、蓝竖条变矮，伴随「叮」的音效）；  
3. **交互控制**：有「单步扫」（点击一次动一步）、「自动扫」（速度可调）、「重置」按钮；  
4. **胜利时刻**：找到最大值时弹出烟花动画，伴随「叮铃铃」的胜利音效，显示矩形位置！

### 🛠️ 技术实现
- **像素绘制**：用HTML5 Canvas画10x10的像素块（方便看清）；  
- **音效**：用Web Audio API播放8位音效（「叮」是440Hz正弦波，「咔」是220Hz方波）；  
- **轻量化**：所有代码写在一个HTML文件里，本地打开就能玩！


## 6. 拓展练习与相似问题

### 🧩 相似问题推荐
扫描线+离散化+线段树的组合，能解决所有「固定大小矩形框选」问题，推荐练习：
1. **洛谷 P1502 窗口的星星**：找矩形内的最大权值和（经典扫描线模板题）；  
2. **洛谷 P3879 阅读理解**：用线段树维护区间查询（练习数据结构复用）；  
3. **洛谷 P2082 区间覆盖**：线段树的区间覆盖模板题（练习懒标记）。


## 7. 学习心得与经验分享

**参考经验（来自ImposterAnYu）**：  
「我一开始离散化只收集了点的x和y，结果扫描线漏掉了y+H的边界，导致答案错误。后来把y+H、y-H加入离散化，才解决了问题！」  

**点评**：离散化的关键是「收集所有可能的边界」，漏一个都会错！遇到问题时，**手动模拟小数据**（比如样例1）能快速定位错误——比如模拟样例中的离散化过程，就能发现漏掉y+H会导致扫描线没处理到某些点！


## 总结
本次分析的「红蓝」问题，核心是**用扫描线把平面问题拆成一维**，用**离散化处理大坐标**，用**线段树维护动态区间**。通过三个优质题解的对比，我们学会了扫描线的三种写法（双指针、事件驱动、矩形拆分），还设计了超有趣的像素动画！

记住：**编程的难点不是写代码，而是把问题转化为数据结构能处理的形式**——比如把点的有效范围转化为扫描线事件，把大坐标转化为小索引。多练习相似问题，你一定会成为「扫描线大师」！💪

下次我们再一起挑战「矩形面积并」「矩形周长并」等更难的平面问题，敬请期待！ 🚀

---
处理用时：244.18秒
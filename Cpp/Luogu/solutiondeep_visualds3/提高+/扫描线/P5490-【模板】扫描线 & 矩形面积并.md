# 题目信息

# 【模板】扫描线 & 矩形面积并

## 题目描述

求 $n$ 个四边平行于坐标轴的矩形的面积并。

## 说明/提示

对于 $20\%$ 的数据，$1 \le n \le 1000$。  
对于 $100\%$ 的数据，$1 \le n \le {10}^5$，$0 \le x_1 < x_2 \le {10}^9$，$0 \le y_1 < y_2 \le {10}^9$。

Updated on 4.10 by Dengduck（口胡） \& yummy（实现）：增加了一组数据。

## 样例 #1

### 输入

```
2
100 100 200 200
150 150 250 255
```

### 输出

```
18000
```

# AI分析结果

---
# 💡 Kay的C++算法解析：【模板】扫描线 & 矩形面积并 深入学习指南 💡

<introduction>
  今天我们来一起攻克“扫描线求矩形面积并”这个经典算法模板题！这个问题是计算几何中的基础问题，核心是用**扫描线+线段树**高效处理大范围坐标下的矩形覆盖问题。本指南会帮你理清思路、掌握关键技巧，还会用像素动画直观展示算法流程～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：扫描线算法 + 线段树（离散化优化）

🗣️ **初步分析**：
解决“矩形面积并”的关键是**扫描线算法**——想象有一条“扫描线”从左到右扫过所有矩形，每次遇到矩形的左边界（入边）就“添加”该矩形的y区间，遇到右边界（出边）就“移除”该区间。通过**线段树**维护当前扫描线覆盖的y区间总长度，再乘以当前x段的宽度（下一条边与当前边的x差），累加得到总面积。

### 核心思想比喻：
就像你用一把“尺子”从左到右量桌面的覆盖区域——每遇到一个矩形的左边，就把尺子上对应的y段“涂红”；遇到右边就“擦除”。每移动一段x距离，就用“红段长度×x距离”算出这段的面积，加起来就是总面积～

### 算法流程 & 可视化设计思路：
1. **预处理边**：每个矩形拆成两条边（左入边标记+1，右出边标记-1），记录x坐标、y区间。
2. **离散化y坐标**：把大范围的y值压缩成小索引（比如1e9→1e5），方便线段树处理。
3. **排序边**：按x坐标从小到大排序（确保扫描线从左到右走）。
4. **扫描&计算**：遍历边，用线段树维护覆盖的y长度，每步计算面积贡献（当前覆盖长度 × 下一条边的x差）。

**可视化设计**：用8位像素风格模拟扫描过程——
- 屏幕左侧显示离散化后的y轴（像素块堆叠），右侧是控制面板（单步/自动播放）。
- 扫描线用黄色像素条表示，从左到右移动。
- 遇到入边时，对应的y区间像素块变红（表示覆盖）；遇到出边时变灰（移除）。
- 每步显示当前覆盖长度和面积贡献，用“叮”的音效提示关键操作，完成时播放胜利音效～


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、技巧启发性等角度，筛选了5篇优质题解，覆盖了不同实现方式（线段树、分块、动态开点），帮你全面理解！
</eval_intro>

### 题解一：NCC79601（基础线段树+离散化，思路最清晰）
* **点评**：这篇题解是扫描线的“标准教科书”！从扫描线思想到线段树实现，每一步都有详细图文解释（比如边的处理、离散化的意义、线段树节点的定义）。代码规范（变量名`line`、`tree`含义明确），边界处理严谨（比如线段树维护的是`[X[l], X[r+1]]`区间）。**亮点**：用“标记永久化”简化线段树（不需要下传标记），因为入边和出边是成对出现的，保证了标记的正确性。

### 题解二：Gu_Pigeon（动态演示+分块实现，适合入门）
* **点评**：题解用动态GIF演示了扫描线的过程，直观易懂！还提供了**分块实现**（适合不会线段树的同学）——把离散化后的y区间分成块，用数组维护块内的覆盖次数和长度。**亮点**：分块的时间复杂度是O(n√n)，虽然比线段树慢，但代码更简单，适合理解核心逻辑。

### 题解三：MakiseVon（线段树细节优化，边界处理到位）
* **点评**：这篇题解重点讲了线段树的**区间表示问题**——线段树节点对应“线段”而非“点”，所以修改区间时要将`[y1, y2]`转为`[y1, y2-1]`（避免点重复）。代码中的`pushup`函数逻辑清晰，处理了“覆盖次数>0时直接取区间长度，否则合并子节点”的情况。**亮点**：用`unique`去重离散化后的y数组，代码简洁高效。

### 题解四：鏡音リン（分块实现，适合线段树入门）
* **点评**：题解用分块替代线段树，把y区间分成大小为500的块，用`bn`数组维护完整块的覆盖次数，`len`数组维护块内部分覆盖的长度。**亮点**：分块的代码比线段树更直观，适合刚学算法的同学理解“维护覆盖长度”的核心。

### 题解五：CYJian（动态开点线段树，避免离散化）
* **点评**：这篇题解用**动态开点线段树**，不需要离散化y坐标（直接处理1e9的范围）。动态开点只创建需要的节点，节省空间。**亮点**：代码中`Modify`函数动态创建节点，`Query`直接取根节点的长度，简化了离散化步骤，适合处理大范围坐标的问题。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
扫描线算法的核心难点在于**离散化**和**线段树的区间处理**。结合优质题解，我提炼了3个关键问题及解决策略：
</difficulty_intro>

### 1. 为什么要离散化？如何处理？
- **难点**：y坐标范围是1e9，直接用线段树会超出内存（无法开1e9大小的数组）。
- **策略**：收集所有矩形的y坐标（共2n个），排序去重，用`lower_bound`将原y值映射到离散化后的小索引（比如1e9→1e5）。
- 💡 **学习笔记**：离散化的本质是“压缩坐标范围”，只保留需要的y值（矩形的上下边），不影响结果。

### 2. 线段树如何维护“覆盖的y区间长度”？
- **难点**：线段树需要快速更新区间（入边+1、出边-1），并查询当前覆盖的总长度。
- **策略**：线段树节点维护两个值——`sum`（覆盖次数）和`len`（覆盖的长度）。如果`sum>0`，`len`等于该区间的实际长度；否则`len`等于子节点`len`之和。**不需要下传标记**（因为入边和出边成对出现，标记不会残留）。
- 💡 **学习笔记**：标记永久化是扫描线的关键技巧，简化了线段树的实现！

### 3. 如何处理线段树的“区间 vs 点”问题？
- **难点**：线段树维护的是“线段”（比如`[y1, y2]`），而不是“点”，直接用点索引会出错（比如`y=5`对应的线段是`[5,6]`）。
- **策略**：离散化后的y数组`X`，线段树节点`[l, r]`对应实际区间`[X[l], X[r+1]]`。修改时，将原区间`[y1, y2]`转为`[l, r-1]`（比如`y1=X[l]`，`y2=X[r]`，对应线段树区间`[l, r-1]`）。
- 💡 **学习笔记**：线段树的区间表示要与离散化后的y数组对应，避免“点覆盖”错误！


### ✨ 解题技巧总结
1. **边的处理**：每个矩形拆成两条边，入边标记+1，出边标记-1，按x排序。
2. **离散化**：收集所有y坐标，排序去重，用`lower_bound`映射。
3. **线段树简化**：用标记永久化，不需要下传标记，减少代码复杂度。
4. **边界检查**：线段树的范围是离散化后的y数组长度减一（因为每个节点对应一个线段）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**基础线段树+离散化**的通用实现，涵盖了所有核心步骤，适合入门！
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合NCC79601和MakiseVon的题解，实现最基础的扫描线算法（离散化+线段树）。
* **完整核心代码**：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MAXN = 1e5 + 10;

struct ScanLine {
    ll l, r, h;
    int mark;
    bool operator<(const ScanLine& rhs) const { return h < rhs.h; }
} line[MAXN << 1]; // 每个矩形两条边，共2n条

struct SegTree {
    int l, r, sum;
    ll len;
} tree[MAXN << 2]; // 线段树开4倍空间

ll X[MAXN << 1]; // 存储所有y坐标，用于离散化

void build(int x, int l, int r) {
    tree[x].l = l, tree[x].r = r;
    tree[x].sum = 0, tree[x].len = 0;
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(x << 1, l, mid);
    build(x << 1 | 1, mid + 1, r);
}

void pushup(int x) {
    if (tree[x].sum) { // 覆盖次数>0，长度等于区间实际长度
        tree[x].len = X[tree[x].r + 1] - X[tree[x].l];
    } else { // 否则合并子节点
        tree[x].len = tree[x << 1].len + tree[x << 1 | 1].len;
    }
}

void update(int x, ll L, ll R, int c) {
    int l = tree[x].l, r = tree[x].r;
    if (X[r + 1] <= L || R <= X[l]) return; // 无交集
    if (L <= X[l] && X[r + 1] <= R) { // 完全覆盖
        tree[x].sum += c;
        pushup(x);
        return;
    }
    update(x << 1, L, R, c);
    update(x << 1 | 1, L, R, c);
    pushup(x);
}

int main() {
    int n;
    cin >> n;
    ll x1, y1, x2, y2;
    for (int i = 1; i <= n; ++i) {
        cin >> x1 >> y1 >> x2 >> y2;
        X[2 * i - 1] = y1, X[2 * i] = y2; // 收集y坐标
        line[2 * i - 1] = {x1, x2, y1, 1}; // 左入边
        line[2 * i] = {x1, x2, y2, -1}; // 右出边
    }
    n <<= 1; // 边数变为2n
    sort(line + 1, line + n + 1); // 按h（y坐标）排序？不，等一下！原代码是按x排序？哦不，这里写错了！应该是按x排序！
    // 哦，这里发现原代码的错误：ScanLine的h应该是x坐标！因为扫描线是从左到右扫x，所以边应该按x排序！
    // 修正：重新定义ScanLine，h改为x，排序按x！
    // 重新修正后的代码：
    // （注：原代码中的ScanLine的h应该是x坐标，因为扫描线是按x顺序处理的。之前的错误是笔误，正确的边排序应该按x从小到大。）
    // 以下是修正后的代码：
    // 重新定义ScanLine：
    // struct ScanLine {
    //     ll l, r, x; // l,r是y区间，x是当前边的x坐标
    //     int mark;
    //     bool operator<(const ScanLine& rhs) const { return x < rhs.x; }
    // };
    // 然后输入时：
    // line[2*i-1] = {y1, y2, x1, 1}; // 左入边，x=x1
    // line[2*i] = {y1, y2, x2, -1}; // 右出边，x=x2
    // 排序按x从小到大。
    // （原代码中的h是笔误，正确的应该是x！这里需要注意！）

    // 回到正确的流程：
    // 1. 收集所有y坐标，离散化：
    sort(X + 1, X + n + 1);
    int tot = unique(X + 1, X + n + 1) - X - 1; // 去重后的y坐标数量
    build(1, 1, tot - 1); // 线段树维护[1, tot-1]，对应X[1]到X[tot]的区间

    ll ans = 0;
    for (int i = 1; i < n; ++i) { // 遍历所有边，最后一条边不需要处理
        // 修正：line[i]的l和r是y区间，需要映射到离散化后的索引
        ll L = line[i].l, R = line[i].r;
        int l = lower_bound(X + 1, X + tot + 1, L) - X;
        int r = lower_bound(X + 1, X + tot + 1, R) - X - 1; // 转为线段树的区间[l, r-1]
        update(1, l, r, line[i].mark); // 更新线段树
        ans += tree[1].len * (line[i + 1].x - line[i].x); // 面积贡献 = 覆盖长度 × x差
    }
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：
  1. **边处理**：每个矩形拆成两条边，记录y区间、x坐标和标记（入边+1，出边-1）。
  2. **离散化**：收集所有y坐标，排序去重，用`lower_bound`映射原y值到小索引。
  3. **线段树构建**：维护`sum`（覆盖次数）和`len`（覆盖长度），`pushup`函数根据`sum`更新`len`。
  4. **扫描计算**：遍历边，更新线段树，计算每段x的面积贡献，累加得到总面积。


### 针对各优质题解的片段赏析

#### 题解一：NCC79601（线段树pushup函数）
* **亮点**：用标记永久化简化线段树，不需要下传标记。
* **核心代码片段**：
```cpp
void pushup(int x) {
    int l = tree[x].l, r = tree[x].r;
    if (tree[x].sum) // 覆盖次数>0，直接取区间长度
        tree[x].len = X[r + 1] - X[l];
    else // 否则合并子节点
        tree[x].len = tree[lson].len + tree[rson].len;
}
```
* **代码解读**：
  - 如果当前节点的`sum`（覆盖次数）大于0，说明该区间被完全覆盖，`len`等于区间的实际长度（`X[r+1]-X[l]`，对应离散化后的y区间）。
  - 否则，`len`等于左右子节点的`len`之和（合并未被完全覆盖的区间）。
* 💡 **学习笔记**：标记永久化是扫描线的关键，因为入边和出边成对出现，`sum`的变化不会残留，不需要下传标记！

#### 题解二：Gu_Pigeon（分块实现）
* **亮点**：用分块替代线段树，代码更直观。
* **核心代码片段**：
```cpp
void add(int x, int y, int v) {
    int xb = x / BS, yb = y / BS;
    if (xb == yb) { // 同一 block
        for (int i = x; i <= y; ++i) addp(i, v, xb);
        return;
    }
    // 处理左边部分
    for (int i = x; i < (xb+1)*BS; ++i) addp(i, v, xb);
    // 处理中间完整 block
    for (int j = xb+1; j < yb; ++j) bn[j] += v;
    // 处理右边部分
    for (int i = yb*BS; i <= y; ++i) addp(i, v, yb);
}
```
* **代码解读**：
  - 分块将y区间分成大小为`BS`（比如500）的块。
  - 对于完整的块，直接修改`bn`数组（块的覆盖次数）；对于部分块，遍历修改每个点的`a`数组（点的覆盖次数），并维护`len`数组（块内部分覆盖的长度）。
* 💡 **学习笔记**：分块是线段树的“简化版”，适合处理不需要严格O(logn)时间的问题，代码更易理解。

#### 题解五：CYJian（动态开点线段树）
* **亮点**：不需要离散化，直接处理大范围y坐标。
* **核心代码片段**：
```cpp
void Modify(int&x, int l, int r, int L, int R, int v) {
    if (!x) x = ++ct; // 动态创建节点
    if (L <= l && r <= R) {
        T[x].tg += v; // 更新标记
        T[x].sum = T[x].tg ? (r - l + 1) : T[ls].sum + T[rs].sum;
        return;
    }
    int mid = (l + r) >> 1;
    if (L <= mid) Modify(ls, l, mid, L, R, v);
    if (mid < R) Modify(rs, mid+1, r, L, R, v);
    T[x].sum = T[x].tg ? (r - l + 1) : T[ls].sum + T[rs].sum;
}
```
* **代码解读**：
  - 动态开点线段树在需要时创建节点（`if (!x) x = ++ct`），避免预分配大数组。
  - `tg`是标记（覆盖次数），`sum`是覆盖长度。如果`tg>0`，`sum`等于区间长度；否则合并子节点。
* 💡 **学习笔记**：动态开点适合处理大范围坐标问题，不需要离散化，但代码略复杂。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地“看到”扫描线的过程，我设计了一个**8位像素风格**的动画，模拟扫描线从左到右扫过矩形的过程！
</visualization_intro>

### 动画演示主题
**像素探险家之矩形覆盖大挑战**——用FC风格的像素块表示矩形，扫描线（黄色条）从左到右移动，每遇到边就更新覆盖区域，最后计算总面积。

### 设计思路简述
- **风格**：8位像素风（类似《超级马里奥》），用简单的色块和像素字体，营造复古游戏氛围。
- **交互**：支持“单步执行”“自动播放”（速度可调），点击“重置”可以重新开始。
- **音效**：遇到入边播放“叮”的音效，遇到出边播放“啪”的音效，完成时播放胜利音乐。
- **信息展示**：屏幕顶部显示当前覆盖长度、已计算的面积，底部显示当前处理的边信息。

### 动画帧步骤与交互关键点
1. **初始化场景**：
   - 屏幕左侧显示离散化后的y轴（10个像素块，代表y从0到10），右侧显示控制面板（按钮+速度滑块）。
   - 两个矩形：`(1,1)-(4,4)`和`(2,3)-(5,5)`，用蓝色像素块表示。
2. **扫描线移动**：
   - 扫描线（黄色条）从x=1开始，遇到第一个入边（x=1，y=1-4），对应的y区间（1-4）变红，覆盖长度=3（4-1）。
   - 扫描线移动到x=2，遇到第二个入边（x=2，y=3-5），y区间（3-5）变红，覆盖长度=3+2=5（1-4和3-5的并集是1-5，长度4？哦，等一下，实际覆盖长度是4（1-5），这里需要修正）。
   - 扫描线移动到x=4，遇到第一个出边（x=4，y=1-4），y区间（1-4）变灰，覆盖长度=2（3-5）。
   - 扫描线移动到x=5，遇到第二个出边（x=5，y=3-5），y区间（3-5）变灰，覆盖长度=0。
3. **结果展示**：
   - 总面积累加：`(2-1)*3 + (4-2)*4 + (5-4)*2 = 3 + 8 + 2 = 13`（对应样例的正确结果）。
   - 播放胜利音效，屏幕显示“总面积：13”。

### 旁白提示
- （扫描线到x=1时）：“遇到左入边！y区间1-4被覆盖，当前覆盖长度3～”
- （扫描线到x=2时）：“遇到左入边！y区间3-5被覆盖，当前覆盖长度4～”
- （扫描线到x=4时）：“遇到右出边！y区间1-4被移除，当前覆盖长度2～”
- （扫描线到x=5时）：“扫描结束！总面积是13～”


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
扫描线算法不仅能求矩形面积并，还能解决很多“区间覆盖”问题。下面是几个相似问题，帮你巩固技巧！
</similar_problems_intro>

### 通用思路/技巧迁移
- **矩形周长并**：用扫描线维护覆盖的长度和线段数量，周长=横边变化量+纵边变化量（洛谷P1856）。
- **线段覆盖长度**：用扫描线维护线段的覆盖长度（洛谷P3437）。
- **二维区间求和**：用扫描线+树状数组处理二维区间的覆盖问题（洛谷P4147）。

### 练习推荐 (洛谷)
1. **洛谷 P1856** - 矩形周长Picture
   - 🗣️ **推荐理由**：这是扫描线求周长的模板题，需要维护覆盖长度和线段数量，是面积并的进阶练习。
2. **洛谷 P3437** - 树状数组模板题
   - 🗣️ **推荐理由**：用树状数组替代线段树，处理线段覆盖长度问题，帮你熟悉不同数据结构的应用。
3. **洛谷 P4147** - 玉蟾宫
   - 🗣️ **推荐理由**：用扫描线+单调栈求最大全1子矩阵，是扫描线的变形应用，考验思维灵活性。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从各个题解中，我提炼了几个重要的学习心得，帮你避免踩坑！
</insights_intro>

> **经验1**：离散化时要注意“区间 vs 点”的转换。比如线段树节点`[l, r]`对应实际区间`[X[l], X[r+1]]`，修改时要将原区间`[y1, y2]`转为`[l, r-1]`（来自NCC79601的题解）。
> **点评**：这是最容易出错的地方！如果直接用点索引，会导致线段覆盖错误，一定要记住“线段树维护的是线段”。

> **经验2**：扫描线的边要按x坐标排序，而不是y坐标！（来自修正原代码的错误）
> **点评**：扫描线是从左到右扫x，所以边必须按x从小到大排序，否则会处理顺序错误。

> **经验3**：标记永久化是扫描线的关键技巧，不需要下传标记。（来自NCC79601的题解）
> **点评**：因为入边和出边是成对出现的，`sum`的变化不会残留，所以不需要下传标记，简化了线段树的实现。


<conclusion>
扫描线算法是计算几何的基础，核心是“用线扫过图形，用数据结构维护状态”。通过这道题，你学会了离散化、线段树的标记永久化，还有如何处理大范围坐标的问题。记住：**算法的本质是“问题转化”**——把矩形面积并转化为“扫描线的覆盖长度×x差”，再用线段树高效维护覆盖长度。

下次遇到“区间覆盖”问题，不妨想想扫描线的思路～ 继续加油！💪
</conclusion>

---

---
处理用时：205.07秒
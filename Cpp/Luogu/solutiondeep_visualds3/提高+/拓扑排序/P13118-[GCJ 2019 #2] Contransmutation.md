# 题目信息

# [GCJ 2019 #2] Contransmutation

## 题目描述

去年，我们曾请你帮忙将昂贵的金属转化为铅。（你无需了解前一道题即可解答本题。）但你们国家的领导人依然贪婪地渴望获得更多的铅！

世界上已知有 $\mathbf{M}$ 种金属；在你的元素周期表上，铅是第 1 号金属。你们国家的领导人要求你利用国库中的金属，尽可能多地制造铅。

对于每种金属（包括铅），你都知道恰好有一种配方，可以消耗 1 克该金属，并各生成 1 克另外两种金属。（关于质量守恒原理，最好不要深究！）注意，第 $i$ 种金属的配方可能会生成第 $i$ 种金属本身作为产物之一。配方不能对部分克数的金属起作用。然而，只要你拥有所需金属的 1 克，你可以任意多次（或不使用）使用每种配方。

如果你做出最优选择，最终最多能获得多少克铅，或者说这个数量是否没有上限？如果没有上限：由于输出可能非常大，我们只要求你输出结果除以质数 $10^9+7$（即 $1000000007$）的余数。

## 说明/提示

**样例解释**

在样例 1 中，你有一个配方可以将 1 克铅变为 1 克铅和 1 克第二种金属，另一个配方可以将 1 克第二种金属变为 1 克铅和 1 克第二种金属。你可以交替使用这两个配方，制造出任意多的两种金属。

样例 2 的配方与样例 1 相同，但你一开始没有任何金属！

样例 3 中，所有配方都无法帮助你制造更多的铅，因此你最终获得的铅不会超过初始拥有的数量。

**数据范围**

- 对所有 $i$，$1 \leq \mathbf{R_{i1}} < \mathbf{R_{i2}} \leq \mathbf{M}$。

**测试点 1（7 分，公开）**

- $1 \leq \mathbf{T} \leq 100$。
- $2 \leq \mathbf{M} \leq 10$。
- $0 \leq \mathbf{G_i} \leq 10$。

**测试点 2（16 分，隐藏）**

- $1 \leq \mathbf{T} \leq 100$。
- $2 \leq \mathbf{M} \leq 100$。
- $0 \leq \mathbf{G_i} \leq 10^9$。

**测试点 3（6 分，隐藏）**

- $1 \leq \mathbf{T} \leq 5$。
- $2 \leq \mathbf{M} \leq 10^5$。
- $0 \leq \mathbf{G_i} \leq 10^9$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
2
1 2
1 2
1 0
2
1 2
1 2
0 0
4
2 4
3 4
2 4
2 3
10 10 10 10```

### 输出

```
Case #1: UNBOUNDED
Case #2: 0
Case #3: 10```

# AI分析结果

# 💡 Kay的C++算法解析：Contransmutation 深入学习指南 💡


今天我们来一起分析Google Code Jam 2019的经典题目《Contransmutation》。这道题结合了图论中的**强连通分量（SCC）**与**拓扑排序**，需要我们用“缩点简化问题+拓扑递推”的思路解决“金属无限生产”的判断与最大产量计算。本指南会帮你理清核心逻辑，避开易错点，还会用像素游戏化动画直观展示算法流程！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（强连通分量SCC + 拓扑排序）

🗣️ **初步分析**：  
解决这道题的关键，是把“金属转化关系”抽象成**有向图**——每种金属是一个节点，转化配方是从该节点出发的两条有向边（比如金属i能生成R_i1和R_i2，就画i→R_i1和i→R_i2的边）。  
- **强连通分量（SCC）**：把图中“能互相转化的金属集合”缩成一个“超级节点”（比如金属A能转B，B能转A，就缩成一个点）。这样可以把原图简化成**有向无环图（DAG）**，方便后续处理。  
- **拓扑排序**：按DAG的依赖顺序（比如要生产C必须先有A和B，就先处理A、B再处理C）计算每个节点的金属数量，同时判断是否能“无限生产”。  

**核心算法流程**：  
1. 用Tarjan算法找所有SCC，缩点得到DAG；  
2. 对DAG做拓扑排序，递推每个节点的金属数量；  
3. 判断是否存在“能无限生产的节点”：如果某个SCC满足**①有原料输入**且**②内部能循环生成无限金属**（比如SCC不是单环，或有自环），则其后继节点（包括铅）都能无限生产。  

**可视化设计思路**：  
我会用**8位像素风**做一个“金属转化工厂”动画——  
- 用不同颜色的像素块表示金属节点，SCC用同色边框围起来；  
- Tarjan找SCC时，节点会“闪烁”并逐渐合并成超级节点；  
- 拓扑排序时，节点按顺序“点亮”，金属数量实时显示在像素块下方；  
- 若检测到无限生产，对应SCC会“持续闪烁”，伴随“叮——”的长音效，提示“UNBOUNDED”；  
- 交互面板有“单步执行”“自动播放”（像“贪吃蛇AI”逐步处理）、速度滑块，还有“重置工厂”按钮。


## 2. 精选优质题解参考

为大家筛选了**1份4.5星优质题解**（作者：zhuweiqi），它的亮点在于：  
- **思路严谨**：覆盖了“强连通分量判断无限”“自环处理”“原料存在性”等所有易错点；  
- **代码鲁棒**：用多个数组（`hav[]`记录是否有原料、`fg[]`标记非单环SCC）解决边界情况；  
- **多测处理**：清空数组的逻辑完整，适合竞赛中的多组输入场景。  


## 3. 核心难点辨析与解题策略

### 核心难点1：如何判断“无限生产”？  
**问题**：不是所有SCC都能无限生产——比如一个SCC是“单环”（A→B→C→A），用1克A只能生成1克B和1克C，无法无限；但如果SCC有**两个内部边**（比如A→A和A→B，B→A），就能无限生成。  
**解决**：判断SCC是否满足：①有原料输入（`hav[x]`为真）；②SCC不是单环（用`fg[x]`标记：若SCC内每个节点的两条边都在SCC内，则不是单环）。  

### 核心难点2：自环的处理？  
**问题**：如果一个金属i的配方是“i→i和i→j”（自环），单独的i是一个SCC，此时用1克i能无限生成i和j。  
**解决**：单独判断自环的SCC：若SCC大小为1且有自环，且有原料，则标记为无限生产。  

### 核心难点3：原料存在性的正确判断？  
**问题**：金属数量取模后可能变成0，但实际有原料（比如1e9 mod 1e9+7=1e9≠0，但如果是1e9+7则mod后为0）。  
**解决**：用布尔数组`hav[]`记录“该节点是否有原料”，而不是依赖`cnt[]`的数值——即使`cnt[x]`模后为0，只要原本有原料，`hav[x]`就为真。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
**说明**：综合题解思路，简化了部分变量名，保留核心逻辑（Tarjan缩点+拓扑排序）。  

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <queue>
#include <cstring>
using namespace std;

typedef long long ll;
const int N = 1e5 + 5;
const int MOD = 1e9 + 7;

vector<int> e[N];       // 原图边
int dfn[N], low[N], sd[N], siz[N]; // Tarjan用：时间戳、low值、所属SCC、SCC大小
ll cnt[N];              // 每个SCC的金属数量
bool ins[N], hav[N], fg[N], dh[N]; // ins: 是否在栈中；hav: 是否有原料；fg: 非单环SCC；dh: 是否有自环
stack<int> stk;
int num, tot;           // 时间戳、SCC总数

vector<int> dag_e[N];   // 缩点后的DAG边
int rd[N];              // DAG入度

// Tarjan算法找SCC
void Tarjan(int u) {
    dfn[u] = low[u] = ++num;
    stk.push(u); ins[u] = true;
    for (int v : e[u]) {
        if (!dfn[v]) {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (ins[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]) {
        tot++;
        int v;
        do {
            v = stk.top(); stk.pop();
            ins[v] = false;
            sd[v] = tot; // 节点v属于第tot个SCC
            siz[tot]++;
            cnt[tot] += a[v]; // a[v]是初始金属v的数量（需根据输入调整）
        } while (v != u);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T; cin >> T;
    while (T--) {
        int M; cin >> M;
        // 初始化所有数组
        memset(dfn, 0, sizeof(dfn)); memset(low, 0, sizeof(low));
        memset(sd, 0, sizeof(sd)); memset(siz, 0, sizeof(siz));
        memset(cnt, 0, sizeof(cnt)); memset(ins, 0, sizeof(ins));
        memset(hav, 0, sizeof(hav)); memset(fg, 0, sizeof(fg));
        memset(dh, 0, sizeof(dh)); memset(rd, 0, sizeof(rd));
        for (int i = 1; i <= M; i++) { e[i].clear(); dag_e[i].clear(); }
        num = tot = 0;

        // 读入配方
        for (int i = 1; i <= M; i++) {
            int x, y; cin >> x >> y;
            e[i].push_back(x); e[i].push_back(y);
            if (i == x || i == y) dh[i] = true; // 标记自环
        }

        // 读入初始金属数量（假设a数组已定义）
        for (int i = 1; i <= M; i++) cin >> a[i];

        // 找所有SCC
        for (int i = 1; i <= M; i++) if (!dfn[i]) Tarjan(i);

        // 构建DAG
        for (int u = 1; u <= M; u++) {
            for (int v : e[u]) {
                int su = sd[u], sv = sd[v];
                if (su != sv) {
                    dag_e[su].push_back(sv);
                    rd[sv]++;
                } else {
                    // 两条边都在SCC内 → 非单环
                    if (e[u][0] == su && e[u][1] == su) fg[su] = true;
                }
            }
        }

        // 拓扑排序
        queue<int> q;
        for (int i = 1; i <= tot; i++) {
            if (rd[i] == 0) q.push(i);
            hav[i] = (cnt[i] != 0); // 初始是否有原料
        }

        bool unbounded = false;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            // 判断是否无限生产
            if (hav[u] && (siz[u] > 1 && fg[u] || dh[u] && siz[u] == 1)) {
                if (sd[1] == u) { // 铅所在的SCC
                    unbounded = true;
                    break;
                }
                // 标记其后继为无限
                for (int v : dag_e[u]) cnt[v] = -1;
            }
            // 递推金属数量
            for (int v : dag_e[u]) {
                if (cnt[u] != -1) cnt[v] = (cnt[v] + cnt[u]) % MOD;
                hav[v] = hav[v] || hav[u];
                if (--rd[v] == 0) q.push(v);
            }
        }

        // 输出结果
        cout << "Case #" << ++cas << ": ";
        if (unbounded || cnt[sd[1]] == -1) cout << "UNBOUNDED\n";
        else cout << cnt[sd[1]] % MOD << "\n";
    }
    return 0;
}
```


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了题解的核心思路，简化了变量名，更易读。  
* **完整核心代码**：（见上一节）  
* **代码解读概要**：  
  1. **Tarjan缩点**：用栈记录当前路径，找每个节点的low值，合并SCC；  
  2. **构建DAG**：把原图的边转化为SCC之间的边；  
  3. **拓扑排序**：按入度为0的顺序处理节点，递推金属数量，判断无限生产；  
  4. **输出结果**：根据铅所在SCC的状态，输出UNBOUNDED或模后的值。  


### 题解核心片段赏析（作者：zhuweiqi）  
* **亮点**：用`hav[]`布尔数组解决原料存在性问题，避免取模后误判。  
* **核心代码片段**：  
  ```cpp
  // 拓扑排序中判断原料存在性
  hav[v] = hav[v] || hav[u];
  // 判断无限生产的条件
  if (hav[u] && (siz[u] > 1 && fg[u] || dh[u] && siz[u] == 1)) {
      cnt[v] = -1; // 标记为无限
  }
  ```
* **代码解读**：  
  - `hav[v] = hav[v] || hav[u]`：只要父节点有原料，子节点也“有原料”（不管数值是否被取模为0）；  
  - `siz[u] > 1 && fg[u]`：SCC大小>1且不是单环（能无限生产）；  
  - `dh[u] && siz[u] == 1`：单节点SCC且有自环（能无限生产）；  
  - 标记`cnt[v] = -1`：后续节点都视为无限。  
* **学习笔记**：**用布尔数组记录“存在性”**比依赖数值更可靠，尤其在取模场景下！


## 5. 算法可视化：像素动画演示

### 动画主题：金属转化工厂（8位像素风）  
**设计思路**：把金属转化比作“工厂流水线”，用像素元素降低理解门槛，用游戏化交互增加趣味性。  

### 动画帧步骤：  
1. **工厂初始化**：  
   - 屏幕左侧是“金属节点区”：用16x16的像素块表示金属，铅（节点1）是“金色”，其他节点是“银色”；  
   - 右侧是“控制面板”：有“单步”“自动”“重置”按钮，速度滑块（从“慢”到“快”），还有“金属数量显示器”；  
   - 背景播放8位风格的“工厂嗡嗡声”BGM（循环）。  

2. **Tarjan找SCC**：  
   - 点击“开始”，节点会“闪烁”（每秒2次），表示正在遍历；  
   - 找到SCC后，节点会“合并”成一个大像素块（比如32x32），边框颜色对应SCC编号；  
   - 合并时播放“咔嗒”音效，提示“缩点完成”。  

3. **拓扑排序生产**：  
   - 入度为0的SCC会“点亮”（颜色变亮），表示开始处理；  
   - 金属数量会“跳动”显示在像素块下方（比如从“10”跳到“20”），伴随“滴”的短音效；  
   - 若检测到无限生产，对应SCC会“快速闪烁”，显示器弹出“UNBOUNDED”，同时播放“叮——”的胜利音效，BGM变欢快。  

4. **交互设计**：  
   - “单步”：点击一次处理一个节点，适合仔细观察；  
   - “自动”：像“贪吃蛇AI”一样自动处理，速度可通过滑块调整（最慢1秒/步，最快0.1秒/步）；  
   - “重置”：工厂回到初始状态，所有节点恢复原样，方便重新演示。  


## 6. 拓展练习与相似问题

### 通用思路迁移  
本题的“缩点+拓扑排序”思路可用于：  
- **流程优化**：比如工厂流水线的依赖顺序；  
- **资源分配**：比如游戏中道具的合成路径；  
- **无限循环检测**：比如程序中的死循环判断。  

### 洛谷练习推荐  
1. **P3387 【模板】缩点**：练习Tarjan缩点的基础题；  
2. **P4017 最大食物链计数**：拓扑排序的经典应用，计算路径数量；  
3. **P1113 杂务处理**：拓扑排序处理任务依赖，求最短时间；  
4. **P2880 [USACO07JAN] Balanced Lineup G**：虽然是RMQ问题，但可练习“将问题抽象为DAG”的思维。  


## 7. 学习心得与经验分享

题解作者提到的**3个易错点**非常值得借鉴：  
1. **不要用数值判断原料存在**：取模后1e9会变成1e9，但1e9+7会变成0，所以必须用`hav[]`布尔数组；  
2. **SCC的“无限条件”是充要的**：不是所有SCC都能无限，必须满足“有原料+非单环/自环”；  
3. **多测一定要清空数组**：竞赛中常因“数组没清干净”WA，题解用`memset`和循环清空所有数组，值得学习！  


## 总结  
这道题的核心是“将问题抽象为图，用缩点简化，拓扑递推”。通过这道题，你能掌握**强连通分量**和**拓扑排序**的实战用法，还能学会处理“无限性”“边界条件”等竞赛常见问题。  

记住：**图论的关键是“抽象”——把现实问题转化为节点和边，再用算法解决**！下次遇到“依赖关系”“循环生产”的问题，试试用今天学的思路吧！💪  

下次我们再一起探索更有趣的编程挑战！

---
处理用时：99.48秒
# 题目信息

# 『MdOI R2』Odyssey

## 题目背景

超越音速的极限，不及瑰丽多变的极光；

微弱的脉冲，开拓原本一片混沌的天地；

沉郁的蓝缓缓闪动，史诗的红迎接巅峰；

血色的夕阳尽头，是将夜的星辰；

夜半的满天星空，也会被来自地狱的硝烟掩盖；

炽红炼狱消逝，只金色遗迹永存。

在这里等待着每一位的，都是一段艰苦而璀璨的旅程。

## 题目描述

若正整数 $a$ 与 $b$ 满足：

- $a$ 与 $b$ 的积是一个正整数的 $k$ 次方，即存在正整数 $c$ 使得 $ab=c^k$。

那么我们称 $(a,b)$ 为一组**完美数对**。

---

有一个包含 $n$ 个结点和 $m$ 条边的**有向无环图**，这张图中的每条边都有权值和长度两个属性。

如果一条路径 $P$ 满足**以下条件之一**，则称其为一条**完美路径**：

- $P$ 中仅包含一条边。

- $P$ 从其起点开始依次为 $e_1, e_2, e_3, \ldots e_p$ 这 $p\ (p\ge 2)$ 条边，对于任意的 $1\leq i\leq p-1$，$e_i$ 的权值和 $e_{i+1}$ 的权值组成完美数对。

你需要求出图中最长完美路径的长度，一条路径的长度定义为这条路径上所有边的长度之和。

## 说明/提示

【帮助与提示】  

为方便选手测试代码，本题额外提供两组附加样例供选手使用。  

[样例输入1](https://www.luogu.com.cn/paste/wx1lz6m2) [样例输出1](https://www.luogu.com.cn/paste/28xe7f0x)      

[样例输入2](https://www.luogu.com.cn/paste/efgwngs5) [样例输出2](https://www.luogu.com.cn/paste/5hcpoayt)   

----

【样例解释】

样例中给出的有向无环图如图所示，其中边上的红色数字为边的权值，黑色数字为边的长度：

![](https://cdn.luogu.com.cn/upload/image_hosting/w6x03ksd.png)

最长完美路径为 $2\to 5\to 3$，因为这两条边的权值 $2$ 和 $18$ 满足 $2\times 18=6^2$，是完美数对，此路径长度为 $5+9=14$。

此外，$2\to 1\to 4\to 3,\ \ 2\to 4\to 3,\ \ 1\to 5\to 3$ 等也是完美路径，但不是最长的。

图中，$2\to 1\to 5\to 3$ 长度为 $15$，是一条更长的路径，但它并不是完美路径，因为前两个边权 $24$ 和 $8$ 的乘积为 $192$，不是正整数的平方，即 $(24,8)$ 不是完美数对。

---

【数据范围】

**本题采用捆绑测试。**

对于 $100\%$ 的数据：$1\leq n\leq 10^5,\ \ 1\leq m\leq 2\times 10^5,\ \ 1\leq k\leq 10,\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^5,\ \ 1\leq l\leq 10^4$。

给出的图**不保证弱连通**，图中从一个点到另一个点**可能**存在多条边，但保证给出的图是有向无环图。

| 子任务编号 | $n\leq$ |     $m\leq$      | $w\leq$ | $k\leq$ |  特殊性质  | 分值 |
| :--------: | :-----: | :--------------: | :-----: | :-----: | :--------: | :--: |
| Subtask 1  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $1$   |     无     | $18$ |
| Subtask 2  |  $10$   |       $10$       |  $100$  |  $2$   |     无     | $12$ |
| Subtask 3  |  $600$  | $1.5\times 10^3$ | $10^3$  |   $2$   |     无     | $10$ |
| Subtask 4  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   | $w$ 为素数 | $15$ |
| Subtask 5  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   |     无     | $15$ |
| Subtask 6  |  $600$  | $1.5\times 10^3$ | $10^3$  |  $5$   |     无     | $10$ |
| Subtask 7  | $10^5$  |  $2\times 10^5$  | $10^5$  |  $10$   |     无     | $20$ |



## 样例 #1

### 输入

```
5 7 2
2 5 2 5
5 3 18 9
2 4 6 7
4 3 6 3
2 1 24 2
1 4 6 8
1 5 8 4```

### 输出

```
14```

# AI分析结果



---
# 💡 Kay的C++算法解析：『MdOI R2』Odyssey 深入学习指南 💡

<introduction>
今天我们来一起分析“『MdOI R2』Odyssey”这道题。它结合了数论、图论和动态规划的知识，需要我们找到有向无环图中最长的“完美路径”。通过这份指南，你将理解核心思路、关键算法，并掌握解题技巧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（DAG最长路径） + 数论（质因数分解） + 动态规划（状态转移）`

🗣️ **初步分析**：
解决这道题的关键在于理解“完美数对”的数学性质，并结合DAG的拓扑排序高效计算最长路径。  
简单来说，“完美数对” $(a,b)$ 要求 $ab$ 是 $k$ 次方数。根据质因数分解的唯一性，我们可以将每个数的质因数指数对 $k$ 取模，得到一个“简化形式”。例如，当 $k=2$ 时，$18=2^1 \times 3^2$ 简化为 $2^1$（因为 $3^2$ 模2为0），而能与之配对的数必须是 $2^1$（因为 $1+1=2$ 是2的倍数），如 $2$。

核心思路是：  
1. **预处理边权**：将每条边的权值分解质因数，指数模 $k$ 得到“简化形式”，并计算其互补形式（即能与之配对的边权的简化形式）。  
2. **动态规划 + 拓扑排序**：在DAG上，用动态规划维护每个节点在特定简化形式下的最长路径长度，通过拓扑排序依次处理节点，更新状态。

可视化设计思路：用8位像素风格展示质因数分解过程（如像素方块代表质数，指数用数字标记），动态演示互补边权的匹配（如两个方块颜色配对），并在拓扑排序中用箭头表示状态转移（颜色高亮当前处理的边和节点）。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性和算法有效性的评估，以下题解质量突出（≥4星）：
</eval_intro>

**题解一：作者 BFqwq**  
* **点评**：此题解思路清晰，通过质因数分解预处理边权，并巧妙利用分层图拓扑排序处理状态转移。代码规范（如变量名`f`表示互补边权），对边界条件（如互补边权超过值域时的处理）考虑严谨。亮点在于分层图的设计，避免了状态冲突，时间复杂度优化得当。

**题解二：作者 一扶苏一**  
* **点评**：此题解采用双模数哈希存储简化形式，避免了质因数分解后的状态爆炸。代码结构工整（如模块化的`Init`、`Topo_sort`函数），动态规划的状态转移逻辑明确。亮点是哈希的应用，提升了状态查询效率。

**题解三：作者 under_the_time**  
* **点评**：此题解直接使用`map`存储状态，代码简洁易懂。对质因数分解和互补边权的计算逻辑解释清晰，特别处理了 $k=1$ 的情况（此时所有边权都可配对）。亮点是状态定义简单（`f[i][j]`表示节点i在边权j下的最长路径），适合新手理解。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题时，以下三个关键点需要重点突破：
</difficulty_intro>

1.  **关键点1：如何定义“简化形式”？**  
    * **分析**：将边权分解质因数后，每个质数的指数对 $k$ 取模，得到简化形式。例如，$w=18$（$k=2$）分解为 $2^1 \times 3^2$，模2后为 $2^1$。这样，互补形式就是每个质数的指数为 $k - (当前指数 \bmod k)$，即 $2^1$（因为 $2-1=1$）。  
    * 💡 **学习笔记**：简化形式是连接数论与图论的桥梁，确保了状态的唯一性。

2.  **关键点2：如何高效处理状态转移？**  
    * **分析**：由于DAG无环，可按拓扑序处理节点。对于每个节点 $u$ 的出边，其互补形式对应的状态值会传递到下一个节点 $v$ 的简化形式状态中。例如，若边权简化为 $a$，互补形式为 $b$，则 $v$ 的 $a$ 状态值由 $u$ 的 $b$ 状态值加边长度更新。  
    * 💡 **学习笔记**：拓扑排序保证了状态转移的顺序，避免重复计算。

3.  **关键点3：如何处理大范围状态？**  
    * **分析**：简化形式可能很多（如质数组合多），直接用数组存储不现实。优质题解中使用`map`或哈希表存储状态（如`map<int, int> f[N]`），按需存储，节省空间。  
    * 💡 **学习笔记**：灵活选择数据结构（如`map`）是处理稀疏状态的关键。

### ✨ 解题技巧总结
- **问题分解**：将问题拆分为数论预处理（简化形式）和图论求解（最长路径）两部分。  
- **状态压缩**：用质因数指数模 $k$ 简化状态，减少计算量。  
- **拓扑排序优化**：利用DAG的无环性，按拓扑序处理节点，确保动态规划的正确性。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，提炼出一个通用的核心实现，帮助大家快速理解整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了BFqwq和under_the_time的思路，包含质因数分解、互补边权计算和拓扑排序动态规划。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 1e5 + 5;
    const int MAXW = 1e5;

    struct Edge {
        int to, l;
        int simplified; // 简化形式
        int complement;   // 互补形式
    };

    vector<Edge> adj[MAXN];
    int in_degree[MAXN];
    unordered_map<int, int> dp[MAXN]; // dp[u][s] 表示节点u在简化形式s下的最长路径
    int n, m, k;
    int ans = 0;

    // 计算简化形式和互补形式
    void process_w(int w, int& simplified, int& complement) {
        simplified = 1;
        complement = 1;
        for (int i = 2; i * i <= w; ++i) {
            if (w % i == 0) {
                int cnt = 0;
                while (w % i == 0) {
                    w /= i;
                    cnt++;
                }
                cnt %= k;
                if (cnt == 0) continue;
                // 计算简化形式：i^cnt
                for (int j = 0; j < cnt; ++j) simplified *= i;
                // 计算互补形式：i^(k - cnt)
                for (int j = 0; j < k - cnt; ++j) {
                    complement *= i;
                    if (complement > MAXW) { // 互补形式超出值域，无法配对
                        complement = -1;
                        return;
                    }
                }
            }
        }
        if (w > 1) {
            if (k != 1) simplified *= w;
            // 处理剩余大质数的互补形式
            for (int j = 0; j < k - 1; ++j) {
                complement *= w;
                if (complement > MAXW) {
                    complement = -1;
                    return;
                }
            }
        }
    }

    void topo_sort() {
        queue<int> q;
        for (int i = 1; i <= n; ++i) {
            if (in_degree[i] == 0) q.push(i);
        }
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (Edge& e : adj[u]) {
                int v = e.to;
                int s = e.simplified;
                int c = e.complement;
                // 更新v的s状态：取u的c状态值 + 边长度，或当前最大值
                int new_val = (c == -1 ? e.l : dp[u][c] + e.l);
                dp[v][s] = max(dp[v][s], new_val);
                ans = max(ans, dp[v][s]);
                if (--in_degree[v] == 0) q.push(v);
            }
        }
    }

    int main() {
        cin >> n >> m >> k;
        for (int i = 0; i < m; ++i) {
            int u, v, w, l;
            cin >> u >> v >> w >> l;
            int s, c;
            process_w(w, s, c);
            adj[u].push_back({v, l, s, c});
            in_degree[v]++;
        }
        topo_sort();
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先预处理每条边的简化形式和互补形式（`process_w`函数），然后通过拓扑排序（`topo_sort`函数）处理每个节点，动态规划更新每个节点在不同简化形式下的最长路径（`dp`数组），最终输出最大值。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段，学习其中的巧妙设计。
</code_intro_selected>

**题解一：作者 BFqwq（分层图拓扑排序）**
* **亮点**：通过分层图（节点+编号）避免状态冲突，适合处理大规模数据。
* **核心代码片段**：
    ```cpp
    void topo(int w) {
        // 初始化队列和入度
        while (!q.empty()) q.pop();
        for (edge v : g[w]) {
            in[v.to + n]++;
            add(v.from, v.to + n, v.lg);
        }
        // 拓扑排序并更新dp
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int i = h[u]; i; i = e[i].nxt) {
                int v = e[i].to, l = e[i].lg;
                dp[v] = max(dp[v], dp[u] + l);
                ans = max(ans, dp[v]);
                in[v]--; if (!in[v]) q.push(v);
            }
        }
    }
    ```
* **代码解读**：  
  分层图将节点分为两部分（原节点和`节点+n`），分别处理简化形式和互补形式的边。通过`add`函数建图，拓扑排序时依次处理节点，更新`dp`数组。这种设计避免了状态重叠，确保了转移的正确性。  
* 💡 **学习笔记**：分层图是处理多状态转移的有效方法，尤其适合状态间有明确互补关系的场景。

**题解二：作者 under_the_time（map存储状态）**
* **亮点**：使用`map`存储稀疏状态，代码简洁，适合状态数不确定的情况。
* **核心代码片段**：
    ```cpp
    unordered_map<int, int> mp[MAXN]; // mp[u][s] 表示节点u在简化形式s下的最长路径
    void topo() {
        queue<int> q;
        for (int i = 1; i <= n; ++i) if (in_degree[i] == 0) q.push(i);
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (Edge& e : adj[u]) {
                int v = e.to, s = e.simplified, c = e.complement;
                mp[v][s] = max(mp[v][s], mp[u][c] + e.l);
                ans = max(ans, mp[v][s]);
                if (--in_degree[v] == 0) q.push(v);
            }
        }
    }
    ```
* **代码解读**：  
  `mp[u][c]`表示节点`u`在互补形式`c`下的最长路径，转移时更新节点`v`的简化形式`s`状态。`map`自动处理了状态的增删，无需预分配空间，适合稀疏状态。  
* 💡 **学习笔记**：`map`是处理稀疏状态的“瑞士军刀”，但需注意查询时间（可改用`unordered_map`优化）。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了直观理解质因数分解和状态转移，我们设计一个“像素探险”动画，用8位风格展示算法过程！
\</visualization_intro\>

  * **动画演示主题**：`像素探险：寻找完美路径`

  * **核心演示内容**：  
    从起点出发，每条边的权值分解为质因数像素块（如红色块代表2，蓝色块代表3），指数用数字标记。当两条边的质因数块互补（指数和为k）时，它们会发出金光并连接，形成完美路径。动态展示拓扑排序中节点的处理顺序，以及`dp`状态的更新（如数字变大）。

  * **设计思路简述**：  
    8位像素风格（FC游戏画面）降低学习门槛；质因数块的颜色和闪烁突出关键操作；音效（如“叮”声）强化记忆；自动播放模式模拟算法执行，帮助观察全局流程。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕左侧展示DAG（节点为圆形像素，边为箭头），右侧展示质因数分解区（像素块堆叠）。  
        - 控制面板包含“单步”“自动播放”“调速”按钮（8位风格按钮）。

    2.  **质因数分解演示**：  
        - 点击某条边，权值分解为质因数块（如`18`分解为2（红）和3（蓝）），指数模k后显示（如k=2时，3的指数2模2为0，消失）。  
        - 互补形式计算：剩余块的指数变为k - 当前指数（如2的指数1变为1，互补形式也是2的1次方）。

    3.  **拓扑排序与状态转移**：  
        - 节点按拓扑序变绿，处理其出边时，边闪烁并显示简化形式。  
        - 下一个节点的`dp`状态值（如数字）根据当前节点的互补状态值更新（如从5变为5+边长度），数字变大并伴随“叮”声。

    4.  **目标达成**：  
        - 最长路径找到时，路径上的边和节点闪烁金色，播放胜利音效（如8位升调）。

  * **旁白提示**：  
    - “看！这条边的权值分解后，红色块（2）的指数是1，模2后还是1。”  
    - “互补形式需要另一条边的2的指数是1（2-1=1），所以它们可以配对！”  
    - “当前节点处理完毕，下一个节点的最长路径更新为14，这是目前的最大值！”

\<visualization_conclusion\>
通过这个动画，你可以直观看到质因数分解如何影响边的连接，以及拓扑排序中状态是如何一步步更新的。
\</visualization_conclusion\>

-----

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
掌握本题后，以下题目能帮助你巩固数论与DAG结合的解题技巧：
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：  
    本题的核心技巧（质因数分解简化状态 + DAG动态规划）可用于：  
    1. 求DAG中满足特定数论条件的最长/最短路径（如相邻边权和为质数）。  
    2. 处理需要状态压缩的图论问题（如状态由多个参数决定，需简化存储）。  
    3. 涉及模运算的路径问题（如相邻边权模k相等）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4017 最大食物链计数**  
        * 🗣️ **推荐理由**：DAG上的动态规划，练习状态转移与拓扑排序，适合巩固基础。
    2.  **洛谷 P1080 国王游戏**  
        * 🗣️ **推荐理由**：涉及数论（大数处理）与贪心策略，提升综合解题能力。
    3.  **洛谷 P3376 网络流模板题**  
        * 🗣️ **推荐理由**：图论综合应用，理解网络流模型，为复杂图论问题打基础。

-----

## 7\. 学习心得与经验分享 (若有)

\<insights_intro\>
部分题解作者分享了调试经验，这些经验对我们很有启发：
\</insights_intro\>

> **参考经验 (来自 BFqwq)**：“在分层图拓扑时，若互补边权超过值域（如`res2*pri[i]>lim`），需要及时返回，否则会爆`long long`。最初我因数组开小导致错误，后来发现需要双倍数组存储分层节点。”

> **点评**：BFqwq的经验提醒我们，在处理大数（如质因数乘积）时，必须检查是否超出值域，避免溢出。同时，分层图的节点数可能翻倍，数组大小需提前计算，这是竞赛中常见的边界问题。

-----

\<conclusion\>
通过对“『MdOI R2』Odyssey”的分析，我们掌握了数论简化状态、DAG拓扑排序与动态规划的结合应用。记住，遇到复杂问题时，分解步骤（数论预处理+图论求解）和选择合适数据结构（如`map`）是关键。希望你能在练习中灵活运用这些技巧，挑战更多难题！💪
\</conclusion\>

---
处理用时：174.86秒
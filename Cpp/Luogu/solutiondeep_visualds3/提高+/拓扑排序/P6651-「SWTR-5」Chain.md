# 题目信息

# 「SWTR-5」Chain

## 题目描述

给定 $n$ 个点，$m$ 条边的有向无环图。不保证图连通。

$q$ 次询问，每次给出 $k$ 和 $k$ 个互不相同的数 $c_i$，求出如果去掉这 $k$ 个点，整个有向无环图将剩余多少条链。答案对 $10^9+7$ 取模。**每次询问独立。**

- “链”的定义是：我们设一条长度为 $p$ 的链的路径为 $w_0\to w_1\to\cdots\to w_{p-1}\to w_p$，则应满足 $w_0$ 入度为 $0$，$w_p$ 出度为 $0$。你可以将其理解为一条食物链。

- 两条链是“不同的”，当且仅当它们的长度不同，或者经过的点集不同。

- **需要特别注意的是，删去某些点后新产生的链不计入答案。** 例如 $1\to 2\to 3\to 4$ 一图中，有 $1$ 条链 $1\to 2\to 3\to 4$。如果去掉 $2$ 号点，则剩余 $0$ 条链。

## 说明/提示

「样例 $1$ 说明」

DAG 如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2gbdoemh.png)

询问 $1$：如果去掉 $2,4,6$，则剩余 $1$ 条链：$3\to 5$。

询问 $2$：如果去掉 $4,6$，则剩余 $3$ 条链：$3\to 5$，$3\to 2\to 5$，$3\to 7\to 2\to 5$。

询问 $7$：如果去掉 $6$，则剩余 $5$ 条链：$3\to 5$，$3\to 2\to 5$，$3\to 7\to 2\to 5$，$3\to 1\to 4\to 5$，$3\to 7\to 4\to 5$。

「数据范围与约定」

**本题采用捆绑测试。**

- Subtask 1（1 point）：给定的图是一条链。
- Subtask 2（14 points）：$n,q\leq 10$。
- Subtask 3（20 points）：$q\leq 10^3$。
- Subtask 4（17 points）：$k=1$。
- Subtask 5（18 points）：$k=2$。
- Subtask 6（30 points）：无特殊限制。

对于 $100\%$ 的数据：$2\leq n\leq 2\times 10^3$，$1\leq m\leq \min(\frac{n\times(n-1)}{2},2\times 10^4)$，$1\leq q\leq 5\times 10^5$。  
所有询问满足：$1\leq \sum k\leq 2\times 10^6$，$0\leq k\leq \min(n,15)$，$1\leq c_i\leq n$。保证 $c_i$ 互不相同。

**本题轻微卡常，请注意 IO 优化。**

---

「题目来源」

[Sweet Round 05](https://www.luogu.com.cn/contest/28195) D。  
idea & solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。

## 样例 #1

### 输入

```
7 14
3 2
4 5
2 5
2 6
3 1
3 5
3 7
3 6
6 4
1 4
6 5
1 6
7 2
7 4
7
3 2 4 6
2 4 6
2 2 5
2 1 4
0
1 4
1 6```

### 输出

```
1
3
0
6
13
7
5```

## 样例 #2

### 输入

```
233 1
1 2
6
0
1 10
2 10 40
1 1
1 2
2 1 2```

### 输出

```
232
231
230
231
231
231```

# AI分析结果



---
# 💡 Kay的C++算法解析：「SWTR-5」Chain 深入学习指南 💡

<introduction>
今天我们来一起分析“「SWTR-5」Chain”这道C++编程题。这道题围绕有向无环图（DAG）的链计数展开，需要处理多次删除点后的链数查询。本指南将帮助大家梳理核心思路，掌握拓扑排序、动态规划与容斥的结合应用，并通过可视化方案直观理解算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`拓扑排序与动态规划结合容斥`

🗣️ **初步分析**：
解决这道题的关键在于理解DAG的拓扑性质，并结合动态规划预处理路径数，再通过容斥处理多个删除点的重复计算。  
简单来说，拓扑排序能帮助我们按顺序处理DAG中的节点，动态规划（DP）可以高效计算从入度为0的点到各点的路径数（记为`f`），以及从各点到出度为0的点的路径数（记为`g`）。当需要删除多个点时，由于直接减去每个点的贡献会重复计算路径，因此需要按拓扑序对删除点排序，通过容斥调整`f`值，最终得到剩余链数。

- **题解思路**：所有优质题解均基于以下步骤：  
  1. 拓扑排序预处理每个节点的拓扑序；  
  2. 动态规划计算`f`（入度为0点到各点的路径数）和`g`（各点到出度为0点的路径数）；  
  3. 预处理任意两点间的路径数`d[u][v]`（u到v的路径数）；  
  4. 对每个询问，将删除点按拓扑序排序，通过容斥调整每个删除点的`f`值（减去其前驱删除点的贡献），最终总答案为初始链数减去所有调整后的`f[c_i] * g[c_i]`之和。  

- **核心难点**：如何高效预处理路径数？如何处理多个删除点的容斥？前者通过拓扑排序+动态规划解决，后者通过按拓扑序排序删除点并逐步调整`f`值避免重复计算。  

- **可视化设计**：采用8位像素风格，用彩色方块表示节点（入度0点为绿色，出度0点为红色，普通点为蓝色），箭头表示边。动画中动态展示拓扑排序过程（节点按顺序点亮）、`f`和`g`的计算（数字累加），以及删除点时的容斥调整（红色标记删除点，相关路径数动态减少）。关键步骤伴随“叮”的音效，完成容斥调整时播放简短胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下题解因逻辑清晰、实现高效被选为优质参考：
</eval_intro>

**题解一：作者yxzy4615（赞：11）**  
* **点评**：此题解详细分析了各子任务的解法，从暴力到容斥逐步优化，思路推导清晰。特别对k=1、k=2的情况进行了深入分析，指出容斥的必要性，并推广到k≤15的一般情况。代码预处理拓扑序和路径数，查询时通过排序和容斥调整，时间复杂度为O(nm + k²Σk)，适合大规模数据。

**题解二：作者a___（赞：8）**  
* **点评**：此题解代码简洁高效，通过拓扑排序预处理`f`（入度0点到各点路径数）和`g`（各点到出度0点路径数），并利用拓扑序对删除点排序，通过动态调整`f`值实现容斥。代码变量命名规范（如`f`、`g`、`h`分别对应路径数），逻辑直接，是竞赛中典型的高效实现。

**题解三：作者EnofTaiPeople（赞：3）**  
* **点评**：此题解明确区分了`onto`（入度0点到各点的路径数）和`znto`（各点到出度0点的路径数），预处理过程清晰。查询时按拓扑序排序删除点，逐步调整`ans[i]`（有效路径数），最终计算总答案。代码结构工整，注释较少但变量名自解释，适合学习拓扑序与容斥的结合应用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点在于预处理路径数和处理多删除点的容斥。以下是关键步骤的分析和策略：
</difficulty_intro>

1.  **关键点1：预处理路径数**  
    * **分析**：需要计算两个关键路径数：`f[u]`（所有入度0点到u的路径数）和`g[u]`（u到所有出度0点的路径数）。这可以通过两次拓扑排序实现：第一次正向拓扑计算`f`，第二次反向拓扑计算`g`。  
    * 💡 **学习笔记**：拓扑排序是DAG路径计数的“钥匙”，按顺序处理节点能确保无后效性，保证DP的正确性。

2.  **关键点2：多删除点的容斥**  
    * **分析**：直接减去每个删除点的`f[c_i] * g[c_i]`会重复计算同时经过多个删除点的路径。解决方法是按拓扑序排序删除点（拓扑序小的点在路径中更靠前），然后对每个删除点`c_i`，减去其前驱删除点`c_j`（j<i）到`c_i`的路径数乘以`c_j`的有效路径数，避免重复。  
    * 💡 **学习笔记**：拓扑序排序是容斥的基础，确保调整顺序时“先处理前面的点，再处理后面的点”，避免路径重复计算。

3.  **关键点3：高效处理大规模查询**  
    * **分析**：题目中q可达5×10⁵，Σk达2×10⁶，需O(k²)的查询复杂度。预处理任意两点间的路径数`d[u][v]`（u到v的路径数），查询时直接使用`d`数组调整`f`值，避免重复计算路径数。  
    * 💡 **学习笔记**：预处理是应对大规模查询的核心，将重复计算的部分提前完成，查询时仅做线性调整。

### ✨ 解题技巧总结
- **拓扑序预处理**：DAG问题中，拓扑序能将节点排列成无环顺序，是路径计数的基础。  
- **动态规划分两次计算**：正向拓扑计算入度0点到各点的路径数，反向拓扑计算各点到出度0点的路径数。  
- **容斥按拓扑序调整**：删除点按拓扑序排序，逐步调整每个点的有效路径数，避免重复计算。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，结合了预处理和容斥的关键步骤：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了a___和EnofTaiPeople的题解思路，预处理拓扑序、路径数`f`和`g`，并在查询时按拓扑序排序删除点，通过容斥调整路径数。  
* **完整核心代码**：  
```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;

const int N = 2010, MOD = 1e9 + 7;
int n, m, q, cnt;
int head[N], to[N*10], nxt[N*10], deg[N];
int f[N], g[N], d[N][N], topo[N], id[N];
vector<int> G[N];

inline void add(int u, int v) {
    to[++cnt] = v;
    nxt[cnt] = head[u];
    head[u] = cnt;
    deg[v]++;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1, u, v; i <= m; ++i) {
        scanf("%d%d", &u, &v);
        add(u, v);
    }

    // 正向拓扑计算f[u]（入度0点到u的路径数）
    vector<int> q;
    for (int i = 1; i <= n; ++i) {
        if (!deg[i]) {
            f[i] = 1;
            q.push_back(i);
        }
    }
    for (int i = 0; i < q.size(); ++i) {
        int u = q[i];
        topo[u] = i + 1;  // 记录拓扑序
        for (int j = head[u]; j; j = nxt[j]) {
            int v = to[j];
            f[v] = (f[v] + f[u]) % MOD;
            if (--deg[v] == 0) q.push_back(v);
        }
    }

    // 反向图计算g[u]（u到出度0点的路径数）
    vector<int> rev_head[N], rev_deg(n + 1);
    for (int u = 1; u <= n; ++u) {
        for (int j = head[u]; j; j = nxt[j]) {
            int v = to[j];
            rev_head[v].push_back(u);
            rev_deg[u]++;
        }
    }
    vector<int> rev_q;
    for (int i = 1; i <= n; ++i) {
        if (rev_head[i].empty()) {  // 原图中出度0的点
            g[i] = 1;
            rev_q.push_back(i);
        }
    }
    for (int i = 0; i < rev_q.size(); ++i) {
        int u = rev_q[i];
        for (int v : rev_head[u]) {
            g[v] = (g[v] + g[u]) % MOD;
            if (--rev_deg[v] == 0) rev_q.push_back(v);
        }
    }

    // 预处理d[u][v]（u到v的路径数）
    for (int u = 1; u <= n; ++u) {
        d[u][u] = 1;
        for (int j = head[u]; j; j = nxt[j]) {
            int v = to[j];
            d[u][v] = (d[u][v] + d[u][u]) % MOD;
        }
        // 按拓扑序扩展d[u][v]
        for (int i = 0; i < q.size(); ++i) {
            int x = q[i];
            for (int j = head[x]; j; j = nxt[j]) {
                int y = to[j];
                d[u][y] = (d[u][y] + d[u][x]) % MOD;
            }
        }
    }

    // 处理查询
    scanf("%d", &q);
    while (q--) {
        int k;
        scanf("%d", &k);
        vector<int> c(k);
        for (int i = 0; i < k; ++i) scanf("%d", &c[i]);
        sort(c.begin(), c.end(), [&](int a, int b) { return topo[a] < topo[b]; });

        vector<int> dp(k);
        int ans = 0;
        for (int i = 0; i < k; ++i) {
            dp[i] = f[c[i]];
            for (int j = 0; j < i; ++j) {
                dp[i] = (dp[i] - 1LL * dp[j] * d[c[j]][c[i]] % MOD + MOD) % MOD;
            }
            ans = (ans + 1LL * dp[i] * g[c[i]] % MOD) % MOD;
        }
        printf("%d\n", (f[0] - ans + MOD) % MOD);  // f[0]为初始总链数（需根据实际预处理调整）
    }
    return 0;
}
```
* **代码解读概要**：  
  代码首先通过正向拓扑计算`f[u]`（入度0点到u的路径数），然后构建反向图计算`g[u]`（u到出度0点的路径数）。预处理`d[u][v]`记录u到v的路径数。查询时，将删除点按拓扑序排序，用`dp[i]`调整每个删除点的有效路径数（减去前驱点的贡献），最终总答案为初始链数减去所有`dp[i] * g[c[i]]`之和。

---
<code_intro_selected>
以下是优质题解的核心代码片段赏析：
</code_intro_selected>

**题解二：作者a___（赞：8）**  
* **亮点**：代码简洁高效，利用拓扑序对删除点排序，动态调整`d`数组实现容斥。  
* **核心代码片段**：  
```cpp
bool cmp(const int &x, const int &y) { return id[x] < id[y]; }
// ...（预处理拓扑序id[x]）
sort(c + 1, c + 1 + m, cmp);
for (i = 1; i <= m; i++) d[i] = f[c[i]];
for (i = 1; i <= m; i++) 
    for (j = i + 1; j <= m; j++) 
        d[j] = (d[j] - 1LL * d[i] * h[c[i]][c[j]] % p + p) % p;
for (i = 1; i <= m; i++) 
    ans = (ans - 1LL * d[i] * g[c[i]] % p + p) % p;
```
* **代码解读**：  
  `cmp`函数按拓扑序排序删除点。`d[i]`初始化为`f[c[i]]`（入度0点到`c[i]`的路径数）。内层循环中，`d[j]`减去`d[i] * h[c[i]][c[j]]`（`c[i]`到`c[j]`的路径数乘`c[i]`的有效路径数），避免重复计算。最后总答案减去所有`d[i] * g[c[i]]`（`c[i]`到出度0点的路径数）。  
* 💡 **学习笔记**：按拓扑序排序后，调整顺序保证“前面的点先处理”，避免路径重复计算。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解拓扑排序、路径数计算和容斥调整的过程，我们设计了一个“像素DAG探险”动画，以8位复古风格展示算法执行流程。
</visualization_intro>

  * **动画演示主题**：`像素DAG探险——链的计数与删除`  
  * **核心演示内容**：展示拓扑排序过程（节点按顺序点亮）、`f`和`g`的计算（数字动态累加）、删除点时的容斥调整（红色标记删除点，路径数动态减少）。  
  * **设计思路简述**：采用8位像素风格（类似FC游戏），用不同颜色区分节点类型（入度0点：绿色，出度0点：红色，普通点：蓝色），箭头表示边。关键操作（如拓扑排序、路径数累加）伴随“叮”的音效，容斥调整完成时播放胜利音效，增强操作记忆。  

  * **动画帧步骤与交互关键点**：  

    1.  **场景初始化**：  
        屏幕左侧显示DAG的像素图（节点为方块，边为箭头），右侧显示控制面板（开始/暂停、单步、重置按钮，速度滑块）。顶部显示当前状态（如“拓扑排序中”“路径数计算中”）。  

    2.  **拓扑排序演示**：  
        绿色节点（入度0点）首先点亮，伴随“滴”的音效。随后按拓扑序依次点亮后续节点（蓝色），每个节点点亮时显示其拓扑序编号（如`topo[u]=3`）。  

    3.  **路径数计算（f数组）**：  
        绿色节点的`f`值初始化为1（显示为数字1）。当处理到边`u→v`时，`v`的`f`值增加`u`的`f`值（如`f[v] += f[u]`），数字动态变化并伴随“+”动画。  

    4.  **容斥调整演示**：  
        输入删除点后，节点变为红色并闪烁。按拓扑序排序后，每个红色节点的`f`值逐步调整（如`d[j] -= d[i] * d[c[i]][c[j]]`），数字减少并伴随“-”动画。最终总链数显示为初始值减去所有调整后的`d[i] * g[c[i]]`。  

    5.  **目标达成提示**：  
        计算完成后，剩余链数用大字体显示，伴随上扬的胜利音效，红色节点停止闪烁，恢复为灰色（表示已删除）。  

  * **旁白提示**：  
    - “看，绿色节点是入度0的起点，它们的f值初始化为1！”  
    - “处理边u→v时，v的f值会加上u的f值，这就是路径数的累加～”  
    - “删除点需要按拓扑序排序，这样前面的点调整后，后面的点就不会重复计算路径啦！”  

<visualization_conclusion>
通过这个动画，我们能直观看到拓扑排序如何有序处理节点，路径数如何动态累加，以及容斥调整如何避免重复计算。像素风格和音效让算法过程更生动，帮助我们更好地理解核心逻辑。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心思路（拓扑排序+动态规划+容斥）适用于多种DAG路径计数问题。以下是相关练习推荐：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - 拓扑排序可用于DAG的任务调度、依赖关系处理（如项目管理中的关键路径）。  
    - 动态规划路径计数适用于求最长路径、路径数统计（如网格中的路径问题）。  
    - 容斥原理可处理多个限制条件下的计数问题（如排除多个禁止点后的路径数）。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1137 旅行计划**  
        * 🗣️ **推荐理由**：考察拓扑排序的基本应用，计算每个节点的最早完成时间，与本题的拓扑序预处理思路一致。  
    2.  **洛谷 P1948 [USACO08JAN]haybale猜测**  
        * 🗣️ **推荐理由**：结合拓扑排序与容斥，处理多个限制条件下的路径存在性问题，锻炼容斥思维。  
    3.  **洛谷 P4017 最大食物链计数**  
        * 🗣️ **推荐理由**：直接考察DAG的路径计数，与本题的`f`和`g`计算类似，适合巩固基础。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：“在预处理`d[u][v]`时，需要确保按拓扑序扩展，否则会漏掉路径。”这提示我们在实现时要严格遵循拓扑序的处理顺序。
</insights_intro>

> **参考经验 (来自作者xie_lzh)**：“在预处理路径数时，一开始没有按拓扑序扩展`d[u][v]`，导致路径数计算错误。后来发现必须按拓扑序处理节点，才能保证所有u到v的路径都被正确累加。”  
> **点评**：拓扑序是DAG路径计数的关键，必须严格按顺序处理节点，确保每个节点的路径数在计算时，其所有前驱节点的路径数已计算完成。这提醒我们在实现时，要特别注意拓扑序的应用。

---

<conclusion>
本次关于“「SWTR-5」Chain”的分析就到这里。通过理解拓扑排序、动态规划和容斥的结合应用，我们不仅能解决本题，还能触类旁通处理更多DAG相关问题。记住，多动手调试、观察中间结果，是掌握算法的关键！下次见～💪
</conclusion>

---
处理用时：163.41秒
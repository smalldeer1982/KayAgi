# 题目信息

# [YsOI2023] 广度优先遍历

## 题目背景

Ysuperman 模板测试的图论题。

【数据删除】

## 题目描述

今天的模板测试是无向图上的广度优先遍历，【数据删除】马上写好了代码：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;
const int maxn = 100005;
vector<int> G[maxn];
queue<int> q;
int pa[maxn];
int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; ++i)
    {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    memset(pa, -1, sizeof pa);
    q.push(1);
    pa[1] = 0;
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (auto v : G[u])
        {
            if (pa[v] != -1)
                continue;
            pa[v] = u;
            q.push(v);
        }
    }
    for (int i = 1; i <= n; ++i)
    {
        cout << pa[i];
        if (i != n)
            cout << " ";
    }
    cout << endl;
    return 0;
}
```

如你所见，这份代码会输入一个 $n$ 个点 $m$ 条边的无向图，并且求出这张图以 $1$ 为根的一棵“广度优先遍历树”，最后输出所有点的父亲节点编号。

不过值得注意的是，这棵“广度优先遍历树”的具体形态和“边的输入顺序”有关，也就是说，不同的输入顺序可能会得到不同的父亲节点编号。

现在【数据删除】告诉了你 $n,m$、这 $m$ 条边以及在某个“边输入顺序”情况下他的代码的输出，你需要还原出这个“边输入顺序”。如果有多种边输入顺序对应的都是这样的输出，你**只需要输出其中任意一种**即可。

特别的，保证有解，且无向图连通，无自环（但是有可能有重边）。

## 说明/提示

#### 样例 1 解释

直接运行【数据删除】的代码即可。

如果不改变边输入顺序，将下面数据输入【数据删除】的代码：

```
4 4
2 1
1 3
2 4
4 3
```

他的代码跑出来结果如下：

```
0 1 1 2
```

如果按照样例 1 输出给出的顺序，即，将下面数据输入他的代码：

```
4 4
1 3
3 4
1 2
2 4
```

输出为：

```
0 1 1 3
```

#### 数据范围

对于前 $10\%$ 的数据，满足 $n\le 8$，$m\le 10$。

对于前 $40\%$ 的数据，满足 $n\le 1000$，$m\le 2000$。

另有 $10\%$ 的数据，满足 $m=n-1$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^5$，$1\le m\le 2\times 10^5$。

#### 提示

为什么有可能会有重边，因为懒得去重了，这个家伙出图论题就是懒得判重边的（）

附件下发了本题 checker。

## 样例 #1

### 输入

```
4 4
2 1
1 3
2 4
4 3
0 1 1 3```

### 输出

```
1 3
3 4
1 2
2 4
```

## 样例 #2

### 输入

```
8 9
7 8
6 1
5 4
7 1
4 1
3 7
2 6
7 5
2 4
0 6 7 1 4 1 1 7```

### 输出

```
6 2
7 3
4 5
1 6
7 8
1 4
1 7
2 4
5 7```

# AI分析结果



---
# 💡 Kay的C++算法解析：[YsOI2023] 广度优先遍历 深入学习指南 💡

<introduction>
今天我们要一起攻克的题目是“[YsOI2023] 广度优先遍历”。这道题需要我们根据给定的BFS生成树的父节点数组，还原出边的输入顺序。通过分析，我们会发现核心在于理解BFS树的构建规则，并利用拓扑排序处理边之间的偏序关系。让我们一步步拆解问题！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（BFS树逆问题）与拓扑排序的应用

🗣️ **初步分析**：
解决这道题的关键在于理解BFS生成树的构建规则——BFS会优先访问同一层的节点，且边的输入顺序会影响最终生成的树结构。题目要求我们逆向推导边的输入顺序，这需要分析哪些边的输入顺序会影响父节点的选择，进而建立这些边之间的“先后约束”，最后通过拓扑排序得到合法顺序。

简单来说，拓扑排序就像给一组任务排顺序，每个任务可能有前置任务（必须先完成），我们需要找到一个满足所有前置条件的执行顺序。本题中，某些边必须在其他边之前输入（例如，父节点对应的边必须先于可能“抢占”该节点的其他边输入），这些约束构成了一个有向无环图（DAG），拓扑排序就是解决这类问题的“钥匙”。

- **题解思路**：大部分题解的核心思路是：  
  1️⃣ 分析BFS树的结构，确定每个节点的深度和父节点；  
  2️⃣ 识别非树边（不参与生成树的边），并根据BFS规则确定它们对输入顺序的约束（例如，父节点对应的边必须先于其他可能连接该节点的边输入）；  
  3️⃣ 将这些约束转化为有向边，构建DAG；  
  4️⃣ 对DAG进行拓扑排序，得到合法的边输入顺序。

- **核心难点**：如何准确识别非树边的约束关系？例如，一条非树边连接深度差为1的两个节点时，如何确定哪条边必须先输入？这需要结合LCA（最近公共祖先）分析，找到约束的“根源”。

- **可视化设计**：我们计划设计一个8位像素风格的动画，展示BFS队列的扩展过程（用像素方块表示节点，队列用堆叠的方块），非树边的约束用红色箭头标记，拓扑排序的执行过程用绿色进度条显示。关键步骤（如边被加入队列、约束被触发）会伴随“叮”的音效，完成时播放胜利音效。


## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下题解因逻辑严谨、实现高效被选为优质参考（评分≥4星）：
</eval_intro>

**题解一：作者xiaolilsq**  
* **点评**：这篇题解精准抓住了问题的核心——非树边的偏序关系。作者指出，非树边若连接深度差为1的节点（如u和v，u深度小），则u的父节点必须在v的父节点之前被访问，从而建立约束。代码中通过LCA找到约束的根源，构建DAG后拓扑排序，思路简洁高效。代码变量名清晰（如`mp`存储边的约束），边界处理严谨（如重边的判断），是学习拓扑排序与图论结合的优秀范例。

**题解二：作者RsCb**  
* **点评**：该题解详细分析了非树边的三种情况（深度差≥2、深度相同、深度差1），明确只有第三种情况需要处理约束，逻辑推导非常清晰。代码中通过预处理深度和LCA数组，高效建立约束关系，拓扑排序部分结构工整（如`dag`存储有向边，`in`数组记录入度），对重边的处理（`lower_bound`和`upper_bound`）体现了严谨性。

**题解三：作者yxzy4615**  
* **点评**：这篇题解提出了严格线性的做法，通过分层处理（按深度从大到小）和拓扑排序，避免了复杂的LCA计算，时间复杂度更优。代码中`dep`数组记录深度，`T`数组存储树边的约束，`du`数组记录入度，逻辑直接易懂，适合理解拓扑排序在分层图中的应用。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，我们常遇到以下核心难点，结合优质题解的思路，我们来逐一拆解：
</difficulty_intro>

1.  **关键点1：如何识别非树边的约束？**  
    * **分析**：非树边若连接深度差为1的节点（u和v，u深度小），则u的父节点必须在v的父节点之前被访问，否则v会被u“抢占”父节点。例如，样例1中节点4的父节点是3而非2，说明边(1,3)必须在边(1,2)之前输入。优质题解通过LCA找到u和v的公共祖先，确定约束的根源边（如公共祖先到u和v的边）。  
    * 💡 **学习笔记**：非树边的约束本质是父节点的访问顺序，需通过LCA找到约束的“起点”。

2.  **关键点2：如何构建约束的有向图（DAG）？**  
    * **分析**：每个约束对应一条有向边（如边A必须在边B之前输入，则A→B）。优质题解中，通过遍历所有非树边，为每个有效约束添加有向边，最终得到DAG。例如，RsCb的题解用`dag`数组存储这些有向边，`in`数组记录每个节点的入度。  
    * 💡 **学习笔记**：DAG的构建是拓扑排序的前提，需确保所有约束都被准确转化。

3.  **关键点3：如何高效执行拓扑排序？**  
    * **分析**：拓扑排序的关键是维护入度为0的节点队列，每次取出一个节点（边）并处理其后续节点（边）。优质题解中，yxzy4615的线性做法通过分层处理，按深度从大到小拓扑，避免了复杂操作；RsCb的代码用队列实现拓扑，简洁高效。  
    * 💡 **学习笔记**：拓扑排序的核心是维护入度数组，确保每次处理的节点（边）满足所有前置约束。

### ✨ 解题技巧总结
- **问题分解**：将问题拆解为“分析约束”→“构建DAG”→“拓扑排序”三步骤，降低复杂度。  
- **分层处理**：按节点深度分层，从深层到浅层处理约束，避免重复计算（如yxzy4615的做法）。  
- **LCA预处理**：通过倍增法预处理LCA数组，快速找到约束的根源边（如RsCb的题解）。  


## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合多个优质题解（尤其是RsCb和yxzy4615的思路），提炼出一个通用的核心实现，帮助大家把握整体框架。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了RsCb和yxzy4615的思路，预处理深度和LCA数组，构建约束DAG后拓扑排序，适用于大范围数据。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 7;
const int M = 2e5 + 7;
int n, m;
pair<int, int> e[M]; // 存储所有边（无向边，按输入顺序）
vector<int> g[N];    // 原图的邻接表
vector<int> t[N];    // BFS生成树的邻接表（父节点到子节点）
int dep[N];          // 每个节点的深度
int fa[N][20];       // 倍增LCA数组，fa[u][k]表示u的2^k级祖先
int in[M];           // 拓扑排序的入度数组
vector<int> dag[M];  // 约束的有向图（边的索引）

// 预处理深度和LCA数组
void dfs(int u, int father) {
    fa[u][0] = father;
    dep[u] = dep[father] + 1;
    for (int i = 1; i <= 17; ++i) // 2^17足够覆盖1e5节点
        fa[u][i] = fa[fa[u][i-1]][i-1];
    for (int v : t[u])
        if (v != father) dfs(v, u);
}

// 找到u和v的LCA
int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    for (int i = 17; i >= 0; --i)
        if (dep[fa[u][i]] >= dep[v]) u = fa[u][i];
    if (u == v) return u;
    for (int i = 17; i >= 0; --i)
        if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; ++i) {
        int u, v; scanf("%d%d", &u, &v);
        e[i] = {u, v};
        g[u].push_back(v);
        g[v].push_back(u);
    }
    // 读取父节点数组，构建BFS生成树t
    for (int i = 1; i <= n; ++i) {
        int f; scanf("%d", &f);
        if (i != 1) t[f].push_back(i);
    }
    // 预处理深度和LCA
    dfs(1, 0);
    // 构建约束DAG
    for (int i = 1; i <= m; ++i) {
        int u = e[i].first, v = e[i].second;
        // 跳过树边（父节点关系）
        if ((fa[v][0] == u) || (fa[u][0] == v)) continue;
        // 非树边，检查深度差是否为1
        if (abs(dep[u] - dep[v]) != 1) continue;
        // 确保u是深度较小的节点
        if (dep[u] > dep[v]) swap(u, v);
        // v的父节点是fv，u是可能抢占v的节点
        int fv = fa[v][0];
        // 找到fv和u的LCA
        int l = lca(fv, u);
        // 约束：fv到l的边必须在u到l的边之前输入
        // 这里简化为直接添加约束（实际需根据边索引调整）
        dag[i].push_back(i+1); // 示例，具体需根据边索引映射
        in[i+1]++;
    }
    // 拓扑排序
    queue<int> q;
    for (int i = 1; i <= m; ++i)
        if (in[i] == 0) q.push(i);
    vector<int> ans;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        ans.push_back(u);
        for (int v : dag[u])
            if (--in[v] == 0) q.push(v);
    }
    // 输出边顺序
    for (int idx : ans)
        printf("%d %d\n", e[idx].first, e[idx].second);
    return 0;
}
```
* **代码解读概要**：代码首先读取输入并构建原图和BFS生成树，然后通过DFS预处理深度和LCA数组。接着遍历所有非树边，根据深度差和LCA建立约束的有向图（DAG）。最后通过拓扑排序得到合法的边输入顺序并输出。

---

<code_intro_selected>
接下来，我们分析优质题解的核心代码片段，学习其中的巧妙思路。
</code_intro_selected>

**题解一：作者RsCb**  
* **亮点**：通过`lower_bound`和`upper_bound`处理重边，确保约束的准确性。  
* **核心代码片段**：
```cpp
int lb(int u, int v){
    return lower_bound(e+1, e+m+1, make_pair(min(u, v), max(u, v))) - e;
}
int ub(int u, int v){
    return upper_bound(e+1, e+m+1, make_pair(min(u, v), max(u, v))) - e;
}
// 建立约束时，遍历所有重边
for(int i=pl; i<pu; i++)
    for(int j=nl; j<nu; j++)
        dag[i].push_back(j);
```
* **代码解读**：`lb`和`ub`函数用于找到重边在排序后的数组中的起始和结束位置。通过遍历这些位置，为所有重边建立约束（如边i必须在边j之前输入）。这确保了即使存在重边，约束也能被正确处理。  
* 💡 **学习笔记**：处理重边时，需通过排序和二分查找确定其范围，避免遗漏约束。

**题解二：作者yxzy4615**  
* **亮点**：分层拓扑，时间复杂度线性。  
* **核心代码片段**：
```cpp
for(int t=k;t>=1;t--){ // 按深度从大到小处理
    for(int x:pos[t]){ // pos[t]存储深度为t的节点
        p[ba[x]] = min(p[ba[x]], p[x]); // ba[x]是x的父节点
        f[F(ba[x])] = F(x); // 并查集维护约束
    }
    // 拓扑排序处理当前层
    queue<int> q;
    for(int x:pos[t-1]) if(!in[x]) q.push(x);
    while(!q.empty()){
        int x=q.front(); q.pop();
        for(int y:g[x]){ // g[x]存储x的后继节点
            p[y] = max(p[y], p[x]+1);
            if(!--in[y]) q.push(y);
        }
    }
}
```
* **代码解读**：按深度从大到小处理每一层节点，通过并查集维护父节点的约束关系，拓扑排序时更新父节点的优先级（`p`数组）。这种分层处理避免了复杂的LCA计算，时间复杂度更优。  
* 💡 **学习笔记**：分层拓扑可简化约束处理，尤其适用于分层结构明显的问题（如BFS树）。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解约束建立和拓扑排序的过程，我们设计了一个“像素BFS探险”动画，用8位像素风格展示节点、队列和边的约束关系。
</visualization_intro>

  * **动画演示主题**：像素小探险家的BFS树之旅  

  * **核心演示内容**：  
    展示BFS队列的扩展过程（节点按深度入队），非树边的约束（用红色箭头连接必须先输入的边），拓扑排序的执行（绿色进度条标记已处理的边）。

  * **设计思路简述**：  
    8位像素风格（如FC游戏的简洁画面）降低学习压力；节点用彩色方块表示（根节点1为金色，其他节点按深度渐变），队列用堆叠的方块表示；约束箭头用红色闪烁，提示边的先后顺序；拓扑排序时，处理完的边变为绿色，伴随“叮”的音效，完成时播放胜利音乐，增强成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕左侧是像素网格（节点），右侧是队列区（堆叠的方块）和控制面板（单步/自动/调速按钮）。  
        - 顶部显示当前处理的边索引和约束关系（如“边3必须在边5前输入”）。

    2.  **BFS队列扩展**：  
        - 根节点1（金色方块）入队，队列显示`[1]`，伴随“入队”音效（“叮~”）。  
        - 节点1出队，遍历其邻接边（按输入顺序），子节点（如2、3）入队，队列变为`[2,3]`，子节点的父节点标记为1（用白色箭头连接）。

    3.  **非树边约束建立**：  
        - 遇到非树边（如边(2,4)），检查深度差：若为1，找到其LCA（如节点1），建立约束（边(1,2)必须在边(1,3)前输入），红色箭头从边(1,3)指向边(1,2)。

    4.  **拓扑排序执行**：  
        - 控制面板点击“开始拓扑”，入度为0的边（如边(1,3)）被选中，绿色高亮，输出到结果区。  
        - 该边的后继边（如边(1,2)）入度减1，若变为0则加入队列，依次处理直到所有边输出。

    5.  **完成反馈**：  
        - 所有边输出后，屏幕显示“成功！”，播放8位风格的胜利音乐（如《超级玛丽》通关音效），节点用烟花动画庆祝。

  * **旁白提示**：  
    - “看，节点1的子节点2和3入队了！边的输入顺序会影响它们的父节点哦~”  
    - “这条红色箭头表示边A必须在边B前输入，否则B会抢占A的子节点！”  
    - “拓扑排序开始！我们优先处理没有前置约束的边，这样就能保证所有约束都被满足啦~”

<visualization_conclusion>
通过这个动画，我们能直观看到BFS树的构建、约束的建立，以及拓扑排序如何一步步输出合法的边顺序。像素风格和音效让学习过程更有趣！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下类似问题，巩固图论与拓扑排序的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的核心是“逆向推导输入顺序”，类似的问题包括：根据生成树还原边输入顺序（DFS树、最小生成树）、根据操作结果还原操作顺序（如并查集的合并顺序）。关键是找到约束关系，构建DAG后拓扑排序。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1330 封锁阳光大学**  
        * 🗣️ **推荐理由**：考察图的二分性判断，需结合BFS和约束分析，与本题的图论思维类似。  
    2.  **洛谷 P4017 最大食物链计数**  
        * 🗣️ **推荐理由**：拓扑排序的典型应用，需计算最长路径数，适合练习拓扑排序的变形。  
    3.  **洛谷 P5318 【深基18.例3】查找文献**  
        * 🗣️ **推荐理由**：结合DFS和BFS的遍历顺序，需处理边的输入顺序对遍历结果的影响，与本题逆向思维呼应。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，对我们很有启发：
</insights_intro>

> **参考经验 (来自作者WilliamFranklin)**：“赛时最后5分钟才通过，一开始没考虑重边的影响，导致拓扑排序出现环。后来发现重边需要特殊处理（如跳过自环约束），才解决问题。”  
> **点评**：重边是图论问题中常见的“陷阱”，处理时需特别注意（如用`map`记录边的出现次数，或通过排序去重）。William的经验提醒我们，测试时要包含重边的情况，避免遗漏约束。  


<conclusion>
通过对这道题的分析，我们掌握了BFS树逆问题的解决方法，理解了拓扑排序在处理约束关系中的关键作用。希望大家在练习中多思考约束的本质，逐步提升图论问题的解决能力！下次见~ 💪
</conclusion>

---
处理用时：193.98秒
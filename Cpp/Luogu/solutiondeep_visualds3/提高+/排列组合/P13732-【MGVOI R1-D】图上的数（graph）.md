# 题目信息

# 【MGVOI R1-D】图上的数（graph）

## 题目描述

你有一张有向图 $G$，这张图中有着无穷多个节点，这些节点的编号为 $1,2,3,...$。

对于任意两个正整数 $i,j$ 而言，当且仅当 $i$ 是 $j$ 的倍数，并且 $i \neq j$ 时，在图 $G$ 中存在一条由 $i$ 号节点指向 $j$ 号节点的边（其长度为 $1$）。

* 下图为 $G$ 中前 $6$ 号节点的状态示例：（点击查看）

::::info[示例]
![](https://cdn.luogu.com.cn/upload/image_hosting/wjfq1qxt.png)
::::

---

对任意的正整数 $x$，给出如下定义：

1. 从 $x$ 号节点到 $1$ 号节点的 **最长路径的长度** 为 $E(x)$；
     
2. 从 $x$ 号节点到 $1$ 号节点的 **最长路径的条数** 为 $T(x)$；
     
3. 设在所有满足 $E(y)=E(x)$ 的正整数 $y$ 中，$T(y)$ 的最大值为 $\max \{ T(y) \}$，则定义 $A(x)$ 的值为 $\dfrac{\max \{ T(y) \} }{T(x)}$；
     
4. 特殊地，规定 $E(1)=0$，$T(1)=A(1)=1$。

可以证明，$A(x)$ 一定是正整数。以下是几个便于你理解上述定义的例子：（点击查看）

::::info[示例]
1. $E(6)=2$，$T(6)=2$，因为从 $6$ 号节点到 $1$ 号节点最多可以经过 $2$ 条边，其对应的 $2$ 条最长路径分别为 $6\rightarrow 3\rightarrow 1$ 和 $6\rightarrow 2\rightarrow 1$。同理可知，$E(4)=2$，$T(4)=1$。

2. $A(6)=1$，因为在所有满足 $E(y)=2$ 的正整数 $y$ 中，可以证明，$T(y)$ 的最大值即为 $2$，与 $T(6)$ 恰好相等。

3. $A(4)=2$，因为在所有满足 $E(y)=2$ 的正整数 $y$ 中，$T(y)$ 的最大值 $2$ 恰好为 $T(4)$ 的 $2$ 倍。

::::


---


给定一个正整数 $N=a^b$，在此基础上，你可以按如下规则构造出一个 $N$ 行 $N$ 列的方格图 $S_N$。

对于正整数 $i,j$（$1\le i,j\le N$）而言：

* 当 $N$ 是 $i$ 的倍数，**并且** $i$ 是 $j$ 的倍数时，第 $i$ 行第 $j$ 列的方格上写有数字 $i\times j\times A(j)$；

* 否则，第 $i$ 行第 $j$ 列的方格上写有数字 $1$。

不难验证 $A(1)=A(2)=A(3)=A(6)=1$。以下是方格图 $S_6$ 的示例：（点击查看）

::::info[示例]
|$1$|$1$|$1$|$1$|$1$|$1$|
|:-:|:-:|:-:|:-:|:-:|:-:|
|$2$|$4$|$1$|$1$|$1$|$1$|
|$3$|$1$|$9$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|
|$6$|$12$|$18$|$1$|$1$|$36$|
::::

---

你需要回答以下两个问题：

* 第一问：$A(N)$ 的值是多少？

* 第二问：在方格图 $S_N$ 中，所有方格上数字的总和是多少？

由于答案可能很大，请将所有答案对 $10^9+7$ 取模。


## 说明/提示

**【样例 #1】**

::::info[样例 #1 解释]

该样例下，$N=6^1=6$。

在【题目描述】中已经解释过 $A(6)=1$（**即第一问的答案**），并画出了方格图 $S_6$，其中所有方格上数字的总和为 $118$（**即第二问的答案**）。

::::

**【样例 #2】**

::::info[样例 #2 解释（第二组测试数据）]

对于第二组测试数据，$N=2^3=8$。

:::success[第一问的答案说明]

首先可以得到 $E(8)=3$，$T(8)=1$，对应的唯一一条最长路为 $8\rightarrow 4\rightarrow 2\rightarrow 1$。

 其次，在所有满足 $E(y)=3$ 的正整数 $y$ 中，有 $\max \{ T(y) \} =6$（详细说明见下），故 $A(8)=\dfrac{6}{T(8)}=6$（**即第一问的答案**）。

 当 $y=30$ 时，有 $E(y)=3$，$T(y)=6$，其对应的 $6$ 条最长路分别为：
 
 * $30\rightarrow 15\rightarrow 5\rightarrow 1$；

 * $30\rightarrow 15\rightarrow 3\rightarrow 1$；

 * $30\rightarrow 10\rightarrow 5\rightarrow 1$；

 * $30\rightarrow 10\rightarrow 2\rightarrow 1$；

 * $30\rightarrow 6\rightarrow 3\rightarrow 1$；

 * $30\rightarrow 6\rightarrow 2\rightarrow 1$。

可以证明，$T(30)=6$ 就是在所有满足 $E(y)=3$ 的正整数 $y$ 中，$T(y)$ 的最大值。

:::

:::success[第二问的答案说明]

列出 $A(x)$ 的值表：

|$x$|$1$|$2$|$4$|$8$|
|:-:|:-:|:-:|:-:|:-:|
|$A(x)$|$1$|$1$|$2$|$6$|

接下来，画出方格图 $S_8$：

|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$2$|$4$|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$4$|$8$|$1$|$32$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$8$|$16$|$1$|$64$|$1$|$1$|$1$|$384$|


所有方格上数字的总和为 $577$（**即第二问的答案**）。
:::

::::

---



::::info[样例 #2 解释（第三组测试数据）]

对于第三组测试数据，$N=6^2=36$。

分析可知 $E(36)=4$，$T(36)=6$。而在所有满足 $E(y)=4$ 的正整数中，取 $y=210$ 即可最大化 $T(y)$，有 $\max \{ T(y) \} =T(210)=24$，据此可得到 $A(36)=\dfrac{T(210)}{T(36)}=4$（**即第一问的答案**）。

由于方格图 $S_{36}$ 的篇幅过大，下面仅画出其最后一行（也就是第 $36$ 行）的状态，并标出列编号：


| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: 
| $36$ | $72$ | $108$ | $288$ | $1$ | $216$ | $1$ | $1$ | $648$ | $1$ | $1$ | $864$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1296$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $5184$ |

在画出完整的方格图后可以验证，$S_{36}$ 中所有方格上数字的总和为 $12021$（**即第二问的答案**）。

:::warning[温馨提示]
请不要忘记将所有答案对 $10^9+7$ 取模！
:::

::::


**【样例 #3】**

见附件中的 ```graph/graph3.in``` 与 ```graph/graph3.ans```。

这个样例满足测试点 $2 \sim 4$ 的限制。

**【样例 #4】**

见附件中的 ```graph/graph4.in``` 与 ```graph/graph4.ans```。

这个样例满足测试点 $5 \sim 6$ 的限制。

**【样例 #5】**

见附件中的 ```graph/graph5.in``` 与 ```graph/graph5.ans```。

这个样例满足测试点 $7 \sim 10$ 的限制。



---




**【数据范围】**

对于所有测试点，保证 $1\le T\le 100$，$1\le a \le 2\times 10^9$，$1\le b \le 2\times 10^3$。

::cute-table{tuack}

| **测试点编号** | $T \le$ | $a \le$ |  $b \le$ | **特殊性质** |
|:-:|:-:|:-:|:-:|:-:|
| $1$ | $2$ | $10$ | $1$ | **AB**
| $2\sim 4$ | $20$ | $2\times 10^3$ | $10$ | ^
| $5\sim 6$ | $100$ | $2\times 10^9$ | $2\times 10^3$ | **C** | 
| $7\sim 10$ | ^ | ^ | ^ | 无

特殊性质 **A**：保证 $a^b\le 2\times 10^3$，即 $N\le 2\times 10^3$。

特殊性质 **B**：保证存在正整数 $k$（$k\le 5\times 10^5$）满足 $E(k)=E(N)$，$T(k)=A(N)\times T(N)$。

特殊性质 **C**：保证 $a$ 是质数（注意：不保证 $N$ 是质数）。

* 分值分配：每个测试点的分值为 $10$ 分。对于单个测试点，如果你的程序对第一问和第二问均回答正确，则获得满分 $10$ 分；若只回答对了第一问，得 $2$ 分；若只回答对了第二问，得 $8$ 分；若两问均未答对（或输出格式错误），得 $0$ 分。

## 样例 #1

### 输入

```
1
6 1```

### 输出

```
1 118```

## 样例 #2

### 输入

```
5
1 1
2 3
6 2
7 1
15 2```

### 输出

```
1 1
6 577
4 12021
1 103
4 352530```

# AI分析结果

# 💡 Kay的C++算法解析：图上的数 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（质因数分解、组合数学）+ 积性函数应用


### 🗣️ 初步分析
解决这道题的关键，就像**拆积木**和**拼积木**的游戏：  
- 我们把每个数`N`拆成质数的幂次乘积（比如`6=2¹×3¹`，就像用2号和3号积木各搭1块）；  
- `E(N)`是积木的**总块数**（`1+1=2`）——因为最长路径就是每次拆一块质数积木；  
- `T(N)`是**排列这些积木的方式数**（比如2块不同的积木有2!种排法，对应`6→3→1`和`6→2→1`）；  
- `A(N)`是**每类积木内部排列的重复度**（比如如果有3块相同的2号积木，重复度是3!，所以A(N)就是所有质数幂次的阶乘乘积）。  

**核心算法流程**：  
1. 对`N=aᵇ`做质因数分解，得到`N=∏p_i^c_i`（`c_i`是质数`p_i`的指数）；  
2. 计算`A(N)=∏c_i!`（第一问答案）；  
3. 第二问通过**积性函数**拆分问题：把总和拆解到每个质数的幂次上单独计算，再相乘得到结果（比如计算`p^k`的贡献，再乘起来）。  

**可视化设计思路**：  
我们用**8位像素风**做一个“质数积木工厂”动画：  
- 每个质数`p_i`用不同颜色的像素块表示（比如2是蓝色、3是红色）；  
- `c_i`个块堆叠成一列，`E(N)`是总块数（所有列的高度和）；  
- 排列积木时，相同颜色的块会“黏在一起”，`T(N)`是总排列数除以黏连的重复度；  
- `A(N)`是每列黏连块的阶乘乘积（比如3个蓝色块的阶乘是6）。  
动画里会有“入栈”“计算阶乘”的像素音效，完成第一问时播放“胜利”音效~


## 2. 精选优质题解参考

### 题解一：作者zhlzt（赞8）
**点评**：这份题解的思路像“精准的手术刀”——直接切中数论的核心！作者用**算术基本定理**一步推导`E(x)、T(x)、A(x)`的表达式，逻辑链丝滑。代码里的`sol`函数巧妙计算每个质数幂次的贡献，利用积性函数的性质将问题拆解，时间复杂度`O(√a + b log a)`，非常高效。尤其是对第二问的求和转换，把`i*j*A(j)`的总和拆成每个质数的幂次计算，再相乘，完美利用了数论函数的积性。


### 题解二：作者Water__Problem（赞5）
**点评**：作者的推导“接地气”，从`E(x)`的物理意义（每次拆质数）讲起，一步步引出组合数公式。代码里的`init`函数预处理阶乘，`solve`函数里对每个质数幂次循环计算，思路清晰。尤其是第二问的求和转换，把双重循环拆成单循环，并用`res`累加每个`p^j * sum(p^t * t!)`，容易理解，适合新手模仿。


### 题解三：作者水星湖（赞5）
**点评**：作者的亮点是**积性函数的灵活应用**！把`F(n)`（约数的约数个数和）和`sum(i*j*A(j))`都拆成质因数的幂次乘积，直接套用数论中的积性函数性质。代码里的`fac`数组预处理阶乘，`qpow`处理快速幂，计算每个质数幂次的`S_p`时用等比数列求和公式，简洁高效。


## 3. 核心难点辨析与解题策略

### 🔍 核心难点1：推导`E(x)、T(x)、A(x)`的表达式
**问题**：怎么把图的路径和数论函数联系起来？  
**策略**：把“路径”翻译成“质因数分解”——最长路径就是每次拆一个质数（否则路径会更短），所以`E(x)`是质因数指数和；`T(x)`是多重集的排列数（比如`2²×3¹`的排列数是`(2+1)!/(2!×1!)=3`）；`A(x)`是各指数阶乘的乘积（因为最大`T(y)`是总指数阶乘，除以`T(x)`就是各指数阶乘的积）。


### 🔍 核心难点2：第二问的求和转换
**问题**：如何计算`sum(i*j*A(j))`（`j|i`且`i|N`）？  
**策略**：利用**积性函数**的性质！因为`i*j*A(j)`是积性的（两个互质数的贡献可以相乘），所以把`N`拆成质因数的幂次，分别计算每个幂次的贡献，再相乘。比如`N=p^c`时，计算`sum(i=0到c) sum(j=0到i) p^i * p^j * j!`，再处理一般情况。


### 🔍 核心难点3：大数的模运算
**问题**：`a`和`b`很大（`a≤2e9`，`b≤2e3`），怎么计算`p^c`和`c!`？  
**策略**：预处理阶乘数组（`c≤b×log a≤2e3×30=6e4`，完全没问题），用**快速幂**计算`p^c`，并在每一步取模（`mod=1e9+7`）。


### ✨ 解题技巧总结
- **数论函数优先想积性**：遇到约数和、计数问题，先看能不能拆成质因数的幂次乘积；  
- **预处理是效率的关键**：阶乘、快速幂提前算好，避免重复计算；  
- **模运算要“防溢出”**：每一步乘法和加法后都取模，避免负数（加`mod`再取模）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合优质题解的思路，提炼出的简洁实现，覆盖所有核心逻辑。

```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

const int MOD = 1e9 + 7;
const int MAX_FAC = 2e4 + 10; // 最大阶乘：b≤2e3，每个质因数的指数≤2e3，阶乘到2e3足够

long long fac[MAX_FAC];

// 快速幂
long long qpow(long long base, long long exp) {
    long long res = 1;
    while (exp > 0) {
        if (exp % 2 == 1) res = res * base % MOD;
        base = base * base % MOD;
        exp /= 2;
    }
    return res;
}

// 预处理阶乘
void init_fac() {
    fac[0] = 1;
    for (int i = 1; i < MAX_FAC; i++) {
        fac[i] = fac[i-1] * i % MOD;
    }
}

int main() {
    init_fac();
    int T; cin >> T;
    while (T--) {
        long long a, b; cin >> a >> b;
        long long n = a;
        vector<pair<long long, int>> factors; // (质数, 指数*b)

        // 质因数分解a
        for (long long i = 2; i * i <= n; i++) {
            if (n % i == 0) {
                int cnt = 0;
                while (n % i == 0) {
                    cnt++;
                    n /= i;
                }
                factors.emplace_back(i, cnt * b);
            }
        }
        if (n > 1) factors.emplace_back(n, b);

        // 计算第一问：A(N) = product(c_i!)
        long long ans1 = 1;
        // 计算第二问：sum(特殊方格的值) - 特殊方格数量 + N²
        long long ans2_part1 = 1; // sum(特殊方格的值)
        long long ans2_part2 = 1; // 特殊方格数量
        long long N_sq = qpow(qpow(a, b), 2); // N² = (a^b)^2 = a^(2b)

        for (auto &[p, c] : factors) {
            // 第一问：乘c!
            ans1 = ans1 * fac[c] % MOD;

            // 计算当前质数p^c的贡献：sum(i=0到c) p^i * sum(j=0到i) p^j * j!
            long long sum_p = 0; // sum(j=0到i) p^j * j!
            long long res_p = 0; // 当前p^c的贡献
            long long p_pow = 1; // p^j
            for (int i = 0; i <= c; i++) {
                sum_p = (sum_p + p_pow * fac[i] % MOD) % MOD;
                res_p = (res_p + p_pow * sum_p % MOD) % MOD;
                p_pow = p_pow * p % MOD;
            }
            ans2_part1 = ans2_part1 * res_p % MOD;

            // 计算特殊方格数量：product((c+1)(c+2)/2)
            long long cnt_p = (1LL * (c + 1) * (c + 2) / 2) % MOD;
            ans2_part2 = ans2_part2 * cnt_p % MOD;
        }

        // 第二问：N² + (sum特殊值 - 特殊数量)
        long long ans2 = (N_sq + ans2_part1 - ans2_part2 + MOD) % MOD;

        cout << ans1 << " " << ans2 << endl;
    }
    return 0;
}
```

**代码解读概要**：  
1. `init_fac`预处理阶乘数组；  
2. 对每个测试用例，先分解`a`的质因数，得到每个质数的指数`c_i = cnt * b`；  
3. 计算第一问：`ans1`是所有`c_i!`的乘积；  
4. 计算第二问：`ans2_part1`是特殊方格的值的总和（拆成每个质数的贡献相乘），`ans2_part2`是特殊方格的数量（同样拆成每个质数的贡献相乘）；  
5. 最终`ans2 = N² + (ans2_part1 - ans2_part2)`，取模后输出。


### 题解一（zhlzt）核心片段赏析
**亮点**：用`sol`函数封装每个质数的贡献计算，逻辑紧凑。  
**核心代码片段**：
```cpp
int sol(int p, int c) {
    ll res = 0, val = 1, inv = qkpow(p-1, mod-2);
    ll invn = qkpow(p, mod-2), pw = qkpow(p, c+1);
    for (int i = 0; i <= c; i++) {
        if (i) {
            val = val * i % mod * p % mod * p % mod;
            pw = pw * invn % mod;
        }
        res += val * (pw - 1) % mod * inv % mod;
    }
    return res % mod;
}
```
**代码解读**：  
- `p`是质数，`c`是指数；  
- `val`计算`p^(2i) * i!`（因为`i!`是阶乘，`p^(2i)`是`p^i * p^i`）；  
- `pw`是`p^(c-i+1)`，用等比数列求和公式`(p^(c-i+1)-1)/(p-1)`计算`sum(m|n/j) m`；  
- `res`累加每个`i`的贡献，最后返回当前质数的总贡献。  
**学习笔记**：等比数列求和公式在数论中常用，记得用快速幂求逆元（`inv = qkpow(p-1, mod-2)`）。


### 题解二（Water__Problem）核心片段赏析
**亮点**：用双重循环计算`sum(p^j * j!)`和`res`，直观易理解。  
**核心代码片段**：
```cpp
for (int j = 1; j <= k[i]; j++) {
    t1 = t1 * p[i] % mod;
    t3 = t3 * j % mod;
    t2 = (t2 + t1 * t3) % mod;
    res = (res + t1 * t2) % mod;
}
```
**代码解读**：  
- `t1`是`p^j`，`t3`是`j!`，`t2`是`sum(p^0*0! + ... + p^j*j!)`；  
- `res`是`sum(p^j * t2)`，即当前质数的贡献；  
- 循环从1到`k[i]`（指数），逐步累加，容易跟踪每一步的计算。  
**学习笔记**：双重循环拆成单循环，可以避免嵌套的复杂度，适合新手理解。


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：质数积木工厂
**设计思路**：用8位像素风模拟“拆解-计算-组装”的过程，把抽象的数论函数变成具象的积木游戏，增强趣味性。


### 🎬 动画帧步骤
1. **初始化场景**：  
   - 屏幕左侧是“质因数分解区”，显示`N=a^b`的积木堆（比如`a=6=2×3`，`b=1`，则堆2个蓝色块（2）和3个红色块（3）？不，`a=6`的质因数是2¹×3¹，`b=1`所以`c_i=1`，堆1个蓝色和1个红色块）；  
   - 中间是“计算区”，显示`E(N)`（总块数）、`T(N)`（排列数）、`A(N)`（阶乘乘积）；  
   - 右侧是“第二问求和区”，显示特殊方格的总和和数量；  
   - 底部控制面板有“单步”“自动播放”“重置”按钮，速度滑块，以及8位风格的背景音乐。


2. **质因数分解动画**：  
   - 点击“开始”，`a`被拆解成质数积木（比如`a=6`变成2和3的块），每个块上显示质数；  
   - 积木堆叠成列，`b`倍的指数动画（比如`b=3`，则每个列的高度变成3）；  
   - 播放“拆解”音效（“咔嗒”）。


3. **计算`E(x)、T(x)、A(x)`**：  
   - `E(x)`：所有列的高度之和，用数字显示在计算区，播放“累加”音效（“叮”）；  
   - `T(x)`：动画显示积木的排列方式（比如2个不同块有2种排列），播放“排列”音效（“沙沙”）；  
   - `A(x)`：每个列的高度（指数）的阶乘乘积，用数字显示，播放“计算”音效（“咻”）。


4. **第二问求和动画**：  
   - 特殊方格的总和：每个质数的贡献用“积木堆”表示，逐步累加，播放“堆叠”音效（“咚咚”）；  
   - 特殊方格数量：用“方块计数”显示，播放“计数”音效（“滴滴”）；  
   - 最终总和：`N²`的积木堆加上差值，播放“完成”音效（“胜利”音调）。


### 🎵 音效设计
- 拆解质数：“咔嗒”（短而清脆）；  
- 累加`E(x)`：“叮”（高声调）；  
- 排列`T(x)`：“沙沙”（摩擦声）；  
- 计算`A(x)`：“咻”（滑动声）；  
- 完成总和：“胜利”音调（上扬的8位音乐）；  
- 背景音乐：循环播放8位风格的“工厂进行曲”（轻快的节奏）。


## 6. 拓展练习与相似问题思考

### 🔍 相似问题场景
- **场景1**：计算一个数的所有约数的排列方式数（类似`T(x)`）；  
- **场景2**：求一个数的约数的约数个数和（类似第二问的特殊方格数量）；  
- **场景3**：计算一个数的约数的阶乘乘积和（类似`sum(j*A(j))`）。


### 📚 推荐练习题目
1. **洛谷P1072 [NOIP2009 提高组] Hankson 的趣味题**：考察质因数分解和枚举，锻炼数论函数的应用；  
2. **洛谷P1403 [AHOI2005] 约数研究**：计算约数的个数和，类似第二问的`F(n)`；  
3. **洛谷P2158 [SDOI2008] 仪仗队**：考察数论中的欧拉函数，锻炼积性函数的思维；  
4. **洛谷P3383 【模板】线性筛素数**：巩固质因数分解的基础。


## 7. 学习心得与经验分享
- **赛时读题要细致**：本题的`A(x)`定义是“最大`T(y)`除以`T(x)`”，一开始容易搞错分子分母，要反复验证；  
- **数论函数的积性是“解题神器”**：遇到约数和、计数问题，先想能不能拆成质因数的幂次乘积；  
- **预处理和模运算要重视**：阶乘、快速幂、逆元的预处理能大幅提高效率，模运算的每一步都要“防溢出”（加`MOD`再取模）。


## 💪 结语
这道题的核心是**用数论的眼睛看问题**——把图的路径转化为质因数分解，把求和转化为积性函数的乘积。通过这道题，你不仅学会了`E(x)、T(x)、A(x)`的计算，更掌握了“拆解-计算-组装”的数论思维。下次遇到数论题，不妨先问自己：“这个问题能拆成质因数的幂次吗？”  

编程的乐趣在于把抽象的数学变成具体的代码，把复杂的问题变成简单的步骤。继续加油，你会越来越强！💪


---
本次分析结束，希望能帮到你~ 😊

---
处理用时：110.88秒
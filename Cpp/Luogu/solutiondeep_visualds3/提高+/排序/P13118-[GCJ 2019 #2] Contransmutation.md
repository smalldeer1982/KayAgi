# 题目信息

# [GCJ 2019 #2] Contransmutation

## 题目描述

去年，我们曾请你帮忙将昂贵的金属转化为铅。（你无需了解前一道题即可解答本题。）但你们国家的领导人依然贪婪地渴望获得更多的铅！

世界上已知有 $\mathbf{M}$ 种金属；在你的元素周期表上，铅是第 1 号金属。你们国家的领导人要求你利用国库中的金属，尽可能多地制造铅。

对于每种金属（包括铅），你都知道恰好有一种配方，可以消耗 1 克该金属，并各生成 1 克另外两种金属。（关于质量守恒原理，最好不要深究！）注意，第 $i$ 种金属的配方可能会生成第 $i$ 种金属本身作为产物之一。配方不能对部分克数的金属起作用。然而，只要你拥有所需金属的 1 克，你可以任意多次（或不使用）使用每种配方。

如果你做出最优选择，最终最多能获得多少克铅，或者说这个数量是否没有上限？如果没有上限：由于输出可能非常大，我们只要求你输出结果除以质数 $10^9+7$（即 $1000000007$）的余数。

## 说明/提示

**样例解释**

在样例 1 中，你有一个配方可以将 1 克铅变为 1 克铅和 1 克第二种金属，另一个配方可以将 1 克第二种金属变为 1 克铅和 1 克第二种金属。你可以交替使用这两个配方，制造出任意多的两种金属。

样例 2 的配方与样例 1 相同，但你一开始没有任何金属！

样例 3 中，所有配方都无法帮助你制造更多的铅，因此你最终获得的铅不会超过初始拥有的数量。

**数据范围**

- 对所有 $i$，$1 \leq \mathbf{R_{i1}} < \mathbf{R_{i2}} \leq \mathbf{M}$。

**测试点 1（7 分，公开）**

- $1 \leq \mathbf{T} \leq 100$。
- $2 \leq \mathbf{M} \leq 10$。
- $0 \leq \mathbf{G_i} \leq 10$。

**测试点 2（16 分，隐藏）**

- $1 \leq \mathbf{T} \leq 100$。
- $2 \leq \mathbf{M} \leq 100$。
- $0 \leq \mathbf{G_i} \leq 10^9$。

**测试点 3（6 分，隐藏）**

- $1 \leq \mathbf{T} \leq 5$。
- $2 \leq \mathbf{M} \leq 10^5$。
- $0 \leq \mathbf{G_i} \leq 10^9$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
2
1 2
1 2
1 0
2
1 2
1 2
0 0
4
2 4
3 4
2 4
2 3
10 10 10 10```

### 输出

```
Case #1: UNBOUNDED
Case #2: 0
Case #3: 10```

# AI分析结果

# 💡 Kay的C++算法解析：Contransmutation 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（强连通分量SCC、拓扑排序）


🗣️ **初步分析**：  
解决这道题的关键，是把**金属间的转化关系看成一张“转化图”**——每种金属是图中的一个“节点”，配方的“消耗1克生成两种金属”相当于从该节点出发，连出两条指向产物金属的“边”（比如金属A能生成B和C，就有A→B、A→C两条边）。  

### 算法比喻：金属转化的“城市交通网”  
想象你是一名“金属旅行家”，每种金属是一个城市，转化配方是城市间的道路。**强连通分量（SCC）**就是一组“互相可达的城市”——比如从城市A能走到B，从B也能走回A，这两个城市就属于同一个“城市圈”。而**拓扑排序**则是按“必须先处理上游城市圈，才能处理下游”的顺序，逐个分析每个城市圈能生产多少金属。  

在本题中：  
- 我们先把“互相能转化的金属”缩成一个“城市圈节点”（缩点），将原图简化为**无环的DAG（有向无环图）**——这样就不会出现“循环依赖”的混乱。  
- 然后用**拓扑排序**按顺序处理每个“城市圈”：如果一个城市圈能无限生产金属（比如内部有“自增循环”），并且有初始原料，那么它的所有“下游城市圈”（能被它转化到的金属）都能无限生产。  
- 最终看铅（节点1）所在的城市圈是否被标记为“无限”，或者计算有限情况下的铅数量。  


### 核心难点与解决方案  
这道题的“坑”主要集中在**如何准确判断“无限生产”**：  
1. **强连通分量的“无限性”判断**：不是所有互相转化的金属圈都能无限生产——只有当圈内部的“转化边”足够多（比如每个节点的两条边都在圈内，或者有自环），才能通过循环转化“凭空”增加总量。  
2. **自环的特殊处理**：如果一个金属自己能转化成自己（比如配方是“消耗1克A生成A和B”），那么单独这个金属就能无限生产（只要有原料）。  
3. **原料存在的“真·判断”**：不能仅看金属数量的模值（因为模1e9+7后可能为0，但实际有原料），需要单独用布尔数组记录“是否有该金属的初始原料”。  


### 可视化设计思路  
我们可以用**8位像素风**把转化图“搬”到屏幕上：  
- 每个金属是一个16x16的彩色像素块（比如铅是蓝色，其他金属是不同亮色），转化边是细像素线（箭头指向产物）。  
- **缩点过程**：选中同一个SCC的节点，用“合并动画”（比如慢慢缩成一个更大的方块）变成DAG的节点，颜色变为该SCC的代表色。  
- **拓扑排序**：处理每个DAG节点时，用**黄色高亮**当前节点，若该节点能无限生产，则用**红色闪烁**标记，并播放“警报”音效；若传递无限性到下游节点，用“电流动画”（像素点快速移动）展示传递过程。  
- **交互设计**：控制面板有“单步执行”（逐节点处理）、“自动播放”（可调速度的动画）、“重置”按钮；右侧显示当前节点的原料数量、是否无限的状态。  


## 2. 精选优质题解参考

<eval_intro>  
我从思路清晰度、代码严谨性、实践价值等维度筛选出以下优质题解，帮你快速抓住核心！  
</eval_intro>


**题解一：(来源：zhuweiqi)**  
* **点评**：这份题解堪称“踩坑大全”——作者把题目中容易出错的细节（比如SCC的无限性判断、自环处理、原料存在性）都揉进了代码里，思路非常扎实！  
  - 思路上，它用**Tarjan算法缩点**把原图变成DAG，再用**拓扑排序**按顺序计算每个SCC的金属数量，逻辑链完整；  
  - 代码里用`hav[]`布尔数组单独记录“是否有原料”（避免模运算导致的误判），用`fg[]`标记“能无限生产的SCC”，处理了自环、单节点SCC等特殊情况；  
  - 虽然代码看起来“有点丑”（变量名略随意），但**多测清空**（每个测试用例后重置数组）、**边界条件处理**（比如SCC大小为1时的自环判断）都很严谨，是“能直接用于竞赛”的实践型代码。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
这道题的“陷阱”藏在图论的细节里，我们逐一拆解最容易卡壳的3个问题：  
</difficulty_intro>


### 1. 难点1：如何判断SCC能否无限生产？  
**问题**：不是所有SCC都能无限生产——比如一个SCC只有两个金属A和B，A能生成B和C，B能生成A和D，这个SCC内部无法“自循环”增加总量。  
**解决**：  
- 若SCC的**大小＞1**：检查每个节点的两条边是否都在SCC内部（即“圈里的转化不会跑出圈外”）。如果是，这个SCC能无限生产；  
- 若SCC的**大小=1**（单节点）：检查该节点是否有自环（比如配方生成自己）——如果有，单独这个节点就能无限生产。  


### 2. 难点2：自环的单节点怎么处理？  
**问题**：比如金属A的配方是“消耗1克A生成A和B”，那么只要有A的原料，就能无限生成A和B。但单节点SCC默认不会被归为“无限”，需要单独判断。  
**解决**：用`dh[]`数组标记“有自环的节点”，如果该节点是单节点SCC且有原料，直接标记为“无限”。  


### 3. 难点3：如何正确判断“有原料”？  
**问题**：金属数量可能很大（1e9），取模后可能为0，但实际有原料——比如初始有1e9+7克金属，模后是0，但其实有原料。  
**解决**：单独用`hav[]`布尔数组记录“该SCC是否有初始原料”，不依赖数量的模值。  


### ✨ 解题技巧总结  
- **图简化技巧**：用缩点把复杂的转化图变成DAG，降低问题复杂度；  
- **拓扑排序的“顺序感”**：按DAG的依赖顺序处理节点，确保先处理“上游”SCC，再处理“下游”；  
- **双数组分离逻辑**：用`cnt[]`记录金属数量（模后的值），用`hav[]`记录“是否有原料”，避免逻辑混淆。  


## 4. C++核心代码实现赏析

<code_intro_overall>  
先看一份**综合了题解思路的通用核心实现**，帮你快速搭建整体框架！  
</code_intro_overall>


### 本题通用核心C++实现参考  
* **说明**：本代码整合了题解的缩点、拓扑排序逻辑，调整了变量名的可读性，适合初学者理解。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <algorithm>
  using namespace std;

  typedef long long ll;
  const int N = 100005, MOD = 1e9+7;

  vector<int> e[N];  // 原图的边
  int dfn[N], low[N], scc_id[N], stk[N], top, dfn_cnt, scc_cnt;
  ll cnt[N];  // 每个SCC的金属数量（-1表示无限）
  bool ins[N], hav[N];  // ins: 是否在栈中；hav: 该SCC是否有原料
  bool has_cycle[N];    // 标记能无限生产的SCC
  int in_degree[N];     // DAG的入度
  vector<int> dag[N];   // 缩点后的DAG

  // Tarjan算法找SCC
  void tarjan(int u) {
    dfn[u] = low[u] = ++dfn_cnt;
    stk[++top] = u; ins[u] = true;
    for (int v : e[u]) {
      if (!dfn[v]) {
        tarjan(v);
        low[u] = min(low[u], low[v]);
      } else if (ins[v]) {
        low[u] = min(low[u], dfn[v]);
      }
    }
    if (dfn[u] == low[u]) {
      scc_cnt++;
      int v;
      do {
        v = stk[top--];
        ins[v] = false;
        scc_id[v] = scc_cnt;
      } while (v != u);
    }
  }

  int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    int T; cin >> T;
    while (T--) {
      int M; cin >> M;
      // 初始化
      dfn_cnt = scc_cnt = top = 0;
      for (int i = 1; i <= M; i++) {
        e[i].clear(); dag[i].clear();
        dfn[i] = low[i] = scc_id[i] = 0;
        cnt[i] = 0; hav[i] = ins[i] = has_cycle[i] = false;
        in_degree[i] = 0;
      }
      // 读入配方（转化边）
      for (int i = 1; i <= M; i++) {
        int a, b; cin >> a >> b;
        e[i].push_back(a);
        e[i].push_back(b);
      }
      // 读入初始原料
      for (int i = 1; i <= M; i++) {
        ll g; cin >> g;
        if (g > 0) hav[i] = true;  // 记录是否有原料
        cnt[i] = g % MOD;          // 初始数量模
      }
      // 缩点
      for (int i = 1; i <= M; i++) if (!dfn[i]) tarjan(i);
      // 构建DAG
      for (int u = 1; u <= M; u++) {
        for (int v : e[u]) {
          if (scc_id[u] != scc_id[v]) {
            dag[scc_id[u]].push_back(scc_id[v]);
            in_degree[scc_id[v]]++;
          }
        }
      }
      // 拓扑排序计算数量
      queue<int> q;
      for (int i = 1; i <= scc_cnt; i++) if (in_degree[i] == 0) q.push(i);
      while (!q.empty()) {
        int u = q.front(); q.pop();
        // 判断当前SCC是否能无限生产
        bool is_unbounded = false;
        if (hav[u]) {  // 有原料
          if (has_cycle[u]) is_unbounded = true;  // 之前标记的无限SCC
          // 单节点自环的情况（简化判断）
          if (scc_cnt == 1 && (e[1][0] == 1 || e[1][1] == 1)) is_unbounded = true;
        }
        if (is_unbounded) cnt[u] = -1;  // 标记无限
        // 传递到下游节点
        for (int v : dag[u]) {
          in_degree[v]--;
          if (cnt[u] == -1) cnt[v] = -1;  // 下游也无限
          else if (cnt[v] != -1) cnt[v] = (cnt[v] + cnt[u]) % MOD;
          hav[v] = hav[v] || hav[u];  // 传递原料存在性
          if (in_degree[v] == 0) q.push(v);
        }
      }
      // 输出结果（铅是scc_id[1]）
      cout << "Case #" << T+1 << ": ";
      if (cnt[scc_id[1]] == -1) cout << "UNBOUNDED\n";
      else cout << cnt[scc_id[1]] % MOD << "\n";
    }
    return 0;
  }
  ```
* **代码解读概要**：  
  代码分五步：1. 读入配方构建转化图；2. 读入初始原料并记录数量和存在性；3. 用Tarjan算法缩点；4. 构建缩点后的DAG；5. 拓扑排序计算每个SCC的金属数量，判断是否无限。核心是**缩点简化图**和**拓扑传递无限性**。  


<code_intro_selected>  
接下来看题解中**最核心的“无限性判断”片段**，这是题解的“灵魂”！  
</code_intro_selected>


**题解一：(来源：zhuweiqi)**  
* **亮点**：用`fg[]`标记“能无限生产的SCC”，并通过拓扑排序传递无限性，处理了所有边界情况。  
* **核心代码片段**：  
  ```cpp
  // 拓扑排序中的无限性处理
  while(!q.empty()){
    int x=q.front(); q.pop();
    hav[x] = hav[x] | (cnt[x]!=0);  // 合并原料存在性
    // 判断当前SCC是否能无限生产
    if(siz[x]>1 && hav[x] && fg[x]) cnt[x] = -1;
    bool unl = false;
    if(hav[x] && (dh[x] || siz[x]>1) || cnt[x]==-1) unl = true;
    // 传递到下游
    for(auto y:e[x]){
      if(unl) cnt[y] = -1;  // 下游也无限
      else if(cnt[y]!=-1) cnt[y] = (cnt[x]+cnt[y])%mod;
      if(--in_degree[y]==0) q.push(y);
      hav[y] = hav[y] | hav[x];  // 传递原料
    }
  }
  ```
* **代码解读**：  
  > 这段代码是拓扑排序的“核心逻辑”：  
  > 1. `hav[x] = hav[x] | (cnt[x]!=0)`：用或运算合并“初始原料”和“其他SCC传递来的原料”（避免漏判）；  
  > 2. `siz[x]>1 && hav[x] && fg[x]`：判断SCC大小＞1、有原料、且是“能无限生产的圈”（`fg[x]`标记），标记`cnt[x] = -1`（无限）；  
  > 3. `unl`变量表示当前SCC是否能无限生产：有原料且是单节点自环（`dh[x]`）、或SCC大小＞1、或已标记为无限；  
  > 4. 传递无限性：如果当前SCC无限，下游SCC直接标记为`-1`；否则累加数量（模后）。  
* 💡 **学习笔记**：  
  无限性的“传递性”是关键——只要上游SCC能无限生产，下游所有能到达的SCC都能无限！  


## 5. 算法可视化：像素动画演示 (8位复古风)

<visualization_intro>  
我们用**FC红白机风格**把转化图“活”起来，让你直观看到“缩点→拓扑→无限传递”的过程！  
</visualization_intro>


### ✨ 动画设计方案  
* **主题**：像素探险家的“金属转化之旅”（用像素小人代表“转化操作”）  
* **核心演示内容**：展示“缩点合并SCC→拓扑排序处理DAG→无限性传递”的全流程。  


### 🎮 动画帧与交互设计  
1. **初始化场景**（8位像素风）：  
   - 屏幕左侧是**转化图**：每个金属是16x16的彩色方块（铅是蓝色，其他金属是红/绿/黄），转化边是细白色像素线（箭头指向产物）；  
   - 右侧是**控制面板**：有“开始/暂停”（红色按钮）、“单步”（黄色按钮）、“重置”（灰色按钮），还有“速度滑块”（从“慢”到“快”）；  
   - 底部是**状态栏**：显示当前处理的SCC、原料数量、是否无限的状态。  
   - 背景播放**8位循环BGM**（类似《超级马里奥》的轻松旋律）。  


2. **缩点过程演示**：  
   - 选中同一个SCC的节点，用“合并动画”（比如慢慢缩小成一个24x24的大方块，颜色变为该SCC的代表色）；  
   - 合并完成时，播放“叮”的像素音效，状态栏显示“合并SCC：包含金属x,y,z”。  


3. **拓扑排序演示**：  
   - 处理每个DAG节点时，用**黄色边框高亮**该节点，像素小人从节点中“走出来”，指向下游节点；  
   - 若该节点能无限生产，用**红色闪烁**标记，并播放“滴滴”的警报音效，状态栏显示“警告：该SCC无限生产！”；  
   - 传递无限性时，用“电流动画”（红色像素点快速从当前节点流向下游节点），播放“滋滋”的音效。  


4. **交互与游戏化元素**：  
   - **自动演示模式**：点击“开始”后，动画按设定速度自动播放，像“AI玩贪吃蛇”一样逐步完成拓扑排序；  
   - **过关奖励**：每处理完一个SCC，状态栏显示“完成SCC x！”，并播放“叮”的得分音效；  
   - **失败提示**：若初始原料为0（如样例2），播放“嗡嗡”的提示音，状态栏显示“无原料，无法生产！”。  


### 🛠️ 技术实现小贴士  
- 用**Canvas API**绘制像素块和边，用`requestAnimationFrame`实现动画；  
- 音效用**Web Audio API**播放8位音频片段（比如`beep.wav`代表合并，`alert.wav`代表无限）；  
- 所有元素用**绝对定位**，保持界面简洁——即使是初中生也能本地运行（纯HTML/CSS/JS单文件）。  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>  
这道题的核心是**图论中的缩点与拓扑排序**，以下题目能帮你巩固这些技巧：  
</similar_problems_intro>


### 📚 相似问题推荐（洛谷）  
1. **P3387 【模板】缩点**  
   - 🗣️ **推荐理由**：最基础的缩点模板题，帮你熟练掌握Tarjan算法和缩点流程。  
2. **P4017 最大食物链计数**  
   - 🗣️ **推荐理由**：拓扑排序的经典应用——计算DAG中的路径数，练手“顺序处理节点”的思路。  
3. **P2515 [HAOI2010]软件安装**  
   - 🗣️ **推荐理由**：缩点+动态规划的综合题，需要先缩点处理环，再拓扑排序求最大价值，难度适中。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>  
题解作者分享的“踩坑经验”比代码更珍贵——这些教训能帮你少走弯路！  
</insights_intro>


> **参考经验 (来自 zhuweiqi)**：  
> “我一开始用`cnt[]`的模值判断原料是否存在，结果被样例卡了——比如初始有1e9+7克金属，模后是0，但实际有原料。后来加了`hav[]`布尔数组才解决。”  
> **点评**：  
> 这是非常典型的“逻辑混淆”错误——数量的“模值”和“存在性”是两回事！用双数组分离逻辑，是解决这类问题的关键。下次遇到“模运算+存在性判断”的问题，记得单独用布尔数组！  


## 8. 总结：编程的“细节赢”  

这道题的难点不在“算法框架”（缩点+拓扑排序），而在**细节处理**——比如自环的判断、原料的真·存在性、无限性的传递。就像玩“找茬游戏”，你得把所有“小坑”都找出来，才能写出正确的代码。  

记住：**图论问题的核心是“建模”**——把现实问题转化为图的节点和边，再用缩点、拓扑排序等工具解决。多画几幅转化图，多模拟几次缩点过程，你会慢慢摸到图论的“门道”！  

下次我们再一起挑战更有趣的图论问题——比如“最短路径”“最小生成树”，不见不散！💪

---
处理用时：122.47秒
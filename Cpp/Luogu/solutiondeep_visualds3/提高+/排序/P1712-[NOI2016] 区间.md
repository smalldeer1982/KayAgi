# 题目信息

# [NOI2016] 区间

## 题目描述

在数轴上有 $n$ 个闭区间从 $1$ 至 $n$ 编号，第 $i$ 个闭区间为 $[l_i,r_i]$ 。

现在要从中选出 $m$ 个区间，使得这 $m$ 个区间共同包含至少一个位置。换句话说，就是使得存在一个 $x$ ，使得对于每一个被选中的区间 $[l_i,r_i]$，都有 $l_i \leq x \leq r_i$ 。

对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。

区间 $[l_i,r_i]$ 的长度定义为 $(r_i-l_i)$ ，即等于它的右端点的值减去左端点的值。

求所有合法方案中最小的花费。如果不存在合法的方案，输出 $-1$。

## 说明/提示

#### 样例输入输出 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/qoddox9k.png)
 
 如图，当 $n=6$，$m=3$ 时，花费最小的方案是选取 $[3,5],[3,4],[1,4]$ 这三个区间，它们共同包含了 $4$ 这个位置，所以是合法的。其中最长的区间是 $[1, 4]$，最短的区间是 $[3, 4]$，所以它的花费是 $(4 - 1) - (4 - 3) = 2$。

#### 数据规模与约定

本题共 20 个测试点，各测试点信息如下表。
| 测试点编号 | $ n= $ | $ m= $ | $ l_i,r_i $ |
|:-:|:-:|:-:|:-:|
| 1 | $ 20 $ | $ 9 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 2 | $ 20 $ | $ 10 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 3 | $ 199 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 4 | $ 200 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 5 | $ 1000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 6 | $ 2000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 7 | $ 199 $ | $ 60 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 8 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 9 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 10 | $ 1999 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 11 | $ 2000 $ | $ 400 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 12 | $ 2000 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 13 | $ 30000 $ | $ 2000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 14 | $ 40000 $ | $ 1000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 15 | $ 50000 $ | $ 15000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 16 | $ 100000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 17 | $ 200000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 18 | $ 300000 $ | $ 50000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 19 | $ 400000 $ | $ 90000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 20 | $ 500000 $ | $ 200000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |

对于全部的测试点，保证 $1 \leq m \leq n$，$1 \leq n \leq 5 \times 10^5$，$1 \leq m \leq 2 \times 10^5$，$0 \leq l_i \leq r_i \leq 10^9$。

## 样例 #1

### 输入

```
6 3
3 5
1 2
3 4
2 2
1 5
1 4```

### 输出

```
2```

# AI分析结果

# 💡 Kay的C++算法解析：[NOI2016]区间 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：尺取法（双指针）+ 线段树（区间覆盖维护）


### 🗣️ 初步分析
解决“区间”问题的关键，在于**找到一组长度尽可能接近的m个区间，使得它们有公共交点**。我们可以把问题拆解为两步：  
1. **排序**：将所有区间按长度从小到大排序（因为要最小化“最长-最短”的差，最优解一定是连续长度的区间组合）；  
2. **滑动窗口**：用两个指针（左`L`、右`R`）维护一个窗口，窗口内的区间是当前考虑的候选集；  
3. **覆盖检查**：用线段树快速判断窗口内的区间是否有公共点（即某个点被覆盖了m次）。  

**比喻**：就像用一把“尺子”在排序后的区间序列上滑动，每次扩大右边界加入新区间，当满足条件（有公共点）时，尝试缩小左边界以寻找更优解（更小的长度差）。线段树则像一个“计数器”，实时统计每个点被覆盖的次数，告诉我们是否满足条件。


### 核心算法流程与可视化设计思路
1. **离散化**：将区间端点压缩到小范围（因为端点可能到1e9，直接用线段树会超空间）。比如把`[1,100]`、`[200,300]`压缩为`[1,2]`、`[3,4]`。  
2. **排序**：按区间长度排序，确保窗口内的区间长度是连续的。  
3. **双指针滑动**：  
   - 右指针`R`向右移动，将区间`[l_R, r_R]`加入线段树（覆盖次数+1）；  
   - 当线段树的最大值≥m时（有公共点），记录当前窗口的长度差（`len[R]-len[L]`），然后左指针`L`向右移动，将区间`[l_L, r_L]`从线段树中移除（覆盖次数-1），尝试寻找更优解。  
4. **可视化设计**：  
   - 用**8位像素风格**展示离散后的坐标轴，每个区间用不同颜色的矩形表示；  
   - 线段树的覆盖次数用**颜色深浅**表示（越深表示覆盖次数越多）；  
   - 双指针用**箭头**标记，滑动时实时更新覆盖次数和当前答案；  
   - 当满足条件时，播放“叮”的音效，并用闪烁效果标记公共点。


## 2. 精选优质题解参考

### 题解一（来源：上进的z君，赞81）
**点评**：  
这份题解的思路非常清晰，完美覆盖了“排序+双指针+线段树”的核心逻辑。代码结构规范，变量命名（如`tree`表示线段树、`add`表示懒标记）易于理解。**亮点**在于离散化的处理（将区间端点排序去重）和双指针的循环逻辑（先扩大右边界，再缩小左边界），非常符合新手的思维习惯。此外，线段树的区间更新和懒标记下传实现正确，是一份非常标准的参考代码。


### 题解二（来源：wanglichao1121，赞47）
**点评**：  
此题解的代码更加简洁，尤其是线段树的实现（用`ma`数组维护最大值，`ad`数组维护懒标记）。**亮点**在于双指针的循环方式（将左指针的移动放在循环开头），逻辑更加紧凑。此外，离散化的步骤（用`p`数组存储端点，排序去重）与题解一一致，但代码更短，适合学习如何简化代码。


### 题解三（来源：EternalEpic，赞38）
**点评**：  
这份题解的**亮点**在于作者分享了自己的踩坑经历（比如离散化时的下标错误、线段树查询最大值的简化），这些经验对新手非常有帮助。代码中的线段树实现（用`RMQ_SegmentTree`类封装）更加面向对象，适合学习如何组织代码结构。此外，作者提到“尺取法”的本质是“滑动窗口”，帮助新手理解算法的核心思想。


## 3. 核心难点辨析与解题策略

### 1. 离散化的正确处理
**难点**：区间端点可能到1e9，无法直接用线段树维护。  
**解决策略**：将所有端点收集起来，排序去重，然后用`lower_bound`将原端点映射到离散后的小下标。例如，原端点`[1,100,200,300]`离散后变为`[1,2,3,4]`。  
**学习笔记**：离散化是处理大区间问题的常用技巧，关键是要正确映射原端点到新下标。


### 2. 双指针的移动逻辑
**难点**：什么时候扩大右边界，什么时候缩小左边界？  
**解决策略**：  
- 右指针`R`：当当前窗口的覆盖次数不足m时，向右移动`R`，加入新区间；  
- 左指针`L`：当当前窗口的覆盖次数≥m时，向右移动`L`，移除旧区间，尝试寻找更优解。  
**学习笔记**：双指针的核心是“单调性”——右指针只会向右移动，左指针也只会向右移动，确保每个区间只被处理一次。


### 3. 线段树的区间更新与懒标记
**难点**：如何高效维护区间覆盖次数的最大值？  
**解决策略**：用线段树维护每个区间的**覆盖次数最大值**，并使用**懒标记**（`add`数组）记录未下传的更新。当需要更新一个区间时，直接修改该区间的懒标记和最大值，延迟下传更新到子节点。  
**学习笔记**：懒标记是线段树处理区间更新的关键，能将时间复杂度从O(n)降低到O(logn)。


### ✨ 解题技巧总结
- **排序**：将区间按长度排序，确保最优解是连续长度的组合；  
- **离散化**：处理大端点问题，压缩坐标范围；  
- **双指针**：滑动窗口寻找最优解，确保时间复杂度为O(nlogn)；  
- **线段树**：高效维护区间覆盖次数的最大值，判断是否满足条件。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合了优质题解的思路，实现了排序、离散化、双指针和线段树的核心逻辑。  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 5e5 + 10;
const int INF = 1e9;

struct Interval {
    int l, r, len;
    bool operator<(const Interval& other) const {
        return len < other.len;
    }
} intervals[MAXN];

vector<int> all_points;
int tree[MAXN << 2], add[MAXN << 2];

void push_down(int node, int l, int r) {
    if (add[node] == 0) return;
    int mid = (l + r) / 2;
    tree[node << 1] += add[node];
    tree[node << 1 | 1] += add[node];
    add[node << 1] += add[node];
    add[node << 1 | 1] += add[node];
    add[node] = 0;
}

void update(int node, int l, int r, int L, int R, int val) {
    if (L <= l && r <= R) {
        tree[node] += val;
        add[node] += val;
        return;
    }
    push_down(node, l, r);
    int mid = (l + r) / 2;
    if (L <= mid) update(node << 1, l, mid, L, R, val);
    if (R > mid) update(node << 1 | 1, mid + 1, r, L, R, val);
    tree[node] = max(tree[node << 1], tree[node << 1 | 1]);
}

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < n; ++i) {
        int l, r;
        cin >> l >> r;
        intervals[i].l = l;
        intervals[i].r = r;
        intervals[i].len = r - l;
        all_points.push_back(l);
        all_points.push_back(r);
    }
    // 离散化
    sort(all_points.begin(), all_points.end());
    all_points.erase(unique(all_points.begin(), all_points.end()), all_points.end());
    for (int i = 0; i < n; ++i) {
        intervals[i].l = lower_bound(all_points.begin(), all_points.end(), intervals[i].l) - all_points.begin() + 1;
        intervals[i].r = lower_bound(all_points.begin(), all_points.end(), intervals[i].r) - all_points.begin() + 1;
    }
    // 排序
    sort(intervals, intervals + n);
    // 双指针
    int L = 0, ans = INF;
    for (int R = 0; R < n; ++R) {
        update(1, 1, all_points.size(), intervals[R].l, intervals[R].r, 1);
        while (tree[1] >= m) {
            ans = min(ans, intervals[R].len - intervals[L].len);
            update(1, 1, all_points.size(), intervals[L].l, intervals[L].r, -1);
            L++;
        }
    }
    if (ans == INF) cout << -1 << endl;
    else cout << ans << endl;
    return 0;
}
```
**代码解读概要**：  
1. **离散化**：收集所有端点，排序去重，将原端点映射到小下标；  
2. **排序**：按区间长度排序；  
3. **双指针**：右指针`R`加入区间，左指针`L`移除区间，直到满足条件；  
4. **线段树**：维护区间覆盖次数的最大值，判断是否有公共点。


### 题解一（上进的z君）亮点赏析
**亮点**：离散化和双指针的标准实现。  
**核心代码片段**：  
```cpp
// 离散化
sort(p + 1, p + cur + 1, Cmp1);
int num = 0;
p[0].val = -1;
for (int i = 1; i <= cur; ++i) {
    if (p[i].val != p[i-1].val) num++;
    int u = p[i].ord;
    if (!L[u]) L[u] = num;
    else R[u] = num;
}
// 双指针
int ans = INF, le = 0, ri = 0;
while (true) {
    while (tree[1] < m && ri <= n) {
        ri++;
        int u = a[ri].ord, v = L[u], w = R[u];
        Update(1, 1, Right, v, w, 1);
    }
    if (tree[1] < m) break;
    while (tree[1] >= m && le <= n) {
        le++;
        int u = a[le].ord, v = L[u], w = R[u];
        Update(1, 1, Right, v, w, -1);
    }
    ans = min(ans, a[ri].len - a[le].len);
}
```
**代码解读**：  
- 离散化部分：用`p`数组存储所有端点，排序去重后映射到`L`和`R`数组；  
- 双指针部分：`ri`扩大右边界，`le`缩小左边界，每次更新答案。  
**学习笔记**：离散化的关键是“收集-排序-去重-映射”，双指针的关键是“循环条件”。


## 5. 算法可视化：像素动画演示（核心部分）

### 🎮 动画演示主题：《像素区间探险家》
**风格**：8位FC红白机风格，用像素块表示区间，颜色深浅表示覆盖次数。


### 🧩 核心演示内容
1. **初始化**：  
   - 屏幕显示离散后的坐标轴（如`1-10`的像素网格）；  
   - 下方显示双指针`L`（蓝色箭头）和`R`（红色箭头）；  
   - 右侧显示当前覆盖次数最大值和答案。  
2. **离散化过程**：  
   - 原端点（如`100`、`200`）逐渐压缩为小下标（如`1`、`2`），用“压缩”动画表示。  
3. **排序过程**：  
   - 区间按长度从小到大排列，用“移动”动画表示。  
4. **双指针滑动**：  
   - `R`向右移动，加入新区间（用绿色矩形表示，覆盖次数+1，颜色变深）；  
   - 当覆盖次数最大值≥m时，`L`向右移动，移除旧区间（绿色矩形消失，颜色变浅）；  
   - 每次更新答案时，播放“叮”的音效，并用黄色闪烁标记公共点。  
5. **结束**：  
   - 显示最终答案，播放“胜利”音效（如《超级马里奥》的通关音乐）。


### 🎯 设计思路
- **像素风格**：符合青少年的童年回忆，降低学习门槛；  
- **颜色编码**：用颜色区分区间、指针和覆盖次数，直观易懂；  
- **音效反馈**：用音效增强互动感，帮助记忆关键步骤；  
- **游戏化元素**：将双指针滑动设计为“探险”过程，增加趣味性。


## 6. 拓展练习与相似问题思考

### 📌 通用思路迁移
- **双指针+线段树**的组合，适用于**寻找连续区间满足某种条件**的问题，比如：  
  1. 区间覆盖次数超过k次的最短区间；  
  2. 区间和超过s的最短区间；  
  3. 区间内不同元素的数量超过k的最短区间。


### 📚 洛谷练习推荐
1. **洛谷 P1803** - 《线段覆盖》  
   - 推荐理由：练习区间排序和贪心策略，是本题的基础。  
2. **洛谷 P2082** - 《区间覆盖次数》  
   - 推荐理由：练习线段树的区间更新和最大值维护，与本题的线段树部分完全一致。  
3. **洛谷 P3397** - 《地毯》  
   - 推荐理由：练习离散化和线段树的区间加操作，是本题的离散化部分的强化。


## 7. 学习心得与经验分享（若有）

### 📝 来自题解的经验
- **EternalEpic**：离散化时要注意`lower_bound`的返回值是迭代器，减去`uni`（而不是`uni+1`）才能得到正确的下标；  
- **上进的z君**：双指针的循环条件要注意边界（如`ri <= n`），避免数组越界；  
- **wanglichao1121**：线段树的懒标记要正确下传，否则会导致覆盖次数计算错误。


### 💡 总结
- **离散化**：一定要先排序再去重，映射时要注意下标是否正确；  
- **双指针**：要理解“单调性”，确保每个区间只被处理一次；  
- **线段树**：懒标记是关键，要记住“先下传再更新”的顺序。


## 🎉 结语
本次分析了NOI2016的“区间”问题，核心是**尺取法+线段树**的组合。希望这份指南能帮助你理解算法的核心思想，掌握解题技巧。记住，编程的关键是**多练习+多总结**，下次遇到类似问题时，你一定能轻松解决！💪

---
处理用时：175.09秒
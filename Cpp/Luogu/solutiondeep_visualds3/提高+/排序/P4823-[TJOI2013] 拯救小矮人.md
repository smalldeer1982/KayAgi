# 题目信息

# [TJOI2013] 拯救小矮人

## 题目描述

一群小矮人掉进了一个很深的陷阱里，由于太矮爬不上来，于是他们决定搭一个人梯。即：一个小矮人站在另一小矮人的 肩膀上，直到最顶端的小矮人伸直胳膊可以碰到陷阱口。

对于每一个小矮人，我们知道他从脚到肩膀的高度 $A_i$，并且他的胳膊长度为 $B_i$。陷阱深度为 $H$。

如果我们利用矮人 $1$，矮人 $2$，矮人 $3$，……，矮人 $k$ 搭一个梯子，满足 $A_1+A_2+A_3+\dots+A_k+B_k \geq H$，那么矮人 $k$ 就可以离开陷阱逃跑了，一旦一个矮人逃跑了，他就不能再搭人梯了。  

我们希望尽可能多的小矮人逃跑，问最多可以使多少个小矮人逃跑。

## 说明/提示

对于 $30\%$ 的数据，$N\leq 200$；  

对于 $100\%$ 的数据，$1 \leq N\leq 2000$，$1 \leq A_i,B_i,H\leq10^5$。

## 样例 #1

### 输入

```
2
20 10
5 5
30```

### 输出

```
2```

## 样例 #2

### 输入

```
2
20 10
5 5
35```

### 输出

```
1```

# AI分析结果

# 💡 Kay的C++算法解析：[TJOI2013]拯救小矮人 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心策略 + 动态规划（背包问题变种）


### 🗣️ 初步分析
想象一下，一群小矮人被困在陷阱里，需要搭人梯逃跑。**最顶端的小矮人**要满足：**下面所有人的肩膀高度之和 + 自己的肩膀高度 + 臂长 ≥ 陷阱深度H**（其实更准确的是，下面人的肩膀高度之和 + 自己的臂长 ≥ H？不，等一下，题目描述是：如果用矮人1到k搭梯子，满足`A₁+A₂+…+Aₖ + Bₖ ≥ H`，那么矮人k可以逃跑。哦对，**A是肩膀高度**（站在别人肩膀上的高度），**B是臂长**（伸直胳膊的长度）。所以，矮人k站在前面k-1个矮人的肩膀上，总高度是`A₁+…+Aₖ`（他自己的肩膀高度也包含在内？不，等一下，题目中的描述是“矮人1站在矮人2的肩膀上，直到最顶端的矮人”，所以**A₁是最下面矮人的肩膀高度，A₂是上面矮人的肩膀高度**，总人梯高度是`A₁+A₂+…+Aₖ`（k个矮人的肩膀高度之和），然后最顶端的矮人k的臂长Bₖ加上这个总高度，只要≥H，他就能逃跑。逃跑后，他不再参与人梯，剩下的矮人继续搭。

我们的目标是**让尽可能多的矮人逃跑**。那怎么安排逃跑顺序呢？


### 🧠 核心算法思路
#### （1）贪心排序：谁先跑？
假设两个矮人i和j，**i的`Aᵢ+Bᵢ`比j的`Aⱼ+Bⱼ`小**。如果让i先跑，那么j后面跑的条件会更容易满足吗？  
举个例子：假设i的`Aᵢ=20，Bᵢ=10`（`A+B=30`），j的`Aⱼ=5，Bⱼ=5`（`A+B=10`）。陷阱深度H=35。如果让j先跑，那么j需要的人梯高度是`H - Bⱼ = 35-5=30`，而i的`Aᵢ=20`，加上j的`Aⱼ=5`，总人梯高度是25，不够。但如果让i先跑，i需要的人梯高度是`35-10=25`，而j的`Aⱼ=5`加上i的`Aᵢ=20`，总人梯高度是25，刚好满足。所以i先跑的话，两个人都能跑；而j先跑的话，只有i能跑。这说明，**`A+B`小的矮人应该先跑**，因为他们需要的“基础人梯高度”（H - B）更小，更容易满足，而且他们的`A`（肩膀高度）可能更大，跑了之后不会让剩下的人梯高度减少太多。

**结论**：按`Aᵢ+Bᵢ`从小到大排序，让“更难自己出去”（需要更低基础人梯）的矮人先跑。


#### （2）动态规划：选哪些人跑？
排序后，我们需要决定**选哪些矮人跑**，使得跑的人数最多，同时剩下的人梯高度足够支撑后面的矮人跑。  
这里用**背包问题**的思路：设`dp[j]`表示**跑了j个矮人后，剩下的人梯的最大高度**（剩下的矮人肩膀高度之和）。为什么要“最大高度”？因为剩下的高度越大，后面的矮人越容易跑（基础人梯高度足够）。

**状态转移**：对于第i个矮人（排序后的），如果跑了j-1个矮人后的剩余高度`dp[j-1]`加上他的臂长`Bᵢ`≥H（说明他可以站在j-1个矮人的人梯上跑），那么跑j个矮人的剩余高度就是`dp[j-1] - Aᵢ`（减去他的肩膀高度，因为他跑了，不再参与人梯）。我们要取最大值，所以`dp[j] = max(dp[j], dp[j-1] - Aᵢ)`。


#### （3）可视化设计思路
为了直观展示算法过程，我们可以做一个**8位像素风格的动画**：  
- **场景**：陷阱是一个垂直的像素条，高度为H（比如35像素）。小矮人是不同颜色的方块，`A`是方块的高度（比如20像素的红方块，5像素的蓝方块），`B`是方块顶部延伸的线条（比如10像素的黄线）。  
- **排序过程**：小矮人按`A+B`从小到大排列，从左到右站成一排。  
- **动态规划过程**：逐个处理小矮人，用“单步执行”展示是否选择让他跑：  
  - 如果`dp[j-1] + Bᵢ ≥ H`，则小矮人“跳”到人梯顶部，臂长线条碰到陷阱顶部，然后“消失”（表示跑了），剩余人梯高度减少`Aᵢ`（比如红方块跑了，剩余高度从25变成5）。  
  - 用进度条展示`dp[j]`的变化，用不同颜色标记已跑和未跑的小矮人。  
- **音效**：跑成功时播放“叮”的音效，剩余高度变化时播放“吱”的音效，增加趣味性。


## 2. 精选优质题解参考


### 📝 题解一：LengChu（赞50）—— 简洁的贪心+DP实现
* **点评**：这份题解的代码非常简洁，完美体现了“贪心排序+动态规划”的核心思路。  
  - **思路清晰**：先按`A+B`排序，再用`dp[j]`表示跑j个人后的最大剩余高度，状态转移逻辑直接。  
  - **代码规范**：变量名`a[i].a`（肩膀高度）、`a[i].b`（臂长）含义明确，循环结构工整。  
  - **算法有效**：动态规划的时间复杂度是O(n²)（n≤2000），完全满足题目要求。  
  - **实践价值**：代码可以直接用于竞赛，边界处理严谨（比如`dp`数组初始化为负无穷，`dp[0]`初始化为所有人的肩膀高度之和）。


### 📝 题解二：HsKr（赞34）—— 状态压缩的DP优化
* **点评**：这份题解解释了状态压缩的思路（将二维`f[i][j]`压缩为一维`f[j]`），帮助理解为什么可以省略`i`维度。  
  - **思路拓展**：提到“背包的`i`那一维可以压缩掉”，因为处理第i个矮人时，只需要用到`j-1`的状态，倒序循环即可避免覆盖。  
  - **代码可读性**：用`read()`函数优化输入，`write()`函数优化输出，适合竞赛中的快速处理。


### 📝 题解三：Sol1（赞7）—— O(nlogn)的贪心+优先队列
* **点评**：这份题解的思路非常巧妙，用优先队列优化了贪心过程，时间复杂度降到O(nlogn)。  
  - **亮点**：先让能跑的矮人跑，然后用优先队列维护已跑矮人的`A`（肩膀高度），如果当前矮人不能跑，就替换已跑矮人中`A`最大的（因为他的`A`大，跑了之后剩余高度减少多，替换他可以增加剩余高度）。  
  - **代码简洁**：用`priority_queue`存储已跑矮人，逻辑清晰，适合学习贪心的“反悔”策略。


## 3. 核心难点辨析与解题策略


### 🧩 核心难点1：为什么按`A+B`排序？
* **分析**：假设两个矮人i和j，`Aᵢ+Bᵢ < Aⱼ+Bⱼ`。如果让j先跑，那么i后面跑的条件是`剩余高度 + Aᵢ + Bᵢ ≥ H`，而如果让i先跑，j后面跑的条件是`剩余高度 + Aⱼ + Bⱼ ≥ H`。由于`Aᵢ+Bᵢ < Aⱼ+Bⱼ`，让i先跑的话，j的条件更容易满足。用**邻项交换法**可以严格证明：交换i和j的顺序会导致结果更差。  
* 💡 **学习笔记**：排序策略是贪心的核心，要找到“最优子结构”（局部最优导致全局最优）。


### 🧩 核心难点2：为什么`dp[j]`要表示“最大剩余高度”？
* **分析**：剩余高度越大，后面的矮人越容易跑（因为`剩余高度 + Bᵢ ≥ H`的条件更容易满足）。比如，跑j个人后，剩余高度是100，比剩余高度是50的情况，后面的矮人更容易满足条件。所以我们要最大化`dp[j]`，这样才能让后面的矮人有更多机会跑。  
* 💡 **学习笔记**：动态规划的状态定义要服务于“最优目标”，这里的“最大剩余高度”就是为了后续的最优选择。


### 🧩 核心难点3：状态转移的条件是什么？
* **分析**：状态转移的条件是`dp[j-1] + Bᵢ ≥ H`，这表示**跑了j-1个人后，剩余的人梯高度加上当前矮人的臂长，刚好能让他跑出去**。此时，跑j个人后的剩余高度是`dp[j-1] - Aᵢ`（减去他的肩膀高度，因为他跑了）。  
* 💡 **学习笔记**：状态转移的条件要严格对应题目要求，不能漏掉任何约束。


### ✨ 解题技巧总结
1. **贪心排序**：找到“局部最优”的排序策略，比如按`A+B`从小到大排序。  
2. **动态规划**：用背包问题的思路处理选择问题，状态定义要服务于最优目标（比如最大剩余高度）。  
3. **状态压缩**：将二维DP压缩为一维，减少空间复杂度（比如`dp[j]`代替`f[i][j]`）。  
4. **边界处理**：初始化`dp`数组为负无穷，`dp[0]`初始化为所有人的肩膀高度之和（没跑任何人时，人梯高度是所有人的肩膀高度之和）。


## 4. C++核心代码实现赏析


### 🖥️ 本题通用核心C++实现参考
* **说明**：综合LengChu和HsKr的题解，提炼出最简洁的核心实现。  
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <algorithm>
  #include <cstring>
  using namespace std;

  struct Node {
      int a, b; // a: 肩膀高度，b: 臂长
  };

  bool cmp(Node x, Node y) {
      return x.a + x.b < y.a + y.b; // 按A+B从小到大排序
  }

  int main() {
      int n, H;
      cin >> n;
      Node a[2010];
      int dp[2010]; // dp[j]: 跑了j个人后的最大剩余高度
      memset(dp, -0x3f, sizeof(dp)); // 初始化为负无穷
      dp[0] = 0; // 没跑任何人时，剩余高度是所有人的肩膀高度之和？不，等一下，初始化应该是：
      for (int i = 0; i < n; i++) {
          cin >> a[i].a >> a[i].b;
          dp[0] += a[i].a; // 对，没跑任何人时，人梯高度是所有人的肩膀高度之和
      }
      cin >> H;
      sort(a, a + n, cmp); // 排序

      for (int i = 0; i < n; i++) { // 处理第i个矮人（排序后的）
          for (int j = i + 1; j >= 1; j--) { // 倒序循环，避免覆盖
              if (dp[j-1] + a[i].b >= H) { // 可以跑
                  dp[j] = max(dp[j], dp[j-1] - a[i].a); // 剩余高度减少a[i].a
              }
          }
      }

      // 找最大的j，使得dp[j] >= 0（剩余高度非负，说明可以跑j个人）
      for (int j = n; j >= 0; j--) {
          if (dp[j] >= 0) {
              cout << j << endl;
              return 0;
          }
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  - **输入与初始化**：读取n个矮人的`a`和`b`，初始化`dp[0]`为所有人的肩膀高度之和（没跑任何人时，人梯高度是所有人的肩膀高度之和）。  
  - **排序**：按`A+B`从小到大排序。  
  - **动态规划**：逐个处理矮人，倒序循环j（避免覆盖），如果可以跑（`dp[j-1] + a[i].b >= H`），则更新`dp[j]`为`max(dp[j], dp[j-1] - a[i].a)`。  
  - **结果查找**：从n到0遍历，找到第一个`dp[j] >= 0`的j，就是最多能跑的人数。


### 📌 题解一（LengChu）代码片段赏析
* **亮点**：状态定义清晰，转移逻辑直接。  
* **核心代码片段**：
  ```cpp
  for (int i = 1; i <= n; i++) {
      for (int j = i; j >= 1; j--) {
          if (dp[j-1] + a[i].b >= H) {
              dp[j] = max(dp[j], dp[j-1] - a[i].a);
          }
      }
  }
  ```
* **代码解读**：  
  - 外层循环处理第i个矮人（排序后的）。  
  - 内层循环倒序处理j（跑了j个人的情况），因为处理j时需要用到j-1的状态，倒序可以避免覆盖。  
  - 条件`dp[j-1] + a[i].b >= H`表示：跑了j-1个人后，剩余的人梯高度加上当前矮人的臂长，刚好能让他跑出去。  
  - 状态转移`dp[j] = max(dp[j], dp[j-1] - a[i].a)`表示：跑j个人后的剩余高度是跑j-1个人后的剩余高度减去当前矮人的肩膀高度（因为他跑了，不再参与人梯）。  
* 💡 **学习笔记**：倒序循环是状态压缩的关键，避免覆盖未处理的状态。


### 📌 题解三（Sol1）代码片段赏析
* **亮点**：O(nlogn)的贪心+优先队列优化。  
* **核心代码片段**：
  ```cpp
  priority_queue<pair<int, int>> que; // 存储已跑矮人的a（肩膀高度），大根堆
  for (int i = 1; i <= n; i++) {
      if (sum + a[i].second >= H) { // 可以跑
          que.push(a[i]);
          sum -= a[i].first;
      } else {
          if (!que.empty() && sum + a[i].second + que.top().first >= H && que.top() >= a[i]) {
              sum += que.top().first;
              que.pop();
              que.push(a[i]);
              sum -= a[i].first;
          }
      }
  }
  cout << que.size();
  ```
* **代码解读**：  
  - **优先队列**：存储已跑矮人的`a`（肩膀高度），大根堆（最大的`a`在顶部）。  
  - **处理每个矮人**：如果当前矮人可以跑（`sum + a[i].b >= H`），则加入队列，sum减去他的`a`（剩余高度减少）。  
  - **替换策略**：如果当前矮人不能跑，就看队列中有没有`a`比他大的矮人（因为替换他可以增加剩余高度），如果替换后当前矮人可以跑，则替换。  
* 💡 **学习笔记**：贪心的“反悔”策略可以优化时间复杂度，适合处理动态选择问题。


## 5. 算法可视化：像素动画演示 (核心部分)


### 🎮 动画演示主题：《小矮人逃生记》（8位像素风格）
* **场景设计**：  
  - 陷阱：垂直的像素条，高度为H（比如35像素），底部是泥土色，顶部是天空色。  
  - 小矮人：不同颜色的方块，`a`是方块的高度（比如20像素的红方块，5像素的蓝方块），`b`是方块顶部延伸的黄色线条（比如10像素）。  
  - 控制面板：有“开始/暂停”“单步执行”“重置”按钮，速度滑块，以及“剩余高度”进度条。


### 🚶 动画帧步骤
1. **初始化**：小矮人按`A+B`从小到大排列，站在陷阱底部，剩余高度进度条显示为所有人的肩膀高度之和（比如25像素）。  
2. **处理第一个矮人（红方块，`a=20，b=10`）**：  
   - 单步执行：红方块“跳”到人梯顶部，黄色线条碰到陷阱顶部（35像素），播放“叮”的音效。  
   - 剩余高度进度条减少20像素（变为5像素），红方块“消失”（表示跑了）。  
3. **处理第二个矮人（蓝方块，`a=5，b=5`）**：  
   - 单步执行：蓝方块“跳”到人梯顶部（剩余高度5像素），黄色线条延伸5像素，总高度5+5=10像素，不够35？不，等一下，题目中的条件是`A₁+…+Aₖ + Bₖ ≥ H`，比如第一个矮人跑了之后，剩下的矮人是蓝方块，他的`A`是5，`B`是5，剩余高度是5（红方块跑了，所以剩余高度是蓝方块的`A`？不对，等一下，初始时`dp[0]`是所有人的`A`之和（20+5=25），第一个矮人跑了之后，`dp[1]`是25-20=5（蓝方块的`A`）。第二个矮人跑的条件是`dp[1] + B₂ =5+5=10 ≥ H=35？`不，样例1中的H是30，所以第一个矮人跑的条件是`dp[0] + B₁=25+10=35 ≥30`，是的。第二个矮人跑的条件是`dp[1] + B₂=5+5=10 ≥30？`不对，样例1的输出是2，说明第二个矮人也能跑。哦，等一下，样例1的输入是：  
     - 2个矮人：第一个`A=20，B=10`，第二个`A=5，B=5`，H=30。  
     - 排序后，第二个矮人（`A+B=10`）先处理？不，等一下，`A+B`从小到大排序，第二个矮人是`5+5=10`，第一个是`20+10=30`，所以排序后顺序是第二个矮人先处理。哦，我之前的例子搞反了！抱歉，样例1中的正确排序应该是第二个矮人（`A=5，B=5`）先处理，因为他的`A+B=10`比第一个的`30`小。  
     - 那重新来：样例1的处理过程：  
       - 初始化`dp[0] =5+20=25`（两个矮人的`A`之和）。  
       - 处理第一个矮人（蓝方块，`A=5，B=5`）：`dp[0] + B=25+5=30 ≥H=30`，所以`dp[1] =25-5=20`（剩下的矮人是红方块，`A=20`）。  
       - 处理第二个矮人（红方块，`A=20，B=10`）：`dp[1] + B=20+10=30 ≥H=30`，所以`dp[2] =20-20=0`。  
       - 结果是2，正确。  
     哦，原来我之前的例子排序顺序搞反了！抱歉，这说明排序策略的重要性。那动画中的处理顺序应该是：**`A+B`小的矮人先处理**。


### 🎵 音效与交互设计
- **关键操作音效**：跑成功时播放“叮”的音效，剩余高度变化时播放“吱”的音效。  
- **交互控制**：支持“单步执行”（逐个人处理）、“自动播放”（按速度滑块设置的速度播放）、“重置”（回到初始状态）。  
- **信息展示**：在动画右侧显示当前处理的矮人信息（`A`、`B`、`A+B`），剩余高度进度条，以及已跑人数。


## 6. 拓展练习与相似问题思考


### 🧬 通用思路/技巧迁移
- **贪心排序**：适用于需要“局部最优导致全局最优”的问题，比如《皇后游戏》（P2123）、《纪念品分组》（P1094）。  
- **动态规划（背包问题）**：适用于需要选择物品使得目标最大化的问题，比如《多米诺骨牌》（P1282）、《背包问题》（P1048）。


### 📚 练习推荐 (洛谷)
1. **洛谷 P1094 纪念品分组**  
   - 🗣️ **推荐理由**：这道题考察贪心排序策略，需要将纪念品分成若干组，每组的总价值不超过给定值，求最少分组数。类似本题的“排序+选择”思路。  
2. **洛谷 P1282 多米诺骨牌**  
   - 🗣️ **推荐理由**：这道题考察动态规划（背包问题变种），需要调整多米诺骨牌的方向，使得相邻骨牌的点数差之和最小。类似本题的“状态定义+转移”思路。  
3. **洛谷 P2123 皇后游戏**  
   - 🗣️ **推荐理由**：这道题考察贪心排序的证明（邻项交换法），需要将皇后按一定顺序排列，使得总时间最小。类似本题的“排序策略证明”思路。


## 7. 学习心得与经验分享 (若有)


### 📝 参考经验（来自LengChu）
> “我在解决这个问题时，最初没有想到按`A+B`排序，而是按`A`排序，结果样例没过。后来通过调试，发现`A+B`小的矮人先跑的话，后面的矮人更容易满足条件。这让我意识到，贪心策略的正确性需要严格证明，不能凭直觉。”

* **点评**：这位作者的经验很典型。在编程过程中，**调试**是发现问题的关键。如果直觉的排序策略不对，不妨尝试用样例验证，或者用邻项交换法证明。


## 🎉 结语
本次关于《[TJOI2013]拯救小矮人》的C++解题分析就到这里。希望这份学习指南能帮助大家理解**贪心+动态规划**的结合应用，掌握排序策略、状态定义、状态转移的核心技巧。记住，编程能力的提升在于**持续学习、勤于思考、勇于实践**。下次我们再一起探索新的编程挑战！💪

---
处理用时：228.74秒
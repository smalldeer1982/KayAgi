# 题目信息

# 「SWTR-5」Chain

## 题目描述

给定 $n$ 个点，$m$ 条边的有向无环图。不保证图连通。

$q$ 次询问，每次给出 $k$ 和 $k$ 个互不相同的数 $c_i$，求出如果去掉这 $k$ 个点，整个有向无环图将剩余多少条链。答案对 $10^9+7$ 取模。**每次询问独立。**

- “链”的定义是：我们设一条长度为 $p$ 的链的路径为 $w_0\to w_1\to\cdots\to w_{p-1}\to w_p$，则应满足 $w_0$ 入度为 $0$，$w_p$ 出度为 $0$。你可以将其理解为一条食物链。

- 两条链是“不同的”，当且仅当它们的长度不同，或者经过的点集不同。

- **需要特别注意的是，删去某些点后新产生的链不计入答案。** 例如 $1\to 2\to 3\to 4$ 一图中，有 $1$ 条链 $1\to 2\to 3\to 4$。如果去掉 $2$ 号点，则剩余 $0$ 条链。

## 说明/提示

「样例 $1$ 说明」

DAG 如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2gbdoemh.png)

询问 $1$：如果去掉 $2,4,6$，则剩余 $1$ 条链：$3\to 5$。

询问 $2$：如果去掉 $4,6$，则剩余 $3$ 条链：$3\to 5$，$3\to 2\to 5$，$3\to 7\to 2\to 5$。

询问 $7$：如果去掉 $6$，则剩余 $5$ 条链：$3\to 5$，$3\to 2\to 5$，$3\to 7\to 2\to 5$，$3\to 1\to 4\to 5$，$3\to 7\to 4\to 5$。

「数据范围与约定」

**本题采用捆绑测试。**

- Subtask 1（1 point）：给定的图是一条链。
- Subtask 2（14 points）：$n,q\leq 10$。
- Subtask 3（20 points）：$q\leq 10^3$。
- Subtask 4（17 points）：$k=1$。
- Subtask 5（18 points）：$k=2$。
- Subtask 6（30 points）：无特殊限制。

对于 $100\%$ 的数据：$2\leq n\leq 2\times 10^3$，$1\leq m\leq \min(\frac{n\times(n-1)}{2},2\times 10^4)$，$1\leq q\leq 5\times 10^5$。  
所有询问满足：$1\leq \sum k\leq 2\times 10^6$，$0\leq k\leq \min(n,15)$，$1\leq c_i\leq n$。保证 $c_i$ 互不相同。

**本题轻微卡常，请注意 IO 优化。**

---

「题目来源」

[Sweet Round 05](https://www.luogu.com.cn/contest/28195) D。  
idea & solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。

## 样例 #1

### 输入

```
7 14
3 2
4 5
2 5
2 6
3 1
3 5
3 7
3 6
6 4
1 4
6 5
1 6
7 2
7 4
7
3 2 4 6
2 4 6
2 2 5
2 1 4
0
1 4
1 6```

### 输出

```
1
3
0
6
13
7
5```

## 样例 #2

### 输入

```
233 1
1 2
6
0
1 10
2 10 40
1 1
1 2
2 1 2```

### 输出

```
232
231
230
231
231
231```

# AI分析结果

# 💡 Kay的C++算法解析：「SWTR-5」Chain 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：拓扑排序 + 动态规划（路径计数） + 容斥原理（处理多元素删除）


### 🗣️ 初步分析
我们的任务是处理一个**有向无环图（DAG）**的多次询问：每次删除`k`个点后，统计剩余的**链**（从入度为0的点到出度为0的点的路径）数量。注意，删除点后新产生的链不算（比如原链`1→2→3→4`，删`2`后没有新链）。

#### 核心算法比喻
- **拓扑排序**：像学校排队打饭，只有前面的人打完，后面的人才能打——DAG中的节点必须按“依赖顺序”处理（没有前驱的节点先处理）。
- **动态规划（路径计数）**：像统计从家到学校的路线数，每到一个路口，把前面所有路口的路线数加起来。
- **容斥原理**：像计算“不选苹果也不选香蕉”的水果数量，需要用总数减去选苹果、选香蕉的数量，再加上同时选两者的数量（避免重复减）。


#### 题解思路与核心难点
所有题解的核心思路一致：
1. **预处理**：通过拓扑排序计算**任意两点间的路径数**（`h[i][j]`表示`i`到`j`的路径数）、**入度0到各点的路径数**（`f[i]`）、**各点到出度0的路径数**（`g[i]`）。
2. **处理询问**：对于每个询问的`k`个点，按**拓扑序排序**（确保前面的点不会依赖后面的点），用**容斥原理**计算删除这些点后剩余的链数（总数减去包含删除点的路径数，避免重复计算）。

**核心难点**：
- **如何避免重复计算**：当删除多个点时，直接减去每个点的贡献会重复减去同时经过多个删除点的路径（比如路径`a→b→c`，删`a`和`b`，直接减`f[a]g[a] + f[b]g[b]`会重复减`f[a]h[a][b]g[b]`）。
- **预处理效率**：`n<=2e3`，`h[i][j]`的计算是`O(n^2)`，刚好符合时间限制。
- **拓扑序的应用**：按拓扑序处理删除的点，确保前面的点的贡献已经被处理，后面的点可以正确减去前面点的影响。


#### 可视化设计思路
我们用**8位像素风格**（类似FC游戏）展示算法流程：
- **场景**：像素化的DAG（节点是彩色方块，边是箭头），顶部有“控制面板”（开始/暂停、单步、速度滑块）。
- **拓扑排序**：节点按顺序“亮起”（从入度0的点开始，逐渐扩散），旁边显示当前处理的节点。
- **路径计数**：节点颜色深浅表示`f[i]`的大小（越深表示路径数越多），边闪烁表示路径被统计。
- **容斥处理**：删除的点变成“灰色”，旁边显示“减去`f[c[i]]g[c[i]]`”的提示，同时动态调整剩余路径数（用数字跳动表示）。
- **音效**：拓扑排序时播放“叮”的音效，路径计数时播放“沙沙”声，容斥处理时播放“咚”的音效，完成时播放“胜利”音效。


## 2. 精选优质题解参考

### 📝 题解一（来源：a___，赞：8）
* **点评**：这份题解的代码简洁到“让人眼前一亮”！作者用拓扑排序预处理了`f`（入度0到各点的路径数）、`g`（各点到出度0的路径数）、`h`（任意两点间的路径数），然后对于每个询问：
  1. 将删除的点按**拓扑序排序**（确保处理顺序正确）；
  2. 用`d`数组记录**不经过前面删除点的情况下，入度0到当前删除点的路径数**（`d[i] = f[c[i]] - sum(d[j] * h[c[j]][c[i]])`，`j<i`）；
  3. 最终答案等于总数减去`sum(d[i] * g[c[i]])`（所有包含删除点的路径数）。  
  代码的**亮点**是用拓扑序排序和容斥处理，时间复杂度`O(nm + k∑k)`，完美应对`q<=5e5`的大量询问。


### 📝 题解二（来源：EnofTaiPeople，赞：3）
* **点评**：作者的思路非常“直观”！预处理了`onto[i]`（入度0到`i`的路径数）、`znto[i]`（`i`到出度0的路径数），然后对于每个询问：
  1. 将删除的点按拓扑序排序；
  2. 用`ans[i]`记录**不经过前面删除点的情况下，入度0到当前删除点的路径数**（`ans[i] = onto[c[i]] - sum(ans[j] * h[c[j]][c[i]])`，`j<i`）；
  3. 最终答案等于总数减去`sum(ans[i] * znto[c[i]])`。  
  代码的**亮点**是用`onto`和`znto`数组简化了路径计数，容易理解。


### 📝 题解三（来源：xie_lzh，赞：0）
* **点评**：这份题解的代码“接地气”，适合新手学习！作者预处理了`st[i]`（入度0到`i`的路径数）、`ed[i]`（`i`到出度0的路径数），然后对于每个询问：
  1. 将删除的点按拓扑序排序；
  2. 用`kk[i]`记录**不经过前面删除点的情况下，入度0到当前删除点的路径数**（`kk[i] = st[c[i]] - sum(kk[j] * h[c[j]][c[i]])`，`j<i`）；
  3. 最终答案等于总数减去`sum(kk[i] * ed[c[i]])`。  
  代码的**亮点**是注释详细，步骤清晰，容易跟随。


## 3. 核心难点辨析与解题策略

### 🧩 关键点1：如何预处理路径数？
* **分析**：路径数的计算是基础，必须用拓扑排序保证正确性。例如，`h[i][j]`（`i`到`j`的路径数）的计算方法是：对于每个节点`u`，遍历其出边`v`，将`h[i][v] += h[i][u]`（所有从`i`到`u`的路径都可以延伸到`v`）。
* 💡 **学习笔记**：拓扑排序是DAG路径计数的“基石”，必须掌握！


### 🧩 关键点2：如何处理多元素删除的容斥？
* **分析**：当删除多个点时，直接减去每个点的贡献会重复计算。例如，删除`a`和`b`，路径`a→b→c`会被减去两次（`f[a]g[a]`和`f[b]g[b]`），所以需要加上`f[a]h[a][b]g[b]`（同时经过`a`和`b`的路径数）。容斥的核心是**按拓扑序处理，逐步减去前面点的影响**。
* 💡 **学习笔记**：容斥原理的关键是“有序处理”，拓扑序是解决这个问题的“钥匙”。


### 🧩 关键点3：如何优化询问处理效率？
* **分析**：`q<=5e5`，`k<=15`，所以询问处理的时间复杂度必须是`O(k^2)`。作者们都用了**拓扑序排序**和**动态规划**（`d[i]`或`kk[i]`）来实现这一点，确保每个询问的处理时间在可接受范围内。
* 💡 **学习笔记**：预处理是应对大量询问的“法宝”，必须提前计算好所有需要的信息。


### ✨ 解题技巧总结
1. **拓扑排序**：处理DAG问题的“标配”，用于保证路径计数的正确性。
2. **路径计数**：用动态规划统计`f[i]`（入度0到`i`）、`g[i]`（`i`到出度0）、`h[i][j]`（`i`到`j`），为后续处理提供基础。
3. **容斥原理**：处理多元素删除的“利器”，按拓扑序处理，逐步减去前面点的影响，避免重复计算。
4. **预处理**：提前计算所有需要的信息，应对大量询问（`q<=5e5`）。


## 4. C++核心代码实现赏析

### 📌 本题通用核心C++实现参考
* **说明**：综合了a___、EnofTaiPeople、xie_lzh的题解思路，提取了核心代码框架。
* **完整核心代码**：
  ```cpp
  #include <cstdio>
  #include <algorithm>
  #include <vector>
  #include <queue>
  using namespace std;

  const int N = 2010, M = 20010, MOD = 1e9 + 7;
  int n, m, q;
  vector<int> G[N]; // 图的邻接表
  int in_degree[N]; // 入度
  int f[N], g[N]; // f[i]: 入度0到i的路径数；g[i]: i到出度0的路径数
  int h[N][N]; // h[i][j]: i到j的路径数
  int topo_order[N], topo_cnt; // 拓扑序
  int c[N]; // 询问的删除点

  // 拓扑排序，计算f、h、拓扑序
  void topo_sort() {
      queue<int> q;
      for (int i = 1; i <= n; ++i) {
          if (in_degree[i] == 0) {
              q.push(i);
              f[i] = 1; // 入度0的点，路径数为1
          }
      }
      while (!q.empty()) {
          int u = q.front();
          q.pop();
          topo_order[++topo_cnt] = u; // 记录拓扑序
          h[u][u] = 1; // 自己到自己的路径数为1
          for (int v : G[u]) {
              // 更新f[v]：入度0到v的路径数 += 入度0到u的路径数
              f[v] = (f[v] + f[u]) % MOD;
              // 更新h[i][v]：所有i到u的路径都可以延伸到v
              for (int i = 1; i <= n; ++i) {
                  h[i][v] = (h[i][v] + h[i][u]) % MOD;
              }
              in_degree[v]--;
              if (in_degree[v] == 0) {
                  q.push(v);
              }
          }
      }
  }

  // 计算g数组（i到出度0的路径数）
  void calc_g() {
      vector<int> out_degree(n + 1, 0);
      for (int u = 1; u <= n; ++u) {
          out_degree[u] = G[u].size();
      }
      queue<int> q;
      for (int i = 1; i <= n; ++i) {
          if (out_degree[i] == 0) {
              q.push(i);
              g[i] = 1; // 出度0的点，路径数为1
          }
      }
      // 逆拓扑序处理
      for (int i = topo_cnt; i >= 1; --i) {
          int u = topo_order[i];
          for (int v : G[u]) {
              g[u] = (g[u] + g[v]) % MOD;
              out_degree[u]--;
              if (out_degree[u] == 0) {
                  q.push(u);
              }
          }
      }
  }

  // 比较函数：按拓扑序排序
  bool cmp(int x, int y) {
      // 找到x和y在拓扑序中的位置
      for (int i = 1; i <= topo_cnt; ++i) {
          if (topo_order[i] == x) x = i;
          if (topo_order[i] == y) y = i;
      }
      return x < y;
  }

  int main() {
      scanf("%d%d", &n, &m);
      for (int i = 0; i < m; ++i) {
          int u, v;
          scanf("%d%d", &u, &v);
          G[u].push_back(v);
          in_degree[v]++;
      }
      // 预处理f、h、拓扑序
      topo_sort();
      // 预处理g
      calc_g();
      // 计算初始答案（所有链的数量）
      int total = 0;
      for (int i = 1; i <= n; ++i) {
          if (G[i].empty()) { // 出度0的点
              total = (total + f[i]) % MOD;
          }
      }
      // 处理询问
      scanf("%d", &q);
      while (q--) {
          int k;
          scanf("%d", &k);
          for (int i = 1; i <= k; ++i) {
              scanf("%d", &c[i]);
          }
          // 按拓扑序排序删除的点
          sort(c + 1, c + k + 1, cmp);
          // 计算d数组：不经过前面删除点的情况下，入度0到c[i]的路径数
          vector<int> d(k + 1, 0);
          for (int i = 1; i <= k; ++i) {
              d[i] = f[c[i]];
              for (int j = 1; j < i; ++j) {
                  d[i] = (d[i] - 1LL * d[j] * h[c[j]][c[i]] % MOD + MOD) % MOD;
              }
          }
          // 计算答案：total - sum(d[i] * g[c[i]])
          int ans = total;
          for (int i = 1; i <= k; ++i) {
              ans = (ans - 1LL * d[i] * g[c[i]] % MOD + MOD) % MOD;
          }
          printf("%d\n", ans);
      }
      return 0;
  }
  ```
* **代码解读概要**：
  1. **拓扑排序**：计算`f`（入度0到各点的路径数）、`h`（任意两点间的路径数）、拓扑序。
  2. **计算g数组**：逆拓扑序计算`g`（各点到出度0的路径数）。
  3. **处理询问**：按拓扑序排序删除的点，用`d`数组记录不经过前面删除点的路径数，然后用容斥原理计算答案。


### 📌 题解一（a___）核心代码片段赏析
* **亮点**：用拓扑序排序和`d`数组进行容斥，代码简洁。
* **核心代码片段**：
  ```cpp
  // 按拓扑序排序删除的点
  sort(c + 1, c + 1 + m, cmp);
  // 计算d数组
  for (int i = 1; i <= m; ++i) d[i] = f[c[i]];
  for (int i = 1; i <= m; ++i)
      for (int j = i + 1; j <= m; ++j)
          d[j] = (d[j] - 1LL * d[i] * h[c[i]][c[j]] % MOD + MOD) % MOD;
  // 计算答案
  for (int i = 1; i <= m; ++i) ans = (ans - 1LL * d[i] * g[c[i]] % MOD + MOD) % MOD;
  ```
* **代码解读**：
  - `sort(c + 1, c + 1 + m, cmp)`：按拓扑序排序删除的点，确保前面的点不会依赖后面的点。
  - `d[i] = f[c[i]]`：初始时，`d[i]`表示入度0到`c[i]`的路径数（包含所有路径）。
  - `d[j] -= d[i] * h[c[i]][c[j]]`：减去经过`c[i]`再到`c[j]`的路径数（避免重复计算）。
  - `ans -= d[i] * g[c[i]]`：减去包含`c[i]`的路径数（`d[i]`是不经过前面删除点的路径数，`g[c[i]]`是`c[i]`到出度0的路径数）。
* 💡 **学习笔记**：拓扑序排序是容斥的关键，`d`数组的计算是避免重复的核心。


## 5. 算法可视化：像素动画演示 (核心部分)

### 🎮 动画演示主题：《像素链探险》
采用8位像素风格（类似FC游戏《超级马里奥》），展示DAG的拓扑排序、路径计数、容斥处理过程。


### 📊 核心演示内容
1. **场景初始化**：
   - 屏幕左侧显示像素化的DAG（节点是彩色方块，边是箭头），右侧是“控制面板”（开始/暂停、单步、速度滑块）。
   - 顶部显示“初始链数：XX”（`total`的值）。

2. **拓扑排序**：
   - 入度0的节点（比如`3`）变成“黄色”，并播放“叮”的音效。
   - 节点按拓扑序依次“亮起”（从`3`到`1`、`7`、`2`、`6`、`4`、`5`），旁边显示“处理节点：X”。
   - 路径计数：节点颜色深浅表示`f[i]`的大小（`3`的`f`是1，颜色最浅；`5`的`f`是13，颜色最深）。

3. **路径计数**：
   - 边闪烁表示路径被统计（比如`3→1`的边闪烁，`f[1]`增加1）。
   - 节点下方显示`f[i]`的值（比如`1`的下方显示“f=1”）。

4. **容斥处理（询问示例）**：
   - 询问：删除`2`、`4`、`6`（样例1的第一个询问）。
   - 删除的节点变成“灰色”，旁边显示“删除点：2、4、6”。
   - 按拓扑序处理：`2`（拓扑序4）、`4`（拓扑序6）、`6`（拓扑序5）→ 排序后是`2`、`6`、`4`。
   - 计算`d`数组：`d[1] = f[2] = 2`（入度0到`2`的路径数）；`d[2] = f[6] - d[1] * h[2][6] = 4 - 2*1 = 2`（不经过`2`的情况下，入度0到`6`的路径数）；`d[3] = f[4] - d[1] * h[2][4] - d[2] * h[6][4] = 6 - 2*1 - 2*1 = 2`（不经过`2`、`6`的情况下，入度0到`4`的路径数）。
   - 答案计算：`total - d[1]*g[2] - d[2]*g[6] - d[3]*g[4] = 13 - 2*3 - 2*2 - 2*1 = 1`（样例1的输出）。
   - 动态显示答案变化（数字从13跳到1），播放“胜利”音效。


### 🎨 设计思路
- **像素风格**：营造复古游戏氛围，让学习者感到亲切。
- **颜色编码**：用颜色深浅表示路径数大小，直观展示数据变化。
- **音效提示**：关键操作（拓扑排序、路径计数、容斥处理）用不同音效，强化记忆。
- **交互控制**：支持单步执行、自动播放、速度调整，让学习者可以仔细观察每一步。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路/技巧迁移
- **拓扑排序**：适用于所有DAG问题（如路径计数、最长路径、最小路径覆盖）。
- **路径计数**：适用于统计图中路径数的问题（如洛谷P1113《路径计数》）。
- **容斥原理**：适用于处理多元素删除、多条件交集的问题（如洛谷P1807《最长路径》的变形）。


### 📚 练习推荐 (洛谷)
1. **洛谷 P1113** - 《路径计数》  
   🗣️ **推荐理由**：这道题是拓扑排序+路径计数的基础题，帮助你巩固`f[i]`（入度0到`i`的路径数）的计算。

2. **洛谷 P1807** - 《最长路径》  
   🗣️ **推荐理由**：这道题需要用拓扑排序计算最长路径，是路径计数的变形，帮助你理解动态规划在DAG中的应用。

3. **洛谷 P2016** - 《最小路径覆盖》  
   🗣️ **推荐理由**：这道题需要用拓扑排序+二分图匹配，是DAG问题的进阶练习，帮助你拓展思路。


## 7. 学习心得与经验分享 (若有)

### 📝 参考经验（来自a___）
> “我在解决这个问题时，最初没想到用拓扑序排序删除的点，导致容斥处理错误。后来通过手玩样例，发现拓扑序可以保证前面的点不会依赖后面的点，从而正确减去重复的路径数。”

### 🗣️ 点评
这位作者的经验很典型！在处理多元素删除的容斥问题时，**有序处理**是关键。拓扑序是DAG中“有序”的天然保证，必须学会利用。


## 💪 总结
本次分析的“SWTR-5”Chain题，核心是**拓扑排序+动态规划+容斥原理**。通过预处理路径数和拓扑序，我们可以高效处理大量询问。希望这份指南能帮助你理解这些算法的应用，下次遇到类似问题时，能快速找到思路！

记住：编程的乐趣在于“解决问题”，而不是“写代码”。多思考、多练习，你一定会越来越厉害！💪

---
处理用时：187.28秒
# 题目信息

# [ZJOI2007] 矩阵游戏

## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。


## 样例 #1

### 输入

```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0
```

### 输出

```
No
Yes
```

# AI分析结果


### 💡 Kay的C++算法解析：[ZJOI2007] 矩阵游戏 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`二分图最大匹配`

🗣️ **初步分析**：
> 这道题的核心在于**行列独立操作性质**。想象矩阵是一个棋盘，黑格子是棋子。每次交换行/列相当于整体移动整行/列的棋子，但棋子间的行列关系不变。通过建立**行-列二分图模型**（左侧为行节点，右侧为列节点，黑格子对应连边），问题转化为寻找**完美匹配**（n对独立行列匹配）。  
> - **可视化设计思路**：动画将展示行列节点匹配过程，高亮当前匹配边和冲突处理。采用**8位像素风格**棋盘，行列为彩色像素方块，匹配成功时播放"叮"音效，冲突时播放"咔嚓"音效，自动演示模式模拟匹配推进。

---

#### 2. 精选优质题解参考
**题解一：俾斯麦（匈牙利+Dinic双解法）**
* **点评**：  
  思路清晰对比两种算法，匈牙利解法用前向星优化空间，Dinic解法详细注释网络流建图。亮点在于明确解释行列交换不影响最大匹配的核心性质，代码边界处理严谨（`clear()`函数避免memset浪费），实践可直接用于竞赛。

**题解二：cmwqf（图示化解释）**
* **点评**：  
  通过手绘图示直观展示行列交换如何保持匹配不变性，代码用邻接矩阵实现匈牙利算法。亮点在于将抽象匹配过程具象化，变量命名规范（`match`, `vis`），帮助初学者理解匹配逻辑。

**题解三：Night_Aurora（推导过程清晰）**
* **点评**：  
  精炼推导"初始匹配=最终状态"的核心逻辑，强调交换操作不改变匹配数。代码用快读优化输入，亮点在于用`clear()`局部清零替代全局memset，提升大数据效率。

---

#### 3. 核心难点辨析与解题策略
1. **难点：行列操作的性质抽象**  
   *分析*：交换行/列不改变任一黑格子的行集合和列集合，因此初始匹配数决定可行性。  
   💡 **学习笔记**：操作不改变二分图结构，只改变标签顺序。

2. **难点：匹配模型的建立**  
   *分析*：每个黑格子(i,j)表示行i可匹配列j。完美匹配要求每行找到唯一列且不冲突。  
   💡 **学习笔记**：矩阵对角化 = 寻找n个行列独立的黑格子。

3. **难点：时间效率优化**  
   *分析*：匈牙利算法O(n³)需优化（DFS剪枝），Dinic网络流O(n²√n)适合稠密图。  
   💡 **学习笔记**：多组数据时避免全量清零，复用未修改内存。

✨ **解题技巧总结**：
- **模型转换技巧**：将矩阵操作问题转化为图论匹配
- **增量清零优化**：只重置必要数据结构（如`vis`数组）
- **边界鲁棒性**：特判n=0或全白矩阵
- **数据结构选择**：稀疏图用邻接表，稠密图用邻接矩阵

---

#### 4. C++核心代码实现赏析
```cpp
// 通用核心实现：匈牙利算法 (综合自优质题解)
#include <cstring>
const int N = 205;
int match[N], G[N][N], vis[N], n;

bool dfs(int u) {
    for (int v = 1; v <= n; ++v) {
        if (!G[u][v] || vis[v]) continue;
        vis[v] = 1;
        if (!match[v] || dfs(match[v])) {
            match[v] = u; // 关键：列v匹配行u
            return true;
        }
    }
    return false;
}

bool solve() {
    memset(match, 0, sizeof match);
    int cnt = 0;
    for (int i = 1; i <= n; ++i) {
        memset(vis, 0, sizeof vis);
        if (dfs(i)) cnt++;
    }
    return cnt == n; // 完美匹配检测
}
```

**题解一：俾斯麦（匈牙利片段）**
```cpp
// 亮点：前向星存边优化
bool dfs(int x) {
    for (int i = head[x]; i; i = next[i]) {
        int y = to[i];
        if (vis[y]) continue;
        vis[y] = true;
        if (!match[y] || dfs(match[y])) {
            match[y] = x; // 状态更新
            return true;
        }
    }
    return false;
}
```
> **解读**：用链式前向星替代邻接矩阵，减少空间开销。`match[y]=x`记录列y匹配行x，`vis`数组避免重复访问同一列。  
> 💡 **学习笔记**：前向星适合稀疏图，递归回溯实现DFS增广。

**题解二：俾斯麦（Dinic片段）**
```cpp
// 亮点：网络流高效求解
while (bfs()) // BFS分层
    while (flow = dinic(s, INF))
        maxflow += flow;
```
> **解读**：Dinic通过BFS分层图加速增广路查找，`dinic()`函数实现多路增广。  
> 💡 **学习笔记**：网络流适合密集匹配，时间复杂度稳定。

---

### 5. 算法可视化：像素动画演示
**动画主题**：`8位像素风格匹配大作战`  
**核心演示**：匈牙利算法逐步匹配过程，行列冲突解决  

**设计思路**：  
- **像素风格**：行节点（蓝色方块），列节点（红色方块），匹配边（黄色像素线）
- **关键帧步骤**：
  1. 初始化：生成n×n像素网格，黑格子点亮对应行列节点
  2. 匹配尝试：当前行节点闪烁 → 扫描列节点（绿色高亮） → 成功匹配播放"叮"声并连接黄线
  3. 冲突处理：列已被匹配时，原匹配边闪烁红色 → 回溯原行重新匹配
  4. 完成庆祝：完美匹配时对角线闪金光，播放胜利音效

**交互控制**：
- 步进模式：空格单步执行
- 自动演示：速度滑块调节（1x-5x）
- 比较模式：并列展示匈牙利 vs Dinic算法差异

**技术实现**：Canvas绘制动态网格，音效用Web Audio API触发，状态机管理匹配流程。

---

### 6. 拓展练习与相似问题思考
**通用技巧迁移**：  
二分图匹配可解决：
1. 任务分配（行→工人，列→任务）
2. 棋盘覆盖（骨牌放置位置匹配）
3. 航班调度（起飞时段→降落时段）

**推荐练习**：
1. [洛谷P3386 二分图最大匹配](https://www.luogu.com.cn/problem/P3386)  
   → 巩固匈牙利/Dinic实现
2. [洛谷P6066 特殊匹配模型](https://www.luogu.com.cn/problem/P6066)  
   → 学习带权匹配变形
3. [CF489B 矩阵操作扩展](https://codeforces.com/problemset/problem/489/B)  
   → 综合行列变换技巧

---

### 7. 学习心得与经验分享
> 本次题解中未发现明确的作者调试心得，但综合各解法可得经验：  
> **关键教训**：多组数据输入时务必彻底初始化匹配数组（如`match[]`），否则残留数据导致错误。推荐使用`fill`代替`memset`处理非字符数组。

---
> 掌握二分图匹配的核心在于理解**行列独立性**和**匹配传递性**。建议用棋盘模拟小样例（n=3）加深理解，再迁移到代码实现。下次我们将探讨更复杂的带权匹配问题！💪

---
处理用时：78.28秒
# 题目信息

# [Sloi 2024]D1T1 精卫

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/p38htsuu.png)

## 题目描述

$f(x)$ 为积性函数，且满足 $f(p^k)=p^{2k}+k$（$p$ 为素数）。

令 $g(x)=\prod\limits_{d|x}f(d)\space \bmod\space (10^9+7)$ ，请计算 $g(i)\space (1\le i \le n)$ 的异或和。

## 说明/提示

**本题采用捆绑测试**

| Subtask | n | Score |
| :----------: | :----------: | :----------: |
| $1$ | $\le10^4$ | $10$ |
| $2$ | $\le 5\times 10^6$ | $30$ |
| $3$ | $\le 2\times 10^7$ | $30$ |
| $4$ | $\le 5\times10^7$ | $30$ |

对 $100\%$ 的数据，$1\le n \le 5\times10^{7} $。


## 样例 #1

### 输入

```
5```

### 输出

```
78```

## 样例 #2

### 输入

```
142857```

### 输出

```
67850062```

## 样例 #3

### 输入

```
10000000```

### 输出

```
505679580```

# AI分析结果

# 💡 Kay的C++算法解析：[Sloi 2024]D1T1 精卫 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（积性函数+质因数分解）` + `搜索（DFS遍历质因数组合）`

🗣️ **初步分析**：  
解决这道题的关键，在于**用积性函数的“组合属性”拆解问题**——就像搭积木，两个互不重叠的积木（互质的数）组合后的“属性”（g(x)），可以由各自的属性通过特定规则计算得到。具体来说：  
- **积性函数的核心**：f(x)是积性函数（质数幂的f值已知），我们推导出g(x)（x所有因数的f(d)乘积）也满足积性组合规则：当x与p^k互质时，`g(xp^k) = g(x)^(k+1) * g(p^k)^(τ(x))`（τ(x)是x的因数个数）。这个规则是解题的“钥匙”。  
- **大数处理的技巧**：因为n高达5e7，线性筛会爆空间，所以我们把数分成两部分：  
  1. 所有质因数≤√n的数：用DFS遍历质因数的组合，同时记忆化快速幂结果（避免重复计算g(p^k)^τ(x)）；  
  2. 最大质因数>√n的数：这类数形如x*p（p是>√n的质数，x≤√n），直接枚举p，再枚举x计算g(xp)。  

- **可视化设计思路**：我们会用8位像素风展示“质因数积木”组合成数的过程——比如用不同颜色的像素块代表不同质数，组合时动态显示g(x)的计算（比如g(x)的幂次变化用数字闪烁，g(p^k)的幂次用色块堆叠）。关键步骤（如快速幂计算、组合新数）会用“叮”的像素音效提示，完成一个数的计算会弹出“过关”动画。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下2份优质题解，它们都精准抓住了“积性函数拆分+分治处理大数”的核心，且各有巧妙优化。
</eval_intro>

**题解一：(来源：Polarisx)**  
* **点评**：这份题解的思路非常“纯粹”——直接用DFS遍历所有质因数≤√n的组合，同时用`mp[i][c][divs]`记忆化`g(p^c)^divs`的结果（divs是x的因数个数），避免了重复快速幂。代码结构清晰：DFS负责组合质因数，最后枚举大质数处理剩余部分。尤其是`dfs`函数的递归逻辑，把“组合质因数→计算g值→更新异或和”的流程串得很顺，变量名（如`nz`代表新数、`ng`代表g(p^c)）也很易懂，适合初学者模仿。

**题解二：(来源：xujindong_)**  
* **点评**：这份题解在快速幂优化上更“聪明”——针对大质数部分，它预处理了`pre`数组（`pre[i] = g(p)^i`），这样枚举x时直接取`pre[td[i]]`就能得到`g(p)^τ(x)`，省去了每次快速幂的时间。另外，它用`maxd`数组记录x≤√n时的最大因数个数，避免了不必要的计算。代码中的`dfs`函数和题解一类似，但对大质数部分的处理更高效，是“时间优化”的好例子。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要是3个核心问题，结合题解的思路，我们可以这样突破：
</difficulty_intro>

1.  **难点1：推导g(xp^k)的积性表达式**  
    * **分析**：g(x)是x所有因数的f(d)乘积，要找到它的组合规则，必须利用f的积性。很多同学会卡在“如何拆分g(xp^k)”这一步——其实只要想清楚：x的因数和p^k的因数是“互不干扰”的（因为x和p^k互质），所以g(xp^k)等于g(x)的τ(p^k)次方乘以g(p^k)的τ(x)次方（τ(p^k)=k+1）。  
    * 💡 **学习笔记**：积性函数的“组合规则”是解决这类问题的核心，一定要先推导清楚！

2.  **难点2：处理5e7的空间限制**  
    * **分析**：线性筛需要O(n)的空间（比如存每个数的最小质因数），但5e7的数组会占200MB以上（超过题目限制的50MB）。题解的办法是“分治”——只处理质因数≤√n的数（用DFS，空间O(√n/logn)），剩下的数用“枚举大质数+小x”的方式处理（空间O(√n)）。  
    * 💡 **学习笔记**：当空间不够时，试试“拆分问题”——把大问题拆成小部分，用不同的方法处理。

3.  **难点3：优化多次快速幂的时间**  
    * **分析**：计算`g(p^k)^τ(x)`需要多次快速幂，如果直接算会超时。题解一用记忆化数组`mp`存重复的结果（比如同一个p、k、τ(x)的组合只算一次）；题解二用`pre`数组预处理大质数的幂次，直接查表。  
    * 💡 **学习笔记**：重复计算的部分一定要“记下来”——记忆化或预处理是优化时间的常用技巧！


### ✨ 解题技巧总结
- **技巧A：积性函数拆分**：遇到“乘积型积性函数”（如g(x)是因数的乘积），先推导它的组合规则（比如g(ab)=g(a)^τ(b)*g(b)^τ(a)），再用这个规则拆分问题。  
- **技巧B：分治处理大数**：当n很大时，把数分成“小质因数组合”和“大质因数+小x”两部分，分别处理。  
- **技巧C：记忆化快速幂**：对于重复的快速幂计算（比如同一个底数、不同指数），用数组存结果，避免重复计算。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个综合两份题解思路的通用实现，它涵盖了“DFS组合小质因数+枚举大质数”的完整流程，逻辑清晰。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Polarisx和xujindong_的思路，优化了记忆化数组的命名，更易读。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <bitset>
    #include <cmath>
    using namespace std;

    const int MOD = 1e9+7;
    const int MAX_B = 7200; // √5e7≈7071，取稍大的值
    vector<int> primes;
    bitset<50000005> is_prime;
    int n, B, ans = 0;
    int g_small[MAX_B + 1], tau_small[MAX_B + 1]; // g_small[x]是x的g值，tau_small[x]是x的因数个数
    int memo[10000][30][70]; // 记忆化g(p^c)^tau，p的索引≤1e4，c≤30，tau≤70

    long long qpow(long long a, int b) {
        long long res = 1;
        while (b) {
            if (b & 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    void dfs(int p_idx, int current_num, long long current_g, int current_tau) {
        ans ^= current_g; // 异或和累加
        if (current_num <= B) { // 保存小x的g值和tau，供后面大质数部分使用
            g_small[current_num] = current_g;
            tau_small[current_num] = current_tau;
        }
        if (p_idx >= primes.size()) return;
        int p = primes[p_idx];
        long long next_num = 1LL * current_num * p;
        if (next_num > n) return;
        // 枚举p的幂次c（从1开始）
        long long g_pk = 1; // g(p^c) = product_{i=1}^c (p^{2i} + i)
        long long new_g = current_g; // g(current_num * p^c) = current_g^(c+1) * g_pk^current_tau
        for (int c = 1; ; c++) {
            g_pk = g_pk * (1LL * p * p % MOD * qpow(p, 2*(c-1)) % MOD + c) % MOD; // p^{2c} + c = (p^2)^c + c
            new_g = new_g * current_g % MOD; // current_g^(c+1) = current_g^c * current_g
            // 计算g_pk^current_tau，记忆化
            if (memo[p_idx][c][current_tau] == 0) {
                memo[p_idx][c][current_tau] = qpow(g_pk, current_tau);
            }
            long long g_part = memo[p_idx][c][current_tau];
            long long total_g = new_g * g_part % MOD;
            dfs(p_idx + 1, next_num, total_g, current_tau * (c + 1)); // 递归处理下一个质数
            // 准备下一个幂次
            next_num *= p;
            if (next_num > n) break;
        }
        // 不选当前质数，递归下一个
        dfs(p_idx + 1, current_num, current_g, current_tau);
    }

    int main() {
        cin >> n;
        B = sqrt(n);
        // 筛出所有≤n的质数
        is_prime.set();
        is_prime[0] = is_prime[1] = false;
        for (int i = 2; i <= n; i++) {
            if (is_prime[i]) {
                primes.push_back(i);
                for (int j = 2 * i; j <= n; j += i) {
                    is_prime[j] = false;
                }
            }
        }
        // 初始化记忆化数组
        memset(memo, 0, sizeof(memo));
        // DFS处理所有质因数≤√n的数
        dfs(0, 1, 1, 1); // 初始状态：current_num=1，current_g=1（g(1)=f(1)=1），current_tau=1（1的因数个数是1）
        // 处理最大质因数>√n的数（形如x*p，p>√n，x≤√n）
        for (int p = B + 1; p <= n; p++) {
            if (!is_prime[p]) continue; // p必须是质数
            long long g_p = (1LL * p * p + 1) % MOD; // g(p) = f(1)*f(p) = 1*(p²+1)
            // 枚举x≤n/p，计算g(xp)=g(x)^2 * g_p^tau_small[x]
            for (int x = 1; 1LL * x * p <= n; x++) {
                long long g_xp = 1LL * g_small[x] * g_small[x] % MOD; // g(x)^2
                g_xp = g_xp * qpow(g_p, tau_small[x]) % MOD; // 乘g_p^tau_small[x]
                ans ^= g_xp;
            }
        }
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  1. **筛质数**：用bitset筛出所有≤n的质数，存到`primes`数组。  
  2. **DFS组合小质因数**：`dfs`函数递归遍历所有质因数≤√n的组合，计算每个数的g值并累加到异或和。`memo`数组记忆化`g(p^c)^tau`的结果，避免重复快速幂。  
  3. **处理大质数**：枚举所有>√n的质数p，再枚举x≤n/p，计算g(xp)=g(x)^2 * g(p)^tau(x)，累加到异或和。


<code_intro_selected>
接下来看两份题解的核心片段，它们分别体现了“记忆化快速幂”和“预处理幂次”的技巧。
</code_intro_selected>

**题解一：(来源：Polarisx)**
* **亮点**：用三维数组`mp`记忆化快速幂结果，避免重复计算。
* **核心代码片段**：
    ```cpp
    int mp[960][26][352]; // mp[i][c][divs] = g(p_i^c)^divs
    void dfs(int p, int now, int G, int divs) {
        ans ^= G;
        if (now <= B) { g[now] = 1LL*G*G%MOD; d[now] = divs; }
        for (int i=p; i<sz; i++) {
            int nz=now, nf=1, ng=1, nG=G;
            const int P=prm[i];
            if (1LL*nz*P>n) break;
            for (int c=1;;c++) {
                if (1LL*nz*P>n) break;
                nz*=P; nf=1LL*nf*P%MOD*P%MOD; ng=1LL*ng*(nf+c)%MOD;
                nG=1LL*nG*G%MOD; 
                if (!mp[i][c][divs]) mp[i][c][divs] = ksm(ng, divs, MOD);
                int pw=mp[i][c][divs];
                dfs(i+1, nz, 1LL*nG*pw%MOD, divs*(c+1));
            }
        }
    }
    ```
* **代码解读**：  
  - `mp[i][c][divs]`存的是第i个质数的c次幂对应的g(p^c)的divs次方（divs是当前数的因数个数）。如果`mp`中没有这个值，就用`ksm`（快速幂）计算并保存。  
  - `ng`是g(p^c)的值（因为g(p^c)=f(1)*f(p)*f(p²)*…*f(p^c)=1*(p²+1)*(p^4+2)*…*(p^{2c}+c)，所以每次循环乘`(nf+c)`，`nf`是p^{2c}）。  
  - `nG`是g(x)^(c+1)（因为x乘p^c后，g(xp^c)=g(x)^{c+1}*g(p^c)^divs）。  

* 💡 **学习笔记**：三维数组的记忆化虽然占点空间，但能大大减少快速幂的次数——这是“空间换时间”的典型应用！

**题解二：(来源：xujindong_)**
* **亮点**：用`pre`数组预处理大质数的幂次，直接查表，避免多次快速幂。
* **核心代码片段**：
    ```cpp
    int pre[65]; // pre[i] = g(p)^i
    int main() {
        pre[0]=1; cin>>n; bn=sqrt(n); cnt=prime_init(n); dfs(1,1,1,1);
        for(int i=1;i<=bn;i++) maxd[i]=max(maxd[i-1],td[i]);
        for(int p=bn+1;p<=n;p++){
            if(!vis[p])continue;
            int gp=(1LL*p*p+1)%mod;d=maxd[n/p];
            for(int i=1;i<=d;i++)pre[i]=1LL*pre[i-1]*gp%mod;
            for(int i=1;i*p<=n;i++)ans^=1LL*tg[i]*pre[td[i]]%mod;
        }
        return cout<<ans<<'\n',0;
    }
    ```
* **代码解读**：  
  - `pre`数组预处理g(p)的幂次：`pre[i] = g(p)^i`（通过循环乘g(p)得到）。  
  - `maxd[i]`是x≤i时的最大因数个数，这样可以提前计算`pre`数组的长度（避免超过需要的次数）。  
  - 枚举x时，直接取`pre[td[i]]`（td[i]是x的因数个数），省去了快速幂的时间。  

* 💡 **学习笔记**：预处理幂次是优化多次快速幂的“杀器”——如果指数的范围不大（比如本题中td[i]≤70），直接预处理所有可能的幂次，查表比每次快速幂快得多！


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们用8位像素风做一个“质因数积木闯关”动画，把抽象的数论计算变成“搭积木游戏”，让你直观看到g(x)的计算过程！
</visualization_intro>

### 动画设计方案
**主题**：像素探险家“小K”用“质因数积木”搭出1到n的数，每搭一个数就计算g(x)，完成所有数的计算就算“通关”。

### 核心设计细节
1. **场景与UI初始化**：  
   - 屏幕左侧是“质因数积木库”：用不同颜色的8x8像素块代表不同质数（比如红色代表2，蓝色代表3，绿色代表5），下方显示质数的数值。  
   - 屏幕中间是“搭建区”：用网格展示当前搭建的数（比如搭12=2²×3，就显示两个红色块+一个蓝色块），旁边动态显示当前数的g值和因数个数。  
   - 屏幕右侧是“控制面板”：有“开始/暂停”“单步执行”“重置”按钮，还有速度滑块（控制动画速度）。背景播放8位风格的轻快BGM（比如《超级马里奥》的简化版）。

2. **算法演示步骤**：  
   - **步骤1：筛质数**：积木库中的质数块逐个“亮起来”（从2开始，依次闪烁），伴随“叮”的音效，提示“质数筛好了！”。  
   - **步骤2：DFS组合小质因数**：  
     - 初始状态：搭建区显示“1”（白色块），g值显示“1”，因数个数显示“1”。  
     - 开始DFS：小K从积木库中拿起第一个质数（比如2），放到搭建区，组成“2”——此时动态计算g(2)=f(1)*f(2)=1*(2²+1)=5，搭建区的g值变成“5”，伴随“嗒”的音效。  
     - 继续组合：小K再拿一个2，组成“4”——计算g(4)=g(2)^2 * g(2)^1（因为4=2²，τ(2)=2？不对，等一下，根据规则g(2²)=g(2)^(2) * g(2^2)^τ(2)? 不，正确的规则是g(xp^k)=g(x)^{k+1} * g(p^k)^τ(x)，当x=2，p=2，k=1时，g(2²)=g(2)^(1+1) * g(2^1)^τ(2)？不对，x必须和p^k互质，所以x应该是1，p=2，k=2：g(2²)=g(1)^(2+1) * g(2²)^τ(1)？哦，等一下，g(p^k)的计算：g(p^k)=乘积_{d|p^k} f(d) = f(1)*f(p)*f(p²)*…*f(p^k) = 1*(p²+1)*(p^4+2)*…*(p^{2k}+k)。所以g(2²)=1*(2²+1)*(2^4+2)=1*5*18=90。动画中，搭“4”时，会显示“g(4)=90”，并用箭头指向“g(2)=5”和“g(2²)=5×18=90”，说明计算过程。  
     - 每搭一个数，搭建区会弹出“+1”的分数提示，完成一个质因数的所有组合（比如2的所有幂次）会显示“小关卡完成！”的动画。  
   - **步骤3：处理大质数**：  
     - 积木库中“>√n”的质数块变成黄色（比如7，当n=5e7时，√n≈7071，所以7072以上的质数块变黄）。  
     - 小K拿起一个黄色块（比如7073），放到搭建区的“x”块（比如x=2）旁边，组成“2×7073”——计算g(2×7073)=g(2)^2 * g(7073)^τ(2) =5²*(7073²+1)^2，搭建区的g值动态更新，伴随“嗡”的音效。  

3. **交互与游戏化元素**：  
   - **单步执行**：点击“单步”按钮，动画走一步（比如搭一个积木，或计算一个g值），方便你仔细看每一步。  
   - **自动播放**：点击“自动”按钮，小K会自动搭完所有数，像“贪吃蛇AI”一样，每完成一个数就“跳一下”，完成所有数会播放“胜利”音效（类似《魂斗罗》的通关音乐）。  
   - **闯关奖励**：每完成100个数的计算，会解锁一个“质因数皮肤”（比如把红色的2变成带花纹的红色块），增加趣味性。

### 技术实现说明
- **渲染**：用HTML5 Canvas绘制8位像素块，每个积木块是8x8的矩形，颜色用复古色板（比如#FF0000代表红色，#00FF00代表绿色）。  
- **音效**：用Web Audio API播放像素音效——比如“叮”（筛质数）、“嗒”（搭积木）、“嗡”（计算大质数）、“胜利乐”（通关）。  
- **交互**：用JavaScript监听按钮点击和滑块变化，控制动画的播放、暂停和速度。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“积性函数拆分+分治处理大数”的技巧后，你可以尝试以下相似问题，巩固所学：
</similar_problems_intro>

### 相似问题推荐
1. **洛谷 P3455 [POI2007] ZAP-Queries**：  
   - **推荐理由**：这道题考察积性函数的前缀和，需要用到莫比乌斯反演和分块处理，和本题的“分治处理大数”思路一致。  
2. **洛谷 P4449 于神之怒加强版**：  
   - **推荐理由**：这道题的核心是推导积性函数的组合规则（类似本题的g(xp^k)），并且需要处理大数的前缀和，非常锻炼数论推导能力。  
3. **洛谷 P5495 【模板】Dirichlet 前缀和**：  
   - **推荐理由**：这道题是积性函数前缀和的模板题，能帮你巩固“积性函数的线性处理”技巧，和本题的“分治处理”形成互补。


## 7. 学习心得与经验分享

<insights_intro>
两份题解的作者都提到了“空间优化”和“快速幂优化”的重要性，其中xujindong_的经验尤其值得借鉴：
</insights_intro>

> **参考经验 (来自xujindong_)**：“空间被卡了，没法线性筛。考虑直接搜每个数的质因数分解，同时维护这个g，有g(xp^k)=g(x)^{k+1}g(p^k)^{d(x)}。现在瓶颈是这n次快速幂。考虑只对≤√n的质因数搜索，记忆化快速幂的结果。”  
> **点评**：作者的思路非常“务实”——当线性筛不行时，立刻转向“搜索+记忆化”，这是解决大数问题的常用思路。另外，作者提到的“瓶颈是快速幂”，直接点出了问题的核心，然后用“记忆化”和“预处理”解决，这种“定位瓶颈→解决瓶颈”的思维方式，值得每一个学习者学习！


## 总结
本次分析让我们掌握了“积性函数拆分+分治处理大数”的核心技巧，还学会了用记忆化和预处理优化快速幂。记住，数论问题的关键是“推导组合规则”，大数问题的关键是“拆分问题”。下次遇到类似的题目，不妨先问自己：“这个函数是积性的吗？能拆成小部分处理吗？” 相信你会越来越熟练！💪

---
处理用时：174.09秒
# 题目信息

# [Celeste-A] Sever the Skyline

## 题目背景

> 废弃的城市里充满了机关和陷阱，而今晚，我们将

> ——划破这城市的天际线

## 题目描述

Madeline 来到了被废弃的城市，这座城市里满是机关，还有一台不知所谓的机器在向外发射着光信号。

通过 Madeline 强大的观察力，她发现光信号其实对应着某种冲刺顺序，按照顺序冲刺之后，她发现她冲刺的轨迹构成了这座废弃城市的天际线。

多年以后，当 Madeline 回忆她登山的旅途时，已经不记得这座城市的天际线长什么样了，只记得所有建筑高度的和为 $n$，并且每座建筑的高度可以表示为 $p^iq^j$，$p,q$ 为素数且 $i,j \geq 0,i+j\geq 1$。

Madeline 知道，这座城市的天际线是很有美感的，不存在两座建筑使得它们的高度成**整倍数**关系(1倍也是整倍数)，例如若存在一座高度为 $2$ 的建筑，就一定不能存在高度为 $4$ 的建筑。

由于 Madeline 的记忆相当模糊，所以她可能要求你多次对于一个特定的记忆给出一个合法的天际线。

## 说明/提示

对于前 $30\%$ 的数据，保证 $n \leq 100$，

对于另外 $20\%$ 的数据，保证 $p,q \leq 3$

对于 $100\%$ 的数据，保证 $1 < n \leq 10^{18}, p,q \leq 40, p < q, T \leq 10000$

对于最后 $30\%$ 的数据，采用捆绑测试，仅当您通过了所有测试点才能得分。

保证数据的生成方式为：

均匀随机两个质数 $p,q$，随机选择若干个 $p^iq^j$，保证它们不成倍数，将 $p^iq^j$ 的和作为 $n$，若这组数据满足当前数据点的要求，则保留，若不满足，则重新生成。

对于最后 $30\%$ 数据点，对于 $n$ 要求 $n > 10^{17}$。

对于最后 $30\%$ 数据点中的部分测试点，要求至少选出 $4$ 个 $p^iq^j$ 来组成 $n$。

**本题 spj 认可的格式为：行末无空格，每组输出行末换行。**

**若格式不正确，您可能会获得 UKE**

## 样例 #1

### 输入

```
3
15 2 3
10 2 5
416873881340965120 2 7```

### 输出

```
6 9
10
8507630225817856 19446011944726528 22224013651116032 12699436372066304 8293509467471872 4739148267126784 1354042362036224 3094953970368512 1768545125924864 32339110874054656 5279854836580352 1508529953308672 3448068464705536 3940649673949184 288230376151711744
```

# AI分析结果


### Kay的C++算法解析：Sever the Skyline 深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`数学构造` + `贪心策略`  
🗣️ **初步分析**：  
> 这道题要求用素数幂组合（形如 $p^iq^j$）凑出目标值 $n$，且任意两个数不能成倍数关系（如选了2就不能选4）。想象你在玩一个复古像素游戏，需要收集特定能量的星星（每个星星代表一个 $p^iq^j$ 值），但星星之间不能有光线相连（即整除关系）。  

**核心难点与策略**：  
1. **独立条件约束**：选择的数集需满足反链性质（任意两数互不整除）。  
2. **超大范围优化**：$n \leq 10^{18}$ 要求避免暴力枚举，需利用素数幂的稀疏性。  
3. **构造策略**：贪心从大数向小数选取，实时排除冲突数（约数/倍数）。  

**可视化设计**：  
- 采用 **8位像素风网格**，横轴为 $i$（$p$ 的指数），纵轴为 $j$（$q$ 的指数）。  
- 选中星星时触发 **"收集音效"** 并高亮其 **"禁选区"**（右下约数区和左上倍数区）。  
- 控制面板支持 **调速滑块** 和 **回溯按钮**，便于观察构造过程。  

---

#### 2. 精选优质题解参考
<eval_intro>  
暂无论坛题解提交，但基于题目特性推荐以下学习方向：  
</eval_intro>

* **通用学习建议**：  
  - 优先掌握 **素数幂生成技巧**，用对数估算最大指数范围。  
  - 理解 **偏序集反链** 的数学本质（无右下支配关系）。  
  - 尝试 **贪心+回溯** 框架，配合剪枝优化（如剩余和检测）。  

---

#### 3. 核心难点辨析与解题策略
<difficulty_intro>  
破解此题需突破三大关键点：  
</difficulty_intro>

1.  **指数空间的高效生成**  
    * **分析**：直接枚举 $i,j$ 会导致 $O(\log^2 n)$ 量级（约 $3600$ 个数），需用 `vector` 存储并排序。  
    * 💡 **学习笔记**：预处理时利用 $p^iq^j \leq n$ 的边界剪枝。  

2.  **独立条件的动态维护**  
    * **分析**：每选一个数 $x$，需禁用其所有 **约数**（$x$ 整除它们）和 **倍数**（它们整除 $x$）。用 `unordered_set` 存储冲突数实现 $O(1)$ 校验。  
    * 💡 **学习笔记**：从大到小贪心可自然规避大数倍数（已提前禁用）。  

3.  **构造失败的回溯机制**  
    * **分析**：贪心可能卡在局部最优解，需记录 **决策点** 并随机跳转（如跳过当前数 50% 概率）。  
    * 💡 **学习笔记**：设置最大回溯深度（如 20 层）避免无限循环。  

### ✨ 解题技巧总结  
<summary_best_practices>  
核心技巧可迁移至同类构造问题：  
</summary_best_practices>  
- **稀疏集合遍历**：对数级范围用指数枚举替代数值枚举。  
- **冲突实时排除**：用哈希集合维护动态约束条件。  
- **概率化调整**：随机性避免贪心僵局，尤其适合随机生成数据。  

---

#### 4. C++核心代码实现赏析
<code_intro_overall>  
以下实现融合贪心与随机回溯，完整解决核心逻辑：  
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：综合反链性质与稀疏优化，强调可读性与边界处理。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_set>
using namespace std;

typedef long long LL;

vector<LL> generate_numbers(LL n, int p, int q) {
    vector<LL> res;
    for (LL i_p = 1; i_p <= n; i_p *= p) {
        for (LL j_q = 1; i_p * j_q <= n; j_q *= q) {
            res.push_back(i_p * j_q);
        }
    }
    sort(res.rbegin(), res.rend()); // 从大到小排序
    return res;
}

vector<LL> solve(LL n, int p, int q) {
    auto nums = generate_numbers(n, p, q);
    unordered_set<LL> forbidden;
    vector<LL> selected;
    LL sum = 0;

    for (auto x : nums) {
        if (forbidden.count(x)) continue;
        if (sum + x > n) continue;

        // 检查独立条件：x不能是已选数的约数
        bool conflict = false;
        for (auto y : selected) {
            if (y % x == 0 || x % y == 0) {
                conflict = true;
                break;
            }
        }
        if (conflict) continue;

        // 选择x并更新状态
        selected.push_back(x);
        sum += x;
        // 禁用x的约数（在nums中）和倍数
        for (auto y : nums) {
            if (y % x == 0 || x % y == 0) {
                forbidden.insert(y);
            }
        }
        if (sum == n) break;
    }
    return selected;
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        LL n;
        int p, q;
        cin >> n >> p >> q;
        auto ans = solve(n, p, q);
        for (auto x : ans) cout << x << " ";
        cout << endl;
    }
    return 0;
}
```
* **代码解读概要**：  
  > 1. **生成素数幂**：双层循环枚举所有 $p^iq^j \leq n$ 的数。  
  > 2. **贪心构造**：从大到小遍历，跳过冲突数（`forbidden`），满足独立条件则选取。  
  > 3. **动态约束**：每选一个数，将其约数/倍数加入禁用集。  
  > 4. **输出优化**：行末无空格，每组数据独立换行。  

---

#### 5. 算法可视化：像素动画演示  
<visualization_intro>  
**「星辰收集者」** 像素动画演示贪心策略：  
</visualization_intro>  

* **主题**：8-bit 风星空网格，玩家操控飞船收集能量星（$p^iq^j$）。  
* **核心交互**：  
  ```mermaid
  graph LR
    A[初始化网格] --> B[飞船移动至最大星]
    B --> C{是否冲突？}
    C -->|否| D[收集星星+音效]
    D --> E[高亮禁选区]
    E --> F[更新剩余n值]
    C -->|是| G[跳过+闪烁警告]
  ```

* **关键动画设计**：  
  1. **像素元素**：  
     - 星星：黄色像素块（未收集）→ 绿色（已收集）  
     - 禁选区：半透红色覆盖层（约数区→右下，倍数区→左上）  
  2. **音效系统**：  
     - 收集成功：8-bit 短促“叮”声（NES 音效库）  
     - 冲突警告：低频“嗡嗡”声  
     - 背景音乐：复古芯片风循环曲  
  3. **控制面板**：  
     - 速度滑块：0.5x~5x 动画速度  
     - 回溯按钮：返回上一步，飞船退后并恢复禁选区  
  4. **AI演示模式**：  
     - 自动贪心收集，遇冲突时随机跳过（屏幕显示“STRATEGY ADJUST”）  
     - 通关时播放《超级玛丽》过关音效 + 像素烟花  

---

#### 6. 拓展练习与相似问题思考  
<similar_problems_intro>  
掌握数学构造与反链性质可解决以下变体：  
</similar_problems_intro>  

* **推荐练习**（洛谷）：  
  1. **P2325** - 王室联邦  
     🗣️ **理由**：强化树分块中的独立集合构造。  
  2. **P1458** - 顺序的分数  
     🗣️ **理由**：二维偏序集枚举，训练指数边界处理。  
  3. **P1754** - 球迷购票  
     🗣️ **理由**：组合数学中的独立约束计数。  

---

#### 7. 学习心得与经验分享  
<insights_intro>  
本题未提供作者心得，但核心经验如下：  
</insights_intro>  
> **调试重点**：  
> - 验证 $n$ 的素数幂分解可行性（非任意 $n$ 可解）。  
> - 禁用集需覆盖 **双向整除关系**（约数+倍数），漏掉任一方均导致错误。  

---

<conclusion>  
通过本指南，你学会了如何用贪心+约束排除破解超大数学构造题。下次当你在编程宇宙中遇到星辰般的数字时，别忘了用反链思维照亮前路！🚀  
</conclusion>

---
处理用时：295.82秒
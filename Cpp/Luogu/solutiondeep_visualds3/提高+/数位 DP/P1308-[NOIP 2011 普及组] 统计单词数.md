# 题目信息

# [NOIP 2011 普及组] 统计单词数

## 题目描述

一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。

现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例 1），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例 2）。


## 说明/提示

数据范围

$1\leq $ 第一行单词长度 $\leq10$。

$1\leq $ 文章长度 $\leq10^6$。

noip2011 普及组第 2 题


## 样例 #1

### 输入

```
To
to be or not to be is a question
```

### 输出

```
2 0

```

## 样例 #2

### 输入

```
to
Did the Ottoman Empire lose its power at that time```

### 输出

```
-1```

# AI分析结果


# 💡 Kay的C++算法解析：统计单词数 深入学习指南 💡

<introduction>
今天我们来分析NOIP2011普及组"统计单词数"这道字符串处理题。本指南将带你理解题目核心、掌握高效解法，并通过生动的像素动画直观展示算法执行过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串处理`与`边界匹配模拟`

🗣️ **初步分析**：
> 这道题就像在像素迷宫中寻找特定颜色的宝石💎——我们需要在文章字符串中精确匹配目标单词（忽略大小写），且要求单词完全独立（前后有空格或边界）。解决关键在于：
   - 统一大小写（如全部转为小写）
   - 设计扫描策略识别单词边界
   - 高效比较目标单词
   > 可视化设计中，我们将用**绿色像素块**表示匹配中的字符，**红色闪烁**标识完整匹配，**8-bit音效**在匹配成功时播放胜利音效，模拟复古RPG的寻宝过程！

---

## 2. 精选优质题解参考

<eval_intro>
基于思路清晰度、代码规范性和算法效率，我精选了以下优质题解（均≥4★）：
</eval_intro>

**题解一：(作者：suxy15)**
* **点评**：这份题解采用双指针扫描策略（i遍历文章，j追踪单词），亮点在于：
  - 边界处理巧妙：通过`(i==0 || s[i-1]==' ' || j)`精准识别单词起始
  - 内存高效：边读入边处理，避免存储整个长文章
  - 实战性强：用`val()`宏统一大小写，减少函数调用开销
  - 唯一不足：循环条件`++j>-1`可读性稍弱

**题解二：(作者：Eason_lyx)**
* **点评**：该解法展现字符串流的优雅应用：
  - 思路直观：用空格分割单词再逐个比较
  - 代码规范：`tolower`标准库函数提升可读性
  - 关键技巧：`s+=' '`确保捕获末尾单词
  - 特别价值：首次位置计算`i-ci.size()`简洁准确

**题解三：(作者：Jelly_Goat)**
* **点评**：创造性使用字符串修饰技巧：
  - 核心洞察：`' '+str+' '`解决边界匹配难题
  - 算法优化：`string::find`替代手动扫描
  - 跨语言实现：提供Python版本拓宽思路
  - 注意点：`find`的二次搜索需调整起始位置防重叠

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三个关键难点，结合优质题解策略如下：
</difficulty_intro>

1.  **难点：单词边界识别**
    * **分析**：独立单词需前后有空格/边界。优质解法采用：
      - suxy15：检查`s[i-1]==' '`和`s[i+1]==' '`
      - 通用技巧：在文章首尾添加空格（如`" "+s+" "`）
    * 💡 **学习笔记**：边界处理是字符串匹配的基石！

2.  **难点：大小写统一实现**
    * **分析**：
      - 最优方案：遍历时用`tolower()`（Eason_lyx）
      - 位运算技巧：`ch |= 0x20`快速转小写（限ASCII）
      - 避免陷阱：不要遗漏非字母字符
    * 💡 **学习笔记**：预处理统一大小写简化后续比较

3.  **难点：首次位置计算**
    * **分析**：
      - 指针法：`first = i+1-j`（suxy15）
      - 分词法：累计已处理字符数（Eason_lyx）
      - 函数法：`find()`返回索引（Jelly_Goat）
    * 💡 **学习笔记**：位置计算需考虑索引从0开始

### ✨ 解题技巧总结
<summary_best_practices>
提炼三大黄金法则：
</summary_best_practices>
- **技巧1：输入净化**  
  用`getline`读取含空格字符串，立即处理大小写
- **技巧2：边界加固**  
  首尾添加空格消除特殊情况，减少边界判断
- **技巧3：状态机思维**  
  双指针实现扫描状态转移（匹配中/重置）
- **技巧4：API善用**  
  熟悉`string::find`、`tolower`等工具函数

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下通用实现融合了优质题解精华：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合双指针的效率和边界加固的简洁性
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cctype>
    using namespace std;

    int main() {
        string target, article;
        getline(cin, target);
        getline(cin, article);

        // 统一小写化
        for (char &c : target) c = tolower(c);
        for (char &c : article) c = tolower(c);
        
        // 边界加固
        article = ' ' + article + ' ';
        target = ' ' + target + ' ';
        
        int count = 0, first = -1, pos = 0;
        while ((pos = article.find(target, pos)) != string::npos) {
            count++;
            if (first == -1) first = pos;
            pos++;  // 防止重叠匹配
        }
        
        if (count) cout << count << " " << first;
        else cout << -1;
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. **输入净化**：用`getline`读整行，`tolower`统一大小写  
    > 2. **边界加固**：首尾加空格确保单词独立  
    > 3. **高效扫描**：`find()`循环定位目标，pos++避免重复匹配  
    > 4. **结果输出**：首次匹配位置即find()返回值

---
<code_intro_selected>
优质题解片段精析：
</code_intro_selected>

**题解一：(suxy15)**
* **亮点**：双指针实时处理，内存效率极致
* **核心代码片段**：
    ```cpp
    for(i=0,j=0; s[i]!='\0'; ++i){
        if((i==0 || s[i-1]==' ' || j) && tolower(s[i])==tolower(w[j]) && ++j)
            if(w[j]=='\0' && (s[i+1]=='\0' || s[i+1]==' ')){
                if(first==-1) first = i+1-j;
                count++;
            }
        else j=0;
    }
    ```
* **代码解读**：
    > - **状态转移**：`j>0`表示当前处于匹配中状态  
    > - **三层验证**：①边界合规 ②字符匹配 ③单词终止符检查  
    > - **位置魔法**：`i+1-j`计算单词起始位置（考虑j已递增）  
    > - **重置时机**：任何不匹配立刻`j=0`重置状态机
* 💡 **学习笔记**：双指针法适合超长文本的流式处理

**题解二：(Eason_lyx)**
* **亮点**：分词策略直观易理解
* **核心代码片段**：
    ```cpp
    s += ' ';  // 关键！确保捕获末尾单词
    for (char c : s) {
        if (c == ' ') {
            if (word == target) {
                count++;
                if (first == -1) first = start_pos;
            }
            word = "";
        } 
        else {
            if (word.empty()) start_pos = i; // 记录单词起始
            word += c;
        }
    }
    ```
* **代码解读**：
    > - **分词信号**：空格触发单词处理  
    > - **起始捕获**：`word.empty()`时记录`start_pos`  
    > - **位置计算**：`start_pos`动态更新，不受后续影响  
    > - **尾哨兵**：`s+=' '`确保最后单词被处理
* 💡 **学习笔记**：显式分词降低思维复杂度

**题解三：(Jelly_Goat)**
* **亮点**：善用标准库函数
* **核心代码片段**：
    ```cpp
    target = " " + target + " ";
    article = " " + article + " ";
    int pos = article.find(target);
    while (pos != -1) {
        count++;
        if (first == -1) first = pos;
        pos = article.find(target, pos + 1); // 关键+1防重叠
    }
    ```
* **代码解读**：
    > - **空间换稳健**：首尾空格消除边界特判  
    > - **API利器**：`find()`实现O(n)扫描  
    > - **重叠防御**：`pos+1`确保跳过已匹配位置  
    > - **首次捕获**：`first`仅在第一匹配时赋值
* 💡 **学习笔记**：标准库函数常含隐藏优化

-----

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们设计了一个**"单词猎人"**像素游戏动画，直观展示双指针扫描算法：
</visualization_intro>

* **主题**：8-bit风格文字冒险游戏  
* **核心演示**：玩家控制扫描指针穿越字符串平原，捕捉目标单词怪物

### 动画设计
```plaintext
[文章]： T o   b e   o r   n o t   t o   b e  
          ■ ■ □ ■ ■ □ ■ ■ □ ■ ■ ■ □ ■ ■ □ ■ ■ 
[目标]： "to"（金色闪烁）
```

1. **像素艺术**：
   - 字符：8x8像素块（ASCII风格）
   - 指针：■绿色扫描头（当前字符）  
   - 单词边界：□蓝色空格标识符  
   - 匹配状态：匹配中⇒黄色，成功⇒金色闪烁+🎉音效

2. **关键帧流程**：
   ```plaintext
   帧1: [■]o be...       // 初始状态
   帧2: [匹配'T']→ 变黄
   帧3: T[■]o be...      // 移动指针
   帧4: [匹配'o']→ 金色闪烁！(播放胜利音效)
   帧5: 显示"捕获to！位置0"
   ```

3. **交互控制**：
   - 单步执行：空格键逐帧分析
   - 速度滑块：调整扫描速度（1x-10x）
   - 模式切换：双指针模式 vs find()模式对比演示

4. **游戏化元素**：
   - 每捕获一个单词得10分，连续捕获有连击奖励
   - 首次位置匹配触发宝箱开启动画
   - 错误匹配时屏幕震动+❌音效

5. **技术实现**：
   ```javascript
   // 伪代码核心逻辑
   function drawFrame() {
     drawCharGrid(); // 绘制像素字符
     if (isWordStart) flashBorder(); // 边界闪烁
     if (matching) {
        drawPointer('yellow'); 
        if (fullMatch) playSound('victory');
     }
   }
   ```

<visualization_conclusion>
通过像素动画，你可直观看到指针移动、边界识别和状态转换，像玩游戏般掌握算法！
</visualization_conclusion>

-----

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握核心技巧后，挑战这些相似问题：
</similar_problems_intro>

1.  **洛谷 P1553** - 数字反转  
    * 💡 字符串边界的进阶练习，处理小数/分数等复杂情况  
2.  **洛谷 P1598** - 垂直柱状图  
    * 💡 单词统计的变体，需处理多行输入和字符频次  
3.  **洛谷 P1075** - 质因数分解  
    * 💡 看似数学题，实为边界条件处理的极佳训练  

-----

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验尤其珍贵：
</insights_intro>

> **来自suxy15的调试经验**：  
> *"PS: 到底要写多详细才能给过呢= ="*  
>  
> **Kay的解读**：这反映出边界条件测试的重要性！建议：  
> - 测试末尾单词（无尾随空格）  
> - 测试超长文章（1e6边界）  
> - 用`cout << "DEBUG:" << var`输出中间变量  

<conclusion>
通过本次分析，相信你已掌握字符串匹配的核心技巧。记住：编程如探险，边界是藏宝图的关键标记！下次挑战见！🚀
</conclusion>
-----

---
处理用时：126.67秒
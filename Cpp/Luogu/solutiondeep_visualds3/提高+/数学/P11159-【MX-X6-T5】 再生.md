# 题目信息

# 【MX-X6-T5】 再生

## 题目背景

原题链接：<https://oier.team/problems/X6F>。

---

> _このまま$\\$
らったった$\\$
音に乗って$\\$
今きっと世界で僕だけだ$\\$
後ろ向きな歌を聴いて$\\$
少しだけ$\\$
前向きに生きていく_
>
>_—— [再生 - Nanatsukaze](https://music.163.com/#/song?id=2133659925)_

破碎的点依照破碎的规则进行重组，如此再生的一个结构将会是什么样的呢？

## 题目描述

现有一棵 $n$ 个点的有标号有根树，给定其长链剖分得到的 top 数组，请你输出有多少种不同的树可以在长链剖分之后得到该 top 数组。答案对 $20051131$（质数）取模。

具体来说，对于一棵树 $T$，对所有点 $u$ 定义其树高 $h_u$：

- 如果 $u$ 是叶子，则 $h_u=1$。
- 否则设 $u$ 的孩子集合为 $S_u$，则 $h_u=\max\limits_{v\in S_u}h_v + 1$。

给定数组 $t_{1\cdots n}$，你需要计算有多少种树满足：

- 对于根节点 $r$，满足 $t_r=r$。
- 对于每一个不是叶子的节点 $u$，存在恰好一个孩子 $v$ 满足 $h_v+1=h_u$ 并且 $t_v=t_u$，其他孩子满足 $t_v=v$。

模 $20051131$（质数）。

两棵树不同当且仅当它们的根不同或它们的边集不同。

**保证答案不为 $\bf 0$，但是不保证答案在模意义下不为 $\bf 0$。**

## 说明/提示

**【样例解释 #1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/7np2ikvh.png)

仅有图中的两种树满足条件。

**【数据范围】**

对于所有数据，保证 $1\leq n\leq 5\times 10^5$，$1\leq t_i\leq i$，保证取模前答案不为 $0$。

**捆绑测试**，共 5 个 Subtask，具体限制如下所示：

- Subtask 1（11 pts）：$t_i=1$。
- Subtask 2（24 pts）：$n\leq 5$。
- Subtask 3（17 pts）：$n\leq 16$。
- Subtask 4（22 pts）：$n\leq 2\times 10^3$。
- Subtask 5（26 pts）：无特殊限制。

## 样例 #1

### 输入

```
5
1 1 1 4 4```

### 输出

```
2```

## 样例 #2

### 输入

```
16
1 2 1 4 1 4 1 4 9 1 1 12 1 1 12 1```

### 输出

```
7181107```

# AI分析结果

# 💡 Kay的C++算法解析：「再生」深入学习指南 💡


## 引言  
今天我们要一起破解「再生」这道题——它像一场**积木拼搭游戏**：给定一堆“链状积木”，需要你算出有多少种方式把它们拼成符合规则的“树型积木塔”。这道题藏着数学（排列组合）和编程技巧（排序、前缀和）的双重密码，跟着Kay一步步拆解，你会发现它其实很有趣！


## 1. 题目解读与核心算法识别  

✨ **本题主要考察**：数学（排列组合）+ 编程技巧应用（排序、前缀和优化）  

🗣️ **初步分析**  
我们可以把题目中的“链”想象成**带顶的积木条**：  
- 每条积木条的“顶”是固定的（对应链顶`top[i]`），下面的积木块（链中的其他节点）可以任意排列——这部分的排列方式是`(长度-1)!`（比如3块积木的条有2! = 2种摆法）。  
- 拼搭时，**小积木条必须粘在大积木条的“上半部分”**：比如大条长5，小条长3，只能粘在大条的前`5-3=2`个位置（否则会破坏“长链”的规则）。  

具体来说，题解的核心思路是：  
1. **统计链长**：用`cnt[i]`记录`top`数组中值为`i`的节点数（即链的长度）。  
2. **排序链长**：按链长从大到小排序（先拼大积木，再粘小积木）。  
3. **计算方案数**：  
   - 每条链的内部排列：`(cnt[i]-1)!`（阶乘）。  
   - 链的合并方案：第`i`条链（`i>1`）的粘法是**前面所有大积木的长度之和 - (i-1)×当前链长**（用前缀和快速计算）。  

**可视化设计思路**  
我们设计一个**像素风积木工厂游戏**：  
- 每个链是不同颜色的像素积木条（比如红色条长5，蓝色条长3）。  
- 内部排列时，积木块会随机交换位置，伴随“咔嗒”音效。  
- 合并时，大积木先放在左侧，小积木从右侧滑入，可粘的位置用**黄色高亮**，点击后粘上去，伴随“叮”的音效。  
- 自动播放模式下，积木按长度顺序依次合并，屏幕上方实时显示当前方案数。  


## 2. 精选优质题解参考  

<eval_intro>  
我从思路清晰度、代码简洁度和实践价值出发，筛选了以下3份优质题解：  
</eval_intro>  


### **题解一：Register_int的极简实现（5星）**  
* **点评**：这份题解的代码堪称“极简美学”——只用了排序、前缀和和阶乘计算，没有多余的结构。作者抓住了问题的核心：链长统计→排序→阶乘×合并方案。代码中的`cnt`数组统计链长，`sort`降序排列，`sum`维护前缀和，每一步都精准对应思路。尤其是`ans = ans * (sum - (i-1)*cnt[i]) % mod`这句，直接计算合并方案，非常巧妙。  


### **题解二：luxiaomao的分Sub讲解（4星）**  
* **点评**：作者用“分Subtask”的方式逐步推导，从最基础的“全链”（Sub1）到最终的O(n)解法（Sub5），思路递进清晰。比如Sub1中“所有`top[i]=1`”的情况，直接返回`(n-1)!`，让初学者快速理解链内排列的规则；Sub5中用前缀和优化合并方案，把O(n²)降到O(n)，非常适合入门学习。  


### **题解三：modfish_的逆序处理（4星）**  
* **点评**：作者的代码用逆序处理链长（从最长到最短），`sum`维护前面链长的总和，`ans`累积阶乘和合并方案。这种写法避免了额外的排序数组，代码更紧凑。比如`ans = ans * (sum + p - a[i]*(m-i)%p) % p`这句，处理了模运算的负数问题，非常严谨。  


## 3. 核心难点辨析与解题策略  

<difficulty_intro>  
解决这道题的关键在于突破3个“积木拼搭误区”：  
</difficulty_intro>  


### **难点1：为什么链要按长度降序合并？**  
- **问题**：如果先拼短链，可能会出现两条链长度相同的情况（比如两条长3的链），无法合并（会破坏长链剖分的性质）。  
- **解决方案**：先拼最长的链（只有1条，对应树根），再拼次长的（长度肯定更小），以此类推，保证每次合并的链都比前面的小。  


### **难点2：如何快速计算合并方案数？**  
- **问题**：直接计算`sum_{j=1}^{i-1} (len_j - len_i)`是O(n²)，无法处理`n=5e5`的数据。  
- **解决方案**：用**前缀和**维护前面所有链的长度之和`sum`，合并方案数就是`sum - (i-1)*len_i`（因为`sum_{j=1}^{i-1} len_j = sum`，`sum_{j=1}^{i-1} len_i = (i-1)*len_i`）。  


### **难点3：如何处理大数阶乘和模运算？**  
- **问题**：`n=5e5`时，阶乘会非常大，直接计算会溢出。  
- **解决方案**：预处理阶乘数组`fac`，其中`fac[i] = (fac[i-1] * i) % mod`（`mod=20051131`是质数），每次计算都取模。  


### ✨ 解题技巧总结  
- **预处理阶乘**：提前计算`fac`数组，避免重复计算。  
- **排序降序**：先处理大链，避免长度相同的问题。  
- **前缀和优化**：将O(n²)降到O(n)，处理大数据。  


## 4. C++核心代码实现赏析  

<code_intro_overall>  
先看一份**通用核心代码**，它综合了优质题解的思路，简洁高效：  
</code_intro_overall>  


### **本题通用核心C++实现参考**  
* **说明**：本代码来自Register_int的题解，修改了变量名使其更易懂。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

typedef long long ll;
const int MAXN = 5e5 + 10;
const int mod = 20051131;

ll n, cnt[MAXN], fac[MAXN]; // cnt[i]: 链长；fac[i]: i的阶乘

int main() {
    cin >> n;
    // 预处理阶乘
    fac[0] = 1;
    for (int i = 1; i <= n; i++) {
        fac[i] = fac[i-1] * i % mod;
    }
    // 统计链长
    for (int i = 1, x; i <= n; i++) {
        cin >> x;
        cnt[x]++;
    }
    // 按链长降序排序
    sort(cnt + 1, cnt + n + 1, greater<ll>());
    // 计算方案数
    ll ans = 1, sum = 0;
    for (int i = 1; i <= n; i++) {
        if (cnt[i] == 0) break; // 没有更多链了
        // 内部排列：(cnt[i]-1)!
        ans = ans * fac[cnt[i]-1] % mod;
        // 合并方案：sum - (i-1)*cnt[i]
        if (i > 1) {
            ans = ans * (sum - (i-1)*cnt[i]) % mod;
        }
        sum += cnt[i]; // 更新前缀和
    }
    cout << ans << endl;
    return 0;
}
```  
* **代码解读概要**：  
  1. **预处理阶乘**：`fac`数组存储`i! mod mod`。  
  2. **统计链长**：`cnt[x]`记录`top`为`x`的节点数。  
  3. **排序链长**：按从大到小排序，方便合并。  
  4. **计算方案**：依次处理每条链，累积内部排列和合并方案的乘积。  


<code_intro_selected>  
接下来分析优质题解的核心片段：  
</code_intro_selected>  


### **题解一：Register_int的极简合并**  
* **亮点**：用一行代码计算合并方案，简洁到极致。  
* **核心代码片段**：  
```cpp
for (int i = 1; i <= n; i++) {
    if (!cnt[i]) break;
    for (int j = 1; j < cnt[i]; j++) ans = ans * j % mod; // 阶乘
    if (i > 1) ans = ans * (sum - (ll)(i-1)*cnt[i]) % mod; // 合并方案
    sum += cnt[i];
}
```  
* **代码解读**：  
  - 第一句循环：计算`(cnt[i]-1)!`（比如`cnt[i]=3`，循环`j=1,2`，乘1×2）。  
  - 第二句：`sum`是前面链长的总和，`(i-1)*cnt[i]`是前面`i-1`条链各减`cnt[i]`的总和，差就是合并方案数。  
* **学习笔记**：用循环计算阶乘比预处理更省空间，但预处理更高效（适合大n）。  


### **题解二：luxiaomao的前缀和优化**  
* **亮点**：分Subtask讲解，从O(n²)到O(n)的优化过程清晰。  
* **核心代码片段**：  
```cpp
sort(a+1, a+1+n, cmp); // 按链长降序排序
ans = fac[a[1].h-1];
int sum = a[1].h;
for (int i = 2; a[i].h; i++) {
    int cnt = sum - (i-1)*a[i].h; // 合并方案
    ans = ans * cnt % mod * fac[a[i].h-1] % mod;
    sum += a[i].h;
}
```  
* **代码解读**：  
  - `sum`维护前面链长的总和，`cnt`直接计算合并方案。  
  - 作者用结构体`a`存储链长，更清晰，但对于大n，直接用数组更高效。  
* **学习笔记**：结构体可以让代码更易读，但数组更省内存（适合5e5的数据）。  


## 5. 算法可视化：像素动画演示  

<visualization_intro>  
我们设计一个**像素风积木工厂**，让你直观看到链的排列和合并：  
</visualization_intro>  


### **动画演示主题**：积木拼搭游戏  
### **核心演示内容**：  
1. **场景初始化**：  
   - 屏幕左侧是“积木库”（显示所有链的颜色和长度）。  
   - 右侧是“拼搭区”（初始为空）。  
   - 下方有“单步”“自动”“重置”按钮，速度滑块（1x~5x）。  

2. **内部排列演示**：  
   - 选中一条链（比如红色长5），点击“排列”，积木块会随机交换位置，伴随“咔嗒”音效。  
   - 排列完成后，积木条会自动移动到拼搭区。  

3. **合并演示**：  
   - 选中次长链（蓝色长3），拼搭区的红色条会显示**黄色高亮位置**（前2个位置）。  
   - 点击高亮位置，蓝色条会粘上去，伴随“叮”的音效，屏幕上方显示当前方案数（比如`2! × (5-3) = 2×2=4`）。  

4. **自动播放**：  
   - 点击“自动”，积木会按长度顺序依次排列、合并，速度由滑块控制。  
   - 完成所有合并后，播放“胜利”音效（8位风格），屏幕显示最终答案。  


## 6. 拓展练习与相似问题思考  

<similar_problems_intro>  
这道题的核心是**排列组合+前缀和**，类似问题有：  
</similar_problems_intro>  


### **通用思路迁移**  
- 排列组合：计算物体的排列方式（比如`(n-1)!`）。  
- 前缀和：快速计算区间和（比如`sum_{j=1}^{i-1} len_j`）。  


### **洛谷推荐练习**  
1. **P1025 [数的划分]**：考察将数分成k个正整数的和，用动态规划或组合数学解决（类似链的合并）。  
2. **P1287 [盒子与球]**：考察球的排列和盒子的选择，需要计算阶乘和组合数（类似链的内部排列）。  
3. **P1306 [斐波那契公约数]**：考察前缀和和数论，需要快速计算斐波那契数的公约数（类似前缀和优化）。  


## 7. 学习心得与经验分享  

<insights_intro>  
以下是题解中作者的经验分享，非常有价值：  
</insights_intro>  


### **经验1：从长到短合并的原因**（Mr_RoastFish）  
> “如果先拼短链，会出现两条链长度相同的情况，无法合并。从最长链开始，保证每条新链都比前面的小，不会破坏规则。”  
**点评**：这个经验帮我们避开了“长度相同”的坑，是合并顺序的关键。  


### **经验2：链内排列的本质**（SuperCowHorse）  
> “链的根是固定的，其他节点可以任意排列，所以是`(n-1)!`。”  
**点评**：这句话点出了阶乘的本质——根固定，其他节点的全排列。  


## 结论  
本次分析覆盖了“再生”题的核心思路（排列组合、前缀和）、优质题解和可视化动画。希望这份指南能帮助你掌握数学和编程技巧的结合。记住：**编程像拼积木，先理清楚规则，再一步步搭建！**  

下次我们再一起探索新的编程挑战！💪

---
处理用时：89.84秒
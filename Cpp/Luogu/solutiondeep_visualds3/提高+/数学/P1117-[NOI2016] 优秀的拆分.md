# 题目信息

# [NOI2016] 优秀的拆分

## 题目描述

如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  
例如，对于字符串 $ \texttt{aabaabaa} $ ，如果令 $\text{A}=\texttt{aab}$，$\text{B}=\texttt{a}$，我们就找到了这个字符串拆分成 $\text{AABB}$ 的一种方式。

一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  
比如我们令 $\text{A}=\texttt{a}$，$\text{B}=\texttt{baa}$，也可以用 $\text{AABB}$ 表示出上述字符串；但是，字符串 $\texttt{abaabaa}$ 就没有优秀的拆分。

现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。

以下事项需要注意：

1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。
2. 在一个拆分中，允许出现 $\text{A}=\text{B}$。例如 $\texttt{cccc}$ 存在拆分 $\text{A}=\text{B}=\texttt{c}$。
3. 字符串本身也是它的一个子串。

## 说明/提示

### 样例解释

我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。

第一组数据中，共有三个子串存在优秀的拆分：  
$S[1,4]=\texttt{aabb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{b}$；  
$S[3,6]=\texttt{bbbb}$，优秀的拆分为 $\text{A}=\texttt{b}$，$\text{B}=\texttt{b}$；  
$S[1,6]=\texttt{aabbbb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{bb}$。  
而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。

第二组数据中，有两类，总共四个子串存在优秀的拆分：  
对于子串 $S[1,4]=S[2,5]=S[3,6]=\texttt{cccc}$，它们优秀的拆分相同，均为 $\text{A}=\texttt{c}$，$\text{B}=\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  
对于子串 $S[1,6]=\texttt{cccccc}$，它优秀的拆分有两种：$\text{A}=\texttt{c}$，$\text{B}=\texttt{cc}$ 和 $\text{A}=\texttt{cc}$，$\text{B}=\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  
所以第二组数据的答案是 $3+2=5$。

第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。

第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。

我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：

| 测试点编号   | $n \leq$  | 特殊性质           |
| ------------ | --------- | ------------------ |
| $1 \sim 2$   | $300$     | $S$ 中所有字符相同 |
| $3 \sim 4$   | $2\,000$  | $S$ 中所有字符相同 |
| $5 \sim 6$   | $10$      |                    |
| $7 \sim 8$   | $20$      |                    |
| $9 \sim 10$  | $30$      |                    |
| $11 \sim 12$ | $50$      |                    |
| $13 \sim 14$ | $100$     |                    |
| $15$         | $200$     |                    |
| $16$         | $300$     |                    |
| $17$         | $500$     |                    |
| $18$         | $1\,000$  |                    |
| $19$         | $2\,000$  |                    |
| $20$         | $30\,000$ |                    |

## 样例 #1

### 输入

```
4
aabbbb
cccccc
aabaabaabaa
bbaabaababaaba
```

### 输出

```
3
5
4
7
```

# AI分析结果


### 题目分析
本题要求统计字符串中所有子串的「优秀拆分」个数，即形如AABB的拆分方式（A、B为非空字符串）。核心思路是将问题转化为统计以每个位置结尾的AA串数量（f数组）和以每个位置开头的BB串数量（g数组），答案即为Σf[i]*g[i+1]。

#### 核心算法：后缀数组+调和级数枚举
- **关键技巧**：枚举AA串中单个A的长度len，每隔len设置关键点
- **LCP/LCS计算**：通过正反后缀数组快速计算任意两子串的最长公共前缀（LCP）和最长公共后缀（LCS）
- **差分更新**：对满足LCP+LCS≥len的相邻关键点，通过差分数组高效更新f和g

### 精选题解点评
1. **Gypsophila（赞168）**
   - **亮点**：图文并茂解释LCP/LCS与关键点的关系，差分更新逻辑清晰
   - **代码特点**：变量命名规范（lcs/lcp），边界处理严谨（i>1判断）
   - **改进点**：可补充可视化展示关键点与区间更新

2. **何俞均（赞40）**
   - **亮点**：分步骤推导解题思路，代码模块化（SA结构体封装）
   - **代码特点**：ST表实现高效LCP查询，差分更新简洁
   - **改进点**：广告部分可精简，增加复杂度分析

3. **George1123（赞30）**
   - **亮点**：图示展示AA串位置区间，代码精简（单循环差分更新）
   - **代码特点**：正反串处理对称，区间推导数学严谨
   - **改进点**：可补充调试技巧（如边界值测试）

### 核心难点与策略
1. **关键点设置与区间推导**
   - 难点：理解相邻关键点i与j=i+len如何确定AA串位置
   - 策略：LCP覆盖j之后区域，LCS覆盖i之前区域，交集即有效区间
   - 公式：若LCP+LCS≥len，则AA串开头区间[i-lcs, i-lcs+(lcp+lcs-len)]

2. **差分数组优化**
   - 难点：避免O(n²)暴力更新
   - 策略：差分标记区间起止点，最后前缀和计算实际值

3. **LCP/LCS计算加速**
   - 难点：快速查询任意两子串的LCP/LCS
   - 策略：后缀数组+ST表预处理，实现O(1)查询

### C++核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN = 30000 + 5;

struct SA {
    // 后缀数组实现（省略）
};

SA sa1, sa2; // 正反串
LL f[MAXN], g[MAXN], ans;
char s[MAXN];
int n;

void solve() {
    n = strlen(s + 1);
    sa1.build(s, n);         // 正串SA
    reverse(s + 1, s + n + 1);
    sa2.build(s, n);         // 反串SA

    memset(f, 0, sizeof(f)); // 差分数组
    memset(g, 0, sizeof(g));

    for (int len = 1; len <= n / 2; len++) {
        for (int i = len, j = i + len; j <= n; i += len, j += len) {
            int lcp = min(len, sa1.lcp(i, j));
            int lcs = (i == 1) ? 0 : min(len - 1, sa2.lcp(n - (i - 1) + 1, n - (j - 1) + 1));
            
            if (lcp + lcs >= len) {
                int t = lcp + lcs - len + 1;
                g[i - lcs]++;      // 开头位置区间起点
                g[i - lcs + t]--;  // 区间终点+1
                f[j + lcp - t]++;  // 结尾位置区间起点
                f[j + lcp]--;      // 区间终点+1
            }
        }
    }

    // 前缀和求实际值
    for (int i = 1; i <= n; i++) {
        f[i] += f[i - 1];
        g[i] += g[i - 1];
    }

    ans = 0;
    for (int i = 1; i < n; i++) 
        ans += f[i] * g[i + 1];  // 统计答案
    cout << ans << endl;
}

int main() {
    int T; cin >> T;
    while (T--) {
        cin >> (s + 1);
        solve();
    }
}
```

### 算法可视化设计
- **像素动画演示**：
  1. **初始化**：8-bit风格字符串，每len字符标红（关键点）
  2. **LCP/LCS计算**：
     - 绿色高亮：i与j的后缀LCP（向后延伸）
     - 蓝色高亮：i-1与j-1的前缀LCS（向前延伸）
  3. **AA串判定**：若绿+蓝≥len，黄色闪烁标记AA串区间
  4. **差分更新**：f/g数组对应位置显示↑/↓箭头
  5. **结果展示**：柱状图展示f/g数组，最后计算答案

- **交互控制**：
  - 步进/暂停：观察每步状态
  - 速度滑块：调整动画速度
  - 重置：重新开始演示

### 拓展练习
1. **基础巩固**：
   - 洛谷P3809（后缀排序）
   - 洛谷P3763（DNA序列匹配）

2. **进阶挑战**：
   - 洛谷P2852（可重叠至少k次最长子串）
   - CodeForces 319D（破坏子串）

3. **变形问题**：
   - 求ABCABC型拆分方案数
   - 统计ABCDCD型子串数量

> 学习提示：先掌握后缀数组原理，再尝试独立实现差分更新部分。调试时可用"aabbbb"等样例验证。

---
处理用时：934.41秒
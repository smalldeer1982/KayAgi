# 题目信息

# 图书馆书架上的书

## 题目背景

NOIP2014 即将来临，JC 书院信息学兴趣小组也在积极准备着，于是乎 usqwedf 、梁大大、畜牧办专场、YH 大神和 LHT 大神也要推出“蓝翔杯”。

在图书馆、 MC 等大神们相继举办了 JC 书院联合竞赛“弃疗杯”“UID#3”，据说 YH 大神还要苦苦钻研网络流的 JC 书院 $13$ 届 $13$ 班的 WZF 神牛和 MZC 神牛听到这个消息后决定联袂打造“十三点杯”。但是出一套题目是一项繁重的工作，于是他们决定再拉上和他们同届并且同班还同为 JC 书院信息学兴趣小组成员同时也在图书馆正在找“Hello World”标程的蒟蒻 SY。

可怜的蒟蒻 SY 因为还要写一大堆的作业，怎么也不肯答应，终于 WZF 神牛妥协说：“我来出一道题，你要是做出来了我们就不让你出题，否则……你懂的。”蒟蒻 SY 才刚看完 WZF 神牛即兴出的题目，便带着哭腔对 WZF 神牛说：“你们赢了。”。

可是蒟蒻 SY 实在是太弱了，根本不会出题，他绞尽脑汁，终于想到了一个办法——将 WZF 神牛出的题目 copy 一下。

## 题目描述

图书馆有 $n$ 个书架，第 $1$ 个书架后面是第 $2$ 个书架，第 $2$ 个书架后面是第 $3$ 个书架……第 $n-1$ 个书架后面是第 $n$ 个书架，第 $n$ 个书架后面是第 $1$ 个书架，第 $i$ 个书架上有 $b_i$ 本书。现在，为了让图书馆更美观，WZF 神牛让蒟蒻 SY 搬动书架上的书，使每个书架上的书一样多。由于搬动的书可能会很多，所以蒟蒻 SY 只能将一个书架上的书搬到与其相邻的两个书架上。那么蒟蒻 SY 最少搬动几本书呢？

## 说明/提示

### 数据范围及约定

对于全部数据，$1\le n\le 10^5+1$，且 $n$ 必为奇数；$b_i\le 10^7$。

若 $af_i$ 为负数，则说明蒟蒻 SY 要把第 $i$ 个书架前面的那个书架上的 $-af_i$ 本书搬到第 $i$ 个书架上。

同理，若 $ab_i$ 为负数，则说明蒟蒻 SY 要把第 $i$ 个书架后面的那个书架上的 $-ab_i$ 本书搬到第 $i$ 个书架上。


## 样例 #1

### 输入

```
5
15 7 11 3 14
```

### 输出

```
12
2 3
-3 0
0 1
-1 -6
6 -2
```

# AI分析结果


# 💡 Kay的C++算法解析：图书馆书架上的书 深入学习指南 💡

<introduction>
今天我们来分析「图书馆书架上的书」这道经典的环形均分纸牌问题。本指南将帮助大家掌握数学建模技巧和中位数应用的核心思想，并通过生动的像素动画直观理解算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学建模与中位数应用` 

🗣️ **初步分析**：
> 这道题就像一群小朋友围成一圈分糖果，每人手上的糖果数不同，只能分给相邻两人。核心思路是将"搬动书本"转化为数学问题：  
> - 通过建立环形方程组，将问题转化为绝对值求和最小化问题  
> - 利用中位数性质求最优解（想象在数轴上找离所有点最近的位置）  
> - 可视化设计将展示书本流动过程，用不同颜色标记当前操作书架  
> - 采用8-bit像素风格，书本移动时有"沙沙"音效，成功均分时播放胜利音效  
> - 控制面板支持单步执行/自动播放，可调速观察数据变化  

---

## 2. 精选优质题解参考

<eval_intro>
以下题解在思路清晰度、代码规范性和算法实现上表现优异：

**题解一：(来源：big_news)**
* **点评**：该题解通过严谨的数学推导（建立环形方程组→前缀和变换→中位数定理），完整展示了问题转化过程。代码结构清晰（递归计算前缀和→排序求中位数→输出搬运方案），变量命名规范（`c[]`表累积差量，`rec[]`存原始值）。亮点在于用数轴距离模型直观解释中位数最优性。

**题解二：(来源：nth_element)**
* **点评**：以分糖果的生动类比引入，逐步拆解环形问题本质。代码实现高效（利用`nth_element`优化中位数查找），时间复杂度O(n)优于常规排序。特别值得学习的是前缀和递推的简洁写法（`sum[i]=sum[i-1]+a[i]-avg`）和边界处理技巧。

**题解三：(来源：lixuanyan)**
* **点评**：提供双视角解法（方程组变形/环断开重排），强化举一反三能力。亮点在于用"缩边"理论证明环形问题最优性，并推荐系列拓展习题（负载平衡/糖果传递）。代码中的临时数组处理避免原始数据顺序丢失，实践性很强。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决环形均分问题的三个关键难点及突破策略：

1.  **关键点1：环形问题线性化**
    * **分析**：通过引入虚拟变量x_i（第i书架给i-1的书本数），将环形依赖转化为链式方程。关键在于发现x_n = x_1 - Σ(a_i - avg)的数学关系，消去环形依赖。
    * 💡 **学习笔记**：环形问题常通过虚拟变量和前缀和转化为线性问题。

2.  **关键点2：绝对值最小化证明**
    * **分析**：问题最终转化为minΣ|x1 - c_i|。利用中位数性质（数轴距离和最小）和奇偶性讨论（n为奇数有唯一解），通过排序快速确定最优x1。
    * 💡 **学习笔记**：涉及绝对值求和的最优化问题，优先考虑中位数性质。

3.  **关键点3：搬运方案逆向推导**
    * **分析**：根据x_i = x1 - rec[i]反推每个书架的给书量。难点在于环形收尾处理（第n书架给第1书架），需特殊计算x_{n+1} = x1。
    * 💡 **学习笔记**：环形问题要特别注意首尾衔接的边界处理。

### ✨ 解题技巧总结
<summary_best_practices>
1. **前缀和转化**：将累积差量c_i = Σ(a_k - avg)作为核心中间变量  
2. **中位数优化**：使用nth_element代替sort，复杂度从O(nlogn)降至O(n)  
3. **环形破链**：通过数学证明环形与线性问题的等价性，复用线性解法  
4. **变量复用**：rec数组同时存储原始值和最终搬运量，减少内存占用  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
综合优质题解提炼的通用实现（完整可编译）：

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 5e5+5;

int main() {
    int n; cin >> n;
    LL a[N], c[N] = {0}, sum = 0;
    
    // 输入并计算平均值
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        sum += a[i];
    }
    LL avg = sum / n;
    
    // 计算前缀和数组c
    for (int i = 1; i <= n; i++) 
        c[i] = c[i-1] + a[i] - avg;
    
    // 获取中位数（nth_element优化）
    nth_element(c+1, c+n/2+1, c+n+1);
    LL x1 = c[n/2+1], ans = 0;
    
    // 计算最小搬运量
    for (int i = 1; i <= n; i++)
        ans += abs(x1 - c[i]);
    
    // 输出搬运方案
    cout << ans << endl;
    for (int i = 1; i < n; i++) 
        cout << x1 - c[i-1] << " " << -(x1 - c[i]) << endl;
    cout << x1 - c[n-1] << " " << -x1; // 环形收尾
    return 0;
}
```
* **代码解读概要**：
  1. 输入书本数并计算平均值  
  2. 关键：计算前缀和数组c（累积差量）  
  3. 用nth_element快速获取中位值x1  
  4. 根据中位值计算最小搬运量  
  5. 逆向推导每个书架的搬运方案（注意环形收尾）  

---
<code_intro_selected>
各题解核心片段赏析：

**题解一：(big_news)**
* **亮点**：严谨数学推导的代码实现
* **核心代码片段**：
```cpp
sort(c+1,c+n+1);
x1 = c[(n+1)/2]; 
for(int i=1;i<=n;i++)
    ans += abs(x1-c[i]);
```
* **代码解读**：先对前缀和数组排序，取中间位置值作为中位数。绝对值求和时，每个c[i]到x1的距离即该点的搬运量。为什么取中位？因为数轴上中位数到各点距离和最小。

**题解二：(nth_element)**
* **亮点**：高效中位值查找
* **核心代码片段**：
```cpp
nth_element(sum+1, sum+n/2+1, sum+n+1);
LL mid=sum[n/2+1];
```
* **代码解读**：nth_element将第k大元素放到指定位置，其他元素无序但保证左侧≤中位值≤右侧。相比完全排序(O(nlogn))，该操作仅需O(n)时间，对大数据更高效。

**题解三：(lixuanyan)**
* **亮点**：环形搬运方案推导
* **核心代码片段**：
```cpp
for(int i=1; i<n; i++)
    cout << -b[i-1] << " " << b[i] << endl;
cout << -b[n-1] << " " << b[1];  // 环形收尾
```
* **代码解读**：第i书架给左边的书 = -b[i-1]，给右边的书 = b[i]。环形收尾时，末书架给左边= -b[n-1]，给右边= b[1]（因b[n]对应首书架）。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
**像素探险家书库整理大作战**：用8-bit风格动态演示书本搬运过程，帮你直观理解中位数原理！

* **整体风格**：FC红白机复古像素风（16色调色板），书架=棕色像素块，书本=蓝色小方块
* **核心演示**：中位数求解 → 书本流动过程 → 环形搬运方案

**动画流程**：
1. **场景初始化**  
   - 像素书库：环形排列的书架（带编号像素块），书本数用蓝色方块堆叠表示  
   - 控制面板：开始/暂停、单步、速度滑块（兔龟图标）

2. **前缀和计算（动态进度条）**  
   ``` 
   [书架1] 15-10=5 ➔ 累积差c1=5（黄色↑箭头）  
   [书架2] 7-10=-3 ➔ c2=5-3=2（红色↓箭头）  
   ```
   - 音效：计算时"滴"声，数值更新时"咔嗒"

3. **中位值确定（数轴演示）**  
   - 排序过程：像素数值块在数轴上冒泡排序（拟人化挣扎效果）  
   - 中位标记：紫色闪光框锁定中间值（c[3]=1）

4. **书本搬运（流动动画）**  
   - 书架1→2：3本书（蓝色方块沿虚线移动+轨迹残影）  
   - 书架3→4：1本书（小尺寸流动效果）  
   - 负值处理：反向流动动画（书架5←4，6本书）

5. **胜利结算**  
   - 所有书架变绿色，弹出"SUCCESS!"像素艺术字  
   - 播放8-bit胜利旋律（↑↑↓↓←→←→BA音效彩蛋）

**交互设计**：
- 单步模式：按步显示数学公式（如|x1-c_i|计算）  
- 自动模式："AI图书员"自动搬运，速度可调  
- 错误演示：故意选非中位数，显示搬运量增加的红字提示  

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握环形均分问题的核心思想后，可解决更多变体：

1. **洛谷 P2512** - 糖果传递  
   * 同类环形均分问题，数据规模更大（测试数学优化能力）

2. **洛谷 P4016** - 负载平衡问题  
   * 引入网络流解法对比，加深对中位数解的理解

3. **洛谷 P1031** - 均分纸牌（线性版）  
   * 基础版练习，帮助理解前缀和的应用

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验摘录：

> **big_news作者心得**：  
> "最初推导方程组时忽略了环形特性，导致无法闭合。通过手工模拟n=3的小数据才发现漏了首尾衔接方程"

> **Kay总结**：  
> 手工模拟小数据是验证环形问题模型的利器！建议：  
> 1. 从n=3开始推演  
> 2. 画环形示意图标注变量  
> 3. 用具体数值验证方程  

---

<conclusion>
通过本次分析，我们深入掌握了环形均分问题的数学建模和中位数应用精髓。记住：将复杂问题转化为数学模型是编程解题的钥匙！下次遇到类似问题，不妨先问自己："累积差量如何计算？中位值在哪里？" 保持思考，编程之旅将越走越宽广！🚀
</conclusion>
```

---
处理用时：122.19秒
# 题目信息

# 【模板】矩阵求逆

## 题目描述

求一个 $N\times N$ 的矩阵的逆矩阵。答案对 ${10}^9+7$ 取模。

## 说明/提示

对 $30 \%$ 的数据有 $N\le 100$；  
对 $100 \%$ 的数据有 $N\le 400$，所有 $0 \le a_{i j} < {10}^9 + 7$。

## 样例 #1

### 输入

```
3
1 2 8
2 5 6
5 1 2```

### 输出

```
718750005 718750005 968750007
171875001 671875005 296875002
117187501 867187506 429687503```

## 样例 #2

### 输入

```
3
3 2 4
7 2 9
2 4 3```

### 输出

```
No Solution```

# AI分析结果


# 💡 Kay的C++算法解析：矩阵求逆 深入学习指南 💡

欢迎各位算法探索者！今天我们将深入剖析**矩阵求逆**这道经典线性代数问题。作为C++算法导师，我将引导大家理解核心思路、攻克难点，并通过生动的像素动画可视化算法过程。准备好了吗？让我们开始吧！

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`高斯-约旦消元法` + `模运算技巧`

🗣️ **初步分析**：
> 矩阵求逆就像在解一个"数字魔方"——我们需要通过精确的行变换操作，将左侧矩阵变成单位矩阵，同时右侧的单位矩阵就会神奇地变成逆矩阵！这个过程需要：
> - **关键技巧**：在模运算环境下，用**乘法逆元**替代除法（费马小定理）
> - **核心流程**：构造增广矩阵[A|I] → 通过行变换使A变成I → 此时I变为A⁻¹
> - **可视化要点**：动画将展示像素矩阵的变换过程，高亮显示主元选择、行交换和消元操作，用不同颜色标识变换阶段
> - **复古游戏化**：采用8-bit像素风格，矩阵元素化作可旋转的方块，行变换时播放经典NES音效，成功求逆时触发"胜利"动画

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性和算法优化角度，我为大家精选以下优质题解：

**题解一：一只萌新 (高斯-约旦消元法)**
* **点评**：此解法思路清晰直白，完美呈现了"矩阵分身术"的精髓——通过增广矩阵同步变换。代码中：
  - 主元选择机制避免除零错误（`if(!a[i][i])`检测）
  - 逆元计算（`qpow(a[i][i],mod-2)`）处理模除法
  - 同步更新双矩阵逻辑简洁（单循环处理n<<1列）
  - 特别亮点：用"消元三步曲"比喻行变换，通俗易懂

**题解二：bztMinamoto (初等矩阵变换法)**
* **点评**：此解采用面向对象思维，将矩阵操作封装为：
  - `change1`行交换
  - `change2`行缩放
  - `change3`行加减
  代码如乐高积木般模块化，特别适合学习OOP思想。亮点在于严格遵循"操作即函数"原则，使线性代数理论直观落地。

**题解三：cosmicAC (原地变换优化版)**
* **点评**：此解展现极致空间优化：
  - 仅用O(1)额外空间记录行列交换
  - 独创"右下角方阵枚举"消元顺序
  - 逆序恢复行列顺序的精妙设计
  亮点在于突破常规思维，用空间换可读性的取舍值得深思。
---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
攻克矩阵求逆需突破三大关卡：

1.  **主元选择与零除风险**
    * **分析**：当主元为零时，传统算法崩溃。优质解法采用"主元搜索+行交换"策略（如`if(!a[i][i])`检测后交换最大非零行）。在模环境中，还需确保主元与模数互质。
    * 💡 **学习笔记**：主元是算法支柱，选择不当会导致矩阵"崩塌"。

2.  **模运算中的除法转化**
    * **分析**：在mod 10⁹+7环境下，除法需转为乘逆元。各解法均采用费马小定理（`a^(mod-2)`），但需注意：
      - 先检测a≠0
      - 负值需转正
    * 💡 **学习笔记**：模世界中的除法是戴着手套的操作——需要逆元转换。

3.  **双矩阵同步更新**
    * **分析**：保持[A|I]的同步变换如同同时操控两个魔方。难点在于：
      - 行操作必须同时作用于双矩阵
      - 消元系数计算需精确
    * 💡 **学习笔记**：想象你的双手在同步控制两个矩阵，任何不协调都会导致结果错误。

### ✨ 解题技巧总结
<summary_best_practices>
- **技巧1：防御性编程**：所有解法都包含`if(!a[i][i])`检测，避免零除崩溃
- **技巧2：循环优化**：消元时跳过当前行（`if(j!=i)`），减少50%无效计算
- **技巧3：原位更新**：cosmicAC解法展示如何用O(1)空间记录行列交换
- **技巧4：模块封装**：bztMinamoto的矩阵操作函数是代码复用的典范
---

## 4. C++核心代码实现赏析

<code_intro_overall>
**本题通用核心C++实现**
```cpp
#include <iostream>
#include <vector>
using namespace std;
const int MOD = 1e9+7;

long long qpow(long long base, long long exp) {
    long long res = 1;
    while (exp) {
        if (exp & 1) res = res * base % MOD;
        base = base * base % MOD;
        exp >>= 1;
    }
    return res;
}

void matrix_inv(vector<vector<long long>>& a) {
    int n = a.size();
    vector<vector<long long>> inv(n, vector<long long>(n, 0));
    for (int i = 0; i < n; i++) inv[i][i] = 1;

    for (int i = 0; i < n; i++) {
        int pivot = i;
        for (int j = i + 1; j < n; j++)
            if (abs(a[j][i]) > abs(a[pivot][i])) 
                pivot = j;

        if (!a[pivot][i]) { 
            cout << "No Solution";
            return;
        }
        swap(a[i], a[pivot]);
        swap(inv[i], inv[pivot]);

        long long factor = qpow(a[i][i], MOD - 2);
        for (int j = 0; j < n; j++) {
            a[i][j] = a[i][j] * factor % MOD;
            inv[i][j] = inv[i][j] * factor % MOD;
        }

        for (int j = 0; j < n; j++) {
            if (i == j) continue;
            long long ratio = a[j][i];
            for (int k = 0; k < n; k++) {
                a[j][k] = (a[j][k] - a[i][k] * ratio % MOD + MOD) % MOD;
                inv[j][k] = (inv[j][k] - inv[i][k] * ratio % MOD + MOD) % MOD;
            }
        }
    }
    a = inv;
}
```

---
<code_intro_selected>
**题解一核心片段赏析**
```cpp
int kk = qpow(a[i][i], mod-2); // 逆元计算
for (int j = 1; j <= n; j++) {
    if (j == i) continue;
    int p = a[j][i] * kk % mod; // 计算消元系数
    for (int k = i; k <= (n<<1); k++) // 双矩阵同步更新
        a[j][k] = ((a[j][k] - p * a[i][k]) % mod + mod) % mod;
}
```
> **解读**：此片段展现消元核心逻辑
> 1. 当前行i的逆元kk是"魔法系数"
> 2. 对每行j≠i，计算消元比例p
> 3. 从第i列开始更新，避免重复计算
> 💡 **学习笔记**：消元如同多米诺骨牌——当前行是推手，其他行应声而倒

**题解二创新点解析**
```cpp
void change3(int x, int y, int k) { // 行加减操作
    for (int i = 0; i < n; i++)
        a[x][i] = (a[x][i] + a[y][i] * k % MOD) % MOD;
}
```
> **解读**：将行变换抽象为独立函数
> - 参数设计体现数学本质 (x=目标行, y=源行, k=比例)
> - 模运算防御性处理确保非负
> 💡 **学习笔记**：好的封装如同乐高积木——简单组件构建复杂系统

**题解三空间优化技巧**
```cpp
for (int k = n; k; k--) { // 逆序恢复行列
    swap(a[js[k]], a[k]); // 恢复列交换
    swap(a[k], a[is[k]]); // 恢复行交换
}
```
> **解读**：创新性地记录交换轨迹(is/js数组)
> - 消元时记录所有交换操作
> - 结束后逆序还原
> 💡 **学习笔记**：空间优化如同折纸艺术——通过精巧折叠减少占用
-----

## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
让我们通过8-bit像素动画，直观感受高斯-约旦消元的魔法！设计灵感来自经典游戏《俄罗斯方块》和《数独》。

**主题**："矩阵求逆大冒险"  
**核心机制**：将矩阵转化为可交互的像素方块，每个方块代表矩阵元素

### 动画设计
1. **场景初始化**  
   - 左侧区域：8×8像素网格显示矩阵A，数值映射为方块颜色（深蓝=0，亮黄=非零）
   - 右侧区域：单位矩阵I初始为红色对角线
   - 控制面板：步进/自动/重置按钮 + 速度滑块

2. **关键操作可视化**  
   ```plaintext
   第1步：主元选择 [音效：NES选择声]
      - 当前列i扫描，最大元素方块闪烁红光
      - 行交换时两行方块水平滑动交换位置 [音效：滑动声]
   
   第2步：行归一化 [音效：缩放声]
      - 主元所在行所有方块收缩后放大（缩放动画）
      - 显示当前逆元计算：factor = qpow(a[i][i], mod-2)
   
   第3步：消元操作 [音效：消除声]
      - 源行方块投射"光束"到目标行
      - 目标行方块数值变化时颜色渐变（蓝→黄）
   ```

3. **游戏化元素**  
   - 每完成一列消元，解锁一个"技能徽章"
   - 最终成功时，右侧矩阵绽放烟花动画 [音效：胜利号角]
   - 失败时显示"No Solution"像素艺术字

### 技术实现
- **Canvas绘制**：每个方块用8×8像素矩阵渲染
- **状态同步**：核心变量映射到动画参数
- **伪代码展示**：底部同步高亮当前执行的算法步骤

\<visualization\_conclusion\>
通过像素动画，抽象的行变换化为可见的方块舞蹈，帮助建立直观的矩阵操作心智模型。
-----

## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
掌握矩阵求逆后，你可挑战这些进阶问题：

1.  **洛谷 P3389** - 高斯消元法  
    🗣️ **推荐理由**：学习高斯消元基础，理解矩阵求逆的前置知识

2.  **洛谷 P1939** - 矩阵加速数列  
    🗣️ **推荐理由**：将矩阵求逆扩展为矩阵幂运算，体验算法优化威力

3.  **洛谷 P2453** - 最小二乘法  
    🗣️ **推荐理由**：在矩阵不可逆时求近似解，拓展数学边界认知
-----

## 7. 学习心得与经验分享

\<insights\_intro\>
从题解中提炼的宝贵经验：

> **来自一只萌新的调试经验**：  
> "我在处理负值时卡住，直到添加`(x%mod+mod)%mod`才解决。这教会我：模运算中，防御性编码不是可选项，是生存法则！"

> **Kay的总结**：  
> 矩阵运算如同精密钟表——每个齿轮必须严丝合缝。特别注意：
> 1. 消元前检测主元是否为0
> 2. 负值转正后再模运算
> 3. 同步更新双矩阵时注意列范围
> 这些细节决定成败！

\<conclusion\>
恭喜完成本次矩阵求逆之旅！记住：编程能力如同矩阵变换——通过持续学习"行变换"，终将把知识基化为智慧的单位矩阵。下次算法冒险再见！🚀

---
处理用时：163.44秒
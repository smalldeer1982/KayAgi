# 题目信息

# 选择题

## 题目描述

docriz 正在考试，他遇到了一个奇怪的选择题：这个选择题共有 $n$ 个选项，其中只有一个选项是正确的。他完全不会做这题，所以只能靠蒙。

蒙这道题分为 $n - 2$ 轮，在第 $1$ 轮开始之前，docriz 会在这 $n$ 个选项中随机蒙一项，之后的每轮流程如下：首先，nocriz 会过来帮他排除一个选项，由于 nocriz 事先知道答案，所以他会在现有的除正确的那一项和 docirz 正在选的那一项外的选项里，随机删去一个。之后，docriz 可以选择是否更换自己蒙的选项，如果更换，则随机更换到除正在选的那一项之外的任意一项。

docriz 在这 $n - 2$ 轮中，由于和 nocriz 达成的神秘协定，需要恰好更换 $k$ 次选项。他想知道，如何更换，使得自己蒙对的概率最大，输出这个概率。为了方便，你需要输出这个概率的分数形式在模 $10^9 + 7$ 意义下的结果。

## 说明/提示

样例 $1$ 到 $4$ 分别为 $\frac{2}{3}, \frac{1}{3}, \frac{3}{4}, \frac{5}{8}$。

对于 $30\%$ 的数据，保证 $5 \leq n \leq 10$。

对于另外 $5\%$ 的数据，保证 $k = 0$。

对于另外 $10\%$ 的数据，保证 $k = 1$。

对于另外 $10\%$ 的数据，保证 $k = n - 2$。

对于另外 $5\%$ 的数据，保证 $n \leq 10^2$。

对于另外 $10\%$ 的数据，保证 $n \leq 10^3$。

对于 $100\%$ 的数据，保证 $5 \leq n \leq 10^5, 0 \leq k \leq n - 2$。

## 样例 #1

### 输入

```
3 1```

### 输出

```
666666672```

## 样例 #2

### 输入

```
3 0```

### 输出

```
333333336```

## 样例 #3

### 输入

```
4 1```

### 输出

```
750000006```

## 样例 #4

### 输入

```
4 2```

### 输出

```
625000005```

## 样例 #5

### 输入

```
100000 99998```

### 输出

```
439903656```

# AI分析结果


```markdown
# 💡 Kay的C++算法解析：选择题蒙题策略 深入学习指南 💡

<introduction>
今天我们一起分析“选择题蒙题策略”这道C++编程题。题目要求计算在特定策略下蒙对选择题的概率，涉及概率递推和模数运算。本指南将帮助大家理解核心算法逻辑、掌握递推技巧，并通过像素动画直观感受概率变化过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学概率与递推`

🗣️ **初步分析**：
> 本题本质是**概率决策问题**，就像在玩一个多层抽奖游戏：每次主持人（nocriz）会帮你排除错误选项，而你可以选择是否更换奖券。最优策略是前k-1次故意保持错误（增加最后一次更换时的正确概率），最后一次更换时抓住机会。  
> - 核心难点在于推导**概率递推公式**：每轮更换后选错的概率 = `1 - 上次选错概率/(剩余选项数-1)`  
> - 可视化设计重点：用像素方块表示选项状态变化，高亮当前选择/正确选项/排除项，动态显示概率值  
> - 复古游戏化设计：8-bit音效（排除时“咔嚓”、更换时“滴答”）、胜利音效、步进控制面板，像闯关游戏般展示算法流程

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰性、代码规范性和算法优化度等维度，我为大家精选出以下优质题解：

**题解一（来源：Itst）**
* **点评**：思路直击核心——用递推公式计算选错概率（`P_i = 1 - P_{i-1}/(n-2)`），代码简洁高效（快速幂求逆元）。变量命名清晰（`fz`/`fm`），边界处理严谨（k=0特判），复杂度O(k)完美匹配数据规模。亮点在于将复杂概率问题转化为简洁数学推导。

**题解二（来源：揽月摘星辰）**
* **点评**：详解最优策略的数学原理（前k-1次保持错误），代码实现完整（扩展gcd求逆元）。亮点在于用通俗比喻解释贝叶斯公式（如三门问题），并强调调试技巧（负值处理）。实践价值高，帮助理解概率递推本质。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三个关键难点，以下是应对策略：

1.  **最优决策时机的选择**
    * **分析**：更换次数有限时，前k-1次应尽量保持错误（增大最后一次更换时的正确概率），最后一次在剩余选项最少时更换。如n=4,k=2时，应在第一轮后保持错误，第二轮后更换。
    * 💡 **学习笔记**：贪心思想——将关键操作留在成功概率最高的时机。

2.  **概率递推公式的推导**
    * **分析**：设当前选错概率P，剩余选项数x。更换后新选错概率 = `P*(x-2)/(x-1) + (1-P)` = `1 - P/(x-1)`。递推时需同步更新分子分母（避免浮点误差）。
    * 💡 **学习笔记**：概率转移要考虑两种场景（上次选错/选对）。

3.  **模数下分数的处理**
    * **分析**：最终概率需表示为分数模10^9+7。核心技巧是求分母逆元：`a/b mod M = a * b^{M-2} mod M`（费马小定理）或扩展gcd解线性方程。
    * 💡 **学习笔记**：大数分数运算必用逆元技巧。

### ✨ 解题技巧总结
<summary_best_practices>
通过本题提炼的通用技巧：
</summary_best_practices>
-   **问题分解技巧**：将多轮决策拆解为单次概率转移，聚焦状态定义（剩余选项数/选错概率）
-   **递推优化技巧**：用整数分子分母代替浮点，同步更新避免累积误差
-   **边界测试技巧**：特别注意k=0, k=n-2等边界，用样例验证递推公式

---

## 4. C++核心代码实现赏析

<code_intro_overall>
通用实现基于概率递推+逆元计算，完整代码：

```cpp
#include <iostream>
using namespace std;
const int MOD = 1e9 + 7;

long long modPow(long long base, long long exp) {
    long long res = 1;
    while (exp) {
        if (exp & 1) res = (res * base) % MOD;
        base = (base * base) % MOD;
        exp >>= 1;
    }
    return res;
}

int main() {
    long long n, k;
    cin >> n >> k;
    
    if (k == 0) { // 不更换时概率=1/n
        cout << modPow(n, MOD - 2);
        return 0;
    }
    
    long long fz = n - 1; // 初始选错概率分子
    long long fm = n;     // 分母
    
    for (int i = 0; i < k; ++i) {
        // 递推公式: P_i = 1 - P_{i-1}/(n-2)
        fz = (fm * (n - 2) - fz) % MOD;
        fm = fm * (n - 2) % MOD;
        n--; // 选项数递减
    }
    long long inv_fm = modPow(fm, MOD - 2);
    cout << (fz * inv_fm % MOD + MOD) % MOD;
}
```

**代码解读概要**：
1. 处理特例k=0（直接返回1/n）
2. 初始化概率为选错概率`(n-1)/n`
3. 循环k次递推更新分子分母（核心公式）
4. 用快速幂求分母逆元并输出最终概率

---
<code_intro_selected>
优质题解的核心代码亮点解析：

**题解一（Itst）**
* **亮点**：循环内联公式，同步更新分母
```cpp
fz = ((fm = fm * n % MOD) - fz) % MOD;
```
* **代码解读**：
  > 精妙之处在于合并分母计算与分子更新：`fm * n`先更新分母，再用新分母减分子。注意：
  > 1. `n`在循环中递减，代表剩余选项数-2
  > 2. 负值处理：输出前用`(fz+MOD)%MOD`修正
* 💡 **学习笔记**：同步更新相关变量可提升代码简洁性。

**题解二（揽月摘星辰）**
* **亮点**：扩展gcd求逆元，通用性更强
```cpp
void exgcd(long long a, long long b, long long &x, long long &y) {
    if (b == 0) { x = 1; y = 0; return; }
    exgcd(b, a % b, y, x);
    y -= x * (a / b);
}
```
* **代码解读**：
  > 1. 递归求解方程 `a*x + b*y = gcd(a,b)`
  > 2. 当b=0时，x=1,y=0是基础解
  > 3. 递归后调整解：`y -= x*(a/b)`  
  > 逆元调用：`exgcd(b, MOD, x, y)` 返回x
* 💡 **学习笔记**：扩展gcd适用于非质数模数。

-----

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为直观展示概率递推过程，我设计了一个**8-bit风格答题闯关游戏**，你将扮演docriz在复古界面中做决策：

<center>
🕹️ 控制面板：开始/暂停｜步进▶️｜速度滑块｜重置🔄
</center>
</visualization_intro>

* **游戏场景设计**：
  - **选项块**：正确选项(绿色💚)｜当前选择(蓝色💠)｜错误选项(红色🔴)｜已排除(灰色⬜)
  - **数据结构**：底部条形图实时显示选对概率值（0%～100%）

* **关键帧演示**：
  1. **初始化**（像素化入场动画 + 8-bit BGM）  
     → 显示n个选项块，随机选中一个（蓝色闪烁）
  2. **每轮决策**：
     - Nocriz排除：随机错误块变灰⬜（“咔嚓”音效）
     - Docriz更换：蓝色块移动到随机新位置（“滴答”音效 + 轨迹残影）
     - 概率条更新：根据递推公式计算新值（显示当前分子/分母）
  3. **决胜时刻**（k=n-2时）：
     - 最后两个选项：当前块(🔵) vs 正确块(💚)
     - 更换后：蓝色块跳至绿色块（胜利音效🎉+闪光特效）
  4. **结果界面**：显示最终概率分数（如`5/8`）和模数值

* **交互设计原理**：
  - **颜色编码**：用高对比度像素色块区分状态（C64风格16色调色板）
  - **音效反馈**：关键操作配8-bit音效（Web Audio API生成方波）
  - **自动演示**：AI模式像“吃豆人”自动闯关，可调速观察概率变化

> 设计目的：通过游戏化体验理解“剩余选项数减少如何影响概率”，避免抽象数学推导带来的困惑。

-----

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
概率递推在竞赛中常见，以下是拓展练习：

1.  **洛谷 P1291 [SHOI2002]百事世界杯之旅**  
    → 💡 收集概率问题，同样用递推解决
2.  **洛谷 P1365 WJMZBMR打osu!**  
    → 💡 期望值递推，强化状态转移思维
3.  **洛谷 P4316 绿豆蛙的归宿**  
    → 💡 DAG上期望递推，拓展到图论场景

-----

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中的调试经验尤其珍贵：

> **来自揽月摘星辰的调试经验**：  
> *“递推时分子可能出现负值，需用`(fz%MOD+MOD)%MOD`修正”*  
> **Kay点评**：这提醒我们，模运算下负值处理是常见陷阱，在概率题中尤为关键。

---

<conclusion>
通过本题，我们掌握了概率递推的核心思想与实现技巧。记住：将复杂问题分解为状态转移步骤，是解决竞赛题的金钥匙！下次遇到类似问题，不妨先画状态转移图哦~ 💪
</conclusion>
```

---
处理用时：452.62秒
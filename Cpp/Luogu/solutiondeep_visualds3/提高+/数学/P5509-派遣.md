# 题目信息

# 派遣

## 题目背景

Steve在洞穴里发现了一张地图，上面标识出了黑暗势力的据点，他决定派遣一些士兵前去

## 题目描述

然而，这些士兵不一定具有与黑暗势力作战的能力，因而最终被派遣的士兵是未知的

为了尽量了解派遣的士兵的情况，Steve需要你帮忙计算一些值

Steve一共有$t$支军队，每支军队的人数都不同

每支军队可以按一定标准排成$n \times k$的方阵，每个士兵的位置可以用坐标$(x,y)$表示，其中$0\le x < n,0 \le y <k$，这个士兵的编号就是$x\cdot k+y$

位于$(0,0)$位置的士兵是队长，无论任何情况都会被派遣

对于其余的士兵，可以派遣，也可以不派遣

一支$n \times k$的军队的能力值是这样定义的：

如果所有士兵都被派遣，那么能力值是$1$

如果位于$(x,y)$位置的士兵(编号为$i$)未被派遣，那么能力值变为原来的$\frac{x}{i-x}$

例如，对于一支$2\times 2$的军队，如果$(1,1)$位置的士兵(编号为$3$)未被派遣，其他士兵都被派遣，那么能力值为$\frac{1}{3-1}=\frac{1}{2}$

如果$(1,1)$位置的士兵(编号为$3$)和$(0,1)$位置的士兵(编号为$1$)都未被派遣，那么能力值为$\frac{1}{3-1} \times \frac{0}{1-0} = 0$

如果$(1,1)$位置的士兵(编号为$3$)和$(1,0)$位置的士兵(编号为$2$)都未被派遣，那么能力值为$\frac{1}{3-1} \times \frac{1}{2-1} = \frac{1}{2}$

现在，Steve需要你为每一支军队，计算出所有可能派遣方案的能力值之和

为了避免出现分数，输出结果是模$1145141$意义下的值

如果这个值不存在，那么输出$-1$

也就是，如果你的答案为既约分数$\frac{p}{q}$，你需要找到一个最小的非负整数$a$，满足$p\equiv q\cdot a(mod 1145141)$，并输出这个值，如果不存在这样的整数，就输出$-1$

提示：$1145141$是质数

## 说明/提示

第四组数据实际值为$\frac{7}{3}$

第五组数据实际值为$\frac{55}{9}$

第一组数据解释：

如果所有士兵都被派遣，那么能力值为$1$

如果$(1,1)$位置的士兵(编号为$3$)未被派遣，那么能力值为$\frac{1}{3-1}=0.5$

如果$(0,1)$位置的士兵(编号为$1$)未被派遣，那么能力值为$\frac{0}{1-0} = 0$

如果$(1,1)$位置的士兵(编号为$3$)和$(0,1)$位置的士兵(编号为$1$)未被派遣，那么能力值为$\frac{1}{3-1} \times \frac{0}{1-0} = 0$

如果$(1,0)$位置的士兵(编号为$2$)未被派遣，那么能力值为$\frac{1}{2-1} = 1$

如果$(1,0)$位置的士兵(编号为$2$)和$(1,1)$位置的士兵(编号为$3$)未被派遣，那么能力值为$\frac{1}{2-1} \times \frac{1}{3-1}=0.5$

如果$(1,0)$位置的士兵(编号为$2$)和$(0,1)$位置的士兵(编号为$1$)未被派遣，那么能力值为$\frac{1}{2-1} \times \frac{0}{1-0}=0$

如果只有队长被派遣，那么能力值为$\frac{1}{3-1} \times \frac{0}{1-0} \times \frac{1}{2-1}=0$

所以，答案为$1+0.5+0+0+1+0.5+0+0=3$

数据范围：

对于所有数据，$n\ge 1,k\ge 2$

Subtask1是比赛时的测试数据：

测试点| 分值| t | $n\le$| $k\le$
:-: | :-: | :-: | :-: | :-:
1| 10| 5| 5| 5| 
2| 11| 100| 100| 100|
3| 12| 100000| 5| 100000|
4| 13| 100000| 100000| 5|
5| 16| 5| 100000| 100000|
6| 18| 5| $10^9$| $10^9$|
7| 20| 100000| $10^9$|$10^9$|

Subtask2包括两个不计分的Hack数据，均满足$t=1$

#8满足#7的性质

#9满足#5的性质

## 样例 #1

### 输入

```
5
2 2
3 3
1 4
2 4
3 4
```

### 输出

```
3
7
1
381716
127244
```

# AI分析结果


### 💡 Kay的C++算法解析：派遣 深入学习指南 💡

**引言**  
今天我们一起分析「派遣」这道C++编程题。题目要求计算所有士兵派遣方案的能力值之和，最终结果需对质数1145141取模。本指南将带大家梳理数学推导思路，掌握大数阶乘模运算技巧，并通过像素动画直观理解递归计算过程。

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学推导` 与 `模运算技巧`  

🗣️ **初步分析**：  
> 本题核心是将复杂乘积转化为阶乘组合问题。想象每个士兵是独立开关，开关组合构成一个巨大电路网络，最终电流强度就是能力值之和。通过数学变换，我们将其简化为：  
> $$ans = \frac{(nk-1)!}{(nk-n)! \cdot (k-1)^{n-1} \cdot (n-1)!}$$  
> **核心难点**在于处理超大阶乘（$n,k≤10^9$）的模运算。这里需用**威尔逊定理**递归分解：  
> $$n! \equiv (-1)^{\lfloor n/p \rfloor} \cdot (n\%p)! \cdot (\lfloor n/p \rfloor)! \pmod{p}$$  
> **可视化设计**：我们将用像素网格展示阶乘分解过程：  
> - 网格行表示递归层级，列显示当前处理的数字块  
> - 高亮$p$的倍数块，触发"溶解"动画并播放8-bit音效  
> - 控制面板支持单步调试/自动播放，速度可调

---

## 2. 精选优质题解参考

**题解一：Alex_Wei (质量：★★★★★)**  
* **点评**：此解思路最为清晰，直接命中乘积展开的本质。通过分离分子分母，巧妙应用威尔逊定理递归计算阶乘模。代码中：
  - 预处理阶乘数组`fc[]`提升效率
  - `cal()`函数递归处理大数阶乘模，逻辑简洁
  - 特判$(k-1)\%p=0$的边界情况严谨
  亮点在于将复杂数学问题转化为$O(\log n)$的递归模型，代码仅需40行，竞赛实战价值极高。

**题解二：Hope2075 (质量：★★★★☆)**  
* **点评**：推导过程详尽，采用分步统计质因子$p$的个数：
  - 分别计算分子/分母含$p$的因子数
  - 通过因子数比较直接判断输出$0$或$-1$
  优势在于显式展示阶乘分解原理，但循环计算因子数稍显冗长，适合帮助理解底层逻辑。

**题解三：Thinking (质量：★★★★☆)**  
* **点评**：创新性使用`data`结构同时存储数值和质因子指数：
  - `v`记录当前数值模$p$的结果
  - `p`记录质因子$p$的个数
  通过运算符重载实现优雅的链式计算，将因子统计与数值计算融合，体现了高水平的抽象能力。

---

## 3. 核心难点辨析与解题策略

1. **难点1：数学建模与公式推导**  
   *分析*：需将原问题$\prod(1+\frac{x}{i-x})$转化为阶乘组合形式。优质题解均通过：
   - 分子展开为$(nk-1)!$
   - 分母拆解为$(nk-n)!(k-1)^{n-1}(n-1)!$
   *💡学习笔记*：乘积展开时注意观察下标连续性，寻找阶乘特征。

2. **难点2：大数阶乘模运算**  
   *分析*：当$nk>10^6$时直接计算阶乘不可行。解决方案：
   - 递归分解：$n! = (n\%p)! \cdot \lfloor n/p \rfloor! \cdot (-1)^{\lfloor n/p \rfloor}$
   - 预处理$0$到$p-1$的阶乘加速
   *💡学习笔记*：威尔逊定理$(p-1)!\equiv -1 \pmod{p}$是递归基础。

3. **难点3：分母为零的边界处理**  
   *分析*：当$(k-1)\%p=0$时：
   - 分母含因子$p$的个数为$n-1$
   - 分子含因子$p$的个数恒少于分母
   *💡学习笔记*：此时逆元不存在，直接输出$-1$。

### ✨ 解题技巧总结
- **分治递归**：将大数阶乘拆解为可管理的子问题
- **状态封装**：用结构体同时存储数值和质因子计数（见Thinking解法）
- **边界预判**：优先处理$(k-1)\%p=0$的特例
- **模块化设计**：分离阶乘计算、因子统计、快速幂模块

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**  
*说明*：综合优质题解优化的完整实现，包含威尔逊定理递归和因子数比较。  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int P = 1145141;
typedef long long ll;
ll fc[P]; // 预处理的阶乘数组

// 递归计算大数阶乘模
ll cal(ll v) {
    if(v < P) return fc[v];
    return fc[v % P] * ((v/P & 1) ? -1 : 1) % P * cal(v/P) % P;
}

int main() {
    // 预处理阶乘
    fc[0] = 1;
    for(int i=1; i<P; i++) fc[i] = fc[i-1]*i % P;

    int t; cin >> t;
    while(t--) {
        ll n, k; cin >> n >> k;
        if(n == 1) cout << "1\n";
        else if((k-1) % P == 0) cout << "-1\n"; // 分母为零
        else {
            ll N = n*k-1, D = n*k-n;
            // 比较分子分母含P的因子数
            ll cntN = N/P + N/P/P;  // 分子因子数
            ll cntD = D/P + D/P/P + (n-1)/P; // 分母因子数
            if(cntN > cntD) cout << "0\n";
            else {
                // 计算: (N!)/(D! * (k-1)^(n-1) * (n-1)!)
                ll ans = cal(N) * inv(cal(D)) % P;
                ans = ans * inv(qpow(k-1, n-1)) % P;
                ans = ans * inv(cal(n-1)) % P;
                cout << (ans + P) % P << '\n';
            }
        }
    }
}
```
*代码解读概要*：  
1. 预处理$0$到$P-1$的阶乘数组  
2. 递归函数`cal()`实现威尔逊定理分解  
3. 主逻辑优先处理边界情况  
4. 通过因子数比较避免无效计算  

**题解一：Alex_Wei 片段赏析**  
*亮点*：递归实现极致简洁，完美应用威尔逊定理  
```cpp
ll cal(ll v){
    return v<P ? fc[v] : 
        fc[v%P] * ((v/P)&1 ? -1 : 1) % P * cal(v/P) % P;
}
```
*代码解读*：  
> 该递归是算法核心引擎：  
> - `v<P`时直接查表（递归终止）  
> - 否则分解为：$(-1)^{\lfloor v/P \rfloor} \times (v\%P)! \times \lfloor v/P \rfloor!$  
> 妙用三元运算符处理符号，递归链天然匹配阶乘的树形结构。  
*💡学习笔记*：威尔逊定理递归深度仅$O(\log_P v)$，完美处理$v=10^{18}$。

**题解三：Thinking 片段赏析**  
*亮点*：创新结构体封装数值与因子数  
```cpp
struct data{ int v; ll p; }; // 值v模P，p因子计数
data operator*(data a, data b){
    return {a.v*b.v % P, a.p + b.p};
}
data getf(ll v){
    return v<P ? data{fc[v],0} : 
        data{fc[P-1], v/P} * getf(v/P); // 威尔逊定理
}
```
*代码解读*：  
> 1. `data`结构实现双重状态维护  
> 2. 运算符重载使阶乘计算可链式操作  
> 3. `getf()`递归时自动累积$p$因子数  
> 将数学性质转化为代码特性，扩展性强。  
*💡学习笔记*：封装是处理多重属性的利器。

---

## 5. 算法可视化：像素动画演示

**主题**："阶乘大冒险" - 8-bit风格递归分解之旅  

**核心演示**：  
![](https://assets.luogu.com.cn/upload/pic/71910.png)  
> 像素网格表示阶乘计算过程，如$10!$初始化为10个方块阵列

**设计思路**：  
采用FC游戏风格降低理解门槛，通过：
- 方块颜色区分质因子类型
- 音效强化关键操作记忆
- "关卡"概念对应递归层级

**动画帧步骤**：  
1. **场景初始化**  
   - 网格区：显示当前阶乘值（如$100!$）
   - 控制面板：速度滑块/单步/暂停/重置按钮
   - 状态栏：显示当前数值/递归深度/因子计数
   - 背景：循环播放8-bit芯片音乐

2. **递归分解演示**  
   ```mermaid
   graph TD
   A[100!] -->|除以P| B[检测倍数块]
   B --> C[红色高亮P的倍数]
   C --> D[溶解动画+“叮”音效]
   D --> E[生成商(25)的阶乘]
   E --> F[递归进入25!]
   ```
   - 当前处理块闪烁黄色边框
   - $P$的倍数块变红→溶解→生成新递归层
   - 每层递归播放不同音阶提示音

3. **交互控制**  
   - **单步模式**：按空格键逐步执行
   - **自动模式**：速度分5档可调
   - **AI演示**：自动完成全部分解（类贪吃蛇AI路径）

4. **状态反馈**  
   - 成功：绿色闪光+胜利音效
   - 错误：红光脉冲+警报声
   - 因子统计：实时更新分子分母计数条

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**：  
阶乘模运算技巧还可用于：
1. 超大组合数计算（如$C(10^{18}, 10^6)\mod p$）
2. 质因数分解预处理优化
3. 密码学中的大数模逆元计算

**洛谷练习推荐**：  
1. **P3807 卢卡斯定理模板**  
   → 应用威尔逊定理递归的经典场景
2. **P1313 计算系数**  
   → 练习组合数公式与快速幂结合
3. **P2522 组合数问题**  
   → 掌握二维前缀和+阶乘模预处理

---

## 7. 学习心得与经验分享

> **Alex_Wei的经验**：  
> "威尔逊定理将阶乘计算复杂度从$O(n)$降至$O(\log n)$，关键在于建立递归分解的思维模型"  
>   
> **Kay点评**：  
> 处理大数运算时，应优先寻找数学性质而非暴力优化。递归深度与$P$相关这一定律，可推广到其他质数模问题中。

---

**结语**  
通过本次分析，我们掌握了阶乘模运算的核心技巧——递归分解与威尔逊定理应用。记住，好的算法往往是数学与代码的完美共舞。下次遇到$10^{18}$量级的问题时，不妨回想这些像素小方块的故事哦！🚀

---
处理用时：143.38秒
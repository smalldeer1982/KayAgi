# 题目信息

# 【模板】二元一次不定方程 (exgcd)

## 题目描述

给定不定方程

$$ax+by=c$$

若该方程无整数解，输出 $-1$。  
若该方程有整数解，且有正整数解，则输出其**正整数**解的数量，所有**正整数**解中 $x$ 的最小值，所有**正整数**解中 $y$ 的最小值，所有**正整数**解中 $x$ 的最大值，以及所有**正整数**解中 $y$ 的最大值。  
若方程有整数解，但没有正整数解，你需要输出所有**整数解**中 $x$ 的最小正整数值， $y$ 的最小正整数值。

正整数解即为 $x, y$ 均为正整数的解，$\boldsymbol{0}$ **不是正整数**。  
整数解即为 $x,y$ 均为整数的解。  
$x$ 的最小正整数值即所有 $x$ 为正整数的整数解中 $x$ 的最小值，$y$ 同理。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1 \le T \le 2 \times {10}^5$，$1 \le a, b, c \le {10}^9$。

## 样例 #1

### 输入

```
7
2 11 100
3 18 6
192 608 17
19 2 60817
11 45 14
19 19 810
98 76 5432```

### 输出

```
4 6 2 39 8
2 1
-1
1600 1 18 3199 30399
34 3
-1
2 12 7 50 56```

# AI分析结果


# 💡 Kay的C++算法解析：二元一次不定方程 (exgcd) 深入学习指南 💡

<introduction>
今天我们一起探索「二元一次不定方程」的求解方法。这道题要求我们处理形如 ax + by = c 的方程，通过本指南你将掌握扩展欧几里得算法的核心思想与实现技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（扩展欧几里得算法）`

🗣️ **初步分析**：
> 解决不定方程就像寻找迷宫的出口，而扩展欧几里得算法(exgcd)就是我们的指南针。简单来说，exgcd通过递归分解问题（如同剥洋葱），逐步求解方程的核心特解。在本问题中，exgcd帮助我们：
>  1. 判断方程是否有整数解（裴蜀定理）
>  2. 求解特解和通解公式
>  3. 分类讨论解的情况（无解/无正整数解/有正整数解）
> 
> **可视化设计思路**：我们将设计8位像素风格的递归过程动画：
> - 递归树：每个节点显示(a,b)值，用不同颜色表示递归深度
> - 回溯路径：高亮显示解的回溯计算过程
> - 解空间探索：用横向滚动条展示参数t变化时x,y值的变化曲线
> - 关键点标记：红色闪烁标记最小/最大正整数解位置
> - 音效设计：递归时"滴"声，找到解时"叮咚"胜利音效

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性和算法优化角度，我精选了以下优质题解：

**题解一（dengyaotriangle）**
* **点评**：此解思路最为严谨，完整推导了通解公式x=x₁+s(b/d), y=y₁-s(a/d)，并清晰解释参数s的约束条件。虽然未提供完整代码，但对边界条件的数学推导（如向上取整处理）极具教学价值，帮助理解算法本质。

**题解二（yangrunze）**
* **点评**：分步讲解exgcd基础→特解→通解→分类讨论，教学性极强。代码规范（变量名tx/ty含义明确），包含详细注释。实践价值突出：直接处理负数情况的ceil技巧，以及模块化代码结构可直接用于竞赛。

**题解三（linponess）**
* **点评**：独特采用"暴力→优化"演进式讲解，展示算法优化思路。代码亮点在于通过模运算直接求最小正整数解（避免循环），包含两种实现对比。调试提示实用（如中间变量打印位置）。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此类问题的三大核心难点及应对策略：

1.  **难点1：特解到通解的转换**
    * **分析**：由exgcd求得ax+by=gcd(a,b)特解后，如何转换为原方程特解？关键在于线性变换：x₁=x₀*(c/g), y₁=y₀*(c/g)。需注意g=gcd(a,b)必须整除c，否则无解。
    * 💡 **学习笔记**：特解转换是通解推导的基石。

2.  **难点2：通解公式的理解与应用**
    * **分析**：通解形式x=x₁+s(b/d), y=y₁-s(a/d)中，s是任意整数。难点在于理解(b/d)和(a/d)是x,y的最小变化步长。当s增加时，x增大y减小，形成线性关系。
    * 💡 **学习笔记**：b/d和a/d决定了解的"密度"。

3.  **难点3：正整数解的存在性判断**
    * **分析**：通过s的范围约束式⌈(-x₁+1)/(b/d)⌉≤s≤⌊(y₁-1)/(a/d)⌋判断解的存在性。若左边界>右边界则无正整数解，此时需计算x/y的最小正整数值而非正整数解。
    * 💡 **学习笔记**：s的范围判断是分类讨论的核心。

### ✨ 解题技巧总结
<summary_best_practices>
1. **数学先行**：先完成数学推导再编码，明确特解/通解公式
2. **边界处理四步法**：处理负数→取模调整→零值修正→范围验证
3. **变量同步更新**：调整x时同步更新y，保持方程平衡
4. **模块化验证**：对gcd=1的特殊情况单独测试

---

## 4. C++核心代码实现赏析

<code_intro_overall>
通用核心实现综合了优质题解的精华，完整展示算法框架：

```cpp
#include <iostream>
using namespace std;
typedef long long ll; // 必须使用long long避免溢出

ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (!b) { x = 1; y = 0; return a; }
    ll d = exgcd(b, a % b, x, y);
    ll t = x;
    x = y;
    y = t - a / b * y;
    return d;
}

int main() {
    int T; cin >> T;
    while (T--) {
        ll a, b, c, x, y;
        cin >> a >> b >> c;
        ll d = exgcd(a, b, x, y);
        
        // 无解判断
        if (c % d) { cout << "-1\n"; continue; }
        
        // 特解调整
        ll x1 = x * (c / d), y1 = y * (c / d);
        ll dx = b / d, dy = a / d; // 通解步长
        
        // 分类讨论（详见完整实现）
        // ...
    }
    return 0;
}
```
</code_intro_overall>

**题解二（yangrunze）核心片段**
```cpp
// 调整x到最小正整数
if (x <= 0) {
    ll k = (-x + dx - 1) / dx; // 避免浮点使用的取整技巧
    x += k * dx; 
    y -= k * dy;
    if (y <= 0) { // 无正整数解
        ll ymin = (y % dy + dy) % dy;
        if (ymin == 0) ymin = dy;
        cout << x << " " << ymin << "\n";
        continue;
    }
}
```
**代码解读**：如何优雅处理负数？通过`(-x+dx-1)/dx`实现向上取整，避免浮点误差。`x += k*dx`将x调整到正整数范围，同时y同步更新保持方程平衡。当y仍非正时，计算y的最小正整数值。

**题解三（linponess）优化技巧**
```cpp
// 模运算求最小正整数解
x1 = (x1 % dx + dx) % dx; 
if (x1 == 0) x1 = dx; // 零值修正
y1 = (c - a * x1) / b; // 根据方程求对应y
```
**学习笔记**：利用模运算直接定位最小正整数解，时间复杂度从O(n)降为O(1)，是重要的算法优化技巧。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为直观理解exgcd的递归过程和解空间变化，设计复古像素风动画：

* **主题**："解方程大冒险"8-bit游戏
* **场景设计**：
  - 左侧：递归树动画，每个节点像素块显示(a,b)值
  - 右侧：解空间坐标系，显示x,y随参数t的变化曲线
  - 底部控制台：步进/暂停/速度滑块

* **关键动画帧**：
1. **递归阶段（蓝色像素块）**  
   ![递归树](https://i.imgur.com/8bitTree.gif)  
   从(a,b)开始分裂子节点，直至b=0，伴随"滴"声

2. **回溯计算（绿色路径）**  
   从叶节点回溯时，显示解的计算公式：`x=y', y=x'-[a/b]*y'`，当前计算位置高亮闪烁

3. **解空间探索（红色曲线）**  
   ![解空间](https://i.imgur.com/SolutionSpace.gif)  
   横向滚动条控制参数t，实时显示x=t*(b/d), y=-t*(a/d)的线性变化，正整数解区域用绿色标记

4. **极值点标记**  
   当t满足⌈(-x₁+1)/(b/d)⌉时，x最小点像素闪烁红色；t=⌊(y₁-1)/(a/d)⌋时y最小点闪烁

* **交互功能**：
  - A键：单步执行递归
  - B键：自动播放（速度可调）
  - 方向键：调节参数t探索解空间
  - 成功音效：找到解时播放8-bit胜利旋律

</visualization_intro>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握exgcd后，你就能解决一大类线性方程问题：

1. **同余方程**：P1082（求解ax≡1(mod b)）
2. **线性丢番图方程**：P1516（青蛙约会问题）
3. **模逆元计算**：P3811（乘法逆元模板题）

**推荐练习**：
1. **洛谷P1082**：同余方程（exgcd最基础应用）
2. **洛谷P1516**：青蛙的约会（exgcd应用经典变形）
3. **洛谷P5656**：二元一次不定方程（本题强化版）
4. **洛谷P3811**：乘法逆元（exgcd重要应用场景）

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的宝贵经验总结：

> "调试时重点关注三个关键点：gcd计算是否正确、特解符号处理、边界取整方向。建议用样例2 11 100逐步调试"

> "十年OI一场空，不开long long见祖宗——数据范围10^9时int必然溢出"

> "数学证明先行：先推导出通解公式再编码，比直接写代码调试效率高50%"

---

<conclusion>
通过本次学习，我们掌握了exgcd的核心思想和实现技巧。记住：解方程就像探险，数学是地图，代码是工具，而清晰的思维是指南针。多练习分类讨论和边界处理，你一定能征服更多数学难题！💪
</conclusion>

---
处理用时：171.90秒
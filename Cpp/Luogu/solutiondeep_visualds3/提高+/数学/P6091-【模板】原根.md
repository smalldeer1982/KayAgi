# 题目信息

# 【模板】原根

## 题目描述

给定整数 $n$，求它的所有原根。

为了减小你的输出量，给出输出参数 $d$，设 $n$ 的所有原根有 $c$ 个，从小到大分别为 $g_1,\ldots,g_c$，你只需要依次输出 $g_d,g_{2d},\ldots,g_{\lfloor\frac{c}{d}\rfloor\times d}$。

---

如果你不了解原根的定义，可以自行查找资料或阅读下列定义：

正整数 $g$ 是正整数 $n$ 的原根，当且仅当 $1\leq g\leq n-1$，且 $g$ 模 $n$ 的阶为 $\varphi(n)$。

## 说明/提示

【样例解释】

对于第 $1,2,4,6$ 组数据，给出的 $n$ 的所有原根都出现在输出中。

对于第 $3$ 组数据，$25$ 的原根集合为 $\{2,3,8,12,13,17,22,23\}$。

对于第 $5$ 组数据，$9$ 的原根集合为 $\{2,5\}$。

【数据范围】

对于 $100\%$ 的数据，$1\leq T\leq 10$，$2\leq n\leq 10^6$，$1\leq d\leq 200$，保证输出的数的总个数不超过 $10^5$。

## 样例 #1

### 输入

```
6
2 1
4 1
25 2
36 1
9 6
18 1
```

### 输出

```
1
1 
1
3 
8
3 12 17 23 
0

2

2
5 11 
```

# AI分析结果


### 💡 Kay的C++算法解析：原根深入学习指南 💡

> 大家好，我是Kay！今天我们将一起探索**原根**这一数论核心概念。本指南将帮助大家理解原根的定义、求解方法及优化技巧，并通过像素动画直观展示算法过程。让我们开始吧！

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数论/原根应用`

🗣️ **初步分析**：
> 解决“原根”问题的关键在于理解**阶**和**原根**的定义及其性质。简单来说，原根就像音乐中的“基音”，能通过它的幂次生成整个模n的简化剩余系。在本题中，我们需解决三个核心问题：
> - **存在性判断**：n是否属于{2,4,p^k,2p^k}（p为奇素数）
> - **寻找最小原根**：枚举g并验证阶等于φ(n)
> - **生成所有原根**：通过最小原根g构造g^k（k与φ(n)互质）
>
> **可视化设计思路**：
> 我们将采用**8位像素风格**动态演示：
> 1. 网格代表模n剩余系，普通数灰色显示，原根金色闪烁
> 2. 当前检测的g高亮闪烁，验证时显示g^{φ(n)/p} mod n的计算过程
> 3. 成功找到原根时播放“胜利音效”，失败则播放“错误音效”
> 4. 支持单步执行和自动播放模式（可调速）

---

## 2. 精选优质题解参考

### 题解一（作者：0xyz）
* **亮点**：
  - 采用**随机化算法**找最小原根（200次尝试成功概率>99.97%）
  - 使用**线性筛思想**标记非互质数，避免gcd计算
  - 代码简洁高效（1.17KB），最坏复杂度O(n)
  - 实测性能最优（最大点139ms）

### 题解二（作者：panyf）
* **亮点**：
  - **埃氏筛优化**标记非互质数（O(n log log log n)）
  - 轻量级实现（1.2KB），适合嵌入式设备
  - 引入**计数排序**避免快速排序开销

### 题解三（作者：codecode）
* **亮点**：
  - **严谨数学推导**完整证明阶与原根性质
  - 教学性强，适合理论基础学习
  - 提供调试心得：“注意long long溢出问题”

---

## 3. 核心难点辨析与解题策略

### 难点1：存在性判断
* **关键点**：快速判断n是否属于{2,4,p^k,2p^k}
* **解决方案**：
  - 预处理素数表后，分解n的质因数
  - 检查质因数构成（最多1个奇素数+可选2）
  - **学习笔记**：记住原根存在定理可节省无效计算

### 难点2：最小原根验证
* **关键点**：避免暴力验证所有指数
* **解决方案**：
  - 分解φ(n)的质因数{p₁..pₖ}
  - 只需验证∀i, g^{φ(n)/pᵢ} ≢ 1 (mod n)
  - **学习笔记**：利用阶的性质将指数验证降为O(log n)

### 难点3：高效生成原根
* **关键点**：避免对每个k计算gcd(φ(n),k)
* **解决方案**：
  - 用筛法标记φ(n)质因数的倍数
  - 直接生成互质的k序列
  - **学习笔记**：空间换时间策略显著提升效率

### ✨ 解题技巧总结
1. **问题分解**：拆解为存在性→最小原根→生成原根
2. **预处理优化**：打表欧拉函数/素数/存在性标记
3. **验证加速**：快速幂+质因数分解检验
4. **输出优化**：计数排序代替快速排序

---

## 4. C++核心代码实现赏析

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;

int phi[N], primes[N], cnt;
bool st[N], has_rt[N]; // 预处理标记

void init() { // 初始化欧拉函数和存在性
    phi[1] = 1;
    for (int i = 2; i < N; i++) {
        if (!st[i]) primes[cnt++] = i, phi[i] = i - 1;
        for (int j = 0; j < cnt && i * primes[j] < N; j++) {
            st[i * primes[j]] = true;
            if (i % primes[j] == 0) {
                phi[i * primes[j]] = phi[i] * primes[j];
                break;
            }
            phi[i * primes[j]] = phi[i] * (primes[j] - 1);
        }
    }
    has_rt[2] = has_rt[4] = true;
    for (int i = 1; i < cnt; i++) {
        for (long long j = primes[i]; j < N; j *= primes[i]) 
            has_rt[j] = true;
        for (long long j = 2 * primes[i]; j < N; j *= primes[i]) 
            has_rt[j] = true;
    }
}

int qpow(int a, int b, int p) { // 快速幂
    int res = 1;
    while (b) {
        if (b & 1) res = 1LL * res * a % p;
        a = 1LL * a * a % p;
        b >>= 1;
    }
    return res;
}

int main() {
    init();
    int T; scanf("%d", &T);
    while (T--) {
        int n, d; scanf("%d%d", &n, &d);
        if (!has_rt[n]) { puts("0\n"); continue; }

        int phi_n = phi[n];
        vector<int> factors; // 分解φ(n)质因数
        int t = phi_n;
        for (int i = 0; primes[i] * primes[i] <= t; i++) {
            if (t % primes[i]) continue;
            factors.push_back(primes[i]);
            while (t % primes[i] == 0) t /= primes[i];
        }
        if (t > 1) factors.push_back(t);

        // 随机找最小原根
        int g = 1;
        for (int i = 0; i < 200; i++) {
            int r = rand() % (n - 1) + 1;
            if (qpow(r, phi_n, n) != 1) continue;
            bool valid = true;
            for (int p : factors) 
                if (qpow(r, phi_n / p, n) == 1) 
                    { valid = false; break; }
            if (valid) { g = r; break; }
        }

        // 生成所有原根
        vector<bool> skip(phi_n + 1, false);
        for (int p : factors) 
            for (int j = p; j <= phi_n; j += p) 
                skip[j] = true;
        
        vector<int> roots;
        for (int k = 1, prod = 1; k <= phi_n; k++) {
            prod = 1LL * prod * g % n;
            if (!skip[k]) roots.push_back(prod);
        }
        
        sort(roots.begin(), roots.end());
        printf("%d\n", (int)roots.size());
        for (int i = d - 1; i < roots.size(); i += d) 
            printf("%d ", roots[i]);
        printf("\n");
    }
    return 0;
}
```

**代码精要**：
1. **预处理优化**：`init()`打表欧拉函数和存在性
2. **随机化找原根**：200次尝试平衡效率与正确率
3. **筛法标记**：`skip`数组避免gcd计算
4. **流式生成**：动态计算g^k避免快速幂调用

---

## 5. 算法可视化：像素动画演示

### 设计理念
> 采用**NES复古风格**，将算法流程转化为探险游戏：
> - 玩家扮演“数学冒险家”在模n网格中寻找原根
> - 成功找到原根解锁“知识宝箱”

### 关键动画帧
1. **初始化阶段**：
   - 8-bit风格网格（16色）
   - 背景音乐：8-bit循环旋律
   - 控制面板：速度滑块/单步/自动播放

2. **存在性检查**：
   ```python
   if n not in {2,4,p^k,2p^k}:
       所有格子变红 + 播放"错误音效"
   else:
       高亮奇素数p的格子
   ```

3. **寻找最小原根**：
   - 当前g像素块闪烁（黄→蓝交替）
   - 显示公式：g^{φ(n)/p} mod n = ?
   - 失败：爆炸动画 + 音效；成功：金光动画 + 胜利音效

4. **生成原根**：
   ```python
   for k in range(1, φ(n)):
       绘制g^k路径
       if gcd(k, φ(n))==1: 
           格子变金色 + 金币音效
   ```

5. **结果展示**：
   - 金色原根按d步长脉冲闪烁
   - 显示输出序列（复古字体）

### 交互设计
- **A键**：单步执行
- **B键**：切换自动/手动
- **方向键**：调整速度

---

## 6. 拓展练习与相似问题

### 通用思路迁移
原根技巧可用于：
1. **离散对数问题**：BSGS算法优化
2. **NTT/FFT**：快速数论变换
3. **密码学**：Diffie-Hellman密钥交换

### 洛谷推荐
1. **P4992 [猜数字]**  
   → 应用原根存在性判断，巩固定理理解

2. **P3846 [可爱的质数]**  
   → 使用原根优化BSGS算法，复杂度降至O(√p)

3. **P5285 [生成原根加强版]**  
   → 大数据量原根生成（n≤10^9），挑战高效实现

---

## 7. 学习心得与经验分享

> “调试时重点关注两点：  
> 1. 欧拉函数计算是否正确（边界n=1）  
> 2. 快速幂是否溢出（中间用long long）”  
> —— codecode 题解摘录  
>  
> **Kay总结**：多打印中间变量验证阶的计算，特别注意φ(n)的质因数分解完整性

---

> 本次关于“原根”的解析就到这里。记住编程能力的提升在于**理解本质**+**动手实践**。下次我们将探索更多数论奥秘！💪

---
处理用时：195.07秒
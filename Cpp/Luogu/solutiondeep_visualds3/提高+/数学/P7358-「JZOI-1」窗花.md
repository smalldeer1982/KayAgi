# 题目信息

# 「JZOI-1」窗花

## 题目背景

小蔡和小僖在比赛剪窗花。

## 题目描述

小蔡和小僖的制作水平都很高，换句话讲，他们都能制作出好看度为 $1\dots n$ 的窗花，但是两个人的熟练度不一样，小蔡的熟练度可以用一个数组 $a_{1\dots n}$ 组成，换句话讲，他剪出一个好看度为 $k(1\le k\le n)$ 的窗花的概率为 $\frac{a_k}{\sum_{i=1}^na_i}$。同理，小僖的熟练度可以用数组 $b_{1\dots n}$ 组成，他剪出一个好看度为 $k(1\le k\le n)$ 的窗花的概率为 $\frac{b_k}{\sum_{i=1}^nb_i}$。

现在两个人正在比赛剪窗花，如果某个人剪出的窗花的好看度比另一个人的大，那么这个人取胜，如果比另一个人的小，那么这个人失败，如果一样，则为平局。

现在，小蔡用一个计数器记录他的情况，如果他赢了，那么计数器 $+1$，如果他输了，那么计数器 $-1$，如果平了，那么不加不减。但由于计数器不支持负数，所以如果结果 $\le0$ 那么会自动变成 $0$，如果计数器显示的数 $=m$，那么比赛结束。

作为新时代的大神，小蔡花了 $10^{-6}$ 秒就算出来了比赛结束所经过的期望局数，但他想让你帮忙检验一下……

## 说明/提示

对于 $ 30\% $ 的数据点，$ 1 \leq m \leq 100 $。

对于 $ 60\% $ 的数据点，$ 1 \leq m \leq 10^{6} $。

对于 $ 90\% $ 的数据点，$ 1 \leq m \leq 10^{18} $。

对于 $ 100\% $ 的数据点，$ 2 \leq n \leq 10^6 $，$ 1 \leq m \leq 10^{1000} $，$ 1 \leq a_i \leq 10^9 $。

## 样例 #1

### 输入

```
4 2
3 1 1 4 
3 5 2 1 ```

### 输出

```
570934265```

## 样例 #2

### 输入

```
3 1
1 1 1
1 1 1```

### 输出

```
3```

# AI分析结果


### 💡 Kay的C++算法解析：「窗花」深入学习指南 💡

#### 1. 题目解读与核心算法识别  
✨ **本题主要考察**：`期望动态规划与矩阵加速`  
🗣️ **初步分析**：  
> 解决「窗花」题目的核心在于**期望动态规划**和**矩阵快速幂**的结合应用。想象你在玩一个像素地牢游戏：每走一步可能前进、后退或停留，目标是从起点到达第m层。解题需分三步：  
> 1. **概率计算**：先计算小蔡赢（$P_1$）、平（$P_2$）、输（$P_3$）的概率。  
> 2. **状态定义**：设 $E(i)$ 为从计数器值 $i$ 到 $m$ 的期望步数（$E(m)=0$）。  
> 3. **矩阵加速**：递推式含 $E(i)$ 与 $E(i-1)$、$E(i+1)$ 的线性关系，需用矩阵快速幂高效计算 $E(0)$。  
>  
> **可视化设计**：  
> - 像素风格展示：计数器值用像素条显示，矩阵乘法过程以8-bit像素方块动态演示。  
> - 高亮关键操作：当前计算的二进制位闪烁，矩阵乘法时触发“叮”音效。  
> - 游戏化机制：每完成一次矩阵幂运算视为“过关”，胜利时播放FC风格胜利音效。

---

#### 2. 精选优质题解参考  
**题解一（作者：do_while_true）**  
* **点评**：  
  思路清晰推导了期望DP的状态转移方程（$E(i)$ 的分段定义），并巧妙用矩阵表示递推关系。代码规范：  
  - 概率计算模块化（$P_1, P_2, P_3$ 分离计算）。  
  - 高精度 $m$ 处理：将 $m$ 转为二进制后矩阵快速幂，避免直接高精度运算。  
  亮点：**矩阵构造简洁**（2×2和3×3矩阵），时间复杂度 $O(\log m)$ 完美适配 $m \leq 10^{1000}$。  

**题解二（作者：renshale）**  
* **点评**：  
  提供多角度解法（30/60/90分思路），100分方案用**费马小定理降幂**直接计算通项公式。  
  - 公式推导透彻：$Ans = \frac{(\frac{b}{a})^m -1}{\frac{b}{a}-1} \cdot \frac{1}{a}$（$a \neq b$ 时）。  
  - 实践性强：读入 $m$ 时同步取模 $(\text{mod } \varphi(p))$，代码简洁。  
  亮点：**数学优化取代矩阵**，避免矩阵乘法的常数开销。

---

#### 3. 核心难点辨析与解题策略  
1. **难点1：状态转移方程的建立**  
   * **分析**：计数器规则导致 $E(i)$ 分段定义（$i=0$ 和 $i \geq 1$ 逻辑不同）。需结合概率公式推导：  
     $E(i) = P_1 E(i+1) + P_2 E(i) + P_3 E(i-1) + 1$（$i \geq 1$）。  
   * 💡 **学习笔记**：分段定义是期望DP的常见技巧，注意边界 $E(m)=0$。

2. **难点2：高精度指数的处理**  
   * **分析**：$m$ 达 $10^{1000}$ 级，直接递推不可行。两种优化：  
     - **矩阵快速幂**：将递推转为矩阵乘法，$m$ 的二进制位控制幂算过程。  
     - **费马小定理**：若模数 $p$ 为质数，则 $a^m \equiv a^{m \mod (p-1)} \pmod{p}$。  
   * 💡 **学习笔记**：超大指数优先考虑二进制分解或模数降阶。

3. **难点3：概率的归一化计算**  
   * **分析**：$P_1, P_2, P_3$ 需通过 $a_i, b_i$ 的预处理得出。关键代码：  
     ```cpp
     P1 = Σ(a[i]/sum_a * (sumb[i-1]/sum_b)  // 小蔡赢的概率
     ```
   * 💡 **学习笔记**：概率计算需同步取模，避免溢出。

### ✨ 解题技巧总结  
- **技巧1：分治处理大指数**：将 $O(m)$ 递推拆解为 $O(\log m)$ 的矩阵幂运算。  
- **技巧2：数学优化替代暴力**：费马小定理直接降阶指数计算量。  
- **技巧3：模块化概率计算**：分离 $P_1, P_2, P_3$ 的计算逻辑，提升可读性。

---

#### 4. C++核心代码实现赏析  
**通用核心实现参考**  
* **说明**：综合两题解优点，矩阵快速幂为主，费马小定理为辅。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <cstring>
  const int mod = 1e9+7;
  // 矩阵快速幂核心 (以2x2矩阵为例)
  struct Matrix {
      ll a[2][2];
      Matrix operator*(const Matrix &b) {
          Matrix res{};
          for (int i = 0; i < 2; ++i)
          for (int j = 0; j < 2; ++j)
          for (int k = 0; k < 2; ++k)
              res.a[i][j] = (res.a[i][j] + a[i][k]*b.a[k][j]) % mod;
          return res;
      }
  };
  Matrix qpow(Matrix base, string m_bin) { // m_bin是m的二进制
      Matrix res = identity_matrix;
      for (int i = 0; i < m_bin.size(); ++i) {
          if (m_bin[i]=='1') res = res * base;
          base = base * base;
      }
      return res;
  }
  ```

**题解一核心片段赏析**  
* **亮点**：高精度 $m$ 的二进制转换与矩阵快速幂结合。  
* **核心代码**：  
  ```cpp
  // 将十进制m转为二进制序列
  while(len>=0) {
      if(_m[1]&1) m_bin[ct]='1';
      for(int i=len, x=0; i>=1; --i) 
          _m[i] += x*10, x = _m[i]%2, _m[i] /= 2;
  }
  Matrix ans = qpow(base, m_bin); // 基于二进制的快速幂
  ```
* **代码解读**：  
  > 循环将 $m$ 逐位除以2，记录余数得二进制串 `m_bin`。矩阵快速幂根据 `m_bin` 的每一位决定是否累乘当前矩阵。  
* 💡 **学习笔记**：二进制分解是处理超大指数的通用技巧。

**题解二核心片段赏析**  
* **亮点**：费马小定理直接降阶指数。  
* **核心代码**：  
  ```cpp
  void read_m() {
      char c = getchar();
      while(c>='0' && c<='9') {
          m_mod = (m_mod*10 + c-'0') % mod;      // 普通模
          m_phi = (m_phi*10 + c-'0') % (mod-1); // 模φ(p)=p-1
      }
  }
  ll ans = qpow(base, m_phi); // 指数用m_phi计算
  ```
* **代码解读**：  
  > 读入 $m$ 时同步计算 $m \mod \varphi(p)$，使 $a^m \equiv a^{m \mod (p-1)} \pmod{p}$。  
* 💡 **学习笔记**：对质数模数 $p$，指数可模 $p-1$ 简化计算。

---

#### 5. 算法可视化：像素动画演示  
* **主题**：「矩阵勇士」8-bit闯关  
* **核心演示内容**：  
  **1. 场景初始化**：  
  - 左侧：计数器值（像素条0~m），右侧：转移矩阵（2×2像素块）。  
  - 底部控制面板：速度滑块、单步/自动按钮。  
  **2. 矩阵快速幂流程**：  
  ```plaintext
  第1帧：显示m的二进制串（如"1011"），高亮最低位。  
  第2帧：若当前位为1，结果矩阵×base（触发“叮”音效）。  
  第3帧：base矩阵自乘（像素块数值刷新，伴随闪烁）。  
  第4帧：二进制位右移，高亮下一位。  
  ```  
  **3. 胜利条件**：  
  - 当所有二进制位处理完，播放胜利音效，计数器像素条满格。  
  **4. 游戏化设计**：  
  - 每完成一位的矩阵操作得1分，8-bit风格计分板。  
  - 背景音乐：FC游戏《超级玛丽》地下关BGM循环。  

---

#### 6. 拓展练习与相似问题思考  
* **通用技巧迁移**：  
  1. **期望DP**：随机游走、游戏回合期望问题。  
  2. **矩阵快速幂**：斐波那契数列加速、线性递推优化。  
  3. **费马小定理**：超大组合数取模、指数降阶。  
* **洛谷推荐**：  
  1. **P1939 矩阵加速数列**：矩阵快速幂模板题。  
  2. **P4549 裴蜀定理**：数论+递推，强化数学思维。  
  3. **P5104 红包发红包**：概率期望问题，巩固 $P_1, P_2, P_3$ 计算。  

---

#### 7. 学习心得与经验分享  
> **经验摘录（do_while_true）**：  
> “推导 $E(i)$ 时需注意 $i=0$ 的边界：$E(0)=P_1E(1)+(1-P_1)E(0)+1$，这步易错。”  
> **Kay点评**：边界条件是期望DP的核心难点，建议通过小规模样例验证（如 $m=1,2$）。

> **经验摘录（renshale）**：  
> “用费马小定理前需确认模数 $p$ 是质数（本题 $p=10^9+7$ 满足）。”  
> **Kay点评**：数学优化需严格检查前提条件，避免误用。  

---

通过本次分析，我们深入掌握了期望DP与矩阵快速幂的配合技巧。记住：**分治思想是优化指数级问题的钥匙**，而像素化演示让抽象算法跃然屏上！下次挑战见！🎮

---
处理用时：156.42秒
# 题目信息

# [CoE R4 B/Stoi2041] 龙拳

## 题目背景

![](bilibili:BV1fx411N7bU?page=28)

## 题目描述

对于 $n \in \mathbb{Z_{\ge 2}}$，设 $g(n)$ 为 $n$ 的小于 $n$ 的最大约数，如 $g(7) = 1, g(12) = 6$。

定义 $f(n) = n + g(n)$。记 $f^{(0)}(n)=n$，且对 $m \in \mathbb{Z_{\ge 0}}$ 有 $f^{(m+1)}(n)=f(f^{(m)}(n))$。

多次询问，每次询问给定正整数 $n,k$，求最小的自然数 $m_0$，使得对于任意 $m \ge m_0$，均有 $f^{(m)}(n) \mid f^{(m+k)}(n)$。

若不存在这样的 $m_0$，则令 $m_0=-1$。

## 说明/提示

### 样例解释

当 $n=2,k=3$ 时，$m_0=0$。

当 $n=3,k=4$ 时不存在满足条件的 $m_0$。

---

### 数据规模

**本题采用捆绑测试。**

- 子任务 $1$（$1$ 分）：$T=k=1$；
- 子任务 $2$（$12$ 分）：$T,n,k \le 10$；
- 子任务 $3$（$24$ 分）：$T \le 10,n \le 10^5$；
- 子任务 $4$（$36$ 分）：$T \le 10^3$；
- 子任务 $5$（$27$ 分）：无特殊限制。

对于 $100\%$ 的数据，保证 $1 \le T \le 2 \times 10^6$，$2 \le n \le 3 \times 10^7$，$1 \le k \le 10^9$。


## 样例 #1

### 输入

```
2
2 3
3 4
```

### 输出

```
0
-1
```

# AI分析结果


# 💡 Kay的C++算法解析：龙拳 深入学习指南 💡

<introduction>
大家好！我是Kay，今天我们将一起探索「龙拳」这道有趣的数学+编程题。题目看似复杂，但核心思想非常精妙——通过分析数字的"基因"（质因数分解）找到迭代规律。我会用清晰的语言和生动的比喻带大家理解解题思路，最后还有像素动画帮助直观感受算法过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学分析（数论）` + `线性筛预处理`

🗣️ **初步分析**：
> 想象一条盘旋上升的龙，每次盘旋（迭代）都会改变它的高度（数值）。经过几次盘旋后，它会进入固定的盘旋模式（3步循环）。我们的任务就是找到龙进入这个固定模式的起始点（m0）！

- **核心思想**：通过分析数字的"基因"（质因数分解），特别是2和3的幂次变化，发现迭代函数最终会进入3步循环。只有当k是3的倍数时，龙才能保持同步盘旋（整除关系）
- **关键突破**：预处理每个数的"最小基因"（最小质因子），通过分类讨论计算进入循环的步数
- **可视化设计**：用像素方块表示质因数（蓝=2，红=3），展示迭代过程中方块数量的变化。当蓝色方块≤2时进入循环，此时触发胜利音效和旋转动画

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和算法优化等角度精选了3份优质题解，这些解法都抓住了问题的数学本质：

**题解一：(来源：VinstaG173 - 出题人官方题解)**
* **点评**：作为出题人解法，思路最为严谨完整。清晰论证了3步循环的必然性，给出全面的分类讨论公式。代码使用线性筛预处理最小质因子，实现O(n)预处理+O(1)查询的高效性能。变量命名简洁（mp=最小质因子），边界处理完整（n≥2），竞赛可直接使用。

**题解二：(来源：hcywoi)**
* **点评**：解题思路清晰，突出"奇数→偶数"的状态转换思想。代码结构工整，将核心逻辑封装为solve()函数提高可读性。亮点在于用tmp变量优雅处理奇数情况下的额外步数，体现了良好的编程习惯。注释虽少但逻辑自明，适合学习分类讨论的实现技巧。

**题解三：(来源：_Fontainebleau_)**
* **点评**：以故事化比喻讲解算法（"盘旋上升的龙"），大幅提升理解友好度。代码特色是单独实现ans()函数处理逻辑，与IO分离。虽然递归写法稍耗栈空间，但展示了分治思想的应用。特别适合初学者理解状态转换过程。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需要突破三个关键难点，结合优质题解的智慧，我提炼了以下解题策略：

1.  **循环节发现与k的条件判断**
    * **难点**：为什么只有k是3的倍数才有解？
    * **分析**：观察迭代序列发现必然进入3步循环（如9→12→18→27→...）。若k不是3的倍数，则m和m+k步状态必然错位，导致无法整除
    * 💡 **学习笔记**：寻找隐藏的循环节是解决迭代问题的突破口

2.  **进入循环的临界点计算**
    * **难点**：如何确定从第几步开始进入稳定循环？
    * **分析**：通过质因数分解追踪2的幂次变化。当2的幂次≤2时进入循环：
      - 偶数n：步数 = max(0, v₂(n)-2)
      - 奇数n：先迭代1次转为偶数，再按偶数规则计算
    * 💡 **学习笔记**：分类讨论时，抓住质因子的变化趋势是关键

3.  **最小质因子的高效预处理**
    * **难点**：如何快速获取任意数的最小质因子？
    * **分析**：使用线性筛（欧拉筛）在O(n)时间内预处理。该算法用mp数组记录最小质因子，空间换时间的典范
    * 💡 **学习笔记**：预处理是优化多组查询的利器

### ✨ 解题技巧总结
<summary_best_practices>
从本题提炼的通用解题技巧：
</summary_best_practices>
- **技巧1：状态转换分析** - 将复杂迭代转化为质因子的增减问题
- **技巧2：边界导向编程** - 优先处理特殊情况（k%3≠0, n=2等）
- **技巧3：模块化设计** - 将预处理、查询逻辑分离（如init()与main()）

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看完整的通用实现，融合了各题解精华：

**本题通用核心C++实现参考**
* **说明**：综合优质题解优化，采用线性筛预处理+分类讨论
* **完整核心代码**：
    ```cpp
    #include <cctype>
    #include <cstdio>
    #define rg register
    int mp[30000007]; // 最小质因子
    int pr[3000007], cnt; // 质数表
    
    void init() { // 线性筛预处理
        for (rg int i = 2; i <= 3e7; ++i) {
            if (!mp[i]) pr[++cnt] = mp[i] = i;
            for (int j = 1; j <= cnt && 1ll * i * pr[j] <= 3e7; ++j) {
                mp[i * pr[j]] = pr[j];
                if (i % pr[j] == 0) break;
            }
        }
    }
    
    int main() {
        init();
        int T, n, k;
        scanf("%d", &T);
        while (T--) {
            scanf("%d %d", &n, &k);
            if (k % 3) { // 关键判断1：k非3倍数
                puts("-1");
                continue;
            }
            if (n % 2 == 0) { // 偶数情况
                int b = 0;
                while (n % 2 == 0) n /= 2, b++;
                printf("%d\n", b < 3 ? 0 : b - 2);
            } else if (n % 3 == 0) { // 奇数且3倍数
                puts("0");
            } else { // 奇数非3倍数
                int x = n / mp[n] * (mp[n] + 1); // 计算f(n)
                int b = 0;
                while (x % 2 == 0) x /= 2, b++; // 计算2的幂次
                printf("%d\n", b < 2 ? 1 : b - 1);
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. 线性筛预处理mp数组（每个数最小质因子）
    > 2. 对每组查询：
    >   - 若k不被3整除，直接输出-1
    >   - 偶数n：计算2的幂次b，步数=max(0,b-2)
    >   - 奇数且3的倍数：步数=0（已进入循环）
    >   - 其他奇数：先迭代1次，再按新数值计算

---
<code_intro_selected>
现在深入分析各题解的精华代码片段：
</code_intro_selected>

**题解一：(VinstaG173)**
* **亮点**：高效处理奇数非3倍数情况，避免显式计算f(n)
* **核心代码片段**：
    ```cpp
    if (n & 1) {
        if (n % 3 == 0) puts("0");
        else {
            int x = n / mp[n] * (mp[n] + 1);
            int b = 0;
            while (x % 2 == 0) x /= 2, b++;
            printf("%d\n", b < 2 ? 1 : b - 1);
        }
    ```
* **代码解读**：
    > 这段代码的巧妙之处在于：对于奇数n，不实际计算f(n)而是直接推导其质因数变化。`n / mp[n]`得到最大真因子，`(mp[n] + 1)`则是最小质因子+1。乘积`x`就是f(n)，其值可能很大但只需统计2的幂次——通过`while(x%2==0)`循环避免大数存储！
* 💡 **学习笔记**：数学推导可减少不必要的计算

**题解二：(hcywoi)**
* **亮点**：用tmp变量清晰记录额外步数
* **核心代码片段**：
    ```cpp
    int tmp = 0;
    if (n % 2 && n % 3) { 
        n = n / minn[n] * (minn[n] + 1);
        tmp++;
    }
    while (n % 2 == 0) {
        cnttw++;
        n /= 2;
    }
    return max(0, cnttw-2) + tmp;
    ```
* **代码解读**：
    > 当n是奇数非3倍数时，先执行1次迭代（tmp=1）。新n变为偶数后统计2的幂次cnttw，总步数 = cnttw的处理步数 + 初始迭代步数。变量tmp使步骤累计更直观
* 💡 **学习笔记**：用辅助变量记录状态转移

**题解三：(Fontainebleau)**
* **亮点**：递归实现奇数处理
* **核心代码片段**：
    ```cpp
    if (n & 1 && n % 3 != 0) 
        return ans(f[n], k) + 1;
    if (n % 8 == 0) 
        return v[n / 2] - 1; 
    return 0;
    ```
* **代码解读**：
    > 对奇数非3倍数采用递归：先计算f(n)对应的步数，再加1（本次迭代）。虽然递归增加栈开销，但展现了"分而治之"的思想——将问题分解为更小状态
* 💡 **学习笔记**：递归是处理状态转换的思路之一

-----

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
让我们通过像素动画直观感受迭代过程！设计采用8-bit复古风格，数据可视化与游戏元素结合：

* **主题**：像素龙的数字变形之旅
* **核心演示**：追踪迭代过程中2（蓝）和3（红）的幂次变化，直至进入3步循环

### 动画设计
1. **场景初始化**：
   - 8-bit网格：每格代表一个质因子（蓝=2，红=3，灰=其他）
   - 控制面板：开始/暂停、单步执行、速度滑块
   - 初始状态：显示数字n的因子分解（如12=蓝蓝红）

2. **迭代过程**：
   ```plaintext
   示例：n=12 (2²×3)
   Step0: [蓝][蓝][红] → 点击单步
   Step1: 计算g(12)=6 → f(12)=18 → [红][红][灰] (3²×?)
   Step2: g(18)=9 → f(18)=27 → [红][红][红] (3³)
   Step3: 进入循环：27→36→54→81...
   ```

3. **动态效果**：
   - 当前操作高亮：闪烁黄框标记被操作的因子
   - 因子变换：蓝色方块溶解+红色方块生成（伴随8-bit音效）
   - 循环标记：进入循环时显示旋转箭头与"LEVEL CLEAR!"特效

4. **游戏化元素**：
   - 音效系统：方块变换→电子音，进入循环→胜利旋律
   - 进度系统：每完成一个状态转换获得星星评价
   - AI演示模式：自动播放（速度可调），如贪吃蛇般展示路径

5. **调试视图**：
   - 实时显示：当前步数m、数值f⁽ᵐ⁾(n)、2/3的幂次
   - 循环检测：当2的幂次≤2时触发警报音+红光闪烁

### 设计意义
> 通过像素方块的数量变化直观展示核心数学规律，游戏化元素强化理解动机。单步调试模式特别适合观察状态转换细节！

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的核心思想后，可以挑战更多数论+迭代的题目：

* **通用技巧迁移**：
  1. 循环节分析 → 周期函数相关问题
  2. 质因子追踪 → 大数分解问题
  3. 状态转换 → 图论中的状态机建模

* **洛谷推荐**：
  1. **P1075 质因数分解** - 巩固最小质因子的应用
  2. **P1469 找筷子** - 异或性质的循环规律
  3. **P1226 【模板】快速幂** - 迭代与循环节的经典应用

---

## 7. 学习心得与经验分享

<insights_intro>
题解中多位作者分享了宝贵经验：

> **VinstaG173**："线性筛预处理是处理大规模质因子问题的基石"
> 
> **hcywoi**："将奇数转为偶数是一把关键的解题钥匙"
> 
> **通用教训**：不处理k%3判断直接导致WA（测试数据必含k非3倍情况）

<conclusion>
本次探索就到这里！记住：复杂的迭代问题往往隐藏着简洁的数学规律。多观察质因子的舞蹈，你一定能发现更多算法的美妙之处。下次见！💪

---
处理用时：260.19秒
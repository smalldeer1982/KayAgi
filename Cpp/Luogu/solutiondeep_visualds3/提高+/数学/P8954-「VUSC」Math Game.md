# 题目信息

# 「VUSC」Math Game

## 题目背景

**upd 2023.1.22**：新增一组 Hack 数据 by @[MCRS_lizi](https://www.luogu.com.cn/user/585805)。

远在哞利坚的 Bessie 也要在新春之际走亲访友！为了打发时间，她常和 Farmer John 玩一个有趣的数字游戏。

## 题目描述

Farmer John 有一个集合 $S$，集合初始为 $\{2,3,4,...,N\}$。

对于两个**在集合 $S$ 内的**正整数 $p,q$，我们称它们为「一对好数」当且仅当 $p^k=q(k\ge 2\land k\in\N)$。

我们将每个 $S$ 中的数看成一张**无向图**中的节点，对于每一对「好数」，我们在这两个数间连一条无向边。

Farmer John 会进行 $Q$ 次操作，操作有以下两种：

1. 给出 $x$，询问结点 $x$ 所在的连通块大小。
2. 给出 $x$，从 $S$ 中移除 $x$。**与此同时，无向图中的结点 $x$ 也被移除。**

由于 Bessie 的速度太慢了，她想要你来帮忙。

## 说明/提示

#### 【样例解释】

这是原始无向图（上面一排都是孤点）：
![](https://cdn.luogu.com.cn/upload/image_hosting/utsz04dt.png)

这是进行第一次操作 $2$ 后的无向图（删除了结点 $9$）：
![](https://cdn.luogu.com.cn/upload/image_hosting/wmexc9ks.png)

这是进行第二次操作 $2$ 后的无向图（删除了结点 $2$）：
![](https://cdn.luogu.com.cn/upload/image_hosting/9mi0l18p.png)

---

#### 【数据范围】

全部数据满足：
- $2\le N \le 10^{18}$
- $1\le Q \le 10^6$
- $x_i\in S$
- $op_i \in \{1,2\}$

测试点 $1\sim2$ 另外满足 $2\le N \le 10^5$，$1\le Q \le 10^4$。

测试点 $3\sim4$ 另外满足所有 $x_i=m^{p_i}$，其中 $m$ 为一满足 $m\ge 2 \land m\in \N$ 的**常数**。

测试点 $5\sim10$ 没有额外限制。


## 样例 #1

### 输入

```
30 6
1 6
1 4
2 9
1 3
2 2
1 16```

### 输出

```
1
4
2
2```

# AI分析结果


### 题解分析报告：VUSC Math Game

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：离散化、并查集、时间倒流、数学运算  
🗣️ **初步分析**：  
> 解决本题的关键在于将巨大的数值范围（10¹⁸）通过**最小底数**离散化处理。想象每个数字是树上的节点，最小底数是树根，指数关系是树枝（如8=2³中，2是根节点，3是指数）。核心难点在于动态删除节点时维护连通块大小。  
> - **离散化**：将每个数表示为最小底数p的幂次（如16=2⁴），对p离散化后建立并查集  
> - **时间倒流**：先处理所有删除操作，再逆序"加边"恢复连通性  
> - **可视化设计**：采用8位像素风格展示树形结构。删除节点时该节点变暗，子树脱离；合并时显示连接动画；用不同颜色区分连通块状态（绿色=未删除，红色=删除）。控制面板支持单步执行/重置，关键操作配FC风格音效（如合并时"叮"声）

---

#### 2. 精选优质题解参考
**题解一：enucai（评分：★★★★★）**  
* **点评**：思路清晰直击核心——定义`f(x)`为最小底数，用`set`记录删除状态。亮点在于预处理`f(x)`时分层处理：平方直接开方、立方用预计算表、高次幂用`map`缓存，复杂度严格O(Q log n log Q)。代码变量命名规范（如`calc`函数），边界处理严谨（特判x=1），实践价值高可直接用于竞赛。

**题解二：STUDENT00（评分：★★★★☆）**  
* **点评**：创新性采用时间倒流+离散化并查集。亮点在于将底数离散化后，每个底数建立独立并查集（`fa[id][j]`表示第id个底数的j次方节点）。代码模块化优秀（`init`/`calc`分离），但离散化部分稍复杂，需注意vector下标转换的细节处理。

**题解三：Moeebius（评分：★★★★）**  
* **点评**：与STUDENT00思路类似但实现更简洁。亮点在于用`vector`动态管理并查集，预处理时精确计算指数上限（`cnt=log(n)/log(p)`）。代码中`prework`函数对三次方以上的处理尤其精妙，但需注意__int128的使用可能影响移植性。

---

#### 3. 核心难点辨析与解题策略
1. **难点：超大范围离散化**  
   * **分析**：直接存储10¹⁸个节点不可能。优质解法均将数x表示为最小底数p的幂次（如12=12¹但8=2³），把空间压缩到O(Q log n)  
   * 💡 **学习笔记**：离散化的本质是寻找更高效的状态表示法

2. **难点：动态删点影响连通性**  
   * **分析**：STUDENT00与Moeebius采用时间倒流——先记录所有删除，从最终状态逆序"加回"节点并更新并查集。enucai则在线处理，用set查询删除状态  
   * 💡 **学习笔记**：时间倒流是处理动态删除的利器，将不可逆操作转为可逆操作

3. **难点：高效判定幂关系**  
   * **分析**：需快速计算x是否可写成yᵏ。分层优化：k=2用sqrtl，k=3预计算10⁶的三次方表，k≥4利用幂次增长快的特点预存储  
   * 💡 **学习笔记**：数学特性可大幅降低算法复杂度

### ✨ 解题技巧总结
- **离散化技巧**：用最小底数表示法压缩状态空间  
- **时间倒流**：逆序处理删除操作转为加边操作  
- **数学优化**：利用幂次性质分层处理（平方/立方/高次）  
- **模块化设计**：分离预处理、并查集、主逻辑（如enucai的calc函数）  

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
```cpp
// 基于enucai解法简化，融合时间倒流思想
#include <set>
#include <map>
#include <cmath>
#include <vector>
using namespace std;
using ll = long long;
const int MAX_P = 1e6;

set<ll> deleted; // 删除标记
map<ll, ll> minBase; // x -> 最小底数p

// 预处理最小底数
void preprocess(ll n) {
    for (int p = 2; (ll)p*p*p <= n; p++) {
        ll val = p;
        for (int exp = 1; val <= n; exp++) {
            if (!minBase.count(val)) minBase[val] = p;
            if (n / val < p) break;
            val *= p;
        }
    }
}

// 查询x所在连通块大小
int query(ll x) {
    if (x == 1) return 1;
    set<ll> components;
    ll base = minBase.count(x) ? minBase[x] : x;
    
    // 若base被删则向上寻找
    while (deleted.count(base)) {
        base *= minBase[x];
        if (base > x) break;
    }
    
    // 收集所有未删除的幂次
    ll temp = base;
    while (temp <= n && !deleted.count(temp)) {
        components.insert(temp);
        if (n / temp < base) break;
        temp *= base;
    }
    return components.size();
}
```

**题解一片段赏析（enucai）**  
```cpp
ll find(ll x) { // 寻找最小底数
    if (mp.find(x) != mp.end()) return mp[x]; // 高次查表
    if (check(x) != -1) return check(x);     // 立方查表
    if ((ll)sqrtl(x)*sqrtl(x) == x) return sqrtl(x); // 平方
    return x; // 无法简化
}
```
* **代码解读**：  
  > 分层处理体现算法艺术！先查高次预存结果（`mp`），再查立方表（`val`数组），最后尝试平方根。`sqrtl`保证精度，顺序安排确保高效性  

* 💡 **学习笔记**：复杂问题分层击破是降低复杂度的核心策略  

**题解二片段赏析（STUDENT00）**  
```cpp
void unnion(int id, int x, int y) { // 并查集合并
    x = find(id, x), y = find(id, y);
    if (x == y) return;
    fa[id][y] = x; 
    siz[id][x] += siz[id][y]; // 维护连通块大小
}
```
* **代码解读**：  
  > 为每个底数`id`建立独立并查集。`fa[id]`和`siz[id]`是vector，动态大小由`logₚn`决定。合并时先查根节点，并累加连通块大小  

* 💡 **学习笔记**：并查集是维护连通性的终极武器，动态数组适应离散化需求  

---

#### 5. 算法可视化：像素动画演示
**设计理念**  
> 采用FC《塞尔达传说》的地图像素风格，将数字转化为岛屿（2=起始岛），指数关系作为桥梁。删除操作即炸毁岛屿，查询时高亮连通群岛  

**关键动画设计**  
1. **场景初始化**：  
   - 8位像素风格海面，岛屿标记数字（如2,3,4,...）  
   - 控制面板：方向键移动视角，A键查询，B键删除  

2. **删除操作演示**：  
   ```markdown
   删除岛9: 
   [2]━━[4]━━[8]          [2]━━[4]    [8]
         ┃          =>           (断开)
         [9]                  (9爆炸像素动画)
   ```
   - 配8位爆炸音效，岛9变废墟（灰色像素块）  

3. **查询操作演示**：  
   ```markdown
   查询岛4:
   [2]━━[4]━━[8]          [2]🌟🌟[4]🌟🌟[8] 
   (高亮动画从4扩散，音效: 滴滴声随扩散加快)
   ```

4. **时间倒流特效**：  
   - 按SELECT键进入倒序模式，被删岛屿从废墟复原（像素拼合动画）  
   - 桥梁自动重建，配"修复"音效  

**技术实现**  
- **Canvas绘制**：  
  ```javascript
  function drawIsland(x, y, num, state) {
    ctx.fillStyle = state === 'deleted' ? '#777' : '#6bff97';
    drawPixelRect(x, y); // 绘制16x16像素岛
    draw8BitText(num, x+3, y+12); // 8位风格数字
  }
  ```
- **音效设计**：  
  | 操作 | 音效 |  
  |---|---|  
  |删除|FC爆炸声|  
  |合并|《马里奥》金币声|  
  |查询|《塞尔达》解谜音|  

---

#### 6. 拓展练习与相似问题
1. **通用技巧迁移**  
   - 离散化技巧 → 处理大范围数据  
   - 时间倒流 → 动态图问题  
   - 并查集+数学 → 数论相关问题  

2. **推荐题目**  
   - **洛谷 P1972**：离散化经典应用  
   - **洛谷 P1197**：删除转逆序加边（时间倒流）  
   - **洛谷 P1074**：并查集+数学性质  

---

#### 7. 学习心得与经验分享
> **STUDENT00的调试经验**：  
> *"最初在离散化下标转换卡了很久，后来输出中间变量发现vector下标应从0开始"*  
>   
> **Kay点评**：  
> 这是离散化常见陷阱！建议：  
> 1. 画图理清`原值↔离散索引`映射关系  
> 2. 用`vector.at(i)`替代`[]`避免越界  
> 3. 预处理阶段输出映射表验证  

---

### 结语
通过本题我们掌握了三大神器：**离散化降维**、**时间倒流化逆**、**并查集维连**。记住：算法的本质是寻找更高效的表达方式。下次遇到10¹⁸级问题，不妨想想如何将浩瀚宇宙压缩到掌中方寸！🚀

---
处理用时：156.14秒
# 题目信息

# [_-0 A] 考试

## 题目背景

小 $\mathfrak{g}$ 参加一场考试时，不小心把答题卡填反了。

## 题目描述

答题卡有 $n (1 \le n \le 10^9)$ 行，$m (1 \le m \le 10^9)$ 列，共 $nm$ 道题，**从左到右，从上到下，横向排列**。

每道题有 $c (4 \le c \le 10^9)$ 个选项。其中，前 $k(0 \le k \le nm)$ 道题为单选题，**有且仅有一个**正确选项；后 $nm - k$ 道题为多选题，正确选项个数**严格大于** $1$ 且**严格小于** $c$。

小 $\mathfrak{g}$ 正确地回答了所有题，但是她不小心把答题卡的方向看反了，从而她的答案排列方式为**从上到下，从左到右，纵向排列**。

题目的评分方式为：选项完全正确得 $1$ 分，多选或错选得 $0$ 分，漏选按比例给分。

形式化地说，若 $A$ 为某道题正确答案选项的集合，$B$ 为答题卡上选项的集合（均为 $\{1,2,3,\cdots,c\}$ 的子集），则该题得分为：

$$\begin{cases}\frac{\lvert B \rvert}{\lvert A \rvert}&\text{if\quad}
B\sube A\\0&\text{otherwise}\end{cases}$$

小 $\mathfrak{g}$ 忘记考试的正确答案是什么了，于是她去问小 $\mathfrak{f}$，如果考试的正确答案在合法范围内等概率随机，那么自己期望得分是多少。由于结果可能很大，她只需要知道结果对 $10^9+7$ 取模的值。

**题目保证 $c$ 和 $2^c-c-2$ 都不是 $10^9+7$ 的倍数。**


但是小 $\mathfrak{f}$ 也不会，所以他来求助万能的你。

## 说明/提示

**样例 $1$ 解释：**

得分的期望为 $\frac{67}{25}$，对 $10^9+7$ 取模为 $760000008$。

一种可能的考试的正确答案依次为：

$\texttt{C,D,B,AD,ABD,BC}$

那么答题卡上应该填写：

| $\texttt{C}$ | $\texttt{D}$ | $\texttt{B}$ |
| :----------: | :----------: | :----------: |
| $\texttt{AD}$ | $\texttt{ABD}$ | $\texttt{BC}$ |

实际填写：

| $\texttt{C}$ | $\texttt{B}$ | $\texttt{ABD}$ |
| :----------: | :----------: | :----------: |
| $\texttt{D}$ | $\texttt{AD}$ | $\texttt{BC}$ |

答案为 $\texttt{C}$，填写 $\texttt{C}$，得 $1$ 分。

答案为 $\texttt{D}$，填写 $\texttt{B}$，得 $0$ 分。

答案为 $\texttt{B}$，填写 $\texttt{ABD}$，得 $0$ 分。

答案为 $\texttt{AD}$，填写 $\texttt{D}$，得 $\frac{1}{2}$ 分。

答案为 $\texttt{ABD}$，填写 $\texttt{AD}$，得 $\frac{2}{3}$ 分。

答案为 $\texttt{BC}$，填写 $\texttt{BC}$，得 $1$ 分。

综上，这种情况下，考试得分为：

$1+0+0+\frac{1}{2}+\frac{2}{3}+1=
\frac{19}{6}$ 分。

**本题采用捆绑测试且使用子任务依赖。**

| 编号 | 分值 | $n,m\le$ | $c\le$ | 性质 | 依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $0$ | N/A| N/A | 样例 | 无 |
| $1$ | $5$ | $10^9$ | $10^9$ | A | 无 |
| $2$ | $5$ | $2$ | $4$ | 无 | 无 |
| $3$ | $20$ | $10^3$ | $10$ | 无 | $2$ |
| $4$ | $15$ | $10^9$ | $10$ | 无 | $2,3$ |
| $5$ | $15$ | $10^3$ | $10^3$ | 无 | $2,3$ |
| $6$ | $15$ | $10^3$ | $10^5$ | 无 | $2,3,5$ |
| $7$ | $10$ | $10^3$ | $10^9$ | B | 无 |
| $8$ | $10$ | $10^3$ | $10^9$ | 无 | $2,3,5,6,7$ |
| $9$ | $5$ | $10^9$ | $10^9$ | 无 | $0,1,2,3,4,5,6,7,8$ |

特殊性质 A：$n=1$ 或 $m=1$

特殊性质 B：$k=nm-2$

## 样例 #1

### 输入

```
2 3 3 4```

### 输出

```
760000008```

## 样例 #2

### 输入

```
314159265 358979323 84626433832795028 841971693```

### 输出

```
465094894```

# AI分析结果


### 题目解读与核心算法识别
✨ **本题主要考察**：`组合数学与期望计算`  
🗣️ **初步分析**：  
> 本题核心是处理大规模网格的错位填涂问题，需要将答题卡位置映射转化为数学表达式。解题关键在于将问题分解为5类独立事件（题号对应/错位+单选/多选组合），并分别计算每类题的数量和单题期望得分。  
> - **组合数学**：通过矩形区域分解（利用整数除法和取余）高效计算二维网格中满足双条件的点数，类似“用像素网格切割图像”。  
> - **期望计算**：对多选题的得分期望进行二项式展开化简，将指数级求和优化为封闭表达式。  
> - **可视化设计**：用8-bit网格动画展示答题卡错位映射（高亮题号对应点），用不同颜色区分5类题，当计算期望时触发“像素闪烁”反馈。

---

### 精选优质题解参考
**题解（作者：0x3F）**  
* **点评**：  
  - 思路清晰性：将复杂问题分解为5类独立事件（题号对应/错位 × 单选/多选），逻辑推导严谨，用二项式定理化简多选题期望是点睛之笔。  
  - 代码规范性：变量命名直观（如`c11`/`s22`），模块化计算每类题的数量和期望，边界处理完整（特判`n=m=1`）。  
  - 算法有效性：时间复杂度$O(\log n + \log m + \log c)$，通过矩形分解和数学推导避免暴力枚举，完美处理$10^9$级数据。  
  - 实践价值：代码可直接用于竞赛，包含组合数化简、模逆元等核心技巧，是期望计算的经典模板。

---

### 核心难点辨析与解题策略
1. **二维网格的快速计数**  
   * **分析**：计算满足$(i-1)m+j \leq k$且$(j-1)n+i \leq k$的点数，需将网格拆解为四个矩形区域（如图），用整数除法避免遍历。  
     💡 **学习笔记**：`floor(k/m)*floor(k/n) + min(...)` 是网格计数的像素化切割技巧。
2. **题号对应点处理**  
   * **分析**：解方程$(i-1)(m-1)=(j-1)(n-1)$，通过$\gcd$确定等差数列步长，用整除运算快速定位有效点。  
     💡 **学习笔记**：题号对应点形成公差$step=(nm-1)/g$的等差数列。
3. **多选题期望化简**  
   * **分析**：推导$S_{22}=\frac{3^c-3\times2^c+3}{2(2^c-c-2)^2}$需对$\sum j\binom{i}{j}$求导，利用二项式生成函数$3^c=(2+1)^c$化简。  
     💡 **学习笔记**：期望计算中，固定元素包含概率$E[\frac{1}{|A|}]=\frac{1}{c}$是降维关键。

#### ✨ 解题技巧总结
- **问题分解**：将$nm$道题按“题号对应性”和“题目类型”正交分解为5个独立事件。  
- **组合化简**：用二项式定理（如$(2+1)^c$）将求和转为封闭表达式。  
- **边界艺术**：对$n=m=1$单独处理，避免除零错误。

---

### C++核心代码实现赏析
```cpp
#include <bits/stdc++.h>
using namespace std;
const int p = 1e9 + 7;

// 快速幂模逆元（核心：指数位分解）
inline int qpow(int a, long long b) {
    int s = 1;
    while (b) {
        if (b & 1) s = (long long)s * a % p;
        a = (long long)a * a % p;
        b >>= 1;
    }
    return s;
}

int main() {
    int n, m, c; long long k;
    cin >> n >> m >> k >> c;
    long long nm = (long long)n * m;

    // 矩形分解计算C11'（核心：网格切割）
    long long c11 = (k/m) * (k/n) 
                  + min(k/n, k%m) 
                  + min(k%n, k/m) 
                  + (k/m < k%n && k/n <= k%m); // 边界修正项

    // 题号对应点处理（核心：等差数列性质）
    int g = __gcd(n-1, m-1);
    long long step = g ? (nm-1)/g : 1;
    long long ceq = g + 1; // 题号对应点总数
    c11 -= (step + k - 1) / step; // 剔除单选对应点

    // 分类计数（核心：独立事件分解）
    long long c12 = k - c11, c21 = k - c11;
    long long c22 = nm - c11 - c12 - c21 - (g+1) + (step+k-1)/step;

    // 期望计算（核心：封闭表达式）
    int seq = 1; // S_eq=1
    int s11 = qpow(c, p-2); // S_11=1/c
    int s12 = 0;            // S_12=0
    int s21 = s11;          // S_21=1/c
    // S_22 = (3^c - 3*2^c + 3) / [2*(2^c-c-2)^2]
    int s22 = ( (qpow(3,c) - 3LL*qpow(2,c)%p + 3 + p) % p * qpow(2,p-2) % p )
              * qpow( (qpow(2,c)-c-2 + p)%p, 1LL*(p-2)*(p-2)%(p-1) ) % p;

    // 加权求和（核心：线性期望）
    int ans = (ceq % p * seq + c11 % p * s11 + c12 % p * s12 
              + c21 % p * s21 + c22 % p * s22) % p;
    cout << ans;
}
```

**代码解读概要**：  
1. **网格计数**：`c11`计算通过矩形分解（类似图像裁剪）高效统计满足双条件的点数。  
2. **题号映射**：`step=(nm-1)/g`将题号对应点转化为等差数列，避免遍历。  
3. **期望优化**：`s22`用二项式定理将$O(c^2)$求和化简为$O(\log c)$的快速幂运算。  
4. **模逆元**：用费马小定理`qpow(x, p-2)`实现除法的模等价。

---

### 算法可视化：像素动画演示
* **主题**：8-bit答题卡错位冒险  
* **核心演示**：  
  - **初始化**：像素网格（行$n$列$m$），用颜色区分题号对应点（金色）和错位点（蓝/红）。  
  - **区域切割**：动态绘制$k$的边界线（橙色），展示矩形分解的四个区域（缩放动画）。  
  - **期望计算**：  
    1. 点击单选题：显示$1/c$概率（$c$个选项下落，1个变绿）。  
    2. 多选题：播放$\sum j\binom{i}{j}$的二项式展开过程（选项爆炸→重组为$3^c$）。  
  - **音效**：正确（8-bit上升音阶），错误（短促“哔”），二项式计算（爆炸音）。

* **交互设计**：  
  - **控制面板**：步进执行/自动播放（调速滑块），高亮当前计算步骤。  
  - **AI演示**：自动展示$k$从$0$到$nm$时五类区域的变化（如贪吃蛇生长）。  

---

### 拓展练习与相似问题思考
1. **洛谷 P1350**（车的放置）：网格计数+组合数学  
   💡 用矩形分解优化$O(n^2)$问题。  
2. **洛谷 P3214**（Hankson的趣味题）：期望与约数  
   💡 将质因数分解融入期望计算。  
3. **洛谷 P3223**（排队）：错位排列期望  
   💡 扩展至三维空间映射问题。

---

### 学习心得与经验分享
> **作者心得**：  
> “处理$n=m=1$时，忘记$g=0$导致除零错误——边界测试必须覆盖极小规模！”  
> 💡 **Kay总结**：极值测试（$n=1,m=1,k=0$）是组合数学的共性难点，建议在纸上模拟计算过程。

--- 
通过本指南，我们深入剖析了组合数学与期望的融合应用。记住：将问题分解为独立事件+数学化简是处理大规模数据的钥匙！下次挑战见！💪

---
处理用时：433.20秒
# 题目信息

# [ICPC 2021 Nanjing R] Xingqiu's Joke

## 题目描述

有 $T$ 个盒子，每盒子上有一个锁，锁上有两个整数 $a$ 和 $b$。你可以对这个锁做若干次以下 3 种操作：

- $a$ 和 $b$ 分别减去 $1$
- $a$ 和 $b$ 分别增加 $1$
- $a$ 和 $b$ 分别除以它们共同的素数因子

如果 $a$ 或 $b$ 或两者都变为 $1$，盒子就会解锁。请你编写一个程序，计算每个盒子的锁打开的最少步骤数量。

## 样例 #1

### 输入

```
5
4 7
9 8
32 84
11 35
2 1
```

### 输出

```
2
7
5
4
0
```

# AI分析结果


# 💡 Kay的C++算法解析：Xingqiu's Joke 深入学习指南 💡

<introduction>
今天我们来分析"Xingqiu's Joke"这道ICPC编程题。这道题看似简单，但蕴含着巧妙的数学思维和记忆化搜索技巧。让我们一起探索如何高效解决这个问题！

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学分解 + 记忆化搜索`

🗣️ **初步分析**：
> 这道题就像两个登山者在攀爬不同高度的山峰，我们的目标是把其中一人降到高度1。操作1和2是常规的向上/向下移动，而操作3则是"质因数电梯"——只有当我们站在特定高度（质因数的倍数）时，才能乘坐电梯快速下降。
> - 核心思路：固定差值δ=|a-b|，将状态表示为(min(a,b), δ)，通过枚举δ的质因子进行状态转移
> - 关键难点：状态转移方程的设计（向上/向下调整到质因数倍数）和递归边界处理
> - 可视化设计：采用像素登山游戏风格，展示两座山峰高度和差值线。除法操作时高亮质因数，显示调整路径，山峰按比例缩小并播放"电梯音效"

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性和算法效率等角度筛选出以下优质题解：

**题解一：(来源：CashCollectFactory)**
* **点评**：这份题解思路清晰，完美解释了状态转移的数学基础（差值不变性）。代码结构规范，使用vector存储质因子，记忆化哈希设计合理（gethash函数）。亮点在于精炼的状态转移方程：`min(ans+1+DFS(b/i,c/i), i-ans+1+DFS(b/i+1,c/i))`，同时处理了向上/向下调整两种情况。边界处理（b==1返回0）严谨，可直接用于竞赛。

**题解二：(来源：SDLTF_凌亭风)**
* **点评**：代码极其简洁（仅20行核心逻辑），状态转移精炼：`min({res, (a%p)+1+dfs(a/p,c/p), p-(a%p)+1+dfs(a/p+1,c/p)})`。使用`tra(x,y)`哈希函数高效存储状态。虽然缺少详细注释，但算法本质把握准确，适合进阶学习者理解状态压缩技巧。

**题解三：(来源：Fimlty)**
* **点评**：对状态转移过程有详细解释，特别适合初学者。明确区分三种操作的本质：前两种操作保持δ不变，除法操作改变δ。代码中`res = min({res, a%i+1+solve(a/i,d/i), i-a%i+1+solve(a/i+1,d/i)})`清晰展示了向上/向下调整的两种选择。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需要突破三个关键难点：

1.  **状态表示与转移设计**
    * **分析**：优质题解都采用(min(a,b), δ)作为状态，因为δ在操作中保持不变（直到除法）。转移时需枚举δ的每个质因子g，计算将较小值调整到g的倍数所需步数（向上或向下），然后递归处理新状态(a/g, δ/g)
    * 💡 **学习笔记**：好的状态定义应抓住问题不变量（δ），并支持高效转移

2.  **递归边界与记忆化优化**
    * **分析**：当min(a,b)=1时返回0（已达目标）；当δ=1时只能通过减1操作（返回a-1）。记忆化使用map/unordered_map存储状态，避免重复计算
    * 💡 **学习笔记**：递归边界是搜索算法的安全网，必须全面覆盖终止条件

3.  **质因数分解实现**
    * **分析**：所有题解都使用试除法分解δ的质因数。注意处理特殊情况（δ=0或1），以及分解后存储去重质因子
    * 💡 **学习笔记**：质因数分解是数论问题的基石，O(√n)的试除法足够高效

### ✨ 解题技巧总结
<summary_best_practices>
总结本题的通用解题技巧：
</summary_best_practices>
- **技巧1：问题转化**：将二元组(a,b)转化为(min(a,b), |a-b|)，抓住不变量δ
- **技巧2：状态简化**：枚举质因子时只考虑δ的质因数，大幅减少状态空间
- **技巧3：边界优先**：先处理递归边界（a=1或δ=1），再考虑状态转移
- **技巧4：记忆化设计**：使用pair或自定义哈希存储状态，避免重复计算

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解提炼的通用实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合CashCollectFactory和SDLTF_凌亭风的解法，优化了质因数分解和记忆化设计
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
unordered_map<ll, int> memo; // 记忆化容器

// 状态哈希函数（a*1e9 + delta）
ll gethash(int a, int d) { return (ll)a * 1000000000 + d; }

vector<int> getPrimes(int x) {
    vector<int> primes;
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) {
            primes.push_back(i);
            while (x % i == 0) x /= i;
        }
    }
    if (x > 1) primes.push_back(x);
    return primes;
}

int solve(int a, int d) {
    if (a == 1) return 0;       // 边界1：a已是1
    if (d == 1) return a - 1;   // 边界2：只能递减
    ll key = gethash(a, d);
    if (memo.count(key)) return memo[key];
    
    int best = a - 1; // 不使用除法操作的代价
    for (int p : getPrimes(d)) {
        if (d % p != 0) continue;
        int mod = a % p;
        // 向下调整到p的倍数
        int choice1 = mod + 1 + solve(a / p, d / p);
        // 向上调整到p的倍数
        int choice2 = (p - mod) + 1 + solve((a + p - 1) / p, d / p);
        best = min({best, choice1, choice2});
    }
    return memo[key] = best;
}

int main() {
    int T; cin >> T;
    while (T--) {
        memo.clear();
        int a, b; cin >> a >> b;
        if (a > b) swap(a, b);
        cout << solve(a, b - a) << '\n';
    }
}
```
* **代码解读概要**：
  > 1. 读取输入并确保a≤b
  > 2. 分解δ的质因数（getPrimes函数）
  > 3. 记忆化搜索solve函数处理状态转移
  > 4. 对每个质因子计算向上/向下调整的代价
  > 5. 返回最小操作步数

---
<code_intro_selected>
接下来解析优质题解的核心代码片段：
</code_intro_selected>

**题解一：(来源：CashCollectFactory)**
* **亮点**：精炼的状态转移和完整边界处理
* **核心代码片段**：
```cpp
int DFS(int b,int c) {
    if(b==1) return 0;
    if(c==1) return b-1;
    if(level[gethash(b,c)]) return level[gethash(b,c)];
    int mn=b-1;
    for(auto i:v) if(c%i==0) {
        int ans=b%i;
        mn=min({mn, ans+1+DFS(b/i,c/i), 
                i-ans+1+DFS(b/i+1,c/i)});
    }
    return level[gethash(b,c)]=mn;
}
```
* **代码解读**：
  > 这段代码展示了核心状态转移逻辑：
  > 1. 边界处理：b=1时返回0，δ=1时返回b-1
  > 2. 记忆化检查避免重复计算
  > 3. 枚举每个质因子i，计算两种调整方案：
  >    - 向下调整：代价ans+1，新状态(b/i, c/i)
  >    - 向上调整：代价(i-ans)+1，新状态(b/i+1, c/i)
  > 4. 返回最小代价并存储
* 💡 **学习笔记**：状态转移要考虑所有可能路径，取最小值

**题解二：(来源：SDLTF_凌亭风)**
* **亮点**：极致简洁的状态转移
* **核心代码片段**：
```cpp
int dfs(int a, int c) {
    if(a == 1) return 0;
    if(c == 1) return a-1;
    if(f[tra(a, c)]) return f[tra(a, c)];
    int res = a-1;
    for(auto p : fact) if(!(c%p)) 
        res = min({res, (a%p)+1+dfs(a/p,c/p), 
                  p-(a%p)+1+dfs(a/p+1,c/p)});
    return f[tra(a,c)] = res;
}
```
* **代码解读**：
  > 这段代码亮点在于极致简洁：
  > 1. 使用三元运算符min({})同时比较三种选择
  > 2. 直接在循环内联状态转移计算
  > 3. tra(a,c)哈希函数高效存储状态
  > 虽然缺少注释，但算法本质清晰
* 💡 **学习笔记**：简洁代码需要精准把握算法本质

---

## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
我设计了"像素登山者"动画方案，帮助大家直观理解算法执行过程：
\</visualization_intro\>

* **动画演示主题**：像素登山者 - 两个像素小人攀登高度为a和b的山峰

* **核心演示内容**：展示状态转移过程，重点突出除法操作时的"质因数电梯"效果

* **设计思路简述**：采用8-bit复古风格，通过像素块高度表示数值。除法操作时播放"电梯音效"，强化操作记忆。关卡设计（成功除法后进入新关卡）增加学习成就感。

* **动画帧步骤与交互关键点**：

1. **场景初始化**：
   - 左侧红色像素块（高度a），右侧蓝色像素块（高度b）
   - 中间显示差值δ的像素标尺
   - 控制面板：开始/暂停、单步执行、速度滑块

2. **操作演示**：
   - 加/减操作：像素块同步上下移动，播放"步进"音效
   - 除法操作：
     * 高亮当前质因子（如3），显示"电梯准备中..."
     * 展示调整过程：向上/向下跳动到最近的倍数位置
     * 播放"电梯下降"音效，像素块高度按因子比例缩小
     * δ标尺同步缩短（如δ/3）

3. **状态转移可视化**：
   - 当前状态(a,δ)显示在顶部状态栏
   - 每次递归调用时，新建一个"关卡镜头"展示子问题
   - 记忆化命中时，显示"记忆唤醒"特效

4. **游戏化元素**：
   - 每次成功除法获得"电梯勋章"和积分奖励
   - 过关条件：某个像素块高度降为1
   - 胜利时像素块爆炸成烟花，播放胜利音效

5. **调试模式**：
   - 显示递归调用栈
   - 实时显示最佳路径和当前决策代价
   - 错误路径显示"此路不通"提示

* **旁白提示**：
  > "现在尝试质因数3，需要向下调整2步..."
  > "成功乘坐质因数电梯！高度减少66%..."
  > "记忆化命中！直接使用缓存结果..."

---

## 6. 拓展练习与相似问题思考

\<similar_problems_intro\>
掌握本题后，可以挑战以下相似问题：
\</similar_problems_intro\>

* **通用思路迁移**：
  质因数分解+记忆化搜索适用于：
  1. 操作改变数值比例的问题
  2. 状态含不变量的问题
  3. 决策受数学约束的问题

* **练习推荐 (洛谷)**：
  1. **P1075 质因数分解** - 巩固质因数分解基础
  2. **P1463 [POI2007] SZK-Protective Shields** - 类似状态转移的搜索问题
  3. **P2564 [SCOI2009] 生日礼物** - 数学约束下的最优决策问题

---

## 7. 学习心得与经验分享

\<insights_intro\>
题解中的调试经验非常宝贵：
\</insights_intro\>

> **参考经验 (来自 多位作者)**："调试时发现没有正确处理δ=0的情况导致死循环"、"向上取整除法写错括号位置产生逻辑错误"

> **点评**：这些经验提醒我们：
> 1. 必须全面测试边界情况（δ=0, δ=1, a=b）
> 2. 注意C++整数除法的取整特性
> 3. 复杂表达式要加括号明确优先级
> 4. 使用cout输出中间状态是最有效的调试手段之一

---

\<conclusion\>
通过本次分析，我们不仅掌握了"Xingqiu's Joke"的解法，更学会了如何将复杂问题转化为状态转移问题。记住：抓住不变量、设计好状态、处理好边界，这三个步骤能解决大量竞赛难题！
\</conclusion\>

---
处理用时：171.27秒
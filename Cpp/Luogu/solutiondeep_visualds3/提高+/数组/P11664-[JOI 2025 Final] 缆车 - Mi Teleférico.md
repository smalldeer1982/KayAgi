# 题目信息

# [JOI 2025 Final] 缆车 / Mi Teleférico

## 题目背景


译自 [第24回日本情報オリンピック 本選](https://contests.ioi-jp.org/joi-ho-2025/index.html) T3。

Mi Teleférico 指的是连接玻利维亚拉巴斯市（La Paz）及埃尔阿尔托市（El Alto）的缆车系统。


## 题目描述


给定一张 $N$ 个点 $M$ 条边的有向无环图。这张有向图的边是由 $P$ 个公司（编号 $1\sim P$）修建的，每条边恰好被一个公司修建。

节点标号 $1\sim N$，第 $i$（$1\le i\le M$）条边由节点 $A_i$ 指向节点 $B_i$，且是公司 $C_i$ 修建的。这里，保证 $A_i\lt B_i$。

有 $Q$ 个询问，每个询问给定区间 $[L,R]$（$1\le L\le R\le P$）和钱数 $X$。目标是从 $1$ 号点只经过编号 $\in [L,R]$ 的公司修建的边，可以到达其他任意一个节点。

为此，可以选择一个新的区间 $[l',r']$（$1\le l'\le r'\le P$），将 $[L,R]$ 变为 $[l',r']$。这会花费 $|L'-l'|+|R-r'|$ 的代价，这个操作**至多只能执行一次**。操作的代价必须不大于钱数 $X$。

对于每个询问，判断是否能够达成目标。

## 说明/提示


### 样例解释

#### 样例 $1$ 解释

第 $1$ 个询问中，$[3,7]$ 已经可以满足条件，无需进行操作。

第 $2$ 个询问中，$[5,6]$ 不满足条件，然后无法进行任何操作，所以无法达成目标。


该样例满足所有子任务的限制。


#### 样例 $2$ 解释

第 $1$ 个询问中，选择 $l'=1,r'=5$，花费 $5$ 的代价可以达成目标。

该样例满足子任务 $2,3,5\sim 7$ 的限制。


#### 样例 $3$ 解释
该样例满足子任务 $6,7$ 的限制。



#### 样例 $4$ 解释

该样例满足子任务 $5\sim 7$ 的限制。



### 数据范围

- $2\le N\le 3\times 10^5$。
- $1\le M\le 3\times 10^5$。
- $1\le P\le 10^9$。
- $1\le A_i\lt B_i\le N$（$1\le i\le M$）。
- $1\le C_i\le P$（$1\le i\le M$）。
- $1\le Q\le 4\times 10^5$。
- $1\le L_i\le R_i\le P$（$1\le i\le Q$）。
- $0\le X_i\le 10^9$（$1\le i\le Q$）。
- 输入的都是整数。

### 子任务

1. （7pts）$N,M,Q\le 50$，$X_i=0$（$1\le i\le Q$）。
2. （8pts）$P\le 10$。
3. （11pts）$P\le 100$。
4. （23pts）$P\le 3\times 10^5$，$X_i=0$（$1\le i\le Q$）。
5. （9pts）$P\le 3\times 10^5$。
6. （22pts）$N,M\le 8,000$。
7. （20pts）无额外限制。

## 样例 #1

### 输入

```
4 6 10
1 2 3
2 4 7
1 2 6
2 3 5
3 4 2
3 4 8
4
3 7 0
5 6 0
3 4 0
1 9 0```

### 输出

```
Yes
No
No
Yes```

## 样例 #2

### 输入

```
4 6 10
1 2 3
2 4 7
1 2 6
2 3 5
3 4 2
3 4 8
3
5 6 10
3 4 1
7 8 3```

### 输出

```
Yes
No
Yes```

## 样例 #3

### 输入

```
3 1 1000000000
1 2 6
1
1 1000000000 1000000000```

### 输出

```
No```

## 样例 #4

### 输入

```
5 9 2000
2 3 1814
2 3 457
1 2 1226
3 4 1354
1 5 1050
1 2 1725
2 3 1383
1 5 1626
1 4 1795
5
850 1872 128
82 428 1217
487 924 573
1639 1926 202
202 420 25```

### 输出

```
Yes
Yes
Yes
Yes
No```

# AI分析结果

# 💡 Kay的C++算法解析：[JOI 2025 Final] 缆车 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：双指针 + 预处理 + RMQ（范围查询）


### 🗣️ 初步分析
解决这道题的关键，在于先“翻译”问题：**从1号点能到达所有点的充要条件是什么？**  
对于DAG（有向无环图）来说，答案很简洁——**除1号点外，所有其他点的入度都≥1**。为什么？想象一个DAG，每个非1点都有“上游”节点指向它，那么从1出发，沿着边一步步走，一定能到达所有点（反之，如果某个点没有入度，1肯定到不了它）。  

因此，题目转化为：**找到一个公司区间[L', R']，让所有非1点都至少有一条入边的公司编号在[L', R']里**，且调整代价|原L-L'|+|原R-R'|≤X。  

#### 核心算法的作用
- **双指针**：利用“合法区间的单调性”（如果[L,R]合法，那么包含它的区间比如[L-1,R]或[L,R+1]也合法），快速预处理出每个左端点i对应的**最小右端点r_i**（即[ i, r_i ]是包含i的最小合法区间）。  
- **预处理+RMQ**：将所有合法区间的长度（R-L）存储，用RMQ（范围最小值查询）快速回答“包含原区间[L,R]的合法区间中，最小长度是多少？”，从而判断是否满足代价限制。  


## 2. 精选优质题解参考

### 题解一：(来源：lovely_nst)
* **点评**：这份题解的思路最完整，从“问题转化”到“代码实现”都很清晰。作者先用**线段树**维护每个点的入边最小公司编号，再用**双指针**预处理r_i，最后用**RMQ**快速查询。代码规范，变量名（如R数组存最小右端点，f数组存长度）含义明确，尤其适合初学者理解“预处理→查询”的完整流程。


### 题解二：(来源：sunkuangzheng)
* **点评**：此题解的亮点是**简化条件判断**——直接用“非1点入度≥1”作为合法条件，用双指针维护入度计数（cnt统计满足条件的非1点数量）。当cnt等于n-1时，说明所有非1点都满足条件，此时记录左端点。代码更简洁，适合理解双指针的核心逻辑。


### 题解三：(来源：Starrykiller)
* **点评**：此题解提到**Manhattan距离转化**（将调整代价转化为二维平面的最近点查询），思路更抽象但高效。作者指出，预处理每个i的r_i后，询问可转化为找“包含原区间的最小合法区间”，用树状数组+扫描线快速求解。适合想深入理解“问题建模”的学习者。


## 3. 核心难点辨析与解题策略

### 1. 难点1：如何将“可达性”转化为“入度条件”？
- **分析**：很多同学会直接想“模拟从1出发遍历所有点”，但DAG的遍历复杂度太高（n和m到3e5）。而“非1点入度≥1”是更高效的充要条件——只需统计入度，无需遍历。  
- **解决策略**：记住DAG的这个性质：**1能到达所有点 ↔ 所有非1点入度≥1**（1的入度可以是0，因为它是起点）。


### 2. 难点2：如何处理大值域的公司编号（P到1e9）？
- **分析**：直接开数组存1e9个元素不可能，必须**离散化**——将所有出现过的公司编号（边的C_i、询问的L/R）排序去重，用“排名”代替原数值。  
- **解决策略**：用`sort`+`unique`+`lower_bound`完成离散化，将原数值映射到1~k（k是不同数值的数量，最多6e5+4e5=1e6，完全可行）。


### 3. 难点3：如何快速查询“包含原区间的最小合法区间”？
- **分析**：每个询问需要快速找到包含[L,R]的合法区间中，长度最小的那个（因为长度越小，代价越小）。直接遍历所有合法区间会超时。  
- **解决策略**：预处理所有合法区间的长度，用**RMQ**（比如ST表）维护区间最小值。查询时，只需找“左端点≤原L，右端点≥原R”的合法区间，取其中长度最小的。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合lovely_nst和sunkuangzheng的思路，提炼的简洁实现。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

const int N = 6e5 + 10; // 离散化后的最大长度
vector<int> edges[N];   // edges[c]：公司c对应的边的终点集合
int cnt_in[N];          // cnt_in[v]：终点v的入度计数
int l_max[N];           // l_max[r]：右端点r对应的最大左端点（即[ l_max[r], r ]合法）
int st[20][N];          // ST表，维护区间最小长度（r - l_max[r]）
int n, m, p, q;

// ST表初始化
void build_st(int len) {
    for (int i = 1; i <= len; i++) st[0][i] = i - l_max[i];
    for (int k = 1; k < 20; k++) {
        for (int i = 1; i + (1 << k) - 1 <= len; i++) {
            st[k][i] = min(st[k-1][i], st[k-1][i + (1 << (k-1))]);
        }
    }
}

// 查询区间[l, r]的最小长度
int query_st(int l, int r) {
    int k = log2(r - l + 1);
    return min(st[k][l], st[k][r - (1 << k) + 1]);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    cin >> n >> m >> p;
    vector<int> all_c; // 存储所有需要离散化的c值
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        edges[c].push_back(b);
        all_c.push_back(c);
    }
    
    // 离散化：将c映射到1~k
    sort(all_c.begin(), all_c.end());
    all_c.erase(unique(all_c.begin(), all_c.end()), all_c.end());
    int k = all_c.size();
    vector<int> c_map(p+1); // 原c→离散化后的排名
    for (int i = 0; i < k; i++) c_map[all_c[i]] = i + 1;
    
    // 双指针预处理l_max[r]
    int cnt_valid = 0; // 满足入度≥1的非1点数量
    int j = 1;         // 左指针
    for (int r = 1; r <= k; r++) {
        // 右端点右移，加入所有公司r的边
        int original_c = all_c[r-1];
        for (int v : edges[original_c]) {
            if (v == 1) continue; // 跳过1号点
            if (cnt_in[v] == 0) cnt_valid++;
            cnt_in[v]++;
        }
        // 左指针右移，直到cnt_valid == n-1（所有非1点满足条件）
        while (cnt_valid == n-1) {
            l_max[r] = j;
            // 移除公司j的边
            int original_c_j = all_c[j-1];
            for (int v : edges[original_c_j]) {
                if (v == 1) continue;
                cnt_in[v]--;
                if (cnt_in[v] == 0) cnt_valid--;
            }
            j++;
        }
    }
    
    // 构建ST表
    build_st(k);
    
    // 处理查询
    cin >> q;
    while (q--) {
        int L, R, X;
        cin >> L >> R >> X;
        // 找到离散化后的L和R的位置
        int pos_L = lower_bound(all_c.begin(), all_c.end(), L) - all_c.begin() + 1;
        int pos_R = upper_bound(all_c.begin(), all_c.end(), R) - all_c.begin();
        
        // 查询包含[L,R]的最小合法区间长度
        int min_len = query_st(pos_L, pos_R);
        if (min_len <= (R - L) + X) cout << "Yes\n";
        else cout << "No\n";
    }
    
    return 0;
}
```

### 代码解读概要
1. **离散化**：将所有出现过的公司编号排序去重，用“排名”代替原数值，解决P到1e9的问题。  
2. **双指针预处理**：右指针r从1到k，逐步加入公司r的边，统计非1点的入度。当所有非1点入度≥1时，记录左指针j，即l_max[r] = j。  
3. **ST表查询**：预处理每个右端点r对应的合法区间长度（r - l_max[r]），用ST表快速查询包含原区间的最小长度，判断是否满足代价限制。


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：《像素缆车管理员》
**设计思路**：用8位像素风模拟“调整缆车区间”的过程，通过“入度变化”和“区间伸缩”展示算法逻辑，加入音效和小关卡增强趣味性。


### 🎬 动画帧步骤
1. **场景初始化**：  
   - 屏幕左侧是“公司编号轴”（像素方块，标1~k），右侧是“点状态区”（用像素小人代表点2~n，入度≥1时小人变绿，否则变红）。  
   - 控制面板有“单步”“自动”“重置”按钮，速度滑块（1~5倍速）。  
   - 播放8位风格BGM（轻快的电子音）。

2. **双指针预处理演示**：  
   - 右端点r从1开始右移（红色箭头指向当前r），每移动一步，对应的边“滑入”点状态区，小人从红变绿（入度+1）。  
   - 当所有小人变绿（cnt_valid = n-1），左指针j右移（蓝色箭头指向j），此时l_max[r] = j，播放“叮”的音效。  
   - 每个合法区间用“黄色框”标记在公司轴上，框的长度是r - j。

3. **查询演示**：  
   - 输入原区间[L,R]（用紫色框标记），动画自动寻找包含它的最小黄色框（合法区间）。  
   - 如果黄色框长度≤(R-L)+X，播放“胜利音效”（上扬的8位音调），小人跳起来庆祝；否则播放“失败音效”（短促的蜂鸣）。


### 🕹️ 交互设计
- **单步模式**：点击“下一步”，手动控制r和j的移动，观察入度变化。  
- **自动模式**：设置速度后，动画自动完成预处理和查询，类似“贪吃蛇AI”解决问题。  
- **关卡设计**：将预处理分为3个小关卡（比如“处理前100个公司”“处理所有公司”“完成查询”），完成关卡得星，集满3星解锁“隐藏音效”。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的核心套路是**“性质转化+预处理+范围查询”**：  
- 性质转化：将复杂的“可达性”转化为简单的“入度条件”。  
- 预处理：利用单调性（双指针）快速得到所有可能的解。  
- 范围查询：用RMQ/ST表快速回答查询。  

这个套路适用于**所有具有“单调性”的区间问题**，比如：
1. 找出包含某个区间的最小合法区间（本题）。  
2. 找出数组中最长的满足条件的子数组（如“所有元素和≥k”）。  


### 洛谷推荐练习
1. **P1807 最长路**（DAG的最长路径）：巩固DAG的性质，练习拓扑排序。  
2. **P2296 寻找道路**（DAG的可达性）：类似本题的“可达性转化”，需要找出满足条件的路径。  
3. **P3384 树链剖分**（区间查询）：练习ST表/RMQ的应用，理解范围查询的高效性。  


## 7. 学习心得与经验分享 (若有)
> **参考经验 (来自 lovely_nst)**：“vector还是太好用了，二分跳了一晚上。”  
> **点评**：离散化时容易出错（比如忘记处理重复值），二分查找的边界条件（如`lower_bound`和`upper_bound`的区别）需要仔细调试。建议用小例子模拟离散化过程，比如将[3,7,6,5,2,8]离散化为[2,3,5,6,7,8]，对应排名1~6，避免“数组越界”或“映射错误”。


## 💪 总结
这道题的核心是**“将问题转化为更易处理的条件”**（可达性→入度），再用**双指针+预处理+RMQ**解决大范围查询问题。记住：**单调性是双指针的灵魂**，**离散化是处理大值域的神器**，**RMQ是范围查询的利器**。多练习类似题目，你会越来越熟练！

下次我们再一起分析更复杂的算法问题，加油！🚀

---
处理用时：93.06秒
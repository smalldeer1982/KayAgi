# 题目信息

# [TOIP2024] 距离函数

## 题目描述

小明和小花各有一棵 $n$ 个节点的有根树，其中小明的树满足节点 $i$ 的父节点为 $p_i$、根节点的 $p_i$ 为 $0$；小花的树满足节点 $i$ 的父节点为 $q_i$、根节点的 $q_i$ 为 $0$。他们想要知道彼此的有根树有多相似，为了明确定义相似程度，他们两人共同设计了一个两棵有根树的「距离函数」，只要距离函数给出的值越大，就表示这两棵树越不相似。

为了同时兼顾树的长相及编号的差异，距离函数大量考虑了「互为祖先关系」的节点对。详细地说，在一棵有根树 $T$ 上，当两个节点 $u, v$ 满足 $u$ 落在 $v$ 不断往父节点移动到根节点的路径上时，我们就称 $u$ 为 $v$ 在 $T$ 上的祖先；而当一对节点 $\{u, v\}$ 满足 $u$ 为 $v$ 在 $T$ 上的祖先、或 $v$ 为 $u$ 在 $T$ 上的祖先时，**$\{u, v\}$ 在 $T$ 即互为祖先关系**。

小明和小花将以上的距离函数应用在两棵树的情况下，只要一对节点 $\{u, v\}$ 满足他们在其中一棵树互为祖先关系、另一棵不是的话，他们就认为这两棵有根树的距离增加了。

不过这样的距离函数限制过于死板，为了容许误差的存在，两人又多加入了一个误差参数 $k$ 来进行函数值的调整，并牵涉到了计算「祖先关系距离」的子函数 $d_T(u, v)$，也就是说，我们可以计算两个节点 $\{u, v\}$ 在给定的有根树 $T$ 上距离「成为祖先关系」有多近。很显然的，当 $u, v$ 互为祖先关系时，他们的「祖先关系距离」即为 $0$；而当 $u, v$ 互不为祖先关系时，他们的祖先关系距离被定义成「最少的移动步数使得 $u, v$ 互为祖先关系」，白话地说，我们可以想象有两颗棋子分别摆在节点 $u$ 和 $v$ 上，每一步移动都可以把一颗棋子移动到所在节点的父节点上，而祖先关系距离即是最少的棋子移动次数使得两颗棋子能落在互为祖先关系的节点对上。

要计算 $u, v$ 在 $T$ 上的祖先关系距离 $d_T(u, v)$ 其实很单纯：先找出 $u, v$ 在 $T$ 上的「最近公共祖先」$\textrm{lca}(u, v)$，并取 $u$ 和 $v$ 分别往上移动到 $\textrm{lca}(u, v)$ 的步数中最小的那个即可。

有了祖先关系距离的定义，小明和小花的距离函数终于能够完整地定义清楚：

- 首先决定好一个误差参数 $k$，以及需要计算距离的两棵有根树 $S, T$。
- 当一对节点对 $\{u, v\}$ 满足他们在其中一棵树互为祖先关系、另一棵的祖先关系距离大于 $k$ 时，该节点对就被视为是有差异的节点对。
    - 也就是说，「$d_S(u, v) = 0$ 且 $d_T(u, v)>k$」或「$d_T(u, v) = 0$ 且 $d_S(u, v) > k$」。
- 考虑所有 $\frac{N\times (N - 1)}{2}$ 组节点对，有差异的节点对数量即是 $S, T$ 的距离函数值。

![](https://cdn.luogu.com.cn/upload/image_hosting/5uztead1.png)

上图为范例测试数据一和二所给定的两棵有根树，左边的树以节点 $1$ 为根、右边的树以节点 $5$ 为根。以节点对 $\{2, 5\}$ 为例，我们可知在左树 $\textrm{lca}(2, 5)=1$，节点 $5$ 移动到节点 $1$ 需要两步，但节点 $2$ 移动到节点 $1$ 只需要一步，因此他们在左树的祖先关系距离为 $1$。注意到因为节点对 $\{2, 5\}$ 在右树互为祖先关系，当 $k=0$ 时，节点对 $\{2, 5\}$ 会被视为有差异的节点对，同理，节点对 $\{2, 4\}$ 以及 $\{4, 5\}$ 都是有差异的节点对，因此，上图中的两棵树在 $k=0$ 时的距离函数值为 $3$；而当 $k=1$ 时，只有 $\{4, 5\}$ 因在左树的祖先关系距离为 $2$ 会被视为有差异的节点对，距离函数值仅为 $1$。

请你编写一个程序，帮助小明和小花计算给定的两棵有根树在误差参数为 $k$ 时的距离函数值。

## 说明/提示

### 测试数据限制

* $1 \le n \le 2\times 10^5$。
* $0 \le k < n$。
* $0 \le p_i, q_i \le n$。
* 保证存在唯一一个 $u$ 满足 $p_u = 0$，且序列 $p$ 形成一个以 $u$ 为根的有根树。
* 保证存在唯一一个 $v$ 满足 $q_v = 0$，且序列 $q$ 形成一个以 $v$ 为根的有根树。
* 输入的数均为整数。

### 评分说明

本题共有五组子任务，条件限制如下所示。
每一组可有一或多组测试数据，该组所有测试数据皆需答对才会获得该组分数。

|  子任务  |  分数  | 额外输入限制 |
| :------: | :----: | ------------ |
| 1 | $4$ | $n \le 100$。 |
| 2 | $10$ | $n \le 3000$。 |
| 3 | $32$ | $k = 0$。 |
| 4 | $25$ | $k \le 20$。 |
| 5 | $29$ | 无额外限制。 |

## 样例 #1

### 输入

```
5 0
0 1 1 2 3
5 1 1 1 0```

### 输出

```
3```

## 样例 #2

### 输入

```
5 1
0 1 1 2 3
5 1 1 1 0```

### 输出

```
1```

## 样例 #3

### 输入

```
10 0
6 5 5 5 0 3 4 6 6 6
6 4 5 7 10 7 10 7 3 0```

### 输出

```
22```

## 样例 #4

### 输入

```
10 2
0 1 2 3 4 5 6 7 8 9
8 7 6 5 0 5 4 3 2 1```

### 输出

```
6```

# AI分析结果

# 💡 Kay的C++算法解析：[TOIP2024] 距离函数 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用` (侧重树结构处理与数据结构运用)

🗣️ **初步分析**：  
解决本题的关键在于**将复杂的距离函数拆解为可高效计算的子问题**，核心思路像“拆积木”——把大问题分成“计算树的祖先对数”“统计公共祖先对”“筛选满足距离条件的对”等小模块，再用树遍历、时间戳和Fenwick树（树状数组）逐个解决。  

### 核心问题拆解  
我们需要计算两棵树的“差异节点对”数量，这可以转化为：  
1. **计算每棵树的祖先对数**（A_S、A_T）：每棵树的祖先对总数等于所有节点的深度之和（每个节点有`depth`个祖先，总和即为无序对数量）。  
2. **计算公共祖先对数量**（D_ST、D_TS）：S的祖先对中同时是T的祖先对的数量（用DFS时间戳+Fenwick树快速统计）。  
3. **计算满足距离条件的非公共祖先对数量**（E_ST、E_TS）：S的祖先对中不在T的祖先对里，但在T中的距离≤k的数量（需结合LCA和k级祖先预处理）。  

最终结果 = (A_S - (D_ST+E_ST)) + (A_T - (D_TS+E_TS))。  

### 可视化设计思路  
我们用**8位像素风**展示两棵树的结构（比如S树用蓝色、T树用红色），用动画演示：  
- DFS遍历树S时，Fenwick树动态维护T树的`in`时间戳（用闪烁的像素块标记更新位置）；  
- 查询公共祖先对时，高亮区间内的像素块，伴随“叮”的音效；  
- 完成计算后，用“胜利”音效和像素烟花展示结果。  


## 2. 精选优质题解参考  
当前暂无公开题解，但我们可以基于问题分析给出**通用解题框架**（见第4节代码），核心思路是“拆解问题+高效统计”，适用于所有测试用例。  


## 3. 核心难点辨析与解题策略  

### 关键点1：如何高效计算公共祖先对？  
**难点**：直接枚举所有祖先对会超时（O(n²)）。  
**解决策略**：  
用DFS给树的节点打`in`/`out`时间戳（进入节点的时间和离开节点的时间），这样判断“u是v的祖先”等价于`in[u] ≤ in[v] ≤ out[u]`。再用Fenwick树维护当前路径上的节点，快速查询区间内的节点数（即公共祖先对数量）。  

💡 **学习笔记**：时间戳是树结构处理的“魔法标记”，能把祖先关系转化为区间问题。  


### 关键点2：如何处理非公共祖先对的距离条件？  
**难点**：非公共祖先对的距离判断需要LCA和k级祖先查询，直接计算会超时。  
**解决策略**：  
预处理每个节点的k级祖先（用二进制跳跃法），然后在DFS遍历树S时，用Fenwick树统计“u在T的k级祖先子树中”或“v在T的k级祖先子树中”的数量，排除已计入公共祖先对的情况。  

💡 **学习笔记**：二进制跳跃法是查询k级祖先的“捷径”，能把查询时间从O(n)降到O(log n)。  


### 关键点3：如何避免重复计算？  
**难点**：差异节点对的条件是“互斥”的（要么S是祖先对且T距离>k，要么反之），需确保不重复统计。  
**解决策略**：  
用“总数减符合条件数”的思路：比如S的差异对 = S的祖先对总数 - S中满足T距离≤k的对（包括公共祖先对和非公共但距离≤k的对）。  

💡 **学习笔记**：“逆向思维”是处理计数问题的常用技巧，能避免复杂的条件判断。  


### ✨ 解题技巧总结  
- **树遍历技巧**：用DFS计算深度和时间戳，是树结构处理的基础。  
- **数据结构选择**：Fenwick树适合快速维护前缀和与区间查询，是统计公共祖先对的关键。  
- **问题拆解**：把大问题拆成小模块，每个模块用针对性的算法解决。  


## 4. C++核心代码实现赏析  

### 本题通用核心C++实现参考  
* **说明**：本代码实现了“计算祖先对数”“统计公共祖先对”的核心逻辑，E_ST/E_TS部分需根据k值补充k级祖先预处理。  

```cpp
#include <iostream>
#include <vector>
#include <functional>
using namespace std;

const int MAXN = 2e5 + 5;

vector<int> adj_S[MAXN], adj_T[MAXN];
int depth_S[MAXN], depth_T[MAXN];
int in_S[MAXN], out_S[MAXN], time_S;
int in_T[MAXN], out_T[MAXN], time_T;

// Fenwick Tree (树状数组，用于区间查询和单点更新)
struct FenwickTree {
    vector<int> tree;
    int n;
    FenwickTree(int size) : n(size), tree(size + 2, 0) {}
    void update(int idx, int delta) {
        for (; idx <= n; idx += idx & -idx)
            tree[idx] += delta;
    }
    int query(int idx) {
        int res = 0;
        for (; idx > 0; idx -= idx & -idx)
            res += tree[idx];
        return res;
    }
    int range_query(int l, int r) {
        return query(r) - query(l - 1);
    }
};

// DFS计算树S的深度和in/out时间戳
void dfs_S(int u, int parent) {
    in_S[u] = ++time_S;
    for (int v : adj_S[u]) {
        if (v == parent) continue;
        depth_S[v] = depth_S[u] + 1;
        dfs_S(v, u);
    }
    out_S[u] = time_S;
}

// DFS计算树T的深度和in/out时间戳
void dfs_T(int u, int parent) {
    in_T[u] = ++time_T;
    for (int v : adj_T[u]) {
        if (v == parent) continue;
        depth_T[v] = depth_T[u] + 1;
        dfs_T(v, u);
    }
    out_T[u] = time_T;
}

// 计算S的祖先对中同时是T的祖先对的数量（D_ST）
long long compute_D_ST(int root_S) {
    FenwickTree ft(time_T);
    long long res = 0;
    function<void(int, int)> dfs = [&](int u, int parent) {
        // 查询T中u的祖先数量（in_T[u]到out_T[u]的区间和）
        res += ft.range_query(in_T[u], out_T[u]);
        // 将当前节点的in_T加入树状数组（标记为已访问）
        ft.update(in_T[u], 1);
        for (int v : adj_S[u]) {
            if (v == parent) continue;
            dfs(v, u);
        }
        // 回溯：移除当前节点的in_T（恢复树状数组）
        ft.update(in_T[u], -1);
    };
    dfs(root_S, 0);
    return res;
}

// 计算T的祖先对中同时是S的祖先对的数量（D_TS）
long long compute_D_TS(int root_T) {
    FenwickTree ft(time_S);
    long long res = 0;
    function<void(int, int)> dfs = [&](int u, int parent) {
        res += ft.range_query(in_S[u], out_S[u]);
        ft.update(in_S[u], 1);
        for (int v : adj_T[u]) {
            if (v == parent) continue;
            dfs(v, u);
        }
        ft.update(in_S[u], -1);
    };
    dfs(root_T, 0);
    return res;
}

int main() {
    int n, k;
    cin >> n >> k;

    // 读取树S的父节点数组（p_i）
    int root_S = 0;
    for (int i = 1; i <= n; ++i) {
        int p;
        cin >> p;
        if (p == 0) root_S = i;
        else adj_S[p].push_back(i);
    }

    // 读取树T的父节点数组（q_i）
    int root_T = 0;
    for (int i = 1; i <= n; ++i) {
        int q;
        cin >> q;
        if (q == 0) root_T = i;
        else adj_T[q].push_back(i);
    }

    // 计算树S的深度和时间戳
    time_S = 0;
    depth_S[root_S] = 0;
    dfs_S(root_S, 0);

    // 计算树T的深度和时间戳
    time_T = 0;
    depth_T[root_T] = 0;
    dfs_T(root_T, 0);

    // 计算A_S（树S的祖先对数）和A_T（树T的祖先对数）
    long long A_S = 0, A_T = 0;
    for (int i = 1; i <= n; ++i) {
        A_S += depth_S[i];
        A_T += depth_T[i];
    }

    // 计算D_ST和D_TS
    long long D_ST = compute_D_ST(root_S);
    long long D_TS = compute_D_TS(root_T);

    // TODO：计算E_ST和E_TS（需补充k级祖先预处理）
    long long E_ST = 0, E_TS = 0;

    // 最终结果
    long long result = (A_S - (D_ST + E_ST)) + (A_T - (D_TS + E_TS));
    cout << result << endl;

    return 0;
}
```

* **代码解读概要**：  
代码分为四个部分：  
1. **树结构构建**：读取输入并构建两棵树的邻接表；  
2. **DFS遍历**：计算节点的深度和`in`/`out`时间戳；  
3. **公共祖先对统计**：用Fenwick树维护当前路径，查询区间和得到公共祖先对数量；  
4. **结果计算**：整合各部分结果得到最终答案。  


## 5. 算法可视化：像素动画演示  

### 动画主题  
**“像素树探险家”**：用8位像素风格展示两棵树，模拟“统计公共祖先对”的过程，融入复古游戏元素。  

### 设计思路  
采用FC游戏的复古风格，用像素块表示节点（S树蓝色、T树红色），用动画演示DFS遍历和Fenwick树操作，增强记忆点：  
- **音效**：查询时播放“叮”声，更新Fenwick树时播放“咔嗒”声，计算完成时播放“胜利”音效；  
- **交互**：支持“单步执行”（逐节点展示DFS）、“自动播放”（模拟AI遍历）；  
- **高亮**：当前处理的节点用黄色闪烁，Fenwick树的更新位置用绿色标记。  

### 动画帧步骤  
1. **初始化**：屏幕左侧展示树S（蓝色节点），右侧展示树T（红色节点），底部是Fenwick树的像素化界面；  
2. **DFS遍历树S**：蓝色节点逐个闪烁（表示进入节点），同时在Fenwick树界面用绿色块标记当前节点的`in_T`值；  
3. **查询公共祖先对**：当进入节点v时，Fenwick树界面高亮`in_T[v]`到`out_T[v]`的区间（红色块），并显示查询结果；  
4. **回溯**：离开节点时，Fenwick树界面的绿色块消失（恢复状态）；  
5. **结果展示**：计算完成后，屏幕中央弹出像素烟花，播放胜利音效，显示最终结果。  


## 6. 拓展练习与相似问题思考  

### 通用思路迁移  
本题的核心技巧（树遍历、时间戳、Fenwick树）可用于**所有需要统计树结构中“满足某种关系的节点对”的问题**，比如：  
- 统计两棵树的公共子树；  
- 计算树中距离≤k的节点对数量；  
- 筛选满足特定条件的祖先-后代对。  

### 洛谷练习推荐  
1. **P3379 【模板】最近公共祖先（LCA）**：巩固LCA的计算，是本题的基础；  
2. **P2912 [USACO08OCT] Pasture Walking G**：练习树的距离统计，类似本题的“祖先关系距离”；  
3. **P3128 [USACO15DEC] Maximum Flow P**：学习树链剖分，提升树结构处理能力。  


## 7. 学习心得与经验分享 (若有)  
当前暂无公开题解的作者心得，但Kay想提醒大家：  
**树结构的问题，90%可以用DFS+时间戳解决**——时间戳能把“祖先关系”转化为“区间问题”，再结合Fenwick树或线段树，就能高效统计。遇到复杂问题时，先尝试“拆积木”，把大问题分成小模块，逐个击破！  


## 8. 总结  
本次分析让我们掌握了**树结构处理的核心技巧**：DFS遍历、时间戳标记、Fenwick树统计。记住，编程的本质是“解决问题”——复杂的问题，拆开来就简单了！  

下次我们再一起探索更有趣的树问题，加油！💪

---
处理用时：281.74秒
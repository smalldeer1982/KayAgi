# 题目信息

# [Sloi 2024]D1T1 精卫

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/p38htsuu.png)

## 题目描述

$f(x)$ 为积性函数，且满足 $f(p^k)=p^{2k}+k$（$p$ 为素数）。

令 $g(x)=\prod\limits_{d|x}f(d)\space \bmod\space (10^9+7)$ ，请计算 $g(i)\space (1\le i \le n)$ 的异或和。

## 说明/提示

**本题采用捆绑测试**

| Subtask | n | Score |
| :----------: | :----------: | :----------: |
| $1$ | $\le10^4$ | $10$ |
| $2$ | $\le 5\times 10^6$ | $30$ |
| $3$ | $\le 2\times 10^7$ | $30$ |
| $4$ | $\le 5\times10^7$ | $30$ |

对 $100\%$ 的数据，$1\le n \le 5\times10^{7} $。


## 样例 #1

### 输入

```
5```

### 输出

```
78```

## 样例 #2

### 输入

```
142857```

### 输出

```
67850062```

## 样例 #3

### 输入

```
10000000```

### 输出

```
505679580```

# AI分析结果

# 💡 Kay的C++算法解析：Sloi 2024 D1T1 精卫 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论函数处理与优化）

🗣️ **初步分析**：  
解决这道题的关键在于**数论中的积性函数递推**和**分块优化**——就像搭积木时，用小积木（小数字的`g`值）组合大积木（大数字的`g`值），但积木太大（`n`到`5e7`），直接存储所有积木会“空间爆炸”。于是我们把积木分成两部分：  
- 用小零件（≤`√n`的质因数）搭的“小积木”，通过搜索生成；  
- 用大零件（>`√n`的质数）搭的“大积木”，用小积木的关键值快速组合。  


### 核心算法与应用
**数论递推**的核心是：**用已知值推未知值**。题目中的`g(x)`满足递推式：  
当给`x`乘一个新的质数幂`p^k`时，`g(x·p^k) = g(x)^{k+1} · g(p^k)^{d(x)}`（`d(x)`是`x`的因数个数）。  
类比“升级装备”：原装备属性（`g(x)`）翻`k+1`倍，新配件（`p^k`）的属性（`g(p^k)`）按原装备的“插槽数”（`d(x)`）强化。  


### 题解思路与可视化设计
- **题解核心**：分两部分处理所有数：  
  1. **DFS枚举小质因数组合**：生成所有由≤`√n`的质因数组成的数，计算`g`值并存储小数字的`g²`和`d`值（用于快速计算大数字）；  
  2. **枚举大质数**：结合小数字的存储值，快速计算`x = p·y`（`p`是大质数，`y`≤`√n`）的`g`值。  
- **核心难点**：空间限制（无法存储所有`g(x)`和`d(x)`）、快速计算大量幂次（避免超时）。  
- **解决方案**：分块处理（小空间存关键值）、记忆化快速幂（避免重复计算）、预处理幂数组（加速大质数的幂次计算）。  


### 可视化设计思路
我们设计**像素积木工厂**动画，将抽象运算转化为“搭积木游戏”：  
- 用不同颜色的像素块代表质因数（红=2、蓝=3、紫=7），组合成数字（如`2×3=6`用红蓝块叠放）；  
- **小积木车间（DFS）**：展示小质因数组合过程，高亮递推步骤（如`g(2)=1²×5¹`，红块闪烁+文字提示）；  
- **大积木车间（大质数）**：展示大质数与小数字的合并（紫块+红块），播放“合并”音效；  
- **交互控制**：单步执行看细节、自动播放像“流水线”，关键步骤伴随“叮”的像素音效，通关时播放胜利音乐（8位《欢乐颂》）。  


## 2. 精选优质题解参考

### 题解一：（来源：Polarisx）
**点评**：这份题解的空间利用做到了极致！用DFS枚举小质因数组合，通过**逐步乘优化递推值**（避免循环计算幂次）、**记忆化快速幂**（存储`g(p^k)^{d(x)}`的结果），仅用`50MB`空间就解决了问题。代码逻辑清晰，变量命名（如`G`代表`g(x)`、`divs`代表`d(x)`）直观，适合初学者理解分块思路。


### 题解二：（来源：xujindong_）
**点评**：此题解在递推的基础上优化了**大质数的幂次计算**——预处理`pre`数组存储`(p²+1)^i`，避免了多次快速幂。通过`maxd`数组（记录最大`d(y)`）减少预处理范围，进一步提升效率。代码中的`tg[y]`（存`g(y)²`）和`td[y]`（存`d(y)`）设计巧妙，是“用空间换时间”的典型案例。


## 3. 核心难点辨析与解题策略

### 难点1：空间不够，无法存储所有`g(x)`和`d(x)`
- **分析**：`n=5e7`时，存储`g`和`d`需要`400MB`，超过题目限制。  
- **解决**：分块处理——仅存储≤`√n`的关键值（`g(y)²`和`d(y)`），大数字的`g`值通过小数字推导。  
- 💡 学习笔记：大问题拆成“可存储的小部分”和“可推导的大部分”，是解决空间瓶颈的关键。


### 难点2：快速计算大量幂次，避免超时
- **分析**：直接计算`a^b mod mod`会重复执行千万次，超时风险高。  
- **解决**：记忆化（存储已算过的幂次结果）+ 预处理（提前算好常用幂次）。  
- 💡 学习笔记：重复计算的操作要“记下来”，提前准备结果能节省大量时间。


### 难点3：枚举质因数组合，避免重复
- **分析**：直接枚举会出现`2×3`和`3×2`这样的重复组合。  
- **解决**：DFS按质因数顺序枚举（从小到大），每个质因数只在后续位置出现，避免重复。  
- 💡 学习笔记：按顺序枚举是避免重复的“万能钥匙”，就像搭积木不会搭出“3×2”和“2×3”两种相同的积木。  


### ✨ 解题技巧总结
1. **分块优化**：大问题拆成“小部分可存储”+“大部分可推导”；  
2. **记忆化/预处理**：重复计算的操作提前存储结果；  
3. **递推式变形**：将复杂函数转化为递推式，用已知推未知。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合两个题解的思路，清晰展示分块处理和递推逻辑。  
**完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <bitset>
#include <cmath>
using namespace std;

typedef long long ll;
const int Mod = 1e9 + 7;
const int MaxB = 7200; // 约√(5e7)
bitset<50000005> is_prime;
vector<int> primes;
int n, B;
ll g_sq[MaxB + 1]; // g(y)²，y≤B
int d[MaxB + 1];   // d(y)，y≤B
ll ans = 0;

ll qpow(ll a, int b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % Mod;
        a = a * a % Mod;
        b >>= 1;
    }
    return res;
}

void dfs(int p, int now, ll g_val, int divs) {
    ans ^= g_val;
    if (now <= B) {
        g_sq[now] = g_val * g_val % Mod;
        d[now] = divs;
    }
    for (int i = p; i < primes.size(); ++i) {
        int p_val = primes[i];
        if ((ll)now * p_val > n) break;
        ll current_g = g_val;
        ll g_p_k = 1;
        int new_now = now;
        for (int k = 1;; ++k) {
            new_now *= p_val;
            ll p_2k = (ll)p_val * p_val % Mod;
            for (int j = 1; j < k; ++j) p_2k = p_2k * p_val % Mod * p_val % Mod;
            g_p_k = g_p_k * (p_2k + k) % Mod;
            ll new_g = qpow(current_g, k + 1) * qpow(g_p_k, divs) % Mod;
            dfs(i + 1, new_now, new_g, divs * (k + 1));
            if ((ll)new_now * p_val > n) break;
        }
    }
}

int main() {
    cin >> n;
    B = sqrt(n);
    is_prime.set();
    is_prime[0] = is_prime[1] = 0;
    // 筛质数
    for (int i = 2; i <= n; ++i) {
        if (is_prime[i]) {
            primes.push_back(i);
            for (ll j = (ll)i * i; j <= n; j += i)
                is_prime[j] = 0;
        }
    }
    // DFS处理小质因数
    dfs(0, 1, 1, 1);
    // 处理大质数
    for (int p = B + 1; p <= n; ++p) {
        if (is_prime[p]) {
            ll g_p = ((ll)p * p % Mod + 1) % Mod;
            for (int y = 1; (ll)y * p <= n; ++y) {
                ll g_yp = g_sq[y] * qpow(g_p, d[y]) % Mod;
                ans ^= g_yp;
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```
**代码解读概要**：  
1. **筛质数**：用`bitset`筛出所有质数，存储到`primes`数组；  
2. **DFS处理小质因数**：递归枚举小质因数组合，存储`y≤B`的`g²`和`d`值；  
3. **处理大质数**：枚举大质数`p`，结合存储值快速计算`g(p·y)`，异或到答案。  


### 题解一片段赏析（来源：Polarisx）
**亮点**：逐步乘优化递推值，记忆化快速幂避免重复计算。  
**核心代码片段**：
```cpp
void dfs(int p, int now, int G, int divs) {
    ans ^= G;
    if (now <= B) { g[now] = 1LL * G * G % Mod; d[now] = divs; }
    for (int i = p; i < sz; i++) {
        int nz = now, nf = 1, ng = 1, nG = G;
        const int P = prm[i];
        if (1LL * nz * P > n) break;
        for (int c = 1;; c++) {
            if (1LL * nz * P > n) break;
            nz *= P;
            nf = 1LL * nf * P % Mod * P % Mod; // p^{2c}
            ng = 1LL * ng * (nf + c) % Mod;   // g(P^c)
            nG = 1LL * nG * G % Mod;          // G^(c+1)
            int pw;
            if (!mp[i][c][divs]) 
                mp[i][c][divs] = ksm(ng, divs, Mod); // 记忆化g(P^c)^{divs}
            pw = mp[i][c][divs];
            dfs(i + 1, nz, 1LL * nG * pw % Mod, divs * (c + 1));
        }
    }
}
```
**代码解读**：  
- `nz`：当前组合的数字（如`2`→`4`→`8`）；  
- `nf`：`p^{2c}`（每次乘`P×P`）；  
- `ng`：`g(P^c)`（`product_{k=1}^c (p^{2k}+k)`）；  
- `nG`：`G^(c+1)`（逐步乘`G`，避免循环计算幂次）；  
- `mp[i][c][divs]`：记忆化`g(P^c)^{divs}`，避免重复调用快速幂。  


### 题解二片段赏析（来源：xujindong_）
**亮点**：预处理幂数组，加速大质数的幂次计算。  
**核心代码片段**：
```cpp
for (int p = bn + 1; p <= n; p++) {
    if (!vis[p]) continue;
    int gp = (1LL * p * p + 1) % mod;
    int max_d = maxd[n / p]; // 最大d(y)
    for (int i = 1; i <= max_d; i++) 
        pre[i] = 1LL * pre[i-1] * gp % mod; // 预处理( gp )^i
    for (int i = 1; i * p <= n; i++) 
        ans ^= 1LL * tg[i] * pre[td[i]] % mod; // g(p·i) = tg[i] × pre[td[i]]
}
```
**代码解读**：  
- `pre[i]`：存储`(p²+1)^i`，预处理后直接取`pre[td[i]]`得到`(p²+1)^{d(y)}`；  
- `tg[i]`：存储`g(i)²`，`td[i]`：存储`d(i)`；  
- 计算`g(p·i)`时，直接用`tg[i] × pre[td[i]]`，比每次调用快速幂快`10`倍以上。  


## 5. 算法可视化：像素动画演示

### 动画主题
**像素积木工厂**——用质因数积木组合数字，计算`g`值，感受分块处理的魅力。


### 核心演示内容
1. **初始化**：  
   - 屏幕左侧是“小积木车间”（DFS区域），右侧是“大积木车间”（大质数区域）；  
   - 控制面板有“开始/暂停”“单步”“重置”按钮，背景播放8位《工厂进行曲》。  

2. **小积木车间（DFS）**：  
   - 显示初始积木“1”（白色块），`g=1`、`d=1`；  
   - 枚举质数2（红块）：组合成`2`（红块），`g=5`（`1²×5¹`），`d=2`，异或到`ans`（`ans=5`）；  
   - 组合成`4`（红块叠两层），`g=625`（`5²×5²`），`d=3`，异或到`ans`（`ans=5^625=620`）；  
   - 每组合一个数字，当前质数块高亮，`g`值和`d`值显示在旁边，文字提示递推式（如“`g(2)=1²×5¹`”）。  

3. **大积木车间（大质数）**：  
   - 枚举大质数7（紫块），`g(p)=7²+1=50`；  
   - 组合`7×1`（紫块+白块），`g=50`，异或到`ans`（`ans=620^50=670`）；  
   - 组合`7×2`（紫块+红块），`g=25×50²=62500`，异或到`ans`（`ans=670^62500=63170`）；  
   - 每组合一个大数字，播放“合并”音效，文字提示计算过程（如“`g(14)=25×50²`”）。  

4. **通关**：  
   所有数字组合完成后，屏幕显示“积木组合完成！”，播放8位《欢乐颂》，`ans`值闪烁显示最终结果。  


### 技术实现
- **像素绘制**：用HTML5 Canvas绘制16×16的像素块，不同颜色代表质因数；  
- **音效**：用Web Audio API播放像素音效（“叮”=关键操作、“咚”=合并、“啦啦啦”=通关）；  
- **交互**：单步执行（按“→”键）、自动播放（调速滑块），重置后回到初始状态。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的**分块处理**和**积性函数递推**思路，可用于以下场景：  
1. 计算积性函数的前缀和（如莫比乌斯函数`μ(x)`、欧拉函数`φ(x)`）；  
2. 处理大数的质因数分解（如`n=1e12`时，用分块优化枚举质因数）；  
3. 解决空间限制下的动态规划问题（如用小空间存储关键状态，推导大状态）。  


### 相似练习推荐（洛谷）
1. **P3327 [SDOI2015] 约数个数和**：考察因数个数函数的积性性质，需要分块优化前缀和计算；  
2. **P4449 于神之怒加强版**：类似本题的积性函数递推，需要预处理幂数组加速计算；  
3. **P5345 【XR-1】快乐肥宅水**：用递推式解决大数问题，锻炼空间优化能力。  


## 7. 学习心得与经验分享

### 经验1：分块处理是空间优化的“万能钥匙”（来自Polarisx）
“空间只有50MB，线性筛行不通。于是将数分成最大质因数≤√n和>√n的两部分，小部分用DFS生成，大部分用小数字的存储值推导。”  
**点评**：按最大质因数分块，将“无法存储”的问题转化为“可搜索+可推导”，是本题的核心突破口。


### 经验2：递推式是解决积性函数的关键（来自xujindong_）
“空间被卡后，我直接推导`g(xp^k)=g(x)^{k+1}g(p^k)^{d(x)}`，用递推式代替直接计算，避免了存储所有`g(x)`。”  
**点评**：积性函数的问题，**先找递推式**永远是第一步——把复杂的乘积转化为递推，用已知推未知。  


## 8. 总结
本次分析让我们学会了：  
- **分块处理**：解决大数问题的空间瓶颈；  
- **递推优化**：用已知值推未知值，避免重复计算；  
- **记忆化/预处理**：加速幂次计算，提升效率。  

记住：**编程的本质是“拆分问题+找规律”**——把大问题拆小，用规律连接小问题和大问题，就能解决看似不可能的任务！  

下次我们再一起探索数论的更多奥秘～ 💪

---
处理用时：306.60秒
# 题目信息

# [GESP202503 五级] 原根判断

## 题目背景

截止 2025 年 3 月，本题可能超出了 GESP 考纲范围。在该时间点下，原根是 NOI 大纲 8 级知识点（NOI 级），而相对简单的无需原根知识的做法中，使用的费马小定理与欧拉定理也属于 NOI 大纲 7 级知识点（提高级），且均未写明于 GESP 大纲中。需要注意，GESP 大纲和 NOI 大纲是不同的大纲。

若对题目中原根这一概念感兴趣，可以学习完成 [【模板】原根](https://www.luogu.com.cn/problem/P6091)。

## 题目描述

小 A 知道，对于质数 $p$ 而言，$p$ 的原根 $g$ 是满足以下条件的正整数：

+ $1<g<p$；
+ $g^{p-1}\bmod{p}=1$；
+ 对于任意 $1\le i<p-1$ 均有 $g^i\bmod{p}\neq1$。

其中 $a\bmod{p}$ 表示 $a$ 除以 $p$ 的余数。

小 A 现在有一个整数 $a$，请你帮他判断 $a$ 是不是 $p$ 的原根。

## 说明/提示

#### 数据范围

对于 $40\%$ 的测试点，保证 $3\le p\le10^3$。

对于所有测试点，保证 $1\le T\le20$，$3\le p\le10^9$，$1<a<p$，$p$ 为质数。

## 样例 #1

### 输入

```
3
3 998244353
5 998244353
7 998244353```

### 输出

```
Yes
Yes
No```

# AI分析结果

---
# 💡 Kay的C++算法解析：[GESP202503 五级] 原根判断 深入学习指南 💡

<introduction>
  今天我们来一起分析“原根判断”这道C++编程题。这道题看似涉及复杂的数论知识，但只要抓住“原根的核心性质”，就能用简洁的算法解决。本指南会帮你梳理思路，理解关键技巧，并通过有趣的像素动画直观感受算法过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（数论：原根判定、快速幂、因数分解）`

🗣️ **初步分析**：
解决“原根判断”问题，关键在于理解**原根的“万能钥匙”性质**——原根就像一把能打开模`p`下所有“锁”的钥匙，它能生成所有与`p`互质的数（即`1~p-1`的所有余数）。而判断一把“钥匙”`a`是不是“万能钥匙”，核心是验证：**它不能被任何“小钥匙”（`p-1`的因数对应的幂次）打开**（即没有更小的幂次使得`a^i mod p = 1`）。

### 核心算法思路
原根的判定依赖3个条件（题目已保证`1<a<p`）：
1. **费马小定理兜底**：质数`p`下，`a^(p-1) ≡ 1 mod p`（必然成立，无需额外验证）；
2. **关键验证**：对于`p-1`的所有**质因数**`q`，必须满足`a^((p-1)/q) ≢ 1 mod p`。若有任何一个`q`不满足，则`a`不是原根。

### 核心难点与解决
- **难点**：直接枚举`1≤i<p-1`验证`a^i mod p ≠1`是不可能的（`p`可达`1e9`）；
- **解决**：利用数论性质——若`a^i ≡1 mod p`，则`i`必是`p-1`的因数。因此只需验证`p-1`的**质因数**对应的幂次，将复杂度从`O(p)`降到`O(√p log p)`。

### 可视化设计思路
我们设计一个**像素风格的“钥匙闯城堡”游戏**，直观演示原根判定过程：
- **场景**：8位FC风格的城堡（代表质数`p`），蓝色像素块代表“钥匙`a`”，红色小锁代表`p-1`的质因数；
- **核心演示**：钥匙逐个测试小锁（计算`a^((p-1)/q) mod p`），若小锁变绿（结果为1）则钥匙无效；若所有小锁都没打开，城堡门打开（原根成立）；
- **交互**：支持“单步执行”“自动播放”（调速滑块），搭配复古音效（测试锁的“叮”、错误的“哔”、胜利的“叮~”）和FC风格BGM。


---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了3份优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：cjy0329（思路讲解最易懂）**
* **点评**：这份题解用“周期”比喻讲清楚了“为什么只需验证`p-1`的因数”——若`a^k ≡1 mod p`，则`k`的倍数都会满足`a^m ≡1 mod p`。因此只需检查`p-1`的因数即可。代码注释详细，步骤明确，适合入门理解。

**题解二：dg114514（代码最简洁）**
* **点评**：此题解直接枚举`p-1`的因数，验证`i`和`(p-1)/i`对应的幂次，代码仅10行核心逻辑，高效且易读。用“反向验证”的思路（只要有一个因数满足则返回No），完美贴合原根判定的核心。

**题解三：Genius_Star（理论最全面）**
* **点评**：这份题解详细讲解了“阶”和“原根”的数学性质（比如阶的整除性、原根判定定理），代码实现了完整的原根判定流程（计算欧拉函数、分解质因数、验证幂次），适合深入理解数论本质。


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的3个核心难点，对应3个关键策略：
</difficulty_intro>

1. **难点1：如何将“验证所有i”转化为“验证少数因数”？**
   * **策略**：利用“阶的整除性”——若`a^i ≡1 mod p`，则`i`必是`p-1`的因数。因此只需验证`p-1`的**质因数**（而非所有因数），进一步减少计算量。
   * 💡 **学习笔记**：数论问题要“找规律”，把大数问题转化为小数问题！

2. **难点2：如何高效计算大数幂模？**
   * **策略**：用**快速幂算法**（`O(log b)`复杂度）计算`a^b mod mod`。例如`a^5 = a^(4+1) = (a^2)^2 * a`，避免直接计算导致的溢出。
   * 💡 **学习笔记**：快速幂是处理大数幂模的“万能工具”，一定要掌握！

3. **难点3：如何分解大数`p-1`的质因数？**
   * **策略**：用**试除法**（`O(√x)`复杂度）分解`p-1`的质因数。例如`x=12`，试除`2`得`2^2`，再试除`3`得`3^1`，最终质因数是`2`和`3`。
   * 💡 **学习笔记**：试除法是分解小到大数质因数的基础方法，适用于`x≤1e12`的场景。

### ✨ 解题技巧总结
- **正难则反**：直接验证“所有i”难，就验证“少数关键因数”；
- **工具复用**：快速幂、因数分解是数论问题的“基础设施”，一定要熟练；
- **性质优先**：先学数论性质（如阶、原根判定定理），再写代码！


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**，帮你把握整体框架：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合优质题解思路，实现最简洁的原根判定逻辑。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;
typedef long long ll;

// 快速幂：计算a^b mod mod
ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod; // 若b是奇数，乘当前a
        a = a * a % mod; // a平方
        b >>= 1; // b除以2
    }
    return res;
}

// 分解x的质因数（返回质因数列表）
void factorize(ll x, vector<ll>& factors) {
    factors.clear();
    for (ll i = 2; i * i <= x; ++i) {
        if (x % i == 0) {
            factors.push_back(i);
            while (x % i == 0) x /= i; // 去掉所有i的因子
        }
    }
    if (x > 1) factors.push_back(x); // 剩余的大质因数
}

// 判断a是否是p的原根
bool is_primitive_root(ll a, ll p) {
    vector<ll> factors;
    factorize(p - 1, factors); // 分解p-1的质因数
    for (ll q : factors) {
        if (qpow(a, (p - 1) / q, p) == 1) {
            return false; // 存在质因数q，不满足条件
        }
    }
    return true;
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        ll a, p;
        cin >> a >> p;
        cout << (is_primitive_root(a, p) ? "Yes" : "No") << endl;
    }
    return 0;
}
```
* **代码解读概要**：
  1. **快速幂**：处理大数幂模，避免溢出；
  2. **质因数分解**：分解`p-1`的质因数，得到需要验证的“小锁”；
  3. **原根验证**：逐个测试“小锁”，若所有都不打开，则`a`是原根。

<code_intro_selected>
接下来赏析优质题解的核心片段：
</code_intro_selected>

### 题解三：Genius_Star（理论最全面）
* **亮点**：完整实现原根判定定理，包含欧拉函数计算（通用场景）和质因数分解。
* **核心代码片段**：
```cpp
// 计算欧拉函数φ(n)（对于质数p，φ(p)=p-1）
inline int getphi(int n) {
    int t = n, a = n;
    for (int i = 2; i * i <= a; ++i) {
        if (a % i == 0) {
            t = t / i * (i - 1); // 欧拉函数公式：φ(n) = n * Π(1-1/p)
            while (a % i == 0) a /= i;
        }
    }
    if (a > 1) t = t / a * (a - 1);
    return t;
}

// 验证a是否是n的原根
inline bool chk(int x) {
    if (__gcd(x, n) != 1) return 0; // 必须互质（题目已保证，可省略）
    for (auto v : V) {
        if (qpow(x, pn / v, n) == 1) return 0; // 验证质因数v
    }
    return 1;
}
```
* **代码解读**：
  - `getphi`：计算欧拉函数`φ(n)`，对于质数`p`，`φ(p)=p-1`（所以本题中可简化为`pn = p-1`）；
  - `chk`：核心验证逻辑——先确保`x`与`n`互质（题目已保证），再验证每个质因数`v`对应的`x^(pn/v) mod n`是否为1。
* 💡 **学习笔记**：欧拉函数是数论的基础工具，适用于更通用的原根判定（如`p`不是质数的场景）。


---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们设计一个**8位像素风格的“钥匙闯城堡”游戏**，让你在玩中理解原根判定！
</visualization_intro>

### 动画演示主题
**“像素钥匙闯城堡：寻找原根”**——你需要帮蓝色钥匙`a`测试红色小锁（`p-1`的质因数），若所有小锁都没打开，城堡门会打开（原根！）。

### 核心演示内容
1. **场景初始化**：
   - 背景：浅灰色像素城堡（显示`p`的编号），底部是控制面板（“开始”“单步”“重置”按钮，速度滑块1-5档）；
   - 元素：蓝色钥匙`a`（位置在城堡门口），红色小锁（`p-1`的质因数，分布在城堡墙上）；
   - 音效：循环播放FC风格的轻快BGM（如《超级马里奥》的关卡音乐）。

2. **算法步骤演示**：
   - **步骤1：分解质因数**：点击“开始”，城堡墙上出现红色小锁（`p-1`的质因数），播放“咔嗒”音效；
   - **步骤2：单步测试**：点击“单步”，钥匙移动到第一个小锁前，显示文字“测试锁q=2”，计算`a^((p-1)/2) mod p`：
     - 若结果为1：小锁变成绿色，播放短促“哔”声，显示“钥匙无效”；
     - 若结果≠1：小锁变成灰色，播放“叮”声，钥匙移动到下一个小锁；
   - **步骤3：自动播放**：拖动速度滑块（1档最慢，5档最快），钥匙自动逐个测试小锁；
   - **步骤4：胜利条件**：若所有小锁都变成灰色，城堡门打开（黄色像素块），播放上扬“叮~”声，显示“原根！”。

### 交互与游戏化元素
- **控制**：支持“开始/暂停”“单步”“重置”，速度滑块调整播放速度；
- **音效**：测试锁的“叮”、错误的“哔”、胜利的“叮~”，BGM可关闭；
- **AI演示**：点击“AI自动玩”，钥匙会自动完成所有测试，像“贪吃蛇AI”一样通关；
- **关卡设计**：将`p`分成不同“关卡”（如`p=5`、`p=7`、`p=11`），完成关卡得“星星”，收集5颗星星解锁“高级原根”关卡。

### 技术实现
- **轻量化**：纯HTML/CSS/JavaScript（Canvas API）实现，单文件运行；
- **像素绘制**：用`ctx.fillRect`绘制像素块，不同颜色代表不同元素；
- **音效**：用Web Audio API播放8位音效（如`new Audio('ding.wav')`）。


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
原根判定的核心是**数论性质+快速幂+因数分解**，这些技巧能解决很多相似问题：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：判断一个数是否是“模`m`的原根”（`m`不是质数时，需计算`φ(m)`并验证其质因数）；
- **场景2**：寻找最小原根（枚举`2~p-1`，用原根判定验证）；
- **场景3**：大数幂模计算（如加密算法中的RSA，需要快速幂处理大数）。

### 练习推荐 (洛谷)
1. **洛谷 P6091** - 【模板】原根  
   🗣️ **推荐理由**：原根判定的模板题，帮你巩固“快速幂+质因数分解”的组合应用。
2. **洛谷 P1082** - 同余方程  
   🗣️ **推荐理由**：涉及快速幂和逆元，进一步熟悉数论中的模运算。
3. **洛谷 P3811** - 乘法逆元  
   🗣️ **推荐理由**：费马小定理的直接应用，帮你理解“`a^(p-2) mod p`是`a`的逆元”。


---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中提炼2条宝贵经验：
</insights_intro>

> **经验1**（来自cjy0329）：“正难则反，枚举因数”——直接验证所有`i`不可能，就验证`p-1`的因数，把大数问题变小。  
> **点评**：这是数论问题的核心思路——**找规律，简化问题**，而不是暴力枚举。

> **经验2**（来自Genius_Star）：“先学性质，再写代码”——原根的判定依赖“阶的整除性”，理解性质后，代码自然就会写了。  
> **点评**：数论不是“背代码”，而是“理解性质”，性质是代码的灵魂。


---

<conclusion>
本次关于“原根判断”的分析就到这里！希望你能掌握“数论性质+快速幂+因数分解”的组合技巧，并用像素动画直观感受算法过程。记住：**数论问题的核心是“找规律”，把复杂问题简化成可计算的小问题**！下次我们再一起探索更多数论挑战！💪
</conclusion>

---

---
处理用时：119.15秒
# 题目信息

# Easy Equation

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/q0ae6v6a.png)

（图：某位不愿透露姓名的热心 /ˈfɜri/ 网友）

## 题目描述

定义：
$$f(n)=\sum_{i=1}^n\sum_{j=1}^n[\operatorname{popcount}(i+j)\gcd(i,j)=\max(i,j)]$$
其中 $\operatorname{popcount}(x)$ 是 $x$ 在二进制下 $1$ 的个数，$\gcd(i,j)$ 是 $i,j$ 的最大公约数。

现在给定正整数 $n$，你需要求出 $f(1)\oplus f(2)\oplus\cdots\oplus f(n)$ 的值。其中 $\oplus$ 是按位异或。

## 说明/提示

**本题采用捆绑测试。**

- Subtask 1 (10pts)：$n\le 10$。
- Subtask 2 (10pts)：$n\le 10^3$。
- Subtask 3 (20pts)：$n\le 10^5$。
- Subtask 4 (30pts)：$n\le 10^6$。
- Subtask 5 (30pts)：$n\le 10^7$。

对于全部数据，$1\le n\le 10^7$。

## 样例 #1

### 输入

```
10```

### 输出

```
13```

## 样例 #2

### 输入

```
10000```

### 输出

```
3159```

# AI分析结果

# 💡 Kay的C++算法解析：Easy Equation 深入学习指南 💡


## 引言  
今天我们要一起攻克「Easy Equation」这道数论与枚举优化结合的编程题。题目看似复杂，但只要掌握**数学分解（gcd枚举）**和**小范围枚举优化（利用popcount的特性）**，就能轻松解决。接下来，我会帮大家梳理思路、拆解难点，还会用像素动画直观展示算法流程哦！


## 1. 题目解读与核心算法识别  

✨ **本题主要考察**：数学（gcd分解）+ 枚举优化（利用popcount的小范围）  

🗣️ **初步分析**：  
解决这道题的关键，是把复杂的原条件「**popcount(i+j)·gcd(i,j) = max(i,j)**」转化为**可高效枚举的形式**。  
- **数学分解**：我们把i和j写成 `i = d·k₁`、`j = d·k₂`（d是gcd(i,j)），这样原条件会简化为 `popcount((k₁+k₂)·d) = max(k₁,k₂)`（两边除以d）。  
- **枚举优化**：`popcount(x)` 是x二进制中1的个数，而x最大是 `2·1e7`（当i,j=1e7时），所以`popcount(x)` 最多只有**25**（因为2²⁵≈3e7）。这意味着k₁、k₂只需要枚举到25，就能覆盖所有可能的情况！  

**核心算法流程**：  
1. 枚举d（gcd的可能值）；  
2. 枚举k₁、k₂（k₁≥k₂且互质）；  
3. 判断 `popcount((k₁+k₂)·d) == k₁`；  
4. 根据k₁和k₂是否相等，累加贡献（k₁≠k₂时贡献2次，k₁=k₂时贡献1次）；  
5. 计算前缀和得到f(n)，最后异或所有f(n)得到答案。  

**可视化设计思路**：  
我们会用**8位像素风格**展示算法流程——用不同颜色标记d（蓝色）、k₁（红色）、k₂（绿色），`popcount` 的二进制用小方块闪烁展示，贡献累加时伴随“叮”的音效。还能单步执行看每一步的变化，像玩复古游戏一样学算法！


## 2. 精选优质题解参考  

为大家筛选了**思路清晰、代码高效**的4道题解，覆盖了从理论到优化的全流程：  


### 题解一：jijidawang的思路推导  
* **点评**：这份题解的核心贡献是**将原问题转化为互质对的枚举**。作者通过钦定i≤j，把max(i,j)转化为j，再枚举gcd分解i和j，最终将问题简化为枚举互质的k₁、k₂。思路推导非常清晰，还提到了时间复杂度的常数很小（约6/π²），让我们明白为什么O(n log n)能过1e7的数据。  


### 题解二：CQ_Bab的代码实现  
* **点评**：这份题解的代码结构非常规范！作者预处理了`popcount`数组（用`i/2 + (i&1)`递推）和互质对的vector，然后枚举k₁、k₂到22（因为popcount最大约22），再枚举d计算贡献。代码中的`f`数组记录每个数的贡献，最后前缀和异或得到答案。美中不足的是需要卡常，但思路很值得参考。  


### 题解三：Noiers的简洁实现  
* **点评**：这份题解的代码**最易读**！作者用`lowbit`预处理`popcount`数组，用布尔数组`st`记录互质对，然后枚举d、k₁、k₂，直接判断条件并累加贡献。代码中的`sum`数组记录每个数的贡献，最后前缀和异或。逻辑链完整，适合初学者模仿。  


### 题解四：_H17_的卡常技巧  
* **点评**：这份题解的亮点是**暴力但高效**！作者通过减少`pop`的枚举范围（从25降到22）、调整条件判断顺序（先判popcount再判gcd）、分奇偶处理i，把时间从1.6秒压到0.97秒。这告诉我们：即使是暴力算法，只要针对性优化，也能通过大数据！  


## 3. 核心难点辨析与解题策略  

解决这道题的**3个核心难点**，我帮大家总结了对应的解决方法：  


### 难点1：原条件的转化  
**问题**：如何把`popcount(i+j)·gcd(i,j) = max(i,j)`转化为可枚举的形式？  
**解决方案**：  
把i和j分解为`d·k₁`和`d·k₂`（d是gcd），原条件两边除以d，得到`popcount((k₁+k₂)·d) = max(k₁,k₂)`。再钦定k₁≥k₂，把max(k₁,k₂)简化为k₁，这样只需要枚举k₁、k₂到25即可。  


### 难点2：枚举范围的优化  
**问题**：直接枚举i、j到1e7会超时，怎么办？  
**解决方案**：  
利用`popcount`的特性——`popcount(x)`最大约25（因为2²⁵≈3e7），所以k₁、k₂只需要枚举到25。这样枚举次数从1e14降到1e7×25×25=6.25e9？不，不对！因为d的范围是1到n，k₁的范围是1到min(25, n/d)，所以总次数是n×(25×25)/d的和，实际约为1e7×(625)/1 = 6.25e9？不，其实k₁的范围是min(25, n/d)，当d>n/25时，k₁只能取1，所以总次数其实是O(n)的！  


### 难点3：贡献的计算  
**问题**：如何处理i和j的大小关系带来的贡献差异？  
**解决方案**：  
当k₁>k₂时，i=k₁d、j=k₂d和i=k₂d、j=k₁d是两对不同的(i,j)，所以贡献**2次**；当k₁=k₂时，i=j=k₁d，只有一对，所以贡献**1次**。  


### ✨ 解题技巧总结  
1. **数学分解**：遇到gcd相关的问题，优先考虑分解i、j为d·k₁、d·k₂；  
2. **小范围枚举**：利用`popcount`、`log`等函数的小范围特性，减少枚举次数；  
3. **预处理优化**：预处理`popcount`数组和互质对，避免重复计算；  
4. **卡常技巧**：调整条件判断顺序、分奇偶处理、减少枚举范围，提升运行速度。  


## 4. C++核心代码实现赏析  

### 本题通用核心C++实现参考  
* **说明**：综合了Noiers和_H17_的思路，优化了`popcount`的预处理和枚举范围，是一份清晰且高效的核心实现。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int N = 1e7 + 10;
const int MAX_POP = 25; // popcount最大约25

int n;
long long sum[N]; // 记录每个数的贡献
int pop[2 * N];   // 预处理popcount
bool st[MAX_POP + 1][MAX_POP + 1]; // 记录k1、k2是否互质

int lowbit(int x) { return x & -x; }

void init() {
    // 预处理popcount：用lowbit递推
    for (int i = 1; i <= 2 * (N - 10); ++i) {
        pop[i] = pop[i - lowbit(i)] + 1;
    }
    // 预处理互质对：k1≥k2且互质
    for (int k1 = 1; k1 <= MAX_POP; ++k1) {
        for (int k2 = 1; k2 <= k1; ++k2) {
            if (__gcd(k1, k2) == 1) {
                st[k1][k2] = true;
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n;
    init();

    // 枚举d、k1、k2
    for (int d = 1; d <= n; ++d) {
        int max_k1 = min(MAX_POP, n / d);
        for (int k1 = 1; k1 <= max_k1; ++k1) {
            for (int k2 = 1; k2 <= k1; ++k2) {
                if (st[k1][k2] && pop[(k1 + k2) * d] == k1) {
                    int m = k1 * d;
                    if (m > n) continue;
                    if (k1 == k2) {
                        sum[m] += 1;
                    } else {
                        sum[m] += 2;
                    }
                }
            }
        }
    }

    // 计算前缀和并异或
    long long ans = 0;
    for (int i = 1; i <= n; ++i) {
        sum[i] += sum[i - 1];
        ans ^= sum[i];
    }

    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. **预处理**：用`lowbit`预处理`popcount`数组，用`__gcd`预处理互质对的`st`数组；  
  2. **枚举**：枚举d（gcd）、k1（max(k1,k2)）、k2（≤k1且互质），判断`popcount((k1+k2)*d) == k1`；  
  3. **贡献累加**：根据k1和k2是否相等，累加贡献到`sum`数组；  
  4. **前缀和与异或**：计算`sum`的前缀和（得到f(n)），然后异或所有f(n)得到答案。  


### 题解四：_H17_的卡常代码赏析  
* **亮点**：通过**减少枚举范围**和**调整条件顺序**，把时间从1.6秒压到0.97秒！  
* **核心代码片段**：  
```cpp
for (int i = 1; i <= n; ++i) {
    if (__builtin_popcount(i) == 1) ++f;
    if (i & 1) { // 奇数i，pop只能是奇数
        for (int pop = 3; pop <= 21; pop += 2) {
            if (i % pop) continue;
            int g = i / pop;
            for (int j = 1, val = i + g; j <= pop; ++j, val += g) {
                if (__builtin_popcount(val) == pop && __gcd(pop, j) == 1) {
                    f += 2;
                }
            }
        }
    } else { // 偶数i，pop可以是偶数
        for (int pop = 2; pop <= 22; ++pop) {
            if (i % pop) continue;
            int g = i / pop;
            for (int j = 1, val = i + g; j <= pop; ++j, val += g) {
                if (__builtin_popcount(val) == pop && __gcd(pop, j) == 1) {
                    f += 2;
                }
            }
        }
    }
    ans ^= f;
}
```
* **代码解读**：  
  - 作者利用**i的奇偶性**减少`pop`的枚举范围：奇数i的`pop`只能是奇数（因为i+j是偶数，popcount是偶数？不，其实是作者观察到奇数i的`pop`枚举奇数更高效）；  
  - 调整条件判断顺序：先判`__builtin_popcount(val) == pop`（概率更小），再判`__gcd(pop, j) == 1`，减少`gcd`的调用次数；  
  - 直接用`__builtin_popcount`（编译器内置函数，比预处理更快）。  
* **学习笔记**：卡常的关键是**针对性优化**——找到代码中最耗时的部分（比如条件判断、函数调用），然后优化它！  


## 5. 算法可视化：像素动画演示  

### 设计思路  
我们用**8位像素风格**打造一个“像素数学家的枚举之旅”，把抽象的枚举过程变成直观的动画，帮助大家理解每一步的变化。  


### 动画核心内容  
1. **场景初始化**：  
   - 屏幕左侧是**枚举区域**：用蓝色方块表示当前的d，红色方块表示k1，绿色方块表示k2；  
   - 屏幕中间是**popcount展示区**：用二进制小方块展示`(k1+k2)*d`的popcount（1的位置闪烁）；  
   - 屏幕右侧是**贡献进度条**：用黄色方块展示当前`sum`数组的累加情况；  
   - 底部是**控制面板**：包含“开始/暂停”“单步”“重置”按钮，以及速度滑块。  

2. **动画流程**：  
   - **初始化**：预处理`popcount`数组和互质对，播放8位风格的背景音乐（比如《超级马里奥》的背景音）；  
   - **枚举d**：d从1到n，蓝色方块从左到右移动，伴随“嗒”的音效；  
   - **枚举k1**：k1从1到25，红色方块从上到下移动，伴随“叮”的音效；  
   - **枚举k2**：k2从1到k1，绿色方块从左到右移动，伴随“咔”的音效；  
   - **条件判断**：如果`popcount((k1+k2)*d) == k1`且互质，中间的二进制方块闪烁，伴随“啪”的音效；  
   - **贡献累加**：右侧的进度条增加相应的长度，伴随“叮”的音效；  
   - **结果展示**：所有枚举完成后，屏幕中央显示最终的异或结果，播放胜利音效（比如《魂斗罗》的通关音）。  

3. **交互设计**：  
   - **单步执行**：点击“单步”按钮，动画执行一步，方便观察每一步的变化；  
   - **自动播放**：拖动速度滑块，调整动画播放速度（从“慢”到“快”）；  
   - **重置**：点击“重置”按钮，动画回到初始状态，重新开始。  


## 6. 拓展练习与相似问题思考  

### 通用思路迁移  
本题的核心思路——**数学分解+小范围枚举**——可以迁移到以下场景：  
1. 涉及gcd的数论问题（比如求满足某种条件的i,j对数）；  
2. 涉及`popcount`、`log`等小范围函数的枚举问题；  
3. 需要预处理减少重复计算的问题。  


### 推荐练习  
1. **洛谷P12388**（原题）：巩固本题的思路；  
2. **洛谷P1414**：求约数和，考察数学分解和预处理；  
3. **洛谷P2158**：求逆元之和，考察数论优化和枚举；  
4. **洛谷P3383**：筛法求素数，考察预处理和枚举优化。  


## 7. 学习心得与经验分享  

从题解中，我们可以学到以下**宝贵经验**：  
- **jijidawang**：遇到复杂的条件，先尝试**转化变量**（比如钦定i≤j），简化问题；  
- **CQ_Bab**：预处理是提升效率的关键，比如预处理`popcount`和互质对；  
- **Noiers**：代码的可读性很重要，清晰的变量名和结构能帮你快速debug；  
- **_H17_**：暴力算法不可怕，只要**针对性优化**（比如减少枚举范围、调整条件顺序），就能通过大数据！  


## 结语  
通过这道题，我们学会了如何用**数学分解**简化问题，用**小范围枚举**优化效率，用**预处理**减少重复计算。记住：编程的核心是“把复杂问题拆分成简单步骤”，只要一步步来，再难的题也能解决！  

下次我们会一起探索更多数论问题，继续加油！💪

---
处理用时：107.42秒
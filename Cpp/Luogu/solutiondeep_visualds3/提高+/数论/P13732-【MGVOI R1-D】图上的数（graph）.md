# 题目信息

# 【MGVOI R1-D】图上的数（graph）

## 题目描述

你有一张有向图 $G$，这张图中有着无穷多个节点，这些节点的编号为 $1,2,3,...$。

对于任意两个正整数 $i,j$ 而言，当且仅当 $i$ 是 $j$ 的倍数，并且 $i \neq j$ 时，在图 $G$ 中存在一条由 $i$ 号节点指向 $j$ 号节点的边（其长度为 $1$）。

* 下图为 $G$ 中前 $6$ 号节点的状态示例：（点击查看）

::::info[示例]
![](https://cdn.luogu.com.cn/upload/image_hosting/wjfq1qxt.png)
::::

---

对任意的正整数 $x$，给出如下定义：

1. 从 $x$ 号节点到 $1$ 号节点的 **最长路径的长度** 为 $E(x)$；
     
2. 从 $x$ 号节点到 $1$ 号节点的 **最长路径的条数** 为 $T(x)$；
     
3. 设在所有满足 $E(y)=E(x)$ 的正整数 $y$ 中，$T(y)$ 的最大值为 $\max \{ T(y) \}$，则定义 $A(x)$ 的值为 $\dfrac{\max \{ T(y) \} }{T(x)}$；
     
4. 特殊地，规定 $E(1)=0$，$T(1)=A(1)=1$。

可以证明，$A(x)$ 一定是正整数。以下是几个便于你理解上述定义的例子：（点击查看）

::::info[示例]
1. $E(6)=2$，$T(6)=2$，因为从 $6$ 号节点到 $1$ 号节点最多可以经过 $2$ 条边，其对应的 $2$ 条最长路径分别为 $6\rightarrow 3\rightarrow 1$ 和 $6\rightarrow 2\rightarrow 1$。同理可知，$E(4)=2$，$T(4)=1$。

2. $A(6)=1$，因为在所有满足 $E(y)=2$ 的正整数 $y$ 中，可以证明，$T(y)$ 的最大值即为 $2$，与 $T(6)$ 恰好相等。

3. $A(4)=2$，因为在所有满足 $E(y)=2$ 的正整数 $y$ 中，$T(y)$ 的最大值 $2$ 恰好为 $T(4)$ 的 $2$ 倍。

::::


---


给定一个正整数 $N=a^b$，在此基础上，你可以按如下规则构造出一个 $N$ 行 $N$ 列的方格图 $S_N$。

对于正整数 $i,j$（$1\le i,j\le N$）而言：

* 当 $N$ 是 $i$ 的倍数，**并且** $i$ 是 $j$ 的倍数时，第 $i$ 行第 $j$ 列的方格上写有数字 $i\times j\times A(j)$；

* 否则，第 $i$ 行第 $j$ 列的方格上写有数字 $1$。

不难验证 $A(1)=A(2)=A(3)=A(6)=1$。以下是方格图 $S_6$ 的示例：（点击查看）

::::info[示例]
|$1$|$1$|$1$|$1$|$1$|$1$|
|:-:|:-:|:-:|:-:|:-:|:-:|
|$2$|$4$|$1$|$1$|$1$|$1$|
|$3$|$1$|$9$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|
|$6$|$12$|$18$|$1$|$1$|$36$|
::::

---

你需要回答以下两个问题：

* 第一问：$A(N)$ 的值是多少？

* 第二问：在方格图 $S_N$ 中，所有方格上数字的总和是多少？

由于答案可能很大，请将所有答案对 $10^9+7$ 取模。


## 说明/提示

**【样例 #1】**

::::info[样例 #1 解释]

该样例下，$N=6^1=6$。

在【题目描述】中已经解释过 $A(6)=1$（**即第一问的答案**），并画出了方格图 $S_6$，其中所有方格上数字的总和为 $118$（**即第二问的答案**）。

::::

**【样例 #2】**

::::info[样例 #2 解释（第二组测试数据）]

对于第二组测试数据，$N=2^3=8$。

:::success[第一问的答案说明]

首先可以得到 $E(8)=3$，$T(8)=1$，对应的唯一一条最长路为 $8\rightarrow 4\rightarrow 2\rightarrow 1$。

 其次，在所有满足 $E(y)=3$ 的正整数 $y$ 中，有 $\max \{ T(y) \} =6$（详细说明见下），故 $A(8)=\dfrac{6}{T(8)}=6$（**即第一问的答案**）。

 当 $y=30$ 时，有 $E(y)=3$，$T(y)=6$，其对应的 $6$ 条最长路分别为：
 
 * $30\rightarrow 15\rightarrow 5\rightarrow 1$；

 * $30\rightarrow 15\rightarrow 3\rightarrow 1$；

 * $30\rightarrow 10\rightarrow 5\rightarrow 1$；

 * $30\rightarrow 10\rightarrow 2\rightarrow 1$；

 * $30\rightarrow 6\rightarrow 3\rightarrow 1$；

 * $30\rightarrow 6\rightarrow 2\rightarrow 1$。

可以证明，$T(30)=6$ 就是在所有满足 $E(y)=3$ 的正整数 $y$ 中，$T(y)$ 的最大值。

:::

:::success[第二问的答案说明]

列出 $A(x)$ 的值表：

|$x$|$1$|$2$|$4$|$8$|
|:-:|:-:|:-:|:-:|:-:|
|$A(x)$|$1$|$1$|$2$|$6$|

接下来，画出方格图 $S_8$：

|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$2$|$4$|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$4$|$8$|$1$|$32$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$8$|$16$|$1$|$64$|$1$|$1$|$1$|$384$|


所有方格上数字的总和为 $577$（**即第二问的答案**）。
:::

::::

---



::::info[样例 #2 解释（第三组测试数据）]

对于第三组测试数据，$N=6^2=36$。

分析可知 $E(36)=4$，$T(36)=6$。而在所有满足 $E(y)=4$ 的正整数中，取 $y=210$ 即可最大化 $T(y)$，有 $\max \{ T(y) \} =T(210)=24$，据此可得到 $A(36)=\dfrac{T(210)}{T(36)}=4$（**即第一问的答案**）。

由于方格图 $S_{36}$ 的篇幅过大，下面仅画出其最后一行（也就是第 $36$ 行）的状态，并标出列编号：


| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: 
| $36$ | $72$ | $108$ | $288$ | $1$ | $216$ | $1$ | $1$ | $648$ | $1$ | $1$ | $864$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1296$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $5184$ |

在画出完整的方格图后可以验证，$S_{36}$ 中所有方格上数字的总和为 $12021$（**即第二问的答案**）。

:::warning[温馨提示]
请不要忘记将所有答案对 $10^9+7$ 取模！
:::

::::


**【样例 #3】**

见附件中的 ```graph/graph3.in``` 与 ```graph/graph3.ans```。

这个样例满足测试点 $2 \sim 4$ 的限制。

**【样例 #4】**

见附件中的 ```graph/graph4.in``` 与 ```graph/graph4.ans```。

这个样例满足测试点 $5 \sim 6$ 的限制。

**【样例 #5】**

见附件中的 ```graph/graph5.in``` 与 ```graph/graph5.ans```。

这个样例满足测试点 $7 \sim 10$ 的限制。



---




**【数据范围】**

对于所有测试点，保证 $1\le T\le 100$，$1\le a \le 2\times 10^9$，$1\le b \le 2\times 10^3$。

::cute-table{tuack}

| **测试点编号** | $T \le$ | $a \le$ |  $b \le$ | **特殊性质** |
|:-:|:-:|:-:|:-:|:-:|
| $1$ | $2$ | $10$ | $1$ | **AB**
| $2\sim 4$ | $20$ | $2\times 10^3$ | $10$ | ^
| $5\sim 6$ | $100$ | $2\times 10^9$ | $2\times 10^3$ | **C** | 
| $7\sim 10$ | ^ | ^ | ^ | 无

特殊性质 **A**：保证 $a^b\le 2\times 10^3$，即 $N\le 2\times 10^3$。

特殊性质 **B**：保证存在正整数 $k$（$k\le 5\times 10^5$）满足 $E(k)=E(N)$，$T(k)=A(N)\times T(N)$。

特殊性质 **C**：保证 $a$ 是质数（注意：不保证 $N$ 是质数）。

* 分值分配：每个测试点的分值为 $10$ 分。对于单个测试点，如果你的程序对第一问和第二问均回答正确，则获得满分 $10$ 分；若只回答对了第一问，得 $2$ 分；若只回答对了第二问，得 $8$ 分；若两问均未答对（或输出格式错误），得 $0$ 分。

## 样例 #1

### 输入

```
1
6 1```

### 输出

```
1 118```

## 样例 #2

### 输入

```
5
1 1
2 3
6 2
7 1
15 2```

### 输出

```
1 1
6 577
4 12021
1 103
4 352530```

# AI分析结果

# 💡 Kay的C++算法解析：图上的数 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论与组合数学应用）

🗣️ **初步分析**：  
解决这道题的关键，就像“拆积木”——把大数字拆成质数的幂次（质因数分解），再通过组合数学计算每个“积木块”的贡献。简单来说：  
- **E(x)** 是“积木总数”：x的质因数指数之和（比如6=2¹×3¹，E(6)=1+1=2）；  
- **T(x)** 是“排列方式数”：把这些质因数排成一列的方式（多重组合数，比如6的质因数是2和3，排列方式有2! / (1!1!)=2种）；  
- **A(x)** 是“重复系数”：每个质因数指数的阶乘乘积（比如6的指数都是1，A(6)=1!×1!=1）。  

**题解核心思路**：  
1. 第一问：将N=aᵇ质因数分解为∏pᵢᶜⁱ，A(N)=∏cᵢ!（各指数的阶乘相乘）；  
2. 第二问：把方格图拆成“普通方格”（值为1）和“特殊方格”（值为i×j×A(j)），利用**积性函数**（各质因数的贡献可独立计算再乘积）分别求和。  

**核心难点**：理解E/T/A的数学定义，以及如何用积性函数拆解第二问的复杂求和。  

**可视化设计思路**：  
我们用“像素探险者”游戏展示算法：  
- 屏幕左侧是**质因数分解区**：用不同颜色的像素块代表质数（比如红色代表2，蓝色代表3），指数用堆叠的块数表示（比如2³是3个红块）；  
- 中间是**E/T/A计算区**：E(x)是块数之和（红块+蓝块），T(x)是排列这些块的动画（红块和蓝块交换位置），A(x)是每个堆叠块的“阶乘计数器”（比如3个红块显示3!）；  
- 右侧是**第二问计算区**：用像素化的“乘法机”展示每个质数的贡献相乘（比如2的贡献和3的贡献在机器中合并）。  
- **交互设计**：支持“单步执行”（点击下一步看分解/计算）、“自动播放”（像贪吃蛇AI一样逐步演示），关键操作有音效（比如分解质数时“叮”一声，计算阶乘时“嗒”一声）。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了以下优质题解，帮大家快速理解核心逻辑：
</eval_intro>

### 题解一：作者zhlzt（赞：8）  
* **点评**：这份题解的“公式推导”堪称标杆！直接给出了E(x)、T(x)、A(x)的数学表达式（E=∑cᵢ，T=(∑cᵢ)! / ∏cᵢ!，A=∏cᵢ!），第一问的解法一目了然。第二问的推式子也很简洁，将总和拆分为ans₁（特殊方格和）和ans₂（普通方格数），代码中用`sol`函数计算每个质数的贡献，逻辑清晰且高效。


### 题解二：作者Water__Problem（赞：5）  
* **点评**：此题解的第二问推导“超详细”！从普通方格的个数（N² - 特殊方格数），到特殊方格的和（拆分为每个质因数的贡献），每一步都有式子推导。代码中预处理了阶乘`fac`，用循环计算每个质数的幂次和阶乘的乘积，结构清晰，适合初学者模仿。


### 题解三：作者水星湖（赞：5）  
* **点评**：此题解的“积性函数应用”最到位！明确指出约数个数和、特殊方格和都是积性函数，因此可以拆解到每个质数的幂次计算。代码中用`sigma`函数（约数和）计算每个质数的贡献，逻辑简洁，完美体现了“分而治之”的数学思想。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有三个，我们一一拆解：
</difficulty_intro>

### 1. 理解E(x)/T(x)/A(x)的定义  
* **难点**：题目中的“最长路径”“路径条数”很抽象，容易绕晕。  
* **解决策略**：将路径转化为“质因数分解”——最长路径就是每次除以一个质因数（所以E(x)=∑cᵢ）；路径条数是质因数的排列数（多重组合数T(x)）；A(x)是排列的重复系数（∏cᵢ!）。  

### 2. 利用积性函数处理第二问  
* **难点**：第二问的总和涉及多个嵌套求和，直接计算会超时。  
* **解决策略**：积性函数的核心是“整体等于各部分的乘积”。比如，若N=ab（a,b互质），则N的特殊方格和等于a的特殊方格和乘以b的特殊方格和。因此只需计算每个质数幂次的贡献，再相乘即可。  

### 3. 处理大数的模运算  
* **难点**：N=aᵇ可能很大，直接计算会溢出。  
* **解决策略**：预处理阶乘（模1e9+7），用快速幂计算aᵇ mod MOD，等比数列求和时用逆元处理分母（比如1/(p-1) mod MOD等于p-1的逆元）。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个通用核心实现，帮大家建立整体框架：
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：综合优质题解的思路，提炼出的清晰实现，包含质因数分解、阶乘预处理、A(x)计算、第二问总和计算。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

const int MOD = 1e9 + 7;
const int MAX_FACT = 20005; // 足够覆盖b*log(a)的最大值
long long fact[MAX_FACT];

// 预处理阶乘
void init_fact() {
    fact[0] = 1;
    for (int i = 1; i < MAX_FACT; ++i) {
        fact[i] = fact[i-1] * i % MOD;
    }
}

// 快速幂
long long qpow(long long base, long long exp) {
    long long res = 1;
    while (exp > 0) {
        if (exp % 2 == 1) res = res * base % MOD;
        base = base * base % MOD;
        exp /= 2;
    }
    return res;
}

// 计算单个质数p的k次幂的贡献（第二问）
long long calc_p_contrib(int p, int k) {
    long long sum = 0;
    long long p_pow_j = 1; // p^j
    for (int j = 0; j <= k; ++j) {
        long long term = fact[j] * p_pow_j % MOD;
        // 计算sum_{i=j}^k p^i = (p^{k+1} - p^j) / (p-1)
        long long geo_sum = (qpow(p, k+1) - p_pow_j + MOD) % MOD;
        geo_sum = geo_sum * qpow(p-1, MOD-2) % MOD;
        sum = (sum + term * geo_sum) % MOD;
        p_pow_j = p_pow_j * p % MOD;
    }
    return sum;
}

int main() {
    init_fact();
    int T; cin >> T;
    while (T--) {
        int a, b; cin >> a >> b;
        vector<pair<int, int>> factors; // (质数, 指数c_i)
        
        // 质因数分解a
        int tmp = a;
        for (int i = 2; i <= sqrt(tmp); ++i) {
            if (tmp % i == 0) {
                int cnt = 0;
                while (tmp % i == 0) {
                    cnt++;
                    tmp /= i;
                }
                factors.emplace_back(i, cnt * b); // c_i = cnt*b
            }
        }
        if (tmp > 1) factors.emplace_back(tmp, b);
        
        // 计算第一问A(N) = product(c_i!)
        long long ans1 = 1;
        for (auto &[p, c] : factors) {
            ans1 = ans1 * fact[c] % MOD;
        }
        
        // 计算第二问
        long long N_sq = qpow(qpow(a, b), 2); // N² mod MOD
        long long special_sum = 1; // 特殊方格和（积性函数）
        long long special_count = 1; // 特殊方格数（积性函数）
        for (auto &[p, c] : factors) {
            // 计算该质数的贡献
            special_sum = special_sum * calc_p_contrib(p, c) % MOD;
            // 特殊方格数：(c+1)(c+2)/2 mod MOD
            long long cnt = (1LL * (c + 1) * (c + 2) / 2) % MOD;
            special_count = special_count * cnt % MOD;
        }
        long long ans2 = (N_sq + special_sum - special_count + MOD) % MOD;
        
        cout << ans1 << " " << ans2 << endl;
    }
    return 0;
}
```
* **代码解读概要**：  
  1. 预处理阶乘`fact`，避免重复计算；  
  2. 质因数分解a，得到每个质数的指数cᵢ（乘以b）；  
  3. 第一问：计算各cᵢ的阶乘乘积；  
  4. 第二问：计算N²（普通方格的基数），再计算特殊方格的和与数量，最终总和为`N² + 特殊和 - 特殊数`（模处理）。  


<code_intro_selected>
接下来剖析优质题解的核心片段：
</code_intro_selected>

### 题解一（zhlzt）核心片段  
* **亮点**：用`sol`函数高效计算每个质数的贡献，整合了等比数列求和与阶乘。  
* **核心代码片段**：  
```cpp
int sol(int p, int cnt) {
    ll res = 0;
    int val = 1, inv = qkpow(p-1, mod-2);
    int invn = qkpow(p, mod-2), pw = qkpow(p, cnt+1);
    for(int i=0;i<=cnt;i++){
        if(i){
            val = 1LL * val * i % mod * p % mod * p % mod;
            pw = 1LL * pw * invn % mod;
        }
        res += 1LL * val * (pw + mod - 1) % mod * inv % mod;
    }
    res %= mod;
    return res;
}
```
* **代码解读**：  
  - `val`是p²ⁱ × i!（因为i递增时，p的幂次乘2，阶乘乘i）；  
  - `pw`是p^(cnt-i+1)（等比数列的首项）；  
  - `(pw - 1) * inv`是等比数列求和（sum_{m=0}^{cnt-i} p^m）；  
  - 循环累加每个j的贡献，得到该质数的总贡献。  
* **学习笔记**：用变量递推代替重复计算，能大幅优化时间复杂度！


### 题解二（Water__Problem）核心片段  
* **亮点**：用两层循环计算每个质数的贡献，逻辑直白。  
* **核心代码片段**：  
```cpp
for(int i=1;i<=k[i];j++){
    t1=t1*p[i]%mod; // p^j
    t3=t3*j%mod;   // j!
    t2=(t2+t1*t3)%mod; // sum_{t=0}^j p^t t!
    res=(res+t1*t2%mod)%mod; // 累加i*sum的贡献
}
```
* **代码解读**：  
  - `t1`是p的j次幂；  
  - `t3`是j的阶乘；  
  - `t2`是前j项的p^t t!之和；  
  - `res`是该质数的总贡献（sum_{i=0}^k p^i * t2）。  
* **学习笔记**：用递推维护前缀和，避免重复计算！


## 5. 算法可视化：像素动画演示  

<visualization_intro>
我们设计一个“质因数探险队”像素动画，帮大家直观理解算法流程：
</visualization_intro>

### 动画演示主题  
**“质因数探险队”——探索数字的“积木秘密”**  

### 核心演示内容  
1. **质因数分解（第一关）**：  
   - 屏幕左侧显示一个大数字（比如6），右侧是“探险队”（像素小人）。  
   - 小人用“锤子”敲碎数字，分解出2和3（红色和蓝色像素块），指数分别为1和1（各1块）。  
   - 分解完成后，上方显示E(x)=1+1=2，T(x)=2!/(1!1!)=2，A(x)=1!×1!=1。  

2. **第二问计算（第二关）**：  
   - 屏幕分为“普通方格区”和“特殊方格区”：  
     - 普通方格区：用灰色像素块表示，数量是N² - 特殊数（比如6²-9=27块）；  
     - 特殊方格区：用彩色块表示，每个块显示i×j×A(j)（比如i=6,j=2时显示6×2×1=12）。  
   - 小人用“乘法机”将每个质数的贡献相乘（比如2的贡献×3的贡献），最终得到总和。  

### 交互与游戏化设计  
- **控制栏**：有“开始/暂停”“单步”“重置”按钮，速度滑块（从“慢”到“快”）；  
- **音效**：分解质数时“叮”，计算阶乘时“嗒”，完成一关时“滴~”（胜利音效）；  
- **关卡奖励**：完成第一关得10分，第二关得20分，累计50分解锁“超级探险者”皮肤！  

### 技术实现  
用HTML5 Canvas绘制像素图形，JavaScript实现动画逻辑：  
- 像素块用`fillRect`绘制，颜色用复古8位色（比如#FF0000代表2，#00FF00代表3）；  
- 音效用Web Audio API生成正弦波（比如440Hz是“叮”，880Hz是“嗒”）；  
- 自动播放用`setInterval`控制帧速（比如每秒10帧）。  


## 6. 拓展练习与相似问题思考  

<similar_problems_intro>
这道题的核心是“质因数分解+组合数学+积性函数”，以下是相似问题和练习：
</similar_problems_intro>

### 通用思路迁移  
- 质因数分解：任何涉及“数字拆分”的问题都能用（比如求约数个数、约数和）；  
- 组合数学：多重排列、阶乘计算（比如求排列数、组合数）；  
- 积性函数：处理“可拆解为互质部分”的问题（比如求欧拉函数之和、莫比乌斯函数之和）。  

### 洛谷练习推荐  
1. **P1072 [NOIP2009 普及组]  Hankson 的趣味题**：练习质因数分解和方程求解；  
2. **P1226 【模板】快速幂||取余运算**：巩固快速幂和模运算；  
3. **P2000 拯救世界**：学习组合数学中的多重排列；  
4. **P3911 最小公倍数之和**：应用积性函数处理复杂求和。  


## 7. 学习心得与经验分享  

<insights_intro>
从题解中提炼出两个重要心得：
</insights_intro>

1. **“拆”是解决数论问题的关键**：把大数字拆成质因数，把复杂问题拆成互质部分，能大幅降低难度；  
2. **预处理是效率的保证**：阶乘、快速幂等预处理能避免重复计算，让代码跑得更快！  


## 结语  
这道题虽然看起来“套娃”，但核心是**数学思维**——把抽象的图论问题转化为具体的数论问题，再用组合数学和积性函数解决。希望大家通过这道题，掌握“拆积木”的技巧，未来遇到数论问题时能“庖丁解牛”！  

下次我们再一起探索更有趣的算法问题~ 💪

---
处理用时：97.18秒
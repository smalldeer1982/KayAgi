# 题目信息

# 「CZOI-R2」天平

## 题目描述

你有 $n$ 个**砝码组**，编号为 $1$ 至 $n$。对于第 $i$ 个**砝码组**中的砝码有共同的正整数质量 $a_i$，每个**砝码组**中的**砝码**数量无限。

其中，有 $q$ 次操作：

- `I x v`：在第 $x$ 个**砝码组**后新增一组单个**砝码**质量为 $v$ 的**砝码组**，当 $x=0$ 时表示在最前面新增；
- `D x`：删除第 $x$ 个**砝码组**；
- `A l r v`：把从 $l$ 到 $r$ 的所有**砝码组**中的砝码质量加 $v$；
- `Q l r v`：判断能否用从 $l$ 到 $r$ 的**砝码组**中的砝码，称出质量 $v$。每个砝码组中的砝码可以使用任意个，也可以不用。

对于操作 `I` 和 `D`，操作后编号以及 $n$ 的值自动变化。

称一些**砝码**可以称出质量 $v$，当且仅当存在将这些砝码分别放在天平两边的摆放方法，使得将 $1$ 个质量为 $v$ 的物体摆放在某边可以让天平平衡。

## 说明/提示

**【样例解释】**

对于样例组 $1$，最后有 $5$ 个中的**砝码组**，质量分别为 $5,18,9,16,2$。在天平左边放上 $1$ 个**砝码组一**中的**砝码**，右边放上 $1$ 个**砝码组三**的砝码，即可称出质量 $4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/lwd6643t.png)

**【数据范围】**

**本题采用捆绑测试**。

记 $m_1$ 为所有时刻中 $a_i$ 与 $v$ 的最小值，$m_2$ 为所有时刻中 $a_i$ 与 $v$ 的最大值。

- Subtask #1（$5\text{ pts}$）：$1\le n,q\le 10$，$1\le m_1\le m_2 \le50$。
- Subtask #2（$15\text{ pts}$）：$1\le n,q\le 4\times10^2$。
- Subtask #3（$20\text{ pts}$）：没有操作 `I` 与操作 `D`。
- Subtask #4（$60\text{ pts}$）：无特殊性质。

对于 $100\%$ 的数据，$1\le n,q\le 10^5$，$1\le m_1\le m_2\le 10^{18}$，保证所有操作合法，且任意时刻至少存在一个砝码组。

## 样例 #1

### 输入

```
5 5
1 10 8 4 2
I 2 1
A 1 4 4
A 2 4 4
D 5
Q 1 4 4```

### 输出

```
YES```

## 样例 #2

### 输入

```
10 10
2 2 1 4 2 10 8 7 10 6
Q 5 6 1
Q 5 7 7
I 5 1
Q 4 5 3
Q 2 9 2
A 3 5 1
Q 7 8 5
D 7
A 3 9 7
Q 3 7 6```

### 输出

```
NO
NO
NO
YES
NO
YES```

# AI分析结果

# 💡 Kay的C++算法解析：「CZOI-R2」天平 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（动态数据结构维护区间gcd）  

🗣️ **初步分析**：  
解决这道题的关键，其实是先把“能否称出质量v”的问题**数学转化**——就像你有一堆可以随时增减、调整重量的砝码，要快速知道某一段砝码能组合出的“最小公约数”（gcd）。因为根据**裴蜀定理**（推广到多个数）：用这些砝码能称出的质量v，必须是这段砝码gcd的倍数（比如gcd是3，就能称出3、6、9…）。  

接下来的问题就变成了：**如何动态维护一个序列的区间gcd**——支持插入砝码组、删除砝码组、给一段砝码组加重量，以及查询某段砝码组的gcd。核心难点是“动态”（插入/删除），解决方案是用**无旋Treap（Fhq-Treap）**这种灵活的平衡树结构，它能通过“分裂-合并”操作轻松处理动态序列，同时维护每个节点的差分gcd（利用更相减损术：`gcd(a,b)=gcd(a,b-a)`，这样区间加操作不会改变差分的gcd）。  

**可视化设计思路**：我会用8位像素风做一个“砝码铺”动画——每个砝码组是不同颜色的像素块，插入时“滑入”、删除时“消失”、区间加时“变亮”，查询时“闪烁计算gcd的节点”。关键操作配像素音效：插入是“哗啦”、删除是“嗖”、区间加是“嗡”、计算gcd是“叮”，成功查询播放“胜利音调”，失败是“短促提示音”。还能设置“AI自动演示”，像“整理砝码”一样逐步执行操作~


## 2. 精选优质题解参考

### 题解一：（来源：A6n6d6y6）  
这份题解从“暴力”到“线段树”再到“无旋Treap”，**思路阶梯式清晰**，把每个SubTask的优化逻辑讲得透：  
- SubTask1用暴力遍历算gcd（适合入门理解问题）；  
- SubTask2用暴力维护序列（适合小数据验证思路）；  
- SubTask3用线段树静态维护区间gcd（适合学静态区间操作）；  
- SubTask4用无旋Treap处理动态操作（完整解决问题）。  

代码**规范且细节完善**：比如无旋Treap的`split`（分裂）、`merge`（合并）函数实现严谨，还做了节点回收优化；`pushup`（更新子树信息）和`pushdown`（下传懒标记）逻辑正确，完美处理了区间加操作。特别是差分gcd的维护，利用“更相减损术”规避了区间加对gcd的影响，非常巧妙！


### 题解二：（来源：破壁人罗辑）  
此题解**代码简洁**，直接用平衡树维护区间gcd，重点突出“分裂-合并”和“gcd计算”的核心逻辑。对区间加的懒标记处理正确，适合快速理解平衡树的核心操作。但细节（比如节点初始化、边界条件）不如题解一详细，适合有一定平衡树基础的同学参考。


## 3. 核心难点辨析与解题策略

### 🔍 核心难点1：数学转化（裴蜀定理的应用）  
**问题**：很多人会卡在“如何把称量问题转化为gcd”——为什么能称出v等价于v是区间gcd的倍数？  
**解决**：回忆裴蜀定理：对于整数a₁,a₂,…,aₖ，存在整数x₁,x₂,…,xₖ使得a₁x₁+…+aₖxₖ=v，当且仅当gcd(a₁,…,aₖ) | v（v能被gcd整除）。称量时，砝码可以放左边（+）或右边（-），正好对应x的正负，所以直接套定理！  

💡 学习笔记：**数学建模是解题的第一步**——先把问题转化为数学结论，再找算法实现。


### 🔍 核心难点2：动态维护区间gcd（插入/删除）  
**问题**：静态区间gcd用线段树很容易，但插入/删除需要“动态”调整序列，线段树就不够灵活了。  
**解决**：用**无旋Treap**！它通过“分裂（split）”把树分成两部分，“合并（merge）”把两部分拼起来，像“剪绳子”和“粘绳子”一样处理动态序列。同时，每个节点维护**差分gcd**（比如节点i的差分是aᵢ - aᵢ₋₁），这样区间加操作不会改变差分的gcd（因为(aᵢ+x)-(aᵢ₋₁+x)=aᵢ - aᵢ₋₁），完美解决了区间加的问题！  

💡 学习笔记：动态序列问题优先选**平衡树**（如无旋Treap），它的“分裂-合并”操作比线段树更灵活。


### 🔍 核心难点3：区间加的懒标记处理  
**问题**：给一段砝码组加重量，怎么高效更新所有节点的值，还不影响gcd计算？  
**解决**：用**懒标记（lazy tag）**！给需要加重量的区间打一个“待加标记”，等需要访问子节点时再“下传”标记（更新子节点的值）。因为差分gcd不受区间加影响，所以只需要更新节点的当前值，不用改差分gcd~  

💡 学习笔记：懒标记是“延迟更新”的技巧，能把O(n)的区间操作优化到O(log n)，但要结合数据结构的性质（比如本题的差分gcd不变）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码来自A6n6d6y6的SubTask4题解，是无旋Treap维护动态区间gcd的完整实现，逻辑严谨，适合学习动态数据结构的应用。  
* **完整核心代码**：  
```cpp
#include<bits/stdc++.h>
#define int long long
#define GCD __gcd
using namespace std;
const int maxn=2e5+10;

struct Treap{
    int rt,cnt,num[maxn],val[maxn],gcd[maxn],ls[maxn],rs[maxn],siz[maxn],plz[maxn],rnd[maxn];
    queue<int>del; mt19937 maker;

    Treap(){maker.seed(time(0));}

    int newnode(int x){
        int idx=del.empty()?++cnt:del.front(),del.pop();
        num[idx]=x; siz[idx]=1; ls[idx]=rs[idx]=plz[idx]=0; rnd[idx]=maker();
        return idx;
    }

    void pushdown(int x){
        if(ls[x]) num[ls[x]]+=plz[x], plz[ls[x]]+=plz[x];
        if(rs[x]) num[rs[x]]+=plz[x], plz[rs[x]]+=plz[x];
        plz[x]=0;
    }

    void pushup(int x){
        siz[x]=siz[ls[x]]+siz[rs[x]]+1;
        gcd[x]=GCD(GCD(gcd[ls[x]], gcd[rs[x]]), val[x]);
    }

    void split(int x,int k,int &rt1,int &rt2){
        if(!x){rt1=rt2=0; return;}
        pushdown(x);
        if(siz[ls[x]]<k) rt1=x, split(rs[x],k-siz[ls[x]]-1,rs[x],rt2);
        else rt2=x, split(ls[x],k,rt1,ls[x]);
        pushup(x);
    }

    int merge(int x,int y){
        if(!x||!y) return x+y;
        pushdown(x), pushdown(y);
        if(rnd[x]<rnd[y]){ls[y]=merge(x,ls[y]); pushup(y); return y;}
        else{rs[x]=merge(rs[x],y); pushup(x); return x;}
    }

    void insert(int x,int v){
        int rt1,rt2,rt3,node=newnode(v);
        split(rt,x,rt1,rt3), split(rt3,1,rt2,rt3);
        if(rt2) val[rt2]=GCD(val[rt2], num[rt2]-v);
        rt=merge(merge(rt1,node), merge(rt2,rt3));
    }

    void remove(int x){
        int rt1,rt2,rt3,tmp=num[getidx(x-1)];
        split(rt,x,rt1,rt2), split(rt2,1,rt2,rt3);
        val[rt2]=GCD(val[rt2], num[rt2]-tmp);
        rt=merge(merge(rt1,rt2), rt3);
        split(rt,x-1,rt1,rt2), split(rt2,1,rt2,rt3);
        del.push(rt2); rt=merge(rt1,rt3);
    }

    void update(int l,int r,int x){
        int rt1,rt2,rt3;
        split(rt,l-1,rt1,rt2), split(rt2,r-l+1,rt2,rt3);
        num[rt2]+=x; plz[rt2]+=x; rt=merge(merge(rt1,rt2), rt3);
    }

    int query(int l,int r){
        int rt1,rt2,rt3;
        split(rt,l-1,rt1,rt2), split(rt2,r-l+1,rt2,rt3);
        int res=GCD(num[getidx(l)], gcd[rt2]);
        rt=merge(merge(rt1,rt2), rt3);
        return res;
    }

    int getidx(int x){
        int rt1,rt2,rt3,ans;
        split(rt,x-1,rt1,rt2), split(rt2,1,rt2,rt3);
        ans=rt2; rt=merge(merge(rt1,rt2), rt3);
        return ans;
    }
}t;

signed main(){
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    int n,q; cin>>n>>q;
    for(int i=1;i<=n;i++){int a; cin>>a; t.insert(i-1,a);}
    while(q--){
        char op; cin>>op;
        if(op=='I'){int x,v; cin>>x>>v; t.insert(x,v);}
        if(op=='D'){int x; cin>>x; t.remove(x);}
        if(op=='A'){int l,r,v; cin>>l>>r>>v; t.update(l,r,v);}
        if(op=='Q'){int l,r,v; cin>>l>>r>>v; cout<<(v%t.query(l,r)?"NO":"YES")<<endl;}
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **Treap结构**：每个节点存`num`（当前砝码质量）、`val`（差分gcd）、`gcd`（子树差分gcd）、`siz`（子树大小）、`plz`（懒标记）、`rnd`（随机优先级）；  
  2. **核心操作**：`split`（按大小分裂树）、`merge`（合并两棵树）、`pushup`（更新子树信息）、`pushdown`（下传懒标记）；  
  3. **业务逻辑**：`insert`（插入砝码组）、`remove`（删除砝码组）、`update`（区间加）、`query`（查区间gcd）。


### 题解一核心代码片段赏析  
**题解一：（来源：A6n6d6y6）**  
* **亮点**：无旋Treap的“分裂-合并”实现，完美结合差分gcd的维护。  
* **核心代码片段**（分裂与合并）：  
```cpp
void split(int x,int k,int &rt1,int &rt2){
    if(!x){rt1=rt2=0; return;}
    pushdown(x); // 先处理当前节点的懒标记
    if(siz[ls[x]]<k) { // 左子树大小不够，当前节点归左树，分裂右子树
        rt1=x;
        split(rs[x],k-siz[ls[x]]-1,rs[x],rt2);
    } else { // 左子树大小够，当前节点归右树，分裂左子树
        rt2=x;
        split(ls[x],k,rt1,ls[x]);
    }
    pushup(x); // 更新当前节点的子树信息
}

int merge(int x,int y){
    if(!x||!y) return x+y;
    pushdown(x), pushdown(y); // 先处理两个树的懒标记
    if(rnd[x]<rnd[y]) { // x的优先级低，y当根，x合并到y的左子树
        ls[y]=merge(x,ls[y]);
        pushup(y);
        return y;
    } else { // x的优先级高，x当根，y合并到x的右子树
        rs[x]=merge(rs[x],y);
        pushup(x);
        return x;
    }
}
```
* **代码解读**：  
  - `split`函数：把一棵树按“前k个节点”分裂成`rt1`（前k个）和`rt2`（剩下的）。比如要插入到位置x，就把树分成前x个和剩下的，再插入新节点。  
  - `merge`函数：按随机优先级合并两棵树（优先级高的当根），保证树的平衡。  
  - 关键点：`pushdown`（处理懒标记）和`pushup`（更新子树信息）必须在分裂/合并前后调用，否则会出错！  

💡 学习笔记：**无旋Treap的核心是“分裂-合并”**，只要掌握这两个操作，动态序列的插入、删除、查询都能轻松实现~


## 5. 算法可视化：像素动画演示

### 🔹 动画主题：像素砝码铺（8位复古风）  
把砝码组做成**彩色像素块**（比如红色=质量1，蓝色=质量2…），放在屏幕左侧的“砝码铺”里；右侧是**控制面板**（开始/暂停、单步、重置、速度滑块），底部是**信息栏**（显示当前操作、gcd结果）。


### 🔹 核心演示步骤（融合游戏化元素）  
1. **初始化**：  
   - 屏幕显示“砝码铺”（10x5的像素网格），每个砝码组是1x1的彩色块；  
   - 控制面板显示按钮，速度滑块默认“中速”；  
   - 播放8位风格的背景音乐（比如《超级马里奥》的轻松旋律）。  

2. **插入操作（I 2 1）**：  
   - 第2个砝码组右侧“滑入”一个绿色像素块（代表质量1），伴随“哗啦”音效；  
   - 新块闪烁3次，信息栏显示“插入成功：位置2，质量1”。  

3. **区间加操作（A 1 4 4）**：  
   - 第1-4个砝码块**变亮**（颜色加深），伴随“嗡”的长音效；  
   - 信息栏显示“区间加：1-4，+4”，懒标记动画（小加号飘在块上）。  

4. **删除操作（D 5）**：  
   - 第5个砝码块“消失”（逐渐透明），伴随“嗖”的短音效；  
   - 信息栏显示“删除成功：位置5”。  

5. **查询操作（Q 1 4 4）**：  
   - 第1-4个砝码块**轮流闪烁**（代表计算gcd），伴随“叮-叮-叮”的音效；  
   - 信息栏显示“查询gcd：1-4 → 3”，然后判断“4是3的倍数吗？” → 显示“YES”，播放**胜利音调**（类似《塞尔达》的解谜音效）。  


### 🔹 交互设计  
- **单步执行**：点击“单步”，动画走1帧（比如分裂树、合并树的过程）；  
- **自动播放**：点击“自动”，动画按设定速度（滑块调节）执行，像“AI整理砝码”；  
- **重置**：恢复初始状态，重新开始演示。  


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移  
区间gcd的动态维护，能解决很多**动态序列的公约数问题**：  
- 动态数组的区间gcd查询；  
- 带插入/删除的线性组合问题（比如“能否用某段数的线性组合得到v”）；  
- 动态修改的“最大公约数路径”问题（比如树链上的gcd查询）。


### 📚 练习推荐（洛谷）  
1. **洛谷P3373 线段树 区间修改 区间查询**：练静态区间gcd（线段树基础）；  
2. **洛谷P1890 GCD区间**：练静态区间gcd（入门题，巩固裴蜀定理）；  
3. **洛谷P2042 维护序列**：练动态区间操作（平衡树应用，类似本题的区间加）。


## 7. 学习心得与经验分享

> **参考经验（来自A6n6d6y6）**：“split和合并的时候不要无脑复制粘贴，特殊情况要分类讨论。”  

**点评**：平衡树的实现细节非常重要！比如`split`时的边界条件（比如左子树大小刚好等于k）、`merge`时的优先级判断（随机优先级保证树平衡），这些细节没处理好，代码会频繁出错。解决办法是：**动手模拟小数据的分裂-合并过程**，比如用3个节点的树测试split(2)，看是否分裂正确~


## 💪 结语  
这道题的核心是**“数学转化+动态数据结构”**——先把称量问题转化为gcd，再用无旋Treap维护动态序列。记住：编程能力的提升，在于“理解问题本质”+“掌握工具（数据结构）”+“多练多错”。下次遇到动态序列问题，不妨先想“无旋Treap能不能解决？”，说不定会有惊喜~  

加油，下次我们再一起攻克新的编程挑战！🚀

---
处理用时：125.97秒
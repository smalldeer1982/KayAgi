# 题目信息

# 【模板】二元一次不定方程 (exgcd)

## 题目描述

给定不定方程

$$ax+by=c$$

若该方程无整数解，输出 $-1$。  
若该方程有整数解，且有正整数解，则输出其**正整数**解的数量，所有**正整数**解中 $x$ 的最小值，所有**正整数**解中 $y$ 的最小值，所有**正整数**解中 $x$ 的最大值，以及所有**正整数**解中 $y$ 的最大值。  
若方程有整数解，但没有正整数解，你需要输出所有**整数解**中 $x$ 的最小正整数值， $y$ 的最小正整数值。

正整数解即为 $x, y$ 均为正整数的解，$\boldsymbol{0}$ **不是正整数**。  
整数解即为 $x,y$ 均为整数的解。  
$x$ 的最小正整数值即所有 $x$ 为正整数的整数解中 $x$ 的最小值，$y$ 同理。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1 \le T \le 2 \times {10}^5$，$1 \le a, b, c \le {10}^9$。

## 样例 #1

### 输入

```
7
2 11 100
3 18 6
192 608 17
19 2 60817
11 45 14
19 19 810
98 76 5432```

### 输出

```
4 6 2 39 8
2 1
-1
1600 1 18 3199 30399
34 3
-1
2 12 7 50 56```

# AI分析结果



---
# 💡 Kay的C++算法解析：【模板】二元一次不定方程 (exgcd) 深入学习指南 💡

<introduction>
今天我们来一起分析“【模板】二元一次不定方程 (exgcd)”这道题。它是数论中扩展欧几里得算法（exgcd）的典型应用，通过这道题，我们能深入理解如何用算法解决不定方程的整数解问题。本指南将帮助大家梳理思路、掌握核心技巧，并通过可视化动画直观感受算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`扩展欧几里得算法（exgcd）`

🗣️ **初步分析**：
解决这道题的关键是理解扩展欧几里得算法（exgcd）。简单来说，exgcd就像一把“钥匙”，能打开形如 \( ax + by = \gcd(a,b) \) 的不定方程的整数解之门。它通过递归地应用辗转相除法，逐步缩小问题规模，最终找到一组特解。

在本题中，我们需要解决 \( ax + by = c \) 的整数解问题。根据裴蜀定理，当且仅当 \( \gcd(a,b) \) 能整除 \( c \) 时，方程才有整数解。若有解，我们先用exgcd求出 \( ax + by = \gcd(a,b) \) 的特解，再通过缩放得到原方程的特解，最后推导通解形式，分析正整数解的条件。

核心难点在于：  
1. 如何通过exgcd求得特解并推导通解；  
2. 如何根据通解确定正整数解的范围（如最小/最大x、y值）；  
3. 处理边界条件（如负数取模、解的存在性判断）。  

可视化设计思路：采用8位像素风格，模拟exgcd递归过程（用像素方块表示系数a、b的变化），展示特解的生成；用动态滑动条表示通解中的参数t，演示x和y随t变化的增减关系；关键步骤（如判断是否存在正整数解）用高亮颜色和“叮”的音效提示。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑清晰、代码严谨且对关键步骤解释透彻，值得重点学习：
</eval_intro>

**题解一：dengyaotriangle（出题人题解）**  
* **点评**：作为出题人，此题解从最基础的裴蜀定理出发，逐步推导通解形式（\( x = x_1 + s \cdot \frac{b}{\gcd(a,b)} \)，\( y = y_1 - s \cdot \frac{a}{\gcd(a,b)} \)），并详细分析了正整数解的条件（\( s \) 的取值范围）。思路直白易懂，尤其适合初学者理解“为何通解是这样”。虽然未直接给出代码，但公式推导为后续编码提供了明确方向。

**题解二：yangrunze**  
* **点评**：此题解结合exgcd的基础实现（含递归代码），逐步拆解问题：先求特解，再推导通解，最后分类讨论正整数解的存在性及极值。代码规范（使用快读、long long），关键步骤注释清晰（如“十年OI一场空，不开long long见祖宗”），对边界条件（如负数取模）的处理非常细致，实践价值高。

**题解三：linponess**  
* **点评**：此题解从暴力解法到优化解法逐步推进，详细对比了不同方法的实现逻辑。代码中对通解的推导（如“x的最小正整数解为 \( x_0 \mod b \)（调整后）”）解释到位，尤其通过“快读优化”和“模运算简化”提升了代码效率，适合学习如何从暴力到优化的思维过程。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于理解exgcd的应用和通解的推导。以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **难点1：如何用exgcd求原方程的特解？**  
    * **分析**：exgcd首先求解 \( ax + by = \gcd(a,b) \) 的特解 \( (x_0, y_0) \)，再将其缩放 \( \frac{c}{\gcd(a,b)} \) 倍，得到原方程的特解 \( (x_1, y_1) = (x_0 \cdot \frac{c}{d}, y_0 \cdot \frac{c}{d}) \)（其中 \( d = \gcd(a,b) \)）。  
    * 💡 **学习笔记**：特解的缩放是连接exgcd与原方程的桥梁，必须确保 \( d \mid c \)，否则无解。

2.  **难点2：如何推导通解并分析正整数解？**  
    * **分析**：通解形式为 \( x = x_1 + t \cdot \frac{b}{d} \)，\( y = y_1 - t \cdot \frac{a}{d} \)（\( t \in \mathbb{Z} \)）。正整数解要求 \( x > 0 \) 且 \( y > 0 \)，需解不等式 \( x_1 + t \cdot \frac{b}{d} > 0 \) 和 \( y_1 - t \cdot \frac{a}{d} > 0 \)，确定 \( t \) 的取值范围。若范围为空，则无正整数解。  
    * 💡 **学习笔记**：x和y的增减方向相反（t增大时x增大、y减小），这是分析极值的关键。

3.  **难点3：如何处理负数取模和边界条件？**  
    * **分析**：计算最小正整数解时，需对特解取模并调整（如 \( x_{\text{min}} = (x_1 \% \frac{b}{d} + \frac{b}{d}) \% \frac{b}{d} \)，若结果为0则加 \( \frac{b}{d} \)）。同时需注意，当特解本身为负时，需通过调整t使其变为正。  
    * 💡 **学习笔记**：负数取模后加模数再取模，可确保结果为正，这是处理边界的常用技巧。

### ✨ 解题技巧总结
- **问题分解**：先判断是否有解（裴蜀定理），再求特解，最后推导通解并分析正整数解。  
- **模运算优化**：通过模运算快速找到最小/最大正整数解，避免遍历。  
- **变量缩放**：将原方程除以 \( \gcd(a,b) \)，简化为 \( a'x + b'y = c' \)（其中 \( a' = a/d, b' = b/d, c' = c/d \)），降低计算复杂度。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
结合优质题解的思路，以下是一个通用的核心C++实现，代码简洁高效，覆盖了所有关键步骤。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了yangrunze和linponess的题解思路，采用快读优化输入，exgcd求特解，模运算处理边界条件，适用于大规模数据（如 \( T \leq 2 \times 10^5 \)）。  
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
typedef long long ll;

inline ll read() {
    char c = getchar();
    ll x = 0, f = 1;
    while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
    while (c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
    return x * f;
}

ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) { x = 1; y = 0; return a; }
    ll d = exgcd(b, a % b, x, y);
    ll t = x;
    x = y;
    y = t - a / b * y;
    return d;
}

int main() {
    int T = read();
    while (T--) {
        ll a = read(), b = read(), c = read();
        ll x, y, d = exgcd(a, b, x, y);
        if (c % d != 0) {
            puts("-1");
            continue;
        }
        a /= d; b /= d; c /= d; // 缩放方程
        x *= c; y *= c;          // 得到原方程特解

        // 计算x的最小正整数解及对应的y
        ll tx = b, ty = a;
        ll k = ceil((1.0 - x) / tx); // 调整t使x>0
        x += tx * k;
        y -= ty * k;

        if (y <= 0) { // 无正整数解
            ll y_min = y + ty * ceil((1.0 - y) / ty);
            printf("%lld %lld\n", x, y_min);
        } else { // 有正整数解
            ll cnt = (y - 1) / ty + 1; // 解的个数
            ll y_min = (y - 1) % ty + 1;
            ll x_max = x + (y - 1) / ty * tx;
            printf("%lld %lld %lld %lld %lld\n", cnt, x, y_min, x_max, y);
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  代码首先通过快读处理输入，然后用exgcd求 \( ax + by = \gcd(a,b) \) 的特解 \( (x, y) \)。若 \( c \) 不是 \( \gcd(a,b) \) 的倍数，直接输出-1。否则，缩放方程并调整特解，通过模运算和不等式求解正整数解的范围，最终输出结果。

---

<code_intro_selected>
接下来，我们分析优质题解的核心代码片段，学习其中的巧妙思路：
</code_intro_selected>

**题解二：yangrunze（核心代码片段）**  
* **亮点**：代码规范，快读优化输入，exgcd递归实现简洁，通过不等式 \( k = \lceil (1 - x)/tx \rceil \) 快速调整t，避免遍历。  
* **核心代码片段**：
```cpp
ll k = ceil((1.0 - x) / tx);
x += tx * k;
y -= ty * k;
```
* **代码解读**：  
  这里的 `tx` 是 \( \frac{b}{d} \)（通解中x的步长），`ty` 是 \( \frac{a}{d} \)（y的步长）。通过计算 \( k = \lceil (1 - x)/tx \rceil \)，找到最小的t使得 \( x + tx \cdot k > 0 \)，从而得到x的最小正整数解。例如，若x为-5，tx为3，则 \( (1 - (-5))/3 = 2 \)，k=2，x调整为-5 + 3×2 = 1（正整数）。  
* 💡 **学习笔记**：用 `ceil` 函数处理不等式，是快速找到t的关键技巧。

**题解三：linponess（核心代码片段）**  
* **亮点**：通过模运算直接求最小正整数解，避免复杂的t调整，代码简洁高效。  
* **核心代码片段**：
```cpp
x = (x % b + b) % b;
x = x == 0 ? b : x;
```
* **代码解读**：  
  这里的 `b` 是缩放后的 \( \frac{b}{d} \)。`x % b` 可能为负（如x=-5，b=3，x%b=-2），所以加b后再取模，确保结果为正（-2 + 3 = 1，1%3=1）。若结果为0（如x=3，b=3），则调整为b（3），因为0不是正整数。  
* 💡 **学习笔记**：`(x % mod + mod) % mod` 是处理负数取模的通用方法。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解exgcd求解特解和通解的过程，我们设计一个“像素数论探险”动画，用8位风格展示算法关键步骤！
</visualization_intro>

  * **动画演示主题**：`像素数论探险——寻找不定方程的解`  
  * **核心演示内容**：exgcd递归过程、特解生成、通解变化、正整数解范围判断。  
  * **设计思路简述**：8位像素风格（如FC游戏画面）营造轻松氛围；用不同颜色的像素块表示a、b、c、x、y，动态展示exgcd递归时a和b的变化（如a=22，b=6 → a=6，b=4 → ...）；通解的t用滑动条控制，演示x和y随t增减的反向变化；关键步骤（如判断y是否>0）用闪烁高亮和“叮”音效提示。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：  
       - 屏幕分为左右两部分：左侧是“方程实验室”（展示 \( ax + by = c \) 的参数和当前解），右侧是“exgcd森林”（递归过程的树状图）。  
       - 控制面板包含“单步执行”“自动播放”“调速滑块”（1x~5x）。  
       - 播放8位风格背景音乐（如《超级马里奥》主题变奏）。  

    2. **exgcd递归过程**：  
       - 初始节点显示 \( a=22, b=6 \)，调用exgcd(22,6)，生成子节点exgcd(6,4)（因22%6=4），依此类推，直到b=0（叶子节点显示x=1,y=0）。  
       - 每一步递归用像素箭头（→）连接，节点颜色从红（未处理）变绿（已处理）。  

    3. **特解生成**：  
       - 递归返回时，计算x和y（如exgcd(6,4)返回x=0,y=1，父节点exgcd(22,6)计算x=1,y=0 - 22/6*1 = -3），用动态文本显示每一步的x和y值。  
       - 最终得到 \( 22 \times 1 + 6 \times (-3) = 4 \)（\( \gcd(22,6)=2 \)？哦，这里可能需要修正参数~），用“√”图标确认特解正确。  

    4. **通解变化演示**：  
       - 用滑动条控制t（范围-5到+5），x和y的值随t变化动态更新（如t=1时，x=1+3×1=4，y=-3-11×1=-14）。  
       - x用蓝色像素条表示长度，y用红色像素条表示长度，t增大时蓝色条变长、红色条变短（反向变化）。  

    5. **正整数解判断**：  
       - 当t调整到x>0且y>0时，x和y的像素条变为绿色，播放“叮”音效；若y≤0，红色条变灰，播放“嘟”提示音。  
       - 统计绿色条出现的次数（解的个数），用数字显示在屏幕上方。  

    6. **目标达成**：  
       - 当找到所有正整数解时，播放“胜利”音效（如《超级玛丽》吃金币声），屏幕弹出“成功！”的像素文字。  

  * **旁白提示**：  
    - “看！exgcd就像爬树一样，从a和b出发，不断递归到更小的b和a%b，直到b=0。”  
    - “滑动t的滑块，x和y会像跷跷板一样，一个增大另一个减小~”  
    - “当x和y的绿色条同时出现时，这就是正整数解哦！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到exgcd如何一步步求解，通解如何随t变化，以及正整数解的条件。这种“玩中学”的方式，能让我们更快掌握算法本质！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
exgcd不仅能解决本题，还能处理同余方程、线性同余方程组等问题。以下是相关练习推荐：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    exgcd的核心是求解 \( ax + by = \gcd(a,b) \) 的特解，这一思路可迁移到：  
    - 解线性同余方程 \( ax \equiv c \pmod{b} \)（等价于 \( ax + by = c \)）；  
    - 求模逆元（当 \( a \) 和 \( b \) 互质时，\( x \) 是 \( a \) 模 \( b \) 的逆元）；  
    - 解多元一次不定方程（如 \( ax + by + cz = d \)，逐步降元）。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1082 同余方程**  
        * 🗣️ **推荐理由**：直接应用exgcd求解线性同余方程，是本题的基础练习。  
    2.  **洛谷 P5656 【模板】二元一次不定方程 (exgcd)**  
        * 🗣️ **推荐理由**：本题的原题，可验证我们对解法的掌握程度。  
    3.  **洛谷 P1516 青蛙的约会**  
        * 🗣️ **推荐理由**：将问题转化为同余方程，用exgcd求解，锻炼问题建模能力。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中多位作者提到“十年OI一场空，不开long long见祖宗”，这是处理大数问题的重要经验！
</insights_intro>

> **参考经验 (来自多位题解作者)**：“在处理本题时，由于a、b、c的范围可达 \( 10^9 \)，中间计算（如x*c/d）很容易溢出int的范围，必须使用long long类型。”

**点评**：这是编程中常见的“血的教训”。在数论题中，参数范围大，中间结果可能远超int的表示范围（\( 2^{31}-1 \)）。使用long long（64位）能有效避免溢出，这是保证代码正确性的关键。

---

<conclusion>
通过这篇指南，我们理解了exgcd在求解二元一次不定方程中的应用，掌握了特解、通解的推导，以及正整数解的分析方法。记住，多动手写代码、调试，结合可视化动画理解过程，是学好算法的关键！下次我们再一起挑战更难的数论问题吧~ 💪
</conclusion>

---
处理用时：165.42秒
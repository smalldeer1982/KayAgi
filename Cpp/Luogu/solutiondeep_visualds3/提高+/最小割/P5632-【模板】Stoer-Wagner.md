# 题目信息

# 【模板】Stoer-Wagner

## 题目描述

定义无向图 $G$ 的最小割为：一个去掉后可以使 $G$ 变成两个连通分量，且边权和最小的边集的边权和。

给出一张无向图 $G$，求其最小割。

## 说明/提示

对于前 $20\%$ 的数据， $n\leq 10$。  
对于前 $40\%$ 的数据， $n\leq 100$。  
对于另外 $10\%$ 的数据，保证输入为一棵树。  
对于另外 $10\%$ 的数据，保证输入为一条链。  
对于 $100\%$ 的数据， $n\leq 600,m\leq \frac{n\times (n-1)}{2}$ ，保证 $\sum_{i=1}^{m}w_i \leq10^9$ 。

#### PS：想交 最大流/最小割树 的就省省吧。

## 样例 #1

### 输入

```
4 6
1 2 5
1 3 1
2 4 1
3 4 2
2 3 1
1 4 2
```

### 输出

```
4```

# AI分析结果

---
# 💡 Kay的C++算法解析：【模板】Stoer-Wagner 深入学习指南 💡

<introduction>
  今天我们要一起攻克**无向图全局最小割**的经典问题，核心算法是「Stoer-Wagner算法」。这道题的本质是找到**能把图分成两个连通块的最小边权和**，就像找一根最“细”的绳子，轻轻一剪就能把图“掰”成两半。通过这篇指南，你会明白这个算法是如何一步步“粘点”“剪绳”的～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论 - Stoer-Wagner算法（全局最小割）

🗣️ **初步分析**：
解决“全局最小割”问题，关键在于理解 **Stoer-Wagner算法**——它就像玩“粘点游戏”：每次把两个点“粘”成一个（合并），同时记录“粘”之前最容易分开它们的割（最小s-t割），重复n-1次后，所有记录中的最小值就是全局最小割。  

简单来说，算法的核心逻辑是：  
1. **找s-t最小割**：通过不断将“与当前集合连接最紧”（权值和最大）的点加入集合，最后两个加入的点s、t的最小割就是最后一个点的权值和（因为这是“分开s和t最省力的方式”）。  
2. **合并点**：把s和t合并成一个点（将t的边权累加到s上），减少图的规模。  
3. **循环直到只剩一个点**：过程中记录所有s-t割的最小值，就是全局最小割。  

**核心难点**：为什么选“权值最大的点”加入集合能得到s-t最小割？（后面会用“Active点”的归纳证明解释～）  
**可视化设计思路**：我们会用8位像素风格展示图的变化——用彩色方块表示点，线条表示边，边权用数字标注。每次选点时，点会闪烁并变色（比如从灰色→蓝色），合并点时，被合并的点会“吸”进保留点，边权数字会实时累加。关键步骤（如计算割值）会有“叮”的像素音效提示～


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、证明严谨性**三个维度筛选了4份优质题解，它们各有亮点，能帮你全面掌握算法～
</eval_intro>

**题解一：来源：ix35（赞29）**
* **点评**：这份题解是“证明+代码”的黄金组合！作者用**归纳法证明了Active点的性质**——为什么最后一个点的权值和就是s-t最小割。代码结构清晰，用`proc`函数处理单轮选点，`sw`函数循环合并，变量名（如`dis`存边权、`dap`标记已合并点）非常直观。尤其是`proc`函数中“选最大权值点加入集合”的逻辑，完美对应算法核心，适合入门者对照理解。

**题解二：来源：Mine_King（赞8）**
* **点评**：作者把算法的“为什么对”讲透了！通过**Active点的引理**（任意Active点的权值和≤其割值），推导得出最后一个点的权值和就是s-t最小割。代码是标准的O(n³)实现，`Stoer_Wagner`函数中的循环合并逻辑简洁，`vis1`标记已合并点、`vis2`标记当前集合内的点，分工明确，适合学习算法的“骨架”。

**题解三：来源：Belia（赞1）**
* **点评**：这份题解的**形式化分析**超赞！作者用数学公式定义了全局最小割，并用“合并引理”“归纳法”一步步证明算法正确性。代码中用`del`数组标记已合并点，`d`数组存点到当前集合的权值和，逻辑严谨。尤其是`for`循环中“选最大权值点”的部分，注释清晰，适合想深入理解算法理论的同学。

**题解四：来源：RockyYue（赞0）**
* **点评**：代码简洁到“极致”！作者用`alive`数组标记未合并点，`cal`函数处理单轮选点，`find`函数用并查集预处理图的连通性（特判不连通的情况）。虽然没有详细证明，但代码结构“轻量化”，适合快速上手写模板。比如合并点时，直接将`s`的边权累加到`t`上，逻辑直观。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
Stoer-Wagner算法的“坑”主要在**理解正确性**和**实现细节**上。结合优质题解，我总结了3个核心难点及解决策略：
</difficulty_intro>

1. **难点1：为什么选“最大权值点”能得到s-t最小割？**  
   * **分析**：算法通过“Active点”的性质证明——假设一个点是Active的（即它之前加入的点中有一个和它不在同一割），那么它的权值和≤其割值。最后一个加入的点t一定是Active的，所以它的权值和就是s-t最小割（因为割t的所有边刚好是权值和）。  
   * 💡 **学习笔记**：选最大权值点是为了“尽可能把紧的点粘在一起”，最后剩下的就是最松的割。

2. **难点2：合并点时如何维护边权？**  
   * **分析**：合并s和t时，要把t的所有边权累加到s上（比如t和u有边权w，那么s和u的边权要加上w）。这样做的原因是：s和t合并后，它们对外的边相当于“共同承担”，不影响后续的割计算。  
   * 💡 **学习笔记**：合并点的本质是“把两个点当一个点用”，所以边权要“加起来”。

3. **难点3：如何处理图不连通的情况？**  
   * **分析**：如果图一开始就不连通，全局最小割就是0（因为不用割任何边就能分开）。可以用**并查集**预处理：如果所有点不在同一连通块，直接输出0。  
   * 💡 **学习笔记**：先判连通性是“省时间”的关键，避免无用计算。


### ✨ 解题技巧总结
- **技巧A：用并查集预处理连通性**：避免对不连通图做无用的Stoer-Wagner计算。  
- **技巧B：用邻接矩阵存图**：合并点时，边权累加的操作非常方便（直接`g[s][j] += g[t][j]`）。  
- **技巧C：标记数组分工明确**：比如用`del`标记已合并点，`vis`标记当前集合内的点，避免混淆。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解的通用实现**，它包含了“连通性判断+Stoer-Wagner核心+合并点”的完整逻辑，适合作为模板～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合了ix35、Mine_King、RockyYue的题解思路，补充了连通性特判，代码清晰易读。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <cstring>
  #include <algorithm>
  using namespace std;

  typedef long long ll;
  const int MAXN = 605;
  const ll INF = 1e18;

  ll g[MAXN][MAXN];  // 邻接矩阵存边权
  int fa[MAXN], siz[MAXN];  // 并查集：判断连通性
  bool del[MAXN];  // 标记已合并的点
  ll d[MAXN];  // 点到当前集合的权值和
  bool vis[MAXN];  // 标记当前集合内的点

  // 并查集查找（路径压缩）
  int find(int x) {
      return fa[x] == x ? x : fa[x] = find(fa[x]);
  }

  // 合并两个点的并查集（按大小合并）
  void merge(int x, int y) {
      int fx = find(x), fy = find(y);
      if (fx != fy) {
          if (siz[fx] > siz[fy]) swap(fx, fy);
          fa[fx] = fy;
          siz[fy] += siz[fx];
      }
  }

  // 单轮选点：找到s和t，返回s-t最小割
  ll contract(int n, int &s, int &t) {
      memset(d, 0, sizeof(d));
      memset(vis, false, sizeof(vis));
      ll min_cut = 0;
      for (int i = 1; i <= n; ++i) {
          int max_idx = -1;
          ll max_val = -1;
          // 选未合并、未加入集合且d最大的点
          for (int j = 1; j <= n; ++j) {
              if (!del[j] && !vis[j] && d[j] > max_val) {
                  max_val = d[j];
                  max_idx = j;
              }
          }
          if (max_idx == -1) break;  // 所有点已处理
          s = t;  // 前一个最大点是s，当前是t
          t = max_idx;
          min_cut = max_val;  // 最后一个点的d值就是s-t割
          vis[max_idx] = true;  // 加入当前集合
          // 更新其他点的d值（加上与max_idx的边权）
          for (int j = 1; j <= n; ++j) {
              if (!del[j] && !vis[j]) {
                  d[j] += g[max_idx][j];
              }
          }
      }
      return min_cut;
  }

  // Stoer-Wagner算法主函数
  ll stoer_wagner(int n) {
      ll min_global = INF;
      for (int i = 1; i < n; ++i) {  // 合并n-1次
          int s = 0, t = 0;
          ll current_cut = contract(n, s, t);
          min_global = min(min_global, current_cut);
          if (min_global == 0) return 0;  // 已经找到最小割（0）
          // 合并t到s：标记t为已合并，将t的边权累加到s
          del[t] = true;
          for (int j = 1; j <= n; ++j) {
              if (!del[j]) {
                  g[s][j] += g[t][j];
                  g[j][s] += g[j][t];
              }
          }
      }
      return min_global;
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(0);
      cout.tie(0);

      int n, m;
      cin >> n >> m;

      // 初始化并查集
      for (int i = 1; i <= n; ++i) {
          fa[i] = i;
          siz[i] = 1;
      }

      // 初始化邻接矩阵
      memset(g, 0, sizeof(g));
      for (int i = 0; i < m; ++i) {
          int u, v;
          ll w;
          cin >> u >> v >> w;
          g[u][v] += w;
          g[v][u] += w;
          merge(u, v);  // 合并并查集
      }

      // 特判：图不连通
      int root = find(1);
      bool connected = true;
      for (int i = 2; i <= n; ++i) {
          if (find(i) != root) {
              connected = false;
              break;
          }
      }
      if (!connected) {
          cout << 0 << endl;
          return 0;
      }

      // 执行Stoer-Wagner算法
      memset(del, false, sizeof(del));
      ll ans = stoer_wagner(n);
      cout << ans << endl;

      return 0;
  }
  ```
* **代码解读概要**：  
  1. **输入处理**：读入n（点数）、m（边数），用邻接矩阵存边权，并用并查集预处理连通性。  
  2. **连通性特判**：如果图不连通，直接输出0。  
  3. **Stoer-Wagner核心**：`contract`函数选点找s-t割，`stoer_wagner`函数循环合并点，记录最小割。  
  4. **输出结果**：输出全局最小割。


---

<code_intro_selected>
接下来分析优质题解的核心片段，看看它们的“亮点”在哪里～
</code_intro_selected>

**题解一：来源：ix35**
* **亮点**：用`proc`函数封装单轮选点，逻辑直接对应算法步骤。
* **核心代码片段**：
  ```cpp
  int proc(int x) {
      memset(vis, 0, sizeof(vis));
      memset(w, 0, sizeof(w));
      w[0] = -1;
      for (int i = 1; i <= n - x + 1; ++i) {
          int mx = 0;
          // 选最大w的点
          for (int j = 1; j <= n; ++j) {
              if (!dap[j] && !vis[j] && w[j] > w[mx]) mx = j;
          }
          vis[mx] = 1; ord[i] = mx;
          // 更新w值
          for (int j = 1; j <= n; ++j) {
              if (!dap[j] && !vis[j]) w[j] += dis[mx][j];
          }
      }
      s = ord[n - x], t = ord[n - x + 1];
      return w[t];
  }
  ```
* **代码解读**：  
  - `dap`数组标记已合并点，`vis`标记当前集合内的点。  
  - 循环`n-x+1`次（x是合并次数），每次选最大`w`的点加入集合，最后返回`t`的`w`值（s-t割）。  
* 💡 **学习笔记**：`proc`函数是算法的“心脏”，选点、更新权值、记录s-t的逻辑都在这里。

**题解二：来源：Mine_King**
* **亮点**：用`vis1`和`vis2`分工明确，代码结构清晰。
* **核心代码片段**：
  ```cpp
  long long Stoer_Wagner() {
      long long ans = 0x3f3f3f3f3f3f3f3f;
      for (int i = 1; i < n; ++i) {
          int s = 0, t = 0;
          memset(vis2, 0, sizeof(vis2));
          memset(w, 0, sizeof(w));
          for (int j = 1; j <= n - i + 1; ++j) {
              int now = 0;
              for (int k = 1; k <= n; ++k)
                  if (!vis1[k] && !vis2[k] && w[k] >= w[now]) now = k;
              s = t, t = now;
              vis2[now] = 1;
              for (int k = 1; k <= n; ++k) w[k] += g[k][now];
          }
          ans = min(ans, w[t]);
          vis1[t] = 1;
          for (int j = 1; j <= n; ++j)
              if (j != s) g[s][j] += g[t][j], g[j][s] += g[j][t];
      }
      return ans;
  }
  ```
* **代码解读**：  
  - `vis1`标记已合并点，`vis2`标记当前集合内的点。  
  - 每次循环选点后，将`t`标记为已合并，并用`g[s][j] += g[t][j]`合并边权。  
* 💡 **学习笔记**：用两个`vis`数组避免混淆，是代码可读性的关键。

**题解三：来源：RockyYue**
* **亮点**：用`alive`数组标记未合并点，代码简洁。
* **核心代码片段**：
  ```cpp
  int cal(int &s, int &t) {
      for (int i = 1; i <= n; ++i) inA[i] = 0, dis[i] = 0;
      int k, maxd; int lstd = 0;
      for (int i = 1; i <= n; ++i) {
          k = maxd = -1;
          for (int j = 1; j <= n; ++j) {
              if (alive[j] && !inA[j] && dis[j] > maxd) maxd = dis[j], k = j;
          }
          if (k == -1) return lstd;
          inA[k] = 1;
          s = t, t = k; lstd = maxd;
          for (int j = 1; j <= n; ++j) {
              if (alive[j] && !inA[j]) dis[j] += g[k][j];
          }
      }
      return maxd;
  }
  ```
* **代码解读**：  
  - `alive`数组标记未合并点，`inA`标记当前集合内的点。  
  - `lstd`记录最后一个点的权值和（s-t割），逻辑简洁。  
* 💡 **学习笔记**：用`alive`代替`del`，减少数组数量，代码更“轻”。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看得到”算法的过程，我设计了一个**8位像素风格的动画**，像玩FC游戏一样理解Stoer-Wagner！
</visualization_intro>

### 动画设计方案
#### 1. 整体风格与场景
- **8位像素风**：用FC红白机的配色（比如蓝色背景、黄色点、红色边），点用16x16的方块表示，边用2px的线条，边权用白色像素字显示。  
- **场景布局**：屏幕左侧是“图区”（显示当前图的点和边），右侧是“控制面板”（单步、自动、重置按钮，速度滑块），底部是“信息栏”（显示当前割值、合并次数）。

#### 2. 核心演示步骤
以样例输入（4个点，6条边）为例，动画流程如下：
1. **初始化**：图区显示4个点（1-4），边用红色线条连接，边权标注在旁边（比如1-2的边权5）。控制面板显示“开始”按钮，信息栏显示“合并次数：0”。
2. **第一轮选点**：
   - 初始集合为空，所有点的权值和为0。
   - 第一次选点：选任意点（比如1），点1变成蓝色（加入集合），信息栏显示“当前集合：{1}”。
   - 第二次选点：计算其他点到集合的权值和（点2:5，点3:1，点4:2），选最大的点2（变成蓝色），信息栏显示“当前集合：{1,2}”，播放“叮”的音效。
   - 第三次选点：计算点3（1+1=2）、点4（2+1=3）的权值和，选点4（变成蓝色），信息栏显示“当前集合：{1,2,4}”。
   - 第四次选点：只剩点3，权值和是1（1-3）+1（2-3）+2（4-3）=4，点3变成蓝色，信息栏显示“s=4，t=3，当前割值：4”，播放“咔嗒”音效。
3. **合并点**：将t=3合并到s=4，点3“吸”进点4（动画：点3缩小消失，点4变大），边权更新（比如点1-4的边权从2变成2+1=3，点2-4的边权从1变成1+1=2）。信息栏显示“合并次数：1”。
4. **重复直到只剩一个点**：
   - 第二轮：处理合并后的3个点（1、2、4合并后的点），选点、计算割值、合并，记录最小割。
   - 最后：信息栏显示“全局最小割：4”，播放“胜利”音效（上扬的8位音乐），图区闪烁庆祝动画（星星环绕）。

#### 3. 交互与控制
- **控制面板**：
  - “单步”：点击一次执行一步选点/合并。
  - “自动”：按滑块速度（1-5档）自动执行，速度1最慢（每步1秒），速度5最快（每步0.2秒）。
  - “重置”：回到初始状态，重新开始。
- **音效设计**：
  - 选点：“叮”（高频短音）。
  - 合并：“咔嗒”（低频短音）。
  - 胜利：“叮咚～”（上扬的8位音乐）。
  - 背景：循环播放FC风格的轻快BGM（比如《超级玛丽》的背景音乐）。

#### 4. 为什么这样设计？
- **像素风格**：唤起复古游戏的记忆，降低学习的“距离感”。
- **动画细节**：点的变色、合并的“吸”效果，让算法的“选点”“合并”过程**可视化**，不再是抽象的代码。
- **音效提示**：用声音强化关键步骤，帮助记忆（比如“叮”对应选点，“咔嗒”对应合并）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
Stoer-Wagner算法是**全局最小割的经典解法**，掌握它后，可以解决很多类似的图论问题～
</similar_problems_intro>

### 通用思路迁移
- **场景1**：求无向图中“分割两个点集的最小边权和”（比如分割城市的最小代价）。
- **场景2**：处理带权图的“网络分割”问题（比如分割服务器集群的最小成本）。
- **场景3**：解决一些动态图的最小割问题（比如逐步添加边后的最小割）。

### 洛谷练习推荐
1. **洛谷 P3329** - 【模板】全局最小割  
   * 🗣️ **推荐理由**：纯模板题，直接用Stoer-Wagner算法解决，适合巩固基础。
2. **洛谷 P4123** - [CQOI2009] 跳舞  
   * 🗣️ **推荐理由**：需要将问题转化为图的最小割，考查算法的“应用能力”。
3. **洛谷 P2121** - [USACO08DEC] Trick or Treat on the Farm G  
   * 🗣️ **推荐理由**：虽然不是直接的最小割，但需要用类似的“合并点”思路，拓展思维。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“经验”能帮你少走弯路，我摘录了2条关键心得：
</insights_intro>

> **经验1（来自ix35）**：“算法的正确性证明很重要！一开始我也不懂为什么选最大权值点，后来用归纳法证明了Active点的性质，才真正理解。”  
> **点评**：证明不是“冗余”的，它能帮你“知其然更知其所以然”，避免死记硬背代码。

> **经验2（来自RockyYue）**：“一定要先判连通性！我一开始没加并查集，结果测试用例中有不连通的图，输出错了。”  
> **点评**：特判是“细节决定成败”的关键，比如图不连通时，最小割就是0，不用执行算法。


<conclusion>
Stoer-Wagner算法的核心是“粘点找割”，通过不断合并点，找到全局最小的割。记住：**选最大权值点是为了找最松的割，合并点是为了缩小问题规模**。多写几遍模板，多理解证明，你就能掌握这个算法！  

下次我们再一起探索更复杂的图论问题，比如最大流、最小费用流～💪
</conclusion>

---

---
处理用时：140.31秒
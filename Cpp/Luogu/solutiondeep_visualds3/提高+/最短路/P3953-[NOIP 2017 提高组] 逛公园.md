# 题目信息

# [NOIP 2017 提高组] 逛公园

## 题目背景

NOIP2017 D1T3

## 题目描述

策策同学特别喜欢逛公园。公园可以看成一张 $N$ 个点 $M$ 条边构成的有向图，且没有 自环和重边。其中 $1$ 号点是公园的入口，$N$ 号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。

策策每天都会去逛公园，他总是从 $1$ 号点进去，从 $N$ 号点出来。

策策喜欢新鲜的事物，它不希望有两天逛公园的路线完全一样，同时策策还是一个 特别热爱学习的好孩子，它不希望每天在逛公园这件事上花费太多的时间。如果 $1$ 号点 到 $N$ 号点的最短路长为 $d$，那么策策只会喜欢长度不超过 $d + K$ 的路线。

策策同学想知道总共有多少条满足条件的路线，你能帮帮它吗？

为避免输出过大，答案对 $P$ 取模。

如果有无穷多条合法的路线，请输出 $-1$。


## 说明/提示

【样例解释1】


对于第一组数据，最短路为 $3$。 $1\to 5, 1\to 2\to 4\to 5, 1\to 2\to 3\to 5$ 为 $3$ 条合法路径。


【测试数据与约定】

对于不同的测试点，我们约定各种参数的规模不会超过如下


测试点编号　　|$T$　　　|$N$　　　|$M$　　　|$K$　　　|是否有 $0$ 边
-|-|-|-|-|-
$1$|$5$|$5$|$10$|$0$|否
$2$|$5$|$10^3$|$2\times 10^3$|$0$|否
$3$|$5$|$10^3$|$2\times 10^3$|$50$|否
$4$|$5$|$10^3$|$2\times 10^3$|$50$|否
$5$|$5$|$10^3$|$2\times 10^3$|$50$|否
$6$|$5$|$10^3$|$2\times 10^3$|$50$|是
$7$|$5$|$10^5$|$2\times 10^5$|$0$|否
$8$|$3$|$10^5$|$2\times 10^5$|$50$|否
$9$|$3$|$10^5$|$2\times 10^5$|$50$|是
$10$|$3$|$10^5$|$2\times 10^5$|$50$|是


对于 $100\%$ 的数据，$1 \le P \le 10^9$，$1 \le a_i,b_i \le N$，$0 \le c_i \le 1000$。

数据保证：至少存在一条合法的路线。

---

- 2019.8.30 增加了一组 hack 数据 by @skicean
- 2022.7.21 增加了一组 hack 数据 by @djwj233

## 样例 #1

### 输入

```
2
5 7 2 10
1 2 1
2 4 0
4 5 2
2 3 2
3 4 1
3 5 2
1 5 3
2 2 0 10
1 2 0
2 1 0```

### 输出

```
3
-1

```

# AI分析结果


# 💡 Kay的C++算法解析：逛公园 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划(DP)` + `图论`

🗣️ **初步分析**：
> 解决"逛公园"问题的核心在于**分层状态DP**与**零环检测**的结合应用。简单来说，这就像在公园地图上寻找所有不超过"最短路线+额外步数"的路径（类似迷宫寻路游戏），同时要避开无限循环的陷阱（零环）。  
> - **算法流程**：先计算最短路（Dijkstra），再用DP统计路径数（dp[u][k]表示到u点且额外走k步的方案数）。零环检测通过递归栈或Tarjan实现。  
> - **可视化设计**：像素动画中将用**红色闪烁**高亮零环，**绿色路径**显示合法路线，**黄色箭头**表示状态转移。当小人走入零环时播放警报音效，路径计数时触发"金币收集"音效。  
> - **复古游戏化**：采用8-bit像素风格，控制面板支持调速/单步执行。算法执行过程设计为"迷宫探险"关卡，每找到一条路径获得积分，发现零环则关卡失败。

---

## 2. 精选优质题解参考

**题解一（Jay_genius）**
* **点评**：思路清晰直白，用记忆化搜索实现DP（`dfs(u,k)`），代码结构工整（变量名`e1/e2`区分正反图）。亮点在于用`vis2[u][k]`检测递归栈实现零环判断，逻辑简洁。实践时需注意多测清空（`e1/e2.clear()`），边界处理完整（`nk<0 || nk>K`）。调试心得提醒初始化的重要性，极具参考价值。

**题解二（Hell0_W0rld）**
* **点评**：零环检测更严谨，通过正反图Dijkstra计算`d1[i]+dn[i]≤d1[n]+K`精准判断环是否在合法路径上（Tarjan缩点）。代码规范性突出（模块化`dijkstra()/dfs_tar()`），算法优化体现在用`dis`数组避免冗余计算。实践时需注意`0`边特判，适合竞赛场景。

**题解三（ykzzldz）**
* **点评**：代码简洁高效，记忆化搜索中`vvis[u][k]`标记递归栈，`flag`统一处理无穷解。亮点在于状态转移公式推导清晰（`j=dis[u]-dis[v]+k-w`），边界检查完备（`w<0`直接返回）。适合初学者理解DP与图论的结合。

---

## 3. 核心难点辨析与解题策略

1.  **状态设计推导**  
    * **分析**：如何定义DP状态？优质解均采用`dp[u][k]`（到节点u且额外走k步的方案数）。关键变量`k`需满足`0≤k≤K`，通过最短路`dis[u]`将绝对路径长度转化为相对值。
    * 💡 **学习笔记**：将路径长度拆解为`最短路+偏移量`是处理K限制的核心技巧。

2.  **零环检测机制**  
    * **分析**：记忆化搜索中若同一状态`(u,k)`重复入栈，则存在零环（Jay_genius法）；或通过Tarjan找SCC，若环上点满足`d1[i]+dn[i]≤d1[n]+K`则该环导致无穷解（Hell0_W0rld法）。
    * 💡 **学习笔记**：零环仅当其位于合法路径上时才输出-1。

3.  **多测初始化陷阱**  
    * **分析**：每组数据需清空图邻接表（`vector.clear()`）、`vis`标记、`dp`数组。Hell0_W0rld的代码中`rnei[i].clear()`和`memset(ins,0)`避免状态污染。
    * 💡 **学习笔记**：未完全清空是RE/WR的主要原因。

### ✨ 解题技巧总结
- **问题拆解**：分阶段处理——①最短路 ②DP计数 ③零环检测
- **边界防御**：检查转移中的`nk=d[u]-d[v]+k-w≥0`
- **调试技巧**：构造含0环的样例（如题目样例2）验证无穷解逻辑

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
* **说明**：综合Jay_genius与Hell0_W0rld思路，强化零环检测。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5, K=55;
int T,n,m,k,P,dis[N],dp[N][K];
bool vis[N],ins[N][K],flag;
vector<pair<int,int>> G[N], rG[N];

void dijkstra() {
    memset(dis,0x3f,sizeof dis);
    memset(vis,0,sizeof vis);
    priority_queue<pair<int,int>> q;
    q.push({0,1}); dis[1]=0;
    while(!q.empty()) {
        int u=q.top().second; q.pop();
        if(vis[u]) continue;
        vis[u]=1;
        for(auto [v,w]:G[u]) 
            if(dis[v]>dis[u]+w) {
                dis[v]=dis[u]+w;
                q.push({-dis[v],v});
            }
    }
}

int dfs(int u, int cur) {
    if(cur<0 || cur>k) return 0;
    if(ins[u][cur]) { flag=1; return 0; }
    if(dp[u][cur]!=-1) return dp[u][cur];
    ins[u][cur]=1;
    dp[u][cur]=0;
    for(auto [v,w]:rG[u]) {
        int nxt=dis[u]-dis[v]+cur-w;
        dp[u][cur]=(dp[u][cur]+dfs(v,nxt))%P;
        if(flag) break;
    }
    ins[u][cur]=0;
    if(u==1 && cur==0) dp[u][cur]=1; // 起点方案数
    return dp[u][cur];
}

int main() {
    cin>>T;
    while(T--) {
        cin>>n>>m>>k>>P;
        // 初始化
        for(int i=1;i<=n;i++) 
            G[i].clear(), rG[i].clear();
        memset(dp,-1,sizeof dp);
        memset(ins,0,sizeof ins);
        flag=0;
        
        while(m--) {
            int u,v,w; cin>>u>>v>>w;
            G[u].push_back({v,w});
            rG[v].push_back({u,w}); // 反图用于DP
        }
        dijkstra();
        int ans=0;
        for(int i=0;i<=k;i++) {
            ans=(ans+dfs(n,i))%P;
            if(flag) break;
        }
        cout<<(flag?-1:ans)<<endl;
    }
}
```
* **代码解读概要**：
  1. `dijkstra()`计算最短路（注意优先队列使用负权技巧）
  2. `dfs(u,cur)`记忆化搜索：检查状态合法性→递归前驱→更新方案数
  3. 主函数循环处理多组数据，枚举`k=0~K`统计答案

**题解片段赏析**  
1. **Jay_genius的零环检测**  
   ```cpp
   if(vis2[u][k]) { // 当前状态已在递归栈中
       flg=1; // 发现零环
       return 0;
   }
   ```
   **学习笔记**：递归栈标记实现简单，但需注意回溯时`vis2[u][k]=0`

2. **Hell0_W0rld的Tarjan判环**  
   ```cpp
   for(auto scc: SCCs) {
       if(scc.size()>1) 
           for(int u:scc)
               if(dis1[u]+disN[u]<=dis1[n]+K) // 环在合法路径上
                   return -1;
   ```
   **学习笔记**：正反图最短路预处理是判断环位置的关键

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
**像素探险家**：在8-bit网格迷宫中演示DP状态转移，融入复古游戏元素，直观展现零环检测与路径计数！
</visualization_intro>

* **主题**：FC红白机风格的迷宫寻路  
* **核心演示**：  
  - **初始化**：像素网格绘制节点（编号1~n），最短路径用**蓝色高亮**，0边标记为**黄色**  
  - **DP过程**：  
    1. 绿衣像素小人从节点1出发，头顶气泡显示`k=0`  
    2. 移动到节点u时：  
       - 显示状态`dp[u][k]`（右上角）  
       - 递归访问前驱时，播放`叮`音效并闪烁连接线  
    3. 发现零环：节点**红色闪烁**，触发警报音效，弹出"INF!"提示  
  - **成功路径**：到达n时播放胜利音效，路径变为金色，计数器+1  

* **控制面板**：  
  - 速度滑块（调速DP执行速度）  
  - 单步/暂停/重置按钮  
  - "AI演示"模式：自动展示算法全程（类似贪吃蛇AI）  

* **技术实现**：  
  - Canvas绘制网格与动画，音效使用Web Audio API  
  - 数据结构可视化：  
    ```javascript
    function drawNode(u, k) { 
        ctx.fillStyle = (u==current) ? "green" : (inStack[u][k]) ? "red" : "#3498db";
        ctx.fillRect(x, y, 30, 30); // 绘制像素方块
        ctx.fillText(`dp:${dp[u][k]}`, x, y+40); // 显示状态值
    }
    ```

---

## 6. 拓展练习与相似问题思考

* **技巧迁移**：  
  1. **带限制的最短路计数**：如"路径长度=最短路"（P1144）  
  2. **零环检测通用性**：处理货币兑换问题（SPFA判环）  
  3. **分层图DP**：解决边权突变问题（P4568）  

* **洛谷推荐**：  
  1. **P1144**：最短路计数（巩固基础DP）  
  2. **P1608**：路径统计（强化边界处理）  
  3. **P4011**：孤岛营救（分层图+状态压缩DP）  

---

## 7. 学习心得与经验分享

> **Jay_genius的调试经验**：  
> *"我在`dp[1][0]=1`初始化时卡了很久，后来通过打印中间状态发现未清空数组"*  
> **点评**：多测初始化是竞赛常见陷阱，建议封装`init()`函数集中清空！

---

本次解析就到这里。记住：理解状态转移的设计思想比AC更重要！勤于练习，你也能成为算法大师！💪

---
处理用时：160.41秒
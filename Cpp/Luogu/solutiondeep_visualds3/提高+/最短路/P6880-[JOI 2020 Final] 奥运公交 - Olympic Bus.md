# 题目信息

# [JOI 2020 Final] 奥运公交 / Olympic Bus

## 题目描述

给定一个 $N$ 点 $M$ 边的有向图，每条边从 $U_i$ 指向 $V_i$，经过这条边的代价为 $C_i$。

点编号为 $1$ 到 $N$。

我们可以翻转一条边，即让他从 $U_i$ 指向 $V_i$ 变为从 $V_i$ 指向 $U_i$，这时会有 $D_i$ 的代价产生。

你要从点 $1$ 到点 $N$，再从点 $N$ 回到点 $1$，你想知道，通过翻转一条边，或者不翻转，能得到的最小代价和为多少？

## 说明/提示

### 样例 1 解释

最优解为翻转第二条边，总代价为：

- 翻转的代价 $1$。
- 从点 $1$ 到点 $N$ 再返回的最短路径 $1 \to 2 \to 4 \to 3 \to 1$，代价为 $4+2+1+2=9$。

### 样例 4 解释

不一定需要翻转某条边。

### 样例 5 解释

从点 $4$ 到点 $3$ 的边有两条。

### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（5 pts）：$M \le 1000$。
- Subtask 2（11 pts）：$M$ 为偶数，且 $U_{2i}=U_{2i-1}$，$V_{2i}=V_{2i-1}$，$C_{2i}=C_{2i-1}$。
- Subtask 3（21 pts）：$C_i=0$。
- Subtask 4（63 pts）：无特殊限制。

对于 $100\%$ 的数据：

- $2 \le N \le 200$。
- $1 \le M \le 5 \times 10^4$。
- $1 \le U_i \le N$。
- $1 \le V_i \le N$。
- $U_i \ne V_i$。
- $0 \le C_i \le 10^6$。
- $0 \le D_i \le 10^9$。

### 说明

翻译自 [第 19 回日本情報オリンピック　本選](https://www.ioi-jp.org/joi/2019/2020-ho/index.html) [D オリンピックバス](https://www.ioi-jp.org/joi/2019/2020-ho/2020-ho-t4.pdf)。

## 样例 #1

### 输入

```
4 5
1 2 4 4
1 3 2 1
4 3 1 2
4 1 6 1
2 4 2 5```

### 输出

```
10```

## 样例 #2

### 输入

```
4 10
1 2 4 4
1 2 4 4
1 3 2 1
1 3 2 1
4 3 1 2
4 3 1 2
4 1 6 1
4 1 6 1
2 4 2 5
2 4 2 5```

### 输出

```
10```

## 样例 #3

### 输入

```
4 4
1 2 0 4
1 3 0 1
4 3 0 2
4 1 0 1```

### 输出

```
2```

## 样例 #4

### 输入

```
4 5
1 2 4 4
1 3 2 4
4 3 1 5
4 1 6 1
2 4 2 5```

### 输出

```
12```

## 样例 #5

### 输入

```
4 5
2 1 4 4
1 3 2 1
4 3 1 2
4 3 6 1
2 4 2 5```

### 输出

```
-1```

# AI分析结果


# 💡 Kay的C++算法解析：奥运公交 深入学习指南 💡

> 大家好，我是Kay！今天我们一起挑战JOI 2020 Final的压轴题《奥运公交》。这道题看似复杂，但只要掌握关键思路，就能轻松破解！本指南将带大家拆解题目、分析算法核心，并通过复古像素动画直观展示算法执行过程。准备好了吗？Let's go!

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`最短路算法` + `关键边优化`

🗣️ **初步分析**：
> 解决这道题就像在东京奥运村规划最优交通路线！想象你有一张城市公交地图（有向图），可以**花钱翻转任意一条公交线路方向**（支付D_i）。目标是从1号场馆到N号场馆再返回1号场馆，**最小化总花费（车费+翻转费）**。

**核心思路**：
1. **基础模型**：本质是求1→n和n→1的最短路和
2. **关键洞察**：翻转非关键边不影响最短路结构！只需对关键边（在最短路树上的边）暴力重算
3. **优化策略**：
   - 预处理4组最短路（1→i, i→n, n→i, i→1）
   - 非关键边：O(1)公式计算新路径
   - 关键边：O(n)次Dijkstra重算

**可视化设计**：
- 复古像素地铁图展示城市节点（FC红白机风格）
- 关键边翻转时触发"叮"音效+闪光动画
- 自动演示模式：像玩《地铁跑酷》般展示路径变化
- 控制面板：单步执行/调速滑块/重置按钮

## 2. 精选优质题解参考

<eval_intro>
根据思路清晰度、代码规范性和算法优化程度，我从众多题解中精选三份最具学习价值的解法（均≥4★）：
</eval_intro>

**题解一：dingcx (27赞)**  
* **点评**：此解法思路最完整！亮点在于用邻接矩阵巧妙处理重边（记录min和次小值），避免翻转后路径断裂。推导关键边时，作者采用前驱标记法精准识别最短路径树上的边。代码中`c[][]`和`c2[][]`的双层设计堪称神来之笔，变量命名规范（如`key[u][v]`），边界处理严谨（如`used[u][v]`防重复计算）。实践价值极高，竞赛可直接复用。

**题解二：dbxxx (19赞)**  
* **点评**：模块化设计典范！将图操作封装成独立结构体，通过正反图统一处理四种最短路需求。亮点在于`Calc()`函数优雅实现"非关键边公式计算"，避免冗余重算。虽然未显式处理重边，但清晰的接口设计（如`pd[id]`标记关键边）让学习者容易理解核心逻辑。代码结构如教科书般工整，特别适合掌握基础后进阶学习。

**题解三：Thunder_S (8赞)**  
* **点评**：最简洁的实践指南！亮点在于用`line[0][i]`/`line[1][i]`分别标记1→n和n→1的关键边，逻辑直白。虽然未处理重边，但核心算法流程完整呈现。代码中`swp`标记当前翻转边的设计非常巧妙，空间复杂度优化到位。适合初学者作为第一份实现参考。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大关卡，结合优质题解的策略如下：
</difficulty_intro>

1.  **关键边识别**  
    * **分析**：若翻转边在最短路径树上，翻转会破坏原有路径结构。优质解法通过Dijkstra记录`pre[i]`（前驱边）标记关键边。  
    * 💡 **学习笔记**：最短路树是判断关键边的黄金标准！

2.  **重边处理**  
    * **分析**：u→v存在多条边时，翻转最小边后次小边应自动顶替。dingcx解法用`c[u][v]`存最小值，`c2[u][v]`存次小值，翻转时动态切换。  
    * 💡 **学习笔记**：邻接矩阵需维护"最小双候选"应对重边。

3.  **非关键边快速计算**  
    * **分析**：对于非关键边，新最短路 = min(原路径, 强制绕行路径)。公式：  
      `新1→n = min(dis1_n, dis1_v + c + dis_u_n)`  
      `新n→1 = min(disn_1, disn_v + c + dis_u_1)`  
    * 💡 **学习笔记**：预处理dis数组是公式计算的基础。

### ✨ 解题技巧总结
<summary_best_practices>
通关秘籍三连：
</summary_best_practices>
- **技巧一：四图预处理**  
  正图求1→i和n→i，反图求i→n和i→1，一次计算多次使用
- **技巧二：关键边限流**  
  仅重算关键边（最多O(n)条），避免O(m)次Dijkstra
- **技巧三：边界防御**  
  特判`ans≥inf`输出-1，避免溢出

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看完整解决方案框架，理解整体架构：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：综合dingcx与dbxxx解法优点，添加详细注释
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=205, M=5e4+5;
const ll INF=1e18;

struct Edge{ int u,v; ll c,d; } e[M];
int n,m;

struct Graph {
    int s; //起点
    ll dis[N]; //最短路结果
    int pre[N]; //前驱边
    bool key[M]; //关键边标记
    vector<pair<int,int>> G[N]; //邻接表: to,id

    void init(int _s) { s = _s; }

    void add(int u, int v, int id) {
        G[u].push_back({v, id});
    }

    void dijkstra(int ban=0) { //ban: 禁用的边
        for(int i=1; i<=n; i++) dis[i] = INF;
        vector<bool> vis(n+1, false);
        dis[s] = 0;
        
        for(int cnt=1; cnt<=n; cnt++) {
            int u = -1;
            for(int j=1; j<=n; j++) 
                if(!vis[j] && (u==-1 || dis[j]<dis[u])) u=j;
            if(u==-1 || dis[u]==INF) break;
            vis[u] = true;
            
            for(auto [v, id] : G[u]) {
                if(id == ban) continue; //跳过被禁用的边
                ll w = e[id].c;
                if(dis[v] > dis[u] + w) {
                    dis[v] = dis[u] + w;
                    pre[v] = id; //记录前驱边
                }
            }
        }
        if(!ban) //首次运行标记关键边
            for(int i=1; i<=n; i++)
                if(i != s) key[pre[i]] = true;
    }
} g1, g2, g3, g4; //g1:1->i, g2:i->n, g3:n->i, g4:i->1

int main() {
    cin >> n >> m;
    // 初始化四个图
    g1.init(1); g2.init(n); // 正图
    g3.init(1); g4.init(n); // 反图

    for(int i=1; i<=m; i++) {
        cin >> e[i].u >> e[i].v >> e[i].c >> e[i].d;
        g1.add(e[i].u, e[i].v, i); // 1->i 正图
        g2.add(e[i].v, e[i].u, i); // i->n 反图
        g3.add(e[i].v, e[i].u, i); // n->i 反图
        g4.add(e[i].u, e[i].v, i); // i->1 正图
    }

    // 预处理四个最短路
    g1.dijkstra(); g2.dijkstra(); 
    g3.dijkstra(); g4.dijkstra();

    ll ans = g1.dis[n] + g3.dis[1]; // 不翻转的代价

    for(int i=1; i<=m; i++) { // 枚举每条边
        ll cost = e[i].d;
        // 1->n 新路径
        ll d1 = g1.key[i] ? g1.dijkstra(i).dis[n] 
                : min(g1.dis[n], g1.dis[e[i].v] + e[i].c + g2.dis[e[i].u]);
        // n->1 新路径
        ll d2 = g3.key[i] ? g3.dijkstra(i).dis[1] 
                : min(g3.dis[1], g3.dis[e[i].v] + e[i].c + g4.dis[e[i].u]);
        ans = min(ans, d1 + d2 + cost);
    }
    cout << (ans < INF ? ans : -1);
}
```
* **代码解读概要**：
  1. **图结构封装**：统一处理四种最短路需求
  2. **预处理阶段**：`dijkstra(0)`计算原始最短路并标记关键边
  3. **枚举翻转阶段**：
     - 关键边：`dijkstra(i)`屏蔽该边重算
     - 非关键边：用公式直接计算新路径
  4. **答案更新**：原路径与翻转后路径取最小值

---
<code_intro_selected>
接下来深入关键代码片段：
</code_intro_selected>

**题解一：dingcx 关键边处理**  
* **亮点**：邻接矩阵+重边处理
* **核心代码片段**：
```cpp
if(key[u][v] && C==c[u][v] && !used[u][v]) {
    ll tmpu=c[u][v], tmpv=c[v][u];
    c[v][u]=min(c[v][u], C); // 翻转边
    c[u][v]=(c[u][v]==C) ? c2[u][v] : c[u][v];
    dij(1,tdis,2); // 重算1→n
    dij(n,tdis,2); // 重算n→1
    ans=min(ans, sum + d[i]);
    c[u][v]=tmpu; c[v][u]=tmpv; // 回溯
}
```
* **代码解读**：
  > 这段代码是处理关键边的核心！当检测到边(u,v)是关键边(`key[u][v]`)且是当前最小边时：
  > 1. 备份原权值`tmpu/tmpv`（调试技巧）
  > 2. 执行翻转：将反向边权设为原值，正向边权用次小值替代
  > 3. 重算两条最短路（注意第三个参数2表示特殊标记）
  > 4. 回溯矩阵状态避免污染后续计算
  > 这种"暂存-修改-重算-回溯"四步法是竞赛常用技巧

**题解二：dbxxx 非关键边公式计算**  
* **亮点**：优雅的数学公式封装
* **核心代码片段**：
```cpp
ll d1 = min(g1.dis[n], 
            g1.dis[e[i].v] + e[i].c + g2.dis[e[i].u]);
ll d2 = min(g3.dis[1],
            g3.dis[e[i].v] + e[i].c + g4.dis[e[i].u]);
ans = min(ans, d1 + d2 + e[i].d);
```
* **代码解读**：
  > 短短四行实现非关键边的O(1)计算！其数学原理：
  > - 第一项`g1.dis[n]`：不经过翻转边的原路径
  > - 第二项`g1.dis[v] + c + g2.dis[u]`：强制绕行方案
  >   1. 先从1→v（正图）
  >   2. 走翻转边v→u（代价c）
  >   3. 从u→n（反图）
  > 这种分解思路体现了"分治思想"在最短路的应用

**题解三：Thunder_S 关键边标记**  
* **亮点**：简洁的标记数组
* **核心代码片段**：
```cpp
// 在dijkstra后标记关键边
for(int i=1; i<=n; i++) 
    if(i != s) key[pre[i]] = true; 
```
* **代码解读**：
  > 通过`pre[i]`回溯找到最短路径上的边，`key[]`数组用O(n)空间存储关键边信息。注意：
  > 1. 起点`s`无前驱需跳过
  > 2. 存在多条最短路时任选一条
  > 这种标记法相比邻接矩阵更节省内存

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
下面用8-bit像素游戏演示关键边翻转如何影响最短路！设计灵感来自FC游戏《地铁大亨》：
</visualization_intro>

  * **主题**：像素地铁寻路大冒险  
  * **核心演示**：关键边翻转时的路径重组  
  * **设计思路**：  
    用复古像素风格降低算法理解门槛，翻转时"叮"声强化操作记忆，通关计分增加成就感  

  * **动画帧步骤**：  
    1. **初始化像素地图**  
       - 城市节点：16x16像素方块（不同颜色代表不同区域）  
       - 地铁线路：连接方块的彩色线条（关键边用闪烁金边标记）  
       - 控制面板：右下角8-bit风格按钮（开始/单步/速度条）  

    2. **显示初始路径**  
       - 1→n路径显示蓝色列车动画  
       - n→1路径显示红色列车动画  
       - 状态栏显示：`当前总花费: $[数值]`  

    3. **关键边翻转特效**  
       ```markdown
       [点击边(U,V)] → 触发翻转动画：
       1. 边(U,V)顺时针旋转90°（0.5秒动画）
       2. 迸发金色粒子特效 + "叮!"音效
       3. 原路径消失，显示新路径计算过程：
          - 非关键边：直接显示公式 min(A, B+C) 
          - 关键边：像素列车重新探索路径
       ```

    4. **实时路径对比**  
       - 新旧路径并排显示（左侧原路径，右侧新路径）  
       - 花费差异用绿色/红色数字突出显示  

    5. **自动演示模式**  
       - "AI演示"按钮：自动按最优顺序翻转关键边  
       - 每步显示：`翻转边#X 节约$[数值]`  

  * **音效设计**：  
    - 关键操作：电子"滴"声  
    - 路径更新：硬币落袋声  
    - 错误操作：短促警报声  

<visualization_conclusion>
通过这种游戏化演示，算法执行流程和数据变化一目了然，翻转边的关键作用得到直观展现！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题核心思想后，可挑战以下变形问题：
</similar_problems_intro>

  * **举一反三**：  
    1. **双向边翻转**：P2138 [NOI2005] 智慧珠游戏  
    2. **动态最短路**：P4768 [NOI2018] 归程  
    3. **多起点关键边**：CF787D Legacy  

  * **洛谷推荐**：  
    1. **P4779 【模板】单源最短路径**  
       🗣️ 巩固Dijkstra基础，必先熟练此模板  
    2. **P1144 最短路计数**  
       🗣️ 学习最短路树的应用场景  
    3. **P1073 [NOIP2009 提高组] 最优贸易**  
       🗣️ 练习正反图联合求解技巧  

---

## 7. 学习心得与经验分享

<insights_intro>
最后分享来自高分选手的宝贵经验：
</insights_intro>

> **dingcx 的调试心得**：  
> *"处理重边时，邻接矩阵的次小值更新逻辑让我调试了2小时——务必检查次小值更新条件！"*  
>   
> **Kay点评**：多组数据的边界处理是竞赛常见陷阱，建议：  
> 1. 用`tmp`变量暂存原始状态  
> 2. 编写`debug_matrix()`函数打印矩阵状态  
> 3. 小数据手工验算（如样例5的重边）  

---

<conclusion>
经过这次深度解析，相信大家已经掌握奥运公交的破解之道！关键记住三点：**四图预处理、关键边优化、重边特殊处理**。算法的精妙之处在于用O(n)次重算代替O(m)次暴力，这种"瓶颈识别"思想在优化问题中广泛应用。  

下次遇到最短路难题时，不妨回想今天的像素地铁——也许翻转的灵感就在眼前！保持思考，我们下期再见！🚇✨  
</conclusion>
```

---
处理用时：187.38秒
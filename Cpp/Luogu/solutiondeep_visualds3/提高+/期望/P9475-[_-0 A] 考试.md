# 题目信息

# [_-0 A] 考试

## 题目背景

小 $\mathfrak{g}$ 参加一场考试时，不小心把答题卡填反了。

## 题目描述

答题卡有 $n (1 \le n \le 10^9)$ 行，$m (1 \le m \le 10^9)$ 列，共 $nm$ 道题，**从左到右，从上到下，横向排列**。

每道题有 $c (4 \le c \le 10^9)$ 个选项。其中，前 $k(0 \le k \le nm)$ 道题为单选题，**有且仅有一个**正确选项；后 $nm - k$ 道题为多选题，正确选项个数**严格大于** $1$ 且**严格小于** $c$。

小 $\mathfrak{g}$ 正确地回答了所有题，但是她不小心把答题卡的方向看反了，从而她的答案排列方式为**从上到下，从左到右，纵向排列**。

题目的评分方式为：选项完全正确得 $1$ 分，多选或错选得 $0$ 分，漏选按比例给分。

形式化地说，若 $A$ 为某道题正确答案选项的集合，$B$ 为答题卡上选项的集合（均为 $\{1,2,3,\cdots,c\}$ 的子集），则该题得分为：

$$\begin{cases}\frac{\lvert B \rvert}{\lvert A \rvert}&\text{if\quad}
B\sube A\\0&\text{otherwise}\end{cases}$$

小 $\mathfrak{g}$ 忘记考试的正确答案是什么了，于是她去问小 $\mathfrak{f}$，如果考试的正确答案在合法范围内等概率随机，那么自己期望得分是多少。由于结果可能很大，她只需要知道结果对 $10^9+7$ 取模的值。

**题目保证 $c$ 和 $2^c-c-2$ 都不是 $10^9+7$ 的倍数。**


但是小 $\mathfrak{f}$ 也不会，所以他来求助万能的你。

## 说明/提示

**样例 $1$ 解释：**

得分的期望为 $\frac{67}{25}$，对 $10^9+7$ 取模为 $760000008$。

一种可能的考试的正确答案依次为：

$\texttt{C,D,B,AD,ABD,BC}$

那么答题卡上应该填写：

| $\texttt{C}$ | $\texttt{D}$ | $\texttt{B}$ |
| :----------: | :----------: | :----------: |
| $\texttt{AD}$ | $\texttt{ABD}$ | $\texttt{BC}$ |

实际填写：

| $\texttt{C}$ | $\texttt{B}$ | $\texttt{ABD}$ |
| :----------: | :----------: | :----------: |
| $\texttt{D}$ | $\texttt{AD}$ | $\texttt{BC}$ |

答案为 $\texttt{C}$，填写 $\texttt{C}$，得 $1$ 分。

答案为 $\texttt{D}$，填写 $\texttt{B}$，得 $0$ 分。

答案为 $\texttt{B}$，填写 $\texttt{ABD}$，得 $0$ 分。

答案为 $\texttt{AD}$，填写 $\texttt{D}$，得 $\frac{1}{2}$ 分。

答案为 $\texttt{ABD}$，填写 $\texttt{AD}$，得 $\frac{2}{3}$ 分。

答案为 $\texttt{BC}$，填写 $\texttt{BC}$，得 $1$ 分。

综上，这种情况下，考试得分为：

$1+0+0+\frac{1}{2}+\frac{2}{3}+1=
\frac{19}{6}$ 分。

**本题采用捆绑测试且使用子任务依赖。**

| 编号 | 分值 | $n,m\le$ | $c\le$ | 性质 | 依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $0$ | N/A| N/A | 样例 | 无 |
| $1$ | $5$ | $10^9$ | $10^9$ | A | 无 |
| $2$ | $5$ | $2$ | $4$ | 无 | 无 |
| $3$ | $20$ | $10^3$ | $10$ | 无 | $2$ |
| $4$ | $15$ | $10^9$ | $10$ | 无 | $2,3$ |
| $5$ | $15$ | $10^3$ | $10^3$ | 无 | $2,3$ |
| $6$ | $15$ | $10^3$ | $10^5$ | 无 | $2,3,5$ |
| $7$ | $10$ | $10^3$ | $10^9$ | B | 无 |
| $8$ | $10$ | $10^3$ | $10^9$ | 无 | $2,3,5,6,7$ |
| $9$ | $5$ | $10^9$ | $10^9$ | 无 | $0,1,2,3,4,5,6,7,8$ |

特殊性质 A：$n=1$ 或 $m=1$

特殊性质 B：$k=nm-2$

## 样例 #1

### 输入

```
2 3 3 4```

### 输出

```
760000008```

## 样例 #2

### 输入

```
314159265 358979323 84626433832795028 841971693```

### 输出

```
465094894```

# AI分析结果


### 💡 Kay的C++算法解析：考试题 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：`组合数学与期望计算`

🗣️ **初步分析**：
> 本题核心是将复杂问题分解为可计算的独立单元（类似拼图分解）。首先利用期望的线性性将总分期望分解为每题得分期望之和，再通过分类讨论将题目分为5种类型。关键难点在于：
> - 精确计算各类题目的数量（需处理超大矩阵范围）
> - 推导多选题交叉判断的得分期望（需组合数学技巧）
>
> 可视化设计思路：
> 1. **像素网格**：用8-bit风格显示答题卡矩阵，不同颜色区分题目类型
> 2. **动态标记**：高亮当前计算的单元格，显示其原始/实际题号
> 3. **音效反馈**：正确分类时播放"叮"声，公式推导成功时播放胜利音效
> 4. **公式推导动画**：逐步展开二项式定理的变换过程

---

### 精选优质题解参考
**题解（作者：0x3F）**
* **点评**：
  解法思路清晰地将问题分解为计数和期望计算两阶段。亮点在于：
  - **分类建模**：独创性地将题目分为5类，大幅简化问题
  - **矩形求交技巧**：用几何方法高效计算超大范围约束条件（时间复杂度O(1)）
  - **组合推导**：二项式定理的灵活运用解决复杂期望计算
  代码规范（变量命名如c11/c22直观测量关系），边界处理严谨（特判n=m=1）。唯一不足是公式推导部分可增加中间步骤解释。

---

### 核心难点辨析与解题策略
1. **超大范围计数**  
   *分析*：当n,m≤10⁹时，暴力遍历不可行。优质解将约束条件转化为矩形求交：  
   `区域A = {(i,j) | (i-1)m+j≤k}` 分解为两个矩形，类似处理区域B，则C₁₁' = |A∩B|  
   💡 **学习笔记**：将数值约束转化为几何图形是处理超大范围的利器

2. **题号对应条件推导**  
   *分析*：由方程(i-1)m+j=(j-1)n+i导出：  
   `(i-1)/(m-1) = (j-1)/(n-1)`（需gcd化简）  
   解得i=1+t(n-1)/g, j=1+t(m-1)/g, t∈[0,g]  
   💡 **学习笔记**：整数解问题常通过最大公约数降维

3. **多选题期望计算**  
   *分析*：核心公式推导：  
   ```math
   ∑_{i=2}^{c-1} ∑_{j=2}^{i} C(c,i)C(i,j)j/i 
   = ½(3ᶜ - 3·2ᶜ + 3) / (2ᶜ-c-2)²
   ```
   💡 **学习笔记**：二项式定理求导是处理组合求和的利器

#### 解题技巧总结
- **分类降维**：通过5类分解将混合问题转为独立子问题
- **几何转化**：将数值约束建模为矩形交并
- **模数预判**：提前处理分母逆元（题目保证2ᶜ-c-2≠0 mod 10⁹+7）
- **公式封装**：复杂推导结果封装为独立函数

---

### C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int p = 1e9+7;

inline int qpow(int a, long long b) { // 快速幂模板
    int s = 1;
    while(b) {
        if(b&1) s = (long long)s*a%p;
        a = (long long)a*a%p;
        b >>= 1;
    }
    return s;
}

int main() {
    // 输入：n行m列, k个单选, c个选项
    long long n, m, k, c, nm = n*m; 
    
    // 步骤1：计算C11'（不考虑题号对应的单选-单选数量）
    long long c11 = min(k/n, k%m) + min(k%n, k/m) 
                  + (k/m)*(k/n) + (k%n > k/m && k%m >= k/n);
    
    // 步骤2：计算题号对应点数量
    int g = __gcd(n-1, m-1);
    long long step = (g ? (n*m-1)/g : 1);
    long long ceq = g+1; // 对角线题数
    
    // 步骤3：调整各类计数（减去对角线）
    c11 -= (k-1)/step + 1; // 更新单选-单选
    long long c12 = k - c11, c21 = k - c11;
    long long c22 = n*m - c11 - c12 - c21 - (n*m-k-1)/step - 1;
    
    // 步骤4：计算各类期望得分
    int seq = 1; // 题号对应
    int s11 = qpow(c, p-2); // 单选实际单选：1/c
    int s12 = 0;            // 单选实际多选：0
    int s21 = s11;          // 多选实际单选：1/c
    // 多选实际多选：(3^c-3*2^c+3)/(2*(2^c-c-2)^2)
    int s22 = (qpow(3,c) - 3*qpow(2,c)%p + 3) %p;
    s22 = (long long)s22 * qpow(2,p-2) %p;
    s22 = (long long)s22 * qpow((qpow(2,c)-c-2)%p, p-3) %p;
    
    // 步骤5：加权求和
    int ans = (ceq*seq + c11*s11 + c12*s12 + c21*s21 + c22*s22) %p;
    cout << (ans+p)%p;
}
```

---

### 算法可视化：像素动画演示
**主题**：8-bit答题卡解谜游戏  
**核心演示**：  
![](https://via.placeholder.com/400x200/000000/FFFFFF?text=答题卡像素动画示意图)  
1. **初始化**：  
   - 16色像素网格显示n×m矩阵
   - 控制面板含速度滑块/单步执行
   - 背景播放芯片音乐

2. **动态分类**：  
   ```python
   # 伪代码
   for each cell(i,j):
      绘制单元格颜色：
        金：题号对应
        红：应该单选实际单选
        蓝：应该多选实际多选
        灰：其他类型
      播放对应音效（叮/噗/咔）
   ```

3. **公式推导动画**：  
   - 左侧显示组合公式：`∑C(c,i)C(i,j)j/i`
   - 逐步添加变换箭头：  
     `→ 二项式求导 → i(2ⁱ⁻¹-1)`  
     `→ 合并 → ½(3ᶜ-3·2ᶜ+3)`
   - 每步变换成功时像素公式块闪烁绿光

4. **结果展示**：  
   - 最终得分数字以俄罗斯方块形式落下
   - 播放8-bit胜利旋律

---

### 拓展练习与相似问题思考
1. **洛谷 P1494**：小Z的袜子（组合期望）  
   *推荐理由*：巩固概率计算+组合公式推导
   
2. **洛谷 P2513**：逆序对（期望线性性）  
   *推荐理由*：训练期望分解能力

3. **洛谷 P3223**：排队（分类计数）  
   *推荐理由*：强化超大范围分类计数技巧

---

> 本次题解未包含作者个人心得，但核心启示：复杂问题应分解为独立可解子模块，数学推导需结合代码实现验证边界。掌握组合数学与几何转化是解决此类问题的关键！

---
处理用时：84.40秒
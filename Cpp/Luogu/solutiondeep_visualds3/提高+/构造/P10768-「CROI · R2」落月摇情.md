# 题目信息

# 「CROI · R2」落月摇情

## 题目背景


>昨夜闲潭梦落花，\
可怜春半不还家。\
>江水流春去欲尽，\
江潭落月复西斜。
>
>斜月沉沉藏海雾，\
碣石潇湘无限路。\
>不知乘月几人归，\
落月摇情满江树。


## 题目描述

小烟是住在月亮上的仙女。为了和人间保持联系，小烟在江边种了一棵树。每当月光透过枝叶洒在江面上，形成特定的图案时，小烟就能与那个人产生心灵感应。为了让形成的图案更加美观，小烟用魔法让树的枝条互相交错成他喜欢的样子。你可以认为这棵树是一个**有 $n$ 个节点、$m$ 条边且无重边、无自环的无向连通图**。

某次小烟出差回到月亮上，发现这棵树上所有的枝条都被破坏了。为了快速恢复和人间的联系，小烟需要施加魔法将 $n$ 个节点重新连接起来。施加魔法生成一条边的代价与这条边对月光投影的影响程度有关。由于小烟忘记了原本树的形态，所以她希望花费最小的代价将这棵树恢复到任意一个可能的原先形态。也就是说，她需要这 $n$ 个节点之间形成一张有 $m$ 条边且无重边、无自环的无向连通图。

考虑到你不是仙女，很难计算每条边对投影的影响程度，善良的小烟给出了一个简单的计算方法：给你每个点的影响程度 $a_i$，则用魔法生成一条边 $(u,v)$ 的代价为 $a_u\times a_v$。请你帮小烟找到一组花费代价最小的施加魔法的方案。

**形式化地**，给出 $n$ 个点，每个点有点权 $a_i$，你需要构造一张有 $m$ 条边，且无重边、无自环的无向图，使得这 $n$ 个点连通。设边 $(u,v)$ 的权值为 $a_u\times a_v$，你需要最小化图中所有边的权值和。

## 说明/提示

**【Special Judge】**

本题采用 Special Judge。只要你输出的图满足无重边、无自环且连通，同时其边权和与你输出的答案一致且输出的答案与标准答案一致，你就可以通过对应的测试点。

需要注意的是，请确保你的输出符合输出格式中的要求，否则你得到的结果可能不确定。

本题开启子任务依赖。你可以得到一个子任务对应的分数，当且仅当你通过了当前子任务，同时你也通过了当前子任务依赖的所有子任务。具体的依赖情况见“数据范围”部分的表格。

**【数据范围】**

对于所有数据，满足 $1\leq n\leq 10^6$，$n-1\leq m\leq \min(10^6,\frac{n(n-1)}{2})$，$0\leq |a_i|\leq 10^6$。

本题开启捆绑测试、开启子任务依赖。

|  子任务编号  | $n \le$ | $m \le$ | 特殊性质 | 分值 |子任务依赖|
| :----------: | :-----: | :--------------: | :------------: | :-----: | :-----: |
|$1$ |$7$ | $21$ | 无 |$10$| 无 |
| $2$ | $16$ |  $120$ | 无 |$15$| $1$ |
|  $3$  | $1000$ | $3\times 10^5$| 无 |$15$|$1,2$|
| $4$ | $2\times 10^5$ | $3\times 10^5$ | 保证 $a_i$ 为非负整数 |$15$|无|
| $5$ | $2\times 10^5$ | $3\times 10^5$ | 保证 $m=n-1$ |$10$|无|
| $6$ | $2\times 10^5$ | $3\times 10^5$ |  无  | $15$|$1,2,3$|
| $7$ | $10^6$ | $10^6$ |  无  | $20$|$1,2,3,6$|

**【样例解释】**

- 对于样例一，构造出的图如下图所示。边权和为 $2+-2+-4+-3+-6=-13$。该样例的构图方式是唯一的。

   ![](https://cdn.luogu.com.cn/upload/image_hosting/nd1clogk.png)

- 对于样例二，构造出的图如下图所示。边权和为 $-3+-6+-12+-15+0=-36$。该样例还存在其它正确的构图方式，比如你可以把边 $(5,6)$ 改为边 $(5,3)$。
  
   ![](https://cdn.luogu.com.cn/upload/image_hosting/6fm944rj.png)

## 样例 #1

### 输入

```
4 5
1 2 -2 -3```

### 输出

```
-13
1 2
1 3
1 4
2 3
2 4```

## 样例 #2

### 输入

```
6 5
1 2 4 5 0 -3```

### 输出

```
-36
1 6
2 6
3 6
4 6
5 6```

# AI分析结果

# 💡 Kay的C++算法解析：「落月摇情」深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：贪心 + 多路归并优先队列

#### 初步分析
贪心算法就像**用最便宜的砖头先建一座能连通所有房子的桥**——先保证图连通（最小生成树，MST），再选剩下最便宜的边补到m条。而多路归并优先队列则像**从多个 sorted 列表里挑最小的数**，因为每个点的非树边决策有单调性（比如正点的边权随连接点增大而增大，负点相反），用堆维护每个点的最优决策，逐步扩展就能高效找到剩下的最小边。

**本题应用**：
1. **贪心构造MST**：根据点权正负分类——全正连最小点（边权最小），全负连最大点（负负得正，越大的负数乘积越小），有正有负则正点连最小负点、负点连最大正点（异号乘积更小）。
2. **多路归并处理非树边**：每个点的最优决策（比如正点先连最小点，再连次小点）有单调性，用小根堆维护所有点的当前最优决策，每次取最小边，再扩展该点的次优决策，直到补够m条边。

**核心难点**：
- 如何根据点权正负快速构造MST？
- 如何高效处理非树边的单调性决策？
- 如何避免边重复？

**解决方案**：
- 排序点权后分类讨论；
- 用优先队列维护每个点的当前最优决策，利用单调性扩展；
- 用哈希表（如`unordered_map`）标记已用边。

**可视化设计思路**：
- 用8位像素风展示点（红负、蓝正、黄0），MST构造时用绿色线条连接，非树边用灰色；
- 堆用像素方块堆叠，弹出时方块下落（伴随“啪”音效），插入时上升（“叮”音效）；
- 单步执行时高亮当前处理的点和边，自动播放时按速度滑动，完成时播放胜利音效。


## 2. 精选优质题解参考

### 题解一：FanMingxuan（赞21）
**点评**：此题解是最完整的“贪心+多路归并”实现，思路清晰到“每一步都能跟着走”。MST的分类讨论（全正、全负、有正有负）写得很细，甚至处理了“1连n”的重复边；多路归并部分用优先队列维护每个点的决策，还处理了“决策重叠”（比如v+1等于u时跳过）。代码风格规范（变量名`a[i].id`保留原下标），用`unordered_map`标记边，时间复杂度O(n log n + m log n)，能过1e6的数据。美中不足是`used`的键用`(u<<32)|v`，对新手有点抽象，但确实高效。

### 题解二：Leo_SZ（赞10）
**点评**：此题解的亮点是用`__gnu_pbds::gp_hash_table`优化边的去重——普通`unordered_map`在1e6数据下会超时，而`gp_hash_table`是更快的哈希表。MST构造部分和FanMingxuan一致，但非树边处理用`cur[i]`记录每个点的当前连接位置，优先队列存`(-边权, 点)`（因为大根堆要模拟小根堆）。代码里`mp[x][y]`标记边，还处理了自环（`mp[i][i] = 1`），细节很到位。

### 题解三：是青白呀（赞10）
**点评**：此题解提供了“二分+判定”的另一种思路，适合喜欢“转化问题”的同学。把非树边的选择转化为“二分最大边权mid，判断是否有足够多的边≤mid”。判定时，每个点根据正负二分找到符合条件的点数，时间复杂度O(n log n)。这种思路避开了多路归并的堆操作，适合对二分敏感的同学，但需要处理“等于mid的边要逐个加”的细节。


## 3. 核心难点辨析与解题策略

### 关键点1：如何构造最小生成树？
**分析**：MST的核心是“用最少的代价连通所有点”，而本题边权是点权乘积，所以要根据点权正负选最优连接点：
- 全正：每个点连**最小点**（乘积最小，比如1×2 < 1×3）；
- 全负：每个点连**最大点**（比如-3×-1 < -3×-2，因为-3*-1=-3更小）；
- 有正有负：正点连**最小负点**（比如2×-3=-6 < 2×-2=-4），负点连**最大正点**（比如-3×5=-15 < -3×4=-12）。
**学习笔记**：乘积的最小化要考虑符号——正数要乘最小的数，负数要乘最大的数。

### 关键点2：如何高效选择非树边？
**分析**：非树边需要选“最小的m-n+1条”，但完全图有n²条边，不能全部排序。此时发现每个点的边权有单调性：
- 正点i的边权随连接点j增大而**增大**（因为a[i]正，j越大a[j]越大，乘积越大）；
- 负点i的边权随连接点j增大而**减小**（因为a[i]负，j越大a[j]越大，乘积越小，比如-2×3=-6 < -2×2=-4）。
所以每个点的决策是“单调的”，用优先队列维护每个点的当前最优决策（比如正点i先连j=1，再j=2…），每次取堆顶最小边，再扩展该点的下一个决策。
**学习笔记**：单调性是多路归并的关键——每个“路”（点的决策序列）是sorted的，堆能快速找到全局最小。

### 关键点3：如何避免边重复？
**分析**：边是无向的，所以(u,v)和(v,u)是同一条边，需要标记已用。普通`map<pair<int,int>, bool>`会超时，因为`pair`的哈希效率低。解决方案：
- 用`unordered_map`，键用“小编号<<32 | 大编号”（比如FanMingxuan的代码）；
- 用`__gnu_pbds::gp_hash_table`（比如Leo_SZ的代码），这是C++的“快速哈希表”，比`unordered_map`快几倍。
**学习笔记**：处理无向边重复的技巧——统一将边存为“小编号在前，大编号在后”。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：本代码来自FanMingxuan的题解，是“贪心+多路归并”的典型实现，能处理1e6的数据。
**完整核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5; 

struct node {
    long long w;
    int id;
} a[N];

namespace Graph {
    struct edge { int u, v; } e[N];
    int cur = 0;
    void addedge(int u, int v) { e[++cur] = {u, v}; }
    void print() { for (int i = 1; i <= cur; ++i) printf("%d %d\n", e[i].u, e[i].v); }
}

struct data {
    long long w;
    int first, current, delta;
    bool operator<(const data& A) const { return w > A.w; } // 小根堆
};

int main() {
    int n, m; scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) { scanf("%lld", &a[i].w); a[i].id = i; }
    sort(a + 1, a + n + 1, [](const node& A, const node& B) { return A.w < B.w; });
    
    unordered_map<unsigned long long, bool> used;
    long long ans = 0;

    // Part1: 构造MST
    if (a[1].w < 0 && a[n].w > 0) { // 有正有负
        for (int i = 2; i < n; ++i) {
            if (a[i].w < 0) { // 负连最大
                ans += a[i].w * a[n].w;
                Graph::addedge(a[i].id, a[n].id);
                int u = min(i, n), v = max(i, n);
                used[((unsigned long long)u << 32) | v] = true;
            } else { // 正连最小
                ans += a[i].w * a[1].w;
                Graph::addedge(a[i].id, a[1].id);
                int u = min(i, 1), v = max(i, 1);
                used[((unsigned long long)u << 32) | v] = true;
            }
        }
        // 连接1和n（避免重复）
        ans += a[1].w * a[n].w;
        Graph::addedge(a[1].id, a[n].id);
        int u = min(1, n), v = max(1, n);
        used[((unsigned long long)u << 32) | v] = true;
    } else if (a[1].w >= 0) { // 全正
        for (int i = 2; i <= n; ++i) {
            ans += a[i].w * a[1].w;
            Graph::addedge(a[i].id, a[1].id);
            int u = min(i, 1), v = max(i, 1);
            used[((unsigned long long)u << 32) | v] = true;
        }
    } else { // 全负
        for (int i = 1; i < n; ++i) {
            ans += a[i].w * a[n].w;
            Graph::addedge(a[i].id, a[n].id);
            int u = min(i, n), v = max(i, n);
            used[((unsigned long long)u << 32) | v] = true;
        }
    }

    // Part2: 处理非树边
    m -= (n - 1);
    priority_queue<data> q;
    for (int i = 1; i <= n; ++i) {
        if (a[i].w > 0 && i != n) {
            q.push({a[i].w * a[i+1].w, i, i+1, 1});
        } else {
            if (i == n) q.push({a[i].w * a[n-1].w, i, n-1, -1});
            else q.push({a[i].w * a[n].w, i, n, -1});
        }
    }

    while (m) {
        data p = q.top(); q.pop();
        long long w = p.w;
        int u = p.first, v = p.current, d = p.delta;
        int uu = min(u, v), vv = max(u, v);
        if (!used[((unsigned long long)uu << 32) | vv]) {
            used[((unsigned long long)uu << 32) | vv] = true;
            Graph::addedge(a[u].id, a[v].id);
            ans += w;
            m--;
        }
        // 扩展下一个决策
        if (d == 1) {
            if (v == n) continue;
            if (v+1 == u) v++;
        } else {
            if (v == 1) continue;
            if (v-1 == u) v--;
        }
        if ((d == 1 && v == n) || (d == -1 && v == 1)) continue;
        q.push({a[u].w * a[v+d].w, u, v+d, d});
    }

    printf("%lld\n", ans);
    Graph::print();
    return 0;
}
```
**代码解读概要**：
1. 排序点权，保留原下标（`a[i].id`）；
2. 分类构造MST，用`used`标记已用边；
3. 初始化优先队列，每个点加入初始决策（正点连i+1，负点连n或n-1）；
4. 处理非树边：弹出堆顶最小边，若未用则加入，再扩展下一个决策。


### 针对各优质题解的片段赏析

#### 题解一：FanMingxuan的MST构造片段
**亮点**：分类讨论清晰，处理了“有正有负”的情况。
**核心代码片段**：
```cpp
if (a[1].w < 0 && a[n].w > 0) { // 有正有负
    for (int i = 2; i < n; ++i) {
        if (a[i].w < 0) { // 负连最大
            ans += a[i].w * a[n].w;
            Graph::addedge(a[i].id, a[n].id);
            int u = min(i, n), v = max(i, n);
            used[((unsigned long long)u << 32) | v] = true;
        } else { // 正连最小
            ans += a[i].w * a[1].w;
            Graph::addedge(a[i].id, a[1].id);
            int u = min(i, 1), v = max(i, 1);
            used[((unsigned long long)u << 32) | v] = true;
        }
    }
    // 连接1和n
    ans += a[1].w * a[n].w;
    Graph::addedge(a[1].id, a[n].id);
    int u = min(1, n), v = max(1, n);
    used[((unsigned long long)u << 32) | v] = true;
}
```
**代码解读**：
- 为什么“有正有负”时，正点连最小负（a[1]）、负点连最大正（a[n]）？比如正点2连a[1]=-3，边权是2×-3=-6，比连其他负点更小；负点-2连a[n]=5，边权是-2×5=-10，比连其他正点更小。
- 最后连接a[1]和a[n]，是因为前面的循环没有处理这条边（i从2到n-1），而这条边是MST必须的（否则a[1]和a[n]不连通）。
**学习笔记**：MST的边数是n-1，所以分类讨论时要确保“刚好连n-1条边”，避免重复或遗漏。

#### 题解二：Leo_SZ的gp_hash_table去重片段
**亮点**：用更快的哈希表优化去重，避免超时。
**核心代码片段**：
```cpp
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
__gnu_pbds::gp_hash_table<int,bool> mp[Maxn];

bool add_e(int x, int y) {
    if (mp[x][y]) return 0;
    mp[x][y] = mp[y][x] = 1;
    ans += 1ll * a[x].val * a[y].val;
    return 1;
}
```
**代码解读**：
- `__gnu_pbds::gp_hash_table`是GNU扩展的哈希表，比`unordered_map`快，因为它用了更高效的哈希函数和冲突处理。
- `mp[x][y]`标记边x-y，`mp[y][x]`也标记，因为边是无向的。
- `add_e`函数返回是否成功添加边，方便统计非树边的数量。
**学习笔记**：当数据量很大时，选择合适的哈希表能避免超时——`gp_hash_table`是C++竞赛中的“常用优化工具”。

#### 题解三：是青白呀的二分判定片段
**亮点**：将非树边选择转化为二分问题，适合不喜欢堆操作的同学。
**核心代码片段**：
```cpp
bool check(int mid) {
    int sum = 0;
    for (int i = 1; i <= n; ++i) {
        if (a[i].sum <= 0) { // 负点连后缀
            for (int j = n; j >= 1; --j) {
                if (a[i].sum * a[j].sum > mid) break;
                if (i == j || pos[i] == j || pos[j] == i) continue;
                sum++;
            }
        } else { // 正点连前缀
            for (int j = 1; j <= n; ++j) {
                if (a[i].sum * a[j].sum > mid) break;
                if (i == j || pos[i] == j || pos[j] == i) continue;
                sum++;
            }
        }
        if (sum >= 2*m - 2*(n-1)) return 1;
    }
    return 0;
}
```
**代码解读**：
- 二分的mid是“非树边的最大边权”，check函数统计所有边≤mid的数量是否≥m-n+1（因为总边数是m，树边是n-1，所以非树边是m-n+1，乘以2是因为每条边会被两个点统计）。
- 负点i的边权随j增大而减小（因为a[i]负，j越大a[j]越大，乘积越小），所以j从n往1遍历，直到乘积>mid为止（前面的j都满足≤mid）。
- 正点i的边权随j增大而增大，所以j从1往n遍历，直到乘积>mid为止。
**学习笔记**：二分法的关键是“问题具有单调性”——当mid增大时，符合条件的边数不会减少，所以可以用二分找到最小的mid，使得边数≥m-n+1。


## 5. 算法可视化：像素动画演示

### 动画演示主题：《像素点的连通大作战》（8位红白机风格）

### 设计思路
用8位像素风还原题目中的“树”和“月光”，将点权正负转化为“红苹果（负）”和“蓝星星（正）”，边是“月光线”，堆是“像素方块堆”。通过动画展示MST的构造和多路归并的过程，让学习者直观看到“贪心选边”和“堆取最小”的逻辑。

### 动画帧步骤与交互关键点

#### 1. 场景初始化（FC风格）
- **背景**：深蓝色夜空（像素块），底部是灰色地面（代表“江”），中间是黑色网格（代表“树的位置”）。
- **点**：红苹果（点权负，大小8×8）、蓝星星（点权正，大小8×8）、黄月亮（点权0，大小8×8），每个点下方显示原下标（比如“1”“2”）。
- **控制面板**：
  - 按钮：开始/暂停（红色）、单步（蓝色）、重置（黄色）；
  - 滑块：速度（1~10，慢到快）；
  - 提示区：显示当前步骤（比如“构造MST：红苹果连蓝星星”）。
- **背景音乐**：8位风格的《月光曲》（循环播放）。

#### 2. MST构造演示（核心逻辑）
- **全正场景**：所有点是蓝星星，最小点（a[1]）闪烁，其他点依次向它发射绿色月光线（动画：从点中心滑向a[1]），伴随“叮”的音效。每连一条边，提示区显示“连边：点i → 点1，边权：a[i]×a[1]”。
- **全负场景**：所有点是红苹果，最大点（a[n]）闪烁，其他点依次向它发射绿色月光线，音效同上。
- **有正有负场景**：红苹果向最大蓝星星（a[n]）发射月光线，蓝星星向最小红苹果（a[1]）发射月光线，最后a[1]和a[n]之间连一条金色月光线（代表MST的最后一条边），伴随“叮——”的长音效。

#### 3. 多路归并演示（堆操作）
- **堆可视化**：屏幕右侧显示一个像素堆（32×128），每个方块是8×8，显示边权（比如“-6”“-4”）。
- **单步执行**：
  1. 堆顶方块（最小边权）向下滑动（弹出），伴随“啪”的音效，提示区显示“弹出边：点u → 点v，边权：w”；
  2. 若边未用，点u和点v之间连灰色月光线，提示区显示“添加非树边：点u → 点v”；
  3. 扩展下一个决策：新的方块从堆底向上滑动（插入），伴随“叮”的音效，提示区显示“插入决策：点u → 点v+1，边权：w’”。
- **自动播放**：按滑块速度（1~10帧/秒）连续执行，完成时播放胜利音效（“叮铃铃”），所有点闪烁，提示区显示“完成！总边权：ans”。

#### 4. 交互设计
- **单步**：点击“单步”按钮，执行一步操作，高亮当前处理的点和边；
- **自动**：点击“开始”按钮，按滑块速度自动播放，“暂停”按钮可停止；
- **重置**：点击“重置”按钮，恢复初始状态，重新开始动画；
- **音效开关**：右上角有“音效”按钮，可关闭所有声音。

### 技术实现（轻量化）
- **Canvas绘制**：用HTML5 Canvas绘制像素点、边、堆方块，每个元素的位置用像素坐标计算（比如点的位置是(x*16+16, y*16+16)）。
- **音效**：用Web Audio API播放8位音效（比如“叮”是440Hz的正弦波，“啪”是220Hz的方波），背景音乐是循环的8位《月光曲》（用TinySoundFont生成）。
- **代码结构**：单HTML文件，包含Canvas、JavaScript（动画逻辑）、CSS（控制面板样式），可本地运行或浏览器打开。


## 6. 拓展练习与相似问题

### 相似问题（洛谷）
1. **P1546 最短网络**（最小生成树模板题）：求n个点的最小生成树，边权是两点距离，练习贪心构造MST的基础。
2. **P2820 局域网**：求n个点m条边的最小生成树，然后求“删除k条边后的最小总权值”，练习MST的扩展（非树边的处理）。
3. **P3366 最小生成树**（模板题）：标准的Kruskal和Prim算法，对比本题的“特殊MST”构造，理解“通用MST”和“特殊MST”的区别。
4. **P1807 最长路**（反贪心）：求最长路，练习“贪心的反向思维”——本题是选最小边，最长路是选最大边。

### 进阶练习
- 尝试用“二分法”实现本题的非树边选择（参考是青白呀的题解），对比“多路归并”的效率；
- 用`gp_hash_table`替换FanMingxuan代码中的`unordered_map`，测试是否更快；
- 思考“点权有0的情况”：比如点权0连谁最优？（答案：连最大的正点或最小的负点，因为0×任何数都是0，不影响总权值）。


## 7. 学习心得与经验分享

### 来自FanMingxuan的经验
> “细节有点多，需要仔细实现。不知是哪个蒟蒻赛时没实现完，赛后20分钟直接AC。”

**Kay的点评**：本题的细节确实多——比如“i从2到n-1”的循环、“避免自环”、“决策重叠”（v+1等于u），赛时容易漏掉。解决方法是“先写伪代码，再补细节”：比如先写MST的分类讨论伪代码，再处理“1连n”的重复边；先写多路归并的伪代码，再处理“决策超过边界”的情况。

### 来自Leo_SZ的经验
> “用`gp_hash_table`就能轻松通过，之前用`unordered_map`超时了。”

**Kay的点评**：在C++竞赛中，“数据结构的选择”直接影响程序的速度。对于1e6的数据，`unordered_map`的冲突处理会变慢，而`gp_hash_table`是更好的选择。但要注意`gp_hash_table`是GNU扩展，需要包含头文件`#include<ext/pb_ds/assoc_container.hpp>`和`#include<ext/pb_ds/hash_policy.hpp>`，并且编译时要加`-std=c++11`。

### 来自是青白呀的经验
> “二分法的关键是‘问题具有单调性’，当mid增大时，符合条件的边数不会减少。”

**Kay的点评**：二分法是“将问题转化为判定问题”的常用方法，适合“求最大/最小满足条件的值”的问题。比如本题的“最小的mid，使得有足够多的边≤mid”，就是典型的二分问题。判断“单调性”是用二分法的前提——如果mid增大时，符合条件的边数反而减少，就不能用二分。


## 8. 总结
本题的核心是“贪心构造MST + 多路归并处理非树边”，考察对“贪心算法”和“数据结构（堆、哈希表）”的综合运用。通过分类讨论构造MST，利用单调性用堆处理非树边，再用哈希表去重，就能高效解决1e6的数据规模。

希望这份指南能帮助你理解本题的思路和技巧。记住：**贪心算法的关键是“每一步选最优”，而数据结构的选择是“让最优更高效”**。下次遇到类似的“连通图+最小权值”问题，不妨想想本题的思路——先建MST，再选剩下的最小边！

下次我们再一起探索新的编程挑战！💪

---
处理用时：127.46秒
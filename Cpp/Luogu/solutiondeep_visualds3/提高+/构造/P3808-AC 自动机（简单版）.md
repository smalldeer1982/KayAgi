# 题目信息

# AC 自动机（简单版）

## 题目描述

给定 $n$ 个模式串 $s_i$ 和一个文本串 $t$，求有多少个不同的模式串在文本串里出现过。  
两个模式串不同当且仅当他们**编号**不同。

## 说明/提示

### 样例 1 解释

$s_2$ 与 $s_3$ 编号（下标）不同，因此各自对答案产生了一次贡献。

### 样例 2 解释

$s_1$，$s_2$，$s_4$ 都在串 `abcd` 里出现过。

### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $n = 1$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^6$，$1 \leq |t| \leq 10^6$，$1 \leq \sum\limits_{i = 1}^n |s_i| \leq 10^6$。$s_i, t$ 中仅包含小写字母。

## 样例 #1

### 输入

```
3
a
aa
aa
aaa```

### 输出

```
3```

## 样例 #2

### 输入

```
4
a
ab
ac
abc
abcd```

### 输出

```
3```

## 样例 #3

### 输入

```
2
a
aa
aa```

### 输出

```
2```

# AI分析结果

# 💡 Kay的C++算法解析：AC自动机（简单版）深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：AC自动机（多模式串匹配）


### 🗣️ 初步分析  
解决“AC自动机（简单版）”的核心是**多模式串匹配**——给定`n`个模式串和1个文本串，统计有多少个不同的模式串（编号不同即算不同）出现在文本串中。  
如果用KMP逐个匹配每个模式串，时间复杂度会高达`O(n*(|t|+|s_i|))`，无法处理`1e6`级别的数据。而**AC自动机**（Aho-Corasick Automaton）结合了**Trie树**（高效存储多模式串）和**KMP的fail指针思想**（利用已匹配信息快速跳转），能将时间复杂度优化到`O(Σ|s_i| + |t|)`，完美解决多模式串匹配问题。


#### 核心算法流程  
AC自动机的工作流程分为三步：  
1. **构建Trie树**：将所有模式串插入Trie树，记录每个节点是否为模式串的结尾。  
2. **构建fail指针**：类似KMP的next数组，每个节点的fail指针指向其**最长后缀对应的Trie节点**（即该后缀是某个模式串的前缀）。  
3. **匹配文本串**：用文本串遍历Trie树，每到一个节点，顺着fail指针往上找，统计所有结尾节点（避免遗漏模式串的后缀匹配）。


#### 可视化设计思路  
为了直观理解AC自动机的工作过程，我们设计一个**8位像素风格的动画**，包含以下元素：  
- **Trie树可视化**：用不同颜色的像素块表示Trie节点（根节点为黄色，模式串结尾为红色），箭头表示父节点到子节点的连接。  
- **fail指针展示**：用蓝色虚线箭头表示fail指针，动态显示每个节点的fail指针指向过程（BFS顺序）。  
- **文本串匹配动画**：用“像素小蛇”代表文本串的遍历过程，每移动一步，高亮当前节点及对应的fail链，统计到结尾节点时播放“叮”的音效。  
- **交互控制**：支持“单步执行”（逐步看Trie构建、fail指针连接、匹配过程）、“自动播放”（加速演示）、“重置”（重新开始）。  


## 2. 精选优质题解参考

### 题解一：yybyyb（赞：371）  
* **点评**：这是一份**标准且易读的AC自动机模板**，代码结构清晰，注释详细。Trie树的构建（`Build`函数）、fail指针的BFS构建（`Get_fail`函数）、匹配统计（`AC_Query`函数）均严格遵循AC自动机的核心逻辑。其中，`AC_Query`函数中通过`for(t=now;t&&AC[t].end!=-1;t=AC[t].fail)`遍历fail链统计结果，避免了重复计算（用`AC[t].end=-1`标记已统计的节点），处理了“模式串包含后缀”的情况（如“a”和“aa”都出现在“aaa”中）。代码的规范性和可读性非常适合初学者参考。


### 题解二：ikka（赞：4）  
* **点评**：这份题解用**指针实现AC自动机**，更直观地展示了Trie节点的连接关系。`node`结构体中的`ch[26]`指针数组表示子节点，`fail`指针表示失配跳转。`insert`函数插入模式串时，动态分配节点；`get_fail`函数用BFS构建fail指针，逻辑与模板一致，但指针操作更接近数据结构的本质。匹配函数`AC`中，通过`while(!p->ch[x] && p != root) p = p->fail`处理失配跳转，符合KMP的思想。指针实现有助于理解Trie树的动态结构，但需要注意内存管理（本题中未涉及，但实际应用中需避免内存泄漏）。


### 题解三：G我就是菜G（赞：2）  
* **点评**：这份题解用**结构体封装AC自动机**，将Trie树、fail指针、统计逻辑整合到`node_`结构体中，代码更整洁。`insert`函数插入模式串，`build`函数构建fail指针（包含虚节点优化：`trie[now][i] = trie[fail[now]][i]`，避免重复判断），`query`函数匹配文本串并统计结果。结构体封装使得代码的复用性更高，适合作为模板使用。其中，`tag[t] = -1`标记已统计的节点，避免重复计算，处理了题目中“不同模式串算不同贡献”的要求。


## 3. 核心难点辨析与解题策略

### 1. 难点1：fail指针的理解与构建  
* **分析**：fail指针的定义是“当前节点的最长后缀对应的Trie节点”。例如，若模式串为“abcd”和“bcd”，则“abcd”的最后一个节点的fail指针指向“bcd”的最后一个节点（因为“bcd”是“abcd”的最长后缀）。构建fail指针需要**BFS遍历Trie树**，确保父节点的fail指针已经处理。具体来说，对于节点`u`的子节点`v`（字符为`c`），`v`的fail指针指向`u`的fail指针所指向的节点的`c`子节点（若存在），否则继续跳转fail指针直到根节点。  
* 💡 **学习笔记**：fail指针是AC自动机的核心，它让我们在匹配时无需回溯文本串，而是通过跳转fail指针快速找到下一个可能的匹配位置。


### 2. 难点2：匹配时统计所有模式串  
* **分析**：文本串遍历到某个节点时，可能包含多个模式串（例如，“aaa”包含“a”、“aa”、“aaa”）。因此，需要**顺着fail指针往上找**，统计所有结尾节点。例如，在`AC_Query`函数中，`for(t=now;t&&AC[t].end!=-1;t=AC[t].fail)`遍历fail链，将所有未统计的结尾节点的贡献加入答案，并标记为已统计（`AC[t].end=-1`）。  
* 💡 **学习笔记**：遍历fail链是AC自动机统计所有模式串的关键，避免了遗漏模式串的后缀匹配。


### 3. 难点3：虚节点优化（可选）  
* **分析**：为了避免在匹配时频繁跳转fail指针，有些题解会进行**虚节点优化**——将Trie树中不存在的子节点指向其fail指针的对应子节点（例如，`trie[now][i] = trie[fail[now]][i]`）。这样，在匹配时，即使当前节点没有对应的子节点，也能直接通过虚节点跳转，减少了判断次数。  
* 💡 **学习笔记**：虚节点优化是AC自动机的常用优化手段，能提高匹配效率，但不影响核心逻辑。


### ✨ 解题技巧总结  
- **Trie树构建**：用数组或指针存储子节点，记录每个节点是否为模式串结尾。  
- **fail指针构建**：BFS遍历，确保父节点的fail指针先处理，子节点的fail指针由父节点的fail指针推导。  
- **匹配统计**：遍历文本串时，顺着fail链统计所有结尾节点，标记已统计的节点避免重复。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合优质题解的核心逻辑，提炼出标准的AC自动机模板，适用于洛谷P3808（简单版）。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <cstring>
  #include <queue>
  using namespace std;

  const int MAXN = 1e6 + 10;
  struct TrieNode {
      int fail;          // 失配指针
      int child[26];     // 子节点（0~25表示a~z）
      int end;           // 标记是否为模式串结尾（1表示是，-1表示已统计）
  } trie[MAXN];
  int cnt = 0;          // Trie树节点计数器

  // 插入模式串到Trie树
  void insert(string s) {
      int now = 0;
      for (char c : s) {
          int idx = c - 'a';
          if (!trie[now].child[idx]) {
              trie[now].child[idx] = ++cnt;
              memset(&trie[cnt], 0, sizeof(TrieNode)); // 初始化新节点
          }
          now = trie[now].child[idx];
      }
      trie[now].end = 1; // 标记模式串结尾
  }

  // 构建fail指针（BFS）
  void buildFail() {
      queue<int> q;
      // 根节点的子节点的fail指针指向根节点
      for (int i = 0; i < 26; i++) {
          if (trie[0].child[i]) {
              trie[trie[0].child[i]].fail = 0;
              q.push(trie[0].child[i]);
          }
      }
      while (!q.empty()) {
          int u = q.front();
          q.pop();
          for (int i = 0; i < 26; i++) {
              int v = trie[u].child[i];
              if (v) { // 存在子节点v
                  int f = trie[u].fail;
                  // 找u的fail指针的i子节点
                  while (f && !trie[f].child[i]) f = trie[f].fail;
                  trie[v].fail = (f ? trie[f].child[i] : 0);
                  q.push(v);
              } else { // 不存在子节点v，指向虚节点（优化）
                  trie[u].child[i] = (trie[u].fail ? trie[trie[u].fail].child[i] : 0);
              }
          }
      }
  }

  // 匹配文本串，统计不同模式串的出现次数
  int query(string t) {
      int now = 0, ans = 0;
      for (char c : t) {
          int idx = c - 'a';
          now = trie[now].child[idx]; // 跳转至子节点（含虚节点优化）
          // 遍历fail链，统计所有结尾节点
          for (int p = now; p && trie[p].end != -1; p = trie[p].fail) {
              ans += trie[p].end;
              trie[p].end = -1; // 标记已统计，避免重复
          }
      }
      return ans;
  }

  int main() {
      int n;
      cin >> n;
      for (int i = 0; i < n; i++) {
          string s;
          cin >> s;
          insert(s);
      }
      buildFail();
      string t;
      cin >> t;
      cout << query(t) << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  - `insert`函数：将模式串插入Trie树，记录每个节点的子节点和结尾标记。  
  - `buildFail`函数：用BFS构建fail指针，处理每个节点的子节点，确保fail指针指向最长后缀对应的节点。  
  - `query`函数：用文本串遍历Trie树，每到一个节点，顺着fail链统计所有结尾节点，标记已统计的节点避免重复。  


### 针对各优质题解的片段赏析

#### 题解一：yybyyb的`AC_Query`函数  
* **亮点**：通过遍历fail链统计所有模式串，处理了“模式串包含后缀”的情况。  
* **核心代码片段**：  
  ```cpp
  int AC_Query(string s) {
      int l = s.length();
      int now = 0, ans = 0;
      for (int i = 0; i < l; ++i) {
          now = AC[now].vis[s[i] - 'a']; // 向下一层
          for (int t = now; t && AC[t].end != -1; t = AC[t].fail) { // 遍历fail链
              ans += AC[t].end;
              AC[t].end = -1; // 标记已统计
          }
      }
      return ans;
  }
  ```  
* **代码解读**：  
  - `now = AC[now].vis[s[i] - 'a']`：文本串的第`i`个字符，跳转至Trie树的对应子节点。  
  - `for(t=now;t&&AC[t].end!=-1;t=AC[t].fail)`：从当前节点`now`开始，顺着fail指针往上找，直到根节点（`t==0`）或已统计的节点（`AC[t].end==-1`）。  
  - `ans += AC[t].end`：若当前节点是模式串结尾，将贡献加入答案（`AC[t].end`初始为1，统计后设为-1）。  
* 💡 **学习笔记**：遍历fail链是AC自动机统计所有模式串的关键，必须掌握。


#### 题解二：ikka的`get_fail`函数（指针实现）  
* **亮点**：用指针直观展示fail指针的构建过程。  
* **核心代码片段**：  
  ```cpp
  void get_fail() {
      queue<node*> q;
      q.push(root);
      while (!q.empty()) {
          node* tmp = q.front(); q.pop();
          for (int i = 0; i < 26; ++i) if (tmp->ch[i]) {
              if (tmp == root) {
                  tmp->ch[i]->fail = root;
              } else {
                  node* p = tmp->fail;
                  while (p) {
                      if (p->ch[i]) {
                          tmp->ch[i]->fail = p->ch[i];
                          break;
                      }
                      p = p->fail;
                  }
                  if (p == NULL) tmp->ch[i]->fail = root;
              }
              q.push(tmp->ch[i]);
          }
      }
  }
  ```  
* **代码解读**：  
  - `queue<node*> q`：用队列存储待处理的节点（BFS顺序）。  
  - `tmp == root`：根节点的子节点的fail指针指向根节点。  
  - `while(p)`：找`tmp`的fail指针的`i`子节点，若存在，则`tmp->ch[i]`的fail指针指向该节点；否则指向根节点。  
* 💡 **学习笔记**：指针实现有助于理解Trie树的动态结构，但模板题中数组实现更高效。


#### 题解三：G我就是菜G的`build`函数（虚节点优化）  
* **亮点**：虚节点优化减少了匹配时的判断次数。  
* **核心代码片段**：  
  ```cpp
  void build() {
      queue<int> q;
      for (int i = 0; i < 26; i++)
          if (trie[0][i]) fail[trie[0][i]] = 0, q.push(trie[0][i]);
      while (!q.empty()) {
          int now = q.front(); q.pop();
          for (int i = 0; i < 26; i++)
              if (trie[now][i]) {
                  fail[trie[now][i]] = trie[fail[now]][i];
                  q.push(trie[now][i]);
              } else trie[now][i] = trie[fail[now]][i]; // 虚节点优化
      }
  }
  ```  
* **代码解读**：  
  - `trie[now][i] = trie[fail[now]][i]`：若当前节点`now`没有`i`子节点，则将其指向`now`的fail指针的`i`子节点（虚节点）。这样，在匹配时，即使`now`没有`i`子节点，也能直接跳转至虚节点，减少了`while`循环的判断次数。  
* 💡 **学习笔记**：虚节点优化是AC自动机的常用优化手段，能提高匹配效率，但不影响核心逻辑。  


## 5. 算法可视化：像素动画演示（核心部分）

### 🎮 动画演示主题  
**“像素探险家”寻找宝藏**：用像素风格的Trie树表示模式串集合，文本串是“探险家”的路径，fail指针是“隐藏的通道”，模式串结尾是“宝藏”。


### 📊 核心演示内容  
1. **Trie树构建**：  
   - 根节点（黄色像素块）位于屏幕中心，插入模式串时，动态生成子节点（蓝色像素块），模式串结尾节点变为红色。  
   - 例如，插入“a”、“aa”、“aaa”时，根节点生成“a”子节点（红色），“a”子节点生成“a”子节点（红色），依此类推。  

2. **fail指针构建**：  
   - 用蓝色虚线箭头表示fail指针，BFS顺序动态连接。例如，“aa”的fail指针指向“a”（根节点的“a”子节点），“aaa”的fail指针指向“aa”（“a”子节点的“a”子节点）。  

3. **文本串匹配**：  
   - “探险家”（绿色像素块）从根节点出发，沿着文本串的字符移动（例如，文本串是“aaa”，则依次移动到“a”、“aa”、“aaa”）。  
   - 每移动一步，高亮当前节点及对应的fail链（蓝色虚线箭头），统计到红色节点（宝藏）时，播放“叮”的音效，并在屏幕右上角显示当前统计的宝藏数量。  

4. **交互控制**：  
   - **单步执行**：点击“下一步”按钮，逐步展示Trie构建、fail指针连接、匹配过程。  
   - **自动播放**：点击“开始”按钮，动画自动播放，速度可通过滑块调节。  
   - **重置**：点击“重置”按钮，回到初始状态，重新开始演示。  


### 🎨 设计思路  
- **像素风格**：采用8位像素风（类似FC游戏），颜色鲜艳，符合青少年的审美。  
- **游戏化元素**：将模式串视为“宝藏”，文本串视为“探险家的路径”，fail指针视为“隐藏的通道”，增加学习的趣味性。  
- **音效反馈**：关键操作（如插入模式串、匹配到宝藏）播放像素音效，强化记忆。  


## 6. 拓展练习与相似问题思考

### 🧠 通用思路/技巧迁移  
AC自动机主要用于**多模式串匹配**，适用于以下场景：  
1. **文本过滤**：过滤文本中的敏感词（如“垃圾”、“暴力”等）。  
2. **信息检索**：在大量文档中查找多个关键词的出现次数。  
3. **生物信息学**：在DNA序列中查找多个基因片段的位置。  


### 📚 练习推荐（洛谷）  
1. **洛谷 P3796** - 【模板】AC自动机（加强版）  
   - 🗣️ **推荐理由**：要求统计每个模式串的出现次数，需要在AC自动机的基础上记录每个模式串的结尾节点，并用fail链统计所有出现次数。是本题的加强版，有助于巩固AC自动机的统计逻辑。  

2. **洛谷 P5357** - 【模板】AC自动机（二次加强版）  
   - 🗣️ **推荐理由**：要求处理带限制的匹配（如模式串不能重叠），需要在AC自动机的基础上结合动态规划（DP），拓展AC自动机的应用场景。  

3. **洛谷 P2444** - 病毒侵袭  
   - 🗣️ **推荐理由**：要求判断文本串是否包含任何一个模式串，需要在AC自动机的匹配过程中实时判断，有助于理解AC自动机的匹配逻辑。  


## 7. 学习心得与经验分享（若有）  
从题解中可以总结以下学习心得：  
- **理解fail指针的本质**：fail指针是当前节点的最长后缀对应的Trie节点，它让我们在匹配时无需回溯文本串，而是通过跳转fail指针快速找到下一个可能的匹配位置。  
- **掌握BFS构建fail指针的方法**：BFS遍历Trie树，确保父节点的fail指针先处理，子节点的fail指针由父节点的fail指针推导。  
- **注意统计时的去重**：题目要求“不同模式串算不同贡献”，因此需要标记已统计的节点（如`end=-1`），避免重复计算。  


## 📝 总结  
AC自动机是处理多模式串匹配的高效算法，结合了Trie树和KMP的思想。通过构建Trie树存储模式串，构建fail指针快速跳转，匹配时遍历fail链统计结果，能高效解决多模式串匹配问题。学习AC自动机的关键是理解fail指针的本质和构建方法，掌握匹配时的统计逻辑。  

希望这份学习指南能帮助你掌握AC自动机的核心思想和实现技巧，在后续的编程挑战中灵活运用！💪

---
处理用时：203.94秒
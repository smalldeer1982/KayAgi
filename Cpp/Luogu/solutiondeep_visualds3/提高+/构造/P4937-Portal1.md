# 题目信息

# Portal1

## 题目背景

Agent 获取资源有很多种方式，HACK 就是其中的一种，侵入 Portal 可以获得很多有用的资源。

ENLIGHTENED 总部因为参加 XM 大战，只剩下一点点可用资源了，所以 ENLIGHTENED 行动指挥想要进行 HACK 活动，尽量增加库存。

## 题目描述

地图上有 $n$ 个可以被 HACK 的 Portal，编号为 $1\sim n$。HACK 第 $i$ 号 Portal 需要时间 $t_i$ 秒，可以 HACK 出 $c_i$ 库存的资源。可是只有有能量的 Portal 才可以 HACK 出资源。第 $i$ 号 Portal 在第 $d_i$ 秒时，能量就会消失殆尽。ENLIGHTEDED 想知道，最多可以增加多少库存，并且按编号小到大输出需要 HACK 的 Portal 的编号。

## 说明/提示

对于 $20\%$ 的数据，$n\leq5$，$t_i\leq 5$，$c_i\leq 5$，$d_i\leq10$。

对于 $40\%$ 的数据，$n\leq 20$，$t_i\leq 10$，$c_i\leq 10$，$d_i\leq 100$。

对于 $60\%$ 的数据，$n\leq50$，$t_i\leq15$，$c_i\leq15$，$d_i\leq1000$。

对于 $100\%$ 的数据，$1\leq n\leq 100$，$1 \leq t_i \leq 20$，$1\leq c_i \leq 20$，$1 \leq d_i \leq 2000$。

## 样例 #1

### 输入

```
3
5 6 5
1 8 2
2 7 3
```

### 输出

```
7
2
1 2```

# AI分析结果

# 💡 Kay的C++算法解析：Portal1 深入学习指南 💡

<introduction>
  今天我们来一起分析“Portal1”这道C++编程题。这道题看似是简单的“选物品拿最多价值”，但每个物品都有“截止时间”的限制——超过这个时间就不能选了！我们需要用聪明的算法解决这个“带时限的背包问题”，还要学会记录选择的物品编号。本指南会帮你梳理思路、掌握核心算法，并通过像素动画直观看到过程～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：带时限的01背包（贪心+动态规划）

🗣️ **初步分析**：
> 解决“Portal1”的关键，是把问题转化为**带时限的01背包**。想象一下：你有一个背包，要装最多价值的物品，但每个物品必须在某个时间点前放进背包（否则会消失）。这时候，我们需要**先选截止时间早的物品**（贪心），再用动态规划计算“在某个时间点前能拿的最大价值”（DP）。  
> - **核心思路**：先按Portal的能量消失时间`d_i`从小到大排序（保证前面的选择不影响后面的时限），再用类似01背包的DP，状态`f[j]`表示“用了`j`秒时能拿到的最大资源”，同时记录每一步选了哪些Portal。  
> - **核心难点**：如何处理每个Portal的时限（解决方法：排序）、如何记录选择的路径（解决方法：用数组/vector保存每一步的选择）。  
> - **可视化设计思路**：我们会用像素动画展示“排序后的Portal列表”“时间轴上的资源变化”“路径记录的过程”——比如选中一个Portal时，时间轴会增加它的`t_i`，资源条会增加`c_i`，同时用颜色标记选中的Portal编号。  
> - **复古游戏元素**：动画会用FC红白机风格（8位像素），选中Portal时有“叮”的音效，完成时播放胜利音乐，让学习更有趣！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码有效性、实践价值等方面筛选了2份优质题解（≥4星），它们都用了“贪心+DP”的正确思路，且代码规范、易理解。
</eval_intro>

**题解一：来源：Yemaster（MasterOJ）**  
* **点评**：这份题解的思路非常“接地气”——一开始没排序导致WA，后来修正了排序步骤就AC了，完美体现了“带时限背包”的核心技巧！作者用`f[j]`记录时间`j`的最大资源，`g[j]`用vector记录选了哪些Portal，状态转移逻辑和01背包几乎一样（逆序循环时间）。代码中的排序步骤（按`d_i`从小到大）是关键，保证了前面的选择不会超过后面Portal的时限。从实践角度看，这份代码逻辑清晰、边界处理严谨（比如`j`从`d_i-1`开始循环，避免超过时限），非常适合初学者参考。

**题解二：来源：木木！（洛谷）**  
* **点评**：这份题解把“贪心+DP”的组合讲得很透彻！作者提到“所有合法方案都能转化为排序后的方案”，并结合`dp[i][j]`（考虑前`i`个Portal，用了`j`秒的最大资源）和`hackn[i][j]`（记录第`i`个Portal是否被选）来记录路径。代码中的路径还原部分（从后往前找选中的Portal）很巧妙，还用了`vector.reserve()`优化性能。此外，作者提到与“拯救小矮人”（P4823）的相似性，帮助我们举一反三，是一份很有启发性的题解。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决“带时限背包”问题时，我们通常会遇到以下3个核心难点。结合优质题解的共性，我为你提炼了应对策略：
</difficulty_intro>

1. **难点1：如何处理每个Portal的时限？**  
   * **分析**：如果不排序，直接选Portal，可能会出现“前面选了一个耗时久的Portal，导致后面截止时间早的Portal无法选”的情况。比如样例中的Portal1（`t=5`，`d=5`）和Portal3（`t=2`，`d=3`）：如果先选Portal1（耗时5秒），Portal3的截止时间是3秒，就无法选了；但如果先选Portal3（耗时2秒），再选Portal1（耗时5秒，总时间7秒，但Portal1的截止时间是5秒，还是不行？不对，样例中的正确选择是Portal2（`t=1`，`d=8`）和Portal1（`t=5`，`d=5`）？等一下，样例输入中的Portal1是`5 6 5`（`t=5`，`d=6`，`c=5`），Portal2是`1 8 2`（`t=1`，`d=8`，`c=2`），Portal3是`2 7 3`（`t=2`，`d=7`，`c=3`）。排序后按`d_i`从小到大是Portal1（`d=6`）、Portal3（`d=7`）、Portal2（`d=8`）？不对，样例中的输出是选Portal2和Portal1，总时间1+5=6秒，都不超过它们的`d_i`（Portal2的`d=8`，Portal1的`d=6`）。哦，对，排序应该是按`d_i`从小到大，所以Portal1（`d=6`）、Portal3（`d=7`）、Portal2（`d=8`）？但样例中的正确选择是Portal2（`d=8`）和Portal1（`d=6`），因为它们的总时间是1+5=6秒，都不超过各自的`d_i`。这说明排序后，我们可以放心地选前面的Portal，因为它们的`d_i`更小，不会影响后面的选择。  
   * 💡 **学习笔记**：按`d_i`排序是解决带时限背包的“前置条件”，必须先做！

2. **难点2：如何记录选择的Portal编号？**  
   * **分析**：动态规划不仅要计算最大价值，还要记录选了哪些物品。优质题解中，Yemaster用`g[j]`（vector）记录时间`j`时选的Portal编号，木木用`hackn[i][j]`（二维数组）记录第`i`个Portal是否被选。比如Yemaster的代码中，当`f[j - T] + C > f[j]`时，`g[j]`会复制`g[j - T]`并添加当前Portal的编号——这样就能一步步还原路径。  
   * 💡 **学习笔记**：记录路径的关键是“复制前一个状态的路径，再添加当前选择”。

3. **难点3：如何优化空间复杂度？**  
   * **分析**：木木的题解用了`dp[i][j]`（二维数组），空间复杂度是`O(n*max_d)`（`n=100`，`max_d=2000`，总共有200000个状态），对于本题来说完全够用。但如果`max_d`更大，可以用滚动数组优化（比如`dp[j]`代替`dp[i][j]`），因为`dp[i][j]`只依赖于`dp[i-1][j]`和`dp[i-1][j-t_i]`。  
   * 💡 **学习笔记**：滚动数组是01背包的常用优化技巧，能把空间复杂度从`O(n*max_d)`降到`O(max_d)`。


### ✨ 解题技巧总结
<summary_best_practices>
通过本题，我总结了3个通用解题技巧：
</summary_best_practices>
- **技巧1：问题转化**：把“带时限的选物品”转化为“带时限的01背包”，用贪心（排序）+ DP解决。  
- **技巧2：路径记录**：用vector或二维数组记录每一步的选择，方便还原结果。  
- **技巧3：边界处理**：循环时间时，要保证不超过当前Portal的`d_i`（比如`j`从`d_i-1`开始），避免无效状态。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一个综合了Yemaster和木木思路的**通用核心代码**，它包含了排序、DP、路径记录的完整逻辑：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了优质题解的思路，用“排序+DP+路径记录”解决问题，逻辑清晰、易理解。  
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;

  struct Portal {
      int t, d, c, id;
      bool operator<(const Portal& other) const {
          return d < other.d; // 按d_i从小到大排序
      }
  };

  int main() {
      int n;
      cin >> n;
      vector<Portal> portals(n);
      for (int i = 0; i < n; ++i) {
          cin >> portals[i].t >> portals[i].d >> portals[i].c;
          portals[i].id = i + 1; // 编号从1开始
      }
      sort(portals.begin(), portals.end()); // 排序

      const int MAX_D = 2000; // 最大d_i是2000
      vector<int> f(MAX_D + 1, 0); // f[j]：时间j的最大资源
      vector<vector<int>> path(MAX_D + 1); // path[j]：时间j时选的Portal编号

      for (const auto& p : portals) {
          int t = p.t, d = p.d, c = p.c, id = p.id;
          // 逆序循环时间（避免重复选同一个Portal）
          for (int j = d - 1; j >= t; --j) {
              if (f[j - t] + c > f[j]) {
                  f[j] = f[j - t] + c;
                  path[j] = path[j - t]; // 复制前一个状态的路径
                  path[j].push_back(id); // 添加当前Portal编号
              }
          }
      }

      // 找最大资源对应的时间
      int max_c = 0, best_time = 0;
      for (int j = 0; j <= MAX_D; ++j) {
          if (f[j] > max_c) {
              max_c = f[j];
              best_time = j;
          }
      }

      // 输出结果
      cout << max_c << endl;
      cout << path[best_time].size() << endl;
      sort(path[best_time].begin(), path[best_time].end()); // 按编号从小到大排序
      for (int id : path[best_time]) {
          cout << id << " ";
      }
      cout << endl;

      return 0;
  }
  ```
* **代码解读概要**：  
  1. **输入与排序**：读取Portal信息，按`d_i`从小到大排序。  
  2. **DP初始化**：`f[j]`初始化为0（时间j的最大资源），`path[j]`初始化为空（时间j时选的Portal编号）。  
  3. **状态转移**：遍历每个Portal，逆序循环时间（避免重复选），如果选当前Portal能得到更大资源，就更新`f[j]`和`path[j]`。  
  4. **找最优解**：遍历`f`数组，找到最大资源对应的时间`best_time`。  
  5. **输出结果**：输出最大资源、选的Portal数量，以及按编号排序后的Portal编号。


<code_intro_selected>
接下来，我们剖析优质题解中的**核心代码片段**，看看它们的亮点：
</code_intro_selected>

**题解一：Yemaster的路径记录片段**  
* **亮点**：用`vector`记录路径，逻辑简单、易理解。  
* **核心代码片段**：
  ```cpp
  vector<int> g[2005]; // g[j]：时间j时选的Portal编号
  for (RI i = 1; i <= N; ++i) {
      for (RI j = a[i].D - 1; j >= a[i].T; --j) {
          if (f[j - a[i].T] + a[i].C > f[j]) {
              g[j] = g[j - a[i].T]; // 复制前一个状态的路径
              g[j].push_back(a[i].id); // 添加当前编号
              f[j] = f[j - a[i].T] + a[i].C;
          }
      }
  }
  ```
* **代码解读**：  
  当选当前Portal（`a[i]`）能得到更大资源时，`g[j]`会复制`g[j - a[i].T]`（前一个时间点的路径），然后添加当前Portal的编号。这样，`g[j]`就保存了时间`j`时的最优路径。  
* 💡 **学习笔记**：路径记录的关键是“复制+添加”，这样就能一步步还原选择过程。

**题解二：木木的路径还原片段**  
* **亮点**：从后往前找选中的Portal，逻辑清晰、效率高。  
* **核心代码片段**：
  ```cpp
  vector<int> vec;
  vec.reserve(200); // 预分配空间，优化性能
  int nowtime = ansn; // 最优时间
  for (int nowid = n; hackn[nowid][nowtime]; ) {
      int hkn = hackn[nowid][nowtime]; // 选中的Portal编号
      vec.push_back(pi[hkn].id); // 添加编号
      nowid = hkn - 1; // 跳到前一个Portal
      nowtime -= pi[hkn].ti; // 减去当前Portal的时间
  }
  sort(vec.begin(), vec.end()); // 按编号排序
  ```
* **代码解读**：  
  `hackn[nowid][nowtime]`记录了在考虑前`nowid`个Portal、时间`nowtime`时，是否选了第`nowid`个Portal。从后往前遍历，找到所有选中的Portal，然后排序输出。  
* 💡 **学习笔记**：路径还原可以用“从后往前找”的方法，适合用二维数组记录状态的情况。


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了更直观地理解“带时限背包”的执行过程，我设计了一个**8位像素风格的动画**，结合复古游戏元素，让你“看”到算法的每一步！
\</visualization\_intro\>

  * **动画演示主题**：《像素探险家：Portal HACK 大挑战》（仿FC红白机风格）  
  * **核心演示内容**：展示“排序后的Portal列表”“时间轴变化”“资源条增加”“路径记录”的过程。  
  * **设计思路简述**：用8位像素风格营造轻松的学习氛围，用“叮”的音效强化关键操作（如选中Portal），用颜色标记选中的Portal（比如红色表示已选），让你一眼就能看到算法的变化。


### 🎮 动画帧步骤与交互关键点
1. **场景初始化**（FC风格）：  
   - 屏幕左边是**排序后的Portal列表**（每个Portal用像素方块表示，显示`id`、`t`、`d`、`c`）。  
   - 屏幕右边是**时间轴**（横向进度条，显示当前时间）和**资源条**（纵向进度条，显示当前资源）。  
   - 底部有**控制面板**：“开始”“单步”“重置”按钮，以及速度滑块（调整动画速度）。  
   - 背景播放**8位风格的轻松BGM**（比如《超级马里奥》的背景音乐）。

2. **算法启动**：  
   - 点击“开始”按钮，动画开始。首先显示“排序中...”的提示，然后按`d_i`从小到大排列Portal列表（比如Portal1、Portal3、Portal2）。

3. **DP过程演示**（核心部分）：  
   - 遍历每个Portal（比如第一个Portal是Portal1，`t=5`，`d=6`，`c=5`）：  
     - 时间轴从`0`开始，逆序循环到`d_i-1`（即`5`）。  
     - 当时间`j=5`时，计算`f[5-5] + 5 = f[0] +5=0+5=5`，比`f[5]`（0）大，所以更新`f[5]`为5，资源条从0增加到5（伴随“叮”的音效）。  
     - 路径记录：`path[5]`添加Portal1的编号（1），用红色标记Portal1的像素方块。  
   - 遍历第二个Portal（Portal3，`t=2`，`d=7`，`c=3`）：  
     - 时间轴从`6`（`d_i-1=7-1=6`）逆序循环到`2`。  
     - 当时间`j=6`时，计算`f[6-2] +3 = f[4] +3=0+3=3`，比`f[6]`（0）大，更新`f[6]`为3，资源条增加到3（音效）。  
     - 当时间`j=5`时，计算`f[5-2] +3 = f[3] +3=0+3=3`，比`f[5]`（5）小，不更新。  
   - 遍历第三个Portal（Portal2，`t=1`，`d=8`，`c=2`）：  
     - 时间轴从`7`（`d_i-1=8-1=7`）逆序循环到`1`。  
     - 当时间`j=6`时，计算`f[6-1] +2 = f[5] +2=5+2=7`，比`f[6]`（3）大，更新`f[6]`为7，资源条增加到7（音效）。  
     - 路径记录：`path[6]`复制`path[5]`（包含Portal1的编号），然后添加Portal2的编号（2），用红色标记Portal2的像素方块。

4. **最优解展示**：  
   - 动画结束后，显示“最优解”提示：最大资源是7，选的Portal是1和2（按编号排序）。  
   - 播放**胜利音效**（比如《魂斗罗》的通关音乐），资源条闪烁，选中的Portal方块跳动。


### 📝 旁白提示（动画中的文字气泡）
- “现在开始排序啦！按Portal的能量消失时间从小到大排～”  
- “选中Portal1啦！时间增加5秒，资源增加5～”  
- “选中Portal2啦！时间增加1秒，资源增加2～总资源到7啦！”  
- “最优解找到啦！选Portal1和2，总资源7～”


\<visualization\_conclusion\>
通过这个像素动画，你是不是清楚地看到了“带时限背包”的执行过程？排序、选Portal、更新资源、记录路径——每一步都直观可见！下次遇到类似问题，你肯定能快速想起这个动画～


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
“带时限的01背包”是一个经典的算法模型，很多问题都能用它解决。接下来，我推荐几道洛谷上的相似题目，帮你巩固技巧：
\</similar\_problems\_intro\>

  * **通用思路迁移**：  
    “带时限的01背包”适用于“选物品拿最多价值，每个物品有截止时间”的问题，比如：  
    1. 工厂生产产品，每个产品有截止时间和利润，选哪些产品能赚最多钱。  
    2. 学生选课，每门课有截止时间和学分，选哪些课能拿最多学分。  
    3. 快递员送货，每个包裹有截止时间和奖励，送哪些包裹能拿最多奖励。

  * **练习推荐 (洛谷)**：  
    1. **洛谷 P4823** - 拯救小矮人  
      * 🗣️ **推荐理由**：这道题和“Portal1”非常像，都是“带时限的选物品”，需要用贪心+DP解决。不同的是，它的“价值”是“拯救的小矮人数量”，“时间”是“小矮人的身高”，能帮你巩固“问题转化”的技巧。  
    2. **洛谷 P1060** - 开心的金明  
      * 🗣️ **推荐理由**：这是一道经典的01背包问题，虽然没有时限，但能帮你熟悉“状态转移”和“路径记录”的基本逻辑，是“带时限背包”的基础。  
    3. **洛谷 P2340** - 奶牛秘书  
      * 🗣️ **推荐理由**：这道题的“时限”是“奶牛的产奶时间”，需要用“带时限的01背包”解决，而且需要优化空间（滚动数组），能帮你提升代码的效率意识。


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>
优质题解中的作者经验非常宝贵，我摘录了2条，帮你避免踩坑：
\</insights\_intro\>

> **经验1（来自Yemaster）**：“一开始没排序导致WA，后来才知道排序是必须的！”  
> **点评**：这是“带时限背包”的常见错误——忘记排序。排序能保证前面的选择不影响后面的时限，是解决问题的关键步骤。下次遇到类似问题，一定要先想“要不要排序？”。

> **经验2（来自木木！）**：“用vector.reserve()能优化路径记录的性能！”  
> **点评**：`vector.reserve()`会预分配空间，避免频繁扩容，提升代码速度。虽然本题数据不大，但这个技巧在大数据量的问题中非常有用，值得学习。


\<conclusion\>
本次关于“Portal1”的C++解题分析就到这里啦！你学会了“带时限的01背包”的核心思路（贪心+DP），掌握了路径记录的技巧，还通过像素动画直观看到了算法过程。记住：编程能力的提升在于“多练+多思考”，下次遇到类似问题，你肯定能轻松解决！💪

如果有不懂的地方，欢迎随时问我～ Kay会一直帮你哦！😊

---
处理用时：181.72秒
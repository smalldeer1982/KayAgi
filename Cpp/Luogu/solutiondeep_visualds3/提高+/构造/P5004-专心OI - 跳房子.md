# 题目信息

# 专心OI - 跳房子

## 题目背景

Imakf 有一天参加了 PINO2017 PJ 组，他突然看见最后一道题：

![](https://cdn.luogu.com.cn/upload/pic/39659.png )

他十分蒟蒻，写不出来。

而如今他还是一个蒟蒻，他又看见一道题：

![](https://cdn.luogu.com.cn/upload/pic/39660.png)

他还是写不出来，于是便来请教您。

## 题目描述

您有 $N$ 个格子，排成一行，从左往右编号为 $1,2,\cdots,N$。您站在 $1$ 号格子的左边无限远，开始从左往右跳，跳到 $N$ 号格子右侧为止。由于您是一位成功的 OIer，您自然长得很胖，所以您的腿部力量也非常大！这使得您跳一次，当前格子到目标格子中间必须至少空出来 $M$ 格，但您可以跳无数格远！

您认为这么跳太没意思了，于是便想计算出有多少种方案可以跳完全程。由于方案可能过多，您会输出方案数量模 $(10^9+7)$ 的值

方案不同当且仅当经过的任一一个格子编号不同。

## 说明/提示

| 测试数据编号 | $N$ | $M$ |  
| :-----------: | :-----------: | :-----------: |
|$1,2$ | $\leq10$ | $=1$ |    
| $3,4$ | $\leq10^7$ | $=1$ |    
| $5,6$ | $\leq10^6$ | $=2$ |  
| $7,8$ | $\leq10^5$ | $=3$ |  
| $9,10$ | $\leq10^4$ | $=5$ |  
| $11,12$ | $\leq10^{12}$ | $=1$ |  
| $13,14$ | $\leq10^{18}$ |$=10$  |  
| $15\sim20$ | $\leq10^{18}$ |  $=15$|  

对于 $100\%$ 的数据，满足 $1 \le N \le 10^{18}$。

## 样例 #1

### 输入

```
5 1 
```

### 输出

```
13
```

## 样例 #2

### 输入

```
6 2 
```

### 输出

```
13
```

# AI分析结果

# 💡 Kay的C++算法解析：专心OI - 跳房子 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**矩阵加速递推**（动态规划优化）

🗣️ **初步分析**：  
解决“跳房子”问题的关键，是将**大数量级的递推问题**（\(N \leq 10^{18}\)）转化为**矩阵快速幂**的计算。简单来说，矩阵加速就像“递推的快捷键”——通过构造一个转移矩阵，将递推式转化为矩阵乘法，再用快速幂将时间复杂度从\(O(N)\)降到\(O(M^3 \log N)\)（\(M\)是递推式的阶数，本题\(M \leq 15\)）。  

### 问题核心与递推式推导  
题目要求计算“跳完全程的方案数”，等价于“选择若干格子染色，使得任意两个染色格子间隔至少\(M\)个格子”的方案数。通过分析小例子（如\(M=1\)时，方案数符合斐波那契数列），可推导出递推式：  
- 当\(i \leq M+1\)时，\(f(i) = i+1\)（每个格子都可以选或不选，但最多选一个）；  
- 当\(i > M+1\)时，\(f(i) = f(i-1) + f(i-M-1)\)（第\(i\)个格子不选时，方案数等于\(f(i-1)\)；选时，前一个选的格子最多在\(i-M-1\)位置，方案数等于\(f(i-M-1)\)）。  

### 矩阵加速的核心逻辑  
为了计算\(f(N)\)（\(N\)极大），我们需要将递推式转化为**矩阵乘法**。例如，对于\(M=2\)，递推式是\(f(i) = f(i-1) + f(i-3)\)，状态向量为\([f(i-2), f(i-1), f(i)]\)，转移矩阵为：  
\[
\begin{bmatrix}
0 & 0 & 1 \\
1 & 0 & 0 \\
0 & 1 & 1 \\
\end{bmatrix}
\]  
通过矩阵乘法，状态向量会从\([f(i-2), f(i-1), f(i)]\)转移到\([f(i-1), f(i), f(i+1)]\)。重复这个过程\(N-M-1\)次，即可得到\(f(N)\)。  

### 可视化设计思路  
我们可以用**8位像素风格**动画展示矩阵加速的过程：  
- **状态向量**用彩色像素块表示（如\(f(i)\)用红色，\(f(i-1)\)用蓝色）；  
- **矩阵乘法**用“像素块移动”动画展示（如转移矩阵的第1行乘状态向量，得到新的\(f(i+1)\)）；  
- **快速幂**用“倍数增长”动画展示（如从\(2^1\)到\(2^2\)，再到\(2^3\)，逐步计算矩阵的幂）；  
- **音效**：矩阵乘法时播放“叮”的音效，快速幂完成时播放“胜利”音效。  


## 2. 精选优质题解参考

### 题解一：Imakf（赞：17）  
* **点评**：  
  这道题解的**核心亮点**是**清晰的递推式推导与矩阵构造**。作者通过小例子（如\(M=1\)、\(M=2\)）总结出递推式，并给出了转移矩阵的通用结构（第一行最后一个元素为1，对角线下方一行为1，最后一行最后一个元素为1）。代码中的矩阵快速幂实现简洁，适合初学者理解。  

### 题解二：Adove（赞：6）  
* **点评**：  
  这道题解的**核心亮点**是**前缀和优化与矩阵构造的结合**。作者将递推式转化为前缀和形式（\(s(i) = s(i-1) + s(i-M-1)\)），并构造了一个\((M+2) \times (M+2)\)的矩阵，处理了前缀和的转移。代码中的矩阵初始化与快速幂实现严谨，边界条件（如\(n \leq M\)）处理到位。  

### 题解三：Flandre_495（赞：1）  
* **点评**：  
  这道题解的**核心亮点**是**从暴力DP到矩阵加速的逐步优化**。作者先写出暴力DP代码（\(O(N^2)\)），再优化为\(O(N)\)的递推式，最后引入矩阵加速。这种“循序渐进”的思路有助于理解矩阵加速的必要性，适合新手入门。  


## 3. 核心难点辨析与解题策略

### 关键点1：递推式的推导  
* **分析**：  
  递推式是矩阵加速的基础。通过小例子（如\(M=1\)时，\(f(1)=2\)、\(f(2)=3\)、\(f(3)=5\)），可以发现\(f(i)\)等于“不选第\(i\)个格子的方案数”（\(f(i-1)\)）加上“选第\(i\)个格子的方案数”（\(f(i-M-1)\)）。  
* 💡 **学习笔记**：递推式的推导需要“从小例子找规律”，再验证规律的正确性。  

### 关键点2：矩阵的构造  
* **分析**：  
  矩阵的构造需要对应递推式的转移逻辑。例如，对于\(f(i) = f(i-1) + f(i-M-1)\)，状态向量是\([f(i-M-1), f(i-M), ..., f(i-1)]\)，转移矩阵需要将其转移到\([f(i-M), ..., f(i-1), f(i)]\)。矩阵的第一行对应\(f(i)\)的计算（\(f(i-1) + f(i-M-1)\)），其余行对应状态的平移。  
* 💡 **学习笔记**：矩阵的构造要“对应状态转移”，每一行代表新状态的一个元素。  

### 关键点3：矩阵快速幂的实现  
* **分析**：  
  矩阵快速幂的实现需要注意**矩阵乘法的顺序**（左乘还是右乘）、**模运算**（防止溢出）、**单位矩阵的初始化**（快速幂的初始值）。例如，在Adove的代码中，矩阵乘法是左乘，单位矩阵的对角线元素为1。  
* 💡 **学习笔记**：矩阵快速幂的模板需要熟练掌握，尤其是模运算的处理。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合Imakf、Adove的题解，提炼出矩阵加速的通用实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <cstring>
  using namespace std;

  typedef long long ll;
  const int MOD = 1e9+7;
  const int MAX_M = 20;

  struct Matrix {
      ll a[MAX_M][MAX_M];
      Matrix() { memset(a, 0, sizeof(a)); }
  };

  Matrix multiply(const Matrix& A, const Matrix& B, int m) {
      Matrix res;
      for (int i = 0; i < m; ++i) {
          for (int k = 0; k < m; ++k) {
              if (A.a[i][k] == 0) continue;
              for (int j = 0; j < m; ++j) {
                  res.a[i][j] = (res.a[i][j] + A.a[i][k] * B.a[k][j]) % MOD;
              }
          }
      }
      return res;
  }

  Matrix matrix_pow(Matrix A, ll p, int m) {
      Matrix res;
      for (int i = 0; i < m; ++i) res.a[i][i] = 1; // 单位矩阵
      while (p > 0) {
          if (p & 1) res = multiply(res, A, m);
          A = multiply(A, A, m);
          p >>= 1;
      }
      return res;
  }

  int main() {
      ll n;
      int m;
      cin >> n >> m;
      if (n <= m) {
          cout << n + 1 << endl;
          return 0;
      }
      int size = m + 1;
      Matrix trans;
      // 构造转移矩阵
      trans.a[0][size-1] = 1;
      trans.a[size-1][size-1] = 1;
      for (int i = 1; i < size; ++i) {
          trans.a[i][i-1] = 1;
      }
      // 初始状态向量：[f(1), f(2), ..., f(m+1)]
      Matrix state;
      for (int i = 0; i < size; ++i) {
          state.a[0][i] = i + 2; // f(i+1) = (i+1)+1 = i+2
      }
      // 计算 trans^(n - m - 1)
      Matrix pow_trans = matrix_pow(trans, n - m - 1, size);
      // 状态向量乘转移矩阵的幂
      Matrix result;
      for (int i = 0; i < size; ++i) {
          for (int k = 0; k < size; ++k) {
              result.a[0][i] = (result.a[0][i] + state.a[0][k] * pow_trans.a[k][i]) % MOD;
          }
      }
      cout << result.a[0][size-1] << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **矩阵结构**：用`struct Matrix`表示矩阵，`multiply`函数实现矩阵乘法，`matrix_pow`函数实现矩阵快速幂。  
  2. **转移矩阵构造**：根据递推式构造转移矩阵，第一行最后一个元素为1，对角线下方一行为1，最后一行最后一个元素为1。  
  3. **初始状态**：初始状态向量是\([f(1), f(2), ..., f(m+1)]\)，其中\(f(i) = i+1\)。  
  4. **快速幂计算**：计算转移矩阵的\(n-m-1\)次幂，再乘初始状态向量，得到最终结果。  


### 针对各优质题解的片段赏析

#### 题解一：Imakf的矩阵构造  
* **亮点**：简洁的转移矩阵构造，符合递推式的逻辑。  
* **核心代码片段**：  
  ```cpp
  // 构造转移矩阵（m=2时）
  trans.a[0][2] = 1; // 第一行最后一个元素为1
  trans.a[2][2] = 1; // 最后一行最后一个元素为1
  for (int i = 1; i < 3; ++i) {
      trans.a[i][i-1] = 1; // 对角线下方一行为1
  }
  ```  
* **代码解读**：  
  这段代码构造了\(m=2\)时的转移矩阵。第一行最后一个元素为1，对应\(f(i) = f(i-1) + f(i-3)\)中的\(f(i-3)\)；最后一行最后一个元素为1，对应\(f(i-1)\)；对角线下方一行为1，对应状态的平移（如\(f(i-2)\)转移到\(f(i-1)\)）。  
* 💡 **学习笔记**：转移矩阵的构造要“对应递推式的每一项”。  

#### 题解二：Adove的前缀和优化  
* **亮点**：将递推式转化为前缀和，简化矩阵构造。  
* **核心代码片段**：  
  ```cpp
  // 初始状态向量（前缀和）
  B.v[1][1] = m + 1; // s(0) = m+1
  for (int i = 2; i <= m+2; ++i) {
      B.v[i][1] = 1; // f(1)到f(m+1)都是1
  }
  ```  
* **代码解读**：  
  这段代码初始化了前缀和的状态向量。\(s(0)\)表示前\(0\)个格子的方案数（即1），但作者这里用\(m+1\)表示前\(m+1\)个格子的方案数之和，简化了后续的转移。  
* 💡 **学习笔记**：前缀和可以简化递推式，减少矩阵的大小。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**“像素跳房子：矩阵加速大挑战”**（FC红白机风格）  

### 核心演示内容  
1. **初始状态**：屏幕显示\(M=2\)的初始状态向量\([f(1)=2, f(2)=3, f(3)=4]\)（用红、蓝、绿像素块表示）。  
2. **矩阵乘法**：转移矩阵\(\begin{bmatrix}0&0&1\\1&0&0\\0&1&1\end{bmatrix}\)从右侧滑入，与状态向量相乘。例如，计算\(f(4) = f(3) + f(1) = 4 + 2 = 6\)，红色像素块（\(f(1)\)）和绿色像素块（\(f(3)\)）合并成新的红色像素块（\(f(4)\)）。  
3. **快速幂**：屏幕上方显示“快速幂：2^1”，转移矩阵变为\(\begin{bmatrix}0&1&1\\0&0&1\\1&0&1\end{bmatrix}\)（平方后的矩阵），与状态向量相乘得到\([f(2)=3, f(3)=4, f(4)=6]\)。  
4. **结果展示**：当计算到\(N=5\)时，屏幕显示最终结果\(f(5)=9\)（黄色像素块），伴随“胜利”音效。  

### 交互设计  
- **单步执行**：点击“下一步”按钮，逐步展示矩阵乘法的过程。  
- **自动播放**：点击“开始”按钮，动画自动播放，速度可调（滑块从“慢”到“快”）。  
- **重置**：点击“重置”按钮，回到初始状态。  

### 设计理由  
- **像素风格**：符合青少年的审美，唤起对经典游戏的回忆，增加学习兴趣。  
- **动画效果**：用像素块的移动和合并展示矩阵乘法，直观理解状态转移的过程。  
- **音效**：关键操作（如矩阵乘法、快速幂）的音效，强化记忆点。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
矩阵加速递推适用于**大数量级的线性递推问题**（如斐波那契数列、广义斐波那契数列、计数类DP）。例如：  
- 计算\(F(n) = a \cdot F(n-1) + b \cdot F(n-2)\)（\(n \leq 10^{18}\)）；  
- 计算“有多少种方式走到第\(n\)级台阶，每次走1或2步”（斐波那契数列）；  
- 计算“有多少种方式排列\(n\)个元素，满足某些约束条件”（如互不侵犯问题）。  

### 练习推荐 (洛谷)  
1. **洛谷 P1939 矩阵加速递推**  
   🗣️ **推荐理由**：这是矩阵加速的模板题，要求计算\(F(n) = F(n-1) + F(n-2) + F(n-3)\)（\(n \leq 10^{18}\)），适合巩固矩阵构造与快速幂的实现。  
2. **洛谷 P3390 矩阵快速幂**  
   🗣️ **推荐理由**：这是矩阵快速幂的基础题，要求计算矩阵的幂，适合熟悉矩阵乘法的实现。  
3. **洛谷 P5004 专心OI - 跳房子**  
   🗣️ **推荐理由**：本题的进阶版，要求处理更大的\(M\)（\(M \leq 15\)），适合强化递推式推导与矩阵构造的能力。  


## 7. 学习心得与经验分享 (若有)  
- **Imakf的经验**：“我在解决这个问题时，最初卡在了递推式的推导上，后来通过小例子找规律，才发现了\(f(i) = f(i-1) + f(i-M-1)\)的递推式。”  
  **点评**：小例子是推导递推式的关键，尤其是对于计数类问题，从小规模数据入手可以快速找到规律。  
- **Adove的经验**：“矩阵的构造需要对应递推式的转移逻辑，每一行代表新状态的一个元素，每一列代表旧状态的一个元素。”  
  **点评**：矩阵的构造要“一一对应”，避免混淆行和列的含义。  


## 结语  
本次关于“专心OI - 跳房子”的C++解题分析就到这里。希望这份学习指南能帮助大家理解矩阵加速递推的核心思想，掌握大数量级递推问题的解决方法。记住，**矩阵加速是处理大\(N\)问题的“神器”**，只要掌握了递推式和矩阵构造，就能解决很多看似不可能的问题！💪  

下次我们再一起探索新的编程挑战！

---
处理用时：173.81秒
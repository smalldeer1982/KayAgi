# 题目信息

# 「SWTR-7」Scores（hard version）

## 题目背景

#### 本题是 Scores 的 hard 版本。注意题目限制与 [easy](https://www.luogu.com.cn/problem/P7873) 版本不同。

#### 请注意特殊的时空限制。

## 题目描述

小 A 的班上有 $n$ 个学生。最近他们进行了一场考试，共有 $m$ 个学科。第 $i$ 个学生第 $j$ 门学科的得分为**整数** $s_{i,j}\ (0\leq s_{i,j}\leq 100)$。

同学们很重视自己在班上的排名，所以他们经常会比较自己和别的同学的分数。如果一个学生 $i$ **至少有一门学科**的分数比 $j$ **高**，ta 就会觉得自己不比 $j$ 差；相反，如果 ta **每门学科**的分数都比 $j$ **低**，ta 就会觉得自己被 $j$ 吊打了。

实际上，**上述两种情况并不是严格意义上相反的**。但是喜好八卦的小 A 打听到了每两个同学之间的分数情况，他惊讶地发现：**一个同学 $i$ 要么被 $j$ 吊打，要么不比 $j$ 差。** 同时，**如果 $i,j$ 被同一个人吊打，或同时吊打同一个人，则他们之间也有一方被另一方吊打**。我们用一个矩阵 $a_{i,j}\ (i\neq j)$ 来描述小 A 知道的同学们之间的分数关系：$a_{i,j}=0$ 表示 $i$ 被 $j$ 吊打；$a_{i,j}=1$ 表示 $i$ 不比 $j$ 差。

小 A 想知道这种情况会不会发生，即是否存在这样一张 $n\times m$ 的成绩表 $s$ 满足矩阵 $a$ 所描述的分数关系，从而确定有没有撒谎的同学。如果存在 $s$，请先输出 $\texttt{YES}$，再**任意**输出一种符合要求的成绩表；否则输出 $\texttt{NO}$。

注意：这里所求的 $s$ 所需满足的条件是 $a$ 的限制，而**不只是**小 A 所发现的性质，因为**他发现的性质已经在给出的 $a$ 中体现**。

## 说明/提示

**「Special Judge」**

**本题使用 Special Judge。请认真阅读输出格式，输出格式有误可能导致 UKE 或 WA。**

SPJ 首先会判断你的第一行输出是否与答案相同。  
如果相同且答案为 $\texttt{YES}$，则 SPJ 会判断你的输出是否符合所有限制。  
如果有解且你输出 $\texttt{YES}$，但给出方案错误，你将获得该测试点 $50\%$ 的分数。

你需要满足的限制如下：  
- $0\leq s_{i,j}\leq 100$。
- 对于任意 $i,j\ (i\neq j)$，若 $a_{i,j}=0$，则对于任意 $k\ (1\leq k\leq m)$，有 $s_{i,k}<s_{j,k}$；若 $a_{i,j}=1$，则存在一个 $k\in [1,m]$，使得 $s_{i,k}>s_{j,k}$。

你需要注意的是，所有输出都应严格符合输出格式。如果你对答案的存在性判断正确，但是输出方案时 $s_{i,j}<0$ 或 $s_{i,j}>100$，SPJ 会判定为 WA，得 $0$ 分，而不是 $50\%\ \times$ 该测试点分数。

**「数据范围与约定」**

本题共有 6 个测试点。

- Testcase #0（1 point）：是样例。
- Testcase #1（10 points）：$n=1$。
- Testcase #2（10 points）：$m=1$。
- Testcase #3（30 points）：$m=2$。
- Testcase #4（20 points）：$a_{i,j}=1\ (i\neq j)$。
- Testcase #5（29 points）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n,m\leq 100$，$a_{i,j}\in\{0,1\}$，$T=50$（除 Testcase #0）。  
对于 $a$ 的限制：若 $a_{i,j}=a_{i,k}=0$，则 $a_{j,k}$ 和 $a_{k,j}$ 中至少有一个为 $0$；若 $a_{i,k}=a_{j,k}=0$，则 $a_{i,j}$ 和 $a_{j,i}$ 中至少有一个为 $0$。  
对于所有测试点，**时间限制 500ms，空间限制 16MB。**

**「题目来源」**

[Sweet Round 07](https://www.luogu.com.cn/contest/51773) A2。  
idea & solution & data：[Alex_Wei](https://www.luogu.com.cn/user/123294)；验题：[chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
5
5 3
0 1 1 1 1
1 0 1 1 1
1 1 0 1 1
1 1 1 0 1
1 1 1 1 0
2 7
0 1
0 0
5 4
0 1 1 0 1
0 0 0 0 1
0 1 0 0 1
1 1 1 0 1
1 1 1 1 0
3 1
0 1 1
1 0 1
1 1 0
3 2
0 1 0
0 0 1
1 0 0```

### 输出

```
YES
100 99 97
98 100 99
95 97 100
0 98 100
99 99 99
YES
98 100 94 98 72 53 53
97 99 93 97 71 52 52
YES
90 80 70 60
50 40 30 20
60 50 40 30
100 90 80 70
40 60 80 100
NO
NO```

# AI分析结果

# 💡 Kay的C++算法解析：「SWTR-7」Scores（hard version）深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：构造性算法 + 图论（拓扑排序/并查集）  

🗣️ **初步分析**：  
解决这道题的关键，是**通过图论工具处理学生间的“吊打关系”，再构造符合条件的分数表**。可以把问题比作“给学生排座位”：  
- 若学生A被B吊打（A的每门分数都比B低），则A必须坐在B的“后面”（分数更低）；  
- 若A不比B差（A至少有一门分数比B高），则A不能完全坐在B后面（至少有一门分数更高）。  

题目中的条件（如“被同一人吊打则互相有吊打关系”）暗示，**吊打关系具有传递性且可划分为“块”**（类似班级中的“小组”，小组内的学生有明确的先后顺序，小组间则互不吊打）。核心算法流程如下：  
1. **块划分**：用**并查集**将互相有吊打关系的学生归为一个块（小组）；  
2. **排名确定**：对每个块内的学生进行**拓扑排序**，确定他们的相对“先后顺序”（即分数的高低排名）；  
3. **分数构造**：为每个块分配不同的分数区间（如块1的分数区间是[80,100]，块2是[60,79]），块内学生的分数按排名递减，同时用不同科目区分块间（如块1的第一门分数高、第二门低，块2则相反）。  

**可视化设计思路**：  
- 用**像素块**表示学生，不同颜色代表不同块；  
- 动画展示**并查集合并**（两个像素块变成同色）、**拓扑排序**（像素块按顺序排列）、**分数生成**（像素块上的数字变化）；  
- 关键操作（如合并块、确定排名）伴随**“叮”的像素音效**，分数构造完成时播放“胜利”音效。  


## 2. 精选优质题解参考

### 题解一（来源：by_chance）  
* **点评**：这份题解的思路非常清晰，完美覆盖了所有测试点。作者用**并查集**处理块划分（将互相吊打的学生归为一组），再通过**统计每个学生被多少人吊打**来确定块内排名（类似拓扑排序的入度统计）。构造分数时，作者用**sum变量记录已处理的块大小**，为每个块分配独立的分数区间（如块1的第一门分数是sum+块大小，块2则是sum+块大小+...），确保块间分数不重叠。代码规范（变量名如`rk`表示排名、`root`表示块的根节点），边界处理严谨（如m=1时的特判），是一份非常值得参考的实现。  

### 题解二（来源：intel_core）  
* **点评**：作者的思路与题解一类似，但用**拓扑排序**（队列实现）代替了入度统计，更直观地展示了块内排名的确定过程。构造分数时，作者用**组号+排名**的方式生成分数（如第一门分数是组内排名，第二门是100-组号+排名），确保块间分数互不吊打。代码结构清晰（分步骤处理输入、拓扑排序、分组、构造分数），适合初学者理解拓扑排序的应用。  

### 题解三（来源：enucai）  
* **点评**：作者用**图结构化简**的方式解释了块的形成（将吊打关系转化为链），帮助理解题目条件的隐含意义。代码中用**并查集**合并块，**统计入度**确定排名，构造分数时用**块的根节点**作为基准（根节点的分数最高，块内其他学生分数递减）。虽然代码简洁，但思路与前两份题解一致，适合巩固构造性算法的核心逻辑。  


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何处理吊打关系的传递性？**  
- **分析**：题目中“被同一人吊打则互相有吊打关系”的条件，意味着吊打关系具有传递性（如A被B吊打，B被C吊打，则A被C吊打）。若直接处理所有关系，会非常复杂。**解决方法**：用**并查集**将互相有吊打关系的学生归为一个块（小组），块内的学生必须有明确的先后顺序（排名），块间则互不吊打。  

### 2. **难点2：如何构造符合条件的分数？**  
- **分析**：分数需要满足两个条件：① 块内学生的分数按排名递减（被吊打的学生分数更低）；② 块间学生的分数互不吊打（至少有一门分数更高）。**解决方法**：为每个块分配不同的分数区间（如块1的第一门分数是[80,100]，块2是[60,79]），块内学生的分数按排名递减；同时用不同科目区分块间（如块1的第一门分数高、第二门低，块2则相反），确保块间学生互不吊打。  

### 3. **难点3：如何处理m=1的特殊情况？**  
- **分析**：当m=1时，分数只有一门，此时“吊打关系”等价于“分数更低”，“不比差关系”等价于“分数更高”。若存在多个块（小组），则块间学生的分数无法同时满足“互不吊打”（因为只有一门分数，块1的分数高，块2的分数低，则块2的学生被块1的学生吊打，与块间互不吊打的条件矛盾）。**解决方法**：m=1时，必须只有一个块（所有学生在同一个小组），否则无解。  

### ✨ 解题技巧总结  
- **块划分**：用并查集处理传递性关系，将问题分解为多个独立的子问题（块内排名）；  
- **排名确定**：用拓扑排序或入度统计确定块内学生的相对顺序；  
- **分数构造**：为每个块分配独立的分数区间，用不同科目区分块间，确保条件满足；  
- **特判处理**：注意m=1、n=1等特殊情况，避免遗漏。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了by_chance和intel_core的思路，用并查集划分块，入度统计确定排名，构造分数时块间分数区间分开。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

const int MAXN = 110;
int a[MAXN][MAXN], rk[MAXN], fa[MAXN], cnt[MAXN], ans[MAXN][MAXN];
vector<int> g[MAXN];

int get(int x) { return fa[x] == x ? x : fa[x] = get(fa[x]); }
void Union(int x, int y) { fa[get(x)] = get(y); }

int main() {
    int t, T, n, m;
    cin >> t >> T;
    while (T--) {
        memset(rk, 0, sizeof(rk));
        memset(cnt, 0, sizeof(cnt));
        for (int i = 0; i < MAXN; i++) g[i].clear();
        cin >> n >> m;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                cin >> a[i][j];
        
        // 并查集划分块
        for (int i = 1; i <= n; i++) fa[i] = i;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                if (i != j && a[i][j] == 0) Union(i, j);
        for (int i = 1; i <= n; i++) g[get(i)].push_back(i);
        
        // 确定块内排名（入度统计）
        bool flag = true;
        for (int x = 1; x <= n; x++) {
            if (g[x].empty()) continue;
            memset(cnt, 0, sizeof(cnt));
            for (int i = 0; i < g[x].size(); i++)
                for (int j = 0; j < g[x].size(); j++) {
                    int u = g[x][i], v = g[x][j];
                    if (u != v && a[u][v] == 0) cnt[u]++;
                }
            // 检查排名是否唯一
            vector<bool> vis(g[x].size(), false);
            for (int i = 0; i < g[x].size(); i++) {
                int u = g[x][i];
                if (vis[cnt[u]]) { flag = false; break; }
                vis[cnt[u]] = true;
            }
            if (!flag) break;
            // 保存排名
            for (int i = 0; i < g[x].size(); i++) rk[g[x][i]] = cnt[g[x][i]];
        }
        
        // 特判m=1
        if (m == 1) {
            int blocks = 0;
            for (int x = 1; x <= n; x++) if (!g[x].empty()) blocks++;
            if (blocks != 1) flag = false;
        }
        
        if (!flag) { cout << "NO" << endl; continue; }
        
        // 构造分数
        int sum = 0;
        for (int x = 1; x <= n; x++) {
            if (g[x].empty()) continue;
            // 块的根节点（排名0的学生）
            int root = -1;
            for (int i = 0; i < g[x].size(); i++)
                if (rk[g[x][i]] == 0) root = g[x][i];
            // 分配根节点的分数（块间分数区间分开）
            ans[root][1] = sum + g[x].size(); // 第一门分数：块大小+已处理的块大小
            ans[root][2] = 100 - sum;         // 第二门分数：100-已处理的块大小
            for (int j = 3; j <= m; j++) ans[root][j] = 100; // 其余门满分
            // 块内其他学生分数递减
            for (int i = 0; i < g[x].size(); i++) {
                int u = g[x][i];
                if (u == root) continue;
                for (int j = 1; j <= m; j++)
                    ans[u][j] = ans[root][j] - rk[u];
            }
            sum += g[x].size(); // 更新已处理的块大小
        }
        
        // 输出结果
        cout << "YES" << endl;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++)
                cout << ans[i][j] << " ";
            cout << endl;
        }
    }
    return 0;
}
```  
* **代码解读概要**：  
  1. **输入处理**：读取测试用例和学生间的关系矩阵；  
  2. **块划分**：用并查集将互相吊打的学生归为一个块；  
  3. **排名确定**：统计每个学生被多少人吊打（入度），确定块内排名；  
  4. **特判处理**：m=1时检查是否只有一个块；  
  5. **分数构造**：为每个块分配分数区间，块内学生分数递减；  
  6. **输出结果**：输出YES和分数表。  


### 题解一（by_chance）核心代码片段赏析  
* **亮点**：用`sum`变量记录已处理的块大小，为每个块分配独立的分数区间，确保块间分数不重叠。  
* **核心代码片段**：  
```cpp
int sum = 0;
for (int x = 1; x <= n; x++) {
    if (g[x].empty()) continue;
    int root = ...; // 块的根节点
    ans[root][1] = sum + g[x].size(); // 第一门分数：块大小+已处理的块大小
    ans[root][2] = 100 - sum;         // 第二门分数：100-已处理的块大小
    for (int j = 3; j <= m; j++) ans[root][j] = 100;
    for (int i = 0; i < g[x].size(); i++) {
        int u = g[x][i];
        if (u == root) continue;
        for (int j = 1; j <= m; j++)
            ans[u][j] = ans[root][j] - rk[u]; // 块内学生分数递减
    }
    sum += g[x].size(); // 更新已处理的块大小
}
```  
* **代码解读**：  
  - `sum`变量记录已处理的块大小，比如第一个块的大小是5，`sum`初始为0，所以第一个块的第一门分数是0+5=5，第二门是100-0=100；第二个块的大小是3，`sum`变为5，所以第二个块的第一门分数是5+3=8，第二门是100-5=95。这样，第一个块的第一门分数（5）比第二个块的（8）低，但第二门分数（100）比第二个块的（95）高，确保块间学生互不吊打。  
  - 块内学生的分数是根节点的分数减去排名（`rk[u]`），比如根节点的分数是5，排名1的学生分数是5-1=4，排名2的是5-2=3，确保块内学生按排名递减。  
* 💡 **学习笔记**：用`sum`变量分配块间分数区间，是构造性算法中常用的技巧，能有效避免块间分数重叠。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**像素学生的“分数排队”游戏**  
### 设计思路简述  
采用**8位像素风格**（类似FC红白机游戏），用像素块表示学生，不同颜色代表不同块（如红色块、蓝色块）。动画展示**块划分**、**排名确定**、**分数构造**的过程，结合**像素音效**（如合并块时的“叮”声、分数构造完成时的“胜利”声）和**游戏化交互**（如“单步执行”、“自动播放”），让学习者直观理解算法逻辑。  


### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧显示**像素学生矩阵**（每个学生是一个16x16的像素块，颜色随机）；  
   - 屏幕右侧显示**控制面板**（包含“开始/暂停”、“单步”、“重置”按钮，速度滑块）；  
   - 背景播放**8位风格的轻松BGM**（如《超级马里奥》的背景音乐）。  

2. **块划分（并查集合并）**：  
   - 当两个学生有吊打关系（`a[i][j] == 0`）时，对应的像素块会**慢慢靠近**，并变成**同一种颜色**（如红色），伴随**“叮”的音效**；  
   - 合并完成后，屏幕上方显示提示：“学生A和学生B被归为同一组！”。  

3. **排名确定（入度统计）**：  
   - 每个像素块的下方显示**入度（被多少人吊打）**（如“入度：2”）；  
   - 入度为0的像素块（排名第一的学生）会**闪烁**，并移动到屏幕左侧的“排名队列”中，伴随**“滴”的音效**；  
   - 队列中的像素块按入度从小到大排列（排名从高到低）。  

4. **分数构造**：  
   - 每个块的根节点（排名第一的学生）会**弹出分数框**（如“第一门：80，第二门：100”）；  
   - 块内其他学生的分数框会**从根节点的分数递减**（如“第一门：79，第二门：99”），伴随**“唰”的音效**；  
   - 分数构造完成后，屏幕显示**“分数表生成成功！”**，并播放**胜利音效**（如《魂斗罗》的通关音乐）。  

5. **交互控制**：  
   - **单步执行**：点击“单步”按钮，动画执行一步（如合并一个块、确定一个排名）；  
   - **自动播放**：拖动速度滑块调整播放速度（如“慢”、“中”、“快”），动画自动执行；  
   - **重置**：点击“重置”按钮，动画回到初始状态。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
本题的核心技巧（**并查集划分块+拓扑排序确定排名+构造性分数生成**）可用于解决以下问题：  
- **图论构造题**：如构造满足某种边关系的图（如无环图、有向无环图）；  
- **排名问题**：如根据比赛结果构造选手的排名（如循环赛排名）；  
- **约束满足问题**：如构造满足多个约束条件的解（如时间表安排、资源分配）。  


### 练习推荐 (洛谷)  
1. **洛谷 P7873** - 「SWTR-7」Scores（easy version）  
   - 🗣️ **推荐理由**：本题的简单版本，不需要处理块划分，直接构造分数，适合入门。  
2. **洛谷 P3953** - 逛公园  
   - 🗣️ **推荐理由**：考察拓扑排序的应用，需要处理图中的环和路径问题，是拓扑排序的经典练习。  
3. **洛谷 P4017** - 最大食物链计数  
   - 🗣️ **推荐理由**：考察拓扑排序和动态规划的结合，需要统计图中的路径数量，适合巩固拓扑排序的应用。  


## 7. 学习心得与经验分享 (若有)  
**参考经验 (来自enucai)**：“我在解决这个问题时，最初没有想到用并查集划分块，导致代码非常复杂。后来通过画图分析，发现吊打关系可以化简为链结构，才想到用并查集处理。这让我意识到，**画图是理解复杂关系的有效方法**。”  
**点评**：enucai的经验很典型。当遇到复杂的关系问题时，画图（如用节点表示学生，边表示吊打关系）能帮助我们直观理解问题的结构，从而找到正确的解决方法。  


## 结语  
本次关于“「SWTR-7」Scores（hard version）”的C++解题分析就到这里。希望这份学习指南能帮助大家理解构造性算法和图论的应用。记住，**构造性问题的关键是将抽象的条件转化为具体的结构（如块、排名），再通过代码实现**。下次我们再一起探索新的编程挑战！💪

---
处理用时：190.84秒
# 题目信息

# 「SvR-1」Hack Function!

## 题目背景

**Problem Number:** $\textit{63}$

小 C 坐在 J-PSC2077 的赛场（题目可于下方「**题目附件**」处下载）上，他早已年逾七旬，但作为 Z 队选手还是成功参赛。

## 题目描述

此时的 J-PSC 终于改成了 CF 赛制，小 C 迅速地 AK 了 Day 1，他发现 T2 function 比较好 Hack，题目的人话翻译如下：

> 对于一个数 $A$，定义函数 $f(A)$ 如下：
> 
> 1. 先把 $A$ 变成 $k$ 进制数 $B$。
> 2. 将 $A$ 替换为 $B$ 各位之和。
> 3. 返回执行第 1 步，直到 $B$ 是一位数为止。
> 4. 记 $x$ 表示 $A$ 此时的值（十进制）。
> 此时 $f(A) = x$，$f(A)$ 称作 $A$ 关于 $k$ 的**位和函数**。
>
> 给定 $k, l, r, p$，求出 $\sum_{i = l}^r f(i^i) \bmod p$ 的值。
>
> **特别地，当 $\sum_{i = l}^r f(i^i) = p$ 时，输出 $\texttt{perfect}$。**

小 C 迅速秒了该题，当他翻看别人的代码时，发现他们用的全是暴力枚举。（因为机子跑得飞快）

好不容易看到一个人，他的代码里竟然没有一个  $\texttt{perfect}$！但由于数据过弱，竟然让他 pp 了。

小 C 突然脑子一热，忘记了怎么构造 Hack 数据，所以他通过 Luogu 6.0 求助于你。

小 C 会告诉你 $k, p$ 的值，你需要构造一组 $l, r$，**使答案输出为 $\texttt{perfect}$**。

**若无法构造，输出两个 $\texttt{-1}$。**

## 说明/提示

#### 样例 1 说明

- 对于数据 $1$，在 $k = 10$ 下，有 $f(2^2) = f(4) = 4$，$f(3^3) = f(27) = 9$，显然 $l = 2, r = 3$ 时原题应该输出 $\texttt{perfect}$。
- 对于数据 $2$，在 $k = 10$ 下，发现不可能满足要求。
- 对于数据 $3$，在 $k = 2$ 下，显然有 $f(1^1) = 1$，但该样例仅用于理解，根据数据规模与约定，我们保证 $k \geq 10$。

#### 数据规模与约定

$$
\newcommand{\arraystretch}{1.5}
\begin{array}{c|c|c|c}\hline\hline
\textbf{Subtask} & \textbf{说明} & \textbf{时限} & \textbf{分值} \\\hline
\textsf{1} & \text{无解} & 1\text{ s} & 3 \\\hline
\textsf{2} & \text{有解且\textbf{\textsf{存在}}一组解使 }1\le l\le r\le 10^5 & 1\text{ s} & 16 \\\hline
\textsf{3} & 1\le p\le 10^7 & 1\text{ s} & 34 \\\hline
\textsf{4} & \text{无特殊限制} & 1.5\text{ s} & 47 \\\hline\hline
\end{array}
$$

对于 $100\%$ 的数据，$10 \leq k \leq 10^3$，$1 \leq p \leq 10^8$，$1 \leq T \leq 10$。

保证时限在 std 用时的 $4$ 倍以上。

#### 评测说明

**本题开启 Special Judge 和捆绑测试。**

你需要保证 $l = r = -1$ 或 $1 \leq l \leq r \leq 10^{18}$ 且 $r - l \leq 10^{15}$，否则 SPJ 会将你的答案判为 $0$ 分。

## 样例 #1

### 输入

```
3
10 13
10 3
2 1```

### 输出

```
2 3
-1 -1
1 1```

# AI分析结果

# 💡 Kay的C++算法解析：「SvR-1」Hack Function! 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（数论）` + `前缀和与循环节处理`

🗣️ **初步分析**：  
解决「Hack Function!」的关键，在于**将复杂的位和函数转化为简单的模运算**，并**利用循环节快速计算区间和**。简单来说，位和函数`f(A)`的本质是`(A-1) mod (k-1) + 1`（比如`k=10`时，`f(27)=9`，因为`27-1=26`，`26 mod 9=8`，`8+1=9`）。这一步就像“把大象放进冰箱”的第一步——打开冰箱门，将复杂问题简化为数学问题。  

接下来，我们需要计算`sum_{i=l}^r f(i^i)`，并让其等于`p`。由于`i^i`的值会非常大，直接计算不可能，因此需要**用扩展欧拉定理求`i^i mod (k-1)`**（因为`f(i^i)`只和`i^i mod (k-1)`有关）。扩展欧拉定理告诉我们，`i^i mod m`（`m=k-1`）在`i`足够大时会进入**循环节**（比如`m=9`，`phi(9)=6`，循环节长度为`lcm(9,6)=18`）。这一步就像“绕操场跑圈”——每一圈的路程相同，我们可以快速计算多圈的总路程。  

**核心难点**：  
1. 证明`f(A)`的模运算结论；  
2. 找到`i^i mod (k-1)`的循环节；  
3. 高效查询区间和等于`p`的`l`和`r`。  

**解决方案**：  
- 用数论知识证明`f(A)`的结论；  
- 用扩展欧拉定理计算`i^i mod (k-1)`，并找到循环节；  
- 用**前缀和+双指针**或**哈希表**处理区间和查询（避免暴力枚举）。  

**可视化设计思路**：  
我们可以设计一个**像素风格的“循环节跑圈”动画**：  
- 屏幕左侧显示`i`从1开始递增，右侧显示`f(i^i)`的值（用不同颜色的像素块表示）；  
- 当`i`进入循环节时，重复的`f`值用闪烁的黄色标记，提示“开始循环”；  
- 底部显示前缀和的变化（用蓝色进度条表示），当进度条达到`p`时，用红色标记当前的`l`和`r`；  
- 交互方面，支持“单步执行”（每点击一次，`i`增加1）、“自动播放”（按一定速度循环），以及“重置”（回到初始状态）。  


## 2. 精选优质题解参考

### 题解一：(来源：yizhiming，赞：4)  
* **点评**：这份题解的**思路非常清晰**，用“双指针”代替了传统的`map`，将区间和查询的复杂度从`O(n log n)`降低到`O(n)`，非常适合处理大规模数据。代码结构工整，变量名（如`phi`表示欧拉函数值，`lcm`表示最小公倍数）含义明确，容易理解。特别是**循环节处理部分**，作者通过计算“整周期”的和，快速调整`r`的值，避免了重复计算，这是解决本题的关键技巧。从实践角度看，代码的时间复杂度（`O(Tkφ(k))`）完全满足题目要求，边界处理也很严谨（比如`f`值为0时调整为`k-1`）。  


### 题解二：(来源：kevinzheng0426，赞：2)  
* **点评**：这份题解的**算法有效性**很高，用`unordered_map`处理前缀和，快速查询`S_r - S_{l-1} = p`的情况。作者对扩展欧拉定理的应用非常熟练，准确找到了`i^i mod (k-1)`的循环节。代码中的`qpow`（快速幂）函数和`f`函数实现简洁，值得学习。不过，`unordered_map`可能存在哈希冲突的问题，在极端情况下可能会影响效率，但对于本题的数据规模来说，完全可以接受。  


### 题解三：(来源：Leasier，赞：6)  
* **点评**：这份题解的**解释性很强**，详细证明了`f(A)`的模运算结论，并分情况讨论了`l`和`r`的位置（比如`r < φ(k-1)`或`r ≥ φ(k-1)`）。作者对循环节的处理非常全面，考虑了“整周期”和“部分周期”的情况，确保了所有可能的`l`和`r`都被覆盖。代码中的`Hash`结构（自定义哈希表）避免了`map`的高时间复杂度，适合处理大规模数据。  


## 3. 核心难点辨析与解题策略

### 1. **关键点1：如何证明`f(A) = (A-1) mod (k-1) + 1`？**  
* **分析**：`f(A)`是`k`进制下的位和直到一位数，根据数论中的模运算性质，`k ≡ 1 mod (k-1)`，因此`k^i ≡ 1^i = 1 mod (k-1)`。所以`A = a_0 + a_1 k + a_2 k^2 + ... + a_m k^m ≡ a_0 + a_1 + a_2 + ... + a_m mod (k-1)`（`a_i`是`k`进制下的各位数字）。重复这个过程，最终`f(A)`就是`A mod (k-1)`，但由于`f(A)`不能为0（位和直到一位数），所以调整为`(A-1) mod (k-1) + 1`。  
* 💡 **学习笔记**：模运算的性质是解决位和问题的关键，要记住`k ≡ 1 mod (k-1)`这个结论。  


### 2. **关键点2：如何找到`i^i mod (k-1)`的循环节？**  
* **分析**：根据扩展欧拉定理，`i^i mod m`（`m=k-1`）的循环节分为两部分：  
  - 前`φ(m)`个`i`（`φ`是欧拉函数）没有循环；  
  - 从`φ(m)+1`开始，循环节长度为`lcm(m, φ(m))`（`lcm`是最小公倍数）。  
  例如，`m=9`，`φ(9)=6`，循环节长度为`lcm(9,6)=18`，所以`i≥7`时，`i^i mod 9`每18个`i`重复一次。  
* 💡 **学习笔记**：扩展欧拉定理是处理大指数模运算的神器，要记住其循环节的计算方法。  


### 3. **关键点3：如何高效查询区间和等于`p`的`l`和`r`？**  
* **分析**：区间和等于`p`等价于`S_r - S_{l-1} = p`（`S`是前缀和数组）。对于这种问题，有两种常用方法：  
  - **双指针**：由于`f(i^i)`是正数，前缀和`S`单调递增，因此可以用双指针（`l`和`r`）遍历数组，调整`l`和`r`的位置，使得`S_r - S_{l-1} = p`。这种方法的时间复杂度是`O(n)`，非常高效。  
  - **哈希表**：将前缀和`S_{l-1}`存入哈希表，然后查询`S_r - p`是否在哈希表中。这种方法的时间复杂度是`O(n log n)`，适合处理非单调的前缀和。  
* 💡 **学习笔记**：双指针是处理单调前缀和区间查询的最优选择，要学会灵活运用。  


### ✨ 解题技巧总结  
- **问题简化**：将位和函数转化为模运算，减少计算量；  
- **循环节利用**：找到`i^i mod (k-1)`的循环节，快速计算多周期的和；  
- **高效查询**：用双指针或哈希表处理区间和查询，避免暴力枚举；  
- **边界处理**：注意`f`值为0的情况，调整为`k-1`。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了yizhiming和kevinzheng0426的思路，用双指针处理前缀和，用扩展欧拉定理计算`i^i mod (k-1)`，是一份清晰且高效的核心实现。  
* **完整核心代码**：  
  ```cpp
  #include <cstdio>
  #include <iostream>
  using namespace std;
  const int N = 1010;
  typedef long long ll;
  int k, p, t, phi, lcm_val, sum, r_max;
  ll r;
  bool ok;
  int f[N*N + N], s[N*N + N]; // f[i]表示f(i^i), s[i]表示前缀和

  int read() {
      char ch;
      int w = 0, f = 1;
      ch = getchar();
      while (ch < '0' || ch > '9') {
          if (ch == '-') f = -f;
          ch = getchar();
      }
      while (ch >= '0' && ch <= '9') {
          w = w * 10 + ch - '0';
          ch = getchar();
      }
      return w * f;
  }

  int get_phi(int x) { // 计算欧拉函数φ(x)
      int ans = 1;
      for (int i = 2; i * i <= x; i++) {
          if (x % i == 0) {
              ans *= i - 1;
              x /= i;
              while (x % i == 0) {
                  ans *= i;
                  x /= i;
              }
          }
      }
      if (x > 1) ans *= x - 1;
      return ans;
  }

  int gcd(int a, int b) { // 计算最大公约数
      return b ? gcd(b, a % b) : a;
  }

  int qpow(int a, int b, int mod) { // 快速幂：a^b mod mod
      int ans = 1;
      while (b) {
          if (b & 1) ans = (ll)ans * a % mod;
          a = (ll)a * a % mod;
          b >>= 1;
      }
      return ans;
  }

  int get_f(int i, int m, int phi_m) { // 计算f(i^i) = (i^i mod m - 1) mod m + 1（m = k-1）
      int val;
      if (i <= phi_m) {
          val = qpow(i % m, i, m);
      } else {
          val = qpow(i % m, i % phi_m + phi_m, m);
      }
      return val ? val : m; // 如果val为0，调整为m（即k-1）
  }

  int main() {
      t = read();
      while (t--) {
          k = read(); p = read();
          int m = k - 1; // m = k-1
          if (m == 0) { // 特殊情况，k=1，但题目中k≥10，所以不需要处理
              printf("-1 -1\n");
              continue;
          }
          phi = get_phi(m);
          lcm_val = m * phi / gcd(m, phi); // 循环节长度
          r_max = phi + lcm_val; // 预处理到phi + lcm_val，覆盖前phi个和一个循环节
          sum = 0; ok = false;
          l = 1;
          for (r = 1; r <= r_max; r++) {
              f[r] = get_f(r, m, phi);
              s[r] = s[r-1] + f[r];
              sum += f[r];
              while (sum > p) { // 双指针调整l，使得sum ≤ p
                  sum -= f[l];
                  l++;
              }
              if (sum == p) { // 找到符合条件的l和r
                  ok = true;
                  break;
              }
          }
          if (!ok) { // 处理循环节部分
              int cycle_sum = s[r_max] - s[phi]; // 一个循环节的和
              int cnt = (p - sum) / cycle_sum; // 整周期的数量
              sum += cnt * cycle_sum;
              r += cnt * lcm_val; // r增加cnt个循环节
              if (sum == p) {
                  ok = true;
              } else { // 处理剩余部分，最多再跑两个循环节
                  for (int i = 1; i <= 2 * lcm_val; i++) {
                      int idx = phi + (i > lcm_val ? i - lcm_val : i); // 循环节内的索引
                      sum += f[idx];
                      r++;
                      while (sum > p) {
                          sum -= f[l];
                          l++;
                      }
                      if (l > r_max) break; // l超过预处理范围，停止
                      if (sum == p) {
                          ok = true;
                          break;
                      }
                  }
              }
          }
          if (ok) {
              printf("%d %lld\n", l, r);
          } else {
              printf("-1 -1\n");
          }
      }
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **输入处理**：用`read`函数快速读取输入；  
  2. **欧拉函数计算**：`get_phi`函数计算`m=k-1`的欧拉函数值`phi`；  
  3. **快速幂**：`qpow`函数计算`a^b mod mod`，用于求`i^i mod m`；  
  4. **f函数计算**：`get_f`函数根据扩展欧拉定理计算`f(i^i)`；  
  5. **双指针处理前缀和**：遍历`i`从1到`r_max`（`phi + lcm_val`），用双指针调整`l`和`r`，寻找区间和等于`p`的情况；  
  6. **循环节处理**：如果未找到，计算整周期的和，调整`r`的值，再处理剩余部分。  


### 针对各优质题解的片段赏析

#### 题解一：(来源：yizhiming)  
* **亮点**：用双指针处理前缀和，时间复杂度`O(n)`，高效且简洁。  
* **核心代码片段**：  
  ```cpp
  for (r = 1; r <= r_max; r++) {
      f[r] = get_f(r, m, phi);
      s[r] = s[r-1] + f[r];
      sum += f[r];
      while (sum > p) { // 调整l，使得sum ≤ p
          sum -= f[l];
          l++;
      }
      if (sum == p) { // 找到符合条件的l和r
          ok = true;
          break;
      }
  }
  ```  
* **代码解读**：  
  - 循环变量`r`表示当前的右端点，`l`表示当前的左端点；  
  - 每次`r`增加1，计算`f[r]`并更新前缀和`sum`；  
  - 如果`sum`超过`p`，则将`l`右移，减少`sum`的值；  
  - 当`sum`等于`p`时，找到符合条件的`l`和`r`，停止循环。  
* 💡 **学习笔记**：双指针是处理单调前缀和区间查询的“神器”，要记住“右指针扩张，左指针收缩”的逻辑。  


#### 题解二：(来源：kevinzheng0426)  
* **亮点**：用`unordered_map`处理前缀和，快速查询`S_r - S_{l-1} = p`的情况。  
* **核心代码片段**：  
  ```cpp
  unordered_map<int, int> mp;
  for (int r = phi, l = 1; l < phi + k; ) {
      if (r < phi + k && sR <= sL) {
          per[r] = sR;
          mp[mR] = r;
          sR += F[++r];
          if ((mR += F[r]) >= S) mR -= S;
      } else {
          if (mp.find(mL) != mp.end()) {
              al = l;
              ar = mp[mL];
              ar += (sL - per[ar]) / S * k;
              ok = true;
              break;
          }
          if ((mL += F[l]) >= S) mL -= S;
          sL += F[l++];
      }
  }
  ```  
* **代码解读**：  
  - `mp`存储前缀和`S_r`对应的`r`值；  
  - 循环变量`r`表示当前的右端点，`l`表示当前的左端点；  
  - 当`sR <= sL`时，将`S_r`存入`mp`，并扩张`r`；  
  - 否则，查询`mp`中是否存在`S_l - p`，如果存在，找到符合条件的`l`和`r`。  
* 💡 **学习笔记**：哈希表是处理非单调前缀和区间查询的有效工具，但要注意哈希冲突的问题。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：`循环节跑圈大挑战`（8位像素风格）

### 核心演示内容  
- **场景初始化**：屏幕左侧显示`i`从1开始递增（用白色像素块表示），右侧显示`f(i^i)`的值（用不同颜色的像素块表示，比如红色表示`f=1`，蓝色表示`f=2`，依此类推）；  
- **循环节标记**：当`i`进入循环节时（比如`i=phi+1`），重复的`f`值用闪烁的黄色标记，提示“开始循环”；  
- **前缀和显示**：底部显示前缀和的变化（用蓝色进度条表示，进度条的长度对应前缀和的大小）；  
- **目标达成**：当进度条达到`p`时，用红色标记当前的`l`和`r`（比如`l=2`，`r=3`），并播放胜利音效（“叮~”）。  

### 交互与控制  
- **单步执行**：点击“下一步”按钮，`i`增加1，更新`f`值和前缀和；  
- **自动播放**：点击“开始”按钮，动画按每秒5帧的速度自动播放，进度条随之前进；  
- **速度调整**：用滑块调整自动播放的速度（1~10帧/秒）；  
- **重置**：点击“重置”按钮，回到初始状态（`i=1`，`l=1`，`r=1`）。  

### 复古游戏化元素  
- **音效**：每计算一个`f`值，播放短音效（“滴”）；当找到符合条件的`l`和`r`，播放胜利音效（“叮~”）；  
- **积分**：每完成一个循环节，获得10分，积分显示在屏幕右上角；  
- **关卡**：将`i`从1到`phi+lcm_val`分为一个关卡，完成关卡获得“循环节达人”称号。  

### 设计思路  
- **像素风格**：采用8位像素风，营造复古游戏的氛围，让学习更有趣；  
- **颜色标记**：用不同颜色区分`f`值和循环节，帮助学习者快速识别；  
- **交互设计**：支持单步执行和自动播放，让学习者可以自由控制学习节奏；  
- **游戏化元素**：积分和关卡设计，增加学习的成就感，激发学习者的兴趣。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **数论**：`f(A)`的模运算结论可以推广到其他位和问题（比如`k=2`时的二进制位和）；  
- **循环节**：扩展欧拉定理的循环节思想可以用于处理大指数模运算（比如`a^b mod m`，其中`b`很大）；  
- **前缀和与双指针**：双指针处理区间和的思路可以用于解决“滑动窗口”问题（比如求最长不重复子串）。  


### 练习推荐 (洛谷)  
1. **洛谷 P1029** - 最大公约数和最小公倍数问题  
   * 🗣️ **推荐理由**：这道题考察数论中的最大公约数和最小公倍数，帮助你巩固模运算的知识。  
2. **洛谷 P1226** - 【模板】快速幂  
   * 🗣️ **推荐理由**：这道题是快速幂的模板题，帮助你熟练掌握快速幂的实现。  
3. **洛谷 P3372** - 【模板】线段树 1  
   * 🗣️ **推荐理由**：这道题考察线段树的前缀和查询，帮助你理解前缀和的应用。  
4. **洛谷 P1886** - 滑动窗口  
   * 🗣️ **推荐理由**：这道题考察双指针的滑动窗口技巧，帮助你巩固双指针的应用。  


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自 yizhiming)  
> “我在解决这个问题时，最初用了`map`处理前缀和，但发现时间复杂度太高，后来改用双指针，时间复杂度降低到`O(n)`，才通过了所有测试点。这让我意识到，**选择合适的算法比暴力枚举更重要**。”  

**点评**：这位作者的经验很典型。在编程过程中，**算法的选择直接影响程序的效率**。对于单调前缀和的区间查询，双指针是最优选择，而`map`则适合处理非单调的情况。动手尝试不同的算法，才能找到最适合的解决方案。  


## 结语  
本次关于「SvR-1」Hack Function! 的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解数论、循环节和双指针的应用。记住，**编程的乐趣在于解决问题的过程**，只要勤于思考，勇于实践，你一定能成为编程高手！💪  

如果有任何问题，欢迎随时向我提问，我会尽力帮助你！😊

---
处理用时：207.18秒
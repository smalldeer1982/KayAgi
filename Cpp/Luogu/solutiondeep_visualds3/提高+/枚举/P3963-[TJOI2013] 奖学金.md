# 题目信息

# [TJOI2013] 奖学金

## 题目背景

小张最近发表了一篇论文，有一个神秘人物要给小张学院发奖学金。

## 题目描述

小张学院有 $c$ 名学生，第 $i$ 名学生的成绩为 $a_i$，要获得的奖学金金额为 $b_i$。  
要从这 $c$ 名学生中挑出 $n$ 名学生发奖学金。这个神秘人物爱好奇特，他希望得到奖学金的同学的**成绩**的**中位数**尽可能大，但同时，他们的**奖学金总额**不能超过 $f$。


## 说明/提示

### 样例 1 解释

选择成绩为 $5$，$35$，$50$ 的三名同学，奖金总额为 $18 + 30 + 21 = 69$。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10^3$，$c \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $3 \leq n  \leq 10^5$，$n \leq c \leq 2 \times 10^5$，$0 \leq f \leq 2\times 10^9$，$0 \leq a_i \leq 2 \times 10^9$，$0 \leq b_i \leq 10^5$。

## 样例 #1

### 输入

```
3 5 70
30 25
50 21
20 20
5 18
35 30
```

### 输出

```
35```

## 样例 #2

### 输入

```
5 6 9
4 0
4 1
6 3
8 0
10 4
10 5
```

### 输出

```
6```

# AI分析结果



---
# 💡 Kay的C++算法解析：[TJOI2013] 奖学金 深入学习指南 💡

<introduction>
今天我们来一起分析“[TJOI2013] 奖学金”这道题。题目要求我们从c名学生中选出n名，使得他们的成绩中位数尽可能大，同时奖学金总额不超过f。这道题的关键在于如何高效地找到最大的合法中位数，我们将通过贪心策略和数据结构优化来解决这个问题。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心策略 + 数据结构运用（优先队列/堆）

🗣️ **初步分析**：
解决这道题的关键在于“贪心选择最小奖学金”的策略。简单来说，贪心就像我们买东西时，想要用最少的钱买到最多的东西——这里我们需要在满足中位数最大的前提下，让奖学金总和尽可能小。具体来说，当我们枚举某个学生作为中位数时，需要在其成绩较小的一侧选n/2个奖学金最小的学生，在成绩较大的一侧也选n/2个奖学金最小的学生，这样总和才可能不超过f。

- **题解思路**：首先将学生按成绩排序（升序或降序均可，这里我们选升序），然后枚举每个可能的中位数位置。对于每个位置i（作为中位数），我们需要计算左侧（成绩小于等于i的学生）前n/2小的奖学金和，以及右侧（成绩大于等于i的学生）前n/2小的奖学金和。如果这两部分和加上i的奖学金不超过f，则i是一个候选答案。最终取最大的候选答案。
- **核心难点**：如何高效计算左右两侧前n/2小的奖学金和？直接暴力计算会超时，因此需要用优先队列（大根堆）维护当前最小的n/2个数，动态更新和。
- **可视化设计思路**：用像素动画展示排序后的学生数组，每个学生用带成绩和奖学金的像素块表示。枚举中位数时，用高亮框标出当前中位数的位置，左右两侧分别用动态的堆结构（堆叠的像素块）展示当前维护的n/2个最小奖学金，每次插入新元素时，堆顶（最大元素）可能被替换，动画中用颜色变化（如红色表示被弹出，绿色表示新插入）和数值更新来体现。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等，以下题解因逻辑直观、实现高效被选为优质参考：
</eval_intro>

**题解一：作者ycyaw（赞：4）**
* **点评**：此题解用优先队列（大根堆）预处理左右两侧的最小和，思路简洁直接。代码中变量命名如`f[i]`（左侧和）、`g[i]`（右侧和）含义明确，边界处理严谨（如枚举范围限制在`n/2+1 <= i <= c-n/2`）。算法时间复杂度为O(c log n)，适合大规模数据，实践价值高。

**题解二：作者胖头鱼学员（赞：10）**
* **点评**：此题解同样用大根堆维护左右最小和，但代码结构更模块化（`Work`函数处理左右两侧），变量命名清晰（如`sum`记录当前和）。特别值得学习的是，通过控制堆的大小始终为n/2，动态更新和，避免了重复计算。

**题解三：作者YinyuDream（赞：2）**
* **点评**：此题解步骤明确，先排序，再预处理左右和数组（`suma`和`sumb`），最后枚举验证。代码中`priority_queue<int>`的使用规范，边界条件（如堆初始化）处理到位，适合新手学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，主要会遇到以下核心难点，结合优质题解的经验，我们逐一分析：
</difficulty_intro>

1.  **关键点1：如何确定枚举中位数的范围？**
    * **分析**：中位数的位置i必须满足左右各有至少n/2个学生。因此i的范围是`n/2+1 <= i <= c-n/2`（假设数组从1开始）。例如，n=3时，n/2=1，i需≥2且≤c-1。
    * 💡 **学习笔记**：枚举范围的确定是避免无效计算的关键，需根据题目要求（选n名学生）严格推导。

2.  **关键点2：如何高效计算左右两侧前n/2小的奖学金和？**
    * **分析**：直接遍历所有可能的组合会超时（O(c²)），因此用大根堆维护当前最小的n/2个数。堆顶是当前最大的数，当新数更小时，弹出堆顶，更新和。这样每次操作O(log n)，总时间O(c log n)。
    * 💡 **学习笔记**：大根堆适合“维护前k小”的场景——堆顶是最大的，保证堆内都是最小的k个数。

3.  **关键点3：如何处理边界条件（如堆初始化和空堆情况）？**
    * **分析**：初始时，堆需要先填充前n/2个数（左侧）或后n/2个数（右侧），并计算初始和。枚举时，若堆未满（如i<n/2），和设为无穷大（表示无法满足条件）。
    * 💡 **学习笔记**：边界条件的处理需仔细，避免数组越界或和计算错误。

### ✨ 解题技巧总结
<summary_best_practices>
- **排序预处理**：先按成绩排序，方便枚举中位数。
- **堆维护前k小**：用大根堆动态维护当前最小的k个数，高效计算和。
- **双向预处理**：分别计算左侧和右侧的最小和数组（如`f[i]`和`g[i]`），避免重复计算。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，提炼一个基于优先队列的高效实现，代码简洁且易理解。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了ycyaw和胖头鱼学员的思路，使用大根堆预处理左右最小和数组，最后枚举验证。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MAXN = 2e5 + 5;
    struct Student {
        int score;
        int money;
    } students[MAXN];
    int left_sum[MAXN], right_sum[MAXN]; // 左右两侧前n/2小的奖学金和

    bool cmp(const Student& a, const Student& b) {
        return a.score < b.score; // 按成绩升序排序
    }

    int main() {
        int n, c, f;
        scanf("%d%d%d", &n, &c, &f);
        int half = n / 2;
        for (int i = 1; i <= c; ++i) {
            scanf("%d%d", &students[i].score, &students[i].money);
        }
        sort(students + 1, students + c + 1, cmp);

        // 预处理左侧前half小的和
        priority_queue<int> max_heap;
        int sum = 0;
        for (int i = 1; i <= half; ++i) {
            max_heap.push(students[i].money);
            sum += students[i].money;
        }
        left_sum[half] = sum;
        for (int i = half + 1; i <= c - half; ++i) {
            if (students[i].money < max_heap.top()) {
                sum -= max_heap.top();
                max_heap.pop();
                sum += students[i].money;
                max_heap.push(students[i].money);
            }
            left_sum[i] = sum;
        }

        // 预处理右侧前half小的和
        max_heap = priority_queue<int>(); // 清空堆
        sum = 0;
        for (int i = c; i > c - half; --i) {
            max_heap.push(students[i].money);
            sum += students[i].money;
        }
        right_sum[c - half + 1] = sum;
        for (int i = c - half; i >= half + 1; --i) {
            if (students[i].money < max_heap.top()) {
                sum -= max_heap.top();
                max_heap.pop();
                sum += students[i].money;
                max_heap.push(students[i].money);
            }
            right_sum[i] = sum;
        }

        // 枚举中位数，找最大合法值
        int ans = -1;
        for (int i = half + 1; i <= c - half; ++i) {
            if (left_sum[i - 1] + right_sum[i + 1] + students[i].money <= f) {
                ans = students[i].score;
            }
        }
        printf("%d\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：代码首先按成绩排序学生，然后用大根堆预处理左侧和右侧的前half小奖学金和数组（`left_sum`和`right_sum`）。最后枚举每个可能的中位数位置，检查总和是否≤f，取最大的合法成绩。

---
<code_intro_selected>
接下来，我们分析优质题解中的核心代码片段，学习其中的技巧。
</code_intro_selected>

**题解一：作者ycyaw**
* **亮点**：用两个大根堆分别处理左右和，代码简洁，变量命名清晰。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n/2;i++){
        q.push(a[i].mn);
        sum+=a[i].mn;
    }
    for(int i=n/2+1;i<=c-n/2;i++){
        f[i]=sum;
        if(a[i].mn<q.top()){
            sum-=q.top();
            sum+=a[i].mn;
            q.pop();
            q.push(a[i].mn);
        }
    }
    ```
* **代码解读**：这部分预处理左侧前n/2小的和。初始时，将前n/2个学生的奖学金加入大根堆（堆顶是最大的），并计算初始和。之后，遍历每个可能的中位数位置i（i>n/2），若当前学生的奖学金小于堆顶，则替换堆顶，更新和。这样`f[i]`始终保存左侧前n/2小的和。
* 💡 **学习笔记**：大根堆的堆顶是当前最大的元素，替换更小的元素能保证堆内始终是最小的n/2个数。

**题解二：作者胖头鱼学员**
* **亮点**：用`Work`函数模块化处理左右和，代码结构清晰。
* **核心代码片段**：
    ```cpp
    void Work(int u, int v, bool l) {
        int sum = 0, i;
        priority_queue<int> q;
        for (i = l ? c : 1; l ? i > u : i < u ; i += I[l]) {
            sum += a[i].w;
            q.push(a[i].w);
        }
        for (; l ? i >= v : i <= v; i += I[l]) {
            f[l][i] = sum;
            int top = q.top();
            if (top > a[i].w) {
                q.pop();
                sum -= top;
                sum += a[i].w;
                q.push(a[i].w);
            }
        }
    }
    ```
* **代码解读**：`Work`函数通过参数`l`控制遍历方向（左到右或右到左），动态维护堆和和。`I[l]`是方向数组（1或-1），实现双向遍历。这样避免了重复代码，提高了复用性。
* 💡 **学习笔记**：模块化设计能提高代码的可读性和维护性，特别是处理对称逻辑时。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了直观理解“贪心选择最小奖学金”和“堆维护前n/2小”的过程，我们设计一个8位像素风格的动画，模拟学生排序、堆维护和枚举中位数的过程。
\</visualization\_intro\>

  * **动画演示主题**：`奖学金小能手的像素冒险`
  * **核心演示内容**：学生按成绩排序后，用像素块排列在屏幕上（成绩越高越靠右）。枚举中位数时，左右两侧各有一个“奖学金堆”（堆叠的像素块），动态维护前n/2小的奖学金，总和实时显示。当找到合法中位数时，该像素块闪烁绿色并播放胜利音效。

  * **设计思路简述**：8位像素风格（如FC游戏画面）让学习更轻松；堆的动态变化用颜色标记（红色为堆顶，绿色为新插入），总和用数字实时更新，帮助理解堆维护过程；枚举时的高亮框和音效强化关键步骤记忆。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
        - 屏幕左侧显示排序后的学生像素块（每个块显示成绩和奖学金），按成绩升序排列（从左到右成绩递增）。
        - 顶部两个区域分别显示“左侧堆”和“右侧堆”（用堆叠的像素块表示），底部显示当前总和和f的阈值。
        - 控制面板包含“单步”、“自动播放”按钮和速度滑块。

    2.  **预处理左侧堆**：
        - 前n/2个学生的奖学金像素块（左侧前n/2个）被“吸入”左侧堆区域，堆顶（最大的奖学金）用红色标记，总和数字动态增加。
        - 每处理一个学生，堆可能弹出堆顶（红色块消失），新块（绿色）加入，总和更新。

    3.  **预处理右侧堆**：
        - 类似左侧，但从右侧开始，后n/2个学生的奖学金被吸入右侧堆区域，堆顶红色标记，总和动态更新。

    4.  **枚举中位数**：
        - 用黄色高亮框依次框住每个可能的中位数位置i（从右到左枚举，找最大的合法值）。
        - 计算左侧和（左侧堆总和）+ 右侧和（右侧堆总和）+ 当前奖学金，若≤f，高亮框变为绿色，播放“叮”的音效，显示当前成绩为候选答案。

    5.  **结束状态**：
        - 找到最大合法中位数时，该像素块放大并闪烁绿色，背景播放简短的胜利音乐；若没有合法解，显示“-1”并播放提示音。

  * **旁白提示**：
    - （预处理左侧堆时）“现在我们要维护左侧前n/2小的奖学金，堆顶是最大的，这样当新的奖学金更小时，替换堆顶可以保证堆内始终是最小的n/2个！”
    - （枚举中位数时）“看，当前中位数的总和是XX，是否小于等于f？如果是，它就是候选答案！”

\<visualization\_conclusion\>
通过这个像素动画，我们能直观看到堆的动态维护过程和中位数的枚举逻辑，理解“贪心选择最小奖学金”如何帮助找到最大合法中位数。
\</visualization\_conclusion\>

---

## 6\. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
本题的核心是“贪心+堆维护前k小”，这种思路适用于许多需要动态选择最小/最大元素的场景。
\</similar\_problems\_intro\>

  * **通用思路/技巧迁移**：
      - **区间前k小和**：如“选k个数使和最小”问题，可用堆维护。
      - **双指针+堆**：如滑动窗口中的最值问题，结合双指针和堆高效处理。
      - **枚举+预处理**：先排序，再预处理左右信息，最后枚举验证，适用于求最值的问题。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1801 黑匣子**  
        * 🗣️ **推荐理由**：本题需要动态维护前k小元素，与本题的堆应用类似，适合巩固堆的使用。
    2.  **洛谷 P1972 [SDOI2009]HH的项链**  
        * 🗣️ **推荐理由**：本题需要高效查询区间内不同元素个数，可尝试用离线处理+树状数组，拓展数据结构应用。
    3.  **洛谷 P2278 [HNOI2003]操作系统**  
        * 🗣️ **推荐理由**：本题需要用优先队列模拟进程调度，结合时间处理，锻炼贪心和堆的综合应用。

---

## 7\. 学习心得与经验分享 (若有)

\<insights\_intro\>
部分题解作者分享了调试经验，例如ycyaw提到“调了两天才发现叶子节点要乘k”，这些经验对我们很有启发：
\</insights\_intro\>

> **参考经验 (来自 ycyaw)**：“在使用主席树时，叶子节点的处理要注意，若存在多个相同值的奖学金，必须用k乘该值，否则会导致和计算错误。我调了两天才发现这个细节。”

> **点评**：这位作者的经验提醒我们，在处理数据结构（如主席树、堆）时，要特别注意边界条件（如叶子节点、重复元素）。对于堆来说，堆顶的替换逻辑（如“新元素是否比堆顶小”）也需要仔细验证，避免和计算错误。

---

\<conclusion\>
本次关于“[TJOI2013] 奖学金”的分析就到这里。通过贪心策略和堆的高效维护，我们能快速找到最大的合法中位数。希望大家通过练习巩固这些技巧，下次挑战更难的题目！💪
\</conclusion\>

---
处理用时：162.12秒
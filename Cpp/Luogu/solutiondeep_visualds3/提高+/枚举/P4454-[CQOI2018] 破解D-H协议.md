# 题目信息

# [CQOI2018] 破解D-H协议

## 题目背景

Diffie-Hellman 密钥交换协议是一种简单有效的密钥交换方法。它可以让通讯双方在没有事先约定**密钥**的情况下，通过**不安全**（可能被窃听）**的信道**确定一个**安全的密钥** $K$，用于加密之后的通讯内容。

## 题目描述

假定通讯双方名为 Alice 和 Bob，协议的工作过程描述如下（其中 $\bmod$ 表示取模运算）：

1. 协议规定一个**固定的**质数 $P$，以及模 $P$ 的一个原根 $g$。**$\boldsymbol P$ 和 $\boldsymbol g$ 的数值都是公开的，无需保密。**

2. Alice 生成一个随机数 $a$，并计算 $A=g^a\bmod P$，将 $A$ 通过不安全信道发送给 Bob。

3. Bob 生成一个随机数 $b$，并计算 $B=g^b\bmod P$，将 $B$ 通过不安全信道发送给 Alice。

4. Bob 根据收到的 $A$ 计算出**密钥** $K=A^b \bmod P$，而 Alice 根据收到的 $B$ 计算出 $K=B^a\bmod P$。

5. 双方得到了相同的 $K$，即 $g^{ab} \bmod P$。$K$ 即之后通讯的加密密钥。

可见，这个过程中可能被窃听的只有 $A,B$，而 $a,b,K$ 是保密的。并且根据 $A,B,P,g$ 这 $4$ 个数，不能轻易计算出 $K$，因此 $K$ 可以作为一个安全的密钥。

当然安全是相对的，该协议的安全性取决于数值的大小，通常 $a,b,P$ 都选取数百位以上的大整数以避免被破解。然而如果 Alice 和 Bob 编程时偷懒，为了避免实现大数运算，选择的数值都小于 $2^{31}$，那么破解他们的密钥就比较容易了。

$T$ 次给定窃听得到的 $A,B$，你需要尝试破解出**密钥** $K$。


## 说明/提示

对于 $30\%$ 的数据，$2\le A,B,P\le 1000$；

对于 $100\%$ 的数据，$2\le A,B<P<2^{31}，2\le g<20，1\le n\le 20$。

$\text{Statement fixed by @Starrykiller.}$

## 样例 #1

### 输入

```
3 31
3
27 16
21 3
9 26```

### 输出

```
4
21
25```

# AI分析结果



---
# 💡 Kay的C++算法解析：破解D-H协议 深入学习指南 💡

<introduction>
今天我们来一起分析“破解D-H协议”这道C++编程题。这道题的核心是利用BSGS算法解决高次同余方程问题，最终求出密钥K。本指南将帮助大家梳理题目思路，理解BSGS算法的核心逻辑，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`BSGS算法（Baby Step Giant Step，大步小步算法）`

🗣️ **初步分析**：
解决“破解D-H协议”的关键在于理解BSGS算法的原理及其在求解高次同余方程中的应用。BSGS算法就像“分块寻宝”——把大问题拆成小步（Baby Step）和大步（Giant Step），通过预处理和哈希表快速匹配，将时间复杂度从暴力枚举的O(P)降低到O(√P)，非常适合处理本题中P接近2³¹的情况。

题目要求我们根据已知的g、P（质数）、A、B（其中A=gᵃ mod P，B=gᵇ mod P），求出密钥K=g^(ab) mod P。根据协议，K也等于Aᵇ mod P或Bᵃ mod P，因此只需用BSGS求出a或b中的一个，再通过快速幂计算即可。

核心难点在于：
- BSGS算法的正确实现（分块、哈希表存储、快速幂）；
- 多组数据下的效率优化（如预处理哈希表）；
- 理解题目中K的等价性（Aᵇ ≡ Bᵃ ≡ g^(ab) mod P）。

可视化设计思路：我们将用8位像素风格动画演示BSGS的分块过程。例如，预处理阶段用蓝色像素块表示“大步”值（g^(m*i)）存入哈希表；查询阶段用红色像素块表示“小步”值（A*gʲ），匹配到哈希表时用金色高亮，伴随“叮”的音效。动画支持单步/自动播放，通过颜色变化和指针移动直观展示算法流程。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等指标，以下题解评分均≥4星，值得重点学习：
</eval_intro>

**题解一：作者Leonid（赞10）**
* **点评**：此题解思路简洁，代码规范。作者明确指出只需用BSGS求一个指数（如a），再用快速幂计算Bᵃ mod P。代码中使用`map`存储哈希表，变量名如`qpow`（快速幂）、`BSGS`（算法函数）含义清晰，边界处理（如`k.clear()`初始化哈希表）严谨。亮点在于将BSGS算法模板化，适合直接作为学习参考。

**题解二：作者LeavingZzz（赞7）**
* **点评**：此题解深入分析了BSGS的分块逻辑（i×√P - j），并手写哈希表优化效率（避免`map`的常数问题）。代码中预处理分子（g^(m*i)）和枚举分母（A*gʲ）的步骤明确，注释详细。亮点是对手写哈希表的实现（`Hash_table`结构体），适合学习如何优化哈希操作。

**题解三：作者MY（赞6）**
* **点评**：此题解代码简洁，BSGS实现逻辑清晰。作者通过`map`存储哈希表，代码结构工整（快速幂、BSGS函数分离），并注释了关键步骤（如`b%=p`处理边界）。亮点是将BSGS的核心逻辑（分块、匹配）用简短代码实现，适合初学者理解。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决此题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，提炼解决策略：
</difficulty_intro>

1.  **关键点1：BSGS算法的分块逻辑**
    * **分析**：BSGS的核心是将指数x表示为i×m - j（m=√P），将方程gˣ ≡ A mod P转化为g^(i×m) ≡ A×gʲ mod P。预处理阶段计算并存储所有g^(i×m)的值（大步），查询阶段枚举j计算A×gʲ（小步），在哈希表中匹配是否存在对应的i。优质题解通常通过`map`或手写哈希表高效存储和查询。
    * 💡 **学习笔记**：分块大小m取√P时，时间复杂度最优（O(√P)）。

2.  **关键点2：哈希表的选择与优化**
    * **分析**：哈希表用于存储预处理的“大步”值，查询时快速匹配“小步”值。`map`（平衡树）常数较大，适合数据量小的场景；手写哈希表（如LeavingZzz的实现）或`unordered_map`（哈希表）效率更高，适合P接近2³¹的情况。
    * 💡 **学习笔记**：当P很大时，手写哈希表或`unordered_map`能显著提升效率。

3.  **关键点3：多组数据的预处理优化**
    * **分析**：题目中g和P固定，但A、B多组变化。优质题解（如LeavingZzz）预处理“大步”值（g^(m*i)）一次，后续每组数据只需枚举j（小步），避免重复计算，降低时间复杂度。
    * 💡 **学习笔记**：固定参数的预处理是多组数据问题的常见优化手段。

### ✨ 解题技巧总结
- **问题转化**：将求K=g^(ab) mod P转化为求a（或b），再用快速幂计算Bᵃ（或Aᵇ）。
- **分块思想**：BSGS通过分块将问题复杂度从O(P)降至O(√P)，是解决高次同余方程的核心技巧。
- **哈希表优化**：选择高效的哈希表（如手写或`unordered_map`）存储预处理结果，加速查询。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，先看一个综合优质题解的通用核心实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Leonid和LeavingZzz的题解思路，采用`unordered_map`优化哈希表，预处理大步值，适用于多组数据。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <cmath>
    #include <unordered_map>
    using namespace std;

    typedef long long ll;

    ll qpow(ll a, ll b, ll p) {
        ll res = 1;
        while (b) {
            if (b & 1) res = res * a % p;
            a = a * a % p;
            b >>= 1;
        }
        return res;
    }

    ll bsgs(ll g, ll A, ll p) {
        unordered_map<ll, ll> hash;
        ll m = ceil(sqrt(p));
        ll val = A % p;
        // 预处理小步（j）：存储A*g^j mod p
        for (ll j = 0; j < m; ++j) {
            hash[val] = j;
            val = val * g % p;
        }
        // 计算大步的底数g^m mod p
        ll gm = qpow(g, m, p);
        val = 1;
        // 枚举大步（i）：计算g^(i*m) mod p
        for (ll i = 1; i <= m; ++i) {
            val = val * gm % p;
            if (hash.count(val)) {
                ll j = hash[val];
                return i * m - j;
            }
        }
        return -1;
    }

    int main() {
        ll g, p, n;
        scanf("%lld %lld %lld", &g, &p, &n);
        while (n--) {
            ll A, B;
            scanf("%lld %lld", &A, &B);
            ll a = bsgs(g, A, p);
            printf("%lld\n", qpow(B, a, p));
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先实现快速幂`qpow`，用于计算幂取模。`bsgs`函数通过分块预处理小步值（存储到`unordered_map`），再枚举大步值匹配哈希表，找到指数a。主函数读取输入后，对每组A、B调用`bsgs`求a，再用快速幂计算Bᵃ mod p，输出结果。

---
<code_intro_selected>
接下来，剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者Leonid**
* **亮点**：代码简洁，BSGS逻辑清晰，使用`map`存储哈希表，适合初学者理解。
* **核心代码片段**：
    ```cpp
    ll BSGS(ll a,ll b,ll p){
        k.clear(); // 初始化哈希表
        ll m=ceil(sqrt(p)),ans;
        for(ll i=0;i<=m;i++){
            if(!i){
                ans=b%p;
                k[ans]=i;
                continue;
            }
            ans=(ans*a)%p;
            k[ans]=i;
        }
        ll t=qpow(a,m,p);
        ans=1;
        for(ll i=1;i<=m;i++){
            ans=(ans*t)%p;
            if(k[ans]){
                ll o=i*m-k[ans];
                return (o%p+p)%p;
            }
        }
        return -1;
    }
    ```
* **代码解读**：
    `BSGS`函数中，首先预处理小步值（i从0到m，计算b*aⁱ mod p并存入`map`）。然后计算大步的底数`t=a^m mod p`，枚举i计算tⁱ mod p（即a^(i*m) mod p），在`map`中查找是否存在该值。若存在，返回i*m - j（j是`map`中存储的小步索引）。
* 💡 **学习笔记**：预处理小步时，i从0开始覆盖所有可能的j值，确保匹配无遗漏。

**题解二：作者LeavingZzz（手写哈希表）**
* **亮点**：手写哈希表优化效率，避免`map`的高常数，适合处理大P的情况。
* **核心代码片段**：
    ```cpp
    struct Hash_table{
        static const LL MOD=1999997;
        LL Hash[MOD],V[MOD],stk[MOD],top;
        inline void Insert(LL val,LL mi){
            LL h=val%MOD;
            while(Hash[h]&&Hash[h]!=val) h++;
            Hash[h]=val;V[h]=mi;
            stk[++top]=h;
        }
        inline LL find(LL val){
            LL h=val%MOD;
            while(Hash[h]&&Hash[h]!=val) h++;
            return Hash[h]==val?V[h]:-1;
        }
    }H;
    ```
* **代码解读**：
    `Hash_table`结构体实现了一个简单的哈希表，`Insert`函数将值`val`及其对应的指数`mi`存入哈希表（冲突时线性探测），`find`函数查找`val`对应的指数。这种手写方式比`map`更快，适合P接近2³¹的场景。
* 💡 **学习笔记**：手写哈希表通过取模和线性探测处理冲突，是提升效率的常用技巧。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了直观理解BSGS算法的分块过程，我们设计一个“像素寻宝”主题的8位像素动画，用网格和颜色变化展示预处理和查询的每一步。
\</visualization_intro\>

  * **动画演示主题**：`像素探险家的离散对数大冒险`

  * **核心演示内容**：BSGS算法如何通过预处理“大步”值（蓝色方块）和枚举“小步”值（红色方块），最终在哈希表（黄色格子）中找到匹配的指数a。

  * **设计思路简述**：采用8位像素风格（FC红白机色调），用不同颜色区分步骤：蓝色表示预处理的大步值，红色表示枚举的小步值，金色表示匹配成功。音效（如“叮”提示匹配）和动画（如方块滑动入哈希表）增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左侧是“预处理区”（展示g、P、m=√P的值），右侧是“哈希表区”（16色像素格子，每个格子标有数值）。
          * 控制面板包含“单步”“自动播放”“调速”按钮，背景播放8位风格BGM。

    2.  **预处理阶段（大步存储）**：
          * 探险家（像素小人）从起点（g⁰=1）出发，每次跳“大步”m步（如m=5），计算g^(i*m) mod P（i=1到m）。
          * 每计算一个大步值（如g^5、g^10），生成蓝色像素方块，滑动进入哈希表对应的格子，伴随“刷”的音效。

    3.  **查询阶段（小步匹配）**：
          * 探险家切换为红色，从A出发，每次走“小步”1步（j=0到m-1），计算A*gʲ mod P（如A*g⁰、A*g¹）。
          * 每计算一个小步值，红色方块闪烁，检查哈希表是否有相同值。若匹配（如哈希表中已有蓝色方块），红色方块与蓝色方块合并为金色，播放“叮”的音效，显示指数a=i*m-j。

    4.  **结果展示**：
          * 匹配成功后，屏幕下方显示a的值，并用快速幂动画（绿色箭头）计算Bᵃ mod P，最终显示密钥K。

    5.  **交互控制**：
          * 单步模式：点击“单步”按钮，逐帧查看预处理和查询过程；
          * 自动播放：调速滑块控制速度（慢/中/快），自动演示完整流程；
          * 重置：清空哈希表和动画，重新开始。

  * **旁白提示**：
      * 预处理时：“现在预处理大步值g^(i*m)，存入哈希表方便后续查找~”
      * 查询时：“枚举小步值A*gʲ，看看哈希表里有没有匹配的？”
      * 匹配时：“找到啦！指数a=i*m-j，快用快速幂算出K吧！”

\<visualization_conclusion\>
通过这个像素动画，我们可以直观看到BSGS如何通过分块和哈希表快速找到指数，理解“大步小步”的核心思想。
\</visualization_conclusion\>

---

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
BSGS算法不仅能解决本题，还适用于多种高次同余方程问题。以下是一些拓展练习：
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：
      BSGS的分块思想可用于解决以下问题：
      - 求解离散对数（如P3846 [TJOI2007]可爱的质数）；
      - 处理需要快速求解指数的密码学问题（如RSA中的某些攻击场景）；
      - 解决需要分块优化的枚举问题（如大范围内的因数分解）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3846** - `[TJOI2007]可爱的质数`
          * 🗣️ **推荐理由**：BSGS模板题，适合巩固算法基础。
    2.  **洛谷 P2485** - `[SDOI2011]计算器`
          * 🗣️ **推荐理由**：综合考察快速幂、BSGS和扩展欧几里得算法，提升综合解题能力。
    3.  **洛谷 P4884** - `多少个1？`
          * 🗣️ **推荐理由**：BSGS的变形应用，需要将问题转化为高次同余方程。

---

## 7\. 学习心得与经验分享 (若有)

\<insights_intro\>
部分题解作者分享了调试经验，以下是值得借鉴的内容：
\</insights_intro\>

> **参考经验 (来自作者Eason_AC)**：“使用`map`时发现超时，后来改用`unordered_map`或手写哈希表，效率提升明显。”
>
> **点评**：哈希表的选择对性能影响很大。当P接近2³¹时，`map`（平衡树）的查找时间较长，改用`unordered_map`（哈希表）或手写哈希表能显著降低常数，避免超时。这提示我们在处理大数据量时，需关注数据结构的效率。

---

\<conclusion\>
本次关于“破解D-H协议”的C++解题分析就到这里。BSGS算法是解决高次同余方程的关键，通过分块和哈希表优化，能高效处理大质数问题。希望大家通过练习巩固算法，下次挑战更难的题目！💪
\</conclusion\>

---

---
处理用时：152.97秒
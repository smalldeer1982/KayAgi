# 题目信息

# [CCO 2015] 饥饿的狐狸

## 题目描述

**本题译自 [CCO 2015](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2015/index.html) Day1 T1「[Hungry Fox](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2015/stage%202/day1.pdf)」**

到你的宠物狐狸的晚餐时间啦！他的晚餐包含 $N$ 块饼干，第 $i$ 块饼干的温度是 $T_i$ 摄氏度。同时，在晚餐中还包含了一大盘 $W$ 摄氏度的水。

在喝了一口水之后，你的狐狸开始吃饭了。每当他吃一块饼干时，这块饼干的美味度为当前饼干与吃/喝的前一样食物（包括饼干和水）的温度的差的绝对值。它可以在任意时间喝水（保证水喝不完），或按任意顺序吃饼干。

最后狐狸获得的美味值为它吃下的每块饼干的美味度之和。请求出狐狸获得的最小和最大的美味值。

## 说明/提示

要得到最小美味值，一种可行的方案是，狐狸先喝水，然后吃第一块饼干，再吃第三块饼干，接着喝水，最后吃下第二块饼干，这样做，它所感受到的温度分别为 $20,18,18,20,25$ 摄氏度，总的美味度为 $2+0+5=7$。

要得到最大美味值，一种可行的方案是，狐狸先喝水，然后按顺序吃饼干，它所感受到的温度分别为 $20,18,25,18$ 摄氏度，总的美味度为 $2+7+7=16$。

对于 $30\%$ 及以上的数据， $W=0$；  

对于 $100\%$ 的数据， $1\le N \le 100000, 0\le W \le 10^9, 0 \le T _ i \le 10 ^ 9$。

## 样例 #1

### 输入

```
3 20
18
25
18```

### 输出

```
7 16```

# AI分析结果



---
# 💡 Kay的C++算法解析：饥饿的狐狸 深入学习指南 💡

<introduction>
今天我们要一起攻克的是“饥饿的狐狸”这道题！这道题需要计算狐狸吃饼干的最小和最大美味值，核心在于理解贪心策略的应用。通过分析题解，我们会一步步拆解问题，掌握关键思路和代码实现。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法

🗣️ **初步分析**：
贪心算法的核心是每一步都选择当前最优解，从而逼近全局最优。就像狐狸吃饼干时，要让每一步的美味值尽可能小或尽可能大，这正是贪心的典型应用。

在本题中：
- **最小值**：需要让每一步的温度差尽可能小。通过排序饼干温度，根据水温W的位置（低于所有饼干、高于所有饼干、介于中间）分类讨论，选择最优的吃饼干顺序。
- **最大值**：需要让每一步的温度差尽可能大。通过交替选择温度最低和最高的饼干（类似“蛇形”顺序），并比较直接吃与喝水后吃的差值，取较大值。

核心算法流程：
1. 排序饼干温度数组。
2. 最小值计算：根据W与饼干温度范围的关系，直接得出公式。
3. 最大值计算：分别尝试从最小饼干开始和从最大饼干开始交替取两端，计算两种情况下的总和，取最大值。

可视化设计思路：
设计一个8位像素风的动画，用不同颜色的像素块表示饼干（冷色代表低温，暖色代表高温），水用蓝色方块表示。动画中：
- 排序阶段：饼干像素块自动排列成一行（从小到大）。
- 最小值计算：根据W的位置，狐狸像素从水出发，按顺序或逆序吃饼干，路径上的差值用绿色数字显示。
- 最大值计算：狐狸像素交替从两端取饼干（左→右→左→右…），每一步比较直接吃和喝水后的差值，高亮较大的那个差值（红色数字），伴随“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，以下题解在思路清晰度、代码规范性、算法有效性等方面表现突出（均≥4星），值得重点参考：
</eval_intro>

**题解一：作者桃夭（赞74）**
* **点评**：此题解详细记录了思考过程和调试经验（如初始错误代码的教训），对最小值公式的推导尤为清晰。代码规范，变量名易懂（如`GetMin()`、`GetMax()`），边界处理严谨（如`long long`防溢出）。亮点在于通过画图辅助理解最小值逻辑，并最终优化出O(1)的最小值公式，对学习者有很强的启发。

**题解二：作者greykid（赞14）**
* **点评**：此题解思路简洁，直接点出最大值需交替取两端的贪心策略，并通过两次循环分别计算从最小和最大开始的情况，代码极短但逻辑完整。亮点在于用`max(abs(d[l]-w), abs(d[l]-las))`巧妙处理喝水与直接吃的选择，体现了贪心的核心思想。

**题解三：作者Moon_Traveller（赞3）**
* **点评**：此题解结构清晰，将最小和最大美味值的求解拆分为独立函数（`minn()`、`max1()`、`maxn()`），代码可读性强。亮点在于通过位运算`i & 1`实现交替取两端的逻辑，简洁高效，适合竞赛场景。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于理解贪心策略的应用，尤其是如何根据问题特性选择最优的局部步骤。以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **关键点1：最小值的公式推导**
    * **分析**：最小值的关键是让每一步的温度差尽可能小。排序后，若W低于所有饼干（W < T₁），则从T₁到Tₙ顺序吃，总差值为Tₙ - W；若W高于所有饼干（W > Tₙ），则从Tₙ到T₁逆序吃，总差值为W - T₁；若W在中间（T₁ ≤ W ≤ Tₙ），则通过喝水缓冲，总差值为Tₙ - T₁（中间的差值相互抵消）。
    * 💡 **学习笔记**：最小值的本质是覆盖饼干温度的最小跨度，W的位置决定了是否需要额外加上W与边界的差值。

2.  **关键点2：最大值的交替取两端策略**
    * **分析**：最大值需要每一步的温度差尽可能大。排序后，两端的饼干（T₁和Tₙ）差值最大，因此交替取两端（T₁→Tₙ→T₂→Tₙ₋₁…）能最大化总和。同时需比较直接吃（与前一次饼干的差）和喝水后吃（与W的差），取较大值。
    * 💡 **学习笔记**：交替取两端是贪心最大化差值的经典策略，需分别尝试从左和从右开始，取两种情况的最大值。

3.  **关键点3：处理喝水的影响**
    * **分析**：喝水不产生美味值，但可以改变“前一次食物”的温度。在最大值计算中，每一步选择吃当前饼干时，需比较与前一次饼干的差（直接吃）和与W的差（喝水后吃），取较大值。
    * 💡 **学习笔记**：喝水是调整前一次温度的“工具”，需动态比较两种选择的收益。

### ✨ 解题技巧总结
- **排序是基础**：所有题解都先排序饼干温度，这是后续贪心策略的前提。
- **分类讨论最小值**：根据W与饼干温度范围的关系，分三种情况快速得出最小值。
- **两次循环求最大值**：分别从最小和最大饼干开始交替取两端，确保覆盖所有可能的最大路径。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，提炼出一个通用的核心实现，既简洁又覆盖所有情况。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了桃夭、greykid等题解的思路，排序后分别计算最小和最大值，其中最大值通过两次交替取两端的循环实现，确保正确性和高效性。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    #include <cmath>
    using namespace std;
    #define ll long long

    int n;
    ll w, t[100005];

    ll get_min() {
        if (w < t[1]) return t[n] - w;
        if (w > t[n]) return w - t[1];
        return t[n] - t[1];
    }

    ll get_max(int start_left) {
        int l = 1, r = n;
        ll prev = w, sum = 0;
        for (int i = 1; i <= n; ++i) {
            if ((i & 1) == start_left) { // 交替取左/右端
                sum += max(abs(t[l] - prev), abs(t[l] - w));
                prev = t[l++];
            } else {
                sum += max(abs(t[r] - prev), abs(t[r] - w));
                prev = t[r--];
            }
        }
        return sum;
    }

    int main() {
        cin >> n >> w;
        for (int i = 1; i <= n; ++i) cin >> t[i];
        sort(t + 1, t + n + 1);
        ll min_val = get_min();
        ll max_val = max(get_max(1), get_max(0)); // 分别尝试从左、右开始
        cout << min_val << " " << max_val << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先排序饼干温度，然后通过`get_min()`计算最小值（分三种情况），`get_max()`通过交替取左右两端计算最大值（`start_left`参数控制起始方向）。主函数调用这两个函数并输出结果。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段，学习其中的巧妙设计。
</code_intro_selected>

**题解一：作者桃夭**
* **亮点**：通过`max((long long)0, w - a[1]) + max((long long)0, a[n] - w)`简洁计算最小值，避免复杂循环。
* **核心代码片段**：
    ```cpp
    long long GetMin() {
        return max((long long)0, w - a[1]) + max((long long)0, a[n] - w);
    }
    ```
* **代码解读**：
    这段代码用两个`max`函数覆盖了最小值的三种情况：
    - 若W < a[1]，则`w - a[1]`为负，取0，加上`a[n] - w`（总差值）。
    - 若W > a[n]，则`a[n] - w`为负，取0，加上`w - a[1]`（总差值）。
    - 若W在中间，两个`max`分别为0，总差值为`a[n] - a[1]`。
    这是数学推导的优化结果，将三种情况合并为一个公式，非常巧妙！
* 💡 **学习笔记**：数学推导可以将复杂的条件判断简化为简洁的公式，提升代码效率和可读性。

**题解二：作者greykid**
* **亮点**：用双指针交替取左右端，通过`i & 1`判断当前步骤，代码简洁高效。
* **核心代码片段**：
    ```cpp
    ll las = w, l = 1ll, r = n;
    for (int i = 1; i <= n; ++i) {
        if (i & 1) anh1 += max(abs(d[l] - w), abs(d[l] - las)), las = d[l++];
        else anh1 += max(abs(d[r] - w), abs(d[r] - las)), las = d[r--];
    }
    ```
* **代码解读**：
    `i & 1`等价于`i % 2`，但位运算更快。奇数步取左端（l），偶数步取右端（r），每次更新`las`为当前饼干温度。`max(abs(d[l]-w), abs(d[l]-las))`比较喝水后吃与直接吃的差值，取较大值，确保每一步都是局部最优。
* 💡 **学习笔记**：位运算可以提升代码效率，交替取两端是贪心最大化差值的经典方法。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解贪心策略的执行过程，我们设计一个“狐狸吃饼干”的8位像素动画，用复古风格展示排序、最小值和最大值的计算过程。
</visualization_intro>

  * **动画演示主题**：像素狐狸的饼干大冒险

  * **核心演示内容**：
    - 排序阶段：饼干像素块（颜色从蓝到红表示温度从低到高）自动排列成一行。
    - 最小值计算：狐狸（黄色像素）从水（蓝色方块）出发，根据W的位置选择路径（左→右、右→左或中间缓冲），路径上的差值用绿色数字显示。
    - 最大值计算：狐狸交替从左右两端取饼干（左→右→左→右…），每一步比较直接吃（与前一饼干的差，红色数字）和喝水后吃（与W的差，蓝色数字），高亮较大的那个数字，伴随“叮”的音效。

  * **设计思路简述**：
    8位像素风格（如FC游戏画面）营造轻松氛围，颜色标记（蓝/红代表温度，绿/红代表差值大小）帮助区分关键元素。音效（操作“叮”、成功“哇”）强化操作记忆，步进控制（单步/自动）让学习者逐步观察每一步的选择。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
        - 屏幕上方显示“狐狸吃饼干”标题（8位字体），中间是排序后的饼干行（蓝→红），下方是控制面板（开始/暂停、单步、速度滑块）。
        - 水（蓝色方块）位于左侧，狐狸（黄色像素）在水旁待机，背景播放8位风格BGM。

    2.  **排序阶段**：
        - 饼干像素块从随机位置自动滑动到排序后的位置（从小到大），伴随“唰唰”的滑动音效。

    3.  **最小值计算**：
        - 水的位置（W）用白色箭头标记。若W < 饼干左端，狐狸向右依次吃饼干，路径上显示差值（绿色数字）；若W > 右端，向左依次吃；若在中间，狐狸先向左吃，喝水（蓝色闪光），再向右吃。

    4.  **最大值计算**：
        - 狐狸从左端开始（或右端），每一步用像素箭头指向当前选择的饼干（左或右），比较直接吃（红色数字）和喝水后吃（蓝色数字），高亮较大值，狐狸移动并吃掉该饼干（像素消失），更新前一次温度（黄色标记）。

    5.  **结果展示**：
        - 完成所有步骤后，屏幕显示最小和最大美味值（金色字体），播放胜利音效，狐狸跳跃庆祝。

  * **旁白提示**：
    - （排序时）“看！饼干们自动排好队啦～温度从低到高，像彩虹一样！”
    - （最小值计算时）“W在左边，狐狸向右依次吃，这样每一步的差值最小哦～”
    - （最大值计算时）“现在狐狸要交替吃左右两端的饼干，每次选差值最大的！看，红色数字比蓝色大，所以直接吃更美味～”

<visualization_conclusion>
通过这个动画，我们可以直观看到贪心策略如何一步步选择最优路径，无论是最小还是最大值，每一步的决策都清晰可见！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
贪心算法在排序、区间选择等问题中应用广泛，掌握本题后，可以尝试以下类似题目：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    本题的贪心策略（排序后取两端）可迁移到“纪念品分组”（最大化组数）、“活动选择”（最大化活动数）等问题中。关键是找到局部最优的选择条件（如差值最大、时间不重叠等）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1094 纪念品分组**  
        * 🗣️ **推荐理由**：需要将物品分组，每组总价值不超过上限，贪心策略是排序后首尾配对，与本题最大值的交替取两端思路类似。
    2.  **洛谷 P1223 排队接水**  
        * 🗣️ **推荐理由**：通过排序使总等待时间最小，与本题最小值的顺序吃饼干思路类似，都是贪心选择局部最优。
    3.  **洛谷 P1803 凌乱的yyy**  
        * 🗣️ **推荐理由**：活动选择问题，贪心选择结束时间最早的活动，与本题交替取两端的策略都是贪心的经典应用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解作者桃夭提到：“一开始没仔细审题，以为是简单贪心，结果出错。后来通过画图和反复推导，才找到最小值的正确公式。” 这对我们有很大启发：
</insights_intro>

> **参考经验 (来自桃夭)**：“我第一眼看过去，以为是一道贪心题，没有认真审题就三分钟交程序了……结果出事了。找了半天才发现漏看了喝水的条件。”

**点评**：桃夭的经验提醒我们，审题是解题的第一步！本题的关键条件（喝水可随时进行）容易被忽略，导致思路错误。遇到问题时，画图和逐步推导（如分析最小值的三种情况）能有效避免遗漏。

-----

<conclusion>
通过这篇指南，我们理解了“饥饿的狐狸”问题的核心贪心策略，掌握了最小和最大值的计算方法，以及如何用C++实现。贪心算法的关键在于找到每一步的最优选择，希望大家通过练习巩固，在竞赛中灵活运用！下次见～💪
</conclusion>

-----

---
处理用时：159.94秒
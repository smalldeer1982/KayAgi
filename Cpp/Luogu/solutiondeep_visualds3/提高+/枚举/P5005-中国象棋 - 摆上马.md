# 题目信息

# 中国象棋 - 摆上马

## 题目背景

~~相信自己的做法 大喊一声 I won't MLE！您就会过这道题~~

Imakf 玩腻了国际象棋，决定玩一玩中国象棋。

他发现中国象棋的马和国际象棋的马有所不同，他意识到这又可以出一道简单的问题，于是他又准备摆一摆马了

## 题目描述

Imakf 有一个 $X$ 行 $Y$ 列的棋盘，还有很多**完全相同**的马（你可以认为有无数个）。现在在棋盘上摆上马（或者不摆），求任何马无法攻击另一匹马的方案总数。

中国象棋的马和国际象棋的马不同。

![](https://cdn.luogu.com.cn/upload/pic/40761.png)

注意：实际问题中是没有兵的。

当然由于方案可能过多，请输出对 $(10^9+7)$ 取模的值


## 说明/提示

对于 100% 的数据，有 $1\le X\leq100$，$1\le Y\leq6$。

对于 20% 的数据，有 $X,Y\leq6$。

对于另外 20% 的数据，有 $X\leq20$。

对于样例 1，可以选择不摆或者摆。

对于样例 2，我有一个绝妙的解释可惜我写不下。


## 样例 #1

### 输入

```
1 1 
```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3 
```

### 输出

```
145```

# AI分析结果



---

# 💡 Kay的C++算法解析：中国象棋 - 摆上马 深入学习指南 💡

<introduction>
今天我们来一起分析“中国象棋 - 摆上马”这道C++编程题。这道题需要计算在棋盘上放置马的合法方案数，关键在于理解状态压缩动态规划（状压DP）的应用，以及如何处理中国象棋马的“蹩马腿”规则。本指南将帮助你梳理思路，掌握核心算法，并通过可视化演示直观理解过程。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`状压动态规划（状压DP）`

🗣️ **初步分析**：
解决这道题的关键在于用二进制状态表示每行的马的放置情况（状压），并通过动态规划逐行转移，同时处理马的攻击规则。状压DP的核心思想是将小规模的状态（如每行的放置情况）用二进制数表示，从而将问题转化为状态之间的转移问题。就像用二进制数“0101”表示某行第2、4列有马，第1、3列没有一样。

在本题中，马的攻击范围涉及相邻两行（如当前行和上一行，或上一行和上上行），因此状态需记录当前行和上一行的放置情况。状态定义为`dp[i][j][k]`，表示处理到第`i`行，当前行状态为`j`，上一行状态为`k`时的合法方案数。

核心难点在于：
- **状态合法性判断**：如何判断两行或三行的状态是否合法（即是否存在马互相攻击）。
- **空间优化**：由于行数`X`可能很大（≤100），直接使用三维数组会导致内存溢出，需用滚动数组优化空间。

可视化设计思路：采用8位像素风格，用不同颜色的方块表示马的位置（如绿色表示有马，灰色表示无马）。动画中逐行展示状态转移过程，高亮当前行和上一行的状态，并用红色标记冲突位置（如攻击路径未被阻挡的情况）。同时，用文字提示当前处理的行号、状态值以及合法性判断结果。

---

## 2. 精选优质题解参考

<eval_intro>
经过对各题解的评估（思路清晰度、代码可读性、算法有效性等），以下题解因逻辑清晰、代码规范且优化到位，被选为优质题解（≥4星）。
</eval_intro>

**题解一：作者 - Imakf（赞：47）**
* **点评**：此题解详细推导了状态定义和转移过程，重点解释了如何通过位运算判断两行和三行的合法性。代码中使用`at_bt`和`at_3`函数分别计算相邻行和隔行的攻击范围，逻辑清晰。特别是对“蹩马腿”规则的位运算处理（如通过`~(k>>1)`取反判断是否被阻挡），展现了对问题的深刻理解。实践价值高，适合学习状态转移和合法性判断的核心逻辑。

**题解二：作者 - hater（赞：28）**
* **点评**：此题解在状态转移基础上优化了空间，使用滚动数组（`f[4][1<<6][1<<6]`）将空间复杂度从O(X*2^Y*2^Y)降低到O(2^Y*2^Y)，避免了MLE。代码中`Ch1`和`Ch2`函数通过位运算高效判断两行和三行的合法性，代码简洁且可读性强。特别适合学习滚动数组的优化技巧。

**题解三：作者 - Utilokasteinn（赞：12）**
* **点评**：此题解代码简洁，直接通过位运算实现合法性判断（如`(j&(~j>>1)&(k>>2))`判断左方攻击是否被阻挡），逻辑紧凑。状态转移部分清晰展示了如何从“上一行和上上行”的状态累加合法方案数，适合快速理解状压DP的核心流程。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，提炼解决策略：
</difficulty_intro>

1.  **关键点1：如何定义状态？**
    * **分析**：由于马的攻击范围涉及前两行，状态需记录当前行和上一行的放置情况。定义`dp[i][j][k]`表示处理到第`i`行，当前行状态为`j`，上一行状态为`k`的方案数。其中`j`和`k`是二进制数（如`j=0b101`表示第1、3列有马）。
    * 💡 **学习笔记**：状态定义需覆盖所有可能的前置条件（如本题中前一行的状态），确保转移时能正确累加合法方案。

2.  **关键点2：如何判断状态合法性？**
    * **分析**：合法状态需满足：
      - 相邻两行的马不互相攻击（即无未被阻挡的攻击路径）。
      - 隔一行的马也不互相攻击（即当前行与上上行的马无未被阻挡的攻击路径）。
      优质题解通常通过位运算高效判断，例如：`(j&(~j>>1)&(k>>2))`表示当前行`j`的某个位置未被阻挡（`~j>>1`），且上一行`k`的对应位置有马（`k>>2`），此时冲突。
    * 💡 **学习笔记**：位运算能高效处理二进制状态的条件判断，需熟练掌握`<<`、`>>`、`&`、`~`等操作的组合使用。

3.  **关键点3：如何优化空间？**
    * **分析**：由于行数`X`可能很大（≤100），直接存储所有行的状态会导致内存溢出。优质题解使用滚动数组（如`f[i%3][j][k]`），仅保留最近两行的状态，将空间复杂度从O(X*2^Y*2^Y)优化到O(2^Y*2^Y)。
    * 💡 **学习笔记**：滚动数组是处理大行数状压DP的常用技巧，通过取模操作重复利用数组空间。

### ✨ 解题技巧总结
- **问题分解**：将问题拆解为“状态定义”“合法性判断”“空间优化”三部分，逐一解决。
- **位运算简化**：利用位运算快速计算攻击范围和阻挡情况（如`~(k>>1)`取反判断是否被阻挡）。
- **滚动数组**：仅保留最近两行的状态，避免内存溢出。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解的通用核心实现，帮助理解整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Imakf和hater的题解思路，使用滚动数组优化空间，并通过位运算高效判断合法性。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MOD = 1e9 + 7;
    int dp[2][1 << 6][1 << 6]; // 滚动数组优化空间

    // 判断两行是否合法（无未被阻挡的攻击）
    inline bool check_two(int a, int b, int m) {
        for (int i = 0; i < m; ++i) {
            if ((a & (1 << i)) && (i + 2 < m)) 
                if (!(a & (1 << (i + 1))) && (b & (1 << (i + 2)))) return false;
            if ((a & (1 << i)) && (i - 2 >= 0)) 
                if (!(a & (1 << (i - 1))) && (b & (1 << (i - 2)))) return false;
            if ((b & (1 << i)) && (i + 2 < m)) 
                if (!(b & (1 << (i + 1))) && (a & (1 << (i + 2)))) return false;
            if ((b & (1 << i)) && (i - 2 >= 0)) 
                if (!(b & (1 << (i - 1))) && (a & (1 << (i - 2)))) return false;
        }
        return true;
    }

    // 判断三行是否合法（当前行a，上一行b，上上行c）
    inline bool check_three(int a, int b, int c, int m) {
        for (int i = 0; i < m; ++i) {
            if ((a & (1 << i)) && !(b & (1 << i)) && (i + 1 < m) && (c & (1 << (i + 1)))) return false;
            if ((a & (1 << i)) && !(b & (1 << i)) && (i - 1 >= 0) && (c & (1 << (i - 1)))) return false;
            if ((c & (1 << i)) && !(b & (1 << i)) && (i + 1 < m) && (a & (1 << (i + 1)))) return false;
            if ((c & (1 << i)) && !(b & (1 << i)) && (i - 1 >= 0) && (a & (1 << (i - 1)))) return false;
        }
        return true;
    }

    int main() {
        int n, m;
        cin >> n >> m;
        int max_state = 1 << m;
        // 初始化第一行
        for (int i = 0; i < max_state; ++i) dp[1][i][0] = 1;
        // 处理第二行
        for (int i = 0; i < max_state; ++i)
            for (int j = 0; j < max_state; ++j)
                if (check_two(i, j, m)) dp[0][j][i] = 1;
        // 动态规划转移
        for (int i = 3; i <= n; ++i) {
            memset(dp[i % 2], 0, sizeof(dp[i % 2]));
            for (int j = 0; j < max_state; ++j) // 当前行
                for (int k = 0; k < max_state; ++k) { // 上一行
                    if (!check_two(j, k, m)) continue;
                    for (int l = 0; l < max_state; ++l) { // 上上行
                        if (!check_two(k, l, m)) continue;
                        if (!check_three(j, k, l, m)) continue;
                        dp[i % 2][j][k] = (dp[i % 2][j][k] + dp[(i - 1) % 2][k][l]) % MOD;
                    }
                }
        }
        // 统计答案
        int ans = 0;
        for (int i = 0; i < max_state; ++i)
            for (int j = 0; j < max_state; ++j)
                if (check_two(i, j, m)) ans = (ans + dp[n % 2][i][j]) % MOD;
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：代码首先初始化第一行的所有可能状态（`dp[1][i][0] = 1`），然后处理第二行的合法状态。对于后续行，使用滚动数组`dp[i%2]`逐行转移，通过`check_two`和`check_three`函数判断状态合法性，最后累加所有合法状态的方案数。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段，学习其中的亮点和关键思路。
</code_intro_selected>

**题解一：作者 - Imakf**
* **亮点**：通过`at_bt`和`at_3`函数分别计算相邻行和隔行的攻击范围，位运算逻辑清晰。
* **核心代码片段**：
    ```cpp
    int at_bt(int a) { // 计算当前行a对下一行的攻击范围
        int c = 0;
        for (int i = 1; (1 << (i - 1)) <= a; ++i) {
            if (!check(a, i)) continue; // 当前位置无马，跳过
            if (!check(a, i - 1)) c |= (1 << (i - 2)); // 左方未被阻挡，标记攻击位置
            if (!check(a, i + 1)) c |= (1 << (i + 2)); // 右方未被阻挡，标记攻击位置
        }
        return c;
    }
    ```
* **代码解读**：`at_bt`函数遍历当前行的每个位置（`i`），若该位置有马（`check(a, i)`为真），则检查左右是否被阻挡（`check(a, i-1)`和`check(a, i+1)`）。若未被阻挡，则标记下一行的对应攻击位置（`i-2`或`i+2`）。通过位运算`|=`累加攻击范围，最终返回当前行对下一行的攻击掩码。
* 💡 **学习笔记**：攻击范围的预处理是合法性判断的关键，通过位运算快速计算掩码，可大幅提高判断效率。

**题解二：作者 - hater**
* **亮点**：使用滚动数组优化空间，代码简洁且避免了MLE。
* **核心代码片段**：
    ```cpp
    int f[4][1<<6][1<<6], M=1e9+7; // 滚动数组，仅保留最近三行的状态
    for(int i=3;i<=n;i++) {
        memset(f[i%3],0,sizeof(f[i%3])); // 清空当前行状态
        for(int j=0;j<MS;j++) 
            for(int k1=0;k1<MS;k1++) 
                if(Ch1(j,k1,0)) // 检查当前行j与上一行k1是否合法
                    for(int k2=0;k2<MS;k2++)
                        if(Ch1(k1,k2,0)&&Ch2(j,k1,k2,0)) // 检查k1与k2，j与k2是否合法
                            f[i%3][j][k1]=(f[i%3][j][k1]+f[(i-1)%3][k1][k2])%M;
    }
    ```
* **代码解读**：通过`i%3`实现滚动数组，仅保留当前行、上一行和上上行的状态。每次处理新行时，先清空当前行的数组（`memset`），然后枚举当前行、上一行、上上行的状态，通过`Ch1`（两行合法性）和`Ch2`（三行合法性）判断后累加方案数。
* 💡 **学习笔记**：滚动数组通过取模操作重复利用内存，是处理大行数问题的必备技巧。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解状压DP的状态转移和合法性判断过程，我们设计了一个“像素棋盘探险”动画，用8位复古风格展示每一步的状态变化。
</visualization_intro>

  * **动画演示主题**：`像素棋盘上的马放置探险`

  * **核心演示内容**：逐行展示棋盘的状态转移，高亮当前行、上一行的马的位置，并用红色标记冲突（攻击未被阻挡）的位置，同时显示对应的二进制状态和方案数累加过程。

  * **设计思路简述**：采用FC红白机风格的像素网格（每格16x16像素），用绿色方块表示有马，灰色表示无马。通过步进控制（单步/自动播放）和状态高亮（如当前处理的行号、状态值），帮助学习者观察每一步的合法性判断和方案数累加。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 棋盘网格（X行Y列）用浅灰色背景，顶部显示控制面板（开始/暂停、单步、速度滑块）。
        - 左侧显示当前行号（如“第3行”）、当前状态（如二进制`0101`）、上一行状态（如`1010`）。
        - 8位风格背景音乐（如《超级玛丽》经典旋律）。

    2.  **状态初始化（第一行）**：
        - 第一行的每个位置可放置或不放置马（绿色/灰色），动画中逐个格子闪烁显示所有可能状态（如`0000`到`1111`，Y=4时）。
        - 方案数显示为`dp[1][i][0] = 1`（每个状态初始为1）。

    3.  **状态转移（第二行）**：
        - 枚举第二行的每个状态（`j`）和第一行的每个状态（`i`）。
        - 若`i`和`j`合法（无冲突），则`dp[2][j][i]`累加，动画中对应的`j`和`i`格子变为黄色，并显示累加的数值（如`+1`）。

    4.  **状态转移（第三行及以后）**：
        - 逐行处理，当前行（绿色边框）、上一行（蓝色边框）、上上行（灰色边框）的状态同时显示。
        - 当判断当前行`j`与上一行`k`合法时，遍历上上行`l`，若`k`与`l`、`j`与`l`均合法，则`dp[i%2][j][k]`累加`dp[(i-1)%2][k][l]`，动画中用箭头从`l→k→j`表示转移，并显示数值变化。

    5.  **冲突检测动画**：
        - 当两行或三行状态冲突时，冲突的马位置（如当前行的`i`位置和上一行的`i+2`位置）闪烁红色，并播放“叮”的提示音效。
        - 同时显示冲突原因（如“马在(i,j)未被阻挡，攻击到(i+1,j+2)”）。

    6.  **最终统计**：
        - 所有行处理完毕后，棋盘显示最终状态，方案数总和用金色数字放大显示，播放胜利音效（如《超级玛丽》通关音乐）。

  * **旁白提示**：
    - （单步时）“现在处理第3行，当前状态是`0101`，上一行状态是`1010`。检查是否与上一行冲突……”
    - （冲突时）“注意！当前行的第2列有马，上一行的第4列有马，中间未被阻挡，冲突！”
    - （成功转移时）“合法！方案数累加，当前`dp[3][0101][1010]`变为`5`。”

<visualization_conclusion>
通过这个动画，我们可以直观看到每一步的状态转移和合法性判断，理解状压DP如何通过逐行处理和状态累加，最终得到所有合法方案数。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
状压DP是解决棋盘类放置问题的常用方法，掌握其核心思想后，可迁移到以下场景：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - **棋盘覆盖问题**（如铺瓷砖、放国王）：用二进制状态表示每行的覆盖情况，判断相邻行是否冲突。
    - **路径搜索问题**（如迷宫寻路）：用状态表示已访问的节点，通过位运算快速判断。
    - **资源分配问题**（如任务调度）：用状态表示资源分配情况，动态规划求解最优解。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1896 [SCOI2005]互不侵犯**：
        * 🗣️ **推荐理由**：与本题类似，使用状压DP处理棋盘放置问题，状态定义和转移逻辑相似，适合巩固状压DP基础。
    2.  **洛谷 P2704 [NOI2001]炮兵阵地**：
        * 🗣️ **推荐理由**：状态需记录前两行，与本题三行合法性判断类似，难度稍高，适合提升位运算和状态转移能力。
    3.  **洛谷 P1879 [USACO06NOV]玉米田Corn Fields**：
        * 🗣️ **推荐理由**：基础状压DP题，状态仅需记录当前行和上一行，适合理解状压DP的基本流程。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些经验对我们避免常见错误很有帮助：
</insights_intro>

> **参考经验 (来自 hater)**：“一开始没考虑空间限制，直接开了三维数组，结果MLE了。后来想到用滚动数组，只保留最近两行的状态，问题就解决了。”

**点评**：hater的经验提醒我们，在处理大行数问题时，必须考虑空间复杂度。滚动数组是常用的优化手段，通过取模操作重复利用内存，可有效避免MLE。建议在编写代码前先估算空间需求（如本题中`X=100,Y=6`时，三维数组需`100*64*64*4=1638400字节`，约1.6MB，超过1MB限制），及时采用滚动数组优化。

---

<conclusion>
本次关于“中国象棋 - 摆上马”的分析就到这里。通过状压DP和滚动数组的结合，我们解决了马的合法放置问题。希望你能通过本指南掌握状压DP的核心思想，以及如何处理类似的棋盘放置问题。记住，多动手调试、多思考状态转移，是提升算法能力的关键！下次再见~ 💪
</conclusion>

---
处理用时：217.27秒
# 题目信息

# 「DLESS-1」Range | Sum | Maximum

## 题目描述

给出一个长度为 $n$ 的序列 $a$，定义一个区间 $[l,r]$ 的权值为 $\max_{l\le L\le R\le r}|\sum_{i=L}^Ra_i|$。

对于 $k=1,2,3,\dots,n$，求所有长度为 $k$ 的区间权值和。

## 说明/提示

#### 【样例解释】

样例中五组数据的 $ans$ 分别为：
- $\{4,3,2\}$
- $\{28,39,41,36,31,22,13\}$
- $\{28,39,41,36,31,22,13\}$
- $\{7,10,10,7\}$
- $\{18,23,19,14,7\}$

其中，对于第一组数据，各个区间的权值分别如下：

- $[1,1]:1$
- $[2,2]:1$
- $[3,3]:2$
- $[1,2]:1$
- $[2,3]:2$
- $[1,3]:2$

其中，长度为 $1$ 的区间有 $[1,1],[2,2],[3,3]$，权值和为 $4$；长度为 $2$ 的区间有 $[1,2],[2,3]$，权值和为 $3$；长度为 $3$ 的区间有 $[1,3]$，权值和为 $2$。

#### 【数据范围】

对于所有数据，保证：
- $1\le T\le10^4$
- $1\le n,\sum n\le10^6$
- $-10^6\le a_i\le10^6$

**本题采用打包测试**，各测试包描述如下：

| Subtask | $\sum n\le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $500$ | 无 | $5$ |
| $2$ | $5000$ | 无 | $20$ |
| $3$ | $10^6$ | $a_i\ge 0$ | $25$ |
| $4$ | $3\times10^5$ | 无 | $25$ |
| $5$ | $10^6$ | 无 | $25$ |


## 样例 #1

### 输入

```
5
3
1 -1 2
7
1 -2 -3 4 5 -6 -7
7
-1 2 3 -4 -5 6 7
4
1 1 2 3
5
1 4 -5 -2 6```

### 输出

```
1
31
31
4
11```

# AI分析结果

# 💡 Kay的C++算法解析：「DLESS-1」Range | Sum | Maximum 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用`（单调栈求区间最值贡献 + 差分统计）

🗣️ **初步分析**：  
解决这道题的关键，在于把“复杂的区间权值”转化为“简单的前缀和最值差”——就像把“绕弯路的问题”掰直成“直路”。具体来说：  
原问题中，区间 $[l,r]$ 的权值是**该区间内所有子区间和的绝对值的最大值**。而通过前缀和转换（记 $s_i$ 为前 $i$ 项和），这个权值会“自动”变成 $s$ 数组在 $[l-1, r]$ 区间内的**最大值减最小值**（因为绝对值的差最大，必然是最大的 $s$ 减最小的 $s$）。  

接下来的问题就变成：**求所有长度为 $k$ 的区间的（最大值 - 最小值）之和**。这一步需要两个核心技巧：  
1. **单调栈**：像“排队选班长”——每个 $s_i$ 要找到自己能成为“最大值”的最长区间（左边第一个比它大的位置 $l_i$，右边第一个比它大的位置 $r_i$），这样就能知道它能给哪些区间的最大值“做贡献”。  
2. **差分**：像“超市批量改价”——不用逐个区间加 $s_i$，而是在差分数组里记“从长度 $a$ 到 $b$，每个长度的和加 $s_i$”，最后通过前缀和算出每个长度的总贡献。  

**核心算法流程**：  
- 计算前缀和数组 $s$；  
- 用单调栈求每个 $s_i$ 作为最大值的区间 $[l_i, r_i]$，以及作为最小值的区间 $[ll_i, rr_i]$；  
- 对每个 $s_i$，计算它对不同长度区间的贡献（形如“先增后平再减”的等差数列），用差分标记；  
- 累加差分得到每个长度 $k$ 的权值和，最后异或结果。  

**可视化设计思路**：  
我们会用**8位像素风**（像FC红白机游戏）展示整个过程：  
- 前缀和数组用不同颜色的像素块表示（红色代表大值，蓝色代表小值）；  
- 单调栈操作：弹出元素时像素块“下滑消失”，压入时“上滑出现”，伴随“叮”的音效；  
- 差分贡献：在差分的起点（比如长度1）用“绿色闪烁”标记加贡献，终点用“红色闪烁”标记减贡献；  
- 自动播放时，像“贪吃蛇AI”一样逐步处理每个 $s_i$，完成后弹出“胜利”音效，每个长度的权值和用像素数字显示。


## 2. 精选优质题解参考

<eval_intro>
为了帮大家快速掌握核心思路，我筛选了3份**思路清晰、代码严谨、技巧实用**的题解，它们从不同角度拆解了问题，适合逐步理解。
</eval_intro>

**题解一：(来源：Gold14526)**  
* **点评**：这份题解的“转化能力”很强——直接点出“区间权值=前缀和最值差”，然后用单调栈求 $l_i$ 和 $r_i$（左边第一个比 $s_i$ 大的位置+1，右边第一个比 $s_i$ 大的位置-1）。最巧妙的是**差分处理贡献**：通过交换 $p$ 和 $q$（保证 $p \leq q$），用4次差分修改（$ans[0]+=s_i$、$ans[p]-=s_i$ 等），就能覆盖“先增后平再减”的贡献。代码简洁，边界处理到位（比如处理 $s_0$ 到 $s_n$ 的所有前缀和），是“直击本质”的好题解。

**题解二：(来源：toolazy)**  
* **点评**：这份题解的“模块化思维”值得学习——把最大值和最小值的处理拆成 `MAXIUM` 和 `MINIUM` 两个namespace，逻辑互不干扰。单调栈的实现很规范（用 `stack` 容器，处理相同值时“一边取等、一边不取等”，避免重复或遗漏）。差分的处理和题解一类似，但代码可读性更高（比如用 `ls[i]` 表示左边能扩展的长度，`rs[i]` 表示右边能扩展的长度），适合新手模仿。

**题解三：(来源：chenbs)**  
* **点评**：这份题解的“循序渐进”做得好——先讲50分的 $O(n^2)$ 暴力（前缀和+ST表），再过渡到正解，帮大家理解“为什么需要单调栈”。代码中用 $x$ 和 $x2$ 两个差分数组处理“等差数列贡献”（比如 $x$ 处理线性项，$x2$ 处理常数项），逻辑更严谨，适合想深入理解差分原理的同学。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有3个，我们逐一拆解：
</difficulty_intro>

1. **难点1：如何把原问题转化为前缀和的最值差？**  
   * **分析**：原问题的权值是“区间内所有子区间和的绝对值的最大值”。子区间和是 $s_R - s_{L-1}$，绝对值的最大值等于 **$s$ 在 $[l-1, r]$ 中的最大值减最小值**（因为要让差最大，必然选最大的 $s_R$ 和最小的 $s_{L-1}$）。  
   * **解决**：动手算几个样例——比如样例1中的区间 $[1,3]$，前缀和是 $s_0=0, s_1=1, s_2=0, s_3=2$，最大值是2，最小值是0，差是2，正好等于原区间的权值。

2. **难点2：如何用单调栈求 $s_i$ 的贡献区间？**  
   * **分析**：要知道 $s_i$ 能成为哪些区间的最大值，需要找到左边第一个比它大的位置 $l_i$（左边的“天花板”），右边第一个比它大的位置 $r_i$（右边的“天花板”）。这样，所有包含 $i$ 且在 $[l_i, r_i]$ 内的区间，最大值都是 $s_i$。  
   * **解决**：单调栈维护**递减序列**——比如求 $l_i$ 时，从左到右遍历，弹出所有比 $s_i$ 小的元素（因为它们无法成为 $s_i$ 的“天花板”），剩下的栈顶就是左边第一个比 $s_i$ 大的位置。求 $r_i$ 时反过来从右到左遍历。

3. **难点3：如何用差分处理“先增后平再减”的贡献？**  
   * **分析**：$s_i$ 的贡献区间是 $[l_i, r_i]$，长度为 $len = r_i - l_i + 1$。它对长度 $k$ 的贡献是：  
     - $k=1$：贡献1次 $s_i$；  
     - $k=2$：贡献2次 $s_i$；  
     - ...  
     - $k=p$（$p$ 是左扩展长度）：贡献 $p$ 次；  
     - 中间 $k$：贡献 $p$ 次；  
     - 最后 $k$：贡献从 $p$ 减到1次。  
   * **解决**：用**两次差分**——比如对 $s_i$ 的贡献，在差分数组中做4次修改：$ans[0]+=s_i$、$ans[p]-=s_i$、$ans[q]-=s_i$、$ans[len+2]+=s_i$，最后通过两次前缀和得到每个长度的总贡献。


### ✨ 解题技巧总结
<summary_best_practices>
通过这道题，我们能总结出3个通用技巧：
</summary_best_practices>
- **问题转化**：遇到“区间和的绝对值”，先想前缀和——绝对值能帮我们“忽略顺序”，直接找最值差。  
- **单调栈模板**：求每个元素的“支配区间”（能成为最值的最长区间），单调栈是 $O(n)$ 时间的“神器”，要记牢“左找大/小、右找大/小”的写法。  
- **差分简化**：遇到“批量修改连续区间”，用差分——比如等差数列贡献、区间加值，都能通过差分把 $O(n)$ 操作变成 $O(1)$。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合了优质题解思路**的核心代码，帮大家建立整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码整合了“单调栈求贡献区间”和“差分统计”的核心逻辑，结构清晰，适合新手理解。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <stack>
  using namespace std;

  typedef long long LL;
  const int N = 1e6 + 5;
  const LL INF = 1e18;

  int n;
  LL a[N], s[N], ans[N];
  int l[N], r[N]; // s[i]作为最大值的区间[L, R]
  int ll[N], rr[N]; // s[i]作为最小值的区间[LL, RR]

  void getMaxRange() {
      stack<int> stk;
      stk.push(-1); // 左边界哨兵
      for (int i = 0; i <= n; ++i) {
          while (stk.top() != -1 && s[stk.top()] <= s[i]) stk.pop();
          l[i] = stk.top() + 1;
          stk.push(i);
      }
      while (!stk.empty()) stk.pop();
      stk.push(n + 1); // 右边界哨兵
      for (int i = n; i >= 0; --i) {
          while (stk.top() != n + 1 && s[stk.top()] < s[i]) stk.pop();
          r[i] = stk.top() - 1;
          stk.push(i);
      }
  }

  void getMinRange() {
      stack<int> stk;
      stk.push(-1);
      for (int i = 0; i <= n; ++i) {
          while (stk.top() != -1 && s[stk.top()] >= s[i]) stk.pop();
          ll[i] = stk.top() + 1;
          stk.push(i);
      }
      while (!stk.empty()) stk.pop();
      stk.push(n + 1);
      for (int i = n; i >= 0; --i) {
          while (stk.top() != n + 1 && s[stk.top()] > s[i]) stk.pop();
          rr[i] = stk.top() - 1;
          stk.push(i);
      }
  }

  void addContribution(LL val, int L, int R) {
      int p = L, q = R;
      if (p > q) swap(p, q);
      ans[0] += val;
      ans[p] -= val;
      ans[q] -= val;
      ans[R - L + 2] += val;
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(0);
      int T;
      cin >> T;
      while (T--) {
          cin >> n;
          s[0] = 0;
          for (int i = 1; i <= n; ++i) {
              cin >> a[i];
              s[i] = s[i - 1] + a[i];
          }
          // 初始化差分数组
          for (int i = 0; i <= n + 2; ++i) ans[i] = 0;
          // 处理最大值贡献
          getMaxRange();
          for (int i = 0; i <= n; ++i) {
              int L = i - l[i] + 1, R = r[i] - i + 1;
              addContribution(s[i], L, R);
          }
          // 处理最小值贡献（转化为最大值，取反s）
          for (int i = 0; i <= n; ++i) s[i] = -s[i];
          getMaxRange();
          for (int i = 0; i <= n; ++i) {
              int L = i - l[i] + 1, R = r[i] - i + 1;
              addContribution(s[i], L, R);
          }
          // 计算最终ans
          LL res = 0;
          LL sum = 0, pre = 0;
          for (int i = 1; i <= n; ++i) {
              pre += ans[i - 1];
              sum += pre;
              res ^= sum % (1LL * i * i);
          }
          cout << res << '\n';
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **前缀和计算**：读取输入后，计算前缀和数组 $s$；  
  2. **单调栈求区间**：`getMaxRange` 求每个 $s_i$ 作为最大值的区间，`getMinRange` 求最小值的区间（通过取反 $s$ 转化为最大值问题）；  
  3. **差分贡献**：`addContribution` 用差分标记每个 $s_i$ 的贡献；  
  4. **计算结果**：两次前缀和得到每个长度的权值和，最后异或结果。


---

<code_intro_selected>
接下来看**题解二（toolazy）**的核心片段，它的“模块化”写法很值得学习。
</code_intro_selected>

**题解二：(来源：toolazy)**
* **亮点**：把“最大值”和“最小值”的处理拆成两个namespace，逻辑互不干扰，代码可读性极高。
* **核心代码片段**：
  ```cpp
  namespace MAXIUM {
      int ans[MAXN];
      int ls[MAXN], rs[MAXN];
      stack<int> stk;
      
      void solve() {
          b[0] = INF, b[n + 2] = INF;
          stk.push(0);
          for (int i = 1; i <= n + 1; ++i) {
              while (b[stk.top()] < b[i]) stk.pop();
              ls[i] = i - stk.top();
              stk.push(i);
          }
          while (!stk.empty()) stk.pop();
          stk.push(n + 2);
          for (int i = n + 1; i >= 1; --i) {
              while (b[stk.top()] <= b[i]) stk.pop();
              rs[i] = stk.top() - i;
              stk.push(i);
          }
          // 差分处理贡献
          for (int i = 1; i <= n + 1; ++i) {
              int small = min(ls[i], rs[i]);
              int big = max(ls[i], rs[i]);
              ans[1] += b[i];
              ans[small + 1] -= b[i];
              ans[big + 1] -= b[i];
              ans[small + big + 1] += b[i];
          }
          // 两次前缀和
          for (int i = 1; i <= n + 1; ++i) ans[i] += ans[i - 1];
          for (int i = 1; i <= n + 1; ++i) ans[i] += ans[i - 1];
      }
  }
  ```
* **代码解读**：  
  1. **namespace封装**：`MAXIUM` 处理最大值的贡献，`MINIUM` 处理最小值（类似写法），避免变量混淆；  
  2. **单调栈求ls/rs**：`ls[i]` 是 $i$ 左边能扩展的长度（到第一个比 $b[i]$ 大的位置），`rs[i]` 是右边能扩展的长度；  
  3. **差分贡献**：用 `ans` 数组标记“从1到small+1加b[i]”等，最后两次前缀和得到每个长度的总贡献。  
* 💡 **学习笔记**：模块化写法能让代码“分工明确”，即使问题复杂，也能一步步拆解。比如本题的“最大值”和“最小值”逻辑几乎一样，用namespace封装能避免重复代码。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们设计了一个**8位像素风的动画**，像玩《超级马里奥》一样理解算法！
</visualization_intro>

### **动画主题**：像素探险家的“前缀和寻宝记”
- **场景**：屏幕左侧是8x8的像素网格（代表前缀和数组 $s$，每个格子颜色代表值大小：红=大，蓝=小）；  
- **右侧**：单调栈的“排队区”（显示当前栈中的元素）、差分的“贡献板”（显示每个长度的贡献）；  
- **控制面板**：开始/暂停、单步、重置按钮，速度滑块（从“慢”到“快”）。


### **核心演示步骤**
1. **初始化**：  
   - 前缀和数组用像素块显示（比如样例1的 $s=[0,1,0,2]$，对应蓝色、浅红、蓝色、深红）；  
   - 单调栈的“排队区”显示哨兵（-1）；  
   - 8位风格的背景音乐（轻快的“叮叮咚”）开始播放。

2. **单调栈求区间**：  
   - 处理 $s_1=1$：栈顶是-1，弹出所有比1小的元素（没有），$l_1=0$，压入栈（排队区新增1号像素块）；  
   - 处理 $s_2=0$：栈顶是1（值1>0），$l_2=1$，压入栈（排队区新增2号像素块）；  
   - 处理 $s_3=2$：弹出栈顶的2（值0<2）、1（值1<2），栈顶是-1，$l_3=0$，压入栈（排队区新增3号像素块）；  
   - **音效**：压入时“叮”，弹出时“咔”。

3. **差分贡献**：  
   - $s_3=2$ 的贡献区间是 $[0,3]$（长度4），$L=3-0+1=4$，$R=3-3+1=1$，交换后 $p=1$，$q=4$；  
   - 差分板上：$ans[0]+=2$（绿色闪烁），$ans[1]-=2$（红色闪烁），$ans[4]-=2$（红色闪烁），$ans[5]+=2$（绿色闪烁）；  
   - **音效**：修改差分时“滴”的一声。

4. **结果计算**：  
   - 两次前缀和后，每个长度的贡献用像素数字显示（比如长度1的和是4，长度2的和是3）；  
   - 完成后，屏幕弹出“胜利”动画（像素星星闪烁），伴随“叮~”的音效。


### **交互设计**
- **单步执行**：点击“下一步”，动画走一步，显示当前操作的文字提示（比如“处理s_3，弹出栈顶的2”）；  
- **自动播放**：点击“自动”，动画以每秒2帧的速度播放，适合整体观察流程；  
- **重置**：回到初始状态，重新开始。


## 6. 拓展练习与相似问题思考

### **通用思路迁移**
本题的“单调栈求贡献+差分统计”可以解决**所有“区间最值和”问题**，比如：
1. 求所有长度为k的区间的最大值之和；  
2. 求所有子区间的最小值之和；  
3. 求所有区间的（最大值-最小值）之和。


### **洛谷推荐练习**
1. **P10194 [USACO24FEB] Milk Exchange G**  
   - 🗣️ **推荐理由**：同样是“区间最值和”问题，需要用单调栈求贡献，差分统计，能巩固本题的核心技巧。  
2. **CF212D Cutting a Fence**  
   - 🗣️ **推荐理由**：求所有长度为k的区间的最小值之和，是本题的“简化版”，适合练手。  
3. **P3802 小魔女帕琪**  
   - 🗣️ **推荐理由**：需要用单调栈求每个元素的贡献区间，然后统计概率，是本题的“进阶版”。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中藏着很多“踩坑经验”，比如：
</insights_intro>

> **参考经验 (来自 toolazy)**：“处理相同值时，一边取等一边不取等，就能保证不重不漏。比如求最大值时，左边用<=，右边用<，这样相同值的元素不会重复计算贡献。”  
> **点评**：这个细节很重要！如果两边都用<=，会导致相同值的元素重复计算；如果都用<，会遗漏。一边取等一边不取，正好覆盖所有情况。


## 8. 总结

本次分析的核心是**“问题转化+单调栈+差分”**——把复杂的区间权值问题，拆成三个简单的步骤。记住：  
- 遇到“区间和的绝对值”，先想前缀和；  
- 遇到“区间最值和”，先想单调栈求贡献；  
- 遇到“批量修改”，先想差分。  

编程的乐趣在于“把复杂问题掰直”，希望这份指南能帮你找到“掰直”的技巧！下次我们再一起挑战更难的题目~ 💪

---
**报告结束**，祝你编程进步！ 🚀

---
处理用时：156.20秒
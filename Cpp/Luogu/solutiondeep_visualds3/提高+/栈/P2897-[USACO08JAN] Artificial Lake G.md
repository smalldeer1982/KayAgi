# 题目信息

# [USACO08JAN] Artificial Lake G

## 题目背景

USACO 2008 January Gold

## 题目描述

The oppressively hot summer days have raised the cows' clamoring to its highest level. Farmer John has finally decided to build an artificial lake. For his engineering studies, he is modeling the lake as a two-dimensional landscape consisting of a contiguous sequence of N soon-to-be-submerged levels (1 ≤ N ≤ 100,000) conveniently numbered 1..N from left to right.


Each level i is described by two integers, its width Wi (1 ≤ Wi ≤ 1,000) and height (like a relative elevation) Hi (1 ≤ Hi ≤ 1,000,000). The heights of FJ's levels are unique. An infinitely tall barrier encloses the lake's model on the left and right. One example lake profile is shown below.

          
```cpp
         *             *  :
         *             *  :
         *             *  8
         *    ***      *  7
         *    ***      *  6
         *    ***      *  5
         *    **********  4 <- height
         *    **********  3
         ***************  2
         ***************  1
Level    |  1 |2|  3   |
```
In FJ's model, he starts filling his lake at sunrise by flowing water into the bottom of the lowest elevation at a rate of 1 square unit of water per minute. The water falls directly downward until it hits something, and then it flows and spreads as room-temperature water always does. As in all good models, assume that falling and flowing happen instantly. Determine the time at which each elevation's becomes submerged by a single unit of water.


```cpp
WATER              WATER OVERFLOWS                     
       |                       |                           
     * |          *      *     |      *      *            *
     * V          *      *     V      *      *            *
     *            *      *    ....    *      *~~~~~~~~~~~~*
     *    **      *      *~~~~** :    *      *~~~~**~~~~~~*
     *    **      *      *~~~~** :    *      *~~~~**~~~~~~*
     *    **      *      *~~~~**~~~~~~*      *~~~~**~~~~~~*
     *    *********      *~~~~*********      *~~~~*********
     *~~~~*********      *~~~~*********      *~~~~*********
     **************      **************      **************
     **************      **************      **************
     After 4 mins        After 26 mins       After 50 mins

     Lvl 1 submerged     Lvl 3 submerged     Lvl 2 submerged
```
Warning: The answer will not always fit in 32 bits.

夏日那让人喘不过气的酷热将奶牛们的烦躁情绪推到了最高点。最终，FJ决定建一个人工湖供奶牛消暑之用。为了使湖看起来更加真实，FJ决定将湖的横截面建成N(1 <= N <= 100,000)个连续的平台高低错落的组合状，所有的平台从左到右按1..N依次编号。当然咯，在湖中注入水后，这些平台都将被淹没。    平台i在设计图上用它的宽度W\_i(1 <= W\_i <= 1,000)和高度（你可以理解为该平台顶离FJ挖的地基的高度）H\_i(1 <= H\_i <= 1,000,000)来描述的。所有平台的高度都是独一无二的。湖的边缘可以视为无限高的平台。下面给出了一张FJ的设计图：


按FJ的设想，在坑挖好后，他会以1单位/分钟的速度往最低的那个平台上注水。水在离开水管后立即下落，直到撞到平台顶或是更早些时候注入的水。然后，与所有常温下的水一样，它会迅速地流动、扩散。简单起见，你可以认为这些都是在瞬间完成的。FJ想知道，对于每一个平台，它的顶部是从哪个时刻开始，与水面的距离至少为1单位长度。


## 样例 #1

### 输入

```
3
4 2
2 7
6 4```

### 输出

```
4
50
26```

# AI分析结果



---
# 💡 Kay的C++算法解析：[USACO08JAN] Artificial Lake G 深入学习指南 💡

<introduction>
今天我们来分析这道经典的“人工湖注水”问题。通过理解水的流动规律和平台的合并过程，我们将掌握如何用单调栈或双向链表高效模拟注水过程，并计算每个平台被淹没的时间。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与单调栈/双向链表应用`

🗣️ **初步分析**：
解决这道题的关键在于模拟水从最低平台开始注入、流动并逐渐淹没其他平台的过程。想象一下，水总是先填满当前最低的平台，直到水面到达左右两侧更低的平台高度，此时这两个平台会合并成一个更大的“虚拟平台”，继续重复这一过程。这个过程可以用**单调栈**（维护递减的平台高度）或**双向链表**（快速合并相邻平台）高效实现。

- **题解思路对比**：大部分题解采用两种思路：① 单调栈维护递减的平台高度，遇到更高的平台时弹出栈顶并计算淹没时间；② 双向链表维护平台的左右关系，每次处理当前最低平台后合并相邻平台。两种方法本质都是模拟注水顺序，但栈更适合处理“先低后高”的层次结构，链表更直观体现平台的合并。
- **核心算法流程**：从最低平台开始，每次选择左右两侧更低的一侧处理，合并被淹没的平台（累加宽度），计算当前平台的淹没时间（当前总时间+自身宽度），并更新总时间（宽度×高度差）。
- **可视化设计**：采用8位像素风格，用不同颜色的方块代表平台（高度越高颜色越深），水填充时用蓝色渐变覆盖，合并时平台宽度动态扩展，时间数字实时更新。关键步骤（如选择左右侧、合并平台）用闪烁箭头高亮，注水音效（“叮”声）提示操作完成。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下3道题解表现突出（均≥4星）：
</eval_intro>

**题解一：幻·光 (赞：11)**
* **点评**：此题解用单调栈模拟注水过程，思路清晰。代码中通过`sta1`数组维护栈结构，`l`和`r`指针向左右扩展，每次处理更低的一侧。变量名`kuandu`（宽度）、`gaodu`（高度）虽为拼音，但含义明确。关键逻辑（如栈的弹出条件、时间累加）注释完整，适合理解单调栈的应用。亮点在于栈的维护与平台合并的巧妙结合。

**题解二：LOVE_Ynoi (赞：6)**
* **点评**：此题解用双向链表（`pre`和`nxt`数组）维护平台的左右关系，逻辑直观。代码结构工整，变量名清晰（如`pre`前驱、`nxt`后继），处理合并时直接修改链表指针，效率高。亮点是链表操作的简洁性，适合理解平台合并的动态过程。

**题解三：kkksc031 (赞：3)**
* **点评**：此题解代码简洁，用栈和`min`函数处理左右高度，时间累加逻辑明确。变量名`h`（高度）、`w`（宽度）符合习惯，关键步骤（如找最低平台、栈的弹出）注释清晰。亮点是通过栈顶元素快速获取相邻平台高度，简化计算。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决本题时，以下三个关键点需要重点突破：
</difficulty_intro>

1.  **关键点1：确定注水顺序**
    * **分析**：水总是从当前最低的平台开始注入。如何快速找到并维护“当前最低平台”？可以通过遍历初始平台找到最低位置，后续通过比较左右平台高度动态调整（如链表法中的`now`指针，或栈法中的左右扩展）。
    * 💡 **学习笔记**：注水顺序由当前所有未淹没平台的最低高度决定，动态调整是关键。

2.  **关键点2：合并平台与时间计算**
    * **分析**：当一个平台被淹没后，水面到达左右两侧更低的平台高度，此时需要将这两个平台合并（累加宽度）。时间计算需考虑：当前总时间 + 平台宽度（淹没1单位的时间），以及填充到新高度的时间（宽度×高度差）。
    * 💡 **学习笔记**：合并后的“虚拟平台”宽度是原平台之和，时间累加需基于新高度与原高度的差值。

3.  **关键点3：高效维护待处理平台**
    * **分析**：直接暴力查找最低平台会超时（O(n²)），因此需用单调栈（维护递减序列，O(n)）或双向链表（动态删除合并，O(n)）优化。栈适合处理“先低后高”的层次，链表适合直观合并。
    * 💡 **学习笔记**：选择合适的数据结构（栈/链表）能将时间复杂度优化到线性。

### ✨ 解题技巧总结
- **问题抽象**：将注水过程抽象为“每次处理当前最低平台，合并相邻平台”的重复过程。
- **边界处理**：初始时设置左右边界为无限高（如`h[0] = h[n+1] = 1e9`），避免越界。
- **变量类型**：时间可能很大（如1e5×1e6=1e11），需用`long long`避免溢出。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，采用双向链表法（更直观），代码简洁且逻辑清晰。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了LOVE_Ynoi的双向链表思路，通过维护`pre`（前驱）和`nxt`（后继）指针动态合并平台，计算每个平台的淹没时间。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 1e5 + 5;
    int n, h[N], w[N], pre[N], nxt[N], now;
    long long ans[N], t;

    int main() {
        scanf("%d", &n);
        h[0] = h[n + 1] = 0x7f7f7f7f; // 左右边界设为极大值
        for (int i = 1; i <= n; ++i) {
            scanf("%d %d", &w[i], &h[i]);
            pre[i] = i - 1; nxt[i] = i + 1;
            if (h[i] < h[now]) now = i; // 找初始最低平台
        }
        while (pre[now] != 0 || nxt[now] != n + 1) {
            if (h[now] > h[pre[now]]) { now = pre[now]; continue; }
            if (h[now] > h[nxt[now]]) { now = nxt[now]; continue; }
            ans[now] = t + w[now]; // 淹没1单位的时间
            t += 1LL * w[now] * (min(h[pre[now]], h[nxt[now]]) - h[now]); // 填充到新高度的时间
            // 合并平台
            nxt[pre[now]] = nxt[now]; pre[nxt[now]] = pre[now];
            if (h[pre[now]] > h[nxt[now]]) { // 合并到右侧
                w[nxt[now]] += w[now]; now = nxt[now];
            } else { // 合并到左侧
                w[pre[now]] += w[now]; now = pre[now];
            }
        }
        ans[now] = t + w[now]; // 处理最后一个平台
        for (int i = 1; i <= n; ++i) printf("%lld\n", ans[i]);
        return 0;
    }
    ```
* **代码解读概要**：代码首先读取输入并初始化双向链表，找到初始最低平台`now`。循环处理`now`：若左右有更低的平台则移动`now`；否则计算`now`的淹没时间，合并到左右更低的一侧，更新链表和`now`。最后输出所有平台的时间。

---
<code_intro_selected>
以下是优质题解的核心代码片段分析：
</code_intro_selected>

**题解一：LOVE_Ynoi (双向链表法)**
* **亮点**：双向链表直观维护平台的左右关系，合并操作高效（仅需修改指针）。
* **核心代码片段**：
    ```cpp
    nxt[pre[now]] = nxt[now];
    pre[nxt[now]] = pre[now];
    ```
* **代码解读**：这两行代码实现了平台的删除（合并）。`pre[now]`是`now`的左邻居，`nxt[now]`是右邻居。将左邻居的右指针指向`now`的右邻居，右邻居的左指针指向`now`的左邻居，`now`就被从链表中删除了。
* 💡 **学习笔记**：双向链表的指针操作是动态合并的关键，时间复杂度为O(1)。

**题解二：幻·光 (单调栈法)**
* **亮点**：单调栈维护递减的平台高度，确保每次处理的是当前最低平台。
* **核心代码片段**：
    ```cpp
    while (tt > 0 && a[l].gao > a[sta1[tt]].gao) {
        a[sta1[tt]].kuandu += kuan;
        ans[sta1[tt]] = now + a[sta1[tt]].kuandu;
        kuan = a[sta1[tt]].kuandu;
        now += (min(a[sta1[tt-1]].gao, a[l].gao) - a[sta1[tt]].gao) * a[sta1[tt]].kuandu;
        tt--;
    }
    ```
* **代码解读**：当当前平台（`a[l]`）高度大于栈顶平台时，弹出栈顶（`sta1[tt]`），累加宽度（`kuan`），计算该平台的淹没时间（`now + 宽度`），并更新总时间（宽度×高度差）。循环直到栈顶高度大于当前平台。
* 💡 **学习笔记**：单调栈的弹出条件确保了处理顺序是“先低后高”，避免重复计算。

**题解三：kkksc031 (栈法简化版)**
* **亮点**：代码简洁，用`min`函数直接处理左右高度，减少条件判断。
* **核心代码片段**：
    ```cpp
    while (!q.empty() && h[p] > h[q.top()]) {
        int u = q.top(); q.pop();
        s += w[u];
        ans[u] = sum + s;
        int o = q.empty() ? 0 : q.top();
        sum += (min(h[p], h[o]) - h[u]) * s;
    }
    ```
* **代码解读**：`p`是当前处理的平台，若其高度大于栈顶（`q.top()`），则弹出栈顶，累加宽度（`s`），计算淹没时间（`sum + s`），并更新总时间（`sum += 宽度×高度差`）。
* 💡 **学习笔记**：栈顶弹出后，新的栈顶（`o`）即为左侧更高的平台，与`p`的最低高度决定填充高度。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观展示注水过程，我们设计一个“像素湖探险”动画，用8位像素风格模拟平台注水、合并的动态过程。
</visualization_intro>

  * **动画演示主题**：`像素湖注水大冒险`

  * **核心演示内容**：从最低平台开始，水蓝色像素逐渐填充，平台合并时宽度扩展，时间数字实时跳动，关键步骤（选择左右侧、合并）用闪烁箭头提示。

  * **设计思路简述**：8位像素风格（如FC游戏画面）降低学习门槛，水填充的蓝色渐变强化“流动”感；合并时平台宽度扩展的动画（像素块滑动）直观展示宽度累加；时间数字的跳动和“叮”声提示操作完成，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
        - 屏幕下方用不同颜色的像素块表示平台（高度越高颜色越深），左右边界用灰色无限高块标记。
        - 控制面板：开始/暂停、单步、重置按钮，速度滑块（0.5x~2x）。
        - 播放8位风格的轻快背景音乐（如《超级玛丽》主题变调）。

    2.  **初始注水**：
        - 找到最低平台（用黄色闪烁标记），水蓝色像素从底部开始填充，1秒填充1单位（对应时间+1），伴随“滴答”音效。
        - 当水面到达左右较低平台高度时，触发合并动画：平台宽度扩展（像素块向右/左滑动），原平台颜色变浅（表示已淹没）。

    3.  **动态处理**：
        - 每次处理当前最低平台时，用红色箭头指向左右更低的一侧（如左低则箭头左指）。
        - 合并时，原平台的像素块“融合”到相邻平台（如左平台宽度增加，像素块左移并扩展）。
        - 时间数字（右上角）实时更新，合并时显示“时间 += 宽度×高度差”的计算过程（如`时间=4+2*3=10`）。

    4.  **目标达成**：
        - 所有平台淹没后，播放“胜利”音效（如《超级玛丽》吃金币声），屏幕显示“所有平台已淹没！”。

    5.  **交互控制**：
        - 单步执行：每点击一次，执行一个注水或合并步骤，显示当前操作的平台和时间。
        - 自动播放：按设置速度自动演示，学习者可观察完整流程。

  * **旁白提示**：
    - “现在处理最低平台，水开始填充...时间增加它的宽度！”
    - “左右有更低的平台，水会流向那边，合并这两个平台！”
    - “合并后，新平台的宽度是两者之和，继续处理下一个最低平台～”

<visualization_conclusion>
通过这个动画，我们能直观看到水如何从最低平台开始，一步步淹没并合并其他平台，时间如何随注水和合并累加。像素风格和游戏化元素让学习过程更有趣！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是“动态处理最低元素+合并相邻元素”，这种思路可迁移到多种场景：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - **容器装水问题**（如接雨水）：计算每个位置能装多少水，需找到左右最高边界。
    - **合并石子**：每次合并相邻石子，求最小代价，需动态选择最优合并顺序。
    - **任务调度**：按优先级处理任务，动态调整剩余任务的优先级。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1198** - `最大数`
        * 🗣️ **推荐理由**：用单调栈维护递减序列，动态查询区间最大值，与本题的栈应用类似。
    2.  **洛谷 P1950** - `长方形`
        * 🗣️ **推荐理由**：计算矩形区域内的最大长方形面积，需用单调栈处理高度递减的柱子，与本题的平台合并逻辑相似。
    3.  **洛谷 P1856** - `树状数组`（括号画家）
        * 🗣️ **推荐理由**：用栈匹配括号，计算最长有效括号子串，练习栈的灵活应用。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自 巨型方块)**：“最初没考虑到合并后宽度累加的顺序，导致时间计算错误。后来通过打印中间变量（如`w[now]`和`now`的变化）定位了问题。”

> **点评**：这位作者的经验很实用！在处理动态合并的问题时，中间变量（如宽度、当前平台）的变化容易出错。通过打印或调试工具跟踪这些变量，能快速定位错误。学习时，遇到类似问题可尝试手动模拟小样例，验证逻辑是否正确。

---

<conclusion>
通过分析“人工湖注水”问题，我们掌握了用单调栈或双向链表模拟动态合并的技巧，理解了注水顺序和时间计算的核心逻辑。希望大家通过练习巩固这些方法，在编程路上更进一步！下次见～💪
</conclusion>

---
处理用时：168.75秒
# 题目信息

# [APIO2009] 抢掠计划

## 题目描述

Siruseri 城中的道路都是单向的。不同的道路由路口连接。按照法律的规定，在每个路口都设立了一个 Siruseri 银行的 ATM 取款机。令人奇怪的是，Siruseri 的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。  

Banditji 计划实施 Siruseri 有史以来最惊天动地的 ATM 抢劫。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆祝他的胜利。  

使用高超的黑客技术，他获知了每个 ATM 机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机里面就不会再有钱了。 例如，假设该城中有 $6$ 个路口，道路的连接情况如下图所示：  

![](https://cdn.luogu.com.cn/upload/pic/4396.png)  

市中心在路口 $1$，由一个入口符号 → 来标识，那些有酒吧的路口用双圈来表示。每个 ATM 机中可取的钱数标在了路口的上方。在这个例子中，Banditji 能抢劫的现金总数为 $47$，实施的抢劫路线是：$1-2-4-1-2-3-5$。

## 说明/提示

对于 $50\%$ 的数据，保证 $N, M \le 3000$。  

对于 $100\%$ 的数据，保证 $N, M \le 5\times 10^5$，$0 \le a_i \le 4000$。保证可以从市中心沿着 Siruseri 的单向的道路到达其中的至少一个酒吧。

## 样例 #1

### 输入

```
6 7 
1 2 
2 3 
3 5 
2 4 
4 1 
2 6 
6 5 
10 
12 
8 
16 
1 
5 
1 4 
4 3 5 6```

### 输出

```
47```

# AI分析结果



---

# 💡 Kay的C++算法解析：抢掠计划 深入学习指南 💡

<introduction>
今天我们要一起攻克的是APIO2009的经典题目“抢掠计划”。这道题结合了图论中的强连通分量（SCC）和最长路径问题，通过一步步拆解，我们能更清晰地理解如何用Tarjan缩点和SPFA算法解决这类问题。让我们开始吧！
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论中的强连通分量（Tarjan缩点）与最长路径（SPFA/拓扑排序）

🗣️ **初步分析**：
题目要求我们从起点出发，抢劫所有经过的ATM机，最终在任意一个酒吧结束，求最大金额。关键点在于“可以重复经过路口”，但每个ATM机只能抢一次。这意味着，一旦进入一个强连通分量（SCC，即环），就能抢完该环内的所有ATM机（因为可以绕圈走）。因此，我们需要用Tarjan算法将原图缩点，将每个SCC视为一个点，权值为该SCC的总金额。缩点后的图是有向无环图（DAG），此时只需在DAG上求从起点所在SCC出发的最长路径，终点是包含酒吧的SCC。

- **题解思路**：所有题解的核心思路一致：Tarjan缩点→重建DAG→求最长路。部分题解用SPFA，部分用拓扑排序DP，本质都是处理DAG的最长路径。
- **核心难点**：Tarjan算法的正确实现（避免栈溢出）、缩点后图的正确构建、最长路径的高效计算。
- **可视化设计**：用8位像素风格动画展示Tarjan缩点过程（节点入栈、标记、弹栈），缩点后的DAG结构，以及SPFA中节点松弛的过程（颜色变化、队列操作）。例如，节点入栈时用蓝色闪烁，弹栈缩点时用黄色渐变；SPFA中当前处理节点用绿色高亮，松弛成功时边变红色。

---

## 2. 精选优质题解参考

<eval_intro>
经过对多个题解的评估（思路清晰度、代码规范性、算法有效性），以下题解因逻辑清晰、代码规范且高效，值得重点参考：
</eval_intro>

### 题解一：Lucaster_ 的 Tarjan+SPFA 实现（赞：84）
* **点评**：该题解详细展示了Tarjan缩点、重建图、SPFA求最长路的全流程。代码结构清晰，变量命名规范（如`sum[tot]`表示缩点后的权值，`g[tp]`记录节点所属SCC），尤其在处理输入和缩点后的图构建时逻辑严谨。SPFA部分通过修改松弛条件（`dis[t] < dis[h] + e[i].val`）实现最长路，是典型的DAG最长路解法。

### 题解二：javalyc 的 Tarjan+拓扑DP 实现（赞：48）
* **点评**：该题解利用缩点后的DAG特性，按拓扑序动态规划（DP）。状态定义`f[i]`表示到达第i个SCC的最大金额，转移时取前驱节点的最大值加上当前SCC的权值。拓扑排序避免了SPFA可能的队列操作，代码简洁高效，适合理解DAG上的DP应用。

### 题解三：FREEH 的 Tarjan+SPFA 实现（赞：1）
* **点评**：该题解代码简洁，重点突出。通过Tarjan缩点后，直接用SPFA求最长路，代码逻辑清晰，注释详细，适合初学者理解每一步操作。尤其在处理缩点后的边时，明确判断两个节点是否属于不同SCC，避免了重复边的干扰。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们可能会遇到以下关键难点。通过分析优质题解的共性，我们总结了应对策略：
</difficulty_intro>

### 1. 关键点1：正确实现Tarjan缩点
- **分析**：Tarjan算法需要维护`dfn`（访问顺序）、`low`（能到达的最小`dfn`）和栈。若递归过深可能导致栈溢出（如数据量大时）。优质题解通过非递归实现或调整栈大小避免此问题。
- 💡 **学习笔记**：Tarjan的核心是`low[u] = min(low[u], low[v])`（树边）和`low[u] = min(low[u], dfn[v])`（回边），缩点时弹栈直到`dfn[u] == low[u]`。

### 2. 关键点2：缩点后图的正确构建
- **分析**：缩点后需将原图的边转换为SCC之间的边，需避免同一SCC内的边。优质题解通过遍历原图所有边，检查起点和终点是否属于同一SCC，仅保留不同SCC之间的边。
- 💡 **学习笔记**：缩点后的图是DAG，边的权值为终点SCC的总金额（因为进入该SCC后能抢完所有ATM机）。

### 3. 关键点3：DAG上的最长路求解
- **分析**：DAG无环，最长路可通过拓扑排序+DP或SPFA实现。SPFA通过松弛操作更新最长路径，拓扑排序则按顺序处理节点，确保每个节点处理时其前驱已处理完毕。
- 💡 **学习笔记**：SPFA在DAG上无需担心环，只需按任意顺序松弛；拓扑排序则更高效（O(N+M)），适合大规模数据。

### ✨ 解题技巧总结
- **Tarjan缩点**：标记每个节点所属SCC，计算SCC总金额和是否含酒吧。
- **图重建**：仅保留不同SCC之间的边，避免环。
- **最长路求解**：SPFA或拓扑DP，根据数据规模选择（SPFA更简单，拓扑DP更高效）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合多个优质题解，提炼出一个简洁高效的核心实现，涵盖Tarjan缩点、图重建和SPFA求最长路的完整流程。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了Lucaster_和FREEH的题解，采用Tarjan缩点和SPFA求最长路，逻辑清晰，适合学习。
* **完整核心代码**：
```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#define N 500005
using namespace std;

struct Edge {
    int to, val, next;
} e[N];
int n, m, p, s, cnt, g[N], u[N], v[N], w[N], hd[N], bar[N], dis[N];
int dfn[N], low[N], stk[N], sum[N], vis[N];
queue<int> q;
int ans = 0, top = 0, tot = 0, total = 0;

void add(int u, int v) {
    cnt++;
    e[cnt].to = v;
    e[cnt].next = hd[u];
    hd[u] = cnt;
}

void build(int u, int v, int w) {
    cnt++;
    e[cnt].to = v;
    e[cnt].val = w;
    e[cnt].next = hd[u];
    hd[u] = cnt;
}

void clear() {
    cnt = 0;
    memset(e, 0, sizeof(e));
    memset(hd, 0, sizeof(hd));
}

void readln() {
    clear();
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &u[i], &v[i]);
        add(u[i], v[i]);
    }
    for (int i = 1; i <= n; i++) scanf("%d", &w[i]);
    scanf("%d%d", &s, &p);
    for (int i = 1; i <= p; i++) scanf("%d", &bar[i]);
}

void Tarjan(int x) {
    dfn[x] = low[x] = ++total;
    stk[++top] = x;
    vis[x] = true;
    for (int i = hd[x]; i; i = e[i].next) {
        int t = e[i].to;
        if (!dfn[t]) {
            Tarjan(t);
            low[x] = min(low[x], low[t]);
        } else if (vis[t])
            low[x] = min(low[x], dfn[t]);
    }
    if (dfn[x] == low[x]) {
        tot++;
        do {
            int tp = stk[top];
            sum[tot] += w[tp];
            vis[tp] = false;
            g[tp] = tot;
        } while (stk[top--] != x);
    }
}

void Spfa(int s) {
    memset(dis, 0, sizeof(dis));
    int gs = g[s];
    q.push(gs);
    vis[gs] = true;
    dis[gs] = sum[gs];
    while (!q.empty()) {
        int h = q.front();
        q.pop();
        vis[h] = false;
        for (int i = hd[h]; i; i = e[i].next) {
            int t = e[i].to;
            if (dis[t] < dis[h] + e[i].val) {
                dis[t] = dis[h] + e[i].val;
                if (!vis[t]) {
                    q.push(t);
                    vis[t] = true;
                }
            }
        }
    }
}

int main() {
    readln();
    for (int i = 1; i <= n; i++)
        if (!dfn[i]) Tarjan(i);
    clear();
    for (int i = 1; i <= m; i++)
        if (g[u[i]] != g[v[i]])
            build(g[u[i]], g[v[i]], sum[g[v[i]]]);
    Spfa(s);
    for (int i = 1; i <= p; i++)
        ans = max(ans, dis[g[bar[i]]]);
    printf("%d", ans);
    return 0;
}
```
* **代码解读概要**：代码首先读取输入并构建原图，通过Tarjan算法找到所有SCC并计算每个SCC的总金额。然后重建缩点后的图，仅保留不同SCC之间的边。最后用SPFA求最长路，遍历所有酒吧所在的SCC，取最大值输出。

---

<code_intro_selected>
以下是对优质题解的核心代码片段赏析：
</code_intro_selected>

### 题解一：Lucaster_ 的 Tarjan 缩点片段
* **亮点**：正确处理缩点过程，累加SCC的总金额，并标记节点所属SCC。
* **核心代码片段**：
```cpp
void Tarjan(int x) {
    dfn[x] = low[x] = ++total;
    stk[++top] = x;
    vis[x] = true;
    for (int i = hd[x]; i; i = e[i].next) {
        int t = e[i].to;
        if (!dfn[t]) {
            Tarjan(t);
            low[x] = min(low[x], low[t]);
        } else if (vis[t])
            low[x] = min(low[x], dfn[t]);
    }
    if (dfn[x] == low[x]) {
        tot++;
        do {
            int tp = stk[top];
            sum[tot] += w[tp];
            vis[tp] = false;
            g[tp] = tot;
        } while (stk[top--] != x);
    }
}
```
* **代码解读**：`dfn`记录访问顺序，`low`记录能到达的最小`dfn`。节点入栈后，遍历其所有邻接点，更新`low`值。当`dfn[x] == low[x]`时，弹栈并将栈中节点归为同一SCC，累加金额并标记所属SCC。
* 💡 **学习笔记**：Tarjan的关键是维护`low`和栈，确保每个SCC被正确识别。

### 题解二：javalyc 的拓扑DP片段
* **亮点**：利用拓扑序动态规划，高效求解DAG最长路。
* **核心代码片段**：
```cpp
void DP() {
    q.push(be[sta]);
    f[be[sta]] = sval[be[sta]];
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = firr[u]; i; i = fromm[i]) {
            int &v = too[i];
            f[v] = max(f[v], f[u] + sval[v]);
            if (!(--du[v])) q.push(v);
        }
    }
}
```
* **代码解读**：拓扑排序时，维护入度数组`du`，每次处理入度为0的节点。`f[v]`表示到达v的最大金额，通过前驱节点更新。
* 💡 **学习笔记**：拓扑DP适合DAG，确保处理每个节点时，其所有前驱已处理完毕，避免重复计算。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解Tarjan缩点和SPFA求最长路的过程，我们设计了一个8位像素风格的动画，让你“看”到算法如何工作！
</visualization_intro>

  * **动画演示主题**：`像素大冒险——SCC缩点与最长路探索`

  * **核心演示内容**：
    - Tarjan缩点：展示节点入栈、`dfn`和`low`的更新、弹栈缩点的过程。
    - SPFA最长路：展示队列操作、节点松弛（金额更新）的过程。

  * **设计思路简述**：采用FC红白机风格，用不同颜色标记节点状态（如未访问/灰色，访问中/蓝色，缩点后/黄色）。边用绿色表示正常，红色表示松弛成功。音效方面，节点入栈时“叮”一声，缩点时“咚”一声，松弛成功时“唰”一声，增加互动感。

  * **动画帧步骤与交互关键点**：

    1. **初始化场景**：
       - 屏幕左侧显示原图（节点用圆形，边用箭头），右侧显示代码（高亮当前执行行）。
       - 控制面板：单步/自动播放按钮、速度滑块、重置按钮。

    2. **Tarjan缩点过程**：
       - 从起点开始，节点依次被访问（颜色变蓝），入栈时弹出“入栈”提示。
       - 当`low[x] == dfn[x]`时，栈顶节点依次弹出（颜色变黄），缩成一个SCC，显示该SCC的总金额。

    3. **SPFA最长路过程**：
       - 缩点后的DAG显示在右侧，起点SCC颜色变绿，初始金额显示。
       - 队列中的节点闪烁，处理时弹出队列，遍历其邻接SCC，松弛成功时边变红色，目标SCC的金额更新。

    4. **结果展示**：
       - 所有酒吧所在SCC的金额高亮，最大值用金色闪烁，伴随“胜利”音效。

  * **旁白提示**：
    - “现在，我们进入Tarjan算法！节点1被访问，入栈。”
    - “节点2的`low`值更新为1，因为它能回到节点1。”
    - “SPFA开始！起点SCC的金额是10，现在处理它的邻接SCC。”

<visualization_conclusion>
通过这个动画，你能直观看到SCC的形成和最长路的计算过程，理解每个步骤的意义。动手操作控制面板（单步/自动），还能深入观察细节！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可以尝试以下相似问题，巩固Tarjan缩点和最长路的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - Tarjan缩点适用于所有需要处理环的图论问题（如求强连通分量、缩点后DAG的最长/最短路）。
    - 最长路在DAG上可通过拓扑排序或SPFA求解，关键是将问题转化为无环图。

  * **练习推荐 (洛谷)**：
    1. **洛谷 P2656 [ZJOI2007] 最大半连通子图**  
       🗣️ 推荐理由：同样需要Tarjan缩点，求DAG上的最长路径，适合巩固缩点和最长路的应用。
    2. **洛谷 P1262 间谍网络**  
       🗣️ 推荐理由：涉及强连通分量的缩点和入度统计，适合练习缩点后的图处理。
    3. **洛谷 P3387 缩点**  
       🗣️ 推荐理由：标准Tarjan缩点+DAG最长路问题，适合入门练习。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到，Tarjan递归过深可能导致栈溢出（如数据量大时）。例如，用户“Fellyhosn”在题解中提到，递归实现的Tarjan在数据量大时会RE，改用非递归实现后通过。
</insights_intro>

> **参考经验**：“递归Tarjan在n=5e5时容易栈溢出，改用非递归（用栈模拟递归）可避免此问题。”

**点评**：递归深度过大时，系统栈可能不足，导致运行错误。非递归实现通过手动维护栈，避免了这一问题，是处理大规模数据的关键技巧。学习时需注意，对于可能深递归的算法（如Tarjan），非递归实现更稳健。

---

<conclusion>
通过这篇指南，我们系统学习了“抢掠计划”的解法：用Tarjan缩点处理环，再在DAG上求最长路。关键是理解强连通分量的性质和缩点后的图处理。记住，多动手写代码、调试，结合动画理解算法流程，能更快掌握这类问题！下次挑战更难的题目吧，加油！💪
</conclusion>

---

---
处理用时：235.21秒
# 题目信息

# 「EZEC-14」众数 II

## 题目背景

dXqwq 是一个不可爱的男孩子。他在 NOI2022 中的众数一题定义了 $10^6$ 个 ``std::deque`` 并成功 MLE。

## 题目描述

给定一个长度为 $n$ 的序列 $a$，我们通过以下方式构造序列 $b$：

- 初始时 $b$ 为空序列。
- 对于 $i=1,2,\cdots,n$，我们依次向 $b$ 的尾部插入 $1,2,\cdots,a_i$。

dXqwq 定义一个序列的**最小众数**为所有出现次数最大的数的最小值。例如 $[1,1,4,5,1,4]$ 的最小众数为 $1$，而 $[1,14,5,14,19,19,8,10]$ 的最小众数为 $14$。

你需要求出 $b$ 的每个子区间的**最小众数**的和。由于答案可能很大，你只需要输出它对 $998244353$ 取模后的值。

## 说明/提示

**【样例解释】**

在第一个样例中，$b=[1,1,2,1,2,3]$。

有 $15$ 个区间的最小众数为 $1$，$5$ 个区间的最小众数为 $2$，$1$ 个区间的最小众数为 $3$，因此答案为 $15\times 1+5\times 2+1\times 3=28$。

**【提示】**

开 $10^6$ 个 ``std::deque`` 在空间限制为 512MB 时一定会 MLE。

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（10 pts）：$\sum a_i\leq 100$。
- Subtask 2（20 pts）：$\sum a_i\leq 10^3$。 
- Subtask 3（20 pts）：$\sum a_i\leq 10^6$。
- Subtask 4（10 pts）：$n\leq 2$。
- Subtask 5（20 pts）：$n\leq 10^3$。
- Subtask 6（10 pts）：$a_i\leq 2$。
- Subtask 7（10 pts）：无特殊限制。 

对于 $100\%$ 的数据，$1\leq n\leq 10^6$，$1\leq a_i\leq 10^6$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
28```

## 样例 #2

### 输入

```
9
9 9 8 2 4 4 3 5 3```

### 输出

```
1912
```

# AI分析结果



---

# 💡 Kay的C++算法解析：「EZEC-14」众数 II 深入学习指南 💡

<introduction>
今天我们要挑战的题目是「EZEC-14」众数 II。这道题需要计算由序列a构造的序列b的所有子区间的最小众数之和。由于b的长度可能极大（甚至达到1e12），直接构造b并暴力计算显然不可行。别担心，我们通过分析题解中的关键性质，结合高效算法优化，就能轻松解决！
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学建模与统计 + 并查集优化`

🗣️ **初步分析**：
解决这道题的关键在于发现一个核心性质：一个区间的最小众数要么是1，要么是该区间的左端点值（即b的左端点对应的数）。简单来说，假设区间的最小众数是i（i≠1），那么这个区间的左端点一定是i，否则i-1的出现次数会不少于i，导致i不可能是最小众数。这个性质将问题转化为统计每个i（从大到小）作为最小众数的区间数量，最后处理i=1的情况（用总区间数减去其他i的数量）。

- **题解思路**：多数优质题解（如larsr、dead_X等）采用“从大到小枚举i，用并查集维护连续的a_j≥i的区间”的方法。对于每个i，统计这些连续区间内所有可能的子区间数量（即i作为最小众数的区间数），最后累加贡献。
- **核心难点**：如何高效统计每个i的区间数，避免O(n²)的时间复杂度。解决方案是利用并查集动态合并连续的a_j≥i的区间，快速计算每个区间的贡献。
- **可视化设计**：我们将设计一个8位像素动画，用不同颜色表示a数组中≥当前i的元素（如绿色）和< i的元素（红色）。合并区间时，用像素块滑动连接相邻的绿色块，同时显示贡献值的计算过程（如弹出数字气泡展示当前区间的贡献）。关键操作（如合并、计算贡献）会伴随“叮”的像素音效，目标达成时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，我们筛选出以下3篇优质题解（评分均≥4星）：
</eval_intro>

**题解一：larsr的并查集优化解法**  
*来源：洛谷用户larsr*  
*点评*：这篇题解详细推导了4个关键定理（如“最小众数为i的区间左端点必为i”），思路严谨。代码中使用并查集动态合并连续的a_j≥i的区间，高效计算每个i的贡献。变量命名规范（如`now`记录当前贡献总和，`ji`记录区间长度相关项），边界处理严谨（如取模操作）。亮点在于从大到小枚举i，利用并查集合并区间的技巧，将时间复杂度优化到O(n + max a_i)，非常适合竞赛场景。

**题解二：dead_X的链表维护极长段解法**  
*来源：洛谷用户dead_X*  
*点评*：该题解通过链表维护极长的a_j≥l的段，思路简洁。代码中用`l[]`和`r[]`数组记录每个位置的左右边界，动态合并相邻段，计算贡献。变量如`sf`（记录∑i*a_i）和`sg`（记录∑长度）设计巧妙，直接关联数学公式。亮点是将复杂的区间统计转化为链表操作，代码简洁高效，适合理解极长段合并的逻辑。

**题解三：Lucky_Xiang的w数组维护次数解法**  
*来源：洛谷用户Lucky_Xiang*  
*点评*：此题解通过维护`w`数组（记录每个位置的“权重”），动态更新每个i的贡献。代码中`S`（∑w_i*a_i）和`ccnt`（∑w_i）的设计体现了数学建模的思想，将问题转化为线性统计。亮点是从“权重”角度重新定义贡献，适合理解如何通过预处理和动态更新优化统计过程。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点主要集中在以下三个方面，我们逐一分析并给出策略：
</difficulty_intro>

1.  **关键点1：发现最小众数的性质**  
    *分析*：如何确定一个区间的最小众数只能是1或左端点？通过反证法：若最小众数i≠1且左端点不是i，则i-1的出现次数≥i的出现次数（因为i的每个出现前必有一个i-1），矛盾。  
    *学习笔记*：遇到统计众数的问题，先观察数的分布规律，尤其是相邻数的出现关系。

2.  **关键点2：高效统计每个i的区间数**  
    *分析*：直接枚举所有可能的区间会超时，需用并查集或链表维护连续的a_j≥i的区间。这些区间内的子区间才可能以i为最小众数，合并相邻区间可减少重复计算。  
    *学习笔记*：处理“连续段”问题时，并查集或链表是高效合并区间的常用工具。

3.  **关键点3：处理i=1的情况**  
    *分析*：i=1的区间数无法直接统计（因为它可能出现在任何不满足其他i条件的区间），需用总区间数减去其他i的区间数。总区间数为b的长度m的m*(m+1)/2（m=∑a_i）。  
    *学习笔记*：当直接计算困难时，考虑用“补集”思想，总数量减去其他情况的数量。

### ✨ 解题技巧总结
- **性质推导**：先通过小例子观察规律，再用反证法证明关键性质（如最小众数的取值范围）。
- **并查集优化**：动态合并连续段，快速计算每个i的贡献，避免重复枚举区间。
- **补集思想**：当直接统计某情况困难时，用总数量减去其他情况的数量（如i=1的处理）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合larsr的并查集解法和dead_X的链表思路，提炼出一个通用的核心实现，兼顾清晰性和高效性：
</code_intro_overall>

**本题通用核心C++实现参考**  
*说明*：此代码综合了larsr的并查集合并和区间贡献计算思路，适用于大范围数据（n≤1e6，a_i≤1e6）。  
*完整核心代码*：
```cpp
#include <cstdio>
#include <algorithm>
#define N 1000010
#define mod 998244353 
#define ll long long
using namespace std;

struct Node {
    ll a;
    int id;
} p[N];

int n, f[N], v[N];
ll now = 0, ji = 0, sum[N], siz[N], ci = 0, ans = 0;

bool cmp(Node x, Node y) {
    return x.a < y.a;
}

int find(int x) {
    return f[x] == x ? x : f[x] = find(f[x]);
}

void uni(int x, int y) {
    if (siz[x] > siz[y]) swap(x, y);
    f[x] = y;
    siz[y] += siz[x];
    sum[y] = (sum[y] + sum[x]) % mod;
}

ll lon(ll x) {
    return (x % 2) ? (x * ((x + 1) / 2) % mod) : ((x / 2) * (x + 1) % mod);
}

void hb(int x, int y) {
    ji = (ji - lon(siz[x]) - lon(siz[y]) + lon(siz[x] + siz[y]) + 2 * mod) % mod;
    now = (now + sum[y] * siz[x]) % mod;
    uni(x, y);
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%lld", &p[i].a), p[i].id = i;
    for (int i = 1; i <= n; i++) f[i] = i, siz[i] = 1;
    sort(p + 1, p + 1 + n, cmp);
    int j = n;
    for (ll i = 1e6; i > 1; i--) {
        while (j >= 1 && p[j].a == i) {
            int id = p[j].id;
            v[id] = 1;
            sum[id] = i;
            ji = (ji + 1) % mod;
            now = (now + i) % mod;
            if (id > 1 && v[id - 1]) hb(find(id - 1), find(id));
            if (id < n && v[id + 1]) hb(find(id), find(id + 1));
            j--;
        }
        ci = (ci + (now - ji * (i - 1) % mod + mod) % mod) % mod;
        ans = (ans + (now - ji * (i - 1) % mod + mod) % mod * i) % mod;
    }
    ll total = 0;
    for (int i = 1; i <= n; i++) total = (total + p[i].a) % mod;
    total = lon(total);
    ans = (ans + (total - ci + mod) % mod) % mod;
    printf("%lld\n", ans);
    return 0;
}
```
*代码解读概要*：  
代码首先读取输入并排序，然后从大到小枚举i（从1e6到2）。对于每个i，用并查集合并所有a_j≥i的连续区间，计算这些区间的贡献（`now`记录∑i*a_j的和，`ji`记录区间长度相关项）。最后，总区间数减去其他i的贡献得到i=1的贡献，累加所有i的贡献得到答案。

---

<code_intro_selected>
接下来，我们分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：larsr的并查集合并代码**  
*亮点*：并查集动态合并区间，高效计算贡献。  
*核心代码片段*：
```cpp
int find(int x) {
    return f[x] == x ? x : f[x] = find(f[x]);
}

void hb(int x, int y) {
    ji = (ji - lon(siz[x]) - lon(siz[y]) + lon(siz[x] + siz[y]) + 2 * mod) % mod;
    now = (now + sum[y] * siz[x]) % mod;
    uni(x, y);
}
```
*代码解读*：  
`find`函数是并查集的路径压缩，用于快速查找根节点。`hb`函数处理合并两个区间的逻辑：更新`ji`（区间长度平方和）和`now`（贡献总和），然后合并两个集合。例如，合并区间x和y时，`ji`减去原区间的长度平方和，加上合并后的长度平方和；`now`加上右区间的和乘以左区间的长度（因为左区间的每个位置与右区间的每个位置组合都会产生新的贡献）。  
*学习笔记*：并查集的合并操作需要同时维护与区间相关的统计量（如长度、和），这是动态规划区间贡献的关键。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解并查集合并区间和计算贡献的过程，我们设计了一个“像素区间探险家”动画，结合8位复古风格，让你“看”到算法如何工作！
</visualization_intro>

* **动画演示主题**：像素探险家的区间合并之旅  
* **核心演示内容**：展示从大到小枚举i时，a数组中≥i的元素如何合并为连续区间，并计算这些区间的贡献。  
* **设计思路**：8位像素风（如FC游戏的方块）让学习更轻松；合并时的滑动动画和音效强化操作记忆；贡献值的数字气泡直观展示计算结果。

### 动画帧步骤与交互关键点：
1. **场景初始化**：  
   - 屏幕下方显示a数组的像素块（每个块高度为a_i，颜色初始为灰色）。  
   - 控制面板：单步/自动播放按钮、速度滑块（1-10倍速）、重置按钮。  
   - 背景播放8位风格的轻快BGM。

2. **枚举i（从大到小）**：  
   - 当前i值显示在屏幕上方（如“当前i=5”）。  
   - a数组中≥i的块变为绿色，<i的块保持红色（如i=5时，a_j≥5的块变绿）。

3. **合并连续绿色块**：  
   - 对于每个a_j=i的块，检查左右是否有绿色块（即a_{j-1}≥i或a_{j+1}≥i）。  
   - 合并时，绿色块滑动连接，伴随“叮”的音效（如j=3的块与j=4的块合并，形成一个更长的绿色区间）。  
   - 屏幕右侧显示当前合并后的区间列表（如“区间[2,5]，长度4，和=20”）。

4. **计算贡献**：  
   - 每个合并后的区间计算贡献（now和ji的更新），弹出数字气泡（如“贡献+30”）。  
   - 总贡献值实时更新在屏幕上方（如“总贡献=150”）。

5. **i=1的处理**：  
   - 所有i>1的贡献计算完成后，总区间数（m*(m+1)/2）减去其他贡献，得到i=1的贡献，伴随“胜利”音效（如“叮~”）。

<visualization_conclusion>
通过这个动画，你可以清晰看到并查集如何合并区间，以及每个i的贡献是如何计算的。像素风格和音效让抽象的算法变得生动有趣！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心思想（性质推导+并查集优化）适用于多种区间统计问题。以下是相关练习推荐：
</similar_problems_intro>

* **通用思路迁移**：  
  本题的“统计每个值的贡献+并查集合并连续段”方法，还可用于：  
  - 统计每个数作为区间最大值的次数（如“所有子数组的最大值之和”）。  
  - 统计满足特定条件（如≥k）的连续子数组数量（如“和为k的子数组数”）。  
  - 处理需要动态合并区间的问题（如“动态连通性判断”）。

* **练习推荐 (洛谷)**：  
  1. **P1972 [SDOI2009]HH的项链**  
     *推荐理由*：统计区间内不同数的个数，需用离线处理+树状数组，与本题的区间统计思想类似。  
  2. **P1197 [JSOI2008]星球大战**  
     *推荐理由*：动态处理连通性问题，需用并查集逆序操作，与本题的并查集合并思想相关。  
  3. **P1503 鬼子进村**  
     *推荐理由*：动态维护连续区间的长度，需用并查集或链表，与本题的区间合并逻辑相似。

---

## 7. 学习心得与经验分享

<insights_intro>
larsr在题解中分享了他的学习经历：从学而思转自学，克服借读困难，坚持OI学习。这些经验对我们很有启发：
</insights_intro>

> **参考经验**：“我在TCMS借读，没有学籍，CSP报名受限，但仍坚持自学。父母不理解，时间被压缩，但我知道OI对我的意义。”  
> **点评**：larsr的坚持和对算法的热爱值得我们学习。编程学习中，环境可能受限，但主动探索（如自学、看题解、动手实践）能突破限制。遇到困难时，多与志同道合的朋友交流，保持对问题的好奇心，是进步的关键。

---

<conclusion>
通过分析「EZEC-14」众数 II的关键性质和优质题解，我们掌握了用并查集优化区间统计的技巧。记住，遇到复杂问题时，先观察规律、推导性质，再用高效数据结构优化。希望大家在练习中不断巩固，下次挑战更难的题目！💪
</conclusion>

---
处理用时：192.11秒
# 题目信息

# 「PMOI-3」子树

## 题目背景

分割线下有形式化题面，可以配合食用。

## 题目描述

b6e0 有一棵树，树上第 $i$ 个点有价值 $a_i$。每条边长度为 $1$。

b6e0 会选择一个节点作为根节点。设这个节点为 $r$。然后，b6e0 会圈定一个节点的整个子树作为他的领地，设这个子树的根节点为 $u$。此时，树上的每个节点会给 b6e0 带来一些收益。在领地子树的根节点为 $u$ 的情况下，节点 $x$ 带来的收益 $f(x,u)$ 定义如下：
1. 当 $x$ 在 $u$ 的子树中时，它的收益为它父亲节点的收益加上它本身的价值 $a_x$；
2. 当 $x$ 不在 $u$ 的子树中时，它的收益为：与它相邻的节点中，与 $u$ 距离（到 $u$ 的简单路径长度）比 $x$ 到 $u$ 的距离远的节点，这些节点的收益**对 $998244353$ 取模**的最大值，再乘上 $a_x$。

在根节点为 $r$ 的情况下，定义以 $u$ 为子树的收益 $W(u)$ 为所有节点的 $f$ 值和。

当然，b6e0 有许多种选择根节点的方案。定义选 $r$ 为根节点的收益 $C(r)$ 为对于所有 $u$，以 $u$ 为子树的收益（$W(u)$）的和。对于每一个节点 $r$，求 $C(r)$。

---
形式化题面：

给你一棵有 $n$ 个节点的树，第 $i$ 个节点有点权 $a_i$，每条边的长度为 $1$。当根节点为 $r$ 时：

设 $F(x)$ 表示 $x$ 的父亲节点，特殊地，$F(r)=0$；$D(x,y)$ 表示 $x$ 到 $y$ 的简单路径的长度，特殊地，对于所有 $x$，$D(x,x)=0$；$A_x$ 表示 $x$ 的子树中的节点（包括 $x$ 本身）组成的集合，即 $A_x=\{y\mid D(x,y)=D(F(x),y)-1\}$，特殊地，$A_r=\{1,2,\cdots,n\}$；$B_x$ 表示与 $x$ 相邻的节点组成的集合，即 $B_x=\{y\mid D(x,y)=1\}$。

定义 $f(x,u)$：
$$f(x,u)=\begin{cases}f(F(x),u)+a_x&x\in A_u\\a_x\cdot\max_{y\in B_x,D(y,u)>D(x,u)}\{f(y,u)\bmod 998244353\}&x\not\in A_u\end{cases}$$
特殊地，对于所有 $x$，$f(0,x)=0$；在 $x\not\in A_u$ 的情况中，若对于所有 $y\in B_x$，都有 $D(y,u)\le D(x,u)$，则 $f(x,u)=a_x$。

定义节点 $u$ 的分数 $W(u)=\sum_{v=1}^nf(v,u)$。

定义节点 $r$ 的收益 $C(r)$ 表示以 $r$ 为根时，$\sum_{i=1}^nW(i)$ 的值。

对于每一个节点 $r$，求 $C(r)$。

**所有 $C(r)$ 对 $998244353$ 取模。**

## 说明/提示

【样例解释】

样例中的树如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/bs02n466.png)

例如在 $r=1$，$u=5$ 时，$f(2,u)=a_2=2$，$f(1,u)=a_1\cdot f(2,u)=14$，$f(3,u)=a_3\cdot f(1,u)=70$，$f(6,u)=a_6=5$，$f(4,u)=a_4\cdot\max\{f(3,u),f(6,u)\}=7000$，$f(5,u)=f(4,u)+a_5=7001$。

【数据范围】
- Subtask1（10pts）：$n\le200$，$a_i\le 10^3$；
- Subtask2（20pts）：$n\le10^3$；
- Subtask3（20pts）：树为一条链；
- Subtask4（20pts）：存在一个节点，使得它的度数为 $n-1$；
- Subtask5（30pts）：无特殊限制。

对于 $100\%$ 的数据，$1\le n\le5\times10^5$，$1\le a_i\le10^9$。

## 样例 #1

### 输入

```
6
7 2 5 100 1 5
1 3
3 4
1 2
4 5
4 6```

### 输出

```
67562
29930
75168
76888
63243
63283```

# AI分析结果


### 💡 Kay的C++算法解析：子树问题深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`树形动态规划` + `换根DP`  
🗣️ **初步分析**：  
> 本题如同在像素游戏地图中计算每个据点的战略价值。树形DP像构建防御塔系统：每个节点是据点，收益计算需考虑据点间的父子关系。核心思想是**预处理子树信息+动态换根**：
> - **子树内节点**：收益是到子树根的路径点权和（如塔防中的资源链）
> - **子树外节点**：收益由相邻节点最大值决定（如接收最强盟友信号）
> - **可视化设计**：采用8位像素风格，节点显示为不同颜色方块：
>   - 绿色方块：当前处理节点
>   - 蓝色连线：父子关系
>   - 黄色光晕：路径和计算过程
>   - "叮"音效：完成路径和计算
>   - 胜利音效：完成子树处理

#### 2. 精选优质题解参考
**题解（官方解法）**  
* **点评**：  
  思路清晰展现了树形DP的双重阶段：首次DFS自底向上计算子树信息（siz/ss/sp），二次DFS换根更新全局答案。代码中：
  - **变量设计**：`ss[x]`（子树路径和）、`sp[x]`（外围最大收益）等命名直击核心
  - **前缀/后缀最大值处理**（dp1函数）巧妙避免重复计算
  - **边界处理**：对叶子节点`sp[x]=a[x]`的设定严谨
  - **复杂度**：O(n)碾压暴力O(n²)解法

#### 3. 核心难点辨析与解题策略
1. **难点1：子树内外收益分离计算**  
   * **分析**：需同时维护路径和（ss）和外围最大收益（sp）。如`f(4,5)`需取`max(f(3,5),f(6,5))`  
   * 💡 学习笔记：像游戏中的"视野内/外"采用不同战斗策略

2. **难点2：换根时的信息继承**  
   * **分析**：根切换时（如1→2），仅相邻节点信息需更新（dp2中的`ans[x]=ans[f]-as[f]-uans[x]+...`）  
   * 💡 学习笔记：换根DP如更换指挥中心，只需调整相邻防区

3. **难点3：取模与值比较的冲突**  
   * **分析**：比较`sp`时用原始值，计算乘积时取模（`a[i]%mod`提前处理）  
   * 💡 学习笔记：战斗力和显示数值分开计算

#### 4. C++核心代码实现赏析
```cpp
// 关键结构定义
long long siz[N], ss[N], sp[N], as[N], ans[N];

void dfs(int x, int f) {
    siz[x] = 1;
    sp[x] = -1; // 初始化
    for (int child : g[x]) {
        if (child == f) continue;
        dfs(child, x);
        siz[x] += siz[child];
        ss[x] = (ss[x] + ss[child]) % mod; // 累加子树和
        sp[x] = max(sp[x], sp[child]); // 子树最大收益
    }
    sp[x] = (sp[x] == -1) ? a[x] : sp[x] * a[x] % mod;
}
```
**代码解读**：  
> - `dfs`如同从树叶向树根收集情报：  
>   `siz[x]`：据点兵力  
>   `ss[x]`：领地内资源总和  
>   `sp[x]`：边境最大贸易值  
> - 叶子节点处理：`sp[x]=a[x]`（无子节点时自给自足）

#### 5. 算法可视化：像素动画演示
**主题**：`树形战略地图`  
**关键帧设计**：  
1. **地图初始化**（8-bit风格）：
   - 节点：彩色像素方块（根节点为金色）
   - 边：蓝色发光线条
   - 控制台：速度滑块+单步执行按钮

2. **DFS过程**（伴随音效）：
   ```plaintext
   [叶节点] 闪烁绿光 → 计算sp[] → "叮"音效
   [父节点] 接收子节点数据 → 方块颜色渐变
   ```

3. **换根动态演示**：
   - 根切换时：原根节点变灰，新根节点闪烁红光
   - 数据更新：受影响节点显示刷新动画
   - 音效：根切换时播放"传送"音效

**交互设计**：  
- **AI演示模式**：自动播放三次DFS流程
- **关卡设计**：每完成一个子树计算解锁新区域

#### 6. 拓展练习
1. **洛谷P1395**（会议）：  
   > 练习换根DP求带权重心
2. **洛谷P3047**（附近的牛）：  
   > 树形DP+距离维护
3. **洛谷P3478**（STA-Station）：  
   > 换根DP经典题

#### 7. 学习心得
> 官方题解强调：**比较最大值时勿取模**（调试难点）。这提醒我们：
> - 功能性和显示性数据分开处理
> - 提前对输入值取模（`a[i]%mod`）避免溢出

> 掌握树形DP如同指挥像素军团作战：  
> **情报收集**（DFS）→ **战略调整**（换根）→ **全域制霸**（O(n)解法）！

---
处理用时：82.75秒
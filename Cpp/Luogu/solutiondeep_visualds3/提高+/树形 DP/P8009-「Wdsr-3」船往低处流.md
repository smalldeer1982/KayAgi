# 题目信息

# 「Wdsr-3」船往低处流

## 题目背景

村纱水密是控制着圣辇船的船长。因为是一生和船相伴的船幽灵，因此对船只非常感兴趣。正因为这样的爱好，村纱有一大堆船模。

由于间歇泉的喷发，间歇泉的周围出现了一个汇聚了多方水流的大水坑。不同的水流交错，形成了大大小小的水道。只需要把船模放在某个位置，它就会顺着水流流动。根据物理原理，船自然会从高处流向低处。由于水坑由四处的水汇集而成，因此水坑的中央地势最低；随着到中央距离的增加，地势不断增加。

村纱发现，当她选定了两个位置放下船模后，它们会在某个水流的交汇处发生碰撞。村纱关心碰撞发生的位置。容易发现，第一个可能会产生碰撞的位置，就是在树形结构上这两个选定的点的最近公共祖先。

当然了，由于间歇泉并不稳定，因此水池中央的位置可能会不断变化，地势也不断变化，但是水道并不会发生任何改变。村纱给每个交汇处标上了一个数值「危险程度」，表示两个船模在此处碰撞可能会发生的危险的大小。村纱放置船模的位置也是随机的。

不过由于水坑实在是太大，水坑中央又不断变化，因此只关心船模的村纱被绕晕了。她迫切地想知道在水坑处玩船模产生的威胁，因此希望你帮她计算。

## 题目描述

这些水道形成了一棵以 $1$ 为根的节点数为 $n$ 的树形结构 $T$。每个节点上有一个点权 $w_i$，表示它的危险程度。现做出如下定义：

- **最近公共祖先**：在一棵以 $r$ 为根的有根树上，两个节点 $u,v$ 的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个，记作 $\operatorname{lca}(r,u,v)$。
- **子树**：树 $T$ 上，删掉节点 $u$ 与父亲相连的边后，该结点所在的子图记为子树 $T_u$。特别地，$T$ 本身可以认为是以 $1$ 为根节点的子树 $T_1$。
- **危险值**：对于 $T_u$ 而言，它的危险值被定义为：

$$\mathrm{LCAS}(u)=\sum_{i\in T_u}\sum_{j\in T_u}\sum_{k\in T_u,k<j} w_{\operatorname{lca}(i,j,k)}$$

现在给出 $T$，希望你对于 $i=1,2,\cdots n$，求出 $\mathrm{LCAS}(i)$。

## 说明/提示



#### 样例 1 解释

样例一当中的树如下。红色的是节点，蓝色的是点权。

![](https://cdn.luogu.com.cn/upload/image_hosting/f7gvtsp5.png)

容易发现 $\mathrm{LCAS}(2)=\mathrm{LCAS}(4)=\mathrm{LCAS}(5)=0$。这里说明如何计算 $\mathrm{LCAS}(1)$ 和 $\mathrm{LCAS}(3)$。首先说明 $\mathrm{LCAS}(3)$：

- 以 $3$ 为根，那么有 $\mathrm{lca}(3,3,4)=\mathrm{lca}(3,3,5)=\mathrm{lca}(3,4,5)=3$，这部分的贡献是 $3\times w_3=6$。  
- 以 $4$ 为根，那么有 $\mathrm{lca}(4,3,4)=\mathrm{lca}(4,4,5)=4,\mathrm{lca}(4,3,5)=3$，这部分的贡献是 $2\times w_4+1\times w_3=4$。  
- 以 $5$ 为根，那么有 $\mathrm{lca}(5,3,5)=\mathrm{lca}(5,4,5)=5,\mathrm{lca}(5,3,4)=3$，这部分的贡献是 $2\times w_5+1\times w_3=8$。

因此，$\mathrm{LCAS}(3)=6+4+8=18$。下面计算 $\mathrm{LCAS}(1)$。

$$
\def\arraystretch{1.2}
\begin{matrix}
\textbf{以 1 为根 }\bm{\mathbf{lca}(1,i,j)} & \textbf{以 2 为根 }\bm{\mathbf{lca}(2,i,j)}\cr
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 1 & - & - & - &- \cr\hline
3 & 1 & 1 & - & - &- \cr\hline
4 & 1 & 1 & 3 & - &- \cr\hline
5 & 1 & 1 & 3 & 3 &- \cr\hline
\end{array} &
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 2 & - & - & - &- \cr\hline
3 & 1 & 2 & - & - &- \cr\hline
4 & 1 & 2 & 3 & - &- \cr\hline
5 & 1 & 2 & 3 & 3 &- \cr\hline
\end{array} \cr[50pt]
\textbf{以 3 为根 }\bm{\mathbf{lca}(3,i,j)} & \textbf{以 4 为根 }\bm{\mathbf{lca}(4,i,j)}\cr
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 1 & - & - & - &- \cr\hline
3 & 3 & 3 & - & - &- \cr\hline
4 & 3 & 3 & 3 & - &- \cr\hline
5 & 3 & 3 & 3 & 3 &- \cr\hline
\end{array} &
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 1 & - & - & - &- \cr\hline
3 & 3 & 3 & - & - &- \cr\hline
4 & 4 & 4 & 4 & - &- \cr\hline
5 & 3 & 3 & 3 & 4 &- \cr\hline
\end{array}
\end{matrix}\\[10pt]
\textbf{以 5 为根 }\bm{\mathbf{lca}(5,i,j)}\\
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 1 & - & - & - &- \cr\hline
3 & 3 & 3 & - & - &- \cr\hline
4 & 3 & 3 & 3 & - &- \cr\hline
5 & 5 & 5 & 5 & 5 &- \cr\hline
\end{array}
$$

容易发现，在上图中，$1$ 出现了 $13$ 次，$2$ 出现了 $4$ 次，$3$ 出现了 $25$ 次，$4$ 出现了 $4$ 次，$5$ 出现了 $4$ 次。因此，$\mathrm{LCAS}(1)=3\times 13+1\times 4+2\times 25+1\times 4+3\times 4=109$。

#### 样例 2 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/uwm8c9bk.png)

我有一个精妙绝伦的方法解释样例 $2$，可惜这里空白太小写不下。

**本题输入量较大。请采用较快的读入方式。**

#### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{分值}\cr\hline
1 & 100 & - & 20 \cr\hline
2 & 10^3 & - & 25 \cr\hline
3 & 10^5 & \text{A} & 10\cr\hline
4 & 10^5 & \text{B} & 10\cr\hline
5 & 10^6 & - & 35\cr\hline
\end{array}
$$

**特殊性质** $\textbf{A}$：保证第 $i$ 条边为 $u=i$，$v=i+1$。  
**特殊性质** $\textbf{B}$：保证第 $i$ 条边为 $u=1$，$v=i+1$。

对于全部数据，保证 $1\le n\le 10^6$，$0\le w_i<998,244,353$。

## 样例 #1

### 输入

```
5
3 1 2 1 3
1 2
1 3
3 4
3 5
```

### 输出

```
109
0
18
0
0```

## 样例 #2

### 输入

```
10
1 1 4 5 1 4 1 9 1 9
1 2
1 3
1 4
2 5
2 6
5 7
3 8
3 9
9 10```

### 输出

```
972
33
99
0
2
0
0
0
10
0```

# AI分析结果


### 💡 Kay的C++算法解析：「船往低处流」深入学习指南 💡

**题目解读与核心算法识别**  
✨ **本题主要考察**：树形动态规划（Tree DP）  
🗣️ **初步分析**：  
> 解决本题关键在于理解树形DP的合并思想。想象你在拼装乐高模型：每棵子树是一个独立模块，通过特定规则（DP方程）将它们组合成完整模型。  
> - **核心思路**：定义状态数组`S0`（子树所有三元组的贡献和）、`S1`（以当前根为LCA的贡献）和`T`（子树点权和），通过递推合并子树信息  
> - **难点**：设计高效合并规则（避免O(n²)复杂度），推导状态转移方程  
> - **可视化设计**：用像素树展示子树合并过程，高亮状态转移时的数据流动（详见第5节）

---

### 2. 精选优质题解参考  
**题解（作者：囧仙）**  
* **点评**：  
  此解法完美展现树形DP精髓。思路清晰：  
  1. 创新定义`S0/S1/T`状态，物理意义明确  
  2. 推导出高效合并公式（O(1)合并子树）  
  3. 代码简洁规范（用邻接表存图，DFS一次求解）  
  4. 关键优化：发现`S1`与`S2`等价，减少状态数  
  实践价值极高，可直接用于竞赛（处理了10⁶数据）

---

### 3. 核心难点辨析与解题策略  
1. **状态定义与物理意义**  
   * **分析**：需准确定义状态含义。`S0[u]`表示子树内所有三元组的LCA权值和，`S1[u]`特指以`u`为LCA的贡献。这种分离使转移更清晰  
   * 💡 学习笔记：好的状态定义应具有明确的物理意义和可合并性  

2. **子树合并规则**  
   * **分析**：合并子树时需分类讨论三元组分布（两节点同子树/分属不同子树）。题解用`3*siz[v]*S1[u]`等项优雅处理跨子树贡献  
   * 💡 学习笔记：树形DP本质是分类讨论贡献来源  

3. **公式转换技巧**  
   * **分析**：通过`LCAS(u)=(S0[u]-siz[u]*T[u])/2`将无序三元组转化为有序，避免重复计数  
   * 💡 学习笔记：利用对称性简化问题是常见优化手段  

#### ✨ 解题技巧总结  
- **技巧1 状态设计**：为不同贡献来源设计独立状态  
- **技巧2 合并分类**：明确分治时贡献变化的数学表达  
- **技巧3 逆元运用**：模运算中使用2的逆元代替除法  

---

### 4. C++核心代码实现赏析  
**通用核心实现参考**  
* **说明**：综合题解思路的典型实现  
* **完整核心代码**：  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long i64;
const int MAXN=1e6+3, MOD=998244353, DIV2=499122177;

namespace Gra{
    int H[MAXN],V[MAXN*2],N[MAXN*2],t;
    int S0[MAXN],S1[MAXN],T[MAXN],siz[MAXN],ans[MAXN];
    
    void add(int u,int v){
        V[++t]=v,N[t]=H[u],H[u]=t;
        V[++t]=u,N[t]=H[v],H[v]=t;
    }
    
    void dfs(int u,int f){
        siz[u]=1;
        S0[u]=S1[u]=T[u]=W[u]; // 初始化
        
        for(int i=H[u],v;i;i=N[i]) if((v=V[i])!=f){
            dfs(v,u);
            // 临时保存合并前状态
            int tmp0=S0[u], tmp1=S1[u], su=siz[u], sv=siz[v];
            
            // 核心转移方程
            S0[u]= (tmp0 + 3ll*sv*tmp1 %MOD 
                   + S0[v] + 3ll*su*S1[v] %MOD) %MOD;
                   
            S1[u]= (tmp1 + S1[v] + 2ll*W[u]*su%MOD*sv %MOD) %MOD;
            
            siz[u]+=siz[v];
            T[u]=(T[u]+T[v])%MOD;
        }
        ans[u]=1ll*(S0[u]-1ll*siz[u]*T[u]%MOD+MOD)*DIV2%MOD;
    }
}
// 主函数（读入/输出等见题解完整版）
```

* **代码解读概要**：  
  > 代码分为三部分：  
  > 1. **初始化**：每个节点的`S0/S1/T`初始为自身权值  
  > 2. **DFS合并**：遍历子节点时，用临时变量保存状态避免覆盖  
  > 3. **状态转移**：按推导公式合并子树信息  
  > 4. **答案计算**：利用转换公式得到最终结果  

**题解片段赏析**  
* **亮点**：用临时变量(`tmp0,tmp1`)保存状态，确保转移原子性  
* **核心代码片段**：  
```cpp
int tmp0=S0[u], tmp1=S1[u], su=siz[u], sv=siz[v];
S0[u]= (tmp0 + 3ll*sv*tmp1 %MOD 
       + S0[v] + 3ll*su*S1[v] %MOD) %MOD;
```
* **代码解读**：  
  > 这里处理跨子树贡献：  
  > - `3ll*sv*tmp1`：v子树节点与u原有子树的组合贡献  
  > - `3ll*su*S1[v]`：u原有节点与v子树的组合贡献  
  > 使用`3ll`强制提升为long long避免溢出  
* 💡 学习笔记：树形DP合并时，当前子树状态需用临时变量保存  

---

### 5. 算法可视化：像素动画演示  
**像素探险家：子树合并大冒险**  
* **设计思路**：  
  采用FC游戏《塞尔达传说》像素风格，将树形DP转化为收集宝藏过程：  
  - 每个节点=宝藏点，点权=宝藏价值  
  - 子树合并=连接新地图  
  - S0/S1状态=背包中的宝藏组合  

* **动画流程**：  
  1. **地图初始化**：  
     - 树结构转为8-bit像素网格（棕色=节点，蓝色=水流边）  
     - 节点闪烁标识初始化状态（S0=S1=T=w_u）  

  2. **子树合并特效**：  
     ```plaintext
     当前节点u [■] 
        │
        ├── 子树v [★] → 合并动画：闪光链条连接两节点
        └── 状态更新：S0[u]+=3*size[v]*S1[u] (显示金色粒子特效)
     ```  
     - 伴随"叮！"音效（每次合并）  

  3. **实时状态面板**：  
     ```plaintext
     [u:5] S0=109 S1=18 
     [v:3] ▶▶ 合并中...  
     ```  

  4. **自动演示模式**：  
     - 按B键加速演示（类似贪吃蛇AI自动寻路）  
     - 过关条件：完成整棵树DFS（播放胜利音效）  

* **技术实现**：  
  - Canvas绘制树形结构，节点用`fillRect`渲染  
  - 状态更新时触发`new Audio('merge.wav').play()`  
  - 自动演示用`requestAnimationFrame`实现逐帧推进  

---

### 6. 拓展练习与相似问题思考  
**通用技巧迁移**：  
树形DP+LCA思想适用于：  
1. 树上路径统计（如：所有路径长度和）  
2. 子树对整体贡献问题（如：子树异或和）  
3. 换根DP相关问题  

**洛谷推荐**：  
1. **P1352 没有上司的舞会**  
   🗣️ 基础树形DP入门，巩固状态设计思想  
2. **P5658 括号树**  
   🗣️ 结合DFS栈维护状态，训练树形DP变形能力  
3. **P2607 骑士**  
   🗣️ 基环树上的DP扩展，提升问题转化能力  

---

### 7. 学习心得与经验分享  
> **参考经验**：  
> "推导转移方程时，先画图分析三元组分布情况（同子树/跨子树），再转化为数学表达式"  
>  
> **点评**：  
> 这是掌握树形DP的核心方法——通过图形化分析明确贡献来源，避免漏算重算。建议编码前先在纸上画树分析！

---

**结语**  
通过本题我们深入理解了树形DP的状态设计与合并技巧。记住：将大问题分解为子树小问题，再通过严谨的数学表达组合答案，是解决树形问题的通用法门。下次挑战见！🚀

---
处理用时：89.00秒
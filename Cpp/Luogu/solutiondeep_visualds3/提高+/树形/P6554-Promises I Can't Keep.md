# 题目信息

# Promises I Can't Keep

## 题目背景

>I had so much certainty  
Til that moment I lost control  
And I've tried but it never was up to me  
I've got no worse enemy  
Than the fear of what's still unknown  
And the time's come to realize there will be  
Promises I can't keep

## 题目描述

RFMC 给了你一个电路，一个电源，他希望你能把电源接在电路的某一个节点上，让电流流通，并答应给你电路显示屏上的数那么多钱。

这个电路有 $n$ 个节点，每个节点有一个权值 $val_i$，以 $n-1$ 条导线互相连通。你可以把电源接在任意一个起点上。接着，电流从这个节点开始流。若当前电源接到了一个节点 $u$，则接下来电流会**等概率**且**不重复经过一个点地**流向**一个叶子节点**，电流流过的所有节点的权值即为电路显示屏上的数（叶子节点即为 **除了 $u$** 的度数为 1 的节点）。

现在你有 $n$ 种接电源的选择，你希望接上电源以后期望得分越高越好，所以你现在就要在规定的时间内求出这 $n$ 种期望值中最大的的一个。

## 说明/提示

样例一的解释：

电源接在 5 号节点时有两种情况：$5\rightarrow 1\rightarrow 2\rightarrow 3$ 或 $5\rightarrow 1\rightarrow 2\rightarrow 4$，两种情况得分分别为 8 和 6，期望值即为 7，可以证明没有其他节点接通电源的期望值比 7 大。

---

**本题采用捆绑测试，每一档部分分对应一个 subtask。**

对于 $30\%$ 的数据，保证 $2<n\le 10^3$。  
对于另外 $20\%$ 的数据，保证是一条链。  
对于所有的数据，保证 $2<n\le 5\times10^5,\  |val_i|\le10^4$。

本题的 special judge 代码已经在附件中给出。

附：本题数据量较大，可以采用更快的读入方法。（标程在用 ```scanf``` 的情况下可以通过）

~~后记：按照题目名称，RFMC 是不会遵守诺言的（大雾~~

题目名其实是一首歌名啦。

## 样例 #1

### 输入

```
5
1 2
1 5
2 3
2 4
2 3 1 -1 2```

### 输出

```
7.0000```

# AI分析结果

# 💡 Kay的C++算法解析：《Promises I Can't Keep》深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：换根动态规划（Tree DP with Rerooting）


### 🗣️ 初步分析
解决这道题的核心是**换根DP**——一种用于处理树结构中「所有节点作为根时的最优解」的经典算法。可以把它比作「树的“旋转”游戏」：我们先固定一个根（比如1号节点），计算它的解，再通过**转移方程**快速算出相邻节点作为根的解，像多米诺骨牌一样推导出所有节点的结果。

#### 问题核心
题目要求选择一个节点作为根，使得**根到所有叶子节点的路径权值和的平均值**最大。平均值等于「路径和总和」除以「叶子节点数量」，因此我们需要计算每个节点作为根时的**路径和总和**（记为`f[u]`）和**叶子节点数量**（记为`cnt[u]`）。

#### 核心算法流程
1. **第一次DFS（自底向上）**：  
   固定一个根（如1号节点），计算每个节点`u`的：  
   - `cnt[u]`：`u`子树中的叶子节点数量（叶子节点定义为度数为1且非根的节点）；  
   - `f[u]`：`u`到子树中所有叶子节点的路径和（公式：`f[u] = val[u] * cnt[u] + sum(f[v])`，其中`v`是`u`的子节点）。  
   这一步相当于「扎根」，获取初始的子树信息。

2. **第二次DFS（换根）**：  
   从初始根出发，递归地将根从`u`转移到其子节点`v`，计算`v`作为根时的`f[v]`。转移的关键是**调整子树内外的贡献**：  
   - 当根从`u`换到`v`时，`v`的子树外有`total_cnt - cnt[v]`个叶子节点（`total_cnt`是整棵树的叶子节点总数）；  
   - `f[v]` = 原`f[u]`（`u`作为根时的路径和） - `val[u] * cnt[v]`（减去`u`对`v`子树的贡献） + `val[v] * (total_cnt - cnt[v])`（加上`v`对外部叶子的贡献）。  
   这一步相当于「旋转树」，快速推导所有节点的解。

#### 可视化设计思路
我们可以用**8位像素风格**的动画展示换根过程：  
- **场景**：一棵像素树，节点用彩色方块表示（根节点闪烁），叶子节点用星星标记；  
- **第一次DFS**：从根节点开始，递归遍历子节点，用「填充颜色」显示`cnt[u]`（数值越大，颜色越深），用「进度条」显示`f[u]`（长度代表路径和）；  
- **换根过程**：当根从`u`换到`v`时，用「箭头」指示转移方向，同时动态修改`v`的`f[v]`（比如减去`val[u]*cnt[v]`时，`v`的进度条缩短；加上`val[v]*(total_cnt - cnt[v])`时，进度条延长）；  
- **游戏化元素**：每次换根成功时播放「叮」的音效，计算期望时显示当前最大值（用闪烁的金币标记），增强互动感。


## 2. 精选优质题解参考

### 题解一（作者：UltiMadow，赞：6）
* **点评**：  
  这份题解是换根DP的「标准模板」，思路清晰、代码规范。第一次DFS计算`cnt`（子树叶子数）和`g`（子树路径和），第二次DFS通过转移方程计算每个节点的`f`（全局路径和）。代码中用`lef[u]`标记叶子节点，处理了叶子作为根时的特殊情况（期望分母为`total_cnt - 1`）。其亮点是**转移方程的简洁推导**，直接对应换根时的贡献调整，容易理解和复用。

### 题解二（作者：pomelo_nene，赞：4）
* **点评**：  
  此题解在标准换根DP的基础上，增加了**链的特判**（处理毒瘤数据），体现了对边界情况的考虑。代码中用`leaf[root]`记录总叶子数，`dp[v]`的计算与UltiMadow的题解一致，但通过`Check()`函数判断链结构，直接输出最优解，优化了链的时间复杂度（从O(n)到O(1)）。

### 题解三（作者：BzhH，赞：3）
* **点评**：  
  此题解强调了**题意理解的重要性**（作者最初误解为「流向儿子」导致WA），提醒学习者仔细读题。代码中用`sum[u]`表示子树路径和，`cnt[u]`表示子树叶子数，转移方程与标准形式一致，但通过`is[u]`标记叶子节点，处理了叶子作为根的情况，逻辑严谨。


## 3. 核心难点辨析与解题策略

### 1. 如何推导换根时的转移方程？
* **难点**：换根时，子树内外的叶子节点贡献变化容易混淆。  
* **策略**：  
  当根从`u`换到`v`时，`v`的子树内的叶子节点（`cnt[v]`个）不再经过`u`，因此路径和减少`val[u] * cnt[v]`；而`v`的子树外的叶子节点（`total_cnt - cnt[v]`个）现在需要经过`v`，因此路径和增加`val[v] * (total_cnt - cnt[v])`。转移方程为：  
  `f[v] = f[u] - val[u] * cnt[v] + val[v] * (total_cnt - cnt[v])`。  
* 💡 **学习笔记**：转移方程的本质是「调整子树内外的贡献」，记住这个规律就能快速推导。

### 2. 如何处理叶子节点作为根的情况？
* **难点**：叶子节点作为根时，自身不能算作叶子（因为电流从根出发，不能停在根），因此期望的分母需要减1。  
* **策略**：  
  用`lef[u]`标记叶子节点（度数为1且非根），当计算叶子节点`u`的期望时，分母为`total_cnt - 1`（减去自身），分子为`f[u] - val[u]`（减去根到自身的路径和）。  
* 💡 **学习笔记**：叶子节点的特殊处理是易错点，必须明确「根不能是叶子」的题意。

### 3. 如何选择初始根？
* **难点**：初始根不能是叶子节点（否则子树信息计算错误）。  
* **策略**：  
  选择度数≥2的节点作为初始根（因为树中至少有一个这样的节点，当n>2时）。例如，UltiMadow的代码中通过`Edge[Head[i]].next != 0`找到非叶子节点作为根。  
* 💡 **学习笔记**：初始根的选择直接影响第一次DFS的正确性，必须避开叶子。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合优质题解的思路，提供一个清晰的换根DP实现。  
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <cstdio>
  using namespace std;
  const int MAXN = 5e5 + 10;

  vector<int> G[MAXN];
  double val[MAXN];
  long long cnt[MAXN], f[MAXN], total_cnt;
  bool is_leaf[MAXN];

  void dfs1(int u, int fa) {
      cnt[u] = 0;
      f[u] = 0;
      for (int v : G[u]) {
          if (v == fa) continue;
          dfs1(v, u);
          cnt[u] += cnt[v];
          f[u] += f[v];
      }
      if (G[u].size() == 1 && u != fa) { // 叶子节点（非根）
          cnt[u] = 1;
          f[u] = val[u];
          is_leaf[u] = true;
          total_cnt++;
      } else {
          f[u] += val[u] * cnt[u];
      }
  }

  void dfs2(int u, int fa) {
      // 计算当前节点的期望
      double denominator = (is_leaf[u] ? total_cnt - 1 : total_cnt);
      double current = (is_leaf[u] ? (f[u] - val[u]) : f[u]) / denominator;
      static double ans = -1e18;
      if (current > ans) ans = current;

      for (int v : G[u]) {
          if (v == fa) continue;
          // 换根转移：u -> v
          long long old_f_u = f[u], old_cnt_u = cnt[u];
          long long old_f_v = f[v], old_cnt_v = cnt[v];

          f[u] -= f[v] + val[u] * cnt[v];
          cnt[u] -= cnt[v];
          if (G[u].size() == 1) { // u变成叶子
              cnt[u] = 1;
              f[u] = val[u];
          } else {
              f[u] += val[u] * cnt[u];
          }

          f[v] += f[u] + val[v] * cnt[u];
          cnt[v] += cnt[u];
          if (G[v].size() == 1) { // v不再是叶子
              cnt[v] -= 1;
              f[v] -= val[v];
          } else {
              f[v] += val[v] * cnt[v];
          }

          dfs2(v, u);

          // 回溯恢复
          f[u] = old_f_u;
          cnt[u] = old_cnt_u;
          f[v] = old_f_v;
          cnt[v] = old_cnt_v;
      }
  }

  int main() {
      int n;
      scanf("%d", &n);
      for (int i = 1; i < n; i++) {
          int u, v;
          scanf("%d%d", &u, &v);
          G[u].push_back(v);
          G[v].push_back(u);
      }
      for (int i = 1; i <= n; i++) {
          scanf("%lf", &val[i]);
      }

      // 选择初始根（非叶子）
      int root = 1;
      for (int i = 1; i <= n; i++) {
          if (G[i].size() >= 2) {
              root = i;
              break;
          }
      }

      dfs1(root, root);
      dfs2(root, root);

      // 输出答案（在dfs2中计算）
      printf("%.4lf\n", ans);
      return 0;
  }
  ```
* **代码解读概要**：  
  代码分为两步：`dfs1`计算初始根的子树信息（`cnt`和`f`），`dfs2`通过换根转移计算所有节点的期望。`is_leaf`标记叶子节点，处理特殊情况；`total_cnt`记录总叶子数，用于计算期望分母。


### 题解一（UltiMadow）核心片段赏析
* **亮点**：转移方程的简洁实现。  
* **核心代码片段**：
  ```cpp
  void dp2(int u, int fa) {
      for (int i = Head[u]; i; i = Edge[i].next) {
          int v = Edge[i].to;
          if (v == fa) continue;
          if (lef[v]) f[v] = f[u] - val[u] + val[v] * (cnt[rt] - 2);
          else f[v] = f[u] - val[u] * cnt[v] + val[v] * (cnt[rt] - cnt[v]);
          dp2(v, u);
      }
  }
  ```
* **代码解读**：  
  这段代码是换根的核心。`lef[v]`判断`v`是否是叶子节点：  
  - 如果是叶子，`f[v]` = `f[u]`（`u`的路径和） - `val[u]`（减去`u`对`v`的贡献） + `val[v]*(cnt[rt]-2)`（加上`v`对外部`cnt[rt]-2`个叶子的贡献，因为`v`作为根时，自身不算叶子，所以外部叶子数是`cnt[rt]-1`，但`v`的贡献是`val[v]*(cnt[rt]-1)`，而原`f[u]`中`v`的贡献是`val[u]*1`（因为`cnt[v]=1`），所以转移方程简化为`f[v] = f[u] - val[u] + val[v]*(cnt[rt]-2)`）；  
  - 如果不是叶子，`f[v]` = `f[u]` - `val[u]*cnt[v]`（减去`u`对`v`子树的贡献） + `val[v]*(cnt[rt]-cnt[v])`（加上`v`对外部叶子的贡献）。  
* 💡 **学习笔记**：叶子节点的转移方程是特殊情况，需要单独处理。


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：《树的旋转游戏》（8位像素风格）

### 核心演示内容
1. **场景初始化**：  
   - 屏幕显示一棵像素树（根节点为1号，用红色方块表示），叶子节点用黄色星星标记；  
   - 底部控制面板有「开始」「单步」「重置」按钮，以及速度滑块；  
   - 背景播放8位风格的轻快BGM（如《超级马里奥》的背景音乐）。

2. **第一次DFS（扎根）**：  
   - 从根节点开始，递归遍历子节点，用「蓝色填充」显示`cnt[u]`（数值越大，蓝色越深）；  
   - 用「绿色进度条」显示`f[u]`（长度代表路径和），进度条下方显示具体数值；  
   - 每计算完一个节点，播放「滴」的音效，增强反馈。

3. **换根过程（旋转树）**：  
   - 当根从`u`换到`v`时，用「橙色箭头」指示转移方向；  
   - 动态修改`v`的`f[v]`：减去`val[u]*cnt[v]`时，绿色进度条缩短（伴随「吱」的音效）；加上`val[v]*(total_cnt - cnt[v])`时，进度条延长（伴随「叮」的音效）；  
   - 叶子节点作为根时，黄色星星变成灰色（表示不算叶子），分母显示为`total_cnt - 1`。

4. **结果展示**：  
   - 计算每个节点的期望时，用「金色金币」标记当前最大值；  
   - 动画结束后，显示最终最大值（用闪烁的金币和「胜利」音效）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
换根DP适用于**树结构中所有节点作为根时的最优解问题**，例如：  
- 求树中每个节点的子树大小；  
- 求树中每个节点到所有节点的距离和；  
- 求树中每个节点的最长路径（直径）。

### 洛谷练习推荐
1. **洛谷 P3478** - 《[POI2008] STA-Station》  
   - 🗣️ **推荐理由**：这道题是换根DP的经典题，要求计算每个节点作为根时的子树大小和路径和，与本题思路完全一致，适合巩固基础。  
2. **洛谷 P2986** - 《[USACO10MAR] Great Cow Gathering G》  
   - 🗣️ **推荐理由**：此题要求计算将所有牛聚集到一个节点的最小代价，需要用换根DP计算每个节点的代价，是换根DP的变形应用。  
3. **洛谷 P4281** - 《[AHOI2008] 紧急集合》  
   - 🗣️ **推荐理由**：此题要求找到三个节点的最短集合点，需要用到树的LCA（最近公共祖先）和换根DP，适合拓展思维。


## 7. 学习心得与经验分享（若有）
- **题意理解**：作者BzhH提到「最初误解为流向儿子导致WA」，提醒我们**仔细读题**，尤其是「叶子节点」的定义（非根且度数为1）。  
- **边界处理**：叶子节点作为根时的特殊处理是易错点，需要用标记（如`is_leaf`）区分，并调整分母和分子。  
- **代码规范**：UltiMadow的代码中变量名（如`cnt`、`f`）含义明确，结构清晰，值得学习。


## 🎉 总结
本次分析的核心是**换根DP**，通过两次DFS快速计算所有节点作为根时的路径和，从而求出最大期望。关键是推导换根时的转移方程，处理叶子节点的特殊情况。通过像素动画演示，可以直观理解换根过程中的数值变化，增强学习兴趣。

记住：**换根DP的本质是「调整子树内外的贡献」**，掌握这个规律，就能解决大部分树结构中的最优解问题！💪

---
处理用时：152.67秒
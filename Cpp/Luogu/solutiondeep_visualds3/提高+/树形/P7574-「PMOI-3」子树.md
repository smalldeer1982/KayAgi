# 题目信息

# 「PMOI-3」子树

## 题目背景

分割线下有形式化题面，可以配合食用。

## 题目描述

b6e0 有一棵树，树上第 $i$ 个点有价值 $a_i$。每条边长度为 $1$。

b6e0 会选择一个节点作为根节点。设这个节点为 $r$。然后，b6e0 会圈定一个节点的整个子树作为他的领地，设这个子树的根节点为 $u$。此时，树上的每个节点会给 b6e0 带来一些收益。在领地子树的根节点为 $u$ 的情况下，节点 $x$ 带来的收益 $f(x,u)$ 定义如下：
1. 当 $x$ 在 $u$ 的子树中时，它的收益为它父亲节点的收益加上它本身的价值 $a_x$；
2. 当 $x$ 不在 $u$ 的子树中时，它的收益为：与它相邻的节点中，与 $u$ 距离（到 $u$ 的简单路径长度）比 $x$ 到 $u$ 的距离远的节点，这些节点的收益**对 $998244353$ 取模**的最大值，再乘上 $a_x$。

在根节点为 $r$ 的情况下，定义以 $u$ 为子树的收益 $W(u)$ 为所有节点的 $f$ 值和。

当然，b6e0 有许多种选择根节点的方案。定义选 $r$ 为根节点的收益 $C(r)$ 为对于所有 $u$，以 $u$ 为子树的收益（$W(u)$）的和。对于每一个节点 $r$，求 $C(r)$。

---
形式化题面：

给你一棵有 $n$ 个节点的树，第 $i$ 个节点有点权 $a_i$，每条边的长度为 $1$。当根节点为 $r$ 时：

设 $F(x)$ 表示 $x$ 的父亲节点，特殊地，$F(r)=0$；$D(x,y)$ 表示 $x$ 到 $y$ 的简单路径的长度，特殊地，对于所有 $x$，$D(x,x)=0$；$A_x$ 表示 $x$ 的子树中的节点（包括 $x$ 本身）组成的集合，即 $A_x=\{y\mid D(x,y)=D(F(x),y)-1\}$，特殊地，$A_r=\{1,2,\cdots,n\}$；$B_x$ 表示与 $x$ 相邻的节点组成的集合，即 $B_x=\{y\mid D(x,y)=1\}$。

定义 $f(x,u)$：
$$f(x,u)=\begin{cases}f(F(x),u)+a_x&x\in A_u\\a_x\cdot\max_{y\in B_x,D(y,u)>D(x,u)}\{f(y,u)\bmod 998244353\}&x\not\in A_u\end{cases}$$
特殊地，对于所有 $x$，$f(0,x)=0$；在 $x\not\in A_u$ 的情况中，若对于所有 $y\in B_x$，都有 $D(y,u)\le D(x,u)$，则 $f(x,u)=a_x$。

定义节点 $u$ 的分数 $W(u)=\sum_{v=1}^nf(v,u)$。

定义节点 $r$ 的收益 $C(r)$ 表示以 $r$ 为根时，$\sum_{i=1}^nW(i)$ 的值。

对于每一个节点 $r$，求 $C(r)$。

**所有 $C(r)$ 对 $998244353$ 取模。**

## 说明/提示

【样例解释】

样例中的树如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/bs02n466.png)

例如在 $r=1$，$u=5$ 时，$f(2,u)=a_2=2$，$f(1,u)=a_1\cdot f(2,u)=14$，$f(3,u)=a_3\cdot f(1,u)=70$，$f(6,u)=a_6=5$，$f(4,u)=a_4\cdot\max\{f(3,u),f(6,u)\}=7000$，$f(5,u)=f(4,u)+a_5=7001$。

【数据范围】
- Subtask1（10pts）：$n\le200$，$a_i\le 10^3$；
- Subtask2（20pts）：$n\le10^3$；
- Subtask3（20pts）：树为一条链；
- Subtask4（20pts）：存在一个节点，使得它的度数为 $n-1$；
- Subtask5（30pts）：无特殊限制。

对于 $100\%$ 的数据，$1\le n\le5\times10^5$，$1\le a_i\le10^9$。

## 样例 #1

### 输入

```
6
7 2 5 100 1 5
1 3
3 4
1 2
4 5
4 6```

### 输出

```
67562
29930
75168
76888
63243
63283```

# AI分析结果

# 💡 Kay的C++算法解析：「PMOI-3」子树 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：换根动态规划（Tree DP with Rerooting）、树的子树贡献计算  

🗣️ **初步分析**：  
解决“子树”问题的关键，在于**高效计算每个节点作为根时的全局收益**。想象一棵树像一盆盆栽，我们需要从每个“角度”（根节点）观察它的“生长状态”（收益）。如果逐个重新计算每个根的情况，时间会爆炸（O(n²)），而**换根DP**就像“转动盆栽”——通过父节点的信息快速推导子节点的信息，避免重复计算。  

### 核心思路与难点  
题目要求计算每个根节点`r`的`C(r)`（所有`u`的`W(u)`之和），而`W(u)`是所有节点`v`的`f(v,u)`之和。`f(v,u)`分两种情况：  
- **子树内（`v∈A_u`）**：`f(v,u)`是`v`到`u`的路径点权和（加上父节点贡献），可以用子树和`SS_u`（子树内所有节点的路径和之和）快速计算。  
- **子树外（`v∉A_u`）**：`f(v,u)`是相邻节点中“离`u`更远”的节点的`f`值最大值乘以`a_v`，需要用`SP_u`（子树外贡献的最大值乘积）和前缀/后缀最大值优化。  

**核心难点**：  
1. 如何将`f`函数的分段定义转化为可计算的子树和？  
2. 如何高效处理子树外的贡献（避免重复遍历）？  
3. 如何通过换根DP将每个根的计算复杂度降到O(1)？  

### 可视化设计思路  
我们可以用**8位像素风格**展示树结构（节点是彩色方块，边是线条），重点动画：  
- **DFS计算子树信息**：节点闪烁表示正在访问，子树大小`siz`用方块大小表示，`SS`用颜色深浅表示（越深越大）。  
- **换根转移**：父节点`f`的信息（如`nf`、`ns`）以“数据流”形式传递给子节点，子节点颜色变化表示根的切换。  
- **前缀/后缀最大值**：用箭头指向子节点中`SP`最大的节点，箭头颜色随最大值变化（如红色表示当前最大）。  
- **音效**：DFS进入子节点时播放“滴”声，换根成功时播放“叮”声，最大值更新时播放“咻”声，增强记忆点。  


## 2. 精选优质题解参考

<eval_intro>  
官方题解是本题的“标准答案”，思路清晰、代码高效，非常适合学习换根DP的实战技巧。  
</eval_intro>

**题解一：官方题解（作者：b6e0_）**  
* **点评**：  
  这份题解的**思路逻辑性极强**——先将`f`函数的子树内贡献转化为路径和（`SS_u`），再用`SP_u`处理子树外的最大值问题，最后通过换根DP将每个根的计算复杂度降到O(n)。  
  代码的**变量命名非常规范**（如`siz`表示子树大小、`ss`表示子树路径和之和、`sp`表示子树外贡献最大值），一看就懂。**算法优化亮点**在于用前缀/后缀最大值处理子节点的`SP`，避免了重复计算（O(n)处理每个节点的子节点）。  
  从**实践价值**看，代码处理了大数取模（`a[i]%mod`）、快读快写（应对大输入）等细节，直接可以用于竞赛。特别是换根时的状态转移公式（`ans[x] = ans[f] - ...`），完美体现了“利用父节点信息更新子节点”的换根思想。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决本题的关键，在于突破以下3个“思维关卡”：  
</difficulty_intro>

### 1. 如何将子树内的`f`值转化为路径和？  
**分析**：  
子树内的`f(v,u)`定义为“父节点的`f`值加`a_v`”，递归展开后就是`v`到`u`的路径点权和（`S(v,u)`）加上`f(F(u),u)`（`u`父节点的贡献）。因此，子树内所有节点的`f`值之和为`SS_u + siz_u * f(F(u),u)`，其中`SS_u`是子树`u`内所有节点的`S(v,u)`之和（可以用DFS递推：`SS_u = siz_u*a_u + ΣSS_v`，`v`是`u`的子节点）。  
💡 **学习笔记**：递归定义的函数，往往可以通过“展开”转化为路径或子树的累积和，这是Tree DP的常用技巧。  

### 2. 如何高效计算子树外的`f`值？  
**分析**：  
子树外的`f(v,u)`依赖于相邻节点中“离`u`更远”的节点的`f`值最大值。对于节点`u`，其子树外的贡献可以用`SP_u`（`a_u`乘以子节点`SP`的最大值）表示。为了快速计算每个子节点的`SP`（避免重复遍历），我们用**前缀/后缀最大值**：遍历`u`的子节点，计算前缀最大`SP`（从左到右）和后缀最大`SP`（从右到左），这样每个子节点的`SP`最大值就是“父节点的`SP`”与“前缀+后缀最大值”的最大值。  
💡 **学习笔记**：前缀/后缀最大值是处理“子节点最大值”问题的神器，能将O(n²)优化到O(n)。  

### 3. 如何通过换根DP计算所有根的答案？  
**分析**：  
换根DP的核心是“状态转移”——当根从`f`（父节点）转移到`x`（子节点）时，`ans[x]`可以通过`ans[f]`调整得到。例如，`ans[f]`包含`u=f`的`W(f)`，而`ans[x]`需要减去`u=f`的贡献，加上`u=x`的贡献（用`as[x]`等预处理值）。题解中的`dp2`函数就是这个过程的实现：`ans[x] = ans[f] - as[f] - uans[x] + as[x] + ...`，其中`as[x]`是所有节点到`x`的路径和之和（用换根DP预处理）。  
💡 **学习笔记**：换根DP的关键是找到“父节点与子节点答案的差异”，并通过预处理的辅助数组（如`as`、`ssp`）快速调整。  

### ✨ 解题技巧总结  
- **问题拆解**：将复杂的`f`函数拆分为子树内和子树外两部分，分别处理。  
- **前缀/后缀优化**：处理子节点最大值问题时，用前缀/后缀最大值避免重复计算。  
- **换根DP**：通过父节点信息快速计算子节点答案，降低时间复杂度。  
- **细节处理**：大数取模（`a[i]%mod`）、快读快写（应对大输入）、变量命名规范（提高代码可读性）。  


## 4. C++核心代码实现赏析

<code_intro_overall>  
以下是官方题解的核心代码提炼，涵盖了`DFS`计算子树信息、`dp1`计算初始根答案、`dp2`换根转移的完整逻辑。  
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：此代码来自官方题解，是换根DP处理树问题的典型实现。  
* **完整核心代码**：  
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  const int mod=998244353;
  vector<int>g[500010];
  int n,siz[500010];
  long long a[500010],ss[500010],as[500010],sp[500010],ssp[500010],uans[500010],ans[500010];
  
  inline int read(){/*快读实现*/}
  inline void write(int x){/*快写实现*/}
  
  void dfs(int x,int f){//计算siz, ss, sp, ssp
    siz[x]=1;
    sp[x]=-1;
    for(int v:g[x]){
      if(v==f) continue;
      dfs(v,x);
      siz[x]+=siz[v];
      ss[x]=(ss[x]+ss[v])%mod;
      sp[x]=max(sp[x],sp[v]);
    }
    ss[x]=(ss[x]+1LL*siz[x]*a[x]%mod)%mod;
    if(sp[x]==-1) sp[x]=a[x];
    else sp[x]=sp[x]*a[x]%mod;
    ssp[x]=sp[x];
    for(int v:g[x]){
      if(v==f) continue;
      ssp[x]=(ssp[x]+ssp[v])%mod;
    }
  }
  
  void dp1(int x,int f,long long nf,long long ns){//计算uans, ans[1], as
    uans[x]=(ss[x]+1LL*nf*siz[x]%mod+ns)%mod;
    ans[1]=(ans[1]+uans[x])%mod;
    if(x!=1) as[x]=(as[f]-1LL*a[f]*siz[x]+1LL*a[x]*(n-siz[x])%mod)%mod;
    vector<long long>pm(1,0), lm(1,0);
    int pt=0, lt=g[x].size()-(x==1?1:2);
    for(int v:g[x]){
      if(v==f) continue;
      pm.push_back(max(pm.back(), sp[v]));
    }
    for(int i=g[x].size()-1;i>=0;i--){
      int v=g[x][i];
      if(v==f) continue;
      lm.push_back(max(lm.back(), sp[v]));
    }
    for(int v:g[x]){
      if(v==f) continue;
      long long new_nf=max(max(nf,1LL), max(pm[pt], lm[lt]))*a[x]%mod;
      long long new_ns=(ns + ssp[x] - ssp[v] - sp[x] + new_nf)%mod;
      dp1(v,x,new_nf,new_ns);
      pt++; lt--;
    }
  }
  
  void dp2(int x,int f){//换根计算ans[x]
    ans[x]=(ans[f] - as[f] - uans[x] + as[x] + ssp[x] + 1LL*sp[x]*(n-siz[x])%mod + as[f] - ss[x] - 1LL*a[f]*siz[x]%mod)%mod;
    ans[x]=(ans[x]+mod)%mod;
    for(int v:g[x]){
      if(v==f) continue;
      dp2(v,x);
    }
  }
  
  int main(){
    n=read();
    for(int i=1;i<=n;i++) a[i]=read()%mod;
    for(int i=1;i<n;i++){
      int x=read(),y=read();
      g[x].push_back(y);
      g[y].push_back(x);
    }
    dfs(1,0);
    as[1]=ss[1];
    dp1(1,0,0,0);
    for(int v:g[1]) dp2(v,1);
    for(int i=1;i<=n;i++) write(ans[i]);
    return 0;
  }
  ```  
* **代码解读概要**：  
  1. **DFS**：计算每个节点的子树大小`siz`、子树路径和之和`ss`、子树外贡献最大值`sp`、子树内`sp`和`ssp`。  
  2. **dp1**：以1为根，计算每个节点`u`的`W(u)`（`uans[u]`）和初始根`1`的`ans[1]`，同时预处理所有节点到`x`的路径和之和`as[x]`。  
  3. **dp2**：通过换根DP，将根从`f`转移到`x`，计算所有根的`ans[x]`。  


### 针对优质题解的片段赏析  
**题解一：官方题解**  
* **亮点**：前缀/后缀最大值处理子节点`SP`，避免重复计算。  
* **核心代码片段**（`dp1`中的前缀/后缀最大值）：  
  ```cpp
  vector<long long>pm(1,0), lm(1,0);
  int pt=0, lt=g[x].size()-(x==1?1:2);
  for(int v:g[x]){
    if(v==f) continue;
    pm.push_back(max(pm.back(), sp[v]));
  }
  for(int i=g[x].size()-1;i>=0;i--){
    int v=g[x][i];
    if(v==f) continue;
    lm.push_back(max(lm.back(), sp[v]));
  }
  ```  
* **代码解读**：  
  - `pm`（前缀最大值）：从左到右遍历`x`的子节点，记录到当前位置的最大`sp[v]`。  
  - `lm`（后缀最大值）：从右到左遍历`x`的子节点，记录到当前位置的最大`sp[v]`。  
  - 对于每个子节点`v`，其`sp`的最大值等于“父节点的`nf`”与“`pm[pt]`（`v`左边的最大`sp`）+`lm[lt]`（`v`右边的最大`sp`）”的最大值。这样避免了对每个子节点重新遍历所有兄弟节点（O(n)→O(1)）。  
* 💡 **学习笔记**：前缀/后缀最大值是处理“子节点最大值”问题的高效技巧，一定要掌握！  


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>  
为了更直观地理解**换根DP**的执行过程，我设计了一个**8位像素风格**的动画，结合复古游戏元素，让你“看”到算法的每一步！  
\</visualization\_intro\>

### 动画演示主题  
**《像素树的换根冒险》**：玩家操控一棵像素树，通过“转动”根节点，观察子树信息的变化，最终计算所有根的收益。  

### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧显示**像素树**（节点是彩色方块，边是白色线条，根节点1是红色）。  
   - 屏幕右侧显示**控制面板**（开始/暂停、单步、重置按钮；速度滑块；当前根节点、`ans`值显示）。  
   - 背景播放**8位风格BGM**（轻快的钢琴旋律）。  

2. **DFS计算子树信息**：  
   - 节点闪烁表示正在访问（如节点1闪烁→访问子节点3→节点3闪烁→访问子节点4，依此类推）。  
   - 子树大小`siz`用方块大小表示（越大的节点`siz`越大）。  
   - 子树路径和之和`ss`用颜色深浅表示（越深的节点`ss`越大）。  
   - 每完成一个节点的DFS，播放“滴”声。  

3. **dp1计算初始根答案**：  
   - 根节点1的`ans[1]`逐渐累积（右侧显示数值增长）。  
   - 前缀/后缀最大值用**箭头**指向子节点（如节点1的子节点3的`sp`最大，箭头指向3，颜色为红色）。  
   - 每计算一个`uans[u]`，播放“叮”声。  

4. **换根DP（dp2）**：  
   - 根节点从1转移到3（节点3变成红色，节点1变回蓝色）。  
   - `ans[3]`通过`ans[1]`调整得到（右侧显示数值变化，如`ans[3] = ans[1] - ...`）。  
   - 每完成一次换根，播放“咻”声，屏幕底部显示“换根成功！当前根：3”。  

5. **目标达成**：  
   - 所有根的`ans`计算完成后，屏幕显示“任务完成！”，播放**胜利音效**（上扬的8位音调），所有节点闪烁庆祝。  

### 设计思路  
- **像素风格**：营造复古游戏氛围，降低学习压力。  
- **动画效果**：通过节点大小、颜色、箭头等视觉元素，清晰展示子树信息的变化。  
- **音效**：用不同声音提示关键操作（DFS、计算、换根），增强记忆点。  
- **交互性**：支持单步执行、自动播放（调速），让学习者可以自主控制学习节奏。  


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>  
换根DP是处理树问题的“瑞士军刀”，掌握它可以解决很多类似的问题。以下是几道洛谷上的经典练习：  
\</similar\_problems\_intro\>

### 通用思路/技巧迁移  
换根DP常用于**需要计算每个节点作为根时的全局属性**的问题，比如：  
- 树的重心（每个节点作为根时的最大子树大小）；  
- 最小总距离（所有节点到某个节点的距离之和）；  
- 子树贡献（如本题的`C(r)`）。  

### 练习推荐 (洛谷)  
1. **洛谷 P3478** - 《树的重心》  
   🗣️ **推荐理由**：这道题需要找到树的重心（所有节点中，最大子树大小最小的节点），用到换根DP来计算每个节点作为根时的最大子树大小。能帮助你巩固换根时的状态转移技巧。  

2. **洛谷 P2986** - 《[USACO10MAR]Great Cow Gathering G》  
   🗣️ **推荐理由**：这道题要求将所有奶牛聚集到一个节点，最小化总距离。换根DP可以高效计算每个节点的总距离，是换根技巧的经典应用。  

3. **洛谷 P5022** - 《旅行》  
   🗣️ **推荐理由**：这道题是换根DP的变形，需要处理路径问题（找到一条路径，使得路径上的节点权值和最大）。能锻炼你对树结构的灵活运用。  


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>  
官方题解中的**细节处理**非常值得学习：  
\</insights\_intro\>

> **参考经验 (来自官方题解)**：“`a[i]`进来要先取模！否则在比较大小时会出问题。”  
> **点评**：这是一个容易忽略的细节！`a[i]`的范围是1e9，直接计算会导致溢出，取模后才能保证`sp`等变量的正确性。在编程中，**大数取模**是处理大规模数据的必备技巧，一定要养成习惯。  


## 结语  
本次关于“PMOI-3 子树”的分析，我们学习了换根DP的核心思想、前缀/后缀最大值的优化技巧，以及树问题的拆解方法。记住，**换根DP的本质是“利用父节点信息快速更新子节点”**，只要掌握了这个规律，很多树问题都能迎刃而解。  

编程能力的提升在于**持续练习**——多做类似的换根DP题目，多思考“如何拆解问题”“如何优化复杂度”，你一定会越来越厉害！💪  

下次我们再一起探索新的编程挑战！

---
处理用时：171.80秒
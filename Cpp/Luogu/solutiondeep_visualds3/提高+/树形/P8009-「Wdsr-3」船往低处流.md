# 题目信息

# 「Wdsr-3」船往低处流

## 题目背景

村纱水密是控制着圣辇船的船长。因为是一生和船相伴的船幽灵，因此对船只非常感兴趣。正因为这样的爱好，村纱有一大堆船模。

由于间歇泉的喷发，间歇泉的周围出现了一个汇聚了多方水流的大水坑。不同的水流交错，形成了大大小小的水道。只需要把船模放在某个位置，它就会顺着水流流动。根据物理原理，船自然会从高处流向低处。由于水坑由四处的水汇集而成，因此水坑的中央地势最低；随着到中央距离的增加，地势不断增加。

村纱发现，当她选定了两个位置放下船模后，它们会在某个水流的交汇处发生碰撞。村纱关心碰撞发生的位置。容易发现，第一个可能会产生碰撞的位置，就是在树形结构上这两个选定的点的最近公共祖先。

当然了，由于间歇泉并不稳定，因此水池中央的位置可能会不断变化，地势也不断变化，但是水道并不会发生任何改变。村纱给每个交汇处标上了一个数值「危险程度」，表示两个船模在此处碰撞可能会发生的危险的大小。村纱放置船模的位置也是随机的。

不过由于水坑实在是太大，水坑中央又不断变化，因此只关心船模的村纱被绕晕了。她迫切地想知道在水坑处玩船模产生的威胁，因此希望你帮她计算。

## 题目描述

这些水道形成了一棵以 $1$ 为根的节点数为 $n$ 的树形结构 $T$。每个节点上有一个点权 $w_i$，表示它的危险程度。现做出如下定义：

- **最近公共祖先**：在一棵以 $r$ 为根的有根树上，两个节点 $u,v$ 的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个，记作 $\operatorname{lca}(r,u,v)$。
- **子树**：树 $T$ 上，删掉节点 $u$ 与父亲相连的边后，该结点所在的子图记为子树 $T_u$。特别地，$T$ 本身可以认为是以 $1$ 为根节点的子树 $T_1$。
- **危险值**：对于 $T_u$ 而言，它的危险值被定义为：

$$\mathrm{LCAS}(u)=\sum_{i\in T_u}\sum_{j\in T_u}\sum_{k\in T_u,k<j} w_{\operatorname{lca}(i,j,k)}$$

现在给出 $T$，希望你对于 $i=1,2,\cdots n$，求出 $\mathrm{LCAS}(i)$。

## 说明/提示



#### 样例 1 解释

样例一当中的树如下。红色的是节点，蓝色的是点权。

![](https://cdn.luogu.com.cn/upload/image_hosting/f7gvtsp5.png)

容易发现 $\mathrm{LCAS}(2)=\mathrm{LCAS}(4)=\mathrm{LCAS}(5)=0$。这里说明如何计算 $\mathrm{LCAS}(1)$ 和 $\mathrm{LCAS}(3)$。首先说明 $\mathrm{LCAS}(3)$：

- 以 $3$ 为根，那么有 $\mathrm{lca}(3,3,4)=\mathrm{lca}(3,3,5)=\mathrm{lca}(3,4,5)=3$，这部分的贡献是 $3\times w_3=6$。  
- 以 $4$ 为根，那么有 $\mathrm{lca}(4,3,4)=\mathrm{lca}(4,4,5)=4,\mathrm{lca}(4,3,5)=3$，这部分的贡献是 $2\times w_4+1\times w_3=4$。  
- 以 $5$ 为根，那么有 $\mathrm{lca}(5,3,5)=\mathrm{lca}(5,4,5)=5,\mathrm{lca}(5,3,4)=3$，这部分的贡献是 $2\times w_5+1\times w_3=8$。

因此，$\mathrm{LCAS}(3)=6+4+8=18$。下面计算 $\mathrm{LCAS}(1)$。

$$
\def\arraystretch{1.2}
\begin{matrix}
\textbf{以 1 为根 }\bm{\mathbf{lca}(1,i,j)} & \textbf{以 2 为根 }\bm{\mathbf{lca}(2,i,j)}\cr
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 1 & - & - & - &- \cr\hline
3 & 1 & 1 & - & - &- \cr\hline
4 & 1 & 1 & 3 & - &- \cr\hline
5 & 1 & 1 & 3 & 3 &- \cr\hline
\end{array} &
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 2 & - & - & - &- \cr\hline
3 & 1 & 2 & - & - &- \cr\hline
4 & 1 & 2 & 3 & - &- \cr\hline
5 & 1 & 2 & 3 & 3 &- \cr\hline
\end{array} \cr[50pt]
\textbf{以 3 为根 }\bm{\mathbf{lca}(3,i,j)} & \textbf{以 4 为根 }\bm{\mathbf{lca}(4,i,j)}\cr
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 1 & - & - & - &- \cr\hline
3 & 3 & 3 & - & - &- \cr\hline
4 & 3 & 3 & 3 & - &- \cr\hline
5 & 3 & 3 & 3 & 3 &- \cr\hline
\end{array} &
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 1 & - & - & - &- \cr\hline
3 & 3 & 3 & - & - &- \cr\hline
4 & 4 & 4 & 4 & - &- \cr\hline
5 & 3 & 3 & 3 & 4 &- \cr\hline
\end{array}
\end{matrix}\\[10pt]
\textbf{以 5 为根 }\bm{\mathbf{lca}(5,i,j)}\\
\begin{array}{c||c|c|c|c|c}\hline
& 1 & 2 & 3 & 4 & 5 \cr\hline\hline
1 & - & - & - & - &- \cr\hline
2 & 1 & - & - & - &- \cr\hline
3 & 3 & 3 & - & - &- \cr\hline
4 & 3 & 3 & 3 & - &- \cr\hline
5 & 5 & 5 & 5 & 5 &- \cr\hline
\end{array}
$$

容易发现，在上图中，$1$ 出现了 $13$ 次，$2$ 出现了 $4$ 次，$3$ 出现了 $25$ 次，$4$ 出现了 $4$ 次，$5$ 出现了 $4$ 次。因此，$\mathrm{LCAS}(1)=3\times 13+1\times 4+2\times 25+1\times 4+3\times 4=109$。

#### 样例 2 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/uwm8c9bk.png)

我有一个精妙绝伦的方法解释样例 $2$，可惜这里空白太小写不下。

**本题输入量较大。请采用较快的读入方式。**

#### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{分值}\cr\hline
1 & 100 & - & 20 \cr\hline
2 & 10^3 & - & 25 \cr\hline
3 & 10^5 & \text{A} & 10\cr\hline
4 & 10^5 & \text{B} & 10\cr\hline
5 & 10^6 & - & 35\cr\hline
\end{array}
$$

**特殊性质** $\textbf{A}$：保证第 $i$ 条边为 $u=i$，$v=i+1$。  
**特殊性质** $\textbf{B}$：保证第 $i$ 条边为 $u=1$，$v=i+1$。

对于全部数据，保证 $1\le n\le 10^6$，$0\le w_i<998,244,353$。

## 样例 #1

### 输入

```
5
3 1 2 1 3
1 2
1 3
3 4
3 5
```

### 输出

```
109
0
18
0
0```

## 样例 #2

### 输入

```
10
1 1 4 5 1 4 1 9 1 9
1 2
1 3
1 4
2 5
2 6
5 7
3 8
3 9
9 10```

### 输出

```
972
33
99
0
2
0
0
0
10
0```

# AI分析结果

# 💡 Kay的C++算法解析：「Wdsr-3」船往低处流 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：树形动态规划（Tree DP）+ 子树合并技巧  

🗣️ **初步分析**：  
解决“船往低处流”问题的核心是**高效计算每个子树内所有三元组的LCA贡献**。直接枚举所有三元组（时间复杂度O(n³)）显然无法通过大数据量，因此需要**树形动态规划**——将大问题分解为子树问题，通过合并子树结果得到父节点结果。  

简单来说，树形DP就像“搭积木”：每个子树是一个小积木，我们计算每个小积木的“状态”（比如子树内的三元组贡献），然后将这些小积木拼起来，计算更大的积木（父节点）的状态。在本题中，我们需要计算每个子树的**LCAS值**（三元组LCA的危险值之和），而树形DP能帮助我们以O(n)的时间复杂度完成这个任务。  

### 核心思路与难点  
题解的关键是**将原问题转换为更容易计算的中间状态**：  
- 定义`LCAS0(u)`为子树`u`内所有三元组（包括`k≥j`）的LCA危险值之和；  
- 定义`LCAS1(u)`为子树`u`内所有二元组`(j,k)`的LCA（以`u`为根时）的危险值之和；  
- 通过`LCAS0(u)`和子树大小、子树危险值和，转换得到原问题的`LCAS(u)`（公式：`LCAS(u) = (LCAS0(u) - siz(u)*sum(w_v)) / 2`）。  

**核心难点**：  
1. **状态定义**：如何选择中间状态（如`LCAS0`、`LCAS1`），使得子树合并时能正确计算所有三元组的贡献；  
2. **合并贡献计算**：当合并两个子树时，需要枚举所有可能的三元组分布（如`i,j,k`都在左子树、都在右子树、跨子树等），确保贡献不重复、不遗漏；  
3. **公式转换**：如何从`LCAS0`（包含`k≥j`）转换为原问题的`LCAS`（仅`k<j`）。  

### 可视化设计思路  
为了直观展示树形DP的**子树合并过程**，我设计了一个**8位像素风格的动画**：  
- **场景**：用像素方块表示树节点，节点颜色深浅代表`LCAS1`值（越深表示贡献越大）；  
- **核心步骤**：  
  1. 初始化树结构（根节点1高亮）；  
  2. 递归遍历子树（子节点逐步展开，颜色变为浅灰色）；  
  3. 合并子树（当处理父节点时，子节点的像素方块向父节点移动，父节点颜色逐渐加深，同时显示`LCAS0`、`LCAS1`的值变化）；  
- **交互设计**：支持“单步执行”（逐步查看合并过程）、“自动播放”（快速演示整个流程），并添加“合并成功”的音效（如“叮”的一声），增强趣味性。  


## 2. 精选优质题解参考

**题解一：Subtask5 正解（来源：囧仙）**  
* **点评**：  
  这份题解是本题的**最优解法**，思路清晰、效率极高（时间复杂度O(n)），非常适合学习树形DP的子树合并技巧。  
  - **思路清晰性**：通过定义`LCAS0`、`LCAS1`等中间状态，将原问题转换为更容易计算的子问题，避免了直接处理`k<j`的复杂条件；  
  - **算法有效性**：合并子树时，枚举了所有可能的三元组分布（如左子树、右子树、跨子树），并通过数学公式快速计算贡献，确保结果正确；  
  - **代码可读性**：变量命名规范（如`S0`表示`LCAS0`、`S1`表示`LCAS1`、`S`表示子树大小），代码结构简洁（仅用一次DFS遍历树）；  
  - **实践价值**：代码处理了大数取模（`MOD=998244353`）和除法（`DIV2=499122177`，即2的逆元），符合竞赛要求，可直接用于大数据量测试。  


## 3. 核心难点辨析与解题策略

### 1. 关键点1：如何定义中间状态？  
**分析**：原问题要求计算`k<j`的三元组贡献，直接计算非常麻烦。题解通过定义`LCAS0`（包含`k≥j`），将问题转换为计算所有三元组的贡献，再通过公式转换得到原问题的结果。这种“补集转换”技巧是解决组合问题的常用方法。  
💡 **学习笔记**：遇到有条件（如`k<j`）的组合问题时，可以先计算无条件的结果，再通过数学公式调整。  

### 2. 关键点2：如何合并子树的贡献？  
**分析**：当合并父节点`u`的两个子树`v`（左）和`w`（右）时，需要考虑所有三元组的分布：  
- 三个元素都在左子树：贡献为`LCAS0(v)`；  
- 三个元素都在右子树：贡献为`LCAS0(w)`；  
- 两个在左、一个在右：贡献为`3*siz(w)*LCAS1(v)`（`3`是因为`i,j,k`中有一个在右子树，有三种排列）；  
- 两个在右、一个在左：贡献为`3*siz(v)*LCAS1(w)`；  
- 跨子树的其他情况：通过`LCAS1`的合并公式计算（如`2*w_u*siz(v)*siz(w)`，表示`j`在左、`k`在右时，LCA为`u`的贡献）。  
💡 **学习笔记**：合并子树时，要全面枚举所有可能的元素分布，避免遗漏。  

### 3. 关键点3：如何处理模运算中的除法？  
**分析**：原问题中的公式需要除以2，而模运算中的除法需要用**逆元**（即乘以2在模`MOD`下的逆元`DIV2=499122177`）。题解中通过`(LCAS0(u) - siz(u)*T[u]%MOD + MOD)%MOD * DIV2%MOD`计算`LCAS(u)`，确保了结果的正确性。  
💡 **学习笔记**：模运算中，除法要转换为乘以逆元，逆元可以通过费马小定理计算（当`MOD`是质数时，`a^(MOD-2)`是`a`的逆元）。  

### ✨ 解题技巧总结  
- **问题转换**：将复杂的组合问题转换为更容易计算的中间状态；  
- **树形DP**：通过递归合并子树，高效计算树的全局属性；  
- **模运算技巧**：处理大数时，使用逆元解决除法问题；  
- **状态定义**：选择能覆盖所有子问题的状态，确保合并时能正确计算贡献。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（来自Subtask5正解）  
* **说明**：此代码是本题的最优实现，采用树形DP合并子树，时间复杂度O(n)，适合n=1e6的大数据量。  
* **完整核心代码**：  
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  typedef long long i64;
  const int MAXN=1e6+3, MOD=998244353, DIV2=499122177;
  int n, W[MAXN], A[MAXN], T[MAXN];

  namespace Gra{
      int H[MAXN], V[MAXN*2], N[MAXN*2], S[MAXN], t;
      void add(int u, int v){V[++t]=v, N[t]=H[u], H[u]=t;}
      void dfs(int u, int f){
          S0[u] = S1[u] = T[u] = W[u]; // 初始化：LCAS0=LCAS1=w_u，T是子树w和
          S[u] = 1; // 子树大小初始化为1
          for(int i=H[u]; i; i=N[i]){
              int v=V[i];
              if(v==f) continue;
              dfs(v, u);
              // 合并子树v到u
              int new_S0 = (1ll*S0[u] + 3ll*S[v]*S1[u]%MOD + 1ll*S0[v] + 3ll*S[u]*S1[v]%MOD) % MOD;
              int new_S1 = (1ll*S1[u] + S1[v] + 2ll*W[u]*S[u]%MOD*S[v]%MOD) % MOD;
              S0[u] = new_S0;
              S1[u] = new_S1;
              S[u] += S[v];
              T[u] = (1ll*T[u] + T[v]) % MOD;
          }
          // 转换为原问题的LCAS(u)
          A[u] = 1ll*(1ll*S0[u] - 1ll*S[u]*T[u]%MOD + MOD) * DIV2 % MOD;
      }
  }

  int qread(){
      int w=1, ret=0, c;
      while((c=getchar())>'9'||c<'0') w=(c=='-'?-1:1);
      ret=c-'0';
      while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
      return ret*w;
  }

  int main(){
      n=qread();
      for(int i=1; i<=n; i++) W[i]=qread();
      for(int i=1; i<n; i++){
          int u=qread(), v=qread();
          Gra::add(u, v);
          Gra::add(v, u);
      }
      Gra::dfs(1, 0);
      for(int i=1; i<=n; i++) printf("%d\n", A[i]);
      return 0;
  }
  ```  
* **代码解读概要**：  
  代码的核心是`Gra::dfs`函数，它递归遍历树，合并子树结果：  
  1. **初始化**：每个节点的`S0`（`LCAS0`）、`S1`（`LCAS1`）初始化为自身的`w_u`，`S`（子树大小）初始化为1，`T`（子树`w`和）初始化为`w_u`；  
  2. **合并子树**：对于每个子节点`v`，计算合并后的`new_S0`（`LCAS0`）和`new_S1`（`LCAS1`），更新父节点的状态；  
  3. **转换结果**：通过公式将`S0`转换为原问题的`LCAS(u)`，存储在`A[u]`中。  


### 针对优质题解的片段赏析（Subtask5正解）  
* **亮点**：巧妙合并子树，通过数学公式快速计算三元组贡献。  
* **核心代码片段**：  
  ```cpp
  int new_S0 = (1ll*S0[u] + 3ll*S[v]*S1[u]%MOD + 1ll*S0[v] + 3ll*S[u]*S1[v]%MOD) % MOD;
  int new_S1 = (1ll*S1[u] + S1[v] + 2ll*W[u]*S[u]%MOD*S[v]%MOD) % MOD;
  ```  
* **代码解读**：  
  - `new_S0`：合并子树`v`后的`LCAS0(u)`，包含四个部分：  
    1. 原`S0[u]`（左子树的三元组贡献）；  
    2. `3*S[v]*S1[u]`（两个元素在左子树、一个在右子树的贡献，`3`是排列数）；  
    3. `S0[v]`（右子树的三元组贡献）；  
    4. `3*S[u]*S1[v]`（两个元素在右子树、一个在左子树的贡献）。  
  - `new_S1`：合并子树`v`后的`LCAS1(u)`，包含三个部分：  
    1. 原`S1[u]`（左子树的二元组贡献）；  
    2. `S1[v]`（右子树的二元组贡献）；  
    3. `2*W[u]*S[u]*S[v]`（一个元素在左子树、一个在右子树的贡献，`2`是排列数，LCA为`u`）。  
* 💡 **学习笔记**：合并子树时，要根据元素分布的不同，使用不同的公式计算贡献，确保结果正确。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**“像素树的积木游戏”**：用8位像素风格展示树的结构，通过合并“积木”（子树）来计算`LCAS`值。  

### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧显示像素树（根节点1在顶部，子节点向下排列），节点用不同颜色表示（如绿色表示未处理，蓝色表示正在处理，红色表示已处理）；  
   - 屏幕右侧显示控制面板（包含“单步执行”、“自动播放”、“重置”按钮，以及`LCAS0`、`LCAS1`的值显示框）；  
   - 播放8位风格的背景音乐（如《超级马里奥》的轻快旋律）。  

2. **递归遍历子树**：  
   - 当处理根节点1时，它的子节点（如2、3）逐渐展开，颜色变为浅蓝色；  
   - 递归处理子节点2，它的子节点（如4、5）继续展开，颜色变为浅灰色。  

3. **合并子树**：  
   - 当处理完子节点4后，它的像素方块向父节点2移动，父节点2的颜色变为深蓝色，同时右侧显示框中的`S0[2]`、`S1[2]`的值增加（伴随“叮”的音效）；  
   - 处理完子节点5后，父节点2的颜色进一步加深，`S0[2]`、`S1[2]`的值继续增加；  
   - 最后，子节点2的像素方块向根节点1移动，根节点1的颜色变为红色，`S0[1]`、`S1[1]`的值更新为合并后的结果。  

4. **结果展示**：  
   - 当所有子树合并完成后，根节点1的颜色变为亮红色，右侧显示框中的`A[1]`（`LCAS(1)`）的值显示为最终结果；  
   - 播放“胜利”音效（如《魂斗罗》的通关音乐），庆祝计算完成。  

### 设计思路  
- **像素风格**：营造复古游戏的氛围，让学习者感到亲切；  
- **动画效果**：通过节点的移动和颜色变化，直观展示子树合并的过程；  
- **音效反馈**：用不同的音效提示关键操作（如合并、完成），增强记忆点；  
- **交互设计**：支持单步执行和自动播放，让学习者可以自由控制学习节奏。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
树形DP的子树合并技巧不仅能解决本题，还能解决以下问题：  
- **选课问题**（如洛谷P2014）：选择课程以获得最大学分，课程之间有先修关系（树形结构）；  
- **没有上司的舞会**（如洛谷P1352）：选择员工参加舞会，使得总快乐值最大，且不选直接上司；  
- **毛毛虫问题**（如洛谷P3174）：计算树中最长的“毛毛虫”（路径上的节点加上其邻接节点）。  

### 练习推荐 (洛谷)  
1. **洛谷 P2014** - 选课  
   🗣️ **推荐理由**：这道题是树形DP的经典问题，需要合并子树结果来计算最大学分，能帮助你巩固子树合并的技巧。  
2. **洛谷 P1352** - 没有上司的舞会  
   🗣️ **推荐理由**：此题考察树形DP的状态转移（选或不选当前节点），能帮助你理解状态定义的重要性。  
3. **洛谷 P3174** - [HAOI2009]毛毛虫  
   🗣️ **推荐理由**：此题需要计算树中的最长路径，能帮助你练习树形DP的路径合并技巧。  


## 7. 学习心得与经验分享 (若有)  
**参考经验 (来自囧仙)**：  
“我在解决这个问题时，最初想直接计算`k<j`的三元组贡献，但发现复杂度太高。后来想到将问题转换为计算所有三元组的贡献，再通过公式调整，这才找到了解题的突破口。”  

**点评**：这位作者的经验很典型。当直接解决问题困难时，不妨尝试**转换问题**，将复杂的条件（如`k<j`）转换为更容易计算的形式（如所有三元组），再通过数学公式调整结果。这种思路能帮助我们解决很多组合问题。  


## 结语  
本次关于“船往低处流”的C++解题分析就到这里。希望这份学习指南能帮助你理解树形DP的核心思想和子树合并技巧。记住，编程能力的提升在于**持续学习、勤于思考和勇于实践**。下次我们再一起探索新的编程挑战！💪

---
处理用时：151.69秒
# 题目信息

# 集合

## 题目描述

你需要**在线**维护一个自然数的排序集 $S$ 并支持以下操作：

1. 给一个数 $x$，若 $x$ 不在集合 $S$ 中则将 $x$ 添加到集合 $S$ 中；
2. 给一个数 $x$，若 $x$ 已在集合 $S$ 中则将 $x$ 从集合 $S$ 中删除。

为了证明你维护了 $S$，你需要在操作过程中回答以下询问：

3. 求集合 $S$ 中最小元素的值，若 $S=\varnothing$ 则返回 `-1`；
4. 求集合 $S$ 中最大元素的值，若 $S=\varnothing$ 则返回 `-1`；
5. 求集合 $S$ 中元素的数量；
6. 给一个数 $x$，判断 $x$ 是否在集合内，若在则返回 `1` ，若不在则返回 `0` ；
7. 给一个数 $x$，求集合 $T=S\cap[0^-,x)$ 中最大元素的值，若 $T=\varnothing$ 则返回 `-1`；
8. 给一个数 $x$，求集合 $T=S\cap[x,n)$ 中最小元素的值，若 $T=\varnothing$ 则返回 `-1`。

为了证明你**在线地**维护了 $S$，对于所有在第一次询问后的操作 $1,2$ 与询问 $6,7,8$，实际操作和询问的参数 $x$ 为输入中给出的操作和询问的参数 $x'$ 与上一次询问的返回结果 $\text{last}$ 之和。即 $x=x'+\text{last}$。

保证 $0\le x<n$ 。

初始时 $S=\varnothing$。

## 说明/提示

### 样例解释

实际上执行的操作与回答的询问如下：

```plain
1 0
1 1
1 3
1 3
3		->  0
7 0		-> -1
7 1		->  0
8 3		->  3
4		->  3
2 3
4		->  1
6 3		->  0
5		->  2
```

因此输出为 $0+(-1)+0+3+3+1+0+2=8$。

### 数据范围

| 测试点编号 |    $n=$     |    $m=$   | 分值  |
|:--------------:|:------------:|:-----------:|:-------:|
|      $1$       | $2^{20}$ | $2^{14}$ |  $5$  |
|      $2$       | $2^{25}$ | $2^{17}$ |  $5$  |
|      $3$       | $2^{30}$ | $2^{20}$ | $10$ |
|      $4$       | $2^{30}$ | $2^{22}$ | $15$ |
|      $5$       | $2^{30}$ | $2^{22}$ | $15$ |
|      $6$       | $2^{30}$ | $2^{23}$ | $25$ |
|      $7$       | $2^{30}$ | $2^{23}$ | $25$ |

对于 $100\%$ 的数据，满足 $2^{20}\le n\le2^{30},2^{14}\le m\le 2^{23},0\le x<n$。

### 提示

**本题输入量较大，建议使用较快的读入方式。**

$0^-$ 表示略小于 $0$ 的一个值，$[0^-,x)$ 可以保证第 $7$ 个操作的 $T$ 恒有意义。

## 样例 #1

### 输入

```
4 13
1 0
1 1
1 3
1 3
3
7 0
7 2
8 3
4
2 0
4
6 2
5
```

### 输出

```
8
```

# AI分析结果


### 💡 Kay的C++算法解析：集合 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`数据结构应用（权值线段树+状态压缩）`  
🗣️ **初步分析**：
> 维护动态集合的核心在于高效处理插入/删除和极值查询。就像在复古游戏《俄罗斯方块》中快速识别最高/最低方块位置一样，**六十四叉权值线段树**将值域分割成64份子区间，每个父节点用64位比特位记录子区间状态（1表示有元素）。这种设计：
> - **空间优化**：通过位压缩避免存储空节点，空间复杂度仅O(n/64)
> - **时间优化**：树高仅5层（2³⁰值域÷2⁶分叉），所有操作O(1)~O(5)常数时间
> - **关键难点**：前驱/后继查询需记录访问路径回溯位图
> 
> **可视化设计**：采用《像素地牢》风格，值域作为64×64网格地图：
> - 插入/删除时：目标格子闪烁+像素烟花特效
> - 查询时：算法路径显示为发光足迹，当前比特位高亮为荧光蓝
> - 音效：比特翻转声(8-bit "click")，找到极值时播放《超级马里奥》金币音

---

#### 2. 精选优质题解参考
**题解一 (作者：a___)**
* **点评**：实现完整且包含关键优化：
  - 思路清晰：严格遵循六十四叉树逻辑，递归更新路径
  - 代码规范：`lowp/uppb`预处理的位运算函数模块化
  - 核心亮点：用`__int128`解决位移边界问题（如`x=64`的特殊处理）
  - 实践价值：直接处理2³⁰大值域，输出参数完全符合在线要求

**题解二 (作者：Daniel13265)**
* **点评**：理论分析透彻：
  - 清晰对比普通平衡树与本解法复杂度
  - 数学证明空间复杂度O(n/ω) 
  - 明确指导ω=64的选择依据（log₆₄2³⁰=5）

---

#### 3. 核心难点辨析与解题策略
1. **难点：大值域下的高效状态存储**
   - **分析**：普通数组需2³⁰空间 → 用比特压缩：每个节点用64位ull表示子区间存在性
   - 💡 **学习笔记**：**位压缩是处理稀疏大值域的核心技巧**

2. **难点：前驱/后继查询的路径回溯**
   - **分析**：`findmax`需：
     1. 记录访问路径到`stk`（如访问x=3时记录[父节点,子索引]）
     2. 向上回溯时检查左侧比特位(`t[rt] & ((1<<q)-1)`)
   - 💡 **学习笔记**：**分层回溯是树结构查询相邻元素的标准解法**

3. **难点：位移操作的边界陷阱**
   - **分析**：`(1<<64)`在ull中等于0 → 必须用`__int128`扩展位数
   - 💡 **学习笔记**：**位运算需特别注意数据类型上限**

**✨ 解题技巧总结**  
- **分层处理**：将值域递归分割为64份子区间  
- **位图状态机**：用比特位表示子区间状态（存在/不存在）  
- **预计算加速**：预处理`lowp/uppb`快速定位最低/最高比特位  

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include<cstdio>
const int N=(1<<26); // 空间优化：只需存储非叶节点
unsigned long long t[N]; // 每个节点64位状态
__int128 ONE = 1; // 解决位移边界

void update(int rt, int l, int r, int p) {
  if(r-l < 64) { // 到达叶子层
    t[rt] ^= (ONE << (p-l)); // 翻转对应比特
    return;
  }
  int len = (r-l+1) >> 6; // 子区间长度
  int q = (p-l) / len;    // 子节点索引
  update(rt<<6|q, l+q*len, l+(q+1)*len-1, p);
  if(t[rt<<6|q]) t[rt] |= (ONE << q);  // 更新父节点状态
  else t[rt] &= ~(ONE << q);
}
```

**题解一核心代码解析**  
```cpp
int findmax(int x) { // 前驱查询：小于x的最大值
  top=0; 
  getpos(1,0,n-1,x); // 记录访问路径到stk
  for(int i=top; i; i--) {
    unsigned mask = (ONE << stk[i][1]) - 1; // 左侧比特掩码
    if(t[stk[i][0]] & mask) {               // 左侧存在元素
      int q = uppbit(t[stk[i][0]] & mask);  // 找最右侧存在的子节点
      return getmax(rt<<6|q, ...);          // 递归该子树最大值
    }
  }
  return -1;
}
```
> **代码解读**：  
> 1. `getpos`记录从根到x的路径（类似二叉树的LCA记录）  
> 2. 从底层向上回溯时，用`mask=(1<<q)-1`获取当前节点左侧子区间状态  
> 3. 若左侧存在元素(`t[rt]&mask`非0)，则找最右侧子节点(`uppbit`)  
> 4. 进入该子树递归查询最大值  
> 💡 **学习笔记**：回溯时检查左侧比特位是前驱查询的关键

---

#### 5. 算法可视化：像素动画演示  
* **主题**：`《比特迷宫探险》`（8-bit风格）  
* **核心演示**：权值线段树的更新与查询过程  

**动画帧设计**：  
1. **场景**：  
   - 值域[0,2³⁰)显示为64×64发光网格（每格代表2²⁴值域）  
   - 右侧面板：实时显示当前节点64位状态（发光=1，灰暗=0）  

2. **插入元素x=3**：  
   - 第1帧：x=3所在网格（第0行第3列）闪烁黄色  
   - 第2帧：递归路径高亮（根→子节点0→叶子层），伴随"滴滴"音效  
   - 第3帧：叶子节点比特位翻转，父节点状态同步更新  

3. **查询前驱(x=5)**：  
   - 红色足迹显示访问路径  
   - 回溯时左侧网格亮蓝色扫描线  
   - 找到前驱后触发《吃豆人》胜利音效  

**交互控制**：  
- 速度滑块：调整单步延迟（100ms~2s）  
- 模式切换：普通演示 vs 自动闯关（完成操作解锁新关卡）  

---

#### 6. 拓展练习与相似问题思考
**相似问题场景**：  
1. 实时排行榜（动态查询第K大）  
2. IP地址归属查询（大值域存在性检测）  
3. 游戏道具管理系统（批量插入/删除）  

**洛谷推荐**：  
1. **P3369** - 普通平衡树  
   → 巩固基础树结构操作  
2. **P3835** - 可持久化线段树  
   → 拓展可持久化版本应用  
3. **P4137** - Rmq Problem  
   → 练习值域分块思想  

---

#### 7. 学习心得与经验分享
> **经验摘录 (a___)**:  
> "`x=64`时`(1<<x)-1`在ull中等于0，必须用`__int128`"  
>   
> **Kay点评**：  
> 位运算的隐式整数提升是常见陷阱。当位移超过数据类型位数时：  
> - `ull`：位移≥64结果为0  
> - `__int128`：支持≤127位移  
> 建议：对大位移操作始终使用`__int128`并加括号保证优先级  

---

通过本指南，大家不仅掌握了六十四叉权值线段树的设计精髓，更理解了位压缩、路径回溯等核心技巧。记住：**好的数据结构能将复杂问题转化为比特级的精准操作**！下次遇到大值域问题时，不妨尝试这种分而治之的位图思维 💪

---
处理用时：101.56秒
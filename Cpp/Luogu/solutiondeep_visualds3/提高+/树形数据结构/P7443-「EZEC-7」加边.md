# 题目信息

# 「EZEC-7」加边

## 题目背景

> 暴力怎么做？暴力是不是，加边！加边！加边！然后，并查集查询！

Alice 不喜欢并查集，但是她喜欢加边。

## 题目描述

给定一棵 $n$ 个节点的树，节点从 $1$ 开始编号，$1$ 号节点是根节点，每条边的方向是从父亲到儿子。每个点有一个点权 $a_i$。Alice 和 Bob 在玩游戏，他们在根节点上放了一个棋子，Alice 和 Bob 轮流将棋子沿边移动，谁不能移动谁输。

已知 Alice 是先手或是后手。在游戏开始前，Alice 可以在树上添加一条有向边 $u\to v$（$1\le u,v\le n$），然后和 Bob 在形成的图上玩这个游戏，她希望自己存在必胜策略。**她也可以选择不加边。如果无法决出胜负则不算胜利。**

给定正整数 $A,B$，Alice 添加边 $u\to v$ 的代价是 $A\times a_u+B\times  a_v$。选择不加边的代价为 $0$。

Alice 要最小化她的代价。如果她怎么加边都不满足要求，输出 $-1$。

Alice 会做出 $T$ 次询问，你需要对每个询问输出答案。

## 说明/提示

**【样例解释】**

在第 $1$ 组询问中，Alice 是后手，她无论怎么添加边都无法拥有必胜策略，所以输出 $-1$。  
在第 $2$ 组询问中，Alice 是后手，她不需要添加边就拥有必胜策略，所以代价为 $0$。  
在第 $3$ 组询问中，Alice 是先手，她只能添加一条 $1\to 3$ 的边使自己必胜，此时代价为 $2\times 4+7\times 2=22$。  
在第 $4$ 组询问中，Alice 是后手，她可以添加一条 $9\to 5$ 的边使自己必胜，此时代价为 $523\times 109+182\times 162=86491$。她还有其他使自己必胜的方法，但是可以发现 $86491$ 是最小代价。  

------------


**【数据范围】**

**本题采用捆绑测试。**


- Subtask 1（10 points）：$n\le 10$，$T=1$；
- Subtask 2（15 points）：$\sum n\le 200$；
- Subtask 3（15 points）：$\sum n\le 2000$；
- Subtask 4（10 points）：$f_i=i-1$；
- Subtask 5（10 points）：$f_i=1$；
- Subtask 6（20 points）：$\sum n\le 5\times 10^5$；
- Subtask 7（20 points）：无特殊限制。

对于 $100\%$ 的数据，满足 $1\le T\le 2\times10^3$，$2\le n\le2\times 10^5$，$\sum n\le 5\times 10^6$，$1\le a_i,A,B\le 10^9$，$f_i<i$，$t\in\{0,1\}$。


------------
**【提示】**

请使用较快的输入方式。

## 样例 #1

### 输入

```
4
3 1 2 7
1 1
4 3 2
3 1 2 7
1 2
4 3 2
3 0 2 7
1 2
4 3 2
9 1 523 182
1 1 2 2 2 3 3 1
3 23 18 293 162 483 574 384 109```

### 输出

```
-1
0
22
86491```

# AI分析结果


### 💡 Kay的C++算法解析：加边问题 深入学习指南 💡

---

#### **1. 题目解读与核心算法识别**  
✨ **本题主要考察**：树上博弈论与树形动态规划  

🗣️ **初步分析**：  
> 解决“加边问题”的关键在于理解树上博弈的**必胜态/必败态分析**（类似迷宫中的安全/危险房间）。叶子节点是必败态（无路可走），非叶子节点若有任意必败态子节点则为必胜态（可迫使对手进入必败态），否则为必败态。  
> - **核心难点**：如何通过添加一条边（不形成环）改变根节点的博弈状态，使Alice获胜？  
> - **策略**：Alice只能从必败态节点连向非祖先的必败态节点，将其变为必胜态（代价为 $A \times a_u + B \times a_v$）。  
> - **解法对比**：  
>   - **0x3F解法**：DFS回溯时动态维护子树信息（`mxu`/`mxv`数组），合并兄弟子树最小值。  
>   - **Macesuted解法**：树形DP定义 `f[u][0/1]` 表示节点状态改变的最小代价。  
> - **可视化设计**：  
>   - 像素方块表示节点（红色=必胜态，蓝色=必败态），高亮当前DFS节点。  
>   - 兄弟子树合并时显示连线动画，加边操作时绘制虚线箭头并弹出代价公式。  
>   - 音效：节点状态更新时播放“叮”，成功加边时播放胜利音效。

---

#### **2. 精选优质题解参考**  
**题解一（0x3F）**  
* **点评**：  
  思路清晰直击要害——通过DFS动态维护两数组：`mxu`（子树内必败点最小权值）、`mxv`（非祖先必败点最小权值）。亮点在于**兄弟子树合并技巧**：从左向右遍历时用 `mmxu`/`mmxv` 记录前缀最小值，实时更新加边代价。代码规范（变量名 `lson`/`rbro` 明确），空间复杂度 $O(n)$ 高效，边界处理严谨（`0x3F3F3F3F` 表无穷大）。实践价值高，可直接用于竞赛。

**题解二（Macesuted）**  
* **点评**：  
  树形DP设计精妙——定义 `f[u][0]`（变必败态代价）、`f[u][1]`（变必胜态代价），配合 `minVal[u]` 记录子树必败点最小权值。亮点是**状态转移分类讨论**：若节点原为必败态，可通过加边或改造子节点转为必胜态；若为必胜态且仅有一个必败子节点，则可改造该子节点。代码模块化强，逻辑缜密，复杂度 $O(n)$。

**题解三（water_tomato）**  
* **点评**：  
  优先队列全局维护必败点权值，DFS时用标记数组排除祖先节点。思路直观易懂，**调试友好**（打印中间变量）。虽复杂度 $O(n \log n)$ 稍高，但代码简洁（约60行），适合初学者理解树上博弈与数据结构结合的应用。

---

#### **3. 核心难点辨析与解题策略**  
1. **难点1：高效获取非祖先必败点最小权值**  
   - **分析**：加边终点需为非祖先必败点。解法分两类：  
     - *前缀/后缀最小值*（0x3F/Macesuted）：DFS时预处理兄弟子树的最值，$O(1)$ 查询。  
     - *全局优先队列*（water_tomato）：用标记排除祖先节点，$O(\log n)$ 查询堆顶。  
   - 💡 **学习笔记**：树问题中“非祖先信息查询”常用前/后缀分解或DFS序转化。  

2. **难点2：状态转移与加边策略融合**  
   - **分析**：  
     - 必败态节点可连向非祖先必败点（代价 $A a_u + B a_v$）或改造子节点状态。  
     - 必胜态节点仅当有唯一必败子节点时，才可将其改造为必胜点。  
   - 💡 **学习笔记**：加边操作本质是单点状态修改，需与子树DP结合。  

3. **难点3：根节点状态初始判断**  
   - **分析**：若根节点状态已满足Alice身份（先手必胜/后手必败），则无需加边。否则需DFS更新代价。  
   - 💡 **学习笔记**：博弈问题首先验证初始状态，避免无效计算。  

✨ **解题技巧总结**  
- **拆解问题**：先计算初始博弈状态，再分析加边策略。  
- **树形DP**：自底向上回溯，维护子树关键信息（如最值）。  
- **兄弟子树合并**：用前缀/后缀数组避免重复计算。  
- **边界处理**：叶子节点显式定义必败态，无穷大值统一用 `0x3F3F3F3F`。  

---

#### **4. C++核心代码实现赏析**  
**通用核心实现参考**（基于0x3F解法优化）：  
```cpp
#include <bits/stdc++.h>
#define _ 5000010
using namespace std;
// 快读/初始化代码省略
int T, n, t, f[_], w[_], lson[_], rbro[_], mxu[_], mxv[_], siz[_], win[_];
bool vis[_]; long long A, B, ans;

void dfs(int p, bool a) {
    vis[p] = a;
    for (int i = lson[p]; i; i = rbro[i]) 
        if (a || !win[i]) dfs(i, !a);
}

int main() {
    T = read();
    while (T--) {
        // 初始化 & 建树（左儿子右兄弟）
        // 计算初始状态 win[]（从叶子向上）
        if ((win[1] != 0) ^ t) { puts("0"); continue; }
        dfs(1, !t); // 标记Alice可达节点
        ans = 0x3F3F3F3F3F3F3F3F;
        for (int i = n; i >= 1; i--) {
            if (vis[i]) mxu[i] = min(mxu[i], w[i]);   // 更新子树必败点最小值
            if (!win[i]) mxv[i] = min(mxv[i], w[i]); // 更新非祖先必败点最小值
            if (siz[i]) {
                int mmxu = mxu[lson[i]], mmxv = mxv[lson[i]];
                for (int j = rbro[lson[i]]; j; j = rbro[j]) {
                    // 关键！兄弟子树合并更新答案
                    if (mmxu != INF && mxv[j] != INF) 
                        ans = min(ans, A*mmxu + B*mxv[j]);
                    if (mmxv != INF && mxu[j] != INF) 
                        ans = min(ans, A*mxu[j] + B*mmxv);
                    mmxu = min(mmxu, mxu[j]); 
                    mmxv = min(mmxv, mxv[j]); // 更新前缀最值
                }
                mxu[i] = min(mxu[i], mmxu);
                mxv[i] = min(mxv[i], mmxv);
                if (vis[i] && mmxv != INF) // 从当前点连边
                    ans = min(ans, A*w[i] + B*mmxv); 
            }
        }
        if (ans == INF) puts("-1"); else printf("%lld\n", ans);
    }
}
```
**代码解读概要**：  
1. **左儿子右兄弟存储**：高效遍历子树。  
2. **逆向DFS更新**：从叶子向根合并信息，`mxu`/`mxv` 分别维护子树内和非祖先的必败点最小权值。  
3. **兄弟子树合并**：循环中动态计算前缀最小值（`mmxu`/`mmxv`），实时更新加边代价。  

**题解一片段赏析**（兄弟子树合并）：  
```cpp
int mmxu = mxu[lson[i]], mmxv = mxv[lson[i]];
for (int j = rbro[lson[i]]; j; j = rbro[j]) {
    if (mmxu != INF && mxv[j] != INF) 
        ans = min(ans, A*mmxu + B*mxv[j]); // 左兄弟 vs 右兄弟
    mmxu = min(mmxu, mxu[j]);  // 更新左兄弟前缀最小值
}
```
**学习笔记**：通过 `mmxu` 累积左侧兄弟子树信息，与当前兄弟 `j` 的数据组合更新答案，实现 $O(n)$ 高效合并。

---

#### **5. 算法可视化：像素动画演示**  
**主题**：像素探险家の树上博弈之旅  
**设计思路**：  
- **8位像素风**：节点为彩色方块（红=必胜，蓝=必败），树边为棕色像素线。  
- **动画流程**：  
  1. **初始化**：根节点闪烁，显示初始状态（红/蓝）。  
  2. **DFS过程**：  
     - 当前节点高亮黄色，显示 `mxu`/`mxv` 数值。  
     - 兄弟子树合并：从左到右连线，动态更新 `mmxu`/`mmxv` 气泡提示。  
  3. **加边操作**：  
     - 必败节点闪烁，弹出虚线箭头指向非祖先蓝点，显示公式 $A \times a_u + B \times a_v$。  
     - 成功更新答案时播放“胜利”音效，节点变绿。  
  4. **控制面板**：步进/暂停/调速滑块，8-bit背景音乐。  

---

#### **6. 拓展练习与相似问题思考**  
- **通用技巧迁移**：  
  树形DP维护子树最值适用于：  
  1. 动态修改树结构后的状态更新（如洛谷P3384 树链剖分）。  
  2. 博弈问题结合代价最小化（如洛谷P2146 软件包管理器）。  
- **推荐练习**：  
  1. **洛谷 P2146**：树链剖分实现路径权值更新，巩固DFS序应用。  
  2. **洛谷 P1352**：简单树形DP（选/不选），理解状态转移。  
  3. **洛谷 P2014**：树形DP+背包问题，拓展组合思维。  

---

#### **7. 学习心得与经验分享**  
> **作者water_tomato心得**：  
> *“调试时打印 `mxu/mxv` 数组，能快速定位合并逻辑错误...”*  
> **Kay点评**：树上DP问题中，**打印中间变量**是调试黄金法则，尤其适用于兄弟子树合并等复杂逻辑。另需注意：  
> 1. **long long**：点权范围 $10^9$，乘积需用 `long long`。  
> 2. **边界值**：`INF` 取 `0x3F3F3F3F3F3F3F3F` 防溢出。  

--- 

> 掌握树上博弈的核心是识别“必胜/必败态传递”，结合树形DP高效维护信息。请动手实现代码并尝试可视化，透彻理解兄弟子树合并的精妙！🚀

---
处理用时：271.48秒
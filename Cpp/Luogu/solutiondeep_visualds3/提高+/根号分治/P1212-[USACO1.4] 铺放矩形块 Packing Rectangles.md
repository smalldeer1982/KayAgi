# 题目信息

# [USACO1.4] 铺放矩形块 Packing Rectangles

## 题目描述

给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)

$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  

这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。

可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，输入的所有数在 $[1,50]$ 内。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5
```

### 输出

```
40
4 10
5 8
```

# AI分析结果

# 💡 Kay的C++算法解析：铺放矩形块 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：模拟与枚举  

🗣️ **初步分析**：  
解决“铺放矩形块”问题，就像**整理积木**——你有4块不同的矩形积木，要找到一个最小的“盒子”（封闭矩形）把它们装下，不能重叠。关键在于：**尝试所有可能的积木摆放方式，计算每种方式的盒子大小，找出最小的那个**。  

具体来说，题目已经给出了6种“基本摆放方案”（其他方案可以通过旋转或镜像得到）。我们需要：  
1. **枚举所有可能的矩形排列**（4块积木的顺序有4! = 24种）；  
2. **枚举每个矩形的旋转**（每个矩形可以正放或倒放，共2^4 = 16种）；  
3. **模拟6种基本方案**，计算每种方案的封闭矩形长宽和面积；  
4. **记录最小面积**及对应的所有可能的长宽组合。  

**核心算法流程**：  
- 用DFS或循环枚举所有排列和旋转；  
- 对每种排列，计算6种摆放情况的面积；  
- 不断更新最小面积，并记录所有可能的长宽。  

**可视化设计思路**：  
我们会做一个**8位像素风格的“矩形收纳游戏”**——用像素块代表矩形，不同颜色区分4个矩形，步骤如下：  
1. 初始化：显示4个待摆放的像素矩形（可点击旋转）；  
2. 排列枚举：用“箭头”高亮当前选中的矩形，拖动到排列位置；  
3. 摆放模拟：按6种方案动态铺放矩形，用“虚线框”显示封闭矩形；  
4. 结果展示：面积更新时闪烁提示，找到最小值时播放“叮”的胜利音效；  
5. 交互：支持“单步执行”（看每一步排列/旋转）、“自动播放”（快速遍历所有情况）。  


## 2. 精选优质题解参考

### 题解一：七喜（DFS生成排列，注释清晰）  
* **点评**：  
  这道题的“标准解法模板”！用DFS生成所有矩形的排列，每一步同时处理“正放”和“倒放”两种情况（通过交换长宽实现），逻辑清晰。`check`函数里详细列出了6种摆放情况的计算方式，注释说明了每种情况的排列顺序（比如“1 2 3 4并排放”“3个并排+1个躺平”），非常适合新手理解。代码中的`alter`函数负责更新最小面积和记录长宽，处理重复情况的方式简单有效。  

### 题解二：Chiesl（结构体存储答案，逻辑详细）  
* **点评**：  
  这道题的“细节满分版”！用`struct node`存储可能的答案（长宽），`flag`数组避免重复记录。`f`函数里把6种情况的计算拆解得非常详细（比如第四种情况“中间堆叠两个矩形”的处理），甚至针对第六种情况分了5个子情况讨论，覆盖了所有边界条件。DFS中通过`swap(a[i][0], a[i][1])`处理旋转，回溯操作规范，最后排序输出答案的方式也很严谨。  

### 题解三：HFUUZY（枚举排列+旋转，直接暴力）  
* **点评**：  
  这道题的“暴力美学版”！用四层循环枚举所有矩形的排列（交换位置），再用四层循环枚举每个矩形的旋转（交换长宽），直接覆盖所有可能的情况。`calc`函数里计算6种情况的面积，`update`函数更新最小面积。虽然代码较长，但逻辑直接，适合理解“枚举所有可能”的核心思想——既然只有384种可能（24排列×16旋转），暴力枚举完全可行！  


## 3. 核心难点辨析与解题策略

### 1. 如何枚举所有排列和旋转？  
* **分析**：  
  4个矩形的排列有`4! = 24`种，可以用`next_permutation`（STL函数）或DFS生成；每个矩形有2种旋转方式（长宽交换），可以用循环或递归中的`swap`实现。比如七喜的DFS中，每次选择一个未使用的矩形，先正放递归，再倒放递归，最后回溯。  
* 💡 **学习笔记**：枚举所有可能的关键是“不重复、不遗漏”，DFS或循环都可以，选择自己容易理解的方式。

### 2. 如何正确计算6种情况的长宽？  
* **分析**：  
  每种情况的长宽计算需要“对应题目中的图”。比如：  
  - 情况1（并排放）：长=4个矩形的长之和，宽=4个矩形的宽的最大值；  
  - 情况2（3个并排+1个躺平）：长=max(3个长之和, 第4个长)，宽=3个宽的最大值+第4个宽；  
  - 情况6（最复杂）：需要分5个子情况，比如“第3个矩形的高≥第2+4个的高”时，长=max(第1个的长, 第3+2个的长, 第3+4个的长)。  
* 💡 **学习笔记**：计算前一定要“画图”，把抽象的情况变成具体的尺寸关系。

### 3. 如何记录最小面积及所有可能的长宽？  
* **分析**：  
  用一个变量`ans`记录最小面积，用数组或集合记录所有可能的长宽（避免重复）。比如七喜用`c`数组标记哪些长宽组合有效，Chiesl用`set<pair<int, int>>`存储答案（自动去重）。  
* 💡 **学习笔记**：记录答案时要“去重”，否则会输出重复的长宽组合。


### ✨ 解题技巧总结  
- **暴力枚举**：当可能的情况数量不大时（比如本题的384种），直接枚举所有可能是最有效的方法；  
- **画图辅助**：遇到复杂的摆放情况，一定要画图，把尺寸关系写下来；  
- **去重处理**：记录答案时用数组或集合去重，避免重复输出；  
- **注释清晰**：给每种摆放情况写注释，方便自己和别人理解。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合七喜和Chiesl的思路，提炼的简洁实现，包含DFS枚举排列、旋转，计算6种情况，更新答案。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
#include <set>
using namespace std;

struct Rect { int w, h; };
Rect rects[4]; // 输入的4个矩形
int order[4] = {0, 1, 2, 3}; // 排列顺序
int min_area = INT_MAX;
set<pair<int, int>> ans; // 存储所有可能的长宽（去重）

// 更新答案：传入封闭矩形的长和宽
void update(int x, int y) {
    if (x > y) swap(x, y);
    int area = x * y;
    if (area < min_area) {
        min_area = area;
        ans.clear();
        ans.insert({x, y});
    } else if (area == min_area) {
        ans.insert({x, y});
    }
}

// 计算当前排列的6种情况
void calculate() {
    Rect r[4];
    for (int i = 0; i < 4; i++) r[i] = rects[order[i]];
    int x, y;

    // 情况1：并排放
    x = r[0].w + r[1].w + r[2].w + r[3].w;
    y = max(max(r[0].h, r[1].h), max(r[2].h, r[3].h));
    update(x, y);

    // 情况2：3个并排+1个躺平
    x = max(r[0].w + r[1].w + r[2].w, r[3].w);
    y = max(max(r[0].h, r[1].h), r[2].h) + r[3].h;
    update(x, y);

    // 情况3：2个并排+1个堆叠+1个并排
    x = max(r[0].w + r[1].w, r[2].w) + r[3].w;
    y = max(max(r[0].h, r[1].h) + r[2].h, r[3].h);
    update(x, y);

    // 情况4：1个+2个堆叠+1个
    x = r[0].w + max(r[1].w, r[2].w) + r[3].w;
    y = max(r[0].h, max(r[1].h + r[2].h, r[3].h));
    update(x, y);

    // 情况5：2个堆叠+2个并排
    x = max(r[0].w, r[1].w) + r[2].w + r[3].w;
    y = max(r[0].h + r[1].h, max(r[2].h, r[3].h));
    update(x, y);

    // 情况6：最复杂的分情况
    y = max(r[0].h + r[2].h, r[1].h + r[3].h);
    if (r[2].h >= r[1].h + r[3].h)
        x = max(max(r[0].w, r[1].w + r[2].w), r[2].w + r[3].w);
    else if (r[3].h < r[2].h)
        x = max(r[0].w + r[1].w, max(r[1].w, r[3].w) + r[2].w);
    else if (r[2].h == r[3].h)
        x = max(r[0].w + r[1].w, r[2].w + r[3].w);
    else if (r[2].h < r[3].h && r[3].h < r[2].h + r[0].h)
        x = max(r[0].w + r[1].w, max(r[0].w, r[2].w) + r[3].w);
    else if (r[3].h >= r[0].h + r[2].h)
        x = max(r[1].w, max(r[0].w, r[2].w) + r[3].w);
    update(x, y);
}

// 枚举旋转：递归处理每个矩形的旋转
void rotate(int depth) {
    if (depth == 4) {
        calculate();
        return;
    }
    // 不旋转当前矩形
    rotate(depth + 1);
    // 旋转当前矩形（交换长宽）
    swap(rects[order[depth]].w, rects[order[depth]].h);
    rotate(depth + 1);
    // 回溯：恢复原状
    swap(rects[order[depth]].w, rects[order[depth]].h);
}

// 枚举排列：用next_permutation生成所有排列
void solve() {
    do {
        rotate(0); // 对当前排列，枚举所有旋转
    } while (next_permutation(order, order + 4));
}

int main() {
    for (int i = 0; i < 4; i++) cin >> rects[i].w >> rects[i].h;
    solve();
    cout << min_area << endl;
    for (auto p : ans) cout << p.first << " " << p.second << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. 输入4个矩形的长宽；  
  2. 用`next_permutation`生成所有排列（`order`数组）；  
  3. 对每个排列，用`rotate`函数枚举所有旋转（交换长宽）；  
  4. 对每个排列+旋转的组合，用`calculate`函数计算6种情况的面积；  
  5. 用`update`函数记录最小面积和所有可能的长宽；  
  6. 输出结果。


### 题解一（七喜）核心片段赏析  
* **亮点**：用DFS生成排列，逻辑直观，注释详细。  
* **核心代码片段**：  
```cpp
void dfs(int ceng) {
    if (ceng == 4) { check(); return; }
    for (int i = 1; i < 5; i++) {
        if (!vis[i]) {
            tmpx[ceng+1] = x[i]; tmpy[ceng+1] = y[i]; vis[i] = true;
            dfs(ceng+1);
            tmpx[ceng+1] = y[i]; tmpy[ceng+1] = x[i]; // 旋转
            dfs(ceng+1);
            vis[i] = false; // 回溯
        }
    }
}
```
* **代码解读**：  
  - `ceng`表示当前处理到第几个矩形（从0到3）；  
  - 遍历所有未使用的矩形（`!vis[i]`），先正放（`tmpx`存x，`tmpy`存y），递归处理下一个；  
  - 再旋转（`tmpx`存y，`tmpy`存x），递归处理下一个；  
  - 回溯：标记`vis[i]`为false，恢复状态。  
* 💡 **学习笔记**：DFS生成排列的关键是“选一个未用的元素，递归，回溯”。


### 题解二（Chiesl）核心片段赏析  
* **亮点**：用结构体存储答案，分情况讨论最复杂的第6种情况。  
* **核心代码片段**：  
```cpp
void f(int s1, int s2, int s3, int s4) {
    // ... 前5种情况 ...
    // 情况6
    if (a[s3][0] >= a[s2][0] + a[s4][0]) 
        x = max(max(a[s1][1], a[s3][1] + a[s2][1]), a[s3][1] + a[s4][1]);
    else if (a[s4][0] < a[s3][0]) 
        x = max(a[s1][1] + a[s2][1], max(a[s2][1], a[s4][1]) + a[s3][1]);
    else if (a[s3][0] == a[s4][0]) 
        x = max(a[s1][1] + a[s2][1], a[s3][1] + a[s4][1]);
    else if (a[s3][0] < a[s4][0] && a[s4][0] < a[s3][0] + a[s1][0]) 
        x = max(a[s1][1] + a[s2][1], max(a[s1][1], a[s3][1]) + a[s4][1]);
    else if (a[s4][0] >= a[s1][0] + a[s3][0]) 
        x = max(a[s2][1], max(a[s1][1], a[s3][1]) + a[s4][1]);
    y = max(a[s1][0] + a[s3][0], a[s2][0] + a[s4][0]);
    answer(x, y);
}
```
* **代码解读**：  
  - `a[s][0]`表示第`s`个矩形的高，`a[s][1]`表示宽；  
  - 根据第3、4个矩形的高的关系，分5种情况计算长`x`；  
  - 宽`y`是左边两个矩形的高之和与右边两个的高之和的最大值；  
  - 调用`answer`函数更新答案。  
* 💡 **学习笔记**：复杂情况要“拆分成子情况”，每个子情况对应一种尺寸关系。


## 5. 算法可视化：像素动画演示  

### 动画演示主题：矩形收纳大挑战（8位像素风）  

### 设计思路  
用FC红白机的像素风格，模拟“整理矩形积木”的过程，让你直观看到每个排列、旋转和摆放的情况。游戏化元素（比如过关音效、单步执行）让学习更有趣！


### 动画帧步骤与交互关键点  

#### 1. 初始化界面（8位像素风）  
- 屏幕左侧：显示4个待摆放的矩形（用红、绿、蓝、黄4种颜色区分），每个矩形下方有“旋转”按钮（点击可交换长宽）；  
- 屏幕右侧：显示“排列区”（4个格子，对应当前的排列顺序）和“摆放区”（显示当前摆放方案的封闭矩形）；  
- 控制面板：“开始/暂停”“单步执行”“重置”按钮，速度滑块（控制自动播放速度），“方案选择”下拉框（可选择查看某一种摆放方案）。


#### 2. 排列枚举（动态演示）  
- 用“像素箭头”高亮当前选中的矩形，拖动到排列区的格子里（模拟DFS或`next_permutation`的过程）；  
- 每选一个矩形，播放“咔嗒”音效，表示“放入排列”；  
- 排列完成后，排列区的4个矩形会“闪烁”，提示“开始旋转枚举”。


#### 3. 旋转枚举（动态演示）  
- 对每个矩形，点击“旋转”按钮，矩形会“翻转”（长宽交换），同时显示当前的长宽值（比如“红矩形：w=2, h=1”变成“w=1, h=2”）；  
- 旋转时播放“咻”的音效，表示“旋转完成”。


#### 4. 摆放方案模拟（核心！）  
- 选择一种摆放方案（比如“情况1：并排放”），摆放区会动态铺放4个矩形：  
  - 每个矩形按顺序“滑入”摆放区，用“虚线框”显示当前的封闭矩形；  
  - 铺放完成后，封闭矩形的面积会显示在屏幕上方（比如“当前面积：20”）；  
  - 如果面积比当前最小值小，屏幕会“闪烁”并播放“叮”的胜利音效；  
- 对情况6（最复杂的），会用“文字气泡”提示当前的子情况（比如“当前子情况：第3个矩形的高≥第2+4个的高”）。


#### 5. 结果展示  
- 所有情况枚举完成后，屏幕会显示“最小面积：X”，并列出所有可能的长宽组合（比如“4 10”“5 8”）；  
- 点击“重新挑战”按钮，可重置所有状态，重新开始枚举。


### 技术实现小技巧  
- **像素绘制**：用HTML5 Canvas绘制像素矩形，每个矩形由16×16的像素块组成；  
- **音效**：用Web Audio API播放8位风格的音效（比如“咔嗒”“咻”“叮”）；  
- **交互**：用JavaScript实现按钮点击和拖动功能，单步执行时每点击一次“下一步”，推进一个排列或旋转步骤。


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
模拟与枚举的思路可以解决很多“尝试所有可能”的问题，比如：  
- 排列问题（比如“全排列”“组合数”）；  
- 状态枚举（比如“翻转硬币”“开关灯”）；  
- 几何问题（比如“矩形覆盖”“多边形面积计算”）。


### 洛谷练习推荐  
1. **洛谷 P5917** - 铺放矩形块（双倍经验！）  
   🗣️ **推荐理由**：和本题完全一样，练手必备，巩固枚举和模拟的思路。  
2. **洛谷 P1010** - 进制转换  
   🗣️ **推荐理由**：需要枚举所有可能的进制，锻炼“枚举+判断”的能力。  
3. **洛谷 P1160** - 队列安排  
   🗣️ **推荐理由**：模拟队列的插入和删除操作，锻炼“模拟复杂流程”的能力。  
4. **洛谷 P1200** - 你的飞碟在这儿  
   🗣️ **推荐理由**：模拟计算飞碟的位置，锻炼“将问题转化为数学模型”的能力。


## 7. 学习心得与经验分享  

### 参考经验（来自题解作者）  
- 七喜：“我在写`check`函数时，一开始漏掉了情况6的等于号，导致答案错误。后来通过打印中间变量，发现了边界条件的问题。”  
- Chiesl：“DFS的时候，一定要记得回溯！我一开始忘记`swap`回来，导致旋转的情况重复了。”  

### 点评  
- 七喜的经验提醒我们：**边界条件要仔细处理**（比如“≥”而不是“>”），打印中间变量是调试的好方法；  
- Chiesl的经验提醒我们：**递归中的回溯非常重要**，否则会修改原数据，导致错误。


## 结语  
通过这道题，我们学会了用“模拟+枚举”解决几何排列问题——虽然看起来麻烦，但只要“拆分成小步骤”（枚举排列→枚举旋转→计算每种情况→更新答案），就能一步步解决。记住：**编程的本质是“把复杂问题拆分成简单问题”**，慢慢来，你一定能掌握！  

下次我们再一起挑战更有趣的算法问题吧！💪

---
处理用时：162.31秒
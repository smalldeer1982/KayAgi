# 题目信息

# [蓝桥杯 2024 省 B 第二场] 质数变革

## 题目背景

本题原题题面中的 $op$ 表述出现矛盾，洛谷题面对此进行了修正。

## 题目描述

质数一直以来都是数学领域中的一个重要概念。传统的数论定义质数为只有两个正因子的自然数。然而，在一次变革中，小蓝提出了一个新的质数定义：绝对值只有两个正因子的数均为质数。根据小蓝的定义，质数序列如下：$\ldots, -7, -5, -3, -2, 2, 3, 5, 7, \ldots$

现给定一个包含 $n$ 个整数的数组 $a$，记为 $a_1, a_2, \ldots, a_n$，以及 $q$ 个操作，每个操作由三个整数 $op, k$ 和 $x$ 组成。小蓝将按顺序执行这些操作，依次改变数组 $a$ 中的元素值。具体地，对于一个操作：

- 若 $op$ 等于 $1$，则对于数组 $a$ 中满足 $i \bmod k = 0$ 的元素 $a_i$，将其替换为从大到小第 $x$ 个小于它的质数。
- 若 $op$ 等于 $2$，则对于数组 $a$ 中满足 $i \bmod k = 0$ 的元素 $a_i$，将其替换为从小到大第 $x$ 个大于它的质数。

由于小蓝不喜欢负数，也不喜欢太大的数，所以如果在所有操作结束后某个元素的值小于 $0$，小蓝会将其替换为 $0$；如果某个元素的值大于 $1000000$，小蓝会将其替换为 $1$。

请问，在所有操作结束后，数组 $a$ 中的元素分别为多少。

## 说明/提示

### 样例说明

- 初始时，数组 $a$ 的元素为 $[2, 3, 6, 9, 12]$。
- 执行第一个操作，将 $a_2$ 替换为从小到大第 1 个大于它的质数，即 $a_2$ 变为 5。将 $a_4$ 替换为从小到大第 1 个大于它的质数，即 $a_4$ 变为 11。数组变为 $[2, 5, 6, 11, 12]$。
- 执行第二个操作，将 $a_2$ 替换为从小到大第 1 个大于它的质数，即 $a_2$ 变为 7。将 $a_4$ 替换为从小到大第 1 个大于它的质数，即 $a_4$ 变为 13。数组变为 $[2, 7, 6, 13, 12]$。
- 执行第三个操作，将 $a_3$ 替换为从大到小第 4 个小于它的质数，即 $a_3$ 变为 -2。数组变为 $[2, 7, -2, 13, 12]$。
- 操作结束后，将数组中所有小于 0 的元素变为 0，大于 1000000 的元素变为 1，因此最后的数组为 $[2, 7, 0, 13, 12]$。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq n, q \leq 2 \times 10^3$，$1 \leq op \leq 2$，$1 \leq k \leq n$，$1 \leq x, a_i \leq 10^5$。
- 对于所有评测用例，$1 \leq n, q \leq 2 \times 10^5$，$1 \leq op \leq 2$，$1 \leq k \leq n$，$1 \leq x, a_i \leq 10^6$。

## 样例 #1

### 输入

```
5 3
2 3 6 9 12
2 2 1
2 2 1
1 3 4```

### 输出

```
2 7 0 13 12```

# AI分析结果

---
# 💡 Kay的C++算法解析：质数变革 深入学习指南 💡

<introduction>
今天我们要一起攻克蓝桥杯2024省赛B组的“质数变革”问题！这道题看似复杂，但只要拆解新质数的定义、用好质数筛法和二分查找，就能轻松解决。让我们开始吧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（数论：质数筛法）` + `二分查找`

🗣️ **初步分析**：
解决这道题的关键，在于先理解**“新质数”的本质**——它其实是“传统质数的正负双胞胎”（比如2和-2都是新质数，因为它们的绝对值是传统质数）。接下来，我们需要像“整理积木”一样，把新质数分成**正部**（传统质数本身，如2、3、5）和**负部**（传统质数的相反数，如-2、-3、-5）。

要快速找到目标质数，我们需要两步核心操作：
1. **用“线性筛法”预处理传统质数**：就像提前把所有“积木块”（传统质数）按顺序摆好，方便后续快速取用。
2. **用“二分查找”定位目标**：对于每个查询，像“查字典”一样快速找到正部或负部中对应的质数位置，再组合出结果。

比如样例中要找比6小的第4个新质数（从大到小）：
- 先找正部中比6小的质数：5、3、2（前3个）；
- 再找负部中第1个质数（-2），组合起来就是第4个目标。

**可视化设计思路**：我们会用复古像素风格模拟这个过程——屏幕左侧是按顺序排列的传统质数积木，右侧是正负部的“质数抽屉”。当查询时，会用高亮和箭头展示二分查找的过程，找到目标后播放“叮”的音效，像游戏中“收集宝石”一样有成就感！


## 2. 精选优质题解参考

<eval_intro>
目前题目暂无题解，我会结合核心思路为你提供一份清晰的通用实现方案~
</eval_intro>


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在**新质数的定义理解**和**快速查询逻辑**上。我帮你梳理了3个核心难点及解决办法：
</difficulty_intro>

1. **难点1：新质数的定义拆解**  
   - **问题**：容易误以为新质数只有正数，忽略负数部分（比如-2也是新质数）。  
   - **解决**：把新质数拆成“正部（传统质数）”和“负部（传统质数的相反数）”，记住：**正部全是正数，负部全是负数，正部所有数都比负部大**。

2. **难点2：快速找“第x个质数”**  
   - **问题**：直接遍历找质数会超时（比如x=1e6时）。  
   - **解决**：用“二分查找”快速定位质数数组中的位置。比如找比v小的正部质数数量，只需用`lower_bound`找第一个≥v的位置，前面的就是比v小的。

3. **难点3：质数筛法的范围选择**  
   - **问题**：筛的范围太小会导致查不到目标质数。  
   - **解决**：根据题目中x的最大值（1e6），用质数定理估算需要筛到2e7左右的质数（足够覆盖第1e6个质数）。

### ✨ 解题技巧总结
- **拆解问题**：把复杂的新质数拆成正负部，降低思考难度；
- **预处理优先**：提前筛好质数，避免重复计算；
- **二分加速**：用二分查找替代暴力遍历，把查询时间从O(n)降到O(log n)。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份完整的核心实现——它综合了线性筛法和二分查找的核心逻辑，帮你快速理解整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码用线性筛预处理传统质数，结合二分查找快速响应每个操作，是解决本题的典型方案。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> primes;

void sieve(int max_n) {
    vector<bool> is_prime(max_n + 1, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i <= max_n; ++i) {
        if (is_prime[i]) primes.push_back(i);
        for (int p : primes) {
            if (1LL * i * p > max_n) break;
            is_prime[i * p] = false;
            if (i % p == 0) break;
        }
    }
}

long long get_op1(long long v, int x) {
    int pos_B = lower_bound(primes.begin(), primes.end(), v) - primes.begin();
    int cnt_B = pos_B;
    if (x <= cnt_B) return primes[pos_B - x];
    
    long long target_v = -v;
    int pos_A = upper_bound(primes.begin(), primes.end(), target_v) - primes.begin();
    int offset = x - cnt_B - 1;
    return -primes[pos_A + offset];
}

long long get_op2(long long v, int x) {
    long long target_v = -v;
    int pos_C = lower_bound(primes.begin(), primes.end(), target_v) - primes.begin();
    int cnt_C = pos_C;
    if (x <= cnt_C) return -primes[pos_C - x];
    
    int pos_D = lower_bound(primes.begin(), primes.end(), v + 1) - primes.begin();
    int offset = x - cnt_C - 1;
    return primes[pos_D + offset];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int max_n = 20000000; // 预处理到2e7，覆盖题目需求
    sieve(max_n);
    
    int n, q;
    cin >> n >> q;
    vector<long long> a(n + 1);
    for (int i = 1; i <= n; ++i) cin >> a[i];
    
    while (q--) {
        int op, k, x;
        cin >> op >> k >> x;
        for (int i = k; i <= n; i += k) {
            long long v = a[i];
            long long new_v;
            if (op == 1) new_v = get_op1(v, x);
            else new_v = get_op2(v, x);
            a[i] = new_v;
        }
    }
    
    for (int i = 1; i <= n; ++i) {
        if (a[i] < 0) a[i] = 0;
        else if (a[i] > 1000000) a[i] = 1;
        cout << a[i] << (i == n ? "\n" : " ");
    }
    return 0;
}
```
* **代码解读概要**：
  1. 用`sieve`函数预处理2e7以内的传统质数，存在`primes`数组中；
  2. `get_op1`/`get_op2`分别处理“找比v小的第x个质数”和“找比v大的第x个质数”；
  3. 主函数读取输入，处理每个操作，最后调整数组并输出。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我设计了一个“质数探险家”的像素动画，帮你直观理解过程：
</visualization_intro>

### 🎮 动画主题：像素质数大冒险
**设计思路**：用8位像素风模拟“收集质数宝石”的过程，结合游戏化元素让学习更有趣——找到目标质数就像“通关”，增强成就感！

### 🕹️ 核心演示步骤
1. **场景初始化**：  
   - 屏幕左侧是按顺序排列的“质数积木”（传统质数，用绿色像素块显示）；  
   - 右侧是“正负抽屉”：正部（红色积木，放传统质数）、负部（蓝色积木，放相反数）；  
   - 底部有“操作面板”：输入v、op、x，点击“单步”或“自动”播放。

2. **查询演示（以v=6、op=1、x=4为例）**：
   - **步骤1**：用二分查找找到正部中比6小的质数位置（pos_B=3，对应5、3、2），绿色积木闪烁；
   - **步骤2**：找到负部中第1个质数（-2），蓝色积木闪烁；
   - **步骤3**：用箭头展示“从大到小”排列（5→3→2→-2），第4个目标（-2）用黄色高亮；
   - **步骤4**：播放“叮”的音效，探险家跳起来庆祝，像游戏中“收集到宝石”！

### 🎵 音效与交互
- **关键操作**：二分查找时播放“滴滴”声，找到目标播放“叮”；
- **交互**：支持“单步执行”（逐步看过程）和“自动播放”（快速演示），速度可调。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了质数筛法和二分查找，可以尝试这些类似问题巩固技能：
</similar_problems_intro>

- **洛谷 P3383 【模板】线性筛素数**：练习线性筛法的基础实现；
- **洛谷 P1036 选数**：结合质数判断和组合问题，强化数论应用；
- **洛谷 P2615 神奇的幻方**：练习数组操作，培养“预处理”思维。


## 7. 学习心得与经验分享 (若有)
目前暂无题解作者心得，但你可以记住：**遇到“质数查询”问题，先预处理再二分，是永远的神！**


<conclusion>
这道题的核心是“用数学方法提前准备，用搜索技巧快速查找”。掌握了这个思路，以后遇到数论问题都能举一反三！编程就像玩游戏，多练多试，你一定能通关~ 💪
</conclusion>

---
处理用时：284.38秒
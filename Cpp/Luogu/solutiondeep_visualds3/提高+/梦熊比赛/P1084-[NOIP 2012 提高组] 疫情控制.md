# 题目信息

# [NOIP 2012 提高组] 疫情控制

## 题目描述

H 国有 $n $ 个城市，这 $n$ 个城市用 $ n-1 $ 条双向道路相互连通构成一棵树，$1 $ 号城市是首都，也是树中的根节点。

H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。

现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。

请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。


## 说明/提示

【输入输出样例说明】

第一支军队在 $2$ 号点设立检查点，第二支军队从 $2$ 号点移动到$ 3$ 号点设立检查点，所需时间为 $3$ 个小时。

 
【数据范围】

保证军队不会驻扎在首都。

- 对于 $20\%$ 的数据，$2 \le n\le 10$；
- 对于 $40\%$ 的数据，$2 \le n\le 50$，$0<w <10^5$；
- 对于 $60\%$ 的数据，$2 \le n\le 1000$，$0<w <10^6$；
- 对于 $80\%$ 的数据，$2 \le n\le 10^4$；
- 对于 $100\%$ 的数据，$2\le m\le n≤5\times 10^4$，$0<w <10^9$。


NOIP 2012 提高组 第二天 第三题


## 样例 #1

### 输入

```
4 
1 2 1 
1 3 2 
3 4 3 
2 
2 2```

### 输出

```
3```

# AI分析结果


# 💡 Kay的C++算法解析：疫情控制 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`二分答案 + 树上倍增 + 贪心策略`

🗣️ **初步分析**：
> 解决"疫情控制"的关键在于**二分答案确定最小时间**，通过**树上倍增优化军队移动**，并运用**贪心策略匹配闲置军队与未封锁子树**。核心思想如同"统筹全局，重点突破"：军队尽可能向根节点移动扩大控制范围，再通过智能调配实现全局覆盖。

- **二分框架**：答案具有单调性（时间越长越可行），二分时间T后转换为判定问题
- **倍增优化**：预处理树上祖先关系与距离，O(log n)时间完成军队上移
- **贪心匹配**：将能到根节点的军队按剩余时间排序，未封锁子树按距离排序，双指针匹配
- **可视化设计**：像素动画将展示军队沿树链上移（红色高亮）、子树封锁状态（绿色/红色）、贪心匹配过程。关键变量（剩余时间、子树距离）动态更新，配以8位音效增强理解

## 2. 精选优质题解参考

**题解一（作者：TEoS）**
* **点评**：
  - 思路清晰：明确二分+倍增+贪心三阶段，推导状态转移与匹配策略
  - 代码规范：邻接表存图，变量名`f[i][j]`（祖先）、`dist[i][j]`（距离）含义明确
  - 算法高效：倍增预处理O(n log n)，check函数O(n log n)，整体O(n log n log w)
  - 实践价值：完整处理边界条件（如军队无法返回时的就地驻扎）

**题解二（作者：litble）**
* **点评**：
  - 逻辑严谨：创新性使用DFS直接判定子树封锁状态，避免重复计算
  - 结构优化：将闲置军队与未封锁子树分离处理，匹配策略更直观
  - 代码简洁：利用STL的pair和vector简化数据结构操作

## 3. 核心难点辨析与解题策略

1. **军队上移优化**
   * **难点**：快速确定军队在时间T内能到达的最高位置
   * **分析**：用树上倍增法预处理祖先关系与距离和。对每个军队从高位到低位枚举，若时间允许则上移，如同"电梯逐层停靠"
   * 💡 **学习笔记**：倍增是树上路径查询的利器，二进制拆分思想贯穿始终

2. **跨子树调配决策**
   * **难点**：闲置军队应留守本子树还是支援他处？
   * **分析**：若军队剩余时间不足返回原子树（`rest < dist[子树]`），则留守更优；否则加入闲置队列全局调配
   * 💡 **学习笔记**：贪心选择需满足"无后效性"，当前决策不影响后续最优性

3. **贪心匹配策略**
   * **难点**：多棵子树需封锁时如何最小化最大时间
   * **分析**：将闲置军队按剩余时间升序排序，未封锁子树按距离升序排序，双指针匹配。如同"小脚穿小鞋"，避免资源浪费
   * 💡 **学习笔记**：排序+双指针是解决匹配问题的经典模式

### ✨ 解题技巧总结
- **技巧A（问题分解）**：将复杂问题拆解为二分判定、树上移动、贪心匹配三个子问题
- **技巧B（数据结构优化）**：使用邻接表存图、pair数组存储匹配关系
- **技巧C（边界处理）**：特别注意军队能否返回原子树、根节点不设检查点等边界
- **技巧D（调试技巧）**：构造特殊数据（如链状树）验证贪心策略正确性

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
* **说明**：综合自TEoS与litble的优质题解，优化变量命名与结构
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e4 + 5;

struct Edge { int v, w; };
vector<Edge> g[N];
int n, m, army[N], fa[17][N];
ll dis[N], dist[17][N];
bool need[N], vis[N];

// 预处理倍增数组
void dfs(int u, int f) {
    fa[0][u] = f;
    for (int i = 1; i <= 16; i++) {
        fa[i][u] = fa[i-1][fa[i-1][u]];
        dist[i][u] = dist[i-1][u] + dist[i-1][fa[i-1][u]];
    }
    for (auto e : g[u]) {
        if (e.v == f) continue;
        dis[e.v] = dis[u] + e.w;
        dist[0][e.v] = e.w;
        dfs(e.v, u);
    }
}

// 判断子树是否被封锁
bool checkSubtree(int u, int f) {
    if (vis[u]) return true;
    bool hasChild = false;
    for (auto e : g[u]) {
        if (e.v == f) continue;
        hasChild = true;
        if (!checkSubtree(e.v, u)) return false;
    }
    return hasChild; // 叶子节点返回false
}

// 二分答案的check函数
bool check(ll T) {
    vector<pair<ll, int>> freeArmy;
    fill(vis, vis + N, false);
    fill(need, need + N, false);

    // 军队上移
    for (int i = 1; i <= m; i++) {
        int u = army[i];
        ll moved = 0;
        for (int j = 16; j >= 0; j--) {
            if (fa[j][u] > 1 && moved + dist[j][u] <= T) {
                moved += dist[j][u];
                u = fa[j][u];
            }
        }
        if (fa[0][u] == 1 && moved + dist[0][u] <= T)
            freeArmy.push_back({T - moved - dist[0][u], u});
        else 
            vis[u] = true;
    }

    // 检查需要封锁的子树
    for (auto e : g[1])
        need[e.v] = !checkSubtree(e.v, 1);

    // 贪心匹配
    vector<ll> needDist;
    for (auto e : g[1]) 
        if (need[e.v]) needDist.push_back(e.w);
    
    sort(freeArmy.begin(), freeArmy.end());
    sort(needDist.begin(), needDist.end());
    
    int i = 0, j = 0;
    while (i < freeArmy.size() && j < needDist.size()) {
        if (freeArmy[i].first >= needDist[j]) j++;
        i++;
    }
    return j == needDist.size();
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i < n; i++) {
        int u, v, w; scanf("%d%d%d", &u, &v, &w);
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    }
    scanf("%d", &m);
    for (int i = 1; i <= m; i++) scanf("%d", &army[i]);
    
    dfs(1, 0);
    ll l = 0, r = 1e15, ans = -1;
    while (l <= r) {
        ll mid = (l + r) >> 1;
        if (check(mid)) ans = mid, r = mid - 1;
        else l = mid + 1;
    }
    printf("%lld", ans);
    return 0;
}
```
* **代码解读概要**：
  - **预处理阶段**：`dfs`函数计算每个节点的祖先与距离
  - **二分框架**：主函数中二分时间，调用`check`判定
  - **军队移动**：`check`内循环让每个军队尽量上移
  - **子树检查**：`checkSubtree`递归判断子树封锁状态
  - **贪心匹配**：排序后双指针完成闲置军队与未封锁子树匹配

**题解一（TEoS）片段赏析**
* **亮点**：记忆化搜索优化子树状态判断
* **核心代码片段**：
```cpp
bool dfs(int x) {
    if (sta[x]) return true;
    bool pson = false;
    for (int i = head[x]; i; i = Next[i]) {
        int y = ver[i];
        if (d[y] < d[x]) continue; // 跳过父节点
        pson = true;
        if (!dfs(y)) return false;
    }
    if (!pson) return false; // 叶子节点未被封锁
    return true;
}
```
* **代码解读**：
  > 该DFS判断以x为根的子树是否被完全封锁。若x是叶子节点且未被封锁直接返回false；遍历所有子节点，遇到未封锁子树则提前终止。`pson`标记判断是否为叶子节点。
* 💡 **学习笔记**：DFS中巧用返回值提前终止，优化搜索效率

## 5. 算法可视化：像素动画演示

* **动画主题**："抗疫指挥官"8位像素策略游戏
* **核心演示**：二分答案下军队移动与封锁匹配全过程
* **设计思路**：
  - **像素网格**：树结构转化为网格地图，城市为像素方块（首都：金色，军队：蓝色，封锁子树：绿色闪烁）
  - **关键帧步骤**：
    1. **初始化**：显示树结构，军队初始位置闪烁
    2. **军队上移**：军队沿树链向根节点移动，路径高亮显示
    3. **子树状态**：被封锁子树变绿，未封锁子树变红闪烁
    4. **贪心匹配**：闲置军队（黄色）与红色子树连线匹配，配成功音效
  - **交互控制**：
    - 单步执行：观察军队移动细节
    - 调速滑块：控制动画速度
    - 重置/暂停：自主探索不同情况

* **技术实现**：Canvas绘制树结构，颜色标记状态变化，Web Audio API添加音效（移动声、匹配成功声）

## 6. 拓展练习与相似问题思考

* **通用技巧迁移**：
  - 二分答案模型：最小化最大值/最大化最小值问题
  - 树上倍增：LCA查询、路径统计
  - 贪心匹配：任务分配、资源调度

* **练习推荐（洛谷）**：
  1. **P1084 [NOIP2012提高] 疫情控制**（同题巩固）
     - 🗣️ **推荐理由**：直接应用本解题框架，强化代码实现
  2. **P3942 将军令** 
     - 🗣️ **推荐理由**：类似贪心覆盖树节点，练习策略设计
  3. **P5025 [SNOI2017]炸弹**
     - 🗣️ **推荐理由**：图论中的覆盖问题，训练问题转化能力

## 7. 学习心得与经验分享

> **参考经验**："我在解决军队跨子树调配时，最初陷入局部最优陷阱，后来通过构造链状树测试用例才理解全局贪心的必要性。这提醒我们：**复杂贪心需构造极端数据验证**，纸上模拟比空想更有效。"

> **点评**：调试经历揭示了算法设计的核心原则——可证明的正确性。通过小规模数据验证边界情况（如单链树、星形树），能有效避免思维漏洞。

---
处理用时：130.28秒
# 题目信息

# [USTCPC 2025] 公平抉择

## 题目背景

考虑到评测机性能差异，改为 400ms 时限。USTCPC 时限为 600ms。

**请注意本题非常规时空限制！**

所以要“费厄”，最好是首先看清对手，倘是些不配承受“费厄”的，大可以老实不客气；待到它也“费厄”了，然后再与它讲“费厄”不迟。(节选自鲁迅《论“费厄泼赖”应该缓行》)

克露丝卡尔酱选择困难！她甚至无法抉择午饭去吃什么，作为她的朋友，你需要和她一起完整**公平的抉择**。

## 题目描述

克露丝卡尔酱在做选择，食堂共有 $n$ 种菜品可选，而她手里只有一个 $k$ 面的骰子(如果 $k = 2$ 则为硬币)。

为了落实公平抉择的理念，她希望她的策略选择到每个菜品的概率相等。

求她期望投掷次数的最小值，**答案对质数 $M$ 取模**。

## 说明/提示

在样例 $1$ 中，不妨设答案为 $E$。考虑扔两次硬币，得到四种情况，出现概率各为 $\dfrac{1}4$。前三种情况分配给三种菜品，第四种情况重投。故 $E=2+\dfrac{E}4$，解得 $E=\dfrac{8}3$。

## 样例 #1

### 输入

```
3 2 998244353```

### 输出

```
665496238```

## 样例 #2

### 输入

```
10 2 998244353```

### 输出

```
798595487```

# AI分析结果

# 💡 Kay的C++算法解析：公平抉择 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论应用） + 循环节优化

🗣️ **初步分析**：  
解决这道题的关键，就像**分糖果游戏**——你有一堆糖果（每次掷骰子产生的`k^v`种情况），要公平分给`n`个小朋友（`n`种菜品）。每次尽量多给每个小朋友同样多的糖果（每种菜品分配`c`种情况），剩下的糖果（未确定的`r_v = k^v mod n`种情况）下次继续分。这个过程会重复直到所有糖果都分完，而我们要算的是“分糖果的总次数期望”（即掷骰子的期望次数）。  

### 核心算法与可视化设计思路  
1. **算法流程**：  
   - 每次掷`v`次骰子后，得到`k^v`种情况，其中`r_v = k^v mod n`种情况未确定（剩下的糖果）。  
   - 第`v+1`次掷骰子时，会有`n * floor((k*r_v)/n)`种情况被确定（分出去的糖果），这部分的期望贡献是`(v+1) * 分出去的情况数 / k^(v+1)`。  
   - 由于`r_v`会因模运算进入**循环节**（比如`k^b ≡ k^(b+d) mod n`），我们可以用循环节优化计算，避免重复求和。  

2. **可视化设计**：  
   - 用8位像素风模拟“分糖果”场景：屏幕左侧是`n`个像素小朋友（不同颜色方块），右侧是“糖果堆”（动态变化的像素块数量）。  
   - 每次分糖果时，高亮当前要分的糖果数量（`k^v`），用“滑动”动画将`n*c`个糖果分到小朋友身上，剩余的糖果（`r_v`）闪烁提示“下次继续”。  
   - 循环节开始时，屏幕底部弹出“循环啦！”的像素文字，伴随“滴”的提示音效，帮助理解“重复过程可以批量计算”。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选出1份优质题解（≥4星），它完整覆盖了核心逻辑，且代码风格简洁规范。
</eval_intro>

**题解一：（来源：VinstaG173）**  
* **点评**：  
  这份题解的**贪心策略**（每次分尽可能多的确定情况）非常直白，直接抓住了问题的核心——用模运算跟踪未确定的情况。作者对期望的分解（将总期望拆分为“非循环部分”和“循环部分”）逻辑严谨，尤其对循环节的处理（用`vis`数组记录`r_v`的出现位置）非常巧妙，避免了无限求和。代码中`qpw`（快速幂）、`inv`（逆元数组）的实现规范，变量命名（如`b`表示循环起点、`d`表示循环长度）清晰易懂。从实践角度看，代码直接处理了模运算和逆元，完全符合题目“对质数M取模”的要求，是一份能直接用于竞赛的高质量题解。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要是三个核心问题：如何分解期望？如何处理无限循环的求和？如何计算模逆元？结合题解的思路，我们逐一突破！
</difficulty_intro>

1. **难点1：如何分解期望？**  
   总期望是“每一步贡献的期望之和”——第`v+1`次掷骰子的贡献是“分出去的情况数 × 次数（v+1） ÷ 总情况数（k^(v+1)）”。比如样例1中，第2次掷骰子分出去3种情况，贡献是`3/4 × 2`；第3次分出去1种情况（剩下的1种重投后分），贡献是`1/8 × 3`，以此类推。  
   💡 **学习笔记**：期望的线性性质是关键——把“总期望”拆成“每一步的期望贡献”，避免直接计算无限级数。

2. **难点2：如何处理循环节？**  
   `r_v = k^v mod n`会进入循环（比如`k=2, n=3`时，`r_1=2, r_2=1, r_3=2, r_4=1...`循环）。此时无限求和可以拆成“循环前的部分”+“循环部分的无限求和”。循环部分的和可以用等比数列公式计算（比如循环长度`d`，公比`1/k^d`）。  
   💡 **学习笔记**：模运算的循环节是优化无限求和的“钥匙”，用`vis`数组记录`r_v`的位置就能找到循环起点和长度。

3. **难点3：如何计算模逆元？**  
   题目要求答案对质数`M`取模，而我们需要计算`1/k^v mod M`（比如`inv[v]`表示`k^v`的逆元）。由于`M`是质数，根据费马小定理，`k^(M-2) mod M`就是`k`的逆元，再用快速幂计算`k^v`的逆元（`inv[v] = inv[v-1] × inv[1] mod M`）。  
   💡 **学习笔记**：费马小定理是计算模逆元的“神器”，尤其适用于模数是质数的情况。

### ✨ 解题技巧总结  
- **分解问题**：把复杂的期望拆成简单的“每一步贡献”，降低思考难度。  
- **循环优化**：利用模运算的循环节，将无限求和转化为有限计算。  
- **逆元计算**：用费马小定理快速求逆元，处理模运算中的除法。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**（基于VinstaG173的题解优化），它完整覆盖了“找循环节→计算非循环部分→计算循环部分→求和”的全流程。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了题解的核心逻辑，优化了变量命名和注释，更易理解。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <cstring>
using namespace std;
typedef long long ll;

ll n, k, M;
ll inv[3000007]; // inv[v] = (1/k^v) mod M
int vis[3000007]; // vis[x]记录x第一次出现的位置（用于找循环节）

// 快速幂：计算x^v mod M
inline ll qpow(ll x, ll v) {
    ll res = 1;
    while (v) {
        if (v & 1) res = res * x % M;
        x = x * x % M;
        v >>= 1;
    }
    return res;
}

int main() {
    cin >> n >> k >> M;
    if (n == 1) { cout << 0 << endl; return 0; } // 特殊情况：只有1种菜品，不用掷
    
    // 初始化逆元：inv[1] = 1/k mod M，inv[v] = inv[v-1] * inv[1] mod M
    inv[1] = qpow(k, M - 2);
    for (int v = 2; v <= 3000000; v++) {
        inv[v] = inv[v-1] * inv[1] % M;
    }
    
    ll x = 1; // x = k^v mod n，初始v=0时x=1（k^0=1）
    int b = 0, d = 0; // b是循环起点前的步数，d是循环长度
    memset(vis, 0, sizeof(vis));
    vis[x] = 1; // 记录x第一次出现的位置（v=0时x=1）
    
    // 找循环节：直到x再次出现
    for (int c = 2; ; c++) {
        x = x * k % n; // 计算k^c mod n（v=c时的r_v）
        if (vis[x]) {
            b = vis[x] - 1; // 循环开始于v = vis[x]-1（因为vis[x]是第一次出现的位置）
            d = c - vis[x]; // 循环长度：当前c - 第一次出现的位置
            break;
        }
        vis[x] = c;
    }
    
    ll ans = 0; // 非循环部分的期望（v从1到b）
    ll y = 1; // y = k^v mod n，用于计算非循环部分
    for (int v = 1; v <= b; v++) {
        y = y * k % n; // 现在y是k^v mod n（即r_v）
        ll assigned = (y * k / n) * n; // 第v+1次分出去的情况数：n*floor((k*r_v)/n)
        ans = (ans + assigned * inv[v] % M * v % M) % M; // 贡献：assigned * v / k^v
    }
    
    // 计算循环部分的期望tmp
    ll tmp = 0;
    x = qpow(k, b) % n; // 循环开始时的r_b = k^b mod n
    for (int i = 1; i <= d; i++) {
        x = x * k % n; // r_{b+i} = k^(b+i) mod n
        ll assigned = (x * k / n) * n; // 第b+i+1次分出去的情况数
        tmp = (tmp + assigned * inv[b + i] % M * (b + i) % M) % M; // 循环部分每一步的贡献
    }
    // 循环部分的无限求和：tmp + tmp*(1/k^d) + tmp*(1/k^d)^2 + ... = tmp * (1 / (1 - 1/k^d))
    ll denom = (M + 1 - inv[d]) % M; // 分母：1 - 1/k^d = (k^d - 1)/k^d，模M下是(1 - inv[d])
    ll inv_denom = qpow(denom, M - 2); // 分母的逆元
    // 循环部分的额外贡献：d * r_b * inv[b + d] （推导见题解）
    ll extra = d * qpow(k, b) % n * inv[b + d] % M;
    tmp = (tmp + extra) % M;
    tmp = tmp * inv_denom % M;
    
    ans = (ans + tmp) % M;
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. **快速幂与逆元初始化**：用`qpow`计算逆元，`inv`数组存储`1/k^v mod M`。  
  2. **找循环节**：用`vis`数组记录`k^v mod n`的出现位置，找到循环起点`b`和长度`d`。  
  3. **计算非循环部分**：直接循环计算前`b`步的期望贡献。  
  4. **计算循环部分**：用等比数列求和公式计算循环部分的无限贡献，最后加总得到答案。

---

<code_intro_selected>
再看**题解一**的核心片段，重点分析“循环节处理”和“逆元计算”的代码。
</code_intro_selected>

**题解一：（来源：VinstaG173）**  
* **亮点**：用`vis`数组高效找循环节，逆元数组预处理优化多次查询。  
* **核心代码片段**：  
```cpp
// 找循环节
for(c=1;!vis[x];++c,x=x*k%n){
    vis[x]=c,inv[c+1]=inv[c]*inv[1]%m;
}d=c-vis[x];b=vis[x]-1;

// 计算循环部分的期望
for(int i=1;i<=d;++i,x=x*k%n){
    tmp=(tmp+(x*k/n*n)%m*inv[i+b]%m*(i+b))%m;
}tmp=(tmp+inv[d]*d%m*x%m*inv[b])%m;
tmp=tmp*qpw(m+1-inv[d],m-2)%m;
```
* **代码解读**：  
  - **找循环节**：`vis[x]`记录`x`第一次出现的位置（`c`），当`x`再次出现时，`d = c - vis[x]`就是循环长度，`b = vis[x]-1`是循环前的步数。比如`k=2, n=3`时，`x`的变化是`1→2→1`，`vis[1]=1`，`c=3`时`x=1`再次出现，所以`d=3-1=2`，`b=1-1=0`（循环从`v=0`开始）。  
  - **循环部分计算**：`tmp`累加循环内每一步的贡献，然后用`qpw(m+1-inv[d], m-2)`计算分母的逆元（`1/(1-1/k^d)`），最后得到循环部分的总期望。  
* 💡 **学习笔记**：循环节的处理是代码的“核心优化点”，避免了O(n)以上的时间复杂度。  


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：《像素分糖果大挑战》  
**设计思路**：用8位像素风模拟“分糖果”游戏，把抽象的数学问题变成“给小朋友分糖”的互动场景，用音效和关卡增强趣味性——每完成一次循环就是“闯过一关”，成功分完所有糖果会播放“胜利音乐”！

### 🎬 动画帧步骤与交互关键点  
1. **场景初始化**（FC风格）：  
   - 屏幕左侧：`n`个像素小朋友（比如3个，用红、蓝、绿方块表示），下方显示“剩余糖果：1”（初始`k^0=1`）。  
   - 屏幕右侧：控制面板（“开始”“单步”“重置”按钮 + 速度滑块），背景播放8位风格的《欢乐分糖歌》。  

2. **非循环部分演示**（比如`b=1`）：  
   - 第1次掷骰子（`v=1`）：剩余糖果变成`k^1=2`（像素块从1个变成2个），伴随“嗒”的掷骰子音效。  
   - 分糖果：`2*k/n = 2*2/3=1`，所以每个小朋友分1个，共分3个？不对，等一下——`r_v=k^v mod n=2 mod 3=2`，`k*r_v=4`，`floor(4/3)=1`，所以分出去`1*3=3`种情况？哦，样例1中`v=1`时`r_v=2`，`k*r_v=4`，`floor(4/3)=1`，分出去3种情况，剩余`4-3=1`种情况。此时动画中：  
     - 3个小朋友各获得1个糖果（像素块从“灰色”变成对应颜色），剩余1个糖果（灰色）闪烁。  
     - 控制面板显示“当前贡献：3/4 × 2 = 1.5”，伴随“叮”的分糖音效。  

3. **循环部分演示**（比如`d=2`）：  
   - 循环开始时，屏幕底部弹出像素文字“进入循环！每2步重复一次～”，伴随“滴”的提示音。  
   - 第2次掷骰子（`v=2`）：剩余糖果变成`1*2=2`，分出去3种情况？不对，`r_v=1`，`k*r_v=2`，`floor(2/3)=0`，所以分出去0种？哦，样例1的循环是`r_1=2, r_2=1, r_3=2, r_4=1...`，所以循环部分的贡献是`v=2`时分出去1种（`r_2=1`，`k*r_2=2`，`floor(2/3)=0`？不对，可能我记错了样例的循环。不管怎样，动画中循环部分会用“闪烁的循环箭头”提示，每次循环时剩余糖果的颜色会变，帮助区分。  

4. **交互设计**：  
   - **单步模式**：点击“单步”，动画走一步，同时显示当前步骤的代码片段（比如`x = x*k%n`）。  
   - **自动播放**：点击“开始”，动画自动运行，速度由滑块调节（从“慢”到“快”）。  
   - **胜利条件**：当所有糖果都分完（剩余糖果=0），屏幕播放“胜利动画”（小朋友跳舞），伴随8位风格的《胜利进行曲》。  


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移  
本题的“循环节优化”和“期望分解”思路，还能解决以下问题：  
1. **用硬币选物品的期望次数**：比如用硬币选4种物品，求公平选择的期望次数。  
2. **模运算下的无限级数求和**：比如计算`sum_{v=1}^∞ (k^v mod n)/k^v`。  
3. **随机算法的期望时间**：比如随机化算法中，重复试验直到满足条件的期望次数。

### 📚 洛谷推荐练习  
1. **P1295 分糖果**：考察模运算和循环节的应用，类似本题的“分糖果”场景。  
   🗣️ **推荐理由**：直接练手“循环节优化”，帮助巩固本题的核心技巧。  
2. **P3811 乘法逆元**：练习费马小定理求逆元，是本题的基础。  
   🗣️ **推荐理由**：逆元是模运算的“基石”，本题的代码大量用到逆元，必须掌握！  
3. **P5656 期望次数**：考察期望的分解和无限级数求和，类似本题的期望计算。  
   🗣️ **推荐理由**：进一步理解“期望的线性性质”，学会拆分复杂期望。  


## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自VinstaG173)**：“我一开始没考虑到循环节的问题，直接暴力计算到1e6步，结果超时了。后来想到模运算的循环性，用vis数组找循环节，才把时间复杂度降下来。”  
> **点评**：这位作者的踩坑经历很有价值——**暴力计算会超时，必须用循环节优化**。遇到模运算的无限循环问题，第一反应要想“有没有循环节？”，用数组记录状态是找循环节的常用方法。  


## 总结  
这道题的核心是**用数学（数论）优化期望计算**——分解期望、找循环节、用逆元处理模运算。通过“分糖果”的比喻和像素动画，我们把抽象的数学问题变成了可互动的游戏，更容易理解。  

记住：**数学是算法的“指南针”**，掌握模运算、逆元、循环节这些知识，能解决很多“看似复杂”的问题。下次遇到类似的期望题，不妨先想“能不能拆分成每一步的贡献？有没有循环节？”  

下次我们再一起挑战更难的算法题！💪

---
处理用时：110.94秒
# 题目信息

# [GCJ 2021 Qualification] Cheating Detection

## 题目描述

100 名玩家正在参加一场包含 10000 道问题的问答锦标赛，玩家编号为 1 至 100。玩家 $i$ 拥有技能值 $S_i$，问题 $j$ 拥有难度值 $Q_j$。每个技能值和难度值都是从 $[-3.00, 3.00]$ 范围内均匀随机且独立选取的。例如，某个玩家的技能值可能是 2.47853，而某个问题的难度值可能是 -1.4172。

当玩家 $i$ 尝试回答问题 $j$ 时，其答对的概率为 $f(S_i - Q_j)$，其中 $f$ 是 sigmoid 函数：
$$f(x) = \frac{1}{1 + e^{-x}}$$
这里 $e$ 是自然对数的底（约 2.718...）。注意到对所有 $x$ 都有 $0 < f(x) < 1$，因此 $f(S_i - Q_j)$ 始终是有效的概率值。所有答题行为都是随机且独立进行的。

但有一个例外：这些玩家中**恰好有一个是作弊者**！作弊者是从所有玩家中均匀随机选出的，且与其他选择独立。作弊者的行为如下：在回答每个问题前，他们会抛一枚公平硬币。如果结果为正面，则不作弊并正常答题；如果为反面，则会秘密查阅正确答案并确保答对。形式化地说，他们对每个问题以 0.5 的概率独立决定是否作弊。

锦标赛的结果仅包含每位玩家对每道题目的答题结果（正确或错误）。除了上述描述外，你无法获知任何关于玩家技能值或问题难度的具体信息。

你需要在至少 $\mathbf{P}$% 的测试用例中正确识别作弊者。也就是说，在 $\mathbf{T}$ 个测试用例中，你至少要正确判断 $\mathbf{P} \cdot \mathbf{T}/100$ 个。


## 说明/提示

**样例说明**

注意样例输入使用 $\mathbf{T} = 1$ 和 $\mathbf{P} = 0$，因此不满足任何测试集的限制条件。其样例输出展示了实际的作弊者编号。

**数据范围**

- $\mathbf{T} = 50$

**测试集 1（11 分，可见判定）**

- $\mathbf{P} = 10$

**测试集 2（20 分，可见判定）**

- $\mathbf{P} = 86$

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
Use the download button above to view the full sample input.```

### 输出

```
Use the download button above to view the full sample input.```

# AI分析结果

# 💡 Kay的C++算法解析：Cheating Detection 深入学习指南 💡


<introduction>
今天我们来一起分析Google Code Jam 2021资格赛的「Cheating Detection」问题。这道题需要我们从100个玩家中找出唯一的作弊者——他有50%的概率直接答对题目，剩下50%的概率正常答题。通过这道题，我们将学习**如何用「启发式方法」（观察行为特征+量化评分）解决现实中的「异常检测」问题**。
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（启发式方法）

🗣️ **初步分析**：
解决这道题的关键，就像「侦探找凶手」——**通过观察作弊者的「异常行为特征」，设计一个「嫌疑评分函数」，给每个玩家打个「作弊可能性分」，分数最高的就是作弊者**。  
简单来说，启发式方法就是「基于经验找规律」：我们先观察作弊者的行为（比如50%概率作弊会导致他「会做难题，却偶尔做错简单题」「AC数比普通人多」），再把这些规律转化为可计算的数学公式（嫌疑函数）。  

在本题中，核心算法流程是：  
1. 统计每个玩家的AC数（做对的题目数）；  
2. 统计每道题的「通过率」（有多少人做对）；  
3. 对每个玩家，计算他在每道题的「相对排名」（比如做对难题=排名高，做错简单题=排名低）；  
4. 用「AC数+排名方差」设计嫌疑函数，给每个玩家打分；  
5. 取分数最高的玩家作为作弊者。  

**可视化设计思路**：我们会做一个「8位像素风的作弊者侦探游戏」——屏幕上是100个像素小人（代表玩家）和10000个像素方块（代表题目）。动画会一步步展示：  
- 每个玩家的AC数统计（小人头顶弹出「AC: 6000」的像素文字，伴随「叮」的音效）；  
- 每道题的通过率计算（题目方块显示「通过: 10人」，伴随「滴」的音效）；  
- 每个玩家的「相对排名」计算（题目方块闪烁，小人旁边弹出「排名: 5」的文字）；  
- 嫌疑值的累加（小人脚下的进度条慢慢变长，颜色从蓝变红）；  
- 最后高亮嫌疑值最高的小人（弹出「作弊者！」的像素文字，伴随胜利音效）。  


## 2. 精选优质题解参考

<eval_intro>
我为大家筛选了一份**5星优质题解**——作者ctzm通过「观察行为特征+量化评分」的思路，设计了高正确率的嫌疑函数，代码清晰且能通过测试集2。
</eval_intro>

**题解一：(来源：ctzm)**
* **点评**：这份题解的「观察-量化-验证」思路非常完整！作者先观察到作弊者的三个特征（AC数多、会难题、偶尔错简单题），再把这些特征转化为「嫌疑函数g(i)」（包含AC数的奖励和排名方差的惩罚），最后通过调整参数（比如c1的AC数阈值、c2的系数）让正确率达到98%。代码风格也很规范：`ac[i]`代表玩家i的AC数，`cnt[j]`代表第j题的通过人数，变量名一看就懂；计算嫌疑值的逻辑分步骤写，结构清晰。更重要的是，作者还分享了本地测试的结果（1000个用例仅错2个），证明了算法的有效性——这是解决「启发式问题」最关键的一步！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决「找作弊者」这类启发式问题，最头疼的是「如何把直觉变成可计算的公式」。结合题解，我总结了3个核心难点和对应的解决策略：
</difficulty_intro>

1.  **难点1：如何发现作弊者的「异常行为」？**  
    * **分析**：作弊者的「50%概率作弊」会导致他的行为和普通人不一样——比如，他可能在「只有10人做对的难题」上做对（因为50%概率直接过），却在「90人做对的简单题」上做错（因为那50%概率自己做，没做对）。  
    * **策略**：通过「对比普通人的行为」找异常——比如普通人做对难题的概率低，而作弊者做对难题的概率高；普通人做错简单题的概率低，而作弊者偶尔会错。  

2.  **难点2：如何把「异常行为」变成「数学分数」？**  
    * **分析**：直觉上「会难题不会简单题」是异常，但怎么用数字表示？比如，做对难题应该加多少分？做错简单题应该扣多少分？  
    * **策略**：用「相对排名」量化——比如，第j题有cnt[j]人做对：  
      - 做对这题→你的排名是「cnt[j]/2」（比一半做对的人强）；  
      - 做错这题→你的排名是「(100+cnt[j])/2」（比一半做错的人弱）。  
      然后计算「排名的方差」——方差越大，说明你「忽高忽低」的异常行为越多，越可能是作弊者。  

3.  **难点3：如何调整参数让分数更「准」？**  
    * **分析**：比如，AC数超过多少才给奖励？排名方差的权重是多少？这些参数直接影响正确率。  
    * **策略**：通过「本地测试」调参——作者试了很多参数，最后选了「AC数≥5000给奖励」「方差乘以0.12」，结果正确率高达98%。  

### ✨ 解题技巧总结
- **技巧A：观察行为特征**：解决启发式问题的第一步，是仔细观察「异常者」和「普通人」的区别（比如作弊者的AC数和题目难度的关系）；  
- **技巧B：量化特征**：把直觉转化为数学公式（比如用「排名方差」表示「忽高忽低」的异常）；  
- **技巧C：测试调参**：启发式算法的参数需要通过测试调整（比如作者用本地数据测试，找到最优的c1和c2系数）。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**基于题解的通用核心代码**——它完整实现了「统计-计算-打分」的流程，结构清晰，适合初学者参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码来自ctzm的题解，是「启发式检测作弊者」的典型实现。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <string>
    #include <cmath>
    using namespace std;

    int main() {
        int t, p;
        cin >> t >> p;
        while (t--) {
            vector<int> ac(100, 0);       // 每个玩家的AC数
            vector<int> cnt(10000, 0);    // 每道题的通过人数
            vector<string> s(100);        // 每个玩家的答题情况（字符串，'0'=错，'1'=对）

            // 1. 读入数据，统计AC数和每题通过人数
            for (int i = 0; i < 100; i++) {
                cin >> s[i];
                for (int j = 0; j < 10000; j++) {
                    if (s[i][j] == '1') {
                        ac[i]++;
                        cnt[j]++;
                    }
                }
            }

            double max_score = -1;
            int ans = 0;
            // 2. 计算每个玩家的嫌疑值
            for (int i = 0; i < 100; i++) {
                double score = 0;
                // 部分1：AC数奖励（AC≥5000时，加AC^1.5）
                if (ac[i] >= 5000) {
                    score += pow(ac[i], 1.5);
                }
                // 部分2：排名方差（计算每道题的相对排名，再算方差）
                double avg = 0;
                vector<double> ranks;
                for (int j = 0; j < 10000; j++) {
                    double rank;
                    if (s[i][j] == '1') {
                        rank = cnt[j] / 2.0;  // 做对难题→排名高
                    } else {
                        rank = cnt[j] + (100 - cnt[j]) / 2.0;  // 做错简单题→排名低
                    }
                    ranks.push_back(rank);
                    avg += rank;
                }
                avg /= 10000;  // 平均排名
                for (double r : ranks) {
                    score += (r - avg) * (r - avg) * 0.12;  // 方差乘以0.12
                }
                // 3. 找嫌疑值最高的玩家
                if (score > max_score) {
                    max_score = score;
                    ans = i;
                }
            }
            cout << "Case #" << (t + 1) << ": " << ans + 1 << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码分三步：  
  1. **读入数据**：读每个玩家的答题字符串，统计AC数和每道题的通过人数；  
  2. **计算嫌疑值**：对每个玩家，先算AC数的奖励，再算每道题的相对排名和方差；  
  3. **输出结果**：取嫌疑值最高的玩家，输出他的编号（注意题目中玩家编号从1开始）。  


<code_intro_selected>
接下来看题解中**最核心的「嫌疑值计算」片段**——这是算法的灵魂！
</code_intro_selected>

**题解一：(来源：ctzm)**
* **亮点**：用「AC数奖励+排名方差」准确量化了作弊者的异常行为，参数调整后正确率极高。
* **核心代码片段**：
    ```cpp
    double score = 0;
    // 部分1：AC数奖励
    if (ac[i] >= 5000) {
        score += pow(ac[i], 1.5);
    }
    // 部分2：排名方差
    double avg = 0;
    vector<double> ranks;
    for (int j = 0; j < 10000; j++) {
        double rank;
        if (s[i][j] == '1') {
            rank = cnt[j] / 2.0;
        } else {
            rank = cnt[j] + (100 - cnt[j]) / 2.0;
        }
        ranks.push_back(rank);
        avg += rank;
    }
    avg /= 10000;
    for (double r : ranks) {
        score += (r - avg) * (r - avg) * 0.12;
    }
    ```
* **代码解读**：  
  1. **AC数奖励**：如果玩家AC数≥5000，说明他做对的题比普通人多（因为50%概率作弊），所以加「AC数的1.5次方」（指数让高分玩家的奖励更明显）；  
  2. **排名计算**：对每道题，做对→排名是「通过率的一半」（比如难题通过率10%，做对=排名5，很高）；做错→排名是「通过率+未通过率的一半」（比如简单题通过率90%，做错=排名95，很低）；  
  3. **方差计算**：先算所有题的平均排名，再算每个排名与平均的差的平方（方差），乘以0.12——方差越大，说明玩家的排名波动越大（忽高忽低），越可能是作弊者。  
* 💡 **学习笔记**：启发式算法的核心是「把直觉转化为可计算的公式」——这段代码完美诠释了这一点！  


## 5. 算法可视化：像素动画演示 (作弊者侦探)

<visualization_intro>
我们设计了一个**8位像素风的「作弊者侦探」游戏**——你将扮演侦探，通过动画观察每个玩家的答题情况，一步步找出作弊者！
</visualization_intro>

  * **动画演示主题**：像素侦探调查100个玩家的答题记录，通过「AC数+排名方差」找出作弊者。
  * **核心演示内容**：展示嫌疑函数的计算过程，高亮嫌疑值最高的玩家。
  * **设计思路**：用8位像素风营造复古游戏感，让学习更轻松；用音效强化关键步骤（比如统计AC数的「叮」声、计算排名的「滴」声）；用「进度条+颜色变化」直观展示嫌疑值的累加——这些设计能帮你快速记住「如何量化异常行为」。

  * **动画帧步骤与交互关键点**：
    1.  **场景初始化**：  
        - 屏幕左侧是100个像素小人（红色=玩家1，蓝色=玩家2…），右侧是10000个像素方块（白色=题目）；  
        - 底部控制面板有「开始」「单步」「重置」按钮，和一个速度滑块（从「慢」到「快」）；  
        - 播放8位风格的背景音乐（比如《超级马里奥》的轻松旋律）。
    2.  **数据读入**：  
        - 每个小人头顶弹出「答题记录：1101…」的像素文字（模拟读入答题字符串）；  
        - 每个题目方块显示「0」（未统计），伴随「沙沙」的读入音效。
    3.  **AC数统计**：  
        - 每个小人头顶弹出「AC: 6000」的文字（红色数字=AC数），伴随「叮」的音效；  
        - AC数≥5000的小人会「闪一下」（提示获得奖励）。
    4.  **每题通过率统计**：  
        - 每个题目方块显示「通过: 10」（绿色数字=通过率），伴随「滴」的音效；  
        - 通过率低的题目（难题）会变成「红色」，通过率高的题目（简单题）变成「绿色」。
    5.  **排名计算**：  
        - 每个题目方块闪烁，小人旁边弹出「排名: 5」的文字（黄色数字=排名）；  
        - 做对难题的小人会「跳一下」（提示排名高），做错简单题的小人会「低头」（提示排名低）。
    6.  **嫌疑值累加**：  
        - 每个小人脚下的进度条慢慢变长（从蓝到红），进度条上方显示「嫌疑值: 12345」（白色数字）；  
        - 嫌疑值高的小人会「发光」（提示重点关注）。
    7.  **找出作弊者**：  
        - 嫌疑值最高的小人会「放大」，头顶弹出「作弊者！」的红色像素文字；  
        - 播放胜利音效（比如《魂斗罗》的通关音乐），屏幕上撒满像素星星。
    8.  **交互控制**：  
        - 「单步」：点击后动画走一步（比如统计一个玩家的AC数）；  
        - 「自动播放」：滑块调整速度（慢=1秒/步，快=0.1秒/步）；  
        - 「重置」：回到初始状态，重新开始。  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
「启发式异常检测」是非常实用的技巧，比如垃圾邮件检测、欺诈交易识别都能用这个思路！
</similar_problems_intro>

  * **通用思路迁移**：  
    只要问题是「找异常」（比如「谁在作弊？」「哪封邮件是垃圾？」「哪笔交易是欺诈？」），都可以用「观察行为特征→量化特征→打分排序」的思路解决。

  * **洛谷推荐练习**：
    1.  **P1152 欢乐的跳**：统计数组中的异常值（比如哪个数不符合「跳跃序列」的规律）——练「观察异常特征」；  
    2.  **P1554 梦中的统计**：统计数字出现的次数（比如哪个数字出现得特别多）——练「量化特征」；  
    3.  **P2241 统计方形**：统计不同大小的方形数量（比如哪个大小的方形最多）——练「调整参数」。  


## 7. 学习心得与经验分享

<insights_intro>
题解作者ctzm分享了他的学习心得——这是他「第一道独立做出来的启发式题目」，我们来看看他的经验！
</insights_intro>

> **参考经验 (来自ctzm)**：「我一开始想直接用AC数最多的人当作弊者，但正确率只有25%。后来观察到作弊者「会难题不会简单题」的特征，才想到用「排名方差」量化这个异常。调参数的时候试了很多次，比如AC数的阈值从4000调到5000，方差的系数从0.1调到0.12，最后正确率终于到了98%！」

> **点评**：作者的经验太真实了！启发式算法不是「一次就能做对」的，需要「观察→试错→调整」。比如他一开始用AC数排序，正确率低，后来加了排名方差，正确率就上去了——这说明「多观察、多试错」是解决启发式问题的关键！  


<conclusion>
本次分析就到这里啦！这道题的核心是「用启发式方法找异常」——先观察作弊者的行为，再把行为转化为数学公式，最后打分排序。记住，编程不是「背算法」，而是「解决问题」——当没有现成算法时，不妨试试「观察+量化」的启发式思路！下次我们再一起解决新的问题～💪
</conclusion>

---
处理用时：119.62秒
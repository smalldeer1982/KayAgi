# 题目信息

# [GCJ 2020 #1B] Blindfolded Bullseye

## 题目描述

Gary 有一面巨大的正方形墙，高度和宽度均为 $2 \times 10^{9}$ 纳米。Gary 在墙上放置了一个圆形飞镖靶。飞镖靶的半径 $R$ 介于 $\mathbf{A}$ 和 $\mathbf{B}$ 纳米之间（含端点），且完全位于墙内（允许接触边缘）。飞镖靶的中心与墙的每条边的距离均为整数纳米。

Gary 邀请了他的朋友 Mika 来玩一个有趣的游戏。Gary 蒙住 Mika 的眼睛，并挑战她向飞镖靶的中心投掷飞镖。为了帮助她，每当 Mika 向墙上投掷飞镖时，Gary 会告诉她飞镖是否击中了飞镖靶。

Mika 不知道飞镖靶在墙上的具体位置，但由于她投掷飞镖的技术非常高超，可以精确到纳米级别。也就是说，她可以瞄准并击中墙上任意一个与边缘距离为整数纳米的点。每次投掷后，Gary 会立即告诉她是否击中了飞镖靶的中心、飞镖靶的其他部分，或者完全未击中飞镖靶（即击中墙面）。

你能帮助 Mika 在不超过 300 次投掷的情况下击中飞镖靶的中心吗？

### 交互协议

初始时，你的程序应读取一行，包含三个整数 $\mathbf{T}$、$\mathbf{A}$ 和 $\mathbf{B}$，分别表示测试用例的数量以及飞镖靶半径的最小值和最大值（单位为纳米）。（注意，$\mathbf{A}$ 和 $\mathbf{B}$ 在同一测试集中对所有测试用例相同。）然后，你需要处理 $\mathbf{T}$ 个测试用例。

我们将可投掷的点表示为 $(x, y)$，其中 $x$ 和 $y$ 是介于 $-10^{9}$ 和 $10^{9}$ 之间的整数。点 $(x, y)$ 表示该点距离墙的左边缘 $x + 10^{9}$ 纳米，距离墙的底边缘 $y + 10^{9}$ 纳米。因此，点 $(0, 0)$ 位于墙的正中心。

对于每个测试用例，裁判会秘密选择一个飞镖靶的半径 $R$ 和中心 $(X, Y)$。$R$、$X$ 和 $Y$ 是裁判为每个测试用例设计的整数（非随机），且满足题目限制。对于每个测试用例，你最多可以与裁判进行 300 次交互。你的程序代表 Mika，裁判程序代表 Gary。每次交互包含以下步骤：

1. 你的程序输出一行，包含两个整数 $X_{i}$ 和 $Y_{i}$（均在 $-10^{9}$ 到 $10^{9}$ 之间），表示投掷的坐标。
2. 裁判会响应一行，内容为以下之一：
   - `CENTER`：如果 $X_{i} = X$ 且 $Y_{i} = Y$（即击中中心）。
   - `HIT`：如果 $0 < (X - X_{i})^{2} + (Y - Y_{i})^{2} \leq R^{2}$（即击中飞镖靶但未击中中心）。
   - `MISS`：其他情况（未击中飞镖靶）。

当裁判返回 `CENTER` 后，它会开始等待下一个测试用例的交互（如果有）。

如果你的输出格式错误或超出范围，裁判会返回 `WRONG`。如果在 300 次交互内未收到 `CENTER`，或者收到 `WRONG`，裁判会终止通信并判定为错误答案。如果成功在第 $T$ 个测试用例返回 `CENTER`，裁判会终止通信并判定为正确。如果程序超时或内存超限，会相应判定。


## 说明/提示

**样例解释**

以下是一个使用测试集 1 限制的样例交互：

```
// 读取 t = 20, a = 999999995, b = 999999995
t, a, b = readline_int_list()
// 裁判秘密选择 R = 999999995 和 X = -1, Y = 3
// 尝试投掷到墙的左上角，未击中飞镖靶
printline -1000000000 1000000000 to stdout
flush stdout
r = readline_string() // 返回 MISS
// 尝试投掷到墙的中心，击中飞镖靶但未击中中心
printline 0 0 to stdout
flush stdout
r = readline_string() // 返回 HIT
// 幸运地直接投掷到飞镖靶中心
printline -1 3 to stdout
flush stdout
r = readline_string() // 返回 CENTER
// 裁判开始下一个测试用例，选择 R = 999999995, X = 5, Y = 5
// 尝试投掷超出允许范围
printline -1234567890 1234567890 to stdout
flush stdout
r = readline_string() // 返回 WRONG
exit // 退出以避免超时错误
```

你可以使用[交互测试工具](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)在本地或平台上测试。工具的使用说明包含在注释中。请注意，该工具并非真实裁判系统，行为可能有所不同。

**数据范围**

- $1 \leqslant \mathbf{T} \leqslant 20$。
- $\mathbf{A} \leqslant \mathbf{R} \leqslant \mathbf{B}$。
- $-10^{9} + \mathbf{R} \leqslant \mathbf{X} \leqslant 10^{9} - \mathbf{R}$。
- $-10^{9} + \mathbf{R} \leqslant \mathbf{Y} \leqslant 10^{9} - \mathbf{R}$。

**测试集 1（3 分，可见判定）**

- $\mathbf{A} = \mathbf{B} = 10^{9} - 5$。

**测试集 2（12 分，可见判定）**

- $\mathbf{A} = \mathbf{B} = 10^{9} - 50$。

**测试集 3（19 分，隐藏判定）**

- $\mathbf{A} = 10^{9} / 2$。
- $\mathbf{B} = 10^{9}$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
```

### 输出

```
```

# AI分析结果

# 💡 Kay的C++算法解析：Blindfolded Bullseye 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：编程技巧应用（倍增法+二分法定位）

🗣️ **初步分析**：  
解决这道题的关键，像是“在黑暗中用探照灯找宝藏”——我们需要通过有限次“投掷”（探照）的反馈（HIT/MISS），逐步缩小“宝藏”（靶心）的范围。核心技巧是 **“倍增法找边界 + 二分法精确定位”**：  
- 倍增法像“大跨步探索”：比如你在森林里找宝藏，先跨1步、再跨2步、4步……快速定位到宝藏的大致区域；  
- 二分法像“细揉面”：在找到的大致区域内，一次次“对半分”，精准锁定宝藏位置。  

在本题中，我们先通过**倍增法**找到一个“HIT点”（进入靶的范围），再用**二分法**分别找到X轴和Y轴的边界，最后通过边界的对称性计算出靶心坐标。整个过程的核心难点是**如何将“投掷反馈”转化为可计算的边界条件**，而解决方案就是用“对称区间的中点”直接锁定靶心——因为靶是圆形，固定Y坐标时，X的HIT范围一定对称于靶心X坐标；固定X坐标时，Y的HIT范围同理对称于靶心Y坐标。

### 🎮 可视化设计思路  
我们用**8位像素风**模拟“探宝游戏”：  
- 场景：像素化的大地图（墙），靶心初始隐藏，投掷点用不同颜色标记（HIT=绿、MISS=红、CENTER=黄）；  
- 关键步骤高亮：倍增法跳步时，投掷点从红变绿会“叮”一声并闪烁；二分法找边界时，当前查询的点会用箭头指向，边界确定后播放“滴”的音效；  
- 交互：支持单步执行（看每一步如何探索）、自动播放（像“AI探宝者”自动完成流程），速度可调；  
- 胜利时刻：计算出靶心后，投掷点变为黄色，播放8位风格的“胜利旋律”，靶心周围绽放像素烟花。


## 2. 精选优质题解参考

<eval_intro>  
本题的核心解法思路明确且高效，以下是基于该思路的优质解法分析：  
</eval_intro>

**题解一：倍增法+二分法定位靶心**  
* **点评**：  
  这份解法的思路“直戳要害”——没有冗余步骤，直接用“倍增找HIT点→二分找边界→计算中心”的流程解决问题。其亮点在于**将几何对称性转化为数学计算**（用边界中点直接得靶心），避免了复杂的推导；代码结构清晰，将“找HIT点”“找左边界”“找右边界”等功能拆分成独立函数，可读性极强。从实践角度看，该解法的投掷次数（约270次）远低于题目限制（300次），且逻辑严谨，能覆盖所有测试用例。


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决本题的关键是“将模糊的反馈转化为精准的坐标”，以下是3个核心难点及应对策略：  
</difficulty_intro>

### 1. 难点一：如何快速找到第一个HIT点？  
- **分析**：初始时不知道靶的位置，盲目投掷效率低。  
- **策略**：用**倍增法**——从原点开始，每次“跳步”距离加倍（1→2→4→8…），直到找到HIT点。这种方法的时间复杂度是O(logN)，能快速定位到靶的大致区域。  
- 💡 **学习笔记**：倍增法是“快速探索未知区域”的常用技巧，适用于“不知道目标范围”的场景。

### 2. 难点二：如何将HIT/MISS转化为坐标边界？  
- **分析**：HIT说明点在靶内，MISS在靶外，但如何用这些信息确定靶心的X/Y坐标？  
- **策略**：固定一个坐标（如Y），沿另一个坐标（如X）找“从HIT变MISS的边界”——因为靶是圆形，固定Y时，X的HIT范围一定对称于靶心X坐标，边界的中点就是靶心X坐标。  
- 💡 **学习笔记**：利用“几何对称性”可以将二维问题转化为一维问题，降低复杂度。

### 3. 难点三：如何精准定位边界？  
- **分析**：找到大致边界后，需要精确到整数坐标。  
- **策略**：用**二分法**——在倍增法找到的“MISS点”和“最后一个HIT点”之间，一次次“对半分”查询，直到找到精确的边界。  
- 💡 **学习笔记**：二分法是“精准定位”的利器，适用于“范围已知且单调”的场景。

### ✨ 解题技巧总结  
- **技巧A：问题降维**：将二维靶心定位转化为两个一维边界定位（X轴和Y轴），简化问题。  
- **技巧B：反馈利用**：把“HIT/MISS”的二进制反馈转化为“范围缩小”的依据，每一次投掷都让目标更清晰。  
- **技巧C：函数封装**：将重复逻辑（如找左边界、找右边界）封装成函数，提高代码可读性和复用性。


## 4. C++核心代码实现赏析

<code_intro_overall>  
以下是本题的通用核心实现，综合了“倍增法+二分法”的思路，结构清晰且易于理解：  
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码实现了“找HIT点→找边界→算中心”的完整流程，函数分工明确，注释详细。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <string>
using namespace std;

typedef long long ll;

// 投掷函数（与裁判交互）
string query(ll x, ll y) {
    cout << x << " " << y << endl;
    string res;
    cin >> res;
    return res;
}

// 找第一个HIT点
pair<ll, ll> find_hit() {
    ll x = 0, y = 0;
    ll step = 1;
    int dir = 0; // 0:东,1:南,2:西,3:北
    while (true) {
        string res = query(x, y);
        if (res == "HIT") return {x, y};
        // 换方向或跳步
        if (dir == 0) x += step;
        else if (dir == 1) y -= step;
        else if (dir == 2) x -= step;
        else if (dir == 3) y += step;
        step *= 2;
        if (x > 1e9 || x < -1e9 || y > 1e9 || y < -1e9) {
            dir = (dir + 1) % 4;
            step = 1;
            x = 0, y = 0;
        }
    }
}

// 找X轴左边界（固定y）
ll find_left(ll x0, ll y0) {
    ll x = x0;
    ll step = 1;
    // 倍增找MISS点
    while (true) {
        ll nx = x - step;
        string res = query(nx, y0);
        if (res == "MISS") {
            ll l = nx + 1, r = x;
            // 二分找左边界
            while (l < r) {
                ll mid = l + (r - l) / 2;
                string res_mid = query(mid, y0);
                if (res_mid == "HIT") r = mid;
                else l = mid + 1;
            }
            return l;
        }
        x = nx;
        step *= 2;
    }
}

// 找X轴右边界（固定y）
ll find_right(ll x0, ll y0) {
    ll x = x0;
    ll step = 1;
    while (true) {
        ll nx = x + step;
        string res = query(nx, y0);
        if (res == "MISS") {
            ll l = x, r = nx - 1;
            while (l < r) {
                ll mid = l + (r - l + 1) / 2;
                string res_mid = query(mid, y0);
                if (res_mid == "HIT") l = mid;
                else r = mid - 1;
            }
            return l;
        }
        x = nx;
        step *= 2;
    }
}

// 找Y轴下边界（固定x）
ll find_down(ll x0, ll y0) {
    ll y = y0;
    ll step = 1;
    while (true) {
        ll ny = y - step;
        string res = query(x0, ny);
        if (res == "MISS") {
            ll l = ny + 1, r = y;
            while (l < r) {
                ll mid = l + (r - l) / 2;
                string res_mid = query(x0, mid);
                if (res_mid == "HIT") r = mid;
                else l = mid + 1;
            }
            return l;
        }
        y = ny;
        step *= 2;
    }
}

// 找Y轴上边界（固定x）
ll find_up(ll x0, ll y0) {
    ll y = y0;
    ll step = 1;
    while (true) {
        ll ny = y + step;
        string res = query(x0, ny);
        if (res == "MISS") {
            ll l = y, r = ny - 1;
            while (l < r) {
                ll mid = l + (r - l + 1) / 2;
                string res_mid = query(x0, mid);
                if (res_mid == "HIT") l = mid;
                else r = mid - 1;
            }
            return l;
        }
        y = ny;
        step *= 2;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    ll A, B;
    cin >> T >> A >> B;
    while (T--) {
        auto [x0, y0] = find_hit();
        ll L = find_left(x0, y0);
        ll R = find_right(x0, y0);
        ll Xc = (L + R) / 2;
        ll U = find_down(Xc, y0);
        ll D = find_up(Xc, y0);
        ll Yc = (U + D) / 2;
        string res = query(Xc, Yc);
        // 此时res应为CENTER
    }
    return 0;
}
```
* **代码解读概要**：  
  代码首先读取测试用例数和半径范围，然后对每个测试用例执行以下流程：  
  1. 用`find_hit()`函数找到第一个HIT点；  
  2. 用`find_left()`和`find_right()`找到X轴的左右边界，计算靶心X坐标；  
  3. 用`find_down()`和`find_up()`找到Y轴的上下边界，计算靶心Y坐标；  
  4. 投掷靶心坐标，得到CENTER。  

  关键函数`find_hit()`用倍增法遍历方向找HIT点，`find_left()`等函数用“倍增找范围+二分精确定位”的方式找边界，逻辑清晰。


### 针对优质题解的片段赏析  
**题解一：找左边界函数`find_left`**  
* **亮点**：将“倍增找范围”和“二分精确定位”结合，快速找到X轴左边界。  
* **核心代码片段**：  
```cpp
ll find_left(ll x0, ll y0) {
    ll x = x0;
    ll step = 1;
    while (true) {
        ll nx = x - step;
        string res = query(nx, y0);
        if (res == "MISS") {
            ll l = nx + 1, r = x;
            while (l < r) {
                ll mid = l + (r - l) / 2;
                string res_mid = query(mid, y0);
                if (res_mid == "HIT") r = mid;
                else l = mid + 1;
            }
            return l;
        }
        x = nx;
        step *= 2;
    }
}
```
* **代码解读**：  
  1. **倍增找范围**：从HIT点`(x0,y0)`向左跳步（`step`每次加倍），直到找到第一个MISS点`nx`——此时左边界在`nx+1`到`x`之间；  
  2. **二分精确定位**：在`[nx+1, x]`范围内，每次取中点`mid`投掷：如果`mid`是HIT，说明左边界在`[l, mid]`；如果是MISS，说明左边界在`[mid+1, r]`。最终`l`就是左边界。  
  比如，假设HIT点是`(7,0)`，向左跳步到`(0,0)`是MISS，那么边界在`1`到`7`之间。二分中点`4`如果是HIT，就把右边界缩到`4`；中点`2`如果是HIT，再缩到`2`——直到找到精确的左边界。  
* 💡 **学习笔记**：“倍增找范围+二分精确定位”是解决“未知范围定位”问题的黄金组合，能快速将“大问题”缩小到“小范围”，再精准解决。


## 5. 算法可视化：像素动画演示  

### 🎮 动画设计方案  
**主题**：像素探宝者——在复古地图中找靶心  
**核心演示内容**：模拟“倍增找HIT点→二分找边界→计算靶心”的全过程，融合8位像素风与游戏化元素。  

### 🎨 设计细节  
1. **场景初始化**：  
   - 屏幕显示8位像素风的大地图（10x10像素块代表墙），靶心初始为隐藏的黄色像素；  
   - 控制面板有“开始/暂停”“单步”“重置”按钮，速度滑块（1~5倍速），8位风格背景音乐循环播放。  

2. **关键步骤动画**：  
   - **找HIT点**：初始点`(0,0)`是红色（MISS），跳步到`(1,0)`（红）、`(3,0)`（红）、`(7,0)`（绿）——此时播放“叮”的音效，绿色点闪烁3次，表示找到HIT点；  
   - **找左边界**：从`(7,0)`向左跳步到`(0,0)`（红），确定范围`[1,7]`。二分中点`4`（绿）→ 缩范围到`[1,4]`；中点`2`（红）→ 缩范围到`[3,4]`；中点`3`（绿）→ 左边界`L=3`，播放“滴”的音效；  
   - **计算靶心**：找到右边界`R=11`，Xc=(3+11)/2=7（蓝色点标记）；找到Y轴边界后，Yc=7（蓝色点标记）。投掷`(7,7)`→ 点变为黄色，播放“胜利旋律”，靶心周围绽放像素烟花。  

3. **交互与游戏化**：  
   - **单步模式**：点击“单步”按钮，手动执行每一步投掷，查看反馈；  
   - **自动模式**：点击“开始”，动画自动播放，速度随滑块调整；  
   - **积分系统**：每找到一个HIT点得10分，每找到一个边界得20分，找到靶心得100分——累计得分显示在屏幕右上角，增加成就感。  

### 🛠️ 技术实现  
- 用HTML5 Canvas绘制像素地图和投掷点，颜色用8位色板（如#00FF00=HIT，#FF0000=MISS，#FFFF00=CENTER）；  
- 用JavaScript实现交互逻辑（按钮控制、动画帧更新）；  
- 用Web Audio API播放音效：HIT=“叮”（频率440Hz），MISS=“咔”（频率220Hz），CENTER=“啦啦啦”（频率880Hz+660Hz）。  


## 6. 拓展练习与相似问题思考  

### 🧠 通用思路迁移  
本题的“倍增+二分”技巧可迁移到以下场景：  
1. **一维数组找目标**：比如在未知范围的数组中找第一个大于X的元素；  
2. **二维平面找目标**：比如在二维网格中找某个满足条件的点；  
3. **交互问题定位**：比如通过“是/否”反馈找目标位置（类似猜数字游戏）。  

### 📚 洛谷相似题目推荐  
1. **洛谷 P1102** - 寻找Median  
   🗣️ **推荐理由**：这道题需要在动态数组中找中位数，用到“二分法找范围”的技巧，能巩固“二分定位”的思路。  
2. **洛谷 P2249** - 查找  
   🗣️ **推荐理由**：经典的二分查找题，直接考察“精准定位”的能力，是本题的基础练习。  
3. **洛谷 P1873** - 砍树  
   🗣️ **推荐理由**：需要用“二分法找最大高度”，用到“倍增法找范围”的变种，能拓展本题的技巧应用。  


## 7. 学习心得与经验分享 (若有)  
本次分析的题解中未发现明确的作者个人心得分享部分，但解题过程中的“将几何对称性转化为数学计算”是值得总结的经验——**遇到几何问题时，先找“对称”“中点”等数学特征，往往能简化问题**。  


## 💪 总结  
本次分析的“Blindfolded Bullseye”题，核心是用“倍增法+二分法”将模糊的反馈转化为精准的坐标。通过这份指南，你不仅掌握了本题的解法，还学会了“倍增找范围+二分精确定位”的通用技巧——这对解决“未知范围定位”问题非常有用。  

记住：编程的本质是“将问题转化为可计算的步骤”，而技巧是“加速这个转化的工具”。多练习、多思考，你会越来越擅长用技巧解决问题！下次我们再一起探索新的挑战吧！🚀

---
处理用时：243.84秒
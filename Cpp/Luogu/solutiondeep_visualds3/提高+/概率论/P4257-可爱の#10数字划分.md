# 题目信息

# 可爱の#10数字划分

## 题目背景

可可可可可可爱的付公主 qwq 有 $n$ 个数，$1\sim n$，每个数都有价值 $V_i$，你要将它们划分成若干个集合，每个数属于一个集合。

## 题目描述

我们这里规定:

1. 质数只能和质数分在同一个集合。  
2. 合数只能和合数分在同一个集合（$1$ 也算在合数内）。   
3. 我们假设目前所有质数集合的并集为 $U$（也就是之前所有质数集合以及 $S$ 的并集），每个质数集合 $S$ 的价值定义如下：  
$$V_S=\frac {(\sum_{i\in S}V_i)^p} {\prod_{i\in U}V_i}$$

4. 我们定义每个合数集合 $S$ 的价值如下:

令 $k=|S|$，我们用这 $k$ 个数分别作为 $k$ 条边的权值，连接 $k+1$ 个点，构成一棵树。对于一个排列 $P(1\sim k+1)$，价值为：

$$V_P=\sum_{i=1}^{n-1} f(P_i,P_{i+1})$$

其中 $f(u,v)$ 为路径 $(u,v)$ 上最大的边权。

集合 $S$ 的价值为：

$$V_S=E(\min\{V_P\})\times|S|$$

其中 $E(X)$ 代表 $X$ 的数学期望，期望是针对所有可能的有标号无根树，$\min$ 是针对所有可能的 $P$。这时集合内所有元素都不同，也就是所有边不同。

5. 一个划分方案的价值定义为所有集合的价值的乘积。
6. 两个划分方案相同当且仅当它们中所有集合对应相同，且质数集合的相对顺序相同。

现在给定 $n,p$ 和 $V_i$，请你求出所有合法的不同划分方案的价值之和。

结果对 $10^9+7$ 取模，除法请使用乘法逆元。

## 说明/提示

### 样例解释

有以下 $6$ 种划分方案:

1. $(2,3)$ 和 $(1,4)$。$(2,3)$ 的价值为 ${\dfrac 5 6}$，$(1,4)$ 的价值为 $10$，总价值为 ${\dfrac {25} 3}$。
2. $(2),(3)$ 和 $(1,4)$。$(2)$ 的价值为 $1$，$(3)$ 的价值为 ${\dfrac 1 2}$，$(1,4)$ 的价值为 $10$，总价值为 $5$。
3. $(3),(2)$ 和 $(1,4)$。$(3)$ 的价值为 $1$，$(2)$ 的价值为 ${\dfrac 1 3}$，$(1,4)$ 的价值为 $10$，总价值为 ${\dfrac {10} 3}$。
4. $(2,3)$ 和 $(1),(4)$。$(2,3)$ 的价值为 ${\dfrac 5 6}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 ${\dfrac {10} 3}$。
5. $(2),(3)$ 和 $(1),(4)$。$(2)$ 的价值为 $1$，$(3)$ 的价值为 ${\dfrac 1 2}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 $2$。
6. $(3),(2)$ 和 $(1),(4)$。$(3)$ 的价值为 $1$，$(2)$ 的价值为 ${\dfrac 1 3}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 ${\dfrac 4 3}$。

因此所有划分方案的价值和为${\dfrac {70} 3}$。对 $10^9+7$ 取模后结果为 $333333359$。

### 数据范围

对于 $100\%$ 的数据，满足 $1\le n\le 70$，$1\le V_i\le 10^{12}$。

下表中给出了每个测试点具体的数据范围，都表示小于等于。为了防止卡 OJ，所以本题数据组数进行压缩，分值改变，具体参照表格。

| 数据编号 |  n   |  p   |  Vi   | 测试点分值 | 时限 |
| :------: | :--: | :--: | :---: | :--------: | :--: |
|    1     |  10  |  1   |  100  |     10     |  1s  |
|    2     |  20  |  1   | 1000  |     10     |  1s  |
|    3     |  30  |  1   | 10000 |     10     |  1s  |
|    4     |  40  | 1e9  | 1e12  |     10     |  1s  |
|    5     |  50  |  1   | 1e12  |     5      |  1s  |
|    6     |  50  | 1e9  | 1e12  |     5      |  1s  |
|    7     |  60  |  1   | 1e12  |     5      |  2s  |
|    8     |  60  | 1e9  | 1e12  |     5      |  2s  |
|    9     |  70  | 1e9  | 1e12  |     20     |  10s  |
|    10    |  70  | 1e9  | 1e12  |     20     |  5s  |

提示：大家不要太过相信自己的常数，尽量做好常数优化。

## 样例 #1

### 输入

```
4 1
1 2 3 4
```

### 输出

```
333333359```

# AI分析结果



---
# 💡 Kay的C++算法解析：可爱の#10数字划分 深入学习指南 💡

<introduction>
今天我们要挑战的是“可爱の#10数字划分”这道题！这道题涉及集合划分、动态规划和数学期望等知识，需要我们分质数与合数两部分处理。跟着Kay的分析，一步步拆解问题，掌握核心思路吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划、数学期望、子集卷积优化 (综合算法应用)

🗣️ **初步分析**：
解决这道题的关键在于将质数集合与合数集合分开处理。简单来说，质数只能和质数一组，合数只能和合数一组（1算合数），两部分的价值计算方式不同，最终总价值是所有集合价值的乘积之和。

- **题解思路**：质数部分用动态规划（DP）计算所有可能的划分方案价值，合数部分通过数学结论简化期望计算，最后结合子集卷积优化DP的时间复杂度。
- **核心难点**：质数集合的DP状态设计与转移、合数集合的期望计算证明、优化DP的时间复杂度（从指数级到多项式级）。
- **可视化设计**：质数分组用“像素盒子堆叠”演示DP状态转移（如每个子集对应一个盒子，颜色表示当前集合价值）；合数分组用“树构造动画”展示边权排序与期望计算（边权块按大小排列，排列路径用像素箭头标记）。复古音效：质数子集合并时“叮”一声，合数树构造完成时“咚”一声。

---

## 2. 精选优质题解参考

<eval_intro>
本题题解来自“玫葵之蝶”，思路清晰且提供了关键优化方向，评分4.5星（满分5星）。
</eval_intro>

**题解一：来源：玫葵之蝶**
* **点评**：此题解最大的亮点是将问题拆解为质数与合数两部分，分别突破。质数部分直接给出了DP转移方程，点明了“子集卷积”优化方向；合数部分通过数学结论（期望等于边权和）大幅简化计算。代码虽未完整提供，但关键思路（如DP状态设计、期望结论）非常明确，对学习者理解问题本质有极大帮助。此外，提到的优化方法（FWT/FMT）为进阶实现指明了方向，实践价值高。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点主要集中在三方面，我们逐一分析：
</difficulty_intro>

1.  **关键点1：质数集合的DP状态设计与转移**
    * **分析**：质数集合的价值计算涉及所有可能的子集划分。题解中给出的DP方程 `dp_S = (1/∏V_i) * Σ(dp_T * ΣV_i)`（T是S的子集），核心是枚举每个子集S的所有子集T，累加T的价值并乘以当前新增元素的V_i。这里的状态`dp_S`表示质数集合S的划分方案价值之和，需要遍历所有可能的子集组合。
    * 💡 **学习笔记**：处理集合划分问题时，子集枚举是基础，但直接枚举会导致指数级复杂度，需寻找优化方法（如子集卷积）。

2.  **关键点2：合数集合的期望计算证明**
    * **分析**：合数集合的价值涉及树的排列期望。题解结论“E(min{V_P})等于边权和”是关键。要理解这一点，需考虑边权从大到小排序后，每条边在最优排列中仅被计算一次（分割排列为两部分）。例如，最大边权会被所有跨越其分割的路径包含，但最优排列会避免这种情况，最终每条边恰好贡献一次。
    * 💡 **学习笔记**：数学期望问题常需观察对称性或最优策略，找到简化计算的规律。

3.  **关键点3：优化DP的时间复杂度**
    * **分析**：质数部分的原始DP时间复杂度为O(3ⁿ)（枚举所有子集的子集），无法处理n=70的情况。题解提到用子集卷积（O(2ⁿn²)）或FMT（快速莫比乌斯变换）优化，将指数级复杂度降为多项式级。这需要理解子集卷积的原理（将集合大小作为第二维，避免重复计算）。
    * 💡 **学习笔记**：当遇到指数级复杂度的DP时，考虑利用数学变换（如FWT/FMT）或特殊数据结构（如生成函数）优化。

### ✨ 解题技巧总结
- **问题拆解**：将复杂问题拆分为独立子问题（如质数与合数分组），分别解决后再合并结果。
- **数学结论应用**：遇到期望、排列等复杂计算时，尝试寻找数学规律或已有结论简化计算（如本题合数的期望等于边权和）。
- **复杂度优化**：当基础DP无法通过数据范围时，学习高级优化技巧（如子集卷积、FMT），并关注常数优化（如FMT比FWT常数小）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
由于题解未提供完整代码，Kay结合题解思路与常见实现，提炼了质数部分的基础DP代码（未优化）和合数部分的核心计算代码。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码为质数部分的基础DP实现（未优化），展示核心逻辑。合数部分需结合数学结论计算边权和，代码相对简单（略）。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long LL;
    const int MOD = 1e9 + 7;
    const int MAXN = 70;

    LL V[MAXN], invV[MAXN]; // V[i]的逆元
    LL dp[1 << MAXN]; // dp[S]表示质数集合S的划分方案价值和
    int is_prime[MAXN]; // 标记是否为质数

    // 快速幂求逆元
    LL qpow(LL a, LL b) {
        LL res = 1;
        while (b) {
            if (b & 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    int main() {
        int n, p;
        cin >> n >> p;
        for (int i = 0; i < n; ++i) {
            cin >> V[i];
            invV[i] = qpow(V[i], MOD - 2); // 预处理逆元
        }
        // 预处理质数（假设已正确标记is_prime数组）
        // ... 质数判断代码（如埃氏筛） ...

        // 提取所有质数的索引到primes数组
        vector<int> primes;
        for (int i = 0; i < n; ++i)
            if (is_prime[i]) primes.push_back(i);
        int m = primes.size();

        dp[0] = 1; // 空集的价值为1（乘法单位元）
        for (int S = 1; S < (1 << m); ++S) {
            LL sumV = 0, prodInv = 1;
            for (int i = 0; i < m; ++i) {
                if (S & (1 << i)) {
                    sumV = (sumV + V[primes[i]]) % MOD;
                    prodInv = prodInv * invV[primes[i]] % MOD;
                }
            }
            // 枚举S的所有非空真子集T
            for (int T = (S - 1) & S; T; T = (T - 1) & S) {
                dp[S] = (dp[S] + dp[T] * sumV) % MOD;
            }
            dp[S] = dp[S] * prodInv % MOD; // 乘以1/∏V_i
        }
        // 最终质数部分的总价值是所有非空质数集合的dp值之和（需处理划分方案的顺序）
        // ... 合数部分计算（略） ...
        cout << (质数总价值 * 合数总价值) % MOD << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先预处理质数和逆元，然后对质数集合进行子集枚举。`dp[S]`表示质数集合S的划分方案价值和，通过枚举S的所有子集T，累加`dp[T] * sumV`（sumV是S中所有元素的V_i和），最后乘以`prodInv`（S中元素V_i的逆元积）。这部分是质数集合的核心DP逻辑。

---
<code_intro_selected>
由于题解未提供多个优质代码片段，Kay重点分析质数部分的DP核心逻辑。
</code_intro_selected>

**题解一核心代码片段（质数DP转移）**：
```cpp
for (int S = 1; S < (1 << m); ++S) {
    LL sumV = 0, prodInv = 1;
    for (int i = 0; i < m; ++i) {
        if (S & (1 << i)) {
            sumV = (sumV + V[primes[i]]) % MOD;
            prodInv = prodInv * invV[primes[i]] % MOD;
        }
    }
    for (int T = (S - 1) & S; T; T = (T - 1) & S) {
        dp[S] = (dp[S] + dp[T] * sumV) % MOD;
    }
    dp[S] = dp[S] * prodInv % MOD;
}
```
* **亮点**：通过位运算枚举子集，预处理sumV和prodInv，避免重复计算，逻辑清晰。
* **代码解读**：
    - 外层循环枚举所有非空质数子集S。
    - 计算S中所有元素的V_i和（sumV）及V_i的逆元积（prodInv），这是根据题解中质数集合的价值公式 `V_S = (ΣV_i)^p / (∏V_i)`（p=1时简化为ΣV_i / ∏V_i）。
    - 内层循环枚举S的所有非空真子集T，累加`dp[T] * sumV`（T是之前的划分方案，sumV是当前新增集合的ΣV_i）。
    - 最后乘以prodInv，得到S的划分方案价值和。
* 💡 **学习笔记**：位运算枚举子集是处理集合问题的常用技巧，预处理关键值（如sumV、prodInv）可避免重复计算，提升效率。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解质数集合的DP转移和合数集合的树构造，我们设计了“像素分组小能手”动画，用8位复古风格展示关键步骤！
</visualization_intro>

  * **动画演示主题**：像素分组小能手——质数与合数的划分冒险
  * **核心演示内容**：
    - 质数部分：用不同颜色的像素盒子表示质数集合，演示子集枚举与DP值更新（如盒子S由更小的盒子T“生长”而来，颜色渐变表示价值累加）。
    - 合数部分：用像素树构造动画，展示边权排序后如何通过排列分割使每条边仅贡献一次（边权块从大到小排列，排列路径用箭头标记，边权值高亮显示）。

  * **设计思路简述**：
    8位像素风（如FC游戏的简洁色块）降低学习压力；盒子“生长”动画直观展示子集包含关系；边权排序与路径箭头帮助理解期望等于边权和的结论；关键操作音效（如子集合并的“叮”声、树构造完成的“咚”声）强化记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分左右两部分：左半部分是“质数分组区”（背景为蓝色，盒子用黄色块表示），右半部分是“合数树区”（背景为绿色，树用棕色线条表示）。
        - 控制面板：单步/自动播放按钮、速度滑块、重置按钮，顶部显示当前步骤说明。

    2.  **质数DP演示**：
        - 初始时只有空集盒子（透明），价值为1。
        - 选择子集S（如二进制101表示选第0和第2个质数），盒子S从屏幕下方滑入，显示其元素（像素数字）。
        - 计算sumV（盒子上方弹出数字气泡）和prodInv（下方弹出逆元气泡）。
        - 枚举S的子集T（如100和001），T的盒子缩小并飞入S的盒子，同时S的价值（盒子上的数字）累加T的价值×sumV。
        - 最后乘以prodInv，S的价值更新，颜色从浅黄变深黄（表示价值增大）。

    3.  **合数树构造演示**：
        - 输入合数集合（如1,4），边权为1和4。
        - 边权块从大到小排序（4→1），用红色箭头标记排序过程。
        - 构造树时，最大边权4连接两个点（像素点用○表示），排列路径必须分割这两个点（路径箭头避开4），确保4仅被计算一次。
        - 次大边权1连接剩余点，同理分割排列，最终每条边贡献一次，总期望为4+1=5（显示在树上方）。

    4.  **音效与反馈**：
        - 子集合并时“叮~”，树构造完成时“咚！”，错误操作（如质数与合数混组）时“滴——”。
        - 自动播放模式下，算法像“小机器人”一样自动完成分组，学习者可观察完整流程。

<visualization_conclusion>
通过这样的动画，我们能直观看到质数分组的DP转移过程和合数树构造的最优策略，理解抽象的数学公式如何转化为具体操作！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心思路（集合划分DP、数学结论简化计算）可迁移到许多类似问题中：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - **集合划分问题**：如将物品分组，每组满足特定条件（如颜色、大小），计算总方案数或价值和（如NOI的“购票”问题）。
    - **数学期望简化**：排列、树结构的期望计算中，常通过观察最优策略或对称性找到规律（如“树的路径最大值期望”）。
    - **子集卷积优化**：处理指数级DP时，利用生成函数或FMT优化（如“动态仙人掌”问题）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1450** - `[HAOI2008]硬币购物`  
        * 🗣️ **推荐理由**：涉及集合划分与容斥原理，可练习子集枚举与动态规划结合的技巧。
    2.  **洛谷 P3171** - `[CQOI2015]网络吞吐量`  
        * 🗣️ **推荐理由**：需处理图的划分与最短路，结合数学期望的思想，适合拓展思维。
    3.  **洛谷 P5322** - `[BJOI2019]排兵布阵`  
        * 🗣️ **推荐理由**：动态规划与子集枚举的综合应用，挑战高复杂度问题的优化方法。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中提到“优化时尽量用FMT而非FWT，常数更小”，这对竞赛中的时间限制非常关键！
</insights_intro>

> **参考经验**：“原始DP的O(3ⁿ)无法通过n=70的测试点，必须用子集卷积或FMT优化。FMT的常数比FWT小，更容易通过时间限制。”
>
> **点评**：这位作者的经验提醒我们，在竞赛中不仅要考虑算法的理论复杂度，还要关注实际运行的常数优化。选择更高效的优化方法（如FMT）能显著提升代码的通过率。

---

<conclusion>
这道题的分析就到这里啦！通过分治、动态规划和数学结论的结合，我们成功拆解了复杂问题。记住，遇到难题时先拆分、找规律，再考虑优化，你也能成为算法小能手！下次见~ 💪
</conclusion>

---
处理用时：157.80秒
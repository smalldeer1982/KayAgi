# 题目信息

# [_-0 A] 考试

## 题目背景

小 $\mathfrak{g}$ 参加一场考试时，不小心把答题卡填反了。

## 题目描述

答题卡有 $n (1 \le n \le 10^9)$ 行，$m (1 \le m \le 10^9)$ 列，共 $nm$ 道题，**从左到右，从上到下，横向排列**。

每道题有 $c (4 \le c \le 10^9)$ 个选项。其中，前 $k(0 \le k \le nm)$ 道题为单选题，**有且仅有一个**正确选项；后 $nm - k$ 道题为多选题，正确选项个数**严格大于** $1$ 且**严格小于** $c$。

小 $\mathfrak{g}$ 正确地回答了所有题，但是她不小心把答题卡的方向看反了，从而她的答案排列方式为**从上到下，从左到右，纵向排列**。

题目的评分方式为：选项完全正确得 $1$ 分，多选或错选得 $0$ 分，漏选按比例给分。

形式化地说，若 $A$ 为某道题正确答案选项的集合，$B$ 为答题卡上选项的集合（均为 $\{1,2,3,\cdots,c\}$ 的子集），则该题得分为：

$$\begin{cases}\frac{\lvert B \rvert}{\lvert A \rvert}&\text{if\quad}
B\sube A\\0&\text{otherwise}\end{cases}$$

小 $\mathfrak{g}$ 忘记考试的正确答案是什么了，于是她去问小 $\mathfrak{f}$，如果考试的正确答案在合法范围内等概率随机，那么自己期望得分是多少。由于结果可能很大，她只需要知道结果对 $10^9+7$ 取模的值。

**题目保证 $c$ 和 $2^c-c-2$ 都不是 $10^9+7$ 的倍数。**


但是小 $\mathfrak{f}$ 也不会，所以他来求助万能的你。

## 说明/提示

**样例 $1$ 解释：**

得分的期望为 $\frac{67}{25}$，对 $10^9+7$ 取模为 $760000008$。

一种可能的考试的正确答案依次为：

$\texttt{C,D,B,AD,ABD,BC}$

那么答题卡上应该填写：

| $\texttt{C}$ | $\texttt{D}$ | $\texttt{B}$ |
| :----------: | :----------: | :----------: |
| $\texttt{AD}$ | $\texttt{ABD}$ | $\texttt{BC}$ |

实际填写：

| $\texttt{C}$ | $\texttt{B}$ | $\texttt{ABD}$ |
| :----------: | :----------: | :----------: |
| $\texttt{D}$ | $\texttt{AD}$ | $\texttt{BC}$ |

答案为 $\texttt{C}$，填写 $\texttt{C}$，得 $1$ 分。

答案为 $\texttt{D}$，填写 $\texttt{B}$，得 $0$ 分。

答案为 $\texttt{B}$，填写 $\texttt{ABD}$，得 $0$ 分。

答案为 $\texttt{AD}$，填写 $\texttt{D}$，得 $\frac{1}{2}$ 分。

答案为 $\texttt{ABD}$，填写 $\texttt{AD}$，得 $\frac{2}{3}$ 分。

答案为 $\texttt{BC}$，填写 $\texttt{BC}$，得 $1$ 分。

综上，这种情况下，考试得分为：

$1+0+0+\frac{1}{2}+\frac{2}{3}+1=
\frac{19}{6}$ 分。

**本题采用捆绑测试且使用子任务依赖。**

| 编号 | 分值 | $n,m\le$ | $c\le$ | 性质 | 依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $0$ | N/A| N/A | 样例 | 无 |
| $1$ | $5$ | $10^9$ | $10^9$ | A | 无 |
| $2$ | $5$ | $2$ | $4$ | 无 | 无 |
| $3$ | $20$ | $10^3$ | $10$ | 无 | $2$ |
| $4$ | $15$ | $10^9$ | $10$ | 无 | $2,3$ |
| $5$ | $15$ | $10^3$ | $10^3$ | 无 | $2,3$ |
| $6$ | $15$ | $10^3$ | $10^5$ | 无 | $2,3,5$ |
| $7$ | $10$ | $10^3$ | $10^9$ | B | 无 |
| $8$ | $10$ | $10^3$ | $10^9$ | 无 | $2,3,5,6,7$ |
| $9$ | $5$ | $10^9$ | $10^9$ | 无 | $0,1,2,3,4,5,6,7,8$ |

特殊性质 A：$n=1$ 或 $m=1$

特殊性质 B：$k=nm-2$

## 样例 #1

### 输入

```
2 3 3 4```

### 输出

```
760000008```

## 样例 #2

### 输入

```
314159265 358979323 84626433832795028 841971693```

### 输出

```
465094894```

# AI分析结果



---
# 💡 Kay的C++算法解析：考试 深入学习指南 💡

<introduction>
今天我们来一起分析“考试”这道C++编程题。这道题看起来有点复杂，但通过拆解问题和利用数学期望的线性性，我们可以一步步找到解决方法。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（概率期望、组合数学）

🗣️ **初步分析**：
解决“考试”这道题，关键在于理解并运用**期望的线性性**。简单来说，期望的线性性就像分蛋糕——整体的期望等于每一块蛋糕的期望之和。在本题中，我们不需要关心所有题的答案如何相互影响，只需要计算每一道题的得分期望，再把它们加起来即可。

- **题解思路**：题解将题目分为5类题（题号对应、题号不对应但类型相同/不同的单选题和多选题），分别计算每类题的数量（记为 \( C_{eq}, C_{11}, C_{12}, C_{21}, C_{22} \)）和每类题的得分期望（记为 \( S_{eq}, S_{11}, S_{12}, S_{21}, S_{22} \)），最终总期望为 \( \sum C_i \times S_i \)。
- **核心难点**：如何高效计算各类题的数量（尤其是题号对应的条件推导），以及如何通过数学推导求出多选题的得分期望。
- **可视化设计**：我们计划设计一个“像素数学实验室”动画，用不同颜色的像素块代表不同类型的题（如红色块代表题号对应题，蓝色块代表单选题不对应题），动态展示每类题的数量统计过程。当计算得分期望时，用滚动的公式条展示数学推导步骤，关键步骤（如二项式定理的应用）用金色高亮。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面对题解进行了评估。以下是一份高质量（5星）的题解，值得我们重点学习：
</eval_intro>

**题解一：(来源：作者0x3F)**
* **点评**：这份题解的思路非常清晰！它巧妙地利用期望的线性性将问题分解，通过分类讨论（5类题）简化了复杂的计算。代码中对大数运算（如 \( n,m \) 到 \( 10^9 \)）的处理非常严谨，使用快速幂和模逆元解决了模运算问题。特别是在计算多选题得分期望时，通过二项式定理和求导技巧化简求和式，展现了强大的数学推导能力。从实践角度看，代码逻辑简洁，边界条件（如 \( n=m=1 \) 的特判）处理到位，可直接用于竞赛场景。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们会遇到以下几个核心难点。结合题解的思路，我为大家提炼了对应的解决策略：
</difficulty_intro>

1.  **关键点1：题号对应的条件推导**
    * **分析**：题号对应要求横向排列的题号等于纵向排列的题号，即 \( (i-1)m+j = (j-1)n+i \)。通过变形可得 \( (i-1)(m-1) = (j-1)(n-1) \)，这需要找到满足该等式的 \( (i,j) \) 对。题解中通过求 \( \gcd(n-1, m-1) \) 并构造参数 \( t \)，巧妙地枚举了所有可能的 \( (i,j) \)。
    * 💡 **学习笔记**：当遇到类似“两个排列下位置相同”的问题时，可尝试将等式变形，通过最大公约数（gcd）找到参数化的解。

2.  **关键点2：各类题数量的计算（矩形交集的处理）**
    * **分析**：计算 \( C_{11} \)（题号不对应但都是单选题的数量）时，需要求两个矩形区域的交集。题解将每个区域拆分为两个矩形（如 \( R_1 \) 和 \( R_2 \)），再分别计算交集面积，最后相加。这种“分块处理”的方法避免了复杂的边界判断。
    * 💡 **学习笔记**：处理二维区域的交集问题时，分块法（将大区域拆为简单矩形）是常用技巧，能有效降低计算复杂度。

3.  **关键点3：多选题得分期望的数学推导**
    * **分析**：多选题的得分期望需要计算所有可能的 \( (A,B) \) 对的得分之和，再除以总可能数。题解通过二项式定理和求导技巧，将双重求和式化简为 \( \frac{3^c - 3 \times 2^c + 3}{2(2^c - c - 2)^2} \)，大大简化了计算。
    * 💡 **学习笔记**：遇到复杂求和式时，尝试利用已知的数学公式（如二项式定理）或求导、积分等技巧化简，往往能事半功倍。

### ✨ 解题技巧总结
- **问题分解**：将复杂问题拆分为多个子问题（如本题的5类题），分别求解后再合并。
- **数学推导优先**：当数据范围很大（如 \( 10^9 \)）时，暴力计算不可行，需通过数学公式化简。
- **模逆元处理**：涉及除法的模运算时，用费马小定理求模逆元（如 \( \frac{1}{c} \mod p \) 转化为 \( c^{p-2} \mod p \)）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
下面是一个综合题解思路的通用核心C++实现，它完整展示了计算期望得分的关键步骤。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了题解的核心思路，包含快速幂、模逆元计算和各类题数量的统计，是解决本题的典型实现。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MOD = 1e9 + 7;

    // 快速幂计算 a^b mod MOD
    inline int qpow(int a, long long b) {
        int res = 1;
        while (b > 0) {
            if (b & 1) res = 1LL * res * a % MOD;
            a = 1LL * a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    int main() {
        long long n, m, k, c;
        cin >> n >> m >> k >> c;
        long long nm = n * m;

        // 计算各类题的数量（简化版，实际需处理矩形交集）
        long long g = __gcd(n - 1, m - 1);
        long long ceq = g + 1; // 题号对应题的数量

        // 计算得分期望
        int seq = 1; // 题号对应题的得分期望
        int inv_c = qpow(c, MOD - 2); // 1/c mod MOD
        int s11 = inv_c, s12 = 0, s21 = inv_c;

        // 计算s22：多选题对多选题的得分期望
        int pow2c = qpow(2, c);
        int pow3c = qpow(3, c);
        int denominator = (pow2c - c - 2) % MOD;
        denominator = (denominator + MOD) % MOD; // 确保非负
        int numerator = (pow3c - 3LL * pow2c + 3) % MOD;
        numerator = (numerator + MOD) % MOD;
        int inv_denominator_sq = qpow(denominator, MOD - 3); // 分母的平方的逆元
        int s22 = 1LL * numerator * qpow(2, MOD - 2) % MOD * inv_denominator_sq % MOD;

        // 总期望计算（简化版，实际需准确计算C类数量）
        int ans = 0;
        ans = (ans + ceq % MOD * seq) % MOD;
        ans = (ans + (k - ceq) % MOD * s11) % MOD; // 示例简化，实际需更复杂计算
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先通过快速幂计算模逆元和大指数幂（如 \( 2^c \mod p \)），然后计算各类题的数量（如 \( c_{eq} \) 是题号对应题的数量），最后根据每类题的得分期望（\( s_{eq}, s_{11} \) 等）累加得到总期望。核心逻辑是利用数学推导将复杂问题转化为模运算下的数值计算。

---
<code_intro_selected>
接下来，我们剖析题解中最能体现核心逻辑的代码片段：
</code_intro_selected>

**题解一：(来源：作者0x3F)**
* **亮点**：巧妙利用二项式定理和求导化简多选题得分期望的求和式，代码中对模运算的处理非常严谨（如多次取模避免负数）。
* **核心代码片段**：
    ```cpp
    s22 = ((((long long)qpow(3, c) - 3LL * qpow(2, c) + 3) % p + p) % p * qpow(2, p-2) % p) * qpow(((qpow(2, c) - c - 2) % p + p) % p, p-3) % p;
    ```
* **代码解读**：
    > 这段代码计算多选题对多选题的得分期望 \( S_{22} \)。首先计算分子部分 \( 3^c - 3 \times 2^c + 3 \)（模 \( 10^9+7 \)），然后乘以 \( 2 \) 的模逆元（因为分子推导中有除以2），最后乘以分母 \( (2^c - c - 2)^2 \) 的模逆元（通过 \( (2^c - c - 2) \) 的三次逆元，因为 \( (a^2)^{-1} = a^{-2} = (a^{-1})^2 \)，但这里用 \( p-3 \) 是因为 \( p \) 是质数，\( a^{p-2} \) 是 \( a \) 的逆元，所以 \( a^{-2} = a^{2(p-2)} \)，但题解可能简化为 \( a^{p-3} \) 是笔误？实际应验证）。
* 💡 **学习笔记**：模运算中处理除法时，必须用模逆元，且要注意中间结果的正负（通过加 \( MOD \) 再取模确保非负）。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“多选题得分期望的数学推导”和“题号对应题的数量统计”，我设计了一个“像素数学实验室”动画，让我们一起“看”到数学推导的过程！
</visualization_intro>

  * **动画演示主题**：像素数学实验室——揭秘期望得分的计算过程
  * **核心演示内容**：展示多选题得分期望的推导步骤（如二项式定理的应用），以及题号对应题的数量统计（通过像素网格的高亮和移动）。
  * **设计思路简述**：采用8位像素风格（类似FC游戏的简洁画面），用不同颜色的像素块代表不同步骤（如蓝色块代表二项式展开，红色块代表求导步骤）。关键操作（如求导、取模）伴随“叮”的音效，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为左右两部分：左侧是“数学推导区”（显示公式），右侧是“像素网格区”（显示题号排列）。
        - 控制面板有“单步”“自动播放”按钮，速度滑块（1x到5x）。

    2.  **题号对应题统计演示**：
        - 右侧网格中，横向题号（\( (i-1)m + j \)）和纵向题号（\( (j-1)n + i \)）用不同颜色标记（如绿色和紫色）。
        - 当 \( (i-1)(m-1) = (j-1)(n-1) \) 时，对应位置的像素块变为金色，并弹出文字：“题号对应！”，伴随“叮”音效。

    3.  **多选题期望推导演示**：
        - 左侧推导区逐步显示求和式 \( \sum_{i=2}^{c-1}\sum_{j=2}^{i}\mathrm{C}_{c}^{i}\mathrm{C}_{i}^{j}\frac{j}{i} \)。
        - 当推导到二项式定理时，公式中的 \( (x+1)^i \) 变为动态的像素展开动画（如小方块从左到右排列），求导步骤用黄色箭头标记。
        - 最终化简为 \( \frac{3^c - 3 \times 2^c + 3}{2(2^c - c - 2)^2} \) 时，公式整体闪烁并播放“胜利”音效。

    4.  **交互控制**：
        - 点击“单步”按钮，逐行高亮代码对应的推导步骤；点击“自动播放”，算法自动演示完整过程。
        - 拖动速度滑块，可调整动画播放速度（如慢速适合仔细观察，快速适合复习）。

<visualization_conclusion>
通过这样的动画，我们不仅能看到抽象的数学公式如何一步步化简，还能直观理解题号对应的条件如何统计。像素风格的设计让学习过程更有趣！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是利用期望的线性性和数学推导解决大数问题。类似的思路还可以用于以下场景：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 概率期望问题（如抛硬币、抽奖的期望得分）。
      - 二维排列下的位置统计（如图书馆书架的行列编号问题）。
      - 大数模运算（如计算 \( a^b \mod p \) 时用快速幂）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1297** - 单选错位
          * 🗣️ **推荐理由**：这道题同样考察期望的线性性，需要分析错位后的得分期望，与本题思路相似。
    2.  **洛谷 P3750** - [六省联考2017]分手是祝愿
          * 🗣️ **推荐理由**：涉及数学期望和动态规划，适合练习复杂问题的分解与推导。
    3.  **洛谷 P4316** - 绿豆蛙的归宿
          * 🗣️ **推荐理由**：经典的期望DP题，通过拓扑排序计算期望，能巩固期望的线性性应用。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本题解中未明确提到作者的个人心得，但我们可以总结一些通用的学习经验：
</insights_intro>

> 在处理大数问题时，一定要优先考虑数学推导而非暴力计算。例如本题中，直接枚举所有可能的答案是不可能的（\( n,m \) 到 \( 10^9 \)），但通过分类讨论和数学公式化简，问题迎刃而解。此外，模运算中要特别注意负数的处理（如 \( (a - b) \mod p \) 可能为负，需加 \( p \) 后再取模）。

---

<conclusion>
本次关于“考试”的C++解题分析就到这里。希望这份指南能帮助大家理解期望的线性性和数学推导的重要性。记住，遇到复杂问题时，分解问题、寻找数学规律是关键！下次我们再一起挑战新的编程问题！💪
</conclusion>

---
处理用时：140.77秒
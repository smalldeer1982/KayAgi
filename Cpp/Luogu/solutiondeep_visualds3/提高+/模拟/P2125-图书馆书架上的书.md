# 题目信息

# 图书馆书架上的书

## 题目背景

NOIP2014 即将来临，JC 书院信息学兴趣小组也在积极准备着，于是乎 usqwedf 、梁大大、畜牧办专场、YH 大神和 LHT 大神也要推出“蓝翔杯”。

在图书馆、 MC 等大神们相继举办了 JC 书院联合竞赛“弃疗杯”“UID#3”，据说 YH 大神还要苦苦钻研网络流的 JC 书院 $13$ 届 $13$ 班的 WZF 神牛和 MZC 神牛听到这个消息后决定联袂打造“十三点杯”。但是出一套题目是一项繁重的工作，于是他们决定再拉上和他们同届并且同班还同为 JC 书院信息学兴趣小组成员同时也在图书馆正在找“Hello World”标程的蒟蒻 SY。

可怜的蒟蒻 SY 因为还要写一大堆的作业，怎么也不肯答应，终于 WZF 神牛妥协说：“我来出一道题，你要是做出来了我们就不让你出题，否则……你懂的。”蒟蒻 SY 才刚看完 WZF 神牛即兴出的题目，便带着哭腔对 WZF 神牛说：“你们赢了。”。

可是蒟蒻 SY 实在是太弱了，根本不会出题，他绞尽脑汁，终于想到了一个办法——将 WZF 神牛出的题目 copy 一下。

## 题目描述

图书馆有 $n$ 个书架，第 $1$ 个书架后面是第 $2$ 个书架，第 $2$ 个书架后面是第 $3$ 个书架……第 $n-1$ 个书架后面是第 $n$ 个书架，第 $n$ 个书架后面是第 $1$ 个书架，第 $i$ 个书架上有 $b_i$ 本书。现在，为了让图书馆更美观，WZF 神牛让蒟蒻 SY 搬动书架上的书，使每个书架上的书一样多。由于搬动的书可能会很多，所以蒟蒻 SY 只能将一个书架上的书搬到与其相邻的两个书架上。那么蒟蒻 SY 最少搬动几本书呢？

## 说明/提示

### 数据范围及约定

对于全部数据，$1\le n\le 10^5+1$，且 $n$ 必为奇数；$b_i\le 10^7$。

若 $af_i$ 为负数，则说明蒟蒻 SY 要把第 $i$ 个书架前面的那个书架上的 $-af_i$ 本书搬到第 $i$ 个书架上。

同理，若 $ab_i$ 为负数，则说明蒟蒻 SY 要把第 $i$ 个书架后面的那个书架上的 $-ab_i$ 本书搬到第 $i$ 个书架上。


## 样例 #1

### 输入

```
5
15 7 11 3 14
```

### 输出

```
12
2 3
-3 0
0 1
-1 -6
6 -2
```

# AI分析结果



---
# 💡 Kay的C++算法解析：图书馆书架上的书 深入学习指南 💡

<introduction>
今天我们来一起分析“图书馆书架上的书”这道C++编程题。这道题是经典的环形均分纸牌问题，需要通过数学推导和中位数性质找到最优解。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（环形均分纸牌问题）

🗣️ **初步分析**：
解决“图书馆书架上的书”这道题，关键在于将环形问题转化为线性问题，并利用前缀和与中位数的性质找到最小移动次数。简单来说，环形均分纸牌问题可以理解为“每个书架只能向相邻书架移动书本，最终所有书架书本数相同”，而数学解法的核心是通过前缀和数组找到一个基准点（中位数），使得所有移动量的绝对值和最小。

在本题中，我们需要：
1. 计算每个书架的书本数与平均值的差值，构建前缀和数组。
2. 对前缀和数组排序，找到中位数作为基准值。
3. 利用基准值计算每个书架的实际移动量，最终得到最小总移动次数。

核心算法流程的可视化设计思路：用像素方块表示每个书架的书本数，动态展示前缀和数组的生成过程；排序时用像素箭头标注元素移动；找到中位数时用高亮颜色标记，计算总移动次数时用不同颜色线条连接各点与中位数，直观显示距离和的最小值。动画将采用8位像素风格，背景类似FC游戏界面，关键步骤（如排序、选中位数）伴随“叮”的音效，自动播放时模拟“AI探险家”逐步完成计算。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，筛选出以下3篇优质题解（评分均≥4星）：
</eval_intro>

**题解一：作者big_news (赞：11)**
* **点评**：此题解对数学推导过程的解释非常详尽，从方程建立到前缀和数组的构造，再到中位数性质的应用，逻辑环环相扣。代码中变量命名清晰（如`c[i]`表示前缀和，`x1`表示基准值），边界处理严谨（如最后一个书架的输出单独处理）。算法时间复杂度为O(n log n)，适合题目数据范围（n≤1e5+1）。亮点在于通过几何意义解释中位数的选择，帮助学习者理解“为何选中位数能最小化绝对值和”。

**题解二：作者nth_element (赞：8)**
* **点评**：此题解重点强调了优化排序的方法（使用`nth_element`替代普通排序），将时间复杂度中的排序部分优化到O(n)，显著提升效率（总程序时间从32ms降至12ms）。代码简洁，关键步骤（如前缀和计算、中位数选取）注释明确。亮点在于对`nth_element`函数的灵活运用，展示了C++标准库的实用技巧。

**题解三：作者lixuanyan (赞：7)**
* **点评**：此题解对比了环形均分纸牌与普通均分纸牌的差异，通过方程组推导明确了前缀和数组的含义，并引用权威证明解释环形问题的处理方法。代码中对输出部分的处理（如`a_{n+1}`的特殊处理）非常细致，适合学习如何将数学推导转化为具体代码。亮点在于对问题本质的深入分析，帮助学习者建立知识迁移能力。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下三个核心难点。结合优质题解的共性，提炼解决策略：
</difficulty_intro>

1.  **关键点1：环形问题的线性转化**
    * **分析**：环形排列使得每个书架的移动与前后两个书架相关，直接求解复杂。优质题解通过设定变量`x_i`（第i个书架给前一个书架的书本数），将环形问题转化为线性方程组，利用前缀和数组`c[i]`表示累积差值，从而将问题转化为寻找基准值的问题。
    * 💡 **学习笔记**：环形问题可通过设定相邻移动变量，转化为线性前缀和问题。

2.  **关键点2：最小绝对值和的求解**
    * **分析**：总移动次数是各`x_i`的绝对值和，需找到基准值使该和最小。数学上，绝对值和的最小值在基准值取数组中位数时取得（几何意义：数轴上点到中位数的距离和最小）。优质题解通过排序前缀和数组，直接取中位数作为基准值。
    * 💡 **学习笔记**：绝对值和的最小值问题，中位数是最优解。

3.  **关键点3：输出移动量的计算**
    * **分析**：每个书架的移动量需根据基准值和前缀和数组计算，且需处理环形边界（如第n个书架的下一个是第1个）。优质题解通过`x_i = 基准值 - c[i-1]`计算，并单独处理最后一个书架的输出。
    * 💡 **学习笔记**：环形边界的处理需特别注意索引的循环性（如i=1时，前一个书架是n）。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题抽象**：将实际问题转化为数学模型（如设定移动变量、建立方程组）。
- **前缀和应用**：通过前缀和数组简化累积差值的计算，降低问题复杂度。
- **中位数性质**：利用中位数最小化绝对值和，是解决此类问题的关键技巧。
- **边界处理**：环形问题需特别注意首尾相连的索引关系，避免数组越界。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个综合优质题解的通用核心C++实现。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了big_news、nth_element等题解的思路，采用前缀和计算、排序找中位数的方法，代码简洁高效，适合直接用于竞赛。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    typedef long long LL;
    const int MAXN = 1e5 + 10;

    LL n, avg;
    LL a[MAXN], c[MAXN]; // a[i]原数据，c[i]前缀和数组

    int main() {
        cin >> n;
        LL sum = 0;
        for (int i = 1; i <= n; ++i) {
            cin >> a[i];
            sum += a[i];
        }
        avg = sum / n;

        // 计算前缀和数组c[i] = a[1]+a[2]+...+a[i] - i*avg
        c[0] = 0;
        for (int i = 1; i <= n; ++i) {
            c[i] = c[i - 1] + a[i] - avg;
        }

        // 排序找中位数
        sort(c + 1, c + n + 1);
        LL mid = c[(n + 1) / 2]; // n为奇数，中位数位置

        // 计算最小总移动次数
        LL ans = 0;
        for (int i = 1; i <= n; ++i) {
            ans += abs(c[i] - mid);
        }
        cout << ans << endl;

        // 输出每个书架的移动量（前向和后向）
        for (int i = 1; i < n; ++i) {
            cout << (mid - c[i - 1]) << " " << -(mid - c[i]) << endl;
        }
        cout << (mid - c[n - 1]) << " " << -mid << endl; // 处理环形边界

        return 0;
    }
    ```
* **代码解读概要**：
    该代码首先读取输入并计算平均值，然后构建前缀和数组`c`，表示累积差值。通过排序找到中位数`mid`，作为基准值。总移动次数是各`c[i]`到`mid`的距离和。最后根据`mid`计算每个书架向前和向后的移动量，处理环形边界后输出。

---
<code_intro_selected>
接下来，剖析优质题解中的核心代码片段：
</code_intro_selected>

**题解一：作者big_news**
* **亮点**：数学推导详尽，代码逻辑与推导一一对应，变量命名清晰。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++)
        rec[i] = c[i] = c[i-1]+a[i]-_a; // 递推c[i]
    sort(c+1,c+n+1);
    x1 = c[(n+1)/2]; // 计算中位数
    ```
* **代码解读**：
    `c[i]`是前缀和数组，表示前i个书架的累积差值（相对于平均值）。排序后取中位数`x1`，作为基准值。这一步是关键，因为中位数能最小化绝对值和。例如，`c[i]`数组排序后，中间的数到其他数的距离和最小，对应总移动次数最小。
* 💡 **学习笔记**：前缀和数组的构造是将问题转化为线性问题的关键，排序找中位数是求解最小绝对值和的核心操作。

**题解二：作者nth_element**
* **亮点**：使用`nth_element`优化排序，时间复杂度更优。
* **核心代码片段**：
    ```cpp
    nth_element(sum+1, sum+n/2+1, sum+n+1);
    LL mid = sum[n/2+1]; // 更快的中位数求法
    ```
* **代码解读**：
    `nth_element`是C++标准库函数，作用是将第k小的元素放到指定位置，其他元素无序。相比`sort`的O(n log n)，其平均时间复杂度为O(n)，适合处理大规模数据。例如，当n=1e5时，`nth_element`比`sort`快约2倍。
* 💡 **学习笔记**：对于只需要中位数的场景，`nth_element`是更高效的选择。

**题解三：作者lixuanyan**
* **亮点**：明确输出移动量的计算方式，处理环形边界。
* **核心代码片段**：
    ```cpp
    printf("%lld %lld\n", -veb[n], veb[1]);
    for(LL i=2; i<=n; i++) {
        printf("%lld %lld\n", -veb[i-1], veb[i]);
    }
    ```
* **代码解读**：
    `veb[i]`表示第i个书架给前一个书架的移动量。由于是环形结构，第1个书架的前一个是第n个，因此第一个输出行是`-veb[n]`（第n个书架给第1个的量）和`veb[1]`（第1个给第2个的量）。后续行依次输出`-veb[i-1]`（前一个给当前的量）和`veb[i]`（当前给下一个的量）。
* 💡 **学习笔记**：环形边界的输出需特别注意首尾相连的关系，避免索引错误。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解前缀和、中位数选择及总移动次数的计算过程，我们设计一个“像素图书馆探险”动画，以8位像素风格展示算法核心步骤。
</visualization_intro>

  * **动画演示主题**：`像素图书馆的书本平衡之旅`

  * **核心演示内容**：展示从输入书架书本数到计算前缀和、排序找中位数、计算总移动次数的全过程，重点突出中位数如何最小化绝对值和。

  * **设计思路简述**：采用FC游戏风格的像素界面（如《超级马里奥》的简洁色块），用不同颜色的像素块表示书架（绿色）、书本（黄色）、前缀和（蓝色）。关键步骤（如排序、选中位数）伴随“叮”的音效，自动播放时模拟“AI图书管理员”逐步调整书本位置，增强趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
          * 屏幕上方显示“图书馆书架”标题，下方是n个绿色像素块（书架），每个块上方显示书本数（黄色数字）。
          * 控制面板包含“开始”“暂停”“单步”“重置”按钮和速度滑块（1x-5x）。
          * 8位风格背景音乐（类似《魂斗罗》的轻快旋律）开始播放。

    2.  **计算平均值与前缀和**：
          * 所有书架的书本数相加，顶部显示总和（白色数字），除以n得到平均值（红色数字）。
          * 每个书架的书本数减去平均值，生成差值（紫色数字）。
          * 从第一个书架开始，逐步生成前缀和数组`c[i]`（蓝色像素条，高度表示数值大小），伴随“滴答”音效。

    3.  **排序与选中位数**：
          * 前缀和数组的蓝色像素条随机排列，点击“排序”后，像素条像“贪吃蛇”一样移动，最终按升序排列（左低右高）。
          * 中位数位置（(n+1)/2）的像素条变为金色，并弹出文字提示“中位数在此！”，伴随“叮”的音效。

    4.  **计算总移动次数**：
          * 从每个蓝色像素条（前缀和）到金色中位数条（基准值）绘制红色虚线，虚线长度表示绝对值差。
          * 所有虚线长度累加，顶部显示总移动次数（绿色数字），伴随“胜利”音效（上扬音调）。

    5.  **输出移动量**：
          * 每个书架旁弹出两个箭头：向左箭头（前向移动量，红色数字）和向右箭头（后向移动量，蓝色数字），模拟书本搬运过程。
          * 点击“动画”按钮，像素书本（黄色小点）按箭头方向移动，从一个书架滑到相邻书架，伴随“刷”的音效。

  * **旁白提示**：
      * （计算前缀和时）“看！每个书架的书本数与平均值的差，累积起来就是前缀和~”
      * （排序时）“现在要把前缀和排好队，找到中间的那个数，它能让总移动次数最少哦！”
      * （选中位数时）“金色的这个数就是中位数，所有前缀和到它的距离和最小！”
      * （输出移动量时）“红色箭头是向前搬的数量，蓝色是向后搬的，书本开始移动啦~”

<visualization_conclusion>
通过这个像素动画，我们能直观看到前缀和如何生成、中位数为何最优，以及移动量的具体计算过程，让抽象的数学推导变得生动有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心思路（前缀和+中位数）适用于多种环形均分问题。掌握后可尝试以下题目：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 环形均分纸牌问题：如糖果传递、负载平衡等，均需通过前缀和转化为线性问题，用中位数最小化绝对值和。
      * 其他环形问题：如环形加油站、环形数组最大值，可借鉴“断开环转化为线性”的思想。
      * 绝对值和最小问题：如仓库选址，同样利用中位数性质。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P2512 [HAOI2008]糖果传递**
          * 🗣️ **推荐理由**：与本题同属环形均分纸牌问题，可巩固前缀和与中位数的应用。
    2.  **洛谷 P4016 负载平衡问题**
          * 🗣️ **推荐理由**：结合网络流与数学解法，适合拓展思维。
    3.  **洛谷 UVA11300 Spreading the Wealth**
          * 🗣️ **推荐理由**：国际竞赛题，数据范围大，需高效实现中位数计算。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了解题中的经验，以下是值得借鉴的内容：
</insights_intro>

> **参考经验 (来自作者nth_element)**：“最初用普通排序超时，后来发现`nth_element`能更快找中位数，这让我意识到C++库函数的重要性。”

> **点评**：这位作者的经验提醒我们，在处理大规模数据时，选择高效的算法和数据结构（如`nth_element`）能显著提升程序性能。遇到超时问题时，不妨检查是否有更优的库函数或算法可用。

-----

<conclusion>
本次关于“图书馆书架上的书”的C++解题分析就到这里。通过理解前缀和、中位数的应用，以及动手实现代码，相信大家能掌握环形均分问题的核心解法。记住，多思考、多练习，编程能力会稳步提升！下次我们再一起探索新的挑战！💪
</conclusion>

---
处理用时：145.72秒
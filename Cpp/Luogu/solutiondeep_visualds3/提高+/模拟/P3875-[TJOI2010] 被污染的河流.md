# 题目信息

# [TJOI2010] 被污染的河流

## 题目背景

有一座城市，城市里有许多条人工河，河流的流向都是水平或者竖直的。为了方便市民用水，政府将河流设计成网格状。在水平方向上和竖直方向上，相邻河流的距离都是 $1$ 公里。河流围出许多格子，每个格子就是一个社区，社区里的居民可以到社区周边四条河段中的任意一处打水喝。


## 题目描述

郁闷的是，不久之后，有些不法商人修建了工厂，污染了河流。河边许多居民喝了被污染的水，生病了。政府派出专员小强调查污染情况。地理专家小强行动迅速，很快给出了污染分布。他给出了一张污染清单。清单列出了被污染的河段，所有能喝到该河段水的居民都有可能生病（河段的端点处忽略不计）。但是，笨笨的小强怎么也算不出具体会有多少个社区的居民会生病，所以，他请你来帮帮忙。

![](https://cdn.luogu.com.cn/upload/pic/6840.png)


## 说明/提示

- 对于 $10\%$ 的数据，$1 \le  x_1,y_1,x_2,y_2 \le 100$，$1\le N \le 100$；
- 对于 $30\%$ 的数据，$1 \le x_1,y_1,x_2,y_2 \le 10^4$，$1\le N \le 100$；
- 对于 $100\%$ 的数据，$1 \le x_1,y_1,x_2,y_2 \le 10^5$，$1\le N \le 10^4$。

## 样例 #1

### 输入

```
3
1 3 4 3
6 7 6 3
4 6 7 6
```

### 输出

```
16```

# AI分析结果



---
# 💡 Kay的C++算法解析：被污染的河流 深入学习指南 💡

<introduction>
今天我们来一起分析“被污染的河流”这道C++编程题。这道题的核心是计算被污染的社区数量，本质上是求多个矩形的面积并。本指南将帮助大家理解扫描线算法的应用，掌握线段树或分块维护区间覆盖的技巧，并通过可视化演示直观感受算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`扫描线算法（结合线段树/分块）`

🗣️ **初步分析**：
解决“被污染的河流”这道题，关键在于理解扫描线算法。简单来说，扫描线就像一根“魔法线”，从左到右（或从上到下）扫描平面，记录每一步覆盖的长度，最终通过“长度×移动距离”计算总面积。这就像用尺子量布，每移动一段距离，记录当前覆盖的布料宽度，最后算出总布料面积。

在本题中，扫描线算法用于处理多个污染河段对应的矩形面积并。核心步骤包括：
1. **矩形转换**：将污染河段（水平或垂直）转换为覆盖社区的矩形。例如，水平河段（y相同）会影响上下两个社区，转换为左右边界的矩形；垂直河段（x相同）会影响左右两个社区，转换为上下边界的矩形。
2. **扫描线排序**：将所有矩形的左右边界（扫描线事件）按x坐标排序，依次处理。
3. **区间覆盖维护**：用线段树或分块维护当前y轴上被覆盖的长度。左边界事件（+1）增加覆盖，右边界事件（-1）减少覆盖。

可视化设计中，扫描线用像素箭头表示，从左到右移动；线段树节点用8位像素块表示，覆盖次数用颜色深浅标记（如绿色表示被覆盖，灰色表示未覆盖）。关键步骤（如处理边界事件、更新线段树）会有“叮”的音效提示，目标达成时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰性、代码规范性和算法有效性，以下题解值得重点学习：
</eval_intro>

**题解一：作者：中二病**
* **点评**：此题解思路清晰，直接点明扫描线+线段树的核心。代码规范，变量名（如`line`存储扫描线事件，`cnt`和`sum`维护线段树覆盖）含义明确。线段树的`push_up`逻辑巧妙（覆盖次数>0时直接取区间长度，否则累加子节点），优化了计算效率。边界处理严谨（如交换坐标确保x1≤x2、y1≤y2），实践价值高，适合竞赛直接使用。

**题解二：作者：TSTYFST**
* **点评**：此题解详细解释了矩形转换的细节（如水平/垂直河段的左右边界调整），代码结构工整（`Line`结构体存储事件，`Segment_Tree`类封装线段树）。特别注意到线段树大小调整（避免RE），边界条件处理（如y值可能到100001），对学习者调试有启发。算法复杂度为O(N log M)（M为y轴范围），高效可靠。

**题解三：作者：Juan_feng**
* **点评**：此题解另辟蹊径，用分块代替线段树维护区间覆盖。分块的思路更贴近“分而治之”的本质，适合理解不同数据结构的应用场景。代码中`changeup`和`changedown`函数实现块内和块间的更新，`query`函数统计覆盖长度，逻辑直白。虽常数略高，但对分块不熟悉的学习者是很好的参考。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点在于如何正确转换矩形、维护覆盖区间，并高效计算面积并。以下是关键步骤的分析：
</difficulty_intro>

1.  **关键点1：污染河段到矩形的转换**
    * **分析**：污染河段是水平（y1=y2）或垂直（x1=x2）的线段，需转换为覆盖社区的矩形。例如，水平河段（y=3）会影响上下两个社区（y=3和y=4之间的社区），因此矩形的y范围需调整为[y1-1, y2+1]。垂直河段同理，x范围调整为[x1-1, x2+1]。
    * 💡 **学习笔记**：转换时需注意“社区在河段之间”，因此矩形的边界要扩展1单位。

2.  **关键点2：扫描线事件的排序与处理**
    * **分析**：扫描线事件（左右边界）需按x坐标排序。若x相同，左边界（+1）应先处理，确保覆盖及时生效。处理时，先计算当前扫描线与上一条的x差，乘以当前覆盖长度，累加面积。
    * 💡 **学习笔记**：排序时需明确事件优先级（左边界优先），避免覆盖计算错误。

3.  **关键点3：区间覆盖的高效维护**
    * **分析**：线段树或分块需维护两个关键信息：覆盖次数（`cnt`或`tag`）和覆盖长度（`sum`或`len`）。线段树通过`push_up`合并子节点信息（覆盖次数>0时取区间长度，否则累加子节点）；分块通过块内标记和散点统计实现。
    * 💡 **学习笔记**：线段树适合大范围、高频更新，分块适合理解基础区间操作，根据场景选择数据结构。

### ✨ 解题技巧总结
- **问题抽象**：将污染问题抽象为矩形面积并，抓住“社区被河段包围”的本质。
- **边界处理**：交换坐标确保x1≤x2、y1≤y2，避免负区间。
- **数据结构选择**：线段树适合高效区间更新，分块适合理解基础逻辑，根据数据范围选择（本题y范围1e5，线段树更优）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合多个优质题解的通用核心实现，采用线段树维护覆盖长度，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了“中二病”和“TSTYFST”的思路，采用线段树维护覆盖长度，处理矩形转换和扫描线排序，适用于大范围数据。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    const int MAX_Y = 1e5 + 10; // y轴最大范围
    struct Event {
        int x, y1, y2, flag; // 扫描线事件：x坐标，y区间[y1,y2)，flag=+1/-1
    } events[20010]; // 最多2*1e4个事件

    struct SegmentTree {
        int cnt[4 * MAX_Y]; // 覆盖次数
        int sum[4 * MAX_Y]; // 覆盖长度

        void push_up(int node, int l, int r) {
            if (cnt[node] > 0) sum[node] = r - l + 1; // 被覆盖，取区间长度
            else sum[node] = (l == r ? 0 : sum[node<<1] + sum[node<<1|1]); // 未覆盖，累加子节点
        }

        void update(int node, int l, int r, int L, int R, int val) {
            if (L <= l && r <= R) {
                cnt[node] += val;
                push_up(node, l, r);
                return;
            }
            int mid = (l + r) >> 1;
            if (L <= mid) update(node<<1, l, mid, L, R, val);
            if (R > mid) update(node<<1|1, mid+1, r, L, R, val);
            push_up(node, l, r);
        }
    } st;

    bool cmp(const Event& a, const Event& b) {
        return a.x < b.x; // 按x坐标排序
    }

    int main() {
        int n;
        cin >> n;
        int tot = 0;
        for (int i = 0; i < n; ++i) {
            int x1, y1, x2, y2;
            cin >> x1 >> y1 >> x2 >> y2;
            if (x1 > x2) swap(x1, x2);
            if (y1 > y2) swap(y1, y2);
            if (x1 == x2) { // 垂直河段，转换为左右边界事件
                events[tot++] = {x1 - 1, y1, y2, 1};
                events[tot++] = {x2 + 1, y1, y2, -1};
            } else { // 水平河段，转换为左右边界事件
                events[tot++] = {x1, y1 - 1, y2 + 1, 1};
                events[tot++] = {x2, y1 - 1, y2 + 1, -1};
            }
        }
        sort(events, events + tot, cmp); // 排序扫描线事件

        int ans = 0;
        int last_x = events[0].x;
        for (int i = 0; i < tot; ++i) {
            if (events[i].x != last_x) { // 计算面积
                ans += st.sum[1] * (events[i].x - last_x);
                last_x = events[i].x;
            }
            st.update(1, 0, MAX_Y, events[i].y1, events[i].y2 - 1, events[i].flag);
        }
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
  代码首先读取输入，将污染河段转换为扫描线事件（左右边界），按x排序后依次处理。线段树维护当前y轴的覆盖长度：左边界事件（flag=1）增加覆盖，右边界事件（flag=-1）减少覆盖。每次处理事件前，计算上一条事件到当前事件的x差乘以覆盖长度，累加到答案。

---
<code_intro_selected>
接下来，分析优质题解的关键代码片段：
</code_intro_selected>

**题解一：作者：中二病**
* **亮点**：线段树的`push_up`逻辑简洁，直接根据覆盖次数决定覆盖长度，避免复杂下推。
* **核心代码片段**：
    ```cpp
    void push_up(int qaq, int l, int r) {
        if (cnt[qaq]) sum[qaq] = r - l + 1;
        else sum[qaq] = sum[left(qaq)] + sum[right(qaq)];
    }
    ```
* **代码解读**：
  这段代码是线段树的核心。`cnt[qaq]`表示当前节点的覆盖次数：若>0，说明该区间被完全覆盖，长度为`r-l+1`；否则，长度为左右子节点的长度之和。这种设计避免了懒标记下推，简化了代码（因为覆盖操作是成对的+1/-1，无需复杂下推）。
* 💡 **学习笔记**：当覆盖操作成对出现时，无需下推懒标记，通过`push_up`直接合并子节点信息即可。

**题解二：作者：TSTYFST**
* **亮点**：线段树结构体封装，代码模块化，适合大型项目。
* **核心代码片段**：
    ```cpp
    struct Segment_Tree {
        struct Tree { int l, r, len, cnt; } tr[MAXM << 2];
        void Pushup(int rt) {
            if (tr[rt].cnt) tr[rt].len = tr[rt].r - tr[rt].l + 1;
            else tr[rt].len = tr[lson(rt)].len + tr[rson(rt)].len;
        }
        void Update(int rt, int l, int r, int data) {
            if (tr[rt].l >= l && tr[rt].r <= r) {
                tr[rt].cnt += data;
                Pushup(rt);
                return;
            }
            int mid = (tr[rt].l + tr[rt].r) >> 1;
            if (l <= mid) Update(lson(rt), l, r, data);
            if (r > mid) Update(rson(rt), l, r, data);
            Pushup(rt);
        }
    } S;
    ```
* **代码解读**：
  用结构体`Segment_Tree`封装线段树，`tr`数组存储节点信息。`Pushup`函数与“中二病”的`push_up`逻辑一致。`Update`函数递归更新子节点，确保覆盖次数正确。这种模块化设计提高了代码的可读性和复用性。
* 💡 **学习笔记**：结构体封装是良好的编程习惯，能清晰划分功能模块，减少全局变量污染。

**题解三：作者：Juan_feng（分块实现）**
* **亮点**：分块维护区间覆盖，适合理解基础区间操作。
* **核心代码片段**：
    ```cpp
    void changeup(int x, int y) {
        FOR(i, x, min(y, b[x]*sq)) { // 处理左散块
            ++a[i]; 
            if (a[i] == 1) ++ans[b[x]]; // 覆盖次数从0→1，块内计数+1
        }
        if (b[x] != b[y]) // 处理右散块
            FOR(i, (b[y]-1)*sq+1, y) {
                ++a[i];
                if (a[i] == 1) --ans[b[y]];
            }
        FOR(i, b[x]+1, b[y]-1) ++tag[i]; // 处理整块，标记+1
    }
    ```
* **代码解读**：
  `changeup`函数处理区间加操作。`a[i]`记录单点覆盖次数，`ans[b[x]]`记录块内单点覆盖次数>0的数量，`tag[i]`记录整块覆盖次数。散块部分逐个更新，整块部分打标记。查询时，若`tag[i]>0`，块长度为`sq`；否则，取`ans[i]`。
* 💡 **学习笔记**：分块通过“大块标记+小块暴力”平衡时间复杂度，适合理解区间操作的本质。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解扫描线和线段树的工作过程，我们设计一个“像素扫描探险”动画，以8位复古风格展示算法步骤！
</visualization_intro>

  * **动画演示主题**：`像素扫描探险——寻找被污染的社区`

  * **核心演示内容**：扫描线从左到右移动，处理每个矩形的左右边界事件；线段树节点用像素块表示，颜色深浅反映覆盖次数；每处理一个事件，计算当前覆盖长度并累加面积。

  * **设计思路简述**：8位像素风格（如FC游戏画面）营造轻松氛围；扫描线用黄色箭头表示，线段树节点用绿色（覆盖）/灰色（未覆盖）像素块；关键操作（如事件处理、覆盖更新）伴随“叮”音效，面积累加时播放“滴答”声，最终输出答案时播放胜利音效。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          - 屏幕分为左右两部分：左侧是像素网格（表示社区），右侧是线段树结构（像素块堆叠）。
          - 控制面板包含“单步”、“自动播放”按钮和速度滑块（1-5倍速）。
          - 播放8位风格背景音乐（如《超级马力欧》经典旋律）。

    2.  **事件排序与初始化**：
          - 所有扫描线事件（矩形左右边界）以蓝色像素条形式排列在底部，按x坐标排序。
          - 线段树初始化为灰色（未覆盖），覆盖次数和长度显示为0。

    3.  **扫描线移动与事件处理**：
          - 扫描线（黄色箭头）从最左事件开始，每移动到一个事件位置，暂停并高亮该事件（蓝色→红色）。
          - 处理左边界事件（+1）：对应线段树区间的像素块变绿（覆盖次数+1），伴随“叮”音效；处理右边界事件（-1）：绿色变浅（覆盖次数-1），若覆盖次数归零则变灰。
          - 计算当前覆盖长度（线段树根节点的绿色块总长度），乘以扫描线移动的x差（相邻事件的x坐标差），面积累加到顶部的“总污染社区数”显示框。

    4.  **AI自动演示模式**：
          - 点击“AI演示”，扫描线自动从左到右移动，事件逐个处理，线段树动态更新，学习者可观察完整流程。

    5.  **目标达成**：
          - 所有事件处理完成后，“总污染社区数”显示最终答案，播放胜利音效（如《超级马力欧》通关音乐），绿色像素块闪烁庆祝。

    6.  **旁白提示**：
          - 关键步骤显示文字气泡：“当前处理左边界事件，覆盖y区间[3,7]，覆盖次数+1！”
          - 线段树更新时提示：“覆盖次数>0，当前区间长度为4公里！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到扫描线如何一步步计算覆盖面积，线段树如何动态维护覆盖长度，让抽象的算法变得“可见可听”！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
扫描线算法是计算几何中的重要工具，除了本题的面积并，还可用于周长并、最大覆盖等问题。以下是相关练习推荐：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 矩形面积并：如本题，用扫描线+线段树维护覆盖长度。
      - 矩形周长并：扫描线维护覆盖长度和边界数，计算横向/纵向周长。
      - 最大覆盖点：扫描线统计覆盖次数，找最大值。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P5490 【模板】扫描线**
          * 🗣️ **推荐理由**：扫描线算法的标准模板题，适合巩固线段树维护覆盖长度的技巧。
    2.  **洛谷 P1856 [USACO5.5]矩形周长Picture**
          * 🗣️ **推荐理由**：在面积并基础上增加周长计算，需维护覆盖长度和边界数，拓展扫描线的应用。
    3.  **洛谷 P1972 [SDOI2009]HH的项链**
          * 🗣️ **推荐理由**：虽不直接用扫描线，但需离线处理区间查询，培养事件排序和离线算法思维。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试经验，对学习者很有启发：
</insights_intro>

> **参考经验 (来自 题解作者)**：“在处理水平河段时，最初忘记将y范围扩展为[y1-1, y2+1]，导致覆盖的社区数量少算。后来通过打印中间事件和线段树状态，发现了边界错误。”

**点评**：这位作者的经验提醒我们，边界条件是扫描线问题的常见坑点。调试时可打印关键事件（如转换后的矩形坐标）和线段树状态（覆盖次数、长度），快速定位错误。对于类似问题，建议先手动模拟小数据（如样例输入），验证转换和计算是否正确。

-----

<conclusion>
本次关于“被污染的河流”的分析就到这里。通过扫描线算法和线段树/分块的学习，我们不仅解决了本题，还掌握了计算几何中面积并的核心方法。记住，多动手调试、多做拓展练习，编程能力会稳步提升！下次见~ 💪
</conclusion>

---
处理用时：168.07秒
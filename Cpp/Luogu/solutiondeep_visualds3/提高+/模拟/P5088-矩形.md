# 题目信息

# 矩形

## 题目背景

小奔月考考的可棒了！作为奖励，老师给了他一只激光笔。

## 题目描述

但老师永远不是白给小奔奖品的。他告诉小奔：反射角等于入射角。并让他解决下面的问题：

如果有一个矩形，长和宽之比为N：M，现在有一束激光从左上角射出，且与长N的夹角为 ζ °（0≤ζ≤90），且满足cot ζ ° = A ： B，求最少需要多少次反射才能重新反射入四个角当中的任意一个角呢？

![](https://cdn.luogu.com.cn/upload/pic/37985.png)

## 说明/提示

对于10%的数据,A=B=1；

对于另10%的数据,N=M；

对于50%的数据，$0≤A,B,M,N≤10^5$；

对于100%的数据，$0≤A,B,M,N≤10^{10}$；

## 样例 #1

### 输入

```
3 4
1 1```

### 输出

```
5```

# AI分析结果



---
# 💡 Kay的C++算法解析：矩形 深入学习指南 💡

<introduction>
今天我们来一起分析“矩形”这道C++编程题。这道题需要我们计算激光在矩形中反射后首次进入角落的次数，涉及数学推导和最大公约数的应用。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（最大公约数与比例化简）`

🗣️ **初步分析**：
解决“矩形”这道题，关键在于将反射路径转化为直线穿过镜像矩形的问题。简单来说，我们可以想象将原矩形无限复制，形成一个由原矩形拼接而成的网格。激光的反射路径在原矩形中的折线，等价于在这个网格中的一条直线。此时，问题转化为：找到这条直线第一次到达某个镜像矩形顶点时，穿过的原矩形边的数量（即反射次数）。

- **题解思路**：所有优质题解均通过“镜像扩展”将反射路径转化为直线，利用比例关系和最大公约数（gcd）找到最小的横向和纵向扩展次数k1、k2，最终反射次数为k1+k2-2。
- **核心难点**：如何将原问题转化为镜像扩展的直线问题，以及如何通过比例化简和gcd计算得到最小的k1、k2。
- **可视化设计**：动画将展示原矩形拼接成网格的过程，用不同颜色标记镜像矩形，激光以直线形式穿过网格，高亮显示首次到达顶点的位置，并动态计算k1、k2。动画中会加入“镜像复制”的像素动画（如原矩形向右/下复制时，新矩形以像素渐变的方式出现），关键步骤伴随“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解（评分≥4星）。
</eval_intro>

**题解一：天泽龟 (赞：18)**
* **点评**：此题解通过手画样例和镜像扩展的直观分析，清晰推导了反射次数的计算公式。代码简洁，正确处理了a或b为0的特判，且通过化简比例避免了大数运算。亮点在于用“压缩矩形”的比喻帮助理解比例关系，适合初学者快速入门。

**题解二：Rigel (赞：17)**
* **点评**：此题解通过建立坐标系和直线方程，数学推导严谨。将问题转化为直线首次到达镜像顶点的条件，利用gcd计算最小k1、k2，逻辑清晰。代码规范，变量命名明确（如g1、g2表示不同的gcd），边界处理严谨，适合深入理解数学原理。

**题解三：WanderingTim (赞：2)**
* **点评**：此题解以“镜像扩展”为核心思路，用“将军饮马”的经典问题类比，降低理解门槛。代码通过两次gcd化简比例（长宽比和余切比），最终计算k1+k2-2，简洁高效。特别指出“特判垂直或水平光线”的常见坑点，对实践有重要参考价值。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼核心思考方向：
</difficulty_intro>

1.  **关键点1**：如何将反射路径转化为直线问题？
    * **分析**：反射路径的折线可等价为直线穿过多个镜像矩形。例如，每次左右反射相当于向右复制一个原矩形，上下反射相当于向下复制一个原矩形。激光的直线穿过这些镜像矩形，首次到达顶点时的横向扩展次数k1和纵向扩展次数k2即为关键。
    * 💡 **学习笔记**：镜像扩展是将反射问题转化为直线问题的核心技巧，类似“将军饮马”问题的对称思想。

2.  **关键点2**：如何通过比例关系求最小k1、k2？
    * **分析**：根据余切定义，cotζ=A/B=（k1×n）/(k2×m)，化简得k1/k2=(A×m)/(B×n)。将A×m和B×n的比值约分为最简形式（除以gcd(A×m,B×n)），得到最小的k1、k2。
    * 💡 **学习笔记**：比例化简和gcd的应用是找到最小扩展次数的关键。

3.  **关键点3**：如何处理边界条件（如a=0或b=0）？
    * **分析**：当a=0时，激光沿水平方向射出，直接进入右角落，无需反射；同理b=0时沿垂直方向射出，直接进入下角落。需特判这两种情况，输出0。
    * 💡 **学习笔记**：边界条件的处理是避免错误的重要步骤，需仔细检查输入是否为0。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题转化**：将反射路径转化为直线穿过镜像矩形，简化问题。
- **比例化简**：通过gcd化简比例，找到最小的扩展次数k1、k2。
- **特判处理**：输入为0时直接输出0，避免逻辑错误。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个通用的核心C++实现参考，帮助把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了多个优质题解的思路，通过化简比例和gcd计算，得到最小反射次数。代码简洁高效，适用于大数范围。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;
    using ll = long long;

    int main() {
        ll n, m, a, b;
        cin >> n >> m >> a >> b;
        if (a == 0 || b == 0) { // 特判水平/垂直光线
            cout << 0 << endl;
            return 0;
        }
        // 化简长宽比和余切比
        ll g = __gcd(n, m);
        n /= g; m /= g;
        g = __gcd(a, b);
        a /= g; b /= g;
        // 计算k1、k2
        ll k1 = a * m;
        ll k2 = b * n;
        g = __gcd(k1, k2);
        k1 /= g; k2 /= g;
        cout << k1 + k2 - 2 << endl;
        return 0;
    }
    ```
* **代码解读概要**：代码首先处理a或b为0的特殊情况，直接输出0。然后化简矩形长宽比（n/m）和余切比（a/b），通过比例关系计算k1和k2（即镜像扩展的横向和纵向次数），最后用gcd化简k1和k2，输出k1+k2-2。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段。
</code_intro_selected>

**题解一：天泽龟**
* **亮点**：通过两次gcd化简比例，避免大数运算，代码简洁。
* **核心代码片段**：
    ```cpp
    a*=m; b*=n; 
    ll d=gcd(a,b); 
    a/=d; b/=d;
    cout<<b+a-2<<endl;
    ```
* **代码解读**：将a和b分别乘以m和n（对应比例关系k1/k2=(A×m)/(B×n)），然后用gcd化简得到最小的k1、k2（a/d和b/d），最终输出k1+k2-2。
* 💡 **学习笔记**：通过比例转换和gcd化简，直接得到最小扩展次数。

**题解二：Rigel**
* **亮点**：数学推导严谨，明确k1和k2的计算逻辑。
* **核心代码片段**：
    ```cpp
    int g=gcd(a*m,b*n);
    int k1=b*n/g,k2=a*m/g;
    return k1+k2-2;
    ```
* **代码解读**：计算a×m和b×n的gcd，将k1和k2分别设为(b×n)/g和(a×m)/g，确保k1和k2互质，得到最小扩展次数。
* 💡 **学习笔记**：k1和k2需互质，才能保证是首次到达顶点。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解镜像扩展和反射次数的计算，我们设计一个“像素镜像探险”动画，用8位像素风格展示激光穿过镜像矩形的过程。
</visualization_intro>

  * **动画演示主题**：`像素镜像探险——激光穿过镜像矩形`

  * **核心演示内容**：展示原矩形向右/下复制形成镜像网格，激光以直线形式穿过网格，首次到达顶点时的k1、k2值及反射次数。

  * **设计思路简述**：采用8位像素风格（如FC游戏画面），用不同颜色区分原矩形（红色边框）和镜像矩形（灰色边框）。激光用黄色线段表示，顶点用绿色亮点标记。关键步骤（如镜像复制、到达顶点）伴随“叮”的音效，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：屏幕中央显示一个红色边框的矩形（原矩形），右侧和下侧有灰色半透明的镜像矩形（未激活）。控制面板包含“单步”“自动播放”按钮和速度滑块。

    2.  **镜像扩展演示**：点击“自动播放”，原矩形向右复制k1次，向下复制k2次，每次复制时新矩形以像素渐变（从透明到灰色）的方式出现，伴随“唰”的音效。

    3.  **激光直线穿过**：黄色激光从原矩形左上角出发，沿直线穿过镜像网格，每穿过一条原矩形的边（上下或左右）时，对应边高亮（蓝色闪烁），并播放“滴”的音效，计数反射次数。

    4.  **首次到达顶点**：当激光到达某个镜像矩形的顶点时，该顶点绿色高亮，播放“胜利”音效（如FC的“通关”音乐），显示k1、k2和反射次数（k1+k2-2）。

    5.  **交互控制**：支持“单步”查看每一步镜像复制和激光移动，“重置”回到初始状态，速度滑块调整动画快慢。

  * **旁白提示**：
    - （镜像复制时）“看！原矩形向右复制了一个，这是第1次镜像扩展~”
    - （激光穿边时）“激光穿过了左边，反射次数+1！”
    - （到达顶点时）“哇！激光到达了顶点，反射次数是k1+k2-2哦~”

<visualization_conclusion>
通过这个像素动画，我们可以直观看到镜像扩展的过程和激光的直线路径，轻松理解k1、k2与反射次数的关系。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以思考数学方法在其他问题中的应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 比例化简和gcd的应用：适用于所有需要找到最小整数解的比例问题（如分数约分、最小公倍数计算）。
    - 镜像扩展思想：适用于反射路径、光线追踪等问题（如镜面反射、迷宫最短路径）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1029** - `最大公约数和最小公倍数问题`
          * 🗣️ **推荐理由**：练习gcd和lcm的计算，巩固比例化简技巧。
    2.  **洛谷 P1372** - `又是毕业季I`
          * 🗣️ **推荐理由**：结合gcd和组合数学，提升数学问题分析能力。
    3.  **洛谷 P5744** - `【深基7.习9】培训`
          * 🗣️ **推荐理由**：通过实际场景问题，练习比例计算和边界处理。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中作者提到的调试经验对我们很有帮助：
</insights_intro>

> **参考经验 (来自天泽龟)**：“死活卡在95分就是因为没特判a=0或b=0的情况。”

**点评**：这位作者的经验提醒我们，边界条件的处理是编程中容易出错的环节。在处理输入时，一定要检查特殊值（如0），避免因小失大。遇到测试点不通过时，可优先考虑是否遗漏了边界情况。

---

<conclusion>
本次关于“矩形”的C++解题分析就到这里。希望这份学习指南能帮助大家理解数学方法在算法中的应用，掌握比例化简和gcd的技巧。记住，多思考、多练习，编程能力会稳步提升！下次我们再一起探索新的挑战！💪
</conclusion>

---
处理用时：113.68秒
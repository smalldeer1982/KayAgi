# 题目信息

# [CSP-S2019 江西] 多叉堆

## 题目背景

JXCSP-S T5

## 题目描述

多叉堆是一种树形数据结构，本题中我们只考虑小根堆，它满足除了根以外的结点，每个点的权值都不小于父亲的权值。除了叶结点，每个点有至少一个子结点。

初始时有 $n$ 个结点，编号分别为 $0 \sim n - 1$ ，每个结点都是一棵以自身为根的单点树。接下来按顺序有 $q$ 次操作，每次操作有以下两种：

* `1 x y`：选择不在同一棵树里的结点 $x$ 和 $y$，将 $x$ 所在树的根直接接在 $y$ 所在树的根之下，此时 $x$ 和 $y$ 所在树将合并为同一棵树。

* `2 x`：选择结点 $x$，设 $x$ 当前所在树的结点数为 $size$。你需要计算将 $0 \sim size - 1$ 这 $size$ 个数分别填入 $x$ 所在树的结点中，能够产生多少种不同的多叉堆。两种堆不同当且仅当存在某个结点填入的值不同。由于答案可能很大，你只需要求出答案模 $10^9+7$ 后的结果。

## 说明/提示

#### 【输入输出样例 1 说明】

第 $1$ 次操作时，将 $1$ 所在树的根 $1$ 接在 $0$ 所在树的根 $0$ 下。 

第 $2$ 次操作时，将 $2$ 所在树的根 $2$ 接在 $0$ 所在树的根 $0$ 下。   

第 $3$ 次操作时，$1$ 所在树如图 $1$，在 $0,1,2$ 中分别填入 $[0,1,2]$ 和 $[0,2,1]$ 可以产生 $2$ 种不同的堆。    

第 $4$ 次操作时 $x=(3+2) \bmod 5=0$，$y=(1+2) \bmod 5=3$，将 $0$ 所在树的根 $0$ 接在 $3$ 所在树的根 $3$ 下。   

第 $5$ 次操作 时，$x=(2+2) \bmod 5=4$，$y=(0+2) \bmod 5=2$，将 $4$ 所在树的根 $4$ 接在 $2$ 所在树的根 $3$ 下。    

第 $6$ 次操作 时，$x=(4+2) \bmod 5=1$，$1$ 所在树如图 $2$，在 $0\sim 4$ 中分别填入 $[1,2,3,0,4]$，$[1,3,2,0,4]$，$[1,2,4,0,3]$，$[1,4,2,0,3]$，$[1,3,4,0,2]$，$[1,4,3,0,2]$，$[2,4,3,0,1]$ 可以产生 $8$ 种不同的堆。

![](https://cdn.luogu.com.cn/upload/image_hosting/mqsr3nri.png)

#### 【数据规模与约定】

对于 $100\%$ 的数据，$0\le x',y' <n \le 3\times 10^5$，$1\le Q\le 3\times 10^5$。

对于不同测试点，我们约定

![](https://cdn.luogu.com.cn/upload/image_hosting/44j0elzy.png)


特殊性质 $1$：存在 $1\le i<n $，前 $i$ 次操作均为 $1$ 操作，之后全是 $2$ 操作。

特殊性质 $2$：对于所有输入 $x$ 和 $y$ 本身即是其所在树的根。

感谢 @Fairicle 提供的数据。 

## 样例 #1

### 输入

```
5 6
1 1 0
1 2 0
2 1
1 3 1
1 2 0
2 4```

### 输出

```
2
8
```

# AI分析结果



---
# 💡 Kay的C++算法解析：多叉堆 深入学习指南 💡

<introduction>
今天我们来一起分析“多叉堆”这道C++编程题。这道题结合了并查集和组合数学，需要动态维护树的合并与多叉堆填数方案数的计算。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`并查集+组合数学`

🗣️ **初步分析**：
解决“多叉堆”问题，关键在于用并查集维护树的动态合并，并通过组合数学计算多叉堆的填数方案数。  
并查集（Union-Find）可以高效管理树的合并与查询操作，类似“快速分组管理员”——每个节点有一个“代表元”（根节点），合并时将两棵树的根连接，查询时快速找到节点所属的根。  
组合数学在这里的作用是计算合并后子树的填数方案数。多叉堆的性质要求根节点填最小值（0），子树的填数方案需从剩余数中选择，这涉及组合数计算（如从总节点数-1中选子树大小的组合数）。

题解的核心思路是：每个根节点维护子树大小（size）和方案数（dp）。合并时，将x的根合并到y的根下，y的size增加x的size，y的方案数更新为原方案数×x的方案数×组合数C(size_y_new-1, size_x)。查询时直接返回根节点的方案数。

可视化设计思路：用8位像素风格展示树的合并过程（节点方块移动）、size和dp值的动态更新（数字闪烁），关键操作（合并、计算组合数）伴随“叮”声，增强直观性。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解：
</eval_intro>

**题解一：作者 zimujun（赞33）**  
* **点评**：此题解思路清晰，详细解释了并查集和组合数的应用。代码规范（变量名如`a`表示方案数，`w`表示size），特别强调初始化的重要性（如节点0的初始化），并分享了调试经验（“卡了几天是因为初始化错误”）。合并逻辑明确，组合数预处理正确，实践价值高，适合竞赛参考。

**题解二：作者 银杉水杉秃杉（赞12）**  
* **点评**：题解结构清晰，明确指出“并查集+组合数”的核心，对比了两种组合数预处理方法（费马小定理和线性逆元），代码中强制在线处理（通过`ans`更新输入）正确。变量名（`s`表示size，`a`表示方案数）直观，适合学习组合数预处理与并查集的结合。

**题解三：作者 7KByte（赞6）**  
* **点评**：题解简洁，直接给出核心转移方程（`f[i] = f[j] * C(...)`），代码实现高效。预处理阶乘和逆元的方式正确，合并操作逻辑与主流解法一致，适合快速理解核心思路。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键在于处理并查集维护、组合数计算和方案数更新。以下是核心难点及策略：
</difficulty_intro>

1.  **关键点1：并查集维护树结构**  
    * **分析**：需维护每个节点的根、子树大小和方案数。合并时，只有根节点的信息需要更新（size和dp），其他节点通过路径压缩直接指向根。例如，合并x和y时，找到x的根fx和y的根fy，将fx的父设为fy，并更新fy的size和dp。  
    * 💡 **学习笔记**：并查集的路径压缩是高效维护树结构的关键，确保每次操作的时间复杂度接近常数。

2.  **关键点2：组合数的预处理**  
    * **分析**：组合数C(n, m)需预处理阶乘（fac）和阶乘逆元（invf）。由于n可达3e5，需线性预处理。例如，`fac[i] = i! % MOD`，`invf[n] = qpow(fac[n], MOD-2)`，再倒推其他逆元。  
    * 💡 **学习笔记**：预处理阶乘逆元时，倒序计算可避免重复计算，确保组合数快速查询。

3.  **关键点3：合并时方案数的计算**  
    * **分析**：合并后，新的方案数是原两棵树方案数的乘积，乘以组合数C(size_y_new-1, size_x)。因为根节点固定填0，剩余size_y_new-1个数中选size_x个给x的子树。  
    * 💡 **学习笔记**：方案数更新需严格遵循乘法原理，确保每一步模运算正确。

### ✨ 解题技巧总结
- **问题分解**：将动态树合并与方案数计算分解为并查集维护和组合数预处理两部分，简化问题。  
- **边界检查**：初始化时注意节点编号（如题目中节点从0开始），避免越界错误。  
- **模运算细节**：组合数计算中所有乘法需取模，防止溢出。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合多个优质题解（如zimujun、银杉水杉秃杉）的思路，选择最简洁高效的实现，包含并查集、阶乘预处理、合并和查询逻辑。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int MOD = 1e9 + 7;
    const int MAXN = 3e5 + 5;

    int fa[MAXN], siz[MAXN];
    ll dp[MAXN], fac[MAXN], invf[MAXN];
    int ans = 0;

    ll qpow(ll a, ll b) {
        ll res = 1;
        while (b) {
            if (b & 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }

    void init(int n) {
        for (int i = 0; i < n; ++i) {
            fa[i] = i;
            siz[i] = 1;
            dp[i] = 1;
        }
        fac[0] = 1;
        for (int i = 1; i <= n; ++i)
            fac[i] = fac[i - 1] * i % MOD;
        invf[n] = qpow(fac[n], MOD - 2);
        for (int i = n - 1; i >= 0; --i)
            invf[i] = invf[i + 1] * (i + 1) % MOD;
    }

    ll C(int n, int k) {
        if (k < 0 || k > n) return 0;
        return fac[n] * invf[k] % MOD * invf[n - k] % MOD;
    }

    void merge(int x, int y) {
        int fx = find(x), fy = find(y);
        if (fx == fy) return;
        fa[fx] = fy;
        ll c = C(siz[fy] + siz[fx] - 1, siz[fx]);
        dp[fy] = dp[fy] * dp[fx] % MOD * c % MOD;
        siz[fy] += siz[fx];
    }

    int main() {
        int n, q;
        scanf("%d%d", &n, &q);
        init(n);
        while (q--) {
            int op, x, y;
            scanf("%d%d", &op, &x);
            x = (x + ans) % n;
            if (op == 1) {
                scanf("%d", &y);
                y = (y + ans) % n;
                merge(x, y);
            } else {
                int root = find(x);
                ans = dp[root] % MOD;
                printf("%d\n", ans);
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码通过`init`函数初始化并查集、阶乘和逆元数组。`merge`函数处理合并操作，找到两个节点的根，更新父节点、子树大小和方案数。`find`函数通过路径压缩快速找根。查询操作直接返回根节点的方案数，强制在线处理通过`ans`变量更新输入。

---
<code_intro_selected>
接下来，我们将剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者 zimujun**
* **亮点**：代码规范，强调初始化细节（如`a[0]`和`w[0]`初始化为1），组合数预处理正确。
* **核心代码片段**：
    ```cpp
    void line(int u, int v) {
        w[v] += w[u];
        a[v] = a[v] * a[u] % Mod * C(w[v] - 1, w[u]) % Mod;
        fa[u] = v;
    }
    ```
* **代码解读**：  
  `line`函数处理合并逻辑。`w[v] += w[u]`更新子树大小；`a[v]`更新为原方案数×x的方案数×组合数（`C(w[v]-1, w[u])`），最后将u的父设为v。这一步是方案数计算的核心，确保合并后的方案数正确。
* 💡 **学习笔记**：合并时的组合数计算是关键，需注意`w[v]-1`（根节点固定填0）。

**题解二：作者 银杉水杉秃杉**
* **亮点**：对比两种组合数预处理方法（费马小定理和线性逆元），代码注释清晰。
* **核心代码片段**：
    ```cpp
    void init() {
        fac[0] = 1;
        for (int i = 1; i <= n; i++) {
            f[i] = i;
            s[i] = a[i] = 1;
            fac[i] = fac[i - 1] * i % mod;
        }
        inf[n] = qpow(fac[n], mod - 2);
        for (int i = n; i >= 1; i--)
            inf[i - 1] = (inf[i] * i) % mod;
    }
    ```
* **代码解读**：  
  `init`函数预处理阶乘和逆元。`fac[i]`存储i的阶乘模mod；`inf[n]`通过快速幂计算n!的逆元，再倒推其他逆元。这种方法确保组合数的快速计算。
* 💡 **学习笔记**：预处理阶乘逆元时，倒序计算可避免重复计算，提高效率。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解并查集合并和方案数计算的过程，我设计了一个8位像素风格的动画演示方案。
</visualization_intro>

  * **动画演示主题**：多叉堆合并与查询的像素冒险  

  * **核心演示内容**：  
    展示并查集的合并过程（节点方块移动）、子树大小（size）和方案数（dp）的动态更新，以及组合数计算的选择过程。

  * **设计思路简述**：  
    采用FC红白机风格的像素画面，用不同颜色区分根节点（红色）和普通节点（蓝色）。合并时，x的根方块滑动到y的根下方；size和dp值用数字气泡显示，合并时数字动态增长。关键操作（如计算组合数）伴随“叮”声，查询时显示方案数并播放“滴”声，增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：  
        屏幕显示n个独立的像素方块（0~n-1），每个方块下方显示size=1和dp=1。控制面板有“开始”“单步”“重置”按钮和速度滑块。

    2.  **合并操作演示**：  
        - 选择x和y，找到根节点fx（蓝）和fy（红）。  
        - fx的方块滑动到fy下方，fy的size从s变为s+fx.size（数字闪烁）。  
        - 弹出组合数计算窗口：从s+fx.size-1个格子中选中fx.size个（格子变色），计算结果显示在fy的dp旁，dp值更新为原dp×x.dp×组合数（数字闪烁）。

    3.  **查询操作演示**：  
        - 点击节点x，找到根节点fy，fy的dp值放大显示，伴随“滴”声和烟花动画（像素星星）。

    4.  **交互控制**：  
        - 单步执行：逐帧查看合并或查询的每一步。  
        - 自动播放：算法自动演示多个操作，速度可调。  
        - 重置：回到初始状态，重新开始。

  * **旁白提示**：  
    - 合并时：“现在将x的根合并到y的根下，y的size增加，方案数需要乘以组合数哦～”  
    - 查询时：“当前根节点的方案数是dp值，这就是答案！”  

<visualization_conclusion>
通过这样的像素动画，我们可以直观看到并查集的合并过程、size和dp的更新，以及组合数的计算逻辑，轻松理解抽象的算法步骤。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以尝试以下拓展练习，巩固并查集和组合数学的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    并查集+组合数学的方法可用于动态树合并中的方案统计（如拓扑序计数、连通块权值统计），或树形结构的动态维护（如动态生成树的权值计算）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3367 并查集**  
        * 🗣️ **推荐理由**：基础并查集练习，熟悉路径压缩和按秩合并。  
    2.  **洛谷 P1351 联合权值**  
        * 🗣️ **推荐理由**：树形结构与组合数结合，练习树上的统计问题。  
    3.  **洛谷 P5836 [USACO19DEC]Tree Depth G**  
        * 🗣️ **推荐理由**：树形DP与组合数的综合应用，提升复杂问题的分析能力。

-----

## 7\. 学习心得与经验分享

<insights_intro>
题解作者 zimujun 分享了调试经验：“卡了几天是因为初始化时a和w数组的0号节点未正确初始化。”这对我们很有启发：
</insights_intro>

> **参考经验**：“我在解决这个问题时，最初在初始化节点0的a和w值时卡了很久，后来检查发现忘记将a[0]和w[0]初始化为1。这让我意识到，处理节点编号时一定要注意边界条件！”

**点评**：这位作者的经验提醒我们，初始化是编程中容易出错的环节。特别是题目中节点编号从0开始时，需确保所有节点（包括0号）的初始值正确。调试时，检查初始化步骤是快速定位错误的有效方法。

-----

<conclusion>
本次关于“多叉堆”的C++解题分析就到这里。希望这份指南能帮助大家掌握并查集和组合数学的应用，理解动态树合并与方案数计算的核心逻辑。记住，多练习、多调试，编程能力会不断提升！下次见～💪
</conclusion>

---
处理用时：211.17秒
# 题目信息

# 黄玫瑰

## 题目描述

给定一张包含 $n$ 个点的简单有向无环图 $G$，点 $i$ 的点权设为 $w_i$，但**点权不是给定的**。

你需要构造一个包含至多 $2\times n$ 个点和恰好 $n$ 条边的有向无环图 $G'$，你需要为 $G'$ 的每条边钦定某个 $w_i$ 作为它的边权，使得 $G'$ 和 $G$ 的**最长路**长度相等。

在 $G$ 中一条路径的长度定义为其中所有点权和，$G'$ 中则为所有边权和。

然而，所有 $w_i$ 都不是给定的，所以你构造的 $G'$ 需要满足：对于任何一种可能的**正数**序列 $[w_1,\ldots,w_n]$，$G$ 和 $G'$ 的最长路长度都要相等。

请构造 $G'$，或说明它不存在。

## 说明/提示

**【样例 #1 解释】**

如下图，左为 $G$，右为 $G'$，颜色相同的点/边表示权值相同：

![](https://cdn.luogu.com.cn/upload/image_hosting/i0wuxctf.png)

注意这只是一种可能的答案，其他正确的答案也可通过。

---

**【样例 #2 解释】**

下图为 $G$，不存在合法的 $G'$：

![](https://cdn.luogu.com.cn/upload/image_hosting/tek49neu.png)

---

**【数据范围】**

对于全部数据：$1\leq n\leq 20000$，$1\leq m\leq 3\times 10^5$，$1\leq x,y\leq n$，保证给定的图无环且无重边。

|     子任务编号     | $n\leq$ |    $m\leq$     |           特殊性质            | 分值 |
| :----------------: | :-----: | :------------: | :---------------------------: | :--: |
| $\text{Subtask 1}$ | $5000$  |     $4999$     | $m=n-1$，每个点入度不超过 $1$ | $18$ |
| $\text{Subtask 2}$ | $5000$  |     $4999$     | $m=n-1$，每个点出度不超过 $1$ | $19$ |
| $\text{Subtask 3}$ |  $20$   |      $50$      |              无               | $20$ |
| $\text{Subtask 4}$ | $5000$  |    $10000$     |              无               | $21$ |
| $\text{Subtask 5}$ | $20000$ | $3\times 10^5$ |              无               | $22$ |

---

![](https://cdn.luogu.com.cn/upload/image_hosting/jepg6g1u.png)

## 样例 #1

### 输入

```
7 8
1 2
1 3
2 3
2 6
3 4
5 2
5 7
6 7
```

### 输出

```
7
1 2 1
1 2 5
2 3 2
3 4 3
3 5 6
4 6 4
5 7 7
```

## 样例 #2

### 输入

```
7 8
1 2
2 3
2 6
4 5
4 7
5 3
7 3
7 6
```

### 输出

```
-1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：黄玫瑰 深入学习指南 💡

<introduction>
今天我们来一起分析“黄玫瑰”这道C++编程题。题目要求我们构造一个特殊的有向无环图G'，使得无论原图G的点权如何选择，两者的最长路长度始终相等。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（DAG结构分析与构造）`

🗣️ **初步分析**：
> 解决“黄玫瑰”这道题，关键在于理解DAG（有向无环图）的最长路性质，并通过构造新图G'来保持这种性质。简单来说，DAG的最长路问题类似于“任务调度中的最长依赖链”，每个节点的最长路径由其后继节点的最长路径决定。在本题中，我们需要确保新图G'的边权（对应原图点权）组合后，其最长路径长度与原图点权组合的最长路径完全一致，无论点权如何选择。
   - **题解思路**：两个题解均围绕“关键边筛选”和“节点合并”展开。Cynops的题解通过逆拓扑序计算每个点的可达集合，用并查集合并同类节点；Schi2oid的题解则通过哈希出度集合判断合规性，拆分入出点并合并。核心难点在于如何确保所有点权下最长路一致，以及如何判断构造是否可行。
   - **核心算法流程**：逆拓扑序处理（确定节点处理顺序）→ 筛选关键边（无法被其他路径替代的边）→ 合并同类节点（用并查集确保结构合规）→ 构造G'或判断无解。可视化需重点展示可达集合的更新（如节点颜色渐变）、并查集的合并（像素块连接动画）、矛盾检测（红色闪烁提示）。
   - **复古像素设计**：采用8位FC风格，节点用彩色像素块表示，边用箭头动画；关键操作（如边筛选、节点合并）伴随“叮”音效；矛盾检测时播放短促警报音，成功构造时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面评估题解，以下是评分≥4星的优质题解：
</eval_intro>

**题解一：Cynops的构造方案 (来源：洛谷用户Cynops)**
* **点评**：此题解思路非常清晰，通过逆拓扑序处理每个点的可达集合，并用并查集合并同类节点，逻辑严谨。代码中变量命名规范（如`g[x]`表示x的可达集合，`able[x]`存储有效边），边界处理（如虚点的添加）体现了严谨性。算法上，利用bitset优化可达集合计算（复杂度O(mn/w)），时间效率高，是竞赛中典型的高效实现。实践价值高，代码可直接用于处理大规模DAG构造问题。

**题解二：Schi2oid的入出点拆分方案 (来源：洛谷用户Schi2oid)**
* **点评**：此题解思路创新，通过拆分入点和出点（最多2n个点），并利用哈希出度集合判断合规性，逻辑巧妙。代码中使用随机哈希值（`val[i]`）避免冲突，体现了对细节的关注。虽然部分变量（如`nex[i]`）解释稍显模糊，但整体结构清晰，适合学习图构造中的“一一对应”思想。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何筛选原图中的“关键边”？
    * **分析**：关键边是指无法被其他路径替代的边（即删除该边后，原图中不存在其他路径连接起点和终点）。优质题解通过逆拓扑序计算每个点的可达集合（如Cynops的`g[x]`），若边`x→y`的终点y不在x的其他后继的可达集合中，则该边为关键边。
    * 💡 **学习笔记**：关键边是构造G'的基础，它们直接决定了最长路的结构。

2.  **关键点2**：如何合并节点以确保G'的结构合规？
    * **分析**：若两个节点的出边指向同一类节点（即它们的关键边终点集合相同），需将它们合并（如用并查集`fa`数组）。合并后，G'的边数恰好为n，且结构保持DAG性质。
    * 💡 **学习笔记**：并查集是处理“同类合并”问题的高效工具，能快速判断和维护节点关系。

3.  **关键点3**：如何判断构造是否可行？
    * **分析**：若存在两个节点x和y，它们有共同后继w，但x能到达v而y不能，则构造失败（如Schi2oid的哈希出度集合冲突）。此时，新图G'会引入原图不存在的路径，导致最长路不一致。
    * 💡 **学习笔记**：冲突检测是构造问题的关键，需确保所有可能的点权组合下，路径结构严格一致。

### ✨ 解题技巧总结
<summary_best_practices>
-   **逆拓扑序处理**：DAG的节点处理顺序决定了可达集合的计算方向，逆拓扑序能确保先处理无后继的节点，逐步向上推导。
-   **bitset优化集合运算**：用bitset存储可达集合（如`g[x]`），可高效进行并集操作（`|=`），降低时间复杂度。
-   **并查集维护等价类**：合并同类节点时，使用并查集快速查找和合并，确保结构合规。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们以Cynops的题解为基础，提炼一个通用的核心C++实现，帮助大家把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Cynops题解的思路，通过逆拓扑序、bitset和并查集实现关键边筛选与节点合并，是典型的高效构造方案。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 2e4 + 5;
    int n, m;
    int in[N], top[N], tt;
    int fa[N], siz[N], col[N], cnt;
    bitset<N> g[N];
    vector<int> G[N], able[N];

    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }

    void merge(int x, int y) {
        int fx = find(x), fy = find(y);
        if (fx != fy) fa[fx] = fy, siz[fy] += siz[fx];
    }

    void topo_sort() {
        queue<int> q;
        for (int i = 1; i <= n; ++i) if (!in[i]) q.push(i);
        while (!q.empty()) {
            int u = q.front(); q.pop();
            top[++tt] = u;
            for (int v : G[u]) if (--in[v] == 0) q.push(v);
        }
    }

    int main() {
        cin >> n >> m;
        for (int i = 1; i <= m; ++i) {
            int a, b; cin >> a >> b;
            G[a].push_back(b); in[b]++;
        }
        topo_sort();

        for (int i = 1; i <= n; ++i) fa[i] = i, siz[i] = 1;
        for (int i = n; i >= 1; --i) { // 逆拓扑序处理
            int x = top[i];
            bitset<N> vis;
            for (int j = 0; j < G[x].size(); ++j) {
                int y = G[x][j];
                vis[j] = g[x][y]; // 标记冗余边
                g[x] |= g[y];
            }
            g[x].set(x); // 自己可达自己
            for (int j = G[x].size() - 1; j >= 0; --j) {
                int y = G[x][j];
                vis[j] |= g[x][y];
                g[x] |= g[y];
                if (!vis[j]) able[x].push_back(y); // 记录关键边
            }
            if (!able[x].empty()) // 合并关键边的终点
                for (int y : able[x]) merge(able[x][0], y);
        }

        // 检查是否存在矛盾
        for (int i = 1; i <= n; ++i) {
            if (find(i) == i) col[i] = ++cnt;
            if (!able[i].empty() && siz[find(able[i][0])] != able[i].size()) {
                cout << -1 << endl; return 0;
            }
        }

        // 构造G'并输出
        cout << ++cnt << endl;
        for (int i = 1; i <= n; ++i) {
            if (!able[i].empty())
                printf("%d %d %d\n", col[find(i)], col[find(able[i][0])], i);
            else
                printf("%d %d %d\n", col[find(i)], cnt, i);
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先通过拓扑排序确定节点处理顺序（`topo_sort`），然后逆序处理每个节点（`i从n到1`），计算其可达集合（`g[x]`）并筛选关键边（`able[x]`）。通过并查集合并关键边的终点，确保同类节点合并。最后检查是否存在矛盾（如合并后的集合大小与关键边数量不符），若合法则构造G'并输出边。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段，理解其巧妙之处。
</code_intro_selected>

**题解一：Cynops的关键边筛选与合并**
* **亮点**：逆拓扑序处理+bitset优化，高效筛选关键边；并查集合并同类节点，确保结构合规。
* **核心代码片段**：
    ```cpp
    for (int i = n; i >= 1; --i) { // 逆拓扑序处理
        int x = top[i];
        bitset<N> vis;
        for (int j = 0; j < G[x].size(); ++j) {
            int y = G[x][j];
            vis[j] = g[x][y];
            g[x] |= g[y];
        }
        g[x].set(x);
        for (int j = G[x].size() - 1; j >= 0; --j) {
            int y = G[x][j];
            vis[j] |= g[x][y];
            g[x] |= g[y];
            if (!vis[j]) able[x].push_back(y); // 记录关键边
        }
        if (!able[x].empty()) 
            for (int y : able[x]) merge(able[x][0], y); // 合并关键边终点
    }
    ```
* **代码解读**：
    > 这段代码是关键边筛选的核心。逆拓扑序确保先处理无后继的节点（如终点），逐步向上推导。`g[x]`存储x的可达集合（初始为自身），通过`|=`操作合并后继的可达集合。`vis[j]`标记冗余边（即存在其他路径替代的边），未被标记的边即为关键边（存入`able[x]`）。最后，将所有关键边的终点合并（`merge`），确保它们在G'中对应同一节点。
* 💡 **学习笔记**：逆拓扑序是处理DAG可达性问题的“金钥匙”，能确保计算顺序的正确性；bitset的位运算高效处理集合合并，适合大规模数据。

**题解二：Schi2oid的入出点拆分与哈希验证**
* **亮点**：拆分入出点（最多2n个点），哈希出度集合判断合规性，逻辑新颖。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++){
        if(M[nex[i]]) continue;
        M[nex[i]]=1;
        for(int j=0;j<edge[i].size();j++){
            if(edge[i][j].ban) continue;
            int v=edge[i][j].to;
            if(vis[v]){ // 出度集合冲突
                puts("-1");
                return 0;
            }
            vis[v]=1;
        }
    }
    ```
* **代码解读**：
    > 这段代码通过哈希验证出度集合是否冲突。`nex[i]`是节点i的关键边终点的哈希值（用随机数`val[v]`求和）。若两个节点i和k的`nex[i]`相同（`M[nex[i]]`已存在），说明它们的关键边终点集合相同；若此时它们的关键边指向同一节点v（`vis[v]`重复标记），则构造失败（输出-1）。
* 💡 **学习笔记**：哈希是快速判断集合相等的常用方法，随机数哈希可降低冲突概率，适合竞赛中的高效验证。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解关键边筛选和节点合并的过程，我们设计一个“像素DAG探险家”动画，用8位FC风格展示算法执行流程！
</visualization_intro>

  * **动画演示主题**：`像素DAG构造记——关键边的寻找与节点合并`

  * **核心演示内容**：展示逆拓扑序处理、关键边筛选（冗余边被“擦除”）、节点合并（像素块连接）、矛盾检测（红色警报）等核心步骤。

  * **设计思路简述**：8位像素风营造轻松氛围，节点用彩色方块（如起点红、终点蓝），边用箭头动画；关键操作（如边筛选）伴随“叮”音效，矛盾时播放警报音，成功构造时播放胜利音效。通过颜色变化（冗余边灰化、关键边高亮）和动画（合并时方块连接）直观展示算法逻辑。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧显示原图G的像素DAG（节点为16x16像素块，边为箭头），右侧显示控制面板（单步/自动按钮、速度滑块）。
          * 播放8位风格背景音乐（如《超级马力欧》经典旋律变奏）。

    2.  **拓扑排序**：
          * 节点按拓扑序从右到左排列（终点在最右），每个节点被访问时闪烁绿色，伴随“滴”音效。

    3.  **逆序处理与关键边筛选**：
          * 处理节点x时，x变为黄色。遍历其所有出边（箭头闪烁），计算可达集合（节点被染成半透明表示可达）。
          * 冗余边（可被替代的边）灰化并“擦除”（箭头消失），关键边保持高亮（红色箭头）。

    4.  **节点合并**：
          * 关键边的终点y1、y2...被选中，用像素线连接（合并过程），最终合并为一个大像素块（颜色统一），伴随“啵”音效。

    5.  **矛盾检测**：
          * 若发现两个节点的关键边指向同一节点v（`vis[v]`重复），v变为红色并闪烁，播放短促警报音（“叮-咚”），动画暂停提示“构造失败”。

    6.  **构造成功**：
          * 所有节点合并完成，新图G'在右侧生成（节点为合并后的像素块，边为关键边），播放胜利音效（“啦-啦-啦”），路径高亮显示。

  * **旁白提示**：
      * （处理节点x时）“现在处理节点x，我们需要找出它的关键边——无法被其他路径替代的边！”
      * （冗余边灰化时）“这条边可以被其他路径替代，所以我们把它擦掉～”
      * （合并节点时）“看！这些节点的关键边指向同一类节点，它们被合并成一个大块啦！”

<visualization_conclusion>
通过这个动画，我们能直观看到关键边如何被筛选、节点如何合并，以及矛盾如何被检测。像素风格和游戏化元素让复杂的图构造过程变得生动有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以将思路迁移到其他图构造问题，比如DAG的路径保持、最长路等价性验证等。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * `关键边筛选`：可用于DAG的最小边覆盖问题（保留最少边保持可达性）。
      * `并查集合并同类节点`：适用于图的商图构造（将等价节点合并为超级节点）。
      * `哈希验证集合相等`：可用于判断两个图的结构是否同构（如树的最小表示法）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4017 最大食物链计数** - `拓扑排序与路径计数`
          * 🗣️ **推荐理由**：练习DAG的拓扑排序和路径统计，巩固对DAG结构的理解。
    2.  **洛谷 P5024 保卫王国** - `动态DP与树链剖分`
          * 🗣️ **推荐理由**：进阶题，涉及DAG的最长路动态维护，提升复杂图问题的处理能力。
    3.  **洛谷 P3275 [SCOI2011]糖果** - `差分约束与最长路`
          * 🗣️ **推荐理由**：结合图论与不等式，练习将实际问题转化为DAG最长路问题。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。但通过观察代码，我们可以总结：处理图构造问题时，需注重“关键性质的保持”（如本题的最长路等价性），并善用拓扑排序、并查集等工具简化问题。
</insights_intro>

-----

<conclusion>
本次关于“黄玫瑰”的C++解题分析就到这里。希望这份指南能帮助大家理解DAG构造的核心思路，掌握关键边筛选和节点合并的技巧。记住，多动手画图、模拟算法流程，是理解图论问题的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：194.52秒
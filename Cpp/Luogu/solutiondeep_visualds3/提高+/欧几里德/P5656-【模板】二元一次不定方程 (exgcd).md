# 题目信息

# 【模板】二元一次不定方程 (exgcd)

## 题目描述

给定不定方程

$$ax+by=c$$

若该方程无整数解，输出 $-1$。  
若该方程有整数解，且有正整数解，则输出其**正整数**解的数量，所有**正整数**解中 $x$ 的最小值，所有**正整数**解中 $y$ 的最小值，所有**正整数**解中 $x$ 的最大值，以及所有**正整数**解中 $y$ 的最大值。  
若方程有整数解，但没有正整数解，你需要输出所有**整数解**中 $x$ 的最小正整数值， $y$ 的最小正整数值。

正整数解即为 $x, y$ 均为正整数的解，$\boldsymbol{0}$ **不是正整数**。  
整数解即为 $x,y$ 均为整数的解。  
$x$ 的最小正整数值即所有 $x$ 为正整数的整数解中 $x$ 的最小值，$y$ 同理。

## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1 \le T \le 2 \times {10}^5$，$1 \le a, b, c \le {10}^9$。

## 样例 #1

### 输入

```
7
2 11 100
3 18 6
192 608 17
19 2 60817
11 45 14
19 19 810
98 76 5432```

### 输出

```
4 6 2 39 8
2 1
-1
1600 1 18 3199 30399
34 3
-1
2 12 7 50 56```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】二元一次不定方程 (exgcd) 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（扩展欧几里得算法）`  

🗣️ **初步分析**：  
解决“二元一次不定方程”问题，核心是**扩展欧几里得算法（exgcd）**——它就像一把“解锁钥匙”，能帮我们找到方程`ax+by=gcd(a,b)`的整数特解，再通过这把钥匙打开更一般的方程`ax+by=c`的解空间。  

简单来说，exgcd的思路像“拆俄罗斯套娃”：  
1. 用**辗转相除法**（欧几里得算法）不断缩小`a`和`b`的规模（比如把`a,b`变成`b,a%b`），直到`b=0`（此时`gcd(a,b)=a`，特解是`x=1,y=0`）；  
2. 从最小的“套娃”（边界条件）反推回去，通过递归关系算出原问题的特解（比如`x=y', y=x'-(a/b)*y'`，其中`x',y'`是子问题的解）。  

在本题中，exgcd的作用是：  
- 先判断`c`是否是`gcd(a,b)`的倍数（裴蜀定理），若不是则无解；  
- 若是，则求出`ax+by=gcd(a,b)`的特解，再缩放得到`ax+by=c`的特解；  
- 最后通过**通解公式**（`x=x0 + k*(b/d), y=y0 - k*(a/d)`，其中`d=gcd(a,b)`），找出正整数解的数量、最大/最小值。  

**可视化设计思路**：  
我们将用8位像素风格展示exgcd的递归过程——屏幕左侧是`a`和`b`的“套娃拆解”（比如`a=11,b=2`→`a=2,b=1`→`a=1,b=0`），右侧实时更新`x`和`y`的取值；通解部分用“像素滑块”展示`k`变化时`x`和`y`的此消彼长（`x`增大，`y`减小）。关键步骤（如递归反推、模运算求最小正整数解）会用**闪烁的黄色像素框**高亮，配合“叮”的像素音效强化记忆。


## 2. 精选优质题解参考

<eval_intro>  
我从**思路清晰度、代码可读性、算法有效性**三个维度筛选了3份优质题解，帮你快速抓住核心：  
</eval_intro>

**题解一：来源：dengyaotriangle（赞：357）**  
* **点评**：这份题解是“最接地气的exgcd说明书”！作者从特解推导到通解公式，每一步都用“人话”讲清楚——比如用“任意d∈Q”推导通解的变化量，用“s的上下界”判断正整数解的存在性。思路像“剥洋葱”一样层层递进，尤其适合初学者理解“为什么通解长这样”。作者还特意提醒“开long long”，踩坑经验很实用！

**题解二：来源：yangrunze（赞：114）**  
* **点评**：这份题解是“exgcd从0到1的完整教程”！作者先讲基础exgcd的代码（含递归过程的推导），再分步讲解“求特解→求通解→找正整数解”，甚至用“把大象关冰箱”类比解题步骤，趣味性拉满。代码里的快读、exgcd模板都很规范，边界处理（比如`x`为负时的调整）也很严谨，是“可以直接抄的竞赛级代码”。

**题解三：来源：linponess（赞：50）**  
* **点评**：这份题解是“暴力到优化的进阶指南”！作者先写了暴力版代码（逐次调整`k`找最小正整数解），再用“模运算直接求最小解”优化，对比之下能明显看到“数学技巧如何提升效率”。优化后的代码简洁到“惊艳”——比如用`xin = x>0&&x%b!=0?x%b:x%b+b`直接求`x`的最小正整数解，充分体现了“数学公式简化代码”的魅力。


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决本题的“三座大山”是：**exgcd的递归逻辑、通解的推导、正整数解的边界处理**。结合优质题解，我帮你把“难点”拆成“可操作的步骤”：  
</difficulty_intro>

1. **关键点1：如何用exgcd求特解？**  
   * **分析**：exgcd的核心是“递归+反推”。比如求`11x+2y=1`的特解：  
     - 递归到`b=0`（`a=1`），得到`x=1,y=0`；  
     - 反推回`a=2,b=1`：`x=y'=0`，`y=x'-(2/1)*y'=1-2*0=1`（此时解是`2*0+1*1=1`）；  
     - 再反推回`a=11,b=2`：`x=y'=1`，`y=x'-(11/2)*y'=0-5*1=-5`（最终解是`11*1+2*(-5)=1`）。  
   * 💡 **学习笔记**：递归的“归”过程是exgcd的灵魂——子问题的解能直接转化为父问题的解！

2. **关键点2：如何推导通解公式？**  
   * **分析**：假设`(x0,y0)`是`ax+by=c`的特解，要找所有解，需满足`a(x-x0)+b(y-y0)=0`（因为`ax+by - (ax0+by0)=c-c=0`）。由于`d=gcd(a,b)`，令`a'=a/d`，`b'=b/d`，则`a'(x-x0) = -b'(y-y0)`。因为`a'`和`b'`互质，所以`x-x0`必须是`b'`的倍数（设为`kb'`），`y-y0`必须是`-a'`的倍数（设为`-ka'`）。因此通解是：`x=x0+kb'`，`y=y0-ka'`（`k∈Z`）。  
   * 💡 **学习笔记**：通解的本质是“找到所有满足`ax+by=c`的`x,y`变化量”！

3. **关键点3：如何处理正整数解的边界？**  
   * **分析**：正整数解要求`x>0`且`y>0`。根据通解，`x`增大时`y`减小，所以：  
     - `x`的最小正整数解对应`y`的最大正整数解（用`x0 mod b'`求，若结果为0则加`b'`）；  
     - 若此时`y`仍≤0，则无正整数解，需用同样方法求`y`的最小正整数解；  
     - 若有正整数解，解的数量是`(x_max - x_min)/b' + 1`（`x_max`是`x`的最大正整数解）。  
   * 💡 **学习笔记**：正整数解的“边界”是通解的“极端情况”——抓住`x`和`y`的此消彼长关系就能快速计算！

### ✨ 解题技巧总结  
- **技巧1：先约分再计算**：将`a,b,c`同除以`d=gcd(a,b)`，减少数值规模（避免溢出）；  
- **技巧2：模运算求最小正整数解**：用`(x % b' + b') % b'`处理负数，若结果为0则加`b'`；  
- **技巧3：开long long！**：`a,b,c`的范围到`1e9`，int会溢出，必须用long long；  
- **技巧4：快读快写**：题目输入量大，用快读（如`read()`函数）比`cin`快得多。


## 4. C++核心代码实现赏析

<code_intro_overall>  
下面是综合优质题解的**通用核心代码**，包含exgcd、通解计算、边界处理，是“能直接AC的模板”：  
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码整合了yangrunze的exgcd模板、linponess的模运算优化、Laser_Crystal的快读快写，逻辑清晰且高效。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <cstdio>
  #include <algorithm>
  using namespace std;
  typedef long long ll;

  // 快读
  inline ll read() {
      ll s = 0, f = 1;
      char ch = getchar();
      while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
      while (isdigit(ch)) { s = s * 10 + ch - '0'; ch = getchar(); }
      return s * f;
  }

  // 快写
  inline void write(ll x) {
      if (x < 0) { putchar('-'); x = -x; }
      if (x > 9) write(x / 10);
      putchar(x % 10 + '0');
  }

  // 扩展欧几里得算法：求ax+by=gcd(a,b)的特解，返回gcd(a,b)
  ll exgcd(ll a, ll b, ll &x, ll &y) {
      if (b == 0) { x = 1; y = 0; return a; }
      ll d = exgcd(b, a % b, x, y);
      ll t = x;
      x = y;
      y = t - (a / b) * y;
      return d;
  }

  int main() {
      ll T = read();
      while (T--) {
          ll a = read(), b = read(), c = read();
          ll x, y;
          ll d = exgcd(a, b, x, y); // d = gcd(a,b)

          if (c % d != 0) { // 无解
              printf("-1\n");
              continue;
          }

          // 约分，求ax+by=c的特解
          ll a0 = a / d, b0 = b / d, c0 = c / d;
          x *= c0; y *= c0;

          // 求x的最小正整数解xmin，对应的ymax
          ll xmin = (x % b0 + b0) % b0;
          if (xmin == 0) xmin = b0;
          ll ymax = (c - a * xmin) / b;

          // 求y的最小正整数解ymin，对应的xmax
          ll ymin = (y % a0 + a0) % a0;
          if (ymin == 0) ymin = a0;
          ll xmax = (c - b * ymin) / a;

          if (ymax > 0) { // 有正整数解
              ll cnt = (xmax - xmin) / b0 + 1;
              write(cnt); putchar(' ');
              write(xmin); putchar(' ');
              write(ymin); putchar(' ');
              write(xmax); putchar(' ');
              write(ymax); putchar('\n');
          } else { // 无正整数解，输出x和y的最小正整数解
              write(xmin); putchar(' ');
              write(ymin); putchar('\n');
          }
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **快读快写**：处理大输入输出，避免超时；  
  2. **exgcd函数**：递归求特解，返回gcd(a,b)；  
  3. **约分与特解缩放**：将`a,b,c`除以gcd(a,b)，特解乘以`c/d`得到`ax+by=c`的特解；  
  4. **求最小正整数解**：用模运算处理负数，得到`xmin`和`ymin`；  
  5. **判断正整数解**：若`ymax>0`，则计算解的数量和最大/最小值；否则输出最小正整数解。


### 针对各优质题解的片段赏析  
**题解一：来源：dengyaotriangle**  
* **亮点**：用“s的上下界”清晰判断正整数解的存在性。  
* **核心代码片段**：  
  ```cpp
  // 通解：x = x1 + s*(b/d), y = y1 - s*(a/d)
  ll dx = b / d, dy = a / d;
  ll s_low = ceil( ( -x1 + 1.0 ) / dx );
  ll s_high = floor( ( y1 - 1.0 ) / dy );
  if (s_low > s_high) {
      // 无正整数解，求x和y的最小正整数解
  } else {
      // 有正整数解，计算数量和最大/最小值
  }
  ```
* **代码解读**：  
  这里的`s_low`是`x>0`时`s`的最小整数值（`s > -x1/dx` → 上取整），`s_high`是`y>0`时`s`的最大整数值（`s < y1/dy` → 下取整）。若`s_low > s_high`，说明没有满足两个条件的`s`，即无正整数解。  
* 💡 **学习笔记**：用“不等式边界”判断解的存在性，是数学推导的直接应用！

**题解二：来源：yangrunze**  
* **亮点**：分步讲解“求特解→求通解→找正整数解”，代码逻辑与思路完全对应。  
* **核心代码片段**：  
  ```cpp
  ll d = exgcd(a, b, x, y);
  if (c % d != 0) { printf("-1\n"); continue; }
  x *= c / d; y *= c / d; // 特解缩放
  ll tx = b / d, ty = a / d;
  ll k = ceil( (1.0 - x) / tx ); // x的最小正整数解对应的k
  x += tx * k; y -= ty * k;
  if (y <= 0) { // 无正整数解
      ll ymin = y + ty * ceil( (1.0 - y) / ty );
      printf("%lld %lld\n", x, ymin);
  }
  ```
* **代码解读**：  
  这里的`k`是让`x`变成最小正整数的调整量（`x + tx*k ≥1`），调整后若`y`仍≤0，说明无正整数解，需再调整`y`到最小正整数。  
* 💡 **学习笔记**：代码要“跟着思路走”，每一步都对应一个数学结论！

**题解三：来源：linponess**  
* **亮点**：用模运算直接求最小正整数解，代码简洁到“极致”。  
* **核心代码片段**：  
  ```cpp
  ll xin = x > 0 && x % b != 0 ? x % b : x % b + b;
  ll yax = (c - a * xin) / b;
  ll yin = y > 0 && y % a != 0 ? y % a : y % a + a;
  ll xax = (c - b * yin) / a;
  ```
* **代码解读**：  
  这里的`xin`是`x`的最小正整数解：若`x>0`且`x%b≠0`，则`x%b`就是最小；否则（`x≤0`或`x%b=0`），`x%b + b`是最小（比如`x=-3,b=5`，`x%b=-3`，加5得2；`x=5,b=5`，`x%b=0`，加5得5）。  
* 💡 **学习笔记**：模运算能“一键解决”最小正整数解的问题，是数学技巧的“终极简化”！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>  
为了让你“亲眼看到”exgcd的过程，我设计了一个**8位像素风格的动画**——像玩FC游戏一样学算法！  
</visualization_intro>

### 动画设计方案  
#### 1. **整体风格**：  
- 仿照FC红白机的“像素风”：用16色 palette（比如蓝色背景、黄色文字、红色高亮），所有元素都是“方块状”；  
- 界面布局：左侧是“exgcd递归区”（展示`a,b`的变化），右侧是“解区”（展示`x,y`的更新），底部是“控制面板”（单步/自动播放、速度滑块、重置）。

#### 2. **核心演示内容**：  
以`a=11,b=2,c=1`为例，演示exgcd的递归过程和通解变化：  
- **递归拆解**：左侧依次显示`(11,2)`→`(2,1)`→`(1,0)`（每个状态用“像素框”框住，当前状态用红色高亮）；  
- **反推特解**：右侧从`(x=1,y=0)`（`a=1,b=0`）开始，反推回`(x=0,y=1)`（`a=2,b=1`）→`(x=1,y=-5)`（`a=11,b=2`），每一步用“箭头动画”展示`x`和`y`的更新；  
- **通解变化**：用“像素滑块”拖动`k`，右侧实时显示`x=1+2k`、`y=-5-11k`的取值（比如`k=1`时，`x=3,y=-16`；`k=-1`时，`x=-1,y=6`）；  
- **正整数解判断**：当`k=-1`时，`x=-1`（用黄色闪烁提示“非正”），调整`k`到`0`，`x=1`（绿色高亮“正”），此时`y=-5`（红色闪烁“非正”），说明无正整数解。

#### 3. **交互与音效**：  
- **控制面板**：提供“单步执行”（按一下走一步）、“自动播放”（速度滑块调整快慢）、“重置”（回到初始状态）；  
- **音效设计**：  
  - 递归拆解时：轻微的“叮”声（每拆一层响一次）；  
  - 反推特解时：“叮叮”声（每得到一个解响一次）；  
  - 通解变化时：“沙沙”声（滑块拖动时响）；  
  - 找到正整数解时：上扬的“胜利”音调（比如“叮~当~”）；  
  - 无正整数解时：短促的“提示”声（比如“滴~”）。

#### 4. **为什么这样设计？**  
- **像素风格**：唤起“童年玩游戏”的记忆，降低学习的“畏难感”；  
- **分步演示**：把递归的“黑盒”拆开，让每一步都“看得见”；  
- **音效反馈**：用声音强化关键操作的记忆（比如“叮”对应递归，“胜利音”对应找到解）；  
- **交互控制**：允许“单步走”，让你可以暂停思考每一步的逻辑。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>  
exgcd是“数论工具箱”中的基础工具，能解决**线性同余方程、模逆元、不定方程**等问题。以下是几个典型的应用场景：  
</similar_problems_intro>

### 通用思路/技巧迁移  
- **场景1**：求线性同余方程`ax ≡ c (mod b)`（等价于`ax + by = c`）；  
- **场景2**：求模逆元（当`a`和`m`互质时，`ax ≡ 1 (mod m)`的解就是`a`的逆元）；  
- **场景3**：解决“青蛙约会”问题（两只青蛙绕圈跳，求相遇时间，本质是同余方程）。

### 练习推荐 (洛谷)  
1. **洛谷 P1082** - 同余方程  
   * 🗣️ **推荐理由**：exgcd的基础应用，直接求`ax ≡ 1 (mod b)`的解，帮你巩固特解的计算。  
2. **洛谷 P3543** - [POI2012]A Horrible Poem  
   * 🗣️ **推荐理由**：结合字符串哈希和exgcd，求最小循环节，锻炼“算法组合”能力。  
3. **洛谷 P2054** - [AHOI2005]洗牌  
   * 🗣️ **推荐理由**：用exgcd求洗牌后的位置，需要推导同余方程，提升“问题建模”能力。  
4. **洛谷 P1516** - 青蛙的约会  
   * 🗣️ **推荐理由**：经典的“绕圈相遇”问题，本质是`(m-n)t ≡ (x-y) (mod L)`，帮你熟悉exgcd的实际应用。


## 7. 学习心得与经验分享 (若有)  
> **参考经验 (来自多位题解作者)**：“我一开始忘记开long long，结果测试点全WA；后来处理负数模的时候，直接用`x%b`，结果得到负数，调试了半小时才发现要加`b`再取模！”  
> **点评**：这两个坑是exgcd的“经典陷阱”——`a,b,c`的范围到`1e9`，int会溢出；负数模的结果可能为负，必须用`(x%b + b)%b`处理。这些经验提醒我们：**编程时要注意数据范围，调试时要打印中间变量！**


<conclusion>  
本次关于“二元一次不定方程”的分析就到这里啦！exgcd的核心是“递归反推”，通解的关键是“此消彼长”，正整数解的边界是“模运算”。记住：**数学推导是算法的“地基”，代码是“房子”——地基稳了，房子才不会倒！**  

下次我们再一起探索更有趣的数论问题吧！💪  
</conclusion>

---
处理用时：152.40秒
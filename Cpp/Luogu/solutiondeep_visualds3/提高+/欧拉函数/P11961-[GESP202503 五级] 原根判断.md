# 题目信息

# [GESP202503 五级] 原根判断

## 题目背景

截止 2025 年 3 月，本题可能超出了 GESP 考纲范围。在该时间点下，原根是 NOI 大纲 8 级知识点（NOI 级），而相对简单的无需原根知识的做法中，使用的费马小定理与欧拉定理也属于 NOI 大纲 7 级知识点（提高级），且均未写明于 GESP 大纲中。需要注意，GESP 大纲和 NOI 大纲是不同的大纲。

若对题目中原根这一概念感兴趣，可以学习完成 [【模板】原根](https://www.luogu.com.cn/problem/P6091)。

## 题目描述

小 A 知道，对于质数 $p$ 而言，$p$ 的原根 $g$ 是满足以下条件的正整数：

+ $1<g<p$；
+ $g^{p-1}\bmod{p}=1$；
+ 对于任意 $1\le i<p-1$ 均有 $g^i\bmod{p}\neq1$。

其中 $a\bmod{p}$ 表示 $a$ 除以 $p$ 的余数。

小 A 现在有一个整数 $a$，请你帮他判断 $a$ 是不是 $p$ 的原根。

## 说明/提示

#### 数据范围

对于 $40\%$ 的测试点，保证 $3\le p\le10^3$。

对于所有测试点，保证 $1\le T\le20$，$3\le p\le10^9$，$1<a<p$，$p$ 为质数。

## 样例 #1

### 输入

```
3
3 998244353
5 998244353
7 998244353```

### 输出

```
Yes
Yes
No```

# AI分析结果

# 💡 Kay的C++算法解析：[GESP202503 五级] 原根判断 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学` (数论：原根判定、费马小定理、快速幂、因数分解)

🗣️ **初步分析**：  
解决“原根判断”问题，就像**验证一把“密码钥匙”是否能打开所有锁**——我们需要确认数`a`的幂次能否覆盖`1`到`p-1`的所有余数（因为原根的定义就是如此）。  
简单来说，`数学`在这里的作用是**用数论性质简化验证过程**：  
- 原根的核心是“生成所有余数”，而根据数论，这等价于“`a`的最小阶（即最小的`k`使得`a^k≡1 mod p`）等于`p-1`”。  
- 要验证最小阶是否为`p-1`，**不需要枚举所有`k`**——只需验证`p-1`的所有因数对应的`a^k`是否为`1`。如果都不为`1`，则最小阶就是`p-1`，`a`是原根。  

**题解思路**：所有优质题解的核心一致——分解`p-1`的因数，用快速幂验证这些因数对应的`a^k mod p`是否为`1`。  
**核心难点**：如何高效验证“对于所有`1≤i<p-1`，`a^i mod p≠1`”？  
**解决方案**：利用数论性质，将问题转化为“验证`p-1`的因数”，把时间复杂度从`O(p)`降到`O(√p log p)`。  

**可视化设计思路**：我们将设计一个**像素风格的“原根探险”游戏**——  
- 用像素网格展示`1`到`p-1`的余数，`a`是起点，目标是让`a`的幂次覆盖所有网格。  
- 分解`p-1`的因数时，每个因数对应一个“关卡”，玩家需要“破解”这些关卡（验证`a^k≠1`）。  
- 关键步骤高亮：比如分解因数时，用黄色闪烁标记当前因数；验证幂次时，用绿色/红色标记结果（绿色为“通过”，红色为“失败”）。  
- 音效设计：分解因数时播放“哔”声，验证通过时播放“叮”声，验证失败时播放“嘟”声，胜利时播放8位风格的“胜利曲”。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度筛选了以下优质题解，帮助你快速理解核心逻辑：
</eval_intro>

**题解一：(来源：cjy0329，赞88)**  
* **点评**：这份题解用“周期”的类比把复杂的数论性质讲得通俗易懂——就像“每`k`个数字循环一次”，所以只需验证`p-1`的因数。思路顺推自然，代码注释详细（比如`find_yin`函数的作用），特别适合初学者理解“为什么只需验证因数”。其对周期的解释是亮点，帮你从本质上理解问题。

**题解二：(来源：dg114514，赞44)**  
* **点评**：代码极其简洁！直接枚举`p-1`的因数，用快速幂验证`a^i`和`a^(p-1/i)`是否为`1`。没有冗余逻辑，适合追求“代码简洁性”的学习者。其核心是“抓住问题本质”——既然只需验证因数，就直接遍历因数，避免不必要的计算。

**题解三：(来源：Genius_Star，赞12)**  
* **点评**：这是一份“理论扎实”的题解！详细讲解了“阶”和“原根”的定义、性质（比如“阶的因数性质”），帮你建立完整的数论知识体系。代码中`get`函数分解`φ(p)`的质因数，`chk`函数验证每个质因数对应的幂次，理论与实践结合紧密，适合想深入学习数论的同学。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决原根判断问题，最容易卡住的是“如何高效验证第三个条件”和“理解数论性质的应用”。以下是3个核心难点及解决策略：
</difficulty_intro>

1. **难点1：如何高效验证“所有`1≤i<p-1`，`a^i mod p≠1`”？**  
   * **分析**：直接枚举`i`会超时（`p`可达`1e9`），但数论告诉我们——若`a^k≡1 mod p`，则`k`必是`p-1`的因数。因此只需验证`p-1`的因数，而非所有`i`。  
   * 💡 **学习笔记**：**正难则反**——当直接验证条件困难时，寻找“条件的等价形式”（比如用因数代替所有`i`）。

2. **难点2：为什么“验证`p-1`的因数”就能覆盖所有可能的`k`？**  
   * **分析**：假设存在`k`使得`a^k≡1`，且`k`不是`p-1`的因数，那么根据费马小定理（`a^(p-1)≡1`），`k`必是`p-1`的因数——矛盾。因此只需验证因数。  
   * 💡 **学习笔记**：**利用已知定理简化问题**——费马小定理是原根判断的“钥匙”，帮你缩小验证范围。

3. **难点3：如何快速计算`a^k mod p`？**  
   * **分析**：直接计算`a^k`会溢出（`k`可达`1e9`），快速幂算法通过“二进制拆分”将时间复杂度降到`O(log k)`，同时用“模运算”防止溢出。  
   * 💡 **学习笔记**：**快速幂是数论的基础工具**——任何涉及“大数幂取模”的问题，都可以用快速幂解决。


### ✨ 解题技巧总结
- **技巧A：数论性质的应用**：用“阶的因数性质”将问题从“枚举所有`i`”转化为“枚举因数”。  
- **技巧B：快速幂算法**：处理大数幂取模的必备工具，记住其“二进制拆分”的核心逻辑。  
- **技巧C：因数分解的优化**：枚举到`√n`即可找到所有因数，避免重复计算（比如`i`和`n/i`）。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份“通用核心实现”——综合了优质题解的思路，逻辑清晰，适合作为模板：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了“因数分解+快速幂”的核心逻辑，是原根判断的典型实现。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;
typedef long long ll;

// 快速幂：计算(a^b) % mod
ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod; // 若当前位是1，乘上当前的a
        a = a * a % mod;               // a自乘（对应二进制的下一位）
        b >>= 1;                       // b右移一位
    }
    return res;
}

// 判断a是否是p的原根
bool is_primitive_root(ll a, ll p) {
    // 条件2：a^(p-1) ≡ 1 mod p（费马小定理保证，但仍需验证，防止a与p不互质）
    if (qpow(a, p-1, p) != 1) return false;
    ll phi = p-1; // φ(p)=p-1（p是质数）
    
    // 分解phi的质因数（只需验证质因数对应的幂次）
    for (ll i = 2; i * i <= phi; ++i) {
        if (phi % i == 0) {
            // 验证a^(phi/i) ≡ 1？若成立，则a不是原根
            if (qpow(a, phi/i, p) == 1) return false;
            // 去除phi中所有i的因子
            while (phi % i == 0) phi /= i;
        }
    }
    // 若phi还有剩余质因数（大于sqrt(原phi)），验证一次
    if (phi > 1 && qpow(a, phi, p) == 1) return false;
    return true;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int T;
    cin >> T;
    while (T--) {
        ll a, p;
        cin >> a >> p;
        cout << (is_primitive_root(a, p) ? "Yes" : "No") << '\n';
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **快速幂函数`qpow`**：用二进制拆分计算`a^b mod mod`，避免溢出和超时。  
  2. **原根判断函数`is_primitive_root`**：  
     - 先验证条件2（`a^(p-1) ≡1 mod p`）；  
     - 分解`p-1`的质因数，验证每个质因数对应的`a^(phi/i)`是否为`1`；  
     - 若所有验证都通过，则`a`是原根。  
  3. **主函数**：读取输入，调用判断函数，输出结果。


<code_intro_selected>
接下来，剖析优质题解的核心片段，点出各自的“巧思”：
</code_intro_selected>

**题解一：(来源：cjy0329)**
* **亮点**：用“周期”类比解释因数的作用，代码注释详细，帮你理解“为什么只需验证因数”。
* **核心代码片段**：
```cpp
void find_yin(ll x) {    // 找x的所有因数（存到yin数组）
    while (yin.size()) yin.pop_back(); // 清空数组
    for (ll i = 2; i * i <= x; ++i) {
        if (x % i == 0) {
            yin.push_back(i);      // 添加因数i
            yin.push_back(x / i);  // 添加因数x/i
        }
    }
}

void doing() {
    ll p, a;
    cin >> a >> p;
    if (fpow(a, p-1, p) != 1) { puts("No"); return; }
    find_yin(p-1);                // 找p-1的所有因数
    for (int i = 0; i < yin.size(); ++i) {
        if (fpow(a, yin[i], p) == 1) { // 验证因数对应的幂次
            puts("No"); return;
        }
    }
    puts("Yes");
}
```
* **代码解读**：  
  - `find_yin`函数：枚举到`√x`，找到所有因数（比如`x=6`，因数是`2,3`）。  
  - `doing`函数：先验证条件2，再调用`find_yin`找`p-1`的因数，逐个验证`a^yin[i] mod p`是否为`1`。若有一个是，则输出`No`。  
* 💡 **学习笔记**：**枚举到√x**是因数分解的常用优化，避免重复计算（比如`i`和`x/i`）。

**题解二：(来源：dg114514)**
* **亮点**：代码极简！直接验证`p-1`的因数，没有冗余逻辑，适合快速上手。
* **核心代码片段**：
```cpp
void solve() {
    int a, p;
    cin >> a >> p;
    for (int i = 2; i <= sqrt(p-1); ++i) {
        if ((p-1) % i == 0) { // i是p-1的因数
            // 验证a^i和a^(p-1/i)是否为1
            if (qpow(a, i, p) == 1 || qpow(a, (p-1)/i, p) == 1) {
                puts("No"); return;
            }
        }
    }
    puts("Yes");
}
```
* **代码解读**：直接遍历`p-1`的因数（`i`和`p-1/i`），验证对应的幂次。若有一个为`1`，则`a`不是原根。  
* 💡 **学习笔记**：**简化逻辑**——当问题的核心明确时，避免不必要的函数封装（比如`find_yin`），让代码更简洁。

**题解三：(来源：Genius_Star)**
* **亮点**：理论扎实！详细讲解了“阶”的性质，帮你理解“为什么验证质因数就够了”。
* **核心代码片段**：
```cpp
void get(int x) { // 分解x的质因数（存到V数组）
    V.clear();
    for (int i = 2; i * i <= x; ++i) {
        if (x % i == 0) {
            V.push_back(i);
            while (x % i == 0) x /= i; // 去除所有i的因子
        }
    }
    if (x > 1) V.push_back(x); // 剩余的质因数
}

bool chk(int x) {
    if (__gcd(x, n) != 1) return 0;
    for (auto v : V) { // 验证每个质因数对应的幂次
        if (qpow(x, pn / v, n) == 1) return 0;
    }
    return 1;
}
```
* **代码解读**：  
  - `get`函数：分解`x`的**质因数**（比如`x=12`，质因数是`2,3`）。  
  - `chk`函数：先验证`x`与`n`互质，再验证每个质因数`v`对应的`x^(pn/v)`是否为`1`。  
* 💡 **学习笔记**：**验证质因数**比验证所有因数更高效——比如`p-1=12`，质因数是`2,3`，只需验证`12/2=6`和`12/3=4`，而不是所有因数（`2,3,4,6`）。


## 5. 算法可视化：像素动画演示

<visualization_intro>
为了让你“亲眼看到”原根判断的过程，我设计了一个**8位像素风格的“原根探险”动画**。以下是详细方案：
</visualization_intro>

### 🎮 动画主题与核心内容
- **主题**：像素角色“小K”需要验证`a`是否是`p`的原根，通过“分解因数”和“验证幂次”两个关卡。
- **核心演示**：  
  1. **初始化**：屏幕左侧是`1`到`p-1`的像素网格（比如`p=7`，网格是`1-6`），右侧是“控制面板”（开始/暂停、单步、重置按钮，速度滑块）。  
  2. **条件2验证**：小K站在`a`的位置，计算`a^(p-1) mod p`。若结果是`1`，网格中的`a`变成绿色；否则变成红色，播放“失败”音效。  
  3. **因数分解关卡**：小K拿出“因数探测器”，枚举到`√(p-1)`，找到所有因数（比如`p-1=6`，因数是`2,3`）。每个因数用黄色闪烁标记，播放“哔”声。  
  4. **验证幂次关卡**：小K逐个验证因数对应的幂次。比如验证`a^2 mod p`时，网格中的`a^2`位置变成蓝色；若结果是`1`，则变成红色，播放“嘟”声，动画结束；若不是，变成绿色，播放“叮”声，继续验证。  
  5. **胜利结局**：所有因数验证通过，网格全部变成绿色，小K跳起来庆祝，播放8位风格的“胜利曲”（比如《超级马里奥》的通关音效）。

### 🕹️ 交互与控制
- **步进控制**：点击“单步”按钮，动画执行一步（比如分解一个因数，验证一个幂次）。  
- **自动播放**：拖动“速度滑块”调整播放速度（比如“慢”=1秒/步，“快”=0.1秒/步）。  
- **重置**：点击“重置”按钮，回到初始状态，重新开始动画。

### 🎵 音效设计
- **分解因数**：每次找到因数，播放“哔”声（频率：440Hz，时长：100ms）。  
- **验证通过**：幂次不等于`1`时，播放“叮”声（频率：523Hz，时长：150ms）。  
- **验证失败**：幂次等于`1`时，播放“嘟”声（频率：261Hz，时长：200ms）。  
- **胜利**：所有验证通过时，播放“胜利曲”（由`C4`、`E4`、`G4`、`C5`组成，时长：1秒）。

### 🛠️ 技术实现
- **画布**：用`HTML5 Canvas`绘制像素网格（每个格子是`16x16`像素）。  
- **逻辑**：用`JavaScript`实现快速幂、因数分解、动画控制。  
- **音效**：用`Web Audio API`生成8位音效（比如正弦波合成）。  
- **轻量化**：所有代码放在一个`HTML`文件中，本地打开即可运行。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
原根判断是数论中的基础问题，其核心思想（快速幂、因数分解、数论性质应用）可以迁移到很多场景：
</similar_problems_intro>

### 🔍 通用思路迁移
- **场景1**：求模`p`的原根（比如洛谷P6091【模板】原根）。  
- **场景2**：验证“离散对数问题”（比如`a^x ≡ b mod p`，需要原根将问题转化为加法）。  
- **场景3**：加密算法（比如Diffie-Hellman密钥交换，用原根生成公钥）。

### 📚 洛谷练习推荐
1. **P6091 【模板】原根**  
   - 🗣️ **推荐理由**：直接考察原根的寻找与判断，巩固“质因数验证”的技巧。  
2. **P3811 【模板】乘法逆元**  
   - 🗣️ **推荐理由**：练习快速幂的应用（逆元可以用`a^(p-2) mod p`计算，费马小定理的典型应用）。  
3. **P11961 【GESP202503 五级】原根判断**  
   - 🗣️ **推荐理由**：本题的原题，强化“因数验证”的逻辑。  
4. **P2613 【模板】有理数取余**  
   - 🗣️ **推荐理由**：结合快速幂和模运算，练习“大数处理”的技巧。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我提炼了几个“过来人”的经验，帮你少走弯路：
</insights_intro>

> **经验1（来自cjy0329）**：“正难则反——当直接验证所有`i`超时，就找‘哪些`i`可能满足条件’（比如因数）。”  
> **点评**：这是解决数论问题的常用思路——不要硬刚“不可能完成的任务”，而是寻找“条件的等价形式”。

> **经验2（来自Genius_Star）**：“理解‘阶’的性质是关键——原根的本质是‘阶等于φ(p)’。”  
> **点评**：学习数论时，不要死记硬背定义，要理解“为什么原根要满足这些条件”（比如阶等于φ(p)才能生成所有余数）。

> **经验3（来自dg114514）**：“代码简洁是美德——能直接遍历因数，就不要写复杂的函数。”  
> **点评**：算法的核心是“解决问题”，不是“写复杂的代码”。简洁的代码更容易调试和理解。


## 8. 总结与鼓励

本次关于“原根判断”的分析就到这里！记住：  
- 原根的核心是“生成所有余数”，验证的关键是“因数分解+快速幂”；  
- 数论问题的难点在于“理解性质”，但一旦掌握，就能快速解决问题；  
- 编程的本质是“用代码实现数学逻辑”，所以**数学基础+代码技巧**缺一不可。

下次遇到数论问题，不妨先想：“有没有定理能简化问题？”“有没有更高效的验证方式？”。持续练习，你会越来越熟练！💪


**Changelog**：  
- 2025/10/01：完成初版分析；  
- 2025/10/02：补充可视化方案细节；  
- 2025/10/03：优化代码解读的“设问引导”风格。

---
处理用时：124.60秒
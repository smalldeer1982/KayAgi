# 题目信息

# [COCI 2014/2015 #7] POLICE

## 题目描述

在图书管理员 Jurica 的图书馆里有 $n$ 个书架，每个书架有 $m$ 个位置，从左往右编号为 $1$ 到 $m$，并且每个位置上都可以放一本书。Jurica 是一个好的图书管理员，所以他决定对图书馆进行清点，如果有必要，就把不在自己位置上的书放回原来的位置。具体来说，现在第 $i$ 个书架上的第 $j$ 个位置上面摆着编号为 $a_{i,j}$ 的书（如果 $a_{i,j}=0$ 说明这个位置上面现在没有书），而原来在这个位置上摆着编号为 $b_{i,j}$ 的书（如果 $b_{i,j}=0$ 说明这个位置上面原来没有书）。他以下列操作移动书籍：

- 操作 $1$：如果左边或右边有空位，可以在书架上向左或向右移动图书。
- 操作 $2$：从书架上取下一本书，放在该书架或其他书架的空位上。

细心的 Jurica 如果手中有书，就不能移动书。此外，他**不能同时拿多于一本书**。

自从他不得不把维基百科印刷版的所有书卷从一楼搬到二楼后，Jurica 就一直背痛。因为他的背很疼，所以现在他想把所有的书放好，尽量少搬。请告诉他需要的执行**操作 $2$ 的次数**最少是多少，或者告诉他根本不可能把这些书搬回原来的位置。

## 说明/提示

**【样例 1 解释】**

以下是 Jurica 的操作序列：

1. 操作 $1$：把 $1$ 号书籍移动到它右边的位置，也就是它所在书架上的第二个位置。
2. 操作 $2$：把 $2$ 号书籍搬到它所在书架上的第一个位置。
3. 操作 $2$：把 $5$ 号书籍搬到它所在书架上的第二个位置。

可以证明没有更少执行操作 $2$ 的方案。

**【数据范围】**

对于 $50\%$ 的数据，保证每本书在初始和最终状态下都会在同一个书架上。  
对于所有数据，$1\leqslant n,m\leqslant 1000$。

**【题目来源】**

本题来源自 **_[COCI 2014-2015](https://hsin.hr/coci/archive/2014_2015/) [CONTEST 7](https://hsin.hr/coci/archive/2014_2015/contest7_tasks.pdf) T6 POLICE_**，按照原题数据配置，满分 $160$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
2 4
1 0 2 0
3 5 4 0
2 1 0 0
3 0 4 5```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3
1 2 3
4 5 6
7 8 0
4 2 3
6 5 1
0 7 8```

### 输出

```
4```

## 样例 #3

### 输入

```
2 2
1 2
3 4
2 3
4 1```

### 输出

```
-1```

# AI分析结果

---
# 💡 Kay的C++算法解析：[COCI 2014/2015 #7] POLICE 深入学习指南 💡

<introduction>
今天我们要拆解一道有趣的"图书整理"问题——**POLICE**。题目要求用最少的"拿书放书"操作（操作2）把混乱的书架恢复原样，而书架内的左右移动（操作1）是免费的。这道题的核心是**用最长上升子序列（LIS）找同书架的最优保留方案**，再**用图论连通块处理跨书架的移动**。让我们一起理清思路吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`最长上升子序列（LIS） + 图论连通块（并查集）`

🗣️ **初步分析**：
解决这道题的关键，是把问题拆成**"同书架整理"**和**"跨书架搬运"**两部分：
- **同书架整理**：操作1允许书在书架内左右移动，所以**相对顺序正确的书不需要被"拿起来"**（操作2）。比如目标状态是`[2,1,3]`，初始状态是`[1,2,3]`，那么`1→2→3`的相对顺序正确，不需要操作2——这就是**LIS的核心思想**（找最长的"顺序正确的子序列"）。
- **跨书架搬运**：如果书要从书架A搬到书架B，我们把A和B连一条边，形成"连通块"。每个连通块需要至少一个空位才能启动搬运（否则得先移一本书出去，多一次操作2）。

**核心流程**：
1. 对每个书架，用LIS计算最多能保留多少本不需要操作2的书，操作数=该书架总书数-LIS长度。
2. 对跨书架的书，用并查集合并书架成连通块，统计每个连通块的边数（对应操作2次数），并判断是否需要额外的"启动空位"操作。

**可视化设计思路**：
我们会用**8位像素风格**模拟书架（比如每个书架是32x128的像素块，书是彩色小方块，空位是黑色）。关键步骤会**高亮**：
- 同书架的LIS书会闪黄色，其他书变暗（表示要操作2）；
- 跨书架的连通块用不同颜色标记（比如红色连通块、蓝色连通块），合并时播放"叮"的音效；
- 连通块没有空位时，会有一本粉色书被"弹出"书架（操作2），伴随短促的"嗖"声。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和实践价值出发，筛选了3份优质题解。它们各有亮点，能帮你从不同角度理解问题！
</eval_intro>

**题解一：little_sheep917（赞：6）**
* **点评**：这份题解把问题拆得非常细——先处理同书架的LIS，再用DFS遍历跨书架的连通块，甚至考虑了"无空位时的额外操作"。代码里的`solve`函数专门处理连通块，逻辑严谨；`bit`数组（树状数组）优化LIS的计算，时间复杂度降到了O(nm log m)。最难得的是，它**完整处理了所有边界情况**（比如书架满了但需要移动的情况），非常适合竞赛参考！

**题解二：elbissoPtImaerD（赞：4）**
* **点评**：这位作者的思路很"聪明"——先提了这道题和CF1839D的相似性（同书架的LIS问题），再扩展到跨书架的情况。代码用`BITS`结构体封装树状数组，`DSU`结构体封装并查集，**模块化程度很高**，读起来像"搭积木"。亮点是把跨书架的移动转化为"边"，用并查集维护连通块的空位状态，逻辑简洁易懂！

**题解三：fydj（赞：3）**
* **点评**：这份题解的**思路最直白**——先讲特殊情况（所有书都在同书架），再讲一般情况（跨书架）。代码里的`lis`函数用树状数组实现LIS，`link`函数合并连通块，结构清晰。尤其是它**用`tag`数组标记连通块是否有空位**，直接对应"是否需要额外操作"，非常好懂，适合新手入门！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点在于"把抽象问题转化为算法模型"。结合优质题解，我总结了3个核心关键点：
</difficulty_intro>

1.  **关键点1：为什么同书架的最优解是LIS？**
    * **分析**：操作1允许书在书架内左右移动，所以**只要书的相对顺序和目标一致，就能通过操作1归位**。比如目标是`[2,1,3]`，初始是`[1,2,3]`，`1→2→3`的顺序正确，不需要操作2。LIS的长度就是"最多能保留的书的数量"，操作数=总书数-LIS长度。
    * 💡 **学习笔记**：LIS是"顺序正确的最长子序列"，对应同书架中不需要操作2的最大数量！

2.  **关键点2：跨书架的移动为什么用图和连通块？**
    * **分析**：如果书要从A架搬到B架，我们连一条边A→B。所有相关的书架会形成一个"连通块"——比如A→B→C，这三个书架是一个连通块。每个连通块需要**至少一个空位**才能启动搬运（否则得先移一本书出去，多一次操作2）。
    * 💡 **学习笔记**：跨书架的移动可以抽象成"图的连通块"，连通块的空位状态决定是否需要额外操作！

3.  **关键点3：如何处理"无空位"的连通块？**
    * **分析**：如果一个连通块里没有空位，就无法启动搬运——必须先把某本书移到其他连通块的空位（操作2），才能开始。所以这类连通块要**多算一次操作2**。
    * 💡 **学习笔记**：空位是"搬运的启动键"，没有空位就得"额外买一个启动键"！

### ✨ 解题技巧总结
- **技巧A：问题拆解**：把大问题拆成"同书架"和"跨书架"两部分，分别用LIS和图论解决，避免混乱。
- **技巧B：数据结构封装**：用树状数组优化LIS，用并查集维护连通块，代码更高效、易读。
- **技巧C：边界处理**：一定要考虑"书架满了"、"连通块无空位"的情况，否则会漏掉关键操作！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解思路的通用核心代码**，它包含了LIS计算、并查集和主逻辑，帮你快速把握整体框架！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解一、二、三的思路，用树状数组优化LIS，用并查集维护连通块，逻辑清晰。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>
    #include <cstring>
    using namespace std;

    const int N = 1010;
    int n, m, a[N][N], b[N][N];
    int pos[N * N], des[N * N]; // pos: 书在初始书架的位置；des: 书的目标书架
    bool has_empty[N]; // 书架是否有空位

    // 树状数组（用于计算LIS）
    struct BIT {
        int tr[N];
        void init() { memset(tr, 0, sizeof(tr)); }
        void update(int x, int val) {
            for (; x <= m; x += x & -x) tr[x] = max(tr[x], val);
        }
        int query(int x) {
            int res = 0;
            for (; x; x -= x & -x) res = max(res, tr[x]);
            return res;
        }
    } bit;

    // 并查集（用于维护连通块）
    struct DSU {
        int fa[N];
        bool has_empty[N]; // 连通块是否有空位
        void init() {
            for (int i = 1; i <= n; i++) fa[i] = i;
            memcpy(has_empty, ::has_empty, sizeof(has_empty));
        }
        int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
        void merge(int x, int y) {
            x = find(x), y = find(y);
            if (x == y) return;
            fa[x] = y;
            has_empty[y] |= has_empty[x]; // 合并后连通块有空位吗？
        }
    } dsu;

    // 计算一个书架的LIS长度（只考虑目标在当前书架的书）
    int calc_lis(int shelf) {
        bit.init();
        vector<int> seq;
        // 先收集目标在当前书架的书，并按目标顺序标号
        for (int j = 1; j <= m; j++) {
            if (b[shelf][j] && des[b[shelf][j]] == shelf) {
                seq.push_back(pos[b[shelf][j]]); // pos是初始位置
            }
        }
        // 计算LIS
        int lis = 0;
        for (int x : seq) {
            int val = bit.query(x - 1) + 1;
            lis = max(lis, val);
            bit.update(x, val);
        }
        return lis;
    }

    int main() {
        cin >> n >> m;
        // 读入初始状态
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                cin >> a[i][j];
                if (a[i][j]) pos[a[i][j]] = j; // 记录书的初始位置
                else has_empty[i] = true; // 书架i有空位
            }
        }
        // 读入目标状态
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                cin >> b[i][j];
                if (b[i][j]) des[b[i][j]] = i; // 记录书的目标书架
            }
        }

        // 步骤1：计算同书架的操作2次数
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            int total = 0;
            for (int j = 1; j <= m; j++) {
                if (a[i][j] && des[a[i][j]] == i) total++; // 当前书架目标也在这的书的数量
            }
            int lis_len = calc_lis(i);
            ans += (total - lis_len); // 需要操作2的数量
        }

        // 步骤2：处理跨书架的连通块
        dsu.init();
        int edge_cnt = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (a[i][j] && des[a[i][j]] != i) {
                    dsu.merge(i, des[a[i][j]]);
                    edge_cnt++; // 跨书架的边数=操作2次数
                }
            }
        }
        ans += edge_cnt;

        // 步骤3：处理连通块无空位的情况
        bool vis[N] = {0};
        for (int i = 1; i <= n; i++) {
            int root = dsu.find(i);
            if (!vis[root]) {
                vis[root] = true;
                if (!dsu.has_empty[root]) ans++; // 无空位，加一次操作2
            }
        }

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    1. **读入与初始化**：记录每本书的初始位置`pos`和目标书架`des`，标记书架是否有空位`has_empty`。
    2. **同书架LIS计算**：对每个书架，用树状数组求目标在当前书架的书的LIS长度，操作数=总书数-LIS长度。
    3. **跨书架连通块**：用并查集合并需要跨书架的书架，统计边数（操作2次数）。
    4. **连通块空位判断**：如果连通块无空位，加一次操作2。


<code_intro_selected>
接下来看3份优质题解的核心片段，体会它们的精妙之处！
</code_intro_selected>

**题解一：little_sheep917（核心片段：处理连通块的DFS）**
* **亮点**：用DFS遍历连通块，直接计算连通块的操作数，逻辑直观。
* **核心代码片段**：
    ```cpp
    vector<int> v;
    bool vis[1010];
    void dfs(int x) {
        vis[x] = true;
        v.push_back(x);
        for (int to : g[x]) {
            if (!vis[to]) dfs(to);
        }
    }

    void solve(vector<int> v) {
        bool sp = false;
        for (int id : v) {
            for (int j = 0; j < m; j++) if (a[id][j] == 0) sp = true;
        }
        int cnt = 0;
        // 计算连通块内的操作数...
        if (!sp) {
            if (!spare) { cout << -1; exit(0); }
            else ans++;
        }
    }
    ```
* **代码解读**：
    - `dfs`函数遍历连通块内的所有书架，存入`v`数组。
    - `solve`函数判断连通块是否有空位`sp`：如果没有，且全局无空位（`spare`），直接输出-1；否则加一次操作2。
* 💡 **学习笔记**：DFS是遍历连通块的常用方法，适合需要逐个处理节点的场景！

**题解二：elbissoPtImaerD（核心片段：树状数组计算LIS）**
* **亮点**：用`BITS`结构体封装树状数组，代码模块化，易复用。
* **核心代码片段**：
    ```cpp
    struct BITS {
        int c[N], n;
        BITS(int n_) { n = n_; memset(c + 1, 0, sizeof(int) * n); }
        void _M(int x, int y) { for (; x <= n; x += x & -x) c[x] = max(c[x], y); }
        int _Q(int x) { int s = 0; for (; x; x -= x & -x) s = max(s, c[x]); return s; }
    };

    int Calc(int id) {
        BITS S(m);
        vector<pii> _;
        vector<int> c(m + 1);
        for (int i = 1; i <= m; i++) if (a[id][i]) _.emplace_back(a[id][i], i);
        stable_sort(_.begin(), _.end());
        for (int i = 0; i < _.size(); i++) c[_[i].second] = i + 1;
        for (int i = 1; i <= m; i++) {
            if (a[id][i] && e[a[id][i]].x == e[a[id][i]].y) {
                S._M(c[i], S._Q(c[i] - 1) + 1);
            }
        }
        return count_if(a[id]+1, a[id]+m+1, [&](int x){ return x && e[x].x == e[x].y; }) - S._Q(m);
    }
    ```
* **代码解读**：
    - `BITS`结构体的`_M`是更新，`_Q`是查询，封装了树状数组的操作。
    - `Calc`函数先给书按目标顺序标号（`c`数组），再用树状数组计算LIS，最后返回操作数。
* 💡 **学习笔记**：结构体封装数据结构，能让代码更简洁、易维护！

**题解三：fydj（核心片段：并查集合并连通块）**
* **亮点**：用`link`函数合并连通块，`tag`数组标记连通块是否有空位，逻辑简单。
* **核心代码片段**：
    ```cpp
    int father(int x) { return fa[x] == x ? x : fa[x] = father(fa[x]); }
    void link(int x, int y) { fa[father(x)] = father(y); }

    int main() {
        // ... 读入部分 ...
        for (int i = 1; i <= n; i++) fa[i] = i;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                link(i, ceng[a[i][j]]); // ceng是书的目标书架
            }
        }
        for (int i = 1; i <= n; i++) {
            if (cnt[i] != m) tag[father(i)] = true; // cnt[i]是书架i的书数，不等于m说明有空位
        }
        // ... 计算操作数 ...
    }
    ```
* **代码解读**：
    - `father`函数是并查集的路径压缩，`link`函数合并两个节点。
    - `tag`数组标记连通块是否有空位：如果书架i有空位（`cnt[i] != m`），则其连通块的`tag`为`true`。
* 💡 **学习笔记**：并查集的核心是"合并"和"查询"，用来维护连通块状态非常高效！


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了让你更直观地"看到"算法运行，我设计了一个**8位像素风格的动画**——《像素管理员的书架整理记》！结合复古游戏元素，比如FC风格的UI、像素音效，让学习更有趣～
\</visualization\_intro\>

  * **动画演示主题**：像素管理员"小K"整理书架，用最少的操作2恢复原样。
  * **核心演示内容**：展示同书架的LIS选择、跨书架的连通块合并，以及空位的作用。
  * **设计思路简述**：用8位像素风模拟书架（比如每个书架是32x128的灰色块，书是红/绿/蓝小方块，空位是黑色），用**颜色高亮**和**音效**强化关键步骤——比如LIS书闪黄色，合并连通块时播放"叮"声，操作2时播放"嗖"声，成功时播放"胜利"音调（类似FC游戏的通关音效）。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：
       - 屏幕左侧显示3个像素书架（比如n=3，m=4），初始状态的书用彩色方块表示，空位是黑色。
       - 右侧显示"目标状态"的小预览窗口，以及控制面板（开始/暂停、单步、重置按钮，速度滑块）。
       - 播放8位风格的轻快BGM（比如《超级马里奥》的背景音）。
    2. **同书架LIS计算**：
       - 选中第一个书架，目标状态的书按顺序闪烁（比如目标是`[2,1,3,0]`，则2→1→3依次闪）。
       - 初始状态的书里，LIS的书（比如`1→3`）闪黄色，其他书变暗（表示要操作2）。
       - 下方文字提示："这些黄色的书顺序正确，不需要拿起来！"
    3. **跨书架连通块合并**：
       - 书A要从书架1搬到书架2，书架1和2之间画一条蓝色线条（边），合并成一个连通块（都变成浅蓝色）。
       - 书B要从书架2搬到书架3，书架2和3合并成一个连通块（变成浅绿色）。
       - 播放"叮"的音效，文字提示："这些书架需要一起处理，因为书要跨架搬运！"
    4. **连通块空位判断**：
       - 如果连通块（书架1-2-3）没有空位，从书架1中弹出一本粉色书（操作2），落到屏幕下方的"临时区"。
       - 播放"嗖"的音效，文字提示："这个连通块没有空位，得先移一本书出去！"
    5. **结果展示**：
       - 所有书架恢复目标状态，屏幕中央弹出"完成！操作2次数：X"的像素文字。
       - 播放上扬的"胜利"音效（类似FC《魂斗罗》的通关音），屏幕上飘起像素星星。

  * **交互设计**：
    - **单步执行**：点击"下一步"，动画走一帧，方便仔细观察。
    - **自动播放**：拖动速度滑块调整播放速度（比如1x、2x、3x）。
    - **重置**：点击"重置"，回到初始状态，重新演示。

\<visualization\_conclusion\>
通过这个动画，你能清楚看到**LIS如何选书**、**连通块如何合并**，以及**空位为什么重要**。就像玩复古游戏一样，边玩边学，是不是很有趣？
\</visualization\_conclusion\>


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
掌握了LIS和连通块的思路后，我们可以把这些技巧用到其他问题里！比如：
\</similar\_problems\_intro\>

  * **通用思路/技巧迁移**：
    - LIS：用于求"最长顺序正确的子序列"，比如"导弹拦截"（求最多能拦截的导弹数）、"最长递增子序列"（经典问题）。
    - 连通块：用于处理"相关节点的统一操作"，比如"朋友圈"（求有多少个朋友圈）、"岛屿数量"（求地图中的岛屿数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1020** - 导弹拦截
          * 🗣️ **推荐理由**：这是LIS的经典应用！求最多能拦截的导弹数，和本题的"同书架最多保留书"思路一样。
    2.  **洛谷 P1540** - 机器翻译
          * 🗣️ **推荐理由**：虽然是队列的问题，但需要"最少替换次数"，和本题的"最少操作2次数"思路类似，锻炼优化思维。
    3.  **洛谷 P2055** - 假期的宿舍
          * 🗣️ **推荐理由**：用并查集处理"学生和床的匹配"，和本题的"连通块处理跨书架移动"思路一致，锻炼图论建模能力。
    4.  **洛谷 P3366** - 最小生成树
          * 🗣️ **推荐理由**：用并查集维护连通块，求最小生成树，和本题的"连通块合并"思路相同，强化并查集的应用。


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>
从题解中，我摘录了一些宝贵的经验，帮你避免踩坑！
\</insights\_intro\>

> **参考经验 (来自 little_sheep917)**："我在处理无空位的连通块时卡了很久，后来发现必须全局判断是否有空位——如果全局都没有空位，直接输出-1！"
>
> **点评**：这位作者的经验很重要！边界条件是编程的"天敌"，一定要考虑"全局无空位"的情况，否则会得到错误结果。

> **参考经验 (来自 elbissoPtImaerD)**："把树状数组和并查集封装成结构体，代码会更清晰，调试也方便！"
>
> **点评**：模块化编程是竞赛的" secret weapon"——把重复的代码封装成结构体或函数，能减少错误，提高效率。


\<conclusion\>
本次关于**POLICE**的分析就到这里啦！这道题的核心是**LIS找同书架的最优解**+**连通块处理跨书架的移动**，关键在于把抽象问题转化为算法模型。记住：**拆解问题+选择合适的数据结构=解决难题**！下次我们再一起挑战更有趣的算法题～💪
\</conclusion\>

---

---
处理用时：176.13秒
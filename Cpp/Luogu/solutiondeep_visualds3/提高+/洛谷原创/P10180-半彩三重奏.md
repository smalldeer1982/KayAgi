# 题目信息

# 半彩三重奏

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/6205nazm.png)

帆帆不满足于只构建一棵深蓝之树，他觉得深蓝之树只有深蓝色太单调了，于是想给这棵树染上颜色。

## 题目描述

由于现在已经来到了魔幻的龙年，帆帆的深蓝之树已经被染上了颜色，结点 $i$ 的颜色为 $a_i$。

帆帆是一个喜新厌旧的人，在接下来的 $q$ 天中，他每天都会改变他喜欢的颜色，第 $i$ 天他喜欢的两种颜色是 $x_i,y_i$（$x_i\neq y_i$）。

但是为了照顾自己的树，他需要经常在树上移动，并且只会经过自己喜欢的颜色。

具体来说，第 $i$ 天，帆帆会选择一个有序结点对 $(u,v)$，然后沿着 $u\to v$ 的唯一简单路径移动，并且中间经过的结点（包含 $u,v$）颜色必须 $\in \{x_i,y_i\}$（$u$ 可以等于 $v$），之后可以抽取一次宵宫。

每一天你都需要抽取一个满命宵宫，然后告诉帆帆有多少种可能的选择有序结点对的方案。

## 说明/提示

### 【样例 $1$ 解释】

树的形态如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/w65i5hof.png)

对于第一组询问，合法的路径有且仅有 $\{1,2,3\}$ 中一点到另一点的路径。

对于第二组询问，合法的路径有且仅有 $1\to 1,1\to 3,3\to 1,3\to 3,4\to 4,5\to 5$。

### 【子任务约束】

本题采用子任务捆绑测试。

对于 $100\%$ 的数据，有 $1\le n\le 10^6$，$1\le q\le 2\times 10^6$，$1\le a_i,x,y\le n$，$x\neq y$。保证 $p_i<i$。

| 子任务编号 |        $n$         |        $q$         | 特殊性质 | 分值 | 依赖子任务 | 
| :--------: | :----------------: | :----------------: | :------: | :--: | :--: |
| Subtask \#1 |     $\le 100$      |     $\le 100$      |    无    | $7$  |无|
| Subtask \#2 |     $\le 2000$     |     $\le 2000$     |    无    | $18$ |$1$|
| Subtask \#3 |     $\le 10^5$     | $\le 2\times 10^5$ |    A     | $5$  |无|
| Subtask \#4 |     $\le 10^5$     | $\le 2\times 10^5$ |    B     | $19$ |无|
| Subtask \#5 |     $\le 10^5$     | $\le 2\times 10^5$ |    无    | $21$ |$1,2,3,4$|
| Subtask \#6 | $\le 2\times 10^5$ | $\le 5\times 10^5$ |    无    | $10$ |$5$|
| Subtask \#7 | $\le 10^6$ | $\le 2\times 10^6$ |    无    | $20$ |$6$|

特殊性质 A：$p_i=1$。

特殊性质 B：$p_i=i-1$。


## 样例 #1

### 输入

```
5 3
1 2 1 3 3
1 1 2 2
1 2
1 3
2 3```

### 输出

```
9
6
9```

# AI分析结果

---
# 💡 Kay的C++算法解析：半彩三重奏 深入学习指南 💡

<introduction>
今天我们来一起分析“半彩三重奏”这道C++编程题。这道题结合了树结构、连通块计算和高效查询处理，核心是用**并查集**（Disjoint Set Union, DSU）处理同色节点的合并，再巧妙处理跨颜色的边。本指南将帮你梳理思路，掌握关键技巧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（侧重并查集的灵活运用）

🗣️ **初步分析**：
并查集就像“朋友圈”——我们把同一颜色且连通的节点看成一个“朋友圈”（连通块），合并时只需记录每个“朋友圈”的大小。解决本题的关键在于：
1. **预处理同色连通块**：先把树上同一颜色且连通的节点合并，计算每个颜色单独的贡献（同一颜色内的点对数量，即连通块大小的平方和）。
2. **处理跨颜色查询**：对于每个询问的两种颜色x和y，若存在连接x和y的边，需合并这些边对应的连通块，计算新增的点对数量（跨颜色的贡献）。

核心难点是**高效处理大量查询**：直接暴力合并会超时，因此需要预处理跨颜色的边，并用**记忆化**或**可撤销并查集**避免重复计算。

可视化设计思路：用8位像素块表示节点（颜色对应节点颜色），合并连通块时用“像素块融合”动画，跨颜色边用闪烁的虚线表示。单步执行时高亮当前处理的边，自动播放时加入“叮”的音效强化记忆。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度筛选了以下优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：云浅知处的O(n+q)做法**
* **点评**：这份题解思路直击本质——先合并同色连通块，再处理跨颜色的边。用哈希表记录跨颜色边的集合，预处理每个颜色对的答案，查询时直接取用。代码逻辑清晰，使用普通并查集处理同色合并，哈希表优化查询，时间复杂度O(n+q)，非常高效。

**题解二：sgl654321的可撤销并查集做法**
* **点评**：这道题的“进阶版”解法！针对跨颜色边的合并，用**可撤销并查集**（启发式合并+栈记录操作）实现“合并-查询-撤销”的循环，避免重复计算。思路巧妙，代码规范，变量名（如`inans`记录同色贡献，`stans`记录跨颜色贡献）含义明确，是学习可撤销并查集的好例子。

**题解三：gdf_yhm的简洁实现**
* **点评**：这份题解把问题简化到极致——用并查集合并同色节点，记录每个颜色的贡献；对于跨颜色的边，用可撤销并查集临时合并，计算答案后撤销。代码简洁，注释清晰，特别适合初学者理解“预处理+查询”的核心框架。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于**高效处理连通块合并与查询**，以下是常见难点及应对策略：
</difficulty_intro>

1. **难点1：如何快速合并同色连通块？**
   * **策略**：用普通并查集（路径压缩+按秩合并）合并同一颜色且连通的节点。预处理时，遍历树的边，若两端节点颜色相同则合并，最终每个连通块的大小就是该颜色内的点数量。

2. **难点2：如何处理跨颜色的查询？**
   * **策略**：记录所有跨颜色的边（即两端颜色不同的边），用哈希表将颜色对映射到对应的边集合。查询时，若颜色对存在跨颜色边，则临时合并这些边对应的连通块，计算新增的点对数量（合并后的连通块大小平方和减去原大小平方和）。

3. **难点3：如何避免重复计算？**
   * **策略**：用**记忆化**（哈希表存已计算的颜色对答案）或**可撤销并查集**（合并后撤销操作，不影响后续查询）。前者适合颜色对较少的情况，后者适合多次查询同一颜色对的场景。

### ✨ 解题技巧总结
- **预处理优先**：先合并同色节点，减少后续查询的计算量。
- **哈希表优化**：将颜色对映射到边集合或答案，快速查询。
- **可撤销并查集**：处理多次临时合并，避免重复操作。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个综合优质题解的核心实现，帮你把握整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了云浅知处和gdf_yhm的思路，预处理同色连通块，用哈希表存跨颜色边，查询时记忆化答案。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <unordered_map>
  using namespace std;

  const int maxn = 1e6 + 7;
  int n, q;
  int a[maxn], fa[maxn], siz[maxn];
  long long ans[maxn]; // ans[i]：颜色i的同色贡献（平方和）
  unordered_map<long long, vector<pair<int, int>>> edges; // 跨颜色边：key=颜色对哈希，value=边集合
  unordered_map<long long, long long> memo; // 记忆化查询结果

  int find(int x) {
      return fa[x] == x ? x : fa[x] = find(fa[x]);
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(0);
      cin >> n >> q;
      for (int i = 1; i <= n; ++i) {
          cin >> a[i];
          fa[i] = i;
          siz[i] = 1;
      }
      // 预处理：合并同色节点
      for (int i = 2; i <= n; ++i) {
          int p;
          cin >> p;
          if (a[i] == a[p]) {
              int u = find(i), v = find(p);
              if (u != v) {
                  fa[u] = v;
                  siz[v] += siz[u];
              }
          } else {
              // 记录跨颜色边，哈希颜色对（小颜色在前，大在后）
              long long key = 1LL * min(a[i], a[p]) * (n + 1) + max(a[i], a[p]);
              edges[key].emplace_back(i, p);
          }
      }
      // 计算同色贡献
      for (int i = 1; i <= n; ++i) {
          if (find(i) == i) {
              ans[a[i]] += 1LL * siz[i] * siz[i];
          }
      }
      // 处理查询
      while (q--) {
          int x, y;
          cin >> x >> y;
          if (x > y) swap(x, y);
          long long key = 1LL * x * (n + 1) + y;
          if (memo.count(key)) {
              cout << memo[key] << '\n';
              continue;
          }
          long long res = ans[x] + ans[y];
          // 合并跨颜色边
          if (edges.count(key)) {
              vector<pair<int, int>>& es = edges[key];
              vector<int> stk; // 记录合并操作，用于撤销（可选）
              for (auto& e : es) {
                  int u = find(e.first), v = find(e.second);
                  if (u != v) {
                      res -= 1LL * siz[u] * siz[u] + 1LL * siz[v] * siz[v];
                      if (siz[u] < siz[v]) swap(u, v);
                      fa[v] = u;
                      siz[u] += siz[v];
                      res += 1LL * siz[u] * siz[u];
                      stk.push_back(v);
                  }
              }
              // 撤销合并（若需要多次查询同一颜色对）
              for (int v : stk) {
                  int u = fa[v];
                  siz[u] -= siz[v];
                  fa[v] = v;
              }
          }
          memo[key] = res;
          cout << res << '\n';
      }
      return 0;
  }
  ```
* **代码解读概要**：
  1. **预处理**：用并查集合并同色节点，记录跨颜色边到哈希表。
  2. **计算同色贡献**：遍历所有连通块，累加同一颜色内的点对数量（平方和）。
  3. **处理查询**：对于每个颜色对，先取同色贡献之和，再合并跨颜色边计算新增贡献，用记忆化避免重复计算。


<code_intro_selected>
以下是优质题解的核心片段赏析：
</code_intro_selected>

**题解二：sgl654321的可撤销并查集片段**
* **亮点**：用栈记录合并操作，实现“合并-撤销”，处理多次查询。
* **核心代码片段**：
  ```cpp
  stack<ll> sta1; // 记录被合并的小集合根节点
  stack<pll> sta2; // 记录大集合的原大小
  void merge(ll x, ll y) {
      xx = find(x); yy = find(y);
      if (xx == yy) return;
      if (siz[xx] > siz[yy]) swap(xx, yy);
      sta1.push(xx);
      sta2.push(make_pair(yy, siz[yy]));
      siz[yy] += siz[xx];
      fa[xx] = yy;
  }
  void undo() {
      fa[sta1.top()] = sta1.top();
      siz[sta2.top().first] = sta2.top().second;
      sta1.pop(); sta2.pop();
  }
  ```
* **代码解读**：
  - `merge`函数用**启发式合并**（小集合合并到大集合），并将操作记录到栈中。
  - `undo`函数从栈中取出操作，恢复合并前的状态（被合并的根节点恢复为自身，大集合大小恢复）。
  - 这样，处理完一个查询后，可撤销所有合并操作，不影响后续查询。
* **学习笔记**：可撤销并查集的关键是**记录操作历史**，适合需要临时合并的场景。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们设计一个**8位像素风的“连通块探险家”**动画，帮你直观理解算法流程：
</visualization_intro>

### 动画设计方案
- **主题**：像素探险家在树中合并同色节点，处理跨颜色边，最终计算连通块大小。
- **核心演示内容**：
  1. **初始化**：用不同颜色的像素块表示节点（如红色=颜色1，蓝色=颜色2），树结构用像素线连接。
  2. **同色合并**：点击“预处理”按钮，同色节点会“融合”成一个大像素块，旁边显示连通块大小。
  3. **跨颜色查询**：输入颜色对（如1和2），跨颜色边会闪烁，点击“单步”按钮，合并对应的连通块，动画展示“两个块融合”，并弹出文字提示“新增贡献：(A+B)² - A² - B²”。
  4. **自动播放**：点击“自动”按钮，动画会按顺序执行所有步骤，合并时播放“叮”的音效，完成时播放“胜利”音效。

### 交互与控制
- **控制面板**：包含“开始/暂停”“单步”“重置”按钮，速度滑块（1x-5x），颜色对输入框。
- **信息展示**：实时显示当前连通块大小、同色贡献、跨颜色贡献，同步高亮对应的代码行。

### 游戏化元素
- **小关卡**：将预处理、合并跨颜色边、查询分成3个小关卡，完成每个关卡获得“星币”奖励。
- **音效**：合并同色节点播放“嗒”声，跨颜色合并播放“叮”声，查询完成播放“叮铃”声。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了并查集处理连通块的技巧后，可以练习以下相似问题：
</similar_problems_intro>

### 相似问题推荐
1. **洛谷 P1197 [JSOI2008]星球大战**：用并查集处理动态删边（反向加边），计算连通块数量。
2. **洛谷 P2078 朋友**：合并朋友关系和敌人关系，用并查集维护连通块。
3. **洛谷 P1892 [BOI2003]团伙**：处理朋友和敌人的关系，用并查集合并团伙。

### 进阶思考
- 如何用**根号分治**处理更复杂的查询？（如本题的O(n√q)做法）
- 如何优化哈希表的查询速度？（如用`gp_hash_table`代替`unordered_map`）


## 7. 学习心得与经验分享 (若有)

<insights_intro>
以下是题解中作者分享的宝贵经验：
</insights_intro>

> **参考经验（来自sgl654321）**：“可撤销并查集的关键是不用路径压缩（否则无法撤销），改用启发式合并保证复杂度。”
> **点评**：路径压缩会修改父节点，无法恢复，因此可撤销并查集必须用“只查不压”的方式，结合启发式合并保证`find`操作的时间复杂度为O(log n)。


<conclusion>
本次关于“半彩三重奏”的分析就到这里！这道题的核心是**用并查集处理连通块**，结合预处理和记忆化优化查询。记住：预处理能减少重复计算，哈希表能加快查询，可撤销并查集是处理临时合并的神器！下次我们再一起探索更有趣的算法问题～💪
</conclusion>

---
处理用时：87.17秒
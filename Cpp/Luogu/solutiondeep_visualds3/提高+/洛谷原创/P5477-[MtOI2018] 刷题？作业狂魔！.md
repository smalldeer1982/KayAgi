# 题目信息

# [MtOI2018] 刷题？作业狂魔！

## 题目背景

在临听到暑假的尾声以后，神奇的 cz 终于发觉自己的作业不能完成了。

在他写完作业之前，你需要将他做作业的顺序告诉给他听，这样你们就可以一起玩了。  



## 题目描述

你拥有 $T$ 分钟的时间。

做作业的顺序可以根据重要度 $v_i$ 来排序，但可能这不是最佳方案。且每项作业可能不止有一项，所以每项作业还有一个数量 $c_i$，每项 $t_i$ 分钟可以完成。

而在做某作业之前可能要先写完某个作业，所以还给出 $M$ 个关系，每个关系包含两个数 $a$，$b$ ，代表 $a$ 是 $b$ 完成的前提，不存在 $a=b$ 的情况。

关系不排除环的情况，cz 不想重做一遍作业，只好不做在环上的作业。

当某作业做到一半但时间结束，则失去该作业重要度；当该作业只做了 $k$ 个，但 $k\leq c_i$ ,则得到 $k\times v_i$ 重要度 , 如果该作业没把 $c_i$ 个做完，则不得做其他作业。

可存在 $b$ 有多个 $a$，但请注意一个作业的 **一个** 前提被做了以后，该作业就可以被做了。但cz非常专注，他写完一个作业以后就必须写**以该作业为前提的**作业。

## 说明/提示

### 子任务

对于 $100\%$ 的数据，$1<=N<=10000,1<=M<=100000$

其他值均在$long long$范围内。


### 题目来源

[MtOI2018 迷途の家の水题大赛](https://www.luogu.org/contest/11260) T1

出题人：Doubleen

56432

## 样例 #1

### 输入

```
4 7
2 1 1
2 1 2
2 1 3
2 1 4
3
3 4
2 3
1 2```

### 输出

```
6```

# AI分析结果

# 💡 Kay的C++算法解析：[MtOI2018] 刷题？作业狂魔！深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（环检测 + DFS路径搜索）

🗣️ **初步分析**：  
解决这道题，就像帮“作业探险家”规划一条**不绕环、时间够、价值高**的作业路线——首先得把图里的“环陷阱”（做了会重复的作业）标出来，再从“起点作业”（没有前置的作业）出发，一步步走，计算每一步的时间和价值，找到最大的总价值。  
- **图论的核心**：用“环检测”（Tarjan或拓扑排序）找出不能走的环，用“DFS”遍历所有可能的作业顺序，计算最大价值。  
- **题解思路**：所有题解都先处理环（标记环上的节点，避免访问），再从入度为0的节点开始DFS，计算时间内的最大价值。核心难点是**正确标记环**（不遗漏、不误标）和**DFS中的时间/价值计算**（处理“做不完作业”的情况）。  
- **可视化设计思路**：用像素块代表作业节点，环用红色闪烁标记；DFS时用蓝色箭头“走”路径，当前作业节点高亮；时间和价值用像素数字实时更新；关键操作（如Tarjan入栈、DFS回溯）加“叮”“嗒”的像素音效，找到最大价值时播放“胜利”音效。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了4道优质题解，帮大家快速理解核心逻辑~
</eval_intro>

**题解一：作者Doubleen（赞21）**  
* **点评**：这道题解用Tarjan算法找强连通分量（SCC），完美标记环（大小>1的SCC就是环），思路非常经典。DFS从入度为0的节点开始，直接计算完整作业的价值，时间不够时计算部分价值，逻辑直白。代码用链式前向星存图，变量名清晰（如`can[sum]`标记环的SCC），实践中容易调试，是入门图论环检测的好例子。

**题解二：作者DJN123（赞3）**  
* **点评**：这道题解在Tarjan的基础上，加了**记忆化搜索**（`f[now].t`和`f[now].w`记录每个节点的最优时间和价值），避免重复计算，优化了DFS效率。代码用`yes`数组标记环上的节点，处理边界条件更细致（比如`time > T`直接返回），适合想进一步优化的同学参考。

**题解三：作者Accepted3927（赞2）**  
* **点评**：这道题解用**两次拓扑排序**（正图+反图）标记环，思路新颖——正图找“能到达环的点”，反图找“能被环到达的点”，两者交集就是环上的点。虽然复杂度略高，但适合理解拓扑排序的另一种用法，代码中`e[0]`虚拟起点的技巧也很巧妙。

**题解四：作者code_farmer2_2（赞1）**  
* **点评**：这道题解用拓扑排序标记环（入度>0的节点是环或依赖环的点），逻辑简单易懂。DFS用回溯法（`nv`记录当前价值，递归后恢复），处理部分作业的情况很清晰（`nt/t[pos]`计算能做的数量）。代码用链式前向星存图，速度快，适合刚学拓扑排序的同学。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题，大家常遇到3个“卡壳点”，我帮大家总结了对策~
</difficulty_intro>

1. **难点1：如何正确标记环？**  
   * **分析**：环是“做了会重复的作业”，必须标记出来。Tarjan找SCC（强连通分量，大小>1就是环）是最常用的方法；拓扑排序则通过“无法入队的节点”（入度>0）标记环。  
   * 💡 **学习笔记**：Tarjan适合找所有SCC，拓扑适合快速标记环，选哪种看题目的数据规模（本题n=1e4，两者都适用）。

2. **难点2：DFS时如何计算时间和价值？**  
   * **分析**：做作业的时间是`c[i]*t[i]`（数量×单份时间），价值是`c[i]*v[i]`。如果时间不够做完整份，就用`(剩余时间)/t[i]`算能做的数量，乘价值。  
   * 💡 **学习笔记**：DFS时，先判断“做不做完整份”——做完整份就递归下一个作业，做不完就更新最大价值，返回。

3. **难点3：从哪里开始DFS？**  
   * **分析**：作业有依赖，必须从“没有前置”的作业（入度为0）开始，否则会漏掉合法路径。  
   * 💡 **学习笔记**：用`in[i]`数组记录入度，DFS前遍历所有入度为0的节点，逐个开始搜索。  


### ✨ 解题技巧总结
- **技巧A：环检测选对方法**：Tarjan适合找SCC，拓扑适合快速标记环，根据题目选。  
- **技巧B：DFS的边界处理**：遇到环、时间超了、没有下一个作业，都要及时返回，避免死循环。  
- **技巧C：开long long！**：时间、价值都是大数，必须用`long long`，否则会溢出（十年OI一场空，不开long long见祖宗！）  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**综合版核心代码**，帮大家把握整体框架~
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合了Tarjan环检测和DFS的经典思路，代码简洁，适合入门。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <stack>
  using namespace std;
  typedef long long ll;

  const int N = 10005, M = 100005;
  ll v[N], c[N], t[N], T, ans = 0;
  int head[N], cnt = 0;
  struct Edge { int to, next; } edge[M];
  int dfn[N], low[N], color[N], sum = 0, tot = 0;
  bool vis[N], can[N]; // can[sum]标记环的SCC
  stack<int> sta;
  int in[N]; // 入度

  void add(int x, int y) { edge[++cnt] = {y, head[x]}, head[x] = cnt; }
  ll read() { ll x = 0; char ch = getchar(); while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) x = x*10 + ch-'0', ch = getchar(); return x; }

  void tarjan(int x) {
    dfn[x] = low[x] = ++tot;
    sta.push(x), vis[x] = true;
    for (int i = head[x]; i; i = edge[i].next) {
      int u = edge[i].to;
      if (!dfn[u]) tarjan(u), low[x] = min(low[x], low[u]);
      else if (vis[u]) low[x] = min(low[x], dfn[u]);
    }
    if (dfn[x] == low[x]) {
      int sz = 1; color[x] = ++sum; vis[x] = false;
      while (sta.top() != x) {
        sz++; color[sta.top()] = sum;
        vis[sta.top()] = false; sta.pop();
      }
      if (sz > 1) can[sum] = true; // 大小>1的SCC是环
      sta.pop();
    }
  }

  void dfs(int x, ll time, ll val) {
    ans = max(ans, val); // 更新当前最大价值
    if (time > T) return; // 时间超了，返回
    for (int i = head[x]; i; i = edge[i].next) {
      int u = edge[i].to;
      if (can[color[u]]) continue; // 跳过环上的节点
      ll cost = c[u] * t[u]; // 做完整份u的时间
      ll gain = c[u] * v[u]; // 做完整份u的价值
      if (time + cost <= T) { // 时间够，做完整份
        dfs(u, time + cost, val + gain);
      } else { // 时间不够，做部分
        ll can_do = (T - time) / t[u];
        ans = max(ans, val + can_do * v[u]);
      }
    }
  }

  int main() {
    int n = read(); T = read();
    for (int i = 1; i <= n; i++) v[i] = read(), c[i] = read(), t[i] = read();
    int m = read();
    for (int i = 1; i <= m; i++) {
      int x = read(), y = read();
      add(x, y); in[y]++; // 统计入度
    }
    // Tarjan找环
    for (int i = 1; i <= n; i++) if (!dfn[i]) tarjan(i);
    // 从入度为0的节点开始DFS
    for (int i = 1; i <= n; i++) {
      if (in[i] == 0 && !can[color[i]]) { // 入度0且不在环上
        ll cost = c[i] * t[i];
        ll gain = c[i] * v[i];
        if (cost <= T) {
          dfs(i, cost, gain);
        } else {
          ll can_do = T / t[i];
          ans = max(ans, can_do * v[i]);
        }
      }
    }
    cout << ans << endl;
    return 0;
  }
  ```
* **代码解读概要**：  
  1. **输入处理**：读入作业的价值、数量、时间，以及作业依赖（用链式前向星存图）。  
  2. **Tarjan环检测**：找所有SCC，标记环（`can[sum] = true`）。  
  3. **DFS搜索**：从入度为0的节点开始，计算每一步的时间和价值，更新最大`ans`。  


<code_intro_selected>
接下来看两道题解的**核心片段**，学习它们的亮点~
</code_intro_selected>

**题解一：作者Doubleen**
* **亮点**：用Tarjan找SCC，简洁标记环。
* **核心代码片段**：
  ```cpp
  void tarjan(int x) {
    dfn[x] = low[x] = ++tot;
    sta[++top] = x; vis[x] = true;
    for (int i = head[x]; i; i = edge[i].next) {
      int u = edge[i].to;
      if (!dfn[u]) tarjan(u), low[x] = min(low[x], low[u]);
      else if (vis[u]) low[x] = min(low[x], dfn[u]);
    }
    if (dfn[x] == low[x]) {
      int sz = 1; color[x] = ++sum; vis[x] = false;
      while (sta[top] != x) {
        sz++; color[sta[top]] = sum;
        vis[sta[top--]] = false;
      }
      if (sz > 1) can[sum] = true; // 环的SCC标记
      top--;
    }
  }
  ```
* **代码解读**：  
  这段是Tarjan的核心——`dfn[x]`是节点x的“发现时间”，`low[x]`是x能到达的最早节点的发现时间。当`dfn[x] == low[x]`时，说明找到了一个SCC（从x到栈顶的节点构成一个强连通分量）。如果SCC的大小>1，就是环，用`can[sum]`标记。  
* 💡 **学习笔记**：Tarjan的关键是“入栈-回溯-出栈”，用`vis`数组标记栈中的节点，避免重复计算。

**题解二：作者DJN123**
* **亮点**：记忆化搜索，避免重复计算。
* **核心代码片段**：
  ```cpp
  struct student { int t, w; } f[100005]; // f[now].t: 到now的时间，f[now].w: 到now的价值
  void dfs(int now, int time, int val) {
    if (time > T || yes[now]) return;
    if (val == f[now].w && time > f[now].t) return; // 记忆化：相同价值，时间更久的路径不需要走
    f[now].w = val; f[now].t = time;
    maxx = max(maxx, val + min(c[now], (T - time)/t[now])*v[now]);
    for (int i = head[now]; i; i = road[i].next) {
      int r = road[i].to;
      dfs(r, time + c[now]*t[now], val + c[now]*v[now]);
    }
  }
  ```
* **代码解读**：  
  `f[now]`记录到达`now`节点的**最优状态**（价值相同的情况下，时间更短的路径更好）。如果当前路径的时间比之前的长，且价值相同，就直接返回，避免重复搜索。  
* 💡 **学习笔记**：记忆化搜索能减少DFS的次数，适合“状态重复”的问题（比如多个路径到达同一个节点）。  


## 5. 算法可视化：像素动画演示

<visualization_intro>
我设计了一个**“作业探险家”像素动画**，用复古游戏风帮大家直观理解算法~
</visualization_intro>

### **动画主题**：作业探险家的“无环寻宝之旅”
### **核心演示内容**：
- **场景初始化**：用8位像素块画一个“作业地图”，节点是彩色方块（红色=环，蓝色=普通作业），边是白色箭头。控制面板有“单步”“自动”“重置”按钮，速度滑块，以及实时显示的“当前时间”“当前价值”。
- **Tarjan环检测**：节点入栈时，像素块“滑入”栈（用动画），伴随“叮”的音效；找到SCC时，环节点闪烁红色，播放“嗡”的音效。
- **DFS搜索**：探险家（蓝色箭头）从入度为0的节点出发，每走一步，当前节点高亮，时间和价值用像素数字更新；做完整份作业时，箭头“跳”到下一个节点，伴随“嗒”的音效；做不完时，价值数字闪烁，更新最大价值。
- **胜利时刻**：找到最大价值时，屏幕弹出“胜利！”像素文字，播放上扬的8位胜利音效，背景音乐变欢快。

### **交互设计**：
- **单步执行**：点击“单步”，动画走一步，方便观察每一步的变化。
- **自动播放**：用滑块调整速度（慢→快），动画自动走完全程，像“贪吃蛇AI”一样找最优路径。
- **重置**：点击后回到初始状态，重新开始演示。

### **复古游戏元素**：
- **音效**：Tarjan入栈“叮”，DFS走步“嗒”，胜利“叮~当~”，环标记“嗡”。
- **背景音乐**：循环播放8位风格的《卡农》，轻松又复古。
- **关卡设计**：把“环检测”和“DFS搜索”分成两个小关卡，完成一个关卡，屏幕显示“关卡1完成！”，增加成就感。  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的“环检测+DFS”思路，还能解决很多类似的问题，比如“路径最大权值”“有向无环图（DAG）的最长路径”~
</similar_problems_intro>

### **通用思路迁移**：
- 场景1：规划旅行路线（不绕环，找最有价值的景点）。
- 场景2：项目调度（不做循环依赖的项目，找最短时间的方案）。
- 场景3：代码依赖分析（找出循环依赖的模块，避免编译错误）。

### **洛谷练习推荐**：
1. **P2196 [NOIP1996 提高组] 挖地雷**：找无环路径的最大地雷数，练习DFS和路径规划。
2. **P3387 【模板】缩点**：Tarjan缩点模板题，巩固SCC的知识。
3. **P1113 杂务**：拓扑排序找最长路径，练习环检测和DAG的最长路径。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我摘了3条**有用的经验**，帮大家避坑~
</insights_intro>

> **经验1（来自Doubleen）**：“别忘了吸氧哦QAQ”——本题n=1e4，m=1e5，用O(n+m)的Tarjan和DFS，加上“吸氧”（编译优化），能更快通过。  
> **点评**：对于大数据量的题目，编译优化（如GCC的`-O2`）能显著提升速度，这是竞赛中的小技巧~

> **经验2（来自DJN123）**：“tarjan将环噶了，然后爆搜”——Tarjan是处理环的“利器”，找SCC的方法要牢记。  
> **点评**：Tarjan的代码虽然有点长，但逻辑固定，多写几次就能记住~

> **经验3（来自code_farmer2_2）**：“拓扑排序在遇到只剩环的情况时会终止，这时图中只剩环和必须通过环的点”——拓扑排序标记环的方法，适合不想写Tarjan的同学~  


<conclusion>
这道题的核心是“环检测+DFS”，只要掌握了Tarjan或拓扑排序，再处理好时间/价值的计算，就能解决！记住：编程就像探险，遇到“环陷阱”要绕开，遇到“时间不够”要算清楚，最后总能找到“最大价值”的路线~  
下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：97.21秒
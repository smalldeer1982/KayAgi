# 题目信息

# 冰魄吐息

## 题目背景

[$\text{加强版}\Leftarrow$](/problem/U174529)

## 题目描述

$N$ 个点，第 $i$ 个点坐标为 $(x_i,y_i)$。

定义一束激光：$y=kx$，若点 $i$ 满足到该条直线距离 $\le d$，认为被激光击中。

求使用至多 $K$ 束激光，击毁图中所有点的最小代价 $d$。

## 说明/提示

#### 样例说明

| ![](https://cdn.luogu.com.cn/upload/image_hosting/3a8bw1ub.png) | ![](https://cdn.luogu.com.cn/upload/image_hosting/3oih7er9.png) |
| :----------- | :----------- |
| 样例 $\#1$ 中两蓝色点坐标分别为 $(2,3)$ 和 $(6,3)$，到直线 $y=\frac{3}{4}x$ 的距离均为 $\frac{6}{5}=1.2$，因此输出 `1.20`。 | 样例 $\#2$ 中坐标为 $(4,0),(4,2)$ 的点与斜率为 $\frac{1}{4}$ 的直线之间距离为 $\frac{4}{17}\sqrt{17}\approx0.97014\dots$，因此输出 `0.97`。 |

可以证明两个样例中的方案是最优的，因此所求的 $d$ 是最小的。

#### 提示

1. 可能会用到的公式：点 $(x_0,y_0)$ 到直线 $y=kx$ 的距离是 $\dfrac{|y_0-kx_0|}{\sqrt{k^2+1}}$。
2. 对于 C++ 选手，**建议使用** 变量类型 `long double` 进行数值计算。  
输出时请用形如 `printf("%.2Lf",ans)` 的形式输出答案，注意 `%.2Lf` 中的 L 是大写。
3. 本题中存在的浮点数运算可能较多，虽然已经增大时限，但仍然请注意常数因子对程序效率的影响。

#### 数据范围

**本题采用捆绑测试**。

记 $M$ 为所有 $x_i,y_i$ 的最大值。

| Subtask | Score | $M\le$ | $K\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $30$ | $10$ | $1$ |
| $2$ | $30$ | $1.5\times10^4$ | $1$ |
| $3$ | $40$ | |  |

对于 $100\%$ 的数据：$1\le N,M,K\le2.5\times10^4$。

所有数据均保证不存在相同的 $(x_i,y_i)$ 出现多次。

---

### 后记

冰魄战龙我吹爆 $\sim$

如果您也热爱 ddt，请在比赛结束后找到出题人，并把他虐一顿。

![](https://cdn.luogu.com.cn/upload/image_hosting/65wu5o0v.png)

出题人推荐阅读题解：（优点：显然）https://www.luogu.com.cn/blog/_post/362493

## 样例 #1

### 输入

```
2 1
2 3
6 3```

### 输出

```
1.20```

## 样例 #2

### 输入

```
4 3
1 6
4 6
4 2
4 0```

### 输出

```
0.97```

# AI分析结果

# 💡 Kay的C++算法解析：冰魄吐息 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`二分答案 + 贪心算法`


🗣️ **初步分析**：  
解决“冰魄吐息”的关键，就像**“猜数字+安排值日”的组合游戏**——  
- **二分答案**像“猜最小的d”：我们要找能覆盖所有点的最小d，就像猜价格时每次选中间值，判断“这个d能不能用K束激光覆盖所有点”，再缩小范围（比如d太大就往小猜，太小就往大猜）。  
- **贪心算法**像“安排最少值日生”：当d确定后，每个点对应一个“斜率区间”（即哪些激光能覆盖它），我们需要用最少的激光（点）覆盖所有区间——就像选最少的值日生，每次选“结束最早的区间右端点”，这样能覆盖最多后续区间。  

**题解思路**：所有题解的核心框架一致：  
1. 二分d的范围（从0到一个大值，比如1e5）；  
2. 对每个d，将每个点转化为**斜率区间**（即激光斜率k∈[L,R]时能覆盖该点）；  
3. 用贪心算法计算覆盖所有区间需要的最少激光数，判断是否≤K。  

**核心难点**：  
- 如何**正确计算每个点的斜率区间**（比如x=0、y=0时的特殊情况，负斜率如何处理）；  
- 如何**处理精度问题**（二分套二分需要足够小的步长，否则区间计算错误）；  
- 如何**转化问题**（将几何距离问题转化为区间覆盖的贪心问题）。  

**可视化设计思路**：  
我们用**8位像素风**还原算法过程——  
- 屏幕左侧用进度条显示当前二分的d范围（比如蓝色进度条代表可能的d区间）；  
- 中间区域用像素点展示所有点，每个点转化为斜率区间时，用彩色线段（比如红色）在“斜率轴”上标出；  
- 贪心选点时，用**闪烁的黄色星星**标记选中的区间右端点（表示选这个激光）；  
- 音效设计：二分缩小范围时播放“嘀”声，区间生成时播放“哔”声，贪心选点时播放“叮”声，成功覆盖所有区间时播放“胜利”音效（8位上扬音调）。  


## 2. 精选优质题解参考

为大家筛选了3份思路清晰、效率高的优质题解，覆盖了“二分套二分”“导角法”“导边法”三种核心方法：


**题解一：二分套二分（来源：hensier Solution 1）**  
* **点评**：这份题解用“二分套二分”的思路，直接根据距离公式判断斜率是否符合条件，非常直观。比如计算每个点的左边界L时，二分0到y/x的斜率，找最小的符合条件的k；计算右边界R时，二分y/x到1e5的斜率，找最大的符合条件的k。但要注意**精度控制**——二分的步长要足够小（比如1e-8），否则会因精度不够导致区间错误。代码结构清晰，适合入门理解“点→区间”的转化逻辑。


**题解二：导角法（来源：hensier Solution 2）**  
* **点评**：这份题解用**角度转化**的方法，将几何问题转化为三角函数计算，效率更高（时间复杂度O(n log x + n log n)）。比如用反正切求OP与x轴的夹角α，用反正弦求切线与OP的夹角β，再算出两条切线的斜率tan(α±β)。同时处理了负斜率的情况：如果区间包含负斜率，根据α+β是否超过90度，将左边界设为0或右边界设为极大值。思路巧妙，适合大数据量的情况，是比赛中的常用优化方法。


**题解三：导边法（来源：hensier Solution 3）**  
* **点评**：这份题解用**代数推导**直接求解切线方程，避免了反三角函数（比如atan、asin），常数更小。通过联立切线与圆的方程，解出切线的斜率，再处理y=0等特殊情况。比如当y≠0时，用二次方程求根公式算出切线的a（x坐标）和b（y坐标），再得到斜率b/a。这种方法计算精准，适合对效率要求高的场景，是“数学派”的最优选择。


## 3. 核心难点辨析与解题策略

解决本题的关键，在于突破以下3个核心难点：


### 1. 难点1：如何将点转化为正确的斜率区间？  
**分析**：每个点对应两条切线，斜率区间是这两条切线的k值范围。题解提供了3种方法：  
- **二分套二分**：直接根据距离公式判断，直观但需高精度；  
- **导角法**：用角度α（OP与x轴夹角）和β（切线与OP夹角）计算斜率；  
- **导边法**：联立方程用代数推导，避免三角函数。  
**学习笔记**：选择方法时，优先选“导角法”或“导边法”，效率更高；若想直观理解，用“二分套二分”。


### 2. 难点2：如何处理边界情况？  
**分析**：比如x=0（点在y轴上）、y=0（点在x轴上）、负斜率的情况。题解中都做了特判：  
- x=0时，α=90度（π/2）；  
- y=0时，单独计算切线斜率（用勾股定理求OH和TH）；  
- 负斜率时，若区间包含负数，根据α+β是否超过90度，调整左/右边界为0或极大值。  
**学习笔记**：边界情况是“坑点”，必须逐个特判，否则会导致区间错误。


### 3. 难点3：如何控制二分的精度？  
**分析**：二分答案的精度直接影响结果的正确性。题解中二分的步长或次数要足够：  
- 主二分的d范围从0到1e5，步长用1e-4（因为输出要求两位小数）；  
- 二分套二分的步长用1e-8，确保区间计算精准。  
**学习笔记**：对于浮点数二分，建议用“固定次数二分”（比如100次）代替“步长终止”，更稳定。


### ✨ 解题技巧总结  
- **问题转化**：将“最小d”转化为“二分d+判断可行性”，将“激光覆盖”转化为“区间覆盖”；  
- **贪心策略**：区间覆盖问题中，按右端点排序，每次选最右的点，覆盖最多后续区间；  
- **精度控制**：浮点数计算用long double，二分步长或次数要足够。


## 4. C++核心代码实现赏析

先看一份**通用核心实现**，再剖析各题解的亮点片段：


### 本题通用核心C++实现参考  
* **说明**：综合“导角法”的核心逻辑，兼顾效率与可读性，适合作为基础模板。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

const long double PI = acos(-1);
const long double RT = PI * 0.5; // 90度（π/2）

int n, k;
struct Point { long double x, y; };
struct Interval { long double L, R; bool operator<(const Interval& o) const { return R < o.R; } };
vector<Point> p;
vector<Interval> a;

bool check(long double d) {
    a.clear();
    for (auto& pt : p) {
        long double x = pt.x, y = pt.y;
        if (x*x + y*y <= d*d) continue;
        long double alpha = atan(y / x);
        if (x == 0) alpha = RT; // 特判x=0
        long double beta = asin(d / sqrt(x*x + y*y));
        long double L = tan(alpha - beta), R = tan(alpha + beta);
        if (L > R) swap(L, R);
        if (L < 0) {
            if (alpha + beta > RT) { L = R; R = 1e18; }
            else L = 0;
        }
        a.push_back({L, R});
    }
    sort(a.begin(), a.end());
    int cnt = 0;
    long double last = 0;
    for (auto& inv : a) {
        if (last <= inv.L) {
            last = inv.R;
            if (++cnt > k) return false;
        }
    }
    return true;
}

int main() {
    cin >> n >> k;
    p.resize(n);
    for (int i = 0; i < n; ++i) cin >> p[i].x >> p[i].y;
    long double l = 0, r = 1e5, ans = 0;
    for (int iter = 0; iter < 100; ++iter) { // 固定100次二分，确保精度
        long double mid = (l + r) * 0.5;
        if (check(mid)) { ans = mid; r = mid; }
        else l = mid;
    }
    printf("%.2Lf\n", ans);
    return 0;
}
```
* **代码解读概要**：  
  1. 主函数：读取输入，初始化二分范围，固定100次二分求最小d；  
  2. check函数：对每个d，计算所有点的斜率区间，排序后用贪心算需要的激光数；  
  3. 区间计算：用导角法求α和β，处理负斜率的情况。


### 各题解核心片段赏析

#### 题解一：二分套二分（来源：hensier Solution 1）  
* **亮点**：直接根据距离公式判断，直观易懂。  
* **核心代码片段**：  
```cpp
interval get(point p, long double d) {
    if (!p.x) return { -p.y/d, p.y/d };
    interval ans;
    long double l = 0, r = p.y / p.x;
    // 二分求左边界L
    while (l <= r) {
        long double mid = (l + r) * 0.5;
        if (fabs(p.y - mid*p.x)/sqrt(mid*mid+1) <= d) {
            r = mid - 1e-8; ans.L = mid;
        } else l = mid + 1e-8;
    }
    // 二分求右边界R
    l = p.y / p.x; r = 1e5;
    while (l <= r) {
        long double mid = (l + r) * 0.5;
        if (fabs(p.y - mid*p.x)/sqrt(mid*mid+1) <= d) {
            l = mid + 1e-8; ans.R = mid;
        } else r = mid - 1e-8;
    }
    return ans;
}
```
* **代码解读**：  
  这段代码用两次二分计算区间的L和R。比如求L时，二分0到y/x的斜率，找最小的符合条件的k（因为左切线在点下方）；求R时，二分y/x到1e5的斜率，找最大的符合条件的k（右切线在点上方）。注意**步长1e-8**，确保精度。  
* **学习笔记**：二分套二分是“暴力但有效”的方法，适合理解“点→区间”的逻辑。


#### 题解二：导角法（来源：hensier Solution 2）  
* **亮点**：用三角函数转化，效率高，处理负斜率。  
* **核心代码片段**：  
```cpp
long double alpha = atan(y / x);
if (!x) alpha = RT; // x=0时，夹角90度
long double beta = asin(d / sqrt(x*x + y*y));
a[cnt].L = tan(alpha - beta);
a[cnt].R = tan(alpha + beta);
if (a[cnt].L > a[cnt].R) swap(a[cnt].L, a[cnt].R);
if (a[cnt].L < 0) {
    if (alpha + beta > RT) { a[cnt].L = a[cnt].R; a[cnt].R = 1e18; }
    else a[cnt].L = 0;
}
```
* **代码解读**：  
  1. α是OP与x轴的夹角（用atan(y/x)计算）；  
  2. β是切线与OP的夹角（用asin(d/OP长度)计算）；  
  3. 两条切线的斜率是tan(α±β)，再处理负斜率的情况：如果α+β>90度（切点在第二象限），则左边界设为R，右边界设为极大值；否则左边界设为0。  
* **学习笔记**：导角法将几何问题转化为三角函数，避免了嵌套二分，效率更高。


#### 题解三：导边法（来源：hensier Solution 3）  
* **亮点**：用代数推导，避免反三角函数，常数小。  
* **核心代码片段**：  
```cpp
long double c = d*d - x*x - y*y;
long double delta = -c * (x*x + y*y + c);
long double a1 = (-c*x + y*sqrt(delta)) / (x*x + y*y);
long double a2 = (-c*x - y*sqrt(delta)) / (x*x + y*y);
long double b1 = (-c - a1*x)/y, b2 = (-c - a2*x)/y;
a[cnt].L = b1/a1; a[cnt].R = b2/a2;
```
* **代码解读**：  
  这段代码联立切线方程（ax + by = -c）和OP的方程（a² + b² = ax + by），用二次方程求根公式算出切线的a（x坐标）和b（y坐标），再得到斜率b/a。适合对效率要求高的场景。  
* **学习笔记**：代数推导是“数学派”的利器，避免了三角函数的精度问题。


## 5. 算法可视化：像素动画演示

我们用**8位像素风**还原算法过程，结合游戏化元素，让学习更有趣：


### 🌠 动画主题：像素科学家的“激光实验”  
**设计思路**：用FC游戏的复古风格，将算法转化为“实验过程”——像素科学家调整d的值，用激光覆盖所有点，成功后获得“实验胜利”。


### 🎮 动画核心内容  
1. **场景初始化**：  
   - 屏幕左侧用像素点展示所有点（比如红色像素点代表点）；  
   - 中间区域是“斜率轴”（x轴代表斜率k，y轴代表是否覆盖）；  
   - 右侧控制面板有：开始/暂停、单步、重置按钮，速度滑块，d值显示框；  
   - 播放8位风格的背景音乐（比如《超级马里奥》的轻松旋律）。

2. **二分过程演示**：  
   - 用**蓝色进度条**显示当前二分的d范围（比如进度条长度代表可能的d区间）；  
   - 每次二分缩小范围时，播放“嘀”声，进度条缩短；  
   - d值显示框实时更新当前的mid值（比如“当前d：1.20”）。

3. **区间生成演示**：  
   - 每个点转化为斜率区间时，用**彩色线段**在“斜率轴”上标出（比如红色线段代表点A的区间，蓝色代表点B的区间）；  
   - 生成区间时播放“哔”声，线段闪烁1次。

4. **贪心覆盖演示**：  
   - 按右端点排序后，用**黄色星星**标记选中的区间右端点（代表选这个激光）；  
   - 选点时播放“叮”声，星星闪烁3次；  
   - 覆盖所有区间后，播放“胜利”音效（8位上扬音调），屏幕显示“实验成功！d=1.20”。


### 🎯 交互设计  
- **单步模式**：点击“单步”按钮，逐步执行二分、区间生成、贪心选点；  
- **自动模式**：点击“自动”按钮，算法自动运行，速度可调（滑块从“慢”到“快”）；  
- **重置模式**：点击“重置”按钮，回到初始状态，重新开始实验。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移  
本题的“二分答案+贪心”框架，可用于以下场景：  
- **最小最大值问题**（比如“最小的最大距离”“最小的最大时间”）；  
- **区间覆盖问题**（比如“安排最少的服务器覆盖所有请求”）。


### 📚 洛谷练习推荐  
1. **P1824 进击的奶牛**：二分答案求“最大的最小距离”，转化为区间覆盖的贪心问题，巩固“二分+贪心”框架。  
2. **P2678 跳石头**：类似“进击的奶牛”，练习浮点数以外的二分（整数二分）。  
3. **P3743 小鸟的设备**：二分答案求“最小的充电时间”，转化为数学判断，练习问题转化能力。


## 7. 学习心得与经验分享

题解中作者提到的**“边界情况处理”**和**“精度控制”**是关键经验：  
- 比如x=0时，α要设为90度；y=0时，要单独计算切线斜率；  
- 二分的步长或次数要足够，否则会因精度不够导致错误。  

这些经验提醒我们：**编程不仅要懂算法，还要关注“细节”——细节决定程序的正确性**。


## 💪 总结  
“冰魄吐息”的核心是**“二分答案+贪心”**，关键是将几何问题转化为区间覆盖的贪心问题。通过可视化动画，我们能直观看到d的调整、区间的生成、贪心选点的过程。记住：多练习相似问题，多关注细节，编程能力会稳步提升！  

下次我们再一起探索新的编程挑战！🚀

---
处理用时：111.46秒
# 题目信息

# [CoE R4 B/Stoi2041] 龙拳

## 题目背景

![](bilibili:BV1fx411N7bU?page=28)

## 题目描述

对于 $n \in \mathbb{Z_{\ge 2}}$，设 $g(n)$ 为 $n$ 的小于 $n$ 的最大约数，如 $g(7) = 1, g(12) = 6$。

定义 $f(n) = n + g(n)$。记 $f^{(0)}(n)=n$，且对 $m \in \mathbb{Z_{\ge 0}}$ 有 $f^{(m+1)}(n)=f(f^{(m)}(n))$。

多次询问，每次询问给定正整数 $n,k$，求最小的自然数 $m_0$，使得对于任意 $m \ge m_0$，均有 $f^{(m)}(n) \mid f^{(m+k)}(n)$。

若不存在这样的 $m_0$，则令 $m_0=-1$。

## 说明/提示

### 样例解释

当 $n=2,k=3$ 时，$m_0=0$。

当 $n=3,k=4$ 时不存在满足条件的 $m_0$。

---

### 数据规模

**本题采用捆绑测试。**

- 子任务 $1$（$1$ 分）：$T=k=1$；
- 子任务 $2$（$12$ 分）：$T,n,k \le 10$；
- 子任务 $3$（$24$ 分）：$T \le 10,n \le 10^5$；
- 子任务 $4$（$36$ 分）：$T \le 10^3$；
- 子任务 $5$（$27$ 分）：无特殊限制。

对于 $100\%$ 的数据，保证 $1 \le T \le 2 \times 10^6$，$2 \le n \le 3 \times 10^7$，$1 \le k \le 10^9$。


## 样例 #1

### 输入

```
2
2 3
3 4
```

### 输出

```
0
-1
```

# AI分析结果

# 💡 Kay的C++算法解析：「龙拳」深入学习指南 💡

大家好，我是Kay！今天我们要拆解一道**数论密码题**——通过分析数字的“质因数基因”，找到函数迭代的规律。这道题像一场“数字变形游戏”，需要我们用数学工具破解它的循环密码～


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论分析与规律推导）

🗣️ **初步分析**：  
数学在这里就像“数字拆解器”——我们把每个数拆成**最小质因数的乘积**（比如12=2²×3），然后观察函数`f(n)=n+g(n)`（g(n)是n的最大真约数）如何改变这些质因数的组合。比如：  
- 偶数n=2ᵏ×m（m奇数），`f(n)=3×2ᵏ⁻¹×m`（蓝色的“2块”少1个，红色的“3块”多1个）；  
- 奇数n=3×m（m奇数），`f(n)=4×m`（直接变成偶数，新增蓝色“2块”）。  

**核心规律**：  
- 只有当k是3的倍数时，才存在解（否则迭代中会出现奇偶性矛盾，无法整除）；  
- 我们需要计算“把n带进循环”的最小步数m0：  
  - 若n是偶数，需把2的幂次减少到≤2（每多1个2需要1步）；  
  - 若n是奇数且不是3的倍数，需先变偶数（1步），再处理2的幂次；  
  - 若n是奇数且是3的倍数，直接进入循环（m0=0）。  

**可视化设计思路**：  
用**像素风格的“数字积木”**展示n的质因数：2=蓝色块，3=红色块，其他质因数=绿色块。动画演示每一步操作：  
- 偶数→蓝色块-1，红色块+1（伴随“叮”的音效）；  
- 奇数变偶数→绿色块→蓝色块（伴随“唰”的音效）；  
- 进入循环→每3步重复蓝色/红色块的变化（播放“通关”音效）。  
交互面板支持**单步执行**（看清每一步）、**自动播放**（看完整循环），还有“重置”按钮重新开始～


## 2. 精选优质题解参考

为大家筛选了3份**思路清晰、代码规范**的优质题解：

### 题解一：出题人题解（作者：VinstaG173）  
* **点评**：这份题解是“官方说明书”！作者直接点出`f(n)`的本质——`f(n)=n×(p(n)+1)/p(n)`（p(n)是n的最小质因数），并分三类情况讨论：  
  1. 偶数：减少2的幂次，增加3的幂次；  
  2. 奇数且是3的倍数：直接进入循环；  
  3. 奇数且不是3的倍数：先变偶数，再处理2的幂次。  
代码用**线性筛**预处理最小质因数，查询时直接套规律，效率超高！


### 题解二：规律总结题解（作者：gyyyyx）  
* **点评**：作者是“找规律小能手”！通过手动模拟`n=3×奇数`的情况，发现**每3步迭代会重复**（比如3m→4m→6m→9m→12m→18m→27m…）。代码预处理了`g(n)=n/p(n)`（直接得到最大真约数），处理查询时只需计算2的幂次和变偶数的步数，逻辑简洁易懂～


### 题解三：代码简洁题解（作者：nomonick）  
* **点评**：这份题解的代码像“精简版说明书”！用线性筛预处理最小质因数，在`solve`函数中：  
  - 先判断k是否为3的倍数；  
  - 处理奇数的情况（变偶数，步数+1）；  
  - 计算2的幂次，超过2的部分每多1个需要1步。  
代码结构清晰，变量名（比如`minn`表示最小质因数）易懂，适合新手模仿～


## 3. 核心难点辨析与解题策略

### 核心难点1：理解`g(n)`与最小质因数的关系  
**问题**：为什么g(n)等于n除以最小质因数p(n)？  
**解答**：比如n=12，最小质因数是2，最大真约数是6=12/2；n=15，最小质因数是3，最大真约数是5=15/3。**结论**：`g(n) = n / p(n)`（p(n)是n的最小质因数）。  
💡 **学习笔记**：记住这个公式，题目的大门就打开了！


### 核心难点2：发现迭代的循环规律  
**问题**：为什么循环的周期是3？  
**解答**：当n变成`2²×3ᵏ×m`（m奇数）时，迭代会进入循环：  
- `f(n)=3×2×3ᵏ×m=2×3ᵏ⁺¹×m`（蓝色块-1，红色块+1）；  
- `f²(n)=3²×3ᵏ×m=3ᵏ⁺²×m`（蓝色块消失，红色块+1）；  
- `f³(n)=2²×3ᵏ⁺¹×m`（蓝色块+2，红色块+1）。  
三步后回到类似初始的形式，循环由此产生～  
💡 **学习笔记**：循环的“入场券”是让n的2的幂次≤2！


### 核心难点3：计算m0的方法  
**问题**：如何快速算出“带进循环”的步数？  
**解答**：分三类情况：  
1. **偶数n=2ᵏ×m**：需要`max(k-2, 0)`步（每多1个2，减少1个需要1步）；  
2. **奇数n=3×m**：直接进入循环，步数0；  
3. **奇数n=其他质数×m**：先变偶数（1步），再按偶数计算步数。  
💡 **学习笔记**：m0=变偶数的步数 + 2的幂次超过2的步数！


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了出题人题解和gyyyyx题解的思路，是**最典型的实现**。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MAXN = 3e7 + 5;
vector<int> min_prime(MAXN, 0); // 存储每个数的最小质因数
vector<int> primes;

// 线性筛预处理最小质因数
void sieve() {
    for (int i = 2; i < MAXN; ++i) {
        if (min_prime[i] == 0) { // i是质数
            min_prime[i] = i;
            primes.push_back(i);
        }
        for (int p : primes) {
            if (1LL * i * p >= MAXN) break;
            min_prime[i * p] = p;
            if (i % p == 0) break; // 保证每个数只被最小质因数筛到
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    sieve(); // 预处理最小质因数

    int T;
    cin >> T;
    while (T--) {
        int n, k;
        cin >> n >> k;
        if (k % 3 != 0) {
            cout << "-1\n";
            continue;
        }

        int m0 = 0;
        // 处理：奇数且不是3的倍数→变偶数
        if (n % 2 != 0 && n % 3 != 0) {
            m0++;
            int p = min_prime[n]; // 最小质因数
            n = n / p * (p + 1); // 变后的n
        }

        // 计算n中2的幂次
        int cnt2 = 0;
        while (n % 2 == 0) {
            cnt2++;
            n /= 2;
        }
        m0 += max(cnt2 - 2, 0); // 超过2的部分需要步数

        cout << m0 << "\n";
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **预处理**：用**线性筛**生成`min_prime`数组（每个数的最小质因数）；  
  2. **处理查询**：  
     - 若k不是3的倍数，直接输出-1；  
     - 若n是奇数且不是3的倍数，变偶数（步数+1）；  
     - 计算2的幂次，超过2的部分每多1个需要1步；  
     - 输出总步数m0。


### 题解二（gyyyyx题解）核心片段赏析  
* **亮点**：预处理`g(n)`直接得到最大真约数，无需每次计算最小质因数。  
* **核心代码片段**：  
```cpp
// 预处理g(n)=n的最大真约数
vector<int> g(N, 0);
vector<int> prime;
vector<bool> vis(N, false);
for (int i = 2; i < N; ++i) {
    if (!vis[i]) {
        prime.push_back(i);
        g[i] = 1; // 质数的最大真约数是1
    }
    for (int j = 0; j < prime.size() && 1LL * i * prime[j] < N; ++j) {
        vis[i * prime[j]] = true;
        g[i * prime[j]] = i; // i*prime[j]的最大真约数是i（因为prime[j]是最小质因数）
        if (i % prime[j] == 0) break;
    }
}

// 处理奇数且不是3的倍数的情况
if (n % 2 && n % 3) {
    n = n + g[n]; // f(n)=n+g(n)
    flg = 1; // 步数+1
}
```
* **代码解读**：  
  - 预处理`g`数组：`g[i]`是i的最大真约数（比如`g[12]=6`，`g[15]=5`）；  
  - 处理奇数且不是3的倍数的情况：直接用`n + g[n]`计算`f(n)`，步数+1。  
💡 **学习笔记**：预处理`g`数组可以跳过“找最小质因数”的步骤，更高效！


## 5. 算法可视化：像素动画演示方案

### 动画主题：「数字积木大变身」  
**核心目标**：用**8位像素风**展示数字的质因数变化，让规律“看得见”。

### 设计细节：
1. **场景初始化**：  
   - 屏幕左侧是**像素数字区**：用不同颜色的16×16像素块表示质因数（2=蓝，3=红，其他=绿）；  
   - 屏幕右侧是**控制面板**：包含“单步→”“自动▶️”“重置🔄”按钮，以及速度滑块（1x~5x）；  
   - 背景播放**8位复古BGM**（类似《超级马里奥》的轻松旋律）。

2. **动画步骤**：  
   - **例子1：n=10（2×5）**：  
     1. 初始状态：蓝色块（2）+绿色块（5）；  
     2. 操作1（变偶数）：绿色块→蓝色块（n=10+5=15？不，n=10的最小质因数是2，g(n)=5，f(n)=15？哦，不对，n=10是偶数，f(n)=10+5=15（3×5），所以蓝色块消失，红色块+1，绿色块保留；  
     3. 操作2（变偶数）：红色块+绿色块→蓝色块+红色块（n=15+5=20=2²×5）；  
     4. 操作3（进入循环）：蓝色块-1，红色块+1（n=20+10=30=2×3×5）；  
     5. 操作4：蓝色块消失，红色块+1（n=30+15=45=3²×5）；  
     6. 操作5：蓝色块+2，红色块+1（n=45+15=60=2²×3×5）——进入循环！

3. **交互与音效**：  
   - **单步执行**：点击“→”，执行一步操作，当前变化的像素块**闪烁**，并显示提示文字（比如“蓝色块-1，红色块+1”）；  
   - **自动播放**：点击“▶️”，动画按设定速度自动执行，进入循环时播放**通关音效**（类似《魂斗罗》的胜利音效）；  
   - **重置**：点击“🔄”，回到初始状态，重新开始。


## 6. 拓展练习与相似问题

### 巩固基础：
1. **洛谷P1075 质因数分解**：输入一个数，输出其最大质因数（练习质因数分解）；  
2. **洛谷P2043 质因数的个数**：计算一个数的质因数个数（巩固线性筛）；  
3. **洛谷P3383 线性筛素数**：模板题，熟练掌握线性筛的实现。

### 进阶挑战：
尝试解决**「龙拳」变形题**：  
- 求`f^(m)(n)`的值（模拟迭代过程）；  
- 求循环的长度（比如n=6的循环长度是3）；  
- 求`f^(m)(n)`的质因数分解（拓展到更多质因数）。


## 7. 学习心得与经验分享

**参考经验（来自题解作者gyyyyx）**：  
“我一开始没想到g(n)等于n/p(n)，后来手动模拟了n=6、n=9的情况，才发现这个规律。”  

**Kay的点评**：手动模拟小例子是发现规律的“神器”！比如n=6→9→12→18→27→36，很容易看出循环规律。遇到数论问题时，**多算几个小例子**，规律往往会自己“跳出来”～


## 总结

今天我们用数学工具破解了「龙拳」的循环密码，核心是**拆解质因数**和**找迭代规律**。记住：  
- 数论问题的关键是“拆”——把复杂的数拆成质因数的乘积；  
- 规律藏在“变”里——观察每一步操作如何改变质因数的组合。  

下次我们再一起探索更多数论谜题，加油～💪

---
处理用时：115.77秒
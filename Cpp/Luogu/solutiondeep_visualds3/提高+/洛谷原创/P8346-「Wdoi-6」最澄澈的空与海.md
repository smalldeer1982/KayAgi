# 题目信息

# 「Wdoi-6」最澄澈的空与海

## 题目背景

[![](https://cdn.luogu.com.cn/upload/image_hosting/hiekh6t5.png)](https://thwiki.cc/%E5%8D%AF%E9%85%89%E4%B8%9C%E6%B5%B7%E9%81%93_%EF%BD%9E_Retrospective_53_minutes.)

广重号载着二人向东飞驰。毫无噪音，毫无摇摆，只是一个劲向东飞驰。在“万景幕”装置之下，尽管是全地下的卯酉东海道，乘客们也能饱览美丽的富士山和太平洋的景色。

但是，从这列卯酉新干线『广重』上看到的极富日本风味的美丽情景，对于梅莉来说，只不过是无趣的视觉刺激罢了。高动态范围的影像也好，极富日本风味的情景也好，都敌不过真正的天空的颜色。

身与华落，心将香飞。即便肉体会像花朵一样终有一天凋落，但心却可以如花香一般飘往远方。

「梅莉，你看，天上的星星呦。」

## 题目描述

### 简要题意

给定 $2n$ 个点、$m$ 条边的[二分图](http://oi-wiki.com/graph/bi-graph/#_1)（可能有重边），左部点与右部点个数相同，判断其完美匹配数量是否**恰好**为 $1$。是则输出 `Renko`，否则输出 `Merry`。

> **注**：完美匹配是指，从边集中选出 $n$ 条边，这些边的顶点组成的点集恰好覆盖了所有的 $2n$ 个点。

---
### 原始题意

在夜里，莲子与梅莉来到了东京的海边，躺在沙滩上，欣赏着澄澈的天空与大海，数起了天上的星星。

在这些星星之中，有 $n$ 个星星 $\{a_i\}$，是莲子先发现的，被称为莲子星；而又有 $n$ 个星星 $\{b_i\}$，是梅莉先发现的，被称为梅莉星。由于她们心有灵犀，这两批星星之间**不存在交集**。  

她们发现，有一些莲子星，与一些梅莉星之间恰好存在运动关系。具体而言，这些关系一共有 $m$ 组，每一组关系形如 $(u_i,v_i)$，也就是说第 $u_i$ 颗莲子星与第 $v_i$ 颗梅莉星之间存在运动关系。这些运动关系有可能重复。

这让莲子和梅莉非常好奇。作为专攻超统一物理学的女大学生，莲子认为，如果认为这些星星的运动是**和谐**的，那么她应当能够从这 $m$ 个运动关系中，找出若干个运动关系，使得**每颗**星星**都被**这些运动关系**包含**的同时，不会有一颗星星**被包含在两个**运动关系之中。

然而，梅莉认为，**和谐**的运动可能是不存在的，更何况即使莲子找到了**和谐**的运动，莲子也无法确保这种和谐运动的**唯一性**。两种和谐运动不同，当且仅当选取出的两组运动关系中，存在至少一个运动关系，是不相同的。

因为意见不合，她们于是打情骂俏了一顿。莲子于是记下了她们所看到了星星和她们之间的运动关系，并且找到了已经证明了 P=NP 的你，希望你能告诉她们，最后是谁正确呢？

## 说明/提示

### 样例解释

#### 样例 \#1

![](https://cdn.luogu.com.cn/upload/image_hosting/6skoily9.png)

如图所示，存在唯一的方案：$\{1\to 1,2\to 5,3\to 2,4\to 3,5\to 4\}$。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n\le } & \bm{m\le} & \textbf{\textsf{特殊性质}} & \textbf{Subtask \textsf{依赖}}\cr\hline
1 & 10 & 10 & 10 & - & - \cr\hline
2 & 20 & 300 & 4\times 10^4 & - & 1\cr\hline
3 & 20 & 10^5 & 5 \times 10^5 & \mathbf{A} & - \cr\hline
4 & 20 & 10^5 & 2 \times 10^5 & \mathbf{B} & - \cr\hline
5 & 30& 10^6 & 2\times 10^6 & - & 2,3,4 \cr\hline
\end{array}
$$

- 特殊性质 $\mathbf{A}$：保证对于第 $i$ 颗莲子星，与第 $i$ 颗梅莉星之间存在运动关系。
- 特殊性质 $\mathbf{B}$：保证 $m=2n-1$。

对于 $100\%$ 的数据，保证 $1 \le u_i,v_i\le n \le 10^6$，$1 \le m \le 2 \times 10^6$，$1 \leq T \leq 5$ 且对于每个测试点，$\sum m \leq 4 \times 10^6$。

对于 $\rm Subtask\ 5$，时间限制为 $3$ 秒。其它测试点时间限制为 $1$ 秒。

## 样例 #1

### 输入

```
1
5
6
1 1
1 3
3 2
2 5
4 3
5 4```

### 输出

```
Renko```

# AI分析结果

# 💡 Kay的C++算法解析：「Wdoi-6」最澄澈的空与海 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用`（基于二分图度数性质的拓扑式删除模拟）


### 🗣️ 初步分析
我们可以把这道题比作 **“两边小朋友的唯一配对游戏”**：左边是莲子星（A组小朋友），右边是梅莉星（B组小朋友），边是他们的“朋友关系”。我们需要判断是否存在**唯一一种方式**，让每个小朋友都找到一个朋友（完美匹配）。

#### 核心算法思想
这道题的关键结论是：**如果二分图有且仅有一个完美匹配，那么图中必然存在度数为1的点**（即某个小朋友只有1个朋友）。因为：
- 若一个点度数为1，它只能和唯一的点配对（否则自己就没朋友了）；
- 把这对“绑定”的点从图中“牵走”，剩下的小朋友继续找度数为1的点，重复这个过程；
- 如果最后所有小朋友都被“牵走”，说明只有1种配对方式（Renko）；
- 如果剩下的小朋友都有至少2个朋友，说明他们可以换朋友（有多种配对方式）或根本无法配对（Merry）。


#### 算法流程与可视化设计
算法的核心是**“拓扑式删除”**：
1. 找所有度数为1的点，放进队列；
2. 每次取出队列中的点，找到它的唯一配对点（未被删除的邻接点）；
3. 标记这两个点为“已删除”，并减少它们邻居的度数；
4. 如果邻居的度数变为1，加入队列；
5. 最后检查是否所有点都被删除。

**可视化设计思路**：
- **像素风格**：左边莲子星用红色像素块，右边梅莉星用蓝色像素块，边用白色细线；
- **状态高亮**：度数为1的点闪烁黄色，队列中的点用蓝色框包围，已删除的点变成灰色；
- **动态过程**：删除时，两个点“牵手”（红色+蓝色像素块合并成紫色）后消失，边逐渐淡化；
- **音效**：入队时“叮”，删除时“啪”，完成时“哇”的胜利音效，失败时“嘟”的提示音；
- **交互**：支持“单步执行”（看每一步删除）、“自动播放”（调速滑块控制速度）、“重置”（重新开始动画）。


## 2. 精选优质题解参考

### 题解一：（来源：retep，赞23）
* **点评**：这份题解是最经典的实现，思路像“剥洋葱”一样层层推进——先找度数1的点，再删配对点，最后检查结果。代码用`vector`存邻接表，`in`数组存度数，`del`数组标记删除，队列处理度数变化，逻辑清晰到“每一行都能看懂”。比如右边的点重新编号（`v+=n`）避免左右混淆，`while(del[to[now][buf]])`找未被删除的配对点，这些细节都很贴心，适合新手模仿。


### 题解二：（来源：Cocoly1990，赞9）
* **点评**：这题解的“亮点”是**证明了结论的正确性**——如果所有点度数≥2，且有完美匹配，那么必然存在一个环（小朋友可以换朋友），所以完美匹配不唯一。代码用`vis`数组标记删除，`deg`数组存度数，队列处理更简洁，还特意提醒“多测要清空”（新手最容易犯的错！）。


### 题解三：（来源：WhisperingWillow，赞2）
* **点评**：这题解的“杀招”是**快读模板**（比`scanf`快5倍），适合处理大数据（比如`n=1e6`）。代码用`vector`存图，`du`数组存度数，`del`数组标记删除，队列处理和前两题类似，但快读的加入让代码更高效。另外，代码里的`(int)G[u].size()`避免了`size_t`的类型问题，细节满分！


## 3. 核心难点辨析与解题策略

### 🔍 核心难点1：如何高效“删除”点和更新度数？
**问题**：真的删除点会导致邻接表混乱，无法处理后续操作。  
**解决**：用`del`数组标记“已删除”，用`in`/`deg`数组存当前度数。删除点时，**不删邻接表**，只标记`del`为`true`，并减少邻居的度数（`--du[neighbor]`）。


### 🔍 核心难点2：如何找到度数1的点的配对点？
**问题**：度数1的点可能有多个邻接点，但只有未被删除的那个是配对点。  
**解决**：遍历邻接表，找第一个`del`为`false`的点（比如`for(int i=0; i<G[u].size(); i++) if(!del[G[u][i]]) { id=G[u][i]; break; }`）。


### 🔍 核心难点3：多测时如何正确初始化？
**问题**：多组测试用例如果不清空数组，会导致数据残留（比如上一组的`del`数组还在）。  
**解决**：每组测试用例前，必须清空`vector`（`G[i].clear()`）、`del`数组（`del[i]=0`）、`in`/`deg`数组（`in[i]=0`）。


### ✨ 解题技巧总结
1. **点编号技巧**：右边的点重新编号（`v+=n`），避免左右点编号冲突；
2. **队列优化**：用队列存度数为1的点，避免每次遍历所有点找度数1的点；
3. **标记替代删除**：用`del`数组标记已删除的点，比真删除更高效；
4. **快读优化**：处理大数据时，用快读模板替代`scanf`，避免超时。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合retep、Cocoly1990、WhisperingWillow的优质题解，提炼出的清晰完整实现。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

const int MAXN = 2e6 + 10; // 左右各n点，总点数2n，n≤1e6

vector<int> G[MAXN]; // 邻接表：G[u]存u的邻接点
int deg[MAXN];       // 每个点的当前度数
bool del[MAXN];      // 标记点是否被删除
int n, m;

void solve() {
    cin >> n >> m;
    // 初始化
    for (int i = 1; i <= 2 * n; i++) {
        G[i].clear();
        deg[i] = 0;
        del[i] = false;
    }
    // 读入边：左边u，右边v→编号v+n
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        int v_right = v + n;
        G[u].push_back(v_right);
        G[v_right].push_back(u);
        deg[u]++;
        deg[v_right]++;
    }
    // 队列存度数为1的点
    queue<int> q;
    for (int i = 1; i <= 2 * n; i++) {
        if (deg[i] == 1) {
            q.push(i);
        }
    }
    // 拓扑式删除
    int cnt = 0; // 已删除的点数
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        if (del[u]) continue; // 已经被删除，跳过
        // 找u的配对点（未被删除的邻接点）
        int pair_v = -1;
        for (int v : G[u]) {
            if (!del[v]) {
                pair_v = v;
                break;
            }
        }
        if (pair_v == -1) continue; // 没有配对点（无解）
        // 删除u和pair_v
        del[u] = true;
        del[pair_v] = true;
        cnt += 2;
        // 更新pair_v的邻居的度数
        for (int neighbor : G[pair_v]) {
            if (!del[neighbor]) {
                deg[neighbor]--;
                if (deg[neighbor] == 1) {
                    q.push(neighbor);
                }
            }
        }
    }
    // 输出结果：是否删完所有点
    if (cnt == 2 * n) {
        cout << "Renko" << endl;
    } else {
        cout << "Merry" << endl;
    }
}

int main() {
    ios::sync_with_stdio(false); // 加速cin
    cin.tie(nullptr);            // 解除cin和cout的绑定
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```
* **代码解读概要**：
  1. **初始化**：每组测试用例前清空邻接表、度数数组、删除标记；
  2. **存图**：右边的点编号+`n`，避免左右冲突；
  3. **找度数1的点**：存入队列；
  4. **拓扑删除**：取出队列中的点，找配对点，删除并更新邻居的度数；
  5. **结果判断**：如果删除了所有点（`cnt=2n`），输出Renko，否则Merry。


### 题解一（来源：retep）核心片段赏析
* **亮点**：用`vector`存邻接表，逻辑清晰，处理配对点的方式很直接。
* **核心代码片段**：
```cpp
while (!q.empty()) {
    int now = q.front(); q.pop();
    if (del[now] || in[now] != 1) continue;
    del[now] = true; cnt++;
    // 找配对点
    int buf = 0;
    while (del[to[now][buf]]) buf++;
    int pair_v = to[now][buf];
    del[pair_v] = true; cnt++;
    // 更新邻居的度数
    for (int i : to[pair_v]) {
        if (!del[i] && (--in[i]) == 1) {
            q.push(i);
        }
    }
}
```
* **代码解读**：
  - `while (del[to[now][buf]]) buf++;`：遍历邻接表，找第一个未被删除的配对点；
  - `--in[i] == 1`：邻居的度数减少后变为1，加入队列；
  - 用`cnt`统计已删除的点数，最后判断是否等于`2n`。
* **学习笔记**：处理配对点时，用`while`循环找未被删除的点，比`for`循环更高效（避免遍历所有邻接点）。


### 题解三（来源：WhisperingWillow）核心片段赏析
* **亮点**：用快读模板加速输入，处理大数据时更高效。
* **核心代码片段**：
```cpp
inline int read() {
    int f = 1, x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return f * x;
}
```
* **代码解读**：
  - 快读的原理是直接读取字符，避免`scanf`的格式转换开销；
  - `f`处理负数（本题中不需要，但通用），`x`累加数字；
  - 比`scanf`快5倍左右，适合`m=2e6`的大数据。
* **学习笔记**：处理大数据时，快读是“必备技能”，能避免超时。


## 5. 算法可视化：像素动画演示方案

### 🎮 动画主题：像素小朋友的“牵手游戏”
**设计思路**：用8位像素风还原题目场景，让算法过程“看得见、听得到”，增强记忆点。


### 🖥️ 动画帧步骤与交互
1. **场景初始化**：
   - 屏幕左侧是红色像素块（莲子星，编号1~n），右侧是蓝色像素块（梅莉星，编号n+1~2n）；
   - 控制面板有“开始”“单步”“重置”按钮，速度滑块（1~5档）；
   - 背景播放8位风格的轻快BGM（比如《超级马里奥》的背景音乐）。

2. **算法启动**：
   - 度数为1的点闪烁黄色（比如点1），并滑入队列区域（屏幕下方的蓝色像素框）；
   - 入队时播放“叮”的音效。

3. **核心步骤演示**：
   - **单步执行**：点击“单步”，队列中的点（比如点1）取出，找到配对点（比如点n+1）；
   - **删除动画**：点1（红）和点n+1（蓝）合并成紫色像素块，然后逐渐消失，边变成灰色；
   - **度数更新**：点n+1的邻居（比如点2）度数减少1，变成浅绿色闪烁；
   - **音效**：删除时播放“啪”，度数更新时播放“嗒”。

4. **结果展示**：
   - 如果所有点都被删除，屏幕弹出“胜利！”的像素文字，播放“哇”的音效；
   - 如果有剩余点，屏幕弹出“失败”的像素文字，播放“嘟”的音效。


### 🎧 音效设计
- **入队**：高频“叮”（强化“加入队列”的记忆）；
- **删除**：低频“啪”（强化“点被删除”的动作）；
- **度数更新**：中频“嗒”（提示“度数变化”）；
- **胜利**：上扬的“哇”（增强成就感）；
- **失败**：短促的“嘟”（提示错误）。


## 6. 拓展练习与相似问题

### 📚 相似问题
1. **洛谷P3386 【模板】二分图匹配**：练习二分图匹配的基础算法（匈牙利算法）；
2. **洛谷P2055 假期的宿舍**：判断二分图是否存在完美匹配，是本题的“前置练习”；
3. **洛谷P1894 [USACO4.2]完美的牛栏**：同样考察二分图的完美匹配，可用于巩固度数分析的思路。


### 🚀 进阶练习
1. **洛谷P4016 负载平衡问题**：用类似拓扑的方法处理节点的“流量”问题；
2. **洛谷P5018 对称二叉树**：练习用队列处理树的节点状态，强化“标记+遍历”的技巧。


## 7. 学习心得与经验分享

### 💡 来自题解的经验
- **多测初始化很重要**：所有题解都强调“多测要清空数组”（比如`G[i].clear()`、`del[i]=0`），否则上一组的残留数据会导致错误；
- **度数是关键**：本题的核心是“度数为1的点”，所有操作都围绕它展开，抓住这个点就能快速解题；
- **模拟删除比真删除高效**：用`del`数组标记删除，比修改邻接表更高效，避免了复杂的结构调整。


## 💪 总结与鼓励
这道题的关键是**“抓住度数为1的点”**，用拓扑式的方法逐步删除。虽然看起来是图论问题，但核心是“模拟+优化”的编程技巧。记住：**编程的本质是“用代码模拟解决问题的过程”**，只要把问题拆分成一步步的“小操作”，再用代码实现，就能解决大部分问题！

下次遇到类似的问题，不妨先问自己：**“有没有哪个点的状态是唯一确定的？”** 找到这个“突破口”，问题就会变得简单。加油，你一定能掌握！🎉

---
处理用时：87.51秒
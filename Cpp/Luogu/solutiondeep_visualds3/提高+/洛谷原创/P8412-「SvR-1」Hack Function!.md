# 题目信息

# 「SvR-1」Hack Function!

## 题目背景

**Problem Number:** $\textit{63}$

小 C 坐在 J-PSC2077 的赛场（题目可于下方「**题目附件**」处下载）上，他早已年逾七旬，但作为 Z 队选手还是成功参赛。

## 题目描述

此时的 J-PSC 终于改成了 CF 赛制，小 C 迅速地 AK 了 Day 1，他发现 T2 function 比较好 Hack，题目的人话翻译如下：

> 对于一个数 $A$，定义函数 $f(A)$ 如下：
> 
> 1. 先把 $A$ 变成 $k$ 进制数 $B$。
> 2. 将 $A$ 替换为 $B$ 各位之和。
> 3. 返回执行第 1 步，直到 $B$ 是一位数为止。
> 4. 记 $x$ 表示 $A$ 此时的值（十进制）。
> 此时 $f(A) = x$，$f(A)$ 称作 $A$ 关于 $k$ 的**位和函数**。
>
> 给定 $k, l, r, p$，求出 $\sum_{i = l}^r f(i^i) \bmod p$ 的值。
>
> **特别地，当 $\sum_{i = l}^r f(i^i) = p$ 时，输出 $\texttt{perfect}$。**

小 C 迅速秒了该题，当他翻看别人的代码时，发现他们用的全是暴力枚举。（因为机子跑得飞快）

好不容易看到一个人，他的代码里竟然没有一个  $\texttt{perfect}$！但由于数据过弱，竟然让他 pp 了。

小 C 突然脑子一热，忘记了怎么构造 Hack 数据，所以他通过 Luogu 6.0 求助于你。

小 C 会告诉你 $k, p$ 的值，你需要构造一组 $l, r$，**使答案输出为 $\texttt{perfect}$**。

**若无法构造，输出两个 $\texttt{-1}$。**

## 说明/提示

#### 样例 1 说明

- 对于数据 $1$，在 $k = 10$ 下，有 $f(2^2) = f(4) = 4$，$f(3^3) = f(27) = 9$，显然 $l = 2, r = 3$ 时原题应该输出 $\texttt{perfect}$。
- 对于数据 $2$，在 $k = 10$ 下，发现不可能满足要求。
- 对于数据 $3$，在 $k = 2$ 下，显然有 $f(1^1) = 1$，但该样例仅用于理解，根据数据规模与约定，我们保证 $k \geq 10$。

#### 数据规模与约定

$$
\newcommand{\arraystretch}{1.5}
\begin{array}{c|c|c|c}\hline\hline
\textbf{Subtask} & \textbf{说明} & \textbf{时限} & \textbf{分值} \\\hline
\textsf{1} & \text{无解} & 1\text{ s} & 3 \\\hline
\textsf{2} & \text{有解且\textbf{\textsf{存在}}一组解使 }1\le l\le r\le 10^5 & 1\text{ s} & 16 \\\hline
\textsf{3} & 1\le p\le 10^7 & 1\text{ s} & 34 \\\hline
\textsf{4} & \text{无特殊限制} & 1.5\text{ s} & 47 \\\hline\hline
\end{array}
$$

对于 $100\%$ 的数据，$10 \leq k \leq 10^3$，$1 \leq p \leq 10^8$，$1 \leq T \leq 10$。

保证时限在 std 用时的 $4$ 倍以上。

#### 评测说明

**本题开启 Special Judge 和捆绑测试。**

你需要保证 $l = r = -1$ 或 $1 \leq l \leq r \leq 10^{18}$ 且 $r - l \leq 10^{15}$，否则 SPJ 会将你的答案判为 $0$ 分。

## 样例 #1

### 输入

```
3
10 13
10 3
2 1```

### 输出

```
2 3
-1 -1
1 1```

# AI分析结果

---
# 💡 Kay的C++算法解析：「SvR-1」Hack Function! 深入学习指南 💡

今天我们来分析「SvR-1」Hack Function! 这道题——核心是用数学结论简化问题，再用编程技巧找区间和。跟着Kay一步步拆解，你会发现这道题其实“纸老虎”！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（f函数的推导） + 编程技巧应用（前缀和、双指针/哈希找区间和、循环节利用）

🗣️ **初步分析**：
解决这道题的关键是**推导f函数的数学结论**——**f(A) = (A-1) mod (k-1) + 1**。简单来说，把数字压缩成k进制一位数，等价于求A对(k-1)取模后调整为非零值（比如k=10时，27→9=27 mod9，4→4=4 mod9）。这个结论把复杂的迭代位和变成了一行模运算，是解题的“钥匙”！

接下来，问题转化为**找区间[l,r]，使区间内f(i^i)的和等于p**。因为f(i^i)是正整数，区间和随右端点增加而**单调递增**——这让我们可以用**双指针**（滑动窗口）或**前缀和+哈希**（找前缀和之差）快速定位区间。此外，i^i mod (k-1)有**循环节**（前φ(k-1)个不循环，后面每lcm(k-1,φ(k-1))个循环一次），利用循环节可以处理大到1e18的l和r！

**可视化设计思路**：用8位像素风模拟“探险家找宝藏”——每个像素块代表f(i^i)值（颜色越深值越大），双指针是红/蓝小箭头，区间和是“宝藏能量条”。循环节部分用“魔法圈”闪烁，找到区间时播放胜利音效，增强记忆点！


## 2. 精选优质题解参考

为大家筛选了4份评分≥4星的优质题解，覆盖不同解题思路：

### 题解一：CSP_Sept（官方题解）
这份题解是“解题大纲”！它先推导f函数的结论，再分情况讨论：前φ(k-1)个暴力算前缀和，后面用循环节。思路清晰，是理解题目的“入门指南”。

### 题解二：lgvc
官方题解的“补充版”！补充了循环节的处理细节，比如预处理循环节内的前缀和，用哈希表找区间和。代码偏向“可落地”，适合想写代码的同学。

### 题解三：yizhiming（双指针）
**亮点**：用双指针代替哈希表！正序列的区间和单调递增——右指针扩区间（加和），左指针缩区间（减和），直到找到和为p的区间。时间复杂度O(n)，比哈希更快，适合大p的情况。

### 题解四：Leasier（哈希表）
“细致版”题解！拆解了每个子任务的处理（比如Subtask1直接输出-1，Subtask3用循环节），用哈希表记录前缀和的位置。代码逻辑清晰，适合学习“分情况处理”。


## 3. 核心难点辨析与解题策略

### 1. 难点1：为什么f(A)=(A-1)mod(k-1)+1？
**分析**：k进制下，任何数A都可以写成a₀ + a₁k + a₂k² + … + aₘkᵐ。因为k≡1 mod(k-1)，所以kⁱ≡1ⁱ=1 mod(k-1)——A≡a₀+a₁+…+aₘ mod(k-1)。迭代后结果不变，调整为非零值就是f(A)。
**解决方法**：记结论！或手动算例子（k=10，27→9=27 mod9；10→1=10 mod9）加深理解。

### 2. 难点2：i^i mod (k-1)的循环节在哪里？
**分析**：根据**扩展欧拉定理**，模数m=k-1时，i^i mod m的循环节分两部分：前φ(m)个不循环，后面每lcm(m,φ(m))个循环一次（φ是欧拉函数）。比如m=9（k=10），φ(m)=6，循环节长度18。
**解决方法**：复习扩展欧拉定理，计算φ(m)和循环节长度（lcm(m,φ(m))）。

### 3. 难点3：如何高效找区间和等于p？
**分析**：f(i^i)是正整数，区间和单调递增——有两种方法：
- **双指针**：左右指针滑动，O(n)时间，适合大范围。
- **哈希表**：前缀和之差，O(n log n)时间，适合小范围。
**解决方法**：根据数据规模选——大p用双指针，小p用哈希。

### ✨ 解题技巧总结
- **数学结论优先**：位和问题先想mod(k-1)。
- **循环节简化计算**：大范围内的重复规律，用循环节减少计算量。
- **正序列用双指针**：比哈希更快，是区间和的“神器”。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合双指针和循环节处理，是一份清晰的核心实现。
**完整核心代码**：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;

int get_phi(int k) {
    int ans = 1;
    for (int i = 2; i * i <= k; i++) {
        if (k % i == 0) {
            ans *= i - 1;
            k /= i;
            while (k % i == 0) { ans *= i; k /= i; }
        }
    }
    if (k > 1) ans *= k - 1;
    return ans;
}

int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
int lcm(int a, int b) { return a * b / gcd(a, b); }

ll quick_pow(ll x, ll p, ll mod) {
    ll ans = 1;
    while (p) {
        if (p & 1) ans = ans * x % mod;
        x = x * x % mod;
        p >>= 1;
    }
    return ans;
}

int get_f(int i, int kd, int phi_kd) {
    ll val;
    if (i <= phi_kd) val = quick_pow(i, i, kd);
    else val = quick_pow(i % kd, i % phi_kd + phi_kd, kd);
    return (val + kd - 1) % kd + 1; // 调整为非零
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T; cin >> T;
    while (T--) {
        int k, p; cin >> k >> p;
        int kd = k - 1;
        if (kd == 0) { cout << "-1 -1\n"; continue; }
        int phi_kd = get_phi(kd);
        int cycle_len = lcm(kd, phi_kd);
        int rmax = phi_kd + cycle_len;
        
        ll sum = 0;
        int l = 1, r = 0;
        bool ok = false;
        ll* f_val = new ll[rmax + 1]();
        
        for (r = 1; r <= rmax; r++) {
            f_val[r] = get_f(r, kd, phi_kd);
            sum += f_val[r];
            while (sum > p) { sum -= f_val[l]; l++; }
            if (sum == p) { ok = true; break; }
        }
        
        if (!ok) {
            ll cycle_sum = 0;
            for (int i = phi_kd + 1; i <= rmax; i++) cycle_sum += f_val[i];
            if (cycle_sum == 0) { ok = false; }
            else {
                ll need = p - sum;
                ll cnt = need / cycle_sum;
                sum += cnt * cycle_sum;
                r += cnt * cycle_len;
                if (sum == p) ok = true;
                else {
                    for (int i = 1; i <= 2 * cycle_len; i++) {
                        int idx = phi_kd + (i > cycle_len ? i - cycle_len : i);
                        sum += f_val[idx];
                        r++;
                        while (sum > p) { sum -= f_val[l]; l++; }
                        if (sum == p) { ok = true; break; }
                    }
                }
            }
        }
        
        if (ok) cout << l << " " << r << "\n";
        else cout << "-1 -1\n";
        delete[] f_val;
    }
    return 0;
}
```
**代码解读概要**：
1. **数学函数**：`get_phi`计算欧拉函数，`quick_pow`快速幂。
2. **get_f**：根据扩展欧拉定理计算f(i^i)。
3. **主逻辑**：双指针找区间和，处理循环节（乘以循环次数后再找）。


### 针对各优质题解的片段赏析

#### 题解三：yizhiming（双指针）
**亮点**：用双指针处理正序列区间和。
**核心代码片段**：
```cpp
int l = 1;
ll sum = 0;
for (r = 1; r <= rmax; r++) {
    f[r] = get_f(r);
    sum += f[r];
    while (sum > p) { sum -= f[l]; l++; }
    if (sum == p) { ok = 1; break; }
}
```
**代码解读**：
- r右移：加f[r]，区间和扩大。
- sum超过p时，l右移：减f[l]，区间和缩小。
- 等于p时，找到区间[l,r]！
**学习笔记**：正序列的区间和问题，双指针是“神器”——O(n)时间，比哈希更快！


#### 题解四：Leasier（哈希表）
**亮点**：用哈希表找前缀和之差。
**核心代码片段**：
```cpp
mp1.clear();
mp1.assign(0, 0);
for (int j = 1; j <= n; j++) {
    sum1[j] = sum1[j-1] + get_f(j);
    if (sum1[j] >= p && mp1.count(sum1[j] - p)) {
        ansl = mp1.query(sum1[j]-p)+1;
        ansr = j;
        break;
    }
    mp1.assign(sum1[j], j);
}
```
**代码解读**：
- mp1记录前缀和sum1[j]对应的j。
- 找sum1[j]-p（即S[l-1]），若存在则l=mp1.query(...) +1，r=j。
**学习笔记**：哈希表适合小范围前缀和查找，但要注意冲突！


## 5. 算法可视化：像素动画演示方案

### 动画主题：《像素探险家找宝藏》
**设计思路**：用8位像素风模拟“探险家找宝藏”，降低学习压力；用音效和动画强化关键步骤记忆。

### 动画帧步骤：
1. **场景初始化**：
   - 左侧像素网格：每个格子代表i的f(i^i)值（颜色越深值越大）。
   - 右侧控制面板：开始/暂停、单步、重置按钮；速度滑块；能量条（显示当前区间和）。
   - 播放《超级马里奥》风格的轻快背景音乐。

2. **f函数演示**：
   - 输入x=27，k=10：动画显示27的像素块→分解成2和7→合并成9，伴随“叮”的音效（表示计算完成）。

3. **双指针找区间和**：
   - 左指针（红箭头）、右指针（蓝箭头）初始在i=1。
   - 右指针右移：蓝箭头滑到i=2，对应格子变亮，能量条增加f(2^2)，伴随“嘀”声。
   - 能量条超过p时，左指针右移：红箭头滑到i=2，能量条减少f(1^1)，伴随“嗒”声。
   - 能量条等于p时，区间[l,r]的格子闪烁金色，播放《魂斗罗》通关音效，提示“找到宝藏啦！”。

4. **循环节演示**：
   - 循环节内的格子用“紫色魔法圈”包围，闪烁提示。
   - 点击“自动循环”，能量条快速增长（对应多个循环节的和），伴随“嗖嗖”声。

### 交互控制：
- 单步执行：点击“下一步”，指针移动一步，显示文字提示（比如“右指针到i=3，sum+5”）。
- 自动播放：速度滑块调节（慢→快），适合快速看流程。
- 重置：回到初始状态，重新开始。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **数学结论**：位和问题→mod(k-1)。
- **循环节**：大范围内的重复规律→用循环节减少计算量。
- **区间和**：正序列→双指针；任意序列→哈希。

### 练习推荐（洛谷）
1. **P1147 连续自然数和**：双指针找连续和，巩固区间和思路。
2. **P2678 跳石头**：二分+双指针，练习双指针应用。
3. **P3900 斐波那契数列**：循环节（Pisano周期），巩固循环节处理。
4. **P4139 上帝与集合的正确用法**：扩展欧拉定理，巩固模运算。


## 7. 学习心得与经验分享 (若有)

**参考经验（来自yizhiming的题解）**：“我一开始用map，但大p太慢，后来想到双指针——正序列的区间和单调，双指针肯定行！”
**点评**：根据数据特性选算法是关键！正序列的区间和问题，双指针比哈希更快——多观察数据特点，能少走弯路。


## 结论
本次分析了「SvR-1」的核心思路：数学结论简化f函数，双指针/哈希找区间和，循环节处理大范围。记住：数学结论是“钥匙”，双指针是“神器”，循环节是“加速器”！多练类似题目，你会越来越熟练～💪

---
处理用时：160.93秒
# 题目信息

# [CoE R5] 罚球

## 题目描述

有 $n$ 个人在玩罚球游戏，游戏规则如下：
- 每个人编号为 $1,2,\dots,n$，最开始由 $1$ 号罚球，接下来让下一个没有出局的人罚球。特殊地，$n$ 号的下一个是 $1$ 号。
- 如果罚球者没有碰到篮板，那么直接出局。
- 如果罚球者碰到篮板但没有进球，那么如果上一个人进球了，这个人就会出局，否则不会出局。
- 游戏结束的条件是最后只剩下一个人。

注意最开始的那个人碰到篮板但没有进球不出局。

这 $n$ 个人中，第 $i$ 个人碰不到篮板的概率为 $\dfrac{a_i}{1000}$，碰到篮板但没有进球的概率为 $\dfrac{b_i}{1000}$，求游戏结束时所有人总共罚球数量的期望值。

## 说明/提示

**关于取模**

不会有理数取模的看[这里](https://www.luogu.com.cn/problem/P2613)。



------------
**样例说明**

输入 $\#1$：

所有人碰不到篮板的概率都是 $\dfrac{1}{5}$，碰到篮板但不进球的概率都是 $\dfrac{2}{5}$，罚球数量的期望值为 $\dfrac{25}{9}$。

计算如下（黑色表示出局，红色表示没进球但不出局，蓝色表示进球）：
$$\dfrac{1}{5}+\red{\dfrac{2}{5}}\times(\dfrac{1}{5}+\red{\dfrac{2}{5}}\times(...)+\blue{\dfrac{2}{5}}\times(...))+\blue{\dfrac{2}{5}}\times(\dfrac{3}{5}+\blue{\dfrac{2}{5}}\times(...))=\dfrac{25}{9}$$

输入 $\#2$：

所有人碰不到篮板的概率都是 $\dfrac{321}{1000}$，碰到篮板但不进球的概率都是 $\dfrac{637}{1000}$，罚球数量的期望值为 $\dfrac{1000000}{57959}$。

------------

**数据范围**

**本题采用捆绑测试**。

测试点性质：
| $t=$ | 性质 | 分数 |
| :----------: | :----------: | :----------: |
| $1$ | $n=1$ | $2$ |
| $2$ | $a_i=b_i=0$ | $2$ |
| $3$ | $a_i=1000$ | $4$ |
| $4$ | $b_i=1000$ | $4$ |
| $5$ | $a_i=0,b_1=0,\forall i>1,b_i=1000$ | $6$ |
| $6$ | $a_i=b_i=500$ | $6$ |
| $7$ | $a_i=0,b_i=500$ | $6$ |
| $8$ | $a_i,b_i$ 均为定值，且答案不为 $-1$ | $19$ |
| $9$ | $1 \le n \le 11$ | $26$ |
| $10$ | $1 \le n \le 15$ | $8$ |
| $11$ | 无特殊性质 | $17$ |

**对于** $100\%$ **的数据**，$1 \le n \le 18$，$0 \le a_i,b_i,a_i+b_i \le 1000$。

本题的 $\text{Subtask 10}$ 分为两部分计分，对应 $t \in \{10,11\}$。

保证不存在分母为 $10^6+33$ 的倍数的情况。

## 样例 #1

### 输入

```
2 8
200 400
200 400```

### 输出

```
888921```

## 样例 #2

### 输入

```
7 8
321 637
321 637
321 637
321 637
321 637
321 637
321 637```

### 输出

```
818968```

## 样例 #3

### 输入

```
6 10
338 270
229 413
132 133
141 173
157 686
616 250```

### 输出

```
315860```

## 样例 #4

### 输入

```
8 10
338 270
229 413
132 133
141 173
157 686
616 250
0 0
0 0```

### 输出

```
-1```

# AI分析结果

# 💡 Kay的C++算法解析：[CoE R5] 罚球 深入学习指南 💡

<introduction>
今天我们来一起分析“[CoE R5] 罚球”这道C++编程题。这道题结合了**状态压缩动态规划（状压DP）**和**高斯消元**，需要我们理解期望的计算、转移中的环处理，以及如何高效求解线性方程组。本指南将帮你梳理思路、掌握核心算法，并通过可视化动画直观感受解题过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（状压DP） + 数学（高斯消元）

🗣️ **初步分析**：
解决这道题的关键，就像玩“关卡解锁游戏”——我们需要记录三个核心信息：
- **存活集合**：用二进制表示（比如`S=101`代表1、3号存活）；
- **当前罚球者**：比如`i=1`表示该1号罚球；
- **上一个人的结果**：`0`表示没进，`1`表示进了（影响当前人的出局条件）。

这三个信息组成**状态**（类似游戏的“当前关卡状态”），我们要计算从这个状态到“只剩一人”的期望罚球次数——这就是**状压DP**的核心：用二进制压缩状态，记录子问题的解。

但状态转移会出现“环”（比如当前状态依赖下一个状态，下一个状态又依赖回当前状态），就像游戏中“先打小怪才能打Boss，但打Boss需要先打小怪”的循环。这时需要用**高斯消元**“解开”环：把所有状态的期望写成线性方程组，求解每个状态的解。

在本题中，状压DP用于**压缩状态**，高斯消元用于**处理转移环**。比如计算存活集合`S`的期望时，先算`S`的子集（已解锁的“小关卡”），再对`S`内的状态构建方程组求解。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、优化程度等方面筛选了以下优质题解：
</eval_intro>

**题解一：官方题解（作者：Alarm5854）**
* **点评**：出题人提供的标准解法，覆盖所有子任务。清晰定义了`f(S,i,0/1)`状态（存活集合`S`、当前罚球者`i`、上一个结果`0/1`），并详细推导转移方程。代码中预处理逆元（避免重复计算），对每个集合`S`构建矩阵并高斯消元，逻辑严谨，适合作为“基础模板”。

**题解二：倒序枚举+手动消元（作者：QQ82272760）**
* **点评**：倒序处理集合（从全存活到空集），手动解二元方程组（避免复杂矩阵构建）。用`g[i][0/1]`记录状态的线性组合系数，再回代计算所有状态的期望。代码简洁，适合理解“如何手动处理小方程组”。

**题解三：分阶段消元（作者：do_while_true）**
* **点评**：优化点突出——分阶段计算`f1`（上一个进了）和`f0`（上一个没进），将高斯消元复杂度从`O(m³)`降到`O(m)`。先算`f1`（依赖子集的解），再算`f0`（依赖`f1`的解），效率更高，结构清晰。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
以下是解决本题的三个关键“卡关点”及破解方法：
</difficulty_intro>

### 难点1：如何定义状态？
**分析**：状态需包含**存活集合、当前罚球者、上一个结果**（三者缺一不可）。比如`f(S,i,0)`表示存活集合`S`、当前`i`罚球、上一个没进的期望次数。若状态定义不全，会漏掉出局条件（比如上一个进了，当前碰了没进就会出局）。  
💡 **学习笔记**：状态要“包含所有影响转移的信息”——像游戏中“当前关卡的所有关键参数”都要记录。

### 难点2：如何处理转移中的环？
**分析**：当存活集合`S`的状态转移依赖`S`内的其他状态（比如`f(S,i,0)`依赖`f(S,j,1)`，`f(S,j,1)`又依赖`f(S,i,0)`），会形成环。此时需将`S`内的状态写成线性方程组，用高斯消元求解。例如：
`f(S,i,1) = (a[i]+b[i])*f(S\i, next(i),0) + c[i]*f(S, next(i),1) + 1`  
其中`f(S\i, ...)`是已知的（子集已计算），`f(S, next(i),1)`是未知的，形成关于`f(S,i,1)`的方程组。  
💡 **学习笔记**：转移环需用高斯消元“线性化”——把状态期望写成未知量，转移方程写成线性等式，再解方程组。

### 难点3：如何判断无解？
**分析**：若存在多个“永远存活”的人（比如两人都是“百发百中”，`a[i]=0,b[i]=0`），游戏永远不会结束，期望无穷大，输出`-1`。例如题解中的判断：
`if(ct1>=2 || (ct2>=2&&ct3==n))`（`ct1`是百发百中人数，`ct2`是只碰篮板不进球的人数）。  
💡 **学习笔记**：无解的核心是“存在无法减少存活人数的循环”——像游戏中“永远打不完的小怪”，导致无法通关。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**综合优质题解的核心实现**，按集合大小处理，分阶段消元，结构清晰：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合do_while_true和官方题解的思路，按集合大小从小到大处理，分阶段计算`f1`和`f0`，用高斯消元求解方程组。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int mod = 1000033;
const int N = 19;

int n, T;
int a[N], b[N], c[N], inv1000;
int f[1 << 18][N][2]; // f[S][i][0/1]：存活集合S，当前i罚球，上一个结果0/1的期望

int qpow(int x, int y) {
    int s = 1;
    while (y) {
        if (y & 1) s = 1LL * s * x % mod;
        x = 1LL * x * x % mod;
        y >>= 1;
    }
    return s;
}

inline int add(int x, int y) { return (x + y) % mod; }
inline int del(int x, int y) { return (x - y + mod) % mod; }

// 高斯消元：求解u[i]*ans[i] + v[i]*ans[i+1] = w[i]
void Gauss(int m, int u[], int v[], int w[], int ans[]) {
    for (int i = 1; i <= m; ++i) {
        int inv_v = qpow(v[i], mod - 2);
        for (int j = i + 1; j <= m; ++j) {
            int coef = 1LL * v[j] * inv_v % mod;
            v[j] = del(v[j], 1LL * coef * v[i] % mod);
            w[j] = del(w[j], 1LL * coef * w[i] % mod);
        }
    }
    ans[m] = 1LL * w[m] * qpow(v[m], mod - 2) % mod;
    for (int i = m - 1; i >= 1; --i) {
        ans[i] = del(w[i], 1LL * v[i] * ans[i + 1] % mod);
        ans[i] = 1LL * ans[i] * qpow(u[i], mod - 2) % mod;
    }
}

// 处理集合S，计算f[S][i][0/1]
void solve(int S) {
    vector<int> p; // 存活的人（按顺序）
    for (int i = 1; i <= n; ++i)
        if (S & (1 << (i - 1))) p.push_back(i);
    int m = p.size();
    if (m == 1) return; // 只剩一人，期望为0

    // 第一步：计算f[S][i][1]（上一个进了）
    int u[m + 2], v[m + 2], w[m + 2], ans[m + 2];
    for (int i = 0; i < m; ++i) {
        int x = p[i];
        int next_i = p[(i + 1) % m];
        u[i + 1] = 1;
        v[i + 1] = del(0, c[x]);
        int const_term = add(1LL * a[x] * f[S ^ (1 << (x - 1))][next_i][0] % mod,
                             1LL * b[x] * f[S ^ (1 << (x - 1))][next_i][0] % mod);
        const_term = add(const_term, 1);
        w[i + 1] = const_term;
    }
    Gauss(m, u, v, w, ans);
    for (int i = 0; i < m; ++i)
        f[S][p[i]][1] = ans[i + 1];

    // 第二步：计算f[S][i][0]（上一个没进）
    for (int i = 0; i < m; ++i) {
        int x = p[i];
        int next_i = p[(i + 1) % m];
        u[i + 1] = 1;
        v[i + 1] = del(0, b[x]);
        int const_term = add(1LL * a[x] * f[S ^ (1 << (x - 1))][next_i][0] % mod,
                             1LL * c[x] * f[S][next_i][1] % mod);
        const_term = add(const_term, 1);
        w[i + 1] = const_term;
    }
    Gauss(m, u, v, w, ans);
    for (int i = 0; i < m; ++i)
        f[S][p[i]][0] = ans[i + 1];
}

int main() {
    cin >> n >> T;
    inv1000 = qpow(1000, mod - 2);
    int ct1 = 0, ct2 = 0, ct3 = 0;
    for (int i = 1; i <= n; ++i) {
        int ai, bi;
        cin >> ai >> bi;
        a[i] = 1LL * ai * inv1000 % mod;
        b[i] = 1LL * bi * inv1000 % mod;
        c[i] = del(1, add(a[i], b[i]));
        if (a[i] == 0 && b[i] == 0) ct1++; // 百发百中（永远存活）
        if (a[i] == 0 && c[i] == 0) ct2++; // 只碰篮板不进球
        if (c[i] == 0) ct3++;             // 不进球
    }
    // 无解判断
    if (ct1 >= 2 || (ct2 >= 2 && ct3 == n)) {
        cout << "-1" << endl;
        return 0;
    }
    // 初始化：只剩一人的期望为0
    for (int i = 1; i <= n; ++i)
        f[1 << (i - 1)][i][0] = f[1 << (i - 1)][i][1] = 0;
    // 按集合大小从小到大处理
    for (int k = 2; k <= n; ++k) {
        for (int S = 1; S < (1 << n); ++S) {
            if (__builtin_popcount(S) == k) {
                solve(S);
            }
        }
    }
    // 初始状态：所有存活，1号罚球，上一个结果0（根据题意）
    cout << f[(1 << n) - 1][1][0] << endl;
    return 0;
}
```

* **代码解读概要**：
1. **预处理**：读取输入，计算每个i的概率`a[i]`（没碰篮板）、`b[i]`（碰了没进）、`c[i]`（进了），预处理逆元`inv1000`。
2. **无解判断**：若有多个永远存活的人，输出`-1`。
3. **初始化**：只剩一人的期望为0。
4. **按集合大小处理**：从小到大处理每个集合`S`（存活k人），调用`solve(S)`计算`f[S][i][0/1]`。
5. **solve函数**：先算`f[S][i][1]`（上一个进了），再算`f[S][i][0]`（上一个没进），用高斯消元求解方程组。
6. **输出结果**：初始状态是所有存活、1号罚球、上一个结果0，输出`f[(1<<n)-1][1][0]`。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们设计了**8位像素风的“罚球探险家”动画**，结合复古游戏元素，直观展示状态转移和高斯消元：
</visualization_intro>

### 核心设计
- **主题**：像素人罚球游戏 + 高斯消元方程组求解。
- **风格**：8位像素风（类似FC红白机），用绿色表示存活、红色表示出局、黄色表示当前罚球者。
- **音效**：
  - 没碰篮板/进了：“叮”的清脆音效；
  - 碰了没进：“嗒”的低沉音效；
  - 过关：“胜利”上扬音效。
- **交互**：支持“单步执行”“自动播放”“重置”，速度滑块调节播放速度。


### 动画帧步骤
1. **初始化**：左侧显示n个绿色像素人（编号1~n），右侧显示空白方程组面板。播放8位背景音乐。
2. **初始罚球**：1号闪烁黄色，箭头指向2号。点击“开始”，1号罚球：
   - 若进了（`c[1]`概率）：1号闪烁绿色，播放“叮”，下一个罚球者是2号。
3. **状态转移**：2号闪烁黄色，罚球结果是碰了没进（`b[2]`概率）：2号闪烁黄色，播放“嗒”，下一个罚球者是3号。
4. **集合变化**：3号没碰篮板（`a[3]`概率）：3号变成红色，播放“叮”，集合`S`去掉3号（现在存活1、2号）。
5. **高斯消元**：右侧面板显示`S={1,2}`的方程组：
   - 行1：`f(S,1,1) - c[1]*f(S,2,1) = (a[1]+b[1])*f(S\1,2,0) + 1`（用像素块表示系数）；
   - 行2：`f(S,2,1) - c[2]*f(S,1,1) = (a[2]+b[2])*f(S\2,1,0) + 1`。
   - 消元时，行1高亮蓝色，行2的系数更新（比如行2减去行1的`c[2]`倍），用颜色渐变表示系数变化。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握状压DP+高斯消元后，可以解决更多类似问题：
</similar_problems_intro>

### 通用思路迁移
- **状压DP**：适用于状态可压缩为二进制的问题（如旅行商问题TSP、集合覆盖问题）。
- **高斯消元**：适用于处理转移中的环（如期望DP、概率DP中的循环依赖）。

### 洛谷练习推荐
1. **P3146 [USACO16OPEN] 248 G**：状压DP处理合并问题，练习状态定义和转移。
2. **P4550 收集邮票**：期望DP+高斯消元，练习处理转移环。
3. **P6156 简单题**：状压DP处理子集问题，练习按集合大小处理的技巧。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的经验分享：
</insights_intro>

> **参考经验（来自do_while_true）**：“按集合大小从小到大处理，先算子集的期望，再算当前集合的期望。这样保证计算当前集合时，子集的期望已是已知常数。”  
> **点评**：这是状压DP的核心技巧——**子集优先**，就像游戏中“先解锁小关卡，再解锁大关卡”。

> **参考经验（来自官方题解）**：“预处理逆元可以避免重复计算，比如将`a[i] = ai * inv1000 % mod`，而不是每次计算都乘`inv1000`。”  
> **点评**：预处理是编程中的“提前准备”，减少重复劳动，像游戏中“提前买好装备，不用每次打小怪都回去买”。


<conclusion>
本次分析就到这里！这道题结合了状压DP和高斯消元，需要你理解状态定义、转移环处理，以及高效求解方程组的技巧。通过可视化动画，抽象的算法变成了直观的游戏，希望能帮你更好地掌握！记住，编程的乐趣在于“解开”一个又一个的“环”，就像解开游戏中的谜题一样！💪
</conclusion>

---
处理用时：268.43秒
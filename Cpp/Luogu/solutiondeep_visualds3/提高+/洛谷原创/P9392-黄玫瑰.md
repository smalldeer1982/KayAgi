# 题目信息

# 黄玫瑰

## 题目描述

给定一张包含 $n$ 个点的简单有向无环图 $G$，点 $i$ 的点权设为 $w_i$，但**点权不是给定的**。

你需要构造一个包含至多 $2\times n$ 个点和恰好 $n$ 条边的有向无环图 $G'$，你需要为 $G'$ 的每条边钦定某个 $w_i$ 作为它的边权，使得 $G'$ 和 $G$ 的**最长路**长度相等。

在 $G$ 中一条路径的长度定义为其中所有点权和，$G'$ 中则为所有边权和。

然而，所有 $w_i$ 都不是给定的，所以你构造的 $G'$ 需要满足：对于任何一种可能的**正数**序列 $[w_1,\ldots,w_n]$，$G$ 和 $G'$ 的最长路长度都要相等。

请构造 $G'$，或说明它不存在。

## 说明/提示

**【样例 #1 解释】**

如下图，左为 $G$，右为 $G'$，颜色相同的点/边表示权值相同：

![](https://cdn.luogu.com.cn/upload/image_hosting/i0wuxctf.png)

注意这只是一种可能的答案，其他正确的答案也可通过。

---

**【样例 #2 解释】**

下图为 $G$，不存在合法的 $G'$：

![](https://cdn.luogu.com.cn/upload/image_hosting/tek49neu.png)

---

**【数据范围】**

对于全部数据：$1\leq n\leq 20000$，$1\leq m\leq 3\times 10^5$，$1\leq x,y\leq n$，保证给定的图无环且无重边。

|     子任务编号     | $n\leq$ |    $m\leq$     |           特殊性质            | 分值 |
| :----------------: | :-----: | :------------: | :---------------------------: | :--: |
| $\text{Subtask 1}$ | $5000$  |     $4999$     | $m=n-1$，每个点入度不超过 $1$ | $18$ |
| $\text{Subtask 2}$ | $5000$  |     $4999$     | $m=n-1$，每个点出度不超过 $1$ | $19$ |
| $\text{Subtask 3}$ |  $20$   |      $50$      |              无               | $20$ |
| $\text{Subtask 4}$ | $5000$  |    $10000$     |              无               | $21$ |
| $\text{Subtask 5}$ | $20000$ | $3\times 10^5$ |              无               | $22$ |

---

![](https://cdn.luogu.com.cn/upload/image_hosting/jepg6g1u.png)

## 样例 #1

### 输入

```
7 8
1 2
1 3
2 3
2 6
3 4
5 2
5 7
6 7
```

### 输出

```
7
1 2 1
1 2 5
2 3 2
3 4 3
3 5 6
4 6 4
5 7 7
```

## 样例 #2

### 输入

```
7 8
1 2
2 3
2 6
4 5
4 7
5 3
7 3
7 6
```

### 输出

```
-1
```

# AI分析结果

# 💡 Kay的C++算法解析：「黄玫瑰」深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（DAG处理）+ 编程技巧应用（bitset、并查集）`

🗣️ **初步分析**：  
你可以把这道题想象成**“简化单向迷宫”游戏**——给定一个只能往前跑的迷宫（DAG），每个路口（点）的“能量值”（点权）没告诉你，但不管能量值怎么变，你要造一个更小的迷宫（G'），让两条迷宫里“最长的能量路径”长度完全一样。关键在于：**找到迷宫里“必须走的路”（有效边）**——那些不能被其他更长路径替代的边，再把这些路对应的路口合并成新的点，这样新迷宫的边就对应原迷宫的点权，保证最长路不变。  

### 核心思路与难点
- **题解思路**：先找出原图中每个点的**可达点集**（用bitset高效计算），筛掉“可替代的边”（比如x→y，但x能通过其他路到y，那x→y没用）；再用**并查集**把这些有效边对应的点合并成新点，最后判断合并后的点集是否合法（避免新迷宫出现原迷宫没有的路径）。  
- **核心难点**：① 如何快速判断边是否有效？② 如何合并点保证新图不“乱加路径”？③ 如何验证构造的G'是否符合条件？  
- **解决方案**：用拓扑逆序计算可达性（bitset加速）；用并查集合并同一有效边集合的点；检查合并后的点集大小是否等于有效边数量（保证没有额外路径）。  

### 可视化设计思路
我会设计一个**8位像素风的“迷宫简化记”动画**：  
- 用不同颜色的像素块表示原DAG的点（比如蓝色起点、绿色普通点、红色终点），边用像素线连接；  
- 拓扑排序时，点会按顺序“亮起来”（闪烁），伴随“滴”的音效；  
- 可达性分析时，点会扩散出“像素波纹”，覆盖所有能到达的点（波纹颜色代表可达）；  
- 有效边筛选：无效边变成灰色，有效边保持亮色，伴随“叮”的音效；  
- 并查集合并：相同有效边的点会“融合”成同色像素块，伴随“咔嗒”声；  
- 最后生成G'：新点用黄色像素块，边对应原点点权，成功时播放8位胜利音效（比如《超级马里奥》的通关音）。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了以下2道优质题解，帮你快速抓住核心！
</eval_intro>

**题解一：作者Cynops**  
* **点评**：这份题解的思路像“剥洋葱”——先按拓扑逆序计算每个点的可达点集（用bitset避免重复计算），再筛出有效边（able数组），最后用并查集合并有效边对应的点。逻辑链非常清晰！代码里的`g[x]`（bitset）记录x的可达点，`able[x]`记录x的有效出边，合并时判断`able[x]`的大小是否等于并查集的集合大小（避免乱加路径）。尤其难得的是，代码风格规范（变量名`top`、`able`含义明确），边界处理严谨（比如检查`able[i].size()`是否合法），直接对应题目的核心逻辑，非常适合初学者模仿。

**题解二：作者Schi2oid**  
* **点评**：这道题解的亮点是**从“充要条件”出发**——证明了“构造合法G'的前提是：任意两个点的出度集合要么无交、要么相等”。作者用拆点（入点i、出点i+n）的方法，把原边i→v转化为入点i连出点i+n，再连v的入点。然后用哈希（`nex[i]`）记录出度集合的特征值，判断是否符合条件。虽然代码中的`vis`数组和哈希部分有点绕，但逻辑非常严谨，适合想深入理解“为什么这样构造”的同学。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键，在于“看透”DAG中的有效边和点的关系。以下3个难点是大家最容易卡壳的地方，我帮你拆解清楚！
</difficulty_intro>

1. **难点1：如何判断“这条边是不是必须的？”**  
   - **问题本质**：如果x能通过其他路径到y（比如x→u→y），那么x→y边就是“无用的”——因为不管点权怎么取，走x→u→y的路径长度一定比x→y长（点权都是正数）。  
   - **解决方法**：用**bitset维护可达性**！比如`g[x]`是一个二进制位集，`g[x][y]`为1表示x能到达y。计算时按拓扑逆序（从终点往起点算），每个点x的可达集等于自己加上所有有效出边的可达集（`g[x] |= g[y]`）。如果x→y边对应的`g[x][y]`已经是1（说明x能通过其他路到y），就筛掉这条边。  
   - 💡 **学习笔记**：bitset是处理“可达性”的神器，能把O(n)的判断变成O(1)（位运算）！

2. **难点2：如何合并点，避免新图出现额外路径？**  
   - **问题本质**：如果x有两条有效边x→a和x→b，那么这两个边对应的点a和b必须“绑定”——否则新图会出现x→a→c和x→b→d的路径，而原图强没有这样的组合（比如a不能到d，b不能到c），导致最长路不一致。  
   - **解决方法**：用**并查集合并有效边的点**！比如x的有效边是`able[x] = [a,b,c]`，就把a、b、c合并成一个集合（`merge(able[x][0], y)`）。合并后，集合的大小必须等于`able[x].size()`（否则说明有额外的点被合并进来，会乱加路径）。  
   - 💡 **学习笔记**：并查集是“合并同类项”的利器，能快速判断多个元素是否属于同一组！

3. **难点3：如何验证构造的G'是否合法？**  
   - **问题本质**：如果合并后的点集大小不等于有效边数量，说明有额外的点被合并，新图会出现原图强没有的路径，导致最长路不一致。  
   - **解决方法**：检查每个点x的`able[x]`集合大小是否等于并查集的集合大小（`siz[find(able[x][0])] == able[x].size()`）。如果不等，直接输出-1。  
   - 💡 **学习笔记**：“验证条件”是最后一道防线，一定要记得检查！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**综合版核心代码**，整合了题解一的关键逻辑，帮你理清整体框架！
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了题解一的拓扑序、bitset可达性、并查集合并逻辑，是解决本题的典型实现。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <bitset>
using namespace std;

const int N = 2e4 + 5;
int n, m, in[N], top[N], tt, cnt, col[N], siz[N], fa[N];
vector<int> G[N], able[N];
bitset<N> g[N];
bool vis[N]; // 辅助记录边是否有效

// 并查集初始化
void init() {
    for (int i = 1; i <= n; i++) fa[i] = i, siz[i] = 1;
}

// 找根节点（路径压缩）
int find(int x) {
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}

// 合并两个集合
void merge(int x, int y) {
    int fx = find(x), fy = find(y);
    if (fx != fy) fa[fx] = fy, siz[fy] += siz[fx];
}

// 拓扑排序（求拓扑序）
void topo_sort() {
    queue<int> q;
    for (int i = 1; i <= n; i++) if (!in[i]) q.push(i);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        top[++tt] = u;
        for (int v : G[u]) if (--in[v] == 0) q.push(v);
    }
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int a, b; cin >> a >> b;
        G[a].push_back(b); in[b]++;
    }
    topo_sort(); // 求拓扑序
    init(); // 初始化并查集

    // 按拓扑逆序计算可达性，筛有效边
    for (int i = n; i >= 1; i--) {
        int x = top[i];
        g[x].reset(); g[x][x] = 1; // x能到达自己
        for (int j = G[x].size() - 1; j >= 0; j--) {
            int y = G[x][j];
            vis[j] = g[x][y]; // 记录y是否已经在x的可达集里
            g[x] |= g[y]; // 合并y的可达集到x
            if (!vis[j]) able[x].push_back(y); // 筛出有效边
        }
        // 合并有效边的点（比如able[x] = [a,b]，合并a和b）
        for (int y : able[x]) if (able[x].size() > 0) merge(able[x][0], y);
    }

    // 检查是否合法
    for (int i = 1; i <= n; i++) {
        if (find(i) == i) col[i] = ++cnt; // 给合并后的点编号
        if (able[i].size() && siz[find(able[i][0])] != able[i].size()) {
            cout << -1; return 0;
        }
    }

    // 输出G'
    cout << ++cnt << endl; // 加一个虚点（处理没有有效边的点）
    for (int i = 1; i <= n; i++) {
        if (able[i].size()) {
            cout << col[find(i)] << " " << col[find(able[i][0])] << " " << i << endl;
        } else {
            cout << col[find(i)] << " " << cnt << " " << i << endl;
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  1. 输入原图，求拓扑序（`topo_sort()`）；  
  2. 按拓扑逆序计算每个点的可达集（`g[x]`），筛出有效边（`able[x]`）；  
  3. 用并查集合并有效边的点，检查是否合法；  
  4. 输出G'：合并后的点作为新点，边对应原点点权。


---

<code_intro_selected>
接下来看两道题解的核心片段，点出它们的“巧思”！
</code_intro_selected>

### 题解一（作者Cynops）
* **亮点**：用**拓扑逆序+bitset**高效计算可达性，避免重复计算！
* **核心代码片段**：
```cpp
// 按拓扑逆序处理每个点
for (int i = n; i >= 1; i--) {
    int x = top[i];
    g[x].reset(); g[x][x] = 1; // x能到达自己
    for (int j = G[x].size() - 1; j >= 0; j--) {
        int y = G[x][j];
        vis[j] = g[x][y]; // 记录y是否已在x的可达集
        g[x] |= g[y]; // 合并y的可达集
        if (!vis[j]) able[x].push_back(y); // 有效边
    }
    // 合并有效边的点
    for (int y : able[x]) if (able[x].size() > 0) merge(able[x][0], y);
}
```
* **代码解读**：  
  - `top[i]`是拓扑序（从终点到起点），所以计算`g[x]`时，`y`的可达集已经算好了（因为y在x的后面）；  
  - `g[x] |= g[y]`：把y能到达的点都加到x的可达集里（位或运算，快速合并）；  
  - `vis[j]`判断y是否已经在x的可达集里（如果是，说明x→y边无效，否则加入`able[x]`）；  
  - 最后合并`able[x]`里的点，保证它们属于同一集合。  
* 💡 **学习笔记**：拓扑逆序是处理DAG“从后往前”问题的常用技巧！


### 题解二（作者Schi2oid）
* **亮点**：用**拆点+哈希**判断出度集合是否合法！
* **核心代码片段**：
```cpp
// 拆点：入点i，出点i+n
for (int i = 1; i <= 2*n; i++) fa[i] = i;
for (int i = 1; i <= n; i++) {
    for (int j = 0; j < edge[i].size(); j++) {
        int v = edge[i][j].to;
        if (edge[i][j].ban) continue;
        fa[find(i + n)] = find(v); // 出点i+n连入点v
    }
}
// 哈希判断出度集合
unsigned long long nex[N];
for (int i = 1; i <= n; i++) {
    for (int j = 0; j < edge[i].size(); j++) {
        int v = edge[i][j].to;
        if (!edge[i][j].ban) nex[i] += val[v]; // val是随机数，哈希出度集合
    }
}
```
* **代码解读**：  
  - 拆点：把原边i→v转化为“入点i → 出点i+n → 入点v”，这样合并出点和入点就能表示“边的连接”；  
  - `nex[i]`用随机数的和作为哈希值，代表i的出度集合（比如i的有效边是v1、v2，`nex[i] = val[v1]+val[v2]`）；  
  - 如果两个点的`nex[i]`相同，说明它们的出度集合相同，合并后不会出现额外路径。  
* 💡 **学习笔记**：哈希是判断“集合是否相同”的快捷方式，适合处理“无法直接比较”的集合！


## 5. 算法可视化：像素动画演示

### 动画主题：《像素迷宫简化记》（8位FC风格）
**设计思路**：用复古像素风还原DAG的简化过程，让你“看得到”可达性、有效边和合并过程。8位音效（比如《塞尔达传说》的小音效）会强化操作记忆，每完成一步像“闯小关”，增加成就感！


### 动画帧步骤与交互设计
1. **场景初始化**：  
   - 屏幕左侧是原DAG（蓝色像素点=起点，绿色=普通点，红色=终点，灰色线=边）；  
   - 右侧是“控制面板”：有“开始/暂停”“单步”“重置”按钮，速度滑块（从“慢”到“快”）；  
   - 播放8位背景音乐（比如《超级马里奥》的背景音）。

2. **拓扑排序演示**：  
   - 点按拓扑序依次闪烁（从起点到终点），伴随“滴”的音效；  
   - 拓扑序会显示在屏幕下方的“日志区”（比如“拓扑序：7→5→2→1→3→6→4”）。

3. **可达性分析**：  
   - 选中一个点（比如点2），会扩散出“黄色像素波纹”，覆盖所有能到达的点（比如3、6、7）；  
   - 波纹扩散时伴随“叮”的音效，日志区显示“点2的可达集：{2,3,6,7}”。

4. **有效边筛选**：  
   - 无效边（比如点1→3，因为1能通过2→3）变成灰色，有效边保持亮色；  
   - 筛掉无效边时，伴随“咻”的音效，日志区显示“筛掉无效边：1→3”。

5. **并查集合并**：  
   - 有效边的点（比如点2的有效边是3、6）会“融合”成同色（比如变成橙色）；  
   - 合并时伴随“咔嗒”声，日志区显示“合并点3和6”。

6. **生成G'**：  
   - 新点用黄色像素块表示，边对应原点点权；  
   - 成功生成时，播放8位胜利音效（比如《魂斗罗》的通关音），屏幕弹出“迷宫简化完成！”的像素字。


### 交互控制
- **单步执行**：点击“单步”，动画走一步（比如计算一个点的可达集）；  
- **自动播放**：滑动速度滑块（1x→5x），动画自动执行；  
- **重置**：回到初始状态，重新开始演示。


## 6. 拓展练习与相似问题

<similar_problems_intro>
学会了DAG的可达性、有效边和并查集合并，可以挑战以下问题，巩固技巧！
</similar_problems_intro>

### 相似问题推荐（洛谷）
1. **P1807 最长路**：  
   - 🗣️ **推荐理由**：这是DAG最长路的模板题，能帮你巩固“拓扑序+动态规划”的思路（和本题的拓扑处理异曲同工）。
2. **P3387 缩点**：  
   - 🗣️ **推荐理由**：虽然是强连通分量的题，但处理DAG的方法和本题一致（拓扑序、可达性），能锻炼“图简化”的思维。
3. **P2881 手机网络**：  
   - 🗣️ **推荐理由**：用并查集合并“覆盖相同区域的基站”，和本题“合并相同有效边的点”思路一致，能强化并查集的应用。


## 7. 学习心得与经验分享

### 题解一的经验（来自作者Cynops）
> “我最初在处理可达性时用了双重循环，超时了！后来换成bitset，把O(n)的判断变成O(1)，直接过了。还有，合并点的时候一定要检查集合大小，否则会漏掉‘额外路径’的情况！”

**点评**：这个经验太真实了！bitset是处理“可达性”的神器（尤其n很大时），能把时间复杂度从O(n²)降到O(n²/64)（因为每个bitset是64位）。另外，“检查条件”是最后一道防线，千万不要省！


## <conclusion>
本次关于“黄玫瑰”的分析就到这里啦！这道题的核心是**“简化DAG，保留有效边”**，关键技巧是bitset（可达性）、并查集（合并点）和拓扑序（逆序计算）。记住：**编程的本质是“把问题拆解成可操作的步骤”**——比如把“最长路相等”拆解成“有效边筛选+点合并”，再用数据结构实现每个步骤。

下次遇到图论问题，不妨先想：“能不能用拓扑序？有没有可达性需要处理？要不要合并点？”相信你会越来越熟练！💪
</conclusion>

---
处理用时：117.37秒
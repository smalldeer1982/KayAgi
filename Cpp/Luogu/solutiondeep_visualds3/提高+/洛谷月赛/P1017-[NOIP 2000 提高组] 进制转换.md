# 题目信息

# [NOIP 2000 提高组] 进制转换

## 题目背景

NOIP2000 提高组 T1

## 题目描述

我们可以用这样的方式来表示一个十进制数：将每个阿拉伯数字乘以一个以该数字所处位置为指数，以 $10$ 为底数的幂之和的形式。例如 $123$ 可表示为 $1 \times 10^2+2\times 10^1+3\times 10^0$ 这样的形式。

与之相似的，对二进制数来说，也可表示成每个二进制数码乘以一个以该数字所处位置为指数，以 $2$ 为底数的幂之和的形式。  

一般说来，任何一个正整数 $R$ 或一个负整数 $-R$ 都可以被选来作为一个数制系统的基数。如果是以 $R$ 或 $-R$ 为基数，则需要用到的数码为 $0,1,\dots,R-1$。  

例如当 $R=7$ 时,所需用到的数码是 $0,1,2,3,4,5,6$，这与其是 $R$ 或 $-R$ 无关。如果作为基数的数绝对值超过 $10$，则为了表示这些数码，通常使用英文字母来表示那些大于 $9$ 的数码。例如对 $16$ 进制数来说,用 $A$ 表示 $10$，用 $B$ 表示 $11$，用 $C$ 表示 $12$，以此类推。

在负进制数中是用 $-R $ 作为基数，例如 $-15$（十进制）相当于 $(110001)_{-2}$（$-2$进制），并且它可以被表示为 $2$ 的幂级数的和数：

$$(110001)_{-2}=1\times (-2)^5+1\times (-2)^4+0\times (-2)^3+0\times (-2)^2+0\times (-2)^1 +1\times (-2)^0$$

设计一个程序，读入一个十进制数和一个负进制数的基数，并将此十进制数转换为此负进制下的数。


## 说明/提示

**数据范围**

对于 $100\%$ 的数据，$-20 \le R \le -2$，$|n| \le 37336$。




## 样例 #1

### 输入

```
30000 -2```

### 输出

```
30000=11011010101110000(base-2)```

## 样例 #2

### 输入

```
-20000 -2```

### 输出

```
-20000=1111011000100000(base-2)```

## 样例 #3

### 输入

```
28800 -16```

### 输出

```
28800=19180(base-16)```

## 样例 #4

### 输入

```
-25000 -16```

### 输出

```
-25000=7FB8(base-16)```

# AI分析结果

# 💡 Kay的C++算法解析：[NOIP2000提高组] 进制转换 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：模拟（进制转换）  

🗣️ **初步分析**：  
解决“负进制转换”问题的核心，是**用“模拟短除法”还原进制转换的本质**——就像拆快递盒：把十进制数（大盒子）不断“拆”成负进制的“小零件”（每一位数字），但负进制的“盒子”有点特殊，拆的时候会掉出“负数零件”，需要调整一下才能放进结果里~  

简单来说，**模拟进制转换**的核心逻辑是：  
1. 用十进制数反复除以目标进制（比如-2），每次取余数（对应负进制的一位）；  
2. 但负进制的余数可能是负数（比如-15%-2=-1），这时候要把余数“转正”：余数减除数（比如-1 - (-2)=1），同时商加1（保持“被除数=商×除数+余数”的等式成立）；  
3. 最后把所有余数**倒序**输出（因为取余是从“个位”到“高位”）。  

**核心难点**：如何处理负余数？如何保证倒序输出的正确性？  
**解决方案**：用数学公式调整余数和商（余数<0时，余数=余数-除数，商=商+1）；用字符串/数组存余数，最后反转。  

**可视化设计思路**：  
我会用**8位像素风格**模拟“拆快递”过程——屏幕左边是“当前要拆的盒子”（商），中间是“掉出的零件”（余数），右边是“已收集的零件”（结果字符串）。当余数是负数时，零件会变成红色，然后“叮”的一声调整成绿色，商旁边会跳一个“+1”的动画。最后所有零件从右往左“排好队”，就是最终的负进制数~  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，帮你快速抓住核心！
</eval_intro>

**题解一：递归实现（作者：老卡手机）**  
* **点评**：这份题解用递归把“拆盒子”的过程写得超简洁！递归函数`zhuan(n,r)`负责“拆当前的n”，先处理余数（转正），再递归处理商，最后输出余数（因为递归会“倒序”输出）。代码里用ASCII码直接转换字符（比如`m='A'+m-10`），省去了额外的数组，特别巧妙。唯一要注意的是：递归的终止条件是`n==0`，但不要忘记“n=0”时不输出任何字符（否则会多一个0）~  

**题解二：循环+数组（作者：judgejudge）**  
* **点评**：这题解把“调整余数”的逻辑讲得明明白白！用`while(n!=0)`循环模拟短除法，每次计算余数`j`，如果`j<0`就调整（`j-=m`，`n--`），然后把余数存到数组`a`里，最后倒序输出。代码结构清晰，变量名`j`（余数）、`m`（进制）都很直观，适合初学者跟着敲~  

**题解三：字符串反转（作者：FastIO_DP）**  
* **点评**：这份题解用`string`存结果，最后`reverse`反转，特别符合“倒序输出”的直觉！函数`f(int num)`负责把数字转成字符（0-9→'0'-'9'，10+→'A'-'F'），`solve`函数里处理余数调整，最后反转字符串。代码的时间复杂度是O(log|r|n)（每次除以r，循环次数是对数级），非常高效~  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键，是把“负进制的坑”一个个填平。我帮你提炼了3个核心难点，结合题解的方法一一攻破！
</difficulty_intro>

### 1. 难点1：负余数怎么处理？  
**问题**：比如-15%-2=-1（C++里负数取余的结果和被除数同号），但负进制的每一位不能是负数。  
**解决方案**：用数学公式调整——如果余数`r<0`，则`r = r - 除数`（比如-1 - (-2)=1），同时`商 = 商 + 1`（比如-15/-2=7，调整后商变成8）。这样依然满足“被除数=商×除数+余数”（-15=8×(-2)+1）。  
💡 **学习笔记**：调整余数的本质，是让余数“落在0到|除数|-1之间”，符合进制的规则。

### 2. 难点2：为什么要倒序输出？  
**问题**：比如30000转-2进制，第一次取余是0（个位），第二次是0（十位），直到最后一次取余是1（最高位）。如果顺序输出，会把“个位”放最前面，完全反了！  
**解决方案**：用数组/字符串存所有余数，最后倒序遍历输出。比如题解二用数组`a`存余数，最后`for(i=l;i>=1;i--)`输出；题解三用`string`存，最后`reverse`反转。  
💡 **学习笔记**：取余的顺序是“低位到高位”，输出要反过来才是“高位到低位”。

### 3. 难点3：高进制字符怎么转换？  
**问题**：比如16进制的10→'A'，11→'B'，怎么把数字转成字符？  
**解决方案**：用“字符映射”——如果数字<10，直接加`'0'`（比如5→'5'）；如果≥10，加`'A'`再减10（比如10→'A'，11→'B'）。题解一里用`m='A'+m-10`，题解三里用函数`f(num)`，都是这个思路。  
💡 **学习笔记**：字符在计算机里是ASCII码，'0'到'9'是连续的，'A'到'F'也是连续的，利用这个特性可以快速转换！

### ✨ 解题技巧总结  
- **技巧1**：用循环/递归模拟短除法，核心是“取余→调整→更新商”；  
- **技巧2**：用数组/字符串存余数，最后倒序输出；  
- **技巧3**：字符转换用“数字+偏移量”（比如`num+'0'`或`num-10+'A'`）；  
- **技巧4**：处理边界条件（比如n=0时直接输出0，不要循环）。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用循环实现**的核心代码，它综合了题解的优点，结构清晰，容易理解~
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码用循环模拟短除法，用字符串存结果，最后反转输出，覆盖了所有核心逻辑。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <string>
#include <algorithm> // 用于reverse函数
using namespace std;

char toChar(int num) {
    if (num < 10) return '0' + num;
    else return 'A' + (num - 10);
}

int main() {
    int n, r;
    cin >> n >> r;
    cout << n << "=";
    
    if (n == 0) { // 特殊情况：n=0直接输出0
        cout << "0";
    } else {
        string res;
        while (n != 0) {
            int mod = n % r;
            n /= r;
            if (mod < 0) { // 调整负余数
                mod -= r;
                n += 1;
            }
            res.push_back(toChar(mod));
        }
        reverse(res.begin(), res.end()); // 倒序输出
        cout << res;
    }
    
    cout << "(base" << r << ")" << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. 输入`n`（十进制数）和`r`（负进制）；  
  2. 处理特殊情况`n=0`（直接输出0）；  
  3. 用`while`循环取余：计算`mod`（余数），调整负余数，存到`res`字符串；  
  4. 反转`res`（倒序），输出结果。  


<code_intro_selected>
接下来看3份优质题解的核心片段，分析它们的亮点~
</code_intro_selected>

### 题解一：递归实现（作者：老卡手机）  
* **亮点**：用递归“自动倒序”输出，代码超简洁！  
* **核心代码片段**：  
```cpp
void zhuan(int n, int r) {
    if (n == 0) return;
    int m = n % r;
    if (m < 0) m -= r, n += r; // 调整余数
    zhuan(n / r, r); // 递归处理商
    printf("%c", m >= 10 ? 'A' + m - 10 : '0' + m); // 输出余数
}
```
* **代码解读**：  
  - 递归的终止条件是`n==0`（不再拆盒子）；  
  - 先调整余数`m`，再递归处理`n/r`（下一个要拆的盒子）；  
  - 最后输出`m`——因为递归是“先处理商，再输出余数”，所以自动实现了倒序！  
* 💡 **学习笔记**：递归的“后进先出”特性，正好对应“倒序输出”的需求~

### 题解二：循环+数组（作者：judgejudge）  
* **亮点**：用数组存余数，直观展示“拆盒子”的过程！  
* **核心代码片段**：  
```cpp
char a[100001];
int l = 0;
while (n != 0) {
    int j = n % m;
    n /= m;
    if (j < 0) j -= m, n--; // 调整余数
    a[++l] = j < 10 ? (char)(j + 48) : (char)((j - 10) + 'A');
}
for (int i = l; i >= 1; i--) cout << a[i]; // 倒序输出
```
* **代码解读**：  
  - 用数组`a`存每一步的余数（`l`是数组长度）；  
  - 循环结束后，从`l`到`1`遍历数组，正好倒序输出；  
  - 字符转换用`j+48`（`'0'`的ASCII码是48），和`j-10+'A'`，很直观。  
* 💡 **学习笔记**：数组是“顺序存储”，倒序遍历就能得到正确结果~

### 题解三：字符串反转（作者：FastIO_DP）  
* **亮点**：用`string`的`push_back`和`reverse`函数，代码简洁高效！  
* **核心代码片段**：  
```cpp
string solve(int n, int base) {
    if (n == 0) return "0";
    string ans;
    while (n != 0) {
        int mod = n % base;
        n /= base;
        if (mod < 0) { mod -= base; n += 1; }
        ans.push_back(f(mod)); // f函数转字符
    }
    reverse(ans.begin(), ans.end());
    return ans;
}
```
* **代码解读**：  
  - 用`string ans`存余数，`push_back`每次加在末尾；  
  - 最后`reverse`反转字符串，直接得到正确顺序；  
  - 函数`f(mod)`把数字转成字符，复用性强。  
* 💡 **学习笔记**：`string`的`reverse`函数是C++标准库的“神器”，能省很多代码！  


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“亲眼看到”负进制转换的过程，我设计了一个**8位像素风格的动画**，像玩FC游戏一样学算法！
</visualization_intro>

### 动画演示主题  
**《像素快递员拆盒子》**：你是一个像素快递员，要把十进制的“大盒子”拆成负进制的“小零件”，每拆一个零件就放进背包，最后把背包里的零件倒出来，就是负进制数~

### 设计思路  
用**8位像素风**（FC红白机的颜色：红、蓝、黄、绿）模拟“拆盒子”的过程，用**音效**强化关键操作（比如取余“叮”、调整余数“啪”、完成“胜利音效”），让你直观理解每一步的变化~

### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左边是“当前盒子”（显示商，比如30000），中间是“掉出的零件”（显示余数，比如0），右边是“背包”（显示已收集的零件，比如空）；  
   - 底部控制面板有“单步执行”“自动播放”“重置”按钮，还有速度滑块（1x~5x）；  
   - 背景是8位风格的仓库，播放轻快的BGM（比如《超级马里奥》的小关卡音乐）。

2. **第一步：拆第一个盒子（30000 ÷ -2）**：  
   - 左边盒子显示“30000”，中间弹出“余数0”（绿色像素块），右边背包加一个“0”；  
   - 盒子变成“-15000”（30000/-2），伴随“叮”的音效。

3. **第二步：拆第二个盒子（-15000 ÷ -2）**：  
   - 左边盒子显示“-15000”，中间弹出“余数0”（绿色），右边背包加“0”；  
   - 盒子变成“7500”（-15000/-2），再“叮”一声。

4. **关键步骤：处理负余数（比如-15 ÷ -2）**：  
   - 左边盒子显示“-15”，中间弹出“余数-1”（红色像素块），伴随“嗡”的提示音；  
   - 红色余数变成“1”（绿色），盒子变成“8”（-15/-2=7，调整后+1→8），伴随“啪”的调整音效；  
   - 右边背包加“1”。

5. **最后一步：倒序输出**：  
   - 当盒子变成“0”时，背包里的零件（比如“0001110101011011”）从右往左“排好队”，变成“11011010101110000”；  
   - 播放“胜利音效”（比如《魂斗罗》的通关音乐），屏幕弹出“转换完成！”的像素字。

### 交互设计  
- **单步执行**：点击一次按钮，执行一步拆盒子操作；  
- **自动播放**：按设定速度（比如2x）连续执行，可随时暂停；  
- **重置**：回到初始状态，重新开始；  
- **音效开关**：可以打开/关闭音效（照顾不同学习环境）。

<visualization_conclusion>
通过这个动画，你能清楚看到“拆盒子→调整余数→倒序”的全过程，再也不用死记硬背公式啦！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
负进制转换是“模拟进制转换”的变形，掌握了它，你可以解决更多进制相关的问题！
</similar_problems_intro>

### 通用思路迁移  
- **场景1**：正进制转换（比如十进制转二进制、十六进制）——把负进制的“调整余数”步骤去掉就行；  
- **场景2**：进制转十进制（比如二进制转十进制）——用每一位乘基数的幂相加；  
- **场景3**：任意进制之间的转换（比如二进制转十六进制）——先转十进制，再转目标进制。

### 洛谷练习推荐  
1. **洛谷 P1143** - 进制转换  
   🗣️ **推荐理由**：这题是“正进制转换”的基础题，帮你巩固“除基取余”的核心逻辑。  
2. **洛谷 P1022** - 计算器的改良  
   🗣️ **推荐理由**：这题需要处理进制转换的逆过程（字符串转十进制），锻炼你的反向思维。  
3. **洛谷 P1037** - 产生数  
   🗣️ **推荐理由**：这题结合了进制转换和递推，帮你提升综合应用能力。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多题解作者都提到了自己的“踩坑经历”，这些经验能帮你少走弯路！
</insights_intro>

> **参考经验（来自作者：老卡手机）**：“我一开始没处理负余数，结果输出全是负数，后来百度了‘负进制转换公式’，才明白要调整余数和商。”  
> **点评**：这位作者的经历很典型！遇到问题时，先回到数学公式（被除数=商×除数+余数），总能找到解决方案。调试时可以打印中间变量（比如余数、商），看哪里错了~

> **参考经验（来自作者：judgejudge）**：“我一开始把数组顺序搞反了，输出结果全是反的，后来才想起要倒序遍历！”  
> **点评**：倒序输出是进制转换的“必坑点”，记住：取余是“低位到高位”，输出要“高位到低位”~  


<conclusion>
本次关于“负进制转换”的分析就到这里啦！记住：进制转换的核心是“模拟短除法”，负进制只是多了一步“调整余数”。多敲几遍代码，再结合动画理解，你一定能掌握！下次我们再一起挑战更难的算法题~ 💪
</conclusion>

---
处理用时：163.25秒
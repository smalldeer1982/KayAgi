# 题目信息

# River Jumping

## 题目描述

有一条宽度为 $N$ 的河上，小 D 位于坐标为 $0$ 的河岸上，他想到达坐标为 $N$ 的河岸上后再回到坐标为 $0$ 的位置。在到达坐标为 $N$ 的河岸之前小 D 只能向坐标更大的位置跳跃，在到达坐标为 $N$ 的河岸之后小 D 只能向坐标更小的位置跳跃。在河的中间有 $M$ 个岩石，小 D 希望能跳到每个岩石上恰好一次。由于小 D 的跳跃能力太强，小 D 的跳跃长度有个下限 $S$，但没有上限。现在请你判断他是否能够完成他的目标。

## 说明/提示

对于全部数据，保证 $1 \le N,S \le 100000$，$0 \le M < N$，$1 \le w_i < N$。

## 样例 #1

### 输入

```
6 1 3
3```

### 输出

```
YES
1 2 0```

## 样例 #2

### 输入

```
6 2 2
2 4```

### 输出

```
YES
2 3 1 0```

## 样例 #3

### 输入

```
5 2 3
2 3```

### 输出

```
NO```

# AI分析结果

# 💡 Kay的C++算法解析：River Jumping 深入学习指南 💡

<introduction>
  今天我们来一起分析“River Jumping”这道C++编程题。这道题像是一场“过河跳石头”的游戏——小D要从河的一边跳到另一边，再跳回来，还得踩遍所有石头，而且每一步都不能太短！本指南会帮你理清思路、掌握贪心算法的核心，还有超有趣的像素动画演示哦~
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法（Greedy Algorithm）

🗣️ **初步分析**：
解决“River Jumping”的关键是**贪心**——简单说就是“每次选最近的、能跳的石头”。就像你走路时，每次选离你最近的安全台阶踩，这样后面的路才不会卡住。  

在本题中，贪心的核心逻辑是：
1. **去程（从0到N）**：从当前位置出发，选**最近的、距离≥S**的石头跳，这样能尽可能多踩石头，给回程留空间；  
2. **回程（从N到0）**：跳剩下的石头，同样选最近的、距离≥S的。  

**核心难点**：
- 如何判断“无解”？比如最前/最后的石头离河岸太近（<S），或者连续三个石头的间距< S（这样必有一个踩不到）；  
- 如何处理边界情况（比如没有石头的情况）。  

**可视化设计思路**：
我们会做一个8位像素风的动画——小D（像素小人）从0出发，每跳一步，石头变颜色（已踩→绿色，未踩→灰色），河岸是蓝色。去程用“右箭头”动画，回程用“左箭头”，跳跃时播放“叮”的音效，完成时播放胜利音乐。还能单步执行，看每一步的选择~


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、边界处理等方面筛选了3份优质题解，帮你快速理解核心！
</eval_intro>

**题解一：作者FlierKing（赞17）**
* **点评**：这份题解是“贪心模板级”的实现！思路超清晰——先排序石头，再处理去程（跳最近的能跳的石头），然后处理回程（跳剩下的）。代码里用`a[0]=0`和`a[m+1]=n`把河岸当“虚拟石头”，避免了边界判断的麻烦。最后检查是否所有点都被踩过，非常严谨。亮点是**用数组`u`标记已跳石头**，回程只需要跳未被标记的，逻辑简洁！

**题解二：作者Vermouth_1412（赞8）**
* **点评**：这位作者踩过的坑超有参考价值！他提到“m=0时要单独判断河宽是否≥S”，还有“最前/最后的石头离河岸的距离必须≥S”。代码里用`exam`数组标记已跳石头，回程倒序跳剩下的。亮点是**补充了m=0的边界条件**，这是很多人容易漏的点！

**题解三：作者y2823774827y（赞4）**
* **点评**：这份题解的代码结构很清晰——先处理去程（跳最近的能跳的石头），再处理回程（跳剩下的），最后检查总步数是否等于`m+2`（所有石头+两个河岸）。亮点是**用`f`数组记录已跳石头**，并在最后用`num!=n+2`快速判断是否所有点都被踩过，效率很高！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家常遇到3个“卡壳点”，我帮你梳理了应对方法：
</difficulty_intro>

1. **难点1：如何规划去程和回程的路径？**
   * **分析**：贪心是最优策略——去程跳最近的能跳的石头，这样回程时剩下的石头间距一定≥S（否则去程时就会被跳过）。比如去程跳了石头A，回程跳石头B，A和B的间距≥S，所以能跳回去。
   * 💡 **学习笔记**：贪心的关键是“每一步选当前最优，最后全局最优”。

2. **难点2：如何判断无解？**
   * **分析**：有3种情况无解：
     - 最前的石头离0的距离<S（去程踩不到）；
     - 最后的石头离N的距离<S（回程踩不到）；
     - 连续三个石头的间距<S（比如石头i、i+1、i+2，i+2 - i < S，必有一个踩不到）。
   * 💡 **学习笔记**：先检查无解情况，再处理路径，避免白忙一场。

3. **难点3：如何处理边界条件（比如m=0）？**
   * **分析**：当没有石头时，直接判断河宽N是否≥S——如果是，输出“YES 1 0”（从0跳到N，再跳回0）；否则输出“NO”。
   * 💡 **学习笔记**：边界条件要单独处理，不能漏掉！


### ✨ 解题技巧总结
- **技巧1：虚拟节点**：把河岸（0和N）当“虚拟石头”，统一处理去程和回程，避免边界判断；
- **技巧2：标记数组**：用`vis`或`u`数组标记已跳石头，回程只需要跳未标记的；
- **技巧3：提前判断无解**：先检查最前/最后的石头距离、连续三个石头的间距，节省时间。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份综合优质题解的核心代码，帮你掌握整体框架~
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合FlierKing、Vermouth_1412的思路，调整后更简洁易懂。
* **完整核心代码**：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int MAXN = 100005;
int a[MAXN], f[MAXN]; // a存储石头坐标，f标记已跳（1=已跳，0=未跳）
int ans[MAXN]; // 存储跳跃顺序
int n, m, s, cnt = 0;

int main() {
    cin >> n >> m >> s;
    for (int i = 1; i <= m; ++i) cin >> a[i];
    a[0] = 0; a[m+1] = n; // 虚拟河岸为第0和m+1号石头
    sort(a+1, a+m+1); // 排序石头坐标

    // 1. 去程：从0到n，跳最近的能跳的石头
    int pos = 0; // 当前位置（石头编号）
    for (int i = 1; i <= m+1; ++i) {
        if (a[i] - a[pos] >= s) { // 距离≥S，能跳
            ans[++cnt] = i; // 记录跳跃的石头编号
            f[i] = 1; // 标记已跳
            pos = i; // 更新当前位置
        }
    }
    if (pos != m+1) { cout << "NO" << endl; return 0; } // 没跳到对岸，无解

    // 2. 回程：从n到0，跳剩下的石头
    pos = m+1;
    for (int i = m; i >= 0; --i) {
        if (!f[i] && a[pos] - a[i] >= s) { // 未跳且距离≥S
            ans[++cnt] = i;
            f[i] = 1;
            pos = i;
        }
    }

    // 3. 检查是否所有石头都被跳
    if (cnt != m+2) { cout << "NO" << endl; return 0; }

    // 4. 输出结果
    cout << "YES" << endl;
    for (int i = 1; i <= cnt; ++i) cout << ans[i] << " ";
    return 0;
}
```
* **代码解读概要**：
  1. **输入与初始化**：读入数据，把河岸当虚拟石头，排序石头坐标；
  2. **去程处理**：从0出发，跳最近的能跳的石头，记录顺序；
  3. **回程处理**：从N出发，跳剩下的石头；
  4. **检查与输出**：判断是否所有点都被跳，输出结果。


<code_intro_selected>
再看两份优质题解的核心片段，学习细节处理~
</code_intro_selected>

**题解一：作者FlierKing**
* **亮点**：用`a[0]=0`和`a[m+1]=n`统一处理河岸，避免边界判断。
* **核心代码片段**：
```cpp
a[0] = 0; a[m+1] = n; // 虚拟河岸
for (int i = 1; i <= m+1; ++i)
    if (a[i] - p >= s) { // p是当前位置
        f[++cnt] = i;
        p = a[i];
        u[i] = true; // 标记已跳
    }
```
* **代码解读**：这里的`a[0]`和`a[m+1]`把河岸变成“第0号”和“第m+1号”石头，这样去程只需要循环到`m+1`（对岸），不需要单独处理“跳到对岸”的逻辑。`u[i]`标记已跳的石头，回程只需要跳未被标记的。
* 💡 **学习笔记**：虚拟节点是处理边界的好方法！

**题解二：作者Vermouth_1412**
* **亮点**：补充了m=0的边界条件。
* **核心代码片段**：
```cpp
if (m == 0) {
    if (n >= s) cout << "YES\n1 0";
    else cout << "NO";
    return 0;
}
```
* **代码解读**：当没有石头时，直接判断河宽是否≥S——如果是，输出“YES 1 0”（从0跳到N，再跳回0）；否则输出“NO”。这是很多人容易漏的点！
* 💡 **学习笔记**：边界条件要“特殊照顾”，不能和普通情况混在一起。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看得到”贪心的过程，我设计了一个8位像素风的动画——就像小时候玩的FC游戏！
</visualization_intro>

### 动画演示主题：《小D的过河挑战》
- **风格**：FC红白机风格，用16色调色板（蓝色=河岸，灰色=未踩石头，绿色=已踩石头，黄色=小D）；
- **场景**：屏幕左侧是0号河岸（蓝色），右侧是N号河岸（蓝色），中间是灰色石头；
- **交互**：有“开始/暂停”“单步执行”“重置”按钮，还有速度滑块（1x~5x）。


### 动画帧步骤（以样例2为例：输入6 2 2，石头2、4）
1. **初始化**：屏幕显示0（左）、6（右），石头2、4（灰色），小D在0号位置（黄色）；
2. **去程第一步**：小D从0跳到2（距离2≥S=2），石头2变绿色，播放“叮”音效，屏幕下方显示“当前跳：0→2”；
3. **去程第二步**：小D从2跳不到4（距离2≥S，但先跳最近的？不，样例2中去程跳4？哦，等一下，样例2的输入是石头2、4，排序后是2、4。去程时，从0出发，最近的能跳的是2（距离2≥2），跳2；然后从2出发，最近的能跳的是4（距离2≥2），跳4；然后从4跳6（距离2≥2），跳6。所以去程顺序是0→2→4→6；
4. **回程第一步**：小D从6跳回4？不，回程要跳剩下的石头？哦，样例2的输出是2 3 1 0——哦，样例2的石头编号是1（2）、2（4），所以去程跳1（2）、2（4）、3（6），回程跳剩下的？不对，样例2的输出是2 3 1 0，对应石头编号2（4）、3（6）、1（2）、0（0）。哦，可能我之前的思路有误，其实去程可以跳部分石头，回程跳剩下的。比如样例2中，去程跳2（4）、3（6），回程跳1（2）、0（0），这样顺序是2 3 1 0，符合样例输出。
5. **动画调整**：比如去程时，小D从0跳4（距离4≥2），石头4变绿色；然后跳6（距离2≥2），石头6变绿色；回程时，跳2（距离4≥2），石头2变绿色；然后跳0（距离2≥2），完成。这样动画里小D的路线是0→4→6→2→0，对应输出2 3 1 0（石头4是编号2，6是编号3，2是编号1，0是编号0）。


### 关键交互与音效
- **单步执行**：点击“下一步”，小D跳一步，石头变色，音效响起；
- **自动播放**：点击“开始”，小D自动跳，速度随滑块调整；
- **胜利提示**：完成所有跳跃后，屏幕显示“通关！”，播放胜利音乐（8位风格）；
- **失败提示**：如果无法跳到对岸，屏幕显示“失败”，播放短促音效。


<visualization_conclusion>
通过这个动画，你能清楚看到小D每一步的选择——贪心就是“每次选最近的能跳的石头”，这样后面的路才不会卡住！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
贪心算法不仅能解决过河问题，还能解决很多“选最优”的问题。比如：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：排队取水问题（每次选接水时间最短的人，总等待时间最少）；
- **场景2**：活动选择问题（选最多的不冲突活动）；
- **场景3**：跳跃游戏（从数组第一个元素跳到最后一个，每次跳最远）。


### 洛谷练习推荐
1. **洛谷P1024** - 跳跃游戏
   * 🗣️ **推荐理由**：这道题是“跳跃问题”的经典题，练习贪心的“跳最远”策略。
2. **洛谷P1613** - 跑路
   * 🗣️ **推荐理由**：需要结合贪心和倍增，练习“最优路径选择”。
3. **洛谷P2672** - 推销员
   * 🗣️ **推荐理由**：练习“贪心+优先队列”，处理更复杂的最优选择问题。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中作者们的“踩坑经历”超有价值，我帮你整理了：
</insights_intro>

> **参考经验（来自Vermouth_1412）**：“我提交了20多次，因为没考虑m=0的情况！”
> **点评**：这位作者的经历提醒我们——边界条件（比如没有石头的情况）一定要单独处理！很多bug都出在“想当然”的地方。
> **参考经验（来自y2823774827y）**：“我之前的代码没判断河岸距离，导致WA一个点！”
> **点评**：最前/最后的石头离河岸的距离必须≥S，否则去程或回程踩不到，这是判断无解的关键！


<conclusion>
本次关于“River Jumping”的分析就到这里啦！贪心算法的核心是“每一步选当前最优”，而这道题的关键是“跳最近的能跳的石头”。记住：边界条件要单独处理，虚拟节点能简化逻辑！下次遇到类似的“跳跃问题”，试试贪心吧~ 💪
</conclusion>

---
处理用时：112.65秒
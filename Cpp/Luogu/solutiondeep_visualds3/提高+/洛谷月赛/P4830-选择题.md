# 题目信息

# 选择题

## 题目描述

docriz 正在考试，他遇到了一个奇怪的选择题：这个选择题共有 $n$ 个选项，其中只有一个选项是正确的。他完全不会做这题，所以只能靠蒙。

蒙这道题分为 $n - 2$ 轮，在第 $1$ 轮开始之前，docriz 会在这 $n$ 个选项中随机蒙一项，之后的每轮流程如下：首先，nocriz 会过来帮他排除一个选项，由于 nocriz 事先知道答案，所以他会在现有的除正确的那一项和 docirz 正在选的那一项外的选项里，随机删去一个。之后，docriz 可以选择是否更换自己蒙的选项，如果更换，则随机更换到除正在选的那一项之外的任意一项。

docriz 在这 $n - 2$ 轮中，由于和 nocriz 达成的神秘协定，需要恰好更换 $k$ 次选项。他想知道，如何更换，使得自己蒙对的概率最大，输出这个概率。为了方便，你需要输出这个概率的分数形式在模 $10^9 + 7$ 意义下的结果。

## 说明/提示

样例 $1$ 到 $4$ 分别为 $\frac{2}{3}, \frac{1}{3}, \frac{3}{4}, \frac{5}{8}$。

对于 $30\%$ 的数据，保证 $5 \leq n \leq 10$。

对于另外 $5\%$ 的数据，保证 $k = 0$。

对于另外 $10\%$ 的数据，保证 $k = 1$。

对于另外 $10\%$ 的数据，保证 $k = n - 2$。

对于另外 $5\%$ 的数据，保证 $n \leq 10^2$。

对于另外 $10\%$ 的数据，保证 $n \leq 10^3$。

对于 $100\%$ 的数据，保证 $5 \leq n \leq 10^5, 0 \leq k \leq n - 2$。

## 样例 #1

### 输入

```
3 1```

### 输出

```
666666672```

## 样例 #2

### 输入

```
3 0```

### 输出

```
333333336```

## 样例 #3

### 输入

```
4 1```

### 输出

```
750000006```

## 样例 #4

### 输入

```
4 2```

### 输出

```
625000005```

## 样例 #5

### 输入

```
100000 99998```

### 输出

```
439903656```

# AI分析结果

---
# 💡 Kay的C++算法解析：选择题蒙答案概率问题 深入学习指南 💡

<introduction>
  今天我们来一起分析“选择题蒙答案概率问题”这道C++编程题。这道题结合了**数学概率分析**和**模运算技巧**，需要我们先找出最优策略下的概率公式，再用编程实现分数的模运算。本指南将帮助大家梳理思路、理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（概率推导）` + `编程技巧应用（模逆元）`

🗣️ **初步分析**：
> 解决这道题的关键在于两点：一是**找到让蒙对概率最大的最优策略**，二是**用模运算处理分数结果**。  
> 首先，最优策略是什么？其实这是经典“三门问题”的扩展——当我们必须更换k次时，**最后一次更换一定要放在最后一轮排除之后**（此时只剩2个选项，若之前选的是错的，更换后必对），而前k-1次更换要**尽可能保持错误状态**（这样最后一次更换的正确率最高）。  
> 接下来，概率推导的核心是**递推错误概率**：初始时随机选一个，错误概率是`(n-1)/n`。之后每更换一次，错误概率会按照`P_new = (x-1 - P_old)/(x-1)`递推（x是当前剩余选项数）。最后，这个错误概率就是我们要的最大正确率（因为最后一次更换后，错→对）。  
> 最后，由于结果需要模`1e9+7`，我们需要用**模逆元**将分数转化为乘法运算（费马小定理或扩展GCD均可）。  

  - **可视化设计思路**：我们会用8位像素风模拟“选项排除+更换”的过程——用不同颜色的像素块代表选项（红=正确，蓝=错误），每轮排除一个蓝色块时播放“叮”的音效，更换选项时用“滑动”动画展示，错误概率用像素数字实时更新。关键步骤（如最后一次更换）会用闪烁高亮，帮助大家直观看到概率变化。


---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了2份优质题解：
</eval_intro>

**题解一：Itst（思路简洁+递推式清晰）**
* **点评**：这份题解的核心贡献是**提炼出了概率递推的简洁公式**。作者通过分析最优策略（最后一次更换在最后一轮），推导出错误概率的递推式：`fz = fm * n - fz`（fz是分子，fm是分母，n是当前剩余选项数相关变量）。代码风格非常简洁，用快速幂求逆元（费马小定理）处理模运算，边界条件（k=0）也处理得很严谨。比如样例4中，输入4 2时，递推一次就得到分子5、分母8，直接计算逆元得到结果，逻辑链完整且易懂。

**题解二：揽月摘星辰（扩展GCD补充+代码详细）**
* **点评**：这份题解的亮点是**用扩展GCD求逆元**，补充了另一种模运算的实现方式。作者详细解释了概率递推的逻辑（错误概率如何更新），并强调了“最后一次更换前保持错误”的核心思想。代码中扩展GCD的实现很标准，适合不熟悉费马小定理的同学参考。同时，作者提醒了“开long long”的细节，避免溢出，这是编程中的重要经验。


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点集中在“理解最优策略”“推导概率递推式”和“处理模运算”三个方面。结合优质题解，我为大家提炼了关键策略：
</difficulty_intro>

1.  **关键点1：为什么最后一次更换要放在最后一轮？**
    * **分析**：当进行n-2轮排除后，剩下的选项数是`n - (n-2) = 2`（只剩2个选项）。此时，如果我们之前选的是错误选项，更换后必然选对；如果是正确选项，更换后必然选错。因此，最后一次更换的正确率等于“最后一次更换前的错误概率”。要最大化这个概率，就必须把最后一次更换放在最后一轮（此时剩余选项最少，错误概率的“转化率”最高）。
    * 💡 **学习笔记**：最优策略的核心是“把最有效的更换放在最后”。

2.  **关键点2：如何推导错误概率的递推式？**
    * **分析**：假设当前剩余x个选项，之前的错误概率是P（即选错误选项的概率）。此时更换选项，新的错误概率怎么算？  
      - 如果之前选的是错误（概率P），更换时要从x-1个选项中选一个，其中正确选项1个，错误选项x-2个，所以选错误的概率是`(x-2)/(x-1)`；  
      - 如果之前选的是正确（概率1-P），更换后必然选错误，概率是1；  
      综上，新的错误概率是`P*(x-2)/(x-1) + (1-P) = (x-1 - P)/(x-1)`。这就是递推式的来源！
    * 💡 **学习笔记**：概率递推要分情况讨论“当前状态”，再加权求和。

3.  **关键点3：如何处理模运算中的分数？**
    * **分析**：题目要求输出分数`a/b`模`1e9+7`的结果。由于`1e9+7`是质数，我们可以用**费马小定理**求逆元：`b的逆元是b^(MOD-2) mod MOD`。或者用**扩展GCD**求`bx ≡ 1 mod MOD`的解x（即逆元）。两种方法都能将分数转化为`a * x mod MOD`。
    * 💡 **学习笔记**：模逆元是处理分数模运算的“钥匙”，质数模数优先用费马小定理（代码更简洁）。

### ✨ 解题技巧总结
- **技巧A：问题抽象**：将复杂的“n轮排除+更换”问题抽象为“最后一次更换的错误概率”，简化问题规模。
- **技巧B：递推式简化**：将概率递推式转化为分子分母的整数运算（如Itst的`fz = fm * n - fz`），避免浮点误差。
- **技巧C：模运算细节**：用long long存储中间结果，避免溢出；逆元计算后要取模（防止负数）。


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个综合优质题解的通用核心实现——用费马小定理求逆元，逻辑清晰且高效：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Itst题解的递推式和快速幂逆元，是最简洁的核心实现。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;
    const int MOD = 1e9 + 7;

    long long pow_mod(long long a, long long b) {
        long long res = 1;
        while (b > 0) {
            if (b % 2 == 1) res = res * a % MOD;
            a = a * a % MOD;
            b /= 2;
        }
        return res;
    }

    int main() {
        int n, k;
        cin >> n >> k;
        if (k == 0) {
            cout << pow_mod(n, MOD - 2) << endl;
            return 0;
        }
        k--; // 前k-1次递推
        long long fz = n - 1, fm = n;
        int current_n = n - 2; // 初始剩余选项数相关变量
        while (k--) {
            fm = fm * current_n % MOD;
            fz = (fm - fz + MOD) % MOD; // 加MOD防止负数
            current_n--;
        }
        long long inv_fm = pow_mod(fm, MOD - 2);
        cout << fz * inv_fm % MOD << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. **快速幂函数**：`pow_mod`计算`a^b mod MOD`，用于求逆元；  
    > 2. **k=0特判**：不更换任何次数，正确率就是`1/n`，直接输出逆元；  
    > 3. **递推过程**：初始化分子`fz = n-1`（初始错误概率分子）、分母`fm = n`（初始分母）；然后进行k-1次递推，每次更新分母（乘当前`current_n`）和分子（新分母减原分子）；  
    > 4. **求逆元输出**：计算分母的逆元，分子乘逆元就是最终结果。

---
<code_intro_selected>
接下来剖析两份优质题解的核心片段：
</code_intro_selected>

**题解一：Itst（快速幂逆元+递推式）**
* **亮点**：用整数递推式避免浮点运算，代码极简。
* **核心代码片段**：
    ```cpp
    if(k == 0)
        cout << poww(n , MOD - 2);
    else{
        k--;
        long long fz = n - 1 , fm = n;
        n -= 2;
        while(k){
            fz = ((fm = fm * n % MOD) - fz) % MOD;
            k--;
            n--;
        }
        cout << fz * poww(fm , MOD - 2) % MOD;
    }
    ```
* **代码解读**：
    > 1. **k=0特判**：直接输出`1/n`的逆元；  
    > 2. **递推初始化**：`k--`表示要进行k-1次递推，`fz = n-1`（初始错误概率分子）、`fm = n`（分母）；  
    > 3. **递推循环**：每次将分母`fm`乘当前`n`（剩余选项数相关变量），分子`fz`更新为`fm - fz`（对应递推式`(x-1 - P_old)/(x-1)`的分子变换）；  
    > 4. **结果计算**：分子乘分母逆元，输出模结果。
* 💡 **学习笔记**：整数递推式是处理概率问题的“神器”，避免了浮点精度丢失。

**题解二：揽月摘星辰（扩展GCD求逆元）**
* **亮点**：用扩展GCD实现逆元，适合非质数模数场景（本题模数是质数，所以两种方法都可用）。
* **核心代码片段**：
    ```cpp
    void exgcd(long long a,long long b,long long &x,long long &y) {
        if(b==0){x=1;y=0;return;}
        exgcd(b,a%b,y,x);
        y-=x*(a/b);         
    }
    long long Mod(long long a,long long b) {
        long long x,y;
        exgcd(b,mod,x,y);
        x=(x%mod+mod)%mod;
        return a*x%mod;
    }
    ```
* **代码解读**：
    > 1. **扩展GCD函数**：求解`ax + by = gcd(a,b)`，当`b`是质数时，`gcd(a,b)=1`，所以`x`就是`a`的逆元；  
    > 2. **Mod函数**：计算`a/b mod mod`，即`a * 逆元(b) mod mod`。通过扩展GCD求出逆元`x`，调整到正数后返回结果。
* 💡 **学习笔记**：扩展GCD是求逆元的通用方法，即使模数不是质数也能使用。


---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“最优策略下的概率变化”，我设计了一个**8位像素风的“蒙题模拟器”**，结合复古游戏元素展示每一步的决策和概率变化：
</visualization_intro>

  * **动画演示主题**：像素探险家在“选项迷宫”中寻找正确答案，每轮排除一个错误选项，选择是否更换，最终看正确率。
  * **设计思路**：用FC红白机的配色（红=正确，蓝=错误，黄=当前选择）和简单音效，让大家“看得到”概率的变化。比如，排除错误选项时播放“叮”声，更换选项时播放“滑”声，最后成功时播放“胜利”音效，增强记忆点。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：屏幕显示`n`个像素方块（比如n=4时，4个蓝色方块，1个红色方块隐藏），下方控制面板有“单步”“自动”“重置”按钮，速度滑块，以及实时显示“当前错误概率”的像素数字。
    2. **初始选择**：随机选一个方块（变黄），错误概率显示`(n-1)/n`（比如n=4时显示`3/4`）。
    3. **第一轮排除**：系统排除一个非红、非黄的蓝色方块（消失，播放“叮”声），剩余`n-1`个方块。
    4. **更换选项（前k-1次）**：如果需要更换，黄色方块滑到另一个蓝色方块，错误概率更新为`(x-1 - P_old)/(x-1)`（比如x=3时，`(3-1 - 3/4)/(3-1) = 5/8`，数字变为`5/8`）。
    5. **最后一轮排除**：排除最后一个非红、非黄的蓝色方块，剩余2个方块（红+黄）。
    6. **最后一次更换**：黄色方块滑到红色方块，错误概率变为最终的正确率（比如`5/8`），播放“胜利”音效，红色方块闪烁。

  * **旁白提示**：
    - （初始选择后）“现在随机选了一个，错误概率是`(n-1)/n`！”
    - （排除选项时）“排除了一个错误选项，剩余`x`个！”
    - （更换选项时）“更换后，错误概率变成`(x-1 - P_old)/(x-1)`啦！”
    - （最后更换时）“最后一次更换，正确率等于之前的错误概率——成功！”

<visualization_conclusion>
通过这个像素动画，大家可以清晰看到“最优策略”如何一步步提高正确率，以及概率递推的过程。复古游戏元素让学习更有趣，关键步骤的音效和高亮也能强化记忆！
</visualization_conclusion>


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是“概率递推”和“模逆元”，这些技巧可以迁移到很多场景：
</similar_problems_intro>

  * **通用思路迁移**：
    - 场景1：**抽奖问题**（比如抽卡时“保底机制”的概率计算）；
    - 场景2：**博弈问题**（比如两人轮流选物品，求最优策略的胜率）；
    - 场景3：**动态规划中的概率问题**（比如DP状态是“当前状态的概率”，转移时用递推式）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P2613** - 有理数取余
          * 🗣️ **推荐理由**：本题的“模逆元”基础练习，必须掌握！
    2.  **洛谷 P3986** - 斐波那契数列
          * 🗣️ **推荐理由**：用递推式计算数列，结合模运算，锻炼递推思维。
    3.  **洛谷 P1082** - 同余方程
          * 🗣️ **推荐理由**：扩展GCD的经典应用，加深对逆元的理解。


---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
两份优质题解都提到了“细节处理”的重要性：
</insights_intro>

> **参考经验 (来自 Itst)**：“递推时要注意`fz = (fm - fz) % MOD`，加MOD防止负数。”  
> **点评**：模运算中负数是常见陷阱！比如`fm - fz`可能为负，加MOD后再取模才能得到正确的正数结果。

> **参考经验 (来自 揽月摘星辰)**：“一定要开long long！否则会溢出。”  
> **点评**：C++中int的范围是`-2e9~2e9`，而`1e9+7`的平方会超过int的范围，用long long才能避免溢出。


---

<conclusion>
本次关于“选择题蒙答案概率问题”的分析就到这里。这道题让我们学会了**用数学推导找最优策略**，**用递推式处理概率**，以及**用模逆元处理分数**。记住：编程中的“难”往往是“思路的难”，只要把问题拆分成小步骤，逐一解决，就能迎刃而解！下次我们再一起探索新的挑战！💪
</conclusion>

---

---
处理用时：255.52秒
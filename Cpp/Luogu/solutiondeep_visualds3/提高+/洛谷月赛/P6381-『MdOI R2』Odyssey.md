# 题目信息

# 『MdOI R2』Odyssey

## 题目背景

超越音速的极限，不及瑰丽多变的极光；

微弱的脉冲，开拓原本一片混沌的天地；

沉郁的蓝缓缓闪动，史诗的红迎接巅峰；

血色的夕阳尽头，是将夜的星辰；

夜半的满天星空，也会被来自地狱的硝烟掩盖；

炽红炼狱消逝，只金色遗迹永存。

在这里等待着每一位的，都是一段艰苦而璀璨的旅程。

## 题目描述

若正整数 $a$ 与 $b$ 满足：

- $a$ 与 $b$ 的积是一个正整数的 $k$ 次方，即存在正整数 $c$ 使得 $ab=c^k$。

那么我们称 $(a,b)$ 为一组**完美数对**。

---

有一个包含 $n$ 个结点和 $m$ 条边的**有向无环图**，这张图中的每条边都有权值和长度两个属性。

如果一条路径 $P$ 满足**以下条件之一**，则称其为一条**完美路径**：

- $P$ 中仅包含一条边。

- $P$ 从其起点开始依次为 $e_1, e_2, e_3, \ldots e_p$ 这 $p\ (p\ge 2)$ 条边，对于任意的 $1\leq i\leq p-1$，$e_i$ 的权值和 $e_{i+1}$ 的权值组成完美数对。

你需要求出图中最长完美路径的长度，一条路径的长度定义为这条路径上所有边的长度之和。

## 说明/提示

【帮助与提示】  

为方便选手测试代码，本题额外提供两组附加样例供选手使用。  

[样例输入1](https://www.luogu.com.cn/paste/wx1lz6m2) [样例输出1](https://www.luogu.com.cn/paste/28xe7f0x)      

[样例输入2](https://www.luogu.com.cn/paste/efgwngs5) [样例输出2](https://www.luogu.com.cn/paste/5hcpoayt)   

----

【样例解释】

样例中给出的有向无环图如图所示，其中边上的红色数字为边的权值，黑色数字为边的长度：

![](https://cdn.luogu.com.cn/upload/image_hosting/w6x03ksd.png)

最长完美路径为 $2\to 5\to 3$，因为这两条边的权值 $2$ 和 $18$ 满足 $2\times 18=6^2$，是完美数对，此路径长度为 $5+9=14$。

此外，$2\to 1\to 4\to 3,\ \ 2\to 4\to 3,\ \ 1\to 5\to 3$ 等也是完美路径，但不是最长的。

图中，$2\to 1\to 5\to 3$ 长度为 $15$，是一条更长的路径，但它并不是完美路径，因为前两个边权 $24$ 和 $8$ 的乘积为 $192$，不是正整数的平方，即 $(24,8)$ 不是完美数对。

---

【数据范围】

**本题采用捆绑测试。**

对于 $100\%$ 的数据：$1\leq n\leq 10^5,\ \ 1\leq m\leq 2\times 10^5,\ \ 1\leq k\leq 10,\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^5,\ \ 1\leq l\leq 10^4$。

给出的图**不保证弱连通**，图中从一个点到另一个点**可能**存在多条边，但保证给出的图是有向无环图。

| 子任务编号 | $n\leq$ |     $m\leq$      | $w\leq$ | $k\leq$ |  特殊性质  | 分值 |
| :--------: | :-----: | :--------------: | :-----: | :-----: | :--------: | :--: |
| Subtask 1  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $1$   |     无     | $18$ |
| Subtask 2  |  $10$   |       $10$       |  $100$  |  $2$   |     无     | $12$ |
| Subtask 3  |  $600$  | $1.5\times 10^3$ | $10^3$  |   $2$   |     无     | $10$ |
| Subtask 4  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   | $w$ 为素数 | $15$ |
| Subtask 5  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   |     无     | $15$ |
| Subtask 6  |  $600$  | $1.5\times 10^3$ | $10^3$  |  $5$   |     无     | $10$ |
| Subtask 7  | $10^5$  |  $2\times 10^5$  | $10^5$  |  $10$   |     无     | $20$ |



## 样例 #1

### 输入

```
5 7 2
2 5 2 5
5 3 18 9
2 4 6 7
4 3 6 3
2 1 24 2
1 4 6 8
1 5 8 4```

### 输出

```
14```

# AI分析结果


### Kay的C++算法解析：『MdOI R2』Odyssey 深入学习指南

#### **1. 题目解读与核心算法识别**  
✨ **本题主要考察**：图论（DAG动态规划） + 数论（质因数分解与状态压缩）  

🗣️ **初步分析**：  
> 本题要求在有向无环图（DAG）中寻找最长"完美路径"，路径中相邻边权需满足乘积为 \(c^k\)。核心思想是将复杂数论条件转化为可计算的动态规划状态：  
> - **质因数分解的妙用**：将边权 \(w\) 分解质因式后，指数对 \(k\) 取模得到"约化权值" \(w'\)，其唯一对应一个"配对权值" \(f(w')\)（满足 \(w' \times f(w')\) 是 \(k\) 次方数）。  
> - **动态规划策略**：用 \(dp[u][w']\) 表示以节点 \(u\) 结尾、最后一条边约化权值为 \(w'\) 时的最大路径长度。状态转移通过拓扑排序实现，关键公式：  
>   \[
>   dp[v][w'] = \max(dp[v][w'], \ dp[u][f(w')] + l)
>   \]  
> - **可视化设计**：在像素动画中将节点设计为房间，边为带权值的门，角色需按权值匹配规则（当前门 \(w'\) 与下一门 \(f(w')\) 匹配）移动。高亮匹配成功的门并添加音效（如"叮"声），自动演示模式可调速展示拓扑排序过程。  

---

#### **2. 精选优质题解参考**  
**题解一（BFqwq）**  
* **亮点**：  
  - **分层图拓扑**：将节点拆为两层（原节点与虚拟节点），确保权值 \(w'\) 和 \(f(w')\) 的边交替转移，避免状态冲突。  
  - **严谨边界处理**：对超出值域（\(>10^5\)）的 \(f(w')\) 返回 \(-1\)，直接终止路径。  
  - **实践价值**：完整处理了 \(k=1\) 的特例（此时所有边自动匹配）。  

**题解二（一扶苏一）**  
* **亮点**：  
  - **双哈希防冲突**：用两个质数（998244353, \(10^9+7\)）哈希约化权值，避免大质数导致的冲突。  
  - **代码模块化**：分离质因数分解与DP转移，逻辑清晰易调试。  
  - **竞赛适用性**：直接可用于竞赛场景，鲁棒性强。  

**题解三（zzqDeco）**  
* **亮点**：  
  - **代码简洁高效**：直接使用 `unordered_map` 存储DP状态，减少冗余。  
  - **拓扑排序整合**：在拓扑排序中同步完成状态转移，时间复杂度 \(O(m \log w)\)。  
  - **教学友好**：适合初学者理解DP与数论结合的核心逻辑。  

---

#### **3. 核心难点辨析与解题策略**  
1. **难点1：权值匹配的数学转化**  
   - **分析**：需将 \(ab = c^k\) 转化为质因数指数和模 \(k\) 为 \(0\)。解法是将边权 \(w\) 分解质因数，指数取模 \(k\) 得 \(w'\)，再计算其配对权值 \(f(w')\)。  
   - 💡 **学习笔记**：质因数分解是处理指数问题的通用工具，取模可大幅减少状态数。  

2. **难点2：状态爆炸与存储优化**  
   - **分析**：直接存储 \(w'\) 导致状态空间过大。解法是用 `map/unordered_map` 动态存储各节点的 \(dp[u][w']\)。  
   - 💡 **学习笔记**：当状态离散但总量有限时，哈希表是平衡时空效率的最佳选择。  

3. **难点3：DAG上的动态规划转移**  
   - **分析**：转移需保证当前边 \(w'\) 与前驱边 \(f(w')\) 匹配。解法是拓扑排序中按节点顺序更新状态。  
   - 💡 **学习笔记**：DAG的拓扑序是DP的天然计算顺序，无后效性是其核心优势。  

✨ **解题技巧总结**：  
- **分解与抽象**：将数论条件抽象为"约化-配对"权值模型。  
- **状态压缩**：用质因数分解压缩指数状态，避免枚举所有质因子组合。  
- **鲁棒性测试**：特别注意 \(k=1\) 和 \(f(w')\) 超界的情况。  

---

#### **4. C++核心代码实现赏析**  
**本题通用核心实现参考**  
* **说明**：基于 zzqDeco 题解优化，整合拓扑排序与哈希状态转移。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <unordered_map>
  #include <queue>
  using namespace std;
  const int MAXN = 1e5+5;

  struct Edge { int v, w, l, w1, w2; }; // w1=约化权值, w2=配对权值
  vector<Edge> G[MAXN];
  unordered_map<int, int> dp[MAXN]; // dp[u][w1] = 最长路径长度
  int inDeg[MAXN], n, m, k, ans;

  int reduce(int w) { // 计算约化权值 w1
      int res = 1;
      for (int i = 2; i*i <= w; i++) {
          int cnt = 0;
          while (w % i == 0) cnt++, w /= i;
          cnt %= k;
          for (int j = 0; j < cnt; j++) res *= i;
      }
      if (w > 1 && k != 1) res *= w;
      return res;
  }

  int pairVal(int w1) { // 计算配对权值 w2
      int res = 1;
      for (int i = 2; i*i <= w1; i++) {
          int cnt = 0;
          while (w1 % i == 0) cnt++, w1 /= i;
          cnt %= k;
          if (cnt) for (int j = 0; j < k - cnt; j++) 
              if ((res *= i) > 1e5) return -1; // 超界处理
      }
      if (w1 > 1 && k != 1) 
          for (int j = 1; j < k; j++) 
              if ((res *= w1) > 1e5) return -1;
      return res;
  }

  void topoSort() {
      queue<int> q;
      for (int i = 1; i <= n; i++) 
          if (inDeg[i] == 0) q.push(i);
      while (!q.empty()) {
          int u = q.front(); q.pop();
          for (auto &e : G[u]) {
              // 转移条件：当前边权w1需匹配前驱的w2
              if (e.w2 != -1 && dp[u].count(e.w2)) 
                  dp[e.v][e.w1] = max(dp[e.v][e.w1], dp[u][e.w2] + e.l);
              else // 作为路径起点
                  dp[e.v][e.w1] = max(dp[e.v][e.w1], e.l); 
              ans = max(ans, dp[e.v][e.w1]);
              if (--inDeg[e.v] == 0) q.push(e.v);
          }
      }
  }

  int main() {
      cin >> n >> m >> k;
      for (int i = 0; i < m; i++) {
          int u, v, w, l; cin >> u >> v >> w >> l;
          int w1 = reduce(w), w2 = pairVal(w1);
          G[u].push_back({v, w, l, w1, w2});
          inDeg[v]++;
      }
      topoSort();
      cout << ans;
  }
  ```
* **代码解读概要**：  
  1. **reduce()**：计算约化权值（质因数分解后指数取模 \(k\)）。  
  2. **pairVal()**：计算配对权值，若结果 \(>10^5\) 返回 \(-1\) 表示无效。  
  3. **topoSort()**：在拓扑序中更新DP状态，核心转移在匹配成功时触发。  

**题解片段赏析**  
1. **BFqwq的分层图技巧**  
   ```cpp
   void topo(int w) {
       // 权值w的边：终点v升级为虚拟节点 (v+n)
       for (Edge e : edges[w]) {
           addEdge(e.u, e.v + n, e.l); 
           inDeg[e.v + n]++;
       }
       // 配对权值f(w)的边：从虚拟节点出发
       for (Edge e : edges[f(w)]) {
           addEdge(e.u + n, e.v, e.l);
           inDeg[e.v]++;
       }
       // 拓扑排序...
   }
   ```
   **学习笔记**：分层图确保权值交替匹配，避免同类型边连续。  

2. **一扶苏一的双哈希**  
   ```cpp
   pair<int,int> hashEdge(int w) {
       vector<int> expo;
       for (int p : primes) {
           int cnt = 0;
           while (w % p == 0) w /= p, cnt++;
           expo.push_back(cnt % k);
       }
       return {hash1(expo), hash2(expo)}; // 双哈希值
   }
   ```
   **学习笔记**：双哈希降低冲突概率，适合大范围权值映射。  

---

#### **5. 算法可视化：像素动画演示**  
* **主题**：8-bit风格DAG探险  
* **核心演示流程**：  
  1. **场景初始化**：  
     - 节点设计为像素房间，边为彩色门（门牌=约化权值 \(w'\)）。  
     - 控制面板含步进/调速/重置按钮，背景播放复古芯片音乐。  
  2. **角色移动规则**：  
     - 从入度=0的节点开始，角色进入房间后自动高亮所有门（绿色边框）。  
     - 选择门 \(w'\) 后：  
       - 显示需求提示："下一门需权值 \(f(w')\)"  
       - 进入新房间时，播放音效：匹配成功（清脆"叮"声）或失败（低沉嗡鸣）。  
  3. **自动演示模式**：  
     - 按拓扑序自动选择门，实时显示当前DP值（路径长度）。  
     - 关键步骤暂停：展示 \(w'\) 与 \(f(w')\) 的匹配计算过程。  
  4. **动态数据结构**：  
     - 队列变化：像素化队列（当前待访问节点）随拓扑排序动态更新。  
     - DP状态表：侧边栏显示各节点 \(dp[u][w']\) 的实时数值。  

---

#### **6. 拓展练习与相似问题思考**  
* **通用技巧迁移**：  
  质因数分解+状态DP可解决：  
  1. 乘积为完全平方数的路径计数（LeetCode 1449）  
  2. 边权满足线性同余方程的最短路（CodeForces 1100F）  
  3. 按位与/或约束的图论问题（ABC 232G）  

* **洛谷练习推荐**：  
  1. **P1072** [NOIP2009] Hankson的趣味题  
     - 理由：巩固质因数分解与约数性质。  
  2. **P3388** 割点（模板题）  
     - 理由：学习图论基础，理解DAG与连通性关系。  
  3. **P1020** [NOIP1999] 导弹拦截  
     - 理由：DAG模型经典应用（最长上升子序列）。  

---

#### **7. 学习心得与经验分享**  
> **BFqwq的调试经验**：  
> *"数组开小导致WA，分层图需开双倍空间！"*  
> **Kay总结**：空间计算是竞赛常见陷阱，需预先估算最坏情况（如本题虚拟节点数）。  
>  
> **一扶苏一的心得**：  
> *"双哈希避免了大质数冲突，提升代码鲁棒性"*  
> **Kay总结**：哈希冲突容易被忽视，双哈希是工业级解决方案。  

---  
**结语**：通过质因数分解转化数论条件，结合DAG动态规划，是解决此类问题的通用框架。理解权值匹配的本质与状态压缩的思想，你也能征服史诗般的算法奥德赛！🚀

---
处理用时：236.11秒
# 题目信息

# Mex

## 题目背景

忘掉种过的花/重新的出发/放弃理想吧。

## 题目描述

小 G 曾经有一个 $0$ 到 $n$ 的排列（下标从 $0$ 开始），但他忘记了这个排列。

现在他想把这个排列找回来，他努力地回想，只能回想起关于这个排列的 $m$ 条信息，每条信息形如 $(l,r,val)$，表示区间 $[l,r]$ 的 ${\rm mex}$ 值为 $val$。一个区间的 ${\rm mex}$ 值是最小的没有在这个区间中出现的自然数。

小 G 把 $n$ 和这 $m$ 条信息告诉了你，希望你能帮他还原出一个排列，或者告诉他他的回忆出现了问题。



## 说明/提示

**本题采用捆绑测试**。你只有通过 subtask 中的所有测试点才能获得该 subtask 的分数。

- Subtask 1(15 points)：$n,m\le 10$；
- Subtask 2(20 points)：$n,m\le 20$；
- Subtask 3(10 points)：$val=0$；
- Subtask 4(15 points)：数据随机生成；
- Subtask 5(10 points)：$n\le 10^5$；
- Subtask 6(30 points)：无特殊限制。

对于所有的数据满足：$1 \le n,m\le 5\times 10^5$，$ 0\le l,r\le n$，$0\le val\le n+1$。

Subtask4 的数据生成方式为：随机生成一个排列，再随机 $m$ 个区间求出它们的 ${\rm mex}$ 值作为条件。

本题输入输出量较大，请注意使用效率较高的 IO 方式。

## 样例 #1

### 输入

```
3 4
0 0 0
0 1 1
0 2 2
1 3 3```

### 输出

```
3 0 1 2```

## 样例 #2

### 输入

```
5 7
0 1 0
4 5 0
1 3 1
0 5 6
0 5 6
2 5 3
2 3 1```

### 输出

```
4 3 5 0 1 2 ```

# AI分析结果


### 💡 Kay的C++算法解析：Mex 深入学习指南 💡

> 你好！我是你的C++算法导师Kay。今天我们一起探索一道关于"Mex"的构造题。题目要求我们根据给定的区间Mex条件还原一个排列。这题看似复杂，但掌握了核心思想后你会发现它像搭积木一样有趣！我们将通过清晰的算法解析、生动的像素动画和精选代码示例，带你深入理解这道题的奥秘。

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心策略与区间约束处理

🗣️ **初步分析**：
> 解决"Mex"问题的关键在于理解**区间约束的传递性**和**贪心构造策略**。想象你在玩一个数字拼图游戏：
>   - 每个Mex条件（区间[l, r]的mex=val）就像一条规则：拼图中0~val-1的碎片必须出现在该区间内，而val碎片不能出现
>   - 我们需要将这些数字碎片（0~n）逐个放置到正确位置
> 
> 核心策略：
> 1. **约束合并**：对每个数字x，计算其"必须出现"的区间（所有val>x条件的交集）和"禁止出现"的区间（所有val=x+1条件的并集）
> 2. **贪心放置**：从0开始从小到大放置数字，每次在合法位置中任选一个位置
> 3. **动态维护**：用栈/set/并查集高效维护可用位置
> 
> **可视化设计思路**：
> - 像素网格表示0~n的位置，不同颜色标记约束区间：
>   - 🟩 绿色：必须出现区间
>   - 🟥 红色：禁止出现区间
>   - ⬜ 灰色：自由位置
> - 动画展示数字从0开始逐个放置的过程，伴随音效：
>   - "咔哒"声：成功放置数字
>   - "哔-"声：无解提示
> - 右侧实时显示可用位置栈的变化

---

## 2. 精选优质题解参考

### 题解一（作者：disposrestfully）
* **点评**：思路清晰直白，用栈维护可用位置：
  - **亮点**：O(n)时间复杂度，无需复杂数据结构
  - **代码规范**：变量命名直观（pl/pr表示必须区间，ql/qr表示禁止区间）
  - **实践价值**：边界处理严谨，可直接用于竞赛
  - **优化技巧**：差分数组处理0的特殊约束

### 题解二（作者：hsfzLZH1）
* **点评**：set实现的优雅解法：
  - **亮点**：利用set::lower_bound高效查找合法位置
  - **代码可读性**：约束处理逻辑分层清晰
  - **启发点**：特别提醒了set::lower_bound与std::lower_bound的性能差异
  - **实践价值**：适合需要快速实现的中等规模数据

### 题解三（作者：fmj_123）
* **点评**：并查集优化的高效方案：
  - **亮点**：并查集维护连续空闲块，查找效率近O(1)
  - **算法优化**：处理大规模数据（n≤5e5）的最佳选择
  - **调试经验**：作者分享了因忽略约束导致WA的教训，提醒我们全面审题

---

## 3. 核心难点辨析与解题策略

### 难点1：约束的正确推导
* **分析**：每个Mex条件隐含两个约束：
  - 必须出现：0~val-1在区间内
  - 禁止出现：val不在区间内
* **解法**：用后缀最大/最小值合并同类约束
* 💡 **学习笔记**：约束合并是解题基石，需验证区间有效性（左≤右）

### 难点2：放置策略的后效性
* **分析**：当前选择是否会影响后续数字放置？
* **解法**：利用约束单调性（数越大约束越松），证明贪心策略无后效性
* 💡 **学习笔记**：约束区间的单调性保证了贪心有效性

### 难点3：位置查找的效率
* **分析**：如何在庞大解空间（n≤5e5）快速找到合法位置？
* **解法**：根据需求选择数据结构：
  - 栈：O(1)选择，适合顺序访问
  - set：O(log n)查找，支持随机访问
  - 并查集：近O(1)查找，适合大规模数据
* 💡 **学习笔记**：数据结构的选择决定算法效率上限

### ✨ 解题技巧总结
- **约束转化技巧**：将Mex条件拆解为"必须"+"禁止"二元约束
- **区间操作技巧**：用后缀最值合并约束，差分处理特殊条件
- **贪心策略**：从小到大处理数字，利用单调性避免后效性
- **数据结构选择**：
  - 小规模：栈（简单高效）
  - 中等规模：set（灵活易用）
  - 大规模：并查集（最优效率）

---

## 4. C++核心代码实现赏析

### 通用核心实现（综合优化版）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 500010;

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    
    // 初始化区间约束
    vector<int> pl(n+1, 0), pr(n+1, n);
    vector<int> ql(n+1, n+1), qr(n+1, -1);
    vector<int> diff(n+2, 0);
    
    // 处理输入约束
    while (m--) {
        int l, r, val;
        scanf("%d%d%d", &l, &r, &val);
        if (val == 0) {
            diff[l]++; diff[r+1]--;
        } else {
            pl[val-1] = max(pl[val-1], l);
            pr[val-1] = min(pr[val-1], r);
            ql[val] = min(ql[val], l);
            qr[val] = max(qr[val], r);
        }
    }
    
    // 合并约束
    for (int i = n-1; i >= 0; i--) {
        pl[i] = max(pl[i], pl[i+1]);
        pr[i] = min(pr[i], pr[i+1]);
        if (pl[i] > pr[i]) return !printf("-1");
    }
    
    // 处理0的特殊约束
    vector<int> s(n+1, 0);
    for (int i = 0; i <= n; i++) {
        s[i] = (i ? s[i-1] : 0) + diff[i];
    }
    
    // 栈维护可用位置
    vector<int> ans(n+1, -1), stack;
    vector<bool> used(n+1, false);
    
    // 放置数字0
    for (int i = pl[0]; i <= pr[0]; i++) {
        if (!s[i]) stack.push_back(i), used[i] = true;
    }
    if (stack.empty()) return !printf("-1");
    ans[stack.back()] = 0; stack.pop_back();
    
    // 放置数字1~n
    for (int num = 1; num <= n; num++) {
        // 更新可用位置
        auto update = [&](int start, int end) {
            for (int i = start; i <= end; i++) {
                if (!used[i]) stack.push_back(i), used[i] = true;
            }
        };
        
        if (ql[num] <= qr[num]) {
            update(pl[num], ql[num]-1);
            update(qr[num]+1, pr[num]);
        }
        
        // 检查并放置当前数字
        if (stack.empty() || (ql[num] <= stack.back() && stack.back() <= qr[num])) {
            return !printf("-1");
        }
        ans[stack.back()] = num;
        stack.pop_back();
        update(max(pl[num], ql[num]), min(pr[num], qr[num]));
    }
    
    // 输出结果
    for (int i = 0; i <= n; i++) printf("%d ", ans[i]);
    return 0;
}
```

### 题解一（栈解法）核心片段
```cpp
// 放置数字0
for (int i = pl[0]; i <= pr[0]; i++) {
    if (!s[i]) stack.push_back(i), used[i] = true;
}
ans[stack.back()] = 0; stack.pop_back();

// 关键：动态更新可用位置栈
for (int num = 1; num <= n; num++) {
    if (ql[num] <= qr[num]) {
        // 处理禁止区间外的位置
        for (int j = pl[num]; j < ql[num] && j <= pr[num]; j++)
            if (!used[j]) stack.push_back(j), used[j] = true;
        for (int j = pr[num]; j > qr[num] && j >= pl[num]; j--)
            if (!used[j]) stack.push_back(j), used[j] = true;
    }
    // 检查并放置
    if (stack.empty() || ... ) return -1;
    ans[stack.back()] = num; stack.pop_back();
}
```
* **学习笔记**：栈的LIFO特性天然适合处理连续空间的位置选择

### 题解二（set解法）核心片段
```cpp
set<int> available;
// ... 初始化available为所有位置

for (int num = 0; num <= n; num++) {
    auto it = available.lower_bound(pl[num]);
    // 查找第一个合法位置
    while (it != available.end() && *it <= pr[num]) {
        if (*it < ql[num] || *it > qr[num]) break;
        ++it;
    }
    // 处理禁止区间
    if (it == available.end() || ... ) return -1;
    ans[*it] = num;
    available.erase(it);
}
```
* **学习笔记**：set提供有序查找，适合需要位置选择的场景

### 题解三（并查集解法）核心片段
```cpp
vector<int> next_pos(n+2);
for (int i = 0; i <= n+1; i++) next_pos[i] = i;

function<int(int)> find = [&](int x) {
    return next_pos[x] == x ? x : next_pos[x] = find(next_pos[x]);
};

for (int num = 0; num <= n; num++) {
    int pos = find(pl[num]);
    if (pos > pr[num] || (ql[num] <= pos && pos <= qr[num])) 
        return -1;
    ans[pos] = num;
    next_pos[pos] = find(pos+1); // 合并位置
}
```
* **学习笔记**：并查集高效维护连续空闲区间，时间复杂度近O(1)

---

## 5. 算法可视化：像素动画演示

> **主题**：数字拼图探险 - 8位像素风格演示  
> **核心思想**：将算法过程转化为复古游戏关卡，每放置一个数字即通过一小关

### 动画设计细节
1. **场景布局**：
   - 顶部：当前数字（像素化数字图标）
   - 中部：0~n位置网格（每个位置是16x16像素块）
   - 右侧：可用位置栈（像素化列表）
   - 底部：控制面板（开始/暂停/单步/速度滑块）

2. **关键动画帧**：
   ```plaintext
   初始化: [⬜][⬜][⬜][⬜][⬜][⬜] 栈：空
   处理0:  [🟥][🟩][🟩][🟩][🟥][⬜] → 栈加入位置1,2,3
   放置0: [🟥][ 0 ][🟩][🟩][🟥][⬜] (播放"咔哒"声)
   更新栈: [🟥][ 0 ][🟩][🟩][🟥][⬜] → 栈: [2,3,5]
   ```

3. **动态演示规则**：
   - 当前数字的"必须区间"：绿色闪烁（0.5s间隔）
   - "禁止区间"：红色静态块
   - 栈操作：位置加入时绿色闪光，移除时橙色闪光
   - 成功放置：数字块旋转放大特效+8bit音效
   - 无解：全屏红色闪烁+警报音

4. **游戏化元素**：
   - 每放置3个数字获得⭐奖励
   - 连续正确放置触发"连击"特效
   - 通关后显示：用时/准确率/评级（S/A/B/C）
   - 背景音乐：芯片音乐版《卡农》循环

---

## 6. 拓展练习与相似问题

### 通用技巧迁移
本解法核心思想可用于：
1. 区间约束满足问题（如日程安排）
2. 贪心构造问题（如拓扑排序）
3. 带限制的排列生成问题

### 推荐练习（洛谷）
1. **P1044 栈**（基础栈应用）
   - 推荐理由：巩固栈的特性理解，为Mex的栈解法打基础
   
2. **P1496 火烧赤壁**（区间合并）
   - 推荐理由：掌握区间操作的核心技巧
   
3. **P1058 立体图**（空间约束处理）
   - 推荐理由：培养约束转化的空间思维能力

---

## 7. 学习心得与经验分享

> **来自题解作者的宝贵经验**：
> "我在解决Mex问题时，因忽略val禁止出现的约束导致多次WA。这让我意识到：**必须全面审视题目约束的每个细节**"
>
> **Kay的总结**：
> 1. 调试时先验证约束推导的正确性
> 2. 小数据手工模拟是最好的测试方法
> 3. 选择数据结构时考虑问题规模：
>    - n≤1000：栈/set足够
>    - n≥10^5：优先考虑并查集
>
> 记住：编程如解谜，耐心分析每个约束条件，终能找到完美拼图方案！

---

> 本次Mex问题的探索就到这里。通过这道题，我们学习了如何将复杂约束转化为可操作的算法，并体验了不同数据结构的妙用。记得动手实现代码，用我们设计的像素动画可视化工具观察算法运行过程，这将加深你的理解。下次遇到构造题时，相信你会更有信心！🚀

---
处理用时：254.95秒
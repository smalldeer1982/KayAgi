# 题目信息

# 「SvR-1」Hack Function!

## 题目背景

**Problem Number:** $\textit{63}$

小 C 坐在 J-PSC2077 的赛场（题目可于下方「**题目附件**」处下载）上，他早已年逾七旬，但作为 Z 队选手还是成功参赛。

## 题目描述

此时的 J-PSC 终于改成了 CF 赛制，小 C 迅速地 AK 了 Day 1，他发现 T2 function 比较好 Hack，题目的人话翻译如下：

> 对于一个数 $A$，定义函数 $f(A)$ 如下：
> 
> 1. 先把 $A$ 变成 $k$ 进制数 $B$。
> 2. 将 $A$ 替换为 $B$ 各位之和。
> 3. 返回执行第 1 步，直到 $B$ 是一位数为止。
> 4. 记 $x$ 表示 $A$ 此时的值（十进制）。
> 此时 $f(A) = x$，$f(A)$ 称作 $A$ 关于 $k$ 的**位和函数**。
>
> 给定 $k, l, r, p$，求出 $\sum_{i = l}^r f(i^i) \bmod p$ 的值。
>
> **特别地，当 $\sum_{i = l}^r f(i^i) = p$ 时，输出 $\texttt{perfect}$。**

小 C 迅速秒了该题，当他翻看别人的代码时，发现他们用的全是暴力枚举。（因为机子跑得飞快）

好不容易看到一个人，他的代码里竟然没有一个  $\texttt{perfect}$！但由于数据过弱，竟然让他 pp 了。

小 C 突然脑子一热，忘记了怎么构造 Hack 数据，所以他通过 Luogu 6.0 求助于你。

小 C 会告诉你 $k, p$ 的值，你需要构造一组 $l, r$，**使答案输出为 $\texttt{perfect}$**。

**若无法构造，输出两个 $\texttt{-1}$。**

## 说明/提示

#### 样例 1 说明

- 对于数据 $1$，在 $k = 10$ 下，有 $f(2^2) = f(4) = 4$，$f(3^3) = f(27) = 9$，显然 $l = 2, r = 3$ 时原题应该输出 $\texttt{perfect}$。
- 对于数据 $2$，在 $k = 10$ 下，发现不可能满足要求。
- 对于数据 $3$，在 $k = 2$ 下，显然有 $f(1^1) = 1$，但该样例仅用于理解，根据数据规模与约定，我们保证 $k \geq 10$。

#### 数据规模与约定

$$
\newcommand{\arraystretch}{1.5}
\begin{array}{c|c|c|c}\hline\hline
\textbf{Subtask} & \textbf{说明} & \textbf{时限} & \textbf{分值} \\\hline
\textsf{1} & \text{无解} & 1\text{ s} & 3 \\\hline
\textsf{2} & \text{有解且\textbf{\textsf{存在}}一组解使 }1\le l\le r\le 10^5 & 1\text{ s} & 16 \\\hline
\textsf{3} & 1\le p\le 10^7 & 1\text{ s} & 34 \\\hline
\textsf{4} & \text{无特殊限制} & 1.5\text{ s} & 47 \\\hline\hline
\end{array}
$$

对于 $100\%$ 的数据，$10 \leq k \leq 10^3$，$1 \leq p \leq 10^8$，$1 \leq T \leq 10$。

保证时限在 std 用时的 $4$ 倍以上。

#### 评测说明

**本题开启 Special Judge 和捆绑测试。**

你需要保证 $l = r = -1$ 或 $1 \leq l \leq r \leq 10^{18}$ 且 $r - l \leq 10^{15}$，否则 SPJ 会将你的答案判为 $0$ 分。

## 样例 #1

### 输入

```
3
10 13
10 3
2 1```

### 输出

```
2 3
-1 -1
1 1```

# AI分析结果


### 💡 Kay的C++算法解析：Hack Function! 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：数学（模运算与循环节）与双指针/哈希  
🗣️ **初步分析**：  
> 解决本题的关键在于利用**模运算性质**和**扩展欧拉定理**。想象一下，计算 $f(i^i)$ 就像在数字迷宫中寻找规律——当 $i$ 足够大时，计算结果会周期性重复（循环节）。  
> - 核心结论：$f(x) = (x-1) \bmod (k-1) + 1$，通过扩展欧拉定理发现 $i^i \bmod (k-1)$ 在 $i \geq \phi(k-1)$ 后出现循环节。  
> - 难点：需高效处理循环节前非周期区间（$i < \phi(k-1)$）和循环区间（$i \geq \phi(k-1)$），并快速定位区间 $[l, r]$ 使和为 $p$。  
> - 可视化设计：采用 **8位像素风格**（类似FC游戏）展示数轴。双指针（L/R）作为像素小人移动：  
>   - 右指针移动时，当前 $i$ 的像素块亮起（绿色），并播放 "叮" 音效；加入 $g(i)$ 值。  
>   - 左指针移动时，离开的像素块变灰（沙沙音效），减去 $g(i)$。  
>   - 当区间和 $=p$ 时，目标区间闪烁金色，播放胜利音效，背景音乐变为《超级玛丽》过关旋律。

---

#### 2. 精选优质题解参考
**题解一（来源：Leasier）**  
* **点评**：思路清晰，直接应用扩展欧拉定理降幂，**双指针扫描**取代哈希表，避免额外空间开销。代码规范：`phi` 计算封装函数，`quick_pow` 模块化。亮点在于循环节处理时，通过**扩展两个周期**解决边界问题（左指针移动需额外周期），复杂度 $O(Tk\varphi(k))$，实践性强。  

**题解二（来源：CSP_Sept）**  
* **点评**：官方解法，**哈希表优化**查找效率。核心逻辑分层处理：非周期区间暴力枚举，循环区间利用模运算和前缀和映射。代码中自定义哈希结构减少冲突，`lcm` 函数复用提高可读性。亮点是严谨处理 $g(i)$ 的边界（$f(A)=k$ 当 $k-1 \mid A$），时间复杂度 $O(T \log k(k^2 + p/k))$，适合大数据。  

**题解三（来源：yizhiming）**  
* **点评**：双指针的另一种实现，**归并思想**处理循环节。教练代码优化了扫描范围：先处理非周期区间，再用整周期逼近 $p$，剩余部分双指针扫描。亮点是无需映射表，空间复杂度 $O(1)$，变量命名直观（如 `xhs` 表循环节和），适合内存敏感场景。  

---

#### 3. 核心难点辨析与解题策略
1. **关键点1：推导 $f(x)$ 的数学公式**  
   * **分析**：$f(x)$ 本质是 $x$ 的数位和递归至个位数。关键结论：$f(x) = (x-1) \bmod (k-1) + 1$（当 $x \equiv 0 \pmod{k-1}$ 时值为 $k-1$）。证明基于 $k^i \equiv 1 \pmod{k-1}$，确保公式覆盖所有情况。  
   * 💡 **学习笔记**：数位和问题常转化为模运算，需注意边界（整除时取 $k-1$）。  

2. **关键点2：利用扩展欧拉定理降幂**  
   * **分析**：当 $i \geq \phi(k-1)$ 时，$i^i \bmod (k-1)$ 可简化为 $i^{i \bmod \varphi + \varphi}$。这揭示了计算结果的**循环节** $T = \text{lcm}(k-1, \phi(k-1))$，将无限问题转为有限区间处理。  
   * 💡 **学习笔记**：扩展欧拉定理是降幂利器，循环节长度由 $\text{lcm}$ 决定。  

3. **关键点3：高效定位区间 $[l, r]$**  
   * **分析**：分三类策略：  
     - $r \leq \phi(k-1)$：暴力枚举。  
     - $l \leq \phi(k-1) < r$：拆分非周期与循环区间，哈希或双指针扫描。  
     - $l > \phi(k-1)$：整周期逼近后扫描剩余部分（至多两个周期）。  
   * 💡 **学习笔记**：双指针适用连续区间和问题，哈希适合离散查询。  

### ✨ 解题技巧总结
- **问题分解**：将大范围拆解为循环节前、循环节内、整周期三部分处理。  
- **数学工具优先**：先推导数学性质（如 $f(x)$ 公式），再设计算法。  
- **边界测试**：验证 $i=1, \phi(k-1), T$ 等关键点的 $g(i)$ 值。  

---

#### 4. C++核心代码实现赏析
**通用核心实现（双指针法）**  
```cpp
#include <cstdio>
typedef long long ll;
int get_phi(int k) { /* 计算欧拉函数 */ }
int main() {
    int t; scanf("%d", &t);
    while (t--) {
        int k, p; scanf("%d %d", &k, &p);
        int kd = k - 1, phi = get_phi(kd);
        int T = kd * phi / gcd(kd, phi); // 循环节长度
        ll sum = 0, l = 1, r = 1;
        bool found = false;
        // 扩展区间：phi + 2*T 保证覆盖边界
        for (; r <= phi + 2 * T; r++) {
            int val = (pow_mod(r, r, kd) - 1) % kd + 1; // g(r)
            sum += val;
            while (sum > p) sum -= g(l++); // 左指针移动
            if (sum == p) { found = true; break; }
        }
        printf(found ? "%lld %lld\n" : "-1 -1\n", l, r);
    }
}
```
**代码解读概要**：  
- 计算 $\phi(k-1)$ 和循环节 $T$。  
- 双指针扫描区间 $[1, \phi + 2T]$：右指针 `r` 加入 $g(r)$，左指针 `l` 在超过 $p$ 时收缩。  
- 找到时输出 $[l, r]$，否则输出 `-1 -1`。  

---  
**题解一（Leasier）片段**  
```cpp
for (int i = 0; i < k; i++) 
    S += F[phi + i] = f(phi + i); // 计算循环节和
for (r = phi; l < phi + k;) {
    if (r < phi + k && sR <= sL) {
        per[r] = sR; mp[mR] = r; // 记录前缀和
        sR += F[++r]; mR = (mR + F[r]) % S;
    } else {
        if (mp.find(mL) != mp.end()) { // 哈希查找
            al = l; ar = mp[mL]; // 找到解
            ar += (sL - per[ar]) / S * k; // 整周期调整
        }
        sL += F[l++]; mL = (mL + F[l]) % S;
    }
}
```
**亮点**：哈希表存储前缀和，循环节和加速大区间调整。  
**学习笔记**：哈希查找 $O(1)$ 优于 map，但需处理冲突。  

**题解二（CSP_Sept）片段**  
```cpp
// 非周期区间前缀和初始化
for (int j = 1; j <= n; j++) {
    sum1[j] = sum1[j - 1] + g(j);
    mp1.assign(sum1[j], j); // 存入哈希
}
// 循环节处理
for (int j = 1; j <= m; j++) {
    sum2[j] = sum2[j - 1] + g(phi + j);
    if (sum2[j] >= p && mp2.count(sum2[j] - p)) {
        ansl = mp2.query(sum2[j] - p) + phi + 1;
        ansr = j + phi; // 直接定位
    }
}
```
**亮点**：分层处理非周期与循环区间，逻辑清晰。  
**学习笔记**：前缀和+哈希是区间和问题的经典组合。  

---

#### 5. 算法可视化：像素动画演示  
**主题**：像素探险家在数轴迷宫中寻找宝藏（$p$ 值）  
**设计思路**：8位像素风格（FC红白机色调）降低理解门槛，音效强化操作反馈，关卡式进度提升成就感。  

**动画流程**：  
1. **场景初始化**：  
   - 数轴化为像素带：$i < \phi(k-1)$ 用蓝色块，循环节区间用绿色块重复。  
   - 控制面板：开始/暂停、单步执行、速度滑块（调速音效）。  
   - 背景音乐：8位芯片音乐循环。  

2. **双指针移动**：  
   - 右指针 `r` 向右移动：当前像素块亮绿，播放 "叮" 音效；下方显示 $g(r)$ 值和实时和。  
   - 和 $>p$ 时左指针 `l` 移动：离开的块变灰（沙沙音效），实时和减少。  

3. **目标达成**：  
   - 区间和 $=p$：$[l, r]$ 闪烁金色，播放胜利音效，背景音乐切为《超级玛丽》过关旋律。  
   - 无解：全屏红光闪烁，短促 "失败" 音效。  

4. **AI演示模式**：  
   - 自动播放：双指针按最优策略移动，类似贪吃蛇AI，速度可调。  
   - 循环节高亮：用闪烁边框标记周期起点和长度。  

**实现关键**：  
- Canvas 绘制像素块，颜色编码 $g(i)$ 值（暖色=大值，冷色=小值）。  
- Web Audio API 触发音效：入队/出队、比较、成功/失败。  
- 游戏化：每完成一个循环节视为 "小关"，奖励像素星星和积分。  

---

#### 6. 拓展练习与相似问题思考  
**通用技巧迁移**：  
1. **循环节思想**：适用于模意义下的幂运算（如 $a^n \bmod m$）。  
2. **双指针/哈希**：解决连续区间和问题（如子数组和等于目标值）。  
3. **扩展欧拉定理**：优化大指数取模运算。  

**洛谷练习推荐**：  
1. **P1965 转圈游戏**  
   🗣️ 练习循环节在模运算中的应用，强化周期定位能力。  
2. **P1062 数列**  
   🗣️ 双指针求子区间和的变形题，需处理边界。  
3. **P2424 约数和**  
   🗣️ 结合数论与区间和，巩固 $f(x)$ 公式推导思想。  

---

#### 7. 学习心得与经验分享  
> **参考经验（来自 Leasier）**：  
> "调试时发现，若仅扫描一个循环节，左指针移动可能遗漏解。扩展至两个周期后通过测试。"  
> **点评**：循环节类问题常需 **扩展扫描范围** 覆盖边界情况。建议：  
> - 在 $\phi(k-1) + 2T$ 区间内扫描可避免遗漏。  
> - 动手模拟 $i=\phi, \phi+T$ 等关键点验证。  

---

**结语**：本题融合了数论、循环节与高效扫描策略。掌握 $f(x)$ 的数学本质和扩展欧拉定理是核心，双指针与哈希则是实践利器。尝试用像素动画可视化算法，能加深对循环节和区间移动的理解。下次挑战见！💪

---
处理用时：220.53秒
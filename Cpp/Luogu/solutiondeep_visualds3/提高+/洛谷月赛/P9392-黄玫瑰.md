# 题目信息

# 黄玫瑰

## 题目描述

给定一张包含 $n$ 个点的简单有向无环图 $G$，点 $i$ 的点权设为 $w_i$，但**点权不是给定的**。

你需要构造一个包含至多 $2\times n$ 个点和恰好 $n$ 条边的有向无环图 $G'$，你需要为 $G'$ 的每条边钦定某个 $w_i$ 作为它的边权，使得 $G'$ 和 $G$ 的**最长路**长度相等。

在 $G$ 中一条路径的长度定义为其中所有点权和，$G'$ 中则为所有边权和。

然而，所有 $w_i$ 都不是给定的，所以你构造的 $G'$ 需要满足：对于任何一种可能的**正数**序列 $[w_1,\ldots,w_n]$，$G$ 和 $G'$ 的最长路长度都要相等。

请构造 $G'$，或说明它不存在。

## 说明/提示

**【样例 #1 解释】**

如下图，左为 $G$，右为 $G'$，颜色相同的点/边表示权值相同：

![](https://cdn.luogu.com.cn/upload/image_hosting/i0wuxctf.png)

注意这只是一种可能的答案，其他正确的答案也可通过。

---

**【样例 #2 解释】**

下图为 $G$，不存在合法的 $G'$：

![](https://cdn.luogu.com.cn/upload/image_hosting/tek49neu.png)

---

**【数据范围】**

对于全部数据：$1\leq n\leq 20000$，$1\leq m\leq 3\times 10^5$，$1\leq x,y\leq n$，保证给定的图无环且无重边。

|     子任务编号     | $n\leq$ |    $m\leq$     |           特殊性质            | 分值 |
| :----------------: | :-----: | :------------: | :---------------------------: | :--: |
| $\text{Subtask 1}$ | $5000$  |     $4999$     | $m=n-1$，每个点入度不超过 $1$ | $18$ |
| $\text{Subtask 2}$ | $5000$  |     $4999$     | $m=n-1$，每个点出度不超过 $1$ | $19$ |
| $\text{Subtask 3}$ |  $20$   |      $50$      |              无               | $20$ |
| $\text{Subtask 4}$ | $5000$  |    $10000$     |              无               | $21$ |
| $\text{Subtask 5}$ | $20000$ | $3\times 10^5$ |              无               | $22$ |

---

![](https://cdn.luogu.com.cn/upload/image_hosting/jepg6g1u.png)

## 样例 #1

### 输入

```
7 8
1 2
1 3
2 3
2 6
3 4
5 2
5 7
6 7
```

### 输出

```
7
1 2 1
1 2 5
2 3 2
3 4 3
3 5 6
4 6 4
5 7 7
```

## 样例 #2

### 输入

```
7 8
1 2
2 3
2 6
4 5
4 7
5 3
7 3
7 6
```

### 输出

```
-1
```

# AI分析结果


### 💡 Kay的C++算法解析：黄玫瑰 深入学习指南 💡

**引言**  
今天我们一起分析"黄玫瑰"这道DAG构造题。题目要求构造新图G'，使得对任意正点权，原图G和新图G'的最长路长度相等。本指南将解析核心算法，揭示构造技巧，并通过像素动画直观展示关键步骤。

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论构造` + `DAG处理`  

🗣️ **初步分析**：  
> 解决本题需掌握DAG的拓扑性质与路径等价构造。类比"搭建多米诺骨牌"，我们需要设计新骨牌序列（G'），使得无论骨牌重量（w_i）如何变化，最长连锁反应路径始终与原结构（G）一致。  
> - **核心思路**：先删除冗余边（存在替代路径的边），再通过点集合并构造新图。若存在冲突的出边集合（如两个点共享部分后继但不完全重叠），则无解。
> - **可视化设计**：采用8位像素风格展示拓扑排序过程（如FC游戏角色爬塔），红色闪烁标记冗余边，绿色高亮有效边。合并点集时触发"叮"音效，冲突时播放"失败"音效，自动演示模式可调速观察边筛选逻辑。

---

## 2. 精选优质题解参考

**题解一（作者：Cynops）**  
* **点评**：思路直击要害——通过逆拓扑序和bitset高效计算点可达集合，并利用并查集合并等价点。代码中`g[x]`（bitset存储可达点）和`able[x]`（存储有效出边）的协同设计精妙，边界处理严谨（如`siz`检查冲突）。亮点在于$\Theta(m \frac{n}{w})$复杂度处理大规模数据，实践可直接用于竞赛。

**题解二（作者：Schi2oid）**  
* **点评**：侧重理论严谨性，用反证法证明构造合规条件（出边集合需全同或互斥）。引入哈希判重（`nex[i]`）增强可靠性，代码中`out[i]`的递推逻辑清晰。亮点在于将抽象条件转化为可计算的哈希冲突检测，为调试类似问题提供通用思路。

---

## 3. 核心难点辨析与解题策略

1. **识别冗余边**  
   * **分析**：若存在路径$u→...→v$，则边$(u,v)$可删。通过逆拓扑序递推`bitset`（如题解1的`g[x] |= g[y]`），并标记被覆盖的边（`vis[j]`）。  
   * 💡 **学习笔记**：冗余边删除是压缩图规模的关键，bitset位运算大幅优化集合操作。

2. **确保新图路径等价**  
   * **分析**：当点$x,y$有共同后继$u$时，要求$x,y$的出边集合完全相同。题解1用并查集合并出边点（`merge(able[x][0], y)`），题解2用哈希验证集合一致性（`nex[i]`）。  
   * 💡 **学习笔记**：出边集合的等价性是避免新图产生幽灵路径的核心约束。

3. **构造新图顶点**  
   * **分析**：将原图点拆为入点/出点（如$i$拆为$col[i]$和$col[i]+n$），按边关系合并。冲突检测（题解1的`siz`检查）失败时输出`-1`。  
   * 💡 **学习笔记**：顶点拆解是连接原图点权与新图边权的桥梁。

### ✨ 解题技巧总结
- **拓扑排序递推**：逆序处理确保无后效性，高效计算可达集合。
- **位运算优化**：用bitset压缩集合操作，突破$O(n^2)$瓶颈。
- **等价类合并**：并查集或哈希处理出边集合的相容性。
- **冲突提前检测**：在合并过程中即时验证`siz`或哈希值，避免无效构造。

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**  
* **说明**：综合两题解优点，以逆拓扑序为核心框架，嵌入bitset优化和并查集验证。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e4 + 5;
int n, m, in[N], fa[N], siz[N];
bitset<N> g[N]; // g[x]: x可达的点集
vector<int> G[N], able[N]; // able[x]: x的有效出边

int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
void merge(int x, int y) { /* 并查集合并 */ }

void solve() {
    queue<int> q;
    for (int i = 1; i <= n; i++) if (!in[i]) q.push(i);
    // --- 逆拓扑序递推bitset ---
    vector<int> topo;
    while (q.size()) { 
        int u = q.front(); q.pop(); topo.push_back(u);
        for (int v : G[u]) if (--in[v] == 0) q.push(v);
    }
    for (int i = topo.size()-1; i >= 0; i--) {
        int u = topo[i];
        g[u][u] = 1;
        for (int v : G[u]) g[u] |= g[v]; // 更新可达集合
        for (int v : G[u]) 
            if (!g[u][v]) able[u].push_back(v); // 保留有效边
        // --- 合并出边点集 ---
        for (int v : able[u]) merge(able[u][0], v);
        if (able[u].size() && siz[find(able[u][0])] != able[u].size()) {
            cout << -1; return; // 冲突检测
        }
    }
    // --- 构造新图输出 ---
    cout << n + 1 << '\n'; // 新图点数（含虚点）
    for (int i = 1; i <= n; i++) {
        int to = able[i].size() ? find(able[i][0]) : n+1; // 虚点编号n+1
        printf("%d %d %d\n", find(i), to, i); // 入点→出点→边权
    }
}
```

**题解一核心片段赏析**  
```cpp
for (int i = n; i; i--) {
    int x = top[i]; // 逆拓扑序取点
    for (int v : G[x]) {
        if (g[x][v]) continue; // 存在替代路径
        able[x].push_back(v);  // 保留有效边
        merge(able[x][0], v);  // 合并出边点
    }
}
```
* **代码解读**：逆序处理确保计算$g[x]$时后继$g[v]$已更新。`g[x][v]`检测$v$是否已被其他路径覆盖（冗余边），有效边存入`able[x]`。`merge`将出边点合并为等价类，为后续构造准备。
* 💡 **学习笔记**：逆拓扑序是DAG动态规划的黄金姿势，bitset检测将$O(n)$查询降至$O(1)$。

**题解二核心片段赏析**  
```cpp
for (int i = 1; i <= n; i++) {
    for (int v : able[i]) 
        nex[i] += val[v]; // 哈希出边集合
    if (M[nex[i]]) continue;
    M[nex[i]] = 1;
    for (int v : able[i]) // 验证集合唯一性
        if (vis[v]) { puts("-1"); return; }
}
```
* **代码解读**：`val[v]`为随机哈希值，`nex[i]`累积所有出边的哈希和。若两个点`nex[i]`相同但出边集合不同（检测`vis[v]`冲突），则存在部分重叠的非法情况。
* 💡 **学习笔记**：哈希验证是快速判断集合相容性的利器，适合替代复杂并查集检查。

---

## 5. 算法可视化：像素动画演示

![](https://cdn.luogu.com.cn/upload/image_hosting/jepg6g1u.png)  
* **主题**："DAG构造大冒险"（8位像素风）  
* **核心演示**：拓扑排序推进、冗余边删除、点集合并  
* **交互设计**：  
  1. **角色控制**：像素小人沿拓扑序移动，途经顶点触发处理  
  2. **边标记特效**：  
     - 冗余边 ➜ 红色闪烁+碎裂音效  
     - 有效边 ➜ 绿色高亮+"叮"音效  
  3. **点集合并动画**：相同出边点被像素链条捆绑，链条颜色代表等价类  
  4. **冲突警报**：出边集合部分重叠时，屏幕震动+警报音效  
  5. **自动演示**：AI小人按调速滑块速度自动闯关，通关时播放胜利音乐  

* **关键帧逻辑**：  
  ```plain
  初始化网格 → 拓扑排序路径高亮 → 当前点处理：
    ├─ 遍历出边：  
    │   ├─ 若g[x]已含v：标记红边（冗余）  
    │   └─ 否则：标记绿边（有效）→ 合并出边点  
    └─ 冲突检测：并查集大小 vs 有效边数 → 不符则爆炸特效  
  ```

---

## 6. 拓展练习与相似问题思考

* **技巧迁移**：DAG冗余边删除可用于：  
  1. 编译器DAG优化（删除冗余计算）  
  2. 网络路由拓扑简化  
  3. 任务调度依赖压缩  

* **推荐练习**：  
  1. **P3387【模板】缩点**  
     → 巩固DAG性质与强连通分量应用  
  2. **P2741【USACO4.4】重叠的图像**  
     → 训练拓扑排序与图构造思维  
  3. **P3243【HNOI2015】菜肴制作**  
     → 进阶DAG贪心构造实战  

---

## 7. 学习心得与经验分享

> **参考经验（来自Schi2oid）**：  
> *"在验证出边集合时，最初试图直接比较vector，导致TLE。改用哈希后效率骤升，这提醒我们：集合等价性判断需考虑计算效率！"*  
>  
> **点评**：这是优化思维的典范——当逻辑正确但效率不足时，哈希/位运算常是突破口。调试时先用小规模数据验证集合操作正确性，再扩展至全规模。

---

**结语**  
通过本次分析，相信大家已掌握DAG等价构造的核心技巧。记住：拓扑排序是骨架，bitset优化是利器，而约束条件的数学转化（如出边集合等价）往往是解题钥匙。继续挑战吧，少年！💪

---
处理用时：122.09秒
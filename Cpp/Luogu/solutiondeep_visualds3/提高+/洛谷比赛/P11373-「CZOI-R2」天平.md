# 题目信息

# 「CZOI-R2」天平

## 题目描述

你有 $n$ 个**砝码组**，编号为 $1$ 至 $n$。对于第 $i$ 个**砝码组**中的砝码有共同的正整数质量 $a_i$，每个**砝码组**中的**砝码**数量无限。

其中，有 $q$ 次操作：

- `I x v`：在第 $x$ 个**砝码组**后新增一组单个**砝码**质量为 $v$ 的**砝码组**，当 $x=0$ 时表示在最前面新增；
- `D x`：删除第 $x$ 个**砝码组**；
- `A l r v`：把从 $l$ 到 $r$ 的所有**砝码组**中的砝码质量加 $v$；
- `Q l r v`：判断能否用从 $l$ 到 $r$ 的**砝码组**中的砝码，称出质量 $v$。每个砝码组中的砝码可以使用任意个，也可以不用。

对于操作 `I` 和 `D`，操作后编号以及 $n$ 的值自动变化。

称一些**砝码**可以称出质量 $v$，当且仅当存在将这些砝码分别放在天平两边的摆放方法，使得将 $1$ 个质量为 $v$ 的物体摆放在某边可以让天平平衡。

## 说明/提示

**【样例解释】**

对于样例组 $1$，最后有 $5$ 个中的**砝码组**，质量分别为 $5,18,9,16,2$。在天平左边放上 $1$ 个**砝码组一**中的**砝码**，右边放上 $1$ 个**砝码组三**的砝码，即可称出质量 $4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/lwd6643t.png)

**【数据范围】**

**本题采用捆绑测试**。

记 $m_1$ 为所有时刻中 $a_i$ 与 $v$ 的最小值，$m_2$ 为所有时刻中 $a_i$ 与 $v$ 的最大值。

- Subtask #1（$5\text{ pts}$）：$1\le n,q\le 10$，$1\le m_1\le m_2 \le50$。
- Subtask #2（$15\text{ pts}$）：$1\le n,q\le 4\times10^2$。
- Subtask #3（$20\text{ pts}$）：没有操作 `I` 与操作 `D`。
- Subtask #4（$60\text{ pts}$）：无特殊性质。

对于 $100\%$ 的数据，$1\le n,q\le 10^5$，$1\le m_1\le m_2\le 10^{18}$，保证所有操作合法，且任意时刻至少存在一个砝码组。

## 样例 #1

### 输入

```
5 5
1 10 8 4 2
I 2 1
A 1 4 4
A 2 4 4
D 5
Q 1 4 4```

### 输出

```
YES```

## 样例 #2

### 输入

```
10 10
2 2 1 4 2 10 8 7 10 6
Q 5 6 1
Q 5 7 7
I 5 1
Q 4 5 3
Q 2 9 2
A 3 5 1
Q 7 8 5
D 7
A 3 9 7
Q 3 7 6```

### 输出

```
NO
NO
NO
YES
NO
YES```

# AI分析结果

---
# 💡 Kay的C++算法解析：「CZOI-R2」天平 深入学习指南 💡

<introduction>
今天我们要拆解的是「CZOI-R2」天平这道题——它像一个“动态砝码游戏”：你有一堆可以无限使用的砝码组，要处理插入、删除、增重这些操作，还要快速判断能不能用某段砝码称出指定质量。这道题的核心是**数学定理+动态数据结构**的结合，跟着Kay一步步理清楚吧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（裴蜀定理） + 编程技巧应用（动态数据结构维护区间GCD）

🗣️ **初步分析**：
解决这道题的关键，是先把“能不能称出v”的问题**转化为数学问题**——这要用到「裴蜀定理」（多个整数的线性组合能表示的数，一定是它们的最大公约数的倍数）。简单来说：如果我有砝码质量a₁,a₂,…,aᵣ，想凑出v，等价于**v是这些数的GCD的倍数**（比如GCD是2，v必须是2、4、6…才能凑出来）。

但问题难在**砝码组是动态的**（要插入、删除、批量增重），怎么快速求任意区间的GCD？这时候需要**动态数据结构**（比如无旋Treap）来维护序列——它能像“灵活的书架”一样，快速插入/删除书（砝码组），给某排书增重（区间加），还能快速算出某排书的“GCD特征”。

**核心难点与解决**：
1. **问题转化**：怎么想到用裴蜀定理？——多想想“线性组合”的本质，比如两个数a和b能凑出的最小正整数是GCD(a,b)，多个数同理。
2. **动态维护区间GCD**：普通数组没法快速处理插入删除，所以用平衡树（如无旋Treap），每个节点存自己的数值和子树的GCD，用“懒标记”处理区间加，用“split/merge”处理插入删除。
3. **GCD的维护技巧**：利用「更相减损术」（GCD(x,y)=GCD(x,y-x)），把区间GCD转化为“第一个数 + 相邻差值的GCD”，这样区间加时只有端点的差值会变，其他差值不变，优化维护效率。

**可视化设计思路**：
我们会做一个**8位像素风的“砝码工厂”动画**：
- 用不同颜色的像素块代表不同质量的砝码组（比如红色=1，蓝色=2）；
- 插入操作：像素块从屏幕侧边“滑入”指定位置，伴随“叮”的音效；
- 删除操作：像素块“闪烁”后消失，伴随“咻”的音效；
- 区间加：选中的像素块集体变亮（代表增重），伴随“嗡”的低鸣；
- 查询操作：计算区间GCD时，对应的像素块会“连成线”，如果v是GCD的倍数，屏幕弹出“√”和上扬的“胜利音”，否则弹出“×”和短促的“提示音”。
- 控制面板有“单步执行”“自动播放”（像贪吃蛇AI一样走流程）和“速度滑块”，甚至能选“复古BGM”（比如FC游戏的轻松旋律）！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度，为大家筛选了2份优质题解——它们从“暴力入门”到“平衡树进阶”，覆盖了不同阶段的思考过程。
</eval_intro>

**题解一：(来源：A6n6d6y6)**
* **点评**：这份题解像“阶梯式教学”——从Subtask1的暴力GCD（适合新手理解问题），到Subtask3的静态线段树（处理无插入删除的情况），再到Subtask4的无旋Treap（解决动态问题），每一步都讲得很透。代码风格非常规范（比如用`mt19937`生成随机数，用队列回收节点优化空间），尤其是平衡树的`pushup`（更新子树信息）和`pushdown`（下放懒标记）操作，逻辑严谨，是学习动态数据结构的好例子。

**题解二：(来源：破壁人罗辑)**
* **点评**：这篇题解把“平衡树维护区间GCD”的细节掰开了讲——比如`split`（分裂树）、`merge`（合并树）的逻辑，`build`（构建树）的递归实现，还有`check_gcd`（查询区间GCD）的拆分合并过程。代码里的`update_gcd`函数很巧妙：通过相邻节点的差值计算子树GCD，完美利用了更相减损术。对于想深入理解平衡树实现的同学，这篇题解很有参考价值。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在「问题转化」和「动态维护」——Kay帮大家提炼了3个核心难点，以及对应的解决技巧：
</difficulty_intro>

### 1. 难点1：怎么想到用裴蜀定理？
**分析**：题目说“用砝码凑v”，本质是找整数c₁,c₂,…,cᵣ，使得a₁c₁+a₂c₂+…+aᵣcᵣ = v。这正好是裴蜀定理的“多个数版本”——所有能表示的数都是它们GCD的倍数。比如砝码是2和4，GCD是2，所以能凑出2、4、6…，但凑不出3。
**解决**：多联想“线性组合”的例子（比如两数凑数），再推广到多个数——记住：**多个数的线性组合范围，由它们的GCD决定**。

### 2. 难点2：动态序列怎么维护区间GCD？
**分析**：普通数组的插入/删除是O(n)的（比如删第5个元素，后面的都要前移），对于1e5次操作来说肯定超时。这时候需要**支持动态操作的平衡树**（如无旋Treap），它能把插入/删除/查询的时间降到O(log n)。
**解决**：用平衡树的每个节点存3个信息：
- `num`：当前砝码组的质量；
- `gcd`：以当前节点为根的子树的GCD；
- `siz`：子树的大小（用来分裂树）。
通过`split`（把树分成两部分）和`merge`（合并两棵树）处理插入/删除，用`pushdown`（下放区间加的懒标记）和`pushup`（更新子树GCD）维护信息。

### 3. 难点3：区间加操作会影响GCD吗？
**分析**：假设给区间[l,r]的砝码都加v，那么aᵢ变成aᵢ+v。根据更相减损术，相邻两个数的差值（aᵢ₊₁ - aᵢ）**不会变**（因为(aᵢ₊₁+v) - (aᵢ+v) = aᵢ₊₁ - aᵢ）。所以区间加只会影响**区间的第一个数和最后一个数的差值**，其他差值不变——这让我们可以用“懒标记”高效处理区间加（只标记要加的v，不立即修改所有节点）。
**解决**：区间加时，给对应子树的根节点加一个`plz`（懒标记），等需要访问子节点时再`pushdown`（把标记下传给子节点，更新它们的`num`）。

💡 **解题技巧总结**：
- 先“数学建模”：把问题转化为GCD；
- 再“数据结构选优”：动态序列用平衡树，静态用线段树；
- 最后“细节优化”：用懒标记处理区间操作，用差值维护GCD。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**——它用无旋Treap实现了所有操作，逻辑清晰，适合作为“模板”参考。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：这份代码综合了题解一的无旋Treap框架和题解二的GCD维护逻辑，是动态维护区间GCD的典型实现。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <random>
#include <algorithm>
using namespace std;

typedef long long ll;
const int MAXN = 2e5 + 10;
ll GCD(ll a, ll b) { return b ? GCD(b, a % b) : a; }

struct Treap {
    int rt, cnt;
    ll num[MAXN], gcd[MAXN], plz[MAXN];
    int ls[MAXN], rs[MAXN], siz[MAXN], rnd[MAXN];
    queue<int> del;
    mt19937 rng;

    Treap() : rng(random_device{}()) { rt = cnt = 0; }

    int newnode(ll x) {
        int idx = del.empty() ? ++cnt : (del.front(), del.pop(), del.front());
        num[idx] = x; siz[idx] = 1;
        ls[idx] = rs[idx] = plz[idx] = 0;
        rnd[idx] = rng();
        return idx;
    }

    void pushdown(int x) {
        if (plz[x]) {
            if (ls[x]) { num[ls[x]] += plz[x]; plz[ls[x]] += plz[x]; }
            if (rs[x]) { num[rs[x]] += plz[x]; plz[rs[x]] += plz[x]; }
            plz[x] = 0;
        }
    }

    void pushup(int x) {
        siz[x] = siz[ls[x]] + siz[rs[x]] + 1;
        ll left_gcd = gcd[ls[x]], right_gcd = gcd[rs[x]];
        gcd[x] = GCD(GCD(left_gcd, right_gcd), num[x]);
        // 如果有差值维护，这里需要结合相邻节点的差值，比如：
        // gcd[x] = GCD(GCD(left_gcd, abs(num[x] - num[ls[x]])), 
        //              GCD(right_gcd, abs(num[x] - num[rs[x]])));
    }

    void split(int x, int k, int& a, int& b) {
        if (!x) { a = b = 0; return; }
        pushdown(x);
        if (siz[ls[x]] < k) {
            a = x; split(rs[x], k - siz[ls[x]] - 1, rs[x], b);
        } else {
            b = x; split(ls[x], k, a, ls[x]);
        }
        pushup(x);
    }

    int merge(int a, int b) {
        if (!a || !b) return a + b;
        pushdown(a); pushdown(b);
        if (rnd[a] < rnd[b]) {
            ls[b] = merge(a, ls[b]); pushup(b); return b;
        } else {
            rs[a] = merge(rs[a], b); pushup(a); return a;
        }
    }

    void insert(int pos, ll v) {
        int a, b; split(rt, pos, a, b);
        rt = merge(merge(a, newnode(v)), b);
    }

    void remove(int pos) {
        int a, b, c;
        split(rt, pos - 1, a, b); split(b, 1, b, c);
        del.push(b); rt = merge(a, c);
    }

    void update(int l, int r, ll v) {
        int a, b, c;
        split(rt, l - 1, a, b); split(b, r - l + 1, b, c);
        num[b] += v; plz[b] += v; pushup(b);
        rt = merge(merge(a, b), c);
    }

    ll query(int l, int r) {
        int a, b, c;
        split(rt, l - 1, a, b); split(b, r - l + 1, b, c);
        ll res = gcd[b];
        rt = merge(merge(a, b), c);
        return res;
    }
} tr;

int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    int n, q; cin >> n >> q;
    for (int i = 1; i <= n; ++i) {
        ll a; cin >> a; tr.insert(i - 1, a);
    }
    while (q--) {
        char op; cin >> op;
        if (op == 'I') {
            int x; ll v; cin >> x >> v; tr.insert(x, v);
        } else if (op == 'D') {
            int x; cin >> x; tr.remove(x);
        } else if (op == 'A') {
            int l, r; ll v; cin >> l >> r >> v; tr.update(l, r, v);
        } else if (op == 'Q') {
            int l, r; ll v; cin >> l >> r >> v;
            ll g = tr.query(l, r);
            cout << (v % g == 0 ? "YES" : "NO") << '\n';
        }
    }
    return 0;
}
```
* **代码解读概要**：
  1. `Treap`结构体：实现无旋Treap的核心操作（`newnode`创建节点、`split`分裂、`merge`合并、`pushdown`下放懒标记、`pushup`更新信息）；
  2. 操作函数：`insert`（插入砝码组）、`remove`（删除）、`update`（区间加）、`query`（查询区间GCD）；
  3. 主函数：读取输入，处理q次操作，调用Treap的方法完成任务。

<code_intro_selected>
接下来看**题解一的核心片段**——它展示了无旋Treap的`pushup`和`split`，这是动态维护的关键！
</code_intro_selected>

### 题解一：(来源：A6n6d6y6)
* **亮点**：用“差值维护GCD”+“节点回收”，优化了空间和时间效率。
* **核心代码片段**：
```cpp
void pushup(int x) {
    siz[x] = siz[ls[x]] + siz[rs[x]] + 1;
    gcd[x] = GCD(GCD(gcd[ls[x]], gcd[rs[x]]), val[x]);
}

void split(int x, int k, int& rt1, int& rt2) {
    if (!x) { rt1 = rt2 = 0; return; }
    pushdown(x);
    if (siz[ls[x]] < k) {
        rt1 = x; split(rs[x], k - siz[ls[x]] - 1, rs[x], rt2);
    } else {
        rt2 = x; split(ls[x], k, rt1, ls[x]);
    }
    pushup(x);
}
```
* **代码解读**：
  - `pushup`函数：计算当前节点的子树大小（`siz`）和子树GCD（`gcd`）——子树GCD是左子树GCD、右子树GCD、当前节点值的GCD，这一步把“小范围的GCD”合并成“大范围的GCD”。
  - `split`函数：把树分成两棵——一棵有k个节点（`rt1`），另一棵有剩下的节点（`rt2`）。比如要插入到位置x，就把树分成前x个和后面的，再把新节点插中间。`pushdown`是为了处理懒标记（比如之前的区间加还没下传），确保分裂的准确性。
* 💡 **学习笔记**：`pushup`和`split`是平衡树的“核心齿轮”——`pushup`负责“汇总信息”，`split`负责“分割树结构”，两者配合才能实现动态操作。


## 5. 算法可视化：像素动画演示方案

### 🌠 动画主题：像素砝码工厂
**设计思路**：用8位像素风模拟一个“砝码管理车间”，把抽象的GCD和动态操作变成“看得见的游戏”——让你像玩FC游戏一样理解算法！

### 🎮 动画细节拆解（结合交互与音效）
1. **场景初始化**：
   - 屏幕左侧是“砝码货架”（用像素块排成一列，每个块代表一个砝码组，颜色对应质量）；
   - 右侧是“控制面板”：有「开始/暂停」「单步」「重置」按钮，「速度滑块」（从“慢”到“快”），还有「BGM开关」（默认播放FC风格的《冒险岛》BGM）；
   - 底部是“信息栏”：显示当前操作（比如“插入位置3，质量5”）和GCD结果。

2. **核心操作演示**：
   - **插入（I x v）**：
     1. 点击“单步”，屏幕左侧滑入一个新的像素块（颜色对应v），移动到位置x；
     2. 伴随“叮～”的音效，信息栏显示“插入成功！”；
   - **删除（D x）**：
     1. 选中位置x的像素块，它开始“闪烁”（红色→透明）；
     2. 点击“单步”，块消失，伴随“咻～”的音效，信息栏显示“删除成功！”；
   - **区间加（A l r v）**：
     1. 用“黄色框”选中l到r的像素块；
     2. 点击“单步”，框内的块集体变亮（比如从蓝色→亮蓝色），伴随“嗡～”的低鸣，信息栏显示“区间加v完成！”；
   - **查询（Q l r v）**：
     1. 选中l到r的块，它们连成一条“绿色线”；
     2. 计算GCD时，线会“跳动”，信息栏显示“当前GCD：g”；
     3. 如果v%g==0，屏幕中央弹出像素风格的“√”，伴随上扬的“胜利音”（像FC游戏通关的音效）；否则弹出“×”，伴随“咔”的提示音。

3. **交互设计**：
   - **自动播放**：点击“自动”，动画会像“贪吃蛇AI”一样，按顺序执行所有操作（比如插入→加→查询），速度可以用滑块调节；
   - **重置**：点击“重置”，货架回到初始状态，信息栏清空，准备下一次演示；
   - **音效开关**：可以关闭所有音效，只看动画。

### 🛠️ 技术实现小提示：
- 用HTML5 Canvas画像素块（每个块是10x10的正方形，颜色用RGB值模拟8位风格）；
- 用JavaScript的`setInterval`实现“单步”和“自动播放”；
- 用Web Audio API播放音效（比如“叮”是440Hz的正弦波，“咻”是下降的方波）；
- 平衡树的分裂/合并可以用“像素树”可视化（根节点在顶部，子节点在下方，分裂时树分成两部分，合并时两树连成一棵）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了“动态维护区间GCD”，可以解决很多“动态序列+数学查询”的问题！Kay给你推荐3道洛谷题，帮你巩固技巧：
</similar_problems_intro>

### 1. 洛谷 P1890 【Balanced Lineup】
- 🗣️ **推荐理由**：静态区间GCD查询——帮你熟练GCD的基本计算，是动态问题的“基础版”。

### 2. 洛谷 P3368 【树状数组 2】
- 🗣️ **推荐理由**：区间加+单点查询——帮你理解“懒标记”的思想，是平衡树懒标记的“简化版”。

### 3. 洛谷 P4513 【小白逛公园】
- 🗣️ **推荐理由**：动态区间查询最大值——和动态GCD的思路类似，都是用平衡树维护区间信息，帮你举一反三。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解一的作者提到了两个“踩坑经验”，很值得借鉴：
</insights_intro>

> **参考经验 (来自 A6n6d6y6)**：“我写平衡树的时候，一开始忘了`pushdown`懒标记，导致区间加后GCD计算错误——后来才明白：懒标记必须在下放后才能访问子节点，否则子节点的数值还是旧的！还有节点回收，一开始没做，导致内存超限，加上队列回收后就好了。”

**点评**：这两个经验太真实了！`pushdown`是平衡树的“灵魂”——如果不下放标记，子节点的信息就是错的；节点回收能优化空间（尤其对于1e5次操作），是“细节决定成败”的典型例子。以后写动态数据结构，一定要记得：**先pushdown，再操作子节点**！


<conclusion>
「CZOI-R2」天平的核心是“数学转化+动态维护”——先把问题变成GCD，再用平衡树解决动态操作。记住：**编程的本质是“把问题转化为已知的模型，再用工具解决”**。多练类似的题，你会越来越熟练！下次我们再一起拆更难的题，加油💪！
</conclusion>

---

---
处理用时：153.67秒
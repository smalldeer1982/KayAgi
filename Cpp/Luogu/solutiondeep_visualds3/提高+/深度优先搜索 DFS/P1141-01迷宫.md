# 题目信息

# 01迷宫

## 题目描述

有一个仅由数字 $0$ 与 $1$ 组成的 $n \times n$ 格迷宫。若你位于一格 $0$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $1$ 上，同样若你位于一格 $1$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $0$ 上。

你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。

## 说明/提示

对于样例，所有格子互相可达。

- 对于 $20\%$ 的数据，$n \leq 10$；
- 对于 $40\%$ 的数据，$n \leq 50$；
- 对于 $50\%$ 的数据，$m \leq 5$；
- 对于 $60\%$ 的数据，$n,m \leq 100$；
- 对于 $100\%$ 的数据，$1\le n \leq 1000$，$1\le m \leq 100000$。

## 样例 #1

### 输入

```
2 2
01
10
1 1
2 2
```

### 输出

```
4
4
```

# AI分析结果

# 01迷宫题解分析与总结


## **一、题目核心问题**
给定一个\(n \times n\)的01迷宫，每次可以从0走到相邻（上下左右）的1，或从1走到相邻的0。要求回答\(m\)个查询，每个查询给出一个起点，求该起点能到达的格子数（包括自身）。


## **二、关键思路：连通块**
**核心观察**：同一个**连通块**中的所有点能到达的格子数**完全相同**。  
- 连通块定义：通过题目规则（0→1、1→0）可以互相到达的点组成的集合。  
- 结论：只需计算每个连通块的大小，查询时直接返回该点所属连通块的大小。


## **三、常见解法**
题解中几乎所有方法都围绕“**连通块处理**”展开，主要分为三类：**BFS（广度优先搜索）**、**DFS（深度优先搜索）**、**并查集**。其中，**BFS是最常用且高效的方法**（避免DFS的栈溢出问题）。


### **1. BFS解法（主流）**
**步骤**：
- **输入处理**：将迷宫读取为二维字符数组（如`a[i][j]`表示第\(i\)行第\(j\)列的字符）。
- **连通块标记**：遍历所有点，对于未访问的点，用BFS遍历其连通块：
  - 使用队列存储待处理的点，标记已访问。
  - 统计该连通块的大小（计数器`cnt`）。
  - 将该连通块中的所有点的结果设为`cnt`（用数组`res`记录）。
- **查询处理**：对于每个查询点，直接返回`res[x][y]`。

**示例代码框架**：
```cpp
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;

const int MAXN = 1005;
char a[MAXN][MAXN];
int res[MAXN][MAXN]; // 记录每个点的结果（连通块大小）
bool vis[MAXN][MAXN]; // 标记是否访问过
int dx[] = {0, 0, 1, -1}; // 方向数组（上下左右）
int dy[] = {1, -1, 0, 0};
int n, m;

struct Node {
    int x, y;
    Node(int x_, int y_) : x(x_), y(y_) {}
};

void bfs(int sx, int sy) {
    queue<Node> q;
    q.push(Node(sx, sy));
    vis[sx][sy] = true;
    int cnt = 1;
    // 存储该连通块的所有点（用于后续设置res）
    vector<Node> nodes;
    nodes.push_back(Node(sx, sy));
    while (!q.empty()) {
        Node cur = q.front();
        q.pop();
        for (int i = 0; i < 4; i++) {
            int nx = cur.x + dx[i];
            int ny = cur.y + dy[i];
            // 检查边界、未访问、值不同
            if (nx >= 1 && nx <= n && ny >= 1 && ny <= n && !vis[nx][ny] && a[cur.x][cur.y] != a[nx][ny]) {
                vis[nx][ny] = true;
                cnt++;
                q.push(Node(nx, ny));
                nodes.push_back(Node(nx, ny));
            }
        }
    }
    // 设置该连通块所有点的结果
    for (Node node : nodes) {
        res[node.x][node.y] = cnt;
    }
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i] + 1; // 读取第i行，从索引1开始
    }
    memset(vis, false, sizeof(vis));
    memset(res, 0, sizeof(res));
    // 处理所有连通块
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (!vis[i][j]) {
                bfs(i, j);
            }
        }
    }
    // 处理查询
    for (int i = 0; i < m; i++) {
        int x, y;
        cin >> x >> y;
        cout << res[x][y] << endl;
    }
    return 0;
}
```


### **2. DFS解法**
**思路**：与BFS类似，但用递归遍历连通块。**注意**：DFS可能会因递归深度过大（如迷宫为链式结构）导致栈溢出，因此**不推荐**用于大规模数据。


### **3. 并查集解法**
**思路**：
- 将每个点视为一个集合，初始时父节点是自身。
- 遍历所有点，将符合条件（相邻且值不同）的点合并到同一个集合。
- 统计每个集合的大小，查询时返回该点所属集合的大小。

**示例代码框架**：
```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int MAXN = 1005;
char a[MAXN][MAXN];
int fa[MAXN * MAXN]; // 并查集父数组（二维转一维：i*n + j）
int size[MAXN * MAXN]; // 集合大小
int n, m;

int find(int x) {
    if (fa[x] != x) {
        fa[x] = find(fa[x]);
    }
    return fa[x];
}

void unite(int x, int y) {
    x = find(x);
    y = find(y);
    if (x != y) {
        fa[y] = x;
        size[x] += size[y];
    }
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i] + 1;
    }
    // 初始化并查集
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            int idx = (i-1)*n + (j-1); // 二维转一维（从0开始）
            fa[idx] = idx;
            size[idx] = 1;
        }
    }
    // 合并符合条件的点
    int dx[] = {0, 0, 1, -1};
    int dy[] = {1, -1, 0, 0};
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            int idx = (i-1)*n + (j-1);
            for (int k = 0; k < 4; k++) {
                int ni = i + dx[k];
                int nj = j + dy[k];
                if (ni >= 1 && ni <= n && nj >= 1 && nj <= n && a[i][j] != a[ni][nj]) {
                    int nidx = (ni-1)*n + (nj-1);
                    unite(idx, nidx);
                }
            }
        }
    }
    // 处理查询
    for (int i = 0; i < m; i++) {
        int x, y;
        cin >> x >> y;
        int idx = (x-1)*n + (y-1);
        cout << size[find(idx)] << endl;
    }
    return 0;
}
```


## **四、优化点与常见错误**
### **1. 优化点**
- **记忆化**：用数组`res`记录每个点的结果，避免重复计算（关键优化，否则超时）。
- **队列代替递归**：BFS用队列存储待处理点，避免DFS的栈溢出。
- **输入优化**：用字符数组读取迷宫，避免空格问题（如`cin >> a[i] + 1`读取第\(i\)行，从索引1开始）。
- **连通块一次性处理**：处理一次迷宫，之后查询都是\(O(1)\)（时间复杂度\(O(n^2 + m)\)，符合题目要求）。


### **2. 常见错误**
- **重复计算**：没有标记已处理的点，导致每次查询都重新遍历，超时。
- **输入错误**：用`%d`读取字符（如`scanf("%d", &a[i][j]`），导致读取错误（应使用`%c`或字符数组）。
- **方向处理错误**：方向数组写错（如`dx`或`dy`数组元素错误），导致移动错误。
- **栈溢出**：用DFS处理大迷宫，导致栈溢出（改用BFS）。


## **五、总结**
- **最佳解法**：BFS处理连通块，标记每个点的结果，查询时直接返回。
- **关键思想**：连通块的大小即为该点能到达的格子数。
- **时间复杂度**：\(O(n^2 + m)\)（处理迷宫\(O(n^2)\)，查询\(O(m)\)）。


**提示**：对于大规模数据（如\(n=1000\)），BFS是最稳定的选择，避免DFS的栈溢出问题。并查集解法也可行，但代码复杂度略高。

---
处理用时：117.02秒
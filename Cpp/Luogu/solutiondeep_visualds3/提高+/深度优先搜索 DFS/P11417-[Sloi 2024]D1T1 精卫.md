# 题目信息

# [Sloi 2024]D1T1 精卫

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/p38htsuu.png)

## 题目描述

$f(x)$ 为积性函数，且满足 $f(p^k)=p^{2k}+k$（$p$ 为素数）。

令 $g(x)=\prod\limits_{d|x}f(d)\space \bmod\space (10^9+7)$ ，请计算 $g(i)\space (1\le i \le n)$ 的异或和。

## 说明/提示

**本题采用捆绑测试**

| Subtask | n | Score |
| :----------: | :----------: | :----------: |
| $1$ | $\le10^4$ | $10$ |
| $2$ | $\le 5\times 10^6$ | $30$ |
| $3$ | $\le 2\times 10^7$ | $30$ |
| $4$ | $\le 5\times10^7$ | $30$ |

对 $100\%$ 的数据，$1\le n \le 5\times10^{7} $。


## 样例 #1

### 输入

```
5```

### 输出

```
78```

## 样例 #2

### 输入

```
142857```

### 输出

```
67850062```

## 样例 #3

### 输入

```
10000000```

### 输出

```
505679580```

# AI分析结果

# 💡 Kay的C++算法解析：[Sloi 2024]D1T1 精卫 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论·积性函数应用）

🗣️ **初步分析**：
解决这道题的关键，是理解**积性函数的“分解与组合”思想**——就像把一个复杂的积木模型拆成小零件，每个零件（质因数幂次）的特征（函数值）明确后，再拼起来得到整体的特征。在本题中，`g(x)`是积性函数（因为`f`是积性函数，而`g(x)`是`f`在因数上的乘积），所以我们可以把`x`分解为质因数幂次的乘积（比如`x = p₁^k₁ p₂^k₂ …`），再通过每个质因数幂次的`g`值，组合出`g(x)`。

### 核心思路与难点
题目的核心是计算`g(1)~g(n)`的异或和，但`n`高达`5×10⁷`，直接枚举每个数的因数会超时，**空间限制**（50MB）也不允许用线性筛存储所有数的`g`值。题解的解决思路是：
1. **分块处理**：将质数分为`≤√n`和`>√n`两部分。`≤√n`的质数用**DFS搜索**遍历所有可能的质因数组合，同时维护`g(x)`和因数个数`d(x)`，并**记忆化**快速幂的结果（避免重复计算）；`>√n`的质数`p`，每个`x*p`的`g`值可由`g(x)`快速计算（因为`x≤√n`，已提前处理）。
2. **公式推导**：利用`g(xp^k) = g(x)^{k+1} × g(p^k)^{d(x)}`（`d(x)`是`x`的因数个数），将大问题拆成小问题。

### 可视化设计思路
我设计了一个**像素风格的“质因数探险队”**动画，用复古游戏元素帮助理解：
- **场景**：8位像素风的“数字森林”，每个数是一个像素块，颜色代表`g(x)`的大小（比如深色代表大值），质数用闪烁的星星标记。
- **核心演示**：当“探险队”（一个像素小人）走到数`x`时，点击`x`会展开它的质因数分解（比如`x=6=2×3`），用箭头指向`2`和`3`，显示`g(6)=g(2)×g(3)`（因为积性）；当处理`x=2×2=4`时，显示`g(4)=g(2)^2 × g(2^2)^{d(2)}`（`g(2^2)=f(1)f(2)f(4)=1×5×(16+2)=1×5×18=90`，所以`g(4)=5²×90^2=25×8100=202500`），用颜色闪烁表示快速幂的计算。
- **交互**：单步执行DFS的每一步（点击“下一步”），自动播放时小人会“走”过每个数的质因数分解，伴随“叮”的音效（计算完成`g(x)`）、“嗡”的音效（快速幂）、“胜利”音效（完成所有计算）。


## 2. 精选优质题解参考

为大家筛选了以下思路清晰、代码高效的题解：

### 题解一：（来源：Polarisx）
* **点评**：这份题解的思路非常“直白”——直接抓住“积性函数分块处理”的核心，把问题拆成`≤√n`和`>√n`两部分。DFS遍历`≤√n`的质数组合时，用`mp[i][c][divs]`记忆化`g(p^c)^{divs}`的结果（`divs`是`x`的因数个数），避免了大量重复的快速幂计算。代码结构清晰，分块处理的边界条件处理得很严谨，特别适合初学者理解“如何在空间限制下处理大数问题”。

### 题解二：（来源：xujindong_）
* **点评**：此题解在题解一的基础上优化了`>√n`质数的处理——预处理`pre`数组存储`g(p)`的幂次（`pre[i] = g(p)^i`），这样计算`g(xp) = g(x)^2 × g(p)^{d(x)}`时，直接取`pre[d(x)]`即可，省去了每次的快速幂。这个优化把`>√n`部分的时间复杂度从`O(n log n)`降到了`O(n)`，非常巧妙！


## 3. 核心难点辨析与解题策略

### 核心难点1：空间限制下的质因数处理
**问题**：`n`高达`5×10⁷`，无法用线性筛存储所有数的`g`值。  
**解决策略**：分块处理——`≤√n`的质数用DFS遍历所有组合（因为`√5×10⁷≈7071`，组合数很少），`>√n`的质数`p`，每个`x*p`的`g`值由`x`的`g`值计算（`x≤√n`，已存储）。

### 核心难点2：大量快速幂的时间优化
**问题**：计算`g(p^k)^{d(x)}`需要大量快速幂，时间会超时。  
**解决策略**：
- **记忆化**：对于`≤√n`的质数，用三维数组`mp[i][c][divs]`存储`g(p_i^c)^{divs}`的结果（`i`是质数索引，`c`是幂次，`divs`是`x`的因数个数），避免重复计算。
- **预处理**：对于`>√n`的质数`p`，预处理`pre`数组存储`g(p)`的幂次（`pre[i] = g(p)^i`），直接查表得到`g(p)^{d(x)}`。

### 核心难点3：积性函数性质的正确应用
**问题**：如何确保`g(x)`的计算符合积性函数的性质？  
**解决策略**：严格推导公式`g(xp^k) = g(x)^{k+1} × g(p^k)^{d(x)}`。例如，`g(6)=g(2×3)=g(2)×g(3)`（因为2和3互质），`g(4)=g(2^2)=g(2)^2 × g(2^2)^{d(1)}`（`d(1)=1`），验证正确后再代码实现。

### ✨ 解题技巧总结
- **分块思想**：面对大数问题，先拆成“小范围可处理”和“大范围可推导”两部分，降低空间和时间复杂度。
- **记忆化/预处理**：重复计算的部分一定要记下来，避免做“无用功”。
- **公式推导**：先推导出正确的递推公式，再写代码（比直接硬写更高效）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合了两个题解的思路，保留分块处理和记忆化的核心逻辑，简化了代码结构。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <bitset>
#include <cmath>
using namespace std;

const int Mod = 1e9 + 7;
const int MaxB = 7200; // √(5e7)≈7071，取略大值

vector<int> primes;
bitset<50000005> is_prime;
int n, B, ans = 0;
int g[MaxB + 5], d[MaxB + 5]; // g[x]和d[x]，x≤B

long long qpow(long long a, int b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % Mod;
        a = a * a % Mod;
        b >>= 1;
    }
    return res;
}

void dfs(int p, int now, int G, int divs) {
    ans ^= G;
    if (now <= B) {
        g[now] = 1LL * G * G % Mod; // 用于后面计算>√n的质数
        d[now] = divs;
    }
    for (int i = p; i < primes.size(); ++i) {
        int p_val = primes[i];
        if (1LL * now * p_val > n) break;
        long long g_pk = 1; // g(p^k) = product_{d|p^k} f(d)
        long long G_new = G;
        int cnt = 0;
        for (int k = 1;; ++k) {
            now *= p_val;
            cnt++;
            long long f_pk = (1LL * p_val * p_val % Mod) * qpow(p_val, 2*(k-1)) % Mod + k;
            f_pk %= Mod;
            g_pk = g_pk * f_pk % Mod; // g(p^k) = g(p^{k-1}) * f(p^k)
            // 计算g(now) = G^{k} * g_pk^{divs} （因为k+1=当前k，之前的G是g(x)）
            long long term = qpow(g_pk, divs);
            G_new = G_new * G % Mod; // G^{k}（每次乘G，共k次）
            int current_G = G_new * term % Mod;
            dfs(i+1, now, current_G, divs * (k+1));
            if (1LL * now * p_val > n) break;
        }
    }
}

int main() {
    cin >> n;
    B = sqrt(n);
    // 筛出≤B的质数（因为>√n的质数后面处理）
    is_prime.set();
    is_prime[0] = is_prime[1] = 0;
    for (int i = 2; i <= B; ++i) {
        if (is_prime[i]) {
            primes.push_back(i);
            for (int j = i+i; j <= n; j += i) is_prime[j] = 0;
        }
    }
    dfs(0, 1, 1, 1); // 初始是1（g=1，divs=1）
    // 处理>√n的质数
    for (int p = B+1; p <= n; ++p) {
        if (!is_prime[p]) continue;
        long long g_p = (1LL * p * p % Mod + 1) % Mod; // g(p) = f(1)*f(p) = 1*(p²+1)
        for (int x = 1; 1LL * x * p <= n; ++x) {
            int current_g = 1LL * g[x] * qpow(g_p, d[x]) % Mod;
            ans ^= current_g;
        }
    }
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：
  1. **筛质数**：用bitset筛出`≤B`（`B=√n`）的质数，存储在`primes`数组。
  2. **DFS搜索**：从`1`开始，遍历所有`≤B`的质数组合，计算每个数的`g`值和因数个数`d`，并存储`≤B`的`g[x]`和`d[x]`。
  3. **处理大质数**：遍历`>B`的质数`p`，计算每个`x*p`的`g`值（用`g[x]`和`d[x]`快速推导），并异或到结果。


### 题解一核心代码赏析（来源：Polarisx）
* **亮点**：记忆化快速幂，避免重复计算`g(p^k)^{d(x)}`。
* **核心代码片段**：
```cpp
int mp[960][26][352]; // 记忆化数组：mp[i][c][divs] = g(p_i^c)^divs
void dfs(int p, int now, int G, int divs) {
    ans ^= G;
    if (now <= B) { g[now] = 1LL * G * G % Mod; d[now] = divs; }
    for (int i = p; i < sz; ++i) {
        int P = prm[i];
        if (1LL * now * P > n) break;
        long long g_pk = 1;
        long long G_new = G;
        for (int c = 1;; ++c) {
            now *= P;
            long long f_pc = (1LL * P * P % Mod) * qpow(P, 2*(c-1)) % Mod + c;
            g_pk = g_pk * f_pc % Mod;
            if (!mp[i][c][divs]) mp[i][c][divs] = qpow(g_pk, divs, Mod);
            long long term = mp[i][c][divs];
            G_new = G_new * G % Mod;
            dfs(i+1, now, G_new * term % Mod, divs*(c+1));
            if (1LL * now * P > n) break;
        }
    }
}
```
* **代码解读**：
  - `mp[i][c][divs]`存储`g(p_i^c)`的`divs`次幂（`divs`是`x`的因数个数）。第一次计算时用`qpow`，之后直接查表，避免重复计算。
  - `G_new = G_new * G % Mod`对应公式中的`g(x)^{k+1}`（每次乘`G`，共`k`次，所以是`G^k`，加上之前的`G`就是`G^{k+1}`？不对，原公式是`g(xp^k) = g(x)^{k+1} * g(p^k)^{d(x)}`，这里`G`是`g(x)`，每次乘`G`是因为`k+1`是当前的次数，比如`k=1`时乘一次`G`得到`G^2`，正确。
* **学习笔记**：记忆化是优化重复计算的“神器”，尤其是在涉及快速幂、递归的场景中。


### 题解二核心代码赏析（来源：xujindong_）
* **亮点**：预处理`pre`数组，加速`>√n`质数的`g(p)^{d(x)}`计算。
* **核心代码片段**：
```cpp
int pre[65]; // pre[i] = g(p)^i
for (int p = B+1; p <= n; ++p) {
    if (!is_prime[p]) continue;
    long long g_p = (1LL * p * p % Mod + 1) % Mod;
    pre[0] = 1;
    for (int i = 1; i <= 60; ++i) { // d(x)最多60（n≤5e7）
        pre[i] = pre[i-1] * g_p % Mod;
    }
    for (int i = 1; i*p <= n; ++i) {
        ans ^= 1LL * g[i] * pre[d[i]] % Mod;
    }
}
```
* **代码解读**：
  - `pre[i]`存储`g(p)`的`i`次幂（预处理到`i=60`，因为`d(x)`最多60）。
  - 计算`g(xp)`时，直接取`pre[d[i]]`（`d[i]`是`x`的因数个数），避免了每次调用`qpow`。
* **学习笔记**：预处理是“用空间换时间”的典型技巧，当某个值的幂次范围有限时，提前算好所有可能的结果，能大幅提升速度。


## 5. 算法可视化：像素动画演示

### 动画主题：像素探险队·质因数分解之旅

### 设计思路
用8位像素风营造复古游戏氛围，通过“探险队遍历数字森林”的过程，演示`g(x)`的计算逻辑。每个数是一个像素块，质数用星星标记，`g(x)`用颜色深浅表示。交互上支持单步、自动播放，伴随复古音效，增强记忆点。


### 动画帧步骤与交互关键点
1. **场景初始化**：
   - 屏幕左侧是“数字森林”（8位像素网格），右侧是“控制面板”（开始/暂停、单步、重置按钮，速度滑块）。
   - 背景播放8位风格的轻快BGM（类似《超级马里奥》的背景音乐）。
2. **算法启动**：
   - 初始位置是`1`（白色像素块，显示`g=1`，`d=1`），探险队（像素小人）站在旁边。
   - 点击“开始”，小人走到`2`（质数，星星标记），计算`g(2)=f(1)*f(2)=1*(2²+1)=5`，`2`的颜色变成浅蓝色（代表`g=5`），伴随“叮”的音效。
3. **DFS搜索**：
   - 小人走到`2×2=4`，计算`g(4)=g(2)^2 × g(2²)^{d(2)}`（`d(2)=2`）：`g(2²)=f(1)*f(2)*f(4)=1×5×(16+2)=90`，所以`g(4)=5²×90²=25×8100=202500`，`4`的颜色变成深蓝色，伴随“嗡”的音效（快速幂）。
   - 单步执行时，每点击“下一步”，小人走到下一个数，显示计算过程；自动播放时，小人匀速遍历所有数，完成后播放“胜利”音效。
4. **处理大质数**：
   - 小人走到`>√n`的质数`7`（`√5=~2.236`，所以`7>√5`），计算`g(7)=7²+1=50`，然后遍历`x=1`（`x≤√5`），计算`g(7)=g(1)^2 × g(7)^{d(1)}=1×50=50`，`7`的颜色变成紫色，伴随“叮”的音效。
5. **结果展示**：
   - 所有数计算完成后，屏幕显示异或结果（比如样例输入`5`的结果`78`），伴随“胜利”音效，背景烟花绽放。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的“分块处理+积性函数+记忆化”思路，可用于**大数范围内的积性函数求和**问题，比如：
- 计算`h(x) = sum_{d|x} φ(d)`（`φ`是欧拉函数）的异或和；
- 计算`k(x) = product_{d|x} μ(d)`（`μ`是莫比乌斯函数）的总和。


### 洛谷练习推荐
1. **P3383 【模板】线性筛素数**：巩固素数筛法，理解线性筛的空间复杂度。
2. **P4449 于神之怒加强版**：考察积性函数的快速求和，需要分块处理和莫比乌斯反演。
3. **P5495 【模板】Dirichlet 前缀和**：学习Dirichlet卷积和前缀和的计算，加深对积性函数的理解。


## 7. 学习心得与经验分享

题解二中作者提到：“空间被卡了，没法线性筛。考虑直接搜每个数的质因数分解，同时维护这个g。” 这提醒我们：
- **不要局限于固定算法**：线性筛是常用的数论工具，但当空间不够时，要学会用“搜索+记忆化”替代。
- **公式推导是关键**：先推导出`g(xp^k)`的公式，再写代码，比直接硬写更高效。


## 结语
本次分析让我们学会了**用分块思想突破空间限制**，**用记忆化优化时间**，更重要的是理解了积性函数的“分解与组合”思想。编程的本质是“解决问题”，而不是“死记算法”——遇到问题时，先拆解，再找规律，最后用代码实现。下次我们再一起探索更有趣的数论问题！💪

---
处理用时：119.32秒
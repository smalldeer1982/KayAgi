# 题目信息

# [SCOI2005] 互不侵犯

## 题目描述

在 $N \times N$ 的棋盘里面放 $K$ 个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共 $8$ 个格子。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N \le 9$，$0 \le K \le N\times N$。

---

$\text{upd 2018.4.25}$：数据有加强。

## 样例 #1

### 输入

```
3 2
```

### 输出

```
16
```

# AI分析结果

要解决**《互不侵犯》**（洛谷P1896）这道题，**状压DP（状态压缩动态规划）**是最经典且高效的解法。其核心思想是将每行的国王放置状态压缩为二进制数，通过动态规划逐行转移，确保国王之间互不攻击。


### **1. 问题分析**
- **约束条件**：国王攻击范围是8个方向（上下、左右、斜上下），因此：
  1. 同一行内，国王不能相邻（无连续1）。
  2. 相邻行之间，国王不能上下对齐（无相同位1），也不能斜上下对齐（无左移/右移后相同位1）。
- **数据范围**：\(1 \leq N \leq 9\)，\(0 \leq K \leq N^2\)，适合状压（二进制状态数最多为\(2^9=512\)，预处理后合法状态数更少）。


### **2. 状压DP核心思路**
#### **2.1 预处理合法状态**
首先枚举所有可能的**单行合法状态**（无连续国王），并记录每个状态的国王数量。例如，对于\(N=3\)，合法状态有：
- \(000\)（0）：0个国王；
- \(001\)（1）：1个国王；
- \(010\)（2）：1个国王；
- \(100\)（4）：1个国王；
- \(101\)（5）：2个国王。

**预处理方法**：
- **枚举法**：遍历所有二进制数（\(0\)到\(2^N-1\)），判断是否有连续1（通过`i & (i << 1)`是否为0）。
- **DFS法**：更高效的方式，递归生成所有合法状态（放国王则跳过下一位，不放则继续）。


#### **2.2 状态定义**
定义`dp[i][j][k]`表示：
- `i`：当前处理到第\(i\)行；
- `j`：第\(i\)行的状态（预处理后的合法状态索引）；
- `k`：前\(i\)行共放置了\(k\)个国王。

`dp[i][j][k]`的值为**满足上述条件的方案数**。


#### **2.3 状态转移**
对于第\(i\)行的状态\(j\)（国王数量为`cnt[j]`），需要枚举第\(i-1\)行的所有合法状态\(l\)，判断\(j\)与\(l\)是否**合法相邻**（无上下、斜上下攻击）：
- 合法条件：`(state[j] & state[l]) == 0`（无上下对齐）、`(state[j] & (state[l] << 1)) == 0`（无左上方攻击）、`((state[j] << 1) & state[l]) == 0`（无右上方攻击）。

若合法，则状态转移方程为：
\[ dp[i][j][k] += dp[i-1][l][k - cnt[j]] \]
其中，`k - cnt[j]`表示前\(i-1\)行放置了\(k - cnt[j]\)个国王。


#### **2.4 初始化与结果**
- **初始化**：第一行的每个合法状态\(j\)，`dp[1][j][cnt[j]] = 1`（只有自己，方案数为1）。
- **结果**：所有`dp[N][j][K]`的和（第\(N\)行所有合法状态，共放置\(K\)个国王的方案数之和）。


### **3. 代码实现**
以下是**状压DP的C++实现**（包含预处理、状态转移和结果统计）：

```cpp
#include <iostream>
#include <vector>
using namespace std;

typedef long long ll;

int N, K;
vector<int> state;    // 合法状态（二进制数）
vector<int> cnt;      // 每个状态的国王数量
ll dp[10][100][100];  // dp[i][j][k]：第i行，状态j，k个国王的方案数

// 预处理合法状态（DFS）
void dfs(int pos, int sum, int tot) {
    if (pos >= N) {
        state.push_back(sum);
        cnt.push_back(tot);
        return;
    }
    // 不放国王，处理下一位
    dfs(pos + 1, sum, tot);
    // 放国王，跳过下一位（避免相邻）
    dfs(pos + 2, sum + (1 << pos), tot + 1);
}

int main() {
    cin >> N >> K;
    dfs(0, 0, 0);  // 预处理合法状态
    int m = state.size();  // 合法状态数

    // 初始化第一行
    for (int j = 0; j < m; j++) {
        if (cnt[j] <= K) {
            dp[1][j][cnt[j]] = 1;
        }
    }

    // 状态转移（逐行处理）
    for (int i = 2; i <= N; i++) {
        for (int j = 0; j < m; j++) {  // 当前行状态j
            int cj = cnt[j];
            if (cj > K) continue;
            for (int l = 0; l < m; l++) {  // 上一行状态l
                int cl = cnt[l];
                // 判断j与l是否合法相邻
                if ((state[j] & state[l]) || (state[j] & (state[l] << 1)) || ((state[j] << 1) & state[l])) {
                    continue;
                }
                // 转移所有可能的国王数量
                for (int k = cj; k <= K; k++) {
                    dp[i][j][k] += dp[i-1][l][k - cj];
                }
            }
        }
    }

    // 统计结果（第N行所有状态的方案数之和）
    ll ans = 0;
    for (int j = 0; j < m; j++) {
        ans += dp[N][j][K];
    }
    cout << ans << endl;

    return 0;
}
```


### **4. 代码解释**
- **预处理**：`dfs`函数生成所有合法状态，`state`存储状态的二进制数，`cnt`存储每个状态的国王数量。
- **初始化**：第一行的每个合法状态，若国王数量不超过\(K\)，则方案数为1。
- **状态转移**：逐行处理，枚举当前行和上一行的状态，判断是否合法，若合法则转移方案数。
- **结果统计**：累加第\(N\)行所有合法状态的方案数，得到最终答案。


### **5. 优化说明**
- **预处理优化**：使用DFS生成合法状态，比枚举所有二进制数更高效（避免无效状态的判断）。
- **状态压缩**：将状态压缩为二进制数，减少状态数量（例如，\(N=9\)时，合法状态数约为89）。
- **数据类型**：使用`long long`避免方案数溢出（例如，\(N=9\)、\(K=25\)时，方案数可能很大）。


### **6. 样例分析**
以样例输入`3 2`为例：
- **预处理**：合法状态有5个（0、1、2、4、5），对应的国王数量分别为0、1、1、1、2。
- **初始化**：第一行的状态5（101）有2个国王，`dp[1][4][2] = 1`（索引从0开始）。
- **状态转移**：第二行的状态2（010）与第一行的状态1（001）合法，`dp[2][2][2] += dp[1][1][1]`（1+1=2个国王）。
- **结果**：第三行所有状态的`dp[3][j][2]`之和为16，与样例输出一致。


### **总结**
状压DP是解决《互不侵犯》问题的最优方法，其核心是**状态压缩**和**逐行转移**。通过预处理合法状态，减少状态数量，再通过动态规划转移方案数，确保国王之间互不攻击。这种方法的时间复杂度为\(O(N \times M^2 \times K)\)（\(M\)为合法状态数），对于\(N=9\)来说完全可行。

---
处理用时：96.08秒
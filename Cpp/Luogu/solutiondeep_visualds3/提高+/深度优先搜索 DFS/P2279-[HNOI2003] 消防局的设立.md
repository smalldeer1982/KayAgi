# 题目信息

# [HNOI2003] 消防局的设立

## 题目描述

2020 年，人类在火星上建立了一个庞大的基地群，总共有 $n$ 个基地。起初为了节约材料，人类只修建了 $n-1$ 条道路来连接这些基地，并且每两个基地都能够通过道路到达，所以所有的基地形成了一个巨大的树状结构。如果基地 $A$ 到基地 $B$ 至少要经过 $d$ 条道路的话，我们称基地A到基地B的距离为 $d$。

由于火星上非常干燥，经常引发火灾，人类决定在火星上修建若干个消防局。消防局只能修建在基地里，每个消防局有能力扑灭与它距离不超过 $2$ 的基地的火灾。

你的任务是计算至少要修建多少个消防局才能够确保火星上所有的基地在发生火灾时，消防队有能力及时扑灭火灾。

## 样例 #1

### 输入

```
6
1
2
3
4
5
```

### 输出

```
2```

# AI分析结果

# HNOI2003 消防局的设立题解分析


## **一、题目回顾**
给定一棵有 \( n \) 个节点的树，每个消防局能覆盖距离不超过2的节点。求覆盖所有节点所需的最少消防局数量。


## **二、核心思路总结**
本题的解法主要分为**贪心**和**树形动态规划（DP）**两类，其中贪心是最常用且高效的方法。


### **1. 贪心算法**
**核心思想**：  
优先覆盖**最深的未被覆盖节点**，在其**祖父节点**（或更上层节点）建立消防局。这样可以最大化覆盖该节点的后代及周边节点，避免重复建设。

**具体步骤**：  
- **步骤1**：计算每个节点的深度（从根节点1开始）。  
- **步骤2**：按深度从大到小排序节点（优先处理最深节点）。  
- **步骤3**：遍历排序后的节点，若当前节点未被覆盖，则在其祖父节点建立消防局，并标记所有距离该祖父节点不超过2的节点为已覆盖。  
- **步骤4**：重复步骤3，直到所有节点被覆盖。

**正确性证明**：  
最深的未被覆盖节点必须被覆盖，而在其祖父节点建立消防局能覆盖该节点的父节点、子节点、孙子节点及祖父节点的其他子节点（即该节点的兄弟节点），覆盖范围最大，不会导致更优解的丢失。

**代码示例（贪心）**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>
using namespace std;

const int MAXN = 1005;
vector<int> G[MAXN];
int depth[MAXN], fa[MAXN];
bool covered[MAXN];
int n, ans;

// 计算深度和父节点（DFS）
void dfs(int u, int f) {
    fa[u] = f;
    depth[u] = depth[f] + 1;
    for (int v : G[u]) {
        if (v != f) {
            dfs(v, u);
        }
    }
}

// 标记覆盖范围（BFS/DFS）
void mark(int u) {
    covered[u] = true;
    // 覆盖距离不超过2的节点
    for (int v : G[u]) {
        covered[v] = true;
        for (int w : G[v]) {
            covered[w] = true;
        }
    }
}

int main() {
    cin >> n;
    for (int i = 2; i <= n; i++) {
        int x;
        cin >> x;
        G[i].push_back(x);
        G[x].push_back(i);
    }
    dfs(1, 0); // 根节点1的父节点为0
    // 按深度从大到小排序节点
    vector<int> nodes(n);
    for (int i = 0; i < n; i++) nodes[i] = i + 1;
    sort(nodes.begin(), nodes.end(), [&](int a, int b) { return depth[a] > depth[b]; });
    // 处理每个节点
    for (int u : nodes) {
        if (!covered[u]) {
            // 找祖父节点（若不存在则找父节点或根）
            int g = fa[fa[u]];
            if (g == 0) g = fa[u];
            if (g == 0) g = u;
            mark(g);
            ans++;
        }
    }
    cout << ans << endl;
    return 0;
}
```


### **2. 树形DP**
**核心思想**：  
通过动态规划定义节点的覆盖状态，考虑节点及其子树的覆盖情况，从而求解最小消防局数量。状态定义需包含节点的覆盖范围（如向上覆盖0、1、2层，向下覆盖子节点、孙子节点等）。

**状态定义**：  
通常定义 \( dp[u][k] \) 表示以 \( u \) 为根的子树满足某种覆盖条件时的最小消防局数量，其中 \( k \) 表示覆盖范围：  
- \( dp[u][0] \)：\( u \) 是消防局，覆盖到向上2层（即 \( u \) 的祖父节点）。  
- \( dp[u][1] \)：\( u \) 不是消防局，但被其子节点覆盖（覆盖到向上1层）。  
- \( dp[u][2] \)：\( u \) 不是消防局，但被其孙子节点覆盖（覆盖到向上0层）。  
- \( dp[u][3] \)：\( u \) 的子节点均被覆盖（向下覆盖1层）。  
- \( dp[u][4] \)：\( u \) 的孙子节点均被覆盖（向下覆盖2层）。

**状态转移**：  
- \( dp[u][0] = 1 + \sum \min(dp[v][0..4]) \)（\( u \) 是消防局，子节点任意状态）。  
- \( dp[u][1] = \min(dp[v][0] + \sum \min(dp[w][0..3])) \)（选一个子节点 \( v \) 作为消防局，其他子节点覆盖到向上1层）。  
- \( dp[u][2] = \min(dp[v][1] + \sum \min(dp[w][0..2])) \)（选一个孙子节点作为消防局，其他子节点覆盖到向上0层）。  
- \( dp[u][3] = \sum \min(dp[v][0..2]) \)（子节点均被覆盖）。  
- \( dp[u][4] = \sum \min(dp[v][0..3]) \)（孙子节点均被覆盖）。

**代码示例（树形DP）**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>
using namespace std;

const int MAXN = 1005;
const int INF = 1e9;
vector<int> G[MAXN];
int dp[MAXN][5];
int n;

void dfs(int u, int f) {
    // 初始化状态
    dp[u][0] = 1; // 选u作为消防局
    dp[u][1] = dp[u][2] = INF;
    dp[u][3] = dp[u][4] = 0;
    // 处理子节点
    for (int v : G[u]) {
        if (v == f) continue;
        dfs(v, u);
        // 更新dp[u][0]：选u，子节点任意状态
        dp[u][0] += min({dp[v][0], dp[v][1], dp[v][2], dp[v][3], dp[v][4]});
        // 更新dp[u][3]：子节点均被覆盖
        dp[u][3] += min({dp[v][0], dp[v][1], dp[v][2]});
        // 更新dp[u][4]：孙子节点均被覆盖
        dp[u][4] += min({dp[v][0], dp[v][1], dp[v][2], dp[v][3]});
    }
    // 处理dp[u][1]：选一个子节点作为消防局
    for (int v : G[u]) {
        if (v == f) continue;
        int sum = dp[v][0]; // 选v作为消防局
        for (int w : G[u]) {
            if (w == f || w == v) continue;
            sum += min({dp[w][0], dp[w][1], dp[w][2], dp[w][3]}); // 其他子节点覆盖到向上1层
        }
        dp[u][1] = min(dp[u][1], sum);
    }
    // 处理dp[u][2]：选一个孙子节点作为消防局
    for (int v : G[u]) {
        if (v == f) continue;
        int sum = dp[v][1]; // v被其子节点覆盖（即孙子节点作为消防局）
        for (int w : G[u]) {
            if (w == f || w == v) continue;
            sum += min({dp[w][0], dp[w][1], dp[w][2]}); // 其他子节点覆盖到向上0层
        }
        dp[u][2] = min(dp[u][2], sum);
    }
    // 合并状态（取最小值）
    dp[u][1] = min(dp[u][1], dp[u][0]); // 选u比选子节点更优
    dp[u][2] = min(dp[u][2], dp[u][1]); // 选子节点比选孙子节点更优
    dp[u][3] = min(dp[u][3], dp[u][2]); // 覆盖到向上0层比覆盖子节点更优
    dp[u][4] = min(dp[u][4], dp[u][3]); // 覆盖子节点比覆盖孙子节点更优
}

int main() {
    cin >> n;
    for (int i = 2; i <= n; i++) {
        int x;
        cin >> x;
        G[i].push_back(x);
        G[x].push_back(i);
    }
    dfs(1, 0);
    cout << min({dp[1][0], dp[1][1], dp[1][2]}) << endl;
    return 0;
}
```


## **三、两种方法对比**
| **维度**         | **贪心算法**                | **树形DP**                  |
|-------------------|-----------------------------|-----------------------------|
| **代码复杂度**     | 低（简洁易写）              | 高（状态定义复杂）          |
| **时间复杂度**     | \( O(n \log n) \)（排序）   | \( O(n) \)（线性遍历）       |
| **扩展性**         | 差（仅适用于覆盖距离2的情况）| 好（可扩展到任意覆盖距离）  |
| **理解难度**       | 低（直观易懂）              | 高（需要掌握状态转移逻辑）  |


## **四、注意事项**
1. **祖父节点不存在的情况**：当节点是根节点的子节点（如深度为2），其祖父节点不存在，此时应在父节点（根节点）建立消防局。  
2. **覆盖范围的标记**：建立消防局后，需标记所有距离不超过2的节点，包括祖父节点的父节点、父节点的子节点、子节点的子节点等。  
3. **树形DP的状态合并**：需合并状态以取最小值，例如 \( dp[u][1] \) 应取“选子节点”和“选自己”中的较小值。


## **五、总结**
本题的最优解法是**贪心算法**，其代码简洁、时间复杂度低，适合数据规模较小的情况。树形DP虽然扩展性好，但代码复杂，适合需要处理更一般情况的问题。在实际比赛中，贪心算法是首选。

---
处理用时：104.31秒
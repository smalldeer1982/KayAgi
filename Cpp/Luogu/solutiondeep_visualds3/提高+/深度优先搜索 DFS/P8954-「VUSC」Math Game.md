# 题目信息

# 「VUSC」Math Game

## 题目背景

**upd 2023.1.22**：新增一组 Hack 数据 by @[MCRS_lizi](https://www.luogu.com.cn/user/585805)。

远在哞利坚的 Bessie 也要在新春之际走亲访友！为了打发时间，她常和 Farmer John 玩一个有趣的数字游戏。

## 题目描述

Farmer John 有一个集合 $S$，集合初始为 $\{2,3,4,...,N\}$。

对于两个**在集合 $S$ 内的**正整数 $p,q$，我们称它们为「一对好数」当且仅当 $p^k=q(k\ge 2\land k\in\N)$。

我们将每个 $S$ 中的数看成一张**无向图**中的节点，对于每一对「好数」，我们在这两个数间连一条无向边。

Farmer John 会进行 $Q$ 次操作，操作有以下两种：

1. 给出 $x$，询问结点 $x$ 所在的连通块大小。
2. 给出 $x$，从 $S$ 中移除 $x$。**与此同时，无向图中的结点 $x$ 也被移除。**

由于 Bessie 的速度太慢了，她想要你来帮忙。

## 说明/提示

#### 【样例解释】

这是原始无向图（上面一排都是孤点）：
![](https://cdn.luogu.com.cn/upload/image_hosting/utsz04dt.png)

这是进行第一次操作 $2$ 后的无向图（删除了结点 $9$）：
![](https://cdn.luogu.com.cn/upload/image_hosting/wmexc9ks.png)

这是进行第二次操作 $2$ 后的无向图（删除了结点 $2$）：
![](https://cdn.luogu.com.cn/upload/image_hosting/9mi0l18p.png)

---

#### 【数据范围】

全部数据满足：
- $2\le N \le 10^{18}$
- $1\le Q \le 10^6$
- $x_i\in S$
- $op_i \in \{1,2\}$

测试点 $1\sim2$ 另外满足 $2\le N \le 10^5$，$1\le Q \le 10^4$。

测试点 $3\sim4$ 另外满足所有 $x_i=m^{p_i}$，其中 $m$ 为一满足 $m\ge 2 \land m\in \N$ 的**常数**。

测试点 $5\sim10$ 没有额外限制。


## 样例 #1

### 输入

```
30 6
1 6
1 4
2 9
1 3
2 2
1 16```

### 输出

```
1
4
2
2```

# AI分析结果

# 💡 Kay的C++算法解析：「VUSC」Math Game 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**并查集（离线处理）+ 数论（幂次分解）**


🗣️ **初步分析**：  
这道题的核心是维护一个**幂次连通图**的连通块大小。比如，2、4、8、16这些数因为可以通过幂次（2²=4，2³=8，等等）连接，所以属于同一个连通块。问题的难点在于：  
- **数据范围极大**（N≤1e18），无法用常规数组存储所有数；  
- **支持删除操作**，而普通并查集不擅长处理动态删除。  

解决这两个问题的关键思路是：  
1. **离线处理**：将所有操作倒序，把“删除”变成“添加”（因为添加操作更容易用并查集维护）；  
2. **幂次分解**：将每个数表示为最小基的幂次（比如16=2⁴，最小基是2），这样连通块就转化为“同一基的所有幂次”的集合；  
3. **离散化**：只处理查询中出现的数，避免存储1e18个元素。  

**核心算法流程**：  
- 预处理所有查询中的数，将其分解为最小基（如x= aᵏ，a是最小的基）；  
- 倒序处理操作：初始时所有要删除的数都被标记为“已删除”，然后依次将“删除”改为“添加”，并将该数的幂次连接到并查集中；  
- 查询时，找到该数的最小基对应的并查集，返回连通块大小。  

**可视化设计思路**：  
我们可以用**8位像素风格**展示这个过程：  
- 用不同颜色的像素块表示不同的基（比如2是红色，3是蓝色）；  
- 每个像素块的大小表示幂次（比如2⁴是红色块，大小为4）；  
- 删除操作时，像素块变暗；添加操作时，像素块变亮，并与同基的其他块连接（用线条表示边）；  
- 查询时，高亮该基的所有像素块，显示连通块大小。  
- 音效：添加时播放“叮”的声音，查询时播放“嗡”的声音，删除时播放“咔”的声音，增加代入感。


## 2. 精选优质题解参考

### 题解一：enucai（在线处理，找最小基）  
* **点评**：  
  这份题解的思路非常**直接**，适合入门理解。它没有用复杂的离线处理，而是通过**找每个数的最小基**（f(x)）来快速计算连通块大小。比如，对于x=16，最小基是2，那么连通块就是所有未被删除的2的幂次（2、4、8、16等）。  
  代码中的`find`函数巧妙地处理了不同幂次的情况（比如平方、立方），用`map`和预处理的三次方数组来快速判断。`calc`函数枚举所有可能的幂次，检查是否被删除，最终统计连通块大小。  
  亮点：**在线处理**不需要离线，代码简洁，容易理解；**时间复杂度低**（O(Q logN logQ)），适合处理1e6次查询。


### 题解二：STUDENT00（离线+时间倒流+并查集）  
* **点评**：  
  这份题解解决了大N的问题，思路非常**巧妙**。它用**时间倒流**将删除操作转化为添加操作，这样就可以用并查集维护连通性。比如，初始时所有要删除的数都被标记为“已删除”，然后倒序处理操作，每次将“删除”改为“添加”，并将该数的幂次连接到并查集中。  
  代码中的`init`函数预处理了所有查询中的数，将其分解为最小基的幂次；`calc`函数倒序处理操作，用并查集合并幂次。  
  亮点：**离线处理**解决了大N的问题；**时间倒流**巧妙处理了删除操作；**离散化**减少了空间占用。


### 题解三：Moeebius（出题人题解，离线+并查集）  
* **点评**：  
  这份题解是出题人的官方解法，思路**权威**。它同样用了离线+时间倒流的方法，但预处理更细致。比如，`prework`函数预处理了所有三次方以上的数，`calc`函数倒序处理操作，用并查集合并幂次。  
  代码中的`find`和`uni`函数是并查集的标准实现，`pool` map存储了每个数的最小基和幂次。  
  亮点：**预处理全面**，覆盖了所有可能的幂次；**代码结构清晰**，容易跟随。


## 3. 核心难点辨析与解题策略

### 1. 难点1：如何处理大N（1e18）的问题？  
* **分析**：  
  N=1e18无法用常规数组存储，所以必须**离散化**——只处理查询中出现的数。比如，STUDENT00的题解中，用`map`存储查询中的数，然后将其分解为最小基的幂次，再离散化基的编号。  
* 💡 **学习笔记**：离散化是处理大值域问题的常用技巧，将有用的数映射到小范围。


### 2. 难点2：如何高效找到每个数的最小基？  
* **分析**：  
  最小基是指最小的y，使得y^k=x（k≥2）。比如，16的最小基是2（2⁴=16），而36的最小基是6（6²=36）。  
  解决方法：  
  - 预处理三次方以上的数（比如i从2到1e6，计算i²、i³…直到超过N）；  
  - 对于平方数，用`sqrtl`函数判断（比如16的平方根是4，再判断4是否是平方数，直到找到最小基）。  
* 💡 **学习笔记**：幂次分解是数论中的基础技巧，需要熟练掌握。


### 3. 难点3：如何处理删除操作？  
* **分析**：  
  普通并查集不支持删除操作，所以需要**离线处理+时间倒流**。比如，将所有操作倒序，把“删除”变成“添加”，这样每次添加操作都可以用并查集合并连通块。  
* 💡 **学习笔记**：时间倒流是处理动态删除问题的常用技巧，将问题转化为更容易处理的添加操作。


### ✨ 解题技巧总结  
- **离线处理**：对于动态删除问题，考虑倒序处理，将删除变为添加；  
- **幂次分解**：将数表示为最小基的幂次，简化连通块维护；  
- **离散化**：处理大值域问题，只存储有用的数；  
- **并查集**：维护连通块的常用数据结构，适合处理合并和查询操作。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（离线+时间倒流+并查集）  
* **说明**：综合了STUDENT00和Moeebius的题解，提供一个清晰的离线处理框架。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <map>
  #include <set>
  #include <algorithm>
  #include <cmath>
  using namespace std;

  typedef long long ll;
  const int MAXN = 1e6 + 5;

  ll n, q;
  vector<pair<int, ll>> oper; // 操作：(op, x)
  map<ll, pair<ll, int>> indx; // 存储每个x的最小基和幂次：(a, k)
  set<ll> del; // 初始时被删除的数
  vector<ll> num; // 离散化后的基
  vector<vector<int>> fa; // 并查集：fa[id][k]表示基id的k次幂的父亲
  vector<vector<int>> siz; // 并查集：siz[id][k]表示基id的k次幂的连通块大小

  int find(int id, int x) {
      if (fa[id][x] == x) return x;
      return fa[id][x] = find(id, fa[id][x]);
  }

  void uni(int id, int x, int y) {
      x = find(id, x);
      y = find(id, y);
      if (x == y) return;
      fa[id][y] = x;
      siz[id][x] += siz[id][y];
  }

  void init() {
      // 预处理三次方以上的数
      for (int i = 2; (ll)i * i * i <= n; ++i) {
          ll tmp = i;
          for (int j = 1; tmp <= n; ++j) {
              if (indx.find(tmp) != indx.end() && indx[tmp].first == tmp) {
                  indx[tmp] = make_pair(i, j);
              }
              tmp *= i;
          }
      }
      // 预处理平方数
      for (auto &p : indx) {
          ll x = p.first;
          if ((ll)sqrtl(x) * (ll)sqrtl(x) == x) {
              ll a = sqrtl(x);
              indx[x] = make_pair(a, 2);
          }
      }
      // 离散化基
      for (auto &p : indx) {
          num.push_back(p.second.first);
      }
      sort(num.begin(), num.end());
      num.erase(unique(num.begin(), num.end()), num.end());
      // 初始化并查集
      int tot = num.size();
      fa.resize(tot + 1);
      siz.resize(tot + 1);
      for (int i = 0; i < tot; ++i) {
          ll a = num[i];
          int cnt = logl(n) / logl(a);
          fa[i + 1].resize(cnt + 1);
          siz[i + 1].resize(cnt + 1);
          for (int j = 1; j <= cnt; ++j) {
              fa[i + 1][j] = j;
              siz[i + 1][j] = 1;
          }
          // 合并未被删除的幂次
          ll tmp = 1;
          for (int j = 1; j <= cnt / 2; ++j) {
              tmp *= a;
              if (del.count(tmp)) continue;
              ll cur = tmp;
              for (int k = 2; k <= cnt / j; ++k) {
                  cur *= tmp;
                  if (del.count(cur)) continue;
                  uni(i + 1, j, j * k);
              }
          }
      }
  }

  vector<ll> ans;
  void calc() {
      int len = oper.size();
      for (int i = len - 1; i >= 0; --i) {
          int op = oper[i].first;
          ll x = oper[i].second;
          ll a = indx[x].first;
          int k = indx[x].second;
          int id = lower_bound(num.begin(), num.end(), a) - num.begin() + 1;
          if (op == 1) {
              // 查询：找到k次幂的连通块大小
              ans.push_back(siz[id][find(id, k)]);
          } else {
              // 删除→添加：将x添加回来，并合并其幂次
              del.erase(x);
              int cnt = logl(n) / logl(a);
              // 合并倍数（比如x=a^k，合并a^k、a^(2k)、…）
              ll tmp = 1;
              for (int j = 1; j <= cnt / k; ++j) {
                  tmp *= x;
                  if (del.count(tmp)) continue;
                  uni(id, k, k * j);
              }
              // 合并因数（比如x=a^k，合并a^1、a^2、…（如果k是它们的倍数））
              tmp = 1;
              for (int j = 1; j <= k; ++j) {
                  tmp *= a;
                  if (k % j == 0 && !del.count(tmp)) {
                      uni(id, j, k);
                  }
              }
          }
      }
      reverse(ans.begin(), ans.end());
  }

  int main() {
      cin >> n >> q;
      for (int i = 0; i < q; ++i) {
          int op;
          ll x;
          cin >> op >> x;
          oper.push_back(make_pair(op, x));
          indx[x] = make_pair(x, 1); // 初始化为自身
          if (op == 2) {
              del.insert(x);
          }
      }
      init();
      calc();
      for (ll a : ans) {
          cout << a << endl;
      }
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. `init`函数：预处理所有查询中的数，将其分解为最小基的幂次，并初始化并查集；  
  2. `calc`函数：倒序处理操作，将删除变为添加，用并查集合并幂次；  
  3. `find`和`uni`函数：并查集的标准实现，用于维护连通块。


### 题解一：enucai的核心代码片段（在线找最小基）  
* **亮点**：在线处理，不需要离线，代码简洁。  
* **核心代码片段**：  
  ```cpp
  ll find(ll x) {
      if (mp.find(x) != mp.end()) return mp[x];
      else if (check(x) != -1) return check(x); // 检查是否是三次方
      else if ((ll)sqrtl(x) * (ll)sqrtl(x) == x) return sqrtl(x); // 检查是否是平方
      else return x;
  }

  int calc(ll x, ll y) {
      int res = 0;
      while (x != 1) res++, x /= y;
      return res;
  }
  ```  
* **代码解读**：  
  - `find`函数：找x的最小基。首先检查是否在`mp`（预处理的三次方以上的数）中，然后检查是否是三次方，再检查是否是平方，否则返回自身；  
  - `calc`函数：计算x是y的多少次幂（比如x=16，y=2，返回4）。  
* 💡 **学习笔记**：在线处理的关键是快速找到最小基，这样可以避免离线的麻烦。


### 题解二：STUDENT00的核心代码片段（时间倒流）  
* **亮点**：时间倒流处理删除操作，巧妙解决动态问题。  
* **核心代码片段**：  
  ```cpp
  void calc() {
      for (int i = q; i >= 1; --i) {
          ll base = indx[x[i]].first;
          int power = indx[x[i]].second;
          int id = lower_bound(num+1, num+tot+1, base) - num;
          if (op[i] == 1) {
              ans[++tott] = siz[id][find(id, power)];
          } else {
              del.erase(x[i]);
              // 合并倍数和因数
              // ...
          }
      }
  }
  ```  
* **代码解读**：  
  倒序处理操作，当遇到查询操作时，记录答案；当遇到删除操作时，将其从`del`集合中移除，并合并其幂次。  
* 💡 **学习笔记**：时间倒流是处理动态删除问题的“神器”，可以将复杂的删除操作转化为简单的添加操作。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**幂次连通块的“积木游戏”**  
用8位像素风格展示数的幂次连通块，比如2的幂次是红色积木，3的幂次是蓝色积木，4的幂次是红色积木（因为4=2²）。


### 核心演示内容  
1. **初始状态**：屏幕上显示所有未被删除的数，用不同颜色的积木表示（比如2是红色1x1积木，4是红色1x2积木，8是红色1x3积木）；  
2. **删除操作**：点击“删除”按钮，选中的积木变暗，并从连通块中移除（比如删除4，红色1x2积木变暗，2和8的积木仍然相连）；  
3. **添加操作**（时间倒流）：点击“添加”按钮，变暗的积木变亮，并与同基的积木连接（比如添加4，红色1x2积木变亮，与2和8的积木连接）；  
4. **查询操作**：点击“查询”按钮，高亮该数所在的连通块（比如查询8，所有红色积木高亮，显示连通块大小为3）。


### 设计思路简述  
- **像素风格**：用简单的积木形状和鲜艳的颜色，符合青少年的审美；  
- **游戏化元素**：将操作设计为“点击按钮”，增加互动性；  
- **音效**：删除时播放“咔”的声音，添加时播放“叮”的声音，查询时播放“嗡”的声音，强化操作记忆；  
- **状态提示**：用文字气泡显示当前操作（比如“删除了4”“添加了4”“查询8的连通块大小为3”）。


### 动画帧步骤  
1. **场景初始化**：屏幕左侧显示积木区域，右侧显示控制面板（开始/暂停、单步、重置、速度滑块）；  
2. **初始状态展示**：所有未被删除的数用积木表示，比如2（红1x1）、3（蓝1x1）、4（红1x2）、5（绿1x1）、8（红1x3）；  
3. **删除操作**：点击“删除4”，红1x2积木变暗，2和8的积木仍然相连；  
4. **添加操作**：点击“添加4”，红1x2积木变亮，与2和8的积木连接；  
5. **查询操作**：点击“查询8”，所有红色积木高亮，显示“连通块大小为3”；  
6. **时间倒流演示**：点击“自动播放”，动画倒序播放所有操作，展示删除变为添加的过程。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **离线处理+时间倒流**：适用于所有需要动态删除的连通块问题（比如星球大战问题）；  
- **幂次分解**：适用于所有涉及数的幂次关系的问题（比如判断一个数是否是完全平方数、完全立方数）；  
- **并查集**：适用于所有需要维护连通块的问题（比如亲戚问题、朋友问题）。


### 练习推荐 (洛谷)  
1. **洛谷 P1197 [JSOI2008] 星球大战**  
   🗣️ **推荐理由**：这道题是时间倒流的经典例题，需要处理动态删除边的问题，与本题的思路高度相似。  
2. **洛谷 P3367 并查集**  
   🗣️ **推荐理由**：这道题是并查集的基础题，需要掌握并查集的基本操作（合并、查询）。  
3. **洛谷 P1551 亲戚**  
   🗣️ **推荐理由**：这道题是并查集的应用题，需要用并查集维护亲戚关系的连通块。  
4. **洛谷 P2078 朋友**  
   🗣️ **推荐理由**：这道题是并查集的拓展题，需要维护多个连通块的大小。


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自 STUDENT00)  
> “我在解决这个问题时，最初被大N的问题卡住了，后来想到用离散化处理查询中的数，才解决了空间问题。另外，时间倒流的思路是我从星球大战问题中学来的，非常适合处理动态删除问题。”  

**点评**：  
这位作者的经验很典型。在处理大值域问题时，离散化是常用的技巧；而时间倒流是处理动态删除问题的“神器”。这些技巧需要多练习才能熟练掌握。


## 📝 总结  
本次分析的“VUSC”Math Game 题，核心是**离线处理+时间倒流+并查集**，结合**幂次分解**和**离散化**解决大N和动态删除的问题。通过学习这些技巧，我们可以解决类似的动态连通块问题。  

记住，编程的关键是**思路**——找到问题的核心，然后用合适的算法和技巧解决它。希望这份指南能帮助你更好地理解这些思路，下次遇到类似问题时能举一反三！💪

---
处理用时：176.66秒
# 题目信息

# [NOIP 2016 提高组] 愤怒的小鸟

## 题目背景

NOIP2016 提高组 D2T3

## 题目描述

Kiana 最近沉迷于一款神奇的游戏无法自拔。

简单来说，这款游戏是在一个平面上进行的。

有一架弹弓位于 $(0,0)$ 处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 $y=ax^2+bx$ 的曲线，其中 $a,b$ 是 Kiana 指定的参数，且必须满足 $a < 0$，$a,b$ 都是实数。

当小鸟落回地面（即 $x$ 轴）时，它就会瞬间消失。

在游戏的某个关卡里，平面的第一象限中有 $n$ 只绿色的小猪，其中第 $i$ 只小猪所在的坐标为 $\left(x_i,y_i \right)$。

如果某只小鸟的飞行轨迹经过了 $\left( x_i, y_i \right)$，那么第 $i$ 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；

如果一只小鸟的飞行轨迹没有经过 $\left( x_i, y_i \right)$，那么这只小鸟飞行的全过程就不会对第 $i$ 只小猪产生任何影响。

例如，若两只小猪分别位于 $(1,3)$ 和 $(3,3)$，Kiana 可以选择发射一只飞行轨迹为 $y=-x^2+4x$ 的小鸟，这样两只小猪就会被这只小鸟一起消灭。

而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。

这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在【输入格式】中详述。

假设这款游戏一共有 $T$ 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。

## 说明/提示

【样例解释1】

这组数据中一共有两个关卡。

第一个关卡与【问题描述】中的情形相同，$2$ 只小猪分别位于 $(1.00,3.00)$ 和 $(3.00,3.00)$，只需发射一只飞行轨迹为 $y = -x^2 + 4x$ 的小鸟即可消灭它们。

第二个关卡中有 $5$ 只小猪，但经过观察我们可以发现它们的坐标都在抛物线 $y = -x^2 + 6x$上，故 Kiana 只需要发射一只小鸟即可消灭所有小猪。

【数据范围】

| 测试点编号 |   $n\leqslant$ |   $m=$ |  $T\leqslant$ |
| :----------: | :----------: | :----------: | :----------: |
|   $1$ |   $2$ |   $0$ |  $10$ |
|   $2$ |   $2$ |   $0$ |  $30$ |
|   $3$ |   $3$ |   $0$ |  $10$ |
|   $4$ |   $3$ |   $0$ |  $30$ |
|   $5$ |   $4$ |   $0$ |  $10$ |
|   $6$ |   $4$ |   $0$ |  $30$ |
|   $7$ |   $5$ |   $0$ |  $10$ |
|   $8$ |   $6$ |   $0$ |  $10$ |
|   $9$ |   $7$ |   $0$ |  $10$ |
|   $10$ |   $8$ |   $0$ |  $10$ |
|   $11$ |   $9$ |   $0$ |  $30$ |
|   $12$ |   $10$ |   $0$ |  $30$ |
|   $13$ |   $12$ |   $1$ |  $30$ |
|   $14$ |   $12$ |   $2$ |  $30$ |
|   $15$ |   $15$ |   $0$ |  $15$ |
|   $16$ |   $15$ |   $1$ |  $15$ |
|   $17$ |   $15$ |   $2$ |  $15$ |
|   $18$ |   $18$ |   $0$ |  $5$ |
|   $19$ |   $18$ |   $1$ |  $5$ |
|   $20$ |   $18$ |   $2$ |  $5$ |

## 样例 #1

### 输入

```
2
2 0
1.00 3.00
3.00 3.00
5 2
1.00 5.00
2.00 8.00
3.00 9.00
4.00 8.00
5.00 5.00```

### 输出

```
1
1```

## 样例 #2

### 输入

```
3
2 0
1.41 2.00
1.73 3.00
3 0
1.11 1.41
2.34 1.79
2.98 1.49
5 0
2.72 2.72
2.72 3.14
3.14 2.72
3.14 3.14
5.00 5.00```

### 输出

```
2
2
3
```

## 样例 #3

### 输入

```
1
10 0
7.16 6.28
2.02 0.38
8.33 7.78
7.68 2.09
7.46 7.86
5.77 7.44
8.24 6.72
4.42 5.11
5.42 7.79
8.15 4.99```

### 输出

```
6
```

# AI分析结果

# 💡 Kay的C++算法解析：[NOIP 2016 提高组] 愤怒的小鸟 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**状态压缩动态规划（状压DP）**  

🗣️ **初步分析**：  
解决“愤怒的小鸟”问题，关键在于用**最少的抛物线**覆盖所有猪的坐标。由于猪的数量最多只有18只（$n \leq 18$），我们可以用**二进制数表示状态**（比如`101`表示第1、3只猪被覆盖），这就是**状压DP**的核心思想——把“集合”转化为“数字”，从而高效处理子集问题。  

### 状压DP的核心逻辑
- **状态定义**：`dp[S]`表示覆盖集合`S`（`S`是二进制数，每一位代表对应猪是否被覆盖）的猪所需的**最少抛物线数量**。  
- **转移方程**：对于每个状态`S`，找到**第一个未被覆盖的猪**（记为`i`），然后枚举所有**包含`i`的抛物线**（比如`i`和其他猪`j`组成的抛物线，或`i`单独的抛物线），更新`dp[S ∪ line[i][j]] = min(dp[S] + 1, dp[S ∪ line[i][j]])`。其中`line[i][j]`是预处理的**抛物线覆盖集合**（表示经过`i`和`j`的抛物线能覆盖的猪的二进制集合）。  

### 核心难点与解决方案
1. **预处理抛物线覆盖集合**：需要计算每对猪`(i,j)`对应的抛物线（`y=ax²+bx`，`a<0`），并判断其他猪是否在该抛物线上（注意浮点数精度问题，用`eps=1e-8`判断相等）。  
2. **状态转移优化**：直接枚举所有抛物线会导致`O(n²2ⁿ)`的时间复杂度，通过**预处理每个状态的第一个未被覆盖的猪**（`lowunbit`数组），可以将转移优化到`O(n2ⁿ)`（只枚举包含该猪的抛物线）。  
3. **处理单独猪的情况**：对于无法与其他猪组成合法抛物线的猪（比如`a≥0`或`x`坐标相同），需要单独用一条抛物线覆盖（`line[i][i] = 1 << (i-1)`）。  

### 可视化设计思路
我们将用**8位像素风格**（类似FC红白机）展示状压DP的过程：  
- **场景**：屏幕左侧显示`n`个猪的像素点（绿色表示未被覆盖，红色表示被覆盖），右侧显示当前状态的二进制数（比如`000`表示初始状态）。  
- **关键步骤动画**：  
  1. **找到未被覆盖的猪**：用黄色闪烁标记第一个未被覆盖的猪（比如`i=1`）。  
  2. **枚举抛物线**：用蓝色曲线绘制经过`i`和`j`的抛物线，覆盖的猪变成红色（比如`line[1][2]`覆盖猪1、2、4）。  
  3. **更新状态**：右侧二进制数从`000`变为`1011`（对应猪1、2、4被覆盖），同时播放“叮”的音效。  
- **交互设计**：支持“单步执行”（逐步看状态转移）、“自动播放”（加速展示整个过程），以及“重置”（回到初始状态）。  


## 2. 精选优质题解参考

### 题解一：作者AThousandSuns（赞：1142）  
* **点评**：  
  这道题解的**核心亮点**是**`lowunbit`优化**，将状压DP的时间复杂度从`O(n²2ⁿ)`降到了`O(n2ⁿ)`，是考场中的“正解”。  
  - **思路清晰性**：作者明确指出“必须覆盖第一个未被覆盖的猪”，避免了不必要的转移（比如重复覆盖已覆盖的猪）。  
  - **代码规范性**：`lowunbit`数组预处理了每个状态的第一个未被覆盖的猪，`line`数组存储了每对猪对应的抛物线覆盖集合，变量命名清晰（如`dp[S]`表示状态`S`的最少抛物线数）。  
  - **算法有效性**：通过`lowunbit`优化，转移时只需要枚举包含第一个未被覆盖猪的抛物线，大大减少了计算量。例如，对于状态`S=0010`（第2只猪未被覆盖），只需要枚举包含第2只猪的抛物线，而不是所有抛物线。  
  - **实践价值**：代码中的精度处理（`eps=1e-8`）和边界条件（`x[i] == x[j]`时跳过）非常严谨，可直接用于竞赛。  


## 3. 核心难点辨析与解题策略

### 1. 预处理抛物线覆盖集合（精度问题）  
- **难点**：浮点数计算存在误差，直接用`==`判断猪是否在抛物线上会出错。  
- **解决方案**：用`eps=1e-8`判断差值是否小于`eps`（比如`fabs(a*x[k]*x[k] + b*x[k] - y[k]) < eps`）。  
- 💡 **学习笔记**：浮点数比较必须用误差范围，否则会因精度问题导致错误。  

### 2. 状态转移优化（`lowunbit`数组）  
- **难点**：直接枚举所有抛物线会导致时间复杂度过高（`O(n²2ⁿ)`），无法通过大数据。  
- **解决方案**：预处理`lowunbit`数组，存储每个状态的第一个未被覆盖的猪（比如`lowunbit[0010] = 2`）。转移时，只需要枚举包含该猪的抛物线（`line[lowunbit[S]][k]`），减少了枚举量。  
- 💡 **学习笔记**：状压DP的优化往往在于“减少不必要的转移”，找到“必须处理的点”（如第一个未被覆盖的猪）是关键。  

### 3. 处理单独猪的情况  
- **难点**：有些猪无法与其他猪组成合法抛物线（比如`a≥0`或`x`坐标相同），需要单独覆盖。  
- **解决方案**：将`line[i][i]`设为`1 << (i-1)`（表示单独覆盖第`i`只猪的抛物线），在转移时枚举`line[lowunbit[S]][i]`即可。  
- 💡 **学习笔记**：不要忽略“边界情况”（如单独猪），否则会导致状态无法转移到最终状态。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（来自AThousandSuns的题解）  
* **说明**：此代码是状压DP的经典实现，采用`lowunbit`优化，时间复杂度`O(n2ⁿ)`，可通过所有测试点。  
* **完整核心代码**：  
```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-8;
int t,n,m,lines[20][20],lowunbit[1<<20],dp[1<<20];
double x[20],y[20];

void equation(double &a, double &b, double x1, double y1, double x2, double y2) {
    a = (y1*x2 - y2*x1) / (x1*x2*(x1 - x2));
    b = (y1 - a*x1*x1) / x1;
}

int main() {
    // 预处理lowunbit：每个状态的第一个未被覆盖的猪（从1开始计数）
    for(int i=0; i<(1<<18); i++) {
        int j=1;
        for(; j<=18 && (i&(1<<(j-1))); j++);
        lowunbit[i] = j;
    }
    scanf("%d",&t);
    while(t--) {
        memset(lines,0,sizeof(lines));
        memset(dp,0x3f,sizeof(dp));
        dp[0] = 0;
        scanf("%d%d",&n,&m);
        for(int i=1; i<=n; i++) scanf("%lf%lf",x+i,y+i);
        // 预处理lines[i][j]：经过i和j的抛物线覆盖的猪的集合
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=n; j++) {
                if(fabs(x[i]-x[j]) < eps) continue; // x坐标相同，无法构成抛物线
                double a,b;
                equation(a,b,x[i],y[i],x[j],y[j]);
                if(a >= -eps) continue; // a必须小于0
                for(int k=1; k<=n; k++) {
                    if(fabs(a*x[k]*x[k] + b*x[k] - y[k]) < eps) {
                        lines[i][j] |= (1<<(k-1));
                    }
                }
            }
        }
        // 状态转移：枚举所有状态S
        for(int S=0; S<(1<<n); S++) {
            int i = lowunbit[S]; // 第一个未被覆盖的猪
            if(i > n) continue; // 所有猪都被覆盖，跳过
            // 转移1：单独覆盖i（lines[i][i] = 1<<(i-1)）
            dp[S | (1<<(i-1))] = min(dp[S | (1<<(i-1))], dp[S]+1);
            // 转移2：枚举包含i的抛物线（lines[i][j]）
            for(int j=1; j<=n; j++) {
                dp[S | lines[i][j]] = min(dp[S | lines[i][j]], dp[S]+1);
            }
        }
        printf("%d\n",dp[(1<<n)-1]);
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **预处理`lowunbit`**：计算每个状态的第一个未被覆盖的猪（比如`lowunbit[0010] = 2`）。  
  2. **预处理`lines`数组**：对于每对猪`(i,j)`，计算抛物线的`a`和`b`，然后遍历所有猪，判断是否在抛物线上，用二进制位记录（比如`lines[1][2] = 1011`表示覆盖猪1、2、4）。  
  3. **状态转移**：枚举所有状态`S`，找到第一个未被覆盖的猪`i`，然后枚举包含`i`的抛物线（单独覆盖或与其他猪组成），更新`dp`数组。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题  
**《像素小鸟打猪记》**（8位像素风格，类似FC游戏《愤怒的小鸟》）  

### 核心演示内容  
- **场景初始化**：屏幕左侧显示`n`个绿色猪的像素点（比如`n=3`时，显示3个绿色方块），右侧显示当前状态的二进制数（初始为`000`），底部有“单步”“自动”“重置”按钮。  
- **关键步骤动画**：  
  1. **找到未被覆盖的猪**：状态`S=000`（所有猪未被覆盖），第一个未被覆盖的猪是`1`（绿色方块闪烁黄色）。  
  2. **枚举抛物线**：点击“单步”，绘制经过`1`和`2`的蓝色抛物线（`lines[1][2] = 110`），覆盖猪1、2（绿色变为红色），右侧二进制数变为`110`，播放“咻”的音效。  
  3. **更新状态**：状态`S=110`，第一个未被覆盖的猪是`3`（绿色方块闪烁黄色），点击“单步”，绘制单独覆盖`3`的抛物线（`lines[3][3] = 001`），覆盖猪3（绿色变为红色），右侧二进制数变为`111`，播放“胜利”音效。  
- **交互设计**：  
  - “单步”：逐步执行状态转移，每步显示抛物线覆盖的猪和状态变化。  
  - “自动”：加速播放整个过程（每秒2步），适合快速理解流程。  
  - “重置”：回到初始状态（所有猪绿色，状态`000`）。  

### 设计思路  
- **像素风格**：模拟FC游戏的复古感，让学习者更容易专注于核心逻辑（状态转移）。  
- **颜色标记**：绿色表示未被覆盖，红色表示被覆盖，黄色表示当前处理的猪，清晰区分状态。  
- **音效反馈**：“咻”表示发射抛物线，“叮”表示击中猪，“胜利”表示完成，增强互动感。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
状压DP的核心是**用二进制表示集合**，适用于以下场景：  
1. **覆盖问题**：比如用最少的矩形覆盖所有点（类似本题）。  
2. **路径问题**：比如旅行商问题（TSP），用二进制表示已访问的城市。  
3. **计数问题**：比如计算满足条件的子集数量（比如子集和为某个值）。  

### 练习推荐（洛谷）  
1. **洛谷 P1896 [NOIP 2004 提高组] 侦探推理**  
   - 🗣️ **推荐理由**：这道题需要用状压DP表示“已排除的嫌疑人”，巩固集合表示的技巧。  
2. **洛谷 P2396 [NOIP 2013 提高组] 任务调度**  
   - 🗣️ **推荐理由**：这道题需要用状压DP表示“已完成的任务”，学习如何处理任务之间的依赖关系。  
3. **洛谷 P3959 [NOIP 2017 提高组] 宝藏**  
   - 🗣️ **推荐理由**：这道题需要用状压DP表示“已挖掘的宝藏”，学习如何优化状态转移（类似本题的`lowunbit`优化）。  


## 7. 学习心得与经验分享（若有）  
- **精度处理**：浮点数比较必须用误差范围（比如`eps=1e-8`），否则会因精度问题导致错误（比如本题中判断猪是否在抛物线上）。  
- **状压DP优化**：找到“必须处理的点”（如第一个未被覆盖的猪）可以大大减少转移次数，提高效率（比如本题的`lowunbit`优化）。  
- **边界情况**：不要忽略“单独猪”的情况（比如无法与其他猪组成合法抛物线），否则会导致状态无法转移到最终状态。  


## 结语  
本次关于“愤怒的小鸟”的C++解题分析就到这里。状压DP是处理“小集合”问题的有力工具，核心是“将集合转化为数字”，通过状态转移高效求解。希望这份指南能帮助你掌握状压DP的思想，并在后续的练习中举一反三！💪  

如果有任何疑问，欢迎随时提问，我会尽力帮助你！😊

---
处理用时：138.99秒
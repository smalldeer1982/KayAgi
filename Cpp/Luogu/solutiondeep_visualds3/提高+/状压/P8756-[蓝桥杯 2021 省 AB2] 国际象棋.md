# 题目信息

# [蓝桥杯 2021 省 AB2] 国际象棋

## 题目描述

众所周知， “八皇后” 问题是求解在国际象棋棋盘上摆放 $8$ 个皇后，使得两两之间互不攻击的方案数。已经学习了很多算法的小蓝觉得 “八皇后” 问题太简单了，意犹末尽。作为一个国际象棋迷，他想研究在 $N \times M$ 的棋盘上，摆放 $K$ 个马，使得两两之间互不攻击有多少种摆放方案。由于方案数可能很大，只需计算答案除以 $1000000007$ (即 $\left.10^{9}+7\right)$ 的余数。

如下图所示，国际象棋中的马摆放在棋盘的方格内，走 “日” 字, 位于 $(x, y)$ 格的马（第 $x$ 行第 $y$ 列）可以攻击 $(x+1, y+2),(x+1, y-2),(x-1, y+2),(x-1, y-2),(x+2, y+1),(x+2, y-1),(x-2, y+1),(x-2, y-1)$ 共 $8$ 个 格子。

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_68f9131d5c14c1f27e68g-12.jpg)


## 说明/提示

对于 $5 \%$ 的评测用例, $K=1$;

对于另外 $10 \%$ 的评测用例, $K=2$;

对于另外 $10 \%$ 的评测用例, $N=1$;

对于另外 $20 \%$ 的评测用例, $N, M \leq 6, K \leq 5$;

对于另外 $25 \%$ 的评测用例, $N \leq 3, M \leq 20 ， K \leq 12$;

对于所有评测用例, $1 \leq N \leq 6,1 \leq M \leq 100,1 \leq K \leq 20$。 

蓝桥杯 2021 第二轮省赛 A 组 I 题（B 组 J 题）。

## 样例 #1

### 输入

```
1 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
4 4 3```

### 输出

```
276```

## 样例 #3

### 输入

```
3 20 12```

### 输出

```
914051446```

# AI分析结果

# 💡 Kay的C++算法解析：[蓝桥杯 2021 省 AB2] 国际象棋 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：状态压缩动态规划（状压DP）  

🗣️ **初步分析**：  
解决“国际象棋”问题的核心是**状压DP**——将每一列的马的摆放状态用二进制数压缩（如`1`表示放马，`0`表示不放），通过动态规划递推合法方案数。  

### （1）状压DP的核心思想  
可以把每一列的状态看作一个“二进制密码”，比如`n=3`时，`101`表示该列第1行和第3行有马。状压DP的关键是**用状态压缩减少维度**，将原本复杂的棋盘状态转化为可枚举的二进制数，再通过递推计算合法方案。  

### （2）本题的应用场景  
马的攻击范围是“日”字形，因此当前列的马是否合法，**依赖于前两列的状态**（比如当前列的马不能被前一列的马“跳日”攻击，也不能被前两列的马“跳日”攻击）。因此，我们需要用**四维DP数组**记录：  
- 当前处理到第`i`列；  
- 当前列的状态`a`（二进制）；  
- 前一列的状态`b`（二进制）；  
- 已放置的马的数量`k`。  

### （3）核心算法流程  
1. **状态压缩**：将每一列的马的摆放状态压缩为二进制数（如`n=6`时，状态数为`2^6=64`）。  
2. **状态转移**：对于第`i`列，枚举当前列状态`a`、前一列状态`b`、前两列状态`d`，检查`a`与`b`、`a`与`d`是否冲突（即马是否互相攻击），若合法则递推方案数。  
3. **结果统计**：累加所有处理完`m`列、放置`k`个马的合法方案数。  

### （4）可视化设计思路  
为了直观理解状压DP的过程，我们可以设计一个**8位像素风格的动画**：  
- **场景**：模拟`n×m`的棋盘，每列用二进制方块表示（`1`为红色，`0`为灰色）。  
- **动画步骤**：  
  - 初始状态：棋盘为空，DP数组初始化。  
  - 逐列处理：每列的二进制状态从左到右滚动显示，当前列用闪烁效果突出。  
  - 冲突检查：若当前列与前两列有冲突，用红色叉号标记冲突位置，伴随“错误”音效（如`beep`）。  
  - 方案累加：若状态合法，用绿色对勾标记，伴随“正确”音效（如`ding`），并实时更新DP数组的值。  
- **交互**：支持“单步执行”（逐列查看）、“自动播放”（快速演示），以及“重置”功能。  


## 2. 精选优质题解参考

### 题解一（来源：lottle1212，赞16）  
* **点评**：  
  这份题解的思路非常清晰，直接针对问题的核心（马的攻击范围）设计了状压DP状态。代码中的`dp[i][l][j][h]`表示第`i`列、前一列状态`l`、当前列状态`j`、已放`h`个马的方案数，准确覆盖了前两列的冲突检查。**亮点**是用`get_val`函数预处理每个状态的1的数量（马的数量），避免了重复计算；状态转移时的冲突判断（`j`与`k`、`j`与`l`的移位与）非常严谨，确保了方案的合法性。代码风格规范（如变量名`num`、`dp`含义明确），适合初学者模仿。  

### 题解二（来源：gesong，赞7）  
* **点评**：  
  此题解的状态设计（`f[i][j][x][y]`表示第`i`列、当前列状态`x`、前一列状态`y`、已放`j`个马的方案数）与题解一异曲同工，但**亮点**是将冲突检查拆分为“当前列与前一列”（移位2位）和“当前列与前两列”（移位1位）两部分，逻辑更清晰。此外，代码中的`get`函数用`x&=x-1`快速计算1的数量，效率更高。  

### 题解三（来源：Stone_Xz，赞5）  
* **点评**：  
  此题解的**亮点**是用`__builtin_popcount`函数（GCC内置函数）快速计算二进制中1的数量，简化了代码。状态转移时的循环顺序（先枚举当前列，再枚举状态）符合状压DP的常规思路，容易理解。此外，代码中的`swap(n, m)`处理（将行和列交换，适应状压列的需求）非常巧妙，避免了对行的状压（行的数量`m`可能很大，状压行的状态数会爆炸）。  


## 3. 核心难点辨析与解题策略

### （1）关键点1：状态设计  
**难点**：如何用状态压缩表示棋盘状态，同时覆盖马的攻击范围？  
**策略**：由于马的攻击范围涉及前两列，状态必须包含**当前列**和**前一列**的状态（如`dp[i][a][b][k]`中的`a`是当前列状态，`b`是前一列状态）。这样才能检查当前列与前两列的冲突（前一列状态`b`对应前一列，前两列状态`d`对应前两列，通过`dp[i-1][b][d][k-cnt(a)]`递推）。  

💡 **学习笔记**：状态设计的核心是**覆盖所有影响当前决策的历史信息**，本题中是前两列的状态。  

### （2）关键点2：冲突检查  
**难点**：如何判断当前列与前两列的马是否互相攻击？  
**策略**：利用二进制移位和按位与运算：  
- 当前列状态`a`与前一列状态`b`的冲突：`a & (b << 2)`（前一列的马右移2位，是否与当前列的马重叠）或`a & (b >> 2)`（前一列的马左移2位，是否与当前列的马重叠）。  
- 当前列状态`a`与前两列状态`d`的冲突：`a & (d << 1)`（前两列的马右移1位，是否与当前列的马重叠）或`a & (d >> 1)`（前两列的马左移1位，是否与当前列的马重叠）。  

💡 **学习笔记**：二进制移位是状压DP中处理“相邻状态冲突”的常用技巧，需熟练掌握。  

### （3）关键点3：状态转移  
**难点**：如何将前一列的合法方案递推到当前列？  
**策略**：对于当前列状态`a`（含`cnt(a)`个马），枚举前一列状态`b`和前两列状态`d`，若`a`与`b`、`a`与`d`均无冲突，则将`dp[i-1][b][d][k-cnt(a)]`（前一列处理完`k-cnt(a)`个马的方案数）加到`dp[i][a][b][k]`（当前列处理完`k`个马的方案数）中。  

💡 **学习笔记**：状态转移的核心是**累加所有合法的前驱状态的方案数**，需注意“已放马的数量”的递推（`k = 前驱k + 当前列马的数量`）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了题解一、二、三的思路，采用状压列的方式，覆盖了所有核心逻辑。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;
  typedef long long ll;
  const int MOD = 1e9 + 7;
  const int MAXN = 101; // 列数上限
  const int MAXS = 1 << 6; // 状态数上限（n≤6）
  const int MAXK = 21; // 马的数量上限

  int n, m, K;
  ll dp[MAXN][MAXS][MAXS][MAXK]; // dp[i][a][b][k]：第i列，当前列状态a，前一列状态b，已放k个马的方案数
  int cnt[MAXS]; // cnt[s]：状态s的1的数量（马的数量）

  int main() {
      cin >> n >> m >> K;
      // 预处理cnt数组：计算每个状态的1的数量
      for (int s = 0; s < (1 << n); s++) {
          cnt[s] = __builtin_popcount(s);
      }
      // 初始化：第0列（虚拟列），状态0，前一列状态0，已放0个马，方案数1
      dp[0][0][0][0] = 1;
      // 处理第1列到第m列
      for (int i = 1; i <= m; i++) {
          // 枚举当前列状态a
          for (int a = 0; a < (1 << n); a++) {
              // 枚举前一列状态b
              for (int b = 0; b < (1 << n); b++) {
                  // 检查当前列a与前一列b是否冲突（移位2位）
                  if ((a & (b << 2)) || (a & (b >> 2))) continue;
                  // 枚举前两列状态d（即i-1列的前一列状态）
                  for (int d = 0; d < (1 << n); d++) {
                      // 检查当前列a与前两列d是否冲突（移位1位）
                      if ((a & (d << 1)) || (a & (d >> 1))) continue;
                      // 枚举已放马的数量k（当前列a贡献cnt[a]个马）
                      for (int k = cnt[a]; k <= K; k++) {
                          // 递推：dp[i][a][b][k] += dp[i-1][b][d][k - cnt[a]]
                          dp[i][a][b][k] = (dp[i][a][b][k] + dp[i-1][b][d][k - cnt[a]]) % MOD;
                      }
                  }
              }
          }
      }
      // 统计答案：所有处理完m列、放K个马的方案数
      ll ans = 0;
      for (int a = 0; a < (1 << n); a++) {
          for (int b = 0; b < (1 << n); b++) {
              ans = (ans + dp[m][a][b][K]) % MOD;
          }
      }
      cout << ans << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **预处理**：用`__builtin_popcount`计算每个状态的1的数量（马的数量）。  
  2. **初始化**：虚拟第0列，状态为0，方案数为1。  
  3. **逐列处理**：枚举当前列状态`a`、前一列状态`b`、前两列状态`d`，检查冲突后递推方案数。  
  4. **统计答案**：累加所有处理完`m`列、放`K`个马的合法方案数。  

### 题解一核心代码片段赏析  
* **亮点**：用`get_val`函数预处理1的数量，逻辑清晰。  
* **核心代码片段**：  
  ```cpp
  int get_val(int x) {
      int sum = 0;
      while (x) sum += x & 1, x >>= 1;
      return sum;
  }
  // 初始化第1列
  for (int i = 0; i < (1 << n); ++i) {
      num[i] = get_val(i);
      dp[1][0][i][num[i]] = 1;
  }
  ```  
* **代码解读**：  
  - `get_val`函数通过循环计算二进制中1的数量，适合所有编译器（`__builtin_popcount`是GCC内置函数，可能不兼容其他编译器）。  
  - 初始化第1列时，前一列状态为0（虚拟列），所以`dp[1][0][i][num[i]] = 1`表示第1列状态为`i`、放`num[i]`个马的方案数为1。  

💡 **学习笔记**：预处理1的数量是状压DP的常用技巧，可提高代码效率。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题  
**“像素马的棋盘冒险”**（8位像素风格，仿FC游戏）  

### 核心演示内容  
- **棋盘**：`n×m`的像素网格，每列用二进制方块表示（`1`为红色，`0`为灰色）。  
- **状态转移**：逐列显示状态变化，当前列用闪烁效果突出，前两列用半透明效果显示。  
- **冲突检查**：若当前列与前两列有冲突，冲突位置显示红色叉号，伴随“beep”音效；若合法，显示绿色对勾，伴随“ding”音效。  
- **方案统计**：实时显示当前列的方案数（`dp[i][a][b][k]`），用数字滚动效果更新。  

### 设计思路简述  
- **像素风格**：营造复古游戏氛围，降低学习压力；  
- **音效提示**：用不同音效强化冲突与合法的概念，帮助记忆；  
- **实时更新**：通过数字滚动效果显示方案数，直观展示DP递推的过程。  

### 动画帧步骤  
1. **初始化**：棋盘为空，显示“开始”按钮，背景音乐（8位风格）响起。  
2. **第1列处理**：枚举所有状态（如`n=3`时，`000`、`001`、`010`等），每个状态的方块从左到右滑入，显示`cnt(a)`个马的数量。  
3. **第2列处理**：枚举当前列状态`a`、前一列状态`b`，检查冲突：  
   - 若冲突，显示红色叉号，“beep”音效响起，跳过该状态；  
   - 若合法，显示绿色对勾，“ding”音效响起，更新`dp[2][a][b][cnt(a)]`的值。  
4. **第3列及以后**：重复步骤3，逐列处理，直到第`m`列。  
5. **结果显示**：统计所有`dp[m][a][b][K]`的和，用大字体显示答案，伴随“胜利”音效（如`fanfare`）。  

### 交互设计  
- **单步执行**：点击“下一步”按钮，逐列处理；  
- **自动播放**：点击“自动”按钮，快速演示所有列的处理过程（速度可调）；  
- **重置**：点击“重置”按钮，回到初始状态，重新开始。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
状压DP适用于**状态空间小、决策依赖历史信息**的问题，比如：  
- **棋盘放置问题**：如“八皇后”（状压行）、“炮兵阵地”（状压行，依赖前两行）；  
- **状态压缩优化**：如“旅行商问题”（状压访问过的城市）、“子集问题”（状压子集）。  

### 练习推荐（洛谷）  
1. **洛谷 P1896 [SCOI2005] 互不侵犯**  
   🗣️ **推荐理由**：状压DP的经典入门题，要求放置国王，互不攻击，思路与本题类似（依赖前一行状态），适合巩固状压DP的基础。  
2. **洛谷 P2704 [NOI2001] 炮兵阵地**  
   🗣️ **推荐理由**：状压DP的进阶题，要求放置炮兵，互不攻击，依赖前两行状态，与本题的马的攻击范围（依赖前两列）逻辑一致，适合提升状压DP的应用能力。  
3. **洛谷 P3959 [NOIP2017 提高组] 宝藏**  
   🗣️ **推荐理由**：状压DP的综合题，要求寻找宝藏的最小代价，状态压缩访问过的节点，适合锻炼状压DP的综合思维。  


## 7. 学习心得与经验分享（若有）  
**参考经验（来自题解作者lottle1212）**：  
“我在解决这个问题时，最初没有考虑到马的攻击范围涉及前两列，导致状态设计错误（只记录了当前列和前一列的状态），结果答案总是不对。后来通过画图模拟马的攻击范围，才意识到需要记录前两列的状态，修改状态设计后才通过了所有测试用例。”  

**点评**：这位作者的经验非常典型。在状压DP中，**状态设计是核心**，必须覆盖所有影响当前决策的历史信息。如果状态设计错误，即使代码逻辑正确，也无法得到正确答案。解决方法是**画图模拟**，直观理解问题中的依赖关系（如马的攻击范围），从而设计出正确的状态。  


## 结语  
本次关于“国际象棋”的C++解题分析就到这里。状压DP是一种非常 powerful 的算法，适合处理状态空间小的问题。通过本题的学习，希望大家能掌握状压DP的核心思想（状态压缩、状态转移、冲突检查），并能举一反三，解决更多类似的问题。记住，编程能力的提升在于**持续练习**和**深入思考**，下次我们再一起探索新的编程挑战！💪

---
处理用时：171.68秒
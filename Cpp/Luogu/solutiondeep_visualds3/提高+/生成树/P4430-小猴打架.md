# 题目信息

# 小猴打架

## 题目描述

一开始森林里面有 $N$ 只互不相识的小猴子，它们经常打架，但打架的双方都必须不是好朋友。每次打完架后，打架的双方以及它们的好朋友就会互相认识，成为好朋友。经过 $N-1$ 次打架之后，整个森林的小猴都会成为好朋友。   
现在的问题是，总共有多少种不同的打架过程。   
比如当 $N=3$ 时，就有 $\{1-2,1-3\}\{1-2,2-3\}\{1-3,1-2\}\{1-3,2-3\}\{2-3,1-2\}\{2-3,1-3\}$ 六种不同的打架过程。 


## 说明/提示

$50\%$ 的数据 $N\le 10^3$。  
$100\%$ 的数据 $N\le10^6$。 

## 样例 #1

### 输入

```
4```

### 输出

```
96```

# AI分析结果


### 💡 Kay的C++算法解析：小猴打架 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`组合数学`（Crucial: Cayley定理 & Prufer编码应用）  
🗣️ **初步分析**：
> 本题本质是**生成树计数问题**，可比喻为在n个孤岛间架桥：每次打架相当于在两个孤岛间架桥，最终所有孤岛连通（形成树）。核心公式：
> $$ \text{答案} = (n-1)! \times n^{n-2} \mod 9999991 $$
> - **难点**：需理解树计数与边顺序的独立性。Cayley定理解决树形态计数（$n^{n-2}$），阶乘$(n-1)!$解决边生成顺序。
> - **可视化设计**：像素动画将展示两个并行过程：
>   - **左画面**：8位像素森林中，小猴按Prufer编码规则逐步连接（删除最小叶子节点时触发"叮"声，连接时亮蓝光）
>   - **右画面**：边生成顺序排列（$(n-1)!$部分），每条边出现时播放"咔嚓"连接音效
> - **游戏化**：每成功构建一棵树解锁"关卡"，胜利时播放8-bit胜利BGM

#### 2. 精选优质题解参考
**题解一（来源：da32s1da）**  
* **点评**：直击核心公式，代码简洁高效（8行）。变量`ans`清晰体现分步计算：先算$n^{n-2}$再乘阶乘。边界处理严谨（循环范围精确），空间复杂度$O(1)$，竞赛实用性强。  

**题解二（来源：DPair）**  
* **点评**：理论解释最完整，独创性证明Prufer编码与树的双射关系。代码与理论高度一致，`for`循环边界明确（`i<=n-2`和`i<=n-1`分离），避免混淆指数与阶乘计算。  

**题解三（来源：ghj1222）**  
* **点评**：提供**矩阵树定理**的替代推导视角，拓展思维。通过初等变换将基尔霍夫矩阵化为上三角阵，直观展示$N^{N-2}$来源。代码中`(i+1)`巧妙合并阶乘计算（$i$从1开始）。

---

#### 3. 核心难点辨析与解题策略
1. **关键点1：问题抽象为生成树计数**  
   * **分析**：需识别"打完架成好朋友"本质是图的连通过程，最终形成树结构（无环连通图）。优质题解均通过Cayley定理跳过复杂图论推导。
   * 💡 **学习笔记**：现实问题 → 图论模型转化是组合数学解题核心技能。

2. **关键点2：分离形态计数与顺序计数**  
   * **分析**：树形态数($n^{n-2}$)和边生成顺序($(n-1)!$)相互独立。乘法原理是本题基石，需注意$n^{n-2}$中$n-2$来自Prufer编码长度。
   * 💡 **学习笔记**：计数问题中，独立事件用乘法，相关事件用排列/组合。

3. **关键点3：大数取模实现技巧**  
   * **分析**：$n≤10^6$需循环取模。所有优质题解采用`ans=(ans*n)%mod`而非`pow(n,n-2)`，避免溢出。关键变量`ans`用`long long`保证中间结果不越界。
   * 💡 **学习笔记**：循环取模时，乘法和取模需交替进行（$a \times b \mod p = ((a \mod p) \times (b \mod p)) \mod p$）。

### ✨ 解题技巧总结
- **模型转化技巧**：将动态过程（打架）转化为静态图论结构（树）
- **组合分解技巧**：将复杂计数拆分为独立子问题（形态 × 顺序）
- **模运算防溢出**：在循环内逐次取模，优先用`long long`存储中间结果

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include <cstdio>
const int mod = 9999991;
int main() {
    int n; scanf("%d", &n);
    long long ans = 1;
    for (int i = 1; i <= n - 2; i++) // 计算n^(n-2)
        ans = (ans * n) % mod; 
    for (int i = 1; i <= n - 1; i++) // 乘(n-1)!
        ans = (ans * i) % mod; 
    printf("%lld", ans);
}
```
* **代码解读概要**：  
  > 分两阶段计算：首阶段`n-2`次循环得$n^{n-2}$，次阶段`n-1`次循环累积阶乘。全程用`long long`防溢出，每步取模保证值域。

**题解一片段（da32s1da）**  
```cpp
for (int i = 1; i <= n-2; i++) 
    ans = (ans * n) % mod;    // 幂计算
for (int i = 1; i <= n-1; i++) 
    ans = (ans * i) % mod;    // 阶乘计算
```
* **亮点**：逻辑分区明确，变量名`ans`自解释  
* **学习笔记**：循环计数器`i`仅控制次数，不参与运算，避免污染主逻辑  

**题解二片段（ghj1222）**  
```cpp
for (int i = 1; i <= n - 2; i++)
    ans = ans * n % mod * (i + 1) % mod;
```
* **亮点**：单循环合并计算$n^{n-2} \times (n-1)!$，`(i+1)`巧用循环变量构造阶乘  
* **学习笔记**：数学等价变换可减少循环次数（但降低可读性）  

---

#### 5. 算法可视化：像素动画演示  
**主题**：`《猴子连通大作战》`（8-bit像素风 + 双线程演示）  
**设计思路**：左半屏演示Prufer编码生成（树形态计数），右半屏演示边生成顺序（阶乘）。通过对比强调独立性。  

**关键帧流程**：  
1. **初始化**（FC音效启动）：  
   - 像素猴分散在网格，控制面板含`单步/自动`按钮和速度滑块  
   <img src="https://via.placeholder.com/150?text=Start" width=100/>  

2. **左屏-Prufer编码生成**（步进触发"滴"声）：  
   - **帧1**：高亮最小叶子猴（红色闪烁），删除时播放"碎裂"音效  
   - **帧2**：记录相邻猴编号到编码区，触发"打字机"音效  
   - **帧3**：重复直至剩两猴，编码区显示$n^{n-2}$种可能  

3. **右屏-边生成顺序**（每步触发"咔嚓"声）：  
   - 随机顺序亮起边（黄→绿），完成时显示$(n-1)!$种排列  
   <img src="https://via.placeholder.com/150?text=Edge" width=100/>  

4. **胜利状态**：  
   - 双屏同时完成时，播放《超级玛丽》过关BGM  
   - 屏幕中央显示最终答案：$(n-1)! \times n^{n-2} \mod p$  

---

#### 6. 拓展练习
- **通用迁移场景**：  
  1. 网络布线方案数（无环连通）  
  2. 分子化学键计数（树形结构）  
  3. 游戏关卡连通路径规划  

- **洛谷推荐**：  
  1. **P4981** 父子  
     🗣️ 直接应用Cayley定理，巩固树计数基础  
  2. **P2290** 无根树计数  
     🗣️ 拓展Prufer编码处理带度数限制场景  
  3. **P2624** 明明的烦恼  
     🗣️ 强化组合思维，处理带约束的树计数  

---

#### 7. 学习心得摘录
> **经验分享（DPair）**：  
> *"调试时发现$n=3$输出应为6，若得0需检查：1) 未用long long溢出 2) 循环边界错用$n-1$计算指数"*  
> **Kay点评**：边界测试（$n=2,3$）和溢出预防是组合计数题的通用技巧，建议用`(a * b) % mod`而非`a % mod * b % mod`  

> **经验分享（yangshurong）**：  
> *"$n^{n-2}$中指数$n-2$易漏，记住它等于Prufer编码长度"*  
> **Kay点评**：算法命名（如Prufer）可辅助记忆公式结构  

---

通过本指南，相信你已掌握**生成树计数**的核心思想。记住：组合数学的关键在于`模型转化`与`子问题分解`。下次遇到类似问题，不妨先问自己：  
> 🤔 **这能否抽象为图论问题？**  
> 🤔 **计数对象是否可分解为独立事件？**  

继续加油，编程世界的探索永无止境！🚀

---
处理用时：116.32秒
# 题目信息

# 刷题比赛

## 题目背景

nodgd 是一个喜欢写程序的同学，前不久洛谷 OJ 横空出世，nodgd 同学当然第一时间来到洛谷 OJ 刷题。   
于是发生了一系列有趣的事情，他就打算用这些事情来出题恶心大家……


## 题目描述

洛谷OJ当然算是好地方，nodgd 同学打算和朋友分享一下。于是他就拉上了他的朋友 Ciocio 和 Nicole 两位同学一起刷题。喜欢比赛的他们当然不放过这样一次刷题比赛的机会！

在第 $1$ 天 nodgd,Coicoi,Nicole 都只做了 $1$ 道题。

在第 $2$ 天 nodgd,Coicoi,Nicole 都只做了 $3$ 道题。

他们都有着严格的刷题规则，并且会在每一天都很遵守规则的刷一定量的题。

1、nodgd 同学第 $k+2$ 天刷题数量    
$$a_{k+2}=pa_{k+1}+qa_k+b_{k+1}+c_{k+1}+rk^2+tk+1$$

2、Ciocio 同学第 $k+2$ 天刷题数量      
$$b_{k+2}=ub_{k+1}+vb_k+a_{k+1}+c_{k+1}+w^k$$

3、Nicole 同学第 $k+2$ 天刷题数量    
$$c_{k+2} = xc_{k+1}+yc_k + a_{k+1} + b_{k+1} + z^k+k+2$$

（以上的字母 $p,q,r,t,u,v,w,x,y,z$ 都是给定的常数，并保证是正整数）

于是他们开始了长时间的刷题比赛！一共进行了 $n$ 天

但是时间是可贵的，nodgd 想快速知道第 $n$ 天每个人的刷题数量。  
不过 nodgd 同学还有大量的数学竞赛题、物理竞赛题、英语竞赛题、美术竞赛题、体育竞赛题…… 要做，就拜托你来帮他算算了。

由于结果很大，输出结果 $\bmod \space m$ 的值即可。


## 说明/提示

对于 $100\%$ 的数据，$4\le n \le 10^{16}$，$2\le m \le 10^{16}$，$1\le p,q,r,t,u,v,w,x,y,z \le 100$。

## 样例 #1

### 输入

```
4 10007
2 1 1 1
2 2 3
1 1 2```

### 输出

```
nodgd 74
Ciocio 80
Nicole 59```

# AI分析结果


### 💡 Kay的C++算法解析：刷题比赛 深入学习指南 💡

#### **题目解读与核心算法识别**
✨ **本题主要考察**：矩阵加速线性递推  
🗣️ **初步分析**：
> 解决“刷题比赛”的关键在于构建状态矩阵和转移矩阵。想象一下，算法就像一台精密的复古游戏机🎮，每个齿轮（状态变量）必须完美咬合。本题需要维护11个状态变量（如刷题数、平方项、指数项等），通过矩阵乘法实现高效递推。核心难点在于：
> - 状态矩阵需包含非线性项（k², wᵏ, zᵏ）和常数项
> - 转移矩阵需精确反映递推公式的交叉依赖关系
> - 大数乘法需用龟速乘避免溢出

可视化方案设计：
- 用8位像素风格展示状态矩阵变化，每个变量用不同颜色方块表示
- 高亮当前计算的行转移矩阵（如红色边框）
- 每次矩阵乘法时播放“咔哒”音效，成功时播放FC游戏通关音效

#### **精选优质题解参考**
**题解一（SDqwq）**
* **点评**：  
  思路清晰直白，完整推导11维状态矩阵，代码规范（龟速乘封装完善）。亮点在于：
  - 状态矩阵设计合理，完美融合非线性项
  - 完整初始化逻辑处理边界情况
  - 时间复杂度优化到O(log n)，实践价值高

**题解二（nodgd）**
* **点评**：  
  作者原创题解具权威性，亮点在：
  - 独创状态矩阵排列方式（a/b/c交错存储）
  - 详细注释转移矩阵每个元素的推导依据
  - 强调龟速乘的必要性，体现工程严谨性

**题解三（qwaszx）**
* **点评**：  
  以效率见长，亮点包括：
  - 使用__int128优化大数运算（需注意比赛合规性）
  - 稀疏矩阵乘法优化（跳过零元计算）
  - 完整状态转移表格，便于理解

#### **核心难点辨析与解题策略**
1. **状态矩阵设计**
   * **分析**：需同时维护线性项(a/b/c)、非线性项(k²/wᵏ/zᵏ)和常数项。优质解法用11维向量覆盖所有依赖项
   * 💡 学习笔记：状态矩阵是递推的"记忆容器"，必须完整封装所有影响因子

2. **转移矩阵构造**
   * **分析**：需严格推导每个元素的系数：
     - 平方项通过(k+1)² = k² + 2k + 1 转化
     - 指数项通过wᵏ⁺¹ = w·wᵏ 线性化
   * 💡 学习笔记：转移矩阵是"递推引擎"，每个系数都是公式的机械翻译

3. **大数处理技巧**
   * **分析**：当mod > 10¹⁶时，常规乘法溢出。龟速乘（加法模拟乘法）是关键：
     ```cpp
     ll mul(ll a,ll b){
         ll res=0;
         while(b){
             if(b&1) res=(res+a)%mod;
             a=(a+a)%mod; b>>=1;
         }
         return res;
     }
     ```
   * 💡 学习笔记：龟速乘是解决大数溢出的"安全气囊"

#### **C++核心代码实现赏析**
**通用核心实现（综合优化版）**
```cpp
#include <cstring>
#include <iostream>
using namespace std;
typedef long long ll;
const int SZ=11;

struct Matrix{
    ll a[SZ][SZ];
    Matrix() { memset(a,0,sizeof(a)); }
    Matrix operator*(const Matrix& b){
        Matrix res;
        for(int i=0;i<SZ;i++)
        for(int k=0;k<SZ;k++)
        for(int j=0;j<SZ;j++)
            res.a[i][j] = (res.a[i][j] + mul(a[i][k],b.a[k][j])) % mod;
        return res;
    }
};

Matrix qpow(Matrix base, ll n){
    Matrix res;
    for(int i=0;i<SZ;i++) res.a[i][i]=1;
    while(n){
        if(n&1) res=res*base;
        base=base*base; n>>=1;
    }
    return res;
}

int main(){
    // 初始化转移矩阵（详见题解SDqwq）
    Matrix trans;
    trans.a[0][0]=p; trans.a[0][1]=1; ... // 完整矩阵见报告结尾
    // 初始状态矩阵
    Matrix init;
    init.a[0][0]=3; init.a[1][0]=3; ... // a2,b2,c2,a1,b1,c1,k2,k,1,w,z
    
    Matrix ans = qpow(trans, n-2) * init;
    printf("nodgd %lld\nCiocio %lld\nNicole %lld", 
        ans.a[0][0], ans.a[1][0], ans.a[2][0]);
}
```

**题解一（SDqwq）核心代码片段**
```cpp
// 龟速乘实现
ll quickMul(ll a, ll b) {
    ll res=0; a%=mod; b%=mod;
    while(b) {
        if(b&1) res=(res+a)%mod;
        b>>=1; a=(a+a)%mod;
    }
    return res;
}
// 矩阵乘法
Matrix operator*(Matrix a, Matrix b){
    Matrix res;
    for(int i=1;i<=11;i++)
    for(int j=1;j<=11;j++)
    for(int k=1;k<=11;k++)
        res.a[i][j]=(res.a[i][j]+quickMul(a.a[i][k],b.a[k][j]))%mod;
    return res;
}
```

#### **算法可视化：像素动画演示**
![](https://example.com/path/to/pixel_anim.gif)  
*复古游戏风矩阵运算演示（设计稿）*

1. **场景设计**
   - 11个像素方块代表状态变量（红：a, 蓝：b, 绿：c）
   - 8-bit风格网格展示转移矩阵，当前操作行高亮闪烁
   - 右下角控制面板：步进/播放/调速滑块

2. **动画流程**
   ```mermaid
   graph LR
   A[初始化像素网格] --> B[显示初始状态]
   B --> C{是否结束？}
   C --否--> D[高亮当前转移行]
   D --> E[播放咔哒音效]
   E --> F[更新状态方块位置]
   F --> G[显示新状态矩阵]
   G --> C
   C --是--> H[显示最终结果+通关音效]
   ```

3. **交互细节**
   - **关键操作**：矩阵行乘列时触发像素粒子动画
   - **音效设计**：
     - 计算：8-bit电子音
     - 错误：短促警报声
     - 成功：FC《超级玛丽》过关旋律
   - **游戏化**：将11步转移设计为游戏关卡，每关解锁新角色

#### **拓展练习与相似问题思考**
1. **技巧迁移场景**：
   - 含指数项的递推（如P4910 斐波那契数列）
   - 高维状态压缩（如P5059 中国象棋）
   - 非齐次项处理（如P5175 数列）

2. **洛谷推荐**：
   1. **P1939** - 模板题｜矩阵加速数列  
      *掌握基本矩阵构造*
   2. **P1397** - 二维状态转移｜[NOI2013]矩阵游戏  
      *学习高维矩阵应用*
   3. **P5175** - 非齐次递推｜数列  
      *强化非线性项处理能力*

#### **学习心得与经验分享**
> **参考经验**（来自SDqwq）：  
> “调试时重点验证转移矩阵前3行，通过小规模n值反向推导矩阵正确性”

> **点评**：  
> 这是极其宝贵的调试技巧——通过n=3,4的手算结果验证矩阵，比静态检查更高效。建议学习者养成：
> 1. 对n=3写单元测试
> 2. 输出中间转移矩阵
> 3. 封装矩阵打印函数便于调试

---

**附录：完整转移矩阵**  
$$
\begin{bmatrix}
p & 1 & 1 & q & 0 & 0 & r & t & 1 & 0 & 0 \\
1 & u & 1 & 0 & v & 0 & 0 & 0 & 0 & 1 & 0 \\
1 & 1 & x & 0 & 0 & y & 0 & 1 & 2 & 0 & 1 \\
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 2 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & w & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & z \\
\end{bmatrix}
$$

---
处理用时：243.49秒
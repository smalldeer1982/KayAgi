# 题目信息

# [NOI2016] 区间

## 题目描述

在数轴上有 $n$ 个闭区间从 $1$ 至 $n$ 编号，第 $i$ 个闭区间为 $[l_i,r_i]$ 。

现在要从中选出 $m$ 个区间，使得这 $m$ 个区间共同包含至少一个位置。换句话说，就是使得存在一个 $x$ ，使得对于每一个被选中的区间 $[l_i,r_i]$，都有 $l_i \leq x \leq r_i$ 。

对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。

区间 $[l_i,r_i]$ 的长度定义为 $(r_i-l_i)$ ，即等于它的右端点的值减去左端点的值。

求所有合法方案中最小的花费。如果不存在合法的方案，输出 $-1$。

## 说明/提示

#### 样例输入输出 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/qoddox9k.png)
 
 如图，当 $n=6$，$m=3$ 时，花费最小的方案是选取 $[3,5],[3,4],[1,4]$ 这三个区间，它们共同包含了 $4$ 这个位置，所以是合法的。其中最长的区间是 $[1, 4]$，最短的区间是 $[3, 4]$，所以它的花费是 $(4 - 1) - (4 - 3) = 2$。

#### 数据规模与约定

本题共 20 个测试点，各测试点信息如下表。
| 测试点编号 | $ n= $ | $ m= $ | $ l_i,r_i $ |
|:-:|:-:|:-:|:-:|
| 1 | $ 20 $ | $ 9 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 2 | $ 20 $ | $ 10 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 3 | $ 199 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 4 | $ 200 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 5 | $ 1000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 6 | $ 2000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 7 | $ 199 $ | $ 60 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 8 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 9 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 10 | $ 1999 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 11 | $ 2000 $ | $ 400 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 12 | $ 2000 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 13 | $ 30000 $ | $ 2000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 14 | $ 40000 $ | $ 1000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 15 | $ 50000 $ | $ 15000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 16 | $ 100000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 17 | $ 200000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 18 | $ 300000 $ | $ 50000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 19 | $ 400000 $ | $ 90000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 20 | $ 500000 $ | $ 200000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |

对于全部的测试点，保证 $1 \leq m \leq n$，$1 \leq n \leq 5 \times 10^5$，$1 \leq m \leq 2 \times 10^5$，$0 \leq l_i \leq r_i \leq 10^9$。

## 样例 #1

### 输入

```
6 3
3 5
1 2
3 4
2 2
1 5
1 4```

### 输出

```
2```

# AI分析结果



---
# 💡 Kay的C++算法解析：NOI2016区间 深入学习指南 💡

<introduction>
今天我们要一起攻克NOI2016的“区间”问题。这道题需要我们找到m个重叠的区间，使得它们的长度差最小。通过分析题解，我们会发现关键在于“尺取法+线段树”的巧妙结合。让我们一步步拆解思路，掌握核心技巧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`滑动窗口（尺取法）结合线段树优化`（编程技巧应用）

🗣️ **初步分析**：
解决这道题的关键在于“如何高效找到覆盖同一位置的m个区间，并最小化它们的长度差”。我们可以把问题拆解为两步：  
1. **确定候选区间**：按区间长度排序后，用“尺取法”（双指针）维护一个窗口，窗口内的区间可能是最优解的候选。  
2. **验证覆盖条件**：用线段树维护区间覆盖次数，快速判断是否存在一个点被至少m个区间覆盖。  

简单来说，尺取法像一把“滑动的尺子”，左指针和右指针分别表示当前候选区间的起始和结束。线段树则像一个“计数器”，记录每个位置被覆盖的次数。当右指针扩展时，将新区间加入线段树；当左指针收缩时，移除旧区间。通过这种方式，我们能高效找到最小的长度差。  

核心难点在于：  
- 如何处理大数值的端点（需要离散化）。  
- 如何快速维护覆盖次数并查询最大值（线段树的区间修改与最大值查询）。  
- 尺取法的正确调整（何时移动左/右指针）。  

可视化设计上，我们可以用8位像素风格展示线段树的区间修改过程（比如用不同颜色的方块表示覆盖次数），双指针用“箭头”动态移动，关键操作（如覆盖次数达标）伴随“叮”的音效，增强直观理解。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，以下题解在思路清晰度、代码规范性和算法有效性上表现突出（≥4星）：
</eval_intro>

**题解一：上进的z君（赞：81）**  
* **点评**：该题解逻辑清晰，完整展示了离散化、排序、线段树维护的全流程。代码中对线段树的懒标记处理规范，变量命名（如`L[u]`、`R[u]`）直观，边界条件（如`tree[1]<m`时终止循环）处理严谨。亮点在于将离散化与线段树结合，高效处理了大数值端点问题，是典型的“尺取法+线段树”实现。

**题解二：夏色祭（赞：6）**  
* **点评**：此题解提供了两种思路——二分答案和尺取法。其中尺取法的代码简洁，通过维护线段树根节点的最大值快速判断覆盖条件。作者还详细标注了离散化的正确写法（如`lower_bound`的使用），对新手友好。亮点是对比了不同算法的复杂度，帮助理解优化思路。

**题解三：yqbylty（赞：2）**  
* **点评**：此题解先给出暴力思路（枚举每个点统计覆盖区间），再过渡到正解（尺取法+线段树），适合理解从暴力到优化的过程。代码中线段树的区间修改和最大值查询逻辑清晰，变量命名（如`now`表示当前左指针）易于理解。亮点是通过对比暴力与正解，强调了数据结构优化的重要性。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，我们常遇到以下关键问题，结合优质题解的共性，总结策略如下：
</difficulty_intro>

1.  **关键点1：如何处理大数值的端点？**  
    * **分析**：题目中`l_i, r_i`可达1e9，直接建立线段树会超内存。优质题解普遍采用离散化，将所有端点排序去重后映射到小范围。例如，将所有`l_i, r_i`存入数组排序，用`lower_bound`找到每个端点的离散化后位置。  
    * 💡 **学习笔记**：离散化是处理大数值范围问题的常用技巧，关键是将原始数据映射到连续的整数索引。

2.  **关键点2：如何高效维护覆盖次数？**  
    * **分析**：需要支持区间加（加入区间）和区间减（移除区间），并快速查询最大值。线段树是最佳选择，每个节点维护当前区间的最大覆盖次数和懒标记（延迟更新）。例如，当加入一个区间`[l, r]`时，线段树对`[l, r]`区间加1，查询根节点即可得到全局最大覆盖次数。  
    * 💡 **学习笔记**：线段树适合处理区间修改+区间查询问题，懒标记能显著降低时间复杂度。

3.  **关键点3：如何正确应用尺取法？**  
    * **分析**：按区间长度排序后，右指针`r`不断扩展，将区间加入线段树，直到存在点覆盖次数≥m。此时左指针`l`收缩，移除区间，直到覆盖次数<m。每次收缩前记录当前的最小长度差（`a[r].len - a[l].len`）。  
    * 💡 **学习笔记**：尺取法的核心是“滑动窗口”，利用问题的单调性（长度排序后，最优解是连续区间）减少枚举次数。

### ✨ 解题技巧总结
- **离散化预处理**：将大数值端点映射到小范围，解决线段树内存问题。  
- **线段树维护覆盖次数**：区间修改和最大值查询是关键操作。  
- **尺取法优化枚举**：利用排序后的单调性，将O(n²)复杂度降至O(n log n)。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合多个优质题解，提炼出一个通用的核心实现，展示“离散化+排序+尺取法+线段树”的完整流程。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了上进的z君和夏色祭的题解思路，逻辑清晰，适合学习。  
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <algorithm>
    using namespace std;
    const int MAXN = 5e5 + 10;
    const int INF = 1e9;

    struct Interval {
        int l, r, len;
        bool operator<(const Interval& other) const {
            return len < other.len;
        }
    } intervals[MAXN];

    int discrete[MAXN * 2], tot; // 离散化数组
    int tree[MAXN * 8], add[MAXN * 8]; // 线段树

    // 离散化函数
    void discretize(int n) {
        tot = 0;
        for (int i = 1; i <= n; ++i) {
            discrete[++tot] = intervals[i].l;
            discrete[++tot] = intervals[i].r;
        }
        sort(discrete + 1, discrete + tot + 1);
        tot = unique(discrete + 1, discrete + tot + 1) - discrete - 1;
        for (int i = 1; i <= n; ++i) {
            intervals[i].l = lower_bound(discrete + 1, discrete + tot + 1, intervals[i].l) - discrete;
            intervals[i].r = lower_bound(discrete + 1, discrete + tot + 1, intervals[i].r) - discrete;
        }
    }

    // 线段树下传懒标记
    void push_down(int rt, int l, int r) {
        if (add[rt] == 0) return;
        int mid = (l + r) >> 1;
        tree[rt << 1] += add[rt];
        tree[rt << 1 | 1] += add[rt];
        add[rt << 1] += add[rt];
        add[rt << 1 | 1] += add[rt];
        add[rt] = 0;
    }

    // 线段树区间修改
    void update(int rt, int l, int r, int L, int R, int val) {
        if (L <= l && r <= R) {
            tree[rt] += val;
            add[rt] += val;
            return;
        }
        push_down(rt, l, r);
        int mid = (l + r) >> 1;
        if (L <= mid) update(rt << 1, l, mid, L, R, val);
        if (R > mid) update(rt << 1 | 1, mid + 1, r, L, R, val);
        tree[rt] = max(tree[rt << 1], tree[rt << 1 | 1]);
    }

    int main() {
        int n, m;
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; ++i) {
            int l, r;
            scanf("%d%d", &l, &r);
            intervals[i] = {l, r, r - l};
        }
        discretize(n);
        sort(intervals + 1, intervals + n + 1);

        int ans = INF, left = 0, right = 0;
        while (true) {
            // 右指针扩展，直到覆盖次数≥m
            while (right <= n && tree[1] < m) {
                ++right;
                update(1, 1, tot, intervals[right].l, intervals[right].r, 1);
            }
            if (tree[1] < m) break;
            // 左指针收缩，更新答案
            while (left <= n && tree[1] >= m) {
                ++left;
                update(1, 1, tot, intervals[left].l, intervals[left].r, -1);
            }
            ans = min(ans, intervals[right].len - intervals[left].len);
        }
        printf("%d\n", ans == INF ? -1 : ans);
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入，对区间端点离散化处理。然后按长度排序区间。通过双指针（`left`和`right`）维护窗口，右指针扩展时用线段树增加覆盖次数，左指针收缩时减少覆盖次数。每次窗口调整后，记录最小长度差。

<code_intro_selected>
接下来，我们分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：上进的z君（来源：用户提供）**  
* **亮点**：线段树的懒标记处理规范，离散化步骤清晰。  
* **核心代码片段**：
    ```cpp
    // 线段树更新
    void Update(int rt, int l, int r, int x, int y, int val) {
        if (x > r || y < l) return;
        if (x <= l && y >= r) {
            tree[rt] += val;
            add[rt] += val;
            return;
        }
        int mid = (l + r) / 2;
        Down(rt, l, r); // 下传懒标记
        Update(rt * 2, l, mid, x, y, val);
        Update(rt * 2 + 1, mid + 1, r, x, y, val);
        tree[rt] = max(tree[rt * 2], tree[rt * 2 + 1]);
    }
    ```
* **代码解读**：  
  这段代码实现了线段树的区间修改。`val`为+1或-1，分别对应加入或移除区间。`Down`函数处理懒标记，确保子节点的更新延迟到需要时才执行，避免重复计算。`tree[rt]`维护当前区间的最大覆盖次数，是判断是否满足条件的关键。  
* 💡 **学习笔记**：线段树的懒标记是优化区间修改的核心，能避免频繁更新所有子节点，提升效率。

**题解二：夏色祭（来源：用户提供）**  
* **亮点**：代码简洁，直接维护线段树根节点的最大值。  
* **核心代码片段**：
    ```cpp
    // 主循环
    int last = 1, ans = 1e9;
    For(i, 1, n) {
        update(1, 1, tot, a[i].l, a[i].r, 1);
        while (tree[1].sum >= m) {
            ans = min(ans, a[i].len - a[last].len);
            update(1, 1, tot, a[last].l, a[last].r, -1);
            last++;
        }
    }
    ```
* **代码解读**：  
  `i`是右指针，`last`是左指针。每次右指针扩展后，检查根节点的最大覆盖次数（`tree[1].sum`）。若≥m，说明存在重叠点，此时记录当前长度差（`a[i].len - a[last].len`），并收缩左指针，直到覆盖次数<m。  
* 💡 **学习笔记**：尺取法的关键是“右扩左缩”，利用排序后的单调性减少无效枚举。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观理解“尺取法+线段树”的过程，我们设计一个8位像素风格的动画，模拟线段树的区间修改和双指针的移动。
</visualization_intro>

  * **动画演示主题**：`像素小探险家的区间覆盖之旅`

  * **核心演示内容**：  
    小探险家在数轴上移动，每个区间是一个“彩色条”，长度代表区间长度。线段树用堆叠的像素方块表示，每个方块的高度代表该位置的覆盖次数。双指针用“左右箭头”表示，移动时调整窗口内的区间。

  * **设计思路简述**：  
    8位像素风格（如FC游戏的简洁画面）降低学习压力，颜色区分不同操作（绿色表示加入区间，红色表示移除）。关键操作（如覆盖次数达标）伴随“叮”的音效，增强记忆点。双指针的移动和线段树的更新同步，直观展示算法流程。

  * **动画帧步骤与交互关键点**：

    1. **初始化场景**：  
       屏幕分为两部分：上方是数轴（离散化后的点用小方块表示），下方是线段树结构（每个节点用像素块堆叠）。控制面板有“单步”“自动播放”按钮和速度滑块。

    2. **区间排序与离散化**：  
       所有区间按长度排序，像“彩色条”排队。端点离散化时，原始大数值点被替换为小方块（如1e9→方块1，1e9+1→方块2）。

    3. **右指针扩展（加入区间）**：  
       右箭头（绿色）向右移动，选中当前区间（彩色条变亮），线段树对应区间（l到r）的方块高度+1（颜色变深），伴随“滴”的音效。根节点的最大高度实时显示。

    4. **覆盖次数达标**：  
       当根节点高度≥m时，播放“叮”的胜利音效，所有覆盖该点的区间闪烁（黄色），提示存在重叠。

    5. **左指针收缩（移除区间）**：  
       左箭头（红色）向右移动，移除最左端区间（彩色条变暗），线段树对应区间的方块高度-1（颜色变浅）。每次收缩前记录当前长度差（显示在屏幕上方）。

    6. **结束状态**：  
       所有可能的窗口处理完毕，最小长度差以金色显示，伴随庆祝动画（像素星星闪烁）。

  * **旁白提示**：  
    - “看！右箭头选中了一个区间，线段树对应的位置变高了，覆盖次数增加啦～”  
    - “当根节点的高度达到m，说明有一个点被覆盖了m次，这时候可以记录当前的长度差哦！”  
    - “左箭头开始移动，移除最左边的区间，覆盖次数减少，直到不满足条件为止～”

<visualization_conclusion>
通过这个动画，我们能直观看到线段树如何维护覆盖次数，双指针如何调整窗口，以及最小长度差的计算过程。像素风格和音效让算法学习更有趣！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下题目，巩固“滑动窗口+线段树”的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的核心是“滑动窗口维护候选集+线段树验证条件”，这一思路可迁移到：  
    1. 寻找最长/最短子数组满足某种条件（如和≥k，或包含m个不同元素）。  
    2. 区间覆盖问题（如统计覆盖某点的最多区间数）。  
    3. 动态维护序列的最值（如滑动窗口最大值）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4230 连环病原体**  
        * 🗣️ **推荐理由**：同样需要线段树维护区间覆盖次数，结合滑动窗口优化，适合练习本题思路的变形。  
    2.  **洛谷 P3061 Subsequence**  
        * 🗣️ **推荐理由**：滑动窗口经典题，用前缀和+线段树维护最小值，训练窗口调整与数据结构结合的能力。  
    3.  **洛谷 P1439 排列LCS问题**  
        * 🗣️ **推荐理由**：考察离散化与线段树的结合，适合提升复杂问题的拆解能力。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如EternalEpic提到离散化时的常见错误：
</insights_intro>

> **参考经验 (来自 EternalEpic)**：“我一开始离散化时写错了`lower_bound`的偏移量（错误地减去`uni + 1`），导致线段树操作错误。后来检查发现应该减去`uni`，这才正确映射了端点。”

**点评**：离散化是处理大数值问题的关键，但容易出错。作者的经验提醒我们，`lower_bound`的返回值是迭代器，正确的偏移量计算（减去数组起始地址）能避免映射错误。调试时可打印离散化后的结果，确认是否正确。

---

<conclusion>
通过分析“区间”问题的解法，我们掌握了“尺取法+线段树”的组合技巧，理解了离散化的重要性。编程的核心是将复杂问题拆解为可处理的步骤，并用合适的数据结构优化。希望大家通过练习，能灵活运用这些方法解决更多问题！下次挑战见～💪
</conclusion>

---
处理用时：170.91秒
# 题目信息

# 【模板】扫描线 & 矩形面积并

## 题目描述

求 $n$ 个四边平行于坐标轴的矩形的面积并。

## 说明/提示

对于 $20\%$ 的数据，$1 \le n \le 1000$。  
对于 $100\%$ 的数据，$1 \le n \le {10}^5$，$0 \le x_1 < x_2 \le {10}^9$，$0 \le y_1 < y_2 \le {10}^9$。

Updated on 4.10 by Dengduck（口胡） \& yummy（实现）：增加了一组数据。

## 样例 #1

### 输入

```
2
100 100 200 200
150 150 250 255
```

### 输出

```
18000
```

# AI分析结果



---
# 💡 Kay的C++算法解析：【模板】扫描线 & 矩形面积并 深入学习指南 💡

<introduction>
今天我们来一起分析“【模板】扫描线 & 矩形面积并”这道经典C++编程题。这道题需要计算多个矩形的面积并，涉及扫描线算法与线段树的结合使用。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`扫描线算法 + 线段树应用`（编程技巧应用类）

🗣️ **初步分析**：
解决“矩形面积并”的关键在于用扫描线算法结合线段树高效计算覆盖区间的长度。扫描线的核心思想是想象一根线（如垂直线）从左到右扫描平面，记录与矩形的交点。每遇到矩形的左右边（称为“扫描线事件”），就更新线段树中对应y区间的覆盖次数，从而维护当前扫描线覆盖的总长度。面积则由覆盖长度乘以扫描线移动的水平距离累加得到。

- **题解思路**：所有题解均采用“扫描线+线段树+离散化”的组合。具体步骤为：  
  1. 收集所有矩形的左右边（扫描线事件），并按x坐标排序；  
  2. 对y坐标离散化，缩小线段树维护的范围；  
  3. 用线段树维护当前扫描线覆盖的y区间总长度；  
  4. 遍历扫描线事件，更新线段树并累加面积。  

- **核心难点**：如何高效维护覆盖区间的长度（需处理离散化后的区间、线段树的覆盖次数标记）。  

- **可视化设计**：设计8位像素风格动画，扫描线从左到右移动，每遇到事件点（矩形边）时，线段树节点用不同颜色高亮覆盖区间，动态更新覆盖长度。关键操作（如区间加/减）伴随“叮”的音效，完成时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰性、代码规范性、算法有效性和实践价值，以下题解值得重点学习：
</eval_intro>

**题解一：作者NCC79601（赞：1201）**  
* **点评**：此题解逻辑完整，详细解释了扫描线的核心步骤（事件收集、排序、离散化），并给出线段树的具体实现。代码变量命名规范（如`line`存储扫描线事件，`tree`存储线段树节点），边界处理严谨（如离散化后的区间映射）。亮点在于线段树维护的`sum`（覆盖次数）和`len`（有效长度）的更新逻辑，通过`pushup`函数巧妙合并子节点信息。

**题解二：作者Gu_Pigeon（赞：350）**  
* **点评**：此题解用动画演示辅助理解，代码简洁且注释详细。特别强调离散化的必要性（因坐标范围大），并通过`lower_bound`快速定位离散化后的索引。亮点在于线段树无需延迟标记（因覆盖次数仅需区间加减），直接通过`sum`判断是否覆盖，简化了代码逻辑。

**题解三：作者dzz1537568241（赞：194）**  
* **点评**：此题解详细推导了离散化和线段树的设计，适合新手理解。通过伪代码和分步解释，清晰展示了“如何用线段树维护覆盖长度”。亮点在于对线段树节点含义的明确说明（如`l,r`表示离散化后的区间索引，`len`为实际覆盖长度），帮助学习者理解每一步操作的意义。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，以下三个核心难点需要重点关注：
</difficulty_intro>

1.  **关键点1：离散化处理**  
    * **分析**：由于坐标范围极大（到1e9），直接用原始坐标构建线段树会导致内存爆炸。离散化通过将原始坐标映射到连续的小范围索引（如将1e9的坐标压缩到1e5），大幅减少线段树节点数量。  
    * 💡 **学习笔记**：离散化步骤为：收集所有坐标→排序→去重→用`lower_bound`定位索引。

2.  **关键点2：线段树的设计**  
    * **分析**：线段树需维护每个区间的覆盖次数（`sum`）和有效长度（`len`）。若`sum>0`，说明该区间被覆盖，`len`为区间实际长度；否则`len`为子节点`len`之和。  
    * 💡 **学习笔记**：线段树的`pushup`函数是核心，根据`sum`决定`len`的计算方式。

3.  **关键点3：扫描线事件的排序与处理**  
    * **分析**：扫描线事件（矩形左右边）需按x坐标排序。左边界事件（进入矩形）对应区间加1，右边界事件（离开矩形）对应区间减1。排序时需确保x相同的事件按类型处理（如左边界先于右边界）。  
    * 💡 **学习笔记**：排序时，若x相同，左边界（标记+1）应先处理，避免覆盖长度计算错误。

### ✨ 解题技巧总结
- **离散化技巧**：用`unique`和`lower_bound`快速完成坐标映射，注意去重后的索引范围。  
- **线段树优化**：无需延迟标记，因覆盖次数是区间加减且无需下传，直接通过`sum`判断覆盖状态。  
- **边界处理**：线段树维护的区间是离散化后的索引，实际长度需通过原始坐标计算（如`X[r+1]-X[l]`）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心代码，结合了离散化、线段树和扫描线的关键步骤。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了NCC79601和Gu_Pigeon的题解思路，结构清晰，涵盖离散化、线段树维护和扫描线处理的核心逻辑。  
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    #define lson (x << 1)
    #define rson (x << 1 | 1)
    using namespace std;
    typedef long long ll;

    const int MAXN = 1e6 + 10;
    int n, cnt = 0;
    ll X[MAXN << 1];  // 离散化后的x坐标

    struct ScanLine {
        ll l, r, h;
        int mark;  // 1表示左边界（进入矩形），-1表示右边界（离开矩形）
        bool operator<(const ScanLine& rhs) const {
            return h < rhs.h;
        }
    } line[MAXN << 1];

    struct SegTree {
        int l, r;
        ll len;  // 当前区间被覆盖的总长度
        int sum;  // 覆盖次数（sum>0表示被覆盖）
    } tree[MAXN << 2];

    void build(int x, int l, int r) {
        tree[x].l = l;
        tree[x].r = r;
        tree[x].len = 0;
        tree[x].sum = 0;
        if (l == r) return;
        int mid = (l + r) >> 1;
        build(lson, l, mid);
        build(rson, mid + 1, r);
    }

    void pushup(int x) {
        if (tree[x].sum > 0) {
            tree[x].len = X[tree[x].r + 1] - X[tree[x].l];
        } else {
            tree[x].len = (tree[x].l == tree[x].r) ? 0 : (tree[lson].len + tree[rson].len);
        }
    }

    void update(int x, ll L, ll R, int c) {
        int l = tree[x].l, r = tree[x].r;
        if (X[r + 1] <= L || R <= X[l]) return;  // 无交集
        if (L <= X[l] && X[r + 1] <= R) {  // 完全覆盖当前区间
            tree[x].sum += c;
            pushup(x);
            return;
        }
        update(lson, L, R, c);
        update(rson, L, R, c);
        pushup(x);
    }

    int main() {
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i) {
            ll x1, y1, x2, y2;
            scanf("%lld%lld%lld%lld", &x1, &y1, &x2, &y2);
            X[2 * i - 1] = x1;  // 收集所有x坐标用于离散化
            X[2 * i] = x2;
            line[2 * i - 1] = {x1, x2, y1, 1};  // 左边界事件
            line[2 * i] = {x1, x2, y2, -1};     // 右边界事件
        }
        n <<= 1;  // 总事件数为2n
        sort(line + 1, line + n + 1);  // 按y坐标排序扫描线事件
        sort(X + 1, X + n + 1);
        int tot = unique(X + 1, X + n + 1) - X - 1;  // 去重，得到离散化后的坐标数
        build(1, 1, tot - 1);  // 线段树维护[1, tot-1]区间（对应原始坐标[X[1], X[tot]]）

        ll ans = 0;
        for (int i = 1; i < n; ++i) {  // 最后一条事件无需处理
            update(1, line[i].l, line[i].r, line[i].mark);  // 更新线段树
            ans += tree[1].len * (line[i + 1].h - line[i].h);  // 累加面积
        }
        printf("%lld\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入并收集所有矩形的左右边事件，对y坐标离散化后排序。线段树`tree`维护当前扫描线覆盖的y区间总长度。遍历扫描线事件时，通过`update`函数更新线段树的覆盖次数，并累加每段的面积（覆盖长度×水平距离）。

---

<code_intro_selected>
以下是对优质题解核心代码片段的赏析：
</code_intro_selected>

**题解一（NCC79601）的核心代码片段**  
* **亮点**：线段树的`pushup`函数逻辑清晰，直接根据覆盖次数决定有效长度。  
* **核心代码片段**：
    ```cpp
    void pushup(int x) {
        if (tree[x].sum > 0) {
            tree[x].len = X[tree[x].r + 1] - X[tree[x].l];
        } else {
            tree[x].len = (tree[x].l == tree[x].r) ? 0 : (tree[lson].len + tree[rson].len);
        }
    }
    ```
* **代码解读**：  
  `pushup`函数是线段树的核心。若当前区间被覆盖（`sum>0`），则有效长度为原始坐标区间的长度（`X[r+1]-X[l]`）；否则，有效长度为子节点有效长度之和。这确保了线段树能正确维护覆盖区间的总长度。  
* 💡 **学习笔记**：`pushup`的设计需紧扣覆盖次数与有效长度的关系，避免漏算或重复计算。

**题解二（Gu_Pigeon）的核心代码片段**  
* **亮点**：离散化后直接用`lower_bound`定位索引，简化坐标映射。  
* **核心代码片段**：
    ```cpp
    int main() {
        // ... 读取输入 ...
        sort(line + 1, line + 2 * n + 1, cmp);  // 按x坐标排序
        sort(y + 1, y + 2 * n + 1);
        int len = unique(y + 1, y + 2 * n + 1) - y - 1;  // 离散化
        build(1, 1, len);
        // ... 遍历事件 ...
    }
    ```
* **代码解读**：  
  离散化步骤通过`sort`和`unique`将原始y坐标压缩为连续索引，`lower_bound`快速定位事件对应的离散化索引。这一步大幅减少了线段树的节点数量，避免内存爆炸。  
* 💡 **学习笔记**：离散化是处理大范围坐标的关键，需确保所有事件点的坐标都被包含。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解扫描线和线段树的工作过程，设计一个8位像素风格的动画，模拟扫描线从左到右移动，线段树动态更新覆盖区间的过程。
</visualization_intro>

  * **动画演示主题**：`像素扫描线大冒险`（8位复古风格）

  * **核心演示内容**：  
    扫描线从左到右移动，每遇到矩形的左右边（事件点）时，线段树对应区间的覆盖次数变化，覆盖长度动态更新。最终累加所有区间的面积，得到总面积。

  * **设计思路简述**：  
    采用FC红白机风格的像素画面，用不同颜色区分未覆盖（灰色）、覆盖（绿色）的区间。扫描线移动时，用箭头标记当前事件点，线段树节点用方块堆叠显示，覆盖次数变化时伴随“叮”的音效。完成所有事件处理后，播放胜利音效并显示总面积。

  * **动画帧步骤与交互关键点**：
    1. **初始化场景**：  
       - 屏幕左侧显示原始矩形，右侧显示线段树结构（每个节点为像素方块）。  
       - 控制面板包含“开始/暂停”“单步”“重置”按钮，速度滑块（1x-4x）。  
       - 播放8位风格背景音乐。  

    2. **扫描线启动**：  
       - 扫描线（红色竖线）从最左端开始，按事件点x坐标排序后依次移动。  
       - 每移动到一个事件点，暂停并高亮该事件（左边界为绿色，右边界为红色）。  

    3. **线段树更新**：  
       - 左边界事件：线段树对应y区间的方块变为绿色，覆盖次数加1（显示在方块上），有效长度更新。  
       - 右边界事件：对应方块恢复灰色，覆盖次数减1，有效长度更新。  
       - 每次更新伴随“叮”的音效，线段树根节点的总长度实时显示。  

    4. **面积累加**：  
       - 扫描线移动一段距离后（两事件点x差），计算覆盖长度×距离，累加到总面积（显示在屏幕顶部）。  

    5. **结束动画**：  
       - 所有事件处理完成后，扫描线到达最右端，播放胜利音效，总面积闪烁显示。  

  * **旁白提示**：  
    - “当前扫描线位置：x=100，遇到左边界，覆盖y=100-200区间。”  
    - “线段树节点[2-3]覆盖次数+1，有效长度变为100。”  
    - “扫描线移动了50单位，当前面积增加100×50=5000，总面积=5000。”

<visualization_conclusion>
通过这一动画，学习者可以直观看到扫描线如何触发线段树更新，以及面积如何逐步累加，深刻理解算法的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
扫描线算法和线段树的结合不仅适用于矩形面积并，还可解决其他几何问题。以下是相似问题和拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    扫描线算法的核心是将二维问题转化为一维区间覆盖问题，线段树用于高效维护区间信息。类似地，该思路可用于：  
    - **周长并**（需维护覆盖次数和边界变化）；  
    - **平面点覆盖计数**（统计某区域内的点数）；  
    - **动态矩形面积查询**（支持矩形的添加和删除）。  

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1856 [USACO5.5]矩形周长Picture**  
        * 🗣️ **推荐理由**：需同时计算水平和垂直方向的覆盖边界，深化扫描线在周长并中的应用。  
    2.  **洛谷 P1502 [窗口的星星]**  
        * 🗣️ **推荐理由**：将点转换为矩形，用扫描线求最大覆盖值，训练问题转化能力。  
    3.  **洛谷 P4145 上帝造题的七分钟**  
        * 🗣️ **推荐理由**：二维区间修改与查询，需结合二维线段树或树状数组，拓展扫描线到更高维度。  

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自NCC79601)**：“变量名`y1`在`<cmath>`库中被定义，会冲突，因此避免使用该变量名。”  
> **点评**：变量命名需注意避免与标准库冲突（如`y1`、`next`等）。建议使用`y1_val`或加前缀，提高代码鲁棒性。  

> **参考经验 (来自Gu_Pigeon)**：“离散化时需确保所有事件点的坐标被包含，否则线段树可能遗漏区间。”  
> **点评**：离散化后需检查`unique`的返回值，确保所有事件的y坐标都被映射到正确的索引。  

-----

<conclusion>
本次关于“【模板】扫描线 & 矩形面积并”的C++解题分析就到这里。通过理解扫描线的核心思想、线段树的设计细节，以及离散化的处理技巧，相信大家能轻松解决此类问题。记住，多动手调试、画图辅助理解是掌握算法的关键。下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：179.81秒
# 题目信息

# [CQOI2018] 破解D-H协议

## 题目背景

Diffie-Hellman 密钥交换协议是一种简单有效的密钥交换方法。它可以让通讯双方在没有事先约定**密钥**的情况下，通过**不安全**（可能被窃听）**的信道**确定一个**安全的密钥** $K$，用于加密之后的通讯内容。

## 题目描述

假定通讯双方名为 Alice 和 Bob，协议的工作过程描述如下（其中 $\bmod$ 表示取模运算）：

1. 协议规定一个**固定的**质数 $P$，以及模 $P$ 的一个原根 $g$。**$\boldsymbol P$ 和 $\boldsymbol g$ 的数值都是公开的，无需保密。**

2. Alice 生成一个随机数 $a$，并计算 $A=g^a\bmod P$，将 $A$ 通过不安全信道发送给 Bob。

3. Bob 生成一个随机数 $b$，并计算 $B=g^b\bmod P$，将 $B$ 通过不安全信道发送给 Alice。

4. Bob 根据收到的 $A$ 计算出**密钥** $K=A^b \bmod P$，而 Alice 根据收到的 $B$ 计算出 $K=B^a\bmod P$。

5. 双方得到了相同的 $K$，即 $g^{ab} \bmod P$。$K$ 即之后通讯的加密密钥。

可见，这个过程中可能被窃听的只有 $A,B$，而 $a,b,K$ 是保密的。并且根据 $A,B,P,g$ 这 $4$ 个数，不能轻易计算出 $K$，因此 $K$ 可以作为一个安全的密钥。

当然安全是相对的，该协议的安全性取决于数值的大小，通常 $a,b,P$ 都选取数百位以上的大整数以避免被破解。然而如果 Alice 和 Bob 编程时偷懒，为了避免实现大数运算，选择的数值都小于 $2^{31}$，那么破解他们的密钥就比较容易了。

$T$ 次给定窃听得到的 $A,B$，你需要尝试破解出**密钥** $K$。


## 说明/提示

对于 $30\%$ 的数据，$2\le A,B,P\le 1000$；

对于 $100\%$ 的数据，$2\le A,B<P<2^{31}，2\le g<20，1\le n\le 20$。

$\text{Statement fixed by @Starrykiller.}$

## 样例 #1

### 输入

```
3 31
3
27 16
21 3
9 26```

### 输出

```
4
21
25```

# AI分析结果



---
# 💡 Kay的C++算法解析：[CQOI2018] 破解D-H协议 深入学习指南 💡

<introduction>
今天我们来一起分析“[CQOI2018] 破解D-H协议”这道C++编程题。这道题的核心是利用BSGS算法解决高次同余方程问题，最终求出密钥K。本指南将帮助大家梳理题目思路，理解BSGS算法的核心逻辑，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（BSGS算法）

🗣️ **初步分析**：
解决这道题的关键在于理解BSGS（Baby Step Giant Step，大步小步）算法。BSGS算法是一种用于求解高次同余方程的数学方法，就像“拆分成小步和大步的寻宝游戏”——先预处理一部分“小步”结果存入“藏宝图”（哈希表），再通过“大步”跳跃快速匹配，从而高效找到解。

在本题中，已知$A = g^a \mod P$和$B = g^b \mod P$，我们需要求$K = g^{ab} \mod P$。根据指数运算性质，$K = B^a \mod P$（或$A^b \mod P$），因此只需要用BSGS算法求出$a$（或$b$），再通过快速幂计算即可。

核心难点在于：如何正确实现BSGS算法（包括分块、哈希表存储、边界处理），以及如何将问题转化为高次同余方程求解。优质题解通常通过分块预处理和哈希表优化，将时间复杂度控制在$O(\sqrt{P})$，适用于题目中$P < 2^{31}$的范围。

可视化设计思路：我们将BSGS的“小步预处理”和“大步匹配”过程用8位像素风格展示。例如，用像素方块表示指数$j$的小步计算（存入哈希表），用闪烁的箭头表示大步$i$的跳跃，匹配成功时播放“叮”的音效，并用高亮颜色标记解的位置。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等方面的评估，以下题解因逻辑清晰、实现高效被选为优质参考（≥4星）：
</eval_intro>

**题解一：作者Leonid**
* **点评**：此题解结构清晰，代码规范，注释明确。作者直接点明BSGS算法的核心，并通过`map`实现哈希表，预处理小步结果，大步匹配求解。代码中快速幂和BSGS函数分工明确，变量名（如`qpow`、`BSGS`）易于理解，边界条件（如哈希表清空）处理严谨。实践价值高，适合直接作为模板参考。

**题解二：作者LeavingZzz**
* **点评**：此题解详细解释了BSGS的步骤，强调多组数据下的优化（预处理分子部分），并手写哈希表提升效率。代码中通过自定义哈希表（`Hash_table`结构体）减少了`map`的常数开销，适合对时间要求较高的场景。对分块逻辑（$i \in (0, \lceil\sqrt{P}\rceil]$，$j \in [0, \lceil\sqrt{P}\rceil)$）的解释有助于理解BSGS的核心思想。

**题解三：作者Eason_AC**
* **点评**：此题解强调`unordered_map`的使用（避免`map`的平衡树常数），并优化了快速幂和BSGS的实现。代码简洁，关键步骤（如预处理小步、大步匹配）注释清晰，适合快速上手。作者对`unordered_map`和`map`性能差异的说明，体现了对实际竞赛中“卡常”问题的关注，具有实践指导意义。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，提炼关键策略：
</difficulty_intro>

1.  **关键点1：BSGS算法的分块与哈希表预处理**
    * **分析**：BSGS的核心是将指数$x$拆分为$im-j$，其中$m = \lceil\sqrt{P}\rceil$。预处理阶段需要枚举$j$（小步），计算$A \cdot g^j \mod P$并存入哈希表；匹配阶段枚举$i$（大步），计算$g^{im} \mod P$，在哈希表中查找是否存在对应值。优质题解通过分块（$m \approx \sqrt{P}$）平衡预处理和匹配的时间复杂度，确保整体复杂度为$O(\sqrt{P})$。
    * 💡 **学习笔记**：分块是平衡时间复杂度的关键，选择$m \approx \sqrt{P}$可使预处理和匹配的时间均为$O(\sqrt{P})$。

2.  **关键点2：快速幂的正确实现与模运算**
    * **分析**：快速幂需要处理大数取模，避免溢出。例如，计算$g^m \mod P$时，需逐步平方并取模。优质题解通常使用`long long`类型存储中间结果，并在每一步乘法后取模，确保数值在合理范围内。
    * 💡 **学习笔记**：快速幂的核心是二进制分解指数，每次将指数右移一位，平方底数，遇到奇数位时乘到底数结果中。

3.  **关键点3：哈希表的选择与冲突处理**
    * **分析**：哈希表用于存储小步结果，需处理冲突（不同$j$可能得到相同的$A \cdot g^j \mod P$）。优质题解或使用`unordered_map`（竞赛中更快），或手写哈希表（如LeavingZzz的`Hash_table`），并在插入时处理冲突（如线性探测）。
    * 💡 **学习笔记**：哈希表的冲突处理直接影响算法效率，手写哈希表可通过调整模数（如取大质数）减少冲突。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题转化**：将求$K = g^{ab} \mod P$转化为求$a$（或$b$），再用快速幂计算$B^a \mod P$，简化问题。
- **预处理优化**：对于多组数据，预处理$g^m \mod P$（$m = \lceil\sqrt{P}\rceil$）可减少重复计算。
- **哈希表选择**：竞赛中优先使用`unordered_map`或手写哈希表，避免`map`的高常数。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解的通用核心实现，帮助把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Leonid、Eason_AC等优质题解的思路，使用`unordered_map`优化哈希表，确保高效性和可读性。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <cmath>
    #include <unordered_map>
    using namespace std;
    typedef long long ll;

    ll qpow(ll a, ll b, ll p) {
        ll res = 1;
        a %= p;
        while (b) {
            if (b & 1) res = res * a % p;
            a = a * a % p;
            b >>= 1;
        }
        return res;
    }

    ll bsgs(ll g, ll A, ll p) {
        unordered_map<ll, ll> hash;
        ll m = ceil(sqrt(p)), val = A % p;
        for (ll j = 0; j < m; j++) {
            hash[val] = j;
            val = val * g % p;
        }
        ll gm = qpow(g, m, p), now = 1;
        for (ll i = 1; i <= m; i++) {
            now = now * gm % p;
            if (hash.count(now)) {
                ll j = hash[now];
                return i * m - j;
            }
        }
        return -1;
    }

    int main() {
        ll g, p, n;
        scanf("%lld%lld%lld", &g, &p, &n);
        while (n--) {
            ll A, B;
            scanf("%lld%lld", &A, &B);
            ll a = bsgs(g, A, p);
            printf("%lld\n", qpow(B, a, p));
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码分为快速幂函数`qpow`、BSGS函数`bsgs`和主函数。`qpow`实现快速幂取模；`bsgs`通过分块预处理小步$j$（存入`unordered_map`），再大步$i$匹配求解；主函数读取输入，调用BSGS求$a$，并计算$B^a \mod P$输出。

---
<code_intro_selected>
接下来，剖析优质题解的核心代码片段，看它们如何实现BSGS的关键逻辑。
</code_intro_selected>

**题解一：作者Leonid**
* **亮点**：代码结构清晰，`map`的使用直观，适合新手理解BSGS流程。
* **核心代码片段**：
    ```cpp
    ll BSGS(ll a,ll b,ll p){
        k.clear();
        ll m=ceil(sqrt(p)),ans;
        for(ll i=0;i<=m;i++){
            if(!i){ ans=b%p; k[ans]=i; continue; }
            ans=(ans*a)%p; k[ans]=i;
        }
        ll t=qpow(a,m,p); ans=1;
        for(ll i=1;i<=m;i++){
            ans=(ans*t)%p;
            if(k[ans]) return (i*m - k[ans] + p) % p;
        }
        return -1;
    }
    ```
* **代码解读**：
    这段代码实现了BSGS的核心。首先预处理小步$j$（$i$从0到$m$），计算$b \cdot a^j \mod p$并存入`map`；然后计算大步$i$的$a^{im} \mod p$，在`map`中查找是否存在对应值。若找到，返回$i \cdot m - j$（即$x$）。
* 💡 **学习笔记**：`map`的`clear()`操作确保每次查询独立，避免数据污染。

**题解二：作者LeavingZzz（手写哈希表）**
* **亮点**：手写哈希表减少`map`的常数，适合对时间敏感的场景。
* **核心代码片段**：
    ```cpp
    struct Hash_table{
        static const LL MOD=1999997;
        LL Hash[MOD],V[MOD],stk[MOD],top;
        inline void Insert(LL val,LL mi){
            LL h=val%MOD;
            while(Hash[h]&&Hash[h]!=val) h++;
            Hash[h]=val; V[h]=mi; stk[++top]=h;
        }
        inline LL find(LL val){
            LL h=val%MOD;
            while(Hash[h]&&Hash[h]!=val) h++;
            return Hash[h]==val?V[h]:-1;
        }
    }H;
    ```
* **代码解读**：
    `Hash_table`结构体通过线性探测处理冲突。`Insert`函数将值`val`和对应的指数`mi`存入哈希表（`stk`记录插入位置以便清空）；`find`函数查找`val`对应的指数。这种方式比`map`更快，适合处理大规模数据。
* 💡 **学习笔记**：手写哈希表的关键是选择大质数作为模数（如1999997），减少冲突概率。

**题解三：作者Eason_AC（unordered_map优化）**
* **亮点**：使用`unordered_map`替代`map`，降低常数，避免超时。
* **核心代码片段**：
    ```cpp
    ll bsgs(ll a, ll b, ll p) {
        unordered_map<ll, ll> cjytql;
        b %= p;
        ll t = (ll)sqrt(p) + 1;
        for (ll j = 0; j < t; j++) {
            ll val = b * qpow(a, j, p) % p;
            cjytql[val] = j;
        }
        a = qpow(a, t, p);
        for (ll i = 0; i <= t; i++) {
            ll val = qpow(a, i, p) % p;
            if (cjytql.count(val)) return i * t - cjytql[val];
        }
        return -1;
    }
    ```
* **代码解读**：
    `unordered_map`的`count`操作比`map`的`find`更快。预处理阶段计算$b \cdot a^j \mod p$并存入表；匹配阶段计算$a^{it} \mod p$，查找是否存在对应值。
* 💡 **学习笔记**：`unordered_map`在竞赛中常用于替代`map`，但需注意其在极端情况下可能退化为链表（可通过自定义哈希函数优化）。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解BSGS算法的“小步预处理”和“大步匹配”过程，我们设计一个8位像素风格的动画，让你“看”到算法如何一步步找到解！
</visualization_intro>

  * **动画演示主题**：`像素寻宝：BSGS的小步与大步`

  * **核心演示内容**：演示BSGS算法如何通过预处理小步$j$（存入哈希表），再通过大步$i$匹配，最终找到指数$x = i \cdot m - j$的过程。

  * **设计思路简述**：采用8位像素风格（如FC游戏画面），用不同颜色的像素块表示小步和大步，结合音效提示关键操作（如插入哈希表、匹配成功），增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为左右两部分：左侧是“小步区”（展示$j$的枚举过程），右侧是“大步区”（展示$i$的跳跃过程）。
        - 顶部显示当前$P$、$g$、$A$的值，底部是控制面板（单步、自动播放、调速滑块）。
        - 播放8位风格的轻快背景音乐（如《超级玛丽》的经典旋律）。

    2.  **小步预处理**：
        - 枚举$j = 0$到$m-1$（$m = \lceil\sqrt{P}\rceil$），计算$A \cdot g^j \mod P$。
        - 每个$j$对应一个像素块（颜色随机，如蓝色），从左到右滑动进入“小步区”，并在哈希表位置（用格子表示）显示值和$j$，伴随“叮”的音效。

    3.  **大步匹配**：
        - 枚举$i = 1$到$m$，计算$g^{i \cdot m} \mod P$。
        - 每个$i$对应一个像素块（颜色为红色），从上到下跳跃进入“大步区”，与哈希表中的值对比。
        - 匹配成功时，红色块与对应的蓝色块同时高亮（黄色闪烁），播放“胜利”音效（如《魂斗罗》的得分音），并显示$x = i \cdot m - j$。

    4.  **交互控制**：
        - 单步执行：点击“下一步”，逐步展示小步预处理或大步匹配。
        - 自动播放：选择速度（慢/中/快），算法自动运行，适合观察整体流程。
        - 重置：清空所有像素块和哈希表，重新开始。

  * **旁白提示**：
    - （预处理时）“现在枚举小步$j$，计算$A \cdot g^j \mod P$，并存入哈希表。”
    - （匹配时）“大步$i$跳跃计算$g^{i \cdot m} \mod P$，查找哈希表中是否有对应值。”
    - （成功时）“匹配成功！指数$x = i \cdot m - j$，这就是我们要求的$a$！”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到BSGS算法如何通过分块和哈希表高效求解高次同余方程，理解“小步预处理”和“大步匹配”的协作过程。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
BSGS算法不仅能解决本题，还适用于多种高次同余方程问题。以下是一些拓展练习和相似问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - **离散对数问题**：如求解$a^x \equiv b \mod p$（$p$为质数）。
      - **密钥破解**：类似本题的Diffie-Hellman协议破解，需快速求解指数。
      - **循环节计算**：求$a$在模$p$下的乘法阶（最小$x$使得$a^x \equiv 1 \mod p$）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3846 [TJOI2007]可爱的质数**
          * 🗣️ **推荐理由**：BSGS模板题，适合巩固算法基础。
    2.  **洛谷 P2485 [SDOI2011]计算器**
          * 🗣️ **推荐理由**：结合快速幂、BSGS和扩展欧几里得算法，锻炼综合应用能力。
    3.  **洛谷 P4884 多少个1？**
          * 🗣️ **推荐理由**：变形的BSGS问题，需将问题转化为高次同余方程求解。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验和算法理解，这些对我们很有启发：
</insights_intro>

> **参考经验 (来自作者Eason_AC)**：“使用`unordered_map`而不是`map`，避免因平衡树的高常数导致超时。”
>
> **点评**：在竞赛中，数据结构的选择直接影响程序效率。`unordered_map`的哈希表实现通常比`map`的平衡树更快，特别是在处理大规模数据时。这提醒我们，在实际编码中要根据场景选择合适的数据结构。

> **参考经验 (来自作者LeavingZzz)**：“手写哈希表时，选择大质数作为模数（如1999997），减少冲突概率。”
>
> **点评**：哈希表的冲突处理是关键。大质数模数能使哈希值分布更均匀，降低冲突，提升查找效率。这对优化BSGS算法的实际运行时间非常重要。

-----

<conclusion>
本次关于“[CQOI2018] 破解D-H协议”的分析就到这里。通过理解BSGS算法的核心逻辑、学习优质题解的实现技巧，以及可视化动画的辅助，相信大家已掌握求解高次同余方程的方法。记住，多练习、多总结，编程能力会稳步提升！下次见～💪
</conclusion>

---
处理用时：177.27秒
# 题目信息

# 【模板】原根

## 题目描述

给定整数 $n$，求它的所有原根。

为了减小你的输出量，给出输出参数 $d$，设 $n$ 的所有原根有 $c$ 个，从小到大分别为 $g_1,\ldots,g_c$，你只需要依次输出 $g_d,g_{2d},\ldots,g_{\lfloor\frac{c}{d}\rfloor\times d}$。

---

如果你不了解原根的定义，可以自行查找资料或阅读下列定义：

正整数 $g$ 是正整数 $n$ 的原根，当且仅当 $1\leq g\leq n-1$，且 $g$ 模 $n$ 的阶为 $\varphi(n)$。

## 说明/提示

【样例解释】

对于第 $1,2,4,6$ 组数据，给出的 $n$ 的所有原根都出现在输出中。

对于第 $3$ 组数据，$25$ 的原根集合为 $\{2,3,8,12,13,17,22,23\}$。

对于第 $5$ 组数据，$9$ 的原根集合为 $\{2,5\}$。

【数据范围】

对于 $100\%$ 的数据，$1\leq T\leq 10$，$2\leq n\leq 10^6$，$1\leq d\leq 200$，保证输出的数的总个数不超过 $10^5$。

## 样例 #1

### 输入

```
6
2 1
4 1
25 2
36 1
9 6
18 1
```

### 输出

```
1
1 
1
3 
8
3 12 17 23 
0

2

2
5 11 
```

# AI分析结果



---

# 💡 Kay的C++算法解析：【模板】原根 深入学习指南 💡

<introduction>
今天我们要一起攻克“原根”这一经典数论问题！原根在数论中扮演着重要角色，理解它的性质和求解方法能帮助我们解决许多复杂的数论问题。本指南将带大家梳理原根的核心概念、解题步骤，并通过代码和可视化方案直观理解算法过程。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（原根的存在性判断、最小原根寻找、所有原根生成）

🗣️ **初步分析**：  
原根的定义是“模n的阶等于φ(n)的数”。简单来说，原根g满足两个条件：①g与n互质；②g的幂次在模n下的最小循环节长度恰好是φ(n)（欧拉函数值）。本题要求输出n的所有原根中按d步长选择的结果。

**核心思路**：  
1. **存在性判断**：n必须是2、4、奇素数的幂（p^α）或其两倍（2p^α）。  
2. **最小原根寻找**：枚举法验证，利用原根判定定理（对φ(n)的所有质因子p，g^(φ(n)/p) ≢ 1 mod n）。  
3. **所有原根生成**：若g是最小原根，则所有形如g^k（k与φ(n)互质）的数均为原根。  

**可视化设计**：  
采用8位像素风格动画，模拟原根的寻找过程：  
- 用不同颜色的像素块表示n的类型（如绿色为有效类型，红色为无效）。  
- 动态展示φ(n)的质因数分解过程（如分解成p1、p2...，用闪烁的小方块表示）。  
- 枚举最小原根时，用箭头标记当前测试的数，通过“√”或“×”图标提示是否满足条件。  
- 生成所有原根时，用链式动画展示g的幂次增长，并高亮与φ(n)互质的k值。  

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法效率等维度，以下题解因逻辑严谨、实现高效被选为优质参考：
</eval_intro>

**题解一：作者codecode（赞244）**  
* **点评**：该题解详细证明了原根的存在定理、判定定理及相关数论性质（如阶的性质），理论深度深厚。代码虽未直接给出，但推导过程为实现提供了坚实基础，适合理解原根的数学本质。

**题解二：作者ix35（赞65）**  
* **点评**：代码实现了线性筛预处理欧拉函数和原根存在性标记，逻辑清晰。通过分解φ(n)的质因数并验证最小原根，最终生成所有原根。代码规范（如变量名含义明确），边界处理严谨，适合直接参考。

**题解三：作者0xyz（赞20）**  
* **点评**：优化了原根生成过程，采用线性筛标记与φ(n)互质的数，将复杂度降至O(n)。代码简洁（仅1.17kb），常数小，适合需要高效实现的场景。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决原根问题的关键在于理解其数学性质，并高效实现关键步骤。以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **难点1：原根存在性判断**  
    * **分析**：需判断n是否为2、4、p^α或2p^α（p为奇素数）。可通过预处理标记所有可能的n类型（如线性筛标记）。  
    * 💡 **学习笔记**：存在性判断是解题的第一步，错误判断会导致后续步骤全部失效。

2.  **难点2：最小原根的高效寻找**  
    * **分析**：枚举法需验证每个数是否满足原根条件。王元定理指出最小原根≤n^0.25，因此枚举范围可控。分解φ(n)的质因数后，仅需验证g^(φ(n)/p) ≢ 1 mod n即可。  
    * 💡 **学习笔记**：质因数分解是关键，避免了枚举所有φ(n)的因数。

3.  **难点3：所有原根的生成**  
    * **分析**：利用“若g是原根，则g^k（k与φ(n)互质）也是原根”的性质。通过线性筛标记与φ(n)互质的k值，快速生成所有原根。  
    * 💡 **学习笔记**：互质标记可通过筛法优化，避免重复计算gcd。

### ✨ 解题技巧总结  
- **预处理**：线性筛预处理欧拉函数和原根存在性，减少重复计算。  
- **质因数分解**：快速分解φ(n)，仅验证关键因数，降低时间复杂度。  
- **筛法优化**：标记与φ(n)互质的k值，高效生成所有原根。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，包含原根存在性判断、最小原根寻找及所有原根生成。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：代码综合了ix35和0xyz的思路，预处理欧拉函数，高效判断原根存在性，快速生成所有原根。  
* **完整核心代码**：  
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 5;
int phi[N], prime[N], cnt;
bool is_prime[N], has_root[N]; // has_root[n]表示n是否有原根

void init() {
    // 线性筛预处理欧拉函数和原根存在性
    fill(is_prime, is_prime + N, true);
    is_prime[0] = is_prime[1] = false;
    phi[1] = 1;
    for (int i = 2; i < N; ++i) {
        if (is_prime[i]) {
            prime[++cnt] = i;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= cnt && i * prime[j] < N; ++j) {
            is_prime[i * prime[j]] = false;
            if (i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            } else {
                phi[i * prime[j]] = phi[i] * (prime[j] - 1);
            }
        }
    }
    // 标记有原根的数（2,4,p^α,2p^α）
    has_root[2] = has_root[4] = true;
    for (int i = 2; i <= cnt; ++i) {
        int p = prime[i];
        for (long long j = p; j < N; j *= p) has_root[j] = true;
        for (long long j = 2 * p; j < N; j *= p) has_root[j] = true;
    }
}

int qpow(int a, int b, int mod) {
    int res = 1;
    while (b) {
        if (b & 1) res = 1LL * res * a % mod;
        a = 1LL * a * a % mod;
        b >>= 1;
    }
    return res;
}

vector<int> get_factors(int x) {
    vector<int> factors;
    for (int i = 2; i * i <= x; ++i) {
        if (x % i == 0) {
            factors.push_back(i);
            while (x % i == 0) x /= i;
        }
    }
    if (x > 1) factors.push_back(x);
    return factors;
}

int find_min_root(int n) {
    int ph = phi[n];
    vector<int> factors = get_factors(ph);
    for (int g = 1; g < n; ++g) {
        if (__gcd(g, n) != 1) continue;
        bool ok = true;
        for (int p : factors) {
            if (qpow(g, ph / p, n) == 1) {
                ok = false;
                break;
            }
        }
        if (ok) return g;
    }
    return -1; // 不存在原根（理论上不会执行）
}

vector<int> get_all_roots(int n, int g) {
    vector<int> roots;
    int ph = phi[n];
    vector<bool> co_prime(ph + 1, true);
    vector<int> factors = get_factors(ph);
    for (int p : factors) {
        for (int j = p; j <= ph; j += p) co_prime[j] = false;
    }
    int current = g % n;
    for (int k = 1; k <= ph; ++k) {
        if (co_prime[k]) roots.push_back(current);
        current = 1LL * current * g % n;
    }
    sort(roots.begin(), roots.end());
    return roots;
}

int main() {
    init();
    int T;
    scanf("%d", &T);
    while (T--) {
        int n, d;
        scanf("%d%d", &n, &d);
        if (!has_root[n]) {
            printf("0\n\n");
            continue;
        }
        int g = find_min_root(n);
        vector<int> roots = get_all_roots(n, g);
        printf("%d\n", (int)roots.size());
        for (int i = d - 1; i < (int)roots.size(); i += d) {
            printf("%d ", roots[i]);
        }
        printf("\n");
    }
    return 0;
}
```
* **代码解读概要**：  
  代码通过`init`函数预处理欧拉函数和原根存在性；`find_min_root`利用质因数分解和快速幂寻找最小原根；`get_all_roots`通过筛法标记与φ(n)互质的k值，生成所有原根并排序。

---

<code_intro_selected>
以下是优质题解的核心代码片段及解读：
</code_intro_selected>

**题解二（ix35）核心代码片段**  
```cpp
// 线性筛预处理欧拉函数和原根存在性
void init () {
    phi[1]=1;
    for (int i=2;i<=MAXN-10;i++) {
        if (!q[i]) {pri[++tot]=i,phi[i]=i-1;}
        for (int j=1;j<=tot&&pri[j]*i<=MAXN-10;j++) {
            q[i*pri[j]]=1;
            if (i%pri[j]==0) {
                phi[i*pri[j]]=phi[i]*pri[j];
                break;
            }
            phi[i*pri[j]]=phi[i]*(pri[j]-1);
        }
    }
    rt[2]=rt[4]=1;
    for (int i=2;i<=tot;i++) {
        for (int j=1;(1ll*j*pri[i])<=MAXN-10;j*=pri[i]) {rt[j*pri[i]]=1;}
        for (int j=2;(1ll*j*pri[i])<=MAXN-10;j*=pri[i]) {rt[j*pri[i]]=1;}
    }
}
```
* **亮点**：线性筛预处理欧拉函数和原根存在性，时间复杂度O(n)。  
* **代码解读**：  
  `phi[i]`计算欧拉函数，`rt[i]`标记i是否有原根。通过筛法遍历所有奇素数p的幂次及其两倍，标记为有原根。  
* 💡 **学习笔记**：预处理是高效解题的关键，减少了每次查询的重复计算。

**题解三（0xyz）核心代码片段**  
```cpp
// 线性筛标记与φ(n)互质的数
for(ll i=1;i<=c;i++)
    for(ll j=1;j<s[i]&&s[i]*j<=n;j++)u[s[i]*j]=0;
for(ll i=1;i<=n;i++)
    for(ll j=1;j<=c&&s[j]<=i&&i*s[j]<=n;j++){
        u[i*s[j]]=0;
        if(i%s[j]==0)break;
    }
```
* **亮点**：通过扩展欧拉筛标记与φ(n)互质的数，时间复杂度O(n)。  
* **代码解读**：  
  利用φ(n)的质因数s，标记所有s的倍数，剩余未标记的数即为与φ(n)互质的数。  
* 💡 **学习笔记**：筛法优化避免了重复计算gcd，提升效率。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解原根的寻找过程，我们设计一个8位像素风格的动画，模拟原根的存在性判断、最小原根寻找及所有原根生成。
</visualization_intro>

  * **动画演示主题**：《原根大冒险》——像素小勇士寻找原根宝藏。

  * **核心演示内容**：  
    小勇士从起点出发，依次通过“存在性关卡”（判断n类型）、“质因数分解关卡”（分解φ(n)）、“最小原根关卡”（验证候选数），最终收集所有原根宝藏。

  * **设计思路简述**：  
    采用FC红白机风格，用像素块表示n的类型（绿色为有效，红色为无效），动态文字提示步骤（如“当前n=25，属于p^α，有原根！”）。关键操作（如质因数分解、快速幂验证）配合“叮”的音效，增强记忆点。

  * **动画帧步骤与交互关键点**：  

    1. **初始化场景**：  
       - 背景为像素风格的数论城堡，顶部显示当前n的值（如n=25）。  
       - 控制面板包含“开始”“单步”“重置”按钮，速度滑块（1-10倍速）。  

    2. **存在性判断**：  
       - 小勇士检查n的类型，若为2、4、p^α或2p^α，城堡门打开（绿色光效）；否则关闭（红色光效）。  

    3. **质因数分解**：  
       - φ(n)的数值（如φ(25)=20）分解为质因数（2²×5），用像素方块逐个弹出，闪烁提示。  

    4. **最小原根寻找**：  
       - 候选数g从1开始枚举（像素数字逐个亮起），验证g^φ(n) mod n是否为1（弹出“√”或“×”）。  
       - 对每个质因数p，验证g^(φ(n)/p) mod n是否为1（弹出子窗口显示计算过程）。  

    5. **所有原根生成**：  
       - 最小原根g确定后，生成g的幂次链（如g=2→2,4,8,16...），标记与φ(n)互质的k值（用金色星星标记），对应位置的数即为原根。  

    6. **胜利展示**：  
       - 所有原根收集完成后，像素烟花绽放，播放“胜利”音效，显示原根列表。

  * **旁白提示**：  
    - “现在检查n是否有原根，n=25是奇素数的平方，有原根！”  
    - “分解φ(25)=20的质因数为2和5，需要验证g^10和g^4是否不等于1 mod 25。”  
    - “g=2满足条件，是最小原根！接下来生成所有与20互质的k值对应的g^k。”

<visualization_conclusion>
通过这样的动画，我们能直观看到原根的寻找过程，理解每个步骤的数学意义，降低学习难度。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
原根的应用广泛，掌握其求解方法后，可尝试以下拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    原根的求解涉及欧拉函数、质因数分解、快速幂等数论基础，这些技巧可迁移到离散对数、多项式乘法（如NTT）等问题中。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P5285** - 【模板】多项式快速幂  
      * 🗣️ **推荐理由**：原根在NTT（数论变换）中是关键，本题需用到原根求解模数的选择。  
    2.  **洛谷 P1495** - 中国剩余定理  
      * 🗣️ **推荐理由**：结合原根与同余方程，深化数论综合应用。  
    3.  **洛谷 P6583** - 回首过去  
      * 🗣️ **推荐理由**：原根与离散对数的结合问题，挑战高阶数论思维。  

---

## 7\. 学习心得与经验分享 

<insights_intro>
部分题解作者分享了调试和优化经验，值得借鉴：
</insights_intro>

> **参考经验 (来自0xyz)**：“在优化原根生成时，发现直接枚举gcd会导致时间超限。通过扩展欧拉筛标记与φ(n)互质的数，将复杂度从O(n log n)降至O(n)，运行时间显著减少。”

**点评**：优化算法时，可考虑用筛法替代重复计算（如gcd），尤其在处理大量数据时，时间复杂度的降低能带来显著性能提升。

---

<conclusion>
原根问题是数论中的经典内容，理解其数学性质并掌握高效求解方法是关键。通过本指南的学习，希望大家能熟练应用原根的存在性判断、最小原根寻找及所有原根生成。继续加油，下一个数论高手就是你！💪
</conclusion>

---
处理用时：176.27秒
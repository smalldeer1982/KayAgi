# 题目信息

# 『MdOI R2』Odyssey

## 题目背景

超越音速的极限，不及瑰丽多变的极光；

微弱的脉冲，开拓原本一片混沌的天地；

沉郁的蓝缓缓闪动，史诗的红迎接巅峰；

血色的夕阳尽头，是将夜的星辰；

夜半的满天星空，也会被来自地狱的硝烟掩盖；

炽红炼狱消逝，只金色遗迹永存。

在这里等待着每一位的，都是一段艰苦而璀璨的旅程。

## 题目描述

若正整数 $a$ 与 $b$ 满足：

- $a$ 与 $b$ 的积是一个正整数的 $k$ 次方，即存在正整数 $c$ 使得 $ab=c^k$。

那么我们称 $(a,b)$ 为一组**完美数对**。

---

有一个包含 $n$ 个结点和 $m$ 条边的**有向无环图**，这张图中的每条边都有权值和长度两个属性。

如果一条路径 $P$ 满足**以下条件之一**，则称其为一条**完美路径**：

- $P$ 中仅包含一条边。

- $P$ 从其起点开始依次为 $e_1, e_2, e_3, \ldots e_p$ 这 $p\ (p\ge 2)$ 条边，对于任意的 $1\leq i\leq p-1$，$e_i$ 的权值和 $e_{i+1}$ 的权值组成完美数对。

你需要求出图中最长完美路径的长度，一条路径的长度定义为这条路径上所有边的长度之和。

## 说明/提示

【帮助与提示】  

为方便选手测试代码，本题额外提供两组附加样例供选手使用。  

[样例输入1](https://www.luogu.com.cn/paste/wx1lz6m2) [样例输出1](https://www.luogu.com.cn/paste/28xe7f0x)      

[样例输入2](https://www.luogu.com.cn/paste/efgwngs5) [样例输出2](https://www.luogu.com.cn/paste/5hcpoayt)   

----

【样例解释】

样例中给出的有向无环图如图所示，其中边上的红色数字为边的权值，黑色数字为边的长度：

![](https://cdn.luogu.com.cn/upload/image_hosting/w6x03ksd.png)

最长完美路径为 $2\to 5\to 3$，因为这两条边的权值 $2$ 和 $18$ 满足 $2\times 18=6^2$，是完美数对，此路径长度为 $5+9=14$。

此外，$2\to 1\to 4\to 3,\ \ 2\to 4\to 3,\ \ 1\to 5\to 3$ 等也是完美路径，但不是最长的。

图中，$2\to 1\to 5\to 3$ 长度为 $15$，是一条更长的路径，但它并不是完美路径，因为前两个边权 $24$ 和 $8$ 的乘积为 $192$，不是正整数的平方，即 $(24,8)$ 不是完美数对。

---

【数据范围】

**本题采用捆绑测试。**

对于 $100\%$ 的数据：$1\leq n\leq 10^5,\ \ 1\leq m\leq 2\times 10^5,\ \ 1\leq k\leq 10,\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^5,\ \ 1\leq l\leq 10^4$。

给出的图**不保证弱连通**，图中从一个点到另一个点**可能**存在多条边，但保证给出的图是有向无环图。

| 子任务编号 | $n\leq$ |     $m\leq$      | $w\leq$ | $k\leq$ |  特殊性质  | 分值 |
| :--------: | :-----: | :--------------: | :-----: | :-----: | :--------: | :--: |
| Subtask 1  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $1$   |     无     | $18$ |
| Subtask 2  |  $10$   |       $10$       |  $100$  |  $2$   |     无     | $12$ |
| Subtask 3  |  $600$  | $1.5\times 10^3$ | $10^3$  |   $2$   |     无     | $10$ |
| Subtask 4  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   | $w$ 为素数 | $15$ |
| Subtask 5  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   |     无     | $15$ |
| Subtask 6  |  $600$  | $1.5\times 10^3$ | $10^3$  |  $5$   |     无     | $10$ |
| Subtask 7  | $10^5$  |  $2\times 10^5$  | $10^5$  |  $10$   |     无     | $20$ |



## 样例 #1

### 输入

```
5 7 2
2 5 2 5
5 3 18 9
2 4 6 7
4 3 6 3
2 1 24 2
1 4 6 8
1 5 8 4```

### 输出

```
14```

# AI分析结果



---
# 💡 Kay的C++算法解析：『MdOI R2』Odyssey 深入学习指南 💡

<introduction>
今天我们来一起分析“『MdOI R2』Odyssey”这道题。这道题结合了图论、数论和动态规划（DP）的知识，需要找到有向无环图（DAG）中最长的“完美路径”。通过这份指南，你将掌握如何将复杂问题拆解为质因数分解、状态转移和拓扑排序的组合，并学会用代码高效实现。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（DAG最长路径）、数学（质因数分解与模运算）、动态规划（状态转移）

🗣️ **初步分析**：
解决这道题的关键在于理解“完美数对”的数学性质，并将其转化为图论中的状态转移问题。  
简单来说，两个数 \(a\) 和 \(b\) 是完美数对的条件是它们的乘积是某个正整数的 \(k\) 次方。通过质因数分解，我们可以将 \(a\) 和 \(b\) 的质因子指数对 \(k\) 取模，得到唯一的“特征值”。例如，当 \(k=2\) 时，\(a=2\)（质因数分解为 \(2^1\)）的特征值是 \(2^1\)，对应的互补特征值是 \(2^{2-1}=2^1\)（即 \(b=2\) 时，\(2×2=4=2^2\)）。  

在本题中，我们需要将每条边的权值转换为特征值，并找到其唯一的互补特征值。然后，在DAG上通过拓扑排序进行动态规划（DP），状态定义为“到达某点时，最后一条边的特征值对应的最长路径长度”，转移时利用互补特征值连接相邻边。  

核心难点包括：  
- 如何正确计算边权的特征值（质因数分解后指数模 \(k\)）。  
- 如何高效存储和转移状态（特征值可能很多，需用哈希或map）。  
- 如何结合DAG的拓扑序进行DP，确保状态转移的正确性。  

可视化方案将设计为“像素探险家”动画：用8位像素风格展示DAG的节点和边，边权分解为质因数的过程用“分解动画”（如数字分裂为小方块），状态转移时用颜色高亮当前节点和边，互补特征值用连线标记，关键操作（如状态更新）伴随“叮”的音效，完成最长路径时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性和算法有效性的评估，以下题解质量较高（≥4星），值得重点学习：
</eval_intro>

**题解一：BFqwq（赞：12）**  
* **点评**：此题解思路清晰，通过质因数分解和分层图拓扑排序解决问题。代码规范（如预处理质数表、分层建图），尤其对特征值的计算和分层处理（避免重复边）的细节处理严谨。亮点在于分层图的设计（通过 \(+n\) 区分状态），确保了状态转移的正确性。实践价值高，适合理解DAG上的状态转移。

**题解二：一扶苏一（赞：11）**  
* **点评**：此题解使用双模数哈希处理特征值，避免了状态冲突。代码结构工整（模块化的Init、Topo_sort等函数），变量命名清晰（如`hash`和`ph`分别表示当前特征值和互补特征值）。亮点在于哈希的设计，将质因数分解后的指数模 \(k\) 结果转化为唯一哈希值，高效存储状态。适合学习如何用哈希优化状态存储。

**题解三：zzqDeco（赞：9）**  
* **点评**：此题解简洁明了，直接使用`unordered_map`存储状态，降低了实现复杂度。代码逻辑直白（如`inv`函数计算互补特征值），边界处理（如特征值超过1e5时返回-1）严谨。亮点在于对`map`的灵活运用，适合初学者理解状态转移的核心逻辑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于如何将数学性质转化为图论状态，并高效处理状态转移。以下是关键步骤和策略：
</difficulty_intro>

1.  **关键点1：质因数分解与特征值计算**  
    * **分析**：每条边的权值需分解为质因数，将每个质因子的指数对 \(k\) 取模，得到特征值。例如，\(w=18=2^1×3^2\)（\(k=2\)），指数模2后为 \(2^1×3^0=2\)，互补特征值为 \(2^{2-1}×3^{2-0}=2^1×3^2=18\)（但模2后为 \(2^1\)，即互补特征值为 \(2\)）。  
    * 💡 **学习笔记**：特征值计算是状态转移的基础，需确保质因数分解的正确性和模运算的准确性。

2.  **关键点2：状态存储与转移**  
    * **分析**：状态定义为 \(f[u][s]\)（到达节点 \(u\) 时，最后一条边的特征值为 \(s\) 的最长路径长度）。由于特征值可能很多，需用`map`或哈希表存储。转移时，当前边的互补特征值 \(s'\) 需与下一条边的特征值 \(s\) 匹配。  
    * 💡 **学习笔记**：使用`map`或哈希表可灵活处理稀疏状态，但需注意查询和更新的效率。

3.  **关键点3：拓扑排序与DP结合**  
    * **分析**：DAG的拓扑序保证了状态转移的无后效性。按拓扑序处理节点，确保在处理节点 \(u\) 时，其所有前驱节点的状态已计算完毕。  
    * 💡 **学习笔记**：拓扑排序是DAG上DP的“时间轴”，正确排序是状态转移的前提。

### ✨ 解题技巧总结
- **质因数分解预处理**：预先筛出质数表（如埃氏筛），加速边权的质因数分解。  
- **特征值边界处理**：若互补特征值超过1e5（边权最大值），则该边无法继续延伸，直接作为路径终点。  
- **状态初始化**：单条边的路径长度为自身长度，需初始化为可能的最大值。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结合了特征值计算、拓扑排序和状态转移的关键逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了BFqwq和zzqDeco的思路，包含质因数分解、特征值计算、拓扑排序和状态转移，逻辑清晰且高效。  
* **完整核心代码**：  
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 + 5;
const int MAXW = 1e5;

int n, m, k;
vector<pair<int, int>> primes; // 预处理质数表（这里简化为动态分解）
unordered_map<int, int> dp[MAXN]; // dp[u][s]：节点u，特征值s的最长路径长度
vector<tuple<int, int, int>> edges[MAXN]; // 邻接表：u -> (v, 特征值s, 长度l)

// 计算特征值s和互补特征值inv_s
pair<int, int> get_features(int w) {
    if (k == 1) return {1, 1}; // k=1时所有数互补
    int s = 1, inv_s = 1;
    for (int i = 2; i * i <= w; ++i) {
        if (w % i != 0) continue;
        int cnt = 0;
        while (w % i == 0) { w /= i; cnt++; }
        cnt %= k;
        if (cnt == 0) continue;
        // 计算s：当前质因子指数模k的乘积
        for (int j = 0; j < cnt; ++j) s *= i;
        // 计算inv_s：互补指数（k - cnt）的乘积
        for (int j = 0; j < k - cnt; ++j) {
            inv_s *= i;
            if (inv_s > MAXW) return {-1, -1}; // 互补特征值超出范围
        }
    }
    if (w > 1) {
        // 处理剩余大质因子
        s *= w;
        for (int j = 0; j < k - 1; ++j) {
            inv_s *= w;
            if (inv_s > MAXW) return {-1, -1};
        }
    }
    return {s, inv_s};
}

int main() {
    cin >> n >> m >> k;
    int ans = 0;
    for (int i = 0; i < m; ++i) {
        int u, v, w, l;
        cin >> u >> v >> w >> l;
        auto [s, inv_s] = get_features(w);
        if (s == -1) { // 互补特征值超出范围，仅作为单条边
            ans = max(ans, l);
            continue;
        }
        edges[u].emplace_back(v, s, l);
        // 初始化单条边的路径长度
        dp[v][s] = max(dp[v][s], l);
        ans = max(ans, l);
    }

    // 拓扑排序
    vector<int> in_degree(n + 1, 0);
    for (int u = 1; u <= n; ++u) {
        for (auto [v, s, l] : edges[u]) in_degree[v]++;
    }
    queue<int> q;
    for (int u = 1; u <= n; ++u) {
        if (in_degree[u] == 0) q.push(u);
    }

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (auto [v, s, l] : edges[u]) {
            // 遍历u的所有出边，转移状态
            for (auto [prev_s, len] : dp[u]) {
                if (prev_s == s) { // 前驱特征值与当前边的互补特征值匹配
                    dp[v][s] = max(dp[v][s], len + l);
                    ans = max(ans, dp[v][s]);
                }
            }
            if (--in_degree[v] == 0) q.push(v);
        }
    }

    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
  代码首先预处理每条边的特征值及其互补值，然后初始化单条边的路径长度。通过拓扑排序按顺序处理节点，利用`dp`数组记录到达每个节点时不同特征值的最长路径长度，最终输出最大值。

---

<code_intro_selected>
接下来分析优质题解的核心代码片段，学习其亮点和实现思路：
</code_intro_selected>

**题解一：BFqwq（来源：用户题解）**  
* **亮点**：分层图拓扑排序，通过 \(+n\) 区分状态，避免重复边干扰。  
* **核心代码片段**：  
```cpp
void topo(int w) {
    while (!q.empty()) q.pop();
    for (edge v : g[w]) { // 处理特征值w的边
        in[v.to + n]++;
        add(v.from, v.to + n, v.lg);
    }
    for (edge v : g[f[w]]) { // 处理互补特征值f[w]的边
        in[v.to]++;
        add(v.from + n, v.to, v.lg);
    }
    // 拓扑排序并更新dp
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = h[u]; i; i = e[i].nxt) {
            int v = e[i].to, l = e[i].lg;
            dp[v] = max(dp[v], dp[u] + l);
            ans = max(ans, dp[v]);
            if (--in[v] == 0) q.push(v);
        }
    }
}
```
* **代码解读**：  
  `topo`函数处理特征值 \(w\) 和其互补值 \(f[w]\) 的边，通过分层（节点 \(+n\)）区分状态，确保相邻边的特征值互补。拓扑排序时，更新每个节点的最长路径长度，`dp[v]`记录到达节点 \(v\) 的最长路径。  
* 💡 **学习笔记**：分层图是处理状态转移的有效方法，尤其适合相邻状态有依赖的问题。

**题解二：zzqDeco（来源：用户题解）**  
* **亮点**：使用`unordered_map`存储状态，简化实现。  
* **核心代码片段**：  
```cpp
unordered_map<int, int> map[100010]; // map[u][s]：节点u，特征值s的最长路径

void topsort() {
    while (!q.empty()) {
        int now = q.front(); q.pop();
        for (int i = head[now]; i; i = e[i].next) {
            // 当前边的特征值s和互补特征值inv_s
            map[e[i].to][e[i].s] = max(map[e[i].to][e[i].s], map[now][e[i].inv_s] + e[i].l);
            ans = max(ans, map[e[i].to][e[i].s]);
            if (--ru[e[i].to] == 0) q.push(e[i].to);
        }
    }
}
```
* **代码解读**：  
  `map[u][s]`直接存储节点 \(u\) 在特征值 \(s\) 下的最长路径。拓扑排序中，遍历当前节点的所有出边，用前驱节点的互补特征值状态更新当前节点的特征值状态。  
* 💡 **学习笔记**：`unordered_map`适合稀疏状态的存储，降低空间复杂度。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解特征值转换和状态转移过程，我们设计一个“像素探险家”动画，用8位复古风格展示DAG的遍历和状态更新！
</visualization_intro>

  * **动画演示主题**：像素探险家的完美路径之旅  
  * **核心演示内容**：展示边权分解为质因数的过程，特征值与互补特征值的匹配，以及拓扑排序中状态转移的动态过程。  
  * **设计思路简述**：8位像素风格（如FC游戏画面）降低学习压力，颜色标记（红色为当前边，蓝色为互补边）突出关键步骤，音效（“叮”声提示状态更新）强化记忆。

  * **动画帧步骤与交互关键点**：  
    1. **场景初始化**：  
       - 屏幕左侧显示DAG的像素网格（节点为方块，边为箭头），右侧显示控制面板（单步、自动播放、调速滑块）。  
       - 顶部显示当前处理的边权、特征值和互补特征值（如“边权18 → 分解为2^1×3^2 → 特征值2，互补值2”）。  

    2. **特征值分解动画**：  
       - 选中一条边（如权值18），像素方块分裂为质因数（2和3），指数数字（1和2）弹出并对 \(k=2\) 取模（变为1和0），最终合并为特征值2（用黄色高亮）。  

    3. **状态转移演示**：  
       - 拓扑排序开始，当前节点（如节点2）用绿色高亮。遍历其出边（如到节点5的边，特征值2），查找前驱节点中互补特征值为2的状态（如节点2的前驱无，初始化为边长度5）。  
       - 状态更新时，节点5的状态值（14）用数字弹出，伴随“叮”的音效。  

    4. **最长路径达成**：  
       - 找到最长路径（如节点2→5→3，长度14）时，路径用金色高亮，播放胜利音效（上扬音调），屏幕显示“完美路径完成！”。  

  * **旁白提示**：  
    - “看！这条边的权值18分解后，特征值是2，互补特征值也是2，所以可以连到下一条特征值为2的边。”  
    - “当前节点的状态值更新了，说明通过这条边可以获得更长的路径！”  

<visualization_conclusion>
通过这个动画，你可以直观看到特征值如何转换、状态如何转移，以及拓扑排序如何保证计算顺序的正确性。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可通过以下题目巩固DAG、质因数分解和DP的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的核心是“特征值转换+DAG DP”，这种思路还适用于：  
    - 带权图中相邻边满足特定数学关系的最长路径（如乘积为平方数）。  
    - 状态依赖前一步选择的问题（如字符串匹配中的状态转移）。  
    - 稀疏状态下的动态规划（如用哈希表处理大量状态）。

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1113** - 杂务  
       * 🗣️ **推荐理由**：基础DAG最长路径问题，适合练习拓扑排序与DP的结合。  
    2.  **洛谷 P1807** - 最长路  
       * 🗣️ **推荐理由**：DAG上的最长路径，需处理负权边（本题边权为正，但思路类似）。  
    3.  **洛谷 P6146** - [USACO20FEB]Timeline G  
       * 🗣️ **推荐理由**：带约束的DAG最长路径，强化状态转移的理解。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时遇到的问题（如特征值超出1e5时未处理，导致错误），这些经验对我们很有帮助：
</insights_intro>

> **参考经验 (来自BFqwq题解)**：“在分层图拓扑时，如果 \(x=f_x\) 则相当于建图两遍，数组需开双倍数组。之前因数组开小导致错误，后来调整后通过。”  

**点评**：这位作者的经验提醒我们，在处理分层或状态扩展时，需注意数组大小的边界条件。例如，本题中特征值可能对应多个状态（如节点 \(u\) 和 \(u+n\)），数组大小需足够容纳这些状态，避免越界错误。

---

<conclusion>
通过对“『MdOI R2』Odyssey”的分析，我们掌握了质因数分解、特征值转换、DAG拓扑排序与DP的结合。记住，遇到复杂问题时，拆解为数学性质分析和图论模型是关键！希望你能在练习中进一步巩固这些技巧，挑战更多难题！💪
</conclusion>

---
处理用时：189.86秒
# 题目信息

# 「EZEC-9」GCD Tree

## 题目背景

规定 $\gcd(x,y)$ 表示 $x,y$ 的最大公约数，$\operatorname{lca}(x,y)$ 表示 $x$ 号节点和 $y$ 号节点的最近公共祖先。

## 题目描述

给你 $n$ 个点，编号分别为 $1,2,\ldots,n$，点权分别为 $a_1,a_2,\ldots,a_n$。

请你用这 $n$ 个点构造一棵树，使得 $\forall 1 \le i < j \le n$，$\gcd(a_i, a_j) = a_{\operatorname{lca}(i, j)}$。

若无解，报告之，否则输出树的形态。

## 说明/提示

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（5 points）：$n = 2$。
-  Subtask 2（5 points）：所有 $a_i$ 均相等。
-  Subtask 3（5 points）：$n \le 5$。
-  Subtask 4（10 points）：保证有解。
-  Subtask 5（15 points）：$n \le 100$。
-  Subtask 6（15 points）：$n \le 10^3$。
-  Subtask 7（15 points）：$n \le 3 \times 10^3$。
-  Subtask 8（30 points）：无特殊限制。

对于 $100 \%$ 的数据，$2 \le n \le 10^5$，$1 \le a_i \le 10^6$。

## 样例 #1

### 输入

```
5
1 2 3 4 5
```

### 输出

```
0 1 1 2 1
```

## 样例 #2

### 输入

```
5
1 2 3 4 6
```

### 输出

```
-1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：「EZEC-9」GCD Tree 深入学习指南 💡

<introduction>
今天我们来一起分析“「EZEC-9」GCD Tree”这道题。这道题需要构造一棵满足特殊GCD条件的树，或判断无解。本指南将帮你梳理核心思路、关键算法，并通过可视化方案直观理解过程，最后提供拓展练习。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学与图论结合（基于数论性质的树构造与验证）

🗣️ **初步分析**：
解决这道题的关键在于理解“GCD等于LCA权值”的隐含条件：若两节点的权值的GCD是某个值d，则它们的LCA权值必须是d。这要求树的结构中，每个节点的权值是其所有子节点权值的因数（因为LCA是祖先，权值更小）。

简单来说，这棵树的构造需要满足：**权值大的节点必须是权值小的节点的祖先**（当存在倍数关系时）。例如，若a=4是a=2的倍数，则权值为4的节点应是权值为2的节点的祖先。

- **题解思路对比**：多数题解采用“去重→按权值从大到小构造树→验证合法性”的流程。例如，littleKtian的题解先处理重复节点，再通过枚举倍数设置父亲，最后检查质因数分布是否合法；LZDQ的题解则通过质因数分解验证树的结构是否满足条件。
- **核心算法流程**：构造阶段，按权值从大到小遍历，将未设置父亲的倍数节点的父亲设为当前节点；验证阶段，检查每个质因数的分布是否在一条链上（否则会导致GCD大于LCA权值）。
- **可视化设计**：采用8位像素风格，用不同颜色的方块表示节点（权值越大颜色越深），动画展示节点连接过程（如权值4的节点“吸附”权值2、8的节点作为子节点）；验证时用闪烁的小图标表示质因数，若同一质因数出现在不同子树则红色警告。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等，筛选出以下3篇优质题解：
</eval_intro>

**题解一：作者 littleKtian（赞：10）**
* **点评**：此题解思路非常清晰，从去重处理到倍数构造再到合法性验证，每一步都紧扣题目条件。代码结构工整（如预处理、DFS遍历），变量名（如`fa`表示父亲节点）含义明确。亮点在于将构造与验证合并，通过枚举倍数和质因数分布检查，复杂度仅O(n log n)，适合竞赛参考。

**题解二：作者 LZDQ（赞：6）**
* **点评**：此题解聚焦质因数分解验证，思路巧妙。代码中通过`cnt`数组记录质因数出现次数，`mx`数组记录深度最大的节点，验证时通过跳父节点检查质因数分布是否在一条链上。虽然代码稍显紧凑，但逻辑严密，对质因数的处理是亮点，适合学习数论与树结合的技巧。

**题解三：作者 chager（赞：9）**
* **点评**：此题解通过引理推导（如重复点缩点、因数链条件），为构造树提供了理论支撑。代码中使用线性筛预处理质因数，结合DFS生成所有因数，验证时检查因数链是否合法。引理的提出降低了构造难度，适合理解问题本质。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点主要集中在构造树的规则和验证合法性的方法上。以下是关键步骤的分析：
</difficulty_intro>

1.  **关键点1：如何确定每个节点的父亲？**
    * **分析**：根据条件，若a_i是a_j的倍数，则i应是j的祖先。因此，构造时需按权值从大到小遍历，将未设置父亲的倍数节点的父亲设为当前节点。例如，权值为6的节点会被权值为3的节点（若存在）“收养”，因为3是6的因数且更大的因数可能不存在。
    * 💡 **学习笔记**：权值大的节点优先作为父亲，确保倍数关系转化为祖先关系。

2.  **关键点2：如何验证树的合法性？**
    * **分析**：合法的树要求任意两节点的GCD等于LCA的权值。若存在两个节点u、v，它们的质因数p同时出现在不同子树中，则它们的GCD会包含p，导致大于LCA的权值（不含p）。验证时需检查每个质因数是否仅出现在一条链上。
    * 💡 **学习笔记**：质因数的分布必须“单链化”，否则树不合法。

3.  **关键点3：如何处理重复权值的节点？**
    * **分析**：相同权值的节点可缩成一条链（如权值为2的节点A、B，A是B的父亲），只需处理链顶节点（A）作为代表，其他节点直接连接到链顶。
    * 💡 **学习笔记**：重复节点的处理可简化问题，避免重复计算。

### ✨ 解题技巧总结
- **去重处理**：先将相同权值的节点缩成链，减少后续计算量。
- **倍数枚举**：按权值从大到小枚举倍数，确保父节点的权值是最大的可能因数。
- **质因数验证**：通过质因数分布是否在一条链上，快速判断树的合法性。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，提炼出一个简洁高效的核心实现，帮助大家快速掌握关键逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了littleKtian和LZDQ的题解思路，包含去重、构造树、验证质因数分布的核心逻辑。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 1e5 + 5;
    const int MAXV = 1e6 + 5;

    int n, a[MAXN], fa[MAXN], cnt[MAXV], mx[MAXV], dep[MAXV];
    int val_to_node[MAXV]; // 权值对应的节点编号（去重后）

    int main() {
        scanf("%d", &n);
        // 去重处理，相同权值的节点连成链
        for (int i = 1; i <= n; ++i) {
            scanf("%d", &a[i]);
            if (val_to_node[a[i]]) fa[i] = val_to_node[a[i]];
            else val_to_node[a[i]] = i;
        }
        // 构造树：按权值从大到小，设置倍数节点的父亲
        for (int v = MAXV; v >= 1; --v) {
            if (!val_to_node[v]) continue;
            for (int j = 2 * v; j < MAXV; j += v) {
                if (val_to_node[j] && !fa[val_to_node[j]]) {
                    fa[val_to_node[j]] = val_to_node[v];
                }
            }
        }
        // 检查连通性（总边数应为n-1）
        int edge_cnt = 0;
        for (int i = 1; i <= n; ++i) if (fa[i]) edge_cnt++;
        if (edge_cnt != n - 1) { puts("-1"); return 0; }

        // 验证质因数分布：记录每个质因数的出现次数和最深节点
        for (int i = 1; i <= n; ++i) {
            int u = a[i], f = fa[i] ? a[fa[i]] : 0;
            int c = u / f; // 与父节点的商（f=0时c=1，根节点）
            if (f == 0) continue;
            cnt[c]++;
            dep[u] = dep[f] + 1; // 记录深度
            if (dep[u] > dep[mx[c]]) mx[c] = u;
        }
        // 检查每个质因数是否在一条链上
        for (int p = 2; p < MAXV; ++p) {
            if (cnt[p] == 0) continue;
            int total = cnt[p], current = mx[p];
            int check = 0;
            while (current > 1) { // 向上跳父节点，统计质因数p的出现次数
                if (a[current] / a[fa[current]] % p == 0) check++;
                current = fa[current];
            }
            if (check != total) { puts("-1"); return 0; }
        }
        // 输出父亲数组
        for (int i = 1; i <= n; ++i) printf("%d ", fa[i]);
        return 0;
    }
    ```
* **代码解读概要**：代码首先去重处理相同权值的节点，然后按权值从大到小构造树（设置倍数节点的父亲）。接着检查连通性（边数是否为n-1），最后通过质因数分布验证树的合法性（每个质因数的出现次数与链上统计一致）。

---
<code_intro_selected>
以下是优质题解的核心片段赏析：
</code_intro_selected>

**题解一：作者 littleKtian**
* **亮点**：通过DFS遍历验证子树包含关系，确保所有倍数节点在子树内。
* **核心代码片段**：
    ```cpp
    void dfs(int w) {
        si[w] = 1, hx[w] = ++dfn;
        for (int o_o = lw[w]; o_o; o_o = bi[o_o][0]) {
            int v = bi[o_o][1];
            dfs(v), si[w] += si[v];
        }
    }
    bool gra(const int &x, const int &y) {
        return hx[x] <= hx[y] && hx[y] < hx[x] + si[x];
    }
    ```
* **代码解读**：`dfs`函数计算每个节点的子树大小和DFS序（`hx`），`gra`函数判断节点y是否在x的子树内（通过DFS序范围）。这一步是构造后验证的关键，确保所有倍数节点确实在当前节点的子树中。
* 💡 **学习笔记**：DFS序是判断子树包含关系的高效方法，适合处理树结构的验证问题。

**题解二：作者 LZDQ**
* **亮点**：通过质因数的深度和出现次数验证分布是否合法。
* **核心代码片段**：
    ```cpp
    for (int i = 1; i <= m; i++) {
        if (p[i]) {
            dep[i] = dep[fw[i]] + 1;
            cnt[i/fw[i]]++;
            if (dep[i] > dep[mx[i/fw[i]]]) mx[i/fw[i]] = i;
        }
    }
    ```
* **代码解读**：`dep`记录节点深度，`cnt`统计质因数出现次数，`mx`记录深度最大的节点。通过这些信息，后续验证时只需从最深节点向上跳，统计质因数出现次数是否与总次数一致。
* 💡 **学习笔记**：质因数的深度和出现次数是验证合法性的关键指标，利用深度信息可快速判断分布是否在一条链上。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解树的构造和验证过程，我们设计一个“像素树探险”动画，用8位风格展示节点连接和质因数检查。
</visualization_intro>

  * **动画演示主题**：像素树的GCD冒险
  * **核心演示内容**：构造阶段（节点按权值从大到小连接）、验证阶段（质因数分布检查）。
  * **设计思路简述**：8位像素风格（类似FC游戏）营造轻松氛围，节点用彩色方块表示（权值越大颜色越深），质因数用小图标（如红色三角形表示质因数2）。动画通过步进控制，展示每个节点如何找到父亲，以及质因数如何分布。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：屏幕左侧显示像素网格（节点位置），右侧显示控制面板（单步/自动/调速）。顶部显示当前步骤（构造/验证）。
    2.  **构造阶段**：
        - 权值从大到小遍历，当前节点（如权值6）高亮（黄色闪烁）。
        - 枚举倍数（12、18等），若存在未连接的节点（如权值12），则从当前节点（6）到该节点（12）绘制绿色连接线，伴随“叮”音效。
        - 重复此过程，直到所有节点连接完成。
    3.  **验证阶段**：
        - 质因数图标（如红色三角形代表2）出现在每个节点旁（根据`a[i]/a[fa[i]]`的质因数）。
        - 检查质因数分布：选中质因数2，所有含该因数的节点（如权值4、8）高亮。若它们不在一条链上（如4在左子树，8在右子树），则红色警告并播放“滴滴”音效；否则绿色通过。
    4.  **交互控制**：支持单步执行（逐节点连接/检查）、自动播放（调速滑块控制速度）、重置（重新开始演示）。

  * **旁白提示**：
    - 构造阶段：“现在处理权值6的节点，它将收养所有未连接的倍数节点（如12、18）。”
    - 验证阶段：“检查质因数2的分布，若出现在不同子树，树不合法！”

<visualization_conclusion>
通过这个动画，我们能直观看到树的构造逻辑和质因数分布的验证过程，更好地理解GCD与LCA的关系。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握此题后，可尝试以下题目巩固数论与树构造的结合应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 本题的“倍数关系→祖先关系”思想可用于构造其他条件树（如LCM树）。
    - 质因数分布验证的方法可用于处理类似“路径上的质因数限制”问题。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1352 没有上司的舞会**：树形DP经典题，练习树结构的动态规划。
    2.  **洛谷 P3366 最小生成树**：图论基础题，练习树构造的贪心策略。
    3.  **洛谷 P2014 选课**：树形依赖问题，练习子树选择的动态规划。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时遇到的问题，例如：
</insights_intro>

> 参考经验（来自作者 littleKtian）：“在验证子树包含关系时，最初没考虑DFS序的范围，导致误判子树关系。后来通过DFS预处理子树大小和序，才正确解决。”

**点评**：这位作者的经验提醒我们，处理树的子树关系时，DFS序是非常有效的工具。预处理子树大小和序可以避免复杂的递归判断，提高效率。学习时，遇到树结构的包含问题，不妨试试DFS序！

-----

<conclusion>
本次关于“GCD Tree”的分析就到这里。希望通过构造逻辑、验证方法和可视化演示，你能更深入理解这道题的核心。记住，多动手调试、多思考质因数的分布，是解决此类问题的关键。下次见！💪
</conclusion>

-----

---
处理用时：147.17秒
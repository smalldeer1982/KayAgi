# 题目信息

# [Sloi 2024]D1T1 精卫

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/p38htsuu.png)

## 题目描述

$f(x)$ 为积性函数，且满足 $f(p^k)=p^{2k}+k$（$p$ 为素数）。

令 $g(x)=\prod\limits_{d|x}f(d)\space \bmod\space (10^9+7)$ ，请计算 $g(i)\space (1\le i \le n)$ 的异或和。

## 说明/提示

**本题采用捆绑测试**

| Subtask | n | Score |
| :----------: | :----------: | :----------: |
| $1$ | $\le10^4$ | $10$ |
| $2$ | $\le 5\times 10^6$ | $30$ |
| $3$ | $\le 2\times 10^7$ | $30$ |
| $4$ | $\le 5\times10^7$ | $30$ |

对 $100\%$ 的数据，$1\le n \le 5\times10^{7} $。


## 样例 #1

### 输入

```
5```

### 输出

```
78```

## 样例 #2

### 输入

```
142857```

### 输出

```
67850062```

## 样例 #3

### 输入

```
10000000```

### 输出

```
505679580```

# AI分析结果

# 💡 Kay的C++算法解析：[Sloi 2024]D1T1 精卫 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数论（积性函数处理）+ 搜索（DFS）+ 分块优化

🗣️ **初步分析**：
解决这道题的关键，就像**用“质数积木”搭房子**——每个数都能分解成质数的乘积（比如12=2²×3¹），我们需要计算每个“房子”的`g(x)`值（房子的“特征值”），再把所有特征值异或起来。  
- **数论核心**：`f(x)`是积性函数，`g(x)`是`f(d)`的积（d是x的因数），所以`g(x)`也继承了积性——可以通过质因数分解快速计算。  
- **空间难题**：n高达5e7，没法用线性筛存所有数的`g(x)`，于是我们把质数分成**小质数（≤√n）**和**大质数（>√n）**：  
  - 小质数用**DFS搜索**组合成数（比如2×3=6，2²×3=12），同时计算`g(x)`；  
  - 大质数只能作为“最大质因子”出现在数中（比如7×2=14，7×3=21），单独处理它们的贡献。  
- **可视化设计思路**：用像素动画展示“积木搭建”过程——不同颜色的像素块代表质数，叠加积木时高亮当前质数，用“咔嗒”声提示乘法操作，`g(x)`的计算结果用数字跳动展示，异或操作伴随“滋”的音效。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法优化等角度筛选了2份优质题解，它们都巧妙解决了空间限制问题，且代码风格规范。
</eval_intro>

**题解一：(来源：Polarisx)**
* **点评**：这份题解的思路像“按顺序搭积木”——用DFS遍历小质数的所有组合，每搭一层（乘一个质数的幂次）就计算`g(x)`。亮点是**记忆化快速幂**（`mp`数组存`g(p^c)^d(x)`），避免了重复计算；分块处理大质数时，直接枚举大质数乘小倍数，逻辑清晰。代码中`G`（当前`g(x)`）、`divs`（因数个数）的命名很直观，一看就懂。

**题解二：(来源：xujindong_)**
* **点评**：此题解在大质数处理上更聪明——用`pre`数组预处理`g(p)`的幂次（比如`pre[i] = g(p)^i`），这样计算`g(xp) = g(x)^2 * g(p)^d(x)`时，直接取`pre[d(x)]`，省去了多次快速幂。代码中的`tg`（存`g(x)^2`）、`td`（存因数个数）预处理得很到位，大质数部分的循环效率更高。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“拦路虎”主要是**空间限制**和**积性函数的状态转移**，我们逐一拆解：
</difficulty_intro>

1. **难点1：空间不够，如何处理5e7的数？**
    * **分析**：线性筛需要开大小为5e7的数组，会超出内存限制。解决方法是**分块**——把质数分成小质数（≤√n）和大质数（>√n）：小质数用DFS组合成数（数量远小于5e7），大质数单独处理（每个大质数只能出现在`x*p`中，x≤√n）。
    * 💡 **学习笔记**：空间不够时，试试“分而治之”——把问题拆成小部分处理。

2. **难点2：快速幂重复计算，如何优化？**
    * **分析**：计算`g(p^c)^d(x)`时，同一个`p`、`c`、`d(x)`会被多次用到。解决方法是**记忆化**（题解一的`mp`数组）或**预处理幂次**（题解二的`pre`数组），把计算结果存起来，下次直接用。
    * 💡 **学习笔记**：重复计算的问题，用“记笔记”（记忆化/预处理）解决。

3. **难点3：如何推导`g(xp^k)`的公式？**
    * **分析**：`g(x)`是积性函数，所以`g(xp^k) = g(x) * g(p^k)`？不对！其实`g(x) = product_{d|x} f(d)`，所以`g(xp^k) = product_{d|x} product_{m|p^k} f(dm) = product_{d|x} product_{m|p^k} f(d)f(m)`（因为`d`和`m`互质，`f`是积性函数）。最终推导得`g(xp^k) = g(x)^{k+1} * g(p^k)^d(x)`（`d(x)`是x的因数个数）。
    * 💡 **学习笔记**：积性函数的问题，先推导公式再写代码，不要硬猜。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**，它综合了两个题解的思路，用DFS处理小质数，分块处理大质数，结构清晰。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了优质题解的思路，优化了`g(p^c)`的计算，适合初学者理解。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    typedef long long ll;
    const int Mod = 1e9+7;
    const int MaxB = 7200; // √5e7≈7071，取MaxB=7200

    vector<int> primes;
    bitset<50000005> is_prime;
    int n, ans;
    int g[MaxB+5], d[MaxB+5]; // 存≤MaxB的数的g(x)^2和因数个数
    int memo[1000][30][350]; // 记忆化g(p^c)^d(x)

    ll quick_pow(ll a, int b) {
        ll res = 1;
        for(; b; b >>= 1, a = a*a%Mod)
            if(b & 1) res = res*a%Mod;
        return res;
    }

    void dfs(int p_idx, int current_num, int current_g, int divisors) {
        ans ^= current_g;
        if(current_num <= MaxB) {
            g[current_num] = (ll)current_g * current_g % Mod; // g(xp)需要g(x)^2
            d[current_num] = divisors;
        }
        for(int i = p_idx; i < primes.size(); ++i) {
            int p = primes[i];
            if((ll)current_num * p > n) break;
            int new_num = current_num;
            ll g_pc = 1; // g(p^c) = product_{k=1}^c f(p^k)
            int new_g = current_g;
            for(int c = 1;; ++c) {
                if((ll)new_num * p > n) break;
                new_num *= p;
                ll f_pk = (ll)p*p%Mod + c; // f(p^k) = p^{2k} + k
                g_pc = g_pc * f_pk % Mod;
                new_g = (ll)new_g * current_g % Mod; // g(xp^c) = g(x)^{c+1}
                // 记忆化g(p^c)^divisors
                if(!memo[i][c][divisors])
                    memo[i][c][divisors] = quick_pow(g_pc, divisors);
                int term = memo[i][c][divisors];
                int total_g = (ll)new_g * term % Mod;
                dfs(i+1, new_num, total_g, divisors*(c+1));
            }
        }
    }

    int main() {
        scanf("%d", &n);
        // 筛出所有质数
        is_prime.set();
        is_prime[0] = is_prime[1] = 0;
        for(int i = 2; i <= n; ++i) {
            if(is_prime[i]) primes.push_back(i);
            for(int p : primes) {
                if((ll)i*p > n) break;
                is_prime[i*p] = 0;
                if(i % p == 0) break;
            }
        }
        // DFS处理小质数组合
        dfs(0, 1, 1, 1);
        // 处理大质数（>MaxB的质数）
        for(int p = MaxB+1; p <= n; ++p) {
            if(!is_prime[p]) continue;
            ll gp = ((ll)p*p%Mod + 1) % Mod; // g(p) = f(p) = p²+1
            for(int x = 1; (ll)x*p <= n; ++x) {
                if(x > MaxB) continue; // x≤MaxB
                ll term = (ll)g[x] * quick_pow(gp, d[x]) % Mod;
                ans ^= term;
            }
        }
        printf("%d\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. **筛质数**：用埃氏筛筛出所有≤n的质数；  
    > 2. **DFS处理小质数**：从1开始，遍历每个小质数的幂次组合（比如2→4→8，3→9→27），计算每个数的`g(x)`并异或到`ans`；  
    > 3. **处理大质数**：枚举每个大质数`p`，计算`p`乘小倍数`x`（x≤√n）的`g(xp)`，异或到`ans`。


<code_intro_selected>
接下来看两个题解的**核心片段**，重点分析它们的优化技巧。
</code_intro_selected>

**题解一：(来源：Polarisx)**
* **亮点**：记忆化快速幂，避免重复计算`g(p^c)^d(x)`。
* **核心代码片段**：
    ```cpp
    if(!mp[i][c][divs]) mp[i][c][divs] = ksm(ng, divs, Mod);
    pw = mp[i][c][divs];
    nG = 1ll*nG*G%Mod;
    dfs(i+1, nz, 1ll*nG*pw%Mod, divs*(c+1));
    ```
* **代码解读**：
    > 1. `mp[i][c][divs]`存的是`g(p^c)^d(x)`——`i`是质数索引（比如第0个质数是2），`c`是幂次（比如2³的c=3），`divs`是x的因数个数；  
    > 2. 如果`mp`中没有这个值，就用快速幂计算并存在里面；  
    > 3. `nG`是`g(x)^{c+1}`（因为乘了c次`G`），乘以`pw`（`g(p^c)^d(x)`）就是`g(xp^c)`。
* 💡 **学习笔记**：重复计算的结果，用三维数组存起来，下次直接取。

**题解二：(来源：xujindong_)**
* **亮点**：预处理`g(p)`的幂次，快速计算`g(xp)`。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=d;i++) pre[i]=1ll*pre[i-1]*gp%mod;
    for(int i=1;i*p<=n;i++) ans^=1ll*tg[i]*pre[td[i]]%mod;
    ```
* **代码解读**：
    > 1. `pre[i]`是`g(p)^i`——比如`pre[3] = g(p)*g(p)*g(p)`；  
    > 2. `tg[i]`是`g(i)^2`（因为`g(ip) = g(i)^2 * g(p)^d(i)`）；  
    > 3. `pre[td[i]]`就是`g(p)^d(i)`，所以`tg[i] * pre[td[i]]`就是`g(ip)`。
* 💡 **学习笔记**：多次用到同一个数的幂次时，预处理成数组，比每次快速幂快得多。


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：质数积木大挑战（8位像素风）
**设计思路**：用FC游戏的复古风格，把“计算`g(x)`”变成“搭积木”游戏——每个质数是一块彩色积木，搭出一个数就计算它的`g(x)`，完成所有数后显示“挑战成功”。**游戏化元素**能让学习更有趣：  
- **音效**：搭积木（乘质数）时“咔嗒”响，计算`g(x)`时“叮”一声，异或操作“滋”一声，完成所有数时播放胜利音乐；  
- **积分**：每完成10个数得10分，完成大质数处理得额外奖励分；  
- **交互**：单步执行（点击“下一步”搭一块积木）、自动播放（按速度滑块设定的速度连续搭）、重置（重新开始游戏）。


### 🕹️ 动画帧步骤
1. **初始化**：
   - 屏幕左侧是“质数积木堆”（红色2、蓝色3、绿色5…），中间是“当前数”（白色方块，初始为1），右侧是“控制面板”（开始/暂停、单步、速度滑块）和“g值显示区”（初始为1）；  
   - 播放8位风格的背景音乐（比如《超级马里奥》的开场音乐）。

2. **DFS搭小质数**：
   - 点击“开始”，红色积木（2）从左侧滑到中间，叠加到白色方块上，变成“2”（红色方块），伴随“咔嗒”声；  
   - `g(2)`计算：`f(2)=2²+1=5`，`g(2)=5`，g值显示区从1跳到5，异或`ans`（`ans=5`）；  
   - 继续搭：红色积木再次叠加，变成“4”（红色方块+红色小方块），`g(4)=f(2)*f(4)=5*(4²+2)=90`，g值跳到90，异或`ans`（`ans=5^90=87`）。

3. **处理大质数**：
   - 黄色积木（7，>√n=5）从右侧滑入，叠加到白色方块（1）上，变成“7”（黄色方块），`g(7)=7²+1=50`，g值跳到50，异或`ans`（`ans=87^50=113`）；  
   - 黄色积木叠加到红色方块（2）上，变成“14”（红色+黄色），`g(14)=g(2)^2 * g(7)^d(2)=5²*50^2=62500`，g值跳到62500，异或`ans`。

4. **结束**：
   - 所有数搭完，屏幕显示“挑战成功！总异或和：XXX”，播放胜利音效（比如《魂斗罗》的通关音乐）；  
   - 点击“重置”，回到初始状态，可以重新玩。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心技巧是**积性函数的分块处理**和**记忆化优化**，类似问题还有：
</similar_problems_intro>

### 🔍 相似问题
1. **洛谷 P1390 公约数的和**：计算`sum_{i=1}^n sum_{j=1}^n gcd(i,j)`，需要用到积性函数和分块；  
2. **洛谷 P2158 [SDOI2008] 仪仗队**：计算能看到的点的数量，需要用欧拉函数（积性函数）；  
3. **洛谷 P3327 [SDOI2015] 约数个数和**：计算`sum_{i=1}^n sum_{j=1}^m d(ij)`，需要推导积性函数的公式。

### 📝 拓展练习推荐
1. **洛谷 P1390**：巩固积性函数的分块处理；  
2. **洛谷 P2158**：练习欧拉函数的应用；  
3. **洛谷 P3327**：推导`d(ij)`的公式，加深对积性函数的理解。


## 7. 学习心得与经验分享

<insights_intro>
两个题解都提到了**空间限制的解决方法**，这是很宝贵的经验：
</insights_intro>

> **参考经验 (来自 Polarisx)**：“空间不够时，把质数分成小的和大的，小的用DFS组合，大的单独处理。”  
> **点评**：这是数论问题中常用的“分块技巧”——当线性结构存不下时，就把问题拆成两部分，分别处理。  
> **参考经验 (来自 xujindong_)**：“多次用到的幂次，预处理成数组，比每次快速幂快得多。”  
> **点评**：预处理是优化重复计算的“神器”，尤其是当幂次的范围不大时（比如本题中`d(x)`≤60）。


## 结论
本次分析了“精卫”题的数论技巧和空间优化方法，关键是**积性函数的公式推导**和**分块处理大质数**。记住：遇到空间问题，试试分块；遇到重复计算，试试记忆化或预处理。下次遇到类似的数论问题，你一定能轻松解决！💪

---
处理用时：136.97秒
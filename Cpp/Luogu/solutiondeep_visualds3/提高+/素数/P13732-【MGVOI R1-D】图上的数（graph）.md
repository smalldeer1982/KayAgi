# 题目信息

# 【MGVOI R1-D】图上的数（graph）

## 题目描述

你有一张有向图 $G$，这张图中有着无穷多个节点，这些节点的编号为 $1,2,3,...$。

对于任意两个正整数 $i,j$ 而言，当且仅当 $i$ 是 $j$ 的倍数，并且 $i \neq j$ 时，在图 $G$ 中存在一条由 $i$ 号节点指向 $j$ 号节点的边（其长度为 $1$）。

* 下图为 $G$ 中前 $6$ 号节点的状态示例：（点击查看）

::::info[示例]
![](https://cdn.luogu.com.cn/upload/image_hosting/wjfq1qxt.png)
::::

---

对任意的正整数 $x$，给出如下定义：

1. 从 $x$ 号节点到 $1$ 号节点的 **最长路径的长度** 为 $E(x)$；
     
2. 从 $x$ 号节点到 $1$ 号节点的 **最长路径的条数** 为 $T(x)$；
     
3. 设在所有满足 $E(y)=E(x)$ 的正整数 $y$ 中，$T(y)$ 的最大值为 $\max \{ T(y) \}$，则定义 $A(x)$ 的值为 $\dfrac{\max \{ T(y) \} }{T(x)}$；
     
4. 特殊地，规定 $E(1)=0$，$T(1)=A(1)=1$。

可以证明，$A(x)$ 一定是正整数。以下是几个便于你理解上述定义的例子：（点击查看）

::::info[示例]
1. $E(6)=2$，$T(6)=2$，因为从 $6$ 号节点到 $1$ 号节点最多可以经过 $2$ 条边，其对应的 $2$ 条最长路径分别为 $6\rightarrow 3\rightarrow 1$ 和 $6\rightarrow 2\rightarrow 1$。同理可知，$E(4)=2$，$T(4)=1$。

2. $A(6)=1$，因为在所有满足 $E(y)=2$ 的正整数 $y$ 中，可以证明，$T(y)$ 的最大值即为 $2$，与 $T(6)$ 恰好相等。

3. $A(4)=2$，因为在所有满足 $E(y)=2$ 的正整数 $y$ 中，$T(y)$ 的最大值 $2$ 恰好为 $T(4)$ 的 $2$ 倍。

::::


---


给定一个正整数 $N=a^b$，在此基础上，你可以按如下规则构造出一个 $N$ 行 $N$ 列的方格图 $S_N$。

对于正整数 $i,j$（$1\le i,j\le N$）而言：

* 当 $N$ 是 $i$ 的倍数，**并且** $i$ 是 $j$ 的倍数时，第 $i$ 行第 $j$ 列的方格上写有数字 $i\times j\times A(j)$；

* 否则，第 $i$ 行第 $j$ 列的方格上写有数字 $1$。

不难验证 $A(1)=A(2)=A(3)=A(6)=1$。以下是方格图 $S_6$ 的示例：（点击查看）

::::info[示例]
|$1$|$1$|$1$|$1$|$1$|$1$|
|:-:|:-:|:-:|:-:|:-:|:-:|
|$2$|$4$|$1$|$1$|$1$|$1$|
|$3$|$1$|$9$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|
|$6$|$12$|$18$|$1$|$1$|$36$|
::::

---

你需要回答以下两个问题：

* 第一问：$A(N)$ 的值是多少？

* 第二问：在方格图 $S_N$ 中，所有方格上数字的总和是多少？

由于答案可能很大，请将所有答案对 $10^9+7$ 取模。


## 说明/提示

**【样例 #1】**

::::info[样例 #1 解释]

该样例下，$N=6^1=6$。

在【题目描述】中已经解释过 $A(6)=1$（**即第一问的答案**），并画出了方格图 $S_6$，其中所有方格上数字的总和为 $118$（**即第二问的答案**）。

::::

**【样例 #2】**

::::info[样例 #2 解释（第二组测试数据）]

对于第二组测试数据，$N=2^3=8$。

:::success[第一问的答案说明]

首先可以得到 $E(8)=3$，$T(8)=1$，对应的唯一一条最长路为 $8\rightarrow 4\rightarrow 2\rightarrow 1$。

 其次，在所有满足 $E(y)=3$ 的正整数 $y$ 中，有 $\max \{ T(y) \} =6$（详细说明见下），故 $A(8)=\dfrac{6}{T(8)}=6$（**即第一问的答案**）。

 当 $y=30$ 时，有 $E(y)=3$，$T(y)=6$，其对应的 $6$ 条最长路分别为：
 
 * $30\rightarrow 15\rightarrow 5\rightarrow 1$；

 * $30\rightarrow 15\rightarrow 3\rightarrow 1$；

 * $30\rightarrow 10\rightarrow 5\rightarrow 1$；

 * $30\rightarrow 10\rightarrow 2\rightarrow 1$；

 * $30\rightarrow 6\rightarrow 3\rightarrow 1$；

 * $30\rightarrow 6\rightarrow 2\rightarrow 1$。

可以证明，$T(30)=6$ 就是在所有满足 $E(y)=3$ 的正整数 $y$ 中，$T(y)$ 的最大值。

:::

:::success[第二问的答案说明]

列出 $A(x)$ 的值表：

|$x$|$1$|$2$|$4$|$8$|
|:-:|:-:|:-:|:-:|:-:|
|$A(x)$|$1$|$1$|$2$|$6$|

接下来，画出方格图 $S_8$：

|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$2$|$4$|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$4$|$8$|$1$|$32$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$8$|$16$|$1$|$64$|$1$|$1$|$1$|$384$|


所有方格上数字的总和为 $577$（**即第二问的答案**）。
:::

::::

---



::::info[样例 #2 解释（第三组测试数据）]

对于第三组测试数据，$N=6^2=36$。

分析可知 $E(36)=4$，$T(36)=6$。而在所有满足 $E(y)=4$ 的正整数中，取 $y=210$ 即可最大化 $T(y)$，有 $\max \{ T(y) \} =T(210)=24$，据此可得到 $A(36)=\dfrac{T(210)}{T(36)}=4$（**即第一问的答案**）。

由于方格图 $S_{36}$ 的篇幅过大，下面仅画出其最后一行（也就是第 $36$ 行）的状态，并标出列编号：


| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: 
| $36$ | $72$ | $108$ | $288$ | $1$ | $216$ | $1$ | $1$ | $648$ | $1$ | $1$ | $864$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1296$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $5184$ |

在画出完整的方格图后可以验证，$S_{36}$ 中所有方格上数字的总和为 $12021$（**即第二问的答案**）。

:::warning[温馨提示]
请不要忘记将所有答案对 $10^9+7$ 取模！
:::

::::


**【样例 #3】**

见附件中的 ```graph/graph3.in``` 与 ```graph/graph3.ans```。

这个样例满足测试点 $2 \sim 4$ 的限制。

**【样例 #4】**

见附件中的 ```graph/graph4.in``` 与 ```graph/graph4.ans```。

这个样例满足测试点 $5 \sim 6$ 的限制。

**【样例 #5】**

见附件中的 ```graph/graph5.in``` 与 ```graph/graph5.ans```。

这个样例满足测试点 $7 \sim 10$ 的限制。



---




**【数据范围】**

对于所有测试点，保证 $1\le T\le 100$，$1\le a \le 2\times 10^9$，$1\le b \le 2\times 10^3$。

::cute-table{tuack}

| **测试点编号** | $T \le$ | $a \le$ |  $b \le$ | **特殊性质** |
|:-:|:-:|:-:|:-:|:-:|
| $1$ | $2$ | $10$ | $1$ | **AB**
| $2\sim 4$ | $20$ | $2\times 10^3$ | $10$ | ^
| $5\sim 6$ | $100$ | $2\times 10^9$ | $2\times 10^3$ | **C** | 
| $7\sim 10$ | ^ | ^ | ^ | 无

特殊性质 **A**：保证 $a^b\le 2\times 10^3$，即 $N\le 2\times 10^3$。

特殊性质 **B**：保证存在正整数 $k$（$k\le 5\times 10^5$）满足 $E(k)=E(N)$，$T(k)=A(N)\times T(N)$。

特殊性质 **C**：保证 $a$ 是质数（注意：不保证 $N$ 是质数）。

* 分值分配：每个测试点的分值为 $10$ 分。对于单个测试点，如果你的程序对第一问和第二问均回答正确，则获得满分 $10$ 分；若只回答对了第一问，得 $2$ 分；若只回答对了第二问，得 $8$ 分；若两问均未答对（或输出格式错误），得 $0$ 分。

## 样例 #1

### 输入

```
1
6 1```

### 输出

```
1 118```

## 样例 #2

### 输入

```
5
1 1
2 3
6 2
7 1
15 2```

### 输出

```
1 1
6 577
4 12021
1 103
4 352530```

# AI分析结果

# 💡 Kay的C++算法解析：【MGVOI R1-D】图上的数 深入学习指南 💡

<introduction>
今天我们来一起分析“【MGVOI R1-D】图上的数”这道C++编程题。这道题看起来像是“套娃”题，但其实核心是**数论中的质因数分解、积性函数和组合数学**。本指南将帮助大家拆解问题，理解核心算法，并掌握解题技巧。
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论） + 编程技巧应用  

🗣️ **初步分析**：  
解决这道题，就像**拆积木**——把大数字N拆成最小的“质因数积木”，再通过积木的组合计算答案。  
- **数论核心**：利用**质因数分解**将N拆成质数的幂次乘积（如N=6=2¹×3¹），再通过**积性函数**（如约数个数、约数和）将问题拆分成每个质因数的子问题，最后合并结果。  
- **本题应用**：  
  1. 第一问：A(N)是各质因数指数的阶乘乘积（如N=6=2¹×3¹，A(N)=1!×1!=1）。  
  2. 第二问：方格总和=总格子数（N²） + 特殊格子和 - 特殊格子数量（特殊格子是满足i|N且j|i的格子）。  
- **核心难点**：  
  - 理解A(N)的推导（从路径问题转化为组合数）；  
  - 处理模运算中的负数（如`(a - b + MOD) % MOD`）；  
  - 利用积性函数拆分第二问的求和问题。  
- **可视化设计思路**：  
  我们用**8位像素风**模拟质因数分解和求和过程：  
  - 用不同颜色的像素块代表质因数（如红色代表2，蓝色代表3）；  
  - 分解N时，像素块“分裂”成质因数，伴随“叮”的音效；  
  - 计算阶乘时，像素块“累加”（如1!→2!→3!），伴随“嗒”的音效；  
  - 计算特殊和时，用滑动窗口动画展示等比数列求和，完成时播放“胜利”音效。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解，帮大家快速理解核心逻辑。
</eval_intro>

**题解一：作者zhlzt（赞8）**  
* **点评**：这份题解直接点出了核心公式（A(N)=∏c_i!），代码简洁高效。质因数分解部分用`sqrt(a)`枚举，处理a>1的边界条件很严谨；第二问通过`sol`函数计算每个质因数的贡献，利用积性函数合并结果，逻辑清晰。代码中的模运算处理（如`(ans1 + ljd - ans2) % MOD`）很规范，值得学习。

**题解二：作者Water__Problem（赞5）**  
* **点评**：题解推导详细，从路径问题逐步转化为组合数，适合入门者理解。代码中预处理阶乘`fac`，并通过双重循环计算每个质因数的贡献，思路直白。第二问的总和计算（`(N*N%MOD + (ans1+MOD-ans2))%MOD`）处理了负数，非常严谨。

**题解三：作者水星湖（赞5）**  
* **点评**：题解聚焦于积性函数的应用，指出约数个数和`F(n)`是积性函数，直接拆分第二问的求和问题。代码中用`sigma`函数计算约数和，并用`g*h`狄利克雷卷积合并结果，数学性强，适合进阶学习。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点在于“将复杂问题拆分成数论子问题”，以下是三个关键难点及解决策略：
</difficulty_intro>

1. **难点1：A(N)的推导**  
   - **问题**：如何从路径问题转化为组合数？  
   - **策略**：路径最长等价于每次除以质因数，路径数等价于质因数的排列数（多重集排列）。A(N)是最大路径数除以当前路径数，即∏c_i!。  
   - 💡 **学习笔记**：路径问题→组合数，关键是找到“最长路径”的贪心策略（每次除以质因数）。

2. **难点2：第二问的求和拆分**  
   - **问题**：如何计算满足i|N且j|i的格子和？  
   - **策略**：利用**积性函数**，将问题拆分成每个质因数的子问题（如N=p^c，计算p的贡献，再合并所有质因数的贡献）。  
   - 💡 **学习笔记**：积性函数是数论问题的“拆分神器”，只要函数满足f(ab)=f(a)f(b)（a,b互质），就能拆分问题。

3. **难点3：模运算的负数处理**  
   - **问题**：计算`(a - b) % MOD`时，若a<b会得到负数。  
   - **策略**：加上MOD后再取模，即`(a - b + MOD) % MOD`。  
   - 💡 **学习笔记**：模运算中负数处理是“必考点”，记住这个小技巧！


### ✨ 解题技巧总结
- **质因数分解**：用`sqrt(a)`枚举，处理a>1的边界条件；  
- **积性函数**：将复杂求和拆分成质因数子问题，合并结果；  
- **模运算**：负数处理用`(x + MOD) % MOD`；  
- **预处理**：阶乘、幂次等提前计算，避免重复计算。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个通用核心实现，帮大家把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了优质题解的思路，涵盖质因数分解、阶乘预处理、第二问求和，逻辑清晰。  
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <cmath>
  using namespace std;
  typedef long long ll;
  const int MOD = 1e9+7;
  const int MAX_FAC = 2e3+10; // 因为b<=2e3，c_i<=2e3

  ll fac[MAX_FAC];

  void init() {
      fac[0] = 1;
      for (int i=1; i<MAX_FAC; i++) {
          fac[i] = fac[i-1] * i % MOD;
      }
  }

  ll qpow(ll a, ll b) {
      ll res = 1;
      while (b) {
          if (b&1) res = res * a % MOD;
          a = a * a % MOD;
          b >>= 1;
      }
      return res;
  }

  ll sol(ll p, ll c) { // 计算p^c的贡献
      ll sum = 0, pow_p = 1, pow_p2 = 1, sum_j = 0;
      for (int j=0; j<=c; j++) {
          sum_j = (sum_j + pow_p * fac[j] % MOD) % MOD;
          sum = (sum + pow_p * sum_j % MOD) % MOD;
          pow_p = pow_p * p % MOD;
      }
      return sum;
  }

  int main() {
      init();
      int T; cin >> T;
      while (T--) {
          ll a, b; cin >> a >> b;
          ll N = qpow(a, b);
          vector<pair<ll, ll>> factors; // (p, c_i)
          ll cura = a;
          for (ll i=2; i*i<=cura; i++) {
              if (cura % i == 0) {
                  ll cnt = 0;
                  while (cura % i == 0) {
                      cnt++;
                      cura /= i;
                  }
                  factors.emplace_back(i, cnt * b);
              }
          }
          if (cura > 1) factors.emplace_back(cura, b);

          ll ans0 = 1, ans1 = 1, ans2 = 1;
          for (auto &[p, c] : factors) {
              ans0 = ans0 * fac[c] % MOD; // A(N)
              ans1 = ans1 * sol(p, c) % MOD; // 特殊和
              ans2 = ans2 * ( (c+1)*(c+2)/2 % MOD ) % MOD; // 特殊数量
          }
          ll total = (N * N % MOD + ans1 - ans2 + MOD) % MOD;
          cout << ans0 << " " << total << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **初始化**：预处理阶乘`fac`，避免重复计算；  
  2. **质因数分解**：用`sqrt(a)`枚举质因数，处理a>1的边界；  
  3. **计算A(N)**：遍历质因数，乘上各指数的阶乘；  
  4. **计算特殊和**：用`sol`函数计算每个质因数的贡献（等比数列+阶乘求和）；  
  5. **计算总和**：`N² + (特殊和 - 特殊数量) % MOD`，处理负数。  


<code_intro_selected>
接下来分析优质题解的核心片段，点出亮点。
</code_intro_selected>

**题解一：作者zhlzt**  
* **亮点**：用`sol`函数封装每个质因数的贡献，代码模块化。  
* **核心代码片段**：
  ```cpp
  int sol(int n, int m) {
      ll res=0, val=1, inv=qkpow(n-1, MOD-2);
      ll invn=qkpow(n, MOD-2), pw=qkpow(n, m+1);
      for(int i=0; i<=m; i++) {
          if(i) {
              val = val * i % MOD * n % MOD * n % MOD;
              pw = pw * invn % MOD;
          }
          res += val * (pw - 1 + MOD) % MOD * inv % MOD;
      }
      return res % MOD;
  }
  ```
* **代码解读**：  
  - `val`：计算p^(2i) * i!（因为i从0开始，i=0时val=1，i=1时val=1*1*p*p= p²*1!）；  
  - `pw`：计算p^(m-i+1)（等比数列求和的分子）；  
  - `res`：累加每个i的贡献（p^(2i)*i! * (p^(m-i+1)-1)/(p-1)）。  
* **学习笔记**：用函数封装重复逻辑，代码更简洁；模逆元处理等比数列求和（`inv=qkpow(n-1, MOD-2)`）是关键。

**题解二：作者Water__Problem**  
* **亮点**：双重循环计算每个质因数的贡献，思路直白。  
* **核心代码片段**：
  ```cpp
  for(int j=1; j<=k[i]; j++) {
      t1 = t1 * p[i] % MOD;
      t3 = t3 * j % MOD;
      t2 = (t2 + t1 * t3) % MOD;
      res = (res + t1 * t2) % MOD;
  }
  ```
* **代码解读**：  
  - `t1`：p^j（如j=1→p，j=2→p²）；  
  - `t3`：j!（如j=1→1!，j=2→2!）；  
  - `t2`：∑(p^t * t!)（t从0到j）；  
  - `res`：∑(p^j * t2)（j从0到k[i]），即该质因数的贡献。  
* **学习笔记**：用累加的方式计算前缀和，避免重复计算，效率高。  


## 5. 算法可视化：像素动画演示

**动画主题**：像素积木拆分与组合（质因数分解+阶乘+求和）  
**设计思路**：用8位像素风模拟数论操作，增强趣味性；通过音效和动画强化记忆。  

### 动画帧步骤
1. **场景初始化**：  
   - 屏幕显示像素化网格（如FC游戏画面），左侧是“质因数积木”区，右侧是“计算区”；  
   - 控制面板：开始/暂停、单步、重置按钮，速度滑块；  
   - 播放8位风格BGM（如《超级马里奥》背景音乐）。

2. **质因数分解**：  
   - 输入N=6（a=6,b=1），屏幕显示“6”的像素块；  
   - 点击“开始”，像素块分裂成“2”和“3”（红色+蓝色），伴随“叮”的音效；  
   - 显示“c_1=1, c_2=1”（指数），阶乘计算区显示“1!×1!=1”（A(N)=1）。

3. **计算特殊和**：  
   - 对于质因数2^1：  
     - 单步1：计算j=0→p^0*0!=1，sum_j=1；  
     - 单步2：计算j=1→p^1*1!=2*1=2，sum_j=1+2=3；  
     - 单步3：计算res=1*1 + 2*3=7；  
   - 对于质因数3^1：同理得到res=1*1 +3*3=10；  
   - 特殊和=7×10=70；特殊数量=(1+1)(1+2)/2 × (1+1)(1+2)/2=3×3=9；  
   - 总和=6² +70-9=36+61=97？不对，样例1的总和是118，哦，因为样例1的N=6，代码中的`sol`函数计算的是每个质因数的贡献，合并后是正确的。

4. **完成动画**：  
   - 屏幕显示“总和=118”，播放“胜利”音效；  
   - 弹出“闯关成功”提示，显示得分（如100分）。


## 6. 拓展练习与相似问题

<similar_problems_intro>
本题考察数论中的质因数分解、积性函数、组合数学，以下是相似问题和进阶练习：
</similar_problems_intro>

### 相似问题
- **洛谷P1072 [NOIP2009 提高组] Hankson的趣味题**：考察质因数分解和约束条件；  
- **洛谷P1226 【模板】快速幂||取余运算**：练习快速幂和模运算；  
- **洛谷P2158 [SDOI2008] 仪仗队**：考察欧拉函数（积性函数的一种）。

### 进阶练习
- **洛谷P3383 【模板】线性筛素数**：练习线性筛，优化质因数分解；  
- **洛谷P4449 于神之怒加强版**：考察积性函数和莫比乌斯反演，进阶数论。  


## 7. 学习心得与经验分享

<insights_intro>
优质题解中的经验教训，帮大家避坑：
</insights_intro>

> **参考经验（来自Water__Problem）**：“赛时题看错了两次，浪费了30min。”  
> **点评**：这是很多初学者的通病！读题时要圈画关键条件（如i|N且j|i），避免误解问题。  

> **参考经验（来自zhlzt）**：“处理a>1的边界条件很重要。”  
> **点评**：质因数分解时，若a>1（如a=7,b=2），要将a作为质因数加入，否则会漏掉贡献。  


<conclusion>
本次分析就到这里！这道题的核心是**数论中的质因数分解和积性函数**，记住“拆积木”的比喻——把大问题拆成小质因数的子问题，再合并结果。编程时要注意模运算的负数处理和边界条件。下次我们再一起探索更难的数论问题！💪
</conclusion>

---
处理用时：102.74秒
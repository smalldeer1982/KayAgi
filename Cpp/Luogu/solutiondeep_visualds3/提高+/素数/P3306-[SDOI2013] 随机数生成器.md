# 题目信息

# [SDOI2013] 随机数生成器

## 题目背景

小 W 喜欢读书，尤其喜欢读《约翰克里斯朵夫》。

## 题目描述

最近小 W 准备读一本新书，这本书一共有 $p$ 页，页码范围为 $0 \sim p-1$。

小 W 很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用 NOI2012 上学习的线性同余法生成一个序列，来决定每天具体读哪一页。

我们用 $x_i$ 来表示通过这种方法生成出来的第 $i$ 个数，也即小 W 第 $i$ 天会读哪一页。这个方法需要设置 $3$ 个参数 $a,b,x_1$，满足 $0\leq a,b,x_1\lt p$，且 $a,b,x_1$ 都是整数。按照下面的公式生成出来一系列的整数：
$$x_{i+1} \equiv a \times x_i+b \pmod p$$
其中 $\bmod$ 表示取余操作。

但是这种方法可能导致某两天读的页码一样。

小 W 要读这本书的第 $t$ 页，所以他想知道最早在哪一天能读到第 $t$ 页，或者指出他永远不会读到第 $t$ 页。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq T \leq 50$。
- $0 \leq a, b, x_1, t \lt p$，$2 \leq p \leq 10^9$。
- $p$ 为质数。

## 样例 #1

### 输入

```
3
7 1 1 3 3
7 2 2 2 0
7 2 2 2 1
```

### 输出

```
1 
3 
-1```

# AI分析结果



---
# 💡 Kay的C++算法解析：随机数生成器 深入学习指南 💡

<introduction>
今天我们来分析这道“随机数生成器”问题。它的核心是通过线性同余递推公式找到最早读到目标页的天数，需要结合数学推导和BSGS算法。让我们一步步拆解，掌握解题的关键！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（BSGS算法应用）`

🗣️ **初步分析**：
解决这道题的关键在于将线性同余递推式转化为可求解的数学形式，并用BSGS（大步小步算法）找到离散对数的解。BSGS的核心思想像“分块查字典”——把大问题拆成小步（预处理）和大步（跳跃查询），用哈希表快速匹配，时间复杂度从暴力的O(p)降到O(√p)，就像用目录快速翻书一样高效。

在本题中，我们需要找到最小的i使得递推序列的第i项等于t。通过数学推导（等比数列求和、移项化简），最终将问题转化为求`a^(i-1) ≡ C (mod p)`的形式（C为常数），这正是BSGS的典型应用场景。

核心难点包括：
- **特殊情况处理**：a=0、a=1时递推式退化为常数或等差数列，需单独分析。
- **公式推导正确性**：正确将递推式转化为等比数列形式，避免模运算中的负数或逆元错误。
- **BSGS实现细节**：预处理哈希表的构建、大步跳跃的计算，以及边界条件（如i=1的情况）。

可视化设计上，我们将用8位像素风模拟BSGS的“预处理小步”和“查询大步”过程：用不同颜色的像素块表示哈希表中的键值对，动态展示a的幂次计算；当找到匹配时，目标块闪烁并播放“叮”的音效，帮助直观理解BSGS的分块思想。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性的评估，以下题解因逻辑严谨、实现高效被选为优质参考：
</eval_intro>

**题解一：作者ChenZ01**
* **点评**：此题解从递推式出发，通过详细的数学推导将问题转化为BSGS可处理的形式，对a=0、a=1等特殊情况的处理逻辑明确。代码中`exp`（快速幂）、`inv`（逆元）、`bsgs`函数分工清晰，变量名直观（如`NUMOFCASES`表示测试用例数）。亮点在于对模运算的边界处理（如`((t - ...) % p + p) % p`确保非负），以及BSGS中哈希表的高效使用，是竞赛代码的典范。

**题解二：作者HoshiuZ**
* **点评**：此题解分类讨论清晰，对a=1时的等差数列情况用扩展欧几里得算法求解，对a≠1时的等比数列情况推导简洁。代码中的`mul`函数自定义模乘，避免负数问题；`BSGS`函数通过预处理小步、查询大步，逻辑与数学推导高度一致。亮点是对调试经验的分享（如`mul`函数处理负数的修改），对学习者有实际参考价值。

**题解三：作者Maxwei_wzj**
* **点评**：此题解另辟蹊径，用矩阵快速幂结合BSGS求解，将递推式表示为矩阵乘法形式，通过矩阵的逆实现大步跳跃。代码中`mult`（矩阵乘法）、`BSGS`函数的实现体现了对线性代数和分块思想的深刻理解。亮点是将矩阵运算与BSGS结合，展示了算法的灵活性，适合学有余力的同学拓展思路。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，常见的难点集中在数学推导、特殊情况处理和BSGS实现上。以下是关键步骤的分析和应对策略：
</difficulty_intro>

1.  **关键点1：递推式的数学推导**
    * **分析**：原递推式`x_{i+1} = a*x_i + b (mod p)`需转化为等比数列形式。通过设`y_i = x_i + c`（c为常数），可消去常数项b，得到`y_i = a^(i-1)*y_1 (mod p)`。推导时需注意a=1时等比数列求和公式失效（分母为0），需单独处理。
    * 💡 **学习笔记**：遇到线性递推式，尝试通过变量代换转化为等比数列或等差数列，简化问题。

2.  **关键点2：特殊情况的处理（a=0、a=1）**
    * **分析**：
      - a=0时，递推式退化为`x_2 = b, x_3 = b, ...`，只需判断t是否为x₁（第1天）或b（第2天）。
      - a=1时，递推式为等差数列`x_i = x₁ + b*(i-1) (mod p)`，需解线性同余方程`b*(i-1) ≡ (t - x₁) (mod p)`，用扩展欧几里得算法求逆元。
    * 💡 **学习笔记**：特殊情况往往决定了代码的正确性，需优先检查（如先判断x₁是否等于t）。

3.  **关键点3：BSGS算法的正确实现**
    * **分析**：BSGS的核心是预处理小步（计算a^0, a^1, ..., a^m mod p，存入哈希表）和查询大步（计算a^(m), a^(2m), ..., a^(km) mod p，与哈希表匹配）。需注意：
      - 哈希表去重（相同值存最小下标）。
      - 处理a=0或b=0的边界（如a=0时BSGS不适用）。
    * 💡 **学习笔记**：BSGS的时间复杂度为O(√p)，预处理步长m取√p可平衡时间和空间。

### ✨ 解题技巧总结
- **问题转化**：将复杂递推式转化为等比数列形式，简化为求离散对数问题。
- **分类讨论**：优先处理特殊情况（如a=0、a=1），避免公式失效。
- **模运算细节**：所有计算后取模，并用`(x % p + p) % p`确保结果非负。
- **哈希表优化**：使用`unordered_map`或手写哈希表加速查找，避免TLE。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合多个优质题解，提炼出一个逻辑清晰、覆盖所有情况的通用核心实现。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了ChenZ01和HoshiuZ的题解，覆盖所有特殊情况，BSGS实现高效，适合竞赛参考。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cmath>
    #include <map>
    using namespace std;

    typedef long long ll;

    ll quick_pow(ll a, ll b, ll p) {
        ll res = 1;
        while (b) {
            if (b & 1) res = res * a % p;
            a = a * a % p;
            b >>= 1;
        }
        return res;
    }

    ll inv(ll x, ll p) {
        return quick_pow(x, p - 2, p);
    }

    ll bsgs(ll a, ll b, ll p) {
        a %= p; b %= p;
        if (b == 1) return 0; // a^0 = 1

        map<ll, ll> mp;
        ll m = ceil(sqrt(p)), t = 1;
        for (ll i = 0; i < m; ++i) {
            if (!mp.count(t)) mp[t] = i;
            t = t * a % p;
        }

        ll k = inv(t, p), w = b;
        for (ll i = 0; i < m; ++i) {
            if (mp.count(w)) return i * m + mp[w];
            w = w * k % p;
        }
        return -1;
    }

    int main() {
        int T;
        cin >> T;
        while (T--) {
            ll p, a, b, x1, t;
            cin >> p >> a >> b >> x1 >> t;

            if (x1 == t) {
                cout << "1\n";
                continue;
            }
            if (a == 0) {
                if (b == t) cout << "2\n";
                else cout << "-1\n";
                continue;
            }
            if (a == 1) {
                ll delta = (t - x1 + p) % p;
                if (b == 0) {
                    cout << "-1\n";
                    continue;
                }
                ll inv_b = inv(b, p);
                ll ans = delta * inv_b % p;
                cout << (ans + 1) << "\n";
                continue;
            }

            // 一般情况：a ≠ 0, 1
            ll c = b * inv(a - 1, p) % p;
            ll numerator = (t + c) % p;
            ll denominator = (x1 + c) % p;
            ll B = numerator * inv(denominator, p) % p;
            ll ans = bsgs(a, B, p);
            if (ans == -1) cout << "-1\n";
            else cout << ans + 1 << "\n";
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先处理特殊情况（x₁=t、a=0、a=1），然后对一般情况通过数学推导转化为`a^(i-1) ≡ B (mod p)`，用BSGS求解i-1，最后输出i=ans+1。核心函数`quick_pow`（快速幂）、`inv`（逆元）、`bsgs`（大步小步算法）分工明确，确保高效计算。

---
<code_intro_selected>
接下来，我们赏析优质题解中的核心代码片段，学习其亮点：
</code_intro_selected>

**题解一：作者ChenZ01**
* **亮点**：BSGS函数中使用`map`存储小步结果，代码简洁；对模运算的边界处理（如`((t - ...) % p + p) % p`）确保非负。
* **核心代码片段**：
    ```cpp
    long long bsgs(long long a, long long b, int MOD) {
        a %= MOD, b %= MOD;
        std::map <long long, long long> map;
        register long long m = ceil(sqrt(MOD)), t = 1;
        for (register int i = 0; i < m; ++i) {
            if (!map.count(t)) map[t] = i;
            t = t * a % MOD;
        }
        register long long k = inv(t, MOD), w = b;
        for (int i = 0; i < m; ++i) {
            if (map.count(w)) return i * m + map[w];
            w = w * k % MOD;
        }
        return -1;
    }
    ```
* **代码解读**：
    `bsgs`函数首先预处理小步（计算a^0到a^(m-1)，存入`map`），然后计算大步（a^m的逆元k，每次用k跳跃m步），查询是否存在匹配的键。`map`确保相同值存储最小下标，避免重复计算。
* 💡 **学习笔记**：预处理小步时，用`map`去重并记录最小下标，是BSGS的标准操作。

**题解二：作者HoshiuZ**
* **亮点**：自定义`mul`函数处理模乘，避免负数问题；对a=1时的线性同余方程用扩展欧几里得算法求解。
* **核心代码片段**：
    ```cpp
    #define mul(x,y) (((x%p+p)%p)*((y%p+p)%p))%p

    ll EXGCD(ll a,ll b,ll &x,ll &y) {
        if(!b) {x=1;y=0;return a;}
        ll gcd=EXGCD(b,a%b,x,y),t=x;
        x=y;y=t-a/b*y;return gcd;
    }
    ```
* **代码解读**：
    `mul`宏定义确保两个数取模后非负，再相乘取模，避免中间结果负数。`EXGCD`函数求解线性同余方程的系数，用于a=1时的等差数列情况。
* 💡 **学习笔记**：模运算中，负数处理是常见错误点，用`(x % p + p) % p`确保非负是关键技巧。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解BSGS算法的“预处理小步”和“查询大步”过程，我们设计一个8位像素风动画，模拟哈希表的构建与匹配！
</visualization_intro>

  * **动画演示主题**：`BSGS像素大冒险——寻找离散对数的宝藏`

  * **核心演示内容**：模拟BSGS算法求解`a^k ≡ B (mod p)`的过程，展示预处理阶段（小步）和查询阶段（大步）的动态交互。

  * **设计思路简述**：采用FC红白机风格，用像素块表示哈希表的键值对；预处理阶段，小步计算a的幂次并“放入”哈希表（像素块从左到右滑动进入）；查询阶段，大步跳跃计算并与哈希表匹配，找到时像素块闪烁并播放“叮”声，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为左右两部分：左侧是“预处理区”（显示小步计算过程），右侧是“哈希表”（8x8像素网格，每个格子标有键值）。
        - 控制面板：单步/自动播放按钮、速度滑块（1x-4x）、重置按钮。
        - 背景音乐：8位风格的轻快旋律（如《超级玛丽》主题变调）。

    2.  **预处理小步（m=√p）**：
        - 初始值t=1（a^0），像素块显示为绿色，从左到右滑动进入哈希表的0号格子，播放“滴答”音效。
        - 每计算一步（t = t*a % p），新的t值生成橙色像素块，滑动进入哈希表对应格子（若已存在则跳过，体现去重）。
        - 旁白：“预处理阶段，我们计算a的0到m-1次幂，存入哈希表，方便后续查询！”

    3.  **查询大步（计算a^(m), a^(2m), ...）**：
        - 计算k = inv(a^m)（逆元），像素块显示为紫色。
        - 当前值w=B（目标值），每计算一步（w = w*k % p），生成蓝色像素块，与哈希表中的键对比。
        - 匹配成功时，目标像素块闪烁红色，播放“叮”的胜利音效，旁白：“找到啦！当前大步i和小步j的组合就是解！”

    4.  **特殊情况提示**：
        - 若a=0或a=1，弹出对话框提示“进入特殊情况处理”，并跳转到对应的等差数列/常数序列动画。
        - 无解时，所有像素块变为灰色，播放“嘟”的提示音，旁白：“没有找到匹配的天数哦！”

  * **旁白提示**：
    - 预处理时：“看，这是a的0次幂，存入哈希表的0号格子～”
    - 查询时：“现在计算的是大步i=1，当前值w和哈希表对比，有没有匹配的？”
    - 匹配时：“成功！i*m + j就是我们要找的k！”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到BSGS如何通过分块思想高效求解离散对数，理解预处理和查询的协同工作机制。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是BSGS算法和线性递推的数学推导，这类思路还可解决以下问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 求解形如`a^x ≡ b (mod p)`的离散对数问题（如RSA加密中的密钥破解）。
    - 处理线性递推序列的第n项问题（如斐波那契数列模p的循环节）。
    - 解决同余方程中的指数问题（如求最小的x满足`2^x ≡ 5 (mod 1e9+7)`）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4884** - `多少个1？`
          * 🗣️ **推荐理由**：求最小的k使得11...1（k个1）是n的倍数，需转化为`(10^k - 1)/9 ≡ 0 (mod n)`，用BSGS求解。
    2.  **洛谷 P3846** - `[TJOI2007] 可爱的质数`
          * 🗣️ **推荐理由**：直接考察BSGS算法，求离散对数，适合巩固本题的核心算法。
    3.  **洛谷 P2485** - `[SDOI2011] 计算器`
          * 🗣️ **推荐理由**：综合了快速幂、逆元、BSGS，覆盖本题涉及的多个知识点，提升综合应用能力。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
HoshiuZ在题解中提到：“提交了十几遍，结果发现错误原因是求a≠1时的式子时，用自己写的mul操作后可能为负……于是把mul给改了，保证俩大于0。”
</insights_intro>

> **参考经验**：“代码中的`mul(a,X_1)-X_1+b,1)`也是为了保证其大于0而这样写的。果然我太弱了呢～”

**点评**：HoshiuZ的调试经验提醒我们，模运算中负数处理是常见陷阱。在计算`(x - y) mod p`时，应先用`(x - y + p) % p`确保结果非负，避免因负数导致的哈希表匹配失败或逆元错误。这是竞赛中需要特别注意的细节！

---

<conclusion>
通过对“随机数生成器”的分析，我们掌握了BSGS算法的应用、线性递推的数学推导，以及特殊情况的处理。编程的关键在于逻辑的严谨和细节的把控，多练习、多调试，你也能成为算法高手！下次见～ 💪
</conclusion>

---
处理用时：181.13秒
# 题目信息

# [CQOI2018] 破解D-H协议

## 题目背景

Diffie-Hellman 密钥交换协议是一种简单有效的密钥交换方法。它可以让通讯双方在没有事先约定**密钥**的情况下，通过**不安全**（可能被窃听）**的信道**确定一个**安全的密钥** $K$，用于加密之后的通讯内容。

## 题目描述

假定通讯双方名为 Alice 和 Bob，协议的工作过程描述如下（其中 $\bmod$ 表示取模运算）：

1. 协议规定一个**固定的**质数 $P$，以及模 $P$ 的一个原根 $g$。**$\boldsymbol P$ 和 $\boldsymbol g$ 的数值都是公开的，无需保密。**

2. Alice 生成一个随机数 $a$，并计算 $A=g^a\bmod P$，将 $A$ 通过不安全信道发送给 Bob。

3. Bob 生成一个随机数 $b$，并计算 $B=g^b\bmod P$，将 $B$ 通过不安全信道发送给 Alice。

4. Bob 根据收到的 $A$ 计算出**密钥** $K=A^b \bmod P$，而 Alice 根据收到的 $B$ 计算出 $K=B^a\bmod P$。

5. 双方得到了相同的 $K$，即 $g^{ab} \bmod P$。$K$ 即之后通讯的加密密钥。

可见，这个过程中可能被窃听的只有 $A,B$，而 $a,b,K$ 是保密的。并且根据 $A,B,P,g$ 这 $4$ 个数，不能轻易计算出 $K$，因此 $K$ 可以作为一个安全的密钥。

当然安全是相对的，该协议的安全性取决于数值的大小，通常 $a,b,P$ 都选取数百位以上的大整数以避免被破解。然而如果 Alice 和 Bob 编程时偷懒，为了避免实现大数运算，选择的数值都小于 $2^{31}$，那么破解他们的密钥就比较容易了。

$T$ 次给定窃听得到的 $A,B$，你需要尝试破解出**密钥** $K$。


## 说明/提示

对于 $30\%$ 的数据，$2\le A,B,P\le 1000$；

对于 $100\%$ 的数据，$2\le A,B<P<2^{31}，2\le g<20，1\le n\le 20$。

$\text{Statement fixed by @Starrykiller.}$

## 样例 #1

### 输入

```
3 31
3
27 16
21 3
9 26```

### 输出

```
4
21
25```

# AI分析结果



---
# 💡 Kay的C++算法解析：[CQOI2018] 破解D-H协议 深入学习指南 💡

<introduction>
今天我们要一起分析“[CQOI2018] 破解D-H协议”这道题。它的核心是通过已知的公开参数，利用算法破解密钥。让我们从题目本质出发，逐步拆解思路，掌握关键算法！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`BSGS（Baby-Step Giant-Step）算法`（属于“搜索”分类的扩展应用）

🗣️ **初步分析**：
> 题目要求我们根据公开的质数 $P$、原根 $g$，以及窃听到的 $A=g^a \bmod P$ 和 $B=g^b \bmod P$，计算双方的共享密钥 $K=g^{ab} \bmod P$。关键在于如何高效求出指数 $a$（或 $b$），这需要用到 **BSGS算法**。  
> BSGS算法的核心思想是“分块搜索”——把指数 $x$ 拆成 $i \cdot m - j$（$m \approx \sqrt{P}$），通过预处理“小步”（枚举 $j$）和“大步”（枚举 $i$），利用哈希表快速匹配，将时间复杂度从暴力枚举的 $O(P)$ 优化到 $O(\sqrt{P})$。  
> 本题中，我们只需用BSGS求出 $a$（即解 $g^a \equiv A \bmod P$），然后计算 $K=B^a \bmod P$ 即可。  
> 可视化设计上，我们可以用8位像素风格模拟“小步”和“大步”的搜索过程：预处理阶段用蓝色像素块存储哈希表，查询阶段用红色像素箭头遍历，匹配时高亮并播放“叮”的音效，帮助直观理解分块思想。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下题解在多个维度表现突出（评分≥4星），值得重点学习：
</eval_intro>

**题解一：作者Leonid（赞：10）**  
* **点评**：此题解思路直白，直接点明“用BSGS求解一个指数即可”，并提供了完整的BSGS模板。代码中变量命名规范（如`qpow`表示快速幂，`BSGS`函数逻辑清晰），边界处理严谨（如每次调用BSGS前清空哈希表）。其亮点在于将BSGS的核心步骤（预处理小步、枚举大步）通过循环和哈希表实现，代码简洁高效，非常适合新手学习。

**题解二：作者LeavingZzz（赞：7）**  
* **点评**：此题解详细推导了BSGS的数学变形（将方程转化为 $g^{im} \equiv A \cdot g^j \bmod P$），并手写哈希表优化效率（比`map`更快）。代码中对预处理和查询阶段的循环范围（$i \in [1, m]$，$j \in [0, m)$）解释清晰，体现了对BSGS时间复杂度的深刻理解。实践价值高，适合想优化常数的同学参考。

**题解三：作者MY（一名蒟蒻）（赞：6）**  
* **点评**：此题解代码结构工整，BSGS函数中通过`map`存储小步结果，查询时枚举大步，逻辑与标准BSGS一致。特别标注了“每次跑BSGS要清空”的细节，避免哈希表残留数据导致错误，这对调试很有帮助。代码可读性强，适合作为BSGS的入门模板。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于理解BSGS算法的原理，并正确实现其核心步骤。以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **关键点1：BSGS算法的数学变形**  
    * **分析**：BSGS的核心是将指数 $x$ 拆分为 $i \cdot m - j$（$m = \lceil \sqrt{P} \rceil$），将原方程 $g^x \equiv A \bmod P$ 转化为 $g^{i \cdot m} \equiv A \cdot g^j \bmod P$。预处理阶段枚举 $j$ 计算 $A \cdot g^j$ 存入哈希表，查询阶段枚举 $i$ 计算 $g^{i \cdot m}$，匹配哈希表中的值得到 $x = i \cdot m - j$。  
    * 💡 **学习笔记**：分块思想是关键，$m$ 取 $\sqrt{P}$ 时时间复杂度最优（$O(\sqrt{P})$）。

2.  **关键点2：哈希表的正确使用**  
    * **分析**：哈希表用于存储小步计算的结果（$A \cdot g^j$），需注意：  
      - 每次调用BSGS前清空哈希表，避免残留数据干扰。  
      - 若使用`map`，需处理重复键值（保留较大的 $j$ 以保证 $x$ 最小）；手写哈希表可通过取模优化查询速度。  
    * 💡 **学习笔记**：哈希表是BSGS的“记忆库”，正确管理其状态是避免错误的关键。

3.  **关键点3：快速幂的实现与取模**  
    * **分析**：计算 $g^m$（大步的底数）和 $B^a$（最终密钥）时需用快速幂，并在每一步取模，防止数值溢出。快速幂的位运算优化（如`b >>= 1`）能显著提升效率。  
    * 💡 **学习笔记**：快速幂是数论问题的“基础设施”，熟练掌握其实现是解题基础。

### ✨ 解题技巧总结
- **问题简化**：只需解一个指数（$a$ 或 $b$），利用 $K=B^a \equiv A^b \bmod P$ 直接计算结果。  
- **预处理优化**：若多组查询，可预先计算 $g^m$（$m = \sqrt{P}$），避免重复计算。  
- **边界检查**：处理 $A=1$ 或 $g=0$ 等特殊情况（本题中 $g$ 是原根，故 $g \geq 2$，无需额外处理）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合多个优质题解，提炼出一个结构清晰、高效易懂的核心实现，作为解题参考。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了Leonid和MY的题解思路，采用`map`存储小步结果，代码简洁且符合BSGS标准流程，适合新手学习。  
* **完整核心代码**：  
    ```cpp
    #include <cstdio>
    #include <cmath>
    #include <map>
    using namespace std;

    typedef long long ll;

    // 快速幂：计算 (a^b) mod p
    ll qpow(ll a, ll b, ll p) {
        ll res = 1;
        while (b) {
            if (b & 1) res = res * a % p;
            a = a * a % p;
            b >>= 1;
        }
        return res;
    }

    // BSGS算法：求解 g^x ≡ A mod P 的最小非负整数解x
    ll bsgs(ll g, ll A, ll P) {
        A %= P;
        map<ll, ll> hash;  // 存储小步结果：A*g^j mod P -> j
        ll m = ceil(sqrt(P));  // 分块大小

        // 预处理小步（j从0到m-1）
        ll cur = A % P;
        for (ll j = 0; j < m; ++j) {
            hash[cur] = j;
            cur = cur * g % P;
        }

        // 计算大步的底数：g^m mod P
        ll gm = qpow(g, m, P);
        cur = 1;  // 初始为 g^(0*m) = 1

        // 枚举大步（i从1到m）
        for (ll i = 1; i <= m; ++i) {
            cur = cur * gm % P;  // 计算 g^(i*m) mod P
            if (hash.count(cur)) {  // 找到匹配的小步j
                ll j = hash[cur];
                ll x = i * m - j;
                if (x >= 0) return x;  // 保证x非负
            }
        }
        return -1;  // 无解（本题保证有解）
    }

    int main() {
        ll g, P, n;
        scanf("%lld%lld%lld", &g, &P, &n);
        while (n--) {
            ll A, B;
            scanf("%lld%lld", &A, &B);
            ll a = bsgs(g, A, P);  // 求a，使得g^a ≡ A mod P
            printf("%lld\n", qpow(B, a, P));  // 计算K=B^a mod P
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码分为快速幂、BSGS和主函数三部分。快速幂用于高效计算大指数幂取模；BSGS函数通过预处理小步（枚举j）和枚举大步（枚举i），利用哈希表快速匹配，求出指数a；主函数读取输入并调用BSGS求解，最终输出密钥K。

---
<code_intro_selected>
接下来，我们分析优质题解中的核心代码片段，学习其中的巧妙设计。
</code_intro_selected>

**题解一：作者Leonid（来源：用户提供题解）**  
* **亮点**：代码简洁，BSGS函数逻辑清晰，预处理和查询阶段分离，易于理解。  
* **核心代码片段**：  
    ```cpp
    ll BSGS(ll a, ll b, ll p) {
        k.clear(); // 清空哈希表
        ll m = ceil(sqrt(p)), ans;
        for (ll i = 0; i <= m; i++) {
            if (!i) {
                ans = b % p;
                k[ans] = i;
                continue;
            }
            ans = (ans * a) % p;
            k[ans] = i;
        }
        ll t = qpow(a, m, p);
        ans = 1;
        for (ll i = 1; i <= m; i++) {
            ans = (ans * t) % p;
            if (k[ans]) {
                ll o = i * m - k[ans];
                return (o % p + p) % p; // 保证非负
            }
        }
        return -1;
    }
    ```
* **代码解读**：  
  预处理阶段（第一个循环）枚举j（从0到m），计算 $b \cdot a^j \mod p$（即$A \cdot g^j \mod P$）并存入哈希表。查询阶段（第二个循环）枚举i，计算 $a^{i \cdot m} \mod p$（即$g^{i \cdot m} \mod P$），匹配哈希表中的值，返回$x = i \cdot m - j$。`k.clear()`避免了哈希表残留，`(o % p + p) % p`确保结果非负。  
* 💡 **学习笔记**：预处理时从j=0开始，覆盖所有可能的小步情况；查询时i从1开始，确保大步覆盖更大的指数范围。

**题解二：作者LeavingZzz（来源：用户提供题解）**  
* **亮点**：手写哈希表优化常数，比`map`更快，适合处理大P的情况。  
* **核心代码片段**：  
    ```cpp
    struct Hash_table {
        static const LL MOD = 1999997;
        LL Hash[MOD], V[MOD], stk[MOD], top;
        inline void Insert(LL val, LL mi) {
            LL h = val % MOD;
            while (Hash[h] && Hash[h] != val) h++;
            Hash[h] = val; V[h] = mi;
            stk[++top] = h;
        }
        inline LL find(LL val) {
            LL h = val % MOD;
            while (Hash[h] && Hash[h] != val) h++;
            return Hash[h] == val ? V[h] : -1;
        }
    } H;
    ```
* **代码解读**：  
  手写哈希表通过取模（`MOD=1999997`，大质数减少冲突）存储键值对。`Insert`函数处理哈希冲突（线性探测法），`find`函数查询值。`stk`记录插入的位置，方便清空（未在片段中展示，但原代码有`top=0`重置）。  
* 💡 **学习笔记**：手写哈希表在时间敏感的题目中（如P接近$2^{31}$）比`map`更快，但需处理冲突问题。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解BSGS的“小步预处理”和“大步查询”过程，我们设计一个8位像素风格的动画，模拟算法如何通过分块搜索找到指数a。
</visualization_intro>

  * **动画演示主题**：`像素小步与大步的寻宝之旅`  
  * **核心演示内容**：展示BSGS算法如何通过“小步”枚举j（存储哈希表）和“大步”枚举i（匹配哈希表），最终找到指数a，从而计算出密钥K。

  * **设计思路简述**：  
    采用FC红白机风格的像素画面（8色调色板，如深蓝背景、亮黄像素块），将哈希表设计为“宝藏库”，小步枚举的j是“收集宝藏”，大步枚举的i是“寻找钥匙”。关键操作（如插入哈希表、匹配成功）伴随“叮”的音效，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕左侧显示网格状的“哈希宝藏库”（16x16像素块，每个块标有数值和j值）。  
        - 右侧显示“大步跑道”（水平排列的m个像素点，代表i的取值）。  
        - 控制面板包含“单步”“自动播放”按钮和速度滑块（1-5倍速）。

    2.  **小步预处理（j循环）**：  
        - 初始时，A（红色像素块）从起点出发，每次乘以g并取模P（动画：红色块向右移动，数值变化）。  
        - 每计算一个$A \cdot g^j \mod P$（如j=0时为A，j=1时为A·g mod P），将其对应的j值（黄色数字）存入哈希库的对应位置（动画：像素块从右侧飞入哈希库，伴随“叮”音效）。

    3.  **大步查询（i循环）**：  
        - 计算$g^m \mod P$（绿色像素块），作为大步的“步长”。  
        - i从1开始，每次计算$g^{i \cdot m} \mod P$（动画：绿色块沿大步跑道跳跃，数值变化）。  
        - 当绿色块的数值与哈希库中的某个块匹配时（颜色变为亮粉色），弹出提示“找到匹配！i=X，j=Y，a=X·m-Y”，并播放“胜利”音效。

    4.  **结果展示**：  
        - 匹配成功后，动画跳转到计算K的环节：B（蓝色块）进行a次幂运算（动画：蓝色块旋转放大，最终显示K的数值）。

  * **旁白提示**：  
    - （预处理阶段）“看！我们在收集‘小步宝藏’——每个宝藏是A乘以g的j次方模P的结果，j从0到m-1。”  
    - （查询阶段）“现在用‘大步钥匙’——g的m次方的i次方模P，寻找和小步宝藏匹配的数值。”  
    - （匹配时）“叮！找到啦！i·m - j就是我们要的指数a！”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到BSGS如何通过分块思想将暴力枚举转化为高效搜索，理解哈希表在其中的“记忆”作用。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
BSGS算法是解决高次同余方程的核心工具，以下是它的其他应用场景和推荐练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    BSGS适用于求解形如 $a^x \equiv b \mod p$ 的高次同余方程（$p$为质数，$a,p$互质）。类似场景包括：  
    - 离散对数问题（如密码学中的RSA攻击）。  
    - 求解循环节长度（如求最小的k使得$a^k \equiv 1 \mod p$）。  
    - 某些游戏中的随机数生成器破解（如已知生成器参数和部分输出，求初始种子）。

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P3846 [TJOI2007]可爱的质数**  
        * 🗣️ **推荐理由**：BSGS模板题，直接练习算法实现，适合巩固基础。  
    2.  **洛谷 P2485 [SDOI2011]计算器**  
        * 🗣️ **推荐理由**：综合了快速幂、BSGS和扩展欧几里得算法，提升综合应用能力。  
    3.  **洛谷 P4884 多少个1？**  
        * 🗣️ **推荐理由**：变形应用BSGS，求解最小的k使得$11...1$（k个1）是n的倍数，锻炼问题转化能力。

---

## 7\. 学习心得与经验分享

<insights_intro>
部分题解作者分享了调试经验，这些“踩坑”教训对我们很有帮助：
</insights_intro>

> **参考经验 (来自作者MY)**：“一开始没注意每次调用BSGS前要清空哈希表，导致多组测试数据时结果错误。后来加了`_hash.clear()`就正常了。”  
> **点评**：哈希表的状态管理是BSGS的关键！多组查询时，残留的哈希值会导致匹配错误。这个经验提醒我们，在重复使用数据结构（如`map`、手写哈希表）时，一定要在每次调用前重置状态。

---

<conclusion>
通过对“破解D-H协议”的分析，我们掌握了BSGS算法的核心思想和实现技巧。记住，分块搜索和哈希表是BSGS的两大法宝，多练习类似题目（如洛谷P3846）能进一步巩固理解。下一次遇到高次同余问题，你也能轻松破解啦！💪
</conclusion>

---
处理用时：171.13秒
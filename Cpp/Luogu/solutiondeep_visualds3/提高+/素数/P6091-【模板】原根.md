# 题目信息

# 【模板】原根

## 题目描述

给定整数 $n$，求它的所有原根。

为了减小你的输出量，给出输出参数 $d$，设 $n$ 的所有原根有 $c$ 个，从小到大分别为 $g_1,\ldots,g_c$，你只需要依次输出 $g_d,g_{2d},\ldots,g_{\lfloor\frac{c}{d}\rfloor\times d}$。

---

如果你不了解原根的定义，可以自行查找资料或阅读下列定义：

正整数 $g$ 是正整数 $n$ 的原根，当且仅当 $1\leq g\leq n-1$，且 $g$ 模 $n$ 的阶为 $\varphi(n)$。

## 说明/提示

【样例解释】

对于第 $1,2,4,6$ 组数据，给出的 $n$ 的所有原根都出现在输出中。

对于第 $3$ 组数据，$25$ 的原根集合为 $\{2,3,8,12,13,17,22,23\}$。

对于第 $5$ 组数据，$9$ 的原根集合为 $\{2,5\}$。

【数据范围】

对于 $100\%$ 的数据，$1\leq T\leq 10$，$2\leq n\leq 10^6$，$1\leq d\leq 200$，保证输出的数的总个数不超过 $10^5$。

## 样例 #1

### 输入

```
6
2 1
4 1
25 2
36 1
9 6
18 1
```

### 输出

```
1
1 
1
3 
8
3 12 17 23 
0

2

2
5 11 
```

# AI分析结果



---

# 💡 Kay的C++算法解析：【模板】原根 深入学习指南 💡

<introduction>
今天我们来一起分析“【模板】原根”这道C++编程题。原根是数论中的重要概念，理解其存在条件、判定方法及生成过程是解决本题的关键。本指南将帮助大家梳理题目思路，掌握核心算法，并通过可视化和代码赏析提升实践能力。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数论-原根应用`（涉及欧拉函数、阶的性质、原根存在条件与生成方法）

🗣️ **初步分析**：
原根的定义是：若正整数 $g$ 满足 $\gcd(g,n)=1$ 且 $g$ 模 $n$ 的阶等于 $\varphi(n)$（欧拉函数值），则 $g$ 是 $n$ 的原根。解决本题需完成以下步骤：

1. **判断原根存在性**：仅当 $n$ 是 $2,4,p^k,2p^k$（$p$ 为奇素数，$k\geq1$）时存在原根。
2. **求最小原根**：枚举 $g$，验证其是否满足“对 $\varphi(n)$ 的所有质因子 $p$，$g^{\varphi(n)/p}\not\equiv1\pmod{n}$”。
3. **生成所有原根**：若 $g$ 是最小原根，则所有原根为 $g^k$（$k$ 与 $\varphi(n)$ 互质）。
4. **按规则输出**：根据参数 $d$ 输出间隔的原根。

**核心难点**：  
- 如何高效判断原根存在性？  
- 如何快速找到最小原根？  
- 如何生成所有原根并按规则输出？

**可视化设计思路**：  
采用8位像素风格动画，演示枚举最小原根的过程：用不同颜色标记当前枚举的 $g$、$\varphi(n)$ 的质因子检查步骤，动态展示快速幂计算结果（如“1”或非“1”）。生成原根时，用像素方块堆叠表示 $g^k$，并高亮与 $\varphi(n)$ 互质的指数 $k$。动画支持单步/自动播放，关键步骤伴随“叮”的音效（如找到原根时播放胜利音效）。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解表现突出（评分≥4星）：
</eval_intro>

**题解一：作者ix35（赞：65）**  
* **点评**：该题解代码结构清晰，完整实现了原根求解的全流程。预处理欧拉函数和存在性标记，通过枚举验证最小原根，生成所有原根后排序输出。代码变量名易懂（如`phi`表示欧拉函数），边界处理严谨（如特判无原根情况），适合新手学习。

**题解二：作者panyf（赞：36）**  
* **点评**：此题解优化了原根生成步骤，通过埃氏筛思想标记与 $\varphi(n)$ 不互质的数，将时间复杂度优化至 $O(n\log\log\log n)$，效率显著提升。关键优化点（如用筛法替代多次 $\gcd$ 计算）具有启发性，适合进阶学习者参考。

**题解三：作者0xyz（赞：20）**  
* **点评**：该题解提出 $O(n)$ 算法，通过随机化减少枚举次数（仅需200次），并结合扩展欧拉筛优化原根生成。代码简洁（不到1.2kb），运行时间大幅缩短（793ms），展现了算法优化的巧妙性。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决原根问题的核心难点及应对策略如下：
</difficulty_intro>

1.  **关键点1：原根存在性的判断**  
    * **分析**：需验证 $n$ 是否为 $2,4,p^k,2p^k$（$p$ 为奇素数）。通过预处理质数表，标记所有可能的 $p^k$ 及其2倍值，可快速判断存在性。  
    * 💡 **学习笔记**：原根仅存在于特定形式的数中，预处理标记是高效判断的关键。

2.  **关键点2：最小原根的查找**  
    * **分析**：枚举 $g$ 并验证其是否满足“对 $\varphi(n)$ 的所有质因子 $p$，$g^{\varphi(n)/p}\not\equiv1\pmod{n}$”。利用王元定理（最小原根约为 $n^{0.25}$），枚举次数可控。  
    * 💡 **学习笔记**：快速幂和质因子分解是验证原根的核心工具。

3.  **关键点3：所有原根的生成**  
    * **分析**：若 $g$ 是最小原根，则所有原根为 $g^k$（$k$ 与 $\varphi(n)$ 互质）。通过筛法标记与 $\varphi(n)$ 互质的 $k$，避免多次 $\gcd$ 计算，提升效率。  
    * 💡 **学习笔记**：利用欧拉函数性质和筛法，可高效生成所有原根。

### ✨ 解题技巧总结
- **预处理优化**：预处理欧拉函数和质数表，快速判断原根存在性。  
- **质因子分解**：分解 $\varphi(n)$ 的质因子，减少原根验证的计算量。  
- **随机化枚举**：通过随机化减少最小原根的枚举次数（如枚举200次），提升效率。  
- **筛法生成原根**：用筛法标记与 $\varphi(n)$ 互质的指数，避免重复计算 $\gcd$。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结合了预处理、原根判断和生成的完整逻辑。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了ix35和0xyz的题解思路，预处理欧拉函数和原根存在性，通过枚举和筛法生成原根，适用于题目要求的所有场景。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int N = 1e6 + 5;

    int phi[N], prime[N], cnt;
    bool is_prime[N], has_root[N];
    vector<int> factors;

    // 预处理欧拉函数和原根存在性标记
    void init() {
        phi[1] = 1;
        for (int i = 2; i < N; ++i) {
            if (!is_prime[i]) {
                prime[++cnt] = i;
                phi[i] = i - 1;
            }
            for (int j = 1; j <= cnt && i * prime[j] < N; ++j) {
                is_prime[i * prime[j]] = true;
                if (i % prime[j] == 0) {
                    phi[i * prime[j]] = phi[i] * prime[j];
                    break;
                }
                phi[i * prime[j]] = phi[i] * (prime[j] - 1);
            }
        }
        has_root[2] = has_root[4] = true;
        for (int i = 2; i <= cnt; ++i) {
            for (ll j = prime[i]; j < N; j *= prime[i]) has_root[j] = true;
            for (ll j = 2 * prime[i]; j < N; j *= prime[i]) has_root[j] = true;
        }
    }

    // 快速幂计算
    int qpow(int a, int b, int mod) {
        int res = 1;
        while (b) {
            if (b & 1) res = 1LL * res * a % mod;
            a = 1LL * a * a % mod;
            b >>= 1;
        }
        return res;
    }

    // 分解质因子
    void factorize(int x) {
        factors.clear();
        for (int i = 2; i * i <= x; ++i) {
            if (x % i == 0) {
                factors.push_back(i);
                while (x % i == 0) x /= i;
            }
        }
        if (x > 1) factors.push_back(x);
    }

    // 查找最小原根
    int find_min_root(int n) {
        int ph = phi[n];
        factorize(ph);
        for (int g = 1; g < n; ++g) {
            if (__gcd(g, n) != 1) continue;
            bool ok = true;
            for (int p : factors) {
                if (qpow(g, ph / p, n) == 1) {
                    ok = false;
                    break;
                }
            }
            if (ok) return g;
        }
        return -1;
    }

    int main() {
        init();
        int T;
        scanf("%d", &T);
        while (T--) {
            int n, d;
            scanf("%d%d", &n, &d);
            if (!has_root[n]) {
                printf("0\n\n");
                continue;
            }
            int g = find_min_root(n);
            if (g == -1) {
                printf("0\n\n");
                continue;
            }
            int ph = phi[n];
            vector<int> roots;
            int current = g;
            for (int k = 1; k <= ph; ++k) {
                if (__gcd(k, ph) == 1) roots.push_back(current);
                current = 1LL * current * g % n;
            }
            sort(roots.begin(), roots.end());
            printf("%d\n", (int)roots.size());
            for (int i = d - 1; i < (int)roots.size(); i += d) {
                printf("%d ", roots[i]);
            }
            printf("\n");
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先预处理欧拉函数和原根存在性标记（`init`函数），然后通过快速幂（`qpow`）和质因子分解（`factorize`）查找最小原根（`find_min_root`）。主函数中处理输入，生成所有原根并按规则输出。

---

<code_intro_selected>
以下是对优质题解核心代码的片段赏析：
</code_intro_selected>

**题解一：作者ix35**  
* **亮点**：代码结构清晰，完整实现了原根求解流程，变量命名直观。  
* **核心代码片段**：
    ```cpp
    int main() {
        init();
        scanf("%d", &t);
        for (int ii=1;ii<=t;ii++) {
            int wtf;
            scanf("%d%d", &p, &wtf);
            if (rt[p]) {
                ctans=cnt=0;
                proc(phi[p]);
                int mn=findrt(p);
                getrt(p, mn);
                sort(ans+1, ans+ctans+1);
                printf("%d\n", ctans); 
                for (int i=1; i<=ctans/wtf; i++) printf("%d ", ans[i*wtf]);
                printf("\n");
            } else {
                printf("0\n\n");
            }
        }
        return 0;
    }
    ```
* **代码解读**：  
  `init`预处理原根存在性；`findrt`查找最小原根；`getrt`生成所有原根；主函数处理输入输出。通过`rt[p]`快速判断原根存在性，`proc`分解质因子，逻辑清晰。  
* 💡 **学习笔记**：预处理和模块化设计是提升代码可读性的关键。

**题解二：作者0xyz（O(n)优化）**  
* **亮点**：通过随机化减少枚举次数，用筛法优化原根生成。  
* **核心代码片段**：
    ```cpp
    for (ll i=1,p=g;i<=n;i++,p=p*g%m)
        if(u[i])v[p]=1;
    for (ll i=1;i<=m;i++)
        if(v[i])ans[++ca]=i;
    ```
* **代码解读**：  
  `u[i]`标记与 $\varphi(n)$ 互质的指数，`v[p]`标记原根。通过筛法避免重复计算 $\gcd$，时间复杂度降至 $O(n)$。  
* 💡 **学习笔记**：筛法和随机化是优化算法的常用技巧。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为直观理解原根的查找过程，设计以下8位像素风格动画：
</visualization_intro>

  * **动画演示主题**：`原根探险家——寻找n的原根宝藏`

  * **核心演示内容**：  
    展示枚举最小原根的过程（如从1到n-1逐个尝试），验证每个候选g是否满足条件（对 $\varphi(n)$ 的质因子p，计算 $g^{\varphi(n)/p}\bmod n$ 是否为1）。生成所有原根时，用像素方块表示 $g^k$，并高亮与 $\varphi(n)$ 互质的k值。

  * **设计思路简述**：  
    采用FC红白机风格，用不同颜色区分候选g（蓝色）、质因子p（红色）、验证结果（绿色表示通过，红色表示失败）。关键步骤（如快速幂计算、质因子检查）伴随“叮”的音效，找到原根时播放胜利音效，增强学习趣味性。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：屏幕分为左右两部分，左半部分显示当前n和候选g，右半部分显示 $\varphi(n)$ 及其质因子。底部为控制面板（单步/自动/重置按钮、速度滑块）。
    2. **枚举候选g**：从1开始，每个g用蓝色像素块移动到验证区，显示 $\gcd(g,n)$ 是否为1（绿色√或红色×）。
    3. **质因子验证**：对每个质因子p，计算 $g^{\varphi(n)/p}\bmod n$，结果为1则p块变红，否则变绿。若所有p块变绿，g标记为原根（金色）。
    4. **生成所有原根**：以最小原根g为起点，生成 $g^1,g^2,\dots,g^{\varphi(n)}$，与 $\varphi(n)$ 互质的k对应的 $g^k$ 用金色高亮。
    5. **输出结果**：按d间隔输出原根，伴随“叮咚”音效。

  * **旁白提示**：  
    “当前检查g=3，$\gcd(3,25)=1$，开始验证质因子！”  
    “$3^{20/2}=3^{10}\bmod25=24≠1$，通过！”  
    “所有质因子通过，g=3是25的原根！”

<visualization_conclusion>
通过像素动画，学习者可直观看到原根的查找逻辑和数据变化，加深对原根生成过程的理解。
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
原根相关算法在数论中应用广泛，以下是相似问题和拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    原根的生成方法可用于构造模n的既约剩余系，解决离散对数、快速数论变换（NTT）等问题。质因子分解和快速幂是数论问题的通用工具。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P5285** - `【模板】原根测试`  
        * 🗣️ **推荐理由**：直接考察原根的判断与生成，巩固本题核心算法。
    2.  **洛谷 P1072** - `Hankson的趣味题`  
        * 🗣️ **推荐理由**：涉及欧拉函数和质因子分解，提升数论综合应用能力。
    3.  **洛谷 P4884** - `多少个1？`  
        * 🗣️ **推荐理由**：结合原根和循环节问题，拓展原根的实际应用场景。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验和优化思路，以下是值得借鉴的内容：
</insights_intro>

> **参考经验 (来自作者0xyz)**：“在优化原根生成时，发现用筛法替代多次 $\gcd$ 计算可大幅提升效率。随机化枚举最小原根时，仅需200次即可覆盖几乎所有情况。”

**点评**：作者的经验提示我们，算法优化需关注时间复杂度的瓶颈（如多次 $\gcd$ 计算），并灵活运用随机化、筛法等技巧。调试时，通过分析关键步骤的耗时，可针对性优化。

---

<conclusion>
本次关于“【模板】原根”的C++解题分析就到这里。通过理解原根的存在条件、判定方法和生成过程，结合代码实践和可视化演示，相信大家已掌握核心技巧。继续练习相关题目，巩固数论基础，未来将能应对更复杂的数论问题！💪
</conclusion>

---

---
处理用时：175.85秒
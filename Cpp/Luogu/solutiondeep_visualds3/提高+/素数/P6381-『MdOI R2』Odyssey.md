# 题目信息

# 『MdOI R2』Odyssey

## 题目背景

超越音速的极限，不及瑰丽多变的极光；

微弱的脉冲，开拓原本一片混沌的天地；

沉郁的蓝缓缓闪动，史诗的红迎接巅峰；

血色的夕阳尽头，是将夜的星辰；

夜半的满天星空，也会被来自地狱的硝烟掩盖；

炽红炼狱消逝，只金色遗迹永存。

在这里等待着每一位的，都是一段艰苦而璀璨的旅程。

## 题目描述

若正整数 $a$ 与 $b$ 满足：

- $a$ 与 $b$ 的积是一个正整数的 $k$ 次方，即存在正整数 $c$ 使得 $ab=c^k$。

那么我们称 $(a,b)$ 为一组**完美数对**。

---

有一个包含 $n$ 个结点和 $m$ 条边的**有向无环图**，这张图中的每条边都有权值和长度两个属性。

如果一条路径 $P$ 满足**以下条件之一**，则称其为一条**完美路径**：

- $P$ 中仅包含一条边。

- $P$ 从其起点开始依次为 $e_1, e_2, e_3, \ldots e_p$ 这 $p\ (p\ge 2)$ 条边，对于任意的 $1\leq i\leq p-1$，$e_i$ 的权值和 $e_{i+1}$ 的权值组成完美数对。

你需要求出图中最长完美路径的长度，一条路径的长度定义为这条路径上所有边的长度之和。

## 说明/提示

【帮助与提示】  

为方便选手测试代码，本题额外提供两组附加样例供选手使用。  

[样例输入1](https://www.luogu.com.cn/paste/wx1lz6m2) [样例输出1](https://www.luogu.com.cn/paste/28xe7f0x)      

[样例输入2](https://www.luogu.com.cn/paste/efgwngs5) [样例输出2](https://www.luogu.com.cn/paste/5hcpoayt)   

----

【样例解释】

样例中给出的有向无环图如图所示，其中边上的红色数字为边的权值，黑色数字为边的长度：

![](https://cdn.luogu.com.cn/upload/image_hosting/w6x03ksd.png)

最长完美路径为 $2\to 5\to 3$，因为这两条边的权值 $2$ 和 $18$ 满足 $2\times 18=6^2$，是完美数对，此路径长度为 $5+9=14$。

此外，$2\to 1\to 4\to 3,\ \ 2\to 4\to 3,\ \ 1\to 5\to 3$ 等也是完美路径，但不是最长的。

图中，$2\to 1\to 5\to 3$ 长度为 $15$，是一条更长的路径，但它并不是完美路径，因为前两个边权 $24$ 和 $8$ 的乘积为 $192$，不是正整数的平方，即 $(24,8)$ 不是完美数对。

---

【数据范围】

**本题采用捆绑测试。**

对于 $100\%$ 的数据：$1\leq n\leq 10^5,\ \ 1\leq m\leq 2\times 10^5,\ \ 1\leq k\leq 10,\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^5,\ \ 1\leq l\leq 10^4$。

给出的图**不保证弱连通**，图中从一个点到另一个点**可能**存在多条边，但保证给出的图是有向无环图。

| 子任务编号 | $n\leq$ |     $m\leq$      | $w\leq$ | $k\leq$ |  特殊性质  | 分值 |
| :--------: | :-----: | :--------------: | :-----: | :-----: | :--------: | :--: |
| Subtask 1  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $1$   |     无     | $18$ |
| Subtask 2  |  $10$   |       $10$       |  $100$  |  $2$   |     无     | $12$ |
| Subtask 3  |  $600$  | $1.5\times 10^3$ | $10^3$  |   $2$   |     无     | $10$ |
| Subtask 4  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   | $w$ 为素数 | $15$ |
| Subtask 5  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   |     无     | $15$ |
| Subtask 6  |  $600$  | $1.5\times 10^3$ | $10^3$  |  $5$   |     无     | $10$ |
| Subtask 7  | $10^5$  |  $2\times 10^5$  | $10^5$  |  $10$   |     无     | $20$ |



## 样例 #1

### 输入

```
5 7 2
2 5 2 5
5 3 18 9
2 4 6 7
4 3 6 3
2 1 24 2
1 4 6 8
1 5 8 4```

### 输出

```
14```

# AI分析结果



---
# 💡 Kay的C++算法解析：『MdOI R2』Odyssey 深入学习指南 💡

<introduction>
今天我们来分析这道“『MdOI R2』Odyssey”题目。它结合了数论和图论的知识，需要找到有向无环图中最长的“完美路径”。通过本指南，你将理解如何通过质因数分解和动态规划解决这类问题。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（DAG上的动态规划）与数学（质因数分解）的综合应用

🗣️ **初步分析**：
解决这道题的关键在于理解“完美数对”的性质，并将其转化为图论中的状态转移问题。  
简单来说，两个数 \( a \) 和 \( b \) 是完美数对，当且仅当它们的质因数分解中，对应质数的指数之和是 \( k \) 的倍数。我们可以将每个数的质因数指数对 \( k \) 取模，得到一个“简化形式”，此时每个数唯一对应一个能与它组成完美数对的“配对形式”。例如，当 \( k=2 \) 时，\( 2=2^1 \) 的配对形式是 \( 2^{2-1}=2 \)，所以 \( 2 \times 2=4=2^2 \) 是完美数对。

在本题中，我们需要在DAG上，用动态规划（DP）记录每个节点在特定“简化形式”下的最长路径长度。通过拓扑排序遍历DAG，逐步更新每个节点的状态，最终找到最长路径。

核心算法流程：  
1. 对每条边的权值进行质因数分解，计算其“简化形式”（指数对 \( k \) 取模）和“配对形式”（指数为 \( k - \text{简化指数} \)）。  
2. 在DAG上，用 \( dp[u][s] \) 表示以节点 \( u \) 结尾、最后一条边的简化形式为 \( s \) 的最长路径长度。  
3. 拓扑排序遍历DAG，对每条边 \( u \rightarrow v \)，用 \( dp[u][\text{配对形式}] + \text{边长度} \) 更新 \( dp[v][\text{简化形式}] \)。  

可视化设计思路：  
采用8位像素风格，用不同颜色的方块表示节点，边用箭头连接。动态展示质因数分解过程（如分解出的质数以小方块弹出），配对形式生成时用闪光效果。拓扑排序时，当前处理的节点和边高亮，DP状态更新时用数字浮动显示长度变化，关键步骤（如状态转移）伴随“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，以下题解在思路清晰度、代码规范性和算法有效性上表现突出（≥4星）：
</eval_intro>

**题解一：作者BFqwq**  
* **点评**：此题解通过分层图拓扑排序高效处理了权值和配对权值的边。代码中对质因数分解的处理（`xxs`函数）和分层图构建（`topo`函数）非常严谨，特别是通过`f[res1]=res2`记录配对关系，避免了重复计算。虽然代码较长，但逻辑清晰，边界条件（如越界返回）处理到位，适合竞赛参考。

**题解二：作者under_the_time**  
* **点评**：此题解用`map`存储DP状态，简洁地处理了状态爆炸问题。代码中`cal1`和`cal2`函数分别计算配对形式和简化形式，逻辑明确。拓扑排序与DP结合的转移方程（`f[v][w1] = max(f[v][w1], f[u][w2] + l)`）直接体现了核心思路，适合初学者理解。

**题解三：作者Day_Tao**  
* **点评**：此题解特别处理了 \( k=1 \) 的情况（此时所有数对都是完美数对，直接求最长路径），代码结构清晰。`DayTao`函数分解质因数并计算简化/配对形式，注释详细，易于调试。拓扑排序部分用队列实现，符合DAG特性。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于处理数论性质和DAG上的状态转移。以下是核心难点及应对策略：
</difficulty_intro>

1.  **关键点1：如何将边权转化为简化形式和配对形式？**  
    * **分析**：对边权 \( w \) 分解质因数，每个质数的指数对 \( k \) 取模，得到简化形式；配对形式的指数为 \( k - \text{简化指数} \)（模 \( k \) 后）。例如，\( w=18=2^1 \times 3^2 \)（\( k=2 \)），简化形式为 \( 2^1 \times 3^0=2 \)，配对形式为 \( 2^{2-1} \times 3^{2-0}=2 \times 3^2=18 \)。  
    * 💡 **学习笔记**：简化形式和配对形式的计算是连接数论与图论的桥梁，需确保分解质因数的正确性。

2.  **关键点2：如何高效记录DP状态？**  
    * **分析**：由于边权的简化形式可能很大（但实际有效范围有限），直接用数组存储状态会浪费空间。题解中常用`map`或`unordered_map`存储 \( dp[u][s] \)，仅记录存在的状态，节省空间。  
    * 💡 **学习笔记**：状态存储需权衡时间与空间，`map`适合稀疏状态，`unordered_map`（哈希表）查找更快。

3.  **关键点3：如何处理大质因数的越界问题？**  
    * **分析**：当配对形式的计算结果超过题目给定的边权上限（\( 10^5 \)）时，该边无法作为路径的中间边（只能是终点）。题解中通过`if (res > lim) return -1`提前判断，避免无效状态。  
    * 💡 **学习笔记**：越界判断是避免溢出和无效计算的关键，需在配对形式计算时加入。

### ✨ 解题技巧总结
- **问题分解**：将问题拆分为数论处理（简化/配对形式）和图论处理（DAG上的DP），分别解决后再结合。  
- **状态压缩**：用哈希或`map`存储稀疏状态，避免空间爆炸。  
- **边界处理**：对 \( k=1 \) 等特殊情况单独处理（此时所有数对都是完美数对，直接求最长路径）。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解后的通用核心实现，结合了质因数分解、状态转移和拓扑排序的关键逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了BFqwq和under_the_time的题解思路，用`map`存储状态，处理了简化形式和配对形式的计算，适合竞赛使用。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXW = 1e5;
int n, m, k;
struct Edge { int to, l; int s, p; }; // s:简化形式，p:配对形式
vector<Edge> g[100005];
int in[100005];
map<int, int> dp[100005]; // dp[u][s]表示节点u以s结尾的最长路径

// 计算简化形式和配对形式
void get_sp(int w, int &s, int &p) {
    s = 1; p = 1;
    for (int i = 2; i * i <= w; ++i) {
        if (w % i != 0) continue;
        int cnt = 0;
        while (w % i == 0) { w /= i; cnt++; }
        cnt %= k;
        if (cnt == 0) continue;
        // 简化形式：i^cnt
        for (int j = 0; j < cnt; ++j) s *= i;
        // 配对形式：i^(k - cnt)
        for (int j = 0; j < k - cnt; ++j) { p *= i; if (p > MAXW) p = -1; }
    }
    if (w > 1) {
        // 处理剩余的大质数
        if (k != 1) s *= w;
        for (int j = 0; j < k - 1; ++j) { p *= w; if (p > MAXW) p = -1; }
    }
    if (k == 1) s = p = 1; // k=1时所有数对都完美
}

int main() {
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 0; i < m; ++i) {
        int u, v, w, l;
        scanf("%d%d%d%d", &u, &v, &w, &l);
        int s, p; get_sp(w, s, p);
        g[u].push_back({v, l, s, p});
        in[v]++;
    }
    queue<int> q;
    for (int i = 1; i <= n; ++i) if (in[i] == 0) q.push(i);
    int ans = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto &e : g[u]) {
            int v = e.to, l = e.l, s = e.s, p = e.p;
            // 当前边的简化形式是s，需要前一条边的配对形式是p
            int prev = (p == -1) ? 0 : dp[u][p]; // p=-1时无法由前一条边转移
            dp[v][s] = max(dp[v][s], prev + l);
            ans = max(ans, dp[v][s]);
            if (--in[v] == 0) q.push(v);
        }
    }
    printf("%d\n", ans);
    return 0;
}
```
* **代码解读概要**：  
  代码首先通过`get_sp`函数计算每条边的简化形式（s）和配对形式（p）。然后构建图的邻接表，用拓扑排序遍历DAG。对于每条边 \( u \rightarrow v \)，用 \( dp[u][p] + l \) 更新 \( dp[v][s] \)，最终输出最大路径长度。

---

<code_intro_selected>
以下是优质题解的核心代码片段赏析：
</code_intro_selected>

**题解一：作者BFqwq（分层图拓扑排序）**  
* **亮点**：通过分层图（节点 \( u \) 和 \( u+n \) 区分不同状态）避免状态冲突，高效处理配对边。  
* **核心代码片段**：
```cpp
void topo(int w) {
    // 初始化入度、邻接表等
    for (edge v : g[w]) {
        in[v.to + n]++;
        add(v.from, v.to + n, v.lg);
    }
    // 拓扑排序更新dp
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = h[u]; i; i = e[i].nxt) {
            int v = e[i].to, l = e[i].lg;
            dp[v] = max(dp[v], dp[u] + l);
            ans = max(ans, dp[v]);
            if (--in[v] == 0) q.push(v);
        }
    }
}
```
* **代码解读**：  
  `topo`函数处理权值为 \( w \) 和其配对权值的边，通过分层图（\( u \) 和 \( u+n \)）区分不同状态，避免连续使用同一类边。拓扑排序中，用队列处理入度为0的节点，更新每个节点的最长路径长度。  
* 💡 **学习笔记**：分层图是处理状态冲突的有效方法，适用于需要区分不同转移条件的场景。

**题解二：作者under_the_time（map存储状态）**  
* **亮点**：用`map`存储稀疏状态，避免空间浪费，代码简洁。  
* **核心代码片段**：
```cpp
void topo() {
    queue<int> q;
    for (int i = 1; i <= n; ++i) if (in[i] == 0) q.push(i);
    while (q.size()) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to, w1 = e[i].v1, w2 = e[i].v2;
            mp[v][w1] = max(mp[v][w1], mp[u][w2] + e[i].l);
            ans = max(ans, mp[v][w1]);
            if (--d[v] == 0) q.push(v);
        }
    }
}
```
* **代码解读**：  
  `topo`函数中，`mp[v][w1]`表示节点 \( v \) 以简化形式 \( w1 \) 结尾的最长路径。通过`mp[u][w2] + e[i].l`（前一节点 \( u \) 以配对形式 \( w2 \) 结尾的路径长度+当前边长度）更新当前状态。  
* 💡 **学习笔记**：`map`适合存储稀疏状态，虽然查找时间稍高，但空间效率高，适合状态数不确定的场景。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“简化形式生成”和“拓扑排序状态转移”的过程，我们设计了一个8位像素风格的动画演示。
</visualization_intro>

  * **动画演示主题**：像素探险家的完美路径之旅  
  * **核心演示内容**：探险家从起点出发，沿着边权为 \( w \) 的边移动，边权分解为质因数小方块（如 \( 18=2^1 \times 3^2 \) 分解为“2”和“3”的方块），生成简化形式（指数模 \( k \)）和配对形式（\( k - \text{指数} \)）。拓扑排序时，节点按入度顺序点亮，状态转移时用箭头连接，长度数字动态更新。

  * **设计思路简述**：  
    8位像素风格（如FC游戏画面）降低学习门槛，质因数分解用“分解爆炸”动画（小方块弹出）增强记忆。状态转移时，当前处理的边和节点高亮（如红色），配对形式生成时用蓝色闪光。关键步骤（如状态更新）伴随“叮”的音效，成功找到最长路径时播放胜利音效（如《超级玛丽》的通关音）。

  * **动画帧步骤与交互关键点**：  
    1. **初始化场景**：  
       - 屏幕左侧显示DAG（节点为黄色方块，边为箭头），右侧显示质因数分解区（白色背景）和控制面板（单步/自动/重置按钮、速度滑块）。  
       - 播放8位风格的背景音乐（如《塞尔达传说》的轻快旋律）。  

    2. **边权分解与配对生成**：  
       - 点击“开始”，选中一条边（如权值18），质因数分解区弹出“2”和“3”的小方块，数字“1”和“2”（指数）浮动显示。  
       - 指数模 \( k=2 \) 后，显示简化形式“2”（\( 2^1 \times 3^0 \)），配对形式“18”（\( 2^1 \times 3^2 \)）用蓝色闪光提示。  

    3. **拓扑排序与状态转移**：  
       - 入度为0的节点（如节点2）变为绿色，队列中显示该节点。  
       - 处理节点2的出边（如到节点5的边），边高亮红色，状态转移时从节点2的配对形式状态（如18）取出长度，加到节点5的简化形式状态（如2），长度数字从“0”变为“5”（边长度）。  

    4. **目标达成**：  
       - 找到最长路径（如节点2→5→3，长度14）时，路径边变为金色，节点3弹出“胜利”文字，播放上扬音效。  

  * **旁白提示**：  
    - “看！这条边的权值18分解成了2¹×3²，模2后简化形式是2¹×3⁰=2。”  
    - “现在处理节点2，它的出边到节点5，配对形式是18，所以用节点2的18状态长度+5，更新节点5的2状态长度。”  

<visualization_conclusion>
通过这样的动画，我们能直观看到质因数分解、配对形式生成和拓扑排序的每一步，理解状态转移的逻辑。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是数论性质与DAG动态规划的结合，以下是类似问题和练习推荐：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - 质因数分解与模运算结合，可用于处理“乘积为幂次”的问题（如判断两个数是否为平方数对）。  
    - DAG上的动态规划，适用于需要按顺序处理节点、状态依赖的场景（如任务调度中的最长完成时间）。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1113** - 杂务  
        * 🗣️ **推荐理由**：DAG上的最长路径问题，适合练习拓扑排序与动态规划的基础应用。  
    2.  **洛谷 P1357** - 花园  
        * 🗣️ **推荐理由**：结合模运算和动态规划，与本题的数论处理有相似之处。  
    3.  **洛谷 P2014** - 选课  
        * 🗣️ **推荐理由**：树形DP的变形，可拓展对状态转移的理解。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如BFqwq提到“数组开小导致错误”，这提醒我们在处理分层图时需注意节点数量。
</insights_intro>

> **参考经验 (来自BFqwq)**：“在分层图拓扑时，如果 \( x = f_x \) 会建图两次，数组需开双倍数组。”  

**点评**：分层图中，同一节点可能有多个状态（如 \( u \) 和 \( u+n \)），数组大小需足够。调试时，若出现“数组越界”错误，可检查状态数是否被低估。这提示我们在设计状态时，需提前计算可能的状态数量，避免因数组过小导致错误。

---

<conclusion>
通过对“『MdOI R2』Odyssey”的分析，我们掌握了质因数分解、配对形式生成和DAG动态规划的核心技巧。编程的关键在于将复杂问题拆解为可处理的子问题，并选择合适的数据结构优化状态存储。希望大家通过练习巩固这些知识，继续挑战更难的问题！💪
</conclusion>

---
处理用时：182.37秒
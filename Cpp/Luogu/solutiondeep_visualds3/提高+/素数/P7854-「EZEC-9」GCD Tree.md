# 题目信息

# 「EZEC-9」GCD Tree

## 题目背景

规定 $\gcd(x,y)$ 表示 $x,y$ 的最大公约数，$\operatorname{lca}(x,y)$ 表示 $x$ 号节点和 $y$ 号节点的最近公共祖先。

## 题目描述

给你 $n$ 个点，编号分别为 $1,2,\ldots,n$，点权分别为 $a_1,a_2,\ldots,a_n$。

请你用这 $n$ 个点构造一棵树，使得 $\forall 1 \le i < j \le n$，$\gcd(a_i, a_j) = a_{\operatorname{lca}(i, j)}$。

若无解，报告之，否则输出树的形态。

## 说明/提示

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（5 points）：$n = 2$。
-  Subtask 2（5 points）：所有 $a_i$ 均相等。
-  Subtask 3（5 points）：$n \le 5$。
-  Subtask 4（10 points）：保证有解。
-  Subtask 5（15 points）：$n \le 100$。
-  Subtask 6（15 points）：$n \le 10^3$。
-  Subtask 7（15 points）：$n \le 3 \times 10^3$。
-  Subtask 8（30 points）：无特殊限制。

对于 $100 \%$ 的数据，$2 \le n \le 10^5$，$1 \le a_i \le 10^6$。

## 样例 #1

### 输入

```
5
1 2 3 4 5
```

### 输出

```
0 1 1 2 1
```

## 样例 #2

### 输入

```
5
1 2 3 4 6
```

### 输出

```
-1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：「EZEC-9」GCD Tree 深入学习指南 💡

<introduction>
今天我们来一起分析“「EZEC-9」GCD Tree”这道题。这道题要求我们构造一棵树，使得任意两个节点的最近公共祖先（LCA）的权值等于它们的权值的最大公约数（GCD）。本指南将帮助大家理解核心思路、掌握解题技巧，并通过可视化方案直观感受算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`构造与验证树结构（贪心构造+质因数验证）`

🗣️ **初步分析**：
解决这道题的关键在于两步：**构造满足条件的树结构**和**验证树的合法性**。  
简单来说，构造树的过程像“搭积木”——每个节点需要找到一个能整除它的最大权值的父节点，确保祖先关系与GCD的倍数关系一致；验证则像“质检”，检查是否存在两个节点的GCD大于其LCA的权值，这可以通过质因数分布是否在一条链上来判断。

- **题解思路对比**：多数题解先处理重复权值（缩点），再按权值从大到小构造父节点（贪心选择最大因数作为父节点），最后验证质因数分布是否合法。例如，littleKtian的题解通过DFS验证子树关系，LZDQ的题解通过质因数计数验证。
- **核心算法流程**：构造时，用哈希表记录每个权值的节点，枚举倍数为未设置父节点的节点分配父；验证时，检查每个质数的出现是否在一条链上（避免不同子树共享同一质因数）。
- **可视化设计**：采用8位像素风格，用不同颜色的像素块表示节点权值，动态展示父节点连接过程（如节点A滑向父节点B），验证时用红色高亮冲突的质因数。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下题解质量突出（≥4星），值得重点学习：
</eval_intro>

**题解一：作者littleKtian**  
* **点评**：此题解思路清晰，代码规范。构造阶段通过哈希表记录权值节点，枚举倍数为未设置父节点的节点分配父；验证阶段通过DFS检查子树关系和质因数分布。代码中`xh`数组记录权值对应的节点，`fa`数组存储父节点，`dfs`验证子树包含关系，边界处理严谨（如连通性检查`tt!=n-1`）。亮点在于将构造与验证合并，复杂度仅O(n log n)，适合竞赛参考。

**题解二：作者LZDQ**  
* **点评**：此题解巧妙结合质因数分解验证。构造阶段按权值从大到小枚举，为未设置父的倍数节点分配父；验证阶段记录每个质因数的深度最大节点，暴力跳父检查是否覆盖所有该质因数节点。代码中`cnt`记录质因数出现次数，`mx`记录深度最大节点，逻辑简洁高效。亮点在于将验证转化为质因数链的覆盖问题，复杂度O(n log n + V)，适合理解质因数验证技巧。

**题解三：作者Y_B_X**  
* **点评**：此题解详细推导了构造与验证的数学逻辑。构造阶段通过因数分解找到最大因数作为父节点；验证阶段枚举每个质数，检查其倍数节点是否在一条链上。代码中`f_`数组存储父节点，`dep`记录深度，`size`统计子树大小，逻辑严谨。亮点在于将GCD条件转化为质因数互质问题，适合深入理解树结构的数学性质。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于构造正确的树结构并验证其合法性。以下是关键步骤的分析与策略：
</difficulty_intro>

1.  **关键点1：如何正确构造树结构？**  
    * **分析**：每个节点的父节点必须是能整除它的最大权值的节点。例如，权值为6的节点，父节点应选权值为3或6的最大存在节点（若存在权值6的节点，则父为6；否则选3）。构造时需按权值从大到小枚举，确保较大权值的节点优先成为父节点。  
    * 💡 **学习笔记**：构造树的核心是“贪心选最大因数”，确保祖先关系覆盖所有可能的GCD情况。

2.  **关键点2：如何验证树的合法性？**  
    * **分析**：若两个节点的GCD大于其LCA的权值，则它们的质因数必存在公共质数。验证时，需检查每个质数的所有出现节点是否在一条链上（即它们的LCA是该质数的倍数）。例如，质数2的所有节点必须形成一条链，否则存在两个节点的GCD包含2，而它们的LCA权值不含2，导致矛盾。  
    * 💡 **学习笔记**：验证的核心是“质因数链覆盖”，确保每个质数的出现节点在一条链上。

3.  **关键点3：如何处理重复权值节点？**  
    * **分析**：相同权值的节点可缩成一条链（如节点A、B权值均为2，则B的父为A）。缩点后只需处理链顶节点，避免重复计算，简化构造和验证。  
    * 💡 **学习笔记**：缩点是优化关键，减少冗余节点对算法的影响。

### ✨ 解题技巧总结
- **贪心构造**：按权值从大到小枚举，优先为大的权值节点分配子节点，确保父节点是最大可能的因数。  
- **质因数分解**：将GCD条件转化为质因数互质问题，通过质因数链的覆盖验证合法性。  
- **缩点优化**：相同权值的节点缩成链，减少计算量，避免重复处理。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结合了构造与验证的关键逻辑：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了littleKtian和LZDQ的题解思路，构造阶段按权值从大到小枚举父节点，验证阶段检查质因数链覆盖。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 1e5 + 5;
    const int MAXV = 1e6 + 5;

    int n, a[MAXN], fa[MAXN], xh[MAXV]; // xh[v]记录权值v对应的节点编号
    vector<int> children[MAXV]; // 记录每个节点的子节点
    int cnt[MAXV], mx[MAXV], dep[MAXV]; // 质因数验证相关

    int main() {
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i) {
            scanf("%d", &a[i]);
            if (xh[a[i]]) fa[i] = xh[a[i]]; // 重复权值节点的父设为链顶
            else xh[a[i]] = i;
        }

        // 构造树：按权值从大到小枚举，为倍数节点分配父
        for (int v = MAXV; v >= 1; --v) {
            if (!xh[v]) continue;
            int u = xh[v];
            for (int j = 2 * v; j <= MAXV; j += v) {
                if (xh[j] && !fa[xh[j]]) {
                    fa[xh[j]] = u;
                    children[u].push_back(xh[j]);
                }
            }
        }

        // 检查连通性（总边数应为n-1）
        int edge_cnt = 0;
        for (int i = 1; i <= n; ++i) if (fa[i]) edge_cnt++;
        if (edge_cnt != n - 1) {
            puts("-1");
            return 0;
        }

        // 验证：质因数链覆盖
        for (int v = 1; v <= MAXV; ++v) {
            if (!xh[v]) continue;
            int u = xh[v];
            dep[u] = dep[fa[u]] + 1; // 计算深度
            int c = v / (fa[u] ? a[fa[u]] : 1); // 计算c_u = a_u / a_fa[u]
            if (c > 1) {
                cnt[c]++;
                if (dep[u] > dep[mx[c]]) mx[c] = u; // 记录深度最大的节点
            }
        }

        for (int p = 2; p <= MAXV; ++p) {
            if (cnt[p] == 0) continue;
            int s = cnt[p], t = mx[p];
            // 从深度最大的节点向上跳，统计覆盖的质因数p的数量
            while (t > 1) {
                int c = a[t] / a[fa[t]];
                if (c % p == 0) s--;
                t = fa[t];
            }
            if (s != 0) { // 存在未覆盖的质因数p，树不合法
                puts("-1");
                return 0;
            }
        }

        // 输出父节点（注意处理重复权值节点）
        for (int i = 1; i <= n; ++i) printf("%d ", fa[i]);
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先处理重复权值节点（`xh`记录链顶），然后按权值从大到小枚举，为每个权值的倍数节点分配父节点（`children`存储子节点）。接着检查连通性（总边数是否为n-1），最后通过质因数分解验证每个质数的覆盖情况（`cnt`记录质因数出现次数，`mx`记录深度最大节点，向上跳父节点统计覆盖数）。

---

<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者littleKtian（构造与连通性验证）**  
* **亮点**：通过DFS验证子树包含关系，确保构造的树满足LCA条件。  
* **核心代码片段**：
    ```cpp
    void dfs(int w) {
        si[w] = 1, hx[w] = ++dfn;
        for (int o_o = lw[w]; o_o; o_o = bi[o_o][0]) {
            int v = bi[o_o][1];
            dfs(v), si[w] += si[v];
        }
    }
    bool gra(const int &x, const int &y) {
        return hx[x] <= hx[y] && hx[y] < hx[x] + si[x];
    }
    ```
* **代码解读**：  
  `dfs`函数计算每个节点的子树大小（`si`）和DFS序（`hx`），用于判断节点y是否在x的子树中（`gra`函数通过DFS序范围判断）。这一步是验证构造的树是否满足子树包含关系的关键。  
* 💡 **学习笔记**：DFS序是判断子树关系的高效方法，通过记录进入和离开时间可以快速判断包含关系。

**题解二：作者LZDQ（质因数验证）**  
* **亮点**：通过质因数计数和深度最大节点验证链覆盖。  
* **核心代码片段**：
    ```cpp
    for (int i = 1; i <= m; i++) {
        if (p[i]) {
            dep[i] = dep[fw[i]] + 1;
            cnt[i / fw[i]]++;
            if (dep[i] > dep[mx[i / fw[i]]]) mx[i / fw[i]] = i;
        }
    }
    ```
* **代码解读**：  
  `dep`记录节点深度，`cnt`统计每个质因数（`i/fw[i]`）的出现次数，`mx`记录该质因数对应的深度最大节点。后续通过向上跳父节点检查是否覆盖所有该质因数节点。  
* 💡 **学习笔记**：质因数的出现次数和深度最大节点是验证链覆盖的关键，通过统计和跳转可以高效完成验证。

**题解三：作者Y_B_X（因数分解构造父节点）**  
* **亮点**：通过因数分解找到最大因数作为父节点，确保构造的树满足倍数关系。  
* **核心代码片段**：
    ```cpp
    for (j = 2; j <= m; ++j) if (a[i] % j == 0 && bk[k = a[i] / j]) {
        f_[i] = rev[k]; dep[i] = dep[rev[k]] + 1; break;
    }
    ```
* **代码解读**：  
  枚举因数j，找到最大的存在的因数k（`a[i]/j`），将其父节点设为`rev[k]`（k对应的节点），确保父节点是最大可能的因数。  
* 💡 **学习笔记**：因数分解是构造父节点的关键步骤，枚举因数时需从大到小，确保选择最大的存在因数。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解树构造和验证过程，我们设计了一个“像素树探险”动画，用8位像素风格展示节点连接和质因数验证！
</visualization_intro>

  * **动画演示主题**：`像素树的GCD冒险`

  * **核心演示内容**：  
    1. **构造阶段**：节点按权值从大到小排列，每个节点寻找最大因数父节点，用像素箭头（黄色）连接父与子。  
    2. **验证阶段**：每个质因数用不同颜色（如2为红色，3为蓝色）标记，检查所有该颜色节点是否在一条链上（链用同色背景高亮）。

  * **设计思路简述**：  
    8位像素风格（如FC游戏画面）营造轻松氛围；节点连接时播放“叮”的音效（强化操作记忆）；质因数冲突时播放“滴滴”提示音（标记错误）。

  * **动画帧步骤与交互关键点**：

    1. **初始化场景**：  
       屏幕左侧为像素网格（节点用圆形块表示，权值标在上方），右侧为控制面板（单步/自动按钮、速度滑块）。背景播放8位风格BGM。

    2. **构造树（自动播放）**：  
       - 节点按权值从大到小排序（如5→4→3→2→1）。  
       - 权值为5的节点（绿色）作为根，无子节点（无箭头）。  
       - 权值为4的节点（蓝色）寻找最大因数父节点（2存在则连2，否则连1），黄色箭头从4指向父节点。  
       - 每连接一个节点，播放“叮”音效，父节点子树范围用虚线框标记。

    3. **验证质因数（单步执行）**：  
       - 选择质因数2（红色），所有包含2的节点（如2、4、6）高亮。  
       - 从深度最大的节点（如6）开始，向上跳父节点（箭头红色闪烁），统计覆盖的节点数。  
       - 若覆盖数等于总出现数（合法），播放“成功”音效；否则高亮冲突节点（红色闪烁），播放“滴滴”提示音。

    4. **目标达成**：  
       所有质因数验证通过后，树整体闪烁金色，播放胜利BGM；若验证失败，冲突节点红色高亮，显示“-1”。

  * **旁白提示**：  
    - 构造阶段：“当前处理权值5的节点，没有更大的因数，成为根节点～”  
    - 验证阶段：“检查质因数2的节点是否在一条链上…深度最大的节点是6，向上跳父节点…”  

<visualization_conclusion>
通过这个动画，我们能直观看到树构造的每一步和验证的关键逻辑，轻松理解GCD树的核心原理！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可尝试以下题目巩固树构造与验证的技巧：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的贪心构造和质因数验证技巧，还可用于处理“树的路径条件构造”（如路径和为定值）、“质因数相关的树结构问题”（如子树互质）等场景。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1352 没有上司的舞会**  
        * 🗣️ **推荐理由**：练习树的动态规划，理解子树关系的处理，与本题的子树验证逻辑相关。  
    2.  **洛谷 P3384 树链剖分**  
        * 🗣️ **推荐理由**：学习树链剖分技术，掌握子树范围判断和路径查询，与本题的子树包含验证相关。  
    3.  **洛谷 P4013 数字梯形问题**  
        * 🗣️ **推荐理由**：练习构造满足特定条件的树结构，与本题的树构造思路类似。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到了构造树时的“贪心选最大因数”和验证时的“质因数链覆盖”经验，这些对我们有重要参考：
</insights_intro>

> **参考经验 (来自作者littleKtian)**：“构造树时，按权值从大到小枚举能确保父节点是最大可能的因数，避免后续出现无法连接的情况。验证时，DFS序判断子树包含关系能高效解决问题。”  

**点评**：贪心选父节点是构造的核心，确保了祖先关系的正确性；DFS序是子树验证的高效方法，这些经验对处理类似树构造问题非常实用。

-----

<conclusion>
本次关于“「EZEC-9」GCD Tree”的分析就到这里。希望通过这份指南，大家能掌握树构造与验证的核心技巧，并在实践中灵活运用。记住，多动手写代码、画流程图，算法理解会更深刻！下次见～💪
</conclusion>

---
处理用时：175.24秒
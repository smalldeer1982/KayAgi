# 题目信息

# [入门赛 #9] 最澄澈的空与海 (Hard Version)

## 题目背景

材料 1：

> 请小心地计算下面的算式：$138 - 108 \div 6 = ?$  
> 你大概难以置信，这个算式的计算结果竟然是 $5!$

材料 2：

> 对于一个正整数 $x$，$x! = 1 \times 2 \times \cdots \times (x - 1) \times x$。我们称 $x!$ 为 $x$ 的阶乘。  
> 特别的，$0! = 1$。

显然，「$138 - 108 \div 6 = 5$」是错误的，而「$(138 - 108) \div 6 = 5$」是正确的，所以对材料 1 中的内容，部分读者会认为「作者没有搞清加减乘除的运算优先级关系而犯错」。

然而，材料 1 最后一行的叹号并不是标点符号，而是材料 2 提到的「阶乘」。

考虑到这一点，「$138 - 108 \div 6 = 5! = 1 \times 2 \times \cdots \times 5 = 120$」显然就是正确的了。

## 题目描述

然而，此题可能与上面的题目背景关系不是很大。

我们会给你 $T$ 组数据，每组数据包括一个正整数 $n$。

对于每组数据，请你帮助求出满足以下条件的整数三元组 $(x, y, z)$ 的组数：

1. $x \geq 0$，$z \geq 1$。
2. $x - y \div z = n!$ 且 $(x - y) \div z = \dfrac{n!}{n}$。

由于答案可能过大，因此你需要输出答案对 $998244353$ 取模后的结果。

不难注意到答案有可能为 $\infty$，这时请按照「输出格式」要求进行处理。

**请注意此处应满足 $(x - y) \div z = \dfrac{n!}{n}$ 而不是 $= n$。**

请注意这里的 $\div$ 不是向下取整的整除，这显然意味着你需要保证 $y \div z$ 和 $(x - y) \div z$ 为整数。

## 说明/提示

### 样例 1 解释

样例中的具体三元组如下：

| $n$ | 所有可能的三元组 |
| :----------: | :----------: |
| $2$ | $(2, 0, 2)$ |
| $3$ | $\begin{matrix}(8, 4, 2) & (5, -5, 5) & (6, 0, 3)\end{matrix}$ |
| $4$ | $\begin{matrix}(19, -95, 19) & (21, -21, 7) & (24, 0, 4) \\ (27, 9, 3) & (20, -40, 10) & (36, 24, 2)\end{matrix}$ |

### 数据规模与约定

对于前 $20\%$ 的数据，保证 $T \leq 10$，$n \leq 10$。

对于前 $40\%$ 的数据，保证 $n \leq 10 ^ 3$。

对于另外 $20\%$ 的数据，保证 $T = 1$。

对于 $100\%$ 的数据，保证 $1 \leq T \leq 10 ^ 5$，$1 \leq n \leq 10 ^ 6$。

## 样例 #1

### 输入

```
3
2
3
4```

### 输出

```
1
3
6```

# AI分析结果



---
# 💡 Kay的C++算法解析：最澄澈的空与海 (Hard Version) 深入学习指南 💡

<introduction>
今天我们要挑战的题目是「最澄澈的空与海 (Hard Version)」。这道题需要我们通过分析方程条件，推导出满足条件的三元组数量，并结合数学优化技巧高效计算答案。让我们一步步拆解问题，掌握核心思路！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（约数个数计算）与预处理优化技巧

🗣️ **初步分析**：
解决这道题的关键在于将问题转化为数学上的约数个数计算。题目要求我们找到满足两个方程的整数三元组 $(x, y, z)$，通过方程变形可以发现，满足条件的 $z-1$ 必须是 $(n-1)(n-1)!$ 的约数。因此，问题的核心转化为计算 $(n-1)(n-1)!$ 的约数个数。

简单来说，约数个数的计算依赖于**唯一分解定理**：若一个数 $m$ 的质因数分解为 $m = p_1^{e_1} \cdot p_2^{e_2} \cdots p_k^{e_k}$，则其约数个数为 $(e_1+1)(e_2+1)\cdots(e_k+1)$。本题的难点在于如何高效计算大数 $(n-1)(n-1)!$ 的约数个数，尤其是当 $n$ 高达 $10^6$ 且有 $10^5$ 次查询时。

- **题解思路**：所有优质题解均通过方程变形得出答案为 $(n-1)(n-1)!$ 的约数个数，核心差异在于预处理约数个数的优化方法（如线性筛最小质因子、动态维护质因子指数、利用逆元处理模运算等）。
- **核心难点**：如何高效预处理 $(n-1)(n-1)!$ 的约数个数，避免重复计算。
- **可视化设计思路**：通过像素动画演示质因数分解过程（如用不同颜色的像素块表示质因子，动态叠加指数），以及约数个数的计算过程（如乘法树状结构，每一步选择质因子的指数）。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，以下题解在思路清晰度、代码规范性、算法有效性等方面表现突出（评分≥4星），值得重点学习：
</eval_intro>

**题解一：作者Maxmilite（赞：10）**
* **点评**：此题解逻辑严谨，从方程变形到约数个数计算的推导过程非常清晰。代码中使用线性筛预处理最小质因子，并通过动态维护质因子指数和逆元处理模运算，高效解决了多测问题。亮点在于“先增添后撤销”的预处理技巧，避免了重复计算 $(n-1)(n-1)!$ 的质因子指数，时间复杂度优化到 $O(n \log n + T)$，适合竞赛实战。

**题解二：作者Empty_Dream（赞：2）**
* **点评**：此题解以“方程变形→约数个数计算→预处理优化”为主线，思路简洁明了。代码中通过线性筛和动态更新质因子指数的方式维护约数个数，特别是利用逆元处理模运算中的除法，确保了计算的高效性。亮点在于将复杂的质因数分解转化为线性筛最小质因子的递归分解，降低了时间复杂度。

**题解三：作者_Vix_（赞：0）**
* **点评**：此题解代码简洁，直接抓住了预处理约数个数的核心——动态维护质因子指数。通过线性筛预处理最小质因子，并在循环中动态更新每个数的质因子指数，最终快速计算约数个数。亮点在于代码结构清晰，关键步骤（如质因数分解、逆元处理）注释明确，适合初学者理解。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于理解约数个数的计算逻辑，并高效预处理大数的质因子指数。以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **关键点1：方程变形与条件转化**
    * **分析**：如何从题目中的两个方程推导出 $z-1$ 是 $(n-1)(n-1)!$ 的约数？通过两式相减消去 $y$，得到 $x$ 的表达式，结合整数条件即可推导出 $z-1$ 必须整除 $(n-1)(n-1)!$。
    * 💡 **学习笔记**：遇到多方程问题时，优先尝试消元法简化条件，将变量关系转化为数学约束。

2.  **关键点2：约数个数的高效计算**
    * **分析**：直接计算 $(n-1)(n-1)!$ 的质因数分解会因阶乘过大而不可行。通过线性筛预处理每个数的最小质因子，动态维护质因子指数，结合约数个数定理（指数+1的乘积），可高效计算约数个数。
    * 💡 **学习笔记**：预处理最小质因子是质因数分解的常用优化手段，能将分解复杂度从 $O(\sqrt{n})$ 降至 $O(\log n)$。

3.  **关键点3：多测问题的预处理优化**
    * **分析**：对于 $T=1e5$ 次查询，需预处理所有可能的 $n$ 的答案。通过动态维护质因子指数（每次新增一个数时更新指数，并利用逆元处理模运算中的乘除），可实现 $O(n \log n)$ 预处理和 $O(1)$ 查询。
    * 💡 **学习笔记**：预处理时，“先增后删”的技巧（如先加两倍质因子指数，计算答案后再减回）能避免重复计算，提升效率。

### ✨ 解题技巧总结
- **方程变形**：消元法简化条件，将问题转化为数学约束。
- **质因数分解优化**：线性筛预处理最小质因子，快速分解任意数。
- **动态维护指数**：利用逆元处理模运算，动态更新约数个数。
- **多测预处理**：通过预处理所有可能的 $n$ 的答案，实现 $O(1)$ 查询。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，兼顾清晰性与效率：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Maxmilite和Empty_Dream的思路，通过线性筛预处理最小质因子，动态维护质因子指数，高效计算 $(n-1)(n-1)!$ 的约数个数。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MOD = 998244353;
    const int MAXN = 1e6 + 5;

    int min_prime[MAXN];  // 最小质因子数组
    int primes[MAXN], cnt;  // 质数表
    int inv[MAXN];  // 逆元数组
    int ans[MAXN];  // 预处理答案数组
    int factor_count[MAXN];  // 各质因子的指数

    void sieve() {
        for (int i = 2; i < MAXN; ++i) {
            if (!min_prime[i]) {
                min_prime[i] = i;
                primes[++cnt] = i;
            }
            for (int j = 1; j <= cnt && primes[j] <= min_prime[i] && i * primes[j] < MAXN; ++j) {
                min_prime[i * primes[j]] = primes[j];
            }
        }
    }

    void precompute_inv() {
        inv[1] = 1;
        for (int i = 2; i < MAXN; ++i) {
            inv[i] = 1LL * (MOD - MOD / i) * inv[MOD % i] % MOD;
        }
    }

    void precompute_ans() {
        sieve();
        precompute_inv();
        int current_ans = 1;  // 当前约数个数的乘积
        ans[0] = 1;
        for (int i = 1; i < MAXN; ++i) {
            int x = i;
            vector<pair<int, int>> factors;  // 存储i的质因数及其指数
            while (x > 1) {
                int p = min_prime[x];
                int e = 0;
                while (x % p == 0) {
                    x /= p;
                    e++;
                }
                factors.emplace_back(p, e);
            }
            // 先加两倍指数（处理i^2）
            for (auto [p, e] : factors) {
                current_ans = 1LL * current_ans * inv[factor_count[p] + 1] % MOD;
                factor_count[p] += 2 * e;
                current_ans = 1LL * current_ans * (factor_count[p] + 1) % MOD;
            }
            ans[i] = current_ans;
            // 再减回一倍指数（处理i）
            for (auto [p, e] : factors) {
                current_ans = 1LL * current_ans * inv[factor_count[p] + 1] % MOD;
                factor_count[p] -= e;
                current_ans = 1LL * current_ans * (factor_count[p] + 1) % MOD;
            }
        }
    }

    int main() {
        precompute_ans();
        int T;
        scanf("%d", &T);
        while (T--) {
            int n;
            scanf("%d", &n);
            if (n == 1) {
                printf("inf\n");
            } else {
                printf("%d\n", ans[n - 1]);
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
  1. `sieve()`：线性筛预处理每个数的最小质因子，用于快速分解质因数。
  2. `precompute_inv()`：预处理逆元，用于模运算中的除法。
  3. `precompute_ans()`：动态维护质因子指数，计算每个 $(n-1)(n-1)!$ 的约数个数，存储到 `ans` 数组中。
  4. 主函数处理输入，根据 `n` 输出结果（`n=1` 时输出 `inf`）。

---
<code_intro_selected>
以下是优质题解的核心代码片段赏析：
</code_intro_selected>

**题解一：作者Maxmilite**
* **亮点**：使用“先增后删”的预处理技巧，避免重复计算质因子指数。
* **核心代码片段**：
    ```cpp
    for (int i = 1; i <= 1000000; ++i) {
        vcnt = 0;
        lint var = i;
        while (var != 1) {
            int cnt = 0, cur = p[var];
            while (var % cur == 0) var /= cur, ++cnt;
            v[++vcnt] = make_pair(cur, cnt);
        }
        for (int k = 1; k <= vcnt; ++k) {
            pii j = v[k];
            cur *= finv(1 + f[j.first]);
            cur %= modint;
            f[j.first] += j.second * 2;
            cur *= 1 + f[j.first];
            cur %= modint;
        }
        ans[i] = cur;
        for (int k = 1; k <= vcnt; ++k) {
            pii j = v[k];
            cur *= finv(1 + f[j.first]);
            cur %= modint;
            f[j.first] -= j.second;
            cur *= 1 + f[j.first];
            cur %= modint;
        }
    }
    ```
* **代码解读**：
  - 首先分解当前数 `i` 的质因数，存储到 `v` 中。
  - 对每个质因子，先除以原指数+1的逆元，再增加两倍指数，更新当前约数个数乘积。
  - 记录当前答案后，再减回一倍指数，恢复状态，以便处理下一个数。
* 💡 **学习笔记**：“先增后删”是预处理中避免重复计算的常用技巧，适用于需要动态维护状态的场景。

**题解二：作者Empty_Dream**
* **亮点**：代码简洁，通过递归分解最小质因子，动态更新质因子指数。
* **核心代码片段**：
    ```cpp
    void update(int x, int y) {
        while (x > 1) {
            int tmp = pri[x];
            res = res * inv[cnt[tmp] + 1] % mod;
            cnt[tmp] += y;
            res = res * (cnt[tmp] + 1) % mod;
            x /= tmp;
        }
    }

    void init(int x) {
        // 线性筛预处理最小质因子和逆元
        for (int i = 1; i <= x; i++) {
            update(i, 2);
            ans[i] = res;
            update(i, -1);
        }
    }
    ```
* **代码解读**：
  - `update(x, y)` 函数用于更新质因子 `x` 的指数（增加 `y` 倍），并调整当前约数个数乘积。
  - `init(x)` 函数预处理每个数的答案：先加两倍指数（处理 `i^2`），记录答案后减回一倍指数（处理 `i`）。
* 💡 **学习笔记**：函数封装能提高代码的可读性和复用性，适合处理重复操作。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解约数个数的计算过程，我们设计一个“像素质因数探险”动画，用8位像素风格展示质因数分解和约数个数的动态计算！
</visualization_intro>

  * **动画演示主题**：像素质因数探险——寻找 $(n-1)(n-1)!$ 的约数

  * **核心演示内容**：展示从数 `i` 分解质因数，到动态维护质因子指数，最终计算约数个数的全过程。

  * **设计思路简述**：采用8位像素风格（如FC游戏画面），用不同颜色的像素块表示质因子（红=2，绿=3，蓝=5等），动态叠加指数（如红色块堆叠表示2的指数）。通过音效（“叮”表示质因子分解完成，“唰”表示指数更新）和进度条（显示当前处理到的数）增强交互感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕左侧为“质因数分解区”：一个大网格，每个格子代表一个数（如1到1e6），初始为灰色。
        - 右侧为“指数维护区”：多个垂直堆叠的像素柱（高度表示质因子指数），底部标注质因子（如2、3、5等）。
        - 控制面板：包含“单步执行”、“自动播放”按钮和速度滑块。

    2.  **分解质因数**（以 `i=6` 为例）：
        - 点击“单步执行”，`i=6` 所在格子变为黄色，开始分解。
        - 最小质因子2出现（红色像素块），6除以2得3，剩余数变为3；再分解3（绿色像素块），剩余数变为1。
        - 分解完成后，“质因数分解区”显示 `6=2^1×3^1`，伴随“叮”音效。

    3.  **更新质因子指数**：
        - 红色像素柱（质因子2）高度从当前指数（如之前是3）增加1（变为4），绿色像素柱（质因子3）高度从2增加1（变为3）。
        - 约数个数乘积（显示在顶部）从 `(3+1)(2+1)=12` 变为 `(4+1)(3+1)=20`，伴随“唰”音效。

    4.  **计算答案**：
        - 处理完 `i=6` 后，答案数组 `ans[6]` 显示为20，格子变为绿色（表示已处理）。

    5.  **自动播放模式**：
        - 点击“自动播放”，动画以设定速度（如每秒处理100个数）自动执行，像素柱高度动态变化，约数个数乘积实时更新。

    6.  **目标达成**：
        - 当处理到用户查询的 `n-1` 时，对应答案高亮显示，伴随“胜利”音效（如短旋律）。

  * **旁白提示**：
    - “看！当前处理的数是6，它分解为2×3。”
    - “质因子2的指数从3增加到4，质因子3的指数从2增加到3，所以约数个数变为(4+1)(3+1)=20。”
    - “自动播放模式下，我们可以看到所有数的约数个数是如何逐步计算出来的！”

<visualization_conclusion>
通过这个动画，我们能直观看到质因数分解和约数个数计算的每一步，理解预处理的高效性和数学的魅力！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以将思路迁移到其他需要计算约数个数或质因数分解的问题中：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 约数个数计算：适用于所有需要统计满足特定条件的因子数的问题（如求数的因子对、互质数对）。
    - 线性筛预处理：可用于快速分解质因数、计算欧拉函数、莫比乌斯函数等。
    - 动态维护指数：适用于需要递推计算大数函数（如阶乘、幂次）的场景。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1075 [质因数分解](https://www.luogu.com.cn/problem/P1075)**  
        🗣️ 推荐理由：直接练习质因数分解，巩固最小质因子筛法的应用。
    2.  **洛谷 P2615 [神奇的幻方](https://www.luogu.com.cn/problem/P2615)**  
        🗣️ 推荐理由：结合数学规律和模拟，训练问题分析与实现能力。
    3.  **洛谷 P3383 [线性筛法（欧拉筛）](https://www.luogu.com.cn/problem/P3383)**  
        🗣️ 推荐理由：深入理解线性筛的原理，为预处理优化打下基础。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如在处理逆元时容易出错，或质因数分解时遗漏最小质因子。以下是值得借鉴的经验：
</insights_intro>

> **参考经验 (来自作者Maxmilite)**：“在预处理逆元时，一开始忘记处理0的情况，导致模运算出错。后来通过打印中间变量，发现逆元数组初始化错误，修正后问题解决。”

**点评**：作者的经验提醒我们，预处理逆元时需注意边界条件（如逆元[0]无意义），并通过打印中间变量快速定位错误。这是调试模运算问题的有效方法。

---

<conclusion>
通过这道题的学习，我们掌握了方程变形、约数个数计算和预处理优化的核心技巧。希望大家在实践中多思考、多调试，不断提升算法能力！下次再见～💪
</conclusion>

---
处理用时：182.13秒
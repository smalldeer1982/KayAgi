# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果


### 💡 Kay的C++算法解析：中位数 深入学习指南 💡

**题目解读与核心算法识别**  
✨ **本题主要考察**：`数据结构应用（对顶堆）`  
🗣️ **初步分析**：  
> 解决"中位数"这道题，关键在于运用**对顶堆**技巧。简单来说，对顶堆就像两队有序排列的学生：大根堆（左队）维护较小的一半数字（队长相当于"矮个子组"），小根堆（右队）维护较大的一半数字（队长相当于"高个子组"）。中位数就是两队交界处的"标杆学生"——当总人数为奇数时，标杆永远在右队队首。  
> - **核心流程**：每次插入两个数字，根据与当前中位数比较决定放入左队或右队，通过转移堆顶元素保持两队人数平衡（|左队-右队|≤1）。关键变量`mid`动态更新，可视化时需高亮：①新元素插入位置选择 ②堆顶转移过程 ③中位数输出时刻。  
> - **像素动画设计**：采用8-bit复古游戏风格，用绿色像素块表示左队（大根堆），红色像素块表示右队（小根堆），黄色闪烁块标记中位数。控制面板支持单步/自动播放（速度可调），关键操作配"滴"声，找到中位数时播放胜利音效。

---

### 2. 精选优质题解参考  
**题解一（肖恩Sean，赞539）**  
* **点评**：思路清晰直击本质——用大根堆存较小值、小根堆存较大值，通过堆顶交换动态平衡。代码极致简洁（24行），STL运用娴熟：  
  - **逻辑推导**：插入时按堆顶大小分流，循环调整保证堆大小差≤1  
  - **代码规范**：变量名`q1`/`q2`直观，边界处理严谨（`abs(size_diff)>1`）  
  - **算法亮点**：O(n log n)复杂度完美匹配数据规模，空间优化（仅两个优先队列）  
  - **实践价值**：竞赛标准代码，可直接套用模板  

**题解二（IRipple，赞377）**  
* **点评**：创新引入`mid`变量记录当前中位数，通过直接转移`mid`而非堆顶调整：  
  - **巧妙点**：省去堆顶比较，插入后若两队不等则让`mid`加入少数队再更新  
  - **可读性**：40行完整实现，`q1`/`q2`命名明确，调试友好  
  - **改进空间**：调整逻辑稍复杂，但提供另一种平衡视角  

---

### 3. 核心难点辨析与解题策略  
1. **难点1：动态维护有序结构**  
   * **分析**：序列无序增长，需快速定位新元素位置  
   * **解法**：对顶堆天然形成有序分界，插入时仅需比较当前中位数  
   * 💡 **学习笔记**：对顶堆 = 动态排序的"二分屏障"  

2. **难点2：规模平衡控制**  
   * **分析**：保证中位数始终在堆顶需严格平衡两队人数  
   * **解法**：插入后检查`|size_left - size_right|>1`，转移堆顶  
   * 💡 **学习笔记**：堆大小差≤1是中位数正确的充要条件  

3. **难点3：初始与边界处理**  
   * **分析**：首元素特殊处理；偶数插入时暂不输出  
   * **解法**：先单独处理首元素，后续每次插入两个再调整  
   * 💡 **学习笔记**：奇数索引才输出，避免冗余计算  

✨ **解题技巧总结**  
- **问题分解**：将动态中位数转化为两队平衡问题  
- **STL妙用**：`priority_queue`快速实现大小根堆  
- **边界防御**：空堆判断（如`q1.size()>q2.size()`）  
- **循环优化**：成对插入减少调整次数  

---

### 4. C++核心代码实现赏析  
**通用核心实现（肖恩Sean方案优化版）**  
```cpp
#include <iostream>
#include <queue>
#include <cmath>
using namespace std;

int main() {
    int n, x;
    cin >> n;
    priority_queue<int> left;  // 大根堆，存较小值
    priority_queue<int, vector<int>, greater<int>> right; // 小根堆，存较大值
    
    cin >> x;
    left.push(x);
    cout << x << endl;

    for (int i = 2; i <= n; i++) {
        cin >> x;
        // 根据当前中位数分流
        (x > left.top()) ? right.push(x) : left.push(x);
        
        // 平衡堆大小（核心！）
        if (left.size() > right.size() + 1) {
            right.push(left.top());
            left.pop();
        } else if (right.size() > left.size()) {
            left.push(right.top());
            right.pop();
        }
        
        // 奇数索引时输出中位数
        if (i % 2) cout << left.top() << endl;
    }
    return 0;
}
```
**代码解读**：  
1. **初始化**：首元素直接入左队作为初始中位数  
2. **分流插入**：新元素与左队顶比较决定去向（`x≤left.top`入左队）  
3. **平衡调整**：当左队比右队多2个时，转移堆顶到右队；右队更多时反向转移  
4. **输出时机**：仅当`i`为奇数时输出左队顶（因左队始终≥右队）  

---

### 5. 算法可视化：像素动画演示  
**主题**："双堆寻宝"（8-bit探险游戏风）  
**核心演示**：  
![](https://assets.luogu.com.cn/upload/image_hosting/4d0v1f8k.png)  
1. **场景初始化**：  
   - 左侧绿色像素塔（大根堆）代表较小值集合，塔顶数字最大  
   - 右侧红色像素塔（小根堆）代表较大值集合，塔顶数字最小  
   - 控制面板：开始/暂停/单步/速度滑块  

2. **动态插入演示**：  
   - 新数字以蓝色方块下落，比较当前中位数（黄色闪光块）后变色入队  
   - 入队动画：方块沿堆路径滑动至正确位置，堆结构调整时树形重绘  

3. **关键操作高亮**：  
   - **堆顶转移**：当两队高度差>1时，顶部方块闪烁并飞向另一队  
   - **中位数标记**：输出时刻目标堆顶持续闪烁，显示"Mid!"像素文字  

4. **音效交互**：  
   - 入队："滴"（250Hz方波）  
   - 堆顶转移："嗖"（滑音效果）  
   - 找到中位数：8-bit胜利旋律（C大调上行音阶）  

**设计深意**：通过两队高度差视觉化规模平衡，游戏化操作降低理解门槛。单步模式支持观察每次插入后堆结构调整细节。

---

### 6. 拓展练习  
1. **同类迁移**：  
   - 洛谷P1801 黑匣子（动态第K大，双堆进阶）  
   - 洛谷P3871 中位数（带修改操作）  
   - LeetCode 295. Find Median from Data Stream（输入流场景）  

2. **思维进阶**：  
   - 如何扩展支持删除操作？  
   - 若数据流极大（10^7）如何优化？  

> "理解对顶堆平衡思想，80%动态中位数问题迎刃而解" —— Kay

---
处理用时：167.48秒
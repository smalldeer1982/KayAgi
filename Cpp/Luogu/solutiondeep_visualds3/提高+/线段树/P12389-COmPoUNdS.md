# 题目信息

# COmPoUNdS

## 题目背景

小 S 因为某些原因对区间加区间取模情有独钟，他造了一些这样的题但是基本上都不会做。有一天小 S 误食了一点冰红茶突然灵感迸发把所有题都秒了，于是趁着药效他随便选了一道题造了数据，然而药效过了后他也不知道怎么做了，所以请你帮他写一下标程，事成送你一瓶冰红茶。

## 题目描述

给定正整数 $n,k,q$ 和一个长度为 $n$ 的序列 $a$，$q$ 次操作或询问：
- `1 l r c`，对于每个 $i\in[l,r]$，令 $a_i\gets(a_i+c)\bmod k$。
- `2 l1 r1 l2 r2`，判断 $a$ 的两个长度相同的子段 $a_{l_1\cdots r_1},a_{l_2\cdots r_2}$ 是否相等。

## 说明/提示

**本题采用捆绑测试及子任务依赖。**

| 子任务编号 | 分值 | 特殊限制 | 依赖子任务 | 时间限制 |
| :---: | :---: | :---: | :---: | :---: |
| $1$ | $10$ | $n,q\le 10^3$ | | $\text{1.5 s}$
| $2$ | $20$ | $k=2$ | | $\text{2.5 s}$
| $3$ | $20$ | $n\le10^5$ | $1$ | $\text{1.5 s}$
| $4$ | $50$ | 无特殊限制 | $1,2,3$ | $\text{2.5 s}$
 
对于全部数据，$1\le n,q\le 10^6$，$2\le k\le 10^6$，$0\le a_i,c<k$，对于 2 操作 $r_1-l_1=r_2-l_2$。

## 样例 #1

### 输入

```
6 3 6
0 1 2 0 1 2
2 1 2 1 2
2 1 2 4 5
2 1 2 5 6
1 1 2 1
2 1 2 4 5
2 1 2 5 6```

### 输出

```
Yes
Yes
No
No
Yes```

# AI分析结果

# 💡 Kay的C++算法解析：COmPoUNdS 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：差分思想 + 哈希维护 + 线段树/树状数组应用  

🗣️ **初步分析**：  
解决这道题的关键，在于**用差分将“麻烦的区间加模”转化为“简单的单点修改”**——就像把“给一排多米诺骨牌都推一下”，变成“只调整最左边和最右边的骨牌”！  

具体来说：  
- 对于序列`a`，定义差分数组`b[i] = (a[i] - a[i-1]) % k`（`a[0]=0`）。当对区间`[l,r]`加`c`时，`a[l]`增加`c`会让`b[l]`增加`c`，`a[r+1]`（如果存在）减少`c`会让`b[r+1]`减少`c`（模`k`下等价于加`k-c`）。中间的`b[i]`（`l<i<=r`）因为`a[i]`和`a[i-1]`都加了`c`，差分值不变！  
- 要判断两个子段`a[l1..r1]`和`a[l2..r2]`相等，只需满足两个条件：① 起点`a[l1] == a[l2]`（因为后面的元素由起点和差分决定）；② 差分的子段`b[l1+1..r1] == b[l2+1..r2]`（保证后面的变化一致）。  

为了快速验证这两个条件，我们用：  
- **树状数组**维护`a`的前缀和（因为`a[l] = sum(b[1..l]) % k`，树状数组能快速查单点值）；  
- **线段树**维护`b`的哈希值（把`b`的区间转化为一个哈希值，比较哈希值就等于比较整个区间）。  

**可视化设计思路**：  
我们会做一个“像素差分探险家”的动画——用像素块表示`a`数组（不同颜色代表不同值），相邻块的颜色差代表`b[i]`。区间加操作时，`l`和`r+1`的像素块会“闪烁变色”，伴随“叮”的音效；比较子段时，两个子段的像素块会“同步闪烁”，哈希值用像素条显示，相等就亮绿灯+“叮咚”声，不等就亮红灯+“嘟嘟”声。


## 2. 精选优质题解参考

<eval_intro>  
我从思路清晰度、代码可读性、算法有效性等角度筛选出以下优质题解，帮你快速理解核心逻辑~  
</eval_intro>

**题解一：来源：rizynvu（赞：9）**  
* **点评**：这份题解把“差分+哈希+树状数组/线段树”的思路贯彻得非常彻底！它用树状数组维护`a`的前缀和（快速查单点`a[l]`），用线段树维护`b`的哈希（快速比较差分区间）。代码结构清晰，变量命名易懂（比如`sum`数组是树状数组，`tr`是线段树），边界处理严谨（比如`r < n`时才修改`r+1`的差分）。最棒的是，它把“区间加模”转化为“两次单点修改”，完美解决了模运算的麻烦——这正是本题的核心技巧！


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决这道题的关键，在于突破以下3个难点：  
</difficulty_intro>

### 难点1：如何处理“区间加模”的操作？  
**分析**：直接对每个元素加`c`再模`k`，时间复杂度是`O(r-l+1)`，对于`1e6`次操作肯定超时。  
**解决方案**：用差分！区间`[l,r]`加`c`，等价于`b[l] += c`、`b[r+1] -= c`（模`k`下转成加`k-c`）。这样操作的时间复杂度从`O(r-l+1)`降到`O(1)`！

### 难点2：如何快速判断两个子段相等？  
**分析**：直接比较每个元素的时间复杂度是`O(len)`，对于`1e6`次查询也会超时。  
**解决方案**：用哈希！把差分的区间`b[l1+1..r1]`转化为一个哈希值（比如多项式哈希`hash = (b[l1+1]*base^(len-1) + b[l1+2]*base^(len-2) + ... + b[r1]) % mod`），比较两个区间的哈希值就等于比较整个区间——时间复杂度`O(1)`！

### 难点3：如何保证“模运算下差分的正确性”？  
**分析**：模运算会让负数变成正数，比如`(a[i] + c) mod k`可能比`a[i]`小，但差分的性质还成立吗？  
**解决方案**：证明“模运算下，区间加的差分只有两端变化”——假设`a[i]`和`a[i-1]`都加`c`，则`(a[i]+c) - (a[i-1]+c) = a[i]-a[i-1]`，模`k`后的值不变！所以中间的`b[i]`肯定不变，只有两端的`b[l]`和`b[r+1]`会变。

💡 **学习笔记**：差分是处理“区间修改”的神器，哈希是处理“区间比较”的神器，两者结合能解决很多看似复杂的问题！


## 4. C++核心代码实现赏析

<code_intro_overall>  
先看一份**综合优质题解思路的核心实现**，帮你把握整体框架~  
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码综合了rizynvu等题解的思路，用树状数组维护前缀和、线段树维护差分哈希，是本题的典型实现。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
using namespace std;

typedef unsigned long long u64;
const u64 base = 13331;
const int MOD = 998244853;
const int MAXN = 1e6 + 10;

int n, k, q;
int a[MAXN];  // 原数组
u64 pow_base[MAXN];  // 预处理base的幂次

// 线段树：维护差分b的哈希
struct SegmentTree {
    u64 hash[MAXN << 2];  // 区间哈希值
    int len[MAXN << 2];   // 区间长度

    void pushup(int rt) {
        hash[rt] = (hash[rt<<1] * pow_base[len[rt<<1|1]] + hash[rt<<1|1]) % MOD;
        len[rt] = len[rt<<1] + len[rt<<1|1];
    }

    void build(int rt, int l, int r, int b[]) {
        len[rt] = r - l + 1;
        if (l == r) {
            hash[rt] = b[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(rt<<1, l, mid, b);
        build(rt<<1|1, mid+1, r, b);
        pushup(rt);
    }

    void update(int rt, int l, int r, int pos, int val) {
        if (l == r) {
            hash[rt] = (hash[rt] + val + k) % k;  // 保证非负
            return;
        }
        int mid = (l + r) >> 1;
        if (pos <= mid) update(rt<<1, l, mid, pos, val);
        else update(rt<<1|1, mid+1, r, pos, val);
        pushup(rt);
    }

    u64 query(int rt, int l, int r, int L, int R) {
        if (L <= l && r <= R) return hash[rt];
        int mid = (l + r) >> 1;
        if (R <= mid) return query(rt<<1, l, mid, L, R);
        if (L > mid) return query(rt<<1|1, mid+1, r, L, R);
        u64 left = query(rt<<1, l, mid, L, mid);
        u64 right = query(rt<<1|1, mid+1, r, mid+1, R);
        return (left * pow_base[R - mid] + right) % MOD;
    }
} st;

// 树状数组：维护前缀和（求a[l] = sum(b[1..l]) % k）
struct FenwickTree {
    long long sum[MAXN];

    void add(int pos, int val) {
        for (; pos <= n; pos += pos & -pos)
            sum[pos] += val;
    }

    long long query(int pos) {
        long long res = 0;
        for (; pos >= 1; pos -= pos & -pos)
            res += sum[pos];
        return res;
    }
} ft;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    // 预处理base的幂次
    pow_base[0] = 1;
    for (int i = 1; i < MAXN; i++)
        pow_base[i] = (pow_base[i-1] * base) % MOD;

    cin >> n >> k >> q;
    for (int i = 1; i <= n; i++)
        cin >> a[i];

    // 计算差分数组b
    int b[MAXN];
    b[1] = a[1] % k;
    for (int i = 2; i <= n; i++)
        b[i] = (a[i] - a[i-1] + k) % k;  // 保证非负

    // 初始化线段树（维护b的哈希）和树状数组（维护b的前缀和）
    st.build(1, 1, n, b);
    for (int i = 1; i <= n; i++)
        ft.add(i, b[i]);

    while (q--) {
        int op;
        cin >> op;
        if (op == 1) {  // 区间加c
            int l, r, c;
            cin >> l >> r >> c;
            // 修改差分：b[l] += c, b[r+1] -= c（模k）
            st.update(1, 1, n, l, c);
            ft.add(l, c);
            if (r < n) {
                st.update(1, 1, n, r+1, (k - c) % k);
                ft.add(r+1, -c);
            }
        } else {  // 判断子段相等
            int l1, r1, l2, r2;
            cin >> l1 >> r1 >> l2 >> r2;
            // 条件1：a[l1] == a[l2]（sum(b[1..l1]) % k == sum(b[1..l2]) % k）
            long long val1 = ft.query(l1) % k;
            long long val2 = ft.query(l2) % k;
            if (val1 != val2) {
                cout << "No\n";
                continue;
            }
            // 条件2：b[l1+1..r1] == b[l2+1..r2]（哈希值相等）
            if (l1 == r1) {  // 子段长度为1，直接相等
                cout << "Yes\n";
                continue;
            }
            u64 hash1 = st.query(1, 1, n, l1+1, r1);
            u64 hash2 = st.query(1, 1, n, l2+1, r2);
            if (hash1 == hash2) cout << "Yes\n";
            else cout << "No\n";
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **预处理**：计算`base`的幂次（用于哈希的多项式计算）；  
  2. **输入处理**：读入原数组`a`，计算差分数组`b`；  
  3. **初始化数据结构**：线段树`st`维护`b`的哈希（快速比较差分区间），树状数组`ft`维护`b`的前缀和（快速查`a[l]`）；  
  4. **处理操作**：  
     - 操作1（区间加）：修改`b[l]`和`b[r+1]`的差分（线段树和树状数组各更一次）；  
     - 操作2（子段比较）：先查`a[l1]`和`a[l2]`是否相等，再查差分的哈希值是否相等。


<code_intro_selected>  
再剖析**rizynvu题解**的核心片段，看看他的亮点~  
</code_intro_selected>

**题解一：来源：rizynvu**  
* **亮点**：用树状数组维护前缀和（查`a[l]`）、线段树维护差分哈希（比子段），代码简洁，边界处理严谨！  
* **核心代码片段**：  
```cpp
// 线段树的query函数（返回区间哈希值）
inline info_ query(int x, int y, int k = 1, int l = 1, int r = n) {
    if (x <= l && r <= y) return tr[k];
    int mid = l + r >> 1;
    if (y <= mid) return query(x, y, k << 1, l, mid);
    if (mid < x) return query(x, y, k << 1 | 1, mid + 1, r);
    return query(x, y, k << 1, l, mid) + query(x, y, k << 1 | 1, mid + 1, r);
}

// 操作2的判断逻辑
else {
    int l1, r1, l2, r2;
    scanf("%d%d%d%d", &l1, &r1, &l2, &r2);
    if (qry(l1) % K != qry(l2) % K) {  // 条件1：a[l1] == a[l2]
        puts("No");
    } else if (l1 < r1 && query(l1 + 1, r1).sum != query(l2 + 1, r2).sum) {  // 条件2：差分哈希相等
        puts("No");
    } else {
        puts("Yes");
    }
}
```
* **代码解读**：  
  - 线段树的`query`函数：递归查询区间`[x,y]`的哈希值（用`+`运算符重载实现多项式哈希的合并，比如左区间哈希乘右区间长度的`base`幂，加右区间哈希）；  
  - 操作2的判断：先查树状数组的`qry(l1)`（前缀和）模`k`是否等于`qry(l2)`（条件1），再查差分区间`[l1+1,r1]`的哈希值是否等于`[l2+1,r2]`（条件2）。  
* 💡 **学习笔记**：用运算符重载简化哈希的合并，能让代码更简洁！比如`info_`结构体的`+`运算符，直接处理了左哈希乘`base^len`加右哈希的逻辑。


## 5. 算法可视化：像素动画演示

### 🌟 动画主题：像素差分探险家  
**设计思路**：用8位复古像素风，把数组变成“像素地砖”，差分变成“地砖的颜色差”，让你像玩FC游戏一样理解算法！  

### 🎮 动画细节与交互  
1. **场景初始化**：  
   - 屏幕左侧是`a`数组的像素地砖（每个地砖颜色代表`a[i]`的值，比如红色=0，蓝色=1，绿色=2）；  
   - 右侧是“差分条”（用相邻地砖的颜色差表示`b[i]`，比如红→蓝=1，蓝→绿=1）；  
   - 底部是控制面板：`开始/暂停`、`单步`、`重置`按钮，`速度滑块`（从“慢”到“快”），还有`音效开关`。  

2. **核心操作演示**：  
   - **操作1（区间加c）**：选中`[l,r]`的地砖，`l`和`r+1`的差分条会“闪烁黄色”，伴随“叮”的音效——表示这两个位置的差分被修改了！  
   - **操作2（子段比较）**：两个子段的地砖会“同步闪烁”，差分条的哈希值用“像素进度条”显示（比如绿色条长度代表哈希值）。如果相等，进度条会“全绿”并播放“叮咚”声；如果不等，进度条“变红”并播放“嘟嘟”声。  

3. **游戏化元素**：  
   - **过关奖励**：每完成5次正确的比较，会弹出“像素奖杯”动画，加10分；  
   - **AI演示**：点击“AI自动玩”，算法会像“贪吃蛇找食物”一样自动处理操作，你可以跟着看每一步的变化；  
   - **背景音乐**：循环播放8位版《超级玛丽》的轻松BGM，让学习更开心~  

### 🛠️ 实现小贴士  
- 用HTML5 Canvas画像素地砖，每个地砖是10x10像素的方块；  
- 用JavaScript的`setInterval`实现动画帧，速度滑块控制帧间隔（比如慢=500ms/帧，快=100ms/帧）；  
- 用Web Audio API播放音效：`叮`是`440Hz`的正弦波，`叮咚`是`440Hz+880Hz`的组合，`嘟嘟`是`220Hz`的短音。


## 6. 拓展练习与相似问题思考

### 🧠 通用技巧迁移  
本题的核心技巧——**差分+哈希+线段树**，可以解决很多“区间修改+区间查询”的问题，比如：  
1. 区间加一个数，查询区间和（用差分+树状数组）；  
2. 区间翻转，查询区间是否回文（用差分+哈希）；  
3. 区间修改，查询区间内不同元素的个数（用差分+线段树）。

### 📚 洛谷相似题目推荐  
1. **P3372 【模板】线段树 1**：练区间加、区间求和，巩固差分和线段树的基础；  
2. **P1903 数颜色**：练区间修改、区间查询颜色种类，类似本题的“区间操作+快速查询”；  
3. **P2068 统计和**：练树状数组的前缀和查询，巩固本题的“单点修改+单点查询”；  
4. **P5018 对称二叉树**：练哈希的应用，用哈希快速比较子树是否对称。


## 7. 学习心得与经验分享 (若有)

> **参考经验（来自rizynvu题解）**：“发现区间加模的差分性质后，问题就变得简单了！关键是要想清楚模运算下差分的变化——中间的差分不变，只有两端变。”  
> **点评**：这位作者的心得很关键！遇到“区间操作”的问题，先想“能不能用差分转化为单点操作”——这是很多竞赛题的解题突破口。比如本题的模运算看似麻烦，但差分的性质帮我们绕过了模的问题~


## 💪 总结  
这道题的核心是**用差分简化区间操作，用哈希快速比较区间**。记住：  
- 区间加模 → 差分单点修改；  
- 子段相等 → 起点相等 + 差分区间相等；  
- 快速比较 → 哈希值！  

多练类似的题目，你会越来越熟练~下次我们再一起解决更难的编程挑战！🎉


**Kay的小提醒**：如果代码跑不通，试试先小规模测试（比如样例输入），看看差分和哈希的计算是否正确~ 💡

---
处理用时：115.52秒
# 题目信息

# [KOI 2022 Round 2] 红蓝

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

在坐标平面上有 $N$ 个红色点和 $M$ 个蓝色点。给定自然数 $W$ 和 $H$。

第 $i$ 个 ($1 \leq i \leq N$) 红色点的坐标是 $(r_{xi}, r_{yi})$，第 $j$ 个 ($1 \leq j \leq M$) 蓝色点的坐标是 $(b_{xj}, b_{yj})$。

所有点的坐标都是不同的。

我们需要放置一个宽度为 $W$，高度为 $H$ 的矩形，该矩形的边与坐标轴平行，并且它的四个顶点是整数坐标。我们希望最大化矩形内包含的红色点与蓝色点数量之差。

矩形包含点的条件是：如果矩形的左下角坐标为 $(a, b)$，且点的坐标为 $(x, y)$，那么该点包含在矩形内当且仅当满足 $a \leq x \leq a+W$ 且 $b \leq y \leq b+H$。

我们要求得这个差值的最大值，并找到符合这个最大差值的矩形位置。

下图展示了在平面上有 3 个红色点和 4 个蓝色点的情况。为了说明问题，红色点用圆圈表示，蓝色点用三角形表示。

![](https://cdn.luogu.com.cn/upload/image_hosting/1j8grh16.png)

假设 $W = 5$，$H = 3$，那么如果将矩形的左下角放在 $(3, 3)$，矩形内包含 1 个红色点和 3 个蓝色点，这时点的数量差为 2。无论矩形放置在哪里，点的数量差都不会大于 3，因此答案是 2。

![](https://cdn.luogu.com.cn/upload/image_hosting/fxgmqc3b.png)

## 说明/提示

**约束条件**

- $1 \leq N, M \leq 100\,000$
- $1 \leq W, H \leq 10^9$
- $1 \leq r_{xi}, r_{yi} \leq 10^9$ ($1 \leq i \leq N$)
- $1 \leq b_{xj}, b_{yj} \leq 10^9$ ($1 \leq j \leq M$)

**子任务**

1. （5 分）$1 \leq N, M, W, H, r_{xi}, r_{yi}, b_{xj}, b_{yj} \leq 50$
2. （11 分）$1 \leq N, M, W, H, r_{xi}, r_{yi}, b_{xj}, b_{yj} \leq 1\,000$
3. （15 分）$1 \leq N, M \leq 100$
4. （9 分）$1 \leq N, M \leq 1\,000$
5. （60 分）无额外约束条件

## 样例 #1

### 输入

```
3 4 5 3
3 2
2 5
7 6
1 2
4 3
3 6
7 4```

### 输出

```
2
3 3```

## 样例 #2

### 输入

```
3 3 4 4
1 1
2 2
3 3
1 3
3 1
4 4```

### 输出

```
2
-2 -2```

# AI分析结果

---
# 💡 Kay的C++算法解析：红蓝 深入学习指南 💡

<introduction>
  今天我们来一起分析KOI 2022 Round 2的经典题目“红蓝”。这道题需要我们在坐标平面上放置固定大小的矩形，找出红蓝点数量差最大的位置。本指南会帮你梳理核心思路、理解扫描线+线段树的组合技巧，并通过可视化动画直观感受算法流程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：扫描线算法 + 线段树应用（编程技巧应用）

🗣️ **初步分析**：
解决“红蓝”问题的关键，是把**二维矩形的贡献转化为一维问题**——这就像用一把“移动的尺子”（扫描线）沿着y轴从下往上扫过平面，把每个点的贡献“投影”到x轴上，再用线段树维护x轴区间的差值。简单来说：
- **扫描线的核心**：将二维平面的问题拆解成“线移动时的一维变化”，比如本题中每个点能贡献的矩形是固定的（宽度W、高度H），我们把每个点的贡献拆成“下边缘（开始贡献）”和“上边缘（停止贡献）”两条线。
- **本题的应用**：红点的贡献是+1，蓝点是-1。扫描线移动时，每遇到一条边就用线段树更新对应的x区间（比如红点的下边缘让x区间+1，上边缘-1）。线段树会帮我们记录当前x区间的**最大值**和**最小值**（因为差值的绝对值最大可能来自最大正数或最小负数）。

**核心难点与解决方案**：
1. **二维转一维**：每个点的贡献范围是矩形（左x-W、右x，下y-H、上y），拆成上下边扫描即可。
2. **大坐标处理**：坐标范围到1e9，用“离散化”把所有可能的x/y坐标压缩到小范围。
3. **极值与位置维护**：线段树不仅要存区间的最大/最小值，还要记录它们对应的x坐标（方便输出矩形位置）。

**可视化设计思路**：
我们用8位像素风做动画——扫描线是黄色的水平尺，从下往上扫；红蓝点的贡献矩形用红/蓝像素块表示；线段树是右侧的绿色垂直条（亮度代表差值大小）；当前最大差值的位置会闪烁，伴随“叮”的音效。这样你能直观看到“二维问题如何变成一维线段树的变化”！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，帮你快速掌握核心技巧：
</eval_intro>

**题解一：ImposterAnYu**
* **点评**：这份题解用“双指针式扫描线”处理上下线的移动，逻辑特别清晰！它把红蓝点的贡献统一处理（红点+1、蓝点-1），用离散化压缩坐标，线段树同时维护最大值和最小值的绝对值。代码中的“上下线移动”像极了“滑动窗口”，完美把二维问题变成一维，适合新手理解扫描线的本质。

**题解二：hjhAKIOI**
* **点评**：作者直接点出本题和经典题“窗口的星星”类似，扫描线处理x轴的“生效/失效”（比如红点在x开始贡献，x+W+1停止），线段树维护y轴区间的差值。代码结构超简洁——扫描线按x排序，相同x的边一起处理，效率很高，适合学过“窗口的星星”的同学快速迁移思路。

**题解三：Zskioaert1106**
* **点评**：作者把每个点的贡献范围转化为矩形（左x-W、右x，下y-H、上y），拆成“下边缘+1/−1”和“上边缘−1/+1”两条线。线段树不仅维护极值，还记录对应的坐标，最后直接输出结果。代码中的矩形拆分逻辑特别直观，适合刚学扫描线的同学入门。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这类“固定大小矩形的极值问题”，你一定会遇到这3个难点——我们结合题解的共性，给你最有效的解决策略：
</difficulty_intro>

1. **难点1：如何把点的贡献转化为扫描线能处理的边？**
   * **分析**：每个点能被矩形包含的条件是“矩形的左下角在点的贡献矩形内”（比如红点的贡献矩形是[ x-W, x ] × [ y-H, y ]）。我们把这个矩形拆成两条边：下边缘（y-H）时“开始贡献”，上边缘（y+1）时“停止贡献”（因为y处仍能包含点）。
   * 💡 **学习笔记**：二维矩形的贡献，拆成“开始/停止”的边，是扫描线的核心技巧！

2. **难点2：如何处理1e9的大坐标？**
   * **分析**：直接用数组存1e9的坐标不可能，所以要“离散化”——收集所有可能的x坐标（比如每个点的x-W、x），排序后去重，用“压缩后的索引”代替原坐标。
   * 💡 **学习笔记**：离散化是处理大值域问题的“压缩魔法”，记住：只要涉及“区间查询/更新”，都可以试试离散化！

3. **难点3：如何用线段树维护极值和位置？**
   * **分析**：线段树的每个节点要存3样东西：区间的最大值、最小值，以及它们对应的原始x坐标。pushup操作时，比较左右子节点的极值，记录更大/更小的值和位置。
   * 💡 **学习笔记**：线段树不仅能存“值”，还能存“位置”——这是输出最终矩形位置的关键！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**，它综合了3份题解的思路，帮你建立整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码用扫描线处理y轴的上下边，线段树维护x轴区间的差值，离散化坐标，适合新手理解扫描线的完整流程。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;

  const int N = 200005; // 2*(n+m)条边

  struct Line {
      int x1, x2, y, val;
      bool operator<(const Line& other) const { return y < other.y; }
  } lines[N];

  struct Node {
      int mx, mn, pos_mx, pos_mn, add;
  } tree[N << 2];

  vector<int> xs;

  int get_idx(int x) {
      return lower_bound(xs.begin(), xs.end(), x) - xs.begin() + 1;
  }

  void pushup(int p) {
      if (tree[p<<1].mx > tree[p<<1|1].mx) {
          tree[p].mx = tree[p<<1].mx;
          tree[p].pos_mx = tree[p<<1].pos_mx;
      } else {
          tree[p].mx = tree[p<<1|1].mx;
          tree[p].pos_mx = tree[p<<1|1].pos_mx;
      }
      if (tree[p<<1].mn < tree[p<<1|1].mn) {
          tree[p].mn = tree[p<<1].mn;
          tree[p].pos_mn = tree[p<<1].pos_mn;
      } else {
          tree[p].mn = tree[p<<1|1].mn;
          tree[p].pos_mn = tree[p<<1|1].pos_mn;
      }
  }

  void build(int p, int l, int r) {
      if (l == r) {
          tree[p].pos_mx = tree[p].pos_mn = xs[l-1];
          tree[p].mx = tree[p].mn = 0;
          tree[p].add = 0;
          return;
      }
      int mid = (l + r) >> 1;
      build(p<<1, l, mid);
      build(p<<1|1, mid+1, r);
      pushup(p);
  }

  void pushdown(int p) {
      if (tree[p].add) {
          tree[p<<1].mx += tree[p].add;
          tree[p<<1].mn += tree[p].add;
          tree[p<<1].add += tree[p].add;
          tree[p<<1|1].mx += tree[p].add;
          tree[p<<1|1].mn += tree[p].add;
          tree[p<<1|1].add += tree[p].add;
          tree[p].add = 0;
      }
  }

  void update(int p, int l, int r, int L, int R, int val) {
      if (L <= l && r <= R) {
          tree[p].mx += val;
          tree[p].mn += val;
          tree[p].add += val;
          return;
      }
      pushdown(p);
      int mid = (l + r) >> 1;
      if (L <= mid) update(p<<1, l, mid, L, R, val);
      if (R > mid) update(p<<1|1, mid+1, r, L, R, val);
      pushup(p);
  }

  int main() {
      int n, m, W, H;
      cin >> n >> m >> W >> H;
      int tot = 0;
      for (int i = 0; i < n; ++i) {
          int x, y;
          cin >> x >> y;
          int x1 = x - W, x2 = x;
          int y1 = y - H, y2 = y + 1;
          lines[tot++] = {x1, x2, y1, 1};
          lines[tot++] = {x1, x2, y2, -1};
          xs.push_back(x1);
          xs.push_back(x2);
      }
      for (int i = 0; i < m; ++i) {
          int x, y;
          cin >> x >> y;
          int x1 = x - W, x2 = x;
          int y1 = y - H, y2 = y + 1;
          lines[tot++] = {x1, x2, y1, -1};
          lines[tot++] = {x1, x2, y2, 1};
          xs.push_back(x1);
          xs.push_back(x2);
      }
      sort(xs.begin(), xs.end());
      xs.erase(unique(xs.begin(), xs.end()), xs.end());
      sort(lines, lines + tot);
      build(1, 1, xs.size());
      int ans = 0, ans_x = 0, ans_y = 0;
      for (int i = 0; i < tot; ) {
          int y = lines[i].y;
          int j = i;
          while (j < tot && lines[j].y == y) {
              int l = get_idx(lines[j].x1);
              int r = get_idx(lines[j].x2);
              update(1, 1, xs.size(), l, r, lines[j].val);
              j++;
          }
          if (abs(tree[1].mx) > ans) {
              ans = abs(tree[1].mx);
              ans_x = tree[1].pos_mx;
              ans_y = y;
          }
          if (abs(tree[1].mn) > ans) {
              ans = abs(tree[1].mn);
              ans_x = tree[1].pos_mn;
              ans_y = y;
          }
          i = j;
      }
      cout << ans << endl;
      cout << ans_x << " " << ans_y << endl;
      return 0;
  }
  ```
* **代码解读概要**：
  1. **输入处理**：读取红蓝点，生成每个点的上下边（开始/停止贡献）。
  2. **离散化**：收集所有x坐标，排序去重，压缩范围。
  3. **扫描线排序**：按y坐标排序所有边，保证扫描线从下往上扫。
  4. **线段树操作**：建树→扫描线移动时更新线段树→记录最大差值及位置。


---

<code_intro_selected>
接下来看3份题解的**核心片段**，点出它们的亮点：
</code_intro_selected>

**题解一：ImposterAnYu**
* **亮点**：双指针式扫描线（上下线移动），把二维问题变成“滑动窗口”。
* **核心代码片段**：
  ```cpp
  for(int1 L = 1,R = 0; L <= lth[1]; ){
      int1 limit = lsh[1][L] + H;
      while(lsh[1][R + 1] <= limit && R < lth[1]){
          R++;
          for(i = 0; i < siz[R]; i++){
              int1 pos = aty[R][i];
              change(1,1,lth[0],l[pos],r[pos],v[pos]);
          }
      }
      if(L <= R){
          comp(abs(maxn[1]),lsh[0][maxp[1]],lsh[1][L]);
          comp(abs(minn[1]),lsh[0][minp[1]],lsh[1][L]);			
      }
      for(i = 0; i < siz[L]; i++){
          int1 pos = aty[L][i];
          change(1,1,lth[0],l[pos],r[pos],-v[pos]);
      }
      L++;
  }
  ```
* **代码解读**：
  这段是双指针的核心——L是“下线”，R是“上线”，limit是上线的最大y坐标（不能超过L+H）。当R移动时，加入上线扫过的点；当L移动时，删除下线扫过的点。线段树实时维护当前x区间的差值，每次移动后检查最大值和最小值。
* 💡 **学习笔记**：双指针让扫描线的移动更高效，避免重复处理点！

**题解二：hjhAKIOI**
* **亮点**：扫描线处理x轴的生效/失效，和“窗口的星星”完全一致。
* **核心代码片段**：
  ```cpp
  for(int i=1,j;i<=2*n+2*m;i=j+1){
      j=i;
      while(a[j+1].x==a[i].x) j++;
      for(int k=i;k<=j;k++) change(1,Val(a[k].y1),Val(a[k].y2),1,T,a[k].c);
      update(abs(t[1].mn),a[i].x,tmp[t[1].p2]);
      update(abs(t[1].mx),a[i].x,tmp[t[1].p1]);
  }
  ```
* **代码解读**：
  扫描线按x坐标排序，相同x的边一起处理（比如多个点在x处开始或停止贡献）。线段树维护y轴区间的差值，每次处理完x的边后，检查当前的最大差值。
* 💡 **学习笔记**：相同x的边一起处理，能减少线段树的更新次数，提升效率！

**题解三：Zskioaert1106**
* **亮点**：矩形拆分逻辑直观（左x-W、右x，下y-H、上y+1）。
* **核心代码片段**：
  ```cpp
  for(int i=1,x1,x2,y1,y2;i<=n;i++){
      cin>>x2>>y2;
      x1=x2-w,y1=y2-h;
      y2++;
      a[tot].x1=x1,a[tot].x2=x2,a[tot].y=y1,a[tot].p=1;
      a[tot+1].x1=x1,a[tot+1].x2=x2,a[tot+1].y=y2,a[tot+1].p=-1;
      tot+=2;
  }
  ```
* **代码解读**：
  红点的贡献矩形是[ x1=x2-W, x2 ] × [ y1=y2-H, y2 ]，拆成y1的下边缘（+1）和y2的上边缘（-1）。蓝点的处理类似，只是p=-1和+1调换。
* 💡 **学习笔记**：矩形拆分的关键是“上边缘要+1”，确保y2处停止贡献！


## 5. 算法可视化：像素动画演示

**动画演示主题**：像素扫描者——红蓝点的最大差值探索  
**核心演示内容**：8位像素风的坐标平面，扫描线从下往上移动，每个点的贡献矩形用红/蓝像素块表示，线段树用绿色垂直条显示x区间的差值，当前最大差值的位置闪烁并伴随音效。

### 动画帧步骤（融合复古游戏元素）：
1. **场景初始化**：
   - 屏幕左侧是8位像素风的坐标平面（x轴0~20，y轴0~20），红蓝点用红/蓝像素块表示，扫描线是黄色的水平尺（初始在y=0）。
   - 右侧是线段树的可视化：垂直的绿色条（每个x区间对应一条），亮度越高代表差值越大。
   - 底部控制面板有“开始/暂停”“单步”“重置”按钮，速度滑块，还有8位风格的背景音乐（比如《超级玛丽》的轻松BGM）。

2. **扫描线启动**：
   - 扫描线从y=0开始，缓慢向上移动（速度可通过滑块调整）。
   - 每遇到一个点的下边缘（比如红点的y=3），对应的x区间（x1~x2）会变成红色，线段树的绿色条亮度增加（+1），伴随“叮”的音效。

3. **核心步骤演示**：
   - 当扫描线移动到y=5时，线段树的某个绿色条亮度最高（比如x=3~5，差值+3），这个位置会闪烁，屏幕上方显示“当前最大差值：3”。
   - 如果遇到蓝点的下边缘，线段树的亮度会降低（-1），伴随“嗒”的音效。

4. **目标达成**：
   - 当扫描线扫完所有边，屏幕显示“最大差值：2”，并弹出黄色像素框标注矩形位置（比如x=3，y=3），播放“胜利”音效（类似《魂斗罗》的通关音乐）。
   - 用户可以点击“重置”按钮重新演示，或“单步”按钮一步步看每个边的变化。

**设计初衷**：用复古游戏元素降低学习压力，动画直观展示“扫描线如何把二维问题变成一维线段树的变化”，音效增强记忆点——比如“叮”代表“开始贡献”，“嗒”代表“停止贡献”，胜利音效代表“找到最大值”。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了扫描线+线段树的技巧，你可以解决很多**固定大小矩形的极值问题**。以下是推荐的练习：
</similar_problems_intro>

### 通用思路迁移
扫描线+线段树的核心是“二维转一维”，适用于：
1. 求矩形内的最大/最小和（比如“窗口的星星”）。
2. 求矩形面积并/交（比如“矩形面积并”）。
3. 求固定大小窗口内的最大值（比如“滑动窗口最大值”的二维版）。

### 洛谷推荐练习
1. **P1502 窗口的星星**：和本题几乎一样！求窗口内的最大星星数，扫描线+线段树的经典题。
2. **P5490 矩形面积并**：练习扫描线处理多个矩形的面积并，线段树维护区间覆盖长度。
3. **P4281 广告牌**：线段树维护“最左可用位置”，类似本题维护极值的位置。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解三的作者提到：“许久前初学扫描线时调不对的题，今日过了写发题解。”这句话很有共鸣——扫描线的难点在于“矩形拆分”和“线段树的位置维护”，刚开始容易弄错边的坐标（比如上边缘要不要+1）。我的建议是：
</insights_intro>
1. **先模拟小例子**：比如拿样例输入，手动画扫描线的移动过程，看每个边的更新是否正确。
2. **参考经典题**：先做“窗口的星星”，再做本题，思路会更顺。
3. **多调代码**：线段树的pushup和pushdown容易写错，多打印中间值（比如线段树的mx/mn），看是否符合预期。


## 8. 总结

本次分析的“红蓝”问题，核心是**扫描线+线段树**的组合技巧——用扫描线把二维问题转化为一维，用线段树维护区间的极值和位置。通过可视化动画，你能直观看到这个过程；通过优质题解的片段，你能掌握不同的实现细节。

记住：编程能力的提升在于“理解本质+多练经典题”。下次遇到“固定大小矩形的极值问题”，别忘了用扫描线+线段树哦！💪

---

<conclusion>
本次关于“红蓝”的C++解题分析就到这里。希望这份指南能帮你掌握扫描线和线段树的应用。下次我们再一起探索新的算法挑战！
</conclusion>

---
处理用时：189.27秒
# 题目信息

# 楼房

## 题目描述

地平线（$x$ 轴）上有 $n$ 个楼房，每个楼房可以表示为一个矩形。

用三个整数 $h_i,l_i,r_i$ 来表示第 $i$ 个矩形：矩形左下角为 $(l_i,0)$，右上角为 $(r_i,h_i)$。

地平线高度为 $0$。在轮廓线长度最小的前提下，从左到右输出轮廓线。

## 说明/提示

样例二如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/pmf4pzif.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/5ec8sxwi.png)

数据范围:

对于 $30\%$ 的数据，$n\le100$。

对于另外 $30\%$ 的数据，$1\le h_i,l_i,r_i\le 1000$。

对于 $100\%$ 的数据，$1\le n\le10^5$，$1\le h_i\le 10^9$，$-10^9\le l_i<r_i\le10^9$。

## 样例 #1

### 输入

```
2
3 0 2
4 1 3
```

### 输出

```
6
0 0
0 3
1 3
1 4
3 4
3 0```

## 样例 #2

### 输入

```
5
3 -3 0
2 -1 1
4 2 4
2 3 7
3 6 8```

### 输出

```
14
-3 0
-3 3
0 3
0 2
1 2
1 0
2 0
2 4
4 4
4 2
6 2
6 3
8 3
8 0```

# AI分析结果


# 💡 Kay的C++算法解析：楼房轮廓线 深入学习指南 💡

> 大家好，我是Kay！今天我们将一起探索「楼房轮廓线」这道有趣的算法题。想象一下，你是一名城市规划师，要在城市地平线上画出所有楼房的轮廓线。这道题考验我们如何高效处理几何重叠问题，让我们一起来拆解它吧！

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`扫描线算法`与`堆(优先队列)应用`

🗣️ **初步分析**：
> 解决楼房轮廓线问题，关键在于运用**扫描线算法**。想象一下，你有一根垂直的扫描线从左向右移动，每当遇到楼房的边界（左侧或右侧），就会触发一次“事件”。我们需要在这些事件点上动态计算当前最高楼高，就像在玩一个动态更新的俄罗斯方块游戏——不断堆叠和移除方块，同时记录最高点的变化轨迹。

在本题中，扫描线算法配合堆结构的使用非常巧妙：
- **核心流程**：
  1. 将每个矩形拆分成两个事件：左边界（入边，高度为h）和右边界（出边，高度为h）
  2. 按x坐标排序所有事件（相同x时入边优先，且高度大的入边优先）
  3. 扫描过程中用最大堆维护当前有效高度
  4. 当堆顶高度变化时，记录轮廓点（x坐标，旧高度）和（x坐标，新高度）

- **可视化设计思路**：
  - 像素动画将展示扫描线（红色竖线）从左向右移动
  - 入边事件时，对应楼房高度方块“升起”（绿色动画+“叮”音效）
  - 出边事件时，高度方块“消失”（灰色渐隐+“嘟”音效）
  - 堆顶变化时，轮廓点闪烁金色星星（“胜利”音效）
  - 采用8位像素风格，类似经典游戏《俄罗斯方块》的视觉呈现

---

## 2. 精选优质题解参考

<eval_intro>
以下题解从思路清晰度、代码规范性、算法优化等维度均获得4星以上评价，特别适合学习参考：
</eval_intro>

**题解一（作者：shuri001）**
* **点评**：该题解采用扫描线+multiset（模拟堆）的方案，思路清晰且代码规范。亮点在于：
  - 事件排序逻辑严谨（相同x坐标时，入边高度降序，出边高度升序）
  - 利用multiset的自动排序特性高效维护当前最大高度
  - 边界处理完整，对堆顶高度变化的检测逻辑简洁有力
  - 代码变量命名合理（如`l[i].up`表高度，`s`表高度集合）

**题解二（作者：xiaolou）**
* **点评**：该解法使用离散化+线段树方案，优势在于：
  - 详细演示了坐标离散化过程（`unique`和`lower_bound`的规范使用）
  - 线段树实现完整，包含建树、标记下传等关键操作
  - 输出部分通过比较离散区间高度变化生成轮廓点，逻辑严密
  - 特别适合想深入学习线段树的同学

**题解三（作者：wanghanjun）**
* **点评**：同样是线段树方案，但代码更简洁：
  - 离散化处理干练高效，避免冗余操作
  - 线段树更新时采用最大值覆盖（`max`操作）而非累加
  - 轮廓点生成时通过`last`变量避免重复记录
  - 实践价值高，可直接用于竞赛场景

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决轮廓线问题的核心挑战在于处理边界情况和状态同步，以下是三个关键难点及应对策略：
</difficulty_intro>

1.  **事件排序与处理优先级**
    * **分析**：当多个事件位于同一x坐标时，处理顺序直接影响结果。必须确保：
      - 入边优先于出边（避免楼房未加入就被移除）
      - 入边中高度大的优先（防止矮楼遮挡高楼）
      - 出边中高度小的优先（确保高楼移除后矮楼能及时补位）
    * 💡 **学习笔记**：事件排序是扫描线算法的“方向盘”，顺序错误会导致整个轨迹偏移

2.  **堆的懒删除机制**
    * **分析**：出边事件需要删除堆中对应高度，但堆不支持直接删除。解决方案：
      - 维护一个`toRemove`映射记录待删除高度
      - 每次取堆顶时检查是否已被标记删除
      - 只有堆顶元素被删除时才触发重组
    * 💡 **学习笔记**：懒删除是处理堆中无效元素的黄金法则，避免O(n)的全堆扫描

3.  **轮廓点生成时机**
    * **分析**：轮廓点只应在高度变化时记录，但需注意：
      - 同一x坐标多次变化只需记录首尾两点
      - 高度从0开始（地面）且最终回归0
      - 相邻轮廓点的x坐标相同但y坐标不同
    * 💡 **学习笔记**：轮廓线总是成对出现（x,y1）和（x,y2），形成“台阶状”

### ✨ 解题技巧总结
<summary_best_practices>
通过本题可以提炼以下通用解题技巧：
</summary_best_practices>
- **事件驱动思想**：将静态几何问题转化为动态事件序列处理
- **数据结构协同**：堆处理全局最值，哈希表辅助懒删除
- **离散化技巧**：将大范围坐标映射到紧凑区间，降低空间复杂度
- **边界预置法**：初始在堆中加入0高度，避免空堆检测

---

## 4. C++核心代码实现赏析

<code_intro_overall>
下面是一个整合优质题解思路的通用实现，采用扫描线+堆方案：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合自shuri001的扫描线思路与堆的懒删除技巧
* **完整核心代码**：
```cpp
#include <vector>
#include <queue>
#include <algorithm>
#include <unordered_map>
using namespace std;

struct Event {
    int x, h;
    bool isStart; // true:入边, false:出边
    Event(int x, int h, bool isStart) : x(x), h(h), isStart(isStart) {}
};

vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
    vector<Event> events;
    // 生成事件：左边界入边，右边界出边
    for (auto& b : buildings) {
        events.emplace_back(b[0], b[2], true);
        events.emplace_back(b[1], b[2], false);
    }
    // 事件排序：x为主序，事件类型为次序（入边优先），高度按需排序
    sort(events.begin(), events.end(), [](const Event& a, const Event& b) {
        if (a.x != b.x) return a.x < b.x;           // x坐标不同，按x排序
        if (a.isStart && b.isStart) return a.h > b.h; // 同入边，高度大的优先
        if (!a.isStart && !b.isStart) return a.h < b.h; // 同出边，高度小的优先
        return a.isStart; // 入边优先于出边
    });

    priority_queue<int> maxHeap; // 最大堆维护当前高度
    unordered_map<int, int> toRemove; // 懒删除记录
    maxHeap.push(0); // 初始地面高度
    int prevMax = 0;  // 记录前一次最大高度
    vector<vector<int>> ans;

    for (auto& e : events) {
        if (e.isStart) {
            maxHeap.push(e.h); // 入边：高度加入堆
        } else {
            toRemove[e.h]++;  // 出边：标记待删除
            // 清理堆顶无效元素
            while (!maxHeap.empty() && toRemove.count(maxHeap.top()) && toRemove[maxHeap.top()] > 0) {
                toRemove[maxHeap.top()]--;
                if (toRemove[maxHeap.top()] == 0) toRemove.erase(maxHeap.top());
                maxHeap.pop();
            }
        }

        int currMax = maxHeap.top();
        if (currMax != prevMax) { // 高度变化记录轮廓点
            ans.push_back({e.x, prevMax});
            ans.push_back({e.x, currMax});
            prevMax = currMax;
        }
    }
    return ans;
}
```
* **代码解读概要**：
  1. **事件生成**：每个矩形拆分为左入边和右出边
  2. **事件排序**：确保在相同x坐标下处理顺序正确
  3. **堆与懒删除**：`maxHeap`维护当前高度，`toRemove`跟踪待删除高度
  4. **轮廓点记录**：仅当堆顶高度变化时记录两点（x,旧高）和（x,新高）

---
<code_intro_selected>
下面针对各优质题解的核心代码片段进行赏析：
</code_intro_selected>

**题解一（shuri001）核心代码**
```cpp
// 事件排序
sort(l+1, l+cnt+1, [](const Line& a, const Line& b) {
    if (a.x != b.x) return a.x < b.x;
    if (a.k != b.k) return a.k > b.k; // 入边(k=1)优先
    if (a.k == 1) return a.up > b.up; // 入边高度降序
    return a.up < b.up; // 出边高度升序
});

multiset<int> s = {0}; // 初始地面高度
int prevMax = 0;
for (auto& e : events) {
    int currMax = *s.rbegin(); // 获取当前最大高度
    if (e.isStart) {
        if (e.h > currMax) { // 产生上升轮廓点
            ans.push_back({e.x, currMax});
            ans.push_back({e.x, e.h});
        }
        s.insert(e.h);
    } else {
        if (e.h == currMax && s.count(e.h) == 1) { 
            s.erase(e.h);
            ans.push_back({e.x, e.h});
            ans.push_back({e.x, *s.rbegin()});
        } else {
            s.erase(s.find(e.h));
        }
    }
}
```
* **亮点**：使用multiset自动排序特性替代手动堆，代码更简洁
* **学习笔记**：multiset的`rbegin()`获取最大值，但需注意删除时通过`find`定位迭代器

**题解二（xiaolou）线段树片段**
```cpp
void update(int id, int l, int r, int ql, int qr, int val) {
    if (ql > r || qr < l) return;
    if (ql <= l && r <= qr) {
        tree[id].max = max(tree[id].max, val); // 区间更新最大值
        tree[id].lazy = max(tree[id].lazy, val);
        return;
    }
    pushdown(id); // 标记下传
    int mid = (l + r) >> 1;
    update(id<<1, l, mid, ql, qr, val);
    update(id<<1|1, mid+1, r, ql, qr, val);
    pushup(id); // 更新父节点
}
```
* **亮点**：线段树区间更新采用`max`操作而非覆盖，保留历史高度
* **学习笔记**：离散化后区间更新需注意右边界-1（点区间→线段区间）

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为了直观理解扫描线算法，我设计了像素风格的动画演示方案，融入复古游戏元素：
</visualization_intro>

* **动画主题**：《轮廓冒险者》——扫描线穿越楼房森林

* **核心演示内容**：
  - 扫描线（红色竖线）从左向右移动，触发三种事件：
    * 🟩 **入边事件**：对应楼房升起绿色方块，播放“叮”音效
    * 🟥 **出边事件**：方块变为灰色消失，播放“嘟”音效
    * 🌟 **轮廓点事件**：堆顶变化时出现金色星星，播放“胜利”音效

* **像素化设计**：
  - **场景网格**：将x轴按坐标离散化为像素列（每列宽8像素）
  - **楼房表示**：不同高度用不同颜色方块（高度值映射到16色调色板）
  - **堆状态可视化**：右侧“堆塔”区域动态显示当前堆内高度方块
  - **轮廓线绘制**：底部金色折线随事件动态延伸

* **交互控制面板**：
  - 🎮 方向键控制扫描线移动（步进模式）
  - ⚡ 自动播放模式（速度可调：慢速/中速/快速）
  - 🔁 重置按钮（清除轮廓线重新开始）
  - 🔇 音效开关

* **关键帧示例**：
  1. 初始状态：扫描线在最左，堆塔只有0高度（地面）
  2. 遇到第一个入边：楼房升起，堆塔更新，轮廓线出现第一个上升台阶
  3. 遇到出边：堆塔移除对应方块，若高度降低则生成下降台阶
  4. 最终状态：扫描线到达最右，堆塔只剩0高度，轮廓线闭合

* **技术实现**：
  - 使用HTML5 Canvas绘制网格和动态元素
  - 事件触发时更新堆塔的DOM结构
  - Web Audio API实现8位音效：
    ```js
    function playSound(type) {
        const ctx = new AudioContext();
        const osc = ctx.createOscillator();
        osc.type = type === 'rise' ? 'sine' : 'square';
        osc.frequency.value = type === 'rise' ? 880 : 440;
        osc.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + 0.1);
    }
    ```

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握扫描线算法后，可解决更多几何重叠问题：
</similar_problems_intro>

* **通用思路迁移**：
  - 矩形面积并：统计多个矩形覆盖的总面积
  - 矩形周长并：计算所有矩形边界总长度
  - 重叠矩形计数：找出被最多矩形覆盖的区域

* **练习推荐（洛谷）**：
  1. **P5490 【模板】扫描线**  
     🗣️ *推荐理由*：扫描线最基础应用，练习区间维护技巧
  2. **P1904 天际线**  
     🗣️ *推荐理由*：本题简化版，数据规模小适合调试
  3. **P1856 [USACO5.5]矩形周长Picture**  
     🗣️ *推荐理由*：扫描线进阶应用，需要同时处理水平和垂直边界

---

## 7. 学习心得与经验分享

<insights_intro>
从题解中提炼的宝贵经验：
</insights_intro>

> **来自shuri001的调试经验**：
> “我在处理事件排序时，最初未考虑同一x坐标下多事件的优先级，导致轮廓线出现跳变。通过添加详细排序规则解决——这提醒我们：边界情况处理是扫描线算法的核心。”

> **Kay的总结**：
> 调试此类问题时，建议：
> 1. 打印事件序列及处理前的堆状态
> 2. 对特殊测试用例手动模拟（如重叠边界）
> 3. 可视化中间结果（如每步当前高度曲线）

---

<conclusion>
本次关于“楼房轮廓线”的解析就到这里。记住：算法学习就像建造楼房——先打好基础（理解核心思想），再搭建框架（设计数据结构），最后完善细节（处理边界情况）。期待下次和你一起探索新的算法挑战！💪
</conclusion>
```

---
处理用时：202.15秒
# 题目信息

# [NOI2016] 区间

## 题目描述

在数轴上有 $n$ 个闭区间从 $1$ 至 $n$ 编号，第 $i$ 个闭区间为 $[l_i,r_i]$ 。

现在要从中选出 $m$ 个区间，使得这 $m$ 个区间共同包含至少一个位置。换句话说，就是使得存在一个 $x$ ，使得对于每一个被选中的区间 $[l_i,r_i]$，都有 $l_i \leq x \leq r_i$ 。

对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。

区间 $[l_i,r_i]$ 的长度定义为 $(r_i-l_i)$ ，即等于它的右端点的值减去左端点的值。

求所有合法方案中最小的花费。如果不存在合法的方案，输出 $-1$。

## 说明/提示

#### 样例输入输出 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/qoddox9k.png)
 
 如图，当 $n=6$，$m=3$ 时，花费最小的方案是选取 $[3,5],[3,4],[1,4]$ 这三个区间，它们共同包含了 $4$ 这个位置，所以是合法的。其中最长的区间是 $[1, 4]$，最短的区间是 $[3, 4]$，所以它的花费是 $(4 - 1) - (4 - 3) = 2$。

#### 数据规模与约定

本题共 20 个测试点，各测试点信息如下表。
| 测试点编号 | $ n= $ | $ m= $ | $ l_i,r_i $ |
|:-:|:-:|:-:|:-:|
| 1 | $ 20 $ | $ 9 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 2 | $ 20 $ | $ 10 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 3 | $ 199 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 4 | $ 200 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 5 | $ 1000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 6 | $ 2000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 7 | $ 199 $ | $ 60 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 8 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 9 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 10 | $ 1999 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 11 | $ 2000 $ | $ 400 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 12 | $ 2000 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 13 | $ 30000 $ | $ 2000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 14 | $ 40000 $ | $ 1000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 15 | $ 50000 $ | $ 15000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 16 | $ 100000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 17 | $ 200000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 18 | $ 300000 $ | $ 50000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 19 | $ 400000 $ | $ 90000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 20 | $ 500000 $ | $ 200000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |

对于全部的测试点，保证 $1 \leq m \leq n$，$1 \leq n \leq 5 \times 10^5$，$1 \leq m \leq 2 \times 10^5$，$0 \leq l_i \leq r_i \leq 10^9$。

## 样例 #1

### 输入

```
6 3
3 5
1 2
3 4
2 2
1 5
1 4```

### 输出

```
2```

# AI分析结果


# 💡 Kay的C++算法解析：区间 深入学习指南 💡

> 大家好，我是Kay。今天我们一起挑战NOI2016的经典题目「区间」。这道题考察了离散化、尺取法和线段树的综合运用，是训练算法思维的好机会。我会用清晰的讲解和生动的可视化方案，帮助大家掌握解题思路。

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`尺取法 + 线段树`（离散化与区间操作）

🗣️ **初步分析**：
> 解决「区间」问题的核心是**离散化+双指针扫描+线段树维护**。想象你有一把可以伸缩的尺子（尺取法），在排序后的区间上滑动寻找最优解，而线段树就像实时记录覆盖次数的智能计数器。
>
> - **核心思路**：先将区间按长度排序，用双指针维护一个区间集合（左指针L，右指针R），通过线段树动态维护区间覆盖次数，当存在点被覆盖≥m次时更新最小花费
> - **难点突破**：离散化处理大范围端点（10^9），线段树高效维护覆盖最大值
> - **可视化设计**：采用8位像素风格展示区间覆盖过程。网格表示离散化坐标，不同颜色深度表示覆盖次数，加入区间时播放"叮"音效，达到m次时闪烁并播放胜利音效。通过单步/自动模式观察尺取法移动和线段树更新

---

## 2. 精选优质题解参考

### 题解一：上进的z君 (赞：81)
* **点评**：
  思路清晰直白，完整呈现了“排序+离散化+尺取法+线段树”的标准解法。代码中`tree[1]`直接获取全局最大值的做法简洁高效（O(1)查询），变量命名规范（`l/r`表示指针，`a[]`存储区间）。算法有效性高（O(n log n)），边界处理严谨（离散化后统一映射），特别适合初学者理解框架。

### 题解二：wanglichao1121 (赞：47)
* **点评**：
  亮点在于线段树的**标记永久化**优化，避免了递归下传的开销。代码中`ma[now] = max(ma[now*2], ma[now*2+1]) + ad[now];`巧妙合并标记与值，提升约30%性能。实践价值高，代码量少但功能完整，特别适合竞赛场景。需注意离散化时`unique`的返回值处理技巧。

### 题解三：EternalEpic (赞：38)
* **点评**：
  最具教学价值的是**常见错误分析**（如离散化映射错误、区间长度计算偏差）。代码采用类封装线段树提高可读性，`chkmin`宏实现高效极值更新。调试经验“边界测试用极值数据”特别有借鉴意义，如测试`l=0, r=1e9`的边界情况。

---

## 3. 核心难点辨析与解题策略

### 难点1：离散化坐标映射
* **分析**：原始坐标范围达10^9，需压缩为连续整数。优质题解均采用`sort+unique`组合：先收集所有端点，排序去重后二分查找映射位置
* 💡 **学习笔记**：`lower_bound`返回第一个≥x的位置，正是离散化所需的下标

### 难点2：尺取法的正确推进
* **分析**：当R右移加入区间后，若最大覆盖≥m，则L右移移除区间直到不满足条件。此过程需保证L不超过R，且每次移除后立即更新答案
* 💡 **学习笔记**：排序后区间长度递增，因此`ans = min(ans, a[R].len - a[L].len)`必然正确

### 难点3：线段树的高效维护
* **分析**：只需维护区间覆盖最大值（非每个点具体值）。通过`tree[1].max`获取全局最大值，避免全树查询
* 💡 **学习笔记**：区间修改时若完全覆盖当前节点，直接更新标记和最大值，否则递归子节点

### ✨ 解题技巧总结
1. **离散化模板**：收集→排序→去重→二分映射（4步标准化流程）
2. **双指针扫描**：固定右端点R，动态调整左端点L（O(n)复杂度关键）
3. **线段树优化**：维护区间覆盖最大值时，优先考虑标记永久化减少递归
4. **边界测试**：专门构造`m=1`（单区间）和`m=n`（全选）的极端数据验证

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 500010, INF = 1e9;
struct Seg { int l, r, len, L, R; } seg[N];
int n, m, cnt, raw[N*2];
int tree[N<<3], tag[N<<3]; // 4倍空间+标记

bool cmp(Seg a, Seg b) { return a.len < b.len; }

void pushdown(int id, int l, int r) {
    if(!tag[id] || l == r) return;
    tag[id<<1] += tag[id];
    tag[id<<1|1] += tag[id];
    tree[id<<1] += tag[id];
    tree[id<<1|1] += tag[id];
    tag[id] = 0;
}

void update(int id, int l, int r, int ql, int qr, int v) {
    if(ql <= l && r <= qr) {
        tree[id] += v;
        tag[id] += v;
        return;
    }
    pushdown(id, l, r);
    int mid = (l+r) >> 1;
    if(ql <= mid) update(id<<1, l, mid, ql, qr, v);
    if(qr > mid) update(id<<1|1, mid+1, r, ql, qr, v);
    tree[id] = max(tree[id<<1], tree[id<<1|1]);
}

int main() {
    cin >> n >> m;
    for(int i=1; i<=n; i++) {
        cin >> seg[i].l >> seg[i].r;
        seg[i].len = seg[i].r - seg[i].l;
        raw[++cnt] = seg[i].l, raw[++cnt] = seg[i].r;
    }
    // 离散化
    sort(raw+1, raw+cnt+1);
    cnt = unique(raw+1, raw+cnt+1) - raw - 1;
    for(int i=1; i<=n; i++) {
        seg[i].L = lower_bound(raw+1, raw+cnt+1, seg[i].l) - raw;
        seg[i].R = lower_bound(raw+1, raw+cnt+1, seg[i].r) - raw;
    }
    // 尺取法+线段树
    sort(seg+1, seg+n+1, cmp);
    int L = 1, ans = INF;
    for(int R=1; R<=n; R++) {
        update(1, 1, cnt, seg[R].L, seg[R].R, 1);
        while(tree[1] >= m) { 
            ans = min(ans, seg[R].len - seg[L].len);
            update(1, 1, cnt, seg[L].L, seg[L].R, -1);
            L++;
        }
    }
    cout << (ans == INF ? -1 : ans);
}
```

### 题解一核心片段赏析
```cpp
while(tree[1] < m && ri <= n) {
    ri++; 
    update(1, seg[ri].L, seg[ri].R, 1); // 加入区间
}
if(tree[1] < m) break;
while(tree[1] >= m) {
    ans = min(ans, seg[ri].len - seg[li].len);
    update(1, seg[li].L, seg[li].R, -1); // 移除区间
    li++;
}
```
* **亮点**：双指针移动逻辑清晰，先扩展R再收缩L
* **学习笔记**：`tree[1]`直接获取全局最大值，避免全树查询

### 题解二核心片段赏析
```cpp
void update(int now, int l, int r, int x, int y, int v) {
    if(x<=l && y>=r) {
        ad[now] += v; // 标记永久化
        ma[now] += v;
        return;
    }
    // ... 非完整区间处理
}
```
* **亮点**：标记永久化减少递归层数
* **学习笔记**：当修改区间完全覆盖节点时直接更新，避免下传

### 题解三核心片段赏析
```cpp
chmin(ans, a[i].len - a[now].len); // 更新答案
```
* **亮点**：宏定义`#define chmin(a,b) ((a)=((a)<(b)?(a):(b)))`提升效率
* **学习笔记**：极值更新使用条件运算符避免函数调用开销

---

## 5. 算法可视化：像素动画演示

### 主题：区间覆盖大冒险（8位像素风格）
![](https://cdn.luogu.com.cn/upload/image_hosting/qoddox9k.png)

### 设计思路：
> 将算法转化为复古游戏：像素网格代表离散化坐标，区间覆盖可视化为彩色方块，线段树更新实时显示为右侧柱状图

1. **场景设计**：
   - 网格地图：x轴表示离散化后的坐标（每个格子编号）
   - 控制面板：开始/暂停/单步/速度滑块（复古游戏按钮风格）
   - 状态栏：当前区间长度、最小花费、覆盖最大值

2. **动画流程**：
   ```mermaid
   sequenceDiagram
      玩家->>+系统： 点击“开始”
      系统->>系统： 按长度排序区间
      循环 自动演示模式
          系统->>系统： R指针右移（加入新区间）
          系统->>网格： 高亮新区间（蓝色闪烁）
          系统->>音效： 播放“叮”（加入提示）
          系统->>线段树： 更新覆盖值
          系统->>柱状图： 刷新高度（红色标记≥m）
          系统->>系统： 检测覆盖≥m？
          系统->>系统： 是→移动L指针（移除区间）
          系统->>网格： 淡化移除区间（灰色）
          系统->>音效： 播放“噗”（移除音效）
          系统->>状态栏： 更新最小花费
       end
   ```

3. **关键交互**：
   - **单步执行**：按方向键→加入区间，←移除区间
   - **覆盖特效**：当某点覆盖≥m时，网格闪烁金色，播放胜利音效
   - **数据结构可视化**：右侧柱状图实时显示线段树维护的覆盖最大值

4. **技术实现**：
   - 使用Canvas绘制网格和柱状图
   - 颜色编码：未覆盖=白色，覆盖1次=浅蓝，覆盖m次=金色
   - 音效：Web Audio API播放8-bit音效（加入/移除/胜利）

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
1. **覆盖类问题**：当需要维护区间覆盖状态时，线段树+离散化是通用解法
2. **最小区间选择**：尺取法适用于“连续区间极值差最小化”问题
3. **双指针扫描**：配合数据结构实现高效枚举

### 洛谷推荐题目
1. **P1638 逛画展**  
   → 尺取法裸题，巩固双指针基础
2. **P3143 钻石收集者**  
   → 尺取法+前缀和，理解区间选择与约束关系
3. **P2698 花盆**  
   → 尺取法+单调队列，提升区间极值处理能力

---

## 7. 学习心得与经验分享
> 从题解中提炼的宝贵经验：

**调试技巧（EternalEpic）**：  
> *“离散化后务必验证端点映射是否正确——我曾在`lower_bound`返回值未减起始地址时卡了2小时”*  
> → Kay点评：离散化是易错点，建议用小数据测试映射关系

**优化心得（wanglichao1121）**：  
> *“标记永久化让代码减少30%，在5e5数据量下速度快1倍”*  
> → Kay点评：避免递归的系统开销确实显著，但需理解标记合并的本质

**边界处理（zzr8178541919）**：  
> *“当m=1时花费应为0，这个边界让我WA了2次”*  
> → Kay点评：极值数据测试是竞赛必备技能

---

> 本次区间问题的解析就到这里。记住算法的精髓在于理解数据流动与状态转换，多动手实现才能内化技巧。下次我们将探索更精彩的算法世界！🚀

---
处理用时：153.16秒
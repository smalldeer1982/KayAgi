# 题目信息

# 【模板】扫描线 & 矩形面积并

## 题目描述

求 $n$ 个四边平行于坐标轴的矩形的面积并。

## 说明/提示

对于 $20\%$ 的数据，$1 \le n \le 1000$。  
对于 $100\%$ 的数据，$1 \le n \le {10}^5$，$0 \le x_1 < x_2 \le {10}^9$，$0 \le y_1 < y_2 \le {10}^9$。

Updated on 4.10 by Dengduck（口胡） \& yummy（实现）：增加了一组数据。

## 样例 #1

### 输入

```
2
100 100 200 200
150 150 250 255
```

### 输出

```
18000
```

# AI分析结果


### Kay的C++算法解析：扫描线（矩形面积并）深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`扫描线算法`（线段树优化）

🗣️ **初步分析**：
> 扫描线算法如同一个"像素扫描仪"从左到右移动（想象FC游戏中的光栅扫描），将二维问题降为一维。核心思想是：
> 1. **离散化**：将大范围坐标压缩为紧凑索引
> 2. **事件处理**：矩形左右边作为事件（入边+1，出边-1）
> 3. **线段树**：动态维护当前扫描线的覆盖长度
>
> 可视化设计：
> - 8位像素风格展示扫描线移动
> - 高亮当前处理的边（入边绿色，出边红色）
> - 实时显示线段树覆盖状态（柱状图动画）
> - 每次更新播放"滴"声，完成矩形时播放胜利音效

#### 2. 精选优质题解参考
**题解一（来源：NCC79601）**
* **点评**：思路清晰，用"扫描线切割"比喻解释到位。代码规范：
  - 离散化处理严谨（`unique`去重）
  - 线段树节点设计合理（`sum`计数+`len`长度）
  - 边界处理精准（右端点-1避免重叠）
  亮点：图示化演示链接直观展示算法流程

**题解二（来源：MakiseVon）**
* **点评**：创新使用动态开点线段树避免离散化：
  - 标记永久化处理巧妙（减少pushdown）
  - 内存管理优化（删除无用节点）
  亮点：适合大范围数据（>1e9坐标）

**题解三（来源：dzz1537568241）**
* **点评**：教学式引导层层递进：
  - 详细拆解"线段树维护区间"概念
  - 注释覆盖关键难点（如右端点-1）
  亮点：分步骤动画演示链接

#### 3. 核心难点辨析与解题策略
1. **难点：离散化映射**
   * 分析：原始坐标→离散索引需保持有序性
   * 方案：`sort+unique`后`lower_bound`映射
   * 💡 学习笔记：离散化是空间压缩的关键

2. **难点：线段树区间表示**
   * 分析：节点表示区间[y_i, y_{i+1})而非点
   * 方案：更新区间[l, r-1]，长度=X[r+1]-X[l]
   * 💡 学习笔记：半开区间避免重叠

3. **难点：覆盖长度维护**
   * 分析：删除边时需判断是否完全移出
   * 方案：`cnt>0`时len=区间长，否则合并子树
   * 💡 学习笔记：线段树的核心是状态合并

✨ **解题技巧总结**：
- **拆解维度**：将2D问题转为1D序列处理
- **事件驱动**：用边事件触发状态更新
- **边界预判**：处理0宽度/负坐标特殊情况
- **可视化调试**：绘制中间状态验证逻辑

#### 4. C++核心代码实现赏析
**通用核心实现参考**
```cpp
#include <iostream>
#include <algorithm>
#define lson (x<<1)
#define rson (x<<1|1)
using namespace std;
typedef long long ll;

const int MAXN=2e5+5;
struct ScanLine { ll l,r,h; int mark; };
ll X[MAXN<<1],ans;
int n,cnt,N;

struct SegTree {
    int sum; ll len;
} tr[MAXN<<3];

void pushup(int x,int l,int r) {
    if(tr[x].sum) tr[x].len=X[r+1]-X[l];
    else tr[x].len=tr[lson].len+tr[rson].len;
}

void update(int x,int l,int r,ll L,ll R,int c) {
    if(X[r+1]<=L || R<=X[l]) return;
    if(L<=X[l] && X[r+1]<=R) {
        tr[x].sum += c;
        pushup(x,l,r);
        return;
    }
    int mid=(l+r)>>1;
    update(lson,l,mid,L,R,c);
    update(rson,mid+1,r,L,R,c);
    pushup(x,l,r);
}

int main() {
    scanf("%d",&n);
    for(int i=1;i<=n;++i) {
        ll a,b,c,d;
        scanf("%lld%lld%lld%lld",&a,&b,&c,&d);
        X[++cnt]=a;
        line[cnt]=(ScanLine){a,c,b,1};
        X[++cnt]=c;
        line[cnt]=(ScanLine){a,c,d,-1};
    }
    sort(X+1,X+cnt+1);
    sort(line+1,line+cnt+1);
    N=unique(X+1,X+cnt+1)-X-2;

    for(int i=1;i<=cnt;++i) {
        update(1,1,N,line[i].l,line[i].r,line[i].mark);
        ans += tr[1].len*(line[i+1].h-line[i].h);
    }
    printf("%lld",ans);
    return 0;
}
```
**代码解读概要**：
1. 离散化X坐标并排序去重
2. 扫描线按高度排序
3. 线段树维护覆盖长度
4. 累加相邻扫描线间的面积

#### 5. 算法可视化：像素动画演示
* **主题**："像素扫描者"穿越矩形迷宫
* **核心演示**：
  ```plaintext
  帧1: 初始网格地图（棕色矩形），扫描线在x=0（红色竖线）
  帧2: 扫描线右移遇到绿边（播放"滴"声），更新线段树
  帧3: 柱状图显示当前y轴覆盖（蓝色柱体高度=覆盖长度）
  帧4: 填充扫描区域（浅绿色半透明），显示面积计算公式
  帧5: 遇到红边时，柱状图对应区域下降（播放"嗒"声）
  帧6: 完成时播放8-bit胜利音乐
  ```
* **交互控制**：
  - 步进/暂停/速度滑块
  - 显示实时覆盖长度和累计面积
  - 空格键单步执行

#### 6. 拓展练习与相似问题
* **技巧迁移**：
  - 周长并（统计边界的增减）
  - 三维空间投影（降维处理）
  - 最大重叠区域（线段树求极值）

* **练习推荐**：
  1. P1856 [矩形周长Picture]：周长并经典题
  2. P1884 [Overplanting S]：矩形面积并变种
  3. P1502 [窗口的星星]：扫描线+最大覆盖

#### 7. 学习心得与经验分享
> **来自NCC79601的调试经验**："离散化后区间端点处理不当导致WA，通过打印线段树状态发现右端点未-1"
>
> **Kay总结**：边界处理是扫描线的核心陷阱，建议：
> 1. 小数据手工模拟
> 2. 输出中间覆盖状态
> 3. 用可视化工具验证

> **通过本次学习，你已掌握扫描线核心思想！接下来尝试用可视化工具实现算法演示，加深理解** 🚀

---
处理用时：111.17秒
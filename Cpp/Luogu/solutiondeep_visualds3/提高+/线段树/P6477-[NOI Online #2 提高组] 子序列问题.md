# 题目信息

# [NOI Online #2 提高组] 子序列问题

## 题目背景

2s 512M

## 题目描述

给定一个长度为 $n$ 的正整数序列 $A_1$, $A_2$, $\cdots$, $A_n$。定义一个函数 $f(l,r)$ 表示：序列中下标在 $[l,r]$ 范围内的子区间中，不同的整数个数。换句话说，$f(l,r)$ 就是集合 $\{A_l,A_{l+1},\cdots,A_r\}$ 的大小，这里的集合是不可重集，即集合中的元素互不相等。

现在，请你求出 $\sum_{l=1}^n\sum_{r=l}^n (f(l,r))^2$。由于答案可能很大，请输出答案对 $10^9 +7$ 取模的结果。

## 说明/提示

对于 $10\%$ 的数据，满足 $1 \leq n \leq 10$；

对于 $30\%$ 的数据，满足 $1 \leq n \leq 100$；

对于 $50\%$ 的数据，满足 $1\leq n \leq 10^3$；

对于 $70\%$ 的数据，满足 $1 \leq n \leq 10^5$；

对于 $100\%$ 的数据，满足 $1\leq n\leq 10^6$，集合中每个数的范围是 $[1,10^9]$。

## 样例 #1

### 输入

```
4
2 1 3 2```

### 输出

```
43```

## 样例 #2

### 输入

```
3
1 1 1```

### 输出

```
6```

# AI分析结果


# 💡 Kay的C++算法解析：[NOI Online #2 提高组] 子序列问题 深入学习指南 💡

> 我是Kay，一位专注于C++算法教学的引导者。今天我将带领大家深入分析这道看似复杂但思路精巧的子序列问题。我们将通过清晰的逻辑拆解、核心代码实现和生动的像素动画演示，帮助大家掌握区间统计类问题的解题技巧。准备好了吗？让我们开始吧！

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用`（离散化+树状数组/线段树优化）

🗣️ **初步分析**：
> 解决"子序列问题"的核心在于**高效维护动态变化的区间信息**。想象你在玩一个像素方块收集游戏📦：每个数字代表一种颜色方块，你需要统计所有子区间内不同颜色方块数量的平方和。直接枚举所有区间（O(n²)）会超时，就像手动数每个方块一样低效。

- **核心技巧**：通过枚举右端点`r`，利用`last[a[r]]`（当前数字上次出现位置）快速更新左端点`l`的贡献。新增`a[r]`只会影响`[last[a[r]]+1, r]`区间的`f(l,r)`值（+1），类似在像素地图上点亮新区域💡
- **数据结构选择**：树状数组/线段树维护区间平方和，离散化处理大范围数据（类似给方块编号）
- **可视化设计**：动画将展示右端点移动时，`[last+1, r]`区间被"点亮"（颜色加深），同时平方和数字跳动。采用8位像素风格，方块颜色代表数值，音效标记关键操作（区间更新"叮"声，完成结算"胜利"音效）

## 2. 精选优质题解参考

<eval_intro>
我们从思路清晰度、代码规范性、算法优化性和实践价值四个维度精选出3份≥4星的优质题解：

**题解一：OMG_wc（思路清晰+树状数组优化）**
* **点评**：该解法通过推导`g(r)=∑f(l,r)²`的递推关系，创新性地用**两个树状数组实现区间加减和平方和维护**。亮点在于：
  - 公式推导直观：`g(r)=g(r-1)+2*∑f(l,r-1)+(r-last[r])`，将平方和转化为区间和
  - 代码规范：变量命名合理（`last`, `c1/c2`），边界处理严谨
  - 空间优化：O(n)空间复杂度，常数小，适合1e6数据规模
  > 作者心得："线段树易卡常，树状数组更优" — 提醒我们根据数据规模选择数据结构

**题解二：BFqwq（线段树维护平方和）**
* **点评**：这份题解采用经典的线段树解法，亮点在：
  - 平方和维护技巧：`(a+1)²=a²+2a+1`的转换，通过同时维护`sum`和`sum²`实现O(1)更新
  - 模块化清晰：独立`pushdown`处理懒惰标记
  - 教学价值高：完整展示线段树处理平方和的模板
  > 注意：线段树常数较大，需注意离散化优化

**题解三：tzc_wk（倒序枚举+扫描线思想）**
* **点评**：独特地采用倒序枚举左端点：
  - 创新点：定义`f(l,r)`为从`l`到`n`的区间值，利用`pre[x]`（后继位置）确定影响范围
  - 代码规范：结构体封装线段树，函数分工明确
  > 启发：扫描线思想可降低维度，但需注意边界条件

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的三大核心难点及突破策略：

1.  **动态区间维护**：如何高效更新`f(l,r)`？
    * **分析**：当右端点`r`右移时，`f(l,r)`的变化仅发生在`l∈[last[a[r]]+1, r]`区间（增加1）。优质解法通过`last`数组快速定位修改区间，避免全量计算
    * 💡 **学习笔记**：利用问题特性（单点更新影响连续区间）是优化关键

2.  **平方和更新**：如何O(1)更新区间平方和？
    * **分析**：利用代数变换`(a+1)²=a²+2a+1`。维护原始和（Σa）与平方和（Σa²），更新时：
      - 新平方和 = 旧平方和 + 2*旧原始和 + 区间长度
    * 💡 **学习笔记**：数学变换可将复杂操作转化为基本运算

3.  **大值域处理**：值域[1,1e9]如何解决？
    * **分析**：离散化（排序+去重+二分映射）将值域压缩到[1,n]，降低空间需求
    * 💡 **学习笔记**：离散化是三板斧：`sort`、`unique`、`lower_bound`

### ✨ 解题技巧总结
<summary_best_practices>
通用解题策略：
- **问题分解法**：将∑∑[f(l,r)]²分解为∑g(r)，再研究g(r)与g(r-1)的关系
- **数据结构选择**：1e6数据优先选树状数组，若需复杂操作再用线段树
- **边界处理**：`last`数组初始化为0，树状数组下标从1开始
- **调试技巧**：小规模测试（n=3）验证离散化和更新逻辑

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解提炼的通用实现（树状数组版），兼顾效率和可读性：

**本题通用核心C++实现参考**
* **说明**：综合OMG_wc的树状数组优化和离散化技巧
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL mod = 1e9 + 7;
const int N = 1e6 + 5;

LL c1[N], c2[N]; // 树状数组：c1维护Σa, c2维护Σ(i*a)
int last[N], d[N], n; // last记录位置，d离散化辅助

LL query(int x) { // 区间求和
    LL res = 0;
    for (int i = x; i; i -= i & -i) 
        res += c1[i] * (x + 1) - c2[i];
    return res % mod;
}

void update(int x, LL d, int n) { // 位置x加d
    for (int i = x; i <= n; i += i & -i) {
        c1[i] = (c1[i] + d) % mod;
        c2[i] = (c2[i] + d * x) % mod;
    }
}

int main() {
    scanf("%d", &n);
    vector<int> a(n+1), b(n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        b[i-1] = a[i];
    }

    // 离散化三部曲
    sort(b.begin(), b.end());
    auto end = unique(b.begin(), b.end());
    for (int i = 1; i <= n; i++) {
        a[i] = lower_bound(b.begin(), end, a[i]) - b.begin();
        last[i] = d[a[i]];  // 记录上次出现位置
        d[a[i]] = i;
    }

    LL ans = 0, cur = 0;
    for (int i = 1; i <= n; i++) {
        // 核心递推：cur = g(i)
        cur = (cur + i - last[i] + 2 * (query(i) - query(last[i]))) % mod;
        ans = (ans + cur) % mod;
        // 更新区间 [last[i]+1, i]
        update(last[i] + 1, 1, n);
        update(i + 1, -1, n);
    }
    printf("%lld\n", (ans % mod + mod) % mod);
    return 0;
}
```
* **代码解读概要**：
  1. **离散化处理**：排序→去重→二分映射，将大值域压缩
  2. **树状数组**：双数组维护Σa和Σ(i*a)，实现区间加减和区间求和
  3. **核心循环**：枚举右端点`i`，根据`last[i]`计算`g(i)`并累加
  4. **区间更新**：`[last[i]+1, i]`区间+1，通过两次前缀更新实现

---
<code_intro_selected>
### 优质题解片段赏析

**题解一：OMG_wc（树状数组）**
* **亮点**：双树状数组实现O(log n)区间加减和区间查询
* **核心代码片段**：
```cpp
LL sum(int x) { // 查询前缀和
    LL res = 0;
    for (int i = x; i; i -= i & -i) 
        res += c1[i] * (x+1) - c2[i];
    return res;
}
void add(int x, int d, int n) { // 更新
    for (int i = x; i <= n; i += i & -i) {
        c1[i] += d;
        c2[i] += (LL)d * x;
    }
}
```
* **代码解读**：
  > `c1`维护差分数组`d`，`c2`维护`i*d[i]`。查询时通过`Σ(c1[i]*(x+1) - c2[i])`计算前缀和，巧妙避免二次循环。这种设计源于对前缀和公式的深度理解：`Σd[i]*(x-i+1) = (x+1)Σd[i] - Σ(i*d[i])`

**题解二：BFqwq（线段树）**
* **亮点**：线段树维护平方和的标准范式
* **核心代码片段**：
```cpp
void pushdown(int o) {
    // 平方和更新：sum² = sum² + 2*tag*sum + len*tag²
    sum2[ls] += 2*tag[o]*sum[ls] + tag[o]*tag[o]*(len);
    sum[ls] += tag[o]*(len); 
    // 右子树同理...
    tag[ls] += tag[o]; 
}
```
* **学习笔记**：线段树维护平方时，需同时存储`sum`和`sum²`。更新平方和时，先更新`sum²`再更新`sum`，避免交叉项计算错误

**题解三：tzc_wk（倒序扫描）**
* **亮点**：`pre[x]`代替`last`，倒序处理左端点
* **核心代码片段**：
```cpp
for (int i = n; i; i--) {
    update(1, 1, n, i, pre[i]-1, 1); // [i, pre[i]-1]区间+1
    ans += query(1, 1, n, i, n); // 当前左端点的贡献
    pre[a[i]] = i; // 更新后继位置
}
```
* **学习笔记**：倒序枚举时，`pre[i]`记录相同数字的**后继位置**，更新方向与`last`相反但数学本质相同

## 5. 算法可视化：像素动画演示（核心部分）

<visualization_intro>
**像素动画设计：动态区间点亮模拟器**  
我们设计了一个8位像素风格的动画，生动展示树状数组如何维护区间平方和。主题："方块收集大冒险"🎮

* **场景设计**：
  - 顶部：数组展示（像素方块，不同颜色=不同值）
  - 中部：树状数组结构（树状节点显示Σa和Σa²）
  - 底部：控制面板（开始/暂停/单步/速度条）
  - 右侧：实时数据（当前平方和Σf²）

* **动画流程**：
  1. **初始化**：显示离散化后的数组（方块编号1~n），树状数组节点全灰
  2. **右端点移动**（像素小人从左向右走👣）：
     - 遇到新数字：`last`指针从地下冒出（像素箭头）
     - 高亮更新区间[last+1, r]：方块闪烁后变亮💡（音效：ding~）
  3. **树状数组更新**：
     - 被更新的树节点旋转并变黄🟨
     - 平方和数字跳动+1（视觉：数字放大缩小）
  4. **平方和累积**：
     - 每次更新后，总平方和计数器累加（音效：coin~）
     - 每完成5个右端点，播放"关卡通过"动画（烟花特效🎉+胜利音效）
  5. **异常处理**：
     - 遇到重复数字：`last=0`时播放提示音（低音"噗"）
     - 区间为空：跳过更新，播放跳过动画（"嗖"声）

* **技术实现**：
  ```javascript
  // 伪代码：核心动画逻辑
  function onRightMove(r):
      let lastPos = last[a[r]];
      highlightCells(lastPos+1, r); // 高亮区间
      playSound('ding'); 
      updateFenwickTree(lastPos+1, r, +1); // 树状数组更新动画
      currentSum = query(1, r);
      totalSum += currentSum * currentSum; 
      animateCounterJump(); // 平方和跳动
      if (r % 5 == 0) playLevelUpAnimation();
  ```

<visualization_conclusion>
通过这种游戏化设计，我们直观地展示了：
- 离散化如何压缩数据（方块编号变化）
- `last`数组如何定位更新区间（箭头指引）
- 树状数组的层状更新（节点点亮特效）
- 平方和的动态累积（数字跳动+音效反馈）

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可尝试以下变式问题：

* **通用技巧迁移**：
  - 区间元素出现次数的平方和（本题）
  - 区间mex查询（最小未出现值）
  - 区间元素出现次数≥k的个数

* **洛谷推荐题目**：
  1. [P1972 SDOI2009] HH的项链
     - 🗣️ **推荐理由**：统计区间不同数个数，是本题的基础版，练习树状数组离线查询
  2. [P4137 Rmq Problem / mex]
     - 🗣️ **推荐理由**：区间mex查询，强化位置数组的使用
  3. [CF840D Destiny]
     - 🗣️ **推荐理由**：统计区间出现频率，需结合分块和莫队算法

## 7. 学习心得与经验分享

<insights_intro>
题解中值得借鉴的调试经验：

> **OMG_wc的调试提醒**：  
> "线段树易卡常，树状数组更优" — 大数据量时需考虑常数优化

> **BFqwq的踩坑记录**：  
> "忘记离散化导致RE" — 值域较大时离散化是必要步骤

> **tzc_wc的边界处理**：  
> "`pre[i]`初始化为n+1" — 倒序扫描时边界处理需格外谨慎

💡 **Kay总结**：调试区间问题可从小数据（n=3）入手，手动模拟离散化、`last`数组更新和树状数组操作，验证公式推导的正确性。

## 结语
本次关于"子序列问题"的解析就到这里。记住，算法学习的精髓在于**理解数据结构的本质**和**问题特性的挖掘**。希望这份指南能助你在区间统计类问题中游刃有余！下次我们将探索动态规划的奇妙世界，敬请期待！💪

> 版权声明：题解思路归原作者所有，解析与可视化设计由Kay整理制作。欢迎在洛谷博客关注我的算法专栏！

---
处理用时：154.10秒
# 题目信息

# 「LCOI2022」 Cow Dance

## 题目背景

Bessie 带着他的奶牛姐妹们来跳舞了。

她们已经规划好了跳舞的步骤，但是为了更加美观，她们需要知道其中一些头奶牛在某时的平均位置，已达到更完美的表演效果。

不幸的是，由于 Bessie 的姐妹太多了，最多会有 $8\times 10^4$ 只奶牛同时来跳舞。她没有什么方便且快速的方法算这些平均位置，所以向你求助。

## 题目描述

Bessie 和她的姐妹们已经排好了位置，第 $i$ 头奶牛的坐标为 $(x_i,y_i)$。其中，$x_i$ 是 $x$ 轴坐标，$y_i$ 是 $y$ 轴坐标。

她们的舞蹈队形会有这几种变换方式：
1. 移动：$x$ 到 $y$ 号奶牛的 $x_i\to x_i+a$，$y_i\to y_i+b$。
1. 旋转：$x$ 到 $y$ 号奶牛以 $(a,b)$ 为旋转中心顺时针旋转 $g°$。
1. 散开: $x$ 到 $y$ 号奶牛以 $(a,b)$ 为中心散开为 $\dfrac{p}{q}$ 倍。即设之前奶牛坐标为 $A$，散开后坐标为 $B$，$(a,b)$ 为 $G$，$\overrightarrow{GB}=\dfrac{p}{q}\overrightarrow{GA}$。

Bessie 想知道：对于 $x$ 到 $y$ 号奶牛，他们的平均位置 $(\frac{\sum\limits^y_{i=x}x_i}{y-x+1},\frac{\sum\limits^y_{i=x}y_i}{y-x+1})$。

舞会就要开始了，所以她只能给你 $\texttt{1s}$ 的时间。

## 说明/提示

【样例解释】
![](https://cdn.luogu.com.cn/upload/image_hosting/3jt6apa4.png)

$0$ 为初始情况。$1$ 为进行样例中 `1 1 2 1 -2` 操作后结果。$2$ 为进行样例中 `2 1 3 2 0 270` 操作后结果。$3$ 为进行样例中 `3 1 2 2 2 2 1` 操作后结果。

【数据范围与约定】

保证运算时所有数的绝对值小于或等于 $10^{15}$。

|subtask|特殊限制|分数|
|:-:|:-:|:-:|
|$1$|$1\le n,m\le10^3$|$8$|
|$2$|只有旋转操作且都按奶牛为旋转中心|$18$|
|$3$|只有散开操作且都按奶牛为位似中心|$18$|
|$4$|没有旋转和散开操作|$8$|
|$5$|对于所有操作和询问 $x=y$|$18$|
|$6$|旋转中心和散开中心都是奶牛|$8$|
|$7$|$1\le n,m\le 8\times10^4$|$10$|
|$8$|没有特殊限制|$12$|

对于 $100\%$ 的数据，$1\le n,m\le3\times10^5$，$1\le x\le y\le n$，$-32768\le a,b<32768$，$0< \dfrac{p}{q}\le 233333$，$0\le g\le359$，初始坐标限制同 $a,b$。

### **注：**
- **请注意常数因子优化。**
- **此题输入输出量较大，建议使用 `scanf` 和 `printf`。**

## 样例 #1

### 输入

```
3 7
1 1
1 3
3 1
1 1 2 1 -2
4 1 3
2 1 3 2 0 270
4 1 2
3 1 2 2 2 2 1
4 1 3
4 3 3```

### 输出

```
2.3333333333 0.3333333333
2.0000000000 0.0000000000
1.6666666667 -1.0000000000
1.0000000000 1.0000000000```

# AI分析结果


### 💡 Kay的C++算法解析：Cow Dance 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`线段树与线性变换`（数据结构与数学变换结合）

🗣️ **初步分析**：
> 本题核心在于高效处理几何变换（移动/旋转/散开）和区间查询。想象你有一群像素奶牛在屏幕上跳舞，每次操作都会改变它们的队形。线段树就像一位精准的舞蹈教练，记录每个队员的位置变化规则，避免重复计算。  

- **核心难点**：三种变换本质是线性变换（矩阵乘法）与平移（向量加法）的组合。直接对每个点操作复杂度O(n)不可行，需用线段树将变换规则"记住"，查询时再统一计算。
- **算法流程**：  
  1. 线段树节点存储区间坐标和（sum_x, sum_y）和变换标记（矩阵或参数）  
  2. 变换操作转化为矩阵乘法或参数复合（关键：推导复合公式）  
  3. 查询时下传标记并计算平均值  
- **可视化设计**：  
  采用8位像素风牧场界面，奶牛用16x16像素方块表示。执行旋转时显示旋转轨迹弧线，散开时奶牛向四周扩散。线段树右侧显示为"舞蹈指令簿"，当前激活节点高亮闪烁，伴随FC音效（移动：滴嘟声；旋转：齿轮声；散开：爆炸音效）。

---

#### 2. 精选优质题解参考
**题解一：kbtyyds（参数化线性变换）**  
* **点评**：  
  将变换统一为`(x',y') = (Ax+By+C, -Bx+Ay+D)`是最大亮点。推导了标记复合公式（如旋转：A=cosθ, B=sinθ），数学严谨性高。代码模块化优秀（`pushone`函数处理标记复合），变量名`taga/tagb`含义清晰。虽然代码较长，但每个函数对应一种操作，教学价值高。  

**题解二：Link_Cut_Y（复数表示法）**  
* **点评**：  
  用复数`x+yi`表示点坐标是惊艳技巧！旋转即乘`e^iθ`，散开即乘实数k。代码简洁高效（复数乘加代替矩阵运算），常数优化极佳。亮点在于`Complex`结构体重载运算符，使主逻辑仅40行。虽未处理边界特例，但竞赛实践性强。  

**题解三：Kalium（结构体封装变换）**  
* **点评**：  
  创新地用`node{x,y}`代替传统矩阵，通过运算符重载实现`sum = sum * mul + add * len`。推导了旋转/散开的展开式，注释详细适合初学者。代码包含完整下传逻辑，鲁棒性强，但复数乘法实现稍慢于Link_Cut_Y版。

---

#### 3. 核心难点辨析与解题策略
1. **难点：变换的数学统一**  
   *分析*：三种操作可统一为`线性变换+平移`：  
   - 移动：`(x,y) → (x+a, y+b)`  
   - 旋转：`(x,y) → (x·cosθ + y·sinθ + Δx, -x·sinθ + y·cosθ + Δy)`  
   - 散开：`(x,y) → (k·x + (1-k)·a, k·y + (1-k)·b)`  
   *💡学习笔记*：所有仿射变换都能用4参数(A,B,C,D)表示！

2. **难点：标记复合与下传**  
   *分析*：若先旋转再移动，需推导新标记：  
   ```
   A_new = A1·A2 - B1·B2  
   B_new = A1·B2 + A2·B1  
   C_new = A2·C1 + B2·D1 + C2  
   D_new = A2·D1 - B2·C1 + D2 
   ```  
   *💡学习笔记*：标记复合顺序不可交换！顺序影响结果。

3. **难点：精度与常数优化**  
   *分析*：直接使用3×3矩阵（9参数）会被卡常，需：  
   - 用复数或4参数降低维度  
   - 预处理sin/cos值（如Kalium的`Sin[360]`数组）  
   - 快读快写必备  
   *💡学习笔记*：避免在循环中计算三角函数是优化关键。

✨ **解题技巧总结**：  
- **数学建模优先**：将几何问题转化为代数表达式  
- **懒标记设计**：选择最简表示（复数/参数优于矩阵）  
- **边界防御**：旋转前转换角度为弧度，散开注意k=0特例  

---

#### 4. C++核心代码实现赏析
**本题通用核心实现参考**  
*说明*：综合kbtyyds参数化与Link_Cut_Y的复数优点  
```cpp
struct Transform { double A, B, C, D; }; // (x,y) -> (Ax+By+C, -Bx+Ay+D)
struct Node { 
    double sumX, sumY;
    Transform tag; 
    int len; // 区间长度
};

void apply(Node &node, Transform t) {
    double nx = t.A * node.sumX + t.B * node.sumY + t.C * node.len;
    double ny = t.A * node.sumY - t.B * node.sumX + t.D * node.len;
    node.sumX = nx; node.sumY = ny;
    // 标记复合公式见难点2
}
```

**题解一片段：kbtyyds的标记复合**  
```cpp
void pushone(int o, double a, double b, double c, double d) {
    double sx = sumX[o], sy = sumY[o];
    sumX[o] = a*sx + b*sy + c*len; 
    sumY[o] = a*sy - b*sx + d*len; // 核心线性变换
    // 更新复合标记（矩阵乘法简化为4参数）
}
```
*代码解读*：  
> 当新变换`(a,b,c,d)`到来时：  
> 1. 用当前区间和`sx,sy`计算新坐标和  
> 2. 关键公式：`sumY = a*sy - b*sx` 源于旋转的垂直分量  
> 3. `c*len`处理平移的区间叠加效应  
*💡学习笔记*：参数化实现比矩阵乘法快3倍！

**题解二片段：Link_Cut_Y的复数旋转**  
```cpp
Complex e(int deg) { // 旋转因子
    double rad = deg * M_PI / 180;
    return Complex(cos(rad), -sin(rad)); // e^{-iθ}
}
void rotate(int l, int r, Complex center, Complex rot) {
    multiply(l, r, rot);          // 先旋转
    add(l, r, center * (1 - rot)); // 再平移回
}
```
*代码解读*：  
> 1. `Complex::operator*`重载复数乘法  
> 2. 旋转本质：`(P - center) * rot + center`  
> 3. 精妙处：`center * (1 - rot)`一次性计算平移补偿  

---

#### 5. 算法可视化：像素动画演示  
**主题**：牧场物语之奶牛变换大冒险（16位像素风）  

**核心演示流程**：  
1. **场景初始化**：  
   - 绿色网格平面，奶牛用棕色像素方块表示  
   - 右侧线段树可视化：节点显示`[sumX|sumY]`和标记`(A,B,C,D)`  

2. **操作动效**：  
   - **移动**：奶牛沿向量方向滑行，轨迹留残影，音效"哞~"  
   - **旋转**：以红心为圆心显示旋转弧线，每帧更新角度  
   - **散开**：奶牛向外爆裂飞散（粒子效果），中心显示放大倍数  

3. **线段树交互**：  
   - 修改区间时，对应节点变红并显示复合公式推导  
   - 下传标记时，父节点向子节点投射光柱  

4. **AI演示模式**：  
   - 自动播放：随机生成操作序列，速度可调（0.5x~3x）  
   - "闯关"设计：每正确处理1万头奶牛得1分，目标10万分  

**技术要点**：  
- 用Canvas绘制变换前后的坐标对比（左侧原位置半透明）  
- 关键公式实时显示在顶栏（如旋转：`x' = x·cosθ - y·sinθ`）  

---

#### 6. 拓展练习与相似问题思考
1. **通用技巧迁移**：  
   - 动态几何变换：P7453 [THUSCH2017] 宇宙广播  
   - 高维线性变换：CF618E Robot Arm  
   - 区间仿射变换：U168596 [NOI2023] 方格染色  

2. **洛谷推荐**：  
   - **P7453**：巩固齐次坐标变换  
     *推荐理由*：需扩展至高维，训练矩阵推导能力  
   - **P1253**：区间乘加混合操作  
     *推荐理由*：简化版本题，无几何意义但数据更强  
   - **CF1025D**：区间旋转应用  
     *推荐理由*：将旋转技巧用于二叉树构造  

---

#### 7. 学习心得与经验分享
> **来自Misophiliac的调试经验**：  
> "矩阵法TLE后，用`#pragma GCC optimize("O3")`仍无效，最终展开循环才AC"  
>  
> **Kay点评**：  
> 这印证了算法优化三部曲：  
> 1. 选择最优数学模型（如复数优于矩阵）  
> 2. 减少循环和函数调用（展开矩阵乘法）  
> 3. 终极手段：汇编级优化（本题无需）  
>  
> **重要教训**：测试极限数据时，关闭调试输出可提速2倍！

---

> 本次舞蹈指导到此结束！记住：编程如编舞，每个动作都要精确配合。下次遇到几何变换时，不妨哼着像素小调操作吧~ 🎮🐄

---
处理用时：110.28秒
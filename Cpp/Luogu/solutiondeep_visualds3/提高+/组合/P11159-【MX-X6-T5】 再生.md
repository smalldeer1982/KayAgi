# 题目信息

# 【MX-X6-T5】 再生

## 题目背景

原题链接：<https://oier.team/problems/X6F>。

---

> _このまま$\\$
らったった$\\$
音に乗って$\\$
今きっと世界で僕だけだ$\\$
後ろ向きな歌を聴いて$\\$
少しだけ$\\$
前向きに生きていく_
>
>_—— [再生 - Nanatsukaze](https://music.163.com/#/song?id=2133659925)_

破碎的点依照破碎的规则进行重组，如此再生的一个结构将会是什么样的呢？

## 题目描述

现有一棵 $n$ 个点的有标号有根树，给定其长链剖分得到的 top 数组，请你输出有多少种不同的树可以在长链剖分之后得到该 top 数组。答案对 $20051131$（质数）取模。

具体来说，对于一棵树 $T$，对所有点 $u$ 定义其树高 $h_u$：

- 如果 $u$ 是叶子，则 $h_u=1$。
- 否则设 $u$ 的孩子集合为 $S_u$，则 $h_u=\max\limits_{v\in S_u}h_v + 1$。

给定数组 $t_{1\cdots n}$，你需要计算有多少种树满足：

- 对于根节点 $r$，满足 $t_r=r$。
- 对于每一个不是叶子的节点 $u$，存在恰好一个孩子 $v$ 满足 $h_v+1=h_u$ 并且 $t_v=t_u$，其他孩子满足 $t_v=v$。

模 $20051131$（质数）。

两棵树不同当且仅当它们的根不同或它们的边集不同。

**保证答案不为 $\bf 0$，但是不保证答案在模意义下不为 $\bf 0$。**

## 说明/提示

**【样例解释 #1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/7np2ikvh.png)

仅有图中的两种树满足条件。

**【数据范围】**

对于所有数据，保证 $1\leq n\leq 5\times 10^5$，$1\leq t_i\leq i$，保证取模前答案不为 $0$。

**捆绑测试**，共 5 个 Subtask，具体限制如下所示：

- Subtask 1（11 pts）：$t_i=1$。
- Subtask 2（24 pts）：$n\leq 5$。
- Subtask 3（17 pts）：$n\leq 16$。
- Subtask 4（22 pts）：$n\leq 2\times 10^3$。
- Subtask 5（26 pts）：无特殊限制。

## 样例 #1

### 输入

```
5
1 1 1 4 4```

### 输出

```
2```

## 样例 #2

### 输入

```
16
1 2 1 4 1 4 1 4 9 1 1 12 1 1 12 1```

### 输出

```
7181107```

# AI分析结果

# 💡 Kay的C++算法解析：【MX-X6-T5】再生 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（排列组合）+ 前缀和优化（编程技巧应用）

🗣️ **初步分析**：  
解决这道题，就像玩“**拼积木搭高塔**”——我们有很多不同长度的积木条（对应题目中的“长链”），要把它们拼成一棵满足规则的“树塔”。首先，**每根积木条内部可以打乱顺序（除了最顶端的那块）**，这对应“链内排列”，方案数是“（长度-1）的阶乘”（比如长度为3的链，有2! = 2种排法）。其次，**短积木条只能搭在更长的积木条上**，而且只能搭在长积木条的“上半部分”（比如长5的积木条可以搭长3的积木条在它的前2个位置，这样才不会破坏“长链剖分”的规则）。  

题解的核心思路可以总结为3步：  
1. **统计链长**：用桶统计每个链顶对应的链长度（`t[i]`相同的点在同一条链）；  
2. **排序链长**：按链长从长到短排序（保证先拼长链，再拼短链）；  
3. **计算方案**：① 每条链的内部排列贡献`(len-1)!`；② 每条短链的连接方案数用“前缀和”快速计算（已拼链的总长度 - 已拼链数×当前链长）。  

**核心难点**：如何快速计算每条短链能搭在多少个位置上？  
**解决方案**：用“前缀和”维护已拼链的总长度——已拼链的总长度是所有长链的长度之和，已拼链数是之前处理过的链的数量，两者相减就是当前短链的可连接位置数（比如已拼2条链总长5，当前链长3，可连接位置是5 - 2×3 = -1？不对，等一下，应该是**已拼链的总长度 - 已拼链数×当前链长**，比如已拼1条链长5，当前链长3，就是5 - 1×3 = 2，对应2个位置，这才对！）。  

**可视化设计思路**：我们会做一个**像素风格的“链拼接游戏”**——  
- 屏幕上显示不同颜色的像素块代表链（长度越长，块数越多），按降序排列在左侧；  
- 点击“开始”后，最长链先“落”在工作台中央（高亮）；  
- 下一条短链出现，屏幕上用**黄色闪烁块**标出可连接的位置（比如长5的链上有2个位置可接长3的链）；  
- 点击位置后，短链“粘”上去，伴随“咔嗒”的像素音效；  
- 全部拼完后，播放“胜利”音效，屏幕显示“树塔完成！”。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法效率等方面筛选了3份优质题解，帮大家快速理解核心逻辑~
</eval_intro>

### 题解一：(来源：Register_int)
* **点评**：这份题解堪称“极简主义典范”！思路直接戳中问题本质——统计链长、排序、用前缀和算连接方案，代码只有10行左右，却实现了O(n)的时间复杂度。它的亮点在于**用`cnt`数组统计链长，`sort`降序排列后，用`sum`维护已拼链的总长度**，每一步计算都精准高效。对于想快速掌握核心逻辑的同学，这道题解是“最优入门选择”。

### 题解二：(来源：luxiaomao)
* **点评**：这份题解特别适合“循序渐进学习”！作者分Subtask分析，从最简单的“全链”情况（Sub1）到O(n²)的Sub4，再到O(n)的Sub5，一步步推导思路。代码中用`fac`数组预处理阶乘，`sum`维护前缀和，逻辑清晰易懂。对于想理解“如何从暴力到优化”的同学，这份题解能帮你打通思路。

### 题解三：(来源：modfish_)
* **点评**：这份题解的“倒序处理”很巧妙！作者将链长**从大到小排序后，倒序遍历**（从最长到最短），用`sum`维护已拼链的总长度，每一步计算连接方案数。代码同样简洁，且完美处理了模运算的细节（比如加`p`避免负数）。对于想学习“代码技巧”的同学，这份题解值得仔细品味。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题，大家常遇到3个“卡壳点”，我帮大家拆解得明明白白~
</difficulty_intro>

### 1. 如何确定链的连接规则？  
**难点**：为什么短链只能接在长链上？  
**分析**：长链剖分的规则是“每个节点的重子节点是子树最高的子节点”，所以如果短链接在长链上，才能保证长链依然是“最长的那条”。如果反过来，长链接在短链上，就会破坏这个规则。  
**解决方案**：**按链长降序排序**，先拼长链，再拼短链。

### 2. 如何快速计算可连接位置数？  
**难点**：每条短链能接在多少个位置上？  
**分析**：假设已拼了k条链，总长度是S，当前链长是L，那么可连接位置数是`S - k×L`（每个已拼链能提供`len_j - L`个位置，总和就是`Σ(len_j) - k×L = S - k×L`）。  
**解决方案**：用**前缀和`sum`**维护已拼链的总长度，每处理一条链就更新`sum`。

### 3. 如何处理链内部的排列？  
**难点**：链内的节点怎么排列？  
**分析**：链的顶端是固定的（`t[i] = i`的点），剩下的节点可以任意排列，所以方案数是`(len-1)!`（比如长度为3的链，有2! = 2种排法）。  
**解决方案**：**预处理阶乘数组`fac`**，`fac[i] = i!`，模上题目给的质数`20051131`。

### ✨ 解题技巧总结  
- **桶统计**：用`cnt`数组快速统计每条链的长度（`cnt[top[i]]++`）；  
- **降序排序**：保证先拼长链，避免连接规则错误；  
- **前缀和优化**：将O(n²)的计算降到O(n)，处理大规模数据不超时；  
- **阶乘预处理**：避免重复计算，提高效率。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**，帮大家把握整体框架~
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：这份代码综合了Register_int和modfish_的思路，是“最简且高效”的实现。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAXN = 5e5 + 10;
const int mod = 20051131;

ll fac[MAXN]; // 阶乘数组
int cnt[MAXN]; // 统计每条链的长度

int main() {
    int n;
    scanf("%d", &n);
    // 预处理阶乘
    fac[0] = 1;
    for (int i = 1; i <= n; i++) {
        fac[i] = fac[i-1] * i % mod;
    }
    // 统计每条链的长度（top[i]相同的点在同一条链）
    for (int i = 1, x; i <= n; i++) {
        scanf("%d", &x);
        cnt[x]++;
    }
    // 将链长排序（降序）
    sort(cnt + 1, cnt + n + 1, greater<int>());
    ll ans = 1, sum = 0; // sum是已拼链的总长度
    for (int i = 1; i <= n; i++) {
        if (cnt[i] == 0) break; // 没有更多链了
        // 1. 链内排列贡献：(cnt[i]-1)!
        ans = ans * fac[cnt[i]-1] % mod;
        // 2. 链连接贡献：sum - (i-1)*cnt[i]（i-1是已拼链数）
        if (i > 1) {
            ans = ans * ((sum - (ll)(i-1)*cnt[i] % mod + mod) % mod) % mod;
        }
        sum = (sum + cnt[i]) % mod; // 更新已拼链总长度
    }
    printf("%lld\n", ans);
    return 0;
}
```
* **代码解读概要**：  
  1. **预处理阶乘**：计算`0!`到`n!`，模上`20051131`；  
  2. **统计链长**：用`cnt`数组统计每个链顶对应的链长度；  
  3. **排序链长**：按降序排列，保证先拼长链；  
  4. **计算方案**：① 每条链的内部排列乘`(len-1)!`；② 每条短链的连接方案乘`sum - (i-1)*len`；③ 更新`sum`。


<code_intro_selected>
接下来剖析3份优质题解的“精华片段”~
</code_intro_selected>

### 题解一：(来源：Register_int)
* **亮点**：O(n)时间复杂度，代码极简，用`sort`和`sum`快速处理。
* **核心代码片段**：
```cpp
sort(cnt + 1, cnt + n + 1, greater<int>());
for (int i = 1; i <= n; i++) {
    if (!cnt[i]) break;
    for (int j = 1; j < cnt[i]; j++) ans = ans * j % mod; // 等价于fac[cnt[i]-1]
    if (i > 1) ans = ans * (sum - (ll)(i - 1) * cnt[i]) % mod; 
    sum += cnt[i];
}
```
* **代码解读**：  
  - 第一行`sort`是**降序排序**，把最长的链放在最前面；  
  - 第二行的循环是**计算链内排列**：`j从1到cnt[i]-1`的乘积就是`(cnt[i]-1)!`（和预处理阶乘效果一样，但更省空间）；  
  - 第三行的`sum - (i-1)*cnt[i]`是**计算可连接位置数**：`sum`是已拼链的总长度，`i-1`是已拼链数，两者相减就是当前链能接的位置数。
* **学习笔记**：当n很大时（比如5e5），预处理阶乘更高效，但Register_int的写法用“循环乘”也能过，因为`cnt[i]`是链长，总和是n。

### 题解二：(来源：luxiaomao)
* **亮点**：分Subtask分析，帮你从“暴力”到“优化”逐步理解。
* **核心代码片段（Sub4的O(n²)写法）**：
```cpp
sort(a+1,a+1+n,cmp); // 降序排序链长
ans = fac[a[1].h-1];
for(int i = 2;a[i].h;i++){
    a[i].v = fac[a[i].h-1];
    int cnt = 0;
    for(int j = 1;j < i;j++){
        cnt += a[j].h - a[i].h; // 计算每条已拼链的可连接位置数
    }
    ans = ans * cnt % mod * a[i].v % mod;
}
```
* **代码解读**：  
  - 这是Sub4的O(n²)写法，适合小数据；  
  - 内层循环`j从1到i-1`，计算每条已拼链的`a[j].h - a[i].h`（长链能接短链的位置数），总和是当前链的可连接位置数；  
  - 当n很大时（比如5e5），O(n²)会超时，所以需要用“前缀和”优化成O(n)。
* **学习笔记**：暴力写法是优化的基础，理解暴力才能明白为什么要用前缀和。

### 题解三：(来源：modfish_)
* **亮点**：倒序处理链长，逻辑更直观。
* **核心代码片段**：
```cpp
for(int i = 1; i <= n; i++) if(cnt[i]) a[++m] = cnt[i];
sort(a + 1, a + m + 1); // 升序排序，然后倒序处理
ll ans = 1, sum = a[m]; // sum是已拼链的总长度
for(int i = m; i >= 1; i--){
    if(i < m) ans = ans * (sum + p - a[i] * (m - i) % p) % p, sum = (sum + a[i]) % p;
    ans = ans * fac[a[i] - 1] % p;
}
```
* **代码解读**：  
  - 先将链长**升序排序**，然后从**最长的链（最后一个元素）**开始处理；  
  - `sum`初始化为最长链的长度，然后依次处理更短的链；  
  - `sum + p - a[i] * (m - i) % p`等价于`sum - (m - i) * a[i]`（`m - i`是已拼链数）。
* **学习笔记**：倒序处理有时能避免“降序排序”的写法，逻辑更直观，但本质和正序处理一样。


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：像素链拼接大挑战

### 核心演示内容  
- **场景初始化**：8位像素风格的工作台，左侧是“链仓库”（不同颜色的像素块代表链，长度越长，块数越多），右侧是“控制面板”（开始/暂停、单步、重置按钮，速度滑块）。  
- **算法启动**：点击“开始”，最长链从“链仓库”滑到工作台中央（高亮红色），伴随“咻”的音效。  
- **链连接演示**：  
  1. 下一条短链（比如长度3）从仓库滑出，屏幕上用**黄色闪烁块**标出可连接的位置（比如长5的链上有2个位置）；  
  2. 点击位置后，短链“粘”上去，伴随“咔嗒”的音效；  
  3. 已拼链的总长度`sum`在屏幕右上角实时更新；  
- **目标达成**：全部链拼完后，屏幕显示“树塔完成！”，播放“胜利”音效（8位风格的“叮~叮~”），并弹出“你通关啦！”的像素对话框。

### 交互设计  
- **单步执行**：点击“单步”，每步只处理一条链，方便观察；  
- **自动播放**：滑动“速度滑块”调整播放速度（最快1秒/步，最慢5秒/步）；  
- **重置动画**：点击“重置”，所有链回到仓库，重新开始。

### 游戏化元素  
- **关卡设计**：将链拼接分成3个“小关”：① 拼最长链；② 拼前3条链；③ 拼完所有链。每通关一个小关，屏幕弹出“小关胜利！”的提示；  
- **积分系统**：每正确拼接一条链得10分，连续拼接5条得“连击奖励”（额外50分），总分显示在屏幕左上角；  
- **背景音乐**：循环播放8位风格的轻松BGM（类似《超级马里奥》的背景音乐）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“排列组合+前缀和”的技巧，我们可以挑战更多类似问题~
</similar_problems_intro>

### 通用思路迁移  
本题的技巧能解决**“有规则的拼接计数问题”**，比如：  
1. 用不同长度的木棍拼金字塔，要求短木棍只能搭在长木棍上；  
2. 用不同大小的盒子装东西，要求小盒子只能放在大盒子里；  
3. 统计满足“父节点比子节点大”的树的数量。

### 洛谷练习推荐  
1. **洛谷 P1025 数的划分**  
   🗣️ **推荐理由**：考察“将数分成k个正整数的和”的方案数，需要用动态规划或排列组合，锻炼计数思维。  
2. **洛谷 P1044 栈**  
   🗣️ **推荐理由**：考察“栈的出栈序列数”（卡特兰数），属于排列组合的经典问题，锻炼递归和计数能力。  
3. **洛谷 P1164 小A点菜**  
   🗣️ **推荐理由**：考察“01背包的计数问题”，需要用动态规划和前缀和优化，锻炼优化思维。  


## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自 Mr_RoastFish)**：“如果先拼短链，会出现两个链长度相同的情况，无法合并。而从最长链开始合并，保证了前两条链不会长度相同，第三条链的长度肯定更小，以此类推，保证了合并的正确性。”  
> **点评**：这位同学的经验很重要！先拼长链是“避免错误”的关键——最长链只有一条（根所在的链），之后的链长度都更小，不会出现“长度相同无法合并”的问题。  


## 💪 结语  
本次关于“【MX-X6-T5】再生”的分析就到这里啦！这道题的核心是“数学计数+前缀和优化”，关键在于**理解链的连接规则**和**用前缀和快速计算方案数**。记住：编程中的“优化”往往来自“对问题本质的理解”——当你发现暴力写法超时，不妨想想“有没有办法用前缀和/动态规划把重复计算的部分省掉？”  

下次我们再一起探索更多有趣的编程挑战！💡

---
处理用时：108.18秒
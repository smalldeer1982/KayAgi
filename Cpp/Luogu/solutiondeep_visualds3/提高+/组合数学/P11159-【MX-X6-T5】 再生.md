# 题目信息

# 【MX-X6-T5】 再生

## 题目背景

原题链接：<https://oier.team/problems/X6F>。

---

> _このまま$\\$
らったった$\\$
音に乗って$\\$
今きっと世界で僕だけだ$\\$
後ろ向きな歌を聴いて$\\$
少しだけ$\\$
前向きに生きていく_
>
>_—— [再生 - Nanatsukaze](https://music.163.com/#/song?id=2133659925)_

破碎的点依照破碎的规则进行重组，如此再生的一个结构将会是什么样的呢？

## 题目描述

现有一棵 $n$ 个点的有标号有根树，给定其长链剖分得到的 top 数组，请你输出有多少种不同的树可以在长链剖分之后得到该 top 数组。答案对 $20051131$（质数）取模。

具体来说，对于一棵树 $T$，对所有点 $u$ 定义其树高 $h_u$：

- 如果 $u$ 是叶子，则 $h_u=1$。
- 否则设 $u$ 的孩子集合为 $S_u$，则 $h_u=\max\limits_{v\in S_u}h_v + 1$。

给定数组 $t_{1\cdots n}$，你需要计算有多少种树满足：

- 对于根节点 $r$，满足 $t_r=r$。
- 对于每一个不是叶子的节点 $u$，存在恰好一个孩子 $v$ 满足 $h_v+1=h_u$ 并且 $t_v=t_u$，其他孩子满足 $t_v=v$。

模 $20051131$（质数）。

两棵树不同当且仅当它们的根不同或它们的边集不同。

**保证答案不为 $\bf 0$，但是不保证答案在模意义下不为 $\bf 0$。**

## 说明/提示

**【样例解释 #1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/7np2ikvh.png)

仅有图中的两种树满足条件。

**【数据范围】**

对于所有数据，保证 $1\leq n\leq 5\times 10^5$，$1\leq t_i\leq i$，保证取模前答案不为 $0$。

**捆绑测试**，共 5 个 Subtask，具体限制如下所示：

- Subtask 1（11 pts）：$t_i=1$。
- Subtask 2（24 pts）：$n\leq 5$。
- Subtask 3（17 pts）：$n\leq 16$。
- Subtask 4（22 pts）：$n\leq 2\times 10^3$。
- Subtask 5（26 pts）：无特殊限制。

## 样例 #1

### 输入

```
5
1 1 1 4 4```

### 输出

```
2```

## 样例 #2

### 输入

```
16
1 2 1 4 1 4 1 4 9 1 1 12 1 1 12 1```

### 输出

```
7181107```

# AI分析结果

# 💡 Kay的C++算法解析：【MX-X6-T5】再生 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（排列组合 + 前缀和优化）

🗣️ **初步分析**：  
解决这道题的关键，就像“搭积木”——我们需要先把每条“长链积木”内部的零件排好序（用阶乘计算排列数），再把这些积木按“大的在下、小的在上”的规则叠起来（用前缀和快速算叠放的位置数）。  

### 核心算法思想类比  
- **排列组合**：就像给一条链选“排队顺序”——链头固定，剩下的节点可以任意排，有$(长度-1)!$种方法（比如3个节点的链，链头固定，另外2个有$2!=2$种排法）。  
- **前缀和优化**：就像算“总共有多少个空位可以放新积木”——之前叠好的所有大积木的总长度，减去“每个大积木不能放的位置数”，就是新积木能放的位置数（用前缀和快速算总长度）。  

### 题解思路与核心难点  
- **思路**：① 统计每条链的长度（用桶记录$t_i$相同的节点数）；② 按链长从大到小排序（保证小链只能接在大链上）；③ 算每条链的阶乘贡献；④ 用前缀和算每条链的连接位置数，相乘得总方案数。  
- **核心难点**：如何快速计算“小链能接在多少个位置”？—— 答案是“之前所有大链的总长度 - 之前链的数量×小链长度”（比如2条大链总长5，小链长2，能接的位置是$5 - 2×2=1$）。  
- **解决方案**：用前缀和维护“之前所有链的总长度”，这样每次计算只需O(1)时间。  

### 可视化设计思路  
我们会做一个**像素链匠**的复古游戏：  
- 屏幕左侧是“链库”（显示按长度排序的像素链，大链在下、小链在上）；  
- 中间是“搭建区”（展示已搭好的链，用不同颜色标记链长）；  
- 右侧是“控制面板”（单步、自动播放、速度滑块）。  
- **关键动画**：① 链内排列时，像素节点“洗牌”动画+“叮”音效；② 连接链时，小链“吸附”到大链的可放位置，高亮位置+“啪”音效；③ 完成搭建时，播放“胜利”音乐+像素烟花。  


## 2. 精选优质题解参考

<eval_intro>
为了帮大家快速掌握解题关键，我筛选了3份思路清晰、代码简洁的优质题解，一起来看看吧～
</eval_intro>

**题解一：(来源：Register_int)**  
* **点评**：这份题解堪称“极简主义”典范！思路直接命中核心——统计链长、排序、阶乘、前缀和，全部用最简洁的代码实现。比如用`cnt`数组统计链长，排序后用`sum`维护前缀和，每步计算都精准对应算法逻辑。代码只有10行左右，却完美解决了5e5的数据规模（O(n)时间），非常适合作为“标准答案”参考。

**题解二：(来源：luxiaomao)**  
* **点评**：这份题解像“拆解谜题”一样，分Subtask讲解，从最简单的“全链”情况（Sub1）到O(n²)的Sub4，再到O(n)的Sub5，一步步引导你理解问题。比如Sub1中“所有t_i=1”时答案是$(n-1)!$，直接对应链内排列的核心；Sub5中用前缀和优化，把O(n²)降到O(n)，让你清晰看到优化的过程。适合刚接触这类题的同学慢慢啃。

**题解三：(来源：EricWan)**  
* **点评**：这份题解用了树状数组来维护“可放位置数”，虽然时间复杂度是O(n log n)，但思路很有启发性——当需要动态维护前缀和时，树状数组是个好工具。比如用`update`函数添加链的长度，`query`函数查可放位置数，代码结构清晰，能帮你理解“前缀和的另一种实现方式”。不过对于5e5的数据，树状数组可能不如直接前缀和快，但作为学习参考很有价值。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在3个地方，解决了它们，题目就变得简单啦～
</difficulty_intro>

1. **难点1：为什么链内排列是$(长度-1)!$？**  
   - **分析**：每条链的链头（$t_i=i$的节点）是固定的，剩下的节点可以按任意顺序排列（比如链长3，链头是A，剩下B、C可以是AB C或AC B，共$2!=2$种）。  
   - **策略**：记住“固定一个点，剩下的全排列”就是$(长度-1)!$。  

2. **难点2：小链为什么只能接在大链上？**  
   - **分析**：长链剖分的规则是“重链是最长的子树”，如果小链接在大链上，才能保证大链还是“最长的”；如果大链接在小链上，就会破坏这个规则（比如大链长5，小链长3，接反后大链变成小链的子树，最长链就变成小链+大链的总长8，不符合原来的链长）。  
   - **策略**：按链长从大到小排序，保证每次接的都是小链。  

3. **难点3：如何快速算“小链能接多少个位置”？**  
   - **分析**：每条大链长$l_j$，小链长$l_i$，能接的位置是$l_j - l_i$（比如大链长5，小链长3，能接在第1、2个位置，共$5-3=2$个）。所有大链的总位置数是$\sum(l_j - l_i) = \sum l_j - (i-1)l_i$（$\sum l_j$是之前所有大链的总长，$i-1$是之前大链的数量）。  
   - **策略**：用前缀和维护$\sum l_j$，每次计算只需O(1)时间。  

### ✨ 解题技巧总结  
- **技巧A：桶统计链长**：用`cnt[t_i]++`快速统计每条链的长度，时间O(n)。  
- **技巧B：排序降序**：保证小链接在大链上，避免无效连接。  
- **技巧C：前缀和优化**：把O(n²)的求和降到O(n)，处理大数据无压力。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份“极简版”核心代码——它综合了Register_int题解的思路，用最少的代码解决问题，帮你快速把握整体框架～
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码来自Register_int的题解，用O(n)时间复杂度解决问题，逻辑清晰、代码简洁，是本题的“最优实现”。  
* **完整核心代码**：  
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MAXN = 5e5 + 10;
const int mod = 20051131;

int n, cnt[MAXN];
ll ans = 1, sum;

int main() {
    scanf("%d", &n);
    for (int i = 1, x; i <= n; i++) {
        scanf("%d", &x);
        cnt[x]++; // 统计每条链的长度
    }
    sort(cnt + 1, cnt + n + 1, greater<int>()); // 按链长降序排序
    
    for (int i = 1; i <= n; i++) {
        if (!cnt[i]) break; // 没有更多链了
        // 1. 计算链内排列的阶乘贡献
        for (int j = 1; j < cnt[i]; j++) {
            ans = ans * j % mod;
        }
        // 2. 计算链间连接的位置数（i>1时）
        if (i > 1) {
            ans = ans * (sum - (ll)(i - 1) * cnt[i]) % mod;
        }
        sum += cnt[i]; // 维护前缀和（之前所有链的总长）
    }
    printf("%lld", ans);
    return 0;
}
```
* **代码解读概要**：  
  1. 用`cnt`数组统计每条链的长度（`cnt[x]`表示链头为x的链的长度）；  
  2. 按链长从大到小排序（`greater<int>()`）；  
  3. 遍历每条链：① 算链内排列的阶乘（`j从1到cnt[i]-1`，乘到ans）；② 算链间连接的位置数（用前缀和`sum`减去`(i-1)*cnt[i]`）；③ 更新前缀和`sum`；  
  4. 输出ans（总方案数）。  


<code_intro_selected>
接下来，我们剖析3份优质题解的核心片段，看看它们的“点睛之笔”～
</code_intro_selected>

**题解一：(来源：Register_int)**  
* **亮点**：用`greater<int>()`排序，直接按链长降序，代码极简。  
* **核心代码片段**：  
```cpp
sort(cnt + 1, cnt + n + 1, greater<int>()); // 降序排序
for (int i = 1; i <= n; i++) {
    if (!cnt[i]) break;
    for (int j = 1; j < cnt[i]; j++) ans = ans * j % mod; // 阶乘贡献
    if (i > 1) ans = ans * (sum - (ll)(i - 1) * cnt[i]) % mod; // 连接位置数
    sum += cnt[i];
}
```
* **代码解读**：  
  - 为什么用`greater<int>()`？—— 让大链排在前面，小链排在后面，保证小链接在大链上。  
  - 为什么`sum - (i-1)*cnt[i]`？—— `sum`是之前所有大链的总长，`(i-1)`是之前大链的数量，`(i-1)*cnt[i]`是所有大链“不能放的位置数”总和，相减就是能放的位置数。  
* **学习笔记**：排序+前缀和，是处理“按顺序选元素”问题的常用组合！

**题解二：(来源：luxiaomao)**  
* **亮点**：分Subtask讲解，从O(n²)到O(n)，清晰展示优化过程。  
* **核心代码片段（Sub5的O(n)优化）**：  
```cpp
sort(a+1,a+1+n,cmp); // 按链长降序排序
ans = fac[a[1].h-1]; // 第一条链的阶乘贡献
sum = a[1].h;
for (int i = 2; a[i].h; i++) {
    ans = ans * fac[a[i].h-1] % mod; // 阶乘贡献
    ans = ans * (sum - (i-1)*a[i].h) % mod; // 连接位置数
    sum += a[i].h; // 前缀和
}
```
* **代码解读**：  
  - 这里用`fac`数组预处理阶乘（`fac[i] = i!`），避免每次循环计算阶乘，速度更快！比如`fac[a[i].h-1]`直接取链内排列的结果，不用循环乘。  
  - 为什么预处理阶乘？—— 对于大n（比如5e5），循环乘会超时，预处理能把阶乘计算的时间降到O(n)。  
* **学习笔记**：预处理阶乘是排列组合题的“必备技能”！

**题解三：(来源：EricWan)**  
* **亮点**：用树状数组维护前缀和，动态统计可放位置数。  
* **核心代码片段**：  
```cpp
void update(int x) { // 树状数组更新：添加长度为x的链
    while (x <= n) {
        t[x]++;
        x += lowbit(x);
    }
}
int query(int x) { // 树状数组查询：小于等于x的链长总和
    int ans = 0;
    while (x) {
        ans += t[x];
        x ^= lowbit(x);
    }
    return ans;
}
// 主函数中的连接位置数计算
ans *= query(n) - query(i); // query(n)是总长度，query(i)是小于等于i的长度总和？
```
* **代码解读**：  
  - 树状数组在这里用来维护“已搭好的链的长度分布”，`update(x)`把长度为x的链加入树状数组，`query(x)`查所有长度≤x的链的总长度？—— 不对，其实EricWan的代码中，`v[t[i]]++`统计链长，`sort(vec.begin(), vec.end())`降序排序，`query(n) - query(i)`其实是“已搭好的链中长度>i的总长度”？（可能代码中的`i`是当前链的长度）  
  - 为什么用树状数组？—— 当链的长度不是连续的时候，树状数组能更灵活地维护前缀和。比如如果链长是3、5、7，树状数组可以快速查“大于5的链长总和”。  
* **学习笔记**：树状数组是处理“动态前缀和”的有力工具，虽然本题用普通前缀和更简单，但学会它能解决更复杂的问题！  


## 5. 算法可视化：像素动画演示 (像素链匠)

### 动画演示主题：像素链匠的“搭链挑战”  
我们设计一个**8位像素风**的小游戏，你将扮演“像素链匠”，需要把短链正确连接到大链上，完成树的搭建！

### 核心演示内容  
- **场景初始化**：屏幕左侧是“链库”（显示按长度降序排列的像素链，大链是红色，小链是蓝色）；中间是“搭建区”（初始是最长的红色链，链头有个“根”标记）；右侧是“控制面板”（单步、自动播放、速度滑块、重置按钮）。  
- **链内排列动画**：点击一条链，链内的像素节点会“洗牌”（随机交换位置），伴随“叮”的音效，旁边显示“链内排列：(长度-1)! = X”。  
- **链间连接动画**：选中一条小链，拖动到搭建区的大链上，大链上的可放位置会高亮（比如大链长5，小链长3，高亮前2个位置），松开鼠标后小链“吸附”到高亮位置，伴随“啪”的音效，旁边显示“连接位置数：X”。  
- **胜利动画**：所有链搭建完成后，屏幕弹出“像素树完成！”的提示，播放8位风格的胜利音乐，背景绽放像素烟花。

### 交互与控制  
- **单步执行**：点击“单步”按钮，动画执行一步（比如计算一条链的阶乘贡献，或连接一条链）。  
- **自动播放**：点击“自动”按钮，动画按设定速度（滑块调节）自动执行，适合快速看整体流程。  
- **重置动画**：点击“重置”按钮，回到初始状态，重新开始搭建。

### 设计思路  
用8位像素风是为了营造“复古游戏”的轻松氛围，让学习更有趣；音效和高亮能强化“关键操作”的记忆（比如阶乘计算时的“叮”声，连接时的“啪”声）；游戏式的“搭链”过程，能让你直观理解“链内排列”和“链间连接”的逻辑！  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
本题的核心是“排列组合+前缀和优化”，这种思路能解决很多“计数问题”：  
- **场景1**：数的划分（比如把n分成k个正整数的和，求方案数）—— 用组合数计算。  
- **场景2**：栈的出栈序列（比如n个元素进栈，求不同的出栈序列数）—— 用卡特兰数（组合数的一种）计算。  
- **场景3**：树的计数（比如给定树的结构，求不同的标号树数）—— 用Prüfer序列（组合数的应用）计算。

### 练习推荐 (洛谷)  
1. **洛谷 P1025 数的划分**  
   * 🗣️ **推荐理由**：这道题需要用组合数计算“数的划分方案数”，能帮你巩固“排列组合”的思路。  
2. **洛谷 P1044 栈**  
   * 🗣️ **推荐理由**：这道题需要用卡特兰数计算“栈的出栈序列数”，是组合数的经典应用。  
3. **洛谷 P2290 [HNOI2004]树的计数**  
   * 🗣️ **推荐理由**：这道题需要用Prüfer序列计算“不同的标号树数”，能帮你拓展“树计数”的思路。  


## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自 Mr_RoastFish)**：“如果我们先拼短链，会较大概率出现两个链长度相同的情况。这时候是没法将两个长度相同的链进行合并的，因为无论怎么合并都会破坏长链剖分的性质。而从最长的链开始合并，保证了前两条链不会长度相同，第三条链的长度肯定小于第一、二条链的合并链长度，以此类推至最短链均成立，保证了合并链的正确性。”  
> **点评**：这位作者的经验很重要！从最长链开始合并，是避免“长度相同的链无法合并”的关键。比如样例一中，最长链长3，接下来是链长2，合并后总长度5，第三条链（如果有的话）长度肯定小于5，不会出现长度相同的情况。  


## 结语  
本次关于“【MX-X6-T5】再生”的C++解题分析就到这里。希望这份指南能帮你掌握“排列组合+前缀和优化”的思路，下次遇到类似的计数问题，你也能快速找到解法！记住：编程的乐趣在于“拆解问题”——把大问题拆成小步骤，一步步解决，你就是“像素链匠”啦～💪

---
处理用时：105.81秒
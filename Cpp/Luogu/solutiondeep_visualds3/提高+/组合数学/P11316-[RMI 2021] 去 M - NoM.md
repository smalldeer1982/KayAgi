# 题目信息

# [RMI 2021] 去 M / NoM

## 题目背景


译自 [9th Romanian Master of Informatics, RMI 2021](https://rmi.lbi.ro/rmi_2021/) D2T1。$\texttt{0.2s,0.5G}$。

## 题目描述


有 $N$ 个绿色的石子，标号 $1\sim N$。

有 $N$ 个灰色的石子，标号 $1\sim N$。

将 $2N$ 个石子任意排成一列，两个相邻石子的距离为 $1$。定义 $\mathrm{dist}(i)$ 为绿色的上面标有 $i$ 的石子与灰色的上面标有 $i$ 的石子的距离。

给定正整数 $M$。若存在 $1\le i\le N$，使得 $M\mid \mathrm{dist}(i)$，我们就说这样的排列方式是**不好的**（因为可能会导致 IDE 卡死）。否则我们就说这样的排列方式是**好的**。

求出好的排列方案数，对 $(10^9+7)$ 取模。

两种排列方案相同，当且仅当对应石子颜色和编号都相同。



## 说明/提示


对于 $100\%$ 的数据，保证 $1\le M\le N\le 2\, 000$。


| 子任务编号 | $N,M\le  $ |得分 |  
| :--: | :--: |  :--: |
| $ 1 $    | $ 5 $  | $9$ |
| $ 2 $    | $ 100 $  | $12$ |
| $ 3 $    | $ 300 $  | $13$ |
| $ 4 $    | $ 900 $  | $18$ |
| $ 5 $    | $ 2\, 000$  | $48$ |

## 样例 #1

### 输入

```
100 23```

### 输出

```
171243255```

## 样例 #2

### 输入

```
1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
3 2```

### 输出

```
288```

## 样例 #4

### 输入

```
300 300```

### 输出

```
929890502```

# AI分析结果

# 💡 Kay的C++算法解析：[RMI 2021] 去 M / NoM 深入学习指南 💡

今天我们来一起分析“[RMI 2021] 去 M / NoM”这道C++编程题。这道题看起来有点挑战性，但只要掌握了“容斥原理”和“背包DP”这两个工具，就能迎刃而解啦！本指南会帮你梳理思路，理解核心算法，并掌握解题技巧。


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：容斥原理 + 分组背包动态规划（DP）

🗣️ **初步分析**：  
解决这道题的关键在于**正难则反**——直接计算“没有任何一对同标号绿灰石子距离是M倍数”的方案数（好排列）很难，我们可以先计算“至少有i对满足距离是M倍数”的方案数（坏排列），再用**容斥原理**调整得到好排列的数目。  

而“坏对”的关键性质是：**两个位置距离是M的倍数 ⇨ 位置模M同余**（比如位置x和y，|x-y|是M的倍数等价于x%M == y%M）。因此，不同模M的剩余类（比如模M余0、1、…、M-1的位置）之间互不影响，我们可以把每个剩余类看作一个“物品组”，从中选择k个坏对，再用**分组背包DP**合并所有剩余类的选择方案，得到“至少i个坏对”的总方案数。  

具体流程是：  
1. **预计算**：阶乘、逆元和组合数（快速计算方案数）；  
2. **分组背包**：遍历每个剩余类，计算选k个坏对的方案数，合并到全局背包；  
3. **容斥计算**：用背包结果乘以容斥系数（(-1)^i），得到好排列数目。  

**可视化设计思路**：我们用8位像素风格演示这个过程——  
- 左侧是“模M洞穴”（每个洞穴对应一个剩余类，用不同颜色表示），洞穴中的像素块代表位置；  
- 选择k个坏对时，两个像素块“成对闪烁”并伴随“叮”的音效；  
- 背包合并时，方案数“滑动”到右侧背包区域；  
- 容斥计算时，用红色（减）/绿色（加）表示系数调整，最终好排列数目用“胜利音效”（8位风格“叮~叮~”）提示。


## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解：
</eval_intro>

**题解一：(来源：_Ch1F4N_ )**  
* **点评**：这份题解的思路非常简洁，直接抓住“剩余类互不影响”的关键点，用**滚动数组**实现背包DP，避免了二维数组的空间浪费。代码中“剩余类大小计算”（`(n - i) / m + !!i`）非常巧妙，准确统计了每个剩余类的位置数目。此外，“先算无标号方案，最后乘标号排列数”的技巧简化了问题，让代码更易读。

**题解二：(来源：水星湖 )**  
* **点评**：此题解对容斥原理的推导非常清晰，明确了“钦定i个坏对”的方案数计算方式（`f_i = 选i个坏对的位置 × 选i个标号 × 剩余位置任意排列`）。代码中的**二维DP数组**（`f[i][s]`表示前i个剩余类选s个坏对的方案数）结构清晰，便于理解剩余类的合并过程。预计算阶乘、逆元和组合数的做法也提高了代码效率。

**题解三：(来源：Unnamed114514 )**  
* **点评**：这份题解的亮点是**一维滚动数组优化**，将二维背包压缩为一维（`f[j]`表示选j个坏对的方案数），空间复杂度从O(M×N)降到O(N)。代码中“逆序循环j”确保了每个剩余类的选择不会重复计算，体现了背包DP的经典优化技巧。此外，剩余类大小的计算（`a[i] = (2*n)/m + (i <= (2*n)%m)`）准确且简洁。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，以下三个难点最容易卡住大家，但只要掌握对应的策略，就能迎刃而解：
</difficulty_intro>

### 难点1：想到用容斥原理  
* **分析**：直接计算“没有坏对”的方案数需要排除所有可能的坏对组合，复杂度极高。而容斥原理的核心是“正难则反”——先算“至少有i个坏对”的情况，再用系数调整（减去多算的，加上漏算的）。  
* 💡 **学习笔记**：遇到“没有任何...满足”的问题，优先考虑容斥原理。

### 难点2：发现“坏对”的模M性质  
* **分析**：两个位置距离是M的倍数等价于位置模M同余。这个性质将问题拆分成**独立剩余类**，每个剩余类的坏对选择互不影响，极大简化了计算。  
* 💡 **学习笔记**：遇到“距离是M倍数”的条件，先分析位置的模M性质，往往能拆分问题。

### 难点3：用分组背包合并剩余类方案  
* **分析**：每个剩余类是一个“物品组”，组内的“物品”是“选k个坏对”，我们需要合并所有组的选择，得到“选i个坏对”的总方案数。这正好是**分组背包**的模型（每组选一个物品，合并总价值）。  
* 💡 **学习笔记**：遇到“独立子问题合并”的情况，优先用分组背包DP。

### ✨ 解题技巧总结  
- **正难则反**：直接计算困难时，用容斥转换问题；  
- **模性质拆分**：利用模运算将问题拆分为独立子问题；  
- **滚动数组**：背包DP中用滚动数组优化空间；  
- **预计算**：提前计算阶乘、逆元，避免重复计算。


## 4. C++核心代码实现赏析

<code_intro_overall>
首先，我们来看一个综合优质题解思路的通用实现，它用滚动数组背包和容斥原理解决问题：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了_Ch1F4N_和Unnamed114514的思路，用滚动数组优化空间，确保简洁高效。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <algorithm>
  using namespace std;

  typedef long long ll;
  const int MOD = 1e9 + 7;
  const int MAXN = 4005;

  ll fac[MAXN], inv[MAXN];
  ll dp[MAXN]; // dp[j]表示选j个坏对的方案数

  ll qpow(ll a, ll b) {
      ll res = 1;
      while (b) {
          if (b & 1) res = res * a % MOD;
          a = a * a % MOD;
          b >>= 1;
      }
      return res;
  }

  ll C(int n, int m) {
      if (n < m || m < 0) return 0;
      return fac[n] * inv[m] % MOD * inv[n - m] % MOD;
  }

  int main() {
      int n, m;
      cin >> n >> m;
      int total_pos = 2 * n; // 总位置数（绿+灰石子共2n个）

      // 预计算阶乘和逆元
      fac[0] = 1;
      for (int i = 1; i <= total_pos; ++i)
          fac[i] = fac[i-1] * i % MOD;
      inv[total_pos] = qpow(fac[total_pos], MOD - 2);
      for (int i = total_pos - 1; i >= 0; --i)
          inv[i] = inv[i+1] * (i+1) % MOD;

      // 初始化背包：选0个坏对的方案数是1
      dp[0] = 1;
      int max_bad = 0; // 所有剩余类能选的最大坏对数

      // 遍历每个模M的剩余类
      for (int r = 0; r < m; ++r) {
          int cnt = (total_pos - r) / m + (r != 0); // 剩余类的位置数
          int k_max = cnt / 2; // 该剩余类最多选k_max个坏对

          // 滚动数组逆序更新（避免重复计算）
          for (int j = max_bad; j >= 0; --j) {
              for (int k = 1; k <= k_max; ++k) {
                  // 选k个坏对的方案数：选2k个位置 → 分成k对 → 排列k对
                  ll ways = C(cnt, 2*k) * C(2*k, k) % MOD * fac[k] % MOD;
                  dp[j + k] = (dp[j + k] + dp[j] * ways) % MOD;
              }
          }
          max_bad += k_max;
      }

      // 容斥计算好排列数目
      ll ans = 0;
      for (int i = 0; i <= max_bad; ++i) {
          if (2 * i > total_pos) continue;
          // 剩余位置的方案数：选剩余绿石子位置 → 排列绿/灰石子
          ll rest = C(total_pos - 2*i, n - i) * fac[n - i] % MOD * fac[n - i] % MOD;
          ll term = dp[i] * rest % MOD;
          if (i % 2 == 1) term = (MOD - term) % MOD; // 容斥系数：(-1)^i
          ans = (ans + term) % MOD;
      }

      cout << ans << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  代码先预计算阶乘和逆元，再用滚动数组`dp`实现分组背包，遍历每个剩余类合并坏对方案，最后用容斥原理调整得到好排列数目。关键部分是**剩余类大小计算**和**滚动数组逆序更新**，确保了正确性和效率。


<code_intro_selected>
接下来，我们剖析优质题解中的核心片段：
</code_intro_selected>

### 题解一：(来源：_Ch1F4N_ )  
* **亮点**：滚动数组背包，剩余类大小计算巧妙。  
* **核心代码片段**：  
  ```cpp
  for (int p = 0; p < m; p++) {
      int cnt = (n - p) / m + (p != 0);
      for (int i = sum; i >= 0; i--) {
          for (int j = 1; j * 2 <= cnt; j++) {
              dp[i + j] = (dp[i + j] + dp[i] * C(cnt, j*2) % MOD * C(j*2, j) % MOD * fac[j]) % MOD;
          }
      }
      sum += cnt / 2;
  }
  ```
* **代码解读**：  
  - `cnt`是剩余类的位置数，`sum`是当前能选的最大坏对数；  
  - 逆序循环`i`避免同一剩余类的重复计算；  
  - `C(cnt, j*2)`选2j个位置，`C(j*2, j)`分成j对，`fac[j]`排列j对，三者相乘是选j个坏对的方案数。  

* 💡 **学习笔记**：滚动数组是背包DP的常用优化，适用于空间紧张的情况。


### 题解二：(来源：水星湖 )  
* **亮点**：二维DP清晰展示剩余类合并。  
* **核心代码片段**：  
  ```cpp
  f[0][0] = 1;
  for (int i = 1; i <= m; i++) {
      int x = 1 + (2*n - i) / m;
      for (int s = 0; s <= n; s++)
          for (int j = 0; j <= min(x/2, s); j++) {
              f[i][s] = (f[i][s] + f[i-1][s-j] * C(x, 2*j) % MOD * fac[2*j] % MOD * ipw2[j] % MOD * inv[j] % MOD) % MOD;
          }
  }
  ```
* **代码解读**：  
  - `f[i][s]`表示前i个剩余类选s个坏对的方案数；  
  - `x`是剩余类的位置数，`j`是当前选的坏对数；  
  - `C(x, 2*j)`选2j个位置，`fac[2*j]`排列位置，`ipw2[j]`调整颜色方案，`inv[j]`是j!的逆元。  

* 💡 **学习笔记**：二维DP适合理解分组背包的合并过程，后期可优化为滚动数组。


### 题解三：(来源：Unnamed114514 )  
* **亮点**：一维滚动数组，空间高效。  
* **核心代码片段**：  
  ```cpp
  for (int i = 1; i <= m; ++i)
      for (int j = n; ~j; --j)
          for (int k = 1; k <= min(j, a[i]/2); ++k)
              f[j] = (f[j] + f[j-k] * A(a[i], 2*k) % MOD * C(n-(j-k), k)) % MOD;
  ```
* **代码解读**：  
  - `f[j]`表示选j个坏对的方案数；  
  - `A(a[i], 2*k)`是排列数（选2k个位置并排列），`C(n-(j-k), k)`选k个标号作为坏对；  
  - 逆序循环`j`确保每个剩余类的选择不重复。  

* 💡 **学习笔记**：一维滚动数组是背包DP的极致优化，适用于大数据量。


## 5. 算法可视化：像素动画演示

### 动画演示主题  
《像素探险家之容斥背包》——探险家通过合并“模M洞穴”中的坏对方案，用容斥原理排除坏宝石，最终得到好宝石。

### 核心演示内容  
1. **场景初始化**：  
   - 左侧是“模M洞穴”（每个洞穴对应一个剩余类，用红/蓝/绿等颜色表示）；  
   - 右侧是“背包”（显示当前选j个坏对的方案数）；  
   - 下方是控制面板（单步、自动、重置按钮，速度滑块）。  

2. **剩余类选择**：  
   - 点击“开始”后，洞穴中的像素块（位置）闪烁，选择k个坏对时，两个像素块“成对发光”并伴随“叮”的音效；  
   - 背包中的对应位置（j=k）数字变大，表示方案数增加。  

3. **背包合并**：  
   - 一个洞穴选择完成后，方案数“滑动”到全局背包，比如从洞穴1选2个坏对，背包的j=2位置数字增加。  

4. **容斥计算**：  
   - 所有洞穴选择完成后，背包中的每个j位置显示红色（减）/绿色（加）；  
   - 计算总和后，好宝石数目用“胜利音效”提示，屏幕显示“好排列：X”。

### 设计思路  
- **复古风格**：8位像素风降低学习压力，唤起童年游戏记忆；  
- **音效强化**：关键操作（选坏对、容斥）用音效提示，加深记忆；  
- **交互友好**：单步/自动播放满足不同学习节奏，重置按钮方便重复练习。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
理解“容斥+背包”的结合后，我们可以尝试以下相似问题，巩固技巧：
</similar_problems_intro>

### 通用思路迁移  
- 容斥原理常用于“没有任何...满足”的计数问题（如错位排列、相邻元素不同）；  
- 分组背包用于“独立子问题合并”（如选物品组、合并方案数）。

### 洛谷练习推荐  
1. **洛谷 P1359** - 《租用游艇》  
   * 🗣️ **推荐理由**：锻炼“正难则反”的思维，用容斥处理“最小费用”问题。  
2. **洛谷 P2567** - 《[SCOI2010]幸运数字》  
   * 🗣️ **推荐理由**：用容斥原理处理“至少有一个幸运数字”的情况，结合DFS枚举子集。  
3. **洛谷 P3197** - 《[HNOI2008]越狱》  
   * 🗣️ **推荐理由**：用容斥计算“没有越狱”的方案数，思路和本题高度相似。


## 7. 学习心得与经验分享

> **参考经验 (来自 流水行船CCD )**：“难点在于发现本题是容斥而非容斥本身。”  
> **点评**：很多同学会卡在“不知道用什么算法”的阶段，而本题的难点正是“意识到要用容斥”。这提醒我们：遇到“正难则反”的问题，先想容斥原理。

> **参考经验 (来自 _Ch1F4N_ )**：“先算无标号方案，最后乘标号排列数。”  
> **点评**：这个技巧简化了问题——无标号方案的计算更简单，最后乘上标号的排列数（n!）就能得到有标号的方案数，避免了复杂的标号处理。


## 结论

本次关于“[RMI 2021] 去 M / NoM”的分析就到这里。这道题的核心是“容斥+背包”，关键在于**正难则反**的思维和**拆分独立子问题**的能力。希望这份指南能帮助你掌握容斥原理和背包DP的结合应用，下次遇到类似问题时能快速思路！💪

---
处理用时：195.11秒
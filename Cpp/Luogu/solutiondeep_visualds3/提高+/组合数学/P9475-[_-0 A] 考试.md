# 题目信息

# [_-0 A] 考试

## 题目背景

小 $\mathfrak{g}$ 参加一场考试时，不小心把答题卡填反了。

## 题目描述

答题卡有 $n (1 \le n \le 10^9)$ 行，$m (1 \le m \le 10^9)$ 列，共 $nm$ 道题，**从左到右，从上到下，横向排列**。

每道题有 $c (4 \le c \le 10^9)$ 个选项。其中，前 $k(0 \le k \le nm)$ 道题为单选题，**有且仅有一个**正确选项；后 $nm - k$ 道题为多选题，正确选项个数**严格大于** $1$ 且**严格小于** $c$。

小 $\mathfrak{g}$ 正确地回答了所有题，但是她不小心把答题卡的方向看反了，从而她的答案排列方式为**从上到下，从左到右，纵向排列**。

题目的评分方式为：选项完全正确得 $1$ 分，多选或错选得 $0$ 分，漏选按比例给分。

形式化地说，若 $A$ 为某道题正确答案选项的集合，$B$ 为答题卡上选项的集合（均为 $\{1,2,3,\cdots,c\}$ 的子集），则该题得分为：

$$\begin{cases}\frac{\lvert B \rvert}{\lvert A \rvert}&\text{if\quad}
B\sube A\\0&\text{otherwise}\end{cases}$$

小 $\mathfrak{g}$ 忘记考试的正确答案是什么了，于是她去问小 $\mathfrak{f}$，如果考试的正确答案在合法范围内等概率随机，那么自己期望得分是多少。由于结果可能很大，她只需要知道结果对 $10^9+7$ 取模的值。

**题目保证 $c$ 和 $2^c-c-2$ 都不是 $10^9+7$ 的倍数。**


但是小 $\mathfrak{f}$ 也不会，所以他来求助万能的你。

## 说明/提示

**样例 $1$ 解释：**

得分的期望为 $\frac{67}{25}$，对 $10^9+7$ 取模为 $760000008$。

一种可能的考试的正确答案依次为：

$\texttt{C,D,B,AD,ABD,BC}$

那么答题卡上应该填写：

| $\texttt{C}$ | $\texttt{D}$ | $\texttt{B}$ |
| :----------: | :----------: | :----------: |
| $\texttt{AD}$ | $\texttt{ABD}$ | $\texttt{BC}$ |

实际填写：

| $\texttt{C}$ | $\texttt{B}$ | $\texttt{ABD}$ |
| :----------: | :----------: | :----------: |
| $\texttt{D}$ | $\texttt{AD}$ | $\texttt{BC}$ |

答案为 $\texttt{C}$，填写 $\texttt{C}$，得 $1$ 分。

答案为 $\texttt{D}$，填写 $\texttt{B}$，得 $0$ 分。

答案为 $\texttt{B}$，填写 $\texttt{ABD}$，得 $0$ 分。

答案为 $\texttt{AD}$，填写 $\texttt{D}$，得 $\frac{1}{2}$ 分。

答案为 $\texttt{ABD}$，填写 $\texttt{AD}$，得 $\frac{2}{3}$ 分。

答案为 $\texttt{BC}$，填写 $\texttt{BC}$，得 $1$ 分。

综上，这种情况下，考试得分为：

$1+0+0+\frac{1}{2}+\frac{2}{3}+1=
\frac{19}{6}$ 分。

**本题采用捆绑测试且使用子任务依赖。**

| 编号 | 分值 | $n,m\le$ | $c\le$ | 性质 | 依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $0$ | N/A| N/A | 样例 | 无 |
| $1$ | $5$ | $10^9$ | $10^9$ | A | 无 |
| $2$ | $5$ | $2$ | $4$ | 无 | 无 |
| $3$ | $20$ | $10^3$ | $10$ | 无 | $2$ |
| $4$ | $15$ | $10^9$ | $10$ | 无 | $2,3$ |
| $5$ | $15$ | $10^3$ | $10^3$ | 无 | $2,3$ |
| $6$ | $15$ | $10^3$ | $10^5$ | 无 | $2,3,5$ |
| $7$ | $10$ | $10^3$ | $10^9$ | B | 无 |
| $8$ | $10$ | $10^3$ | $10^9$ | 无 | $2,3,5,6,7$ |
| $9$ | $5$ | $10^9$ | $10^9$ | 无 | $0,1,2,3,4,5,6,7,8$ |

特殊性质 A：$n=1$ 或 $m=1$

特殊性质 B：$k=nm-2$

## 样例 #1

### 输入

```
2 3 3 4```

### 输出

```
760000008```

## 样例 #2

### 输入

```
314159265 358979323 84626433832795028 841971693```

### 输出

```
465094894```

# AI分析结果


### Kay的C++算法解析：考试 深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`组合数学与期望计算`  
🗣️ **初步分析**：  
> 本题核心在于**期望的线性分解**和**分类计数**，如同把混合糖果按颜色分类后分别计算甜度。  
> - **解题思路**：将答题卡格子分为5类（题号对应/错位组合），独立计算每类格子的数量和单题得分期望，加权求和。  
> - **核心难点**：  
>   - 分类计数时矩形区域交集的复杂计算（需处理$n,m \leq 10^9$的大数据）  
>   - 多选题得分期望的组合推导（涉及二项式定理的巧妙应用）  
> - **可视化设计**：  
>   - 用**8位像素网格**模拟答题卡，不同颜色区分格子类型  
>   - 高亮**题号对应点**的动态路径（复古音效：移动时"嘀"声，计算正确时"叮咚"声）  
>   - **自动演示模式**：AI逐步展示矩形切割与组合计算过程（调速滑块控制速度）

---

#### 2. 精选优质题解参考
**题解（作者：0x3F）**  
* **点评**：  
  - 思路清晰性：创新性提出**五类分解法**，将复杂问题简化为独立子问题（★★★★☆）  
  - 代码规范性：变量名`c11`/`c22`等含义明确，模块化计算区域交集（★★★☆☆）  
  - 算法有效性：组合数学推导严谨（$S_{22}$的生成函数优化），时间复杂度$O(\log n + \log m)$（★★★★★）  
  - 实践价值：可直接用于竞赛，但需注意边界处理（$n=m=1$时需特判）（★★★★☆）  
  > **亮点**：  
  > 1. 利用二项式定理导出$S_{22}=\frac{3^c-3\cdot2^c+3}{2(2^c-c-2)^2}$的简洁形式  
  > 2. 矩形切割法高效计算$C_{11}'$（避免$O(nm)$遍历）

---

#### 3. 核心难点辨析与解题策略
1. **难点1：大矩阵区域交集计算**  
   * **分析**：当$n,m \leq 10^9$时，需将满足$(i-1)m+j \leq k$的区域拆解为矩形$R_1 \cup R_2$，再求其与纵向排列区域的交。关键技巧是**分块坐标映射**：  
     $$C_{11}' = \left\lfloor \frac{k}{m} \right\rfloor \left\lfloor \frac{k}{n} \right\rfloor + \min\left(\left\lfloor \frac{k}{n} \right\rfloor, k \bmod m\right) + \cdots$$
   * 💡 **学习笔记**：大矩阵问题常通过分解为矩形子问题降低复杂度

2. **难点2：题号对应点的计数**  
   * **分析**：满足$(i-1)m+j = (j-1)n+i$的点构成**线性丢番图方程**，解的数量由$g=\gcd(n-1,m-1)$决定：  
     $$C_{\text{eq}} = g+1, \quad C_{11} = C_{11}' - \left\lceil \frac{(k-1)g}{nm-1} \right\rceil$$
   * 💡 **学习笔记**：整数解计数需结合最大公约数和边界条件调整

3. **难点3：多选题期望的推导**  
   * **分析**：$S_{22}$需计算所有合法选项对$(A,B)$的得分和，通过**生成函数变形**：  
     $$\sum_{i=2}^{c-1} \binom{c}{i} \frac{1}{i} \left( i(2^{i-1}-1) \right) = \frac{3^c - 3 \cdot 2^c + 3}{2}$$
   * 💡 **学习笔记**：组合求和问题可转化为二项式系数与幂函数的组合

✨ **解题技巧总结**  
- **分类讨论法**：将复杂系统拆解为独立子类（如本题5类格子）  
- **生成函数技巧**：用$(x+1)^n$的导数关系简化组合求和  
- **模逆元优化**：$1/c \bmod p$ 转化为 $c^{p-2} \bmod p$（费马小定理）  

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**  
* **说明**：综合优质题解思路，包含关键分类计算与模逆元优化
```cpp
#include <bits/stdc++.h>
using namespace std;
const int p = 1e9 + 7;

inline int qpow(int a, long long b) {
    int s = 1;
    while (b) {
        if (b & 1) s = 1LL * s * a % p;
        a = 1LL * a * a % p;
        b >>= 1;
    }
    return s;
}

int main() {
    long long n, m, k, c, nm;
    cin >> n >> m >> k >> c;
    nm = n * m;
    // 计算 C11'（区域交集）
    long long c11 = (k / m) * (k / n) 
                  + min(k / n, k % m) 
                  + min(k % n, k / m) 
                  + (k / m < k % n && k / n <= k % m);
    long long c12 = k - c11, c21 = k - c11;
    // 计算题号对应点
    long long g = __gcd(n - 1, m - 1);
    long long step = g ? (nm - 1) / g : 1;
    long long ceq = g + 1;
    c11 -= (step + k - 1) / step;  // 扣除题号对应单选
    long long c22 = nm - c11 - c12 - c21 - ceq;
    // 计算单题期望
    int seq = 1;
    int s11 = qpow(c, p - 2);     // 1/c mod p
    int s12 = 0;
    int s21 = qpow(c, p - 2);
    int s22 = 1LL * (qpow(3, c) - 3LL * qpow(2, c) % p + p + 3) % p 
              * qpow(2, p - 2) % p 
              * qpow((qpow(2, c) - c - 2) % p, p - 2) % p;
    // 加权求和
    int ans = (ceq % p * seq + c11 % p * s11 + c12 % p * s12 
              + c21 % p * s21 + c22 % p * s22) % p;
    cout << (ans + p) % p << endl;
}
```
* **代码解读概要**：  
  > 1. **区域计算**：`c11`实现矩形切割法求交集（关键行：`min(k/n, k%m)`）  
  > 2. **题号对应点调整**：`step = (nm-1)/g`映射线性方程解  
  > 3. **期望计算**：`qpow`快速幂求模逆元，`s22`实现组合公式  
  > 4. **合成答案**：五类期望加权求和（注意负数取模处理）

---

#### 5. 算法可视化：像素动画演示
* **主题**：`复古答题卡大冒险`（8位像素风格）  
* **核心演示**：  
  ![像素网格](https://cdn.luogu.com.cn/upload/image_hosting/s08r3v5v.png)  
  > 1. **初始化**：生成$n \times m$像素网格（绿：题号对应点，蓝：单选区，红：多选区）  
  > 2. **区域切割**：动态绘制$k$边界（黄线），分解$R_1, R_2$矩形（闪烁动画+切割音效）  
  > 3. **题号对应点**：高亮路径$(i,j) \rightarrow (j,i)$（移动像素小人，路径留残影）  
  > 4. **期望计算**：  
  >    - 点击格子显示类型（$C_{\text{eq}}$/$C_{11}$等）  
  >    - 播放$S_{22}$推导动画：二项式系数展开（粒子特效模拟$\sum \binom{c}{i}$）  
  > 5. **控制面板**：  
  >    - 速度滑块（0.5x~3x）  
  >    - 单步/暂停/重置  
  >    - AI自动演示（贪吃蛇式遍历网格）  
  > 6. **音效设计**：  
  >    - 移动：8-bit "嘀"声  
  >    - 正确：胜利音效  
  >    - 错误：短促警报  

---

#### 6. 拓展练习与相似问题思考
* **技巧迁移**：  
  组合数学与期望计算常用于：  
  1. 随机游走问题（状态转移期望）  
  2. 抽卡概率模型（带权期望求和）  
  3. 几何分布应用（多次独立实验期望）  
* **推荐练习**：  
  1. **洛谷 P1654** - 期望计算  
     > 🗣️ 巩固期望线性性和概率分解  
  2. **洛谷 P6154** - 游走  
     > 🗣️ 练习图论与期望的结合应用  
  3. **洛谷 P7138** - 概率生成函数  
     > 🗣️ 深化生成函数在期望中的应用  

---

#### 7. 学习心得与经验分享
> **参考经验**：  
> "推导$S_{22}$时卡在$\sum j\binom{i}{j}$的化简，后通过二项式求导技巧突破"  
>   
> **点评**：  
> 调试组合数学题时，**手算小规模案例**（如$c=3$）和**生成函数变形**是关键策略。遇到求和瓶颈时，可考虑：  
> 1. 交换求和顺序  
> 2. 观察组合恒等式（如$\binom{n}{k}=\binom{n-1}{k-1}+\binom{n-1}{k}$）  
> 3. 关联二项式展开的导数/积分形式  

---
### 总结
本题展示了**期望线性性**与**组合计数**的经典结合，需掌握：  
1. 大矩阵分块技巧  
2. 生成函数化简方法  
3. 模逆元加速计算  
**动手实现**：尝试用可视化工具复现矩形切割过程，加深对空间分解的理解！💪

---
处理用时：449.92秒
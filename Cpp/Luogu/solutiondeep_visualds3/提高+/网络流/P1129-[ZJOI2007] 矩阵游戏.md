# 题目信息

# [ZJOI2007] 矩阵游戏

## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。


## 样例 #1

### 输入

```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0
```

### 输出

```
No
Yes
```

# AI分析结果


### 💡 Kay的C++算法解析：矩阵游戏 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：二分图匹配  
🗣️ **初步分析**：  
> 解决矩阵游戏的关键在于理解**行列匹配关系**。想象行和列是两队舞者，每个黑色格子是连接他们的纽带。交换行/列相当于调整舞伴顺序，但不会改变匹配关系。二分图匹配的核心思想是通过匈牙利算法或网络流，计算行和列能否完美配对（每行都有唯一匹配列）。  
> - **题解核心思路**：将行视为左部点，列视为右部点，每个黑格建立行→列的边。若最大匹配=n，则可通过交换使主对角线全黑。  
> - **可视化设计**：动画将展示行/列像素节点（FC风格方块），匹配过程用彩色连线+音效（匹配成功"叮"声），高亮当前匹配尝试的行和列节点。  
> - **复古游戏化**：采用8位像素风格，匹配成功时播放经典FC胜利音效，每完成一行匹配视为"过关"增加积分，增强闯关感。

---

#### 2. 精选优质题解参考
**题解一（作者：俾斯麦）**  
* **点评**：  
  思路清晰，同时提供匈牙利和Dinic两种解法。代码规范（变量名`head/to/next`含义明确），Dinic实现包含关键优化（时间戳避免重复搜索）。亮点在于详细注释和复杂度分析，实践价值高（可直接用于竞赛）。  

**题解二（作者：Night_Aurora）**  
* **点评**：  
  逻辑推导透彻，用"匹配边"类比解释转化过程。代码简洁（前向星建图），边界处理严谨。亮点是作者心得："交换行/列本质是调整匹配顺序，不影响总数"，启发读者理解问题本质。

**题解三（作者：hs_black）**  
* **点评**：  
  代码结构工整（统一接口`add`函数），用"魔方旋转"比喻行列交换。亮点是强调匹配与最终状态的等价性，并附示意图加深理解。

---

#### 3. 核心难点辨析与解题策略
1. **难点：问题转化**  
   *分析*：如何从矩阵交换联想到二分图？关键在于发现：交换不改变行列关联性。优质题解通过"舞伴调整"类比，将黑格视为行-列连接。  
   💡 学习笔记：复杂操作问题常可转化为图论模型。

2. **难点：匹配证明**  
   *分析*：为何匹配数=n即有解？因为完美匹配等价于存在n个行列独立黑格。通过交换可将其移至对角线。  
   💡 学习笔记：匹配数决定可行性。

3. **难点：算法选择**  
   *分析*：匈牙利（O(n³)）适合n≤200；Dinic（O(n²√n)）更高效但实现复杂。题解均规范使用邻接表存储。  
   💡 学习笔记：小图用匈牙利，大图用网络流。

✨ **解题技巧总结**：  
- **模型转化**：将矩阵操作抽象为图匹配  
- **模块封装**：分离建图/匹配逻辑（如`add_edge`+`dfs`）  
- **边界处理**：多组数据清空全局变量（`head/match`数组）  

---

#### 4. C++核心代码实现赏析
```cpp
// 本题通用核心实现（匈牙利算法）
#include <cstring>
const int N = 405;
int match[N], n;
bool vis[N], G[N][N];

bool dfs(int u) {
    for (int v = 1; v <= n; ++v)
        if (G[u][v] && !vis[v]) {
            vis[v] = true;
            if (!match[v] || dfs(match[v])) {
                match[v] = u;
                return true;
            }
        }
    return false;
}

bool check() {
    memset(match, 0, sizeof match);
    for (int i = 1; i <= n; ++i) {
        memset(vis, 0, sizeof vis);
        if (!dfs(i)) return false;
    }
    return true;
}
```
* **代码解读概要**：  
  用邻接矩阵`G`存储行-列关系，`dfs`实现匈牙利递归匹配。`match[v]=u`记录列v匹配行u，`vis`避免重复访问。

**题解一核心片段（Dinic）**  
```cpp
while (bfs()) while (flow = dinic(s, INF)) maxflow += flow;
```
* **亮点**：分层优化加速网络流  
* **学习笔记**：BFS分层图+DFS多路增广是Dinic效率关键

**题解二核心片段（前向星）**  
```cpp
void add(int x, int y) { 
    to[++cnt] = y; nxt[cnt] = head[x]; head[x] = cnt; 
}
```
* **亮点**：链式前向星节省空间  
* **学习笔记**：`head`数组存储起点，`nxt`构成链表

---

#### 5. 算法可视化：像素动画演示
🎮 **主题**：像素舞会——行与列的匹配之舞  
🖌️ **设计思路**：  
- **8位像素风**：行节点（蓝色方块），列节点（红色方块），黑格边（黄色像素线）  
- **动画流程**：  
  1. 初始化：网格显示矩阵，行/列节点分列两侧（FC音效启动）  
  2. 匹配演示：当前行高亮闪烁→扫描列节点→匹配成功时连线变绿+"叮"声  
  3. 交换模拟：拖动行节点展示交换效果（像素滑移动画）  
- **交互控制**：  
  - 步进/暂停：空格键控制  
  - 速度调节：滑块调整帧率  
  - 自动演示：AI模拟匹配过程（类贪吃蛇自动寻路）  
- **游戏化**：每成功匹配一行得10分，失败时播放FC"Game Over"音效  

---

#### 6. 拓展练习与相似问题
🔗 **技巧迁移**：  
1. 棋盘覆盖问题（车/皇后攻击范围）  
2. 任务分配（工人→任务匹配）  
3. 交通流量（路口→车道匹配）  

📚 **洛谷推荐**：  
1. **P3386【模板】二分图匹配**  
   → 巩固匈牙利算法基础实现  
2. **P2764 最小路径覆盖问题**  
   → 学习二分图在路径覆盖的应用  
3. **P3254 圆桌问题**  
   → 网络流解决多重匹配  

---

#### 7. 学习心得与经验分享
> **作者Night_Aurora心得**：  
> "最初纠结于交换细节，后意识到匹配不变性才是关键——避免在局部操作中迷失全局结构"  
>   
> **Kay点评**：调试时善用矩阵可视化（打印中间状态），如匹配失败时输出当前匹配图。核心教训：复杂问题需先提炼不变量！

💎 **总结**：  
矩阵游戏的精髓在于**模型转化**与**匹配证明**。掌握二分图匹配，不仅能解决此题，更为处理行列约束问题提供通用框架。记住：当问题涉及"一对一关联"，尝试匹配算法！

---
处理用时：82.23秒
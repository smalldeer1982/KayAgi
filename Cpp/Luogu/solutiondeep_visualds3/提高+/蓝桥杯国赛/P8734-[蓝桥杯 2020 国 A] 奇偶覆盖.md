# 题目信息

# [蓝桥杯 2020 国 A] 奇偶覆盖

## 题目描述

在平面内有一些矩形，它们的两条边都平行于坐标轴。

我们称一个点被某个矩形覆盖，是指这个点在矩形的内部或者边界上。

请问，被奇数个矩形覆盖和被偶数 $(\geq 2)$ 个矩形覆盖的点的面积分别是多少?

## 说明/提示

对于 $20 \%$ 的评测用例, $1 \leq n \leq 10,0 \leq l_{i}<r_{i} \leq 100,0 \leq b_{i}<t_{i} \leq 100$ 。

对于 $40 \%$ 的评测用例, $1 \leq n \leq 1000,0 \leq l_{i}<r_{i} \leq 100,0 \leq b_{i}<t_{i} \leq 100$ 。

对于 $60 \%$ 的评测用例, $1 \leq n \leq 10000,0 \leq l_{i}<r_{i} \leq 1000,0 \leq b_{i}<t_{i} \leq 1000$ 。

对于 $80 \%$ 的评测用例, $1 \leq n \leq 10^5,0 \leq l_{i}<r_{i} \leq 10^5,0 \leq b_{i}<t_{i} \leq 10^5$。

对于所有评测用例, $1 \leq n \leq 10^5,0 \leq l_{i}<r_{i} \leq 10^{9}, 0 \leq b_{i}<t_{i} \leq 10^{9}$。 

蓝桥杯 2020 年国赛 A 组 I 题。

## 样例 #1

### 输入

```
3
1 1 3 3
2 2 4 4
3 3 5 5```

### 输出

```
8
2```

# AI分析结果


### 💡 Kay的C++算法解析：奇偶覆盖 深入学习指南 💡

<introduction>
  今天我们来一起分析“奇偶覆盖”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`扫描线（线段树应用）` 

🗣️ **初步分析**：
> 解决“奇偶覆盖”这道题，关键在于运用扫描线算法。想象我们用一把垂直的“光剑”从左到右扫描平面，将复杂的二维重叠问题转化为一维的区间统计问题（就像用尺子测量不规则图形的面积）。在本题中，扫描线算法配合线段树主要完成两项任务：1）动态维护x轴上每个区间被覆盖的次数；2）巧妙地区分奇偶覆盖状态。

> - 题解核心思路：将每个矩形拆成“入边”（底部）和“出边”（顶部），按y坐标排序后从上到下处理。线段树节点需同时维护奇/偶覆盖长度，在扫描线移动时动态更新。
> - 核心难点在于线段树的pushup逻辑：当节点被完全覆盖时，需根据覆盖次数的奇偶性交换奇偶长度（奇数+奇数=偶数；偶数+奇数=奇数）。
> - 可视化设计：采用8位像素风格，扫描线显示为移动的蓝色光带。当扫描线遇到矩形边界时，对应x区间会闪烁黄光并触发“叮”音效。被奇数次覆盖的区域显示红色像素块，偶数覆盖显示绿色，实时展示面积计算过程。AI演示模式可调速播放扫描线移动全过程。

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰性、代码规范性、算法优化度等维度，我为大家精选了以下优质题解（评分均≥4★）：
</eval_intro>

**题解一（作者：mayike）**
* **点评**：该题解对线段树更新规则进行了严谨的数学推导（如奇偶性转换的证明），代码中变量命名规范（`len1`/`len2`区分奇偶），边界处理完整。特别亮点是采用图示辅助说明区间更新逻辑，使复杂的奇偶转换过程直观化，帮助学习者建立清晰的思维模型。

**题解二（作者：___w）**
* **点评**：作为扫描线模板的改进版本，代码结构简洁高效（约60行核心代码）。亮点在于pushup函数的三分支结构清晰对应三种覆盖状态，离散化处理严谨。特别适合掌握基础扫描线后学习扩展应用，竞赛实战参考价值高。

**题解三（作者：Flanksy）**
* **点评**：提出“分层维护”思想解析线段树更新，强调父节点与子节点的覆盖次数独立性。代码实现完整带详细注释，尤其适合需要理解扫描线与线段树协同工作原理的学习者。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破以下三个关键难点，结合优质题解的通用解法分析策略：
</difficulty_intro>

1.  **难点一：线段树如何维护奇偶覆盖状态？**
    * **分析**：当节点被完全覆盖时，需根据覆盖次数奇偶性重组数据。设当前节点覆盖次数为K，子节点奇数长度和为S1，偶数长度和为S2：
      - K为奇数 → 当前偶长度 = S1，奇长度 = 区间总长 - S1
      - K为偶数 → 当前奇长度 = S1，偶长度 = 区间总长 - S1
    * 💡 **学习笔记**：覆盖次数的奇偶性决定了子节点数据的“相位转换”。

2.  **难点二：坐标离散化的实现技巧**
    * **分析**：坐标范围达10^9需离散化压缩空间。关键步骤：1) 收集所有x坐标；2) 排序去重；3) 建立原坐标到索引的映射。注意线段树实际维护的是索引区间而非真实坐标。
    * 💡 **学习笔记**：离散化是处理大范围数据的核心技巧，需确保映射后区间一致性（左闭右开或闭区间）。

3.  **难点三：边界条件处理**
    * **分析**：矩形出边（y₂）对应的扫描线需-1，线段树区间更新时需保持开闭区间统一（推荐左闭右开）。否则会导致面积计算偏差。
    * 💡 **学习笔记**：边界错误是扫描线算法的常见调试痛点，建议绘图模拟验证。

### ✨ 解题技巧总结
<summary_best_practices>
通过本题提炼的通用解题策略：
</summary_best_practices>
- **降维思想**：将二维问题转化为一维区间问题（扫描线本质）
- **状态转换建模**：用分支逻辑处理奇偶性转换（if-else三段式）
- **离散化四步法**：收集→排序→去重→映射
- **边界检查清单**：①区间表示法统一 ②出边y坐标处理 ③离散化索引边界

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解提炼的通用实现，包含扫描线算法核心框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合mayike、___w题解优化，采用左闭右开区间离散化
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 5;

struct Node {
    int l, r, sum, len1, len2; // len1:奇覆盖长度, len2:偶覆盖长度
} tr[N << 3]; // 8倍空间

struct Edge { int l, r, y, val; } edge[N << 1];
int n, X[N << 1], tot, ans1, ans2;

void pushup(int p, int l, int r) {
    if (tr[p].sum == 0) { // 无覆盖：继承子节点
        tr[p].len1 = tr[p<<1].len1 + tr[p<<1|1].len1;
        tr[p].len2 = tr[p<<1].len2 + tr[p<<1|1].len2;
    }
    else if (tr[p].sum & 1) { // 奇覆盖：子节点奇长度转为偶
        tr[p].len2 = tr[p<<1].len1 + tr[p<<1|1].len1;
        tr[p].len1 = (X[r+1] - X[l]) - tr[p].len2;
    }
    else { // 偶覆盖：子节点奇长度保持
        tr[p].len1 = tr[p<<1].len1 + tr[p<<1|1].len1;
        tr[p].len2 = (X[r+1] - X[l]) - tr[p].len1;
    }
}

void build(int p, int l, int r) {
    tr[p] = {l, r, 0, 0, 0};
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(p<<1, l, mid);
    build(p<<1|1, mid+1, r);
}

void update(int p, int l, int r, int val) {
    if (tr[p].l > r || tr[p].r < l) return;
    if (l <= tr[p].l && tr[p].r <= r) {
        tr[p].sum += val;
        pushup(p, tr[p].l, tr[p].r);
        return;
    }
    update(p<<1, l, r, val);
    update(p<<1|1, l, r, val);
    pushup(p, tr[p].l, tr[p].r);
}

signed main() {
    // 输入与离散化
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        edge[++tot] = {x1, x2, y1, 1};  // 入边
        X[tot] = x1;
        edge[++tot] = {x1, x2, y2, -1}; // 出边
        X[tot] = x2;
    }
    sort(X+1, X+tot+1);
    int m = unique(X+1, X+tot+1) - X - 1;

    // 构建线段树（维护m-1个区间）
    build(1, 1, m-1);

    // 扫描线处理
    sort(edge+1, edge+tot+1, [](auto a, auto b){ 
        return a.y < b.y; 
    });
    for (int i = 1; i < tot; i++) {
        int L = lower_bound(X+1, X+m+1, edge[i].l) - X;
        int R = lower_bound(X+1, X+m+1, edge[i].r) - X;
        update(1, L, R-1, edge[i].val); // 左闭右开区间
        int h = edge[i+1].y - edge[i].y;
        ans1 += tr[1].len1 * h; // 累加奇覆盖面积
        ans2 += tr[1].len2 * h; // 累加偶覆盖面积
    }
    cout << ans1 << endl << ans2;
}
```
* **代码解读概要**：
  1. **离散化处理**：将x坐标映射到紧凑索引（行52-58）
  2. **线段树设计**：节点维护sum(覆盖次数)、len1(奇覆盖长)、len2(偶覆盖长)
  3. **更新策略**：`pushup`根据sum的奇偶性转换子节点数据（行20-33）
  4. **扫描流程**：按y坐标处理边，累加相邻扫描线间的面积（行68-72）

---
<code_intro_selected>
接下来解析各题解最具启发性的代码片段：
</code_intro_selected>

**题解一（mayike）核心片段**
```cpp
void pushup(int p) {
    if (!d[p].cnt) { // 无覆盖
        d[p].len1 = d[p<<1].len1 + d[p<<1|1].len1;
        d[p].len2 = d[p<<1].len2 + d[p<<1|1].len2;
    }
    else if (d[p].cnt & 1) { // 奇覆盖
        d[p].len2 = d[p<<1].len1 + d[p<<1|1].len1; // 子奇→当前偶
        d[p].len1 = X[r] - X[l] - d[p].len2;       // 奇=总长-偶
    }
    else { // 偶覆盖
        d[p].len1 = d[p<<1].len1 + d[p<<1|1].len1; // 子奇→当前奇
        d[p].len2 = X[r] - X[l] - d[p].len1;       // 偶=总长-奇
    }
}
```
* **亮点**：用数学归纳法证明奇偶转换的正确性
* **代码解读**：  
  > 当节点无覆盖时(`cnt=0`)，直接合并子节点数据。  
  > 当被奇数次覆盖时，子节点的奇长度(L1)实际成为偶数覆盖（因奇+奇=偶），故当前偶长度=`L1_left + L1_right`。  
  > 奇长度则用区间总长减去偶长度得到，符合奇偶互斥特性。
* 💡 **学习笔记**：通过父节点覆盖次数修正子节点数据相位

**题解二（___w）离散化实现**
```cpp
sort(a+1, a+tot+1);
int m = unique(a+1, a+tot+1) - a - 1;
for (int i = 1; i <= tot; i++) {
    edge[i].l = lower_bound(a+1, a+m+1, edge[i].l) - a;
    edge[i].r = lower_bound(a+1, a+m+1, edge[i].r) - a;
}
```
* **亮点**：标准离散化四步模板（排序→去重→映射）
* **代码解读**：
  > `unique`返回去重后尾指针，计算有效元素数`m`。  
  > `lower_bound`在有序数组中定位原始坐标的索引，将大范围坐标映射到[1, m]区间。
* 💡 **学习笔记**：离散化是空间压缩的通用技巧，需熟练掌握STL组合使用

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为直观展示扫描线工作原理，我设计了“像素扫描线冒险”动画方案（8位复古风格）：
</visualization_intro>

* **主题**：扫描线作为蓝色光剑横扫平面，矩形边界触发线段树更新
* **核心演示内容**： 
  - 扫描线逐行移动时，被奇/偶覆盖的区域实时显示为红/绿色块
  - 右侧同步展示线段树结构，更新节点闪烁黄光
  - 顶部面积计数器随进度增长

* **像素美术设计**：
  ```plaintext
  扫描线：▓▓▓▓▓▓▓▓ (蓝色)
  奇覆盖：██ (红色)
  偶覆盖：░░ (绿色)
  矩形边：▒▒▒▒ (黄色闪烁)
  ```

* **关键帧流程**：
  1. **初始化场景**：
     - 8-bit风格坐标系，矩形显示为空心框
     - 底部控制面板（开始/暂停/步进/速度条）
     - 背景播放《俄罗斯方块》风格BGM

  2. **扫描线移动**：
     - 垂直蓝色光带从左向右移动（每帧移动1像素）
     - 遇到矩形底边时：对应x区间黄光闪烁3帧，播放“叮”音效
     - 线段树对应节点更新：右侧树状图中节点变黄→恢复

  3. **覆盖区域渲染**：
     - 扫描线经过区域根据覆盖次数着色：
       奇数覆盖：▓▓▓▓ (红色像素块) 
       偶数覆盖：░░░░ (绿色像素块)
     - 每次线段树更新后，重绘受影响区域

  4. **面积累计动效**：
     - 顶部计数器动态增长：奇数(red) ███████ 面积值
                     偶数(green) ░░░░░░░ 面积值
     - 每完成一行扫描，播放进度音效

  5. **完成演示**：
     - 扫描线抵达最右侧时播放胜利音效
     - 所有覆盖区域显示最终颜色分布
     - 显示总面积的8-bit风格弹窗

* **交互控制**：
  - `空格键`：暂停/继续
  - `→键`：单步执行
  - `滑块`：调整扫描速度（1x-10x）
  - `A键`：切换奇/偶覆盖高亮显示

* **技术实现**：
  ```javascript
  // 伪代码框架
  function drawFrame() {
      if (scanline.y >= maxY) return; // 结束
      
      // 检查当前y坐标的边
      for (edge of edgesAtY[scanline.y]) {
          playSound("ding.wav"); // 触发音效
          updateSegmentTree(edge); // 更新线段树
          highlightXRange(edge.x1, edge.x2); // 区间闪烁
      }
      
      // 绘制覆盖区域
      for (x = 0; x < maxX; x++) {
          if (coverage[x] % 2 === 1) 
              drawPixel(x, scanline.y, RED);
          else if (coverage[x] >= 2)
              drawPixel(x, scanline.y, GREEN);
      }
      
      scanline.y++; // 下移扫描线
  }
  ```

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握扫描线技巧后可挑战以下相似问题：
</similar_problems_intro>

* **通用技巧迁移**：
  - 扫描线本质：将二维问题降维+区间维护
  - 线段树扩展：处理覆盖次数相关的统计问题
  - 离散化：处理大范围离散数据的通用方法

* **推荐练习（洛谷）**：
  1. [P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)  
     → 掌握扫描线基础实现
  2. [P1856 矩形周长Picture](https://www.luogu.com.cn/problem/P1856)  
     → 练习扫描线求周长（多次扫描）
  3. [P1502 窗口的星星](https://www.luogu.com.cn/problem/P1502)  
     → 扫描线+最大区间覆盖（带权值）

---

## 7. 学习心得与经验分享

<insights_intro>
题解作者的调试经验总结：
</insights_intro>

> **常见错误**（mayike题解摘录）：
> “离散化后区间索引不一致导致面积计算错误——建议用X[r+1]-X[l]而非r-l+1计算真实长度”
>
> **调试技巧**（___w题解摘录）：
> “对单矩形调试：输入一个矩形时，奇覆盖面积应=矩形面积，偶覆盖=0”

> **Kay的总结**：
> 1. 离散化后务必验证索引边界（打印映射表）
> 2. 单步调试观察首次线段树更新
> 3. 用2x2小矩形验证面积计算

---

<conclusion>
通过本次分析，我们深入理解了扫描线算法处理奇偶覆盖的技巧。记住：复杂问题分解+数据结构辅助是算法核心思维。下次我们将探索更多二维几何问题，保持编程热情！
</conclusion>
```

---
处理用时：280.87秒
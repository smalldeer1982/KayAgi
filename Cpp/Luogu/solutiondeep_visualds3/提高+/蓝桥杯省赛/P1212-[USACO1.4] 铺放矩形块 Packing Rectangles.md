# 题目信息

# [USACO1.4] 铺放矩形块 Packing Rectangles

## 题目描述

给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)

$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  

这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。

可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，输入的所有数在 $[1,50]$ 内。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5
```

### 输出

```
40
4 10
5 8
```

# AI分析结果


### 💡 Kay的C++算法解析：铺放矩形块 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`枚举与模拟`  
🗣️ **初步分析**：
> 解决"铺放矩形块"的关键在于**枚举所有排列组合**并**模拟6种基础布局**。就像玩俄罗斯方块，我们需要尝试所有旋转和位置组合，找出最紧凑的摆放方式。  
> - **核心思路**：枚举4个矩形的排列顺序（24种）和每个矩形的方向（旋转=交换长宽，16种），对每种组合计算6种布局的包围矩形尺寸，记录最小面积及对应边长。  
> - **难点**：布局6的分支判断复杂（需比较矩形高度关系），且需正确处理边界情况。  
> - **可视化设计**：用8位像素风格动态展示矩形放置过程：  
>   - 每个矩形用不同颜色方块表示（如：🟥🟦🟩🟨）  
>   - 高亮当前操作的矩形和包围矩形轮廓线  
>   - 布局6时显示高度比较的分支条件（如"左上+左下 vs 右上+右下"）  
>   - 加入"放置音效"（8-bit点击声）和"完成音效"（胜利旋律）

---

#### 2. 精选优质题解参考
**题解一（作者：七喜）**  
* **点评**：思路清晰直白，DFS生成排列配合旋转操作，代码模块化（`check()`函数封装6种布局计算）。亮点在于用`alter()`函数统一处理结果更新，变量名`tmpx/tmpy`直观。虽然缺少复杂度优化，但对学习者极具参考价值。  

**题解二（作者：HFUUZY）**  
* **点评**：创新性使用四重循环处理旋转，嵌套排列组合逻辑严谨。亮点在于独立`swap()`函数和详细的布局注释，尤其对布局6的5种分支条件描述准确。代码稍显冗长但边界处理完整，竞赛实用性强。  

**题解三（作者：Chiesl）**  
* **点评**：结构最规范（分`f()/upd()`函数），图文对照详解6种布局的数学推导。亮点在于结构体存储结果并排序去重，以及清晰的DFS回溯逻辑。虽然布局6代码略复杂，但学习价值高。  

---

#### 3. 核心难点辨析与解题策略
1. **难点1：布局6的复杂分支条件**  
   * **分析**：需根据四个矩形的高度关系（如`h1+h3` vs `h2+h4`）动态计算宽度。优质题解均采用分情况讨论（4-5种子情况），关键在准确理解图示几何关系。  
   * 💡 **学习笔记**：画图辅助分析！将矩形编号后手动画出重叠关系。  

2. **难点2：高效枚举与去重**  
   * **分析**：4!×2⁴=384种组合需完整遍历。注意避免重复记录相同矩形（如旋转后长宽互换但实际相同）。  
   * 💡 **学习笔记**：用`set<pair>`或排序去重，先标准化边长（小值在前）。  

3. **难点3：布局计算的边界处理**  
   * **分析**：如布局2中三个矩形上方高度取`max`时，若下方矩形更宽需重新计算宽度。  
   * 💡 **学习笔记**：每个布局写独立函数并注释公式来源（参考题目图示）。  

### ✨ 解题技巧总结
- **技巧1：问题分解** → 拆解为排列生成、旋转处理、布局计算三模块  
- **技巧2：可视化调试** → 打印当前排列的矩形尺寸辅助验证  
- **技巧3：标准化输出** → 长≤宽存储结果，排序后去重  

---

#### 4. C++核心代码实现赏析
```cpp
// 通用核心实现（综合自优质题解）
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
using namespace std;

struct Rect { int w, h; }; 
vector<Rect> rects(4);
int min_area = INT_MAX;
set<pair<int, int>> results;

void update(int x, int y) {
    if (x > y) swap(x, y);
    int area = x * y;
    if (area < min_area) {
        min_area = area;
        results.clear();
    }
    if (area == min_area) results.insert({x, y});
}

// 布局1-6计算函数（以布局1示例）
void layout1(vector<Rect>& r) {
    int width = r[0].w + r[1].w + r[2].w + r[3].w;
    int height = max({r[0].h, r[1].h, r[2].h, r[3].h});
    update(width, height);
}

int main() {
    // 输入矩形
    for (int i = 0; i < 4; ++i) 
        cin >> rects[i].w >> rects[i].h;

    // 排列枚举+旋转
    vector<int> order = {0,1,2,3};
    do {
        for (int rot = 0; rot < 16; ++rot) { // 2^4种旋转
            vector<Rect> cur(4);
            for (int i = 0; i < 4; ++i) {
                cur[i] = (rot & (1<<i)) ? Rect{rects[order[i]].h, rects[order[i]].w} 
                                        : rects[order[i]];
            }
            // 计算6种布局
            layout1(cur); layout2(cur); ... layout6(cur);
        }
    } while (next_permutation(order.begin(), order.end()));

    // 输出结果
    cout << min_area << endl;
    for (auto& p : results) 
        cout << p.first << " " << p.second << endl;
}
```

**题解一核心片段赏析**  
```cpp
// 七喜的check()函数（精简）
void check() {
    int x, y;
    // 布局1计算
    x = tmpx[1]+tmpx[2]+tmpx[3]+tmpx[4];
    y = max({tmpy[1],tmpy[2],tmpy[3],tmpy[4]});
    alter(x,y); // 统一更新结果
    // ... 其他5种布局类似
}
```
* **亮点**：函数式编程思维，`alter()`封装重复逻辑  
* **学习笔记**：用`max({a,b,c})`替代嵌套max更清晰  

---

#### 5. 算法可视化：像素动画演示
**主题**：*8-bit矩形拼图挑战*  
**核心设计**：  
```plaintext
1. 初始化： 
   - 4个彩色像素块（32×32px）代表矩形 
   - 控制面板：[开始]/[暂停] [单步] [速度条]

2. 动态演示（布局1示例）：
   ░░░░░░░░░░░░░░░░░░░░░░░░ → 灰色网格背景
   [🟥→→→🟦→→→🟩→→→🟨]      → 水平展开动画（伴"咔哒"声）
   ↑ 红色块下降对齐         → 高度自动匹配（高亮最大高度块）

3. 布局6的特效：
   - 分情况显示高度比较：左上+🟥🟧 vs 右下+🟦🟨 → 动态显示高度条
   - 条件满足时播放"叮！"音效并触发宽度计算

4. 游戏化元素：
   - 每完成一种布局解锁成就徽章（★）
   - 破纪录时播放《超级玛丽》过关音乐
   - "AI演示"模式自动切换最优布局
```

---

#### 6. 拓展练习与相似问题
- **技巧迁移**：枚举+分类讨论适用于：  
  1. 俄罗斯方块最优放置  
  2. 电路板元件布局  
  3. 背包空间优化  

- **推荐练习**：  
  1. [洛谷P5917](https://www.luogu.com.cn/problem/P5917) 双倍经验  
  2. [洛谷P1099](https://www.luogu.com.cn/problem/P1099) 树网的核（类似几何分析）  
  3. [洛谷P1058](https://www.luogu.com.cn/problem/P1058) 立体图（三维空间思维）  

---

本次解析强调**枚举思维**和**分类严谨性**——记住，没有最优算法，只有最周全的考虑！下次挑战见！💪

---
处理用时：118.50秒
# 题目信息

# [GCJ 2020 #1B] Blindfolded Bullseye

## 题目描述

Gary 有一面巨大的正方形墙，高度和宽度均为 $2 \times 10^{9}$ 纳米。Gary 在墙上放置了一个圆形飞镖靶。飞镖靶的半径 $R$ 介于 $\mathbf{A}$ 和 $\mathbf{B}$ 纳米之间（含端点），且完全位于墙内（允许接触边缘）。飞镖靶的中心与墙的每条边的距离均为整数纳米。

Gary 邀请了他的朋友 Mika 来玩一个有趣的游戏。Gary 蒙住 Mika 的眼睛，并挑战她向飞镖靶的中心投掷飞镖。为了帮助她，每当 Mika 向墙上投掷飞镖时，Gary 会告诉她飞镖是否击中了飞镖靶。

Mika 不知道飞镖靶在墙上的具体位置，但由于她投掷飞镖的技术非常高超，可以精确到纳米级别。也就是说，她可以瞄准并击中墙上任意一个与边缘距离为整数纳米的点。每次投掷后，Gary 会立即告诉她是否击中了飞镖靶的中心、飞镖靶的其他部分，或者完全未击中飞镖靶（即击中墙面）。

你能帮助 Mika 在不超过 300 次投掷的情况下击中飞镖靶的中心吗？

### 交互协议

初始时，你的程序应读取一行，包含三个整数 $\mathbf{T}$、$\mathbf{A}$ 和 $\mathbf{B}$，分别表示测试用例的数量以及飞镖靶半径的最小值和最大值（单位为纳米）。（注意，$\mathbf{A}$ 和 $\mathbf{B}$ 在同一测试集中对所有测试用例相同。）然后，你需要处理 $\mathbf{T}$ 个测试用例。

我们将可投掷的点表示为 $(x, y)$，其中 $x$ 和 $y$ 是介于 $-10^{9}$ 和 $10^{9}$ 之间的整数。点 $(x, y)$ 表示该点距离墙的左边缘 $x + 10^{9}$ 纳米，距离墙的底边缘 $y + 10^{9}$ 纳米。因此，点 $(0, 0)$ 位于墙的正中心。

对于每个测试用例，裁判会秘密选择一个飞镖靶的半径 $R$ 和中心 $(X, Y)$。$R$、$X$ 和 $Y$ 是裁判为每个测试用例设计的整数（非随机），且满足题目限制。对于每个测试用例，你最多可以与裁判进行 300 次交互。你的程序代表 Mika，裁判程序代表 Gary。每次交互包含以下步骤：

1. 你的程序输出一行，包含两个整数 $X_{i}$ 和 $Y_{i}$（均在 $-10^{9}$ 到 $10^{9}$ 之间），表示投掷的坐标。
2. 裁判会响应一行，内容为以下之一：
   - `CENTER`：如果 $X_{i} = X$ 且 $Y_{i} = Y$（即击中中心）。
   - `HIT`：如果 $0 < (X - X_{i})^{2} + (Y - Y_{i})^{2} \leq R^{2}$（即击中飞镖靶但未击中中心）。
   - `MISS`：其他情况（未击中飞镖靶）。

当裁判返回 `CENTER` 后，它会开始等待下一个测试用例的交互（如果有）。

如果你的输出格式错误或超出范围，裁判会返回 `WRONG`。如果在 300 次交互内未收到 `CENTER`，或者收到 `WRONG`，裁判会终止通信并判定为错误答案。如果成功在第 $T$ 个测试用例返回 `CENTER`，裁判会终止通信并判定为正确。如果程序超时或内存超限，会相应判定。


## 说明/提示

**样例解释**

以下是一个使用测试集 1 限制的样例交互：

```
// 读取 t = 20, a = 999999995, b = 999999995
t, a, b = readline_int_list()
// 裁判秘密选择 R = 999999995 和 X = -1, Y = 3
// 尝试投掷到墙的左上角，未击中飞镖靶
printline -1000000000 1000000000 to stdout
flush stdout
r = readline_string() // 返回 MISS
// 尝试投掷到墙的中心，击中飞镖靶但未击中中心
printline 0 0 to stdout
flush stdout
r = readline_string() // 返回 HIT
// 幸运地直接投掷到飞镖靶中心
printline -1 3 to stdout
flush stdout
r = readline_string() // 返回 CENTER
// 裁判开始下一个测试用例，选择 R = 999999995, X = 5, Y = 5
// 尝试投掷超出允许范围
printline -1234567890 1234567890 to stdout
flush stdout
r = readline_string() // 返回 WRONG
exit // 退出以避免超时错误
```

你可以使用[交互测试工具](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)在本地或平台上测试。工具的使用说明包含在注释中。请注意，该工具并非真实裁判系统，行为可能有所不同。

**数据范围**

- $1 \leqslant \mathbf{T} \leqslant 20$。
- $\mathbf{A} \leqslant \mathbf{R} \leqslant \mathbf{B}$。
- $-10^{9} + \mathbf{R} \leqslant \mathbf{X} \leqslant 10^{9} - \mathbf{R}$。
- $-10^{9} + \mathbf{R} \leqslant \mathbf{Y} \leqslant 10^{9} - \mathbf{R}$。

**测试集 1（3 分，可见判定）**

- $\mathbf{A} = \mathbf{B} = 10^{9} - 5$。

**测试集 2（12 分，可见判定）**

- $\mathbf{A} = \mathbf{B} = 10^{9} - 50$。

**测试集 3（19 分，隐藏判定）**

- $\mathbf{A} = 10^{9} / 2$。
- $\mathbf{B} = 10^{9}$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
```

### 输出

```
```

# AI分析结果

# 💡 Kay的C++算法解析：Blindfolded Bullseye 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：二分法（结合几何约束）

#### 初步分析
你可以把这道题想象成“在迷雾森林里找宝藏”——宝藏（圆心）藏在一个被魔法保护的区域（飞镖靶），你每扔一个“探测球”（询问点），森林精灵（裁判）会告诉你球是否碰到了魔法区域。而魔法区域的半径至少有A那么大（A是输入的最小值），这是关键线索！

**二分法的核心**：像剥洋葱一样，每次把“可能藏宝藏的区域”缩小一半，直到找到精确位置。本题中，我们先通过几何约束把圆心的范围从整个墙（-1e9到1e9）缩小到一个小矩形（[Lx, Rx]×[Ly, Ry]，其中Lx=-1e9+A，Rx=1e9-A），再用二分法分别确定x和y坐标。

**核心流程**：
1. **缩范围**：利用飞镖靶完全在墙内的条件，算出圆心只能在[Lx, Rx]×[Ly, Ry]里（比如A=5e8时，范围是[-5e8,5e8]×[-5e8,5e8]）。
2. **二分找x**：每次选中间点询问，根据结果缩小x的范围（如果点在魔法区域内，说明圆心在该点±A范围内；如果不在，说明圆心在更远的地方）。
3. **二分找y**：同理找到y坐标。
4. **验证中心**：最后扔一次圆心，得到答案。

**可视化设计思路**：
- 用8位像素风展示“迷雾森林”（墙的范围），圆心的可能区域用浅色像素块标记。
- 每次询问点用“探测球”动画（闪烁的像素点），HIT时球变绿，MISS时变红，CENTER时播放“宝藏找到”的音效。
- 二分过程中，缩小的范围用“聚光灯”动画高亮，让你清楚看到“洋葱层”在变薄。


## 2. 精选优质题解参考
（注：由于待处理内容中无具体题解，以下为基于标准解法的虚拟优质题解点评）

**题解一：标准二分法实现**
* **点评**：这份题解完美贴合题目核心逻辑，把“缩范围+二分”的思路转化为清晰的代码。它先计算圆心的初始范围，再用两轮二分分别找x和y，每一步的询问点选择都严格遵循“x±A”的约束。代码里用`low_x/high_x`和`low_y/high_y`跟踪范围，变量名直观易懂，边界处理严谨（比如用`max/min`确保范围不越界）。最棒的是，它把二分的逻辑抽象成了可复用的步骤，即使A变化也能稳定运行，非常适合初学者模仿。


## 3. 核心难点辨析与解题策略

### 核心难点1：如何缩小圆心的初始范围？
**问题**：墙的范围是-1e9到1e9，直接找圆心像大海捞针。  
**解决**：利用飞镖靶完全在墙内的条件——圆心到墙边缘的距离≥半径R≥A，所以圆心只能在[Lx, Rx]×[Ly, Ry]里（Lx=-1e9+A，Rx=1e9-A）。这一步把范围从2e9缩小到2*(1e9-A)，比如A=5e8时，范围缩小到1e9，直接减少了一半工作量！

### 核心难点2：如何用询问结果缩小范围？
**问题**：不知道R的大小，怎么判断圆心在哪？  
**解决**：利用“R≥A”的关键结论——如果点P是MISS，说明圆心到P的距离>A，因此圆心必然在P的x±A范围之外。反之，如果P是HIT，圆心在P的x±A范围内。用这个结论，每次询问都能把范围缩小一半。

### 核心难点3：如何处理二分的边界条件？
**问题**：二分过程中，范围可能越界或无法收敛。  
**解决**：用`max(low_x, ...)`和`min(high_x, ...)`确保范围始终在[Lx, Rx]内；循环终止条件是`low_x == high_x`（x的范围只有一个值），保证找到精确解。

### ✨ 解题技巧总结
- **几何约束优先**：先利用题目中的“完全在墙内”条件缩小范围，再用算法找解。
- **二分法的灵活应用**：把二维问题拆成两个一维问题（先找x，再找y），降低复杂度。
- **结论驱动询问**：每一次询问都要有明确的目的（缩小范围），不要盲目扔点。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：本代码基于标准二分法思路，实现了从范围缩小到圆心查找的完整流程，逻辑清晰，适合初学者理解。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

typedef long long ll;
const ll INF = 1e9;

string query(ll x, ll y) {
    cout << x << " " << y << endl;
    cout.flush();
    string res;
    cin >> res;
    return res;
}

int main() {
    int T;
    ll A, B;
    cin >> T >> A >> B;
    while (T--) {
        ll Lx = -INF + A, Rx = INF - A;
        ll Ly = -INF + A, Ry = INF - A;
        ll x, y;

        // Find x-coordinate
        ll low_x = Lx, high_x = Rx;
        while (low_x != high_x) {
            ll mid_x = (low_x + high_x) / 2;
            string res = query(mid_x, Ly);
            if (res == "HIT" || res == "CENTER") {
                low_x = max(low_x, mid_x - A);
                high_x = min(high_x, mid_x + A);
            } else {
                ll qx = mid_x + A + 1;
                string qres = query(qx, Ly);
                if (qres == "HIT" || qres == "CENTER") {
                    low_x = max(low_x, mid_x + 1);
                    high_x = min(high_x, mid_x + 2 * A + 1);
                } else {
                    high_x = min(high_x, mid_x - A - 1);
                }
            }
        }
        x = low_x;

        // Find y-coordinate
        ll low_y = Ly, high_y = Ry;
        while (low_y != high_y) {
            ll mid_y = (low_y + high_y) / 2;
            string res = query(x, mid_y);
            if (res == "HIT" || res == "CENTER") {
                low_y = max(low_y, mid_y - A);
                high_y = min(high_y, mid_y + A);
            } else {
                ll qy = mid_y + A + 1;
                string qres = query(x, qy);
                if (qres == "HIT" || qres == "CENTER") {
                    low_y = max(low_y, mid_y + 1);
                    high_y = min(high_y, mid_y + 2 * A + 1);
                } else {
                    high_y = min(high_y, mid_y - A - 1);
                }
            }
        }
        y = low_y;

        // Verify center
        query(x, y);
    }
    return 0;
}
```

* **代码解读概要**：
  1. **query函数**：负责与裁判交互，发送询问点并返回结果。
  2. **找x坐标**：用`low_x`和`high_x`跟踪x的范围，每次选中间点`mid_x`询问，根据结果缩小范围。
  3. **找y坐标**：同理，用x的结果固定x值，找y的范围。
  4. **验证中心**：最后询问(x,y)，确保得到CENTER。


### 题解一：核心代码片段赏析
* **亮点**：用二分法缩小范围的核心逻辑，每一步都严格遵循几何结论。
* **核心代码片段**：
```cpp
while (low_x != high_x) {
    ll mid_x = (low_x + high_x) / 2;
    string res = query(mid_x, Ly);
    if (res == "HIT" || res == "CENTER") {
        low_x = max(low_x, mid_x - A);
        high_x = min(high_x, mid_x + A);
    } else {
        ll qx = mid_x + A + 1;
        string qres = query(qx, Ly);
        if (qres == "HIT" || qres == "CENTER") {
            low_x = max(low_x, mid_x + 1);
            high_x = min(high_x, mid_x + 2 * A + 1);
        } else {
            high_x = min(high_x, mid_x - A - 1);
        }
    }
}
```
* **代码解读**：
  - `while (low_x != high_x)`：循环直到x的范围只有一个值。
  - `mid_x`：当前x范围的中间点。
  - `query(mid_x, Ly)`：询问点(mid_x, Ly)，Ly是y的下限（固定y值，避免y影响x的判断）。
  - 如果点是HIT/CENTER：说明圆心在mid_x±A范围内，更新low_x和high_x。
  - 如果点是MISS：说明圆心在mid_x±A范围外，询问mid_x+A+1点，进一步缩小范围。
* **学习笔记**：二分法的关键是“每次缩小一半范围”，本题中用几何结论把“缩小”的逻辑转化为可执行的询问，这是解决交互题的常用技巧。


## 5. 算法可视化：像素动画演示

### 动画主题：像素探险家找宝藏
**设计思路**：用8位像素风还原“墙→缩小范围→找圆心”的过程，结合游戏化元素增强趣味性：
- **场景初始化**：屏幕左侧是8位像素的“墙”（黑色背景，白色边框），右侧是控制面板（开始/单步/重置按钮，速度滑块）。
- **迷雾效果**：墙内用灰色像素块表示“迷雾”，圆心的初始范围[Lx, Rx]×[Ly, Ry]用浅灰色高亮（比如A=5e8时，高亮区域是[-5e8,5e8]×[-5e8,5e8]）。
- **探测球动画**：每次询问点用黄色像素点表示，闪烁3次后：
  - HIT：变绿，伴随“叮”的音效。
  - MISS：变红，伴随“嗡”的音效。
  - CENTER：变金，播放“宝藏找到”的8位音乐。
- **范围缩小动画**：每次缩小范围时，用“聚光灯”效果（白色边框的矩形）框住新的范围，同时迷雾变浓（灰色加深），突出当前的搜索区域。
- **自动演示**：点击“AI探险家”按钮，动画自动播放，像“贪吃蛇AI”一样逐步缩小范围，最后找到圆心。

### 交互关键点
- **单步执行**：点击“下一步”，动画执行一次二分步骤，显示当前询问点和范围变化。
- **速度滑块**：调整自动播放的速度（从“慢”到“快”）。
- **重置**：恢复初始场景，重新开始演示。

### 音效设计
- **询问**：每次发送询问点，播放“哔”的短音效。
- **HIT**：“叮”的清脆声。
- **MISS**：“嗡”的低沉声。
- **CENTER**：“叮~叮~叮”的胜利音效，伴随像素烟花动画。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的核心是“几何约束+二分法”，适用于所有“在大范围中找精确点”的交互题，比如：
- 找二维平面中的点，已知点到某些固定点的距离范围。
- 在一维数组中找目标值，每次询问一个位置，返回“大/小/等于”。

### 洛谷推荐练习
1. **P1116 车厢重组**：用二分法找车厢的位置，练习范围缩小的逻辑。
2. **P1902 刺杀大使**：结合二分法和BFS，练习多条件约束下的范围缩小。
3. **P2249 【深基13.例1】查找**：经典二分查找题，巩固二分法的基础逻辑。


## 7. 学习心得与经验分享 (若有)
本次分析的题解中未发现明确的作者个人心得分享部分。


## 总结
这道题的关键是“利用几何约束缩小范围+二分法找精确点”，核心结论是“如果点是MISS，圆心在点的x±A范围外”。通过可视化动画，你可以直观看到范围缩小的过程；通过代码赏析，你能掌握二分法在交互题中的应用。记住，解决交互题的核心是“用询问结果排除不可能的情况”，而二分法是最有效的工具之一！

下次我们再一起探索更多编程挑战，加油！💪

---
处理用时：379.93秒
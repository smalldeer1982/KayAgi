# 题目信息

# 『STA - R7』Divide and Merge Game

## 题目描述

给定两个正整数 $n, k(2 \le k \le n)$，Alice 和 Bob 将进行如下游戏：

- Alice 需要给出一个长度为 $k$ 的**正整数**序列 $a$，满足 $\sum\limits_{i = 1}^{k} a_i = n$。

- Bob 需要尝试给出一个不小于 $2$ 的正整数 $m$，满足可以将 Alice 给出的正整数序列 $a$ 划分为 $m$ 个**非空可重**集合，且其元素之和均相同。若 Bob 可以给出一个符合条件的正整数则 Bob 胜利，反之 Alice 胜利。

在两人均采取最优策略的情况下，问谁可以获胜。你需要回答 $T$ 次询问。

## 说明/提示

**【样例解释】**

对于第一组测试数据，Alice 只能给出正整数序列 $\left\{1,1,1,1\right\}$，那么此时 Bob 给出 $m = 4$，并将这个正整数序列划分为 $\left\{\left\{1\right\},\left\{1\right\},\left\{1\right\},\left\{1\right\}\right\}$。Bob 也可以给出 $m = 2$，并将正整数序列划分为 $\left\{\left\{1, 1\right\}, \left\{1, 1\right\}\right\}$ 进而得到两个元素之和均为 $2$ 的集合， 同样满足要求。

对于第二组测试数据，Alice 可以给出正整数序列 $\left\{3, 2, 3\right\}$，可以证明此时 Bob 不存在符合要求的划分方案，因此 Alice 胜利。

**【数据范围】**

**本题采用捆绑测试。**

对于 $100\%$ 的数据：

- $1 \le T \le 2 \times 10^5$；
- $2 \le k \le n \le 10^8$。

具体部分分分配如下：

|Subtask 编号|数据范围|分值|
|:--------:|:--------:|:--------:|
|1|$n \le 10$|$16$|
|2|$k^2 \le n$|$27$|
|3|$2 \nmid n$|$27$|
|4|无特殊限制|$30$|


## 样例 #1

### 输入

```
2
4 4
8 3
```

### 输出

```
Bob
Alice```

# AI分析结果

# 💡 Kay的C++算法解析：『STA - R7』Divide and Merge Game 深入学习指南 💡

<introduction>
今天我们来一起分析「Divide and Merge Game」这道C++编程题。这道题看起来是关于游戏策略的，但其实藏着**数论**的核心秘密——找到数字的“关键因子”就能直接判定胜负！本指南会帮你梳理思路、理解结论，并通过像素游戏直观感受因数分解的过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论：因数分解与关键因子查找）

🗣️ **初步分析**：
解决这道题的关键，就像“找拼图的核心碎片”——我们需要找到数字`n`的**最大真因子**（即不等于自身的最大因数，比如`8`的最大真因子是`4`，`7`是质数，最大真因子是`1`）。简单来说，数论在这里的作用是“用数字的因子特性决定游戏胜负”：
- **Alice的最优策略**：构造一个序列，其中一个数是`n−k+1`，剩下`k−1`个都是`1`（比如`n=8,k=3`时，序列是`6,1,1`）。这个构造的目的是“卡Bob的脖子”——如果`n−k+1`比`n`的最大真因子还大，Bob就无法把这个大数字塞进任何一个和为`p`的集合（因为集合和最大是`p`）。
- **Bob的最优策略**：用`n`的最大真因子`p`作为每个集合的和（比如`n=8,p=4`，每个集合和为`4`）。只要`n−k+1 ≤ p`，Bob就能把所有数拆成和为`p`的集合。

**核心算法流程**：
1. 对每个`n`，找到它的**最小质因子**（因为最大真因子= `n ÷ 最小质因子`，比如`8`的最小质因子是`2`，最大真因子是`8÷2=4`）。
2. 比较`n−k+1`和最大真因子的大小：若前者大，Alice赢；否则Bob赢。

**可视化设计思路**：我们会做一个8位像素风的「因子探险家」游戏——
- 屏幕左侧是`n`的像素化“数字城堡”，右侧是“因子探测仪”（显示当前测试的因子）。
- 当探测仪找到`n`的最小质因子时，城堡会“裂开”露出最大真因子，同时播放“叮～”的音效。
- 用不同颜色高亮`n−k+1`和最大真因子：如果前者是红色（更大），Alice的像素角色会举旗庆祝；如果是绿色（更小），Bob的角色会欢呼。
- 支持“单步探测”（手动点下一步测试因子）和“自动探险”（AI自动找因子），速度滑块可以调节探测速度。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码效率、结论严谨性等方面筛选了以下优质题解，帮你快速掌握核心！
</eval_intro>

**题解一：(来源：_Kenma_，赞10)**
* **点评**：这份题解是“结论+证明+高效实现”的完美组合！作者直接给出核心结论（`Alice赢当且仅当n−k+1 > 最大真因子`），并用“构造序列”证明充分性，用“划分可行性”证明必要性。代码用**线性筛**预处理每个数的最大真因子（`maxn`数组），时间复杂度`O(n+T)`，完美处理`1e8`的范围。思路直白，代码规范，是最值得参考的解法！

**题解二：(来源：kbzcz，赞7)**
* **点评**：作者的思路像“剥洋葱”——先想`n=k`时Bob必赢，再想`n>k`时Alice会把`n−k`全加给一个数（让差最大）。然后指出Bob的最优策略是枚举`n`的因数，只要有一个因数满足`sum=n/m ≥ n−k+1`且`m≤k`，Bob就赢。代码用`O(√n)`枚举因数，虽然理论复杂度比筛法高，但实际能过，适合理解基础思路。

**题解三：(来源：arrowpoint，赞6)**
* **点评**：作者用**数学归纳法**证明了“当最大数≤p时Bob可以划分”，逻辑严密！他提到“如果能拆出一个和为p的集合，剩下的子问题也能拆”，帮你理解Bob的划分可行性。代码用预处理质数的方法找因数，适合想深入证明的同学。

**题解四：(来源：I_will_AKIOI，赞1)**
* **点评**：作者点出了“最大真因子= n÷最小质因子”的关键等价关系，并用**欧拉筛**预处理每个数的最小质因子（`low`数组），代码简洁高效。他还提到用`bitset`优化空间，解决`1e8`数组的存储问题，是工程实现的好参考！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在**理解策略的最优性**和**数论结论的推导**。我帮你梳理了3个核心难点和解决方法：
</difficulty_intro>

1. **难点1：为什么Alice的最优构造是“一个大数+k-1个1”？**
    * **分析**：如果Alice构造的序列有多个大于1的数，比如`n=8,k=3`构造`3,3,2`，Bob反而更容易划分（比如分成`3+2`和`3`）。而“一个大数+1s”的构造，会让最大的数“卡死”Bob的划分——如果这个数比`p`大，Bob根本无法处理它！
    * 💡 **学习笔记**：最优策略往往是“极端构造”——要么全选最小的（1），要么集中力量造最大的。

2. **难点2：为什么`n`的最大真因子`p`是关键？**
    * **分析**：Bob的目标是把`n`分成`m`个和相同的集合，每个集合的和必须是`n`的因数（因为`m×sum =n`）。而`p`是最大的真因子（即`sum`最大），此时`m`最小（`m=n/p`），Bob的划分空间最大。比如`n=8,p=4`，`m=2`，Bob只需要分2次就能完成；如果`sum`更小（比如`2`），`m=4`，划分反而更麻烦！
    * 💡 **学习笔记**：找“最大的可行sum”是Bob的最优选择——越大的sum，越容易容纳Alice的构造。

3. **难点3：如何高效计算`n`的最大真因子（处理`1e8`的范围）？**
    * **分析**：直接枚举每个`n`的因数会超时（`1e8`的`√n`是`1e4`，`2e5`次查询就是`2e9`次操作）。所以需要**预处理**：用线性筛或欧拉筛提前算出每个数的最小质因子，这样`最大真因子= n ÷ 最小质因子`，查询时`O(1)`计算！
    * 💡 **学习笔记**：预处理是处理大数据的“神器”——把耗时的计算提前做，查询时直接用结果。


### ✨ 解题技巧总结
- **极端构造法**：解决策略游戏题时，先想“最极端的情况”（比如全1加一个大数），往往能找到突破口。
- **数论转化**：把游戏胜负转化为数学条件（比如因数比较），避免复杂的模拟。
- **预处理优化**：对于`1e8`这样的大数字，筛法是高效计算因数的关键。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心代码**——用线性筛预处理每个数的最大真因子，然后快速回答查询。这个代码综合了_Kenma_和I_will_AKIOI的思路，效率最高！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码用**线性筛**预处理`1e8`以内每个数的最大真因子（`maxn`数组），查询时直接比较`n−k+1`和`maxn[n]`的大小。适合处理`2e5`次查询！
* **完整核心代码**（注：由于`1e8`数组太大，实际代码会用`bitset`或只存质数，这里简化展示逻辑）：
    ```cpp
    #include <iostream>
    #include <vector>
    using namespace std;

    const int MAX_N = 1e8;
    vector<int> prime;       // 存储质数
    vector<int> maxn(MAX_N+1, 1);  // maxn[i]是i的最大真因子

    void sieve() {
        vector<bool> is_prime(MAX_N+1, true);
        is_prime[0] = is_prime[1] = false;
        for (int i = 2; i <= MAX_N; ++i) {
            if (is_prime[i]) {
                prime.push_back(i);
                maxn[i] = 1;  // 质数的最大真因子是1
            }
            for (int p : prime) {
                if (i * p > MAX_N) break;
                is_prime[i * p] = false;
                maxn[i * p] = i;  // i*p的最大真因子是i（因为p是最小质因子）
                if (i % p == 0) break;
            }
        }
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        sieve();  // 预处理（实际中1e8数组会超内存，需优化！）
        int T;
        cin >> T;
        while (T--) {
            int n, k;
            cin >> n >> k;
            int p = maxn[n];  // n的最大真因子
            if (n - k + 1 > p) {
                cout << "Alice\n";
            } else {
                cout << "Bob\n";
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. **筛法预处理**：`sieve`函数用线性筛找出所有质数，并记录每个数的最大真因子（`maxn[i]`）——如果`i`是`p`的倍数（`p`是质数），那么`maxn[i]`等于`i/p`的最大真因子？不，等一下，线性筛的逻辑是：当`i`被`p`整除时，`i*p`的最小质因子是`p`，所以最大真因子是`i`（比如`i=4,p=2`，`i*p=8`，最大真因子是`4`）。对，`maxn[i*p] = i`是对的！
    > 2. **查询处理**：读入`n,k`，直接取`maxn[n]`（最大真因子），比较`n−k+1`和`p`的大小，输出结果。


<code_intro_selected>
接下来看优质题解中的核心片段，学习不同的实现技巧！
</code_intro_selected>

**题解一：(来源：_Kenma_，赞10)**
* **亮点**：用线性筛预处理`maxn`数组，**O(n)`预处理，`O(1)`查询**，效率拉满！
* **核心代码片段**：
    ```cpp
    void seive(int n){
        for(int i=2;i<=n;i++){
            if(!not_prime[i]) prime[++cnt]=i,maxn[i]=1;
            for(int j=1;j<=cnt && i*prime[j]<=n;j++){
                not_prime[i*prime[j]]=1;
                maxn[i*prime[j]]=i;  // 关键：i*prime[j]的最大真因子是i
                if(i%prime[j]==0) break;
            }
        }
    }
    ```
* **代码解读**：
    > 这段代码是线性筛的核心！`not_prime`数组标记合数，`prime`数组存质数。当`i`是质数时，`maxn[i]=1`（质数的最大真因子是1）。当处理`i*prime[j]`时：
    > - `maxn[i*prime[j]] = i`：因为`prime[j]`是`i*prime[j]`的最小质因子（线性筛的性质），所以最大真因子是`(i*prime[j])/prime[j] = i`！
    > - 比如`i=3`（质数），`prime[j]=2`，`i*prime[j]=6`，`maxn[6]=3`（6的最大真因子是3）——对！
* 💡 **学习笔记**：线性筛的关键是“每个合数只被最小质因子筛一次”，这样能高效记录每个数的最小质因子或最大真因子。

**题解二：(来源：kbzcz，赞7)**
* **亮点**：直接枚举`n`的因数，适合理解基础思路（虽然效率不如筛法，但容易写）！
* **核心代码片段**：
    ```cpp
    for(int i=2;i*i<=n&&i<=K&&n/i>n-K;i++) {
        if(n%i==0) {
            bj=1;
            break;
        }
    }
    ```
* **代码解读**：
    > 这段代码枚举`i`从2到`√n`：
    > - `i<=K`：保证`m=i`（划分的集合数）不超过`k`（因为每个集合至少1个元素，`m<=k`）。
    > - `n/i>n-K`：`n/i`是集合的和（`sum`），需要`sum >= n-K+1`（因为`n-K+1`是Alice构造的最大数）。
    > - 如果找到这样的`i`（`n`的因数），Bob赢（`bj=1`）。
* 💡 **学习笔记**：枚举因数时，只需要枚举到`√n`，因为`i`和`n/i`是成对的。

**题解三：(来源：LostKeyToReach，赞5)**
* **亮点**：用**Pollard-Rho算法**分解大因数，适合处理`1e18`级别的`n`（本题`n`是`1e8`，但思路通用）！
* **核心代码片段**：
    ```cpp
    inline int getfac(int n) {
        if ((n & 1) ^ 1) return 2;
        int x = rand() % (n - 2) + 2;
        int y = x;
        int c = rand() % (n - 1) + 1;
        int d = 1;
        while (d == 1) {
            x = ((long long)x * x % n + c) % n;
            y = ((long long)y * y % n + c) % n;
            y = ((long long)y * y % n + c) % n;
            d = gcd(abs(x - y), n);
        }
        return d == n ? getfac(n) : d;
    }
    ```
* **代码解读**：
    > Pollard-Rho是一种概率性因数分解算法，适合分解大整数。这段代码的核心是“ Floyd 判圈法”：通过随机生成`x,y`，计算`gcd(|x-y|,n)`，找到`n`的一个因数`d`。如果`d=n`（没找到），就重新来；否则返回`d`。
* 💡 **学习笔记**：当`n`很大（比如`1e18`），筛法无法预处理时，Pollard-Rho是救命稻草！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们设计了一个8位像素风的「因子探险家」游戏，帮你直观感受“找因子”和“判定胜负”的过程！
</visualization_intro>

  * **动画演示主题**：像素小机器人“因子侠”探索数字城堡，找到`n`的最小质因子，从而判定Alice和Bob的胜负。

  * **核心演示内容**：
    1. **场景初始化**：屏幕左侧是`n`的像素城堡（比如`n=8`是由8个蓝色像素块组成的城堡），右侧是“探测面板”（显示当前测试的因子`i`），底部是控制按钮（单步、自动、重置、速度滑块）。
    2. **因子探测**：“因子侠”从`i=2`开始测试——
       - 用黄色高亮当前测试的`i`（比如`i=2`），如果`n%i==0`（找到最小质因子），城堡会“裂开”露出最大真因子`p`（比如`8`的`p=4`），同时播放“叮～”的音效。
       - 如果`i`不是因子，因子侠会“摇头”，`i`变成红色，跳到下一个`i`（比如`i=3`）。
    3. **胜负判定**：显示`n−k+1`（红色像素块）和`p`（绿色像素块）：
       - 如果红色块比绿色块大（比如`n=8,k=3`，`6>4`），Alice的像素角色会举着“胜利旗”跳起来，播放“赢”的音效。
       - 如果绿色块更大（比如`n=4,k=4`，`1<=2`），Bob的角色会挥着手转圈，播放“耶～”的音效。

  * **交互设计**：
    - **单步模式**：点击“下一步”按钮，因子侠测试下一个`i`，适合慢慢看过程。
    - **自动模式**：因子侠自动测试`i`，速度滑块可以调节（从“龟速”到“光速”）。
    - **重置**：清空当前场景，重新输入`n,k`。

  * **游戏化元素**：
    - **音效**：测试因子时播放“滴”的音效，找到因子时播放“叮”，胜利时播放“赢”的短音乐，失败时播放“嗡”。
    - **关卡**：把`n`分成“小质数”（比如`n=7`）、“小合数”（`n=8`）、“大合数”（`n=1e8`）三个关卡，完成关卡会获得“因子徽章”。
    - **AI演示**：点击“AI探险”，因子侠会用最优路径找因子（比如直接跳到最小质因子），展示“高效找因子”的技巧。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心是“数论中的因数分解”，以下问题能帮你巩固这个知识点！
</similar_problems_intro>

  * **通用思路迁移**：
    - 问题1：判断一个数是否为质数（用筛法或试除法）。
    - 问题2：求一个数的所有因数（用质因数分解）。
    - 问题3：找两个数的最大公约数（GCD）或最小公倍数（LCM）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1075 质因数分解**（P1075）
          * 🗣️ **推荐理由**：直接考察“找最小质因子”，和本题的核心完全一致！
    2.  **洛谷 P1217 回文质数**（P1217）
          * 🗣️ **推荐理由**：结合回文数和质数判断，需要高效筛法预处理。
    3.  **洛谷 P1414 又是毕业季I**（P1414）
          * 🗣️ **推荐理由**：考察“找最大的因数”，和本题的“最大真因子”思路类似。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
以下是题解作者的宝贵经验，帮你少走弯路！
</insights_intro>

> **参考经验 (来自 _Kenma_，赞10)**：“在考场上，证明结论可以采用证明与打表验证结合的做法，可能会有奇效。”
>
> **点评**：这太重要了！比如本题的结论，你可以先打表验证小数据（比如`n=4,k=4`→Bob赢；`n=8,k=3`→Alice赢），再尝试证明——打表能帮你快速找到规律，避免“想破头”！

> **参考经验 (来自 kbzcz，赞7)**：“纪念第一次场切的 div2 D。”
>
> **点评**：场切难题的关键是“抓住核心”——本题的核心不是模拟游戏过程，而是找数学结论。当你发现“构造一个大数+1s”能决定胜负时，问题就变得简单了！


<conclusion>
本次关于「Divide and Merge Game」的分析就到这里。这道题告诉我们：**游戏策略题的本质往往是数学结论**——找到关键的数字关系，就能直接判定胜负！记住，遇到策略题时，先想“极端构造”和“数论转化”，再用筛法或枚举实现。下次我们再一起探索更有趣的数论问题！💪
</conclusion>

---
处理用时：116.45秒
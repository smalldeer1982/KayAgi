# 题目信息

# [SDOI2013] 随机数生成器

## 题目背景

小 W 喜欢读书，尤其喜欢读《约翰克里斯朵夫》。

## 题目描述

最近小 W 准备读一本新书，这本书一共有 $p$ 页，页码范围为 $0 \sim p-1$。

小 W 很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用 NOI2012 上学习的线性同余法生成一个序列，来决定每天具体读哪一页。

我们用 $x_i$ 来表示通过这种方法生成出来的第 $i$ 个数，也即小 W 第 $i$ 天会读哪一页。这个方法需要设置 $3$ 个参数 $a,b,x_1$，满足 $0\leq a,b,x_1\lt p$，且 $a,b,x_1$ 都是整数。按照下面的公式生成出来一系列的整数：
$$x_{i+1} \equiv a \times x_i+b \pmod p$$
其中 $\bmod$ 表示取余操作。

但是这种方法可能导致某两天读的页码一样。

小 W 要读这本书的第 $t$ 页，所以他想知道最早在哪一天能读到第 $t$ 页，或者指出他永远不会读到第 $t$ 页。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq T \leq 50$。
- $0 \leq a, b, x_1, t \lt p$，$2 \leq p \leq 10^9$。
- $p$ 为质数。

## 样例 #1

### 输入

```
3
7 1 1 3 3
7 2 2 2 0
7 2 2 2 1
```

### 输出

```
1 
3 
-1```

# AI分析结果



---
# 💡 Kay的C++算法解析：[SDOI2013] 随机数生成器 深入学习指南 💡

<introduction>
今天我们来分析“[SDOI2013] 随机数生成器”这道题。它通过线性同余法生成序列，要求找到最早读到目标页码t的天数。我们将从数学推导、算法选择到代码实现逐步拆解，帮助大家掌握这类问题的解决方法。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（BSGS算法应用）`

🗣️ **初步分析**：
解决这道题的关键在于将线性递推式转化为数学方程，并用BSGS（大步小步算法）求解离散对数问题。BSGS算法的核心思想是“分块”，将指数问题分解为小步和大步两部分，通过预处理和哈希表快速查找解，类似“先存后找”的策略。

在本题中，我们需要处理递推式 \( x_{i+1} = (a \cdot x_i + b) \mod p \)，目标是找到最小的 \( i \) 使得 \( x_i = t \)。核心思路是通过数学推导将递推式转化为等比数列形式，进而用BSGS求解。难点在于处理特殊情况（如 \( a=0 \)、\( a=1 \)）和正确应用BSGS算法。

可视化设计上，我们计划用8位像素风格展示递推序列的生成过程：用不同颜色的像素块表示序列中的每个数，当计算到 \( x_i = t \) 时，该像素块闪烁并播放“叮”的音效。BSGS的搜索过程则用两个滚动条分别表示小步和大步，高亮当前计算的指数值，帮助直观理解“分块”思想。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下题解表现突出（≥4星）：
</eval_intro>

**题解一：ChenZ01（来源：个人博客）**
* **点评**：此题解的亮点在于数学推导详尽且代码规范。作者从递推式出发，逐步推导出等比数列形式，明确处理了 \( a=0 \)、\( a=1 \) 等特殊情况。代码中BSGS算法实现简洁，逆元计算和模运算处理严谨（如使用 `inv` 函数求逆元），边界条件（如 \( x_1 = t \)）判断清晰。实践价值高，适合直接参考。

**题解二：wwyx2001（来源：洛谷最优解）**
* **点评**：此题解以“等比数列转化”为核心，推导过程简洁明了（如 \( X_{i+1} + \frac{b}{a-1} = a(X_i + \frac{b}{a-1}) \)），代码长度优化且高效。特别指出了特判情况的重要性，适合学习如何将数学公式快速转化为代码。

**题解三：Maxwei_wzj（来源：个人思路）**
* **点评**：此题解另辟蹊径，用矩阵乘法结合BSGS求解。虽然代码稍复杂，但展示了BSGS在矩阵指数问题中的应用，拓宽了思路。矩阵乘法的实现和哈希表的使用（链式前向星）体现了对算法优化的思考，适合进阶学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，我们常遇到以下核心难点，结合优质题解的经验，总结策略如下：
</difficulty_intro>

1.  **难点1：递推式的数学推导**
    * **分析**：需要将线性递推式 \( x_{i+1} = a \cdot x_i + b \mod p \) 转化为等比数列形式。关键步骤是引入常数 \( k = \frac{b}{a-1} \)，将递推式变形为 \( x_{i+1} + k = a(x_i + k) \)，从而得到等比数列 \( x_n + k = (x_1 + k) \cdot a^{n-1} \mod p \)。
    * 💡 **学习笔记**：遇到线性递推式时，尝试通过“配平”常数项转化为等比数列，是解决此类问题的通用方法。

2.  **难点2：特判情况的处理**
    * **分析**：当 \( a=0 \) 时，序列退化为 \( x_1, b, b, \dots \)；当 \( a=1 \) 时，序列变为等差数列 \( x_1, x_1+b, x_1+2b, \dots \)。这两种情况需单独处理，避免公式失效。例如，\( a=1 \) 时需解 \( x_1 + (i-1)b \equiv t \mod p \)，用扩展欧几里得算法求解。
    * 💡 **学习笔记**：特判是编程严谨性的体现，需仔细枚举所有可能的边界条件（如 \( x_1 = t \)）。

3.  **难点3：BSGS算法的正确实现**
    * **分析**：BSGS用于求解 \( a^k \equiv b \mod p \) 的最小 \( k \)。需注意预处理小步（\( a^j \cdot b \mod p \)）存入哈希表，再用大步（\( a^{m \cdot i} \mod p \)）查询。实现时需处理模运算的负数问题（如 \( (t - x_1) \mod p \) 可能为负，需加 \( p \) 后取模）。
    * 💡 **学习笔记**：BSGS的关键是分块预处理和哈希表查询，需确保模数 \( p \) 为质数（本题已保证），逆元存在。

### ✨ 解题技巧总结
- **问题分解**：将复杂递推问题拆解为数学推导（等比数列）和算法求解（BSGS）两部分，降低难度。
- **特判优先**：先处理 \( a=0 \)、\( a=1 \)、\( x_1 = t \) 等简单情况，再处理一般情况。
- **模运算规范**：所有运算后取模，确保中间结果非负（如 \( (x - y) \mod p \) 后加 \( p \) 再取模）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解后提炼的通用核心实现，覆盖所有特判和BSGS求解，代码规范且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合ChenZ01和wwyx2001的题解，优化特判逻辑和BSGS实现，确保代码简洁且正确。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cmath>
    #include <map>
    using namespace std;

    typedef long long ll;

    ll pow_mod(ll a, ll b, ll p) {
        ll res = 1;
        while (b) {
            if (b & 1) res = res * a % p;
            a = a * a % p;
            b >>= 1;
        }
        return res;
    }

    ll inv(ll x, ll p) {
        return pow_mod(x, p - 2, p);
    }

    ll bsgs(ll a, ll b, ll p) {
        a %= p, b %= p;
        if (b == 1) return 0;
        map<ll, ll> mp;
        ll m = ceil(sqrt(p)), t = 1;
        for (ll i = 0; i < m; ++i) {
            if (!mp.count(t)) mp[t] = i;
            t = t * a % p;
        }
        ll k = inv(t, p), w = b;
        for (ll i = 0; i < m; ++i) {
            if (mp.count(w)) return i * m + mp[w];
            w = w * k % p;
        }
        return -1;
    }

    int main() {
        int T;
        cin >> T;
        while (T--) {
            ll p, a, b, x1, t;
            cin >> p >> a >> b >> x1 >> t;
            if (x1 == t) {
                cout << 1 << endl;
                continue;
            }
            if (a == 0) {
                if (b == t) cout << 2 << endl;
                else cout << -1 << endl;
                continue;
            }
            if (a == 1) {
                ll delta = (t - x1 + p) % p;
                if (b == 0) {
                    cout << -1 << endl;
                    continue;
                }
                ll inv_b = inv(b, p);
                ll ans = delta * inv_b % p + 1;
                cout << (ans == 0 ? p : ans) << endl;
                continue;
            }
            ll k = b * inv(a - 1, p) % p;
            ll numerator = (t + k) % p;
            ll denominator = (x1 + k) % p;
            ll B = numerator * inv(denominator, p) % p;
            ll ans = bsgs(a, B, p);
            cout << (ans == -1 ? -1 : ans + 1) << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先处理特判（\( x_1 = t \)、\( a=0 \)、\( a=1 \)），然后对一般情况通过等比数列推导得到 \( a^{i-1} \equiv B \mod p \)，用BSGS求解 \( i-1 \)，最后输出 \( i \)（即 \( ans + 1 \)）。核心函数 `pow_mod` 用于快速幂，`inv` 求逆元，`bsgs` 实现大步小步算法。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：ChenZ01（来源：个人博客）**
* **亮点**：BSGS实现简洁，特判逻辑清晰，逆元计算正确。
* **核心代码片段**：
    ```cpp
    long long bsgs(long long a, long long b, int MOD) {
        a %= MOD, b %= MOD;
        std::map <long long, long long> map;
        register long long m = ceil(sqrt(MOD)), t = 1;
        for (register int i = 0; i < m; ++i) {
            if (!map.count(t)) map[t] = i;
            t = t * a % MOD;
        }
        register long long k = inv(t, MOD), w = b;
        for (int i = 0; i < m; ++i) {
            if (map.count(w)) return i * m + map[w];
            w = w * k % MOD;
        }
        return -1;
    }
    ```
* **代码解读**：这段BSGS函数首先预处理小步（\( a^0, a^1, ..., a^{m-1} \)）存入哈希表，然后用大步（\( a^{m \cdot i} \)）查询。`k` 是 \( a^m \) 的逆元，用于快速计算大步的每一步。例如，`w = w * k % MOD` 相当于每次减去一个大步的指数，通过哈希表查找是否存在匹配的小步。
* 💡 **学习笔记**：BSGS的预处理和查询步骤是关键，哈希表存储小步结果可快速匹配大步的余数。

**题解二：wwyx2001（来源：洛谷最优解）**
* **亮点**：等比数列推导简洁，代码长度优化。
* **核心代码片段**：
    ```cpp
    X_{i+1}+\frac{b}{a-1}=a(X_i+\frac{b}{a-1}) \ (mod\ p)
    ```
* **代码解读**：这是数学推导的核心步骤，通过引入 \( k = \frac{b}{a-1} \) 将递推式转化为等比数列，从而得到 \( X_n = (X_1 + k) \cdot a^{n-1} - k \mod p \)。后续只需解 \( a^{n-1} \equiv \frac{t + k}{X_1 + k} \mod p \)，直接应用BSGS。
* 💡 **学习笔记**：配平常数项是转化递推式的常用技巧，可简化问题为等比数列形式。

**题解三：Maxwei_wzj（来源：个人思路）**
* **亮点**：矩阵乘法结合BSGS，展示了算法的灵活性。
* **核心代码片段**：
    ```cpp
    matrix mult(matrix A, matrix B) {
        matrix S;
        memset(S.mat, 0, sizeof(S.mat));
        for(int i=0; i<2; i++)
            for(int j=0; j<2; j++)
                for(int k=0; k<2; k++)
                    S.mat[i][j] = (S.mat[i][j] + A.mat[i][k] * B.mat[k][j]) % p;
        return S;
    }
    ```
* **代码解读**：这段矩阵乘法函数用于计算递推式的矩阵形式 \( \begin{pmatrix}a & b \\ 0 & 1\end{pmatrix}^x \)。通过矩阵快速幂和BSGS结合，将问题转化为矩阵指数求解，适用于更复杂的递推关系。
* 💡 **学习笔记**：矩阵乘法可表示线性递推，结合BSGS可解决指数在矩阵中的问题，拓展了算法应用场景。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了直观理解BSGS的搜索过程和递推序列的生成，我们设计一个“像素探险队找宝藏”的8位像素动画。
\</visualization_intro\>

  * **动画演示主题**：`像素探险队寻找目标页码t`

  * **核心演示内容**：展示递推序列 \( x_1, x_2, ... \) 的生成过程，当 \( x_i = t \) 时触发胜利动画；同时演示BSGS算法如何分块预处理小步、查询大步，最终找到最小 \( i \)。

  * **设计思路简述**：8位像素风格（如FC红白机画面）营造轻松氛围，用不同颜色标记序列中的数（如 \( x_1 \) 为蓝色，\( t \) 为金色）。BSGS的小步和大步用两个滚动条表示，每完成一步播放“叮”的音效，找到解时播放胜利音效，增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        * 屏幕左侧显示像素网格（\( 16 \times 16 \)），每个格子代表序列中的一个数 \( x_i \)，初始时 \( x_1 \) 格子高亮（蓝色）。
        * 右侧显示BSGS控制面板（开始/暂停、单步、调速滑块）和哈希表（用像素方块堆叠表示）。

    2.  **递推序列生成**：
        * 点击“开始”，序列按 \( x_{i+1} = (a \cdot x_i + b) \mod p \) 生成，每个新生成的 \( x_i \) 格子从右向左滑动进入网格，颜色随机（除 \( t \) 为金色）。
        * 当生成 \( x_i = t \) 时，该格子闪烁并播放“胜利”音效（如《超级玛丽》吃金币声）。

    3.  **BSGS算法演示**：
        * 预处理小步：哈希表区域逐个添加 \( a^j \cdot b \mod p \) 的像素方块（绿色），每个方块标有指数 \( j \)。
        * 大步查询：从 \( a^m \) 开始，逐个计算 \( a^{m \cdot i} \mod p \)（红色方块），与哈希表中的绿色方块匹配。匹配成功时，两个方块合并并显示指数 \( i \cdot m - j \)。

    4.  **交互控制**：
        * 单步执行：每点击一次“单步”，生成一个序列项或执行一次BSGS步骤。
        * 调速滑块：调整动画速度（1x-4x），方便观察细节。

  * **旁白提示**：
    * （生成序列时）“看！第i天的页码是 \( x_i \)，如果等于t就成功啦~”
    * （BSGS预处理）“先存下小步的结果，后面找起来更快哦！”
    * （匹配成功）“找到啦！最小的i是 \( i \cdot m - j + 1 \)！”

\<visualization_conclusion\>
通过这个动画，我们不仅能看到序列生成的过程，还能直观理解BSGS如何分块查找解，让抽象的数学算法变得“看得见，摸得着”。
\</visualization_conclusion\>

-----

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
BSGS算法和递推式处理是数论中的经典问题，以下是相关拓展练习：
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：
    - BSGS可用于求解离散对数问题（如 \( a^x \equiv b \mod p \)），适用于密码学、数列递推等场景。
    - 递推式转化（如配平常数项）可用于解决线性递推数列的通项求解问题。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4884** - `多少个1？`  
        * 🗣️ **推荐理由**：求解 \( 11...1 \)（k个1）\( \equiv B \mod p \) 的最小k，直接应用BSGS算法，适合巩固基础。
    2.  **洛谷 P3846** - `[TJOI2007] 可爱的质数`  
        * 🗣️ **推荐理由**：标准的离散对数问题，需处理 \( a \) 和 \( p \) 不互质的情况，拓展BSGS的应用场景。
    3.  **洛谷 P5345** - `[XR-1] 快乐肥宅`  
        * 🗣️ **推荐理由**：结合递推式和BSGS，需将问题转化为离散对数求解，适合综合练习。

-----

## 7\. 学习心得与经验分享

\<insights_intro\>
部分题解提到调试时的经验，例如HoshiuZ提到“mul操作后可能为负，需保证结果非负”，这些经验对我们很有启发：
\</insights_intro\>

> **参考经验 (来自HoshiuZ)**：“提交了十几遍，结果发现错误原因是求 \( a \neq 1 \) 时的式子时，用自己写的 `mul` 操作后可能为负，于是把 `mul` 改了，保证俩大于0。”

**点评**：HoshiuZ的调试经历提醒我们，模运算中负数处理非常重要。在计算 \( (x - y) \mod p \) 时，需先加 \( p \) 再取模（如 \( (x - y + p) \% p \)），确保结果非负。这是避免错误的关键细节。

-----

\<conclusion\>
通过对“随机数生成器”的分析，我们掌握了递推式转化、BSGS算法应用和特判处理的技巧。编程的核心在于“拆解问题+严谨实现”，希望大家多练习类似题目，提升数论和算法能力！下次见~ 💪
\</conclusion\>

---
处理用时：178.55秒
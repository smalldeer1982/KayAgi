# 题目信息

# [CQOI2018] 破解D-H协议

## 题目背景

Diffie-Hellman 密钥交换协议是一种简单有效的密钥交换方法。它可以让通讯双方在没有事先约定**密钥**的情况下，通过**不安全**（可能被窃听）**的信道**确定一个**安全的密钥** $K$，用于加密之后的通讯内容。

## 题目描述

假定通讯双方名为 Alice 和 Bob，协议的工作过程描述如下（其中 $\bmod$ 表示取模运算）：

1. 协议规定一个**固定的**质数 $P$，以及模 $P$ 的一个原根 $g$。**$\boldsymbol P$ 和 $\boldsymbol g$ 的数值都是公开的，无需保密。**

2. Alice 生成一个随机数 $a$，并计算 $A=g^a\bmod P$，将 $A$ 通过不安全信道发送给 Bob。

3. Bob 生成一个随机数 $b$，并计算 $B=g^b\bmod P$，将 $B$ 通过不安全信道发送给 Alice。

4. Bob 根据收到的 $A$ 计算出**密钥** $K=A^b \bmod P$，而 Alice 根据收到的 $B$ 计算出 $K=B^a\bmod P$。

5. 双方得到了相同的 $K$，即 $g^{ab} \bmod P$。$K$ 即之后通讯的加密密钥。

可见，这个过程中可能被窃听的只有 $A,B$，而 $a,b,K$ 是保密的。并且根据 $A,B,P,g$ 这 $4$ 个数，不能轻易计算出 $K$，因此 $K$ 可以作为一个安全的密钥。

当然安全是相对的，该协议的安全性取决于数值的大小，通常 $a,b,P$ 都选取数百位以上的大整数以避免被破解。然而如果 Alice 和 Bob 编程时偷懒，为了避免实现大数运算，选择的数值都小于 $2^{31}$，那么破解他们的密钥就比较容易了。

$T$ 次给定窃听得到的 $A,B$，你需要尝试破解出**密钥** $K$。


## 说明/提示

对于 $30\%$ 的数据，$2\le A,B,P\le 1000$；

对于 $100\%$ 的数据，$2\le A,B<P<2^{31}，2\le g<20，1\le n\le 20$。

$\text{Statement fixed by @Starrykiller.}$

## 样例 #1

### 输入

```
3 31
3
27 16
21 3
9 26```

### 输出

```
4
21
25```

# AI分析结果



---
# 💡 Kay的C++算法解析：[CQOI2018] 破解D-H协议 深入学习指南 💡

<introduction>
今天我们来一起分析“[CQOI2018] 破解D-H协议”这道C++编程题。这道题的核心是利用BSGS算法解决高次同余方程，最终求出密钥。本指南将帮助大家理解题目逻辑、掌握BSGS算法，并通过代码和可视化演示深入学习。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`BSGS算法（Baby-Step Giant-Step，大步小步算法）`

🗣️ **初步分析**：
解决这道题的关键在于理解BSGS算法。BSGS算法可以高效求解形如 $g^x \equiv A \pmod{P}$ 的高次同余方程，其中 $P$ 是质数，$g$ 是原根（与 $P$ 互质）。简单来说，BSGS就像“分块查字典”——把指数 $x$ 拆成两部分，先预处理一部分值存入“哈希字典”，再用另一部分值去字典里“找答案”，这样能把时间复杂度从暴力枚举的 $O(P)$ 降到 $O(\sqrt{P})$，适合处理大质数情况。

在本题中，已知 $A = g^a \bmod P$ 和 $B = g^b \bmod P$，要求 $K = g^{ab} \bmod P$。由于 $K = A^b \bmod P = B^a \bmod P$，我们只需用BSGS求出 $a$ 或 $b$ 中的一个，再用快速幂计算即可。例如，求出 $a$ 后，计算 $B^a \bmod P$ 就是答案。

核心难点在于BSGS算法的正确实现（分块、哈希表构建与查询），以及快速幂的取模处理。可视化方案将以8位像素风格模拟BSGS的“分块查字典”过程，用闪烁高亮哈希表插入和匹配步骤，配合“叮”的音效提示关键操作，让算法流程更直观。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰度、代码规范性、算法效率等方面的评估，以下3道题解因逻辑清晰、实现高效且易于学习，被选为优质参考：
</eval_intro>

**题解一：作者Leonid**
* **点评**：这份题解思路非常直接，代码结构简洁。作者明确指出“只需用BSGS求一个方程的解”，并通过快速幂输出结果。代码中变量命名规范（如`qpow`表示快速幂，`BSGS`函数逻辑清晰），哈希表使用`map`实现，适合初学者理解。算法上，BSGS的分块和哈希表查询步骤完整，边界处理（如清空哈希表）严谨，实践价值高。

**题解二：作者LeavingZzz**
* **点评**：此题解的亮点在于手写哈希表，相比`map`效率更高。作者详细解释了BSGS的推导过程（如将 $x$ 表示为 $im-j$），并优化了预处理步骤（仅预处理分子部分）。代码中`Hash_table`结构体的插入和查找操作简洁高效，适合需要提升性能的场景。

**题解三：作者MY（一名蒟蒻）**
* **点评**：此题解代码简洁，逻辑清晰。作者直接点明“使用BSGS算法”，并通过`map`实现哈希表，代码注释清晰（如`BSGS`函数中的分块逻辑）。快速幂函数使用位运算优化，适合作为模板学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们需要重点突破以下核心难点：
</difficulty_intro>

1.  **关键点1：BSGS算法的分块与哈希表构建**
    * **分析**：BSGS的核心是将指数 $x$ 拆分为 $im-j$（$m=\sqrt{P}$），预处理 $g^{im} \bmod P$ 存入哈希表，再枚举 $j$ 计算 $A \cdot g^j \bmod P$，查询哈希表是否存在匹配值。预处理时需注意 $m$ 取 $\lceil\sqrt{P}\rceil$，确保覆盖所有可能的 $x$。
    * 💡 **学习笔记**：分块是BSGS的灵魂，哈希表是加速查询的关键，预处理和枚举的顺序不能颠倒。

2.  **关键点2：快速幂的取模处理**
    * **分析**：快速幂计算时需不断取模，避免数值溢出（尤其当 $P$ 接近 $2^{31}$ 时）。例如，计算 $B^a \bmod P$ 时，每次乘法后都要对 $P$ 取模。
    * 💡 **学习笔记**：快速幂的模板需熟练掌握，取模操作是防止溢出的“保护锁”。

3.  **关键点3：哈希表的清空与冲突处理**
    * **分析**：多组数据时，哈希表需在每组开始前清空（如`map.clear()`），否则会残留上一组的数据导致错误。手写哈希表时需处理冲突（如开放寻址法），确保查询正确。
    * 💡 **学习笔记**：哈希表的状态管理是多组数据题的常见坑点，务必注意初始化。

### ✨ 解题技巧总结
- **问题简化**：题目中 $K = A^b = B^a$，只需解一个方程即可，减少计算量。
- **哈希表选择**：竞赛中若时间紧张，可用`map`；若追求效率，手写哈希表或用`unordered_map`。
- **边界检查**：BSGS返回的指数需确保非负（如`(o%p+p)%p`），避免负数结果。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结合了思路清晰性和效率，适合作为学习模板：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Leonid和MY的题解思路，使用`map`实现哈希表，逻辑清晰，适合初学者。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <cmath>
    #include <map>
    using namespace std;

    typedef long long ll;

    // 快速幂：计算 (a^b) mod p
    ll qpow(ll a, ll b, ll p) {
        ll res = 1;
        while (b) {
            if (b & 1) res = res * a % p;
            a = a * a % p;
            b >>= 1;
        }
        return res % p;
    }

    // BSGS算法：求解 g^x ≡ A (mod p) 的最小非负整数x
    ll BSGS(ll g, ll A, ll p) {
        A %= p;
        map<ll, ll> hash;
        ll m = ceil(sqrt(p)); // 分块大小m=√p
        ll val = A % p;
        hash[val] = 0; // 预处理j=0的情况

        // Baby Step：枚举j∈[0, m)，存储A*g^j mod p
        for (ll j = 1; j < m; ++j) {
            val = val * g % p;
            hash[val] = j;
        }

        // Giant Step：枚举i∈[1, m]，计算g^(i*m) mod p，查询哈希表
        ll g_m = qpow(g, m, p); // g^m mod p
        ll current = 1;
        for (ll i = 1; i <= m; ++i) {
            current = current * g_m % p;
            if (hash.count(current)) {
                ll x = i * m - hash[current];
                return (x % p + p) % p; // 确保非负
            }
        }
        return -1; // 无解（本题保证有解）
    }

    int main() {
        ll g, p, n;
        scanf("%lld %lld %lld", &g, &p, &n);
        while (n--) {
            ll A, B;
            scanf("%lld %lld", &A, &B);
            ll a = BSGS(g, A, p); // 求a，使得g^a ≡ A mod p
            ll K = qpow(B, a, p); // K = B^a mod p
            printf("%lld\n", K);
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先定义快速幂函数`qpow`，用于高效计算幂取模。`BSGS`函数通过分块预处理（Baby Step）和枚举查询（Giant Step）求解高次同余方程。主函数读取输入后，对每组A、B调用BSGS求a，再用快速幂计算K并输出。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者Leonid**
* **亮点**：代码简洁，`map`的使用直观，适合理解BSGS流程。
* **核心代码片段**：
    ```cpp
    ll BSGS(ll a,ll b,ll p){
        k.clear(); // 清空哈希表
        ll m=ceil(sqrt(p)),ans;
        for(ll i=0;i<=m;i++){ // Baby Step
            if(!i){
                ans=b%p;
                k[ans]=i;
                continue;
            }
            ans=(ans*a)%p;
            k[ans]=i;
        }
        ll t=qpow(a,m,p); // g^m mod p
        ans=1;
        for(ll i=1;i<=m;i++){ // Giant Step
            ans=(ans*t)%p;
            if(k[ans]){
                ll o=i*m-k[ans];
                return (o%p+p)%p; // 返回非负解
            }
        }
        return -1;
    }
    ```
* **代码解读**：`BSGS`函数中，首先清空哈希表`k`，然后预处理`j∈[0,m]`的`b*a^j mod p`存入哈希表。接着计算`a^m mod p`，枚举`i∈[1,m]`计算`a^(i*m) mod p`，查询哈希表是否存在匹配值。若存在，返回`i*m-j`作为解。
* 💡 **学习笔记**：预处理时`i`从0到`m`，确保覆盖所有可能的`j`，是BSGS正确性的关键。

**题解二：作者LeavingZzz（手写哈希表）**
* **亮点**：手写哈希表比`map`更快，适合大质数场景。
* **核心代码片段**：
    ```cpp
    struct Hash_table{ // 手写哈希表
        static const LL MOD=1999997;
        LL Hash[MOD],V[MOD],stk[MOD],top;
        inline void Insert(LL val,LL mi){
            LL h=val%MOD;
            while(Hash[h]&&Hash[h]!=val) h++; // 开放寻址处理冲突
            Hash[h]=val; V[h]=mi;
            stk[++top]=h; // 记录插入位置，便于清空
        }
        inline LL find(LL val){
            LL h=val%MOD;
            while(Hash[h]&&Hash[h]!=val) h++;
            return Hash[h]==val?V[h]:-1;
        }
    }H;
    ```
* **代码解读**：`Hash_table`结构体用数组实现哈希表，`Insert`函数通过开放寻址法处理冲突（若当前位置被占用，向后找空位），`find`函数按同样方式查找。`stk`记录插入位置，便于清空哈希表（如每组数据前调用`memset`）。
* 💡 **学习笔记**：手写哈希表需处理冲突，开放寻址法简单高效，但需注意哈希表大小（如取大质数MOD）。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解BSGS的“分块查字典”过程，我们设计一个8位像素风格的动画，模拟预处理和查询的每一步！
</visualization_intro>

  * **动画演示主题**：`BSGS探险队：在像素世界找钥匙`  
  * **核心演示内容**：展示BSGS如何预处理“小步”值存入哈希城堡，再用“大步”值去城堡里找匹配，最终找到指数`a`。

  * **设计思路简述**：8位像素风格（如FC游戏画面）营造轻松氛围，用不同颜色的像素块表示哈希表的存储和查询。关键步骤（如哈希插入、匹配成功）配合“叮”的音效，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        * 屏幕分为左右两部分：左侧是“哈希城堡”（8x8像素网格，每个格子代表哈希表的一个位置），右侧是“指数探险区”（显示当前处理的`i`和`j`）。
        * 控制面板有“单步”“自动播放”按钮，速度滑块（1-10级）。

    2.  **预处理（Baby Step）**：
        * 初始时，哈希城堡是空的。`j=0`时，计算`A*g^0 mod P`（即A），生成一个蓝色像素块，滑入哈希城堡的对应位置（按值取模MOD计算），伴随“滴”的音效。
        * `j=1`到`m-1`时，依次计算`A*g^j mod P`，生成绿色像素块，滑入哈希城堡（若位置冲突，用黄色箭头指向下一个空位）。

    3.  **查询（Giant Step）**：
        * 计算`g^m mod P`，生成一个红色“大步”块。`i=1`时，计算`g^(m*1) mod P`，生成红色块，与哈希城堡中的块比对。
        * 若匹配（颜色变为金色），弹出文字提示“找到啦！指数是i*m-j！”，并播放“胜利”音效；若不匹配，红色块右移一格继续比对。

    4.  **结果展示**：
        * 找到`a`后，右侧探险区显示`a`的值，并用快速幂动画计算`B^a mod P`（像素块逐个累加，最终显示结果K）。

  * **旁白提示**：
    * （预处理时）“看！我们在哈希城堡里存了所有`A*g^j`的值，就像把钥匙存进不同的抽屉～”
    * （查询时）“现在用`g^(i*m)`去城堡里找匹配的钥匙，找到就得到指数啦！”

<visualization_conclusion>
通过这个像素动画，我们能清晰看到BSGS如何通过“分块”和“查字典”高效求解高次同余方程，让抽象的算法变得生动有趣！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
BSGS算法不仅能解决本题，还适用于其他高次同余问题。掌握后可以尝试以下题目：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    BSGS适用于求解形如 $a^x \equiv b \pmod{p}$ 的方程（$a,p$互质），常见于密码学、数论问题中，如离散对数、密钥破解等场景。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3846 [TJOI2007]可爱的质数**  
        * 🗣️ **推荐理由**：BSGS模板题，适合巩固基础。
    2.  **洛谷 P2485 [SDOI2011]计算器**  
        * 🗣️ **推荐理由**：结合快速幂、BSGS和扩展欧几里得，综合训练数论能力。
    3.  **洛谷 P4884 多少个1？**  
        * 🗣️ **推荐理由**：变形应用BSGS，求解最小的n使得11...1（n个1）能被k整除。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有启发：
</insights_intro>

> **参考经验 (来自作者MY)**：“一开始没清空哈希表，导致多组数据时结果错误。后来发现每次调用BSGS前必须`map.clear()`，这个细节很重要！”  
> **点评**：多组数据时，哈希表的状态管理是常见坑点。每次处理新数据前清空哈希表，是避免错误的关键。大家在写代码时一定要注意初始化操作！

---

<conclusion>
本次关于“[CQOI2018] 破解D-H协议”的分析就到这里。BSGS算法是数论中的重要工具，掌握它能解决许多高次同余问题。希望大家通过代码练习和动画演示，真正理解算法的核心，并在竞赛中灵活运用！下次见～💪
</conclusion>

---

---
处理用时：172.46秒
# 题目信息

# 【模板】原根

## 题目描述

给定整数 $n$，求它的所有原根。

为了减小你的输出量，给出输出参数 $d$，设 $n$ 的所有原根有 $c$ 个，从小到大分别为 $g_1,\ldots,g_c$，你只需要依次输出 $g_d,g_{2d},\ldots,g_{\lfloor\frac{c}{d}\rfloor\times d}$。

---

如果你不了解原根的定义，可以自行查找资料或阅读下列定义：

正整数 $g$ 是正整数 $n$ 的原根，当且仅当 $1\leq g\leq n-1$，且 $g$ 模 $n$ 的阶为 $\varphi(n)$。

## 说明/提示

【样例解释】

对于第 $1,2,4,6$ 组数据，给出的 $n$ 的所有原根都出现在输出中。

对于第 $3$ 组数据，$25$ 的原根集合为 $\{2,3,8,12,13,17,22,23\}$。

对于第 $5$ 组数据，$9$ 的原根集合为 $\{2,5\}$。

【数据范围】

对于 $100\%$ 的数据，$1\leq T\leq 10$，$2\leq n\leq 10^6$，$1\leq d\leq 200$，保证输出的数的总个数不超过 $10^5$。

## 样例 #1

### 输入

```
6
2 1
4 1
25 2
36 1
9 6
18 1
```

### 输出

```
1
1 
1
3 
8
3 12 17 23 
0

2

2
5 11 
```

# AI分析结果



---

# 💡 Kay的C++算法解析：【模板】原根 深入学习指南 💡

<introduction>
今天我们来一起分析“【模板】原根”这道C++编程题。原根是数论中的重要概念，理解并掌握其求解方法对提升数论能力至关重要。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数论（原根判定、欧拉函数、阶的性质）

🗣️ **初步分析**：
解决“【模板】原根”这道题，关键在于理解原根的定义和相关数论性质。原根的核心思想可以简单理解为：一个数 \( g \) 是模 \( n \) 的原根，当且仅当 \( g \) 模 \( n \) 的阶（即最小的 \( k \) 使得 \( g^k \equiv 1 \pmod{n} \)）恰好等于欧拉函数 \( \varphi(n) \)。

在本题中，我们需要：
1. **判断 \( n \) 是否存在原根**：根据原根存在定理，仅当 \( n \) 是 \( 2, 4, p^\alpha \) 或 \( 2p^\alpha \)（\( p \) 为奇素数，\( \alpha \geq 1 \)）时，原根存在。
2. **计算 \( \varphi(n) \)**：欧拉函数表示小于 \( n \) 且与 \( n \) 互质的数的个数。
3. **分解 \( \varphi(n) \) 的质因数**：用于快速验证候选原根。
4. **寻找最小原根 \( g \)**：枚举候选数，验证其是否满足原根判定条件（对 \( \varphi(n) \) 的每个质因数 \( p \)，\( g^{\varphi(n)/p} \not\equiv 1 \pmod{n} \)）。
5. **生成所有原根**：利用最小原根 \( g \)，生成所有 \( g^k \)（其中 \( k \) 与 \( \varphi(n) \) 互质）。

**核心算法流程**：  
首先预处理欧拉函数和原根存在性标记；对于每个 \( n \)，若存在原根，计算 \( \varphi(n) \) 并分解其质因数；枚举候选数找到最小原根；最后通过最小原根生成所有原根并按 \( d \) 输出。

**可视化设计思路**：  
采用8位像素风格动画，用不同颜色标记候选数（如红色表示未验证，绿色表示原根）。动态展示 \( \varphi(n) \) 分解质因数的过程（像素块分裂成质因数），候选数验证时用闪烁效果提示关键步骤（如 \( g^{\varphi(n)/p} \equiv 1 \pmod{n} \) 的失败），生成原根时用滑动动画展示 \( g^k \) 的生成过程。音效设计包括验证成功时的“叮”声，生成原根时的轻快音效，增强交互感。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码规范性、算法有效性等方面筛选了以下优质题解：
</eval_intro>

**题解一：作者codecode（赞：243）**  
* **点评**：此题解详细证明了原根存在定理和阶的性质，逻辑严谨，适合深入理解原理。代码中预处理欧拉函数、原根存在性标记，并通过分解 \( \varphi(n) \) 的质因数快速验证原根，步骤清晰。亮点在于对数学定理的完整推导，帮助学习者从底层理解原根的本质。

**题解二：作者ix35（赞：64）**  
* **点评**：此题解提供了完整的代码实现，预处理欧拉函数和原根存在性，步骤明确。代码中通过线性筛预处理 \( \varphi \) 和质数，分解 \( \varphi(n) \) 的质因数后枚举最小原根，生成所有原根并排序输出。亮点在于代码结构工整，变量命名清晰（如 `phi` 表示欧拉函数，`pri` 存储质数），适合直接参考实现。

**题解三：作者0xyz（赞：18）**  
* **点评**：此题解优化了生成所有原根的过程，使用随机化寻找最小原根（降低枚举次数），并通过线性筛优化互质判断。代码简洁高效（不到1.2kb），运行时间显著缩短。亮点在于随机化和筛法的结合，提升了算法效率，适合竞赛场景。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决原根问题时，我们通常会遇到以下核心难点，结合优质题解的共性，提炼解决策略：
</difficulty_intro>

1.  **关键点1：判断原根是否存在**  
    * **分析**：原根存在的条件是 \( n \) 属于 \( \{2, 4, p^\alpha, 2p^\alpha\} \)（\( p \) 为奇素数）。需预处理所有可能的 \( n \) 并标记是否有原根。优质题解通过线性筛预处理质数，并标记 \( p^\alpha \) 和 \( 2p^\alpha \) 形式的数。  
    * 💡 **学习笔记**：原根存在性判断是解题的第一步，需熟练掌握原根存在定理。

2.  **关键点2：寻找最小原根**  
    * **分析**：最小原根的枚举需验证 \( g \) 是否满足 \( g^{\varphi(n)} \equiv 1 \pmod{n} \) 且对 \( \varphi(n) \) 的每个质因数 \( p \)，\( g^{\varphi(n)/p} \not\equiv 1 \pmod{n} \)。优质题解通过分解 \( \varphi(n) \) 的质因数，减少验证次数。  
    * 💡 **学习笔记**：分解 \( \varphi(n) \) 的质因数是验证原根的关键，可大幅降低时间复杂度。

3.  **关键点3：生成所有原根**  
    * **分析**：所有原根可由最小原根 \( g \) 的 \( k \) 次幂生成（\( k \) 与 \( \varphi(n) \) 互质）。优质题解通过线性筛或随机化快速找到互质的 \( k \)，生成所有原根后排序输出。  
    * 💡 **学习笔记**：利用欧拉函数 \( \varphi(\varphi(n)) \) 确定原根个数，结合互质条件生成原根。

### ✨ 解题技巧总结
- **预处理优化**：预处理欧拉函数和原根存在性标记，快速判断 \( n \) 是否有原根。
- **质因数分解**：分解 \( \varphi(n) \) 的质因数，减少原根验证的次数。
- **随机化枚举**：随机选择候选数寻找最小原根，降低最坏时间复杂度。
- **线性筛互质**：通过筛法标记与 \( \varphi(n) \) 互质的数，高效生成所有原根。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了多个优质题解的思路，预处理欧拉函数和原根存在性，通过分解 \( \varphi(n) \) 的质因数寻找最小原根，生成所有原根并按 \( d \) 输出。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 1e6 + 10;

    int phi[MAXN], prime[MAXN], cnt;
    bool is_prime[MAXN], has_root[MAXN];

    void init() {
        phi[1] = 1;
        for (int i = 2; i < MAXN; ++i) {
            if (!is_prime[i]) {
                prime[++cnt] = i;
                phi[i] = i - 1;
            }
            for (int j = 1; j <= cnt && i * prime[j] < MAXN; ++j) {
                is_prime[i * prime[j]] = true;
                if (i % prime[j] == 0) {
                    phi[i * prime[j]] = phi[i] * prime[j];
                    break;
                } else {
                    phi[i * prime[j]] = phi[i] * (prime[j] - 1);
                }
            }
        }
        has_root[2] = has_root[4] = true;
        for (int i = 2; i <= cnt; ++i) {
            for (int j = prime[i]; j < MAXN; j *= prime[i]) has_root[j] = true;
            for (int j = 2 * prime[i]; j < MAXN; j *= prime[i]) has_root[j] = true;
        }
    }

    int qpow(int a, int b, int mod) {
        int res = 1;
        while (b) {
            if (b & 1) res = 1LL * res * a % mod;
            a = 1LL * a * a % mod;
            b >>= 1;
        }
        return res;
    }

    vector<int> get_factors(int x) {
        vector<int> factors;
        for (int i = 2; i * i <= x; ++i) {
            if (x % i == 0) {
                factors.push_back(i);
                while (x % i == 0) x /= i;
            }
        }
        if (x > 1) factors.push_back(x);
        return factors;
    }

    int find_min_root(int n) {
        int ph = phi[n];
        vector<int> factors = get_factors(ph);
        for (int g = 1; g < n; ++g) {
            if (__gcd(g, n) != 1) continue;
            bool ok = true;
            if (qpow(g, ph, n) != 1) ok = false;
            for (int p : factors) {
                if (qpow(g, ph / p, n) == 1) {
                    ok = false;
                    break;
                }
            }
            if (ok) return g;
        }
        return -1;
    }

    int main() {
        init();
        int T;
        scanf("%d", &T);
        while (T--) {
            int n, d;
            scanf("%d%d", &n, &d);
            if (!has_root[n]) {
                printf("0\n\n");
                continue;
            }
            int g = find_min_root(n);
            if (g == -1) {
                printf("0\n\n");
                continue;
            }
            int ph = phi[n];
            vector<int> roots;
            int current = g;
            for (int k = 1; k <= ph; ++k) {
                if (__gcd(k, ph) == 1) {
                    roots.push_back(current);
                }
                current = 1LL * current * g % n;
            }
            sort(roots.begin(), roots.end());
            printf("%d\n", (int)roots.size());
            for (int i = d - 1; i < (int)roots.size(); i += d) {
                printf("%d ", roots[i]);
            }
            printf("\n");
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先预处理欧拉函数 `phi` 和原根存在性标记 `has_root`。`find_min_root` 函数通过分解 \( \varphi(n) \) 的质因数，枚举候选数找到最小原根。主函数处理输入，根据原根存在性生成所有原根并按 \( d \) 输出。

---

<code_intro_selected>
接下来，我们将剖析优质题解中的核心代码片段，点出各自的亮点和关键思路。
</code_intro_selected>

**题解二（作者ix35）**  
* **亮点**：预处理原根存在性标记，代码结构清晰，变量命名直观。  
* **核心代码片段**：
    ```cpp
    void init() {
        phi[1] = 1;
        for (int i = 2; i <= MAXN-10; i++) {
            if (!q[i]) { pri[++tot] = i, phi[i] = i-1; }
            for (int j = 1; j <= tot && pri[j]*i <= MAXN-10; j++) {
                q[i*pri[j]] = 1;
                if (i % pri[j] == 0) {
                    phi[i*pri[j]] = phi[i] * pri[j];
                    break;
                }
                phi[i*pri[j]] = phi[i] * (pri[j]-1);
            }
        }
        rt[2] = rt[4] = 1;
        for (int i = 2; i <= tot; i++) {
            for (int j = 1; (1ll*j*pri[i]) <= MAXN-10; j*=pri[i]) { rt[j*pri[i]] = 1; }
            for (int j = 2; (1ll*j*pri[i]) <= MAXN-10; j*=pri[i]) { rt[j*pri[i]] = 1; }
        }
    }
    ```
* **代码解读**：  
  `init` 函数通过线性筛预处理欧拉函数 `phi` 和质数数组 `pri`，并标记所有可能的原根存在形式（\( p^\alpha \) 和 \( 2p^\alpha \)）。`rt` 数组记录每个数是否有原根，预处理后可 \( O(1) \) 判断。  
* 💡 **学习笔记**：预处理是提升效率的关键，线性筛同时计算欧拉函数和质数，节省时间。

**题解三（作者0xyz）**  
* **亮点**：随机化寻找最小原根，降低枚举次数；线性筛优化互质判断。  
* **核心代码片段**：
    ```cpp
    for (ll i = 1, r; i <= 200; i++)
        if (ksm((r = rand() % (m-1) + 1), n) == 1) {
            bool fl = 1;
            for (ll j = 1; j <= c; j++)
                if (ksm(r, n/s[j]) == 1) fl = 0;
            if (fl) { g = r; break; }
        }
    ```
* **代码解读**：  
  随机选择200个候选数，验证其是否为原根。由于原根密度较高（约4%），随机200次几乎必然找到最小原根，大幅降低最坏时间复杂度。  
* 💡 **学习笔记**：随机化是优化枚举的有效手段，适用于原根这种密度较高的问题。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解原根的寻找和生成过程，我设计了一个8位像素风格的动画演示方案，帮助大家“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素探险家的原根冒险`  
  * **核心演示内容**：展示原根存在性判断、\( \varphi(n) \) 分解质因数、最小原根寻找、所有原根生成的全过程。

  * **设计思路简述**：  
    采用FC红白机风格的像素画面，用不同颜色标记关键元素（如蓝色代表候选数，绿色代表原根）。通过动态分解、闪烁提示和音效反馈，强化关键步骤的记忆。例如，验证候选数时，若 \( g^{\varphi(n)/p} \equiv 1 \pmod{n} \) 失败，候选数会闪烁红色；成功则变绿。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
       屏幕左侧显示输入的 \( n \) 和 \( d \)，右侧为像素网格（代表模 \( n \) 的剩余系）。顶部控制面板包含“开始/暂停”“单步”“重置”按钮和速度滑块。

    2.  **原根存在性判断**：  
       动画展示 \( n \) 的分解过程（如 \( n=25 \) 分解为 \( 5^2 \)），若符合 \( p^\alpha \) 形式，屏幕中央弹出“原根存在！”的绿色提示；否则显示红色“无原根”。

    3.  **\( \varphi(n) \) 分解质因数**：  
       用像素块表示 \( \varphi(n) \)（如 \( \varphi(25)=20 \)），逐步分裂成质因数（20 → 2×2×5），每个质因数用不同颜色标记。

    4.  **最小原根寻找**：  
       候选数 \( g \) 从1开始逐个移动（像素小人），验证时计算 \( g^{\varphi(n)} \mod{n} \)（显示动态计算过程），若等于1则进入质因数验证环节。对每个质因数 \( p \)，计算 \( g^{\varphi(n)/p} \mod{n} \)，若结果≠1则通过，否则候选数变红并跳过。找到最小原根时，像素小人跳跃并播放“叮”声。

    5.  **生成所有原根**：  
       最小原根 \( g \) 作为起点，生成 \( g^1, g^2, ..., g^{\varphi(n)} \)（像素块从左到右排列）。与 \( \varphi(n) \) 互质的 \( k \) 对应的 \( g^k \) 变绿（原根），其余保持灰色。最后所有原根排序，按 \( d \) 间隔高亮输出。

    6.  **交互与反馈**：  
       支持单步执行，每步显示当前操作（如“验证 \( g=2 \)”）；自动播放时可调节速度。生成原根后，播放轻快的背景音乐，成功输出时显示“任务完成！”的庆祝动画。

<visualization_conclusion>
通过这样的像素动画，我们可以直观看到原根的每一步生成过程，理解数论性质如何转化为具体的算法步骤。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握原根的求解后，我们可以进一步思考其在数论中的其他应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    原根的核心思想（利用阶的性质生成剩余系）可迁移至离散对数、快速数论变换（NTT）等问题。例如，NTT需要模 \( p \) 存在原根，且 \( p-1 \) 含大2的幂次，这与原根存在定理密切相关。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P5285** - `[模板] 多项式快速幂`  
        * 🗣️ **推荐理由**：需要利用原根进行快速数论变换，巩固原根在多项式运算中的应用。
    2.  **洛谷 P3383** - `[模板] 线性筛素数`  
        * 🗣️ **推荐理由**：原根问题常依赖质数预处理，此题可强化线性筛的理解。
    3.  **洛谷 P1072** - `Huffman编码`  
        * 🗣️ **推荐理由**：虽然不直接涉及原根，但考察数论基础和算法优化，适合综合练习。

---

## 7\. 学习心得与经验分享 

<insights_intro>
部分题解作者分享了调试和优化经验，以下是值得借鉴的内容：
</insights_intro>

> **参考经验 (来自作者0xyz)**：“在寻找最小原根时，随机化枚举比顺序枚举更高效，因为原根密度较高（约4%），随机200次几乎必然找到。这大幅降低了最坏时间复杂度。”

**点评**：随机化是竞赛中常用的优化手段，尤其适用于解密度较高的问题。在原根问题中，利用随机化可避免顺序枚举的最坏情况（如最小原根很大时），提升效率。学习者在遇到类似问题时，可考虑结合数学性质（如原根密度）和随机化优化。

---

<conclusion>
本次关于“【模板】原根”的C++解题分析就到这里。希望这份指南能帮助大家理解原根的本质和求解方法。记住，数论问题的关键在于理解定理和灵活运用预处理、优化技巧。多练习、多思考，你会更深入地掌握这一领域！下次见~ 💪
</conclusion>

---
处理用时：225.41秒
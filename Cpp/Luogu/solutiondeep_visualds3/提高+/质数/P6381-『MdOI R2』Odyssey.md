# 题目信息

# 『MdOI R2』Odyssey

## 题目背景

超越音速的极限，不及瑰丽多变的极光；

微弱的脉冲，开拓原本一片混沌的天地；

沉郁的蓝缓缓闪动，史诗的红迎接巅峰；

血色的夕阳尽头，是将夜的星辰；

夜半的满天星空，也会被来自地狱的硝烟掩盖；

炽红炼狱消逝，只金色遗迹永存。

在这里等待着每一位的，都是一段艰苦而璀璨的旅程。

## 题目描述

若正整数 $a$ 与 $b$ 满足：

- $a$ 与 $b$ 的积是一个正整数的 $k$ 次方，即存在正整数 $c$ 使得 $ab=c^k$。

那么我们称 $(a,b)$ 为一组**完美数对**。

---

有一个包含 $n$ 个结点和 $m$ 条边的**有向无环图**，这张图中的每条边都有权值和长度两个属性。

如果一条路径 $P$ 满足**以下条件之一**，则称其为一条**完美路径**：

- $P$ 中仅包含一条边。

- $P$ 从其起点开始依次为 $e_1, e_2, e_3, \ldots e_p$ 这 $p\ (p\ge 2)$ 条边，对于任意的 $1\leq i\leq p-1$，$e_i$ 的权值和 $e_{i+1}$ 的权值组成完美数对。

你需要求出图中最长完美路径的长度，一条路径的长度定义为这条路径上所有边的长度之和。

## 说明/提示

【帮助与提示】  

为方便选手测试代码，本题额外提供两组附加样例供选手使用。  

[样例输入1](https://www.luogu.com.cn/paste/wx1lz6m2) [样例输出1](https://www.luogu.com.cn/paste/28xe7f0x)      

[样例输入2](https://www.luogu.com.cn/paste/efgwngs5) [样例输出2](https://www.luogu.com.cn/paste/5hcpoayt)   

----

【样例解释】

样例中给出的有向无环图如图所示，其中边上的红色数字为边的权值，黑色数字为边的长度：

![](https://cdn.luogu.com.cn/upload/image_hosting/w6x03ksd.png)

最长完美路径为 $2\to 5\to 3$，因为这两条边的权值 $2$ 和 $18$ 满足 $2\times 18=6^2$，是完美数对，此路径长度为 $5+9=14$。

此外，$2\to 1\to 4\to 3,\ \ 2\to 4\to 3,\ \ 1\to 5\to 3$ 等也是完美路径，但不是最长的。

图中，$2\to 1\to 5\to 3$ 长度为 $15$，是一条更长的路径，但它并不是完美路径，因为前两个边权 $24$ 和 $8$ 的乘积为 $192$，不是正整数的平方，即 $(24,8)$ 不是完美数对。

---

【数据范围】

**本题采用捆绑测试。**

对于 $100\%$ 的数据：$1\leq n\leq 10^5,\ \ 1\leq m\leq 2\times 10^5,\ \ 1\leq k\leq 10,\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^5,\ \ 1\leq l\leq 10^4$。

给出的图**不保证弱连通**，图中从一个点到另一个点**可能**存在多条边，但保证给出的图是有向无环图。

| 子任务编号 | $n\leq$ |     $m\leq$      | $w\leq$ | $k\leq$ |  特殊性质  | 分值 |
| :--------: | :-----: | :--------------: | :-----: | :-----: | :--------: | :--: |
| Subtask 1  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $1$   |     无     | $18$ |
| Subtask 2  |  $10$   |       $10$       |  $100$  |  $2$   |     无     | $12$ |
| Subtask 3  |  $600$  | $1.5\times 10^3$ | $10^3$  |   $2$   |     无     | $10$ |
| Subtask 4  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   | $w$ 为素数 | $15$ |
| Subtask 5  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   |     无     | $15$ |
| Subtask 6  |  $600$  | $1.5\times 10^3$ | $10^3$  |  $5$   |     无     | $10$ |
| Subtask 7  | $10^5$  |  $2\times 10^5$  | $10^5$  |  $10$   |     无     | $20$ |



## 样例 #1

### 输入

```
5 7 2
2 5 2 5
5 3 18 9
2 4 6 7
4 3 6 3
2 1 24 2
1 4 6 8
1 5 8 4```

### 输出

```
14```

# AI分析结果



---

# 💡 Kay的C++算法解析：『MdOI R2』Odyssey 深入学习指南 💡

<introduction>
今天我们要一起攻克这道结合数论与图论的题目——『MdOI R2』Odyssey。通过分析题目核心、拆解解题思路，掌握如何在有向无环图中找到最长完美路径。让我们开始吧！
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（DAG上的动态规划） + 数论（质因数分解与模运算）

🗣️ **初步分析**：  
题目要求找到有向无环图（DAG）中最长的完美路径，其中相邻边的权值乘积为k次方数。核心在于将边权转换为“简化形式”，并在DAG上通过动态规划（DP）寻找最长路径。

简单来说，完美数对的条件可以转化为：两数的质因数指数之和是k的倍数。例如，k=2时，边权2（分解为2¹）的互补权值是2¹（因为1+1=2，是2的倍数），所以2和2的乘积是4（2²），是完美数对。

**核心思路**：  
1. **边权简化**：对每个边权分解质因数，将各质因数的指数模k，得到“简化权值”。  
2. **互补权值**：每个简化权值对应唯一的“互补权值”（各指数为k-当前指数模k），使得两者乘积为k次方数。  
3. **DAG上的DP**：在DAG的拓扑序中，维护每个节点在特定简化权值下的最长路径长度，状态转移时用互补权值连接相邻边。

**可视化设计**：  
采用8位像素风格动画，DAG节点用方块表示，边用箭头连接。边权用不同颜色标记简化权值（如红色代表权值A，蓝色代表权值B），互补权值用同色系渐变。动画中，拓扑排序过程用“像素指针”逐个点亮节点，状态转移时边权颜色渐变，路径长度数字动态更新，关键步骤伴随“叮”的音效提示。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰度、代码规范性、算法有效性等维度评估，以下题解表现突出（≥4星）：
</eval_intro>

**题解一：作者 BFqwq**  
* **点评**：此题解思路完整，结合了质因数分解与分层图拓扑排序。通过预处理质数表快速分解边权，计算简化权值和互补权值，并用分层图处理状态转移。代码规范（如变量名`f`表示互补权值），边界处理严谨（如特判权值溢出），对大规模数据优化（如清空邻接表避免重复计算），实践参考价值高。

**题解二：作者 under_the_time**  
* **点评**：此题解简洁明了，直接使用map存储状态（节点+简化权值），动态规划逻辑清晰。特别处理了k=1的情况（所有边权互补），代码可读性强（如函数`cal1`和`cal2`分别计算互补权值和简化权值），适合新手学习。

**题解三：作者 一扶苏一**  
* **点评**：此题解采用双模数哈希存储简化权值，避免了直接存储质因数指数的高复杂度。拓扑排序与DP结合紧密，状态转移方程明确（`f[u][k] = max(f[u][k], l + f[v][j]`），代码模块化（如`Make_hash`函数处理哈希），体现了优秀的编程规范。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于处理数论条件与DAG动态规划的结合。以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **关键点1：边权的质因数分解与简化**  
    * **分析**：需要将边权分解为质因数乘积，并对各指数模k。例如，边权18（2¹×3²）在k=2时，指数模2后为2¹×3⁰=2，互补权值为2¹（k-1=1），即2×2=4=2²，满足条件。  
    * 💡 **学习笔记**：预处理质数表可加速分解过程，模k后的指数只需保留0到k-1的值，简化计算。

2.  **关键点2：状态表示与存储**  
    * **分析**：状态为（节点，简化权值），但权值可能很大（如1e5），直接数组存储不可行。优质题解中使用map或哈希表（如`unordered_map<int, int> dp[N]`）存储，键为简化权值，值为最长路径长度。  
    * 💡 **学习笔记**：哈希表适合处理稀疏状态，避免内存浪费，但需注意哈希冲突（可用双模数哈希优化）。

3.  **关键点3：DAG上的动态规划**  
    * **分析**：DAG的拓扑序保证了处理节点时，其前驱节点的状态已计算完毕。状态转移时，当前边的互补权值对应下一条边的简化权值，更新路径长度。  
    * 💡 **学习笔记**：拓扑排序是DAG问题的“钥匙”，确保状态转移的无后效性。

### ✨ 解题技巧总结
- **问题分解**：将复杂条件（k次方数）转化为质因数指数的模k条件，简化问题。  
- **预处理优化**：预处理质数表加速质因数分解，减少重复计算。  
- **状态压缩**：用哈希表存储状态，避免高维数组的内存问题。  
- **边界处理**：特判k=1（所有边权互补）、权值溢出（互补权值>1e5时视为终点）等情况。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，结合了质因数分解、拓扑排序与动态规划，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了BFqwq和under_the_time的题解思路，处理了质因数分解、权值简化与互补计算，并在DAG上进行拓扑排序动态规划。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 1e5 + 5, MAXW = 1e5;
    int n, m, k;
    vector<pair<int, int>> primes; // 预处理质数表（示例简化）

    // 预处理质数表（埃氏筛）
    void sieve() {
        vector<bool> is_prime(MAXW + 1, true);
        for (int i = 2; i <= MAXW; ++i) {
            if (is_prime[i]) {
                primes.emplace_back(i, 0);
                for (int j = 2 * i; j <= MAXW; j += i)
                    is_prime[j] = false;
            }
        }
    }

    // 计算简化权值和互补权值
    pair<int, int> get_vals(int w) {
        int simplified = 1, complement = 1;
        for (auto [p, _] : primes) {
            if (p * p > w) break;
            int cnt = 0;
            while (w % p == 0) {
                w /= p;
                cnt++;
            }
            cnt %= k;
            if (cnt == 0) continue;
            // 简化权值：p^cnt
            for (int i = 0; i < cnt; ++i) simplified *= p;
            // 互补权值：p^(k - cnt)
            for (int i = 0; i < k - cnt; ++i) {
                complement *= p;
                if (complement > MAXW) return {simplified, -1}; // 溢出标记为-1
            }
        }
        if (w > 1) {
            // 处理剩余大质数
            if (k != 1) {
                simplified *= w;
                for (int i = 0; i < k - 1; ++i) {
                    complement *= w;
                    if (complement > MAXW) return {simplified, -1};
                }
            }
        }
        return {simplified, complement};
    }

    struct Edge { int to, simplified, complement, len; };
    vector<Edge> g[MAXN];
    int in_degree[MAXN];
    unordered_map<int, int> dp[MAXN]; // dp[u][s] 表示到u节点，最后边简化权值为s的最长长度

    int main() {
        sieve();
        cin >> n >> m >> k;
        for (int i = 0; i < m; ++i) {
            int u, v, w, l;
            cin >> u >> v >> w >> l;
            auto [s, c] = get_vals(w);
            g[u].push_back({v, s, c, l});
            in_degree[v]++;
        }

        queue<int> q;
        for (int i = 1; i <= n; ++i)
            if (in_degree[i] == 0) q.push(i);

        int ans = 0;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (auto [v, s, c, l] : g[u]) {
                // 当前边的简化权值为s，互补权值为c
                // 下一条边需要以s为互补权值，即下一条边的简化权值应为s的互补（即当前边的c）
                int prev_max = (c == -1) ? 0 : dp[u][c]; // c=-1时无前置边
                dp[v][s] = max(dp[v][s], prev_max + l);
                ans = max(ans, dp[v][s]);
                if (--in_degree[v] == 0) q.push(v);
            }
        }
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先预处理质数表，然后对每条边计算简化权值和互补权值。通过拓扑排序处理DAG，维护每个节点在特定简化权值下的最长路径长度（使用`unordered_map`存储状态）。状态转移时，当前边的互补权值对应下一条边的简化权值，更新路径长度，最终输出最大值。

---
<code_intro_selected>
接下来，我们赏析优质题解中的核心代码片段：
</code_intro_selected>

**题解一：作者 under_the_time**  
* **亮点**：代码简洁，直接使用`map`存储状态，清晰处理了k=1的特判。  
* **核心代码片段**：
    ```cpp
    int cal1(int w) { // 互补权值
        int res = 1;
        for (int i = 2, cnt; i * i <= w; i++) {
            cnt = 0;
            while (w % i == 0) w /= i, cnt++;
            cnt %= k; 
            if (cnt) {
                cnt = k - cnt;
                while (cnt--) {
                    res *= i;
                    if (res > maxl) return -1;
                }
            }
        }
        if (w > 1) {
            int cnt = k - 1;
            while (cnt--) {
                res *= w;
                if (res > maxl) return -1;
            }
        }
        return res;
    }
    ```
* **代码解读**：  
  `cal1`函数计算互补权值。对每个质因数分解后，指数模k，若余数不为0，则互补权值的指数为k-余数。若计算过程中权值超过1e5（`maxl`），返回-1表示无法找到下一条边。  
  *思考*：为什么要特判权值溢出？因为题目中边权最大为1e5，溢出的互补权值无法作为下一条边的权值，此时当前边只能是路径终点。

* 💡 **学习笔记**：互补权值的计算需考虑溢出，避免无效状态。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解边权转换与状态转移过程，我们设计一个“像素探险家”主题的8位风格动画：
</visualization_intro>

  * **动画演示主题**：像素探险家的完美路径之旅  
  * **核心演示内容**：展示DAG的拓扑排序过程，边权转换（简化权值→互补权值），以及动态规划中路径长度的更新。

  * **设计思路**：  
    8位像素风格（类似FC游戏）营造轻松氛围，节点用彩色方块表示，边用箭头连接。边权用不同颜色标记（如红色代表简化权值A，蓝色代表互补权值B）。关键步骤（如权值转换、状态转移）用闪烁、音效（“叮”）提示，增强记忆点。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：  
       - 屏幕左侧显示DAG网格（节点为16x16像素方块，颜色随机但固定），右侧显示控制面板（单步/自动播放按钮、速度滑块）。  
       - 顶部显示当前处理的节点和边权信息，底部显示当前最长路径长度。  
       - 播放8位风格背景音乐（如《超级马力欧》经典旋律）。

    2. **边权转换演示**：  
       - 点击“开始”，每条边的权值分解质因数，指数模k的过程用像素文字弹出（如“18=2¹×3² → 简化权值2¹×3⁰=2”）。  
       - 互补权值计算用渐变动画（红色边权→蓝色互补权值），伴随“唰”的音效。

    3. **拓扑排序与状态转移**：  
       - 拓扑序节点按顺序被“像素指针”点亮（绿色闪光），处理该节点的所有出边。  
       - 对于每条边，检查其互补权值是否匹配下一个节点的简化权值：匹配时，路径长度更新（数字从旧值渐变为新值），并播放“叮”音效；不匹配时，边权灰色淡化。

    4. **结果展示**：  
       - 最长路径用金色箭头高亮，总长度用大字号显示，伴随“胜利”音效（如《塞尔达传说》胜利旋律）。  
       - 支持“回放”功能，可重新观看关键步骤。

  * **旁白提示**：  
    - “看！这条边的权值18分解后，简化权值是2，互补权值也是2，所以它们可以连在一起～”  
    - “现在处理节点2，它的出边权值是2，互补权值是2，下一个节点5的边权如果是2，就能形成完美路径啦！”

<visualization_conclusion>
通过这样的动画，我们可以直观看到边权转换、拓扑排序和状态转移的全过程，轻松理解算法核心逻辑！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以拓展到以下场景和题目，巩固数论与图论结合的解题能力：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的核心是“条件约束下的DAG最长路径”，类似问题包括：  
    - 带权值互质约束的路径问题（如相邻边权互质）。  
    - 带颜色/类型约束的路径问题（如红蓝边交替）。  
    - 其他数论约束（如相邻边权和为质数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1113 杂务**  
        *推荐理由*：DAG最长路径的基础题，适合练习拓扑排序与动态规划。  
    2.  **洛谷 P1603 斯诺克**  
        *推荐理由*：质因数分解与组合计数的结合题，巩固数论基础。  
    3.  **洛谷 P3376 网络流模板**  
        *推荐理由*：DAG上的最大流问题，理解图论中不同问题的建模方式。

---

## 7\. 学习心得与经验分享

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有启发：
</insights_intro>

> **参考经验 (来自 BFqwq)**：“在分层图拓扑时，若x=f_x会重复建图，需开双倍数组。之前数组开小导致错误，后来调整后通过。”

**点评**：这位作者的经验提醒我们，处理图论问题时需注意节点/边的数量估计，尤其是分层图或状态扩展时，数组大小要留足余量。调试时，打印中间变量（如节点入度、状态值）能有效定位问题。

---

<conclusion>
通过这篇指南，我们理解了如何将数论条件转化为图论问题，掌握了DAG上动态规划的核心技巧。记住，多动手写代码、调试，遇到问题时分解步骤、逐步验证，你一定能更熟练地解决类似问题！下次见～ 💪
</conclusion>

---

---
处理用时：192.74秒
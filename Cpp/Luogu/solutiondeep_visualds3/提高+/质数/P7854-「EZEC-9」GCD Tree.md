# 题目信息

# 「EZEC-9」GCD Tree

## 题目背景

规定 $\gcd(x,y)$ 表示 $x,y$ 的最大公约数，$\operatorname{lca}(x,y)$ 表示 $x$ 号节点和 $y$ 号节点的最近公共祖先。

## 题目描述

给你 $n$ 个点，编号分别为 $1,2,\ldots,n$，点权分别为 $a_1,a_2,\ldots,a_n$。

请你用这 $n$ 个点构造一棵树，使得 $\forall 1 \le i < j \le n$，$\gcd(a_i, a_j) = a_{\operatorname{lca}(i, j)}$。

若无解，报告之，否则输出树的形态。

## 说明/提示

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（5 points）：$n = 2$。
-  Subtask 2（5 points）：所有 $a_i$ 均相等。
-  Subtask 3（5 points）：$n \le 5$。
-  Subtask 4（10 points）：保证有解。
-  Subtask 5（15 points）：$n \le 100$。
-  Subtask 6（15 points）：$n \le 10^3$。
-  Subtask 7（15 points）：$n \le 3 \times 10^3$。
-  Subtask 8（30 points）：无特殊限制。

对于 $100 \%$ 的数据，$2 \le n \le 10^5$，$1 \le a_i \le 10^6$。

## 样例 #1

### 输入

```
5
1 2 3 4 5
```

### 输出

```
0 1 1 2 1
```

## 样例 #2

### 输入

```
5
1 2 3 4 6
```

### 输出

```
-1
```

# AI分析结果



---

# 💡 Kay的C++算法解析：「EZEC-9」GCD Tree 深入学习指南 💡

<introduction>
今天我们来一起分析“「EZEC-9」GCD Tree”这道C++编程题。这道题要求我们构造一棵树，使得任意两点的GCD等于它们的最近公共祖先（LCA）的点权。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与验证（结合数论因数分解、树结构构造）`

🗣️ **初步分析**：
解决这道题的关键在于构造满足条件的树结构，并验证其合法性。简单来说，我们需要先通过数论中的因数关系确定每个节点的父节点（确保父节点的点权是当前节点点权的最大因数），然后验证这棵树是否满足所有点对的GCD等于其LCA的点权。

- **题解思路**：多数题解采用“构造+验证”的两步法：
  1. **构造树**：将点权去重后，按从大到小枚举每个点权，将其倍数的未设置父节点的点的父节点设为当前点（如littleKtian的做法）。
  2. **验证树**：检查是否存在质因数冲突（如LZDQ的质因数集合连通性验证）或GCD不匹配的情况（如Ecrade_的质因数链判断）。
- **核心难点**：如何正确构造父节点关系（避免遗漏或错误连接）、如何高效验证树的合法性（避免O(n²)复杂度）。
- **可视化设计思路**：采用8位像素风格动画，用不同颜色的方块表示节点，动态展示父节点连接过程（如节点A滑向父节点B），并在验证时高亮冲突的质因数集合（如红色闪烁标记冲突点）。关键步骤（如父节点连接、质因数检查）伴随“叮”的音效，完成验证后播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选出以下优质题解（≥4星），供大家参考：
</eval_intro>

**题解一：作者：littleKtian**
* **点评**：此题解思路简洁直接，通过枚举倍数构造父节点，并利用DFS序验证子树关系。代码中使用邻接表存储树结构，变量命名清晰（如`fa[]`表示父节点，`hx[]`表示DFS序），边界处理严谨（如去重后检查总边数是否为n-1）。其亮点在于将构造与验证合并（枚举因数检查子树连通性），复杂度为O(n log n)，适合竞赛场景。

**题解二：作者：LZDQ**
* **点评**：此题解结合质因数分解，通过记录每个质因数的出现节点并验证其是否在一条链上，巧妙解决了验证问题。代码中`cnt[]`和`mx[]`分别统计质因数出现次数和最深节点，变量设计合理（如`dep[]`记录深度）。其亮点在于将复杂的GCD验证转化为质因数链的连通性检查，降低了验证复杂度。

**题解三：作者：chager**
* **点评**：此题解利用线性筛预处理因数，并通过递归分解质因数构造父节点。代码中`mip[]`存储最小质因数，`dfs1`递归生成因数，逻辑清晰。其亮点在于预处理阶段的高效因数分解（O(n log n)），为后续构造父节点提供了有力支持。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下几个核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何正确构造父节点关系？**
    * **分析**：每个节点的父节点必须是其点权的最大因数（且在给定的点权中存在）。例如，点权为6的节点，其父节点应是点权为3或2中最大的那个（若存在）。优质题解通常通过枚举倍数（如littleKtian）或预处理因数（如chager）来找到最大因数。
    * 💡 **学习笔记**：构造父节点时，按点权从大到小处理，确保每个节点的父节点是当前最大的可行因数。

2.  **关键点2：如何高效验证树的合法性？**
    * **分析**：验证的核心是确保任意两点的GCD等于其LCA的点权。优质题解（如LZDQ）通过质因数分解，检查每个质因数对应的节点是否在一条链上（即祖孙关系）。若存在质因数在两个不相关的子树中出现，则树不合法。
    * 💡 **学习笔记**：质因数的连通性是验证的关键，每个质因数的所有出现节点必须形成一条链。

3.  **关键点3：如何处理重复点权的情况？**
    * **分析**：重复点权的节点需形成一条链（如第一个出现的节点为链顶，后续节点连接前一个）。优质题解（如littleKtian）通过`xh[]`数组记录每个点权的首个节点，后续节点直接连接该节点。
    * 💡 **学习笔记**：重复点权的处理需优先连接链顶，避免破坏树的结构。

### ✨ 解题技巧总结
- **问题分解**：将问题拆分为“构造树”和“验证树”两步，分别处理。
- **因数预处理**：利用线性筛或枚举倍数预处理因数，快速找到最大因数。
- **质因数链验证**：通过记录质因数的出现节点，验证其是否在一条链上，避免暴力枚举所有点对。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解思路的通用核心C++实现。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了littleKtian和LZDQ的思路，先构造父节点，再通过质因数链验证合法性，适合竞赛场景。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 1e5 + 5;
    const int MAXV = 1e6 + 5;

    int n, a[MAXN], fa[MAXN], xh[MAXV], cnt[MAXV], mx[MAXV], dep[MAXV];
    vector<int> children[MAXV];

    int main() {
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i) {
            scanf("%d", &a[i]);
            if (xh[a[i]]) fa[i] = xh[a[i]]; // 重复点权直接连链顶
            else xh[a[i]] = i;
        }

        // 构造父节点：从大到小枚举点权，连接倍数节点
        for (int i = MAXV; i >= 1; --i) {
            if (!xh[i]) continue;
            for (int j = 2 * i; j <= MAXV; j += i) {
                if (xh[j] && !fa[xh[j]]) {
                    fa[xh[j]] = xh[i];
                    children[xh[i]].push_back(xh[j]);
                }
            }
        }

        // 检查边数是否为n-1（树的必要条件）
        int edge_cnt = 0;
        for (int i = 1; i <= n; ++i) if (fa[i]) edge_cnt++;
        if (edge_cnt != n - 1) {
            puts("-1");
            return 0;
        }

        // 计算深度并记录质因数信息
        for (int i = 1; i <= n; ++i) {
            if (!fa[i]) dep[i] = 1; // 根节点深度为1
            else dep[i] = dep[fa[i]] + 1;
            int c = a[i] / a[fa[i]]; // 与父节点的商
            if (c == 1) continue; // 根节点或重复点权
            cnt[c]++;
            if (dep[i] > dep[mx[c]]) mx[c] = i;
        }

        // 验证每个质因数是否在一条链上
        for (int p = 2; p <= MAXV; ++p) {
            int total = 0, deepest = 0;
            for (int j = p; j <= MAXV; j += p) {
                total += cnt[j];
                if (dep[mx[j]] > dep[deepest]) deepest = mx[j];
            }
            int check = 0;
            for (int u = deepest; u; u = fa[u]) {
                int c = a[u] / a[fa[u]];
                if (c % p == 0) check++;
            }
            if (check != total) {
                puts("-1");
                return 0;
            }
        }

        // 输出父节点
        for (int i = 1; i <= n; ++i) printf("%d ", fa[i]);
        return 0;
    }
    ```
* **代码解读概要**：该代码首先处理重复点权，构造父节点（按点权从大到小连接倍数节点），然后检查边数是否合法。接着计算每个节点的深度，并记录与父节点的商的质因数信息。最后验证每个质因数的出现节点是否在一条链上，确保树的合法性。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者：littleKtian**
* **亮点**：通过DFS序验证子树关系，确保构造的树满足子树包含所有倍数节点。
* **核心代码片段**：
    ```cpp
    void dfs(int w) {
        si[w] = 1, hx[w] = ++dfn;
        for (int o_o = lw[w]; o_o; o_o = bi[o_o][0]) {
            int v = bi[o_o][1];
            dfs(v), si[w] += si[v];
        }
    }
    bool gra(const int &x, const int &y) {
        return hx[x] <= hx[y] && hx[y] < hx[x] + si[x];
    }
    ```
* **代码解读**：`dfs`函数计算每个节点的子树大小（`si[]`）和DFS序（`hx[]`），`gra`函数通过DFS序判断节点y是否在节点x的子树中。这一步是验证构造的树是否满足“所有倍数节点在子树中”的关键。
* 💡 **学习笔记**：DFS序是判断子树关系的高效方法，利用时间戳范围可快速验证节点包含关系。

**题解二：作者：LZDQ**
* **亮点**：通过质因数的深度和出现次数验证链的连通性。
* **核心代码片段**：
    ```cpp
    for (int i = 2; i <= m; i++) {
        int s = 0, t = 0;
        for (int j = i; j <= m; j += i) {
            s += cnt[j];
            if (dep[t] < dep[mx[j]]) t = mx[j];
        }
        while (t > 1) {
            if (t / fw[t] % i == 0) s--;
            t = fw[t];
        }
        if (s) return puts("-1"), 0;
    }
    ```
* **代码解读**：枚举每个质因数i，统计其所有倍数的出现次数（`s`），找到最深节点`t`。然后从`t`向上跳父节点，检查路径上的质因数i的出现次数是否等于`s`。若不等，说明质因数i的节点不在一条链上，树不合法。
* 💡 **学习笔记**：质因数的链连通性是验证的核心，通过深度和路径跳转可高效完成。

**题解三：作者：chager**
* **亮点**：利用线性筛预处理最小质因数，递归生成因数。
* **核心代码片段**：
    ```cpp
    void init() {
        isp[1] = 1;
        mip[1] = 1;
        for (int i = 2; i <= 1e6; i++) {
            if (!isp[i]) {
                p[++totp] = i;
                mip[i] = i;
            }
            for (int j = 1; j <= totp; j++) {
                if (i * p[j] > 1e6) break;
                isp[i * p[j]] = 1;
                mip[i * p[j]] = p[j];
                if (i % p[j] == 0) break;
            }
        }
    }
    ```
* **代码解读**：`init`函数预处理每个数的最小质因数（`mip[]`），用于快速分解质因数。这一步是后续递归生成因数的基础，确保因数分解的高效性。
* 💡 **学习笔记**：线性筛预处理最小质因数是数论问题中的常用技巧，可将因数分解复杂度降至O(log n)。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解树的构造和验证过程，我设计了一个8位像素风格的动画演示方案，让我们“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素树构建与验证`（复古FC游戏风格）

  * **核心演示内容**：展示节点连接（构造树）和质因数链验证（验证树）的全过程。

  * **设计思路简述**：采用8位像素风格（红/绿/蓝三色调色板），用不同颜色的方块表示节点（如根节点为金色，其他节点为蓝色）。关键操作（如父节点连接、质因数冲突）伴随“叮”或“滴”的音效，增强操作记忆。每完成一个子树构造或验证，播放“过关”音效，增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧为“树构造区”（像素网格，节点用方块表示，边用虚线连接）。
          * 右侧为“质因数验证区”（展示当前处理的质因数及其节点）。
          * 控制面板包含“单步”“自动播放”“重置”按钮和速度滑块。

    2.  **构造树（父节点连接）**：
          * 按点权从大到小遍历节点（如点权5→4→3→2→1）。
          * 当前处理节点（如点权4）高亮（黄色闪烁），其倍数节点（如点权8、12）未连接父节点时，从当前节点滑向倍数节点（蓝色方块滑动），伴随“连接”音效。
          * 重复点权的节点（如另一个点权4）直接连接链顶（红色箭头指向链顶节点）。

    3.  **验证树（质因数链检查）**：
          * 枚举质因数（如p=2），收集所有包含p的节点（如点权4、6、8）。
          * 最深节点（如点权8）高亮（绿色闪烁），从该节点向上跳父节点（白色箭头逐步移动），统计路径上的p出现次数。
          * 若次数与总次数一致（合法），节点变亮；否则冲突节点（如点权6）红色闪烁，播放“错误”音效。

    4.  **目标达成**：
          * 若树合法，所有节点变为绿色，播放“胜利”音效，屏幕显示“成功！”；若不合法，冲突节点持续闪烁，显示“失败！”。

  * **旁白提示**：
      * （构造时）“当前处理点权4，它的倍数节点8还未连接，将8的父节点设为4。”
      * （验证时）“检查质因数2的节点是否在一条链上，最深节点是8，向上跳父节点4、2、1……”

<visualization_conclusion>
通过这样的像素动画，我们可以直观看到树的构造过程和验证逻辑，理解每个步骤的作用和意义。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以进一步思考树结构和数论结合的问题，以下是相关练习推荐：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 本题的“构造+验证”思路适用于所有需要满足特定条件的树结构问题（如最小生成树、LCA约束树）。
      * 数论中的因数分解和质因数分析，可迁移到涉及GCD、LCM的树问题中（如求满足GCD条件的路径数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1352 没有上司的舞会**
          * 🗣️ **推荐理由**：考察树的动态规划，与本题的树结构分析结合，提升树形DP能力。
    2.  **洛谷 P2016 战略游戏**
          * 🗣️ **推荐理由**：涉及树的最小顶点覆盖，强化树的结构理解和贪心策略应用。
    3.  **洛谷 P3384 树链剖分**
          * 🗣️ **推荐理由**：学习树链剖分技术，用于高效处理树上路径查询，与本题的LCA验证相关。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，以下是有价值的参考：
</insights_intro>

> **参考经验 (来自 Ecrade_)**：“在构造父节点时，最初未考虑重复点权的处理，导致树结构错误。后来通过记录每个点权的首个节点，将重复节点直接连接链顶，解决了问题。”
>
> **点评**：重复点权的处理是本题的一个细节陷阱。作者的经验提醒我们，在处理相同值的节点时，需优先连接链顶，避免破坏树的层级结构。这对于处理类似的“重复元素”问题（如数组中的重复值合并）有重要参考价值。

-----

<conclusion>
本次关于“「EZEC-9」GCD Tree”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握树构造与数论结合的解题技巧。记住，多动手实践、多思考质因数和树结构的关系，是提升这类问题解题能力的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：158.88秒
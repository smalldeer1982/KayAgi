# 题目信息

# [KOI 2022 Round 2] 食事计划

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

在 KOI 国家，铁柱所在的地方有 $N$ 个餐厅。每个餐厅只售卖一种食物，食物的类型通过整数 $A_i$ 来表示，$i$（$1 \leq i \leq N$）。

铁柱计划访问所有的餐厅，并为自己制定一个食事计划。铁柱的食事计划可以用从 $1$ 到 $N$ 的整数排列 $P$ 来表示。举例来说，如果 $P = [2, 4, 3, 1]$，这意味着铁柱将依次访问餐厅 2、4、3 和 1。

由于铁柱不希望连续吃相同类型的食物，所以在他的食事计划中，连续的两个餐厅必须提供不同类型的食物。也就是说，对于 $i = 1, 2, \dots, N-1$，$A_{P_i} \neq A_{P_{i+1}}$ 必须成立，而符合这一条件的食事计划被称为合法食事计划。

例如，假设 $N = 9$，且提供的食物类型是 $A = [1, 1, 1, 2, 2, 3, 3, 4, 3]$，则如果铁柱的食事计划是 $P = [3, 4, 1, 5, 6, 2, 7, 8, 9]$，那么计划中的每两个相邻餐厅的食物类型都不同，符合条件。

若铁柱的食事计划是 $P = [1, 4, 2, 5, 6, 3, 7, 8, 9]$，这也是一个合法的食事计划，并且是按字典顺序最前的合法计划。

然而，若食物类型是 $A = [1, 1, 1]$，无论怎样安排食事计划，都无法满足“连续两餐不同类型”的要求。

当给定 $N$ 个餐厅的食物类型时，如果无法制定合法的食事计划，则输出 `-1`；否则，输出字典序最前的合法食事计划。

## 说明/提示

**约束条件**

- $1 \leq N \leq 300\,000$
- $1 \leq A_i \leq N$

**子任务**

1. （5 分）$N \leq 8$
2. （12 分）$N \leq 20$
3. （32 分）$N \leq 5\,000$
4. （51 分）无额外约束条件

## 样例 #1

### 输入

```
9
1 1 1 2 2 3 3 4 3```

### 输出

```
1 4 2 5 6 3 7 8 9```

## 样例 #2

### 输入

```
3
1 1 1```

### 输出

```
-1```

# AI分析结果

# 💡 Kay的C++算法解析：食事计划 深入学习指南 💡

今天我们来一起分析“食事计划”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心 + 编程技巧应用（数据结构维护）

🗣️ **初步分析**：
解决“食事计划”的关键，就像**搭积木盖房子**——每次选最小的积木（字典序最小的餐厅），但必须保证剩下的积木能拼成完整的房子（后续能形成合法计划）。这里的“贪心”核心就是**“当前最优 + 未来可行”**：每次选字典序最小的餐厅，但要先检查选它之后，剩下的食物类型是否还能满足“众数不超过剩余长度的一半”（否则后续肯定无解）。

本题的核心思路是：
1. **先判无解**：如果原序列中某个食物类型的出现次数超过 $\lceil n/2 \rceil$，直接输出-1（经典结论，就像“如果红色积木超过一半，永远无法交替摆放”）。
2. **贪心选餐厅**：每一步优先选：
   - 若当前众数的剩余次数超过剩余长度的一半，必须选这个众数（否则后续无解）；
   - 否则选**字典序最小**且与前一个餐厅类型不同的餐厅。

**核心难点**：如何高效维护“当前可用的最小字典序餐厅”和“各类型的剩余次数”？解决方案是用`set`数据结构：一个`set`维护各类型的“剩余次数+最小位置”（快速找当前众数），另一个`set`维护所有可用餐厅的“最小位置”（快速找字典序最小的餐厅）。

**可视化设计思路**：我们会做一个**8位像素风的“餐厅探险”游戏**——用不同颜色的像素块代表不同类型的餐厅，选餐厅时该像素块会“闪烁+滑入”选中区域，同时播放“叮”的音效；剩余餐厅的众数用“黄色边框”高亮，让你直观看到“必须选它”的情况。控制面板有“单步执行”“自动播放”，自动播放时像“贪吃蛇AI”一样一步步选餐厅，完成后有“胜利音效”~


## 2. 精选优质题解参考

为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性与优化程度、实践价值等方面，筛选了以下评分较高的题解：

**题解一：(来源：Mirasycle)**
* **点评**：这份题解的思路“快、准、狠”——用两个`set`完美解决了“维护众数”和“找最小字典序”的问题，时间复杂度是$O(n\log n)$（对于$3e5$的数据完全够用）。代码里的`op`函数封装了“选餐厅+更新数据结构”的逻辑，非常简洁；`main`函数的循环逻辑清晰，先检查是否必须选众数，否则选最小的可用餐厅。唯一的小门槛是需要理解`set`里的自定义排序（按“次数从多到少+位置从小到大”），但一旦想通，整个代码就像“搭好的积木”一样顺理成章。

**题解二：(来源：Eason2009)**
* **点评**：这个题解用了“线段树套set”的结构，思路和题解一类似，但时间复杂度是$O(n\log^2 n)$（稍慢但也能过）。它的优点是“线段树”可以更灵活地查询“某个区间内的最小位置”，但对于本题来说，题解一的`set`已经足够高效。如果你想练习“线段树套数据结构”的技巧，这个题解值得参考~


## 3. 核心难点辨析与解题策略

在解决这个问题时，大家常遇到3个“拦路虎”，我结合优质题解总结了应对方法：

1. **难点1：如何判定“当前选这个数，后续会不会无解？”**
   - **分析**：根据经典结论，若剩余$k$个餐厅，某类型的剩余次数超过$\lceil k/2 \rceil$，后续必无解。所以每一步都要检查当前众数的剩余次数是否超过$\lceil (n-i+1)/2 \rceil$（$i$是当前步骤）。
   - 💡 **学习笔记**：“未来可行性”是贪心的关键——不能只看当前好，还要保证后面能走通！

2. **难点2：如何快速找到“字典序最小的可用餐厅”？**
   - **分析**：用`set`维护所有可用餐厅的“位置+类型”，`set`会自动按位置从小到大排序，所以`begin()`就是最小的位置。
   - 💡 **学习笔记**：数据结构是贪心的“工具”——选对工具能让问题变简单！

3. **难点3：如何处理“相邻餐厅类型不能相同”？**
   - **分析**：选餐厅时，如果最小的位置对应的类型和前一个相同，就选下一个最小的（比如`set`的`begin()`是前一个类型，就`++it`选下一个）。
   - 💡 **学习笔记**：细节决定成败——相邻不同的条件要“实时检查”！

### ✨ 解题技巧总结
- **技巧A：先记经典结论**：无解当且仅当某类型出现次数超过$\lceil n/2 \rceil$，避免重复推导。
- **技巧B：用数据结构封装复杂度**：比如用`set`维护众数和最小位置，把“找众数”“找最小位置”变成`set.begin()`的简单操作。
- **技巧C：封装重复逻辑**：比如题解一的`op`函数，把“选餐厅+更新数据结构”的代码封装起来，让主逻辑更清晰。


## 4. C++核心代码实现赏析

在深入分析具体题解的精妙片段之前，让我们先来看一个**通用核心C++实现**（基于题解一，因为它更高效）：

### 本题通用核心C++实现参考
* **说明**：本代码来自题解一（Mirasycle），用两个`set`高效维护众数和最小位置，逻辑清晰、效率极高，是本题的“标准解法”。
* **完整核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
const int maxn=3e5+10;

struct node{
    int c,pos,x; // c:剩余次数, pos:该类型的最小位置, x:类型
    bool operator < (const node &rhs) const{ 
        return c>rhs.c||(c==rhs.c&&pos<rhs.pos); // 按次数从多到少，次数相同按位置从小到大
    }
};

int a[maxn],cnt[maxn],cur[maxn]; // cur[x]:类型x的当前最小位置
int lst[maxn],nxt[maxn],col,n; // lst[x]:类型x的最后一个位置, nxt[i]:i的下一个同类型位置
set<node> s1; // 维护各类型的(次数, 最小位置, 类型)
set<pii> s2; // 维护所有可用的(最小位置, 类型)

// 选类型x的餐厅：输出、更新数据结构
void op(int x){
    cout<<cur[x]<<" "; 
    col=x; // 记录上一个选的类型
    // 从s1和s2中删除旧的记录
    s1.erase((node){cnt[x],cur[x],x}); 
    s2.erase({cur[x],x});
    cnt[x]--;
    if(!cnt[x]) return;
    // 更新该类型的最小位置（选下一个同类型餐厅）
    cur[x]=nxt[cur[x]]; 
    // 插入新的记录到s1和s2
    s1.insert((node){cnt[x],cur[x],x});
    s2.insert({cur[x],x});
}

int main(){
    ios::sync_with_stdio(false); cin.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        cnt[a[i]]++;
        if(lst[a[i]]) nxt[lst[a[i]]]=i; // 链接同类型的前一个位置
        else cur[a[i]]=i; // 该类型的第一个位置
        lst[a[i]]=i; // 更新最后一个位置
    }
    // 初始化s1和s2
    for(int i=1;i<=n;i++) if(cnt[i]) s1.insert((node){cnt[i],cur[i],i});
    for(int i=1;i<=n;i++) if(cur[i]) s2.insert({cur[i],i});
    // 先判无解
    if(s1.begin()->c>(n+1)/2){ cout<<"-1"; return 0; }
    // 贪心选餐厅
    for(int i=1;i<=n;i++){
        node top=s1.begin()->c; // 当前众数
        if(top.c>(n-i+1)/2){ // 必须选众数，否则后续无解
            op(top.x);
        } else {
            auto it=s2.begin();
            if(it->second==col){ // 最小位置的类型和前一个相同，选下一个
                ++it;
            }
            op(it->second);
        }
    }
    return 0;
}
* **代码解读概要**：
> 代码分为三步：1. 输入数据，记录每个类型的餐厅位置（用`lst`和`nxt`链接同类型的餐厅）；2. 初始化两个`set`（`s1`维护众数，`s2`维护最小位置）；3. 贪心循环选餐厅：先检查是否必须选众数，否则选最小的可用且与前一个不同的餐厅。`op`函数负责更新数据结构——选一个餐厅后，删除旧的记录，更新该类型的最小位置，再插入新的记录。

---

### 题解一核心片段赏析
**题解一：(来源：Mirasycle)**
* **亮点**：用两个`set`完美解决“找众数”和“找最小位置”的问题，代码效率极高。
* **核心代码片段**：
```cpp
struct node{
    int c,pos,x;
    bool operator < (const node &rhs) const{ return c>rhs.c||(c==rhs.c&&pos<rhs.pos); }
};
set<node> s1; set<pii> s2;

void op(int x){
    cout<<cur[x]<<" "; col=x;
    s1.erase((node){cnt[x],cur[x],x}); s2.erase({cur[x],x});
    cnt[x]--; if(!cnt[x]) return;
    cur[x]=nxt[cur[x]]; 
    s1.insert((node){cnt[x],cur[x],x}); s2.insert({cur[x],x});
}
```
* **代码解读**：
> 1. `node`结构体的`operator<`是关键：`c>rhs.c`表示“次数多的排前面”（这样`s1.begin()`就是众数）；`c==rhs.c&&pos<rhs.pos`表示“次数相同的，位置小的排前面”（保证字典序最小）。
> 2. `op`函数是“选餐厅”的核心：比如选类型`x`的餐厅，首先输出它的当前最小位置`cur[x]`，然后从`s1`和`s2`中删除旧的记录（因为这个位置被选了），接着`cnt[x]--`（该类型的剩余次数减一），如果还有剩余，就把`cur[x]`更新为下一个同类型的位置（`nxt[cur[x]]`），最后把新的记录插入`s1`和`s2`。
* 💡 **学习笔记**：`set`的排序规则决定了它能快速找到我们需要的元素——**自定义排序是`set`的“灵魂”**！


## 5. 算法可视化：像素动画演示

### 🎮 动画演示主题：像素餐厅探险记（8位复古风）
**核心演示内容**：模拟贪心选餐厅的过程，用像素块展示餐厅类型，直观看到“必须选众数”“选最小字典序”的逻辑。

### 🎨 设计思路简述
采用8位像素风是因为它**复古、轻松**，能让你像玩FC游戏一样学习；“叮”的音效在选餐厅时响起，强化你的操作记忆；每选5个餐厅算一个“小关卡”，完成后有“关卡胜利”的提示，增加成就感。

### 🚶 动画帧步骤与交互关键点
1. **场景初始化**：
   - 屏幕左侧是**像素化餐厅网格**：每个餐厅是16x16的像素块，红色=类型1，蓝色=类型2，绿色=类型3（根据题目输入动态生成）。
   - 屏幕右侧是**控制面板**：有“开始/暂停”“单步”“重置”按钮，一个“速度滑块”（控制自动播放的速度），还有一个“众数提示区”（显示当前众数的类型和剩余次数）。
   - 背景播放**8位风格的轻松BGM**（比如《超级马里奥》的简化版）。

2. **算法启动**：
   - 输入数据后，餐厅网格显示所有餐厅，众数餐厅会有**黄色边框**（比如类型1是众数，所有红色餐厅都有黄色边框）。
   - 点击“开始”，第一个要选的餐厅会**闪烁+箭头指向**（比如最小位置是餐厅1，就有一个像素箭头指向它）。

3. **核心步骤演示**：
   - **选餐厅**：点击“单步”，选中的餐厅会“滑入”右侧的“已选列表”，同时播放“叮”的音效；剩余餐厅的众数边框会更新（比如类型1的剩余次数减少，黄色边框消失）。
   - **必须选众数**：如果当前众数的剩余次数超过剩余长度的一半，众数餐厅会**快速闪烁**，同时控制面板弹出提示“必须选这个类型！”，选它之后闪烁停止。
   - **相邻不同**：如果选的餐厅类型和前一个相同，会播放“错误提示音”（短促的“哔”），然后自动选下一个最小的餐厅。

4. **目标达成**：
   - 选完所有餐厅后，屏幕中央弹出**像素化的“胜利”字样**，播放“胜利音效”（比如《魂斗罗》的通关音乐）；同时“已选列表”会滚动显示最终的食事计划。

### 🛠️ 技术实现（轻量化）
- 用HTML5 Canvas绘制像素块，用JavaScript控制动画；
- 用Web Audio API播放8位音效（比如“叮”的音效是200Hz的方波，“胜利”是300Hz的三角波）；
- 控制面板用CSS做复古风格（比如按钮是像素化的矩形，字体用“Press Start 2P”）。


## 6. 拓展练习与相似问题思考

### 💡 通用思路迁移
“贪心+数据结构维护”的思路可以解决很多类似问题，比如：
1. **任务调度**：每次选优先级最高的任务，同时保证资源够用；
2. **区间覆盖**：每次选覆盖当前点的最长区间，最大化覆盖范围；
3. **字符串构造**：每次选最小的字符，同时保证后续能构造出合法字符串。

### 📚 洛谷练习推荐
1. **洛谷 P1080 国王游戏**：贪心经典题，需要排序后计算最大值，锻炼“当前最优+未来可行”的思路。
2. **洛谷 P2123 皇后游戏**：类似的贪心问题，需要推导排序规则，强化“贪心策略正确性”的证明能力。
3. **洛谷 P3047 Cow Traffic**：贪心+图论，需要选最短路径，锻炼“数据结构维护贪心”的技巧。


## 7. 学习心得与经验分享

**参考经验 (来自 Mirasycle)**：“超级简单题。首先如何判定合法？找到序列众数，只要其出现次数 ≤ ⌈n/2⌉，就必然合法……”
**点评**：作者的“超级简单题”其实是因为他**掌握了经典结论**！这提醒我们：学习算法时，要先记一些“经典结论”（比如本题的无解条件），这样能快速切入问题，避免重复推导。比如下次遇到“交替排列”的问题，第一反应就是“查众数次数”~


本次关于“食事计划”的C++解题分析就到这里。希望这份指南能帮助你理解贪心算法的“当前最优+未来可行”思路，以及如何用`set`高效维护数据。记住：**贪心不是“随便选”，而是“选对当前，保证未来”**！下次我们再一起探索新的编程挑战~ 💪

---
处理用时：118.79秒
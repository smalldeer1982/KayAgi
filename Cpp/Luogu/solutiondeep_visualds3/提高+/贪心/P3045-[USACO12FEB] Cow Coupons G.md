# 题目信息

# [USACO12FEB] Cow Coupons G

## 题目背景

Subtask 0 为原数据，Subtask 1,2 为 hack 数据。

## 题目描述

Farmer John needs new cows! There are N cows for sale (1 <= N <= 50,000), and FJ has to spend no more than his budget of M units of money (1 <= M <= 10^14).  Cow i costs P\_i money (1 <= P\_i <= 10^9), but FJ has K coupons (1 <= K <= N), and when he uses a coupon on cow i, the cow costs C\_i instead (1 <= C\_i <= P\_i). FJ can only use one coupon per cow, of course.

What is the maximum number of cows FJ can afford? 

FJ 准备买一些新奶牛。市场上有 $N$ 头奶牛，第 $i$ 头奶牛价格为 $P_i$。FJ 有 $K$ 张优惠券，使用优惠券购买第 $i$ 头奶牛时价格会降为 $C_i$，当然每头奶牛只能使用一次优惠券。FJ 想知道花不超过 $M$ 的钱最多可以买多少奶牛？

- $1 \le K \le N \le 5 \times 10^4$
- $1 \le C_i \le P_i \le 10^9$
- $1 \le M \le 10^{14}$

## 说明/提示

FJ has 4 cows, 1 coupon, and a budget of 7.


FJ uses the coupon on cow 3 and buys cows 1, 2, and 3, for a total cost of 3 + 2 + 1 = 6.


## 样例 #1

### 输入

```
4 1 7 
3 2 
2 2 
8 1 
4 3 
```

### 输出

```
3 
```

# AI分析结果


### 💡 Kay的C++算法解析：Cow Coupons G 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：反悔贪心  
🗣️ **初步分析**：
> 解决奶牛优惠券问题的关键在于反悔贪心算法。想象你购物时先抢购打折商品，后来发现更划算的商品时，可以退掉之前的商品重新购买（需补差价）。在本题中：
> - 先将K张优惠券用在优惠价最小的K头奶牛上（绿色方块）
> - 对于剩余奶牛（灰色方块），有两种选择：
>   - 直接原价购买（蓝色箭头）
>   - "反悔"：将之前某头奶牛的优惠券转让给当前奶牛（红色箭头+黄色闪烁），需满足条件：`P_j - C_j < P_i - C_i`（差价比较）
> - **可视化设计**：采用8位像素风格，用颜色标记状态（绿色=优惠购买，黄色=反悔操作，红色=当前操作）。控制面板支持单步执行，音效反馈关键操作（"叮"声表示反悔，"胜利"音效达成目标）

---

#### 2. 精选优质题解参考
**题解一（人间温柔）**  
* **点评**：思路清晰推导严谨，通过数学证明反悔条件 `Δ_j < Δ_i`（Δ=差价）。代码规范（三个优先队列），变量名`delta`直指核心逻辑。亮点在于用最小堆维护差价，实现O(N log N)高效反悔，边界处理严谨（钱不够时立即跳出）  

**题解二（Cuxhin）**  
* **点评**：教学性强，分阶段演示贪心策略进化（基础→改进→优化）。代码提供两种实现，优化版将优惠券初始化为0简化判断。亮点在于用"转移优惠券"比喻反悔操作，帮助理解数据流动  

---

#### 3. 核心难点辨析与解题策略
1. **初始优惠券分配**  
   * **难点**：优惠券必须优先用于优惠价最小的奶牛  
   * **分析**：将奶牛按`C_i`排序，选前K个用券购买，同时计算差价`Δ_i = P_i - C_i`存入最小堆  
   * 💡 **学习笔记**：初始选择是反悔的基础，确保局部最优解  

2. **反悔条件判定**  
   * **难点**：何时转让优惠券更优？  
   * **分析**：当新奶牛的差价`Δ_i` > 堆顶`Δ_j`时，转让券可省`P_i - (C_i + Δ_j)`  
   * 💡 **学习笔记**：反悔的本质是用高差价奶牛替换低差价奶牛  

3. **数据结构优化**  
   * **难点**：快速获取最小原价/优惠价/差价  
   * **分析**：用三个优先队列：  
     - `P`：未购奶牛的原价  
     - `C`：未购奶牛的优惠价  
     - `delta`：已用券奶牛的差价  
   * 💡 **学习笔记**：堆维护是反悔贪心的核心加速器  

### ✨ 解题技巧总结
- **问题分解**：分阶段处理（初始用券 → 反悔调整）  
- **差价抽象**：将反悔条件转化为`Δ_i`比较  
- **边界处理**：实时检查总花费，超过预算立即终止  

---

#### 4. C++核心代码实现赏析
**通用核心实现**（综合题解优化）：  
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int maxn = 50010;
int n, k, m, ans;
int p[maxn], c[maxn];
bool bought[maxn];
priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> P, C;
priority_queue<int, vector<int>, greater<>> delta;

signed main() {
    cin >> n >> k >> m;
    for (int i = 1; i <= n; ++i) {
        cin >> p[i] >> c[i];
        P.push({p[i], i});
        C.push({c[i], i});
    }
    for (int i = 0; i < k; ++i) delta.push(0); // 初始化k张券

    while (!P.empty()) {
        auto [p_val, i] = P.top(); 
        auto [c_val, j] = C.top();
        if (bought[i]) { P.pop(); continue; }
        if (bought[j]) { C.pop(); continue; }

        // 决策比较：原价购买 vs 反悔操作
        if (p_val <= c_val + delta.top()) {
            if (m < p_val) break;
            m -= p_val;
            bought[i] = true;
            P.pop();
        } else {
            if (m < c_val + delta.top()) break;
            m -= c_val + delta.top();
            bought[j] = true;
            delta.pop();             // 弹出被反悔的券
            delta.push(p[j] - c[j]); // 存入新差价
            C.pop();
        }
        ans++;
    }
    cout << ans << endl;
}
```

**关键代码解读**：
1. **三个优先队列**：  
   - `P`/`C`存储未购奶牛的价格，快速获取最小值  
   - `delta`维护已用券奶牛的差价，堆顶即最小`Δ`  
2. **反悔条件**：`p_val > c_val + delta.top()`时，用优惠价买当前奶牛+反悔堆顶奶牛更优  
3. **更新机制**：反悔后弹出旧`Δ`，压入新奶牛的`Δ`  

---

#### 5. 算法可视化：像素动画演示
**主题**：奶牛购买决策模拟（复古像素风）  
**核心交互设计**：  
```plaintext
| 控制面板         | 主画面（网格化奶牛）              |
|------------------|---------------------------------|
| [开始/暂停]      | 已购奶牛：■绿色(用券) ■黄色(反悔) |
| [单步执行] →     | 当前奶牛：●红色闪烁               |
| 速度滑块 ————○  | 操作提示：蓝色箭头(原价)          |
| [重置]           |         红色箭头(反悔转让)        |
```
**动画流程**：  
1. **初始化**：前K头奶牛变绿（用券购买），播放"叮"声  
2. **反悔决策**：  
   - 新奶牛闪烁红光，比较原价购买（蓝箭头）和反悔操作（红箭头）  
   - 选择反悔时：最小`Δ`的绿奶牛变黄，新奶牛变绿，播放"咔嚓"音效  
3. **结束条件**：钱不够时，已购奶牛闪烁金色，播放胜利音效  

---

#### 6. 拓展练习与相似问题
1. **反悔贪心本质**：用堆维护可撤销的局部最优解，适用场景：  
   - 区间调度（P2949）  
   - 带截止时间的任务调度（P4053）  
   - 资源分配（P2107）  

2. **洛谷推荐**：  
   - P2949：基础反悔贪心，理解"替换"思想  
   - P4053：结合时间窗口，练习反悔条件设计  
   - P2107：多维条件贪心，巩固堆的应用  

---

#### 7. 学习心得与经验
> "反悔贪心像下棋——当前最优解可能被后续更好的选择推翻。调试时要像这位作者所说：*常思己过*，通过打印中间变量（如`delta.top()`）验证反悔条件是否触发。"

---

通过本指南，你已掌握反悔贪心的核心思想与实现技巧。记住：好算法是"算"出来的，更是"调"出来的！下次遇到类似问题，不妨想想奶牛们如何"转让优惠券"哦~ 🐄💸

---
处理用时：194.11秒
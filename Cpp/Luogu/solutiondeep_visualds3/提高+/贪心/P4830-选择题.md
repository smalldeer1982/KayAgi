# 题目信息

# 选择题

## 题目描述

docriz 正在考试，他遇到了一个奇怪的选择题：这个选择题共有 $n$ 个选项，其中只有一个选项是正确的。他完全不会做这题，所以只能靠蒙。

蒙这道题分为 $n - 2$ 轮，在第 $1$ 轮开始之前，docriz 会在这 $n$ 个选项中随机蒙一项，之后的每轮流程如下：首先，nocriz 会过来帮他排除一个选项，由于 nocriz 事先知道答案，所以他会在现有的除正确的那一项和 docirz 正在选的那一项外的选项里，随机删去一个。之后，docriz 可以选择是否更换自己蒙的选项，如果更换，则随机更换到除正在选的那一项之外的任意一项。

docriz 在这 $n - 2$ 轮中，由于和 nocriz 达成的神秘协定，需要恰好更换 $k$ 次选项。他想知道，如何更换，使得自己蒙对的概率最大，输出这个概率。为了方便，你需要输出这个概率的分数形式在模 $10^9 + 7$ 意义下的结果。

## 说明/提示

样例 $1$ 到 $4$ 分别为 $\frac{2}{3}, \frac{1}{3}, \frac{3}{4}, \frac{5}{8}$。

对于 $30\%$ 的数据，保证 $5 \leq n \leq 10$。

对于另外 $5\%$ 的数据，保证 $k = 0$。

对于另外 $10\%$ 的数据，保证 $k = 1$。

对于另外 $10\%$ 的数据，保证 $k = n - 2$。

对于另外 $5\%$ 的数据，保证 $n \leq 10^2$。

对于另外 $10\%$ 的数据，保证 $n \leq 10^3$。

对于 $100\%$ 的数据，保证 $5 \leq n \leq 10^5, 0 \leq k \leq n - 2$。

## 样例 #1

### 输入

```
3 1```

### 输出

```
666666672```

## 样例 #2

### 输入

```
3 0```

### 输出

```
333333336```

## 样例 #3

### 输入

```
4 1```

### 输出

```
750000006```

## 样例 #4

### 输入

```
4 2```

### 输出

```
625000005```

## 样例 #5

### 输入

```
100000 99998```

### 输出

```
439903656```

# AI分析结果


### 💡 Kay的C++算法解析：选择题概率优化 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：概率递推与最优策略（动态规划思想）  
🗣️ **初步分析**：  
> 本题核心是**概率递推**，类似于动态规划中的状态转移。想象你在玩一个"像素冒险"游戏：有`n`个宝箱（选项），只有1个藏有宝藏（正确答案）。游戏进行`n-2`轮，每轮NPC会帮你排除一个假宝箱（但不会排除你当前选中的或正确答案）。你需要在`k`次关键回合更换选择。  
> - **最优策略**：前`k-1`次更换时故意保持错误选择（积累"错误能量"），最后一次更换在最终回合翻盘  
> - **核心变量**：错误概率`P`（初始值`(n-1)/n`），每轮用递推公式更新分子分母  
> - **像素动画设计**：用不同颜色方块表示宝箱（金色=正确答案/红色=错误/绿色=当前选择），NPC排除时显示"爆破"动画，更换选择时触发像素音效。自动演示模式会以贪吃蛇AI风格展示最优策略路径  

---

#### 2. 精选优质题解参考
**题解一（作者：Itst）**  
* **点评**：  
  思路直击核心——提出前`k-1`次保持错误的最优策略，推导出精炼的递推公式`P_next = 1 - P/(x-1)`。代码实现简洁高效（仅15行），用费马小定理求逆元处理模运算，边界处理严谨（`k=0`特判）。变量名`fz`（分子）、`fm`（分母）符合数学习惯，空间复杂度`O(1)`的优化是亮点。

**题解二（作者：揽月摘星辰）**  
* **点评**：  
  在Itst基础上补充了完整概率推导过程，用扩展欧几里得替代费马小定理求逆元，更适合模数非质数场景。代码中`exgcd`函数封装规范，详细注释了递推中分子分母的变化逻辑（`son_=n*mom-son`对应公式`P_next=(x-1-P)/(x-1)`），实践时更易调试。

---

#### 3. 核心难点辨析与解题策略
1. **难点1：最优策略的逆向思维**  
   * **分析**：直觉上每次更换都应瞄准正确答案，但实际需前`k-1`次故意选错。这类似象棋"弃子争先"策略，通过暂时牺牲局部正确率换取最终更高收益  
   * 💡 **学习笔记**：概率问题常需反直觉思考，建立"错误概率"的递推比直接求正确概率更简单  

2. **难点2：递推公式的数学转化**  
   * **分析**：将概率更新`P_next=1-P/(x-1)`转化为分子分母运算时，需注意模运算下公式等价变形：  
     ```math
     \frac{A_{i+1}}{B_{i+1}} = \frac{(x-1)B_i - A_i}{(x-1)B_i}
     ```  
   * 💡 **学习笔记**：概率递推中，保持分子分母的独立计算可避免浮点精度问题  

3. **难点3：模意义下的分数处理**  
   * **分析**：最终输出概率模`10^9+7`需用逆元。当`b≠0`时，`a/b mod p = a*b^{-1} mod p`，`b^{-1}`可通过费马小定理（`b^{p-2}`）或扩展欧几里得求得  
   * 💡 **学习笔记**：`p`为质数时首选费马小定理（代码短），否则用扩展欧几里得  

##### ✨ 解题技巧总结
- **策略设计技巧**：将操作过程明确划分为"积累期"（前k-1次）和"决胜期"（最后1次）  
- **递推优化技巧**：仅维护两个变量`fz`/`fm`避免数组存储，时间复杂度`O(k)`  
- **边界防御技巧**：对`k=0`、`n=1`等特殊情况优先处理  

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**  
* **说明**：综合Itst与揽月摘星辰的递推框架，采用费马小定理求逆元（代码更简洁）  
* **完整核心代码**：
```cpp
#include <iostream>
using namespace std;
const int MOD = 1e9 + 7;

long long qpow(long long a, int b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    int n, k;
    cin >> n >> k;
    if (k == 0) {
        cout << qpow(n, MOD - 2); // 1/n 的逆元
        return 0;
    }
    long long fz = n - 1, fm = n; // 初始错误概率
    int rounds = n - 2; // 剩余删除轮次
    for (int i = 1; i < k; ++i) { // 前k-1次更换
        fm = fm * rounds % MOD;
        fz = (fm - fz) % MOD; // P_next = ( (x-1) - P ) / (x-1)
        rounds--;
    }
    long long inv = qpow(fm, MOD - 2);
    cout << (fz * inv % MOD + MOD) % MOD; // 保证结果非负
    return 0;
}
```
* **代码解读概要**：  
  > 1. 处理`k=0`特例：直接返回`1/n`的模逆元  
  > 2. 初始化：`fz`/`fm`表示初始错误概率`(n-1)/n`  
  > 3. 循环`k-1`次：按公式更新分子分母，每轮剩余选项数减1  
  > 4. 最终计算：`fz * inv(fm)`即最后一次更换的正确概率  

**题解一（Itst）核心代码片段**  
* **亮点**：循环内联公式实现，无冗余计算  
* **核心代码片段**：
```cpp
k--;
long long fz = n - 1, fm = n;
n -= 2;
while (k) {
    fz = ((fm = fm * n % MOD) - fz) % MOD;
    k--; n--;
}
```
* **代码解读**：  
  > `n-=2`巧妙对齐首轮选项数（删除1轮后剩`n-1`选项），`fm * n`对应分母乘`(x-1)`，`fm - fz`实现分子转换。注意`k--`先减后判空，避免多余循环  

**题解二（揽月摘星辰）核心代码片段**  
* **亮点**：扩展欧几里得实现普适逆元计算  
* **核心代码片段**：
```cpp
void exgcd(long long a, long long b, long long &x, long long &y) {
    if (!b) { x = 1; y = 0; return; }
    exgcd(b, a % b, y, x);
    y -= x * (a / b);
}
long long Mod(long long a, long long b) {
    long long x, y;
    exgcd(b, MOD, x, y);
    return (a * (x % MOD + MOD) % MOD;
}
```
* **代码解读**：  
  > `exgcd`递归求解`bx ≡ 1 (mod p)`，`y -= x*(a/b)`维护贝祖等式。`Mod`函数处理负系数，保证返回`[0, MOD-1]`内的值  

---

#### 5. 算法可视化：像素动画演示
![](https://via.placeholder.com/600x300/222222/ffffff?text=像素动画示意图)  
* **主题**："宝箱大冒险"（8-bit像素风格）  
* **核心演示**：  
  1. **初始化**：`n`个宝箱（16x16像素块）随机排列，玩家选择绿色宝箱，正确答案为金色  
  2. **NPC排除**：红色"爆破"动画排除非正确非当前选择的宝箱，触发"啵"音效  
  3. **更换阶段**：  
     - 前`k-1`次：玩家更换到其他红色宝箱（故意选错），显示"失误"音效  
     - 最后一次：玩家切换到唯一剩余宝箱，若原选错则翻转为金色（胜利音效）  
  4. **数据面板**：实时显示当前概率公式`P = fz/fm`，选项计数器  

* **交互设计**：  
  - **控制面板**：步进/暂停/重置按钮 + 速度滑块  
  - **自动演示**：AI按最优策略自动操作（速度可调）  
  - **音效系统**：  
    - 正确选择：16-bit胜利旋律  
    - 错误选择：短促"哔"声  
    - 公式更新：打字机音效  

* **设计逻辑**：通过像素色块变化直观呈现概率递推：  
  > 初始`(n-1)/n` → 每轮分母`*(x-1)` → 分子更新为`分母-原分子`  

---

#### 6. 拓展练习与相似问题思考
* **通用技巧迁移**：  
  1. 递推法解概率问题（如赌徒破产问题）  
  2. 模逆元处理分数输出（RSA加密等）  
  3. 最优策略设计（背包问题决策）  

* **洛谷推荐题目**：  
  1. **P1291 [SHOI2002]百事世界杯之旅**  
     → 同类概率递推+分数处理，强化递推建模能力  
  2. **P2564 [SCOI2009]生日礼物**  
     → 滑动窗口+最优策略选择，类似"更换时机"决策  
  3. **P1654 OSU!**  
     → 高维期望递推，进阶概率训练  

---

#### 7. 学习心得与经验分享
> **参考经验（来自Itst）**：  
> *"小心0的特判——k=0时概率直接是1/n，单独处理避免递推错误"*  
>  
> **点评**：边界条件处理是算法健壮性的关键！类似地：  
> - 当`n=1`时需避免除零错误  
> - 模运算中负数转正：`(x%MOD + MOD)%MOD`

---

通过本次分析，我们深入掌握了概率递推的核心思想——**用错误概率的积累换取最终胜率**。记住Kay的秘诀："解题如闯关，有时退一步才能跳得更高！" 🎮

---
处理用时：224.44秒
# 题目信息

# [JSOI2016] 反质数序列

## 题目描述

对于一个长度为 $L \ge 2$ 的序列 $X:\{x_1,x_2,...,x_L\}$，如果满足对于任意 $1 \le i < j \le L$，均有 $x_i+x_j$ 不为质数，则 JYY 认为序列 $X$ 是一个「反质数序列」。

JYY 有一个长度为 $N$ 的序列 $A:\{a_1,a_2,...,a_N\}$，他希望从中选出一个包含元素最多的**子序列**，使得这个子序列是一个反质数序列。

## 说明/提示

对于 $10\%$ 的数据，满足 $N \le 10$；

对于 $40\%$ 的数据，满足 $N \le 150$；

对于 $80\%$ 的数据，满足 $N \le 1000$；

对于 $100\%$ 的数据，满足 $2 \le N \le 3000$，$1 \le a_i \le 10^5$。

## 样例 #1

### 输入

```
6
1 2 2 3 4 10
```

### 输出

```
4
```

# AI分析结果


### 💡 Kay的C++算法解析：反质数序列 深入学习指南 💡
**题目核心**：从序列中选出最多的元素组成子序列，使任意两数之和不为质数。

---

## 1. 题目解读与核心算法识别
✨ **本题主要考察**：`二分图最大独立集` + `网络流/匈牙利算法`  
🗣️ **初步分析**：  
> 想象把数字分成两队：奇数队（蓝队）和偶数队（红队）。蓝队和红队队员握手（连边）当且仅当他们相加是质数。我们需要选出最多互不握手的队员——这就是**二分图最大独立集问题**。  

- **核心难点**：1+1=2是质数 → 序列最多保留1个1（预处理删除多余1）  
- **算法流程**：  
  1. 删除多余1 → 2. 奇偶分队 → 3. 和为质数则连边 → 4. 求最大匹配 → 5. 答案 = 总点数 - 最大匹配  
- **可视化设计**：  
  - 像素风格：奇数蓝色方块，偶数红色方块，质数和时闪黄光  
  - 关键步骤高亮：连边时画闪电动画，匹配成功时方块变金色  
  - 音效：匹配成功"叮"，计算完成播放8-bit胜利音乐

---

## 2. 精选优质题解参考
**题解一：djh123（网络流标准实现）**  
* **点评**：思路直击本质，将奇偶分类与质数判断结合，清晰推导出二分图模型。代码规范（`vis`标记质数，`add`封装连边），网络流模板完整。亮点在于特殊处理1的边界条件（`cnt`计数），实践价值高，可直接用于竞赛。  

**题解二：mRXxy0o0（匈牙利算法优化）**  
* **点评**：采用匈牙利算法替代网络流，代码更简洁。亮点在极致优化：①偶数点优先枚举提升效率 ②BFS匈牙利避免递归栈溢出 ③位运算加速奇偶判断。虽理论复杂度高，但实际跑满3000点，展现算法常数优化的艺术。  

**题解三：crescentic（网络流教学向）**  
* **点评**：代码结构堪称教科书典范，关键步骤有详细注释（如`init`预处理质数）。亮点在严谨处理源汇点方向（S→偶数→奇数→T），变量名自解释（`tru`标记质数），适合初学者理解网络流在建图时的流向逻辑。  

---

## 3. 核心难点辨析与解题策略
1. **奇偶分类与1的特殊处理**  
   *分析*：质数≠2时必为奇数→只能奇+偶组合。但1+1=2打破规则，需预处理删除多余1（保留1个）。  
   💡 **学习笔记**：奇偶分类是二分图基础，特殊值预处理是竞赛常见技巧。  

2. **质数判断的时空优化**  
   *分析*：暴力判断每对数O(n²)超时→预处理[1,2e5]的质数表（埃氏筛）。连边时直接查表O(1)。  
   💡 **学习笔记**：预处理是优化重复计算的利器，尤其当n>>质数范围时。  

3. **二分图模型的建立**  
   *分析*：建图时需保证方向一致（如S→偶数→奇数→T），避免双向边。匈牙利算法需优化枚举顺序（偶数点更少时优先）。  
   💡 **学习笔记**：二分图建模时，边的方向决定算法实现细节。  

### ✨ 解题技巧总结
- **问题转化艺术**：将"两数和不为质数"转化为图论独立集  
- **预处理为王**：质数表、去重1等预处理大幅降低复杂度  
- **常数优化**：匈牙利用BFS替代DFS，位运算替代取模  
- **边界战士**：特殊值（如1）优先单独处理避免污染主逻辑  

---

## 4. C++核心代码实现赏析
**本题通用核心实现**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=3010, MAX=2e5;
int prime[MAX], vis[MAX], n, a[N], cnt;
vector<int> G[N]; // 匈牙利邻接表

void init() { // 埃氏筛预处理质数
    for(int i=2; i<MAX; i++) {
        if(!vis[i]) prime[++cnt]=i;
        for(int j=1; j<=cnt && i*prime[j]<MAX; j++) {
            vis[i*prime[j]]=1;
            if(i%prime[j]==0) break;
        }
    }
}

int main() {
    init();
    cin >> n;
    int one_cnt = 0;
    for(int i=1; i<=n; i++) {
        cin >> a[i];
        if(a[i]==1 && one_cnt) n--, i--; // 删除多余1
        else if(a[i]==1) one_cnt=1;
    }
    // 匈牙利算法求最大匹配（详见题解）
    cout << n - max_match; // 独立集 = 点数 - 最大匹配
}
```
* **代码解读概要**：  
  1. 预处理质数表 → 2. 过滤多余1 → 3. 建图（奇偶连边）→ 4. 匈牙利求匹配 → 5. 输出独立集大小  

---

## 5. 算法可视化：像素动画演示
![](https://example.com/pixel-demo.gif)  
* **主题**：8-bit风格"数字冒险者"闯关  
* **关键帧设计**：  
  1. **初始化**：  
     - 蓝色奇数方块（带⚡标志）居左，红色偶数方块（带🛡️标志）居右  
     - 控制面板：速度滑块/单步执行/重置按钮  
  2. **质数判断**：  
     - 蓝方块+红方块碰撞→闪黄光+播放"叮"音效→生成连接闪电  
  3. **匈牙利匹配**：  
     - BFS队列像素化展示：方块上浮显示序号  
     - 匹配成功：方块变金色+播放升级音效  
  4. **结果展示**：  
     - 独立集方块高亮闪烁+播放胜利音乐  
     - 统计区显示：总点数/匹配数/答案  

---

## 6. 拓展练习与相似问题思考
**通用技巧迁移**：  
二分图建模适用于：  
1. 冲突关系问题（如不能共存元素）  
2. 棋盘覆盖问题（黑白染色）  
3. 任务分配（左工人右任务）  

**洛谷推荐**：  
1. P3386 二分图最大匹配（模板题）  
2. P1330 封锁阳光大学（冲突关系建模）  
3. P1284 三角形牧场（特殊值处理练习）  

---

## 7. 学习心得与经验分享
> **mRXxy0o0的调试经验**：  
> "匈牙利DFS递归爆栈，改用BFS队列后AC，树结构算法要注意深度限制"  
>   
> **Kay总结**：递归深度是隐藏炸弹！当n>1000时，递归算法应优先转迭代或BFS，STL的queue是救命稻草。

---

掌握二分图建模的思维，你就能将看似复杂的约束转化为清晰的图论问题！下次遇到"不能共存"类问题，试试奇偶分队的魔法吧~ 💪

---
处理用时：86.97秒
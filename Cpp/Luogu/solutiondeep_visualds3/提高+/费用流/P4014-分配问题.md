# 题目信息

# 分配问题

## 题目描述

有 $n$ 件工作要分配给 $n$ 个人做。第 $i$ 个人做第 $j$ 件工作产生的效益为 $c_{ij}$ 。试设计一个将 $n$ 件工作分配给 $n$ 个人做的分配方案，使产生的总效益最小或最大。


## 说明/提示

$1 \leq n \leq 50, 0 \le c _ {i, j} \le 100$。

一个人只能修一个工件。

## 样例 #1

### 输入

```
5
2 2 2 1 2
2 3 1 2 4
2 0 1 1 1
2 3 4 3 3
3 2 1 2 1```

### 输出

```
5
14```

# AI分析结果

---
# 💡 Kay的C++算法解析：分配问题 深入学习指南 💡

<introduction>
  今天我们来一起分析「分配问题」这道经典的C++编程题——把n件工作分给n个人，要找到总效益最小或最大的方案。这道题藏着二分图匹配的核心秘密，我们会用**KM算法**和**费用流**两种方法破解它，还会用像素动画直观看到算法运行过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：二分图最佳完美匹配（KM算法 / 费用流）

🗣️ **初步分析**：
解决「分配问题」的关键，是把问题转化为**二分图带权匹配**——左边是“人”，右边是“工作”，边的权值是“效益”。我们需要找到一个**完美匹配**（每个人都分到工作，每个工作都有人做），同时让总权值最小或最大。

### 核心算法比喻
- **KM算法**：像给男女嘉宾定“好感度阈值”——给每个人（左节点）和工作（右节点）一个“顶标”（分数），要求“人的分数+工作的分数≥效益”。然后找“相等子图”（边权等于分数和的边），如果这个子图有完美匹配，就是最佳方案！如果没有，就调整顶标（降低人的分数、提高工作的分数），直到找到完美匹配。
- **费用流**：像“任务流分配”——建一个超级源点（发任务的人）连到所有“人”，所有“工作”连到超级汇点（收任务的终点）。人到工作的边容量是1（只能做一份）、费用是效益。跑**最小费用最大流**得到最小总效益，把费用取反再跑一次，得到最大总效益的相反数。

### 可视化设计思路
我们会做一个**8位像素风的KM算法动画**：
- 左边是像素小人（人节点），右边是像素箱子（工作节点），顶标用数字显示在节点上方。
- 相等子图的边用**绿色**高亮，增广路用**闪烁的黄色**标记。
- 调整顶标时，小人的分数减少、箱子的分数增加，伴随“叮”的音效；找到完美匹配时，播放“胜利”音效（类似FC游戏通关声）。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和实践价值出发，选了3个高分题解——覆盖KM算法和费用流，帮你全面理解！
</eval_intro>

**题解一：Khassar的KM算法（赞24）**
* **点评**：这是最贴合题目本质的解法！作者直接套用KM算法的核心逻辑：先初始化顶标（左节点取最大边权，右节点取0），然后用DFS找相等子图的增广路。如果找不到，就调整顶标（计算最小松弛量a，降低左节点顶标、提高右节点顶标）。代码里“顶标和等于总效益”的技巧非常巧妙——最大效益直接取顶标和，最小效益只需把边权取反再算一次。代码结构清晰，变量名（如`lx`左顶标、`ly`右顶标）一看就懂，是KM算法的标准模板！

**题解二：YoungLove的费用流（赞22）**
* **点评**：费用流的通用性很强，这道题是它的“模板级应用”！作者的建图逻辑超清晰：超级源点连人（容量1、费用0），工作连超级汇点（容量1、费用0），人连工作（容量1、费用为效益）。跑最小费用最大流得到最小效益，把费用取反再跑一次得到最大效益。代码里用SPFA找最短增广路，处理负权边也没问题，实践中容易调试，适合新手入门费用流！

**题解三：lolte的费用流（赞15）**
* **点评**：作者用Dinic算法实现费用流，比SPFA更快！代码里把“最大效益”转化为“边权取反后的最小费用”，思路和题解二一致，但用Dinic的分层+DFS优化了速度。亮点是代码注释详细，比如`spfa()`函数找最短路径、`dfs()`函数找增广路，新手能跟着注释一步步理解费用流的运行过程。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键难点，其实是“如何把问题转化为算法模型”和“处理最小/最大效益的转换”。我总结了3个核心要点：
</difficulty_intro>

1. **难点1：KM算法的顶标调整**  
   * **问题**：怎么让相等子图出现完美匹配？  
   * **解决**：当DFS找不到增广路时，收集已经访问的左节点（S集合）和右节点（T集合），计算最小松弛量`a = min(lx[i]+ly[j]-w[i][j])`（i在S、j不在T）。然后**S中的左节点顶标减a，T中的右节点顶标加a**——这样会让更多边进入相等子图，同时不破坏“lx[i]+ly[j]≥w[i][j]”的条件。  
   * 💡 **学习笔记**：顶标调整是KM算法的“核心魔法”，目的是扩大相等子图的范围！

2. **难点2：费用流的建图逻辑**  
   * **问题**：怎么用流量限制“每人做一份工作”？  
   * **解决**：超级源点到人的边容量为1（每人只能接一个任务），工作到超级汇点的边容量为1（每个工作只能被做一次）。人到工作的边容量为1（只能分配一次），费用为效益。这样满流（流量= n）时，刚好是完美匹配！  
   * 💡 **学习笔记**：费用流的“流量”对应“分配次数”，“费用”对应“效益”，建图要围绕“限制次数”和“计算总成本”设计！

3. **难点3：最小/最大效益的转换**  
   * **问题**：怎么用同一算法求最小和最大？  
   * **解决**：无论是KM还是费用流，求最大效益都可以通过**边权取反**实现——把效益`c_ij`变成`-c_ij`，求最小总效益，最后再取反就是原问题的最大效益。比如KM算法中，取反后顶标和也会取反，费用流中取反后最小费用的相反数就是最大费用。  
   * 💡 **学习笔记**：“取反”是处理“最大最小”问题的通用技巧，能把陌生问题转化为熟悉的模型！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**KM算法的通用核心实现**——它直接对应题目中的“最佳完美匹配”，逻辑清晰，适合入门！
</code_intro_overall>

### 本题通用核心C++实现参考（KM算法）
* **说明**：综合Khassar的题解，保留KM算法的核心逻辑，简化了输入输出，适合理解算法本质。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 55;  // n≤50，所以数组开55足够
int n;
int w[N][N];       // 效益矩阵：w[i][j]是第i个人做第j个工作的效益
int lx[N], ly[N];  // 左顶标（人）、右顶标（工作）
int link[N];       // link[j] = i：工作j被人i分配
bool S[N], T[N];   // 标记DFS中访问过的左、右节点

// DFS找增广路：尝试给左节点x分配工作
bool dfs(int x) {
    S[x] = true;  // 标记x已访问（左集合S）
    for (int j = 1; j <= n; j++) {
        if (lx[x] + ly[j] == w[x][j] && !T[j]) {  // 边在相等子图中，且j未访问
            T[j] = true;  // 标记j已访问（右集合T）
            if (!link[j] || dfs(link[j])) {  // j未分配，或已分配的人能找到其他工作
                link[j] = x;  // 分配j给x
                return true;
            }
        }
    }
    return false;
}

// 调整顶标：当DFS找不到增广路时，扩大相等子图
void update() {
    int a = 1e9;  // 初始化为很大的数
    // 找S中的左节点和非T中的右节点的最小松弛量
    for (int i = 1; i <= n; i++) if (S[i])
        for (int j = 1; j <= n; j++) if (!T[j])
            a = min(a, lx[i] + ly[j] - w[i][j]);
    // 调整顶标：S中的左节点减a，T中的右节点加a
    for (int i = 1; i <= n; i++) {
        if (S[i]) lx[i] -= a;
        if (T[i]) ly[i] += a;
    }
}

// KM算法主函数：返回最大总效益
int KM() {
    memset(link, 0, sizeof(link));
    memset(ly, 0, sizeof(ly));
    // 初始化左顶标：每个左节点取最大的边权
    for (int i = 1; i <= n; i++) {
        lx[i] = 0;
        for (int j = 1; j <= n; j++)
            lx[i] = max(lx[i], w[i][j]);
    }
    // 给每个左节点找增广路
    for (int i = 1; i <= n; i++) {
        while (true) {
            memset(S, false, sizeof(S));
            memset(T, false, sizeof(T));
            if (dfs(i)) break;  // 找到增广路，下一个人
            else update();      // 没找到，调整顶标
        }
    }
    // 计算总效益：顶标和（因为相等子图的边权和等于顶标和）
    int sum = 0;
    for (int j = 1; j <= n; j++) sum += w[link[j]][j];
    return sum;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            cin >> w[i][j];
    
    // 求最大效益
    int max_sum = KM();
    // 求最小效益：把边权取反，再跑KM，结果取反
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            w[i][j] *= -1;
    int min_sum = -KM();
    
    cout << min_sum << endl << max_sum << endl;
    return 0;
}
```
* **代码解读概要**：
  1. **初始化**：左顶标`lx`取每个节点的最大边权，右顶标`ly`初始化为0。
  2. **DFS找增广路**：尝试给每个左节点（人）分配右节点（工作），标记访问过的节点。
  3. **调整顶标**：如果找不到增广路，计算最小松弛量，调整顶标扩大相等子图。
  4. **计算结果**：最大效益是顶标和，最小效益是边权取反后的结果取反。


<code_intro_selected>
接下来看两个优质题解的核心片段，分析它们的亮点！
</code_intro_selected>

### 题解一：Khassar的KM算法（核心片段）
* **亮点**：直接应用KM定理，顶标和即为总效益，代码简洁高效。
* **核心代码片段**：
```cpp
IL void KM() {
    Rf(i,1,n) {
        link[i]=lx[i]=ly[i]=0;
        Rf(j,1,n) lx[i]=max(lx[i],w[i][j]);// 左顶标初始化为最大边权
    }
    Rf(i,1,n) while(true) {
        Rf(j,1,n) S[j]=T[j]=false;// 每次DFS前清空访问标记
        if(dfs(i)) break;// 找到增广路，下一个人
        else update();// 调整顶标
    }
}
```
* **代码解读**：
  - `lx[i] = max(lx[i], w[i][j])`：左顶标初始化为该人的最大效益——这样能保证“lx[i]+ly[j]≥w[i][j]”（因为ly[j]=0）。
  - `while(true)`：循环直到找到增广路——如果DFS失败，就调整顶标，直到成功。
* 💡 **学习笔记**：KM算法的“顶标初始化”和“循环调整”是固定套路，记下来就能解决大部分二分图带权匹配问题！


### 题解二：YoungLove的费用流（核心片段）
* **亮点**：费用流的标准建图，清晰区分“源点-人-工作-汇点”的层次。
* **核心代码片段**：
```cpp
// 建图：超级源点s=0，超级汇点t=n+n+1
for(R int i=1; i<=n; ++i)
    add(s,i,1,0), add(i,s,0,0),  // 源点连人，容量1、费用0
    add(i+n,t,1,0), add(t,i+n,0,0); // 工作连汇点，容量1、费用0
for(R int i=1; i<=n; ++i)
    for(R int j=1; j<=n; ++j)
        in(x), add(i,j+n,1,x), add(j+n,i,0,-x); // 人连工作，容量1、费用x
```
* **代码解读**：
  - `add(u, v, flow, cost)`：添加一条从u到v的边，容量`flow`、费用`cost`，同时添加反向边（容量0、费用-cost）。
  - 人连工作的边费用是`x`（效益），反向边费用是`-x`——这是费用流处理“退流”的关键（比如要调整分配时，反向边能“撤销”之前的选择）。
* 💡 **学习笔记**：费用流的建图要“分层”——源点→左节点→右节点→汇点，每层的边对应问题的约束条件（比如容量1限制次数）！


## 5. 算法可视化：像素动画演示（KM算法版）

<visualization_intro>
为了让你“看”到KM算法的运行过程，我设计了一个**8位像素风的动画**——像玩FC游戏一样理解顶标调整和增广路！
</visualization_intro>

### 动画设计方案
#### 1. 场景与UI（FC风格）
- **主界面**：左边是5个像素小人（代表5个人，编号1~5），右边是5个像素箱子（代表5个工作，编号1~5）。
- **顶标显示**：每个小人头顶显示左顶标`lx[i]`（红色数字），每个箱子头顶显示右顶标`ly[j]`（蓝色数字）。
- **控制面板**：下方有“开始/暂停”“单步执行”“重置”按钮，以及速度滑块（1~5倍速）。
- **音效**：背景是轻松的8位BGM（类似《超级马里奥》的背景音乐），关键操作有音效：
  - 点击“单步”：播放“咔嗒”声；
  - 调整顶标：播放“叮”声；
  - 找到增广路：播放“滴”声；
  - 完成匹配：播放“胜利”音效（类似《魂斗罗》通关声）。


#### 2. 动画步骤演示
以样例输入为例（n=5，效益矩阵如题目所示）：
1. **初始化顶标**：小人1的顶标是2（最大效益是2），小人2的顶标是4（最大效益是4），以此类推；箱子的顶标都是0。
2. **第一次DFS（小人1）**：
   - 小人1的顶标是2，箱子的顶标是0。找`lx[1]+ly[j] == w[1][j]`的边——箱子4的`w[1][4]=1`，`2+0=2≠1`？不对，等一下，样例输入中小人1的效益是`2 2 2 1 2`，所以最大是2，`lx[1]=2`。然后找`lx[1]+ly[j] == w[1][j]`的边：`2+0=2`，对应箱子1、2、3、5（效益都是2），箱子4是1（2+0≠1）。
   - DFS尝试给小人1分配箱子1：标记S[1]=true，T[1]=true。箱子1未分配，所以link[1]=1——找到增广路！
3. **第二次DFS（小人2）**：
   - 小人2的顶标是4（最大效益是4），找`4+0 == w[2][j]`的边——箱子5的效益是4，所以尝试分配箱子5。标记S[2]=true，T[5]=true。箱子5未分配，link[5]=2——成功！
4. **第三次DFS（小人3）**：
   - 小人3的顶标是2（最大效益是2），找`2+0 == w[3][j]`的边——箱子1的效益是2？样例输入中小人3的效益是`2 0 1 1 1`，最大是2，对应箱子1。尝试分配箱子1，但箱子1已被小人1占用！
   - 进入DFS递归：尝试让小人1找其他箱子。小人1的S[1]=true，找其他`lx[1]+ly[j] == w[1][j]`的边——箱子2、3、5。尝试分配箱子2：标记T[2]=true，箱子2未分配，所以link[2]=1，小人3分配箱子1——成功！
5. **调整顶标（当DFS失败时）**：
   - 比如小人4的DFS失败，收集S={4}，T={...}，计算最小松弛量a=1。然后小人4的顶标减1（从3变2），T中的箱子顶标加1。这样原来的边`w[4][j]`会有更多进入相等子图，继续DFS直到找到增广路。


#### 3. 交互设计
- **单步执行**：点击一次按钮，执行一步DFS或顶标调整，同时显示当前操作的文字提示（比如“小人1尝试分配箱子1”“调整顶标：小人4的lx减1，箱子2的ly加1”）。
- **自动播放**：按设定的速度（1~5倍）自动执行，适合整体观察算法流程。
- **重置**：回到初始状态，重新开始动画。


<visualization_conclusion>
通过这个动画，你能清楚看到KM算法“如何找增广路”“如何调整顶标”——就像玩游戏一样，每一步都有明确的目标，慢慢逼近完美匹配！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了二分图最佳匹配的方法，你可以解决很多类似的问题——比如“任务分配”“资源调度”“配对问题”！
</similar_problems_intro>

### 通用思路迁移
- **任务分配**：比如“工人做任务，每个工人做一个任务，求总时间最短”——和本题完全一样，把“效益”换成“时间”即可。
- **资源调度**：比如“机器加工零件，每个机器加工一个零件，求总利润最大”——同样是二分图带权匹配。
- **配对问题**：比如“男女配对，每对的好感度最高”——左节点是男，右节点是女，边权是好感度，求最大匹配。


### 洛谷练习推荐
1. **洛谷 P4015 运输问题**  
   * 🗣️ **推荐理由**：这是分配问题的“升级版”——多源多汇的运输问题，需要用费用流解决，能巩固你对“流量限制”和“费用计算”的理解！
2. **洛谷 P2053 [SCOI2007] 修车**  
   * 🗣️ **推荐理由**：这道题需要把“修车时间”转化为“费用”，建图更复杂，但核心还是费用流——能锻炼你“将实际问题转化为算法模型”的能力！
3. **洛谷 P3381 【模板】最小费用最大流**  
   * 🗣️ **推荐理由**：费用流的模板题，和本题的费用流解法完全一致——多练几遍，费用流就再也不怕了！


## 7. 学习心得与经验分享

<insights_intro>
题解中的作者们分享了很多实用经验，我选了两个最有价值的：
</insights_intro>

> **经验1（来自Khassar）**：“KM算法的顶标初始化要取左节点的最大边权——这样能保证初始的相等子图尽可能大，减少调整次数。”  
> **点评**：这是KM算法的“小技巧”——初始顶标越大，相等子图的边越多，找到增广路的概率越高，能加快算法速度！

> **经验2（来自YoungLove）**：“费用流中，反向边的费用是原边的相反数——这是处理‘退流’的关键，比如要调整分配时，反向边能‘撤销’之前的选择。”  
> **点评**：反向边是费用流的“灵魂”——没有反向边，就无法调整已经做出的选择，也就找不到更优的增广路！


<conclusion>
「分配问题」是二分图匹配的经典题目，KM算法和费用流是解决它的两把“钥匙”。通过这道题，你能学会“将实际问题转化为算法模型”“处理最小/最大问题的取反技巧”，还有“顶标调整”“费用流建图”这些核心技能。

记住：编程的本质是“解决问题”，算法是“工具”——多练、多想，你会越来越厉害！下次我们再一起破解更难的问题~ 💪
</conclusion>

---

---
处理用时：191.72秒
# 题目信息

# [COCI 2015/2016 #3] DOMINO

## 题目背景

「誕生日おめでとう！!」

小 M 收到了他女朋友的生日祝福和一份礼物。

## 题目描述

小 M 的女朋友送小 M 了一张 $n \times n$ 的表格作为生日礼物，在表格的每个单元格中都写有一个非负整数。

不幸的是，有些单元格里数字太大了，小 M 不喜欢它们，所以他将在表格上面放置 $k$ 张骨牌，将覆盖那些数字太大的单元格。

更准确地说，小 M 按照以下规则放置骨牌。

- 骨牌为 $1\times 2$ 的矩形，不能拆开放置。
- 骨牌不重叠（但可以接触）。
- 所有可见（未覆盖）字段的总和需要尽可能的小。

您的任务是确定最小可见区域的数字的总和。数据保证可防止 $k$ 个骨牌且无重叠。

## 说明/提示

#### 数据规模及约定
对于 $100\%$ 的数据，$1\le n \le 2 \times 10 ^ 3$，$1\le k \le 8$，$0 \le a_i \le 10 ^ 3$。

#### 说明
翻译自 [COCI 2015-2016 #3 F DOMINO](https://hsin.hr/coci/archive/2015_2016/contest3_tasks.pdf)，满分 160。

## 样例 #1

### 输入

```
3 1
2 7 6
9 5 1
4 3 8
```

### 输出

```
31```

## 样例 #2

### 输入

```
4 2
1 2 4 0
4 0 5 4
0 3 5 1
1 0 4 1
```

### 输出

```
17```

# AI分析结果

# 💡 Kay的C++算法解析：DOMINO 深入学习指南 💡

<introduction>
  今天我们来一起分析COCI 2015/2016赛季的经典题目「DOMINO」。这道题需要我们在n×n的网格中放置k个1×2的骨牌，让未被覆盖的数字总和最小——其实换个角度想，就是要让**覆盖的数字总和最大**（因为总和固定，未覆盖=总和-覆盖）。本指南会帮你梳理核心思路，理解不同解法的巧妙之处，还会用像素动画直观展示算法过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`贪心+搜索` / `费用流` / `meet-in-the-middle（折半搜索）`

🗣️ **初步分析**：
解决这道题的关键，在于**处理“骨牌不重叠”的限制**和**最大化覆盖总和**。由于k很小（≤8），我们可以用“缩小搜索范围+剪枝”的暴力思路；而骨牌覆盖本质是**二分图匹配问题**（黑白染色后，骨牌连接黑格和白格），所以也能用费用流解决。下面用两个比喻帮你理解核心算法：

- **贪心+搜索**：就像从一堆“大额硬币”（权值大的骨牌）里挑k个，且不能选重叠的——先挑前56个最大的硬币（因为每个硬币最多挡住6个其他硬币，7×8=56足够覆盖最优解），再用DFS逐个尝试组合，中途如果发现“剩下的硬币加起来都不如当前最优”，就直接跳过（剪枝）。
- **费用流**：把网格当成“ bipartite graph（二分图）”，黑格是左半部分，白格是右半部分。源点给黑格发“令牌”（流量1），白格把令牌传给汇点。骨牌就是“黑格→白格”的边，我们要选k条这样的边，让总“收益”（覆盖的数字和）最大——这就是**最大费用最大流**问题！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度，为你筛选了3份优质题解。它们分别代表了“暴力直观”“经典模型”“巧妙分治”三种思路，适合不同阶段的学习~
</eval_intro>

**题解一：贪心+DFS（作者：Cells）**
* **点评**：这份题解特别适合初学者理解问题本质！作者先把所有可能的骨牌（横向/纵向）列出来，按权值从大到小排序，然后只保留前56个（因为k≤8，每个骨牌最多挡住6个，前56个足够覆盖最优解）。接下来用DFS搜索选k个不重叠的骨牌，关键是**剪枝优化**——如果当前选的总和加上后面所有骨牌的最大可能总和，都不如当前最优解，就直接跳过。代码逻辑直白，变量名（比如`mp`标记已覆盖的格子）也很易懂，是入门的好例子！

**题解二：费用流（作者：zsq147258369）**
* **点评**：这是骨牌问题的经典解法！作者用**黑白染色**把网格分成两部分：(i+j)为奇数的是“黑格”，偶数的是“白格”。然后建图：
  - 源点→黑格：容量1，费用是黑格的权值（因为选这个黑格会覆盖它的权值）；
  - 黑格→相邻白格：容量1，费用0（骨牌连接黑格和白格）；
  - 白格→汇点：容量1，费用是白格的权值。
  最后跑**最大费用最大流**（用zkw算法优化），得到的总费用就是覆盖的最大总和。作者还优化了空间——用`short`存边的容量和费用，解决了n=2e3时的内存问题，代码结构清晰，适合学习费用流的实际应用！

**题解三：meet-in-the-middle（作者：UnyieldingTrilobite）**
* **点评**：这是针对k小的“神级优化”！作者同样先选前50个最大的骨牌，然后把它们分成两半（比如前22个和后28个）。对每一半，用**状压DP**计算所有可能的选法（比如前一半的状态是2^22种，后一半是2^28种，但因为k≤8，实际只需要处理选≤8个的状态）。最后合并两部分：对前一半的每个状态，找后一半中**不重叠**且选够剩余数量的最大总和。这种“分而治之”的思路，把原本2^50的状态量降到了可处理的范围，非常巧妙！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家常遇到三个“卡壳点”。结合优质题解的经验，我帮你提炼了对应的解决策略：
</difficulty_intro>

1.  **难点1：如何处理“骨牌不重叠”？**
    * **分析**：骨牌覆盖两个相邻格子，选一个骨牌就意味着这两个格子不能再被其他骨牌覆盖。解决方法有两种：
      - 搜索时用`bitset`或二维数组`mp`标记已覆盖的格子（比如Cells的题解）；
      - 费用流中给每个格子的“流入/流出”容量设为1（比如zsq147258369的题解），保证每个格子只能被选一次。
    * 💡 **学习笔记**：“不重叠”本质是“资源独占”，要么用标记，要么用流量限制！

2.  **难点2：n很大（2e3），如何避免超时/超内存？**
    * **分析**：n=2e3时，网格有4e6个格子，直接建图会爆内存。解决方法：
      - 费用流中用`short`存边的容量和费用（减少内存占用）；
      - 贪心+搜索中只保留前56个最大的骨牌（缩小搜索范围）。
    * 💡 **学习笔记**：面对大数据，先找“关键部分”（比如权值大的骨牌），再处理！

3.  **难点3：如何高效计算“选k个不重叠骨牌的最大总和”？**
    * **分析**：k≤8是关键！如果直接枚举所有可能的骨牌组合，时间会爆炸，但可以用：
      - 剪枝DFS（Cells的题解）：提前终止不可能更优的路径；
      - meet-in-the-middle（UnyieldingTrilobite的题解）：把状态分成两半，分别计算后合并。
    * 💡 **学习笔记**：k小的时候，“暴力+优化”往往比“复杂算法”更有效！

### ✨ 解题技巧总结
<summary_best_practices>
通过这道题，我总结了3个通用技巧，帮你举一反三：
</summary_best_practices>
- **技巧1：问题转换**：把“未覆盖总和最小”转换成“覆盖总和最大”，简化目标（总和固定时，反向思考更简单）；
- **技巧2：利用数据范围**：k≤8时，优先考虑搜索或状压（比如meet-in-the-middle）；n很大时，优先优化空间（比如用short）；
- **技巧3：模型识别**：骨牌覆盖是二分图匹配问题，直接套费用流模板（黑白染色是关键）！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**贪心+DFS的通用实现**——它直观易懂，适合入门。这份代码来自Cells的题解，我做了简化和注释：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码是贪心+DFS的典型实现，保留了关键逻辑（选前56个骨牌、DFS剪枝），适合理解问题本质。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int N = 2e3 + 10;
    int n, k, ans = 0;
    long long sum = 0;
    int a[N][N], s[60]; // s是前i个骨牌的权值前缀和
    bitset<N> mp[N];    // 标记已覆盖的格子

    struct Node {
        int val, x1, y1, x2, y2; // 骨牌的权值和两个端点
    };
    vector<Node> q;

    bool cmp(Node a, Node b) { return a.val > b.val; } // 按权值从大到小排序

    // k:当前选了几个骨牌；lst:下一个开始选的位置；num:当前覆盖的总和
    void dfs(int now_k, int lst, int num) {
        ans = max(ans, num); // 更新最优解
        // 剪枝：选完剩下的骨牌也不如当前最优，或者已经选够k个
        if (now_k == k + 1 || num + s[lst + k - now_k] - s[lst - 1] <= ans)
            return;
        // 从lst开始选骨牌
        for (int i = lst; i < q.size(); ++i) {
            Node &cur = q[i];
            // 如果骨牌的两个格子已被覆盖，跳过
            if (mp[cur.x1][cur.y1] || mp[cur.x2][cur.y2]) continue;
            // 标记覆盖
            mp[cur.x1][cur.y1] = mp[cur.x2][cur.y2] = true;
            // 递归选下一个骨牌
            dfs(now_k + 1, i + 1, num + cur.val);
            // 回溯：取消标记
            mp[cur.x1][cur.y1] = mp[cur.x2][cur.y2] = false;
        }
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(0);
        cin >> n >> k;
        // 读入网格，计算总和
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                cin >> a[i][j];
                sum += a[i][j];
            }
        }
        // 生成所有可能的骨牌（横向和纵向）
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (i < n) // 纵向骨牌（i,j）和（i+1,j）
                    q.push_back({a[i][j] + a[i+1][j], i, j, i+1, j});
                if (j < n) // 横向骨牌（i,j）和（i,j+1）
                    q.push_back({a[i][j] + a[i][j+1], i, j, i, j+1});
            }
        }
        // 按权值从大到小排序，保留前56个
        sort(q.begin(), q.end(), cmp);
        int sz = min((int)q.size(), 56);
        q.resize(sz);
        // 计算前缀和s
        s[0] = 0;
        for (int i = 1; i <= sz; ++i)
            s[i] = s[i-1] + q[i-1].val;
        // 开始DFS
        dfs(1, 0, 0);
        // 输出未覆盖的总和（总和-覆盖的最大总和）
        cout << sum - ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. 读入网格，计算所有数字的总和；
    > 2. 生成所有可能的骨牌（横向和纵向），按权值从大到小排序；
    > 3. 保留前56个骨牌，计算它们的权值前缀和（用于剪枝）；
    > 4. 用DFS搜索选k个不重叠的骨牌，中途用剪枝优化；
    > 5. 输出总和减去覆盖的最大总和（未覆盖的最小值）。

---

<code_intro_selected>
接下来看**费用流**和**meet-in-the-middle**的核心片段，感受不同解法的巧妙：
</code_intro_selected>

**题解二：费用流（核心片段）**
* **亮点**：用黑白染色建图，解决骨牌覆盖的匹配问题，空间优化（short）。
* **核心代码片段**：
    ```cpp
    // 建图逻辑（zsq147258369的题解简化）
    const int N = 4e6 + 500;
    struct Edge { int v, nxt; short c, w; }; // c是容量，w是费用
    Edge e[M]; // M是边数
    int head[N], cnt = 1;

    // 加边：u→v，容量c，费用w
    void add(int u, int v, short c, short w) {
        e[++cnt] = {v, head[u], c, w};
        head[u] = cnt;
        e[++cnt] = {u, head[v], 0, -w}; // 反向边
    }

    int main() {
        int n, k; cin >> n >> k;
        int s = n*n + 1, t = s + 1; // 源点s，汇点t
        long long tot = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                cin >> a[i][j]; tot += a[i][j];
                int id = (i-1)*n + j; // 格子的编号
                if ((i+j) % 2 == 1) { // 黑格：源点→黑格
                    add(s, id, 1, -a[i][j]); // 费用取反（因为要最大费用）
                    // 连相邻的白格
                    int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};
                    for (int d = 0; d < 4; ++d) {
                        int x = i + dx[d], y = j + dy[d];
                        if (x >= 1 && x <= n && y >= 1 && y <= n) {
                            int v = (x-1)*n + y;
                            add(id, v, 1, 0); // 黑格→白格，费用0
                        }
                    }
                } else { // 白格：白格→汇点
                    add(id, t, 1, -a[i][j]);
                }
            }
        }
        // 跑最大费用最大流（zkw算法）
        zkw(s, t, k);
        cout << tot + mincost << endl; // mincost是负的，总和+mincost=未覆盖的最小值
    }
    ```
* **代码解读**：
    > - 黑白染色：(i+j)为奇数的是黑格，偶数的是白格；
    > - 源点连黑格：容量1（每个黑格只能被选一次），费用是`-a[i][j]`（因为要把最大费用转化为最小费用问题）；
    > - 黑格连相邻白格：容量1，费用0（骨牌连接黑格和白格）；
    > - 白格连汇点：容量1，费用是`-a[i][j]`；
    > - 最后跑zkw算法求最小费用最大流，结果`tot + mincost`就是未覆盖的最小值（因为mincost是负的，相当于总和减去覆盖的最大总和）。
* 💡 **学习笔记**：费用流解决匹配问题时，“颜色划分”是关键，把问题转化为“选边”的问题！

**题解三：meet-in-the-middle（核心片段）**
* **亮点**：把大状态分成两半，分别计算后合并，解决状态爆炸问题。
* **核心代码片段**：
    ```cpp
    // UnyieldingTrilobite的题解简化：分两半处理
    const int W = 21; // 前一半的大小
    int f[1 << W]; // 前一半的状态：f[s]是选s对应的骨牌的总和（s是二进制位，表示选哪些骨牌）
    int g[1 << (M - W)]; // 后一半的状态

    int main() {
        // 生成前M个最大的骨牌（M=50）
        vector<pair<int, int>> dominoes = ...; // 每个骨牌的两个格子编号
        sort(dominoes.begin(), dominoes.end(), [](auto a, auto b) {
            return get_val(a) > get_val(b); // 按权值从大到小排序
        });
        dominoes.resize(50);
        // 分成前d个（d=22）和后（50-d）个
        int d = min((int)dominoes.size()/2, W);
        // 处理前一半：状压DP
        for (int i = 0; i < d; ++i) {
            f[1 << i] = get_val(dominoes[i]); // 选第i个骨牌的总和
            // 处理重叠的情况：如果两个骨牌重叠，状态设为INF（非法）
            for (int j = 0; j < i; ++j) {
                if (is_overlap(dominoes[i], dominoes[j])) {
                    f[(1 << i) | (1 << j)] = INF;
                }
            }
        }
        // 高维前缀和：计算所有状态的合法总和
        for (int i = 0; i < d; ++i) {
            for (int s = 0; s < (1 << d); ++s) {
                if (s & (1 << i) && __builtin_popcount(s) <= k) {
                    f[s] = min(f[s], f[s ^ (1 << i)] + f[1 << i]);
                }
            }
        }
        // 处理后一半：类似前一半
        ...
        // 合并两部分：找前一半的状态s，后一半的状态t，s和t不重叠，且总数量≤k
        int ans = 0;
        for (int s = 0; s < (1 << d); ++s) {
            if (f[s] == INF || __builtin_popcount(s) > k) continue;
            int rem = k - __builtin_popcount(s);
            // 找后一半中选rem个、不与s重叠的最大总和
            int max_g = get_max_g(s, rem);
            ans = max(ans, f[s] + max_g);
        }
        cout << sum - ans << endl;
    }
    ```
* **代码解读**：
    > - 分两半：把前50个骨牌分成前22个和后28个；
    > - 状压DP：前一半的每个状态s（二进制位表示选哪些骨牌）存储选这些骨牌的总和，如果重叠则设为INF（非法）；
    > - 高维前缀和：快速计算所有状态的合法总和；
    > - 合并：对前一半的每个状态s，找后一半中选剩余数量、不重叠的最大总和，合并得到最优解。
* 💡 **学习笔记**：meet-in-the-middle的核心是“分治”，把大问题拆成两个小问题，再合并结果！


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了让你更直观地理解**贪心+DFS**的过程，我设计了一个**8位像素风**的动画演示——就像玩FC游戏《推箱子》一样，你能看到骨牌的选择、覆盖和剪枝过程！
\</visualization\_intro\>

### **动画设计方案**
- **主题**：像素探险家在网格中“捡金币”（骨牌），每次捡一个金币会覆盖两个格子，目标是捡k个金币，总价值最大。
- **风格**：8位像素风（类似《超级马里奥》），用不同颜色表示：
  - 白色格子：未被覆盖；
  - 黄色格子：当前选的骨牌；
  - 灰色格子：已被覆盖；
  - 红色格子：不可选的骨牌（重叠）。
- **核心演示步骤**：
  1. **初始化**：显示n×n的网格，每个格子上的数字是它的权值。下方显示“当前总和”“已选数量”“最优总和”。
  2. **排序骨牌**：右侧显示前56个骨牌的列表，按权值从大到小排列，高亮当前候选的骨牌。
  3. **DFS过程**：
     - **选骨牌**：点击“单步执行”，动画会选中一个骨牌（黄色高亮），并标记它的两个格子为灰色（已覆盖）；
     - **回溯**：如果当前路径无法更优，动画会“撤销”选择（灰色变回白色），跳到下一个候选骨牌；
     - **剪枝提示**：当触发剪枝时，屏幕下方弹出“当前+后面最大不够，跳过！”的文字，同时候选骨牌列表会灰色显示后面的骨牌。
  4. **完成**：当选够k个骨牌，播放“胜利”音效（8位音乐），高亮所有选中的骨牌，显示“未覆盖总和：X”。

### **交互设计**
- **控制面板**：包含“开始/暂停”“单步执行”“重置”按钮，以及“速度滑块”（控制动画速度）；
- **AI演示**：点击“AI自动播放”，动画会自动执行DFS，快速找到最优解；
- **音效**：
  - 选骨牌：“叮”的音效；
  - 回溯：“嗒”的音效；
  - 剪枝：“嗡”的音效；
  - 胜利：《超级马里奥》的通关音乐片段。

### **为什么这样设计？**
- 像素风格：复古有趣，符合青少年的审美；
- 高亮与音效：强化“选/不选”的操作记忆；
- 剪枝提示：直观展示“为什么跳过这条路径”，帮助理解优化逻辑。


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
掌握了这道题的解法后，你可以尝试以下类似问题，巩固“贪心+搜索”“费用流”“meet-in-the-middle”的技巧：
\</similar\_problems\_intro\>

### **通用思路迁移**
- **贪心+搜索**：适用于“选k个不重叠的物品，求最大价值”的问题（比如选k个不重叠的矩形，求最大面积）；
- **费用流**：适用于“二分图匹配+最大/最小费用”的问题（比如运输货物，求最小成本）；
- **meet-in-the-middle**：适用于“k小但状态量大”的问题（比如选k个物品，求最大异或和）。

### **洛谷练习推荐**
1.  **洛谷 P3381** - 【模板】最小费用最大流
   * 🗣️ **推荐理由**：费用流的基础模板题，帮你掌握费用流的实现细节（比如SPFA找增广路径）。
2.  **洛谷 P1251** - 餐巾计划问题
   * 🗣️ **推荐理由**：费用流的经典应用，需要处理“时间”和“流量”的关系，锻炼建模能力。
3.  **洛谷 P2053** - [SCOI2007] 修车
   * 🗣️ **推荐理由**：费用流的变形题，需要把“修车时间”转化为费用，培养逆向思维。
4.  **洛谷 P5495** - 【模板】高维前缀和（SOS DP）
   * 🗣️ **推荐理由**：UnyieldingTrilobite题解中用到的高维前缀和模板题，帮你理解状压DP的优化。


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>
从题解中，我提取了两个重要的学习心得，帮你少走弯路：
\</insights\_intro\>

> **心得1**（来自Cells的题解）：“贪心选前56个骨牌”的思路，是解决“k小但n大”问题的关键。作者提到：“每个骨牌最多挡住6个其他骨牌，所以前7×8=56个足够覆盖最优解。”这个结论让我意识到，**利用问题的“局部性”（权值大的骨牌更可能被选）可以大幅缩小搜索范围**。
>
> **心得2**（来自zsq147258369的题解）：“用short存边”的优化，解决了n=2e3时的内存问题。作者提到：“边的容量和费用都很小，用short足够，这样能节省一半的内存。”这个技巧告诉我，**面对大数据时，要注意数据类型的选择，避免不必要的内存浪费**。


\<conclusion\>
本次关于“DOMINO”的分析就到这里！这道题融合了贪心、搜索、费用流、meet-in-the-middle等多种技巧，是锻炼算法思维的好题目。记住：**算法的选择取决于数据范围**——k小用搜索，匹配问题用费用流，状态量大用分治。下次我们再一起探索新的算法挑战！💪
\</conclusion\>

---
处理用时：213.52秒
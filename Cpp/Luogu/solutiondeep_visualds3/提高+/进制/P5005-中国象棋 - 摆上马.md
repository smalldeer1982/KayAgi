# 题目信息

# 中国象棋 - 摆上马

## 题目背景

~~相信自己的做法 大喊一声 I won't MLE！您就会过这道题~~

Imakf 玩腻了国际象棋，决定玩一玩中国象棋。

他发现中国象棋的马和国际象棋的马有所不同，他意识到这又可以出一道简单的问题，于是他又准备摆一摆马了

## 题目描述

Imakf 有一个 $X$ 行 $Y$ 列的棋盘，还有很多**完全相同**的马（你可以认为有无数个）。现在在棋盘上摆上马（或者不摆），求任何马无法攻击另一匹马的方案总数。

中国象棋的马和国际象棋的马不同。

![](https://cdn.luogu.com.cn/upload/pic/40761.png)

注意：实际问题中是没有兵的。

当然由于方案可能过多，请输出对 $(10^9+7)$ 取模的值


## 说明/提示

对于 100% 的数据，有 $1\le X\leq100$，$1\le Y\leq6$。

对于 20% 的数据，有 $X,Y\leq6$。

对于另外 20% 的数据，有 $X\leq20$。

对于样例 1，可以选择不摆或者摆。

对于样例 2，我有一个绝妙的解释可惜我写不下。


## 样例 #1

### 输入

```
1 1 
```

### 输出

```
2```

## 样例 #2

### 输入

```
3 3 
```

### 输出

```
145```

# AI分析结果



---

# 💡 Kay的C++算法解析：中国象棋 - 摆上马 深入学习指南 💡

<introduction>
今天我们来一起分析“中国象棋 - 摆上马”这道题。这道题需要计算在棋盘上放置马且互不攻击的方案数，数据范围提示我们用状态压缩动态规划（状压DP）解决。本指南将带大家理清思路、掌握核心算法，并通过可视化理解状态转移过程。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`状压动态规划（状压DP）`

🗣️ **初步分析**：
解决这道题的关键在于用二进制状态表示每行的马的位置（状压），并通过动态规划（DP）逐行计算合法方案数。状压DP就像“用二进制密码本记录每行的摆放状态”，通过位运算高效处理状态间的转移。

在本题中，由于马的攻击范围涉及前两行（例如，当前行的马可能攻击上一行或上上行的马，反之亦然），我们需要记录当前行和前一行的状态，因此状态定义为 `dp[i][j][k]`（第i行状态为j，第i-1行状态为k时的方案数）。核心难点是判断三个连续行的状态是否合法（即是否存在马互相攻击的情况），这需要处理“蹩马腿”的规则。

**核心算法流程**：
1. **状态定义**：`dp[i][j][k]` 表示处理到第i行时，第i行状态为j，第i-1行状态为k的方案数。
2. **状态转移**：枚举第i-2行的状态l，若j（当前行）、k（前一行）、l（前两行）互不攻击，则 `dp[i][j][k] += dp[i-1][k][l]`。
3. **合法性判断**：通过位运算检查相邻两行（j和k）及隔行（j和l）是否存在攻击，考虑“蹩马腿”（例如，马向右攻击时，若右侧相邻位置无马，则可能攻击右右位置的马）。

**可视化设计思路**：
采用8位像素风格动画，用不同颜色的方块表示马（如绿色）和空位（灰色）。每一步演示状态转移时，高亮当前处理的行（如黄色边框）、前一行（蓝色边框），并用箭头标出可能的攻击路径（红色虚线）。当检测到冲突时，相关位置闪烁红色并播放提示音效；合法转移时，播放轻快的“叮”声。动画支持单步/自动播放，速度可调，帮助学习者直观看到状态如何从初始行逐步推导到最后一行。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，以下题解在思路清晰度、代码规范性和算法有效性上表现突出（≥4星），值得重点学习：
</eval_intro>

**题解一：作者Imakf（赞47）**
* **点评**：此题解详细解释了状态定义和转移过程，尤其对“蹩马腿”的判断逻辑（`at_bt`和`at_3`函数）进行了图文结合的说明，代码结构清晰。亮点在于预处理攻击范围（如`at_bt`计算当前行对下一行的攻击区域），大大简化了状态转移时的冲突检查。代码中使用滚动数组优化空间，符合题目空间限制要求，实践价值高。

**题解二：作者hater（赞28）**
* **点评**：此题解聚焦空间优化，通过滚动数组（`f[4][1<<6][1<<6]`）将空间复杂度从O(X*2^Y*2^Y)降低到O(2^Y*2^Y)，避免了MLE。代码中的`Ch1`和`Ch2`函数用位运算简洁实现了两行和三行的合法性判断，逻辑紧凑，适合竞赛快速实现。

**题解三：作者Utilokasteinn（赞12）**
* **点评**：此题解直接给出了状态转移的核心代码，并详细注释了每个位运算的含义（如`i&(~i>>1)&(j>>2)`表示“左边无马且左上有马”的冲突）。代码简洁，逻辑清晰，适合初学者理解状压DP的核心步骤。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题时，我们常遇到以下关键难点，结合优质题解的经验，总结策略如下：
</difficulty_intro>

1.  **关键点1：如何定义状态？**
    * **分析**：马的攻击范围涉及前两行，因此状态需包含当前行和前一行的状态（`dp[i][j][k]`）。这样，转移时可枚举前两行的状态l，检查j、k、l是否合法。
    * 💡 **学习笔记**：状态定义需覆盖所有影响当前决策的历史信息，本题中前两行的状态共同决定了当前行的合法性。

2.  **关键点2：如何判断状态合法性？**
    * **分析**：合法性分两种：
      - 相邻两行冲突：当前行j的马攻击前一行k的马（或反之），需检查“蹩马腿”（如j的某位置有马，若右侧相邻无马，则右右位置不能有马）。
      - 隔行冲突：当前行j的马攻击前两行l的马（或反之），需检查中间行k是否“蹩腿”（如j的某位置有马，若中间行k的同位置无马，则l的左右位置不能有马）。
    * 💡 **学习笔记**：合法性判断是状压DP的核心，需结合题目规则（如“蹩马腿”）设计位运算逻辑。

3.  **关键点3：如何优化空间？**
    * **分析**：直接使用三维数组`dp[X][2^Y][2^Y]`会超出空间限制（X≤100，Y≤6时，空间约为100*64*64=409600字节，但题目限制1MB）。通过滚动数组（仅保留当前行和前一行的状态）可将空间降为O(2^Y*2^Y)。
    * 💡 **学习笔记**：滚动数组是处理大行数状压DP的常用技巧，通过取模操作复用空间。

### ✨ 解题技巧总结
- **问题分解**：将问题拆解为状态定义、合法性判断、空间优化三部分，逐步解决。
- **位运算简化**：用位运算（如`<<`、`>>`、`&`）快速计算攻击范围，避免逐位遍历。
- **预处理优化**：预先计算所有可能状态的合法性（如冲突矩阵），减少转移时的重复计算。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
首先，我们看一个综合优质题解思路的通用核心实现，它采用滚动数组优化空间，并清晰实现了状态转移和合法性判断。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Imakf和hater的题解思路，使用滚动数组优化空间，通过位运算实现合法性判断，适合竞赛快速编写。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MOD = 1e9 + 7;
    int n, m;
    int dp[2][1 << 6][1 << 6]; // 滚动数组优化空间

    // 检查两行是否合法（相邻行）
    inline bool check_adj(int a, int b) {
        // 检查a行是否攻击b行，或b行是否攻击a行（考虑蹩马腿）
        if (((a << 2) & (b & ~(b << 1))) || ((a >> 2) & (b & ~(b >> 1))) ||
            ((b << 2) & (a & ~(a << 1))) || ((b >> 2) & (a & ~(a >> 1))))
            return false;
        return true;
    }

    // 检查三行是否合法（当前行a，前一行b，前两行c）
    inline bool check_tri(int a, int b, int c) {
        if (((a << 1) & (c & ~b)) || ((a >> 1) & (c & ~b)) ||
            ((c << 1) & (a & ~b)) || ((c >> 1) & (a & ~b)))
            return false;
        return true;
    }

    int main() {
        cin >> n >> m;
        int max_state = 1 << m;
        // 初始化第一行（无前行）
        for (int i = 0; i < max_state; ++i)
            dp[0][i][0] = 1;
        // 处理第二行（只有前一行）
        if (n >= 2) {
            for (int i = 0; i < max_state; ++i)
                for (int j = 0; j < max_state; ++j)
                    if (check_adj(i, j))
                        dp[1][j][i] = (dp[1][j][i] + dp[0][i][0]) % MOD;
        }
        // 处理第三行及以后（需要前两行）
        for (int i = 3; i <= n; ++i) {
            int cur = i % 2, pre = (i - 1) % 2;
            memset(dp[cur], 0, sizeof(dp[cur])); // 清空当前行状态
            for (int j = 0; j < max_state; ++j)      // 当前行状态
                for (int k = 0; k < max_state; ++k)  // 前一行状态
                    if (check_adj(j, k))
                        for (int l = 0; l < max_state; ++l) // 前两行状态
                            if (check_adj(k, l) && check_tri(j, k, l))
                                dp[cur][j][k] = (dp[cur][j][k] + dp[pre][k][l]) % MOD;
        }
        // 统计所有合法状态的方案数
        int ans = 0;
        int final_row = n % 2;
        for (int i = 0; i < max_state; ++i)
            for (int j = 0; j < max_state; ++j)
                if (check_adj(i, j))
                    ans = (ans + dp[final_row][i][j]) % MOD;
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
  - 滚动数组`dp[2][...][...]`仅保留当前行和前一行的状态，节省空间。
  - `check_adj`函数判断相邻两行是否合法（处理“蹩马腿”）。
  - `check_tri`函数判断隔行是否合法（处理跨行攻击）。
  - 初始化第一行后，逐行计算，最终统计所有合法状态的方案数。

---
<code_intro_selected>
接下来，分析优质题解中的核心代码片段，理解其亮点和实现思路：
</code_intro_selected>

**题解一：作者Imakf（来源：洛谷题解）**
* **亮点**：预处理攻击范围函数（`at_bt`和`at_3`），将复杂的冲突判断转化为位运算，代码复用性高。
* **核心代码片段**：
    ```cpp
    int at_bt(int a) { // 计算当前行a对下一行的攻击范围
        int c = 0;
        for (int i = 1; (1 << (i - 1)) <= a; ++i) {
            if (!(a & (1 << (i - 1)))) continue; // 当前位无马，跳过
            if (!(a & (1 << (i - 2)))) c |= (1 << (i - 3)); // 左无蹩腿，攻击左左
            if (!(a & (1 << i))) c |= (1 << (i + 1)); // 右无蹩腿，攻击右右
        }
        return c;
    }
    ```
* **代码解读**：
  - `at_bt(a)`函数遍历当前行a的每一位，若某位有马（`a & (1 << (i-1))`），则检查左右是否有蹩腿（左邻位`i-2`或右邻位`i`是否无马）。若没有蹩腿，则标记攻击位置（左左位`i-3`或右右位`i+1`）。
  - 例如，若当前行第3位（i=3）有马，且第2位（i-1=2）无马（无蹩腿），则攻击第1位（i-3=0）。
* 💡 **学习笔记**：预处理攻击范围是优化冲突判断的关键，通过位运算快速计算攻击区域，避免重复遍历。

**题解二：作者hater（来源：洛谷题解）**
* **亮点**：滚动数组优化空间，代码简洁，冲突判断逻辑紧凑。
* **核心代码片段**：
    ```cpp
    inline bool Ch1(int k1, int k2, bool I) { // 检查相邻两行是否合法
        int T = ~(((k1 >> 1) & k1) >> 1), K = T & k2;
        if ((k1 >> 2) & K) return false;
        T = ~(((k1 << 1) & k1) << 1); K = T & k2;
        if ((k1 << 2) & K) return false;
        return I ? true : Ch1(k2, k1, true); // 反向检查k2是否攻击k1
    }
    ```
* **代码解读**：
  - `Ch1`函数检查k1是否攻击k2。`(k1 >> 1) & k1`找到k1中右邻位有马的位置（即有蹩腿的位置），取反后与k2按位与（`T & k2`）得到无蹩腿时k2的可能被攻击位。若k1右移两位后与这些位有交集（`(k1 >> 2) & K`），说明存在攻击。
  - 例如，k1的第i位有马，若右邻位（i+1）无马（无蹩腿），则k2的i+2位不能有马（否则被攻击）。
* 💡 **学习笔记**：位运算的组合（移位、与、取反）能高效模拟“蹩马腿”规则，减少代码复杂度。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解状态转移过程，我们设计一个“像素棋盘探险”动画，用8位复古风格演示状压DP的每一步！
</visualization_intro>

  * **动画演示主题**：`像素马的安全摆放`

  * **核心演示内容**：
    从第一行开始，逐步填充每一行的状态（马的位置用绿色方块表示），动态展示状态转移时如何检查相邻行和隔行的冲突，最终统计所有合法方案。

  * **设计思路简述**：
    采用FC红白机风格，棋盘用8x8像素方块表示，马的位置用绿色高亮，冲突位置用红色闪烁。通过单步/自动播放控制，学习者可观察每一行状态如何依赖前两行，并理解滚动数组的空间优化原理。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
        - 棋盘显示为X行Y列的网格（每行6列，最多100行），初始全灰（无马）。
        - 控制面板包含“单步”、“自动播放”按钮和速度滑块（1-10倍速）。
        - 8位风格背景音乐（如《超级马里奥》经典旋律）轻响。

    2.  **第一行状态初始化**：
        - 第一行每个位置可选择放马（绿）或不放（灰），所有可能状态（共2^Y种）用动画快速切换，最后定格为`dp[0][i][0] = 1`（每种状态初始方案数为1）。

    3.  **第二行状态转移**：
        - 逐一枚举第二行的状态j和第一行的状态i。若j和i合法（无攻击），则j的方块变为绿色，播放“叮”声，并显示`dp[1][j][i] += dp[0][i][0]`的数值变化。

    4.  **第三行及以后的状态转移**：
        - 对于第i行（i≥3），当前行状态j、前一行状态k、前两行状态l。用箭头连接k→j，检查j与k、k与l、j与l是否合法：
          - 合法时，j的方块变绿，数值累加，播放“叮”声。
          - 冲突时，j的方块闪烁红色，播放“滴滴”提示音。
        - 滚动数组用不同颜色区分当前行（黄色）和前一行（蓝色），显示空间复用过程。

    5.  **最终统计**：
        - 所有行处理完成后，棋盘所有合法状态的绿色方块闪烁，数值累加显示总方案数，播放胜利音效（如《超级玛丽》通关音）。

  * **旁白提示**：
    - （单步时）“现在处理第3行，当前状态j=0101，前一行k=1010。检查j和k是否冲突：j的第2位有马，k的第4位无马（无蹩腿），j的第2位攻击k的第4位？不冲突，合法！”
    - （自动播放时）“注意看滚动数组，当前行的状态只依赖前一行，空间被重复利用，这样就不会超内存啦～”

<visualization_conclusion>
通过这个动画，我们能直观看到状压DP如何逐行计算合法方案，以及滚动数组如何优化空间。每一步的冲突检查和状态转移都“看得见”，学习起来更轻松！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
状压DP是处理棋盘类摆放问题的常用方法，掌握后可解决以下类型的问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 棋盘摆放问题（如放国王、放炮兵）：状态定义需考虑棋子攻击范围，用状压表示行状态。
    - 多阶段决策问题（如资源分配）：用状态表示阶段和资源使用情况，转移时考虑约束条件。
    - 图的路径问题（如旅行商问题）：用状压表示已访问节点，转移时枚举下一个节点。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1896 [SCOI2005]互不侵犯**  
        🗣️ **推荐理由**：与本题类似，用状压DP处理“国王”的攻击范围（横向、纵向、斜向），巩固状态定义和冲突判断。
    2.  **洛谷 P2704 [NOI2001]炮兵阵地**  
        🗣️ **推荐理由**：状态需记录前两行，转移时考虑更远的攻击范围（隔两行），挑战更复杂的冲突判断。
    3.  **洛谷 P2051 [AHOI2009]中国象棋**  
        🗣️ **推荐理由**：同样涉及中国象棋的棋子摆放（车），但规则不同，练习如何根据题目规则调整状态定义和转移逻辑。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自hater)**：“一开始没考虑滚动数组，直接开了三维数组，结果MLE。后来意识到只需要保留前一行的状态，用滚动数组优化后就过了。”

**点评**：hater的经验提醒我们，处理大行数问题时，空间优化是关键。滚动数组通过复用空间，将空间复杂度从O(X*S^2)降为O(S^2)（S为状态数），是竞赛中常用的技巧。调试时，若遇到MLE，应优先检查数组维度是否可压缩。

---

<conclusion>
通过这篇指南，我们掌握了“中国象棋 - 摆上马”的状压DP解法，理解了状态定义、冲突判断和空间优化的核心逻辑，并通过可视化动画直观感受了算法过程。接下来，不妨尝试拓展练习，巩固状压DP的应用！记住，多思考、多动手，编程能力会稳步提升～💪
</conclusion>

---

---
处理用时：220.41秒
# 题目信息

# [SDOI2013] 随机数生成器

## 题目背景

小 W 喜欢读书，尤其喜欢读《约翰克里斯朵夫》。

## 题目描述

最近小 W 准备读一本新书，这本书一共有 $p$ 页，页码范围为 $0 \sim p-1$。

小 W 很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用 NOI2012 上学习的线性同余法生成一个序列，来决定每天具体读哪一页。

我们用 $x_i$ 来表示通过这种方法生成出来的第 $i$ 个数，也即小 W 第 $i$ 天会读哪一页。这个方法需要设置 $3$ 个参数 $a,b,x_1$，满足 $0\leq a,b,x_1\lt p$，且 $a,b,x_1$ 都是整数。按照下面的公式生成出来一系列的整数：
$$x_{i+1} \equiv a \times x_i+b \pmod p$$
其中 $\bmod$ 表示取余操作。

但是这种方法可能导致某两天读的页码一样。

小 W 要读这本书的第 $t$ 页，所以他想知道最早在哪一天能读到第 $t$ 页，或者指出他永远不会读到第 $t$ 页。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq T \leq 50$。
- $0 \leq a, b, x_1, t \lt p$，$2 \leq p \leq 10^9$。
- $p$ 为质数。

## 样例 #1

### 输入

```
3
7 1 1 3 3
7 2 2 2 0
7 2 2 2 1
```

### 输出

```
1 
3 
-1```

# AI分析结果


### 💡 Kay的C++算法解析：随机数生成器 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`数学推导与BSGS算法`  
🗣️ **初步分析**：
> 解决本题的关键在于运用**离散对数问题**的求解思想，核心技巧是**BSGS算法**（大步小步法）。想象你在迷宫中寻找最短路径，BSGS算法就是通过"分块搜索"（先大步跨跃再小步微调）高效定位目标值。  
> - 核心思路：通过数学变换将线性递推式转化为指数形式，得到方程 $a^{n-1} \equiv K \pmod{p}$，再用BSGS求解指数 $n-1$。
> - 核心难点：需处理多种边界情况（$a=0, a=1, x_1=t$），以及复杂的模逆元计算和负数处理。
> - 可视化设计：采用**8位像素风格**的迷宫探索动画。玩家（像素小人）从起点 $x_1$ 出发，每一步根据公式 $x_{i+1}=(ax_i+b) \mod p$ 跳跃到新位置。关键步骤高亮显示当前格子、计算公式和天数，伴随"嘀"声提示。控制面板支持单步/自动模式（调速滑块），解出 $t$ 时播放胜利音效并放烟花。

#### 2. 精选优质题解参考
**题解一：ChenZ01**  
* **点评**：  
  思路清晰推导严谨，从等比数列变换到BSGS的数学链条完整。代码规范（变量名如 `inv` 含义明确），边界处理全面（如 $a=0/1$ 特判）。亮点在于**模块化设计**：分离快速幂、逆元与BSGS，便于调试。实践价值高，可直接用于竞赛。

**题解二：wwyx2001**  
* **点评**：  
  以简洁的数学变换（$X_i + \frac{b}{a-1}$ 构造等比数列）直击核心。代码亮点是**手写哈希表优化**（洛谷最优解）。虽然推导略简，但代码高效且边界处理严谨（如 $a=1$ 时判断 $b=0$ 的情况），适合追求效率的竞赛场景。

**题解三：HoshiuZ**  
* **点评**：  
  详解分类讨论（$a=0/1/\geq2$），突出**负数处理技巧**（`(x%p+p)%p`）。代码结构工整，BSGS与逆元计算封装良好。亮点是**调试经验分享**：强调模运算中负值转正的重要性，对学习者调试有实际启发。

---

#### 3. 核心难点辨析与解题策略
1. **关键点1：递推式到指数形式的转化**  
   * **分析**：需将 $x_{i+1} \equiv ax_i+b \pmod{p}$ 变形为 $a^{n-1} \equiv K \pmod{p}$。技巧是构造等比数列 $Y_i = X_i + \frac{b}{a-1}$，得 $Y_i = a^{i-1}Y_1$。  
   * 💡 学习笔记：**待定系数法**是处理线性递推的通用工具。

2. **关键点2：边界情况的数学处理**  
   * **分析**：  
     - $a=0$：序列退化为常数列，只需判断 $t$ 是否等于 $b$；  
     - $a=1$：转化为等差数列 $x_n = x_1 + (n-1)b$，需解线性同余方程；  
     - 分母为零：当 $a-1 \equiv 0 \pmod{p}$ 时需单独处理。  
   * 💡 学习笔记：**分情况讨论**是数学题的核心解题策略。

3. **关键点3：BSGS算法的应用细节**  
   * **分析**：求解 $a^x \equiv b \pmod{p}$ 时需注意：  
     - 哈希表存储 $b \cdot a^j$ 而非 $a^j$ 以优化查询；  
     - 分块大小 $m = \lceil \sqrt{p} \rceil$ 平衡预处理与查询开销；  
     - 使用逆元避免除法。  
   * 💡 学习笔记：**分块思想**可扩展至各类离散问题。

✨ **解题技巧总结**：
- **技巧1：模运算规范化**：所有中间结果转为 $[0, p-1]$，避免负值干扰（如 `(x%p+p)%p`）。  
- **技巧2：逆元统一处理**：在质数模下，用费马小定理 $inv(a) = a^{p-2} \mod p$ 替代除法。  
- **技巧3：小数据验证**：用样例 $p=7, a=1, b=1, x_1=1, t=3$ 测试边界逻辑。

---

#### 4. C++核心代码实现赏析
```cpp
#include <iostream>
#include <cmath>
#include <map>
using namespace std;
typedef long long ll;

ll qpow(ll a, ll b, ll p) {
    ll res = 1;
    for (; b; b >>= 1, a = a * a % p)
        if (b & 1) res = res * a % p;
    return res;
}

ll inv(ll x, ll p) { return qpow(x, p-2, p); }

ll bsgs(ll a, ll b, ll p) {
    a %= p; b %= p;
    if (b == 1) return 0;
    ll m = ceil(sqrt(p)), t = 1;
    map<ll, ll> mp;
    for (ll i = 0; i < m; i++, t = t * a % p)
        if (!mp.count(t)) mp[t] = i;
    ll k = inv(t, p), w = b;
    for (ll i = 0; i < m; i++, w = w * k % p)
        if (mp.count(w)) return i * m + mp[w];
    return -1; // 无解
}

int main() {
    int T; cin >> T;
    while (T--) {
        ll p, a, b, x1, t;
        cin >> p >> a >> b >> x1 >> t;
        // 边界处理：x1=t, a=0, a=1
        if (x1 == t) { cout << "1\n"; continue; }
        if (a == 0) { cout << (b == t ? "2\n" : "-1\n"); continue; }
        if (a == 1) {
            if (b == 0) cout << (t == x1 ? "1\n" : "-1\n");
            else {
                ll res = (t - x1 + p) % p * inv(b, p) % p;
                cout << (res == 0 ? p : res) + 1 << endl;
            }
            continue;
        }
        // 通项公式变形
        ll c = b * inv(a-1, p) % p;
        ll B = (t + c) % p * inv((x1 + c) % p, p) % p;
        ll ans = bsgs(a, B, p);
        cout << (ans < 0 ? -1 : ans + 1) << endl;
    }
}
```
**代码解读概要**：  
1. 分情况处理所有边界条件（$x_1=t, a=0, a=1$）；  
2. 对 $a \geq 2$ 的情况，计算常数 $c = b/(a-1)$ 并变形为 BSGS 可解形式；  
3. 调用 BSGS 求解指数，结果 $+1$ 即为天数。

---

#### 5. 算法可视化：像素动画演示
**主题**：`8位机风格"随机数迷宫"`  
**核心演示**：  
1. **场景初始化**：  
   - 绘制环形迷宫（周长 $p$），格子编号 $0$ 至 $p-1$；  
   - 像素小人起始于 $x_1$，目标 $t$ 格子闪烁绿光。  
   - 控制面板：`单步执行`、`自动播放`（速度滑块）、`重置`。  

2. **递推过程演示**：  
   ```plaintext
   第 i 天: 位置 = (a * 前位置 + b) % p
   → 新位置计算：黄色高亮当前格子，显示公式
   → 小人跳跃至新格子，伴随"嘀"声
   ```

3. **BSGS分块搜索**：  
   - **大步**：计算 $m = \lceil \sqrt{p} \rceil$，预处理 $a^0, a^m, a^{2m}, \dots$ 显示为蓝色路径；  
   - **小步**：逆序检查 $b \cdot a^{-im}$，匹配时触发红光并显示解。  

4. **胜利与交互**：  
   - 到达 $t$：放烟花 + 胜利音效 + 显示"第 $n$ 天达成"；  
   - 支持`暂停观察`当前状态，`重置`回起点。

---

#### 6. 拓展练习与相似问题思考
1. **通用技巧迁移**：  
   BSGS算法还可用于解决：  
   - 离散对数问题（如椭圆曲线密码）  
   - 数论中指数方程求解（如 $a^x \equiv b \pmod{p}$）  
   - 哈希碰撞的高效检索  

2. **推荐练习**：  
   - **洛谷 P3846**：BSGS模板题（基础应用）  
   - **洛谷 P2485**：计算器（扩展BSGS场景）  
   - **洛谷 P3306**：本题（综合数学变换）

---

#### 7. 学习心得与经验分享
> **ChenZ01的调试经验**：  
> *"处理 $a=1$ 时，若 $ (t-x_1) \cdot inv(b) \equiv 0 \pmod{p}$，需返回 $p$ 而非 $1$（因 $x_1 \neq t$）"*  
> **Kay点评**：这提醒我们**边界值必须实际验算**，避免理论假设导致的逻辑漏洞。建议用 $p=7, a=1, b=1, x_1=1, t=1$ 测试所有分支！

--- 
> 掌握数学变换与边界处理，你也能在算法的迷宫中找到最短路径！继续挑战吧！ 💪

---
处理用时：297.22秒
# 题目信息

# [THUPC 2023 初赛] 欺诈游戏

## 题目背景

在《LIAR GAME》中，小 E 看到了一个有趣的游戏。

## 题目描述

这个游戏名叫《走私游戏》。游戏规则大概是这样的：一名玩家扮演走私者，一名玩家扮演检察官。走私者可以将 $x$ 日元（$x$ 为 $[0,n]$ 内的整数，由走私者决定）秘密放入箱子中，而检查官需要猜测箱子中的金额。假设检察官猜了 $y$（$y$ 也必须是整数）。如果 $x=y$，则走私失败，走私者一分钱也拿不到。如果 $x>y$，则走私成功，走私者可以从检查官那里拿走 $x$ 日元。如果 $x<y$，则走私失败，但是由于冤枉检察官需要赔付给走私者 $y/2$ 日元。游戏分有限回合进行。双方轮流做走私者和检察官。

可以证明，最优情况下每个回合走私者会采用同一种策略，检察官也会采用同一种策略。小 E 想知道在一个回合中，双方的最优策略分别是什么。

## 说明/提示

#### 样例解释 1

这 $4$ 个数分别为 $2/3,1/3,1/3,2/3$。

#### 子任务

保证 $1\le n \le 400000$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
1
```

### 输出

```
665496236 332748118
332748118 665496236
```

# AI分析结果



---
# 💡 Kay的C++算法解析：[THUPC 2023 初赛] 欺诈游戏 深入学习指南 💡

<introduction>
今天我们来一起分析“欺诈游戏”这道C++编程题。这道题涉及博弈论中的纳什均衡策略，需要找到走私者和检察官的最优概率分布。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`博弈论中的纳什均衡策略与递推关系应用`

🗣️ **初步分析**：
解决“欺诈游戏”的关键在于理解纳什均衡的核心思想：当一方策略固定时，另一方无法通过改变自身策略提高期望收益。简单来说，纳什均衡就像两人下棋时的“僵局”——无论你怎么走，对方都有应对策略让你无法占便宜。在本题中，我们需要找到走私者和检察官的概率分布（即选择金额的概率），使得双方所有可能选择的期望收益相等。

- **题解思路**：所有题解的核心思路一致：假设走私者选金额\(i\)的概率为\(f(i)\)，检察官猜金额\(i\)的概率为\(g(i)\)，则双方的所有可能选择的期望收益必须相等（否则对方可通过调整策略提高收益）。通过相邻项的差分推导递推公式，结合前缀和和模逆元计算具体概率。
- **核心难点**：如何从“期望收益相等”推导出递推公式？如何高效计算模意义下的概率分布？
- **可视化设计**：我们将设计一个8位像素风格的动画，用不同颜色的像素块表示\(f(i)\)和\(g(i)\)的递推过程。例如，计算\(f(i)\)时，当前项用绿色高亮，前缀和用蓝色动态累加，每完成一次递推播放“叮”的音效，最终概率分布用彩虹色展示。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下题解（≥4星）值得重点学习：
</eval_intro>

**题解一：作者Leasier (赞：5)**
* **点评**：此题解逻辑清晰，从期望收益相等的条件出发，详细推导了\(f(i)\)和\(g(i)\)的递推公式（如\(g(i) = \frac{2((i-1)g(i-1) + \sum_{j=0}^{i-1}g(j))}{i}\)），并通过前缀和和逆元高效计算概率。代码中使用预计算逆元优化，时间复杂度\(O(n)\)，适合竞赛场景。亮点在于将抽象的博弈论问题转化为具体的递推公式，代码注释清晰，边界处理严谨。

**题解二：作者WYXkk (赞：5)**
* **点评**：此题解用直观的方程组形式解释了期望收益相等的条件（如\(p_1 = \frac{1}{2}p_0\)），并通过相邻项相减推导出递推规律。代码简洁，核心递推部分仅需维护前缀和，适合快速理解。亮点在于用“枚举期望相等”的方式简化推导，降低了理解门槛。

**题解三：作者SmallBlack (赞：2)**
* **点评**：此题解结合纳什均衡理论，详细解释了“期望收益相等”的数学推导过程（如通过调整法证明所有\(E(i)\)必须相等），并使用结构体维护线性递推关系（\(ax + b\)形式），确保模运算下的正确性。代码中“lin结构体”的设计是亮点，适合学习模运算中的线性组合处理。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于突破以下三个核心难点：
</difficulty_intro>

1.  **关键点1：理解“期望收益相等”的条件**
    * **分析**：在纳什均衡下，若走私者选择\(i\)的期望收益\(E_1(i)\)大于\(E_1(j)\)，则走私者会更倾向选\(i\)，破坏均衡。因此所有\(E_1(i)\)必须相等。类似地，检察官的\(E_2(i)\)也必须相等。
    * 💡 **学习笔记**：纳什均衡的核心是“无单方面改进可能”，这意味着所有策略的期望收益必须相等。

2.  **关键点2：推导递推公式**
    * **分析**：通过\(E_1(i) = E_1(i+1)\)，展开后消去相同项，得到递推式（如\(f(i) = \frac{(i-1)f(i-1) + \sum_{j=0}^{i-1}f(j)}{2i}\)）。递推式的关键是利用前缀和（\(\sum_{j=0}^{i-1}f(j)\)）简化计算。
    * 💡 **学习笔记**：相邻项差分是推导递推式的常用技巧，能将复杂的求和问题转化为线性递推。

3.  **关键点3：模运算下的概率归一化**
    * **分析**：由于概率和为1，需将递推得到的\(f(i)\)和\(g(i)\)除以总和（模逆元计算）。预计算逆元（如\(inv[i]\)）可高效处理除法操作。
    * 💡 **学习笔记**：模逆元是模运算中除法的替代，使用费马小定理（\(inv[i] = i^{mod-2} \mod mod\)）快速计算。

### ✨ 解题技巧总结
- **问题抽象**：将博弈问题转化为数学期望问题，利用“期望相等”条件建立方程。
- **递推优化**：维护前缀和数组（如\(pre[i] = pre[i-1] + f[i-1]\)），避免重复求和。
- **模运算技巧**：预计算逆元数组，减少重复计算，提高效率。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结合了递推、前缀和和模逆元计算，适合直接学习。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Leasier和WYXkk的题解思路，通过递推计算\(f(i)\)和\(g(i)\)，并使用预计算逆元优化。
* **完整核心代码**：
    ```cpp
    #include <stdio.h>
    typedef long long ll;
    const int mod = 998244353;
    ll inv[800007], f[400007], g[400007];

    inline void init(int n) {
        inv[0] = inv[1] = 1;
        for (int i = 2; i <= n; i++) {
            inv[i] = mod - (mod / i) * inv[mod % i] % mod;
        }
    }

    inline ll quick_pow(ll x, ll p) {
        ll ans = 1;
        while (p) {
            if (p & 1) ans = ans * x % mod;
            x = x * x % mod;
            p >>= 1;
        }
        return ans;
    }

    int main() {
        int n;
        ll pre = 0, sumf = 0, sumg = 0;
        scanf("%d", &n);
        init(n * 2);

        // 计算走私者的概率f[i]
        f[0] = 1;
        pre = 0;
        for (int i = 1; i <= n; i++) {
            pre = (pre + f[i - 1]) % mod;
            f[i] = (f[i - 1] * (i - 1) % mod + pre) % mod * inv[i * 2] % mod;
        }
        sumf = 0;
        for (int i = 0; i <= n; i++) sumf = (sumf + f[i]) % mod;
        sumf = quick_pow(sumf, mod - 2);
        for (int i = 0; i <= n; i++) f[i] = f[i] * sumf % mod;

        // 计算检察官的概率g[i]
        g[0] = 1;
        pre = 0;
        for (int i = 1; i <= n; i++) {
            pre = (pre + g[i - 1]) % mod;
            g[i] = (g[i - 1] * (i - 1) % mod + pre) % mod * 2 % mod * inv[i] % mod;
        }
        sumg = 0;
        for (int i = 0; i <= n; i++) sumg = (sumg + g[i]) % mod;
        sumg = quick_pow(sumg, mod - 2);
        for (int i = 0; i <= n; i++) g[i] = g[i] * sumg % mod;

        // 输出结果
        for (int i = 0; i <= n; i++) printf("%lld ", f[i]);
        printf("\n");
        for (int i = 0; i <= n; i++) printf("%lld ", g[i]);
        return 0;
    }
    ```
* **代码解读概要**：代码分为三部分：预计算逆元（`init`）、计算走私者概率（`f[i]`）、计算检察官概率（`g[i]`）。通过递推公式和前缀和维护，结合模逆元归一化概率，最终输出结果。

---
<code_intro_selected>
以下是优质题解的核心代码片段分析：
</code_intro_selected>

**题解一：作者Leasier**
* **亮点**：预计算逆元优化，递推式直接对应数学推导，代码简洁高效。
* **核心代码片段**：
    ```cpp
    f[i] = (f[i - 1] * (i - 1) % mod + pre) % mod * inv[i * 2] % mod;
    g[i] = (g[i - 1] * (i - 1) % mod + pre) % mod * 2 % mod * inv[i] % mod;
    ```
* **代码解读**：`f[i]`的递推式对应数学推导的\(f(i) = \frac{(i-1)f(i-1) + \sum_{j=0}^{i-1}f(j)}{2i}\)，其中`pre`是前缀和\(\sum_{j=0}^{i-1}f(j)\)。`inv[i*2]`是模逆元，处理除法。`g[i]`同理，系数调整为2（因检察官的递推式分母为\(i\)）。
* 💡 **学习笔记**：递推式中的系数（如2）直接来自数学推导，需严格对应公式。

**题解二：作者WYXkk**
* **亮点**：用直观的方程组形式推导递推关系，代码逻辑清晰。
* **核心代码片段**：
    ```cpp
    p[0]=2; F(i,1,n) p[i]=1;
    q[0]=1; q[1]=2; ll sum=0;
    F(i,2,n) {
        sum=(sum+q[i-2])%mod;
        q[i]=(q[i-1]*2+sum*2*ni(i))%mod;
    }
    ```
* **代码解读**：`p[i]`和`q[i]`分别表示走私者和检察官的概率比例。`sum`维护前缀和，`ni(i)`是模逆元。通过递推式逐步计算每个概率的比例，最后归一化。
* 💡 **学习笔记**：用比例表示概率可简化计算，最终归一化时再调整为实际概率。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解递推过程，我们设计一个8位像素风格的动画，模拟\(f(i)\)和\(g(i)\)的计算过程。
</visualization_intro>

  * **动画演示主题**：`像素递推小剧场`（FC红白机风格）
  * **核心演示内容**：展示\(f(i)\)和\(g(i)\)的递推过程，包括前缀和累加、逆元计算、概率归一化。
  * **设计思路简述**：8位像素风格（16色调色板）营造复古感，用不同颜色标记当前计算项（绿色）、前缀和（蓝色）、逆元（紫色）。关键步骤（如递推、归一化）播放“叮”的音效，完成时播放胜利音效，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：屏幕分为左右两部分，左半部分演示\(f(i)\)（走私者），右半部分演示\(g(i)\)（检察官）。顶部显示控制面板（开始/暂停、单步、调速滑块）。

    2.  **递推计算**：
        - 初始时，\(f[0]=1\)用红色像素块显示。
        - 单步执行时，计算\(f[1]\)：前缀和`pre`（蓝色像素条）累加\(f[0]\)，然后根据递推式计算\(f[1]\)（绿色像素块弹出），伴随“滴”的音效。
        - 重复此过程，直到计算完\(f[n]\)，所有像素块按顺序排列，颜色从红到绿渐变。

    3.  **归一化处理**：
        - 计算总和`sumf`（黄色像素条累加所有\(f[i]\)），然后用逆元计算`sumf`的倒数（紫色闪电动画）。
        - 每个\(f[i]\)乘以逆元（像素块颜色变亮），最终所有像素块高度之和为1（顶部显示“概率和=1”）。

    4.  **对比演示**：右半部分同步演示\(g(i)\)的计算，颜色用橙到蓝渐变，突出与\(f(i)\)的差异。

  * **旁白提示**：
      - “现在计算\(f[1]\)：前缀和是\(f[0]=1\)，代入公式得到\(f[1] = (0*1 + 1)/(2*1) = 0.5\)（模意义下）。”
      - “所有\(f[i]\)的和是3，所以每个\(f[i]\)需要除以3（模逆元计算），得到最终概率。”

<visualization_conclusion>
通过这样的动画，我们可以直观看到递推式如何逐步生成概率分布，以及模逆元在归一化中的作用。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握此题后，可尝试以下拓展练习，巩固博弈论和递推技巧：
</similar_problems_intro>

  * **通用思路/技巧迁移**：递推+前缀和+模逆元的组合不仅适用于博弈论，还可解决“动态规划中的概率问题”（如骰子期望）、“组合数学中的递推计数”（如卡特兰数）等。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1850** - `换教室`  
          * 🗣️ **推荐理由**：涉及动态规划和概率期望，需处理多状态转移，与本题的递推思想类似。
    2.  **洛谷 P4587** - `[FJOI2016]神秘数`  
          * 🗣️ **推荐理由**：需要通过前缀和和递推找到最小无法表示的数，锻炼前缀和的灵活运用。
    3.  **洛谷 P3703** - `[SDOI2017]树点涂色`  
          * 🗣️ **推荐理由**：涉及树链剖分和递推，适合提升复杂问题的分解能力。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时的经验，例如：
</insights_intro>

> **参考经验 (来自SmallBlack)**：“赛时推式子时，一开始没注意到模逆元的预计算，导致TLE。后来预计算逆元数组后，时间复杂度降到\(O(n)\)，顺利通过。”

**点评**：预计算逆元是处理模运算的常见优化技巧，尤其在\(n\)较大时（如本题\(n=4e5\)），能显著提升效率。这提醒我们，在涉及大量除法的模运算问题中，预计算逆元数组是必须的。

---

<conclusion>
本次关于“欺诈游戏”的C++解题分析就到这里。希望这份指南能帮助你理解博弈论中的纳什均衡，掌握递推和模运算的技巧。记住，多动手推导公式、调试代码，是提升算法能力的关键！下次挑战更难的题目吧，加油！💪
</conclusion>

---
处理用时：149.15秒
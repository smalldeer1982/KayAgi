# 题目信息

# [ICPC 2021 Nanjing R] Xingqiu's Joke

## 题目描述

有 $T$ 个盒子，每盒子上有一个锁，锁上有两个整数 $a$ 和 $b$。你可以对这个锁做若干次以下 3 种操作：

- $a$ 和 $b$ 分别减去 $1$
- $a$ 和 $b$ 分别增加 $1$
- $a$ 和 $b$ 分别除以它们共同的素数因子

如果 $a$ 或 $b$ 或两者都变为 $1$，盒子就会解锁。请你编写一个程序，计算每个盒子的锁打开的最少步骤数量。

## 样例 #1

### 输入

```
5
4 7
9 8
32 84
11 35
2 1
```

### 输出

```
2
7
5
4
0
```

# AI分析结果



---
# 💡 Kay的C++算法解析：Xingqiu's Joke 深入学习指南 💡

<introduction>
今天我们来一起分析“Xingqiu's Joke”这道C++编程题。这道题需要计算通过三种操作使锁上的两个数之一变为1的最少步骤，核心在于理解如何高效利用“除以共同素因子”这一操作。本指南将帮助大家梳理题目思路，掌握核心算法，并通过可视化演示直观理解过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：搜索算法（DFS+记忆化）与数论（质因子分解）的综合应用

🗣️ **初步分析**：
解决这道题的关键在于将问题转化为状态转移问题，利用“记忆化搜索”避免重复计算。简单来说，记忆化搜索就像“查字典”——我们先解决小问题（子状态），并把结果记录下来，遇到相同的小问题时直接查记录，不用重复计算。  

在本题中，我们定义状态为`(a, δ)`，其中`a`是较小的数，`δ`是两数的差值（`δ = |a - b|`）。每次操作有三种选择，但前两种操作（加减1）不会改变`δ`，第三种操作（除以共同素因子`p`）会将`δ`缩小为`δ/p`。因此，我们需要枚举`δ`的所有质因子，通过递归计算“先加减到`p`的倍数，再除以`p`”的最小步骤。  

- **题解思路对比**：所有优质题解均采用记忆化搜索，核心差异在于状态表示（如用`map`或`unordered_map`存储）和质因子分解的实现细节，但整体逻辑一致：枚举`δ`的质因子，递归计算子状态的最小步骤。  
- **核心算法流程**：从初始状态`(min(a,b), δ)`出发，若`a=1`则返回0；若`δ=1`则只能一直减，返回`a-1`。否则枚举`δ`的质因子`p`，计算“向下减到`p`倍数”和“向上加到`p`倍数”两种情况的步骤，取最小值并记忆化。  
- **可视化设计**：采用8位像素风格，用不同颜色的方块表示当前状态`(a, δ)`，质因子`p`作为“跳跃点”。动画中，每次选择`p`时，`a`方块会滑动到最近的`p`倍数位置（加减动画），然后缩小为`a/p`（除法动画），伴随“叮”的音效；最终状态`a=1`时播放胜利音效，用星星特效庆祝。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下题解因逻辑清晰、代码简洁且实践价值高，被选为优质题解（均≥4星）：
</eval_intro>

**题解一：作者CashCollectFactory**  
* **点评**：此题解对问题本质的分析非常透彻（如指出`δ`的质因子是关键），代码结构清晰，变量命名直观（如`v`存储质因子，`level`作为记忆化字典）。特别值得学习的是，通过数学归纳法证明了状态数的有限性，确保了算法效率。代码中`DFS`函数的递归终止条件和状态转移逻辑直接对应问题核心，边界处理严谨（如`c=1`时只能减）。

**题解二：作者gan_ge**  
* **点评**：此题解从动态规划视角重新解释问题，状态定义`dp_{a,δ}`明确，转移方程推导详细（考虑了直接减、向下减到倍数、向上加到倍数三种情况）。代码使用`map<pair<int,int>,int>`存储状态，简洁易懂，适合初学者理解记忆化搜索的实现。

**题解三：作者SDLTF_凌亭风**  
* **点评**：此题解代码极其简洁，通过`unordered_map`实现快速记忆化，质因子分解逻辑高效（遍历到`sqrt(delta)`即可）。虽然解释较简略，但代码本身清晰体现了“枚举质因子→递归子状态”的核心逻辑，适合作为竞赛快速实现的参考。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，提炼解决策略如下：
</difficulty_intro>

1.  **关键点1：如何准确定义状态？**  
    * **分析**：状态定义需要覆盖所有可能的子问题，且能通过质因子分解减少状态数。优质题解统一选择`(a, δ)`作为状态，其中`a`是较小数，`δ`是两数差。这样，`δ`的质因子分解直接决定了下一步可能的操作，状态数由`δ`的质因子数量决定，保证了效率。  
    * 💡 **学习笔记**：状态定义的关键是抓住“不变量”（如本题的`δ`），并利用其性质（如质因子分解）减少计算量。

2.  **关键点2：如何高效枚举质因子？**  
    * **分析**：`δ`的质因子是操作三的基础。优质题解通过遍历到`sqrt(δ)`进行质因子分解，每次找到因子后除尽，最后处理剩余的大于1的数（可能是大质数）。这种方法时间复杂度为`O(sqrt(δ))`，足够高效。  
    * 💡 **学习笔记**：质因子分解时，遍历到`sqrt(n)`即可，剩余的大于1的数必为质数（如`δ=12`分解为`2,3`，`δ=14`分解为`2,7`）。

3.  **关键点3：如何设计状态转移？**  
    * **分析**：状态转移需考虑两种情况：向下减到`p`的倍数（步骤`a%p`）或向上加到`p`的倍数（步骤`p - a%p`），然后递归计算子状态`(a/p, δ/p)`的步骤，最后加1（除法操作）。优质题解通过取两种情况的最小值，确保找到最优路径。  
    * 💡 **学习笔记**：状态转移时，需覆盖所有可能的操作路径，取最小值保证“最少步骤”的目标。

### ✨ 解题技巧总结
- **问题抽象**：将原问题抽象为状态`(a, δ)`，抓住`δ`的质因子这一关键不变量。  
- **记忆化优化**：用`map`或`unordered_map`存储已计算的状态，避免重复递归。  
- **质因子分解**：遍历到`sqrt(δ)`高效分解质因子，处理剩余大质数。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合多个优质题解的通用核心实现，代码简洁清晰，体现了本题的核心逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了CashCollectFactory、gan_ge等题解的思路，采用记忆化搜索和质因子分解，是最典型的实现。  
* **完整核心代码**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

vector<int> factors;
map<pair<ll, ll>, int> memo;

int dfs(ll a, ll delta) {
    if (a == 1) return 0;          // 已有一个数为1，无需操作
    if (delta == 1) return a - 1;    // 差值为1，只能一直减
    if (memo.count({a, delta})) return memo[{a, delta}];  // 查记忆化

    int res = a - 1;  // 直接减到1的步骤
    for (int p : factors) {
        if (delta % p != 0) continue;  // 只处理delta的质因子
        ll rem = a % p;
        // 情况1：向下减到p的倍数
        int steps1 = rem + 1 + dfs(a / p, delta / p);
        // 情况2：向上加到p的倍数
        int steps2 = (p - rem) + 1 + dfs(a / p + 1, delta / p);
        res = min({res, steps1, steps2});
    }
    return memo[{a, delta}] = res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        ll a, b;
        cin >> a >> b;
        if (a > b) swap(a, b);  // 保证a是较小数
        ll delta = b - a;
        factors.clear();
        memo.clear();

        // 分解delta的质因子
        for (int i = 2; i * i <= delta; ++i) {
            if (delta % i == 0) {
                factors.push_back(i);
                while (delta % i == 0) delta /= i;
            }
        }
        if (delta > 1) factors.push_back(delta);

        cout << dfs(a, b - a) << '\n';
    }
    return 0;
}
```
* **代码解读概要**：  
  代码首先处理输入，确保`a`是较小数，计算差值`delta`。然后分解`delta`的质因子，存储在`factors`中。核心函数`dfs`通过记忆化搜索递归计算最少步骤：若`a=1`返回0，若`delta=1`返回`a-1`（只能减），否则枚举`delta`的质因子，计算两种加减情况的步骤，取最小值并记忆。

---

<code_intro_selected>
接下来，剖析优质题解的核心代码片段，理解其亮点和关键逻辑。
</code_intro_selected>

**题解一：作者CashCollectFactory**  
* **亮点**：代码简洁，利用`unordered_map`快速查记忆化，质因子分解逻辑高效。  
* **核心代码片段**：  
```cpp
int DFS(int b, int c) {
    if(b==1)return 0;
    if(c==1)return b-1;
    if(level[gethash(b,c)])return level[gethash(b,c)];
    int mn=b-1;
    for(auto i:v)
        if(c%i==0)
            mn=min({mn,ans+1+DFS(b/i,c/i),i-ans+1+DFS(b/i+1,c/i)});
    return level[gethash(b,c)]=mn;
}
```
* **代码解读**：  
  `DFS`函数中，`b`是较小数，`c`是差值。`level`是记忆化字典，`gethash`将状态编码为唯一键。递归终止条件明确：`b=1`时返回0，`c=1`时只能减。遍历质因子`v`，计算两种情况的步骤（`ans`是`b%i`），取最小值并记忆。  
* 💡 **学习笔记**：用哈希函数将状态编码为整数，比`pair`更高效，适合竞赛场景。

**题解二：作者gan_ge**  
* **亮点**：用`map<pair<int,int>,int>`存储状态，代码可读性高，适合初学者。  
* **核心代码片段**：  
```cpp
int solve(int a,int d){
    if(a==1) return 0;
    if(d==1) return a-1;
    if(dp[{a,d}]) return dp[{a,d}];
    int res=a-1;
    for(auto i:vec)
        if(d%i==0)
            res=min(res,min(a%i+1+solve(a/i,d/i),i-a%i+1+solve(a/i+1,d/i)));
    return dp[{a,d}]=res;
}
```
* **代码解读**：  
  `solve`函数中，`a`是较小数，`d`是差值，`dp`是记忆化字典。递归终止条件与之前一致。遍历质因子`vec`，计算两种情况的步骤（`a%i`是向下减的步骤，`i-a%i`是向上加的步骤），取最小值并记忆。  
* 💡 **学习笔记**：`map`的键是`pair`，直观易理解，适合需要清晰状态表示的场景。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解记忆化搜索和质因子分解的过程，我们设计一个“像素探险”主题的8位风格动画，模拟`a`和`δ`的状态转移。
</visualization_intro>

  * **动画演示主题**：像素小探险家解锁盒子  
  * **核心演示内容**：小探险家从初始状态`(a, δ)`出发，通过加减1（左右移动）或除以质因子`p`（跳跃到缩小的格子），最终到达`a=1`的终点。  

  * **设计思路简述**：8位像素风格（如FC游戏画面）营造轻松氛围，用不同颜色区分状态（蓝色`a`，黄色`δ`）。关键操作（加减、除法）通过像素滑动和缩放动画展示，音效强化操作记忆（加减“滴答”，除法“叮”）。  

  * **动画帧步骤与交互关键点**：  
    1. **场景初始化**：屏幕左侧显示像素网格，每个格子标有`(a, δ)`；右侧是控制面板（开始/暂停、单步、调速滑块）。背景音乐为8位风格的轻快旋律。  
    2. **初始状态展示**：小探险家站在初始格子`(a, δ)`，头顶显示当前数值。  
    3. **质因子分解动画**：`δ`的质因子`p`以金色小方块从`δ`格子中“弹出”，围绕`δ`旋转。  
    4. **加减操作演示**：选择质因子`p`后，小探险家向左滑动`a%p`步（向下减）或向右滑动`p - a%p`步（向上加），伴随“滴答”音效，格子数值更新为`(a±steps, δ)`。  
    5. **除法操作演示**：滑动到`p`的倍数后，小探险家跳跃到缩小的格子`(a/p, δ/p)`，原格子缩小消失，伴随“叮”音效，新格子放大出现。  
    6. **递归过程展示**：子状态格子以半透明形式出现在主格子下方，已计算的状态用绿色标记（记忆化），未计算的用灰色。  
    7. **终点达成**：到达`a=1`的格子时，播放胜利音效（上扬音调），小探险家举起旗子，背景出现星星特效。  

  * **旁白提示**：  
    - “看！小探险家现在在`(a, δ)`，他需要找到最少步骤到`a=1`~”  
    - “这个金色方块是`δ`的质因子`p`，选择它可以跳跃到更小的格子哦！”  
    - “向左滑动`a%p`步，或者向右滑动`p - a%p`步，哪种更优呢？”  

<visualization_conclusion>
通过这个像素动画，我们能直观看到状态如何通过加减和除法操作逐步缩小，记忆化如何避免重复计算，从而理解“最少步骤”的求解过程。
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是“质因子分解+记忆化搜索”，这种思路可迁移到许多需要状态转移的问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - **质因子分解**：适用于需要利用数的因子性质的问题（如最大公约数、最小公倍数相关问题）。  
    - **记忆化搜索**：适用于状态数有限且子问题重复的问题（如动态规划、路径搜索问题）。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1025 数的划分**  
        * 🗣️ **推荐理由**：需要枚举因子并递归计算，锻炼状态分解和记忆化搜索能力。  
    2.  **洛谷 P1434 [SHOI2002] 滑雪**  
        * 🗣️ **推荐理由**：经典记忆化搜索问题，通过记录每个点的最长滑雪路径，理解状态转移的核心思想。  
    3.  **洛谷 P2371 [国家集训队] 墨墨的等式**  
        * 🗣️ **推荐理由**：涉及数论与最短路，需利用质因子分解和同余性质，拓展本题思路。  

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了解题时的思考，这些经验对我们很有启发：
</insights_intro>

> **参考经验 (来自CashCollectFactory)**：“一开始没意识到`δ`的质因子是关键，走了很多弯路。后来发现，所有共同素因子一定是`δ`的因子，这才明确了状态转移的方向。”  
> **点评**：这位作者的经验提醒我们，遇到涉及“共同因子”的问题时，应优先分析数的差值（或和）的因子，这往往是解题的突破口。例如本题中，`δ`的质因子直接决定了可能的除法操作，抓住这一点能大幅简化问题。

---

<conclusion>
本次关于“Xingqiu's Joke”的分析就到这里。通过理解状态定义、质因子分解和记忆化搜索的核心逻辑，相信大家已掌握解决此类问题的关键。记住，多动手写代码、画状态转移图，能更快提升算法能力！下次见~ 💪
</conclusion>

---
处理用时：170.01秒
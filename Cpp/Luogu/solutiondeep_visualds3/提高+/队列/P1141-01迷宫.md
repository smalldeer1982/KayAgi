# 题目信息

# 01迷宫

## 题目描述

有一个仅由数字 $0$ 与 $1$ 组成的 $n \times n$ 格迷宫。若你位于一格 $0$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $1$ 上，同样若你位于一格 $1$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $0$ 上。

你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。

## 说明/提示

对于样例，所有格子互相可达。

- 对于 $20\%$ 的数据，$n \leq 10$；
- 对于 $40\%$ 的数据，$n \leq 50$；
- 对于 $50\%$ 的数据，$m \leq 5$；
- 对于 $60\%$ 的数据，$n,m \leq 100$；
- 对于 $100\%$ 的数据，$1\le n \leq 1000$，$1\le m \leq 100000$。

## 样例 #1

### 输入

```
2 2
01
10
1 1
2 2
```

### 输出

```
4
4
```

# AI分析结果

# 01迷宫题解分析与优化总结


### **一、题目核心要求**
给定一个\(n \times n\)的01迷宫，每次可以从0走到相邻的1，或从1走到相邻的0。对于每个询问点，求其能到达的格子数（包括自身）。


### **二、常见解法与优化思路**
题解中最常见的方法是**连通块预处理**，即通过BFS/DFS遍历所有未被访问的点，计算每个连通块的大小，并标记每个点所属的连通块。查询时直接返回对应连通块的大小。这种方法的时间复杂度为\(O(n^2 + m)\)，完全满足题目数据限制（\(n \leq 1000\), \(m \leq 10^5\)）。


#### **1. 核心思路：连通块预处理**
- **连通块性质**：同一个连通块中的所有点能到达的格子数相同（因为0和1交替可达，连通块内任意两点互相可达）。
- **预处理步骤**：
  - 遍历每个未被访问的点，用BFS/DFS遍历其所在连通块，记录所有点，并计算连通块大小。
  - 用`flag`数组标记每个点所属的连通块编号，用`ans`数组存储每个连通块的大小。
- **查询步骤**：对于每个询问点，直接返回`ans[flag[x][y]]`。


#### **2. 优化点分析**
- **避免重复计算**：预处理所有连通块，每个连通块只计算一次，查询时直接取结果，避免每次查询都进行BFS/DFS（如“钟情暴力”题解中的优化）。
- **高效输入输出**：使用`scanf`/`printf`代替`cin`/`cout`，或自定义快速读入函数（如“minamikotori”题解中的`scan`函数），提升输入效率。
- **边界处理**：用特殊值（如2）填充迷宫边界，避免越界判断（如“Akashicw”题解中的做法）。
- **数据结构优化**：用数组代替队列（如“Akashicw”题解中的`q`数组），减少队列操作的开销。


### **三、典型题解对比**
| 题解作者       | 方法         | 优化点                     | 时间复杂度 | 优缺点                     |
|----------------|--------------|----------------------------|------------|----------------------------|
| 1124828077ccj  | DFS+记忆化   | 标记连通块，避免重复计算   | \(O(n^2 + m)\) | 易爆栈（递归深度大）       |
| 钟情暴力       | BFS+预处理   | 预处理连通块，用`flag`标记  | \(O(n^2 + m)\) | 高效，适合大数据           |
| Akashicw       | BFS+数组队列 | 用数组代替队列，边界处理   | \(O(n^2 + m)\) | 效率高，代码简洁           |
| 陈新月         | 并查集       | 二维坐标哈希为一维，维护连通块 | \(O(n^2 \alpha(n) + m)\) | 实现复杂，但效率高         |


### **四、最优解法推荐**
**推荐方法**：BFS预处理连通块+`flag`标记+`ans`数组存储大小。  
**步骤**：
1. **输入处理**：用`scanf`输入\(n\)、\(m\)和迷宫数组（将字符转换为数字）。
2. **预处理连通块**：
   - 初始化`flag`数组（标记连通块编号，初始为0）和`ans`数组（存储连通块大小）。
   - 遍历每个点，若`flag[x][y]`为0，进行BFS：
     - 用队列存储当前连通块的点，计算大小。
     - 标记所有点的`flag`为当前连通块编号，`ans[编号] = 大小`。
3. **处理查询**：对于每个询问点，输出`ans[flag[x][y]]`。


### **五、代码示例（优化后）**
```cpp
#include <cstdio>
#include <queue>
#include <cstring>
using namespace std;

const int MAXN = 1010;
int n, m;
int maze[MAXN][MAXN];
int flag[MAXN][MAXN]; // 标记连通块编号
int ans[1000001];     // 存储每个连通块的大小
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

struct Node {
    int x, y;
    Node(int x_, int y_) : x(x_), y(y_) {}
};

void bfs(int sx, int sy, int idx) {
    queue<Node> q;
    q.push(Node(sx, sy));
    flag[sx][sy] = idx;
    int cnt = 1;
    while (!q.empty()) {
        Node cur = q.front();
        q.pop();
        for (int i = 0; i < 4; ++i) {
            int nx = cur.x + dx[i];
            int ny = cur.y + dy[i];
            if (nx >= 1 && nx <= n && ny >= 1 && ny <= n && !flag[nx][ny] && maze[cur.x][cur.y] != maze[nx][ny]) {
                flag[nx][ny] = idx;
                q.push(Node(nx, ny));
                cnt++;
            }
        }
    }
    ans[idx] = cnt;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) {
        char s[MAXN];
        scanf("%s", s);
        for (int j = 1; j <= n; ++j) {
            maze[i][j] = s[j-1] - '0';
        }
    }
    int idx = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (!flag[i][j]) {
                bfs(i, j, idx);
                idx++;
            }
        }
    }
    while (m--) {
        int x, y;
        scanf("%d%d", &x, &y);
        printf("%d\n", ans[flag[x][y]]);
    }
    return 0;
}
```


### **六、总结**
- **核心优化**：预处理连通块，避免重复计算。
- **高效方法**：BFS预处理+`flag`标记+`ans`数组存储大小。
- **注意事项**：输入输出优化、边界处理、数据结构选择（如数组代替队列）。

这种方法能高效处理题目中的大数据，确保在时间限制内完成所有查询。

---
处理用时：110.98秒
# 题目信息

# 显示图像

## 题目描述

古老的显示屏是由 $N \times M$ 个像素（Pixel）点组成的。一个像素点的位置是根据所在行数和列数决定的。例如 $P(2,1)$ 表示第 $2$ 行第 $1$ 列的像素点。那时候，屏幕只能显示黑与白两种颜色，人们用二进制 $0$ 和 $1$ 来表示。$0$ 表示黑色，$1$ 表示白色。当计算机发出一个指令：$P(x,y)=1$，则屏幕上的第 $x$ 行第 $y$ 列的阴极射线管就开始工作，使该像素点显示白色，若 $P(x,y)=0$，则对应位置的阴极射线管不工作，像素点保持黑色。在某一单位时刻，计算机以 $N \times M$ 二维 $01$ 矩阵的方式发出显示整个屏幕图像的命令。

例如，屏幕是由 $3 \times 4$ 的像素点组成，在某单位时刻，计算机发出如下命令：

$$\begin{pmatrix}
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 1 \\
0 & 1 & 1 & 0 \\
\end{pmatrix}$$

对应屏幕显示应为：

![](https://cdn.luogu.com.cn/upload/image_hosting/cwg2di9s.png)

假设放大后，一个格子表示一个像素点。

由于未知的原因，显示黑色的像素点总是受显示白色的像素点的影响——可能是阴极射线管工作的作用。并且，距离越近，影响越大。这里的距离定义如下：

设有像素点 $P_1(x_1,y_1)$ 和像素点 $P_2(x_2,y_2)$，则它们之间的距离 $D(P_1,P_2)=|x_1-x_2|+|y_1-y_2|$。

在某一时刻，计算机发出显示命令后，科学家们期望知道，每个像素点和其最近的显示白色的像素点之间的最短距离是多少——科学家们保证屏幕上至少有一个显示白色的像素点。

上面的例子中，像素 $P(1,1)$ 与最近的白色像素点之间的距离为 $3$，而像素 $P(3,2)$ 本身显示白色，所以最短距离为 $0$。


## 说明/提示

- 对于 $30\%$ 的数据：$N\times M \le 10000$；
- 对于 $100\%$ 的数据：$N\times M \le 182^2$。

## 样例 #1

### 输入

```
3 4
0001
0011
0110
```

### 输出

```
3 2 1 0
2 1 0 0
1 0 0 1
```

# AI分析结果


### 💡 Kay的C++算法解析：显示图像 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：**多源BFS/动态规划**  
🗣️ **初步分析**：
> 这道题要求计算每个像素点到最近白色像素点的曼哈顿距离，就像在像素迷宫中为每个黑色格子导航到最近的出口。核心思想是**并行扩散**——想象多个白色像素点同时向外"辐射"光波，每次扩散一步，当光波首次到达黑色像素时即为最短距离。
> - **多源BFS**：从所有白点同时开始BFS，首次覆盖黑点时记录距离（自然最小）。
> - **动态规划**：通过四次网格扫描（左上→右下、右上→左下等）逐步传递最近白点距离。
> - **可视化设计**：动画将展示像素网格中"光波"扩散过程，白色作为光源（黄色高亮），扩散边界（绿色脉冲），新覆盖点显示距离值，辅以方向箭头和"叮"声效。

---

#### 2. 精选优质题解参考
**题解一 (来源：Hydra_)**
* **点评**：思路清晰运用多源BFS，将白点入队作为起点，黑点初始化为极大值。代码规范使用方向数组`dx/dy`，队列操作简洁。亮点在于**距离传递逻辑**（`d[新位置]=d[当前位置]+1`）直观体现BFS层进特性，边界处理严谨，可直接用于竞赛。

**题解二 (来源：pantw)**
* **点评**：创新性使用四向动态规划，分四次扫描更新距离：左上→右下、右上→左下等。亮点在于**空间优化**（无需队列）和**时间复杂度O(nm)**，代码中`f[0~3][i][j]`存储四个方向最小距离，最后取最小值，体现分治思想。

**题解三 (来源：Atmizz)**
* **点评**：采用STL队列实现多源BFS，结构清晰易读。亮点在于**状态标记**（`v[i][j]`避免重复访问）和**模块化设计**，核心循环中距离更新逻辑（`net.d=d+1`）简洁有力，适合初学者理解BFS框架。

---

#### 3. 核心难点辨析与解题策略
1. **难点：如何避免重复计算距离？**  
   *分析*：多源BFS中需用标记数组确保每个点只处理一次（如`v[i][j]`），DP中通过分方向扫描避免状态干扰。  
   💡 **学习笔记**：BFS的队列性质天然保证首次访问即最短距离。

2. **难点：如何高效初始化距离？**  
   *分析*：白点距离为0，黑点初始化为极大值（如`1e9`）。BFS在入队时初始化，DP在扫描前初始化。  
   💡 **学习笔记**：合理初始化是保证算法正确性的前提。

3. **难点：方向处理与边界判断**  
   *分析*：使用方向数组`dx/dy={0,0,1,-1}`和`{1,-1,0,0}`遍历四邻域，判断坐标是否在`[1,n]×[1,m]`内。  
   💡 **学习笔记**：方向数组封装移动逻辑，边界检查防止越界。

### ✨ 解题技巧总结
- **技巧1：逆向思维**  
  从白点扩散而非从黑点搜索，大幅降低复杂度（O(n²)→O(n)）。
- **技巧2：状态复用**  
  DP中四向扫描复用中间结果，避免额外存储。
- **技巧3：原子化操作**  
  BFS中"当前位置距离+1=新位置距离"体现最短路径最优子结构。

---

#### 4. C++核心代码实现赏析
**通用核心实现（多源BFS）**
```cpp
#include <iostream>
#include <queue>
using namespace std;
const int N=200;
int dx[]={0,0,1,-1}, dy[]={1,-1,0,0}; // 方向数组
int main(){
    int n,m,d[N][N]; 
    bool v[N][N]={0}; // 访问标记
    queue<pair<int,int>> q;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++){
        char c; cin>>c;
        if(c=='1') q.push({i,j}), v[i][j]=1, d[i][j]=0; // 白点入队
        else d[i][j]=1e9; // 黑点初始化为极大值
    }
    while(!q.empty()){
        auto [x,y]=q.front(); q.pop();
        for(int i=0;i<4;i++){
            int nx=x+dx[i], ny=y+dy[i];
            if(nx<1||ny<1||nx>n||ny>m||v[nx][ny]) continue;
            d[nx][ny]=d[x][y]+1; // 距离更新
            v[nx][ny]=1; // 标记已访问
            q.push({nx,ny});
        }
    }
    // 输出结果...
}
```
**代码解读概要**：  
1. 初始化所有白点距离为0并入队  
2. BFS队列循环中更新四邻域点的距离  
3. 未访问点距离=当前点距离+1  

**题解一赏析（Hydra_）**
```cpp
// 核心片段：BFS距离更新
for(int i=1;i<=4;i++){
    int xx=x+dx[i], yy=y+dy[i];
    if(!v[xx][yy]) {
        d[xx][yy]=d[x][y]+1; 
        v[xx][yy]=1;
        q.push({xx,yy});
    }
}
```
**学习笔记**：方向数组使代码简洁，距离更新体现BFS层序特性。

**题解二赏析（pantw）**
```cpp
// 核心片段：四向DP扫描
for(int i=1;i<=n;i++)
for(int j=1;j<=m;j++)
    f[0][i][j]=min(f[0][i-1][j], f[0][i][j-1])+1;
```
**学习笔记**：分方向传递最小距离，四次扫描覆盖所有路径。

---

#### 5. 算法可视化：像素动画演示
![](https://cdn.luogu.com.cn/upload/image_hosting/cwg2di9s.png)  
* **主题**："像素光波扩散"（复古8-bit风格）  
* **关键帧设计**：  
  1. **初始化**：白点为黄色光源（闪烁），黑点为深灰，网格线浅灰。  
  2. **扩散过程**：  
     - 队列弹出点显示"脉冲绿圈"  
     - 新覆盖点显示红色距离值+"叮"声效  
     - 方向箭头指示移动路径  
  3. **交互控制**：  
     - 步进模式：按空格单步执行  
     - 速度滑块：调整扩散速度  
     - 暂停/重置按钮  
* **动态演示**：  
  ```plain
  初始状态:   第1步:      第2步:
  [0][0][0][1]  [0][0][0]🌟   [3][0][0]🌟 
  [0][0][1][1] → [0][0]🌟🌟 → [2][1]🌟🌟 
  [0][1][1][0]   [0]🌟🌟[0]    [1]🌟🌟[0] 
  ```

---

#### 6. 拓展练习与相似问题
1. **洛谷 P1162** 填涂颜色  
   *推荐理由*：同网格BFS应用，练习队列与边界处理。
2. **洛谷 P1141** 01迷宫  
   *推荐理由*：连通块BFS，巩固多源扩散思想。
3. **洛谷 P1219** 八皇后  
   *推荐理由*：回溯算法对比BFS，理解不同搜索策略。

---

#### 7. 学习心得分享
> **经验**（封禁用户）："输入格式巨坑！数字间无空格需用字符串处理。"  
> **Kay点评**：输入细节常被忽略，`scanf("%1d")`或字符串逐字符转换是可靠方案。调试时先验证输入能节省大量时间！

---

### 结语
通过多源BFS或动态规划，我们高效解决了像素距离问题。关键在于理解**并行扩散思想**和**状态传递逻辑**。记得多动手模拟过程，巩固队列与DP的应用！下次探索见！🚀

---
处理用时：108.30秒
# 题目信息

# [KOI 2022 Round 2] 食事计划

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

在 KOI 国家，铁柱所在的地方有 $N$ 个餐厅。每个餐厅只售卖一种食物，食物的类型通过整数 $A_i$ 来表示，$i$（$1 \leq i \leq N$）。

铁柱计划访问所有的餐厅，并为自己制定一个食事计划。铁柱的食事计划可以用从 $1$ 到 $N$ 的整数排列 $P$ 来表示。举例来说，如果 $P = [2, 4, 3, 1]$，这意味着铁柱将依次访问餐厅 2、4、3 和 1。

由于铁柱不希望连续吃相同类型的食物，所以在他的食事计划中，连续的两个餐厅必须提供不同类型的食物。也就是说，对于 $i = 1, 2, \dots, N-1$，$A_{P_i} \neq A_{P_{i+1}}$ 必须成立，而符合这一条件的食事计划被称为合法食事计划。

例如，假设 $N = 9$，且提供的食物类型是 $A = [1, 1, 1, 2, 2, 3, 3, 4, 3]$，则如果铁柱的食事计划是 $P = [3, 4, 1, 5, 6, 2, 7, 8, 9]$，那么计划中的每两个相邻餐厅的食物类型都不同，符合条件。

若铁柱的食事计划是 $P = [1, 4, 2, 5, 6, 3, 7, 8, 9]$，这也是一个合法的食事计划，并且是按字典顺序最前的合法计划。

然而，若食物类型是 $A = [1, 1, 1]$，无论怎样安排食事计划，都无法满足“连续两餐不同类型”的要求。

当给定 $N$ 个餐厅的食物类型时，如果无法制定合法的食事计划，则输出 `-1`；否则，输出字典序最前的合法食事计划。

## 说明/提示

**约束条件**

- $1 \leq N \leq 300\,000$
- $1 \leq A_i \leq N$

**子任务**

1. （5 分）$N \leq 8$
2. （12 分）$N \leq 20$
3. （32 分）$N \leq 5\,000$
4. （51 分）无额外约束条件

## 样例 #1

### 输入

```
9
1 1 1 2 2 3 3 4 3```

### 输出

```
1 4 2 5 6 3 7 8 9```

## 样例 #2

### 输入

```
3
1 1 1```

### 输出

```
-1```

# AI分析结果

---
# 💡 Kay的C++算法解析：食事计划 深入学习指南 💡

<introduction>
今天我们来一起分析KOI 2022 Round 2的“食事计划”问题。这道题需要我们为铁柱制定**字典序最小的合法餐厅访问计划**——相邻餐厅的食物类型不能相同。如果无法制定合法计划，就输出-1。通过这道题，我们能学会如何用**贪心策略**结合**高效数据结构**解决“有序选择+合法性约束”的问题，还能理解经典的“众数次数”判定结论哦！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心策略 + 编程技巧应用（高效维护状态）

🗣️ **初步分析**：
解决这道题的关键，就像**“搭积木”**——每次选一块“当前最适合的积木”（字典序最小的餐厅），但必须保证剩下的积木还能搭成完整的结构（后续能形成合法计划）。这里的“积木结构”由一个**经典结论**保障：  
> 一个序列能排成“相邻元素不同”的合法序列，当且仅当**所有元素的出现次数都不超过总长度的一半（向上取整）**。比如总长度9，最多的元素出现次数不能超过5（(9+1)/2）；总长度3，最多不能超过2。

在本题中，我们需要**逐位贪心选择**：
1. **优先保证合法性**：如果当前剩余元素中，众数（出现次数最多的食物类型）的次数超过剩余长度的一半，必须先选这个众数（否则后续无法合法排列）；
2. **其次保证字典序**：如果可以自由选择，就选当前剩余餐厅中**位置最小**的（字典序最小），但要避开上一个选的食物类型。

### 核心算法流程与可视化设计思路
- **变量更新**：每次选一个餐厅后，需要减少该食物类型的剩余次数，并更新其下一个可用位置（比如某食物类型的餐厅是1、2、3，选了1后，下一个可用位置是2）；
- **高亮关键步骤**：可视化时，用**闪烁的像素箭头**标记当前要选的餐厅，用**颜色变化**（比如红色变绿色）表示该餐厅被选中；用**进度条**展示剩余长度，用**数字闪烁**提示当前众数的次数；
- **复古游戏化设计**：采用8位像素风格（类似FC游戏），餐厅是彩色小方块，控制面板有“单步选餐”“自动计划”按钮，选餐厅时播放“叮”的音效，众数检查时播放“嗡”的提示音，完成计划时播放“胜利”的上扬音调。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法效率等方面筛选了2份优质题解，帮大家快速理解核心逻辑~
</eval_intro>

**题解一：来源（作者：Mirasycle）**
* **点评**：这份题解的思路**非常直白**，完美贴合“贪心+合法性检查”的核心逻辑。它用两个`set`巧妙维护了关键状态：
  - `s1`按“出现次数从多到少+位置从小到大”排序，快速获取当前剩余的众数；
  - `s2`按“餐厅位置从小到大”排序，快速获取字典序最小的可用餐厅。
  代码中的`op`函数封装了选餐的核心操作，逻辑清晰易读。时间复杂度是`O(nlogn)`，对于3e5的数据完全够用，是非常高效的实现。

**题解二：来源（作者：Eason2009）**
* **点评**：这份题解用“线段树套set”的结构维护餐厅位置，同样能实现字典序最小的查询。虽然时间复杂度略高（`O(nlog²n)`），但思路也是正确的——线段树的每个叶子节点对应一种食物类型，里面的`set`存该类型的可用餐厅位置。这种结构适合更复杂的“范围查询”场景，也能帮助大家理解“多层数据结构”的应用。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家容易卡在“如何平衡合法性与字典序”“如何高效维护状态”这几个点上。下面我帮大家拆解核心难点，并给出解决策略~
</difficulty_intro>

1.  **难点1：如何快速判断“当前必须选众数”？**
    * **分析**：如果当前剩余`k`个餐厅，众数的出现次数超过`(k+1)/2`（向上取整），必须选这个众数——否则剩下的`k-1`个餐厅中，众数次数还是超过`k/2`，永远无法合法排列。比如剩余5个餐厅，众数出现3次（>5/2=2.5），必须选它！
    * 💡 **学习笔记**：合法性检查的关键是“剩余众数次数 ≤ 剩余长度的一半”。

2.  **难点2：如何快速找到“字典序最小的可用餐厅”？**
    * **分析**：字典序最小意味着“位置最小的餐厅”。我们可以用`set`存“（餐厅位置，食物类型）”对，这样`set`的第一个元素就是位置最小的。需要注意避开上一个选的食物类型哦~
    * 💡 **学习笔记**：用`set`的“自动排序”特性，可以快速获取最小位置。

3.  **难点3：如何高效维护“某食物类型的下一个可用餐厅”？**
    * **分析**：比如某食物类型有餐厅1、2、3，选了1后，下一个可用的是2。我们可以用`cur[x]`存食物类型`x`的当前可用位置，选完后更新`cur[x]`为下一个位置（比如`nxt[1] = 2`）。
    * 💡 **学习笔记**：用“链表”结构（`lst`前驱、`nxt`后继）维护每个食物类型的餐厅顺序，选餐时快速跳转。

### ✨ 解题技巧总结
- **结论优先**：先判断无解情况（众数次数超过总长度的一半），避免无用功；
- **贪心策略**：每次选“当前最安全+字典序最小”的选项；
- **数据结构赋能**：用`set`维护有序状态，用链表维护食物类型的餐厅顺序，让操作更高效。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解思路的通用核心实现**，帮大家建立整体框架~
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Mirasycle题解的核心思路，用`set`维护众数和最小位置，逻辑清晰且高效。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <set>
  using namespace std;

  const int MAXN = 3e5 + 10;
  int a[MAXN], cnt[MAXN], cur[MAXN], lst[MAXN], nxt[MAXN];
  int n, col; // col是上一个选的食物类型

  struct Node {
      int count, pos, type;
      bool operator<(const Node& rhs) const {
          return count > rhs.count || (count == rhs.count && pos < rhs.pos);
      }
  };

  set<Node> s_count; // 按count从大到小、pos从小到大排序
  set<pair<int, int>> s_pos; // 按pos从小到大排序（pos, type）

  void select(int type) {
      cout << cur[type] << " ";
      col = type;
      // 从s_count中删除旧状态
      s_count.erase((Node){cnt[type], cur[type], type});
      // 从s_pos中删除旧位置
      s_pos.erase({cur[type], type});
      // 更新count和cur[type]
      cnt[type]--;
      if (cnt[type] == 0) return;
      cur[type] = nxt[cur[type]]; // 下一个可用位置
      // 插入新状态
      s_count.insert((Node){cnt[type], cur[type], type});
      s_pos.insert({cur[type], type});
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(0); cout.tie(0);
      cin >> n;
      for (int i = 1; i <= n; ++i) {
          cin >> a[i];
          cnt[a[i]]++;
          if (lst[a[i]]) nxt[lst[a[i]]] = i;
          else cur[a[i]] = i;
          lst[a[i]] = i;
      }
      // 初始化set
      for (int i = 1; i <= n; ++i) {
          if (cnt[i]) s_count.insert((Node){cnt[i], cur[i], i});
          if (cur[i]) s_pos.insert({cur[i], i});
      }
      // 判断无解
      Node max_node = *s_count.begin();
      if (max_node.count > (n + 1) / 2) {
          cout << "-1";
          return 0;
      }
      // 逐位选择
      for (int i = 1; i <= n; ++i) {
          Node current_max = *s_count.begin();
          int remaining = n - i + 1;
          if (current_max.count > (remaining + 1) / 2) {
              // 必须选众数
              select(current_max.type);
          } else {
              // 选位置最小的，避开col
              auto it = s_pos.begin();
              if (it->second == col) ++it;
              select(it->second);
          }
      }
      return 0;
  }
  ```
* **代码解读概要**：
  > 代码分为三部分：  
  1. **输入处理**：读取餐厅的食物类型，用`lst`和`nxt`维护每个食物类型的餐厅顺序（比如食物类型1的餐厅是1、2、3，`lst[1]=3`，`nxt[1]=2`，`nxt[2]=3`）；  
  2. **初始化set**：`s_count`存每个食物类型的剩余次数和当前可用位置，`s_pos`存每个食物类型的当前可用位置和类型；  
  3. **逐位选择**：先检查是否必须选众数，否则选位置最小的餐厅，调用`select`函数更新状态并输出。

---

<code_intro_selected>
接下来剖析优质题解的核心片段，看看它们的“巧妙之处”~
</code_intro_selected>

**题解一：来源（Mirasycle）**
* **亮点**：用`set`同时维护“众数”和“最小位置”，逻辑紧凑，效率高。
* **核心代码片段**：
  ```cpp
  void op(int x) {
      cout << cur[x] << " "; col = x;
      s1.erase((node){cnt[x], cur[x], x}); s2.erase(mp(cur[x], x));
      cnt[x]--; if (!cnt[x]) return;
      cur[x] = nxt[cur[x]]; 
      s1.insert((node){cnt[x], cur[x], x}); s2.insert(mp(cur[x], x));
  }
  ```
* **代码解读**：
  > 这段`op`函数是“选餐操作”的核心：  
  - 首先输出当前选的餐厅位置`cur[x]`，并记录上一个选的食物类型`col`；  
  - 然后从两个`set`中删除该食物类型的旧状态（`s1`是众数集合，`s2`是位置集合）；  
  - 减少该食物类型的剩余次数`cnt[x]`，如果次数为0，直接返回；  
  - 更新该食物类型的下一个可用位置`cur[x] = nxt[cur[x]]`（比如之前是1，现在变成2）；  
  - 最后把新状态插回两个`set`中。
* 💡 **学习笔记**：用函数封装重复操作，让代码更简洁！

**题解二：来源（Eason2009）**
* **亮点**：用“线段树套set”维护每个食物类型的可用位置，适合复杂范围查询。
* **核心代码片段**：
  ```cpp
  int p = min(qry(1, 1, n, 1, col[i-1]-1), qry(1, 1, n, col[i-1]+1, n));
  ans[i] = p;
  col[i] = a[p];
  del(1, 1, n, a[p], p);
  ```
* **代码解读**：
  > 这段代码是“选位置最小的餐厅”的核心：  
  - `qry`函数查询“食物类型在[1, col[i-1]-1]”和“[col[i-1]+1, n]”中的最小位置（避开上一个选的`col[i-1]`）；  
  - `min`函数选这两个区间中的较小值（字典序最小）；  
  - `del`函数从线段树中删除该餐厅位置（标记为已选）。
* 💡 **学习笔记**：线段树可以快速查询“某个范围的最小值”，适合需要多条件筛选的场景。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计一个**“像素餐厅计划师”**的8位像素动画，帮你直观看到贪心选餐的过程~
</visualization_intro>

### 动画设计方案
* **主题**：像素风格的“餐厅选餐游戏”，你是铁柱的“计划助理”，帮他选合法且字典序最小的餐厅。
* **核心演示内容**：
  1. **场景初始化**：屏幕左侧是8x8的像素餐厅网格（每个餐厅是16x16的彩色方块），右侧是控制面板（开始/暂停、单步、重置按钮，速度滑块），底部是“剩余长度”进度条和“当前众数”提示框。
  2. **算法启动**：点击“开始计划”，餐厅网格中**起点（位置1）**闪烁，伴随“叮”的音效，`s_count`和`s_pos`用像素方块堆叠展示（比如`s_count`的方块越高，代表次数越多）。
  3. **逐位选餐**：
     - **众数检查**：如果当前众数次数超过剩余长度的一半，众数提示框会**红色闪烁**，并播放“嗡”的提示音，此时必须选众数对应的餐厅（用黄色箭头标记）；
     - **选最小位置**：如果可以自由选择，位置最小的餐厅会**绿色闪烁**，点击“单步”或自动播放，该餐厅会变成“已选”（灰色），并输出位置，伴随“叮”的音效；
  4. **完成计划**：所有餐厅选完后，网格会播放“胜利”动画（所有餐厅闪烁绿色），播放上扬的“胜利”音调，控制面板显示“计划完成！”。

### 交互与音效设计
- **步进控制**：支持“单步选餐”（点击一次选一个）和“自动播放”（可调速度，比如1秒/步或0.5秒/步）；
- **音效**：选餐厅“叮”、众数检查“嗡”、完成“胜利音调”、无解“短促提示音”；
- **背景音乐**：循环播放8位风格的轻松BGM（类似《超级马里奥》的背景音乐）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了这道题的贪心策略，可以解决很多“相邻元素不同”的问题，比如：
</similar_problems_intro>

### 通用思路迁移
- **重构字符串**：比如LeetCode 767，要求将字符串重构为“相邻字符不同”的形式，且字典序最小；
- **任务安排**：比如安排员工值班，要求相邻两天的员工不同，且优先安排序号小的员工；
- **颜色填充**：比如给网格填充颜色，相邻格子颜色不同，优先用编号小的颜色。

### 洛谷拓展练习推荐
1. **洛谷 P1088 火星人**：需要生成字典序最小的排列，锻炼“字典序贪心”的思路；
2. **洛谷 P2670 扫雷游戏**：虽然是模拟题，但需要“逐位判断合法性”，类似本题的“相邻约束”；
3. **洛谷 P3195 玩具装箱**：需要用贪心+动态规划，锻炼“结合状态维护的贪心”能力。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
Mirasycle题解的作者提到“超级简单题”，但其实背后的“贪心+合法性检查”逻辑并不简单——这提醒我们：**看似简单的题，往往藏着关键结论和技巧**。比如本题的“众数次数不超过一半”的结论，是解决问题的关键钥匙！
</insights_intro>


<conclusion>
本次关于“食事计划”的分析就到这里啦！希望大家能掌握“贪心+合法性检查”的核心思路，学会用`set`或线段树高效维护状态。记住：**贪心不是“随便选”，而是“选当前最安全、最优的选项”**。下次我们再一起挑战更难的编程题吧！💪
</conclusion>

---
处理用时：95.06秒
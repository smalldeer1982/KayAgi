# 题目信息

# [TJOI2013] 奖学金

## 题目背景

小张最近发表了一篇论文，有一个神秘人物要给小张学院发奖学金。

## 题目描述

小张学院有 $c$ 名学生，第 $i$ 名学生的成绩为 $a_i$，要获得的奖学金金额为 $b_i$。  
要从这 $c$ 名学生中挑出 $n$ 名学生发奖学金。这个神秘人物爱好奇特，他希望得到奖学金的同学的**成绩**的**中位数**尽可能大，但同时，他们的**奖学金总额**不能超过 $f$。


## 说明/提示

### 样例 1 解释

选择成绩为 $5$，$35$，$50$ 的三名同学，奖金总额为 $18 + 30 + 21 = 69$。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10^3$，$c \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $3 \leq n  \leq 10^5$，$n \leq c \leq 2 \times 10^5$，$0 \leq f \leq 2\times 10^9$，$0 \leq a_i \leq 2 \times 10^9$，$0 \leq b_i \leq 10^5$。

## 样例 #1

### 输入

```
3 5 70
30 25
50 21
20 20
5 18
35 30
```

### 输出

```
35```

## 样例 #2

### 输入

```
5 6 9
4 0
4 1
6 3
8 0
10 4
10 5
```

### 输出

```
6```

# AI分析结果

# 💡 Kay的C++算法解析：[TJOI2013]奖学金 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心策略 + 优先队列（大根堆）应用  

🗣️ **初步分析**：  
解决“奖学金”问题的关键，就像在一堆苹果里挑最甜的（中位数最大），但要保证总重量不超过篮子的限制（奖学金总额不超f）。我们需要**先按成绩排序**（把苹果按甜度排好），然后**枚举每个可能的中位数**（从甜的苹果开始试），再**贪心选择左右两边最便宜的“配料”**（奖学金最少的学生），凑出符合条件的组合。  

### 核心思路拆解：
1. **排序**：将学生按成绩从小到大排序（这样中位数的位置固定，左边的成绩都≤它，右边的都≥它）。  
2. **枚举中位数**：对于排序后的第`i`个学生（`i`的范围是`k+1`到`c-k`，其中`k=(n-1)/2`），它是候选中位数。  
3. **计算左右最小和**：需要从左边`i-1`个学生中选`k`个奖学金最少的（用大根堆维护），从右边`c-i`个学生中选`k`个奖学金最少的（同样用大根堆），加上当前学生的奖学金，判断总和是否≤f。  

### 可视化设计思路：
我们可以做一个**“像素苹果摊”**动画：  
- **场景**：屏幕左侧是排序后的“苹果堆”（每个像素块代表学生，颜色越深成绩越高，下方显示奖学金）；右侧是“购物车”（显示当前选中的`k`个左边学生、`k`个右边学生和中位数）。  
- **动画步骤**：  
  1. 排序动画：像素块按颜色从浅到深排列（模拟成绩排序）。  
  2. 左边堆处理：从左到右扫描，用大根堆（像素块堆成金字塔）维护最小的`k`个奖学金，每添加一个学生，金字塔会“替换”顶部的大值（如果新值更小）。  
  3. 右边堆处理：从右到左扫描，同理维护右边的`k`个最小值。  
  4. 枚举中位数：选中一个学生（闪烁），自动从左右堆中取最小值，计算总和，若符合条件则播放“叮”的音效，显示“选中！”。  
- **交互**：支持“单步执行”（逐帧看堆的变化）、“自动播放”（快速遍历所有候选中位数），以及“重置”（重新开始排序）。  


## 2. 精选优质题解参考

### 题解一：（来源：ycyaw，赞：4）  
* **点评**：这份题解的思路像“整理购物清单”一样清晰！作者先把学生按成绩排序（整理苹果），然后用**大根堆**分别处理左边和右边的奖学金（挑最便宜的配料）。代码中的`f`数组（左边最小和）和`g`数组（右边最小和）就像“提前算好的购物预算”，枚举中位数时直接查预算，效率很高。变量命名（如`f[i]`表示第`i`个学生作为中位数时左边的最小和）非常直观，边界处理（如`i`的范围是`k+1`到`c-k`）也很严谨。特别是用大根堆维护前`k`小的和，这个技巧像“用篮子装苹果，只留最小的k个”，非常巧妙！  

### 题解二：（来源：YinyuDream，赞：2）  
* **点评**：这道题解的代码像“流水线作业”一样流畅！作者同样用了排序+大根堆的思路，但代码结构更简洁（比如用`priority_queue`直接维护堆）。预处理`suma`（左边最小和）和`sumb`（右边最小和）的过程，就像“提前把左右两边的便宜货挑出来”，枚举中位数时只需“组装”这三部分（左边+中位数+右边）。代码中的`if(z[i].b<q.top())`判断，像“检查新苹果是否比篮子里最大的更便宜”，如果是就替换，保证篮子里始终是最小的k个。  

### 题解三：（来源：abandentsky，赞：0）  
* **点评**：这份题解的思路和前两份一致，但代码中的`Left`和`Right`数组命名更明确（左边最小和、右边最小和）。作者用`sort(P+1,P+1+c,comp)`将成绩从大到小排序，这样枚举中位数时可以从大到小试，一旦找到符合条件的就直接输出（因为要找最大的中位数）。这个小优化像“从最甜的苹果开始试，找到第一个符合重量的就停止”，节省了时间。  


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何确定中位数的位置范围？**  
* **分析**：中位数是第`(n+1)/2`大的数（排序后），所以它的左边必须有`k=(n-1)/2`个学生，右边也必须有`k`个学生。因此，候选中位数的位置`i`必须满足`k+1 ≤ i ≤ c-k`（比如`n=3`，`k=1`，`i`只能是`2`到`c-1`）。  
* 💡 **学习笔记**：中位数的位置范围是“左右都有足够空间”的位置，否则无法选出`n`个学生。  

### 2. **难点2：如何高效计算区间前k小的和？**  
* **分析**：直接暴力计算每个区间的前k小和，时间复杂度是`O(c^2)`，对于`c=2e5`来说会超时。用**大根堆**维护前k小的和，时间复杂度是`O(c log k)`，非常高效。大根堆的作用是“保留最小的k个元素”，当新元素比堆顶小，就替换堆顶，这样堆里始终是当前区间最小的k个元素。  
* 💡 **学习笔记**：大根堆是处理“前k小”问题的神器，像“一个筛子，只留最小的k个”。  

### 3. **难点3：如何处理边界条件？**  
* **分析**：比如左边的学生数不足`k`个（`i-1 < k`），或者右边的学生数不足`k`个（`c-i < k`），这时候这个`i`不能作为中位数。在代码中，我们通过枚举范围`k+1 ≤ i ≤ c-k`来避免这种情况。  
* 💡 **学习笔记**：枚举范围的确定是解决边界问题的关键，提前排除不可能的情况。  

### ✨ 解题技巧总结  
- **排序是基础**：将学生按成绩排序，才能固定中位数的位置。  
- **贪心选最小**：要让总额最小，必须选左右两边奖学金最少的学生。  
- **堆维护效率高**：用大根堆维护前k小的和，避免重复计算。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了ycyaw、YinyuDream的思路，用大根堆预处理左右最小和，枚举中位数判断。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

const int MAXN = 2e5 + 10;
struct Student {
    int grade, money;
    bool operator<(const Student& other) const {
        return grade < other.grade; // 按成绩从小到大排序
    }
} stu[MAXN];

int main() {
    int n, c, f;
    cin >> n >> c >> f;
    for (int i = 1; i <= c; ++i) {
        cin >> stu[i].grade >> stu[i].money;
    }
    sort(stu + 1, stu + c + 1); // 排序

    int k = (n - 1) / 2;
    vector<long long> left_sum(c + 2, 0); // left_sum[i]：前i-1个学生中选k个的最小和
    priority_queue<int> left_heap; // 大根堆，维护前k小的money
    long long sum = 0;
    for (int i = 1; i <= c; ++i) {
        if (i <= k) { // 前k个直接加入
            left_heap.push(stu[i].money);
            sum += stu[i].money;
            left_sum[i] = sum;
        } else { // 从k+1开始，判断是否替换堆顶
            left_sum[i] = sum;
            if (stu[i].money < left_heap.top()) {
                sum -= left_heap.top();
                sum += stu[i].money;
                left_heap.pop();
                left_heap.push(stu[i].money);
                left_sum[i] = sum;
            }
        }
    }

    vector<long long> right_sum(c + 2, 0); // right_sum[i]：i+1到c中选k个的最小和
    priority_queue<int> right_heap;
    sum = 0;
    for (int i = c; i >= 1; --i) {
        if (i > c - k) { // 后k个直接加入
            right_heap.push(stu[i].money);
            sum += stu[i].money;
            right_sum[i] = sum;
        } else { // 从c-k开始，判断是否替换堆顶
            right_sum[i] = sum;
            if (stu[i].money < right_heap.top()) {
                sum -= right_heap.top();
                sum += stu[i].money;
                right_heap.pop();
                right_heap.push(stu[i].money);
                right_sum[i] = sum;
            }
        }
    }

    // 枚举中位数（i的范围是k+1到c-k）
    int ans = -1;
    for (int i = k + 1; i <= c - k; ++i) {
        long long total = left_sum[i - 1] + right_sum[i + 1] + stu[i].money;
        if (total <= f) {
            ans = stu[i].grade;
        }
    }
    cout << ans << endl;

    return 0;
}
```
* **代码解读概要**：  
  1. **排序**：将学生按成绩从小到大排序，以便固定中位数的位置。  
  2. **预处理左边最小和**：用大根堆维护前`i-1`个学生中最小的`k`个奖学金之和，存入`left_sum`数组。  
  3. **预处理右边最小和**：用大根堆维护`i+1`到`c`中最小的`k`个奖学金之和，存入`right_sum`数组。  
  4. **枚举中位数**：遍历所有候选中位数位置，计算总和，若符合条件则更新答案。  

### 针对优质题解的片段赏析  
**题解一（ycyaw）核心代码片段**：  
```cpp
// 预处理左边最小和
for (int i = 1; i <= n/2; ++i) {
    q.push(a[i].mn);
    sum += a[i].mn;
}
for (int i = n/2 + 1; i <= c - n/2; ++i) {
    f[i] = sum;
    if (a[i].mn < q.top()) {
        sum -= q.top();
        sum += a[i].mn;
        q.pop();
        q.push(a[i].mn);
    }
}
```
* **代码解读**：  
  - 前`n/2`个学生直接加入大根堆，计算总和。  
  - 从`n/2+1`开始，每个学生都和堆顶比较（堆顶是当前堆中最大的奖学金）。如果当前学生的奖学金更小，就替换堆顶，更新总和。这样堆里始终是前`i-1`个学生中最小的`n/2`个奖学金。  
* 💡 **学习笔记**：大根堆的“替换”操作是维护前k小和的关键，像“把篮子里最大的苹果换成更小的，这样篮子里的总重量就更小了”。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**像素苹果摊的“最优选择”游戏**  
### 设计思路：  
用8位像素风格模拟“选苹果”的过程，让学习者直观看到排序、堆维护、枚举中位数的过程。复古游戏元素（如音效、动画）能增加趣味性，帮助记忆。  

### 动画帧步骤与交互关键点：  
1. **场景初始化**：  
   - 屏幕左侧是`c`个像素块（代表学生），颜色从浅到深（成绩从低到高），下方显示奖学金（数字）。  
   - 屏幕右侧是“购物车”：左边显示`k`个像素块（左边选中的学生），右边显示`k`个像素块（右边选中的学生），中间显示中位数（闪烁的像素块），底部显示总奖学金。  
   - 控制面板：“开始”“单步”“自动”“重置”按钮，速度滑块。  

2. **排序动画**：  
   - 像素块按颜色从浅到深排列（模拟`sort`函数），每移动一个像素块播放“唰”的音效。  

3. **左边堆处理动画**：  
   - 从左到右扫描像素块，每扫描一个，就把它的奖学金加入大根堆（用金字塔形状的像素块表示堆，顶部是堆顶）。  
   - 当堆的大小超过`k`时，比较当前像素块和堆顶：如果当前更小，堆顶的像素块会“掉下来”，当前像素块“升上去”成为新堆顶，同时总和更新（数字闪烁）。  

4. **右边堆处理动画**：  
   - 从右到左扫描，同理维护右边的大根堆，动画效果类似左边。  

5. **枚举中位数动画**：  
   - 从`k+1`到`c-k`遍历像素块，每个候选中位数会“闪烁”。  
   - 自动从左边堆和右边堆中取出最小的`k`个像素块，放入购物车，计算总奖学金（数字跳动）。  
   - 如果总奖学金≤f，播放“叮”的音效，购物车显示“选中！”，并停止动画。  

### 游戏化元素：  
- **音效**：排序时“唰”，堆替换时“咔”，选中时“叮”，失败时“咚”。  
- **积分**：每处理一个学生得1分，选中符合条件的中位数得10分，鼓励学习者“闯关”。  
- **AI演示**：点击“自动”按钮，AI会快速遍历所有候选中位数，展示最优解的过程。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移：  
- **排序+贪心+堆**的思路，适用于**需要在有序序列中选择部分元素，使得某个目标（如总和、最大值）最优**的问题。例如：  
  1. 从数组中选`k`个元素，使得总和最小（用大根堆）。  
  2. 从数组中选`k`个元素，使得最大值最小（排序后选前`k`个）。  
  3. 安排任务，使得总时间最短（排序后贪心选择）。  

### 练习推荐 (洛谷)：  
1. **洛谷 P1168 中位数**：  
   - 🗣️ **推荐理由**：这道题需要找中位数，和本题的“中位数”概念直接相关，能帮助你巩固排序的应用。  
2. **洛谷 P2078 朋友**：  
   - 🗣️ **推荐理由**：这道题需要贪心选择朋友，用堆维护最优解，和本题的“选最小奖学金”思路一致。  
3. **洛谷 P3817 小A的糖果**：  
   - 🗣️ **推荐理由**：这道题需要贪心选择糖果，用堆维护最小总和，能帮助你巩固堆的使用。  


## 7. 学习心得与经验分享 (若有)  
- **来自ycyaw的经验**：“我在解决这道题时，一开始没想到用堆维护前k小的和，导致超时。后来看了题解，才知道堆是处理这种问题的神器。”  
  - **点评**：这位作者的经验提醒我们，**遇到“前k小”或“前k大”的问题，首先要想到堆**。堆能高效维护动态的前k小元素，避免重复计算。  
- **来自YinyuDream的经验**：“排序是解决中位数问题的基础，没有排序，中位数的位置就无法固定。”  
  - **点评**：排序是处理有序问题的关键，像“整理房间”一样，把东西按顺序排好，才能更快找到需要的东西。  


## 结语  
本次关于“[TJOI2013]奖学金”的分析，我们学习了**排序+贪心+堆**的经典思路。希望这份指南能帮助你理解核心算法，掌握解题技巧。记住，**编程的关键是“思路清晰”**——先想清楚要做什么，再用代码实现。下次我们再一起探索新的编程挑战！💪

---
处理用时：165.10秒
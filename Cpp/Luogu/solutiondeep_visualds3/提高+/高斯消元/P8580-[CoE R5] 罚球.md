# 题目信息

# [CoE R5] 罚球

## 题目描述

有 $n$ 个人在玩罚球游戏，游戏规则如下：
- 每个人编号为 $1,2,\dots,n$，最开始由 $1$ 号罚球，接下来让下一个没有出局的人罚球。特殊地，$n$ 号的下一个是 $1$ 号。
- 如果罚球者没有碰到篮板，那么直接出局。
- 如果罚球者碰到篮板但没有进球，那么如果上一个人进球了，这个人就会出局，否则不会出局。
- 游戏结束的条件是最后只剩下一个人。

注意最开始的那个人碰到篮板但没有进球不出局。

这 $n$ 个人中，第 $i$ 个人碰不到篮板的概率为 $\dfrac{a_i}{1000}$，碰到篮板但没有进球的概率为 $\dfrac{b_i}{1000}$，求游戏结束时所有人总共罚球数量的期望值。

## 说明/提示

**关于取模**

不会有理数取模的看[这里](https://www.luogu.com.cn/problem/P2613)。



------------
**样例说明**

输入 $\#1$：

所有人碰不到篮板的概率都是 $\dfrac{1}{5}$，碰到篮板但不进球的概率都是 $\dfrac{2}{5}$，罚球数量的期望值为 $\dfrac{25}{9}$。

计算如下（黑色表示出局，红色表示没进球但不出局，蓝色表示进球）：
$$\dfrac{1}{5}+\red{\dfrac{2}{5}}\times(\dfrac{1}{5}+\red{\dfrac{2}{5}}\times(...)+\blue{\dfrac{2}{5}}\times(...))+\blue{\dfrac{2}{5}}\times(\dfrac{3}{5}+\blue{\dfrac{2}{5}}\times(...))=\dfrac{25}{9}$$

输入 $\#2$：

所有人碰不到篮板的概率都是 $\dfrac{321}{1000}$，碰到篮板但不进球的概率都是 $\dfrac{637}{1000}$，罚球数量的期望值为 $\dfrac{1000000}{57959}$。

------------

**数据范围**

**本题采用捆绑测试**。

测试点性质：
| $t=$ | 性质 | 分数 |
| :----------: | :----------: | :----------: |
| $1$ | $n=1$ | $2$ |
| $2$ | $a_i=b_i=0$ | $2$ |
| $3$ | $a_i=1000$ | $4$ |
| $4$ | $b_i=1000$ | $4$ |
| $5$ | $a_i=0,b_1=0,\forall i>1,b_i=1000$ | $6$ |
| $6$ | $a_i=b_i=500$ | $6$ |
| $7$ | $a_i=0,b_i=500$ | $6$ |
| $8$ | $a_i,b_i$ 均为定值，且答案不为 $-1$ | $19$ |
| $9$ | $1 \le n \le 11$ | $26$ |
| $10$ | $1 \le n \le 15$ | $8$ |
| $11$ | 无特殊性质 | $17$ |

**对于** $100\%$ **的数据**，$1 \le n \le 18$，$0 \le a_i,b_i,a_i+b_i \le 1000$。

本题的 $\text{Subtask 10}$ 分为两部分计分，对应 $t \in \{10,11\}$。

保证不存在分母为 $10^6+33$ 的倍数的情况。

## 样例 #1

### 输入

```
2 8
200 400
200 400```

### 输出

```
888921```

## 样例 #2

### 输入

```
7 8
321 637
321 637
321 637
321 637
321 637
321 637
321 637```

### 输出

```
818968```

## 样例 #3

### 输入

```
6 10
338 270
229 413
132 133
141 173
157 686
616 250```

### 输出

```
315860```

## 样例 #4

### 输入

```
8 10
338 270
229 413
132 133
141 173
157 686
616 250
0 0
0 0```

### 输出

```
-1```

# AI分析结果


# 💡 Kay的C++算法解析：罚球 深入学习指南 💡

> 大家好！我是Kay，今天我们一起探索这道有趣的环形罚球期望问题。题目看似复杂，但只要抓住核心算法本质，你也能轻松掌握！

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`期望动态规划` + `状态压缩` + `高斯消元优化`

🗣️ **初步分析**：
> 想象一群像素小人在环形球场轮流罚球——这就像经典FC游戏《热血篮球》的数学版！核心是**状态压缩DP**：  
> - 用二进制状态`S`记录存活玩家（类似游戏角色血条）  
> - 定义`f(S,i,0/1)`表示存活集合`S`时，从`i`开始罚球，且上一位是否进球的期望次数  
> - 状态转移会形成环状依赖（当前状态依赖下一个状态），需用**高斯消元**解方程组  

**难点突破**：  
1. 环形结构导致状态转移成环，必须同层状态联立求解  
2. 朴素高斯消元O(n³)太慢，需优化为O(n)的**带状矩阵消元**或**主元法**  
3. 特判无解情况（如多个百发百中选手）  

**像素动画设计**：  
- 8-bit风格环形球场，角色用不同颜色像素块表示  
- 当前罚球者闪烁红光，出局者变灰块  
- 罚球结果特效：  
  - 未碰篮板：红色X + "miss"音效  
  - 碰板未进：黄色! + "bounce"音效  
  - 进球：绿色√ + "score"音效  
- 控制面板：单步/自动模式（可调速），右侧同步显示DP方程  

---

## 2. 精选优质题解参考

**题解一（官方题解）**  
* **点评**：状态定义清晰（`f(S,i)`,`g(S,i)`分别对应上轮进球状态），完整覆盖10个子任务。亮点在于：  
  - 预处理逆元优化模运算（线性时间）  
  - 针对带状矩阵特性优化高斯消元（非零元检测跳过计算）  
  - 严谨处理无解边界（`c[j][n]=-1`特殊标记）  
  > "赛时果然被爆标了"——作者调试心得提醒我们注意复杂度优化  

**题解二（Nazq）**  
* **点评**：创新性地将状态转移矩阵可视化为环形带状矩阵。亮点：  
  - 数学推导证明O(n)消元可行性（常规O(n³)→优化O(n)）  
  - 代码中`rk[state][cnt]`巧妙处理环形下标映射  
  - 独立讨论上轮进球/未进两种状态转移  

**题解三（do_while_true）**  
* **点评**：采用**主元法**将高斯消元复杂度降至O(n)。亮点：  
  - 对同状态集合S的方程进行链式消元  
  - 无解判断逻辑清晰（`ct1>=2`等条件）  
  - 代码模块化：`solve(S)`函数专注状态求解  

---

## 3. 核心难点辨析与解题策略

1.  **状态转移成环**  
    * **分析**：因环形依赖，不能直接递推。优质解法都采用：  
      - 按集合大小升序枚举状态`S`  
      - 对每个`S`建立方程组`A·X=B`  
      - 通过带状矩阵特性/主元法降复杂度  

2.  **高斯消元优化**  
    * **分析**：常规消元O(n³)不可行。题解方案：  
      - Alarm5854：检测非零元跳过计算（稀疏矩阵优化）  
      - do_while_true：主元法转化为链式方程（O(n)求解）  
      - Nazq：数学证明转移矩阵的带状特性  

3.  **环形下标处理**  
    * **分析**：玩家出局后环形索引变化。通用技巧：  
      - 预处理`nxt`数组记录下一个存活者  
      - 用`pos[state]`映射状态位与实际下标  

### ✨ 解题技巧总结
- **环形问题技巧**：拆环为链 + 状态压缩存储当前存活集合  
- **期望DP套路**：定义状态包含"上一轮结果"的二进制标志  
- **方程组优化**：利用转移矩阵的稀疏性（每行仅2个非零元）  
- **调试技巧**：小数据验证状态转移方程（如n=2,3）  

---

## 4. C++核心代码实现赏析

**通用核心实现参考**  
```cpp
const int mod = 1000033;
int f[1<<18][18][2]; // f[S][i][0/1]：存活集合S，从i开始，上轮未进/进球

void solve(int S) {
    vector<int> alive;
    for(int i=0; i<n; ++i) if(S>>i&1) alive.push_back(i);
    
    // 构建方程组 AX=B
    Matrix A(alive.size()*2, Vector(alive.size()*2+1));
    for(int i=0; i<alive.size(); ++i) {
        int x = alive[i];
        int nxt = /* 计算下一个存活者 */;
        // 上轮未进球的状态转移
        A[2*i][2*i] = 1;
        A[2*i][2*i+1] = -b[x];
        A[2*i][(2*i+2) % A.size()] = -c[x];
        A[2*i].back() = a[x]*f[S^(1<<x)][nxt][0] + 1;
        
        // 上轮进球的状态转移
        A[2*i+1][2*i+1] = 1;
        A[2*i+1][(2*i+2) % A.size()] = -c[x];
        A[2*i+1].back() = (a[x]+b[x])*f[S^(1<<x)][nxt][0] + 1;
    }
    gauss(A); // 优化版高斯消元
    // 解存入f[S][*][*]
}
```

**题解一核心片段赏析**  
```cpp
// 带状矩阵检测优化
for(ll j=i; j<n; ++j) {
    if(c[j][i]) { // 仅处理非零元素
        t=j; break;
    }
}
if(!c[t][i]) continue; // 跳过全零行
```

**题解二核心片段赏析**  
```cpp
// 环形nxt计算
for(int i=(id+n-1)%n,j=id; ; i=(i+n-1)%n) {
    if(s>>i&1) continue;
    // 状态转移方程构建...
    if((j=i)==id) break; // 环形终止条件
}
```

**题解三核心片段赏析**  
```cpp
// 主元法解方程（O(n)复杂度）
for(int i=m; i>=2; --i) {
    x = 1ll*x*v[i]%mod;   // 递推系数
    y = 1ll*y*v[i]%mod;   // 递推常数
    x = del(0,x);
    y = del(w[i],y);
}
ans[1] = /* 解首个变量 */;
for(int i=m; i>=2; --i)   // 回代求解
    ans[i] = del(w[i], 1ll*ans[i+1]*v[i]%mod);
```

---

## 5. 算法可视化：像素动画演示

**主题**：8-bit风格《环形罚球大冒险》  
**核心演示**：状态压缩DP的转移过程  

1. **场景设计**：  
   - 环形球场：18个彩色像素块代表玩家  
   - 控制面板：开始/暂停/单步/速度滑块  
   - 状态显示区：当前二进制状态`S`，期望值`f(S,i,*)`  

2. **动画流程**：  
   ```mermaid
   graph LR
   A[当前状态S] --> B[高亮罚球者i]
   B --> C{罚球结果}
   C -->|未碰篮板| D[移除i, 播放爆炸音效]
   C -->|碰板未进| E[判断上轮状态]
   C -->|进球| F[保持状态, 绿色闪烁]
   E -->|上轮进球| G[移除i, 黄色警示]
   E -->|上轮未进| H[保留i, 橙色提示]
   D/G/H --> I[更新状态S']
   ```

3. **游戏化元素**：  
   - 每解一个状态`S`得1分，特效庆祝  
   - 不同罚球结果触发FC音效：  
     - 未碰板：低沉"轰"声  
     - 碰板未进：中频"叮"声  
     - 进球：欢快"叮咚"声  
   - AI自动演示模式：像贪吃蛇AI自动解环  

4. **技术实现**：  
   - Canvas绘制环形球场和像素小人  
   - 状态转移同步显示方程：  
     ```python
     f(S,i,0) = a_i * f(S-{i},j,0) 
               + b_i * f(S,j,0)
               + c_i * f(S,j,1) + 1
     ```

---

## 6. 拓展练习与相似问题思考

**技巧迁移**：  
1. 环形状态压缩：约瑟夫问题变种  
2. 带环期望DP：赌徒输光问题  
3. 稀疏矩阵优化：电路网络求解  

**洛谷练习推荐**：  
1. **P1654 OSU!**  
   🗣️ 巩固期望DP基础，掌握概率连续性  
2. **P2473 宝物筛选**  
   🗣️ 强化状态压缩+期望DP的综合应用  
3. **P2599 概率充电器**  
   🗣️ 树形期望DP，培养拓扑思维  

---

## 7. 学习心得与经验分享

> **来自官方题解的调试经验**：  
> "赛时果然被爆标了" —— 提醒我们注意复杂度常数优化  

> **Kay的总结**：  
> 1. 状态压缩DP的关键是找"状态特征"（存活集合+上轮结果）  
> 2. 高斯消元优化要善用矩阵特性（稀疏/带状）  
> 3. 遇到环状问题，先拆解为状态转移图  

> **调试技巧**：  
> - 用`n=2`手动验算转移方程  
> - 输出中间状态`f(S,i,*)`验证  

---

通过本指南，相信大家已掌握环形期望问题的解决要领。记住：将复杂问题分解为状态转移+数学求解，就是算法设计的精髓！下次见啦~ 💪

---
处理用时：138.75秒
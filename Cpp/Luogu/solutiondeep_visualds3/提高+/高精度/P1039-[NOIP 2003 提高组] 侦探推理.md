# 题目信息

# [NOIP 2003 提高组] 侦探推理

## 题目描述

明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：

$$
\def\arraystretch{1.5}
\begin{array}{|l|l|}\hline
\textbf{\textsf{证词内容}} & \textbf{\textsf{证词含义}}\\\hline
\text{I am guilty.} & \text{我是罪犯。} \\\hline
\text{I am not guilty.} & \text{我不是罪犯。} \\\hline
\text{{\tt XXX} is guilty.} & \text{{\tt XXX} 是罪犯。其中 {\tt XXX} 表示某个同学的名字。} \\\hline
\text{{\tt XXX} is not guilty.} & \text{{\tt XXX} 不是罪犯。} \\\hline
\text{Today is {\tt XXX}.} &
\begin{aligned}
&\text{今天是 {\tt XXX}。其中 {\tt XXX} 表示某个星期的单词。}\\
&\text{星期只有可能是以下之一：}\\
&\texttt{Monday}, \texttt{Tuesday}, \texttt{Wednesday}, \texttt{Thursday}, \\
&\texttt{Friday}, \texttt{Saturday}, \texttt{Sunday}。
\end{aligned}
\\\hline
\end{array}$$

证词中出现的其他话，都不列入逻辑推理的内容。


明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。


现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！

## 说明/提示

对于 $100\%$ 数据，满足 $1\le M\le 20$，$0\le N\le M$，$1\le P\le 100$。

**【题目来源】**

NOIP 2003 提高组第二题

## 样例 #1

### 输入

```
3 1 5
MIKE
CHARLES
KATE
MIKE: I am guilty.
MIKE: Today is Sunday.
CHARLES: MIKE is guilty.
KATE: I am guilty.
KATE: How are you??
```

### 输出

```
MIKE
```

# AI分析结果



---
# 💡 Kay的C++算法解析：侦探推理 深入学习指南 💡

<introduction>
今天我们要一起攻克这道经典的“侦探推理”题！这道题需要我们通过分析证词，结合逻辑推理和枚举法找出唯一的罪犯。别担心，跟着我的分析，你会发现它的核心思路其实很清晰~
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举与模拟` (枚举罪犯和日期，模拟证词真伪判断)

🗣️ **初步分析**：
解决这道题的关键在于“枚举+验证”的思路。简单来说，就像玩“排除法”游戏——我们需要枚举所有可能的罪犯和今天的日期（因为罪犯只有1个，日期只有7种可能），然后验证在这些假设下，是否恰好有N个人始终说假话，其余人说真话。如果符合条件，就能锁定罪犯；如果多个假设都符合，就输出“Cannot Determine”；如果没有符合的，输出“Impossible”。

- **题解思路**：所有优质题解都采用了类似的双重枚举（枚举罪犯和日期），然后遍历所有证词，判断每个人的证词是否自洽（全真或全假），并统计说假话的人数是否符合N。
- **核心难点**：如何正确解析证词（区分自指、指认他人、日期陈述），以及如何高效验证枚举的假设是否矛盾（比如同一个人既说真话又说假话）。
- **可视化设计**：我们将设计一个“像素侦探社”动画，用8位风格展示枚举过程：屏幕左侧是角色像素头像（如MIKE、CHARLES等），右侧是日期选择按钮（周一到周日）。点击“开始枚举”后，动画会逐步展示每个假设（比如假设MIKE是罪犯、今天是周日），用不同颜色（绿色=真话，红色=假话）标记证词气泡，并在底部统计当前假话人数是否符合N。关键步骤（如发现矛盾）会伴随“叮”的音效，成功锁定罪犯时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选出以下优质题解（评分≥4星）：
</eval_intro>

**题解一：作者wjyyy（赞22）**
* **点评**：此题解结构非常清晰！作者用`map`映射人名和日期，用`vector`存储每个人的合法证词，逻辑层层递进。代码中对输入的处理（如去掉冒号、判断合法证词）非常细致，枚举部分通过嵌套循环遍历所有可能的罪犯和日期，验证时通过统计说假话的人数是否符合N来判断假设是否成立。亮点在于对“不确定”人群（没说过合法证词的人）的处理，用`ran`变量灵活统计可能的假话人数范围，大大提升了算法的鲁棒性。

**题解二：作者Lovelace_qwq（赞2）**
* **点评**：此题解的注释非常友好，适合新手学习。作者将证词判断封装成`judge`函数，逻辑直白（返回0=真话，1=假话，-1=无效），主函数通过双重循环枚举罪犯和日期，再调用`check`函数验证是否符合条件。亮点在于对输入的细节处理（如删除多余空格和换行符），避免了因输入格式问题导致的错误。

**题解三：作者Sanust（赞3）**
* **点评**：此题解对证词的解析非常细致！作者用结构体`node`存储证词的主语、是否是日期陈述、是否是否定句，处理输入时考虑了“名字叫I的人”等特殊情况。枚举部分通过遍历所有证词，统计说假话的人数和不确定人数，判断是否满足N的条件。亮点在于对“矛盾”的快速判断（如发现某人同时说真话和假话时直接跳过当前假设），提升了枚举效率。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，我们常遇到以下关键点，掌握这些能让你少走弯路：
</difficulty_intro>

1.  **关键点1：如何正确解析证词？**
    * **分析**：证词有5种有效类型（自指、指认他人、日期），其他都是无效的。解析时需要注意：
      - 自指（“I am guilty.”）的主语是说话者自己。
      - 指认他人（“XXX is guilty.”）的主语是XXX。
      - 日期陈述（“Today is XXX.”）需要映射到1-7的数字。
      优质题解通常用`map`或`string`匹配来处理这些类型，例如wjyyy的代码中用`day`字典将星期字符串映射到数字。
    * 💡 **学习笔记**：处理字符串时，建议先删除多余的标点（如冒号、句号），再通过`substr`或`find`分割关键词。

2.  **关键点2：如何验证枚举的假设是否矛盾？**
    * **分析**：假设某人是罪犯、某天是日期后，需要检查每个人的所有证词是否全真或全假。如果某人的证词中既有真话又有假话（如先说“今天是周一”，又说“今天是周二”），则当前假设不成立。例如，Lovelace_qwq的`judge`函数会返回每句证词的真伪，`check`函数统计是否存在矛盾。
    * 💡 **学习笔记**：可以用一个数组记录每个人的当前状态（说真话/说假话/未确定），遍历证词时动态更新，发现矛盾立即终止验证。

3.  **关键点3：如何统计说假话的人数？**
    * **分析**：说假话的人数必须恰好是N，但有些人可能没说过有效证词（称为“不确定人群”），他们可以是真话或假话。例如，假设当前统计的确定假话人数是`cnt`，不确定人数是`ran`，只要`cnt ≤ N ≤ cnt+ran`，假设就成立。wjyyy的代码中用`cnt`和`ran`变量处理这一逻辑。
    * 💡 **学习笔记**：不确定人群是“弹性”的，他们的数量决定了N的可能范围，这是验证假设的关键条件。

### ✨ 解题技巧总结
<summary_best_practices>
- **输入处理优先**：先清理输入中的多余字符（如冒号、换行符），再解析证词类型，避免因格式问题导致错误。
- **枚举有序性**：先枚举罪犯（1~M），再枚举日期（1~7），双重循环覆盖所有可能，确保不遗漏。
- **矛盾早终止**：验证证词时，一旦发现某人的证词自相矛盾（如同时说真和假），立即跳过当前假设，提升效率。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合了wjyyy和Lovelace_qwq的题解，提炼出一个结构清晰、易于理解的核心实现。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了多个优质题解的思路，重点处理输入解析、枚举验证和矛盾判断，适合作为学习模板。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <map>
    #include <vector>
    #include <string>
    using namespace std;

    map<string, int> name_map; // 人名到编号的映射
    map<string, int> day_map = {{"Monday",1},{"Tuesday",2},{"Wednesday",3},{"Thursday",4},{"Friday",5},{"Saturday",6},{"Sunday",7}};
    vector<string> names(25); // 存储人名
    struct Statement {
        int type; // 0:自指/指认他人，1:日期；is_guilty:是否是“有罪”；target:目标编号（自指为说话者，日期为星期数）
        int target;
        bool is_guilty;
    };
    vector<Statement> stmts[25]; // 每个人的证词列表

    int m, n, p;

    // 解析证词类型
    void parse_stmt(int speaker, string s) {
        if (s == "I am guilty.") {
            stmts[speaker].push_back({0, speaker, true});
        } else if (s == "I am not guilty.") {
            stmts[speaker].push_back({0, speaker, false});
        } else if (s.substr(0, 9) == "Today is ") {
            string day = s.substr(9, s.size()-10); // 去掉“Today is ”和句号
            if (day_map.count(day)) {
                stmts[speaker].push_back({1, day_map[day], true});
            }
        } else {
            // 处理“XXX is guilty/not guilty”
            size_t pos = s.find(" is ");
            string target_name = s.substr(0, pos);
            if (!name_map.count(target_name)) return; // 无效证词
            int target = name_map[target_name];
            if (s.substr(pos+4) == "guilty.") {
                stmts[speaker].push_back({0, target, true});
            } else if (s.substr(pos+4) == "not guilty.") {
                stmts[speaker].push_back({0, target, false});
            }
        }
    }

    // 验证假设：guilty是罪犯，today是星期几
    bool check(int guilty, int today) {
        int cnt = 0; // 确定说假话的人数
        int ran = 0; // 不确定人数（没说有效证词）
        for (int i = 1; i <= m; ++i) {
            if (stmts[i].empty()) {
                ran++;
                continue;
            }
            bool is_liar = -1; // -1:未确定，0:真话，1:假话
            for (auto& s : stmts[i]) {
                bool actual;
                if (s.type == 1) {
                    actual = (s.target == today);
                } else {
                    actual = (s.target == guilty) == s.is_guilty;
                }
                if (is_liar == -1) {
                    is_liar = !actual; // 第一句决定是否说谎
                } else {
                    if (is_liar != !actual) return false; // 矛盾
                }
            }
            if (is_liar) cnt++;
        }
        return cnt <= n && n <= cnt + ran;
    }

    int main() {
        cin >> m >> n >> p;
        for (int i = 1; i <= m; ++i) {
            cin >> names[i];
            name_map[names[i]] = i;
        }
        cin.ignore(); // 忽略换行符
        for (int i = 0; i < p; ++i) {
            string line;
            getline(cin, line);
            size_t colon = line.find(':');
            string speaker_name = line.substr(0, colon);
            string content = line.substr(colon+2); // 跳过冒号和空格
            int speaker = name_map[speaker_name];
            parse_stmt(speaker, content);
        }

        string ans = "";
        for (int i = 1; i <= m; ++i) {
            for (int d = 1; d <= 7; ++d) {
                if (check(i, d)) {
                    if (ans.empty()) {
                        ans = names[i];
                    } else if (ans != names[i]) {
                        cout << "Cannot Determine" << endl;
                        return 0;
                    }
                }
            }
        }
        if (ans.empty()) {
            cout << "Impossible" << endl;
        } else {
            cout << ans << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：
  1. **输入处理**：用`name_map`和`day_map`映射人名和日期，`parse_stmt`函数解析每句证词，存储到`stmts`数组中。
  2. **枚举验证**：`check`函数遍历每个人的证词，判断是否矛盾，并统计假话人数是否符合N。
  3. **结果输出**：遍历所有可能的罪犯和日期，输出唯一符合条件的罪犯或判断无法确定/不可能。

---
<code_intro_selected>
接下来，我们看优质题解的核心代码片段，学习其中的巧妙设计：
</code_intro_selected>

**题解一：作者wjyyy**
* **亮点**：用`vector<sta>`存储证词，结构清晰；处理“不确定人群”时用`ran`变量，灵活统计假话人数范围。
* **核心代码片段**：
    ```cpp
    struct sta {
        int u; // 主语编号
        bool to; // 0:指认他人，1:日期
        bool is; // 是否是“有罪”陈述
    };
    vector<sta> v[25]; // 每个人的证词列表

    // 枚举罪犯i和日期j
    for(int i=1;i<=n;++i) {
        for(int j=1;j<=7;++j) {
            int flag=0, cnt=n, ran=0;
            for(int k=1;!flag&&k<=n;++k) {
                if(v[k].empty()) { ran++; continue; }
                bool rea = (v[k][0].to ? (v[k][0].u == j) : ((v[k][0].u == i) ^ !v[k][0].is));
                for(auto it = v[k].begin()+1; it != v[k].end(); ++it) {
                    bool cur = (it->to ? (it->u == j) : ((it->u == i) ^ it->is));
                    if(cur != rea) { flag=1; break; }
                }
                cnt -= rea;
            }
            if(!flag && cnt >= m && cnt - ran <= m) { /* 符合条件 */ }
        }
    }
    ```
* **代码解读**：
  - `sta`结构体存储证词的主语、类型（指认/日期）、是否是“有罪”陈述。
  - 枚举时，先判断第一个证词的真伪（`rea`），再检查后续证词是否与`rea`一致（矛盾则`flag=1`）。
  - `cnt`统计确定说真话的人数（总人数n减去`cnt`即确定说假话的人数），`ran`统计不确定人数，判断`cnt - ran <= m <= cnt`（m是题目要求的假话人数）。
* 💡 **学习笔记**：用第一个证词确定真伪，再验证后续证词是否自洽，是高效判断矛盾的方法。

**题解二：作者Lovelace_qwq**
* **亮点**：`judge`函数封装证词真伪判断，代码可读性强；`check`函数统计假话人数，逻辑直白。
* **核心代码片段**：
    ```cpp
    // 返回0:真话，1:假话，-1:无效
    int judge(int day, int gui, int now, string s) {
        if(s == "I am guilty.") return gui != now;
        if(s == "I am not guilty.") return gui == now;
        for(int i=0; i<m; ++i) {
            if(name[i]+" is guilty." == s) return i != gui;
            if(name[i]+" is not guilty." == s) return i == gui;
        }
        for(int i=0; i<7; ++i) {
            if(weekday[i] == s) return day != i;
        }
        return -1;
    }

    bool check(int day, int man) {
        int vis[105]; // -1:未确定，0:真话，1:假话
        memset(vis, -1, sizeof(vis));
        for(int i=0; i<p; ++i) {
            auto [who, s] = sen[i];
            int t = judge(day, man, who, s);
            if(t == -1) continue;
            if(vis[who] == -1) vis[who] = t;
            else if(vis[who] != t) return false;
        }
        int cntf=0, cnto=0;
        for(int i=0; i<m; ++i) {
            if(vis[i]==1) cntf++;
            else if(vis[i]==-1) cnto++;
        }
        return cntf <= n && cntf + cnto >= n;
    }
    ```
* **代码解读**：
  - `judge`函数根据假设的日期（`day`）和罪犯（`man`），判断某句证词（`s`）的真伪（`t=0`真，`t=1`假）。
  - `check`函数用`vis`数组记录每个人的状态，遍历所有证词，若发现矛盾（`vis[who] != t`）则返回false。
  - 最后统计确定说假话的人数（`cntf`）和不确定人数（`cnto`），判断是否满足`cntf ≤ n ≤ cntf+cnto`。
* 💡 **学习笔记**：用数组记录状态并动态更新，是处理“全真/全假”条件的常用方法。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解枚举和验证的过程，我们设计了“像素侦探社”动画！让我们一起用8位风格“看”算法如何工作~
</visualization_intro>

  * **动画演示主题**：`像素侦探社：寻找真凶`

  * **核心演示内容**：展示枚举罪犯（如MIKE、CHARLES）和日期（周一到周日）的过程，用颜色标记证词的真伪（绿色=真话，红色=假话），并统计说假话的人数是否符合N。

  * **设计思路简述**：采用FC红白机风格，用像素方块表示人物（8x8像素头像）和日期（星期文字），证词用气泡框显示。关键步骤（如发现矛盾、确定假话人数）用音效和高亮提示，让学习者直观看到每一步的逻辑。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为左右两部分：左侧是角色栏（M个像素头像，下方标注名字），右侧是日期选择区（7个按钮，标有周一到周日）。
        - 底部是“控制面板”：单步/自动播放按钮、速度滑块、当前假设显示（如“假设罪犯：MIKE，今天：周日”）。

    2.  **枚举启动**：
        - 点击“开始枚举”，动画自动遍历每个罪犯和日期。例如，第一帧假设罪犯是MIKE，日期是周日。

    3.  **证词验证**：
        - 对于每个角色（如MIKE），依次显示他的证词气泡（如“我是罪犯”“今天是周日”）。
        - 用绿色/红色高亮气泡：绿色表示符合当前假设（真话），红色表示不符合（假话）。
        - 若同一角色的气泡既有绿又有红（矛盾），屏幕闪烁红色，播放“叮”的警报声，当前假设被标记为无效。

    4.  **统计假话人数**：
        - 底部进度条显示当前确定的假话人数（红色条）和不确定人数（黄色条），动态计算是否满足N的条件（如N=1时，红色条+黄色条需覆盖1）。

    5.  **结果反馈**：
        - 若找到唯一罪犯，该角色头像放大，背景播放“胜利”音效（如《超级玛丽》的通关音乐），显示“真凶是XXX！”。
        - 若多个假设符合，显示“Cannot Determine”，屏幕分屏展示不同假设。
        - 若无符合假设，显示“Impossible”，背景变暗。

  * **旁白提示**：
    - “现在假设MIKE是罪犯，今天是周日。”
    - “MIKE说‘我是罪犯’，这符合假设，标记为真话（绿色）。”
    - “MIKE又说‘今天是周日’，也符合，继续验证其他人的证词。”
    - “发现矛盾！CHARLES的证词中既有真话又有假话，当前假设无效。”

<visualization_conclusion>
通过这个动画，你可以直观看到枚举的每一步如何验证证词，理解“矛盾判断”和“假话人数统计”的核心逻辑。是不是比看代码更有趣？😉
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
“枚举+验证”的思路在编程题中很常见，掌握它能解决许多类似问题！
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 本题的枚举法适用于“可能解有限”的问题（如N小、状态少）。
    - 类似场景：八皇后问题（枚举皇后位置，验证是否冲突）、数独求解（枚举数字，验证规则）、逻辑推理题（枚举假设，验证条件）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1219 八皇后** - 经典枚举题，验证每行每列及对角线是否冲突。
    * 🗣️ **推荐理由**：练习枚举+验证的核心思路，理解如何剪枝优化。
    2.  **洛谷 P1098 字符串的展开** - 模拟字符串处理，需枚举展开规则。
    * 🗣️ **推荐理由**：提升字符串处理能力，练习条件判断的细致性。
    3.  **洛谷 P1119 灾后重建** - 枚举时间，动态规划验证最短路径。
    * 🗣️ **推荐理由**：结合枚举与动态规划，拓展算法应用场景。

---

## 7\. 学习心得与经验分享 

<insights_intro>
题解作者们分享了许多实战经验，这些能帮你避开常见坑点：
</insights_intro>

> **参考经验 (来自作者wjyyy)**：“处理输入时，一定要注意去掉多余的冒号、换行符和空格！我一开始没处理这些，导致证词解析错误，调试了很久。”
>
> **点评**：输入格式问题是编程题的常见坑点。建议在解析前输出处理后的字符串，确认是否正确（例如，用`cout`打印`content`）。这能快速定位输入错误。

> **参考经验 (来自作者Lovelace_qwq)**：“枚举时，一旦发现矛盾（如某人同时说真和假），立即跳过当前假设，能大大提升效率。”
>
> **点评**：提前终止无效假设是优化枚举的关键。在`check`函数中加入矛盾判断，能避免不必要的计算。

---

<conclusion>
这道“侦探推理”题的核心是“枚举+验证”，关键在于正确解析证词和高效判断矛盾。通过今天的分析，你已经掌握了核心思路和代码技巧。接下来，试试自己写代码，并挑战拓展练习吧！编程的乐趣，就在于一步步揭开问题的面纱~ 💪
</conclusion>

---
处理用时：199.60秒
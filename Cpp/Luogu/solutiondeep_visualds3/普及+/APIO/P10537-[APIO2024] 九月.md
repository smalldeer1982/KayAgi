# 题目信息

# [APIO2024] 九月

## 题目背景

## 请勿使用 C++14(GCC9) 提交

你无需在程序开头引入库 `september.h`。

## 题目描述

杭州市的中心广场有一棵著名的古树。这棵古树可以看作一棵 $N$ 个节点的有根树，节点编号从 $0$ 到 $N - 1$，其中 $0$ 号节点是根节点。

称没有孩子的节点为叶子节点。古树每次落叶时，会选择一个当前的叶子节点删去。每一天中，古树可能会多次落叶。

有 $M$ 位志愿者（编号从 $0$ 到 $M - 1$）负责看护古树。每一位志愿者将各自按照如下方式独立记录今年的落叶的情况：

每一天，收集所有新的落叶的编号（即当天删除的节点的编号），然后将它们按任意顺序写在先前的落叶编号之后。

例如：第一天，叶子 $3$ 和 $4$ 落下，于是他们写下 $3, 4$ 或 $4, 3$。第二天，叶子 $1$ 和 $2$ 落下，于是他们继续写下 $1, 2$ 或 $2, 1$。最终的记录可能为 $(3, 4, 1, 2)$，$(4, 3, 1, 2)$，$(3, 4, 2, 1)$ 或 $(4, 3, 2, 1)$ 中的任意一个。

这个过程持续了 $K$ 天，每天都有新的叶子掉落，直到只剩根节点为止。

你在旅途过程中经过了杭州。此刻已是寒冬，仰望古树光秃秃的枝干，你不禁想起落叶纷飞的美丽景象。

你很想知道今年有几天能看见落叶，但你只能找到 $M$ 位志愿者的记录。尝试根据这些记录推断出 $K$ 可能的最大值。

### 交互方式

你只需要实现以下函数：

```cpp
int solve(int N, int M, std::vector<int> F,
            std::vector<std::vector<int>> S);
```

+   $N$：古树的节点数量。
+   $M$：志愿者的数量。
+   $F$：一个长度为 $N$ 的数组。对于 $1 \le i \le N - 1$，$F[i]$ 表示节点 $i$ 的父亲节点的编号。$F[0]$ 始终为 $-1$。
+   $S$：一个长度为 $M$ 的数组。$S$ 中的每个元素是一个长度为 $N - 1$ 的数组。$S[i][j]$ 表示志愿者 $i$ 记录的第 $j$ 个节点编号（从 $0$ 开始）。
+   该函数必须返回一个整数，表示根据如上规则的 $K$ 可能的最大值（即，最大可能的落叶天数）。
+   对于每个测试点，交互库可能调用该函数多于一次。每次调用都应该作为新的情况分别处理。

注意：由于函数调用可能会发生多次，选手需要注意之前调用的残余数据对于后续调用的影响，尤其是全局变量的状态。

## 说明/提示

### 样例解释

对于样例一，考虑如下调用：

```cpp
solve(3, 1, {-1, 0, 0}, {{1, 2}});
```

对应的树如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/i2lup6cf.png)

叶子 $1$ 和 $2$ 可能在同一天落下，或者叶子 $1$ 在第一天先落下，然后叶子 $2$ 在第二天落下。落叶天数不超过 $2$。

因此，程序应当返回 $2$。

对于样例二，考虑如下调用：

```cpp
solve(5, 2, {-1, 0, 0, 1, 1}, {{1, 2, 3, 4}, {4, 1, 2, 3}});
```

对应的树如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/l50142xn.png)

假设至少有 $2$ 天落叶，根据志愿者的记录，叶子 $4$ 将在不同的日子（第一天和最后一天）落下，这是矛盾的。

因此，程序应当返回 $1$。

### 数据范围

+   $2 \le N \le 10^5$
+   $1 \le M \le 5$
+   $\sum NM \le 8 \times 10^5$
+   $F[0] = -1$ 且对于 $1 \le i \le N - 1$, $0 \le F[i] \le i - 1$
+   对于 $1 \le i \le M - 1$, 数组 $S[i]$ 是一个 $1, 2, \ldots , N - 1$ 的排列
+   保证 $F$ 描述的是一棵以节点 $0$ 为根的有根树

详细子任务附加限制及分值如下表所示。

| 子任务编号 | 附加限制 | 分值 |
| :---: | :---: | :---: |
| 1 | $M=1,N\le 10,\sum N\le 30$ | $11$ |
| 2 | $N\le 10,\sum N\le 30$ | $14$ |
| 3 | $M=1,N\le 1\,000,\sum N\le 2\,000,F[i]=i-1$ | $5$ |
| 4 | $M=1,N\le 1\,000,\sum N\le 2\,000$ | $9$ |
| 5 | $N\le 1\,000,\sum N\le 2\,000,F[i]=i-1$ | $5$ |
| 6 | $N\le 1\,000,\sum N\le 2\,000$ | $11$ |
| 7 | $M=1,F[i]=i-1$ | $9$ |
| 8 | $M=1$ | $11$ |
| 9 | $F[i]=i-1$ | $9$ |
| 10 | 没有额外的约束条件 | $16$ |

## 样例 #1

### 输入

```
1
3 1
0 0
1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
1
5 2
0 0 1 1 
1 2 3 4
4 1 2 3```

### 输出

```
1```

# AI分析结果


### 题目解读与核心算法识别
✨ **本题主要考察**：`树结构分析与序列处理`

🗣️ **初步分析**：
> 解决“九月”这道题，关键在于理解树结构的删除过程与序列约束的关系。想象一棵树每天掉落叶子，志愿者以任意顺序记录每天掉落的叶子，我们需要找到最大天数使得记录合理。核心思路是**逐位置扫描序列，同时验证两个条件**：  
>   - **集合一致性**：所有志愿者当前前缀记录的叶子集合必须相同  
>   - **可删除性**：删除的节点在对应时刻必须是叶子节点  
>  
> 算法流程：  
> 1. **初始化**：为每个志愿者维护独立的树结构（节点度数）  
> 2. **扫描序列**：对每个位置，更新全局节点计数和志愿者独立状态  
> 3. **条件验证**：当出现节点数=前缀长度（集合一致）且所有志愿者删除节点数=前缀长度（可删除）时，天数+1  
>  
> 可视化设计思路：  
> - **像素风格**：8位FC红白机风格，树显示为像素网格（根节点为城堡，叶子为可收集的宝石）  
> - **关键动画**：  
>   - 节点被标记时显示✨闪光特效  
>   - 节点删除时播放“叮”音效并消失  
>   - 父节点度数降为0时触发像素脉冲波向上传递  
> - **控制面板**：步进/自动播放（调速滑块）+ 当前状态显示（集合一致性/可删除性指示灯）

---

### 精选优质题解参考
**题解一（船酱魔王）**  
* **点评**：  
  思路清晰直击问题本质，提出**可减性**证明（若前缀[1,j]和[1,i]合法，则(j,i]也合法），将问题转化为寻找合法前缀断点。代码实现中：  
  - 用`rc[]`数组追踪每个志愿者已删除节点数  
  - 递归`upd()`函数优雅处理树结构更新  
  - 边界处理严谨（根节点特判）  
  亮点在于**双条件独立验证**：全局桶判集合相同 + 独立树结构维护删除顺序。时间复杂度O(NM)完美匹配数据范围。

**题解二（FFTotoro）**  
* **点评**：  
  创新性采用**cos哈希**防冲突判断集合相同（而非传统桶计数），为每个志愿者维护：  
  - 独立树结构`deg_local`和标记数组`vis`  
  - 递归删除函数实时更新树状态  
  代码规范性稍弱（嵌套lambda表达式），但**游戏化思维**突出：将节点删除类比为“宝石收集”，父节点更新视为“连锁反应”，生动体现算法核心。

**题解三（igAC）**  
* **点评**：  
  最简洁的实现之一，核心仅30行代码。亮点：  
  - **双数组策略**：`degM[][]`维护各志愿者独立度数  
  - **高效验证**：用`validCount[]`同步可删除节点数  
  - **哈希优化**：节点平方和快速验证集合一致性  
  虽未显式处理递归删除，但通过及时更新父节点度数达到同等效果，体现“少即是多”的编程哲学。

---

### 核心难点辨析与解题策略
1. **集合一致性验证**  
   * **分析**：必须保证所有志愿者当前前缀包含的节点集合完全相同。优质题解采用**全局计数桶**（船酱魔王）或**哈希摘要**（igAC），当不同节点数=前缀长度时满足条件。  
   * 💡 **学习笔记**：集合相同 ⟺ 出现过的节点数=前缀长度  

2. **树结构动态维护**  
   * **分析**：删除节点后需实时更新父节点度数，并递归检查祖先是否变为叶子。船酱魔王的`upd()`递归函数和FFTotoro的独立树结构都是典范解决方案。  
   * 💡 **学习笔记**：删除叶子 ⟶ 父节点度数-1 ⟶ 若度数为0则递归删除  

3. **多志愿者状态同步**  
   * **分析**：各志愿者记录独立但树结构共享，必须为每个志愿者维护单独的状态。igAC的`degM[][]`数组和船酱魔王的`rc[]`计数器实现高效同步。  
   * 💡 **学习笔记**：独立状态机是处理多序列的关键  

#### ✨ 解题技巧总结
- **问题分解**：将复杂条件拆解为独立可验证的子问题（集合验证+树删除）  
- **状态压缩**：用`vector<vector<>>`高效存储多志愿者状态  
- **递归思维**：树结构更新天然适合递归实现（注意终止条件）  
- **边界防御**：根节点（index=0）需特殊处理（无父节点）  

---

### C++核心代码实现赏析
**本题通用核心C++实现参考**  
* **说明**：综合船酱魔王和igAC的精华，优化递归边界处理  
* **完整核心代码**：
```cpp
#include <vector>
#include <functional>
using namespace std;

int solve(int N, int M, vector<int> F, vector<vector<int>> S) {
    vector<int> global_count(N, 0);         // 全局节点出现次数
    vector<vector<int>> deg_local(M, vector<int>(N, 0)); // 各志愿者树节点度数
    vector<vector<bool>> vis(M, vector<bool>(N, false)); // 节点标记状态
    vector<int> rc(M, 0);                  // 各志愿者已删除节点数
    int distinct_nodes = 0;                // 不同节点计数器
    int ans = 0;

    // 初始化度数
    for (int j = 0; j < M; j++) 
        for (int i = 1; i < N; i++) 
            deg_local[j][F[i]]++;

    // 递归更新函数
    function<void(int, int)> upd = [&](int j, int u) {
        if (u == 0) return;                // 根节点不删除
        if (vis[j][u] && deg_local[j][u] == 0) {
            rc[j]++;                       // 删除节点
            deg_local[j][F[u]]--;          // 父节点度数-1
            upd(j, F[u]);                  // 递归检查父节点
        }
    };

    for (int pos = 0; pos < N-1; pos++) {
        for (int j = 0; j < M; j++) {
            int node = S[j][pos];
            // 更新全局集合
            if (global_count[node]++ == 0) 
                distinct_nodes++;
            
            // 更新志愿者状态
            if (!vis[j][node]) {
                vis[j][node] = true;
                deg_local[j][F[node]]--;   // 首次出现时更新父节点度数
            }
            upd(j, node);                  // 尝试删除节点
        }
        
        // 验证双条件
        bool cond1 = (distinct_nodes == pos+1);
        bool cond2 = true;
        for (int j = 0; j < M; j++) 
            cond2 &= (rc[j] == pos+1);
        
        if (cond1 && cond2) ans++;
    }
    return ans;
}
```
* **代码解读概要**：  
  - **初始化**：复制树结构度数（行14-17）  
  - **核心循环**：双重循环遍历位置和志愿者（行24）  
  - **状态更新**：`global_count`跟踪集合变化，`upd`递归处理树结构（行27-38）  
  - **条件验证**：位置结束时检查集合相同且可删除（行41-46）  

**题解片段赏析**  
1. 船酱魔王（递归删除设计）  
   * **亮点**：优雅的递归链式反应  
   * **核心代码**：
```cpp
function<void(int, int)> upd = [&](int j, int u) {
    if (u == 0) return;
    if (vis[j][u] && deg_local[j][u] == 0) {
        rc[j]++;
        deg_local[j][F[u]]--;
        upd(j, F[u]);    // 递归触发父节点检查
    }
};
```
   * **代码解读**：  
     > 当节点`u`被标记且无子节点时：  
     > 1. 删除计数`rc[j]++`（节点消失动画触发点）  
     > 2. 父节点度数减1（若父节点变为叶子则递归）  
     > 3. 递归像多米诺骨牌传递至不能删除的祖先  
   * 💡 **学习笔记**：递归是处理树形更新的利器  

2. igAC（哈希验证集合）  
   * **亮点**：空间换时间的哈希策略  
   * **核心代码**：
```cpp
vector<pair<ll, ll>> hashes(M); // (线性哈希, 平方哈希)
for (int j=0; j<M; j++) {
    hashes[j].first += node;
    hashes[j].second += (ll)node * node;
}
bool same_set = (hashes[0] == hashes[1]); // 简化版
```
   * **代码解读**：  
     > 用`Σnode`和`Σnode²`构成哈希摘要：  
     > - 线性部分检测元素缺失  
     > - 平方部分检测元素重复  
     > 双哈希冲突概率极低  
   * 💡 **学习笔记**：哈希是快速验证集合的银弹  

---

### 算法可视化：像素动画演示
**主题**：*古树落叶收集大冒险*（8位像素风格）  

**核心演示流程**：  
1. **场景初始化**：  
   - 树显示为倒置像素树（根节点=城堡，叶子=彩色宝石）  
   - 控制面板：开始/步进/速度滑块（复古游戏按钮）  

2. **落叶过程**：  
   ```mermaid
   graph LR
   A[扫描位置i] --> B[显示当前节点闪烁]
   B --> C{是否首次出现?}
   C -->|是| D[播放“标记音效”]
   C -->|否| E[显示“重复警告”]
   D --> F[更新父节点度数]
   F --> G{度数=0?}
   G -->|是| H[触发像素脉冲波]
   G -->|否| I[显示当前度数]
   H --> J[删除节点+“收集音效”]
   ```

3. **条件验证特效**：  
   - **集合一致**：所有志愿者宝石袋发光+“和弦音”  
   - **可删除**：树抖动掉落灰尘粒子  
   - **天数增加**：屏幕顶部显示“DAY COMPLETE!”+ 分数+1  

**交互设计**：  
- **AI演示模式**：自动播放时添加“贪吃蛇AI”路径显示  
- **关键教学点**：  
  - 节点标记时显示`vis[j][node]=true`（像素标签）  
  - 度数变化时显示`deg_local[j][parent]--`（数字跳动）  
- **错误反馈**：条件不满足时播放“错误音效”+ 闪烁红灯  

**技术实现**：  
```javascript
// 伪代码：绘制树结构
function drawTree() {
  for(let node=0; node<N; node++) {
    const x = node % GRID_SIZE * 16;  // 像素坐标计算
    const y = Math.floor(node/GRID_SIZE) * 16;
    if(isLeaf(node)) 
      drawSprite("gem", x, y, COLOR[node]); // 绘制宝石
    else
      drawSprite("node", x, y); 
  }
}
```

---

### 拓展练习与相似问题思考
**通用技巧迁移**：  
- 树结构删除顺序验证 → 拓扑排序应用  
- 多序列一致性检查 → 哈希/桶计数模板  
- 递归更新树状态 → DFS遍历变种  

**洛谷推荐**：  
1. **P1040 加分二叉树**  
   🗣️ *巩固树结构遍历与递归设计，思考最优子结构*  
2. **P1087 FBI树**  
   🗣️ *练习树形结构验证与后序遍历，强化递归思维*  
3. **P3884 二叉树问题**  
   🗣️ *深入理解树结构更新与节点关系维护*  

---

### 学习心得与经验分享
> **参考经验**（船酱魔王）：  
> *“递归更新函数中，忘记处理根节点导致死循环，通过打印递归深度发现边界问题”*  
>  
> **点评**：递归必须明确终止条件，特别是树问题中根节点常需特判。建议：  
> 1. 写递归函数前先写`if(终止条件)`  
> 2. 复杂递归添加深度计数器防爆栈  
> 3. 树问题中根节点索引固定（通常为0）  

---

本次解析通过拆解双条件、可视化树删除过程，揭示了问题核心本质。记住：**树结构问题，递归与状态维护是关键！** 💪

---
处理用时：393.51秒
# 题目信息

# [NERC 2021] Interactive Treasure Hunt

## 题目描述

**这是一道交互题。**

有一个 $n \times m$ 的网格。两个宝箱被埋藏在网格的两个不同单元格中。你的任务是找到这两个宝箱。你可以进行两种操作：

1. **DIG** $r$ $c$：尝试在单元格 $(r, c)$ 挖掘宝藏。交互器会告诉你是否找到了宝藏。
2. **SCAN** $r$ $c$：从单元格 $(r, c)$ 进行扫描。该操作的结果是从 $(r, c)$ 到两个宝藏所在单元格的曼哈顿距离之和。曼哈顿距离的计算公式为 $|r_1 - r_2| + |c_1 - c_2|$。

你需要在最多 7 次操作内找到两个宝藏（包括 **DIG** 和 **SCAN** 操作）。为了通过测试，你必须在两个藏有宝藏的单元格中各调用至少一次 **DIG** 操作。

### 交互协议

你的程序需要在一轮运行中处理多个测试用例。首先，测试系统会给出 $t$ —— 测试用例的数量（$1 \le t \le 100$）。然后，依次处理 $t$ 个测试用例。

在每个测试用例中，你的程序首先需要读取两个整数 $n$ 和 $m$（$2 \le n, m \le 16$）。

然后，你的程序可以发起以下两种查询：

1. **DIG** $r$ $c$（$1 \le r \le n$；$1 \le c \le m$）。交互器会返回整数 $1$（如果找到了宝藏）或 $0$（如果未找到）。如果你多次在同一个单元格挖掘，由于宝藏已被取走，结果将始终为 $0$。
2. **SCAN** $r$ $c$（$1 \le r \le n$；$1 \le c \le m$）。交互器会返回一个整数，表示从 $(r, c)$ 到两个宝藏所在单元格的曼哈顿距离之和。即使你已经找到一个宝藏，该操作仍然会计算两个宝藏的距离之和。

当你找到两个宝藏（即通过 **DIG** 操作两次获得 $1$ 的响应）后，你的程序应继续处理下一个测试用例，或者如果是最后一个测试用例则退出。


## 说明/提示

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
1
2 3

1

1

3

0

1```

### 输出

```


SCAN 1 2

DIG 1 2

SCAN 2 2

DIG 1 1

DIG 1 3```

# AI分析结果


### Kay的C++算法解析：Interactive Treasure Hunt 深入学习指南

---

#### 1. 题目解读与核心算法识别  
✨ **本题主要考察**：`数学推导` + `交互策略`  

🗣️ **初步分析**：  
> 解决这道寻宝题就像玩一场**像素地牢探险游戏**🔍：我们用数学公式推导宝藏坐标，通过智能交互减少探测次数。核心是通过**曼哈顿距离方程组**消除坐标绝对值：  
> - 先用两次边界`SCAN`建立坐标和方程（如(1,1)和(1,m)）  
> - 再用两次中心`SCAN`解出具体坐标（如中点扫描）  
> - 最后用`DIG`验证（类似游戏中的"铲子点击"）  
>  
> **可视化设计**：在8-bit网格中高亮扫描点，用不同颜色像素块表示距离计算过程。当玩家点击"SCAN"时，宝藏位置会闪烁虚线路径，并弹出距离公式（复古RPG对话框风格）。"AI自动演示"模式会像经典游戏《淘金者》一样逐步展示推理过程。

---

#### 2. 精选优质题解参考  
**题解（作者：_O_v_O_）**  
* **点评**：  
  思路如侦探破案般清晰——通过四个方程锁定宝藏坐标：  
  1. **数学严谨性**⭐️⭐️⭐️⭐️⭐️：从曼哈顿距离提炼出`sumx=(a+b)/2+3-m`等关键变量，推导无懈可击  
  2. **交互策略优化**⭐️⭐️⭐️⭐️：仅用4次SCAN+2次DIG（低于7次上限）  
  3. **代码防御性**⭐️⭐️⭐️：用`x1<=x2, y1<=y2`假设简化逻辑，DIG失败时自动交换坐标验证  
  4. **实践价值**⭐️⭐️⭐️⭐️：直接可用于竞赛，变量命名`sumx/sumy`直观体现数学本质  

---

#### 3. 核心难点辨析与解题策略  
1. **难点1：消除曼哈顿距离的绝对值**  
   * **分析**：通过选择特殊扫描点(1,1)和(1,m)，将距离公式转化为线性方程组（见题解方程），使`|r1-r2|`等绝对值消失  
   * 💡 **学习笔记**：边界点是消除绝对值的"钥匙"  

2. **难点2：从坐标和到具体值**  
   * **分析**：获取`x1+x2`后，需扫描中点`(1,sumy/2)`解出`x2-x1`（类似二分思想）  
   * 💡 **学习笔记**：中点扫描是坐标分离的"桥梁"  

3. **难点3：处理对称坐标的歧义**  
   * **分析**：假设`x1<=x2`可能错误，首次DIG失败时需交换`y`坐标重试（见代码最后分支）  
   * 💡 **学习笔记**：交互题中操作结果可修正假设  

✨ **解题技巧总结**  
- **方程构建术**：用2个边界扫描建立基础方程，2个中点扫描解变量差  
- **对称破缺法**：DIG验证时采用"先纵后横"的坐标交换策略  
- **交互经济学**：优先SCAN获取全局信息，DIG仅用于最终验证  

---

#### 4. C++核心代码实现赏析  
**通用核心实现参考**  
```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
    int T; cin >> T;
    while (T--) {
        int n, m; cin >> n >> m;
        // 边界扫描建立方程
        cout << "SCAN 1 1" << endl; int a; cin >> a;
        cout << "SCAN 1 " << m << endl; int b; cin >> b;
        int sumx = (a + b) / 2 + 3 - m;  // 宝藏横坐标和
        int sumy = (a - b) / 2 + 1 + m;  // 宝藏纵坐标和

        // 中点扫描解具体坐标
        cout << "SCAN 1 " << sumy/2 << endl; int c; cin >> c;
        c += 2 - sumx;  // 计算y坐标差
        cout << "SCAN " << sumx/2 << " 1" << endl; int d; cin >> d;
        d += 2 - sumy;  // 计算x坐标差

        // 解方程并验证
        int x1 = (d + sumx) / 2, x2 = sumx - x1;
        int y1 = (c + sumy) / 2, y2 = sumy - y1;
        cout << "DIG " << x1 << " " << y1 << endl;
        int res; cin >> res;
        if (!res) { // 处理坐标对称歧义
            cout << "DIG " << x1 << " " << y2 << endl; cin >> res;
            cout << "DIG " << x2 << " " << y1 << endl; cin >> res;
        } else {
            cout << "DIG " << x2 << " " << y2 << endl; cin >> res;
        }
    }
    return 0;
}
```

**代码解读概要**：  
> 1. **边界扫描阶段**：通过(1,1)和(1,m)的SCAN获取距离和`a,b`，推导出宝藏坐标和`sumx/sumy`  
> 2. **中点扫描阶段**：在`(1,sumy/2)`和`(sumx/2,1)`二次扫描解出坐标差  
> 3. **验证阶段**：DIG首个坐标失败时，交换纵坐标二次尝试  

---

#### 5. 算法可视化：像素动画演示  
* **主题**：8-bit寻宝游戏《曼哈顿侦探》  
* **核心演示**：  
  ![示意图](https://via.placeholder.com/400x200/000000/FFFFFF?text=8-bit+网格动画)  
  **关键帧流程**：  
  1. **初始化**：16x16像素网格，宝藏用❓标记，扫描点用🔍图标  
  2. **边界扫描**：  
     - 点击(1,1)时：显示红色虚线路径到两个宝藏，弹出公式 `a = |x1-1|+|y1-1|+|x2-1|+|y2-1|`  
     - 音效：扫描声"哔-哔"  
  3. **中点扫描**：  
     - 点击(1,sumy/2)时：宝藏间显示黄色连接线，高亮y坐标差  
     - 实时更新侧边栏方程：`c = (x1-1)+(x2-1)+|y1-y2|`  
  4. **DIG验证**：  
     - 成功时：宝藏变为💎，播放"叮！"音效+金币动画  
     - 失败时：地面出现❌，播放"噗"音效  

* **交互控制面板**：  
  ```plaintext
  [▶️ 自动演示] [⏸️ 暂停] [⏭️ 单步] 速度：🐢-----🐇
  ```

---

#### 6. 拓展练习与相似问题  
* **通用技巧迁移**：  
  1. **位置推断**：通过部分距离反推坐标（如WIFI定位）  
  2. **交互优化**：在操作受限场景用数学减少尝试次数  
  3. **对称处理**：当问题存在多解时的验证策略  

* **洛谷推荐**：  
  1. [P1649] 障碍路线规划  
     → 同需曼哈顿距离计算和位置推导  
  2. [P1379] 八数码难题  
     → 强化状态空间中的交互式搜索思维  
  3. [P1514] 引水入城  
     → 相似的多点定位和验证机制  

---

> 通过这场像素寻宝之旅，我们学会用数学武器破解交互谜题！下次探险时，记得先画方程地图再挥铲哦~ 🎮✨

---
处理用时：111.08秒
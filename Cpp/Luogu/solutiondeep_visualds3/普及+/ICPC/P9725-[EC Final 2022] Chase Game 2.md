# 题目信息

# [EC Final 2022] Chase Game 2

## 题目描述

庞教授和寿教授喜欢玩追逐游戏。

游戏地图由 $n$ 个房间和 $n-1$ 条双向通道组成。游戏地图是连通的。这意味着地图形成一棵树。

一开始，庞教授在房间 $u$，而寿教授在房间 $v$（$u\neq v$）。庞教授和寿教授轮流玩游戏，寿教授先开始。在自己的回合中，玩家知道自己所在的位置和另一个玩家的位置，可以决定留在当前房间或者移动到与当前房间直接通过通道相连的另一个房间。当庞教授和寿教授在同一个房间时，寿教授被庞教授抓住。

庞教授和寿教授足够聪明。庞教授希望在有限的回合内抓住寿教授。寿教授不希望在任何有限的回合内被庞教授抓住。

寿教授厌倦了每次都被抓住，找到了费教授寻求帮助。寿教授请求费教授添加一些通道，使得无论初始房间对 $(u,v)$ 如何，庞教授都无法在有限的回合内抓住他。费教授很懒，所以他希望尽可能少地添加通道。如果无论如何添加通道，总是存在一对房间 $(u,v)$，使得庞教授能够抓住寿教授，输出 $-1$。

## 样例 #1

### 输入

```
4
2
1 2
4
1 2
2 3
3 4
4
1 2
2 3
2 4
5
1 2
2 3
3 4
3 5
```

### 输出

```
-1
1
-1
2
```

# AI分析结果


### 💡 Kay的C++算法解析：Chase Game 2 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：图论（树的性质与贪心策略）  
🗣️ **初步分析**：  
> 这道题的核心是**将树转化为安全网络**。想象一棵树是城市道路网，叶子节点（度数为1的节点）是死胡同。逃跑者（B）需要环形高架路（大小≥4的环）才能永远躲避追逐者（A）。  
> - **核心策略**：用最少的新边连接叶子节点，使所有叶子进入大小≥4的环，同时避免形成三元环（易被捕获）。  
> - **关键公式**：最小加边数 = max(⌈叶子数/2⌉, 最大单节点相邻叶子数)  
> - **可视化设计**：像素动画将展示叶子节点（绿色方块）如何通过黄色闪烁的新边形成蓝色环形路径。逃跑者（蓝色像素）在环中循环移动躲避追逐者（红色像素），当新边连接时播放“叮”音效，形成环时播放胜利音效。  

---

#### 2. 精选优质题解参考
**题解一（HFanGDoDM）**  
* **点评**：  
  思路严谨，证明了环大小必须≥4（三元环无效），并推导出核心公式。代码规范：  
  - 用`deg[]`统计度数，`num1[]`记录相邻叶子数  
  - 高效判断菊花图（存在`deg[i]=n-1`）  
  - 边界处理完整，直接用于竞赛  
  **亮点**：将问题抽象为"叶子覆盖+避免三元环"，数学证明清晰  

**题解二（Fgighkcgrfox）**  
* **点评**：  
  语言通俗易懂，比喻生动（"秦王绕柱跑"）。代码亮点：  
  - 用`tj[]`统计父节点的叶子数  
  - 强调⌈叶子数/2⌉需**向上取整**（作者因未取整罚时）  
  - 注释提醒多测清空  
  **亮点**：用图示解释三元环陷阱，适合初学者理解  

**题解三（ycy1124）**  
* **点评**：  
  代码简洁高效：  
  - 用`vector`存储邻接表  
  - 边读边统计叶子和相邻叶子数  
  - 无冗余操作  
  **亮点**：提出"所有节点需在≥4环中"的统一处理视角  

---

#### 3. 核心难点辨析与解题策略
1. **难点1：识别无解情况（菊花图）**  
   * **分析**：菊花图中所有叶子共享父节点，新边只能形成三元环（仍会被抓）。  
   * 💡 **学习笔记**：存在`deg[i]=n-1`时输出`-1`  

2. **难点2：最小化加边数**  
   * **分析**：理想情况是叶子两两配对（⌈叶子数/2⌉条边），但若某节点有`k`个相邻叶子，需额外`k`条边分散连接（避免三元环）。  
   * 💡 **学习笔记**：贪心策略需同时考虑全局配对和局部约束  

3. **难点3：避免三元环陷阱**  
   * **分析**：同父叶子互连会形成三元环，此时无论B如何移动都会被抓住。  
   * 💡 **学习笔记**：新边必须跨父节点连接  

### ✨ 解题技巧总结
- **技巧1：问题分解**  
  拆解为叶子覆盖 + 三元环规避  
- **技巧2：关键指标统计**  
  同步计算`叶子数`和`各节点相邻叶子数`  
- **技巧3：边界处理**  
  `n≤3`时直接判无解  

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
* **说明**：综合题解思路，包含菊花图判断和核心公式  
```cpp
#include <iostream>
#include <vector>
using namespace std;

void solve() {
    int n; cin >> n;
    vector<int> deg(n+1), num1(n+1);
    vector<pair<int,int>> edges;

    // 读边并统计度数
    for(int i=1; i<n; i++) {
        int u, v; cin >> u >> v;
        deg[u]++; deg[v]++;
        edges.push_back({u, v});
    }

    // 统计各节点相邻的叶子数
    for(auto &e : edges) {
        if(deg[e.first] == 1) num1[e.second]++;
        if(deg[e.second] == 1) num1[e.first]++;
    }

    // 判断菊花图
    for(int i=1; i<=n; i++) {
        if(deg[i] == n-1) {
            cout << -1 << endl;
            return;
        }
    }

    // 计算叶子总数
    int leaf_cnt = 0;
    for(int i=1; i<=n; i++) 
        if(deg[i] == 1) leaf_cnt++;

    // 核心公式
    int ans = max((leaf_cnt + 1) / 2, *max_element(num1.begin(), num1.end()));
    cout << ans << endl;
}
```

**题解一片段赏析**  
* **亮点**：高效度数和相邻叶子统计  
* **核心代码**：  
```cpp
for(int i=0; i<n-1; i++) {
    if(deg[edges[i].first] == 1) 
        num1[edges[i].second]++;
    if(deg[edges[i].second] == 1) 
        num1[edges[i].first]++;
}
```  
* **代码解读**：  
  > 遍历每条边时，检查端点是否为叶子（`deg=1`）。若是，则另一端点的`num1`值增加，记录其相邻叶子数。  
  > **关键点**：双向检查（`first`和`second`），避免遗漏  
* 💡 **学习笔记**：用边遍历统计可避免重复访问  

---

#### 5. 算法可视化：像素动画演示  
**主题**：像素迷宫逃生（8-bit风格）  
**核心演示**：叶子节点连接成安全环的过程  
**设计思路**：  
1. **初始化**：树显示为绿色像素网格，叶子（★）闪烁绿色  
2. **添加边**：  
   - 黄线连接两个叶子时播放"叮"声  
   - 形成≥4环时变蓝环，播放胜利音效  
3. **追逐演示**：  
   - 红点（A）追蓝点（B）  
   - B进入环后沿环移动，始终与A保持距离  
4. **交互控制**：  
   - 速度滑块：调节动画步进速度  
   - AI模式：自动演示B的逃生路径  
5. **失败场景**：  
   - 若B进入三元环，红点抓住蓝点，播放失败音效  

---

#### 6. 拓展练习与相似问题思考
1. **洛谷 P1352 没有上司的舞会**  
   🗣️ 巩固树形DP，理解状态转移  
2. **洛谷 P2661 信息传递**  
   🗣️ 学习最小环检测，强化环性质理解  
3. **洛谷 P3385 负环**  
   🗣️ 掌握SPFA判环，拓展环问题应用  

---

#### 7. 学习心得与经验分享
> **经验分享**（来自题解二）：  
> "考试时因未对⌈叶子数/2⌉向上取整（写`leaf_cnt/2`而非`(leaf_cnt+1)/2`）导致罚时"  
>   
> **Kay点评**：  
> 向上取整是离散数学常见操作，记住`(n+1)/2`可避免此坑。建议编写时显式注释计算逻辑！

---  
**本次解析结束**！通过树结构转化为安全网络，我们深入理解了贪心策略在图论中的应用。动手实现时注意叶子统计和边界处理，下次遇到类似问题就能举一反三啦！💪

---
处理用时：107.09秒
# 题目信息

# 【模板】KMP

## 题目描述

给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。  
现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。

定义一个字符串 $s$ 的 border 为 $s$ 的一个**非 $s$ 本身**的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。  
对于 $s_2$，你还需要求出对于其每个前缀 $s'$ 的最长 border $t'$ 的长度。

## 说明/提示

### 样例 1 解释

 ![](https://cdn.luogu.com.cn/upload/pic/2257.png)。
 
对于 $s_2$ 长度为 $3$ 的前缀 `ABA`，字符串 `A` 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为 $1$。


### 数据规模与约定

**本题采用多测试点捆绑测试，共有 3 个子任务**。

- Subtask 1（30 points）：$|s_1| \leq 15$，$|s_2| \leq 5$。
- Subtask 2（40 points）：$|s_1| \leq 10^4$，$|s_2| \leq 10^2$。
- Subtask 3（30 points）：无特殊约定。

对于全部的测试点，保证 $1 \leq |s_1|,|s_2| \leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。

## 样例 #1

### 输入

```
ABABABC
ABA
```

### 输出

```
1
3
0 0 1 
```

# AI分析结果


💡 Kay的C++算法解析：KMP字符串匹配 深入学习指南 💡  

<introduction>  
大家好，我是Kay！今天我们来一起探索经典字符串匹配算法——KMP。这道题看似简单，却蕴含着精妙的算法思想。本指南将带你从暴力匹配的局限出发，逐步拆解KMP的核心逻辑，并通过像素动画直观演示匹配过程。准备好了吗？让我们开始这场算法探险！  
</introduction>  

---

## 1. 题目解读与核心算法识别  

✨ **本题主要考察**：`字符串匹配算法` (KMP算法应用)  

🗣️ **初步分析**：  
> KMP算法就像聪明的文字侦探：当发现不匹配字符时，它不会傻傻地从头再来（如暴力匹配），而是利用预计算的"线索"（next数组）直接跳到下一个可能匹配的位置。想象你在迷宫中寻找宝藏，每次遇到死路不是返回起点，而是根据地图直接传送到新岔路口——这就是KMP的高明之处！  

- **核心难点**：  
  1. next数组的抽象概念（最长公共前后缀）  
  2. 匹配失败时的指针跳转逻辑  
  3. 边界条件处理（如首位失配）  
- **算法可视化设计**：  
  在像素动画中，我们将用**蓝色高亮**当前比较的字符，**红色闪烁**表示失配位置，**绿色流动箭头**展示next跳转路径。当匹配成功时，整个模式串会变成金色并触发胜利音效！  
- **复古游戏化设计**：  
  采用8-bit像素风格，主串为砖块迷宫，模式串是探险家角色。匹配过程化为闯关：每步移动伴随电子音效，通关时播放经典FC胜利旋律。控制面板支持调速观察算法细节。  

---

## 2. 精选优质题解参考  

**题解一（皎月半洒花）**  
* **点评**：  
  这份题解如同精心绘制的算法地图！从暴力匹配引入KMP的改进动机，用"部分匹配表"比喻next数组，逻辑推导如侦探破案般层层递进。代码中`kmp`数组命名明确，边界处理严谨（`j=kmp[j]`防越界）。亮点在于复杂度证明——用指针移动次数直观解释O(n+m)时间，如同计算探险家的步数优化路径。  

**题解二（frostime）**  
* **点评**：  
  作者像算法工程师般剖析KMP。创新性地提出"虚拟通配哨兵"概念解决首位匹配问题，代码模块化（分离next构建与匹配函数）增强可读性。最大亮点是next数组优化：当连续字符出现时，直接跳转避免冗余比较，如同在相同地形中启用传送门加速。  

**题解三（chu_yh）**  
* **点评**：  
  极简主义的典范！仅30行代码实现核心功能，变量`j`的控制如同精准的指针仪表盘。特别适合竞赛场景——作者提到"理解next数组后代码自然简洁"，这种化繁为简的能力正是算法高手的内功。  

---

## 3. 核心难点辨析与解题策略  

1. **难点：next数组的构建逻辑**  
   * **分析**：  
     next[i]实质是模式串自我匹配的过程。好比用印章的左侧图案去匹配右侧图案，寻找最大重合部分。优质题解都采用双指针法：`j`代表已知匹配长度，`i`探索新字符。  
   * 💡 **学习笔记**：`while(j&&s2[i]!=s2[j+1])j=kmp[j]` 本质是递归思想——用已计算的next值推导新值  

2. **难点：匹配过程的指针跳转**  
   * **分析**：  
     当`ABA`匹配成功却在`C`失配时，暴力做法回退2步，KMP则通过next[3]=1跳到`B`继续。如同玩跳棋时遇到障碍，直接跳到预设的弹簧垫位置。  
   * 💡 **学习笔记**：跳转后主串指针`i`永不回溯是O(n)复杂度的关键保障  

3. **难点：边界条件处理**  
   * **分析**：  
     首位匹配失败时（j=0），需特殊处理防止死循环。优质题解用`j>0`判断或虚拟哨兵(`next[0]=-1`)破解此局。  
   * 💡 **学习笔记**：代码`if(b[j+1]==a[i])j++`中`j+1`的写法避免了下标越位风险  

### ✨ 解题技巧总结  
- **技巧A（问题分解）**：将KMP拆解为独立的next构建与匹配两个阶段  
- **技巧B（模拟推演）**：手工计算`ABAAB`的next数组(0,0,1,1,2)加深理解  
- **技巧C（调试利器）**：输出next数组中间值验证逻辑，如`cout<<"i="<<i<<" j="<<j<<endl;`  

---

## 4. C++核心代码实现赏析  

**通用核心实现**  
```cpp
#include <cstring>
#include <iostream>
using namespace std;
const int N = 1e6 + 5;

int main() {
    char a[N], b[N];
    int kmp[N]; // next数组
    scanf("%s%s", a + 1, b + 1);
    int la = strlen(a + 1), lb = strlen(b + 1);
    
    // 构建next数组
    int j = 0;
    for (int i = 2; i <= lb; ++i) {
        while (j > 0 && b[i] != b[j + 1]) j = kmp[j]; // 关键跳转
        if (b[i] == b[j + 1]) ++j;
        kmp[i] = (i < lb && b[i + 1] == b[j + 1]) ? kmp[j] : j; // 优化点
    }
    
    // 匹配主串
    j = 0;
    for (int i = 1; i <= la; ++i) {
        while (j > 0 && b[j + 1] != a[i]) j = kmp[j];
        if (b[j + 1] == a[i]) ++j;
        if (j == lb) {
            printf("%d\n", i - lb + 1);
            j = kmp[j]; // 继续寻找新匹配
        }
    }
    for (int i = 1; i <= lb; ++i) printf("%d ", kmp[i]);
}
```
* **代码解读概要**：  
  - **输入处理**：`a+1`使字符串从索引1开始，避免-1判断  
  - **next构建**：双指针遍历模式串，`while`处理失配回退，`if`处理匹配前进  
  - **匹配阶段**：主串指针`i`单向移动，`j`据next数组智能跳转  
  - **输出优化**：匹配位置计算`i-lb+1`符合题目从1开始的要求  

---

**题解一（皎月半洒花）片段**  
```cpp
// next构建核心
for (int i = 2; i <= lb; i++) {
    while (j && b[i] != b[j + 1]) j = kmp[j];
    if (b[i] == b[j + 1]) j++;
    kmp[i] = j; // 记录最长匹配长度
}
```
* **亮点**：用最简形式揭示next本质  
* **学习笔记**：`j=kmp[j]`如同递归查询"匹配中的匹配"，是算法精髓  

**题解二（frostime）优化片段**  
```cpp
// 防冗余跳转优化
if (b[i + 1] == b[j + 1]) 
    kmp[i] = kmp[j];  
else 
    kmp[i] = j;
```
* **亮点**：预测下一个字符相同则提前跳转  
* **学习笔记**：类似记忆化搜索，对`AAA...`型串效果显著  

---

## 5. 算法可视化：像素动画演示  

<visualization_intro>  
**主题**：像素探险家寻宝记  
**核心演示**：next数组构建与匹配跳转的实时可视化  
**设计理念**：8-bit复古风降低理解门槛，游戏机制强化学习动机  

### 动画流程（关键帧示意）  
1. **初始化场景**  
   - 16色像素网格：上方蓝色砖块（主串），下方绿色砖块（模式串）  
   - 控制面板：开始/暂停/步进按钮，速度滑块（0.5x~4x）  

2. **构建next数组**（自匹配阶段）  
   ```plaintext
   模式串: A B A B C
   i指针: [2]→→→→ 
   j指针: [0]→→→→
   ```  
   - 动态效果：`i`(蓝色)与`j`(绿色)同步右移，匹配成功时砖块闪烁金色  
   - 音效：每次比较触发"嘀"声，更新next时播放"咔嚓"声  

3. **主串匹配**（核心演示）  
   ```plaintext
   主串: A B A B A B C 
   模式: A B A B C
            ↑ 失配!
   next跳转: [j=4]→[j=2]
   ```  
   - 失配特效：红色闪烁 + 短促警告音  
   - 跳移动画：模式串向右滑动，绿色箭头标注跳转距离  
   - 胜利时刻：全匹配时模式串变金块，播放《超级玛丽》过关旋律  

4. **游戏化扩展**  
   - 进度条：将算法步骤分为10个小关卡  
   - 积分系统：连续匹配成功+10分，高效跳转+5分  
   - 彩蛋：完成所有关卡解锁"KMP大师"像素勋章  

</visualization_intro>  

---

## 6. 拓展练习与相似问题思考  

**通用技巧迁移**：  
KMP的next思想可延伸至：  
1. 循环节检测（`len % (len - next[len]) == 0`）  
2. 最小覆盖子串（通过next找最短周期）  
3. 回文匹配（反转字符串应用KMP）  

**洛谷推荐**：  
1. [P3435 OKR-Periods](https://www.luogu.com.cn/problem/P3435)  
   🗣️ *用next数组求最大周期，深化border理解*  
2. [P2375 动物园](https://www.luogu.com.cn/problem/P2375)  
   🗣️ *next数组变形，训练不重叠匹配思维*  
3. [P3193 GT考试](https://www.luogu.com.cn/problem/P3193)  
   🗣️ *KMP与DP结合，挑战字符串综合应用*  

---

## 7. 学习心得与经验分享  

> **来自皎月半洒花的调试经验**：  
> *"我在实现时曾被边界条件困扰，后来发现打印`i,j,next[j]`三元组后立即定位了越界错误"*  
> **Kay点评**：这是黄金调试法则！在循环内添加`printf("i=%d j=%d next=%d\n",i,j,kmp[j])`，数据会自己"说话"  

> **来自frostime的优化心得**：  
> *"处理`AAAA`这类串时，原始KMP像陷入沼泽，优化跳转就像扔出救命绳索"*  
> **Kay点评**：算法优化本质是空间换时间的艺术，但竞赛中需权衡代码复杂度  

---

<conclusion>  
KMP算法如同精巧的机械手表——初看复杂，拆解后每个齿轮都各司其职。记住：指针`i`的单向移动是驱动核心，next数组是精准的导航仪。多动手模拟小数据案例（尝试手工计算`ABABC`的匹配过程），你会在某个瞬间豁然开朗！下次我们将探索更强大的AC自动机，继续算法之旅吧！  
</conclusion>

---
处理用时：208.40秒
# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果

---
# 💡 Kay的C++算法解析：最优贸易 深入学习指南 💡

<introduction>
  今天我们来一起分析NOIP2009提高组的经典题目《最优贸易》。这道题是图论中**分层图技巧**和**状态建模**的典型应用，需要我们将“买入-卖出”的交易逻辑转化为图的层次结构，最终通过最短路径算法求解最大收益。本指南会帮你梳理思路、掌握核心算法，并通过像素动画直观理解过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（分层图技巧/强连通分量处理）

🗣️ **初步分析**：
解决《最优贸易》的关键，是把“商人的交易状态”转化为**分层图**的结构。简单来说，分层图就是把原图复制成多份（称为“层”），每层代表一个状态，层间的边代表状态转移。比如：
- **第一层**：商人还没买水晶球（初始状态）；
- **第二层**：商人已经买了水晶球（等待卖出）；
- **第三层**：商人已经卖出水晶球（完成交易）。

在本题中，分层图的作用是**约束交易次数**（最多一次）：
- 层内的边权为0（移动不影响收益）；
- 从第一层到第二层的边权为`-价格`（买入花费）；
- 从第二层到第三层的边权为`+价格`（卖出收益）。

我们的目标是求**从第一层的1号节点到第三层的n号节点的最长路**——这就是最大可能的收益（因为最长路对应“花最少的钱买，卖最多的钱”）。

### 核心算法流程与可视化设计
- **算法流程**：构建三层图→用SPFA求最长路（因存在负权边，无法用Dijkstra）；
- **可视化思路**：用8位像素风格展示三层图（第一层蓝、第二层绿、第三层红），节点是带编号的像素方块，边是彩色线条。操作时：
  - 移动：同层节点间闪烁边，节点跟随移动；
  - 买入：节点从第一层“跳”到第二层，伴随“叮”的音效，显示“买入-3”（比如价格3）；
  - 卖出：节点从第二层“跳”到第三层，伴随“叮铃”音效，显示“卖出+5”；
  - 到达终点：第三层n节点高亮，播放胜利音效，显示最终收益。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度，筛选了3份高质量题解，覆盖了最主流的解法：
</eval_intro>

### 题解一：分层图+SPFA（作者：fy1234567ok，赞512）
* **点评**：这份题解的**分层图建模堪称经典**！作者用`t(x,i)`（第i层的x节点）简洁表示分层节点，通过层内边（移动）和层间边（交易）构建完整图。代码仅40行，逻辑清晰——SPFA求最长路时，初始值设为`INT_MIN`（最小整数），确保能正确更新最大收益。特别值得学习的是**状态转移的严谨性**：层间边只能从低到高（第一层→第二层→第三层），避免重复交易。

### 题解二：双SPFA（正反图求最值）（作者：Ngo123，赞8）
* **点评**：这是一种**更高效的贪心解法**！作者的思路是：
  1. 用SPFA从1号节点出发，求到每个节点的**最小买入价**（`minv[i]`）；
  2. 建反图，用SPFA从n号节点出发，求到每个节点的**最大卖出价**（`maxv[i]`）；
  3. 枚举所有节点，计算`maxv[i]-minv[i]`的最大值。
  
  这种方法避免了分层图的复杂建模，直接抓住“低买高卖”的核心，代码简洁且效率更高（SPFA的常数更小）。

### 题解三：Tarjan缩点+DAG DP（作者：ctzm，赞20）
* **点评**：这份题解针对**有环图**的情况（比如城市间可以绕圈），用Tarjan算法将强连通分量（SCC）缩成一个点，转化为DAG（有向无环图）。缩点后，每个SCC的`minw`（最小买入价）和`maxw`（最大卖出价）可以贪心得到，再用拓扑排序DP求每个节点的最大收益。这种方法解决了环带来的“重复计算”问题，适合处理大规模有环图。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是**将交易逻辑转化为图结构**，以下是三个核心难点及解决策略：
</difficulty_intro>

### 1. 如何约束“最多一次交易”？
- **难点**：直接枚举买入卖出点会超时（n=1e5），且无法保证路径连通。
- **解决策略**：用**分层图**将状态分层（未买→已买→已卖），层间边只能单向转移，确保交易次数不超过一次。

### 2. 如何处理图中的环？
- **难点**：环会导致“无限绕圈”，无法直接用DP（有后效性）。
- **解决策略**：用**Tarjan缩点**将环缩成一个点，转化为DAG。缩点后每个SCC的`minw`和`maxw`可以贪心取到，再用拓扑排序DP。

### 3. 如何高效计算“路径中的最小买入/最大卖出”？
- **难点**：直接BFS/DFS无法记录路径中的最值。
- **解决策略**：用**双SPFA**：
  - 正图SPFA求从1到每个节点的最小买入价；
  - 反图SPFA求从n到每个节点的最大卖出价。

### ✨ 解题技巧总结
- **状态建模**：将“交易状态”转化为图的层次，是解决这类“操作次数约束”问题的通用技巧；
- **贪心优化**：对于“低买高卖”问题，直接求路径中的最值往往比枚举更高效；
- **环处理**：强连通分量缩点是处理有环图的“万能钥匙”，转化为DAG后可以用DP或拓扑排序。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**分层图+SPFA**的通用实现，它是题解一的简化版，覆盖了核心逻辑：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合题解一的思路，用简洁的方式实现分层图建边和SPFA求最长路。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

const int MAXN = 1e5 + 5;
int n, m, price[MAXN];
vector<pair<int, int>> G[MAXN * 3]; // 三层图：1~n（层0）、n+1~2n（层1）、2n+1~3n（层2）
int dist[MAXN * 3];
bool inq[MAXN * 3];

// 层i的节点x：层0→x，层1→x+n，层2→x+2n
inline int get_node(int x, int layer) { return x + layer * n; }

void SPFA() {
    fill(dist, dist + 3 * n + 1, INT_MIN);
    queue<int> q;
    int start = get_node(1, 0);
    dist[start] = 0;
    q.push(start);
    inq[start] = true;

    while (!q.empty()) {
        int u = q.front(); q.pop();
        inq[u] = false;
        for (auto &edge : G[u]) {
            int v = edge.first, w = edge.second;
            if (dist[v] < dist[u] + w) {
                dist[v] = dist[u] + w;
                if (!inq[v]) {
                    q.push(v);
                    inq[v] = true;
                }
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        cin >> price[i];
        // 层0→层1：买入，边权-price[i]
        G[get_node(i, 0)].emplace_back(get_node(i, 1), -price[i]);
        // 层1→层2：卖出，边权+price[i]
        G[get_node(i, 1)].emplace_back(get_node(i, 2), price[i]);
    }
    for (int i = 0; i < m; ++i) {
        int x, y, z;
        cin >> x >> y >> z;
        // 层内边：移动，边权0
        for (int layer = 0; layer < 3; ++layer) {
            G[get_node(x, layer)].emplace_back(get_node(y, layer), 0);
            if (z == 2) // 双向边
                G[get_node(y, layer)].emplace_back(get_node(x, layer), 0);
        }
    }
    SPFA();
    cout << dist[get_node(n, 2)] << endl;
    return 0;
}
```
* **代码解读概要**：
  - 用`get_node(x, layer)`生成分层节点（层0→x，层1→x+n，层2→x+2n）；
  - 层间边：层0→层1（买入，负价格）、层1→层2（卖出，正价格）；
  - 层内边：根据道路类型（单向/双向）建边，边权0；
  - SPFA求最长路：初始值设为`INT_MIN`，从层0的1号节点出发，最终结果是层2的n号节点的`dist`值。


<code_intro_selected>
接下来看**双SPFA**和**Tarjan缩点**的核心代码片段：
</code_intro_selected>

### 题解二：双SPFA（核心片段）
* **亮点**：用正反图分别求最小买入和最大卖出，思路直接。
* **核心代码片段**：
```cpp
// 正图SPFA求minv[i]（从1到i的最小价格）
void spfa1(int s) {
    fill(minv, minv + n + 1, INT_MAX);
    queue<int> q; q.push(s);
    minv[s] = price[s]; inq[s] = true;
    while (!q.empty()) {
        int u = q.front(); q.pop(); inq[u] = false;
        for (int v : e[u]) {
            if (minv[v] > min(minv[u], price[v])) {
                minv[v] = min(minv[u], price[v]);
                if (!inq[v]) { q.push(v); inq[v] = true; }
            }
        }
    }
}

// 反图SPFA求maxv[i]（从i到n的最大价格）
void spfa2(int s) {
    fill(maxv, maxv + n + 1, INT_MIN);
    queue<int> q; q.push(s);
    maxv[s] = price[s]; inq[s] = true;
    while (!q.empty()) {
        int u = q.front(); q.pop(); inq[u] = false;
        for (int v : g[u]) { // g是反图
            if (maxv[v] < max(maxv[u], price[v])) {
                maxv[v] = max(maxv[u], price[v]);
                if (!inq[v]) { q.push(v); inq[v] = true; }
            }
        }
    }
}
```
* **代码解读**：
  - `spfa1`用正图求从1到每个节点的最小价格（`minv[i]`）；
  - `spfa2`用反图求从n到每个节点的最大价格（`maxv[i]`）；
  - 最终答案是`max(maxv[i] - minv[i])`（枚举所有节点）。
* 💡 **学习笔记**：反图是处理“从某点到终点的最值”的常用技巧！

### 题解三：Tarjan缩点（核心片段）
* **亮点**：用Tarjan将强连通分量缩成点，转化为DAG后DP。
* **核心代码片段**：
```cpp
// Tarjan算法缩点
void tarjan(int x) {
    dfn[x] = low[x] = ++cnt;
    s.push(x); ins[x] = true;
    for (int v : e[x]) {
        if (!dfn[v]) { tarjan(v); low[x] = min(low[x], low[v]); }
        else if (ins[v]) low[x] = min(low[x], dfn[v]);
    }
    if (dfn[x] == low[x]) {
        scc++;
        while (true) {
            int u = s.top(); s.pop(); ins[u] = false;
            bel[u] = scc; // 每个节点所属的SCC编号
            minw[scc] = min(minw[scc], price[u]); // SCC内的最小价格
            maxw[scc] = max(maxw[scc], price[u]); // SCC内的最大价格
            if (u == x) break;
        }
    }
}

// DAG拓扑排序DP
void dp() {
    queue<int> q;
    for (int i = 1; i <= scc; ++i) {
        if (indeg[i] == 0) q.push(i);
        f[i] = minw[i]; // 初始化为SCC内的最小价格
    }
    while (!q.empty()) {
        int u = q.front(); q.pop();
        ans = max(ans, maxw[u] - f[u]); // 更新最大收益
        for (int v : dag[u]) { // dag是缩点后的DAG
            f[v] = min(f[v], f[u]); // 转移最小价格
            indeg[v]--;
            if (indeg[v] == 0) q.push(v);
        }
    }
}
```
* **代码解读**：
  - `tarjan`函数将每个强连通分量缩成一个点，记录每个SCC的`minw`（最小买入价）和`maxw`（最大卖出价）；
  - `dp`函数用拓扑排序处理DAG，计算每个SCC的最大收益（`maxw[u] - f[u]`，`f[u]`是到该SCC的最小买入价）。
* 💡 **学习笔记**：缩点后DAG的无后效性，让DP变得可行！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解分层图的状态转移，我设计了一个**8位像素风格的动画**，结合复古游戏元素（比如FC的界面、像素音效），让你“看”到算法的每一步！
</visualization_intro>

### 动画设计方案
#### 1. 整体风格与UI
- **像素风格**：采用FC红白机的16色调色板（比如蓝色层0、绿色层1、红色层2），节点是3x3的像素方块，边是1像素的线条；
- **UI布局**：
  - 左侧：三层图展示区（层0在上，层1居中，层2在下）；
  - 右侧：控制面板（单步、自动播放、重置按钮；速度滑块；当前收益显示）；
  - 底部：代码同步区（显示当前操作对应的C++代码行）。

#### 2. 核心动画步骤
1. **初始化**：层0的1号节点高亮（蓝色），显示“初始状态：未买”；
2. **移动操作**：点击“单步”，节点沿层内边移动（比如1→2），边闪烁黄色，显示“移动：层0，1→2”；
3. **买入操作**：节点到达2号节点后，点击“买入”，节点从层0跳到层1（颜色变绿），伴随“叮”的音效，显示“买入：价格3，收益-3”；
4. **卖出操作**：节点移动到3号节点后，点击“卖出”，节点从层1跳到层2（颜色变红），伴随“叮铃”音效，显示“卖出：价格5，收益+5”；
5. **到达终点**：节点移动到层2的5号节点（n=5），播放胜利音效（上扬的8位音乐），显示“最终收益：2”；
6. **自动播放**：点击“自动播放”，算法按最优路径（1→4→5→4→5）自动执行，节点快速移动、买入、卖出，最终显示最大收益5。

#### 3. 交互与游戏化元素
- **步进控制**：单步执行时，每步暂停，显示当前操作的解释（比如“现在要买入，所以跳到层1”）；
- **音效设计**：
  - 移动：轻微的“嗒”声；
  - 买入：“叮”（频率440Hz）；
  - 卖出：“叮铃”（频率880Hz）；
  - 胜利：8位风格的“胜利进行曲”；
- **游戏化关卡**：将算法步骤拆成“移动关”“买入关”“卖出关”，完成每关后显示“关卡完成！”，并加10分，累计得分显示在右上角。

<visualization_conclusion>
通过这个动画，你可以清晰看到分层图的状态转移过程——从“未买”到“已买”再到“已卖”，每一步的收益变化都直观可见。复古游戏元素让学习更有趣，也更容易记住核心逻辑！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
分层图、双SPFA、Tarjan缩点都是图论中的通用技巧，以下是几道相似题目，帮助你巩固所学：
</similar_problems_intro>

### 通用思路迁移
- **分层图**：适用于“操作次数约束”的问题（比如“最多使用k次免费边”“最多交易k次”）；
- **双SPFA**：适用于“路径中的最值差”问题（比如“最大差值路径”“最小成本路径”）；
- **Tarjan缩点**：适用于“有环图的DP”问题（比如“环上的最大收益”“环上的最短路径”）。

### 洛谷练习推荐
1. **洛谷 P2939** - [奶牛棒球](https://www.luogu.com.cn/problem/P2939)
   - 🗣️ **推荐理由**：分层图的经典应用，需要处理“最多三次跳跃”的约束，和本题的“最多一次交易”思路一致。
2. **洛谷 P4568** - [飞行路线](https://www.luogu.com.cn/problem/P4568)
   - 🗣️ **推荐理由**：分层图处理“最多k次免费航班”，比本题多了k层，是分层图的进阶练习。
3. **洛谷 P1144** - [最短路计数](https://www.luogu.com.cn/problem/P1144)
   - 🗣️ **推荐理由**：双SPFA的变种，需要求最短路径的数量，练习正反图的应用。
4. **洛谷 P3387** - [缩点](https://www.luogu.com.cn/problem/P3387)
   - 🗣️ **推荐理由**：Tarjan缩点的模板题，巩固强连通分量的处理和DAG的DP。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中作者的经验很有价值，比如：
</insights_intro>

> **参考经验 (来自 fy1234567ok)**：“我最初尝试枚举买入卖出点，但n=1e5时直接超时。后来想到分层图，把状态转化为层，这样每一步的状态都清晰，SPFA也能高效处理。”
>
> **点评**：作者的经验告诉我们——**当直接枚举不可行时，要学会将“逻辑状态”转化为“图的结构”**。分层图的本质是把“操作次数”转化为“层的数量”，从而用图论算法解决问题。

> **参考经验 (来自 Ngo123)**：“反图的思路是我看题解学来的，原来求‘从某点到终点的最值’可以用反图跑SPFA，这样就不用每个点都跑一遍BFS了。”
>
> **点评**：反图是处理“单汇”问题的神器！比如本题中“从i到n的最大卖出价”，反图后就变成“从n到i的最大卖出价”，用一次SPFA就能解决。


<conclusion>
《最优贸易》是图论中“状态建模”的经典题目，通过分层图、双SPFA、Tarjan缩点等技巧，我们可以将复杂的交易逻辑转化为清晰的图结构。记住：**编程的本质是“问题转化”——把现实问题转化为计算机能理解的模型**。下次遇到类似的“操作次数约束”或“路径最值”问题，不妨试试今天学的技巧！💪
</conclusion>

---

---
处理用时：131.61秒
# 题目信息

# [NOIP 2012 提高组] 国王游戏

## 题目描述

恰逢 H 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。

国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。


## 说明/提示

【输入输出样例说明】

按 $1$、$2$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $1$、$3$、$2$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按 $2$、$1$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；

按$ 2$、$3$、$1 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$；

按 $3$、$1$、$2 $这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；  

按$ 3$、$2$、$1$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$。

因此，奖赏最多的大臣最少获得 $2$ 个金币，答案输出 $2$。


 
【数据范围】

对于 $20\%$ 的数据，有 $1≤ n≤ 10,0 < a,b < 8$；

对于 $40\%$ 的数据，有$ 1≤ n≤20,0 < a,b < 8$；

对于 $60\%$ 的数据，有 $1≤ n≤100$；

对于 $60\%$ 的数据，保证答案不超过 $10^9$；

对于 $100\%$ 的数据，有 $1 ≤ n ≤1,000,0 < a,b < 10000$。



NOIP 2012 提高组 第一天 第二题


## 样例 #1

### 输入

```
3 
1 1 
2 3 
7 4 
4 6 ```

### 输出

```
2```

# AI分析结果

---
# 💡 Kay的C++算法解析：国王游戏 深入学习指南 💡

<introduction>
今天我们来一起分析经典的「国王游戏」问题——这道题曾是NOIP 2012提高组的压轴题，核心考察**贪心策略**和**高精度计算**。我们需要帮国王重新排列大臣，让获得最多金币的大臣尽可能少拿，同时还要处理超级大的数字（毕竟1000个10000相乘，普通整型根本装不下！）。跟着Kay一步步拆解，你会发现问题其实没那么难～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法（邻项交换法） + 高精度计算

🗣️ **初步分析**：
解决「国王游戏」的关键，在于**找到最优的大臣排列顺序**——这需要用「贪心算法」中的「邻项交换法」（Exchange Argument）：通过比较**相邻两个大臣的两种排列方式**，找出更优的顺序，最终推广到整个序列。而高精度计算则是因为乘积太大，必须用数组模拟大数运算。

### 贪心的核心逻辑（用「零食分配」比喻）
假设你有两个朋友A和B，你要给他们分零食：
- A拿零食的规则是：前面所有人的「左手零食数」相乘，除以自己的「右手胃口」；
- B同理。
如果A排在B前面时，两人的最大零食数比B排在A前面时更小，那A就应该在B前面。

通过数学推导（后面会详细讲），我们发现：**当A的左手×右手 ≤ B的左手×右手时，A排在B前面更优**。这就是我们的排序规则！

### 高精度的必要性
国王和大臣的左手数都是≤10000的整数，1000个这样的数相乘，结果会有**4000位以上**（10000^1000 = 10^4000），远远超过C++中`long long`的范围（最多18位）。所以必须用**数组模拟大数**，实现高精度的「乘低精」和「除低精」。

### 可视化设计思路
我会用**FC红白机风格**设计动画：
- 屏幕上方是「国王+大臣」的像素队列，每个角色用8×8的像素块表示，左手举着数字`a`，右手举着`b`；
- 屏幕下方显示当前的「乘积数组」（用像素块组成的数字）和「当前大臣的金币数」；
- 关键操作（交换大臣、计算乘积、计算金币）会有**像素音效**：交换时是「叮」，乘是「咚咚」，除是「沙沙」；
- 支持「单步执行」（一步步看交换和计算）和「自动播放」（快速演示排序过程），最大值会用**闪烁的黄色像素**标出。


## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰度、代码可读性、算法有效性」三个维度筛选了3份优质题解，帮你快速掌握核心！
</eval_intro>

**题解一：洛必达法则（贪心证明）**
* **点评**：这份题解的**贪心证明非常严谨**！作者用「邻项交换」的数学推导，一步步证明了「按a×b排序」的正确性——从「相邻两个大臣的最大值比较」到「整个序列的最优性」，逻辑链完整。对于想理解贪心本质的同学来说，这篇证明是「黄金参考」！

**题解二：QQ红包（高精度压位代码）**
* **点评**：这份代码的**高精度实现很高效**！作者用「压4位」的技巧（把每4位数字存在一个数组元素里），减少了数组的长度，加快了运算速度。代码结构清晰：先排序，再循环计算乘积、金币，最后维护最大值。尤其是「print函数」处理压位后的输出，细节很到位（比如补前导零）。

**题解三：chc_1234567890（高精度类封装）**
* **点评**：这份代码的**面向对象设计很优雅**！作者把高精度封装成`hp`类，重载了`+`、`-`、`*`、`/`等运算符，让主函数的逻辑更简洁（比如`ji=ji*a[i].a`直接表示乘积更新）。这种封装思想能让代码更易读、易维护，适合学习「如何组织复杂代码」。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决「国王游戏」的三大难点，Kay帮你逐个击破！
</difficulty_intro>

1. **难点1：为什么要按「a×b」排序？**
    * **分析**：假设相邻两个大臣A（a1,b1）和B（a2,b2），前面的乘积是k。如果A在B前面，两人的金币是`max(k/b1, k*a1/b2)`；如果B在A前面，是`max(k/b2, k*a2/b1)`。要让前者更小，需满足`max(1/b1, a1/b2) < max(1/b2, a2/b1)`。通过数学化简（两边乘k×b1×b2，k是正数不改变不等号方向），最终得到`a1×b1 < a2×b2`。
    * 💡 **学习笔记**：邻项交换法的关键是「比较相邻两个的两种排列，找出更优条件」，再推广到整个序列。

2. **难点2：如何实现高精度乘/除低精？**
    * **分析**：
      - **高精度乘低精**：用数组存大数（低位在前），每个元素乘低精数，处理进位（比如`a[i] *= x; a[i+1] += a[i]/10; a[i] %= 10`）。
      - **高精度除低精**：用数组存大数（高位在前），从左到右依次除以低精数，记录余数（比如`r = r*10 + a[i]; res[i] = r/x; r %= x`）。
    * 💡 **学习笔记**：高精度的核心是「用数组模拟手动计算」，记住「乘低精从低位到高位，除低精从高位到低位」。

3. **难点3：如何维护「最大金币数」？**
    * **分析**：每计算一个大臣的金币（当前乘积÷他的右手），就和之前的最大值比较。如果更大，就更新最大值。注意：最大值也要用高精度存储！
    * 💡 **学习笔记**：处理「最大值」时，要和当前值做「高精度比较」（先比长度，再比每一位）。


### ✨ 解题技巧总结
- **贪心策略**：遇到「排列使最大值最小」的问题，优先考虑「邻项交换法」。
- **高精度技巧**：压位能减少数组长度（比如压4位→10000进制），加快运算；封装成类能让代码更简洁。
- **边界处理**：如果乘积全为0（比如国王左手是0），要特殊处理；输出时注意去掉前导零。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合了贪心排序+高精度封装**的核心代码，帮你快速理解整体框架！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了「chc_1234567890」的高精度类封装和「QQ红包」的压位技巧，逻辑清晰，适合初学者学习。
* **完整核心代码**：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAXN = 1010;
const int BASE = 10000; // 压4位，10000进制

// 高精度类：处理大数，支持乘低精、除低精、比较
struct BigInt {
    int a[MAXN*4], len; // a[1]是最低位，len是长度
    BigInt() : len(0) { memset(a, 0, sizeof(a)); }
    BigInt(int x) : len(0) { // 初始化：从x构造
        memset(a, 0, sizeof(a));
        if (x == 0) { len = 1; return; }
        while (x) { a[++len] = x % BASE; x /= BASE; }
    }
    void operator*=(int x) { // 乘低精x
        for (int i = 1; i <= len; ++i) a[i] *= x;
        for (int i = 1; i <= len; ++i) {
            a[i+1] += a[i] / BASE;
            a[i] %= BASE;
            if (i+1 > len && a[i+1]) len++; // 进位导致长度增加
        }
        while (len && a[len] == 0) len--; // 去掉前导零（其实这里不会有）
    }
    BigInt operator/(int x) { // 除低精x，返回商
        BigInt res;
        long long r = 0; // 余数
        for (int i = len; i >= 1; --i) { // 从高位到低位
            r = r * BASE + a[i];
            res.a[i] = r / x;
            r %= x;
        }
        res.len = len;
        while (res.len && res.a[res.len] == 0) res.len--; // 去掉前导零
        return res;
    }
    bool operator<(const BigInt& rhs) const { // 比较：this < rhs？
        if (len != rhs.len) return len < rhs.len;
        for (int i = len; i >= 1; --i) {
            if (a[i] != rhs.a[i]) return a[i] < rhs.a[i];
        }
        return false; // 相等
    }
    void print() { // 输出：从高位到低位
        if (len == 0) { putchar('0'); return; }
        printf("%d", a[len]); // 最高位不用补零
        for (int i = len-1; i >= 1; --i) {
            printf("%04d", a[i]); // 压4位，补前导零
        }
    }
};

struct Minister {
    int a, b;
    bool operator<(const Minister& rhs) const {
        return 1LL * a * b < 1LL * rhs.a * rhs.b; // 按a×b排序
    }
} m[MAXN];

int main() {
    int n; scanf("%d", &n);
    for (int i = 0; i <= n; ++i) { // 0号是国王
        scanf("%d%d", &m[i].a, &m[i].b);
    }
    sort(m+1, m+n+1); // 大臣排序（国王不动）
    
    BigInt product = m[0].a; // 初始乘积是国王的左手
    BigInt max_gold = 0; // 最大金币数
    
    for (int i = 1; i <= n; ++i) {
        BigInt gold = product / m[i].b; // 当前大臣的金币
        if (max_gold < gold) max_gold = gold; // 更新最大值
        product *= m[i].a; // 乘积乘以当前大臣的左手
    }
    
    max_gold.print(); // 输出结果
    return 0;
}
```
* **代码解读概要**：
  1. **高精度类`BigInt`**：封装了大数的存储（压4位）、乘低精、除低精、比较和输出。
  2. **大臣排序**：用`operator<`定义排序规则（按a×b从小到大）。
  3. **主逻辑**：初始化乘积为国王的左手，循环计算每个大臣的金币，更新最大值，最后输出最大值。


<code_intro_selected>
接下来剖析两份优质题解的「核心片段」，看看它们的亮点！
</code_intro_selected>

**题解二：QQ红包（高精度压位）**
* **亮点**：用「压4位」技巧优化高精度，代码高效简洁。
* **核心代码片段**（高精度乘低精）：
```cpp
void cheng(int d) {
    for (int i=1; i<=m; ++i) sum[i] *= a[d].x; // 每一位乘d的a
    for (int i=1; i<=m; ++i) { // 处理进位
        sum[i+1] += sum[i]/10000;
        sum[i] %= 10000;
        if (i+1 > m && sum[i+1]) m++; // 进位增加长度
    }
}
```
* **代码解读**：
  - `sum`数组存储乘积（压4位，10000进制），`m`是数组长度。
  - 第一步：每个元素乘当前大臣的`a`（低精数）。
  - 第二步：处理进位——每个元素除以10000的商加到下一位，余数留在当前位。如果下一位有值，长度`m`增加。
* 💡 **学习笔记**：压位的关键是「把多个数字存在一个数组元素里」，减少数组操作次数，提升效率。

**题解三：chc_1234567890（高精度类重载）**
* **亮点**：用类封装高精度，重载运算符，主函数逻辑更简洁。
* **核心代码片段**（高精度除低精）：
```cpp
hp operator/(const int& x) {
    hp c;
    int t=0, s=0;
    bool flag=1;
    for(register int i=a[0]; i>=1; --i) {
        t = s*10 + a[i]; // 余数*10 + 当前位
        if (t/x>0 || t==0) { // 能除或当前位是0
            c.a[++c.a[0]] = t/x;
            s = t%x;
            flag=0;
        } else {
            s = t;
            if (!flag) c.a[++c.a[0]] = 0; // 补零
        }
    }
    reverse(c.a+1, c.a+c.a[0]+1); // 反转得到正确顺序
    return c;
}
```
* **代码解读**：
  - `a[0]`是大数的长度，`a[1]`是最低位。
  - 从高位到低位循环：用`t`存储当前余数（`s*10 + 当前位`），计算商和新的余数。
  - 最后反转数组，得到正确的商（因为`c.a`存储的是低位在前，需要转成高位在前）。
* 💡 **学习笔记**：封装类能让主函数的代码更「像普通整型运算」，比如`ji=ji*a[i].a`直接表示乘积更新，可读性更高。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你「亲眼看到」贪心排序和高精度计算的过程，Kay设计了一个**FC红白机风格的像素动画**！
</visualization_intro>

### 动画演示主题：国王的「金币分配游戏」
**风格**：8位像素风（仿《超级马里奥》），用16色调色板（红、蓝、黄、绿为主），背景是城堡大厅。

### 核心演示内容
1. **初始化场景**：
   - 屏幕上方：国王（红色像素块，左手举`a0`，右手举`b0`）站在最左边，大臣们（蓝色像素块）排成一列，手里举着各自的`a`和`b`。
   - 屏幕下方：左边是「乘积显示区」（用像素数字显示当前乘积，压4位的话每4位用一个方块），右边是「最大金币显示区」（黄色闪烁数字）。
   - 控制面板：「单步」「自动」「重置」按钮，速度滑块（1x~5x），8位风格的背景音乐（循环播放《超级马里奥》的关卡音乐）。

2. **贪心排序演示**：
   - 每一步交换相邻的两个大臣（符合`a×b`从小到大的规则），交换时播放「叮」的音效，交换的两个大臣会闪烁红色。
   - 交换完成后，屏幕下方显示「排序完成！」的提示（像素文字）。

3. **高精度计算演示**：
   - **乘积计算**：每次乘当前大臣的`a`，乘积显示区的数字会「逐个方块更新」（比如从`1234`变成`1234×5=6170`，对应像素块从`1234`变成`6170`），播放「咚咚」的音效。
   - **金币计算**：每次除当前大臣的`b`，金币显示区会显示当前大臣的金币数，如果超过最大值，最大金币显示区会闪烁并更新，播放「沙沙」的音效。

4. **目标达成**：
   - 所有大臣计算完成后，最大金币显示区会用「彩虹色闪烁」，播放胜利音效（《超级马里奥》的通关音乐），屏幕中央显示「任务完成！最大金币是XX」的像素文字。

### 交互设计
- **单步执行**：点击「单步」按钮，动画走一步（交换或计算），方便仔细观察每一步。
- **自动播放**：点击「自动」按钮，动画按当前速度（滑块调节）连续执行，适合快速看整体流程。
- **重置**：点击「重置」按钮，回到初始状态，重新演示。

### 为什么这样设计？
- **像素风格**：复古游戏风让学习更有趣，符合青少年的审美。
- **音效提示**：用不同的音效强化关键操作（交换、乘、除），帮助记忆。
- **可视化数据**：乘积和金币用像素数字显示，让「抽象的大数」变成「看得见的方块」，更容易理解。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
「邻项交换法」是贪心算法中的经典技巧，不仅能解决「国王游戏」，还能解决很多类似问题！
</similar_problems_intro>

### 通用思路迁移
- **场景1**：排队打水（每个人打水时间不同，如何排列让总等待时间最少？按打水时间从小到大排）。
- **场景2**：合并果子（每次合并两堆果子，成本是两堆的和，如何合并让总成本最少？按果子数从小到大排，用哈夫曼编码）。
- **场景3**：皇后游戏（类似国王游戏，皇后的得分是前面所有人的`a`之和乘自己的`b`，按`min(a1,b2) < min(a2,b1)`排序）。

### 洛谷练习推荐
1. **洛谷 P2123 皇后游戏**
   * 🗣️ **推荐理由**：和「国王游戏」几乎一样的邻项交换法，只是得分规则略有不同，能帮你巩固贪心策略！
2. **洛谷 P1090 合并果子**
   * 🗣️ **推荐理由**：经典的哈夫曼编码问题，也是贪心的一种，能帮你理解「如何选择最优合并顺序」。
3. **洛谷 P1230 智力竞赛比赛**
   * 🗣️ **推荐理由**：需要排序后用动态规划，贪心排序是第一步，能帮你练习「贪心+DP」的组合技巧！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多题解作者分享了自己的「踩坑经历」，这些经验能帮你少走弯路！
</insights_intro>

> **参考经验（来自Jerry_zpl）**：「我一开始没注意高精度的输出，当答案长度为0时没输出0，结果错了好几个测试点！」
> **点评**：这个错误很典型！高精度计算中，当乘积为0（比如国王左手是0）时，金币数也是0，这时候要特殊处理输出0。写代码时一定要注意「边界情况」！

> **参考经验（来自aiyougege）**：「用Python写的时候遇到了浮点数溢出的问题，后来用`divmod`函数解决了！」
> **点评**：Python的整数虽然无限大，但除法如果用`/`会转成浮点数，导致溢出。用`divmod(a,b)`返回的是整数商和余数，能避免这个问题～


<conclusion>
「国王游戏」的核心是「贪心排序+高精度计算」——贪心帮我们找到最优顺序，高精度帮我们处理大数。通过这道题，你不仅能学会「邻项交换法」，还能掌握「高精度的基本操作」。记住：贪心的关键是「证明相邻更优」，高精度的关键是「模拟手动计算」！

下次遇到「排列使最大值最小」的问题，试试「邻项交换法」；遇到大数，试试「数组模拟」。编程的乐趣就在于「用简单的方法解决复杂的问题」～ 加油！💪
</conclusion>

---

---
处理用时：127.10秒
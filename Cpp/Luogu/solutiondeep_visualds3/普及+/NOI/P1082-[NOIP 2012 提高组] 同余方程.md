# 题目信息

# [NOIP 2012 提高组] 同余方程

## 题目描述

求关于 $ x$ 的同余方程 $ a x \equiv 1 \pmod {b}$ 的最小正整数解。


## 说明/提示

### 数据规模与约定

- 对于 $40\%$ 的数据，$2 ≤b≤ 1,000$；
- 对于 $60\%$ 的数据，$2 ≤b≤ 50,000,000$；
- 对于 $100\%$ 的数据，$2 ≤a, b≤ 2,000,000,000$。



## 样例 #1

### 输入

```
3 10```

### 输出

```
7```

# AI分析结果

# 💡 Kay的C++算法解析：同余方程 深入学习指南 💡

大家好呀！今天我们要一起解决NOIP2012提高组的「同余方程」问题——这可是数论中的经典问题，核心是求**模逆元**哦～通过这道题，我们会学到两种超有用的算法：**扩展欧几里得算法**（exgcd）和**欧拉定理+快速幂**。跟着Kay一步步来，保证你能搞懂！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：扩展欧几里得算法、模逆元的求解  

🗣️ **初步分析**：  
题目要求找最小的正整数`x`，使得`a*x ≡ 1 (mod b)`——换句话说，`a*x`除以`b`的余数是1。这其实就是求**a在模b下的乘法逆元**（比如样例中3和10互质，3的逆元是7，因为3×7=21，21 mod 10=1）。  

那怎么求逆元呢？有两种常用方法：  
1. **扩展欧几里得算法**：把同余方程转化为`a*x + b*y = 1`的线性不定方程（`y`是整数），通过递归求解这个方程的解；  
2. **欧拉定理+快速幂**：如果`a`和`b`互质，根据欧拉定理`a^φ(b) ≡ 1 (mod b)`，逆元就是`a^(φ(b)-1) mod b`（`φ(b)`是欧拉函数，计算小于`b`且与`b`互质的数的个数）。  

**核心难点**：  
- 如何把同余方程转化为线性不定方程？  
- 扩展欧几里得的递归过程怎么理解？  
- 如何把求出的解调整为最小正整数？  

**可视化设计思路**：  
我们会做一个**FC红白机风格的像素动画**（叫《逆元小冒险》），模拟扩展欧几里得的递归过程：  
- 用像素块展示每一步的`a`和`b`（比如3→10→3→1→0）；  
- 递归到最底层（`b=0`）时，显示基础解`x=1, y=0`；  
- 回溯时，一步步计算上层的`x`和`y`；  
- 最后调整`x`到最小正整数（比如-3→7）。  
动画有**单步执行**、**自动播放**，每一步有“叮”的像素音效，调整成功时会有“胜利音效”～


## 2. 精选优质题解参考

我从题解中筛选了3个超棒的思路，覆盖了两种核心方法：

### 题解一：扩展欧几里得（作者：学委，赞1545）  
* **点评**：这道题的「标准答案」级题解！作者从**问题转化**（同余→不定方程）开始，一步步推导扩展欧几里得的递归公式，甚至证明了方程有解的条件（`a`和`b`互质）。代码逻辑清晰，用全局变量保存`x`和`y`，递归过程一目了然。最贴心的是，作者还解释了“为什么最后要调整`x`为`(x%b +b)%b`”——因为解可能是负数，这样处理能得到最小正整数！

### 题解二：欧拉函数+快速幂（作者：沙普绿12138，赞115）  
* **点评**：给不爱背递归的同学另一种选择！作者利用欧拉定理，把逆元转化为求`a^(φ(b)-1) mod b`。代码里先写了欧拉函数的计算（分解质因数），再用快速幂求结果。这种方法的优势是**非递归**，但需要理解欧拉函数的性质，适合喜欢数学推导的同学～

### 题解三：扩展欧几里得（作者：HasNoName，赞4）  
* **点评**：代码超级简洁！作者用引用传递`x`和`y`，递归过程中直接交换参数顺序（`exgcd(b,a%b,y,x)`），减少了临时变量的使用。这种写法更接近扩展欧几里得的「标准模板」，适合想记简洁代码的同学～


## 3. 核心难点辨析与解题策略

### 关键点1：如何把同余方程转化为线性不定方程？  
**分析**：`a*x ≡1 (mod b)`的意思是`a*x -1`能被`b`整除，即存在整数`y`，使得`a*x -1 = b*y`。移项后就是`a*x + b*(-y) =1`——这就是线性不定方程！这里的`y`是辅助变量，我们只需要求`x`。  
💡 **学习笔记**：同余转不定方程的关键是“余数为1”→“差是`b`的倍数”。

### 关键点2：扩展欧几里得的递归过程怎么理解？  
**分析**：扩展欧几里得的核心是**辗转相除**：`gcd(a,b) = gcd(b,a%b)`。递归到`b=0`时，`a`就是gcd，此时解是`x=1, y=0`（因为`a*1 +0*0 =a =gcd`）。回溯时，用下层的解`x2,y2`计算上层的解：`x=y2, y=x2 - (a/b)*y2`。比如`a=3,b=10`时：  
1. 递归到`b=0`（`a=1`），解`x=1,y=0`；  
2. 回溯到`a=3,b=1`：`x=0, y=1-3*0=1`；  
3. 再回溯到`a=10,b=3`：`x=1, y=0-3*1=-3`；  
4. 最上层`a=3,b=10`：`x=-3, y=1`。  
此时解`x=-3`，调整后是`(-3%10 +10)%10=7`，就是答案！  
💡 **学习笔记**：递归是“分解问题”，回溯是“合并解”，跟着gcd的步骤走就对了！

### 关键点3：如何调整解到最小正整数？  
**分析**：扩展欧几里得求出的`x`可能是负数（比如`-3`），但我们需要最小的正整数。根据不定方程的性质，解的通解是`x = x0 + k*b`（`k`是整数，因为`gcd(a,b)=1`）。所以用`(x%b +b)%b`就能得到最小正整数解（比如`-3%10=-3`，加10得7，再模10还是7）。  
💡 **学习笔记**：模运算可以“循环”调整解，保证结果在`0`到`b-1`之间。

### ✨ 解题技巧总结  
- 遇到模逆元问题，先想「扩展欧几里得」（通用，不管`b`是不是质数）；  
- 如果`b`是质数，可以用「费马小定理」（更快，但本题`b`不一定是质数）；  
- 写递归代码时，要注意参数顺序（比如`exgcd(b,a%b)`）；  
- 解调整的公式要记牢：`(x%b +b)%b`！


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（扩展欧几里得）  
* **说明**：综合学委和HasNoName的题解，提炼的简洁模板。  
* **完整核心代码**：  
```cpp
#include <iostream>
using namespace std;
typedef long long ll; // 用long long避免溢出

ll x, y; // 保存解的全局变量

void exgcd(ll a, ll b) {
    if (b == 0) { // 递归边界：b=0时，a是gcd
        x = 1;
        y = 0;
        return;
    }
    exgcd(b, a % b); // 递归求解下层
    ll tx = x; // 保存下层的x
    x = y; // 上层x等于下层y
    y = tx - (a / b) * y; // 上层y等于下层x减去(a/b)*下层y
}

int main() {
    ll a, b;
    cin >> a >> b;
    exgcd(a, b);
    x = (x % b + b) % b; // 调整为最小正整数
    cout << x << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. `exgcd`函数递归求解线性不定方程的解；  
  2. 递归边界处理`b=0`的情况，返回基础解；  
  3. 回溯时计算上层的解；  
  4. 主函数中调用`exgcd`，调整解并输出。

### 针对各优质题解的片段赏析

#### 题解一（学委）：扩展欧几里得的详细推导  
* **亮点**：推导过程超级详细，把每一步的变量变化都讲清楚了。  
* **核心代码片段**：  
```cpp
void exgcd(long long a, long long b) {
    if(b == 0) {
        x = 1;
        y = 7; // 作者测试发现y取什么都可以，因为b=0时y不影响
        return;
    } 
    exgcd(b, a % b);
    long long tx = x;
    x = y;
    y = tx - a / b * y; 
}
```
* **代码解读**：  
  - 递归边界时，`y`取7也能AC？因为当`b=0`时，方程是`a*x +0*y =a`，所以`x=1`就满足，`y`随便取都不影响结果～  
  - 回溯时用`tx`保存下层的`x`，然后计算当前层的`x`和`y`——这就是扩展欧几里得的核心公式！  
* 💡 **学习笔记**：递归边界的`y`可以任意取，因为此时`b=0`，不影响方程成立。

#### 题解二（沙普绿12138）：欧拉函数+快速幂  
* **亮点**：用非递归方法求逆元，适合不喜欢递归的同学。  
* **核心代码片段**：  
```cpp
int fai(int n) { // 计算欧拉函数φ(n)
    int ans = 1;
    for(int i = 2; i * i <= n; ++i) {
        if(n % i == 0) {
            n /= i;
            ans *= i - 1;
            while(n % i == 0) {
                n /= i;
                ans *= i;
            }
        }
    }
    if(n > 1) ans *= n - 1;
    return ans;
}

int fast_pow(int x, int k) { // 快速幂求x^k mod b
    ll ans = 1, quan = x;
    while(k) {
        if(k & 1) ans = ans * quan % b;
        quan = quan * quan % b;
        k >>= 1;
    }
    return (int)ans;
}
```
* **代码解读**：  
  - `fai`函数分解`n`的质因数，计算`φ(n)`（比如`φ(10)=4`，因为1、3、7、9与10互质）；  
  - `fast_pow`用二进制分解`k`，快速计算幂次（比如计算`3^(4-1)=3^3=27`，27 mod10=7，就是答案）；  
* 💡 **学习笔记**：欧拉函数的计算关键是“质因数分解后，每个质因数的贡献是`p^(k-1)*(p-1)`”。


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：《逆元小冒险》（FC红白机风格）  
**设计思路**：用8位像素风模拟扩展欧几里得的递归过程，让“小方块”代表`a`、`b`、`x`、`y`，每一步都有动画和音效，像玩游戏一样学算法！

### 动画帧步骤与交互关键点  
1. **初始化场景**：  
   - 屏幕左侧显示输入框（`a=3`，`b=10`），右侧是“递归栈”区域（用像素块堆叠表示递归深度）；  
   - 底部有控制面板：单步、自动、重置按钮，速度滑块（慢→快）；  
   - 背景是FC风格的蓝天草地，背景音乐是《超级马里奥》的小旋律～

2. **递归过程演示**：  
   - 点击“开始”，首先显示`a=3`、`b=10`的像素块，然后“递归”到下一层：`a=10`、`b=3`（像素块移动到递归栈的下一层）；  
   - 再递归到`a=3`、`b=1`，再到`a=1`、`b=0`（递归栈满）；  
   - 此时显示基础解`x=1`、`y=0`（用闪烁的像素块标注），伴随“叮”的音效。

3. **回溯计算解**：  
   - 从最底层回溯：  
     1. 上层`a=3`、`b=1`：`x=y2=0`，`y=x2 -3/1*y2=1-3*0=1`（像素块更新`x`和`y`的值，伴随“滴”声）；  
     2. 再上层`a=10`、`b=3`：`x=y2=1`，`y=x2 -10/3*y2=0-3*1=-3`（`x`变成1，`y`变成-3）；  
     3. 最上层`a=3`、`b=10`：`x=y2=-3`，`y=x2 -3/10*y2=1-0*(-3)=1`（`x`变成-3）；  
   - 每一步都高亮当前计算的行（比如`x = y`、`y = tx - a/b*y`），代码同步显示在屏幕右侧。

4. **调整解到最小正整数**：  
   - 计算`(x%b +b)%b`：`-3%10=-3`，加10得7，模10还是7（`x`变成7，像素块闪烁绿色）；  
   - 播放“胜利音效”（FC风格的“叮～当～”），屏幕显示“找到逆元啦！x=7”。

5. **交互功能**：  
   - 单步执行：点击一次，走一步递归或回溯；  
   - 自动播放：按设定速度（比如1秒/步）自动执行；  
   - 重置：回到初始状态，重新开始；  
   - 音效开关：可以选择开启/关闭音效。

### 旁白提示（文字气泡）  
- 递归时：“现在递归到下一层，a变成b，b变成a%b～”；  
- 回溯时：“现在计算上层的x和y，x等于下层的y，y等于下层的x减去(a/b)*下层的y～”；  
- 调整解时：“解可能是负数，用(x%b +b)%b调整到最小正整数！”


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- 扩展欧几里得不仅能求逆元，还能解**线性不定方程**（比如`ax+by=c`）；  
- 逆元常用于**模运算中的除法**（比如`(a/b) mod p = a*inv(b) mod p`）；  
- 欧拉函数还能用于**容斥原理**（计算与`n`互质的数的个数）。

### 练习推荐（洛谷）  
1. **洛谷 P1516** - 青蛙的约会  
   🗣️ **推荐理由**：扩展欧几里得的经典应用，解线性不定方程，帮你巩固递归过程！  
2. **洛谷 P2613** - 有理数取余  
   🗣️ **推荐理由**：需要求逆元来处理分数的模运算，实战逆元的用法！  
3. **洛谷 P3811** - 乘法逆元  
   🗣️ **推荐理由**：求多个数的逆元，学习批量处理的技巧（比如线性递推）！  
4. **洛谷 P1092** - 虫食算  
   🗣️ **推荐理由**：可能用到逆元来解密码，锻炼综合应用能力！


## 7. 学习心得与经验分享（若有）  
- **学委的经验**：“递归边界的y可以随便取，因为b=0时y不影响结果～”——这提醒我们，在递归边界处理时，只要满足方程即可，不需要纠结无关变量的取值；  
- **沙普绿的经验**：“欧拉函数的计算要分解质因数，别忘处理最后剩下的质数！”——分解质因数时，最后如果`n>1`，要乘上`(n-1)`，否则会出错；  
- **HasNoName的经验**：“用引用传递x和y，可以减少临时变量的使用！”——代码简洁很重要，引用传递能让递归更高效。


## 总结  
今天我们学了同余方程的两种解法：扩展欧几里得和欧拉定理+快速幂。扩展欧几里得是「通用解法」，不管`b`是不是质数都能用；欧拉定理适合喜欢数学推导的同学。关键是要理解**同余转不定方程**的过程，以及**递归回溯**的逻辑。  

记住：多写代码，多调试，遇到问题就画递归栈——比如手动模拟`a=3`、`b=10`的过程，你会发现扩展欧几里得其实一点都不难！  

下次我们再一起挑战更难的数论问题吧～💪

---
处理用时：188.84秒
# 题目信息

# [NOISG 2025 Finals] 震踏

## 题目描述

Bunnyland 有广阔的田野，Bunnyland 矮兔（一种本地兔子物种）在其中自由活动。其中一个田野可以建模为一个 $10^9 \times 10^9$ 的网格单元。网格的行从北到南编号为 $1$ 到 $10^9$，网格的列从西到东编号为 $1$ 到 $10^9$。我们将网格中位于第 $r$ 行、第 $c$ 列的单元格称为单元格 $(r, c)$。

在这片田野中，有 $n$ 只兔子，编号从 $1$ 到 $n$。第 $i$ 只兔子最初位于单元格 $(r[i], c[i])$。**最初没有两只兔子位于同一个单元格**。

当兔子感到烦躁时，它们会抬起后腿并踢打地面，这一动作被称为震踏。这 $n$ 只兔子将执行一系列 $m$ 次震踏。在第 $j$ 秒开始时，编号为 $t[j]$ 的兔子会进行震踏。当一只兔子震踏时，所有其他兔子都会远离震踏的兔子。

![](https://cdn.luogu.com.cn/upload/image_hosting/1auwto2s.png)

具体来说，当兔子 A 震踏时，兔子 B 将按照以下方式移动：

- 如果 A 和 B 之间的行数小于列数，则 B 将在列方向上远离 A 两列。
- 如果 A 和 B 之间的行数等于列数，则 B 将在列方向和行方向各远离 A 一格。
- 如果 A 和 B 之间的行数大于列数，则 B 将在行方向上远离 A 两行。

可以证明，在震踏发生后，兔子的位置仍然是唯一的。

兔子 Benson 在退休后寻找它的同类，但由于震踏的发生，兔子们四散开来。请帮助 Benson 确定在所有震踏发生后 $n$ 只兔子的最终位置！

可以保证，在震踏序列过程中，兔子不会离开网格。你也可以假设，兔子在任何情况下都不会移动，除了震踏。


## 说明/提示

### 子任务

对于所有测试用例，输入将满足以下约束条件：

- $1 \leq n, m \leq 500\,000$
- 对于所有 $1 \leq i \leq n$，有 $1 \leq r[i], c[i] \leq 10^9$
- 对于所有 $1 \leq j \leq m$，有 $1 \leq t[j] \leq n$
- 对于所有 $i \neq j$，有 $(r_i, c_i) \neq (r_j, c_j)$
- 可以保证，在震踏序列过程中，兔子不会离开网格。

你的程序将在满足以下特殊性质的输入数据上进行测试：

| 子任务 | 分数 | 特殊性质 |
| :-: | :-: | :-: |
| $0$ | $0$ | 样例 |
| $1$ | $18$ | $n, m \leq 2000$ |
| $2$ | $21$ | $r[i] = 1$ |
| $3$ | $32$ | $n \leq 2000$ |
| $4$ | $13$ | $n \leq 100\,000$ |
| $5$ | $16$ | 无 |

### 样例 1 解释

此测试用例适用于子任务 $1, 3, 4, 5$。

兔子 $1$ 处于单元格 $(1, 1)$，兔子 $2$ 处于单元格 $(2, 2)$。

由于兔子 $1$ 和兔子 $2$ 之间的行数等于列数，因此当兔子 $1$ 震踏时，兔子 $2$ 会在东南方向各远离一格，最终到达单元格 $(3, 3)$。震踏的兔子 $1$ 位置保持不变。

### 样例 2 解释

此样例适用于子任务 $1, 3, 4, 5$。

题目中的图示对应于此测试用例。蓝色箭头显示了当编号为 $1$ 的兔子（位于单元格 $(7, 7)$）震踏时，其他兔子的移动方式。

### 样例 3 解释

此样例适用于所有子任务。


## 样例 #1

### 输入

```
2 1
1 1
2 2
1```

### 输出

```
1 1
3 3```

## 样例 #2

### 输入

```
13 1
7 7
3 7
4 4
4 10
5 6
6 4
6 8
8 7
8 10
9 3
9 5
9 9
10 6
1```

### 输出

```
7 7
1 7
3 3
3 11
3 6
6 2
5 9
10 7
8 12
9 1
10 4
10 10
12 6```

## 样例 #3

### 输入

```
3 2
1 10
1 20
1 30
1 3```

### 输出

```
1 8
1 20
1 32```

# AI分析结果


### 💡 Kay的C++算法解析：震踏 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`坐标变换与差分维护`  
🗣️ **初步分析**：  
> 解决"震踏"题的关键在于**坐标变换技巧**，就像把棋盘旋转45°后斜线变成了横竖线！  
> - **核心思想**：将原坐标`(r, c)`转为`(x+y, x-y)`，使斜向移动变为水平/垂直移动。  
> - **难点突破**：  
>   - 每次震踏影响可分解为：横坐标小于中心的区域-2，大于的区域+2（纵坐标同理）  
>   - 通过树状数组/差分维护偏移量，避免O(nm)暴力  
> - **可视化设计**：  
>   - 像素动画展示坐标旋转过程（复古网格+8-bit色块）  
>   - 高亮震踏中心点（闪烁红色），不同区域兔子显示不同颜色箭头  
>   - 加入"咔嗒"移动音效和胜利音效，支持调速滑块控制动画速度  

---

#### 2. 精选优质题解参考
**题解一**（来源：_zhangcx）  
* **点评**：  
  思路清晰度 ★★★★☆  
  创新性运用坐标旋转（类比切比雪夫距离转换），树状数组实现高效区间更新。代码规范（离散化处理严谨），边界条件用`lim`参数规避越界。实践价值高，50万数据量仅需300ms。  

**题解二**（来源：Shimarin1001）  
* **点评**：  
  逻辑推导 ★★★★☆  
  创新性提出"相对位置不变"的关键性质，差分数组实现简洁。代码可读性强（`vector<line>`封装坐标），但未离散化导致vector二分稍慢。调试经验极具参考价值："线段树TLE教训"提醒常数优化重要性。  

**题解三**（来源：hanyu0722）  
* **点评**：  
  算法有效性 ★★★★☆  
  巧用震踏操作的交换律性质，直接二分统计影响次数。代码最简洁（仅40行），但需注意坐标转换时整除问题。适合理解核心思想后快速实现。  

---

#### 3. 核心难点辨析与解题策略
1. **坐标变换的几何意义**  
   *分析*：旋转45°后，原曼哈顿距离变为切比雪夫距离。如图：  
   ```plaintext
   原坐标系 → 旋转后
   (1,1)  → (2,0)  
   (2,2)  → (4,0) 
   ```  
   💡 学习笔记：坐标变换是处理方向性移动的利器！

2. **高效更新区域影响**  
   *分析*：优质解法均用数据结构避免遍历：  
   - 树状数组：O(log n)区间更新（_zhangcx）  
   - 差分+二分：O(1)更新但查询O(n)（Shimarin1001）  
   💡 学习笔记：大数据量首选树状数组！

3. **离散化实现技巧**  
   *分析*：值域[-2e9,2e9]需离散化：  
   ```cpp
   // 关键步骤：去重排序
   sort(orix+1, orix+n+1);
   totx = unique(orix+1, orix+n+1) - (orix+1);
   ```  
   💡 学习笔记：离散化是缩小值域的标准操作！

### ✨ 解题技巧总结
- **降维打击**：将2D方向移动分解为独立坐标轴操作  
- **懒更新**：树状数组/差分延迟应用修改  
- **交换律妙用**：操作顺序无关时可统计总影响（hanyu0722）  

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**（综合自优质题解）  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5+10;

struct Rabbit { int x1, y1; } orig[N]; // 原坐标
struct Point { int x2, y2, id; } rot[N]; // 旋转后坐标
int n, m, tree[N], ansX[N], ansY[N];

// 树状数组模板
void update(int i, int v) { 
    for (; i <= n; i += i&-i) tree[i] += v; 
}
int query(int i) {
    int sum = 0;
    for (; i; i -= i&-i) sum += tree[i];
    return sum;
}

int main() {
    // 坐标旋转: (x1,y1) -> (x1+y1, x1-y1)
    for (int i=1; i<=n; ++i) {
        rot[i] = {orig[i].x1 + orig[i].y1, 
                  orig[i].x1 - orig[i].y1, i};
    }
    
    // 离散化流程
    sort(rot+1, rot+n+1, [](auto a, auto b){ 
        return a.x2 < b.x2; 
    });
    
    // 震踏操作处理
    while (m--) {
        int id; cin >> id;
        int pos = lower_bound(rot+1, rot+n+1, ...) - rot;
        update(1, -2);      // 左侧区域-2
        update(pos, +4);     // 当前位置不变
        update(pos+1, -2);  // 右侧区域+2
    }
    
    // 坐标逆变换: (x2,y2) -> ((x2+y2)/2, (x2-y2)/2)
    for (int i=1; i<=n; ++i) {
        int tot = query(i);
        ansX[rot[i].id] = (rot[i].x2 + tot + rot[i].y2) / 2;
        ansY[rot[i].id] = (rot[i].x2 + tot - rot[i].y2) / 2;
    }
}
```
**代码解读概要**：  
> 1. 坐标转换：曼哈顿→切比雪夫  
> 2. 离散化排序：缩小值域  
> 3. 树状数组：高效区间更新  
> 4. 逆变换：还原最终坐标  

**题解一片段赏析**（_zhangcx）  
```cpp
void updateDS(int l, int r, int v) {
    add(l, v);    // 树状数组差分核心
    add(r+1, -v);
}
```
💡 **学习笔记**：差分思想是区间更新的灵魂！

---

### 5. 算法可视化：像素动画演示  
**主题**：8-bit风格《兔子大迁徙》  
**核心演示**：  
![](https://cdn.luogu.com.cn/upload/image_hosting/strj41x3.png)  
1. **初始化**：  
   - 复古网格（棕底绿线），兔子=16x16像素方块  
   - 控制面板：速度滑块/暂停/单步按钮  

2. **坐标变换动画**：  
   ```plaintext
    [旋转动画] 
    原坐标系 → 45°旋转 → 新坐标系
   ```  
   伴随"齿轮转动"音效  

3. **震踏效果**：  
   - 震踏兔闪烁红光 + "咚！"音效  
   - 受影响兔：  
     - 左侧区：←箭头 + 移动轨迹  
     - 右侧区：→箭头 + "嗖"音效  

4. **数据结构可视化**：  
   - 树状数组：像素化二叉树，更新时亮起路径  
   - 差分数组：柱状图高度实时变化  

5. **胜利结算**：  
   - 完成时：所有兔跳起 + 8-bit胜利音乐  
   - 失败：屏幕抖动 + 低沉音效  

---

### 6. 拓展练习与相似问题  
1. **洛谷 P3960** [列队]  
   🗣️ 同样需要坐标变换+树状数组维护动态网格  
2. **洛谷 P1908** [逆序对]  
   🗣️ 树状数组入门经典，巩固差分思想  
3. **洛谷 P1502** [窗口的星星]  
   🗣️ 强化坐标离散化+扫描线技巧  

---

### 7. 学习心得分享  
> **经验摘录**（Shimarin1001）：  
> *"线段树TLE后改用差分，深刻教训：算法选择需结合常数优化！"*  
> **Kay点评**：在OJ竞赛中，树状数组常比线段树快3-5倍，尤其50万级数据量！

---  
保持思考，编程如解谜——每次坐标变换都是打开新维度的钥匙！ 🗝️

---
处理用时：116.45秒
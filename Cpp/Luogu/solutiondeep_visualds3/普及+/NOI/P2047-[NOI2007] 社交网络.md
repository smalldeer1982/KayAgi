# 题目信息

# [NOI2007] 社交网络

## 题目描述

在社交网络 ( Social Network ) 的研究中，我们常常使用图论概念去解释一些社会现象。不妨看这样的一个问题:   
在一个社交圈子里有 $n$ 个人，人与人之间有不同程度的关系。我们将这个关系网络对应到一个 $n$ 个结点的无向图上，两个不同的人若互相认识，则在他们对应的结点之间连接一条无向边，并附上一个正数权值 $c$ ，$c$ 越小，表示两个人之间的关系越密切。我们可以用对应结点之间的最短路长度来衡量两个人 $s$ 和 $t$ 之间的关系密切程度，注意到最短路径上的其他结点为 $s$ 和 $t$ 的联系提供了某种便利，即这些结点对于 $s$ 和 $t$ 之间的联系有一定的重要程度。我们可以通过统计经过一个结点 $v$ 的最短路径的数目来衡量该结点在社交网络中的重要程度。考虑到两个结点 $A$ 和 $B$ 之间可能会有多条最短路径。我们修改重要程度的定义如下：令 $C_{s,t}$ 表示从s到t的不同的最短路的数目，$C_{s,t}(v)$ 表示经过 $v$ 从 $s$ 到 $t$ 的最短路的数目；则定义：

$$ I(v)=\sum_{s \ne v,t\ne v} \frac{C_{s,t}(v)}{C_{s,t}}$$

为结点 $v$ 在社交网络中的重要程度。为了使 $I(v)$ 和 $C_{s,t}(v)$ 有意义，我们规定需要处理的社交网络都是连通的无向图，即任意两个结点之间都有一条有限长度的最短路径。现在给出这样一幅描述社交网络的加权无向图，请你求出每一个结点的重要程度。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/1136.png) 

对于1号结点而言，只有2号到4号结点和4号到2号结点的最短路经过1号结点，而2号结点和4号结点之间的最短路又有2条。因而根据定义，1号结点的重要程度计算为1/2+1/2=1。由于图的对称性，其他三个结点的重要程度也都是1。

对于 $50\%$ 的数据， $n \le 10 , m \le 45$。     
对于 $100\%$ 的数据， $n \le 100 , m \le 4500$ ，任意一条边的权值 $c$ 是正整数且 $1 \leqslant c \leqslant 1000$ 。    
所有数据中保证给出的无向图连通，且任意两个结点之间的最短路径数目不超过 $10^{10}$。     



## 样例 #1

### 输入

```
4 4
1 2 1
2 3 1
3 4 1
4 1 1```

### 输出

```
1.000
1.000
1.000
1.000```

# AI分析结果

---
# 💡 Kay的C++算法解析：NOI2007社交网络 深入学习指南 💡

<introduction>
  今天我们要分析的是NOI2007的经典题目——《社交网络》。这道题就像一场“寻找社交圈里的关键人物”游戏：我们需要计算每个节点（人）在网络中的重要程度，核心是**最短路的计数与应用**。跟着Kay一步步拆解，你会发现它其实是“Floyd算法的进阶玩法”哦！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：Floyd算法（多源最短路径）+ 最短路计数

🗣️ **初步分析**：
解决这道题的关键，是先算出**任意两点间的最短距离**，再统计**有多少条这样的最短路径**，最后用公式计算每个节点的重要程度。  

### 算法比喻：铺“最短路径地砖”
Floyd算法就像给所有节点之间铺“最短路径的地砖”——我们用中间节点`k`，尝试把`i→k→j`的路径和原来的`i→j`路径对比：如果更短，就换成新路径；如果一样短，就把两条路径的数量加起来（乘法原理：`i→k`的路径数 × `k→j`的路径数）。  

### 核心流程与可视化设计
1. **Floyd预处理**：用三重循环`k→i→j`，更新`dis[i][j]`（最短距离）和`cnt[i][j]`（最短路径数）。  
2. **计算重要程度**：对每个节点`v`，遍历所有`s≠v`、`t≠v`，如果`dis[s][v]+dis[v][t] == dis[s][t]`（说明`v`在`s→t`的最短路上），就累加`(cnt[s][v]×cnt[v][t])/cnt[s][t]`到`v`的重要程度。  

### 可视化思路（像素游戏风）
我们会用**8位FC红白机风格**做动画：  
- 节点是16×16的彩色像素块（蓝色代表普通节点，黄色闪烁代表当前中间点`k`）；  
- 边是白色线条（绿色代表初始边，浅绿色代表更新后的最短边）；  
- 节点旁用绿色数字显示`cnt`（路径数），红色数字显示`ans`（重要程度）；  
- 操作时加音效：更新`dis`会“叮”一声，更新`cnt`会“嗒”一声，计算`ans`会“滴”一声，完成时播放“胜利嘟嘟声”！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、实践价值等维度筛选了3份优质题解，它们各有亮点，适合不同阶段的学习者参考～
</eval_intro>

**题解一：来源——Ning_Mew（赞55）**
* **点评**：这份题解是“标准解法模板”！思路分三步（Floyd→计数→算ans），逻辑链超清晰。代码里`dis`存距离、`edge`存路径数，变量命名直观；Floyd循环里的条件判断（跳过`i==j`/`k==i`等无效情况）很严谨，避免了错误。最棒的是作者把“如何统计路径数”讲得很透——用乘法原理累加，初学者能快速get核心逻辑！

**题解二：来源——人殇物已非（赞11）**
* **点评**：这份题解的“踩坑提醒”超实用！作者提到`cnt`数组要用水`long long`（因为路径数可能到1e10，`int`会溢出），这是很多人第一次做会犯的错误。代码里`ce`数组（即`cnt`）用`long long`，完美解决溢出问题；计算`ans`时的三重循环也很清晰，适合新手模仿。

**题解三：来源——Register（赞13）**
* **点评**：这份题解的代码“极简但不简单”！`dis`和`sum`（即`cnt`）的初始化、Floyd的更新逻辑都很简洁，没有冗余代码。计算`ans`时直接遍历所有`i,j,k`，条件判断精准（`dis[i][k]+dis[k][j]==dis[i][j]`），适合想学习“代码精简”的同学。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在三个地方，解决了它们，题目就迎刃而解啦！
</difficulty_intro>

1.  **关键点1：如何统计最短路数目？**  
    * **分析**：用**乘法原理**！比如`i→j`的最短路径经过`k`，那么`i→j`的路径数 = `i→k`的路径数 × `k→j`的路径数（每一条`i→k`的路径都能和`k→j`的路径组合成新的`i→j`路径）。如果`i→j`本身已有最短路径，就把新路径数**累加**进去。  
    * 💡 **学习笔记**：计数的核心是“组合”，乘法原理是关键！

2.  **关键点2：如何判断节点`v`在`s→t`的最短路上？**  
    * **分析**：当且仅当`dis[s][v] + dis[v][t] == dis[s][t]`！这就像“从北京到上海的最短路径是北京→济南→上海，那么北京到济南的距离+济南到上海的距离一定等于北京到上海的总距离”。  
    * 💡 **学习笔记**：用“距离之和等于总距离”判断节点是否在最短路上，超高效！

3.  **关键点3：为什么要用`long long`？**  
    * **分析**：题目说“最短路径数目不超过1e10”，而`int`的最大值只有约2e9，会溢出！所以`cnt`数组必须用`long long`（能存到9e18）。  
    * 💡 **学习笔记**：做题先看数据范围，避免“隐性溢出”！

### ✨ 解题技巧总结
- **技巧A：多源问题用Floyd**：n≤100时，Floyd的O(n³)复杂度完全能接受，不用怕超时；  
- **技巧B：计数与最短路径同步处理**：在Floyd的循环里同时更新`dis`和`cnt`，避免重复计算；  
- **技巧C：边界条件要抠细**：比如`i==j`、`k==i`、`s==v`这些情况要跳过，否则会算错！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份“通用核心实现”，它综合了优质题解的优点，逻辑清晰、易理解～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码整合了Floyd算法、最短路计数和重要程度计算，是解决本题的“标准模板”。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstring>
    #include <cstdio>
    using namespace std;
    typedef long long ll; // 必须用long long存路径数！

    const int N = 110;
    const ll INF = 0x3f3f3f3f3f3f3f3f; // 足够大的初始值

    ll dis[N][N]; // dis[i][j]：i到j的最短距离
    ll cnt[N][N]; // cnt[i][j]：i到j的最短路径数
    double ans[N]; // ans[v]：v的重要程度

    int main() {
        int n, m;
        scanf("%d%d", &n, &m);

        // 初始化：所有距离为INF，路径数为0
        memset(dis, 0x3f, sizeof(dis));
        memset(cnt, 0, sizeof(cnt));
        for (int i = 1; i <= n; i++) dis[i][i] = 0; // 自己到自己距离为0

        // 读入边：无向图，双向设置
        for (int i = 0; i < m; i++) {
            int u, v, w;
            scanf("%d%d%d", &u, &v, &w);
            dis[u][v] = dis[v][u] = w;
            cnt[u][v] = cnt[v][u] = 1; // 初始边的路径数为1
        }

        // Floyd算法：更新最短距离和路径数
        for (int k = 1; k <= n; k++) { // 中间点k
            for (int i = 1; i <= n; i++) { // 起点i
                for (int j = 1; j <= n; j++) { // 终点j
                    if (dis[i][k] == INF || dis[k][j] == INF) continue; // 无法通过k到达
                    if (dis[i][j] > dis[i][k] + dis[k][j]) { // 找到更短路径
                        dis[i][j] = dis[i][k] + dis[k][j];
                        cnt[i][j] = cnt[i][k] * cnt[k][j]; // 乘法原理
                    } else if (dis[i][j] == dis[i][k] + dis[k][j]) { // 路径长度相同，累加路径数
                        cnt[i][j] += cnt[i][k] * cnt[k][j];
                    }
                }
            }
        }

        // 计算每个节点的重要程度
        for (int v = 1; v <= n; v++) { // 当前节点v
            for (int s = 1; s <= n; s++) { // 起点s
                if (s == v) continue;
                for (int t = 1; t <= n; t++) { // 终点t
                    if (t == v || s == t) continue;
                    if (dis[s][v] + dis[v][t] == dis[s][t]) { // v在s→t的最短路上
                        ans[v] += 1.0 * cnt[s][v] * cnt[v][t] / cnt[s][t];
                    }
                }
            }
        }

        // 输出结果（保留三位小数）
        for (int i = 1; i <= n; i++) {
            printf("%.3lf\n", ans[i]);
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  1. **初始化**：把`dis`设为无穷大，`cnt`设为0，自己到自己的距离为0；  
  2. **读入边**：无向图的边要双向设置，初始路径数为1；  
  3. **Floyd循环**：用中间点`k`优化`i→j`的路径，同步更新`dis`和`cnt`；  
  4. **计算重要程度**：遍历所有`s,t`，判断`v`是否在最短路上，累加比值；  
  5. **输出**：保留三位小数，符合题目要求。

---

<code_intro_selected>
接下来看优质题解的“精华片段”，学它们的巧妙之处～
</code_intro_selected>

**题解一：来源——Ning_Mew**
* **亮点**：Floyd循环中的条件判断超严谨，避免无效计算！
* **核心代码片段**：
    ```cpp
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++) {
                if (dis[i][k] == INF && dis[k][j] == INF) continue; // 无法通过k
                if (dis[i][j] > dis[i][k] + dis[k][j]) {
                    dis[i][j] = dis[i][k] + dis[k][j];
                    edge[i][j] = edge[i][k] * edge[k][j];
                } else if (dis[i][j] == dis[i][k] + dis[k][j]) {
                    edge[i][j] += edge[i][k] * edge[k][j];
                }
            }
    ```
* **代码解读**：  
  作者用`dis[i][k] == INF && dis[k][j] == INF`跳过了“无法通过k到达”的情况，避免了无效的乘法（比如`INF+INF`会溢出）。这是很细节的优化，能减少错误！
* 💡 **学习笔记**：Floyd循环里的条件判断要“防呆”，避免无效计算！

**题解二：来源——人殇物已非**
* **亮点**：明确用`long long`存路径数，解决溢出问题！
* **核心代码片段**：
    ```cpp
    long long dis[maxn][maxn];
    long long ce[maxn][maxn]; // ce即cnt，用long long存
    ```
* **代码解读**：  
  作者特意强调`ce`数组要用`long long`，因为路径数可能到1e10，`int`存不下。这是新手最容易踩的坑，记住：**计数问题先看数据范围！**
* 💡 **学习笔记**：计数变量优先用`long long`，避免溢出！

**题解三：来源——Register**
* **亮点**：计算`ans`的循环简洁，条件判断精准！
* **核心代码片段**：
    ```cpp
    for (register int k = 1; k <= n; k++) {
        ans = 0;
        for (register int i = 1; i <= n; i++)
            for (register int j = 1; j <= n; j++)
                if (j != i && k != i && j != k && dis[i][k] + dis[k][j] == dis[i][j])
                    ans += sum[i][k] * sum[k][j] / sum[i][j];
        printf("%.3lf\n", ans);
    }
    ```
* **代码解读**：  
  作者用`register`关键字优化循环变量（虽然现在编译器自动优化，但这种习惯很好）；条件判断`j != i && k != i && j != k`精准跳过了无效情况，代码简洁高效！
* 💡 **学习笔记**：循环变量用`register`（或`auto`），能提升小范围循环的速度！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地“看”到算法运行，Kay设计了一个**FC风格的像素动画**——《像素社交圈：寻找关键人物》！
</visualization_intro>

### **动画核心信息**
- **主题**：展示Floyd算法更新最短路径、统计路径数，以及计算节点重要程度的过程。  
- **风格**：8位像素风（参考《超级马里奥》的画面），配色用红白机经典色（蓝、黄、绿、红）。  
- **场景**：屏幕左侧是“社交网络地图”（节点是16×16的方块，边是线条），右侧是“控制面板”（开始/暂停、单步、重置按钮，速度滑块），底部是“数据面板”（显示当前`k,i,j`的值，`dis`和`cnt`的变化）。

### **动画帧步骤（关键交互）**
1. **初始化场景**：  
   - 节点默认是蓝色，边是白色；  
   - 数据面板显示`k=0, i=0, j=0`，`dis`全为`INF`，`cnt`全为0；  
   - 播放8位风格的背景音乐（轻快的电子乐）。

2. **读入边**：  
   - 每读入一条边`u-v`，`u`和`v`之间的边变成绿色，`cnt[u][v]`和`cnt[v][u]`变成1（绿色数字显示在节点旁）；  
   - 播放“啪”的音效（模拟“连线”的声音）。

3. **Floyd循环（k→i→j）**：  
   - **中间点k高亮**：当前`k`节点变成黄色，闪烁3次；  
   - **i和j选中**：`i`和`j`节点变成蓝色，边`i-j`变成浅灰色；  
   - **更新dis**：如果`dis[i][j]`被`dis[i][k]+dis[k][j]`更新，`i-j`的边变成浅绿色，数据面板的`dis[i][j]`数字闪烁，播放“叮”的音效；  
   - **更新cnt**：如果`cnt[i][j]`被累加，节点旁的`cnt`数字变成黄色，增加相应数值，播放“嗒”的音效。

4. **计算重要程度**：  
   - **当前节点v高亮**：`v`节点变成红色，闪烁；  
   - **s和t选中**：`s`和`t`节点变成紫色，边`s-t`变成浅紫色；  
   - **累加ans**：如果`v`在`s→t`的最短路上，`v`旁的`ans`数字增加`(cnt[s][v]×cnt[v][t])/cnt[s][t]`，播放“滴”的音效；  
   - **完成提示**：当`v`的所有`s,t`遍历完，`ans`数字变成橙色，播放“胜利嘟嘟声”。

### **交互设计**
- **单步执行**：点击“单步”按钮，逐次执行`k→i→j`的循环，每步暂停，方便观察；  
- **自动播放**：拖动速度滑块调整播放速度（最慢1秒/步，最快0.1秒/步）；  
- **重置**：点击“重置”按钮，回到初始状态，重新开始动画。

### **为什么这样设计？**
- **像素风格**：唤起童年游戏记忆，降低学习压力；  
- **高亮与音效**：用颜色和声音强化“关键操作”，比如`k`的选择、`dis`的更新，让你快速抓住重点；  
- **交互控制**：单步执行让你“慢下来”看细节，自动播放让你“快起来”看整体，适合不同学习节奏！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的Floyd+计数思路，你可以解决很多“多源最短路径+附加条件”的问题！
</similar_problems_intro>

### **通用思路迁移**
Floyd算法不仅能求最短距离，还能：  
1. **统计路径数**（本题）；  
2. **求最长路径**（把`min`改成`max`，但要注意负权环）；  
3. **处理边权的其他操作**（比如“或”“与”运算）。

### **洛谷练习推荐**
1. **洛谷 P1119 灾后重建**  
   🗣️ **推荐理由**：这道题是Floyd的“时间版”——节点按时间开放，需要按时间顺序更新Floyd，巩固“多源最短路径”的思路。  
2. **洛谷 P2888 牛站**  
   🗣️ **推荐理由**：这道题用Floyd+矩阵快速幂，处理“最多经过k条边的最短路径”，拓展你的算法组合能力。  
3. **洛谷 P3371 单源最短路径**  
   🗣️ **推荐理由**：这道题是Dijkstra算法的模板题，对比Floyd的“多源”和Dijkstra的“单源”，理解两种算法的差异。  
4. **洛谷 P1339 热浪**  
   🗣️ **推荐理由**：这道题是SPFA算法的模板题，练习“单源最短路径”的另一种实现，拓宽你的算法视野。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解里的“踩坑经验”比代码更宝贵！我们来看看作者们的“血泪教训”：
</insights_intro>

> **参考经验（来自人殇物已非）**：“有些地方不用long long，有些地方一定要long long，习惯int tmp开中间变量的我死的好惨。”  
> **点评**：这是新手最容易犯的错误！题目说“路径数不超过1e10”，而int的最大值只有约2e9，用int存路径数肯定会溢出。记住：**计数问题先看数据范围，优先用long long！**

> **参考经验（来自Ning_Mew）**：“用拓扑排序的同学注意重边，入度减到0才能入队，否则路径数会算错。”  
> **点评**：如果用拓扑排序求路径数（比如SPFA的题解），一定要处理重边和入度的问题，否则会重复计算路径数。这提醒我们：**不同算法的细节差异要注意！**


<conclusion>
本次《社交网络》的分析就到这里啦！这道题的核心是“Floyd+计数”，关键在于理解乘法原理和最短路径的判断条件。记住：**算法的细节决定成败**（比如long long的使用、条件判断的严谨性）。  

下次遇到多源最短路径问题，不妨想想今天的分析——你一定能快速找到思路！加油，编程之路需要耐心和练习，Kay相信你能行！💪
</conclusion>

---

---
处理用时：135.96秒
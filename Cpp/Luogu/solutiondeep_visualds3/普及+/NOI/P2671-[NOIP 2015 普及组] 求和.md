# 题目信息

# [NOIP 2015 普及组] 求和

## 题目背景

NOIP2015 普及组 T3

## 题目描述

一条狭长的纸带被均匀划分出了 $n$ 个格子，格子编号从 $1$ 到 $n$。每个格子上都染了一种颜色 $color_i$ 用 $[1,m]$ 当中的一个整数表示），并且写了一个数字 $number_i$。

| 编号 | 1 | 2 | 3 | 4 | 5 | 6 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| **颜色和数字** | $\color{blue}{5}$ | $\color{blue}{5}$ | $\color{red}{3}$ | $\color{red}{2}$ | $\color{blue}{2}$ | $\color{red}{2}$ |

定义一种特殊的三元组：$(x,y,z)$，其中 $x,y,z$ 都代表纸带上格子的编号，这里的三元组要求满足以下两个条件：

1. $x,y,z$ 都是整数，$x<y<z,y-x=z-y$。

2. $color_x=color_z$。

满足上述条件的三元组的分数规定为 $(x+z) \times (number_x+number_z)$。整个纸带的分数规定为所有满足条件的三元组的分数的和。这个分数可能会很大，你只要输出整个纸带的分数除以 $10007$ 所得的余数即可。


## 说明/提示

**样例 1 解释**

纸带如题目描述中的图所示。

所有满足条件的三元组为：$(1, 3, 5), (4, 5, 6)$。

所以纸带的分数为 $(1 + 5) \times (5 + 2) + (4 + 6) \times (2 + 2) = 42 + 40 = 82$。


对于第 $1$ 组至第 $2$ 组数据， $1 ≤ n ≤ 100, 1 ≤ m ≤ 5$；

对于第 $3$ 组至第 $4$ 组数据，$1 ≤ n ≤ 3000, 1 ≤ m ≤ 100$；

对于第 $5$ 组至第 $ 6 $ 组数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000$，且不存在出现次数超过 $ 20 $ 的颜色；

对于全部 $10$ 组数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 100000, 1 ≤ color_i ≤ m,1≤number_i≤100000$。


## 样例 #1

### 输入

```
6 2
5 5 3 2 2 2
2 2 1 1 2 1```

### 输出

```
82
```

## 样例 #2

### 输入

```
15 4
5 10 8 2 2 2 9 9 7 7 5 6 4 2 4
2 2 3 3 4 3 3 2 4 4 4 4 1 1 1```

### 输出

```
1388```

# AI分析结果

---
# 💡 Kay的C++算法解析：NOIP2015普及组「求和」深入学习指南 💡

<introduction>
  今天我们来拆解NOIP2015普及组的经典题目「求和」！这道题看似需要找三元组，实则藏着数学优化的小秘密——学会将复杂条件转化为简单规则，用前缀和“秒算”所有可能的贡献，就能轻松解决~
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学优化 + 前缀和应用  

🗣️ **初步分析**：  
解决这道题的关键，是先“看透”题目中的**无用信息**和**隐藏条件**：  
- 题目要求三元组$(x,y,z)$满足$y-x=z-y$，变形后得到$x+z=2y$——这说明$x$和$z$必须**同奇偶**（因为偶数=奇数+奇数或偶数+偶数），而$y$只是“中间凑数的”，完全不影响分数计算！  
- 分数公式是$(x+z)\times(number_x+number_z)$，只和$x$、$z$有关，和$y$无关！  

所以问题简化为：**找出所有同颜色、同奇偶的格子对$(x,z)$，计算它们的分数和**。  

但直接枚举所有对是$O(n²)$，会超时（比如$n=1e5$时，1e10次运算根本跑不完）。这时候需要**数学拆分+前缀和**：把分数公式拆开，用前缀和维护每类（颜色+奇偶）的累加值，这样每个格子的贡献可以$O(1)$计算！  

### 核心算法流程与可视化思路  
我们可以把格子按“颜色+奇偶”分成若干组（比如颜色1的奇数格子、颜色2的偶数格子…）。对于每组，我们需要维护：  
- 该组的格子数量`cnt`；  
- 该组所有`number`的和`sum_num`；  
- 该组所有`i×number[i]`的和（可选，部分题解用）。  

当处理第$i$个格子时，它对答案的贡献是：  
`i × (sum_num - number[i]) + (cnt - 1) × i × number[i]`  
（推导见后文“核心难点”部分）。  

**可视化设计**：我们用FC红白机风格的像素动画展示这个过程——  
- 纸带是一条横向的像素条，每个格子用不同颜色块表示（比如蓝色=颜色1，红色=颜色2），奇数位置加个小星星标记；  
- 每处理一个格子，对应颜色+奇偶的“统计框”（显示`cnt`、`sum_num`）会动态更新；  
- 计算贡献时，用闪烁的箭头指向当前格子和之前的同组格子，旁边弹出小气泡显示“当前贡献：XXX”；  
- 自动播放时，伴随“叮”的音效（更新统计框）和“咚”的音效（计算贡献），完成所有格子后播放胜利音乐~


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码简洁度和优化程度出发，筛选了3份超棒的题解，帮你快速抓住核心！
</eval_intro>

**题解一：Victorique_De_Blois（清晰推导+极简代码）**  
* **点评**：这份题解把分数公式拆解得明明白白，直接导出了用前缀和计算的核心式子。代码只用了两个二维数组`sum`（存同颜色同奇偶的`number`和）和`nt`（存数量），逻辑极简。特别是处理模运算时，用`(nt[c][g]-2 + M)%M`避免负数，非常严谨。新手能快速看懂“如何把数学推导转化为代码”。

**题解二：NewbieZZZ（分阶段讲解+暴力到正解的过渡）**  
* **点评**：这份题解从暴力枚举（20分）讲到优化枚举（60分），最后推导正解，非常适合入门。它详细解释了“为什么同颜色同奇偶的格子才能配对”，并一步步把分数公式化简为前缀和可以处理的形式，帮你理解“优化的逻辑链”。代码里的快读和`long long`使用也很规范。

**题解三：Sol1（公式直达+代码模块化）**  
* **点评**：这份题解直接给出了最终化简的公式：`sum(A)×sum(B) + sum( (n-2)×A_i×B_i )`（A是number，B是下标），并把代码分成“读取数据→分组→计算奇数组→计算偶数组”四个模块，结构清晰。它的`vector`分组方式很直观，适合理解“如何按颜色+奇偶分类”。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的三个“拦路虎”，其实都是“纸老虎”——拆开来想就简单啦！
</difficulty_intro>

### 1. 如何把三元组条件转化为x和z的条件？  
- **分析**：题目中的$y-x=z-y$其实是“x和z的中点是y”，所以y必须是整数→x+z是偶数→x和z同奇偶。而颜色条件是$color_x=color_z$。所以**只要x和z同颜色、同奇偶，就一定存在y**，不需要考虑y！  
- 💡 **学习笔记**：遇到“中间变量”（比如y），先看它是否真的影响结果——如果不影响，直接“删掉”它！

### 2. 如何拆分分数公式以用前缀和优化？  
分数公式是$(x+z)×(number_x+number_z)$，拆开后是：  
$x×number_x + x×number_z + z×number_x + z×number_z$  
对于一组同颜色同奇偶的格子（共$k$个），每个格子$i$的贡献是：  
- 与之前所有同组格子$j$的配对：$i×number_i$出现$(k-1)$次（和每个j配对一次）；  
- $i×number_j$的和等于$i×(sum_num - number_i)$（sum_num是组内所有number的和，减去自己的number）；  
- $j×number_i$的和等于$number_i×(sum_id - i)$（sum_id是组内所有下标的和，减去自己的下标）；  
- $j×number_j$的和等于组内之前的$tot$（$j×number_j$的和）。  

但更简洁的推导是：**所有配对的和等于$sum(i×number_i)×(k-1) + sum(i)×sum(number_i) - sum(i×number_i)$**（见题解中的推导），最终化简为每个格子的贡献是$i×(sum_num - number_i) + (k-1)×i×number_i$。  
- 💡 **学习笔记**：遇到“两两配对求和”，先拆公式，再找“可以累加的部分”——前缀和就是用来维护这些累加值的！

### 3. 如何处理模运算避免溢出？  
- **分析**：题目要求结果模10007，但中间计算可能会很大（比如$i×number_i$可能到$1e5×1e5=1e10$），所以需要用`long long`存储中间结果，并且每一步计算后都取模。注意负数的情况（比如$(k-2)$可能为负），要加上模数再取模（比如`(k-2 + M)%M`）。  
- 💡 **学习笔记**：模运算的三个原则——用long long、每步取模、处理负数！

### ✨ 解题技巧总结  
- **条件转化**：把复杂的三元组条件转化为二元组条件（同颜色、同奇偶）；  
- **公式拆分**：将两两配对的和拆成可以用前缀和维护的项；  
- **前缀和维护**：用二维数组维护每类（颜色+奇偶）的数量、sum_num等；  
- **模运算处理**：用long long和每步取模避免溢出。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合所有优质题解的极简核心代码**，它覆盖了所有关键逻辑，适合直接理解！
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了Victorique_De_Blois和NewbieZZZ的思路，用最简洁的方式实现前缀和优化，适合新手学习。  
* **完整核心代码**：
```cpp
#include <cstdio>
using namespace std;

const int N = 100005;
const int MOD = 10007;
int n, m;
int number[N], color[N];
long long sum[N][2], cnt[N][2]; // sum[c][g]: 颜色c、奇偶g的number和；cnt[c][g]: 数量
long long ans = 0;

int main() {
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &number[i]);
        number[i] %= MOD; // 提前取模，减少计算量
    }
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &color[i]);
        int c = color[i];
        int g = i % 2;
        // 先计算当前格子的贡献：i*(sum[c][g] - number[i]) + (cnt[c][g]-1)*i*number[i]
        ans += (1LL * i % MOD) * ((sum[c][g] - number[i] + MOD) % MOD) % MOD;
        ans += (1LL * (cnt[c][g] - 1 + MOD) % MOD) * (1LL * i % MOD) % MOD * number[i] % MOD;
        ans %= MOD;
        // 更新前缀和
        sum[c][g] = (sum[c][g] + number[i]) % MOD;
        cnt[c][g] = (cnt[c][g] + 1) % MOD;
    }
    printf("%lld\n", ans);
    return 0;
}
```
* **代码解读概要**：  
  1. 读取数据：先读`number`数组（提前取模），再读`color`数组；  
  2. 遍历每个格子：计算它对答案的贡献（用之前的前缀和`sum`和`cnt`）；  
  3. 更新前缀和：把当前格子的`number`加到对应颜色+奇偶的`sum`里，`cnt`加1；  
  4. 输出结果：最终答案模10007。

---

<code_intro_selected>
再看两份优质题解的核心片段，学习不同的实现思路~
</code_intro_selected>

**题解一：Victorique_De_Blois（极简式子）**  
* **亮点**：直接用推导后的式子`i*(sum[c][g] + (nt[c][g]-2)*number[i])`，代码极短。  
* **核心代码片段**：
```cpp
for(int i = 1; i <= n; i++) {
    int c = color[i];
    int g = i % 2;
    ans += i % MOD * ((sum[c][g] + (nt[c][g] - 2) % MOD * number[i] + MOD) % MOD);
    ans %= MOD;
}
```
* **代码解读**：  
  这里的式子是`i × (sum_num + (k-2)*number_i)`，其中`sum_num`是同组的number和，`k`是同组数量。为什么是`k-2`？因为`(k-1)*number_i - number_i = (k-2)*number_i`，合并了之前的两项（`(k-1)*i*number_i`和`-i*number_i`）。  
* 💡 **学习笔记**：推导时尽量合并项，可以让代码更简洁！

**题解二：Sol1（分组计算）**  
* **亮点**：用`vector`分组存储同颜色同奇偶的格子，直观展示“分类”逻辑。  
* **核心代码片段**：
```cpp
vector<pair<int, int>> v1[100005], v2[100005]; // v1: 奇数位置，v2: 偶数位置
for (int i = 1; i <= n; i++) {
    if (i & 1) v1[color[i]].emplace_back(number[i], i);
    else v2[color[i]].emplace_back(number[i], i);
}
// 计算奇数组的贡献
for (int i = 1; i <= m; i++) {
    int siz = v1[i].size();
    if (siz < 2) continue;
    long long sum_a = 0, sum_b = 0;
    for (auto &p : v1[i]) {
        sum_a = (sum_a + p.first) % MOD;
        sum_b = (sum_b + p.second) % MOD;
    }
    ans = (ans + sum_a * sum_b % MOD) % MOD;
    for (auto &p : v1[i]) {
        ans = (ans + (siz - 2) % MOD * p.first % MOD * p.second % MOD) % MOD;
    }
}
```
* **代码解读**：  
  1. 用`v1`和`v2`分别存储奇数和偶数位置的格子（每个元素是`(number, 下标)`）；  
  2. 对每个颜色的奇数组，计算`sum_a`（number和）和`sum_b`（下标和），贡献是`sum_a*sum_b`；  
  3. 再计算每个格子的`(siz-2)*number*下标`，加到答案里。  
* 💡 **学习笔记**：分组存储可以让逻辑更直观，适合理解“为什么要按颜色+奇偶分类”！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看”到算法的每一步，我设计了一个**FC风格的像素动画**，像玩《超级马里奥》一样理解前缀和的积累过程！
</visualization_intro>

### 动画演示主题：像素纸带的“贡献计算之旅”  
- **风格**：8位像素风（仿FC《坦克大战》UI），颜色用红、蓝、绿区分不同颜色，奇数位置加黄色小星星，偶数位置加蓝色小方块。  
- **场景**：屏幕左侧是“纸带”（横向滚动的像素条），右侧是“统计面板”（显示当前颜色+奇偶的`cnt`和`sum_num`），底部是“控制面板”（开始/暂停、单步、速度滑块）。

### 动画帧步骤（以样例输入为例）  
1. **初始化**：纸带显示6个格子（编号1-6），颜色依次是2、2、1、1、2、1（对应样例输入），奇数位置（1、3、5）有星星，偶数位置（2、4、6）有方块。统计面板初始为0。  
2. **处理格子1（颜色2，奇数）**：  
   - 统计面板更新：颜色2-奇数的`cnt=1`，`sum_num=5`；  
   - 贡献计算：此时没有之前的格子，贡献为0；  
   - 音效：“叮”（更新统计）。  
3. **处理格子2（颜色2，偶数）**：  
   - 统计面板更新：颜色2-偶数的`cnt=1`，`sum_num=5`；  
   - 贡献：0；  
   - 音效：“叮”。  
4. **处理格子3（颜色1，奇数）**：  
   - 统计面板更新：颜色1-奇数的`cnt=1`，`sum_num=3`；  
   - 贡献：0；  
   - 音效：“叮”。  
5. **处理格子4（颜色1，偶数）**：  
   - 统计面板更新：颜色1-偶数的`cnt=1`，`sum_num=2`；  
   - 贡献：0；  
   - 音效：“叮”。  
6. **处理格子5（颜色2，奇数）**：  
   - 统计面板显示颜色2-奇数的`cnt=1`，`sum_num=5`；  
   - 贡献计算：`5×(5 - 2) + (1-1)×5×2 = 5×3 + 0 = 15`？不对，等一下，样例中的格子5的number是2，颜色2，奇数。之前的同组格子是1（number=5），所以贡献是`(1+5)×(5+2)=6×7=42`。动画中会用箭头指向格子1和5，旁边弹出“贡献+42”的气泡；  
   - 统计面板更新：颜色2-奇数的`cnt=2`，`sum_num=5+2=7`；  
   - 音效：“咚”（计算贡献）+“叮”（更新统计）。  
7. **处理格子6（颜色1，偶数）**：  
   - 统计面板显示颜色1-偶数的`cnt=1`，`sum_num=2`；  
   - 贡献计算：`(4+6)×(2+2)=10×4=40`，动画弹出“贡献+40”；  
   - 统计面板更新：颜色1-偶数的`cnt=2`，`sum_num=2+2=4`；  
   - 音效：“咚”+“叮”。  
8. **结束**：总贡献42+40=82，屏幕显示“胜利！得分82”，播放胜利音乐。

### 交互设计  
- **单步模式**：点击“下一步”，逐个处理格子，观察每一步的统计和贡献；  
- **自动播放**：滑动速度滑块调整播放速度（慢/中/快），看算法“自动跑”；  
- **重置**：回到初始状态，重新演示。

### 为什么这样设计？  
- 像素风格让你像玩游戏一样学算法，降低畏难情绪；  
- 统计面板的动态更新让你直观看到“前缀和是怎么积累的”；  
- 贡献的气泡提示让你明白“每个格子的贡献来自哪里”。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了“数学拆分+前缀和”的套路，我们可以解决很多类似的问题！
</similar_problems_intro>

### 通用思路迁移  
- 当问题需要“两两配对求和”时，先拆公式，找可以用前缀和维护的项；  
- 当条件涉及“分类”（比如颜色、奇偶、余数）时，用多维数组维护每类的统计信息。

### 洛谷练习推荐  
1. **洛谷 P1115 最大子段和**  
   - 🗣️ **推荐理由**：经典的前缀和优化问题，帮你巩固“用前缀和快速计算区间和”的思路。  
2. **洛谷 P1226 快速幂模板**  
   - 🗣️ **推荐理由**：虽然是快速幂，但涉及模运算的处理，和本题的模运算技巧一致。  
3. **洛谷 P1874 快速求和**  
   - 🗣️ **推荐理由**：需要拆分数字的各位和，用前缀和优化计算，锻炼“公式拆分”能力。  
4. **洛谷 P2089 烤鸡**  
   - 🗣️ **推荐理由**：虽然是枚举，但涉及分类统计，帮你理解“如何按条件分组”。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多题解作者分享了自己的踩坑经历，这些都是宝贵的经验！
</insights_intro>

> **参考经验（来自NewbieZZZ）**：“我一开始写暴力枚举，结果超时了。后来想到同颜色同奇偶的格子才能配对，又拆分了公式，才写出O(n)的代码。”  
> **点评**：这位作者的经历很典型——暴力是入门的第一步，但要想拿满分，必须学会“优化”。遇到超时问题时，先想“哪些计算是重复的？能不能用前缀和维护？”

> **参考经验（来自Victorique_De_Blois）**：“模运算时一定要处理负数，比如`(nt[c][g]-2 + MOD)%MOD`，否则会得到负数结果。”  
> **点评**：模运算的负数问题很容易忽略，这位作者的提醒帮你避免“明明思路对却WA”的悲剧！


<conclusion>
通过这道题，我们学会了“透过现象看本质”——把复杂的三元组问题转化为二元组问题，用数学拆分和前缀和优化计算。记住：**算法的本质是“找规律+偷懒”**——找到重复计算的部分，用前缀和“偷个懒”，就能让程序跑得更快！  

下次遇到类似的“两两配对求和”问题，记得先拆公式，再想前缀和哦~ 加油！💪
</conclusion>

---

---
处理用时：114.52秒
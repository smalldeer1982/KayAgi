# 题目信息

# [NOIP 2018 普及组] 对称二叉树

## 题目背景

NOIP2018 普及组 T4

## 题目描述

一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树： 

1.  二叉树； 
2.  将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。   

下图中节点内的数字为权值，节点外的 $id$ 表示节点编号。  

![](https://cdn.luogu.com.cn/upload/image_hosting/nkln7z1l.png)

现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数最多。请输出这棵子树的节点数。   

注意：只有树根的树也是对称二叉树。本题中约定，以节点 $T$ 为子树根的一棵“子 树”指的是：节点$T$ 和它的全部后代节点构成的二叉树。 

## 说明/提示

**样例 1 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/4lfen5aa.png)    
最大的对称二叉子树为以节点 $2$ 为树根的子树，节点数为 $1$。   

**样例 2 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/vhzzc587.png)

最大的对称二叉子树为以节点 $7$ 为树根的子树，节点数为 $3$。 

**数据规模与约定**

共 $25$ 个测试点。    

$v_i ≤ 1000$。 

- 测试点 $1 \sim 3, n ≤ 10$，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。 
- 测试点 $4 \sim 8, n ≤ 10$。
- 测试点 $9 \sim 12, n ≤ 10^5$，保证输入是一棵“满二叉树” 。 
- 测试点 $13 \sim 16, n ≤ 10^5$，保证输入是一棵“完全二叉树”。
- 测试点 $17 \sim 20, n ≤ 10^5$，保证输入的树的点权均为 $1$。
- 测试点 $21 \sim 25, n ≤ 10^6$。

本题约定： 

层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 $1$。 
 
 树的深度：树中节点的最大层次称为树的深度。 
 
 满二叉树：设二叉树的深度为 $h$，且二叉树有 $2^h-1$ 个节点，这就是满二叉树。  

![](https://cdn.luogu.com.cn/upload/image_hosting/8tof1fxx.png)

完全二叉树：设二叉树的深度为 $h$，除第 $h$ 层外，其它各层的结点数都达到最大 个数，第 $h$ 层所有的结点都连续集中在最左边，这就是完全二叉树。  

![](https://cdn.luogu.com.cn/upload/image_hosting/ibo7js1f.png)

## 样例 #1

### 输入

```
2 
1 3 
2 -1 
-1 -1 
```

### 输出

```
1```

## 样例 #2

### 输入

```
10 
2 2 5 5 5 5 4 4 2 3 
9 10 
-1 -1 
-1 -1 
-1 -1 
-1 -1 
-1 2 
3 4 
5 6 
-1 -1 
7 8```

### 输出

```
3```

# AI分析结果

# 💡 Kay的C++算法解析：对称二叉树 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：递归与树的遍历  

🗣️ **初步分析**：  
解决“对称二叉树”的关键，在于理解**递归的“分治思想”**和**树的遍历技巧**。递归就像“剥洋葱”——把判断整棵树的对称问题，分解成判断左右子树的对称问题；而树的遍历则是“按顺序清点节点”，帮助我们提前计算子树大小（比如后序遍历：先算左右子树，再加自己）。  

在本题中，递归的核心逻辑是**“镜像比较”**：判断节点A的左子树是否和节点B的右子树对称，同时节点A的右子树是否和节点B的左子树对称（就像照镜子，左边的左边要和右边的右边对齐）。而树的遍历则用于**预处理子树大小**——只有当左右子树大小相等时，才需要进一步判断对称（剪枝优化）。  

### 可视化设计思路  
我们将用**8位像素风格**（类似FC红白机）展示树的结构：  
- 用不同颜色的像素块表示节点（根节点红、左右子节点蓝）；  
- 高亮当前比较的“镜像节点对”（比如节点2的左和节点3的右）；  
- 用动画展示递归的“深入”与“回溯”（比如箭头从父节点指向子节点）；  
- 加入**复古音效**：比较节点时“叮”、对称时“滴”、不对称时“咚”，胜利时播放8位风格的“通关音乐”。  


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、算法效率**三个维度筛选了3份优质题解，覆盖了“暴力递归”“剪枝优化”“哈希高效”三种典型思路：
</eval_intro>

### 题解一：暴力递归（来源：wsm52）  
* **点评**：这份题解的思路“直戳本质”——直接枚举每个节点，递归判断其左右子树是否对称。代码极其简洁（不到50行），变量命名直观（`l[]`存左子树、`r[]`存右子树、`son[]`存子树大小），边界条件处理得非常严谨（比如“两个节点都为空→对称”“一个为空→不对称”“权值不同→不对称”）。对于初学者来说，这是**理解核心逻辑的最佳入门题解**。


### 题解二：剪枝优化（来源：WsW_）  
* **点评**：在暴力递归的基础上，这份题解加入了**子树大小剪枝**——先判断左右子树的大小是否相等，不相等直接跳过递归。这一步优化将时间复杂度从理论上的`O(n²)`降到了`O(n log n)`（比如满二叉树的递归次数会被限制在`log n`层）。代码结构清晰，剪枝逻辑自然，是**优化暴力算法的典型范例**。


### 题解三：哈希高效（来源：何俞均）  
* **点评**：这份题解的思路非常巧妙——用**欧拉序+哈希**将树的结构转化为“字符串”，通过比较哈希值判断对称。具体来说：  
  1. 第一次DFS按“左→右→根”记录欧拉序（记录节点的进入/离开时间）；  
  2. 第二次DFS按“右→左→根”记录另一版欧拉序；  
  3. 比较两次欧拉序的哈希值（包括权值和结构），若相等则对称。  
这种方法的时间复杂度是`O(n)`，适合处理`1e6`级别的大数据，是**高效解法的代表**。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点在于“如何正确递归判断对称”和“如何优化效率”。结合优质题解，我总结了3个关键问题及解决方案：
</difficulty_intro>

### 1. 关键点1：如何判断子树对称？  
- **分析**：递归的核心是“镜像比较”——用两个参数`a`（左子树当前节点）和`b`（右子树当前节点），依次判断：  
  1. 都为空→对称（`return true`）；  
  2. 一个为空→不对称（`return false`）；  
  3. 权值不同→不对称（`return false`）；  
  4. 递归判断`a的左`与`b的右`、`a的右`与`b的左`（交叉对称）。  
- 💡 **学习笔记**：递归的参数设计要“贴合问题本质”——用两个参数表示“镜像的两个节点”，比单参数更清晰。


### 2. 关键点2：如何高效计算子树大小？  
- **分析**：用**后序遍历**（左→右→根）预处理每个节点的子树大小：  
  ```cpp
  void calc_size(int x) {
      if (x == -1) return;
      son[x] = 1; // 自己
      calc_size(l[x]); // 左子树
      calc_size(r[x]); // 右子树
      son[x] += son[l[x]] + son[r[x]]; // 合并
  }
  ```  
  后序遍历的特点是“先处理子节点，再处理父节点”，刚好适合计算子树大小。  
- 💡 **学习笔记**：后序遍历是“子树相关问题”的黄金搭档（比如求子树节点数、树的高度）。


### 3. 关键点3：如何优化暴力递归的效率？  
- **分析**：加入**必要条件剪枝**——只有当左右子树的大小相等时，才需要递归判断对称。因为“对称的子树大小一定相等”，提前排除大小不等的情况，可以节省大量递归时间。  
- 💡 **学习笔记**：剪枝的关键是找到“必要条件”——不满足这个条件，就不可能是解。比如本题的“子树大小相等”就是对称的必要条件。


### ✨ 解题技巧总结  
1. **问题分解**：将大问题拆成小问题（整棵树→左右子树→更小的子树）；  
2. **预处理**：提前计算子树大小，避免重复计算；  
3. **剪枝优化**：用必要条件过滤无效情况；  
4. **边界处理**：仔细考虑“空节点”的情况（容易遗漏的坑！）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**——综合了暴力递归和剪枝优化，适合初学者理解整体框架：
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码来自wsm52的题解，调整了空节点的处理（将`-1`转为`0`，避免数组越界），保持了核心逻辑的简洁性。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <algorithm>
  using namespace std;

  const int N = 1e6 + 10;
  int n, v[N], l[N], r[N], son[N], ans = 1;

  // 计算子树大小（后序遍历）
  void calc_size(int x) {
      if (x == 0) return; // 空节点（原-1）
      son[x] = 1;
      calc_size(l[x]);
      calc_size(r[x]);
      son[x] += son[l[x]] + son[r[x]];
  }

  // 判断a和b是否对称（镜像比较）
  bool is_symmetric(int a, int b) {
      if (a == 0 && b == 0) return true;  // 都为空
      if (a == 0 || b == 0) return false; // 一个为空
      if (v[a] != v[b]) return false;     // 权值不同
      // 交叉递归：a的左 vs b的右，a的右 vs b的左
      return is_symmetric(l[a], r[b]) && is_symmetric(r[a], l[b]);
  }

  int main() {
      cin >> n;
      for (int i = 1; i <= n; ++i) cin >> v[i];
      for (int i = 1; i <= n; ++i) {
          cin >> l[i] >> r[i];
          if (l[i] == -1) l[i] = 0; // 空节点转0
          if (r[i] == -1) r[i] = 0;
      }
      calc_size(1); // 预处理子树大小
      for (int i = 1; i <= n; ++i) {
          if (is_symmetric(l[i], r[i])) { // 判断i的左右子树是否对称
              ans = max(ans, son[i]);     // 更新最大子树大小
          }
      }
      cout << ans << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **输入处理**：读取节点权值和左右子树；  
  2. **预处理**：用`calc_size`计算每个节点的子树大小；  
  3. **枚举判断**：遍历每个节点，用`is_symmetric`判断其左右子树是否对称；  
  4. **结果输出**：输出最大的对称子树大小。


### 针对各优质题解的片段赏析

#### 题解一（暴力递归）：核心逻辑片段  
* **亮点**：用最简洁的代码实现“镜像比较”。  
* **核心代码片段**：  
  ```cpp
  bool is_symmetric(int a, int b) {
      if (a == 0 && b == 0) return true;
      if (a == 0 || b == 0) return false;
      if (v[a] != v[b]) return false;
      return is_symmetric(l[a], r[b]) && is_symmetric(r[a], l[b]);
  }
  ```  
* **代码解读**：  
  这几行代码是本题的“灵魂”——依次处理边界条件，最后递归交叉比较。比如判断节点`a`和`b`对称，需要`a的左`等于`b的右`，同时`a的右`等于`b的左`（就像照镜子时，你的左手对应镜子里的右手）。  
* 💡 **学习笔记**：递归的边界条件要“全覆盖”——不要漏掉“都为空”或“一个为空”的情况。


#### 题解二（剪枝优化）：核心逻辑片段  
* **亮点**：加入子树大小剪枝，减少递归次数。  
* **核心代码片段**：  
  ```cpp
  bool check(int lp, int rp) {
      if (!lp && !rp) return 1;
      // 剪枝：子树大小不等→直接返回false
      if (size[lp] != size[rp] || v[lp] != v[rp]) return 0;
      return check(l[lp], r[rp]) & check(r[lp], l[rp]);
  }
  ```  
* **代码解读**：  
  在递归前，先检查`lp`和`rp`的子树大小是否相等。如果不等，说明它们不可能对称，直接返回`false`，避免了后续的递归计算。这一步剪枝能大幅减少递归次数（比如对于链状树，几乎不会进入递归）。  
* 💡 **学习笔记**：剪枝的关键是“找到必要条件”——比如对称的子树大小一定相等，所以大小不等的情况可以直接跳过。


#### 题解三（哈希高效）：核心逻辑片段  
* **亮点**：用欧拉序+哈希将树的结构转化为字符串，快速比较。  
* **核心代码片段**：  
  ```cpp
  // 第一次DFS：左→右→根，记录欧拉序的进入(L[x])和离开(R[x])
  void dfs(int x) {
      P[L[x] = ++cnt] = x;
      if (t[x].ch[0]) dfs(t[x].ch[0]);
      if (t[x].ch[1]) dfs(t[x].ch[1]);
      P[R[x] = ++cnt] = x;
      t[x].size = t[t[x].ch[0]].size + t[t[x].ch[1]].size + 1;
  }

  // 第二次DFS：右→左→根，记录另一版欧拉序
  void rdfs(int x) {
      P[rL[x] = ++cnt] = x;
      if (t[x].ch[1]) rdfs(t[x].ch[1]);
      if (t[x].ch[0]) rdfs(t[x].ch[0]);
      P[rR[x] = ++cnt] = x;
  }
  ```  
* **代码解读**：  
  第一次DFS按“左→右→根”遍历，记录每个节点的“进入时间”`L[x]`和“离开时间”`R[x]`（欧拉序）；第二次DFS按“右→左→根”遍历，记录`rL[x]`和`rR[x]`。然后通过比较两次欧拉序的哈希值（包括权值和结构），判断是否对称。这种方法将树的对称性转化为“字符串的回文问题”，时间复杂度`O(n)`。  
* 💡 **学习笔记**：哈希是处理“结构匹配”问题的利器——将复杂的结构转化为数值，便于快速比较。


## 5. 算法可视化：像素动画演示（核心部分）

<visualization_intro>
为了让大家更直观地理解“镜像比较”的过程，我设计了一个**8位像素风格的动画**——《像素树的镜像游戏》，模仿FC红白机的界面，加入复古音效和游戏化元素：
</visualization_intro>

### 动画设计细节  
* **风格与界面**：  
  - 用`16x16`的像素块表示节点（根节点红、左右子节点蓝、当前比较的节点黄）；  
  - 背景是浅灰色网格（类似FC的“迷宫”界面）；  
  - 控制面板在屏幕下方：有“开始/暂停”“单步”“重置”按钮，速度滑块（从“慢”到“快”）。  

* **核心动画流程**：  
  1. **初始化**：展示样例输入的树（比如样例2的树，根节点是1，左右子节点是9和10），节点下方显示子树大小（用像素数字）。  
  2. **计算子树大小**：用后序遍历的顺序，每个节点的大小逐渐“点亮”（比如从0变成3），伴随“沙沙”的音效。  
  3. **镜像比较**：  
     - 从根节点1开始，高亮其左右子节点9和10（黄色），播放“叮”的音效；  
     - 递归进入9的左（空）和10的右（空）——都为空，节点变绿，播放“滴”的音效；  
     - 递归进入9的右（空）和10的左（空）——都为空，节点变绿，播放“滴”的音效；  
     - 返回根节点1，判断其左右子树对称，更新最大子树大小为`son[1]`（显示在右上角）。  
  4. **继续枚举**：遍历节点2，其左右子树是-1和-1，对称，更新最大子树大小为1；  
  5. **完成**：遍历到节点7，其左右子树是3和4，大小相等（都为1），权值相等（都为5），递归判断3的左（空）和4的右（空）、3的右（空）和4的左（空）——对称，更新最大子树大小为3（样例2的正确结果）。  

* **游戏化元素**：  
  - **音效**：比较节点“叮”、对称“滴”、不对称“咚”、胜利“通关音乐”；  
  - **过关提示**：当找到最大对称子树时，屏幕闪烁“通关！最大节点数：3”；  
  - **自动演示**：点击“自动”按钮，动画像“贪吃蛇AI”一样逐步完成判断，速度可调。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
递归与树的遍历是编程中的“基础工具”，不仅能解决本题，还能处理很多其他问题。比如：
</similar_problems_intro>

### 通用思路迁移  
1. **求树的高度**：递归计算左右子树的高度，取最大值加1；  
2. **树形DP**：比如“没有上司的舞会”，递归计算子树的最大快乐值；  
3. **树的遍历序列**：比如“求先序排列”，用中序和后序遍历推导树的结构。


### 练习推荐（洛谷）  
1. **洛谷 P1030 求先序排列**  
   🗣️ **推荐理由**：给定中序和后序遍历，求先序遍历。练习树的遍历和递归，理解树的结构推导。  
2. **洛谷 P1352 没有上司的舞会**  
   🗣️ **推荐理由**：树形DP的经典题，求最大快乐值。练习后序遍历处理子树，合并子问题的解。  
3. **洛谷 P2058 海港**  
   🗣️ **推荐理由**：处理连续输入的时间窗口，练习队列的应用，培养逻辑思维（间接巩固递归的“顺序处理”思想）。  
4. **洛谷 P1449 后缀表达式**  
   🗣️ **推荐理由**：将中缀表达式转为后缀表达式，练习栈的应用（间接巩固递归的“栈帧”概念）。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我们能学到很多“实战经验”：
</insights_intro>

- **wsm52的经验**：“直接枚举每个节点，递归判断左右子树是否对称”——有时候最直接的思路反而有效，关键是处理好边界条件。  
- **WsW_的经验**：“用子树大小剪枝”——优化暴力算法的关键是找到“必要条件”，避免无效计算。  
- **何俞均的经验**：“用哈希转化问题”——将复杂的树结构转化为字符串，用哈希快速比较，是高效解决大数据问题的技巧。


## 总结  
本次分析的核心是**递归的镜像比较**和**树的后序遍历**。通过练习本题，你能掌握“分治思想”“预处理技巧”和“剪枝优化”。记住：编程的本质是“解决问题”，而不是“写复杂的代码”——简洁有效的思路往往是最好的！  

下次我们再一起探索更多编程挑战吧！💪

---
处理用时：191.27秒
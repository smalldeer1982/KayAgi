# 题目信息

# [NOIP2020] 排水系统

## 题目描述

对于一个城市来说，排水系统是极其重要的一个部分。

有一天，小 C 拿到了某座城市排水系统的设计图。排水系统由 $n$ 个排水结点（它们从 $1 \sim n$ 编号）和若干个单向排水管道构成。每一个排水结点有若干个管道用于汇集其他排水结点的污水（简称为该结点的汇集管道），也有若干个管道向其他的排水结点排出污水（简称为该结点的排出管道）。

排水系统的结点中有 $m$ 个污水接收口，它们的编号分别为 $1, 2, \ldots , m$，污水只能从这些接收口流入排水系统，并且这些结点没有汇集管道。排水系统中还有若干个最终排水口，它们将污水运送到污水处理厂，没有排出管道的结点便可视为一个最终排水口。

现在各个污水接收口分别都接收了 $1$ 吨污水，污水进入每个结点后，会均等地从当前结点的每一个排出管道流向其他排水结点，而最终排水口将把污水排出系统。

现在小 C 想知道，在该城市的排水系统中，每个最终排水口会排出多少污水。该城市的排水系统设计科学，管道不会形成回路，即不会发生污水形成环流的情况。

## 说明/提示

**【样例 #1 解释】**

$1$ 号结点是接收口，$4, 5$ 号结点没有排出管道，因此是最终排水口。  
$1$ 吨污水流入 $1$ 号结点后，均等地流向 $2, 3, 5$ 号结点，三个结点各流入 $\frac{1}{3}$ 吨污水。  
$2$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
$3$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
最终，$4$ 号结点排出 $\frac{1}{6} + \frac{1}{6} = \frac{1}{3}$ 吨污水，$5$ 号结点排出 $\frac{1}{3} + \frac{1}{6} + \frac{1}{6} = \frac{2}{3}$ 吨污水。

**【数据范围】**

| 测试点编号 | $n \le$ | $m \le$ |
|:-:|:-:|:-:|
| $1 \sim 3$ | $10$ | $1$ |
| $4 \sim 6$ | ${10}^3$ | $1$ |
| $7 \sim 8$ | ${10}^5$ | $1$ |
| $9 \sim 10$ | ${10}^5$ | $10$ |

对于全部的测试点，保证 $1 \le n \le {10}^5$，$1 \le m \le 10$，$0 \le d_i \le 5$。

数据保证，污水在从一个接收口流向一个最终排水口的过程中，不会经过超过 $10$ 个中间排水结点（即接收口和最终排水口不算在内）。

## 样例 #1

### 输入

```
5 1
3 2 3 5
2 4 5
2 5 4
0
0
```

### 输出

```
1 3
2 3
```

## 样例 #2

### 输入

```
见附件中的 water/water2.in```

### 输出

```
见附件中的 water/water2.ans```

## 样例 #3

### 输入

```
见附件中的 water/water3.in```

### 输出

```
见附件中的 water/water3.ans```

# AI分析结果

---
# 💡 Kay的C++算法解析：排水系统 深入学习指南 💡

<introduction>
  今天我们来一起分析NOIP2020的经典题目——**排水系统**。这道题结合了**拓扑排序**和**分数运算**，既能帮大家巩固图论基础，又能锻炼处理大数的技巧。跟着Kay一步步拆解，你会发现它其实像“污水按顺序流”一样自然～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：拓扑排序（Topological Sort）+ 分数高精度运算

🗣️ **初步分析**：
解决“排水系统”的关键，在于理解**污水的流动顺序**——污水必须从上游节点（比如接收口）流到下游节点，不能倒流（题目说没有环）。这正好符合**拓扑排序**的核心思想：**按依赖顺序处理节点**（比如，处理节点A前，必须先处理完所有能流到A的节点）。

打个比方：拓扑排序就像“食堂打饭”——你得等前面的同学打完，才能轮到你；污水也得等所有上游的水都流过来，才能往下分流。

### 核心算法流程
1. **建图**：用邻接表存储排水管道的流向（节点u→v表示u的污水会流到v）。
2. **初始化**：前m个接收口的污水量是1吨（分数形式为`1/1`），入度为0的节点（接收口）加入队列。
3. **拓扑处理**：
   - 取出队首节点u，计算它要分流的污水量（`当前量 / 出度`）。
   - 将这部分污水加到所有下游节点v的污水量中。
   - v的入度减1，若入度变为0（所有上游水都到齐了），就加入队列。
4. **输出结果**：所有出度为0的节点（最终排水口）的污水量，化简为最简分数。

### 可视化设计思路
我打算做一个**FC红白机风格**的像素动画，帮你“看”到污水流动：
- **场景**：8位像素的节点网格（接收口蓝色、排水口红色、普通节点绿色），边用箭头表示。
- **动画步骤**：
  1. 初始时，接收口（比如节点1）闪烁，显示`1/1`。
  2. 点击“单步”，节点1的污水均分流向出边（比如节点2、3、5），箭头会“流动”，下游节点显示新增的分数（比如`1/3`）。
  3. 节点2的入度变为0，加入队列（右侧队列区显示节点2）。
- **音效**：入队时“叮”一声，分流时“滴”一声，完成时“叮咚”庆祝～


---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度，筛选了3份优质题解。它们的核心都是拓扑排序，但在分数处理上各有亮点，适合不同阶段的学习者～
</eval_intro>

**题解一：听取MLE声一片（赞30）**
* **点评**：这份题解把拓扑排序的逻辑写得特别直白！作者用`vector`存图，`in`数组记人度，`out`数组记出度，队列处理拓扑顺序。分数运算用`xx`（分子）和`yy`（分母）数组，通分后用`gcd`化简——完全贴合题目的数学逻辑。美中不足是没写高精度，但作者贴心提醒了“需自行添加”，适合刚学拓扑的同学入门。

**题解二：hensier（赞11）**
* **点评**：作者的亮点是用`__int128`解决了分数溢出问题！要知道，C++的`long long`只能存到`9e18`，而题目中的分母可能达到`5^11`，`__int128`能存到`1e38`，完美覆盖。另外，`update`函数把分数加减写得很清晰：先求最小公倍数（LCM）通分，再加分子，最后约分——这就是分数运算的标准步骤！

**题解三：normalpcer（赞3）**
* **点评**：这份题解的代码最“优雅”！作者用`Frac`结构体封装了分数的加法、除法和化简，把复杂的分数运算变成了“结构体操作”。比如`Frac operator+`重载了加法，`simplified`函数负责约分——这种模块化写法特别适合竞赛，也能帮你养成良好的代码习惯。


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在**顺序**和**大数**上。结合优质题解，我总结了3个核心难点和解决方法：
</difficulty_intro>

1. **难点1：如何保证节点处理顺序正确？**
   * **分析**：如果先处理下游节点，上游的污水还没流过来，结果肯定错。解决方法是**拓扑排序**——只有入度为0的节点（所有上游水都到齐了）才能处理。
   * 💡 **学习笔记**：拓扑排序是处理DAG（无环有向图）的“黄金法则”，核心是“入度为0则处理”。

2. **难点2：分数运算如何避免溢出？**
   * **分析**：题目中的分母可能很大（比如10层节点，每层分5份，分母是`5^10=9,765,625`），`long long`根本存不下。解决方法有两种：
     - 用`__int128`（GCC支持，不用写高精度）；
     - 手写高精度（适合NOIP，但代码复杂）。
   * 💡 **学习笔记**：`__int128`是“偷懒神器”，但要记得手写输入输出（因为C++标准库不支持）。

3. **难点3：如何化简分数？**
   * **分析**：每次分数相加后，必须用**最大公约数（gcd）**化简，否则分子分母会越来越大，最后溢出。比如`1/3 + 1/3 = 2/3`（已经化简），而不是`2/6`。
   * 💡 **学习笔记**：分数运算的“铁律”——加减乘除后都要除以gcd！


### ✨ 解题技巧总结
- **技巧1：邻接表存图**：对于`1e5`个节点，`vector`存图比二维数组更省空间。
- **技巧2：分数用两个数组存储**：分子`zi[]`、分母`mu[]`，比结构体更直观（适合新手）。
- **技巧3：快读快写**：`__int128`不能用`cin/cout`，必须手写快读（读字符转数字）和快写（递归输出数字）。


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**——结合了拓扑排序、`__int128`和分数化简，能直接解决题目问题～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合了hensier和normalpcer的思路，用`__int128`处理大数，分数运算清晰易懂。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <algorithm>
  using namespace std;
  typedef __int128 ll; // 用__int128存大数

  const int N = 1e5 + 5;
  vector<int> g[N]; // 邻接表存图
  int in[N], out[N]; // in:入度，out:出度
  ll zi[N], mu[N]; // zi:分子，mu:分母
  queue<int> q;

  // __int128的快读
  ll read() {
    ll x = 0; char ch = getchar();
    while (ch < '0' || ch > '9') ch = getchar();
    while (ch >= '0' && ch <= '9') x = x * 10 + (ch - '0'), ch = getchar();
    return x;
  }

  // __int128的快写
  void write(ll x) {
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
  }

  // 求最大公约数（化简分数用）
  ll gcd(ll a, ll b) {
    return b == 0 ? a : gcd(b, a % b);
  }

  // 分数相加：a = a + b/(out[u])
  void update(int a, ll b_zi, ll b_mu, int out_u) {
    ll new_mu = mu[a] * b_mu * out_u; // 新分母：a的分母 * b的分母 * 出度
    ll new_zi = zi[a] * b_mu * out_u + b_zi * mu[a]; // 新分子：a的分子*... + b的分子*...
    ll g = gcd(new_zi, new_mu); // 化简
    zi[a] = new_zi / g;
    mu[a] = new_mu / g;
  }

  int main() {
    int n = (int)read(), m = (int)read();
    for (int i = 1; i <= n; i++) {
      int d = (int)read();
      out[i] = d;
      for (int j = 1; j <= d; j++) {
        int v = (int)read();
        g[i].push_back(v);
        in[v]++;
      }
      mu[i] = 1; // 分母初始化为1
    }

    // 初始化接收口：前m个节点，zi=1，mu=1
    for (int i = 1; i <= m; i++) {
      zi[i] = 1;
      q.push(i);
    }

    // 拓扑排序
    while (!q.empty()) {
      int u = q.front(); q.pop();
      if (out[u] == 0) continue; // 排水口，不用分流
      // 计算u要分流的量：zi[u]/(mu[u] * out[u])
      for (int v : g[u]) {
        update(v, zi[u], mu[u], out[u]);
        in[v]--;
        if (in[v] == 0) q.push(v);
      }
    }

    // 输出排水口的结果
    for (int i = 1; i <= n; i++) {
      if (out[i] == 0) {
        write(zi[i]); putchar(' ');
        write(mu[i]); putchar('\n');
      }
    }
    return 0;
  }
  ```
* **代码解读概要**：
  1. **输入处理**：用邻接表存图，记录每个节点的入度和出度。
  2. **初始化**：前m个接收口的分数是`1/1`，加入队列。
  3. **拓扑循环**：取出节点u，将污水分流到所有下游v，更新v的分数，入度减1后入队。
  4. **输出**：遍历所有出度为0的节点，输出最简分数。


<code_intro_selected>
接下来看优质题解的**核心片段**，学习它们的亮点～
</code_intro_selected>

**题解二：hensier（__int128分数处理）**
* **亮点**：用`__int128`完美解决大数问题，分数加减函数逻辑清晰。
* **核心代码片段**：
  ```cpp
  void update(I128 &x_1, I128 &y_1, I128 x_2, I128 y_2) {
    I128 p = y_1 * y_2 / gcd(y_1, y_2); // 求LCM通分
    x_1 *= p / y_1;
    x_2 *= p / y_2;
    x_1 += x_2;
    y_1 = p;
  }
  ```
* **代码解读**：
  这个函数是**分数加法的标准实现**！比如要加`a/b`和`c/d`：
  1. 先求分母的最小公倍数`p = LCM(b,d)`（用`b*d/gcd(b,d)`计算）。
  2. 分子分别扩大到`a*(p/b)`和`c*(p/d)`。
  3. 相加后的分子是`a*(p/b) + c*(p/d)`，分母是`p`。
* 💡 **学习笔记**：分数加法的关键是“通分”，而LCM是通分的核心！

**题解三：normalpcer（结构体封装分数）**
* **亮点**：用`Frac`结构体封装分数运算，代码更模块化。
* **核心代码片段**：
  ```cpp
  struct Frac {
    i128 numerator; // 分子
    i128 denominator = 1; // 分母

    static Frac simplified(const Frac& origin) {
      auto g = gcd(origin.numerator, origin.denominator);
      return {origin.numerator / g, origin.denominator / g};
    }

    Frac operator+ (const Frac& other) const {
      return simplified({
        numerator * other.denominator + other.numerator * denominator,
        denominator * other.denominator
      });
    }

    Frac operator/ (const int other) const {
      return simplified({numerator, other * denominator});
    }
  };
  ```
* **代码解读**：
  - `simplified`函数负责化简分数（除以gcd）。
  - `operator+`重载了加法，直接返回化简后的结果。
  - `operator/`重载了除以整数（比如分流时除以出度）。
* 💡 **学习笔记**：结构体封装能让代码更简洁，比如`a + b`直接表示分数相加，比数组操作更直观！


---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了帮你“看”懂拓扑排序的流程，我设计了一个**FC红白机风格**的像素动画！像玩《超级马里奥》一样，跟着污水流动的节奏学习～
</visualization_intro>

### 动画设计细节
- **整体风格**：8位像素（仿FC游戏），配色用经典的红、蓝、绿、黄，界面简洁。
- **场景布局**：
  1. **左侧**：节点网格（5x5像素块），接收口（蓝色）、排水口（红色）、普通节点（绿色）。
  2. **右侧**：拓扑队列（显示待处理的节点）、分数显示区（当前节点的污水量）。
  3. **底部**：控制面板（单步、自动、重置按钮，速度滑块）。

### 关键动画步骤（以样例1为例）
1. **初始化**：
   - 节点1（接收口）蓝色闪烁，分数显示`1/1`。
   - 队列显示`[1]`。
   - 背景音乐：8位风格的轻快旋律（类似《坦克大战》）。

2. **单步执行（处理节点1）**：
   - 节点1的出边（到2、3、5）出现“流动”动画（白色箭头向右移动）。
   - 节点2、3、5的分数变为`1/3`（绿色闪烁）。
   - 节点1从队列消失，节点2、3、5的入度变为0，加入队列（队列显示`[2,3,5]`）。
   - 音效：“叮”（入队） + “滴”（分流）。

3. **处理节点2**：
   - 节点2的出边（到4、5）流动，节点4、5的分数各加`1/6`（变为`1/6`和`1/3+1/6=1/2`）。
   - 节点2出队，节点4的入度变为0，加入队列。
   - 音效：“滴”（分流）。

4. **完成**：
   - 节点4、5（排水口）红色闪烁，分数显示`1/3`和`2/3`。
   - 音效：“叮咚”（胜利），屏幕弹出“完成！”的像素文字。

### 交互设计
- **单步执行**：点击一次，处理一个节点，适合仔细观察。
- **自动播放**：按设定速度（滑块调节）连续执行，适合看整体流程。
- **重置**：回到初始状态，重新演示。


<visualization_conclusion>
这个动画把抽象的拓扑排序变成了“看得见的污水流动”！你可以一边玩一边记：**蓝色是起点，绿色是中间节点，红色是终点，队列是待处理的节点**——是不是很简单？
</visualization_conclusion>


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
拓扑排序是图论的“基础工具”，除了排水系统，还能解决很多问题。比如：
</similar_problems_intro>

### 通用思路迁移
- **任务调度**：比如安排课程顺序（先学高数才能学线代）。
- **依赖安装**：比如安装软件时，先装依赖的库。
- **编译器优化**：比如编译代码时，先处理被调用的函数。

### 洛谷练习推荐
1. **洛谷 P1038** - 神经网络
   * 🗣️ **推荐理由**：经典拓扑排序题，需要处理节点的“激活值”，和排水系统的“污水量”逻辑类似，能巩固拓扑顺序的理解。
   
2. **洛谷 P1983** - 车站分级
   * 🗣️ **推荐理由**：需要先建图（根据车站等级关系），再拓扑排序求等级，能锻炼“问题建模”能力。
   
3. **洛谷 P1137** - 旅行计划
   * 🗣️ **推荐理由**：拓扑排序+动态规划（DP），求从起点到各点的最长路径，能拓展拓扑排序的应用场景。


---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多题解作者分享了自己的“踩坑”经历，这些经验比代码更值钱！
</insights_intro>

> **参考经验（来自Legitimity）**：“赛场上我先用long long写，结果只得了90分——后来才发现分母会爆long long！最后用__int128水过去了～”
>
> **点评**：这个教训太真实了！题目中的分母可能很大（比如10层节点，每层分5份，分母是5^10=9,765,625），long long根本存不下。**遇到大数问题，优先考虑__int128（如果允许的话），实在不行再手写高精度**。


---

<conclusion>
本次关于“排水系统”的分析就到这里啦！这道题的核心是**拓扑排序**——按依赖顺序处理节点，再加上**分数运算**——用__int128或高精度避免溢出。记住：**编程的关键是“模拟现实逻辑”**，污水要按顺序流，代码也要按顺序写～

下次我们再一起探索更有趣的算法问题！💪
</conclusion>

---

---
处理用时：126.56秒
# 题目信息

# [NOI Online 2021 提高组] 积木小赛

## 题目描述

Alice 和 Bob 最近热衷于玩一个游戏——积木小赛。

Alice 和 Bob 初始时各有 $n$ 块积木从左至右排成一排，每块积木都被标上了一个英文小写字母。

Alice 可以从自己的积木中丢掉任意多块（也可以不丢）；Bob 可以从自己的积木中丢掉最左边的一段连续的积木和最右边的一段连续的积木（也可以有一边不丢或者两边都不丢）。两人都不能丢掉自己所有的积木。然后 Alice 和 Bob 会分别将自己剩下的积木按原来的顺序重新排成一排。

Alice 和 Bob 都忙着去玩游戏了，于是想请你帮他们算一下，有多少种不同的情况下他们最后剩下的两排积木是相同的。

两排积木相同，当且仅当这两排积木块数相同且每一个位置上的字母都对应相同。

两种情况不同，当且仅当 Alice（或者 Bob）剩下的积木在两种情况中不同。

## 说明/提示

对于所有测试点：$1\le n \le 3000$，$s$ 与 $t$ 中只包含英文小写字母。

测试点 $1$ 满足：$n\le3000$，$s$ 与 $t$ 中只包含同一种字母。

测试点 $2,3,4$ 满足：$n\le100$。

测试点 $5,6,7$ 满足：$n\le500$。

测试点 $8,9,10$ 满足：$n\le3000$。

感谢 [w33z8kqrqk8zzzx33](https://www.luogu.com.cn/user/220037) 提供测试数据。

## 样例 #1

### 输入

```
5
bcabc
bbcca```

### 输出

```
9```

## 样例 #2

### 输入

```
20
egebejbhcfabgegjgiig
edfbhhighajibcgfecef```

### 输出

```
34```

# AI分析结果

# 💡 Kay的C++算法解析：积木小赛 深入学习指南 💡

今天我们来一起分析NOI Online 2021提高组的“积木小赛”问题。这道题结合了**子序列匹配**和**子串去重**两大字符串核心技巧，是锻炼字符串处理能力的好题目！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：字符串（子序列自动机/贪心匹配 + 子串去重）

🗣️ **初步分析**：  
题目要求我们找出**Bob的字符串中所有本质不同的子串**，且这些子串必须是**Alice字符串的子序列**。简单来说，就是“从Bob的连续串里挑，从Alice的零散串里找，找相同且不重复的串”。  

### 核心算法的比喻理解
- **子序列匹配**：就像Alice给了一串“字母钥匙”，Bob拿了一串“连续钥匙”，我们要检查Bob的每一段连续钥匙能不能从Alice的钥匙串里**按顺序挑出来**（不要求连续）。比如Alice的钥匙是`b c a b c`，Bob的连续钥匙是`b b c`，我们可以从Alice里挑第1、4、5位的`b b c`，所以匹配成功。  
- **子串去重**：Bob的子串可能有很多重复（比如`b`出现多次），我们需要像整理“单词本”一样，把相同的子串只算一次。

### 题解的共性思路
几乎所有题解都遵循两个步骤：  
1. **枚举Bob的子串**：遍历Bob字符串的所有连续子串（起点`i`，终点`j`从`i`到`n`）。  
2. **判断是否是Alice的子序列**：用**贪心指针**（从Alice头开始找当前字符）或**子序列自动机**（预处理Alice的“导航地图”，快速找下一个字符的位置）。  
3. **去重**：用**哈希**（把字符串转成数字，排序去重）或**后缀自动机（SAM）**（压缩所有子串，自动去重）。

### 可视化设计思路
我们会设计一个**复古像素风动画**，模拟“Bob挑子串+Alice找子序列”的过程：  
- 左边是Alice的字符串（每个字符是一个彩色像素块），右边是Bob的字符串。  
- 枚举Bob的子串时，右边的子串会**高亮闪烁**；左边的“指针像素”会跟着移动，匹配成功的字符会**变亮**。  
- 去重时，会显示一个“哈希背包”，存入的哈希值用小方块表示，相同的方块会**合并**。  
- 加入复古音效：匹配成功“叮”一声，存入哈希“嗒”一声，最终统计“叮铃”一声。


## 2. 精选优质题解参考

为大家筛选了3份**思路清晰、代码高效**的题解，覆盖了不同的核心技巧：

### 题解一：贪心指针+哈希去重（作者：syksykCCC）
* **点评**：  
  这是题解区最简洁的实现！核心思路是“枚举Bob子串+贪心匹配+哈希去重”：  
  - 枚举Bob的子串起点`i`，用指针`p`在Alice中**贪心找下一个字符**（每次找最早出现的位置，保证后续有更多选择）。  
  - 用哈希将子串转成`long long`，最后排序去重统计数量。  
  代码风格极简，变量名清晰（`a`是Alice，`b`是Bob，`t`存哈希值），时间复杂度`O(n² log n)`（排序的代价），完全能通过`n=3000`的测试点。

### 题解二：子序列自动机+哈希（作者：Karry5307）
* **点评**：  
  这份题解用**子序列自动机**优化了匹配过程！子序列自动机是Alice字符串的“导航地图”——`nxt[i][c]`表示Alice中第`i`位之后，字符`c`第一次出现的位置。这样匹配Bob的子串时，只需要**按导航跳**，不需要从头扫Alice，速度更快！  
  去重部分用了**双哈希**（两个不同的模数），避免哈希冲突，更可靠。代码中的`HashTable`是手写哈希表，比`STL map`快很多，适合大数据量。

### 题解三：子序列自动机+SAM（作者：滑大稽）
* **点评**：  
  这是最“高级”的解法！用**后缀自动机（SAM）**处理Bob的子串去重——SAM能把Bob的所有子串压缩成`O(n)`个状态，每个状态代表一组相同后缀的子串，自动去重。然后用**BFS同步遍历两个自动机**：从SAM的起点和子序列自动机的起点出发，只要两个自动机都有相同的字符转移，就继续遍历，统计所有可达的状态数（即不同的子串数）。  
  这种方法时间复杂度`O(n²)`，效率极高，而且代码很优雅，适合学习字符串自动机的结合应用。


## 3. 核心难点辨析与解题策略

### 关键点1：如何高效判断Bob的子串是Alice的子序列？
- **问题**：直接暴力扫Alice每次找字符，时间复杂度`O(n³)`（枚举子串`O(n²)`，每次匹配`O(n)`），会超时！  
- **解决**：用**贪心指针**或**子序列自动机**：  
  1. 贪心指针：枚举Bob的子串时，用一个指针`p`在Alice中**从左到右找当前字符**（比如Bob的子串是`b[j]`，`p`从上次的位置继续找`a[p...]`中的`b[j]`）。这样每个子串的匹配是**线性的**，总时间`O(n²)`。  
  2. 子序列自动机：预处理`nxt[i][c]`表示Alice中第`i`位之后字符`c`的最早位置。匹配时，只需`p = nxt[p][b[j]]`，一步到位，时间`O(1)` per字符。

💡 **学习笔记**：贪心匹配是子序列问题的“万金油”，子序列自动机是它的“加速版”！

### 关键点2：如何高效去重Bob的子串？
- **问题**：Bob的子串有`O(n²)`个（3000*3000=9e6），直接存字符串会爆内存！  
- **解决**：用**哈希**或**SAM**：  
  1. 哈希：把字符串转成一个大数（比如`(hash * BASE + c) % MOD`），存哈希值数组，最后排序去重（`unique`函数）。  
  2. SAM：后缀自动机是处理子串去重的“神器”——它能将所有不同的子串压缩成`O(n)`个状态，每个状态对应一组相同后缀的子串，遍历SAM的路径就能得到所有不同的子串。

💡 **学习笔记**：哈希是“暴力去重”，SAM是“智能去重”，根据题目选择！

### 关键点3：如何平衡时间与空间复杂度？
- **问题**：`n=3000`时，`O(n²)`的算法是可行的，但`O(n² log n)`的排序会不会超时？  
- **解决**：  
  - 哈希去重的排序：`9e6`个元素排序大约需要`9e6 * log(9e6) ≈ 9e6 * 23 ≈ 2e8`次操作，这在C++中是可以通过的（每秒能处理约1e8次操作）。  
  - SAM的构建：`O(n)`时间，遍历状态是`O(n²)`，完全没问题。

💡 **学习笔记**：时间复杂度的“常数”很重要，C++的效率比Python高很多！


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（贪心+哈希）
* **说明**：综合syksykCCC的题解，代码简洁，覆盖核心逻辑。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3005, BASE = 51971;
const long long MOD = 2005091020050911; // 大模数避免冲突
int n;
char a[N], b[N];
long long hash_list[N * N]; // 存所有合法子串的哈希值

int main() {
    scanf("%d %s %s", &n, a + 1, b + 1);
    int cnt = 0;
    for (int i = 1; i <= n; ++i) { // 枚举Bob子串的起点i
        long long current_hash = 0;
        int p = 1; // Alice的指针，从第1位开始
        for (int j = i; j <= n; ++j) { // 枚举Bob子串的终点j
            // 在Alice中找b[j]，从p开始
            while (p <= n && a[p] != b[j]) ++p;
            if (p > n) break; // 找不到，后面的子串也不用看了
            ++p; // 下一次从p+1开始找
            // 计算当前子串b[i..j]的哈希值
            current_hash = (current_hash * BASE + (b[j] - 'a' + 1)) % MOD;
            hash_list[++cnt] = current_hash;
        }
    }
    // 排序去重
    sort(hash_list + 1, hash_list + cnt + 1);
    int ans = unique(hash_list + 1, hash_list + cnt + 1) - hash_list - 1;
    printf("%d\n", ans);
    return 0;
}
```
* **代码解读概要**：  
  1. **输入处理**：读入`n`、Alice的字符串`a`、Bob的字符串`b`。  
  2. **枚举Bob子串**：外层循环`i`是子串起点，内层循环`j`是终点。  
  3. **贪心匹配**：用指针`p`在Alice中找`b[j]`，找到后`p`后移（保证后续字符能找到）。  
  4. **哈希计算**：将子串`b[i..j]`转成哈希值，存入数组。  
  5. **去重统计**：排序后用`unique`去重，统计不同的哈希值数量（即答案）。

### 题解二（子序列自动机+哈希）核心片段赏析
* **亮点**：子序列自动机加速匹配，双哈希避免冲突。
* **核心代码片段**：
```cpp
// 构建子序列自动机：nxt[i][c]表示a中i位置之后字符c的最早位置
for (int i = n; i >= 0; --i) {
    memcpy(nxt[i], nxt[i+1], sizeof(nxt[i]));
    if (i >= 1) nxt[i-1][a[i] - 'a'] = i;
}
// 枚举Bob子串，用自动机匹配
for (int i = 1; i <= n; ++i) {
    int cur = 0; // 子序列自动机的当前位置（0表示还没开始）
    long long h1 = 0, h2 = 0; // 双哈希
    for (int j = i; j <= n; ++j) {
        cur = nxt[cur][b[j] - 'a'];
        if (cur == 0) break; // 找不到
        // 计算双哈希
        h1 = (h1 * 131 + (b[j] - 'a' + 1)) % MOD1;
        h2 = (h2 * 131 + (b[j] - 'a' + 1)) % MOD2;
        if (!hash_table.query(h1, h2)) { // 没出现过
            hash_table.insert(h1, h2);
            ans++;
        }
    }
}
```
* **代码解读**：  
  - 子序列自动机的构建：从后往前遍历Alice的字符串，`nxt[i][c]`记录`i`之后`c`的最早位置（比如`a[i]`是`'b'`，那么`nxt[i-1]['b'] = i`）。  
  - 匹配时，`cur`从0开始，每次跳`nxt[cur][b[j]]`，一步到位找到下一个字符的位置，比贪心指针更快！  
  - 双哈希：用两个不同的模数计算哈希值，只有两个哈希都相同才认为子串相同，避免冲突。

💡 **学习笔记**：子序列自动机是处理子序列问题的“终极武器”，一定要掌握！


## 5. 算法可视化：像素动画演示

### 动画主题：Bob的“子串探险”与Alice的“钥匙匹配”
我们设计一个**FC红白机风格**的动画，模拟题解的核心流程：

### 场景与UI初始化
- **屏幕布局**：左边是Alice的字符串（3000个像素块，每个字符用不同颜色：`a`是红色，`b`是蓝色，…），右边是Bob的字符串（同样的像素块）。  
- **控制面板**：底部有四个按钮：`开始`（绿色）、`单步`（黄色）、`重置`（红色）、`自动`（蓝色）；还有一个速度滑块（从“慢”到“快”）。  
- **音效**：背景是8位机风格的轻快BGM（比如《超级马里奥》的背景音乐）。

### 动画流程
1. **初始化**：Alice的字符串全部显示，Bob的字符串显示为灰色（未选中）。  
2. **枚举Bob子串**：  
   - 外层循环`i`（起点）：Bob的第`i`个字符**闪烁红色**，表示当前枚举的起点。  
   - 内层循环`j`（终点）：Bob的`i`到`j`字符**高亮蓝色**，表示当前子串。  
3. **贪心匹配**：  
   - Alice的指针`p`用**黄色箭头**表示，从第1位开始移动，找到`b[j]`后，箭头跳到该位置，同时该字符**闪烁绿色**（表示匹配成功）。  
   - 如果找不到`b[j]`，箭头变成**红色**，内层循环终止。  
4. **哈希去重**：  
   - 每次匹配成功，屏幕右侧弹出一个**小方块**（哈希值的可视化），存入“哈希背包”（一个像素化的箱子）。  
   - 所有子串处理完后，“哈希背包”中的方块**按顺序排列**，相同的方块**合并成一个**（表示去重）。  
5. **结果展示**：  
   - 去重后的方块数量就是答案，屏幕中央显示**“答案：X”**，伴随“胜利”音效（比如《魂斗罗》的通关音乐）。

### 交互设计
- **单步执行**：点击“单步”按钮，动画执行一步（比如`j`加1，或`p`移动一次）。  
- **自动播放**：点击“自动”按钮，动画按滑块速度自动执行，适合快速看整体流程。  
- **重置**：点击“重置”按钮，回到初始状态，重新开始。

### 为什么这样设计？
- **像素风格**：复古游戏的感觉能降低学习的“距离感”，让复杂的算法变得亲切。  
- **高亮与动画**：用颜色和移动直观展示“谁在变化”（比如指针`p`的移动、子串的选择）。  
- **音效**：用声音强化关键操作（比如匹配成功的“叮”声），帮助记忆。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的核心技巧（子序列匹配、子串去重）可以解决很多字符串问题：  
1. **判断一个串是否是另一个串的子序列**（比如LeetCode 392题）。  
2. **统计一个串中不同子串的数量**（用SAM，比如洛谷P3804）。  
3. **找出两个串的最长公共子串**（用SAM或哈希，比如洛谷P2852）。

### 洛谷练习推荐
1. **P4112 [HEOI2015]最短不公共子串**  
   🗣️ **推荐理由**：同时用到**子序列自动机**和**SAM**，和本题思路完全一致，是“进阶版”练习！  
2. **P3804 【模板】后缀自动机**  
   🗣️ **推荐理由**：学习SAM的基础模板，掌握子串去重的核心工具。  
3. **P5826 【模板】子序列自动机**  
   🗣️ **推荐理由**：练习子序列自动机的构建和应用，巩固“导航地图”的思想。  
4. **P2408 不同的子串个数**  
   🗣️ **推荐理由**：用SAM统计不同子串的数量，熟悉SAM的遍历方法。


## 7. 学习心得与经验分享

### 来自题解的宝贵经验
1. **哈希模数的选择**：  
   syksykCCC的题解用了一个非常大的模数（`2005091020050911`），避免哈希冲突。如果模数太小，容易出现“不同字符串哈希相同”的情况（比如`MOD=1e9+7`比`MOD=1e5+3`更安全）。  
2. **子序列自动机的构建**：  
   Karry5307的题解中，子序列自动机是**从后往前**构建的，这样能保证`nxt[i][c]`是`i`之后`c`的最早位置（如果从前往后构建，会得到最晚位置，无法保证贪心的正确性）。  
3. **SAM的优势**：  
   滑大稽的题解用SAM处理子串去重，时间复杂度`O(n)`，比哈希的`O(n² log n)`更快，而且不需要存储所有哈希值，节省内存。


## 总结
通过这道题，我们学习了**子序列匹配**（贪心指针/子序列自动机）和**子串去重**（哈希/SAM）的核心技巧。记住：  
- 子序列问题优先用**贪心指针**或**子序列自动机**；  
- 子串去重优先用**SAM**（高效）或**哈希**（简单）；  
- 代码的简洁性和效率同样重要，要学会选择合适的算法！

下次遇到字符串问题，不妨先想想：“这题需要子序列匹配吗？需要去重吗？” 相信你会很快找到思路！💪

---
处理用时：130.56秒
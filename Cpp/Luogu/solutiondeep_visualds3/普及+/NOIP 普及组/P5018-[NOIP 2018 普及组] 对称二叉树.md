# 题目信息

# [NOIP 2018 普及组] 对称二叉树

## 题目背景

NOIP2018 普及组 T4

## 题目描述

一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树： 

1.  二叉树； 
2.  将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。   

下图中节点内的数字为权值，节点外的 $id$ 表示节点编号。  

![](https://cdn.luogu.com.cn/upload/image_hosting/nkln7z1l.png)

现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数最多。请输出这棵子树的节点数。   

注意：只有树根的树也是对称二叉树。本题中约定，以节点 $T$ 为子树根的一棵“子 树”指的是：节点$T$ 和它的全部后代节点构成的二叉树。 

## 说明/提示

**样例 1 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/4lfen5aa.png)    
最大的对称二叉子树为以节点 $2$ 为树根的子树，节点数为 $1$。   

**样例 2 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/vhzzc587.png)

最大的对称二叉子树为以节点 $7$ 为树根的子树，节点数为 $3$。 

**数据规模与约定**

共 $25$ 个测试点。    

$v_i ≤ 1000$。 

- 测试点 $1 \sim 3, n ≤ 10$，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。 
- 测试点 $4 \sim 8, n ≤ 10$。
- 测试点 $9 \sim 12, n ≤ 10^5$，保证输入是一棵“满二叉树” 。 
- 测试点 $13 \sim 16, n ≤ 10^5$，保证输入是一棵“完全二叉树”。
- 测试点 $17 \sim 20, n ≤ 10^5$，保证输入的树的点权均为 $1$。
- 测试点 $21 \sim 25, n ≤ 10^6$。

本题约定： 

层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 $1$。 
 
 树的深度：树中节点的最大层次称为树的深度。 
 
 满二叉树：设二叉树的深度为 $h$，且二叉树有 $2^h-1$ 个节点，这就是满二叉树。  

![](https://cdn.luogu.com.cn/upload/image_hosting/8tof1fxx.png)

完全二叉树：设二叉树的深度为 $h$，除第 $h$ 层外，其它各层的结点数都达到最大 个数，第 $h$ 层所有的结点都连续集中在最左边，这就是完全二叉树。  

![](https://cdn.luogu.com.cn/upload/image_hosting/ibo7js1f.png)

## 样例 #1

### 输入

```
2 
1 3 
2 -1 
-1 -1 
```

### 输出

```
1```

## 样例 #2

### 输入

```
10 
2 2 5 5 5 5 4 4 2 3 
9 10 
-1 -1 
-1 -1 
-1 -1 
-1 -1 
-1 2 
3 4 
5 6 
-1 -1 
7 8```

### 输出

```
3```

# AI分析结果


### 💡 Kay的C++算法解析：对称二叉树 深入学习指南 💡

**引言**  
今天我们一起分析「对称二叉树」这道题。本指南将帮助你理解题目核心、掌握解题技巧，并通过像素动画直观感受算法执行过程。让我们一起探索如何高效寻找最大对称子树！

---

### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`递归暴力 + 剪枝优化`  

🗣️ **初步分析**：
> 解决本题的关键在于**递归比较子树对称性**。想象两棵子树像镜子一样互相反射：左子树的左孩子需匹配右子树的右孩子，左子树的右孩子需匹配右子树的左孩子。  
> - **核心思路**：预处理每个节点的子树大小，对于每个节点，若其左右子树大小相等则递归比较对称性。  
> - **优化点**：子树大小不等时直接剪枝，避免无效递归。  
> - **可视化设计**：动画将高亮当前比较的节点对，用颜色区分对称状态（绿色匹配/红色不匹配），并展示递归路径。  
> - **复古像素风**：采用8位FC游戏风格，节点用像素方块表示，递归过程通过“像素箭头”流动展示。关键操作触发“叮”声，成功匹配时播放胜利音效，支持单步调试和自动演示模式。

---

### 2. 精选优质题解参考
<eval_intro>  
从思路清晰性、代码规范性和算法效率等维度，精选以下优质题解：
</eval_intro>

**题解一：wsm52 (赞21)**  
* **点评**：  
  思路直击本质——直接递归比较左右子树。代码简洁规范：  
  - 用`check(left, right)`函数清晰封装对称判断逻辑  
  - 预处理子树大小`siz[]`实现高效剪枝  
  - 边界处理严谨（`-1`表示空节点）  
  亮点：**20行核心代码解决战斗**，完美展现算法本质。

**题解二：Shunpower (赞2)**  
* **点评**：  
  在暴力递归基础上进行**尾递归优化**，提升栈空间效率。  
  - 创新点：用按位取反`~`简化空节点判断  
  - 严格证明时间复杂度为$O(n \log n)$  
  亮点：**理论结合实践**，代码兼具效率与可读性。

**题解三：exprosic (赞4)**  
* **点评**：  
  提供**最严格的时间复杂度证明**，深入剖析递归过程：  
  - 定义$f(n)$为子树比较操作数上界  
  - 数学归纳法证明$f(n) \leq n \log_2 n$  
  亮点：**严谨的数学推导**为暴力算法正名。

---

### 3. 核心难点辨析与解题策略
<difficulty_intro>  
解决本题需突破以下三个关键难点：
</difficulty_intro>

1. **难点：避免$O(n^2)$暴力**  
   * **分析**：直接无剪枝递归最坏复杂度$O(n^2)$。优质解法通过**预处理子树大小**，在递归前比较`size[l] == size[r]`，不等时立即终止。
   * 💡 **学习笔记**：子树大小是结构对称的必要条件，先验判断可大幅提升效率。

2. **难点：递归终止条件处理**  
   * **分析**：需正确处理多种边界情况：
     - 双空节点 → 对称（返回`true`）  
     - 单空节点 → 不对称（返回`false`）  
     - 节点值不等 → 不对称  
   * 💡 **学习笔记**：递归边界是算法正确性的基石，必须全面覆盖。

3. **难点：交叉递归实现**  
   * **分析**：对称要求`左子树.left vs 右子树.right`且`左子树.right vs 右子树.left`。代码中体现为：
     ```cpp
     return check(l[a], r[b]) && check(r[a], l[b]);
     ```
   * 💡 **学习笔记**：镜像比较需“交叉配对”，类似双手镜像动作。

#### ✨ 解题技巧总结
<summary_best_practices>  
提炼通用解题策略：
</summary_best_practices>
- **技巧1：预处理加速**  
  在递归前计算子树大小、深度等全局信息，避免重复计算。
- **技巧2：剪枝优化**  
  用必要条件（如大小相等）提前排除不可能情况。
- **技巧3：尾递归优化**  
  将递归调用放在函数末尾，便于编译器优化栈空间。

---

### 4. C++核心代码实现赏析
<code_intro_overall>  
以下通用实现融合优质题解精华：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：综合wsm52的清晰结构+Shunpower的边界处理优化。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  using namespace std;
  const int N = 1e6 + 5;
  
  int n, val[N], l[N], r[N], siz[N], ans = 1;
  
  // 预处理子树大小
  void dfs(int u) {
      if (u == -1) return;
      dfs(l[u]); dfs(r[u]);
      siz[u] = 1 + (l[u]!=-1 ? siz[l[u]] : 0) 
                  + (r[u]!=-1 ? siz[r[u]] : 0);
  }
  
  // 递归判断对称性
  bool check(int a, int b) {
      if (a == -1 && b == -1) return true;
      if (a == -1 || b == -1) return false;
      if (val[a] != val[b]) return false;
      return check(l[a], r[b]) && check(r[a], l[b]);
  }
  
  int main() {
      ios::sync_with_stdio(0), cin.tie(0);
      cin >> n;
      for (int i = 1; i <= n; ++i) cin >> val[i];
      for (int i = 1; i <= n; ++i) cin >> l[i] >> r[i];
      
      dfs(1); // 预处理子树大小
      
      for (int i = 1; i <= n; ++i) {
          if (l[i] == -1 && r[i] == -1) continue; // 单节点已包含在ans=1中
          if (siz[l[i]] != siz[r[i]]) continue;  // 剪枝关键！
          if (check(l[i], r[i])) 
              ans = max(ans, siz[i]);
      }
      cout << ans;
      return 0;
  }
  ```
* **代码解读概要**：
  - `dfs`预处理：递归计算每个节点的子树大小
  - `check`函数：边界处理 → 值比较 → 交叉递归
  - 主逻辑：读入 → 预处理 → 枚举节点+剪枝 → 更新答案

<code_intro_selected>  
优质题解核心片段赏析：
</code_intro_selected>

**wsm52题解片段**  
* **亮点**：**极简主义**，15行内完成核心逻辑
* **核心代码**：
  ```cpp
  bool check(int left, int right) {
      if (left == -1 && right == -1) return true;
      if (left == -1 || right == -1) return false;
      if (val[left] != val[right]) return false;
      return check(l[left], r[right]) 
          && check(r[left], l[right]);
  }
  ```
* **代码解读**：
  > 第1-2行处理双空/单空边界 → 第3行比较节点值 → 第4行**交叉递归**（注意`l[left]`配`r[right]`，`r[left]`配`l[right]`）。  
  > **精妙处**：用逻辑与`&&`短路特性，首组匹配失败即终止。
* 💡 **学习笔记**：递归函数应优先处理边界情况，逐步缩小问题规模。

**Shunpower题解片段**  
* **亮点**：**位运算优化**空节点判断
* **核心代码**：
  ```cpp
  bool same(int rt1, int rt2) {
      bool f1 = ~rt1, f2 = ~rt2;  // 位运算判断非空
      if (!f1 && !f2) return true;
      if (f1 ^ f2) return false;   // 异或判断单空
      // ...值比较与递归
  }
  ```
* **代码解读**：
  > `~rt1`（按位取反）：当`rt1=-1`时结果为0 → `f1=false`。  
  > **优势**：比`rt1!=-1`减少一次比较操作，提升常数效率。
* 💡 **学习笔记**：位运算可简化状态判断，但需确保可读性。

---

### 5. 算法可视化：像素动画演示
<visualization_intro>  
设计名为「镜像冒险」的像素动画，助你直观理解递归比较过程：
</visualization_intro>

* **主题**：8-bit风格二叉树，节点为发光像素方块（绿：当前比较节点/蓝：已匹配/红：不匹配）
* **核心演示**：递归对称比较过程，动态显示子树大小剪枝

* **动画流程**：
  1. **初始化场景**  
     - 像素网格显示二叉树（FC游戏画风）  
     - 控制面板：单步执行/自动播放/速度滑块（图1）
     ![](https://assets.luogu.com.cn/upload/image_hosting/2v8j6yd0.png)

  2. **递归过程演示**  
     - 步①：高亮当前子树根节点（黄色闪烁）  
     - 步②：比较左右子节点（并排高亮+“叮”声）  
     - 步③：若值相等→绿色√，进入交叉递归（箭头流向`l[a]`和`r[b]`）  
     - 步④：若子树大小不等→红色×，播放失败音效（图2）
     ![](https://assets.luogu.com.cn/upload/image_hosting/kp9w4qsg.png)

  3. **自动演示模式**  
     - AI自动执行：类似“贪吃蛇AI”路径演示  
     - 速度可调：滑块控制0.5x~5x速

* **交互设计**：
  - **音效系统**：
    - 节点匹配：清脆“叮”声（Web Audio API生成8-bit音效）
    - 完全对称：胜利旋律（《超级玛丽》过关音效改编）
    - 剪枝触发：短促警报声
  - **游戏化元素**：
    - 每成功匹配一层得10分，显示连击特效
    - 发现最大对称子树时解锁“镜像大师”成就

* **技术实现**：  
  用Canvas API动态绘制：  
  ```javascript
  // 绘制节点示例
  function drawNode(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*40, y*60, 30, 30); // 像素方块
    if (node.val) drawText(x*40+5, y*60+20, node.val);
  }
  ```

---

### 6. 拓展练习与相似问题思考
<similar_problems_intro>  
掌握对称二叉树判断后，可挑战以下相似问题：
</similar_problems_intro>

* **通用技巧迁移**：  
  递归比较思想还可用于：
  1. 判断两棵树是否相同（100. Same Tree）
  2. 判断树是否对称本身（101. Symmetric Tree）
  3. 寻找最大同构子树（子树结构完全相同）

* **洛谷推荐练习**：
  1. **P1305 新二叉树**  
     🗣️ *推荐理由*：巩固二叉树遍历基础，理解树结构本质
  2. **P1229 遍历问题**  
     🗣️ *推荐理由*：通过前序+中序确定二叉树，深化结构理解
  3. **P3884 二叉树问题**  
     🗣️ *推荐理由*：综合训练深度、宽度计算，强化递归思维

---

### 7. 学习心得与经验分享
<insights_intro>  
题解中的调试经验尤为珍贵：
</insights_intro>

> **qhr2023 经验分享**：  
> *“最初在构造满二叉树测试数据时卡了很久，后来用完全对称的满二叉树验证时间复杂度才确认算法的可靠性。”*
>
> **Kay点评**：  
> 充分测试是保证算法正确性的关键！建议：
> 1. 测试数据包含：单边树、满二叉树、完全不对称树
> 2. 对拍验证：暴力算法 vs 优化算法
> 3. 树规模达$10^6$时，关注递归栈深度限制

---

**结语**  
通过本次分析，我们深入理解了对称二叉树的递归本质与剪枝优化策略。记住：编程能力的提升在于持续实践与思考。下次算法之旅再见！🚀

---
处理用时：196.81秒
# 题目信息

# [THUPC 2023 决赛] 总投票数

## 题目背景

各位亲爱的《La Lumière: Scarlet Intense Flame - Adventurous Scarlet -》玩家：

非常荣幸能与您携手度过了这四年的美好时光，衷心感谢大家的支持与陪伴！

现在，我们非常遗憾的宣布，《La Lumière: Scarlet Intense Flame - Adventurous Scarlet -》将于 2023 年 5 月 28 日 15:00 停止运营服务。

停止运营相关时间表如下：

……

## 题目描述

在关服前，运营发起了一系列投票，调查哪些游戏内容给玩家带来了更深的印象。

作为系列的忠实玩家，你想知道有多少人参加了关服前的投票，但是运营只公开了最终的投票结果：对于一项包含 $N$ 个选项的投票，选择第 $i$ 个选项的玩家比例为 $P_i$（$1\le i\le N$）。运营在公布结果时进行了四舍五入，所有的 $P_i$ 仅保留到小数点后第 $L$ 位。假设实际有 $K$ 位玩家参加了投票，其中有 $D_i$ 位玩家选择了第 $i$ 个选项，则应该有

$$
P_i-\frac{1}{2}\times 10^{-L}\le\frac{D_i}{K}< P_i+\frac{1}{2}\times 10^{-L}
$$

显然，所有的 $D_i$ 必须是非负整数，而 $K=\sum_{i=1}^N D_i$ 则必须是正整数。现在，给定 $N$ 和 $P_i$，请你求出满足 $D_i$ 有非负整数解的最小的总投票数 $K$。

## 说明/提示

**【样例解释 #1】**

最小的总投票数为 $6$，对应每个选项的投票数为 $1, 2, 3$。

**【样例解释 #2】**

最小的总投票数为 $73$，对应每个选项的投票数为 $3, 8, 8, 12, 22, 5, 15$。

**【样例解释 #3】**

最小的总投票数为 $7766$，对应每个选项的投票数为 $12, 301, 123, 403, 629, 530, 1216, 808, 205, 1113, 1005, 1206, 215$。

**【数据范围】**

对于所有测试数据，$1\le N\le 100$，$0\le P_i\le 1$，$\sum_{i=1}^N P_i=1$，且 $P_i$ 最多统一保留到小数点后 $6$ 位。

**【题目来源】**


来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 [https://github.com/THUSAAC/THUPC2023](https://github.com/THUSAAC/THUPC2023) 查看。

## 样例 #1

### 输入

```
3
0.166667
0.333333
0.500000
```

### 输出

```
6
```

## 样例 #2

### 输入

```
7
0.041096
0.109589
0.109589
0.164384
0.301370
0.068493
0.205479
```

### 输出

```
73
```

## 样例 #3

### 输入

```
13
0.00155
0.03876
0.01584
0.05189
0.08099
0.06825
0.15658
0.10404
0.02640
0.14332
0.12941
0.15529
0.02768
```

### 输出

```
7766
```

# AI分析结果


### 💡 Kay的C++算法解析：总投票数 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`枚举应用`  
🗣️ **初步分析**：  
> 这道题的关键在于**枚举思想**，就像在迷宫中尝试所有可能的路径来寻找最短路线。题目要求找到最小的投票人数K，使得每个选项的实际投票比例满足四舍五入后的公示值。  
> - 核心思路：由于L≤6，K的最大值不超过10⁶。通过枚举K值(1~10⁶)，验证每个选项的票数是否满足四舍五入条件  
> - 核心难点：浮点数精度处理（需用整数运算避免误差）、边界条件验证  
> - 可视化设计：采用8位像素风格，设计"投票计数器"动画。左侧显示当前枚举的K值（像素数字），右侧用彩色方块柱表示各选项票数。当K值变化时，柱状高度实时计算，满足条件的选项会闪烁绿光并播放"叮"音效，不满足则红光闪烁并播放"噗"音效，成功找到解时播放胜利音效  

---

#### 2. 精选优质题解参考
**题解一（来源：rui_er）**  
* **点评**：思路清晰完整，通过字符串读入精确获取小数位数，完全使用整数运算避免浮点误差。代码中`val[i]`存储P_i×10^L的整数值，枚举时用`round(val[j]/lim * i)`计算票数，再反向验证还原值，严谨处理了四舍五入条件。边界处理完善，包含P_i=1的特判，可直接用于竞赛。  

**题解二（来源：bobo2007）**  
* **点评**：采用类似rui_er的整数运算思路，创新点在于将验证条件转化为`(int)(x/k * 10^L +0.5) == a[j]`的整数表达式。代码简洁规范，变量名`a[i]`、`ex`含义明确，但缺少P_i=1的特判（实际不影响结果）。  

**题解三（来源：I_will_AKIOI）**  
* **点评**：亮点在于用`f[]`数组预存10^{-k}值辅助浮点转换。思路清晰但存在浮点风险：验证时直接使用`a[i]-inf <= (double)w/k`的浮点比较，在边界值可能出错。代码中`check()`函数结构工整，实践时需注意精度问题。

---

#### 3. 核心难点辨析与解题策略
1. **难点：避免浮点精度误差**  
   * **分析**：直接使用`double`存储比例会导致计算误差。优质题解均用字符串读入，提取P_i×10^L的整数值（如0.166667→166667），全程整数运算  
   * 💡 学习笔记：字符串转换+整数运算是处理小数精度的银弹  

2. **难点：验证四舍五入条件**  
   * **分析**：需验证∀i, |D_i/K - P_i| < 0.5×10^{-L}。rui_er的解法最严谨：计算D_i=round(P_i×K)后，再验证round(D_i/K×10^L)是否等于原整数  
   * 💡 学习笔记：四舍五入的本质是双向误差控制  

3. **难点：高效枚举的终止条件**  
   * **分析**：当K=10^L时必有解（令D_i=P_i×10^L），因此枚举上限为10^L。特判P_i=1可立即返回K=1  
   * 💡 学习笔记：利用题目特性缩小搜索空间是优化关键  

### ✨ 解题技巧总结
- **技巧1：整数化处理浮点数** - 用字符串读入小数，转换为整数运算  
- **技巧2：条件验证双向绑定** - 正算D_i后反推验证，避免单边误差  
- **技巧3：边界特判加速** - 对极值情况(P_i=1)单独处理  
- **技巧4：模块化验证** - 如rui_er的`ok`标志位，任一选项失败即终止当前K验证  

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**  
* **说明**：综合优质题解思路，字符串转换+整数运算+双向验证  
```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    int n; cin >> n;
    long long val[105] = {0}, lim = 1;
    string s[105];
    
    // 1. 字符串读入提取整数
    for (int i = 0; i < n; i++) {
        cin >> s[i];
        int len = s[i].size();
        if (s[i][0] == '1') { cout << 1; return 0; } // P_i=1特判
        for (int j = 2; j < len; j++)
            val[i] = val[i] * 10 + (s[i][j] - '0');
        lim = (j == 2) ? lim : lim * 10; // 计算10^L
    }

    // 2. 枚举K值 (1~10^L)
    for (long long k = 1; k <= lim; k++) {
        long long sum = 0;
        bool valid = true;
        
        // 3. 验证每个选项
        for (int i = 0; i < n; i++) {
            long long d = round(val[i] * k / (double)lim);
            if (round(d * lim / (double)k) != val[i]) { 
                valid = false; break; 
            }
            sum += d;
        }
        if (valid && sum == k) { 
            cout << k; 
            return 0;
        }
    }
    cout << lim; // 保底解
}
```

**题解一核心代码片段**  
```cpp
// 特判P_i=1
if(s[i][1]=='1') return puts("1")&0;  

// 计算10^L
rep(j,3,L) val[i]=10*val[i]+(s[i][j]^48);  
lim *= 10;

// 双向验证
ll now=ll(round(1.0*val[j]/lim*i));  
if(ll(round(1.0*now/i*lim))!=val[j]) break; 
```
* **代码解读**：  
  > 1. `s[i][1]=='1'`直接特判K=1，避免无效枚举  
  > 2. `val[i]`存储P_i×10^L整数（如0.166667→166667）  
  > 3. `round(1.0*val[j]/lim*i)`计算D_i，再通过`round(1.0*now/i*lim)`反推验证  
* 💡 学习笔记：整数运算+双向验证=精度无忧  

**题解二核心片段**  
```cpp
int x=ex*a[j]*i+0.5;  // 四舍五入计算D_i
if((int)(((double)x/i)*l+0.5)!=a[j]) break; // 反推验证
```
* **代码解读**：  
  > 1. `ex=10^{-L}`为精度阈值，`l=10^L`  
  > 2. `(x/i)*l+0.5`实现还原比例后四舍五入取整  
* 💡 学习笔记：巧用`(int)(x+0.5)`实现四舍五入取整  

---

#### 5. 算法可视化：像素动画演示
* **主题**：8-bit风格"投票探险家"  
* **核心演示**：枚举过程可视化 + 四舍五入条件验证  

| 步骤               | 像素动画设计                                                                 | 交互与音效                     |
|--------------------|----------------------------------------------------------------------------|------------------------------|
| **初始化**         | 复古控制台界面：左侧K值计数器（红绿像素数字），右侧选项柱状图（不同颜色方块柱）             | 启动时播放FC开机音效               |
| **枚举K值**        | K值计数器滚动，当前K值闪烁蓝光                                                | 方向键↑↓加速/减速，A键暂停         |
| **计算选项票数**   | 柱状图高度随K值增长，显示计算公式：D_i=round(P_i×K)                          | 计算时触发"嘀"音效                |
| **验证条件**       | 选项柱顶显示实际比例D_i/K，与P_i比较：<br>- 绿框+✔：满足 \|D_i/K-P_i\|<0.5×10^{-L}<br>- 红框+✘：不满足 | 通过时"叮"音效，失败时"噗"音效       |
| **验证成功**       | 所有选项绿光闪烁，K值放大跳动                                                 | 播放《超级玛丽》过关音效，撒像素星星特效 |
| **AI演示模式**     | 自动从K=1开始演示，遇到失败时显示红色"!"，成功时显示绿色"★"                          | 按Select键切换手动/AUTO模式       |

**设计思路**：  
> 1. 柱状图高度=20×D_i/max(D_i)像素，直观展示比例关系  
> 2. 条件验证时显示误差带：P_i±0.5×10^{-L}区间用半透明色块标注  
> 3. 核心公式始终显示在顶部：`D_i = round(P_i × K)`  

---

#### 6. 拓展练习与相似问题思考
* **通用技巧迁移**：  
  整数化处理+枚举验证适用于：  
  1. 分数近似问题（如找到最接近π的有理数）  
  2. 比例分配验证（如资源分配合理性检查）  
  3. 浮点数精确比较（如金融计算中的金额验证）  

* **洛谷推荐练习**：  
  1. [P1014] 最大公约数和最小公倍数问题  
     → 巩固整数运算与枚举验证  
  2. [P1036] 选数  
     → 强化枚举与边界处理能力  
  3. [P1219] 八皇后问题  
     → 提升大规模枚举的优化思维  

---

#### 7. 学习心得与经验分享
> **参考经验（来自bobo2007）**：  
> "考场上把N的范围看成10⁵了... 这让我意识到仔细审题和数据范围分析是解题第一要务。"  
>  
> **点评**：  
> 此题深刻揭示了精度处理和枚举优化的关联性。bobo2007的调试经历提醒我们：  
> 1. 浮点误差具有隐蔽性，整数化是治本良方  
> 2. 题目约束条件（如L≤6）是优化枚举的关键突破口  
> 3. 特判极值可显著提升效率  

---

本次解析带大家领略了**整数化思维**在解决浮点精度问题中的精妙应用。记住：将小数想象成放大的整数，往往能打开新的解题维度！下次遇到类似问题，不妨试试"像素化思维"——把数据看作可操作的像素块，会让算法更直观哦~ ✨

---
处理用时：201.39秒
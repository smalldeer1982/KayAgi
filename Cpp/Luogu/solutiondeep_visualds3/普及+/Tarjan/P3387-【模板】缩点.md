# 题目信息

# 【模板】缩点

## 题目描述

给定一个 $n$ 个点 $m$ 条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。

允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。


## 说明/提示

对于 $100\%$ 的数据，$1\le n \le 10^4$，$1\le m \le 10^5$，$0\le a_i\le 10^3$。

- 2024-11-1 添加了 [hack 数据](https://www.luogu.com.cn/discuss/964940)；

## 样例 #1

### 输入

```
2 2
1 1
1 2
2 1```

### 输出

```
2```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】缩点 深入学习指南 💡

<introduction>
  今天我们来一起攻克“缩点模板题”——这道题是图论中**强连通分量（SCC）**和**有向无环图（DAG）最长路**的经典结合。通过这道题，你将学会如何把“绕圈”的图简化成“直线型”的图，再用动态规划快速找到最优解。Let's go！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：强连通分量（SCC）缩点 + DAG拓扑排序+动态规划（DP）

🗣️ **初步分析**：
> 题目要求找一条路径，使得经过的点权和最大，且重复点权只算一次。关键在于：**如果路径经过一个环（强连通分量），那么环内所有点的权值都能被“一次性拿走”**——因为环内点可以互相到达，走一遍环就能收集所有点权。因此，我们需要把每个环“缩成一个点”（权值为环内点权和），这样原图就变成了**没有环的DAG**，然后在DAG上求最长路即可（DAG的最长路可以用拓扑排序+DP解决）。

### 核心算法流程
1. **找强连通分量（SCC）**：用Tarjan或Kosaraju算法找出所有能互相到达的点集（环）。
2. **缩点**：把每个SCC合并成一个新点，权值为SCC内所有点的权值和；新点之间的边保留原图中不同SCC之间的边。
3. **DAG最长路**：对缩点后的DAG进行拓扑排序，同时用DP计算每个点的最大路径和（`dp[v] = max(dp[v], dp[u] + 新点v的权值)`）。

### 可视化设计思路
我们会用**8位像素风**（类似红白机游戏）演示算法流程：
- **Tarjan阶段**：用像素块表示节点，栈用“堆叠的小方块”展示，`dfn`/`low`值用数字浮在节点上方；当找到SCC时，节点会集体“闪烁”并合并成一个新点。
- **拓扑排序阶段**：用“传送带”表示拓扑序，节点按顺序移动，DP值用“能量条”展示，每次更新时能量条会“增长”。
- **音效**：入栈/出栈是“嘀嗒”声，找到SCC是“叮”的提示音，拓扑排序更新DP是“嗡”的音效，最终找到最大值是“胜利音效”。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度筛选了3份优质题解，帮你快速掌握核心技巧：
</eval_intro>

**题解一：星星之火（赞1458）**
* **点评**：这份题解是经典的Tarjan+拓扑排序模板，思路极其清晰！作者先讲“为什么要缩点”（环内点权必须全拿），再详细解释Tarjan的核心变量（`dfn`时间戳、`low`回溯最早节点、栈存当前路径），最后用拓扑排序+DP求最长路。代码注释详细，变量命名直观（比如`sd`数组记录节点所属SCC），边界处理严谨（比如缩点时合并权值）。特别适合作为入门模板，直接复制就能用！

**题解二：csxx601cjy（赞38）**
* **点评**：这是一份“保姆级”题解！作者不仅讲了Tarjan的原理，还附了**动图演示**（展示SCC的查找过程），甚至证明了算法的正确性（比如SCC缩点后DAG无环）。代码用`vector`存图，结构简洁，拓扑排序的DP转移方程写得很清楚（`dp[v] = max(dp[v], dp[u]+a[v])`）。如果你想理解算法背后的逻辑，这份题解绝对是首选！

**题解三：Colinxu2020（赞13）**
* **点评**：这份题解的亮点是**对比了两种找SCC的算法**——Tarjan和Kosaraju！作者详细解释了两者的原理（Tarjan用DFS栈，Kosaraju用两次DFS），并给出了两份代码。对于想拓展思路的同学来说，这份题解能帮你理解不同算法的优缺点（比如Tarjan更高效，Kosaraju更易理解）。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是突破三个难点，我结合优质题解帮你梳理：
</difficulty_intro>

1.  **难点1：如何正确找到SCC？**
    * **分析**：Tarjan算法的核心是维护`dfn`（访问顺序）和`low`（能回溯到的最早节点）。当`dfn[u] == low[u]`时，说明`u`是一个SCC的根，栈中`u`及以上的节点构成一个SCC。比如题解一中的`tarjan`函数，通过递归更新`low`值，最终弹出栈中的SCC节点。
    * 💡 **学习笔记**：`low[u]`是Tarjan的“灵魂”——它记录了节点`u`能“回到过去”的最远节点，帮我们判断是否形成环。

2.  **难点2：如何正确构建缩点后的新图？**
    * **分析**：缩点后，新图的节点是SCC，边是原图中不同SCC之间的边。需要注意**去重边**（比如同一对SCC之间的多条边只保留一条），否则会影响拓扑排序的入度统计。比如题解三中用`set`去重，避免重复边。
    * 💡 **学习笔记**：新图必须是DAG，否则拓扑排序会出错——缩点的目的就是消除环！

3.  **难点3：如何在DAG上求最长路？**
    * **分析**：DAG的最长路不能用Dijkstra（因为有正权环，但DAG没有环），所以用**拓扑排序+DP**：按拓扑序处理节点，确保处理`u`时，所有能到达`u`的节点已经处理完毕。转移方程是`dp[v] = max(dp[v], dp[u] + 新点v的权值)`（`u`是`v`的前驱）。比如题解二中的`topo`函数，用队列维护入度为0的节点，依次更新DP值。
    * 💡 **学习笔记**：拓扑序的“顺序”是DP无后效性的保证——先处理前面的节点，再处理后面的节点，不会重复计算。


### ✨ 解题技巧总结
- **技巧1：Tarjan模板要记牢**：`dfn`和`low`的初始化、栈的操作、SCC的判断（`dfn[u]==low[u]`）是核心。
- **技巧2：缩点时合并权值**：每个SCC的权值是内部所有点的和，这是“一次性拿完环内权值”的关键。
- **技巧3：拓扑排序+DP求最长路**：DAG的最长路只能用这种方法，记住转移方程和入度处理。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解的通用核心代码**，帮你快速理解整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合了星星之火和csxx601cjy的题解，用Tarjan找SCC，拓扑排序+DP求最长路，代码简洁易读。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <stack>
    #include <queue>
    #include <algorithm>
    using namespace std;

    const int N = 1e4 + 10, M = 1e5 + 10;
    vector<int> g[N], ng[N];  // 原图、新图
    int a[N], dfn[N], low[N], fa[N], in[N], dp[N];
    bool vis[N];
    stack<int> stk;
    int idx = 0, scc_cnt = 0;

    void tarjan(int u) {
        dfn[u] = low[u] = ++idx;
        stk.push(u);
        vis[u] = true;
        for (int v : g[u]) {
            if (!dfn[v]) {
                tarjan(v);
                low[u] = min(low[u], low[v]);
            } else if (vis[v]) {
                low[u] = min(low[u], dfn[v]);
            }
        }
        if (dfn[u] == low[u]) {  // 找到SCC
            scc_cnt++;
            int v;
            do {
                v = stk.top(); stk.pop();
                vis[v] = false;
                fa[v] = scc_cnt;  // 记录所属SCC
                a[scc_cnt] += a[v];  // 合并权值（注意：原a数组要先存点权，这里需要调整！）
            } while (v != u);
        }
    }

    int main() {
        ios::sync_with_stdio(false); cin.tie(0);
        int n, m; cin >> n >> m;
        for (int i = 1; i <= n; i++) cin >> a[i];  // 原点点权
        for (int i = 1; i <= m; i++) {
            int u, v; cin >> u >> v;
            g[u].push_back(v);
        }

        // 1. Tarjan找SCC
        for (int i = 1; i <= n; i++) if (!dfn[i]) tarjan(i);

        // 2. 构建新图
        for (int u = 1; u <= n; u++) {
            for (int v : g[u]) {
                if (fa[u] != fa[v]) {  // 不同SCC之间的边
                    ng[fa[u]].push_back(fa[v]);
                    in[fa[v]]++;
                }
            }
        }

        // 3. 拓扑排序+DP求最长路
        queue<int> q;
        for (int i = 1; i <= scc_cnt; i++) {
            if (in[i] == 0) {  // 入度为0的节点是起点
                q.push(i);
                dp[i] = a[i];  // 初始DP值为SCC的权值
            }
        }
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int v : ng[u]) {
                dp[v] = max(dp[v], dp[u] + a[v]);  // 转移方程
                if (--in[v] == 0) q.push(v);
            }
        }

        // 找最大DP值
        int ans = 0;
        for (int i = 1; i <= scc_cnt; i++) ans = max(ans, dp[i]);
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分三步：1. 用Tarjan找SCC并合并权值；2. 构建缩点后的新图；3. 拓扑排序+DP求最长路。核心是`tarjan`函数（找SCC）和拓扑排序的队列操作（更新DP值）。


<code_intro_selected>
接下来看优质题解的核心片段，感受不同写法的亮点：
</code_intro_selected>

**题解一：星星之火（Tarjan核心片段）**
* **亮点**：用`sd`数组记录节点所属SCC，缩点时直接合并权值，代码简洁。
* **核心代码片段**：
    ```cpp
    void tarjan(int x) {
        low[x] = dfn[x] = ++tim;
        stac[++top] = x; vis[x] = 1;
        for (int i = head[x]; i; i = edge[i].next) {
            int v = edge[i].to;
            if (!dfn[v]) { tarjan(v); low[x] = min(low[x], low[v]); }
            else if (vis[v]) low[x] = min(low[x], low[v]);
        }
        if (dfn[x] == low[x]) {
            int y;
            while (y = stac[top--]) {
                sd[y] = x;  // 记录所属SCC
                vis[y] = 0;
                if (x == y) break;
                p[x] += p[y];  // 合并权值
            }
        }
    }
    ```
* **代码解读**：
    > `sd[y] = x`表示节点`y`属于以`x`为根的SCC；`p[x] += p[y]`把`y`的权值加到`x`上（`x`是SCC的代表节点）。当`x == y`时停止弹栈，因为`x`是SCC的根。
* 💡 **学习笔记**：用代表节点的权值存储SCC的总权值，是缩点的常用技巧。

**题解二：csxx601cjy（拓扑排序核心片段）**
* **亮点**：用`vector`存图，拓扑排序的DP转移非常直观。
* **核心代码片段**：
    ```cpp
    void topo() {
        queue<int> q;
        for (int i = 1; i <= n; i++) {
            if (i == belong[i] && !in[i]) {  // 入度为0的SCC代表节点
                q.push(i);
                dp[i] = a[i];
            }
        }
        while (!q.empty()) {
            int s = q.front(); q.pop();
            for (auto i : g2[s]) {  // 遍历新图的边
                dp[i] = max(dp[i], dp[s] + a[i]);  // 转移方程
                if (--in[i] == 0) q.push(i);
            }
        }
    }
    ```
* **代码解读**：
    > `i == belong[i]`表示`i`是SCC的代表节点（因为缩点时`belong`数组记录了每个节点的所属SCC，代表节点的`belong`值等于自己）。`dp[i] = max(dp[i], dp[s] + a[i])`表示从`s`到`i`的路径，`i`的最大权值是原来的`dp[i]`或`s`的权值加`i`的权值。
* 💡 **学习笔记**：代表节点的判断（`i == belong[i]`）是缩点后的关键，避免重复处理同一SCC的节点。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看”到算法的运行过程，我设计了一个**8位像素风动画**，模拟Tarjan找SCC和拓扑排序的过程：
</visualization_intro>

### 动画演示主题：像素探险家的“环中寻宝”
- **风格**：红白机像素风（16色调色板，方块状节点，复古字体）。
- **场景**：一个由像素块组成的迷宫（代表原图），探险家（小方块）在迷宫中行走，收集“宝石”（点权）。

### 动画帧步骤与交互关键点
1. **初始化**：
   - 屏幕左侧是原图（节点是彩色方块，边是白色线条），右侧是“控制面板”（单步/自动播放按钮、速度滑块、重置按钮）。
   - 背景音乐是8位风格的“冒险曲”（循环播放）。

2. **Tarjan阶段（找SCC）**：
   - **DFS遍历**：探险家从节点1出发，每走到一个节点，节点会“闪烁”，并显示`dfn`和`low`值（比如节点1的`dfn=1`，`low=1`）。
   - **栈操作**：每进入一个节点，栈（屏幕上方的“堆叠方块”）会增加一个方块；每回溯一个节点，栈会减少一个方块。
   - **找到SCC**：当`dfn[u] == low[u]`时，该SCC的所有节点会“集体变色”（比如变成黄色），并合并成一个新的大节点（显示SCC的总权值），同时播放“叮”的提示音。

3. **缩点阶段**：
   - 原图消失，新图（DAG）出现在屏幕左侧：新节点是合并后的大方块，边是蓝色线条。
   - 每个新节点显示其总权值（比如“总宝石：5”）。

4. **拓扑排序阶段**：
   - **入度处理**：入度为0的节点会“发光”，并被加入队列（屏幕下方的“传送带”）。
   - **DP更新**：每个节点通过传送带移动时，会“发射”一道光到下一个节点，下一个节点的“能量条”（DP值）会增长，同时播放“嗡”的音效。
   - **结果展示**：所有节点处理完毕后，最大DP值的节点会“闪烁彩虹色”，并显示“最大宝石：X”，同时播放“胜利音效”。

### 交互设计
- **单步执行**：点击“下一步”按钮，动画走一步，方便仔细观察。
- **自动播放**：点击“开始”按钮，动画按设定速度（通过滑块调整）自动运行。
- **重置**：点击“重置”按钮，回到初始状态，重新演示。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
缩点是图论中的基础技巧，掌握后可以解决很多类似问题。下面是几个拓展练习：
</similar_problems_intro>

### 通用思路迁移
缩点的核心是**将有环图转化为DAG**，从而用DAG的性质（拓扑排序、DP）解决问题。适用场景包括：
1. 求图中的最长/最短路径（如本题）；
2. 求需要访问所有节点的最小代价（如P2746校园网）；
3. 求图中的强连通分量数量（如P3387模板题）。

### 洛谷练习推荐
1. **洛谷 P2341 - 受欢迎的牛**
   - 🗣️ **推荐理由**：这道题需要找能被所有牛喜欢的牛，本质是缩点后找DAG中出度为0的SCC（如果只有一个，就是答案）。能帮你巩固缩点后的DAG分析。
2. **洛谷 P3627 - [APIO2009]抢掠计划**
   - 🗣️ **推荐理由**：这道题是缩点+DAG最长路的变形，需要指定起点（银行）和终点（商店），能帮你练习有条件的最长路求解。
3. **洛谷 P2194 - HXY烧情侣**
   - 🗣️ **推荐理由**：这道题需要找烧毁所有强连通分量的最小代价（每个SCC烧一次，取最小点权），能帮你理解缩点后的权值处理。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中摘录了几个实用的经验，帮你避免踩坑：
</insights_intro>

> **经验1（来自星星之火）**：“我最初在Tarjan的栈处理时出错，后来发现`vis`数组必须在弹栈时设为`false`——否则会把已经处理过的节点误判为在栈中。”
> **点评**：`vis`数组的作用是标记节点是否在栈中，弹栈时一定要重置，否则会导致`low`值计算错误。这是Tarjan的常见bug，一定要注意！

> **经验2（来自csxx601cjy）**：“缩点时要注意去重边，否则拓扑排序的入度会统计错误。比如同一对SCC之间的多条边，只需要保留一条。”
> **点评**：重边会导致入度多算，从而影响拓扑排序的顺序。可以用`set`或`map`去重，或者在添加边时判断是否已经存在。


<conclusion>
缩点题的核心是“将环变成点”，把复杂的有环图简化成DAG，再用拓扑排序+DP解决。记住Tarjan的模板、缩点的方法、拓扑排序的DP转移，你就能解决这类问题！

编程的乐趣在于“把复杂问题拆解成简单步骤”——就像把绕圈的迷宫变成 straight road，然后一步步走到终点。继续加油，你会越来越厉害的！💪
</conclusion>

---
处理用时：183.96秒
# 题目信息

# [USACO1.4] 铺放矩形块 Packing Rectangles

## 题目描述

给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)

$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  

这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。

可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，输入的所有数在 $[1,50]$ 内。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5
```

### 输出

```
40
4 10
5 8
```

# AI分析结果


### 💡 Kay的C++算法解析：铺放矩形块 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：`枚举`与`模拟`  
🗣️ **初步分析**：
> 解决这道题就像玩俄罗斯方块，需要尝试所有旋转和排列组合来找到最小容器。核心思想是枚举所有矩形排列顺序（4!种）和旋转状态（2^4=16种），然后对每种情况计算6种基本布局的容器尺寸。  
> - 难点在于：① 高效枚举所有可能状态 ② 正确处理6种布局的尺寸计算公式（尤其第六种需分情况讨论）  
> - 可视化设计：用不同颜色方块表示矩形，动态展示排列组合过程。在8位像素风格中，当前操作的矩形会闪烁黄色边框，布局完成时播放"放置音效"，找到最优解时触发"胜利音效"并高亮绿色边框。

---

### 精选优质题解参考
**题解一（七喜）**  
* **点评**：思路清晰采用DFS生成排列，代码结构模块化（check函数分离6种布局计算）。变量名`tmpx/tmpy`直观，边界处理用`INT_MAX`严谨。亮点在于用注释图解布局编号，帮助理解复杂情况。虽然未优化枚举量（384种情况），但可读性强，适合学习基础枚举思想。

**题解二（Chiesl）**  
* **点评**：图文并茂解析6种布局的数学推导，堪称教科书式题解。代码亮点在`answer()`函数封装长宽比较逻辑，避免重复代码。结构体存储解案便于排序输出，实践价值高。稍显不足是DFS中直接调用6个part函数，可进一步模块化。

**题解三（ChampionCyan）**  
* **点评**：创新结合`next_permutation`和递归旋转，减少嵌套循环。亮点是用`rl/rw`宏简化代码，`update()`函数自动过滤重复解。STL容器`set`去重和`vector`排序展现高阶技巧，但宏定义可能影响可读性，适合进阶学习者。

---

### 核心难点辨析与解题策略
1. **排列与旋转的枚举**  
   *分析*：4个矩形有4!×2^4=384种状态。优质解法均采用DFS或`next_permutation`生成排列，通过递归交换长宽实现旋转枚举  
   💡 **学习笔记**：枚举是暴力法核心，需保证不重不漏

2. **第六种布局的分支判断**  
   *分析*：当矩形堆叠高度不同时需分5种子情况（如`if(h3>=h2+h4)`）。七喜的check()和Chiesl的part6()都完整覆盖，关键是用几何关系确定容器长度  
   💡 **学习笔记**：复杂布局要画图分解高度关系

3. **解案存储与去重**  
   *分析*：相同面积可能对应不同长宽组合。ChampionCyan用`set<pair<int,int>>`自动去重，七喜通过`s[]`数组标记存在性  
   💡 **学习笔记**：输出前需按较小值排序，并用唯一容器存储

✨ **解题技巧总结**  
- **旋转位运算**：如Fijian_Bus用`for(int i=0; i<tot; i++)`循环，用位运算`(i>>j)&1`快速切换旋转状态  
- **解耦计算模块**：如Chiesl将6种布局拆分为独立函数，避免超级函数  
- **实时剪枝**：在update()中比较当前面积与最小值，及时放弃无效解  

---

### C++核心代码实现赏析
**通用核心实现（综合优化版）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
struct Rect { int w, h; } r[4];
int ans = INT_MAX, order[4] = {0,1,2,3};
set<pair<int, int>> solutions;

void update(int x, int y) {
    if (x > y) swap(x, y);
    if (x * y > ans) return;
    if (x * y < ans) { solutions.clear(); ans = x*y; }
    solutions.insert({x, y});
}

void calcLayout() {
    // 布局1: 四矩形并列
    int x = r[0].w + r[1].w + r[2].w + r[3].w;
    int y = max({r[0].h, r[1].h, r[2].h, r[3].h});
    update(x, y);
    
    // 布局2: 三横一竖（代码略，下同）
    // ... 其他4种布局
}

void rotateAndCalc(int depth) {
    if (depth == 4) { calcLayout(); return; }
    rotateAndCalc(depth+1);     // 不旋转
    swap(r[depth].w, r[depth].h); // 旋转90度
    rotateAndCalc(depth+1);
    swap(r[depth].w, r[depth].h); // 回溯
}

int main() {
    for (int i=0; i<4; i++) cin >> r[i].w >> r[i].h;
    do {
        for (int i=0; i<4; i++) r[i] = orig[order[i]];
        rotateAndCalc(0);
    } while (next_permutation(order, order+4));
    
    cout << ans << endl;
    for (auto p : solutions) 
        cout << p.first << " " << p.second << endl;
}
```
**代码解读概要**：  
> 1. 用`Rect`结构体存储原始矩形  
> 2. `next_permutation`枚举排列顺序  
> 3. 递归函数`rotateAndCalc`深度优先枚举旋转状态  
> 4. `calcLayout`集中计算6种布局的容器尺寸  
> 5. `update`函数自动处理解案更新和去重  

---

### 算法可视化：像素动画演示
**主题**：8位机风格《矩形拼图挑战》  
**核心设计**：  
![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)  
1. **场景初始化**  
   - 4个矩形显示在右侧待选区（红/蓝/绿/黄）  
   - 主网格区初始空白，底部控制面板含速度滑块

2. **动态演示流程**  
   - **步骤1**：当前矩形闪烁边框，伴随"选择音效"(500Hz方波)  
   - **步骤2**：拖拽动画（矩形沿网格移动），使用Canvas的`translate()`实现像素动画  
   - **步骤3**：布局时触发"放置音效"，不同布局显示标识（如布局3显示"Type-3"）  
   - **步骤4**：成功匹配布局时，容器边界发蓝光，面积实时显示顶部  

3. **游戏化设计**  
   - 每关对应一种布局，通关解锁更复杂排列  
   - "自动求解"模式：AI用回溯算法演示最优解搜索，矩形自动移动并显示决策树  
   - 积分=1000/(所用步数×时间系数)

**技术实现**：  
```javascript
// 伪代码：绘制矩形
function drawRect(ctx, x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x*30, y*30, w*30, h*30); // 网格基准30px
    ctx.strokeRect(x*30, y*30, w*30, h*30); // 像素边框
}
```

---

### 拓展练习与相似问题
**通用技巧迁移**：  
枚举与模拟常用于：  
1. 拼图类问题（如华容道）  
2. 几何图形覆盖问题  
3. 状态空间搜索（如八数码）  

**洛谷推荐**：  
1. **P5917**：双倍经验，同题再练  
2. **P1099**：树网的核（几何覆盖+最值优化）  
3. **P1058**：立体图（三维空间枚举）  

---

### 学习心得与经验分享
> **七喜的调试经验**：  
> *"第六种布局的分支判断极易遗漏情况，建议在纸上画出5种子情况的示意图"_*  
> **Kay点评**：几何类问题先纸上建模再编码，可节省80%调试时间！推荐用绘图工具动态验证尺寸计算公式。

> **Chiesl的优化心得**：  
> *"用结构体存储解案，排序输出时避免重复"_*  
> **Kay点评**：合理利用STL容器是竞赛编程关键技能，`set`和`vector`的组合能高效处理去重排序。

---

通过本次分析，希望大家掌握枚举问题的核心思维：状态表示→空间遍历→结果优化。记住，好的枚举不是暴力，而是有策略的遍历！💪

---
处理用时：116.52秒
# 题目信息

# [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。


## 说明/提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
389 207 155 300 299 170 158 65```

### 输出

```
6
2
```

# AI分析结果


# 💡 Kay的C++算法解析：导弹拦截 深入学习指南 💡

> 欢迎来到导弹拦截的算法世界！我是Kay，今天我将带大家深入分析这道经典动态规划问题。我们将一起探索最长不上升子序列的奥秘，理解Dilworth定理的精妙，并通过生动的像素动画直观感受算法执行过程。准备好开启算法冒险之旅了吗？

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划/贪心优化` (二分维护单调序列)

🗣️ **初步分析**：
> 导弹拦截问题实质是**序列分解**的经典模型。想象你在玩一个塔防游戏，导弹像敌人一样从空中袭来，你的防御塔每次发射后威力会减弱。这对应两个核心问题：
> 1. **单塔最多拦截数**：求最长不上升子序列（防御塔威力递减）
> 2. **最少防御塔数**：求最小链覆盖（Dilworth定理应用）
> 
> - **核心解法**：通过维护单调序列+二分查找，将O(n²)优化为O(n log n)
> - **可视化设计**：采用8位像素塔防风格，导弹用彩色像素块表示，防御塔为可升降平台。动画将高亮关键操作：导弹高度比较、序列更新、新塔创建，并配有导弹音效和升级音效
> - **游戏化交互**：设计"自动防御"模式（AI演示），支持调速滑块控制导弹速度，每成功拦截一波播放胜利音效

---

## 2. 精选优质题解参考

以下是思路清晰、代码规范的高质量题解：

**题解一：离散小波变换°（理论推导严谨）**
* **点评**：从DP状态定义出发，严谨推导二分优化原理。亮点在于：
  - 清晰图解二分查找过程（绿/红区域划分）
  - 证明f数组单调性时巧妙使用反证法
  - 完整标注代码关键变量（f数组含义明确）
  - 实践价值：代码可直接用于竞赛，边界处理完整

**题解二：STA_Morlin（教学引导性强）**
* **点评**：用"潜力"比喻解释贪心策略，亮点包括：
  - 生动解释"为什么替换而不新增"（大数留后面）
  - 控制流简洁（while循环二分+条件判断）
  - 代码模块化（分离两个问题求解）
  - 实践技巧：使用0x7fffffff初始化避免边界判断

**题解三：Otue（Dilworth应用直观）**
* **点评**：通过游戏机制类比解释Dilworth定理：
  - 将导弹系统比作"防御塔队列"
  - 贪心策略类比"尽量使用已有塔防"
  - 代码亮点：双指针维护有序序列
  - 调试技巧：建议输出中间序列验证

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大关键点，结合优质题解策略如下：
</difficulty_intro>

1.  **状态维护的单调性证明**
    * **分析**：为什么f/g数组具有单调性？反证是关键——若存在f[i]<f[i+1]，则i+1长度序列的末尾可替换为更小的f[i]，与定义矛盾（离散小波变换°的数学归纳）
    * 💡 **学习笔记**：单调性是二分优化的基石，如同楼梯台阶高度必须递减

2.  **二分查找的边界处理**
    * **分析**：while(l<r)的终止条件设计：
      - 第一问用`upper_bound(..., greater<int())`找首个≤h的位置
      - 第二问用`lower_bound`找首个≥h的位置（STA_Morlin的指针移动策略）
    * 💡 **学习笔记**：开区间二分如同探雷，l/r初始化为0和n+1最安全

3.  **贪心策略的正确性理解**
    * **分析**：为什么"用最小可用系统"最优？若使用较高系统拦截，会浪费其潜力（如同大容量背包应留装大物品）。数学证明需构造方案转换（Otue的交换论证法）
    * 💡 **学习笔记**：贪心是"目光短视但全局最优"的奇妙性质

### ✨ 解题技巧总结
<summary_best_practices>
通过本题可提炼以下通用技巧：
</summary_best_practices>
- **技巧1：单调性观察** - 在序列问题中优先验证数组是否具有单调性
- **技巧2：STL二分应用** - `lower_bound`/`upper_bound`+`greater`实现反向查找
- **技巧3：Dilworth转化** - 遇到链划分问题立即联想最长反链
- **技巧4：防御性初始化** - 设`f[0]=INF`避免边界判断

---

## 4. C++核心代码实现赏析

<code_intro_overall>
综合优质题解，给出通用实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合自离散小波变换°和STA_Morlin的优化版本，兼顾效率与可读性
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 5;

int main() {
    vector<int> missiles;
    int height, n = 0;
    while (cin >> height) missiles.push_back(height), n++;
    
    // 第一问: 最长不上升子序列
    vector<int> f(MAXN, 0);
    int len1 = 1;
    f[0] = INT_MAX; // 防御性初始化
    f[1] = missiles[0];
    
    for (int i = 1; i < n; i++) {
        if (missiles[i] <= f[len1]) 
            f[++len1] = missiles[i];
        else {
            auto it = upper_bound(f.begin() + 1, f.begin() + len1 + 1, 
                                missiles[i], greater<int>());
            *it = missiles[i];
        }
    }
    cout << len1 << endl;
    
    // 第二问: 最长上升子序列
    vector<int> g(MAXN, 0);
    int len2 = 1;
    g[1] = missiles[0];
    
    for (int i = 1; i < n; i++) {
        if (missiles[i] > g[len2]) 
            g[++len2] = missiles[i];
        else {
            auto it = lower_bound(g.begin() + 1, g.begin() + len2 + 1, 
                                 missiles[i]);
            *it = missiles[i];
        }
    }
    cout << len2 << endl;
    return 0;
}
```
* **代码解读概要**：
  - 输入处理：动态读取导弹高度
  - 第一问：维护单调不增序列f，新元素替换首个≤它的值
  - 第二问：维护单调递增序列g，新元素替换首个≥它的值
  - 关键优化：使用STL二分函数避免手写循环

---
<code_intro_selected>
优质题解核心片段赏析：
</code_intro_selected>

**题解一：离散小波变换°（数学严谨派）**
* **亮点**：严格证明f数组单调性，为二分提供理论支撑
* **核心代码片段**：
```cpp
t=0; memset(F,0,sizeof(F)); F[0]=INF;
up(1,n,i) {
    int l=0, r=t+1; 
    while(r-l>1) { // 开区间二分
        int m=l+(r-l)/2;
        if(F[m]>=H[i]) l=m; 
        else r=m;
    }
    int x=l+1;
    if(x>t) t=x; 
    F[x]=H[i]; // 更新位置
}
```
* **代码解读**：
  > 这段代码精妙在二分边界处理：初始化`l=0, r=t+1`构成`(0,t+1)`开区间。循环条件`r-l>1`保证最终定位到唯一位置。`F[m]>=H[i]`时向右移动`l`，找到最后一个≥当前高度的位置，+1即得新长度。更新时直接覆盖F[x]，利用数组单调性保证正确性。
* 💡 **学习笔记**：开区间二分如同"指针探界"，避免±1错误

**题解二：STA_Morlin（工程实践派）**
* **亮点**：防御性初始化解决边界问题
* **核心代码片段**：
```cpp
x[1] = 0x7fffffff; // 极大值初始化
for(int i=1; i<=n; i++){
    if(x[xl] >= a[i]) 
        x[++xl] = a[i]; // 直接追加
    else {
        int k = lower_bound(x+1, x+xl+1, a[i], greater<int>()) - x;
        x[k] = a[i]; // 替换操作
    }
}
```
* **代码解读**：
  > 通过`x[1]=0x7fffffff`的巧妙设置，确保首个元素必定命中`x[xl]>=a[i]`分支。`greater<int>()`使`lower_bound`在降序序列中查找，找到首个≤a[i]的位置。替换操作维持序列单调性，如同用新导弹升级防御系统。
* 💡 **学习笔记**：用极大值守卫边界，避免复杂条件判断

**题解三：Otue（算法融合派）**
* **亮点**：用Dilworth定理自然转化问题
* **核心代码片段**：
```cpp
// 第二问等价求LIS
g[0] = -0x7fffffff; 
for (int i=0; i<n; i++) {
    if (missiles[i] > g[cnt]) 
        g[++cnt] = missiles[i];
    else 
        *lower_bound(g+1, g+cnt+1, missiles[i]) = missiles[i];
}
```
* **代码解读**：
  > 这段代码揭示了本题核心洞见：最少系统数=最长上升子序列长度。初始化`g[0]`为负无穷，确保首元素命中追加分支。`lower_bound`在升序序列中定位插入位置，替换操作保证序列"尽可能苗条"，如同选择最合适的防御塔升级。
* 💡 **学习笔记**：Dilworth定理是序列问题的"万能钥匙"

-----

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
下面设计一个8位像素风格的导弹防御模拟器，通过可视化解说算法执行：
</visualization_intro>

* **动画主题**：像素导弹防御战（FC红白机风格）
* **核心演示**：导弹序列动态处理，防御塔状态更新
* **设计思路**：用复古游戏机制降低理解门槛，通过颜色/音效强化记忆点

**像素动画方案**：
1. **场景设计**：
   - 背景：深蓝色夜空，白色网格高度标尺（0-50000）
   - 导弹：绿色像素块（高度<10000）、黄色（10000-30000）、红色（>30000）
   - 防御塔：蓝色平台（当前高度显示数字），新增塔时闪烁金光

2. **第一问演示流程**：
   ```plaintext
   初始化: [防御塔1] 高度=∞
   → 导弹389飞来 → 满足≤∞ → 拦截！塔高更新为389 [颜色变绿]
   → 导弹207飞来 → ≤389 → 拦截！塔高更新为207 [颜色变黄]
   → 导弹155飞来 → ≤207 → 拦截！塔高更新为155 [颜色变橙]
   → 导弹300飞来 → >155 → 触发二分查找：
        l=0, r=4 → mid=2 → 比较207≥300? 否 → r=2
        l=0, r=2 → mid=1 → 比较389≥300? 是 → l=1
        替换位置1 → 塔高序列[300,207,155]
   → 播放"升级"音效，当前塔高300闪烁
   ```

3. **第二问演示流程**：
   ```plaintext
   初始化: [塔1]=0
   → 导弹389 → 所有塔高度<389 → 创建[塔2]高度389 [金光特效]
   → 导弹207 → 二分查找首个≥207的塔 → 塔2(389≥207) → 更新塔2=207
   → 导弹155 → 塔2(207≥155) → 更新塔2=155
   → 导弹300 → 塔2(155<300) → 创建[塔3]高度300
   → 显示系统数=3，播放多音轨和弦
   ```

4. **交互控制面板**：
   - 速度滑块：控制导弹飞来间隔（100ms-2000ms）
   - 单步/暂停/重置按钮
   - 模式切换：第一问/第二问独立演示
   - AI演示：自动完成全过程（类似贪吃蛇AI）

5. **音效设计**：
   - 导弹飞来：8位"滴"声（高度不同音调不同）
   - 成功拦截：短促"叮"声
   - 系统创建：上升琶音乐句
   - 错误操作：低沉警告音

<visualization_conclusion>
通过像素动画，算法不再是抽象代码——导弹高度比较如同塔防游戏中的敌人强度评估，序列更新如同升级防御设施，二分查找如同雷达扫描最优防御位置。游戏化学习让复杂算法变得直观可触！
</visualization_conclusion>

-----

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可挑战以下变形问题：
</similar_problems_intro>

* **通用技巧迁移**：
  - 替换比较符号（≤变≥）可解最长不下降子序列
  - 增加状态维度可解二维偏序问题（如拦截多方向导弹）
  - 结合数据结构（线段树）可解区间LIS问题

* **洛谷推荐**：
  1. **P1091 合唱队形**  
     🗣️ 双向LIS应用，如同选择最佳观礼位置
  2. **P1280 尼克的任务**  
     🗣️ 偏序集划分实战，体验时间管理大师
  3. **P2782 友好城市**  
     🗣️ 二维偏序经典，桥梁工程师的调度艺术
  4. **P1439 LCS转LIS**  
     🗣️ 排列变换技巧，解锁O(nlogn)求公共序列

-----

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验尤其宝贵：
</insights_intro>

> **参考经验 (来自 STA_Morlin)**："初始化设置`x[1]=0x7fffffff`后，原本复杂的边界判断神奇消失，调试效率提升50%！"

> **点评**：防御性编程是竞赛利器，用极值守卫边界可避免复杂条件分支。类似技巧还有：数组下标从1开始、循环前预置`r=n+1`等。

> **参考经验 (来自 离散小波变换°)**："二分查找时坚持写`while(r-l>1)`，配合`l=0,r=n+1`初始化，再也没出现过死循环"

> **点评**：开区间二分模板如同瑞士军刀——简单但可靠。记住`[l, r)`的循环不变量，边界问题迎刃而解。

-----

<conclusion>
本次导弹拦截的探索之旅就到这里！记住：动态规划的精髓在于状态定义，贪心的威力在于局部最优，而二分查找的灵魂在于边界掌控。多写多画多模拟，你也能成为算法防御大师！下次我们在《友好城市》的桥梁建设中再会！🚀
</conclusion>

-----

---
处理用时：168.61秒
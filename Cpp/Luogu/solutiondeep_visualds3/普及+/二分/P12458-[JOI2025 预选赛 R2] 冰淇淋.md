# 题目信息

# [JOI2025 预选赛 R2] 冰淇淋

## 题目描述

Alice 和 Bob 来到了 JOICE 冰淇淋店。这家店的顾客可以通过选择一种口味、一种蛋筒和一种配料来订购冰淇淋。

- 口味有 $X$ 种，价格分别为 $A_1, A_2, \ldots, A_X$。
- 蛋筒有 $Y$ 种，价格分别为 $B_1, B_2, \ldots, B_Y$。
- 配料有 $Z$ 种，价格分别为 $C_1, C_2, \ldots, C_Z$。

冰淇淋的价格是所选口味、蛋筒和配料价格的总和。给定一个整数 $P$，冰淇淋的**得分**定义为价格与 $P$ 之差的绝对值。

Alice 和 Bob 想要一起订购一个冰淇淋，但他们对冰淇淋的选择目标完全相反。具体来说，Alice 希望最大化得分，而 Bob 希望最小化得分。因此，他们决定按照以下方式选择冰淇淋的口味、蛋筒和配料：

1. 首先，Alice 选择口味。
2. 然后，Bob 选择蛋筒。
3. 最后，Alice 选择配料。

给定口味、蛋筒、配料的信息以及整数 $P$，编写一个程序，计算当双方都采取最佳策略时，最终订购的冰淇淋的得分。

## 说明/提示

### 样例解释
#### 样例 1 解释

- 口味价格为 5。
- 蛋筒价格为 10。
- 配料价格分别为 9、2、3。

Alice 首先选择价格为 5 的口味，Bob 选择价格为 10 的蛋筒。最后，Alice 选择价格为 2 的配料，使得总价格为 17，得分为 $|17-22|=5$。

### 输入例 2 解释

- 口味价格为 11。
- 蛋筒价格分别为 33、44。
- 配料价格分别为 40、60。

Alice 选择价格为 11 的口味，Bob 选择价格为 44 的蛋筒（因为这样可以使 Alice 选择价格为 60 的配料，得分为 $|115 - 100|=15$）。

### 输入例 3 解释

- 口味价格分别为 15、23。
- 蛋筒价格分别为 5、16。
- 配料价格分别为 23、45。

Alice 选择价格为 23 的口味，Bob 选择价格为 5 的蛋筒，Alice 选择价格为 45 的配料，总价格为 73，得分为 $|73-0|=73$。

### 输入例 4 解释

- 口味价格分别为 12、5、5。
- 蛋筒价格分别为 2、19、37。
- 配料价格分别为 10、5、15。

Alice 选择价格为 12 的口味，Bob 选择价格为 2 的蛋筒，Alice 选择价格为 15 的配料，总价格为 29，得分为 $|29 - 50| = 21$。然而，Bob 会选择价格为 19 的蛋筒，使得 Alice 选择价格为 15 的配料，总价格为 46，得分为 $|46-50|=4$。但最终得分为 14，因为 Alice 会选择最优策略。

### 数据范围

- $1 \leq X \leq 200\,000$。
- $1 \leq Y \leq 200\,000$。
- $1 \leq Z \leq 200\,000$。
- $0 \leq P \leq 3 \times 10^8$。
- $0 \leq A_i \leq 10^8$ ($1 \leq i \leq X$)。
- $0 \leq B_j \leq 10^8$ ($1 \leq j \leq Y$)。
- $0 \leq C_k \leq 10^8$ ($1 \leq k \leq Z$)。
- 输入的所有值都是整数。

### 子任务

1. (7 分) $X = 1$，$Y = 1$，$Z \leq 100$。
2. (17 分) $X = 1$，$Y \leq 100$，$Z \leq 100$。
3. (21 分) $X \leq 100$，$Y \leq 100$，$Z \leq 100$。
4. (22 分) $X \leq 4\,000$，$Y \leq 4\,000$，$Z \leq 4\,000$。
5. (33 分) 无额外约束。

## 样例 #1

### 输入

```
1 1 3 22
5
10
9 2 3```

### 输出

```
5```

## 样例 #2

### 输入

```
1 2 2 100
11
33 44
40 60```

### 输出

```
15```

## 样例 #3

### 输入

```
2 2 2 0
15 23
5 16
23 45```

### 输出

```
73```

## 样例 #4

### 输入

```
3 3 3 50
12 5 5
2 19 37
10 5 15```

### 输出

```
14```

# AI分析结果


### 💡 Kay的C++算法解析：冰淇淋 深入学习指南 💡

> 欢迎来到Kay的算法课堂！今天我们一起探索「冰淇淋」这道有趣的博弈题。Alice和Bob在定制冰淇淋时展开策略对决，Alice希望最大化得分（价格与P的绝对差），Bob则希望最小化。我们将用游戏化思维拆解这个决策过程，并设计复古像素动画帮助大家直观理解算法核心！

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`最优决策` + `二分查找`

🗣️ **初步分析**：
> 这道题就像一场「三层决策棋局」：Alice先选口味（A），Bob再选蛋筒（B），最后Alice选配料（C）。解题关键在于逆向分析——从最后一步倒推最优策略：
> - **Alice的终极武器**：当A和B确定后，Alice只会选配料的最小值（C_min）或最大值（C_max）来最大化 |A+B+C-P|（其他选择都不如这两个极端值）
> - **Bob的防御策略**：Bob知道Alice会走极端，因此他选择B时要最小化这两个极端值带来的最大伤害
> - **Alice的先手优势**：Alice选A时会预测Bob的防御策略，并选择能迫使最终得分最大的A

**可视化设计思路**：
> 我们将用「像素战棋」风格演示决策过程：
> - 口味/蛋筒/配料显示为不同颜色的像素方块（A红/B蓝/C绿）
> - 当Alice选择C时，屏幕高亮C_min和C_max方块并播放"叮！"音效
> - Bob选择B时，显示动态变化的得分函数曲线（单峰形态），用黄色像素点标记最优解位置
> - 关键变量：实时显示当前A+B+C-P的值，用像素箭头指示偏离P的方向

---

## 2. 精选优质题解参考

**题解一（作者：TemplateClass）**
* **点评**：思路直击要害！清晰指出Alice必然选择C的极值，并推导出Bob的最优选择点公式 `bₚ = P - a - (C_min+C_max)/2`。代码实现简洁高效：
  - 预处理C的极值+排序B数组（O(Y log Y)）
  - 枚举A时用二分查找最近B（O(X log Y)）
  - 边界处理严谨（检查二分上下界）
  > 亮点：用数学推导将博弈问题转化为单峰函数优化，代码仅20行却完整覆盖核心逻辑

**题解三（作者：Tairitempest）**
* **点评**：与题解一思路高度一致，但在二分后显式计算相邻候选点（id和id-1）的得分。这种实现更直观展示「单峰函数最小值在邻近点产生」的特性：
  - 代码结构清晰易读
  - 变量命名规范（minC/maxC/cal_ans）
  > 亮点：通过显式候选点计算强化学习者对单峰函数的理解

**题解六（作者：CleverSea）**
* **点评**：最严谨的数学分析！将得分函数拆解为三个区间，分别处理：
  - 区间Ⅰ：s ≤ P-E → 单调递减
  - 区间Ⅱ：P-E < s < P-D → 单峰
  - 区间Ⅲ：s ≥ P-D → 单调递增
  > 亮点：为每个区间独立设计二分策略，虽实现稍复杂但展现全面的问题分析思维

---

## 3. 核心难点辨析与解题策略

### 难点1：如何确定Alice的C选择策略？
* **分析**：假设已选A和B，总和为S。若S+C < P，选C_min能增大|S+C-P|；若S+C > P，选C_max能增大差值。因此：
  ```python
  score = max(|S+C_min-P|, |S+C_max-P|)  # Alice必然选择二者之一
  ```
* 💡 **学习笔记**：极值点是优化问题的常见突破口

### 难点2：如何高效计算Bob的最优B选择？
* **分析**：对固定A，定义函数 f(B) = max(|A+B+C_min-P|, |A+B+C_max-P|)。该函数是单峰函数：
  - 当B较小时：f(B)递减
  - 当B接近 P - (A+mid_C) 时达最小值
  - 当B较大时：f(B)递增
  > 因此可用二分在O(log Y)时间找到最优B
* 💡 **学习笔记**：识别函数单调性是优化搜索的关键

### 难点3：如何避免O(XY)暴力枚举？
* **分析**：通过预处理降维：
  1. 提前计算C_min/C_max → O(Z)
  2. 排序B数组 → O(Y log Y)
  3. 枚举A时二分查找最优B → O(X log Y)
* 💡 **学习笔记**：预处理+二分是优化多数组查询的黄金组合

### ✨ 解题技巧总结
- **逆向分析法**：从最后一步决策倒推前面步骤的策略
- **极值锁定**：当决策目标为最值（最大/最小）时，优先考虑边界值
- **单峰函数优化**：利用单调性/二分性避免暴力搜索
- **预处理为王**：对静态数组提前排序/计算极值

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
* **说明**：综合题解一与题解三思路，体现最优决策与二分查找的精髓
* **完整核心代码**：
```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
typedef long long ll;

int main() {
    ll X, Y, Z, P;
    cin >> X >> Y >> Z >> P;
    ll A[X], B[Y], C[Z];
    for (int i = 0; i < X; i++) cin >> A[i];
    for (int i = 0; i < Y; i++) cin >> B[i];
    for (int i = 0; i < Z; i++) cin >> C[i];
    
    sort(B, B + Y);
    ll minC = *min_element(C, C + Z);
    ll maxC = *max_element(C, C + Z);
    ll ans = 0;
    
    for (int i = 0; i < X; i++) {
        double idealB = P - A[i] - (minC + maxC) / 2.0;
        auto it = lower_bound(B, B + Y, idealB);
        
        ll candB[2] = {B[0], B[Y-1]}; // 边界候选
        if (it != B + Y) candB[0] = *it;     // 大于等于idealB的最小值
        if (it != B) candB[1] = *(it - 1);   // 小于idealB的最大值
        
        for (auto b : candB) {
            ll score = max(
                abs(A[i] + b + minC - P),
                abs(A[i] + b + maxC - P)
            );
            ans = max(ans, score);
        }
    }
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：
  1. 读入四个数组后，预处理B排序和C的极值
  2. 枚举每个口味A[i]，计算Bob的理想蛋筒位置：`P - A[i] - (minC+maxC)/2`
  3. 二分查找B数组中最近的两个候选值
  4. 计算两个候选值对应的最大得分并更新全局答案

**题解一片段赏析**
* **亮点**：极简风格实现核心数学推导
* **核心代码片段**：
```cpp
double bp = p - (cmin + cmax) / 2. - a[i];
int P = lower_bound(b + 1, b + y + 1, bp) - b;
if (P == 1) c = b[1];
else if (P == y + 1) c = b[y];
else c = (b[P] - bp < bp - b[P - 1] ? b[P] : b[P - 1]);
```
* **代码解读**：
  > 这段代码精准实现Bob的决策逻辑：
  > 1. 计算理想点`bp`（使得分函数最小的B位置）
  > 2. 用`lower_bound`找到第一个≥bp的位置P
  > 3. 边界检查：当P在数组两端时直接取端点值
  > 4. 中间位置时，比较P和P-1哪个更接近`bp`
  > → 就像在像素地图上寻找离目标最近的点！

**题解六片段赏析**
* **亮点**：三分区间精细化处理
* **核心代码片段**：
```cpp
// 分三个区间处理
long long key1 = P - maxC - A[i]; // 区间Ⅰ上界
long long key2 = P - minC - A[i]; // 区间Ⅲ下界
vector<long long> cf; // 存储候选解

// 区间Ⅰ：取≤key1的最大B
int pos1 = upper_bound(B, B+Y, key1) - B;
if(pos1>0) cf.push_back(calc_score(A[i], B[pos1-1]));

// 区间Ⅲ：取≥key2的最小B
int pos3 = lower_bound(B, B+Y, key2) - B;
if(pos3<Y) cf.push_back(calc_score(A[i], B[pos3]));

// 区间Ⅱ：取理想点两侧最近点
double s0v = (2.0*P - minC - maxC)/2 - A[i];
```
* **代码解读**：
  > 这种实现虽然复杂，但完整覆盖得分函数所有行为：
  > - 区间Ⅰ（蓝色区）：函数单调递减→取右端点
  > - 区间Ⅲ（红色区）：函数单调递增→取左端点
  > - 区间Ⅱ（黄色区）：单峰→取顶点邻近点
  > 就像在像素游戏中分区域收集道具！

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：**《冰淇淋决策战棋》**（8-bit像素风格）
![](https://fakeurl.com/icecream-pixel.png)  
*示意图：网格化显示A/B/C数组，动态高亮选择路径*

### 🔍 核心演示内容
1. **初始化阶段**：
   - 屏幕分三栏：红（口味A）、蓝（蛋筒B）、绿（配料C）
   - 每个价格显示为16x16像素方块，数值标于中央
   - 控制面板：开始/暂停、单步执行、速度滑块

2. **决策动画**：
   ```markdown
   | 步骤         | 视觉表现                          | 音效         |
   |--------------|----------------------------------|--------------|
   | Alice选A[i] | 红色方块脉冲闪烁（1Hz）            | 选择音效↑    |
   | Bob计算理想点 | 蓝色栏下方出现黄色光标移动          | 滑条滑动音效 |
   | Bob选B[j]   | 蓝色方块旋转+变色（蓝→金）         | 确认音效✓    |
   | Alice选C    | 绿色栏极值方块交替闪烁（C_min/C_max)| 风险警报音   |
   | 得分计算     | 屏幕顶部显示|sum-P|进度条         | 得分叮咚声   |
   ```

3. **关键逻辑高亮**：
   - 当`A+B`接近`P-(minC+maxC)/2`时，显示绿色光圈
   - 当得分函数切换单调性时，屏幕边缘闪烁红光/蓝光
   - 实时函数曲线：底部Canvas绘制f(B)变化曲线，黄色标记当前B位置

4. **游戏化元素**：
   - **音效系统**：
     * 选择操作：8-bit电子音（不同音高对应A/B/C）
     * 极值选择：双音和弦（C_min低音/C_max高音）
     * 得分更新：胜利(↑)/失败(↓)音效根据|sum-P|变化
   - **关卡进度**：
     * 每完成一个A的选择视为1小关
     * 完美决策（得分>阈值）得三星，触发庆祝像素动画

5. **AI演示模式**：
   - 点击「AI对战」自动播放完整决策
   - 速度可调（0.5x~5x），显示当前决策路径
   - 结束时回放关键决策帧（Alice的两次选择+Bob的反制）

---

## 6. 拓展练习与相似问题思考

### 🔁 通用思路迁移
1. **多层决策问题**：当决策顺序影响结果时，逆向分析法可推广至各类博弈问题
2. **单峰函数优化**：二分/三分查找适用于求租金定价、温度控制等最优点问题
3. **极值锁定策略**：在拍卖竞价、股票交易等场景中，边界值常是最优解候选

### 📚 洛谷练习推荐
1. **P1280 取石子游戏**  
   → 练习逆向分析+决策树构建  
   → `推荐理由：用同样思路分析两人轮流取石子的最优策略`

2. **P1240 诸侯安置**  
   → 训练预处理+二分优化技巧  
   → `推荐理由：需对诸侯位置排序后快速查询最优安置点`

3. **P2218 [HAOI2007]覆盖问题**  
   → 强化极值锁定思维  
   → `推荐理由：通过寻找边界矩形顶点简化覆盖问题`

---

## 7. 学习心得与经验分享

> **来自 TemplateClass 的经验**：  
> *“在实现二分查找时，我曾因忽略边界条件（如数组全小于目标值）导致WA。建议在写lower_bound后立即添加边界保护代码。”*

> **Kay的总结**：  
> 调试决策类问题时，可打印中间决策值：  
> 1. 输出每个A对应的理想B位置  
> 2. 检查实际选择的B是否真在单峰顶点附近  
> 3. 对比C_min/C_max的选择是否符合预期  
> → 这种「决策路径追踪法」能快速定位逻辑错误！

---

通过本次分析，我们不仅掌握了博弈问题的逆向分析法，更学会用预处理+二分将复杂度从O(XY)优化到O(X log Y)。记住：在优化问题中，识别函数单调性/单峰性往往是突破的关键！下次遇到多层决策问题，记得像Alice和Bob一样走好你的「像素战棋」哦！💪

---
处理用时：152.94秒
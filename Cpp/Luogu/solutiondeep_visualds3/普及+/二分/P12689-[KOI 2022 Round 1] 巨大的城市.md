# 题目信息

# [KOI 2022 Round 1] 巨大的城市

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

KOI 市太大了，移动时需要花费很长时间。为了解决这个问题，KOI 市修建了一条贯穿全城的超长道路。这些道路朝南北方向或东西方向无限延伸。南北方向的道路共有 $N$ 条，东西方向的道路共有 $M$ 条。道路的宽度可以忽略不计。

若以 KOI 市市政府为原点在坐标平面上绘制城市，则南北方向的道路可表示为 $x = a_i\ (1 \leq i \leq N)$ 的直线，东西方向的道路可表示为 $y = b_j\ (1 \leq j \leq M)$ 的直线。例如，下图展示了 $x = 3$ 的道路和 $y = 2$ 的道路。请注意，尽管图中道路是有限长度，但实际这些道路是无限延伸的。

![](https://cdn.luogu.com.cn/upload/image_hosting/as2axcwd.png)

在这 $N + M$ 条道路中，有 $K$ 条道路上各派驻了一名警察以防止超速。第 $k\ (1 \leq k \leq K)$ 名警察的位置是 $(p_k, q_k)$，且每名警察必定位于其负责的道路上。

例如，图中有一名警察被派驻在 $x = 3$ 的道路上 $(3, -2)$ 处，另一名警察被派驻在 $y = 2$ 的道路上 $(-4, 2)$ 处。某些道路上可能没有警察，但如果某条道路上有警察，则只会有一名。

![](https://cdn.luogu.com.cn/upload/image_hosting/d7n73voc.png)

警察只能沿道路移动。如果两条道路交叉，则警察可以在交点处切换到另一条道路，切换过程无需耗费距离。

如下图所示，一名警察可以从 $x = 3$ 的道路上 $(3, -2)$ 处出发，经由交点 $(3, 2)$ 切换到 $y = 2$ 的道路上，从而移动到另一名警察所在的位置，所需移动总距离为 $11$。

![](https://cdn.luogu.com.cn/upload/image_hosting/4exico08.png)

警察需要在紧急情况下能够迅速会合。因此，你的任务是：对于所有可能的两两警察组合，计算他们最短的相遇距离，并输出所有这些最短距离的总和。

![](https://cdn.luogu.com.cn/upload/image_hosting/2qlef35p.png)

在这个例子中，共有 3 种可能的组合：

- 位于 $y = 2$ 道路的警察与位于 $x = -4$ 道路的警察会合。这种情况下，两位警察至少需要移动 $3$ 单位距离才能相遇。
- 位于 $y = 2$ 道路的警察与位于 $x = 3$ 道路的警察会合。这种情况下，两位警察至少需要移动 $11$ 单位距离才能相遇。
- 位于 $x = -4$ 道路的警察与位于 $x = 3$ 道路的警察会合。这种情况下，两位警察至少需要移动 $12$ 单位距离才能相遇。

因此，总和为 $26$。虽然有两名警察的 $x$ 坐标都是 $-4$，但警察 $(-4, 2)$ 是驻扎在 $y = 2$ 道路上的，而警察 $(-4, -1)$ 则在 $x = -4$ 道路上，所以这样的输入是有效的，请注意此类情况。

请你编写一个程序，给定 KOI 市的道路和警察的位置，计算如上所述的所有警察两两之间最短相遇距离的总和。

## 说明/提示

**约束条件**

- 所有输入均为整数。
- $1 \leq N \leq 100\,000$
- $1 \leq M \leq 100\,000$
- $2 \leq K \leq N + M$
- $-100\,000 \leq a_i \leq 100\,000\quad (1 \leq i \leq N)$
- $-100\,000 \leq b_j \leq 100\,000\quad (1 \leq j \leq M)$
- $-100\,000 \leq p_k, q_k \leq 100\,000\quad (1 \leq k \leq K)$
- 所有 $a_i$ 互不相同，所有 $b_j$ 互不相同，所有警察位置 $(p_k, q_k)$ 互不相同
- 每条道路上最多只有一名警察

**子任务**

1. （14 分）$M = 1$
2. （11 分）所有警察都仅驻扎在两条道路的交点上
3. （20 分）$1 \leq N, M \leq 20$
4. （25 分）$1 \leq N, M \leq 1\,000$
5. （30 分）无附加限制

## 样例 #1

### 输入

```
2 2 3
-4 3
2 -4
-4 2
-4 -1
3 -2```

### 输出

```
26```

## 样例 #2

### 输入

```
2 3 5
-2 5
5 -3 2
-1 5
0 2
4 -3
5 4
-2 -2```

### 输出

```
88```

# AI分析结果


### 题目分析

#### 题目概述
题目描述了一个巨大的城市网格，由南北向道路（x = a_i）和东西向道路（y = b_j）组成。城市中有 K 个警察，每个警察位于某条道路上（即要么在南北向道路上，要么在东西向道路上）。警察只能沿道路移动，并在交点处切换道路。任务是计算所有警察两两组合的最短相遇距离之和。

#### 核心算法识别
本题的核心算法是 **坐标分离优化与双维度分类讨论**，结合了 **绝对差最小化** 和 **独立轴优化** 的思想。简单来说，可以将问题建模为二维空间中的路径优化问题，但需独立处理 x 轴和 y 轴上的移动成本，并通过预处理和分类讨论高效求解。

- **算法核心思想**：  
  将警察按所在道路类型分类（南北向为 A 类，东西向为 B 类）。对于任意两个警察，最短相遇距离取决于他们相遇的位置（可能在某条道路的交点或非交点）。通过分析，最优相遇策略可分解为：
  - **选项1（在交点相遇）**：  
    \(\text{dist}_1 = \min_{a_i \in A_{\text{set}}} (|x_1 - a_i| + |x_2 - a_i|) + \min_{b_j \in B_{\text{set}}} (|y_1 - b_j| + |y_2 - b_j|)\)
  - **选项2（在水平道路相遇）**：  
    \(\text{dist}_2 = |x_1 - x_2| + \min_{b_j \in B_{\text{set}}} (|y_1 - b_j| + |y_2 - b_j|)\)
  最终最短距离为 \(\min(\text{dist}_1, \text{dist}_2)\)。

- **应用场景**：  
  该策略有效的原因是警察移动受限于给定道路网格。最优相遇点必须是道路网络上的点（交点或水平/垂直道路上的点），通过独立优化 x 轴和 y 轴的成本，并利用预处理技术加速计算。

#### 解题难点
1. **移动约束的建模**：  
   警察只能在给定的道路网格上移动，且相遇点必须是道路上的点（非任意平面点），这增加了最优路径计算的复杂度。
   
2. **多维度优化**：  
   需要独立处理 x 轴和 y 轴的成本最小化，并对所有警察对（共 \(O(K^2)\) 组合）高效计算。

3. **大规模数据处理**：  
   \(K, N, M\) 高达 \(10^5\)，暴力枚举所有组合不可行，需设计 \(O(K \log K)\) 的聚合算法。

### 算法可视化：像素动画演示

#### 设计思路
我们设计一个 **8位像素风格** 的动画，模拟警察在网格道路上的移动和相遇过程。动画采用 **复古游戏界面**（类似 FC 红白机），通过颜色高亮、音效和步进控制，直观展示算法核心步骤。

- **整体风格**：  
  采用 16 色调色板，网格道路用像素方块表示（南北向：蓝色竖线；东西向：红色横线）。警察用不同颜色像素点表示（A 类：黄色；B 类：绿色）。

- **关键动画流程**：
  1. **初始化场景**：  
     绘制城市网格（如图 1），标记警察起点（如警察 A 在 \((-4, -1)\)，警察 B 在 \((3, -2)\)）。
     ![](https://cdn.luogu.com.cn/upload/image_hosting/as2axcwd.png)
  2. **移动路径高亮**：  
     - 当警察移动时，路径上的方块逐帧高亮（黄色/绿色闪烁）。
     - 在交点切换道路时播放 "切换音效"（短促 "叮" 声）。
  3. **相遇点计算**：  
     - 选项 1（交点相遇）：在交点 \((a_i, b_j)\) 显示闪烁红星，并显示路径成本（如 \(\text{dist}_1 = 12\)）。
     - 选项 2（水平道路相遇）：沿水平道路滑动相遇点，动态更新成本（如图 2）。
     ![](https://cdn.luogu.com.cn/upload/image_hosting/4exico08.png)
  4. **结果展示**：  
     相遇时播放 "胜利音效"（8 位上扬音阶），并显示总移动距离。

- **交互控制**：
  - **步进/暂停**：单步执行移动过程。
  - **速度滑块**：调整动画速度（1x~5x）。
  - **AI 自动演示**：自动播放最优路径（类似贪吃蛇 AI 移动）。

#### 技术实现
- **Canvas 绘制**：  
  网格用 `drawGrid()` 函数绘制，警察移动路径通过逐帧更新坐标并重绘实现。
  ```javascript
  function drawGrid() {
    for (let a_i of A_set) drawVerticalLine(a_i, BLUE);
    for (let b_j of B_set) drawHorizontalLine(b_j, RED);
  }
  ```
- **音效设计**（Web Audio API）：
  - 移动：低音 "滴" 声。
  - 相遇：高音 "胜利" 音效。
  - 错误：短促 "哔" 声。

### 核心代码实现赏析

#### 通用核心代码
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

typedef long long LL;

// 计算最小绝对差值和（单轴）
LL min_sum_dist(vector<LL>& pos, vector<LL>& refs) {
    sort(refs.begin(), refs.end());
    LL total = 0;
    for (auto p : pos) {
        auto it = lower_bound(refs.begin(), refs.end(), p);
        if (it == refs.end()) total += p - refs.back();
        else if (it == refs.begin()) total += refs.front() - p;
        else {
            LL d1 = p - *(it-1), d2 = *it - p;
            total += min(d1, d2);
        }
    }
    return total;
}

// 计算所有对的最小值和
LL solve(vector<LL>& A_set, vector<LL>& B_set, vector<pair<LL, LL>>& cops) {
    vector<LL> xs, ys;
    for (auto [x, y] : cops) {
        xs.push_back(x);
        ys.push_back(y);
    }

    // 预处理坐标排序
    sort(A_set.begin(), A_set.end());
    sort(B_set.begin(), B_set.end());
    sort(xs.begin(), xs.end());
    sort(ys.begin(), ys.end());

    // 计算选项2中的 min_b |y1-b| + |y2-b|
    vector<LL> minB_pair(cops.size(), 0);
    // ...（此处省略具体实现，需用前缀和优化）

    LL ans = 0;
    for (int i = 0; i < cops.size(); i++) {
        for (int j = i+1; j < cops.size(); j++) {
            auto [x1, y1] = cops[i];
            auto [x2, y2] = cops[j];
            LL opt1 = min_sum_dist({x1, x2}, A_set) + min_sum_dist({y1, y2}, B_set);
            LL opt2 = abs(x1 - x2) + min_sum_dist({y1, y2}, B_set);
            ans += min(opt1, opt2);
        }
    }
    return ans;
}

int main() {
    // 输入处理
    int N, M, K;
    cin >> N >> M >> K;
    vector<LL> A_set(N), B_set(M);
    for (int i = 0; i < N; i++) cin >> A_set[i];
    for (int i = 0; i < M; i++) cin >> B_set[i];
    vector<pair<LL, LL>> cops(K);
    for (int i = 0; i < K; i++) cin >> cops[i].first >> cops[i].second;

    cout << solve(A_set, B_set, cops) << endl;
    return 0;
}
```

#### 代码解读概要
- **输入处理**：读入道路和警察坐标。
- **预处理**：对道路和警察坐标排序，为二分查找做准备。
- **关键函数**：
  - `min_sum_dist()`：计算一组点到参考点集的最小绝对差值和（单轴优化）。
  - `solve()`：聚合算法逻辑，遍历所有警察对并计算最短相遇距离。
- **算法核心**：对每对警察计算两个选项的距离并取最小值。

### 拓展练习
1. **洛谷 P1908** - 逆序对  
   **推荐理由**：巩固坐标离散化和绝对差求和技巧，与本题的预处理方法高度相关。

2. **洛谷 P1886** - 滑动窗口  
   **推荐理由**：训练单调队列优化，适用于优化本题中的最小值查询。

3. **洛谷 P1090** - 合并果子  
   **推荐理由**：练习贪心算法的同时，为路径优化问题提供基础思路。

### 学习心得
- **关键点**：将二维路径优化分解为独立轴处理，结合预处理（排序、二分）加速查询。
- **调试技巧**：对边界情况（如坐标在参考点集之外）需额外处理，避免逻辑错误。
- **迁移应用**：该算法框架适用于任何网格路径优化问题（如机器人导航）。 

通过本指南，希望学习者能够掌握坐标分离优化思想，并在类似问题中举一反三。

---
处理用时：795.32秒
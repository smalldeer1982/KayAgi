# 题目信息

# [AHOI2008] 紧急集合 / 聚会

## 题目描述

欢乐岛上有个非常好玩的游戏，叫做“紧急集合”。在岛上分散有 $n$ 个等待点，有 $n-1$ 条道路连接着它们，每一条道路都连接某两个等待点，且通过这些道路可以走遍所有的等待点，通过道路从一个点到另一个点要花费一个游戏币。

参加游戏的人三人一组，开始的时候，所有人员均任意分散在各个等待点上（每个点同时允许多个人等待），每个人均带有足够多的游戏币（用于支付使用道路的花费）、地图（标明等待点之间道路连接的情况）以及对话机（用于和同组的成员联系）。当集合号吹响后，每组成员之间迅速联系，了解到自己组所有成员所在的等待点后，迅速在 $n$ 个等待点中确定一个集结点，组内所有成员将在该集合点集合，集合所用花费最少的组将是游戏的赢家。

小可可和他的朋友邀请你一起参加这个游戏，由你来选择集合点，聪明的你能够完成这个任务，帮助小可可赢得游戏吗？


## 说明/提示

对于 $40\%$ 的数据，$n\leq2\times10^3$，$m\leq2\times 10^3$。

对于 $100\%$ 的数据，$1\leq x,y,z\leq n\leq 5\times10^5$，$1\leq m\leq 5\times 10^5$。

## 样例 #1

### 输入

```
6 4  
1 2  
2 3  
2 4 
4 5
5 6
4 5 6
6 3 1
2 4 4 
6 6 6```

### 输出

```
5 2
2 5
4 1
6 0


```

# AI分析结果


### 题目分析
本题要求在树上找到一个点，使得给定的三个点到该点的距离之和最小。通过分析题解，核心结论如下：
1. 最优集合点是三个点两两最近公共祖先（LCA）中深度最大的那个。
2. 最小距离和为：三个点深度之和减去三个两两LCA的深度之和。

### 算法思路
1. **预处理**：使用深度优先搜索（DFS）初始化每个节点的深度和倍增数组（用于高效查询LCA）。
2. **LCA查询**：利用倍增算法快速查询任意两点的最近公共祖先。
3. **处理查询**：对于每个查询：
   - 计算三个点两两之间的LCA。
   - 选择深度最大的LCA作为集合点。
   - 计算最小距离和：`depth[x] + depth[y] + depth[z] - depth[a] - depth[b] - depth[c]`。

### 核心代码实现
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 500010;
const int LOG = 20; // 2^20 > 500000

vector<int> tree[MAXN];
int depth[MAXN];
int fa[MAXN][LOG];

void dfs(int u, int parent) {
    depth[u] = depth[parent] + 1;
    fa[u][0] = parent;
    for (int i = 1; i < LOG; i++) {
        if (fa[u][i-1] != -1) {
            fa[u][i] = fa[fa[u][i-1]][i-1];
        } else {
            fa[u][i] = -1;
        }
    }
    for (int v : tree[u]) {
        if (v == parent) continue;
        dfs(v, u);
    }
}

int lca(int u, int v) {
    if (depth[u] < depth[v]) swap(u, v);
    int diff = depth[u] - depth[v];
    for (int i = 0; i < LOG; i++) {
        if (diff & (1 << i)) {
            u = fa[u][i];
        }
    }
    if (u == v) return u;
    for (int i = LOG - 1; i >= 0; i--) {
        if (fa[u][i] != fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return fa[u][0];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    int n, m;
    cin >> n >> m;
    
    // 初始化
    for (int i = 1; i <= n; i++) {
        tree[i].clear();
        for (int j = 0; j < LOG; j++) {
            fa[i][j] = -1;
        }
    }
    
    // 建树
    for (int i = 0; i < n - 1; i++) {
        int u, v;
        cin >> u >> v;
        tree[u].push_back(v);
        tree[v].push_back(u);
    }
    
    // DFS预处理
    depth[0] = -1;
    dfs(1, 0);
    
    // 处理每个查询
    while (m--) {
        int x, y, z;
        cin >> x >> y >> z;
        
        // 计算两两LCA
        int a = lca(x, y);
        int b = lca(x, z);
        int c = lca(y, z);
        
        // 选择深度最大的LCA作为集合点
        int p = a;
        if (depth[b] > depth[p]) p = b;
        if (depth[c] > depth[p]) p = c;
        
        // 计算最小距离和
        int dist = depth[x] + depth[y] + depth[z] - depth[a] - depth[b] - depth[c];
        
        // 输出结果
        cout << p << " " << dist << "\n";
    }
    
    return 0;
}
```

### 算法分析
- **时间复杂度**：
  - 预处理DFS：O(n log n)
  - 每次LCA查询：O(log n)
  - 总时间复杂度：O((n + m) log n)
- **空间复杂度**：O(n log n)（存储倍增数组）

### 关键点说明
1. **深度初始化**：根节点深度设为0，子节点深度逐层递增。
2. **倍增数组**：`fa[u][i]`表示节点u向上跳2^i步到达的节点，用于高效查询LCA。
3. **距离公式**：三个点深度之和减去三个LCA深度之和，避免了重复路径计算。

此算法高效可靠，适合处理大规模树结构查询问题。

---
处理用时：127.30秒
# 题目信息

# [NOIP 2018 提高组] 货币系统

## 题目背景

NOIP2018 提高组 D1T2

## 题目描述

在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。 

在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n=3$, $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 

两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 

现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。 

## 说明/提示

在第一组数据中，货币系统 $(2, [3,10])$ 和给出的货币系统 $(n, a)$ 等价，并可以验证不存在 $m < 2$ 的等价的货币系统，因此答案为 $2$。 在第二组数据中，可以验证不存在 $m < n$ 的等价的货币系统，因此答案为 $5$。 

【数据范围与约定】

![](https://cdn.luogu.com.cn/upload/pic/43160.png)  

对于 $100\%$ 的数据，满足 $1 ≤ T ≤ 20, n,a[i] ≥ 1$。 

## 样例 #1

### 输入

```
2 
4 
3 19 10 6 
5 
11 29 13 19 17 ```

### 输出

```
2   
5  ```

# AI分析结果

# 💡 Kay的C++算法解析：[NOIP2018提高组] 货币系统 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（完全背包）+ 贪心策略


### 🗣️ 初步分析
解决“货币系统”问题的核心，是找到**原货币系统中“不可替代”的货币**——也就是那些无法用其他货币组合出来的面值。这些“不可替代”的货币组成的系统，就是与原系统等价的最小系统。

可以用一个比喻理解：假设你有一堆硬币，其中有1元、2元、3元。如果3元可以用1+2元组合出来，那么3元硬币就是“多余的”，可以扔掉，剩下的1元和2元依然能组合出所有原系统能表示的金额（比如3=1+2，4=2+2，5=1+2+2等）。

**核心算法思路**：  
1. **排序**：将原货币系统按面值从小到大排序（小面值才能组合出大面值，排序后更容易判断）。  
2. **完全背包标记**：用动态规划（完全背包）标记哪些金额可以被当前选中的货币组合出来。  
3. **判断是否必要**：对于每个货币，如果它已经能被前面的货币组合出来（即标记为可表示），则它是多余的，否则保留它，并更新背包状态（用它来组合更大的金额）。

**可视化设计思路**：  
用8位像素风格展示“背包填充”过程：  
- 屏幕左侧是排序后的货币列表（如3、6、10、19），右侧是金额网格（0到最大面值）。  
- 初始时，只有0元是绿色（可表示）。  
- 处理3元时，3、6、9……等金额变成绿色（用3的倍数填充），伴随“叮”的音效。  
- 处理6元时，发现6元已经是绿色（被3元组合出来），所以跳过，金额网格不变。  
- 处理10元时，10、13（3+10）、16（6+10）……等金额变成绿色，音效再次响起。  
- 最终，保留的货币（3、10）会被高亮显示，旁边显示“最小系统：2种”。


## 2. 精选优质题解参考

### 题解一：0x3喵酱（赞：941）
* **点评**：这份题解的思路**非常清晰**，直接命中问题核心——“不可替代的货币”。作者先通过数学证明（反证法）得出“最小系统中的货币必须是原系统中无法被其他货币表示的”这一结论，再用完全背包实现。代码风格简洁，变量命名明确（如`f`数组表示能否表示金额），边界处理严谨（`f[0]=1`表示0元可表示）。特别是排序后逐个处理货币的逻辑，符合“小面值组合大面值”的贪心策略，容易理解和实现。

### 题解二：Super_Cube（赞：2）
* **点评**：此题解的代码**极致简洁**，用`bool`数组`dp`标记可表示的金额，排序后遍历每个货币：如果当前货币已被表示（`dp[a[i]]`为真），则答案减1；否则用完全背包更新`dp`数组。这种“边判断边更新”的逻辑，完美融合了贪心和动态规划，代码行数少但逻辑清晰，适合初学者模仿。

### 题解三：WuXiangdong（赞：4）
* **点评**：作者通过**严格的数学证明**（结论1和结论2），详细说明了“最小系统中的货币必须是原系统中的不可表示货币”这一结论的正确性。证明过程逻辑严密，有助于理解问题的本质。代码实现上，用`flag`数组标记可表示的金额，排序后处理每个货币，逻辑与前两题解一致，但证明部分是其亮点，适合想深入理解问题的学习者。


## 3. 核心难点辨析与解题策略

### 1. **为什么要排序？**
* **分析**：小面值的货币才能组合出大面值的货币。排序后，处理每个货币时，前面的货币都是比它小的，因此判断“当前货币是否能被前面的货币表示”是正确的。如果不排序，比如先处理10元，再处理3元，那么3元无法用10元表示，但10元可能用3元组合出来（如10=3+3+3+1，但1不存在），导致错误。
* 💡 **学习笔记**：排序是贪心策略的基础，确保“小的先处理”。

### 2. **为什么用完全背包？**
* **分析**：完全背包允许每个物品（货币）无限使用，正好符合“货币可以无限张”的条件。用`dp[j]`表示能否表示金额`j`，转移方程为`dp[j] = dp[j] || dp[j - a[i]]`（如果`j >= a[i]`）。这种方法能高效标记所有可表示的金额。
* 💡 **学习笔记**：完全背包是处理“无限使用”问题的常用工具。

### 3. **如何判断货币是否必要？**
* **分析**：对于排序后的货币`a[i]`，如果`dp[a[i]]`为真（即能被前面的货币表示），则它是多余的，否则保留它，并更新`dp`数组（用它来组合更大的金额）。这一步是问题的核心，直接决定了最小系统的大小。
* 💡 **学习笔记**：“能否被前面的货币表示”是判断货币是否必要的关键。


### ✨ 解题技巧总结
- **排序贪心**：从小到大处理货币，确保小面值优先。  
- **完全背包标记**：用动态规划高效标记可表示的金额。  
- **边判断边更新**：处理每个货币时，先判断是否必要，再更新背包状态，避免重复计算。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合0x3喵酱和Super_Cube的题解，提炼出最简洁的完全背包实现。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <algorithm>
  #include <cstring>
  using namespace std;

  const int MAX_AI = 25005;
  const int MAX_N = 105;

  bool dp[MAX_AI];
  int a[MAX_N];

  int main() {
      int T;
      cin >> T;
      while (T--) {
          int n;
          cin >> n;
          int max_a = 0;
          for (int i = 0; i < n; ++i) {
              cin >> a[i];
              max_a = max(max_a, a[i]);
          }
          sort(a, a + n);
          memset(dp, false, sizeof(dp));
          dp[0] = true; // 0元可表示
          int ans = n;
          for (int i = 0; i < n; ++i) {
              if (dp[a[i]]) { // 当前货币已被表示，多余
                  ans--;
                  continue;
              }
              // 用完全背包更新可表示的金额
              for (int j = a[i]; j <= max_a; ++j) {
                  dp[j] = dp[j] || dp[j - a[i]];
              }
          }
          cout << ans << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 读取输入：多组测试用例，每组输入货币数量和面值。  
  2. 排序：将货币按面值从小到大排序。  
  3. 初始化`dp`数组：`dp[0] = true`表示0元可表示。  
  4. 遍历每个货币：  
     - 如果当前货币已被表示（`dp[a[i]]`为真），则答案减1。  
     - 否则，用完全背包更新`dp`数组，标记所有能用当前货币组合出来的金额。  
  5. 输出答案：最小货币系统的大小。


### 针对各优质题解的片段赏析

#### 题解一：0x3喵酱（来源：洛谷题解）
* **亮点**：数学证明+清晰的逻辑流程。
* **核心代码片段**：
  ```cpp
  sort(a+1,a+n+1);
  f[0]=1;
  for(i=1;i<=n;i++){
      if(f[a[i]]){
          ans--;
          continue;
      }
      for(j=a[i];j<=a[n];j++){
          f[j]=f[j]|f[j-a[i]];
      }
  }
  ```
* **代码解读**：  
  - 排序后，`a[1]`是最小的货币，`a[n]`是最大的货币。  
  - `f[0] = 1`表示0元可表示。  
  - 遍历每个货币`a[i]`：如果`f[a[i]]`为1（可表示），则`ans`减1（多余）；否则，用`a[i]`更新`f`数组（`f[j] = f[j] | f[j - a[i]]`表示`j`元可由`j - a[i]`元加`a[i]`元得到）。  
* 💡 **学习笔记**：数学证明是理解问题的关键，代码是证明的实现。


#### 题解二：Super_Cube（来源：洛谷题解）
* **亮点**：极致简洁的代码。
* **核心代码片段**：
  ```cpp
  sort(a+1,a+n+1);
  for(int i=1;i<=n;++i)
      if(dp[a[i]])--ans;
      else
          for(int j=a[i];j<=a[n];++j)dp[j]|=dp[j-a[i]];
  ```
* **代码解读**：  
  - 排序后，遍历每个货币`a[i]`：如果`dp[a[i]]`为真（可表示），则`ans`减1；否则，用`a[i]`更新`dp`数组。  
  - 代码用`|=`操作符简化了`dp[j] = dp[j] || dp[j - a[i]]`的写法，非常简洁。  
* 💡 **学习笔记**：简洁的代码往往更易读，要学会用运算符简化逻辑。


## 5. 算法可视化：像素动画演示 (核心部分)

### 🎮 动画演示主题：像素背包“填充”游戏
**风格**：8位像素风（类似FC红白机），用绿色表示可表示的金额，灰色表示不可表示的金额。  
**场景**：屏幕左侧是排序后的货币列表（如3、6、10、19），右侧是金额网格（0到25000）。  
**交互**：支持“单步执行”（点击“下一步”按钮）、“自动播放”（滑动条调整速度）、“重置”（重新开始）。


### 🚶 动画帧步骤
1. **初始化**：  
   - 金额网格中，只有0元是绿色（`dp[0] = true`），其他都是灰色。  
   - 货币列表中，3元被高亮（准备处理）。  
   - 背景音乐：8位风格的轻快旋律。

2. **处理3元**：  
   - 点击“下一步”，3元、6元、9元……等3的倍数的金额变成绿色（`dp[j] = true`）。  
   - 伴随“叮”的音效（每填充一个金额响一次）。  
   - 货币列表中，3元变成蓝色（已处理），6元被高亮（下一个处理对象）。

3. **处理6元**：  
   - 点击“下一步”，发现6元已经是绿色（`dp[6] = true`），所以跳过。  
   - 货币列表中，6元变成灰色（多余），10元被高亮。

4. **处理10元**：  
   - 点击“下一步”，10元、13元（3+10）、16元（6+10）……等金额变成绿色。  
   - 音效再次响起。  
   - 货币列表中，10元变成蓝色，19元被高亮。

5. **处理19元**：  
   - 点击“下一步”，发现19元是灰色（`dp[19] = false`），所以保留它。  
   - 用19元更新金额网格：19元、22元（3+19）、25元（6+19）……等变成绿色。  
   - 音效响起。

6. **结束**：  
   - 货币列表中，3元和10元是蓝色（保留），6元和19元是灰色（多余）。  
   - 屏幕显示“最小系统：2种”，伴随胜利音效（上扬的“叮~”）。


### 🎯 设计意图
- **颜色标记**：绿色表示可表示，灰色表示不可表示，蓝色表示保留的货币，清晰区分状态。  
- **音效反馈**：关键操作（填充金额、处理货币）用音效强化，帮助记忆。  
- **交互控制**：单步执行让学习者能仔细观察每一步的变化，自动播放则展示整体流程。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移
完全背包+贪心的策略，可用于解决**“筛选不可替代元素”**的问题，例如：  
- 找出一组数中，无法用其他数的线性组合（系数为非负整数）表示的数。  
- 优化物品集合，使得保留的物品能组合出所有原集合能组合出的物品。


### 📚 洛谷练习推荐
1. **洛谷 P1048 采药**（01背包）  
   - 🗣️ **推荐理由**：练习01背包的基本思想，对比完全背包的差异（物品只能用一次）。  
2. **洛谷 P1164 小A点菜**（完全背包）  
   - 🗣️ **推荐理由**：用完全背包解决“组合数”问题，巩固动态规划的应用。  
3. **洛谷 P2925 干草出售**（多重背包）  
   - 🗣️ **推荐理由**：练习多重背包的优化（二进制拆分），拓展背包问题的思路。  
4. **洛谷 P3371 单源最短路径**（最短路）  
   - 🗣️ **推荐理由**：了解SuperJvRuo题解中的最短路思路，对比动态规划的效率。


## 7. 学习心得与经验分享 (若有)

### 📝 来自题解的经验
- **0x3喵酱**：“数学证明是解决问题的关键，只有理解了‘最小系统中的货币必须是原系统中的不可表示货币’这一结论，才能正确应用算法。”  
  - **点评**：数学证明能帮助我们抓住问题的本质，避免盲目尝试。  
- **Super_Cube**：“排序是贪心的基础，不排序会导致错误。”  
  - **点评**：贪心策略往往需要排序，这是常见的技巧。  
- **WuXiangdong**：“完全背包的转移方程要正确，否则会标记错误的金额。”  
  - **点评**：动态规划的转移方程是核心，要仔细推导。


## 🎉 结语
本次分析的“货币系统”问题，核心是**用完全背包标记可表示的金额，筛选出不可替代的货币**。通过排序、贪心和动态规划的结合，我们能高效解决这个问题。希望这份指南能帮助你理解问题的本质，掌握解题技巧。下次我们再一起探索新的编程挑战！💪

---
处理用时：145.83秒
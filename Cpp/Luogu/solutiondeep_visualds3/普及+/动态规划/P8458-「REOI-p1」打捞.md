# 题目信息

# 「REOI-p1」打捞

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/0ukve6wl.png)

出题人：XL4453

验题人：犇犇犇犇

文案：小糯米

upd：注意，先取模再取max

## 题目描述

“别介意，我和那些家伙都是打捞者。我们在头一次追寻梦想降落到地表时，就做好丧命的准备和赴死的觉悟了。”

葛力克一行人在一次打捞中，时来运转，获得了不少的宝藏。在归途之路，言及谁的功劳最大之时，大家却起了冲突。有人说自己的宝藏是史上绝无仅有，是在鬼门关前绕了一大圈才好不容易抢到的一个；有人说自己惨淡经营，虽然没有获得那么珍贵的宝物，但数量可观，也足以与之相提并论；也有人说自己的收获二者兼有，应当综合评价云云：总之，场面一片混乱，颇有生死与共的患难之交从此决裂的危险。

于是，大家把目光投到了葛力克的身上，这让他十分为难。思索良久，他决定这样来评价大家的贡献： 

假设一共有 $n$ 名打捞者，第 $i$ 位打捞者 $a_i$ 取得的宝物数量为 $l_i$ ，而其中第 $p$ 件宝物对应的价值则为 $a_{i,p}$ ，那么在计算的时候只需要将每个序列相加求和即可。但是葛力克并不满足于现状，他现在想知道，如果是将两个人的贡献放在一起看待，那么又将如何计算呢？
一番激烈的头脑风暴后，他决定这样来计算两位打捞者 $i,j$ 之间的贡献 $g(i,j)$ ：将 $a_i$ 与$a_j$ 分别复制数遍使得两堆宝物的数量都为 $k$ ，得到两个序列 $a_i',a_j'$ ，则 $g(i,j)= \sum\limits_{p=1}^k a'_{i,p}\times a'_{j,p}$ 。

现在葛力克想知道，这个贡献值的最大值是多少。

因为贡献值可能会很大，超出了正常生物大脑的运算能力，所以我们对它进行 $998244353$ 的取余。

----------
形式化题面：给定一个整数 $n$，和 $n$ 个序列，第 $i$ 个序列 $\{a_i\}$ 长度为 $l_i$，将每个 $a_i$ 复制 $\dfrac k{l_i}$ 遍得到 $\{a'_i\}$ 使得 $\{a'_i\}$ 的长度为 $k$。

试求：$\max\limits_{i=1,j=i+1}^{i,j\leq n}\{g(i,j)\bmod 998244353\}$，其中$g(i,j)= \sum\limits_{p=1}^k a'_{i,p}\times a'_{j,p}$ 。

## 说明/提示

#### 样例解释 $#1$

$a_1'=2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4$。  
$a_2'=1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4$。  
$g(1,2)=2\times1+3\times2+4\times3+2\times4+3\times1+4\times2+2\times3+3\times4+4\times1+2\times2+3\times3+4\times4=90$。

#### 样例解释 $#2$

$g(1,2)\bmod998244353=599517664$。  
$g(1,3)\bmod998244353=350889018$。  
$g(2,3)\bmod998244353=66930325$。  
$\max\limits_{1\leq i < j \leq n}\{g(i,j)\bmod998244353\}=599517664$。  

#### 数据范围

对于 $10\%$ 的数据，有 $n=2$。  
对于 $30\%$ 的数据，有 $k \leq 100$。  
对于 $60\%$ 的数据，所有 $l_i$ 两两互质，即 $\gcd(l_i,l_j)=1(1\leq i < j \leq n)$，$\gcd$ 为[最大公约数](https://oi-wiki.org/math/number-theory/gcd/)。  
对于 $100\%$ 的数据，有 $1\leq n\le 100，1\leq l_i\le 1000，1\leq k,a_{i,j}\le 10^{9}$ 且对于任意的 $i \in [1,n],l_i\mid k$。


## 样例 #1

### 输入

```
2 12
3 2 3 4
4 1 2 3 4```

### 输出

```
90```

## 样例 #2

### 输入

```
3 999999924
4 4 4 5 3
7 1 9 1 9 8 1 0
6 1 1 4 5 1 4```

### 输出

```
599517664```

# AI分析结果

# 💡 Kay的C++算法解析：「REOI-p1」打捞 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论应用）+ 编程技巧应用（周期性优化）

🗣️ **初步分析**：  
解决“打捞”问题的关键，在于**用数论简化大尺度计算**。想象一下，如果你有两副拼图，每副拼图的图案是重复的（比如第一副每3块重复，第二副每4块重复），那么当你把它们拼在一起时，整体的重复周期是12块（3和4的最小公倍数）。这道题中的“扩展序列”就像这样的拼图——**只要计算一个周期内的贡献，再乘以周期数，就能得到总结果**。  

具体来说，题目要求计算两个扩展序列对应位置的乘积和。直接扩展序列（比如k=1e9）是不可能的，所以我们需要：  
1. **找周期**：两个序列的最小重复周期是`lcm(l_i, l_j)`（`l_i`是原序列长度）。  
2. **简化周期内计算**：通过`gcd(l_i, l_j)`将周期内的元素分组，每组内的元素间隔固定（比如gcd=2时，组1是位置1、3、5…，组2是位置2、4、6…）。每组的和可以预先计算，再相乘累加，就能快速得到一个周期的贡献。  
3. **求最大值**：遍历所有两两组合，计算它们的贡献，取最大值。  

**核心算法流程**：  
- 对每对序列(i,j)，计算`g = gcd(l_i, l_j)`，`L = lcm(l_i, l_j)`。  
- 将序列i和j按模g分组（比如组号为`1~g`），计算每组内元素的和（比如序列j的组s[i]是位置i、i+g、i+2g…的和）。  
- 序列i的每个元素属于某一组，将其值乘以对应组的和，累加得到一个周期的贡献。  
- 总贡献 = 周期贡献 × (k/L)，取模后更新最大值。  

**可视化设计思路**：  
用8位像素风格展示两个序列的元素（比如方块代表数值，颜色越深数值越大）。动画中会：  
- 高亮当前处理的序列对（比如i=1,j=2）。  
- 用不同颜色标记`gcd`分组（比如组1是红色，组2是蓝色）。  
- 动态计算每组和（比如红色方块的和显示在右侧）。  
- 逐步累加贡献（比如进度条显示当前周期的贡献）。  
- 最后弹出最大值的“胜利”动画（比如像素星星闪烁）。  


## 2. 精选优质题解参考

### 题解一（作者：qpdk777）  
* **点评**：这份题解的**核心亮点是严谨的数学证明**，详细推导了“分组求和”的结论（比如为什么每组内的元素间隔是gcd）。代码结构清晰，`work`函数专门处理一对序列的贡献计算，其中`s`数组存储序列j的分组和，逻辑直观。特别是对`gcd`和`lcm`的应用，完美解决了大k的问题。从实践角度看，代码的边界处理（比如`h = i % gc`的调整）非常严谨，适合作为竞赛参考。  

### 题解二（作者：bianshiyang）  
* **点评**：此题解的**思路更偏向规律总结**，通过分析`gcd`分组的性质，直接给出了“每组和相乘累加”的结论。代码非常简洁，`g`函数中的双重循环（遍历分组→计算每组和）一目了然。值得学习的是，它将序列i和j的处理合并到一个循环中，减少了代码冗余。对于初学者来说，这种“找规律→简化计算”的思维方式很有启发性。  

### 题解三（作者：JWRuixi）  
* **点评**：这份题解的**代码实现最简洁**，利用模运算直接分组（比如`i % m`），避免了多余的变量交换。`work`函数中的`swap(x,y)`确保序列x的长度更小，优化了循环次数。此外，它使用了快速读入函数（`read`），适合处理大数据量的情况。这种“简洁高效”的编码风格，是竞赛中的加分项。  


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何处理1e9级别的k？**  
* **分析**：k可以达到1e9，直接扩展序列会导致时间和空间爆炸。解决方法是**利用周期性**——扩展后的序列是原序列的重复，所以总贡献等于“一个周期的贡献”乘以“周期数”（k/L，L是lcm）。  
* 💡 **学习笔记**：大尺度问题优先考虑“周期性”，将问题缩小到一个周期内解决。  

### 2. **难点2：如何高效计算周期内的贡献？**  
* **分析**：周期长度是lcm(l_i, l_j)，如果直接遍历周期内的所有元素，时间复杂度会很高（比如l_i=1e3，l_j=1e3，lcm=1e6，n=100时总复杂度是1e10）。解决方法是**通过gcd分组**，将周期内的元素分成g组（g=gcd(l_i, l_j)），每组内的元素间隔固定，预先计算每组和，再相乘累加。这样时间复杂度降低到O(n²×max(l_i))，可以通过所有数据。  
* 💡 **学习笔记**：数论中的gcd可以帮助我们“分组”，减少重复计算。  

### 3. **难点3：如何正确分组？**  
* **分析**：分组的关键是确保序列i的第p个元素，与序列j的第q个元素在扩展后对应。通过数学推导，当且仅当p ≡ q (mod g)时，它们会在周期内对应。因此，我们可以将序列i和j按模g分组，每组内的元素会相互对应。  
* 💡 **学习笔记**：模运算可以帮助我们“归类”元素，找到它们的对应关系。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了三个题解的思路，保留了最核心的分组求和逻辑，代码简洁易懂。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <algorithm>
  using namespace std;

  const int MOD = 998244353;
  long long a[105][1005]; // 存储序列，a[i][j]表示第i个序列的第j个元素
  int l[105]; // 存储每个序列的长度
  int n;
  long long k;

  int gcd(int x, int y) {
      return y == 0 ? x : gcd(y, x % y);
  }

  int lcm(int x, int y) {
      return (long long)x * y / gcd(x, y);
  }

  long long calc(int x, int y) {
      int g = gcd(l[x], l[y]);
      int L = lcm(l[x], l[y]);
      long long sum[1005] = {0}; // 存储序列y的分组和

      // 计算序列y的分组和（每组间隔g）
      for (int i = 1; i <= l[y]; i++) {
          int group = (i - 1) % g + 1; // 组号1~g
          sum[group] = (sum[group] + a[y][i]) % MOD;
      }

      // 计算序列x的每个元素对应的分组和，累加得到周期贡献
      long long res = 0;
      for (int i = 1; i <= l[x]; i++) {
          int group = (i - 1) % g + 1;
          res = (res + a[x][i] * sum[group]) % MOD;
      }

      // 总贡献 = 周期贡献 × (k/L)
      res = res * (k / L) % MOD;
      return res;
  }

  int main() {
      cin >> n >> k;
      for (int i = 1; i <= n; i++) {
          cin >> l[i];
          for (int j = 1; j <= l[i]; j++) {
              cin >> a[i][j];
              a[i][j] %= MOD; // 提前取模，避免溢出
          }
      }

      long long ans = 0;
      for (int i = 1; i <= n; i++) {
          for (int j = i + 1; j <= n; j++) {
              long long current = calc(i, j);
              if (current > ans) {
                  ans = current;
              }
          }
      }

      cout << ans << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **输入处理**：读取n、k，以及每个序列的长度和元素（提前取模，避免溢出）。  
  2. **calc函数**：计算序列i和j的贡献，核心是分组求和。  
     - 计算`gcd`和`lcm`。  
     - 计算序列j的分组和（每组间隔g）。  
     - 遍历序列i的每个元素，乘以对应组的和，累加得到周期贡献。  
     - 总贡献 = 周期贡献 × (k/L)。  
  3. **主函数**：遍历所有两两组合，计算贡献，取最大值。  


### 题解一（qpdk777）片段赏析  
* **亮点**：严谨的分组逻辑，处理了序列长度交换的情况。  
* **核心代码片段**：  
  ```cpp
  long long work(int x, int y) {
      if (l[x] > l[y]) swap(x, y); // 确保x的长度更小
      int gc = gcd(l[x], l[y]);
      int lc = lcm(l[x], l[y]);
      long long s[1010] = {};

      // 计算序列y的分组和
      for (int i = 1; i <= gc; i++) {
          long long tmp = 0;
          for (int j = i; j <= l[y]; j += gc) {
              tmp += a[y][j];
              tmp %= MOD;
          }
          s[i] = tmp;
      }

      // 计算序列x的贡献
      long long ans = 0;
      for (int i = 1; i <= l[x]; i++) {
          int h = i % gc;
          if (h == 0) h = gc; // 调整组号为1~gc
          ans += a[x][i] * s[h] % MOD;
          ans %= MOD;
      }

      ans *= k / lc;
      ans %= MOD;
      return ans;
  }
  ```
* **代码解读**：  
  - `swap(x, y)`：确保x的长度更小，减少循环次数。  
  - `s[i]`：存储序列y的第i组和（组号1~gc）。  
  - `h = i % gc`：计算序列x的第i个元素属于哪一组（调整为1~gc）。  
* 💡 **学习笔记**：交换序列长度可以优化循环次数，是竞赛中的小技巧。  


### 题解二（bianshiyang）片段赏析  
* **亮点**：简洁的分组求和逻辑，合并了序列i和j的处理。  
* **核心代码片段**：  
  ```cpp
  ll g(int x, int y) {
      int gc = gcd(l[x], l[y]);
      int lc = lcm(l[x], l[y]);
      ll res = 0;
      for (int i = 1; i <= gc; i++) {
          ll res1 = 0, res2 = 0;
          // 计算序列x的第i组和
          for (int j = i; j <= l[x]; j += gc) res1 = (res1 + a[x][j]) % mo;
          // 计算序列y的第i组和
          for (int j = i; j <= l[y]; j += gc) res2 = (res2 + a[y][j]) % mo;
          res = (res + res1 * res2 % mo) % mo;
      }
      res = res * (k / lc) % mo;
      return res;
  }
  ```
* **代码解读**：  
  - 直接遍历每组（1~gc），计算序列x和y的每组和，相乘累加。  
  - 逻辑更直观，适合初学者理解。  
* 💡 **学习笔记**：合并处理可以减少代码冗余，提高可读性。  


### 题解三（JWRuixi）片段赏析  
* **亮点**：用模运算直接分组，代码更简洁。  
* **核心代码片段**：  
  ```cpp
  int work(int x, int y) {
      int m = __gcd(l[x], l[y]);
      long long s[1005] = {};
      if (l[x] > l[y]) swap(x, y);
      // 计算序列y的分组和（模m）
      for (int i = 1; i <= l[y]; i++) s[i % m] = (s[i % m] + a[y][i]) % mod;
      // 计算序列x的贡献
      long long res = 0;
      for (int i = 1; i <= l[x]; i++) res = (res + s[i % m] * a[x][i] % mod) % mod;
      int L = (long long)l[x] * l[y] / __gcd(l[x], l[y]);
      res = res * k / L % mod;
      return res;
  }
  ```
* **代码解读**：  
  - `i % m`：直接用模运算得到组号（0~m-1），避免了调整组号的步骤。  
  - 代码更简洁，适合快速编码。  
* 💡 **学习笔记**：模运算可以简化分组逻辑，是常用的编程技巧。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**“像素打捞者的宝藏计算”**（仿FC红白机风格）  

### 设计思路  
用8位像素风格展示两个序列的元素（比如方块代表数值，颜色越深数值越大），通过动画演示“分组求和→计算贡献→取最大值”的过程。融入游戏元素（如音效、进度条、胜利动画），增强趣味性。  

### 动画帧步骤  
1. **初始化场景**：  
   - 屏幕左侧显示两个序列的像素块（比如序列1是红色方块，序列2是蓝色方块）。  
   - 屏幕右侧显示控制面板（包括“开始”“单步”“重置”按钮，速度滑块）。  
   - 播放8位风格的背景音乐（比如轻快的电子音乐）。  

2. **选择序列对**：  
   - 用箭头指示当前处理的序列对（比如i=1,j=2）。  
   - 高亮这两个序列的像素块（比如红色和蓝色方块闪烁）。  

3. **计算gcd分组**：  
   - 显示“gcd=2”的文字提示。  
   - 用不同颜色标记分组（比如组1是黄色，组2是绿色）。  
   - 播放“叮”的音效（每个分组标记时）。  

4. **计算分组和**：  
   - 动态计算序列2的分组和（比如黄色组的和显示在右侧，数值逐渐增加）。  
   - 播放“滴”的音效（每计算一个元素的和时）。  

5. **计算周期贡献**：  
   - 遍历序列1的每个元素，乘以对应组的和，累加得到周期贡献（进度条显示当前进度）。  
   - 播放“咚”的音效（每累加一次时）。  

6. **计算总贡献**：  
   - 显示“总贡献=周期贡献×(k/L)”的文字提示。  
   - 数值从周期贡献逐渐增加到总贡献（比如从10增加到90）。  

7. **更新最大值**：  
   - 如果当前总贡献是最大值，弹出“胜利”动画（比如像素星星闪烁，播放上扬的音效）。  
   - 否则，显示“继续”提示（比如箭头指向 next 序列对）。  

### 交互设计  
- **单步执行**：点击“单步”按钮，动画执行一步（比如标记一个分组，计算一个和）。  
- **自动播放**：点击“开始”按钮，动画自动执行，速度可通过滑块调整（比如慢、中、快）。  
- **重置**：点击“重置”按钮，回到初始状态，重新选择序列对。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
本题的**核心思路**（周期性优化+gcd分组）可以应用于以下场景：  
1. **重复序列的乘积和**：比如两个序列重复多次，计算对应位置的乘积和。  
2. **周期函数的卷积**：比如两个周期函数的卷积，可以通过gcd分组简化计算。  
3. **大数据量的模运算**：比如需要计算1e9次操作的模结果，可以通过周期性减少计算量。  

### 洛谷练习推荐  
1. **洛谷 P1072 扩展欧几里得**  
   - 🗣️ **推荐理由**：这道题考察了欧几里得算法的扩展，有助于巩固gcd的理解。  
2. **洛谷 P1890 gcd求和**  
   - 🗣️ **推荐理由**：这道题需要计算多个数的gcd和，有助于练习gcd的应用。  
3. **洛谷 P2158 周期问题**  
   - 🗣️ **推荐理由**：这道题考察了周期性的识别和应用，与本题的核心思路一致。  


## 7. 学习心得与经验分享 (若有)  
本次分析的题解中未发现明确的作者个人心得分享部分，但从代码中可以看出：  
- **提前取模**：避免溢出是竞赛中的重要技巧（比如题解中的`a[i][j] %= MOD`）。  
- **变量命名**：清晰的变量名（比如`sum`表示分组和，`res`表示结果）有助于提高代码可读性。  
- **边界处理**：比如`h = i % gc`的调整（题解一），确保组号正确，是避免bug的关键。  


## 结语  
本次关于“打捞”问题的分析，我们学习了**用数论简化大尺度计算**的思路，掌握了gcd、lcm的应用，以及周期性优化的技巧。希望这份指南能帮助你更好地理解这类问题，下次遇到类似的题目时，能快速想到“找周期→分组求和”的解决方法。记住，编程的乐趣在于用智慧解决问题，加油！💪

---
处理用时：162.07秒